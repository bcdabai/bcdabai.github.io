<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1d2b10c950f50f9fbf7078db4e215b5/" rel="bookmark">
			Linux内核查看配置文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一般是/boot/config-(内核名)，如果没有可以查看proc/config.gz，前提是内核打开CONFIG_IKCONFIG_PROC配置。如下图所示： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4006a1f5b01f444ae1c8ae20207fa218/" rel="bookmark">
			使用 Nginx Ingress 快速实现 URL 重写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是URL重写 URL重写（URL rewriting）是一种在Web服务器上修改或转换请求URL的过程。它通常涉及使用服务器配置或规则来更改传入的URL，以便在不改变实际请求资源的情况下，实现不同的行为，如重定向、路径映射、参数处理等。
URL重写在服务器层面进行，因此客户端（如浏览器）对于URL的请求不会感知到这些更改，但服务器会根据配置进行适当的处理。URL重写可以用于多种目的，例如：
重定向: 将一个URL重写为另一个URL，实现301永久重定向或302临时重定向。这可以用于更改站点结构、修复错误的URL、实现SEO优化等。
路径映射: 将一个URL的路径映射到另一个位置，这对于隐藏实际文件路径或路径重组很有用。
查询参数处理: 在URL中添加、删除或修改查询参数，以适应不同的应用需求。
动态URL到静态URL: 将动态生成的URL（带有参数）转化为静态URL，更友好且易于索引。
隐藏技术细节: 可以通过URL重写隐藏后端服务器或应用程序的实际技术细节，提高安全性。
在Nginx、Apache等常见的Web服务器中，URL重写可以通过正则表达式、规则匹配等方式来实现。具体的语法和方法会因服务器软件的不同而有所不同。通常，服务器配置文件中会有专门的部分用于配置URL重写规则，例如在Nginx中是使用rewrite指令。URL重写是一种强大的技术，但在使用时需要小心，确保配置正确以避免潜在的问题，例如无限循环重定向或错误的重写规则可能导致网站不可用。
Ingress 内置变量 内置预定义变量即无需声明就可以使用的变量，通常包括一个http请求或响应中一部分内容的值，以下为一些常用的内置预定义变量：
变量名 定义
$arg_PARAMETER GET请求中变量名PARAMETER参数的值。
$args 这个变量等于GET请求中的参数。例如，foo=123&amp;bar=blahblah;这个变量只可以被修改
$binary_remote_addr 二进制码形式的客户端地址。
$body_bytes_sent 传送页面的字节数
$content_length 请求头中的Content-length字段。
$content_type 请求头中的Content-Type字段。
$cookie_COOKIE cookie COOKIE的值。
$document_root 当前请求在root指令中指定的值。
$document_uri 与$uri相同。
$host 请求中的主机头(Host)字段，如果请求中的主机头不可用或者空，则为处理请求的server名称(处理请求的server的server_name指令的值)。值为小写，不包含端口。
$hostname 机器名使用 gethostname系统调用的值
$http_HEADER HTTP请求头中的内容，HEADER为HTTP请求中的内容转为小写，-变为_(破折号变为下划线)，例如：$http_user_agent(Uaer-Agent的值);
$http_user_agent ： 客户端agent信息;
$http_cookie ： 客户端cookie信息;
$sent_http_HEADER HTTP响应头中的内容，HEADER为HTTP响应中的内容转为小写，-变为_(破折号变为下划线)，例如： $sent_http_cache_control, $sent_http_content_type…;
$is_args 如果$args设置，值为"?"，否则为""。
$limit_rate 这个变量可以限制连接速率。
$nginx_version 当前运行的nginx版本号。
$query_string 与$args相同。
$remote_addr 客户端的IP地址。
$remote_port 客户端的端口。
$remote_user 已经经过Auth Basic Module验证的用户名。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4006a1f5b01f444ae1c8ae20207fa218/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e57872f2e327d4d61a039b2398cd651/" rel="bookmark">
			微信小程序的几种常见的样式写法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、微信小程序样式默认写法 默认写法就是直接用class类选择器的方法，在WXSS中直接用“.”+class类来定位渲染
微信小程序中使用class选择器可以使用".class-name"（class类名可以随意取，但是未来便于阅读代码一般使用英语单词）的形式来定义样式。在wxml文件中，可以给需要添加样式的组件添加class属性，例如：
&lt;view class="container"&gt;&lt;/view&gt; 在对应的wxss文件中，可以使用以下方式定义.container的样式：
.container { background-color: #fff; border: 1px solid #ddd; padding: 10rpx; } 二、样式直接在WXML组件里面编辑 这种方法就不用到WXSS文件中写，但是原理都是一样的
三、外部定义然后引用 在微信小程序和pages包同级位置创建Css（名字可以自取）文件（可以在微信小程序中建也可以找到小程序文件包在电脑中的位置再在pages同级位置建），然后在这个目录下新建一个文件命名为my.wxss，然后在这个文件中编写css代码.
我们在my.wxss中编写
.test1{ color: brown; } 然后在需要引入的页面的WXSS文件中写入以下代码
@import'/mywxss/myCSS.wxss' 将需要渲染的模块的class类设置为和my.wxss中的class类名对应
&lt;view&gt; &lt;text class="test1"&gt;这是一段文字&lt;/text&gt; &lt;/view&gt; 运行即可引用成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50cde037e24895f1772c54dbd7ad3ff3/" rel="bookmark">
			Zabbix 6 详细安装部署教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、安装 MySQL 数据库
二、安装 zabbix 监控平台
三、编辑配置文件 四、启动服务 五、zabbix-web 安装
zabbix web 出图展示乱码问题解决方案 zabbix 的安装部署非常简单，官方提供了四种安装途径，分别是二进制 rpm 包安装方式、源码安装方式、容器安装方式和虚拟机镜像安装方式。本次使用 dnf 在线进行安装的方式。
Zabbix web 端是基于 HTTP 服务器和 PHP 脚本语言进行构建的，HTTP 服务器可以是 nginx或 apache，zabbix 的数据存储支持多种数据库，可以是 MySQL、Oracle、PostgreSQL、SQLite等，这里我们选择 MySQL 数据库作为后端存储。
虚拟机安装环境介绍：
操作系统：Centos 8 Stream数据库：MySQL 8.0.32Zabbix：Zabbix 6.4 注意：Centos 7 及以下版本不支持 yum 在线安装 zabbix 6 的 web 服务了（zabbix-nginx-conf），只能手动部署 Nginx 和 PHP，所以为了方便快捷本次使用 Centos 8 及以上版本部署 Zabbix 6.4 一、安装 MySQL 数据库 这里使用目前 MySQL 8.0.32 版本（下载地址：MySQL :: Download MySQL Community Server (Archived Versions)），采用 MySQL 官方发布的二进制版本进行安装，下载后的二进制版本名称大致为 mysql-8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50cde037e24895f1772c54dbd7ad3ff3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c85300faad050c85afbf3e76e1cff5c/" rel="bookmark">
			doris on k8s 的安装部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方已更新Operator部署方式，最新部署方式参考 官方文档
1. 按照官网提供地址下载部署文件 2. 修改内核配置 sysctl -w vm.max_map_count=2000000 3. 根据服务器环境，修改doris_be.yml文件。 # Licensed to the Apache Software Foundation (ASF) under one # or more contributor license agreements. See the NOTICE file # distributed with this work for additional information # regarding copyright ownership. The ASF licenses this file # to you under the Apache License, Version 2.0 (the # "License"); you may not use this file except in compliance # with the License.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c85300faad050c85afbf3e76e1cff5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa1616752894395ff1262d96f9aef33c/" rel="bookmark">
			【FPGAUP】之关于Aurora的几个功能实现的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个QUAD中的4个通道绑定到一共IP核中是否可行？ 可行但不能实现预想目的。
GTP可以将一个QUAD的4个串行高速通道“GTPE2_CHANNEL”绑定到一个核中，如下图，且收发独立接口。
Aurora也可以实现4通道绑定一个核中，如下图IP核的配置
但4个通道无法独立进行读写操作，如下图4通道在核内部会合并成在一起发出。
这时如果有些光口没有通讯，会报channel_up，而且合成一个多bit数也不好拆开来用，故认为不可行
AURORA主从模式是否可以单个独立使用且互不影响？ 可以
所谓的主从模式其实主要就是一个QUAD的“GTPE2_COMMON”这个PLL是否共享，如果共享，从模式的核则不包括该硬核，由主模式的核提供串行时钟、并行时钟以及相关复位信号。如果我们对“GTPE2_COMMON”复位则会导致主从核都进行复位，如果我们只对每个通道的“GTPE2_CHANNEL”复位，则不会影响其它核的正常运行。而且AURORA也提供了该复位接口。
AURORA是否可以实现线速率的动态配置？ 目前认为可以实现，但还需要实际的测试。
如上图是GTP的逻辑架构，从中可以看出，要想改变时钟频率，或是改变“GTPE2_COMMON”（QPLL）硬核的PLL输出时钟，或者改变“GTPE2_CHANNEL”D分频器。其中QPLL有两个PLL，即PLL0和PLL1，但每个PLL只能产生一路串行时钟和并行时钟提供到“GTPE2_COMMON”。
如果是改变“GTPE2_COMMON”硬核的PLL则会改变该QUAD的所有通道的速率，这样有违初衷，
如果另每个改变“GTPE2_CHANNEL”D分频器，则会有限制，例如最高4G/s，只能调整为2G/s，而不能调整到2.5G/s的线速率。如下图所示
之前张月在主控板实现过两个光口不同速率的方法，是可行的，在此基础上可以做如下尝试：
GTP有一个功能，即支持“东西QPLL”的共享，也就是水平相邻两个BANK的“GTPE2_COMMON”共享，每个QPLL提供两个PLL，这样就有4个时钟，每个通道可以选择不同的时钟，并通过D分频器的配合，应该可以满足速率要求。
实现方式就是每个BANK的QPLL拿到外面，配置成不同的四个时钟频率，将AURORA配置成不含共享逻辑的模式。这样每个通道可以选择不同的时钟。
另外，如果使用GTX的话，则可以轻松实现上述功能，如下是GTX的时钟架构图，每个“GTPE2_CHANNEL”均有一个CPLL，CPLL支持线速率是1.6GHz到3.3GHZ之间。
欢迎关注 FPGAUP网--专注打造FPGA知识平台 https://fpgaup.com/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/958ec895dd08340f87fee64c39083e34/" rel="bookmark">
			Ubuntu上安装、使用Redis的详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章简单地介绍一下怎么在linux虚拟机上完成redis的安装及使用。
目录
1、安装redis
2、使用redis
3、启动/关闭redis
启动redis
启动方式一
启动方式二
启动方式三
重启redis
关闭redis
查看redis状态
4、在宿主机连接redis
5、通过java连接redis
创建maven项目
添加jedis的依赖
jedis的案例代码
关闭保护模式
重新运行代码
1、安装redis 首先，访问Redis官网，点击首页的【Get Started】，然后点击Install Redis on Linux
然后按照页面内容提示，在Ubuntu上安装redis
只需要在终端依次输入以下命令，如果过程中没有错误提示，则redis安装完成。
sudo apt install lsb-release curl gpg curl -fsSL https://packages.redis.io/gpg | sudo gpg --dearmor -o /usr/share/keyrings/redis-archive-keyring.gpg echo "deb [signed-by=/usr/share/keyrings/redis-archive-keyring.gpg] https://packages.redis.io/deb $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/redis.list sudo apt-get update sudo apt-get install redis 2、使用redis 在终端输入redis-cli，会进入到redis的命令行模式，这时候就可以愉快地使用redis的各种命令了。
输入exit退出redis-cli。
3、启动/关闭redis 启动redis 启动方式一 /etc/init.d/redis-server start 启动方式二 systemctl start redis-server 启动方式三 service redis-server start 重启redis service redis-server restart 关闭redis service redis-server stop 查看redis状态 service redis-server status 4、在宿主机连接redis 根据以上步骤安装启动redis后，默认只能在虚拟机内访问redis，如果在其他机器上访问，需要修改配置文件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/958ec895dd08340f87fee64c39083e34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1236bde01cbefd0f5d27b20fa9532f09/" rel="bookmark">
			spark部署及提交任务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.spark部署模式 1.1 Local模式 Local模式就是运行在一台计算机上的模式，通常就是用于在本机上练手和测试。它可以通过以下集中方式设置master。
local: 所有计算都运行在一个线程当中，没有任何并行计算，通常我们在本机执行一些测试代码，或者练手，就用这种模式。local[K]: 指定使用几个线程来运行计算，比如local[4]就是运行4个worker线程。通常我们的cpu有几个core，就指定几个线程，最大化利用cpu的计算能力local[*]: 这种模式直接帮你按照cpu最多cores来设置线程数了。 /bin/spark-submit \ --cluster cluster_name \ --master local[*] \ ... 这几种local模式都是运行在本地的单机版模式，通常用于练手和测试，而实际的大规模计算就需要下面要介绍的cluster模式。
1.2 cluster模式 cluster模式肯定就是运行很多机器上了，但是它又分为以下三种模式，区别在于谁去管理资源调度。（说白了，就好像后勤管家，哪里需要资源，后勤管家要负责调度这些资源）
1.2.1 standalone模式 这种模式下，Spark会自己负责资源的管理调度。它将cluster中的机器分为master机器和worker机器，master通常就一个，可以简单的理解为那个后勤管家，worker就是负责干计算任务活的苦劳力。具体怎么配置可以参考Spark Standalone Mode
使用standalone模式示例：
/bin/spark-submit \ --cluster cluster_name \ --master spark://host:port \ ... --master就是指定master那台机器的地址和端口，我想这也正是--master参数名称的由来吧。
1.2.2 mesos模式 这里就很好理解了，如果使用mesos来管理资源调度，自然就应该用mesos模式了，示例如下：
/bin/spark-submit \ --cluster cluster_name \ --master mesos://host:port \ ... 1.2.3 yarn模式 同样，如果采用yarn来管理资源调度，就应该用yarn模式，由于很多时候我们需要和mapreduce使用同一个集群，所以都采用Yarn来管理资源调度，这也是生产环境大多采用yarn模式的原因。yarn模式又分为yarn cluster模式和yarn client模式：
yarn cluster: 这个就是生产环境常用的模式，所有的资源调度和计算都在集群环境上运行，客户端只负责提交应用程序。Driver 运行在Application Master中， 当用户提交了作业之后，就可以关于关闭Client，作业会继续在YARN上运行， 因而YARN-cluster模式不适合进行交互式类型的作业yarn client: Spark Driver在本机运行，而计算任务在cluster上。可以使Spark Application和客户端进行交互。Application Master仅仅向YARN请求Executor，Client会和请求的Container的通信来调度它们工作，Client是不能离开的 YARN的两种运行模式_夏末的初雪的博客-CSDN博客_yarn模式
2.提交任务 spark-submit \ --master yarn \ --queue test_queue \ --deploy-mode client \ --driver-memory 10g \ --executor-cores 2 \ --executor-memory 1G \ --num-executors 8 \ --class com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1236bde01cbefd0f5d27b20fa9532f09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad334ee50fd21dd2efbd8e83710df915/" rel="bookmark">
			002-getopt_long()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1-代码及注释 这个例程是man手册里的。
1-1 getopt_long.c #include &lt;stdio.h&gt; /* for printf */ #include &lt;stdlib.h&gt; /* for exit */ #include &lt;getopt.h&gt; /* man 3 getopt_long 函数原型： int getopt_long(int argc, char * const argv[], const char *optstring, const struct option *longopts, int *longindex); */ int main(int argc, char **argv) { int c;//c在下面作为getopt_long（）的返回值 int digit_optind = 0; while (1) { int this_option_optind = optind ? optind : 1; int option_index = 0; static struct option long_options[] = { {"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad334ee50fd21dd2efbd8e83710df915/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d404ddceeca77c3f4b7c72739fa6b07/" rel="bookmark">
			001-调用函数访问结构体数组成员，并修改其数值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 代码 /* 调用函数访问结构体数组成员，并修改其数值 */ #include &lt;stdio.h&gt; /* for printf */ #include &lt;stdlib.h&gt; /* for exit */ struct mytest{ char a ; char b ; char c ; }; void p_find_test(struct mytest *aaa) { struct mytest *test = aaa+1; test-&gt;a = 6; test-&gt;b = 7; test-&gt;c = 8; } int main(void) { struct mytest test01[3]; test01[1].a=2; test01[1].b=2; test01[1].c=2; printf("a: %d\n",test01[1].a); printf("b: %d\n",test01[1].b); printf("c: %d\n",test01[1].c); p_find_test(test01); printf("a: %d\n",test01[1].a); printf("b: %d\n",test01[1].b); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d404ddceeca77c3f4b7c72739fa6b07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fa02238e88a26751837fd8a8169f5bf/" rel="bookmark">
			FreeRTOS任务创建及细节
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
任务创建 简化的TCB结构体
创建任务堆栈和任务TCB
初始化任务TCB的成员
初始化任务堆栈
把新任务添加到就绪列表
任务删除
任务创建 BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode, const char * const pcName,	/*lint !e971 Unqualified char types are allowed for strings and single characters only. */ const configSTACK_DEPTH_TYPE usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask ) 这个API函数的作用是创建新的任务并将它加入到任务就绪列表，函数参数含义为：
pvTaskCode：函数指针，指向任务函数的入口。任务永远不会返回（位于死循环内）。该参数类型TaskFunction_t定义在文件projdefs.h中，定义为：typedef void(*TaskFunction_t)( void * )，即参数为空指针类型并返回空类型。pcName：任务描述。主要用于调试。字符串的最大长度（包括字符串结束字符）由宏configMAX_TASK_NAME_LEN指定，该宏位于FreeRTOSConfig.h文件中。usStackDepth：指定任务堆栈大小，能够支持的堆栈变量数量（堆栈深度），而不是字节数。比如，在16位宽度的堆栈下，usStackDepth定义为100，则实际使用200字节堆栈存储空间。堆栈的宽度乘以深度必须不超过size_t类型所能表示的最大值。比如，size_t为16位，则可以表示堆栈的最大值是65535字节。这是因为堆栈在申请时是以字节为单位的，申请的字节数就是堆栈宽度乘以深度，如果这个乘积超出size_t所表示的范围，就会溢出，分配的堆栈空间也不是我们想要的。pvParameters：指针，当任务创建时，作为一个参数传递给任务。uxPriority：任务的优先级。具有MPU支持的系统，可以通过置位优先级参数的portPRIVILEGE_BIT位，随意的在特权（系统）模式下创建任务。比如，创建一个优先级为2的特权任务，参数uxPriority可以设置为 ( 2 | portPRIVILEGE_BIT )。pvCreatedTask：用于回传一个句柄（ID），创建任务后可以使用这个句柄引用任务。
虽然xTaskCreate()看上去很像函数，但其实是一个宏，真正被调用的函数是xTaskGenericCreate()，xTaskCreate()宏定义如下所示：
#define xTaskCreate( pvTaskCode, pcName, usStackDepth,pvParameters, uxPriority, pxCreatedTask ) \ xTaskGenericCreate( ( pvTaskCode ),( pcName ), ( usStackDepth ), ( pvParameters ), ( uxPriority ), ( pxCreatedTask), ( NULL ), ( NULL ), ( NULL ) ) 可以看到,xTaskCreate比xTaskGenericCreate少了三个参数，在宏定义中，这三个参数被设置为NULL。这三个参数用于使用静态变量的方法分配堆栈、任务TCB空间以及设置MPU相关的参数。一般情况下，这三个参数是不使用的，所以任务创建宏xTaskCreate定义的时候，将这三个参数对用户隐藏了。接下来的章节中，为了方便，我们还是称xTaskCreate()为函数，虽然它是一个宏定义。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fa02238e88a26751837fd8a8169f5bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac9683c6dbb540ee412cfdda881aec13/" rel="bookmark">
			一文带你读懂PyQt：用Python做出与C&#43;&#43;一样的GUI界面应用程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简介 Python标准库更多的适合处理后台任务，唯一的图形库tkinter使用起来很不方便，所以后来出现了针对Python图形界面开发的扩展库，今天老猿要介绍的是主流Python图形界面扩展库之一的PyQt。
在介绍PyQt之前，必须先简单介绍一下Qt。Qt是一个C++可视化开发平台，是一个跨平台的C++图形用户界面应用程序框架（C++ GUI），能够为应用程序开发者提供建立图形用户界面所需的功能。Qt是完全面向对象的、易扩展，可应用于组件编程，并可以用于嵌入式开发。它是目前流行的Linux桌面环境KDE 的基础，是Linux和嵌入式操作系统下的主流图形界面开发环境，其最大优势在于只需编写一次代码，就能编译部署在任何操作系统和硬件上。因为擅长图形界面开发，如今更扩展到移动及嵌入式设备开发。对于商业软件公司来说极具价值，可以广泛应用于物联网特别是智能汽车、智能制造业等的研发。
PyQt是一个创建Python GUI应用程序的工具包，是Qt和Python结合的一个产物，可以说是为了将Qt的功能用于Python开发的一个Qt的Python包装器。它是Python编程语言和Qt库的成功融合。
PyQt的整个程序开发框架，老猿认为主要包括如下部分：
图形界面编辑的工具：Qt Designer不同部分信息交换机制：信号和槽界面操作的事件及捕获机制一套控制界面显示和数据存储分离以及映射的机制：Model/View架构 通过这些重要的工具和框架机制，开发人员可以设计对应的GUI图形化界面、定义不同部件的操作及响应、捕获部件或应用的消息以及实现界面显示组件和数据存储组件的联动，从而构造完整的应用程序框架。
二、Qt Designer：PyQt图形化界面开发的利器 Qt Designer是一个可视化的界面设计工具，可以通过拖拽等方式来设计界面。下面就是Qt Designer的操作界面：
老猿将界面各部分使用红色数字进行标记，按照数字顺序各区域对应功能分别为：
1、界面元素控件区域 这部分提供了Qt所有可视化控件，分为八大类，分别为布局控件（Layouts）、分隔控件（Spacers）、按钮控件（Buttons）、表项视图（item views）、表项组件（item widgets）、容器（Containers）、输入组件（input widgets）、显示组件（Display widgets），在新建窗口后，可以将各种功能的组件拖拽到窗口上实现可视化的界面设计。
2、菜单及工具栏 本部分是各种操作菜单和对应的工具栏。其中：
File菜单用来新建、打开、打开最近、保存界面的UI文件。
Edit菜单可以编辑界面控件、控件属性、信号/槽连接、控件Tab顺序、标签和其他控件的伙伴关系等
Form菜单用来编辑当前窗口的布局、大小，预览窗口等。
View菜单就是看整体界面哪些区域展示出来，即本文中除UI设计工作区的区域哪些展现在界面上；
window菜单就是当前UI设计窗口的切换。
3、UI设计工作区 所有UI设计的工作区，工作区构建的UI作为设计成果保存。
4、组件属性定义区 这块完成组件各个属性的设置，属性是按组件的类、父类的方式展现的，由于属性太多单页没有展现完，上面截图没能体现这点，如果把这些属性的父节点折叠起来，就可以很清晰的看到这个关系，下图就是输入控件的根节点折叠后展示的情况：
可以看到，除了控件自身的QLineEdit类外，还有父类QWidget、QObject，在这个截图中，这三个是按父类在前、子类在后的顺序展现的，据老猿观察大部分情况都是这样的，但某些特殊情况可能不是这样的。如下图：
上图中QTreeView控件及其之上的节点都是按父子继承关系展示的，但下面多了个Header。
通过这些展示信息，我们可以清楚知道哪些属性是从哪个类带来的。
5、信号/槽编辑区 信号和槽是Qt最有特色的内容，具体在后面介绍，在这里可以编辑信号和槽函数的连接关系，但直接按F4进入信号和槽函数连接的界面更方便。
6、动作编辑区 动作Action是Qt抽象的用户界面操作，Qt中单独引入的一个对象，对应QAction类。Action表示一个独立的操作，是将界面上某个可以通过菜单、快捷键、toolBar按钮执行的同一个操作映射到同一个Action对象，由该对象通过信号触发实际的操作。
三、PyQt三大框架机制之信号和槽 信号和槽是PyQt和Qt特有的信息传输机制，是PyQt和Qt设计程序的重要基础，它可以让互不干扰的对象建立一种联系。
信号和槽用于对象间的通信，在一个图形界面程序中，当一个组件中发生变化时，通常需要通知其他对象，在Qt中当特定事件发生时会发射一个信号来通知需要通知的对象，需要关注的对象就会调用信号连接的槽函数执行响应操作。信号本质上是一个公有函数（或方法）。
槽可以用来接收信号，但槽也是部件派生类的正常成员函数，槽本质上是某个类的方法（包括虚方法），用来调用以响应特定信号，非虚函数的槽函数也可以正常调用，与普通实例的唯一的区别是信号可以连接到它们。
四、PyQt三大框架机制之事件机制 PyQt的图形界面应用中，事件处理类似于Windows系统的消息处理。一个带图形界面的应用程序启动后，事件处理（如鼠标事件处理、键盘事件处理等）就是应用的主循环，事件处理负责接收事件、分发事件、接收应用处理事件的返回结果，在程序中捕获应用关注的事件触发相关事件处理是良好UI开发的必经之路。
PyQt中的事件分为应用层级的事件、部件级的事件，所有事件都可以捕获和过滤，从而影响事件的处理结果。
五、PyQt三大框架机制之Model/View架构 在PyQt和Qt中，Model/View架构是图形界面开发时用于管理数据和界面展现方式的关系。由该体系架构引入的功能分离使得开发人员能够更灵活地定制展现数据项的呈现方式，并提供标准模型接口支持广泛的数据源与预定义好的项视图（item views）一起使用。
老猿理解Model/View就是Model提供数据访问，View进行数据呈现，二者可以绑定实现联动，但界面呈现的风格与数据本身无关。
六、一些老猿使用PyQt做的界面化的案例 老猿是个没有艺术细胞的人，做的GUI界面说实在的很丑陋，但并不是说PyQt做不出炫酷的界面，恰恰相反，Qt或PyQt都能做出漂亮的界面。
下面是为了说明PyQt多种风格界面的一些老猿做的界面，仅用于说明PyQt能支持的界面风格类型：
listView用于文件目录显示
用QTableView展示Excel文件
用QTreeWidget显示目录文件信息
用QTableWidget操作表格
用QTabWidget选项窗显示不同操作页
用QToolBox构建的桌面工具箱
用QStackedWidget构建的堆叠窗口展示多张图片
QMdiArea多文档界面部件一次展示多张图片
QDockWidget停靠窗(停靠窗请见底部窗口切换选项卡）
用主窗口QMainWindow实现的一个消除视频Logo的工具
以上案例的界面设计做得很Low，并不是PyQt的界面设计功能把不行，相信有艺术细胞的人来设计，可以比老猿做的界面漂亮一万倍。 七、小结 本文介绍了Python的图形化界面应用开发工具PyQt的功能和开发框架，通过PyQt的这些重要的工具、功能和框架机制，开发人员可以设计对应的GUI图形化界面、定义不同部件的操作及响应、捕获部件或应用的消息以及实现界面显示组件和数据存储组件的联动，从而构造完整的应用程序框架，最后提供了老猿实现的一些PyQt开发程序的界面来说明PyQt不同部件的界面风格。
通过以上内容的介绍，有助于对PyQt或Qt不了解的初学者提了解PyQt的基本开发框架、应用界面风格。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac9683c6dbb540ee412cfdda881aec13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81b67b0ce85cb1f1f0751fb4e36837b0/" rel="bookmark">
			C&#43;&#43; 泛型编程，函数模版和类模版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.泛型编程 泛型编程：编写与类型无关的通用代码，是代码复用的一种手段。模板是泛型编程的基础 就比如说活字印刷术，就是提供一个模具，然后根据模具来印刷出不同的字。
泛型编程跟着类似，提供一个模版，根据这个模版由编译器自动生成不同的函数或者类
2.函数模版 2.1为什么要有函数模版 在c语言中，我们想交换两个整数、交换两个浮点数、交换自定义类型类型，我们必须自己手动写n个函数！！！并且每个函数的函数名都不一样！！！
void SwapInt(int&amp; a,int&amp; b) { int c = a; a = b; b = c; } void SwapDouble(double&amp; a, double&amp; b) { double c = a; a = b; b = c; } int main() { int a1 = 1, b1 = 2; SwapInt(a1, b1); cout &lt;&lt; a1 &lt;&lt; " " &lt;&lt; b1 &lt;&lt; endl; double a2 = 1.1, b2 = 2.2; SwapDouble(a2, b2); cout &lt;&lt; a2 &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81b67b0ce85cb1f1f0751fb4e36837b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4ef9c7598675fbdd074cf4a4d6a0c66/" rel="bookmark">
			快速入门ESP32——开发环境配置Arduino IDE
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ESP32开发环境配置——Arduino IDE 前言一、ESP32有几种开发环境？二、Arduino IDE环境搭建1.下载安装2.配置环境1）方法一1）方法二 3.验证 三、注意事项总结 前言 最近这段时间刚好在捣鼓ESP32，遇到了挺多大大小小的坑，所以我将自己的配置过程和注意要点写出来分享给大家，希望对你们有帮助。
一、ESP32有几种开发环境？ ESP32系列单片机可以用MicroPython和C++进行编程，在这里我主要介绍C++编程语言下的两种常用的开发环境：
Arduino IDE：Arduino 相信很多玩过Arduino系列单片机的朋友都不会，有点像STM32用到的Keil，但是相比Keil多了Arduino 提供了大量的内置库和扩展库，涵盖了各种传感器、执行器和通信模块等组件。这些库可以简化编程过程，减少开发时间，可以非常方便我们的上手。
VSCode + PlatformIO： PlatformIO是一个开源的IoT开发生态系统，支持多种硬件平台。它集成了多种开发框架，包括Arduino和ESP-IDF。配合上VSCode的高扩展性和个性化定制这就获得了许多开发者的青睐，这也是笔者比较推荐的一种开发方式。
二、Arduino IDE环境搭建 1.下载安装 官网下载arduino ide 2.配置环境 1）方法一 打开之后我们需要配置一下ESP开发板管理器地址，arduino 才能搜索到esp32的配置包
https://dl.espressif.com/dl/package_esp32_index.json
https://raw.githubusercontent.com/espressif/arduino-esp32/gh-pages/package_esp32_index.json
在开发板管理器搜索安装ESP32开发板（我这里下载的是Arduino架构下的）
由于国内网络的原因，这样下载会特别慢，而且时不时会报错，所以这种方法比较慢一点
1）方法二 直接安装我提供的ESP开发板安装包（文章后面会给出链接）
点击他自己会安装
安装完后，重启arduino ，就会看到有esp32的开发板了
3.验证 在示例程序中选择个简单的程序来试试
编译烧录
打开串口监视，查看结果
在下面就可以看到串口打印的信息，这就说明我们的环境搭建正常了
三、注意事项 要是烧录不了，就看一下设备管理器上的串口上跟开发板上的是不是对的上，一般来说Arduino会自己识别设备的串口
要在设备管理器中没有发现串口设备，那可能是电脑没安装串口驱动文件，点击默认安装就行
代码能烧录进去，但是没打印或者打印乱码，那可能是波特率没设置好
总结 笔者也是小白一枚，有不对的地方还请大家指出来。文章中所涉及到资料我都整理好放在我的个人公众号，欢迎各位新老朋友微信关注我的个人公众号乐天小白，回复ESP32即可获得。里面也会不定期更新各种干货，有最新的科技咨询和前沿的科技知识分享，还有Linux、嵌入式和单片机相关的干货知识。
视频链接
快速入门ESP32
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/000d342fbbcca3c514532a43d69833fd/" rel="bookmark">
			【LeetCode】128. 最长连续序列——哈希的应用(3)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、思路2、解题方法3、复杂度时间复杂度:空间复杂度: 4、Code Problem: 128. 最长连续序列
1、思路 我会用一种做题者的思路来去看待这道题。
我们在乍一看到这道题的时候，看到它的时间复杂度要求为O(N)，然后又要求去找序列(就是让你判断这个数的前面一个数在不在这个数组里，这个数的后面一个数在不在数组里）。按照我们平时暴力的做法(也是最先想到的做法)，遍历一个O(N)，然后判断每个元素在不在又是O(N)，然后有可能会有N个元素，这样N* N *N最坏的情况就都有可能是O(N^3)了。要我们找序列，又要我们O(N)，这不扯淡么。
因为所谓O(N)的复杂度，就是要让你一遍过，或者你能说出来几遍过(也即常数个O(N)，即O(kN)，k为常数)，所以，我们说要你说常数遍过就有些扯淡了。
这个时候，我们就可以想到用时间换空间的思想。 并且，用哈希表的存储这样一个空间，来换遍历查找的时间，是一个非常暴力且不要脸的做法(但是并不妨碍我说这种做法好哈哈哈哈)。说它不要脸，是因为它简单易行。
什么意思？简单举个例子：假如有个数组，你要找比某个元素大1(或者小1)的元素在不在该数组里面，按照最粗暴的方法，那么你需要遍历整个数组，也就是O(N)的时间复杂度。但是如果你用哈希的话，那就变成O(1)啦！
那么，现在对于数组内的每一个元素，我都要去找比它小1的元素在不在该数组里，如果按照原来的方法，我需要O(N*2)的时间复杂度。但是如果我用了哈希表，我就一下子变成了O(N)了。
没用什么多难的思想（即没有怎么多人为的操作，参见DP的某些题目），但是就轻轻松松完成了复杂度由时间向空间的转化。所以说，它很不要脸哈哈哈哈哈。
我们就是用这样一个核心的思想来去做这道题。
2、解题方法 在一开始拿到这道题，并且明确了哈希表有这样一个功能之后，最先想到的，是用unordered_map这样一个结构。因为不是要O(N)嘛，我是用哈希来去降了一次，但是我似乎遍历一遍数组需要O(N)，但还需要去递归地去找 比每个元素小1的、小2的、小3的…小n的 在不在里面，这不是还是有个O(N)吗，然后合在一块不还是O(N^2)？
然后我想着，前面的第一次O(N)是不可避免的（因为你总要遍历整个数组嘛）。但是后面的那个O(N)，可不可以用unordered_map里的 &lt;key, value&gt;来去标记我每个元素有没有遍历过呢？如果说，我在某次找比某个元素小1的、小2的…小n的时候遍历过了，那么我在第一个遍历数组的那个O(N)循环里就不需要再去遍历它了，但是这就有可能造成新的问题，就是我怎么知道谁是最长的呢？比如对于样例：
[100, 4, 200, 1, 3, 2, 5] 如果在外层第一层循环遍历到4的时候，我依靠哈希在内层找到了后面的1，2，3，并且标记它们已经被遍历过。那后面第一层循环再遍历到数组1，2，3的时候就直接跳过。但是如果我后面的5来了，我该怎么办呢？而且我这个时候4已经遍历过了。
如果大家能够明白我上面想表达的意思了，那么大家可以先不着急往下看，自己想一想该如何做。
其实做法有很多啦。在这里呢，就说两种。
1.是采用计数的方法。我们刚刚不是用了unordered_map嘛，那就可以在value中来去存储长度的相关信息。这样，在5来了之后，将它现在已有的长度加上4中的value中存储的长度，作为5的长度来使用。
2.这个做法就更加简单粗暴了。就是如果这个数不是边界，就别理它，只有当它是边界的时候我们再去给它计数。什么意思呢？就是说，假如我们在内循环中，往比每个数小的那个方向去找（就是对于每个元素，我们统一找比它小1的、小2的、小3的…，而不是大1的，大2的，大3的…），那么如果我们能在该数组中找到有比它大1的元素存在，我们就直接跳过它，就不理它。直到我们在数组中不能够找到有比它大的元素存在，说明它就是边界了，这时我们才开始计数。
这里笔者就对第二种思路进行展开分析了哈。可以确立以下思路：
1)先把数组中所有的数都放到哈希表里面，直接放。
2)然后用几个 if 和 else 就搞定了
然后，对于数组的每一个元素，如果它的value值不是false（一开始初始化的时候都是true），\ 判断每个数比它大1的和比它小1的是否在里面 if 比它大1: if 它的比它大1没有在这数组里面(也就是不存在): then 它是最后一个元素 从它开始计数;再开始判断比它小1的数是否存在 【 if 比它小1的数在这里面 : then 继续往前找(找小2的、小3的...)，并且找的那个元素的\ value值赋值false，这样在外层“对于每一个元素中”看到它就会直接跳过了。 else: 就不管，跳过 】 else if 比它大1的数在这里面: then 它不是最后一个元素，别理它，直接跳过 但是我又发现，这个false赋值的好像很鸡肋的样子。因为你会发现最后所有的value值是false的元素，都是"比它大1的数"存在的。那当我在外层循环遍历到这个value值是false的元素的时候，如果跟我不用这个false，我直接去找比它大1的数存不存在，如果存在，那我也仍然是可以直接跳过它，这个查找的时间复杂度也是O(1)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/000d342fbbcca3c514532a43d69833fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/471f4dd241f071ebc0fcef248546d7c4/" rel="bookmark">
			穿云推出可绕过Cloudflare的API，可绕过更多网站的Cloudflare Turnstile CAPTCHA验证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着网络安全的不断升级，许多网站采用了Cloudflare的反爬虫技术，其中包括了强大的Turnstile CAPTCHA验证。为了应对这一挑战，穿云公司推出了一项创新性的API，通过其技术可以成功绕过Cloudflare的Turnstile CAPTCHA验证，使得爬虫程序员能够在无阻碍的情况下访问目标网站。本文将深入介绍穿云API的实现原理以及如何在不触发反爬虫机制的情况下合理使用该API，实现对多种网站的高效爬取。
1. 背景 Cloudflare是一家全球领先的CDN服务提供商，其强大的反爬虫机制对于爬虫程序员来说是一道难以逾越的防线。Turnstile CAPTCHA验证是其防爬虫体系中的一环，采用了先进的人机验证技术，给爬虫程序带来了极大的困扰。穿云公司的API应运而生，为爬虫程序员提供了绕过这一验证的有效途径。
2. 穿云API的工作原理 穿云API通过深度解析Cloudflare的反爬虫机制，特别是Turnstile CAPTCHA验证的流程，实现了对其的绕过。其工作原理主要包括对页面结构的智能分析、JavaScript的解析和对Cookie及Session的处理。这一系列技术手段使得穿云API能够迅速模拟出符合要求的用户行为，成功通过验证，实现对目标网站的无阻碍访问。
3. API的使用方法 穿云公司为用户提供了详细的使用文档，使得爬虫程序员能够方便地将API集成到他们的爬虫系统中。文档中明确了API的接口地址、请求参数和返回处理等关键信息，为用户提供了便捷而高效的使用指南。通过简单的接口调用，爬虫程序员即可轻松绕过Cloudflare的Turnstile CAPTCHA验证，实现对目标网站的爬取。
4. 多网站支持 穿云API不仅可以绕过Cloudflare的Turnstile CAPTCHA验证，还支持更多网站的反爬虫机制。其设计的灵活性使得其可以适应各种不同的验证方式和防爬虫手段，为爬虫程序员提供了更广泛的应用场景。无论是面对特定网站的特殊验证还是一般性的反爬虫措施，穿云API都能够胜任，为用户提供极大的便利。
5. 高级功能：IP代理池与指纹设备特征设置 穿云API不仅仅是一项绕过验证的技术，同时还提供了高级功能。其中包括一站式全球高速Socks5动态IP代理/爬虫代理IP池。用户可以通过API获取全球各地的高速动态IP，避免被网站封锁。此外，穿云API还支持用户设置自定义的HTTP请求头部信息，包括Referer、浏览器User-Agent和浏览器是否处于headless状态等浏览器指纹设备特征，以更好地模拟真实用户的访问行为。
6. 结语 穿云API的推出为爬虫程序员提供了一种强大的工具，使得他们能够更轻松地应对复杂的反爬虫机制。通过绕过Cloudflare反爬5秒盾人机验证的WAF防护和突破Turnstile CAPTCHA验证，爬虫程序员可以实现无阻碍注册和登录访问目标网站。同时，穿云API的多网站支持和高级功能使其具备了更广泛的适用性，为用户提供了更全面的解决方案。通过本文详细的介绍，相信爬虫程序员能够更好地理解穿云API的强大功能，并在实际应用中发挥其最大的价值。
本文转自：穿云推出可绕过Cloudflare的API，可绕过更多网站的Cloudflare Turnstile CAPTCHA验证 – 穿云API帮助教程
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8861287d2d009892ae9dc10a95c1468f/" rel="bookmark">
			c&#43;&#43;socket的select函数以及多路复用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		c++socket的select函数以及多路复用 1.select函数原型使用示例及解释 2.select()函数返回值3.select()函数与socket阻塞的关系与原因4.select函数的意义5.深入理解select模型（1）特点（2）带外数据（2）select函数相关的常见的几个宏（3）select使用范例及结论 6.多路复用及代码示例 1.select函数原型 int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout); 参数说明：
nfds：需要监视的最大文件描述符值加1。
readfds、writefds、exceptfds：分别表示可读、可写和异常事件的文件描述符集合。这些集合是用fd_set结构体表示的。
timeout：指定超时时间，如果为NULL，则select函数会一直阻塞，直到有事件发生。如果指定为0，则select函数会立即返回，用于轮询文件描述符的状态。
select函数的返回值是就绪文件描述符的个数。如果返回0，表示超时；如果返回-1，表示出错。
使用select函数的步骤如下：
(1)准备需要监视的文件描述符集合，并初始化它们。
(2)调用select函数，进行文件描述符的监视。
(3)检查select函数的返回值，判断哪些文件描述符就绪。
(4)对就绪的文件描述符进行相应的操作
使用示例及解释 #include &lt;iostream&gt; #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; int main() { int sockfd; fd_set readfds; struct timeval timeout; // 创建socket sockfd = socket(AF_INET, SOCK_STREAM, 0); // 设置需要监视的文件描述符集合 FD_ZERO(&amp;readfds); FD_SET(sockfd, &amp;readfds); // 设置超时时间 timeout.tv_sec = 5; timeout.tv_usec = 0; // 监视文件描述符 int ret = select(sockfd + 1, &amp;readfds, NULL, NULL, &amp;timeout); if (ret == -1) { std::cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8861287d2d009892ae9dc10a95c1468f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/516538792bf8e4c36e6aa0c38258ade2/" rel="bookmark">
			用Notepad&#43;&#43; 合并两行数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 用脚本跑结果的时候，会取回错误输出信息，导致结果不可用，需要将对应的输出修改之后，合并两行数据
替换前的原数据（错误消息已经批量删除）
20231128161653:xxxxxxx:0: CentOS Linux release 7.4.1708 (Core) 20231128161653:xxxxxxx:0:CentOS Linux release 7.4.1708 (Core) 20231128161653:xxxxxxx:0: CentOS Linux release 7.4.1708 (Core) 20231128161653:xxxxxxx:0:CentOS Linux release 7.4.1708 (Core) 使用notepad++采用正则表达式合并两行数据
(\r?\n)(^[a-zA-Z]) $2 替换后的数据格式
20231128161653:xxxxxxx:0:CentOS Linux release 7.4.1708 (Core) 20231128161653:xxxxxxx:0:CentOS Linux release 7.4.1708 (Core) 20231128161653:xxxxxxx:0:CentOS Linux release 7.4.1708 (Core) 20231128161653:xxxxxxx:0:CentOS Linux release 7.4.1708 (Core) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e0c4179f9e80a6a940da93ec37ee834/" rel="bookmark">
			杂记 | 使用Docker安装并配置MongoDB以支持事务（单副本，并解决了证书文件错误的问题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 00 安装前的准备01 创建Docker Compose文件02 设置证书文件03 启动MongoDB04 初始化副本集和创建用户05 验证安装 00 安装前的准备 在开始之前，确保已经安装了Docker，本文基于Docker Compose进行示范，没有装Docker Compose也可将其中的docker-compose命令转换为docker run命令执行。
01 创建Docker Compose文件 首先，新建一个名为mongo的目录，并在其中创建一个名为docker-compose.yml的文件，并写入以下内容：
version: '3.8' services: mongo: image: mongo:latest container_name: mongo command: --auth --bind_ip_all --replSet rs0 --keyFile /data/mongodb/keyFile ports: - "27017:27017" volumes: - ./data:/data/db - ./conf:/data/configdb - ./backup:/data/backup - ./keyFile:/data/mongodb/keyFile 这个配置会启动一个MongoDB容器，使用最新的MongoDB镜像，并将容器命名为mongo。
命令解释：
command: --auth --bind_ip_all --replSet rs0 --keyFile /data/mongodb/keyFile: 这是传递给MongoDB服务器的命令行参数。
--auth: 开启身份验证。--bind_ip_all: 允许MongoDB绑定到服务器上的所有IP地址。--replSet rs0: 初始化一个名为rs0的副本集。--keyFile /data/mongodb/keyFile: 指定用于副本集成员之间身份验证的密钥文件路径。 ports:: 这部分定义了容器和宿主机之间的端口映射。
"27017:27017": 将容器的27017端口映射到宿主机的27017端口。MongoDB默认使用27017端口。 volumes:: 这部分定义了宿主机和容器之间的数据卷映射，用于数据持久化和配置管理。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e0c4179f9e80a6a940da93ec37ee834/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4e4cb3a0fb444b1ec0f0e17794eddfb/" rel="bookmark">
			Kafka事务机制：原理和实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kafka事务机制：原理和实践 Apache Kafka 是一个分布式流处理平台，广泛用于构建实时数据管道和流应用程序。它不仅以高吞吐量、可扩展性和容错能力著称，还提供了事务支持，以确保数据的完整性和一致性。在这篇博客中，我们将深入探讨 Kafka 的事务机制，了解其原理，并通过一个实际的例子来说明其应用。
Kafka事务简介 在 Kafka 0.11 版本之前，它主要支持“至少一次”（At-Least-Once）和“最多一次”（At-Most-Once）的消息传递保证。然而，这些保证在需要跨多个分区和主题原子地更新数据时显得不够。为了解决这个问题，Kafka 0.11 引入了事务支持，允许跨多个分区和主题进行原子写操作。
事务原理 Kafka 的事务功能基于以下几个核心概念：
事务协调器（Transaction Coordinator）:
Kafka 为每个事务分配一个事务协调器，它负责管理事务的状态。 事务日志（Transaction Log）:
Kafka 使用专门的事务日志来记录事务的状态更改。 生产者ID和事务ID:
每个事务都有唯一的事务ID，生产者使用这个ID来初始化事务。 幂等性:
Kafka 保证在一个事务内部，即使生产者重试发送消息，也不会导致消息重复。 写入隔离:
Kafka 确保只有已提交的事务的消息对消费者可见。 事务的处理流程 初始化事务:
生产者开始一个事务，向事务协调器发送初始化请求。 写操作:
生产者将消息发送到一个或多个主题的分区中。这些消息在事务提交或中止之前，对消费者是不可见的。 提交或中止事务:
生产者可以决定提交事务，使所有写操作对消费者可见，或中止事务以放弃所有更改。 实例应用 假设我们有一个简单的电商应用，需要在订单服务和库存服务之间同步数据。当一个新订单创建时，我们需要在订单主题中写入订单数据，并在库存主题中更新库存信息。
初始化事务:
订单服务开始一个新的事务。 写订单数据:
订单服务向订单主题写入新订单的数据。 更新库存:
同一个事务中，订单服务还需要在库存主题中更新库存信息。 提交事务:
如果两个操作都成功，订单服务提交事务。这时，订单数据和库存更新对消费者可见。 中止事务:
如果任一操作失败，订单服务将中止事务，从而撤销所有更改。 通过这种方式，Kafka 确保了订单创建和库存更新要么都成功，要么都不执行，从而保证了数据的一致性。
结语 Kafka 的事务机制为处理跨多个分区和主题的复杂数据流提供了强大的工具。它确保了数据的一致性和完整性，使 Kafka 成为构建可靠、一致的分布式应用和微服务的理想选择。通过合理地利用 Kafka 事务，开发者可以设计出更健壮、更容错的系统。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85c3c435f0ff28e4c3b37f62097146f6/" rel="bookmark">
			Kafka生产者发送消息的流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kafka 生产者发送消息的流程涉及多个步骤，从消息的创建到成功存储在 Kafka 集群中。以下是 Kafka 生产者发送消息的主要步骤：
1. 创建消息 生产者首先创建一个消息，消息通常包含一个键（可选）和一个值，以及目标主题。 2. 选择分区 如果消息指定了键，生产者会使用分区器（Partitioner）根据键的哈希值选择一个分区；如果没有指定键，可能会基于轮询策略选择分区。分区决策可能考虑分区的负载均衡，以及确保具有相同键的消息发送到同一分区，从而保持消息的顺序。 3. 消息序列化 Kafka 生产者将消息的键和值序列化为字节流，以便它们可以通过网络发送。序列化的方式可以根据配置进行自定义，常见的序列化格式包括字符串、JSON、Avro等。 4. 添加到消息缓冲区 序列化后的消息被添加到一个内部缓冲区。这个缓冲区临时存储消息，直到它们被批量发送到 Kafka 服务器。批量发送可以提高网络效率和吞吐量。 5. 压缩和批处理 为了提高效率，多个消息可能会被组合成一个消息批次，可能还会进行压缩。压缩和批处理是 Kafka 高效处理大量消息的关键。 6. 发送消息 消息批次被发送到 Kafka 集群中目标分区的领导者 Broker。生产者可以配置为同步或异步发送消息。在同步发送中，生产者会等待服务器的响应；在异步发送中，生产者将消息发送到缓冲区后即返回。 7. 确认和重试 Kafka 服务器接收并处理消息后，会向生产者发送一个确认（ACK）。
如果发送失败（例如，由于网络问题或服务器故障），生产者可以根据配置进行重试。
8. 更新偏移量 一旦消息被成功存储在 Kafka 中，其偏移量会被更新。生产者可以选择是否关注这个偏移量。 9. 错误处理 如果消息在所有重试尝试后仍然失败，生产者将执行错误处理逻辑，这可能包括记录错误、调整策略或者将消息发送到一个死信队列。 整个流程强调了效率、可靠性和扩展性，使 Kafka 成为处理大规模、高吞吐量数据流的理想选择。通过适当的配置和优化，生产者可以在保证数据一致性和可用性的同时实现高性能的消息发送。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c32b92b8a488803f717d5d7a9773a65/" rel="bookmark">
			BMS应用MRAM存储芯片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BMS是一种针对电动汽车、混合动力汽车等新能源车辆，对电池组进行管理和控制的系统。BMS的主要功能是对电池组进行监测、保护和控制，以确保电池组的安全、稳定和长寿命。是连接车载动力电池和电动汽车的重要纽带。
BMS实时采集、处理、存储电池模组运行过程中的重要信息，与外部设备如整车控制器交换信息，保障锂电池系统的安全可靠运行。BMS是一个极其复杂的系统，不同的行业BMS也不一样，涉及机到的芯片也不同。产品包含MOSFET,驱动芯片，CAN收发器，MCU,传感器，转换器，电源管理芯片，安全和存储芯片等。
存储芯片MRAM是适合用于数据记录设备中的一款非易失性存储器，可以持续、反复地将重要数据保存于设备的过程。系统内外部发生的事件；使用历史；环境参数；机器状态；用于分析目的的其他数据。因需要持续、反复地保存数据，内存需要快速的写入速度与高耐久性。
RAMSUN提供的MRAM存储芯片的主要优势包括与SRAM不同，无需电压控制器、电池及电池插座；与nvSRAM不同，无需电容器；写入速度快；近乎无限的耐用性（100兆次的写入次数）；断电即时数据备份。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99f231fc58095ccf1c195077869e90c8/" rel="bookmark">
			Java实现LeetCode题目（链表）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Leetcode203去除链表元素 package link_list; public class removePoint { //无虚拟结点的方法,注意不能操作空指针 public static ListNode removeElement(ListNode head,int target) { while(head!=null&amp;&amp;head.val==target) { //判断头结点是不是为空 为什么是while[1,1,1,1] head = head.next; } ListNode cur = head; while(cur!=null&amp;&amp;cur.next!=null) { if(cur.next.val==target) { cur.next=cur.next.next; }else { cur = cur.next; } } return head; } //虚拟结点 public static ListNode removeElement2(ListNode head,int target) { if(head==null) { return head; } ListNode demmyHead = new ListNode(-1,head); ListNode cur = demmyHead; while(cur.next!=null) { if(cur.next.val==target) { cur.next=cur.next.next; }else { cur=cur.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99f231fc58095ccf1c195077869e90c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/954cbb30cdf9aa10a30b72a4a5cf1718/" rel="bookmark">
			VS2017动态链接库（.dll）的生成与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近项目需要生成dll，这里介绍我生成和调用dll的流程。环境是vs2017
一，dll的生成 C++代码是在普通环境下开发调试的（文件-&gt;新建-&gt;项目-&gt;空项目）一定要注意平台是x86还是x64!!
把正确的代码放到生成可以生成dll的环境中（文件-&gt;新建-&gt;项目-&gt;Visual C++的控制台应用）
其实这里我也采用过 文件-&gt;新建-&gt;项目-&gt;Visual C+±&gt;Windows 桌面 -&gt; 动态链接库（DLL） 生成解决方案的时候遇到了找不到头文件的问题，感觉比较麻烦，所以还是采用控制台应用修改为dll的方式
新建 添加头文件和源文件的代码
定义动态链接库的接口，接口的头文件和源代码文件需要以下操作
此处参考https://zhuanlan.zhihu.com/p/651022331
右键解决方案-&gt;属性-&gt;配置属性-&gt;常规-&gt;配置类型 选择动态库（.dll） 这里需要注意红框位置平台要选择正确和代码的运行平台要一致~
生成-&gt;重新生成解决方案 下面提示 ”成功：1个“…则代表dll已经成功生成了
检查debug文件夹下是否有.dll和.lib文件生成
二，调用dll 新建项目（文件-&gt;新建-&gt;项目-&gt;Visual C++的控制台应用）一定要注意平台是x86还是x64，和前面保持一致!!
将步骤一生成的.dll .lib和头文件放到新建项目的如图文件夹
添加一个源文件调用主函数，注意要include头文件
绑定头文件（头文件-&gt;添加-&gt;现有项）
添加.lib到资源文件
生成-&gt;重新生成解决方案
运行结果如下
点绿色三角执行
执行窗口如下
三，中间遇到的问题 生成dll解决方案的时候报错
严重性 代码 说明 项目 文件 行 禁止显示状态 错误 LNK2019 无法解析的外部符号 "void __cdecl AddAnAdd(int,int (__cdecl*)(int,int))" (?AddAnAdd@@YAXHP6AHHH@Z@Z)，该符号在函数 _main 中被引用 DLLTest D:\vs\DLLTest\DLLTest\test.obj 1 解决办法：
后来新创建了一个空项目，然后再创建cpp文件和h文件，再敲代码，然后操作：解决方案资源管理器-&gt;（右键点击）AlexDll-&gt;属性-&gt;配置属性-&gt;常规-&gt;配置类型：动态库(.dll)，再重新生成解决方案就成功了。
最后验证dll的时候，生成解决方案再点击下面的绿色三角就可以正常运行了，而且在主函数加入了下面代码可以暂停窗口
system("pause"); 报错
解决方法
报错
解决方法
注意release和debug模式下的opencv依赖库不同，参考（https://blog.csdn.net/weixin_42450976/article/details/125749045）
参考网址：https://blog.csdn.net/m0_37170593/article/details/76445972
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee7319815090e97ed66b018d0ccc64e8/" rel="bookmark">
			es集群相关报错信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给es集群添加用户密码的时候，会自动弹出相关的账户信息，这个时候，只需要设置对应密码就可以了
[esuser@jky-test1 bin]$ ./elasticsearch-setup-passwords interactive future versions of Elasticsearch will require Java 11; your Java version from [/usr/java/jdk1.8/jre] does not meet this requirement Unexpected response code [500] from calling GET http://192.168.0.29:9200/_security/_authenticate?pretty It doesn't look like the X-Pack security feature is enabled on this Elasticsearch node. Please check if you have enabled X-Pack security in your elasticsearch.yml configuration file. ERROR: X-Pack Security is disabled by configuration. [esuser@jky-test1 bin]$ ./elasticsearch-setup-passwords interactive future versions of Elasticsearch will require Java 11; your Java version from [/usr/java/jdk1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee7319815090e97ed66b018d0ccc64e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da4496b7d4f940851764c88190fd4856/" rel="bookmark">
			线性系统理论 -- 降阶观测器的设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定理： 若系统能观测，且rankC=m，则系统的状态观测器的最小维数是(n-m)。
线性定常时不变系统方程如下（以三阶(n=3)单入单出系统为例，有m=rankC=1）： 取变换阵P，有：
对上述系统方程进行线性变换，
得到如下形式：
输出y直接给出。于是状态估计时，只需对 n-m=2 维的、进行估计即可。这就是说，降阶观测器的维数为n-m=2。
降阶观测器方程为：
只需要选择合适的G1阵，使得 所有的特征值具有期望的特征值即可。
举例如下：
给定连续线性时不变系统：
试确定特征值为-3，-4的二维状态观测器。
解答：
先判断系统是否能观测：
故系统能观测。
选取变换阵P：
可见状态变量可由y直接提供。现只需要设计一个二阶状态观测器来估计即可。
设G1阵为：
则有：
期望的特征多项式为：
对照系数得：
得到：
从而：
系统的二阶降维观测器为：
其中：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45ae9fab3834c7db0aefbb4a93198689/" rel="bookmark">
			敲公式，请不要再挨个找了！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		`
文章目录 1.latex的介绍2.常用的latex的公式3.MathType相关介绍 你还在word上敲公式挨个找吗？你还在为word中公式排版对不齐而苦恼吗？你还在因为找不到相关的符号而暴躁吗？本文将告诉你如可快速的在word中快速的敲写公式！
1.latex的介绍 你还在word上敲公式挨个找吗？你还在为word中公式排版对不齐而苦恼吗？你还在因为找不到相关的符号而暴躁吗？本文将告诉你如可快速的在word中快速的敲写公式！ LaTeX是一种排版系统，用于创建高质量的文档，特别适用于科学、技术和数学领域。它是由Donald Knuth在20世纪80年代初开发的，旨在提供一种简洁而强大的方式来排版复杂的文档。 与常见的文字处理软件（如Microsoft Word）不同，LaTeX使用一种基于标记语言的方法来定义文档的结构和格式。用户通过编写LaTeX命令来描述文档的外观和布局，而不是直接操作可视化界面。这种方式使得LaTeX非常灵活，可以轻松地创建复杂的数学公式、表格、图表和参考文献等。
LaTeX的一个重要特点是它的数学排版能力。它提供了丰富的数学符号和结构的支持，使得编写数学公式变得简单而精确。许多科学和数学领域的专业人士喜欢使用LaTeX来编写论文、报告和书籍，因为它能够准确地呈现复杂的数学表达式。
另一个LaTeX的优点是它的跨平台性。LaTeX可以在各种操作系统上运行，包括Windows、Mac和Linux。它也是开源的，可以免费下载和使用。
虽然LaTeX在开始时可能需要一些学习和适应，但一旦熟悉了基本的命令和语法，它将成为一个非常强大和高效的工具，可以帮助用户创建专业水平的文档。很多学术和科研机构都鼓励使用LaTeX来编写论文和报告，因为它可以确保文档的一致性和可靠性。
总而言之，LaTeX是一种功能强大的排版系统，适用于创建高质量的科学、技术和数学文档。它提供了丰富的数学排版能力和灵活的文档布局，使得用户可以轻松地创建复杂的文档。虽然需要一些学习和适应，但一旦掌握了基本的命令和语法，LaTeX将成为一个非常有用的工具。
2.常用的latex的公式 废话不多说进下来，进行动手实践环节，在wps中点击插入公式中的latex。
输入相关的代码，敲击回车相应的符号就会显现
以下是常用的一些latex代码
% ：用于插入百分号。# ：用于插入井号。&amp; ：用于插入和号。_ ：用于插入下划线。{ 和 } ：用于插入大括号。$ ：用于插入美元符号。\textbackslash ：用于插入反斜杠。^{} ：用于插入上标符号，例如 ^{}a 会得到 “â”。~{} ：用于插入波浪符号，例如 ~{}n 会得到 “ñ”。`` 和 ‘’ ：用于插入双引号。` 和 ’ ：用于插入单引号。alpha ：表示希腊字母α。\beta ：表示希腊字母β。\gamma ：表示希腊字母γ。\delta ：表示希腊字母δ。\epsilon ：表示希腊字母ε。\theta ：表示希腊字母θ。\lambda ：表示希腊字母λ。\mu ：表示希腊字母μ。\pi ：表示希腊字母π。\sigma ：表示希腊字母σ。\omega ：表示希腊字母ω。\infty ：表示无穷大符号。\leq ：表示小于等于符号（≤）。\geq ：表示大于等于符号（≥）。\neq ：表示不等于符号（≠）。\approx ：表示约等于符号（≈）。\times ：表示乘号（×）。\div ：表示除号（÷）。\Rightarrow ：表示蕴含符号（⇒）。\leftarrow ：表示向左箭头（←）。\rightarrow ：表示向右箭头（→）。\uparrow ：表示向上箭头（↑）。\downarrow ：表示向下箭头（↓）。\forall ：表示全称量词（∀）。\exists ：表示存在量词（∃）。 3.MathType相关介绍 如果你想进一步的敲写公式，那么就要使用MathType了，当涉及到MathType时，有一些额外的信息可以了解：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45ae9fab3834c7db0aefbb4a93198689/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdb845764b88a67a538324201b1acc65/" rel="bookmark">
			【C语言】Hello, world!
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. C语言
2. 源文件
3. 注释
4. #include指令和头文件
5. main函数
6. printf函数
7. 语句
8. return语句
/* 输出Hello, world! */ #include &lt;stdio.h&gt; /* 包含头文件 */ int main() // 主函数 { printf("Hello, world!\n"); // 在屏幕上打印Hello, world!并换行 return 0; } 1. C语言 C语言是贝尔实验室的Ken Thompson、Dennis Ritchie等人开发的UNIX操作系统的“副产品”。Thompson独自编写出了UNIX操作系统的最初版本，这套系统运行在DEC PDP-7计算机上。这款早期的小型计算机仅有16KB内存（毕竟那是在1969年）。
与同时代的其他操作系统一样，UNIX系统最初也是用汇编语言编写的。用汇编语言编写的程序往往难以调试和改进，UNIX系统也不例外。Thompson意识到需要用一种更加高级的编程语言来完成UNIX系统未来的开发，于是他设计了一种小型的B语言。Thompson的B语言是在BCPL语言（20世纪60年代中期产生的一种系统编程语言）的基础上开发的，而BCPL语言又可以追溯到最早（且影响最深远）的语言之一——Algol 60语言。
不久，Ritchie也加入到UNIX项目中，并且开始着手用B语言编写程序。1970年，贝尔实验室为UNIX项目争取到一台PDP-11计算机。当B语言经过改进并能够在PDP-11计算机上成功运行后，Thompson用B语言重新编写了部分UNIX代码。到了1971年，B语言已经明显不适合PDP-11计算机了，于是Ritchie着手开发B语言的升级版。最初，他将新开发的语言命名为NB语言（意为“New B”），但是后来新语言越来越偏离B语言，于是他将其改名为C语言。到了1973年，C语言已经足够稳定，可以用来重新编写UNIX系统了。改用C语言编写程序有一个非常重要的好处：可移植性。只要为贝尔实验室的其他计算机编写C语言编译器，他们的团队就能让UNIX系统也运行在那些机器上。
总结：
B语言创始人：Ken Thompson（肯·汤普森）
C语言创始人：Dennis Ritchie（丹尼斯·里奇）
UNIX创始人：Ken Thompson、Dennis Ritchie
2. 源文件 源文件（source file）一般指用汇编语言或高级语言写出来的代码保存为文件后的结果。
C语言源文件的拓展名为.c。
3. 注释 /*……*/（注释一行或多行）//…… （只能注释一行） 4. #include指令和头文件 在编译C程序之前，预处理器会首先对其进行编辑。我们把预处理器执行的命令称为指令。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fdb845764b88a67a538324201b1acc65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb938d77612f507b1d6f81550e34cf49/" rel="bookmark">
			DHCP协议与域名系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机网络与协议： 1、DHCP协议 DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）是一个用于局域网的网络协议，位于OSI模型的应用层，使用UDP协议工作，主要用于自动分配IP地址给用户，方便管理员进行统一管理。
DHCP服务器端使用67/udp，客户端使用68/udp。
DHCP运行分为四个基本过程：
请求IP租约提供IP租约选择IP租约确认IP租约 客户端在获得了一个IP地址以后，就可以发送一个ARP请求来避免由于DHCP服务器地址池重叠而引发的IP冲突。
2、路由算法： 路由算法是用于找到一条从源路由器到目的路由器的最佳路径的算法。
存在着多种路由算法，每种算法对网络和路由器资源的影响都不同。
由于路由算法使用多种度量标准（metric），所以不同路由算法的最佳路径选择也有所不同。
路由选择算法的要求：
正确性：确保分组从源节点传送到目的节点简单性：实现方便，软硬件开销小自适应性：也称健壮性，算法能够适应业务量和网络拓扑的变化稳定性：能长时间无故障运行公平性：每个节点都有机会传送信息最优性：尽量选取好的路由。 两大类路由选择协议： 内部网关协议 IGP：
外部网关协议 EGP：
IGP是在一个AS内部使用的路由选择协议，如RIP和OSPF协议，是域内路由选择。
当源主机和目的主机处在不同的AS中，在数据报到达AS的边界时，使用外部网关协议 EGP 将路由选择信息传递到另一个自治系统中，如BGP-4，是域间路由选择（ intradomain routing）。
RIP： RIP（ Routing Information Protocol）是一种基于距离向量的路由选择协议。RIP 协议要求网络中的每一个路由器都要维护从它自己到自治系统内其他每一个目的网络的距离和下一跳路由器地址。
OSPF： 开放最短路径优先(Open Shortest Path First，OSPF)，这个算法名为“最短路径优先”是因为使用了 Dijkstra 提出的最短路径算法SPF，只是一个协议的名字，它并不表示其他的路由选择协议不是“最短路径优先”。
3、域名系统： DNS是一个简单的请求-响应协议，是将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS使用TCP和UDP协议的53端口。
术语： mDNS：多播DNS，使用5353端口，组播地址为 224.0.0.251 或 [FF02::FB] 。在一个没有常规DNS服务器的小型网络内可以使用mDNS来实现类似DNS的编程接口、包格式和操作语义。mDNS的域名是用 .local 和普通域名区分开的。FQDN：域名的完全形态，主要是包含零长度的根标签，例如 www.example.com. 。TLD：属于根域的一个域，例如 com 或 jp 。CNAME：又称alias，将域名指向另一个域名。TTL：记录DNS记录过期的时间，最小是0，最大是2147483647 (2^31 - 1)。 域名系统工作原理： DNS解析过程是递归查询的，具体过程如下：
用户要访问域名www.baidu.com时，先查看本机hosts是否有记录或者本机是否有DNS缓存，如果有，直接返回结果，否则向递归服务器查询该域名的IP地址；递归缓存为空时，首先向根服务器查询com顶级域的IP地址；根服务器告知递归服务器com顶级域名服务器的IP地址；递归向com顶级域名服务器查询负责baidu.com的权威服务器的IP；com顶级域名服务器返回相应的IP地址；递归向baidu.com的权威服务器查询www.baidu.com的地址记录；权威服务器告知www.baidu.com的地址记录；递归服务器将查询结果返回客户端； 递归服务器： 递归服务器负责接收用户的查询请求，进行递归查询并响应用户查询请求。在初始时递归服务器仅有记录了根域名的Hint文件。
DNS隧道： DNS隧道工具将进入隧道的其他协议流量封装到DNS协议内，在隧道上传输。这些数据包出隧道时进行解封装，还原数据。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0da54d28330219b88cab1c4477d3e1aa/" rel="bookmark">
			HTTP状态返回代码大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 HTTP状态返回代码大全 1、HTTP状态返回代码 1xx（临时响应）： 表示临时响应并需要请求者继续执行操作的状态代码。
Code代码说明100继续服务器返回此代码表示已收到请求的第一部分，正在等待其余部分101切换协议请求者已要求服务器切换协议，服务器已确认并准备切换 2、HTTP状态返回代码 2xx （成功）： 表示成功处理了请求的状态代码。
Code代码说明200成功服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页201已创建请求成功并且服务器创建了新的资源202已接受服务器已接受请求，但尚未处理203非授权信息服务器已成功处理了请求，但返回的信息可能来自另一来源204无内容服务器成功处理了请求，但没有返回任何内容205重置内容服务器成功处理了请求，但没有返回任何内容206部分内容服务器成功处理了部分GET请求 3、HTTP状态返回代码 3xx （重定向）： 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。
Code代码说明300多种选择针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。301永久移动请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。302临时移动服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。303查看其他位置请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。304未修改自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。305使用代理请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。307临时重定向服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 4、HTTP状态返回代码 4xx（请求错误）： 这些状态代码表示请求可能出错，妨碍了服务器的处理。
Code代码说明400错误请求服务器不理解请求的语法。401未授权请求要求身份验证。对于需要登录的网页，服务器可能返回此响应。403禁止服务器拒绝请求。404未找到服务器找不到请求的网页。405方法禁用禁用请求中指定的方法。406不接受无法使用请求的内容特性响应请求的网页。407需要代理授权此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。408请求超时服务器等候请求时发生超时。409冲突服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。410已删除如果请求的资源已永久删除，服务器就会返回此响应。411需要有效长度服务器不接受不含有效内容长度标头字段的请求。412未满足前提条件服务器未满足请求者在请求中设置的其中一个前提条件。413请求实体过大服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。414请求的 URI 过长请求的 URI（通常为网址）过长，服务器无法处理。415不支持的媒体类型请求的格式不受请求页面的支持。416请求范围不符合要求如果页面无法提供请求的范围，则服务器会返回此状态代码。417未满足期望值服务器未满足"期望"请求标头字段的要求。 5、HTTP状态返回代码 5xx（服务器错误）： 这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。
Code代码说明500服务器内部错误服务器遇到错误，无法完成请求。501尚未实施服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。502错误网关服务器作为网关或代理，从上游服务器收到无效响应。503服务不可用服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。504网关超时服务器作为网关或代理，但是没有及时从上游服务器收到请求。505HTTP 版本不受支持服务器不支持请求中所用的 HTTP 协议版本。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96cd5e0254ff1fdfe311502b05a6ff09/" rel="bookmark">
			js 删除数组中指定元素——5种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.使用splice()方法删除元素 JavaScript 中的 splice() 方法可用于在数组中添加或删除元素。如果我们需要删除数组中的元素，可以使用 splice() 方法。该方法接受两个参数，第一个参数指定要删除的元素的位置，第二个参数指定要删除的元素个数：
let myArray = ["apple", "banana", "orange", "grape"]; myArray.splice(1, 1); console.log(myArray); // ["apple", "orange", "grape"] 2.使用filter()方法删除元素 除了使用 splice() 方法，我们还可以使用 filter() 方法来删除数组中的元素。该方法可用于创建一个新的数组，其中包含符合特定条件的元素。我们可以使用以下代码删除数组中的所有 “banana” 元素：
let myArray = ["apple", "banana", "orange", "grape"]; myArray = myArray.filter(function(item) { return item !== "banana" }); console.log(myArray); // ["apple", "orange", "grape"] 3.使用pop()和shift()方法删除元素 pop() 和 shift() 方法可用于删除数组的最后一个元素和第一个元素。如果我们想删除数组中的特定元素，可以使用这些方法与 indexOf() 方法结合使用。例如，以下代码可以删除数组中的第二个元素：
let myArray = ["apple", "banana", "orange", "grape"]; let index = myArray.indexOf("banana"); if (index !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96cd5e0254ff1fdfe311502b05a6ff09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0ad0a3b100ca83ac03c85d6e13594f2/" rel="bookmark">
			C# 实现微信退款及对帐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
需求
基础准备
关键代码
操作界面
​编辑
退款订单类及方法
退款功能实现
对帐
支付商家后台相关要点
实时交易帐单查询
精确交易帐单查询
小结
需求 在招聘报名系统里，考务费支付是其中一个环节，支付方式很多种，比如银联、微信、支付宝等等。本次我们以微信支付进行举例，在考生注册账号、编写简历、报名职位、被初审核通过等一系列基础的条件的具备下，可以进入支付考务费的环节（笔试费用），我们会为其生成一个支付二维码，考生支付后（无论成功与否），都会记录其支付结果状态。
在实际的应用中，对于支付成功的考生，我们会遇到实现退款的需求，只要包括如下场景：
1、根据政策规定，某些符合全部或部分退款条件的考生。
2、其它未知原因，重复支付订单的考生。
3、其它不可抗力，需求进行退款的考生。
基础准备 在实现功能前，做为企业，我们需要申请一个微信服务号，并成为微信支付商家。
1、申请服务号
申请成功后会获得到 AppId 和 AppSecret 用于后续开发，如关联支付商户、网页授权登录等。
具体指引请参照微信公众平台首页：https://mp.weixin.qq.com/cgi-bin/loginpage
2、成为微信支付商家
申请成功后会获得 Mchid 和 paySignKey 用于微信支付、退款等，请在商家后台务必关联申请的公众号。
具体指引请参照微信支付平台首页：https://pay.weixin.qq.com/index.php/core/home/login
上述两个平台申请成功后，请登录微信支付商家平台，进行如下图操作：
在产品中心、AppID帐号管理、关联 AppID（即申请的服务号） 另外一个重要配置是支付目录，我们写的支付程序需要在这里设置，如下图：
关键代码 操作界面 界面上会显示最近一笔的微信订单支付情况，包括订单号、交费时间、交费金额、退款金额。其中退款金额不能大于成功交费金额，否则会返回失败。另外，还可以显示微信交易跟踪日志列表信息，如果订单号、交易价格、openid、返回信息、交易状态等。
示例界面如下：
退款订单类及方法 实现微信退款，需要在支付商家平台申请退款证书，证书文件保存到自定义的目录中，在退款时指定路径。
退款示例代码如下：
const string RefundOrderUrl = "https://api.mch.weixin.qq.com/secapi/pay/refund"; //退款申请API地址 const string RefundQueryUrl = "https://api.mch.weixin.qq.com/pay/refundquery"; //退款查询API地址 //退款订单明细类 public class RefundOrderDetail { /// &lt;summary&gt; /// 返回状态码，SUCCESS/FAIL 此字段是通信标识，非交易标识，交易是否成功需要查看trade_state来判断 /// &lt;/summary&gt; public string return_code = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0ad0a3b100ca83ac03c85d6e13594f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9702522d179ae13fd1bc0a5a2287aaf/" rel="bookmark">
			如何查看容器运行的端口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要查看 Docker 容器运行的端口，你可以使用 Docker 的命令行工具。以下是几种常用的方法来查看容器的端口信息：
使用 docker ps 命令 最简单的方式是使用 docker ps 命令，它可以显示当前正在运行的所有容器及其相关信息，包括端口映射。
打开命令行界面。
输入以下命令：
docker ps 这个命令会列出所有正在运行的容器，以及它们的 ID、镜像名称、创建时间、状态、端口等信息。
在输出结果中，查找“PORTS”列，它会显示容器的端口映射。例如，0.0.0.0:8080-&gt;80/tcp 表示宿主机的 8080 端口被映射到容器的 80 端口。
使用 docker inspect 命令 如果你需要更详细的端口映射信息，可以使用 docker inspect 命令，加上你要检查的容器 ID 或名称。
首先，找到你的容器 ID 或名称，可以使用 docker ps 来查看。
然后，使用以下命令：
docker inspect [container_id_or_name] 替换 [container_id_or_name] 为你的容器 ID 或名称。
在输出结果中，查找有关“NetworkSettings”部分，它包含了端口映射的详细信息。
这两种方法都可以有效地帮助你查看 Docker 容器的端口映射情况。docker ps 更适合快速查看，而 docker inspect 提供了更全面的信息。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/830c172cf1dfe2c5384e8c9f874f414d/" rel="bookmark">
			PDF转WORD（Java实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java实现PDF转WORD 相信在日常，我们都会用到word文档来查看一些内容，但是很多时候获取到的资料都是只允许查看的PDF形式，而你又想编辑这个文档，那就需要将这个PDF文档转换为WORD文档，来进行编辑，最后在转回去即可，word转pdf相信大家都会，后缀名改一下就行…但是PDF转WORD缺需要一些工具，接下来我们介绍一下怎么通过Java代码实现。
Aspose.PDF for Java Aspose.PDF for Java 可用于轻松将文本、图像、SVG、HTML 转换为 PDF，并将 PDF 转换为各种文档格式，性能卓越，质量好。在这里我们只是用他的PDF转WORD功能。
其他的功能和使用可以参考官网：https://products.aspose.com/pdf/
（1）首先指定 Aspose 存储库配置
首先，您需要在 Maven pom.xml 中指定 Aspose 存储库配置/位置，如下所示：
&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;AsposeJavaAPI&lt;/id&gt; &lt;name&gt;Aspose Java API&lt;/name&gt; &lt;url&gt;https://releases.aspose.com/java/repo/&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; （2）定义 Aspose.PDF for Java API 依赖项
然后在您的 pom.xml 中定义 Aspose.PDF for Java API 依赖项，如下所示：
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.aspose&lt;/groupId&gt; &lt;artifactId&gt;aspose-pdf&lt;/artifactId&gt; &lt;version&gt;21.7&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; （3）创建方法两行代码即可实现
import com.aspose.pdf.Document; import com.aspose.pdf.SaveFormat; 切记Documen引入aspose相关的，引入以上地址即可 @GetMapping("/toWord") public String pdfToWord() { // Open the source PDF document Document pdfDocument = new Document("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/830c172cf1dfe2c5384e8c9f874f414d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52bcda4e83e800ef148dd7e3fd473bfd/" rel="bookmark">
			分享一下快速搭建IntelliJ IDEA开发环境的完整教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IntelliJ IDEA是我们Java程序员使用最多的的开发工具，用过之后都觉得香，相比之下，Eclipse和MyEclipse就有点平平无奇了（反正我果断抛弃了Eclipse）。
接下来这篇文章将会详细地介绍如何快速搭建一个IntelliJ IDEA的开发环境。
目录
第一步：安装jdk
第二步：安装Maven
第三步：配置环境变量
1、jdk环境变量配置
2、maven环境变量配置
第四步：修改Maven配置
第五步：修改IntelliJ IDEA设置
第一步：安装jdk 推荐安装jdk1.8，在jdk官网或者通过以下百度网盘链接下载：
jdk1.8百度网盘链接https://pan.baidu.com/s/1dKsHNFVnFC722lwqPva8vQ?pwd=g1km
第二步：安装Maven 首先，访问maven的官网Maven – Welcome to Apache Maven
在官网首页点击红框内的Download
这时候看到的是maven推荐下载的较新版本，点击下载zip就可以了
如果不想下载最新版本，把页面稍微往下滚动，点击下面图片中的链接Maven Releases History
然后在maven历史版本的页面能看到各种maven版本
然后找到想要下载的版本，点击后面的链接中的reference documentation进入对应maven版本的页面
比如要下载maven3.6.1版本，点击左边的Download链接进入下载页面，接下来就不用我说了吧
最后，把下载下来的Maven压缩包解压到系统盘指定位置，建议解压到D盘，比如D:/program，至此，maven的安装就完成了。
第三步：配置环境变量 1、jdk环境变量配置 在电脑桌面找到此电脑
右键点击【此电脑】在菜单中点击【属性】，会打开下图中的设置界面。
然后点击界面右侧的【高级系统设置】，在弹出的窗口中点击【环境变量】。
在系统变量下方的列表中：
（1）新建变量CLASS_PATH，变量值为
.%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar （2）新建变量JAVA_HOME，变量值为jdk的安装路径，例如
C:\Program Files\Java\jdk1.8.0_152 （3）找到Path变量，选中点击编辑
在编辑窗口中点击右边的【新建(N)】按钮，新增两个值
%JAVA_HOME%\bin %JAVA_HOME%\jre\bin 2、maven环境变量配置 （1）新建变量MAVEN_HOME，变量值为maven的安装路径，例如
D:\program\apache-maven-3.6.1 （2）找到Path变量，选中点击编辑，打开编辑环境变量窗口，在窗口中点击右边的【新建(N)】按钮，新增以下值
%MAVEN_HOME%\bin 最后依次点击窗口的【确定】按钮保存修改，配置完成后的截图如下，首次安装jdk需要重启一下电脑。
第四步：修改Maven配置 找到Maven的安装目录，打开config文件夹下的settings.xml，修改两处配置
修改1：Maven本地仓库的地址，这个值设置为本地仓库repository的目录，随便在一个地方创建一个repository文件夹就可以了，建议在D盘创建，例如：
&lt;localRepository&gt;D:\program\repository&lt;/localRepository&gt; 修改2：配置远程仓库地址，使用阿里云的仓库，本地仓库repository中没有的jar包会到这个仓库去下载。
&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt; http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt; 第五步：修改IntelliJ IDEA设置 打开IntelliJ IDEA，第一次打开idea的时候，界面长这样，在这个界面的设置应用于全局。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52bcda4e83e800ef148dd7e3fd473bfd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6be2bdbceb3d04726effcf21c5d5f127/" rel="bookmark">
			SpringBoot 操作pdf模板全套流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.自定义Pdf 模板 真实开发场景中，大部分需求都是指定让你在某个地方插入的具体数据是什么，这个时候我们就需要一个PDF 的模板。
（1）新建一个word 文档，编排好你需要的格式。
（2）将编号的文档另存为pdf
(3)使用pdf编辑器,编辑表单，（例如福昕PDF阅读器、Adobe Acrobat DC），在本篇文章中使用的是Acrobat 9 Pro v9.0.0
2.Acrobat 9 Pro v9.0.0的简单使用： （1）点开软件，打开制作好的pdf 基础模板，点击表单选项，然后点击添加或编辑域。
（2）在表单-&gt;表单工具中选择你需要的控件，如果是文本内容一般就使用文本框即可
（3）将控件拖动到指定你想填充数据的地方并拖动鼠标调整大小
（4）双击控件进行一些配置
配置注意项
【1】必须给一个名字，后序在程序中就是通过这个名字找到该文本框并填入内容
【2】给文本框表单域选择隐藏，这样就不会保存之后点开能看到这个框本身
隐藏效果如下：
不隐藏效果如下：
【3】其他细节就自行配置，
（5）配置好之后保存成pdf 即可。
3.Springboot 操作模板添加数据： 1.依赖引入
&lt;!-- PDF操作,itext7全家桶 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.itextpdf&lt;/groupId&gt; &lt;artifactId&gt;itext7-core&lt;/artifactId&gt; &lt;version&gt;7.1.11&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;com.itextpdf&lt;/groupId&gt; &lt;artifactId&gt;itextpdf&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.pdfbox&lt;/groupId&gt; &lt;artifactId&gt;pdfbox&lt;/artifactId&gt; &lt;version&gt;2.0.24&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.itextpdf&lt;/groupId&gt; &lt;artifactId&gt;font-asian&lt;/artifactId&gt; &lt;version&gt;7.1.11&lt;/version&gt; &lt;/dependency&gt; 2.操作模板并返回生成的Pdf 说明：这里我们直接调用接口返回的就是pdf 本身
private void createPDF(HttpServletResponse response, data1) throws IOException { private static final String DOWNLOAD_PATH = new File(System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6be2bdbceb3d04726effcf21c5d5f127/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2e39b23cef469077a4d03a627867c4a/" rel="bookmark">
			Python&#43;PySide6之模型/视图/委托框架QListView案例实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qt中的模型/视图/委托框架是一种数据与可视化相互分离的技术，起源于Smalltalk的设计模式——Mode/View/Controller(MVC,模型/视图/控制器），通常在构建用户界面时使用。
MVC是由3部分组成。Model是应用程序对象，View是它的界面展示，Controller定义了界面对用户输入的反应方式。
Qt提供的技术方法和MVC稍有不同，称为Model/View/Delegate（模型/视图/委托），可以提供与MVC相同的全部功能，如下图，MVC中的控制器的部分功能既可以通过委托实现，也可以通过模型实现。
一般来说，模型从数据源中读/写数据，视图从模型的索引中获取需要呈现的数据，并通过委托绘制。对于用户的编辑操作，视图会要求委托提供一个编辑器，并把编辑后的结果传递给模型。模型、视图和委托使用信号/槽机制相互通信。
来自模型的信号将数据源的变更信息通知视图。来自视图的信号提供用户与当前项目的交互信息。来自委托的信号在编辑的时候告诉模型和视图编辑器的状态。 一、关于模型（Model）：
模型中数据存储的基本单元是item,每个item都对应唯一的索引值（QModelIndex），每个索引值都有3个属性：行、列、父对象。
对于一维模型，如列表（List），只会用到行
对于二维模型，如表格（Table），会用到行和列
对于三维模型，如树（Tree），会用到行、列、父对象。
所有模型都基于QAbstractItemModel类,它定义了一个接口，视图和委托使用该接口访问数据。通过该接口数据不一定要存储在模型中，可以保持在由单独的类、文件、数据库或者默写其它应用程序组件提供的数据结构或者存储库中。
QAbstactItemModel是处理列表、表格、树的基类，在此基础上，QAbstactListModel和QAbstractTableMode提供了处理列表和表格的更好选择，因为它们提供了一些常用的方法。需要注意的是，这3个Model都是抽象模型，必须子类化并且要重新实现部分方法才能使用。如果不想这么麻烦，Qt也提供了一些便准的现有模型，可以直接实例化处理数据。
QStringListModel,用于存储QString项的简单列表，一般和QListView或者QComboBox一起使用。QStandardItemModel,可以管理更复杂的项目树结构，可以用于表示列表、表格、树视图所需要的各种不同的数据结构，该模型还包含了数据项，每个项可以包含任意数据。QStandardItemModel可以与QListView,QTableView和QTreeView一起使用。QFileSystemModel是一个用于维护有关目录内容的信息的模型，它本身不保存任何数据，只是表示本地文件系统上的文件和目录。QFileSystemModel可以与QListView、QTableView、QTreeView一起使用。QSqlQueryModel、QSqlTableModel、QSqlRelationalTableModel用于使用模型/视图约定访问数据库，一般和QTableView一起使用。 模型角色：
模型中的项目可以为其它组建执行各种角色，允许为不同情况提供不同类型的数据，比如使用setText(),setIcon(),setForeground()等函数可以设置不同的角色。例如，在视图中正常显示字符串需要设置Qt.DisplayRole角色，这一般是项目的默认角色；为项目添加ToolTip提示功能，需要设置Qt.ToolTipRole角色；设置项目item的文本颜色，需要设置Qt.ForegroundRole角色。
一个项目item可以包含多个不同角色的数据，也就是说拥有这些角色，标准角色由Qt.ItemDataRole定义。
模型通过索引（QModelIndex）定位角色，使用setData()函数可以设置角色，使用data()函数可以获取角色。
有些模型（如QStringListMode)只支持字符串，不支持颜色、图片等角色；有些模型（如QStandardItemMode)支持字符串、颜色、图片等多种角色。
二、关于视图（View）：
视图从模型中获取数据并在界面上呈现。QListWidget/QTableWidget/QTreeWidget是分别继承QListView/QTableView/QTreeView类，包含了默认的模型，使用简单一些，但是QListView/QTableView/QTreeView类更加灵活，配合不同模型（Model）可以处理更复杂的数据处理，比如数据的筛选、过滤、复杂计算、及时更新等。
QListView：在列表中显示模型的数据，一般和QStringListModel一起使用，也可以使用QStandardItemModel。使用QFileSystemModel可以显示本地文件目录。QTableView：在表格中显示模型的数据，一般和QStandardItemModel一起使用。如果要显示数据库数据，则可以使用QSqlQueryModel、QSqlTableModel、QSqlRelationalModel。使用QFileSystemModel可以显示文件目录。QTreeView：在树中显示模型的数据，一般和QStandardItemModel一起使用，使用QFileSystemModel可以显示文件目录。 三、关于委托（Delegate)：
Delegate（委托或代理）的作用包括以下两个方面：
绘制视图中来自模型的数据，委托会参考项目的角色和数据进行绘制，不同的角色和数据有不同的绘制效果（比如字符串颜色，字体，背景色，图标等）。
在视图与模型之间交互操作时提供临时编辑组件的功能，该编辑器位于视图的顶层。
QAbstractItemDelegate是委托的抽象基类，它的子类QStyledItemDelegate是所有Qt项目视图的默认委托，并在创建视图时自动安装。QStyledItemDelegate是QListView、QTableView、QTreeView的默认委托，如果要编辑QTableView,那么其默认委托（QStyledItemDelegate)会提供QLineEdit作为编辑器；对于子类QListWidget/QTableWidget/QTreeWidget也一样。如果要使用其他编辑器，比如vQTableView使用QSpinBox作为委托编辑器，就需要通过自定义委托实现。
四、QListView应用案例：
QListView是Qt中用来存储列表的纯视图类。QListView是基于Qt模型/视图/委托架构提供更灵活的方法，一般与QStringListModel绑定管理数据。
1、绑定模型和初始化数据
QListView需要绑定模型，一般绑定QStringListModel模型。QStringListModel是一个可编辑模型，，提供了可编辑模型的所有标准功能，可用于在视图小部件中显示多个字符串的简单情况。
模型既可以在实例化时传递字符串列表来初始化数据，也可以使用setStringList()函数设置字符串，视图绑定模型使用setModel()函数。
实例化时传递字符串列表初始化数据示例：
# 使用for循环表达式，创建一个字符串列表 model = QStringListModel(['行'+str(i) for i in range(6)]) 使用setStringList()函数初始化数据示例：
model = QStringListMode() model.setStringList(['行'+str(i) for i in range(6)]) 视图绑定模型示例：
# 实例化一个QListView列表视图对象 listView = QListView() # 实例化QStringListModel模型 model = QStringListModel(['row'+str(i) for i in range(6)]) # 列表视图绑定模型 listView.setModel(model) 2、增、删、改、查、移、选
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2e39b23cef469077a4d03a627867c4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ac9edbfd5e272781f92e31d1871ea1e/" rel="bookmark">
			Redis基本操作及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📑前言 本文主要是【Redis】——Redis基本操作及使用的文章，如果有什么需要改进的地方还请大佬指出⛺️
🎬作者简介：大家好，我是听风与他🥇
☁️博客首页：CSDN主页听风与他
🌄每日一句：狠狠沉淀，顶峰相见
目录 📑前言 Redis基本操作及使用什么是Redis关系型数据库和非关系数据库的区别 全局key操作查看所有的key删除查看key是否存在，存在返回1，不存在返回0查看key类型运算 Redis五种数据类型及操作value :都是字符串类型的(可加引号也可不加) string设置获取查看过期时间设置过期时间追加redis里面所有的value，都是字符串类型的 设置/获取 多个 list添加查看获得list的元素个数设置，修改数据删除 hash设置获取删除获取全部field value获取所有的field获取所有的value获取field的个数 set集合设置获取删除移动一个集合的值到另一个集合判断集合存在某个值交集并集差集 zset设置获取删除索引zcard 查看有序集合元素数zrangebyscore 返回集合中 score 在给定区间的元素zcount 返回集合中 score 在给定区间的数量zscore : 查看score值zremrangebyrank : 删除集合中排名在给定区间的元素(正向)zremrangebyscore : 删除集合中 score 在给定区间的元素 Redis发布和订阅📑文章末尾 Redis基本操作及使用 什么是Redis Redis是由意大利人Salvatore Sanfilippo（网名：antirez）开发的一款内存高速缓存数据库。Redis全称为：Remote Dictionary Server，该软件使用C语言编写，Redis是一个key-value存储系统，它支持丰富的数据类型，如：string、list、set、zset(sorted set)、hash。
redis是一种nosql数据库,他的数据是保存在内存中，同时redis可以定时把内存数据同步到磁盘，即可以将数据持久化，还提供了多个语言的API，操作比较方便
Redis特点:
Redis以内存作为数据存储介质，所以读写数据的效率极高，远远超过数据库。Redis应用场景:
因为Redis交换数据快，所以在服务器中常用来存储一些需要频繁调取的数据，这样可以大大节省系统直接读取磁盘来获得数据的I/O开销，更重要的是可以极大提升速度。
将这种热点数据存到Redis（内存）中，要用的时候，直接从内存取，极大的提高了速度和节约了服务器的开销。 关系型数据库和非关系数据库的区别 关系型数据库
表和表之间存在的关系非关系型数据库
不存在表的这种概念,redis是键值对数据库，通过key查找value 所以key是唯一的。 全局key操作 对redis五个数据类型都适用的命令 查看所有的key keys * keys n* 删除 del key 例: (del name) 查看key是否存在，存在返回1，不存在返回0 exists key 查看key类型 type key 运算 set num 1 # 自动识别，字符串里面的 整数 # +1 incr key 例 (incr num) # -1 decr key 例 (decr num) # +整数 incrby key increment 例 (incrby num 50) # -整数 decrby key increment 例 (decrby num 50) Redis五种数据类型及操作 string 字符串list 列表hash 哈希set 集合sorted sets 有序集合 key 有5种数据类型：string、list、set、zset(sorted set)、hash。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ac9edbfd5e272781f92e31d1871ea1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd89bdf161b7ee8e1430002fb258cbdd/" rel="bookmark">
			在window11系统下安装和配置Hadoop并在idea上连接HDFS的过程中可能出现的问题以及解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将hadoop下载解压到window系统下
在硬盘力创建一个文件夹专门存放Hadoop
接下就是配置环境变量（win11系统）
在桌面的此电脑中鼠标右击，找到属性。
点击
找到环境变量
在系统变量中新建一个变量，将下面的变量名写入HADOOP_HOME
HADOOP_HOME Hadoop文件地址就是下载解压后的文件地址
然后点击进入path
在path添加
%HADOOP_HOME%\bin 以及
%HADOOP_HOME%\sbin 然后win+R在命令行cmd 里面用 hadoop version 查看Hadoop是否安装成功。这里需要注意的是如果jdk安装在文件路径里有空格的地方，如C:\Program Files，就会报错。像下面这样子。解决办法就是把jdk放在别的没有空格的路径里，比如直接放在C盘 C:\Java\jdk-17
C:\Users\g'xing&gt;hadoop version 系统找不到指定的路径。 Error: JAVA_HOME is incorrectly set. Please update E:\hadoop\hadoop-2.9.2\hadoop-2.9.2\etc\hadoop\hadoop-env.cmd '-Xmx512m' 不是内部或外部命令，也不是可运行的程序 或批处理文件。 这样子就是安装成功。
下一步，将网盘里bin文件hadoop.dll,winutils.exe替换自己下载hadoop安装目录下bin目录的文件
找到对应版本的bin文件, 直接全部覆盖到原目录上，下面各个版本的bin文件
链接：https://pan.baidu.com/s/1W6enylh0sb6fVspx5yqEsw?pwd=qn44 提取码：qn44
在idea上连接hdfs，即可完成。如果还在idea上还是无法连接HDFS，可以尝试上传一个测试文件。
在CentOS 7上使用Hadoop上传测试文件，您可以按照以下步骤进行操作：
确保您已经安装了Hadoop，并且已经正确配置了Hadoop集群。
在CentOS 7上创建一个测试文件。您可以使用以下命令创建一个名为"testfile.txt"的空文本文件：
hdfs dfs -ls / 将测试文件上传到Hadoop分布式文件系统（HDFS）。使用以下命令将文件从本地系统复制到HDFS的根目录（"/"）中：
hdfs dfs -copyFromLocal testfile.txt / 该命令将"testfile.txt"文件复制到HDFS的根目录中。
4. 验证文件是否成功上传到HDFS。您可以使用以下命令查看HDFS根目录中的文件列表：
hdfs dfs -ls / 如果"testfile.txt"文件存在于列表中，则表示上传成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b3e1abdd2e955813ac5e8a5cdaeca00/" rel="bookmark">
			AttributeError: XX object has no attribute XX问题案例分享（未解决）2023/11/28
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		太痛太痛
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3897801762f92cd10412c430e3175682/" rel="bookmark">
			现代控制理论 -- 能控性、能观性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		能控性定义：
若给定系统的一个初始状态x(t0)（t0可为0），若在t1&gt;t0的有限时间区间[t0,t1]内，存在容许控制u(t)使得x(t1)=0，则称系统状态在t0时刻是能控的。
若系统对任意一个初始状态都能控，则称系统是状态完全能控的。
能观性定义：
若给定系统一个初始状态x(t0)(t0可为0)，在t1&gt;t0的有限时间区间[t0,t1]内，通过观测y(t)，能够唯一地确定系统的初始状态x(t0)，称系统状态在t0是能观测的。
若在任意的初始状态都能观测，则称系统是状态完全能观测的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9f64e1976c6e7ba8a29e4465c3b46d0/" rel="bookmark">
			Python银行信贷风控建模实战（xgb&#43;lgb）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、数据读取及预处理
1、数据读取
2、数据预处理
二、模型构建及评估
三、划重点
少走10年弯路
一、数据读取及预处理 1、数据读取 数据来源某比赛网站（下图仅为部分字段），数据集中包含银行借贷订单的金额、利息、账期、担保等基本信息，还有历史授信情况，数据类型同样包含数值型、类别型、日期等变量，同时存在缺失问题，适合初学者入门练习。文末获取数据
2、数据预处理 （1）无效特征剔除：数据集中存在部分无效数据，唯一值数量仅为1、不包含有效信息，可以直接剔除；
（2）日期、编码剔除：如下图，部分日期为脏数据，为方便处理直接剔除日期字段
（4）类别型变量处理：使用xgb时特征输入需要为数值型，所以复制一份xgb建模数据集对类别型变量使用目标编码、即使用训练集（避免穿越）每类类别型变量对应的y均值进行编码；而对于lgb可以直接转为category类型输入。
（5）FM交叉特征：针对lgb，数据集中存在部分类别型变量可以衍生二阶交叉特征、后续测试效果
def init_data(): df_fea=pd.read_excel('原始数据/trainX.xlsx') df_y=pd.read_excel('原始数据/trainY.xlsx') df=pd.concat([df_fea.drop(['id'],axis=1),df_y.drop(['id'],axis=1)],axis=1) return df df=init_data() def drop_useless_col(data): df_sta=data.nunique(dropna=False).to_frame() df_sta.columns=['unique_cnt'] drop_col=list(df_sta[df_sta.unique_cnt&lt;2].index) return data[[col for col in data.columns if col not in drop_col]] def data_pred(data): df=data.copy() df=df.pipe(drop_useless_col) drop_col=['jieju_next_anew_pricing_dt'] drop_tmp=['kehu_tm_dpst_early_open_acct_dt','kehu_open_cust_tm','kehu_open_cust_dt'] return df[[col for col in df.columns if col not in drop_col+drop_tmp]] df_pre=df.pipe(data_pred) from itertools import combinations def combine(df_pre,cate_col): df=df_pre.copy() comb=list(combinations(cate_col,2)) cate_col_add=[] for col1,col2 in comb: df[col1+'_'+col2]=df[col1].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9f64e1976c6e7ba8a29e4465c3b46d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd4fc88e092f70427ffff8217e3de2ab/" rel="bookmark">
			现代控制理论 --如何将连续系统离散化？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线性定常系统的系统方程为：
经过离散化后，系统方程变为：
举例：
线性定常系统方程为： 将其离散化。
解：
第一步：先求 。
第二步：确定G。
第三步：确定H。
第四步：确定C。
C=C
第五步：确定D。 D=D=0
从而离散化后的系统的系统方程为：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/620580b4fc6ddc5ffad2ea75ee9b745d/" rel="bookmark">
			ARCGIS PRO SDK NET6框架wpf界面下使用winform控件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用记事本，打开项目工程csproj文件，添加：
&lt;UseWindowsForms&gt;true&lt;/UseWindowsForms&gt;
放置的位置是，【项目名】.csproj文件，在Visual Studio 2022 里双击项目名可以打开这个文件，见下图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0651aa1d9b89f2bc60faaf734552b66b/" rel="bookmark">
			Python的控制流语句使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python的控制流语句使用 判断语句 if分支示意图语法介绍注意事项示例 for循环示意图语法介绍列表推导式示例 while循环与for的区别语法介绍示例 判断语句 if分支 示意图 单、双、多分支：
语法介绍 # 单分支 if condition: expression # 双分支 if condition: expression1 else: expression2 # 多分支 if condition1: expression1 elif condition2: expression2 else: expression3 注意事项 关键词（if、elif和else）所在的行末必须加上英文状态的冒号。
冒号所在行的下一行必须缩进（目的是为了代码的好看与好用）。
elif的正确写法 （错误写法：elseif else if ）。
else后面永远不要写条件。
示例 1.二分支：返回一个数的绝对值
# 二分支：返回一个数的绝对值 x = -3 if x &gt;= 0: print(x) else: print(-1*x) 输出：
3
2.多分支：返回成绩对应的等级
# 多分支：返回成绩对应的等级 score = 68 if score &lt; 60: print('不及格') elif score &lt; 70: print('合格') elif score &lt; 80: print('良好') else: print('优秀') 输出：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0651aa1d9b89f2bc60faaf734552b66b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b82a374b89da2755fa696ee305e2cafa/" rel="bookmark">
			Linux部署宝塔面板及安装WordPress环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux部署宝塔面板及安装WordPress环境 1. 引言2. 环境3. 安装宝塔面板4. 登录面板5. 安装LNMP6. 面板设置（可选）7. 新建站点及数据库8. 安装WordPress9. 配置 WordPress10. 访问网站11. 杂言 1. 引言 我本身已经有了一台已经部署完毕并且网站已经上线的腾讯云轻量服务器，但为了分离测试~~（xjb玩）~~，又去天翼云试用白嫖了两个月的云服务器。
同时我也发现，一般正式的云服务器的镜像没有自带宝塔Linux面板的，只有轻量服务器才可以选择自带面板。同时因为之前我在安装WordPress的时候踩了很多坑，也看了一大堆奇奇怪怪的没用的文章，所以打算以本文记录我基本的建站流程。（等明年换服务器的时候给自己参考）。
本文尽量详细描述，一直进行到安装完WordPress并实现通过IP地址能访问网站，域名解析部分暂时不搞（一来又要买个域名，二来也要备案才能访问，等明年手头的域名过期再考虑更新）。
注：发文时该服务器已过期删除，IP及账号都已废弃，不用去尝试登录本文演示用的账号了。
注2：本文所有文字图片均为本人原创，全部自己手敲and截图，无网络复制内容。
2. 环境 云服务器：CentOS7.9 64位 （1vCPUs | 1 GiB）【全新（已被重装系统）】
SSH工具：Finalshell （SSH工具安装与否无所谓，通过云服务器管理后台直接连接也行）
3. 安装宝塔面板 用宝塔面板来建站和维护非常方便，可以实现环境的快速安装及网站文件的快速添加及修改等功能。
（1）访问宝塔网站
网站：https://www.bt.cn/new/index.html
宝塔面板有 Linux 和 Windows 两种，这里肯定选择 Linux。安装方式建议选择下面的通过安装脚本安装，在线安装可能因为没配置好安全组规则而被防火墙拦截。
复制第一行的 Centos 安装脚本：
yum install -y wget &amp;&amp; wget -O install.sh https://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh ed8484bec （2）打开 Finalshell 连接Linux。（或通过服务器提供商提供的在线连接）
黏贴上面复制的脚本，回车。
不重要的两点：
（1）windows的复制黏贴是 ctrl + c 和 ctrl + v；而Linux的复制黏贴是 ctrl + shirt + c 和 ctrl + shirt + v；因此黏贴到 finalshell 时记得多按一个 shirt 键。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b82a374b89da2755fa696ee305e2cafa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb1da5b1709a47822f8fcf15652e51c8/" rel="bookmark">
			详细堆排序的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
建堆有两种方法（以升序为例）：
建完堆之后，就可以去排序了：
以下是向上调整和向下调整的两个接口：
完整实现和测试代码：
首先，排序之前要先建立一个堆来实现排序
由于兄弟之间无大小关系，所以：
实现升序要创建大堆
实现降序要创建小堆
建堆有两种方法（以升序为例）： 1.利用AdjustUp（向上调整）：
从第二个数据（因为第一个数据上面无父节点），也就是下标为1的那个点开始遍历调整数据，只要该节点上面的父节点比该点小，就互换数据（Swap），最后就会建立出一个大堆。
// 建大堆 // O(N*logN) for (int i = 1; i &lt; n; i++) { AdjustUp(a, i); } 2.利用AdjustDown（向下调整）：
从倒数第一个非叶子节点，也就是倒数第一个父节点开始（建成分成许多个分散的大堆），只要该节点上面的父节点比该点小，就互换数据（Swap），最后就会建立出一个大堆。
// O(N) for (int i = (n - 1 - 1) / 2; i &gt;= 0; --i) { AdjustDown(a, n, i); } 这两种方法中，更推荐下面这种，因为时间复杂度稍低，而且下方排序也要用到向下调整接口，这样就节省了一个接口。
建完堆之后，就可以去排序了： 通过大堆的顶端元素最大的特性，可以将尾数据和top数据交换（Swap），AdjustDown的参数中传进去的end是个判断点，size--后，就可以将top那个最大的数据保存在尾部，然后利用向上调整的特性，次大的数据又到了top点，再次交换，size--，依次进行下去，最后就将最大，次大，次次大......依次放到了尾部，就排序完成了。
//0（N*logN） int end = n - 1; while (end &gt; 0) { Swap(&amp;a[0], &amp;a[end]); AdjustDown(a, end, 0); end--; } 以下是向上调整和向下调整的两个接口： void AdjustUp(HPDataType* a, int child) { int parent = (child - 1) / 2; while (child &gt; 0) { if (a[child] &lt; a[parent]) { Swap(&amp;a[child], &amp;a[parent]); child = parent; parent = (child - 1) / 2; } else { break; } } } void AdjustDown(int* a, int size, int parent) { int child = parent * 2 + 1; while (child &lt; size) { // 假设左孩子大 if (child + 1 &lt; size &amp;&amp; a[child + 1] &gt; a[child]) { ++child; } if (a[child] &gt; a[parent]) { Swap(&amp;a[child], &amp;a[parent]); parent = child; child = parent * 2 + 1; } else { break; } } } 完整实现和测试代码： #include&lt;stdio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb1da5b1709a47822f8fcf15652e51c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72daa4606597fccf797db5159f2ed0df/" rel="bookmark">
			SpringBoot定时任务报错Unexpected error occurred in scheduled task原因及其解决方法（亲测有效）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 spring boot项目在线上一直正常运行没有错误，然后今天发生了报错，如图
这是一个定时器错误，发生这个报错
主要有两个原因
定时器编写的有错误@Scheduled注解方式级别高于资源注入级别，导致了资源注入失败 以下是我的代码
@RestController @Slf4j @SuppressWarnings({"all"}) @CrossOrigin @RequestMapping("/journal") @Component public class JournalController { @Autowired Journal_timeMapper journal_timeMapper; /** * 每周日将签到时间数据清空 */ @Scheduled(cron = "0 0 0 * * SUN") public void journaltimeout() { List&lt;Journal_time&gt; journal_times = journal_timeMapper.selectList(null); for (Journal_time journal_time : journal_times) { journal_time.setDay_time("0小时0分钟"); journal_time.setWeek_time("0小时0分钟"); journal_time.setAll_time("0小时0分钟"); journal_time.setWeek_time_desc("第0名"); journal_timeMapper.updateById(journal_time); } } /** * 每天晚上将一天签到数据清空 */ @Scheduled(cron = "0 0 0 * * ?") public void daytimeout() { List&lt;Journal_time&gt; journal_times = journal_timeMapper.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72daa4606597fccf797db5159f2ed0df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d3002f5407f45abf07663c877af1423/" rel="bookmark">
			进程等待讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今日为大家分享有关进程等待的知识！希望读完本文，大家能有一定的收获！
正文开始！
进程等待的引进 既然我们今天要讲进程等待这个概念！那么只有我们把下面这三个方面搞明白，才能真正的了解进程等待！
什么是进程等待！ 进程等待：
进程等待就是通过系统调用wait/waitpid的方式，让父进程对子进程进行资源回收的等待过程！
为什么要有进程等待！ 其中存在进程等待有两种原因
1.防止僵尸进程的产生！（必要的！）因为当子进程退出之后，如果父进程不及时回收子进程的资源时，会导致子进程一直处于僵死状态，就连kill-9也拿他没有任何办法，所以引进了进程等待来解决对操作系统资源的浪费！这一点原因是进程等待存在的必要！
2.既然通过了父进程创建了子进程，那么我们需要知道子进程将任务完成的如何了，此时就引进了进程等待！这也是进程等待存在的一种原因，但是这种原因不是必须的！
既然上面讲到了为什么要有进程等待，那么就不得不介绍进程等待是如何做到的，能满足上述的两种情况！
进程等待是怎么做到的！ 想要了解进程等待是如何做到的，必须要了解有关进程等待的两个系统调用！
首先验证进程等待可以将僵尸进程进行回收！可以写一段代码，让子进程跑起来，然后退出，此刻让父进程先睡会儿，然后通过监视进程窗口观察子进程状态的变化即可验证！
代码如下：
通过复制渠道来进行监视进程的运行状态，其中监视进程的代码如下！：
while : ; do ps ajx |head -1&amp;&amp;ps ajx |grep mytest|grep -v grep; echo "-----------------------------"; sleep 1;done
通过上述的情况可以发现，的确可以通过wait函数将僵尸进程进行杀掉，那么是如何进行杀掉的呢？下面通过介绍两种等待进程的函数即可得到结论！ 1.wait 函数原型：pid_ t wait(int *status);
首先来介绍wait函数，此函数只有一个参数，是一个返回型参数！最后返回进程的状态！其返回值类型是pid_t 类型，如若进程等待成功，那么将会返回子进程的pid！！，如果在fork之前调用wait函数，那么就会出现结果为-1的情况！！
作用：进程一旦调用了wait，就会立刻阻塞自己，由wait分析当前进程中的某个子进程是否已经退出了，如果让它找到这样一个已经变成僵尸进程的子进程，wait会收集这个子进程的信息，并将它彻底销毁后返回；如果没有找到这样一个子进程，wait会一直阻塞直到有一个出现。参数stat_loc用来保存被收集进程退出时的一些状态，它是一个指向int型的指针。但如果对这个子进程是如何死掉的不在乎，咱们可以将它设置为NULL：pid = wait(NULL);如果成功，wait会返回被收集的子进程的进程ID，如果调用进程没有子进程，调用会失败，wait返回-1，同时errno会被设置为ECHILD。
2.waitpid 函数原型：pid_ t waitpid(pid_t pid, int *status, int options);
第一个参数： 相比较与wait函数来言，waitpid的参数有三个！其中第一个参数表示某个子进程的pid，若不想指定特定的子进程，只需要将第一个参数置为-1即可！-1指的是任意子进程！
第二个参数： 其中第二个参数和wait中的参数是一样的，是一种输出型参数，用于返回子进程退出的状态信息！
第三个参数： 第三个参数option代表的是进程的等待方式！其中默认0是阻塞等待方式！
还有一种方式是WNOHANG，其代表的状态是非阻塞式等待！其中其返回值有三种类型！
当正常返回的时候waitpid返回收集到的子进程的进程ID；而调用中waitpid发现没有已退出的子进程可收集,则返回0；如果调用中出错,则返回-1,这时errno会被设置成相应的值以指示错误所在；其中要想看见具体的出错信息可以利用strerror函数来进行打印！
这里再介绍与一下linux中关于进程状态变量的存储方式！
可以看出如果想要观察进程的退出码信息，只需要将status的值右移8位然后按位与上1即可得到退出码的信息！ 对于终止信号的信息来眼，只需要按位与一个0x1F即可获得终止信号信息！
退出码信息：
(status&gt;&gt;8)&amp;0xFF
终止信号信息:
status&amp;0x1F
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d3002f5407f45abf07663c877af1423/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/033e4281cd0712274a2a95ffbddc7a22/" rel="bookmark">
			Vue CLI 初体验之如何创建一个项目并打开，以及组件的简单使用案例。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
什么是Vue CLI?
如何使用Vue CLI 创建一个项目 1.win+r 打开cmd 输入vue create 1127(1127是文件名)
2.配置基础设置
选择Manually select features
选择Router和Vuex
选中vue版本（我这里选vue3）
剩下的看自己需要，如果不确定就一直按回车键下载就可以了
项目创建成功 直接在vscode打开 使用ctrl+j 调出终端选择cmd，输入npm/yarn run serve 点击链接
查看 案例组件的使用
效果预览图
解析 相关代码 组件一
组件二
组件三
组件四
HomeView
什么是Vue CLI? Vue CLI是一个基于Vue.js进行快速开发的完整系统。它提供了多种功能：
交互式的项目脚手架：通过使用@vue/cli命令，可以快速创建一个新的Vue项目框架，方便快捷地搭建基于Vue框架的开发环境3。
零配置原型开发：通过使用@vue/cli和@vue/cli-service-global命令，可以进行零配置的原型开发，快速验证和实验新的想法3。
运行时依赖：Vue CLI提供了一个运行时依赖@vue/cli-service，它是一个基于webpack构建的工具，具有合理的默认配置，并且可以通过项目内的配置文件进行自定义配置。同时，它还可以通过插件进行扩展，集成了前端生态中最好的工具3。
官方插件集合：Vue CLI还提供了丰富的官方插件集合，这些插件集成了前端生态中最好的工具，可以帮助开发者更高效地开发Vue.js项目3。
图形化用户界面：Vue CLI提供了一套完全图形化的用户界面，可以用于创建和管理Vue.js项目，使项目的创建和管理更加直观和方便3。
如何使用Vue CLI 创建一个项目 注意:要先确定自己要在哪一个文件夹里创建项目，并且项目打开后vscode里应该有且仅有一个项目。
1.win+r 打开cmd 输入vue create 1127(1127是文件名) 2.配置基础设置 选择Manually select features 选择Router和Vuex 注意：使用空格键选择是否选中
选中vue版本（我这里选vue3） 剩下的看自己需要，如果不确定就一直按回车键下载就可以了 项目创建成功 直接在vscode打开 使用ctrl+j 调出终端选择cmd，输入npm/yarn run serve 点击链接 查看 接下来你就可以根据自己的项目进行编程了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/033e4281cd0712274a2a95ffbddc7a22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72d697c9d0bb844de27d948a3f2dbe75/" rel="bookmark">
			离线强化学习：Offline RL MOPO环境配置(Ubuntu20.04安装Mujoco、Mujoco-py、D4RL、gym、d3rlpy）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码网址：https://github.com/junming-yang/mopo
配置环境参考网址：Ubuntu20.04安装Mujoco、Mujoco-py、D4RL、gym、d3rlpy
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/061a52afb5ce33bc4ee67a64d338e5df/" rel="bookmark">
			org.springframework.http.converter.HttpMessageNotReadableException: Required request body is missing
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 前端没有传 json 格式的参数
2. GET请求的接口使用了@RequestBody注解
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adff72610ac1a299ef564948fcbd4bec/" rel="bookmark">
			【运维】nginx中root和alias区别和作用是啥
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1、root指令2、alias指令总结： 前言 nginx指定文件路径有两种方式root和alias，这两者的用法区别，使用方法总结了下，方便大家在应用过程中，快速响应。root与alias主要区别在于nginx如何解释location后面的uri，这会使两者分别以不同的方式将请求映射到服务器文件上。
1、root指令 用于指定服务器文件的根目录，nginx会将location后面的uri与root指令指定的路径拼接起来，作为最终的文件路径。例如：
location /dist/ { root /usr/share/nginx/html; } root是拼接
当请求/dist/static/css/style.css时，nginx会将其映射到/usr/share/nginx/html/dist/static/css/style.css文件上。
2、alias指令 用于指定服务器文件的别名，nginx会将location后面的uri替换为alias指令指定的路径，作为最终的文件路径。例如：
location /dist/ { alias /usr/share/nginx/html; } alias是替换
当请求/dist/static/css/style.css时，nginx会将其映射到/usr/share/nginx/html/static/css/style.css文件上。
因此，root和alias的主要区别在于nginx如何解释location后面的uri，这会使两者分别以不同的方式将请求映射到服务器文件上。
总结： root指令：
root指令用于定义根目录，即服务器上所有请求的基础目录。
当使用root指令时，Nginx会将请求的URI附加到根目录路径后面来查找文件。
例如，如果设置了root /usr/share/nginx/html;，并且客户端请求http://example.com/index.html，Nginx会在/usr/share/nginx/html目录下寻找并返回index.html文件。
alias指令：
alias指令也用于定义一个目录，但它允许你为请求的URI提供替代路径。
使用alias指令时，Nginx会将匹配到的部分路径替换为指定的目录路径。
例如，如果设置了location /images/ { alias /usr/share/nginx/html; }，并且客户端请求http://example.com/images/photo.jpg，Nginx会将/images替换为/usr/share/nginx/html，然后在该目录下寻找并返回photo.jpg文件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a869fe6bba34bafcca410bba358012bf/" rel="bookmark">
			我是标题123
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内容测试
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a8728f220008f5e2e90047305252686/" rel="bookmark">
			微信小程序防微信聊天界面（scroll-view滚动、下拉刷新、键盘弹起不遮挡文字、苹果手机底部安全距离处理等）细节处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.图形界面展示如下 2.scroll-view详解 //1.分析：对话有很多种格式，我们需要封装一个组件作为对话的子组件展示我们消息的内容 //2.scroll-view 每次消息返回都要滚动到最新的一条数据 利用对话里面唯一id和scroll-into-view去实现 //wxml代码如下 &lt;!-- 消息滚动区域 开始 --&gt; &lt;scroll-view bindrefresherrefresh="freshPages" refresher-triggered="{{triggered}}" refresher-enabled="{{true}}" class="scroll-wrapper" style="height:{{scrollHeight}}" scroll-into-view="{{scrollTo}}" scroll-y="true" scroll-with-animation="{{true}}"&gt; &lt;!-- &lt;view class="record-wrapper"&gt; --&gt; &lt;chat-items ref="chatItem" id="item{{index}}" message="{{item.message}}" &gt; &lt;/chat-items&gt; &lt;/scroll-view&gt; &lt;!-- 消息滚动区域 结束 --&gt; //js代码如下：messageList是你的消息数组 this.setData({ scrollTo:`item${this.data.messageList.length - 1}` })//实现消息滚动到底部 this.setData({ scrollHeight:this.data.inputShow ? '76%' : '90%' })//实现有输入框和无数框的时候的scroll-view的动态高度 3.下拉刷新 //triggered: false, //是否开始自定义下拉刷新（）在data定义 freshPages(){ if(this.data.lastPage){ //最后一页 this.setData({ triggered:false }) wx.showToast({ title:'没有更多了~', icon:'none', duration:3000 }) }else{ this.setData({ pageNum:this.data.pageNum + 1 }) this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a8728f220008f5e2e90047305252686/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed292d037fa813bc6718edbd42dd930d/" rel="bookmark">
			uniapp自定义tabBar
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
uniapp自定义tabBar方案
一、pages.json文件中添加tarBar
二、把原生的tabBar隐藏起来
三、自定义一个tabBar组件
四、全局引用组件
五、路由跳转
自定义switchTab
在app中$route找不到的问题
六、相关代码
七、可拖拽式
相关代码
uniapp自定义tabBar方案 该方案，可以在切换tabBar的时候，路由也跟着变化，方便平时进行页面测试使用，不过有个缺点，第一次切换的时候会出现闪烁现象。
解决闪烁的问题：
1、可以把tabBar和页面组件都放在单页中用v-if判断，进行切换，单页切换的缺点是不能进行路由跳转（不能路由跳转）
&lt;template&gt; &lt;view&gt; &lt;index&gt;&lt;/index&gt; &lt;my&gt;&lt;/my&gt; &lt;team&gt;&lt;/team&gt; &lt;promotion&gt;&lt;/promotion&gt; &lt;tab-bar&gt;&lt;/tab-bar&gt; &lt;/view&gt; &lt;/view&gt; &lt;/template&gt; 2、把组件注入App.vue中，实现全局引用，但是uniapp不建议在App.vue中使用页面组件，也不要使用，不然出现各种问题，uniapp不能像vue那样在App.vue使用router-view实现选项卡功能（不推荐）
3、 所以要同时实现首次不闪烁，而且可以进行路由切换的功能，目前不知道如何处理。（有个取巧的方式就是用uni-transition包裹一下，使得第一次加载有个过渡效果）
首次加载闪烁，严格意义上说，可以被认定为bug。小编在想能不能用vue的路由方式去实现router-view呢？因此尝试的去自定义router-view，却发现uniapp内置了路由，当想用vue插件方式，重写路由时，发现冲突了。
其实关于自定义，在uniapp中，官方目前不推荐大家去自定义的，如果业务场景需要根据不同权限，显示不同tabBar，我们可以去跟需求谈，换另外一方式，也是可以的。例如用下图的方式
（方案还有需要完善的地方，这里仅供大家参考）
一、pages.json文件中添加tarBar 因为需要用到tabBar跳转，因此可以往原来的tabBar.list中多添加几个,用于做判断是否tabBar切换(这里可以只添加路径，icon和text可以不需要)
二、把原生的tabBar隐藏起来 在App.vue中把原生的tabBar先隐藏起来，同时添加一个removeStorageSync，用于移除使用的tabBar的下标。
onLaunch: function() { console.log('App Launch') uni.hideTabBar() uni.removeStorageSync('selectedIndex'); }, 三、自定义一个tabBar组件 在components中新建一个tabBar.vue的页面，用来封装组件
HTML代码，这里循环遍历自己定义的tabBar.list(可根据需求来定义)
这里用了uni-transition组件包裹，这个组件需要到插件市场自行安装，这里用uni-transition是为了让加载的时候闪烁不那么明显。
&lt;template&gt; &lt;uni-transition mode-class="fade" :duration="200" :show="true"&gt; &lt;view&gt; &lt;view class="tab-content"&gt; &lt;slot /&gt; &lt;/view&gt; &lt;view class="tabbar"&gt; &lt;view class="navigator"&gt; &lt;view ref='warpper' class="warpper"&gt; &lt;view ref="navItem" class="navigator-item" v-for="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed292d037fa813bc6718edbd42dd930d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/471d0f37602ac7d6dcef7d0bdc36e717/" rel="bookmark">
			Java面试题及答案整理（2023年11月最新版，持续更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024年马上快到了，发现网上很多Java面试题都没有答案，所以花了很长时间搜集整理出来了这套Java面试题大全~
这套互联网 Java 工程师面试题包括了：MyBatis、ZK、Dubbo、EL、Redis、MySQL、并发编程、Java面试、Spring、微服务、Linux、Springboot、SpringCloud、MQ、Kafka 面试专题
一、Java 基础
1. JDK 和 JRE 有什么区别？
JDK：Java Development Kit 的简称，java 开发工具包，提供了 java 的开发环境和运行环境。JRE：Java Runtime Environment 的简称，java 运行环境，为 java 的运行提供了所需环境。 具体来说 JDK 其实包含了 JRE，同时还包含了编译 java 源码的编译器 javac，还包含了很多 java 程序调试和分析的工具。简单来说：如果你需要运行 java 程序，只需安装 JRE 就可以了，如果你需要编写 java 程序，需要安装 JDK。
2. == 和 equals 的区别是什么？
== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。
3. 两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？
不对，两个对象的 hashCode()相同，equals()不一定 true。
代码解读：很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode()相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/471d0f37602ac7d6dcef7d0bdc36e717/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6010e8b1ce4d4ae77923ecf8ce9e9a25/" rel="bookmark">
			本地Nginx服务搭建结合内网穿透实现多个Windows Web站点公网访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 下载windows版Nginx2. 配置Nginx3. 测试局域网访问4. cpolar内网穿透5. 测试公网访问6. 配置固定二级子域名7. 测试访问公网固定二级子域名 1. 下载windows版Nginx 进入官方网站(http://nginx.org/en/download.html)下载windows版的nginx
下载好后解压进入nginx目录双击Nginx.exe即可运行
打开浏览器输入http://localhost ,nginx默认使用80端口,所以无需加端口号.出现nginx欢迎页面表示启动成功
2. 配置Nginx 在8086,和9999端口分别配置两个web服务,这里不详细说如何搭建web站点服务,可以参考该教程:https://www.cpolar.com/blog/build-web-server-in-windows-system
站点搭建好后,接下来需要修改nginx.conf配置文件,打开nginx目录,找到conf文件夹下面的nginx.conf
编辑文件,这里使用notepad++进行编辑,添加如下信息:
location ^~ /webs/ { proxy_pass http://127.0.0.1:8086/; } location ^~ /webc/ { proxy_pass http://127.0.0.1:9999/; } 参数简介(详情请看官方文档): ^~ : 表示开头对URL路径进行前缀匹配,并且在正则之前 proxy_pass: 代理的服务地址 编辑完保存,打开cmd窗口,进入nginx目录,执行如下命令重启:
nginx.exe -s reload 3. 测试局域网访问 重启后Nginx后，打开浏览器,以80端口加上在配置文件中配置的location代理转发规则进行访问两个站点:
4. cpolar内网穿透 接下来,我们通过强大的且稳定的内网穿透工具cpolar，将本地nginx服务暴露至公网环境,以实现穿透多个站点端口需求，无需公网IP，也不用设置路由器。
cpolar官网：https://www.cpolar.com/
打开cpolar官网，下载cpolar并安装。安装完成后，在浏览器上访问本地9200端口【http://localhost:9200/】，登录进入cpolar web ui管理界面。
点击左侧的隧道管理——创建隧道：
隧道名称：可自定义，注意不要与已有的隧道名称重复协议：http协议本地地址：80域名类型：免费选择随机域名地区：选择china vip 点击创建
隧道创建成功后，点击左侧的状态——在线隧道列表，可以看到已经有生成了相应的公网地址，将其复制下来。
5. 测试公网访问 打开浏览器，使用cpolar所生成的公网地址+在配置文件中配置的location代理转发规则来访问两个站点，测试访问成功。
6. 配置固定二级子域名 由于以上使用的cpolar所生成的公网地址为随机临时地址，24小时内会随机变化，我们可以为其配置固定的二级子域名。
注意，配置固定二级子域名需要将cpolar套餐升级至基础套餐或以上。
进入cpolar官网并登录进入后台界面，点击左侧的预留，找到保留二级子域名:
地区：选择China
二级域名：可自定义
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6010e8b1ce4d4ae77923ecf8ce9e9a25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18f3d8d84b8519f858df4bd8190245c4/" rel="bookmark">
			liunx下pyttsx3 &#43; espeak &#43; mbrola（中文cn1）整合实录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经过两天对mbrola的实际使用，对之前调用“文心一言”语言模型进行了深一步的后续开发，将文字转成语音（tts）。
首先介绍下环境，liunx系统用的centos7（low了，当初买ubuntu好了），python3。
加载pytsx3的过程就不再赘述了，上篇文章有所记录，下面直接对espeak的安装，mbrola这个语音包如何安装到centos上，如何把mb的中文语音（cn1）引入espeak上并使用进行一下介绍，希望能帮助到要使用和学习的人。
由于centos7的yum工具对mbrola不支持，只能自己下载。
mbrola相关文件 这个地址下有三个文件夹（第三个很重要）
1.MBROLA-master //mbrola可执行文件下载到服务器需要make下 2.cn1 //中文语音包 3.voicesMb //espeak-data下 voices/mb 文件夹下的执行文件 接下来开始安装espeak
1.先安装 EPEL 仓库： sudo yum install epel-release 2.然后安装 espeak： sudo yum install espeak 安装mbrola、cn1语音包、mb-cn1文件
1.下载 MBROLA-master.zip 包，并且将其放到任意文件夹内进行解压并且make操作 2.执行完make会在解压文件夹内生成一个Bin的文件夹，里面有个mbrola文件，将其拷贝到 /usr/bin/ 文件夹下 3.增加权限 sudo chmod +x /usr/bin/mbrola 4.下载cn1语音文件 5.创建mb语音文件夹 sudo mkdir -p /usr/share/mbrola/voices/ 6.把cn1文件拷贝到 /usr/share/mbrola/voices/之下 7.修改espeak读取的mb路径 export MBROLA_PATH="/usr/share/mbrola/voices" 8.把mb-cn1文件拷贝到 /usr/share/espeak-data/voices/mb/ (以个人安装的espeak的data路径为准) 这里有个语音配置就是mb-cn1这个文件，内容如下
name chinese-mb-cn1 language zh mbrola cn1 zh_phtrans pitch 82 117 //关键在这，这个是高低音的设置，可以自己根据自己的感觉进行调教 speed 105 //语速 mbrola cn1 cn1_phtrans pyttsx3加载cn1语音包进行中文读取
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18f3d8d84b8519f858df4bd8190245c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b6f002f7b77843efea382812eaaad57/" rel="bookmark">
			框架版本高于当前目标框架“.NETFramework,Version=v4.6.1“以及如何下载并更改.NETFramework
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一部分：框架版本高于当前目标框架“.NETFramework,Version=v4.6.1” 事情原由：同事给予一版C# Code，但是他的Framework(V4.7.2),自己本机最高框架只有Framework(V4.6.1)。因此选择了“更改目标框架以适应当前VS的”（之前也有框架版本不符合的时候，选择了这种方式，大都可以顺利运行Code，但是本次没有成功）。报了如下错误：
设想解决方案有两种：
1.我这边打开程式解决方案，将目标框架参照同事的进行配置：Framework(V4.7.2)，但是我电脑上没有这个框架呀!!!
2.同事那边生成低Framework版本的程式给我，但是效果也不太理想，因为程式可能会出错!!!
（同事按照上方的形式进行切换框架后，报了如下错误!）：
总的来说：
（1）因为本机上没有高框架Framework(V4.7.2)，因此更改目标框架以适应当前VS的。但是，还是无法成功运行。
(2)让同事降低框架版本后再发给我，但是由于其降低框架版本，可能会导致程式中的Code无法正常运行，因此也不行，
那么就只找方法，来提升我电脑上的框架了，使其能运行.NETFramework,Version=V4.7.2的内容。那么如何提升呢?
第二部分：下载并更改.Net Framework目标框架（以2017版VS为例） 1.进入VS主界面后，点击工具-&gt;获取工具和功能。勾选需要的目标框架。
注：更改安装时，VS需关闭，所以如有打开VS中的项目代码请先保存好；
2.下载完成后，再重新打开同事给的Code，就可以成功运行了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/419d8780674d2ac5eb3e9e1d53b9ae7f/" rel="bookmark">
			centos7部署flask项目ssl证书&#43;https请求/http请求(uwsgi&#43;nginx&#43;flask)&#43;nginx负载均衡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 环境说明2. 环境准备3. 搭建虚拟环境4. 创建uwsgi配置文件5. 安装nginx5.1 http请求添加如下内容5.2 https请求添加如下内容 6. 部署时加上nginx做负载均衡6.1 nginx配置文件6.2 uwsgi配置文件 7. 配置常用命令8. 502访问不到页面 1. 环境说明 服务器Centos7python 3.6flask项目 2. 环境准备 Centos7自带的python版本是2.7,所以需要手动安装python3.6 版本,参考我这篇文章https://blog.csdn.net/weixin_44232093/article/details/105248148 3. 搭建虚拟环境 # 下载虚拟环境包 pip3 install virtualenv # 使用命令新建虚拟环境，我的目录是/usr # 创建虚拟环境名叫 venv ,如果你是参考我的文章安装的python # 那么和我的路径保持一致即可,如果在这一步提示bash: virtualenv: 未找到命令...,执行以下命令 # 添加环境变量 vim /etc/profile # 将下面内容添加到文件的最下面 PATH=$PATH:/usr/local/python3/bin # 添加后修改 :wq保存退出 配置文件生效命令 source /etc/profile # 最后查看是否添加成功 echo $PATH --------------------------------------------------------------------------------------------- # 指定虚拟环境的python版本 这里指定3.6 virtualenv -p /usr/local/bin/python3 venv # 激活虚拟环境 source后加你自己的venv目录路径 /bin/activate source venv/bin/activate # 查看当前虚拟环境的python版本 python -V # 在虚拟环境中安装flask、uwsgi库 pip install uwsgi pip install flask # 也可以指定 requirements.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/419d8780674d2ac5eb3e9e1d53b9ae7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be2bac4040a50b2f5df23b19695cd9ba/" rel="bookmark">
			Vue3经典面试题总结：对Teleport的理解及作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📌大前端入门到精通 专栏正在持续更新中，案例的原理图解析、各种模块分析💖这里都有哦，同时也欢迎大家订阅专栏，获取更多详细信息哦✊✊✊
✨个人主页：零小唬的博客主页
🥂欢迎大家 👍点赞 📨评论 🔔收藏
✨作者简介：20级计算机专业学生一枚，来自宁夏，可能会去做大前端，目前还在努力学习并记录博客中🧸
🎀本系列专栏: 大前端入门到精通
💕希望本文对你在学习前端的过程中有所帮助，如有不足请指正一起学习，一起进步🥇
⛪座右铭：只要你还愿意努力，世界一定会给你惊喜
在vue3中，Teleport是一种新的组件，它可以让我们更容易地在DOM树中的任何地方渲染组件内容，而不需要挂载到全局DOM中。
具体来说，Teleport允许将组件的内容渲染到一个指定的目标位置，而不必遵循父组件的层次结构。这样就有一个好处就是可以在组件层次之外进行渲染，比如：弹出窗口、对话框以及模态框。通过使用Teleport，可以将组件的内容传送到任何位置，包括body元素或者其他具有特定CSS类的容器元素。
Teleport 的作用是提供了更大的灵活性和可重用性。平时，为了在组件之外渲染内容，我们需要手动创建一个容器元素，并手动将组件的内容渲染到该容器中。而 Teleport 提供了一个更简单和优雅的方式来实现这一目标，通过指定一个目标位置，将组件的内容直接传送到指定位置，无需手动创建容器。
示例代码（模态框）
&lt;template&gt; &lt;div&gt; &lt;button @click="showModal = true"&gt;打开模态框&lt;/button&gt; &lt;teleport to="body"&gt; &lt;Modal v-if="showModal" @close="showModal = false"&gt; 模态框的内容 &lt;/Modal&gt; &lt;/teleport&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { ref } from 'vue'; import Modal from './Modal.vue'; export default { components: { Modal, }, setup() { //vue3的写法，主要是利用ref创建了一个响应式数据变量 const showModal = ref(false); return { // 通过ref创建的数据需要使用.value才可以拿到数据的值 showModal, }; }, }; &lt;/script&gt; 在上面的代码中，当点击按钮时，会将 Modal 组件的内容传送到 body 元素中进行渲染，实现了在组件之外渲染模态框的效果。通过使用 Teleport，我们可以更方便地控制组件内容的位置，提高了组件的灵活性和可重用性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be2bac4040a50b2f5df23b19695cd9ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/971ebd4d94f9094400855d65c4147b00/" rel="bookmark">
			vue面试题：路由模式你知道哪些
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📌大前端入门到精通 专栏正在持续更新中，案例的原理图解析、各种模块分析💖这里都有哦，同时也欢迎大家订阅专栏，获取更多详细信息哦✊✊✊
✨个人主页：零小唬的博客主页
🥂欢迎大家 👍点赞 📨评论 🔔收藏
✨作者简介：20级计算机专业学生一枚，来自宁夏，可能会去做大前端，目前还在努力学习并记录博客中🧸
🎀本系列专栏: 大前端入门到精通
💕希望本文对你在学习前端的过程中有所帮助，如有不足请指正一起学习，一起进步🥇
⛪座右铭：只要你还愿意努力，世界一定会给你惊喜
Vue中的路由模式是通过Vue Router实现的，它允许我们构建单页应用，实现SPA（Single Page Application）的效果。
两种常见的路由模式是：哈希模式（Hash Mode）和历史模式（History Mode）
哈希模式（Hash Mode）
在哈希模式下，URL中会出现类似#的哈希符号,例如：http://www.example.com/#/home当URL发生变化时，页面不会重新加载，而是通过监听hashchange事件来实现路由的切换优点是兼容性好，可以支持老版本浏览器；缺点是URL不够干净，不够语义化 历史模式（History Mode）
在历史模式下，URL中不会出现哈希符号（#），而是直接使用传统的路径格式，例如：http://www.example.com/home使用HTML5 History API来管理路由，可以通过浏览器的前进、后退按钮实现路由的切换优点是URL干净、语义化，更符合传统网站的URL格式；缺点是需要服务端配合，以处理在刷新页面时的路由问题 在Vue中，配置路由模式的方式也略有不同：
Vue 2中，需要在创建Vue Router实例时显式地指定路由模式 export default new VueRouter({ mode: 'hash',//设置路由模式 base: process.env.BASE_URL, routes }) Vue 3中，可以通过createWebHistory和createWebHashHistory等函数来创建路由模式对应的实例 import { createRouter, createWebHistory , createWebHashHistory } from "vue-router"; export default createRouter({ history: createWebHistory(),//定义history模式url不带# history: createWebHashHistory(),//定义hash模式 routes: [], });	🎉记录是为了不停的思考，创作更是为了更好的思考，有人说过：2023年以后的中国市场将永远属于长期主义者，bug是改不完的，只能说这次遇到了希望下次不会在出现同样的bug就行，如果你觉得对您有帮助，欢迎一起交流学习，本人也是一名很菜的20级学生，编程界的小白，一起加油变优秀啦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42cc266f39e2b6b97de0d30ed64ccea0/" rel="bookmark">
			MVC、MVP、MVVM三种区别及适用场合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MVC模式最初生根于服务器端的Web开发，后来渐渐能够胜任客户端Web开发，能够满足其复杂性和丰富性。
MVC:是 Model-View-Controller 的缩写，它将应用程序划分为三个部分：
1.视图(View)：用户界面，只负责渲染HTML
2.控制器(Controller)：业务逻辑，负责调度model和view
3.模型(Model)：数据保存，只负责存储数据，请求数据，更新数据
MVC允许在不改变视图的情况下改变视图对用户输入的响应方式，用户对view操作交给Controller处理在Controller中响应View的事件调用Model的接口对数据进行操作，一旦Model发生变化便通知相关View进行更新。接受用户指令时，MVC可以分成两种方式。一种是通过View接受输入，传递给Controller。另一种是直接通过Controller接受指令。
MVC流程：
MVC流程一共有两种，在日常开发中都会使用到。
一种是通过 View 接受指令，传递给 Controller，然后对模型进行修改或者查找底层数据，最后把改动渲染在视图上。
另一种是通过controller接受指令，传给Controller：
在MVC中，View会直接从Model中读取数据而不是通过 Controller。
MVC优点：
1.耦合性低，视图层和业务层分离，这样就允许更改视图层代码而不用重新编译模型和控制器代码。
2.重用性高
3.生命周期成本低
4.MVC使开发和维护用户接口的技术含量降低
5.可维护性高，分离视图层和业务逻辑层也使得WEB应用更易于维护和修改
6.部署快
MVC缺点：
不适合小型，中等规模的应用程序，花费大量时间将MVC应用到规模并不是很大的应用程序通常会得不偿失。
视图与控制器间过于紧密连接，视图与控制器是相互分离，但却是联系紧密的部件，视图没有控制器的存在，其应用是很有限的，反之亦然，这样就妨碍了他们的独立重用。
视图对模型数据的低效率访问，依据模型操作接口的不同，视图可能需要多次调用才能获得足够的显示数据。对未变化数据的不必要的频繁访问，也将损害操作性能。
MVC应用：在web app 流行之初， MVC 就应用在了java(struts2)和C#(ASP.NET)服务端应用中，后来在客户端应用程序中，基于MVC模式，AngularJS应运而生。
MVP：(Model-View-Presenter)是MVC的改良模式，由IBM的子公司Taligent提出。和MVC的相同之处在于：Controller/Presenter负责业务逻辑，Model管理数据，View负责显示只不过是将 Controller 改名为 Presenter，同时改变了通信方向。
MVP特点：
M、V、P之间双向通信。View 与 Model 不通信，都通过 Presenter 传递。Presenter完全把Model和View进行了分离，主要的程序逻辑在Presenter里实现。View 非常薄，不部署任何业务逻辑，称为”被动视图”(Passive View)，即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。Presenter与具体的View是没有直接关联的，而是通过定义好的接口进行交互，从而使得在变更View时候可以保持Presenter的不变，这样就可以重用。不仅如此，还可以编写测试用的View，模拟用户的各种操作，从而实现对Presenter的测试–从而不需要使用自动化的测试工具。
在MVP中，View并不直接使用Model，它们之间的通信是通过Presenter (MVC中的Controller)来进行的，所有的交互都发生在Presenter内部。
MVP优点：
模型与视图完全分离，我们可以修改视图而不影响模型；可以更高效地使用模型，因为所有的交互都发生在一个地方——Presenter内部；我们可以将一个Presenter用于多个视图，而不需要改变Presenter的逻辑。这个特性非常的有用，因为视图的变化总是比模型的变化频繁；如果我们把逻辑放在Presenter中，那么我们就可以脱离用户接口来测试这些逻辑(单元测试)。MVP缺点：视图和Presenter的交互会过于频繁，使得他们的联系过于紧密。也就是说，一旦视图变更了，presenter也要变更。
MVP应用：可应用与Android开发。
MVVM：是Model-View-ViewModel的简写。
微软的WPF(Windows Presentation Foundation–微软推出的基于Windows 的用户界面框架)带来了新的技术体验, 使得软件UI层更加细节化、可定制化。
与此同时，在技术层面，WPF也带来了 诸如Binding(绑定)、Dependency Property(依赖属性)、Routed Events(路由事件)、Command(命令)、DataTemplate(数据模板)、ControlTemplate(控制模板)等新特性。
MVVM模式其实是MV模式与WPF结合的应用方式时发展演变过来的一种新型架构模式。它立足于原有MVP框架并且把WPF的新特性糅合进去，以应对客户日益复杂的需求变化。
MVVM模式将Presenter改名为ViewModel，基本上与MVP模式一致。唯一的区别是，它采用了双向绑定(data-binding),View的变动，自动反应在ViewModel，反之亦然。
MVVM优点：
MVVM模式和MVC模式类似，主要目的是分离视图(View)和模型(Model)，有几大优点：
低耦合，视图(View)可以独立于Model变化和修改，一个ViewModel可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。
可重用性，可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。
独立开发，开发人员可以专注于业务逻辑和数据的开发(ViewModel)，设计人员可以专注于页面设计，使用Expression Blend可以很容易设计界面并生成xml代码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42cc266f39e2b6b97de0d30ed64ccea0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df6ab7a6a6397a9a09bc8ebac52d2be4/" rel="bookmark">
			什么是好的FPGA编码风格？（3）--尽量不要使用锁存器Latch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在FPGA设计中，几乎没人会主动使用锁存器Latch，但有时候不知不觉中你的设计莫名其妙地就生成了一堆Latch，而这些Latch可能会给你带来巨大的麻烦。
什么是锁存器Latch？ Latch，锁存器，一种可以存储电路状态信息的组合逻辑元件，和同样可以保存电路状态的时序逻辑元件–触发器（Flip-Flop，FF）不同，锁存器只在其使能端口有效时，将输入传递给输出；而在其使能端口无效时，输出则保持不变，就像被“锁住储存”起来了一样。
下图是一个典型的Latch的门电路结构。当使能信号E无效时，两个与门的输出均为0，对后面的SR锁存器即或非门无影响，所以无论输入D的值为1或0，输出Q的值都不会改变，就像被“锁住”了。
当使能信号E有效且输入D为1时，两个与门的输出分别为0和1、此时的输出Q值为1，与输入D一致。
当使能信号E有效且输入D为0时，两个与门的输出分别为1和0、此时的输出Q值为0，同样与输入D一致。
Latch有什么危害？ 当Latch的使能信号有效时，直接让输入信号通过，使得输出完全等于输入。这一特性无疑会很容易地引入毛刺，使得设计不稳定；其次，Latch没有时钟信号，是一个异步电路元件，这就使得综合工具对Latch的静态时序分析十分困难。
而同步逻辑所使用的触发器FF，它的典型结构是这样的，由2个Latch+1个反相器组成。
当时钟信号Clock为高电平时，第1个Latch的使能有效，输入数据直接通过；由于反向器的存在，第2个Latch的使能端无效，所以其输出保持不变。
当时钟信号Clock为低电平时，第1个Latch使能无效，其输出保持不变，而这个输出也就是在时钟信号处于下降沿时的输入信号；由于反向器的存在，第2个Latch的使能端有效，输入直接传递到输出，此时最终输出的是在时钟下降沿时采集的输入信号。
可以看到，在同步电路中，FF的输出只在时钟边沿（这里是下降沿）变化，而在其他时间是保持不变的，这样一来，即使某些时刻在输入上出现了毛刺，但只要这个毛刺不发生在时钟边沿，那它就不会传递到输出进而影响后面的电路。
显然，同一个时钟周期比起来，时钟边沿持续的时间实在是微不足道，所以这大大降低了毛刺影响电路的概率。这也是同步电路相对于异步电路的一个大优点。
什么样的代码会生成Latch 下面的一些代码风格是会生成Latch的：
if-else语句不完整的组合逻辑 在组合逻辑中，如果if-else语句没有写完整的话，是会生成Latch的（不管你是有意还是无意的），因为缺失掉的条件会被综合工具理解成不变，即锁存。
module test( input data, input en, output reg	q ); always@(*)begin if(en) q = data; end endmodule Vivado中生成的RTL电路如下–一个Latch。
生成Latch的时候，Vivado也会报警告，所以设计的时候请务必多多关注这些信息！
有些时候，尽管你的if-else语句已经很完整了，也还是会生成Latch，就像这样：
module test( input data, input en, output reg	q ); always@(*)begin if(en) q = data; else	q = q;	//输出反馈给了输入，相当于没变 end endmodule 这是因为输出直接反馈给了输入，使得输出等于输入，相当于没变化，依然是被锁存住了。
消除Latch的方法有两种：
1、补全if-else语句。注意不能将输出反馈给输入，而是应该给输入赋一个其他值，例如0、1或其他变量。 module test( input data, input en, output reg	q ); always@(*)begin if(en) q = data; else	q = 1'b0;	//q = 1'b1也可以 end endmodule 2、赋初值。在条件语句之前给输出一个初始值。 module test( input data, input en, output reg	q ); always@(*)begin q = 1'b0;	//q = 1'b1也可以 if(en) q = data; end endmodule 两种方法中推荐第一种方法，因为比较规范，代码风格容易统一。这样的代码不会生成Latch，而是生成一个组合逻辑用的2选1MUX：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df6ab7a6a6397a9a09bc8ebac52d2be4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7be0e8b6a3e292e9b57f9a352b3150e3/" rel="bookmark">
			如何下载OpenEuler Linux的iso镜像？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何下载OpenEuler Linux的iso镜像 方法一：通过官网下载
链接：https://www.openeuler.org/zh/download/archive/
//选择需要的镜像版本和对应的架构和场景进行筛选，找到想要的版本，点击前往下载到对应的下载页面。
方法二：阿里云镜像库
链接：https://mirrors.aliyun.com/openeuler/
//选择对应版本下载。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3041a65c342f4a3930853d9591405a5d/" rel="bookmark">
			（二）Linux系统安装显卡驱动（GPU-Pytorch）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、查看是否已安装显卡驱动 nvidia-smi: 如果你使用的是NVIDIA显卡，这个命令可人显示显卡的状态和驱动程序的版本总之，Linux系统中查看显卡驱动的方法有很多种，可以根据自己的需求选择适合自己的方法相关问题。
命令行输入：nvidia-smi
1.下面显示的是未安装显卡
sxw@sxw-server:~$ nvidia-smi Command 'nvidia-smi' not found, but can be installed with: sudo apt install nvidia-utils-390 # version 390.157-0ubuntu0.22.04.2, or sudo apt install nvidia-utils-418-server # version 418.226.00-0ubuntu5~0.22.04.1 sudo apt install nvidia-utils-450-server # version 450.248.02-0ubuntu0.22.04.1 sudo apt install nvidia-utils-470 # version 470.199.02-0ubuntu0.22.04.1 sudo apt install nvidia-utils-470-server # version 470.199.02-0ubuntu0.22.04.1 sudo apt install nvidia-utils-525 # version 525.125.06-0ubuntu0.22.04.1 sudo apt install nvidia-utils-525-server # version 525.125.06-0ubuntu0.22.04.1 sudo apt install nvidia-utils-535 # version 535.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3041a65c342f4a3930853d9591405a5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19af2f8d97ed769c88b647268cce2933/" rel="bookmark">
			基于java&#43;mysql的swing&#43;mysql学生管理系统java基础gui(java&#43;gui)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于java+mysql的swing+mysql学生管理系统java基础gui(java+gui)
私信源码获取及调试交流
运行环境
Java≥8、MySQL≥5.7
开发工具
eclipse/idea/myeclipse/sts等均可配置运行
适用
课程设计，大作业，毕业设计，项目练习，学习演示等
功能说明
基于java+mysql的Swing+MySQL学生管理系统java基础gui(java+gui)
功能介绍：
学生信息管理，姓名，编号，性别，成绩，学号住址
}finally{ try { dbUtil.closeCon(con); } catch (Exception e) { // TODO Auto-generated catch block e.printStackTrace(); } } } /** * 重置表单 */ private void resetValue(){ this.idTxt.setText(""); this.nameTxt.setText(""); this.snTxt.setText(""); this.deptTxt.setText(""); this.manJrb.setSelected(true); this.addressTxt.setText(""); if(this.schoolClassJcb.getItemCount()&gt;0){ this.schoolClassJcb.setSelectedIndex(0); } } /** * 表格行点击事件处理 * @param met */ private void studentTableMousePressed(MouseEvent met) { int row=this.studentTable.getSelectedRow(); this.idTxt.setText((String)studentTable.getValueAt(row, 0)); this.nameTxt.setText((String)studentTable.getValueAt(row, 1)); this.snTxt.setText((String)studentTable.getValueAt(row, 2)); String sex=(String)studentTable.getValueAt(row, 3); if("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19af2f8d97ed769c88b647268cce2933/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/844edcd87c69e1d580bfad01c01002b9/" rel="bookmark">
			Java中MapDB使用简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.简介 在这篇文章中，我们将研究 MapDB 库 - 一个通过类似集合的 API 访问的嵌入式数据库引擎。
我们首先探讨核心类 DB 和 DBMaker，它们帮助配置、打开和管理我们的数据库。然后，我们将深入研究一些存储和检索数据的 MapDB 数据结构的例子。
最后，我们将看一下一些内存模式，然后将 MapDB 与传统数据库和 Java 集合进行比较。
后文代码演示使用的依赖包版本如下
&lt;dependency&gt; &lt;groupId&gt;org.mapdb&lt;/groupId&gt; &lt;artifactId&gt;mapdb&lt;/artifactId&gt; &lt;version&gt;3.0.10&lt;/version&gt; &lt;/dependency&gt; 2.在MapDB中存储数据 首先，让我们介绍一下在这个教程中我们将经常使用的两个类 —— DB和DBMaker。DB类代表一个打开的数据库。它的方法调用用于创建和关闭存储集合以处理数据库记录，以及处理事务事件的动作。
DBMaker处理数据库配置，创建和打开。作为配置的一部分，我们可以选择将我们的数据库托管在内存中或者在我们的文件系统上。
2.1. 一个HashMap的简单样例 @Test public void testMapDb() { DB db = DBMaker.fileDB("file.db").make(); String welcomeMessageKey = "Welcome Message"; String welcomeMessageString = "Hello Baeldung!"; HTreeMap myMap = db.hashMap("myMap").createOrOpen(); myMap.put(welcomeMessageKey, welcomeMessageString); String welcomeMessageFromDB = (String) myMap.get(welcomeMessageKey); assertEquals(welcomeMessageString, welcomeMessageFromDB); db.close(); } 首先，让我们使用DBMaker类创建一个新的内存数据库：
一旦我们的DB对象启动并运行，我们就可以使用它来构建一个HTreeMap来处理我们的数据库记录：
HTreeMap是MapDB的HashMap实现。所以，现在我们的数据库中有数据了，我们可以使用get方法来获取数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/844edcd87c69e1d580bfad01c01002b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70ecc08fa415de86e67074b3f7a580a0/" rel="bookmark">
			wpf 使用 StringFormat
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在xaml里使用StringFormat,将两个字符串拼起来，一个字符串时固定不变的，一个字符串是动态绑定，如：平均密度：绑定的值
代码如下：
&lt;TextBlock Margin="0,0,0,0" Text="{Binding CellAverageDensity, StringFormat='{}平均密度：{0}'}" Style="{StaticResource TextBlockMediumStyle}" HorizontalAlignment="Left"/&gt; 在cs里，用的是 String.Format方法
string msg = String.Format("{0} {1} {2:x2} {3:x2} {4:x2} {5:x2} {6:x2} {7:x2} {8:x2} {9:x2} to handle {10}", id, dlc, data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7], _handle); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4abb681f3f7051a00102c93094da6ad0/" rel="bookmark">
			python桌面开发PyQt6库和工具库QTDesigner安装和配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、安装PyQt6 二、安装pyqt6-tools 三、安装外部工具 四、创建QTDesigner 1.首先查找designer.exe的路径（可以自己在窗口中选择，也可以使用Everything搜索） 2.使用Everything搜索后会出现多个designer.exe,选中，OpenPath 3.选择含有qt6_applications的路径，还要注意你的安装环境（我的是conda,如果你的是python就使用你的python路径） 4.输入路径后，点击“ok” 五、创建pyUIC 1.首先查找python.exe的路径（同样使用Everything搜索) 注意:搜索查找路径和Designer.exe一样，同时还要注意你的环境，此处是conda 2.填写相关路径，点击“ok” 六、这时，External Tools下会出现你创建的外部工具 七、点击“QTDesigner”,出现下面界面后，再点击“创建” 八、将窗口左侧的“Push Button”拖入untiled项目窗口中，就会出现一个“PushButton”按钮 九、按照下图中步骤保存ui文件 十、在PythonCharm中创建一个文件夹，将其放入其中，选中后点击“pyUIC” 十一、目录中就会出现untiled.py的python文件，里面是一些窗体创建的python代码 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8272b13b892b4aa368c784c7993600a9/" rel="bookmark">
			ChatGPT初体验：注册、API Key获取与ChatAPI调用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自从2022年10月，ChatGPT诞生以后，实际上已经改变了很多！其火爆程度简直超乎想象，一周的时间用户过百万，两个月的时间用户过亿。
目前ChatGPT4已经把2023年4月以前的人类的知识都学习到了，在软件工程里面，大模型已经有了非常好的应用。据统计，100多万开发者编码，已经有46%的代码是大模型生成的，预计5年以后会有80%的代码是由人工智能，大模型生成。因此，掌握如何在程序中使用ChatGPT就显得十分重要了！
这里以Python程序为例，讲解如何在Python程序中调用ChatGPT的API！
1.ChatGPT介绍 ChatGPT是OpenAI开发的一种基于大型语言模型GPT（Generative Pretrained Transformer）的聊天机器人。这种聊天机器人可以生成连贯、自然的文本回复，被广泛用于各种对话式应用。下面是关于ChatGPT的一些主要特点：
基于GPT-3或GPT-3.5模型：ChatGPT通常基于GPT-3或GPT-3.5模型，这些都是目前最先进的自然语言处理模型之一。它们能理解和生成非常自然的语言。
预训练和微调：GPT模型通过大量的数据预训练，学会了语言的基本结构和模式。然后通过特定的对话数据进行微调，以优化其在对话任务上的表现。
多领域知识：由于在广泛的文本数据上进行训练，ChatGPT能够处理各种主题和领域的对话，从日常闲聊到专业领域的咨询。
上下文理解能力：ChatGPT能够理解和记住对话的上下文，这意味着它可以在对话中保持连贯性和相关性。
生成性能力：除了回答问题，ChatGPT还能生成诸如诗歌、故事、代码或其他创造性文本的内容。
应用场景：ChatGPT可以被用于客户服务、教育辅助、娱乐、内容创作等多种场景。
持续更新：OpenAI持续对模型进行优化和更新，以提高其性能、安全性和可靠性。
ChatGPT是人工智能和自然语言处理领域的一个重要成果，展示了当前技术在理解和生成人类语言方面的能力。然而，它也有局限性，比如对错误信息的复制、对新信息的缺乏响应等。OpenAI不断在改进这些模型，以提供更准确和实用的对话体验。
2.注册OpenAI账号 要在 OpenAI 网站上注册一个账号，请按照以下步骤操作：
1.打开浏览器，在地址栏中输入 https://openai.com/ ，打开 OpenAI 网站。
2.点击网站顶部的“登录”按钮。
3.在弹出的登录页面中，点击“注册”按钮。
4.输入您的电子邮件地址和密码，然后再次输入密码以确认。
5.在“我同意 OpenAI 的服务条款和隐私政策”复选框旁边打勾。
6.点击“创建账号”按钮完成注册。
7.按照提示，检查您的电子邮件并点击邮件中的链接以验证您的电子邮件地址。
8.在验证页面输入姓名和生日。
9.最后需要绑定一个国外手机号。
这里推荐一个网站可以获取国外手机号的验证码以绑定国外手机号！获取国外手机号验证码
如果按照上述流程你还不能注册成功，这边建议可以参考视频openAI账号注册。
3.获得OpenAI API Key 首先点击右侧链接进入查看ChatGPT文档API网址链接，具体如下所示：然后点击网站左上角图标可以显示侧边栏菜单项！
之后选择点击Create new key来创建一个属于自己的私钥，点击后输入一个Test key用来创建密钥，最后，生产密钥之后一定要复制保存，因为密钥只能被查看一次，不能被反复查看！
4.测试程序 这段代码的作用是使用 OpenAI GPT-3.5-turbo 模型进行聊天对话。它使用 OpenAI 的 Python 客户端库进行与 OpenAI API 的交互。
代码的主要流程如下：
1. 导入所需的库，其中包括 `json` 和 `OpenAI`。 2. 进入一个无限循环，直到用户输入 "end" 结束循环。 3. 提示用户输入需要查询的信息或资源。 4. 获取用户输入的消息。 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8272b13b892b4aa368c784c7993600a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25d63d3abf4369139041b7c49068dc1a/" rel="bookmark">
			软件学院PTA天梯赛初赛选拔赛题解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
7-2 生肖确定（模拟）
AC代码：
7-3 韩信点兵（模拟）
AC代码：
7-4 程序员买包子（模拟）
AC代码：
7-5 h0078. 蛇形矩阵变形
AC代码：
7-6 军事体能成绩统计（升级版）（模拟）
AC代码：
7-7 铺草坪提高版（思维）
AC代码：
7-8 FJCC-GPLT（模拟）
AC代码：
7-9 看照片找基友（并查集）
AC代码：
7-10 小猫爬山（dfs+剪枝）
AC代码：
7-11 h0075. 射击游戏（dfs）
AC代码：
7-12 令人抓狂的四则运算（大模拟）
7-13 寻宝图（BFS+连通块）
7-14 完美树（树形DP，状态机，贪心）
7-2 生肖确定（模拟） 2023年是兔年，1年后（2024年）是龙年，1年前（2022年）是虎年。那么对于给定的一个整数n，请确定2023年之前（n为负数）或之后（n为正数）∣n∣年的结果年份及其对应的生肖（以英文单词表示，详见最后的提示）。
输入格式:
首先输入一个正整数T，表示测试数据的组数，然后是T组测试数据。每组测试输入1个整数n (−2023&lt;n≤10000，n≠0)。
输出格式:
对于每组测试，在一行上输出结果年份及其对应的生肖，之间以一个空格间隔。
输入样例:
3
-1
1
2
输出样例：
2022 tiger
2024 dragon
2025 snake
提示：
鼠、牛、虎、兔、龙、蛇、马、羊、猴、鸡、狗、猪等十二生肖相应的英文单词如下：
rat、ox、tiger、rabbit、dragon、snake、horse、goat、monkey、rooster、dog、pig
思路：简单模拟题，定义一个字符串数组把十二生肖对应的英文单词分别记录进去，随后依据题意进行模拟即可
AC代码： #include &lt;bits/stdc++.h&gt; using namespace std; vector&lt;string&gt; item = {"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25d63d3abf4369139041b7c49068dc1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c66a2b9d25199689b7a4ca00cd0cca4f/" rel="bookmark">
			MySQL字符函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在数据库中，字符函数是一组用于处理字符串的函数。这些函数可以帮助我们执行各种操作，如连接、比较、替换等。本文将介绍一些常用的MySQL字符函数，并演示如何在查询中使用它们。
1.concat() 函数 CONCAT() 函数用于连接两个或多个字符串。它接受一个或多个字符串参数，并将它们连接在一起。如果只提供一个参数，它将返回该参数的值。
示例：
SELECT CONCAT('Hello', ' ', 'World'); 结果：
Hello World 2.length() 函数 LENGTH() 函数用于返回字符串的长度。它接受一个字符串参数，并返回其长度。
示例：
SELECT LENGTH('Hello World'); 结果：
11 3.substring() 函数 SUBSTRING() 函数用于从字符串中提取子字符串。它接受三个参数：要提取子字符串的原始字符串、开始位置和结束位置。也可以写成SUBSTR()
示例：
SELECT SUBSTRING('Hello World', 1, 5); 结果：
Hello 4.replace() 函数 REPLACE() 函数用于替换字符串中的某个子字符串。它接受三个参数：原始字符串、要查找的子字符串和要替换为的新字符串。
示例：
SELECT REPLACE('Hello World', 'World', 'MySQL'); 结果：
Hello MySQL 5.locate() 函数和instr()函数 LOCATE() 函数用于查找子字符串在原始字符串中的位置。它接受两个参数：要查找的子字符串和原始字符串。如果找到子字符串，它将返回子字符串的第一个字符在原始字符串中的位置；否则，它将返回 0。和instr()函数用法一样
示例：
SELECT LOCATE('World', 'Hello World'); 结果：
7 6.upper(str)、lower(str)函数 MySQL中的UPPER(str)和LOWER(str)函数分别用于将字符串中的所有字符转换为大写和小写。
SELECT UPPER('hello world'); -- 结果为 'HELLO WORLD' SELECT LOWER('Hello World'); -- 结果为 'hello world' 7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c66a2b9d25199689b7a4ca00cd0cca4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d6a0692ffe3d2bbfac5ba169729e902/" rel="bookmark">
			C/C&#43;&#43;内存管理,malloc,realloc,calloc,new,delete详解！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.初步了解内存中各个区间存储的数据特征 1.栈区：存储一些局部变量、函数参数、返回值等，跟函数栈振有关，出了作用域，生命周期结束。
2.堆区：用于动态开辟空间，如果不主动销毁空间，则程序运行结束，生命周期结束。
3.数据段（静态区）：static修饰的静态变量和全局变量，程序运行结束，生命周期结束。
4.代码段（常量区）：可执行的代码和常量。
练习 int globalVar = 1; static int staticGlobalVar = 1; void Test() { static int staticVar = 1; int localVar = 1; int num1[10] = { 1, 2, 3, 4 }; char char2[] = "abcd"; const char* pChar3 = "abcd"; int* ptr1 = (int*)malloc(sizeof(int) * 4); int* ptr2 = (int*)calloc(4, sizeof(int)); int* ptr3 = (int*)realloc(ptr2, sizeof(int) * 4); free(ptr1); free(ptr3); } 选项 : A .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d6a0692ffe3d2bbfac5ba169729e902/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f7bb8abae0572b8648899a972c15252/" rel="bookmark">
			Python常见基础数据结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python常见基础数据结构 字符串字符串的构造字符串是一种序列正向索引负向索引有限切片无限切片查询方法压缩方法替换方法格式化插入分割方法 列表列表构造列表同样属于序列列表的元素增加列表其他方法 元组字典字典的构造字典不属于序列字典可变 字符串 字符串的构造 • 单引号：字符串中含有双引号时；
• 双引号：字符串中含有单引号时；
• 三引号：字符串中既含有单引号又含有双引号时，或需要多
行显示时；
# 单引号构造字符串 string1 = '"commentTime":"2018-01-26 08:59:30","content":"包装良心！馅料新鲜！还会回购"' # 双引号构造字符串 string2 = "ymd:'2017-01-01',bWendu:'5℃',yWendu:'-3℃',tianqi:'霾~晴',fengxiang:'南风'" # 三引号构造字符串 string3 = ''''nickName':"美美",'content':"环境不错，服务态度超好，就是有点小贵"''' string4 = '''据了解，持续降雪造成安徽部分地区农房倒损、种植养殖业大棚损毁， 其中合肥、马鞍山、铜陵3市倒塌农房8间、紧急转移安置8人。''' print(string1) print(string2) print(string3) print(string4) 输出：
“commentTime”:“2018-01-26 08:59:30”,“content”:“包装良心！馅料新鲜！还会回购”
ymd:‘2017-01-01’,bWendu:‘5℃’,yWendu:‘-3℃’,tianqi:‘霾~晴’,fengxiang:‘南风’
‘nickName’:“美美”,‘content’:“环境不错，服务态度超好，就是有点小贵”
据了解，持续降雪造成安徽部分地区农房倒损、种植养殖业大棚损毁，
其中合肥、马鞍山、铜陵3市倒塌农房8间、紧急转移安置8人。
字符串是一种序列 正向索引 1、正向单索引指的是只获取列表中的某一个元素，并且是从左到右的方向索取对应位置下的元素，可以使用[index]表示。
2、需要注意的是，索引值index是从0开始的，所以索引值与实际元素的位置正好差1。
price = '5元/瓶' # 取出价格，并做整型转换 print(int(price[0])) # 取出字符串中的“元” print(price[1]) # 取出字符串中的“瓶” print(price[3]) print(price[len(price) -1]) # len()取字符串的长度 输出：
5
元
瓶
瓶
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f7bb8abae0572b8648899a972c15252/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e24d6693604fd54746b6e82520fc0d7/" rel="bookmark">
			【算法】最短路径——迪杰斯特拉 (Dijkstra) 算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.概述2.代码实现2.1.节点类2.2.邻接矩阵存储图2.3.邻接表存储图2.4.测试 3.扩展3.1.只计算一对顶点之间的最短路径3.2.获取起点到其它节点具体经过的节点 4.应用 更多数据结构与算法的相关知识可以查看数据结构与算法这一专栏。
1.概述 （1）在图论中，最短路径是指在加权图中两个顶点之间长度最短的路径，这个路径的长度是每条边的权重之和。在现实生活中，可以将图中的顶点表示为地点，将边表示为这些地点之间的道路或交通线路，把每条边的权重定义为行程时间、行驶距离、经济成本、能源消耗等相应的度量单位。在这种情况下，最短路径问题就是为了找到从一个地点到另一个地点的最快、最短、最便宜、最节能的路径。最短路径问题在计算机科学和运筹学方面非常重要，它可以解决很多现实问题，如网页排名算法、路由算法、航班调度、电信网络建设等。Dijkstra 算法是解决最短路径问题的经典算法之一。
（2）迪杰斯特拉算法 (Dijkstra) 是由荷兰计算机科学家狄克斯特拉于1959年提出的，因此又叫狄克斯特拉算法。是从一个顶点到其余各顶点的最短路径算法，解决的是有权图中最短路径问题。迪杰斯特拉算法主要特点是从起始点开始，采用贪心算法的策略，每次遍历到始点距离最近且未访问过的顶点的邻接节点，直到扩展到终点为止。
（3）实现 Dijkstra 算法的一种基本思路如下：
维护一个待确定最短路径的节点的集合，初始时只有起点。之后，每次从这个集合中取出一个节点，更新它所有邻居的距离，将它们加入这个集合中。具体实现中，使用一个优先队列来存储待访问的节点，并按照最短距离从小到大的顺序进行访问。在代码中，使用一个数组 dist 来记录起点到每个节点的最短距离，同时使用一个自定义的 Node 类来表示所有待访问的节点，并存储其与起点的距离。算法主体部分由一个 while 循环实现。每次取出队列中距离最小的节点，并遍历其所有邻居，更新起点到每个邻居的距离，然后将未确定最短路径的点加入队列中。 ① 常数较小的情况下，Dijkstra 算法的时间复杂度为 O(ElogV)，其中 E 为边数，V 为顶点数。
② 当图中存在负权边时，Dijkstra 算法可能会陷入无限循环或得到错误的结果。
③ 另外一种计算最短路径的弗洛伊德 (Floyd) 算法可参考【算法】最短路径——弗洛伊德 (Floyd) 算法这篇文章。
2.代码实现 2.1.节点类 class Node { //图中当前节点的 id int id; //从 start 节点到当前节点的距离 int distFromStart; public Node(int id, int distFromStart) { this.id = id; this.distFromStart = distFromStart; } } 2.2.邻接矩阵存储图 class Solution { /* start: 起点 graph: 用于表示图的邻接矩阵 返回值: 起点到图中每一个点的最短距离 */ public int[] dijkstra(int start, int[][] graph) { // dist[i] 表示起点 start 到节点 i 的最短路径长度 int[] dist = new int[graph.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e24d6693604fd54746b6e82520fc0d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42a536ed6ec93d0a24af810b18fea9e3/" rel="bookmark">
			解决Cause: java.sql.SQLSyntaxErrorException: Unknown column ‘ins_flow‘ in ‘field list‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在测试大批量数据入库时，发现下面报错：
问题产生原因是因为数据库字段与实体类字段对应不上，像该类问题解决方案是将数据库字段改为和java实体类字段一致，或者采取起别名的方式，或者根据驼峰式命名的方式修改数据库字段或者java字段
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70cfb92088d1e4af2089e4a47faef25f/" rel="bookmark">
			c&#43;&#43;中printf()的函数的简略介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当谈到C++中的输出语句时，人们经常会想到printf函数。printf函数是C语言中用于格式化输出的标准库函数，但在C++中也可以使用它。在这篇博客中，我们将介绍printf函数的基本用法以及在C++中使用它的一些注意事项。
什么是printf函数？ printf函数是C语言中用于格式化输出的函数，它可以将各种类型的数据输出到标准输出设备（通常是屏幕）。printf函数使用格式化字符串来指定输出的格式，可以包含普通字符和格式控制符。
基本用法 在C++中，可以使用printf函数来进行格式化输出，例如：
#include &lt;cstdio&gt; int main() { int num = 10; printf("The number is: %d\n", num); return 0; } 在这个例子中，%d是格式控制符，用于指定输出整数类型的变量。当printf函数执行时，它会将num的值插入到格式化字符串中，并输出结果。
注意事项 在C++中使用printf函数时，需要注意以下几点：
头文件：在C++中使用printf函数需要包含&lt;cstdio&gt;头文件。
命名空间：printf函数位于C标准库中，因此在C++中需要使用std::命名空间来调用它，或者使用using namespace std;来简化调用。
类型安全：printf函数不具有类型安全性，如果格式化字符串与传入的参数类型不匹配，可能会导致未定义的行为或错误的输出。因此，在C++中更推荐使用cout和&lt;&lt;操作符进行输出，因为它们提供了更好的类型安全性。
格式化字符串：在使用printf函数时，需要谨慎编写格式化字符串，确保与传入参数的类型和数量匹配，以避免出现错误。
常用格式控制符： %d：用于打印带符号的十进制整数（int）。
%u：用于打印无符号的十进制整数（unsigned int）。
%f：用于打印浮点数（float或double）。
%c：用于打印单个字符（char）。
%s：用于打印字符串（char*）。
%p：用于打印指针的值。
%e：用于打印以指数形式表示的浮点数。
%x：用于打印无符号十六进制整数（unsigned int），并使用小写字母a-f。
%X：用于打印无符号十六进制整数（unsigned int），并使用大写字母A-F。
%%：用于打印一个百分号。
结论 虽然printf函数是C语言中常用的输出函数，但在C++中更推荐使用cout和&lt;&lt;操作符进行输出。这样可以提高代码的可读性和类型安全性。当然，在一些特定的情况下，printf函数仍然可以发挥作用，但在使用时需要格外小心，以避免出现潜在的问题。
希望这篇介绍能够帮助你更好地理解C++中的printf函数。如果你有任何问题或建议，欢迎留言讨论！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2fdf3fb226ab1bc2d67c5129c433c69/" rel="bookmark">
			点云 surface 方法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点云的表面方法是指通过点云数据来估计和重建物体或场景的表面几何形状。下面总结了几种常见的点云表面方法：
三角化：三角化是最常用的点云表面重建方法之一。它将点云中的点连接成三角形网格，从而重建出物体或场景的表面。常见的三角化算法包括Delaunay三角化和Alpha形状三角化。
【点云surface】无序点云快速三角化-CSDN博客
泊松重建：泊松重建是一种基于体素的点云表面重建方法。它通过将点云数据转化为体素网格，然后利用泊松方程来估计表面。泊松重建方法可以处理不完整和噪声点云数据。
【点云surface】Poisson表面重建-CSDN博客
网格生成：网格生成是一种将点云数据转化为网格表面的方法。它将点云数据映射到网格上，并通过插值或拟合方法来估计网格上的表面。常见的网格生成算法包括Marching Cubes和Moving Least Squares。
【点云surface】基于多项式重建的平滑和法线估计-CSDN博客
曲面拟合：曲面拟合是通过拟合数学曲面来估计点云表面的方法。它可以使用多项式拟合、贝塞尔曲线、B样条曲面等方法来拟合点云数据，从而得到平滑的曲面。
【点云surface】 修剪B样条曲线拟合-CSDN博客
深度学习方法：近年来，深度学习方法在点云表面重建领域取得了显著的进展。通过神经网络模型，可以直接从点云数据中学习和预测物体或场景的表面。
这些点云表面方法各有优缺点，适用于不同的场景和应用。在选择和使用点云表面方法时，需要考虑点云数据的特点、噪声水平、数据完整性以及应用需求等因素。同时，还可以结合多种方法和技术来提高点云表面重建的质量和效果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e62ced66271f90fcfb47feeb8907371/" rel="bookmark">
			注解之@Configuration、@Bean、@Component
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
@Component：通用的注解！
@Bean
引入第三方的类
@Configuration
前言 首先：我们先简单描述一下这三个的作用
@Component注解表明一个类会作为组件类，并告知Spring要为这个类创建bean。
@Bean注解告诉Spring这个方法将会返回一个对象，这个对象要注册为Spring应用上下文中的bean。通常方法体中包含了最终产生bean实例的逻辑。用于显式声明单个bean，而不是让Spring像上面那样自动执行它。它将bean的声明与类定义分离，并允许您精确地创建和配置bean。另外@Bean注解的方法返回值是对象，可以在方法中为对象设置属性。
@Configuration即用来代替Spring配置文件的，它就是一个@Component组件，接收一个value值也就是bean的名字，value可以不填。
但是上面的讲解都只是冰冷的概念，决定重新捡起来，好好研究这些配置，因为虽说平时自己写的时候都是机械性的，甚至是试探性的，但是还是要更深入一点。
为什么要先讲这三个概念，是因为他们之间的关系，有些你中有我我中有你，最好先有一个大概的了解。
@Component：通用的注解！ 通俗的讲：@Compent就是说，是标注这个类是一个组件类，只要你想将你写的类交给Spring容器来管理，那就可以用它！
1、@controller： controller控制器层（注入服务）
2、@service ： service服务层（注入dao）
3、@repository ： dao持久层（实现dao访问）
为什么摆出上面这三个，因为他们其实就是@Compent，例如我们进入到@Controller里看一下,发现在Controller上就有一个@Component，剩下的两个同理
package org.springframework.stereotype; ​ import java.lang.annotation.Documented; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; import org.springframework.core.annotation.AliasFor; ​ @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Component public @interface Controller { @AliasFor( annotation = Component.class ) String value() default ""; } 写一个简单的功能，先写一个类，用@Compent注解上
package com.newcrud.learn; ​ import lombok.Data; import org.springframework.stereotype.Component; ​ @Data @Component public class KangShiFuTwo { String name; Integer age; public void getKangShiFuTwo(){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e62ced66271f90fcfb47feeb8907371/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d17dfb7ed1c9520470e35920b1cb342/" rel="bookmark">
			【Linux学习笔记】protobuf 基本数据编码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://zhuanlan.zhihu.com/p/557457644https://zhuanlan.zhihu.com/p/557457644 [新文导读] 从Base64到Protobuf，详解Protobuf的数据编码原理本篇将从Base64再到Base128编码，带你一起从底层来理解Protobuf的数据编码原理。本文结构总体与 Protobuf 官方文档相似，不少内容也来自官方文档，并在官方文档的基础上添加作者理解的内容，如有出入请以官方文档为准。https://mp.weixin.qq.com/s/OgPnO2TEGSc2Eb8wxQTs6g?spm_id_from=444.41.rich-text.link.click
目录
安装
Base128 Varints 编码
uint
sint
字符串
安装 1. 下载：
wget https://github.com/protocolbuffers/protobuf/releases/download/v21.5/protobuf-cpp-3.21.5.tar.gz tar zxvf protobuf-cpp-3.21.5.tar.gz protobuf-3.21.5/ 2. 编译
cd protobuf-3.21.5/ ./configure make sudo make install sudo ldconfig 3. 生成 xxx.pb.h 和 xxx.pb.cc
protoc -I=input_dir --cpp_out=output_dir [*.proto |/input_dir/specific.proto] // -I 原文件.proto的所在的文件夹 // --cpp_out 生存pb.c pb.h 存放的文件夹 // 后面跟着所需的.proto文件 Base128 Varints 编码 Varint 是一种紧凑的表示数字的方法。它使用小端标识（意味着计算时需要调换顺序），用一个或多个字节来表示一个数字，值越小的数字使用越少的字节数。这能减少用来表示数字的字节数。其中每个字节的最高位用来表示后面一个字节是否属于当前这个数的组成部分，1 代表是，0表示不是。
uint 对于无符号整数，其编码比较简单，以 1 和 300 为例。
step1: 1 的二进制为 0000 0001 step2: 取 7 位，即 000 0001 step3: 多个byte的话，需要进行翻转（因为varints是用小端表示，低位字节放在前面） step3: 最高位添加一个表示下一个byte是否属于当前数字的标志位，因为 1 只有1个字节表示，所以表示位为0，即最终varints编码表示位为 0000 0001 step1: 300 的二进制表示为 100101100 step2: 每7位隔开，不足的补0 -&gt; 0000010 0101100 step3: 翻转一下byte顺序 0101100 0000010 step4: 填写标志位 1010 1100 0000 0010 （ac 02） sint 对于有符号数，因为计算机定义负数的符号位为数字的最高位。如果采用 Varint 表示一个负数，那么一定需要 10 个 byte 长度。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d17dfb7ed1c9520470e35920b1cb342/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13867f4e21ff261ad3ee0f9dc4089e05/" rel="bookmark">
			python中模块的创建及引用（import as，import，from）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		模块（module）简介：
1.模块化，模块化指将一个完整的程序分解为一个一个的小模块，
通过将模块组合，来搭建出一个完整的程序
2.不采用模块化就是统一将所有的代码编写到一个文件中，采用
模块化就是将程序编写到多个文件中。
特点：
1.方便开发
2.方便维护
3.模块可以复用
说明：在python中一个py就是一个模块，创建一个python就是创建模块
例如：创建一个模块然后在test中测试
就会有如下运行结果：
说明：
（一）在模块命名时需要符合命名规范：
1.使用有意义的名字 模块的名字应该能够准确地描述模块的功能和
用途。 避免使用无意义的名字或者缩写，这样可以提高代码的
可读性。
2.使用小写字母和下划线
(二) import 模块名（模块名是python开头不要py）以此来引用模块
（三）也可以使用import 模块名 as 别名来引用，如：
说明：有的模块名太长会用这个，给他命名一个好引用的别名
注：引用模块可以在程序任意位置引用，一般都会写在开头
在每一个模块中都有一个__name__属性，属性值为__main__是主模块，是直接通过python直接执行的，如：
&gt;&gt;&gt;
说明：
1. 模块里可以放任何东西，变量，函数，类等等
2. 想要引用模块里的部分内容，语法：from import （或者：from import as或者：模块名.变量）
例如：
运行结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36ae3b46995f43e52ade71813e253734/" rel="bookmark">
			完美解决Python报错：PermissionError: [Errno 13] Permission denied
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我接着这篇博客写，大家先移步这篇文章，如果还是解决不了就来看我这篇Python报错：PermissionError: [Errno 13] Permission denied_netcdf4.dataset permission denied-CSDN博客
前言： 我觉得对我而言，网上这么多教程，这篇是对我最有用的，经过我两次的实践，得出了比较清晰和系统的解决这个问题的有效方法，希望看过的人别再踩坑了，这个过程是如此的痛苦。
下面干货来了：
第一，在使用.load()函数读取json文件前，要先给出文件路径path相信大家都知道，但是这里有一个细节，
path这里的最后一步不是父目录，而是原目录，也就是最后一个/后面的是一个文件而非文件夹，都去给我精确到json文件本身。
第二，使用os.chmod(path, stat.S_IRWXU)以及import stat两句话把权限全开放给自己，以解决如标题所示的因为权限不够发生的报错。
至此，就是这两点，把握住了就能避坑，成功编译通过，然后就用load()函数去读取json文件。
以下是我改正后的代码，请大家注意我前面说的几条重要语句的相对位置，作为大家的参考。
热知识：你随手的一键三连能暖作者一整天（疯狂暗示~）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/626a2d7734bc59ba17ee7e84ee07afc9/" rel="bookmark">
			基于Haclon的图形镜像案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 项目要求： 图为HALCON的例图“green-dot”，请将其中的圆形图案按水平和垂直两个方向分别进行镜像。
项目知识： 首先要用BLOB分析的方法，得到圆形图案的目标区域，再对其进行镜像。
在HALCON中与镜像相关的算子为mirror_image(Image : ImageMirror : Mode : )和mirror_region(Region : RegionMirror : Mode, Width, Height : )，分别对应了图像旋转和区域旋转，其中的Mode为方式选择，可以选择row（水平）、column（垂直）和diagonal（对角）三种旋转方式。
项目代码： read_image (Image, 'green-dot') *BLOB分析，得到目标区域 threshold (Image, Regions, 0, 133) connection (Regions, ConnectedRegions) *用面积筛选出圆型区域select_shape (ConnectedRegions, SelectedRegions, 'area', 'and', 8930.15, 66224.6) *水平方向镜像mirror_region (SelectedRegions, RegionMirror, 'row', 512) *垂直方向镜像mirror_region (RegionMirror, RegionMirror1, 'column', 512) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6832c3205299fe9068d96349908bb4c5/" rel="bookmark">
			wpf 根据属性，动态创建TextBlock，显示名称和值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		private static void OnItemsChanged(DependencyObject d, DependencyPropertyChangedEventArgs e) { if (d is not ExaminationProtocolsControl self) { return; } var baseModeOption = (BaseModeOption) e.NewValue; self._ParameterPanel_.Children.Clear(); if (baseModeOption != null &amp;&amp; !string.IsNullOrEmpty(baseModeOption.Name)) { System.Reflection.PropertyInfo[] properties; Type type = baseModeOption.GetType(); properties = type.GetProperties(BindingFlags.Public | BindingFlags.Instance); object obj = baseModeOption; if (properties.Length &lt;= 0) { return; } List&lt;string&gt; list = new List&lt;string&gt;(); for (int i = 0; i &lt; properties.Length; i += 2) { list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6832c3205299fe9068d96349908bb4c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5b5c91e279cc097744b935117c387f0/" rel="bookmark">
			mysql-事务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL-事务 什么是事务？事务的开始和结束查看事务是否开启？注意 清晰的事务控制语句流程图演示一下事务过程COMMIT 或 ROLLBACK 语句之前的数据的状态并发事务的4个问题详细解释 事务有4个特性事务的四个隔离级别在MySQL中查看隔离级别 什么是事务？ 事务: transaction 一个数据库事务由一条或者多条sql语句构成，它们形成一个逻辑的工作单元。这些sql语句要么全部执行成功，要么全部执行失败。
事务是保证数据的完整性和一致性的重要手段。DML事务: 由一条或者多条DML语句构成DDL事务: 总是由一条DDL语句构成DCL事务: 总是由一条DCL语句构成 简单来说：办理一件事，背后会有多个操作，这些步骤合起来成为事
务。但步骤有一条错了，那整个事情就是失败，全部成功，那才算成功。
事务的开始和结束 一条sql语句就会开始一个事务
查看事务是否开启？ 注意 也就是说 DDL DXL语句，MySQL会自动执行，跟变量autocommit是关闭
还是开启没有关系，都会自动提交。
清晰的事务控制语句流程图 开始事务：事务开始时，可以执行多个数据库操作，如插入、更新或删除数据。
执行 DELETE 操作：在这个特定的事务中，首先执行了一个删除操作。
设置保存点 A：在删除操作之后，设置了一个保存点A。这样做可以在事务执行过程中，如果需要，可以只回滚到这个点，而不是事务的开始。
执行 INSERT 操作：在设置保存点A之后，进行了数据插入操作。
执行 UPDATE 操作：接下来执行了更新操作。
设置保存点 B：在更新操作之后，设置了第二个保存点B。
执行另一个 INSERT 操作：在保存点B之后，执行了另一个插入操作。
回滚到保存点 B：由于某些原因，需要撤销最后的插入操作，于是事务被回滚到保存点B，这意味着最后的插入操作被撤销，但保存点B之前的操作（包括第一个插入和更新操作）仍然有效。
回滚到保存点 A：接下来，事务又被回滚到保存点A，这意味着回滚到保存点A之后所有的操作都被撤销，只留下第一次的删除操作。
完全回滚事务：最后，整个事务被完全回滚，这意味着所有的操作，包括删除操作，都被撤销，数据库回到了事务开始之前的状态。
演示一下事务过程 root@gh 11:01 mysql&gt;CREATE TABLE players( id INT, NAME VARCHAR(20) ); Query OK, 0 rows affected (0.00 sec) root@gh 11:02 mysql&gt;START TRANSACTION; Query OK, 0 rows affected (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5b5c91e279cc097744b935117c387f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47e95f7d47fe448d0af8f3ad1f562ee8/" rel="bookmark">
			Xubuntu16.04系统中create_ap开启5G网络的踩坑记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Xubuntu16.04系统中安装create_ap创建无线AP：
https://blog.csdn.net/qq_45445740/article/details/133972642?spm=1001.2014.3001.5501
目录 1.create_ap.conf 配置文件解析2.关于信号强度和延时2.1 信号强度2.2 信号延时2.3 网络延时测试工具推荐——PingPlotter 3.确定当前网卡是否支持5G网络4.通过create_ap修改信道5.坑一：iw list显示 no IR6.坑二：将5G频道设为首选7.坑三：芯片支持5G，网卡不支持——打补丁8.坑四：驱动需要更新9.坑五：Linux下Intel无线网卡不支持5GHz AP频道？10.5G热点和5G自发ap？11.无线模块发射5g信号和5g的自发AP？ 1.create_ap.conf 配置文件解析 /etc/create_ap.conf
CHANNEL=default：无线热点的频道设置为默认信道。 GATEWAY=10.0.0.1：设置无线热点的网关地址为10.0.0.1。 WPA_VERSION=2：设置无线热点使用的WPA版本为2。 ETC_HOSTS=0：禁用/etc/hosts文件的解析。 DHCP_DNS=gateway：设置无线热点的DHCP DNS服务器为网关地址。 NO_DNS=0：启用无线热点的DNS服务器。 NO_DNSMASQ=0：启用DNSMASQ服务。 HIDDEN=0：无线热点的SSID不隐藏。 MAC_FILTER=0：禁用MAC地址过滤。 MAC_FILTER_ACCEPT=/etc/hostapd/hostapd.accept：指定MAC地址过滤的白名单文件路径。 ISOLATE_CLIENTS=0：不隔离连接到无线热点的客户端之间的通信。 SHARE_METHOD=nat：使用NAT方式进行无线热点的Internet共享。 IEEE80211N=0：禁用802.11n标准。（2.4G） IEEE80211AC=0：禁用802.11ac标准。（5G） HT_CAPAB=[HT40+]：启用HT40+高级设置。 VHT_CAPAB=：未指定VHT_CAPAB。 DRIVER=nl80211：使用nl80211驱动程序。 NO_VIRT=0：启用虚拟无线接口。 COUNTRY=：未指定国家代码。 FREQ_BAND=2.4：设置频段为2.4GHz。 NEW_MACADDR=：未指定新的MAC地址。 DAEMONIZE=0：不将create_ap进程置于后台运行。 NO_HAVEGED=0：启用haveged服务。 WIFI_IFACE=wlp3s0：指定用于创建无线热点的无线网卡接口。 INTERNET_IFACE=enp1s0：指定用于连接到Internet的有线网卡接口。 SSID=0125：设置无线热点的SSID为0125。 PASSPHRASE=12345678：设置无线热点的密码为12345678。 USE_PSK=0：禁用预共享密钥(PSK)。 2.关于信号强度和延时 2.1 信号强度 推荐测试信号强度的APP
2.2 信号延时 有时候明明信号强度很好，但延时却很高，可能是当前信道的网络较多。
要判断哪个信道不拥堵，可以考虑以下几个因素：
信道的使用情况：观察每个信道的使用情况，特别是附近的WIFI网络和其他无线设备。如果某个信道上有多个网络同时使用，那么该信道可能会拥堵。相反，如果某个信道上没有或只有少数网络使用，那么该信道可能不拥堵。信道的干扰情况：除了WIFI网络，还要注意其他可能引起干扰的设备，如蓝牙设备、微波炉等。这些设备可能会占用特定的频段，导致信道拥堵。因此，选择一个与这些设备干扰较少的信道可能更好。信道的频率：不同信道的频率可能会有所不同。一般来说，较高频率的信道可能会有更高的带宽和速度，但在传输距离上可能较短（5G）。因此，如果你的设备距离WIFI路由器较近，可以考虑选择较高频率的信道。 综合考虑以上因素，你可以选择一个较少拥堵、干扰较少且适合你的设备的信道。在给定的信息中，你可以观察每个信道的频率和可能的干扰源，并根据这些信息来判断哪个信道可能不拥堵。
使用iwlist命令来列出无线网卡支持的所有信道：
sudo iwlist wlp3s0 channel root@bossdog-2177018234:/etc# iwlist wlp3s0 channel wlp3s0 32 channels in total; available frequencies : Channel 01 : 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47e95f7d47fe448d0af8f3ad1f562ee8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdb97c186c1a63946e9f7132c6da3e16/" rel="bookmark">
			WPF 代码里替换按钮样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 首先建2个样式
&lt;Style x:Key="SnapStartCommandButtonStyle" TargetType="{x:Type ToggleButton}"&gt; &lt;Setter Property="Template"&gt; &lt;Setter.Value&gt; &lt;ControlTemplate TargetType="{x:Type ToggleButton}"&gt; &lt;StackPanel Orientation="Vertical" Background="Transparent" Margin="0,0,0,0" &gt; &lt;Image x:Name="ProgressImage" Source="/Custom;component/Images/snapStart1.png" Stretch="Fill"/&gt; &lt;/StackPanel&gt; &lt;ControlTemplate.Triggers&gt; &lt;Trigger Property="IsMouseOver" Value="True"&gt; &lt;Setter Property="Source" Value="/Custom;component/Images/snapStart2.png" TargetName="ProgressImage"/&gt; &lt;/Trigger&gt; &lt;Trigger Property="IsEnabled" Value="False"&gt; &lt;Setter Property="Source" Value="/Custom;component/Images/snapStart1.png" TargetName="ProgressImage"/&gt; &lt;/Trigger&gt; &lt;Trigger Property="IsChecked" Value="True"&gt; &lt;Setter Property="Source" Value="/Custom;component/Images/snapStart2.png" TargetName="ProgressImage"/&gt; &lt;/Trigger&gt; &lt;/ControlTemplate.Triggers&gt; &lt;/ControlTemplate&gt; &lt;/Setter.Value&gt; &lt;/Setter&gt; &lt;/Style&gt; &lt;Style x:Key="StackStartCommandButtonStyle" TargetType="{x:Type ToggleButton}"&gt; &lt;Setter Property="Template"&gt; &lt;Setter.Value&gt; &lt;ControlTemplate TargetType="{x:Type ToggleButton}"&gt; &lt;StackPanel Orientation="Vertical" Background="Transparent" Margin="0,0,0,0" &gt; &lt;Image x:Name="ProgressImage" Source="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdb97c186c1a63946e9f7132c6da3e16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d1e5eb8b93dbea915fbdc2b9d72ae05/" rel="bookmark">
			Linux安装node18完整图文教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决/lib64/libm.so.6的报错
解决error: no acceptable C compiler found in $PATH
解决These critical programs are missing or too old: make bison compiler
教程 ↓ ↓ ↓ ↓ ↓ ↓ ↓
Linux安装node18完整图文教程
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ed042a4d380938c064c767fd661010e/" rel="bookmark">
			软件工程理论与实践 (吕云翔) 第五章 面向对象方法与UML课后习题及其答案解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第五章 面向对象方法与UML
面向对象方法与UML 1.判断题 （1）UML是一种建模语言，是一种标准的表示，是一种方法。( ×)
（2）类图用来表示系统中的类和类与类之间的关系，它是对系统动态结构的描述。(×)
解释：类图是对系统的静态结构进行描述，而不是动态结构
（3）在面向对象的软件开发方法中，每个类都存在其相应的对象，类是对象的实例，对
象是生成类的模板。(×）
解释：类是对象的模板，而对象是类的实例
（4）顺序图用于描述对象是如何交互的，并且将重点放在消息序列上。(√ )
（5）继承性是父类和子类之间共享数据结构和消息的机制，这是类之间的一种关系。(×
（6）多态性增强了软件的灵活性和重用性，允许用更为明确、易懂的方式去建立通用软件，多态性和继承性相结合使软件具有更广泛的重用性和可扩充性。(×)
（7）类封装比对象封装更具体、更细致。(×)
解释 ：对象封装和类封装是相同的概念，用于将数据和相关操作封装在一个单元中
（8）用例之间有扩展、使用和组合等几种关系。(√ )
（9）活动图用于显示动作及其结果，着重描述操作实现中所完成的工作，以及用例实例或类中的活动。(√)
（10）UML语言支持面向对象的主要概念，并与具体的开发过程相关。(×)
（11）部署图用于描述系统硬件的物理拓扑结构，以及在此结构上执行的软件。（√）
2.选择题 （1）面向对象技术中，对象是类的实例。对象有3种成分：（A）、属性和方法（或操作)。
A.标识
B.继承
C.封装
D.消息
（2）以下不是面向对象的特征的是（D)
A.多态性
B.继承性
C.封装性
D.过程调用
（3）汽车有一个发动机，汽车和发动机之间的关系是（B）关系。
A.组装
B.整体与部分
C.分类
D.一般与具体
（4）（D）是把对象的属性和操作结合在一起，构成一个独立的对象，其内部信息对外界是隐藏的，外界只能通过有限的接口与对象发生联系。.
A.多态性
B.继承
C.消息
D.封装
（5）面向对象的主要特征除了对象唯一性、封装和继承外，还有（D）。
A.兼容性
B.完整性
C.可移植性
D.多态性
（6）关联是建立（B）之间关系的一种手段。
A.对象
B.类
C.功能
D.属性
（7）面向对象软件技术的许多强有力的功能和突出的优点，都来源于把类组织成一个层次结构的系统，一个类的上层可以有父亲，下层可以有子类，这种层次结构系统的一个重要性质是（B），一个类获得其父亲的全部描述（数据和操作）。
B.继承性
C.复用性
D.多态性
A.兼容性
（8）所有的对象可以成为各种对象类，每个对象类都定义了一组（D）。
A.说明
B.类型
C.过程
D.方法
（9）通过执行对象的操作可以改变对象的属性，但它必须通过（B）的传递。
A.操作
B.消息
C.信息
D.继承
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ed042a4d380938c064c767fd661010e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae6b538a63f836e711ed57d7a0fe8b3b/" rel="bookmark">
			智能投研领域公司
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公司 介绍 产品通联数据背靠万向控股，有很强的金融背景，老大是肖风，是各大金融机构的理事鼎复数据有百度七剑客之一的郭眈，还拿了红杉的投资，因为创始团队闹掰了，郭眈已经出走另起炉灶了阡寻科技大佬白硕创办的股票对话机器人阡宝虎博科技这家公司属于学术背景，联合创始人是NLP领域的大牛，他们一直在C端发力，用互联网免费的打法在做ToB市场壁虎舆情和西梅，感觉一般香侬科技庖丁科技好像是以机器视觉见长的，辅助投研的报告撰写，联合创始人高大光，是前证监会副主席高西庆的侄子阿博茨科技主打机器视觉文因互联创始人鲍捷博士圈内无人不知，人设几乎等同于是智能投研的布道者，从各种理论到实践都很厉害 最近想换工作，关注智能投研领域，通联数据、鼎复数据、庖丁科技、阿博茨科技都还可以，哪位大神给分析一下? - 知乎
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b278ce9a1e7a3d5aa3a4a70fb2078ac7/" rel="bookmark">
			Android flutter this and base files have different roots
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		类似经历者 Android build fails with certain plugins if project is in a different drive (from sdk)
错误描述 我是windows系统，下载 flutter sdk 我是放在D盘，flutter项目是放在E盘，flutter 执行 pub get的时候，会在我C盘里面默认给你创建一个，C://xxxx\Pub\Cache的文件，这里的文件又跟你的flutter sdk 不在同一个目录，这就会导致这样的问题
解决方案 1、创建环境变量 PUB_CACHE ，值为 E:\pub_cache
2、环境变量path末尾多添加 ;%PUB_CACHE%; 注意前后;
3、将D盘的 flutter sdk 放到 E盘里面
4、关闭Android studio
5、执行命令 flutter clean
6、删除 android 里面的 .gradle .idea
7、执行命令 flutter pub get
如果遇到如下的错误，就是没有执行 flutter pub get
Process 'command 'E:\flutter_sdk\flutter_windows_stable\flutter\bin\flutter.bat'' finished with non-zero exit value 1 或者 assert pluginDirectory.exists() | | | false \root\snap\flutter\common\flutter\.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b278ce9a1e7a3d5aa3a4a70fb2078ac7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/195e3246a15f567e7f0980567064e91b/" rel="bookmark">
			Android实战项目：日记应用开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 第一篇 Android实战项目：日记应用开发
文章目录 系列文章目录前言一、效果展示1. 登录模块2. 引导模块3. 功能模块4. 我的模块5. 日记操作 二、功能介绍三、知识点四、下载链接总结 前言 应用基于Android studio开发，使用Java语言。
一、效果展示 1. 登录模块 2. 引导模块 3. 功能模块 4. 我的模块 5. 日记操作 二、功能介绍 启动应用先显示启动页首次打开应用先进入引导页设置密码进入应用，对密码进行加密处理数据库存储日记信息列表显示所有日记新增、删除、更新日记信息修改个人中心的圆形头像，通过相册选择或相机拍照网络更新个人中心风景图显示或隐藏个人中心密码个人中心跳转应用系统设置动态获取拍照及相册访问权限 三、知识点 基本控件：ImageView、Button、TextView、EditView、Dialog复杂控件：RecyclerView、ViewPager、Toolbar、BottomNavigationView、ShapeableImageView布局控件：LinearLayout、RelativeLayout、FrameLayout、ConstraintLayout、AppBarLayout、ScrollView依赖：Glide存储：SQLite数据库、SharedPrefrenced、文件存储Activity、Fragment、ContentProvider、动画、drawable形状、多语言、基础自定义View、MVC框架、动态申请应用权限、系统应用调用 四、下载链接 源码下载：https://pan.baidu.com/s/1bzSSuPrtlq1m5UG29TWvoQ
提取码：1111 (好像不需要)
总结 后续会陆续更新整个项目的实现过程，并对项目进行讲解，可先自己获取源码学习。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a027f2e54492141489ac9720b036a4d/" rel="bookmark">
			【数据集】全网最全的常见已公开医学影像数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一，极市医学数据集汇总
1.CT 医学图像
​编辑
2.恶性与良性皮肤癌
3.白内障数据集
4.胸部 X 光图像（肺炎）
5.用于图像增强的内窥镜真实合成曝光过度和曝光不足帧
6.医学家
7.乳房组织病理学图像
8.皮肤癌 MNIST：HAM10000
9.疟疾细胞图像数据集
10.m2caiSeg腹腔镜图像数据集 11. 淋巴结切片的组织病理学数据集
12.PanNuke癌组织细胞数据集
13.Kumar肿瘤数据集
14.FASCICLE 小腿肌肉超声数据集
15.3D-IRCADB脏器分割数据集
16.COVID-19 胸部CT图像增强GAN数据集
二，Kaggle网站数据集汇总
一，眼睛和视力
17.眼底青光眼检测数据
18.糖尿病视网膜病变的诊断
19.眼部疾病识别
20.视网膜疾病分类
21.白内障数据集
22.视网膜OCT图像（光学相干断层扫描）
二，糖尿病
23.糖尿病数据集-1
24.糖尿病数据集-2
25.皮马印第安人糖尿病数据库
26.糖尿病健康指标数据集
三，各种癌症
27.威斯康星州乳腺癌（诊断）数据集
28.子宫颈癌疫苗
29.乳腺组织病理学图像
30.宫颈癌风险分类
31.脑肿瘤分类 （MRI）
32.皮肤癌：恶性与良性
33.乳腺癌数据集-1
​编辑34.肺癌
35.乳腺超声图像数据集
​编辑36.胸部 CT 扫描图像数据集
37.脑瘤
38.乳腺癌数据集-2
39.肺癌和结肠癌组织病理学图像
40.丙型肝炎预测数据集
41.分割软组织肉瘤
42.前列腺癌
43.印度肝脏患者记录
44.Br35H ：： 脑肿瘤检测 一，极市医学数据集汇总 1.CT 医学图像 网站：【CT,医学图像】-计算机视觉数据集-极市开发者平台 (cvmart.net)
2.恶性与良性皮肤癌 网站：【恶性与良性皮肤癌】-计算机视觉数据集-极市开发者平台 (cvmart.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a027f2e54492141489ac9720b036a4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5333d09b2da720bf906eb74649dcafb7/" rel="bookmark">
			显存充足，pytorch却报错CUDA out of memory？(已解决)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 明明显存充足，我们服务器有两张卡，nvidia-smi 查看时两张卡空闲：
但是train的时候总是提示“CUDA out of memory”：
注意！这里的allocated是你自己程序所占用的，我之前理解错了，以为是被别人占用的（然而并没有其他进程）。
原因分析： 原因是cuda内存不够，查了一下试过以下方法（都没解决）：
1、改小batchsize，后面调到1了都不行；
2、改小num_worker，设置为0了都不行；
3、用torch.cuda.empty_cache() 清理空闲内存，没啥用（可能我没用对）；
4、还有博主建议说改小图像尺寸，我的图像已经是256x256了，不大，所以我没试。
解决方案： 我先是在程序里面查看了一下GPU占用情况：
# 查看GPU使用情况 print(torch.cuda.memory_allocated()) print(torch.cuda.memory_reserved()) 然后我发现，在某些代码片段内部，内存占用率就很高了，会不会是某些计算占用内存太多？于是我恍然大悟：由于我是要对比不同编码器的特征提取效果，训练的时候每一个编码器都会运行一遍，占用了大量内存！于是我先注释掉不用的编码器，只留下本次实验想要运行的编码器，问题解决！
所以大家在上述方法都不work的时候，可以看看是不是自己模型太大，或者计算量太大，试试适量减少一些冗余计算。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e6965a03656ebb3b25856bb41b34b79/" rel="bookmark">
			jpom学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jpom学习 整理jpom 一键安装 部署会需要 mvn跟jdk环境
# 安装服务端和 jdk、maven 环境 yum install -y wget &amp;&amp; \ wget -O install.sh https://jpom.top/docs/install.sh &amp;&amp; \ bash install.sh Server jdk+mvn docker安装 安装docker挂载方式安装 docker pull jpomdocker/jpom mkdir -p /home/jpom-server/logs mkdir -p /home/jpom-server/data mkdir -p /home/jpom-server/conf docker run -d -p 2122:2122 \ --name jpom-server \ -v /home/jpom-server/logs:/usr/local/jpom-server/logs \ -v /home/jpom-server/data:/usr/local/jpom-server/data \ -v /home/jpom-server/conf:/usr/local/jpom-server/conf \ jpomdocker/jpom 访问 创建账号
安装插件端
yum install -y wget &amp;&amp; \ wget -O install.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e6965a03656ebb3b25856bb41b34b79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4983ace92f775a1ae5d8014202c895a/" rel="bookmark">
			Linux网卡没有eth0显示ens33原因以及解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原因 首先说明一下eth0 与 ens33的关系：
目前的主流网卡为使用以太网络协定所开发出来的以太网卡（Ethernet),因此我们Linux就称呼这种网络接口为ethN(N为数字)。
举个栗子：就是说主机上面有一张以太网卡，因此主机的网络接口就是eth0(第一张为0号开始)。而从新的CentOS 7开始对于网卡的编号有另一套规则，网卡的界面代号于网卡的来源有关，网卡名称会是这样分类的：
eno1: 代表由主板BIOS内置的网卡
ens1: 代表由主板BIOS内置夫人PCI-E界面网卡
enp2s0: 代表PCI-E界面独立网卡，可能会由多个插孔，因此会有s0,s1...的编号
eth0: 如果上述的名称都不适用，就回到原本的默认网卡编号。
所以才会有ens33这种的网卡表现形式。
解决办法 1、编辑网卡的配置文件 vi /etc/sysconfig/network-scripts/ifcfg-ens33 将里面的NAME和DEVICE项修改为eth0，ONBOOT需修改为yes
具体操作如下：
[root@localhost ~]# vi /etc/sysconfig/network-scripts/ifcfg-ens33 NAME=eth0 # 修改ens33为eth0 DEVICE=eth0 # 修改ens33为eth0 ONBOOT=yes # 修改no为yes 2、重命名网卡配置 cd /etc/sysconfig/network-scripts/ mv ifcfg-ens33 ifcfg-eth0 3、编辑 /etc/default/grub 加入"net.ifnames=0 biosdevname=0"到GRUBCMALINELINUX变量中
你可以直接复制粘贴下面的内容
[root@localhost network-scripts]# vi /etc/default/grub GRUB_TIMEOUT=5 GRUB_DISTRIBUTOR="$(sed 's, release .*$,,g' /etc/system-release)" GRUB_DEFAULT=saved GRUB_DISABLE_SUBMENU=true GRUB_TERMINAL_OUTPUT="console" GRUB_CMDLINE_LINUX="crashkernel=auto net.ifnames=0 biosdevname=0 spectre_v2=retpoline rd.lvm.lv=centos/root rd.lvm.lv=centos/swap rhgb quiet"GRUB_DISABLE_RECOVERY="true" 4、重新生成GRUB配置并更新内核参数 运行命令 grub2-mkconfig -o /boot/grub2/grub.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4983ace92f775a1ae5d8014202c895a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7548d2c69415e815974c5da875e43b38/" rel="bookmark">
			modelsim10.5安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		双击.exe程序
粘贴
弹出如下界面，按回车键
稍等片刻
另存文件到任意目录。
新建用户变量
至此整个安装及破解过程结束。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d00c94d7036d17cb2944dc1b60a00d7/" rel="bookmark">
			Java—简单的猜数游戏(1~1000)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是我课后的一个作业 在学习Java之前，我已经写过C语言的猜数游戏，所以开始写代码之前已经有了一定的思路
1.起始代码 在最开始我们先定义两个input和random对象，便于后续对变量赋值。然后让程序帮我们生成一个随机数赋值给i。最后定义一个布尔类型，便于后续进行判断。
在这里我多加了一个细节，就是用户最多猜的次数，为20次。
public class Guessnumber { public static void main(String[] args) { Scanner input = new Scanner(System.in); Random random = new Random(); int i = random.nextInt(1000) + 1; // 因为要求数的范围时1~1000，所以需要在随机生成的数的范围上+1 int j = 20; int p = 20; boolean flag = false; System.out.println("机器人已生成一个1~1000的随机数"); System.out.println("请您输入一个整数，猜出这个随机数："); 2.判断代码 在while循环体内，我们让用户输入一个数。然后用if-else嵌套判断，这个数是大了还是小了，还是正好相等。
1.数小了 当用户输入的数小于程序随机生成的数时，让总共能猜的次数自减1当次数＜=5时，打印一句有意思的提示语句当次数=0时，跟用户说出正确答案，游戏结束，同时把true赋值给flag if (b &lt; i) { j--; System.out.println("您猜的数小了,您还剩下" + j + "次机会了哦~"); if (j &lt;= 5) { System.out.println("哥们醒醒，再这样下去没机会了！猜的这么小，难道有什么难言之隐吗？请注意：你只剩下" + j + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d00c94d7036d17cb2944dc1b60a00d7/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/40/">«</a>
	<span class="pagination__item pagination__item--current">41/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/42/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>