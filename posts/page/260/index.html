<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea52d90269f33ee39b7f068754a490ba/" rel="bookmark">
			indexOf()查找错误;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在项目开发过程中,有时候需要用 indexOf() 进行匹配,但是通过 indexOf() 判断的字符在判断内容前段部分同而后端部分不相同的情况下,会出现查找错误的情况;
列: limit.indexOf( 'Function_Session_Agenda_VerifyVoing' ); 和 limit.indexOf( 'Function_Session_Agenda_VerifyVoingRuling' );
注; indexOf() 在判断内容 'Function_Session_Agenda_VerifyVoing' 和 'Function_Session_Agenda_VerifyVoingRuling' 时,如果第二个存在的话,第一个indexOf()判断会出现当前的下标,而不是出现 -1 的情况;从而导致判断错误;
解决办法是在判断的字符后吗加一个 HTML 字符实体 limit.indexOf('Function_Session_Agenda_VerifyVoing&amp;quot;'); &amp;apos; ----单引号
$#39; ----单引号（兼容IE）
&amp;quot; -----双引号
注意,那两个相似的也要加字符,就可以区分开了;
转载于:https://www.cnblogs.com/chenjiangyang/p/11591989.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e770ac1cbe87fe7243c3fff94107fbf9/" rel="bookmark">
			三元环计数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		算法如其名，就是用来找三元环的。
介绍 给出一张无向图，问图中有多少个三元组 { x , y , z } \{x,y,z\} {x,y,z}，满足图中存在 { x − y , y − z , z − x } \{x-y,y-z,z-x\} {x−y,y−z,z−x} 三条边。
转化 考虑将这张图转化为有向图：对于一条无向边 x − y x-y x−y，不妨设点 x x x 的度大于点 y y y 的度，那么就将这条无向边变成 x → y x \to y x→y。假如两点的度相同，就从编号大的往编号小的连边。
这样转化后，这张图一定是有向无环图。
证明：
使用反证法，假设有一个环： a → b → c → a a\to b \to c \to a a→b→c→a，那么有（设 x x x 的度为 d x d_x dx​）： d a ≥ d b ≥ d c ≥ d a d_a \geq d_b \geq d_c \geq d_a da​≥db​≥dc​≥da​，要使该不等式成立，当且仅当满足 d a = d b = d c = d a d_a=d_b=d_c=d_a da​=db​=dc​=da​。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e770ac1cbe87fe7243c3fff94107fbf9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be38c2a3582c9247b0ed174d3e8319b4/" rel="bookmark">
			深度学习（一）——placeholder的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用placeholder
import tensorflow as tf # 让我们修改前面的代码去实现Mini-Batch梯度下降 # 为了去实现这个，我们需要一种方式去取代X和y在每一次迭代中，使用一小批数据 # 最简单的方式去做到这个是去使用placeholder节点 # 这些节点特点是它们不真正的计算，它们只是在执行过程中你要它们输出数据的时候去输出数据 # 它们会传输训练数据给TensorFlow在训练的时候 # 如果在运行过程中你不给它们指定数据，你会得到一个异常 # 需要做的是使用placeholder()并且给输出的tensor指定数据类型，也可以选择指定形状 # 如果你指定None对于某一个维度，它的意思代表任意大小 # 相当于占位，先挖一个空留着，后面执行的时候才填数据 A = tf.placeholder(tf.float32, shape=(None, 3)) B = A + 5 with tf.Session() as sess: B_val_1 = B.eval(feed_dict={A: [[1, 2, 3]]}) B_val_2 = B.eval(feed_dict={A: [["4", 5, 6], [7, 8, 9]]}) print(B_val_1) print(B_val_2) #!/usr/bin/python # -*- coding: UTF-8 -*- # 文件名: 12_Softmax_regression.py # 就是0～9图片的数据集 from tensorflow.examples.tutorials.mnist import input_data import tensorflow as tf __author__ = 'yasaka' # mn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be38c2a3582c9247b0ed174d3e8319b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4afaf2db6bbd7747675c57e1be1351b6/" rel="bookmark">
			Qt 的第一个的错误：Could not create directory
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用QT写了一个窗口程序，ctrl + r 后构建显示红色，编译输出信息栏显示：
Could not create directory “D:\Codes\Qt\Error in " Util.asciify(“build-untitled6-Desktop_Qt_5_5_1_MSVC2010_32bit-Debug”)”: TypeError: Property ‘asciify’ of object Core::Internal::UtilsJsExtension(0x1033120) is not a function"
解决方法1
解决方案2
或者你也可以像网上说的那样在项目那里把那个 shadow build的勾去了或者下面的路径修改一下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5798efc29b49456cc55aa6813a3d8dc/" rel="bookmark">
			IGMP基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IGMP基础 2019年09月26日 IGMP简介 IGMP是Internet Group Management Protocol的简称，又被称为互联网组管理协议，是TCP/IP协议族中负责IPv4组播成员管理的协议。IGMP用来在接收者主机和与其直接相邻的组播路由器之间建立和维护组播组成员关系。IGMP通过在接收者主机和组播路由器之间交互IGMP报文实现组成员管理功能，IGMP报文封装在IP报文中。
目的： IP组播通信的特点是报文从一个源发出，被转发到一组特定的接收者。但在组播通信模型中，发送者不关注接收者的位置信息，只是将数据发送到约定的目的组播地址。要使组播报文最终能够到达接收者，需要某种机制使连接接收者网段的组播路由器能够了解到该网段存在哪些组播接收者，同时保证接收者可以加入相应的组播组中。IGMP就是用来在接收者主机和与其所在网段直接相邻的组播路由器之间建立、维护组播组成员关系的协议。
IGMPv1工作原理 ICMPv1报文： IGMPv1包括两种类型的报文：
普遍组查询报文（General Query）：查询器向共享网络上所有主机和路由器发送的查询报文，用于了解哪些组播组存在成员。成员报告报文（Report）：主机向查询器发送的报告报文，用于申请加入某个组播组或者应答查询报文。 图：IGMPv1报文格式 字段说明VersionIGMP版本，值为1。Type报文类型。该字段有以下两种取值：0x11：表示普遍组查询报文。0x12：表示成员报告报文。Unused在IGMPv1中，该字段在发送时被设为0，并在接收时被忽略。ChecksumIGMP报文的校验和。校验和是IGMP报文长度（即IP报文的整个有效负载）的16位检测，表示IGMP信息补码之和的补码。Checksum字段在进行校验计算时设为0。当发送报文时，必须计算校验和并插入到Checksum字段中去。当接收报文时，校验和必须在处理该报文之前进行检验。Group Address组播组地址。在普遍组查询报文中，该字段设为0；在成员报告报文中，该字段为成员加入的组播组地址。 IGMPv1报文抓包示例： 图：IGMPv1报文实例 IGMPv1工作机制： IGMPv1协议主要基于查询和响应机制完成组播组管理。当一个网段内有多个组播路由器时，由于它们都可以接收到主机发送的成员报告报文，因此只需要选取其中一台组播路由器发送查询报文就足够了，该组播路由器称为IGMP查询器（Querier）。在IGMPv1中，由组播路由协议PIM选举出唯一的组播信息转发者（Assert Winner或DR）作为IGMPv1的查询器，负责该网段的组成员关系查询。
IGMPv1的工作机制可以分为：普遍组查询和响应机制、新成员加入机制和组成员离开机制三个方面。
普遍组查询和响应机制： 通过普遍组查询和响应，IGMP查询器可以了解到该网段内哪些组播组存在成员。
图：IGMPv1查询和响应示意图 如上图所示，普遍组查询和响应过程如下：
IGMP查询器发送目的地址为224.0.0.1（表示同一网段内所有主机和路由器）的普遍组查询报文；收到该查询报文的组成员启动定时器。
普遍组查询报文是周期性发送的，发送周期可以通过命令配置，缺省情况下每隔60秒发送一次。HostA和HostB是组播组G1的成员，则在本地启动定时器Timer-G1。缺省情况下，定时器的范围为0～10秒之间的随机值。
图：IGMPv1普遍组查询报文 如上图，为v1的查询报文，类型为0x11,目的IP地址为224.0.0.1。源IP地址为自己接口的IP地址。在组播地址中，填充为0.0.0.0。
第一个定时器超时的组成员发送针对该组的报告报文。
假设HostA上的Timer-G1首先超时，HostA向该网段发送目的地址为G1的报告报文。也想加入组G1的HostB收到此报告报文，则停止定时器Timer-G1，不再发送针对G1的报告报文。这样报告报文被抑制，可以减少网段上的流量。
图：IGMPv1报告报文抓包示例 如上图，为主机向路由器发送的报告报文，类型值为0x12，源IP地址为自己主机的IP地址，目的IP地址为组播地址。
IGMP查询器接收到HostA的报告报文后，了解到本网段内存在组播组G1的成员，则由组播路由协议生成（*，G1）组播转发表项，“ * ”代表任意组播源。网络中一旦有组播组G1的数据到达路由器，将向该网段转发。 新组成员加入机制： 图：新组成员加入示意图 如上图所示，主机HostC加入组播组G2的过程如下：
主机HostC不等待普遍组查询报文的到来，主动发送针对G2的报告报文以声明加入。IGMP查询器接收到HostC的报告报文后，了解到本网段内出现了组播组G2的成员，则生成组播转发项（*，G2）。网络中一旦有G2的数据到达路由器，将向该网段转发。 组成员离开机制： IGMPv1没有专门定义离开组的报文。主机离开组播组后，便不会再对普遍组查询报文做出回应。
假设HostA想要退出组播组G1
HostA收到IGMP查询器发送的普遍组查询报文时，不再发送针对G1的报告报文。由于网段内还存在G1组成员HostB，HostB会向IGMP查询器发送针对G1的报告报文，因此IGMP查询器感知不到HostA的离开。
假设HostC想要退出组播组G2
HostC收到IGMP查询器发送的普遍组查询报文时，不再发送针对G2的报告报文。由于网段内不存在组G2的其他成员，IGMP查询器不会收到G2组成员的报告报文，则在一定时间（缺省值为130秒）后，删除G2所对应的组播转发表项。
IGMPv2工作原理 IGMPv2的工作机制与IGMPv1基本相同，最大的不同之处在于IGMPv2增加了离开组机制。成员主机离开组播组时，会主动发送成员离开报文通知IGMP查询器；IGMP查询器收到成员离开报文后，会连续发送特定组查询报文，询问该组播组是否还存在组成员。如果在一段时间内没有收到成员主机发送的报告报文，IGMP查询器将不再维护该组的组成员关系。IGMPv2可以使IGMP查询器及时了解到网段内哪些组播组已不存在成员，从而及时更新组成员关系，减少网络中冗余的组播流量。
IGMPv2报文： 与IGMPv1相比，IGMPv2的变化如下：
除了普遍组查询报文和成员报告报文之外，IGMPv2新增了两种报文： 成员离开报文（Leave）：成员离开组播组时主动向查询器发送的报文，用于宣告自己离开了某个组播组。特定组查询报文（Group-Specific Query）：查询器向共享网段内指定组播组发送的查询报文，用于查询该组播组是否存在成员。 IGMPv2对普遍组查询报文格式也做了改进，添加了最大响应时间（Max Response Time）字段。此字段取值可以通过命令配置，用于控制成员对于查询报文的响应速度。 图：IGMPv2报文格式 字段解释：
Type：报文类型。该字段有以下四种取值：
0x11:表示查询报文。IGMPv2的查询报文包括普遍组查询报文和特定组查询报文两类。0x12:表示IGMPv1成员报告报文。0x16:表示IGMPv2成员报告报文。0x17:表示成员离开报文。 Max Response Time：最大响应时间。
成员主机在收到IGMP查询器发送的普遍组查询报文后，需要在最大响应时间内做出回应。该字段仅在IGMP查询报文中有效。
Group Address：组播组地址。
在普遍组查询报文中，该字段设为0.0.0.0。在特定组查询报文中，该字段为要查询的组播组地址。在成员报告报文和离开报文中，该字段为成员要加入或离开的组播组地址。 IGMPv2报文抓包示例： 图：IGMPv2查询报文 IGMPv2工作机制： 在工作机制上，与IGMPv1相比，IGMPv2增加了查询器选举和离开组机制。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5798efc29b49456cc55aa6813a3d8dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5ab25f41673618aa21243a12628f64c/" rel="bookmark">
			Android使用高德和风天气Sdk获取定位实况天气数据（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android使用高德和风天气Sdk获取定位实况天气数据（二） 先看一下效果关于实现第一步，引用高德api与和风天气第二步，修改AndroidManifest.xml第三步，修改activity_main.xml第四步，修改MainActivity.java 先看一下效果 关于 首先我们需要需要申请高德开发者，获取key，这个我在Android使用高德地图api实现基础定位（来实现获取到定位位置的经纬度）有具体的介绍使用，我们还需要一个和风天气的天气Androidsdk用于获取天气以及和风天气webapi来根据经纬度获取城市的详细信息来获取到城市码，毕竟和风天气根据城市码来获取相应的天气。
这里我晒一下和风天气的应用：
这两个是必须的哦。
关于和风天气图片的加载用的是glide加载框架。
实现 第一步，引用高德api与和风天气 关于和风天气sdk的下载可以到和风天气开发者里下载，应该是v3.1版本的，或者参考我的Android和风天气sdk
关于ButterKnife如果想使用的话引用参考Android使用ButterKnife与和风天气sdk或者是在oncreate中获取实例。
在项目的build.gradle中添加如下：
//使用okhttp请求网络 implementation 'com.squareup.okhttp3:okhttp:3.9.0' implementation 'com.google.code.gson:gson:2.6.2' //使用glide加载天气图片 implementation 'com.github.bumptech.glide:glide:4.2.0' //高德定位及3D地图 implementation 'com.amap.api:3dmap:latest.integration' implementation 'com.amap.api:location:latest.integration' 第二步，修改AndroidManifest.xml &lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" /&gt; &lt;!-- 用于进行网络定位 --&gt; &lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" /&gt; &lt;!-- 用于访问GPS定位 --&gt; &lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" /&gt; &lt;!-- 用于获取运营商信息，用于支持提供运营商信息相关的接口 --&gt; &lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /&gt; &lt;!-- 用于访问wifi网络信息，wifi信息会用于进行网络定位 --&gt; &lt;uses-permission android:name="android.permission.ACCESS_WIFI_STATE" /&gt; &lt;!-- 用于获取wifi的获取权限，wifi信息会用来进行网络定位 --&gt; &lt;uses-permission android:name="android.permission.CHANGE_WIFI_STATE" /&gt; &lt;!-- 用于访问网络，网络定位需要上网 --&gt; &lt;uses-permission android:name="android.permission.INTERNET" /&gt; &lt;!-- 用于读取手机当前的状态 --&gt; &lt;uses-permission android:name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5ab25f41673618aa21243a12628f64c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60fc879dc831e022fc82c10c0ed98833/" rel="bookmark">
			Spring阶段性学习总结（十 二）切面的优先级的优先级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		配置优先级十分简单，只需要在切面添加注解，@order(number)即可，参数越小，优先级越高
转载于:https://www.cnblogs.com/zhang188660586/p/11588715.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f96da6783c4bfb7946c5f7ae8f2bb81d/" rel="bookmark">
			time包中Parse和Format的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		time包中Parse和Format的区别 参考代码 package main import( "fmt" "time" ) // 规定parse和Format的参考时间，这个是官方规定的 const longForm = "Jan 2, 2006 at 3:04pm (MST)" const shortForm = "2006-Jan-02" const timeFormat = "2006-01-02 15:04:05" func main(){ //根据格式，将字符串转变为时间类型，第一个参数表示时间的格式，第二参数表示目标字符串 //t, err:= time.Parse(longForm, time.Now().String()) //这个是错误，因为没有符合longForm的格式 //if err!=nil{ // panic(err) //}else{ // fmt.Println(t) //} t, _ := time.Parse(shortForm, "2020-Feb-03") fmt.Printf("类型： %T，值%v \n",t,t) t2 := time.Now() strTime := t2.Format(timeFormat) fmt.Printf("类型： %T，值%v \n",strTime,strTime) } 输出结果 类型： time.Time，值2020-02-03 00:00:00 +0000 UTC 类型： string，值2019-09-26 00:08:31 总结：两者的区别：Format表示将时间转化为字符串，parse表示将字符串转化为时间 转载于:https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f96da6783c4bfb7946c5f7ae8f2bb81d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b8102a38aa5af3162be3189405c3d73/" rel="bookmark">
			【2019.9.25】Za
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		容斥 容斥 \(\Big|\bigcup\limits_{i=1}^nS_i\Big|=\sum\limits_{m=1}^n(-1)^{m-1}\ \sum\limits_{a_i&lt;a_{i+1}}\Big|\bigcap\limits_{i=1}^mS_{a_i}\Big|\)
不定方程非负整数解计数
不定方程\(\sum_{i=1}^n\ x_i=m\)和\(n\)个限制条件\(x_i\le b_i\)
没有限制时 其非负整数解为\(C_{m+n-1}^{m-1}\) 相当于有\(m\)个球分给\(n\)个盒子 允许有空盒子
容斥：
1. 全集$\cup$：不定方程$\sum_{i=1}^n\ x_i=m$的非负整数解 有$C_{m+n-1}^{m-1}$个 元素：变量\(x_i\)属性：\(x_i\)的属性即其限制条件 目标：满足对应关系时集合大小\(\Big|\bigcap_{i=1}^n\ S_i\Big|\)
\(\Big|\bigcap_{i=1}^n\ S_i\Big|=\Big|\bigcup\Big|-\Big|\bigcup_{i=1}^n\overline{S_i}\) 即变为对于一些
HAOI2008硬币购物 即可转化为求方程\(\sum_{i-1}^4\ C_ix_i=S,x_i\le D_i\)的非负整数解的个数
最后求解\(\sum\limits_{i=1}^4C_ix_i=S-\sum\limits_{i=1}^kC_{a_i}(D_{a_i}+1)\)
int main(){ f[0]=1; for(int i=1;i&lt;=4;++i){ rd(a[i]); for(int v=a[i];v&lt;M;++v) f[v]+=f[v-a[i]]; } int T;rd(T); while(T--){ rd(d[1]),rd(d[2]),rd(d[3]),rd(d[4]),rd(s); ans=0; for(int i=1,m,bit;i&lt;(1&lt;&lt;4);++i){//二进制枚举集合 m=s,bit=0; for(int j=1;j&lt;=4;++j) if((i&gt;&gt;(j-1))&amp;1) m-=(d[j]+1)*a[j],++bit; if(m&gt;=0) ans+=(bit%2*2-1)*f[m];//奇加偶减 } printf("%lld\n",f[s]-ans); } } 以前写的是dfs版
void dfs(int nw,int mon,int fla){ if(mon&lt;0) return; if(nw&gt;4) {ans+=f[mon]*fla;return;} dfs(nw+1,mon,fla); dfs(nw+1,mon-a[nw]*(d[nw]+1),-fla); } int main(){ f[0]=1; for(int i=1;i&lt;=4;++i){ rd(a[i]); for(int v=a[i];v&lt;M;++v) f[v]+=f[v-a[i]]; } rd(T); while(T--){ for(int i=1;i&lt;=4;++i) rd(d[i]); rd(m); ans=0; dfs(1,m,1); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b8102a38aa5af3162be3189405c3d73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/556d7349c30e3b97f4db2c264d82ed8a/" rel="bookmark">
			Springboot输出PDF文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 有个人（死需求）跑过来跟你说，这些都给我输出成报告，pdf格式的，所以就有了下面这个，做一下笔记，以后有用直接过来拿。在网上找了一下，发现大家都是在用itext。
iText是著名的开放项目，是用于生成PDF文档的一个java类库。通过iText不仅可以生成PDF或rtf的文档，而且可以将XML、Html文件转化为PDF文件。
http://itextpdf.com/
maven依赖 &lt;dependency&gt; &lt;groupId&gt;com.itextpdf&lt;/groupId&gt; &lt;artifactId&gt;itextpdf&lt;/artifactId&gt; &lt;version&gt;5.5.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.itextpdf&lt;/groupId&gt; &lt;artifactId&gt;itext-asian&lt;/artifactId&gt; &lt;version&gt;5.2.0&lt;/version&gt; &lt;/dependency&gt; 基础操作 itext有很多功能，这里先说基本的操作。其他更多高级的操作，可以继续看下面的。
基本处理步骤如下伪代码：
//Step 1—Create a Document. Document document = new Document(); //Step 2—Get a PdfWriter instance. PdfWriter.getInstance(document, new FileOutputStream(FILE_DIR + "createSamplePDF.pdf")); //Step 3—Open the Document. document.open(); //Step 4—Add content. document.add(new Paragraph("Hello World")); //Step 5—Close the Document. document.close(); 1、直接输出数据到pdf文件 这里有个特别注意的是，中文必须要指定字体，即是BaseFont
public class PDFReport { private final static String REPORT_PATH = "C:/air-navi-monitor/report"; private static void exportReport() { BaseFont bf; Font font = null; Font font2 = null; try { bf = BaseFont.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/556d7349c30e3b97f4db2c264d82ed8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd138f22575f57d6ab1284eda2bbe732/" rel="bookmark">
			【Activiti】使用学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Activiti】使用学习
转载：
==================================================
==================================================
转载于:https://www.cnblogs.com/yangchongxing/p/11585095.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5f15bfdc80a00774180d6101f2f633f/" rel="bookmark">
			安卓设置FloatingActionButton图片居中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 给FloatingActionButton组件添加 app:fabCustomSize属性，值与layout_width和layout_height的值相等即可。 &lt;com.google.android.material.floatingactionbutton.FloatingActionButton android:id="@+id/add_alarm" android:src="@drawable/add" android:layout_width="50dp" android:layout_height="50dp" app:fabCustomSize="50dp" app:backgroundTint="#BEBFC3" app:borderWidth="0.0dip" app:elevation="5.0dip" android:layout_gravity = "bottom|center" android:layout_margin = "16dp"&gt; &lt;/com.google.android.material.floatingactionbutton.FloatingActionButton&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/307f5077de90be53dbf725d18594711e/" rel="bookmark">
			Spring阶段性学习总结（十 一）Aspect实现各种通知
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 package SpringAopImp; 2 3 public interface Calculator { 4 int add(int i, int j); 5 int sub(int i, int j); 6 int mul(int i, int j); 7 int div(int i, int j); 8 } 1 package SpringAopImp; 2 3 4 import org.springframework.stereotype.Component; 5 6 @Component 7 public class CalculatorImp implements Calculator { 8 9 @Override 10 public int add(int i, int j) { 11 int result=i+j; 12 System.out.println("Method is Running"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/307f5077de90be53dbf725d18594711e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64dac7ce701cf20f4c3499d4be1e3d69/" rel="bookmark">
			小程序如何提交代码到git
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		......小程序的提交的不友善性我真的想杀人了
我的代码是直接提交的微信的仓库中，已经创建好仓库并关联代码了
第一 设置网络认证（你不会自己找么。git base就能。是不是傻）
第二 工作区 全选 写上描述 相当于commit了
第三步 完成提交
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35d53f94b4bcb6b7986b7e2dc043e6e0/" rel="bookmark">
			量化投资——IC、IR、RankIC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在量化投资中，IC和IR是用来计算因子好坏的一个标准。在多因子模型中，IC的值如果大于0.03则可能说明该因子是个不错的因子，和收益率有较大的相关性。那么我们应该如何来计算IC呢，IR又是什么东西呢，我将在本文中对IC、IR的计算方法以及含义进行介绍，并引出RankIC的计算方法。
1、IC **IC即信息系数（Information Coefficient），表示所选股票的因子值与股票下期收益率的截面相关系数，通过 IC 值可以判断因子值对下期收益率的预测能力。**信息系数的绝对值越大，该因子越有效。IC为负表示因子值越小越好，IC为正表示因子值越大越好。IC的计算方法是：计算全部股票在调仓周期期初排名和调仓周期期末收益排名的线性相关度（Correlation）。IC越大的因子，选股能力就越强。
IC最大值为1，表示该因子选股100%准确，对应的是排名分最高的股票，选出来的股票在下个调仓周期中，涨幅最大；相反，如果IC值为-1，则代表排名分最高的股票，在下个调仓周期中，跌幅最大，是一个完全反向的指标。
实际上，反向的指标也是非常有意义的。最无用的IC值是0或者接近0的值，这代表该因子对于股票没有任何的预测能力。当IC的绝对值大于0.03时（若要求更为严格，则限制在0.05），因子的选股能力较强。
2、IR IR即信息比率（Information Ratio），是超额收益的均值与标准差之比，可以根据 IC 近似计算，公式如下。该公式是从超额收益出发，逐步推导得出的。IR= IC的多周期均值/IC的标准方差，代表因子获取稳定Alpha的能力。整个回测时段由多个调仓周期组成，每一个周期都会计算出一个不同的IC值，IR等于多个调仓周期的IC均值除以这些IC的标准方差。所以IR兼顾了因子的选股能力（由IC代表）和因子选股能力的稳定性（由IC的标准方差的倒数代表），当IR大于0.5时因子稳定获取超额收益能力较强。
IC的计算公式如下：
I R ≈ I C t ‾ s t d ( I C t ‾ ) IR\approx \frac{\overline{IC_{t}}}{std(\overline{IC_{t}})} IR≈std(ICt​​)ICt​​​
3、RankIC 由于IC的值是连续型，为了防止计算过程中由于因子值差距过大，所以发明了RankIC的计算，即某时点某因子在全部股票暴露值排名与其下期回报排名的截面相关系数，它与IC的区别就是将因子的具体值以及收益的具体值，都转换为了所对应的数值在其截面上的排序名次。然后通过计算排序值的相关系数，得到RankIC。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74a3f2861effc620d47af5cdaa4db49f/" rel="bookmark">
			并发编程之上下文切换学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍上下文切换之前先介绍一下进程、线程的相关概念，以便于更好地理解上下文切换
进程：在操作系统中的定义是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位。在早期的操作系统中，确实是由进程直接执行程序的，所谓程序就是数据、指令及其组织形式的描述。进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度
线程：早期的操作系统程序是由进程执行，现在的操作系统就是由线程执行的，进程是线程的容器，每一个进程都有它自己的地址空间，一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。线程拥有自己独立的栈和共享的堆，线程是共享堆，不共享栈的，线程同样由操作系统调度
协程：协程与子例程类似。协程（coroutine）也是一种程序组件。协程和线程一样共享堆，不共享栈。协程由程序员代码控制是否调度，代码控制得好的话，是可以避免无意义的调度的，所以协程是可以用于避免
在java原生的jdk没有提供对应的api，只能通过第三方组件来做，github上有两个是支持的框架，https://github.com/offbynull/coroutines，https://github.com/kilim/kilim
上下文切换(context switch)：对于单核CPU来说，在一个时刻只能运行一个线程，对于并行来说，单核cpu也是可以支持多线程执行代码的，CPU是通过给线程分配时间片来解决的，所谓时间片是CPU给每个现场分配的时间，时间片的时间是非常短的，所以执行完成一个时间片后，进行任务切换，切换之前先保存这个任务的状态，以便于下次换回来的时候，可以加载这个任务的状态，所以从保存任务状态到再加载任务的过程称为上下文切换，不仅在线程间可以上下文切换，进程也同样可以
上下文切换测试：
Lmbench3 [1] 可 以 测 量 上 下 文 切 换 的 时 长。使 用 vmstat 可 以 测 量 上 下 文 切 换 的 次 数。 避免上下文切换方法：
多线程的锁竞争会导致上下文切换频繁，所以就可以从这两方面下手，一个方面是锁，就是尽量不用锁；一个方面是线程，不用线程，用其它方法替换
取模分段，将id按照hash算法取模分段，不同线程处理不同端的数据CAS算法，java中的Atomic就是使用CAS算法来更新数据，并没有使用锁使用协程的方法，在不必要的地方就不调用，避免上下文切换volatitle的应用，volatile关键字可以说是轻量级的锁，volatile关键字是实现线程操作可见性的，可以用于避免上下文切换 转载于:https://www.cnblogs.com/mzq123/p/11582282.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6b5f7e372d448fc42d708963d00c4d2/" rel="bookmark">
			java线程join方法使用方法简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本博客简介介绍一下java线程的join方法，join方法是实现线程同步，可以将原本并行执行的多线程方法变成串行执行的
如图所示代码，是并行执行的
public class ThreadTest { //private static final Long count = 10000L; public static void main(String[] args){ long base = System.currentTimeMillis(); try { ThreadJoin t1 = new ThreadJoin("线程1"); ThreadJoin t2 = new ThreadJoin("线程2"); t1.start(); t2.start(); } catch (Exception e) { e.printStackTrace(); } long time = System.currentTimeMillis() - base; System.out.println("执行时间："+time); } } class ThreadJoin extends Thread{ private static final Long count = 10L; public ThreadJoin(String name){ super(name); } @Override public void run() { //super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6b5f7e372d448fc42d708963d00c4d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a734fb0386b4268e111adf7035a025e3/" rel="bookmark">
			JAVA个版本新特性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JDK Version 1.1 1997-02-19
JDBC(Java DataBase Connectivity);支持内部类;RMI(Remote Method Invocation) ;反射;Java Bean; JDK Version 1.2 1998-12-08 Playground(操场)
集合框架;JIT(Just In Time)编译器;对打包的Java文件进行数字签名;JFC(Java Foundation Classes), 包括Swing 1.0, 拖放和Java2D类库;Java插件;JDBC中引入可滚动结果集,BLOB,CLOB,批量更新和用户自定义类型;Applet中添加声音支持. JDK Version 1.3 2000-05-08 Kestrel(红隼)
Java Sound API;jar文件索引;对Java的各个方面都做了大量优化和增强; JDK Version 1.4 2002-02-13 Merlin(隼)
XML处理;Java打印服务;Logging API;Java Web Start;JDBC 3.0 API;断言;Preferences API;链式异常处理;支持IPV6;支持正则表达式;引入Imgae I/O API. JAVA 5 2004-09-30 Tiger(老虎)
泛型;增强循环,可以使用迭代方式;自动装箱与自动拆箱;类型安全的枚举;可变参数;静态引入;元数据(注解);Instrumentation; JAVA 6 2006-12-11 Mustang(野马)
支持脚本语言;JDBC 4.0API;Java Compiler API;可插拔注解;增加对Native PKI(Public Key Infrastructure), Java GSS(Generic Security Service),Kerberos和LDAP(Lightweight Directory Access Protocol)支持;继承Web Services; JAVA 7 2011-07-28 Dolphin(海豚)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a734fb0386b4268e111adf7035a025e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1b64fb5ebf81f938e7628bacceecf7d/" rel="bookmark">
			keras训练准确率和损失表现都非常好，预测时准确率和损失都非常差
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题简述：
在keras框架下使用model.fit得到的训练准确率和损失表现都非常好，但是在相同的训练集上使用model.evaluate得到的准确率和损失都非常差
keras中的model.fit和model.evaluate在同样的数据集上的准确率acc和损失值loss存在巨大的差异
https://github.com/keras-team/keras/issues/6977
上面的github链接讨论了多种可能，
1.model.fit和model.evaluate的batch_size不匹配：model.fit时若指定了batch_size，在使用model.evaluate时的batch_size默认为16，而使用model.evaluate时并未设置与使用model.fit时同样的batch_size。解释大概为不同的batch_size的BatchNormalizaiton会产生不同的效果不同(当然在神经网络中存在BatchNormalization层时）
结果：匹配batch_size了也无效
2.dropout,batchnorm的影响：model.fit时的dropout层是设置dropout参数的，比如说0.5，而model.evaluate设置的dropout参数为1，keras在使用这两个function的时候会呈现两种模式(training mode, predict mode)，model.fit时为training mode，dropout参数值为0.5，model.evaluate时为predict mode，dropout参数值自动调至1。同样的，batchnorm在两种模式下的效果也是不一样的。
结果：这样的话问题就有一个很好的解决思路，就是在model.evaluate时，把模式定为training mode，这样就可以得到和训练时一样的效果。事实上也是这样的，使用from keras import backend as K, K.set_learning_phase(0)（这里是强制整个session为training mode包括在model.fit后使用model.evaluate），调用model.fit训练后，直接在这个session里对之前的训练集数据使用model.evaluate，得到的是与model.fit训练的最后一次的结果是非常相近的。但是你只在这个session里强制设置了training mode，把该模型保存后再重新开一个py文件或ipynb文件读取该模型(由于项目指定的tensorflow版本较低，使用model.save保存模型所有内容有问题，所以使用了model.save_weights;model.save下，下述方法没试），再使用对上述相同的训练集数据进行model.evaluate，又出现了很差的准确率和损失，当然即使在模型读取前再写上K.set_learning_phase(0)。
等等还有讨论的其他可能原因就不细说了，来说说最简单粗暴的解决方法：
####################################################################################
####################################################################################
###################################超粗的分割线#######################################
####################################################################################
####################################################################################
别用keras了，直接用tensorflow码代码把。。。。。keras的好多Conv2d，Batchnormalization，Dense啊，在tf.layers里都有，虽然写着tf代码烦点，但起码各种东西都可以自己定义。。。。keras虽说非常简便，但封装的太好了，能调的东西不多，这种问题就是属于bug类的，暂时查遍github，stackoverflow，bing都没找到在不换框架下解决问题的，真的，没办法。。。。所以放弃keras把
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/225d3914612d7be14f47728b67ac6a18/" rel="bookmark">
			@Bean的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@Bean是一个方法级别上的注解，主要用在@Configuration注解的类里，也可以用在@Component注解的类里。目的是创建一个类。当spring需要创建指定的一个类时会调用这个注解（@Bean）的方法。
一个对象
@Data @AllArgsConstructor @NoArgsConstructor public class Info { String name; int age; } 就如同在在xml配置中添加一个类的配置。这样spring在自动创建这个类时会调用配置的方法。
&lt;bean id="info" class="zhong.test.springbootdemo.usultestdemo.demo.Info"&gt; &lt;property name="name" value="sjl"/&gt; &lt;property name="age" value="18"/&gt; &lt;/bean&gt; SprignBoot中 @Bean 完美的替换了了上面的这种在xml中配置的方法。使用以下方法就能让spring在需要自动创建Info对象时，自动调用这个方法。
@Configuration public class BeanInit { /** * 测试@Bean的作用 */ @Bean(name = "info") public Info getInfo(){ return new Info("gfagduis", 2343); } @Bean(name = "info1") public Info getInfo1(){ return new Info("gfagdufasfdfdais", 2343); } } 获取这个类的方法：
AnnotationConfigApplicationContext 类获取 @Component public class BeanTest implements CommandLineRunner { private void getBean(){ ApplicationContext ctx = new AnnotationConfigApplicationContext(BeanInit.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/225d3914612d7be14f47728b67ac6a18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f286222ce4216810f26d5d414b801a0/" rel="bookmark">
			Java调用第三方http接口  单点登录   HttpClient
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java调用第三方http接口的方式 Java调用第三方接口示范 范例： 响应形式： 主逻辑： 访问此地址：http:// { cas }/cas/login?service=http://localhost/Demo 认证通过后：http://localhost/Demo?ticket=ST-9-C6sjiJ4xqn0ydAsWSXBt-{ cas } 后端访问地址为：http://{ cas }/cas/serviceValidate?ticket={ ticket }&amp;service={ service } 校验通过：重定向登录操作 实现： package com.company.xxx.servlet; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.net.HttpURLConnection; import java.net.MalformedURLException; import java.net.ProtocolException; import java.net.URL; import java.util.HashMap; import java.util.List; import java.util.Map; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import com.xxx.FUser; import com.xxx.FUserFilterAdmin; import com.xxx.Context; import com.xxx.SystemContextUtil; public class HEBOAServlet extends HttpServlet { private static final long serialVersionUID = 1L; public static String exitUrl = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f286222ce4216810f26d5d414b801a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2563f21edb4d7fb21e44e64776b5602/" rel="bookmark">
			Vue中使用Sortable bug:排序混乱、与数据不一致、拖拽结束后回跳
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		更新 20/11/7
因为研究了patch算法，所以又质疑自己之前答案，目前有两种可能，待验证
正确绑定key（patch算法） 在封装组件中，绑定数组下标，不出现问题，在有其他列表渲染情况下，绑定下标出现了错误（偶然）
在list中的对象（响应式数据）中添加一个唯一id绑定似乎就解决了这个问题;
一个列表中index是唯一，即按照patch源码来说是有差异，可比较出来的。所以，要么是patch方法有问题，要么是vdom和真实dom(更新)绑定有问题
vdom和真实dom(更新)绑定问题 draggable操作了真实dom（需要看源码确认），drag后回调函数中操作了vue的响应式数据 =》 vdom diff =》 真实dom改变。
解决方式可以参考https://www.jianshu.com/p/d92b9efe3e6a
不全认同上文，但是为我说清了大多问题
原文 2019-09-24 14:15:18
先答案 推荐方案：正确绑定key
https://www.jianshu.com/p/d92b9efe3e6a
此文很详细了，各位应该看这个就够了，方案也在里面，我尽量不重复造轮子，做补充。
原因： VUE中的virtualDom与真实dom不匹配
思路 现象 1.打印数据是正常的
2.观察到拖拽dom对象后，dom对象又被调换回去
3.当不对data数据进行操作是正常的
4.我写了一个单文件组件，正常，出bug页面引用也正常。同事直接复制代码就bug了
5.绑定了key值的，绑定方式为绑定数组下标
v-for="(item,index) in navList" :key="index" 猜测与尝试 1.根据现象123，有可能是dom 与数据层出了差错，所以要正确绑定
但是key已经绑定，我再考虑是否是变量污染，是其他地方的index，于是把index的名字改了，无用
2.怀疑数据层有问题，用不同变量绑定，然后用watch，compute等关联，并且尝试深浅拷贝对象，无用
3.因为数据层显示一直正确，假设无问题，所以在每次拖拽后重新初始化一边，Sortable.create（），无用
4.怀疑是Sortable源码问题，或者使用配置某个字段有问题，也尝试阅读Sortable文档，查找相关bug，逐个配置字段修改尝试，未果。
5.现象3验证现象2
6.最后还是查看了数据格式，有个key值，重新绑定了下key
结论 根据上面链接文章完善：
操作了真实dom，但是因为绑定问题，虚拟dom并未检测到dom变化。
操作后dom对象已经替换，然后触发方法中修改了数据层，数据更新自然开始更新视图层，被打乱。
引用上面链接：
拖拽移动真实DOM -&gt; 操作数据数组 -&gt; Patch算法再更新真实DOM 其他链接 virtual-dom(Vue实现)简析
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9d78d14e6f43e10c978f5e017ae9ec7/" rel="bookmark">
			coding&#43;&#43;：Java 中Model 与 实体的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		model的字段&gt;entity的字段，并且model的字段属性可以与entity不一致，model是用于前端页面数据展示的，而entity则是与数据库进行交互做存储用途。
举个例子：
比如在存储时间的类型时，数据库中存的是datetime类型，entity获取时的类型是Date（）类型，date型的数据在前端展示的时候必须进行类型转换（转为String类型），在前端的进行类型转换则十分的麻烦，转换成功了代码也显得十分的臃
肿，所以将entity类型转换后，存储到对应的model中，在后台做类型转换，然后将model传到前端显示时，前端的就十分的干净。
同时也可以添加字段，作为数据中转。
转载于:https://www.cnblogs.com/codingmode/p/11577456.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8876aee09e70bfbe858f980c4367882/" rel="bookmark">
			BlockingQueue深入解析之一DelayQueue
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、初识阻塞队列
在新增的Concurrent包中，BlockingQueue很好的解决了多线程中，如何高效安全“传输”数据的问题。通过这些高效并且线程安全的队列类，为我们快速搭建高质量的多线程程序带来极大的便利。本文详细介绍了BlockingQueue家庭中的所有成员，包括他们各自的功能以及常见使用场景。
BlockingQueue的核心方法：
public interface BlockingQueue&lt;E&gt; extends Queue&lt;E&gt; { //将给定元素设置到队列中，如果设置成功返回true, 否则返回false。如果是往限定了长度的队列中设置值，推荐使用offer()方法。 boolean add(E e); //将给定的元素设置到队列中，如果设置成功返回true, 否则返回false. e的值不能为空，否则抛出空指针异常。 boolean offer(E e); //将元素设置到队列中，如果队列中没有多余的空间，该方法会一直阻塞，直到队列中有多余的空间。 void put(E e) throws InterruptedException; //将给定元素在给定的时间内设置到队列中，如果设置成功返回true, 否则返回false. boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException; //从队列中获取值，如果队列中没有值，线程会一直阻塞，直到队列中有值，并且该方法取得了该值。 E take() throws InterruptedException; //在给定的时间里，从队列中获取值，时间到了直接调用普通的poll方法，为null则直接返回null。 E poll(long timeout, TimeUnit unit) throws InterruptedException; //获取队列中剩余的空间。 int remainingCapacity(); //从队列中移除指定的值。 boolean remove(Object o); //判断队列中是否拥有该值。 public boolean contains(Object o); //将队列中值，全部移除，并发设置到给定的集合中。 int drainTo(Collection&lt;? super E&gt; c); //指定最多数量限制将队列中值，全部移除，并发设置到给定的集合中。 int drainTo(Collection&lt;?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8876aee09e70bfbe858f980c4367882/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f815bb04e44a490e118618d96e8946c/" rel="bookmark">
			定时任务 Cron表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. cron表达式
有专门的语法，而且感觉有点绕人，不过简单来说，大家记住一些常用的用法即可，特殊的语法可以单独去查。
cron一共有7位，但是最后一位是年，可以留空，所以我们可以写6位：
第一位，表示秒，取值0-59 第二位，表示分，取值0-59 第三位，表示小时，取值0-23 第四位，日期天/日，取值1-31 第五位，日期月份，取值1-12 第六位，星期，取值1-7，星期一，星期二…，注：不是第1周，第二周的意思 ​ 另外：1表示星期天，2表示星期一。 第7为，年份，可以留空，取值1970-2099 2. cron中，还有一些特殊的符号，含义如下：
(*) 星号：可以理解为每的意思，每秒，每分，每天，每月，每年… (?)问号：问号只能出现在日期和星期这两个位置，表示这个位置的值不确定，每天3点执行，所以 * 第六位星期的位置，我们是不需要关注的，就是不确定的值。同时：日期和星期是两个相互排斥的* 元素，通过问号?来表明不指定值。比如，1月10日，比如是星期1，如果在星期的位置是另指定星期二，就前后冲突矛盾了。 (-)减号：表达一个范围，如在小时字段中使用“10-12”，则表示从10到12点，即10,11,12 (,)逗号：表达一个列表值，如在星期字段中使用“1,2,4”，则表示星期一，星期二，星期四 (/)斜杠：如：x/y，x是开始值，y是步长，比如在第一位（秒） 0/15就是，从0秒开始，每15秒，最后就是0，15，30，45，60 另：/y，等同于0/y 3. 常用的表达式例子：
0 0 3 * * ? 每天3点执行 0 5 3 * * ? 每天3点5分执行 0 5 3 ? * * 每天3点5分执行，与上面作用相同 0 5/10 3 * * ? 每天3点的 5分，15分，25分，35分，45分，55分这几个时间点执行 0 10 3 ? * 1 每周星期天，3点10分 执行，注：1表示星期天 0 10 3 ? * 1#3 每个月的第三个星期天 执行，#号只能出现在星期的位置 0 * * * * ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f815bb04e44a490e118618d96e8946c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b9e143c8d46dc715e62a7bc791986c2/" rel="bookmark">
			Python实例--输入两个正整数m和n，求其最大公约数和最小公倍数。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：输入两个正整数m和n，求其最大公约数和最小公倍数。 代码如下： m=m1=eval(input('请输入第一个正整数：')) n=n1=eval(input('请输入第二个正整数：')) if m1&gt;=n1: #判断m和n哪个为较大的数 while n1 !=0 : #较小的数为0时，返回的大数即为最大公约数 a=m1%n1 m1=n1 #将小数作为下一轮循环的大数 n1=a #将大数除于小数得到的的余数作为下一轮循环的小数 u = (m * n) // m1 #最小公倍数为两数之积除以最大公约数 print('最大公约数%d\n最小公倍数%d'%(m1,u)) else: while m1 != 0: a=n1%m1 n1=m1 m1=a u = (m * n) // n1 print('最大公约数%d\n最小公倍数%d'%(n1,u)) 运行结果： 请输入第一个正整数：14
请输入第二个正整数：4
最大公约数2
最小公倍数28
进程已结束,退出代码0
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ebf089901af490252a591ae22e7cbf7/" rel="bookmark">
			JAVA下拉列表框组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.JComboBox类 Swing中的下拉列表框使用JComboBox类对象来表示，它是javax.swing.JComponent类的子类。
它的常用构造方法如下：
public JComboBox().public JComboBox(ComboBoxModel dataModel).public JComboBox(Object[] arrayData).public JComboBox(Vector vector).
在初始化下拉列表框时，可以选择同时指定下拉列表框中的项目内容，也可以在程序中使用其他方法设置下拉列表框中的内容，下拉列表框中的内容可以被封装在ComboBoxModel类型、数组或Vector类型中。 import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import javax.swing.*; public class Demo12 extends JFrame{ public Demo12() { setBounds(100,100,190,120); setDefaultCloseOperation(EXIT_ON_CLOSE); Container c=getContentPane(); c.setLayout(null); JComboBox&lt;String&gt; comboBox=new JComboBox&lt;&gt;(); comboBox.addItem("身份证"); comboBox.addItem("学生证"); comboBox.addItem("工作证"); JButton btn =new JButton("打印"); btn.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { System.out.println("选中的索引"+comboBox.getSelectedIndex()); System.out.println("选中的值"+comboBox.getSelectedItem()); } }); btn.setBounds(100, 10, 60, 20); c.add(btn); comboBox.setBounds(10, 10, 80, 21); c.add(comboBox); setVisible(true); } public static void main(String[] args) { new Demo12(); } } import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ebf089901af490252a591ae22e7cbf7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3045f73b14715b0e7579a445a64bd62e/" rel="bookmark">
			Spring事务异常rollback-only 笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		造成以上异常的原因情形:
在spring里面我们配置了事务的传播机制是REQUIRED，所以这两个事务最终会合并成一个事务。
当a方法调用b方法时，程序中a方法中由于某某原因导致抛出异常（或者明确将该事务设置为了RollbackOnly），但是由于其内部已经捕获了这个异常，所以不会影响外面b方法的继续执行，
当外面的b方法执行完 且准备提交(commit)这个事务时，发现之前这个事务的状态位已经被设置为了RollbackOnly，此时spring就会抛出一个transaction rolled back because it has been marked as rollback-only。
回滚事务异常报错： java.lang.RuntimeException: org.apache.cxf.interceptor.Fault: Transaction rolled back because it has been marked as rollback-only 发生的场景：由于是webservice 接口 服务，当客户端调用接口方法时，service当中有异常抛出时需要回滚之前的数据库操作。后台就抛出回滚失败事务异常。
解决办法是：Spring 事务的传播属性 PROPAGATION_REQUIRED 改为 PROPAGATION_REQUIRES_NEW ，虽然解决了可以正常操作，但是还是要理解这个属性，是否会带来其它的影响。
针对单个方法添加事务传播属性：
//添加事务注解 //1.使用 propagation 指定事务的传播行为, 即当前的事务方法被另外一个事务方法调用时 //如何使用事务, 默认取值为 REQUIRED, 即使用调用方法的事务 //REQUIRES_NEW: 使用自己的事务, 调用的事务方法的事务被挂起. //2.使用 isolation 指定事务的隔离级别, 最常用的取值为 READ_COMMITTED //3.默认情况下 Spring 的声明式事务对所有的运行时异常进行回滚. 也可以通过对应的 //属性进行设置. 通常情况下去默认值即可. //4.使用 readOnly 指定事务是否为只读. 表示这个事务只读取数据但不更新数据, //这样可以帮助数据库引擎优化事务. 若真的事一个只读取数据库值的方法, 应设置 readOnly=true //5.使用 timeout 指定强制回滚之前事务可以占用的时间.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3045f73b14715b0e7579a445a64bd62e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/772612bf917c290084c63d52a414e94d/" rel="bookmark">
			随便转载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://mguba.eastmoney.com/mguba/article/0/876052153
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8de049581c8ef3d5df4cd4ee6d613f46/" rel="bookmark">
			表单元素中readonly和disabled区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.作用元素： readonly只对input(type=“text”、password、number）和textarea元素有效；
disabled对所有表单元素有效；
2. 表单提交： 表单会提交readonly元素，不会提交disabled元素
3. 实际使用情况： 表单中预填了某个值，不允许用户改动，但提交表单时需要传该值，此时使用readonly。用户点了提交按钮后，需要用js把提交按钮disabled掉，这样可以防止网络较差时用户反复点击提交按钮。用户提交含多种元素的表单后，只允许查看表单，此时使用disabled，因为disable对所有表单元素有效。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e447d9b1507f68dafff021430858c3c1/" rel="bookmark">
			eclipse  配置参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		-vmargs
-XX:+UseParallelGC
-Dosgi.requiredJavaVersion=1.8
-Xms128m
-Xmx2048m
-XX:PermSize=128m
-XX:MaxPermSize=128m
-Xms:是初始分配的堆内存
-Xmx:是最大的分配的堆内存
超出了xms的大小，JVM会向系统继续要内存，如果一直扩展到Xmx都不够的话，这是就抛出OOM了。
-XX:PermSize：是默认永生代大小，永生代主要用来加载类和常量池，这部分很难GC。JDK8的Hotspot已经取消了永生代，改为元空间，元空间不需要指定大小，会自动扩展。
-XX:MaxPermSize：是永生代大小上限。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3861438fdc7cc62dd8d79f4679a1326/" rel="bookmark">
			php &#34; &#34;,0,&#39;0&#39;,false ==判断
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天项目中遇到的一个问题，举个栗子：
if（$_GET['is_has_idcard']==0 || $_GET['is_has_idcard']==1）{
echo '这次我要上传身份证';
}
if（$_GET['marry_mes']!=''){
echo '这次我要上传婚姻信息';
}
这样的判断，当没有传值is_has_idcard的时候，也会echo 这次我要上传身份证。就这个判断写法在我们的流程中成了个bug ,百度学一下，基础还是得打啊。。。
===========================================================================================================
下列哪一个是假：
A、0=="0";
B ""== "0"
C “”==0
D false=="0"
请解释下PHP在这些情况下以哪种类型比较的标准是什么?
答案：
A,真
B,假
C,真
D,真
PHP是一种弱类型语言,字符串,数,布尔,有时它自作聪明地帮你转化,这种转化有时带来方便,有时带来恼火.A:字符数字与数可以互相转化,这个大家都知道,B：空字符串与0字符串当然不一样.C：空就是0,D:0字符可以认为是假的.
如上就产生了一个问题：因为""==0, 0=="0" ,所以,""=="0",就是B了,而B是假的,MD,纠结了.
这里因为PHP只作了两两转换,所以上面推理虽然是那么纠结.但事实上“”不能直接转化为“0”的.
对于D这条,你说得有道理,我也觉得0也是有字符啊, 但是“0”可转化为0,0是假呀.感觉没道理可说,所谓道理就是人家规定的.实际写时多测试吧.
==============================================================================================================
转载于:https://www.cnblogs.com/gyrgyr/p/11571904.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a20c65786f294f6ef7e4fceaf9eb665/" rel="bookmark">
			学生信息管理系统2.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# 学生管理系统
import os
#同一个类可以生成无数个对象，这些对象来源于同一个类的属性和方法，当一个对象的方法进行调用的时候，
#对象会将自身作为第一个参数传递到self,接收到这个参数，python就知道是那一个对象调用方法了
#定义学生类
#类写完之后就变成了对象
class Student:
#__init__(self) 构造方法：只要实例化一个对象的时候，就会在对象被创建中调用，这些参数会自动的传递到init方法中。
def __init__(self,id,name,age,score):
self.id = id self.name = name
self.age = age self.score = score
def __str__(self): #如果要把一个类的实例变成 str，就需要实现特殊方法__str__() #msg = "{'id':" + "'"+self.id +"'"+ ",'name':" + "'" +self.name + "'" + ",'age':" + "'" + self.age+"'}"
msg = "学生信息：id=" + self.id + ",name=" + self.name + ",age=" + self.age + ",score=" + self.score
return msg
# array 是数组,可以存放一组相同类型的数字。这里都存放对应的字符串类型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a20c65786f294f6ef7e4fceaf9eb665/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e15ee7daedd3b2517003dc2130e6f00/" rel="bookmark">
			工作经常需要用到的git命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工作经常需要用到的git命令 我们开发人员比较多，需要保持develop分支上时直线提交，
拉取代码 git remote update -----检查远程是否有更新，一般会打印出远程更新的记录
git rebase origin/develop/或其他分支 —拉取主分支上最新的代码到本地
git rebase --continue ----- 到遇到冲突时，解决冲突，再执行该命令，再有冲突，再解决
git log --oneline ----- 可查看log日志，可以确定本地的代码是否已经和更新的分支同步
git pull — 将最新的代码pull 下来
git reset --hard origin/develop ---- 重置当前分支（本地）
提交代码 git stash — 暂存更改，当你还不想提交时，
git stash --list — 查看暂存更改的列表
git stash pop ---- 当然就是弹出你刚暂存的文件
git add . ---- 提交的时候用，提交到本地
git push origin 自己的分支名 ----提交到自己的远程分支，方便大佬check 合并你的代码
git push origin 自己的分支名 -f -----强制提交，当你本地落后于远程时会没办法提交，要么更新本地，不然也可以强制提交
分支操作 git branch — 检查现在处于哪个分支上
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e15ee7daedd3b2517003dc2130e6f00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d97082bcc8791cbbe39e2acc1074ae2/" rel="bookmark">
			标签传播算法及其改进方案（科研记录）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标签传播算法 注：本文只是对自己设计的算法的一个简单记录。
算法步骤 初始时，给每个节点一个唯一的标签；每个节点使用其邻居节点的标签中最多的标签来更新自身的标签。反复执行步骤2，直到每个节点的标签都不再发生变化为止。
一次迭代过程中一个节点标签的更新可以分为同步和异步两种。所谓同步更新，即节点z在第t次迭代的label依据于它的邻居节点在第t-1次迭代时所得的label；异步更新，即节点z在第t次迭代的label依据于第t次迭代已经更新过label的节点和第t次迭代未更新过label的节点在第t-1次迭代时的label。 改进方案 标签传播算法的时间复杂度很低，非常适合大型网络的社区划分，但是也存在很多缺点：
划分结果不稳定，随机性强；准确度不高。 具体体现在： 更新顺序：节点标签更新顺序随机，但是很明显，越重要的节点越早更新会加速收敛过程；随机选择：如果一个节点的出现次数最大的邻居标签不止一个时，随机选择一个标签作为自己标签。这种随机性可能会带来一个雪崩效应，即刚开始一个小小的聚类错误会不断被放大。 改进思路： 确定节点的更新顺序 : LeaderRank，PageRank，HITS，参与系数，k-核/k-壳，等等及其改进算法；
降低随机选择的概率 : 各种相似度度量/距离度量以及他们的随机结合。
目前算法： k为社区数量，ARI为调整兰德系数，NMI为网络选择标准互信息，Q为模块性指标，δ为算法稳定系数，Time为运行时间，环境为python2.7（黑体 为与 FMM，LPA ，BGLL ，LPAm， LPAm+， infomap， ISCD+， LPA-S这些算法的比较。 ）
karate:k=2 ,ARI=1.0000,NMI=1.0000,Q=0.3715,δ=0,Time=8;
dolphin:k=4 ,ARI=0.4325,NMI=0.6241,Q=0.5203,δ=0,Time=20;
football:k=12 ,ARI=0.8896,NMI=0.9268,Q=0.6010,δ=0,Time=66;
polkbooks:k=4 ,ARI=0.6664,NMI=0.5534,Q=0.5140,δ=0,Time=59;斜体样式
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db484a3cf8073ff42c92b4121f26ba87/" rel="bookmark">
			学生信息管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# 学生管理系统
import os
#定义学生类
class Student:
def __init__(self,id,name,age,score):
self.id = id
self.name = name
self.age = age
self.score = score
def __str__(self):
#msg = "{'id':" + "'"+self.id +"'"+ ",'name':" + "'" +self.name + "'" + ",'age':" + "'" + self.age+"'}"
msg = "学生信息：id=" + self.id + ",name=" + self.name + ",age=" + self.age + ",score=" + self.score
return msg
#获取id
def getId(self):
return self.id
#获取name
def getName(self):
return self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db484a3cf8073ff42c92b4121f26ba87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c601d3b9f47b5c557d106bbc694f4a4/" rel="bookmark">
			tcp-full.cc
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ns2--tcp-full.cc
1 /* -*- Mode:C++; c-basic-offset:8; tab-width:8; indent-tabs-mode:t -*- */ 2 3 /* 4 * Copyright (c) Intel Corporation 2001. All rights reserved. 5 * 6 * Licensed under the Apache License, Version 2.0 (the "License"); 7 * you may not use this file except in compliance with the License. 8 * You may obtain a copy of the License at 9 * http://www.apache.org/licenses/LICENSE-2.0 10 * 11 * Unless required by applicable law or agreed to in writing, software 12 * distributed under the License is distributed on an "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c601d3b9f47b5c557d106bbc694f4a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddb90db3c9a83a395cba101872a73dc3/" rel="bookmark">
			LogStash安装及综合案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 14、LogStash介绍及安装1、介绍2 、node01机器安装LogStash3、Input插件1、stdin标准输入和stdout标准输出2、监控日志文件变化 3、jdbc插件第一步：编写脚本第二步：上传mysql连接驱动包到指定路劲第三步：检查配置文件是否可用第四步：启动服务第五步：数据库当中添加数据 4 systlog插件4、filter插件1、grok正则表达式1、收集控制台输入数据，采集日期时间出来2、使用grok收集nginx日志数据第一步：安装grok插件第二步：开发logstash的配置文件第三步：启动logstash第四步：从控制台输入nginx日志文件数据 5、 Output插件1 标准输出到控制台2 将采集数据保存到file文件中第一步：开发logstash的配置文件第二步：检测配置文件并启动logstash服务 3 将采集数据保存到elasticsearch第一步：开发logstash的配置文件第二步：检测配置文件并启动logstash第三步：es当中查看数据 16、logStash+ES综合案例1、采集服务器运行产生的日志1.1、rsyslog的基本介绍1.2、修改rsyslog的配置文件1.3、重启linux服务器的rsyslog服务1.4、开发logstash的配置文件，收集rsyslog日志1.5、启动logstash服务 2、采集服务器用户操作所有历史日志第一步：定义日志格式第二步：开发logstash的配置文件第三步：启动logstash 3、采集nginx日志到es当中第一步：上传日志文件第二步：开发logstash的配置文件第三步：启动logstash并查看es当中的数据 14、LogStash介绍及安装 官网：
https://www.elastic.co/guide/en/logstash/current/index.html
1、介绍 logstash就是一个具备实时数据传输能力的管道，负责将数据信息从管道的输入端传输到管道的输出端；与此同时这根管道还可以让你根据自己的需求在中间加上滤网，Logstash提供里很多功能强大的滤网以满足你的各种应用场景。是一个input | filter | output 的数据流。
2 、node01机器安装LogStash 下载logstache并上传到第一台服务器的/home/es路径下，然后进行解压
#下载安装包—可以直接将已经下载好的安装包上传到/home/es路径下即可
cd /home/es wget https://artifacts.elastic.co/downloads/logstash/logstash-6.7.0.tar.gz #解压 tar -zxf logstash-6.7.0.tar.gz -C /export/servers/es/ 3、Input插件 1、stdin标准输入和stdout标准输出 使用标准的输入与输出组件，实现将我们的数据从控制台输入，从控制台输出
cd /export/servers/es/logstash-6.7.0/ bin/logstash -e 'input{stdin{}}output{stdout{codec=&gt;rubydebug}}' { "@version" =&gt; "1", "host" =&gt; "node01", "@timestamp" =&gt; 2018-10-13T08:33:13.126Z, "message" =&gt; "hello" } 2、监控日志文件变化 Logstash 使用一个名叫 FileWatch 的 Ruby Gem 库来监听文件变化。这个库支持 glob 展开文件路径，而且会记录一个叫 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ddb90db3c9a83a395cba101872a73dc3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96f04c85369ee227475f7516c3a2332f/" rel="bookmark">
			解决 Navicat 无法导入带外键的json 亲测有效！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 进入mysql数据库，设置全局外键检查忽略
临时的解决办法是：
set @@global.foreign_key_checks = 0; 在导入完毕后
set @@global.foreign_key_checks = 1; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/deeca65fd0b5a11ea2d86d2275ddeaeb/" rel="bookmark">
			LeetCode 841：钥匙和房间 Keys and Rooms
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目： ​ 有 N 个房间，开始时你位于 0 号房间。每个房间有不同的号码：0，1，2，...，N-1，并且房间里可能有一些钥匙能使你进入下一个房间。
​ 在形式上，对于每个房间 i 都有一个钥匙列表 rooms[i]，每个钥匙 rooms[i][j] 由 [0,1，...，N-1] 中的一个整数表示，其中 N = rooms.length。 钥匙 rooms[i][j] = v 可以打开编号为 v 的房间。
最初，除 0 号房间外的其余所有房间都被锁住。
你可以自由地在房间之间来回走动。
如果能进入每个房间返回 true，否则返回 false。
​ There are N rooms and you start in room 0. Each room has a distinct number in 0, 1, 2, ..., N-1, and each room may have some keys to access the next room.
​ Formally, each room i has a list of keys rooms[i], and each key rooms[i][j] is an integer in [0, 1, .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/deeca65fd0b5a11ea2d86d2275ddeaeb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/071f08ad34de13a1929fc1fe91ce17cd/" rel="bookmark">
			Mysql创建数据库和指定权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.登录Mysql
若环境变量配置了mysql，则直接通过命令窗口执行即可；若没有配置环境变量，则需要进入到指定的mysql路径下（/mysql/bin/）
例：mysql -uroot -padmin
说明 -u 代表是用户(user) root 为登陆用户 -p代表密码（password） admin代表为登陆密码
2.创建用户
创建用户名为 user_test1 的用户，设置密码为 user_test1&amp;psw
例：CREATE USER ‘user_test1’ IDENTIFIED BY ‘user_test1&amp;psw’;
ant all privileges on student.* to test3@localhost identified by ’123456′;
3.创建数据库
在 root 用户下创建数据库 test_data1 设置编码格式 （注：Mysql的版本不同编码格式会有所不同）
例：CREATE DATABASE test_data1 DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;
4.为创建用户授权
为新增用户授予增删改查等权限，具体看需要授权哪些就授权哪些即可，如下：
grant create,select,insert,update,delete,drop,alter on test_data1.* to user_test1@”%” identified by “user_test1&amp;psw”;
删除fypay用户*
例1：delete from user where user=”user_test1”
例2：drop user user_test1@localhost
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/071f08ad34de13a1929fc1fe91ce17cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5c8d24d0f39c69425de0c2950026a88/" rel="bookmark">
			初识Hadoop
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大数据特点 4V：volume variety velocity value
海量性（volume）：大数据的数据量很大，每天我们的行为都会产生大批量数据
多样性（variety）：大数据的类型多种多样，比如视频、音频和图片都属于数据
高速性（velocity）：大数据要求处理速度快，比如淘宝双十一需要实时显示交易数据
价值性（value）：大数据产生的价值密度低，意思是说大部分数据没有参考意义，少部分数据会形成高价值
Hadoop简介与意义 Apache开源软件基金会开发了运行在大规模普通服务器上，用于大数据存储、计算、分析的分布式存储系统和分布式计算框架--Hadoop。其两大核心如下：
HDFS（Hadoop Distributed File System，分布式文件系统）：是Hadoop中的核心组件之一，除了可以保存海量数据，还具有高可靠性、高扩展性和高吞吐率的特点。MapReduce：属于分布式计算框架，一般用于对海量数据的计算，它的特点是易于编程、高容错和高扩展性等优点。另外，MapReduce可以独立于HDFS使用。 总结来说，hadoop中的核心HDFS为海量数据提供了存储，而MapReduce则为海量数据提供了计算服务。
大数据计算模式 大数据计算模式：
批处理计算：又称为离线计算，针对大规模历史数据的批量处理，如MapReduce 流计算：针对流数据的实时计算，可以实时处理产生的数据。 图计算：针对大规模图结构数据的处理，常用于社交网络 查询分析计算：针对大规模数据的存储管理和查询分析，如Hive 大数据技术框架 大数据技术框架主要包含6个部分，分别是：
数据收集、数据存储、资源管理、计算框架、数据分析、数据展示
每部分包括的具体技术：
数据源（如企业数据、互联网、物联网等）数据收集（提取、转换、加载）---数据收集数据存储（关系型和非关系型数据）---数据存储资源管理 ---资源管理流处理、交互式分析、资源管理 ---计算框架数据挖掘（OLAP，数据仓库和商务智能）---数据分析数据可视化 ----数据展示用户 核心组件 Hadoop的分布式协调服务--ZooKeeper分布式离线计算框架--MapReduceHadoop的集群资源管理系统--YARNHadoop的数据仓库框架--Hive大数据快速读写--HBase海量日志采集工具--FlumeHadoop和关系型数据库间的数据传输工具--Sqoop分布式消息队列--Kafka开源内存数据库--Redis快速且通用的集群计算系统--Spark 转载于:https://www.cnblogs.com/sunbr/p/11562584.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7faa8c8b1a736b5cc4152968b4cd281e/" rel="bookmark">
			Unknown float option `H&#39;. \begin{table}[H]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 LaTeX的表格在设置浮动时提示了如题所示错误，首先能肯定没写错，那么显然是少导了包。因此导入一个名为float的宏包即可。
在文档导言内加上如下代码即可：
\usepackage{float} 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa4b985d38eb2682153cb108fe4c8ba7/" rel="bookmark">
			ajax 更新 Echarts
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 ajaxEcharts ajax 干货警告！在ajax回调函数里设置更新的那部分配置即可
$.ajax({ url: "http://www.example.com", type: "POST", success: function (data) { myChart.setOption({ series: [{ axisLine: { lineStyle: { width: 3, color: [ [0.8, '#ff802c'], ] } }, data: [{ value: 80 }] }] }); } }); Echarts // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById('main')); // Echarts 指定图表的配置项和数据 option = { backgroundColor: '', grid: { top: 10, }, series: [{ type: 'gauge', startAngle: 180, endAngle: 0, radius: '100%', center: ['50%', '80%'], z: -9, axisTick: { show: false, }, splitLine: { show: false, }, axisLabel: { show: false, }, detail: { //文字的高度 offsetCenter: [0, -40], textStyle: { fontSize: 30, fontWeight: '700', color: '#ff802c' }, formatter: function (value) { return value; }, }, pointer: { show: false }, min: 0, max: 100, // --------- 比如说我只想更新这一块代码 --------- 开始 --------- axisLine: { lineStyle: { width: 3, color: [ [0, '#ff802c'], ] } }, data: [{ value: 0 }] // --------- 比如说我只想更新这一块代码 --------- 结束 --------- }, { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa4b985d38eb2682153cb108fe4c8ba7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29c8b035777098303a997927e15ab769/" rel="bookmark">
			python - try-except 语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		异常可以通过 try 语句来检测. 任何在 try 语句块里的代码都会被监测, 检查有无异常发生。
try 语句有两种主要形式: try-except 和 try-finally . 这两个语句是互斥的, 也就是说你只能使用其中的一种 . 一个 try 语句可以对应一个或多个 except 子句 , 但只能对应一个finally 子句, 或是一个 try-except-finally 复合语句.
1、try-except 语句
首先尝试执行 try 子句, 如果没有错误, 忽略所有的 except 从句继续执行，如果发生异常, 解释器将在这一串处理器(except 子句)中查找匹配的异常。
a = 10 try: abc print('尝试输出') except: print('若错误转到此处') print('继续执行') print('a =',a) &gt;&gt;&gt; 若错误转到此处 继续执行 a = 10 只捕获特定的异常，其他的异常不予捕获：
2、带有多个 except 的 try 语句
可以把多个 except 语句连接在一起, 处理一个 try 块中可能发生的多种异常, 如下所示:：
首先尝试执行 try 子句, 如果没有错误, 忽略所有的 except 从句继续执行.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29c8b035777098303a997927e15ab769/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edac2085817ad13d32ae4ef97f4080ae/" rel="bookmark">
			Spring阶段性学习总结（六）Bean的生命周期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 package SpringBeansCycle; 2 3 public class Car { 4 private String brand; 5 6 public Car() { 7 System.out.println("我是一个构造器"); 8 } 9 10 public void init() { 11 System.out.println("this is a init!"); 12 } 13 14 public void destory() { 15 System.out.println("this is a destory!"); 16 } 17 18 public String getBrand() { 19 return brand; 20 } 21 22 public void setBrand(String brand) { 23 this.brand = brand; 24 } 25 26 } 1 package SpringBeansCycle; 2 3 import org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edac2085817ad13d32ae4ef97f4080ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d4f9d817cf4db330231fae859cd71b0/" rel="bookmark">
			小程序 分包问题 主包体积超过限制2MB
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解决思路：将主包里造成体积过大的包，放在分包里，因为分包加起来可以有8MB
我是因为需要用到折线图，使用了echarts，造成主包体积过大，而ec-canvas这个包并不是需要全局使用，所以可以将ec-canvas包放进分包里。
小程序打包时会将除了subPackages外的所有文件放进主包，官方文档看这里
具体操作：
1.移动文件夹，将ec-canvas包放进会使用到的分包里
2.修改app.json文件内容，在分包“subPackages”里添加ec-canvas路径
代码：
{ "pages": [ "pages/index/index", ], "subPackages": [ { "root": "pages/test/", "pages": [ "ec-canvas/ec-canvas" ] }, ], "sitemapLocation": "sitemap.json" } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19cc94a7abee9e4931b2a1888906d56a/" rel="bookmark">
			file文件方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python3 File(文件) 方法 open() 方法 Python open() 方法用于打开一个文件，并返回文件对象，在对文件进行处理过程都需要使用到这个函数，如果该文件无法被打开，会抛出 OSError。
注意：使用 open() 方法一定要保证关闭文件对象，即调用 close() 方法。
open() 函数常用形式是接收两个参数：文件名(file)和模式(mode)。
open(file, mode='r') 完整的语法格式为：
open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None) 参数说明:
file: 必需，文件路径（相对或者绝对路径）。mode: 可选，文件打开模式buffering: 设置缓冲encoding: 一般使用utf8errors: 报错级别newline: 区分换行符closefd: 传入的file参数类型opener: mode 参数有：
模式描述t文本模式 (默认)。x写模式，新建一个文件，如果该文件已存在则会报错。b二进制模式。+打开一个文件进行更新(可读可写)。U通用换行模式（Python 3 不支持）。r以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。rb以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。r+打开一个文件用于读写。文件指针将会放在文件的开头。rb+以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。w打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。wb以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。w+打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。wb+以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。a打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。ab以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。a+打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。ab+以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 默认为文本模式，如果要以二进制模式打开，加上 b 。
file 对象 file 对象使用 open 函数来创建，下表列出了 file 对象常用的函数：
序号方法及描述1 file.close()
关闭文件。关闭后文件不能再进行读写操作。
2 file.flush()
刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。
3 file.fileno()
返回一个整型的文件描述符(file descriptor FD 整型), 可以用在如os模块的read方法等一些底层操作上。
4 file.isatty()
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19cc94a7abee9e4931b2a1888906d56a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0171735a5bc3bf289a907e6382d02a9/" rel="bookmark">
			快速排序的原理和实现（纯白话文口述）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		快速排序的形象例子：
一队人组成两排拍集体照，拍摄者发现有些前排队员身高太高挡住了后排队员，于是想弄一个法子来确保后排所站队员的身高不低于前排队员。第一次想到的是先将所有队员从低到高进行排序，然后将排好的序列从某个地方折断成两个部分，前一部分的作为前排，后一部分的作为后排。但这种方式效率太低了太耗时了，因为它不但确定了某个队员是属于前排还是后排，而且还确定了该队员在该所属排中的具体位置，即做了许多无用的操作，所以太慢了。接着想到的是将所有队员以其中某个队员的身高为参考基准，身高高于他的队员站后排，身高低于他的队员站前排。对身高等于他的队员不做要求，即原来属于前排就仍然在前排，原来属于后排就仍然在后排（为什么身高等于的不做要求，因为这样有个好处，如果所有队员身高都等于该队员，那么就不需要做任何调整了）。由于没有进一步要求每排队员相互之间的身高顺序（譬如左边的队员身高不能比右边的队员低），所以从整体上来看，这可以看作是一次为了操作方便（即节省时间、速度快）而进行的粗略排序，这个粗略排序只有一个简单的规则，即后排身高不能低于前排（如果进一步要求同排左方队员不能低于右方队员，显然这就会增加操作的复杂度，导致所需时间增加，即速度变慢）。这种粗略的排序因为操作方便，实施起来速度快，所以又叫快速排序。
快速排序的两种基本思想：
思想一：通过一趟排序将数组分割成两部分，其中一部分的任意一数据都大于或等于另一部分的任意一数据，这样的一次排序称作为一次快速排序。然后再用同样的方法分别对被分割而成的两部分数组进行快速排序，一直递归下去，直到分割所得到的部分包含的数据个数不大于一为止。
这种思想的内在原理是，当把一个数组分成两个部分时，虽然各部分中的元素仍然是处于无序状态，但是此时元素所在位置与最终数组完全排好序后该元素所处的位置的相离的更近一些了。随着快速排序的一次次递归下去，元素所处的位置与最终排好序所处的位置离的越来越近，直至元素位置最终等于数组完全排好序时该元素所处的位置，整个数组排序完成。
也就是说，一开始数组元素位置的可变动范围很大，随着快速排序的递归执行，元素的可变动范围越来越小，直至元素的位置最终被完全确定，排序结束。
思想二：通过一趟排序将数组分割成两部分另加一个基准元素，其中一部分的任意一数据都大于或等于基准元素值，另一部分的任意一数据都小于或等于基准元素值，将这样的一次排序也称作为一次快速排序。然后再用同样的方法分别对被分割而成的两部分数组进行快速排序，一直递归下去，直到分割所得到的部分包含的数据个数不大于一为止。
这种思想的内在原理是，每一次快速排序，都会使得选出来的基准元素被放在一个正确的位置，这个位置与整个数组完全排好序后的位置是一致的（都是左边的元素小于或等于它，右边的元素大于或等于它）。随着快速排序的递归进行，越来越多的基准元素被放在了正确的位置，知道所有的元素都被用作基准元素放在了正确位置，排序结束。
快速排序实现的要点： 要点在于如何将一个数组拆分成两个满足快速排序规则的子数组，即一个子数组中的所有元素都大于或等于另一个子数组中的元素，这其中容易存在两种错误的直觉，或者说是两种错误的潜意识。下面分别介绍下这两种错觉以及应该形成一个怎样的正确的直觉：
1. 错误直觉之俩子数组长度相等：很容易产生一种错觉，认为对数组进行一趟快速排序后，将会产生两个长度相等（或长度大小相差不超过一）的子数组。而因为有这种错觉，甚至使人在实现快速排序算法的时候，直接先把数组分为两个部分，然后将数值大于某参考元素值的元素放于其中一个部分，其它的元素放入另一个部分（这是错误的，因为实际一趟快速排序很可能会将数组分割成两个不同长度的数组，所分出来的俩数组长度决定于快速排序时所选择的参考元素的值的大小）。
2. 错误直觉之参考元素位置决定俩子数组分界线：另一个容易产生的错觉是，既然我们选择了一个参考元素，那么将各元素与参考元素相比较，较小的元素放参考元素左边，较大的元素放参考元素右边，结束后将数组分为以参考元素位置为分界线的两个数组（这也是错误的，原因同上，也就是有可能参考元素的左边没有多余的位置盛放需要挪到左边的元素，而挪到右边的元素太少，根本没有占满右边数组的空位）。
正确直觉的建立：那么怎么来确定两个子数组的分界点呢？可以假想从数组的两端各有一个盛放小于等于和大于等于参考值元素的子数组（将一次快排所操作的数组视为母数组，若参考元素为母数组的第一个元素，则左子数组的始地址为母数组左端的第二个元素的地址），并且两子数组以逐渐向对方增长的方式来最终得到一个分割点。即可以在母数组的左端遍历，将符合“小于等于参考值”规则的元素统计为左子数组的一部分，直到找到第一个大于参考值的元素，然后在母数组的右端反向遍历，将符合“大于等于参考值”规则的元素统计为右子数组的一部分，直到找到第一个小于参考值的元素，此时两个子数组因为遇到了违反规则的元素，所以两个数组停止增长。这时如果俩数组还没有相遇或相交，则将两个元素彼此交换，交换后两个子数组又可以继续进行相向增长，直到两子数组停止增长时（遇到不符合与参考元素大小关系的元素或遇到了母数组的边界）发现两个子数组已经相接或重叠时为止（重叠是因为含有等于参考元素值的元素，这些元素可以属于两个子数组中的任何一个数组），此时再将参考元素与右子子数组起始地址的前一个元素进行交换（该元素可能是左子数组中最后一个不属于右子树的元素，也可能是参考元素自身。也就是说，参考元素不能与右子数组中的下标最小的元素进行交换，因为这个元素可能大于参考元素。由于最初参考元素选择的是母数组的第一个元素，元素位置应处于左子数组，所以参考元素不能与右子数组的元素交换，否则交换后，左子数组中的元素可能会违反与参考元素的大小规则。交换后，左子数组从母数组第一个元素开始，到交换后的参考元素的前一元素为止），交换后，参考元素的位置就是俩数组的分割点，并且也是整个母数组有序化后参考元素应该在的位置。由于参考元素已经放在了应该放的位置，所以参考元素不必参与后续的左右子数组快排过程。
不存在的零长子数组问题：
利用快速排序思想进行排序时，思考的深一些的时候还会有另一种错觉，其实它是不存在的，下面来介绍一下：
错误直觉之零长子数组导致无穷递归：有时候会忽然想到“将母数组分为俩子数组时，会不会出现其中一子数组的长度为零，另一子数组的长度为整个母数组的长度”，即导致实际一趟快排并没有将一个数组分为两个数组的效果，从而出现无穷次数的递归调用快速排序呢。
解答：会出现分成的两个数组一个长度为零，另一个为母数组长度减一的情况。但这并不会出问题，因为参考元素是不参与下一次快速排序的。一次快速排序完毕后，参考元素总能放到它应该在的位置，并且不再参与下一次俩子数组的快速排序。所以俩子数组即使有一个长度为零，但另一个子数组的长度还是要比原母数组长度小（少一个元素即参考元素）。所以快速排序的递归调用不会无穷次数的进行下去。
快速排序代码（C++版）（使用思想二实现）：
#include &lt;iostream&gt; using namespace std; void Qsort(int arr[], int low, int high){ if (high &lt;= low) return; int i = low; int j = high + 1; /* 参考值取参与快速排序的第一个元素 */ int key = arr[low]; while (true) { /*从左向右找比key大的值, 实际是找左子数组向右生长的停止元素*/ while (arr[++i] &lt;= key) //++i：即快速排序从参考元素的下一位置元素开始 { if (i == high){ break; } } /*从右向左找比key小的值，实际上是找右子数组向左生长的停止元素*/ while (arr[--j] &gt;= key) { if (j == low){ break; } } /* 俩子数组相接或交叉，则一段快速排序完成 */ if (i &gt;= j) break; /*交换i,j对应的值，实际是交换左右俩子数组的停止元素，使得俩数组可以继续生长*/ int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } /*参考值与j对应值交换*/ int temp = arr[low]; arr[low] = arr[j]; arr[j] = temp; /* 参考元素（元素下标为j）不再参与下一次快排 */ Qsort(arr, low, j - 1); Qsort(arr, j + 1, high); } int main() { int a[] = {57, 68, 59, 52, 72, 28, 96, 33, 24}; Qsort(a, 0, sizeof(a) / sizeof(a[0]) - 1);/*这里原文第三个参数要减1否则内存越界*/ for(int i = 0; i &lt; sizeof(a) / sizeof(a[0]); i++) { cout &lt;&lt; a[i] &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0171735a5bc3bf289a907e6382d02a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98d49ecf046f09c78e9ad5184e343ea6/" rel="bookmark">
			C语言之补漏（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 typedef 1.define与typedef区别？
相比起宏定义的直接替换，typedef是对类型的封装（通俗说就是对类型起一个别名）
2.typedef可以给多个别名 typedef int tint,*tint; 3.复杂数据类型 int (*p)[3]; typedef int (*ptr_to_array)[3]; int (*fun)(void); typedef int (*ptr_to_fun)(void); 4.与结构体结合 typedef struct Node { int date； struct Node *next; }Node,*List; 共用体或联合体 1.共用体的所有成员共享同一个内存地址
2.使用时赋值，不能在一起赋值后再用
3.长度：
4.定义变量与结构体相同
5.union可以没有名字
union 共用体名称 { 共用体1； 共用体2； 共用体3； ... } 枚举
枚举的值在编译时确定，中间代码不可改变。位域
位域是指信息在存储时，并不需要占用一个完整的字节， 而只需占几个或一个二进制位。例如在存放一个开关量时，只有0和1 两种状态， 用一位二进位即可。为了节省存储空间，并使处理简便，C语言又提供了一种数据结构，称为“位域”或“位段”。所谓“位域”是把一个字节中的二进位划分为几 个不同的区域， 并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。 这样就可以把几个不同的对象用一个字节的二进制位域来表示。 unsigned int,int,char,unsigned char,支持位域 struct Test { unsigned int a:1; unsigned int b:1; unsigned int c:2; };	struct Test test; a占1个bit，b占1个bit，c占2个bit。sizeof(test)为4个字节，因为存在位对齐（int） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22e63e88e9534dc18c620762b4263e79/" rel="bookmark">
			Python多线程、多进程和协程的实例讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线程、进程和协程是什么 线程、进程和协程的详细概念解释和原理剖析不是本文的重点，本文重点讲述在Python中怎样实际使用这三种东西
参考： 进程、线程、协程之概念理解 **进程（Process）**是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。
线程，有时被称为轻量级进程(Lightweight Process，LWP），是程序执行流的最小单元。
**协程：**一个程序可以包含多个协程，可以对比于一个进程包含多个线程，因而下面我们来比较协程和线程：我们知道多个线程相对独立，有自己的上下文，切换受系统控制；而协程也相对独立，有自己的上下文，但是其切换由自己控制，由当前协程切换到其他协程由当前协程来控制。
如果你依然在编程的世界里迷茫，可以加入我们的Python学习扣qun：784758214，看看前辈们是如何学习的。从基础的python脚本到web开发、爬虫、django、数据挖掘等，0基础到项目实战的资料都有整理。送给每一位python的小伙伴！每天分享学习方法和趣味实战教程，技术经验！点击加入我们的 python学习者聚集地
准备工作 磨刀不误砍柴工，在用实例讲解线程、进程和协程怎么使用之前，先准备一些工具：
实际上多线程、多进程和协程，都属于并发编程，并发编程的最重要的目标就是提高程序运行的效率，那么我们需要一个计算一个函数耗时长度的工具，用于对比不同方式程序的运行时间，这里我们写一个函数计时装饰器fn_timer来完成这件事：
def fn_timer(function): ''' 函数计时装饰器 :param function: 函数对象 :return: 装饰器 ''' @wraps(function) def function_timer(*args,**kwargs): # 起始时间 t0 = time.time() # 调用函数 result = function(*args,**kwargs) # 结束时间 t1 = time.time() # 打印函数耗时 print '[finished function:{func_name} in {time:.2f}s]'.format(func_name = function.__name__,time = t1 - t0) return result return function_timer 该装饰器的用法示例：
# 测试 @fn_timer def add(x,y): time.sleep(1.22) return x + y if __name__ == '__main__': # 测试 sum = add(1,2) print sum 运行代码输出：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22e63e88e9534dc18c620762b4263e79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5b35b1baedc49153e83566f87d67237/" rel="bookmark">
			面试刷题9-19
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		招银科技
一面：
自我介绍
1.递归
2.网络编程：服务器与客户端 Linux C网络编程部分
3.TCP三次握手
客户端发送连接请求给服务器，服务器收到回复确认，客户端再次收到再次回复一个报文建立连接。
为什么要三次握手？
假如因为网络拥塞，第一次发出的连接请求超时，又重新发了一个，那么两次握手就会建立起多余的连接。
4.链表 环的检测
5.使用栈排序
6.mysql 排序 取前100个
tp-link
一面：
1.自我介绍
2.项目相关
3.抽象类和接口
4.重载与重写
5.快速排序
可能还有一些记不清了。
今天下着雨，人不多。十点面试，面试官好像还没睡醒，表情淡漠。今天只是一面，hr说二面后续有的话再通知。（今天只有一面，我在楼下等着的时候有人问hr的）
一加手机：
这个投很久了没消息，之前看别人说过了笔试才发笔试通知，我以为就此凉了，前天突然收到让去面试的通知。
1.自我介绍
2.项目 3.研究方向
4.计算机网络
5.spring框架
6.mysql 锁 7.英语口语
一面：
自我介绍
一些项目的问题 主要讲解自己在项目中的角色 问了我几个功能怎么实现的。
hashmap和concurrenthashmap的区别，实现原理。
前者非线程完全，后者线程完全。
==和equals的区别，给了几个例子问结果。
分基本类型和引用类型回答
arraylist的remove方法。
数组中删除元素
mysql索引，数据结构。
B+树
jvm内存结构，gc。
jmm，底层如何实现volatile。
多线程一些相关问题。
redis如何实现高并发。
暂时只想到这些，面了大概40多分钟。
二面：
二面简直打击人…很多时候都一问三不知
项目，和一面差别不大。
问你本科和硕士期间的课程之类的。
我本硕都是软工，还问了点c++的问题……佛了
数据库，面试官提条件，手写sql，涉及到模糊查询，分组，连接。
计算机网络，分层，https实现。
操作系统，这个真不会…基本忘记了。
java基础，只记得一个问题就是float类型如何存放的，二面的基础问题太基础了，导致我实在是不知道如何下手…给我的感觉就是看了太多深度的东西，反而对这种特别基础的问题疏忽了。
给了我一个代码，让我优化，涉及到向下转型之类的。
面向对象思想的理解。
HR面：
自我介绍，聊项目中学到了什么。
聊人生。
社团经历。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5b35b1baedc49153e83566f87d67237/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66f6f79f4e16791caf26c7e494c26a05/" rel="bookmark">
			FeignClient注解及参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、FeignClient注解
FeignClient注解被@Target(ElementType.TYPE)修饰，表示FeignClient注解的作用目标在接口上
@FeignClient(name = "github-client", url = "https://api.github.com", configuration = GitHubExampleConfig.class) public interface GitHubClient { @RequestMapping(value = "/search/repositories", method = RequestMethod.GET) String searchRepo(@RequestParam("q") String queryStr); } 声明接口之后，在代码中通过@Resource注入之后即可使用。@FeignClient标签的常用属性如下：
name：指定FeignClient的名称，如果项目使用了Ribbon，name属性会作为微服务的名称，用于服务发现url: url一般用于调试，可以手动指定@FeignClient调用的地址decode404:当发生http 404错误时，如果该字段位true，会调用decoder进行解码，否则抛出FeignExceptionconfiguration: Feign配置类，可以自定义Feign的Encoder、Decoder、LogLevel、Contractfallback: 定义容错的处理类，当调用远程接口失败或超时时，会调用对应接口的容错逻辑，fallback指定的类必须实现@FeignClient标记的接口fallbackFactory: 工厂类，用于生成fallback类示例，通过这个属性我们可以实现每个接口通用的容错逻辑，减少重复的代码path: 定义当前FeignClient的统一前缀 @FeignClient(name = "github-client", url = "https://api.github.com", configuration = GitHubExampleConfig.class, fallback = GitHubClient.DefaultFallback.class) public interface GitHubClient { @RequestMapping(value = "/search/repositories", method = RequestMethod.GET) String searchRepo(@RequestParam("q") String queryStr); /** * 容错处理类，当调用失败时，简单返回空字符串 */ @Component public class DefaultFallback implements GitHubClient { @Override public String searchRepo(@RequestParam("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66f6f79f4e16791caf26c7e494c26a05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0d072f7f1762a04833d647acf350daa/" rel="bookmark">
			uniapp属性插值报错Interpolation inside attributes has been removed. Use v-bind or the colon shorthand inst...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决方法：
因为vue 2.x不支持对属性使用插值{{}}的方式赋值，所以要使用v-bind指令（或简写“:”）来指定属性。
v-bind指令 v-bind:id="item.id"
v-bind简写指令: :id="item.id" 转载于:https://www.cnblogs.com/XiaoYEBLog/p/11546343.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b53f66f4151c1b76974f4508b316386/" rel="bookmark">
			ASP.NET开发实战——（六）ASP.NET MVC &amp; 分层 代码篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇文章对如何规范使用ASP.NET进行了介绍，本章内容将根据上一篇得出的结论来修改博客应用的代码。
代码分层 综合考虑将博客应用代码分为以下几个层次：
○ 模型：代表应用程序中的数据模型，与数据库表结构对应。同时也作为MVC与逻辑层之间的数据交换对象(后续会使用DTO代替)。
○ 仓储：用于管理数据增、删、查、改。
○ 逻辑：用于处理业务逻辑，一般来说是根据应用层提供的数据来驱动业务执行，业务逻辑会使用仓储来对数据持久化。
○ 应用：也就是MVC应用，它为用户提供操作界面(UI)，然后调用逻辑来完成业务。
为模型、仓储和逻辑创建类库项目 1. 使用VS2017创建3个类库项目，分别是BlogBusinessLogic、BlogModel、BlogRepository：
它们之间的依赖关系如下：
2. 将My Blog的Post类转移到BlogModel中(复制的时候应注意命名空间)：
3. 创建Blog仓储(这里仍然使用静态列表来表示一个数据源)：
4. 创建BlogManager作为一个简单的业务逻辑管理者：
5. 在MVC中定义视图模型，用于显示：
文章详情模型：
文章列表模型：
6. 在Controller中使用BlogManager：
7. 修改页面，使用Model来渲染页面：
8. 运行结果，仍然和之前一致：
小结 本章仅仅是根据上一篇的分析对原有的MVC应用进行了拆分，拆分的目的是将关注点分离，便于代码的管理和维护。需要注意的是从拆分的代码中可以看到从MVC调用逻辑层的获取文章列表、信息方法与逻辑层调用仓储层的方法基本一致，并没有额外的逻辑加入，这是因为现在的业务逻辑相对简单，而并不是无用的。
欢迎添加个人微信号：Like若所思。
欢迎关注我的公众号，不仅为你推荐最新的博文，还有更多惊喜和资源在等着你!一起学习共同进步！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/241c550d632cc533f3e3ec53b541bffe/" rel="bookmark">
			交换两个变量的输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		交换两个变量的输出 题目： 输入两个整数num1和num2，交换两者的值，然后输出。
样例输入：
824 16
样例输出：
16 824
1.三变量交换法 #include &lt;stdio.h&gt; int main() { int num1, num2; scanf("%d %d", &amp;num1, &amp;num2); int temp = num1;//利用定义一个中间临时变量去储存。 num1 = num2; num2 = temp; printf("%d %d\n", num1, num2); return 0; } 2.利用加减法交换 #include &lt;stdio.h&gt; int main() { int num1, num2; scanf("%d %d", &amp;num1, &amp;num2); num1 = num1 + num2; num2 = num1 - num2; num1 = num1 - num2; printf("%d %d\n", num1, num2); return 0; } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/241c550d632cc533f3e3ec53b541bffe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06529ae0189962839cdbbf98abf5ab0a/" rel="bookmark">
			Python 编写一个函数，输出整数m的全部素数因子，如m= 120，输出2,2,2,3,5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 来自于教材上的一道课后题
def isprime(num): #判断因子是不是素数 flag = 1 for i in range(2,num): if num % i == 0: flag = 0 return flag #如果是素数返回1 不是返0 temp = int(input('请输入一个数求其所有的素因子：')) for i in range(2,temp): flag = isprime(i) if flag ==1: while 1: if (temp % i == 0)and(i &lt;= temp): temp /= i print(i) else: break else: pass 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27f41660d33cf00257f4fc49f219c772/" rel="bookmark">
			libapk-protect.so的保护机制分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近碰到一款apk，只要修改了dex程序就会进不去，由此想到apk做了dex校验；通过查看application可知加载了libapk-protect.so
通过log可以看到有apk_protect字样
在IDA解析libapk-protect.so后搜索apk_protect，查找它的调用
可以看到这边就是程序退出了，再查找这个函数的调用就只有一处
往前跟踪v81
再往前跟踪v28
可以看到这里有三个判断，判断不一样的话就会进入if函数，这边我们只需要将if函数里赋值0改成赋值1，这样就不会进入退出的函数了；改完之后替换原来的so，发现游戏会一直在登录进不去；这边猜想是有对libapk-protect.so进行验证；
通过抓包发现和正常登陆的包很多不一样，原始app的初始化和登陆与修改后的都不一样；
通过网址等信息跟踪到java层发包的地方
可以看到这边用了xxtea进行加解密，可以hook这个类的openUrl打印参数和返回值
可以看到有发送classes_md5和manifest_md5值，这两个可以校验程序的所有dex和AndroidManifest.xml是否被修改过，把这两个值改成正确的（后面验证虽然这两个值不改也能进游戏，但毕竟是传到服务器的，最好改成正确的值）；
这边还没找到so的验证在哪边，但猜想so的验证也要MD5计算，就在计算classes_md5的MD5的函数那边进行hook；
可以看到确实有libapk-protect.so进行MD5运算；
通过查找函数调用，找到校验libapk-protect.so的地方，通过比较MD5值，进行动态代理；
动态代理执行代码如下，MD5值比较和原来的不一样的话，就会进行if里面的操作，抓包看到的101也是下面进行赋值的；
至此，可以通过屏蔽这个so检验的类，也可以在MD5计算那边通过是否是so文件返回正确的MD5值，这样游戏就可以 进入啦；
小结：这个游戏通过so进行dex验证，通过dex进行so验证，两处都要修改，改其中一处都会出问题；还有apk会将dex和AndroidManifest.xml的MD5值传到服务器，虽然传错误的值不会出现问题，但指不定后面就会封你的号，所有将这两个MD5值也改成正确的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16d6fb0d0b624f1136628330fd6bc2ba/" rel="bookmark">
			python multiprocessing.Barrier
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		屏障
构造函数有一个参数，是指管理的进程的数目
Barrier.wait 是指阻塞进程，直到阻塞的进程数等于构造Barrier时传入的数值时解锁所有被阻塞的进程。
就是说，我先到了wait，然后等着你，等你也到了wait，我们就一起走，等待的人数未构造Barrier时传入的数值。
如
可以看到两个进程输出的时间戳是一样的。
如果把Barrier(num)的num变成3，以上代码会卡住。因为我们没有第三个进程到wait
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7671e58cedb244c1ac1a8caca1d3f14b/" rel="bookmark">
			multiprocessing.Pool 进程池
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进程池就是维持一定量的进程，当有任务时调用进程处理，没有任务时进程空闲，当任务过多时就会等有空闲进程后再进行处理。
进程池有几个函数
apply() 执行一个任务，会阻塞当前进程
apply_async() 执行一个任务，不会阻塞当前进程
apply会返回执行函数的结果，但是apply_async不会等待结果而是直接返回一个multiprocessing.pool.ApplyResult object，因为apply阻塞了进程，等子进程运行完后才继续，所以可以拿到结果，而apply_async不阻塞当前进程，直接输出结果就会输出一个multiprocessing.pool.ApplyResult object
例如：
apply
apply_async
map() 并行地执行一个map，会阻塞当前进程
map_async() 并行地执行一个map，不会阻塞当前进程
map和python内置的map差不多，但是这里是并行执行（会占用所有空闲进程去实现函数）。
map
map_async
close() 关闭进程池，不接受新任务，当所有进程的任务都完成后关闭
terminate() 无论任务是否完成，立刻关闭
join() 等待进程池中进程完成，会阻塞当前进程
进程池中共享对象，之前提到进程之间用队列实现共享可以用到multiprocessing.Queue，但是进程池中进程共享队列必须是multiprocessing.Manager.Queue
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6830b04ff2b4d6a251af05eb2993bf4/" rel="bookmark">
			PostgreSQL远程连接，发生的SSL错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SSL 关闭 的 pg_hba.conf 记录 (pgjdbc: autodetected server-encoding to be GB2312, if the message is not readable, please check database logs and/or host, port, dbname, user, password, pg_hba.conf)
原因：
这是在远程连接时pg_hba.conf文件没有配置正确。
解决方法：
1、找到pg_hba.conf文件（在Postgre安装文件目录下的data文件夹中）
2、打开pg_hba.conf文件，并在文件末尾添加
host all all 0.0.0.0/0 md5
3、重启postgresql的服务，应该就可以连了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/761c87025fa10d8c5c7b06991ae191e6/" rel="bookmark">
			IntelliJ IDEA 创建Web项目（全教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.cnblogs.com/ysgcs/p/9148999.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60534943178643f50104c43ec9967638/" rel="bookmark">
			Override和new的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		override
1. override是派生类用来重写基类中方法的；
2. override不能重写非虚方法和静态方法；
3. override只能重写用virtual、abstract、override修饰的方法；
4. 不能使用修饰符 new、static、virtual 或 abstract 来修改 override 方法。
new
1. new是派生类用来隐藏基类中的方法的；也就是说在派生类中“看不到”基类中的方法；
2. 如果要在派生类中隐藏（不是重写）基类中的方法，而没有使用new关键字，编译时会出现一个警告，提示如果是要隐藏基类中的方法，请使用new关键字；
3. 派生类可以隐藏基类中的虚方法，也可以隐藏基类中的普通方法。
4. 如果在派生类中用private来修饰new 方法，那么只在该派生类中隐藏了基类中的方法，在该派生类之外，相当于没有隐藏基类中的方法；
5. 如果在派生类中隐藏了基类中的方法，在该派生类的派生类中，将延续对该派生类对基类方法的隐藏。
代码：
class A { public virtual void Func() // 注意virtual,表明这是一个虚拟函数 { Console.WriteLine("Func In A"); } } class B : A // 注意B是从A类继承,所以A是父类,B是子类 { public override void Func() // 注意override ,表明重新实现了虚函数 { Console.WriteLine("Func In B"); } } class C : B // 注意C是从B类继承,所以B是父类,C是子类 { } class D : A // 注意D是从A类继承,所以A是父类,D是子类 { public new void Func() // 注意new，表明覆盖父类里的同名类，而不是重新实现 { Console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60534943178643f50104c43ec9967638/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6cd73b862233cc9c6a86187486be2d0/" rel="bookmark">
			kafka 主题管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于 kafka 主题（topic）的管理（增删改查），使用最多的便是kafka自带的脚本。
创建主题 kafka提供了自带的 kafka-topics 脚本，用来帮助用户创建主题（topic）。
bin/kafka-topics.sh --bootstrap-server broker_host:port --create --topic my_topic_name --partitions 1 --replication-factor 1 create 表明我们要创建主题，而 partitions 和 replication factor 分别设置了主题的分区数以及每个分区下的副本数。
这里为什么用的 --bootstrap-server 参数，而不是 --zookeeper ? --zookeeper 参数是之前版本的用法，从kafka 2.2 版本开始，社区推荐使用 --bootstrap-server 参数替换 --zoookeeper ，并且显式地将后者标记为 “已过期”，因此，如果你已经在使用 2.2 版本了，那么创建主题请指定 --bootstrap-server 参数。
推荐使用 --bootstrap-server 而非 --zookeeper 的原因主要有两个。
使用 --zookeeper 会绕过 Kafka 的安全体系。这就是说，即使你为 Kafka 集群设置了安全认证，限制了主题的创建，如果你使用 --zookeeper 的命令，依然能成功创建任意主题，不受认证体系的约束。这显然是 Kafka 集群的运维人员不希望看到的。使用 --bootstrap-server 与集群进行交互，越来越成为使用 Kafka 的标准姿势。换句话说，以后会有越来越少的命令和 API 需要与 ZooKeeper 进行连接。这样，我们只需要一套连接信息，就能与 Kafka 进行全方位的交互，不用像以前一样，必须同时维护 ZooKeeper 和 Broker 的连接信息。 查询主题 创建好主题之后，Kafka 允许我们使用相同的脚本查询主题。你可以使用下面的命令，查询所有主题的列表。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6cd73b862233cc9c6a86187486be2d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/942943a62b753f54cd6d186dea231bf3/" rel="bookmark">
			构造函数--继承
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		构造函数的理解 构造函数在通过new关键字调用的过程中会创建一个对象，并作为参数传递给构造函数。
如果构造函数返回值是 一般的数据类型， 构造函数就会忽略这个值，实例不会改变 如果构造函数的返回值是引用数据类型，构造函数就会忽略this，实例就会变成构造函数返回的对象
var button = { clicked: false, click: () =&gt; { console.log(this, 'this') } } button.click() // 非严格模式下是window 严格模式下是空对象{} var button2 = { clicked: false, click: function (){ console.log(this, 'this') } } button2.click() // 指向button2 function Button() { this.isClick = false, this.click = function() { console.log(this) } } const button = new Button() button.click() // Button {isClick: false, click: ƒ} console.log(button) // Button {isClick: false, click: ƒ} document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/942943a62b753f54cd6d186dea231bf3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/265460301cc90a8c3045e4c509f72ccb/" rel="bookmark">
			Java JDK8新特性之Lambada表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. lambada表达式简介 Lambda 表达式是一种匿名函数(对 Java 而言这并不完全正确，但现在姑且这么认为)，简单地说，它是没有声明的方法，也即没有访问修饰符、返回值声明和名字。
你可以将其想做一种速记，在你需要使用某个方法的地方写上它。当某个方法只使用一次，而且定义很简短，使用这种速记替代之尤其有效，这样，你就不必在类中费力写声明与方法了。
Java 中的 Lambda 表达式通常使用 (argument) -&gt; (body) 语法书写，例如：
(arg1, arg2...) -&gt; { body } (type1 arg1, type2 arg2...) -&gt; { body } 常见的写法如下
(int a, int b) -&gt; { return a + b; } () -&gt; System.out.println("Hello World"); (String s) -&gt; { System.out.println(s); } () -&gt; 42 () -&gt; { return 3.1415 }; 2. Lambda 表达式的结构 一个 Lambda 表达式可以有零个或多个参数参数的类型既可以明确声明，也可以根据上下文来推断。例如：(int a)与(a)效果相同所有参数需包含在圆括号内，参数之间用逗号相隔。例如：(a, b) 或 (int a, int b) 或 (String a, int b, float c)空圆括号代表参数集为空。例如：() -&gt; 42当只有一个参数，且其类型可推导时，圆括号（）可省略。例如：a -&gt; return a*aLambda 表达式的主体可包含零条或多条语句如果 Lambda 表达式的主体只有一条语句，花括号{}可省略。匿名函数的返回类型与该主体表达式一致如果 Lambda 表达式的主体包含一条以上语句，则表达式必须包含在花括号{}中（形成代码块）。匿名函数的返回类型与代码块的返回类型一致，若没有返回则为空 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/265460301cc90a8c3045e4c509f72ccb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce6a86567121c06fcf3b9bd819509ce8/" rel="bookmark">
			eclipse打包mvn和gradle
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		gradle 项目可以直接export war
maven项目如果没有export,在run 中 congratulation中,左边找到maven build,点过三角,然后选择项目,在skip.test上打勾,在global上添加install ,run即可.
如果,test能通过.直接用命令行在项目的界面,gradle build 或者mvn install 即可.
这种方式全是默认的包格式
mvn 通过配置war 可以改成war 的方式,如果是纯粹的后台服务,那么你访问的地址是 localhost:8080/后台服务名称/你的controler 映射地址
如果是java -jar的方式启动,则很方便…自己的服务配的什么地址,直接用什么就行了…
我用的是spring-boot,所以在原来的启动类 XXXApplication.java…需要继承SpringBootServletInitializer,并实现configure 返回 builder.sources(XXXApplication.class) 务必注意,这个XXXApplication.java,中的"XXX",毕竟有的名字不一样.
这时候所有的jar包和war包,是都可以用java -jar 的方式启动的,war包放在tomcat中也是可以访问的.
这应该是因为pom文件的关联并没有排除tomcat,导致打包的时候,把tomcat内置进去了.如果需要排除,用在spring-boot-starter-web排除…网上资料这么说,但是我发现我这么做了,还是能用java -jar的方式启动.
至于其他的复杂的方式,需要了自己研究吧.大多数用不着.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01e56093ba397d59e51677ae59a1b5a5/" rel="bookmark">
			echarts 实现图表缩放功能 dataZoom自带属性实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		echarts 实现图表缩放功能 亲测有效，dataZoom自带属性实现 图表数据过多展示起来密密麻麻看不到细节，需要实现缩放这确实是实现了缩放，但是需求是标尺进行缩放，我们可以添加如下属性 图表数据过多展示起来密密麻麻看不到细节，需要实现缩放 以下是未做缩放效果图
在网上查看了许多方式之后一直不起效果，都说添加 dataZoom 属性，也没有全面一点的代码作为小白的我，真让人摸不着头脑，经过我的不懈努力查看了许多相关资料后，点点累计终于找到突破口，添加 dataZoom 属性是没错，但是对于新手小白就会犯糊涂了，代码不知添加在哪，下面根据自己的经验给大家粗略讲解一下 echarts dataZoom 自带属性的实现
我们需要知道开启缩放效果的入口是在 toolbox下 ，在toolbox.feature.dataZoom.show:true属性下添加如下代码
toolbox: { show : true, feature : { mark : {show: true}, dataView : { show: true, readOnly: false, //修改数据视图格式 optionToContent: function (opt) { //修改数据视图代码最后贴出，此处不做过多展示 } }, magicType : {show: true, type: ['line', 'bar']}, restore : {show: true}, saveAsImage : {show:true}, dataZoom : { show : true, } } } 添加刷新后我们可以看到右上角多出两个按钮
鼠标移入
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01e56093ba397d59e51677ae59a1b5a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7e677e743941835819caae9135e2548/" rel="bookmark">
			京城卫戍区派车管理系统开源项目  一定要收藏！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目简介： 外包公司投标的御林军派车项目，由我负责，总开发人数3人，项目虽然没用到什么特别高端的技术，从中收获了很多项目开发经验，项目从需求分析-详细设计-编码开发-测试-甲方演示到最后到部署上线。
项目上线后开源了这个项目
下面详细介绍项目： 开发技术：Springboot、Springmvc、mybatis、mysql5.7
部署：因不能连接外网，且只在一台电脑操作，因此是本地部署，然后与门卫的电脑连接内网控制道闸与收费
业务功能：主要是值班员派车（公车），对车辆能更好对管理车辆有效管理；用车人到值班室填写派车单，然后由值班员录入系统，车辆可以通过道闸出入场，简单来说就是这么个功能。登陆账号两种权限：管理员和操作员，管理员不能派车操作
项目截图： 1.登陆页面
2.主页面
3.派车页面
派车单是根据甲方要求格式设计
派车单支持 取消/删除
4.车辆管理页面
5.主要功能大概就是这些，甲方要求派车单可以下拉选择也可以手动填写。
码云：https://gitee.com/lzhjava/car_manager
github：https://github.com/lzhjavagithub/vehicle_manager
项目在码云/GitHub上开源，各位小伙伴可以下载参考学习，祝愿可以通过这个简单的项目帮助每一位初入开发的小伙伴；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ed9ed39c5ca1f6e51e9612da84c55a1/" rel="bookmark">
			QT on Android  UI界面设计了但是APP界面不变的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.删除构建目录下的所有的文件，如果APP界面变为设计的界面，问题解决，如果没解决请继续2.
2.将构建目录下的ui_xxxx.h文件复制，然后直接替换到主程序中的ui_xxxx.h文件，然后编译，问题解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/922f1c63175283ab1f5a33ab357014d9/" rel="bookmark">
			golang读取文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/*
go读取文件
读写文件是很多程序的基本任务
*/
package main
import (
"bufio"
"fmt"
"io"
"io/ioutil"
"os"
)
/*
读取文件的函数调用大多需要检查错误
使用下面这个错误检查方法可以方便点
*/
func check(e error) {
if e != nil {
panic(e)
}
}
/*
知识点：
ioutil.ReadFile 读取整个文件内容到内存
make([]byte, 5)
os.Open()
f.Read()
string(b1)
*/
func main() {
//最基本的文件读写任务就是把整个文件的内容读取到内存
dat, err := ioutil.ReadFile("tmp/dat")
check(err)
fmt.Print(string(dat))
/*
有的时候你想更多地控制到底层
是读取文件的那个部分
这个时你可以使用 os.open 打开一个文件获取一个 os.File对象
*/
f, err := os.Open("tmp/dat")
/*
从这个文件中读取一些字节 并且由于字节数组长度所限
最多读取5个字节 另外还需要注意实际能够读取的字节数量
*/
b1 := make([]byte, 5)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/922f1c63175283ab1f5a33ab357014d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bebe82147cac73a509ac0124c200e98/" rel="bookmark">
			Fastadmin 后台上传视频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在FastAdmin官网中，【文档-组件-文件上传】中传介绍了文件的上传（本文围绕上传50M的视频文件进行说明），在阅读以下内容前，建议先了解关于文件上传中的data-mimetype和data-maxsize两个属性。
一、在html文件中，添加2个属性data-mimetype和data-maxsize。 &lt;div class="form-group"&gt; &lt;label class="control-label col-xs-12 col-sm-2"&gt;{:__('Vediofile')}:&lt;/label&gt; &lt;div class="col-xs-12 col-sm-8"&gt; &lt;div class="input-group"&gt; &lt;input id="c-vediofile" class="form-control" size="50" name="row[vediofile]" type="text"&gt; &lt;div class="input-group-addon no-border no-padding"&gt; &lt;span&gt;&lt;button type="button" id="plupload-vediofile" class="btn btn-danger plupload" data-input-id="c-vediofile" data-mimetype="mp4,mp3,avi,flv,wmv" data-multiple="false" data-maxsize="50M"&gt;&lt;i class="fa fa-upload"&gt;&lt;/i&gt; {:__('Upload')}&lt;/button&gt;&lt;/span&gt; &lt;span&gt;&lt;button type="button" id="fachoose-vediofile" class="btn btn-primary fachoose" data-input-id="c-vediofile" data-mimetype="mp4,mp3,avi,flv,wmv" data-multiple="false"&gt;&lt;i class="fa fa-list"&gt;&lt;/i&gt; {:__('Choose')}&lt;/button&gt;&lt;/span&gt; &lt;/div&gt; &lt;span class="msg-box n-right" for="c-vediofile"&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 二、修改application/extra/upload.php中的maxsize配置： &lt;?php //上传配置 return [ // .... /** * 最大可上传大小 */ 'maxsize' =&gt; '50mb', /** * 可上传的文件类型(新增mp4,mp3,avi,flv,wmv视频文件后缀) */ 'mimetype' =&gt; 'jpg,png,bmp,jpeg,gif,zip,rar,xls,xlsx,mp4,mp3,avi,flv,wmv', // .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bebe82147cac73a509ac0124c200e98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9fd0e7c747f49cfed61e18379bc4144/" rel="bookmark">
			搭建开发环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		搭建开发环境
什么是开发环境？
就是开发软件的时候，你需要用到的软件，硬件要求，操作系统平台，称之为环境。
涉及到两个东西：虚拟机软件+linux 系统
虚拟机软件：就是一个单纯的在 windows 中运行的软件，跟 word、360 没有本质区别。现在主流的虚拟机软件有 VMWare 和 VirtualBox
虚拟机软件在 windows 系统中运行，运行后它会模拟出来一个电脑，所以叫虚拟机。然后我们可以在该虚拟机中安装别的操作系统。
当前，可以先使用事先安装好的 ubuntu，密码是 root。
这几天出去，没时间具体讲怎么安装虚拟机，如果有什么安装不懂得话，可以参考网上，或者参考书上。
下面是我提供的怎么安装虚拟机。针对虚拟机安装，大家可以多安装几次，就会了，非常简单。
在微信公众号，大家可以搜软件安装管家，里面有很详细的步骤。
VMware14（32/64）位下载地址：
提取码: qwrc
选择下载需要在虚拟机里安装的系统：
Windows 7/64位下载链接
[提取码]：fj4p
Windows 7/32位下载链接
[提取码]：3pp2
Windows 8/64位下载链接
[提取码]：ewsp
Windows 8/32位下载链接
[提取码]：n1xg
Windows 10/64位下载链接)
[提取码]：dggh
Windows 10/32位下载链接
[提取码]：xsp3
Windows XP下载链接
[提取码]：wpqk
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5249a8b5151246b6c95a33d4d8acd760/" rel="bookmark">
			clean architecture 读书笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		The goal of software architecture is to minimize the human resources required to build and maintain the required system. 架构设计的目标： 用最小的人力来开发并维护需要的系统。 Every software system provides two different values to the stakeholders: behavior and structure. 软件提供两种价值：行为和结构 行为：软件需要满足要求，能够工作。 结构：软件需要便于改变，够“软” 编程范式： structured programming object-oriented programming functional programming structured programming 结构化编程 functional decomposition 划分规模合理的程序块，各程序块完成相应部分任务，组合完成整体任务。 create falsifiable units of programming 构建可证伪的程序块，便于测试。 Certain uses of goto statements prevent modules from being decomposed recursively into smaller and smaller units, thereby preventing use of the divide-and-conquer approach necessary for reasonable proofs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5249a8b5151246b6c95a33d4d8acd760/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52ebf34006c3734689fa286618ea0b19/" rel="bookmark">
			Altium Designer 18 速成实战 第三部分 原理图的绘制 （八）元件的排列与对齐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Altium Designer 18 速成实战 第三部分 原理图的绘制 （八）元件的排列与对齐
一、左对齐：选中+按下A+选择左对齐 二、右对齐：选中+按下A+选择右对齐 三、水平中心对齐：选中+按下A+选择水平中心对齐 四、水平分布：选中+按下A+选择水平分布 五、顶对齐/底对齐：选中+按下A+选择顶对齐/底对齐 六、垂直中心对齐：选中+按下A+垂直中心对齐 七、垂直分布：选中+按下A+垂直分布 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/275e9380678a314d32eaeda9803fe3bb/" rel="bookmark">
			电影感想——《记得香蕉成熟时》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		其实我去年看这个电影时纯粹是为了看我偶像——哥哥张国荣，不过他只在2里面客串了一下，我看到这个2觉得还不错，顺便把1也给看了。当时我挺感动的，男主与我何其相似，没有看过的我推荐你看一下。电影名字我觉得和“有花堪折直须折，莫待无花空折枝。”有异曲同工之处，都是说的同样的意思。
男主与女主婷婷是青梅竹马，婷婷小时候很丑，后来很漂亮。男主后来想追她，后来发现女主与别的男生关系密切，就一直躲着，有种刻意避开的意思。男主情场失意，女主换了几个男票，轮也该轮到男主了吧，当时给我气的，不过注定这是个悲剧，鲁迅说“悲剧是把美好的东西撕碎给人看”，本来男女主青梅竹马，为何不能在一起？不知道婷婷是怎么想的，这又是何必呢？后来下雨天说的话真令人伤心，后来女主出国了，男主开车接她回来的当天带着他8个月大的女儿还有老婆，这是我唯一看到的欣慰。真是的，本来两人在一起完全没意外，女人心海底针，看不透猜不出。
不过我看出了一个意思，这或许也是电影想表达的，喜欢一个人并不一定能在一起，美好的也不一定要拥有，我只能用这么消极一点的话来宽慰自己，毕竟世事我曾努力争取。
青少年经历的坎坷不算什么，长大后会更多。你以为已经是人生的低谷，其实不过是半山腰，就像股票一样，谁知道还会不会有几个跌停呢？人生的意义我已参透了许多，经历这些也算是一笔财富吧，可我宁愿不要这些财富，谁想要谁要？我有选择权利吗？
后来看《战斗天使：阿丽塔》同样感动，特别是女主拉着雨果的手，在万丈高空，雨果说了句“Thank you persuing me ”(谢谢你救了我，单词我可能记错了)，当时特别感动，这部电影我给评分9.8分，比某些电影好很多。
电影和电视剧都是骗人的，我从没在实际生活中遇到过类似的感情，或许是我太屌丝了，我不想活成别人的样子难道就没人看得上我？人生真是艰难啊。不要悲观叹息，以后的艰难还有很多，我们不妨一起经历。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/923aaced1409001bf5f82eb8433f692a/" rel="bookmark">
			Layer Normalization
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文： Jimmy Lei Ba, Jamie Ryan Kiros, Geoffrey E. Hinton. Layer Normalization. arXiv:1607.06450
Batch normalization 对每个channel或者hidden unit，求输入(mini-)batch上所有样本在这个channel上的均值和标准差。之后根据每个channel上的均值和标准差对这些样本进行归一化处理。
然后对归一化后的样本的每个channel进行放射变换: y i c = g a i n c × x i c + b i a s c y_{ic}= gain_c \times x_{ic} + bias_c yic​=gainc​×xic​+biasc​，一个mini-batch上不同样本的同一channel上处理方式相同。
每个channel需要且仅需要学习两个参数： g a i n c gain_c gainc​和 b i a s c bias_c biasc​。
Layer normalization 对于输入的每个样本求一个均值和方差，然后根据每个样本的均值和方差对该样本进行归一化处理。
pytorch 中默认参数 elementwise_affine=True
这时需要学习 C × \times × W × \times ×H个gain和bias。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/923aaced1409001bf5f82eb8433f692a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2062926e7915776d3384d8b8df7e937b/" rel="bookmark">
			【openmv专题】串口通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章主要讲述openmv串口通信过程中会出现错位，因缓存空间不足带来的串口报错问题，直接进入正题：
串口通信有同步和异步之分，而openmv用的是异步通信，需要有缓存区，当缓存区内容过多的时候就会报错，就会出现串口因为缓存区内容过多而报错，需要及时读取或清除缓存区的东西。因此我选择用openmv唯一一个可以用的定时器来定时读取或清除串口缓存区。废话不多说，直接放代码。
uart = UART(3,115200) uart.init(115200,bits=8,parity=None,stop=1,timeout_char=1000)#串口初始化 def uart_read(timer):#定时器回调函数，串口接收 global step global cmd global height if uart.any(): m_1 = uart.readchar() #print(m_1) if m_1==0x05: m_2 = uart.readchar() #print(m_2) if m_2==0x20: cmd = uart.readchar() height = uart.readchar() m_5 = uart.readchar() m_6 = uart.readchar() if cmd==0: step = 0 #串口发送 def uart_send(): for i in range(16): uart.writechar(data.send_buf[i]) tim = pyb.Timer(4,freq=100) tim.callback(uart_read) 如果要在openmv定时器的回调函数改变某个值只能使用global声明的变量，就算是用class类型的也改变不了。在通信的过程中发现如果直接读取多个会出现某一次读取数量不够，导致下一次读取错位的问题。所以我采用逐个读取的方法，当帧头完全正确的时候开始连续读取，然后一般不会错位。
第一次写博客，有什么不对的地方请指出，谢谢。也欢迎大家一起交流，共同进步。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2d49b83f22542408477d1efb3403fb1/" rel="bookmark">
			利用Python取出excel数据并生成统计图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		取出excel数据生成图表 帮朋友写的一个小脚本从excel中取出数据，然后生成一个统计图表借助了Python的第三方模块xlrd和pyecharts xlrd Python中用来读取excel数据的模块安装pip install xlrdxlrd文档 pyecharts Echarts 是一个由百度开源的数据可视化，凭借着良好的交互性，精巧的图表设计，得到了众多开发者的认可。pyecharts就是通过Python使用Echarts。安装pip install pyecharts注意： 现在有很多网上的使用pyecharts的版本都是v0.5.x的，现在安装都是v1版本的，两者差别还是蛮大的。pyecharts 分为 v0.5.X 和 v1 两个大版本，v0.5.X 和 v1 间不兼容，v1 是一个全新的版本pyecharts v1版本文档 代码分析 # 打开存储数据的excel data = xlrd.open_workbook('C:\\Users\\Administrator\\Desktop\\新建文件夹\\个人-月\\12.xlsx') # 以表格的形式取出数据 table = data.sheets()[0] # 取出表格中第一列数据 PM2_5 = table.col_values(0) # 生成一个折线统计图对象 line = Line() # 添加 x 轴元素 line.add_xaxis(handle_time_list(time[1:])) # 添加 y 轴元素 line.add_yaxis('PM2.5', PM2_5[1:]) # 渲染到html页面 line.render('./person/12.html') 代码很简单，就是表格中的数据较多。
实现代码 from pyecharts.charts import Bar, Line import xlrd def handle_time_list(time_list): """ 处理float格式的时间数据为 年/月/日 小时:分钟 time_list: 时间列表 return: 处理好的时间数据列表 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2d49b83f22542408477d1efb3403fb1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e92df10083bcfcf22e10b8a867e7799/" rel="bookmark">
			ES集群搭建及Kibana安装、操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、搜索的介绍2、全文检索的介绍1、全文检索的需求介绍2、非结构化数据查找方法3、如何实现全文检索4、lucene实现全文检索流程5、全文检索框架介绍 3、ELK日志协议栈1、ELK协议栈基本介绍1、集中式日志系统2、ELK 协议栈介绍及体系结构3、Elk整体架构4、参考文档 4、Elasticsearch介绍1、什么是ElasticSearch2、ElasticSearch使用案例3、ElasticSearch对比Solr4、ElasticSearch架构图以及基本概念(术语)1、es概述2、ES架构模块3、Elasticsearch核心概念 5、es的集群部署第一步：创建普通用户第二步：为普通用户es添加sudo权限第三步：下载并上传压缩包，然后解压第四步：修改配置文件第五步：将安装包分发到其他服务器上面第六步：node02与node03修改es配置文件第七步：修改系统配置，解决启动时候的问题第八步：启动ES服务 6、node01服务器安装elasticsearch-head插件1 、node01机器安装nodejs第一步：下载安装包第二步：创建软连接第三步：修改环境变量第四步：验证安装成功 2 、node01机器安装elasticsearch-head插件1、第一种方式：在线安装elasticsearch-head插件（网速慢，不推荐）第一步：在线安装必须依赖包第二步：从git上面克隆编译包并进行安装第三步、node01机器修改Gruntfile.js 第四步、node01机器修改app.js2、第二种方式：直接使用提供的编译之后的源码包解压之后修改配置文件即可（强烈推荐）第一步：上传压缩包到/home/es路径下去第二步：解压安装包第三步、node01机器修改Gruntfile.js第四步、node01机器修改app.js 3、node01机器启动head服务4、访问elasticsearch-head界面 7、node01服务器安装Kibana第一步：下载资源上传服务器并解压第二步：修改配置文件第三步：启动服务第四步：浏览器访问 8、使用kibana管理索引1、使用 Xput创建索引1、创建索引2、插入文档3、查询文档4、更新文档5、搜索文档6、删除文档7、删除索引 2、返回值说明1、Hits2、took3、Shard4、timeout 3、花式查询1、使用match_all做查询2、通过关键字段进行查询3、bool的复合查询4、bool的复合查询中的should5、term匹配6、使用terms匹配多个值7、Range过滤8、exists和 missing过滤9、bool的多条件过滤10、查询与过滤条件合并 4、索引映射（mappings）管理1、为什么要映射2、基本命令3、获取映射字段 5、索引库配置管理（settings）1、 索引库配置2、 零停机重新索引数据 15、kibana报表展示第一步：下载数据集第二步：上传我们的数据集并解压第三步：创建对应的索引库第四步：加载示例数据到我们的索引库当中来第五步：实现数据的报表展示 1、搜索的介绍 搜索是指搜寻检索，指代使用一定手段来检索到我们自己需要的信息，包括从文件当中检索，百度当中检索，网站内部搜索等等
2、全文检索的介绍 1、全文检索的需求介绍 首先我们谈几个公司，如雷贯耳的：百度、谷歌、维基百科；这些公司都有一个相似性就是门户网站，可以提供我们通过关键字搜索，然后快速的检索出我们想要的信息；
【网页百度展示】
比如我们检索传智播客，百度后台就会按照这个关键字进行查找（里面有搜索库，以及爬虫库），然后按照权重来进行从上到下的排序，给我们高亮的展示出现
【京东或者淘宝展示】
随便搜索东西，就会高精度的展示我们想要的；就会根据关键词进行海量数据的快速的检索
比如我们查找：”护手霜“ ， 那么这期间内部会经过大体的：1、分词（护手，手霜，护等）2、根据这些词去海量的数据中检索 3、然后根据权重把检索出来的信息进行排序展示给我们
【传统做法】
那么对于一般的公司，初期是没有那么多数据的，所以很多公司更倾向于使用传统的数据库：mysql；比如我们要查找关键字”传智播客“，那么查询的方式大概就是:select * from table where field like ‘%传智播客%’; 但是随着业务发展，数据会不断的膨胀，那么问题就来了；mysql单表查询能力即便经过了优化，它的极限也就是400W左右的数据量。而且还会经常出现查询超时的现象；
然后很多公司开始对数据库进行横向和纵向的扩容，开始进行数据库表的“拆分”：横向拆分和纵向拆分；但是即便这样操作，仍然会出现很多问题，比如：
1、数据库会出现单点故障问题，于是先天主从复制关系，于是增加了运维成本
2、因为对表的拆分，增加了后期维护的难度，同样也是增加了运维成本
3、即便做了大量的维护，但对于大数据的检索操作，依然很慢，完全达不到期望值
于是出现了lucene，全文检索的工具。但是lucene对外暴露出的可用接口对于开发人员来说，操作是非常的复杂，而且没有效率的；于是在lucene的基础上进一步的封装，有了一个叫做solr的高性能分布式检索服务框架，但是，solr有一个致命的缺点就是：在建立索引期间，solr的搜索能力会极度下降，这就在一定程度上造成了solr在实时索引上效率并不高；
最后，出现了一个叫做elasticsearch的框架，同样是以lucene为基础，并且吸收了前两代的教训而开发出的分布式多用户能力的全文搜索引擎，并且elasticsearch是基于RESTful web接口进行发布的，那么这就意味着，我们开发人员操作起来更方便快捷；同时es拓展节点方便，可用于存储和检索海量数据，接近实时搜索能力，自动发现节点、副本机制保障可用性
2、非结构化数据查找方法 1：顺序扫描法(Serial Scanning)
所谓顺序扫描，比如要找内容包含某一个字符串的文件，就是一个文档一个文档的看，对于每一个文档，从头看到尾，如果此文档包含此字符串，则此文档为我们要找的文件，接着看下一个文件，直到扫描完所有的文件。如利用windows的搜索也可以搜索文件内容，只是相当的慢。
2：全文检索(Full-text Search)
将非结构化数据中的一部分信息提取出来，重新组织，使其变得有一定结构，然后对此有一定结构的数据进行搜索，从而达到搜索相对较快的目的。这部分从非结构化数据中提取出的然后重新组织的信息，我们称之索引。
例如：字典。字典的拼音表和部首检字表就相当于字典的索引，对每一个字的解释是非结构化的，如果字典没有音节表和部首检字表，在茫茫辞海中找一个字只能顺序扫描。然而字的某些信息可以提取出来进行结构化处理，比如读音，就比较结构化，分声母和韵母，分别只有几种可以一一列举，于是将读音拿出来按一定的顺序排列，每一项读音都指向此字的详细解释的页数。我们搜索时按结构化的拼音搜到读音，然后按其指向的页数，便可找到我们的非结构化数据——也即对字的解释。
这种先建立索引，再对索引进行搜索的过程就叫全文检索(Full-text Search)。
虽然创建索引的过程也是非常耗时的，但是索引一旦创建就可以多次使用，全文检索主要处理的是查询，所以耗时间创建索引是值得的。
3、如何实现全文检索 可以使用Lucene实现全文检索。Lucene是apache下的一个开放源代码的全文检索引擎工具包（提供了Jar包，实现全文检索的类库）。它提供了完整的查询引擎和索引引擎，部分文本分析引擎。Lucene的目的是为软件开发人员提供一个简单易用的工具包，以方便地在目标系统中实现全文检索的功能。
注意：Lucene只是一个引擎，只是一个工具包，如果使用Lucene开发全文检索功能，要记住Lucene是不能单独运行的。
4、lucene实现全文检索流程 绿色表示索引过程，对要搜索的原始内容进行索引构建一个索引库，索引过程包括：确定原始内容即要搜索的内容→采集文档→创建文档→分析文档→索引文档。红色表示搜索过程，从索引库中搜索内容，搜索过程包括：用户通过搜索界面→创建查询→执行搜索，从索引库搜索→渲染搜索结果。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e92df10083bcfcf22e10b8a867e7799/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b011876f352c4d641fb1139f5546564f/" rel="bookmark">
			Java校招面试题复习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 JAVA 基础知识点（一）什么是J2EE？JVM？JRE？JDK？（二）面向对象的三大特性什么是继承？什么是封装？什么是多态？java为什么不支持多继承？ Java 中覆盖和重载是什么意思？重定向和转发的区别。抽象类和接口的区别有哪些？Java 和 C++ 的区别：&amp;与&amp;&amp;的区别：IN和EXISTS的区别 Java 中常见集合1）说说常见的集合有哪些吧？2）HashMap 和 Hashtable 的区别有哪些？（必问）3）HashMap 的底层实现你知道吗？4）ConcurrentHashMap 和 Hashtable 的区别？（必问）5）HashMap 的长度为什么是 2 的幂次方？6）List 和 Set 的区别是啥？7）List、Set 和 Map 的初始容量和加载因子8）Comparable 接口和 Comparator 接口有什么区别？9）Java 集合的快速失败机制 “fail-fast” 高并发编程-JUC 包1）多线程和单线程的区别和联系：2）如何指定多个线程的执行顺序？3）线程和进程的区别：（必考）4）多线程产生死锁的 4 个必要条件？5）sleep( ) 和 wait( n)、wait( ) 的区别：6）synchronized 关键字：7）volatile 关键字8）ThreadLocal（线程局部变量）关键字：9）Atomic 关键字：10）线程池有了解吗？（必考） JVM 内存管理1）JVM 内存划分：2）类似-Xms、-Xmn 这些参数的含义：3）垃圾回收算法有哪些？4）root 搜索算法中，哪些可以作为 root？GC是什么？为什么要有GC？5）GC（垃圾回收机制） 什么时候开始？6）内存泄漏和内存溢出7） 解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法。9）Java 中会存在内存泄漏吗，请简单描述。 Java 8 相关知识点数据库知识点1）MySQL 和 MongoDB 的区别有哪些？如何选择？3）听说过事务吗？（必考）4）事务的并发问题有哪几种？5）数据库中的锁有哪几种？6）事务的隔离级别有哪几种？7）数据库的索引有什么作用？（必考） 底层数据结构是什么，为什么使用这种数据结构？8）数据库中 Where、group by、having 关键字：处理上百万条的数据库如何提高处理查询速度 MVC 框架相关知识点Spring 知识点1）Spring 的 IOC 和 AOP 有了解吗？2）AOP 的实现方式有哪几种？如何选择？（必考）Spring创建对象的三种方式IoC和DI的区别IoC容器装配Bean两种方法 什么是AOP ？BeanFactory和FactoryBean的区别？什么是EL、OGNL、spEL？动态代理和静态代理区别？REQUIRED、REQUIRES_NEW、NESTED 区分 Mybatis 知识点Spring MVCSpring MVC 的核心控制器是什么？消息处理流程有哪些？ Spring Boot 异常Error和Exception有什么区别？try{}里有一个return语句，那么紧跟在这个try后的finally{}里的代码会不会被执行，什么时候被执行，在return前还是后?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b011876f352c4d641fb1139f5546564f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44c001b741ac343b59da5f16a137c4b2/" rel="bookmark">
			STM32CubeIDE使用总结（三）——debug调试程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里说明的是调试程序的步骤，所以前提是工程（project）已经编译（Build）成功。
首先，调试用的是调试器是ST-LINK V2，如下图所示：
1.如果第一次使用Cube IDE，应该需要更新ST-LINK固件
在STM32CubeIDE菜单栏“Help-&gt;ST-LINK更新” 中更新ST-LINK固件。
拔下并重新连接ST-LINK/V2，然后点击"Open in update mode"，显示固件版本，之后点击“Upgrade”进行固件升级。
2.在CUBEMX中配置SYS-&gt;Debug：
根据实际调试接口进行配置。
这一步不要忘记，否则后面不能调试。
3.debug调试设置
菜单栏“Run-&gt;Debug Configurations”，弹出设置框，进入调试设置，如下图所示：
上述两图引自：https://blog.csdn.net/Naisu_kun/article/details/97393547
对于“调试器”的设置，一般是根据实际接线，如果用的是SWD接口，则选中SWD，若是JTAG，则选JTAG。
4.设置Debug As目标为“STM32 MCU C/C++ Application”，进入调试
调试界面及功能说明：
上图引自：https://blog.csdn.net/Naisu_kun/article/details/97393547
eclipse进入调试模式自动停在main函数的第一行，这一点与KEIL有区别。要使程序运行，点击工具栏“resume”（继续运行）按钮。
5.调试观察变量或表达式的值
在调试界面菜单栏，点击“window-&gt;show view”：
根据程序中需要观察的变量值或表达式的值，添加到右侧的显示栏中。程序suspend时，将光标放在变量或表达式上位置，会自动弹出其值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d28b4d148a9808191fc0d1d9338b653e/" rel="bookmark">
			【mba旅游管理论文】天乐湖旅游度假区发展现状及问题分析（节选）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要
目前，旅游业在我国取得了很大程度的发展，国家相继出台了多部关于旅游方面的法律，用于规范与促进旅游业的进一步发展，随着旅游市场的逐步开发，形成了一种全新的发展机遇。仪征市是位于宁镇扬中心节点的一个县级市，拥有良好的交通区位以及一定的旅游资源。在仪征市政府的政策正确指引下，诸多企业跻身于旅游行业领域，市场开发力度空前提高，各地的旅游景区像雨后春笋般建立起来，天乐湖旅游度假区正是在这样的背景下发展起来的，积极应对剧烈的竞争以及第十届江苏省园艺博览会、2021 年世界园艺博览会在仪征举办的机遇。因此，此时对天乐湖旅游度假区的市场发展战略进行研究，具有非常重要的战略意义。
本文以天乐湖旅游度假区为研究主体，对其内在环境与外在环境进行分析，指定符合仪征旅游市场的天乐湖旅游度假区的发展战略，根据发展战略采取有针对性的改革措施，保证企业在仪征甚至扬州旅游市场的竞争优势，赢取更大的市场空间。
这篇文章在研究的过程中采用了文献综述法，同时结合了实地考察、数据收集研究、比较分析等对天乐湖旅游度假区进行研究分析。在进行分析时，采用 PEST 分析法以及竞争环境分析的相关理论，来对天乐湖旅游度假区的经营环境以及竞争状况进行各方面的分析。
此外还采用了 SWOT 和 QSPM 分析的方法，通过这些分析，从而确定天乐湖旅游度假区的发展战略，并为它的基础设施以及旅游消费品的增长战略进行规划，这样可以保证在仪征市此种发展战略能够成功实施。在实施过程中，还从组织架构、人力资源、市场营销这三方面进行实施保障。以便能够更好的对天乐湖旅游度假区的发展战略进行指导，帮助其在市场竞争中，保持自身优势，同时能扩大市场份额，增强市场地位。
在本文的研究过程中，主要的分析目的即为探索适合旅游企业发展的模式，为其制定科学的发展战略，明确其自身发展方向，进而提高企业竞争实力。
关键词：天乐湖旅游度假区，旅游市场，发展战略，战略管理
Abstract
With Views on Speeding up the Development of Tourism launched by the state council andimplemented Tourism Law in October 1, 2013 officially, tourism positioning has reached anunprecedented new high, tourism market cannot get consistent development Yizheng is acounty-level city which is located in central node of Ningzhenyang, where has a favorabletransportation area and a degree of tourism resources With governmental guidance of Yizhenggovernment, its tourism enterprise increased consistently and market is developed as well TianleLake holiday resort as a tourism enterprise developed in recent years in Yizheng should replayincreasingly fierce competition and chance of the 10thJiangsu horticultural exposition, 2021world horticultural exposition which will be hold in Yizheng Therefore, researching developmentstrategy to Tianle Lake tourism holiday resort plays an very important role
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d28b4d148a9808191fc0d1d9338b653e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51b339b1c0f981ab538714c99793e5bf/" rel="bookmark">
			【模版】Tarjan离线算法求最近公共祖先(LCA)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【模版】Tarjan离线算法求最近公共祖先(LCA) 储备知识 一、离线算法
离线算法其实就是将多个询问一次性解决.
二、深度优先生成树
什么是生成树：
在图论的数学领域中，如果连通图G的一个子图是一棵包含G的所有顶点的树，则该子图称为G的生成树(SpanningTree). 生成树是连通图的包含图中的所有顶点的极小连通子图. 图的生成树不惟一. 从不同的顶点出发进行遍历，可以得到不同的生成树.
由深度优先搜索得到的树为深度优先生成树.
------&gt;无向图的DFS
三、并查集查询、合并最大祖先
四、最近公共祖先(Least Common Ancestors)
两个点在一棵无环棵树上距离最近的公共祖先节点.
LCA还可以将自己视为祖先节点.
五、链式前向星
什么是前向星：前向星是一种特殊的边集数组
利用前向星会有排序操作, 用快排时间至少为O(nlog(n))
为什么使用链式前向星：链式前向星可以避免排序
链式前向星建立边结构体:
struct Edge{ int to; int next; int wei; }edge[MAXN]; 边结构体解释：
其中edge[i].to表示第i条边的终点, edge[i].next表示与第i条边同起点的下一条边在边集中的存储位置, edge[i].wei为边权值.
另外有一个数组head[MAXN],它是用来表示以i为起点的第一条边存在边集中的存储位置.
head[]数组一般初始化为-1.
加边连点的核心add函数:
void add(int x, int y){ //加边连点 edge[++cnt].next = head[x]; //记录与当前边同起点的下一条边在边集中的存储位置 edge[cnt].to = y; //记录当前边的终点 head[x] = cnt; //对当前边编号 } 注意事项 该模版默认为无向图Tarjan离线算法
若使用有向图Tarjan离线算法 则将add(y, x);以及que[y].push_back(make_pair(x, i));两行注释即可.
无向图测试题目 P3379 【模板】最近公共祖先（LCA）
有向图测试数据 输入： 6 4 1 1 2 1 5 3 6 2 3 2 4 1 2 2 5 3 5 6 2 输出： 1 1 1 2 代码 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; #include &lt;utility&gt; #include &lt;cstring&gt; using namespace std; #define inf 0x3f3f3f3f //极大数据 10^9数量级 #define MAXN 500010 //点的个数 注意依题改变 vector&lt;pair&lt;int, int&gt; &gt; que[MAXN]; //存放查询关系 int vis[MAXN]; //标记访问数组 int pre[MAXN], head[MAXN]; //存放最大祖先 存放当前点为起点的第一条边在边集中的存储位置 int ans[MAXN]; //记录查询问题答案 int cnt, n, q, s; //计数器 点的个数 问题查询数 数根节点 struct Edge{ int to; int next; }edge[MAXN&lt;&lt;1]; //边集 无向图需要双倍空间 有向图不需要 //edge[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51b339b1c0f981ab538714c99793e5bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a19e5cb6bb6b027974591672b671149/" rel="bookmark">
			c源文件中要包含自己的头文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言： 我们经常在c工程中发现，源文件中要包含自己的头文件。一直以来，都不知道为什么这样做。现在，我知道了。
以前的认知： 我认为，.c文件没有必要包含自己的.h文件。.h文件包含.c文件中定义的函数和全局变量的声明，.h文件就是.c文件提供的对外接口文件。既然.h文件就是.c文件提供的对外接口文件，那么.c文件就没必要包含自己的.h文件了（.h文件是对外提供用的，对内又何必再包含进来呢）。
鉴于这样的理解，我对于工程中.c源文件包含自己的.h头文件很是不理解，不知道为什么要这样做。
现在对此的理解： 但是现在，我知道为什么要源文件包含自己的头文件了。
如下，一段书中的原话： “如果希望让编译器检查声明的一致性,一定要把全局声明放到头文件中。特别是,永远不要把外部函数的原型（也就是函数声明）放到.c文件中:通常它与定义的一致性不能得到检查,而矛盾的原型（也就是函数声明）比不用还糟糕。”
注意：外部函数的原型，就是外部函数的声明。
对这段话的理解： 为什么：“永远不要把外部函数的原型放到.c 文件中” 这个外部函数A指的是B.c文件之外定义的函数，B.c文件中需要使用外部函数A，就需要先对外部函数A声明（对外部函数的声明就是外部函数原型）。对这个外部函数A的声明，不能放在B.c文件里面来实现。
以实例说明：
①假若工程中有2个源文件a.c和b.c；a.c的头文件为a.h，b.c的头文件为b.h。
②a.c中定义了一个函数sum。
③b.c要引用sum这个函数。做法是：在b.c中声明sum这个函数。然后b.c就可以使用sum函数了。
这样的做法就是把外部函数sum的声明放到了b.c中来。然而，这样的做法很不妥。
不妥的原因：
sum是在a.c中定义的，而声明确是在b.c中，sum函数的定义和声明不是在同一个文件中的。定义和声明不在同一个文件中，编译的时候，编译器就不能对定义和声明的一致性进行检查。这样，如果sum的定义和声明不一致，编译器就无法检查出来（定义和声明不在同一个文件中），那么编译的时候不会报错，但是程序运行的时候就可能会出错。而这样的错误，查找起来又不是很容易。
鉴于此，才这样说：“永远不要把外部函数的原型放到.c文件中”。
那如何才能让编译器检查定义和声明的一致性呢？ 前面说，如果把外部函数的原型放到.c文件中，编译器就无法检查声明和定义的一致性（声明和定义不在同一个文件中）。那么，要让编译器检查定义和声明的一致性呢，自然是把定义和声明放在同一个文件中，而如何实现把定义和声明放在同一个文件里呢？
答案：源文件定义的函数，在源文件对应的头文件中声明，然后源文件包含自己的头文件。这样定义和声明就放在同一个文件里了。
总结：c语言源文件包含自己的头文件有两个好处：
1.方便编译的时候检查函数声明和定义的一致性，免得运行时出错
有三个文件：math.c myadd.c myadd.h，内容如下：
//myth.c #include &lt;stdio.h&gt; #include "myadd.h" int main(void) { int a = myadd(4,2); printf("a=%d\n",a); printf("%s\n","hello world" ); } //myadd.h #ifndef _MYADD_H #define _MYADD_H int myadd(int ,int ); #endif //myadd.c #include&lt;stdio.h&gt; void myadd(char * a, int b,int c) { //return a+b; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a19e5cb6bb6b027974591672b671149/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70964e8ff07c73dac79e2191e8f56413/" rel="bookmark">
			Dubbo框架项目 启动服务提供者 tomcat报错[ERROR] No plugin found for prefix &#39;tomcat7&#39; in the current project and in
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误信息：
[ERROR] No plugin found for prefix ‘tomcat7’ in the current project and in the plugin groups [org.apache.maven.plugins, org.codehaus.mojo] available from the repositories [local (E:\Maven\repository), alimaven (http://121.42.166.202:8081/nexus/content/groups/public)] -&gt; [Help 1]
[ERROR]
[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.
[ERROR] Re-run Maven using the -X switch to enable full debug logging.
[ERROR]
[ERROR] For more information about the errors and possible solutions, please read the following articles:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70964e8ff07c73dac79e2191e8f56413/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed0048f4559f7bf091fb70b41c04c88b/" rel="bookmark">
			Power Query 系列 (13) - 自定义函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇博客介绍 Power Query 自定义函数的技巧，在 PQ 中计算个税。
以工资类所得应交个税为例，最新的个税起征点为 5000 并按下表的级次进行缴税（假设没有其它扣除项）。
对照税率表，我们先看看手工如何计算。比如 xxx 的薪资为 8900，没有其它扣除，那么应缴纳的个税为：
1: 应纳税所得额 = 8900 - 5000 = 3900 2： 3900 对应级数为 1，应纳税额 = 3900 * 10% - 210 = 180 接下来介绍在 PQ 中如何通过自定义函数来计算。有下面两个表：税率表（TaxRate）he员工薪资表（salaries），要计算张三和李四应交个税金额。假设我们用自定义函数的方式。本文将给出三种方法。
将 Excel 工作表中的两个数据源通过 Ctrl + T 转换成表，加载到 PQ 中。
函数的语法 PQ 函数的语法示例：
(x, y) =&gt; x + y 方法1：在高级编辑器中手写代码。新建一个空查询，改名为 GetIncomeTax，进入高级查询，在高级查询中输入下面的代码：
(taxable) =&gt; if taxable &lt;=0 then 0 else if taxable &lt;= 3000 then taxable * 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed0048f4559f7bf091fb70b41c04c88b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dade30fe6b806378b42457d1d7e885ee/" rel="bookmark">
			6-5抽象类和抽象方法的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package com.atguigu.java; /* * abstract 关键字的使用 * 1.abstract 抽象的 * 2.abstract 可以用来修饰的结构： 类， 方法 * 3.abstract 修饰类 抽象类 * 此类不能实例化 * 抽象类中一定有构造器便于子类实例化的时候调用（涉及，子类对象实例化的过程) * 开发中都会提供抽象类的子类让子类对象进行实例化 * 抽象类可以含有不是抽象方法 * * 4.abstract 修饰方法 * 只有方法的声明，没有方法体 * 包含抽象方法的类一定是抽象类，反之抽象类中可以没有抽象方法 * 若子类重写了父类中所有的抽象方法后，次子类可以实例化 * */ public class AbstractTest { public static void main(String[] args) { //	Person p1 = new Person(); //	p1.eat(); } } abstract class Person{ String name; int age; public Person() { } public Person(String name,int age) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dade30fe6b806378b42457d1d7e885ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07b8d003951e22f12087d40f11287edb/" rel="bookmark">
			InnoDB Cluster详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、InnoDB Cluster简介
1. 整体架构
2. MySQL Shell
3. MySQL Router
4. MySQL服务器集群
二、创建InnoDB Cluster
1. 检查实例配置
2. 配置实例
3. 创建集群
4. 向集群添加实例
5. 查看集群状态
6. 基于已有组复制的集群创建
7. 配置MySQL Router
8. 客户端连接测试
三、使用MySQL Shell管理InnoDB Cluster
1. 配置实例的自动重新加入
2. 从InnoDB Cluster中删除实例
3. 重启群集
4. 解散InnoDB Cluster
5. 配置新主选举权重
6. 配置故障转移一致性
7. 更改组复制拓扑
8. 设置InnoDB Cluster的选项
MySQL作为当今最流行的关系数据库系统，在其高可用特性上也在不断进行着尝试和改进。最初的MySQL版本只提供一种简单的主从异步复制，满足最基本的数据同步。为了提高复制性能，从单线程到组提交再到多线程复制，基本解决了复制延迟问题。为了解决从库与主库的一致性读问题，新增了半同步复制，而为了提供自动故障转移功能，又提供了组复制功能。要做到真正的高可用，失败切换必须对应用透明，于是在组复制的基础上，又发展出了InnoDB Cluster。本文说明InnoDB Cluster的相关概念、安装部署及管理维护。需要指出的一点是，在InnoDB Cluster出现前，实现MySQL数据库的高可用性，除了原生的复制功能，通常还需要借助第三方中间件，如Keepalived、MHA等等。
一、InnoDB Cluster简介 1. 整体架构 InnoDB Cluster主要由MySQL Shell、MySQL Router和MySQL服务器集群组成，三者协同工作，共同为MySQL提供完整的高可用性解决方案。图1所示为InnoDB Cluster的整体架构。
图1 InnoDB Cluster架构 InnoDB Cluster以组复制为基础，集群中的每个MySQL服务器实例都是组复制的成员，提供了在InnoDB Cluster内复制数据的机制，并且具有内置的故障转移功能。MySQL Shell在InnoDB Cluster中充当控制台角色，使用它包含的AdminAPI，可以使安装、配置、管理、维护多个MySQL组复制实例的工作更加轻松。通过AdminAPI的几条交互指令就可自动完成组复制配置。MySQL Router可以根据集群部署信息自动生成配置，将客户端应用程序透明地连接到MySQL服务器实例。如果服务器实例意外故障，群集将自动重新配置。在默认的单主模式下，InnoDB Cluster 具有单个读写主服务器实例。多个辅助服务器实例是主服务器实例的副本。如果主服务器出现故障，则辅助服务器将自动升级为主服务器。MySQL Router可以检测到这种情况并将客户端应用程序自动转发到新的主服务器。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07b8d003951e22f12087d40f11287edb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c16f6f46a410ef38ecec327e2e8ed99/" rel="bookmark">
			centos7安装docker并配置php运行环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装docker 首先我们先来了解一下什么是docker。
docker是一个虚拟化的技术，基于 Linux 内核，是将进程进行封装隔离，由于隔离的进程独立于宿主机和其它的隔离的进程，因此也可以称为容器。很多人把docker理解为虚拟机，其实不是的，因为它不需要进行硬件虚拟以及运行完整操作系统等额外开销的，docker的出现也是为了解决在各种复杂的环境下不需要做任何的修改还可以保证程序正常稳定的运行，也就是环境一致性的问题，当然还有kubernets，简称k8s，是把docker容器的管理和编排做成自动化，下一篇文章中在对k8s进行介绍。
接下来进入正题开始安装docker
1.卸载旧版的docker yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-selinux \ docker-engine-selinux \ docker-engine 2.安装依赖包 yum install -y yum-utils \ device-mapper-persistent-data \ lvm2 3.更换yum源，更换为国内镜像，下载更快 yum-config-manager \ --add-repo \ https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.repo 4.安装docker yum-config-manager --enable docker-ce-nightly #获取夜间通道的存储库 yum makecache fast #更新yum缓存 yum install -y docker-ce #安装docker 5.启动docker，建立docker用户组并将当前用户加入用户组 systemctl start docker groupadd docker #创建用户组 usermod -aG docker $USER #将当前用户加入用户组 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c16f6f46a410ef38ecec327e2e8ed99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdb05c4f8c2e384a06a8e2ceb5fc667b/" rel="bookmark">
			Centos7&#43;Hadoop3.1.2&#43;HBase2.2.0搭建过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		centos7系统安装 光盘驱动外接服务器,服务器开机F12进BISO安装系统,选择any other systyem,其他默认即可,一直点finish,服务器最终重启进入安装程序.
系统安装时，系统盘的分区如下：
/home 50G(51200M) /var 2G(2048M) /boot 1G(1024M) swap 20G(20480M) / 剩下的容量 服务器基础配置 注意:配置之前先熟悉linux基本命令 cd vi cat 1. 网卡bonding 注意:配置之前先熟悉网卡bond的作用 查看 /etc/sysconfig/network-scripts 目录可以看到服务器自带的四个网卡文件
ifcfg-em1,ifcfg-em2,ifcfg-p2p1,ifcfg-p2p2(名字可能有稍微差别),
em为普通网卡,pxpx为光纤网卡.
我们需要使用光纤网卡并且对其做bond0操作
首先编辑 ifcfg-p2p1 文件 修改成:
DEVICE=p2p1 ONBOOT=yes BOOTPROTO=none MASTER=bond0 SLAVE=yes 再编辑ifcfg-p2p2 文件 修改成:
DEVICE=p2p2 ONBOOT=yes BOOTPROTO=none MASTER=bond0 SLAVE=yes 在同目录下创建ifcfg-bond0文件,编辑文件添加内容(这里的IPADDR是bond0的IP地址,根据机器的实际情况修改):
DEVICE=bond0 BOOTPROTO=static TYPE=bond ONBOOT=yes IPADDR=192.168.1.10 NETMASK=255.255.255.0 GATEWAY=192.168.1.254 BONDING_OPTS="mode=0 miimon=100" DNS1=202.118.1.29 DNS2=202.118.1.53 编辑/etc/resolv.conf,修改成如下:
nameserver 202.118.1.29 nameserver 202.118.1.53 执行命令systemctl stop firewalld.service关闭防火墙,执行systemctl disable firewalld.service禁止防火墙开机自启
然后执行下面的命令重启网络
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdb05c4f8c2e384a06a8e2ceb5fc667b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a3441e11832228cec7f474b8101477d/" rel="bookmark">
			git项目的完整迁移
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在本地虚拟机上搞了一套测试环境，并搭建了一个新的gitlab，所以需要把现在开发的代码复制一份到新的gitlab上。
因为是本地自己测试用的，所以我之前碰到这种情况都是这样操作的：
1、在新的gitlab上创建一个project 2、在自己电脑上新建一个目录，并把心gitlab上的项目克隆下来 3、直接把旧git上的代码先克隆到电脑的另一个目录中，并把克隆下来的文件拷贝到之前2步骤的项目中 4、执行git的add、commit、push把代码推送到新的gitlab上 这样的做法，push到新gitlab上的只有一个master分支（包括历史日志），并没有所有的分支和标签等。所以，这种做法是比较low的，需要一个个分支上传，根本没有效率可言，而且还容易出错。
今天要做的是完整的复制（迁移），也就是要包括项目的所有的分支、标签和历史日志。
在开始之前，记得先在gitlab中创建好新的项目。
具体的复制（迁移）命令如下：
git clone --mirror &lt;老仓库的git地址&gt; cd &lt;克隆下来的项目目录&gt; git remote set-url origin &lt;新的git项目的地址&gt; git push -f origin 完成上面的操作之后，就把老Git上的项目完全迁移到了新的gitlab上了，包含了该项目的所有的分支、标签和历史日志，简直完美！
参考文章：https://blog.csdn.net/diyiday/article/details/85247749
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a876e2758ebcbc14143c795d0ddc192e/" rel="bookmark">
			倒排索引的MapReduce实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		倒排索引 参考链接：https://blog.csdn.net/Xw_Classmate/article/details/50639848 “ 倒排索引”是文档检索系统中最常用的数据结构，被广泛地应用于全文搜索引擎。 它主要是用来存储某个单词（或词组） 在一个文档或一组文档中的存储位置的映射，即提 供了一种根据内容来查找文档的方式。由于不是根据文档来确定文档所包含的内容，而是进 行相反的操作，因而称为倒排索引（ Inverted Index）。
1 实例描述 通常情况下，倒排索引由一个单词（或词组）以及相关的文档列表组成，文档列表中的 文档或者是标识文档的 ID 号，或者是指文档所在位置的 URL，如图 6.1-1 所示。
[外链图片转存失败(img-a6OHY0ai-1567902000353)(assets/1566473796048.png)]
从图 6.1-1 可以看出，单词 1 出现在{文档 1，文档 4，文档 13， ……}中，单词 2 出现 在{文档 3，文档 5，文档 15， ……}中，而单词 3 出现在{文档 1，文档 8，文档 20， ……} 中。在实际应用中， 还需要给每个文档添加一个权值，用来指出每个文档与搜索内容的相 关度，如图 6.1-2 所示。
最常用的是使用词频作为权重，即记录单词在文档中出现的次数。以英文为例，如图 6.1-3 所示，索引文件中的“ MapReduce”一行表示：“ MapReduce”这个单词在文本 T0 中 出现过 1 次，T1 中出现过 1 次，T2 中出现过 2 次。当搜索条件为“ MapReduce”、“ is”、“ Simple” 时，对应的集合为： {T0， T1， T2}∩{T0， T1}∩{T0， T1}={T0， T1}，即文档 T0 和 T1 包 含了所要索引的单词，而且只有 T0 是连续的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a876e2758ebcbc14143c795d0ddc192e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0faf3d4127b690110dde19a72676437/" rel="bookmark">
			MVC框架&#43;vue&#43;elementUI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用自动化构建做的vue项目，因为是动态加载数据，在SEO优化时一直不如意，于是我们换了框架，用MVC框架，做成静态页面，但是原来的代码都是用vue和elementUI，为了快速的复用原来的代码，于是在项目中引入了引入vue.js和elementUI。
需要引入的：
@Styles.Render("~/Content/elementUI/index.css")//element ui 的样式
@Styles.Render("~/Content/base.css") //自己写的css
@Styles.Render("~/Content/usercenter.css") //自己写的css
@Scripts.Render("~/Content/vue/vue.js") //vue.js
@Scripts.Render("~/Content/elementUI/index.js")//element ui 的js
@Scripts.Render("~/Content/js/jquery.js")//引入jquery
转载于:https://www.cnblogs.com/colorful-paopao1/p/11506986.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d225e93da6562ff5885fbc96a3c14328/" rel="bookmark">
			求助：Tushare get_k_data获取的复权数据是否有问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近做量化分析的时候发现，使用Tushare get_k_data方法，部分股票最近一次的前复权数据似乎不对，例如以爱尔眼科为例 300015
df_stock.set_index(‘date’,inplace=True)
df_stock=ts.get_k_data(‘300015’)
print(‘stock_1’,df_stock.loc[‘2018-05-22’:‘2018-05-25’]) ## 2018年中期分红送股后前复权数据
print(‘stock_2’,df_stock.loc[‘2019-06-03’:‘2019-06-06’]) ## 2019年中期分红送股后前复权数据
结果如下：
stock_1 open close high low volume code
date
2018-05-22 32.236 33.236 33.249 32.024 90030.0 300015
2018-05-23 33.130 32.792 33.859 32.255 121327.0 300015
2018-05-24 32.790 33.300 33.630 32.190 161699.0 300015
2018-05-25 33.300 33.500 34.070 32.710 134980.0 300015
stock_2 open close high low volume code
date
2019-06-03 38.30 37.46 38.38 37.12 140623.0 300015
2019-06-04 37.43 37.30 37.87 36.88 84413.0 300015
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d225e93da6562ff5885fbc96a3c14328/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf1d5e251f5a8410933cb8853873716c/" rel="bookmark">
			tensorflow学习笔记（3）: 使用load_modeld载入的keras模型是随机的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ● 问题描述：
在一个二分类任务上，我训练好的keras模型的准确率是0.9。但是，当我用tf.keras.models.load_modeld重新加载该模型后，它的准确率却变成了0.5（显然是因为网络的参数变成随机值了）。
● 问题原因：
导致该问题的原因是，我的模型用到了自建的keras layer，但是我的自建layer写错了。错误点是，我在自建layer里调用了其它layer。该错误会导致用load_modeld重载权重时，其它layer的权重不会被载入，而会被随机初始化。(详细原因可查阅tf.keras.models.load_modeld的源码)
● 解决方法：
自建层里需要保存的参数，都需要使用add_weight来注册。
● 举例说明：
下面通过一个例子，来进一步说明该错误以及其解决方法。
错误写法：
下面这段代码自建了一个keras layer，实现的是dense layer的功能。这个错误例子里，我是通过调用keras的Dense来实现该功能的。
import tensorflow as tf class MyLayer(tf.keras.layers.Layer): def __init__(self,**config): super(MyLayer, self).__init__(config) def build(self,input_shape): self.detector_layer_dense = tf.keras.layers.Dense(20, activation='sigmoid') super(MyLayer,self).build(input_shape) def call(self,input): output = self.detector_layer_dense_1(merged_feature_of_each_steps) return output 正确写法：
首先要build()函数中用add_weight创建一个dense kernel，然后在call()函数中用矩阵相乘实现dense layer.
import tensorflow as tf class MyLayer(tf.keras.layers.Layer): def __init__(self,**config): super(MyLayer, self).__init__(config) def build(self,input_shape): self.dense_kernel = add_weight(shape=[20,1],name='kernel') super(MyLayer,self).build(input_shape) def call(self,input): output = tf.matmul(input,self.dense_kernel) return output 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d9c9162dc2af61c25715529bbee867c/" rel="bookmark">
			hybird (混合开发 - 视频详解) - 王云飞 - 小四
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景介绍 移动端占大部分流量，已经远远超过PC端一线互联网公司都有自己的APP这些APP中有很大比例的前端代码 不要指望一个APP都是客户端开发，有很大一部分是JS、HTML、css前端的语言 那微信举例，你每天浏览微信的内容，多少是前端 移动应用分类： 原生应用
使用某一个移动平台所特有的语言
HTML5应用
使用标准的web技术
优势：跨平台
劣势：访问原生设备功能
混合应用
即使用了移动原生语言，又使用了web技术
使用技术 苹果手机
IOS系统，由swift和C++/object-c语言编写，后缀名为ipa
安卓手机
安卓系统，由Java + 安卓语言编写，后缀为apk
wp手机
windowphone系统
由C#语言编写，后缀分为两类（wp7 wp8的是xap，wp8.1以后用8.1的SDK开发后缀为appx）
混合开发
原生语言 + JS
因为JS无法调用系统的原生功能，拍照、短信、打电话、通讯录等，但是原生（IOS、Android、wp）可以。原生有很大的适配问题（特别是Android），JS可以很好的解决这个问题。
术语 hybird
JS + 安卓/IOSwebAPP
m站、手机网站nativeapp
纯IOS/android 题目 hyBird是什么？为什么用？介绍一下hybird更新和上线的流程hybird和h5的区别前端JS和客户端如何通讯 知识点 概念 hybird既混合，即前端和客户端的混合开发混合动力的汽车 需前端开发人员和客户端开发人员配合完成某些环节也可能涉及到server端PS：不要以为自己是前端就可以不理会客户端的知识，同样也不要不理会server端知识，现在是大前端的时代 存在价值 可以快速迭代更新【关键】，（无需app审核）客户端都需要应用市场审核，安卓的还好审核周期可能是一两天，苹果的就会很慢， 你不可能一天一更新迭代，小步快跑的时代，审核时间耗不起的。 APP需要审核是因为安卓的Java代码，IOS的swift，这些代码或开发环境都有权利访问 到手机的一些比较安全比较隐私的一些东西或者是一些比较深层次的API， 比如获取地理位置、相机等，用这些功能开发出来的APP肯定需要审核，你有这么高的权限 我如果不审核你，如何保证用户的合法权益。 hybird是纯前端代码，没有那么高的权限，所以无需审核 体验更流畅（和NA的体验基本类似，不抠细节）减少开发和沟通成本，双端共用一套代码 webview 浏览器的内核，可以承载一个HTML页面并且显示出来是APP中的一个组件（APP中可以有，也可以没有）webview是一个统称，每个APP中可能叫法不同浏览器中的webview
微信中的webview
file协议 其实一开始接触HTML开发，就已经使用了file协议只不过你当时没有“协议”、“标准”这些概念 HTTP(s)和file协议的区别 file协议：本地文件、快
http(s)：网络加载、慢
hybird不能用http协议只能用file协议，太慢受不了，要快，要做到和NA一样的体验， 要极致的快要变态的快 使用场景 不是所有的场景都适合使用hybird使用NA：体验要求极致，变化不频繁（头条首页）使用hybird：体验要求高，变化频繁（头条详情）使用h5：体验无要求，不常用的（举报、反馈） 具体实现 前端做好静态页面，将文件交给客户端客户端拿到前端静态页面，以文件形式存储在APP中客户端在一个webview中使用file协议加载静态页面
hybird和h5的区别 优点 体验更好，和NA差不多无需审核，迭代快 缺点 开发成本高，联调、测试、查bug都比较麻烦运维成本高，（更新上线流程） 适用场景 hybird - 适合产品型 产品的稳定功能，体验要求高，迭代频繁 h5 - 适合运营型 单次的运营活动（如，红包）或不常用功能 webview组件介绍 webview组件是我们原生开发中最核心的组件，可以理解为一个轻量级的浏览器。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d9c9162dc2af61c25715529bbee867c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa4c0c63f5822cebd8c06d319f1526cc/" rel="bookmark">
			前端工程化实践总结 | QQ音乐商业化Web团队
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		蓝字关注，回复“加群”加入前端技术群 与大家一起成长
| 导语 本文主要介绍在前端工程化的一些探索和实践，结合移动端的基础库重构和UI组件库开发这两个项目详细介绍工程化方案 。 随着业务的不断扩展，团队的项目越来越多，面对日益复杂的业务场景和代码逻辑，我们发现在前端工程化方面团队还有很多需要优化的地方。现有的解决方案已经无法满足各种复杂的场景，我们每天都在疲于应付很多重复的工作，为此我们基于移动端基础库重构和UI组件库的建设这两个项目对团队的项目构建流程进行了详细的分析和梳理，并制定了一套适用于团队的工程化方案。
浅谈前端工程化 前端工程化是一个非常广泛的议题，包含的技术和解决方案也是非常丰富的。一个前端工程的生命周期可以大致划分为这四个过程：
前端工程的生命周期
任何在这四个过程中应用的系统化、严格约束、可量化的方法都可以称之为工程化。工程化的程度越高，在工作中因人的个体差异性导致的缺陷或者短板就会越少，项目质量可以得到更有效的保障。对上面四个过程的工程化并不是完全分隔的，而是相辅相成，比如开发阶段的优化也会对测试、部署和维护产生很大的影响。
下面从模块化、组件化、规范化和自动化这四个方面进行具体介绍。
模块化
模块化可以对复杂逻辑进行有效分割，每个模块更关注自身的功能，模块内部的数据和实现是私有的，通过向外部暴露一些接口来实现各模块间的通信。开发阶段前端需要关注JS、CSS和HTML，下面我们将分别对JS、CSS、HTML的模块化进行简单介绍。
1. JS模块化 JS模块化是一个逐渐演变的过程，开始的namespace概念实现了简单对象封装，约定私有属性使用_开头，到后来的IIFE模式，利用匿名函数闭包的原理解决模块的隔离与引用，下面介绍现在比较流行的几种模块化标准。
2. CommonJS Nodejs中的模块化方案，就是基于CommonJS规范实现的。一个文件就是一个模块，有自己的作用域，没有export的变量和方法都是私有的，不会污染全局作用域，模块的加载是运行时同步加载的。CommonJS可以细分为CommonJS1和CommonJS2，二者的模块导出方式不同，CommonJS2兼容CommonJS1，增加了module.exports的导出方式，现在一般所指的都是CommonJS2。
每个文件一个模块，有自己的作用域，不会污染全局；
使用require同步加载依赖的其他模块，通过module.exports导出需要暴露的接口；
多次require的同一模块只会在第一次加载时运行，并将运行结果缓存，后续直接读取缓存结果，如果需要重新执行，需要先清理缓存；
Nodejs环境下可以直接运行，各个模块按引入顺序依次执行。
AMD 浏览器加载js文件需要进行网络请求，而网络请求的耗时是不可预期的，这使得CommonJS同步加载模块的机制在浏览器端并不适用，我们不能因为要加载某个模块js而一直阻塞浏览器继续执行下面的代码。AMD规范则采用异步的方式加载模块，允许指定回调函数，这非常适合用于浏览器端的模块化场景。
使用define定义一个模块，使用require加载模块；
异步加载，可以并行请求依赖模块；
原生JavaScript运行环境无法直接执行AMD规范的模块代码，需要引入第三方库支持，如requirejs等；
CMD 类似于AMD规范，是应用在浏览器端的JS模块化方案，由sea.js提出，详见 https://www.zhihu.com/question/20351507 。
UMD UMD规范兼容AMD和CommonJS，在浏览器和Nodejs中均可以运行。
ES6 Module ES6从语言标准的层面上实现了模块化，是ECMA提出的模块化标准，后续浏览器和Nodejs都宣布会原生支持，越来越受开发者青睐。
使用import引入模块，export导出模块；
与CommonJS的执行时机不同，只是个只读引用，只会在真正调用的地方开始执行，而不是像CommonJS那样，在require的时候就会执行代码；
支持度暂不完善，需要进行代码转换成上面介绍的某一种模块化规范。
在浏览器中可以通过下面的方式引入es6规范的模块js：
defer和async不同，它会阻塞DomContentLoaded事件，每个模块js会根据引入的顺序依次执行。
随着更多浏览器对ES6的支持，现在有一些方案开始提出直接使用ES2015+的代码在浏览器中直接执行来提高运行效果，这篇文章《Deploying ES2015+ Code in Production Today》中有详细的介绍，可以结合这份性能测试报告综合评估ES6在node以及各种浏览器环境下的执行效率对比。
3. CSS模块化 CSS 自诞生以来，基本语法和核心机制一直没有本质上的变化，它的发展几乎全是表现力层面上的提升。不同于JS，CSS本身不具有高级编程属性，无法使用变量、运算、函数等，无法管理依赖，全局作用域使得在编写CSS样式的时候需要更多人工去处理优先级的问题，样式名还有压缩极限的问题，为此，出现了很多“编译工具”和“开发方案”为CSS赋予“编程能力”。
预处理器 随着页面越来越复杂，为了便于开发和维护，我们常常会将CSS文件进行切分，然后再将需要的文件进行合并。诸如LESS、SASS、Stylus等预处理器为CSS带来了编程能力，我们可以使用变量、运算、函数，@import指令可以轻松合并文件。但各种预处理器并不能完全解决全局作用域的问题，需要结合namespace的思想去命名。
OOCSS &amp; SMACSS OOCSS和SMACSS都是有关css的方法论。OOCSS(Object Oriented CSS)即面向对象的CSS，旨在编写高可复用、低耦合和高扩展的CSS代码，有两个主要原则，它们都是用来规定应该把什么属性定义在什么样式类中。
Separate structure and skin（分离结构和主题）
Separate container and content（分离容器和内容）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa4c0c63f5822cebd8c06d319f1526cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bda4ed6a15363dc0e458546f49d9f24b/" rel="bookmark">
			mybatis中CDATA的作用是什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		例子：
&lt;if test="beginTime != null"&gt;
&lt;![CDATA[ AND book_time &gt;= FROM_UNIXTIME(#{beginTime}) ]]&gt;
&lt;/if&gt;
在使用mybatis 时我们sql是写在xml 映射文件中，如果写的sql中有一些特殊的字符的话，在解析xml文件的时候会被转义，但我们不希望他被转义，所以我们要使用&lt;![CDATA[ ]]&gt;来解决。
&lt;![CDATA[ ]]&gt; 是什么，这是XML语法。在CDATA内部的所有内容都会被解析器忽略。
如果文本包含了很多的"&lt;"字符 &lt;=和"&amp;"字符——就象程序代码一样，那么最好把他们都放到CDATA部件中。
但是有个问题那就是 &lt;if test=""&gt; &lt;/if&gt; &lt;where&gt; &lt;/where&gt; &lt;choose&gt; &lt;/choose&gt; &lt;trim&gt; &lt;/trim&gt; 等这些标签都不会被解析，所以我们只把有特殊字符的语句放在 &lt;![CDATA[ ]]&gt; 尽量缩小 &lt;![CDATA[ ]]&gt; 的范围。
实例如下：
&lt;select id="allUserInfo" parameterType="java.util.HashMap" resultMap="userInfo1"&gt;
&lt;![CDATA[
SELECT newsEdit,newsId, newstitle FROM shoppingGuide WHERE 1=1 AND newsday &gt; #{startTime} AND newsday &lt;= #{endTime}
]]&gt;
&lt;if test="etidName!=''"&gt;
AND newsEdit=#{etidName}
&lt;/if&gt;
&lt;/select&gt;
因为这里有 "&gt;" "&lt;=" 特殊字符所以要使用 &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bda4ed6a15363dc0e458546f49d9f24b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10957076d78c63b4dd27d472d0fa8789/" rel="bookmark">
			pytorch计算余弦相似度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在pytorch中，可以使用torch.cosine_similarity函数对两个向量或者张量计算余弦相似度。先看一下pytorch源码对该函数的定义：
class CosineSimilarity(Module): r"""Returns cosine similarity between :math:`x_1` and :math:`x_2`, computed along dim. .. math :: \text{similarity} = \dfrac{x_1 \cdot x_2}{\max(\Vert x_1 \Vert _2 \cdot \Vert x_2 \Vert _2, \epsilon)}. Args: dim (int, optional): Dimension where cosine similarity is computed. Default: 1 eps (float, optional): Small value to avoid division by zero. Default: 1e-8 Shape: - Input1: :math:`(\ast_1, D, \ast_2)` where D is at position `dim` - Input2: :math:`(\ast_1, D, \ast_2)`, same shape as the Input1 - Output: :math:`(\ast_1, \ast_2)` Examples:: &gt;&gt;&gt; input1 = torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10957076d78c63b4dd27d472d0fa8789/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/259/">«</a>
	<span class="pagination__item pagination__item--current">260/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/261/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>