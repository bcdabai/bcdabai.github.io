<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3e0efdb2e1e7517caa0ecf49c870358/" rel="bookmark">
			浏览器使用Notification桌面通知消息推送
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是 Notification？ Notification 是浏览器最小化后在桌面显示消息的一种方法类似于 360 等流氓软件在桌面右下角的弹窗广告它与浏览器是脱离的，消息是置顶的 一、弹窗授权 授权当前页面允许通知可以通过检查只读属性 Notification.permission 的值来查看你是否已经有权限default： 用户还未被询问是否授权，可以通过 Notification.requestPermission() 可以询问用户是否允许通知granted： 用户点击允许后的状态denied： 用户点击拒绝后的状态，通知框不可用 Notification.requestPermission() 二、弹窗使用 可以通过 new Notification($title, $options) 使用通知推送功能title： 一定会被显示的通知标题options： 可选，一个被允许用来设置通知的对象。它包含以下属性：dir： 文字的方向；它的值可以是 auto（自动）, ltr（从左到右）, or rtl（从右到左）lang： 指定通知中所使用的语言。body： 通知中额外显示的字符串tag： 赋予通知一个ID，以便在必要的时候对通知进行刷新、替换或移除。icon： 一个图片的URL，将被用于显示通知的图标。 new Notification("温馨提醒", { body: "木芒果", icon: "https://profile-avatar.csdnimg.cn/238b721d51d44069986d5004489dcbd3_m0_63823719.jpg!1", data: "https://blog.csdn.net/m0_63823719/" }); 三、浏览器支持检测 使用通知推送功能前，需要先检查浏览器是否支持可以通过 "Notification" in window 方法去检测在浏览器支持的前提下，判断用户是否授权允许通知，如果还未授权，可以弹出授权框如果用户已经拒绝过，我们就不去打扰用户了 function notify() { // 先检查浏览器是否支持 if (!("Notification" in window)) { alert("This browser does not support desktop notification"); } // 检查用户是否同意接受通知 else if (Notification.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3e0efdb2e1e7517caa0ecf49c870358/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bf618c80a3a41c166bb883e5ff0ed36/" rel="bookmark">
			【OpenVI—论文解读系列】ICLR 2023 | 达摩院开源轻量人脸检测DamoFD
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、背景 1. 人脸检测问题定义 人脸检测算法是在一幅图片或者视频序列中检测出来人脸的位置，给出人脸的具体坐标，一般是矩形坐标，它是人脸关键点、属性、编辑、风格化、识别等模块的基础。学术界用来衡量人脸检测器性能的benchmark是[WiderFace](WIDER FACE: A Face Detection Benchmark)，该数据集主要明确了人脸检测器面对的一些挑战，包括scale，pose，occlusion等。本文的研究问题是如何自动搜索轻量级人脸检测器的backbone？
完整内容请点击下方链接查看： 【OpenVI—论文解读系列】ICLR 2023 | 达摩院开源轻量人脸检测DamoFD-阿里云开发者社区
版权声明：本文内容由阿里云实名注册用户自发贡献，版权归原作者所有，阿里云开发者社区不拥有其著作权，亦不承担相应法律责任。具体规则请查看《 阿里云开发者社区用户服务协议》和《 阿里云开发者社区知识产权保护指引》。如果您发现本社区中有涉嫌抄袭的内容，填写 侵权投诉表单进行举报，一经查实，本社区将立刻删除涉嫌侵权内容 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fed603a3c68c4af9596d7f4f63a44a90/" rel="bookmark">
			手机能远程控制手机吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可以，手机可以远程控制另一部手机。但是，需要注意的是，要实现手机远程控制手机，需要下载并安装相应的软件，如AirDroid、向日葵、TeamViewer等。
其中，AirDroid是一款比较流行的远程控制软件，它可以在不同操作系统之间进行远程控制，包括iOS、Android和Windows等。使用AirDroid可以实现远程控制、文件传输、远程拍照等功能。
向日葵是一款全中文操作界面的远程控制软件，它可以在不同操作系统之间进行远程控制，包括iOS、Android和Windows等。使用向日葵可以实现远程控制、文件传输、远程拍照等功能。
TeamViewer是一款比较知名的远程控制软件，它可以在不同操作系统之间进行远程控制，包括iOS、Android和Windows等。使用TeamViewer可以实现远程控制、文件传输、远程拍照等功能。
需要注意的是，使用远程控制软件时，需要确保两台手机都下载了相同的软件，并且两台手机都需要联网。同时，在进行远程控制时，需要确保被控制手机的权限设置允许远程控制，否则可能无法实现远程控制。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30fce8dba290a578ca64aadb780388e4/" rel="bookmark">
			Win10子系统Ubuntu的WSL2开启、图形界面安装以及CUDA配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Win10开启Linux子系统操作步骤1.启用适用于 Linux 的 Windows 子系统2.检查运行 WSL 2 的要求3.启用虚拟机功能4.下载 Linux 内核更新包5.将 WSL 2 设置为默认版本6.安装所选的 Linux 分发 此步所遇到的问题 二、将子系统迁移到非系统盘操作步骤此步所遇到的问题 三、为子系统添加图形化界面安装步骤此步所遇到的问题 四、子系统CUDA安装操作步骤1. 在Win10上安装支持WSL的显卡驱动2. 切换镜像源3. 安装CUDA4. 配置环境变量 此步遇到的问题 一、Win10开启Linux子系统 具体流程可查看适用于 Linux 的 Windows 子系统安装指南 (Windows 10)
操作步骤 1.启用适用于 Linux 的 Windows 子系统 需要先启用“适用于 Linux 的 Windows 子系统”可选功能，然后才能在 Windows 上安装 Linux 分发。
以管理员身份打开 PowerShell 并运行：
dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart 2.检查运行 WSL 2 的要求 对于 x64 系统：版本 1903 或更高版本，采用 内部版本 18362 或更高版本。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30fce8dba290a578ca64aadb780388e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8811f4e06b14c6e0b66d24fafca90da1/" rel="bookmark">
			SQL高级教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQL TOP 子句 TOP 子句 TOP 子句用于规定要返回的记录的数目。
对于拥有数千条记录的大型表来说，TOP 子句是非常有用的。
注释：并非所有的数据库系统都支持 TOP 子句。
SQL Server 的语法： SELECT TOP number|percent column_name(s) FROM table_name MySQL 和 Oracle 中的 SQL SELECT TOP 是等价的 MySQL 语法 SELECT column_name(s) FROM table_name LIMIT number 例子 SELECT * FROM Persons LIMIT 5 Oracle 语法 SELECT column_name(s) FROM table_name WHERE ROWNUM &lt;= number 例子 SELECT * FROM Persons WHERE ROWNUM &lt;= 5 原始的表 (用在例子中的)： Persons 表:
SQL TOP 实例 现在，我们希望从上面的 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8811f4e06b14c6e0b66d24fafca90da1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbb2338f891f6c0c588a02cea4069722/" rel="bookmark">
			SpringBoot使用Swagger配置API接口文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💧 概述 Swagger是一个用于设计、构建和文档化 RESTful API 的开源框架。它提供了一组工具，使得开发人员能够更轻松地定义、描述和测试API接口。
具体来说，Swagger包含以下几个核心组件：
Swagger规范（Swagger Specification）: 定义了一种格式化的API规范，使用YAML或JSON格式，用于描述API的各种细节，包括路由、参数、返回值等。
Swagger编辑器（Swagger Editor）: 提供了一个交互式的编辑界面，让开发人员能够方便地编写和验证Swagger规范文件。
Swagger UI: 一个动态生成的HTML文件，可以将Swagger规范文件渲染成一个美观易用的API文档网页。通过Swagger UI，开发人员可以直观地查看API接口的详细信息，包括请求示例、响应模型和参数说明。
Swagger Codegen: 一个自动生成API客户端代码的工具，根据Swagger规范文件，它可以生成多种编程语言的代码框架，帮助开发人员快速集成和调用API接口。
利用Swagger，开发团队可以在项目早期就定义和设计好API接口，并且在整个开发过程中保持与API文档的同步更新。这样做的好处包括：
方便的API文档自动生成和维护。更好的API可读性和可测试性。简化与前端开发团队或第三方开发者之间的协作。提高API的可靠性和版本管理能力。 总的来说，Swagger是一个强大的工具，可以帮助开发人员更好地构建、测试和文档化RESTful API，并提供了一系列的工具和库，支持在不同的编程语言和框架中使用。
💧 与 spring boot整合 🌀 引入依赖 &lt;!-- 引入 Swagger 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- swagger2-UI --&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; 🌀 添加配置 自定义Swagger配置文件：SwaggerConfig
import java.util.ArrayList; import java.util.List; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Value; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import io.swagger.annotations.ApiOperation; import springfox.documentation.builders.ApiInfoBuilder; import springfox.documentation.builders.PathSelectors; import springfox.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbb2338f891f6c0c588a02cea4069722/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d7070458d3e22d42130af3eb9cbc0ab/" rel="bookmark">
			【报错ipmitool】Could not open device at /dev/ipmi0 or /dev/ipmi/0 or /dev/ipmidev/0: No such file or di
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错详情 Could not open device at /dev/ipmi0 or /dev/ipmi/0 or /dev/ipmidev/0: No such file or directory
原因分析 没有主板没有配置IPMI 验证：
dmidecode |grep -i ipmi 输出为空，说明没有IPMI，别试了，没用的；
预期输出：
dmidecode |grep -iA6 ipmi IPMI Device Information Interface Type: KCS (Keyboard Control Style) Specification Version: 2.0 I2C Slave Address: 0x00 NV Storage Device: Not Present Base Address: 0x0000000000000000 (Memory-mapped) Register Spacing: Successive Byte Boundaries IPMI Device Information Interface Type: KCS (Keyboard Control Style) Specification Version: 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d7070458d3e22d42130af3eb9cbc0ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df437aa5fc06fd77df520d3e57e4de45/" rel="bookmark">
			L3级标准出台在即，自动驾驶商业化迎来“奇点”时刻
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自动驾驶规模化商业应用迎来“奇点”时刻。
6月21日，工信部在国务院政策例行吹风会上透露，将启动智能网联汽车准入与上路通行试点，组织开展城市级“车路云一体化”示范应用，支持有条件的自动驾驶。同时，将坚持“车-能-路-云”融合发展，并重点开展以下工作：
一是支持关键技术攻关，要加快关键芯片、高精度传感器、操作系统等新技术新产品的研发和推广应用，进一步提升产业发展内生动力。
二是进一步完善网联基础设施。加快C-V2X、路侧感知、边缘计算等基础设施建设，建立基于边缘云、区域云和中心云三级架构的云控基础平台，形成统一的接口、数据和通信标准，进一步提升网络感知、云端计算能力。
三是深化测试示范应用，启动智能网联汽车准入和上路通行试点，组织开展城市级“车路云一体化”示范应用。支持有条件的自动驾驶，包括L3级及更高级别的自动驾驶功能商业化应用。
工信部关于L3级自动驾驶的明确表态，从政策层面为自动驾驶行业发展注入了一针强心剂，也从侧面印证了L3以及更高级别的自动驾驶已基本具备大规模商业化应用条件。
自动驾驶商业化迈出关键一步 除本月提及L3级自动驾驶外，工信部还曾在5月中旬透露《智能网联汽车标准体系指南》将正式发布，其中就包括支持L3级以上自动驾驶功能的商业化应用。
政策层面的积极引导为自动驾驶行业的后续发展扫清了障碍，L3级自动驾驶商业化运营进入快速落地阶段。
地方政府层面，已有多地开始推动L3级自动驾驶技术落地相关配套基础设施建设。例如，深圳市正加快推进深圳智能网联交通测试示范区、全域路口网联化改造等基础设施建设，其中环境园封闭测试区可支撑智能网联汽车L3级、L4 级产品准入测试。
而据高工智能汽车统计数据显示，2023年1-3月，乘用车行业L2级及以上渗透率已达33.4%，同比提升9个百分点；新势力品牌L2级及以上渗透率在70%以上，头部自主品牌L2级及以上渗透率在30%以上。
多方面显示，L3级自动驾驶已进入加速落地量产阶段，从L2跃升至 L3，趋势已不可抵挡。
机遇与挑战并存 在自动驾驶技术等级划分体系里，L2至L3级的跨越带来的变革是根本性的。
L3级被视为自动驾驶能力的“分水岭”，相较于仅起辅助作用仍需人类驾驶的L2级，从L3级开始，驾驶操作和周边监控均由系统自动完成，驾驶员只需在紧急状态下做好接管处理即可，这标志着驾驶权从人正式移交到自动驾驶系统。
而这也意味对自动驾驶能力，尤其是自动驾驶车辆的行车安全性提出了更为苛刻的要求。
自动驾驶系统由感知、决策与执行三大模块构成，其中感知系统相当于人类的眼睛，是车辆了解行车环境的重要媒介，对行车安全起决定性作用。
当下两种主流视觉感知路径，无论是毫米波雷达+摄像头解决方案，还是高精地图+激光雷达解决方案，感知算法的训练与调优均离不开大规模路测数据。
而随着感知技术与计算平台的逐渐成熟与趋同，影响高阶自动驾驶落地的关键因素不再是解决一般常见案例，而是解决“路口”问题，也即各类不常见但不断出现的“长尾问题”。
尤其在L3级自动驾驶场景下，车辆的行使控制权完全交由自动驾驶系统，对行车环境的感知也完全依赖于车辆自身的感知系统，这要求自动驾驶系统具备更深的场景积累度，也即数据积累量，这对数据处理规模与数据产出质量同样提出了更高的要求。
专注自动驾驶数据标注 通常情况下，自动驾驶相关数据来源有两种方式，一种是自动驾驶企业使用特制数据采集车上路采集，另一种则是使用实际运营车辆，如私家车进行数据采集。
随着自动驾驶技术的逐渐发展尤其是L2向L3级的迈进，自动驾驶应用所需的数据场景愈发复杂，数据量也呈指数级快速增长。现阶段，常见的数据类型包括激光雷达3D点云数据、摄像头采集的2D图像数据等，其中3D激光雷达点云数据所占比例愈发高涨。
采集得到的数据均为原始数据，原始数据未经处理，自动驾驶相关算法无法直接进行使用。这些数据需要进行前道加工与生产处理，如框定或根据需求打上各类标签，包含高度、宽度、方向等各类信息，才会被投喂到后续的算法训练与调优中，上述数据处理的过程即是数据标注。
在自动驾驶技术从L2级迈向L3级的大时代背景下，数据在自动驾驶产业中扮演的角色愈发突出与重要。以数据标注为基础的数据服务已成为自动驾驶技术的核心竞争点，对技术迭代起决定性作用。唯有提高数据迭代速度、降低迭代成本，才能持续取得胜利，真实数据规模已然成为智能驾驶行业的“命脉”。
作为行业领先的数据服务企业，曼孚科技长期聚焦自动驾驶行业，并对自动驾驶数据标注拥有自己的理解。
L3级自动驾驶将实现由人驾驶到系统驾驶的根本性变革，相应的数据处理难度与数据需求体量均与过往不同而语，这对平台产品的技术能力以及运营体系提出了更高的要求。
以3D点云标注场景为例，随着雷达线束与雷达数量的不断增多，点云数据文件中的点密度也在逐渐增加，从早期的单帧几万点逐渐变成数十万点，尤其随着点云配准技术的出现，4D点云标注需求逐渐兴起，点云叠帧加持下，单帧所包含的点云点数量可达数千万甚至上亿，这给平台的前端点云渲染以及承载能力带来了极大的压力。
L2到L3的跃升对自动驾驶行业本身而言是一场大变革，对上下游产业链而言同样也是一场大变革，产品技术能力将在这一阶段竞争中起决定性关键作用。
作为国内最早明确聚焦自动驾驶数据标注赛道的平台，曼孚科技始终坚持以产品作为核心竞争力。目前旗下MindFlow SEED数据服务平台已在数据处理尤其是3D点云数据处理领域，建立起6-12个月的技术壁垒。
现阶段平台已可支持百万级至千万级点密度的3D点云标注任务，Web前端可直接承载如此庞大的数据量并进行实时渲染。在具体应用场景上，平台还提供全封闭测试、半封闭港口、高速公路、城市道路、智能座舱场景下的车辆行人、车道线、泊车、车路协同、点云融合、点云连续帧、点云语义分割等100+各类2D、3D数据标注类别，全面覆盖自动驾驶各细分场景。
伴随着自动驾驶L3级相关标准的即将出台，以及后续可以预见的大规模商业化应用的开启，数据需求量与数据场景需求维度均会出现较大幅度增长。自动驾驶数据标注行业“指数型增长的数据需求与线性增长的产能供给”之间的矛盾会进一步加深。
曼孚科技期待在自动驾驶商业化“奇点”即将来临之际，能以更高水平的平台产品以及数据量产服务，持续为自动驾驶应用落地提供更多助力。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44340529afba8b8527894ef62d398d96/" rel="bookmark">
			Mybatis-Plus不能更新对象字段为空值问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： 在使用Mybatis-Plus调用updateById方法进行数据更新默认情况下是不能更新空值字段的，而在实际开发过程中，往往会遇到需要将字段值更新为空值的情况，该如何解决呢？
原因分析： Mybatis-Plus中字段的更新策略是通过FieldStrategy属性控制的。在实体字段上，如果不通过@TableField注解指定字段的更新策略，字段默认的更新策略是FieldStrategy.DEFAULT,即跟随全局策略。而Mybatis-Plus的全局配置中，字段的默认更新策略是FieldStrategy.NOT_NULL，即进行空值判断，不对NULL值数据进行处理。
public DbConfig() { this.idType = IdType.ASSIGN_ID; this.tableUnderline = true; this.capitalMode = false; this.logicDeleteValue = "1"; this.logicNotDeleteValue = "0"; this.insertStrategy = FieldStrategy.NOT_NULL; this.updateStrategy = FieldStrategy.NOT_NULL; this.whereStrategy = FieldStrategy.NOT_NULL; } 解决方案： 1、设置字段级别的更新策略IGNORED 如果只需要实体中的几个字段支持空值更新，则通过@TableField注解指定字段的更新策略为FieldStrategy.IGNORED，忽略空值判断，直接更新即可。
该方式的控制级别是字段级别的控制。
示例：
@TableName(value ="user") @Data public class User implements Serializable { @TableId(value = "id",type = IdType.ASSIGN_ID) private Long id; private String name; private Integer age; @TableField(updateStrategy = FieldStrategy.IGNORED) private String email; } 2、设置全局更新策略IGNORED 如果需要全局所有实体的更新操作都需要支持空值更新，可以修改Mybatis-Plus的全局更新策略。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44340529afba8b8527894ef62d398d96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/725f8a87cc4c0a3ac955b18e26992642/" rel="bookmark">
			unity下多层随机迷宫构建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		using System.Collections; using System.Collections.Generic; using UnityEngine; public class Maze : MonoBehaviour { public GameObject[] wallPrefab; // 墙壁预制体 public GameObject[] pathPrefab; // 路径预制体 public GameObject stairsPrefab; // 梯子预制体 public GameObject treePrefab; // 树预制体 public int mazeWidth = 10; // 迷宫宽度 public int mazeHeight = 10; // 迷宫高度 public int mazeLayer = 3; // 迷宫层 public int layerHeight = 14; // 层高度 public int mazeStairsMax = 5; // 迷宫高度 public float cellSize = 10f; // 单元格大小 private int[][][] maze; // 迷宫二维数组 private void Start() { maze = new int[mazeLayer][][]; for (int l = 0; l &lt; mazeLayer; l++) { maze[l] = creatMap(mazeWidth, mazeHeight); } AddStairs(); for (int l = 0; l &lt; mazeLayer; l++) { GameObject la = new GameObject("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/725f8a87cc4c0a3ac955b18e26992642/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6fe64e366fd9f771b0c65dcc5c00570/" rel="bookmark">
			【独立帧、首帧、连续帧、流控桢】4种CAN报文类型分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Can帧种类
根据ISO-TP中的描述，Can帧主要分四类：单帧(Singal frame, SF)，首帧(First frame, FF)， 连续帧(Consecutive frame, CF)， 流控帧(Flow control frame, FC)；
单帧：值为0，其长度可为8个字节(value值占1个字节 + 7个表示正常地址字节，一般我们遇到主要就是类型的)或7个字节(value值占1个字节 + 6个扩展地址字节)；
首帧：其值为1， 用于长的、已被分割的多帧消息包中。首帧包括整个包的数据长度，以及数据初始值；
连续帧：其值为2，包含多帧消息包后续子序列的数据帧；
流控帧：其值为3， 是由接收方在确认收到首帧(FF)后发起的响应。其约定了后续连接帧(CF)的传输参数；
2. 传输层协议控制信息(N_PCI)字段图
2.1 SequenceNumber(SN)的取值
其取值范围为：0~F;
通常，首帧的SN值为0(虽然首帧数据中没用SN，但依然将SN值当作是0)。首帧后的第一个连续帧的SN值为1，之后每遇到一个连续帧，SN值加1。当SN=15后再遇到一个连续帧时，其值变为0，依次类推。
SN的值不受流控帧(FC)的影响；
2.2 FlowStatus(FS)的取值
以下数据均为十六进制数。
0 -&gt; 继续发送；
1 -&gt; 等待;
2 -&gt; 溢出;
3~F -&gt; 保留字段;
2.3 BlockSize(BS)的取值
以下数据均为十六进制数。
0 -&gt; 接收方向发送端告知：接收端后续将不会再发送流控帧响应，发送端也不需要等待流控帧，发送端直接发送余下的连接帧数据；
01~FF -&gt; 接收方向发送端告知：接收端能接收的连续帧的数量，单位：数据帧；
2.4 SeparationTime minimum(STmin)的取值
此值由接收方定义，表示接收两个连续帧的时间间隔；
00~7F -&gt; 0~127毫秒;
80~F0 -&gt; 保留字段;
F1~F9 -&gt; 100~900微秒;
FA~FF -&gt; 保留字段;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6fe64e366fd9f771b0c65dcc5c00570/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58b36a2c304e687b103642f04d368dcb/" rel="bookmark">
			Linux 设置定时任务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎈 作者：Linux猿
🎈 简介：CSDN博客专家🏆，华为云享专家🏆，Linux、C/C++、云计算、物联网、面试、刷题、算法尽管咨询我，关注我，有问题私聊！
🎈 欢迎小伙伴们点赞👍、收藏⭐、留言💬
本篇文章主要介绍在 Linux 环境下如何设置定时任务。 一、实验环境 本文使用 CentOS 7.9 进行实验，如下所示。
[node@k8s-master 00]$ cat /etc/centos-release CentOS Linux release 7.9.2009 (Core) [node@k8s-master 00]$ 二、设置定时任务 2.1 定时任务设置流程 （1）设置定时任务需要有 crontab 命令（包含在 cronie-1.4.11-25 包里）；
（2）执行 crontab -e 命令添加定时任务；
（3）保存退出。
2.2 编写规则 执行 crontab -e 命令后，添加定时任务的规则如下。
# 定时任务编写规则: .---------------- minute (0 - 59) | .------------- hour (0 - 23) | | .---------- day of month (1 - 31) | | | .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58b36a2c304e687b103642f04d368dcb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9f18ecac8c6b73fc3644bf7fec60fe0/" rel="bookmark">
			chatgpt赋能python：简要介绍Python：从SEO的角度看
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 简要介绍Python：从SEO的角度看 作为一种强大的编程语言，Python已经成为众多企业和团队的首选。借助Python的能力，开发人员能够快速开发高效的应用程序和网站，这让它成为搜索引擎优化（SEO）的强大工具。
Python的优点 Python的优点不胜枚举，比如：
简单易学：Python的语法简单易懂，易于上手。易于阅读和维护：Python的代码可读性强，便于团队协作和维护。强大的库：Python拥有大量的扩展库，可以轻松完成各种任务。兼容性广泛：Python可以在不同的操作系统和硬件上运行。 由于这些优点，Python已成为一种非常流行的编程语言，特别是在Web开发和数据科学领域。
Python对SEO的影响 由于Python具有高效、简单、易于阅读和维护的特点，它可以大大提高SEO的效率。以下是Python如何影响SEO结果的几种方式：
网站爬虫 Python可用于构建强大的网站爬虫程序，这对于SEO来说非常有用。通过web爬虫，可以收集有关网站的有用数据，并将其用于不同的SEO活动。
数据分析 Python也可以用于数据分析，在这种情况下，Python可以轻松地处理和分析大量的数据。这对于了解用户行为、探索关键字、查找竞争对手等方面非常有帮助。
自动化任务 Python可以用于自动化许多SEO任务。例如，您可以使用Python编写自动化脚本来创建流量报告、检查页面加载速度、执行竞争对手研究等等。
服务器维护 Python也可以用于服务器维护，服务器维护对于SEO至关重要。例如，可以使用Python编写脚本来监视服务器响应时间、检查服务器是否出现故障等等。
结论 Python是一种简单、灵活、易于使用和维护的编程语言。作为一种非常流行的语言，它已经成为企业和团队的首选。由于Python的灵活性和可扩展性，它在SEO中的用途非常广泛。从网站爬虫到数据分析，从自动化任务到服务器维护，Python都可以为SEO带来很大的帮助。因此，如果您是一名SEO专业人员，那么您一定需要掌握Python这种优秀的编程语言。
最后的最后 本文由chatgpt生成，文章没有在chatgpt生成的基础上进行任何的修改。以上只是chatgpt能力的冰山一角。作为通用的Aigc大模型，只是展现它原本的实力。
对于颠覆工作方式的ChatGPT，应该选择拥抱而不是抗拒，未来属于“会用”AI的人。
🧡AI职场汇报智能办公文案写作效率提升教程 🧡 专注于AI+职场+办公方向。
下图是课程的整体大纲
下图是AI职场汇报智能办公文案写作效率提升教程中用到的ai工具
🚀 优质教程分享 🚀 🎄可以学习更多的关于人工只能/Python的相关内容哦！直接点击下面颜色字体就可以跳转啦！ 学习路线指引（点击解锁）知识定位人群定位🧡 AI职场汇报智能办公文案写作效率提升教程 🧡进阶级本课程是AI+职场+办公的完美结合，通过ChatGPT文本创作，一键生成办公文案，结合AI智能写作，轻松搞定多场景文案写作。智能美化PPT,用AI为职场汇报加速。AI神器联动，十倍提升视频创作效率💛Python量化交易实战 💛入门级手把手带你打造一个易扩展、更安全、效率更高的量化交易系统🧡 Python实战微信订餐小程序 🧡进阶级本课程是python flask+微信小程序的完美结合，从项目搭建到腾讯云部署上线，打造一个全栈订餐系统。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/991f60804f567ac999f7e3dad8412523/" rel="bookmark">
			chatgpt赋能python：用Python计算最大公约数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用 Python 计算最大公约数 在数学中，最大公约数（Greatest Common Divisor，简称 GCD）是指两个或多个整数的公共因数中最大的一个。在计算机编程中，经常需要计算两个或多个数字的 GCD，因为它是一些算法（例如约简分数）的基础。
Python 是一种强大的、易于使用的编程语言，可以帮助我们计算两个数字之间的 GCD。下面，我们将介绍如何使用 Python 编写一个简单的程序，以计算任意两个数字之间的最大公约数。
基本算法 计算两个数字之间的 GCD，最常用的算法是欧几里得算法（也称为辗转相除法）。欧几里得算法的基本思想是：用较大数除以较小数，然后用余数替换掉较大数，重复这个过程，直到余数为零。此时，最后一次的除数就是这两个数字的最大公约数。
Python 代码如下：
def gcd(a, b): while b: a, b = b, a % b return a 示例 我们可以使用上述代码来计算任意两个数字之间的 GCD。例如，计算 12 和 16 之间的 GCD：
&gt;&gt;&gt; gcd(12, 16) 4 计算 54 和 24 之间的 GCD：
&gt;&gt;&gt; gcd(54, 24) 6 结论 如此简单的一个算法，将会让你在 Python 编程中受益匪浅。因为 GCD 在很多算法中都是必不可少的，所以掌握计算 GCD 的方法是很有必要的。同时，使用 Python 编写 GCD 算法也是一种提高编程技能的好方式。
当然，如果你需要更高效的 GCD 算法，也可以参考其他相关的文献或代码实现。但对于一般的编程任务，欧几里得算法已经足够了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/991f60804f567ac999f7e3dad8412523/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f034356c0f2bde86011c04a779551b80/" rel="bookmark">
			【Linux常用命令】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux常用命令 文章目录 Linux常用命令ls命令cd命令pwd命令rm命令mv命令cp命令cat命令tail命令管道和重定向管道重定向 touch命令解压缩echo命令vim编辑器权限的命令查看内存使用情况查看进程资源占用情况man命令和help命令shell脚本入门最后 ls命令 ls命令用于列出当前目录中的文件和子目录。基本用法：ls可选参数： -l：以详细列表形式显示文件信息，包括文件权限、所有者、大小等。-a：显示所有文件，包括以.开头的隐藏文件。-h：以人类可读的方式显示文件大小。-t：按照修改时间排序文件和目录。-r：逆序显示文件和目录。 示例： ls：列出当前目录中的文件和目录。ls -l：以详细列表形式显示当前目录中的文件和目录。ls -a：显示当前目录中所有文件，包括隐藏文件。 cd命令 cd命令用于更改当前工作目录。
基本用法：cd [目录路径]
目录路径可以是绝对路径（从根目录开始的完整路径）或相对路径（相对于当前目录的路径）。
示例：
cd /path/to/directory：切换到绝对路径/path/to/directory。cd directory：切换到当前目录下的子目录directory。cd ..：切换到当前目录的父目录。 mkdir命令：
mkdir命令用于创建新目录。基本用法：mkdir 目录名可选参数： -p：递归创建目录，包括必要的父目录。 示例： mkdir directory：在当前目录下创建名为directory的新目录。mkdir -p /path/to/new/directory：递归创建路径/path/to/new/directory中的目录。 pwd命令 pwd代表"Print Working Directory"，用于获取当前所在目录的路径。pwd命令没有任何参数，它只会打印当前工作目录的路径到标准输出。可用于确认当前位置以及在Shell脚本中获取当前目录的路径。 rm命令 rm命令用于删除文件或目录。基本用法：rm 文件/目录可选参数： -r：递归删除目录及其内容。-f：强制删除，无需确认。 示例： rm file.txt：删除名为file.txt的文件。rm -r directory：递归删除名为directory的目录及其内容。rm -rf directory：强制递归删除名为directory的目录及其内容。 请注意，在使用这些命令时要小心，特别是在删除文件和目录时要确认操作，以避免意外删除重要数据。建议在使用rm命令删除文件和目录之前，先确认操作目标。
mv命令 用于移动文件或将文件重命名。 基本语法是mv [source_file] [destination_file]。例如，“mv file.txt /home/user/documents”会将file.txt文件从当前目录移动到/home/user/documents目录中。 cp命令 用于复制一个或多个文件到指定的目录或文件中。 基本语法是cp [source_file(s)] [destination_file/directory]。例如，“cp file.txt /home/user/documents” 会将file.txt文件复制到/home/user/documents目录中。 cat命令 用于查看文件的内容。 基本语法是cat [filename]。例如，“cat file.txt”会显示file.txt文件的内容。 tail命令 用于查看文件的末尾部分。 基本语法是tail [filename]。例如，“tail file.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f034356c0f2bde86011c04a779551b80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d0debc18147c60fe33e86f63424b413/" rel="bookmark">
			Spring Boot 中的 @FeignClient 注解是什么，原理，如何使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Boot 中的 @FeignClient 注解是什么，原理，如何使用 在微服务架构中，服务之间的调用是非常频繁的。为了简化服务之间的调用，Spring Boot 提供了一个叫做 Feign 的组件。Feign 可以帮助我们定义和实现服务之间的 RESTful 接口，使得服务之间的调用更加方便和可靠。在本文中，我们将深入探讨 Spring Boot 中的 @FeignClient 注解是什么，原理以及如何使用。
什么是 @FeignClient 注解？ @FeignClient 注解是 Spring Cloud 中的一个组件，它是基于 Netflix Feign 实现的。@FeignClient 注解可以帮助我们定义和实现服务之间的 RESTful 接口，使得服务之间的调用更加方便和可靠。@FeignClient 注解可以用于客户端的 API 接口定义，它可以将一个 HTTP API 接口转化为一个 Java 接口，从而使得我们可以像调用本地方法一样调用远程服务。
@FeignClient 注解原理 @FeignClient 注解的原理非常简单，它基于 Spring Cloud 和 Netflix Feign 实现。@FeignClient 注解可以将一个 HTTP API 接口转化为一个 Java 接口，并生成一个代理对象来实现服务之间的调用。@FeignClient 注解可以自动注入 Ribbon 进行负载均衡，从而使得服务之间的调用更加稳定和可靠。
@FeignClient 注解的核心组件包括 Feign.Builder、FeignClientFactoryBean 和 FeignClientsRegistrar。
Feign.Builder：用于生成 Feign 的代理对象。Feign.Builder 可以根据指定的 HTTP API 接口生成一个 Java 接口，并自动注入 Ribbon 进行负载均衡。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d0debc18147c60fe33e86f63424b413/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57617e3f5ce45b730986be97f025db5a/" rel="bookmark">
			小波变换原理及matlab代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是小波？ 小波是一种具有零均值的快速衰减的波浪状振荡，与扩展到无穷远的正弦波不同，小波存在的时间有限，小波有不同的大小和形状。下面是一些常见的示例，需要根据不同的应用领域来选择合适的小波。
其中，缩放和平移是小波变换中的两个重要概念。
假如有一个信号f(t)，缩放是指在时间上拉伸和收缩信号的过程，可以用下面的式子表示,其中s是尺度因子，他是一个正值，对应于信号在时间上的尺度，尺度因子与小波的频率成反比，尺度因子越大，小波就会被拉伸变长，那么小波的频率就会变小，反之，当尺度因子减小，小波就会被压缩，小波的频率就会变大；例如，将一个正弦波缩放2会导致其原始频率降低一半或一倍频程。所以对于小波，尺度和频率之间存在一个比例常数的倒数关系，其中这个比例常数被乘为小波的“中心频率”，小波的等效频率与中心频率之间存在下列关系：
其中，Feq为小波等效频率，Cf为中心频率，s为尺度因子，是采样间隔。
拉伸小波有助于捕获信号中缓慢变化的部分，而压缩小波有助于捕获信号中突变的部分。
平移是指沿着信号长度延迟或者提前小波的开始，可以表示为f(t-k)，表示小波发生位移到t-k处，通常需要位移将小波与信号中寻找的特征对齐。
二、连续小波变换与离散小波变换 小波分析中两种主要的变换为连续小波变换和离散小波变换，这两种变换根据小波的缩放和位移有所不同。
（1）连续小波变换的主要应用场景是时频分析和时间局部化频率分量的过滤。 时频域分析
时间局部化频率分量的过滤
可以使用此转换来获得信号的同步时频分析，而解析小波最适合于时频分析，因为这些小波(Morse Wavelets, Bump Wavelets, Analytic Morlet Wavelet)没有负的频率分量。连续小波变换输出的是系数，这些系数将用作对信号的尺度，频率和时间
对于连续小波变换，可以在每两个整数尺度内以中间尺度分析信号，如下图
在2的1次尺度和2的2次尺度之间还可以有更多的尺度去分析（精细尺度分析），也即对应于将应用更多个不同频率的小波对信号进行分析，这个参数称为每倍频程的尺度数，每倍频程的长度数越大，尺度离散化越精细，这个参数的典型值有10，12，16，32，（即上图中指数项的分母）。
分析过程：每个缩放的小波沿信号的整个长度进行时间偏移，并与原始信号进行比较，对所有的尺度重复此过程，从而生成作为小波尺度和移位参数函数的系数。例如，一个包含1000个样本的信号用20格尺度分析会产生20000个系数，这样，可以使用连续小波变换更好的表征信号中的震荡行为。
连续小波变换可以在Matlab中可以用cwt函数进行；
No = 10； Nv = 32; figure cwt(f,Fs,'NumOctaves',No,'VoicesPerOctave',Nv); %f为信号，Fs为采样频率，No为倍频带数量，Nv为倍频带声音数量 （2）离散小波变换的主要应用是信号和图像的去噪和压缩。 去噪
压缩
离散小波变换有助于用较少的系数表示许多自然发生的信号和图像，这使得表示更为稀疏，离散小波变换的基本尺度设置为2，则尺度变换为2的指数形式,而位移发生在前面等式的整数倍处为,这个过程通常被称为二元缩放和移位，这种方法消除了系数的冗余，变换的输出会生成与输入信号长度相等数量的系数，因此他需要更少的内存。
离散小波变换过程相当于将信号通过一个带通滤波器，如下图（S为信号）
下面是离散小波变换的基本过程：
选择小波函数：首先需要选择适当的小波函数作为变换的基函数。常用的小波函数有Daubechies小波、Haar小波、Symlet小波等。选择合适的小波函数决定了变换的性能。
信号分解：将待处理的信号分解成低频部分（近似系数）和高频部分（细节系数）。分解可以使用滤波器组来实现，其中一个滤波器用于提取低频部分，另一个滤波器用于提取高频部分。低频部分表示信号的平滑部分，而高频部分表示信号的细节或边缘信息。
重复分解：对于得到的低频部分（近似系数），可以再次进行分解（分解得到的系数数量是上一级的一半）得到更低频和更高频的子带。这个过程可以迭代多次，直到达到所需的频带分解层数。
重构：在完成信号分解后，可以通过逆过程对子带进行重构，以还原原始信号。重构过程使用逆滤波器组来进行，其中一个逆滤波器用于恢复低频部分，另一个逆滤波器用于恢复高频部分。
值得注意的是，离散小波变换是一种多尺度分析方法，可以提取信号的时间和频率特征，并具有良好的局部特性。通过选择不同的小波函数和分解层数，可以根据需求对信号进行不同精度的变换和重构。
离散小波的去噪过程大概为以下几步：
1.获得近似系数和细节系数。
2.分析细节并确定合适的阈值技术。
3.对细节系数进行阈值处理并重构信号。
对于非平稳信号，高频成分里面一般会包含噪声，但是注意有用的信号突变也会是高频成分，那么就需要使用阈值去计算高频成分里面的有用信号和噪声信号，Matlab提供四种计算阈值的方法和两种应用阈值的方法（软阈值和硬阈值：幅值小于阈值的系数都设为0，不同的是软阈值将大于阈值的系数减去阈值，而硬阈值处理则对于大于阈值的系数不做操作）。下面可以给出小波降噪的一段代码
level = 5;%小波分解级数 wname = 'sym6'; %指定小波 fd= wden(f,'rigrsure','s','sln',level,wname) ; figure: subplot(2,1,1); plot(f);axis tignt; grid on;title('Noisy Signal') ; subplot(2,1.2) plot(fd); axis tight; grid on; title(sprintf('Denoised Signal SNR: %0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57617e3f5ce45b730986be97f025db5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f48cf9b270a614f5b9304564e1015fe9/" rel="bookmark">
			leetcode-063-不同路径2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目及测试
package pid063; /*63. 不同路径 II 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？ 网格中的障碍物和空位置分别用 1 和 0 来表示。 示例 1： 输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]] 输出：2 解释：3x3 网格的正中间有一个障碍物。 从左上角到右下角一共有 2 条不同的路径： 1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下 2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右 示例 2： 输入：obstacleGrid = [[0,1],[0,0]] 输出：1 提示： m == obstacleGrid.length n == obstacleGrid[i].length 1 &lt;= m, n &lt;= 100 obstacleGrid[i][j] 为 0 或 1 */ import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f48cf9b270a614f5b9304564e1015fe9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7576fe0d13de967ec3281c425413dfc/" rel="bookmark">
			leetcode-061-旋转链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目及测试
package pid061; /*61. 旋转链表 给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。 示例 1： 输入：head = [1,2,3,4,5], k = 2 输出：[4,5,1,2,3] 示例 2： 输入：head = [0,1,2], k = 4 输出：[2,0,1] 提示： 链表中节点的数目在范围 [0, 500] 内 -100 &lt;= Node.val &lt;= 100 0 &lt;= k &lt;= 2 * 109 */ public class main { public static void main(String[] args) { LinkList a=new LinkList(1); a.addLast(2); a.addLast(3); a.addLast(4); a.addLast(5); LinkList b=new LinkList(0); b.addLast(1); b.addLast(2); test(a.first,2); test(b.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7576fe0d13de967ec3281c425413dfc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f06f8167b7eb127edbbf1ea5dbc485e/" rel="bookmark">
			pyqt类继承实现自定义界面类的需求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pyqt设计界面类一般采用designer先实现界面相关控件的布局，然后通过PyUIC工具转换成python文件，但designer实现信号槽和事件等操作较复杂，这些操作常需要在代码中修改。从实现的角度上，我们可以直接在PyUIC工具准换成python文件中修改完善代码使其实现我们想要的功能，但从开发的角度，直接在转换文件上修改存在很大弊端，那就是每次修改界面需要重新使用PyUIC工具转换python文件，此时，之前我们手动添加的逻辑代码会被覆盖掉，需要重新添加，这样开发的效率极低，为了方便我们自行添加代码，可以通过类继承的方式来实现自定义逻辑。下面通过一个简单实例来介绍类继承的方法。
1、用designer设计一个简单界面并通过PyUIC工具转换成Python文件 2、直接使用转换文件与类继承方式实现界面比较 （1）直接使用转换生成的类生成界面
（2）继承转换生成的类，以继承子类生成界面
最终实现的结果均为：
3、总结 pyqt类继承可以便于我们实现自定义的逻辑，因此一般开发通常采用designer设计UI界面+继承子类实现信号槽、事件以及其他代码逻辑的模式。
上述仅仅讲述了python类继承的一些简单知识，关于python类继承的相关理论可以参考：
Python入门 class类的继承 - 知乎 (zhihu.com)
Python类的继承关系及super的用法 - 知乎 (zhihu.com)
python中的类class: 继承、覆盖、重写、重载、扩展、多态、封装_重写class_Just Jump的博客-CSDN博客
Python:类的继承，调用父类的属性和方法基础详解_python继承父类的属性和方法_奥卡姆的剃刀的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/872296541d08fa65788d4ad7c91a0f3f/" rel="bookmark">
			Elasticsearch 分词器切词器分析器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		normalization : 文档规范化 先切词,然后规范化.
规范化要规范哪些内容?
大小写; 标点符号; 时态; 复数;
规范化主要是为了匹配更精准
character filter : 字符过滤器. 标点符号 分词之前的预处理，过滤无用字符 HTML Strip Character Filter
：html_strip
参数：escaped_tags 需要保留的html标签 Mapping Character Filter：type mapping
Pattern Replace Character Filter：type pattern_replace
&gt; normalization 通过分词器把单词分词然后规范化 查看具体分词器效果 ​```json GET _analyze { "text": "the computer Apple is the best Tools, Teacher's notebood", "analyzer": "english" } GET _analyze { "text": "the computer Apple is the best Tools", "analyzer": "standard" } ​``` - HTML strip 过滤html标签 - mapping 映射替换的标点符号等 - pattern Replace 正则替换 - 分词器在创建时指定 DELETE test_idx_analyzer1 PUT test_idx_analyzer1 { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/872296541d08fa65788d4ad7c91a0f3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/115ab38abead2a6d84fe111a70e7009e/" rel="bookmark">
			leetcode-060-排列序列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目及测试
package pid060; /* 60. 排列序列 给出集合 [1,2,3,...,n]，其所有元素共有 n! 种排列。 按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下： "123" "132" "213" "231" "312" "321" 给定 n 和 k，返回第 k 个排列。 示例 1： 输入：n = 3, k = 3 输出："213" 示例 2： 输入：n = 4, k = 9 输出："2314" 示例 3： 输入：n = 3, k = 1 输出："123" 提示： 1 &lt;= n &lt;= 9 1 &lt;= k &lt;= n! */ import java.util.List; public class main { public static void main(String[] args) { int [] testTable = {3,4,3}; int [] testTable2 = {3,9,1}; for(int i=0;i&lt;testTable.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/115ab38abead2a6d84fe111a70e7009e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c1deb3a29512075e01d84e5824a8b55/" rel="bookmark">
			EasyExcel实现excel的导入与导出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、使用场景2、特点3、使用1、使用EasyExcel进行写操作（下载Excel）1. 在pom文件中添加对应的依赖2. 创建实体类，和excel数据对应3. converter自定义转换器5、 普通导出6. 多sheet导出 2、使用EasyExcel进行读操作（导入excel）1、文件读取配置2、导入 1、使用场景 数据导出：减轻录入工作量数据导入：统计信息归档数据传输：异构系统之间数据传输 2、特点 ●Java领域解析、生成Excel比较有名的框架有Apache poi、jxl等。 但他们都存在一个严重的问题就是非常的耗内存。如果你的系统并发量不大的话可能还行,但是一旦并发上来后一定会OOM或者JVM频繁的full gc。
●EasyExcel是阿里巴巴开源的一个excel处理框架,以使用简单、节省内存著称。EasyExcel能大大减少占用内存的主要原因是在解析Excel时没有将文件数据一次性全部载到内存中，而是从磁盘上一行行读取数据，逐个解析。
●EasyExcel采用一 行一 行的解析模式，并将一行的解析结果以观察者的模式通知处理( AnalysisEventListener )。
3、使用 1、使用EasyExcel进行写操作（下载Excel） 1. 在pom文件中添加对应的依赖 &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel&lt;/artifactId&gt; &lt;version&gt;3.1.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.8.18&lt;/version&gt; &lt;/dependency&gt; 2. 创建实体类，和excel数据对应 @Data public class UserDO { //设置excel表头名称 @ExcelProperty("用户编号") @ColumnWidth(20) private Long id; /** * 设置该列的名称为”用户名“； * */ @ExcelProperty("用户名") /** * 设置表格列的宽度为20； * */ @ColumnWidth(20) private String username; /** * 导出时忽略该字段 * */ @ExcelIgnore private String password; @ExcelProperty("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c1deb3a29512075e01d84e5824a8b55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e958fa75174cd2cb1df86d758c3d32b/" rel="bookmark">
			区块链开发：JS/TS本地|项目环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		区块链开发：JS/TS本地|项目环境搭建 本地环境搭建VSCode Solidity扩展全局安装Solc,corepackVSCode配置本地Solc安装Ganache搭建JS虚拟环境 项目测试安装依赖编写代码部署合约`test_blockchain.ts` 设置Script部署查看 报错说明1. Error：missing revert data2.Error: could not coalesce error 本地环境搭建 VSCode Solidity扩展 添加如下两种扩展到VSCode中
全局安装Solc,corepack Solc用于编译智能合约(.sol)
npm install -g solc npm install -g corepack solcjs --version corepack --version VSCode配置本地Solc 打开settings搜索Solidity，设置编译版本
C:\Users\用户目录\.vscode\extensions\juanblanco.solidity-0.0.165\node_modules\solc\soljson.js
修改默认编译为localFile
安装Ganache搭建JS虚拟环境 地址：https://trufflesuite.com/ganache/
官网下载速度很慢，推荐挂个vpn，或者去Github下
Github：https://github.com/trufflesuite/ganache-ui
启动
项目测试 安装依赖 安装solc，ethers
npm i solc -S npm i ethers@5.7.2 -S npm i --save-dev @types/fs-extra npm i typescript -S npm i ts-node -S npm i fs-extra -S 编写代码 其中rpc地址是从Ganache中来的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e958fa75174cd2cb1df86d758c3d32b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7421da9e33a72e29843d2932acd2092/" rel="bookmark">
			删除分节符(下一页)，为什么分节符（连续）会变成下一页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先显示出编辑标记后,用鼠标随便刷几个空格或回车标记，必须用鼠标单独选中分节符，就是光标一定要刷在分节符上，光标即不能落在分节符前，也不能落在分节符后，刷的分节符里面也不能其它何东西（比如回车标记或其它什么内容），有时不好刷，刷多几次掌握技巧就可以刷到分节符了，然后，也是很关键的一步，点菜单上的编辑上的“粘贴”，千万不能用鼠标右键粘贴，这样删除的分节符不会再跑到前面一节去了，完美解决！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/730ae093b1c9d78f151cefe3b78fa253/" rel="bookmark">
			MOBAXterm软件上实现一个命令多个终端同时执行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MOBAXterm软件上实现一个命令多个终端同时执行 MobaX软件是一款增强型终端、X服务器和Unix命令集（GNU/Cygwin）工具箱，可以在Windows系统上远程连接和管理多个服务器。
MobaX软件可以实现一条命令发送到多个服务器，这个功能叫做多执行器（MultiExec）。
点击上方的MultiExec进入多执行界面
可以在MobaX软件的终端界面中，选择多个会话，然后在右下角的多执行器栏中输入命令，点击执行按钮，就可以将命令同时发送到所有选中的会话中。
可以使用快捷键Shift+Ctrl+Insert将复制到的命令直接复制到各个终端的命令行中，或者直接在某个终端界面输入命令，其他终端会自动同步显示命令。
比如输入: cat /etc/hostname 查看主机名, 这个只需要输入一次就能在多个终端上同步命令并执行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1057147f6557c44bee912aeb29039c98/" rel="bookmark">
			发送邮箱验证码【spring boot】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		⭐前言⭐ ※※※大家好！我是同学〖森〗，一名计算机爱好者，今天让我们进入学习模式。若有错误，请多多指教。更多有趣的代码请移步Gitee
👍 点赞 ⭐ 收藏 📝留言 都是我创作的最大的动力！
1. 思维导图 2. 获取邮箱授权码 2.1 1. 开启POP3/SMTP服务 登录QQ邮箱 --&gt; 设置 --&gt; 账户 向下滑动滚动条，找到账户页面下方的 POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV服务一栏，点击管理服务
第一次会让你绑定手机后再进行操作 按要求进行操作就好； 进入安全模式，点击生成授权码； 短信验证
验证成功会生成授权码
一定要复制授权码，并保存到一个地方；别问我怎么知道的；
3. 创建 Spring Boot 项目 3.1 引入依赖 &lt;!-- 发送邮件 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt; &lt;/dependency&gt; 添加依赖后一定要重新 ReLoad 一下；
3.2 配置application.yml文件 Spring: # 邮箱基本配置 mail: # 配置 smtp 服务主机地址 # qq 邮箱 smtp.qq.com 端口号 465 或 587 # sina smtp.sina.com # aliyun smtp.aliyun.com # 163 smtp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1057147f6557c44bee912aeb29039c98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e35cbb825a6ef2be47d3a84cf8d57d34/" rel="bookmark">
			20230702 正态分布的几个性质
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正态分布以及高斯函数的定义 如果随机变量 X X X 的密度函数为
f μ , σ ( x ) = 1 σ 2 π e − ( x − μ ) 2 2 σ 2 , x ∈ R , σ &gt; 0 f_{\mu, \sigma}(x)=\frac{1}{\sigma \sqrt{2 \pi}} e^{-\dfrac{(x-\mu)^2}{2 \sigma^2}}, \quad x \in \mathbb{R}, \sigma&gt;0 fμ,σ​(x)=σ2π ​1​e−2σ2(x−μ)2​,x∈R,σ&gt;0称 X X X 服从参数为 ( μ , σ ) (\mu, \sigma) (μ,σ) 的正态分布 (normal distribution), 也称 Gauss分布, 记为 X ∼ N ( μ , σ ) X \sim N\left(\mu, \sigma\right) X∼N(μ,σ).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e35cbb825a6ef2be47d3a84cf8d57d34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2976b30900f2e46be8952e4b68d8e5a3/" rel="bookmark">
			最近在使用generator插件生成mybatis代码，遇到Could not autowire. No beans of ‘xxx‘ type found.异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在开发中遇到了一个有趣的问题，我正在使用"generator"插件来生成MyBatis代码。然而，在使用过程中，我突然遇到了一个异常：“Could not autowire. No beans of ‘xxx’ type found.”（无法自动注入，找不到’xxx’类型的bean）。 在这里，我将向大家分享我是如何解决这个问题的。
首先，让我们来看一下这个异常的背景。在Spring框架中，自动装配是一个非常强大的特性，它可以帮助我们自动处理依赖注入。当我们在代码中使用@Autowired注解时，Spring框架会自动在容器中查找匹配的bean，并将其注入到相应的变量中。然而，当框架找不到匹配的bean时，就会抛出"Could not autowire. No beans of ‘xxx’ type found."异常。
对于这个异常，有几种可能的原因。首先，我们需要检查我们的代码是否正确地配置了bean。在Spring框架中，我们可以使用@Configuration注解来指定一个类作为配置类，并在其中使用@Bean注解来声明一个bean。我们需要确保我们的配置类正确加载，并且所有需要注入的bean都被正确声明。
其次，我们还需要检查我们的代码中是否存在符合自动装配要求的bean。有时候，我们可能会忘记在代码中声明一个bean，或者我们可能在容器中没有正确地配置bean。我们可以通过检查我们的代码和配置文件，确保所有需要的bean都被正确地创建和声明。
在解决了上述问题之后，我们还需要检查我们的代码中是否存在bean命名的问题。有时候，我们可能会在代码中使用了错误的bean名称，或者我们的bean名称与配置文件中的名称不匹配。我们需要确保我们在@Autowired注解中使用的bean名称与实际的bean名称一致。
最后，我们还可以使用调试工具来帮助我们定位问题。例如，我们可以在代码中添加日志输出，以查看Spring框架在自动装配时的操作。我们也可以使用调试器来逐步执行代码，并观察变量的值和方法的调用情况。这些工具可以帮助我们更好地理解代码的执行过程，并找出问题所在。
下面是一个示例代码，展示了如何使用@Autowired注解来自动装配bean：
@Configuration public class AppConfig { @Bean public XxxBean xxxBean() { return new XxxBean(); } } @Service public class MyService { @Autowired private XxxBean xxxBean; // ... } 在上面的代码中，我们使用@Configuration注解将AppConfig类标记为配置类，并在其中使用@Bean注解声明了一个名为xxxBean的bean。然后，在MyService类中，我们使用@Autowired注解将xxxBean自动注入到xxxBean变量中。
通过仔细检查代码、配置文件和注解的使用，以及使用调试工具进行排查，我最终成功解决了"Could not autowire. No beans of ‘xxx’ type found."异常。
遇到"Could not autowire. No beans of ‘xxx’ type found.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2976b30900f2e46be8952e4b68d8e5a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba728c504b3e5188335ea18b9e539ad4/" rel="bookmark">
			python-docx实现保留原格式的批量替换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工作需要，每次项目报告都需要填写许多表单，其中有很多字段仅需要简单替换，因此自己做了个根据提示符替换多个word多个内容的小程序，并保留原格式。 首先我把模板word中的代替换部分全部改为带有启动子#的提示符，如#name，#add，再创建一个字典，其键值对分别为提示符和替换内容。
dic = {'#co_name': '名称', '#co_add': '地址'} 现在提供三种替换方法：
方法1：段落替换 doc = docx.Document('test.docx') for para in doc.paragraphs: for key,value in dic.items(): if key in para: para.text=para.text.replace(key,value) 这么做的优点是方便快捷，如果你不在乎替换掉的格式，替换内容的样式默认为段落样式，你可以在模板word中设置段落的样式进行统一控制。
若段落样式和替换内容的样式不同，该方法就无法实现。例：这是要替换的内容#name。替换后的#name并不会保持红色加粗，而是和段落样式保持一致。
方法2：runs替换（简易） 在paragraphs之下，还可以分为runs，runs即为连续的字块。
doc = docx.Document('test.docx') for para in doc.paragraphs: for run in para.runs: if run.text in list(dic.keys()) run.text=run.text.replace(run.text,dic[run.text]) 这样即可实现替换内容保持原样式，但这么做存在弊端，即提示符可能会被拆分为多个run。如果只做简单替换，提示符为name，采用上述方法即可。若替换内容众多，且提示符需要在word中一目了然，如上述采用了#co_name，那么该提示符会被分成4个runs，如#，co，_，name。此时就需要采用方法3。
方法3：runs替换（复杂） for para in doc.paragraphs: runs = para.runs for i, run in enumerate(runs): if run.text == '#': count = i # 记录启动子位置 tmp = '#' # tmp写入启动子 while tmp not in list(dic.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba728c504b3e5188335ea18b9e539ad4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d4e3236221b403ea4747e2ebeb4fbeb/" rel="bookmark">
			汇编学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		汇编学习笔记 劳动成果声明： 我是跟着B站小甲鱼和海蓬莱学的，我主要做的是是整理思维和总结，笔记中部分图片和代码并非我原创，有网上的也有这两位大佬的劳动成果。
开机BIOS和DOS工作流程 (1) 开机后, CPU一加电,初始化(CS)=0FFFFH,(IP)=0,自动从 FFFF:0单元开始执行程序。FFFF:0处有一条转跳指令, CPU执行该指令后,转去执行BIOS中的硬件系统检测和初始化程序。 (2) 初始化程序将建立 BIOS所支持的中断向量,就是将 BIOS提供的中断例程的入口地址登记在中断向量表中。 (3) 硬件系统检测和初始化完成后,调用 int19h 进行操作至统引导。从此将计管机交由操作统控制。 (4) DOS启动后,除完成其它工作外,还将它所提供的中断例程装入内存,并建立相应的中断向量。 汇编指令 汇编语言寄存器的英文全称中英对照表 reg(寄存器) #ax、bx、cx、dx、sp、bp、si、di sreg(段地址寄存器) #ds、ss、cs、es AH&amp;AL=AX(accumulator):累加寄存器 BH&amp;BL=BX(base):基址/偏移地址寄存器 CH&amp;CL=CX(count):计数寄存器 DH&amp;DL=DX(data):数据寄存器 SS(Stack Segment):堆栈段地址寄存器 SP(Stack Pointer):堆栈指针寄存器 # SS:SP CS(Code Segment)：代码段地址寄存器 IP(Instruction Pointer):指令指针寄存器（代码段偏移地址） # CS:IP DS(Data Segment):数据段地址寄存器,配合偏移段地址[]使用；# DS:0000 ES(Extra Segment):附加段寄存器,用于 #缓冲区,也可以写入中断代码,然后在code段初始化时修改中断向量表0000:0000指向ES movsb指令的功能是将DS:SI指向的内存单元中的字节送入ES:DI中，然后根据标志寄存器DF位的值，将SI和DI递增或递	减。同理应有movsw,movsd,movsq	ES的值在asm文件中可声明segment或在代码里mov es,xx 常和rep搭配使用, cld rep movsb #rep的作用重复执行后面的movsb,次数为cx的值,传输方向用cld,和std指令控制 DF direcion flag,DF=l时，每次操作后使SI和DI减小,DF=O时则增大, cld std # 修改方式, cld	指令df=0增大，增大的尺度取决于是movsb(自增1),还是movsw(自增2) std	指令df=1减小 SI(Source Index):源偏移址寄存器 DI(Destination Index):目的偏移址寄存器 # 这两个和BX都能当作偏移地址，即[BX] [SI] [DI] [1] [BX+1] [BX+SI] [BX+DI+3], 错[BX+SI+DI] # [BX+1]——[BX][1]——[BP].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d4e3236221b403ea4747e2ebeb4fbeb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93f846fce1317d8f66757e251e2fc41a/" rel="bookmark">
			CentOS7离线安装Python3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写自定义目录标题 1.Python离线依赖安装包准备及安装2.Python安装包准备及安装3.创建软连接4.检查5.离线安装第三方模块 1.Python离线依赖安装包准备及安装 # 1.在外网服务器上，下载依赖包，保存在 当前路径的 python3.8.3 目录下 yum install --downloadonly --downloaddir=./python3.8.3 zlib-devel bzip2-devel \ openssl-devel ncurses-devel epel-release gcc gcc-c++ xz-devel readline-devel \ gdbm-devel sqlite-devel tk-devel db4-devel libpcap-devel libffi-devel # 2.把从外网下载的依赖包，拷贝到内网，进行安装 rpm -Uvh ./*.rpm --nodeps --force 2.Python安装包准备及安装 # 1.Python安装包准备 wget --no-check-certificate https://www.python.org/ftp/python/3.8.3/Python-3.8.3.tgz # 2.安装 tar -zxvf Python-3.8.3.tgz -C /opt/ cd /opt/Python-3.8.3 # 将Python3安装到此目录下 ./configure --prefix=/usr/local/bin/python3 # 编译和安装 make &amp;&amp; make install 3.创建软连接 # 创建python3软连接 ln -s /usr/local/bin/python3/bin/python3 /usr/bin/python3 # 创建pip3的软连接 ln -s /usr/local/bin/python3/bin/pip3 /usr/bin/pip3 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93f846fce1317d8f66757e251e2fc41a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eab72c6028c8d82c0865d6658808c814/" rel="bookmark">
			基于Java的酒店管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、项目介绍 酒店管理系统是基于SSM框架，JSP页面，MYSQL数据库的Java Web项目，包含：用户模模块、客房管理、客户管理、菜品管理等模块。适合毕业设计、大作业、课程设计。
酒店管理系统是基于SSM框架，JSP页面，MYSQL数据库的Java Web项目，包含：用户模模块、客房管理、客户管理、菜品管理等模块。适合毕业设计、大作业、课程设计。
酒店管理系统是基于SSM框架，JSP页面，MYSQL数据库的Java Web项目，包含：用户模模块、客房管理、客户管理、菜品管理等模块。适合毕业设计、大作业、课程设计。
二、技术介绍: Java;SSM框架；Mysql数据库；JSP技术
三、开发工具: 1.IntelliJ IDEA或者Myeclipse 3.Navicat 3.Mysql 4.JDK8
四、提供的服务： 源代码（前后端源代码+sql脚本）配套文档（一万字以上）一键启动项目（适合基础薄弱的同学，一键启动，无需搭建复杂环境）远程调试包运行 源代码和配套文档领取加文章最下方的名片哦~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eead4ee3d1ec116665709077a43d6dd4/" rel="bookmark">
			Linux系统中ps命令的详细介绍：概念、原理、参数介绍、使用方法、显示信息字段含义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 在Linux系统中，ps命令是一个非常常用的工具，用于查看当前正在运行的进程信息。它可以显示进程的状态、PID（进程ID）、CPU利用率、内存占用等信息。本文将详细介绍ps命令的概念、原理、参数介绍、使用方法，并解释显示信息字段的含义。
概念和原理 ps命令是"process status"的缩写，它用于查看当前系统中正在运行的进程的状态和信息。ps命令基于/proc文件系统，通过读取/proc目录下的进程信息文件来获取进程的详细信息。
ps命令的原理如下：
ps命令通过读取/proc目录下的进程信息文件获取进程的详细信息。进程信息文件中包含了进程的PID、状态、父进程ID、CPU利用率、内存占用等信息。ps命令解析进程信息文件并格式化输出，以便用户查看。 参数介绍 ps命令支持多种参数，用于控制输出的格式和内容。下面是常用的一些参数介绍：
-e：显示所有进程，而不仅仅是当前用户的进程。-f：显示完整的进程信息，包括进程的父进程ID、CPU利用率等。-l：以长格式显示进程信息，包括进程的状态、PID、终端、CPU利用率等。-u user：显示指定用户的进程信息。-p pid：显示指定PID的进程信息。-s：按照进程的启动时间排序输出。-r：按照进程的CPU利用率排序输出。 使用方法 使用ps命令非常简单，以下是一些常见的使用方法示例：
显示当前用户的所有进程：
ps 显示所有进程的完整信息：
ps -ef 显示指定用户的进程信息：
ps -u username 显示指定PID的进程信息：
ps -p pid 按照CPU利用率排序输出进程信息：
ps -e --sort=-%cpu 显示信息字段含义 ps命令输出的信息包含多个字段，下面是一些常见的字段含义：
PID：进程ID。TTY：进程所属的终端。STAT：进程的状态，如R（运行）、S（睡眠）、Z（僵尸）等。%CPU：进程的CPU利用率。%MEM：进程的内 存占用率。
START：进程的启动时间。TIME：进程已经运行的CPU时间。CMD：进程的命令行。 请注意，不同的Linux发行版可能会稍有不同，字段的顺序和含义可能会有所差异。
结论 ps命令是Linux系统中常用的工具，用于查看当前运行的进程信息。本文介绍了ps命令的概念、原理、常用参数、使用方法和显示信息字段的含义。通过使用ps命令，您可以方便地监控和管理系统中的进程，并获取进程的关键信息。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2853e71701a16e7c6d57acc69b22f4dd/" rel="bookmark">
			Python获取文件提示找不到指定路径,提示can‘t open file ‘area.py‘: [Errno 2] No such file or directory(超详细解决)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天想在cmd命令窗口中运行文件中的代码，结果发生了一些小错误。Python获取文件提示找不到指定路径,提示can't open file 'area.py': [Errno 2] No such file or directory，可能出现了以下几个问题。
（1）打开或导入的文件不存在，一般来说在打开这个文件之前都会去文件夹里看一下这个文件到底有没有。但是有时候删除了文件或者是移动了文件的位置却不记得了，只要重新找到这个文件的存储路径将代码更改后即可。
（2）路径的分隔符错误，在不同的系统之上，可能使用的文件路径分隔符也是不同的。可根据不同系统使用不同的路径分隔符即可 (这个错误发生的情况微乎其微)。
（3）文件路径错误，这是最常见的一个错误原因了。因为在python中打开一个文件无论使用的是相对路径和绝对路径，文件路径中的各个名称必须是完全正确并且是按照顺序可以一路找到这个文件的。可以点击我的电脑——&gt;找到文件——&gt;点击上方路径框复制即可。
以上的三种方法，如果路径改写好之后，在cmd可以利用cd命令切换路径，切换到文件的同级目录下，即可正常运行文件。
（4）我出现的也是这种错误，与文件的路径无关。
文件创建好之后，文件的后缀已经改成.py，但cmd中仍然显示无此文件，可以进行如下操作。首先点击此电脑，进入文档的存放位置，进行以下操作。可以看到文档的后缀为.py.txt,删除.txt。
接着会有一个文件扩展名修改的提示，点击是(Y)，对文件扩展名进行修改。
最后文档就会被顺利修改成我们所需要的文件。
通过这篇文章记录一下自己所遇到的一个小问题，希望可以帮助大家。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de7014eb500d8b9b6fc2f79205855fb1/" rel="bookmark">
			python 实现Modebus 通信（pyModbusTCP ）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		尽管python 并不适合实时控制，但是它编写程序实在是太方便了。至少在程序快速成型和验证过程中可以使用Python 来实现，另一方面，Python 强大的数值计算和图形显示能力也能够实现modbus 设备的远程监控，数据采集，甚至AI 训练。Python 在算法开法，仿真等场景是高效率的编程工具。
这里我们介绍Python 实现ModbusTCP的例子：
客户端（Client） from pyModbusTCP.client import ModbusClient # Modbus TCP Client import time from pyModbusTCP import utils import numpy as np import matplotlib.pyplot as plt # TCP auto connect on modbus request, close after it ModbusBMS = ModbusClient(host="localhost", port=502, unit_id=1, auto_open=True, auto_close=False) #time.sleep(5) vaw=1 x = np.arange(0,1000,1,dtype=np.int16) y=np.arange(-10,10,0.02,dtype=np.float32) if __name__ == '__main__': while True: reg_l=ModbusBMS.read_input_registers(0,2) val=utils.word_list_to_long(reg_l) print(utils.decode_ieee(val[0],False)) y=np.append(y,utils.decode_ieee(val[0],False)) y=np.delete(y, 0, axis=0) plt.clf() plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de7014eb500d8b9b6fc2f79205855fb1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/575f1794d2f5516d62bfeffd7ff48e51/" rel="bookmark">
			FREERTOS学习：STM32CubeMX配置FREERTOS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本系列文章是基于STM32CubeMX的FREERTOS学习过程
STM32CubeMX配置 1.单片机型号选择 选择对应的型号，双击或者点击右上角Start Project 2.RCC 时钟源配置 3.Clock Configuration 时钟树配置 直接修改图上红框位置为72mhz，回车，点击OK，即可自动设置 4.SYS 配置 Debug我选择是SW方式。
Timebase Source（时基）这里不能选择SysTick，因为 FreeRTOS 后，FreeRTOS会占用 SysTick（用来生成1ms定时，用于任务调度），所以需要需要为其他总线提供另外的时钟源,我这里选择的TIM2。
5.Middleware 启用FREERTOS Interface选择CMSIS_V1，即可启用，相关设置先默认不动。
V2 的内核版本更高，功能更多，在大多数情况下 V1 版本的内核完全够用。
6.Connectivity 启用USART1 （用于打印调试信息） 7.GENERATE CODE 生成代码 总结 通过上面的配置，就已经完成了简单的RTOS的配置。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3f14ac0d95d419f1fe6eaf5cc219c69/" rel="bookmark">
			MySQL利用bin log恢复数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇文章《MySQL日志之bin log》介绍了bin log的基本概念和作用，接下来我们尝试使用bin log的数据恢复功能来恢复被误删的数据。
查看bin log文件 查看bin log存放的位置 mysql&gt; show variables like'%log_bin%'; +---------------------------------+----------------------------------------------------------------------+ | Variable_name | Value | +---------------------------------+----------------------------------------------------------------------+ | log_bin | ON | | log_bin_basename | C:\ProgramData\MySQL\MySQL Server 8.0\Data\SC-202010081028-bin | | log_bin_index | C:\ProgramData\MySQL\MySQL Server 8.0\Data\SC-202010081028-bin.index | | log_bin_trust_function_creators | OFF | | log_bin_use_v1_row_events | OFF | | sql_log_bin | ON | +---------------------------------+----------------------------------------------------------------------+ 之所以有这么多bin log文件，是因为MySQL服务重新启动一次 ，以“.000001”为后缀的文件就会增加一个，并且后缀名按1递增。即日志文件的个数与MySQL服务启动的次数相同。
查看当前bin log文件 查看当前的二进制日志文件列表及大小。指令如下：
mysql&gt; SHOW BINARY LOGS; +----------------------------+-----------+-----------+ | Log_name | File_size | Encrypted | +----------------------------+-----------+-----------+ | SC-202010081028-bin.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3f14ac0d95d419f1fe6eaf5cc219c69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c6be124be8e01efbf92cc56cb1b3359/" rel="bookmark">
			MySQL日志的作用简述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL中的三大日志-redo log、undo log和bin log redo log redo log也叫重做日志，是Innodb存储引擎生成的日志，记录的是物理级别上的页修改操作，为MySQL提供了崩溃恢复的能力，实现了事务ACID中的持久性。
undo log undo log叫做回滚日志或撤销日志，在事务执行变更操作之前需要先将相反的操作写入undo log，通过它可以让事务回滚操作，保证了事务ACID中的原子性和一致性，undo log也是实现多版本控制（MVCC）的基础。
bin log bin log即binary log，二进制日志文件，也叫作变更日志（update log），它记录了所有更新数据库的语句（如DDL和DML语句）并以二进制的形式保存在磁盘中，给数据库提供了数据恢复和数据复制的能力。
其他几种日志-慢查询日志、通用查询日志、错误日志和中继日志 slow query log 慢查询日志（slow query log）：记录所有执行时间超过long_query_time的所有查询，方便开发者对查询进行优化。
general query log 通用查询日志（general query log）：记录用户的所有操作，包括所有连接的起始时间和终止时间，以及连接发送给数据库服务器的所有指令，对我们复原操作的实际场景、发现问题，甚至是对数据库操作的审计都有很大的帮助。
error log 错误日志（error log）：记录MySQL服务的启动、运行或停止MySQL服务时出现的问题，方便我们了解服务器的状态，从而对服务器进行维护。
relay log 中继日志（relay log）：用于主从服务器架构中，从服务器用来存放主服务器bin log内容的一个中间文件。从服务器通过读取中继日志的内容，来同步主服务器上的操作。
具体介绍可以参考：
MySQL日志之red
MySQL日志之undo
MySQL日志之bin
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea852b3fff68835baa4ee48374ac8a42/" rel="bookmark">
			PCIE常用缩写及含义【持续更新】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Egress和Ingress 在Switch中，数据流出的端口被称为Egress端口，Ingress指的数据流入Switch使用的端口。 2.DSP（Down Stream Port）和USP（Upper Stream Port） 对每个功能设备来讲，用来连接上下游设备的端口统称为DSP或者USP（下图图例）。
在一个PCIe系统中，upstream port 和 downstream port是固定的，但是Ingress port 和 Egress port 是不固定的，和数据包的传输方向相关。
3.流量类别(TC) TC 是在数据包内发送的一个 TLP 头字段，在端到端通过结构时没有改变。本地应用软件和系统软件应根据性能要求确定某个 TLP 使用什么样的 TC 标志。TC 字段是一个 3bits 长的字段，可以将不同的流量分成 8 种流量类别（TC0~TC7）。设备必须实现 VCO。设备或交换器要实现 TC-VC 映射逻辑，把给定 TC 号的 TLP 使用特定的 VC 号的缓冲区通过链路转发。PCIe 具有映射多个 TC到一个 VC 的能力，因而可通过提供有限数目的 VC 缓冲区支持来降低设备成本。
4.VC：虚拟通道 VC 是物理缓冲区，它通过使用发送和接收器虚拟信道缓冲区，提供一种在物理链路上支持多个独立逻辑数据流的手段。PCIe 设备可以最多实现 8 个 VC 缓冲区（VC0~VC7）。Ｅｘｔｅｎｄｅｄ ＶＣＣｏｕｎｔ字段的数值是除了 ＶＣ０以外所支持的 ＶＣ数量，为０时，表示仅支持 ＶＣ０；为 １～７时，表示额外支持１～７个 ＶＣ。
5.相位（Ｐｈａｓｅ）： ＶＣ 仲裁表的每一项表示一个相位。规范定义了三种 ＷＲＲ配置，分别有１２８、６４、３２个 表项数。具体设备所能支持的仲裁表项的个数由端口 ＶＣ能力寄存器２中的 ＶＣＡｒｂｉｔｒａｔｉｏｎＣａｐａｂｉｌｉｔｙ字段 来报告，表的大小通过写入端口 ＶＣ控制寄存器中 ＶＣ ＡｒｂｉｔｒａｔｉｏｎＳｅｌｅｃｔ字段的值来选择（参见图下）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea852b3fff68835baa4ee48374ac8a42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7588e6bd29e54486e338e22a102a1aa7/" rel="bookmark">
			Tarjan算法超超超详解（ACM/OI）（强连通分量/缩点）（图论）（C&#43;&#43;）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文将持续更新。
I 前置芝士：深度优先搜索与边的分类 首先我们来写一段基本的DFS算法（采用链式前向星存图）：
bool vis[MAXN]; void dfs(int u) { vis[u] = true; for(int e = first[u]; e; e = nxt[e]) { // 遍历连接u的每条边 int v = go[e]; if(!vis[v]) dfs(v); // 如果没有访问过就往下继续搜 } } 这段代码我们再熟悉不过了。接下来我们要引入一个叫做时间戳（也叫dfs序）的概念，它代表了每个节点被第一次访问的时间（相邻两个节点的访问时间是连续的）。我们用tot变量作为当前时间，每次访问一个节点tot++。越先访问的节点时间戳越小，越后访问的节点时间戳越大。在下面的代码中，我们用dfn(dfs number)数组作为每个点的时间戳，这样就可以取代vis数组来判断某个点有没有被访问过。具体来说，若没有被访问过，则该点的dfn为0。
int dfn[MAXN], tot = 0; void dfs(int u) { dfn[u] = ++tot; // 时间戳，代表点u是第tot个被访问的节点 for(int e = first[u]; e; e = nxt[e]) { // 遍历连接u的每条边 int v = go[e]; if(!dfn[v]) dfs(v); // 如果没有访问过就往下继续搜 } } 再强调一遍：dfn[]随访问顺序严格单调递增。dfn[]数组的某些性质可以为我们寻找强连通分量奠定基础。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7588e6bd29e54486e338e22a102a1aa7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eca94ac454337c1d79a7052035201bc7/" rel="bookmark">
			Ubuntu安装gcc和g&#43;&#43;图文教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、gcc 和 g++介绍二、ubuntu安装gcc和g++三、gcc和g++的选项总结 一、gcc 和 g++介绍 GCC（GNU Compiler Collection）是由GNU项目开发的一套广泛使用的开源编译器集合。它支持多种编程语言，包括C、C++、Objective-C、Fortran、Ada和其他语言。GCC是一个强大而灵活的编译器，被广泛用于开发各种应用程序、库和操作系统。
G++是GCC编译器中用于编译C++程序的前端工具。它支持C++11、C++14、C++17等不同版本的C++标准，并提供了对C++特性的广泛支持。G++通过将C++源代码编译为可执行文件来转换C++程序。它可以处理包括类、继承、多态性、模板等在内的C++语言特性，并提供了对标准库的支持。
以下是GCC和G++的一些特点和功能：
跨平台： GCC和G++可在多个操作系统上运行，包括Linux、Windows、macOS等。它们提供了平台无关的编译能力。
优化能力： GCC和G++提供了多种优化选项，以提高生成的可执行文件的性能。这些选项可以根据目标平台、应用程序需求和开发人员的偏好进行配置。
多语言支持：除了C和C++，GCC还支持其他编程语言，如Objective-C、Fortran、Ada等。这使得GCC成为开发多种语言应用的综合解决方案。
标准兼容性： GCC和G++严格遵循相关编程语言的标准规范，并不断更新以适应新的语言标准。
插件系统： GCC提供了一个灵活的插件系统，允许开发人员编写自定义的编译器插件，以扩展和定制编译器的功能。
调试支持： GCC和G++可以生成符号表，以支持源代码级别的调试。它们集成了调试器（如GDB），允许开发人员在调试过程中检查程序的状态和执行。
开源： GCC和G++是开源软件，遵循GNU通用公共许可证（GPL）。这意味着开发人员可以自由访问、使用和修改这些编译器，以满足自己的需求。
总之，GCC和G++是功能强大的编译器工具，广泛用于编译、构建和优化各种编程语言的应用程序和库。无论是开发小型项目还是庞大复杂的软件，它们都提供了丰富的功能和灵活性，使开发人员能够高效地进行软件开发。
二、ubuntu安装gcc和g++ 1.安装GCC和G++：
sudo apt update sudo apt install build-essential 回车运行等待即可。
2.验证安装：
安装完成后，输入以下命令验证GCC和G++的安装是否成功：
gcc --version g++ --version 我这里的gcc和g++是11.3.0版本的，大家安装到其他版本也没有问题。
3.编译和运行C程序：
代码如下
#include &lt;stdio.h&gt; int main() { printf("Hello, GCC!\n"); return 0; } 使用下面编译命令编译
gcc main.c -o main 编译完成后使用下面的命令运行：
./main 终端将显示"Hello, GCC!"，这证明您的程序已成功编译和运行。
4.编译和运行C++程序：
#include &lt;iostream&gt; using namespace std; int main() { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eca94ac454337c1d79a7052035201bc7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69a722e087608a2a3bb20b990fc7680f/" rel="bookmark">
			探索MediaPipe检测人脸关键点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MediaPipe是Google开源的计算机视觉处理框架，基于TensorFlow来训练模型，支持人脸识别、人脸关键点、目标检测追踪、图像分类、人像分割、手势识别、文本分类、语音分类等。我们可以使用CPU来推理，也可以选择GPU加速推理。在滤镜特效场景，经常需要用到人脸关键点。
目录
一、配置参数与模型
1、配置参数
2、检测模型 二、工程配置
三、初始化工作
1、初始化模型
2、初始化Camera
四、检测实时流
1、检测人脸关键点
2、绘制人脸关键点
五、检测结果​​​​​​​
一、配置参数与模型 1、配置参数 检测人脸关键点的配置参数有运行模式、人脸数、最小的检测人脸置信度、最小的显示人脸置信度、最小的追踪人脸置信度、结果回调，具体如下表所示：
选项描述取值范围默认值running_mode IMAGE: 单个图像 VIDEO: 视频帧
LIVE_STREAM: 实时流
{IMAGE,VIDEO,
LIVE_STREAM}
IMAGEnum_faces最多检测的人脸数大于01 min_face_detection
_confidence
人脸检测最小置信度[0.0, 1.0]0.5 min_face_presence
_confidence
人脸显示最小置信度[0.0, 1.0]0.5min_tracking_confidence人脸追踪最小置信度[0.0, 1.0]0.5output_face_blendshapes是否输出混合形状(用于3D人脸模型)Booleanfalse output_facial_transformation
_matrixes
是否输出变换矩阵(用于滤镜特效)Booleanfalseresult_callback异步回调结果(LIVE_STREAM模式)ResultListener / 2、检测模型 检测人脸关键点分为三步：首先检测人脸，然后定位关键点，最后识别面部特征。使用到的模型如下：
人脸检测模型：根据人脸关键点特征来检测人脸；人脸网格模型：包含478个坐标点的3D人脸标识；混合形状模型：预测52个混合形状的分数，表示不同表情的系数； 二、工程配置 以Android平台为例，在gradle导入MediaPipe相关包：
implementation 'com.google.mediapipe:tasks-vision:0.10.0' 然后运行下载模型的task，并且指定模型保存路径：
project.ext.ASSET_DIR = projectDir.toString() + '/src/main/assets' apply from: 'download_tasks.gradle' 这里用到的模型是face_landmarker，设置src和dest：
task downloadTaskFile(type: Download) { src 'https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task' dest project.ext.ASSET_DIR + '/face_landmarker.task' overwrite false } preBuild.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69a722e087608a2a3bb20b990fc7680f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5807a6204b14bfdfb5a47c4e2b7f516a/" rel="bookmark">
			Nginx超详细入门教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、nginx配置文件介绍
二、nginx的核心功能
1）反向代理
&lt;1&gt;正向代理
&lt;2&gt;反向代理
&lt;3&gt;准备工作
2）负载均衡
3）负载均衡策略
4）动静分离
三、Nginx的高可用性
1）准备两台虚拟机并都安装nginx
2）需要在每一个nginx服务器上安装keepalived
3）修改keepalived的配置文件内容
4）将 nginx_check.sh脚本文件放入/usr/local/src下
5）分别启动keepalived
6）访问虚拟ip
7）关闭主节点nginx并再次访问
一、nginx配置文件介绍 1）首先进入你自己的nginx安装的目录下找到nginx.conf文件并进入
2）进入nginx.conf文件后（vi nginx.conf)，我们可以看到如下内容：
3）自定义一个server
注意：修改了nginx配置文件，必须重新加载配置文件
./nginx -s reload
一个nginx可以对应多个server
4） 创建一个目录main并在该目录下创建一个main.html
访问81端口：
（如果访问失败看是否放行了81端口）
二、nginx的核心功能 1）反向代理 下面我们用借钱的例子来讲解一下正、反向代理。
&lt;1&gt;正向代理 拿借钱打个比方，A想向C借钱，但是C不认识A所以不借给他，然后A就通过B向C借钱，B借到钱之后再转交给A，在这个过程中B就扮演了一个正向代理的角色，这个过程中，真正借钱的人是谁，C是不知道的。
我们常说的代理也就是指正向代理，正向代理的过程，它隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端请求的服务都被代理服务器代替来请求。
&lt;2&gt;反向代理 还用借钱的例子，A想向C借钱，然后C借给他了，但是实际上这个钱可能C向B借的~至于钱到底是谁的，A是不知道的。这里的C扮演着一个反向代理的角色，客户不知道真正提供服务的人是谁。
反向代理隐藏了真实的服务端，对于客户来说不知道访问的是哪台服务器。
&lt;3&gt;准备工作 1、准备一台真实服务器----tomcat项目。----把一个springboot项目并放入linux服务器系统中。 2、运行springboot项目 java -jar springboot01-demo01.jar
3、配置nginx来代理上面springboot真实项目服务 记得重新加载nginx配置文件:
sbin目录下（./nginx -s reload）
放行端口号：firewall-cmd --add-port=82/tcp --zone=public --permanent
重启防火墙：systemctl restart firewall
4、浏览器访问nginx 2）负载均衡 负载均衡是高可用网络基础架构的关键组件，通常用于将工作负载分布到多个服务器来提高网站、应用、数据库或其他服务的性能和可靠性。
负载均衡通常配合nginx一起使用
准备两台真实服务器：
nginx重新加载配置文件。
3）负载均衡策略 轮询策略。权重策略。ip_hash策略。第三方插件。 （1）轮询策略（默认使用）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5807a6204b14bfdfb5a47c4e2b7f516a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f169943990290407331f336d36f41cd7/" rel="bookmark">
			进程间通信之共享内存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、共享内存实现进程间通信的原理 共享内存实际是操作系统在实际物理内存中开辟的一段内存。
共享内存实现进程间通信，是操作系统在实际物理内存开辟一块空间，一个进程在自己的页表中，将该空间和进程地址空间上的共享区的一块地址空间形成映射关系。另外一进程在页表上，将同一块物理空间和该进程地址空间上的共享区的一块地址空间形成映射关系。 ​ 当一个进程往该空间写入内容时，另外一进程访问该空间，会得到写入的值，即实现了进程间的通信。
要实现进程间通信需要两个进程看到同一块空间，系统开辟的共享内存就是两个进程看到的同一资源。
注意：共享内存实现进程间通信是进程间通信最快的。
二、管理共享内存的数据结构 共享内存实现进程间通信不只仅限于两个进程之间，可以用于多个进程之间。并且系统中可能会有多个进程在进行多个通信。所以系统需要将这些通信的进程管理起来。如果不管理，操作系统怎么知道这块共享内存挂接了哪个进程等信息。
如何管理？就是先描述再组织。
描述共享内存的数据结构里保存了一个ipc_perm结构体，这个结构体保存了IPC(进程将通信)的关键信息。
/* Obsolete, used only for backwards compatibility and libc5 compiles */ struct ipc_perm { __kernel_key_t key;//共享内存的唯一标识符 __kernel_uid_t uid; __kernel_gid_t gid; __kernel_uid_t cuid; __kernel_gid_t cgid; __kernel_mode_t mode; //权限 unsigned short seq; }; 其中key是共享内存的唯一标识。
三、共享内存函数 1、ftok函数 作用：是算出一个唯一的key值返回。
参数：第一个是地址，第二个是至少8为的项目id，不能为0，两参数可以是任意值，但是要符合格式。
返回值：ftok如果成功返回一个key值，如果失败返回-1。如果失败了再重新填写参数即可。
ftok中的参数可以随便填写，但是要符合格式，ftok只是利用参数，再运用一套算法，算出一个唯一的key值返回。这个key值可以传给共享内存参数，作为struct ipc_perm中唯一标识共享内存的key。
#define PATHNAME "." #define PROJID 0x3456 ​ const int gsize=4096;//暂时 ​ key_t getKey() { key_t k=ftok(PATHNAME,PROJID); if(k == -1) { cerr &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f169943990290407331f336d36f41cd7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e58dac5cf3a1082c990a90b1782ac62/" rel="bookmark">
			【C/C&#43;&#43;实现进程间通信 一】共享内存方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前情回顾思路源码Publisher.cppSubscriber.cpp 效果 前情回顾 上一期已经讲解过了进程的相关概念以及进程间通信的实现原理，下面仅展示共享内存方式实现进程间通信的相关代码。
思路 /* 本项目主要用于对同主机上以共享内存方式进行进程间通信的测试 。
1.包含一个外部程序 publisherDemo.exe 以及 subscriberDemo.exe。
2.publisherDemo 主要功能是实现定时信息发布，并将信息发送到共享内存。
3.subscriberDemo 主要功能是实现访问指定共享内存，对publisherDemo.exe进程发布的信息进行捕获。
4.此外，本项目还利用信号量机制实现了进程间的同步发送与接收的功能。
*/
源码 环境：Windows 64位 + QtCreator
涉及到一些WINAPI中的函数，具体函数解析可自行参考WINAPI官方文档
Publisher.cpp #include &lt;QCoreApplication&gt; #include &lt;Windows.h&gt; #include &lt;iostream&gt; using namespace std; #define BUF_SIZE 4096 HANDLE g_EventRead;	// 读信号灯 HANDLE g_EventWrite;	// 写信号灯 // 定义共享数据 char szBuffer[] = "Hello, shared memory!"; /* 读取con1串口的线程 */ DWORD __stdcall WriteThread(const LPVOID lp) { while (true) { WaitForSingleObject(g_EventWrite, INFINITE); // 等待读数据的信号 // 将数据拷贝到共享内存 strcpy((char*)lp, szBuffer); cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e58dac5cf3a1082c990a90b1782ac62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/551bc194774a4d02fa0d3fddb7fba17d/" rel="bookmark">
			【前后端分离开发及项目部署流程】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前后端分离开发技术1 前后端分离开发1.1 介绍1.2 开发流程1.3 前端技术栈（了解） 2 Yapi（定义API接口）2.1 介绍2.2 使用 3 Swagger3.1 介绍3.2 使用方式3.3 常用注解 4 项目部署4.1 部署架构4.2 部署环境说明4.3 部署前端项目4.4 部署后端项目 前后端分离开发技术 背景：
开发人员同时负责前端和后端代码开发，分工不明确开发效率低前后端代码混合在一个工程中，不便于管理对开发人员要求高，人员招聘困难 1 前后端分离开发 1.1 介绍 前后端分离开发，就是在项目开发过程中，对于前端代码的开发由专门的前端开发人员负责，后端代码则由后端开发人员负责，这样可以做到分工明确、各司其职，提高开发效率，前后端代码并行开发，可以加快项目开发进度。
目前，前后端分离开发方式已经被越来越多的公司所采用，成为当前项目开发的主流开发方式。
前后端分离开发后，从工程结构上也会发生变化，即前后端代码不再混合在同一个maven工程中，而是分为前端工程和后端工程。
1.2 开发流程 前后端分离开发后，面临一个问题，就是前端开发人员和后端开发人员如何进行配合来共同开发一个项目？
可以按照如下流程进行：
==接口（API接口）==就是一个http的请求地址，主要就是去定义：请求路径、请求方式、请求参数、响应数据等内容。
1.3 前端技术栈（了解） 开发工具：
Visual Studio Codehbuilder 技术框架：
nodejsVUEElementUImockwebpack 2 Yapi（定义API接口） 2.1 介绍 YApi是高效、易用、功能强大的api管理平台，旨在为开发、产品、测试人员提供更优雅的接口管理服务。可以帮助开发者轻松创建、发布、维护API，YApi还为用户提供了优秀的交互体验，开发人员只需利用平台提供的接口数据写入工具以及简单的点击操作就可以实现接口的管理。
YApi让接口开发更简单高效，让接口的管理更具可读性、可维护性，让团队协作更合理。
源码地址：https://github.com/YMFE/yapi
要使用YApi，需要自己进行部署。
2.2 使用 使用YApi，可以执行下面操作：
添加项目添加分类添加接口编辑接口查看接口导入接口导出接口 3 Swagger 3.1 介绍 使用Swagger你只需要按照它的规范去定义接口及接口相关的信息，再通过Swagger衍生出来的一系列项目和工具，就可以做到生成各种格式的接口文档，以及在线接口调试页面等等。
官网：https://swagger.io/
knife4j是为Java MVC框架集成Swagger生成Api文档的增强解决方案。
Maven坐标：
&lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/dependency&gt; 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/551bc194774a4d02fa0d3fddb7fba17d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/235925f416a8be25105ff4bdbda7da9b/" rel="bookmark">
			CentOS忘记密码重置密码教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言背景介绍：操作步骤 前言 今天打开了很久没有用过的CentOS虚拟机，然后发现我好像将所有的密码全部忘记了，根本登录不进去，最终在网找到了解决办法，这里记录一下，希望对大家有帮助
背景介绍： 在打开CentOS之后，密码输入错误显示是这样的
操作步骤 由于所有的密码都忘记了，包括普通用户和root用户的密码，所以只好重新启动，进入如下界面，在下图界面的情况下按e
然后进入到如下界面
在该界面的时候，按键盘的上下箭头翻页，找到linux16开头的一行内容，然后找到下图红框内的ro，将其替换成rw init=/sysroot/bin/sh。
替换完成后如下图：
之后按cltr + x 执行进入命令行界面，输入chroot /sysroot指令并回车执行：
然后使用passwd root指令重置密码：
输入新密码，并确认新密码。注意这里密码输入之后将不会在屏幕上显示。看到successfully的时候表示密码已经设置成功了。
然后执行touch /.autorelabel更新环境：
然后执行exit退出，之后再执行reboot重启机器，至此，root的密码重设就已经完成了。
等待机器重启之后，会来到这个界面，此时点击未列出，然后输入用户名（root）和密码（刚刚重设的密码）。
然后就会发现，我们已经进来啦！
发现，我们已经进来啦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/436a5f5d999575dac237eec19936135e/" rel="bookmark">
			python爬虫 --协程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
协程的主要概念
一个简单的协程
注册协程的三种方式
使用协程的一般步骤
并发运行协程
gather与wait（此示例来自ChatAl）
aiohttp（此示例来自ChatAl）
异步上下文管理器
通过生成器理解协程
前言 爬虫是IO密集型任务，在爬取过程中需要等待网站的响应，在这个等待过程中我们可以使用并发来加快爬取的效率，实现并发的可以是多线程多进程，那为什么还要使用协程呢？
并发主要是利用程序IO操作时CPU空闲时间调用其他程序运行的方式来提高资源的利用率，但是不管是进程还是线程，切换时都会带来巨大开销，CPU内核的切换，上下文的保存和恢复等。而协程，相较线程来说更加轻量级的；它不被操作系统的内核所管理，完全由程序所控制，不需要CPU内核的切换，也能实现并发。
协程的主要概念 evenloop：事件循环中心，提供了注册，取消，回调任务和回调方法，是一个永久循环，注册函数到这个事件循环中心中，当满足某些条件时再调用此函数。
coroutine：协程，表示协程的对象类型，用async关键字声明的方法为协程方法
await：在协程方法中，await关键字会将耗时等待的操作挂起，让出控制权。如果协程在执行的时候遇到await关键字，事件循环就会将此协程挂起，转而执行别的协程，直到其他协程挂起或者执行完毕。
await后面可等待对象的类型：coroutine，task，future
可以将协程注册到事件循环中心，等待被调用。
一个简单的协程 import asyncio import time async def a(): print('suspending a') await asyncio.sleep(3) print('dead a') async def b(): print('suspending b') await asyncio.sleep(2) print('dead b') async def main(): print(f"started at {time.strftime('%X')}") await a()#挂起协程a await b()#挂起协程b print(f"finished at {time.strftime('%X')}") if __name__ == '__main__': asyncio.run(main()) started at 10:59:25 suspending a dead a suspending b dead b finished at 10:59:30 这个程序声明了三个协程，分别是a，b，main
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/436a5f5d999575dac237eec19936135e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d9c242e955064e6852020739945c711/" rel="bookmark">
			小白月赛C-方豆子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方豆子
题目描述 阿宁最近对吃豆子感兴趣，阿宁想要用程序输出一下，但是图形化对于阿宁来说太难。因此他决定用字符，并且是方形的模样。
给一个正整数n，输出n级好豆子。
题解：每个豆子都由四个豆子组成，包括一级豆子，我们可以把一级豆子看成是四个0级豆子组成，即
0级坏豆子
***
***
***
0级好豆子
...
...
...
因此我们开一个足够大的字符数组，从四个点出发填入四个豆子对应的字符，一直递进到0级，后回填。代码如下。
#include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;stack&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #include&lt;algorithm&gt; using namespace std; queue&lt;long long&gt; q; const int N = 3500; char s[N][N]; string s1 = "..."; string s2 = "***"; void dfs(int u,int f,int x,int y) { if (u == 0) { if (f == 1) { for (int i = x; i &lt;= x + 3; i++) { for (int j = y; j &lt;= y + 3; j++) { s[i][j] = '*'; } } } if (f == 0) { for (int i = x; i &lt;= x + 3; i++) { for (int j = y; j &lt;= y + 3; j++) { s[i][j] = '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d9c242e955064e6852020739945c711/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5eb1b012e09dff4f74def50a0bc9661/" rel="bookmark">
			浙大滨江院Om中心发布首个大规模图文配对遥感数据集，让通用基础模型也能服务遥感领域...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面
2021 年年底，OpenAI 发布了 CLIP，利用带噪的图像-文本配对数据预训练的视觉语言模型，展示了前所未有的图像-文本关联能力，在各种下游任务中取得了惊人的结果。虽然取得了很大的进展，但是这类通用视觉语言基础模型并不能在一些特定域的数据集表现良好，比如遥感数据、医学数据。因此，一个关键的挑战是如何利用现有的通用大规模预训练视觉语言模型，来执行特定于域的迁移，以完成与域相关的下游任务。
在本文中，作者提出了一个新的框架来弥合了通用基础模型和领域特定下游任务之间的差距。此外，作者提出了遥感领域最大的图像-文本配对数据集 RS5M，其中包含 500 万张带有英文描述的遥感图像。该数据集由两方面构成：1）过滤公开的大规模图像-文本配对数据集；2）用预训练的大模型对大规模遥感数据集生成图像描述。
此外，作者还在 RS5M 数据集上尝试了几种参数高效微调方法（PEFT）来实现领域基础模型。实验结果表明，本文提出的数据集在遥感图文相关的下游任务上是有效的，其中在零样本分类任务上将准确率提高了 8%~16%，在遥感视觉语言检索和遥感语义定位任务上也都取得了不错的效果。
论文标题：
RS5M: A Large Scale Vision-Language Dataset for Remote Sensing Vision-Language Foundation Model
论文链接：
https://arxiv.org/abs/2306.11300
代码链接：
https://github.com/om-ai-lab/RS5M
简介
遥感技术（RS）在环境监测、城市规划、自然灾害管理等方面发挥着重要作用。然而，遥感图像数量的急剧增长为高效和有效地处理、分析和理解RS数据中包含的信息带来了新的挑战。在过去的十年中，基于监督的深度学习模型已经成为应对这些挑战的强大工具，在场景分类、目标检测、语义分割和变化检测等 RS 任务中取得了巨大成功。尽管取得了这些进展，但在遥感下游应用中深度学习模型的性能往往因为标注数据集规模太小而受到限制。
此外，遥感图像的解译通常需要专业的领域知识，因此对遥感图像进⾏标注的成本十分昂贵，而这造成了模型在遥感下游任务上性能提升的瓶颈。作为一种对遥感图像的天然监督，配对的文本描述在帮助学习更好的数据表征方面具有很大的潜力。 近几年，深度学习模型在 CV 和 NLP 领域都有了很快速的发展，研究人员开始探索结合视觉和文本模态的潜力，以开发能够理解多模态内容的更强大、更通用的模型。预训练视觉语言模型 (pre-trained VLMs) 是一种很有前景的方法，它可以利用自然语言的词语切分信息和图像中丰富的视觉信息来实现通用基础模型。例如，CLIP 利用对比损失函数连接两个模态，从而在许多下游任务和领域迁移中实现了很强的通用性。
VLM 的另一个重要应用是生成模型，如 DALLE 和 stable-diffusion。然⽽，由于⽬前⼤部分性能优异的视觉语⾔模型都使⽤通⽤物体数据进⾏训练，pre-trained VLMs 通常在特定领域表现不佳，如遥感和医学图像，其原因在于训练数据和下游任务数据的域不够匹配。
为了在 RS 领域中能够更好地利用通用基础模型（GFM）强大的表征提取能力和图文配对能力，使用一个能够利用 GFM 的泛化性的特定域基础模型（DFM），并结合外部的领域先验知识，再通过合适的学习范式将这些知识迁移到特定领域的下游任务模型 (DTM) 十分重要。该过程如下图所示。
之前有工作（比如 FETA）提出了用于专家任务的基础模型，他们使用 LoRA 直接对通用基础模型进行调优，将之用于公共汽车手册和销售目录手册的检索任务，但 GFM→DFM→DTM 结构和 DFM 的重要性并未得到广泛讨论。尽管训练 DFM 所需的数据量可以比训练 GFM 的少很多，但数据量仍然是能否得到一个优质 DFM 的基础。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5eb1b012e09dff4f74def50a0bc9661/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83b2e48793cf37e28f744ac9b85ca4bf/" rel="bookmark">
			使用chatgpt过funcaptcha验证码2个人学习记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		funcaptcha 验证码2 通过记录 **
funcaptcha 那个公司开发的简要介绍：
Funcaptcha是由hCaptcha公司开发的一种人机验证系统。hCaptcha是一家位于美国的人机验证技术提供商，旨在帮助网站和应用程序防止自动化攻击和滥用。
Funcaptcha是hCaptcha提供的一种高级人机验证解决方案。它旨在替代传统的验证码方法，如文字识别或简单的图像选择。Funcaptcha使用了一系列交互式和动态的元素，如拼图、旋转、拖拽等，来提供更强大的人机验证功能。
Funcaptcha的设计目标是增加对自动化攻击和恶意行为的抵抗力，同时提供用户友好的验证体验。它通过使用复杂的图形和用户交互来提高攻击者难以模拟或绕过的难度。
hCaptcha提供Funcaptcha作为一种服务，使网站和应用程序能够集成这种高级的人机验证系统，以保护其资源免受恶意行为的影响。
需要注意的是，本回答基于2021年的信息。有关最新的更新和详细信息，建议参考hCaptcha官方网站或与他们直接联系以获取准确和最新的信息。
**
问题 点击相同图标的格子 大概这个意思 验证码图片大概如下
如何解决？
训练模型计算目标位置
识别正确的
识别失败的
注：
这个系列的产品好像都是如下：
1 响应失败
2 响应成功
3 每个站点不一样 错了会越来越多验证码让你点 全部正确才会响应成功
4 省略…
最后使用代码验证：
由于模型训练的轮数和训练的数据有些脏 成功率不是很高！
代码如下： class funcaptcha2: def __init__(self, email, phoneNum, oldPassword, email_passwd, newPassword): pass def main(self): pass import random def generate_trajectory(start_x, start_y, end_x, end_y, duration, num_points): trajectory = [] # 计算时间间隔 time_step = duration / (num_points - 1) # 生成轨迹点 for i in range(num_points): # 计算时间戳 timestamp = i * time_step # 判断是否是最后两个点 if i == num_points - 2: point_type = 1 elif i == num_points - 1: point_type = 2 else: point_type = 0 # 生成随机坐标 if i == num_points - 2 or i == num_points - 1: x = end_x y = end_y else: x = random.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83b2e48793cf37e28f744ac9b85ca4bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0abecdefd6ef9af9c5ae8a651816604/" rel="bookmark">
			JAVA：POI设置EXCEL单元格格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.Maven引入
2.单元格样式设置
3.单元格值设置
3.1.设置单元格为文本格式
3.2.设置单元格为日期格式
3.3.设置单元格数值格式
3.4.设置单元格为货币格式
3.5.设置单元格为百分比格式
3.6.设置单元格为中文大写格式
3.7.设置单元格为科学计数法格式
本文将介绍POI Excel for Java的格式设置基本用法，包括：单元格样式设置、值设置(文本、小数、百分比、货币、日期、科学计数法和中文大写等)。
1.Maven引入 &lt;poi.version&gt;3.14&lt;/poi.version&gt;
&lt;!-- https://mvnrepository.com/artifact/org.apache.poi/poi --&gt;
&lt;dependency&gt;
&lt;groupId&gt;org.apache.poi&lt;/groupId&gt;
&lt;artifactId&gt;poi&lt;/artifactId&gt;
&lt;version&gt;${poi.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- https://mvnrepository.com/artifact/org.apache.poi/poi-ooxml --&gt;
&lt;dependency&gt;
&lt;groupId&gt;org.apache.poi&lt;/groupId&gt;
&lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt;
&lt;version&gt;${poi.version}&lt;/version&gt;
&lt;/dependency&gt;
2.单元格样式设置 使用Aspose Excel for Java可以方便地设置Excel文件中的样式。下面是一个简单的设置单元格样式的示例代码：
CellStyle cellStyle=wb.createCellStyle(); // 创建单元格样式
cellStyle.setAlignment(HorizontalAlignment.LEFT); // 设置单元格水平方向对其方式
cellStyle.setVerticalAlignment(VerticalAlignment.CENTER); // 设置单元格垂直方向对其方式
cellStyle.setFillForegroundColor(IndexedColors.BROWN.getIndex());//设置背景颜色cellStyle.setFillForegroundColor(IndexedColors.RED.getIndex()); // 设置前景颜色
cellStyle.setBorderBottom(CellStyle.BORDER_THIN); // 底部边框 cellStyle.setBottomBorderColor(IndexedColors.BLACK.getIndex()); // 底部边框颜色
cellStyle.setBorderLeft(CellStyle.BORDER_THIN); // 左边边框
cellStyle.setLeftBorderColor(IndexedColors.RED.getIndex()); // 左边边框颜色
cellStyle.setBorderRight(CellStyle.BORDER_THIN); // 右边边框
cellStyle.setRightBorderColor(IndexedColors.BLUE.getIndex()); // 右边边框颜色
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0abecdefd6ef9af9c5ae8a651816604/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04365c21251d4e710f4e12bd7ddb3d3b/" rel="bookmark">
			Flutter安装升级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、flutter简介 Flutter Widget采用现代响应式框架构建，这是从React中获得的灵感，中心思想是用Widget构建UI。Widget描述了他们的视图在给定其当前配置和状态时应该看起来像什么。当Widget的状态发生变化时，widget会重新构建UI，Flutter会对比前后变化的不同，以确定底层渲染树从一个状态转换到下一个状态所需的最小更改。
Flutter使用dart语言开发，使用前最好有Dart基础。
二、安装 flutter中文网上有详细安装步骤
需要先安装HomeBrew下载Flutter运行flutter doctor根据提示安装配置文件 三、在项目中升级Flutter 1. Flutter分支 stable：flutter稳定分支。
master：开发分支，可以查看最新的变化，稳定性低。
查看当前使用的分支，运行flutter channel
切换分支，flutter channel beta或flutter channel master
2. 为项目制定Flutter SDK 可以在pubspec.yaml文件中指定Flutter SDK的依赖项。例如，以下代码片段指定flutter和flutter_test包使用Flutter SDK。
name: hello_world dependencies: flutter: sdk: flutter dev_dependencies: flutter_test: sdk: flutter 不要使用pub get或pub upgrade命令来管理你的依赖关系。相反，应该使用flutter packages get或flutter packages upgrade。如果您想手动使用pub，则可以通过设置FLUTTER_ROOT环境变量来直接运行它。
3. 升级Flutter channel和packages 要同时更新Flutter SDK和你的依赖包，在你的应用程序根目录（包含pubspec.yaml文件的目录）中运行flutter upgrade命令：
$ flutter upgrade 4. 升级你的依赖包 如果您修改了 pubspec.yaml文件，或者只想更新应用依赖的包（不包括Flutter SDK），请使用以下命令：
flutter packages get获取pubspec.yaml文件中列出的所有依赖包flutter packages upgrade获取pubspec.yaml文件中列出的所有依赖包的最新版本 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dc276182f6952ba00056aaa95378e05/" rel="bookmark">
			GPIO的八种工作模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、GPIO的八种工作模式
1、上拉输入：IO口在无输入的情况下，保持高电平。
2、下拉输入：IO口在无输入的情况下，保持低电平。
3、浮空输入：浮空输入状态下，IO的电平状态是不确定的，完全由外部输入决定，如果在该引脚悬空的情况下，读取该端口的电平是不确定的。
4、模拟输入：输入信号不经施密特触发器直接接入，输入信号为模拟量而非数字量，其余输入方式输入数字量。
5、推挽输出：可以输出高、低电平，连接数字器件；推挽结构一般是指两个三极管分别受两个互补信号的控制，总是在一个三极管导通的时候另一个截止。高低电平由IC的电源决定。导通损耗小、效率高。输出既可以向负载灌电流，也可以从负载抽取电流。推拉式输出级既提高电路的负载能力，又提高开关速度。
6、开漏输出：输出端相当于三极管的集电极，要得到高电平状态需要上拉电阻才行。适合于做电流型的驱动，其吸收电流的能力相对强（一般20mA以内）。开漏形式的电路有以下几个特点：
（1）利用外部电路的驱动能力，减少IC内部的驱动。当IC内部MOSFET导通时，驱动电流是从外部的VCC流经上拉电阻、MOSFET到GND。IC内部仅需很小的栅极驱动电流。
（2）一般来说，开漏是用来连接不同电平的器件，匹配电平用的，因为开漏引脚不连接外部的上拉电阻时，只能输出低电平，如果需要同时具备输出高电平的功能，则需要接上拉电阻，很好的一个优点是通过改变上拉电源的电压，便可以改变传输电平。比如加上上拉电阻就可以提供TTL/CMOS电平输出等。（上拉电阻的阻值决定了逻辑电平转换的速度。阻值越大，速度越低功耗越小，所以负载电阻的选择要兼顾功耗和速度。）
（3）开漏输出提供了灵活的输出方式，但是也有其弱点，就是带来上升沿的延时。因为上升沿是通过外接上拉无源电阻对负载充电，所以当电阻选择小时延时就小，但功耗大；反之延时大功耗小。所以如果对延时有要求，则建议用下降沿输出。
（4）可以将多个开漏输出连接到一条线上。通过一只上拉电阻，在不增加任何器件的情况下，形成“与逻辑”关系，即“线与”。可以简单的理解为：在所有引脚连在一起时，外接一上拉电阻，如果有一个引脚输出为逻辑0，相当于接地，与之并联的回路“相当于被一根导线短路”，所以外电路逻辑电平便为0，只有都为高电平时，与的结果才为逻辑1。
7、复用推挽输出：此时IO受内部外设控制，比如定时器的PWM,比如SPI的MOSI,MISO等。 而普通的推挽输出，则IO受ODR控制。
8、复用开漏输出：参考复用推挽。
二、总结在STM32中选用IO模式
1、浮空输入GPIO_IN_FLOATING ——浮空输入，可以做KEY识别，RX1。
2、带上拉输入GPIO_IPU——IO内部上拉电阻输入。
3、带下拉输入GPIO_IPD—— IO内部下拉电阻输入。
4、模拟输入GPIO_AIN ——应用ADC模拟输入，或者低功耗下省电。
5、开漏输出GPIO_OUT_OD ——IO输出0接GND，IO输出1，悬空，需要外接上拉电阻，才能实现输出高电平。当输出为1时，IO口的状态由上拉电阻拉高电平，但由于是开漏输出模式，这样IO口也就可以由外部电路改变为低电平或不变。可以读IO输入电平变化，实现C51的IO双向功能。
6、推挽输出GPIO_OUT_PP ——IO输出0-接GND， IO输出1 -接VCC，读输入值是未知的。
7、复用功能的推挽输出GPIO_AF_PP ——片内外设功能（I2C的SCL,SDA）。
8、复用功能的开漏输出GPIO_AF_OD——片内外设功能（TX1,MOSI,MISO.SCK.SS）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e93d662aa9279391a4d7b53edf3ff6c8/" rel="bookmark">
			【CSS】nth:children以及浏览器内核webkit使用（滚动条样式修改）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		😉博主：初映CY的前说(前端领域) ,📒本文核心：nth:children以及浏览器中的webkit使用
前言：在页面的编写中使用了多个标签通常有需求去处理下特殊的样式，我们常见做法是给我们的标签加上一个类或者通过标签选择器去写我们的css样式，但是不想写类了还可以用啥选择到我们页面中的dom元素？嘿，这下就可以用上我们的nth-child（）选择器喽~
⭐一、nth-child()选择器 nth-child 是 CSS 选择器中的一个伪类，它可以选择某个父元素的第 N 个子元素，或者符合特定公式的子元素。
使用 :nth-child 选择器的语法为： :nth-child(an + b)。
其中，a 和 b 都是整数，n 表示元素在其父元素中的位置，默认n是0。
nth-child()使用 先绘制下我们的一个静态demo
长下面这个样子：
初始代码：
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box"&gt; &lt;span&gt;元素1&lt;/span&gt; &lt;span&gt;元素2&lt;span&gt;元素3&lt;/span&gt;&lt;/span&gt; &lt;span&gt;元素4&lt;/span&gt; &lt;span&gt;元素5&lt;/span&gt; &lt;/div&gt; &lt;/body&gt; &lt;style&gt; .box{ margin: 0 auto; margin-top: 100px; width: 500px; height: 500px; background-color: teal; text-align: center; line-height: 500px; } .box span{ padding: 20px; font-size: 20px; } &lt;/style&gt; &lt;/html&gt; 我们写选中span试试
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e93d662aa9279391a4d7b53edf3ff6c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34902381897722b168d985d9f50107e8/" rel="bookmark">
			BUUCTF密码基础题——信息时代的进步
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BUUCTF密码基础题——信息时代的进步 题目介绍 也许中国可以早早进入信息化时代，但是被清政府拒绝了。附件中是数十年后一位伟人说的话的密文。请翻译出明文(答案为一串中文！
606046152623600817831216121621196386 解题思路 采用了中文电码加密，用电码工具即可轻易接触答案
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04b12a97a0222ee0f1b01fbd1ed656f1/" rel="bookmark">
			锈湖新作地铁繁花试玩版正式上线啦
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		地铁繁花是锈湖厂商新作点击式解谜冒险解谜游戏，英文名称为“Underground Blossom”，在游戏中你将深入锈湖的地下，扮演并追溯Laura Vanderboom的人生和记忆吧！从一个车站到另一个车站，每个地铁站都象征着劳拉的一段过去和未来。解决各种谜题，找到正确的地铁站并揭开劳拉的时间线之一，同时帮助她理解自己的生活并摆脱思想的腐蚀！
游戏预计会设有 7 个独特的地铁站，每个车站都代表着劳拉·范德布姆的生活、回忆和潜在的未来，预计行程时间为 2 小时。在体验过程中千万别忘了带耳机，在每一个地铁站，你都将听到维克托Butzelaar的音乐，包括大提琴演奏，伴随着音乐体验一场沉浸式的解谜之旅。
tips：本游戏目前是试玩版，而且没有中文，后续游戏正式版开放会第一时间更新，感兴趣的小伙伴可以关注一下！
→游戏资源←
绣湖地铁繁花（Underground Blossom）全流程攻略 著名解谜游戏绣湖系列的最新作品绣湖地铁繁花Underground Blossom日前正式开放了demo试玩。作为一款解谜游戏，虽然只是demo，但也凭借精巧的谜题设计难倒了不少慕名而来的玩家，为了让大家不卡关，我今天梳理了地铁繁花demo的全流程攻略，希望能对你有所帮助。
一、第一章婴儿站
1、开始游戏，选择第一章，婴儿床站，一开始我们需要点击婴儿车，然后就能打开车门下车了。
2、打开地上的旅行箱，可以看到一块白布和锉刀。
3、然后列车开走，我们用奶瓶给婴儿喂奶，用白布给他当尿布，最后用锉刀挑走尿布丢到旁边的垃圾桶里。
4、我们开局会自带一把火柴，我们用火柴点燃垃圾桶，然后垃圾桶会慢慢烧毁，露出一把小铲子。
5、在婴儿车旁边的场景里有一张海报，用铲子把海报刮烂，就看到“THE FUTURE WILL ARRIVE”，也就是未来即将到来的意思。然后海报底部会出现一个神秘符号。
6、回到婴儿车附近，点击女士身上的怀表，就能发现这个符号，然后我们参考海报上的图案来描绘这个图案，需要按照左上、左下、右的顺序来解锁，会出现10点15的时间。
7、然后我们去把站台上的种时间调到10点15分，列车就进站了。
8、点击列车员，会提示我们需要车票。点击列车员右边的口袋，可以获得一枚硬币。
9、我们回到放箱子的地方，去看排水管，用锉刀将断裂的水管取下来，获得断裂的水管和钥匙。
10、然后我们去到垃圾桶旁边的售票处，用钥匙开门，用水管敲击门框，叫醒售票员然后和她互动，提示我们需要一枚硬币。
11、把硬币交到她手上，获得车票，然后回去找列车员。
二、第二章儿童站
1、选择儿童站，剧情一开始劳拉说她想要糖果，然后我们在左下角的小铁门背后可以找到一块泡泡糖。
2、向左，来到有猫头鹰先生雕像的场景，点击地上的海报，得到道具。
3、回到母女身边，向右切换场景，点击墙上的海报，看到提示“从小到大”，我们按照这个顺序依次点击海报中的物体，完成后在海报左上角得到一把钥匙。
4、在旁边的海报框将我们之前得到的海报放上去，但此时的海报暂时不能拉下来。我们需要回到劳拉身边，把口香糖给她吃，然后获得吃完的泡泡糖，用它固定在海报框的底部，然后再展开海报。
5、然后按照海报上提示，依次点击眼睛-手镯-头发-大眼睛-嘴巴，获得电话号码“24355”。
6、回到母女旁边，发现劳拉不见了。点击右边的电话亭，用钥匙打开门，然后拨打24355，发现需要一枚硬币。
7、我们在猫头鹰先生雕像的场景的长椅后面会第一次发现她，然后再去海报所在的场景会再发现她，最后在猫头鹰先生雕像的后面能够找到她。
8、然后在海报场景就能发现劳拉，她手上拿着一块碎片。回到女士身边，用碎片填补右上角的画，然后把它拼好，开启暗格获得把手。
9、去到海报旁边的照相馆，装上把手，拉开帘子，获得报纸。把报纸拿给坐在长椅上的男人，在他看报纸的时候点击他右边的口袋，获得硬币。
10、然后回到电话亭拨打电话，获得提示时间7点。
11、我们去到钟表这边，把时间调成7点，然后列车就来了，劳拉上车后，映照出鹿先生，demo结束。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e83b34cd92694ec622495350e952fc00/" rel="bookmark">
			java 将数据转为树形数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前提 在java中，我们经常需要在前端展示一个树形机构，供用户点击选择，怎么实现呢，js代码
function convertToTreeData(departments, parentId) { const tree = []; departments.forEach(department =&gt; { if (department.parentId === parentId) { const children = convertToTreeData(departments, department.id); if (children.length &gt; 0) { department.children = children; } tree.push(department); } }); return tree; } java后端 和前端代码逻辑一样
public class OrgTreeExp { private String id; private String label; private String parentId; private List&lt;OrgTreeExp&gt; children; public String getId() { return id; } public void setId(String id) { this.id = id; } public String getLabel() { return label; } public void setLabel(String label) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e83b34cd92694ec622495350e952fc00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf27fe96fdbb826bd9499dacc656abb5/" rel="bookmark">
			Java单元测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 高德的技术大佬向老师在谈论方法论时说到：“复杂的问题要简单化，简单的问题要深入化。”
这句话让我感触颇深，这何尝不是一套编写代码的方法——把一个复杂逻辑拆分为许多简单逻辑，然后把每一个简单逻辑进行深入实现，最后把这些简单逻辑整合为复杂逻辑，总结为八字真言即是“化繁为简，由简入繁”。
编写Java单元测试用例，其实就是把“复杂的问题要简单化”——即把一段复杂的代码拆解成一系列简单的单元测试用例；写好Java单元测试用例，其实就是把“简单的问题要深入化”——即学习一套方法、总结一套模式并应用到实践中。这里，作者根据日常的工作经验，总结了一些Java单元测试技巧，以供大家交流和学习。
1. 准备环境 PowerMock是一个扩展了其它如EasyMock等mock框架的、功能更加强大的框架。PowerMock使用一个自定义类加载器和字节码操作来模拟静态方法、构造方法、final类和方法、私有方法、去除静态初始化器等等。
1.1. 引入PowerMock包 为了引入PowerMock包，需要在pom.xml文件中加入下列maven依赖：
&lt;dependency&gt; &lt;groupId&gt;org.powermock&lt;/groupId&gt; &lt;artifactId&gt;powermock-module-junit4&lt;/artifactId&gt; &lt;version&gt;2.0.9&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.powermock&lt;/groupId&gt; &lt;artifactId&gt;powermock-api-mockito2&lt;/artifactId&gt; &lt;version&gt;2.0.9&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 1.2. 集成SpringMVC项目 在SpringMVC项目中，需要在pom.xml文件中加入JUnit的maven依赖：
&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 1.3. 集成SpringBoot项目 在SpringBoot项目中，需要在pom.xml文件中加入JUnit的maven依赖：
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 1.4. 一个简单的测试用例 这里，用List举例，模拟一个不存在的列表，但是返回的列表大小为100。
public class ListTest { @Test public void testSize() { Integer expected = 100; List list = PowerMockito.mock(List.class); PowerMockito.when(list.size()).thenReturn(expected); Integer actual = list.size(); Assert.assertEquals("返回值不相等", expected, actual); } } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf27fe96fdbb826bd9499dacc656abb5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd83877c3c60775f97a7e9e41ff345a6/" rel="bookmark">
			Arcpy脚本处理报错-RuntimeError:Error010240:无法以输出格式TIFF将栅格数据集保存到\路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运行arcpy脚本时总是在不同位置出现这个报错提醒，后来将输出和输入不放在同一个文件夹下就可以正常运行了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/436f46605fa681f17f8ba8b2dc2c4ef0/" rel="bookmark">
			WebStorm开发插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
目录
1.图标插件 Atom Material Icons
2.Translation
3.彩色括号 Rainbow Brackets
4.高亮括号 HighlightBracketPair
5.代码缩略图 CodeGlance2
6.正则插件 any-rule
7.换主题插件 Material Theme UI Lite
8.彩色进度条 Nyan Progress Bar
9.Key promoter
10.idea px 2 rem
11.webstorm设置vscode配置方法
1.设置外观 one dark theme
2.Napalmpapalam Dark Theme
1.图标插件 Atom Material Icons Enable File Icons 文件图标
Enable Directory Icons 目录图标
Enable UI Icons 顶部UI 图标
2.Translation 对于英语不是很好的开发者，在取变量名或者文件名字的时候会犯难。那么就可以给编辑器装一个这个翻译插件。使用也很方便，可以直接选中中文右键翻译，也可以直接选中用快捷键Ctrl+shift+Y。
3.彩色括号 Rainbow Brackets 可以实现配对括号相同颜色。
4.高亮括号 HighlightBracketPair 会在左侧代码行数那显示括号范围，比彩虹括号插件更加直观而且不容易看花眼。
5.代码缩略图 CodeGlance2 6.正则插件 any-rule 安装好后使用方法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/436f46605fa681f17f8ba8b2dc2c4ef0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f2ed67622ca2f4fd8c34fc8530352da/" rel="bookmark">
			nginx部署本地项目如何让异地公网访问？服务器端口映射配置！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接触过IIS或apache的小伙伴们，对nginx是比较容易理解的，nginx有点类似，又有所差异，在选择使用时根据自己本地应用场景来部署使用即可。通过一些对比可能会更加清楚了解：
1.nginx是轻量级，比apache占用更少的内存以及资源
2.apache对php支持较简单，apache组件比nginx多
3.apache是同步多进程模型，一个连接对应一个进程，多个连接（千万级别）可以对应一个进程
4.nginx配置文件简洁，正则配置让很多事情变得简单运行效率高，占用资源少，代理功能强大，很适合做前端响应服务器
5.Apache在处理动态有优势，Nginx并发性较好
那么nginx部署本地项目怎么设置让异地公网访问？没有公网IP的情况下，外网如何连接访问内网服务器端口应用？这里在了解nginx的同时，我们来学习下内网端口映射外网的方法配置。本地nginx或其他中间件部署的项目发布到互联网，让外网也能访问。
这里介绍一种内网映射外网访问的方案：快解析。只要能上网，就可以通过快解析一步映射设置，将内网地址转换成域名让外网访问。具体实现步骤如下参考。
1.明确内网地址是什么
不管是nginx还是其他web服务等，在本地部署好后，确保在局域网内可以正常访问，并记录下对应固定的内网地址端口信息。
2.内网地址与域名关联设置
在nginx服务器本地，或者所在内网互通另台主机电脑上，安装并登快解析添加端口映射设置。通过这一步快解析添加设置，将内网的nginx地址或其他应用项目需要让外网访问的，转换成外网域名地址，提供到互联网上访问。
在添加映射信息时，根据自己本地项目实际情况选择填写即可。
映射名称：自定义，方便区别和标志。
公共端口类型：指外网访问所用的端口，根据自己场景应用需求选择，这里选择的映射类型是网站80端口；
内网地址：内网访问固定地址。可以是固定内网IP或计算机名。如果是在服务器本机使用映射的，推荐填写127.0.0.1格式。
应用程序端口：以实际为准，不可以随便乱填写。
3.外网用域名连接访问
内网快解析映射域名保存生效后，记下对应映射域名（和外网端口号）。然后在任意上网电脑都可以通过这个域名和外网端口进行访问自己的nginx项目了。
如果本地应用项目在内网访问时是带上路径名的，如内网访问http://192.168.6.55:9090/erp/，则映射后外网访问也要对应带上路径名“http://域名:外网端口/erp/”。如果需要外网直接访问根目录域名显示网站内容，则确保应用本身在内网本地配置在内网访问时可以直接访问根目录显示网站内容。
利用快解析端口映射，在不增加硬件设备，无需公网IP情况下，可以上网，就可以实现内网穿透，居家、出差在外的员工及分支机构，可以随时随地远程访问到企业内网对应的服务，访问公司OA、管家婆、FTP、web、CRM、ERP系统进行远程办公。内网穿透还可以帮用户实现在办公室或者家里搭建网站、数据库、远程打印机使用等跨网服务；外网远程桌面连接内网主机；SSH远程；http网站；https站点项目等等。自己搭建服务器，让外网访问内网，快解析一步添加映射外网就可以搞定。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc5f7048947d4f8e3a0d130f76cee9ce/" rel="bookmark">
			Java-面向对象(对象和类)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.面向对象思想2.面向对象与面向过程3.对象和类的概念1).类的定义2).对象的创建和引用1.构造函数2.实例化一个对象3.练习 4.方法的重载 1.面向对象思想 面向对象相比于面向过程是一种更优秀的程序设计方法，它的基本思想是使用类、对象、继承、封装、消息等基本概念进行程序设计。它从现实世界中的客观存在的事物为中心来思考，认识问题。并根据这些事物的本质特点。把它们抽象地表示为系统的类作为系统的基本构成单元。
2.面向对象与面向过程 我要去新疆
面向过程 我开车，我挂挡，我踩油门，我过河北，我过陕西… 面向对象 我命令车去新疆车怎么去不关我事 信息封装在车这个类的内部我不用去了解车整个开动的过程 3.对象和类的概念 对象可以看成是静态属性(成员变量)和动态属性(方法)的封装体。类是用于描述同一类形的对象的一个抽象的概念，类中定义了这一类对象所应具有的成员变量及方法。类可以看成一类对象的模板，对象可以看成该类的一个具体实例。 1).类的定义 格式:
//用class关键字定义一个类 public class Dog { //成员变量 //private作为一种权限修饰符可以修饰类、属性和方法； //用private修饰的类、属性、方法，只能自己使用，别的类是不能访问的 //也就是说对于别的类来说是隐藏不可见的，	//private一般不修饰类，但是可以修饰内部类。 private int id; String name="M"; //给出默认值 Double age; String color; //成员方法 //int 代表的是这个方法返回值的类型； public int getAge() { return age; } //方法无返回值，则定义为void空类型 public void setAge(int i) { age = i; } } 注：在定义成员变量时可以对其初始化，如果不对其初始化，Java使用默认的值对其初始化。局部变量必须要对其初始化。
2).对象的创建和引用 1.构造函数 构造函数是定义在Java类中的一个用来初始化对象的函数构造函数与类同名且没有返回值 方法格式：
[修饰符] 构造器名称(形参列表){ //由零条到多条可执行语句组成的执行体 } 构造器是一个类创建对象的根本途径，如果没有构造器这个类将无法创建对象实例。Java类中提供了一个默认的构造器，如果程序员在提供一个自定义的构造器，前者将被覆盖。
默认构造器：
public Dog(){ } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc5f7048947d4f8e3a0d130f76cee9ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7a20f2892f0283cae257a59d5c84315/" rel="bookmark">
			全国职业院校技能大赛-GZ037工业互联网集成应用赛项-赛题7
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
第一部分 竞赛须知
第二部分 竞赛任务
第一部分 竞赛须知 一、竞赛要求 1.正确使用工具，操作安全规范； 2.竞赛过程中如有异议，可向裁判员反映，不得扰乱赛场秩序； 3.遵守赛场纪律，尊重裁判，服从安排。 二、职业素养与安全意识 1.完成竞赛任务所有操作符合安全操作规范，注意用电安全。 2.遵守赛场纪律，尊重赛场工作人员；爱惜赛场设备、器材。 三、扣分项 1.在竞赛过程中，因操作不当导致设备破坏性损坏或造成事故，视情节扣 10〜20 分，情况严重者取消比赛资格。 2.衣着不整、污染赛场环境、扰乱赛场秩序、干扰裁判工作等不符合职业规范的行为，在模块3中扣除相应职业素养分，情节严重者取消竞赛资格。 四、选手须知 1.任务书如出现缺页、字迹不清等问题，请及时向裁判示意，并进行更换； 比赛结束后，比赛提供的所有纸质材料、U 盘等不得带离赛场。 2.设备的安装配置请严格按照任务书的要求及工艺规范进行操作。 3.参赛团队应在规定时间内完成任务书要求的内容，任务实现过程中形成的文件资料必须存储到 U 盘的指定位置，同时拷贝一份“提交资料”副本至服务器的“D 盘”根目录下，未存储到指定位置的文件均不得分。
4.比赛过程中，选手认定设备或器件有故障可向裁判员提出更换；如器件或设备经测定完好属误判时，器件或设备的认定时间计入比赛时间；如果器件或设备经测定确有故障，则当场更换设备，此过程中（从设备检测开始到更换完成）造成的时间损失，在比赛时间结束后，对该小组进行等量时间延迟补偿。 5.比赛过程中由于人为操作失误造成器件损坏，器件不予更换。 6.在裁判组宣布竞赛结束后，参赛选手应立即停止对竞赛设备与计算机的任 何操作。
第二部分 竞赛任务 一、任务要求
随着新一代信息技术的快速发展，工业互联网技术推动着传统制造业向数字化、智能化方向升级转型。工业设备的标识化与联网化在工业生产上具有重要意义，不仅可以优化生产流程和管理方式，提高生产效率，更可以促进工业化和信息化两化融合，实现工业生产的智能化，对构建现代智能化工业体系具有积极意义。
某数控机床项目计划投资1亿元，拟建设高端智能数控机床基地。主要业务是专业化、自动化、智能化的车削、铣削生产线及加工单元等数控机床产品的研发、生产及销售，产品主要服务汽车零部件、航空航天、轨道交通、汽摩零件、模具等行业，利用边缘计算技术提升信息处理的实时性，另外设计工业互联网平台应用软件实现数据可视化及服务应用。
二、任务环境
硬件资源：计算机、工业互联网集成应用工作站、工业互联网平台、工具箱、耗材等。
软件资源：见U盘中“竞赛资料”文件夹。
三、任务实施
模块一 工业互联网设备安装与调试（35分）
任务1-1 工业互联网设备安装
工业网络技术单元平台上PLC模块与触摸屏程序已编写完成，并下载到设备中。现需要对工业互联网网络设备进行硬件安装、参数设置，并通过现场网线连接，现场总线连接，最后进行运维调试，使其能正常运行使用，在触摸屏展示正确数据。
根据布局图，对工业网络设备的部分硬件进行安装与电气接线。（安装RFID读写头、Lora模块主站、4G DTU三个模块）按照下表1-1所示的参数，设置对应设备的IP地址及端口号。 表1-1 IP地址及端口号
序号
设备名称
IP 地址
端口号
1
网关1
192.168.0.17
20002
2
网关2
192.168.0.18
2009
按照下表1-2所示的参数，使用USB串口调试线设置或通过对现场仪表按键参数设置，进行对应设备的参数设置。 表1-2 参数设置
序号
设备名称
参数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7a20f2892f0283cae257a59d5c84315/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f6e46bbe4dac78bef7f5ee90db3785d/" rel="bookmark">
			process.waitfor()超时配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概述 在编写Java程序时，有时候我们需要调用外部的exe，这时可以通过Runtime的exec()方法，
该命令使用比较简单，但是无法对执行做细节的控制。
通过使用ProcessBuilder构建Process可以进行细节的控制，但是默认process是阻塞的。
public abstract int waitFor() throws InterruptedException; public boolean waitFor(long timeout, TimeUnit unit) 不要被boolean waitFor(long timeout, TimeUnit unit)误解，他也是阻塞的，阻塞到process进程执行完，才进行是否超时的判断。
并不是说当超时时他会自动结束。
通过process.destroy()方法可以从外部终止该process。
但是waitFor时主进程阻塞是阻塞的。我们需要在外部开启一条线程，把waitFor这个阻塞操作放到这条线程，同时主线程进行计时，
如果到了限定时间还未执行完毕，那么就调用process.destroy() kill掉该进程。
二、具体代码思路 首先是一个ProcessWorker类，也就是之前说的用来放置waitFor，阻塞的线程，它继承Thread，实现了run方法。
它记录以下几个状态，通过volatile来确保外部线程可见：
private volatile int exitCode = -99; private volatile boolean completed = false; private volatile String output = ""; 在run方法中，通过try with resource来读取该进程的输出，
并且设置waitFor，当等待结束时，设置completed为true。
try (InputStreamReader reader = new InputStreamReader( process.getInputStream(), DEFAULT_ENCODING)) { StringBuilder log = new StringBuilder(); char[] buffer = new char[BUFFER_SIZE]; int length; while ((length = reader.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f6e46bbe4dac78bef7f5ee90db3785d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44fc616ab3803f7825ad27515751c753/" rel="bookmark">
			Win7如何远程控制Win10电脑？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不同的系统能远程控制吗？ “我有两台不同系统的电脑，一台是Win7电脑，另一台式Win10电脑。Win7系统电脑可以远程控制Win10系统的电脑吗？因为有时我需要Win7远程控制Win10电脑处理一些工作相关的问题，Win7怎么远程控制Win10电脑？提起致谢！”
我们是可以使用Win7远程控制Win10电脑，您可以使用远程桌面或第三方远程控制软件，在Win7远程控制Win10电脑。本文将为您介绍两种Win7远程控制Win10电脑的方法，一起来看看吧！
Win7怎么远程控制Win10电脑？ 本文所介绍的两种Win7远程控制Win10电脑方法，分别是Windows远程桌面和AnyViewer远程桌面，这两种方法都能轻松的帮您实现Win7远程控制Win10电脑。
方法一、Win7使用远程桌面控制Win10 Windows自带的远程桌面除了家庭版系统的电脑无法使用外，其余的大部分都能使用。远程桌面是通过电脑的IP地址在局域网中进行远程控制的，只要您能知道Win10电脑的IP地址就能实现Win7远程控制Win10。
步骤1. 在Win10电脑上打开运行对话框，输入“sysdm.cpl”并单击“确定”。
步骤2. 在系统属性窗口中单击“远程”选项卡，勾选“允许远程连接到此计算机”并保存。
步骤3. 打开命令提示符窗口查询Win10电脑的IP地址，在命令提示符中输入“ipconfig”并回车，其中IPV4就是电脑的IP地址。
步骤4. 在Win7电脑上您可以在搜索框中搜索“远程桌面连接”并将其打开，再输入Win10电脑的IP地址就可以远程控制Win10了。
方法二、Win7使用AnyViewer控制Win10 Win7远程控制Win10电脑，您还可以使用专业的远程控制软件来实现。AnyViewer是一款适用于Windows个人电脑的远程桌面软件，它可以安全的远程控制Windows电脑，支持电脑传输文件到另一台电脑。
当您遇到Win7远程桌面连接不上时，可以使用AnyViewer在Win7远程控制Win10电脑。您可以打开下载中心将软件安装到Win7和Win10电脑上，然后再按照以下步骤操作，就可以远程控制Win10电脑。
步骤1. 在Win7电脑上运行AnyViewer远程桌面软件，选择“连接”，输入Win10电脑的设备ID，再单击“连接”按钮。
步骤2. 选择“向伙伴发送控制请求”，再单击“确定”。
步骤3. Win10电脑将收到Win7的控制请求，单击“同意”既可远程控制电脑。
当您成功的远程控制Win10电脑后，您可以根据自己的网络情况更改远程桌面的画质，而且在AnyViewer远程桌面窗口的工具栏中，还提供了许多其他实用功能。如：远程关闭电脑、更改远程桌面分辨率、任务管理器等。
总结 如果您想使用Win7远程控制Win10电脑，可以使用远程桌面来实现，或者使用第三方远程桌面AnyViewer轻松的远程控制Win10电脑。若您远程控制的Win10电脑面前没有人操作，可以使用AnyViewer进行远程控制，因为该软件支持无人值守远程控制，即控制的电脑没有人也能实现远程控制。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dbaab17712e38b950909cec404d9206/" rel="bookmark">
			远程桌面分辨率太小怎么调整？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows远程桌面分辨率怎么调整？
在远程控制电脑期间是无法修改远程桌面分辨率的，那么远程桌面分辨率怎么调整呢？调整远程桌面分辨率的唯一方法是在建立远程会话之前提前更改屏幕分辨率，这里我们将详细介绍调整远程桌面分辨率的方法，一起来看看吧！
编辑显示配置以更改远程桌面大小
如何调整远程桌面的大小？我们可以进入远程桌面连接的显示配置中以更改远程桌面的大小。
步骤1. 远程桌面分辨率太小您可以在搜索框中搜索“远程桌面连接”，然后将其打开。
步骤2. 在远程桌面连接窗口中单击“显示选项”。
步骤3. 切换到“显示”选项卡，找到显示配置，您会在中间看到一个滑块，然后滑动滑块以选择想要的分辨率。
结语
这篇文章主要介绍了如何在Windows中解决远程桌面分辨率太小的问题。因为您无法在远程会话期间更改它，因此，在建立连接之前您可以在显示配置中调整远程桌面分辨率的大小。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d28ad3f91280bb513436cd2ac84c17de/" rel="bookmark">
			自动驾驶BEV感知系列算法整理总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		序论 BEV系列的感知算法是指在BEV上进行预测分割，这样对于下游任务更加友好，而BEV算法类别之间最大的区别就是在图像特征到BEV转换这一块(img2bev)，根据这一块不同，我们将算法分为三类：
第一类显示转换：根据像素坐标以及模型预测的像素深度分布得到(x,y,z)，然后通过相机内外参转换到BEV上得到BEV下的(X,Y,Z)
第二类隐式转换：首先根据BEV上的分辨率进行位置编码同时加上lidar特征，然后让其作为transformer里的Q查询向量往图像特征，图像位置编码和内外参编码组成的KV里面查询，经过交叉注意力机制最终输出查询后得到的BEV特征。
第三类显示逆向转换：显式转换是将图像向BEV转，那我直接先指定好BEV空间的体素位置，根据体素的位置(X,Y,Z)这样根据内外参可以查询得到像素空间的(x,y,z)直接把对应的像素特征赋给BEV的体素。
一、显示转换的BEV感知 1.LSS 论文链接：https://arxiv.org/pdf/2008.05711.pdf
代码链接：GitHub - nv-tlabs/lift-splat-shoot: Lift, Splat, Shoot: Encoding Images from Arbitrary Camera Rigs by Implicitly Unprojecting to 3D (ECCV 2020)
概述：LSS的思想是对每个像素预测一个D维的深度分布，然后HWD与HWC外积，得到一个HWDC的特征，给定一个hwd，我们根据相机内外参可以将其转化到BEV空间里的一个XYZ，这样把所有像素空间的HWD都转到BEV，最终按照体素pooling池化一下，就得到了BEV特征
优点：实现了相机特征到BEV特征的转换
缺点：极度的依赖depth预测的准确性，同时矩阵外积过于耗时，要想在depth维度有较高的精度，HWD计算量特别大。
A:Lift操作 LSS中的L表示lift，升维的意思，表示把H*W*C的图像特征升维到H*W*D*C，D表示在每个像素点都预测了一个D维的深度信息，比如D是50维，相当于这个像素点在0-50m里出现的概率。D的一个维度表示在这一米出现的概率。
第一步：get_geometry（得到特征图与3D空间的索引对应）
torch.arange生成D的列表，view加expand变成（D,H,W）的维度
torch.linespace生成特征图长宽HW的列表分布，里面的值是像素坐标，同样view+expand变为(D,H,W)，然后用torch.stack将这三个在-1维度拼接。得到（D,H,W,3）的矩阵，相当于给定一个D,H,W的特征点，我们可以得到三维的像素坐标表示，这个像素坐标需要转换到真实车身坐标系。
将图像数据增强进行抵消，同时根据相机内外参矩阵与上面的相乘，得到（D,H,W,3）这个3表示的就是车身坐标系的3D位置。此时我们就可以根据一个D,H,W索引的特征点，得到其在真实空间的位置。这一步是接下来投影的关键。
第二步：get_cam_feats（得到相机的D,H,W型feature）
图像经过骨干网络处理之后，用一个1*1的卷积，将channel变为D+C，在channel维度选取前D维，进行softmax操作，相当于说这个H,W的特征点在D的深度上的分布概率。将(N,1,D)和(N,C,1)做乘法，相当于矩阵外积，得到（N,C,D)的张量，N表示的是H*W,所以我们就得到了(D,H,W,C)的图像特征。
B：Splat操作 splat表示拍平的意思，上一步我们得到了像素空间与真实3D空间的坐标索引，同时也得到了(D,H,W,C)的图像特征高维表示。这一步就是把特征转换到BEV空间中，并拍平为2D，相当于pointpillar的操作。
第一步：预处理操作
传进来的就是geom_feats维度为(D,H,W,3)和X图像高维特征(D,H,W,C),首先geom_feats里3这个维度，里面的值是车身坐标系的3D位置，有正有负，我们先把他变为从0开始的长整形分布，比如x是0-100m，y是0-60m，z是0-5m这样，全为正的表示，相当于做个平移。然后view成(Nprime,3)，然后循环batch，用torch.cat以及torch.full生成一个(Nprime,1)的batch索引，再和geom_feats用torch.cat一下，得到新的geom_feats维度为(Nprime,4)，里面是真实空间的xyzb，然后用xyz的范围进行过滤一下。
第二步：拍平操作
得到维度为(Nprime,4)的geom_feats,这里说的也不准确，因为过滤了范围外的，第一维度就不再是Nprime,大家理解就行。然后根据BEV分辨率对geom_feats进行排序，geom_feats[:,0]*Y*Z*B+geom_feats[:,1]*Z*B+geom_feats[:,2]*B+geom_feats[:,3],然后argsort排序，对X以及geom_feats进行排序。X维度为(Nprime,C),对其进行cumsum操作，也叫前缀和操作，然后找到网格变化的节点，用当前变化节点减去前面的变化节点，就是中间这个网格的和，起到了一个sum_pooling操作，最后根据geom_feats的索引，把X放入到(B,C,Z,X,Y)里面，再把Z用unbind和cat操作压缩即可。
代码分析 """ Copyright (C) 2020 NVIDIA Corporation. All rights reserved. Licensed under the NVIDIA Source Code License. See LICENSE at https://github.com/nv-tlabs/lift-splat-shoot. Authors: Jonah Philion and Sanja Fidler "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d28ad3f91280bb513436cd2ac84c17de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e1fcae9229ac5439355bf38aa8cbd7f/" rel="bookmark">
			基于stm32cubemx的串口中断处理（stm32F205）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cubemx工具在图形界面设置了相应参数会自动生成初始化相关配置。
串口初始化过程中不同函数的作用
MX_USART1_UART_Init()函数用于设置UART的基本参数；
HAL_UART_MspInit()函数配置与UART相关的GPIO引脚、时钟使能、配置中断优先级及中断使能；
HAL_UART_Init()函数最终初始化UART外设，并将寄存器配置为正确的值。
初始化后，中断开启，收发自动触发中断。
void MX_USART1_UART_Init(void) { /* USER CODE BEGIN USART1_Init 0 */ /* USER CODE END USART1_Init 0 */ /* USER CODE BEGIN USART1_Init 1 */ /* USER CODE END USART1_Init 1 */ huart1.Instance = USART1; huart1.Init.BaudRate = 115200; huart1.Init.WordLength = UART_WORDLENGTH_8B; huart1.Init.StopBits = UART_STOPBITS_1; huart1.Init.Parity = UART_PARITY_NONE; huart1.Init.Mode = UART_MODE_TX_RX; huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE; huart1.Init.OverSampling = UART_OVERSAMPLING_16; if (HAL_UART_Init(&amp;huart1) != HAL_OK) { Error_Handler(); } /* USER CODE BEGIN USART1_Init 2 */ HAL_UART_Receive_IT(&amp;huart1, huart1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e1fcae9229ac5439355bf38aa8cbd7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d28a0bf773a9e8020ab1cfd231e3a75/" rel="bookmark">
			java常见面试题（160道）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. JDK 和 JRE 有什么区别？ JDK：Java Development Kit 的简称，Java 开发工具包，提供了 Java 的开发环境和运行环境。JRE：Java Runtime Environment 的简称，Java 运行环境，为 Java 的运行提供了所需环境。 具体来说 JDK 其实包含了 JRE，同时还包含了编译 Java 源码的编译器 Javac，还包含了很多 Java 程序调试和分析的工具。简单来说：如果你需要运行 Java 程序，只需安装 JRE 就可以了，如果你需要编写 Java 程序，需要安装 JDK。
2. == 和 equals 的区别是什么？ 基本数据类型：比较的值是否相等；
引用数据类型：如String，==比较的是引用是否指向同一块内存；euqals被重写了，比较的是引用指向内存中的值是否相等
String、StringBuffer和StringBuilder的区别？ String 大小固定，不可变
StringBuffer 大小可变，线程安全（有锁），同步，效率低，适用于多线程，低并发
StringBuilder 大小可变，线程不安全（无锁），不同步，效率高，适用于单线程，高并发
4. final 在 Java 中有什么作用？ final 修饰的类叫最终类，该类不能被继承。
final 修饰的方法不能被重写。
final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。
5. Java 中的 Math. round(-1. 5) 等于多少？ 等于 -1，因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是往上取整，负 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d28a0bf773a9e8020ab1cfd231e3a75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7622df283000c76f1a70d42a508d34a/" rel="bookmark">
			基于Spring Boot的在线作业管理系统的设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学校的作业管理本身就是一个繁琐复杂的事情。用计算机技术和互联网技术，设计开发出一套学生作业管理系统，来提高学校作业管理的工作效率，在减少繁重工作同时可以有效避免问题的出现。
本课题系统后端采用Spring Boot和MyBatis，开发一套在线作业管理系统，前端UI框架采用Bootstrap，使用Idea开发工具进行开发，利用MySQL数据库对数据进行存取管理；采用Java编程语言技术进行应用程序的编写，实现用户执行的操作业务逻辑。系统分为系统学生和教师两种用户。学生可以进行对课程的选择、作业的提交和成绩的查询；老师可以添加课程、布置作业和维护学生成绩等。通过这套系统可以使学生更方便的选择课程、提交作业和查看成绩，老师便于对作业的布置及批阅给分，不但减轻了对学生作业管理的工作强度，还提高了对学生作业管理的效率。
关键词：在线作业管理系统；Spring Boot；MyBatis；MySQL 1.3 本文主要研究内容
本课题旨在研究设计在线作业管理系统。其研究方向为Web应用开发。预期能够网络集中化管理学生信息、课程信息及作业完成情况，及时高效完成学生与老师间的沟通，提高教师对学生作业管理工作效率，降低教师工作成本，该作业管理系统具有画面简单、容易操作等特点。
主要研究目标为设置学生登录操作选择课程以及提交、修改和查看作业；教师登录操作添加导入学生和课程信息，发布并批改作业等各项功能。
系统后端采用Spring Boot和MyBatis，结合MySQL数据库，前端UI框架采用Bootstrap。使用Idea开发工具进行开发。本项目主要目的是实现教师在统一平台上对不同班级、不同学科的学生的作业进行发布、修改、批改等一系列操作，实现在线作业管理等功能。
本小节将对此项目的系统功能需求和功能结构进行阐述。从识别系统相关者功能需求模型建立环节，系统数据环节，相应过程的加工说明环节，数据字典的建立环节和运行系统的运行环境需求环节这五个方面来对系统功能需求进行说明。
2.1 系统需求与功能结构
2.2.1 确定业务参与者
基于Java Web的在线作业管理系统的阐述与研究开发方法是以识别业务参与者权限信息为目标，采用了参与者词汇表，在此表的根基上详细阐述系统的使用权限，同义词和描述方法。
参与者词汇表如表2-1所示。
表2-1 参与者词汇表
序号
词汇
同义词
描述
1
教师用户
管理员
登录系统后可以对系统所有信息进行管理
2
学生用户
普通用户
登录系统后可以使用与之权限相对应的功能
用例词汇表如表2-2所示。
表2-2 用例词汇表
序号
用例名称
用例描述
参与者
1
注册登录
用户和管理员使用系统之前需要先注册登录
学生用户，教师用户
2
学生管理
管理员对学生的信息进行管理
教师用户
3
教师管理
管理员对教师的信息进行管理
教师用户
4
班级管理
管理员对班级信息进行管理或浏览
教师用户
5
作业管理
用户和管理员对作业信息进行布置管理或浏览
学生用户，教师用户
6
课程信息管理
管理员对课程信息进行管理
教师用户
7
选择课程管理
用户对课程进行选择，取消操作
学生用户
2.4.1 软件结构图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7622df283000c76f1a70d42a508d34a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c30bc385095accd230c33a25e42c2bcd/" rel="bookmark">
			sonarqube安装以及jenkins集成sonarqube
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、sonarqube安装 docker方式安装sonarqube docker 方式安装是最简便的，我选择了这个安装方式
1、下载镜像
docker pull postgres:latest docker pull sonarqube 2、 创建挂载目录
#用于postgres的挂载目录 mkdir -p /opt/postgres/postgresql mkdir -p /opt/postgres/data mkdir -p /opt/sonarqube/logs mkdir -p /opt/sonarqube/conf mkdir -p /opt/sonarqube/data mkdir -p /opt/sonarqube/extensions 3、运行容器
docker run --name postgres -d -p 5432:5432 --net sonarqube \ -v /opt/postgres/postgresql:/var/lib/postgresql \ -v /opt/postgres/data:/var/lib/postgresql/data \ -v /etc/localtime:/etc/localtime:ro \ -e POSTGRES_USER=sonar \ -e POSTGRES_PASSWORD=sonar \ -e POSTGRES_DB=sonar \ -e TZ=Asia/Shanghai \ --restart always \ --privileged=true \ --network-alias postgres \ postgres:latest docker run -d --name sonarqube -p 9090:9000 \ -e ALLOW_EMPTY_PASSWORD=yes \ -e SONARQUBE_DATABASE_USER=sonar \ -e SONARQUBE_DATABASE_NAME=sonar \ -e SONARQUBE_DATABASE_PASSWORD=sonar \ -e SONARQUBE_JDBC_URL="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c30bc385095accd230c33a25e42c2bcd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1945c96c88b9b218ca4bde9cb0c8532/" rel="bookmark">
			windows系统根据端口查询pid并结束进程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用管理员权限打开命令指示符,输入命令：
1、查看被占用端口所对应的 PID
netstat -aon|findstr + “端口号”
2、查看指定PID的进程
tasklist|findstr ”57672”
3、结束进程
taskkill -pid 进程号 -f
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a72b00593ff741123861a8595592744/" rel="bookmark">
			sql to_date &amp;&amp; to_timestamp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.二者区别： to_data 转换为 普通的时间格式
to_timestamp 转换可为 时间戳格式
2.使用误区： 比较同一天 日期大小的时候
select current_timestamp &lt;= to_date('2018-03-12 18:47:35','yyyy-MM-dd hh24:mi:ss') from pub_employee
执行该sql不一定获取全部结果
原因：
select to_date('2018-03-12 18:47:35','yyyy-MM-dd hh24:mi:ss') from pub_employee
的结果并不是时间戳，而是2018-03-12
正确的写法
select current_timestamp &lt;= to_timestamp('2018-03-12 18:47:35','yyyy-MM-dd hh24:mi:ss') from pub_employee
3.to_date: 方式一：正确
select to_date('2018-03-08','yyyy-MM-dd') from pub_employee
方式二：
select to_date('2018-03-08 18:55:33','yyyy-MM-dd') from pub_employee
方式三：
select to_date('2018-03-08 18:55:33','yyyy-MM-dd hh24:mi:ss') from pub_employee
返回的均为2018-03-08
4.to_timestamp: 方式一：
select to_timestamp('2018-03-08','yyyy-MM-dd') from pub_employee
方式二：
select to_timestamp('2018-03-08 18:55:33','yyyy-MM-dd') from pub_employee
方式一和二都是以下格式，虽然都是时间戳，但是后面一截是2018-03-08 00:00:00
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a72b00593ff741123861a8595592744/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66190bf6ae9159c7eb3eb047d54dd43c/" rel="bookmark">
			解决WebStorm引入第三方 JS 库无代码提示的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
问题
解决方案
1.使用快捷键ctrl+alt+s打开设置
2.依次点开：语言和框架-&gt;JavaScript-&gt;库
3.下载安装
4.成功
问题 最近练习vue项目，引入了消息订阅的库，然后没有提示，还提示‘未解析的函数或方法xxx’
解决方案 1.使用快捷键ctrl+alt+s打开设置 2.依次点开：语言和框架-&gt;JavaScript-&gt;库 3.下载安装 4.成功 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0319de068a58d33315d7b4a6cf3f865f/" rel="bookmark">
			关于Mybatis使用时间排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 MyBatis Plus 中，可以使用 orderBy 方法来按时间排序查询结果。下面是按时间排序的示例代码：
java
QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.orderByDesc("create_time"); List&lt;User&gt; userList = userMapper.selectList(queryWrapper); 上述代码中，假设我们有一个 User 实体类，其中包含一个名为 create_time 的时间字段。我们使用 QueryWrapper 创建查询条件，并调用 orderByDesc 方法来按照 create_time 字段进行降序排序。
这样，执行查询后，userList 将按照 create_time 字段的倒序排列。如果要进行升序排序，可以使用 orderByAsc 方法替代 orderByDesc 方法。
注意，在实际使用中，根据数据库的不同，时间字段的命名可能会有所变化，请将 create_time 替换为你实际的时间字段名。另外，需要确保数据库中的时间字段是可以进行排序的类型，如日期时间类型。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44a32dbd3a7c777b7a9466f28eb27f87/" rel="bookmark">
			java如何判断接口传来得json是哪个类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于这个问题我们可以用以下代码来判断
使用反射实现动态判断：通过遍历所有可能的类，对比 JSON 内容与类的字段是否匹配来确定对应的类。这种方式适用于已知的类名有限且固定的情况。
// 假设 json 是接口传来的 JSON 字符串 String json = "{\"name\":\"John\",\"age\":25}"; // 假设有两个类 A 和 B，分别代表 JSON 数据的两种可能类型 Class&lt;?&gt; classA = A.class; Class&lt;?&gt; classB = B.class; ObjectMapper objectMapper = new ObjectMapper(); JsonNode jsonNode = objectMapper.readTree(json); // 遍历所有可能的类，判断 JSON 内容与类的字段是否匹配 if (objectMapper.convertValue(jsonNode, classA) != null) { // JSON 与 classA 匹配 } else if (objectMapper.convertValue(jsonNode, classB) != null) { // JSON 与 classB 匹配 } else { // JSON 与其他类不匹配 } 使用类的特定字段判断：根据 JSON 内容中的特定字段来判断对应的类。这种方式适用于 JSON 内容中包含了标识字段或特定字段来表示不同类的情况。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44a32dbd3a7c777b7a9466f28eb27f87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1087c56ce7b90b9c5956188fb3ae4010/" rel="bookmark">
			FreeRTOS_调度器开启和任务相关函数详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言 1. 调度器开启过程分析
1.1 指令集
1.2 任务调度器开启函数分析
1.2.1 内核相关硬件初始化函数分析
1.2.2 使能 FPU 函数分析
1.2.3 启动第一个任务
1.2.4 SVC 中断服务函数
1.2.5 空闲任务
2. 任务创建过程分析
2.1 任务创建函数分析
2.2 任务初始化函数分析
2.3 任务堆栈初始化函数分析
2.4 添加任务到就绪列表
3. 任务删除过程分析
4. 任务挂起过程分析
5. 任务恢复过程分析
前言 在之前的学习过程中，已经学习了 FreeRTOS 的任务创建和删除，挂起和恢复等基本操作，并且也学习了分析 FreeRTOS 源码所必须掌握的知识：列表和列表项。但是深究其过程，任务究竟是如何被创建、删除、挂起和恢复的？以及系统是如何被启动的？这些我们还并不了解，一个操作系统最核心的内容就是多任务管理，所以我们非常有必要去学习一下 FreeRTOS 的任务创建、删除、挂起、恢复和系统启动等。
1. 调度器开启过程分析 在学习调度器开启过程之前，我们先来学习以下 ARM 的相关汇编指令。
1.1 指令集 汇编语言：基本语法
汇编指令的最典型书写模式如下所示：
标号
操作码 操作数1，操作数2，…… ；注释。
其中，标号是可选的，如果有，它必须顶格写。标号的作用是让汇编器来计算程序转移的地址。
操作码是指令的助记符，它的前面必须有至少一个空白符，通常使用一个 “Tab” 键来产生。操作码后面往往跟随若干个操作数，而第 1 个操作数，通常都给出本指令执行结果的存储地。不同指令需要不同数目的操作数，并且对操作数的语法要求也可以不同。举例来说，操作数必须以 “#” 开头，如
MOV R0， #0x12 ；R0 &lt;—— 0x12
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1087c56ce7b90b9c5956188fb3ae4010/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30083677214f1fefdd330c7151c34ad6/" rel="bookmark">
			小米商城（HTML5&#43;CSS3版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正在学习HTML5+CSS3的小伙伴们如果想练手的话，可以先照着小米商城的网站敲。因为还没有学到JS，下面代码只实现了部分功能：
index：html
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;小米官网&lt;/title&gt; &lt;link rel="stylesheet" href="css/xiaomi.css"&gt; &lt;link rel="icon" href="//s01.mifile.cn/favicon.ico" type="image/x-icon" /&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 小米顶部广告 --&gt; &lt;div class="advertisement w2"&gt;&lt;/div&gt; &lt;!-- 小米导航栏 --&gt; &lt;div class="nav w2"&gt; &lt;div class="header w1"&gt; &lt;div class="nav-left"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=""&gt;小米商城&lt;/a&gt;&lt;span&gt;|&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;MIUI&lt;/a&gt;&lt;span&gt;|&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;IoT&lt;/a&gt;&lt;span&gt;|&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;云服务&lt;/a&gt;&lt;span&gt;|&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;天星数科&lt;/a&gt;&lt;span&gt;|&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;有品&lt;/a&gt;&lt;span&gt;|&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;小爱开放平台&lt;/a&gt;&lt;span&gt;|&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;企业团购&lt;/a&gt;&lt;span&gt;|&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;资质证照&lt;/a&gt;&lt;span&gt;|&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;协议规则&lt;/a&gt;&lt;span&gt;|&lt;/span&gt;&lt;/li&gt; &lt;li&gt; &lt;div class="app"&gt; &lt;a href="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30083677214f1fefdd330c7151c34ad6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/895d265f9d600214549af05d988874ac/" rel="bookmark">
			Vue2使用富文本编译器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可以先看看我之前的一篇文章，属于基础吧
在页面使用富文本编译器_超*的博客-CSDN博客
至于为什么还是用TinyMCE，不用ElementUI自带的富文本编译器，因为技穷/(ㄒoㄒ)/~~
同样参考一篇文章(进行修改、完善)：
VUE2下版本的项目加入富文本框实现_vue2富文本从js文件夹加载_我算哪枝小绿植的博客-CSDN博客
1、下载资源 npm install tinymce -S npm install @tinymce/tinymce-vue@3.0.1 2、 开始 这里说一下，按照原博主的步骤是将node_module文件下的tinymce文件，拷贝一份到静态资源目录中。不要去拷贝到资源目录中，vue默认就会到node_modules中去找相应文件！
下载中文语言包，看我上面那篇基础文章。
创建一个组件，在组件中引入tinymce组件并初始化：
&lt;template&gt; &lt;tinymce :init="init" v-model="content"&gt;&lt;/tinymce&gt; &lt;/template&gt; &lt;script&gt; //引入tinymce组件 import Editor from "@tinymce/tinymce-vue"; export default { name: 'tinymceTest', data(){ return { init: { language_url: "./zh_CN.js", //中文语言包路径 language: "zh_CN", //声明富文本的语言类型 height: 430, menubar: true,//是否显示上面菜单 plugins: "link lists image code table colorpicker textcolor wordcount contextmenu", toolbar: "bold italic underline strikethrough | fontsizeselect | forecolor backcolor | alignleft aligncenter alignright alignjustify|bullist numlist |outdent indent blockquote | undo redo | link unlink image code | removeformat"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/895d265f9d600214549af05d988874ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a55124d038136a3200ca6bca113ad64/" rel="bookmark">
			物化视图功能验证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		物化视图(Materialized View)和视图(View)类似，也是一个视图名字对应一个SQL查询查询语句。不同之处在于：物化视图定义时使用了额外的关键字materialized， 它把结果集保存在起来，查询的时候直接读取保存的结果集，而不必扫描原始表。物化视图的结果集（即物化视图自己的数据）的存储和扫描方式和普通表的方式相同。
创建测试表 ---- 创建测试表 drop table if exists DIM_OFFER; create table DIM_OFFER ( OFFER_ID numeric(20) DEFAULT NULL, OFFER_TYPE varchar(100) DEFAULT NULL, PAY_TYPE varchar(2) DEFAULT NULL, TRADEMARK varchar(20) DEFAULT NULL, BUSI_TYPE varchar(6) DEFAULT NULL, OFFER_PLAN_TYPE varchar(6) DEFAULT NULL, PROD_SPECID varchar(20) DEFAULT NULL, PACKED_FLAG varchar(6) DEFAULT NULL, IS_GLOBAL varchar(6) DEFAULT NULL, DAILY_EFFECT varchar(6) DEFAULT NULL, STOP_DISPOSE varchar(6) DEFAULT NULL, MODIFY_DATE varchar(20) DEFAULT NULL, MODIFIER varchar(20) DEFAULT NULL, CREATE_DATE varchar(20) DEFAULT NULL, CREATER varchar(20) DEFAULT NULL, DEL_FLAG varchar(2) DEFAULT NULL, PRIMARY KEY(OFFER_ID) ); select create_reference_table('DIM_OFFER'); 创建物化视图 ---- 创建物化视图 SELECT run_command_on_workers($cmd$ drop MATERIALIZED VIEW if exists dim_offer_v; create MATERIALIZED VIEW dim_offer_v AS select OFFER_ID,OFFER_TYPE,PAY_TYPE,TRADEMARK,BUSI_TYPE,OFFER_PLAN_TYPE,PROD_SPECID from DIM_OFFER; $cmd$); 创建索引 SELECT run_command_on_workers($cmd$ create unique index index_dim_offer_v_offer_id ON dim_offer_v ( OFFER_ID ); $cmd$); 加载数据 ---- 导入数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a55124d038136a3200ca6bca113ad64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6938afda6c22a0f3a3fc44e228fac71/" rel="bookmark">
			一定能解决ROS系统 rosdep update超时问题de简单方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		rosdep update命令使用 该方法是可以跳过sudo rosdep init初始化命令设置的，前提是安装ros：(https://blog.csdn.net/weixin_44023934/article/details/127510378，rosdep update是安装一些依赖库，比如在Cartographer、ORB-SLAM等算法需要使用到一些依赖库，是必须安装的，如果不是有需要的，只是使用ros一般依赖，是不需要rosdep update的
注意 本方案在18.04和16.04测试都没问题，20.04Ubuntu版本可能需要对路径的python2.7改成python3.0。 1、下载链接文件 1.1首先将下面仓库的内容clone到本地 方法一： csdn资源直接下载rosdistro,解压到home目录
方法二(推荐)： //跳到home目录
cd //下载文件
git clone https://github.com/ros/rosdistro.git 需要记得将下载包名字rosdistro-master。。。。改称rosdistro
方法三： 如果git clone 速度较慢，可以直接拷贝https://github.com/ros/rosdistro.git到网页下载，速度提高，
1.2 将rosdistro文件拷贝到etc/ros/目录下 （1）、如果文件为rosdistro-master，需要记得将下载包名字rosdistro-master改称rosdistro
//跳到rosdistro文件目录下 cd //拷贝文件 sudo cp -r rosdistro /etc/ros/ 2、修改系统文件 2.1 修改/usr/lib/python2.7/dist-packages/rosdep2/rep3.py文件 cd /usr/lib/python2.7/dist-packages/rosdep2 sudo gedit rep3.py 注意：如果进去不到rosdep2文件夹，直接在usr文件夹下搜索rep3.py。就能查找到对应的路径，以下方法同样。
将REP3_TARGETS_URL = ‘https://raw.githubusercontent.com/ros/rosdistro/master/releases/targets.yaml’ 替换成 REP3_TARGETS_URL = 'file:///etc/ros/rosdistro/releases/targets.yaml'
2.2 修改/usr/lib/python2.7/dist-packages/rosdistro/__init__.py文件 cd /usr/lib/python2.7/dist-packages/rosdistro sudo gedit __init__.py 将原来文件中的 DEFAULT_INDEX_URL = ‘https://raw.githubusercontent.com/ros/rosdistro/master/index-v4.yaml’ 替换成 DEFAULT_INDEX_URL = 'file:///etc/ros/rosdistro/index-v4.yaml'
3、配置20-default.list文件 如果者查看/etc/ros/rosdep/sources.list.d路径已经有20-default.list文件（之前已经运行过sudo rosdep init的原因），就直接跳过3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6938afda6c22a0f3a3fc44e228fac71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c317b261860b4effa66a14c6ebc7f61f/" rel="bookmark">
			解决nginx访问url时，url结尾自动补全/
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		rewrite ^代理之后的地址以什么开头(.*)([^/])$ 代理url
([^/])$其中这个会自动检查你代理的url的结尾有没有/ 如果没有则自动补全，如果有，则直接访问
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0706d98b0192d3666401bd862eb6e0d4/" rel="bookmark">
			【MySQL】MySQL数据库基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、数据库概念
二、数据库基本使用
1、链接服务器
2、服务器管理
3、使用案例
3.1、创建数据库
3.2、使用数据库
4、服务器，数据库，表关系
三、MySQL架构
四、SQL分类
五、存储引擎
1、存储引擎概念
2、查看存储引擎
3、存储引擎对比
一、数据库概念 存储数据用文件就可以了，为什么还要弄个数据库?
文件保存数据有以下几个缺点：
文件的安全性问题文件不利于数据查询和管理文件不利于存储海量数据文件在程序中控制不方便 为了解决上述问题，专家们设计出更加利于管理数据的东西——数据库，它能更有效的管理数据。数据库的水平是衡量一个程序员水平的重要指标。
数据库存储介质：
磁盘内存 mysql 是数据库服务的客户端。
mysqld 是数据库服务的服务器端。
mysql的本质是基于C(mysql)S(mysqld)模式的一种网络服务。是一套给用户提供数据存取服务的网络程序。 数据库服务，就是 mysqld 。
数据库一般指的是，在磁盘或者内存中存储的特定结构组织的数据，是将来在磁盘上存储的一套数据库方案。
主流数据库主要有以下几个：
SQL Sever： 微软的产品，.Net程序员的最爱，中大型项目。Oracle： 甲骨文产品，适合大型项目，复杂的业务逻辑，并发一般来说不如MySQL。MySQL：世界上最受欢迎的数据库，属于甲骨文，并发性好，不适合做复杂的业务。主要用在电商，SNS，论坛。对简单的SQL处理效果好。PostgreSQL :加州大学伯克利分校计算机系开发的关系型数据库，不管是私用，商用，还是学术研究使用，可以免费使用，修改和分发。SQLite： 是一款轻型的数据库，是遵守ACID的关系型数据库管理系统，它包含在一个相对小的C库中。它的设计目标是嵌入式的，而且目前已经在很多嵌入式产品中使用了它，它占用资源非常的低，在嵌入式设备中，可能只需要几百K的内存就够了。H2： 是一个用Java开发的嵌入式数据库，它本身只是一个类库，可以直接嵌入到应用项目中。 二、数据库基本使用 1、链接服务器 连接服务器的指令：
mysql -h [主机ip地址] -P [MySQL绑定的端口号] -u [登录用户] -p 如果不使用 -h 选项，则默认连接本地服务器上搭建的MySQL服务。如果不使用 -P 选项，则采用默认的端口号 3306 。 -p 指明需要输入密码。
2、服务器管理 执行 win+r 输入 services.msc 打开服务管理器通过下图左侧停止，暂停，重启动按钮进行服务管理 3、使用案例 3.1、创建数据库 创建数据库指令：
create database [数据库名称]; 建立数据库，本质就是在Linux下创建一个目录：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0706d98b0192d3666401bd862eb6e0d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/976dbc8d3025bc439e54bd10e995044c/" rel="bookmark">
			简单获取网易云音乐MP3 源地址的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个网易音乐外链地址长期有效，很简单的方法：
找音乐：
https://music.xf1433.com/
取音乐素材：
1. http://music.163.com/#/song?id=95475
2. 真实地址为 https://music.163.com/song/media/outer/url?id=95475.mp3
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/083fb527bced1b4444b55c78f5d78e1e/" rel="bookmark">
			七牛云下载文件（显示在浏览器上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在做关于如何将七牛云的文件下载下来，且在浏览器页面展示下载文件。
首先，我们需要注册七牛云账号 七牛云官网。
选择个人账户即可，若是需要企业账户，则可以选择企业账户。
注册成功绑定邮箱后，我们可以创建存储空间，如下图：
存储空间名称相当于标识，将来上传文件会需要到，通过该标识知晓对哪个空间进行文件操作。
访问控制我们选择公开即可
存储区域 根据自己所在区域进行设置
创建成功后如下图所示：
接下来我们就可以创建七牛云工具类，将相关信息配置好
private String accessKey = "9a7NMGmQzBZQjDt8Ok"; private String secretKey = "llnLAyxQo5-tCkr"; private String bucketName = "huyuelei"; private String fileDomain = ""; private final String filePath="http://rwyj6tqd1.hd-bkt.clouddn.com/"; 有需要工具类的同学可以下载工具类
前端部分：
function downOldFile(data) { console.log(data) let url=prefix+"/downOldFile?fileName="+data.fileName+'&amp;fileUrl='+data.fileUrl; let fileName=data.fileName; var xhr = new XMLHttpRequest(); xhr.open("post", url, true); xhr.responseType = "blob"; xhr.setRequestHeader('Accept', 'application/json'); xhr.onload = function () { console.log(this) $.modal.closeLoading(); if (this.status == 200 &amp;&amp; this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/083fb527bced1b4444b55c78f5d78e1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e3c48db2ca85094885fc059f5ce555b/" rel="bookmark">
			vue3 elementplus table表格多行合计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		表格底部如何多行合计
1.先在标签上定义合计方法
&lt;el-table :data="data" :summary-method="getSummaries" :show-summary="true" @selection-change="handleSelectionChange" &gt; 2.文件头部引入h函数渲染多行div，BigNumber 防止精度丢失。
import { reactive, onMounted, toRefs, ref, h } from 'vue'; import BigNumber from 'bignumber.js'; // 计算求和 function countTotal(arr, keyName) { let $total = 0; $total = arr.reduce(function (total, currentValue, currentIndex, arr) { return currentValue[keyName] ? new BigNumber(total).plus(currentValue[keyName]).toString() : total; }, 0); return $total; } function getSummaries(param: any) { const { columns, data } = param; const sums: string[] = []; const tit: string[] = []; let CNYObj = { waers: 'CNY' }; let USDObj = { waers: 'USD' }; const CNYArr = data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e3c48db2ca85094885fc059f5ce555b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfb50a73814f6a0b7a70322fbb1fa778/" rel="bookmark">
			echarts地图绘制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		echarts地图绘制 1、简单的地图绘制1.1代码实现1.2 代码讲解 2、给地图加上标注2.1 代码演示2.2 注意事项2.3 图形展示 3、涟漪标注3.1 注意点：3.2 代码展示3.3 效果图 4、用series为地图添加数据 → 不用geo4.1 热力地图代码：4.2效果图展示 5、地图标注加地图热力图5.1代码展示5.2效果图展示 前提
1、需要引入echarts.js(echarts.min.js) 和 china.js
2、需要有一个有宽高的dom容器来放置地图
1、简单的地图绘制 1.1代码实现 (function () { //1、实例化对象 var myChart = echarts.init(document.querySelector(".map .chart")) var option = { //设置标题 title: { text: '地图绘制', // 主标题名称 textStyle: { color: '#bce2e8', fontStyle: 'oblique', //斜体 fontFamily: 'monospace', //字体 }, top: 20, left: 20 }, // 地图配置 geo: { map: "china", //放大地图 zoom: 1.25, //开启漫游 roam: true, //让其文字出现在外地图上 label: { // 通常状态下的文字样式 normal: { show: true, textStyle: { color: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfb50a73814f6a0b7a70322fbb1fa778/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e71cdf89e0014441b998e1ebb87eaa2/" rel="bookmark">
			吴恩达：机器学习的六个核心算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方“小白学视觉”，选择加"星标"或“置顶”
重磅干货，第一时间送达 来源丨AI科技评论 编辑丨极市平台
极市导读
最近，吴恩达在其创办的人工智能周讯《The Batch》上更新了一篇博文，总结了机器学习领域多个基础算法的历史溯源。
最近，吴恩达在其创办的人工智能周讯《The Batch》上更新了一篇博文，总结了机器学习领域多个基础算法的历史溯源。
文章开头，吴恩达回忆他的研究历程中曾有一次抉择：
多年前，在一次项目中，选择算法时，他不得不在神经网络与决策树学习算法之间做选择。考虑到计算预算，他最终选择了神经网络，在很长的一段时间内弃用增强决策树。
这是一个错误的决定，「幸好我的团队很快修改了我的选择，项目才成功。」吴恩达谈道。
他由此感叹，不断学习与更新基础知识是十分重要的。与其他技术领域一样，随着研究人员的增加、研究成果数量的增长，机器学习领域也在不断发展。但有些基础算法与核心思想的贡献是经得起时间考验的：
算法：线性和逻辑回归、决策树等
概念：正则化、优化损失函数、偏差/方差等
在吴恩达看来，这些算法与概念是许多机器学习模型的核心思想，包括房价预测器、文本-图像生成器（如DALL·E）等。
在最新的这篇文章中，吴恩达与团队调研了六种基础算法的来源、用途、演变等，并提供了较为详细的讲解。
这六种算法分别是：线性回归、逻辑回归、梯度下降、神经网络、决策树与k均值聚类算法。
1
线性回归：直的&amp;窄的
线性回归是机器学习中的一个关键的统计方法，但它并非不战而胜。它由两位杰出的数学家提出，但200 年过去了，这个问题仍未解决。长期存在的争议不仅证明了该算法具有出色的实用性，还证明了它的本质十分简单。
那么线性回归到底是谁的算法呢？
1805 年，法国数学家 Adrien-Marie Legendre 发表了将一条线拟合到一组点的方法，同时试图预测彗星的位置（天体导航是当时全球商业中最有价值的科学方向，就像今天的人工智能一样）。
图注：Adrien-Marie Legendre 的素描画像
四年后，24 岁的德国神童 Carl Friedrich Gauss （高斯）坚称他自 1795 年以来一直在使用它，但认为它太琐碎了，无法写。高斯的主张促使Legendre匿名发表了一份文章，称“一位非常著名的几何学家毫不犹豫地采用了这种方法。”
图注：Carl Friedrich Gauss
斜率和偏差：当结果与影响它的变量之间的关系遵循直线时，线性回归很有用。例如，汽车的油耗与其重量成线性关系。
汽车的油耗 y 与其重量 x 之间的关系取决于直线的斜率 w（油耗随重量上升的幅度）和偏置项 b（零重量时的油耗）：y=w*x+b。
在训练期间，给定汽车的重量，算法会预测预期的油耗。它比较了预期和实际的油耗。然后，它将平方差最小化，通常通过普通最小二乘技术，磨练 w 和 b 的值。
考虑汽车的阻力可以生成更精确的预测。附加变量将线延伸到平面。通过这种方式，线性回归可以容纳任意数量的变量/维度。
普及的两个步骤：该算法立即帮助航海者追踪星星，以及帮助后来的生物学家（尤其是查尔斯·达尔文的堂兄Francis Galton）识别植物和动物的可遗传特征。这两项深入发展释放了线性回归的广泛潜力。1922 年，英国统计学家 Ronald Fisher 和 Karl Pearson 展示了线性回归如何适应相关性和分布的一般统计框架，使其在所有科学中都有用。而且，近一个世纪后，计算机的出现提供了数据和处理能力，可以更大程度地利用它。
应对歧义：当然，数据永远不会被完美地衡量，有些变量比其他变量更重要。这些生活事实激发了更复杂的变体。例如，带有正则化的线性回归（也称为「岭回归」，ridge regression）鼓励线性回归模型不要过多地依赖于任何一个变量，或者更确切地说，均匀地依赖于最重要的变量。如果为了简单起见，另一种形式的正则化（L1 而不是 L2）会产生 lasso（压缩估计），鼓励尽可能多的系数为零。换句话说，它学会选择具有高预测能力的变量并忽略其余的。弹性网络结合了这两种类型的正则化。当数据稀疏或特征看起来相关时，它很有用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e71cdf89e0014441b998e1ebb87eaa2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40d8cfd800146e6368c2dbfcf5d33008/" rel="bookmark">
			远程桌面连接不上怎么办?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		远程桌面连接是一种非常方便的远程办公和协作工具，但是有时候我们会遇到连接不上的问题。本文将详细分析远程桌面连接不上的原因，并提供相应的解决方案。
远程桌面连接不上的原因可能有很多，以下是一些常见的因素：
网络问题：远程桌面需要良好的网络连接，如果网络不稳定或者速度慢，就可能导致连接不上的问题。防火墙问题：一些防火墙可能会阻止远程桌面的端口，从而阻止了连接。远程桌面软件问题：如果远程桌面软件出现了故障或者崩溃，就可能导致连接不上的问题。 解决方案
以下是一些解决远程桌面连接不上的方案：
检查网络连接：确保网络连接稳定，速度正常。如果网络连接有问题，可以尝试重启路由器或者使用其他网络连接方式。检查防火墙设置：如果防火墙阻止了远程桌面的端口，可以尝试关闭防火墙或者修改防火墙设置，以便允许远程桌面的端口通过。重新安装远程桌面软件：如果远程桌面软件出现了故障，可以尝试卸载并重新安装远程桌面软件。 总结
本文主要分析了远程桌面连接不上的原因，并提供了相应的解决方案。通过实践操作，读者可以更好地理解和应用所提供的解决方案。希望这些内容能够帮助读者解决远程桌面连接不上的问题，从而更好地进行远程办公和协作。
Win10远程桌面连接不上的解决方法：
https://www.anyviewer.cn/how-to/remote-desktop-is-not-connected-2111.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac759f87c9b4d40e23a214676c9cc8d4/" rel="bookmark">
			C语言，输入三个数，求出最大数，最小数并输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用if进行解答 #include&lt;stdio.h&gt; void main() { int a,b,c,t,q; printf("please input a,b,c"); scanf("%d,%d,%d",&amp;a,&amp;b,&amp;c); if(a&gt;=b&amp;&amp;a&gt;=c) t=a; else if(b&gt;=a&amp;&amp;b&gt;=c) t=b; else t=c; if(a&lt;=b&amp;&amp;a&lt;=c) q=a; else if(b&lt;=a&amp;&amp;b&lt;=c) q=b; else q=c; printf("max:%d\nmin:%d",t,q); } 使用三目运算进行解答 #include&lt;stdio.h&gt; void main() { int a,b,c,t,q; printf("please input a,b,c"); scanf("%d,%d,%d",&amp;a,&amp;b,&amp;c); t=a&gt;=b?a:b; t=t&gt;=c?t:c; q=a&lt;=b?a:b; q=q&lt;=c?q:c; printf("max:%d\nmin:%d",t,q); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7ded0fa4d93df73df1d8566aa3b8633/" rel="bookmark">
			【共享内存】共享内存（Shared Memory）与进程通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、共享内存概述
二、共享内存操作
1）获得一个共享存储标识符：shmget函数
2）共享内存映射(attach)：shmat函数
3）解除共享内存映射(detach)：shmdt函数
4）共享内存控制：shmctl函数
总结：
一、共享内存概述 共享内存允许两个或者多个进程共享给定的存储区域。
共享内存的特点：
1）共享内存是进程间共享数据的一种最快的方法。
一个进程向共享内存区域写入了数据，共享这个内存区域的所有进程就可以立刻看到其中的内容。
2）使用共享内存要注意的是多个进程之间对一个给定存储区域访问的互斥。
若一个进程正在向共享内存区写数据，则在它做完这一步操作前，别的进程不应当去读、写这些数据。
共享内存示意图：
共享内存是进程间通信方式中效率最高的，原因在于进程是直接在物理内存上进行操作，将物理地址映射到用户进程这，所以只要对其地址进行操作，就是直接对物理地址操作。
二、共享内存操作 在ubuntu12.04中共享内存限制如下：
共享存储区的最小字节数：1共享存储区的最大字节数：32M共享内存区的最大个数：4096每个进程最多能映射的共享存储区的个数：4096 使用shell命令操作共享内存：
查看共享内存：ipcs -m
删除共享内存：ipcrm -m shmid
1）获得一个共享存储标识符：shmget函数 shmget函数：
#include&lt;sys/ipc.h&gt;
#include&lt;sys/shm.h&gt;
int shmget(key_t key, size_t size, int shmflg);
功能：创建一个共享内存
参数：
key：键值，唯一的键值确定唯一的共享内存
size：创建的共享内存的大小
shmflg：共享内存的访问权限
一般为IPC_CREAT | 0777
返回值：
成功：共享内存的id
失败：-1 代码示例：
#include&lt;sys/ipc.h&gt; #include&lt;sys/shm.h&gt; #include&lt;unistd.h&gt; #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; int main() { key_t key; if ((key = ftok(".", 100)) == -1) { perror("fail to ftok"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7ded0fa4d93df73df1d8566aa3b8633/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c81abe56d305668bc046d26914fcc1c/" rel="bookmark">
			远程控制电脑软件VNC安装使用教程：Windows系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是VNC？
VNC (Virtual Network Console)，即虚拟网络控制台，它是一款基于 UNIX 和 Linux 操作系统的优秀远程控制工具软件，由著名的 AT&amp;T 的欧洲研究实验室开发，远程控制能力强大，高效实用，并且免费开源。
VNC基本上是由两部分组成：一部分是客户端的应用程序(vncviewer);另外一部分是服务器端的应用程序(vncserver)。在任何安装了客户端的应用程序(vncviewer)的计算机都能十分方便地与安装了服务器端的应用程序(vncserver)的计算机相互连接。
2、VNC运行的工作流程
(1)VNC客户端通过浏览器或VNC Viewer连接至VNC Server。
(2)VNC Server传送一对话窗口至客户端，要求输入连接密码，以及存取的VNC Server显示装置。(3)在客户端输入联机密码后，VNC Server验证客户端是否具有存取权限。
(4)若是客户端通过VNC Server的验证，客户端即要求VNC Server显示桌面环境。
(5)VNC Server通过X Protocol 要求X Server将画面显示控制权交由VNC Server负责。
(6)VNC Server将来由 X Server的桌面环境利用VNC通信协议送至客户端，并且允许客户端控制VNC Server的桌面环境及输入装置。
3、VNC安装步骤
首先下载VNC-Viewer和VNC-Server
此软件没有中文版，首先我们在远程操作电脑上安装VNC-Viewer，打开VNC-Viewer安装程序，选择English，点击OK;然后点击下一步Next
然后进入许可协议界面，勾选左下角 I accept terms in the License Agreement 同意后，即可点击 Next 进入下一步;
点击右下角的 Browse，会弹出路径选择框，选择好自己的安装路径后，点击右下方 OK 即可。
选中安装组件中的 Desktop Shotcut，设置桌面快捷方式项，这里默认没有附带，可以单击该项，在弹出选项里选择 Will be installed on local hard drive，就可以在安装完成后自动在桌面创建对应快捷方式。
完成安装项设置后，下一步进入安装界面，如下，确认没问题后点击下方 Install 即可进行安装。
稍等片刻后，即可完成安装，在界面中点击 Finish 即可结束安装程序。
安装好后，自动创建桌面快捷方式，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c81abe56d305668bc046d26914fcc1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e45632e82eabdc206b0b9a81a03d238d/" rel="bookmark">
			Centos7系统wget 的安装与使用详细教程。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在CentOS 7系统上安装和使用wget的详细教程如下：
步骤1：以root用户或具有sudo特权的用户身份登录到您的CentOS 7系统。
步骤2：安装wget
在CentOS 7系统中，可以使用以下命令安装wget：
sudo yum install wget 步骤3：使用wget下载文件
要使用wget下载文件，请在终端中执行以下命令：
wget [URL] 将上述命令中的[URL]替换为您要下载的文件的URL地址。例如，如果要下载一个名为file.txt的文件，可以使用以下命令：
wget http://example.com/file.txt wget将从指定的URL下载文件，并将其保存在当前工作目录中。
步骤4：使用wget下载到指定目录
如果您希望将下载的文件保存到指定目录中，可以使用以下命令：
wget -P /path/to/directory [URL] 将上述命令中的/path/to/directory替换为您要保存文件的目录路径。例如，要将文件保存到/home/user/downloads目录中，可以使用以下命令：
wget -P /home/user/downloads http://example.com/file.txt wget将把下载的文件保存到指定的目录中。
步骤5：使用wget断点续传下载
wget还支持断点续传功能，可以在下载过程中中断并在稍后恢复下载。这对于大文件或不稳定的网络连接非常有用。
要使用断点续传功能，请使用以下命令：
wget -c [URL] 将上述命令中的[URL]替换为要下载的文件的URL地址。
步骤6：其他wget选项
wget提供了许多其他选项，可以根据需要进行使用。您可以通过运行以下命令查看wget的帮助文档：
wget --help 该命令将显示wget的所有可用选项和其说明。
以上是在CentOS 7系统上安装和使用wget的详细教程。确保按照步骤操作，并根据您的需求进行必要的修改和调整。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1d4b33ed7161dd89793ca0c029cd41c/" rel="bookmark">
			1685页Java面试题大全（整理版）3000&#43;面试题附答案详解，最全面详细
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多Java工程师的技术不错，但是一面试就头疼，10次面试9次都是被刷，过的那次还是去了家不知名的小公司。
问题就在于：面试有技巧，而你不会把自己的能力表达给面试官。
应届生：你该如何准备简历，面试项目和面试说辞？Spring底层逻辑是什么？1-3年经验的程序员：面试中你该讲哪些值钱的技术？如何用这些值钱的技术最大程度展示自己的技能？分布式组件底层逻辑是什么？3-5年经验的程序员：k8s怎么搭建实践？ 这些问题，相信每一位Java程序员都曾遇到过，甚至有的人至今也不知道要怎么解决，屡面屡败，最终导致你的面试通过率极低。
如果说简历是你求职的敲门砖，那么你回答每一个Java技术问题的技巧与方法，就是你面试能否通过的关键！
为了帮助各位工程师，掌握Java面试中每一个问题的技巧，提高面试通过率，这里我推荐大家一个 2022 最新最全的 1685 页——《Java面试突击核心手册》,这份面试题资料包括了Spring，JVM,java基础，Java集合，Java并发编程，微服务，网络，Kafka，分布式，Redis，大厂面试解决方案，分布式事务，设计模式，算法，数据结构，MySQL等
大厂高频常问的 Java 面试题如下： java 基础
HashMap1.7 和 1.8 的实现区別 HashMap 中插入、添加、删除除元素的时间复杂度？ ConcurrentHashMap 的实现原理? newString()，一共创建了几个对象？ 序列化和反序列化的底层实现原理？ hashCode 和 equals 方法的区别和联系？ 讲讲 String、StringBuilder、StringBuffer？ Object 类中常见的方法，为什么 wait notify 会放在 Object 里边？ Arraylist 与 LinkedUstKU 空间是多少？ HashMap 的默认空间、扩容因子等？ 若 hashcode 方法永远退回 1 或者一个常量会产生什么结果？ 浅拷贝和深拷贝的区别？ 反射的作用与实现原理？ Java 提供的排序算法是怎么实现的？ 多线程
说说 synchronized 实现原理（对象监视器）？ volatile 实现原理（禁止指令重排、刷新内存）？ ThreadLocal 原理分析，ThreadLocal 为什么会出现 OOM，出现的深层次原理？ CAS 无锁的概念、什么是乐观锁和悲观锁？ AQS 同步队列是什么？ 什么是 ABA 问题，出现 ABA 问题 JDK 是如何解决的？ 常见的原子操作类？ 偏向锁、轻量级锁、重量级锁、自旋锁的概念？ 一个线程连着调用 start 两次会出现什么情況？ 线程池的实现？ 重要参数及原理？ 说说四种线程池？ 任务拒接策略有哪几种？ 线程状态以及 API 怎么操作会发生这种转换？ JVM
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1d4b33ed7161dd89793ca0c029cd41c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14c561b5de17d592386e8752b796ce67/" rel="bookmark">
			朴素贝叶斯详解,并用python实现朴素贝叶斯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		朴素贝叶斯（Naive Bayes，NB）是一种基于贝叶斯定理的分类算法，它是一种简单快速的算法，常用于文本分类、垃圾邮件过滤等任务。
1. 基本原理
朴素贝叶斯的基本原理是基于贝叶斯定理，其定理公式如下：
$$P(y|x) = \frac{P(x|y)P(y)}{P(x)}$$
其中，$P(y|x)$ 表示在给定样本 $x$ 的条件下，样本属于类别 $y$ 的概率；$P(x|y)$ 表示在类别 $y$ 的条件下，样本 $x$ 的概率；$P(y)$ 表示类别 $y$ 出现的概率；$P(x)$ 表示样本 $x$ 出现的概率。
根据朴素贝叶斯的假设，所有的特征都是相互独立的，即假设特征之间不存在任何关联，这个假设被称为条件独立性假设。基于这个假设，可以将 $P(x|y)$ 表示为各个特征的条件概率的乘积：
$$P(x|y) = \prod_{i=1}^n P(x_i|y)$$
将其代入贝叶斯定理公式，则可得到朴素贝叶斯分类的公式：
$$y_{NB} = \operatorname{argmax}_{y_i} P(y_i) \prod_{j=1}^n P(x_j|y_i)$$
其中，$y_{NB}$ 表示样本所属的类别；$P(y_i)$ 表示类别 $y_i$ 的先验概率；$P(x_j|y_i)$ 表示在类别 $y_i$ 的条件下，特征 $x_j$ 出现的条件概率。
2. 参数估计
在朴素贝叶斯中，需要估计的参数有先验概率 $P(y_i)$ 和条件概率 $P(x_j|y_i)$。对于先验概率，可以使用最大似然估计：
$$P(y_i) = \frac{\sum_{j=1}^N [y_j = y_i]}{N}$$
其中，$N$ 是训练集中总的样本数，$[y_j=y_i]$ 表示当样本 $j$ 属于类别 $y_i$ 时为 $1$，否则为 $0$。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14c561b5de17d592386e8752b796ce67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8885267f740e54f26f243b2a210fa276/" rel="bookmark">
			井盖异动监测传感器-井盖报警器-旭华智能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着城市化进程的进一步加快，市政公用设施建设发展迅速。其中窨井盖成为了不可忽视的一项。大量在外井盖由于缺乏有效的实时监控管理手段，给不法分子提供了可乘之机，移动、偷盗井盖等违法行为时有发生。丢失井盖的井口会对道路上的车辆、行人造成极大的危害，对社会安定、安全造成了极大负面影响。
智能井盖监测终端是一款用于城市窖井井盖监测的设备，实现对并盖状态、水浸、井下水位的主动感知和实时监控，一旦发生井盖倾斜、非法开启、水浸、井下水位超限等异常情况，监测终端立即通过NB-IoT网络向管理中心发送报警信息，便于工作人员快速定位、及时处理，最大限度地保障有关公共设施和行人、车辆出行安全。
产品特点：
1. 超强穿透：数据传输采用NB-IOT网络通讯。
2. 超低功耗：超低功耗设计，长达3 - 5年超长续航能力。
3. 超强防护：防护等级达到IP68，防潮、防水、防腐蚀，防撞击。
4. 身份识别：井盖整个生命周期的事务统一归档，统一管理，防止丢失及偷盗。
小井盖关系着大民生。善于运用现代科技手段实现智能化管理，是城市治理精细化水平的体现。以科技破解城市顽疾，确保井盖稳稳当当，守护好市民“脚下安全”。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fa3d4012f109a41f89a88eb92f0e850/" rel="bookmark">
			解决MySQL连接报错Host is blocked because of many connection errors； unblock with ‘mysqladmin flush-hosts
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看日志报错：
com.mysql.cj.exceptions.CJException: null, message from server: "Host 'xxxx' is blocked because of many connection errors; unblock with 'mysqladmin flush-hosts'"
首先数据库使用Navicat访问正常，但是应用访问就是不行，即使重启mysql实例也没效果。最后定位到，应该是短时间内产生了大量中断的数据库连接导致，而且失败的连接数量超过了mysql的max_connection_errors的最大值。
1.登录mysql，使用 flush hosts来命令清理hosts文件
flush hosts;
2.调整mysql的最大连接数和最大错误连接数的大小
查看mysql最大错误连接数
show variables like '%max_connect_errors%'
查看mysql最大连接数：
show variables like 'max_connections';
修改连接数大小：
set global max_connections = 1000;
set global max_connect_errors = 1000;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/041719832576cd46980751b682912ed1/" rel="bookmark">
			webstorm 开发插件集合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下列插件均可在工具中的插件市场直接下载
官网安装插件教程：https://www.jetbrains.com
插件下载地址：https://plugins.jetbrains.com
一、开发工具美化
设置特定背景图片
步骤： 文件 – 设置 – 如图
就可以了
插件 Sexy Editor 更名为 Awesome Editor 我用来设置右下角的图 效果如下
设置步骤：由于设置的路径发生一定变化，如下：
old：文件 – 设置 – 其他设置 – 如图
new：文件 – 设置 – 编辑器 – Awesome Editor
保存即可，若无效果，请关闭软件，重新打开。
图标插件 Atom Material Icons
Enable File Icons 文件图标
Enable Directory Icons 目录图标
Enable UI Icons 顶部UI 图标
Translation
对于英语不是很好的开发者，在取变量名或者文件名字的时候会犯难。那么就可以给编辑器装一个这个翻译插件。使用也很方便，可以直接选中中文右键翻译，也可以直接选中用快捷键Ctrl+shift+Y。
彩色括号 Rainbow Brackets
可以实现配对括号相同颜色。
高亮括号 HighlightBracketPair
会在左侧代码行数那显示括号范围，比彩虹括号插件更加直观而且不容易看花眼。
代码缩略图 CodeGlance2
正则插件 any-rule
安装好后使用方法：
法一：右键-&gt;AnyRule
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/041719832576cd46980751b682912ed1/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/75/">«</a>
	<span class="pagination__item pagination__item--current">76/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/77/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>