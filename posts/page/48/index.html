<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0660195c1361f9235c6e18bc4d521585/" rel="bookmark">
			HAL库自学笔记（三）——中断
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、中断的概念 1.异常与中断 异常 异常是由操作系统和硬件实现的，是控制流中的突变，用来响应处理器状态的某些变化。异常分为中断（interrupt）、陷阱（trap）、故障（fault）和终止（abort）。
（1）陷阱（trap） 陷阱是有意的异常，主要用来切换用户态和内核态，其提供的一个切换过程称为系统调用。用户希望调用系统资源的时候，可以执行syscall指令，这时会导致一个异常陷阱，从而进入内核态。
（2）故障（fault） 故障由错误情况引起，它可能被故障处理程序修正，从而重新执行当前指令，也有可能无法被修正，即进入终止（abort），cpu会终止该应用程序。例：取数据时发生“缺页”，导致故障，操作系统通过将所需页面从磁盘调入内存，此时故障处理完毕，操作系统重新执行取数据指令。
（3）终止（abort） 终止是不可恢复的致命错误导致的，通常是硬件错误，例如DRAM或SRAM损坏导致存储器校验错。此时会终止运行的应用程序。
中断 中断是处理来自处理器外部的I/O设备的信号的结果。硬件中断是异步的，硬件中断的异常处理程序被称为中断处理程序。
（1）硬中断与软中断 硬中断是由硬件产生的，例如磁盘，定时器，键盘等。软中断是一组静态定义的下半部分接口，可以在所有处理器上同时执行。软中断不会抢占软中断，硬中断会抢占软中断。
（2）可屏蔽中断和不可屏蔽中断 可屏蔽中断和不可屏蔽中断都属于外部中断，不可屏蔽中断源提出请求，CPU必须响应，而对可屏蔽中断源的请求，CPU可选择响应。
2.事件 对于处理器的外设，是通过内部信号来协同工作的，这个信号则为事件。事件通常和中断绑定在一起，一个事件会引起一个中断或者引起另一个事件。例如：定时器计数完毕，通过计数完毕事件引起中断，或导致另一个事件开始。
二、外部中断/事件控制器（EXTI） 1.EXTI框图 EXTI 可分为两大部分功能，一个是产生中断，另一个是产生事件，这两个功能从硬件上就有所 不同。
对于事件：外部电路的I/O设备的高低电平变化通过输入线被边沿检测电路捕获（通过上升沿或下降沿触发），进入2（或门），并与软件中断做或运算，其中一个发生即可。接着进入4（与门）若事件屏蔽器允许则进入脉冲发生器，此时发出的脉冲可以被另一个事件或中断捕获。
对于中断：1，2电路过程相同，此时中断信号被请求挂起寄存器挂起，与中断屏蔽寄存器作为3号与门的两个输入端，两者同时为1则触发NVIC中断。
三、中断实验 1.背景 实验板：指南者STM32F103VET6
配置环境：STM32CubeMX
开发环境：Keil
实现功能：利用按键进入中断，并在中断中控制LED的亮灭
2.配置环境 参照按键和LED的原理图配置。
对于按键，配置其为GPIO_EXIT，对于LED配置为GPIO_Output。
3.生成代码 略，可看之前的文章。
4.代码解析 （1）引脚的宏定义 在main.h中，STM32帮我们定义了一些宏来增强程序可读性。
/* Private defines -----------------------------------------------------------*/ //按键的宏定义 #define KEY2_EXIT_Pin GPIO_PIN_13 #define KEY2_EXIT_GPIO_Port GPIOC #define KEY2_EXIT_EXTI_IRQn EXTI15_10_IRQn #define KEY1_EXIT_Pin GPIO_PIN_0 #define KEY1_EXIT_GPIO_Port GPIOA #define KEY1_EXIT_EXTI_IRQn EXTI0_IRQn //LED的宏定义 #define GREEN_Pin GPIO_PIN_0 #define GREEN_GPIO_Port GPIOB #define BLUE_Pin GPIO_PIN_1 #define BLUE_GPIO_Port GPIOB #define RED_Pin GPIO_PIN_5 #define RED_GPIO_Port GPIOB （2）GPIO的初始化配置 将按键1和按键2配置为中断源，同时配置LED初始为高电平，即灭的状态。此代码在gpio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0660195c1361f9235c6e18bc4d521585/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b533e42a9b9dd1361225775770fdacb8/" rel="bookmark">
			快速排序详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、定义 快速排序（英语：Quicksort），又称分区交换排序（英语：partition-exchange sort），简称「快排」，是一种被广泛运用的排序算法。
二、基本原理 快速排序是一个基于 分治 的排序方法。 给定一个数组 a a a，该数组共有 n n n 个元素，我们需要对其进行 从小到大（也可以从大到小）的排序。
假设要排序的区间为 [ l , r ] [l,r] [l,r]：
如果区间长度小于等于 1，那就直接退出（因为只有一个元素不用排序）。否则在该区间中选择任意一个元素 x x x 作为 基准元素。将 大于 x x x的元素放到 x x x 的 右边；将 小于 x x x的元素放到 x x x 的 左边，等于 x x x 的元素随便放哪边。此时， x x x 的位置实际上就已经确定了，再对 x x x 的左右两边的区间分别进行递归即可。 注意：为了保证时间复杂度，实际操作的时候，一般是随机选择区间的某一元素当作基准元素。
三、步骤与实现 1.步骤 在编写代码时，为了将 大于 x x x 和 小于 x x x 的元素放到 x x x 的两边，我们并不需要使用额外的存储空间，只需要使用两个指针 i i i 和 j j j。现在我们要对 区间 [ l , r ] [l,r] [l,r]中的元素进行排序（我们这里选择第一个元素，即 a [ i ] a[i] a[i] 当作 x x x）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b533e42a9b9dd1361225775770fdacb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c423b8454242c3cf3094ec50ec96e0f/" rel="bookmark">
			ESP32 for Arduino 分区信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		忘记过去，超越自己
❤️ 博客主页 单片机菜鸟哥，一个野生非专业硬件IOT爱好者 ❤️❤️ 本篇创建记录 2023-11-04❤️❤️ 本篇更新记录 2023-11-04❤️🎉 欢迎关注 🔎点赞 👍收藏 ⭐️留言📝🙏 此博客均由博主单独编写，不存在任何商业团队运营，如发现错误，请留言轰炸哦！及时修正！感谢支持！🔥 Arduino ESP8266教程累计帮助过超过1W+同学入门学习硬件网络编程，入选过选修课程，刊登过无线电杂志 🔥 快速导读 1. 前言2. 分区表说明3. 程序烧录4. 分区表如何对应配置 1. 前言 Arduino ESP32有多个不同的分区版本。
我们在ESP32 for Arduino的工具中，有一个选项，可以配置不同的分区表，这里已经做好了一些，一般我们都是使用默认的，如下图所示：
分别代表什么意思呢？
4M FLASH默认分区方案为1.2MB的应用程序空间，1.2MB为OTA保留，1.5MB为SPIFFS文件系统保留的。
我们找到这个描述文件，这里博主对应sdk版本是 2.0.11：
C:\Users\xxxx\AppData\Local\Arduino15\packages\esp32\hardware\esp32\2.0.11\tools\partitions
我们打开default.csv，对应默认的分区表：
表格里面
Name 对应各个分区名字Offset 对应的偏移地址Size 对应占用大小 比如，nvs分区，从0x9000地址处开始，大小为0x5000，也就是20480字节的大小。
2. 分区表说明 网上找到一张ESP32的阿里云分区表。
0-0x1000 保留0x1000-0x8000 Bootloader分区0x8000-0x9000 Partition Table分区，保存着分区表0x9000-0xD000 NVS分区，可以存储一些PHY初始化数据，也可以存储其他数据，一些断电存储的数据建议放在这里0xD000-0xF000 OTA data分区，系统从哪个app分区启动由这里存储的数据决定0xF000-0x10000 PHy_init分区，用于存储的PHY初始化数据0x10000-0x3FFFFF Factory APP分区，保存出厂应用程序（也就是我们平常代码写入的地方），分区表有工厂应用程序就会启动这个分区的程序Core dump分区，查找系统崩溃时的软件错误，以便开发者分析原因OTA0/OTA1分区，保存OTA下载固件，交替保存在这两个分区，镜像验证无误之后，会更新OTA data分区，分配好下一次应该从哪里启动。fctry分区，保存阿里云四元组，这个就是私有数据了，可以在存储空间的最后分配一些空间用于保存一些APP的激活数据之类的，没有用到就可以忽略。 3. 程序烧录 这个烧录过程就有各个区分的操作过程，包括Bootloader区、Partition Table区、app区。
4. 分区表如何对应配置 如何查找哪个配置对应哪个csv文件呢？
找一下Board.txt文件。
随便以一个为案例（Default 4MB with spiffs）：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2aa608b9f9874ffab6c7acd6bf0b22c6/" rel="bookmark">
			Ubuntu重启后进入initramfs导致无法开机解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天，我的电脑意外关机，重新开机后打开了虚拟机。该虚拟机使用的是 Ubuntu 22.04 系统。但重启后，系统一直显示(initramfs):，导致无法正常启动。最后，在网上查找了一些解决方案，成功解决了这个开机问题。在这篇文章中，我将与大家分享解决方案的过程和经验。
开机现象 虚拟机系统是Ubuntu 22.04，开机后一直显示(initramfs):，导致无法正常启动。
解决方案 使用如下命令查看和识别磁盘、分区或文件系统的信息 blkid 找到TYPE="EXT4"的盘，我们此处是 /dev/mapper/ubuntu–vg-ubuntu–lv,fsck命令是用于检查和修复Linux文件系统中的错误。通过使用-t参数指定文件系统类型（例如ext4）。我们使用如下命令进行修复，出现y/n就一路y下去。 fsck -t ext4 /dev/mapper/ubuntu--vg-ubuntu--lv 修复完成以后，直接输入exit命令，系统就会自动启动了。 exit 总结 在解决Ubuntu进入initramfs导致无法开机的问题时，请确保备份重要数据并谨慎操作，以免造成数据丢失或其他不可逆的损失。
希望本文中提供的解决方案能够帮助您解决Ubuntu开机问题并恢复系统的正常运行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9fac3eb1a2dd14aaabaec094ef882ef/" rel="bookmark">
			编写shell脚本，利用mysqldump实现mysql数据库分库分表备份
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要：本文介绍了如何使用 Shell 脚本和 mysqldump 工具实现 MySQL 数据库的分库分表备份。通过编写脚本，我们可以自动化备份多个数据库以及每个数据库中的所有表，并将备份文件按照数据库和表的层次结构进行存储。
一、准备工作 在开始编写 Shell 脚本之前，请确保已经安装了 MySQL 数据库和 mysqldump 工具。同时，你需要创建一个用于存储备份文件的目录。
二、编写shell脚本 创建一个新的文件，例如 bak_v1.sh
#!/bin/bash # 定义备份目录和连接选项 BAK_DIR="/backup/db" CMD_OPT="-uroot -p030429" EX_DB="information_schema|mysql|performance_schema|sys" # 获取所有数据库（排除系统数据库） DBS=$(mysql ${CMD_OPT} -N -e 'show databases' | egrep -v ${EX_DB}) # 备份每个数据库及其表 for db in $DBS do # 获取数据库中的所有表 TABS=$(mysql ${CMD_OPT} -N -e "show tables from $db") # 创建数据库备份目录（如果不存在） [ -d ${BAK_DIR}/$db ] || mkdir -p ${BAK_DIR}/$db # 备份整个数据库 mysqldump ${CMD_OPT} -B $db | gzip &gt; ${BAK_DIR}/$db/${db}_$(date +%F).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9fac3eb1a2dd14aaabaec094ef882ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a55baa6b4e590d9dd10ab6b3cd1c8774/" rel="bookmark">
			软件测试面试题及答案2024
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、你们的缺陷等级如何划分的？☆☆☆☆☆ 我们的缺陷一般分为四个等级，致命级，严重级，一般级和轻微级。致命级指能够导致软件程序无法使用的缺陷，比如宕机，崩溃，手机APP的闪退，数据库死锁等。严重级别一般是指软件的主要功能存在缺陷或者非主要功能缺失等，影响用户的正常使用。一般级别是指非主要功能存在缺陷，但不影响用户正常使用，或者有替代的方案。轻微错误一般指的是界面或者文字图片的轻微显示错误等。
2、你们的项目团队有多少人？测试人员有几个？如何分工的？ 我们的项目团队大概20多人，其中测试人员4个，我们一般都是按照功能模块来进行分工的（有时候也会按照不能的测试类型来进行划分，比如功能测试，性能测试，自动化测试等。）
3、你们最近一个项目一共写了多少条测试用例？发现了多少个bug？ 我们最近的一个项目大概写了800多条测试用例，一共4个人编写的，大概编写了两周左右的时间，因为在编写的过程中发现需求模糊的地方还需要和产品经理进行沟通。
一共发现了300多个bug，开始的轮次发现的缺陷会比较多一些，后面回归测试中逐渐减少，其中一般级别的bug数量最多。
4、你一天大概能写多少条测试用例？ 按照我目前的能力，依照系统的复杂度来看，通常一天可以写一百多条，如果是需求有模糊不清的地方或者业务比较复杂，可能写的会少一些，几十条吧。
5、你发现了一个bug，但开发人员不认可，你会怎么处理？ 如果我提交了一个bug，开发人员认为不是，那么我首先要再次确认一下这个bug是否存在，是否影响用户的实际使用，确认后，再去和开发人员进行沟通，讲清楚这个缺陷的复现步骤和对用户的影响，争取能够取得开发人员的认可，如果还是不能达成一致，那么我本着对用户负责的态度，需要将此bug的情况上报给测试经理和项目经理，由他们进行裁决。
6、一个不能复现的bug需要上报么？ 这个问题我们还真的遇到过，一般我们发现的bug都需要反正求证复现的步骤，确认百分百复现之后才会上报，但如果遇到比较严重的问题，虽然不能复现，但还是有一定的出现几率，那么我们也要进行上报，需要提交给开发人员进行定位或者观察，但这种bug我们一般会在缺陷报告中标明出现的频率，比如一个手机app闪退的bug，出现频率大概50%。
7、你们的测试工作通常是在什么时候开展的？ 我们项目的测试工作一般是在需求阶段就会介入，参与需求的讨论，需求经过评审之后，我们就开始依照需求规格说明书进行测试用例的编写。
需求讨论主要是从测试人员的角度审查需求描述是否清晰，准确，是否可以编写用例进行测试。
8、你们项目的迭代周期一般多长时间？ 项目初始时候的迭代周期一般长一些，大概一两个月，后面根据迭代的功能和修改的缺陷时间逐渐缩短，一般一两周一个迭代周期，项目上线前期甚至一周就一两个版本。我们这个项目大概迭代了10几个版本。
9、你们使用什么来管理缺陷（bug）的？ 我们使用禅道来管理缺陷，禅道是一个开源的项目管理工具，可以用它来管理产品的需求，项目的任务，测试用例和跟踪bug，我们主要用它来管理测试用例和缺陷。
我们编写了测试用例，依照开发提交的版本进行测试用例的执行，执行的过程中发现bug会提交缺陷报告，开发修改后，我们会进行跟踪验证。
除了禅道，我还了解Bugzilla，Jira，Mantis等缺陷管理工具。
10、你们项目共有几套运行环境☆☆☆☆ 我们项目一般有4套环境，开发环境，测试环境，用户验收环境（UAT环境）和生产环境（线上环境，正式环境）
有的公司还会在测试环境和生产环境之间加上 灰度环境，这种环境和用户验收环境类似，需要和生产环境相似度比较高，主要用于在上生产环境之前验证整体功能的环境兼容性。
11、如何搭建测试环境？你会独立搭建测试环境么？ 注：被问到测试环境的时候需要注意当时的情境，因为测试环境一般有两种理解：
一种是我们测试人员自己使用的环境，通常是在windows下，安装和配置一些常用的软件，比如java环境，python环境，eclipse，jmeter，Loadrunner等。
还有一种是指服务端的软件运行环境，配置java运行环境，安装tomcat中间件，安装Mysql数据库，将web应用的war包放入webapps目录下，解压，重新启动tomcat服务器，就可以通过url访问我们的web软件了。
一般回答第一种就可以了，就说我们的环境和经常用到的软件都是我们自己安装的，问到第二种的时候就说我们服务端的环境部署有专门的运维人员来做。
12、请问你们的测试退出或结束的标准是什么？你们系统上线后是如何组织测试的？ 我们公司的测试结束的标准是公司制定的质量标准，通常是：
1、&amp;nbsp;测试用例对需求功能点的覆盖达到100%
2、&amp;nbsp;测试用例执行率达到90%以上
3、&amp;nbsp;发现的致命、严重级别的缺陷修复率为100%（都得到修复）
4、&amp;nbsp;发现的一般和轻微的缺陷修复率达到90%（遗留的缺陷不能影响用户的正常使用，可以推迟到下一个版本进行修改）
5、&amp;nbsp;在最近一轮的回归测试中未发现致命和严重级别的缺陷。
系统上线之后就是正式的环境，一般我们会在上面做一些验证的工作，通过一个特定的账号跑一下主要流程，完成之后再把测试数据清掉。一般我们不在线上环境做太多的细致的功能测试工作，对应线上环境，我们会有一套用户验收环境（UAT环境），软硬件环境完全模仿线上环境，如果线上环境出现bug，我们会现在UAT环境当中进行复现，如果不能复现再考虑线上环境和UAT环境的差异，进行排查定位。 &amp;nbsp;&amp;nbsp;
13、优惠券测试点有哪些？ 1、就比如在某宝上买东西，达到什么要求才能领取优惠券，不符合要求不能领取，然后一件商品需要到什么样的价格条件才可以使用优惠券
2、这个优惠券的使用周期是多久？达到什么样的要求能使用什么面额的优惠券（如5,10,20，50,99不等），过期了能不能使用都需要测试
3、能不能给别人使用，能不能叠加使用，使用过的优惠券还能不能继续使用，还有未使用和已使用的优惠券状态能不能区分，通常已使用的优惠券是置灰状态，这些都需要测试
4、还有就是现在网站正在做什么活动，然后购买某样商品可以打五折，优惠券能不能和其他活动一起使用
5、还有一个重点，就是购买了一件商品，使用了优惠券，然后退货，而这样商品的价格和使用了优惠券的价格不一致，那么退货后退款是按照优惠后的价格来推，那么这个优惠券能不能再次使用，这里就和需求规定有关
6、这个优惠券的后台功能，比如如何创建优惠券，设置优惠券的使用条件，使用的有效期，如何展示，和退款退货流程相关联等 14、如何查看系统日志☆☆☆☆☆ web端的日志通常保存在数据库中，可以通过连接测试数据库通过sql语句来进行log日志的查询，有的系统也会保存在服务器端，需要连接liunx系统进行查询
手机端的如果是安卓系统可以通过adb命令来进行日志查看 adb logcat，也可以把日志抓取到本地来进行查看 adb logcat &gt;c:\logcat.txt
如果是苹果手机iOS端的，需要通过开发环境x-code进行查询，所以如果查询苹果手机的日志需要请开发人员协助
内容太多写不下，需要的请评论888获取！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ebb47f518b4a83a8ed540ad4219aeb0/" rel="bookmark">
			【Cadence Allegro 17.4 】学习日志005——常用操作指令汇集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OrCAD Capture CIS画原理图时常使用的操作指令，汇总如下：
（时时更新，文章用于记录自我学习，常忘常看~）
1.放置元器件 ❶执行菜单命令Place→Part→在Library面板中选择所需要放置的元器件→双击后将鼠标移至原理图编辑区即可出现元器件→在原理图空白处单击一下鼠标即可将元器件放置成功；
❷直接点击左侧工具栏的第二个图标，或者店家Par面板左侧的图标，将鼠标移至原理图编辑区即可出现元器件，在原理图空白处单击一下鼠标即可将元器件放置成功；
❸可以通过预览图快速检查所选择的元器件是不是自己需要的；
❹执行放置命令时会连续执行，按一下Esc键可以退出当前命令，结束放置；或者鼠标右击，选择End Mode选项，结束放置。
2.移动 / 对齐 / 旋转元器件 ❶单个元器件移动：直接使用鼠标拖动即可移动；多个元器件移动：使用鼠标框选住需要移动的那部分元器件，框住部分会变成紫色，当鼠标光标移至元器件主体上时会出现可移动标志，此时按住元器件拖动即可；
❷
❸
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03d736c92f2428d5781937847d0ec813/" rel="bookmark">
			【华为网络-配置-004】-VLAN 及三层交换配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要求： 1、两台交换机配置 vlan ，使同 vlan 间 PC 可以相互 ping 通。不同 vlan 间不能相互ping 通。
2、配置三层交换，使不同 vlan 间也可以互相通信。
一、VLAN 配置（完成要求 1） 1.1 LSW1 配置 用 batch 参数批量创建 vlan 10 和 vlan 20，也可以用两条 vlan （编号）命令创建。（vlan batch 30 to 40 这种形式的命令可以创建 vlan 30号、31号、32号......40号） [LSW1]vlan batch 10 20 进入对应链接终端（PC等）的接口。配置接口模式为 access。配置此接口对应的默认 vlan 号。 [LSW1]interface Ethernet 0/0/2 [LSW1-Ethernet0/0/2]port link-type access [LSW1-Ethernet0/0/2]port default vlan 10 [LSW1-Ethernet0/0/2]quit [LSW1]interface Ethernet 0/0/3 [LSW1-Ethernet0/0/3]port link-type access [LSW1-Ethernet0/0/3]port default vlan 20 [LSW1-Ethernet0/0/3]quit 进入对应链接交换机的接口。配置接口模式为 trunk。允许接口能经过 vlan 10 20 的数据包（10 20 可以用 all 代替表示可以经过所有 vlan 的数据包）。 [LSW1]interface Ethernet 0/0/1 [LSW1-Ethernet0/0/1]port link-type trunk [LSW1-Ethernet0/0/1]port trunk allow-pass vlan 10 20 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03d736c92f2428d5781937847d0ec813/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebf9c8868def1e1e809a32da078348cb/" rel="bookmark">
			面试记录_
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1: ❀公司 三道编程题，可以运用你最擅长的语言编写：可以尝试搜索、查找、暴力遍历等方法
稍微复杂点的题目，基本上通过递归、BFS/DFS 解决，暴力也可尝试。
常考知识点&amp;算法：
1、排序
2、查找
3、字符串切割、子串查找、统计，替换
4、数的不同进制表示及转换
5、区间合并
6、全排列
7、二叉树，并查集，单调栈
8、位运算
9、数学表达式计算
10、广度/深度优先搜索
11、图类的单源路径搜索
https://blog.csdn.net/armstronghappy/article/details/119236183
线上笔试 进程流调，最大快乐数（读书），内存操作
现场🍣代码 同构字符串
def main(): s = "badc" t = "bada" list_s = list(s) list_t = list(t) dic_s2t = {} dic_t2s = {} for i in range(len(list_t)): x, y = list_s[i], list_t[i] if (x in dic_s2t and dic_s2t[x] != y) or (y in dic_t2s and dic_t2s[y] != x): return False dic_s2t[x] = y dic_t2s[y] = x return True if __name__ == '__main__': print(main()) 三角形最大周长
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebf9c8868def1e1e809a32da078348cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3da0702a12c456b7e13803d28e81ee2d/" rel="bookmark">
			通过sed在文档下面添加内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写了一下午的脚本，大部分时间都花在正则上了，以下是总结
想要在指定字符串的结尾添加
sed "/指定字符串/ s/$/&amp;你要添加的内容/" 文件名 sed "/指定字符串/s:$: 你要添加的内容:" sed "/指定字符串/s|$| 你要添加的内容|" 想要指定字符串哪一行其中一部分内容替换成空
sed "/指定字符串/ $/你要减去的内容/ /" 文件名 在指定字符串的下一行结尾添加
sed "/你要选择当前一行的字符串/ {n;s/$/你要在下一行结尾添加的内容/}" 文件名 在指定行号的后面添加字符
sed “行号 s/$/追加的内容/” 文件名 在所有行的结尾添加内容
sed 's/$/添加的内容/' 文件名 如果输出内容是分开的字符串，想让他变成一行
[root@test1 ~]# grep xp /etc/group|grep -Eo '[[:digit:]]' 1 0 0 1 如果输出结果想要变成1001只需要在后面加上 sed ':a;N;$!ba;s/\n//g' 即可 [root@test1 ~]# grep xp /etc/group|grep -Eo '[[:digit:]]'|sed ':a;N;$!ba;s/\n//g' 1001 统计文本中重复的次数
awk -F, '{a[$2]++}END{for (i in a) print i" "a[i]}' 文件名.txt cat 文件名.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3da0702a12c456b7e13803d28e81ee2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1de0b2335800440d5fb44d5135189b82/" rel="bookmark">
			js获取日期的农历时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/** * 获取某个日期的农历 * @parmas {newDate} 日期 年-月-日 */ function getLunar(newDate){ var nyear; var nmonth; var nday = -1; var nwday; var nhrs; var nmin; var nsec; var newDate = newDate; var lmonth, lday, lleap; //农历参数 function Draw() { NewTick(); //显示时间 var s = nyear + '年' + nmonth + '月' + nday + '日 ' + '星期' + cweekday(nwday) + ' ' + shapetime(nhrs, nmin, nsec); s += "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1de0b2335800440d5fb44d5135189b82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24344ffafa1d6f033f0114f861e294b3/" rel="bookmark">
			Feign:熔断,@FeignClient注解参数简介,优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相对于RestTemplate来说更加易懂 ，操作方面更加动态化。代码如下：
@GetMapping("/buy/{id}") public Product order() { Product product = restTemplate.getForObject("http://shop-serviceproduct/product/1",Product.class); return product; } 由代码可知，我们是使用拼接字符串的方式构造URL的，该URL只有一个参数。但是，在现实中，URL 中往往含有多个参数。
Feign简介 相关依赖:
&lt;!--springcloud整合的openFeign--&gt; &lt;dependency&gt;
&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
&lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
&lt;/dependency&gt;
Feign是Netflflix开发的声明式，模板化的HTTP客户端。
SpringCloud中，使用Feign非常简单——创建一个接口，并在接口上添加@FeignClient注解。
在消费者的微服务启动类上加上@EnableFeignClients注解开启Spring Cloud Feign的支持功能。
package com.zb; import com.zb.service.impl.TestServiceImpl; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.openfeign.EnableFeignClients; import org.springframework.context.ConfigurableApplicationContext; /** * 启动类 */ @EnableFeignClients @SpringBootApplication public class UserApplication { public static void main(String[] args) { SpringApplication.run(UserApplication.class, } } Feign本身不直接支持负载均衡策略，而是通过集成Ribbon来实现负载均衡。因此，Feign可以使用Ribbon支持的各种负载均衡策略，包括轮询、随机、权重、最佳可用等。
服务熔断 SpringCloud Fegin默认已为Feign整合了hystrix，所以添加Feign依赖后就不用在添加hystrix。
yml配置开启熔断
feign: hystrix: enabled: true package com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24344ffafa1d6f033f0114f861e294b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/905c36ac2f2dce0e56e2d14c09bcc130/" rel="bookmark">
			20231103配置cv180zb的编译环境【填坑篇】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		20231103配置cv180zb的编译环境【填坑篇】
2023/11/3 11:36
感谢您选择了晶视科技的cv180zb，让我们一起来填坑。
在你根据文档找不到答案的时候，是不是想把他们家那个写文档的家伙打一顿，我顶你。
当你在在网上找一圈，BAIDU/BING/GOOGLE之后还是找不到答案，是不是想把他们的老板也打一顿。
没事的，北京晶视智能科技有限公司的法定代表人： 赵红爱
【如果有任何事/不满，就】冲他来吧！
https://aiqicha.baidu.com/detail/compinfo?pid=11718665230024&amp;rq=ef&amp;pd=ee&amp;from=ps&amp;query=%E5%8C%97%E4%BA%AC%E6%99%B6%E8%A7%86%E6%99%BA%E8%83%BD%E7%A7%91%E6%8A%80%E6%9C%89%E9%99%90%E5%85%AC%E5%8F%B8
男人何苦为难男人，要知道，晶视那帮写文档的男人，我们这帮做技术的是和你们站在一个战壕里的！
我们一起将晶视发扬光大，为什么整这么多大坑呢？
你们提供STEP-BY-STEP的文档，我们可以把时间花在别的地方，让晶视更加发光发热的地方。
大陆这么多公司，怎么这帮苦逼的人就不能帮他们把坑给填上，花了我两天时间搜索BAIDU/BING才把坑给填完！
实际上，这些最基础的编译文档，只要给晶视自己新入职的新手工程师从头验证一下文档中的步骤，就可以查漏补缺了！
SDK：
https://developer.sophgo.com/thread/471.html
HDK：
https://developer.sophgo.com/thread/472.html
# how to build and use dual_fast_ipc
1. build SDK first
1.1 tar -zxvf 2023-10-04_source.tar.gz
1.2 cd 2023-10-04_source
1.3 source build/cvisetup.sh
1.4 defconfig cv180zb_wevb_0008a_spinor
1.5 build_all
2. build dual_fast_ipc
主要操作步骤：
rootroot@rootroot-HP-245-14-inch-G10-Notebook-PC:/usr/bin$ sudo ln -s python3.8 python
rootroot@rootroot-HP-245-14-inch-G10-Notebook-PC:~/2023-10-18_source$ pip install ruamel.yaml
pip install yoctools -i https://pypi.tuna.tsinghua.edu.cn/simple
rootroot@rootroot-HP-245-14-inch-G10-Notebook-PC:~/2023-10-18_source/mars_alios/boards/cv181xc_evb/configs$ sudo cp product /usr/bin/
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/905c36ac2f2dce0e56e2d14c09bcc130/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c281c46cba5bb12b2bae8da48fc71ac/" rel="bookmark">
			【SWAT水文模型】率定参数选择及校准技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SWAT模型率定参数选择及校准技巧 水量平衡与径流（Water Balance And Stream Flow）1 基本水量平衡和总径流校准（Basic Water Balance &amp; Total Flow Calibration）1.1 校准地表径流：1.2 校准地下径流： 2 流量过程线校准（Temporal Flow Calibration）2.1 峰值看起来合理，但是衰减期值降得太快2.2 在融雪季节里，峰值会很高而衰退值很低、2.3 部分洪峰没有模拟 3 径流空间上的校准（Spatial Flow Calibration） 参考 水文模型评价指标参见另一博客-【水文模型】评价指标。
SWAT模型率定（CALIBRATION）分为以下几步：
1、水文-水量平衡与径流
2、泥沙
3、水质-营养物（氮、磷、农药、DO、细菌）
由于本人研究只关注流量大小，在此只介绍【水量平衡与河流流量】相关率定步骤。
水量平衡与径流（Water Balance And Stream Flow） 在校准之前，必须对流域内的实际情况有所了解。理论上，必须具有河流实测数据或是流域出口实测数据。首先对年平均值做校准，年校准之后，可以延伸至月、日记录，进行校准微调。
年平均观测和模拟值汇总为下表的格式：
项目Total Water Yield 总水量Baseflow 基流Surface Flow 地表径流实测 ObservemmmmmmSWAT Simulationmmmmmm 如果在流域出口处校准，对应的 SWAT 值的表在.std （SWAT运行保存文件夹中）文件中。在文件的末尾，在标题为Ave Annual Basin Values 的表中列出了这些值。
如果对流域内某个测站进行校准，总水量可以从河段.rch文件的FLOW_OUT字段计算得到。
基流和地表径流值必须从HRU 输出文件（.sbs）或子流域输出文件 (.bsb)得到。
为估计基流和径流的贡献，必须对GWQ，SURQ和总水量(WYLD) 的年平均值做平均计算，以求得目标流域面积加权平均值。
地表径流（SURQ）和基流（GWQ）必须转化为对总水量(WYLD)的百分比，这些百分比然后乘以河道输出文件中的总水量。
不能直接用基流（GWQ）和SURQ 地表径流（SURQ）的值，是因为河道内的降水，蒸发，输移损失等会改变从HRU或子流域输出文件的总水量(WYLD)字段预测的净水量。
这里有几种把观测径流量分割为基流和地表径流，并计算其百分率的方法。如果有每日径流数据，可以使用基流分割程序来完成这项分析过程。
1 基本水量平衡和总径流校准（Basic Water Balance &amp; Total Flow Calibration） 基本要素：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c281c46cba5bb12b2bae8da48fc71ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bdd0a1f0d1bd97d3f6756449cd90ee3/" rel="bookmark">
			静态库的概念及影响
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、目标文件的生成： 由编译器针对源文件编译生成，生成的.o或者.so(动态库)或者.a(静态库)也可以看作是目标文件；
2、静态库的生成： 由给定的一堆目标文件以及链接选项，链接器可以生成两种库，分别是静态库以及动态库；
3、静态链接指定是哪个阶段/过程？ 静态链接是指将多个目标文件链接在一起以创建可执行文件(该可执行文件用到了静态库)或静态库的过程。
4、当使用静态库作为目标文件进行链接时(这个过程叫做静态链接)，链接器做了什么？ 当你使用静态库进行静态链接时，链接器只取静态库中被使用到的目标文件，而静态库中没被使用的目标文件不会进行链接。然后将它们与你的程序的其他目标文件一起链接到最终的可执行文件中。
5、将静态库链接到动态库时，链接器做了什么？有什么影响？ 1）链接器做了什么：
静态库链接到动态库时，链接器会执行静态链接，即将这个静态库中被使用到的代码完全复制到生成的动态库中。
2）有什么影响：
如果多个动态库都链接了同一个静态库，每个动态库都会包含一份该静态库的拷贝。会导致内存浪费；可能存在一致性问题，即动态库A拷贝了静态库M的版本1；动态库B拷贝了静态库M的版本2，而静态库M的版本1与版本2对同一个函数做了修改，这样可执行文件运行时调用版本1还是版本2的函数是不确定的。 3）建议：
将静态库链接到动态库中不是一个常见或推荐的做法，因为它可能引发一系列问题。如果有必要共享代码，通常更好的做法是将代码放入动态库中。
6、由静态库引发的程序段错误案例 1）现象： 可执行文件E运行时，调用一个类C中的函数F后崩溃，提示段错误。
2）直接原因：分析后段错误的原因是野指针(调飞了)，即找不到函数F的地址。
3）根本原因： 该类C定义在静态库M中，静态库M被静态链接到动态库A与动态库B中，动态库A与B又被链接到可执行文件E中。而动态库A与B是分别在不同时间编译的。A与B编译期间一个coder修改了静态库M中类C的内容，导致A与B用到的静态库M不同/类C不同/函数F地址不同(即类C的声明所在的头文件H未对齐),即遇到了【5】中提到的一致性问题。
4）段错误出现的流程：可执行文件E运行时，按照动态库A中包含的M中的头文件H查找函数F的内存地址并调用，而可执行文件E加载了动态库B中包含的M中函数F所在的头文件H的声明与实现。因此出现了地址错位，因此该指针为野指针，导致段错误。
7、参考资料： 1）彻底理解链接器：三，库与可执行文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9eb5695d8e3955d25d605d79d4495a8b/" rel="bookmark">
			【优秀毕设】基于vue&#43;ssm&#43;springboot的校园交友网站系统设计（附源码论文）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要
随着信息技术和网络技术的飞速发展，人类已进入全新信息化时代，传统管理技术已无法高效，便捷地管理信息。为了迎合时代需求，优化管理效率，各种各样的管理系统应运而生，各行各业相继进入信息管理时代，校园交友网站就是信息时代变革中的产物之一。
任何系统都要遵循系统设计的基本流程，本系统也不例外，同样需要经过市场进行调研，论文需求进行分析，概要设计，系统详细设计，测试和编码等步骤，设计并实现了校园交友网站。系统选用java语言，B/S模式和Mysql为后台数据库。系统主要包括首页、个人中心、用户管理、线下活动管理、交友信息管理、活动报名管理、交流论坛、系统管理等功能模块。
本文首先介绍了校园交友管理的技术发展背景与发展现状，然后遵循软件常规开发流程，首先针对系统选取适用的语言和开发平台，根据需求分析制定模块并设计数据库结构，再根据系统总体功能模块的设计绘制系统的功能模块图，流程图以及E/R图。然后，设计框架并根据设计的框架编写代码以实现系统的各个功能模块。最后，对初步完成的系统进行测试，对功能、单元和性能进行测试。测试结果表明，该系统能够实现所需的功能，运行状况尚可并无明显缺点。
关键词：校园交友；java； Mysql数据库
3 系统需求分析 本章节主要是对系统设计目标，系统功能需求，系统性能需求，开发环境等方面对系统进行了详细的论述分析。
3.1 系统设计的目标 本系统主要是针对线下管理方式中管理不便与效率低的缺点，将电子商务和计算机技术结合起来，开发出管理便捷，效率高的校园交友网站。该系统操作简单方便，界面友好，容易管理和维护；而且对校园交友的管理具有较强的针对性，实用性和可操作性，可初步解决线下管理因各种因素限制，高成本等因素造成的一系列不便。
3.2 系统可行性分析 一个完整的系统，可行性分析是必须要有的，因为他关系到系统生存问题，对开发的意义进行分析，能否通过本系统来补充线下校园交友管理模式中的缺限，去解决其中的不足等，通过对本系统，不仅能使工作量不断地减少，还能使工作和管理的效率更加高。所以开发该系统能实现更大的意义和价值，系统完成后，能否达到预期效果就要通过可行性分析，分析之后，决定此系统是否开发。该校园交友网站的开发设计中，下面我们将从经济、技术、操作、运行、时间等方面来选择这个系统最终是否开发。
3.2.1 经济可行性 由于本系统是作为毕业设计系统，且系统本身存在一些技术层面的缺陷，并不能直接用于商业用途，只想要通过该系统的开发提高自身学术水平，不需要特定服务器等额外花费。所有创造及工作过程仅需在个人电脑上就能实现，使用到的软件大多为开源软件，所以经济成本并不高，可以轻易实现。
4 系统整体设计 4.1系统设计思想 系统确定了各项需求，完成了系统的分析和数据库的设计，它就可以根据系统的特点决定系统的发展模式，才能实现代码。通过对系统的分析，这个系统是属于一个小项目，所完成的功能相对简单，就是对数据的基本操作。从而决定采用B/S开发模式。该模型的基本过程是：当用户访问系统的浏览器，或从用户向服务器发送请求时，通过接收请求，然后调用数据访问逻辑运算如比，将结果返回给将结果返回到用户通过浏览器。
使用开发的模型时，我们要把一些常用的，可以重复使用了java技术。当用户浏览网页，很多网页上的信息是从数据库动态删除，这就要求网页必须有数据库操作的能力，如连接数据库和数据表，更新。一个系统包含多个相同的网页，实现数据库操作功能的、代码就需要在不一样的网页中重复的被使用，这样不仅降低了工作的效率，一般也会给维护带来较大的麻烦。为了弥补这一缺陷，功能代码应该在java中完整的数据库操作，可以使用在每一个页面上。
4.2 系统设计主要功能 通过市场调研及咨询研究，了解了使用者及管理者的使用需求，于是制定了管理员和用户的功能模块。其功能结构图如下图4-1所示：
图4-1系统功能结构图
系统功能展示 开发说明 开发语言：Java
框架：springboot
JDK版本：JDK1.8
服务器：tomcat7
数据库：mysql 5.7
数据库工具：Navicat11
开发软件：eclipse/myeclipse/idea
Maven包：Maven3.3.9
浏览器：谷歌浏览器
论文全文+源码下载 论文及源码讲解视频地址：
https://download.csdn.net/download/DeveloperFire/88298254
相关推荐：
https://download.csdn.net/download/DeveloperFire/87795058
https://download.csdn.net/download/DeveloperFire/87594335
https://download.csdn.net/download/DeveloperFire/87594321
https://download.csdn.net/download/DeveloperFire/87594298
资源截图 ​
源码截图 ​
相关推荐（海量资源，欢迎咨询） ​
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95519db9cdc91e414668ad65878adcf9/" rel="bookmark">
			Chrome浏览器访问百度失败，提示“Err_Connection_Reset”错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【问题】 Google Chrome 浏览器是 Windows 7、Windows 10 、Windows 11 等平台的最佳网络浏览器之一。尽管如此，但它也是有缺点的。最近不少同事反应在使用时遇到了一条显示 “ERR_CONNECTION_RESET ”的错误消息。
【原因分析】 “ERR_CONNECTION_RESET ”问题可能是由多种问题引起的，包括网络问题、错误的配置、缓存等，甚至可能是恶意软件造成的。最常见的原因是：
网络问题：如果您的网络连接配置不正确，可能遇到此错误。可以通过对网络设置进行一些调整来解决。系统防火墙：防火墙可能会阻止某些连接，从而导致错误。可以将其关闭或对防火墙设置进行一些更改。 浏览器缓存：浏览器缓存可能是 ERR_CONNECTION_RESET 错误背后的罪魁祸首。可以通过清除缓存解决。防病毒冲突：众所周知，第三方防病毒程序会导致出现问题，尤其是在您使用多个防病毒应用程序时。恶意软件：某些恶意软件可能会在您的计算机上导致此错误。可以通过安全软件杀毒来解决。 【解决办法】 在此，只针对网络正常的情况下出现“ERR_CONNECTION_RESET”的解决方法：
方法1：清除浏览器缓存
清除浏览器数据会删除您的 cookie 和历史记录，当然您可以选择执行。操作步骤如下：
首先，打开 Google Chrome，单击右上角三个点图标，将鼠标悬停在“更多工具”上，然后选择“清除浏览数据” 。
其次，确保时间范围设置为所有时间。勾选以下选项：浏览历史记录、Cookie 和其他站点数据以及缓存的图像和文件。单击【清除数据】按钮。该过程结束后，重新启动 Google Chrome 并查看是否正常。
方法2：重置浏览器配置
重置浏览器步骤如下：
首先，打开 Google Chrome，单击右上角三个点图标，选择“设置” 。
其次，点击【重置并清理】-&gt;【将设置还原为原始默认设置】-&gt;【重置设置】。该过程结束后，重新启动 Google Chrome 并查看是否正常。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6659c069232eb274df630426c58e6ca4/" rel="bookmark">
			element-ui基础组件-message
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、message组件 1.避免重复弹窗
（1）element-ui
this.$message.closeAll();
this.$message.error('请勿重复添加根节点！');
（2）antd-design
message.destroy();
message.error('请勿重复添加根节点！');
（3）若项目中出现场景较多，建议全局配置js。
第一步:新建optimizePop.js
// 重置 message，防止重复点击重复弹出 message 弹框 import { Message } from 'element-ui' let messageInstance = null const mainMessage = options =&gt; { // 如果弹窗已存在先关闭 if (messageInstance) messageInstance.close() messageInstance = Message(options) } const arr = ['success', 'warning', 'info', 'error'] arr.forEach(type =&gt; { mainMessage[type] = options =&gt; { if (typeof options === 'string') { options = { message: options } } options.type = type return mainMessage(options) } }) const message = mainMessage export default message 第二步：main.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6659c069232eb274df630426c58e6ca4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e4fd6a8c9a424b7176b09ae8567aa77/" rel="bookmark">
			前端如何配置hosts
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 以管理员身份运行 cmd
2.在控制台输入notepad - 弹出一个txt
3.打开文件 windows - System32 - drivers - etc 4.复制想要配置的路径到此文档
5. finish
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/846524039566c3cf9b2a1ac344347ddd/" rel="bookmark">
			【mongo事务】使用docker-compose启动mongo,‘单副本模式‘实现支持事务。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想要mongo支持事务的首要条件是mongo版本4.x 以上，且为复制集模式。由于很多时候使用mongo都不需要部署多副本，但是想支持事务，所以可以使用‘单副本模式’，既能保证mongo实例只有一个，又是复制集模式。
本文使用mongo5.0.8作为样例。
本文只是日常遇到问题的小记，如有错误，欢迎指出。
首先给出docker-compose.yml version: '3.0' services: mongo: image: mongo:5.0.8 restart: unless-stopped container_name: mongodb command: --replSet rs0 --bind_ip_all --keyFile /data/mongodb/keyFile environment: TZ: 'Asia/Shanghai' #用户名密码 MONGO_INITDB_ROOT_USERNAME: 'admin' MONGO_INITDB_ROOT_PASSWORD: 'password' ports: - 27017:27017 volumes: - ./mongodb/data:/data/db - ./mongodb/keyFile:/data/mongodb/keyFile 准备keyFile 本人粗略测试在4.x版本不需要使用keyFile,但是在5.x版本是必须要KeyFile的，不然会报 “BadValue: security.keyFile is required when authorization is enabled with replica sets”
生成keyFile openssl rand -base64 128 &gt; ./mongodb/keyFile 其中 ./keyFile 是指定生成文件的名字以及在哪一个文件夹下
设置权限以及所属用户 keyFile文件的权限必须为600,如果权限太大，启动时会报“error opening file: /data/mongodb/keyFile: bad file”
当权限改为600以后还需要把keyFile文件的所属用户和用户组改为mongodb不然在启动时会报"permissions on /data/mongodb/keyFile are too open"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/846524039566c3cf9b2a1ac344347ddd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/059adf334e87fa95ce1c801e32f1eebd/" rel="bookmark">
			Vue报错：may use special comments to disable some warnings. Use // eslint-disable-next-line to ignore
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目运行时，报错 You may use special comments to disable some warnings. Use // eslint-disable-next-line to ignore the next line. Use /* eslint-disable */ to ignore all warnings in a file. 解决办法 方法一 找到项目根目录下的bulid文件夹下的 webpack.base.conf.js，找到以下代码块并注释掉第三行代码
module: { rules: [ ...(config.dev.useEslint ? [createLintingRule()] : []), //注释掉该行代码 { test: /\.vue$/, loader: 'vue-loader', options: vueLoaderConfig }, 注释完保存退出，重新启动项目即可。
方法二 关闭eslint语法检测，在.eslintrc.js文件中，注释掉 eslint:recommended。
方法三 当项目并不存在build文件夹，即不属于vue脚手架工程，那请到根目录下 config文件夹下的index.js文件，将useEslint属性设置为false。
方法四 如果是vue3新项目的话，找不到上面的文件，找到vue.config.js把vue.config.js中的lintOnSave的值改为false即可。但如果在vue.config.js中没有lintOnSave则添加
lintOnSave: false module.exports = defineConfig({ transpileDependencies: true, lintOnSave: false }) 然后重新启动就行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/059adf334e87fa95ce1c801e32f1eebd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efee74fbaba3d9f752f2d16edc5f0754/" rel="bookmark">
			js进阶学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文章是自学，有错误欢迎指出
循环 for(i=0;i&lt;10;i++){} 输出 console.log("a") prototype 在JavaScript中，prototype是一个对象，它允许定义一个对象的实例方法。通过将这些方法添加到原型对象上，可以使得它们在所有创建的对象实例中共享。这意味着，当你创建一个对象时，你可以在该对象的实例上调用这些定义在原型对象上的方法。
下面是一个示例，展示了如何使用prototype来定义一个简单的Person类，并在其上添加一个名为greet的方法：
// 创建一个Person类 function Person(name) { this.name = name; } // 在Person类的原型上添加greet方法 Person.prototype.greet = function() { console.log(`Hello, my name is ${this.name}`); }; // 创建一个Person对象实例 const person1 = new Person('Alice'); const person2 = new Person('Bob'); // 在对象实例上调用greet方法 person1.greet(); // 输出: Hello, my name is Alice person2.greet(); // 输出: Hello, my name is Bob 在这个示例中，我们定义了一个Person类，并在其原型上添加了一个名为greet的方法。然后，我们创建了两个Person对象实例，并在每个实例上调用greet方法。由于这个方法是在Person类的原型上定义的，所以它可以在所有的Person对象实例上共享和访问。
split() 在JavaScript中，可以使用split()函数来分割字符串。split()函数根据指定的分隔符将字符串分割成数组。
以下是split()函数的基本用法：
在这个例子中，我们使用逗号（,）作为分隔符，将字符串"Hello, World!"分割成了两个部分。
split()函数还可以接受第二个参数，表示分割的次数。例如：
let str = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/efee74fbaba3d9f752f2d16edc5f0754/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37b087cd42f84e12e374e76f0ff90642/" rel="bookmark">
			《自制编程语言基于c语言》读书笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 很久之前，我在双十一的时候入手了一本《自制编程语言基于c语言》。这本书是写《操作系统真象还原》的作者。我当时看他的关于操作系统的这本书，非常不错，就连着这本书一起入了。但是后面，因为各种事情，没有来得及仔细翻阅。（当然，当时双十一入手的书有点多，没来及看）。
环境说明 当时，这本书上的代码是基于gcc的，是在linux上面跑的。但是，前不久，我的电脑重刷了系统。下载的window的vm虚拟机也没有了。需要重新下载。下载下来有点麻烦。安装系统啥的。安装gcc啥的。而且各种环境配置也比较麻烦。后期调试也不大方便。我看了一下作者的说明。代码是基于c89的。也没有特别依赖Linux的地方。我想改成window也应该可以运行的。
尝试修改为window环境下运行 我们先拿到源代码，源代码的话，我们到异步社区下载好源码
地址的话，就放到这里:https://box.lenovo.com/l/M1ZtHI
下载好代码以后，打开看一下目录。
这里为了方便修改和测试，我们选择c10文件夹下面的b文件夹里面的代码。直接一步到位。
使用cmake构建项目 使用cmake构建项目，这样方便移植到linux。
修改的文件的编码格式
因为文件编码不一样，在vs里面会警告，所以，修改了一下文件编码格式
修改了一下OBJ_TO_VALUE定义
#define OBJ_TO_VALUE(objPtr) ({ \ Value value; \ value.type = VT_OBJ; \ value.objHeader = (ObjHeader*)(objPtr); \ value; \ }) static Value OBJ_TO_VALUE(void* objPtr) { Value value; value.type = VT_OBJ; value.objHeader = (ObjHeader*)(objPtr); return value; } 上面的语法再gcc里面可以运行，但是在vs会报错。这里改成静态函数。
将内联类改成普通类
inline Class* getClassOfObj(VM* vm, Value object); Class* getClassOfObj(VM* vm, Value object); 这里地方只是改了定义，还有一个函数的实现也需要改一下。
改一下vm的申请内存的代码
VM* vm = (VM*)malloc(sizeof(VM)); VM* vm = (VM*)calloc(1,sizeof(VM)); 用malloc申请的内存不会初始化为0，后期会报错。这里改成calloc全部初始化为0就好。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37b087cd42f84e12e374e76f0ff90642/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebe39fbd61562954774f42656398b532/" rel="bookmark">
			Android 源码学习地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源码学习地址 线上源码类搜索线上源码查看Android 源码学习官方源代码下载镜像 线上源码类搜索 https://cs.android.com/
https://github.com/aosp-mirror
线上源码查看 http://androidxref.com/
http://aospxref.com/
https://www.androidos.net.cn/sourcecode
Android 源码学习 https://www.yuque.com/beesx/beesandroid/vhwgnp
官方源代码下载 https://source.android.google.cn/docs/setup/build/downloading?hl=zh-cn
镜像 https://juejin.cn/post/7008335634263703589
清华大学开源软件镜像站：mirrors.tuna.tsinghua.edu.cn/
中国科学技术大学开源软件镜像站：mirrors.ustc.edu.cn/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dfe971b78317cddd388115481edb033/" rel="bookmark">
			把整形数字转换为二进制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		main()
{
int x,y,i,a[8],j,u,v;
scanf("%d",&amp;x);
y=x;i=0;
do
{
u=y/2; a[i]=y%2;
i++;
y=u;
}while(y&gt;=1);
for(j=i-1;j&gt;=0;j--)
printf("%d",a[j]);
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a648205af1a0e514bae4b30e06e9442d/" rel="bookmark">
			2023年第四届MathorCup大数据挑战赛（B题）|电商零售商家需求预测及库存优化问题|数学建模完整代码&#43;建模过程全解全析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		让我们来看看MathorCup的B题！
问题重述 这是一个电商零售商家需求预测及库存优化问题的描述。这个问题涉及到电商平台上的上千个商家，它们将商品放在不同的仓库中，而电商平台需要进行供应链管理，以降低库存成本并保证按时交货。主要问题包括需求预测和库存优化。
问题一：使用历史出货量数据（附件1）和相关附件中的信息，需要预测各商家在各仓库的商品在2023年5月16日至2023年5月30日的需求量。预测的结果需要填写在结果表1，并上传至竞赛平台。同时，需要对模型的预测性能进行评价，并讨论如何对这些时间序列进行分类以找到相似特征。
问题二：有一些新的商家+仓库+商品维度出现（附件5），需要根据历史数据（附件1）找到相似序列并预测这些新维度在2023年5月16日至2023年5月30日的需求量。预测结果需要填写在结果表2，并上传至竞赛平台。
问题三：每年6月有大型促销，给需求预测和履约带来挑战。附件6提供了去年双十一期间的需求量数据，需要参考这些数据并给出2023年6月1日至2023年6月20日的需求量预测值，填写在结果表3中并上传至竞赛平台。
问题一 问题一涉及对各商家在各仓库的商品需求进行预测，此题我们使用ARIMA模型来进行预测。
步骤1：数据预处理
首先，对历史出货量数据进行预处理，包括数据清洗、缺失值处理等，以确保数据的质量和一致性。对附件2-4的信息也进行必要的数据关联，以便使用商品、商家和仓库的特征信息。
步骤2：时间序列分类
根据问题描述，需要对不同商家、仓库和商品的时间序列进行分类，以找到相似的特征。这可以通过以下步骤来实现：
a. 对每个商家在各仓库的商品需求量序列进行聚类分析，例如使用K均值聚类。
b. 对聚类后的序列进行统计特征提取，如平均值、标准差、季节性等。
c. 基于提取的特征，使用聚类结果将序列分为不同的类别。
步骤3：需求预测
对于每个时间序列类别，使用ARIMA模型进行需求预测。
步骤4：模型评价
评估模型的性能可以使用各种指标，如1-wmape，MAE，RMSE等。1-wmape在问题描述中已经给出，可以计算每个序列的预测误差并汇总为模型整体性能。
ARIMA模型
ARIMA（AutoRegressive Integrated Moving Average）模型是一种经典的时间序列分析方法，用于对时间序列数据进行建模和预测。它结合了自回归（AR）、差分（I）和滑动平均（MA）三个组成部分，用于处理具有趋势和季节性的时间序列数据。ARIMA模型旨在捕捉数据中的自相关性和移动平均性，从而生成未来时间点的预测。 下面是ARIMA模型的核心概念：
自回归（AR）部分：ARIMA模型中的"AR"代表"自回归"。这部分考虑了时间序列中的自相关性，即过去时间点的观测值对当前时间点的影响。AR部分表示为p，它表示在模型中考虑多少期的过去观测值。例如，ARIMA(p, d, q)中的p。
差分（I）部分：ARIMA模型中的"I"代表"差分"。这部分用于处理非稳定的时间序列，即具有趋势和季节性的序列。通过差分，可以将非稳定序列转化为稳定的序列。d表示差分的次数。例如，ARIMA(p, d, q)中的d。
滑动平均（MA）部分：ARIMA模型中的"MA"代表"滑动平均"。这部分考虑了时间序列中的滑动平均性，即过去时间点的预测误差对当前时间点的影响。MA部分表示为q，它表示在模型中考虑多少期的滑动平均误差。例如，ARIMA(p, d, q)中的q。
ARIMA模型的建模步骤通常包括以下几个关键步骤：
观察时间序列数据：首先，分析时间序列数据，检查是否存在趋势、季节性以及自相关性。
差分操作：如果时间序列数据不是稳定的，需要进行差分操作，直到数据变得稳定。差分的次数由参数d决定。
模型识别：通过观察自相关函数（ACF）和偏自相关函数（PACF）的图表，确定ARIMA模型的阶数（p、d、q）。
拟合ARIMA模型：使用选定的参数，拟合ARIMA模型到时间序列数据。
模型诊断：检查模型的残差，确保其是白噪声，没有自相关性。
预测：使用拟合好的ARIMA模型生成未来时间点的预测。
在问题一中，使用ARIMA模型的主要原因是针对历史出货量数据进行需求预测。原因在于：
存在趋势和季节性：ARIMA模型适用于具有趋势和季节性的时间序列数据，这在电商领域通常是普遍存在的情况。历史出货量数据往往受季节性促销、市场趋势等因素的影响，因此需要模型来捕捉这些影响。
稳定性处理：ARIMA模型中的"差分"（I）部分用于将非稳定的时间序列数据转化为稳定的序列。这对于处理数据中的趋势和季节性非常重要，以便模型能够准确预测未来需求。
自相关性和滑动平均性：ARIMA模型的"自回归"（AR）和"滑动平均"（MA）部分分别考虑了时间序列数据中的自相关性和滑动平均性，从而更好地捕捉数据的内在模式。
参数调整：ARIMA模型的参数（p、d、q）可以根据时间序列数据的特点进行调整，以获得更准确的预测。这使得ARIMA模型非常灵活，适应不同类型的时间序列。
因为它可以帮助预测各商家在各仓库的商品需求，考虑了历史趋势、季节性和自相关性，有助于更好地管理库存和满足客户需求。此外，ARIMA模型的参数可以根据不同商家、仓库和商品的需求模式进行调整，从而提高预测的准确性。
代码如下：
import pandas as pd import numpy as np import statsmodels.api as sm from statsmodels.tsa.stattools import adfuller # 读取历史出货量数据 historical_data = pd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a648205af1a0e514bae4b30e06e9442d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba088411327c6af5ff6dc8857ce89496/" rel="bookmark">
			磁盘和硬盘的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 “磁盘”和“硬盘”是两个常用的存储设备名词，容易混淆。事实上，“硬盘”通常指的就是“磁盘硬盘”。为了让大家更清晰区分这两者，下面大家可以详细的了解到磁盘和硬盘的区别。
磁盘
磁盘是一个广泛的概念，用来描述一种存储数据的物理媒介。它可以分为磁盘、光盘和固态盘等。光盘是我们之前常用的数据存储手段，像什么CD、VCD等。磁盘是利用磁性材料的特性来存储和读取数据的。数据以磁化方式存储在磁性介质上，通过磁头来读取和写入这些数据。磁盘可以是软盘、磁盘带、磁盘存储器等。软盘是专门用来进行存储的数据的外部存储器，它不同于硬盘安装在主机中，而是用于外部连接。可以插拔随身携带。
硬盘
硬盘指的是硬盘驱动器，是一种常见的计算机存储设备，通常用于存储和读取大量的数据。硬盘驱动器中的主要存储媒介是磁盘。硬盘内部包含多个旋转的磁性盘片，磁头负责在盘片上读取和写入数据。磁头能够悬浮在磁盘片上方并移动，读写数据。
硬盘有着下面两种特点：
较大存储容量：硬盘存储容量一般较大，可容纳数百GB到数TB的数据。
常见类型：硬盘分为机械硬盘（HDD）和固态硬盘（SSD），其中HDD是以磁性存储为主，SSD则是以闪存芯片为主，二者在工作原理、速度、耐用性等方面有较大区别。
在分别了解了什么是磁盘什么是硬盘之后，我们一起来看一看磁盘跟硬盘的区别有哪些。
磁盘和硬盘的区别
磁盘和硬盘的区别有哪些呢？他们的区别大致可以分为以下的3类：
磁盘是一个广泛概念，包括多种存储介质，如磁盘、光盘等，其中磁盘以磁性原理存储数据。硬盘指的是硬盘驱动器，是一种常见的存储设备，主要采用磁盘作为存储媒介。磁盘和硬盘的区别之一硬盘是磁盘的一种常见形式，以磁性盘片作为数据存储介质，通过磁头进行读写。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e9de87dd138a60b7a517f665ac01f34/" rel="bookmark">
			js获取当前日期前后三天日期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		// 获取当前日期 var today = new Date(); // 获取前后三天 var yesterday1 = new Date(today) var yesterday2 = new Date(today) var yesterday3 = new Date(today) var yesterday4 = new Date(today) var yesterday5 = new Date(today) var yesterday6 = new Date(today) var yesterday = new Date(today) yesterday1.setDate(today.getDate() - 3); yesterday2.setDate(today.getDate() - 2); yesterday3.setDate(today.getDate() - 1); yesterday4.setDate(today.getDate() ); yesterday5.setDate(today.getDate() +1); yesterday6.setDate(today.getDate() + 2); yesterday7.setDate(today.getDate() + 3); console.log(yesterday.getFullYear() + "-" + (yesterday.getMonth() + 1) + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e9de87dd138a60b7a517f665ac01f34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/787d5b9ca484a442485fc987550d6b45/" rel="bookmark">
			PC端windows自动化:pywinauto(四)鼠标和键盘操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、鼠标操作 pywinauto自带的鼠标操作有些时候并不能完全满足要求，可以调用mouse的方法
导入：
from pywinauto import mouse 常见操作：
# 移动鼠标 mouse.move(coords=(x, y)) # 左键单击指定坐标 mouse.click(button='left', coords=(40, 40)) # 鼠标双击指定坐标 mouse.double_click(button='left', coords=(140, 40)) # 将鼠标移动到（140，40）坐标处按下 mouse.press(button='left', coords=(140, 40)) # 将鼠标移动到（300，40）坐标处释放， mouse.release(button='left', coords=(300, 40)) # 右键单击指定坐标 mouse.right_click(coords=(400, 400)) # 鼠标中键单击指定坐标(很少用的到) mouse.wheel_click(coords=(400, 400)) # 滚动鼠标 wheel_dist指定鼠标滚轮滑动，正数往上，负数往下。 mouse.scroll(coords=(1200,300),wheel_dist=-3) # 以控件中心为起点，滚动 def mouse_scroll(control, distance): rect = control.rectangle() cx = int((rect.left+rect.right)/2) cy = int((rect.top + rect.bottom)/2) mouse.scroll(coords=(cx, cy), wheel_dist=distance) mouse_scroll(control=win_main_Dialog.child_window(control_type='List', title='XXX'), distance=-5) 二、键盘操作 导入：
from pywinauto import keyboard pywinauto模拟操作键盘，需要使用到 pywinauto.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/787d5b9ca484a442485fc987550d6b45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b6afe3b252cd5c02115eb3c09c5ce42/" rel="bookmark">
			mysql 统计昨日，当月，当年，最近30天，最近12月
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 昨日
select SUM(your_value_field) as sValue from your_table where TO_DAYS(CURDATE())-TO_DAYS(your_date_field)=1 当月
SELECT sum(your_value_field) as sValue FROM your_table where DATE_FORMAT(your_date_field, '%Y%m') = DATE_FORMAT(CURDATE(), '%Y%m') 当年
select sum(your_value_field) as sValue from your_table where YEAR(your_date_field) = YEAR(CURDATE()) 最近30天
SELECT date(your_date_field) as sDate, SUM(your_value_field) as sValue FROM your_table where (date(your_date_field) BETWEEN DATE_SUB(CURDATE(), INTERVAL 30 DAY) AND CURDATE()) GROUP BY date(your_date_field) ORDER BY date(your_date_field) 最近12月
SELECT date(your_date_field) as sDate, SUM(your_value_field) as sValue FROM your_table where (date(your_date_field) BETWEEN DATE_SUB(CURDATE(), INTERVAL 12 MONTH) AND CURDATE()) GROUP BY YEAR(your_date_field), MONTH(your_date_field) ORDER BY YEAR(your_date_field), MONTH(your_date_field) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4fdbc39f05277acbf4db1c9b2420eb1/" rel="bookmark">
			在职场上，有多少人输在了不会用python数据分析？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在职场上，数据分析已经成为各个职能岗位的必备技能。无论是从事金融、职教、法律、汽车等专业领域，还是想要提升自己的工作竞争力，掌握数据分析技能都是必不可少的。而在数据分析领域，Python作为一种强大的工具和编程语言，正在成为越来越多人的选择。
1、那么，学了Python后，能够做哪些事情呢？ 首先，Python可以帮助进行数据清洗和处理。在现实工作中，常常需要处理大量的数据，而Python提供了丰富的数据处理库和函数，能够帮助高效地处理数据，从而得到更准确、更有价值的分析结果。
其次，Python还具备强大的数据可视化能力。数据可视化是将抽象的数据通过图表、图像等形式展现出来，更直观地理解数据的分布、趋势和规律。Python中的matplotlib和seaborn等库提供了丰富的可视化工具，能够轻松地创建各种图表和图像，更好地传递数据分析的结果。
此外，Python还可以进行机器学习和深度学习。随着人工智能的快速发展，机器学习和深度学习已经成为炙手可热的领域。Python中的scikit-learn和TensorFlow等库提供了丰富的机器学习和深度学习算法，能够在数据分析中应用先进的模型和算法，提升分析的准确度和效果。
在使用Python进行数据分析的过程中，我有过一些宝贵的经历。在某次市场调研中，我使用Python对大量的用户数据进行了清洗和处理，然后通过数据可视化的方式展现出来，从而发现了用户行为和偏好的一些规律。这些规律对于市场推广和产品优化有着重要的指导作用，最终帮助我们部门取得了较好的业绩。
2、Python有哪些入门学习方法和值得推荐的经典教材？ 对于想要学习Python的人来说，入门学习方法和经典教材是非常重要的。我个人推荐的入门学习方法是先学习Python的基础语法和常用库，然后再逐步深入学习数据分析相关的库和技术。这样的学习方法可以帮助初学者建立起扎实的编程基础，从而更好地应用Python进行数据分析。
至于经典教材，我推荐《Python编程：从入门到实践》和《Python数据分析基础教程》。这两本书内容全面，适合初学者入门，同时也对Python数据分析的高级技术有所涉及，可以帮助读者全面掌握Python数据分析的技能。
简单的说，掌握Python数据分析技能，不仅能够让你在职场上与众不同，还能够帮助你更好地理解和利用数据，从而为工作带来更大的价值。无论你是想要提升自己的职业竞争力，还是想要在数据分析领域有所建树，学习Python都是一个明智的选择。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b29c900b3f9073215ccbb3d32a608190/" rel="bookmark">
			力扣第474题 一和零 c&#43;&#43; 动态规划 01背包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 474. 一和零
中等
相关标签
数组 字符串 动态规划
给你一个二进制字符串数组 strs 和两个整数 m 和 n 。
请你找出并返回 strs 的最大子集的长度，该子集中 最多 有 m 个 0 和 n 个 1 。
如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。
示例 1：
输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3 输出：4 解释：最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 。 其他满足题意但较小的子集包括 {"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b29c900b3f9073215ccbb3d32a608190/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2b8c214e6459debbe437926db5bbe11/" rel="bookmark">
			如何让 Bean 深度感知 Spring 容器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring 有一个特点，就是创建出来的 Bean 对容器是无感的，一个 Bean 是怎么样被容器从一个 Class 整成一个 Bean 的，对于 Bean 本身来说是不知道的，当然也不需要知道，也就是 Bean 对容器的存在是无感的。
但是有时候我们可能会遇到一些场景，这些场景让我们去感知容器的存在，松哥举几个例子：
Spring 容器提供的功能不止 IoC、AOP 这些，常见的 I18N 也是 Spring 的能力之一，如果我们想要在自己的 Bean 中去使用 I18N，那就得去找 Spring，这样就感知到了 Spring 容器的存在了。Spring 提供了资源加载器，如果我们想要使用这个资源加载器去加载配置，那就得去找 Spring 要，这样就感知到了 Spring 容器的存在了。想根据 beanName 去 Spring 容器中查找 Bean，那不用多说，肯定得知道 Spring 容器的存在。… 也就是说，虽然 Spring 中的 Bean 可以不用去感知 Spring 容器的存在，但是在实际开发中，我们往往还是需要 Spring 容器提供的各种能力，这样就迫使我们的 Bean 不得不去感知到 Spring 容器的存在。
那么 Spring 中的 Bean 如何感知到 Spring 容器的存在呢？
1. Aware Aware 本身就有感知的意思。
Spring Aware 是 Spring 框架中的一个特性，它允许我们的应用程序或组件与 Spring 容器进行交互。当一个类实现了 Spring Aware 接口并注册到 Spring 容器中时，该类就能够感知到 Spring 容器的存在，并且可以获取容器的一些资源或进行一些特定的操作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2b8c214e6459debbe437926db5bbe11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86899882ea4768cfd566044dffe9618d/" rel="bookmark">
			用模型跑一下数据，结果提示OSError: SavedModel file does not exist at: on_object_test.h5\{saved_model.pbtxt|save
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		请大佬看看是什么问题，太头疼了，源代码如下
源代码如下数据集：Pascal VOC Dataset Mirror
import os import sys import xml.etree.ElementTree as ET import cv2 import os os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2' # 不显示等级2以下的提示信息 import tensorflow as tf from tensorflow.python.keras.layers import Input, Conv2D, MaxPooling2D, Flatten, Dense, Reshape, Concatenate, \ concatenate, ZeroPadding2D, Convolution2D,BatchNormalization, Activation, AveragePooling2D, Add from tensorflow.python.keras.models import Model from tensorflow.python.keras.losses import categorical_crossentropy,binary_crossentropy import numpy as np from tensorflow.python.keras.saving.save import load_model from tensorflow.python.ops.init_ops_v2 import glorot_uniform from tensorflow.python.ops.losses.losses_impl import mean_squared_error batch_size=32 input_size=224 # https://juejin.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86899882ea4768cfd566044dffe9618d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75bf87af5468fdd8dd89285f5b977e48/" rel="bookmark">
			（linux-x86）openEuler安装配置OpenJDK1.8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenJDK1.8是Java语言的一种开源实现，任何人都可以免费下载使用。用户可以从OpenJDK1.8的官方网站上下载最新版本的OpenJDK1.8安装包，也可以从Java的官方网站上下载JDK1.8安装包。
下载链接：
OpenJDK1.8官方网站：https://openjdk.java.net/projects/jdk8/
Java官方网站：https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html
安装步骤
从OpenJDK1.8官网或Java官方网站下载安装包。
运行安装包，按照提示进行安装。
配置环境变量，将OpenJDK1.8的bin目录添加到系统的PATH变量中。
验证OpenJDK1.8是否安装成功：在命令行中输入命令"java -version"，如果能够正确输出OpenJDK1.8的版本信息，则表示安装成功。
#创建java，下载openjdk
cd /usr
mkdir java
cd java
wget https://download.java.net/openjdk/jdk8u41/ri/openjdk-8u41-b04-linux-x64-14_jan_2020.tar.gz
#解压，更改文件夹名
tar -zxvf openjdk-8u41-b04-linux-x64-14_jan_2020.tar.gz
ll
mv java-se-8u41-ri openjdk-8u41
#配置环境变量
vi /etc/profile
#最后添加如下内容
export JAVA_HOME=/usr/java/openjdk-8u41
export PATH= P A T H : PATH: PATH:JAVA_HOME/bin
#更新，验证
source /etc/profile
java -version
原文链接：https://bbs.huaweicloud.com/blogs/301909
JDK是 Java 语言的软件开发工具包，主要用于移动设备、嵌入式设备上的java应用程序。JDK是整个java开发的核心，它包含了JAVA的运行环境（JVM+Java系统类库）和JAVA工具。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6d92877ff52dfd08cdfefcfe5d98686/" rel="bookmark">
			图像特征Vol.1：计算机视觉特征度量|第二弹：【统计区域度量】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、前言二、统计区域度量2.1：图像矩特征2.1.1：原始矩/几何矩2.1.2：中心距2.1.3：归一化的中心矩2.1.4：不变矩——Hu矩2.1.5：OpenCv实现矩特征及其应用 2.2：点度量特征2.3：全局直方图和局部区域直方图2.4：散点图和3D直方图2.5：多尺度直方图2.6：径向直方图2.6：轮廓或边缘直方图 一、前言 在前篇图像特征Vol.1：计算机视觉特征度量【纹理区域特征】中，我们说到计算机视觉度量的三类方法，在那篇博客中，我们介绍了纹理区域度量的各个方法。在本篇博客中，我们将继续介绍纹理区域特征的第二类方法：统计区域度量。Let’s Go！
二、统计区域度量 统计区域度量，是利用统计方法，描述图像区域中像素值分布和变化情况的一种方法。 它主要应用在图像处理和计算机视觉领域。对于图像处理方面，在前面的博客【cv】图像预处理技术——从特征检测讲述图像预处理理论、实践、应用|01中，利用全局直方图和局部直方图，对图像进行光照校正、增强对比度，就是统计区域度量在图像处理方面应用的一个体现。这篇博客中，我们将介绍统计区域度量在计算机视觉特征度量中的应用体现。
常见的图像像素统计度量包括以下八种
图像矩特征点度量特征全局直方图局部直方图散点图和3D直方图多尺度直方图径向直方图轮廓或边缘直方图 这些统计度量可以通过对图像像素值进行数学运算和分析来得到。它们可以为图像处理和计算机视觉算法提供重要的特征和信息，从而提高算法的性能和鲁棒性。
接下来，我会基于每种方法给出基本原理，和步骤，以及一些简单的应用举例~Go
2.1：图像矩特征 👧🏻 什么是矩和图像矩？
矩是概率与统计中的一个概念，是随机变量的一种数字特征。在数字图像处理、计算机视觉与相关领域中，图像矩(Image moments)是指图像的某些特定像素灰度的加权平均值（矩），或者是图像具有类似功能或意义的属性。
图像矩通常用来描述 分割后的图像对象。可以通过图像的矩来获得图像的部分性质，包括面积(或总体亮度)，以及有关几何中心和方向的信息 。
💁🏻‍♀️基本思想和原理？
实际上，对于矩，我们实际上可以看作是二维图像在基空间上的投影。 为什么这么说呢？接着看完它的基本思想和原理你应该就懂了。
根据加权求和的方法不同，有不同种类的矩，且每一种矩有各自不同的表示图像特征的特征值。
2.1.1：原始矩/几何矩 对于灰度图像f,其(p+q)阶矩(有时称为"原始矩"),定义如下:
原始矩阵中包含以下可以描述图像特征的信息：
二值图像或者或度图像的像素总和,可以表示为:
图像的几何中心也叫质心 (Cx,Cy) ,计算公式如下
2.1.2：中心距 当图像平移时，原始矩会发生变化（质心肯定会因为平移而改变嘛）。但是中心矩具有平移不变性（但在图像旋转时会发生变化；归一化中心距不仅具有平移不变性，而且具有比例不变性（尺度不变性））。相比于原始矩，它添加了一个基于质心的平移，对于灰度图像f,其(p+q)阶中心矩的定义如下：
ps.述公式中（cx, cy)是用原始矩求出的图像的几何质心
中心矩可以用来计算图像的方向和形状等特征，不管是一维的序列分布还是二维的图像，不同的阶次均具备下述视觉上的规律性性质：
零阶矩：表示一维均值或二维质心；一阶中心矩：包含二维面积、质心和物体/目标大小等相关信息；二阶中心矩：与方差和2D椭圆度量相关；三阶中心矩：提供了二维形状（或偏度）的对称信息；四阶中心矩：用来度量二维分布，如高、矮、细、短、胖等形态；更高阶的矩：可由多个矩的比值组成，比如协方差。 2.1.3：归一化的中心矩 当图像发生平移时，几何距 mpq ​也会发生变化；中心矩 mupq具有平移不变性，但在图像旋转时会发生变化；归一化中心距不仅具有平移不变性，而且具有比例不变性（尺度不变性）。归一化的中心矩定义如下：
2.1.4：不变矩——Hu矩 Hu 利用二阶和三阶归一化中心距构造了 7 个不变矩 M1~M7， 在连续图像下具有平移、灰度、尺度、旋转不变性， 是高度浓缩的图像特征。不变矩能够描述图像的整体性质，从而在边缘提取、图像匹配及目标识别中得到了广泛的应用。
在实际的图像识别中，只有 M1 和 M2 的不变性比较好，而 M3~M7 的误差较大，识别率比较低。Hu不变矩对于物体的形状描述比较稳定，比较适合识别较大尺寸的物体，如水果的形状、车牌的字符等。
2.1.5：OpenCv实现矩特征及其应用 OpenCV 提供了函数 cv2.moments() 计算图像矩 Mu，函数 cv2.HuMoments() 计算目标轮廓的 Hu 不变矩。
函数说明：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6d92877ff52dfd08cdfefcfe5d98686/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ba73008070127b374403fb87450b3ea/" rel="bookmark">
			llava1.5模型安装、预测、训练详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 本博客介绍LLava1.5多模态大模型的安装教程、训练教程、预测教程，也会涉及到hugging face使用与wandb使用。
源码链接:点击这里
demo链接:点击这里
论文链接:点击这里
一、系统环境 ubuntu 20.04
gpu: 2*3090
cuda:11.6
二、LLava环境安装 1、代码下载 git clone https://github.com/haotian-liu/LLaVA.git cd LLaVA 2、虚拟环境构建 conda create -n llava python=3.10 -y conda activate llava pip install --upgrade pip # enable PEP 660 support 3、模型预测安装 pip install -e . 4、模型训练环境安装 pip install -e ".[train]" pip install flash-attn --no-build-isolation # 可能安装失败 5、flash-attn离线环境安装 根据对应环境格式下载相应flash-attn，
flash-attn下载链接点击这里
实际为whl的离线文件，在使用pip install *.whl 即可
三、LLava推理运行 1、启动网页预测(类似服务端与客户端) Launch a controller
python -m llava.serve.controller --host 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ba73008070127b374403fb87450b3ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c7525b4cf628397e2cea2950ee66975/" rel="bookmark">
			Win10系统盘迁移--不借助第三方工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Win10系统盘迁移折腾备忘 前言一、事后诸葛：最简洁方法二、注意事项三、扩展知识 前言 手上在用的笔记本有些年头了，原配是128G的固态硬盘，后续又加了一个500G的固态和1T的机械硬盘。软件装得多了，C盘明显不够用，终于下定决定把系统盘从128G的SSD迁到500G的SSD上去。
过程有些曲折，记录备忘。
一、事后诸葛：最简洁方法 第一步: 备份系统
点击 控制面板里“更新和安全”，点左侧“备份”，在右侧选择“转到备份和还原”
然后选择“创建系统映像”。跟着提示走，备份到另一个空间较大的盘上(至少要100多G)
第二步: 创建U盘恢复启动器
在Windows 左下角搜索栏搜"恢复"，在跳出来的选项中选择“恢复驱动器”应用。准备一个大于2G的U盘，按提示一步步走，创建一个可用于启动的U盘
第三步：重启，在BIOS里设置启动顺序，优先从U盘启动
有些电脑也可以在启动时按功能键临时决定启动次序。总之，从上一步创建的U盘启动
第四步：禁用原来的系统盘。
如果BIOS支持，直接禁用最简单。否则就要拆机，断开这块盘。（很不幸，折腾的这款HP电脑不能从BIOS里禁用，只能拆机）。只所以这样做，是因为在下一步恢复备份时，如果系统探测到原来的盘，就只能恢复到这张盘上。
第五步，从U盘启动电脑，恢复备份
基本上跟着提示走就是了。
第六步：调整分区
重启电脑，可以看到系统已经迁移到新盘上。但是，它会原样复制原来的C盘大小，更糟糕的是，它会在C盘分区后建一个恢复分区，新盘上多出的空间虽然空着，也难以直接合并到C盘上。
所以需要想办法把恢复分区移到最后，把多出的空间合并给C盘
6.1 先在空闲的空间上创建一个新的普通分区，容量为空闲空间减去恢复分区的大小，这个是占位分区，等会儿会删掉。然后再建一个分区，大小就与恢复分区相当了。注意建最后这个分区时，不要选择分配驱动器号，否则将来比较麻烦。
6.2 将备份来的恢复分区移到最后新建的分区：
(1) 先给两个分区分配盘符，方便操作
用diskpart命令
查看有几个硬盘: list disk
选择要操作的那个盘(比如说第一个，编号是0): select disk 0
查看有几个分区: list partition (也可以简写为 list part)
选择要处理的分区(比如说第3个): select part 3
分配盘符: assign letter=R
将原恢复分区盘符设为R，新的设为N 随便设)
(2)备份原来恢复分区资料
使用命令行工具Dism
Dism /Capture-Image /ImageFile:C:\recovery-partition.wim /CaptureDir:R:\ /Name:"Recovery" 这里是把备份的文件放在C盘下
(3)将备份的资料还原到新分区(这里用的盘符是N)
Dism /Apply-Image /ImageFile:C:\recovery-partition.wim /Index:1 /ApplyDir:N:\ (4) 拷贝全部文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c7525b4cf628397e2cea2950ee66975/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f76b31e94edc4dc91651dc1edea7cc1a/" rel="bookmark">
			【微信小程序】使用和风天气接口api（全过程）——获取天气
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍
这里是小编成长之路的历程，也是小编的学习之路。希望和各位大佬们一起成长！
以下为小编最喜欢的两句话：
要有最朴素的生活和最遥远的梦想，即使明天天寒地冻，山高水远，路远马亡。
一个人为什么要努力？ 我见过最好的答案就是：因为我喜欢的东西都很贵，我想去的地方都很远，我爱的人超完美。因此，小编想说：共勉！ 目录
前言
显示效果
一、注册和风天气的账号（具体过程就不演示了）
二、获取和风天气的key
1、创建项目
2、获取key
三、在小程序中的使用
第一步：创建包
第二步：示例代码
workweather.wxml
workweather.wxxs
workweather.js
显示效果 注意：如果各位大佬们，按照该博客不能出现自己想要的效果，那么可以去找其他的方法实现，可将该博客当做一个小小的参考。感谢各位大佬的观看！
一、注册和风天气的账号（具体过程就不演示了） 和风天气的官网
和风天气插件 | 和风天气插件产品，免费、跨终端。适配你的网站、APP、公众号 (qweather.com)
二、获取和风天气的key 1、创建项目 控制台===》项目管理===》创建项目 就可以看到以下页面（注意：如果页面不一样的话，可能是更新了）
这个地方注意一下，看你是做案例还是，公司使用，如果是做案例，可以和小编一样选择免费订阅。设置key的地方你可以选择Web API，如果你选择了 Android SDK / iOS SDK，那么生成的密钥只能使用官方的 SDK 进行数据访问，如果是 Web API的话，可以自己编程获取并解析数据。（当然WebAPI解析比较慢一点，可以稍微等一会）
2、获取key 三、在小程序中的使用 如果是小白的话，没有账号，建议注册一个小程序的账号，具体看小编的这篇文章。有账号跳过这个步骤
【微信小程序】注册小程序账号、做一个案例——你好我的小程序_determine ZandR的博客-CSDN博客
第一步：创建包 第二步：示例代码 workweather.wxml &lt;view class="header-modular" wx:if="{{now}}"&gt; &lt;image class="bg-wave" src="https://codermoyv.gitee.io/coder-moyv/assets/images/wechat/bg_wave.gif"&gt;&lt;/image&gt; &lt;view class="row"&gt; &lt;view class="row location-wrap" bindtap="selectLocation"&gt; &lt;image class="icon" src=""&gt;&lt;/image&gt; &lt;view class="title"&gt;{{City}} {{County}}&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f76b31e94edc4dc91651dc1edea7cc1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/152e4b7ee4caa82335ff4b5875a17320/" rel="bookmark">
			分享66个工作总结PPT，总有一款适合您
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分享66个工作总结PPT，总有一款适合您
66个工作总结PPT下载链接：https://pan.baidu.com/s/1g8AWl42-tLdFYXEHZUYyGQ?pwd=8888 提取码：8888
Python采集代码下载链接：采集代码.zip - 蓝奏云
立冬PPTPPT模板
西藏信仰PPT模板
古镇丽江旅游景点PPT模板
心理健康青少年心理健康PPT模板
唯美读书分享会PPT模板
蓝色清新风年终工作报告PPT模板
蓝色年终总结PP模板
可爱卡通体育运动通用PPT模板
牙科医疗口腔医疗通用PPT模板
水墨古典中国风PPTPPT模板
极简黑白舞者工作总结汇报PPT模板
简约商务汇报商务展示PPT模板
红色人物剪影年终总结新年计划PPT模板
中国风桃李满天下教师节快乐PPT模板
机器人科技类总结汇报PPT模板
def sprider(self, title_name): """ 采集 工作总结PPT模板 https://www.2ppt.com/ppt/49/1.html 节日庆典PPT模板 https://www.2ppt.com/ppt/51/1.html :return: """ if title_name == "工作总结": self.first_column_name="ppt" self.second_column_name = "49" self.three_column_name = "ppt_dongtai" elif title_name == "节日庆典": self.first_column_name = "ppt" self.second_column_name = "51" BaseFrame().debug("开始采集" + self.folder_name + "...") self.merchant = int(self.spider_start_count) // int(self.max_pager) + 1 # 起始页码用于效率采集 BaseFrame().right("本次采集参数：日志路径=" + str(BaseFrame().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/152e4b7ee4caa82335ff4b5875a17320/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a81676495c0a3f37be9011e6071e4c9/" rel="bookmark">
			SELECT list is not in GROUP BY clause and contains nonaggregated column
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 报错 MySQL 8.0.22
GROUP BY 语句执行报错：
1055 - Expression #22 of SELECT list is not in GROUP BY clause and contains nonaggregated column 'xxx.xxx.xxx' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by, Time: 0.000000s 2 原因 MySQL 8.0.22 默认启用了 ONLY_FULL_GROUP_BY SQL模式（select @@sql_mode）;
ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION MySQL 5.7.5以上版本，实现了对功能依赖的检测。如果启用了only_full_group_by SQL模式(默认启用)，那么MySQL就会拒绝执行 select list、HAVING condition或ORDER BY list引用既不在GROUP BY子句中被命名，也不在功能上依赖于GROUP BY列（由GROUP BY列唯一确定）的未聚合列的查询。
从MySQL5.7.5开始，默认的SQL模式包括only_full_group_by。（在5.7.5之前，MySQL没有检测到功能依赖项，only_full_group_by在默认情况下是不启用的。关于前5.7.5行为的描述，请参阅MySQL 5.6参考手册。)
MySQL :: MySQL 5.7 Reference Manual :: 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a81676495c0a3f37be9011e6071e4c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/225dac8580b35c9512949c5922014e3a/" rel="bookmark">
			将Live Server上的DB添加到Always ON中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 任务目的：Always On已经创建；过了一段时间后，需将几个DB单独加到Always On中进行同步;
本次操作中：172.26.150.11是Live Server。172.26.150.12（LCFA-DB01）和172.26.150.13（LCFA-DB3）是其辅本；
想要将RFeData\RFTesting\SystemControl三个DB由Live DB利用ALways ON同步到辅Server。
下方仅演示SystemControl如何进行相关操作，多个DB添加方式相同。
一：首先，将Live Server上需要添加到Always ON的DB先Full备份一下。 注：下方D:\SQLData\SystemControl\SystemControl _FULL_20231030.BAK可根据实际情况设置具体备份路径。
二：将DB添加到Always ON具体步骤 （一） “Add DataBase” （二）Select Databases(选中需要添加到Always On的DB) 点击“Next”
（三）Connect to Replicas(Connect 辅Server) 我们本次需要将目标DB 同步到另外两个辅Server。因此下方的两个我们都需要Connect一下。
点击“Next”
（四）Select Data Synchronization(Automatic seeding) 在这一步直接默认第一个选项即可。不需要“full database and log backup”。
点击“next”;
（五）Validation 全部Succsss,点击“Next”
（六）Summary 点击“Finish”
（七）Results Success,点击“Close”
三：Check是否添加DB 到Always ON成功 接下来，将相关Server刷新一下。看看添加的DB是不是显示“同步”
(172.26.150.11是Live ip,172.26.150.12和172.26.150.13是辅Server，检查的时候，三台sqlserver都刷新一下)
四：用一些数据测试一下，相关DB运行是否正常即可； 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f04d0e0c623c3aa028ab78f1cf0a2664/" rel="bookmark">
			Java通过cellstyle属性设置Excel单元格常用样式全面总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近做了一个导出Excel的功能，导出是个常规导出，但是拿来模板一看，有一些单元格的样式设置，包括合并，背景色，字体等等，毕竟不是常用的东西，需要查阅资料完成，但是搜遍全网没有一个全面的，工作完成后，我便总结了一下，能够应对日常开发使用的Excel样式设置属性。
这里重点总结生成Excel中对单元格的样式设置，不讲解如何导出Excel，基本导出很容易。
直接上代码，按照注释来看依次是：
首先创建一个工作薄 下面所有的操作都是对这个style对象来设置的。
// 创建excel工作簿 SXSSFWorkbook wb = new SXSSFWorkbook(getXSSFWorkbook(examPath), 1000); //获取样式 CellStyle style = wb.createCellStyle(); 1.设置单元格对齐，属性使用参照注解 //1、先设置单元格对齐方式 //水平对齐，一般对齐方式。文本数据左对齐。数字、日期和时间是正确对齐的。布尔类型居中。 style.setAlignment(HorizontalAlignment.GENERAL); //靠左 style.setAlignment(HorizontalAlignment.LEFT); // 靠右 style.setAlignment(HorizontalAlignment.RIGHT); // 居中 style.setAlignment(HorizontalAlignment.CENTER); // 填充单元格的值,跨越单元格的整个宽度 style.setAlignment(HorizontalAlignment.FILL); // 水平对齐对齐(左右齐平)。对于每行文本，将单元格中换行文本的每行左右对齐 style.setAlignment(HorizontalAlignment.JUSTIFY); // 水平对齐在多个单元格中居中 style.setAlignment(HorizontalAlignment.CENTER_SELECTION); //平铺。表示单元格中每行文本中的text均匀分布.跨越单元格的宽度，左右外边距齐平。 style.setAlignment(HorizontalAlignment.DISTRIBUTED); 2.设置单元格垂直对齐，参考注解 //2.此枚举值指示单元格的垂直对齐类型，即: //垂直居中对齐 style.setVerticalAlignment(VerticalAlignment.CENTER); //顶部对齐 style.setVerticalAlignment(VerticalAlignment.TOP); //底部对齐 style.setVerticalAlignment(VerticalAlignment.BOTTOM); //对齐。 style.setVerticalAlignment(VerticalAlignment.JUSTIFY); //分布。 style.setVerticalAlignment(VerticalAlignment.DISTRIBUTED); 3.设置背景色 //3.设置背景色 style.setFillForegroundColor(IndexedColors.PALE_BLUE.getIndex()); //必须设置 否则背景色不生效 style.setFillPattern(FillPatternType.SOLID_FOREGROUND); 背景色的IndexedColors类中属性对应的具体颜色如下所示：
（1）枚举值对应的颜色
（2）色卡名称对应的颜色
GREY_80_PERCENTINDIGO
PLUM BROWN
OLIVE_GREEN DARK_GREEN
SEA_GREEN DARK_TEAL
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f04d0e0c623c3aa028ab78f1cf0a2664/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/536c50b9d6c607a7c0b4536da6dd5b6b/" rel="bookmark">
			Mac pro解压rar文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		unrar 已经从homebrew移除了！！
在 MacOS 上解压 rar 文件，需要使用一个支持 rar 格式的第三方工具。有很多工具可以选择，但我会推荐一个名为 "Unarchiver" 的免费工具，它支持许多不同类型的压缩文件，包括 rar 文件。
以下是安装和使用 "Unarchiver" 的步骤：
在 Mac App Store 中搜索 "Unarchiver"。
点击 "获取"，然后点击 "安装"。
等待 Unarchiver 安装完成。
安装完成后，打开 "Unarchiver"。
在 "解压档案到..." 下拉菜单中，选择你希望解压的目标位置。
然后，你可以选择需要解压的 rar 文件，点击 "解压"。
你也可以直接在 Finder 中右键点击 rar 文件，然后选择 "Open With" -&gt; "Unarchiver"，以便直接解压 rar 文件。
以上方法需要注意的是，Unarchiver 可能需要你在系统偏好设置的安全与隐私选项中授权对文件和文件夹的访问权限。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/890429a3ede574a64b783d0d4f0e79c4/" rel="bookmark">
			Kafka基于Zookeeper搭建高可用集群实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、前言
1.1 高可用的由来
1.2 相关术语
2、架构图
3、发送消息流程
4、部署kafka&amp;zookeeper集群
4.1 准备工作
4.2 启动zookeeper集群
4.3 启动kafka集群
4.4 测试
5、 kafka集群管理控制台安装
5.1 安装配置
5.2 控制台访问
6、Java API操作
6.1 本地DNS映射配置
6.2 pom依赖
6.3 生产者类
6.4 消费者类
7、分区/片备份
8、集群监控
8.1 开启JMX端口
8.2 Kafka Manager加载JMX监控信息
8.3 JDK自带JMX API
9、消费规则
1、前言 1.1 高可用的由来 为何需要Replication？
在Kafka在0.8以前的版本中，是没有Replication的，一旦某一个Broker宕机，则其上所有的Partition数据都不可被消费，这与Kafka数据持久性及Delivery Guarantee的设计目标相悖。同时Producer都不能再将数据存于这些Partition中。
如果Producer使用同步模式则Producer会在尝试重新发送message.send.max.retries（默认值为3）次后抛出Exception，用户可以选择停止发送后续数据也可选择继续发送。而前者会造成本应发往该Broker的数据的丢失，后者会造成数据的阻塞。
如果Producer使用异步模式，则Producer会尝试重新发送message.send.max.retries（默认值为3）次后记录该异常并继续发送后续数据，这会造成数据丢失并且用户只能通过日志发现该问题。
由此可见，在没有Replication的情况下，一旦某机器宕机或者某个Broker停止工作则会造成整个系统的可用性降低。随着集群规模的增加，整个集群中出现该类异常的几率大大增加，因此对于生产系统而言Replication机制的引入非常重要。
什么是Leader Election
引入Replication之后，同一个Partition可能会有多个Replica，而这时需要在这些Replication之间选出一个Leader，Producer和Consumer只与这个Leader交互，其它Replica作为Follower从Leader中复制数据。
因为需要保证同一个Partition的多个Replica之间的数据一致性（其中一个宕机后其它Replica必须要能继续服务并且不能造成数据重复也不能造成数据丢失）。如果没有一个Leader，所有Replica都可同时读/写数据，那就需要保证多个Replica之间互相（N×N条通路）同步数据，数据的一致性和有序性非常难保证，大大增加了Replication实现的复杂性，同时也增加了出现异常的几率。而引入Leader后，只有Leader负责数据读写，Follower只向Leader顺序Fetch数据（N条通路），系统更加简单且高效。
1.2 相关术语 正文开始之前，我们先了解一下Kafka中涉及的相关术语：　Broker ： 安装Kafka服务的那台集群就是一个broker（broker的id要全局唯一） Producer：消息的生产者，负责将数据写入到broker中（push） Consumer：消息的消费者，负责从kafka中读取数据（pull），老版本的消费者需要依赖zk，新版本的不需要 Topic:主题，相当于是数据的一个分类，不同topic存放不同的数据 partition：分区，是一个物理分区，一个分区就是一个文件，一个topic可以有一到多个分区，每一个分区都有自己的副本。 replication：副本，数据保存多少份（保证数据不丢） Consumer Group：消费者组，一个topic可以有多个消费者同时消费，多个消费者如果在一个消费者组中，那么他们不能重复消费数据 Kafka通过Zookeeper管理集群配置，选举leader，以及在Consumer Group发生变化时进行rebalance。Producer使用push模式将消息发布到broker，Consumer使用pull模式从broker订阅并消费消息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/890429a3ede574a64b783d0d4f0e79c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bb6a22bac40e9c39fa95f58fa11e76e/" rel="bookmark">
			公众号爆款流量主，日入500&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章：
在如今的互联网时代，公众号已成为许多人追逐利润的热门平台。然而，要想在公众号上实现稳定的收益并非易事，很多人在尝试中遇到了各种挑战和困惑。但是，通过一些行之有效的方法和技巧，你也可以在公众号上赚取可观的利润。
本文将揭示一个公众号流量主盈利的秘籍，教你如何打造一个稳定收益的单人单号项目。下面将逐步介绍具体方法：
选择具备潜力的领域：在选择公众号运营的领域时，要结合自身兴趣和专业知识，选择一个有潜力、受众需求大的领域。针对该领域，你可以提供有价值的内容和服务，吸引更多粉丝。
突出独特个性：公众号市场竞争激烈，要脱颖而出需要有独特的个性和风格。你可以通过精心设计的品牌形象、独特的创作思路以及与读者互动等方式，营造独特的公众号形象，吸引更多关注和转发。
提供高质量内容：内容是公众号的核心竞争力。你需要注意保持内容的原创性、有价值性和可读性，对读者进行精准定位，满足他们的需求和兴趣。同时，不断改进和优化内容形式，增加互动性和分享性，提高用户留存和传播率。
运用营销技巧：在公众号运营中，营销技巧起着至关重要的作用。你可以通过有效的推广手段，如合作推广、活动营销、社交媒体传播等，扩大公众号的影响力和知名度。此外，还可以运用精准营销的手段，如粉丝标签分析、个性化推送等，提高用户参与度和转化率。
寻找合作伙伴：与其他公众号或品牌进行合作，可以实现资源共享和互惠共赢，提高公众号的曝光度和影响力。通过与合作伙伴的联合推广、内容合作等方式，扩大受众范围，增加收益。
数据分析与优化：对公众号的运营情况进行数据分析和优化是提升收益的关键。你可以通过监测用户互动数据、粉丝增长情况等指标，掌握受众需求和行为，及时调整运营策略，提升公众号的用户黏性和转化效果。
通过以上方法和技巧，你可以打造一个稳定收益的单人单号项目。然而，需要明确的是，公众号的盈利并非一蹴而就，需要持续努力和不断学习，随着时间的推移才能看到明显的经济回报。
真心话坦白局公众号系统介绍：
文件资料
流量主收益截图
详细具体查看：https://ms3.ishenglu.com/archives/223
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff6001f3d8c218b8cc829f0e952ccab6/" rel="bookmark">
			linux centos7环境下安装apache2.4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.切换root账号 sudo su root
2.yum方式安装apache yum -y install httpd
3.开启停止重启apache服务
service httpd start | stop | restart
ps -A|grep httpd //检查是否已经启动apache服务
4.查看是否安装成功
rpm -qa |grep httpd
注意：
CentOS7用的是Firewall-cmd，CentOS7之前用的是iptables防火墙；要想让外网能访问到apache主目录，就需要做以下的操作：
firewall-cmd --permanent --zone=public --add-service=http
firewall-cmd --permanent --zone=public --add-service=https
firewall-cmd --reload
最后输入IP地址就可以访问到默认的Apache页面了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80cd5c9da3c4b9b0e8d559063b32e334/" rel="bookmark">
			【入门级图文教程】在Visual Studio中创建自定义Winform控件库并在其他解决方案中引用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
本教程使用到的相关软件或产品：
教程正文：
创建用户控件库：
添加自定义控件项：
在其他解决方案中引用：
本教程使用到的相关软件或产品： Windows 10 专业版 10.0.19044Microsoft Visual Studio Community 2022 (64 位) 版本17.3.2「.NET 桌面开发」工作负荷（在开始菜单中找到Visual Studio Installer打开可以看到已安装的工作负荷） Microsoft .NET Framework 版本4.8.04084（在Visual Studio帮助菜单内可查看相应版本） 教程正文： 创建用户控件库： 打开VS，选择“创建新项目”
按下图过滤筛选后选择Windows 窗体控件库(.NET Framework)，点击“下一步”
自行命名项目并指定位置，点击“创建”(请指定自己能记住的项目位置，后面还会用到)
创建完成后界面如下图
（如果界面右边没有解决方案资源管理器可在“视图”中打开）
添加自定义控件项： 鼠标右击项目名称，选择“添加” ——&gt; “新建项”
在弹出的窗口中选择“用户控件(Windows 窗体)”并自行拟定名称，随后点击“添加”
使用 .NET Framework 可以创建复合控件、扩展控件或者自定义控件。有关如何确定创建何种类型的控件的信息可参考：各种自定义控件。
添加后在解决方案资源管理器中可以看到新增了Switch.cs与Switch.Designer.cs；其中Switch.cs是编写业务代码的地方，而Switch.Designer.cs是系统存放设计代码的地方，一般情况下不要轻易去改动里面的内容。
鼠标右击Switch.cs，选择“查看代码”可以打开其代码页面，而Switch.Designer.cs的代码页面直接左键双击即可打开。打开后如下图：
上述内容完成后，最小化Visual Studio，打开文件资源管理器，找到项目所在文件夹，新建一个文件夹命名为“Resources”
打开Resources文件夹并放入下面两张图片（名称分别命名为"SwitchOFF"和"SwitchON"）：
回到Visual Studio，右击解决方案资源管理器中的项目名称，选择“属性” ——&gt; “资源”
单击“此项目不包含默认的资源文件，单击此处可进行创建”
在“添加资源(R)”下拉菜单中选择“添加现有文件”
选中Resources文件夹中的两张图片后点击“打开”
添加后如下图所示，修改“访问修饰符(I)”为“Internal”，随后 Ctrl + s 保存一下：
关闭当前属性页面，回到Switch.cs与Switch.Designer.cs，将如下代码替换进去（直接全文替换即可）：
（这里的代码参考了如下文章）
😃请注意，代码中使用的命名空间需要与创建自定义控件库时项目的名称相同！ /// &lt;summary&gt; /// Switch.cs /// &lt;summary&gt; using System; using System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80cd5c9da3c4b9b0e8d559063b32e334/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b064133b0f2b1f4c7cfcedd397a91d3/" rel="bookmark">
			Nginx代理转发请求POST变GET请求问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🚀 注重版权，转载请注明原作者和原文链接
🥭 作者：Yuan-Programmer
🍎 个人博客：https://boke.open-yuan.com
🍉 已经替换了新的域名，总站叫做：OpenYuan开袁网，后续将慢慢开源一些项目上去，目前是只有一个博客平台 只想看解决结果的，可以直接拉到最底下看代码 问题 起因是这样的，之前重新买了一个新的服务器，这几天有空闲便将我之前的博客项目平台重新部署上去。
先贴个修改前的Nginx配置文件
强制http转发到https，重定向，先部署的前端，访问一切正常
但是做接口请求代理转发的时候，出现问题了
前端项目请求一直请求失败
排查 先直接通过IP+后端项目端口请求接口，正常可以请求到没问题，那么就是nginx配置的问题
起初我以为是配置哪里没有写对，反复看了好几遍配置，修修改改，都没什么问题
最后去Apifox测试下，看看是不是也是一样，就在这时候发现了一样东西
是不是很奇怪，明明我发起的是POST请求，结果转发成了GET请求，于是顺藤摸瓜，排查到了原来是由http强制重定向成https时候出现的问题
重定向，nginx会重新发起一道新的请求到重定向的地址，而nginx默认使用GET请求方式转发所有的请求，所以才会把POST变成GET（这里夸赞一波文心一言，还不错，比讯飞好用多了）
解决 到这里，问题一切都明了了，调整一下重定向的配置
return 307：用于临时重定向，保留原来的请求方式
rewrite：常用的地址跳转方式，兼容正则表达式，推荐使用这种方式
rewrite ^(.*)$ https://$host$1;
哎，太久没部署过项目了，这么简单的问题居然都忘了，这次长长记性
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/325383468ac9fa668a6457068c294ae4/" rel="bookmark">
			Docker网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker网络 一.Docker网络原理1.linux veth pair2.理解docker0 二.网络模式讲解1.bridge模式2.host模式3.none模式4.container模式5.自定义网络1.网络互通 一.Docker网络原理 1.linux veth pair 容器是相对独立的环境，相当于一个小型的 Linux 系统，外界无法直接访问，那他是怎么做的呢，这里我们先了解下 Linux veth pair
veth虚拟网络设备的特点就是它会成对出现，pair英文就是成对的意思，也就是说你创建veth的时候，他会创建一个对veth设备，veth设备一段连着linux网络协议栈，另一端连接的另外的veth设备，成对的veth发送数据后会直接到另一个veth设备上去。
veth pair将两个网络eth0和eth1连通
2.理解docker0 2.1查看本地ip
三个网络 1. lo 127.0.0.1 #本地回环地址 2. eth0 172.21.221.194 # 阿里云的私有IP 3. docker0 172.17.0.1 # docker网桥 lo和eth0在我们创建虚拟机的时候就会创建，但是docker0在我们安装了docker的时候就会创建，docker0用来和虚拟机之间通信
2.2启动一个容器，查看网络
[root@docker ~]# docker run -d -p 8080:8080 --name tomcat01 tomcat [root@docker ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ba0a3198a482 tomcat "catalina.sh run" 2 minutes ago Up 2 minutes 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/325383468ac9fa668a6457068c294ae4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/660435d667323f237ef0a6876060dbfe/" rel="bookmark">
			npm i 报错：Cannot read properties of null (reading ‘refs‘)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题: 旧项目要更改东西，重新部署上线的时候，发现页面显示有异常。当时在开发环境是没有问题的。后经排查是一个引入swiper的页面报错了，只要注释掉swiper插件，就没问题了，但这肯定是不行的。
原因： npm和pnpm的混用。这个项目开发的时候用的是npm，这次更更新内容的时候又是pnpm。猜测是导致swiper版本出现了问题。
但是运行npm i的时候，会报错：Unexpected token '.'。
解决： 切换低版本node，我目前使用的是18，以前开发项目用的是16。切换到低版本的16，npm i也没有问题，部署项目后也没有问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b262c1131f49710f1b45a6f6f795718e/" rel="bookmark">
			LVGL库入门 04 - 颜色与图像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、颜色 1.1、构造颜色 在 LVGL 中，颜色以结构 lv_color_t 表示。在最开始移植整个工程时，曾经在 lv_conf.h 中修改过颜色深度：
/*Color depth: 1 (1 byte per pixel), 8 (RGB332), 16 (RGB565), 32 (ARGB8888)*/ #define LV_COLOR_DEPTH 32 LVGL 会自动根据所选的颜色深度创建合适的颜色结构。在接下来几处位置还有几个与颜色有关的配置选项，可以参照注释修改。
例如，16 位 big-endian 的颜色定义为：
typedef union { struct { uint16_t blue : 5; uint16_t green : 6; uint16_t red : 5; } ch; uint16_t full; } lv_color16_t; typedef lv_color16_t lv_color_t; 那么就可以根据该结构创建合适的颜色值了：
lv_color_t orange = { .ch = { .red = 0b11111, .green = 0b101001, .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b262c1131f49710f1b45a6f6f795718e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0af67e7d25a2c0156889e83c6fef456/" rel="bookmark">
			【Cadence Allegro 17.4】学习日志004——Design Template常用设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		执行菜单命令：Options→Design Template，弹出Design Template对话框，如下图。
​​
一、Fonts 一般默认模板字体，可按需自行更改。
二、Title Block / 标题栏的制作 这一选项是用于设置原理图右下角的标题栏模板的，头文件，可以根据自己需求定义或修改。
这里是根据默认的边框进行修改，如果想要自己设计一个边框，可参考以下步骤：
如下图，绘制一个框，添加文本（快捷键T），然后插入图片（插入图片方法：Place→Picture→选择要插入的图片（如果图片过大，添加时可能会加载一些时间，耐心等待）），绘制好后保存。
画好之后如何在原理图中使用呢？当我们在库文件里画好想要的标题框之后，回到原理图界面，执行菜单命令：Place→Title Block，会弹出一个Place Title Block的对话窗口，按以下步骤选择添加：
三、Page size 原理图纸张页面大小设置，按自己需求进行设置，如一般要求设置为：Millimeters / A3。
四、Grid Reference / Hierarchy / SDT Compatibility 这几项一般选择默认设置即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/979eb2a7cab4e52a6c981187085edb07/" rel="bookmark">
			InSQL（IndustrialSQL Server / Historian） 简单概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. InSQL全名为：IndustrialSQL Server - 实时/历史数据库 2. 特点 标准的关系型数据库快百倍
集成 了 Wonderware 的设备连接性
有高级的客户端分析工具
数据采集和数据存储分离
支持多个IDAS
支持旧的、人工的、非实时的数据
InSQL采用SQL Server 来提供一个开放的数据查询访问系统
在 2018 年 12 月之前仅支持Windows（后面不知道支不支持其他系统，没有查到相关资料）
3. 查询方式 采用 SQL 进行查询数据，而不是采用专用的查询系统或者是方式
和普通 SQL 查询一样
4. Wonderware文件夹 InTouch 文件夹：InTouch是Wonderware公司开发的一种人机接口（HMI）软件，用于监视和控制工业过程中的设备和系统。该软件具有用户友好的界面，使操作员能够实时监视过程数据、执行操作和进行报警管理。InTouch文件夹包含了InTouch HMI软件的安装文件和相关的支持文件。
DAServer 文件夹：DAServer代表数据访问服务器（Data Access Server），是Wonderware软件套件中的一个组件。DAServer用于与不同类型的控制系统和数据源进行通信，以获取实时和历史数据，并使其可在InTouch或其他Wonderware软件中使用。DAServer文件夹包含了DAServer组件的安装文件和相关的支持文件。
这两个文件夹在Wonderware软件套件中起着关键作用。InTouch提供了一个直观的界面，允许操作员与工业过程进行交互。DAServer则负责与各种控制系统和数据源进行通信，并将数据传输到InTouch等软件中，以实现数据监视和控制功能。
5. 官方概念 AVEVA Historian - Tech Notes - Industrial Software Solutions
相关pdf文档
Index of /docs/Wonderware/Historian
6. InSQL 和 SQL Server 的关系 InSQL 使用 Microsoft SQL Server 作为其数据存储引擎。因此，在使用 InSQL 进行数据存储时，实际上是在 SQL Server 中进行操作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/979eb2a7cab4e52a6c981187085edb07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1dfa41336d3d0ae69cee541be65506c/" rel="bookmark">
			应急响应—日志分析工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		应急响应—日志分析工具 1. 工具提供2. 日志提取工具2.1. 七牛Logkit2.1.1. 优点2.1.2. 支持类型2.1.3. 下载地址2.1.4. 使用方式2.1.4.1. 修改配置2.1.4.2. 启动工具2.1.4.3. 使用测试 2.2. 观星应急工具 3. 日志分析工具3.1. 360星图3.1.1. 使用方式3.1.1.1. 开始运行3.1.1.2. 查看分析3.1.1.3. 具体分析报告 3.2. GScan3.2.1. 下载地址3.2.2. 使用方式 3.3. GoAccess3.3.1. 下载地址3.3.2. 使用方式 3.4. analog3.4.1. 下载地址3.4.2. 使用方式 4. 总结 1. 工具提供 所有工具关注公众号“剁椒鱼头没剁椒”回复“应急响应”获取，不过需要注意的是，有的工具下载下来会报毒哦！
2. 日志提取工具 日志提取工具以方便系统监控、故障排查和性能优化等方面进行关键信息分析和处理的。这些工具可以处理不同类型的数据源，包括日志文件、数据库和事件日志等。它们具备多种功能，如关键词匹配，可以根据用户定义的关键词从日志文件中提取与之相关的信息。用户可以指定关键词的匹配规则，如精确匹配、模糊匹配或正则表达式匹配，以满足不同的需求。
2.1. 七牛Logkit logkit-community（社区版）是七牛智能日志管理平台开发的一个配套的日志收集工具，支持海量的数据源，方便地发送到七牛智能日志管理平台以及其他常见的数据存储服务进行分析，同时也，除了基本的数据发送功能，logkit还有容错、并发、监控、删除等功能。
2.1.1. 优点 GO 语言编写，性能优良，资源消耗低，跨平台支持。Web 支持，提供 页面 对数据收集、解析、发送过程可视化插件式架构，扩展性强，使用灵活，易于复用。定制化能力强，可以仅使用部分 logkit 包，以此定制专属收集工具。配置简单，易于上手，可通过 页面 进行操作管理。原生中文支持，没有汉化烦恼。功能全面，涵盖了包括 grok 解析、metric 收集、字段变化 (transform) 在内的多种开源软件特点。生态全面，数据发送到七牛的 Pandora 大数据平台支持包括时序数据库、日志检索以及压缩永久存储等多种数据落地方案。数据收集安全稳定，拥有磁盘队列、内存队列、错误重试、压缩传输、限速限流等多种机制，数据发送不重不漏。集群化，可以通过一个logkit 作为master 在 web 管理众多logkit，对整体集群进行管理。 2.1.2. 支持类型 系统支持：Windows、Linux、mac。File: 读取文件中的日志数据，包括csv格式的文件，kafka-rest日志文件，nginx日志文件等,并支持以grok的方式解析日志。Elasticsearch: 读取ElasticSearch中的数据。MongoDB: 读取MongoDB中的数据。MySQL: 读取MySQL中的数据。MicroSoft SQL Server: 读取Microsoft SQL Server中的数据。Postgre SQL: 读取 PostgreSQL 中的数据。Kafka: 读取Kafka中的数据。Redis: 读取Redis中的数据。Socket: 读取tcp\udp\unixsocket协议中的数据。Http: 作为 http 服务端，接受 POST 请求发送过来的数据。Script: 支持执行脚本，并获得执行结果中的数据。Snmp: 主动抓取 Snmp 服务中的数据。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1dfa41336d3d0ae69cee541be65506c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72a7ebfe625704dd0d6d5fd6a761c8eb/" rel="bookmark">
			在Visual Studio上开启自己的C&#43;&#43;学习之旅
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
0、引言：
1、本教程使用到的相关软件或产品： 2、下载及安装Visual Studio： 2.1、创建符号链接： 2.2、安装Visual Studio： 2.2.1、补充：
3、创建并运行自己的第一个C++程序： 0、引言： 在学习一门编程语言之前，选择一款合适的编辑器与编译器是十分重要的事情。发展到现在，C++的主流编译器已经十分强大与完善了。现列举比较常用的一些：
GCC（GNU Compiler Collection GNU编译器套件）：由GNU开发的类Unix操作系统上的编程语言编译器，从最开始仅支持编译C语言发展至今已经支持C++、Fortran、Pascal、Ada、Java、Objective-C、Objective-C++(并非一门单独的编程语言，而是指Objective-C和C++混用编程)、Go以及各类处理器架构上的汇编语言等多种语言的编译了。 官方网站：点这里
Windows移植版本：MinGW；TDM-GCC；Cygwin
对于 C 语言或者 C++ 程序，可以通过执行 gcc 或者 g++ 指令来调用 GCC 编译器。值得一提的是，实际使用中我们更习惯使用 gcc 指令编译 C 语言程序，用 g++ 指令编译 C++ 程序。需要强调的一点是，这并不是 gcc 和 g++ 的区别，gcc 指令也可以用来编译 C++ 程序，同样 g++ 指令也可以用于编译 C 语言程序。 LLVM Clang：Clang是一个由Apple主导、采用C++编写、基于LLVM、发布于LLVM BSD许可证下的的C/C++/Objective-C/Objective-C++编译器，在FreeBSD、macOS等系统中广泛使用。它与GNU C语言规范几乎完全兼容，并在此基础上增加了额外的语法特性，其目标（之一）就是超越GCC。 LLVM官方网站：点这里 Clang官方网站：点这里
MSVC(MicroSoft Visual C++)：由微软开发，仅能用于Windows操作系统的C++编译器（也支持C）。 综上所述： MSVC 通常用于编译Windows应用，而 GCC / Clang 则可以用来编译Windows/Linux/MacOS等所有平台的应用。 针对初学者，往往更推荐使用集成开发环境（IDE，Integrated Development Environment），比如Visual Studio、Dev-C++、Eclipse、Intellij IDEA(Java IDE)等。本文主要介绍在Windows平台下下载安装Visual Studio并创建自己的第一个C++程序。 1、本教程使用到的相关软件或产品： Windows 10 专业版 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72a7ebfe625704dd0d6d5fd6a761c8eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e76cd3c8a75927ddeae2fe9f692f07f/" rel="bookmark">
			【总结】linux centos 7 开启网络白名单访问策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 linux开启网络端口白名单访问策略开启白名单步骤补充说明 linux开启网络端口白名单访问策略 安全需要，被检测各种3306、9200、9300端口没有设置访问策略。需要整改。
对于linux来说，有两种方式可以开启防火墙
开启白名单步骤 场景一：开放指定端口给指定来源ip访问，将本机3306端口，开放给192.168.10.160 机器访问。
sudo firewall-cmd --permanent --add-rich-rule=‘rule family=“ipv4” source address=“192.168.10.160” port protocol=“tcp” port=“3306” accept’
场景二：开放指定端口给全部来源ip访问
sudo firewall-cmd --permanent --zone=public --add-port=6080/tcp
# 开启网络防火墙 sudo systemctl start firewalld.service # 添加 160 到 3306 白名单网络 sudo firewall-cmd --permanent --add-rich-rule='rule family="ipv4" source address="192.168.10.160" port protocol="tcp" port="3306" accept' # 添加 54 到 3306 白名单网络 sudo firewall-cmd --permanent --add-rich-rule='rule family="ipv4" source address="192.168.10.54" port protocol="tcp" port="3306" accept' # 开放6080端口出去 sudo firewall-cmd --permanent --zone=public --add-port=6080/tcp # 重新加载防火墙，使得新增的网络端口访问策略生效 sudo firewall-cmd --reload 补充说明 sudo systemctl stop firewalld #关闭firewalld
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e76cd3c8a75927ddeae2fe9f692f07f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14f67c31516127f2b8c2e84a70225445/" rel="bookmark">
			Weblogic反序列化漏洞原理分析及漏洞复现(CVE-2018-2628/CVE-2023-21839复现)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内容目录 Weblogic反序列化漏洞(CVE-2018-2628/CVE-2023-21839)weblogic中间件CVE-2018-2628漏洞描述影响版本漏洞复现修复方案 CVE-2023-21839漏洞描述影响版本漏洞复现修复方案 Weblogic反序列化漏洞(CVE-2018-2628/CVE-2023-21839) weblogic中间件 WebLogic是美国Oracle公司出品的一个application server，用于本地和云端开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。WebLogic Server是一个基于JAVAEE架构的中间件，将Java的动态功能和Java Enterprise标准的安全性引入大型网络应用的开发、集成、部署和管理之中，提供了Java Enterprise Edition (EE)和Jakarta EE的可靠、成熟和可扩展的实现。
CVE-2018-2628 漏洞描述 Weblogic Server中的RMI 通信使用T3协议在Weblogic Server和其它Java程序（客户端或者其它Weblogic Server实例）之间传输数据, 服务器实例会跟踪连接到应用程序的每个Java虚拟机（JVM）中, 并创建T3协议通信连接, 将流量传输到Java虚拟机。T3协议在开放WebLogic控制台端口的应用上默认开启。攻击者可以通过T3协议发送恶意的的反序列化数据, 进行反序列化, 实现对存在漏洞的weblogic组件的远程代码执行攻击（开放Weblogic控制台的7001端口，默认会开启T3协议服务，T3协议触发的Weblogic Server WLS Core Components中存在反序列化漏洞，攻击者可以发送构造的恶意T3协议数据，获取目标服务器权限。）
T3协议缺陷实现了Java虚拟机的远程方法调用（RMI）,能够在本地虚拟机上调用远端代码。
T3协议：
用于在Weblogic服务器和其他类型的Java程序之间传输信息的协议。Weblogic会跟踪连接到应用程序的每个Java虚拟机，要将流量传输到Java虚拟机，Weblogic会创建一个T3连接。该链接会通过消除在网络之间的多个协议来最大化效率，从而使用较少的操作系统资源。用于T3连接的协议还可以最大限度减少数据包大小，提高传输速度。
RMI方法：
远程方法调用，除了该对象本身的虚拟机，其它的虚拟机也可以调用该对象的方法。（对象的虚拟化和反序列化广泛应用到RMI和网络传输中）
JRMP：
Java远程消息交换协议JRMP。
JRMP是一个Java远程方法协议，该协议基于TCP/IP之上，RMI协议之下。也就是说RMI该协议传递时底层使用的是JRMP协议，而JRMP底层则是基于TCP传递。
RMI默认使用的JRMP进行传递数据，并且JRMP协议只能作用于RMI协议。当然RMI支持的协议除了JRMP还有IIOP协议，而在Weblogic里面的T3协议其实也是基于RMI去进行实现的。
影响版本 Oracle Weblogic Server10.3.6.0.0
Oracle Weblogic Server12.1.3.0.0
Oracle Weblogic Server12.2.1.2.0
Oracle Weblogic Server12.2.1.3.0
漏洞复现 环境：kali linux
靶场：vulhub /vulhub/weblogic/CVE-2018-2628
开启靶场，进入环境：
进行访问：
Nmap扫描目标IP端口，查看是否使用weblogic
nmap -sV 192.168.100.134 //靶场ip地址 扫描结果，开放了7001端口，对应weblogic服务以及版本信息
使用Nmap的脚本查看对方是否开启T3协议，查看到目标站点开启了T3协议
nmap -n -v -p 7001,7002 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14f67c31516127f2b8c2e84a70225445/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95dc1b742dc0150f608f5095dc1fa660/" rel="bookmark">
			在Qt中解决opencv的putText函数无法绘制中文的一种解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.问题2.查阅资料3.解决办法 1.问题 在opencv中，假如直接使用putText绘制中文，会在图像上出现问号，如下图所示：
2.查阅资料 查了一些资料，说想要解决这个问题，需要用到freetype库或者用opencv5（详情请查看文末的参考资料）。但是我现在用的是opencv4，freetype库已经被移到opencv_contrib去了，用起来麻烦，而且用freetype的话，其实也是相当于用了第三方库来实现：
... cv::Ptr&lt;cv::freetype::FreeType2&gt; ft2; ft2=cv::freetype::createFreeType2(); ... // then put the text itself ft2-&gt;putText(img, text, textOrg, fontHeight, cv::Scalar(255,0,0), thickness, linestyle, true ); 那我Qt也是第三方库啊，还倒不如直接用Qt实现呢。
3.解决办法 于是，我实现了一个myPutText函数
int myPutText(cv::Mat &amp;img, QString text, QPoint org, QFont font, QPen pen) { QImage::Format imgFormat; switch (img.channels()) { case 1: imgFormat = QImage::Format_Grayscale8; break; case 3: imgFormat = QImage::Format_RGB888; // 没有BGR格式，因此要注意一下pen的color break; default: return -1; break; } // 直接共享了Mat的内存，不存在内存复制。所以应该不怎么耗时 QImage tmpImg(img.data, img.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95dc1b742dc0150f608f5095dc1fa660/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5001e8ac37ea12729eb2450c8e24442/" rel="bookmark">
			优化模型的关键：ARR
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
简介
1.近似 Approximation
2.重构 Reformulation
3.松弛 Relaxation
4.降维 Decomposition
简介 Principle ARR – Shu-Cherng Fang
• Approximation – “accept good-enough” to make problem easy
• Reformulation – “change view” to make the problem clear and simple
• Relaxation – “drop difficulties” to get a bound of the problem
• Decomposition – “reduce dimensionality”
1.近似 Approximation 非线性转化为线性本质就是近似，无论是我们手动近似还是求解器内部线性逼近（想一下两个连续变量连续乘积线性化，以及分段函数线性化等），本质都是近似。
近似的本质是≈，不是精确的，因此存在着一定的误差。
2.重构 Reformulation 用不同的形式来写模型，如VRP中的3index，2index，以及1index模型；再比如我们把解的模型转化为极射线和极点表示的模型等等。
重构的本质是让模型更紧，或是可以利用到更多理论性质。我们熟知的D-W分解，或是bender分解它其实也算是一种重构。
3.松弛 Relaxation 松弛的本质是提供一个界，从而提供一个更好的参照系，或者是在求解器求解时砍掉更多的枝干；或者是与启发式算法对比提供一个更好的标杆。
我们熟知的拉格朗日算法松弛、线性松弛应归于此类。
4.降维 Decomposition 降维的本质是把幂指级的问题降为若干个小幂指级相加的问题。比如1个100维的问题变为求解100个1维问题，难度系数一下子降低很多。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5001e8ac37ea12729eb2450c8e24442/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04d8a1f5237fc02ce81d3ce567178c06/" rel="bookmark">
			【JVM经典面试题（五十二道）】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 JVM经典面试题（五十二道）引言1.什么是JVM 内存管理2.能说一下JVM的内存区域吗？3.说一下JDK1.6、1.7、1.8内存区域的变化？4.为什么使用元空间替代永久代作为方法区的实现？5.对象创建的过程了解吗？6.什么是指针碰撞？什么是空闲列表？7.JVM 里 new 对象时，堆会发生抢占吗？JVM是怎么设计来保证线程安全的？8.能说一下对象的内存布局吗？9.对象怎么访问定位？10.内存溢出和内存泄漏是什么意思？11.能手写内存溢出的例子吗？12.内存泄漏可能由哪些原因导致呢？13.如何判断对象仍然存活？14.Java中可作为GC Roots的对象有哪几种？15.说一下对象有哪几种引用？16.finalize()方法了解吗？有什么作用？17.Java堆的内存分区了解吗？18.垃圾收集算法了解吗？19.说一下新生代的区域划分？20.Minor GC/Young GC、Major GC/Old GC、Mixed GC、Full GC都是什么意思？21.Minor GC/Young GC什么时候触发？22.什么时候会触发Full GC？23.对象什么时候会进入老年代？24.知道有哪些垃圾收集器吗？25.什么是Stop The World ? 什么是 OopMap ？什么是安全点？26.能详细说一下CMS收集器的垃圾收集过程吗？27.G1垃圾收集器了解吗？28.有了CMS，为什么还要引入G1？29.你们线上用的什么垃圾收集器？为什么要用它？30.垃圾收集器应该如何选择？31.对象一定分配在堆中吗？有没有了解逃逸分析技术？ JVM调优32.有哪些常用的命令行性能监控和故障处理工具？33.了解哪些可视化的性能监控和故障处理工具？34.JVM的常见参数配置知道哪些？35.有做过JVM调优吗？36.线上服务CPU占用过高怎么排查？37.内存飙高问题怎么排查？38.频繁 minor gc 怎么办？39.频繁Full GC怎么办？40.有没有处理过内存泄漏问题？是如何定位的？41.有没有处理过内存溢出问题？ 虚拟机执行42.能说一下类的生命周期吗？43.类加载的过程知道吗？44.类加载器有哪些？45.什么是双亲委派机制？46.为什么要用双亲委派机制？47.如何破坏双亲委派机制？48.历史上有哪几次双亲委派机制的破坏？49.你觉得应该怎么实现一个热部署功能？50.Tomcat的类加载机制了解吗？ 其他问题51.Java集合一直存放数据，存放的位置是哪个区域52.Java集合如何限制输入的大小 JVM经典面试题（五十二道） 引言 1.什么是JVM JVM——Java虚拟机，它是Java实现平台无关性的基石。
Java程序运行的时候，编译器将Java文件编译成平台无关的Java字节码文件（.class）,接下来对应平台JVM对字节码文件进行解释，翻译成对应平台匹配的机器指令并运行。
同时JVM也是一个跨语言的平台，和语言无关，只和class的文件格式关联，任何语言，只要能翻译成符合规范的字节码文件，都能被JVM运行。
内存管理 2.能说一下JVM的内存区域吗？ JVM内存区域最粗略的划分可以分为堆和栈，当然，按照虚拟机规范，可以划分为以下几个区域：
JVM内存分为线程私有区和线程共享区，其中方法区和堆是线程共享区，虚拟机栈、本地方法栈和程序计数器是线程隔离的数据区。
1、程序计数器
程序计数器（Program Counter Register）也被称为PC寄存器，是一块较小的内存空间。
它可以看作是当前线程所执行的字节码的行号指示器。
2、Java虚拟机栈
Java虚拟机栈（Java Virtual Machine Stack）也是线程私有的，它的生命周期与线程相同。
Java虚拟机栈描述的是Java方法执行的线程内存模型：方法执行时，JVM会同步创建一个栈帧，用来存储局部变量表、操作数栈、动态连接等。
3、本地方法栈
本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。
Java 虚拟机规范允许本地方法栈被实现成固定大小的或者是根据计算动态扩展和收缩的。
4、Java堆
对于Java应用程序来说，Java堆（Java Heap）是虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，Java里“几乎”所有的对象实例都在这里分配内存。
Java堆是垃圾收集器管理的内存区域，因此一些资料中它也被称作“GC堆”（Garbage Collected Heap，）。从回收内存的角度看，由于现代垃圾收集器大部分都是基于分代收集理论设计的，所以Java堆中经常会出现新生代、老年代、Eden空间、From Survivor空间、To Survivor空间等名词，需要注意的是这种划分只是根据垃圾回收机制来进行的划分，不是Java虚拟机规范本身制定的。
5.方法区
方法区是比较特别的一块区域，和堆类似，它也是各个线程共享的内存区域，用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。
它特别在Java虚拟机规范对它的约束非常宽松，所以方法区的具体实现历经了许多变迁，例如jdk1.7之前使用永久代作为方法区的实现。
3.说一下JDK1.6、1.7、1.8内存区域的变化？ JDK1.6、1.7/1.8内存区域发生了变化，主要体现在方法区的实现：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04d8a1f5237fc02ce81d3ce567178c06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfe76e22aadb0379f3f393e50b898bef/" rel="bookmark">
			【开源】基于SpringBoot的校园电商物流云平台的设计和实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、摘要1.1 项目介绍1.2 项目录屏 二、功能模块2.1 数据中心模块2.2 商品数据模块2.3 快递公司模块2.4 物流订单模块 三、系统设计3.1 用例设计3.2 数据库设计3.2.1 商品表3.2.2 快递公司表3.2.3 物流订单表 四、系统展示五、核心代码5.1 查询商品5.2 查询快递公司5.3 查询物流订单5.4 新增物流订单5.5 快递收揽派签 六、免责说明 一、摘要 1.1 项目介绍 基于JAVA+Vue+SpringBoot+MySQL 的校园电商物流云平台，包含了商品管理模块、快递公司模块、物流订单模块，还包含系统自带的用户管理、部门管理、角色管理、菜单管理、日志管理、数据字典管理、文件管理、图表展示等基础模块，校园电商物流云平台基于角色的访问控制，给商家、物流公司、物流管理员使用，可将权限精确到按钮级别，您可以自定义角色并分配权限，系统适合设计精确的权限约束需求。
项目编号： S 034 ，源码已在 B i l i b i l i 中上架，需要的朋友请自行下载。 \color{red}{项目编号：S034，源码已在 Bilibili 中上架，需要的朋友请自行下载。} 项目编号：S034，源码已在Bilibili中上架，需要的朋友请自行下载。
https://gf.bilibili.com/item/detail/1104217029 为了帮助小白入门 Java，博主录制了本项目配套的《项目手把手启动教程》，希望能给同学们带来帮助。
1.2 项目录屏 二、功能模块 互联网和电子商务行业已成为各产业升级创新的“发动机”，也是大众创业的肥沃土壤。各大院校纷纷在基于互联网或电子商务平台的大学生创业教育方面进行了探索和尝试。依托电子商务专业教育体系，立足于高校市场资源，利用新型的社群移动电商平台开展电子商务创业教育创新实践，取得了较好效果。本文旨在建立一个面向校园电商创业的物流云平台，采用Vue、SpringBoot、MySQL技术，包含数据中心模块、商品档案模块、快递公司模块、物流订单管理模块，对物流配送实现云平台管理。
本文设计的面向校园电商创业的物流云平台的包括了系统数据中心模块，用来存放管理系统通用的模块，另外分别设计了商品档案模块、快递公司模块、物流订单模块这三大模块，用于存放系统的核心业务逻辑。
2.1 数据中心模块 数据中心模块包含了对面向校园电商创业的物流云平台的基础模块，比如管理谁可以登录这套系统，记录这些人登录系统做了什么，不同的人拥有不同权限的管理。
2.2 商品数据模块 商品数据模块用于对商品的数据进行管理，其中包括商品ID、商品名称、商品规格、商品图片、商品备注、归属人ID、归属人、创建人等，可以通过此模块对商品数据进行添加、编辑更新、删除、查询操作。
2.3 快递公司模块 快递公司模块是对快递公司的档案信息进行管理，快递公司是快递运输的主要参与者，快递公司字段包括公司简称、公司全名、LOGO、营业执照、地址、经营范围、备注、创建人等，管理员可以新增快递公司的数据，用户可以查询管理员发布的快递公司信息。
2.4 物流订单模块 物流订单模块是对商品数据的实例化，有了商品后，用户就可以对商品进行创建物流订单，这就产生了物流订单模块，其中包括物流单号、下单人ID、下单人、收件人、收件电话、收件地址、下单日期、订单状态、发货物流等，用户可以进行物流下单，快递公司可以操作发货，管理员可以删除物流订单。
三、系统设计 3.1 用例设计 3.2 数据库设计 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfe76e22aadb0379f3f393e50b898bef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/889258f54465e3264cec016c6b56b8bf/" rel="bookmark">
			‘parent.relativePath‘ of POM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错信息 'parent.relativePath' of POM com.dianping:joy-general-api:0.0.60 (/Users/tengfei/IdeaProjects/joy-general/joy-general-api/pom.xml) points at com.dianping:joy-general instead of com.meituan.mdp:mdp-bom, please verify your project structure 排查原因 这个错误通常发生在Maven项目的多模块设置中。在你的情况下，看起来com.dianping:joy-general-api:0.0.60模块的父模块被设置为com.dianping:joy-general，但Maven期望它的父模块应该是com.meituan.mdp:mdp-bom。
你可以通过以下步骤来解决这个问题：
打开joy-general-api模块的pom.xml文件。
找到&lt;parent&gt;元素，它应该看起来像这样：
&lt;parent&gt; &lt;groupId&gt;com.dianping&lt;/groupId&gt; &lt;artifactId&gt;joy-general&lt;/artifactId&gt; &lt;version&gt;0.0.60&lt;/version&gt; &lt;relativePath&gt;../pom.xml&lt;/relativePath&gt;&lt;!-- 这里是问题所在 --&gt; &lt;/parent&gt; 将&lt;groupId&gt;和&lt;artifactId&gt;的值更改为正确的父模块，也就是com.meituan.mdp:mdp-bom： &lt;parent&gt; &lt;groupId&gt;com.meituan.mdp&lt;/groupId&gt; &lt;artifactId&gt;mdp-bom&lt;/artifactId&gt; &lt;version&gt;你的版本号&lt;/version&gt; &lt;relativePath&gt;../pom.xml&lt;/relativePath&gt; &lt;!-- 假设mdp-bom的POM文件位于mdp-bom目录下 --&gt; &lt;/parent&gt; 保存并关闭pom.xml文件。
在IDE或命令行中运行mvn clean install来重新构建项目。
如果你的项目结构正确，并且所有的POM文件都指向正确的父模块，那么这个错误应该就会消失了。
其他原因 如果你已经确认了所有的POM文件都没有问题，那么这个错误可能是由以下原因引起的：
Maven版本问题：不同版本的Maven可能会有不同的行为。你可以尝试更新你的Maven到最新版本，或者更换到一个不同的版本，看看问题是否仍然存在。
IDE问题：有些IDE（如IntelliJ IDEA或Eclipse）可能会缓存一些旧的项目信息。你可以尝试重启你的IDE，或者清除IDE的缓存，看看问题是否仍然存在。
本地仓库问题：Maven会在你的本地仓库中缓存项目的依赖。有时候，这些缓存的依赖可能会引起问题。你可以尝试删除你的本地仓库（通常位于你的用户目录下的.m2文件夹），然后重新构建项目，看看问题是否仍然存在。
项目设置问题：如果你的项目是一个多模块项目，那么可能需要在父POM文件中包含所有的子模块。你可以检查你的父POM文件，确保所有的子模块都被包含在&lt;modules&gt;元素中。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f342d352e6b530e3535f16d847051851/" rel="bookmark">
			电脑关机很慢？这几个优化技巧请收好！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我们使用电脑时，一个令人不快的问题是，关机变得异常缓慢。电脑在关机时可能需要很长时间，甚至让人感到沮丧。这不仅是时间浪费，还可能表明系统存在问题。在本文中，我们将介绍四种解决电脑关机很慢的方法，通过逐步操作，您将能够提高计算机的关机速度，使其更加高效。
方法1：管理启动项 当我们使用电脑久了，可能会遇到电脑关机很慢的情况发生，这时我们应该怎么做呢？通过管理启动项可以解决。具体步骤如下：
第一步：在键盘上同时按下“Ctrl + Shift + Esc”或“Ctrl + Alt + Delete”来打开任务管理器。
第二步：在任务管理器中，切换到“启动”选项卡。浏览列出的启动程序，并禁用那些您不希望在系统启动时自动运行的程序。
方法2：更新驱动程序 还有一种方法，通过更新驱动程序来加快电脑关机速度。具体步骤如下：
第一步：在Windows搜索栏中键入“设备管理器”并打开它。
第二步：扩展相关硬件类别，右键单击设备并选择“更新驱动程序”，按照向导更新驱动程序。
方法3：磁盘清理和磁盘碎片整理 定期进行磁盘清理，可以加快电脑运行速度，从而改善电脑关机慢的问题。以下是具体的步骤：
第一步：在Windows搜索栏中键入“磁盘清理”并打开它。选择要清理的磁盘，并按照提示执行磁盘清理。
第二步：在Windows搜索栏中键入“磁盘碎片整理”并打开它，选择磁盘并执行碎片整理。
方法4：运行系统文件检查 通过运行系统文件进行检查，可以发现电脑程序中的错误，并进行修复，提高电脑关机速度。以下是具体的步骤：
第一步：在Windows搜索栏中键入“cmd”或“命令提示符”，右键单击“命令提示符”并选择“以管理员身份运行”。
第二步：在命令提示符中输入以下命令“sfc /scannow”并按Enter键，等待系统文件检查工具完成扫描和修复。
结论： 通过遵循上述方法，可以帮助您解决电脑关机很慢的问题。这将不仅节省您的时间，还能改善系统性能，确保您的电脑在运行时更加高效。不管您是在工作还是娱乐中使用电脑，一个快速且高效的关机过程都将为您的日常计算机体验增色不少。希望这些方法对您有所帮助，使您的电脑重新焕发活力。
文章推荐：
亲测有效！盘点3款好用的录屏软件https://blog.csdn.net/shujuwa__net/article/details/134154169?spm=1001.2014.3001.5502
录屏工具大揭秘！让你轻松成为录像达人https://blog.csdn.net/shujuwa__net/article/details/134154841?spm=1001.2014.3001.5502
玩家必备，2款顶级游戏录屏软件！https://blog.csdn.net/shujuwa__net/article/details/134155652?spm=1001.2014.3001.5502
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c23ec7ee5b8a255668b5594fd1f1507/" rel="bookmark">
			框架安全-CVE 复现&amp;Apache Shiro&amp;Apache Solr漏洞复现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 服务攻防-框架安全&amp;CVE 复现&amp;Apache Shiro&amp;Apache Solr漏洞复现中间件列表常见开发框架Apache Shiro-组件框架安全暴露的安全问题漏洞复现Apache Shiro认证绕过漏洞（CVE-2020-1957）CVE-2020-11989验证绕过漏洞CVE_2016_4437 Shiro-550 &amp;&amp; CVE-2019-12422 Shiro-721 漏洞复现 Apache Solr-组件框架安全披露的安全问题漏洞复现Apache Solr 远程命令执行漏洞（CVE-2017-12629）任意文件读取&amp;&amp;命令执行（CVE-2019-17558）远程命令执行漏洞(CVE-2019-0193)Solr 任意文件读取&amp;&amp; SSRF （CVE-2021-27905） 服务攻防-框架安全&amp;CVE 复现&amp;Apache Shiro&amp;Apache Solr漏洞复现 中间件列表 中间件及框架列表：
IIS，Apache，Nginx，Tomcat，Docker，K8s，Weblogic，JBoos，WebSphere，Jenkins ，GlassFish，Jetty，Jira，Struts2，Laravel，Solr，Shiro，Thinkphp，Spring，Flask，jQuery 等
常见开发框架 1、开发框架-PHP-Laravel-Thinkphp
2、开发框架-Javaweb-St2-Spring
3、开发框架-Python-django-Flask
4、开发框架-Javascript-Node.js-JQuery
5、其他框架-Java-Apache Shiro&amp;Apache Sorl
常见语言开发框架：
PHP：Thinkphp Laravel YII CodeIgniter CakePHP Zend 等
JAVA：Spring MyBatis Hibernate Struts2 Springboot 等
Python：Django Flask Bottle Turbobars Tornado Web2py 等
Javascript：Vue.js Node.js Bootstrap JQuery Angular 等
Apache Shiro-组件框架安全 详解：shiro（java安全框架）
Apache Shiro是一个强大且易用的Java安全框架,执行身份验证、授权、密码和会话管理。使用Shiro的易于理解的API,您可以快速、轻松地获得任何应用程序,从最小的移动应用程序到最大的网络和企业应用程序。
暴露的安全问题 Apache Shiro &lt;= 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c23ec7ee5b8a255668b5594fd1f1507/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84a037f5aacc0d8a824caaf1ba06db4d/" rel="bookmark">
			【雕爷学编程】MicroPython手册之 ESP32-CAM 远程监控
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MicroPython是为了在嵌入式系统中运行Python 3编程语言而设计的轻量级版本解释器。与常规Python相比，MicroPython解释器体积小(仅100KB左右)，通过编译成二进制Executable文件运行，执行效率较高。它使用了轻量级的垃圾回收机制并移除了大部分Python标准库，以适应资源限制的微控制器。
MicroPython主要特点包括:
1、语法和功能与标准Python兼容,易学易用。支持Python大多数核心语法。
2、对硬件直接访问和控制,像Arduino一样控制GPIO、I2C、SPI等。
3、强大的模块系统,提供文件系统、网络、图形界面等功能。
4、支持交叉编译生成高效的原生代码,速度比解释器快10-100倍。
5、代码量少,内存占用小,适合运行在MCU和内存小的开发板上。
6、开源许可,免费使用。Shell交互环境为开发测试提供便利。
7、内置I/O驱动支持大量微控制器平台，如ESP8266、ESP32、STM32、micro:bit、掌控板和PyBoard等。有活跃的社区。
MicroPython的应用场景包括:
1、为嵌入式产品快速构建原型和用户交互。
2、制作一些小型的可 programmable 硬件项目。
3、作为教育工具,帮助初学者学习Python和物联网编程。
4、构建智能设备固件,实现高级控制和云连接。
5、各种微控制器应用如物联网、嵌入式智能、机器人等。
使用MicroPython需要注意:
1、内存和Flash空间有限。
2、解释执行效率不如C语言。
3、部分库函数与标准版有差异。
4、针对平台优化语法,订正与标准Python的差异。
5、合理使用内存资源,避免频繁分配大内存块。
6、利用原生代码提升速度关键部位的性能。
7、适当使用抽象来封装底层硬件操作。
ESP32-CAM是一款基于ESP32芯片的小尺寸摄像头模块，具有低功耗、高性能、Wi-Fi和蓝牙功能等特点。根据我从网络上搜索到的信息，ESP32-CAM的核心技术参数如下：
1、CPU：双核32位LX6微处理器，主频高达240MHz，运算能力高达600 DMIPS
2、内存：内置520 KB SRAM，外置4-8MB PSRAM
3、存储：支持TF卡，最大32G
4、无线通信：支持802.11 b/g/n Wi-Fi和蓝牙4.2 BR/EDR和BLE标准
5、接口：支持UART/SPI/I2C/PWM/ADC/DAC等接口
6、摄像头：支持OV2640和OV7670摄像头，内置闪光灯，支持图片Wi-Fi上传
7、电源管理：支持多种休眠模式，深度睡眠电流最低达到6mA
8、封装形式：DIP封装，可直接插上底板使用
9、尺寸：2740.54.5mm
MicroPython的ESP32-CAM是一种用于远程监控的开发板，下面从专业的视角详细解释其主要特点、应用场景以及需要注意的事项。
主要特点：
图像和视频采集：ESP32-CAM集成了摄像头，可以实时采集高质量的图像和视频。它支持不同分辨率的图像捕获，并提供了图像和视频处理功能，如图像压缩、视频流传输等。
网络连接和通信：ESP32-CAM支持Wi-Fi连接，可以通过网络与其他设备进行通信。它可以通过网络将采集到的图像和视频传输到云平台或本地服务器，实现远程监控和访问。
实时监控和通知：ESP32-CAM可以实时传输图像和视频流，使用户能够实时监控远程位置的情况。通过与其他传感器的结合，还可以实现基于图像和视频的实时报警和通知功能。
应用场景：
家庭安防监控：ESP32-CAM可以用作家庭安防监控系统的核心设备。通过将ESP32-CAM安装在家中的关键位置，用户可以通过互联网远程监控家庭，并在检测到异常情况时接收实时通知。
商业场所监控：ESP32-CAM适用于商业场所的安全监控需求，如商店、办公室、仓库等。它可以实时监控并记录关键区域的图像和视频，提供对商业场所的远程访问和实时监控。
环境监测：ESP32-CAM可以结合其他传感器，如温度传感器、湿度传感器等，实现环境监测。通过采集图像和视频，可以实时监测环境的状况，并在检测到异常情况时触发报警或通知。
需要注意的事项：
网络连接和带宽：使用ESP32-CAM进行远程监控需要保证稳定的网络连接和足够的带宽。确保设备与网络的稳定连接，以避免图像和视频传输的中断或延迟。
隐私和数据安全：在设计远程监控系统时，需要注意保护用户隐私和数据安全。采取适当的安全措施，如加密通信、访问控制和数据加密，以防止未经授权的访问和数据泄露。
存储和数据管理：ESP32-CAM的存储容量有限，需要合理管理图像和视频数据的存储。考虑使用压缩算法、存储策略和数据清理机制，以优化存储空间和数据管理效率。
综上所述，MicroPython的ESP32-CAM是一种适用于远程监控的开发板，具有图像和视频采集、网络连接和通信以及实时监控和通知的特点。它适用于家庭安防监控、商业场所监控和环境监测等场景。在使用时，需要注意网络连接和带宽、隐私和数据安全，以及存储和数据管理等方面的问题。通过ESP32-CAM，用户可以实现远程监控和访问，提高安全性和便利性。
案例一：实时视频流
import network import socket from machine import Pin, PWM import time import ustruct import sensor, image, time # 初始化摄像头和显示屏 sensor.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84a037f5aacc0d8a824caaf1ba06db4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d91789f92e2285ae554ab4e38cf624e/" rel="bookmark">
			C语言基本语法入门练习题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 第1关：求绝对值第2关：求m以内的奇数之和第3关：排除此数还是输出此数第4关：医院收费第5关：相反次序重新组合 第1关：求绝对值 编程要求
请仔细阅读右侧代码，根据方法内的提示，在Begin - End区域内进行代码补充，具体任务如下：
根据输入数据输出该值的绝对值，效果如下： 输入：-25。 输出：25。
测试说明
补充完代码后，点击测评，平台会对你编写的代码进行测试，当你的结果与预期输出一致时，即为通过。
代码如下：
#include &lt;stdio.h&gt; int main() { //获取参数方式 scanf //int x =0; //int y = 0; //scanf("%d", &amp;x); //结果输出使用prinf //printf("%d",x); // 请在此添加你的代码 /********** Begin ********/ int i; scanf("%d",&amp;i); if(i&lt;0) { i=-i; printf("%d",i); } else printf("%d",i); return 0; /********** End **********/ } 第2关：求m以内的奇数之和 编程要求
请仔细阅读右侧代码，根据方法内的提示，在Begin - End区域内进行代码补充，具体任务如下：
给定一个整数m，求m以内的奇数之和，并将其输出。
例如，当m=50时， 即求1+3+5+7+……+49，当m=9时，即求1+3+5+7+9。 效果如下：
输入：9。
输出：25。
测试说明
补充完代码后，点击测评，平台会对你编写的代码进行测试，当你的结果与预期输出一致时，即为通过。
代码如下：
#include &lt;stdio.h&gt; int main() { //获取参数方式 scanf //int x =0; //int y = 0; //scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d91789f92e2285ae554ab4e38cf624e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b1b0f9447e9b8668e4451ea5f207e42/" rel="bookmark">
			编写程序，根据公式e=1&#43;1/1!&#43;1/2！….&#43;1/n!；计算e的近似值，直到最后一项小于10^-5为止
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本题需要使用for循环语句将多个1/n！相加
#include &lt;iostream&gt; using namespace std; int main( ) { double sum = 0; double i = 1.0; int n; for (n = 1; i &gt;= 0.00001; n++) { sum =sum + i; i =i/ n; } cout &lt;&lt; "当n为 " &lt;&lt; n - 1 &lt;&lt; " 时最后一项小于0.00001" &lt;&lt; endl; cout &lt;&lt; "e的值为 " &lt;&lt; sum; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a97eb39eac50766bdf774e50a779fd8/" rel="bookmark">
			使用pip3从指定源安装特定版本的pyodbc库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple pyodbc==4.0.32 这个命令是在使用 pip3（Python 的包管理器）来安装一个名为 pyodbc 的 Python 库的特定版本（4.0.32）。这个命令还指定了一个特定的包源，即 `https://pypi.tuna.tsinghua.edu.cn/simple`，这可能是清华大学的一个包源服务器。 让我们详细解释这个命令的各个部分： * `pip3`: pip 是 Python 的包管理器，它用于在 Python 中安装和管理软件包。`pip3` 是针对 Python3 的版本。 * `install`: 这是 pip 的一个命令，用于安装指定的 Python 包。 * `-i`: 这是一个选项，用于指定包源。在这个例子中，它被设置为 `https://pypi.tuna.tsinghua.edu.cn/simple`。这告诉 pip 从这个特定的 URL 获取包。 * `pyodbc`: 这是要安装的包的名称。 * `==4.0.32`: 这是要安装的包的版本号。这告诉 pip 安装 pyodbc 的 4.0.32 版本。 这个命令的目的是从指定的源安装一个特定版本的 pyodbc 包。在运行这个命令之前，你需要确保你的计算机已经安装了 Python3 和 pip3。 如果你想检查 pyodbc 包是否已经成功安装，你可以在 Python shell 中尝试导入这个包，如下所示： import pyodbc 如果没有出现错误信息，那么 pyodbc 包就已经成功安装了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb6a3f6f91231399354901cd2839760a/" rel="bookmark">
			Windows系统鼠标右键菜单添加打开cmd终端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows想当要在某个文件夹下右键打开cmd终端，如果没有右键菜单快捷方式，则需要cmd，使用cd方式进入 当前目录，效率很低。利用一下方法可以创建打开终端右键菜单快捷方式。
首先，在任意文件夹中创建一个.txt文件，修改文件名和后缀为 cmd.reg。将下面代码保存到文件中，保存，退出，右键该文件选择合并。这样，鼠标右键菜单就有open cmd here即可在当前路径打开终端。
Windows Registry Editor Version 5.00 [HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\background\shell\cmd_here] @="open cmd here" "Icon"="cmd.exe" [HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\background\shell\cmd_here\command] @="\"C:\\Windows\\System32\\cmd.exe\"" "Icon"="cmd.exe" [HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Folder\shell\cmdPrompt] @="open cmd here" "Icon"="cmd.exe" [HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Folder\shell\cmdPrompt\command] @="\"C:\\Windows\\System32\\cmd.exe\" \"cd %1\"" "Icon"="cmd.exe" [HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\shell\cmd_here] @="open cmd here" "Icon"="cmd.exe" [HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\shell\cmd_here\command] @="\"C:\\Windows\\System32\\cmd.exe\"" [HKEY_CLASSES_ROOT\Directory\Background\shell\runas] "ShowBasedOnVelocityId"=dword:00639bc8 [HKEY_CLASSES_ROOT\Directory\Background\shell\runas\command] @="cmd.exe /s /k pushd \"%V\"" 转载 于
https://blog.csdn.net/Bulk_Zhang/article/details/123295746?spm=1001.2014.3001.5506
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0829a7e62416ef38b977362f67f1789a/" rel="bookmark">
			K8s最佳实践！这些热门案例你清楚吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		容器已成为2023年的热门话题。面对庞大的容器业务管理需求，企业急需一种工具来集中管理所有容器，但招聘市场却供不应求。目前最热门的容器管理工具是谷歌公司推出的Kubernetes（简称K8s），其市场份额占比高达95%以上。（根据看准网2023年10月数据显示，同行业大厂平均月薪可达25k）
根据最新的市场研究报告，Kubernetes的市场份额在过去的一年中增长了近50%，显示出其在容器管理领域的领先地位。此外，根据DevOps调查，76%的企业正在使用或计划在未来12个月内使用Kubernetes。K8s具有故障自修复、自动扩缩容、滚动更新等众多强大的功能，这是其他容器管理工具所不具备的。
某求职网2023年10月份的招聘数据展示
然而，细心的求学者会发现，关于K8s的资料在网上极其丰富，但其中90%的内容都着重教授如何进行部署和安装K8s。那么一旦成功部署，我们接下来该如何操作呢？
在此，51CTO与资深架构师韩先超联合推出《3天K8s直播训练营》，本课程完全站在小白的角度，包含梳理K8s知识体系、部署K8s（手动安装、自动安装、使用云厂商自带的k8s等）、基于K8s的实战案例分享，讲师专业答疑，赠送精选实战资料和学习指南等，帮助你快速上手云原生时代最重要的技能。学完还可以选择考取CKA和CKS证书，对于想加薪、或者想跳槽的同学可谓一举两得。
限时免费~扫码报名学习
￥0 元 拼手速秒杀
▲
报名成功加助教老师微信、进班级群
领取【课程资料+超值全勤奖】
51CTO直播训练营
如果你属于下面这五类人任何一种，那就赶紧加入我们的直播训练营吧！
第一类：想要学习K8s的运维、开发、测试、售前、售后、项目、产品、DevOps工程师、架构师等相关技术人员，或相关专业大学生；
第二类：想要考取K8s高含金量证书CKA和CKS的人员；
第三类：想要实现K8s在公司落地实施的；
第四类：想要学习DevOps体系、监控、链路监控、日志、持久化存储、微服务、二次开发的人员。
第五类：想要实现升值加薪的相关人员。
跟K8S相关的技术岗位覆盖面非常广，如：系统运维工程师/运维工程师、网络工程师、开发/软件工程师/测试工程师、架构师、安全渗透工程师、数据工程师、运维开发（SRE）、自动化工程师、DevOps工程师、DBA、技术顾问/解决方案架构师、产品经理、项目经理、Linux、容器工程师、K8S工程师、云原生工程师等。
3天课程会介绍Linux和虚拟化、容器、K8S、云原生、云计算之间的关联性，K8s架构、组件、核心资源、应用领域、大厂真实案例、通过K8S可视化UI界面Rancher创建k8s资源，带你实战练习基于K8s构建自动化运维管理平台DevOps、基于Helm一键式部署k8s资源、K8S二次开发、基于K8S实现电商网站自动扩缩容等世界500强实战案例。而且听完课后，还可在群里向韩先超老师提问，有问题当堂解决！非常适合想要快速学习和了解K8s的同学。
讲师韩先超，是51CTO金牌讲师兼年度十大杰出讲师，51CTO学堂K8S教学总监，深受学员好评！国内最早一批K8s布道者，多年致力于K8s相关技术研究，已发表的技术文章阅读量过百万，是《Kubernetes从入门到DevOps应用实战》畅销书作者，并曾受邀作为《新一代云计算大会》的主讲嘉宾分享K8s技术，被北京日报、环球网专题报道。
这样一门干货满满、实操实战的直播课
👇学习完3天课程后还额外赠送👇
▼
扫码预约
￥0 元 拼手速秒杀
▲
报名成功加助教老师微信、进班级群
领取【课程资料+超值全勤奖】
京东、阿里、抖音、银行等基于K8s的真实案例👉
1.基于k8s构建DevOps流程图
2.某国有银行K8S微服务双中心架构图
3.某大型电商平台双十一：支撑千万订单的k8s容器云平台
4.直播平台：基于k8s构建亿级PV流量的DevOps架构图
5.Rancher管理k8s集群，在Rancher ui界面部署k8s资源
6.某电商平台双十一：支撑千万订单的K8S容器云平台
完整内容，扫码预约，报名直播课学习👇
￥0 元 拼手速秒杀
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b854b074b145cef4951bf77e059b87d7/" rel="bookmark">
			LeetCode刷题总结 - LeetCode 热题 100 - 持续更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LeetCode 热题 100 其他系列哈希1. 两数之和49. 字母异位词分组128. 最长连续序列 双指针27. 移除元素283. 移动零11. 盛最多水的容器剑指 Offer II 007. 数组中和为 0 的三个数42. 接雨水 滑动窗口438. 找到字符串中所有字母异位词3. 无重复字符的最长子串 字串560. 和为 K 的子数组剑指 Offer 59 - I. 滑动窗口的最大值 普通数组最大子数组和56. 合并区间189. 轮转数组238. 除自身以外数组的乘积 矩阵73. 矩阵置零54. 螺旋矩阵48. 旋转图像240. 搜索二维矩阵 II 链表160. 相交链表206. 反转链表234. 回文链表141. 环形链表（基础模板题）142. 环形链表 II21. 合并两个有序链表（模板题）2. 两数相加19. 删除链表的倒数第 N 个结点24. 两两交换链表中的节点25. K 个一组翻转链表138. 复制带随机指针的链表148. 排序链表23. 合并 K 个升序链表 二叉树94. 二叉树的中序遍历104. 二叉树的最大深度226. 翻转二叉树101. 对称二叉树543. 二叉树的直径102. 二叉树的层序遍历108. 将有序数组转换为二叉搜索树98. 验证二叉搜索树剑指 Offer 54.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b854b074b145cef4951bf77e059b87d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74c848d6110e67d6a431a1cea0274998/" rel="bookmark">
			Oracle常用操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1：启动Oracle数据库
步骤如下：
su - oracle sqlplus / as sysdba startup lsnrctl start //启动监听 2：启动oracle数据库监听
步骤如下：
1：打开终端或控制台，以root用户或具有sudo权限的用户登录，然后切换到安装目录的bin目录下：
cd /u01/app/oracle/product/{Oracle版本号}/dbhome_1/bin
请根据实际安装路径进行相应调整。
启动监听器：./lsnrctl start
查看监听器：./lsnrctl status
如果监听器已经启动，将显示监听器的名称和状态信息。
若想在每次系统启动时自动启动监听器，可以将以下命令添加到/etc/rc.local文件中：
su - oracle -c “/u01/app/oracle/product/{Oracle版本号}/dbhome_1/bin/lsnrctl start”
请确保以上命令与实际路径一致，并根据需要进行相应调整。
3：lsnrctl start 命令找不到
命令找不到，一定是环境变量没有配置对，或者由于没有正常关闭数据库造成的。
具体操作： 正常情况下 使用root用户登录后，执行 su oracle 命令把环境变量直接带过去。如果还没有查看环境变量参数就使用oracle用户配置下面三个参数，配置正确路径。
export PATH=/home/oracle/app/oracle/product/11.2.0/dbhome_1/bin:$PATH export ORACLE_HOME=/home/oracle/app/oracle/product/11.2.0/dbhome_1 export ORACLE_SID=orcl 使用oracle用户临时配置上这三个环境变量，就可以正常的 lsnrctl start 启动监听。
$ sqlplus /nolog //登录sqlplus
SQL&gt; connect /as sysdba //连接oracle
SQL&gt; startup //起动数据库
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b9dc6d32859f854f70d802ae157869c/" rel="bookmark">
			160. 相交链表、Leetcode的Python实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博客主页：🏆看看是李XX还是李歘歘 🏆
🌺每天分享一些包括但不限于计算机基础、算法等相关的知识点🌺
💗点关注不迷路，总有一些📖知识点📖是你想要的💗
⛽️今天的内容是 Leetcode 160. 相交链表 ⛽️💻💻💻
160. 相交链表
给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。
图示两个链表在节点 c1 开始相交：
题目数据 保证 整个链式结构中不存在环。
注意，函数返回结果后，链表必须 保持其原始结构 。
自定义评测：
评测系统 的输入如下（你设计的程序 不适用 此输入）：
intersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0
listA - 第一个链表
listB - 第二个链表
skipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数
skipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数
评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。
示例 1：
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b9dc6d32859f854f70d802ae157869c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/619467d1707e5bba1257db913d33cbed/" rel="bookmark">
			使用Python读取Tiff图像的几种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 PIL.Imagecv2gdal 本文总结了使用 PIL Image, cv2, gdal.Open三种python package 读取多通道Tiff格式遥感影像的方法。 PIL.Image PIL对Tiff只支持两种格式的图像：
多通道8bit图像单通道int16, int32, float32图像 多通道多bit的tiff图像PIL不支持读取。
file = Image.open(tiff_file)) # 也可以读取之后进行格式转换: img = np.array(Image.open(tiff_file)).astype(np.float32) cv2 cv2的读取可以选择一下几种类型：
img = cv2.imread(tiff_file, arg) # arg = -1: 8bit原通道 # arg = 2: 原深度单通道 # arg = 3: 原深度三通道 gdal from osgeo import gdal img = gdal.Open(tiff_file) # 查看通道数 img.RasterCount # 读取至数组格式 img = img.ReadAsArray() print(img.shape) &gt; 会得到(channel, height, widht) img = img.transpose(1,2,0) &gt; 得到(height, width, channel) print(np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/619467d1707e5bba1257db913d33cbed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bce29e512021611ac9ed8e7e58f1d79/" rel="bookmark">
			【PID专题】控制算法PID之积分控制（I）的原理和示例代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		积分（I）项是PID控制器的一个重要组成部分，它对系统的控制输出做出反应，以减小系统的静态误差，即长时间内误差积累导致的误差。积分项的作用是在控制系统中引入一个积分效应，以便持续减小系统的稳态误差。
以下是积分（I）项的详细介绍：
1.作用原理：积分项的计算基于误差的积分，通常是误差随时间的积分。积分项将误差积累，并根据积分时间常数T(i)来计算控制输出。积分项的数学表达式如下：
2.影响：积分项对系统的控制输出有两个主要作用：首先，它减小系统的稳态误差，确保系统最终能够达到期望值；其次，它帮助减小系统的过度调节，防止振荡。积分项通常在控制系统长时间运行时显现出作用，对短期变化的响应较小。
3.积分时间常数：积分时间常数T(i)是一个重要参数，它控制了积分项的响应速度。较大的T(i)值会导致积分项的响应较慢，较小的T(i)值会导致响应较快。通过调整T(i)，可以平衡系统的稳态误差和过度调节之间的关系。
4.调节：调节积分增益K(i)和积分时间常数T(i)是调整PID控制器性能的关键。根据具体应用，您可能需要不同的K(i)和T(i)值。一种常见的调节方法是通过试验和模拟来找到合适的K(i)和T(i)值，以使系统能够快速达到期望值并保持稳定。
5.特点：积分项主要用于减小稳态误差，因此在系统长时间运行时起关键作用。如果积分项设置得过高，可能会导致系统过度调节或振荡。如果积分项设置得过低，系统可能无法消除稳态误差。
在PID控制器中，积分项通常与比例项和微分项一起使用，以综合控制系统的性能。合理设置积分增益K(i)和积分时间常数T(i)是PID控制器调节的关键，因为它们直接影响了系统的稳态误差和响应速度。通过仔细调整积分项，可以实现系统的精确控制和稳定性。
积分（I）项通常在实际的PID控制器实现中需要进行累积误差，以计算积分项的控制输出。下面是一个简单的C语言示例代码，演示如何计算积分项的控制输出：
#include &lt;stdio.h&gt; // PID控制器参数 float Ki = 0.1; // 积分增益 float Ti = 1.0; // 积分时间常数 // 全局变量用于存储累积误差 float accumulatedError = 0.0; // 计算积分项 float calculateIntegral(float error, float deltaTime) { // 累积误差 accumulatedError += error * deltaTime; // 计算积分项的控制输出 float integralOutput = Ki * accumulatedError / Ti; return integralOutput; } int main() { float setpoint = 100.0; // 期望值 float processVariable = 80.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8bce29e512021611ac9ed8e7e58f1d79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/165131e153603396f1c5b7eac4d6c97b/" rel="bookmark">
			vite &#43; vue3 解决低版本火狐浏览器兼容性问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vite + vue3 解决低版本火狐浏览器兼容性问题 第一步：用以下命令创建一个 vue3 项目 （没装 vite 的先去装 vite 不然创建不了）
1.npm create vite@latest 2.填写项目名称 3.选择 vue 4.选择JavaScript 5.cd 项目名称 6.npm install 第二步：用 npm install @vitejs/plugin-legacy 命令安装打包兼容性插件 -&gt;
npm install @vitejs/plugin-legacy 第三步：在vite.config.js 配置文件中配置好如下内容 -&gt;
import { defineConfig } from 'vite' import legacy from '@vitejs/plugin-legacy' import vue from '@vitejs/plugin-vue' // https://vitejs.dev/config/ export default defineConfig({ plugins: [ vue(), legacy({ targets: ['firefox &lt; 59','chrome &lt; 60'], additionalLegacyPolyfills: ['regenerator-runtime/runtime'], renderLegacyChunks: true, polyfills: [ 'es.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/165131e153603396f1c5b7eac4d6c97b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd1d2c37a07f45b27deddbb23f285a19/" rel="bookmark">
			python&amp;selenium自动化测试实战项目（完整、全面）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 之前的文章说过， 要写一篇自动化实战的文章， 这段时间比较忙再加回家过11一直没有更新博客，今天整理一下实战项目的代码共大家学习。（注:项目是针对我们公司内部系统的测试，只能内部网络访问，外部网络无法访问）
问：
1.外部网络无法访问，代码也无法运行，那还看这个项目有啥用
2.如何学习本项目
3.如何学习自动化测试（python+selenium）
答：
1.其实代码并不重要，希望大家完完整整的看完这个项目后，自己会有思路有想法，学会这个项目的框架结构和设计思想，把这些能应用到自己的项目中，那么目的就达到了（项目中涉及到的一些公共方法是可以单独运行的，大家可以拿来执行用到自己的项目中）
2.首先希望大家带着目标来学习这个项目1. 项目的目录结构（每个目录中存放什么东西）2.项目如何使用框架（本项目使用的是unittest框架）3.设计模式是如何应用在本项目中的（本项目应用page object设计模式）
3.个人而言
1）如果你没有任何的编程基础，建议先学习一门编程语言，包括环境的搭建，自己动手写代码，遇到问题多想多琢磨，这样一定会加深自己的印象。如果你有一定的编程基础那么直接看看python的基础语法和selenium就ok（我的自动化测试经验也有限，可能给不了大家太多的建议 ，当然会的越多越好 呵！）
2）自己动手搭个框架，手写一个实战的项目，这时候你会发现你还有好多东西不会，那么线路就来了，哪里不会就去学哪里，边学边写，直到你的项目完成，再次回味就会发现你会了好多，当然不会的东西更多了因为你的思路慢慢的扩宽了，你会想到无人值守，集成等等的想法
3）可以参加培训机构的培训，说实话现在的培训机构越来越多，个人认为有些机构的老师确实是没什么水准的，因为他们教的是基础没有太多的拔高内容，但是有一点是好了，你可以很系统的学习一系列的自动化知识
最后有什么不懂的地方欢迎大家文末加群，我们已经交流学习！
ok 说了很多废话，大家不要介意！直接上项目
项目简介 项目名称：**公司电子零售会员系统
项目目的：实现电子零售会员系统项目自动化测试执行
项目版本：v1.0
项目目录 Retail_TestPro Docs# 存放项目的相关文档　01测试计划 02测试大纲 03测试用例 04测试报告 05测试进度 06技术文档 07测试申请 Package# 存放第三方插件 HTMLTestRunner.py Retail Config __init__.py Conf.py# 读配置文件获取项目跟目录路径 并获取所有欲使用的目录文件的路径 Config.ini# 存放项目跟目录的路径 Data TestData __init__.py elementDate.xlsx# 存放项目中所有的元素信息及测试数据 Email_receiver.txt# 存放邮件的接受者信息 Report# 测试报告 Image Fail# 存放用例执行失败时的截图 Pass# 存放用例执行成功时的截图 Log# 存放用例执行过程中的log信息 TestReport# 存放测试用例执行完成后生成的测试报告 Test_case# 测试用例信息 Models # 存放一些公共方法 Doconfini.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd1d2c37a07f45b27deddbb23f285a19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adda3068f4394f00b67a9652772ed03a/" rel="bookmark">
			javascript 字符串数组排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		javascript 字符串数组排序 可以使用JavaScript内置的sort()方法对字符串数组进行排序。sort()方法默认按照字母顺序进行排序。 例如，对以下字符串数组进行排序：
let fruits = ["banana", "apple", "orange", "kiwi"]; 可以使用以下代码对数组进行排序：
fruits.sort(); 结果将会是：
["apple", "banana", "kiwi", "orange"] 如果需要按照其他方式排序，可以通过传递一个比较函数来控制排序顺序。比较函数接收两个参数，表示要比较的元素。如果第一个元素应该排在第二个元素之前，函数应该返回一个负数；如果第一个元素应该排在第二个元素之后，函数应该返回一个正数；如果两个元素相等，则返回0。
例如，如果需要按照字符串长度进行排序，可以使用以下比较函数：
function compareLength(a, b) { return a.length - b.length; } fruits.sort(compareLength); 结果将会是：
["kiwi", "apple", "orange", "banana"] 该博文为原创文章，未经博主同意不得转。本文章博客地址：https://cplusplus.blog.csdn.net/article/details/134169379
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33f0e8550942fc6cf2ceced0097c9a6b/" rel="bookmark">
			二叉搜索树 和 哈希表 (JAVA)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
二叉搜索树
二叉搜索树的插入 二叉搜索树的查找
二叉搜索树的删除
哈希表 哈希冲突
闭散列
线性探测法
二次探测法
开散列
开散列代码实现：
插入元素 删除元素
查找元素
二叉搜索树 先了解一下二叉搜索树是啥，概念如下：
二叉搜索树又称二叉排序树，它具有以下性质的二叉树或空树:
若它的左子树不为空，则左子树上所有节点的值都小于根节点的值若它的右子树不为空，则右子树上所有节点的值都大于根节点的值它的每颗子树也分别为二叉搜索树 这就是一颗简单的二叉搜索树： 二叉搜索树的插入 二叉搜索树的插入非常简单：
从根节点开始比较，如果大于根节点就遍历右子树，小于根节点就遍历左子树对所有的子树都进行如上操作直到遍历到空节点，将待插入元素插入此空节点 先创建一个二叉搜索树的类，然后创建一个描述节点的内部类：
public class BinarySearchTree { //描述节点的内部类 public static class TreeNode { public int key; public TreeNode left; public TreeNode right; TreeNode(int key) { this.key = key; } } //搜索树的根节点 public TreeNode root; } 添加一个插入元素的方法，注：二叉搜索树的插入只会出现在null节点处，也就是插入的新节点都会成为搜索书的叶子节点 。
public class BinarySearchTree { public static class TreeNode { public int key; public TreeNode left; public TreeNode right; TreeNode(int key) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33f0e8550942fc6cf2ceced0097c9a6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/451addfaf51df69fdb33a84f4aeaffde/" rel="bookmark">
			Vue脚手架学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写自定义目录标题 脚手架文件结构：关于不同版本的Vue:vue.config.js配置文件ref属性配置项propsmixin(混入)插件scoped样式总结TOdoList案例1.组件化编码流程：2.props适用于：3.使用v-model时要记住:v-mdeol绑定的值不能是props传过来的值，因为props是不可以修改的！4.props传过来的若是对象类型的值，修改对象中的属性时Vue不会报错,但不推荐这样做 组件的自定义事件全局事件总线(GlobalEvnetBus)消息订阅与发布(pubsub)nextTick(钩子函数)动画Vue封装的过渡与动画vue脚手架配置代理方法一方法二 插槽Vuex1.概念2.安装搭建3.基本使用4.getters的使用5.四个map方法使用6.模块化+命名空间 路由1.基本使用2.几个注意点3.多级路由4.路由的query参数5.命名路由6.路由的params参数7.路由的props配置8.&lt;router-link&gt;的replace属性 9.编程式路由导航10.缓存路由组件11.路由里面的两个钩子函数12.路由守卫13.路由器的两种工作模式 欢迎使用Markdown编辑器新的改变功能快捷键合理的创建标题，有助于目录的生成如何改变文本的样式插入链接与图片如何插入一段漂亮的代码片生成一个适合你的列表创建一个表格设定内容居中、居左、居右SmartyPants 创建一个自定义列表如何创建一个注脚注释也是必不可少的KaTeX数学公式新的甘特图功能，丰富你的文章UML 图表FLowchart流程图导出与导入导出导入 脚手架文件结构： node_moudels public favicon.ico:页签图标 index.html:主页面 src assets:存放静态资源 logo.png component:存放组件 HelloWord.vue App.vue:汇总组件 main.js:入口文件 .gitignore:git版本管理忽略的配置 babel.config.js:babel的配置文件 package.json:应用包配置文件 README.md:应用描述文件 package-lock.json:包版本控制文件 关于不同版本的Vue: 1.vue.js与vue.runtime.xxx.js区别： (1).vue.js是完整版的Vue,包含：核心功能+模板解析器 (2).vue.runtime.xxx.js是运行版的Vue,只包含：核心功能;没有模板解析器 2.因为vue.runtime.xxx.js没有模板解析器,所以不能使用template配置项,需要使用render函数接受到的createElement函数去指定具体内容 vue.config.js配置文件 使用vue inspect&gt;output.js可以查看都Vue脚手架的默认配置。
使用vue.config.js可以对脚手架进行个性化定制，详情见：https://cli.vuejs.org/zh/config
ref属性 1.被用来给元素或子元素注册引用信息（id的替代者） 2.应用在html标签上获取真实的dom,应用在组件标签上是组件实例对象(vc) 3.使用方式： 打标识:&lt;h1 ref="xxx"&gt;......&lt;/h1&gt;或&lt;School ref="xxx"&gt;&lt;/School&gt; 获取：this.refs.xxx 配置项props 功能：让组件接受外部传过来的数据 (1).传递数据： &lt;Demo name="xxx"/&gt; (2).接收数据： 第一种方式(只接受) props:['name'] 第二种方式(限制类型): props:{ name:Number } 第三种方式(限制类型、限制必要性、指定默认值); props:{ name:{ type:String,//类型 required:true,//必要性 default:'老王'//默认值 } } (3).备注 props是只读的,Vue底层会检测你对props的修改，如果进行了修改,就会发出警告，若业务需求确定需要修改,那么请复制props的内容到data中一份，然后去修改data中的数据，所有的 props 都遵循着单向绑定原则，props 因父组件的更新而变化，自然地将新的状态向下流往子组件，而不会逆向传递。这避免了子组件意外修改父组件的状态的情况，不然应用的数据流将很容易变得混乱而难以理解。 mixin(混入) 功能：可以把多个组件共用的配置提取成一个混入对象 使用方式： 第一步定义混合,列如： { data(){ .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/451addfaf51df69fdb33a84f4aeaffde/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/baa68e37d39e7a97313ce6bded039d92/" rel="bookmark">
			毕业设计项目：基于Python的宁夏旅游景点客流量数据分析与可视化-可视化大屏分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		收藏关注不迷路
文章目录 前言一、项目介绍二、开发环境三、功能介绍四、核心代码五、效果图六、文章目录 前言 随着计算机网络技术的发展，近年来，新的编程语言层出不穷， python语言就是近些年来最为火爆的一门语言，python语言，相对于其他高级语言而言，python有着更加便捷实用的模块以及库，具有语法简单，语句清晰的特点，使得它在代码的编程中，变得更加简洁容易上手，另外，python应用特别广泛，作为是一门应用性广泛的语言，无论是游戏的开发，还是数据的爬取，再到网站的搭建，pvthon都能轻松驾驭，其中，爬虫的应用，更加使得 pvthon这门语言为人所知。
作为网络搜索引擎的组成成分之一，爬虫能够有效的为我们搜索和爬取有用的信息，减少人工的操作，十分方便，在自己定义的条件下，采集得到某些网页的信息，比如房价、股票、招聘信息等，对于这些信息，我们可以对数据进行处理，从而得到我们所需要的信息。
本文通过pvthon实现了一个旅游网站的爬虫信息搜集，并对网站中采集得到的数据进行分析处理，得到想要的数据。
为了提高旅游景点客流量预测准确性,提出了基于数据挖掘的旅游景点客流量预测模型.首先采集旅游景点客流量历史数据,然后通过引入混沌算法构建了旅游景点客流量预测的学习样本,最后引入数据挖掘技术对旅游景点客流量预测进行建模,并引入粒子群算法对旅游景点客流量预测模型参数进行优化.与粒子群算法优化BP神经网络的,支持向量机的旅游景点客流量预测模型的仿真对比测试结果表明,本文模型可以更加准确描述旅游景点客流量变化特点,旅游景点客流量预测误差远小于对比模型,获得了理想的旅游景点客流量预测预测结果.
一、项目介绍 随着计算机网络技术的发展，近年来，新的编程语言层出不穷， python语言就是近些年来最为火爆的一门语言，python语言，相对于其他高级语言而言，python有着更加便捷实用的模块以及库，具有语法简单，语句清晰的特点，使得它在代码的编程中，变得更加简洁容易上手，另外，python应用特别广泛，作为是一门应用性广泛的语言，无论是游戏的开发，还是数据的爬取，再到网站的搭建，pvthon都能轻松驾驭，其中，爬虫的应用，更加使得 pvthon这门语言为人所知。
作为网络搜索引擎的组成成分之一，爬虫能够有效的为我们搜索和爬取有用的信息，减少人工的操作，十分方便，在自己定义的条件下，采集得到某些网页的信息，比如房价、股票、招聘信息等，对于这些信息，我们可以对数据进行处理，从而得到我们所需要的信息。
本文通过pvthon实现了一个旅游网站的爬虫信息搜集，并对网站中采集得到的数据进行分析处理，得到想要的数据。
为了提高旅游景点客流量预测准确性,提出了基于数据挖掘的旅游景点客流量预测模型.首先采集旅游景点客流量历史数据,然后通过引入混沌算法构建了旅游景点客流量预测的学习样本,最后引入数据挖掘技术对旅游景点客流量预测进行建模,并引入粒子群算法对旅游景点客流量预测模型参数进行优化.与粒子群算法优化BP神经网络的,支持向量机的旅游景点客流量预测模型的仿真对比测试结果表明,本文模型可以更加准确描述旅游景点客流量变化特点,旅游景点客流量预测误差远小于对比模型,获得了理想的旅游景点客流量预测预测结果.
二、开发环境 开发语言：Python
python框架：django
软件版本：python3.7/python3.8
数据库：mysql 5.7或更高版本
数据库工具：Navicat11
开发软件：PyCharm/vs code
前端框架:vue.js
————————————————
三、功能介绍 （1）数据获取：通过爬虫技术对携程网、去哪儿网等旅游网站中宁夏旅游景点近五年的信息进行爬取，包括宁夏各个景点(贺兰山、沙坡头、影视基地等)的游客人数、每月来宁夏旅游的人数、全国各省来宁旅游人数、每月各省来宁夏旅游人数、对景点的评论及好评率、特产的销售数据、每月特产的销售情况等数据进行爬取。
（2）数据处理：将爬取到的数据通过Python技术进行处理，对爬取的数据进行数据清洗操作，处理缺失值、空值等。
（3）数据存储：将通过爬虫获取到的数据经过数据清洗和处理之后存储在数据库中，同时将可视化分析与数据库表连接，确保数据实时更新。
（4）数据可视化：完成数据的获取、处理和存储后，开始进行制作可视化大屏，先制作一个宁夏的地图，然后在地图上显示宁夏地区的各个旅游景点，将宁夏地区的每个旅游景点的数据制作成一个个的图表，将旅游景点的信息与图表相关联，用户点击每个旅游景点查询相关数据图展示效果。
（5）算法：在完成的可视化大屏中添加协同过滤算法，对旅游用户进行分析来发现旅游用户的旅游偏好，并预测用户喜欢的旅游地点进行推荐。
（6）前端展示：将完成的可视化大屏通过前端的方法进行展示，将可视化大屏制作成网页的形式，使用起来快捷、方便，给用户带来较高的用户体验。
四、核心代码 部分代码：
def users_login(request): if request.method in ["POST", "GET"]: msg = {'code': normal_code, "msg": mes.normal_code} req_dict = request.session.get("req_dict") if req_dict.get('role')!=None: del req_dict['role'] datas = users.getbyparams(users, users, req_dict) if not datas: msg['code'] = password_error_code msg['msg'] = mes.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/baa68e37d39e7a97313ce6bded039d92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ddfddbe4b1166292f2b20bafe4c02af/" rel="bookmark">
			oracle sqlplus的使用 ，查询oracle实例名和服务名，查询oracle容器，切换oracle容器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Oracle的sqlplus是与oracle数据库进行交互的客户端工具（oracle数据库自带的客户端工具），借助sqlplus可以查看、修改数据库记录。在sqlplus中，可以运行sql*plus命令与sql语句。
1。先使用root账户登陆系统后，使用su - oracle 切换至oracle用户。
2.在oracle账户下使用以下命令
sqlplus / as sysdba 以sysdba（超级用户）连接oracl数据库，可以用来执行sql语句,分配数据库用户，配置等操作。
3.使用以下sql语句可以切换数据库用户
sql：
connect 用户名/用户名密码@ORCLPDB1 ORCLPDB1是可插拔数据库名称
4.使用普通用户账号连接数据库
sqlplus balll/dbpwd123@10.52.11.6/ORCLPDB1 其中balll 是账号，dbpwd123是密码,10.52.11.6是ip ,ORCLPDB1是服务名。
5.查看当前数据库服务名
sql:
select global_name from global_name; 6.查看数据库实例名
sql：
select instance_name from v$instance; 7.查看当前容器
sql:
show con_name; 8.切换容器
sql:
alter session set container=orclpdb1; alter session set container=cdb$root; 不同容器中 服务名是不同的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd31b19f1e189088afc9df9678233917/" rel="bookmark">
			vscode远程ssh服务器且更改服务器别名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、打开VS Code并确保已安装"Remote - SSH"扩展。如果尚未安装，请在扩展市场中搜索并安装它。
2、单击左下角的"Remote Explorer"图标，打开远程资源管理器。
3、在远程资源管理器中，单击右上角的齿轮图标，选择"Configure SSH Hosts"。
4、在弹出的文本框中，你可以添加你的远程服务器配置。配置的格式如下所示：
5、保存配置文件并关闭。
在Visual Studio Code (VS Code) 中通过SSH连接到远程服务器时，由于连的服务器较多，容易将端口号搞混，浪费时间且浪费精力。以下是如何在VS Code中为远程服务器设置别名的步骤：
1、打开VS Code并确保已安装"Remote - SSH"扩展。如果尚未安装，请在扩展市场中搜索并安装它。 2、单击左下角的"Remote Explorer"图标，打开远程资源管理器。 3、在远程资源管理器中，单击右上角的齿轮图标，选择"Configure SSH Hosts"。 输入: ssh root@10.10.10.19
4、在弹出的文本框中，你可以添加你的远程服务器配置。配置的格式如下所示： Host &lt;别名&gt;
HostName &lt;服务器IP或域名&gt;
User &lt;用户名&gt;
Port &lt;端口号&gt;
请将&lt;别名&gt;替换为你希望使用的服务器别名，&lt;服务器IP或域名&gt;替换为远程服务器的实际IP地址或域名，&lt;用户名&gt;替换为你的远程服务器用户名，&lt;端口号&gt;替换为你的远程服务器SSH端口号（默认为22）。
例如
Host 测试小主板
HostName 192.168.1.100
User myusername
Port 2222
5、保存配置文件并关闭。 现在，你可以在远程资源管理器中看到你的服务器别名，可以轻松地通过VS Code连接到服务器。
方法二：
vi ~/.ssh/config 直接在这个里面修改
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79e925adea8fcf6511cced90324bee2b/" rel="bookmark">
			Tomcat 启动闪退问题解决集（八大类详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Tomcat启动闪退问题解决集（八大类详细） 本文目录：
一、Java环境不对，Tomcat 不同版本需要的Java环境不同。
二、环境变量没有配置好
三、Tomcat端口被占用
四、配置文件编码问题
五、启动时需要的配置文件编写出错
六、部分相关文件丢失
七、免安装的tomcat闪退
八、修改配置文件setclasspath.bat
九、等待更新
Tomcat 启动时出现黑屏一闪而过的现象原因有很多，但通常都涉及几个方法：
一、Java环境不对，Tomcat 不同版本需要的Java环境不同。 有时tomcat版本能够正常安装，但启动时检测到java 版本不对就会出现启动黑屏一闪而过的现象。例如：tomcat 10.1-M14版本能够在java version “1.8.0_131”下用命令提示符安装成功，运行时却出现启动黑屏一闪而过的现象，查了很久都没有发现原因，最近官方出了安装提示才明白问题出在运行需要Java 11 或更高版本环境。
检查Java版本是否适合安装，按windows + R 启用cmd命令,打开命令提示符，输入“java -version”，回车，出现jdk版本，
如果不适合，请先安装相应的Java版本。
当前Java SE Development Kit 最新版本是18.0.1.1
下载地址：Java Archive Downloads - Java SE 18
或http://openjdk.java.net/install/index.html
Java SE Development Kit 18.0.1.1
二、环境变量没有配置好 Tomcat需要配置好JRE才能正常运行。一般情况下，启动闪屏崩溃是因为找不到JRE路径，也就是说环境变量在安装JDK的时候没有配置好。
检查jdk是否安装，按windows + R 启用cmd命令,打开命令提示符，进入命令提示符，输入“java -version”，回车，出现jdk版本，表示安装成功，检查版本是否合适，参考上文Java环境和tomcat版本对应关系。
检测jdk配置有没出错，可以在tomcat安装目录\bin下，startup.bat文件最后加上pause命令
启动运行tomcat，黑屏会需要按任意键才结束如图：
如能如图正常显示Using路径，说明环境变量设置没有问题，可跳过此步骤。
如发现问题，可检查相关环境变量配置
① 配置环境变量，本机电脑—&gt;属性—&gt;高级—&gt;点击环境变量
②在系统变量里点击新建—&gt;添加变量：
③ 输入变量名，变量值：
变量名：CATALINA_HOME
变量值：c:\00\ tomcat10_021
（变量值为tomcat安装路径，就是你刚刚解压安装tomcat的那个文件夹路径）
④ 在系统变量里找到Path，双击打开：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79e925adea8fcf6511cced90324bee2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd0875e43e5988a19724a5c7337d5d93/" rel="bookmark">
			字段属性（MySQL和Navicat版本比较）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Unsigned 作用：将int类型的数据声明为无符号数，则该数据不能为负数
在mysqlyod中是：Unsigned
在navicat中是
zerofill 作用：int类型的数据，如果我们设置了长度，则不满足长度的数据用0来填充 在mysqlyod中是：zerofill
在navicat中是
自增 作用：将int类型的数据自动设置成自增X（可以设置），通常用在设计唯一的主键，必须是整数类型！！！
navicat:
还可以自定义主键的自增起始值和步长：
非空 作用： 当我们给这个字段勾选了非空，当我们给表增加数据时，如果这个字段为空，系统就会报错
navicat:
默认 作用：设置默认的值
假如设置性别sex,默认为男，当插入数据时，这个字段为空，系统会自动默认为男
navicat:
注意：navicat中设置默认值需要加‘’
项目字段规范 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33a8e9ec79efa4959a583a1e984d36d9/" rel="bookmark">
			【ChatGPT 01】ChatGPT基础科普
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 从图灵测试到ChatGPT 1950年，艾伦•图灵(Alan Turing)发表论文**《计算机器与智能》（ Computing Machinery and Intelligence），提出并尝试回答“机器能否思考”这一关键问题。在论文中，图灵提出了“模仿游戏”（即图灵测试**）的概念，用来检测机器智能水平。图灵测试的核心思想是，如果一个人（代号C）使用测试对象皆理解的语言去询问两个他不能看见的对象任意一串问题，其中一个是正常思维的人（代号B），另一个是机器（代号A）。如果经过若干询问以后，C不能得出实质的区别来分辨A与B的不同，则此机器A通过图灵测试。
1956年，人工智能正式成为了一个科学上的概念，而后涌现了很多新的研究目标与方向。虽然，图灵测试只是一个启发性的思想实验，而非可以具体执行的判断方法，但他却通过这个假设，阐明了“智能”判断的模糊性与主观性。从此图灵测试成为了 自然语言处理（Natural Language Processing，NLP） 任务的一个重要评测标准。图灵测试提供了一个客观和直观的方式来评估机器是否具有智能，即通过让机器与人类进行对话来判断其智能水平。这种方式可以避免对智能本质的哲学争论，也可以避免对智能具体表现形式的技术细节。 因此，很多自然语言处理任务都可以用图灵测试来进行评测，例如对话系统、问答系统、文本生成等。
自然语言处理（Natural Language Processing，NLP）是计算机科学，人工智能，语言学关注计算机和人类（自然）语言之间的相互作用的领域。它研究能实现人与计算机之间用自然语言进行有效通信的各种理论和方法。自然语言处理包括很多不同的任务，如分词、词性标注、句法分析、语义分析、信息抽取、文本分类、文本摘要、机器翻译、问答系统、对话系统等。
图灵测试与自然语言处理任务有着密切而复杂的关系，可以从以下两个方面来概括：
一方面，图灵测试是自然语言处理任务的一个重要驱动力。图灵测试提出了一个具有挑战性和吸引力的目标，即让机器能够用自然语言与人类进行流畅、智能、多样化的对话。 为了达到这个目标，自然语言处理领域不断地发展和创新各种技术和方法，以提高机器对自然语言的理解和生成能力。例如，为了让机器能够回答用户提出的问题，就需要研究问答系统这一自然语言处理任务；为了让机器能够根据用户提供的信息生成合适的文本，就需要研究文本生成这一自然语言处理任务；为了让机器能够适应不同领域和场景的对话，就需要研究领域适应和情境感知这一自然语言处理任务等等。另一方面，图灵测试是自然语言处理任务的一个重要目标。图灵测试提出了一个具有前瞻性和理想性的愿景，即让机器能够达到与人类相同或者超越人类的智能水平。 这个愿景激发了很多自然语言处理领域的研究者和开发者，使他们不断地探索和创新，以期实现真正意义上的自然语言理解和生成。例如，为了让机器能够理解用户提出的问题，就需要研究语义分析、知识表示、逻辑推理；为了让机器能够生成符合用户需求的文本，就需要研究文本规划、文本风格、文本评价；为了让机器能够与用户建立信任和情感的联系，就需要研究情感分析、情感生成、情感对话等等。 自然语言处理与人工智能发展历史有着密切而复杂的关系。它们相互促进、相互影响、相互依存、相互目标。自然语言处理在人工智能发展历史上有很多里程碑式的成果，比如：
1954年，IBM实现了世界上第一个机器翻译系统，将俄语翻译成英语。1966年，约瑟夫·韦伊岑鲍姆开发了ELIZA，一种模拟心理治疗师的对话系统。1972年，特里·温诺格拉德开发了SHRDLU，一种能够理解和生成自然语言的程序，用于控制一个虚拟的机器人在一个虚拟的世界中进行操作。1988年，杰拉尔德·萨斯曼和詹姆斯·马丁创建了Text Retrieval Conference（TREC），一个旨在推动信息检索和自然语言处理技术发展的国际评测活动。2011年，苹果公司推出了Siri，一种基于自然语言处理技术的智能个人助理。同年，IBM的Watson战胜了《危险边缘》节目的冠军选手，展示了自然语言处理技术在问答领域的强大能力。2013年，谷歌公司推出了Word2Vec，一种基于神经网络的词向量表示方法，开启了自然语言处理领域的深度学习时代。2016年，Facebook发布了FastText的文本分类算法，它可以在处理大规模文本分类任务时取得很好的效果。2017年，Google发布了一篇很可能是AI历史上最重要的一篇论文《Attention is all you need》，在论文中作者提出了Transformer——一个具有多头注意力机制的模型，在文本特征提取方面取得了优异的效果。2018年，Google发布了BERT预训练模型，它在多项NLP任务上取得了最佳效果，引领自然语言处理进入了预训练时代。2020年，OpenAI发布的GPT-3模型有多达1750亿的参数，可以在提供少量样本或不提供样本的前提下完成大多数NLP任务。 以上这些能力成果依赖于自然语言处理技术（NLP）的不断发展。NLP领域涉及到的技术非常广泛，但其中最基础的就是——词嵌入（也叫词向量，Word Embedding），以及与此相关的文本表征技术。它本质上是找到一种编码方式，实现从自然语言中到数学空间的映射。
我们为什么需要词向量呢？当我对计算机说出“我爱你。”的时候，计算机无法真正理解我说了什么。要想让计算机理解我说的话，必须要对“我爱你。”这句话进行编码（Encoding）——比如：我们可以让数字“1”代表“我”，数字“2”代表“爱”，数字“3”代表“你”，数字“0”代表“句号”。经过编码之后，计算机才能理解这句话然后再进行计算和处理。词向量就是以单词为为单位进行编码，那么如何进行编码才是最优的方式呢？从1940年代开始，人们就希望寻找解决这个问题的模型和方法，下面选择最经典的词袋模型和神经网络概率模型，做一些简单一点的介绍。
词袋模型（Bag of Words,BOW）：从名字来看，词袋模型就像是一个大袋子，把所有的词都装进来。文本中的每个单词都看作是独立的，忽略单词之间的顺序和语法，只关注单词出现的次数。在词袋模型中，每个文本可以表示为一个向量，向量的每个维度对应一个单词，维度的值表示该单词在文本中出现的次数。神经概率语言模型（Neural Probabilistic Language Model，NPLM）：它可以通过学习大量的文本数据来预测下一个单词或字符的概率。其中，最早的神经网络语言模型是由Yoshua Bengio等人于2003年发表的《A Neural Probabilistic Language Model》提出的，它在得到语言模型的同时也产生了副产品词向量。 早期的词向量都是静态的，一旦训练完就固定不变了。随着NLP技术的不断发展，词向量技术逐渐演变成基于语言模型的动态表征。语言模型不仅可以表征词，还可以表征任意文本。
时间来到了2022年，终于轮到我们的主角要隆重登场了。2022年11月30日OpenAI发布了一款真正的智能聊天机器人ChatGPT，一经发布立刻就点燃了AI圈。仅仅五天就达到了100万用户。OpenAI不得不紧急扩容，用户发现ChatGPT不仅仅只会插科打诨和人类聊天，它还能写论文，讲笑话，编段子，生成演讲稿，写请假条，模仿导师写推荐信，甚至帮你写代码，写营销策划案等等。拥有了ChatGPT，就像你身边配备了一个功能强大的秘书。到了2023年1月，大量用户开始涌入，仅仅两个月的时间ChatGPT成为了史上最快达到1亿用户的应用。
无论是ChatGPT，还是其他后来的模仿者，它们其实都是语言模型，准确来说——大语言模型。使用时，无论是调用API还是开源项目，总有一些参数可能需要调整。对大部分内行人士来说应该都不成问题，但对外行就有点玄乎了。基于此，本文将简要介绍ChatGPT相关技术基本原理，行文将站在外行人角度，尝试将内容尽量平民化。虽然不能深入细节，但知晓原理足以很好使用了。
本文共分为四个部分：
LM：这是ChatGPT的基石的基石，是一个最基本的概念，绕不开，逃不过，没办法。Transformer：这是ChatGPT的基石，准确来说它的一部分是基石。GPT：本体，从GPT-1，一直到现在的GPT-4，按OpenAI自己的说法，模型还是那个模型，只是它长大了，变胖了，不过更好看了。关于这点，大家基本都没想到。现在好了，攀不上了。RLHF：ChatGPT神兵利器，有此利刃，ChatGPT才是那个ChatGPT，不然就只能是GPT-3。 1. LM LM，Language Model，语言模型，简单来说就是利用自然语言构建的模型。这个自然语言就是人常说的话，或者记录的文字等等，只要是人生产出来的文字，都可以看做语言。你现在看到的文字也是。模型就是根据特定输入，通过一定计算输出相应结果的一个东西，可以把它当做人的大脑，输入就是你的耳、眼听或看到的文字，输出就是嘴巴说出来或手写出来的文字。总结一下，语言模型就是利用自然语言文本构建的，根据输入的文字，输出相应文字的模型。
具体是怎么做的呢，方法有很多种，比如我写好一个模板：「XX喜欢YY」，如果XX=我，YY=你，那就是我喜欢你，反过来就是你喜欢我。我们这里重点要说的是概率语言模型，它的核心是概率，准确来说是下一个词的概率。这种语言模型的过程是通过已经有的词预测接下来的词。我们举个简单的例子，比如你只告诉模型：「我喜欢你」这句话，当你输入「我」的时候，它就知道你接下来要说「喜欢」了。为什么？因为它脑子里就只有这四个字，你没告诉它其他的呀。
好，接下来，我们要升级了。假设你给了模型很多很多句话，多到现在网上能找到的资料都给了它。这时候你再输入「我」，我敢打赌它大概不会说「喜欢」了。为什么？简单，见多了世面，眼里怎么可能只有喜欢你三个字。但因为我们考虑的是最大概率，很有可能它每次都会输出同样的话。对，没错，如果每次都只选择下个最大概率的词，你就是会得到同样的话。这种方法叫做Greedy Search（中文叫贪心搜索），很贪，很短视！所以，语言模型都会在这个地方做一些策略，让模型每一步多看几个可能的词，而不是就看那最高的一个，这样继续往下找的时候，你会发现到下一步时，刚刚最大概率的词，如果加上这一步的词，它的路径（两步概率乘积）概率可能没有刚刚小一点概率的词的路径概率大。举个例子，请看下面这幅图：
（图1：如何预测下一个词）
先看第一步，如果只选概率最大的那个词，那就变成「我想」了，但是别急，我们给「喜欢」一点机会，同时考虑它们两个。再往下看一步，最大概率的都是你，我们也选两个，最后有这么几句（以及我们附上它们的概率）：
「我喜欢你」概率：0.3×0.8=0.24「我喜欢吃」概率：0.3×0.1=0.03「我想你」概率：0.4×0.5=0.2「我想去」概率：0.4×0.3=0.12 多看一步大不一样！看看概率最大的成谁了，久违了，再说一句「我喜欢你」。上面这种方法叫做Beam Search（中文叫集束搜索），简单来说就是一步多看几个词，看最终句子（比如生成到句号、感叹号或其他停止符号）的概率。刚刚我们的例子中，num_beams=2（只看了2个），看的越多，约不容易生成固定的文本。
好了，其实在最开始的语言模型中，大家基本就到这里，上面介绍这两种也叫解码策略。当时更多被研究的还是模型本身，我们经历了从简单模型到复杂模型到巨复杂模型的变迁过程。简单模型就是把一句话切成一个个词，然后统计概率，这类模型叫做Ngram语言模型，是最简单的语言模型，**这里的N表示每次用到的上下文长度。**还是举个例子，看下面这句话：「我喜欢在深夜的星空下伴随着月亮轻轻地想你」。常用的N=2或3，等于2的叫Bi-Gram，等于3的叫Tri-Gram：
Bi-Gram：我/喜欢 喜欢/在 在/深夜 深夜/的 的/星空 星空/下……Tri-Gram：我/喜欢/在 喜欢/在/深夜 在/深夜/的 深夜/的/星空 的/星空/下…… 前者下一个词是根据上一个词来的，后者是根据上两个词来的，就是这个区别。这里有个小知识需要说明一下，实际中我们往往不叫一个词为「词」，而是「Token」，你可以将其理解为一小块，可以是一个字，也可以是两个字的词，或三个字的词，取决于你怎么Token化。也就是说，给定一个句子时，我有多种Token化方式，可以分词，也可以分字，英文现在都是分子词。比如单词Elvégezhetitek，Token化后变成了：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33a8e9ec79efa4959a583a1e984d36d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b87b507f153e0723a2b3fd61fd2361c/" rel="bookmark">
			关于使用PyQt6与PySide6的出现：DLL load failed while importing QtCore: 找不到指定的程序。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提供一个解决思路：我在代码中同时引入了
PySide6和PyQt6的依赖，所以会出现该问题，单独使用没有问题 因此注意你是否同时引用了这两个包的依赖，如果是的话，修改为一种pyqt6或者是pyside6
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08a2b19f31418734bcf98dd6cd56c2b6/" rel="bookmark">
			物理内存,虚拟内存,磁盘swap分区的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
一、图形简介
二、详解
1、物理内存
2、虚拟内存
3、磁盘swap分区
4、为了节省内存
4.1、实际用了多少，物理内存就给分配多少
4.2、物理内存什么时候用什么时候分配
一、图形简介 二、详解 1、物理内存 硬件上，就是内存条。我们知道一个程序运行，必要开一片内存来存储其相关指令和需要用到的堆栈段空间等。
2、虚拟内存 物理内存总共4G或16G的大小，若每个进程都开4G物理内存，那物理内存就会被很快用完，系统多进程运行也必将受限。
为了节省物理内存，从逻辑的角度上，我们为每个进程虚拟出4G虚拟内存，每个进程都以为自己拿到了4G内存。
好处是不再为每个进程分配4G物理内存，而是实际用了多少，物理内存就给分配多少
3、磁盘swap分区 对物理内存扩展，若4G物理内存分配完了，那程序的数据就会存到磁盘swap分区上。
4、为了节省内存 4.1、实际用了多少，物理内存就给分配多少 如：一个进程实际用了400M内存，那4G虚拟内存理论上就对应400M的物理内存。因不是一下就分配的(因虚拟内存和swap分区存在，允许程序什么时候用就什么时候分配物理内存)，所以某个时间点上，对应的物理内存&lt;400M
4.2、物理内存什么时候用什么时候分配 因cpu只与物理内存交互，所以什么时候用到了swap分区上的数据，什么时候就把数据拷贝或做页面置换到物理内存。实际上一开始虚拟空间都被映射到了磁盘空间当中(像代码段，常量数据等)，只有当访问到此地址时，也就是真正用到的时候，才会将磁盘上的数据拷贝到物理内存中。像malloc动态分配内存时也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应的设置，当进程真正访问到此数据时，才引发页面异常。 先建立好虚拟内存和磁盘swap分区、虚拟内存和物理内存的映射关系；进程创建时，程序的代码段和数据其实还在磁盘上，并未放到物理内存上运行到对应的程序时，进程查找页表，根据映射关系，发现其真正的地址（存储的真正位置）并不在物理内存上而是在磁盘上。此时发生缺页异常 -&gt; 进程阻塞 -&gt; 页面置换或拷贝，将磁盘数据放到物理内存中 -&gt; 进程就绪进程运行 -&gt; 访问其对应的物理内存 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dc97fd60aa4ecf70667588b8050fde9/" rel="bookmark">
			Java中的I/O流系统（一）：字节流体系知识总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 字节I/O流简要体系原始字节流FileInputStreamFileOutputStream 缓冲字节流BufferedInputStreamBufferedOutputStream 字节打印流PrintStream 数据流DataInputStreamDataOutputStream 序列化流ObjectInputStreamObjectOutputStream I/O流是指从计算机的外设和程序之间传送的数据序列；输入流代表从计算机外设流入程序的数据序列，如通过键盘输入的数据；输出流代表从程序流向计算机外设的数据序列，如向屏幕打印数据。根据I/O流数据格式分类可以将I/O流分为字节流和字符流，本篇主要介绍字节流。
字节I/O流简要体系 原始字节流 FileInputStream 1. 构造方法
构造方法说明FileInputStream(String name)输入流关联文件，文件路径以字符串形式给出FileInputStream(File file)输入流关联文件，文件路径以File对象形式给出 关联的文件如果不存在就会抛出FileNotFoundException异常，路径如果是一个文件夹会提示拒绝访问。
2. 常用成员方法
成员方法说明int read()从数据中读入一个字节，并返回该字节，碰到输入流结尾时返回-1int read(byte[] b)读入一个字节数组，返回实际读入的字节数，碰到输入流结尾时返回-1，最多读入b.length个字节void close()关闭这个输入流 当完成输入/输出流的读写时，应该调用close方法来关闭它，以释放掉十分有限的操作系统资源。
在JDK7版本以后，可以使用将需要调用close方法的对象放到try()的括号里面，将在代码块结束后自动关流。try()中的对象需要实现过AutoCloseable接口。
FileOutputStream 1. 构造方法
构造方法说明FileOutputStream(String name)输出流关联文件，文件路径以字符串形式给出FileOutputStream(String name, boolean append)append若为Ture表示允许追加FileOutputStream(File file)输出流关联文件，文件路径以File对象形式给出FileOutputStream(File file, boolean append)append若为Ture表示允许追加 2. 常用成员方法
成员方法说明void write(int b)写出单个字节void write(byte[] b)写出一个字节数组void write(byte[] b, int off, int len)写出从off开始len长范围内的字节数组内容void close()冲刷并关闭输出流void flush()冲刷输出流将缓冲数据发送到目的地 write()方法括号内放的是字节，对于非字节内容的输出可以使用getBytes()将内容转化为字节或字节数组进行输出。
关闭一个输出流的同时还会冲刷用于该输出流的缓冲区，所有被临时置于缓冲区以便用更大的包的形式传递的字节在关闭输出流是将会被送出。当然也可以用flush方法人为地冲刷写出字节的最后一个包的输出。
//读入和写出单个字节 try(FileInputStream fis1=new FileInputStream("E:\\Test1.jpg"); FileOutputStream fos1=new FileOutputStream("E:\\Test1New.jpg")){ int b; while((b=fis1.read())!=-1){ fos1.write(b); } } catch (IOException e){ e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2dc97fd60aa4ecf70667588b8050fde9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d96c9ae3a41b6bf212b3dd57367befd/" rel="bookmark">
			求四个数的最大数#C语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目描述 已知有四个不等的数，将其中的最大数找出来。
输入 输入只有一行，包括4个整数。之间用一个空格分开。
输出 输出只有一行（这意味着末尾有一个回车符号），包括1个整数。
样例输入 1 9 8 6 样例输出 9 代码如下
#include&lt;stdio.h&gt; int main() { int a[4]; int max = 0; for (int i = 0; i &lt; 4; i++) { scanf("%d", &amp;a[i]); } for (int i = 0; i &lt; 4; i++) { if (a[i] &gt; max) { max = a[i]; } } printf("%d", max); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56ad6953aee12eb6b8234393fdfe2a21/" rel="bookmark">
			Linux 操作另一台服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		服务器信任 在运维场景中，如果需要在一台服务器操作另一台服务器，就需要目标服务器（下面称为 B 服务器）信任当前服务器（下面称为 A 服务器）。
在 A 服务器生成证书。
ssh-keygen -t rsa 一直回车结束。
会在 /root/.ssh 目录下生成 id_rsa 和 id_rs.pub 两个文件：
id_rsa 为私钥。id_rs.pub 为公钥。 公钥拷贝到 B 服务器。
scp /root/.ssh/id_rsa.pub root@B:/root/ 这里由于 B 服务器还没有信任 A 服务器，所以会提示输入密码。
登录 B 服务器，并将该文件追加到 /root/.ssh/authorized_keys 文件中。
cat /root/id_rsa.pub &gt;&gt;/root/.ssh/authorized_keys 如果此时报Operation not permitted，说明authorized_keys没有修改权限，可以进行如下操作：
修改 authorized_keys 权限：
chmod 600 /root/.ssh/authorized_keys 如果依然报Operation not permitted，有以下两种可能：
当前用户权限不足，可以在命令前面加上sudo执行：
sudo chmod 600 /root/.ssh/authorized_keys 如果以上命令依然报Operation not permitted，则可能是文件处于保护状态，执行如下命令解除：
chattr -ia /root/.ssh/authorized_keys 如此再执行上诉操作即可。
服务器操作 上传文件 使用如下命令可以传输 A 服务器的文件到 B 服务器。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56ad6953aee12eb6b8234393fdfe2a21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b343acdaaeabed3146e8dc7d1fa36997/" rel="bookmark">
			网站整站下载工具，将网站离线下载到本地，本地自动生成网站镜像的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本期带来一个实用小工具，可以将整个网站下载到本地，以实现目标网站的离线浏览。不论是教程网站、还是在线工具网站，都可以尝试用它生成本地镜像网站，实现网站的离线浏览/使用。
文末附工具下载链接~
一、软件简介 本次带来的软件是一个实用的离线浏览器程序，它可以将目标网站的目录结构及内容完整的下载保存到本地磁盘，并自动将拷贝页面中的超链接修改为本地镜像链接，以此来实现在本地访问目标网站而不需要联网。重要的是，该软件所有功能完全免费，无任何收费功能。
二、使用方法 软件的最新版本是3.49-2，分为安装版以及绿色版（免安装），安装版完成安装后可以在系统最近安装的软件中找到，直接打开即可使用。绿色版是一个压缩文件，解压后有一个名为【httrack】的文件夹和一个【file_id.diz】文件。要运行绿色版软件，首先进入【httrack】子文件夹，然后下拉找到名为【WinHTTrack.exe】文件，双击即可运行进入软件主界面。
第一次使用软件会弹出窗口选择语言，这里直接上划选择【Chinese-Simplified】即可切换为中文，选择完成后会弹出一个窗口提示我们重启软件后可以切换语言，手动关闭软件后再打开即可（不重启可能会出现汉化不完整的情况）。
重启软件后进入主界面直接点击【下一步】来创建一个新的工程。
在第一个红框内填写工程名称（随便写），然后点击第二个红框中【…】按钮，选择一个文件夹用来存储目标网站的镜像。
第一个红框中操作选项，使用默认的【下载整站】即可，该选项已经可以将目标网站进行整站镜像下载。第二个红框中输入你要下载网站的链接即可（如果你只想下载该网站的一个子目录，这里的链接就填写子目录链接）。第三个红框中的【选项】功能可以设置下载选项。
如果你要下载的网站中包含图片等内容，可以找到【选项】中的【扫描规则】，将下图红色框中最左侧与图像后缀名相关的一栏勾选上（如果磁盘空间允许，也可以全部勾选上）。
上一个页面设置完成后，下一个页面有需要特别注意的地方，该页面中红色框中原始选项为【不使用远程连接】，如下图所示
如果使用上述默认选项下载失败，可以手动切换成【已连接到网络】选项，如下图所示
点击完成后即可开始网站下载，根据网站大小不同，下载所需的时间长短也不一样。
下载完成后，从之前的设置的下载文件夹中就可以找到目标网站的镜像，双击【index.html】，然后在页面中点击对应的【工程名称】即可进入对应的本地网站镜像。
如果出现瞬间下载完成，但网站没有镜像成功，可能是因为网络问题或先前工程的设置问题，可以检查网络是否通畅或修改工程的设置再次尝试下载。
三、下载链接 链接1：
https://pan.baidu.com/s/1BjnF-fnH0q2J8iN4QHWQtg?pwd=39ce
链接2：
https://donot996.lanzoub.com/b048ul1uf
密码：e3mh
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f42affc12898e64274f51e2bf53154ca/" rel="bookmark">
			【SWAT水文模型】ArcSWAT各种报错总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ArcSWAT各种报错总结 1 变量未实例化1.1 报错内容1.2 解决方法 2 Error Number :-2147467259； 对 COM 组件的调用返回了错误 HRESULT E_FAIL2.1 报错内容2.2 解决方法 3 Error Number :-21474672593.1 报错内容3.2 解决方法 4 INSER INTO 语句的语法错误。: IN, mWriteInputFiles.sol4.1 报错内容4.2 解决方法 5 IN, mWriteInputFiles.wgn5.1 报错内容5.2 解决方法 6 系统找不到指定的文件。:Unable to open Access database from ArcSWAT6.1 报错内容6.2 解决方法 7 Outlet输入文件格式：Type field does not exist7.1 报错内容7.2 解决方法经纬度坐标转平面坐标 8 Overlay时：Unhandled exception has occured in a component in your application. Exception from HERSULF: 0x800A01C98.1 报错内容8.2 解决方法 9 Error Number: -21472172569.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f42affc12898e64274f51e2bf53154ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c697df9cd78a2fea3310277e238e985e/" rel="bookmark">
			Java如何使用KEPserver 实现S71500 OPC通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.PLC和OPC
使用的PLC：西门子PLC S7-1500
使用的OPC server软件：
KEPServer V6 二.连接测试
OPC是工业控制和生产自动化领域中使用的硬件和软件的接口标准，以便有效地在应用和过程控制设备之间读写数据。O代表OLE(对象链接和嵌入)，P (process过程)，C (control控制)。
OPC服务器包括3类对象(Object)：服务器对象(Server)、项对象(Item)和组对象(Group)。
OPC标准采用C/S模式，OPC服务器负责向OPC客户端不断的提供数据。
maven依赖
&lt;!--utgard --&gt; &lt;dependency&gt; &lt;groupId&gt;org.openscada.external&lt;/groupId&gt; &lt;artifactId&gt;org.openscada.external.jcifs&lt;/artifactId&gt; &lt;version&gt;1.2.25&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.openscada.jinterop&lt;/groupId&gt; &lt;artifactId&gt;org.openscada.jinterop.core&lt;/artifactId&gt; &lt;version&gt;2.1.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.openscada.jinterop&lt;/groupId&gt; &lt;artifactId&gt;org.openscada.jinterop.deps&lt;/artifactId&gt; &lt;version&gt;1.5.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.openscada.utgard&lt;/groupId&gt; &lt;artifactId&gt;org.openscada.opc.dcom&lt;/artifactId&gt; &lt;version&gt;1.5.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.openscada.utgard&lt;/groupId&gt; &lt;artifactId&gt;org.openscada.opc.lib&lt;/artifactId&gt; &lt;version&gt;1.5.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.bouncycastle&lt;/groupId&gt; &lt;artifactId&gt;bcprov-jdk15on&lt;/artifactId&gt; &lt;version&gt;1.61&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;1.3.0-alpha4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.3.0-alpha4&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 读取PLC 的点位值
import java.util.concurrent.Executors;
import org.jinterop.dcom.common.JIException;
import org.jinterop.dcom.core.JIString;
import org.jinterop.dcom.core.JIVariant;
import org.openscada.opc.lib.common.ConnectionInformation;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c697df9cd78a2fea3310277e238e985e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26107ec6216d52fed6d0edbd3df3a064/" rel="bookmark">
			Springboot使用EasyExcel导入导出Excel文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，准备Excel文件和数据库表结果 2，导入代码 1，引入依赖 &lt;!-- https://mvnrepository.com/artifact/com.alibaba/easyexcel --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; 2，创建请求body import com.alibaba.excel.annotation.ExcelProperty; import lombok.Data; /** * Description * * @author WangYaoLong * @createdate 2023/11/01 0001 11:43 */ @Data public class StudentImportExcelForm { @ExcelProperty(value = "学生姓名", index = 0) private String name; @ExcelProperty(value = "性别", index = 1) private String sex; @ExcelProperty(value = "学号", index = 2) private String stuId; @ExcelProperty(value = "身份证号", index = 3) private String identityNum; @ExcelProperty(value = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26107ec6216d52fed6d0edbd3df3a064/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c53b7a6bfc45b117a705cf693f936d18/" rel="bookmark">
			java面试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、谈谈对面向对象的理解 面向对象编程（Object-Oriented Programming, OOP）是一种流行的编程范式，它以“对象”为核心来设计和实现程序。在OOP中，对象是现实世界事物的抽象，它包含了数据（属性）和操作（方法）。这种编程范式通过将数据和操作封装在一起，实现了代码的高度模块化和复用性。
2、redis的数据格式类型。 Redis支持五种基本数据类型：
string（字符串）：字符串类型是Redis中最基本的数据存储类型，它是一个由字节组成的序列，在Redis中是二进制安全的。这意味着该类型可以接受任何格式数据，如JPEG图像数据和Json对象说明信息。它是标准的key-value，通常用于存储字符串、整数和浮点。hash（哈希）：哈希类型是一种键值对的集合。它允许存储一个由字段和值组成的字典，每个字段都是唯一的。list（列表）：列表类型是有序的字符串集合，可以随时插入和删除元素。set（集合）：集合类型是无序的唯一元素集合，它不保留元素的顺序，但可以快速检查元素是否存在。sort set （有序集合）：有序集合类型与集合类似，但每个元素都有一个相关的分数，Redis根据这个分数为集合中的元素排序。 以上是Redis的五种数据类型，每种类型都有其特定的用途和操作方式。
3、用redis实现博客系统的评论缓存，怎么具体存储，用什么数据格式类型 在博客系统的评论缓存中，我们可以使用Redis的hash数据类型来存储评论信息。具体来说，我们可以为每条评论创建一个hash，其key可以是由评论ID、评论时间或者其他唯一标识符组成的字符串。
在这个hash中，我们可以存储以下字段：
comment_id: 评论的唯一标识符。comment_text: 评论的文本内容。user_id: 评论者的用户ID。timestamp: 评论的时间戳。 对于数据格式类型，我们可以使用Redis的默认字符串类型来存储这些字段。例如，comment_text和user_id可以使用字符串类型存储，而timestamp可以使用时间戳类型存储。
此外，我们还可以使用Redis的list类型来存储一组评论。可以将所有评论按照时间戳排序，并将它们存储在一个list中。这样，我们可以通过获取指定时间戳范围内的评论来分页获取评论列表。
需要注意的是，在存储评论时，我们需要确保每条评论的唯一性，以便在添加新评论时不会覆盖已有的评论。此外，我们还需要定期清理过期的评论，以避免占用Redis的存储空间。
4、用redis实现博客系统的评论缓存,怎么和数据库保持一致 使用Redis实现博客系统评论缓存时，需要与数据库保持一致，以确保数据的一致性和完整性。以下是几个方面可以考虑：
1、缓存评论的写入操作
当用户发表评论时，应该先将评论写入数据库，然后再将评论写入Redis缓存。这样可以保证数据库和Redis缓存中的数据是一致的。在写入Redis缓存时，可以使用Redis的SET命令将评论存储在对应的hash中。
2、缓存评论的读取操作
当用户访问评论列表或查看评论详情时，应优先从Redis缓存中读取数据。如果Redis缓存中存在该评论，则直接返回该评论；如果Redis缓存中不存在该评论，再去数据库中查询并返回数据。为了避免每次查询都直接访问数据库，可以将查询结果也存储在Redis缓存中，以加速后续的读取操作。
3、缓存评论的更新操作
当用户对评论进行回复或点赞等操作时，应该先更新数据库中的评论数据，然后再更新Redis缓存中的数据。这样可以保证数据库和Redis缓存中的数据是最新的。在更新Redis缓存时，可以使用Redis的HSET命令更新对应hash中的评论数据。
4、缓存评论的过期处理
为了保证Redis缓存中不会存储过期的评论数据，需要定期清理Redis缓存。可以使用Redis的HDEL命令删除已经过期的评论数据。同时，也需要同步清理数据库中的过期评论数据。
总之，在用Redis实现博客系统评论缓存时，需要保证数据库和Redis缓存中的数据一致性。通过合理的操作顺序和定期清理过期数据，可以确保数据的一致性和完整性。
5、用redis实现博客系统的评论缓存,如何实现持久化 Redis提供了持久化机制，可以将数据保存到磁盘中，以保证数据在Redis服务器重启后仍然可以恢复。在实现博客系统评论缓存的持久化时，可以采用以下两种方式：
1、RDB（Redis DataBase）持久化
RDB持久化是通过生成数据快照的方式来保存数据。Redis可以在指定的时间间隔内，将内存中的数据生成一个二进制文件，通常是一个名为dump.rdb的文件。这个文件可以用来在服务器重启后恢复数据。
为了实现RDB持久化，可以配置Redis在指定的时间间隔内执行bgsave命令来生成数据快照。同时，需要配置Redis在启动时自动加载dump.rdb文件，以恢复数据。
2、AOF（Append Only File）持久化
AOF持久化是通过记录Redis的所有写操作命令到一个追加日志文件（append only file）中来实现持久化。在Redis服务器启动时，会通过回放这些写操作命令来恢复数据。
为了实现AOF持久化，可以配置Redis使用appendonly.aof文件来记录写操作命令。同时，需要配置Redis在启动时自动加载appendonly.aof文件，以恢复数据。
需要注意的是，在持久化过程中，可能会对Redis的性能产生一定的影响。因此，需要根据实际情况选择适合的持久化方式，并调整相关参数以获得最佳性能。
6、用redis实现基于springboot的博客系统缓存，要怎么设计事务？ 在基于Spring Boot和Redis实现的博客系统缓存中，事务的设计主要关注的是如何确保数据的一致性和可靠性。以下是一种设计事务的思路：
配置Redis事务：
在Spring Boot项目中，使用RedisTemplate或StringRedisTemplate类来操作Redis。设置Redis事务的超时时间，以防止长时间占用Redis资源。通过事务传播属性来配置事务的传播行为，例如，使用PROPAGATION_REQUIRED表示当前方法必须在一个事务中运行。 封装评论相关的事务操作：
创建一个评论相关的服务类，例如CommentService，用于封装评论的增删改查操作。在服务类中，使用RedisTemplate或StringRedisTemplate类来执行Redis事务。将发表评论、更新评论和删除评论等操作封装成事务方法，例如saveComment、updateComment和deleteComment等。 设计评论缓存的事务逻辑：
在saveComment方法中，首先将评论写入数据库，然后将评论数据存储到Redis缓存中。在updateComment方法中，首先更新数据库中的评论数据，然后更新Redis缓存中的评论数据。在deleteComment方法中，首先删除数据库中的评论数据，然后删除Redis缓存中的评论数据。 处理事务异常：
在事务方法中，使用try-catch语句捕获可能出现的异常，例如RedisException、DataAccessException等。如果出现异常，则回滚事务，撤销已经执行成功的命令。如果事务执行成功，则返回成功结果给调用者。 优化事务性能：
考虑使用批量操作来减少与Redis的通信开销。考虑使用管道化操作来提高事务的执行效率。根据实际情况调整Redis的事务队列长度和超时时间等参数。 监控和日志记录：
监控Redis事务的执行情况，例如事务的开始时间、结束时间和执行结果等。记录Redis事务的日志信息，以便在出现问题时进行排查和分析。 通过以上设计，可以实现基于Spring Boot和Redis的博客系统缓存的事务管理，确保数据的一致性和可靠性。
7、基于springboot的博客系统怎么进行登录模块的设计，怎么回答？ 需求分析：首先，你需要明确系统需要提供哪些功能，例如用户注册、用户登录、找回密码等。在这个阶段，你需要考虑系统的安全性和用户数据的保密性。数据库设计：设计用户表，包含用户名、密码、电子邮件等字段。在这个阶段，你需要考虑密码的加密存储方式，如使用哈希算法对密码进行加密。认证管理器：创建一个AuthenticationManager类，继承自AbstractAuthenticationManager，实现用户认证逻辑。在该类中，你需要实现用户信息的验证和密码的解密操作。认证服务：创建一个AuthenticationService类，用于处理用户登录请求。在该类中，你需要注入AuthenticationManager类的实例，并调用其authenticate方法进行用户认证。控制器：创建一个LoginController类，用于处理登录请求。在该类中，你需要注入AuthenticationService类的实例，并调用其login方法进行用户认证。如果认证成功，将用户信息保存到Session中，并重定向到博客首页；如果认证失败，返回错误信息给前端页面。前端页面：创建一个登录页面，包含用户名和密码输入框以及登录按钮。在该页面上设置表单的action属性为"/login"，method属性为"post"，将登录请求发送到服务器端。安全配置：在Spring Boot主配置类中添加安全配置，如设置跨域访问、限制IP等。 在回答问题时，你需要重点突出你在设计登录模块时对安全性和数据保密性的考虑，例如使用哈希算法对密码进行加密、使用Session保存用户信息等。同时，你还可以强调你在设计过程中考虑到系统的可扩展性和可维护性，例如使用Spring Boot提供的注解和组件进行模块化设计和可测试性等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c53b7a6bfc45b117a705cf693f936d18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4c2636a6b7a42b6d13ab10775f33352/" rel="bookmark">
			Qt中串口模块的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		串口模块介绍 1、简介 在Qt的拓展模块中，Qt提供了许多的结果通讯模块，有串口、can、 ModBus等。下面就简单介绍一些Qt中的串口模块。
Qt串口提供基本功能，包括配置、I/O操作、获取和设置RS-232引脚的控制信号。
Qt串口模块不支持以下功能：
终端功能，如回声、控制CR/LF等。
文本模式。
配置读取或写入时的超时和延迟。
引脚输出信号更改通知。
特殊收发器条件，如帧错误、奇偶校验错误和中断条件错误。
2、包含类 在Qt串口模块中主要使用的类有两个：
QSerialPort提供访问串行端口的功能QSerialPortInfo提供有关现有串行端口的信息 串口模块使用 串口的使用步骤如下：
1、在项目中引入串口模块
QT += serialport 2、添加串口类相关头文件
#include &lt;QSerialPort&gt; #include &lt;QSerialPortInfo&gt; 3、使用QSerialPortInfo中的静态文件获取设备中的串口信息。availablePorts()函数返回的是一个串口信息的列表。
foreach(const QSerialPortInfo &amp;Info, QSerialPortInfo::availablePorts()) { //读取串口信息 m_serialPort-&gt;setPort(Info); if( m_serialPort-&gt;open(QIODevice::ReadWrite) ) { portnames.append(Info.portName()); m_serialPort-&gt;close(); } } 4、创建一个QSerialPort类对象，使用通过availablePorts()函数获取的串口信息，设置需要打开的串口号、波特率、校验位等一些串口信息。设置的函数如下：
boolsetBaudRate(qint32 baudRate, QSerialPort::Directions directions = AllDirections)设置波特率boolsetBreakEnabled(bool set = true)boolsetDataBits(QSerialPort::DataBits dataBits)设置数据位boolsetDataTerminalReady(bool set)boolsetFlowControl(QSerialPort::FlowControl flowControl)设置流量控制模式boolsetParity(QSerialPort::Parity parity)设置校验模式voidsetPort(const QSerialPortInfo &amp;serialPortInfo)voidsetPortName(const QString &amp;name)设置串口号voidsetReadBufferSize(qint64 size)设置读写缓存区大小boolsetRequestToSend(bool set)设置保持线路信号RTS的状态（高或低）boolsetStopBits(QSerialPort::StopBits stopBits)设置停止位 5、设置完各种参数之后就可以打开串口了，打开串口使用serialPort类中的open函数。此函数需要传入一个权限控制：读、写、读写等。
bool MySerialPort::openSeriaPort(QSerialPort::OpenMode openmode){ return m_serialPort-&gt;open(openmode); } 6、在Qt中使用QSerialPort::readyRead信号通知程序有数据上来。之后程序在使用readAll()函数获取缓存区中数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4c2636a6b7a42b6d13ab10775f33352/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9192342807c85dd0e6c5065677bceb96/" rel="bookmark">
			【安装】自建Rustdesk Server
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 RustDesk说明RustDesk优点RustDesk相关链接非Docker基于CentOSRustDesk默认程序占用端口说明 启动 hbbr 是中继服务器启动 hbbs 是ID服务器客户端配置编写启动脚本hbbr、hbbs命令详细说明 RustDesk说明 RustDesk优点 自建服务端。搭建在自己的云服务器就相当于独享高速带宽！点对点通信。TCP隧道功能一旦打洞成功，相当于用户之间直连，不走服务器带宽！信加密。配置公钥后，必须拥有公钥才能正常使用！内置文件传输。得益于点对点通信，文件传输不也是手到擒来嘛！ RustDesk相关链接 官方介绍：https://rustdesk.com/zh/
服务下载地址：https://github.com/rustdesk/rustdesk-server/releases
客户端下载地址：https://rustdesk.com/zh/ 支持IOS、Mac、Windows、Android、Linux等等！
非Docker基于CentOS [root@VM-4-14-centos rustdesk]# tree . └── amd64 ├── db_v2.sqlite3 ├── db_v2.sqlite3-shm ├── db_v2.sqlite3-wal ├── hbbr ├── hbbs ├── id_ed25519 （一开始不会有这个文件，启动后会自动生成，如需更换删除重启服务） ├── id_ed25519.pub （一开始不会有这个文件，启动后会自动生成，如需更换删除重启服务） └── rustdesk-utils RustDesk默认程序占用端口说明 hbbs是ID/Rendezvous 服务器。默认监听：21115(tcp), 21116(tcp/udp), 21118(tcp)
hbbr是中继服务器。默认监听：21117(tcp), 21119(tcp)
如果只需要基本的远程控制： 请注意21116同时要开启TCP和UDP。
其中21115是hbbs用作NAT类型测试（无需开启，不用关注）
hbbs：21116/UDP是hbbs用作ID注册与心跳服务，21116/TCP是hbbs用作TCP打洞与连接服务
hbbr：只用TCP。21117是hbbr用作中继服务使用。21118、21119是为了支持网页客户端。如果您不需要网页客户端（21118，21119）支持，端口可以不开。
总结：hbbs需要指定端口用于客户端的ID服务器、hbbr用于中继服务器。
启动 hbbr 是中继服务器 修改hbbr默认端口为 21117 -&gt; 36001（注意要去云安全组、服务器系统防火墙方形哦 注意是TCP即可）
-k 是加密 参数使用固定的_ 公钥在id_ed25519.pub文件中。秘钥你也可以自定义字符串哦
nohup ./hbbr -p 36001 -k _ &gt; hbbr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9192342807c85dd0e6c5065677bceb96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4914dcec005527521d753a084ef2e948/" rel="bookmark">
			nginx转发接口一会正常一会返回404.html
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用nginx(版本是1.24.0)转发时，出现了api接口一会正常返回，一会返回 404.html的情况。
以下是我的nginx配置：
nginx.conf
#user nobody; worker_processes 1; #error_log logs/error.log; #error_log logs/error.log notice; #error_log logs/error.log info; pid logs/nginx.pid; events { worker_connections 1024; } http { include conf.include/gateway-upstream.conf; include mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] "$request" ' '$status $body_bytes_sent "$http_referer" ' '"$http_user_agent" "$http_x_forwarded_for"'; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server { listen 8080; server_name localhost; #charset koi8-r; access_log logs/host.access.log main; error_page 404 /404.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4914dcec005527521d753a084ef2e948/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/47/">«</a>
	<span class="pagination__item pagination__item--current">48/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/49/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>