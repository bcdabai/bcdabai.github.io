<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f034641ab80e7d29898eccfdf0773f21/" rel="bookmark">
			tensorflow 数据读取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TensorFlow常见的数据读取方式分为3类：
1. placeholder+feeding
2. QueueRunner
3. dataset
其中第三种方式是目前的主流，但前2种方法，尤其是第二种方法我认为了解一下对于理解他人的代码是有帮助的：
1. placeholder+feeding 简单地说就是用Python程序处理好相关的数据，然后将整理好的数据通过placeholder+feed_dict的方式直接将数据喂给模型，这种方法感觉比较慢，适合小模型，小数据：
def data_in_fn(): return np.array(xxx) with tf.Session() as sess: sess.run(train_op, feed_dict={in_:data_in_fn()}) 2. QueueRunner 这个方案是基于队列的形式构建的输入输入通道，简单地说就是构建一个文件名队列，一个内存队列，如下图所示，文件名队列中存储所有的文件名数据，如果设置了epoch，shuffle等信息，则会体现在文件名队列中，比如有3个文件，名字为A,B,C，当epoch=2，shuffle=True时，文件名队列可能的顺序为CBAACB这样，内存队列始终根据FIFO的原则，从队列的头部读取下一个文件的名字，然后放到内存中。
构建的步骤如下：
首先，文件列表就是需要处理的文件的名字，可以使用Python的list，然后使用接口 tf.train.string_input_producer 将该列表创建成一个FIFO的队列，此接口可以设置是否要shuffle文件名列表，设置想要多少个epoch，但要注意，shuffle只是调整一个epoch的文件顺序，比如文件有A,B,C三个，想要2个epoch，那么shuffle之后不可能出现ABBCCA这种情况情况，因为对于第一个epoch中，出现了2个B。
第二，TensorFlow给出了几个我们常用的格式的reader和decode，分别处理：text（CSV）格式，二进制文件（读取固定长度字节数信息），tfrecord格式的文件。三组接口分别是：
filename_queue = ['文件1', '文件2'] # 处理text和CSV read 方法每执行一次，会从文件中读取一行。然后 decode_csv 将读取的内容解析成一个Tensor列表 reader = tf.TextLineReader() key, value = reader.read(filename_queue) record_defaults = [[1], [1], [1], [1], [1]] col1, col2, col3, col4, col5 = tf.decode_csv(value, record_defaults=record_defaults) # 处理二进制 record_bytes = label_bytes + image_bytes # 读取固定长度字节数信息(针对bin文件使用FixedLengthRecordReader读取比较合适) reader = tf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f034641ab80e7d29898eccfdf0773f21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1796a98cd36dad7abad5dbd943712f3f/" rel="bookmark">
			Games101课程笔记_lecture21_动画与模拟
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Games101课程笔记_lecture21_动画与模拟 1 history1 动画是什么？2 历史 2 keyFrame animation1 什么是关键帧2 关键帧技术 3 物理模拟1 物理模拟的概念。2 Mass Spring System 质点弹簧系统1 例子：2 概念 3 粒子系统 4 Kinematics运动学1 正向运动学2 逆运动学 5 Rigging6 动作捕捉7 现代化动画电影产业8 视频 整个课程讲了光栅化，几何，光线传播，动画/模拟/仿真。前面的课程都是静态的，运动的物体如何做呢？
1 history 1 动画是什么？ 让物体动起来。
美学问题
几何的扩展。
每一帧有不同的图，3D的一张图在时间上做个扩展。
电影:24帧/s
视频：
虚拟现实：90fps。不晕的话需要达到90。
游戏：144
2 历史 远古：
1831
电影:1878年
最早的电影是做科学研究的，并不是来娱乐的。
完整长度，手绘的。
24*
1963年。
1872年：
1972年
1993年。
整个电影都是电脑生成的—玩具动员–光栅化。1995
2009年
冰雪奇缘2 2019年
2 keyFrame animation 1 什么是关键帧 关键帧定义一个动画的走向
最厉害的艺术人画关键帧，中间的帧让其他人画。
flash–自动生成中间的过渡帧。
自动化生成中间的过程—是个方向。
最简单的动画技术
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1796a98cd36dad7abad5dbd943712f3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d196199a5535ef2a7ed90ae08ad915a/" rel="bookmark">
			串的置换操作Replace(&amp;S,T,V)的算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原文链接
编写一个实现串的置换操作Replace(&amp;S,T,V)的算法。
StringType是串的一个抽象数据类型，它包含以下6种基本操作：
void InitStr(StringType &amp;s); // 初始化s为空串。 void StrAssign(StringType &amp;t, StringType s); // 将s的值赋给t。s的实际参数是串变量。 int StrCompare(StringType s, StringType t); // 比较s和t。若s&gt;t，返回值&gt;0；若s=t，返回值=0；若s&lt;t，返回值&lt;0。 int StrLength(StringType s); // 返回s中的元素个数，即该串的长度。 StringType Concat(StringType &amp;s, StringType t); // 返回由s和t联接而成的新串。 StringType SubString(StringType s, int start, int len); // 当1&lt;=start&lt;=StrLength(s)且0&lt;=len&lt;=StrLength(s)- start+1时， // 返回s中第start个字符起长度为len的子串，否则返回空串。 实现函数如下：
void Replace(StringType &amp;S, StringType T, StringType V) //以串 v 置换串 s 中出现的所有和串 t 相同的非空串 { int n,m,k,i; StringType sub; InitStr(sub); n = StrLength(S); m = StrLength(T); k = StrLength(V); i = 1; while(i &lt;= n-m+1){ //将串S中的子串逐个提取出来与串T进行匹配 StrAssign(sub,SubString(S,i,m));//将串S中的子串赋值给sub if(StrCompare(sub,T) == 0){//sun和T匹配相等时 InitStr(sub);//初始化sub Concat(sub,SubString(S,1,i-1));//将匹配相等的子串的前面的子串连接到串sub后 Concat(sub,V);//将替换串连接到串sub后 Concat(sub,SubString(S,m+i,n-(m+i)+1));//将匹配相等的子串的后面的子串连接到串sub后 StrAssign(S,sub);//将sub赋值给S i += k;//从匹配串之后的一个位置重新开始匹配 n = StrLength(S);//操作完一次之后，串S已经改变，更新S的长度 } else {//如果不匹配，就i向后移动 i++; } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3475d4ed321110cca009f5ec1b925cd9/" rel="bookmark">
			前端技术：Webpack 工程化最佳实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、引言 1. 前端构建工具的演变
回想在 2015-2016 年的时候，开发者们开始渐渐把视线从大量使用 Task Runner 的 Grunt 工具，转移到 Gulp 这种 Pipeline 形式的工具。Gulp 还可以配合上众多个性化插件（如 gulp-streamify），从而使得整个前端的准备工作链路，变得清晰易控，如刷新页面、代码的编译和压缩等等。自动化“流水线”工具取代了很多繁杂的手动工作，可以说，是具有跨时代意义的。之于 Webpack 而言，其本质是是基于“模块化”思想的一个“JS 预编译”解决方案，诞生初期，和其相似的方案还有 Browserify，和 Webpack 属于同门不同派别的还有 sea.js 或 require.js，这二者需“在线依赖”解释器编译。
时至今日，多数日常工作接触的项目，已经可以完全的舍弃 Gulp 了。但工作中有时还会接触一些老项目，其中 Gulp 的使用和维护屡见不鲜。2019 年初之时，通过一个老项目（gulp 3.x + webpack 3.x）的技术升级，借机了解了 gulp 4.x 的动态，又不禁让人回想起 gulp-browserify，和 gulp-webpack（五年前发布，目前改名为 webpack-stream）。所以，Webpack 做为某一个垂直方向的解决方案，当然可以 manaually built-in Gulp 中。在拿 Webpack“方案”和 Gulp 类“工具”去做正面比较的时候，需要明晰两者解决问题的范围和思路。如今再次回顾历史，对技术的发展演变顺序，能有一个基本客观的概念。
在 2017 年的时候，Gulp 和 Webpack 在用户的使用率和“将继续使用”的意向上，还不分伯仲。但从《State of Javascript 2019》中可以看到，Webpack 已经完全碾压了其它工具和类库，成为了首屈一指被大家广泛使用、讨论的 Build Tool。2018 年 2 月 25 日 Webpack 发布了 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3475d4ed321110cca009f5ec1b925cd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd4fcfd503028e27f8884c097d07784e/" rel="bookmark">
			UKF原理与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		卡尔曼滤波家族主要有KF、EKF、UKF三兄弟。KF主要应用于系统方程和量测方程为线性的的场景，EKF应用于轻度非线性场景，而UKF则在强非线性情况下有更好的表现。这里只介绍UKF。
在KF中，我们需要求取状态协方差来确定卡尔曼增益，但是由于系统存在非线性，只能得到它的近似值。EKF通过雅可比矩阵对系统进行线性化，而UKF则是利用随机采样的条件均值代替均值，使用被估计量和量测量的再现样本点计算两者的自协方差阵和互协方差阵( U T UT UT变换）。
UT变换 对于一维状态变量的情况，可以将这个过程看作是选取 μ x , μ x + σ x , μ x − σ x \mu_x,\mu_x+\sigma_x,\mu_x-\sigma_x μx​,μx​+σx​,μx​−σx​三个点，用非线性变换 g g g投影过去，再拟合出一个高斯分布。
U T UT UT变换的步骤如下：
假设 n n n维随机向量 X X X经 f ( ⋅ ) f(·) f(⋅)非线性变换后形成 m m m维随机向量 Y Y Y,即
Y = f ( X ) Y=f(X) Y=f(X),在已知 X X X的均值 X ˉ \bar{X} Xˉ和方差阵 P X X P_{XX} PXX​的情况下,求 Y Y Y的均值 Y ˉ \bar{Y} Yˉ和 P Y Y P_{YY} PYY​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd4fcfd503028e27f8884c097d07784e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30ba43b30b2943e5557618fa09d92840/" rel="bookmark">
			winform在设置控件enabled=false后，无法更改控件字体颜色的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下代码用于将控件禁用但不改变控件样式（字体颜色等）
[System.Runtime.InteropServices.DllImport("user32.dll")] public static extern int SetWindowLong(IntPtr hWnd, int nIndex, int wndproc); [System.Runtime.InteropServices.DllImport("user32.dll")] public static extern int GetWindowLong(IntPtr hWnd, int nIndex); public const int GWL_STYLE = -16; public const int WS_DISABLED = 0x8000000; public static void SetControlEnabled(Control c, bool enabled) { if (enabled) { SetWindowLong(c.Handle, GWL_STYLE, (~WS_DISABLED) &amp; GetWindowLong(c.Handle, GWL_STYLE)); } else { SetWindowLong(c.Handle, GWL_STYLE, WS_DISABLED + GetWindowLong(c.Handle, GWL_STYLE)); } } private void button2_Click(object sender, System.EventArgs e) { SetControlEnabled(this.button1, false); this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30ba43b30b2943e5557618fa09d92840/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e3468c332a75f7ce716c10e4a3d56e6/" rel="bookmark">
			计算机网络自顶向下方法 第三章 作业习题答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://github.com/jzplp/Computer-Network-A-Top-Down-Approach-Answer
P1
设主机A的telnet会话端口号为x，主机B的telnet会话端口号为y
a. 源端口号：x，目的端口号：23
b. 源端口号：y，目的端口号：23
c. 源端口号：23，目的端口号：x
d. 源端口号：23，目的端口号：y
e. 可能相同
f. 不可能相同
P2
服务器到客户A:
源端口号:80, 目的端口号:26145, 源IP:B, 目的IP:A
服务器到客户C，会话1:
源端口号:80, 目的端口号:7532, 源IP:B, 目的IP:C
服务器到客户C，会话2:
源端口号:80, 目的端口号:26145, 源IP:B, 目的IP:C
P3
01010011+01100110=10111001
10111001+01110100=00101110
反码为 11010001
使用反码对接收方非常方便，只需将所有数据包含校验码加起来，计算和为全1即可。
如果不是全1则说明出现了差错。
1比特的差错肯定可以检查出，2比特的差错存在检测不出的情况。
P4
a. 00111110
b. 10111111
c. 两个字节的最后一位变化: 01011101 01100100
P5
接收方不能完全确认没有比特差错，如P4c题目所示，出现多个差错时存在检测不出的情况
P6
发送方发送序号0的报文，进入等待ACK0状态。接收方收到，并且回复ACK，进入等待状态1。 回复的ACK受损了。此时发送方重传报文0，接收方收到报文0，认为序号不对，回复NAK。 发送方收到NAK，发送方重传报文0，接收方依然认为序号不对，回复NAK。
产生死锁。
P7
因为ACK和确认序号已经可以完整的标识这个分组，而且ACK的缺失会导致重传，因此最终ACK可以确保到达。
P8
与rdt2.2的接收方相同
P9
数据分组发生篡改时：
正在上传…重新上传取消
确认分组发生篡改时：
正在上传…重新上传取消
P10
如果不使用NAK，则协议正如rdt3.0所示。
如果使用NAK，则协议如下：
正在上传…重新上传取消
接收方与rdt2.1接收方相同
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e3468c332a75f7ce716c10e4a3d56e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28e2cfe15ce75a833639801f3477a448/" rel="bookmark">
			mysql的lpad函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		lpad：即left padding的简称，意思是左边填充，格式为lpad(str,len,padstr)。
参数说明：
str:要处理的对象
len:处理完后的str长度为len
padstr:如果str的长度小于len指定的值，那么长度差由padstr在左边填充；如果str的长度大于len指定的值，则截取str到len指定的长度。
返回值说明：
lpad函数返回的是处理后的str
如下几个例子简单说明下：
SELECT lpad('zhao',10,'-'); 结果：
可以看到"zhao"的长度因为是4自然就小于10，那么10-4=6，这个6的长度差就有padstr（这里是"-"）来填充。
再如：
SELECT lpad('zhao',2,'-'); 结果：
学是很好学，有什么用呢？比如现在我又这样一个需求，需要在页面上展示出某个表的创建语句，我们知道怎么在mysql里面获取一个表的创建语句“SHOW CREATE TABLE abc”即可(abc是表名),但是要求不止于此哦，页面上不仅要求显示表的创建语句，还要求格式化显示，那你可能说也不难，我语句既然已经可以取到了，使用java处理一下语句不就行了，当然可以，不过我今天不介绍也不想去想怎么样用java来处理这个格式化的问题，我如果想用mysql怎么处理呢？就像下面的这种效果：
上图中，第一列是列名，第二列是列的类型，第三列是comment,第四列是注释的内容。
分析一下，不管你的列名和列类型是什么，我们可以看到，列名+列的类型的长度总是一定的，加入这个长度总共是40个字符，那么列类型的所占据的宽度就应该是"40-length(列名)",不够的话就用空格填充，所以在处理的时候就可以用lpad函数这样子写：
select concat((case when col_no=0 then ' ' else ',' end),col_name,lpad(col_type,40-length(col_name),' ') from table_field_attr 当然，是用场景并非仅仅如此，我只是拿这个来举个例子，记住它吧，不定什么时候就能帮你省下不少时间。
同理的，还有右填充函数rpad，跟lpad用法类似，我就不赘述了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/557bd4adbaf17bca660ba1ef4b6a2dba/" rel="bookmark">
			Logstash——配置介绍，数据输入配置（input）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前介绍过如何使用文件系统通过Logstash将数据推送至elasticsearch来实现日志的线上分析 安装Logstash并完成一个简单的日志收集功能。而Logstash所支持的数据源远远不止这些，这里对Logstash的数据输入配置进行一个介绍。
Logstash——配置介绍，数据输入配置（input）
Logstash——Logstash从MySQL中收集数据并输出添加
Logstash——Logstash从Redis中收集数据并输出
Logstash配置内容 Logstash的配置主要分为三部分：数据输入部分、数据处理部分、数据输出部分。这三部分的定义覆盖了数据整个的生命周期。这一篇主要介绍数据输入部分
数据输入 数据输入部分的配置定义在input内容下
一个简单的示例
input { stdin {} syslog {} } 支持的数据来源 Logstash提供了一个非常长的数据来源支持列表，目前最新版的Logstash可以从下面渠道里面获得数据
输入插件支持内容azure_event_hubs从Azure事件中心接收事件beats从Elastic Beats框架接收事件cloudwatch从Amazon Web Services CloudWatch API提取事件couchdb_changes从CouchDB的_changesURI 流事件dead_letter_queue从Logstash的死信队列中读取事件elasticsearch从Elasticsearch集群读取查询结果exec将shell命令的输出捕获为事件file从文件流事件ganglia通过UDP读取Ganglia数据包gelf从Graylog2读取GELF格式的消息作为事件generator生成用于测试目的的随机日志事件github从GitHub Webhook读取事件google_cloud_storage从Google Cloud Storage存储桶中的文件中提取事件google_pubsub消费来自Google Cloud PubSub服务的事件graphite从graphite工具读取指标heartbeat生成心跳事件以进行测试http通过HTTP或HTTPS接收事件http_poller将HTTP API的输出解码为事件imap从IMAP服务器读取邮件irc从IRC服务器读取事件java_generator生成综合日志事件java_stdin从标准输入读取事件jdbc从JDBC数据创建事件jms从Jms Broker读取事件jmx通过JMX从远程Java应用程序检索指标kafka读取来自Kafka主题的事件kinesis通过AWS Kinesis流接收事件log4j从Log4j SocketAppender对象通过TCP套接字读取事件lumberjack使用Lumberjack协议接收事件meetup将命令行工具的输出捕获为事件pipe从长时间运行的命令管道流式传输事件puppet_facter接收来自Puppet服务器的事件rabbitmq从RabbitMQ交换中提取事件redis从Redis实例读取事件relp通过TCP套接字接收RELP事件rss将命令行工具的输出捕获为事件s3从S3存储桶中的文件流式传输事件s3_sns_sqs使用sqs从AWS S3存储桶读取日志salesforce根据Salesforce SOQL查询创建事件snmp使用简单网络管理协议（SNMP）轮询网络设备snmptrap根据SNMP陷阱消息创建事件sqlite根据SQLite数据库中的行创建事件sqs从Amazon Web Services简单队列服务队列中提取事件stdin从标准输入读取事件stomp创建使用STOMP协议接收的事件syslog读取系统日志消息作为事件tcp从TCP套接字读取事件twitter从Twitter Streaming API读取事件udp通过UDP读取事件unix通过UNIX套接字读取事件varnishlog从varnish缓存共享内存日志中读取websocket从网络套接字读取事件wmi根据WMI查询的结果创建事件xmpp通过XMPP / Jabber协议接收事件 常用数据来源配置 Logstash提供了足够多的数据来源，这里只介绍一些平时使用量会比较多的数据渠道
读取文件(File) 从文件中流式传输事件，通常以类似于tail -0F但可选地从头开始读取它们。Logstash 使用一个名叫 FileWatch 的 Ruby Gem 库来监听文件变化。而且会记录一个叫 .sincedb 的数据库文件来跟踪被监听的日志文件的当前读取位置。
这是一个完全的示例：
input file { # 日志文件地址 path =&gt; ["/var/log/*.log", "/var/log/message"] # 默认一小时 close_older =&gt; 3600 # 设置新行分隔符，默认为“ \ n”。 delimiter =&gt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/557bd4adbaf17bca660ba1ef4b6a2dba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9590e124cda8f7d8e84a4e81cbcb657f/" rel="bookmark">
			Android之NavigationView（抽屉导航）的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先上效果图：
现在很多软件都使用到了抽屉导航，它能实现侧滑，也可称为侧滑菜单。它能够使界面更加简洁，简单明了，接下来就用这个案例来敲代码吧！
抽屉导航的头部布局:
head.xml
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent" android:gravity="center" android:padding="8dp"&gt; &lt;ImageView android:layout_width="wrap_content" android:layout_height="wrap_content" android:src="@mipmap/ic_launcher"/&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="textView"/&gt; &lt;/LinearLayout&gt; 在这个案例里,我在抽屉导航里写了一个菜单资源引入
menu菜单的写法:
首先要在res资源文件夹下新建一个menu文件夹,然后再这个文件夹里写相关的代码,如图:
menu1:
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;menu xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:icon="@mipmap/img01" android:title="财富管理" /&gt; &lt;item android:icon="@mipmap/img02" android:title="生活管理" /&gt; &lt;item android:icon="@mipmap/img03" android:title="开开心心" /&gt; &lt;item android:icon="@mipmap/img04" android:title="快快乐乐" /&gt; &lt;/menu&gt; 主界面的布局：
activity_navigation_view.xml
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;androidx.drawerlayout.widget.DrawerLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" xmlns:app="http://schemas.android.com/apk/res-auto" tools:context=".NavigationViewActivity"&gt; &lt;!--在打开抽屉导航前能看到的布局都写在这个LinearLayout里面--&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="match_parent" android:background="#FFEEB5" android:gravity="center"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9590e124cda8f7d8e84a4e81cbcb657f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95f21c79d430c4ed96fb49badb6cec27/" rel="bookmark">
			ros的插件库 pluginlib 的简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 Getting ready
2 Create a Base Class
3 Create the Plugins
4 Registering the Plugins
5 Building the Plugin Library
6 Making the Plugins Available to the ROS Toolchain
6.1 The Plugin XML File
6.2 Exporting Plugins
7 Using a Plugin
8 Running the Code
1 Getting ready First, install pre-made pluginlib_tutorials pkg by doing the following where %ROS_DISTRO% can be {fuerte, groovy,hydro,indigo,jade} etc.:
$ apt-get install ros-%ROS_DISTRO%-common-tutorials
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95f21c79d430c4ed96fb49badb6cec27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70f5fe10b36c9b02c4bbddc12a066785/" rel="bookmark">
			node-pre-gyp WARN Using needle for node-pre-gyp https download 错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 windows上安装bcrypt加密npm总是报node-pre-gyp WARN Using needle for node-pre-gyp https download错误 1. 可以用淘宝镜像cnpm（不推荐） 注意尽量不要用淘宝镜像cnpm，因为cnpm总是出现一些莫名其妙的bug，到时候改都改不了的 2.可以替代bcryptjs npm install bcryptjs --save 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e56980f6a32a4a4bd34cd97e33c18543/" rel="bookmark">
			logstash-input-http用户名和密码方式请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		logstash.conf配置
input { http { # 类型，用于判断 type =&gt; "desktop_message" host =&gt; "68.61.113.52" port =&gt; "9601" # 请求头用户名、密码验证 #需要在请求头加上参数：Authorization #参数值Basic Base64("user:password")：Basic ZGVza3RvcF9tZXNzYWdlOmRlc2t0b3BfbWVzc2FnZQ== user =&gt; "desktop_message" password =&gt; "desktop_message" } } filter { if [type] == "desktop_message" { mutate { # 移除不需要的字段 remove_field =&gt; ["headers","host"] } } } output { if [type] == "desktop_message" { elasticsearch { # es地址，多个逗号隔开 hosts =&gt; ["localhost:9200"] # 账号 #user =&gt; "" # 密码 #password =&gt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e56980f6a32a4a4bd34cd97e33c18543/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2fe6845e5143bb7c55b2dbf1ce13af8/" rel="bookmark">
			通过切面记录业务日志记录的一种模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 我们在做业务系统研发的时候，总会有这种需求，用户做了哪些操作、修改了哪些数据都需要记录下来，有没有一种通用的方式来记录业务日志并且与业务逻辑解耦，今天我们就来讲一种通过切面来记录日志的一种方式，并通过约定对开发流程定一些基本的规范来达到减少硬编码的目的。
原理 1、【客户端】提交的内容都是变更内容的核心参数，非变更内容不提交。所有修改操作 Request Body 需要绑定 提交前的变更内容快照。
2、【服务端】通过自定义注解 + 拦截器方式，解析参数并模板化变更内容。
规范 1、注解 @ApiLog 标记
【服务端】所有修改操作(新增/修改/删除/上线/下线/…)的Controller方法上，都需要标记 @ApiLog 。只有带上 @ApiLog 拦截器才能识别，并保存操作记录。示例如图一：
图一
ApiLog，包含两个属性，name 表示操作名称，act 表示操作动作。所有返回 Result 都需要 带上 withId 。因为这里离ID最近，因此也最方便。如果要在拦截器中萃取，判断太多。因此，在这里统一加上。 2、新增/修改POST提交
a、【客户端】所有新增/修改操作都必须是POST的提交方式为RequestPayload。Content-Type: application/json
b、【客户端】所有修改操作提交，只需要提交变更参数和对应的主键ID。
c、【服务端】Controller 方法入参只能有1个 RequestBody，且必须继承 BaseDO 基类。
3、修改操作须绑快照
1、【客户端】客户端提交修改操作时，需要在 Request Body 中绑定 snapshot 参数和值。snapshot的值表示修改提交之前的快照。格式和外面保持一致。如图所示：
图二
图三
图四
4、入库结果示例
其中 request_params 为提交入库参数模板化内容。
解析request_params字段，需要根据两个参进行判断：操作类型(日志) 和 参数形式(日志)
当 action_type = 修改 且 param_type = Body 时，内容如：[{“after”:“aiqiyi211”,“before”:“aiqiyi111”,“key”:“apk包名”}]，前后记录都有了。
其他情况，内容如：[{“key”:“ID”,“value”:9}]
《通过切面记录日志》
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f1fc964ce3b58fe5ddabff8d7d87dec/" rel="bookmark">
			C&#43;&#43; 实现 实例分割（Mask_RCNN-81类）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在
https://github.com/matterport/Mask_RCNN
下载《Mask_RCNN-master》，并下载训练权重（mask_rcnn_coco.h5）。
然后安装 Keras 2.0.8。pycocotools 就不用装了。
由于我的TensorFlow 是1.0 &lt;1.3，所以按提示修改一二处Keras 中的代码，就可以运行了。
流程图：
这 张图算是比较全了。
C++运行流程：
正在从二进制文件载入‘Mask_RCNN模型’的数据 载入完成 载入模型用时：0.703 秒 生成5层金字塔特征... 输入图像宽度：314 高度：208 预处理... 缩放比:1.42675 窗口(window):75,0,372,448 宽，高，深度：448,448,3 首层... 宽，高，深度：224,224,64 宽，高，深度：112,112,64 组2... 宽，高，深度：112,112,256 组3... 宽，高，深度：56,56,512 组4... 23... 宽，高，深度：28,28,1024 组5... 宽，高，深度：14,14,2048 宽，高，深度：14,14,2048 生成5层融合金字塔特征... p2 宽，高，深度：112,112,256 p5 宽，高，深度：14,14,256 p6 宽，高，深度：7,7,256 p3 宽，高，深度：56,56,256 p4 宽，高，深度：28,28,256 回归候选区前、背景分类和位置修正... fpn_p2... rpn_model 输入的 宽，高，深度：112,112,256 宽，高，深度：112,112,512 宽，高，深度：112,112,6 rpn_class_logits 输出的 宽，高，深度：2,37632,1 宽，高，深度：112,112,12 rpn_bbox 输出的 宽，高，深度：4,37632,1 size：50127 fpn_p3... rpn_model 输入的 宽，高，深度：56,56,256 宽，高，深度：56,56,512 宽，高，深度：56,56,6 rpn_class_logits 输出的 宽，高，深度：2,9408,1 宽，高，深度：56,56,12 rpn_bbox 输出的 宽，高，深度：4,9408,1 fpn_p4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f1fc964ce3b58fe5ddabff8d7d87dec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98d9fee508f783a22e0b692db844e580/" rel="bookmark">
			Docker进入容器报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 docker命令进入容器时发生如下错误：OCI runtime exec failed: exec failed: container_linux.go:349: starting container process caused “exec: “bash”: executable file not found in $PATH”: unknown
以管理员身份运行
windows: 右键桌面docker desktop，以管理员身份运行
linux: 命令前添加sudo
使用sh命令替换bash
docker exec -it container-name sh 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e23b14459018a693a3ae9df9cf2f6d2/" rel="bookmark">
			golang时间格式化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package main import ( "fmt" "time" ) func main() { t := time.Now() //2019-07-31 13:55:21.3410012 +0800 CST m=+0.006015601 fmt.Println(t.Format("20060102150405")) //当前时间戳 t1 := time.Now().Unix() //1564552562 fmt.Println(t1) //时间戳转化为具体时间 fmt.Println(time.Unix(t1, 0).String())　//2020-03-26 00:04:37 +0800 CST //基本格式化的时间表示 fmt.Println(time.Now().String()) //2019-07-31 13:56:35.7766729 +0800 CST m=+0.005042501 fmt.Println(time.Now().Format("2006-01-02")) //2019-07-31 fmt.Println(time.Now().Format("2006-01-02 15:04:05")) //2019-07-31 13:57:52 //获取第几周 _, week := time.Now().ISOWeek() //获取年、月、日 year, month, day := rwTools.DateYmdInts() } // 时间戳转年月日 时分秒 func DateFormat(timestamp int) string { tm := time.Unix(int64(timestamp), 0) return tm.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e23b14459018a693a3ae9df9cf2f6d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b658a2cf2ae6e6a127eac81f2b68d8b0/" rel="bookmark">
			Java基础之多线程学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进程和线程 进程可以简单的理解为一个可以独立运行的程序单位，它是线程的集合，进程就是有一个或多个线程构成的。而线程是进程中的实际运行单位，是操作系统进行运算调度的最小单位。可理解为线程是进程中的一个最小运行单元。
进程和线程是包含关系，但是多任务既可以由多进程实现，也可以由单进程内的多线程实现，还可以混合多进程＋多线程。
和多线程相比，多进程的缺点在于：
创建进程比创建线程开销大，尤其是在Windows系统上；进程间通信比线程间通信要慢，因为线程间通信就是读写同一个变量，速度很快。 而多进程的优点在于：
多进程稳定性比多线程高，因为在多进程的情况下，一个进程崩溃不会影响其他进程。而在多线程的情况下，任何一个线程崩溃会直接导致整个进程崩溃。 Java多线程编程的特点又在于：
多线程模型是Java程序最基本的并发模型；后续读写网络、数据库、Web开发等都依赖Java多线程模型。 普通方法调用和多线程 继承Thread类 //创建线程方式之一：继承Thread类，重写run()方法，调用start()开启线程 //线程不一定立即执行，CPU安排调度 public class TestThread1 extends Thread { @Override public void run() { //run方法线程体 for (int i = 0; i &lt; 20; i++) { System.out.println("我在看代码" + i); } } public static void main(String[] args) { //main线程，主线程 //创建一个线程对象 TestThread1 testThread1 = new TestThread1(); //调用start()方法开启线程 testThread1.start(); for (int i = 0; i &lt; 20; i++) { System.out.println("我在学多线程" + i); } } } 实现runnable接口 //创建线程方法2：实现runnable接口，重写run方法，执行线程需要丢入runnable接口实现类，调用start方法 public class TestThread2 implements Runnable{ @Override public void run() { //run方法线程体 for (int i = 0; i &lt; 200; i++) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b658a2cf2ae6e6a127eac81f2b68d8b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b999d16d5bc33270d7e5b0e17deb9147/" rel="bookmark">
			深信服SCSA认证过程记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本次主要是记录一下深信服SCSA认证的全过程。由于本人是公司安排培训，所以可能跟自主报名的部分流程不一致。
首先是考前测试部分。
考前会进行一次简单测试。内容大致如下：
1、报名之后会受到链接，需要先确认是否能参加考试，不会立即进入考试界面，确认之后可以自主选时间参加测试。
2、测试是在牛客网上进行的，一共100题，需在100分钟内完成作答，答对60%即可过关，还是比较简单的。
3、测试的内容主要包括两个部分。一是网络相关的基础知识，即网络基础、协议基础、Windows、Linux，这部分大概占了考题的90%。个人认为难点主要集中在LLS VPN、DNS、Linux的命令（题目不多，但考得比较细）；二是深信服的产线的相关知识，主要测试AC、NGAF、SSL VPN的了解，题目相对简单，大致了解功能和部署即可。
第二个是培训前的缴费部分。
通过测试之后会进入一个微信班群，在群里会指导如何进行缴费。费用包括：4500培训费+500考试费+500保证金。缴费方式是通过支付宝或者微信二维码转账给培训公司的老师。
培训费我是使用全价券报销，考试费先自费，保证金在培训之后会返还给我们。这里需要注意一点，即所有缴费凭证请保留好，后期如果退保证金出问题的时候比较好处理。
第三个是培训过程部分。
1、整个培训中，课前点到（早上、中午各一次），课中会不定期点名、提问，多次点到未到的会扣除部分保证金（一般不过分都不会扣的）。
2、培训需脱产学习，工作的同事需提前跟上级沟通好，培训过程中遇特殊情况可请假。
3、培训为期七天，每天时间安排为：
上午 9:00-12:00
下午 13:30-17:30
晚上19:00-21:00
可以明确一点，上下午是上课，课中会讲理论知识，同时也会演示实验。
晚上的时间，用来完成作业，作业内容包括：手写作业（老师会给题目），实验截图（实验关键步骤的截图）
4、培训七天中，前两天半主要讲解理论知识，后面几天，是理论和实验穿插着进行（不过以演示实验为主）。
5、实验部分，在一个已经搭建好的线上环境进行（环境会保留两周）。使用VPN连接到环境之后，使用RDP（remote desktop）连接即可看到相关设备。
实验前老师会给指导手册，即实验整体部分的各个关键步骤截图和解释的文档，按照文档进行一般都没有问题。实验关键在于动手做，眼高手低就不太美了。
第四个部分是预约考试。
1、首先需要按照导师指引，在“安全牛”上注册并报名等一系列动作。
2、第一步完成之后会受到一份邮件，里面有自己的考生账号和初始密码，可以根据导师给的文件，打开对应网址（不一定是person VUE）。
3、登录网站之后可以自己选择附近的与深信服签约的培训机构，根据自己的情况选择时间、地点，时间可以在周末。
4、预约考试之后，也会收到邮件提醒，到时候按到到目的地考试即可。
第五部分是参加认证。（目前只写了笔试，实验部分以后再补充）
1、考试一共60题，答对40题即可通过笔试部分。
2、考试内容主要集中在深信服的业务产线部分，即AC、SSL VPN、NGAF等，这部分的题目占了90%左右，网络基础部分占比大约10%。（比重可能会根据个人气运有所偏差，但应该不会过大）
3、考完之后可以打印成绩，成绩单上会含有各个部分的答题准确率，可以根据成绩单继续查缺补漏。
4、考试内容中个人认为比较重要的：a、各种安全产品的部署模式；b、安全策略的使用和局限。
以上是简要内容，仅供参考。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/582e37640e33b8da5fbca7731840bbcb/" rel="bookmark">
			c&#43;&#43;命令行选项器的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考文献：https://blog.csdn.net/morning_color/article/details/50241987
#include &lt;iostream&gt; #include &lt;string&gt; #include &lt;boost/program_options.hpp&gt; namespace bpo = boost::program_options; int main(int argc, char const *argv[]) { //步骤一: 构造选项描述器和选项存储器 //选项描述器,其参数为该描述器的名字 bpo::options_description opts("Display all options"); //选项存储器,继承自map容器 bpo::variables_map vm; //步骤二: 为选项描述器增加选项 //其参数依次为: key, value的类型，该选项的描述 opts.add_options() ("version,v","Show version info.") ("help,h", "Show this help doc.") ("start_idx,s", bpo::value&lt;int&gt;(), "Start index") ("end_idx,e", bpo::value&lt;int&gt;(), "End index") ("visiualize",bpo::value&lt;bool&gt;(),"Is visiualize or not."); bpo::store(bpo::parse_command_line(argc, argv, opts), vm); //assert(vm.count("config") &amp;&amp; vm.count("visualize") &amp;&amp; vm.count("start") &amp;&amp; vm.count("end")); //步骤四: 参数解析完毕，处理实际信息 //count()检测该选项是否被输入 if(vm.count("help") ){//若参数中有help选项 //options_description对象支持流输出， 会自动打印所有的选项信息 std::cout &lt;&lt; opts &lt;&lt; std::endl; } if(vm.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/582e37640e33b8da5fbca7731840bbcb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fea6e3d09f764abc4b9e7db4771de0a5/" rel="bookmark">
			Unity3D-Tag 标签简介与应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unity3D-Tag 标签简介与应用 转载自Unity3D(通过Tag 标签查找物体)
1.Tag 简介 Tag 标签，就是一个标签。标签可以起到标识，区分的作用。
同一类的模型，我们可以根据需要给他们设置成统一的标签。
2.给模型添加Tag 标签 选中一个模型，在模型的Inspector 面板上的顶部位置，设置Tag 选项为一个具体的标签。如果说引擎提供的标签没有自己想要的标签，可以自己手动添加新标签。
3.通过Tag 标签查找N 个物体 GameObject.FindGameObjectsWithTag(string)：[静态方法]
通过特定的标签，查找到所有“贴有”该标签的游戏物体，返回一个数组。
String：标签名
4.for 循环输出模型信息 通过for 循环遍历FindGameObjectsWithTag（）方法返回的数组，输出游戏物体的信息。
using UnityEngine; using System.Collections; public class DeskTrigger : MonoBehaviour { private GameObject[] m_Desk; //创建一个全部游戏物件GameObject类型的数组 void Start () { m_Desk = GameObject.FindGameObjectsWithTag ("Desks"); 查找所有关于Desk标签的物件，保存到数组m_Desk /* for(int i = 0; i &lt; m_Desk.Length; i++) //遍历数组，输出物件的名称 { Debug.Log (m_Desk[i].name); } */ } void Update () { if(Input.GetKeyDown(KeyCode.Z)) { //up.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fea6e3d09f764abc4b9e7db4771de0a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4b2f6522762c5f194b0e42b30bd2aba/" rel="bookmark">
			【学习计算机组成原理】补码的乘运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 补码一位乘运算补码两位乘运算 如果看了 原码的乘运算，这篇更容易理解。 补码一位乘运算 假设：
[X]补=xn-1xn-2……x1x0
[Y]补=yn-1yn-2……y1y0
已知补码的性质： X = − x n − 1 × 2 n − 1 + x n − 2 × 2 n − 2 + … … + x 1 × 2 1 + x 0 × 2 0 X=-x_{n-1}\times2^{n-1}+x_{n-2}\times2^{n-2}+……+x_{1}\times2^{1}+x_{0}\times2^{0} X=−xn−1​×2n−1+xn−2​×2n−2+……+x1​×21+x0​×20
令n=32则：
Y = − y 31 × 2 31 + y 30 × 2 30 + … … + y 1 × 2 1 + y 0 × 2 0 Y=-y_{31}\times2^{31}+y_{30}\times2^{30}+……+y_{1}\times2^{1}+y_{0}\times2^{0} Y=−y31​×231+y30​×230+……+y1​×21+y0​×20
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4b2f6522762c5f194b0e42b30bd2aba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/473829ef2d39ee88de564ab6fa62136c/" rel="bookmark">
			190320&amp;使用markdown时遇到的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用markdown时遇到的问题 task list 样式显示错误标题样式没显示没有正常换行，一长串显示出来了链接语法没有正常展示标题链接显示错误，标题左边出现一个无法正常显示的图片 task list 样式显示错误，task list 直接显示成了 列表小圆点以及 右边 [] 的形式。 中间括号加X格，标题左边也加空格[] 中间括号不加空格，标题左边加空格[]中间括号不加空格，标题左边不加空格[ ]中间括号加空格，标题左边不加空格 中间括号加空格，标题左边也加空格 标题样式没显示 ##标题左边没有加空格
没有正常换行，一长串显示出来了 写完一句或者一段，需要换行，需要手动在句末或者段落末尾加 1 个空格，否则就尴尬了。
&amp; 加 1 个空格不行，得加两个。
链接语法没有正常展示 用了中文输入法下的括号，效果如下:
[github 的 markdown 语法]（https://guides.github.com/features/mastering-markdown/）
用了英文输入法下的括号，效果如下:
github 的 markdown 语法
标题链接显示错误，标题左边出现一个无法正常显示的图片 写成了图片链接的写法。文字链接左边没有!。
//实际语法实例 ![]() 改为 []() 参考 github 的 markdown 语法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cda7beec6c60a2cd7b4df7f6d1f2d9dd/" rel="bookmark">
			c&#43;&#43;编写的成绩管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		c++编写的成绩管理系统，采用指针的形式。
# include &lt;iostream&gt; # include &lt;fstream&gt; # include &lt;cstring&gt; #include &lt;conio.h&gt; using namespace std; //﹌﹌﹌﹌﹌﹌﹌﹌﹌﹌Student类﹌﹌﹌﹌﹌﹌﹌﹌﹌﹌﹌ class Student { public: char name[20]; char xuehao[20]; int Cnum; //C++课程得分 int Mnum; //高数课程得分 int Enum; //英语课程得分 int sum; //总分 Student * Next; void Input() { cout&lt;&lt;"\t\t请输入学生的姓名："; cin&gt;&gt;name; cout&lt;&lt;"\t\t请输入学生的学号："; cin&gt;&gt;xuehao; cout&lt;&lt;"\t\t请输入C++课程的成绩："; cin&gt;&gt;Cnum; cout&lt;&lt;"\t\t请输入高数的成绩："; cin&gt;&gt;Mnum; cout&lt;&lt;"\t\t请输入英语课程的成绩："; cin&gt;&gt;Enum; sum=Cnum+Mnum+Enum; } void ReadFile(istream &amp; in) { in&gt;&gt;name&gt;&gt;xuehao&gt;&gt;Cnum&gt;&gt;Mnum&gt;&gt;Enum&gt;&gt;sum; } void Show() { cout&lt;&lt;"姓名:"&lt;&lt;name&lt;&lt;endl&lt;&lt;"学号:"&lt;&lt;xuehao&lt;&lt;endl&lt;&lt;"C++:"&lt;&lt;Cnum&lt;&lt;endl &lt;&lt;"高数:"&lt;&lt;Mnum&lt;&lt;endl&lt;&lt;"英语："&lt;&lt;Enum&lt;&lt;endl&lt;&lt;"总成绩:"&lt;&lt;sum&lt;&lt;endl&lt;&lt;endl&lt;&lt;endl; } }; //﹌﹌﹌﹌﹌﹌﹌﹌﹌Studentmassage类﹌﹌﹌﹌﹌﹌﹌﹌﹌﹌﹌﹌ class Studentmassage { public: Studentmassage(); ~Studentmassage(); void ShowMenu(); void Find(); void Save(); void ModifyItem(); void RemoveItem(); void Swap(Student *,Student *); void Sort(); //void Unpass(); int ListCount(); //void Average(); void Display() { for(Student * p=Head-&gt;Next;p!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cda7beec6c60a2cd7b4df7f6d1f2d9dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3941ac41fa1d9cbef10dc35830b6b20/" rel="bookmark">
			hbase:meta 表解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hbase:meta 表中存储了 Hbase 集群中全部表的所有的 region 信息，在 Hbase 2.x 之后新增了表的状态信息。
hbase:meta 表的结构非常简单，在 Hbase 2.x 之前整个表只有一个名为 info 的 ColumnFamily。在 Hbase 2.x 新增表状态信息后，增加了名为 table 的 ColumnFamily。
HBase 保证 hbase:meta 表始终只有一个 Region，这是为了确保 meta 表多次操作的原子性，因为 HBase 本质上只支持 Region 级别的事务。
示例（Hbase 2.x版本之前）
ROW COLUMN+CELL testTable,,1577522582939.b84a96d0e074272569b6fa79946e79df. column=info:regioninfo, timestamp=1577522584346, value={ENCODED =&gt; b84a96d0e074272569b6fa79946e79df, NAME =&gt; 'testTable,,1577522582939.b84a96d0e074272569b6fa79946e79df.', STARTKEY =&gt; '', ENDKEY =&gt; '1'} testTable,,1577522582939.b84a96d0e074272569b6fa79946e79df. column=info:seqnumDuringOpen, timestamp=1583992456271, value=\x00\x00\x00\x00\x00\x00\x00[ testTable,,1577522582939.b84a96d0e074272569b6fa79946e79df. column=info:server, timestamp=1583992456271, value=node1:16020 testTable,,1577522582939.b84a96d0e074272569b6fa79946e79df. column=info:serverstartcode, timestamp=1583992456271, value=1583992398626 hbase:mate 表所在的 RegionServer 信息被存储到了 zookeeper 中的 /hbase/meta-region-server 节点。通过查询该节点，可以获得 hbase:meta 表在那个 RegionServer。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3941ac41fa1d9cbef10dc35830b6b20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7fdc40db76565a628747386ed84b5f4/" rel="bookmark">
			PTA：找最大的字符串（C语言）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 输入5个字符串，输出其中最大的字符串。
输出格式： printf(“Max is: %s\n”, );
输入输出示例：括号内为说明，无需输入输出
输入样例:
peach
pear
melon
orange
berry
输出样例:
Max is: pear
#include &lt;stdio.h&gt; #include &lt;string.h&gt; #define MAX 5 #define MAX_LINE 10 int main() { int i,j; char name[MAX][MAX_LINE]; char temp[2][100]; for (i = 0; i &lt; MAX; i++) scanf("%s", &amp;name[i]); strcpy(temp[0],name[0]); //printf("%s", temp[0]); for (i = 1; i &lt; MAX; i++) if(strcmp(temp[0],name[i]) &lt; 0) strcpy(temp[0],name[i]); printf("Max is:"); printf(" %s", temp[0]); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fcbfcf71f8f62bee4e8a8703a2a2cde/" rel="bookmark">
			PTA 练习8-2 计算两数的和与差 (10分)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本题要求实现一个计算输入的两数的和与差的简单函数。
函数接口定义 void sum_diff( float op1, float op2, float *psum, float *pdiff ); 其中op1和op2是输入的两个实数，psum和pdiff是计算得出的和与差。
裁判测试程序样例： #include &lt;stdio.h&gt; void sum_diff( float op1, float op2, float *psum, float *pdiff ); int main() { float a, b, sum, diff; scanf("%f %f", &amp;a, &amp;b); sum_diff(a, b, &amp;sum, &amp;diff); printf("The sum is %.2f\nThe diff is %.2f\n", sum, diff); return 0; } /* 你的代码将被嵌在这里 */ 输入样例1： 4 6 输出样例1： The sum is 10.00 The diff is -2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fcbfcf71f8f62bee4e8a8703a2a2cde/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06f9eba85c27883653a5932d6f93726c/" rel="bookmark">
			什么是 P = NP 问题？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击关注上方“五分钟学算法”，
设为“置顶或星标”，第一时间送达干货。
转自后端技术指南针
1 前言 今天和大家一起了解个高能知识点：P=NP问题。
看到这里我们可能是一头雾水，不由得发问：
P问题是什么？
NP问题又是什么？
P=NP又是什么意思？
研究并解决P=NP问题的意义是什么？
这四个问题也是我们由表及里去理解P=NP问题的重要切入点，通过本文你将了解到包括但不限于以下内容：
千禧年世纪难题
P类问题和NP类问题特征定义
P=NP的研究和NPC问题
解决P=NP问题的大方向
2 千禧年世纪难题 时间镜头拉回2000年数学界出现了一个里程碑事件：千禧年大奖难题
千禧年大奖难题 Millennium Prize Problems 是七个由美国克雷数学研究所 Clay Mathematics Institute 于2000年5月24日公布的数学难题。根据克雷数学研究所订定的规则，所有难题的解答必须发表在数学期刊上，并经过各方验证，只要通过两年验证期，每解破一题的解答者，会颁发奖金100万美元。 这些难题是呼应1900年德国数学家大卫·希尔伯特在巴黎提出的23个历史性数学难题，经过一百年，许多难题已获得解答。而千禧年大奖难题的破解，极有可能为密码学以及航天、通讯等领域带来突破性进展。
大概意思就是2000年5月美国的一个私人非盈利机构出了7个意义重大的问题，解答任何1道会得到100w美元奖金，说到钱忽然精神起来了，不妨看下这7个多金的题目：
P/NP问题（P versus NP）
霍奇猜想（The Hodge Conjecture）
庞加莱猜想（The Poincaré Conjecture）
黎曼猜想（The Riemann Hypothesis）
杨-米尔斯存在性与质量间隙（Yang-Mills Existence and Mass Gap）
纳维-斯托克斯存在性与光滑性（Navier-Stokes existence and smoothness)
贝赫和斯维讷通-戴尔猜想（The Birch and Swinnerton-Dyer Conjecture）
黎曼猜想去年闹得沸沸扬扬，相信都有所耳闻，不过黎曼猜想是研究素数分布规律的问题，相比之下P=NP问题和计算机领域的关系更为密切，所以P=NP问题被认为是理论计算机和数学领域的综合问题，该问题的研究成果将对计算机领域和现实生活带来巨大的影响。
如克雷数学研究所的约定只要证明或者证伪P=NP问题即可赢取100w美元奖金，其实相比P=NP问题的证明或证否的影响和意义，100w奖金只是皇冠上的一粒尘埃而已。
前面铺垫了一些卖了个关子，快马加鞭一起先来看下 P和NP，到底是个怎样的问题？
3 P类和NP类问题特征 我在克雷数学研究所官网找到了关于 P和NP问题 的简单说明：
简单意译一下：
假设你正在为400名大学生组织住宿，但是空间有限只有100名学生能在宿舍里找到位置。更复杂的是还给了你一份不相容学生的名单，并要求在你的最终选择中不要出现这份名单中的任何一对。
这是计算机科学家称之为NP问题的一个例子，因为很容易检查一个同事提出的一百个学生的给定选择是否令人满意，然而从头开始生成这样一个列表的任务似乎太难了以至于完全不切实际。
事实上从400名申请者中选择100名学生的方法总数比已知宇宙中的原子数量还要多！这类其答案可以被快速检查，但是通过任何直接的程序需要不可接受长度的时间来解决，比如300年或者更多...
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06f9eba85c27883653a5932d6f93726c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1be4dd81f1fe31c5fdc6279d91ee613e/" rel="bookmark">
			Python极简讲义——一本书入门数据分析与机器学习（序言）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么写此书？ 我们正处于一个数据科技（Data Technology，简称DT）的时代。我们的一举一动，都有能在数据空间留下电子印记。于是海量的社交、电商、行为及科研大数据铺面而来。然而，太多的数据给人们带来的，可能并不是更多的洞察，还可能是迷失。
因为仅仅就数据本身而言，它们是“一无所知”的。数据的价值，在于形成信息，变成知识，乃至升华为智慧。也就是说，这些数据如果不能进一步 “深加工”，即使数据量再“大”，也意义聊聊。
于是，就派生这么一个问题，这些数据，谁来“深加工”？如何“深加工”？其实，早在2012年，《哈佛商业评论》就刊登一篇文章，给出了答案，他们就是“数据科学家”，文章还断言，“数据科学家是21世纪最性感的职业”[①]。
但如何成为一个数据科学家呢？特别是一个性感的数据科学家？作为一个有点文青情怀的理工男，我喜欢读写书。读书总会给我们启迪。
曾读过埃里克•莱斯（Eric Ries）写的一本有关创业书，叫《精益创业》（The Lean Startup）[②]。在阅读这本书时，有个概念深入我心，那就是“最小可行产品”（minimum viable product，简称MVP）。这个概念说得是，在创业初期，不可贪多求全，而应先做出一个最小可用的产品，拿到市场上去检验，然后再根据反馈反复迭代，打磨升级，最终做出比较完善比较成功的产品。
后来，看到有人提出了类似的概念——“最少必要知识（Minimal Actionable Knowledge and Experience，简称MAKE）”，这算是点醒了我，我觉得大概可以回答前面的问题。那就是：You can MAKE it （你可以做到）。
先来说说什么是MAKE？它指的是入门某个新领域切实可行的最小知识集合。MAKE说起来好像比较高级，但实际上，在其背后，有个支撑它的朴素原则——Pareto原则（亦称80-20原则），即80%的工作可以掌握20%的知识来解决。
同样，想成为一个“性感的”数据科学家，一条路自然是按部就班地学习所有技能，“十年磨一剑”，但这样做的风险在于，当你“携剑下山”时，可能别人都用上了飞机大炮，这样的对垒，你胜算有几何？
当然，还有另外一条备选之路，那就是走一走MAKE之道。在学习某项技能（如Python、数据分析或机器学习）时，我们要想办法在最短的时间内，摸索清楚这项技能的“最小必要知识”。一方面，它已然可以帮我们解决工作中的大部分问题；另一方面，入门之后，技能的提升通道可以在实践中寻得，缺啥补啥。有明确的任务导向，学习效率就会“有如神助”。这也是当前时代的快节奏学习法。
说到这里，本书的写作用意就呼之欲出了。是的，它的定位就在于，为初学者提供关于数据科学的“最小必要知识”储备，从而找到那份“最性感的”工作。它包含了成为数据科学家的基础知识——Python、数据分析和机器学习。
本书内容 本书包括三个部分，共计10章，每个部分和每章的内容简介如下。
第一部分 Python讲义 这部分内容主要涉及Python的基本应用。
第１章　初识Python与Jupyter
本章介绍了Python和Jupyter的基本用法，包括Python的安装与运行，以及文学化编程利器—Jupyter的使用。
第2章　数据类型与程序控制结构
本章介绍了Python的基础语法以及常见的数据类型、三种控制结构，包括顺序结构、分支结构和循环结构。
第3章　自建Python模块与第三方模块
本章介绍了Python的自定义模块及常用的第三方模块，包括collection、datetime、json和random等。
第4章　Python函数
本章讨论了Python的函数定义、函数的参数 “花式”传递、函数的递归调用及函数式编程。
第5章　Python高级特性
本章讨论了面向对象程序设计思想、迭代器及生成器、文件操作、异常处理及错误调试等内容。
第二部分 数据分析 这部分内容主要涉及数据分析所需的技能，如向量计算所用的NumPy、数据分析的所用Pandas和可视化展示所用的Matplotlib。
第6章　NumPy向量计算
本章讨论了NumPy数组的构建、方法和属性、NumPy的广播和布尔索引、向量的堆叠及爱因斯坦求和约定等。
第7章　Pandas数据分析
本章主要介绍了Pandas的两种常用数据处理结构Series和DataFrame。并介绍了基于Pandas的文件读取和分析，涉及数据的清洗、条件过滤、聚合与分组。
第8章　Matplotlib与Seaborn可视化分析
本章主要介绍Matplotlib和Seaborn的基本用法，包括散点图、折线图、条形图、直方图及饼状图等专业图形的画法，并以谷歌流感趋势数据，结合Pandas绘图分析。
第三部分 机器学习 这部分内容主要涉及机器学习的基本概念和机器学习框架scikit-learn的基本用法。
第9章　机器学习初步
本章主要介绍有关机器学习初步知识，包括机器学习的概念，以及机器学习的几个主要流派，并讨论机器学习的模型评估和性能度量，包括混淆矩阵、查准率、ROC曲线等。
第10章　sklearn与经典机器学习算法
本章主要讲解sklearn的用法，并介绍几种经典机器学习算法的原理和实战，这些算法包括线性回归、k-近邻算法、Logistics回归分类算法、神经网络、k均值聚类算法等。
阅读准备 本书理论结合实践，为运行本书示例代码，需提前安装如下软件环境。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1be4dd81f1fe31c5fdc6279d91ee613e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9194f10935a25ee8e6ad24ef67f71651/" rel="bookmark">
			网络协议之以太网协议解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ethernet ：以太网协议，用于实现链路层的数据传输和地址封装（MAC），以太网是局域网使用最广泛的协议，由于部署简单，价格低廉，被IEEE委员会标准化。
封装原理：
以太网的数据帧格式如下图所示：
它由6个字节的目的MAC地址，6个字节的源MAC地址，2个字节的类型域（用于标示封装在这个Frame、里面的数据的类型）。接下来是46-1500字节的数据和4字节的帧校验。
前同步码：8字节，前7个0，1交替的字节（10101010）用来同步接收站，一个1010101011字节指出帧的开始位置。报头提供接收器同步和帧界定服务。
目标地址：标识目的通信方的MAC地址，6个字节，单播多播或者广播。单播地址叫个人、物理、硬件或MAC地址，广播地址为全1, 0xFF FF FF FF 。
源地址：标识发送端的MAC地址，6个字节，指出发送节点的单点广播地址。
以太类型：2个字节，用来指出以太网帧内所含的上层协议。即帧格式的协议标识符。对于IP报文来说，该字段值是0x0800。对于ARP信息来说，以太类型字段的值是0x0806。
以太类型值(16进制)对应协议 0x0000 -0x05DC IEEE 802.3 长度 0x0101-0x01FF 实验 0x0600 XEROX NS IDP 0x0660-0x0661 DLOG 0x0800 网际协议（IP） 0x0801 X.75 Internet 0x0802 NBS Internet 0x0803 ECMA Internet 0x0804 Chaosnet 0x0805 X.25 Level 3 0x0806 地址解析协议（ARP ： Address Resolution Protocol） 0x0808 帧中继 ARP （Frame Relay ARP） [RFC1701] 0x6559 原始帧中继（Raw Frame Relay） [RFC1701] 0x8035 动态 DARP （DRARP：Dynamic RARP）反向地址解析协议（RARP：Reverse Address Resolution Protocol） 0x8037 Novell Netware IPX 0x809B EtherTalk 0x80D5 IBM SNA Services over Ethernet 0x80F3 AppleTalk 地址解析协议（AARP：AppleTalk Address Resolution Protocol） 0x8100 以太网自动保护开关（EAPS：Ethernet Automatic Protection Switching） 0x8137 因特网包交换（IPX：Internet Packet Exchange） 0x814C 简单网络管理协议（SNMP：Simple Network Management Protocol） 0x86DD 网际协议v6（IPv6，Internet Protocol version 6） 0x8809 OAM 0x880B 点对点协议（PPP：Point-to-Point Protocol） 0x880C 通用交换管理协议（GSMP：General Switch Management Protocol） 0x8847 多协议标签交换（单播） MPLS：Multi-Protocol Label Switching &lt;unicast&gt;） 0x8848 多协议标签交换（组播）（MPLS, Multi-Protocol Label Switching &lt;multicast&gt;） 0x8863 以太网上的 PPP（发现阶段）（PPPoE：PPP Over Ethernet &lt;Discovery Stage&gt;） 0x8864 以太网上的 PPP（PPP 会话阶段） （PPPoE，PPP Over Ethernet&lt;PPP Session Stage&gt;） 0x88BB 轻量级访问点协议（LWAPP：Light Weight Access Point Protocol） 0x88CC 链接层发现协议（LLDP：Link Layer Discovery Protocol） 0x8E88 局域网上的 EAP（EAPOL：EAP over LAN） 0x9000 配置测试协议（Loopback） 0x9100 VLAN 标签协议标识符（VLAN Tag Protocol Identifier） 0x9200 VLAN 标签协议标识符（VLAN Tag Protocol Identifier） 0xFFFF 保留
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9194f10935a25ee8e6ad24ef67f71651/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e0876d2f900d5fc942da33e082c6732/" rel="bookmark">
			解决scrapy中创建请求，部分url丢失的情况
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决scrapy中创建请求，部分url丢失的情况 验证 先感受一下发生的问题
def parse(self, response): # print(response.text) book_url = response.xpath('//*[@class="r"]/ul/li/span[1]/a/@href').extract() print(len(book_url)) #30 for url in book_url: yield scrapy.Request(url, callback=self.parse_book, dont_filter=True) def parse_book(self, response): print(response.url) 遍历url_list中的url,分别创建请求进行二次访问。看一下令人头疼的结果。
30个url请求成功9个，丢失率超过2/3。
解决方法：
1、 添加参数 dont_filter=True
`yield scrapy.Request(url, callback=self.parse_book, dont_filter=True)` 2、修改配置文件中的参数
# Configure a delay for requests for the same website (default: 0) # See https://docs.scrapy.org/en/latest/topics/settings.html#download-delay # See also autothrottle settings and docs DOWNLOAD_DELAY = 3 # The download delay setting will honor only one of: CONCURRENT_REQUESTS_PER_DOMAIN = 16 CONCURRENT_REQUESTS_PER_IP = 16 3、降低delay
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e0876d2f900d5fc942da33e082c6732/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d7306cf104720583a0a165366a14497/" rel="bookmark">
			sklearn.neural_network.MLPClassifier用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		from sklearn.neural_network import MLPClassifier #初始化输入矩阵 X = [[0., 0.], [1., 1.]] #初始化目标值 y = [0, 1] #实例化一个人工神经网络分类器并传入数据训练 clf = MLPClassifier(solver='sgd', alpha=1e-5, activation='logistic',hidden_layer_sizes=(5, 2), max_iter=2000, tol=1e-4) clf.fit(X, y) #打印预测类别 predicted_value = clf.predict([[2., 2.], [-1., -2.]]) print(predicted_value) #打印预测类别的概率值 predicted_proba = clf.predict_proba([[2., 2.], [-1., -2.]]) print(predicted_proba) #打印三组权重矩阵的形状 print([coef.shape for coef in clf.coefs_]) #打印三组权重矩阵的参数 print([coef for coef in clf.coefs_]) 运行结果：
[1 1]
[[0.46120433 0.53879567]
[0.45146875 0.54853125]]
[(2, 5), (5, 2), (2, 1)]
[array([[-0.50343439, 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d7306cf104720583a0a165366a14497/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e8b192a65122e884a5909137c95653f/" rel="bookmark">
			jsmind-网页版的由js实现的思维导图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有时候，我们可能需要在网页上展示思维导图般的效果，比如现在有个要展示某个数据库表与其他表的关系，这些关系可能有业务依赖、键依赖、调度依赖等，怎么更直观的展示这些关系呢？思维导图是个不错的选择，效果就像一些流行的思维导图比如xmind等软件一样，但是我们这些做javaEE开发的是和浏览器打交道的，有在浏览器上画思维导图的js或者jquery插件吗?经过在网上一番搜寻之后，还真是功夫不负有心人，发现了一款名叫jsmind的插件可以实现这样的功能，最后它也出色的胜任了当时的开发任务，让我不至于饿。基于这个插件资料比较零碎，我呢，就总结了一下，希望能帮助到各位有需要的朋友。
下来看一下几张效果图吧：
还可以给上面的节点加上各种事件：
好了，知道了是什么样子，我们来看下代码是怎么实现的。
html：
&lt;%@ page language="java" contentType="text/html; charset=utf-8" pageEncoding="utf-8"%&gt; &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;link href="&lt;%=request.getContextPath()%&gt;/rs/jsmind/jsmind/style/jsmind.css" rel="stylesheet"&gt; &lt;script type="text/javascript" src="&lt;%=request.getContextPath()%&gt;/rs/js/jquery-1.12.4.min.js"&gt; &lt;/script&gt; &lt;script src="&lt;%=request.getContextPath()%&gt;/rs/jsmind/jsmind/js/jsmind.js"&gt;&lt;/script&gt; &lt;script src="&lt;%=request.getContextPath()%&gt;/rs/jsmind/jsmind/js/jsmind.draggable.js"&gt; &lt;/script&gt; &lt;title&gt;jsmind&lt;/title&gt; &lt;style type="text/css"&gt; #jsmind1_container,#jsmind2_container{ width:1000px; height:500px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="jsmind1_container"&gt;&lt;/div&gt; &lt;div id="jsmind2_container"&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; JavaScript：
&lt;script type="text/javascript"&gt; /* 例子一：以node_tree格式定义 */ var mind_data_1 = { "meta":{ "name":"js课程", "author":"乐之者管理员", "version":"0.2" }, "format":"node_tree", /* 数据格式声明 */ "data":{"id":"js","topic":"javascript","children":[ {"id":"easy","topic":"第一天","direction":"left","expanded":false,"children":[ {"id":"var","topic":"变量"}, {"id":"exp","topic":"表达式"}, {"id":"easy3","topic":"语句"} ]}, {"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e8b192a65122e884a5909137c95653f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b56107b400d210ddaf284a41751bbcdd/" rel="bookmark">
			6-6 计算两数的和与差 (10分)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本题要求实现一个计算输入的两数的和与差的简单函数。
函数接口定义： void sum_diff( float op1, float op2, float *psum, float *pdiff ); 其中op1和op2是输入的两个实数，*psum和*pdiff是计算得出的和与差。
裁判测试程序样例： #include &lt;stdio.h&gt; void sum_diff( float op1, float op2, float *psum, float *pdiff ); int main() { float a, b, sum, diff; scanf("%f %f", &amp;a, &amp;b); sum_diff(a, b, &amp;sum, &amp;diff); printf("The sum is %.2f\nThe diff is %.2f\n", sum, diff); return 0; } /* 你的代码将被嵌在这里 */ 输入样例： 4 6 输出样例： The sum is 10.00 The diff is -2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b56107b400d210ddaf284a41751bbcdd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cd7fd03fa276b47a39a963943f25889/" rel="bookmark">
			R语言|回归分析（一） ———R语言数据分析系列(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		回归分析 数据准备数据基本信息 建立回归模型建立回归方程预测数值 回归方程可视化散点图加拟合回归方程诊断 完整代码 回归分析它是最为人熟知的建模技术之一。线性回归通常是人们在学习预测模型时首选的技术之一。在这种技术中，因变量是连续的，自变量可以是连续的也可以是离散的，回归线的性质是线性的。利用回归预测模型计算预测值，并对预测值进行综合分析，确定最后的预测值。【该分析完整代码附于文章末】 数据准备 首先加载“gcookbook”包，这个包包含由OReilly Media出版的Winston Chang所著的《R Graphics Cookbook》一书中使用的数据集。
数据基本信息 调用"gcookbook"数据包中的heightweight数据框。
#install.packages("gcookbook") #没有下载过的可先运行此语句 library(gcookbook) #引用gcookbook数据集 View(heightweight) #heightweight为下面分析所用数据 str(heightweight) #按例查看数据形式 summary(heightweight) #查看数据基本内容 先查看数据的变量，如图1，该数据框有236行5列，其中包含了性别、年龄、月数、身高、体重五个变量。除了性别，其余的都是数值型数据。
图1 数据的变量信息 接下来查看数据的基本内容，如图2，这些年龄为11岁到17岁的青少年，平均年龄为13岁，男女比例基本各占一半，男性（male）仅比女性（famale）多14人。
图2 数据的基本内容 建立回归模型 建立回归方程 直接调用系统lm()函数，下面将做结果解读。
model &lt;- lm(heightIn~ageYear,heightweight) #建立回归模型 model #直接查看回归系数 summary(model) #查看回归模型参数 首先查看方程形式，直接查看回归系数，如图3，常数项系数为37.436，常数项系数为1.748，因此该回归方程表示为
y = 37.4 + 1.75 x y=37.4+1.75x y=37.4+1.75x
图3 回归方程的回归系数 回归方程最主要还是看回归参数，如图4，可看出残差分析(Residuals)、系数项(Coefficients)、P值(p-value)、调整R方(Adjusted R-squared)均在下图对应位置。在系数分析一栏，每一项后面的星号代表着显著性的大小。图中显示R方为0.4225，P值为 p = 2.2 ∗ 1 0 − 16 p=2.2*10^{-16} p=2.2∗10−16。
图4 回归方程的模型参数 预测数值 首先建立需要预测的自变量数值，其次调用predict()函数进行预测。
data.frame() xmin &lt;- min(heightweight$ageYear) xmax &lt;- max(heightweight$ageYear) predicted &lt;- data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4cd7fd03fa276b47a39a963943f25889/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc0b5a5af193ebc3d2a77972bc61dcc6/" rel="bookmark">
			SQLyog无法连接mysql且不是因为未启动服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题
无法连接mysql,通常是因为我们没有启动mysql服务导致的,这里是有对应的状态码的,在结尾我会留给大家
有一次我在启动SQLyog连接mysql时发现无法连接,回忆我的操作时我认为我是删除更改了mysql中原有的一些库,这是一种不常见的问题,我不知道是删掉更改了那些库,但我知道我user库肯定是没了的,或者更改,账号已经无效了
解决方案
解决之前告诉大家一个小知识:我们把MySQL装在了C:/Program Files/MySQL/MySQL Server 5.0，默认的数据库文件是放在C:/Program Files/MySQL/MySQL Server 5.0/data下。
1.在mysql默认数据保存路径下我们应该是少了一些table,我们在D盘或者其他盘找到我们的mysql(自己安装时候的),我们需要将缺少的table复制进我们的mysql安装目录下的对应地方,问题来了我们不知道缺少什么也不知道在哪,此时我们可以查看日志管理器,知道对应时间的mysql启动错误信息,里面有详细信息
2.这个操作可能会失去密码mysql -u root -p登录后SET PASSWORD FOR ‘root’@‘localhost’ = PASSWORD(‘密码’);
mysql提示状态码大全
服务器错误代码和消息 服务器错误信息来自下述源文件： · 错误消息信息列在share/errmsg.txt文件中。“%d”和“%s”分别代表编号和字符串，显示时，它们将被消息值取代。 · 错误值列在share/errmsg.txt文件中，用于生成include/mysqld_error.h和include/mysqld_ername.h MySQL源文件中的定义。 · SQLSTATE值列在share/errmsg.txt文件中，用于生成include/sql_state.h MySQL源文件中的定义。 由于更新很频繁，这些文件中可能包含这里未列出的额外错误消息。 · 错误：1000 SQLSTATE: HY000 (ER_HASHCHK) 消息：hashchk · 错误：1001 SQLSTATE: HY000 (ER_NISAMCHK) 消息：isamchk · 错误：1002 SQLSTATE: HY000 (ER_NO) 消息：NO · 错误：1003 SQLSTATE: HY000 (ER_YES) 消息：YES · 错误：1004 SQLSTATE: HY000 (ER_CANT_CREATE_FILE) 消息：无法创建文件'%s' (errno: %d) · 错误：1005 SQLSTATE: HY000 (ER_CANT_CREATE_TABLE) 消息：无法创建表'%s' (errno: %d) · 错误：1006 SQLSTATE: HY000 (ER_CANT_CREATE_DB) 消息：无法创建数据库'%s' (errno: %d) · 错误：1007 SQLSTATE: HY000 (ER_DB_CREATE_EXISTS) 消息：无法创建数据库'%s'，数据库已存在。 · 错误：1008 SQLSTATE: HY000 (ER_DB_DROP_EXISTS) 消息：无法撤销数据库'%s'，数据库不存在。 · 错误：1009 SQLSTATE: HY000 (ER_DB_DROP_DELETE) 消息：撤销数据库时出错（无法删除'%s'，errno: %d） · 错误：1010 SQLSTATE: HY000 (ER_DB_DROP_RMDIR) 消息：撤销数据库时出错（can't rmdir '%s', errno: %d） · 错误：1011 SQLSTATE: HY000 (ER_CANT_DELETE_FILE) 消息：删除'%s'时出错 (errno: %d) · 错误：1012 SQLSTATE: HY000 (ER_CANT_FIND_SYSTEM_REC) 消息：无法读取系统表中的记录。 · 错误：1013 SQLSTATE: HY000 (ER_CANT_GET_STAT) 消息：无法获取'%s'的状态(errno: %d) · 错误：1014 SQLSTATE: HY000 (ER_CANT_GET_WD) 消息：无法获得工作目录(errno: %d) · 错误：1015 SQLSTATE: HY000 (ER_CANT_LOCK) 消息：无法锁定文件(errno: %d) · 错误：1016 SQLSTATE: HY000 (ER_CANT_OPEN_FILE) 消息：无法打开文件：'%s' (errno: %d) · 错误：1017 SQLSTATE: HY000 (ER_FILE_NOT_FOUND) 消息：无法找到文件： '%s' (errno: %d) · 错误：1018 SQLSTATE: HY000 (ER_CANT_READ_DIR) 消息：无法读取'%s'的目录 (errno: %d) · 错误：1019 SQLSTATE: HY000 (ER_CANT_SET_WD) 消息：无法为'%s'更改目录 (errno: %d) · 错误：1020 SQLSTATE: HY000 (ER_CHECKREAD) 消息：自上次读取以来表'%s'中的记录已改变。 · 错误：1021 SQLSTATE: HY000 (ER_DISK_FULL) 消息：磁盘满(%s)；等待某人释放一些空间.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc0b5a5af193ebc3d2a77972bc61dcc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35aea00dad9f56b2e87cec60ca639973/" rel="bookmark">
			JavaScript DOM：Node对象、添加子节点、删除子节点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Node :节点对象 特点:
所有dom对象都可以被认为是一个节点方法:
CRUD dom树: appendChild() :向节点的子节点列表的结尾添加新的子节点。removeChild() : 删除(并返回)当前节点的指定子节点。replaceChild() :用新节点替换一个子节点。 属性
parentNode返回节点的父节点。 举例： &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; div{ border: red 1px solid; } #div1{ width: 200px; height: 200px; } #div2{ width: 100px; height: 100px; } #div3{ width: 100px; height: 100px; border: blue solid 1px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="div1"&gt; &lt;div id="div2"&gt; div2 &lt;/div&gt; div1 &lt;/div&gt; &lt;!-- &lt;input type="button" value="删除子节点" id="del"&gt;--&gt; &lt;a href="javascript:void(0);" id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35aea00dad9f56b2e87cec60ca639973/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6216b553c55a557a414280ffabdfeb0/" rel="bookmark">
			微信小程序实现智能识别名片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、背景2、腾讯开放平台名片OCR接口2.1 文档参考2.2 小程序OCR功能主要JS代码实现 3、微信小程序名片OCR功能接入3.1 微信小程序首页设计3.2 扫名片功能实现3.2.1 识别页面3.2.2 识别程序 4 名片识别验证4.1 名片拍照4.2 名片识别 1、背景 最近在做一个CRM微信小程序工具，用户提出需要增加名片拍照智能识别的需求。由于在前段时间特意对BAT AI开放平台的OCR能力做过了解（具体参见本文：百度、阿里、腾讯开放平台OCR功能解析），故设想使用腾讯开放平台名片OCR接口完成以上需求。
2、腾讯开放平台名片OCR接口 2.1 文档参考 注意：腾讯开放平台接口的接口鉴权的签名算法较为特殊。
. 接口描述
根据用户上传的名片图像，返回识别出的名片字段信息，目前已支持20多个字段识别（姓名、英文姓名、职位、英文职位、部门、英文部门、公司、英文公司、地址、英文地址、邮编、邮箱、网址、手机、电话、传真、QQ、MSN、微信、微博、公司账号、logo、其他）
2.2 小程序OCR功能主要JS代码实现 let md5 = require('../md5.js') let app_id = '请录入您对应的app_id' let app_key = '请录入您对应的app_key' let url = 'https://api.ai.qq.com/fcgi-bin/ocr/ocr_bcocr' let request = (base64Img, callback) =&gt; { let params = { app_id: app_id, image: base64Img, nonce_str: Math.random().toString(36).substr(2), time_stamp: parseInt(new Date().getTime() / 1000).toString() } params['sign'] = _genRequestSign(params) wx.request({ url: url, data: params, header: { 'content-type': 'application/x-www-form-urlencoded' }, method: 'POST', success: function (res) { let formatRes = _formatResult(res.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6216b553c55a557a414280ffabdfeb0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bc6c8482dea411f6cd1b43111731693/" rel="bookmark">
			Unity 自定义事件 AddListerner
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unity 自定义事件 AddListerner Unity中有的Button组件有onCick.AddListener属性，如果想要自己定义事件并能够像Button一样AddListener使用需要怎么做呢？
Unity中提供有UnityEvent类来用作事件的声明，下面直接放上代码，再一一说明。
CustomEventClass.cs
/* 事件类型的声明类 */ using UnityEngine.Events; using UnityEngine; // 开始移动事件 public class StartMoveEvent : UnityEvent&lt;GameObject, string&gt; {} // 移动中事件 public class OnMoveEvent : UnityEvent&lt;GameObject, string&gt; {} // 移动结束事件 public class EndMoveEvent : UnityEvent&lt;GameObject, string&gt; {} 这个类主要是声明几个自定义的事件，可以按照个人喜好和代码风格来确定放在一个脚本或者是跟逻辑脚本放在一起。
自定义的类继承了 UnityEvent 就成为了一个Unity的事件，支持多参数，但至多只能是4个，具体API可以看 UnityEvent.cs 文件。
TestGameObject.cs
/* 测试的Mono类 */ using System.Collections; using System.Collections.Generic; using UnityEngine; public class TestGameObject : MonoBehaviour { public StartMoveEvent startMoveEvent = new StartMoveEvent(); public OnMoveEvent onMoveEvent = new OnMoveEvent(); public EndMoveEvent endMoveEvent = new EndMoveEvent(); static float startTime = 0f; void Awake(){ startMoveEvent.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bc6c8482dea411f6cd1b43111731693/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c83dac3aa448b97b9e8bb29d120b6137/" rel="bookmark">
			mysql数据库怎么存入emoji表情
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 第一步第二部 第一步 数据库右键-改变数据库- 设置数据库字符编码为utf8mb4_general_ci ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200417114141585.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NTA1MDY1,size_16,color_FFFFFF,t_70) 表右键-改变表 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200417114233729.png) 第二部 设置具体字段的字符编码
alter table link_feedback CHANGE `profiles` `profiles` varchar(300) CHARACTER SET utf8mb4 alter table 表名CHANGE 列名 列名 修改列数据类型 CHARACTER SET utf8mb4
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0ca7e572416910fd1d4074d444ad4ba/" rel="bookmark">
			Games101课程笔记_lecture20_color颜色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Games101课程笔记_lecture20_color颜色 1 light Field/Lumingraph1 全光函数2 光场3 光场相机 2 颜色1 光谱2 颜色1 人靠什么感知颜色的？2 视网膜 3 颜色感知4 Metamerism同色异普5 颜色混合6 颜色空间1 RGB2 CIE-XYZ3 色域4 HSV 颜色空间5 CIELAB　Space视觉暂留现象颜色是相对的 3 减色系统4 剩下课程信息5 视频 2分钟的视频，一个ppt讲解录视频+录音
排列模式–ppt.做
1 light Field/Lumingraph 光场.上面这两个词是因为两个团队做出来对光场不同的称呼贰而已。
把右边的图片把所有的信息呈现在Painted backdrop，让人觉的自己看到的和自己在现实世界中看到的是 一样的，这个就是虚拟现实的原理。
1 全光函数 引入波长后：
再扩展一个时间t，就是电影
继续扩展到整个空间：自己可以随处看，就是全息电影。
再继续扩展，任何时间，任何位置，任何方向看到的。
整个世界是7个维度的函数，咱们看到的世界就可以用这个函数来表示。
全光函数简化：
2 光场 光场就是全光函数的一个小部分。
这个函数记录了不同 的点不同的位置它往各个方向发射的光的强度。
光场和全光函数的关系就建立了起来了。
二维的方向二维的位置。
记录光场的时候，你往那个点看的时候，都知道自己看到了什么。在这个物体中查询那个光场的强度。
可以得到物体任意位置任何方向光的强度
只关心观测点的光的强度，不需要知道物体的形状。前提是观测点在光场的外面。
一个方向，一个点：
2个点定义一条光线：
uv，st
参数化方法：
整个世界在st平面的右边：
a:类似于针孔摄像机
b:
摄像机矩阵：每个相机形成一个二维图
苍蝇的眼睛就是形成一个广场：
lanslet当成一个像素，如果将其当成一个透镜，后面的感光元件就可以记录各个方向的
记录的不再是radiances，而是穿过各个方向的光。
3 光场相机 大神:Ng.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0ca7e572416910fd1d4074d444ad4ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8732fa5b112c6f1e59663e660b994995/" rel="bookmark">
			tensorboard--曲线图颜色深浅两条线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用了用tensorboard，看到左边有一个平滑度数选择，默认是0.6，就调了下，曲线就发生变化了，原来颜色浅的才是真实曲线，但真实曲线往往不好看，所以加入了平滑产生了颜色深的线
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75421d6490db7c57176bde217f9be499/" rel="bookmark">
			ThinkPHP3.2.3 { Fast &amp; Simple OOP PHP Framework }报错可能存在的问题解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.可以清runtime 缓存
2.如果有保留日志，查看服务器磁盘空间是否已满，可以使用 df -h 命令查看系统的分配，已使用和可用情况。如果空间已满，可以将日志或占用空间大的部分清理。在清楚缓存即可正常
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/167d310af1f062b2d658d016196d61f7/" rel="bookmark">
			浙大PTA 学生顺序表的建立
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		完成对一个顺序表的建立，表中的每个元素是同学们的学号、姓名和三门课程的成绩，输入5个同学的信息，然后显示在屏幕上。（要求利用顺序表的基本操作）
输入格式:
首先收入学生人数5，然后依次输入5个学生的学号、姓名和三门课的成绩
输出格式:
输入5个学生的学号、姓名和三门课的成绩
输入样例:
5
01 张三 89 89 89
02 李四 90 90 90
03 王五 89 89 89
04 钱六 97 97 97
05 赵倩 90 90 90
输出样例:
1 张三 89.0 89.0 89.0
2 李四 90.0 90.0 90.0
3 王五 89.0 89.0 89.0
4 钱六 97.0 97.0 97.0
5 赵倩 90.0 90.0 90.0
思路：将输入的学生信息存储在结构体数组中，输入5个学生，按输入顺序输出学生信息。
ac代码：
#include &lt;iostream&gt; using namespace std; const int maxn = 10; typedef struct LNode * List; struct LNode{ int id[maxn]; string name[maxn]; float score1[maxn], score2[maxn], score3[maxn]; int last; }; int main() { List L; L = (List)malloc(sizeof(struct LNode)); L-&gt;last = 0; int n; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/167d310af1f062b2d658d016196d61f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f8c37f81762a3c0db7a59326486625b/" rel="bookmark">
			小程序使用uni.createAnimation(OBJECT)实现点赞动画
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		思路： 在页面创建的时候，创建一个临时动画对象调用 step() 来表示一组动画完成通过动画实例的export方法导出动画数据传递给组件的animation属性还原动画页面卸载的时候，清除动画数据 &lt;template&gt; &lt;view class="content"&gt; &lt;view class="item" v-for="(item,index) in list" :key="item.id"&gt; &lt;view class="left"&gt; {{item.memo}} &lt;/view&gt; &lt;view class="right" @click="praiseMe(index)"&gt; &lt;image src="../../static/praise.png"&gt;&lt;/image&gt; &lt;view class="font11"&gt;点赞&lt;/view&gt; &lt;view :animation="animationDataArr[index]" class="praise-me animation-opacity"&gt; +1 &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { list:[ {id:"001",memo:"苹果"}, {id:"002",memo:"橘子"}, {id:"003",memo:"草莓"}, {id:"004",memo:"香蕉"} ], animationData: {}, animationDataArr: [] }; }, onLoad() { // 1 在页面创建的时候，创建一个临时动画对象 this.animation = uni.createAnimation(); this.animationDataArr=Array(this.list.length).fill({}); }, onUnload() { // 5 页面卸载的时候，清除动画数据 this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f8c37f81762a3c0db7a59326486625b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39ac76b54c738d235bab380a7bd98b72/" rel="bookmark">
			stm32栈空间分布分析——让你能更合理的设置栈空间，防止栈溢出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天我们利用stm32来探究一下程序运行时的栈空间是怎么分布的，为什么栈空间设置不合理时会有栈溢出导致程序崩溃
下面是我们要使用的测试代码，先贴出来, 为了更好地分析栈空间我们把栈空间用串口dump出来
void hex_dump(unsigned char *p, int len) { uint32_t i, j; //printf("\n===============dump start====================\n"); printf("\r\n["); for (i = 0, j = 0; i &lt; len; i++) { printf("%02x ", p[i]); if (j &lt; 15) { j++; } else { j = 0; printf("\r\n"); } } printf("]\r\n"); //printf("\n===============dump end====================\n"); } void statck_dump() { hex_dump((char *)(0x20000460-0x400), 0x400); } void test_func(int v) { printf("%d\r\n", v); statck_dump(); } void func(void) { char buf[50] = {0}; memset(buf, 0x22, sizeof(buf)); buf[0] = 0xFF; statck_dump(); } /** * @brief The application entry point.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39ac76b54c738d235bab380a7bd98b72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/917f7511d10d8a44a7d6f48f28e37db0/" rel="bookmark">
			sql语句查询解决group by 统计重复数据问题个人总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通常情况下我们写sql语句主键都是唯一的不会出现id重复的问题。如：
查询表table1的所有数据
select * from table1
会显示出table1中所有字段列表。
select count(*) as count from table1
统计table表中数据总数也不会有问题。
但是如果使用的分组group by那么问题就会出现统计不准的问题
select count（*） from table1 where status=1
返回结果
但是如果这样写就会按分组统计总数，不是我们想要的结果如下：
select count（*） from table1 where status=1 group by name
我们本来想要统计一共多少条数据，但结果返回的是每个分组查询有多少条数据。这样就不能达到我们想要的目的。
那怎么解决呢？其实mysql自带了函数，我们可以利用DISTINCT去重
select * from table1 where status=1 group by name 查询出以name分组的数据
统计分组后的数据时这样处理：
select count(DISTINCT name) from table1 where status=1
将分组的字段放到查询语句中，使用DISTINCT去重就可以达到我们想要的效果了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ff241b85fd9a45698c9a50d0079a405/" rel="bookmark">
			【leetcode】任务调度器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目： 给定一个用字符数组表示的 CPU 需要执行的任务列表。其中包含使用大写的 A - Z 字母表示的26 种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。CPU 在任何一个单位时间内都可以执行一个任务，或者在待命状态。
然而，两个相同种类的任务之间必须有长度为 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。
你需要计算完成所有任务所需要的最短时间。
示例 ：
输入：tasks = ["A","A","A","B","B","B"], n = 2 输出：8 解释：A -&gt; B -&gt; (待命) -&gt; A -&gt; B -&gt; (待命) -&gt; A -&gt; B. 在本示例中，两个相同类型任务之间必须间隔长度为 n = 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。 提示：
任务的总个数为 [1, 10000]。n 的取值范围为 [0, 100]。 思路： (1）先找出现次数最多的字母，假设为A，出现m次，要求字母间隔大于n。那么先将A按照给定间隔排好后的长度为(m-1)*(n+1) + 1,（m-1）是因为m个A之间有（m-1）块空格。（n+1）是因为每块空格长度为n，在加上字母A，一共n+1,最后一个+1是最后一个字母A。比如字母A出现3次，间隔为2，则A排好后为
A _ _ A _ _ A
（2）接下来排的时候只需要依次将频率小的字母插入这些空格中，注意插的时候要先插满第二位的空格，再插第三位的空格，以此类推，且频率高的字母先插。
（3）上面说的是大部分情况，但是还会出现两种特殊情况：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ff241b85fd9a45698c9a50d0079a405/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79afeb9ae3b561be2ac1b9b2a2c4da51/" rel="bookmark">
			ts泛型，函数返回类型为对象某个key值的类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 泛型是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。一直是ts学习中的一个重难点。
具体的学习资料还是看官网吧。这里出一个题目：
写一个函数，接受两个参数，一个为object，另一个为object中的一个key。函数返回类型指定为obj[key]的类型。
interface Person{ name:string, age:number } function demo&lt;T extends object, K extends keyof T&gt;(obj:T, key:K){ return obj[key] } //测试 let obj:Person={ name:"tea", age:23 } let age = demo(obj, "age") // number类型 let name = demo(obj, "name") // string类型 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bfe755debd17265cea95a6aa493b014/" rel="bookmark">
			zynq如何通过官方提供例程检测phy的硬件是否正常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人最近在调试uboot的phy芯片两次因为硬件问题导致调试浪费了很多时间由此提供给大家一个测试硬件的方法。
1使用Xilinx sdk 逻辑侧(fpga)提供的（*.hdf）文件创建一个工程。2创建一个裸机fsbl文件同时创建bsp包；3创建一个裸机基于已经创建的bsp包的app，选择lwip echo server 如下图选择finish。
4、build project 然后选择app上的单机右键选择run as 然后配置加载到开发板 串口打开 等待打印信息
板子的ip port 和getway
之后自己添加pc添加对应网段的ip 网关等信息；
5、使用teltnetl等工具连接board ip 使用串口打印信息提供的port
连接后输入相应的字符等回得到回显就代表连接成功。 二、采用uboot测试
uboot加载后有提供命令行进行测试读写寄存器
如：
mii info 打印phy寄存器信息
mii device 打印phy 的设备名称
mii read phyaddr phynum 读取phy地址的第几个寄存器
mii write phyaddr phynum data 写
需要注意：
phy 寄存器按页划分，如88e1518phy芯片 切换页的寄存器就是22 (0x16)
如果读取phy地址第0页 第一个寄存器 假设phyaddr = 0
mii write 0 0x16 0x0
mii read 0 1 //这时读取的就是第0页第一个寄存器
如果每个寄存器能够正常读写代表你的mdio 和mdc基本没有问题，需要检测rx tx时钟，mdc是单独的时钟，mdio是管理口。管理口正常后需要继续测试管理口写入的寄存器值是否生效。
1、测试时钟 rx tx
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bfe755debd17265cea95a6aa493b014/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7642040d14215df0de339bdd726ed915/" rel="bookmark">
			Linux一键拉取代码打包部署项目脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.脚本功能说明2.运行前提3.创建执行文件4.脚本内容4.运行脚本5.效果演示 1.脚本功能说明 1.拉取代码:没项目时clone到本地,有项目时更新项目
2.maven打包
3.循环杀掉所有正在运行的项目相关的服务(注意执行文件不要起和项目相同的名字,会把正在执行的文件任务给杀掉)
4.删除原来的jar包和内容.复制打包jar到指定位置
5.加载外部配置文件启动项目,并输出当前日志到指定位置
2.运行前提 使用前需要安装git 和 maven
安装git
安装maven
3.创建执行文件 vi mysh.sh 给执行文件赋权
chmod 777 mysh.sh 4.脚本内容 copy脚本时注意修改路径等项目之间相关不同的内容
#!/bin/sh #项目的git地址 git_path="仓库地址" #本地代码位置代码路径 code_path="/xxx" #项目名称 projectName="xxx" env="master" #如果项目文件夹不存在说明没有下载过改项目代码，需要检出该项目 if [ ! -d ${code_path}/${projectName} ]; then echo ${projectName}"不存在,检出该项目" cd $code_path git clone "仓库地址" else echo ${projectName}"项目存在，更新代码" cd ${code_path}/${projectName} git reset --hard git pull fi #删除项目 echo "删除项目下target" rm -rf "${code_path}/${projectName}/${projectName}/target" #maven 再打项目包 echo "maven打包${projectName}" cd ${code_path}/${projectName} mvn install -Dmaven.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7642040d14215df0de339bdd726ed915/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/625a6e1c3bd9bf79a8ca4aea260bb08e/" rel="bookmark">
			MySql面试题（总结最全面的面试题！！！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 什么是SQL？什么是MySQL?MySql, Oracle，Sql Service的区别数据库三大范式是什么mysql有关权限的表都有哪几个数据库经常使用的函数 数据类型mysql有哪些数据类型 引擎MySQL存储引擎MyISAM与InnoDB区别MyISAM索引与InnoDB索引的区别？InnoDB引擎的4大特性存储引擎选择 索引什么是索引？索引有哪些优缺点？怎么创建索引的，有什么好处，有哪些分类简述有哪些索引和作用索引使用场景主键索引与唯一索引的区别索引有哪几种类型？索引的数据结构（b树，hash）索引的基本原理索引算法有哪些？索引设计的原则？创建索引的原则创建索引的三种方式如何删除索引创建索引时需要注意什么？使用索引查询一定能提高查询的性能吗？为什么百万级别或以上的数据如何删除前缀索引什么是最左前缀原则？什么是最左匹配原则B树和B+树的区别使用B树的好处使用B+树的好处Hash索引和B+树所有有什么区别或者说优劣呢?数据库为什么使用B+树而不是B树B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，什么是聚簇索引？何时使用聚簇索引与非聚簇索引非聚簇索引一定会回表查询吗？联合索引是什么？为什么需要注意联合索引中的顺序？ 事务什么是数据库事务？事物的四大特性(ACID)介绍一下?什么是脏读？幻读？不可重复读？什么是事务的隔离级别？MySQL的默认隔离级别是什么？ 锁对MySQL的锁了解吗从锁的类别上分MySQL都有哪些锁呢？隔离级别与锁的关系按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法MySQL中InnoDB引擎的行锁是怎么实现的？InnoDB存储引擎的锁的算法有三种什么是死锁？怎么解决？数据库的乐观锁和悲观锁是什么？怎么实现的？ 视图为什么要使用视图？什么是视图？视图有哪些特点？视图的使用场景有哪些？视图的优点视图的缺点什么是游标？ 存储过程与函数什么是存储过程？有哪些优缺点？ 触发器什么是触发器？触发器的使用场景有哪些？MySQL中都有哪些触发器？ 常用SQL语句SQL语句主要分为哪几类SQL语句的语法顺序：超键、候选键、主键、外键分别是什么？SQL 约束有哪几种？六种关联查询表连接面试题有2张表。1、交叉连接(笛卡尔积)2、内连接结果3、左连接结果4、右连接结果5、全表连接的结果（MySql不支持，Oracle支持） 什么是子查询mysql中 in 和 exists 区别varchar与char的区别varchar(50)中50的涵义int(20)中20的涵义mysql为什么这么设计mysql中int(10)和char(10)以及varchar(10)的区别FLOAT和DOUBLE的区别是什么？drop、delete与truncate的区别UNION与UNION ALL的区别？ SQL优化说出一些数据库优化方面的经验?怎么优化SQL查询语句吗你怎么知道SQL语句性能是高还是低SQL的执行顺序如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因？SQL的生命周期？大表数据查询，怎么优化超大分页怎么处理？mysql 分页慢查询日志关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？为什么要尽量设定一个主键？主键使用自增ID还是UUID？字段为什么要求定义为not null？如果要存储用户的密码散列，应该使用什么字段进行存储？如何优化查询过程中的数据访问如何优化长难的查询语句优化特定类型的查询语句优化关联查询优化子查询优化LIMIT分页优化UNION查询优化WHERE子句SQL语句优化的一些方法 数据库优化为什么要优化数据库结构优化MySQL数据库cpu飙升到500%的话他怎么处理？大表怎么优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？1、垂直分区2、垂直分表3、水平分区4、水平分表：数据库分片的两种常见方案：分库分表后面临的问题 MySQL的复制原理以及流程主从复制的作用MySQL主从复制解决的问题MySQL主从复制工作原理基本原理流程，3个线程以及之间的关联复制过程 读写分离有哪些解决方案？备份计划，mysqldump以及xtranbackup的实现原理数据表损坏的修复方式有哪些？ 大部分都是参考ThinkWon大神的，我只是自己添加删除了一些题，整理了格式
什么是SQL？ 结构化查询语言(Structured Query Language)简称SQL，是一种数据库查询语言。 作用：用于存取数据、查询、更新和管理关系数据库系统。
什么是MySQL? MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。在Java企业级开发中非常常用，因为 MySQL 是开源免费的，并且方便扩展。 MySql, Oracle，Sql Service的区别 Sql Service只能在Windows上使用，而MySql和Oracle可以在其他系统上使用， 而且可以支持数据库不同系统之间的移植MySql开源免费的，Sql Service和Oracle要钱。我从小到大排序哈，MySql很小，Sql Service居中，Oracle最大Oracle支持大并发量，大访问量，Sql Service还行，而MySql的话压力没这么大，因此现在的MySql的话最好是要使用集群或者缓存来搭配使用Oracle支持多用户不同权限来进行操作，而MySql只要有登录权限就可操作全部数据库安装所用的空间差别也是很大的，Mysql安装完后才几百M而Oracle有几G左右，且使用的时候Oracle占用特别大的内存空间和其他机器性能。做分页的话，MySql使用Limit，Sql Service使用top，Oracle使用rowOracle没有自动增长类型，Mysql和Sql Service一般使用自动增长类型 数据库三大范式是什么 第一范式：每个列都不可以再拆分。
第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。
第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。
在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。事实上我们经常会为了性能而妥协数据库的设计。
mysql有关权限的表都有哪几个 MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql\_install\_db脚本初始化。这些权限表分别user，db，table\_priv，columns\_priv和host。下面分别介绍一下这些表的结构和内容：
user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。db权限表：记录各个帐号在各个数据库上的操作权限。table_priv权限表：记录数据表级的操作权限。columns_priv权限表：记录数据列级的操作权限。host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。 数据库经常使用的函数 count(*/column)：返回行数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/625a6e1c3bd9bf79a8ca4aea260bb08e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a7f8685316508287242ccae57f1f37a/" rel="bookmark">
			超硬核！一篇文章彻底搞懂【二叉树】及的前序、中序、后序三种遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		树的概念与特性 1 树的概念 树是类似于链表的线性结构，但又是一种典型的非线性的结构；树具有很强的层级性，相比于线性结构，其时间复杂度更低，效率更高；读者可以联系，生活中看见的树； 2 树的术语 先看一张树的图片如下，去除图中的箭头和相关术语，树就是一种非线性的层级结构； 树的相关术语如下：
根节点： 没有父节点的节点，上图 A节点；兄弟节点：具有相同的父节点的孩子节点；比如 F,G互为兄弟节点；叶子节点：没有孩子节点的节点；比如D,F,G,I,J；祖先节点与孙节点：如果存在根节点A到节点 J 的路径，并且存在节点E出现在该路径上，则称E是节点 J 的祖先节点，J是 E 的孙节点；A B E H 都可以算是 J 的祖先节点；节点大小：节点的大小是指节点拥护的孙节点个数，包括自身； 比如E 节点大小为4；节点的深度：指根节点到节点的路径长度 ； 比如 (A-B-D ), 两个 链，即D节点的深度为2；节点的高度：指节点到最深节点的 路径长度；比如 (E - H -J), 两个链, 即E节点的高度为2；树的层级：具有相同深度的集合称为树的层级；比如 B和C ； 又比如 D,E,F,G树的高度和深度： 树的深度指所有节点中深度的最大值，树的高度指所有节点中高度的最大值；树的高度等于树的深度 3 树的类型 二叉树： 如果一棵树中每个节点有0个或者1个或者2个节点，则称该树为二叉树；故空树也是二叉树；
严格二叉树: 树的每个节点都有左孩子右孩子或者没有孩子；
斜树：斜树的每个节点只有一个孩子；若斜树的每个节点都只有左孩子则称为左斜树，若斜树的每个节点只有右孩子则称为右斜树； 满二叉树：所有的父节点都存在左孩子和右孩子，并且所有的叶子结点都在同一层上，则称该类树为满二叉树 完全二叉树：对于一棵具有n个节点的二叉树按照层级编号，同时，左右孩子按照先左孩子后右孩子编号，如果编号为i的节点与同样深度的满二叉树中编号为i的节点在二叉树中的位置完全相同，则这棵二叉树称为完全二叉树；故满二叉树一定是完全二叉树，反之不成立 2.4满二叉树的性质 满叉树的节点个数: 假设满二叉树层级为k，根据 数学归纳法和等比数列求和公式可得 2^0 + 2^1 +…+ 2^k = 2^(k+1) - 1; 推导过程如下图；
满二叉树的叶子节点个数：根据满二叉树的结构可知，第k层就是叶子节点所在的层，故叶子节点个数为 2^k个
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a7f8685316508287242ccae57f1f37a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa65e45d9f1e388b14709c2d74f863a2/" rel="bookmark">
			无迹卡尔曼滤波 (Unscented Kalman Filter)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无迹卡尔曼滤波是在卡尔曼滤波的基础上，进行了一系列的改进，得到的一种新的滤波算法。无迹卡尔曼滤波中不需要假设状态变量的变化是线性的，也不用假设观测变量和状态变量的关系是线性的。所以需要我们指定变化的函数。但是，无迹卡尔曼滤波也不是没有限制条件。卡尔曼滤波中观测变量和测量变量都需要服从正态分布，这个条件在这里也是需要的。关于卡尔曼滤波，可以参考之前的博客，这里不再赘述。
无迹变换（Unscented Transform） 根据卡尔曼滤波的计算公式，我们知道，卡尔曼滤波会根据之前的状态变量 x t − 1 x_{t-1} xt−1​来预测当前的状态变量 x t x_t xt​。然后根据观测变量 y t y_t yt​来预测当前的状态变量 x t x_t xt​。然后根据两者的协方差矩阵来确定卡尔曼增益 K K K，用来判断当前的预测中，根据状态变量的预测的可信度大小以及根据测量变量预测的可信度大小。然后找到一个最优解，即卡尔曼滤波的预测结果。但是对于无迹卡尔曼滤波来讲，协方差矩阵的计算并不容易。因为状态变量的变化以及观测变量和状态变量的关系不是线性的。无法通过矩阵计算直接得到协方差矩阵。那么如何去计算当前的协方差矩阵。目前有两种解决方案：
首先是利用蒙特卡罗方法模拟大量数据点，得到转换后数据的分布均值和方差，然后计算协方差矩阵。这种方法计算的精确程度和模拟数据点数量有关。但是大量的模拟数据点会增加计算量。所以不是一个好的选择。然后就是无迹变换，这种方法能通过很少的采样点数据，计算出转换后数据的分布均值和方差，从而计算协方差矩阵。
对于一组数据 x = { x 1 , x 2 , . . . , x n } x=\{x_1, x_2, ..., x_n\} x={x1​,x2​,...,xn​}，经过一个变换 f f f后，得到了另外一组数据 y = { y 1 , y 2 , . . . , y n } y=\{y_1, y_2, .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa65e45d9f1e388b14709c2d74f863a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea9ecfa9d1081f5a0ab8814e2d288871/" rel="bookmark">
			Unity&#43;C#开发笔记（三）| 控制按钮的禁用跟变灰 | ╭(●｀∀´●)╯╰(●’◡’●)╮
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**********下面开始正文**********
this.GetComponent&lt;Button&gt;().enabled= false; //禁用 this.GetComponent&lt;Button&gt;().interactable = false; //禁用与变灰 **************正文完**************
Unity+C#开发笔记（三）| 控制按钮的禁用跟变灰 | ╭(●｀∀´●)╯╰(●’◡’●)╮
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37b94eb9f54e036e99fe831292d8ec5c/" rel="bookmark">
			配置java 运行环境 jdk
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、右击计算机，点击“属性”
2、点击高级系统设置
3、点击高级，在点击“环境变量”
4、点击新建（下面那个），变量名输入：“JAVA_HOME” 变量值输入java软件安装路径，这一步实际上就是找你的jdk.1.8.0_131在哪里
5、找到变量名为path，点击“编辑”，在后面添加 %JAVA_HOME%\bin\ 注意：(直接在后面添加即可，千万不要删除已经存在的)
6、同时按查下 键盘上 ”win键+R键“，输入cmd，点击确定
7、输入“java -version”，按一下回车键(Enter),出现以下文字说明则安装成功，如果出现其他则说明安装失败，你可能需要从第4步重新配置
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/085f58e3700724c9b225b3ccb0c20895/" rel="bookmark">
			洛谷P5703 【深基2.例5】苹果采购
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 **
P5703 【深基2.例5】苹果采购 题目描述
现在需要采购一些苹果，每名同学都可以分到固定数量的苹果，并且已经知道了同学的数量，请问需要采购多少个苹果？
输入格式
输入两个不超过 10^9的正整数，分别表示每人分到的数量和同学的人数。
输出格式
一个整数，表示答案。保证输入和答案都在int范围内的非负整数。
输入输出样例
输入：5 3
输出：15
**
#include&lt;stdio.h&gt; int main(){ int m,n; scanf("%d %d",&amp;m,&amp;n); printf("%d",m*n); return 0; } 对于printf，在我的第一篇有提到基本格式为：printf（"&lt;格式化字符串&gt;", &lt;参量表&gt;），而对于参量表，我们可以用赋值语句，以本题为例，printf("%d",m*n); 意即计算a*b并以%d的格式输出，即a乘b作为整数输出。此时也等于
int c=a*b; printf(“%d”,c); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b22889fe583ccda842dd6d42dff0846/" rel="bookmark">
			Python requests请求爬虫
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python 疫情__数据【包括国内外】 更多关于机器学习的知识请加关注哟~~。若需联系请私信或者加博主联系方式:
新浪微博:Jetuser
微信公众号：不一样的数据分析
抖音号：1858359940
CSDN : Jetuser-data
前言 这几天上班忙的不可开交，纵观新型冠状病毒近日在国外大势猖獗，随国内控制的不错，但仍需努力，不可懈怠，武汉加油！中国加油！全世界人民加油！刚好赶上周末，就闲下来写一下python requests请求方式爬取国内外疫情数据，我的方法是最易懂、最高效、爬取是最全的，我以人头担保【惊恐/滑稽】，没有谁的会比我的全。这次我将以该百度链接进行抓取。
1、如何开始？ 首先我们看看该上网页的数据
可以看到数据在网页上显示为这个鬼样子，那么我们如何将其抓取下来呢？
2、思路解析 其实爬虫就如同我们做事情一样的，按部就班，一步一个脚印，解决途中一步步困难。包括读取网页、数据读取、数据清洗以及后期的可视化展现…
我的思路就是先将网页request出来，text读取里面的内容，然后使用强大的正则表达式匹配出我们想要的内容再写入到excel 中，注意这样是得到一天的数据，那么我们要写一个while循环，让其固定在每天晚上11点过进行自动爬取，每天的数据依次累加到excel里面，最终得到完整的表格 [ps:我这里用Google浏览器]。
3、爬虫解析 进入页面后按键盘上的F12，依次点击 Network–&gt;XHR–&gt; 并按下ctrl+R，此时点击下方出现的XHR，找到
Request Headers下的Referer，你会看到这是一个链接，这个链接就是我们要请求的网页，将其复制下来。
4、爬虫步骤 4.1 请求网页响应且返回数据 url = 'https://voice.baidu.com/act/newpneumonia/newpneumonia/?from=osari_pc_3'
response = requests.get(url=url)
response.text
这时候往下滑动你会得到一串带有"\u"的字符串
"subList":[{"city":"\\u897f\\u5b81","confirmed":"15","died":"","crued":"1
5","confirmedRelative":"0","curConfirm":"0","cityCode":"66"},{"city":"\\u6d77\\u5317\\u5dde","confirmed":"3","died":"","crue
d":"3","confirmedRelative":"0","curConfirm":"0","cityCode":"67"
}]},
{"confirmed":"298","died":"2","crued":"30","relativeTime":"1585
324800","confirmedRelative":"16","diedRelative":"0","curedRelat
ive":"0","curConfirm":"266","curConfirmRelative":"16","icuDisab
le":"1","area":"\\u53f0\\u6e7e","subList":[]},
{"confirmed":"641","died":"4","crued":"118","relativeTime":"158
5324800","confirmedRelative":"64","diedRelative":"0","curedRelative":"1","curConfirm":"519","curConfirmRelative":"63","cityCode":"2912","icuDisable":"1","area":"\\u9999\\u6e2f","subList":[]}
这TM是什么鬼，好！既然是鬼就收它，我猜这个Unicode就是城市名称，打开站长解码输入带有"\u"的任意字符比如"\u897f\u5b81"你会得到“\西\宁”二字,果然就是，那么其实我们已经找到了，只是需要将其解码出来即可。
此时我们又有新思路，先将中国疫情数据找到并且匹配出来，再将国外疫情数据找到又匹配出来，最终得到每个字段并且存入excel即可。
4.2 找到数据列表 其实将带有"\u"的字符串进行解码可知，网页上的图表数据在返回的"captain-config"到"bundle"之间，于是有
datas=re.findall(r'id="captain-config"&gt;(.*?)"bundle"', response.text)# 得到初步 来源方式
data=re.findall(r'(.*),"version"', datas[0])# 得到初步 来源方式 加？是贪婪模式 最短匹配
这样就会得到我们所需的数据集，但是我后来发现，老是这样一次次解码太麻烦，干脆一次性将其转为中文，便于观察，但是带有"\u"的翻译出来又多一个""，所以先将其替换掉再转为中文，于是有
data0 = 'u'+'\''+data[0].replace('\\\\', '\\')+'\''
data3=eval(data0) # 替换斜杠并转编码 神奇的eval函数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b22889fe583ccda842dd6d42dff0846/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0054463b0d0cf73c86c7718c466528d9/" rel="bookmark">
			1103 Integer Factorization (30分)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		The K−P factorization of a positive integer N is to write N as the sum of the P-th power of K positive integers. You are supposed to write a program to find the K−P factorization of N for any positive integers N, K and P.
Input Specification:
Each input file contains one test case which gives in a line the three positive integers N (≤400), K (≤N) and P (1&lt;P≤7).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0054463b0d0cf73c86c7718c466528d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7d2e978fb8b0924e856c77e4a80442a/" rel="bookmark">
			markdown编译结果中标题消失的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决办法：
https://stackoverflow.com/questions/13648124/header-label-in-doxygen-markdown-page-makes-header-title-disappear
http://www.voidcn.com/article/p-gmkxtrdp-btr.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9782ab44d9fd151d306cd63ede8aba02/" rel="bookmark">
			微信读书电脑版更改字体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信读书电脑版，在网页上看书比手机上看舒服多了。最近又租校色仪校了一下显示器的色彩。只是微信读书 PC 版只能改字体大小，不能更改字体。于是写了一个 Tampermonkey 脚本，更改了几行 CSS，前景色和背景色参照 iBooks，字体也设定为楷体加粗。Mac OS + Firefox + Tampermonkey 测试通过。
// ==UserScript== // @name WeRead // @namespace http://tampermonkey.net/ // @version 0.1 // @description try to take over the world! // @author Lonely // @match https://weread.qq.com/web/reader/* // @grant GM_addStyle // ==/UserScript== GM_addStyle("*{font-family: Kaiti,STKaiti,FangSong, SimSun; !important;}"); GM_addStyle(".readerTopBar{font-family: SourceHanSerifCN-Bold !important;}"); GM_addStyle(".bookInfo_title{font-family: SourceHanSerifCN-Bold !important;}"); GM_addStyle(".readerTopBar_title_link{font-family: SourceHanSerifCN-Bold; !important; font-weight:bold !important;}"); GM_addStyle(".readerTopBar_title_chapter{font-family: SourceHanSerifCN-Bold !important;}"); GM_addStyle(".wr_whiteTheme .renderTargetContainer .renderTargetContent .wr_readerImage_opacity {background-color: rgba(249,243,232,100) !important;}"); GM_addStyle(".wr_whiteTheme .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9782ab44d9fd151d306cd63ede8aba02/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a7c2e2e36e2ed1b37bb73dea2d4fe06/" rel="bookmark">
			零基础如何自学编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自品略图书馆 http://www.pinlue.com/article/2020/04/1323/1710162866516.html
编程的学习是一件比较枯燥的事情，特别对于初学者来说简直如同天书一般。下面小编就为大家介绍一下零基础如何自学编程的方法。
如何自学编程 一、书本加视频
对于初学者来说，可以采用视频+书籍的方式进行学习。这两种方式形成互补关系。
编程教学视频可以让你迅速掌握编程，但通常比较生动、浅显，不成系统。而书本是比较系统，深入，但是枯燥，所以最好的方法是书和视频结合。
二、选择编辑器
学习编程最开始的一点就是找到一个自己用着习惯的编辑器，这里推荐Sublime Text3和Notepad++，之后有适合自己的可以随时更换。
三、熬
自学编程难免遇到这种现象：学了一两个月，发现自己会的不多。
编程在一开始不会有那么大的反馈，这种现象非常正常!关键是你要坚持个三个月到半年的时间，熬过这个艰难的入门期。
四、选择语言
刚开始推荐学习HTML，了解什么是编程，而HTML属于最简单的一种语言，虽然它并不是编程语言，但学习后你会对整个编程有一个整体的理解，最关键的是它很简单。
五、加深语言范围
了解HTML之后推荐学习CSS，它和HTML是一种配合使用的，我们见到的网页都是用HTML与CSS编写的，它同样很简单。
六、寻找编程项目
有些程序员学习编程一上来就想着月薪1W+以上，这样的学习过程会非常痛苦，很容易放弃。
最好是奔着一个小项目而学习编程，当你把作品做出来了，就有成就感，同时基本上具备找工作的能力，直接找个初级的开发岗位，再进阶，你的自学之路功与名都有了。
编程热门语言 1、Java
Java 这种老牌编程语言，虽然一直被诟病语法臃肿，但是其实随着 Java 版本的更新，已经逐渐支持了很多新语言的特性。并且在2017年的TIOBE编程语言排行榜上，Java每月总是稳坐第一宝座，毋庸置疑，它仍然是市场上最流行和最火爆的编程语言。
2、Python
AI兴起，Python开始大热。Python是一种用于 Web 开发的通用编程语言，也是软件开发人员的支持语言。它可广泛用于科学计算，数据挖掘和机器学习。人工智能大量依赖数据，而Python 在数据分析、数据挖掘方面实用性非常的强。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61ce1d49fe268fb924ecc6aaf66b8503/" rel="bookmark">
			初学gitlab设置访问权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写本文的目的是，能够实现开发代码共享。
1.打开一个项目your project 主界面如下图所示： 2.将gitlab项目私有设置为内部 在左侧工具栏中找到Setting，并点进去，将Project visibility设置为Internal（内部的），保存：
3.添加成员与权限 在Settings/Members中添加成员（members）与不同的权限（permission）。
其中，权限可选择有这几种（Guest、Reporter、Developer、Maintainer）： 解释，此处参考：
Guest：可以创建issue、发表评论，不能读写版本库
Reporter：可以克隆代码，不能提交，QA、PM可以赋予这个权限
Developer：可以克隆代码、开发、提交、push，RD可以赋予这个权限
Maintainer：可以创建项目、添加tag、保护分支、添加项目成员、编辑项目，核心RD负责人可以赋予这个权限
Owner：可以设置项目访问权限 - Visibility Level、删除项目、迁移项目、管理组成员，开发组leader可以赋予这个权限
参考 1.GitLab 如何修改项目从私有到公有 2.Gitlab用户在组中有五种权限
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b76239006803d0c58e913c309e863d9/" rel="bookmark">
			Hystrix
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Hystrix基本概念 1、Spring Cloud调用接口过程 Spring Cloud 在接口调用上，大致会经过如下几个组件配合：
Feign -----&gt;Hystrix —&gt;Ribbon —&gt;Http Client（apache http components 或者 Okhttp） 具体交互流程上，如下图所示：
（1）接口化请求调用当调用被@FeignClient注解修饰的接口时，在框架内部，将请求转换成Feign的请求实例feign.Request，交由Feign框架处理。
（2）Feign ：转化请求Feign是一个http请求调用的轻量级框架，可以以Java接口注解的方式调用Http请求，封装了Http调用流程。
（3）Hystrix：熔断处理机制 Feign的调用关系，会被Hystrix代理拦截，对每一个Feign调用请求，Hystrix都会将其包装成HystrixCommand,参与Hystrix的流控和熔断规则。如果请求判断需要熔断，则Hystrix直接熔断，抛出异常或者使用FallbackFactory返回熔断Fallback结果；如果通过，则将调用请求传递给Ribbon组件。
（4）Ribbon：服务地址选择 当请求传递到Ribbon之后,Ribbon会根据自身维护的服务列表，根据服务的服务质量，如平均响应时间，Load等，结合特定的规则，从列表中挑选合适的服务实例，选择好机器之后，然后将机器实例的信息请求传递给Http Client客户端，HttpClient客户端来执行真正的Http接口调用；
（5）HttpClient ：Http客户端，真正执行Http调用根据上层Ribbon传递过来的请求，已经指定了服务地址，则HttpClient开始执行真正的Http请求
2、Hystrix概念 Hystrix 是一个供分布式系统使用，提供延迟和容错功能，保证复杂的分布系统在面临不可避免的失败时，仍能有其弹性。
比如系统中有很多服务，当某些服务不稳定的时候，使用这些服务的用户线程将会阻塞，如果没有隔离机制，系统随时就有可能会挂掉，从而带来很大的风险。SpringCloud使用Hystrix组件提供断路器、资源隔离与自我修复功能。下图表示服务B触发了断路器，阻止了级联失败
二、feign结合Hystrix使用 改造service-edu模块
1、在service的pom中添加依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--hystrix依赖，主要是用 @HystrixCommand --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--服务注册--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--服务调用--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; 2、在配置文件中添加hystrix配置 #开启熔断机制 feign.hystrix.enabled=true #设置hystrix超时时间，默认1000ms hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=6000 3、在service-edu的client包里面创建熔断器的实现类 @Component public class VodFileDegradeFeignClient implements VodClient { @Override public R removeVideo(String videoId) { return R.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b76239006803d0c58e913c309e863d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f723ab44a70cf952f8efbbbaaf41c42/" rel="bookmark">
			脉冲触发器(JK触发器)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【 1. 一般脉冲触发器 】 电路结构 将边沿触发器的两个电平触发D触发器换成电平触发的SR触发器。
工作原理 即
上升沿：
CLK由0→1时，CLK’由1→0，
FF1由“锁存”→正常工作，FF2由正常工作→“锁存”
Q1由锁存时的不变→可随S、R变化，Q保持不变下降沿：
CLK由1→0时，CLK’由0→1，
FF1由正常工作→“锁存”，FF2由“锁存”→正常工作
Q1由可随S、R变化→锁存时的不变，Q由锁存时的不变→受输入Q1影响时的状态输出Q在一个CLK周期内只变化一次，解决了电平触发方式的空翻问题（空翻：在一个时钟周期内触发器翻转一次以上的现象）。 脉冲触发与边沿触发的区别 即：
由于边沿触发、脉冲触发电路结构上的区别：脉冲触发由两个电平触发的SR触发器组成，SR触发器的两个输入信号会出现“保持”原输出状态的情况。
故脉冲触发器需要考虑全部CLK=1期间主触发器状态的变化情况。
功能描述 时序图 【 2. JK触发器 】 设计目的 避免一般脉冲触发器的主触发器输出不定的状态。
电路结构 工作原理 即
J=K=1时，主触发器输出会进行翻转。在CLK=1期间，从触发器锁存主触发器第一次翻转（翻转成与初态相反的状态）后的状态，并在CLK=0即下降沿时，输出该状态。 功能描述 J K 触 发 器 特 性 方 程 ： Q ∗ = J Q ′ + K ′ Q JK触发器特性方程： Q^*=JQ'+K'Q JK触发器特性方程：Q∗=JQ′+K′Q
时序图 【 3. 脉冲触发方式的动作特点 】 【 4. 多输入端的JK触发器 】 【 5. 可异步置零、置一的JK触发器 】 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b685e2e65062c12f530edf1dac208107/" rel="bookmark">
			算法__流水作业调度问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、问题描述： n个作业{1，2，…，n}要在由2台机器M1和M2组成的流水线上完成加工。每个作业加工的顺序都是先在M1上加工，然后在M2上加工。M1和M2加工作业i所需的时间分别为ai和bi。流水作业调度问题要求确定这n个作业的最优加工顺序，使得从第一个作业在机器M1上开始加工，到最后一个作业在机器M2上加工完成所需的时间最少。
2、问题分析
直观上，一个最优调度应使机器M1没有空闲时间，且机器M2的空闲时间最少。在一般情况下，机器M2上会有机器空闲和作业积压2种情况。设全部作业的集合为N={1，2，…，n}。S是N的作业子集。在一般情况下，机器M1开始加工S中作业时，机器M2还在加工其他作业，要等时间t后才可利用。将这种情况下完成S中作业所需的最短时间记为T(S,t)。流水作业调度问题的最优值为T(N,0)。 设π是所给n个流水作业的一个最优调度，它所需的加工时间为 aπ(1)+T’。其中T’是在机器M2的等待时间为bπ(1)时，安排作业π(2)，…，π(n)所需的时间。
记S=N-{π(1)}，则有T’=T(S,bπ(1))。
证明：事实上，由T的定义知T’&gt;=T(S,bπ(1))。若T’&gt;T(S,bπ(1))，设π’是作业集S在机器M2的等待时间为bπ(1)情况下的一个最优调度。则π(1)，π'(2)，…，π'(n)是N的一个调度，且该调度所需的时间为aπ(1)+T(S,bπ(1))&lt;aπ(1)+T’。这与π是N的最优调度矛盾。故T’&lt;=T(S,bπ(1))。从而T’=T(S,bπ(1))。这就证明了流水作业调度问题具有最优子结构的性质。
由流水作业调度问题的最优子结构性质可知:
从公式（1）可以看出，该问题类似一个排列问题，求N个作业的最优调度问题，利用其子结构性质，对集合中的每一个作业进行试调度，在所有的试调度中，取其中加工时间最短的作业做为选择方案。将问题规模缩小。公式（2）说明一般情况下，对作业集S进行调度，在M2机器上的等待时间，除了需要等该部件在M1机器上完成时间，还要冲抵一部分原来的等待时间，如果冲抵已成负值，自然仍需等待M1将作业做完，所以公式取max{t-ai,0}。
3、动态规划法求解思路
假设有一组作业需要在M1和M2 两台机器上进行流水作业，他们在M1和M2上的作业时间如下表：
问题是如何安排他们的加工顺序，使得，到最后一个作业在机器M2上加工完成所需要的时间最少。也就是所有作业在两台机器全部加工完成所需的时间最少。
思路如下：考虑如果只有一个作业的情况，肯定所需时间就是它自身需要在M1和M2 上的加工时间总和；如果有两个作业就要考虑在两种不同的加工顺序下选取最优的一种作为候选，三个作业的时会出现三种组合情况(0,(1,2)); (1,(0,2)); (2,(0,1)),拿第一种为例,它表示先加工作业0,然后再按照作业1和作业2的优化顺序加工;将三种的作业时间计算出来,取最小值,即为三个作业的优化结果,同理可对更多的作业进行排序优化。具体做法是，用类似矩阵连乘的办法，自底向上将所有能的情况计算出来，并产生一个表，供后面的计算查用，减少重复计算的工作量。
对于j1 作业M2 的等待时间为b0,实际上在M2加工j0作业的同时，M1 并行加工j1,实际它需要等待b1-a0时间。
2+4+(5-4)+2=9
从J0和J1两个作业的加工顺序，可以看出，先加工J0后J1，所用时间最短为9，将其填入表中，依此类推，即可得出最优解。
a4+a0+a2+a1+a3+[(b4+b0+b1+b2)-(a0+a1+a2+a3)]+b3
=1+2+3+4+6+[(7+5+2+3)-(2+4+3+6)]+1
=16+[17-15]+1=19
选其中加工时间短的作为候选方案；在具体计算时非最优子集不必考虑，这样可以减少计算次数。
4、流水作业调度的Johnson法则
设兀是作业集S在机器M2的等待时间为t时的任一最优调度。若在这个调度中，安排在最前面的两个作业分别是i 和j ，即π(1)=I,π(2)=j。则有动态规划递归式可得
其中
如果作业i和j满足min{bi,aj} ≥min{bj,ai},则称作业i和j满足Johnson不等式。如果作业i和j 不满足Johnson不等式，则交换作业i和j满足Johnson不等式。
证明 ：在作业集S中，对于机器M2 的等待时间为t的调度π，交换作业i和j 的加工顺序，得到作业集S 的另一个调度π’，它所需的加工时间为
当作业i和j 满足Johnson 不等式 min{bi,aj} ≥min{bj,ai}时，有
从而
由此可得
因此，对任意t 有
从而，tij≤tji,由此可见，换句话说，当作业i 和j不满足Johnson 不等式时，交换它们的加工顺序后，作业i和j满足Johnson 不等式，且不增加加工时间。由此可知，对于流水作业调度问题，必存在最优调度π，使得作业π(i)和π(i+1)满足Johnson 不等式：
这样的调度π称为满足Johnson 法则的调度。进一步还可以证明，调度满足Johnson 法则当且仅当对任意i&lt;j 有：
由此可知，任意两个满足Johnson 法则的调度具有相同的加工时间，从而所有满足Johnson 法则的调度均为最优调度。
5、流水作业调度问题Johnson算法
从上面的分析可知，流水作业调度问题一定存在满足Johnson法则的最优调度，且容易由下面的算法确定：
流水作业调度问题的Johnson算法：
(1)令N1={i|ai&lt;bi},N2={i|ai&gt;=bi};
(2)将N1中作业按ai的非减序排序；将N2中作业按bi的非增序排序；
(3)N1中作业接N2中作业构成满足Johnson法则的最优调度。 Johnson算法中分类及排序的作用（验证不等式）设数组c[]为排序后的作业排列，排序结果如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b685e2e65062c12f530edf1dac208107/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ec9df141b9168ce64afee4a127ec046/" rel="bookmark">
			ubuntu18.04 设置状态栏时间显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Ubuntu16是有时间显示的，18默认没有，但是这很不人性啊，于是打算解决这个问题
解决方法：
在Ubuntu商店中搜索tweaks 然后点击安装Gnome tweaks 选择在top bar里面可以显示时间 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccb07eea65869044a5c3a8d8c32e8621/" rel="bookmark">
			Spring Data ES增删改查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先来个映射类
package com.czxy.changgou3.vo; import org.springframework.data.annotation.Id; import org.springframework.data.elasticsearch.annotations.Document; import org.springframework.data.elasticsearch.annotations.Field; import org.springframework.data.elasticsearch.annotations.FieldType; /** * Created by liangtong. */ @Document(indexName = "czxy56",type="book",shards = 4,replicas = 2) public class ESBook { @Id private Long id; @Field(type= FieldType.Text, analyzer = "ik_max_word") private String title; @Field(type=FieldType.Keyword , index = true) private String images; @Field(type=FieldType.Float) private Float price; } •步骤一：测试类中，直接注入ElasticsearchTemplate
•步骤二：调用对应的API进行操作
代码实现
package com.czxy.changgou3.elasticsearch; import com.czxy.changgou3.TestApplication; import com.czxy.changgou3.vo.ESBook; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.boot.test.context.SpringBootTest; import org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccb07eea65869044a5c3a8d8c32e8621/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8ff44bbd1f64d9bacccf32a41015f67/" rel="bookmark">
			span行内元素如何转为块级元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在css中span标签为行内元素，需要对它单独定义样式才能产生变化，但有些情况需要将它转为按块元素展示才能达到我们想要的效果。这时可以在span的样式中增加 display:inline-block 强制转换为行内块元素即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adf473cc3a3832bb1b1182aa4cb07a40/" rel="bookmark">
			VS Code终端窗口（TERMINAL）无法输入命令问题及解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出现的问题： 新安装的VS Code终端窗口无法输入命令
解决办法： 右键VS Code快捷方式，点击属性，打开“兼容性”标签，勾选"以管理员身份运行此程序"，点击确定。
如下：
结果： 修改完成之后重启VS Code，还是不可以正常在终端窗口输入命令。
最后解决办法： 1.win+r 打开系统命令提示符cmd；
2.窗口左上角右键 -&gt; 属性 ,勾选“使用旧版本控制台”；
3.重启VS Code;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/468697c006352f06ca8f513c9717e46a/" rel="bookmark">
			感谢CSDN平台记录了我6年的点点滴滴
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 感谢CSDN平台记录了我6年的点点滴滴。 我的新博客如下： 博客园
https://www.cnblogs.com/ztguang/ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20f427d22b6f1b3f544a49323eb46282/" rel="bookmark">
			C语言一行语句太长的换行处理方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、C语言中代码的多行书写2、版权声明 1、C语言中代码的多行书写 对C语言初学者来说，编写的程序的功能很简单，一句代码很短，但是在实际开发中，参数往往很长很多，一句代码可能会很长，需要用多行才能书写。
如果我们在一行代码的行尾放置一个反斜杠，c语言编译器会忽略行尾的换行符，而把下一行的内容也算作是本行的内容。这里反斜杠起到了续行的作用。
strcpy(str,"aaaaaaaaaa\ bbbbbbbbb"); 如果我们不使用反斜杠，当我们试图初始化一个跨多行的字符串时，c语言编译器可能会发出警告或错误，如下面的语句是不正确的。
strcpy(str,"aaaaaaaaaa bbbbbbbbb"); C语言中还有字符串多行书写的方法，那就是将它写个多个字符串，C语言编译器会自动将这些字符串连接起来，如下：
strcpy(str,"aaabbbccc"); printf("str=%s=\n",str); // 输出str=aaabbbccc= strcpy(str,"aaa""bbb""ccc"); printf("str=%s=\n",str); // 输出str=aaabbbccc= strcpy(str,"aaa"\ "bbb"\ "ccc"); printf("str=%s=\n",str); // 输出str=aaabbbccc= sprintf(str,"aaabbbccc"); printf("str=%s=\n",str); // 输出str=aaabbbccc= sprintf(str,"aaa""bbb""ccc"); printf("str=%s=\n",str); // 输出str=aaabbbccc= sprintf(str,"aaa"\ "bbb"\ "ccc"); printf("str=%s=\n",str); // 输出str=aaabbbccc= 以上每段代码的输出结果完全一样，表达式：“aaa” “bbb” “ccc” 实际上相当于
“aaabbbccc”。
把字符串很长，参数很多的代码用多行书写，可以使程序代码结构更清晰，以下代码是我实际开发中用到的一句代码，这还不算长的。
2、版权声明 C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。
来源：C语言技术网（www.freecplus.net）
作者：码农有道
如果这篇文章对您有帮助，请点赞支持，或在您的博客中转发我的文章，谢谢。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/404a43e45d8457f51fc28c5b5c35c781/" rel="bookmark">
			延时队列demo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package com.jst.park.rabbit;
import java.util.HashMap;
import java.util.Map;
import javax.annotation.PostConstruct;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.amqp.core.AmqpTemplate;
import org.springframework.amqp.core.Binding;
import org.springframework.amqp.core.BindingBuilder;
import org.springframework.amqp.core.DirectExchange;
import org.springframework.amqp.core.Message;
import org.springframework.amqp.core.MessageProperties;
import org.springframework.amqp.core.Queue;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import com.alibaba.fastjson.JSON;
import com.jst.park.common.constant.MqCodeConstant;
import com.jst.park.common.util.ConfigUtil;
import com.jst.park.model.MqMsg;
import com.jst.park.service.car.BrandCarService;
import com.jst.prodution.base.bean.BaseBean;
/**
* 类名: CarBrandInfoQueueConfig&lt;/br&gt;
* 作者: lin
* 描述: 车辆品牌信息获取（获取易车网http://shenzhen.bitauto.com/） * 创建时间: 2018年8月9日下午3:33:42
* 版权及版本: Copyright(C)2018 jst版权所有
*/
//@Configuration
public class BrandCarInfoQueueConfig {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/404a43e45d8457f51fc28c5b5c35c781/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa54795e0a5623db75fcffa9f1be3dfe/" rel="bookmark">
			千图/千库/我图网/觅元素，终身会员来了！设计师的福利日！视觉运营室
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在很多素材网站、PPT办公音频网站、商业图片网站大多数都是会员制充值化得服务，如果没有刚入门或是做美工淘宝的小伙伴会经常遇到图片和素材的问题，花一大笔钱去购买所有网站的会员是个不可取的做法，如何减少自己的开销又能让自己在工作中的执行力度加快呢？小编为最近粉丝的大力支持与认可，决定整理我们多年以来的设计素材网站的账号共享给各位！
No.1 千图网
网站名称：千图网
站点素材：平面广告、电商淘宝、装修设计、元素素材、视频音频等
推荐指数：☆☆☆☆☆
站点概述：千图网集合了我们日常使用的素材，在日常工作中能有效的提高我们作图的效率，基本的插画、平面广告、公司的节假日活动海报的制作等。
No.2 千库网
网站名称：千库网
站点素材：平面广告、电商淘宝、装修设计、元素素材、视频音频等
推荐指数：☆☆☆☆
站点概述：千库网是千图网的孪生兄弟，是一个矢量图素材库，减少我们在日常所用的抠图，无背景颜色的图形、图片等。
No.3 我图网
网站名称：我图网
站点素材：平面广告、电商淘宝、装修设计、元素素材、视频音频等
推荐指数：☆☆☆☆
站点概述：我图网集合了我们日常使用的素材，在日常工作中能有效的提高我们作图的效率，基本的插画、平面广告、公司的节假日活动海报的制作等。
No.4 觅元素
网站名称：觅元素
站点素材：平面广告、电商淘宝、装修设计、元素素材、视频音频等
推荐指数：☆☆☆☆☆
站点概述：觅元素是千图网的孪生兄弟，是一个矢量图素材库，减少我们在日常所用的抠图，无背景颜色的图形、图片等。
如何获取终生设计VIP，参与一下方式即可哦！点击这里进入原文
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fa16bc6b21e6f096c20d9da9e1bf502/" rel="bookmark">
			XILINX AXI_Lite 总线详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文转载自FPGA之家
12.1前言
ZYNQ拥有ARM+FPGA这个神奇的架构，那么ARM和FPGA究竟是如何进行通信的呢？本章通过剖析AXI总线源码，来一探其中的秘密。
12.2 AXI总线与ZYNQ的关系
AXI（Advanced eXtensible Interface）本是由ARM公司提出的一种总线协议，Xilinx从6系列的FPGA开始对AXI总线提供支持，此时AXI已经发展到了AXI4这个版本，所以当你用到Xilinx的软件的时候看到的都是“AIX4”的IP，如Vivado打包一个AXI IP的时候，看到的都是Create a new AXI4 peripheral。
到了ZYNQ就更不必说了，AXI总线更是应用广泛，双击查看ZYNQ的IP核的内部配置，随处可见AXI的身影。
12.3 AXI总线和AXI接口以及AXI协议
总线、接口和协议，这三个词常常被联系在一起，但是我们心里要明白他们的区别。
总线是一组传输通道，是各种逻辑器件构成的传输数据的通道，一般由由数据线、地址线、控制线等构成。接口是一种连接标准，又常常被称之为物理接口。
协议就是传输数据的规则。
12.3.1 AXI总线概述
在ZYNQ中有支持三种AXI总线，拥有三种AXI接口，当然用的都是AXI协议。其中三种AXI总线分别为：
AXI4：（For high-performance memory-mapped requirements.）主要面向高性能地址映射通信的需求，是面向地址映射的接口，允许最大256轮的数据突发传输；
AXI4-Lite：（For simple, low-throughput memory-mapped communication ）是一个轻量级的地址映射单次传输接口，占用很少的逻辑单元。
AXI4-Stream：（For high-speed streaming data.）面向高速流数据传输；去掉了地址项，允许无限制的数据突发传输规模。
首先说AXI4总线和AXI4-Lite总线具有相同的组成部分：
（1）读地址通道，包含ARVALID, ARADDR, ARREADY信号；
（2）读数据通道，包含RVALID, RDATA, RREADY, RRESP信号；
（3）写地址通道，包含AWVALID，AWADDR, AWREADY信号；
（4）写数据通道，包含WVALID, WDATA，WSTRB, WREADY信号；
（5）写应答通道，包含BVALID, BRESP, BREADY信号；
（6）系统通道，包含：ACLK，ARESETN信号。
AXI4总线和AXI4-Lite总线的信号也有他的命名特点：
读地址信号都是以AR开头（A：address；R：read）
写地址信号都是以AW开头（A：address；W：write）
读数据信号都是以R开头（R：read）
写数据信号都是以W开头（W：write）
应答型号都是以B开头（B：back（answer back））
了解到总线的组成部分以及命名特点，那么在后续的实验中您将逐渐看到他们的身影。每个信号的作用暂停不表，放在后面一一介绍。
而AXI4-Stream总线的组成有：
（1）ACLK信号：总线时钟，上升沿有效；
（2）ARESETN信号：总线复位，低电平有效
（3）TREADY信号：从机告诉主机做好传输准备；
（4）TDATA信号：数据，可选宽度32,64,128,256bit
（5）TSTRB信号：每一bit对应TDATA的一个有效字节，宽度为TDATA/8
（6）TLAST信号：主机告诉从机该次传输为突发传输的结尾；
（7）TVALID信号：主机告诉从机数据本次传输有效；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fa16bc6b21e6f096c20d9da9e1bf502/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12f5eb641086f4e03e96b29075bd6cba/" rel="bookmark">
			IntelliJ IDEA 2020.1 稳定版发布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IntelliJ IDEA 2020.1 稳定版发布 转载：https://www.oschina.net/news/114775/intellij-idea-2020-1-released?from=20200412
idea插件：https://blog.csdn.net/w605283073/article/details/103266294
转载理由：看看
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86dc4914c75350f3f3ac0cb6ef571354/" rel="bookmark">
			探秘 Linux 之父 Linus Torvalds 的日常，一不小心就撸出两个创世神作！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公众号关注 「奇妙的 Linux 世界」
设为「星标」，每天带你了解圈内新鲜事！
“ Linux 之父 Linus Torvalds 是一个怎么样的人？他平时是怎么工作的？Linux 这么大的一个项目，大家如何协同开发？2016 年，他做客 TED，为我们展现了他鲜为人知的一面。他两次推动了技术的革命，第一次是 Linux，第二次是 Git，下面的访谈，详细记录了他为什么要做这两个项目， 他对开源的看法，以及他对自己的评价。
Chris Anderson（下文简称 CA ）：有件事情很奇怪。你的软件，Linux，运行于数百万的计算机中， 可以说是他驱动了网络。我想，全世界正在使用将近 15 亿台的安卓设备。每一台里都有你的软件。这非常了不起。你肯定有一个特别高大上的总部来实现这一切。我以前真这么想——到我看到这张照片（如下图），我被震惊了。真的惊了，这就是 linux 总部。
（笑声）
（掌声）
Linus Torvalds（下文简称 LT ）：好吧，让大家失望了。我不得不说，这张照片里最有意思的地方，被最多人问起的地方，就是那种会动的办公桌。这是我办公桌最有趣的地方，虽然我现在不怎么用它了。我觉得两者是有关系的。
我的工作方式是...。我不想要太多外来的刺激。大家能看到，我的墙是淡绿色的。据说精神病院的墙就是这种颜色。
（笑声）
这种颜色能让你平静，不会刺激到你。
其实大家看不到我的电脑（主机），只能看到我的显示器，我对电脑最主要的要求 —— 并不是性能强劲，尽管我也爱 —— 就是它必须没有任何声音。我认识一些在谷歌工作的人，他们在家里都有小型的数据中心，我可没这习惯。我的办公室也许是你见过最无聊的一个。我喜欢独自一人，享受安静。如果有猫进来，它会坐在我的大腿上，我喜欢听猫打呼噜，而不是听特烦的电脑风扇的声音。
LT：太了不起了，你的这种工作方式，才能让你运行如此庞大的一个技术帝国——确实是一个帝国——这是开源（软件）强大力量的一个最好例证。
请告诉我们你是如何理解开源的以及它又是如何一步一步发展成 Linux 的。
LT：我现在还是独自工作。真的，我独自一人在家工作，经常穿着浴袍干活。当一个摄影师来的时候，我才会穿戴整齐，所以（这张照片里）我是穿着衣服的。
（笑声）
我一直以来就是这样工作的。Linux 也是这样诞生的。Linux 并不是一个合作的产物，它是我一系列项目中的一个，纯粹出于当时自己的需要，部分原因是我需要得到结果，但更重要的原因是我享受编程。这段旅途的终点，在 25 年后的今天，我们仍未达到。当年我只是想做一个完全属于自己的项目，我压根就没想过开源这件事情。
但在那之后，随着项目越来越大，你会开始想让别人知道。感觉就像“哇，快来看看我的成果！”，但说实话，刚开始并没那么好。我把它放到网上供人下载，当时甚至还不是开源的。当然，所有的代码都是开放的，但我并没有想过要用我们今天所熟知的开源方法来改进它。我当时想的是， “看，这是我折腾了半年的成果，我想听听大家的意见。“
有人来找过我，在赫尔辛基大学，我有一个朋友是做开源软件的——当年还叫免费软件——他让我了解到，“嘿，你可以用那些已有的开源许可证”我考虑了一段时间。我其实有点担心商业利益牵涉其中，我想，很多人一开始会跟我一样，担心自己的工作成果会被人利用，不是吗？于是我决定了，“不管了“。然后...
CA：然后某一天，一些人对你的代码提出了些建议，你觉得“哇哦，真是不错，我都没想到这一点。对改进软件很有帮助。“
LT：其实最开始没有多少人直接改代码，而是提出很多的想法。让别人看一下你所做的项目——我想在其他行业也是这样——有人对你的代码感兴趣，仔细研究过，能给你反馈，给你建议。对我而言是非常重要的一件事。
当时我 21 岁，还很年轻，但在那之前，我人生一半时间都在敲代码。之前的每一个项目都是我独自完成的。有人开始评论我的代码，给予反馈，真是头一遭。他们甚至还没开始改代码，当对我来讲足以载入史册，因为我觉得，“我爱世人！”，别误会我， 其实我并不合群。
（笑声）
我并不爱世人
（笑声）
我爱电脑， 我喜欢通过发邮件互动， 因为这样能给你缓冲。但我真正喜欢的是 人们给出评论，参与我的项目。这样能让我的项目快速成长。
CA：有没有那样一个时间点， 你发现自己一直在做的项目 突然开始成型了， 你对自己说， “等一下，这事儿也许能做成， 不单单是一个我能得到良好反馈的个人项目， 而是能在整个科技界掀起轩然大波的大事”？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86dc4914c75350f3f3ac0cb6ef571354/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/473716831c14df6ec279ec75ab77dc85/" rel="bookmark">
			三种振幅调制AM、DSB、SSB
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【 1. 调制与解调 】 调制 用调制信号去控制载波信号的某一个参量的过程。
解调 调制的逆过程，即从已调波中恢复原调制信号。
【 2. 振幅调制AM 】 AM调幅波的数学表达式 波形 频谱 单一频率信号的频谱 限带信号调幅波的频谱 AM信号的生成原理框图 调幅波的频率 调幅波的功率 【 3. DSB 】 双边带调幅信号DSB（double sideband）
波形 频谱 【 4. SSB 】 单边带信号SSB（single sideband ）
实现 滤波法 相移法 相移滤波法 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a934a74d4d5dc9f7c0fd2d7dc9b894a9/" rel="bookmark">
			卡尔曼滤波算法思想理解 Kalman filter 第一篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		卡尔曼滤波算法思想理解 Kalman filter 第一篇 最近在初步的理解目标跟踪的领域， 其中一个非常经典的算法卡尔曼滤波Kalman filter是需要有很好的理解才行， 由于已经脱离了学校，懂得寻找资源学习就变的非常重要， 我会先找找国内资源有没有好的视频讲解算法， 但通常一搜下来的结果不是一开始就讲公式不讲来由， 不然就是讲的太差还好意思上传的， 对于这样的资源实在不敢花时间观看， 人生短暂， 实在不愿意做这样的赌注， 而确实许多q外的视频确实好，所以接下来我就以matlab官方在youtube 的channel所讲解的Karlman filter 作为学习基础， 并且记录
首先我们需要知道为什么需要卡尔曼滤波？
我们来举一个例子
太空船飞行到火星需要很强大的动力推进才有可能到的了对吧？
但是强大的动力也代表会产生极高的热能， 这热能是会将靠近燃烧室附近的机械组件融化的， 导致太空船损毁，如果要避免这样的问题， 我们必须严格密切的监控燃烧室内的温度， 是不是在推进器周围装个温度sensor就能解决问题？ 当然没那么简单， 前面提过超高温度会融化许多的机器组件， 那同样的你的sensor也一样会被融化， 于是我们将sensor装在燃烧室附近温度比较低的地方就行， 但是这样测量到的温度显然是不准确的， 卡尔曼滤波就是解决这样的问题而诞生
注意这里我们引入了一个概念就是 测量measurement
我们继续用太空船这个例子继续说明， W表示输入燃料， Tin， Text分别表示燃烧室内部温度以及外部温度（可以搭配上面的图对照）， 大家都知道航天方面的工程计算是必须严谨的， 所以在飞之前肯定已经陈列了许多的计算式来推算出输入W量的燃料会为燃烧室产生多少温度（就是下面的Mathematical model)， 也许你在地面上可以模拟的非常精准， 但实际等太空船上了太空又是另一回事了， 所以基本上是没办法单靠设计的数学式就能推算出Tin, Text的， 这个时候我们就需要状态观测器K（Kalman）来当做控制器， 调和y（测量值）和yhat（预测值）中间的误差，
这个状态观测器的作用就是想办法将 y 和 yhat 之间的误差降至最小
好 太空船的例子举到这边就可以了， 注意到了这里我们已经引入一共两个概念
测量measurement预测prediction 接下来用另一个例子加深印象也同时说明Kalman的原理
假设有一场比赛是关于自动驾驶的汽车， 决定胜出的关键就是 经过多次尝试之后 取最终平均停车的位置， 这个停下来的位置越靠近终点线， 就说明你设计的越好， 也能够胜出这场比赛
首先看看Team1, 明显偏离了终点线太远了， 而team2呢？ 虽然最终平均下来的位置确实在终点线上， 但是你看每一次停车的差距都非常大， 能算胜利吗？， 为了提高鉴别度， 必须将所有数据的方差值考虑进来，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a934a74d4d5dc9f7c0fd2d7dc9b894a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ff8ec9a8f0261838d606aa434090b4e/" rel="bookmark">
			PBR：双向反射分布函数(BRDF)介绍与Cook-Torrance模型的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PBR：双向反射分布函数(BRDF)介绍与Cook-Torrance模型的实现 BRDF简介 再介绍BRDF之前我们要引入渲染方程这个东西：
其中L表示辐射率，其公式为：
它表示了一个拥有辐射强度Φ的光源在单位面积A，单位立体角ω上的辐射出的总能量。
辐射率是辐射度量学上表示一个区域平面上光线总量的物理量，它受到入射光线与平面法线间的夹角θ的余弦值cosθ的影响：当直接辐射到平面上和法线夹角越大时，光线就越弱。
我们继续看渲染方程，在接收的光量由两部分组成，其中是自发光在方向的辐射光量，而’+‘号右边的公式则是我们的反射率方程。如果物体不会自发光，则：
该函数表示了表面A在接收了半球上所有的入射光量乘上，然后它们的累加在反射方向的光量为。用一个最简单的例子，假设场景只有一个光源，且忽视间接照明：
我们有：
这里的就是我们的BRDF函数。许多地方会看到BTDF(双向透射分布函数)，BSDF(双向散射分布函数)或者SVBRDF(空间变化的BRDF)等。BTDF表明若有些材料如玻璃等需要考虑镜面透射则可以使用。BSDF则是BRDF和BTDF的结合使用。基本BRDF或者SVBRDF已经能满足我们的需求了。
我们现在来看一下BRDF。其中ωo和ωi分别是表面法线(N)和视线方向(V)与光方向之间的夹角。因此就有了“双向反射分布函数”的美称。BRDF可以近似的求出每束光线对一个给定了材质属性的平面上最终反射出来的光线所作出的贡献程度。举例来说，如果一个平面拥有完全光滑的表面（比如镜面），那么对于所有的入射光线ωi而言BRDF函数都会返回0.0，只有一束与出射光线ωo拥有相同（被反射）角度的光线会得到1.0这个返回值。到目前为止已经提出了很多的BRDF模型包括Phong，Blinn-Phong，Lafortune，Torrance-Sparrow，Cook-Torrance，Ward各向异性，Oren-Nayar等等。其中Phong模型是我们最常见的也是最简单，但是由于其是经验型的，不符合能量守恒，我们本文就介绍Cook-Torrance模型。
Cook-Torrance模型 Cook-Torrance BRDF兼有漫反射和镜面反射两个部分：
这里的是早先提到过的入射光线中被折射部分的能量所占的比率，而是被反射部分的比率。BRDF的左侧表示的是漫反射部分，这里用来表示。这是Lambertian漫反射。右侧是我们的镜面反射部分。
Lambertian反射 Lambertian反射是用来模拟完美的漫反射模型。它以兰伯特余弦定律的名称而闻名。表面接收的光量与表面法线N和光方向L之间的角度成正比。
表明了：
漫反射颜色和成正比(∝为正比)。这还需要知道反照率albedo:
即反射光量和入射光量的比。我们用符号表示albedo。根据lambert模型我们就可以计算出漫反射的光量为：
但实际上并不是这样的，我们实际的lanbert公式为：
为什么要除以呢？根据lambert漫反射定义：
我们可以用积分计算出反射的光量：
即我们的反射总光量不能大于入射光量。求解出积分得：
但是我们定义的反照率属于[0,1]。所以看上式会有问题，我们只要将除以，便可以使式子正确，即：
所以我们的漫反射为：
BRDF的镜面反射部分 BRDF的镜面部分有如下形式：
Cook-Torrance BRDF的镜面反射部分包含三个函数，此外分母部分还有一个标准化因子 。字母D，F与G分别代表着一种类型的函数，各个函数分别用来近似的计算出表面反射特性的一个特定部分。三个函数分别为法线分布函数(Normal Distribution Function)，菲涅尔方程(Fresnel Rquation)和几何函数(Geometry Function)：
法线分布函数：估算在受到表面粗糙度的影响下，取向方向与中间向量一致的微平面的数量。这是用来估算微平面的主要函数。几何函数：描述了微平面自成阴影的属性。当一个平面相对比较粗糙的时候，平面表面上的微平面有可能挡住其他的微平面从而减少表面所反射的光线。菲涅尔方程：菲涅尔方程描述的是在不同的表面角下表面所反射的光线所占的比率。 以上的每一种函数都是用来估算相应的物理参数的，而且你会发现用来实现相应物理机制的每种函数都有不止一种形式。它们有的非常真实，有的则性能高效。这里我们其中D使用Trowbridge-Reitz GGX，F使用Fresnel-Schlick近似(Fresnel-Schlick Approximation)，而G使用Smith’s Schlick-GGX。
法线分布函数 法线分布函数D，或者说镜面分布，从统计学上近似的表示了与某些（中间）向量h取向一致的微平面的比率。举例来说，假设给定向量h，如果我们的微平面中有35%与向量h取向一致，则正态分布函数或者说NDF将会返回0.35。目前有很多种NDF都可以从统计学上来估算微平面的总体取向度，只要给定一些粗糙度的参数以及一个我们马上将会要用到的参数Trowbridge-Reitz GGX：
在这里h表示用来与平面上微平面做比较用的中间向量，而a表示表面粗糙度。
如果我们把h当成是不同粗糙度参数下，平面法向量和光线方向向量之间的中间向量的话(实际运算H = normalize(V(观察方向) + L(光线方向)))，我们可以得到如下图示的效果：
当粗糙度很低（也就是说表面很光滑）的时候，与中间向量取向一致的微平面会高度集中在一个很小的半径范围内。由于这种集中性，NDF最终会生成一个非常明亮的斑点。但是当表面比较粗糙的时候，微平面的取向方向会更加的随机。你将会发现与h向量取向一致的微平面分布在一个大得多的半径范围内，但是同时较低的集中性也会让我们的最终效果显得更加灰暗。
使用GLSL代码编写的Trowbridge-Reitz GGX法线分布函数是下面这个样子的：
float D_GGX_TR(vec3 N, vec3 H, float a) { float a2 = a*a; float NdotH = max(dot(N, H), 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ff8ec9a8f0261838d606aa434090b4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b51d8bb0ceb646033ca0d4ec66de160/" rel="bookmark">
			操作系统第一章课后题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		操作系统第一章课后题 1. 设计现代OS的主要目标是什么？
答：方便性,有效性,可扩充性和开放性
2. OS的作用可表现在哪几个方面?
答：(1) OS作为用户与计算机硬件系统之间的接口。(2) OS作为计算机系统资源的管理者。(3) OS实现了 对计算机资源的抽象。
3.为什么说OS实现了对计算机资源的抽象？
答：OS首先在裸机上覆盖一层I/O设备管理软件，实现了对计算机硬件操作的第一层次抽象；在第一层 软件上再覆盖文件管理软件，实现了对硬件资源操作的第二层次抽象。OS 通过在计算机硬件上安装多 层系统软件，增强了系统功能，隐藏了对硬件操作的细节，由它们共同实现了对计算机资源的抽象。
4．试说明推动多道批处理系统形成和发展的主要动力是什么？
答：主要动力来源于四个方面的社会需求与技术发展：（1）不断提高计算机资源的利用率；（2）方便 用户；（3）器件的不断更新换代；（4）计算机体系结构的不断发展。
5．何谓脱机I/O和联机I/O？
答：脱机I/O 是指事先将装有用户程序和数据的纸带或卡片装入纸带输入机或卡片机，在外围机的控制 下，把纸带或卡片上的数据或程序输入到磁带上。该方式下的输入输出由外围机控制完成，是在脱离主 机的情况下进行的。而联机I/O方式是指程序和数据的输入输出都是在主机的直接控制下进行的。
6．试说明推动分时系统形成和发展的主要动力是什么？
答：推动分时系统形成和发展的主要动力是更好地满足用户的需要。主要表现在：CPU 的分时使用缩短 了作业的平均周转时间；人机交互能力使用户能直接控制自己的作业；主机的共享使多用户能同时使用 同一台计算机，独立地处理自己的作业。
7．实现分时系统的关键问题是什么？应如何解决？
答：关键问题是当用户在自己的终端上键入命令时，系统应能及时接收并及时处理该命令，在用户能接 受的时延内将结果返回给用户。 解决方法：针对及时接收问题，可以在系统中设置多路卡，使主机能同时接收用户从各个终端上输入的 数据；为每个终端配置缓冲区，暂存用户键入的命令或数据。针对及时处理问题，应使所有的用户作业 都直接进入内存，并且为每个作业分配一个时间片，允许作业只在自己的时间片内运行，这样在不长的 时间内，能使每个作业都运行一次。
8．为什么要引入实时OS？
答：实时操作系统是指系统能及时响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制 所有实时任务协调一致地运行。引入实时OS 是为了满足应用的需求，更好地满足实时控制领域和实时 信息处理领域的需要。
9．什么是硬实时任务和软实时任务？试举例说明。
答：硬实时任务是指系统必须满足任务对截止时间的要求，否则可能出现难以预测的结果。举例来说， 运载火箭的控制等。软实时任务是指它的截止时间并不严格，偶尔错过了任务的截止时间，对系统产生 的影响不大。举例：网页内容的更新、火车售票系统。
10．在8位微机和16位微机中，占据了统治地位的是什么操作系统？
答：单用户单任务操作系统，其中最具代表性的是 CP/M 和 MS-DOS.
11．试列出Windows OS中五个主要版本，并说明它们分别较之前一个版本有何改进。
答：（1） Microsoft Windows 1.0 是微软公司在个人电脑上开发图形界面的首次尝试。 （2） Windows 95 是混合的16位/32位系统，第一个支持32位。带来了更强大、更稳定、更实用的桌面 图形用户界面，结束了桌面操作系统间的竞争。 （3） Windows 98 是微软公司的混合16位/32位~操作系统，改良了硬件标准的支持，革新了内存管 理，是多进程操作系统。 （4） Windows XP 是基于 Windows2000 的产品，拥有新用户图形界面月神Luna。简化了用户安全特 性，整合了防火墙。 （5） Windows Vista 包含了上百种新功能；特别是新版图形用户界面和 WindowsAero 全新界面风 格、加强的搜寻功能 （Windows IndexingService ）、新媒体创作工具以及重新设计的网络、音频、 输出（打印）和显示子系统。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b51d8bb0ceb646033ca0d4ec66de160/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06b4d0bdd9fb3fdec869cb74e984979c/" rel="bookmark">
			Linux Etc/GMT 与现实时GMT区对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于时区ETC/GMT设置问题： 当你使用Linux设定时区时，若是选用Etc底下的GMT时区，可能会发现设定的结果与你预想的不同，当你想设定北京的时区（GMT＋8) ，但设定完后，系统时间却是-8的时区，和北京时间相差16小时，原因是因为Etc底下的GMT时区是以格林威治以西为正，以东为负，刚好与我们现实生活的认知相反
而原因只是因为当初Unix 多为西方人使用，便以西为正
因此在设定的时候需要选择正负相反的选项。
参考文档：
http://lemonlatte.logdown.com/tags/tzdata
Dkukoc运维学习参考：
https://www.dkukoc.com/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/814b4ae49de032b1c9c51efb56156886/" rel="bookmark">
			VUE表单重置报错：Error in v-on handler: &#34;TypeError: Cannot read property &#39;resetFields&#39; of  undefined&#34;解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错如下：
博主遇到的问题其实说起来很羞耻......不是多么难得问题，就是
&lt;el-form-item label="用户名" props="userName"&gt;//错误写法 中prop写错了，多加了个s
&lt;el-form-item label="用户名" prop="userName"&gt;//正确写法 prop写错不会出现上图出现的错误，就是点击重置按钮没有效果也没有报错，但是一开始没想到是prop拼错了，所以改了其他代码才出现上图报错
综合网上的修改方式仍未解决，
方法一：
this.$nextTick(()=&gt;{
this.$refs.refs名.resetFields();
})
方法二：
检查this.$refs.refs名.resetFields();的refs名和ref名是否一致（要一致才行）
方法三：（如果是组件引入）
this.$refs.refs名.resetFields();应该写在子组件里面，(原谅菜鸟一个，具体原因未知）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a43de451cc5a207373137056579bde9b/" rel="bookmark">
			解决升级idea版本到2020.1后Lombok插件无法使用问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		发现问题
今天idea提示我需要可以更新到idea版本到2020.1,我没多想就点了更新,然后在更新之前idea有提示我Lombok版本不兼容,当时也没多想,还想着赶快更新撸代码,然后就悲剧了
关于实体类的自动get和set方法都会报错,虽然这样不会影响到项目运行,但是看起来也是特别的不舒服的呀
解决办法
1.点击idea中Lombok插件的"Plugin homepage"(我的之所以没报错是因为我已经下载过了)进入lombok的官网 * 2.点击官网中"Version History"版本历史, 3.点击下方的"show More"找到带有EAP的版本 4.点击进入详情页,然后下载到本地,打开idea 在此处选择你下载下来的zip压缩包后,点击重启idea后就可以使用啦,不过这也是临时方案,在过些时间idea上lombok应该会更新吧
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b46fd6fbf05bf866b22be77d6478bf45/" rel="bookmark">
			【笔记】CSS3滤镜效果，可实现整个网页变灰
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用filter属性可添加滤镜效果，【注意】IE没有filter属性
注意: 滤镜通常使用百分比 (如：75%), 当然也可以使用小数来表示 (如：0.75)。
以下实例演示了所有滤镜的使用方法:
.blur { -webkit-filter: blur(4px); filter: blur(4px); } .brightness { -webkit-filter: brightness(0.30); filter: brightness(0.30); } .contrast { -webkit-filter: contrast(180%); filter: contrast(180%); } .grayscale { -webkit-filter: grayscale(100%); filter: grayscale(100%); } .huerotate { -webkit-filter: hue-rotate(180deg); filter: hue-rotate(180deg); } .invert { -webkit-filter: invert(100%); filter: invert(100%); } .opacity { -webkit-filter: opacity(50%); filter: opacity(50%); } .saturate { -webkit-filter: saturate(7); filter: saturate(7); } .sepia { -webkit-filter: sepia(100%); filter: sepia(100%); } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b46fd6fbf05bf866b22be77d6478bf45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/484e78a536195a2deac7fe32d4c21dca/" rel="bookmark">
			美国高校开源迄今为止最大新冠肺炎CT数据集！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方“视学算法”，选择“星标”
快速获得最新干货
本文转载自：新智元 编辑：元子、白峰
【导读】胸部计算机断层扫描（CT）图像在对新冠肺炎（COVID-19）提供准确、快速、廉价的筛查和检测方面很有前景。在本文中，研究团队构建了一个开源的COVID-CT数据集，其中包含275个COVID-19检测呈阳性的CT图像，有助于使用深度学习方法分析病人的CT图像并预测其是否患有新冠的相关研究和发展。 胸部计算机断层扫描（CT）图像在对新冠肺炎（COVID-19）提供准确、快速、廉价的筛查和检测方面很有前景。
在本文中，研究者构建了一个开源的COVID-CT数据集，其中包含275个COVID-19检测呈阳性的CT图像，有助于使用深度学习方法分析病人的CT图像并预测其是否患有新冠的相关研究和发展。
研究者在该数据集上训练了一个深度卷积神经网络，F1值达到0.85，这个结果达到了研究团队的期待，但仍需进一步改进。
相关数据和代码：
https://github.com/UCSD-AI4H/COVID-CT
核酸检测的最大问题：速度慢且稀缺，追不上新冠肺炎的传播速度 截至2020年3月30日，在全世界范围内已有775306人感染新冠肺炎，37083人死亡。对此疾病检测的低效和缺乏成为控制其传播的主要障碍。
目前的检测主要基于逆转录聚合酶链反应（RT-PCR），需要4到6个小时才能获得结果。与新冠肺炎可怕的传播速度相比，这远不够快。除了效率低下之外，RT-PCR检测试剂盒也非常短缺。
这促使研究团队去研究替代的检测方式。这些方式可能更快，比RT-PCR便宜，更容易获得，但与RT-PCR一样准确。在众多可能性中，研究团队对CT图像尤其感兴趣。
有几篇著作研究了CT图像在筛选和检测新冠肺炎时的效果，结果鼓舞人心。然而，出于对隐私的保护，这些研究中所使用的CT图像并不会公之于众，这极大地阻碍了基于CT图像的精准检测新冠肺炎先进人工智能方法的研发。
构建COVID-CT数据集，训练深度学习模型诊断新冠肺炎 为了解决这个问题，研究团队构建了一个COVID-CT数据集，其中包含275个新冠肺炎检测呈阳性的CT图像，并向公众开放，以助于基于CT图像的新冠肺炎检测的研发。
研究团队从760个关于新冠肺炎的medRxiv和bioRxiv预印本中提取了 CT图像，并通过阅读这些图像的标题人工筛选出具有新冠肺炎临床病症的图像。基于183个新冠肺炎 CT图像和146个非新冠肺炎 CT图像，研究团队训练了一个深度学习模型，以预测一个CT图像是否呈新冠肺炎阳性。
在35个新冠肺炎 CT图像和34个非新冠肺炎 CT图像上进行了测试，研究团队的模型F1值为0.85。结果表明，CT扫描有望用于筛选和检测新冠肺炎，然而还需要更先进的方法来进一步提高准确性。
确诊新冠肺炎的患者入院时的CT图像。
A，2020年2月2日，一名39岁男性的胸部CT扫描结果，显示双侧毛玻璃混浊。
B，2020年2月6日，一名45岁男性的胸部CT扫描结果，显示双侧毛玻璃混浊。
C，2020年1月27日，一名48岁男性（在治疗后第9天出院）的胸部CT扫描结果，显示斑片状阴影。
D，2020年1月23日，一名34岁男性（在治疗后第11天出院）的胸部CT扫描结果，显示斑片状阴影。
图1：对于包含多个CT子图像的图像，研究团队将其手动拆分为单个CT图像。
如何创建数据集 在本节中，研究团队描述了如何构建COVID-CT数据集。研究团队首先收集了760个于1月19日 至3月25日期间在medRxiv1和bioRxiv2上发布的的关于新冠肺炎的预印本。
这些预印本中有许多报告了新冠患者病例并且其中一些展示了患者的CT图像。
这些 CT图像附有描述其临床病症的标题。研究团队使用了PyMuPDF3提取预印本PDF文件的底层结构信息并定位到所有嵌入的图表。这些图表的质量（包括分辨率，大小等）大都保存完好。
根据结构信息，研究团队还识别出所有图表的标题。基于提取的图表和标题，研究团队首先手动选出所有CT扫描图像。
然后对于每个CT图像，阅读其对应的标题从而判断它对新冠肺炎是否呈阳性。如果无法通过标题判断，则在预印本中找到分析此图的文字以做出决定。对于包含多个CT子图像的图像，研究团队将其手动拆分为单个CT图像，如图1所示。
最后，研究团队获得了27个CT扫描图像，标记为新冠肺炎阳性。这些图像大小不同，最小，平均和最大高度分别为153、491和1853；最小，平均和最大宽度分别为124、383和1485。这些扫描来自143例患者。图2 显示了新冠肺炎CT扫描图像的一些示例。
图2：新冠肺炎阳性的CT扫描图像示例
两种方式：迁移学习和数据扩充 研究团队基于这个数据集开发了一个基线方法，希望有兴趣的学者可以对其进行基准测试。
尽管研究团队所使用的关于新冠肺炎的CT图像数据集是目前最大的公开可使用的CT图像数据集，然而它依旧较难达到训练模型所需的数据量。
因为在如此小的数据集上训练深度学习模型十分容易导致过度拟合：模型在训练数据上表现良好，但是在测试数据上泛化不理想。因此，研究团队采用了两种不同的方法来解决这个问题：迁移学习和数据扩充。
其中，迁移学习的目的是利用来自相关领域的大量数据来辅助模型的训练与学习。具体来说，研究团队使用大量的胸部X光图像来预先训练一个深度卷积神经网络，然后在COVID-CT数据集上对训练好的网络进行微调。
数据扩充的目的是组合近似正确的图像-标签组，例如，在大多数组合的图像标签组中，标签是对图像的正确注释。
迁移学习
为了解决训练数据不足的问题，研究团队采用了迁移学习的方法。具体来讲，研究团队使用NIH发布的ChestX-ray14 数据集来预训练DenseNet，然后在COVID-CT数据集上对预训练后的DenseNet进行微调。
数据扩充
另一种解决数据不足的方法是数据扩充：即从有限的训练数据中，创建新的图像-标签组，并将合成后的组添加到原本的训练集中。在创建新的组时，研究团队采用了随机仿射变换、随机裁剪和翻转来扩充每个训练图像。随机仿射变换包括平移和旋转（角度依次为5，15，25）。
实验设计以及结果 研究团队收集了195个检测新冠肺炎呈阴性的CT扫描数据，来训练一个二分类模型用于预测一个CT图像是新冠阳性还是阴性。
其中，研究团队根据患者数据将其分为训练集，检验集和测试集，图表1总结了每个数据集中新冠阳性和新冠阴性图像的数量，每个CT图像的大小都调整为224*224,并通过验证集对超参数进行调优。
再者，通过使用学习率为0.0001，余弦调度和最小批处理大小为4的Adam，研究团队对网络中的权重参数进行了优化。最后，研究团队使用五个指标来评估研究团队的方法：(1)准确性; (2)精度; (3)召回率; (4)F1指数; (5)ROC曲线面积(AUC)。对于这些指标，越高越好。
上图展示了这个基线方法的准确度、精密度、召回率、F1指数和AUC。尽管精度较高，然而召回率的结果并不令人满意，因此，需要使用更先进的方法来提高召回率。
总结 研究团队建立了一个关于新冠肺炎的公开CT扫描数据集，来促进通过读取CT图像进而筛选和检测新冠肺炎患者的AI技术的发展。
此数据集包含275个CT扫描结果为阳性的新冠肺炎患者的CT图像。
研究团队使用该数据集训练了一个深度学习模型，并获得了0.85的F1值。下一步，研究团队将继续改进方法以达到更好的精度。
论文链接：
https://arxiv.org/abs/2003.13865
数据集：
https://github.com/UCSD-AI4H/COVID-CT
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57161e1567defbc171a85f13097af9ea/" rel="bookmark">
			SimpleDateFormat格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误使用SimpleDateFormat导致时间显示错误 SimpleDateFormat格式 SimpleDateFormat格式 我每次从数据库读存入的时间，然后new Date(longTime),再用SimpleDateFormat格式化，但总是显示时间不对，最后找到原因是new SimpleDateFormat时候格式要严格遵守规定。
常用格式有：
年：y
月:M
日：d
时：h(1~12) H(0~23)
分：m
秒：s
毫秒:S
星期:E
写几个对应格式符号，就显示几位，不够用0填充；例如 格式：“hh:mmm” 则12：24显示为12：024；如果只是一位，则显示最少可以显示时间的位数；如果不是一位但不能显示全部位数，则从左向右显示；示例如下：
String dateStr1= new SimpleDateFormat("yy.MM.dd HH:mm").format(date); String dateStr2= new SimpleDateFormat("y.M.d H:m:s:S").format(date); String dateStr3= new SimpleDateFormat("yyy.M.d H:m:s:S").format(date); String dateStr4= new SimpleDateFormat("yyyyy.MMM.d H:m:s:S").format(date); Log.e("发送时间", "onClick: Date"+ dateStr); Log.e("发送时间1", "onClick: Date"+ dateStr1); Log.e("发送时间2", "onClick: Date"+ dateStr2); Log.e("发送时间3", "onClick: Date"+ dateStr3); Log.e("发送时间4", "onClick: Date"+ dateStr4); 我起初就是把分对应的mm写成大写MM,而这个对应的是月份，所以每次都显示的分是当前月份。
简单示例：
SimpleDateFormat format=new SimpleDateFormat("yyyy.MM.dd-HH:mm"); Date date=new Date(); format.format(date);//@return dateString 2020.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57161e1567defbc171a85f13097af9ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b28093734eedd3c1cabd8f2aa0acd3ea/" rel="bookmark">
			Spring Cloud Netflix 面试题（总结最全面的面试题！！！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 什么是微服务架构为什么需要学习Spring CloudSpring Cloud 是什么SpringCloud的优缺点SpringBoot和SpringCloud的区别？Spring Cloud和SpringBoot版本对应关系SpringCloud由什么组成使用 Spring Boot 开发分布式微服务时，我们面临什么问题Spring Cloud 和dubbo区别? Eureka服务注册和发现是什么意思？Spring Cloud 如何实现？什么是EurekaEureka怎么实现高可用什么是Eureka的自我保护模式，DiscoveryClient的作用Eureka和ZooKeeper都可以提供服务注册与发现的功能,请说说两个的区别 Zuul什么是网关?网关的作用是什么什么是Spring Cloud Zuul（服务网关）网关与过滤器有什么区别常用网关框架有那些？Zuul与Nginx有什么区别？既然Nginx可以实现网关？为什么还需要使用Zuul框架如何设计一套API接口ZuulFilter常用有那些方法如何实现动态Zuul网关路由转发Zuul网关如何搭建集群 Ribbon负载平衡的意义什么？Ribbon是什么？Nginx与Ribbon的区别Ribbon底层实现原理@LoadBalanced注解的作用 Hystrix什么是断路器什么是 Hystrix？谈谈服务雪崩效应在微服务中，如何保护服务?服务雪崩效应产生的原因谈谈服务降级、熔断、服务隔离服务降级底层是如何实现的？ Feign什么是Feign？SpringCloud有几种调用接口方式Ribbon和Feign调用服务的区别 Bus什么是 Spring Cloud Bus？ Config什么是Spring Cloud Config?分布式配置中心有那些框架？分布式配置中心的作用？SpringCloud Config 可以实现实时刷新吗？ Gateway什么是Spring Cloud Gateway? SpringCloud主要项目Spring Cloud ConfigSpring Cloud Netflix(重点，这些组件用的最多)Spring Cloud BusSpring Cloud ConsulSpring Cloud SecuritySpring Cloud SleuthSpring Cloud StreamSpring Cloud TaskSpring Cloud ZookeeperSpring Cloud GatewaySpring Cloud OpenFeign Spring Cloud的版本关系Spring Cloud和SpringBoot版本对应关系Spring Cloud和各子项目版本对应关系 什么是微服务架构 微服务架构就是将单体的应用程序分成多个应用程序，这多个应用程序就成为微服务，每个微服务运行在自己的进程中，并使用轻量级的机制通信。这些服务围绕业务能力来划分，并通过自动化部署机制来独立部署。这些服务可以使用不同的编程语言，不同数据库，以保证最低限度的集中式管理。 为什么需要学习Spring Cloud 首先springcloud基于spingboot的优雅简洁，可还记得我们被无数xml支配的恐惧？可还记得springmvc，mybatis错综复杂的配置，有了spingboot，这些东西都不需要了，spingboot好处不再赘诉，springcloud就基于SpringBoot把市场上优秀的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理
什么叫做开箱即用？即使是当年的黄金搭档dubbo+zookeeper下载配置起来也是颇费心神的！而springcloud完成这些只需要一个jar的依赖就可以了！
springcloud大多数子模块都是直击痛点，像zuul解决的跨域，fegin解决的负载均衡，hystrix的熔断机制等等等等
Spring Cloud 是什么 Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、智能路由、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。Spring Cloud并没有重复制造轮子，它只是将各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。 SpringCloud的优缺点 优点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b28093734eedd3c1cabd8f2aa0acd3ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e2e9596e16324f76fefdb794f65c84b/" rel="bookmark">
			Yes沟通法则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在日常生活、工作中，我们对他人的想法持否定意见时，常常的做法是立即否定他人的想法，并开始阐述自己的建议。显然这种沟通方式容易激起对方的反弹心里，影响沟通效果与合作关系。因此常见的沟通技巧有三个沟通定律：
1、yes，but定律
这个定律是先耐心倾听对方的想法，在了解对方的想法后，先对该想法的可取之处表示赞同认可，让对方感受到你的接纳，然后再批评其中的错误和不当之处，这样会让对方更容易接受你的建议。
例：你的这个方案非常详细完整，上个周末你一定费了不少心思吧。只是按照这个方案实施周期会较长，看能够再梳理梳理，尽可能接近这个方案效果同时又能够快速落地。
2、yes，and定律
同样，先yes赞同、接纳对方想法，接着通过and扩展、延伸、增加你的想法，用想法激发想法，用人点燃人。会带来意想不到的效果，对方会马上接纳你的想法并付诸行动，能够让相互之间产生心流，共同聚焦解决问题。
例：你的这个方案非常详细完整，上个周末你一定费了不少心思吧。同时如果能够再考虑一下B部门的X场景，那就更加完美了。
3、group yes and定律
提出团队共同目标，并在目标基础上鼓励支持，鼓励多元创造，激发思路。
例：
A、我们团队这个月的目标是完成A项目上线，并且能够在完成质量上比上个月更好。
B、是的，我们肯定能完成A项目上线，而且我们还将组织2场内部培训加强大家对业务的深度理解。
通过以上3个沟通法则的学习，我们了解到在沟通掌握一些小技巧，会起到事半功倍的效果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/951c1f757a9f918f0624cd5cb90b890d/" rel="bookmark">
			vue
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写目录标题 一.什么是MVVM二.VUE入门1. 常用指令1.1 插值1.2 v-text和v-html1.3 v-model和v-on1.4 v-for 循环1.5 v-if和v-show1.6 v-if 、v-else-if、v-else1.7 v-bind1.8 Watch 监测数据的变化 相当于onchange事件 2.生命周期—钩子函数 一.什么是MVVM 双向：js上的数据和HTML页面上的数据
二.VUE入门 1. 常用指令 1.1 插值 写法就是{{}}
1.2 v-text和v-html 1.3 v-model和v-on v-model:做双向绑定，只能出现在input type=text password checkbox radio select 中
v-on: 上面的事件已经演示过了，v-on:可以使用@符号代替
&lt;!DOCTYPE html&gt; &lt;html lang="en" xmlns:v-on="http://www.w3.org/1999/xhtml"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src="node_modules/vue/dist/vue.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;div&gt; &lt;input v-model="a"&gt;+&lt;input v-model="b"&gt; &lt;button v-on:click="add"&gt;等于&lt;/button&gt;&lt;input v-model="c"&gt; &lt;/div&gt; &lt;div&gt; &lt;input v-model="username"&gt; &lt;span&gt;{{age}}&lt;/span&gt; &lt;button v-on:click="addAge"&gt;下一年&lt;/button&gt; &lt;/div&gt; &lt;div&gt;{{userName}}&lt;/div&gt; &lt;br&gt; &lt;span v-text="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/951c1f757a9f918f0624cd5cb90b890d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9412d38d0d086386f080aa9239bb22c6/" rel="bookmark">
			MySQL索引详细介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是索引？为什么要建立索引？ 索引用于快速找出在某个列中有一特定值的行，不使用索引，MySQL必须从第一条记录开始读完整个表，直到找出相关的行，表越大，查询数据所花费的时间就越多，如果表中查询的列有一个索引，MySQL能够快速到达一个位置去搜索数据文件，而不必查看所有数据，那么将会节省很大一部分时间。
例如：有一张person表，其中有2W条记录，记录着2W个人的信息。有一个Phone的字段记录每个人的电话号码，现在想要查询出电话号码为xxxx的人的信息。如果没有索引，那么将从表中第一条记录一条条往下遍历，直到找到该条信息为止。如果有了索引，那么会将该Phone字段，通过一定的方法进行存储，好让查询该字段上的信息时，能够快速找到对应的数据，而不必在遍历2W条数据了。其中MySQL中的索引的存储类型有两种：BTREE、HASH。 也就是用树或者Hash值来存储该字段。
二、MySQL中索引的优点和缺点和使用原则 优点：
1、所有的MySql列类型(字段类型)都可以被索引，也就是可以给任意字段设置索引；
2、大大加快数据的查询速度。
缺点：
1、创建索引和维护索引要耗费时间，并且随着数据量的增加所耗费的时间也会增加；
2、索引也需要占空间，我们知道数据表中的数据也会有最大上线设置的，如果我们有大量的索引，索引文件可能会比数据文件更快达到上线值；
3、当对表中的数据进行增加、删除、修改时，索引也需要动态的维护，降低了数据的维护速度。
使用原则：
1、对经常更新的表就避免对其进行过多的索引，对经常用于查询的字段应该创建索引；
2、数据量小的表最好不要使用索引，因为由于数据较少，可能查询全部数据花费的时间比遍历索引的时间还要短，索引就可能不会产生优化效果；
3、在一同值少的列上(字段上)不要建立索引，比如在学生表的"性别"字段上只有男，女两个不同值。相反的，在一个字段上不同值较多可以建立索引。
三、索引的分类　注意：索引是在存储引擎中实现的，也就是说不同的存储引擎，会使用不同的索引。
MyISAM和InnoDB存储引擎：只支持BTREE索引， 也就是说默认使用BTREE，不能够更换；
MEMORY和HEAP存储引擎：支持HASH和BTREE索引。
单列索引(普通索引，唯一索引，主键索引)、组合索引、全文索引、空间索引。 1.1 单列索引：一个索引只包含单个列，但一个表中可以有多个单列索引。 这里不要搞混淆了。
1）普通索引：MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值，纯粹为了查询数据更快一点。
2）唯一索引：索引列中的值必须是唯一的，但是允许为空值，
3）主键索引：是一种特殊的唯一索引，不允许有空值。
1.2 组合索引
在表中的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，使用组合索引时遵循最左前缀集合。
1.3 全文索引
全文索引，只有在MyISAM引擎上才能使用，只能在CHAR,VARCHAR,TEXT类型字段上使用全文索引，介绍了要求，说说什么是全文索引，就是在一堆文字中，通过其中的某个关键字等，就能找到该字段所属的记录行。
1.4 空间索引
空间索引是对空间数据类型的字段建立的索引，MySQL中的空间数据类型有四种，GEOMETRY、POINT、LINESTRING、POLYGON。在创建空间索引时，使用SPATIAL关键字。要求，引擎为MyISAM，创建空间索引的列，必须将其声明为NOT NULL。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61108918976a5c147d6c54595aaeeae1/" rel="bookmark">
			自然语言处理（NLP）——哈工大pyltp的安装与使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		哈工大语言技术平台（Language Technology Platform, LTP）是哈尔滨工业大学社会计算与信息检索研究中心开发的一整套中文语言处理系统。LTP还提供了包括中文分词、词性标注、命名实体识别、依存句法分析、语义角色标注等NLP技术。
哈工大语言云演示平台：http://www.ltp-cloud.com/
GitHub代码：https://github.com/HIT-SCIR/pyltp
文档：https://pyltp.readthedocs.io/zh_CN/latest/
安装 我的电脑环境：Windows64位，python 3.6
操作演示环境：pycharm
下载内容 模型下载：下载最新版的模型ltp_data_v3.4.0
下载地址：http://ltp.ai/download.html
2.下载LTP：pyltp-0.2.1-cp36-cp36m-win_amd64.whl
下载地址：https://download.csdn.net/download/xiaoxy97/10525781
备注：需要和自己电脑python版本对于，我的是python3.6 安装流程 1、将下载的两个文件解压（文件夹名称不要用中文）
2、将pyltp-0.2.1-cp36-cp36m-win_amd64.whl拷贝到自己python安装目录下的Scripts文件夹中（我的是D:\python\Scripts）
3、进入cmd命令行，进入自己python安装目录下的Scripts文件夹中（我的是D:\python\Scripts）。然后执行命令行：
pip.exe install pyltp-0.2.1-cp36-cp36m-win_amd64.whl 4、出现Successfully installed pyltp-0.2.1说明安装成功
5、检验：进入自己python安装目录下的Scripts文件夹中（我的是D:\python\Scripts）。然后执行命令行：
pip.exe list 出现如图所示情况表示安装成功
实际操作 1、打开charm，创建新的python项目
运行如下代码：
#itp-cws 分词方法 from pyltp import Segmentor def segmenter(sentence): segmenter = Segmentor() #加载模型 segmenter.load(r'D:/NLP/ltp_data_v3.4.0/cws.model') words = segmenter.segment(sentence) words_list = list(words) segmenter.release() return words_list if __name__ == "__main__": sentence = r"我是一个喜欢吃串串的程序员小哥哥" words = segmenter(sentence) print(words) 备注：在代码：segmenter.load(r’D:/NLP/ltp_data_v3.4.0/cws.model’)中，模型地址就是我们最初下载的ltp_data_v3.4.0中的模型地址（cws.model是分词模型）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/226c2b55693a6f535e07b037c1d62e80/" rel="bookmark">
			浏览器地址栏输入URL，按下回车后发生了什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在地址栏输入URL后
输入URL，按回车dns解析（浏览器是不能识别url地址的，需解析成ip地址），建立tcp连接，（tcp三次握手）发送Http请求，服务器进行处理并返回Http报文，浏览器渲染页面，断开连接（tcp四次挥手） URL
URL（Uniform Resource Locator），统一资源定位符，用于定位互联网上资源，俗称网址。
域名解析解析 （DNS解析url对应的ip）
域名解析：DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。DNS 是一个网络服务器，我们的域名解析简单来说就是在 DNS 上记录一条信息记录。
在浏览器中输入URL后，首先要进行DNS解析，DNS解析的顺序为：
1、浏览器缓存
2、本地hosts文件
3、系统缓存
4、路由器缓存
5、DNS服务器迭代查询
分析：域名解析实际上是将域名解析为ip地址的过程。
首先，浏览器会检查本地hosts文件中是否有此url的映射关系，如果有就调用这个ip地址映射，完成域名解析。
如果没有，则会查找本地DNS解析器缓存，如果查找到则返回。
如果还是没有，则会查找本地DNS服务器，如果查找到则返回。
最后迭代查询，按根域服务器 -&gt;顶级域(.com)-&gt;第二层域(yeahfei.com) -&gt;子域(admin.yeahfei.com)的顺序找到IP地址。
tcp三次握手
1.目的：同步客户端和服务端的序列号和确认号，并交换TCP窗口大小信息。防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。
通过DNS得到目标的IP地址后，通过TCP协议向服务器发送请求即三次握手。 分析：通过第3阶段已经拿到了服务器的ip地址，在获取到IP地址后，便会开始建立一次连接，这是由TCP协议完成的，主要通过三次握手进行连接。
第一次握手： 建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；
第二次握手： 服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；
第三次握手： 客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成
发送Http请求
建立连接：服务器允许客户端建立连接
接受请求：从网络中读取HTTP报文交给Nginx或者Apache进行规则匹配
处理请求：根据方法，资源，首部和可选的主体部分对请求进行处理
访问资源：寻找存储对象，访问报文中指定的资源
构建响应报文：创建有正确首部的HTTP响应报文
此处需要图来说明
服务器处理请求并返回HTTP报文
服务器处理请求并返回HTTP报文
解析渲染页面
解析渲染页面
浏览器得到页面后会进行展示，如果还包含其他外部资源如图片、视频等等则继续请求其他资源。
分析：如果说响应的内容是HTML文档的话，就需要浏览器进行解析渲染呈现给用户。整个过程涉及两个方面：解析和渲染。在渲染页面之前，需要构建DOM树和CSSOM树。
在浏览器还没接收到完整的 HTML 文件时，它就开始渲染页面了，在遇到外部链入的脚本标签或样式标签或图片时，会再次发送 HTTP 请求重复上述的步骤。在收到 CSS 文件后会对已经渲染的页面重新渲染，加入它们应有的样式，图片文件加载完立刻显示在相的应位置。在这一过程中可能会触发页面的重绘或重排。
1.概念：
重绘：某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的重绘。
回流：某个元素的尺寸发生了变化，则需重新计算渲染树，重新渲染。
2.步骤：
根据 HTML 解析出 DOM 树
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/226c2b55693a6f535e07b037c1d62e80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d61fb4e3feed9583a05150f6d96bb6be/" rel="bookmark">
			停用词过滤原理及实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.停用词 指语言中一类没有多少意义的词语，比如“的”，“甚至”，“不仅”，“吧”…
一个句子去掉了停用词并不影响理解，停用词视具体的任务不同而不同。停用词过滤是一个常见的预处理过程
2.实现思路 加载中止词：IO加载中止词(中止词下载地址，复制粘贴保存为txt文本)分词：使用HanLP进行分词停用词过滤：从分词结果中去除中止词 3.加载中止词 这里最简单的做法是把中止词直接加入List中，但当词过多时，会浪费大量空间和查询时间，考虑到中文词大部分较短，这里使用双数组字典树(DATrie)构建，不熟悉双数组字典树的可以看这里，下面是构建代码：
/** * @author: Ragty * @Date: 2020/4/11 12:37 * @Description: 加载字典到DATrie */ public static DATrie loadStopword(String path) throws IOException { BufferedReader bufferedReader = new BufferedReader(new FileReader(stopWordsPath)); List&lt;String&gt; stopWords = new ArrayList&lt;String&gt;(); String temp = null; while ((temp = bufferedReader.readLine()) != null) { stopWords.add(temp.trim()); } DATrie daTrie = new DATrie(); daTrie.build(stopWords); return daTrie; } 4.分词 这里分词我们使用HanLP进行分词，不熟悉的可参考配置，下面是分词代码：
/** * @author: Ragty * @Date: 2020/4/11 12:41 * @Description: HanLP分词 */ private static List&lt;Term&gt; segment(String text) { List&lt;Term&gt; list = HanLP.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d61fb4e3feed9583a05150f6d96bb6be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aba43f165957c928bbb9357148e12d9f/" rel="bookmark">
			Xamarin.Android App接收其他App的广播及其参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：之前写过接收系统开机广播的内容，做Xamarin很多时候对于平台下的内容都是不求甚解。
这次接收的是第三方App的广播，查了一下广播相关的东西。
广播分为静态和动态的，接收系统开机广播用的是静态注册的，也只能静态的，因为App还没启动，肯定动态调不起来啊。
1. 接收到第三方app的广播。
我抄了下接收开机广播的方法， 结果第三方app广播后，我这边就报错。
静态注册是在AndroidManifest.xml里面application节点下写一下内容，通过action android:name来匹配对应的广播。
Java.lang.RuntimeException: Unable to instantiate receiver “” didn't find class on path dexpathlist
其实能报错，说明广播被触发了，action名称配置什么的应该都对，但是问题在哪还是不知道，后面查资料说是有可能是因为注册的顺序问题，于是改成动态注册。
在MainActivity启动后用代码注册receiver, 就可以正常接收到了。
2. 接收广播参数 一个receiver可以接收多个多个广播内容，通过intent.Action来判断是哪个广播，对应获取参数。
需要根据参数的类型调用不同的方法来获取
获取整数参数的方法intent.GetIntExtra(参数名称，默认值)，， 文本intent.GetStringExtra(参数名称)等等。
[BroadcastReceiver(Enabled = true, Exported = true)] public class BootReceiver1 : BroadcastReceiver { public override void OnReceive(Context context, Intent intent) { var action = intent.Action; //开启定时开关机 ：参数　mode ==someday/week/everyday offTime onTime // int EVERYDAY = 1; //int SOMEDAY = 2; // int WEEK = 3; if (action == "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aba43f165957c928bbb9357148e12d9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dea48e303592713438655cf7355ac61/" rel="bookmark">
			Wireshark捕获不到本地或者网卡接口解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Wireshark作为一款免费开源的抓包工具，被广泛使用，下载后直接一路式安装，无难度。但是安装成功需要去捕获我们所需要的接口，而恰恰它又不存在时，如何解决呢？
一：安装Wireshark成功
以上出现四个接口Cisco remote capture / Random packet generator /SSH remote capture / UDP Listener remote capture 未出现我们想要的接口时，怎么去解决？
网上有说使用cmd启用控制台输入net start npf回车即可，如果回车后出现服务名无效或者拒绝访问，则使用管理员启用控制台 输入 net start npf 服务名无效
但是如果使用管理员输入net start npf还是报服务名无效，怎么办呢？
1.输入ipconfig后找到连接的网口名
2.打开控制面板—&gt;网络和Internet—&gt;查看网络状态和任务—&gt;更改适配器设置
3.右键—&gt;属性;检查是否有Pcap Packet Capture Driver;如有直接勾选，确定即可；如没有，则需要安装win10Pcap Packet，下载网址：http://www.win10pcap.org/download/；安装后重复上述步骤进行勾选Pcap Packet Capture Driver即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3294ed5fec3ca470284c7052f209df96/" rel="bookmark">
			如何批量调整Word中mathtype公式的大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 尊敬的读者您好：笔者很高兴自己的文章能被阅读，但原创与编辑均不易，所以转载请必须注明本文出处并附上本文地址超链接以及博主博客地址：https://blog.csdn.net/vensmallzeng。若觉得本文对您有益处还请帮忙点个赞鼓励一下，笔者在此感谢每一位读者，如需联系笔者，请记下邮箱：zengzenghe@gmail.com，谢谢合作！
最近在写大论文，在导师给得众多的反馈之中，有一点就是：“要求将word中由mathtype编辑的公式统一一下格式”。针对这一问题，起初是想一个一个调，但是一看我的大论文，六章共6w多字且公式多达百余个，所以此路肯定行不通，于是就想能不能批量的修改呢？通过一番探索与实践，答案是肯定的，所以下面笔者就把批量调整Word中mathtype公式大小的经验和大家分享一下吧。
1、首先在word的菜单栏上要能看到“mathtype”选项；
如果您的菜单栏上没有这一个选项，可以参照这篇文章或其他文章进行加载“https://blog.csdn.net/weixin_36564655/article/details/78604456” 。
2、以张(wo)淑(lao)慧(po)的一部分内容为例，很容易可以看到这里的公式大小是不一致的。
3、 先将文中某个公式调成自己觉得合适的大小，然后双击该公式并选择选项-&gt;公式选项-&gt;保存到文件
4、之后就会弹出一个窗口，笔者这里将公式直接命名为paper_equation.eqp，再点保存即可。
5、回到word文档，按照以下四步进行操作。
6、此时会弹出一个框，在框中选择刚刚保存的paper_equation.eqp文件，并点击打开。
7、按以下两步进行操作即可。
8、如果您弹出了以下方框，恭喜您已经成功批量调整Word中mathtype公式的大小啦！
最终效果图如下：
9、当你使用了mathtype编辑的公式后，文字间的行间距一般会受到影响，这时候按照以下操作就会使得这一影响得到消除。其中第三步中要把默认的√去掉。
日积月累，与君共进，增增小结，未完待续。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc706479a86fbc5518c9dd436f33f059/" rel="bookmark">
			JavaScript的基础知识点总结（上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这是之前学习JavaScript过程中自己总结的相关的知识点，比较零散但分享出来和大家一起学习学习。 6种数据类型
当尝试把基本类型的str当做对象一样访问时，例如：str.length;
解释器会创建一个临时的包装对象，伪代码：
[[tempObj]] = new String(str);
[[tempObj]].length; // 返回具体的length;
delete [[tempObj]]; // 销毁临时对象
重复访问str.length会重复创建这个临时对象。
所以str.t赋值可以成功，但再次访问str.t返回undefined，因为每次创建的临时包装对象都是不同的。判断类型
4. 表达式
5. delete 删除对象的属性
6. 运算符
7 . 遍历数组不要使用for in
8 . 对象的结构：prototype是指对象的原型
obj.z(先在属性里面找，没有找到再在原型里面找)；
9 . 对象的原型链：
Object.create方法是把属性值创建在proto原型上的。
10.巧用运算符&amp;&amp;去取得属性的值
&amp;&amp;从左至右寻找，没有则返回undefined，有则返回相应的值 11.全局、局部变量、函数（方法）都不能被delete
属性检测
cat.propertyIsEnumberable(‘legs’):判断属性是否是枚举的
Object.defineProperty(cat,‘price’):通过这种方法创建的属性它的属性（例如Enumberable）
都是false的。
13.null == undefined(true)
14.小节：对象创建的三种方法：①字面量方法创建对象②原型链方法（new方法）创建对象③create方法创建对象属性的删除用delete，而全局变量，局部变量，函数这些是不能够被删除的。属性的检测。object.defineProPerty。属性的枚举，①object.propertyIsEnumerable(“x”) //false;object.create() //trueobj.hasOwnProperty(key) console.log(key) 则返回创建的元素 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b7fda65fc649a6c4166a2b1f1afb56d/" rel="bookmark">
			pycharm 快速导包/导包快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		alt + 回车
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f90d357a7a1d91ff19de99d9244bcee/" rel="bookmark">
			Android 项目 引用了第三方aar 同步成功 但是编译时报错 跟这个aar 相关的类全部飘红
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		遇到个奇怪的问题 记录一下：
以下开始废话，解决办法在最后面：
有个项目能正常编译运行 ，几天没有打开过，今天一打开那个aar相关的类找不到了 aar还在，然后我做了一下无用工作：
把项目下的.idea、.gradle、还有各个模块的build目录全部删除 再编译 还是报错把代码commit一下，结果发现没有改动过任何文件,然后我又把每个模块删了 再重新往svn拉代码，还是报错创建另外一个目录把代码checkout进去 编译 正常运行，把原来报错的目录名字更改，重新打开项目编译 正常运行把步骤3更改的目录名恢复成没改之前的名字 打开项目编译 报错 居然只跟项目目录名字有关，奇了怪了，虽然可以通过更换目录解决问题，这nm是啥破问题 ，太气人了，必须要解决它，找到问题根源：
根据上面推断，这已经不是项目级别得问题了，一定是每个项目都会共用的缓存之类的文件有问题 ，很明显 ，可以想到Idea 、gradle这两个东西的缓存目录是公用（全局）的，至于Idea ,如果出错不可leng单单是一个库出错 ，所有的aar都会报错，那么就可以找到gradle的全局目录了，一搬在系统的用户目录下有个.gradle目录 这里面包含有各种包的缓存数据，最终经过我精确推断分析，相关的文件夹大概两个分别在以下位置：
user\xxx\.gradle\caches\transforms-1
user\xxx\.gradle\caches\transforms-1
在这里发现有那个aar的缓存文件夹，直接删掉,再打开项目同步--&gt;编译 ,正常运行 ，nm、解决了
好了，废话说完了，解决办法是：
把
user\xxx\.gradle\caches\transforms-1
user\xxx\.gradle\caches\transforms-1
这两个目录删掉就ok了，其他目录不建议删，删了的话需要重新下载很多东西
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/246/">«</a>
	<span class="pagination__item pagination__item--current">247/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/248/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>