<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b37b359099471e6c70756f97166ead28/" rel="bookmark">
			Window11新机激活步骤（零基础）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Window 11新机常规激活步骤（包含绕过OOBE）及购机注意事项 此文章介绍了在电脑生产厂商预装window 11的情况下，首次开机并联网激活的流程。由于电脑厂商最新声明，系统联网激活后概不退换，如果担心拿到的电脑是翻新机，可以绕过OOBE直接进行硬件、屏幕的检查，让自己放心。笔者今年618购入新机，更换了之前用了9年的笔记本。因此特把激活流程、注意事项等分享出来，希望大家不要踩坑。
绕过OOBE启动 OOBE（Out-of-box experience），译名为开箱体验，它是在安装完Windows后就会进行的一个步骤。在这个步骤，您需要对Windows进行一些基本设置。
插电源后开机首先来到设置地区界面此时按组合键Ctrl+Shift+F3（部分机型没反应可以试试Ctrl+Shift+F3+Fn）系统会以Administrator最高管理员权限进入电脑桌面，此过程需要等待一段时间进入后，无视系统准备工具 sysprep 的 重启 选项，将它拖动至不会误触的地方（因为检查完硬件之后需要重启设备，进行联网激活Windos系统），将U盘里文件安装至新电脑，进行检查。 正常联网启动 插电源后开机，设置地区、输入法、命名设备名称，自动重启
连接网络、查看微软和联系许可证协议，自动重启
注意此后有两个分支：
设置电脑使用者的用户名、密码、三个安全问题、设置指纹一键开机（需要设备支持）、设置开机PIN、勾选隐私设置、注册联想账户（可跳过）
启动微软联机账户，输入已注册的微软账户（个人这一步骤很慢很慢，应该与网络状况有关，最后强制关机重启了，然后第一个分支很快走完）
等待后进入桌面
关于硬件检查 主要是检查 电源、磁盘的启动次数 ，硬盘的相应速度 和 屏幕有无坏点 ，可参考以下这篇文章，两种工具需要提前下载好压缩包，用U盘拷贝到新电脑进行检查。
笔记本新机验机最详解 - 知乎 (zhihu.com)
EX-DIY工具箱 卡硬工具箱 （原：卡吧工具箱） 官方网站-电脑DIY装机必备软件
Downloads | AIDA64
给大家浅看一下我的机器配置
购机注意事项 尽量到官方渠道购买，但要区分 官方自营旗舰店，旗舰店，官方旗舰店，授权店 等的区别新机首次开机需要连接电源才能启动（这是厂家设置的运输模式，如果不连接电源适配器就能开机，证明机子出厂后不是第一次被打开）拿到快递后先看外包装有无破损，然后现场拆包，注意联想封条有无破损，然后验证不能在没插电源的情况下启动（这些过程注意拍照、录像，避免万一出问题后理赔时说不清） 引用 引用了该文章的部分内容：
预装Windows 11系统的新电脑怎么跳过联网验机？这两种方法可以搞定 - 知乎 (zhihu.com)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/260d1790b454c4b2f6837a18c1e1ff86/" rel="bookmark">
			JT1078流媒体服务器的开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 JT/1078即&lt;道路运输车辆卫星定位系统-视频通信协议&gt;，于2016年发布，经过几年的沉淀，逐渐应用于道路两客一危、中高端定制化货运、出租车运输等行业。
目前市面上开发的JT1078流媒体服务器，多数只能完成一种或者二种播放方式(比如rtsp、rtmp、flv等的一种)。
本文将介绍的一种实现方式，可实现从终端获取到的视频流，经转码后，可进行rtmp、rtsp、hls、ts、http-flv、websocket-flv、webRTC等播放方式，可适配手机端播放、PC端及浏览器的视频播放。主要支持的终端为基于JT1078协议的H264视频流，以及aac、g711a、adpcma等音频流格式。
对于JT1078的开发，1是按照1078音视频格式解析出相应的消息头，比如SIM卡号、音频还是视频及其格式、时间戳、包的大小等。采集整包的消息，然后给到音视频转换接口，由转换接口将音视频转换为对应的RTSP、RTMP或http-flv播放流。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0689ec907f50c58cbe05f9e7a11dd4e/" rel="bookmark">
			Linux命令之ifconfig命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ifconfig命令有点类似于Windows的ipconfig命令
ifconfig是Linux中用于显示或配置网络设备的命令，英文全称是network interfaces configuring
ifconfig命令用于显示或设置网络设备。
ifconfig可设置网络设备的状态，或是显示目前的设置。
使用者权限：所有（设置级别的需要管理员）用户
语法 ifconfig [网络设备][down up -allmulti -arp -promisc][add&lt;地址&gt;][del&lt;地址&gt;][&lt;hw&lt;网络设备类型&gt;&lt;硬件地址&gt;][io_addr&lt;I/O地址&gt;][irq&lt;IRQ地址&gt;][media&lt;网络媒介类型&gt;][mem_start&lt;内存地址&gt;][metric&lt;数目&gt;][mtu&lt;字节&gt;][netmask&lt;子网掩码&gt;][tunnel&lt;地址&gt;][-broadcast&lt;地址&gt;][-pointopoint&lt;地址&gt;][IP地址] add&lt;地址&gt;：设置网络设备IPv6的ip地址； del&lt;地址&gt;：删除网络设备IPv6的IP地址； down：关闭指定的网络设备； &lt;hw&lt;网络设备类型&gt;&lt;硬件地址&gt;：设置网络设备的类型与硬件地址； io_addr&lt;I/O地址&gt;：设置网络设备的I/O地址； irq&lt;IRQ地址&gt;：设置网络设备的IRQ； media&lt;网络媒介类型&gt;：设置网络设备的媒介类型； mem_start&lt;内存地址&gt;：设置网络设备在主内存所占用的起始地址； metric&lt;数目&gt;：指定在计算数据包的转送次数时，所要加上的数目； mtu&lt;字节&gt;：设置网络设备的MTU； netmask&lt;子网掩码&gt;：设置网络设备的子网掩码； tunnel&lt;地址&gt;：建立IPv4与IPv6之间的隧道通信地址； up：启动指定的网络设备； -broadcast&lt;地址&gt;：将要送往指定地址的数据包当成广播数据包来处理； -pointopoint&lt;地址&gt;：与指定地址的网络设备建立直接连线，此模式具有保密功能； -promisc：关闭或启动指定网络设备的promiscuous模式； IP地址：指定网络设备的IP地址； 网络设备：指定网络设备的名称。 示例：
显示网络设备信息（激活状态的）：
[root@localhost ~]# ifconfig eth0 Link encap:Ethernet HWaddr 00:16:3E:00:1E:51 inet addr:10.160.7.81 Bcast:10.160.15.255 Mask:255.255.240.0 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:61430830 errors:0 dropped:0 overruns:0 frame:0 TX packets:88534 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:3607197869 (3.3 GiB) TX bytes:6115042 (5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0689ec907f50c58cbe05f9e7a11dd4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1f95fb422ae7cad349cc0c8f97ff00b/" rel="bookmark">
			java双指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、实践题目 两数之和
2、问题描述 给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列 ， 请你从数组中找出满足相加之和等于目标数 target 的两个数。 如果设这两个数分别是 numbers[index1] 和 numbers[index2] ， 则 1 &lt;= index1 &lt; index2 &lt;= numbers.length 。 以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。 你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。 你所设计的解决方案必须只使用常量级的额外空间。 示例 1： 输入：numbers = [2,7,11,15], target = 9
输出：[1,2] 解释：2 与 7 之和等于目标数 9 。
因此 index1 =1, index2 = 2 。返回 [1, 2] 。
3、算法描述 初始时两个指针分别指向第一个元素位置和最后一个元素的位置。每次计算两个指针指向的两个元素之和，并和目标值比较。如果两个元素之和等于目标值，则发现了唯一解。如果两个元素之和小于目标值，则将左侧指针右移一位。如果两个元素之和大于目标值，则将右侧指针左移一位。移动指针之后，重复上述操作，直到找到答案。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1f95fb422ae7cad349cc0c8f97ff00b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f2cc36438dc94edf599d4fdf7214a29/" rel="bookmark">
			Windows 7 旗舰版高效办公 - 任务栏和 开始 菜单属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows 7 旗舰版高效办公 - 任务栏和 开始 菜单属性 1. 开始 -&gt; 右键 属性
2. 任务栏和 开始 菜单属性
3. 自定义 开始 菜单
运行命令
要显示的最近打开过的程序的数目：16
要显示在跳转列表中的最近使用的项目数：16
4. 运行
5. cmd
6. cmd.exe
7. 将此程序锁定到任务栏
References https://yongqiang.blog.csdn.net/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c62a20292859892d12929c3c806f0139/" rel="bookmark">
			Discriminative frequent subgraph mining with optimality guarantees详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Discriminative frequent subgraph mining with optimality guarantees 论文链接：Discriminative frequent subgraph mining with optimality guarantees
频繁子图挖掘(frequent subgraph mining)是检测子图是否在图集上反复出现。discriminative frequent subgraph可以理解为在某些类中频繁出现，但是在其他类中出现的不多。
本文提出了CORK算法，这是一个子模性质算法，可以使用贪心获取次优解，并且可以将其于gSpan结合。
1 Introduction 本文主要考虑的是frequent pattern approaches相关的问题，用频繁子图来表示一个图。并且最优化图分类的结果。
目前这类问题存在两个重点：
在一张大图中枚举所有存在的子结构是计算复杂的(指数级别)。不频繁子图(infrequent subgraph)的区分能力(discriminative power)是很差的。 因此我们需要frequent subgraph mining。
大量的图结构会产生以下的挑战：
绝大部分的频繁结构仅有一些细微的区别，并且它们都会出现在一张图中。仅仅是频繁结构还不具备区分能力，因此只有频繁子图结构与类挂上统计学关联的时候，它们才对分类有较大的贡献。（可以理解为在这个类中频繁出现，但是在别的类中出现的不频繁意味着它是这个类的重要频繁子图，能够代表这个类）当threshold设置的过小的时候，会产生大量的频繁子图，这会是计算十分复杂并且存储不够。 本文提出了一个具有子模性质的贪心算法，通过它来提取图中重要的结构。并且将其与gSpan做结合，用于频繁子图挖掘。该算法为二分类设置，但同时可以服务多分类问题。
2 Near-optimal feature selection among frequent subgraphs 第二节开头首先是一些定义的介绍，我默认读者有一定的图论基础。
subgraph isomorphism: 两张图中有对应的节点，同时在此基础上边也对应。
threshold: 只有子图在图集中出现的次数超过定义的threshold时，才能被称为是频繁的。
2.1 Combinatorial optimization problem 频繁子图的特征提取可以被认为是组合优化问题，我们定义 D D D是特征的总集合，在预测当中， ε ⊆ D \varepsilon \sube D ε⊆D是决定图分类的特征。
我们定义 ε \varepsilon ε的相关性是 q ( ε ) q(\varepsilon) q(ε)。用于衡量它的类区分性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c62a20292859892d12929c3c806f0139/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c230576488d92662c8f669ec51f09d0b/" rel="bookmark">
			SpringBoot&#43;微信小程序实现的云音乐小程序系统 附带详细运行指导视频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、项目演示二、项目介绍三、项目运行截图四、主要代码 一、项目演示 项目演示地址： 视频地址
二、项目介绍 项目描述：这是一个基于SpringBoot+微信小程序框架开发的云音乐微信小程序系统。首先，这是一个前后端分离的项目，前端分为用户端和管理端，用户端使用微信小程序(微信小程序开发)，管理端使用Web页面(Vue开发)。其次这项目代码简洁规范，注释说明详细，易于理解和学习。其次，这项目功能丰富，具有一个云音乐微信小程序系统该有的所有功能。
项目功能：此项目分为两个角色：普通用户和管理员。普通用户有登录注册、搜索音乐、查看专辑、查看歌单、查看歌手、查看排行榜、管理自己歌单、播放音乐、收藏音乐、评论音乐、自定义播放音乐（随机播放、单曲循环、列表循环）、管理个人信息等等功能。管理员有管理所有用户信息、管理所有专辑信息、管理所有海报信息、管理所有音乐信息、管理所有歌单信息、管理所有评论信息、管理所有歌手信息等等功能。
应用技术：SpringBoot + 微信小程序+ Vue + MySQL + MyBatis + Redis + ElementUI
运行环境：IntelliJ IDEA2019.3.5 + MySQL5.7（项目压缩包中自带) + Redis5.0.5（项目压缩包中自带） + JDK1.8 + Maven3.6.3（项目压缩包中自带）+ Node14.16.1（项目压缩包中自带）+ 微信开发者工具（项目压缩包中自带）
三、项目运行截图 四、主要代码 1.后台管理系统保存音乐数据代码：
/** * 保存音乐数据(添加、修改) * @param musicDTO * @return */ @Override public ResponseDTO&lt;Boolean&gt; saveMusic(MusicDTO musicDTO) { // 进行统一表单验证 CodeMsg validate = ValidateEntityUtil.validate(musicDTO); if(!validate.getCode().equals(CodeMsg.SUCCESS.getCode())){ return ResponseDTO.errorByMsg(validate); } Music music = CopyUtil.copy(musicDTO, Music.class); Album album = albumMapper.selectByPrimaryKey(music.getAlbumId()); if(album == null) { return ResponseDTO.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c230576488d92662c8f669ec51f09d0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a8858950befd87f55b99bf5a56659e4/" rel="bookmark">
			excel多条件预算：规划求解工具计算多产品最佳效益组合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		江南皮革厂生产三种产品，皮鞋、皮手套、皮帽。三种产品需要原材料甲、乙、丙。近期，原材料供应有限制，生产工时也有限制。已知产品单件的用时、用料、利润，求如何组合产品利润最大。
一、加载规划求解工具
规划求解工具位于“数据”菜单下。如果没有，则可以按下方的步骤进行加载。
1.单击“文件”&gt;“选项”命令，弹出“Excel选项”对话框，选择“加载项”选项。
2.单击下方“转到”按钮，弹出“加载宏”对话框，在“可用加载宏”列表框中勾选“规划求解”加载项，单击“确定”按钮。
经过前面的操作，即可在“数据”选项卡的“分析”组中找到“规划求解”功能。
二、设置目标的计算公式
目标是总利润最大。总利润等于各产品的产量乘以单件利润。选择B9单元格，输入公式“=SUMPRODUCT(B7:D7,B8:D8)”，返回两个区域对应数值的乘积的和，即得到总利润。
三、规划求解
1．设置目标和变量。选择B9单元格，单击“数据”&gt;“分析”&gt;“规划求解”按钮，在弹出的“规划求解参数”对话框中，设置目标为“最大值”。（因为我们需要利润最大化。）设置“通过更改可变单元格”为“$B$8:$D$8”（生产量数值）。
2．设置约束条件。单击“添加”按钮，在弹出的“添加约束”对话框，设置材料甲的约束条件，在“单元格引用”参数框中输入“$E$3”，将“&lt;=”更改为“&gt;=”符号，在“约束”参数框中输入“$B$8*$B$3+$C$8*$C$3+$D$8*$D$3”。
用同样的方法添加材料乙、材料丙的约束条件。
材料乙：$E$4&gt;=$B$8*$B$4+$C$8*$C$4+$D$8*$D$4
材料丙：$E$5&gt;=$B$8*$B$5+$C$8*$C$5+$D$8*$D$5
3．增加产量为整数的条件。再次单击“添加”按钮，设置皮鞋、皮手套、皮帽的数量为整数的条件，在“单元格引用”参数框中输入“$B$6:$B$15”，在运算符下拉列表中选择“int”。
4．由于产品数量为非负数，勾选“使无约束变量为非负数”复选框；在“选择求解方法”下拉列表框中选择“单纯线性规划”。
5．得出答案。单击“求解”按钮，弹出“规划求解结果”对话框，单击“确定”按钮。
经过前面的操作，即可计算出每天生产皮鞋17件、皮手套50件、皮帽72件，能够实现利润最大化，总利润为5430元。
四、规划求解报告
规划求解会生成报告。再次执行“规划求解”，单击“求解”&gt;“运算结果报告”&gt;“确定”，即可得到报告。报告中清楚看到目标单元格、可变单元格及约束条件，以及是否达到条件限制。 这种方法适合于好多场合——商场进货、个体进货等，都可以哦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8961ff9a7436839bc2fd97ec6333752c/" rel="bookmark">
			vue使用maptalks-gl-layer.js加载三维地图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue使用maptalks-gl-layer.js加载三维地图 版本：
vue：2.7.14
vue-cli：3.2.1参考文档：
http://examples.maptalks.com/vtLayer/3dPolygonStyle/approachAnimation若有不清楚的地方可以参考我的另一篇文章：vue使用maptalks绘制地图教程 复制下面的内容到vue项目中public/index.html文件里 &lt;link rel="stylesheet" href="https://maptalks.com/api/maptalks.css" /&gt; &lt;script type="text/javascript" src="https://maptalks.com/api/maptalks.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="https://maptalks.com/api/maptalks-gl-layers.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="https://maptalks.com/api/dat.gui.min.js"&gt;&lt;/script&gt; 2. 在.vue文件的中写下面的代码：
&lt;template&gt; &lt;div id="map" class="container"&gt;&lt;/div&gt; &lt;/template&gt; 将官网中script中的内容（也就是下面的代码），复制到.vue的mounted函数中 const map = new maptalks.Map("map", { center: [-74.00912099912109, 40.71107610933129], zoom: 16, }); const vt = new maptalks.VectorTileLayer("vt", { urlTemplate: "http://tile.maptalks.com/test/planet-single/{z}/{x}/{y}.mvt", spatialReference: "preset-vt-3857", }); const style = { style: [{ filter: [ "all", ["==", "$layer", "building"], ["==", "$type", "Polygon"], ], renderPlugin: { dataConfig: { type: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8961ff9a7436839bc2fd97ec6333752c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0edb3b024774d367ef33799deb8be028/" rel="bookmark">
			vue使用maptalks绘制地图教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue使用maptalks绘制地图教程 一、加载最简单的地图二、加载更多地图样式 版本：
vue：2.7.14
vue-cli：3.2.1
maptalks：1.0.0
一、加载最简单的地图 在github下载js文件，链接：https://github.com/maptalks/maptalks.js/releases
解压后把要用到文件的放在public下面
打开public下面的index.html，引入要用的文件： &lt;link href="maptalks.css" rel="stylesheet" type="text/css" /&gt; &lt;script src="maptalks.min.js" type="text/javascript"&gt;&lt;/script&gt; &lt;script src="maptalks.js" type="text/javascript"&gt;&lt;/script&gt; 4. 在要展示地图的vue文件里，加入以下代码：
&lt;template&gt; &lt;div class="map_container"&gt; &lt;div style="width:800px;height:600px;" id="map"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script scoped&gt; export default { name: 'Login', data() { return { map: null, } }, methods: {}, mounted() { map = new maptalks.Map('map', { center: [0, 0], zoom: 2, baseLayer: new maptalks.TileLayer('base', { 'urlTemplate' : 'http://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', 'subdomains' : ['a','b','c','d'], 'attribution' : '&amp;copy; &lt;a href="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0edb3b024774d367ef33799deb8be028/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54ce67fedecd6e2262d4840ef0eda6e6/" rel="bookmark">
			batch_size应该怎么设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在训练中：我们通常会将batch_size设置较大，从而使得GPU或者CPU满载运行，提高训练的速度。并且会使梯度下降的方向更加准确。并且不使用较小的batch_size，举一个极端的例子：如果batch_size为1时，因为每一个样本都具有自己独特的特征，会对梯度的计算产生波动，即模型的收敛是不利的。
梯度的方差表示为：
公式解读：D(cx)=c^2D(x)
m即BATCH_SIZE设置大小，即增大BATCH_SIZE的大小可以使得梯度方差的大小减小。直接使梯度更加准确。
但在测试中：我们通常会将batch_size设置为1，主要是因为一些将数据统一的操作来使其可以放到一个batch中（例如：cv领域中的将图像调整大小致相同，NLP领域中Bert模型也会将token长度的向同一个batch中最大的长度对齐）
这样就会带来一个问题，模型效果的降低，所以在测试时：为了尽可能的表现模型的能力，设置batch_size为1。
以上的观点不适用于全部情况，应该根据自己的实际情况来看。
若输入模型数据shape固定，验证时对Batch_size无限制。
若输入模型数据shape不固定，验证时对Batch_size设置为1。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6475fdb3d5697b1518933b96afa2eff/" rel="bookmark">
			vscode中使用powershell报错解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vscode中报错 CommandNotFoundError: Your shell has not been properly configured to use ‘conda activate’. 以及
win10、win11使用WindowsPowershell 碰到 “无法加载文件 xx.ps1，因为在此系统上禁止运行脚本。 第一步：在VScode powershell comdline中执行conda init后重启vscode，出现错误无法加载文件******.ps1，因为在此系统中禁止执行脚本，这是这个信息可以先不管进行下一步就行。
如： conda init cmd.exe
conda init powershell
第二步：通过Win10 开始菜单进入PowerShell（管理员）or win11搜索power shell 在使用管理员执行 ,输入命令set-ExecutionPolicy RemoteSigned，这是在输入一个y点回车确定执行命令就行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d53b396a5bfd6b8f9019c579efa7f56a/" rel="bookmark">
			nginx配置proxy_pass代理转发时报404
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		加 / 与不加 / 在配置proxy_pass代理转发时，如果后面的url加/，表示绝对根路径；如果没有/，表示相对路径
例如
加 / server_name xxx.com location /data/ { proxy_pass http://127.0.0.1/; } 访问 http://xxx.com/data/index.xml 会转发到 http://127.0.0.1/index.html
不加 / server_name xxx.com location /data/ { proxy_pass http://127.0.0.1; } ​​​​​​​访问 ​​​​​​​http://xxx.com/data/index.xml 会转发到 ​​​​​​​http://127.0.0.1/data/index.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2426369c70fc409acebd19f475143ce6/" rel="bookmark">
			SonarQube:数据库统计项目质量情况
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景 使用SonarQube进行代码质量检查是，想导出检查结果编译记录和展现，除了一些导出插件外，可以通过数据库查询的方式根据需要查询想要的结果。
方法说明 相关数据表说明 projects：项目字典表，uuid-项目主键，name项目名，project_branches：项目代码分支，project_uuid项目主键，updated_at项目分支最后检查时间metrics：检查指标，uuid指标主键，name指标名analysis_properties：检查记录，uuid，analysis_uuid检查主键，text_value-检查场景（scm全量代码库，ci-增量代码），created_at检查时间project_measures：检查结果，metric_uuid指标主键，analysis_uuid检查主键，component_uuid项目主键 分项目统计 最近的检查结果 select ps.name,ms.name,pm.value,to_char(to_timestamp(pb.updated_at/1000),'YYYY-MM-DD HH24:MI:SS') updated_at from project_branches pb,project_measures pm, analysis_properties ap ,projects ps,metrics ms where ap.analysis_uuid = pm.analysis_uuid and ap.text_value='git' and abs(ap.created_at-pb.updated_at)&lt;60000 and ps.uuid = pb.project_uuid and pb.project_uuid = pm.component_uuid and ms.uuid=pm.metric_uuid and ms.name in('bugs','vulnerabilities','code_smells','duplicated_lines_density','ncloc') order by name 分团队项目汇总 可以根据项目名前几位进行分组时 select substr(ps.name, 0,10) team,ms.name,ROUND(sum(pm.value),2) from project_branches pb,project_measures pm, analysis_properties ap ,projects ps,metrics ms where ap.analysis_uuid = pm.analysis_uuid and ap.text_value='git' and abs(ap.created_at-pb.updated_at)&lt;60000 and ps.uuid = pb.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2426369c70fc409acebd19f475143ce6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1da8679a08a2bb228da49e53bdaaabce/" rel="bookmark">
			【课程设计】Windows控制台上的交互界面（通过c/c&#43;&#43;，在windows控制台实现选择菜单（可通过方向键选择））
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【课程设计】通过c/c++，在windows控制台实现选择菜单（可通过方向键选择） 【课程设计】通过c/c++，在控制台实现选择菜单（可通过方向键选择）前言正文SetConsoleTextAttribute函数GotoxyCursorOpr ⋆ ⋆ ⋆ \star\star\star ⋆⋆⋆TheConsoleSizeThe Whole Code 结语参考资料每日一句 【课程设计】通过c/c++，在控制台实现选择菜单（可通过方向键选择） 前言 以前做课设的时候，费了很大功夫，在windows控制台实现方向键选择菜单。希望可以在这里总结一下，也欢迎大家一起交流学习。
正文 SetConsoleTextAttribute函数 以下摘自百度百科 传送门 SetConsoleTextAttribute是Windows系统中一个可以设置控制台窗口字体颜色和背景色的计算机函数，该函数被广泛应用于软件开发中。
使用此函数前，必须包含Windows.h头文件，即#include &lt;Windows.h&gt;。原型 BOOL SetConsoleTextAttribute(HANDLE hConsoleOutput, WORD wAttributes); 宏定义以下代码： #define IN_RED SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), \ BACKGROUND_RED | \ BACKGROUND_INTENSITY) #define IN_DEFAULT SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), \ FOREGROUND_RED | \ FOREGROUND_GREEN | \ FOREGROUND_BLUE) In_Red，意味着将字体的背景变为红色；而In_DEFAULT，意味着将字体的背景变为默认状态（混合红、绿、蓝）定义函数： void ShowInRed() { IN_RED; printf("Red\n"); return; } 效果展示：
我们注意到后面的语句的背景也变红了。怎么解决这个问题呢？我们只需要在printf执行完之后，调用IN_DEFAULT，将字体背景重置为默认色即可。代码： void ShowInRed() { IN_RED; printf("Red\n"); IN_DEFAULT; return; } 结果：
Gotoxy void Gotoxy(int x, int y) { COORD pos = {x, y}; HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE); SetConsoleCursorPosition(hOut, pos); return; } 该函数的用处为将光标移动到(x, y)处 CursorOpr ⋆ ⋆ ⋆ \star\star\star ⋆⋆⋆ 下面我们重点来讲以下实现原理
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1da8679a08a2bb228da49e53bdaaabce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d42622edd8d99b8a795bc45cda47b533/" rel="bookmark">
			安装spark时输入spark-shell报错 “系统找不到指定的路径“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装spark时输入spark-shell报错 “系统找不到指定的路径“ 1、检查是不是已经安装了pyspark2、用spark-shell.cmd命令 这个问题在网上大部分人都是说 Java_Home 配置的有问题，或者调节 Java_Home 和 Spark_Home 顺序来表示执行优先级，但是我试了各种方法之后都没有成功。
1、检查是不是已经安装了pyspark 大家可以检查一下是不是已经安装了pyspark，如果之前安装了pyspark，那么此时在cmd里运行spark-shell是会找不到指定路径的。
可以先将pyspark卸载掉，用
pip uninstall pyspark 然后打开cmd输入spark-shell就可以出现。
2、用spark-shell.cmd命令 如果不卸载pyspark，那么可以用spark-shell.cmd，也可以进入spark。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4f5bbc335443dbc3dd962f71cc7908b/" rel="bookmark">
			华为交换机日常维护命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 display mac-address display mac-address | include display mac-address dynamic display arp 用来查看所有ARP表项。
display arp | exclude 从ARP表项的显示结果中屏蔽掉干扰项。
dis arp network 用来查看指定网段的ARP表项
命令格式
display arp network net-number [ net-mask | mask-length ] [ dynamic | static ]
display interface display interface ethernet brief 命令用来查看以太网接口的简要信息。（所有视图）
display current-configuration display current-configuration interface 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07350bf0d26b69b2c33ca6f33e1366f0/" rel="bookmark">
			python 自动分考场程序同班不重复不连排
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要求同一班的人员前后不相邻，python 写的分考场的程序，源数据 input.xlsx，在这个 Excel 文件中2个工作表 Sheet1 里是参考人员信息，有三列，姓名、班级、r值，Sheet2 里是考场信息，有三列，考场号、人数、考场位置。程序运行后会读取 input.xlsx 里的数据，自动分场，结果放在 output.xlsx 里。
# encoding=utf-8 # 考试分场程序，同一考场中相同班级同学前后不相临 import pandas as pd import numpy as np import sys # 生成准考证号 年级2位 考场2位 考号2位 def gen(grade,number,index): if(len(number)&lt;2): number="0"+number if(len(index)&lt;2): index="0"+index return str(grade) + number + index # 检测 DataFrame 的数据班级列有没有连续重复 def check(df): clss=df['班级'].tolist() for i,j in enumerate(clss): # 防止下标出错 try: if clss[i]==clss[i+1]: return False except: pass return True # place 考场位置 number 考场号 def arrange(df,place,number): # 随机排序法 flag=False while flag==False: rnd=np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07350bf0d26b69b2c33ca6f33e1366f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94f28d04fd99b9a4a5d1ba43826ede8b/" rel="bookmark">
			Java实现抽奖功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java实现抽奖功能 商城项目开发中经常会有抽奖这样的活动的需求，这里介绍一种简单的抽奖方式
public static void main(String[] argc) throws Exception { //定义一个集合list，可以是用户id，也可以是抽奖号码之类的 List&lt;Long&gt; list = new ArrayList&lt;Long&gt;();//用户id集合 list.add(10L); list.add(11L); list.add(12L); list.add(13L); list.add(14L); list.add(15L); list.add(16L); list.add(17L); List &lt;Long&gt; userId = new ArrayList&lt;&gt;(); Random random = new Random(); // 定义一个数组用于存放需要抽奖的名单(长度为参与抽奖的人数) Long[] name = new Long[list.size()]; for (int i = 0;i &lt; name.length;i++) { //循环录入 name[i] = list.get(i); } //想要抽取的人数(即中奖名额) int renShu = 5; int index = 0; //定义新int数组shuZi int[] shuZi = new int[renShu]; //选出想要选的人数 while(index &lt; renShu){ int num = random.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94f28d04fd99b9a4a5d1ba43826ede8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f9c1c2d2f2894caa92fef13e38163aa/" rel="bookmark">
			Error：javaJDK isn‘t specified for module问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Error：javaJDK isn‘t specified for module问题解决 Idea重启Tomcat或者重新编译出现了
Error:java:JDK isn’t specified for module
解决办法：在IDEA中关掉该项目，将文件目录下的 .idea文件删除，然后重新打开项目即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a196f2878dbfac9f4bcfaed3e6e89bd/" rel="bookmark">
			5分钟教你快速配置nginx实现访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 需求操作步骤一、开放端口二、在nginx配置文件中配置端口1）server块2）区分root和alias3）区分server块的root和location块的root4）proxy_pass处理跨域 三、根据配置文件往路径下丢包 总结 需求 工作中我们时常需要完成个性化任务，有些甚至涉及从零搭建客户需要的一套代码项目。以移动端+vue+nginx为例，如何将本地代码部署到客户现场？
操作步骤 一、开放端口 sudo firewall-cmd --zone=public --add-port=4161/tcp --permanent 很多人会忽视这一步。在我的工作场景中，可能客户现场的实施人员已经自行完成nginx部署，却发现始终无法访问。其实是因为服务器防火墙并未开放端口。（如上，以4161为例）
sudo firewall-cmd --reload 执行命令后们需要重新加载，保险起见可通过list查看是否开启此端口。
二、在nginx配置文件中配置端口 同样以4161为例，键入以下server块：
server { listen 4161; root /opt/example/h5/dist; location / { try_files $uri $uri/ /index.html; } location /h5 { alias /opt/example/h5/dist; index index.html index.htm; try_files $uri $uri/ /index.html; } location /api { proxy_pass http://172.xx.xx.xx:8080/; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $remote_addr; } } 网上有很多大佬分享了nginx相关知识，这里就简单描述一下：
1）server块 nginx配置文件的位置通常在 /nginx/conf 或是/etc/nginx 下，main块相当于全局配置、server块相当于单独为每个端口进行指定配置。
listen 4161; // 监听端口 2）区分root和alias location /h5 { root /absolute; } location /h5 { alias /relative; } root和alias的区别在于：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a196f2878dbfac9f4bcfaed3e6e89bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f60e2aa49ebb1eddcabf0f182d77e88/" rel="bookmark">
			通用Excel数据导入-不限导入的列顺序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Excel导入数据 此为一个自定义excel导入方法，基于apache.poi 此为一个自定义excel导入方法，基于apache.poi 详细的全码，可以直接在对应程序运行，涉及到的类都有详细说明，替换即可。
其中涉及到的主要依赖有apache.poi，也有用hutool.core。不知道各位具体项目引入情况，所以就不把所以依赖写出来。hutool也一半用什么引入哪些，直接hutool-all可能也会和apche的有冲突。
先上代码
import cn.hutool.core.bean.DynaBean; import cn.hutool.core.util.StrUtil; //此处为公司自定义异常已做处理--可以自行抛出RuntimeException import com.exception.RRException; //此处为公司一个文件处理工具类，代码上有说明 import com.FileUtil; import com.alibaba.fastjson.JSONObject; import org.apache.poi.hssf.usermodel.HSSFDateUtil; import org.apache.poi.ss.usermodel.*; import org.springframework.web.multipart.MultipartFile; import java.text.DecimalFormat; import java.util.*; /** * excel导入数据读取执行类 */ public class ExecuteAuto { private static final List&lt;String&gt; TRUE_VALUES = Arrays.asList("1", "是", "正确", "对", "OK", ""); private final MultipartFile file; private final List&lt;ExcelConfig&gt; header; private final Integer startRow; private final Integer startCell; private final Class disClazz; private final ResultInfo resultInfo; private Map&lt;String,ExcelConfig&gt; map; //此处一个为前端传过来的一个excel文件，用MultipartFile接收，这为一个文件工具类一般都用它接收前段传入文件，ImportConfig为下文中一个工具类，用作数据映射关系处里。 public ExecuteAuto(MultipartFile file, ImportConfig importConfig) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f60e2aa49ebb1eddcabf0f182d77e88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/667b484dd9fbf43d7ff15368538b1793/" rel="bookmark">
			VMware 虚拟机 无法打开配置文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无法创建新的虚拟机：Cannoopen配置文件“D:VMware systemhz2021-02 Centos 6 64-bit.vmx拒绝访问 Unable to create a new virtual machine: Cannotopen configuration file "D: VMware systemhz2021-02 Centos 6 64-bit.vmx拒绝访问
VMware虚拟机 无法创建新的虚拟机：Cannoopen配置文件“D:VMware systemhz2021-02 Centos 6 64-bit.vmx拒绝访问目录 一、VMware会出现如图这种情况应该如何去做？二、解决方法： 目录 一、VMware会出现如图这种情况应该如何去做？ 二、解决方法： `在桌面找到VMware 右键单击以管理员身份运行，重新创建即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1ceedb18d4e865cba4f192156a1b505/" rel="bookmark">
			Spring循环依赖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 依赖三级缓存
2 对应单例ban，在AbstractBeanFactory里的doGetBean，它里面会有个getSingleton方法，它在创建bean之前会执行beforeSingleCreation，将bean设置成正在创建中
3 在Bean实力化完成后，对应单例的，执行循环依赖的，并且再创建中的Bean会把它放到三级缓存中，使用的是addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));方法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9140791c4d71e46100533f72bb7b652c/" rel="bookmark">
			Grain: Improving Data Efficiency of Graph Neural Networks via Diversified Influence Maximization分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Grain论文详解 Link: Grain: Improving Data Efficiency of Graph Neural Networks via Diversified Influence Maximization
Github Code: https://github.com/zwt233/Grain
本文主要介绍了一种使用影响力最大化(Influence Maximization)和多样性(diversity)方法的数据选择技术，使得我们只需要选择部分信息量最大的节点进行标记后训练，就可以让测试误差达到极小值。
1 Introduction Grain提供了一个全新视角，在GNN的数据选择和社交影响力最大化(social influence maximization)之间搭建了桥梁。它介绍了一种新颖的特征传播概念和一个由影响力和多样化的双目标思想组成的多样化影响力最大化目标函数(diversified influence maximization)。并且它提供了一种有近似保证的贪心算法，用于改善数据选择的能力。
图神经网络在各个基于图的任务都达到了SOTA效果，例如节点分类和链接预测等等。但是它在训练的时候为了达到良好的效果需要大量的标注数据。因此在GNN领域中引入数据选择(data selection)是很重要的。
图神经网络从邻居节点汇聚了特征信息，但是目前的数据选择方法都忽略了图结构上的交互信息。
本文作者提出了Grain框架，一个为GNN准备的新颖的高效数据选择的框架。它的运行哲学如下：
选择GNN中最重要的特征传播部分，将其作为一种影响力的传播。类比社交影响力最大化(social influence maximization)思想，用于最大化特征传播的高效性。即通过计算节点 u u u的输入特征在特征传播过程后对节点 v v v的汇聚特征的影响程度来衡量重要性。 Grain会最大化所选择的节点集对未标注节点的影响力。Grain高效地探索了节点间的交互，并且显示的最大化被标注节点影响的未标注节点个数。
此外，除了考虑直接影响力，Grain还考虑了间接影响力(indirect influence)，在特征空间相近的节点倾向于为同一类。在这种思想下，Grain引入了多样化思想(diversity)来鼓励影响节点能够覆盖更多的节点。
Grain证明了上述的social influence和diversity influence在该问题(GNN数据选择)下都是单调和具有子模性质的，因此它提出了一种次优的贪心算法，并且通过分离出特征传播层来减少训练代价。
Grain的贡献如下：
通过active learning和social influence maximization来优化数据选择。提出了一种新的数据选择准则–&gt; diversified influence maximization，并提出了一种有近似保证的贪心算法。提出了新的目标函数，既考虑了直接影响力，又考虑了简洁影响力。高效和精准。 2 Preliminary **Activate learning: **在训练中选择数据进行标注，使得训练出来的模型对测试集的误差小。
Core-set selection: 在所有训练集中选取一部分，使得这部分训练出来的结构与训练集差距最小。
social influence maximization: 选择部分节点，使得整个社交网络中被激活的节点最多。
σ ( S ) \sigma(S) σ(S) 是指的某个传播模型下，整个节点集被选择出来的节点激活的个数。虽然计算该值是NP-Hard问题，但是由于它的不增和子模性质，我们可以给出精度在 1 − 1 e 1- \frac{1}{e} 1−e1​的保证下的贪心次优解。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9140791c4d71e46100533f72bb7b652c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c2be9446e5db14ce5d9d1682e44b04f/" rel="bookmark">
			markdown的基本用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码块语法 ```java 1.标题语法 # h1 ## h2 ### h3 2.段落标签 今天天气真好.
段落标签&lt;P&gt;&lt;/P&gt;
3.换行语法 like usin efaeaweeawfewfe
换行&lt;br&gt;
4.强调语法 加粗
加粗
语法： **加粗**(兼容性好) __加粗__ 倾斜
倾斜
*倾斜*（兼容性好） _倾斜_ 加粗倾斜
加粗倾斜
***加粗倾斜*** ___加粗倾斜___ 5.引用语法 添加一个段落
多个段落
多个段落
嵌套使用
嵌套使用
嵌套使用
带有其它元素的块引用
Revenue was off the chart.Profits were higher than ever. Everything is going according to plan.
&gt; 添加一个段落 &gt; 添加多个段落 &gt; 添加多个段落 &gt; 嵌套使用 &gt; &gt; 嵌套使用 &gt; 嵌套使用 &gt; 带有其它元素的块引用 &gt; - Revenue was off the chart.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c2be9446e5db14ce5d9d1682e44b04f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c68dc473eed9a0e4ace8121f55a7f67e/" rel="bookmark">
			Java——Ueditor自定义图片上传接口和路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、首先在富文本页面中修改上传路径，将下面代码复制在富文本页面中
UE.Editor.prototype._bkGetActionUrl = UE.Editor.prototype.getActionUrl; UE.Editor.prototype.getActionUrl = function(action) { if (action == 'uploadimage' || action == 'uploadscrawl') { return 'http://localhost:8080/ueditor/uploadimage';//这就是自定义的上传地址 } else { return this._bkGetActionUrl.call(this, action); } } 二、然后写一个对应的上传图片接口，如下
@RequestMapping(value = "/uploadimage", method = RequestMethod.POST) @ResponseBody public Map&lt;String, String&gt; uploadimage(@RequestParam(value = "upfile") MultipartFile upfile) { Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); String fileName=upfile.getOriginalFilename(); SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMddHHmmssSSS"); String filename = sdf.format(new Date()) + new Random().nextInt(1000); String fileExt = fileName.substring(fileName.lastIndexOf(".") + 1).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c68dc473eed9a0e4ace8121f55a7f67e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5479d9d0c38540e3682e8e1ddef7d0cf/" rel="bookmark">
			linux系统网络相关命令之iwlist
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 iwlist主要用来显示无线网卡的一些附加信息。
参数说明：
查询WiFi支持的频率信道命令
iwlist wlan0 channel 如果提示iwlist找不到命令，安装wireless-tools。
sudo apt install wireless-tools 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8c813e9229f27b773539ceceb687cd4/" rel="bookmark">
			Python -- 字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、字符串的表达方式
2、字符串的下标和切片
2.2 遍历
2.3 切片
3、字符串的常见操作
3.1 len
3.2 查找
3.3 判断
3.4 count
3.5 替换
3.6 内容分割
3.7 修改大小写
3.8 空格处理
3.9 字符串拼接
3.10 字符串运算符
4、成员运算符
5、字符串的format方法
5.1 概念
5.2 字段名
1、字符串的表达方式 字符串介绍
字符串可以理解为一段普通的文本内容，在python里，使用引号来表示一个字符串，不同的引号表示的效果会有区别。
字符串表示方式
a = "I'm Tom" # 一对双引号 b = 'Tom said:"I am Tom"' # 一对单引号 c = 'Tom said:"I\'m Tom"' # 转义字符 d = '''Tom said:"I'm Tom"''' # 三个单引号 e = """Tom said:"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8c813e9229f27b773539ceceb687cd4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed47edcbf7c7d397c48ab4b3e575f93c/" rel="bookmark">
			线性表·顺序表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是Koko~ 数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。 数据结构往往同高效的检索算法和索引技术有关。
本专栏将针对数据结构相关知识进行梳理及总结。建议搭配C语言版（严蔚敏版）数据结构教材使用更佳。
线性表是最常用且最简单的一种数据结构。一个线性表是n个数据元素的有限序列。在稍复杂的线性表中，一个数据元素可以由若干个数据项组成。在这种情况下，常把数据元素称为记录，含有大量记录的线性表又称文件。
同一线性表中的元素必定具有相同特性，即属同一数据对象，相邻数据元素之间存在着序偶关系。
1、线性结构的基本特征： 线性逻辑结构的非形式化描述 一个数据元素的有序（次序）集
（1）集合中必存在唯一的一个“第一元素”
（2）集合中必存在唯一的一个 “最后元素”
（3）除最后元素在外，均有 唯一的后继
（4）除第一元素之外，均有 唯一的前驱
2、线性表类型的存储结构----顺序映射 线性表具有两种结构——顺序结构和链式结构。本节主要讲解顺序结构所对应的顺序表。
顺序映象
以 x 的存储位置和 y 的存储位置之间某种关系表示逻辑关系&lt;x,y&gt;
通常情况顺序映象方法是
令y的存储位置和x的存储位置相邻。
一、顺序表的定义 顺序表，用一组地址连续的存储单元依次存储线性表的数据元素，它的逻辑地址相邻，物理地址也相邻（参照一维数组）。
顺序表的优点：简单、支持随机访问、查找方便、尾插和尾删效率高。
顺序表的缺点：数据的插入和删除慢（需要挪动后面的数据）。
顺序表的结构如下图所示，它有两个区域，一个是数据区域类似于数组，存放用户存储的数据，另一个是一个整形变量区，存放已经使用了的区域个数。
定义顺序表类型 #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #define MAXSIZE 20 //数据元素的类型 typedef int ElemType; //定义顺序表类型 typedef struct { ElemType a[MAXSIZE]; int length; //顺序表的实际长度 }SqList, *SqList; 二、顺序表的基本操作函数 对顺序表，有初始化、打印、插入、删除、查找的基本操作。
1、初始化顺序表函数 Status Init_List(SqList &amp;L) { memset(L.data, 0, sizeof(L));//初始化数据为0 L.length = 0; //初始化长度为0 return 0; } 2、创建顺序表函数 //建立线性表 void Creat_List(SqList *L) { int i; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed47edcbf7c7d397c48ab4b3e575f93c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aed984701b70092f318624e38840ffba/" rel="bookmark">
			SpringBoot入门(3.0.0)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、SpringBoot介绍 Spring Boot可以帮助我们创建可以运行的独立的、基于Spring的生产级应用程序。 SpringBoot对Spring平台和第三方库采取了开箱即用的方式，这样我们就能以最少的麻烦开始工作。 大多数Spring Boot应用程序只需要很少的Spring配置。
SpringBoot的优点：
为所有的Spring开发提供一个根本性的更快、更广泛的入门体验。开箱即用，但随着需求开始偏离默认值，需要修改默认配置。提供一系列大类项目常见的非功能特性（如嵌入式服务器、安全、度量、健康检查和外部化配置）绝对没有代码生成，也不要求XML配置。 2、SpringBoot3.0开发的系统要求 Spring Boot 3.0.1-SNAPSHOT 需要 Java 17支持，并且可以兼容到Java 19，包括Java 19。还需要 Spring Framework 6.0.2 或以上版本。
为以下构建工具提供了明确的构建支持。
构建工具 版本
Maven 3.5+
Gradle 7.x (7.5 or later)
2.1. Servlet 容器版本要求 Spring Boot支持以下嵌入式Servlet容器。
Servlet 容器 Servlet 版本
Tomcat 10.0 ; 5.0
Jetty 11.0 5.1
Undertow 2.2 (Jakarta EE 9 variant) 5.0
3、开发第一个SpringBoot项目 3.1. 创建 POM 我们需要先创建一个Maven的 pom.xml 文件。 pom.xml 是用于项目构建的配置文件。
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aed984701b70092f318624e38840ffba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3a100b68a8be915ca0f0492a16767c2/" rel="bookmark">
			【C&#43;&#43;课程设计】期末大作业 - 基于Qt开发的中国象棋软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 题目 基于Qt的中国象棋软件开发
本博客只是简略的描述论文的大致结构、框架，以及软件开发的大致过程。有兴趣的参考原文档资料。
2总体设计与主要功能 2.1概述 中国象棋是起源于中国的一种棋，属于二人对抗性游戏的一种，在中国有着悠久的历史。由于用具简单，趣味性强，成为流行极为广泛的棋艺活动。中国象棋是中国棋文化，也是中华民族的文化瑰宝，它源远流长，趣味浓厚，基本规则简明易懂。中国象棋在中国的群众中基础远远超过围棋，是普及最广的棋类项目，中国象棋已流传到十几个国家和地区。本项目主要目的为实现中国传统双人对弈游戏—中国象棋，实现了在单机或联网状态下，无论是单人还是多人，无论使用系统是否相同，均可以实现象棋游戏功能。开发全程使用 Qt Creator 4.3.0 (Community) 的 C/C++功能，基本不使用控件拖拽，并且尽量手写代码来实现相应的函数功能，以此来熟悉面向对象编程，提高手写代码能力。通过此项目，不仅自己将取得编程技术上的进步，更是对中国传统文化的一种宣扬和推广。
最终程序运行效果如图1、图2所示：
图1 主菜单界面图 图2 游戏界面效果图
项目重难点分析：
棋子和棋盘的绘画棋子ID的确定每一类型棋子的规则制定多界面之间的切换对战计时模块的实现悔棋模块的实现人机对战中AI的算法
程序总体流程如图3所示。 图3 游戏流程图
2.2模块划分 对于这个基于QT的中国象棋游戏的项目，因QT本身提供了良好的封装机制，使得它的模块化非常高，可重用性良好。
此项目分为登录界面、用户选择界面、人机对战、人人对战、关于作者五个模块。如图4所示。
图4模块层次图
2.3各模块功能介绍 2.3.1 登录界面和用户选择界面 登录界面作为程序初始界面，用户需要输入正确的用户名和密码才能进入程序下一界面，用户选择界面为用户提供了人人对战、人机对战、关于作者三个选项，用户点击一个按钮进入对应的窗口。
2.3.2人人对战 作为最主要、最核心的基类，也是最开始就单独保持运行的玩家和自己对战的游戏模块。包含有棋子类，在创建和绘画棋盘的时候，要在构造函数里里面对32颗棋子进行初始化赋值。ChessBoard类实现了棋子的创建、棋子的初始化、棋盘的创建、棋盘的初始化、游戏规则指定等任务，同时三大模块之一的人人对战也将在这个类中实现。
2.3.3人机对战 这个模块实现了用户和电脑下棋的功能，由MachineGame类实现。该类继承于ChessBoard类，在已经实现了人人对战的基础上，只需实现几个AI算法函数，这样大大减少了不必要的编程工作量。
2.3.4关于作者 此模块显示作者信息：为本人的学号及姓名。
3 详细设计与实现 3.1登录界面的设计实现 添加一个设计师界面类，选择界面模板Dialog without Buttons，而后在其ui界面添加相关控件，如图5所示。
图5 UI界面控件添加
在on_loginBtn_clicked()函数中设置默认用户名为：jjxq，密码为1234，这通过检测用户的输入与设定的数据是否相等来实现，即以下if语句：
if(ui-&gt;usrLineEdit-&gt;text().trimmed()==tr("jjxq") &amp;&amp;ui-&gt;pwdLineEdit-&gt;text().trimmed()==tr("1234")) 如果用户输入错误，则弹出提示信息：
QMessageBox::warning(this,tr("警告！"),tr("用户名或密码错误！"),QMessageBox::Yes); 3.2棋子的设计实现 棋子共有三十二个，分为红、黑两组，每组共十六个，各分七种，其名称和数目如下：
红棋子：帅一个，车、马、炮、相、仕各两个，兵五个。
黑棋子：将一个，车、马、炮、象、士各两个，卒五个。
一个棋子包括了它的名称（ID号）、状态（是否死亡）、是红棋还是黑棋、它在棋盘中的位置（几行几列）等信息。棋子由ChessPieces类实现,其包含以下私有成员变量：
enum m_emTYPE{JIANG, SHI, XIANG, MA, CHE, PAO, BING}; int m_nRow; int m_nCol; int m_nID; bool m_bDead; bool m_bRed; m_emTYPE m_emType; 其中，棋子的位置由结构体pos实现，包含了棋子所在行、所在列、以及棋子类型的信息：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3a100b68a8be915ca0f0492a16767c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8ad98b59e567889f02bbe345f665259/" rel="bookmark">
			MySQL大表变更“字段/索引“可能会引发的锁表问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 参考：
亿级大表在线不锁表变更字段与索引_华为云官方博客-CSDN博客mysql该字段锁表_Mysql笔记（七）~ 大表加字段不锁表方案_weixin_39871162的博客-CSDN博客 声明：加索引可以不锁表，MySQL 5.6 以上的新特性，可参考：MySQL 5.6版本新特性之Online DDL：在线变更表结构且不阻塞数据库服务
背景：
大家在日常工作中，往往需要对数据库的表结构做变更，一般涉及到增删字段，修改字段属性等ALTER的操作。然而，在大表场景下，特别是千万级、亿级的大表，如果处理不当，这些操作往往会引发锁表的巨大隐患，特别是在生产环境中，一旦在变更表结构过程中，出现了长时间锁表，会导致用户产生的数据长时间无法正常变更到表中，进而导致服务功能异常，结果将是灾难性的。
一般执行这种Alter类型的变更，我们可能有以下的想法：
停服，在停服期间做表结构的变更，自然就可以防止对用户产生影响。但是，很多场景是不允许停服的。而且如果表的数据量达到上亿，那么需要停服时间可能需要十几个小时，甚至更长，这是极不现实的；凌晨执行，在用户较少的时间段内，做变更，尽量减少对用户产生影响。但是如果出现锁表的话，万一有用户使用服务，服务将不可用；使用临时表，但是缺点是复制数据到新表期间，如果用户在这期间做了update或delete操作，且数据修改发生在之前已经复制完成的部分，那么将无法感知到这部分数据，导致丢失掉用户的操作数据，风险太大；使用存储过程分批更新，缺点是执行时间会很久，且有可能影响到用户的DDL操作。因为为了防止每次循环修改时，锁住太多数据行，我们需要控制每次更新数据的行数，粒度不能太大，否则很有可能会锁住用户正在操作的数据行。 具体操作步骤：
创建一个临时的新表，首先复制旧表的结构(包含索引)
create table new_table like old_table;
给新表加上新增的字段
把旧表的数据复制过来（需注意复制过程也需要时间，这时如果有已经复制完的数据又被用户修改后，可能会导致复制后的数据不能保持最新的。所以原表如果有记录了数据的写入时间字段就最好了（比如modify_time），可以找到执行这一步操作之后的数据，并重复导入到新表，直到数据差异很小。不过还是会可能损失极少量的数据。）
insert into new_table(filed1,filed2…) select filed1,filed2,… from old_table;
删除旧表，重命名新表的名字为旧表的名字
建议：
尽量选择请求流量小的时间执行执行时先看一下有没有未提交的事务，注意查看事物 information_schema.innodb_trx 表随时关注服务器日志状况，已有问题要先行解决后续可先在预发环境或测试环境先行模拟，评估风险 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0d675090c118bef97009b5c39454944/" rel="bookmark">
			组件化开发必备：Gradle 依赖切换源码的实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近，因为开发的时候经改动依赖的库，所以，我想对 Gradle 脚本做一个调整，用来动态地将依赖替换为源码。这里以 android-mvvm-and-architecture 这个工程为例。该工程以依赖的形式引用了我的另一个工程 AndroidUtils。在之前，当我需要对 AndroidUtils 这个工程源码进行调整时，一般来说有两种解决办法。
1、一般的修改办法 一种方式是，直接修改 AndroidUtils 这个项目的源码，然后将其发布到 MavenCentral. 等它在 MavenCentral 中生效之后，再将项目中的依赖替换为最新的依赖。这种方式可行，但是修改的周期太长。
另外一种方式是，修改 Gradle 脚本，手动地将依赖替换为源码依赖。此时，需要做几处修改，
修改 1，在 settings.gradle 里面将源码作为子工程添加到项目中，
include ':utils-core', ':utils-ktx' project(':utils-core').projectDir = new File('../AndroidUtils/utils') project(':utils-ktx').projectDir = new File('../AndroidUtils/utils-ktx') 修改 2，将依赖替换为工程引用，
// implementation "com.github.Shouheng88:utils-core:$androidUtilsVersion" // implementation "com.github.Shouheng88:utils-ktx:$androidUtilsVersion" // 上面的依赖替换为下面的工程引用 implementation project(":utils-core") implementation project(":utils-ktx") 这种方式亦可行，只不过过于繁琐，需要手动修改 Gradle 的构建脚本。
2、通过 Gradle 脚本动态修改依赖 其实 Gradle 是支持动态修改项目中的依赖的。动态修改依赖在上述场景，特别是组件化的场景中非常有效。这里我参考了公司组件化的切换源码的实现方式，用了 90 行左右的代码就实现了上述需求。
2.1 配置文件和工作流程抽象 这种实现方式里比较重要的一环是对切换源码工作机制的抽象。这里我重新定义了一个 json 配置文件，
[ { "name": "AndroidUtils", "url": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0d675090c118bef97009b5c39454944/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e65158d20042721576d16bf86f7a15bf/" rel="bookmark">
			Mysql查看表结构的三种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录： mysql查看表结构
方法：
show create tabledescinformation_schema.COLUMNS 表结构： 获取所有的表结构及备注
根据库名导出所有表信息
根据库名导出所有表名及表备注
mysql获取整个库的所有表，及表结构
方法：
show create table
这个语句每次本能想出的，语义好记，可以直接查看建表语句，但不便于代码处理。desc 表名称
这个语句简单易用，可以获取到 COLUMNS 中的比较重要的字段：名称、类型、是否为空、键、默认值、额外信息。但无法获取字段的注释。information_schema.COLUMNS
select * from information_schema.COLUMNS where TABLE_SCHEMA = '库名称' and TABLE_NAME = '表名称' information_schema.COLUMNS字段和含义： 字段名称及含义
如下：
TABLE_CATALOG表类型（没搞懂干啥用？）TABLE_SCHEMA所属库名称TABLE_NAME表名称COLUMN_NAME字段名称ORDINAL_POSITION位置序号COLUMN_DEFAULT默认值IS_NULLABLE是否可为空DATA_TYPE数据类型CHARACTER_MAXIMUM_LENGTH字符串最大长度（数值类型为空）CHARACTER_OCTET_LENGTH字符串最大存储长度（一般与上一字段相同）NUMERIC_PRECISION数值精度（非数值类型为空）NUMERIC_SCALE数值小数位数（非数值类型为空）DATETIME_PRECISION日期精度CHARACTER_SET_NAME编码方式COLLATION_NAME排序方式COLUMN_TYPE字段类型COLUMN_KEY字段涉及的key（主键、唯一键等）EXTRA其他（如 auto_increment）PRIVILEGES权限COLUMN_COMMENT字段注释GENERATION_EXPRESSION代表达式（没搞懂，mysql可以表继承？） 获取所有的表结构及备注： 根据需要调整SQL语句
如下：
根据库名导出所有表信息
SELECT
*
FROM
information_schema.`TABLES`
WHERE
TABLE_SCHEMA = 'db_name'根据库名导出所有表名及表备注
SELECT
TABLE_NAME,
TABLE_COMMENT
FROM
information_schema.`TABLES`
WHERE
TABLE_SCHEMA = 'db_name';mysql获取整个库的所有表，及表结构
SELECT
TABLE_SCHEMA AS '库名',
TABLE_NAME AS '表名',
COLUMN_NAME AS '列名',
ORDINAL_POSITION AS '列的排列顺序',
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e65158d20042721576d16bf86f7a15bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/803b7c475d018384bce5e17957d46662/" rel="bookmark">
			互动抽奖背后的随机性与算法实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 抽奖，是一种典型的互动玩法形式。无论是大V的粉丝抽奖，还是活动会场的参与抽奖，这种起源于彩票开奖的互动玩法，同时兼顾了高期待感和低预期的特征，让活动在成本控制之余又能有惊喜和引爆点，这样的优势让其在各种运营场景中幻化万千，大行其道。
在闲鱼各种互动场与营销活动中，抽奖自然也是一个相当高频使用的互动玩法。众所周知，越是经典的玩法，业务需求就越发别出机杼，在参与条件、开奖展示、奖品规则等各方面千变万化，闲鱼内典型的就有现金夺宝、低碳双十一抽iphone、旧衣回收抽锦鲤等，不胜枚举。
本系列文章的出发点即是从技术的视角出发，讲一讲抽奖这种互动玩法自底向上的各种思考。而本文主要探讨的，就是抽奖随机性的来源和常用的算法实现。
关于随机 抽奖最需要保证的，其实是公平的产生抽奖结果，而这个公平，则来自于足够随机的抽奖算法，而抽奖算法不论怎么设计，常常依赖于计算机随机数的发生。不妨先来看一看万仞之基础——随机数是怎么产生的。
伪随机数与其产生——线性同余 为了效率和成本计，现在常用的随机数的产生方式往往是伪随机数，最广为流行的就是线性同余产生器，其本质非常直白：
不难看出，其中的a、b、p的取值，就是是否能产出随机分布的数据根本所在。基本数论的常识告诉我们，这个同余式的取值必定在[0,p-1]的范围内封闭，并且拥有最大为p的周期，或者是多个较小但互不重合的周期构成，当其周期为p时，其式就成为了0到p-1的一个离散排列。
之所以这个看似简单的式子，能够成为随机数的生成方法，正是因为模数运算的良好特性，一来其在周期内绝不会出现重复结果，二来其分布也相对均匀。可以将f(x)/p视为[0,1)范围内的平均分布。
参数取值 所以，我们的第一个问题，就必然是探索，在参数满足什么条件时，能将这个函数的周期尽可能的扩大，以更有效的利用其周期特性，挖掘这个式子产出的随机性。
我们先从模数p开始，不论其他，光凭数学直觉就会让人下意识的想取一个大素数，以此轻易攫取优越的分布特性和天然形成的宽周期。
但是，我们要注意到，伪随机数作为一个非常底层的方法，其存在本身就是为了效率的，取模操作虽然不算慢，但此时就会有一个更加优越的模数跃入眼帘，那就是2^n——不但可以直接将取模操作退化为移位和与操作，也可以很轻松的理解随机数的取值范围。当然，这个周期比起素周期也更方便均分以转化为其他范围的随机函数。
当然，模数不是素数的情况下，就对a、b的取值有了更大的约束。为了取得一个满周期序列的生成方法，The Art of Computer Programming中论证了其充要条件，也是现在大部分线性同余产生器的构造依据：
• b与p互质
• c=a-1是p所有素因子的倍数
• 若p是4的倍数，c也是4的倍数
我们可以看到，这其中对加数b的约束其实非常小，于是在gcc中，就比较随意的选择了个12345，java中干脆是个小素数11。而对于a的取值，在已知我们取模数为2^n时，就非常容易得知其约束条件：a-1是4的倍数。
实现时的考量 现在我们满怀欢喜的得到一个满周期序列的生成方法，似乎只需要按照某些特性去选一些优秀的生成参数就可以跑起来成为一个经典库了。但事情还没有这么简单。
刚才我们的选择还遗留了一个问题，我们往往不是直接使用一个全模数范围的随机，而是由大周期的随机数取模转化为一个更小的周期来随机——只要大范围的随机函数能保证概率均等，取模后自然也是一个均匀分布的函数：
——但是以上方式有一个天然的缺陷，当我们的模数m与2的幂次相关时，其低位随机性并不是很好——低位周期的分布也会在这个小周期上呈现周期，形式化地说，就是：
也总是一个满周期序列，所以，无论怎么去改变参数分布，在模数非素的情况下，随机的分布都会呈现一个特别均匀的形式，当我们想取得范围特别小时，比如我们只需要0-1的整数，这个算法就会持续输出0、1、0、1、0、1、0、1。当然，它仍然是满周期的，但是呈现出的结果完全违背了我们对于“随机”这件事的直觉，可预测性太强了。
这个时候，我们重新回顾一下，就会发现，我们想要的其实不是满周期的随机性，当周期非常小的时候，我们更期待的是超越本周期的随机性分布，比如，给0-1的随机安排一个00101110这样的周期序列，这个要求在本周期的计算比较难达成的，但是既然这个小周期是由一个更大的周期序列摘取到的，我们就能够将大周期的随机性反映到小周期当中去。
很多平台的实现当中，是舍弃这些随机性不强的低比特位，换为截取高位比特位作为结果序列，这样当然会导致该序列一些很好的数列特性消失，但是从而也增强了其本身的随机性。
比如在java的实现中：
private final AtomicLong seed; private static final long multiplier = 0x5DEECE66DL; private static final long addend = 0xBL; private static final long mask = (1L &lt;&lt; 48) - 1; protected int next(int bits) { long oldseed, nextseed; AtomicLong seed = this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/803b7c475d018384bce5e17957d46662/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f06227003c9cb649aa42ca6293a8fac/" rel="bookmark">
			GanttChart
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GanttChart github中的Gantt Chart github:这是目前还算活跃的代码质量不错的基于Vue的甘特图开源项目：
https://github.com/w1301625107/Vue-Gantt-chart
https://github.com/neuronetio/gantt-elastic
https://github.com/mikaeljorhult/segel
https://github.com/w1301625107/Gantt-chart
https://github.com/InfectoOne/vue-ganttastic
https://github.com/Cavend/Vue-D3-GanttChart
https://github.com/Cavend/Echart-Vue-Gantt-Chart
https://github.com/mvsde/vue-project-timeline
https://github.com/neuronetio/vue-gantt-schedule-timeline-calendar
https://github.com/w1301625107/Gantt-chart/blob/master/baseOnVue.html
经过更细致的筛选之后，确定了一下几个精选示例：
https://github.com/w1301625107/Vue-Gantt-chart
https://github.com/w1301625107/Gantt-chart/blob/master/baseOnVue.html
https://github.com/InfectoOne/vue-ganttastic
https://github.com/mvsde/vue-pr
只存链接，详细日后写完demo再补充。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9d19490899ff74b112ba10d139d583a/" rel="bookmark">
			Java基础疑难点梳理(泛型到反射9章内容)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 泛型2. 基础类库3. 集合4. 异常5. 注解6. JDBC7. IO流8. 网络编程9. 类加载和反射 1. 泛型 静态方法的形参，静态变量，静态代码块中不能使用泛型（因为即使泛型不同，还是同一个类，静态变量是属于类的）
instanceof运算符后不能跟泛型类：a instanceof ArrayList&lt;String&gt;
A extends B A[]是B[]的子类 但是List&lt;A&gt; 不是List&lt;B&gt;的子类
通配符的使用
public static void main(String[] args) { List&lt;Integer&gt; integers = new ArrayList&lt;&gt;(); //f1(integers); 不能调用 List&lt;Integer&gt; 不是 List&lt;Object&gt; list子类 f2(integers);//可以使用通配符调用 } public static void f1(List&lt;Object&gt; list){ for (Object o : list) { System.out.println(o); } list.add("123"); list.add(123); } public static void f2(List&lt;?&gt; list){ for (Object o : list) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9d19490899ff74b112ba10d139d583a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/383af8669a047039904e5362490c4dbd/" rel="bookmark">
			webstorm上没有Element-ui的提示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前提,在已经安装element-ui的情况下,看网上的例子说是在
Setting----Languages &amp; Frameworks----JavaScript----Libararies
第一次出现这个问题的时候我发现自带的项目库,也就是下图中最下面未选中node_modules不是打勾的状态,而是横线未全选,我把他取消选中重新选中之后加载重启后解决问题。
第二次出现，再次记录一下，我以为和之前一样他是未全选状态，但发现不是，然后去网上搜了一下，有帖子说，可以在右侧add一下element-ui的库，从下面第二个图哪里去选node_modules中的element-ui,我的试了，但是没有用，，然后我就想到了，把整个node_modules重新加载一下，重启ide之后问题解决。
可以先试一下单独添加element-ui的库，如果可以，就无需添加node_modules，毕竟整个库文件太大，加载会比较耗时
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5792ac029d4ade4e98fd340c8f1d4fd/" rel="bookmark">
			Java——时间戳和时间格式转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时间戳(TimeStamp)：通常是一个字符序列，唯一地标志某一刻的时间。Java 中时间戳是指格林威治时间1970年01月01日00时00分00秒起至现在的总毫秒数。
一、获取时间戳的方式
1.System.currentTimeMillis(); 2.Calendar.getInstance().getTimeInMillis(); 3.newDate().getTime(); 二、Date类
1、无参构造方法——返回结果Thu Dec 15 09:55:39 CST 2022
public Date() { this(System.currentTimeMillis()); } 2、有参构造方法——已废弃
public Date(long date) { fastTime = date; } 三、时间格式转换
1、获取当前时间字符串
SimpleDateFormat dateFormat = new SimpleDateFormat(); String dataStr = dateFormat.format(new Date()); 2、获取固定格式当前时间字符串
SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-dd-MM HH:mm:ss"); String dataStr = dateFormat.format(new Date()); 3、时间字符串转格式（yyyyMMddHHmmss ——&gt; yyyy-MM-dd HH:mm:ss ）
String dateStr = "20210818154600"; SimpleDateFormat sdfF = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); SimpleDateFormat sdfP = new SimpleDateFormat("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5792ac029d4ade4e98fd340c8f1d4fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93d93ebbefcbef67fde1905cd49a5962/" rel="bookmark">
			【经验记录】在ENSP中ping一台设备丢包，可能是运行ENSP的电脑资源消耗过多导致设备无法发送返回的ICMP echo包导致。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【经验记录】在ENSP中ping一台设备丢包，可能是运行ENSP的电脑资源消耗过多导致设备无法发送返回的ICMP echo包导致。关闭无关的设备，可以减少资源占用，就可以ping通了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2704a0ac31f70c895b444f18c19c3b64/" rel="bookmark">
			JVM性能监控与分析工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 jps 用于查看正在运行的java程序及相关信息
jps -m:显示运行传入朱磊的参数.
jps -v: 显示虚拟机参数。
jsp -l: 显示运行的主类全名或者JAR包名称。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01209d74ffd8b4d9a2f1ea2a4eaba84a/" rel="bookmark">
			BeanFactory和DefaultListtableBeanFactory
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 BeanDefinitionRegistry 提供注册增、删、查BeanDefinition的api
2 BeanDefinitionRegistry的唯一实现是DefaultListableBeanFactory
3 BeanFactoryPostProcessor 在创建bean实例化之，动态修改bean定义的属性值
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc4e6e2c10c2edb51c534f69b6a97f74/" rel="bookmark">
			.net core/5/6/7中WPF如何优雅的开始开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WPF是微软的.net平台中的一个桌面客户端应用程序框架,经常用于企业开发windows桌面客户端,广泛应用于中小企业快速开发一款工具，本人也是比较喜欢利用WPF开发一些小工具。
知名案例 1.虎牙直播客户端
2.西门子医疗上位机
其中西门子医疗的上位机程序称得上使用WPF技术的极其优秀的项目。(:德国人写代码真的很严格工整。
当然西门子的.net还是基于framework，模块之间通信用的WCF,依赖注入使用的spring.net我在的时候好像准备改成Autofac了。扯远了~
.net core/5/6/7中开发WPF 伴随着.net5这个半成品出世，.net framework和core正式合并到一起，在core中也是支持创建WPF模板代码的，那么我们如何在新的平台下优雅的使用WPF开发一个小工具呢？
MVVM 老的framework我喜欢使用MvvmLightLibs，但是目前用过的都知道该包已经被标记为弃用了，推荐使用微软的CommunityToolkit.Mvvm，我们可以在项目文件中添加该包的引用
&lt;PackageReference Include="CommunityToolkit.Mvvm" Version="8.0.0" /&gt; 添加好了之后我们将我们的viewmodel继承ObservableObject具体使用可以看园子里的一篇文章https://www.cnblogs.com/dino623/p/building_MVVM_programs_using_MVVM_Toolkit.html
示例代码：
public class MainWindowViewModel : ObservableObject { /// &lt;summary&gt; /// 属性变更通知 /// &lt;/summary&gt; private Page _currentPage; public Page CurrentPage { get =&gt; _currentPage; set =&gt; SetProperty(ref _currentPage, value); } //命令绑定 public RelayCommand ShiftWorkPageCommand { get; set; } public RelayCommand OpenWorkSpaceCommand { get; set; } } } 当然该包还带了同进程下模块发布订阅的实现。本身的事件也支持绑定异步方法。
DI 常用的依赖注入组件有spring.net，autofac，当然autofac在现在看来也是非常流行强大的。.net一直有一个自带的依赖注入容器，功能没有autofac强大，但是一般也够用。我们需要在项目文件中导入微软提供的相关的包。
&lt;PackageReference Include="Microsoft.Extensions.Hosting" Version="6.0.1" /&gt; &lt;PackageReference Include="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc4e6e2c10c2edb51c534f69b6a97f74/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0be6c6ba58c52dab8919e7f0bda2b60/" rel="bookmark">
			例1 反转一个三位数（Python）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述：
反转一个只有三位数的整数。
例如输入number = 123，输出 321；输入number = 900，输出 9。 方法一：字符串分割
str = input("输入：") a,b,c = str[0],str[1],str[2] if c == "0": if b == "0": result = int(a) else: result = int(b+a) else: result = int(c+b+a) print("输出:",result) 方法二：纯计算（取余）
number = int(input("输入：")) a = number // 100 b = (number // 10) % 10 c = number % 10 if c == 0: if b == 0: result = a else: result = b * 10 + a else: result = c * 100 + b * 10 + a print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0be6c6ba58c52dab8919e7f0bda2b60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f11509d8132f240447fab12e7dd49033/" rel="bookmark">
			Ubuntu20.04 安装配置 Ros2 (原)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录一下折磨了一周的ros2配置qaq以及踩的无数坑
第一次按照一个教程安装后，命令行输入sudo apt-update 报错 The repository 'http://packages.ros.org/ros/ubuntu $(lsb_release-sc) Release' does not have a Release file.
卸载后，按照第二个教程安装
ROS 2 Documentation: Foxyhttps://docs.ros.org/en/foxy/Installation/Ubuntu-Install-Debians.html
添加 gpg key 的步骤无法完成，修改后的整体安装流程如下：
Set locale sudo apt update &amp;&amp; sudo apt install locales sudo locale-gen en_US en_US.UTF-8 sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8 export LANG=en_US.UTF-8 Setup Sources 确保 Ubuntu Universe repository 已启用
sudo apt install software-properties-common sudo add-apt-repository universe 教程原文：用apt方法添加 ROS2 GPG key
sudo apt update &amp;&amp; sudo apt install curl sudo curl -sSL https://raw.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f11509d8132f240447fab12e7dd49033/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d28de93feeada2eeb9533245e97c08e4/" rel="bookmark">
			cherry-pick多次
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 git cherry-pick命令执行多次，会怎样？以下通过idea进行演示，先总结结论：
1、cherry-pick无冲突时，仅能执行一次此命令，第二次cherry-pick会直接卡住
2、cherry-pick有冲突时，可执行多次此命令，每次都是拿各分支最新代码让人合并，每次执行都要解决冲突
下面通过idea实际操作，验证以上结论。我们选定dev分支、st分支，选定hjtest1.txt、hjtest2.txt文件进行分支冲突和cherry-pick操作。
首先先看idea上cherrypick该怎么操做
下图是把dev分支，选中一条代码合并到st上，即cherry-pick一条到st上。单击这条提交记录-&gt;右键Cherry-Pick即可
上图是无冲突的情况，可看到左下角直接提示：Cherry-pick successful。之后我们进行正常push代码即可，此条提交记录就合到st上了。
我们再次进行右键Cherry-Pick，即验证无冲突情况的多次Cherry-Pick。此时idea报错，如下：
至此，情况1验证完毕
对于情况2，我们先制造分支冲突，制造完分支冲突后Cherry-pick效果如下图所示：
上图中，左侧为st分支，右侧为dev分支，次Cherry-Pick是为了将dev代码合并至st。即dev为源头分支，st为目标分支，我们将本地分支切为st分支。
我们进行冲突合并，合并后如下图所示：
这里插一下，如果我们某次 Cherry-Pick不想要了，可通过Abort Cherry-Pick取消：
之后我们push掉合并后的代码（如果没push，那当前是处于Cherry-picking状态的，是无法再次Cherry-Pick的）。
然后进行再次Cherry-Pick，此时仍发生冲突，冲突情况如下图所示：
可以看到，左侧st代码已变为最新合并后的代码，即验证情况2的结论。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a79369fc3a99fae8aa3ab2b2010674cf/" rel="bookmark">
			Pycharm创建QT工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装工具包pyqt5和PyQt5-tools 添加环境变量 把上面变量添加到Paty中 Pycharm创建QT工具 先添加Qt-Designer应用 $FileDir$ $	ProjectFileDir$ 点击工具里面的External Tools 若出现弹框报错 解决方案是将pyqt5_tools\Qt\plugins文件夹进行复制，覆盖到site-packages\pyqt5_tools\Qt\bin目录下，覆盖后的文件夹如下： 就可以打开应用 使用QT应用先创建 进行添加图片操作 先创建文件名 添加图片和目录完成 保存指定位置 用pycharm进行打开 pycharm添加PyUIC：这个是对ui后缀的代码转换成python代码 添加对应的设置参数 C:\USEAPP\Anaconda\envs\QTES\python.exe -m PyQt5.uic.pyuic $FileName$ -o $FileNameWithoutExtension$.py 最后是写上你创建好的UI对应的目录地址 第二种直接用python直接运行 python -m PyQt5.uic.pyuic ui文件名 -o 转成的python文件名 第三种方式 pyuic5 ui文件名 -o 转成的python文件名 找到对应的pyuic5：C:\USEAPP\Anaconda\envs\QTES\Scripts\pyuic5 demo.ui -o demo.py 或者：C:\USEAPP\Anaconda\pkgs\pyqt-5.6.0-py37ha878b3d_6\Library\bin\pyuic5 demo.ui -o demo.py 转换程序，ui文件转换成py文件 对应的代码转换成功 在尾部添加代码 if __name__ == '__main__': import sys from PyQt5.QtWidgets import QApplication, QMainWindow import jes# 导入添加的资源（如转换成功的照片py代码）（根据实际情况填写文件名） app = QApplication(sys.argv) MainWindow = QMainWindow() ui = Ui_MainWindow() ui.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a79369fc3a99fae8aa3ab2b2010674cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da056314c75471ccc391fe915be551d7/" rel="bookmark">
			有了这几个软件安全测试工具，编写安全测试报告再也不愁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件的安全是开发人员、测试人员、企业以及用户共同关心的话题，尤其是软件产品的使用者，因为系统中承载着用户的个人信息、人际互动、管理权限等各类隐私海量关键数据。软件安全测试工作不仅是为了用户，更牵扯到许多的利益共同体。因此软件安全测试必不可少，在测试过程中安全测试工具的选择也尤为重要。小编整理了以下几个软件安全测试工具，让你编写安全测试报告再也不愁。
1、IBM AppScan
一个领先的web应用安全工具，可自动进行安全漏洞评估、扫描和检测所有常见的web应用安全漏洞，如：SQL注入、跨站点脚本攻击(CSS)、缓冲区溢出等。
2、Burp Suite
一个用于攻击web应用程序的集成平台，包含大量的安全测试工具，并为这些工具设计了对外访问接口，以加快攻击应用程序的过程。
3、Metasploit
一款开源的安全漏洞检测工具，可以帮助安全人员和IT专业人士识别安全性问题，挖掘漏洞，攻击漏洞，并评估漏洞风险级别。
4、Wireshark
适用于Windows和Linux的网络协议分析工具，也是一个很出名的数据包分析工具，可以检查网络流量，是观察TCP/IP异常流量的很好的工具。
5、Kail Linux
目前比较流行的安全渗透测试平台，包含了最新的安全测试工具，允许用户从CD或者U盘启动，通过U盘来实施安全渗透测试。
软件测试除了测试工具的助力外，测试团队的选择同样重要。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3aa734bd3903dd7f7cb71efe4e41da55/" rel="bookmark">
			node只能以管理员的身份运行才能正常使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		node只能以管理员的身份运行才能正常使用，解决办法 下载node后，默认下载包安装在c盘中，
修改方式：
npm config set prefix “D:\Program Files\nodejs\node_global”
npm config set cache “D:\Program Files\nodejs\node_cache”
修改完成后，在环境变量中配置好环境，这里不做细讲
使用node下包或者创建项目的时候：
只能使用超级管理员的身份才能正常使用
解决办法：
1.先到C:\Users{账户}\下的.npmrc文件
注意：这个文件默认是被隐藏，一定要选择将隐藏取消掉
删除.npmrc文件
2.删除c盘中的npm文件
同上地址：位置C:\Users{账户}\AppData\Roaming
删除npm，之后就可以正常使用cmd了，不需要管理员身份运行即可正常使用
注：有些电脑配置完需要关机
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec1a0d12a195dde1f2f7353f5b061a06/" rel="bookmark">
			【VUE3】下载文件流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VUE3+TS 下载文件流
/** * @description: 下载文件流 * @param { string } url 请求路径 * @param { MISSING_TYPE } params 请求参数 */ export const downloadFile = &lt;T = MISSING_TYPE&gt;(url: string, params: T) =&gt; { //用于与服务器通信 const xhr = new XMLHttpRequest() //用于打开服务器连接 xhr.open('post', url, true) const headers = requestHeaders({ //告诉服务器发送数据格式 'Content-Type': 'application/json;charset=UTF-8', }) //设置请求头 Object.keys(headers).forEach((item) =&gt; { xhr.setRequestHeader(item, headers[item] as string) }) // 存储下载文件内容 xhr.responseType = 'arraybuffer' xhr.send(JSON.stringify(params)) xhr.onload = function () { // 304表示资源未更改，通常用于缓存控制 if (xhr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec1a0d12a195dde1f2f7353f5b061a06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcaf4d6e71dbe7209cc81c0067e2451a/" rel="bookmark">
			microsoft yarp Reverse Proxy 与 Nginx 配置替换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		yarp 取代Nginx的几个配置项：
路由匹配： Nginx：
location /WebUI Yarp：在Routes中增加
"svc-web-route": { "ClusterId": "svc-web-cluster", "Match": { "Path": "/WebUI/{**catch-all}" } }, 路由转发： Nginx：
proxy_pass http://svc-api; Yarp： 在Clusters中增加
"Destinations": { "svc-api-destination": { "Address": "http://svc-api" } }, 默认页面： Nginx：
index index.html index.htm; Yarp：暂时没找到，可由程序完成默认路由
超时配置 Nginx：
proxy_connect_timeout 300; proxy_send_timeout 300; proxy_read_timeout 300; Yarp：在Clusters中增加
"HttpRequest": { "ActivityTimeout": "00:03:00" } 重定向关闭 proxy_redirect off;
替换方案：默认关闭
Forward配置 Nignx:
proxy_set_header X-Forwarded-Proto $http_X_Forwarded_Proto; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; Yarp：默认 X-Forwarded-For，X-Forwarded-Proto，X-Forwarded-Host ,可在 Transforms 中修改
地址重写 我们一般会增加一个固定前缀到后端，或者删除一个前缀到后端
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcaf4d6e71dbe7209cc81c0067e2451a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/756bf4444257587541440a3e1c65fe91/" rel="bookmark">
			c# 请求接口302重定向获取不到cookie
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出现问题：请求三方接口的时候，用postman测试过，能获取到cookie值。在项目中，接口获取不到cookie，且返回状态为302重定向。
解决办法 设置参数： AllowAutoRedirect = false;
默认值为true
true如果希望处理程序自动遵循 HTTP 重定向标头到资源的新位置
如果 AllowAutoRedirect 设置为 false，则 HTTP 状态代码为 300 到 399 的所有 HTTP 响应将返回到应用程序
HttpWebRequest request = (HttpWebRequest)WebRequest.Create(url); request.Method = "Get"; request.AllowAutoRedirect = false; CookieContainer cookieContainer = new CookieContainer(); Cookie JSESSIONID = new Cookie("JSESSIONID", Global.JSESSIONID); JSESSIONID.Domain = "xxx.xxx.xxx.xxx"; cookieContainer.Add(JSESSIONID); request.CookieContainer = cookieContainer; //--------------------------------------------------- //响应 //--------------------------------------------------- HttpWebResponse response = (HttpWebResponse)request.GetResponse(); Stream rspStream = response.GetResponseStream(); using (StreamReader reader = new StreamReader(rspStream, Encoding.UTF8)) { string resRead = reader.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/756bf4444257587541440a3e1c65fe91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4071ea786cf3a91cbb75fc48e49e65b5/" rel="bookmark">
			sftp的操作命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		bye 退出sftp
cd change your remote working directory
clear clear screen
exit 退出sftp
explore 浏览本地目录
get 下载
help give help
lcd 更改和/或打印本地工作目录
lls list contents of a local directory
lpwd print your local working directory
ls 查看当前目录下文件
mkdir 创建文件夹
mv 移动或重命名远程服务器上的文件
put 上传
pwd 查看当前目录
quit 退出sftp
rename 修改文件名
rm 删除文件
rmdir 删除文件夹
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/937ba0ae4c76992afe1b5d7d35ae3d78/" rel="bookmark">
			JS进阶第三篇：开发中对数组及对象的判断方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章传送门：
JS进阶第一篇：手写call apply bind
JS进阶第二篇：函数参数按值传递
文章目录 JS判断数组1.通过instanceof运算符判断2.通过constructor判断3.通过数组自带的isArray方法判断4.通过isPrototypeOf()方法判断5.通过Object.prototype.toString.call()判断 判断对象属性是否存在通过in运算符判断通过hasOwnProperty判断通过Reflect.has判断 判断对象是否为空通过JSON.Stringify()判断使用Object.keys()方法判断 有很多小伙伴在涉及到类型检查的时候只知道 typeof 一把梭哈，但是 typeof 并不是万能的。 typeof 只能检测基本数据类型，包括 boolean、undefined、string、number、symbol，而 null ,Array、Object ,使用 typeof 出来都是 Object，函数的 typeof 是 function 无法检测具体是哪种引用类型。 JS判断数组 1.通过instanceof运算符判断 从构造函数入手:可以判断一个对象是否是在其原型链上原型构造函数中的属性。
console.log(arr instanceof Array); //true typeof 和 instanceof 这两者都可以用来判断变量，typeof会返回基本类型，而instanceof只会返回一个布尔值。
2.通过constructor判断 这个属性是返回对象相对应的构造函数，Object的每个实例都有构造函数 constructor，用于保存着用于创建当前对象的函数。
console.log(arr.constructor === Array); //true 3.通过数组自带的isArray方法判断 ES5中新增了Array.isArray方法,IE8及以下不支持，用于确定传递的值是否是一个 Array，值得一提的是，这个方法是我在开发中最常用的：
console.log(Array.isArray(arr)); //true 对于ES5之前不支持此方法的问题，我们其实可以做好兼容进行自行封装，如下：
if (!Array.isArray) { Array.isArray = function(argument) { return Object.prototype.toString.call(argument) === '[Object Array]' } } 4.通过isPrototypeOf()方法判断 从原型入手，Array.prototype 属性表示 Array 构造函数的原型，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/937ba0ae4c76992afe1b5d7d35ae3d78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba704e57d2b257e0717bc5f4d8936cac/" rel="bookmark">
			银河麒麟桌面系统启用 rc.local 设置开机启动方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		银河麒麟系统不再使用initd管理系统，改用systemd。
然而systemd很难用，改变太大，跟之前的完全不同。
使用systemd设置开机启动，为了像以前一样，在/etc/rc.local中设置开机启动程序，需要以下几步：
一、实现原理 systemd 默认会读取 /etc/systemd/system 下的配置文件，该目录下的文件会链接 /lib/systemd/system/ 下的文件。一般系统安装完 /lib/systemd/system/ 下会有 rc-local.service文件，即我们需要的配置文件。
/lib/systemd/system/:
可以看到 target 的定义：
查看
target:ll | grep target target 用于指定什么时候启动我们自己自定的软件。
二、操作方法 1.将 /lib/systemd/system/rc-local.service 链接到 /etc/systemd/system/ 目录下面来：
ln -fs /lib/systemd/system/rc-local.service /etc /systemd/system/rc-local.service 查看文件内容：
cd /etc/systemd/system/ cat rc-local.service 说明：
[Unit] 区块：启动顺序与依赖关系。
ConditionFileIsExecutable ：指定了执行的文件，
After ：表示在 network.target 这个target后面进行执行。也就是网络启动完成之后，执行 /etc/rc.local 文件。
[Service] 区块：启动行为，如何启动，启动类型。
Type=forking
ExecStart=/etc/rc.local start
TimeoutSec=0
RemainAfterExit=yes
GuessMainPID=no
[Install] 区块：定义如何安装这个配置文件，即怎样做到开机启动。也是我们自己编辑新增的。
2.创建/etc/rc.local文件
touch /etc/rc.local 3.赋可执行权限
chmod 755 /etc/rc.local 4.编辑rc.local，添加需要开机启动的任务
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba704e57d2b257e0717bc5f4d8936cac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e917b9d4e4f25e06787d6e5b14c3ab3/" rel="bookmark">
			JVM-详解G1垃圾收集器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写这篇文章的原因是我看很多人提到G1的Full GC时都说是使用单线程回收，这个就很迷惑，虽然Full GC是在内存很紧张的时候才发生，但是既然都内存分块，为什么不能开多线程去并行回收，这样明显效率高很多，这点内存都不预留出来那设计G1回收的大佬是怎么考虑的？
G1垃圾回收在发生Full GC的时候由于全程单线程完全失去了内存分块意义，反而由于内存分块甚至比不分块还慢，这个问题已经在JDK10中改进了，感兴趣的可以看下官网的描述Parallel Full GC for G1，也就是说现在G1的Full GC其实是多线程处理的。可以灵活的设定Full GC时的工作线程数
由于上面问题的困扰，导致本人看了不少G1原理的文章，总感觉都讲的很复杂，很多很多概念性的东西，所以准备自己画一些图，对G1一些关键的机制做一个简单的说明。错误之处希望大家能够勘正，感谢🙏。
1.内存结构-为什么要将Java堆划分为多个Region？
基于分代收集理论实现的垃圾收集器，将Java堆分为两个区域，新生代和老年代。G1同样如此，G1将Java堆划分为多个Region区，每个Region有三个状态：未分配，新生代，老年代。
因为新生代收集是基于复制算法实现的所以又分为Eden区，Survivor区 老年代包括新生代中熬过多次回收后被复制到Old区的对象以及超过单个Region设定容量Humongous区
G1的创新之处在于每个区域可以灵活的根据当前状态去执行不同策略，同时做了很好的内存隔离，举个极端的例子，在不考虑跨区引用，且一块没有内存隔离的区域只能用一个线程去进行垃圾回收的情况下：
对于G1之前的垃圾回收器假如使用1G的内存作新生代，那么其实在进行清理回收的时候只能是开1个线程去处理的，顶多可以开其他线程去处理别的请求，但是不能参与垃圾回收，这本质就是并发。 而G1则是1G的内存作为新生代，同时又把这1G内存分为10个Region的话，那就可以开10个线程去并行处理，这样的回收速度远超单线程回收，当然了代价就是需要额外的内存去记录这些Region的信息。
上图是CMS(老年代)和G1（新生代+老年代）垃圾回收的主要过程，可以看出G1是并发标记+并行回收，而CMS则是并发标记+并发回收。并行回收看着简单其实实现难度还是很高的，要考虑很多因素,比如如何做到各个区域间的内存隔离，信息管理等，从提出理论到初步实现就花费了将近10年。
因为G1实现了模块化的内存管理模式，所以可以根据每个模块的状态以及内存利用率这些信息，提前计算出进行一次垃圾回收需要的时间等，从而去选择回收价值最高的先去回收。而CMS这种提前就把内存区域划分为两大块的做法就显得很笨重，同时也没有办法去控制回收的对象比例（主要还是在没有内存隔离的情况下实现这个需求太难了）。
问题结论：只有将Java堆划分为多个独立Region模块才能做到多线程并行回收
2.回收目标-什么是卡表CardTable，记忆集Remembered Set和写屏障Write Barrier？如何利用这些来定位需要回收的对象？
先提一下卡表的作用：卡表中存放着能够快速找到存在跨代引用的对象的索引，在进行非全局的GC时，可以凭借这种索引结构快速定位需要保留的对象。
G1是根据可达性算法来确定需要回收的目标，通过从GC Root Set包含的对象向下寻找引用链，来标记不能被回收的对象，在一个回收中，如果一个Region参与垃圾收集，那么在回收阶段，没有标记的对象将被全部清除。GC Roots由固定对象和临时对象构成。
固定对象： 虚拟机栈中引用的对象：线程中正在使用的对象方法区中类静态属性引用的对象：类中static声明的引用类型字段方法区中常量引用的对象：类中final声明的引用类型字段本地方法栈中引用的对象：native本地方法引用的对象 临时对象：记忆集Remembered Set中保存的对象，可以理解为一个集合结构，里面放了一些同新生代有引用关系的老年代对象的地址，跟集合中对象有引用关系的对象就不会被回收，而卡表Card Table就是这个集合实现的一种方式 重点看下临时对象是怎么确定的，首先我们可以知道一个对象在哪个区域，这个区域是什么状态（新生代/老年代），当新生代中的对象引用了老年代对象时，就会把老年代的这个对象放入Remembered Set中，当作一个临时对象。
写屏障Write Barrier在其中的作用则类似Spring的AOP，当对象的赋值发生时，判断是不是老年代，如果是则通过统一的切面处理将引用对象的地址加入Remembered Set。（实际过程跟这个有出入，但我觉得如果不深究源码的话，这么理解是没有问题的）
下面画图来解释下CardTable的实现，可以理解为内存中建立的稀疏索引
G1的每个Region都是连续内存，Card Table第一行表示 Card Table的key为与当前Eden Reign存在引用关系的Old Region的内存起始位置，value是一个集合存储这临时对象所在的内存数组索引,，这就构成了一个稀疏索引。
比如1MB的内存，如果我们把其分为10个内存块，那么想确定这个Region中的一个临时对象最多只需要扫描100Kb即可，当对象的引用关系发生变化时，通过写屏障将key和value加入Card Table即可，代价也很明显就是为一个Region建立Card Table需要额外的空间，这个空间大小取决于索引段的大小，所以相同的Java堆内存，G1的内存使用率要低于CMS。
这种通过空间换时间的索引结构运用也很广泛，在Kafka，MySQL，Redis等中间件和数据库中都能见到。
3.回收过程-三种GC有哪些共同点和不同点？
先简单说明细不同的GC的目标类型，G1涉及 Young GC/Mixed GC/Full GC三种垃圾收集
部分收集（Partial GC）：目标不是完整收集整个Java堆的垃圾收集
Minor GC/Young GC：新生代的垃圾收集Major GC/Old GC：老年代的垃圾收集Mixed GC：整个新生代及部分老年代的垃圾收集 整堆收集（Full GC）：整个Java堆和方法区的垃圾收集。
Young GC
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e917b9d4e4f25e06787d6e5b14c3ab3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4383a0d5ae11bda1a07931bc6153c7d7/" rel="bookmark">
			数据结构-红黑树插入结点示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据结构-红黑树插入结点示例 1、红黑树简介2、在线可视化生成红黑树工具3、红黑树插入结点性质和规则3.1、红黑树插入结点性质3.2、红黑树插入结点规则 4、红黑树插入结点示例4.1、红黑树插入结点示例(带有过程描述)4.1.1、带有过程描述-补充-两种不旋转的方法 4.2、红黑树插入结点示例(不带过程截图) 1、红黑树简介 红黑树（Red Black Tree）是一种特定类型的二叉树，它是在计算机科学中用来组织数据比如数字的块的一种结构。
红黑树是在1972年由Rudolf Bayer发明的，当时被称为平衡二叉B树(symmetric binary B-trees)。后来，在1978年被Leo J.Guibas和Robert Sedgewick修改为如今的“红黑树”。
红黑树是一种平衡二叉查找树的变体，它的左右子树高差有可能大于 1&lt;所以红黑树不是严格意义上的平衡二叉树(AVL)，但对之进行平衡的代价较低，其平均统计性能要强于 AVL 。
------粘百度百科
2、在线可视化生成红黑树工具 网址是：https://www.cs.usfca.edu/~galles/visualization/RedBlack.html
3、红黑树插入结点性质和规则 3.1、红黑树插入结点性质 一颗红黑树是满足如下红黑性质的二叉排序树：
1、每个结点或是红色，或是黑色的；
2、根结点是黑色的；
3、叶结点（虚构的外部结点、NULL结点）都是黑色的 ；
4、不存在两个相邻的红结点（即红结点的父结点和孩子结点均是黑色的）；
5、对每个结点，从该结点到任一叶结点的简单路径上，所含黑结点的数量相同。
3.2、红黑树插入结点规则 红黑树插入结点的规则总结如下图3-1所示（验证总结的，若有哪里不对，请指出）：
图3-1 4、红黑树插入结点示例 4.1、红黑树插入结点示例(带有过程描述) 下面展示具体例子，关键字序列为：89，79，82，50，13，3，17，18，14，15，25，20，36，95，90，265，262，289，526，352，365，360，377，522，674。【不看过程的话，直接跳转到：4.2、红黑树删除示例(不带过程截图)即可】。
1、新插入红黑树的结点初始着为红色，插入关键字序列（89，79，82，50，13，3，17，18，14，15，25，20，36，95，90，265，262，289，526，352，365，360，377，522，674）中第1个，构建过程截图和在线可视化工具结果截图如图4-1和图4-2所示。
图中步骤①，新插入结点"89"初始时为红色，根据红黑树插入结点性质2【红黑树根结点是黑色】，所以"89"更新为黑色。
图4-1 过程截图 图4-2 在线可视化工具结果截图 2、插入关键字序列（89，79，82，50，13，3，17，18，14，15，25，20，36，95，90，265，262，289，526，352，365，360，377，522，674）中第2个，构建过程截图和在线可视化工具结果截图如图4-3和图4-4所示。
图中步骤①，新插入结点"79"初始时为红色，根据红黑树插入结点规则③【当前待插入结点"79"的父结点"89"是黑色，直接插入当前结点"79"】
图4-3 过程截图 图4-4 在线可视化工具结果截图 3、插入关键字序列（89，79，82，50，13，3，17，18，14，15，25，20，36，95，90，265，262，289，526，352，365，360，377，522，674）中第3个，构建过程截图和在线可视化工具结果截图如图4-5和图4-6所示。
方法一：
图中步骤①，新插入结点"82"初始时为红色，根据红黑树插入结点性质4【不存在两个相邻的红结点】；再根据红黑树插入结点性质3【虚构的外部结点都是黑色的】，即"82"结点的叔叔结点为黑色；故根据红黑树插入结点规则②【旋转】，由于79&gt;82，所以先左旋。
图中步骤②，82&lt;89，所以右旋，根据红黑树插入结点规则②【变色（后旋转的结点各取反色）】，82和89是后旋转的，所以结点82和结点89颜色取反。
方法二和方法三直接跳转到："4.1.1、带有过程描述-补充-两种不旋转的方法"即可】。
图4-5 过程截图 图4-6 在线可视化工具结果截图 4、插入关键字序列（89，79，82，50，13，3，17，18，14，15，25，20，36，95，90，265，262，289，526，352，365，360，377，522，674）中第4个，构建过程截图和在线可视化工具结果截图如图4-7和图4-8所示。
图中步骤①，新插入结点"50"初始时为红色，根据红黑树插入结点性质4【不存在两个相邻的红结点】；再根据红黑树插入结点规则①【叔叔结点+父亲结点+爷爷结点各取反色】，所以结点89、79、82均取反颜色。
图中步骤②，根据红黑树插入结点规则①【爷爷结点检查更新】，再根据红黑树插入结点性质2【红黑树根结点是黑色】，所以"82"更新为黑色。
图4-7 过程截图 图4-8 在线可视化工具结果截图 5、插入关键字序列（89，79，82，50，13，3，17，18，14，15，25，20，36，95，90，265，262，289，526，352，365，360，377，522，674）中第5个，构建过程截图和在线可视化工具结果截图如图4-9和图4-10所示。
方法一：
图中步骤①，新插入结点"13"初始时为红色，根据红黑树插入结点性质4【不存在两个相邻的红结点】；再根据红黑树插入结点性质3【虚构的外部结点都是黑色的】，即"13"结点的叔叔结点为黑色；故根据红黑树插入结点规则②【旋转】，由于50&lt;79，故右旋。
图中步骤②，根据红黑树插入结点规则②【变色（后旋转的结点各取反色）】，50和79是旋转的，所以结点50和结点79颜色取反。
方法二和方法三直接跳转到："4.1.1、带有过程描述-补充-两种不旋转的方法"即可】。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4383a0d5ae11bda1a07931bc6153c7d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8683934cfc6fe3b27fb338aea19d5a72/" rel="bookmark">
			第五章. 可视化数据分析图表—图表的常用设置1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第五章. 可视化数据分析图
5.2 图表的常用设置1 本节主要介绍图表的常用设置，主要包括颜色设置，线条样式，标记样式，设置画布，坐标轴，添加文本标签。
1.设置画布（matplotlib.pyplot.figure） 在matplotlib中，可以使用figure函数来设置画布大小，分辨率，颜色和边框等
1).语法： matplotlib.pyplot.figure(num=None,figsize=None,dpi=None,facecolor=None,edgecolor=None,frameon=True) 参数说明:
num：图像编号(数字)或名称(字符串)，可以通过这个参数来激活不同的画布
figsize：画布的宽和高，单位：英寸
dpi：指定绘图对象的分辨率，每英寸包含多少个像素，像素越大，画布越大，默认值为80
facecolor：背景颜色
edgecolor：边框颜色
frameon：是否显示边框，True：绘制边框（默认值）
注:
figsize(5,3),实际的画布大小是500*300，所以参数不宜给很大
2.基本的绘图函数（matplotlib.pyplot.plot） 在matplotlib中，基本绘图主要使用plot函数
1).语法： matplotlib.pyplot.plot(x,y,format_string,**kwargs) 参数说明:
x：x轴数据
y：y轴数据
format_string：控制曲线格式的字符串，包括颜色，线条样式，标记样式等
**kwargs：键值参数，相当于一个字典，比如，输入参数为：（1,2,3,4,k,a=1,b=2,c=3）,*args=(1,2,3,4,k),**kwargs={‘a’:1,‘b’:2,‘c’:3}
2).颜色设置:(color) 设置值说明设置值说明b蓝色m洋红色g绿色y黄色r红色K黑色c蓝绿色W白色#FFFF00黄色，十六进制颜色值0.5灰色 注:其他颜色可通过十六进制字符串进行指定
3).线条样式：(linestyle) 设置值说明-实线（默认）–双划线-.点划线：虚线 4).标记样式：(marker) 设置值说明设置值说明设置值说明.点标记1下花三角标记h竖六边形标记,像素标记2上花三角标记Ho实心圆标记3左花三角标记+v倒三角标记4右花三角标记x^上三角标记s实心正方形标记D大菱形标记&gt;右三角标记p实心五角星标记d小菱形标记&lt;左三角标记*星形标记|垂直线标记 注:mfc参数可为标记样式内部填充颜色
3.设置坐标轴（x轴：xlabel,y轴：ylabel） 1).语法： x轴语法：
matplotlib.pyplot.xlabel(xlabel, fontdict=None，labelpad=None，**kwargs) 参数说明:
xlabel：标签文本。并且包含字符串值
y轴语法：
matplotlib.pyplot.ylabel(ylabel, fontdict=None，labelpad=None，**kwargs) 参数说明:
ylabel：标签文本。并且包含字符串值
2).技巧： 中文乱码问题的解决方法：matplotlib.pyplot.rcParams['font.sans-serif'] = ['SimHei'] 符号不显示问题的解决方法：plt.rcParams['axes.unicode_minus'] = False 4.坐标轴刻度（x轴：xticks,y轴：yticks） 1).语法： x轴语法：
matplotlib.pyplot.xticks(locs,[labels]，**kwargs) 参数说明:
locs：数组，x轴的刻度
labels：数组，默认与locs相同，locs表示位置，labels决定了位置上的标签
y轴语法：
matplotlib.pyplot.yticks(locs,[labels]，**kwargs) 参数说明:
locs：数组，y轴的刻度
labels：数组，默认与locs相同，locs表示位置，labels决定了位置上的标签
2).技巧： 通过xlim函数和ylim函数可设置坐标轴范围：matplotlib.pyplot.xlim(1,10) matplotlib.pyplot.ylim(1,10) 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8683934cfc6fe3b27fb338aea19d5a72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da292a94d23cf1797b4a84a385569cb6/" rel="bookmark">
			Arduino环境下在ESP32上使用SmartConfig
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目总结 本教程将介绍如何将 ESP-Touch 协议用于基于 ESP32 的物联网项目/设备。
使用 ESP-Touch，您将不再需要对 Wi-Fi 凭据进行硬编码，因为您可以随时轻松更改它。
我们将使用 Espressif 应用程序名称作为 EspTouch: SmartConfig for ESP8266, ESP32。
通过使用这个应用程序，我们可以轻松地使用新的 Wi-Fi 凭据配置我们的 ESP32 设备。
关于 ESP-Touch 协议和SmartConfig技术
ESP-Touch 协议使用 SmartConfig 技术。 SmartConfigTM 是 TI 开发的一项技术，用于将基于 Wi-Fi 的新型物联网设备连接到 Wi-Fi 网络。 它使用移动应用程序将网络凭据从智能手机或平板电脑广播到未配置的 Wi-Fi 设备。
使用 ESP-Touch 的主要优点是无需在 ESP32 中创建具有已知 SSID 或密码的接入点 (AP)。
因此，ESP-Touch 协议提供了一种无缝方式来配置连接到路由器的 Wi-Fi 设备。对于无头系统，它非常用户友好。只需在您的智能手机上点击几下。
IoT 设备最初没有连接到网络，ESPTOUCH 应用程序无法直接向设备发送任何信息。借助 ESP-TOUCH 通信协议，智能手机等具备 Wi-Fi 接入能力的设备可以向 Wi-Fi 接入点（AP）发送一系列 UDP 数据包，将 SSID 和密码编码到每个 UDP 数据包。然后，物联网设备可以访问 UDP 数据包，获取并解析出所需的信息。根据 ESP-Touch 用户指南，数据包结构如下所示。 与 Wi-Fi 管理器相比，协议本身是轻量级的，因为 Wi-Fi 管理器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da292a94d23cf1797b4a84a385569cb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96c6e94464c2ade582743178fbf0e33f/" rel="bookmark">
			【序列标注】kaggle实战系列-序列标注
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据：来自于98年人民日报NER语料
环境：TensorFlow 1.13.1
模型：BiLSTM-CRF
目录 一、任务描述二、数据说明三、模型架构概述模型结构模型实现细节 四、代码 一、任务描述 用seq_tag/data_path 中的数据训练模型，来完成序列标注任务（命名实体识别），识别出文本中的人名、地名和组织机构名。
二、数据说明 注：该数据集为小规模中文数据集，来自于98年人民日报NER语料
1.标签说明
{ B-PER：人名开始； I-PER：人名中间 ；B-LOC：地名开始， I-LOC：地名中间； B-ORG：机构名开始 ；I-ORG：机构名中间；O：其他 }
2.数据集格式说明
训练语料：
train_corpus.txt 文件为训练文本：
train_label.txt 文件为训练文本对应的每个字的标签：
如“周恩来”这个人名实体对应的标签B-PER, I-PER, I-PER。
测试语料：
test_corpus.txt 文件为测试文本，test_label.txt 文件为对应的标签，格式同上。
3.评价指标
采用准确率、召回率以及F1值来进行模型评价。
三、模型架构概述 输入层通过embedding获得词向量，表示层选择BiLSTM对词向量进行加工和表示，输出层未直接使用softmax来直接获得词对应的标签，而是通过CRF使得标注精度更高。
模型结构 模型实现细节 Word Embedding功能及完整思路：
1). 将训练数据集train_corpus.txt、train_label.txt进行遍历得到词典{字：[id, 出现次数]}，id为字对应的标签： {“O”:0;“B-PER”：1; “I-PER”：2 ; “B-LOC”：3; “I-LOC”：4; “B-ORG”：5; “I-ORG”：6} ，将7种标签转化为对应数字类型，便于模型处理；
2)设定出现次数阈值，去除词典中的低频词，重新生成词典{字：id}，这里丢弃低频词之后，出现次数便不再需要记录了；
3)对于训练数据中的每条语句，利用上一步生成的词典，将句子转化为id序列，再将所有的句子按照最长的一句话进行padding，得到句子的向量表示。
BiLSTM-CRF层功能及完整思路：
1). 功能：使用双向长短期记忆网络LSTM加条件随机场CRF的方式解决文本标注的问题，LSTM是RNN的加强版，主要解决RNN对距离较远文本之间关联较差的问题，其单向性也成为了相比于BiLSTM的不足之处。
2). BiLSTM模型更好地利用了文本上下文中的信息，相较于之前的模型LSTM，从上下文中获取了更多信息，从而减小了对词向量的依赖。但它也存在十分明显的缺点，其最终输出依赖于softmax输出概率最大的标签，使得相邻输出标签之间可能存在没有实际意义的连续标签。这个问题可以通用CRF来解决。
3). CRF计算整个标记序列的联合概率分布，优势是考虑了标签间的关系。
4). LSTM-CRF结合了上述两种模型。CRF将状态转移矩阵作为参数，并使用之前和之后的标签预测当前标签。
四、代码 环境配置：
!pip install tensorflow==1.13.1 如果环境有问题，kaggle终端使用conda init --user来初始化环境，再重新配置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96c6e94464c2ade582743178fbf0e33f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6964c3ddcb4ad7a4c85ee7b5dee0b55/" rel="bookmark">
			Error response from daemon: conflict: unable to delete feb5d9fea6a5 (must be forced) - image is bein
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		失败原因：镜像被id为b5d9fea6a5容器使用
解决办法：先删除容器
docker rm 容器id 如果继续报错：
root@weihua-VirtualBox:~# docker rm 24e4a6defd66 Error response from daemon: You cannot remove a running container 24e4a6defd669091ff8bc495c8ac4bb89d71e6ee3db005c272492074c4e0e479. Stop the container before attempting removal or force remove 显示容器真在运行，先停止运行容器
root@weihua-VirtualBox:~# docker stop 24e4a6defd66 24e4a6defd66 root@weihua-VirtualBox:~# docker rm 24e4a6defd66 24e4a6defd66 然后删除镜像
docker rmi 镜像id 成功
root@weihua-VirtualBox:~# docker images
REPOSITORY TAG IMAGE ID CREATED SIZE
test/ubuntu v1 ad4e5a33c5c3 33 minutes ago 77.8MB
ubuntu latest 2dc39ba059dc 2 weeks ago 77.8MB
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6964c3ddcb4ad7a4c85ee7b5dee0b55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ce05b73d0136af7539dd13dfeed9202/" rel="bookmark">
			css之@media网页适配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原因：
原本是想用 iview Grid 栅格,但以下响应并不符合我的需求
【我需要的分辨率是1920和1536】，所以需要手动修改
解决方案：
html &lt;Row&gt; &lt;i-col :xs="6" :sm="6" :md="6" :lg="8"&gt; &lt;div class="description-term"&gt;服务器IP：&lt;/div&gt; &lt;div class="description-detail"&gt;{{ selectObj.server }}&lt;/div&gt; &lt;/i-col&gt; &lt;/Row&gt; css【从小到大渲染】 // CSS样式与DOM/JS一样，从前往后加载，后面的代码覆盖前面的代码。当 min-width 和 max-width 混用时，一定要注意前后顺序。 @media (min-width: 1536px) { :deep(.ivu-col-span-md-6) { display: block; flex: 0 0 25%; max-width: 25%; } } @media (min-width: 1920px) { :deep(.ivu-col-span-lg-8) { display: block; -webkit-box-flex: 0; -ms-flex: 0 0 33.33333333%; flex: 0 0 33.33333333%; max-width: 33.33333333%; } } 注意事项：
1.CSS @media min-width max-width 不生效
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ce05b73d0136af7539dd13dfeed9202/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0395f7279a1e4096e9177a65ac794ff8/" rel="bookmark">
			树莓派安装conda 虚拟环境中pip instasll出现Illegal Instruction
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		树莓派4b安装tensorflow2踩坑记录
系统镜像版本：2022-09-22-raspios-bullseye-arm64.img.xz
创建的虚拟环境如下：
conda create -n tf2 python=3.7.10 进入虚拟环境后，输入pip，出现非法指令(Illegal Instruction), 无法正常工作
可尝试conda install pip=21.0.1
有概率解决问题(我7次只成功一次)使用sudo pip而不是pip
可以看到sudo pip list有输出 pip install tensorflow,安装完输入python 2.1_tensorflow.py出现报错
Traceback (most recent call last): File "2.1_tensorflow.py", line 1, in &lt;module&gt; import tensorflow as tf ModuleNotFoundError: No module named 'tensorflow' 但是输入sudo python 2.1_tensorflow.py无报错, 每次都用sudo显然也不正常
这又遇到玄学问题了
此时我的命令行界面如下：
(tf2) pi@raspberrypi:~ $ 可以看到已在tf2虚拟环境内
但是要再输入一边conda activate tf2, 此时python 2.1_tensorflow.py无报错，不用加sudo权限
pip list也恢复正常，不用加sudo权限
问题完美解决
哪位大佬能解释一下问题所在，百思不得其解
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d9aae39d4493063b63c572cb0c28ebb/" rel="bookmark">
			labview调用DLL程序崩溃问题的解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初学labview，最近学到调用DLL实现某些功能。
在编写完程序之后，多次出现在VI运行、以及关闭时程序崩溃，并且报错误码：0xC0000005。
调用DLL关闭程序时出现0xC0000005错误代码说明发生了内存访问冲突
搜寻资料出现这种情况解决的方案如下：
1.确保选择了和DLL相同的调用规范。是C还是stdcall，好像一般跨平台调用的DLL都是要选用stdcall，需要被调用函数来清除堆栈。
2.确保已经连接了调用库函数节点（Call Library Function Node）的所有输入和输出。
3.确保DLL函数不会覆写LabVIEW内存。如果足够的内存空间分配或DLL函数写入的内容超过分配的内存，DLL将覆写入剩余的LabVIEW内存空间并导致LabVIEW崩溃。所以需要在传值和读出DLL中的数组，字符串或波形之前确保正确分配内存。
4.确保LabVIEW使用了正确的数据类型像函数传递参数。我自己就犯了这个错误，labview的数据类型要和调用的DLL函数参数对应上，不然会在程序运行时就崩溃。对应的关系照搬书本好像还不是完全对，需结合实际，比如DLL函数输出参数类型为unsigned char ，事实上我需要的是这个字符对应的ASCLL值，所以labview可以在输出端接一个无符号8位数值类型显示控件。
5.函数调用本身就是非法的。如果某个函数试图执行非法操作，可能会导致LabVIEW崩溃。
6.如果LabVIEW在关闭之前不会崩溃（本人也遇到了这个问题）。最可能的问题是被调用的DLL函数已损坏内存。如果将数组或字符串传递给DLL，则DLL函数无法动态调整数组大小。在数组或字符串的最后一个元素之外写入可能会损坏内存，这在LabVIEW关闭之前可能并不明显。我将传入的一个空字符串常量替换成了一个数值，同时对DLL函数的输入输出参数也做了修改，程序在关闭时不会崩溃了（原因还没找到）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c5fcdfe0a161587da9a55f5d0d482e2/" rel="bookmark">
			内外网、出入口IP区分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、ip地址分类 IP地址是一个32位的二进制数，通常被分割为4个“8位二进制数”（也就是4个字节）。
IP地址通常用“点分十进制”表示成（a.b.c.d）的形式，其中，a,b,c,d都是0~255之间的十进制整数。例：点分十进IP地址（100.4.5.6），实际上是32位二进制数（01100100.00000100.00000101.00000110）。
为了方便管理，在很早的时候IP地址，一共分成了5类，范围分别如下：
A类IP：从0.0.0.0 – 127.255.255.255，共有16777216个IP B类IP：从128.0.0.0 – 191.255.255.255，共有65536个IP C类IP：从192.0.0.0 – 223.255.255.255，共有256个IP D类IP：从224.0.0.0 – 239.255.255.255 E类IP：从2240.0.0.0 – 255.255.255.255 二、内网ip 内网IP（或者叫私网ip）其实是ABC三类地址中保留出的地址段，专门用作内网通讯。
A类地址：10.0.0.0～10.255.255.255 B类地址：172.16.0.0 ～172.31.255.255 C类地址：192.168.0.0～192.168.255.255 判断一个地址是否为内网，只要看下其是否在上面的ABC三类私网地址所在的范围即可。
内网地址互通使用的解决方案
1.将内网ip映射为外网ip，访问服务时使用公网ip来替代内网ip。
2.建设基础设施，在办公网与机房建立一条物理线路，使两者形成一个大内网环境。
3.与第2种方案类似，在办公网与机房建立一条虚拟线路，办公网设备拨号到IDC机房内网的vpn设备后，由vpn设备发起对IDC机房内网设备的访问。
对于第一种方案，通常使用F5建立vs、nginx做转发的方式来实现；
对于第二种方案，一般成本较高，并且存在权限滥用的风险；
对于第三种方案，vpn设备常常成为机房隐患的重点保护区，vpn设备流量大时会影响机房线上业务；
三、外网ip 等同于公网ip。除了私网ip之外，其余统称为公网ip，这些ip可以在互联网设备上正常传输。
出口ip与入口ip 通常来说，访问他人提供的服务需要我们提供给对方我们的出口ip；他人访问我们的服务需要对方提供给我们对方的出口ip。
出口ip与入口ip不一定是同一个地址。
1）出口ip
目的地址为私网ip的数据包无法在互联网上传输。当目的地址为公网ip，源地址（发起请求的设备地址）为内网时，数据包能够顺利到达服务器，但服务器无法将响应数据报回复回来（服务器回复的数据报的目的地址是内网地址）。故为了使内网的笔记本/服务器能够正常访问到互联网的资源，网络设备会将私网设备发出的请求转换为外网ip。
查看自己的出口ip：
curl ifconfig.me curl ipinfo.io/ip curl ip.sb curl icanhazip.com curl http://icanhazip.com curl http://ip.3322.net curl https://httpbin.org/ip curl -s http://httpbin.org/ip 最终具体请以网络部的通知为准。
当需要与第三方合作时，如果需要访问对方的服务，则一般需要告知对方我们的出口ip，方便对方进行访问授权。
2）入口ip
入口ip指的是你作为被访问端（server端），接收来自其他人（client端）的访问。即client端使用哪个地址来访问你的服务。
可以通过ping域名等方式得到。
当需要与第三方合作时，如果需要对方访问到自己的服务，则需要告知对方一个可访问的地址。并且授权对方的网络设备ip（对方的出口ip）允许访问我们的服务。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1694128bae90401ea85a453a2c477f77/" rel="bookmark">
			spark读取oracle ebs排坑No matching authentication protocol
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.先在DBeaver输入登陆信息上正常登陆，测试账号等信息正常。
2.在IDEA上配置
刚开始pom文件配置的是，调试了很多遍，都是报错No matching authentication protocol
老的依赖文件（oracle版本较新的连不上）：
&lt;dependency&gt; &lt;groupId&gt;com.oracle&lt;/groupId&gt; &lt;artifactId&gt;ojdbc14&lt;/artifactId&gt; &lt;version&gt;10.2.0.4.0&lt;/version&gt; &lt;/dependency&gt; 老依赖文件写的启动
// val oracleDriver = "oracle.jdbc.driver.OracleDriver"
特别建议：Oracle9.0以后的版本都建议使用：“oracle.jdbc.OracleDriver”加载驱动类，而不再使用“oracle.jdbc.driver.OracleDriver”.
val oracleDriver = "oracle.jdbc.OracleDriver"
3.解决方法：更新驱动版本，我是直接拿DBeaver的驱动包，找到对应的存储文件
IDEA中将驱动jar包导入进来
pom文件更新成导入jar包的版本
&lt;dependency&gt; &lt;groupId&gt;com.oracle&lt;/groupId&gt; &lt;artifactId&gt;ojdbc8&lt;/artifactId&gt; &lt;version&gt;12.2.0.1&lt;/version&gt; &lt;/dependency&gt; spark读取oracle数据成功
val oracleUrl = "jdbc:oracle:thin:@//xx.x.x.xxx:1529/xxxx" val oracleDriver = "oracle.jdbc.OracleDriver" // val oracleDriver = "oracle.jdbc.driver.OracleDriver" val oracleUserName = "xxxx" val oraclePassword = "xxxx" val jdbcDF = spark.read .format("jdbc") .option("driver", oracleDriver) .option("url", oracleUrl) .option("dbtable", "xx.xxxx") .option("user", oracleUserName) .option("password", oraclePassword) .load() jdbcDF.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1694128bae90401ea85a453a2c477f77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f8141d323b8828eb54d90dffac18ae8/" rel="bookmark">
			为什么启动了vue以后另外一台电脑访问不了对应的页面？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当你在本地启动了 Vue 项目以后，它只会在本地电脑上运行，其他计算机无法访问。如果想要让其他计算机能够访问，你需要在本地电脑上运行一个服务器，并将 Vue 项目部署到该服务器上。这样，其他计算机就能通过服务器的网址来访问你的 Vue 项目了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf0d834fe8ca5c529215a806da330aa0/" rel="bookmark">
			springboot开启mybatis驼峰命名自动映射的三种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总结springboot开启mybatis驼峰命名自动映射的三种方式
方式一：通过springboot的配置文件application.yml
mybatis:
configuration:
map-underscore-to-camel-case: true
此方式是最简单的，但是要注意，通过springboot的配置文件配置mybatis的设置，则不能够再使用mybatis的配置文件，例如：下边代码中标红的两个设置不能同时存在，要么使用config-location指定mybatis的配置文件，在通过mybatis的配置文件配置相关设置，要么通过springboot配置文件的mybatis.configuration进行相关设置，二者只能选其一，否则会报错。
mybatis:
config-location: classpath:mybatis/mybatis-config.xml
mapper-locations: classpath:mybatis/mapper/*.xml
configuration:
map-underscore-to-camel-case: true
方式二：通过mybatis的配置文件
首先需要在springboot的配置文件application.yml中指定mybatis配置文件的位置。
mybatis:
config-location: classpath:mybatis/mybatis-config.xml
mapper-locations: classpath:mybatis/mapper/*.xml
然后在mybatis配置文件中进行设置
&lt;?xml version="1.0" encoding="UTF-8" ?&gt; 方式三：通过@Comfiguration注解和@Bean注解，向容器中添加ConfigurationCustomizer类型的组件，在ConfigurationCustomizer中进行设置 @Configuration
public class MybatisConfig {
@Bean
public ConfigurationCustomizer configurationCustomizer(){
return new ConfigurationCustomizer() {
@Override
public void customize(org.apache.ibatis.session.Configuration configuration) {
configuration.setMapUnderscoreToCamelCase(true);
}
};
}
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4f8a935913304c69984aa87686b1dc2/" rel="bookmark">
			查看cuda cudnn 版本 &amp; 一些常见疑问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、快速确定版 查看cuda nvcc -V 查看cudnn dpkg -l | grep cudnn 二、历史方法 有一些已经失效，这里仅仅作为备选 查看cuda 方法一 nvcc -V 或者 nvcc —version 方法二 cat /usr/local/cuda/version.txt 或者 cat /usr/local/cuda/version.json 查看cudnn 方法一 dpkg -l | grep cudnn 方法二 whereis cudnn_version 或者 whereis cudnn.h 获得真实路径。这里以/usr/local/cuda/include/为例 cat /usr/local/cuda/include/cudnn.h |grep CUDNN_MAJOR -A 2 cat /usr/local/cuda/include/cudnn_version.h |grep CUDNN_MAJOR -A 2 三、不建议使用的方法 方法一、pytorch 接口 import torch # 查看torch的版本 print(torch.__version__) # 查看cuda的版本 print(torch.version.cuda) # 查看cudnn的版本 print(torch.backends.cudnn.version()) 方法二、nvidia-smi 命令 原因简单介绍 对于算法工程师我们知道一般层级为GPU硬件-GPU驱动（driver）—cuda-(cudnn)-pytorch. 其中cuda 一般也分两种:driver api(nvidia-smi显示的)和runtime api (nvcc -v等显示的)。用于支持driver api的必要文件由 GPU driver installer 安装，nvidia-smi就属于这一类API；而用于支持runtime api的必要文件是由 CUDA Toolkit installer 安装。nvcc是与CUDA Toolkit一起安装的CUDA compiler-driver tool，它只知道它自身构建时的CUDA runtime版本，并不知道安装了什么版本的GPU driver，甚至不知道是否安装了GPU driver。如果driver API和runtime API的CUDA版本不一致可能是因为你使用的是单独的GPU driver installer，而不是CUDA Toolkit installer里的GPU driver installer。一般现在大家使用docker 开发技术，宿主机安装driver， docker 内部安装cuda cudnn，这时一般nvidia-smi 和 nvcc -v 的结果便是不一样的，通常driver api 的版本能向下兼容 runtime api 的版本。 Nvidia 驱动和cuda对应表： CUDA 12.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4f8a935913304c69984aa87686b1dc2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ce6c2d5ef56fe5d0ac23e4b0d1b673f/" rel="bookmark">
			ubuntu安装postgresql并修改数据存储目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装postgresql: @ubuntu:~$ sudo apt install postgresql 安装成功显示：
Success. You can now start the database server using: /usr/lib/postgresql/10/bin/pg_ctl -D /var/lib/postgresql/10/main -l logfile start 新磁盘挂载在/home目录，因此需要将postgresql的数据存储目录修改: 新建迁移目标文件夹
@ubuntu:~$ mkdir /home/postgresql @ubuntu:~$ mkdir /home/postgresql/data 添加用户： @ubuntu:~$ useradd postgres 修改权限： @ubuntu:~$ chown -R postgres:postgres /home/postgresql @ubuntu:~$ chmod 750 -R /home/postgresql 修改配置文件：
@ubuntu:~$ su postgresql postgres@ubuntu:~$ vim ~/.profile postgres@ubuntu:~$ psql postgres=# SHOW data_directory; postgres=# ^Z postgres@ubuntu:~$ vi /etc/postgresql/10/main/postgresql.conf *data_directory = '/var/lib/postgresql/14/main'* #是数据库存放目录，可以修改 postgres@ubuntu:~$ source /etc/profile 初始化数据库 找到initab位置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ce6c2d5ef56fe5d0ac23e4b0d1b673f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a610329ed49b10693e8ff3462ba6a27d/" rel="bookmark">
			matplotlib绘图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用matplotlib可视化数据。图表的基本组成元素包括画布、坐标系、坐标轴、坐标轴标题、图表标题、数据标签、网格线、图例等。
1.建立画布和坐标系 首先导入matplotlib库，新建一个画布
import matplotlib.pyplot as plt #导入matplotlib库 # 1.建立画布 fig = plt.figure(figsize = (6,4))#将画布的宽度设置为6，高度设置为4 然后建立坐标系，可以使用add_subplot函数、plt.subplot函数或plt.subplots函数建立坐标系。
先是add_subplot函数
import matplotlib.pyplot as plt #导入matplotlib库 # 1.建立画布 fig = plt.figure(figsize = (6,4))#将画布的宽度设置为6，高度设置为4 # 2.add_subplot建立坐标系 ax1 = fig.add_subplot(1,1,1)#创建1个坐标系 plt.show() 如果想同时绘制几个子图，可以
# 2.add_subplot建立坐标系 ax2 = fig.add_subplot(1,2,1) ax3 = fig.add_subplot(1,2,2) plt.show() 会产生1*2个坐标系，1行2列的。
然后plt.subplot函数，将画布分成2*2个区域，然后在第1和2个区域里绘图
x = list(range(6)) y = [i**2 for i in x] fig1 = plt.subplot(2,2,1) fig2 = plt.subplot(2,2,2) fig1.scatter(x,y) fig2.plot(x,y) plt.show() plt.subplots函数同理。
x = list(range(6)) y = [i**2 for i in x] fig,ax = plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a610329ed49b10693e8ff3462ba6a27d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a77de4dd0fa8df9c394223a46b379bfa/" rel="bookmark">
			Error cannot find module ‘custom-electron-titlebarmain‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 问题描述问题原因解决方案问题：依赖冲突 Keywords: angular-electron | custom-electron-titlebar
这类问题的解决思路在Angular-Electron框架上基本可以看作一个通用的解决方案。
问题描述 简单阐述下怎么出现的问题：
开发项目的过程中，我使用了插件custom-electron-titlebar，正常在项目根目录下下载，并按照官方文档，在主进程main.ts文件中进行配置后。在dev环境下，一切正常，但是build项目，安装exe可执行程序之后发现，我双击打开客户端软件时直接提示我：
A JavaScript error occurred in the main process
继续看错误详情发现：
Uncaught Exception: Error: cannot find module 'custom-electron-titlbear/main' Require stack: xxxx/xxx/xxx/app.asar/main.js 有用的错误信息就这两个了，找不到这个模块，以及在哪里没找到。
问题原因 那，不禁就要问了，为啥我dev运行没有问题，build之后会有问题？
我去网上搜索了一下，一个有用的答案是——没有答案，没什么卵用，还得自己分析。
Angular-Electron使用了two-package.json的项目结构：
其实我们可以简单的理解为，这两个package.json,一个为渲染进程服务，一个为主进程服务在项目dev环境下，项目将所有的依赖都集中放到了一个公共区域，谁用谁取，由于这个区域是公共的，所以主进程中使用的依赖依然可以正确找到自己对应的模块。但是在build时，却分开了，也就是各自打包各自的，分开到了不同的区域，主进程找主进程的，子进程找子进程的，所以production环境下，主进程找不到模块了。 这么说可能不准确，但是简单的理解下这个意思还是可以的。
关于这块我们可以验证下，根据错误信息中的Require stack，我们可以发现这个模块是在app.asar/main.js中没找到，那我们可以解压下这个asar文件，一个简单的方法是在electron-builder.json配置中加上asar:false配置，这样最终生成出来的app.asar就不是一个压缩文件，而是一个正常的文件夹。
我们可以在build之后看下release打包输出文件夹的win-unpack文件夹，这个是免安装文件夹，方便我们查看，可以很明显的看到app.asar生成的nodeModules依赖中并没有custom-electron-titlebar包。
破案了！
解决方案 分析出了原因，解决方案显而易见了，那就在app/package.json这个依赖区中下载一下custom-electron-titlebar呗。这样我们再build时，就能正常的把这个包打进去了，主进程就可以用了。
值得注意的是，如果某个插件包，不仅在主进程中用了，在渲染进程中也用了，那可能两个package.json中都要下载一遍。
没什么问题的话，到这一步基本就解决问题了，但是也会有一些额外的问题，这个就需要具体问题具体分析了，我这里提供一个我遇到的问题：
问题：依赖冲突 我在主进程的package.json下载custom-electron-titlebar之后，由于这个包依赖electron,我使用的Angular-Electron框架呢，也是依赖electron的，很不幸就依赖冲突了。
因为在渲染进程的package.json中下载这个包时，根据npm的规则，nodeModules中出现的包不会重复下载不同的版本，会进行复用，所以不会出现依赖冲突，但是当你下载到主进程的package.json中时，主进程中可没有electron的依赖项，所以在下载custom-electron-titlebar时，不可避免的会再去下载一遍electron，而且electron下载的版本可不是深度绑定的，默认下载的是最新版本。
so,如果下载的electron版本和渲染进程中依赖的electron版本不一致，啧啧，依赖冲突不可避免。
那显而易见，最简单的解决方案是啥，统一版本呗。
看看custom-electron-titlebar下载的electron版本是多少，然后把我们渲染进程中依赖的electron版本进行升/降级。
是个好方法，但是问题太大，版本的升降会带来一些不可预知的意外错误，而且，一旦electron发布了新版，啧啧，你又得统一一次，所以这个方案不是很可取。
比较好的方案是使用对等依赖来解决因为依赖项版本问题导致的冲突。
什么是对等依赖，简单来说就是宿主包和依赖插件之间的依赖关系，比如：我规定了要使用我这个插件，angular的版本必须是13.0.0，那你安装angular依赖时，如果不是13.0.0，那就不会安装成功。 所以回到我们这个问题上，我们只需要在主进程的package.json中指定electron依赖的版本必须是x.x.x(渲染进程中eletron依赖项的版本)，那我们在下载依赖项时就能避免依赖冲突的问题。
对等依赖在package.json配置如下：
"peerDependencies": { "electron": "21.1.1" } 至此，完结。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f22d675bf24465109bec2e98541a2b4a/" rel="bookmark">
			微信小程序中实现——【音乐播放器】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、学习目标1、掌握swiper组件、scroll-view组件的使用2、掌握image组件的使用3、掌握音频API的使用4、掌握slider组件的使用 二、开发前的准备1、页面结构图2、项目初始化3、 任务分析4、 前导知识 三、标签页切换1、页面和样式：2、音乐小程序基础页面和样式：3、页面和样式tab导航的样式：4、测试页面info.wxml、page.wxml、play.wxml文件：5、通过滚动时间切换页面效果（一）滚动事件（二）通过滚动事件切换页面效果： 四、音乐推荐1、scroll-view组件的属性及说明： 2、image组件缩放模式和裁剪模式测试：（一）scroll-view组件： 3、swiper组件实现轮播图：4、flex布局实现功能按钮：（一）flex布局实现功能按钮：（二）flex布局实现页面布局：5、index页面底部播放 五、播放器1、audioctx对象声明的方式：（一）innerAudioContext案例使用：（二）slider组件的使用：（三）音乐播放列表和音乐状态数据：（四）实现音乐播放功能（五）底部播放器的结构代码：（六）底部播放器暂停/播放按钮控制歌曲：(七）实现播放器切换下一曲歌曲：（八）播放器页面结构代码： 六、播放器1、播放器样式12、通过CSS3动画实现海报的旋转功能：3、播放器页面下方的滑块结构：3、显示音乐的播放进度：4、控制进度条的长度控制歌曲播放进度： 七、播放列表1、控制进度条的长度控制歌曲播放进度：2、实现换曲功能： 一、学习目标 1、掌握swiper组件、scroll-view组件的使用 2、掌握image组件的使用 3、掌握音频API的使用 4、掌握slider组件的使用 二、开发前的准备 音乐小程序项目效果展示：
1、页面结构图 tab导航栏
content内容区
player音乐播放控件
2、项目初始化 开发者工具创建空白项目：
{"pages:["pages/index/index" ] } “navigationBarBackgroudColor”:"#fff,
“navigationBartitletext”:“音乐,”
“navigationBarBackgroudColor”:“black”,
3、 任务分析 标签页和页面info.wxml、play.wxml、palylist.wxml
4、 前导知识 swiper组件编写滑动页面结构
&lt;swiper&gt; &lt;swiper-item style="background:#ccc"&gt;0&lt;/swiper-item&gt; &lt;swiper-item style="background:#ddd"&gt;1&lt;/swiper-item&gt; &lt;swiper-item style="background:#eee"&gt;2&lt;/swiper-item&gt; &lt;/swiper-item&gt; swiper组件编写滑动页面结构index.wxml:
&lt;swiper current-item-id="c"&gt; &lt; swiper-item item-id="a"&gt; &lt;image src= "https://assets.lexus.com.cn/images/index/kv/2880x1480. newes. 1.jpg?x-Oss- process=image/resize,w. 1898/quality.q. 80" mode= "widthFix" &gt; &lt;/image&gt; &lt;/swiper-item&gt; &lt;swiper-item item-id="b"&gt; &lt;image src= https://assets.exus.com.cn/images/models/s/s -kv-1 2880.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f22d675bf24465109bec2e98541a2b4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2457c49a6476930b163e7396fee12704/" rel="bookmark">
			hive伪分布式详细部署步骤及报错解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装hive
1、下载压缩包到指定路径：cd /home/bduser/data/hive/
解压缩 tar -xzvf 改名为hive
2、上传mysql-connector到data的mysql-connect下
3、配置环境变量 sudo vim /etc/profile
source /etc/profile
4、cp /home/bduser/data/mysql-connect/mysql-connector-java-5.XXXXXXXXX.jar /home/bduser/data/hive/hive/lib/
5、到hive/conf 目录下 touch hive-site.xml
&lt;configuration&gt;
&lt;property&gt;
&lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt;
&lt;value&gt;jdbc:mysql://hadoop:3306/hive?createDatabaseIfNotExist=true&amp;amp;useSSL=false&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
&lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;/name&gt;
&lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
&lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt;
&lt;value&gt;root&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
&lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt;
&lt;value&gt;123456&lt;/value&gt;
&lt;/property&gt;
&lt;/configuration&gt;
6、将conf下的hive-env.sh.template 重命名为 hive-env.sh
7、重塑lib库（很重要）！！！
# cd /home/bduser/data/hive/hive/lib/
# mv guava-19.0.jar guava-19.0.jar.bak
从hadoop的share/hadoop/common/lib目录复制guava-27.0-jre.jar
# cp /home/bduser/data/hadoop/hadoop/share/hadoop/common/lib/guava-
27.0-jre.jar /home/bduser/data/hive/hive/lib/
# mv log4j-slf4j-impl-2.10.0.jar log4j-slf4j-impl-2.10.0.jar.bak
不然后续会造成冲突报错！！！
7、先启动mysql
service mysqld start
mysql -uroot -p
create database hive CHARACTER SET latin1;(编码格式是Latin1)，用于存储元数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2457c49a6476930b163e7396fee12704/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/100c162dd2530dfe147bf432694d8d96/" rel="bookmark">
			Python课程设计题目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.基于Python的XX管理系统。2.基于Python的XX工具开发 1.基于Python的XX管理系统。 实例要求：采用面向对象或是字典保存实例的属性信息。
功能要求：提供增加，删除，修改，单个查询，查询所有，保存信息到本地文件，退出等功能。
可以是名片管理系统，学生通讯录管理系统，图书馆图书管理系统，售票系统等，大家在线提报自己的选题，不能重复。
下面以学生通讯录管理系统为例，提供参考：
运行程序提示功能选择页面：
每种功能都需要有具体的实现，包括：
添加学生，
删除学生，
修改学生，
查询学生，
查询所有学生，
保存学生到本地文件，
退出学生通讯录管理系统。
每个学习通讯录:
需要含有的信息为学生姓名，性别，电话等。
学生通讯录信息可以通过字典或对象存储，如
2.基于Python的XX工具开发 XX工具可以为：
文件拆分合并工具，
计算器应用，
随机点名工具。
等
小工具具有一定的使用价值。大家在线提报自己的选题，不能重复。
随机点名小工具案例：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8504d978c39723fe3e540c0e1b2bed9/" rel="bookmark">
			重启supervisor服务及 查看、启动、停止、重启supervisor进程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 概述 一、重启supervisor服务 前提：监控报警发现supervisor服务down了 or 检查服务发现supervisor 服务down了
执行sudo supervisorctl命令，输入密码后发现执行失败，说明supervisor服务挂了
解决办法：
1、首先找到supervisor安装的目录，命令为
whereis supervisor1 2、找到对应的supervisor配置文件路径，见截图
3、启动supervisor服务，命令为
sudo supervisord -c /etc/supervisor/supervisord.conf1 4、查看supervisor服务是否正常运行，命令为
sudo supervisorctl1 如果还是不行的话，重复执行第3、4步骤
要操作关闭supervisor则执行命令
sudo supervisorctl shutdown1 见截图
要操作重启supervisor则执行命令
sudo supervisorctl reload1 见截图（重启的前提是supervisor已经在启动中）
二、查看、启动、停止、重启supervisor进程 1、更新配置后必须执行更新命令才生效
sudo supervisorctl update1 2、查看supervisor进程
sudo supervisorctl status1 3、启动某个supervisor进程
sudo supervisorctl start xxxx1 4、停止某个supervisor进程
sudo supervisorctl stop xxxx1 5、停止所有supervisor进程
sudo supervisorctl stop all1 6、重启某个supervisor进程
sudo supervisorctl restart xxxx 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a6c2e59fced9a42571f083b7b6d42ea/" rel="bookmark">
			CentOS7.9.2009安装要点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ISO镜像地址 阿里云镜像源地址（默认选择）：
https://mirrors.aliyun.com/centos/7/isos/x86_64/，选择2207这个。
各个版本的ISO镜像文件说明：
CentOS-7-x86_64-DVD-2207-02.iso # 标准安装版（推荐）
CentOS-7-x86_64-Everything-2009.iso # 完整版，集成所有软件（以用来补充系统的软件或者填充本地镜像）
CentOS-7-x86_64-Everything-2207-02.iso # 完整版，集成所有软件（以用来补充系统的软件或者填充本地镜像）
CentOS-7-x86_64-Minimal-2207-02.iso # 精简版，自带的软件最少
CentOS-7-x86_64-NetInstall-2009.iso # 网络安装版（从网络安装或者救援系统）
其他国内镜像地址：
http://ftp.sjtu.edu.cn/centos/7.9.2009/isos/x86_64/
http://mirrors.njupt.edu.cn/centos/7.9.2009/isos/x86_64/
http://mirrors.bupt.edu.cn/centos/7.9.2009/isos/x86_64/
http://mirrors.cqu.edu.cn/CentOS/7.9.2009/isos/x86_64/
http://mirrors.neusoft.edu.cn/centos/7.9.2009/isos/x86_64/
http://mirrors.bfsu.edu.cn/centos/7.9.2009/isos/x86_64/
http://mirror.lzu.edu.cn/centos/7.9.2009/isos/x86_64/
http://mirrors.aliyun.com/centos/7.9.2009/isos/x86_64/
http://mirrors.tuna.tsinghua.edu.cn/centos/7.9.2009/isos/x86_64/
http://mirrors.ustc.edu.cn/centos/7.9.2009/isos/x86_64/
http://mirrors.nju.edu.cn/centos/7.9.2009/isos/x86_64/
其他镜像地址：
http://ftp.twaren.net/Linux/CentOS/7.9.2009/isos/x86_64/
http://ftp.ksu.edu.tw/pub/CentOS/7.9.2009/isos/x86_64/
http://mirror01.idc.hinet.net/centos/7.9.2009/isos/x86_64/
http://mirror-hk.koddos.net/centos/7.9.2009/isos/x86_64/
http://mirror.worria.com/centos/7.9.2009/isos/x86_64/
http://mirror.xtom.com.hk/centos/7.9.2009/isos/x86_64/
http://mirror.hostlink.com.hk/centos/7.9.2009/isos/x86_64/
http://ftp.kaist.ac.kr/CentOS/7.9.2009/isos/x86_64/
http://mirror.navercorp.com/centos/7.9.2009/isos/x86_64/
http://mirror.anigil.com/CentOS/7.9.2009/isos/x86_64/
http://mirror.kakao.com/centos/7.9.2009/isos/x86_64/
http://mirror.vodien.com/centos/7.9.2009/isos/x86_64/
http://download.nus.edu.sg/mirror/centos/7.9.2009/isos/x86_64/
http://mirror.aktkn.sg/centos/7.9.2009/isos/x86_64/
http://ftp.tsukuba.wide.ad.jp/Linux/centos/7.9.2009/isos/x86_64/
http://ftp.nara.wide.ad.jp/pub/Linux/centos/7.9.2009/isos/x86_64/
http://mirrors.cat.net/centos/7.9.2009/isos/x86_64/
http://ftp.riken.jp/Linux/centos/7.9.2009/isos/x86_64/
http://ftp.iij.ad.jp/pub/linux/centos/7.9.2009/isos/x86_64/
系统安装步骤 1、开机按F11进入bios模式
2、进入启动选项，选择U盘启动
3、加载操作系统程序，选择Install CentOS 7
4、按“e”进入命令编辑界面，将原来的vmlinuz …… quiet部分替换成：vmlinuz initrd=initrd.img linux dd quiet，按下ctrl+x，罗列出盘符路径，如下图所示，找到我们U盘对应的磁盘路径，重新启动。 5、重新进入按“e”进入命令编辑界面，将原来的vmlinuz …… quiet部分替换成vmlinuz initrd=initrd.img inst.stage2=hd:/dev/sdb4 quiet，按下ctrl+x即可正常进入系统安装界面。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a6c2e59fced9a42571f083b7b6d42ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be272ff89839662a2a1788f25712a7ba/" rel="bookmark">
			解决PTA题：找错误原因（3）6-6 删除字符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本题要求实现一个删除字符串中的指定字符的简单函数。
答案：
void delchar( char *str, char c ) { int i,j; for (i = 0; * (str + i) != '\0'; i++) if (*(str + i) == c) { for (j = i; * (str + j) != '\0'; j++) *(str + j) = *(str + j + 1); i=-1;//一定不能少 } } 分析：
第一次我的代码如下：
void delchar( char *str, char c ) { int i,j; for (i = 0; * (str + i) !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be272ff89839662a2a1788f25712a7ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/080365b93e1bd284a5ff530566193ad0/" rel="bookmark">
			一个变量命名神器：支持中文转变量名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		变量命名的规范，对于我们编程，大家都知道是非常重要的，上次给大家推荐过一个命名辅助工具《程序员还在为变量取名苦恼，那是因为你不知道，这个变量命名神器》，但大家一致反馈存在2个问题：
1、网速很慢，非常影响效率；
2、对于中文支持不是很好。
所以，今天给大家推荐另外一个变量命名辅助工具。
一、网站介绍
输入中文，自动翻译为英文，并按照匈牙利命名法列举变量列表。
变量列表分为2部分，第一部分为常用命名方法：小驼峰法、大驼峰法、下划线法、前下划线法。
第二部分：为全局的命名方法
包含各种类型的变量，比如：全局、常量、静态、数组、函数、布尔类型、句柄等等。
支持直接点击，拷贝变量名称，方便使用。
二、效果展示
输入：用户列表
输入：数字相加
输入：倒序
三、网站地址
https://www.chtml.cn/
- End -
-
技术群：添加小编微信并备注进群
小编微信：mm1552923 公众号：dotNet编程大全 ​
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31f609c8e397338e30538e5822f73592/" rel="bookmark">
			所有的 Boost 库文档的索引
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		入门 工具 网站 新闻 社区 常见问题 更多的信息
按字母顺序列出的库
按类别列出的库
算法
破碎的编译器的解决方法
并发编程
容器
正确性和测试
数据结构
特定于域的
函数对象和高阶编程
泛型编程
图像处理
输入/输出
跨语言支持
迭代器
语言功能仿真
数学和数字
内存
解析
模式和习语
预处理器元编程
编程接口
状态机
字符串和文本处理
系统
模板元编程
杂项
图书馆从提高退休
请参阅入门页面以了解如何下载、 构建和安装库。
按字母顺序列出的库
蓄能器-增量计算和统计累加器，Eric Niebler 从集合框架
算法-有用的通用算法，从马歇尔小钩集合
对齐-内存对齐功能、 分配器和特质，从格伦费尔南德斯
任何单一类型的值不同的值，从 Kevlin 海安全、 泛型容器
数组的数组大小不变，从尼科莱约祖蒂斯的 STL 兼容的容器包装
澳洲-便携式网络和其他低级的 I/O，包括插座、 定时器、 主机名解析、 套接字 iostreams，串行端口、 文件描述符和 Windows 处理，从克里斯 Kohlhoff
断言-可自定义断言宏，从彼得 Dimov
分配-用常数或生成的数据填充容器从未如此简单，从托尔斯腾 · Ottosen
原子-C + + 11 式原子 &lt;&gt;，从 Helge 巴曼、 蒂姆 · Blechmann 和安德烈 Semashev
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31f609c8e397338e30538e5822f73592/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9f7b260444e8bed7694619a1821eb3b/" rel="bookmark">
			Vue3&#43;TS使用element-plus 动态Icon图标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1，前言2，使用2.1，方式一2.2，方式二 1，前言 源于一段话
Element Plus 团队正在将原有组件内的 Font Icon 向 SVG Icon 迁移，请多多留意更新日志, 及时获取到更新信息，Font Icon 将会在第一个正式发布被废弃，请尽快迁移
在此记录一下如何使用element-plus中的icon组件
环境：
Vue：3.2.16Element-Plus：1.2.0-beta.3TypeScript：4.4.3Vite：2.6.4 2，使用 文档原话：如果你想像用例一样直接使用，你需要全局注册组件，才能够直接在项目里使用
在main.ts中先导入
import * as Icons from '@element-plus/icons' 2.1，方式一 在main.ts中
import { createApp } from 'vue' import App from './App.vue' import router from './router' import { store, key } from './store' import * as Icons from '@element-plus/icons' const app = createApp(App) app.use(store, key) app.use(router) app.mount('#app') // 注册全局组件 Object.keys(Icons).forEach(key =&gt; { app.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9f7b260444e8bed7694619a1821eb3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc081fdc4226fde463ed99dbc23af9dc/" rel="bookmark">
			windows10: 在一个局域网上，一台电脑可以ping其他电脑，其他电脑ping不通这台电脑。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、windows，点击设置
2、点击更新和安全
3、点击Windows安全中心
4、 选择防火墙
5、 选择 ：允许应用通过防火墙
6、 选择文件和打印机共享
7、至此结束
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40f3ae663a80f7f8464d87ae93b28418/" rel="bookmark">
			如何排查CPU 100%的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一台机器，CPU100%，如何找到相关服务，如何定位问题代码，今天简单分享下思路。
简要步骤如下：
找到最耗CPU的进程； 找到最耗CPU的线程； 查看堆栈，定位线程在干嘛，定位对应代码； 步骤一、找到最耗CPU的进程 工具：top 方法：
执行top -c ，显示进程运行信息列表 键入P (大写p)，进程按照CPU使用率排序 图示： 如上图，最耗CPU的进程PID为10765。
步骤二：找到最耗CPU的线程 工具：top 方法：
top -Hp 10765 ，显示一个进程的线程运行信息列表 键入P (大写p)，线程按照CPU使用率排序 图示： 如上图，进程10765内，最耗CPU的线程PID为10804。
步骤三：查看堆栈，定位线程在干嘛，定位对应代码 首先，将线程PID转化为16进制。 工具：printf 方法：printf "%x\n" 10804
如上图，10804对应的16进制是0x2a34，当然，这一步可以用计算器。
之所以要转化为16进制，是因为堆栈里，线程id是用16进制表示的。
jave 查看方式 接着，查看堆栈，找到线程在干嘛。 工具：jstack 方法：jstack 10765 | grep '0x2a34' -C5 --color 打印进程堆栈 通过线程id，过滤得到线程堆栈 图示：
如上图，找到了耗CPU高的线程对应的线程名称“AsyncLogger-1”，以及看到了该线程正在执行代码的堆栈。
go的查看方式 目前pstack对于go进程根本不管用 目前我了解的唯一办法就是给进程发送SIGQUIT信号：
kill -SIGQUIT &lt;pid&gt;
go进程在收到SIGQUIT信号后，会往标准错误(stderr)打印出所有goroutine的stack信息。
但是遗憾的是，此时go进程也就退出了。
package main
import (
"runtime/debug"
"time"
)
func main() {
go a()
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40f3ae663a80f7f8464d87ae93b28418/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c36b3346cbce96a6cac9aeec633befa7/" rel="bookmark">
			Java web 2022跟学尚硅谷(八)qqzone项目完整版开源分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java web 2022跟学尚硅谷 八qqzone完整版 项目说明项目结构界面展示用户的登录主界面进入朋友空间针对朋友发表的日志进行回复主人回复添加日志 数据库相关sql相关代码BasicDAO 调用德鲁伊连接池，完成sql执行HostReplyController 主人回复ReplyController 回复TopicController 日志UserController用户信息以及登录DAOException自定义异常DispatcherServletException中央控制器自定义异常HostReplyServiceImpl主人回复实现ReplyServiceImpl 回复实现TopicServiceImpl日志实现类UserBasicServiceImpl用户功能实现类DruidUtils德鲁伊连接池 项目说明 跟学尚硅谷最新版本2022，完成了qqzone项目的制作，项目所有源码给出，方便所有需要学习的朋友，项目给出，Gitee码云的连接，可以自行fork。麻烦顺手给文章点个赞谢谢啦！
qqzone项目完整版
数据库连接池:Druid跟学韩顺平老师的项目，这里没按照视频老师的方式配置，所以Service中有些代码的地方是按照自己的实际情况写的。源码和素材可以去看视频底下有获取方式 项目结构 界面展示 用户的登录 还没有账号，这个功能暂时没有实现
主界面 进入朋友空间 当前登录用户是Jim，现在点击左侧好友列表，进入kate的空间，可以查看kate发表的日志
针对朋友发表的日志进行回复 在朋友的日志下，可以进行回复
主人回复 在当前登录的用户日志列表中，鼠标靠近别人的回复，可以直接添加主人回复，这里是用form表单实现，因为超链接跳转隐藏form表单的方法不是太会，就用了这种方式，大家可以自行尝试
添加日志 点击日志列表右上角的“发表新日志，即可跳转发表新日志”
数据库相关sql CREATE DATABASE `qqzonedb2` CHAR SET utf8; USE qqzonedb2; `t_friend``t_friend` CREATE TABLE `t_user_basic` ( `id` INT(11) NOT NULL AUTO_INCREMENT, `loginId` VARCHAR(20) NOT NULL, `nickName` VARCHAR(50) NOT NULL, `pwd` VARCHAR(20) NOT NULL, `headImg` VARCHAR(20) DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `loginId` (`loginId`) ) ENGINE=INNODB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8; INSERT INTO `t_user_basic`(`id`,`loginId`,`nickName`,`pwd`,`headImg`) VALUES (1,'u001','jim','ok','h1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c36b3346cbce96a6cac9aeec633befa7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb36d721446e4892c257803c3c8eced4/" rel="bookmark">
			深度相机介绍（TOF、RGB双目、结构光参数对比）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、深度相机的介绍
随着计算机视觉与人工智能技术的飞速发展，采用深度相机进行场景三维重建、目标检测、环境感知等应用越来越广泛，与传统的2D相机不同，深度相机可以通过拍摄空间来获得景深信息，从而获得目标的3D信息，构建3D模型，这也是与普通相机最大的差别。目前的深度相机根据其工作原理可以分为三种：TOF、RGB双目、结构光，在机器人、人机交互以及其他工业领域中等到了广泛应用。如下图所示为三种相机的参数差异对比：
相机类型
TOF
RGB双目
结构光
测距方式
主动式
被动式
主动式
工作原理
根据光的飞行时间直接测量
RGB图像特征点匹配，三角测量间接计算
主动投射已知的编码图案，提升特征匹配效果
测量精度
最毫米级高可达厘米级
近距离可达
近距离达到高精度0.01-1 mm
测量范围
＜100 m
由于基线的限制，一般只能测量较近的距离，距离较远时，测距越不准确。
一般2 m（基线10 mm）以内
小于10 m
影响因素
不受光照变化和物体纹理影响，受多重反射影响
受光照变化和物体纹理影响很大，夜晚无法使用
不受光照变化和物体纹理反射影响，收反光影响
户外工作
功率小，则影响较大
无影响
有影响，与编码图设计有关
分辨率
低于640×480
可达2K分辨率
可达1080×720
帧率
可达上百fps
从高到底都有
一般30fps
软件复杂度
较低
很高
中等
功耗
很高，需全面照射
较低，纯软件
中等，投射图案，照射局部区域
市面上常见的深度相机代表公司：
（1）结构光(Structured-light)，代表公司有奥比中光，苹果(Prime Sense)，微软 Kinect-1，英特尔 RealSense, Mantis Vision等。
（2）双目视觉(Stereo)，代表公司Leap Motion，ZED，大疆等。
（3）光飞行时间法(TOF)，代表公司微软Kinect-2，PMD，SoftKinect，联想Phab等。
二、深度相机工作原理简介
1.RGB双目
双目立体视觉(Binocular Stereo Vision)是机器视觉的一种重要形式，他是基于视差原理并利用成像设备从不同的位置获取被测物体的两幅图像，通过计算图像对应点间的位置偏差，来获取物体三维几何信息的方法。
双目立体视觉系统的四个基本步骤：
①相机标定主要包含两部分内容: 单相机的内参标定和双目相机的外参标定，前者可以获得每个相机的焦距、光心、畸变系数等参数，后者可以获得双目相机之间的相机坐标系的旋转、平移关系。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb36d721446e4892c257803c3c8eced4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7bb692df54c02d101f652dd30eb165c/" rel="bookmark">
			nginx配置下载文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.nginx配置文件添加配置 location /download { root /data; add_header Content-Disposition: "attachment"; add_header Content-Type application/octet-stream; autoindex off; # 开启目录浏览功能 autoindex_exact_size off; # 关闭详细文件大小统计，让文件大小显示MB，GB单位，默认为b autoindex_localtime on; # 开启以服务器本地时区显示文件修改日期 } 2.重启nginx 3.在/data/download 目录下创建要下载的文件 aa.txt 4.在浏览器输入:http://ip:prot/download/aa.txt 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abe53d01d8124d04c03a89f6462e48fe/" rel="bookmark">
			spring boot整合Knife4j
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、Knife4j简介2、与 spring boot整合2.1 引入依赖2.2 配置Knife4j2.3 放行Knife4j请求2.4 使用Knife4j注解标记接口2.5 访问页面 3、其它功能3.1 token认证参数设置3.2 离线文档 1、Knife4j简介 以下内容来自Knife4j官网，贴一下官网地址：https://doc.xiaominfo.com/
knife4j是为Java MVC框架集成Swagger生成Api文档的增强解决方案
Knife4j的前身是swagger-bootstrap-ui,前身swagger-bootstrap-ui是一个纯swagger-ui的ui皮肤项目
一开始项目初衷是为了写一个增强版本的swagger的前端ui,但是随着项目的发展,面对越来越多的个性化需求,不得不编写后端Java代码以满足新的需求,在swagger-bootstrap-ui的1.8.5~1.9.6版本之间,采用的是后端Java代码和Ui都混合在一个Jar包里面的方式提供给开发者使用.这种方式虽说对于集成swagger来说很方便,只需要引入jar包即可,但是在微服务架构下显得有些臃肿。
因此,项目正式更名为knife4j,取名knife4j是希望她能像一把匕首一样小巧,轻量,并且功能强悍,更名也是希望把她做成一个为Swagger接口文档服务的通用性解决方案,不仅仅只是专注于前端Ui前端.
swagger-bootstrap-ui的所有特性都会集中在knife4j-spring-ui包中,并且后续也会满足开发者更多的个性化需求.
主要的变化是,项目的相关类包路径更换为com.github.xiaoymin.knife4j前缀,开发者使用增强注解时需要替换包路径
后端Java代码和ui包分离为多个模块的jar包,以面对在目前微服务架构下,更加方便的使用增强文档注解(使用SpringCloud微服务项目,只需要在网关层集成UI的jar包即可,因此分离前后端)
目前主要支持以Java开发为主,并且是依赖于大环境下使用的Spring MVC、Spring Boot、Spring Cloud框架.
当然,Knife4j也提供了离线版本,只要是符合Swagger的OpenAPI版本的规范JSON,都可以通过简单的配置进行适配，离线版本是适合于任何语言中使用Swagger的,非常的灵活、方便。
2、与 spring boot整合 2.1 引入依赖 &lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.7&lt;/version&gt; &lt;/dependency&gt; 2.2 配置Knife4j @Configuration @EnableSwagger2WebMvc public class Knife4jConfig { @Bean public Docket docket(Environment environment) { // 添加接口请求头参数配置 没有的话 可以忽略 ParameterBuilder tokenPar = new ParameterBuilder(); List&lt;Parameter&gt; pars = new ArrayList&lt;&gt;(); tokenPar.name("token") .description("令牌") .defaultValue("") .modelRef(new ModelRef("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abe53d01d8124d04c03a89f6462e48fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b35e729e5288ad15bf2b689448c2a1ee/" rel="bookmark">
			VMware 虚拟机安装 Ubuntu 20.04-server 详细图文教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、安装步骤
1.选择语言
2.系统更新 3.设置键盘
4.配置动态IP地址
5.服务器代理
6.设置镜像源地址 7. 配置存储
8.文件系统
​9.创建用户
10.不用理会，直接跳过
11.安装SSH服务
12.其他工具
13.系统配置完成，安装界面
15.登录界面
二、配置静态网络
1.查看当前 ip
2.查看网关
3.修改配置文件
三、开启 root 默认登录
1.以普通用户登录系统，创建 root 用户的密码
2. 修改 sshd 配置
3.重启 sshd 服务
四、替换 yum 源
1.这里我们先打开存放源的目录
2.在配置文件添加下面信息
3.为了使修改的内容发挥作用，我们需要更新系统，依次输入以下指令：
4.安装常用工具
Ubuntu下载官网
阿里巴巴开源镜像站-OPSX镜像站-阿里云开发者社区 下载速度快些：
本次使用VMware Workstation 16 进行安装！
一、安装步骤 开机后会先进行各种检查，等待一小会，直到出现安装界面，后面的各种操作都使用回车键确定选择！
1.选择语言 选择语言为English：
2.系统更新 提示我们可以更新系统版本，选择不更新：
3.设置键盘 选择键盘布局，我们这里就使用默认的美式英语键盘布局，直接回车：
4.配置动态IP地址 接下来选择网络连接，可以看到我的虚拟机有一个叫ens32的网卡，这个是VMware生成的一个虚拟网卡，默认使用DHCP（动态分配IP），实际中服务器使用的是固定的IP，而这里为了虚拟机能够直接访问外网下载软件包，我们先使用默认的DHCP方式连接，如果确有需要进行固定IP的访问再修改IP。直接回车：
5.服务器代理 接下来选择一个代理服务器，看英文解释也可以明白，如果你的虚拟机不能直接连接外网，但是它连接了一个代理服务器，代理服务器可以连接外网，那么可以在这里填入代理服务器的地址来让你的虚拟机通过代理访问外网，我们直接回车：
6.设置镜像源地址 接下来选择安装软件包的镜像源，Ubuntu默认的官方镜像源下载很慢，我们需要更换成国内其他镜像源，这里我更改为阿里云(https://mirrors.aliyun.com/ubuntu/)或者清华镜像源(https://mirrors.tuna.tsinghua.edu.cn/ubuntu/)并回车：
7. 配置存储 接下来配置存储引导，我只创建了一块30GB的硬盘，选择使用整块硬盘，并且安装LVM，LVM是一个管理磁盘的工具，下面的Encrypt意思是加密，我们不需要磁盘加密，不选择，这些都是默认值，所以其实还是直接回车就行：
8.文件系统 显示在磁盘上创建文件系统的摘要，直接回车即可：
然后会提示你你在进行破坏性操作，之前选择的硬盘上的数据都会丢失，而且安装过程不可逆，选择Continue然后回车：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b35e729e5288ad15bf2b689448c2a1ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d77ac5eed64597ff7b4e4b038d80ec6/" rel="bookmark">
			斐波那契数列问题【Java实现】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
题目：
背景：
方法一：暴力递归 复杂度O(2^N)
方法二：复杂度O(N)
方法三：O（logN）复杂度
两个矩阵相乘：
求矩阵m的p次方的代码实现：
用矩阵乘法求斐波那契数列第N项代码实现：
题目： 给定整数N，返回斐波那契数列的第N项。
背景： 斐波那契数列（Fibonacci sequence），又称黄金分割数列，因数学家莱昂纳多·斐波那契以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波那契数列以如下被以递推的方法定义：F(0)=0，F(1)=1, F(n)=F(n - 1)+F(n - 2)（n ≥ 2，n ∈ N*）。
方法一：暴力递归 复杂度O(2^N) public static int f1(int n) { if (n &lt; 1) { return 0; } if (n == 1 || n == 2) { return 1; } return f1(n-1) + f1(n-2); } 方法二：复杂度O(N) 从左到右依次求出每一项的值：
（1）定义三个变量 result，pre，tmp
（2）tmp 保存上次的result值 （用于等会儿赋值给pre），然后计算新的result=result+pre，计算完新的result之后，把tmp中存的上一个result的值赋值给pre。换句话说，就是实现前一个和后一个一直相加。
//从左到右依次求出每一项的值 1 1 2 3 5 8 13 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d77ac5eed64597ff7b4e4b038d80ec6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22ab13febe39eaca83111071f3bb0222/" rel="bookmark">
			centos安装java8(一键安装)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		centos安装java8(一键安装) 安装JDK
# yum install java-1.8.0-openjdk* 安装java1.8.0所有程序
yum install -y java-1.8.0-openjdk-devel.x86_64 注意:输入确认(y)直到控制台返回Complete安装成功
查看java版本信息
# java -version 输入javac java命令后显示帮助信息就算是安装成功了
使用yum安装环境变量自动就配好了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f2c477c480edc91e8b7784aac363723/" rel="bookmark">
			C语言#bug#双向链表尾部插入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如图：
1、正确的，下意识认为的2、bug的，实际发生的。 测试代码：
#include "gtest/gtest.h" #include "mockcpp/mokc.h" #include "linux/list.h" #include &lt;cstdlib&gt; #define TEST_PRINT #ifdef TEST_PRINT #define TEST_LOG_PRINT(x) std::cout &lt;&lt; "res is [" &lt;&lt; x &lt;&lt; "]" #define TEST_LOG_PRINT2(x) std::cout &lt;&lt; "res is [" &lt;&lt; x &lt;&lt; "]\n" #endif // TEST_PRINT TEST(linux_list, basic) { head_t list; // Act#01: 空链表 ---&gt; 指向自身 INIT_LIST_HEAD(&amp;list); // assert#01: EXPECT_EQ(list.prev, &amp;list); EXPECT_EQ(list.next, &amp;list); } TEST(linux_list, add_tail) { struct TestBuffer { int val; list_head list; }; // Act: 链表链接10个元素: 0 1 2 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f2c477c480edc91e8b7784aac363723/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17591c32f6fa35b371763b4c38a3bf7f/" rel="bookmark">
			Spring Cloud Ribbon负载均衡策略（IRule接口）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ribbon负载均衡策略 可以看到 Ribbon 中实现了非常多的选择策略，下面来详细解读一下 IRule 接口的各个实现。
AbstractLoadBalancerRule 负载均衡的策略的抽象类，在该抽象类中定义了负载均衡器 ILoadBalancer 对象，该对象能够在具体实现选择服务策略时，获取到一些负载均衡器中维护的信息来作为分配依据，并以此设计一些算法来实现针对特定场景的高效策略。
/** * Class that provides a default implementation for setting and getting load balancer * 该类提供用户设置和获取负载均衡器的默认实现 * @author stonse * */ public abstract class AbstractLoadBalancerRule implements IRule, IClientConfigAware { private ILoadBalancer lb; @Override public void setLoadBalancer(ILoadBalancer lb){ this.lb = lb; } @Override public ILoadBalancer getLoadBalancer(){ return lb; } } RandomRule 该策略实现了从服务实力清单中随机选择一个服务实例的功能。
@Override public Server choose(Object key) { return choose(getLoadBalancer(), key); } public Server choose(ILoadBalancer lb, Object key) { if (lb == null) { return null; } Server server = null; while (server == null) { if (Thread.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17591c32f6fa35b371763b4c38a3bf7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6949e3bf2ce17babe51a3045e230618c/" rel="bookmark">
			Android Studio中默认Botton的颜色(学习笔记）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.首先建立一个xml文件，在android--app--res--layout目录下
如下所示创建的december.xml文件
2.选择一个button拖至页面任意位置
3.将会看见code页面下出现以下，关于button的一段默认的设定
一、修改button的颜色
在&lt;button/&gt;内添加，android:background="#FF0"(#FF0代表亮黄色）
⚠️！！！此处可能会出现，右边按钮颜色仍然是默认颜色的情况（我换了别的颜色，发现有的可以改变，有的不行，也不知道是啥子问题）
如果出现上面的问题，可以参考以下方法来实现改成黄色滴按钮：
&lt;1&gt;首先打开thems.xml文件,res--values, choose "themes.xml"
&lt;2&gt;然后将&lt;style name="……"parent="Theme.MaterialComponents.DayNight.DarkActionBar"&gt;
修改成
&lt;3&gt;返回december，此时button已经修改成了黄色滴按钮
&lt;4&gt;修改button的textcolor，再在外部添加一个background，如下所示的第6行和第17行
​​​​​​​
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f48f1df120c4a1539cfcfc0fa8f0e39/" rel="bookmark">
			SSM整合：spring层，springMVC层-P17，18
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		applicationContext.xml：（将三个层的配置文件整合到一个xml里面）
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;import resource="spring-dao.xml"/&gt; &lt;import resource="spring-service.xml"/&gt; &lt;import resource="spring-mvc.xml"/&gt; &lt;/beans&gt; database.properties：（数据库连接配置文件）
jdbc.driver=com.mysql.cj.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/ssmbuild?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai jdbc.username=root jdbc.password=123456 spring-dao.xml：（相当于用spring来配置mybatis）
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 配置整合mybatis --&gt; &lt;!-- 1.关联数据库文件 --&gt; &lt;context:property-placeholder location="classpath:database.properties"/&gt; &lt;!-- 2.数据库连接池 --&gt; &lt;!--数据库连接池 dbcp 半自动化操作 不能自动连接 c3p0 自动化操作（自动的加载配置文件 并且设置到对象里面） --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;!-- 配置连接池属性 --&gt; &lt;property name="driverClass" value="${jdbc.driver}"/&gt; &lt;property name="jdbcUrl" value="${jdbc.url}"/&gt; &lt;property name="user" value="${jdbc.username}"/&gt; &lt;property name="password" value="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f48f1df120c4a1539cfcfc0fa8f0e39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59857cbdcd6038c3781fd61936931292/" rel="bookmark">
			Javaweb安全——Weblogic反序列化漏洞(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从原生反序列化过程开始谈起。
原生反序列化 序列化就是把对象转换成字节流，便于保存在内存、文件、数据库中；反序列化即逆过程，由字节流还原成对象。
大致是这么一个过程，简单画了个图：
测试类如下：
package ser; import java.io.*; public class TestClass implements Serializable { private String text; public TestClass() { this.text = "hello world"; } private void readObject(ObjectInputStream ois) throws Exception { System.out.println("serializing......"); ois.defaultReadObject(); System.out.println("Done"); System.out.println(this.text); } public static void main(String[] args) throws IOException, ClassNotFoundException { TestClass Class = new TestClass(); ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("C:\\Users\\aaa\\Documents\\GitHub\\zkar\\o.ser")); oos.writeObject(Class); oos.close(); ObjectInputStream ois = new ObjectInputStream(new FileInputStream("C:\\Users\\aaa\\Documents\\GitHub\\zkar\\o.ser")); ois.readObject(); } } 生成的序列化文件内容如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59857cbdcd6038c3781fd61936931292/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17b4482086cb24dd599e1f5a0c8bc3f6/" rel="bookmark">
			Android基础学习（二十一）—— Handler
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、一文读懂 Handler 机制
Handler 在整个 Android 开发体系中占据着很重要的地位，是一种标准的事件驱动模型，对开发者来说起到的作用很明确，就是为了实现线程切换或者是执行延时任务，稍微更高级一点的用法可能是为了保证多个任务在执行时的有序性。由于 Android 系统中的主线程有特殊地位，所以像 EventBus 和 Retrofit 这类并非 Android 独有的三方库，都是通过 Handler 来实现对 Android 系统的特殊平台支持。
该文章讲解了Handler的内部实现机制
二、关于Handler 的这 15 个问题，你都清楚吗？
该文章从问题出发来讲解了原理
三、几个问题的解答
1、更新UI的方式
2、子线程向主线程发消息，使主线程更新UI
3、主线程向子线程发消息
4、子线程向子线程发消息
5、Handler的实现中涉及到循环的地方？
6、Looper.loop阻塞主线程时，怎么响应用户操作和回调Activity生命周期相关的方法？
7、Handler内存泄漏？
1、更新UI的方式 共有四种方式（https://blog.csdn.net/ruancoder/article/details/52081614)：
（1）Handler.sendEmptyMessage 或者 Handler.sendMessage
private Handler mHandler = new Handler() { @Override public void handleMessage(Message msg) { if (msg.what == MSG_REFRESH) { mTextView.setText("123"); } } }; private void refresh1() { mHandler.sendEmptyMessage(MSG_REFRESH); } （2）Handler.post
private void refresh2() { mHandler.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17b4482086cb24dd599e1f5a0c8bc3f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38cc710860f7a27f6766548540cfb5fb/" rel="bookmark">
			【开发经验】为什么gateWay网关要用webFlux代替WebMvc
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看过gateWay源码的都知道，它的底层使用的WebFlux。
WebFlux会比传统的MVC更快？如果是这样，为什么平时开发不用这个？带着这个疑惑我翻了大把的资料，全是异步编程，全是快，异步等。但是一个机器的资源就这么多，它又是如何更快的呢？如果快的话，为什么平时没人用呢？通过如下这个案例，来说一下我的理解。
测试案例1 设置当前服务工作线程数为1，通过普通的同步写法，请求到接口。
public static void main(String[] args) { // 设置当前工作线程为1. System.setProperty("reactor.netty.ioWorkerCount","1"); SpringApplication.run(GatewayApplication.class, args); } @GetMapping("/test3") public String stringMono3(){ logger.info("threadName:{}",Thread.currentThread().getName()); return "1"; } @GetMapping("/test4") public String stringMono4(){ logger.info("threadName:{}",Thread.currentThread().getName()); try { Thread.sleep(10000); } catch (InterruptedException e) { e.printStackTrace(); } return "1"; } 快速的请求test4和test3接口（保证先请求test4）日志如下：
2022-11-11 11:23:01.697 INFO 61844 --- [ctor-http-nio-1] c.m.gateway.handler.FollBackController : threadName:reactor-http-nio-1 2022-11-11 11:23:11.704 INFO 61844 --- [ctor-http-nio-1] c.m.gateway.handler.FollBackController : threadName:reactor-http-nio-1 仔细观察日志打印时间，可以看出当只有一个线程的时候，test4通过sleep方法让线程休眠，在休眠期间，该线程不做任何事情，导致请求test3接口时，也会等待很久。
这样可以想到，在真实场景中，如果有太多的这种阻塞操作，大量的线程在等待，会大量浪费计算机资源。能不能有一种方式，不让其等待呢？好比这个人没事的时候，就去干会别的活呢？
测试案例2 @GetMapping("/test2") public Mono&lt;String&gt; stringMono2(){ Mono&lt;String&gt; log = WebClient.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38cc710860f7a27f6766548540cfb5fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e8b9ecab22a04f2ad074db3eac1e262/" rel="bookmark">
			transformer与视觉
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 综述优秀网文基本transformer视觉transformer原理具体的transformer一般方法ViT ：一张图等于 16x16 个字，计算机视觉也用上 Transformer 了DeiT：[Facebook开源高效图像Transformer，速度、准确率与泛化性能媲美SOTA CNN](https://mp.weixin.qq.com/s/FmlCX1okXxOiJeBPQ6wuOQ)T2T ViT：Tokens-to-Token ViT: Training Vision Transformers from Scratch on Imagenet (图像patch之间有部分重叠)DeepViT: Towards Deeper Vision Transformer(多个注意力头之间重新生成注意力，增加transformer深度) transformer与CNN结合Bottleneck Transformers for Visual Recognition：resnet的卷积用多头注意力模块替代PiT: Rethinking Spatial Dimensions of Vision Transformers（ 结合池化层的视觉Transformer网络）.Scalable Visual Transformers with Hierarchical PoolingCvT: Introducing Convolutions to Vision TransformersCeiT: Incorporating Convolution Designs into Visual TransformersConViT: Improving Vision Transformers with Soft Convolutional Inductive BiasesTransFuse：融合Transformers和CNN用于医学图像分割CoTr：基于CNN和Transformer进行3D医学图像分割 多尺度，高分辨率PVT：Pyramid Vision Transformer: A Versatile Backbone for Dense Prediction without ConvolutionsDPT: Vision Transformers for Dense PredictionCrossViT: Cross-Attention Multi-Scale Vision Transformer for Image ClassificationMulti-Scale Vision Longformer: A New Vision Transformer for High-Resolution Image EncodingSwin Transformer: Hierarchical Vision Transformer using Shifted WindowsM2TR: multi-modal multi-scale transformers for deepfake detection (多模多尺度) Transformer内部机制的探究充分挖掘patch内部信息：Transformer in Transformer：TNT探究位置编码的必要性：Do We Really Need Explicit Position Encodings for Vision Transformers?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e8b9ecab22a04f2ad074db3eac1e262/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0a32131f38cfbe9f1e4602ce42d525d/" rel="bookmark">
			解一元二次方程——Java
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解一元二次方程：
可以使用下面的公式求元二次方程ax*x+bx+c=0的两个根： b*b- 4ac称作一元二次方程的判别式。如果它是正值，那么一元二次方程就有两个实数根。如果它为0，方程式就只有一个根。如果它是负值，方程式无实数根。 编写程序，提示用户输入a、b和c的值，并且显示基于判别式的结果。如果这个判别式为正，显示两个根。如果判别式为0，显示一个根。否则，显示“Theequation has no real roots" (该方程式无实数根)。 注意，可以使用Math.pow(x , 0.5)或Math.sqrt( x )来计算的值。下面是一些运行示例。 Enter a, b, c：1.0 3 1 8 The equation hastwo roots -0.381966 and -2.61803 Enter a, b, c：1 2.0 1 8 The equation hasone root -1.0 Enter a, b, c： 1 2 3 8 The equation hasno real roots 代码如下：
import java.util.Scanner; public class fangcheng { public static void main(String[] args) { //输入a,b,c值 System.out.println("请分别输入a,b,c的值"); Scanner input=new Scanner(System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0a32131f38cfbe9f1e4602ce42d525d/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/117/">«</a>
	<span class="pagination__item pagination__item--current">118/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/119/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>