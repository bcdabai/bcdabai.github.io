<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49026fc55147531f176cafe95e313f20/" rel="bookmark">
			【C语言】指针之函数指针（回调函数）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、函数指针的概念
二、函数指针的应用
（1）调用函数
（2）将函数的地址作为函数参数传入其他函数。
三、实例演示
一、函数指针的概念 函数指针的定义
若在程序中定义了一个函数，编译时，编译器会为函数代码分配一段存储空间，这段空间的起始地址（又称入口地址）称为这个函数的指针。
与普通变量相同，可以定义一个指针指向存放函数代码的存储空间的起始地址，这样的指针就是函数指针。
函数指针的定义格式如下：
返回值类型 （*变量名）（参数列表）
返回值类型是指针指向函数的返回值类型，*表示一个指针变量，参数列表是指针指向函数的形参列表。
【注释】因为*的优先级较高，所以要将*和变量名括起来
实例：
int func(int a,int b);//函数声明
int (*p) (int , int );//定义一个参数列表为两个int型的变量，返回值类型为int型的函数指针p
p=func；//函数指针p指向函数func的起始地址 二、函数指针的应用 （1）调用函数 使用函数指针调用对应函数，方法和使用函数名调用函数类似，只需将函数名替换成（*指针名）
调用函数指针p指向的函数
（*p）(3,5);
（2）将函数的地址作为函数参数传入其他函数。 将函数的地址传入其他参数，就可以在被调函数中使用实参函数。
将func的地址作为参数传入func2函数
void func2(int（*p）（int，int），int b,int c);
三、实例演示 #include &lt;stdio.h&gt; void sum_row(int(*arr)[4], int raw, int* sum);//行求和函数声明 void sum_col(int(*arr)[4], int raw, int* sum);//列求和函数声明 //行求和函数定义 void sum_row(int(*arr)[4], int raw, int* sum) { int i = 0; *sum = 0; for (; i &lt; 4; i++) { *sum += (*(*(arr + raw-1) + i)); } } //列求和函数定义 void sum_col(int(*arr)[4], int col, int* sum) { int i = 0; *sum = 0; for (; i &lt; 3; i++) { *sum += (*(*(arr +i ) + (col-1))); } } int main() { int matrix[3][4]; int i, j; for (i = 0; i &lt; 3; i++) { for (j = 0; j &lt; 4; j++) { matrix[i][j] = i * 4 + j; } } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49026fc55147531f176cafe95e313f20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a6b82ee224971aec2894b05c6e80599/" rel="bookmark">
			【设计模式系列17】中介者模式原理及其在JDK源码中的体现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		中介者模式原理及示例分析 设计模式系列总览前言什么是中介者模式为什么需要中介者模式中介者模式示例中介者模式角色中介者模式和桥接模式的区别中介者模式在JDK源码中应用中介者模式应用场景中介者模式优缺点总结 设计模式系列总览 设计模式飞机票三大工厂模式登机入口策略模式登机入口委派模式登机入口模板方法模式登机入口观察者模式登机入口单例模式登机入口原型模式登机入口代理模式登机入口装饰者模式登机入口适配器模式登机入口建造者模式登机入口责任链模式登机入口享元模式登机入口组合模式登机入口门面模式登机入口桥接模式登机入口中介者模式登机入口迭代器模式登机入口状态模式登机入口解释器模式登机入口备忘录模式登机入口命令模式登机入口访问者模式登机入口软件设计7大原则和设计模式总结登机入口 前言 本文主要介绍中介者模式的原理，并会结合示例进行分析。中介者模式其实和桥接有点相似，桥接模式也是通过组合来实现的，但是中介者模式和桥接模式的侧重点不一样，接下来就让我们一起来看看中介者模式吧。
什么是中介者模式 中介者模式（Mediator Pattern）又称为调节者模式或者调停者模式，是用来降低多个对象和类之间的通信复杂性。
中介者模式中用一个中介对象封装一系列的对象交互，从而使各个对象不需要显示的相互作用，达到松耦合的目的，使得维护更加容易。当某些对象之间的作用发生改变时，不会立刻影响其他的一些对象之间的作用，保证了对象之间的相互作用可以独立的变化。
中介者模式属于行为型模式，其核心思想是通过中介者对象解耦各层次对象的直接耦合，层次对象的对外依赖通信全部交由中介者转发。
为什么需要中介者模式 假如现在有六个对象，对象与对象之间都需要互相调用，那么它们的关系就会如下图所示：
各个对象之间互相依赖，整个依赖关系形成了网状，关系错综复杂，非常难以管理。这时候如果引入一个中介者，每个对象都只和中介者交互，那么它们之间的关系就会如下图所示：
可以看到，所有的对象之间的关系都归中介者进行统一管理，避免了各个对象之间各自依赖的乱像。
其实在生活中也一样，比如飞机航线，假如有多驾飞机都需要走同一条航线，那么到底什么时候能走，谁先走就会是一个问题，如果各架飞机之间自己去协商，那么会非常复杂而且容易出错，所以这时候就需要有塔台来统一调度，而塔台扮演的角色就是中介者对象。
中介者模式示例 好了，装逼时刻又到了：Talk is cheap，Show you the code，先看一个非常简单的例子。
我们就以上面的航空塔台为例子来写一个示例：
1、首先建立一个抽象的 Plane 类，当然这里其实可以不用抽象类，为了方便功能扩展一般我们都是建议面向抽象编程：
package com.lonely.wolf.note.design.pattern.mediator; public abstract class AbstractPlane { protected AbstractMediator mediator; public AbstractPlane(AbstractMediator mediator) { this.mediator = mediator; } public abstract void fly(); } 注意这里面持有了一个抽象中介者对象的引用，稍后我们就会建立中介者对象
2、然后新建两个具体的 PlaneA 和 PlaneB 来继承抽象服务类：
package com.lonely.wolf.note.design.pattern.mediator; public class PlaneA extends AbstractPlane { public PlaneA(AbstractMediator mediator) { super(mediator); } @Override public void fly() { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a6b82ee224971aec2894b05c6e80599/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59f2c45da942a3cdf03b9d821b95fc9b/" rel="bookmark">
			Python努力学习笔记（第九课）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python小白学习 Python学习第九课1. 函数的返回值1.1 不写return语句和只写有一个return的时候，返回值是Nnoe1.2 函数内嵌套的return1.3 在函数体中，return后面的代码语句不在执行。 2. ⽂档字符串3. 函数的作⽤域4. 命名空间5. 递归函数 Python学习第九课 1. 函数的返回值 1.1 不写return语句和只写有一个return的时候，返回值是Nnoe def hax(*args): # print("haha",*args) def hmm1(): print(123) # return ["是不是",2,3] # return hmm1 if __name__ == '__main__': r = hax() print(r) 1.2 函数内嵌套的return def hax(*args): # print("haha",*args) def hmm1(): print(123) return ["是不是",2,3] return hmm1 if __name__ == '__main__': r = hax() print(r) 要拿到函数内嵌套的返回值直接写 print®肯定是拿不到的，因为返回的是hmm1（据说是这个函数在内存中的地址之类的东西，如果说错了大佬不要喷我😁），所以需要改下,写成：print(r())
1.3 在函数体中，return后面的代码语句不在执行。 2. ⽂档字符串 help()是Python中内置函数，通过help()函数可以查询Python中函数的⽤法
在定义函数时，可以在函数内部编写⽂档字符串，⽂档字符串就是对函数的
说明
查看函数的用法：
help() help(print) 框起来的就是print这个函数的用法说明，（我的英文不好，就不解释了）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59f2c45da942a3cdf03b9d821b95fc9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a8ab0a9a9ccc140102e3dcd92505a80/" rel="bookmark">
			GB9706.1-2007 标准检测项目详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GB9706.1-2007 标准检测项目详解
从本篇文章开始介绍一下GB9706.1-2007，虽然新的标准GB9706.1-2020已经出来，但距离正式实施还要一段时间，而且很多东西是可以通用的，所谓一通百通，好了，那么我们今天按照检测条款来进行解释。
关于GB9706.1-2007需要检测哪些测试项目，相信大家也都知道一个大概，如果你有看过你们公司产品的检测报告，那么会更加清楚，我也有专门把他用表格的形式列出来，感兴趣的或者想要了解的也可以去看一下我另外一篇文章，word版本也可以私聊我发。
后面我就以标准条款的序号来指代这条内容要求，大家有什么疑问也可以在话题讨论下留言或者进群讨论都可以。
第3.1条：这条几乎都符合，其实只要你的产品其它项尤其是关于漏电流的要求符合本标准的要求，那么这条都没有什么问题，一般也都直接判过，不用纠结。
第3.4条：如果你的产品用的材料或结构形式的安全证明方法是按照本标准进行的，那么这条便不适用；如果你的产品用的材料或结构形式的安全证明方法不是按照本标准进行的，那么这条适用，而且你需要证明你用的这些材料或者结构形式能够达到同等安全程度。
第5.1条：按照防电击的类型分类可以分为I类设备、II类设备、内部电源设备。先看定义
I类设备：对电击的防护不仅依靠基本绝缘，而且还有附加安全保护措施，把设备与供电装置中固定布线的保护接地导线连接起来，使可触及的金属部件即使在基本绝缘失效时也不会带电的设备。
通俗的讲，电源线为三个插脚（含地线）的为I类设备，电源线为两个插脚（不含地线）的为II类设备，见下图
II类设备：对电击的防护不仅依靠基本绝缘，而且还有如双重绝缘或加强绝缘那样的附加安全保护措施，但没有保护接地措施，也不依赖于安装条件的设备。
关于什么是基本绝缘、辅助绝缘、加强绝缘和双重绝缘我在另一篇文章中也用更为通俗易懂的方法为大家介绍了一下，感兴趣的朋友也可以去查看一下。
内部电源设备：电源置于设备内部，提供设备工作所需电能的设备。我们安装电池不连接供电网的都属于内部电源设备。
其实还有另外一类，那就是具有网电源连接装置的内部电源设备，这类设备需要双重分类，举个例子，在正常工作时使用内部电源供电，但设备上留有充电插口，在充电模式下需要链接网电源，那么这类设备就是内部电源设备+I类设备或者内部电源设备+II类设备。
第5.2条：按防电击的程度可以分为B型应用部分、BF型应用部分和CF型应用部分，这个也是厂家来声称，然后检测所根据厂家的声称来检测是否符合，比如我声称CF型，检测所检测后发现只能满足BF型要求那么就是不合格，如果改声称为BF型，那么这项就合格。具体什么是B型，什么是BF型，什么是CF型呢？一起来看下
应用部分：
如果没有应用部分那就既不属于B型也不属于BF、CF型，归到无分类-无应用部分。
如果有应用部分那么要么就是B型，要么就是BF型，要么就是CF型，只有这三种情况。
重要知识：
B 型：对电击有特定防护程度的设备，符合本标准要求，尤其是漏电流容许值要求，也就是只要带应用部分最低就要是B型。
BF型：有F型应用部分的B型设备，那么什么是F型应用部分呢？标准上是这么说的，与设备其他部分相隔离的应用部分，其绝缘达到，当来自外部的非预期电压与患者相连，并因此施加于应用部分与地之间时，流过其间的电流不超过单一故障状态时患者漏电流的容许值。
F型隔离是对应用部分而言的，也就是应用部分不仅与带电部件隔离绝缘，而且与地也应该隔离绝缘。F型应用部分不是BF型就是CF型。BF型应用部分对电击的防护能力和漏电流容许值均不低于B型应用部分，而且应用部分应该与其他带电电路和大地进行F型浮动隔离。
曾经有同事问如何判断B型和BF型呢？当然就是要判断产品是否有F型应用部分，另外一个简单的方法就是在应用部分施加一个242V电压，如果漏电流满足要求便可以声称为BF型。
CF型：直接用于心脏的设备或设备部件必须为CF型。CF型和BF型在结构上一致，但CF可以直接应用于心脏部位，BF型却不能，CF型的患者漏电流容许值为BF型的1/10。
虽然这个类型是厂家自己声称的，但是如果你没有F型应用部分你就只能声称为B型，如果你有F型应用部分那么你就必须声称为CF型或者BF型，当然声称前其实应该进行一个预测试的，如果满足CF型的漏电流容许值要求，那么你可以声称BF型也可以声称CF型；如果你有F型应用部分但你BF型的漏电流容许值要求都满足不了，显然这是一个不合格产品，需要整改。如果是用于心脏的设备或附件就必须是CF型的。
第5.3条：按GB4208中规定对今夜的防护程度进行分类，不防水的话可以写为IPX0，这个也比较常见了，用字母IP后接上X然后按照GB4208外壳对有害今夜防护程度来区分（1-9），
这个也是制造商自己声称的，当然也要预先试验，每个等级都有相对应的试验方法，见下图
第5.5条：
关于AP型和APG型定义也可以结合标准查看，如果不是AP型也不是APG型那么便是第一类，这类也最常见，比如我们的产品目前都属于这类。
第5.6条：按运行模式分类可以分为：连续运行、短时运行、间歇运行、短时加载连续运行和间歇加载连续运行等五类，若无特殊说明那么默认为连续运行。
下面结合一图来让大家能更清晰直观的了解一下这几个类型
这里面的间歇连续即为间歇加载连续运行，短时连续即为短时加载连续运行。
连续运行：额定负载下不超过规定温度限值。
短时运行：从冷态启动，在规定周期内和额定负载条件下，工作温度不超过规定值的运行，各运行周期的间歇时间相当长，足以使设备冷却到冷态。
间歇运行：由一系列规定的相同周期组成的运行状态，每一周期均包括一个温度极限不超过规定值的额定负载运行期和随后的设备空转或切断的间歇期。
短时加载连续运行：设备一直和电网相连接运行，规定的容许加载时间很短，以至不会达到长时间负载运行的温度，而随后的间歇时间足够长，使设备冷却到长时间空载运行的温度。
间歇加载连续运行：设备一直和电网相连接运行，规定的容许和加载时间很短，以致不会达到长时间负载运行的温度；而随后的间歇时间又不够长到使设备冷却到长时间空载运行的温度。
检测所会根据厂家的声称进行超温检测。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8eb13c2db6c63ee0f97833f1c77ad91/" rel="bookmark">
			C语言占位符 格式占位符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常用占位符： %d, %i------代表整数，%f------浮点数，%s------字符串，%c------char. %p------指针，%fL------长log，%e------科学计数法，%g------小数或科学计数法。
C语言中的格式占位符： %a,%A 读入一个浮点值(仅C99有效)
%c 读入一个字符
%d 读入十进制整数
%i 读入十进制，八进制，十六进制整数
%o 读入八进制整数
%x,%X 读入十六进制整数
%s 读入一个字符串，遇空格、制表符或换行符结束。
%f,%F,%e,%E,%g,%G 用来输入实数，可以用小数形式或指数形式输入。
%p 读入一个指针
%u 读入一个无符号十进制整数
%n 至此已读入值的等价字符数
%[] 扫描字符集合
%% 读%符号
数据类型和占位符之间的对应关系 char和unsingned char %c
short %hd
unsigned short %hu
long %ld
unsigned long %lu
int %d
unsigned int %u
float %f/%g
double %lf/%lg
%f和%lf会保留小数点后面多余的0 如 3.1400000 .2%f得 3.14
%g和%lg不会保留 如 3.14
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d43b9c7ee5830cf0f116a6d4766c319/" rel="bookmark">
			微信公众号自动回复小白入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信公众号自动回复 被关注回复关键词回复收到消息回复 登录进入自己的供公众号后
点击 功能下的自动回复
被关注回复 被关注回复是 用户关注公众号后收到的消息
这里选择文字
效果
&lt;a href="xxxx/"&gt;点这里获取最新资源&lt;/a&gt;这里功能和h5的超链接一样。
关键词回复 选择添加回复
在设置好基本信息后点击回复内容
这里我选择文字消息；
规则名称：随意，建议写与内容相关的。
匹配方方式，这里我选择半角匹配
全匹配是指你设置关键词的时候，需要用户准确的输入这个关键词才有回复。比如你设置了一个“你好”，然后用户在公众号里发出“你好”，才能得到你设置关键词的回复，但是当用户发出“你”或“好”，是没有回复的
半匹配则是指你设置关键词的时候，用户输入的内容包含这个关键词的时候，你设置的关键词回复便会被触发，从而发信息给用户。比如你设置一个“领取奖品”，那用户发出“领取”或者“奖品”就可以得到回复
点击回复内容后，我选择文字消息
在编辑完消息后保存即可。
效果
收到消息回复 收到消息回复 是用户输入非关键字后的回复
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b5899c428379959334bed5251bd2174/" rel="bookmark">
			CSS在不影响总体布局情况下让元素自由缩小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSS在不影响总体布局情况下让元素自由缩小 开始状态 &lt;body&gt; &lt;div class="box1"&gt;box1box1&lt;/div&gt; &lt;div class="box2"&gt;box2box2&lt;/div&gt; &lt;div class="box3"&gt;box3box3&lt;/div&gt; &lt;div class="box4"&gt;box4box4&lt;/div&gt; &lt;div class="box5"&gt;box5box5&lt;/div&gt; &lt;/body&gt; &lt;style&gt; .box1{ height: 100px; background-color: red; } .box2{ height: 100px; background-color: blue; } .box3{ height: 100px; background-color: green; } .box4{ height: 100px; background-color: gray; } .box5{ height: 100px; background-color: rgb(233, 30, 206); } &lt;/style&gt; 效果 要求 此时，如果要将class = "box2"的div元素高度由100px变化成50px,而不对总体布局产生变化，即如图
但是如果这里单纯地让box2的height变为50px,如
.box2{ height: 50px; background-color: blue; } 会得到下图所示效果，此时box2高度的变化会影响box3 4 5的整体布局
要解决这个问题，可以在class = "box2"的div元素外加一层div元素盒子，把box2的div元素包含在内，然后把该盒子的大小设定为固定值，这样，改变box2的高度就不会对box3 4 5产生变化，具体实现如下。
&lt;body&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b5899c428379959334bed5251bd2174/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/216fe379dd60b4dd3192e456e45d3441/" rel="bookmark">
			安装ubuntu出现Minimal BASH-like line editingis supported.解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个误操作，ubuntu系统崩了，重装一次，但是这次没有之前那么幸运，重启之后进入系统就出现以下错误
Minimal BASH-like line editing is supported.For the first word.TAB lists possible command completions.Anywhere else TAB lists possible device or file completions.
grub&gt;
这个错误主要原因是引导出错，需要修复。为了不出错，先进bios关闭uefi，
下面是解决方案：
1.临时进入方法 出现这个问题并不是引导丢失，只是出现了错误
先使用ls命令，找到Ubuntu的安装在哪个分区： grub&gt;ls 会罗列所有的磁盘分区信息，比方说：(hd0,gpt1),(hd0,gpt5),(hd1,gpt3),(hd1,gpt2)
然后依次调用如下命令： X表示各个分区号码
如果/boot没有单独分区，用以下命令： ls (hd0,gptX)/boot/grub 如果/boot单独分区，则用下列命令：
ls （hd0,gptX)/grub 这里需要一个一个分区的测试，如果出现unknow file 表示这个不是，换下一个，直到出现列出来几百个文件，很多文件的扩展名是.mod和.lst和.img，还有一个文件是grub.cfg。假设找到（hd0,gpt5）时，显示了文件夹中的文件，则表示Linux安装在这个分区。
3. 如果找到了正确的grub目录，则设法临时性将grub的两部分关联起来，方法如下：
grub&gt;set root=(hd0,gpt5) grub&gt;set prefix=(hd0,gpt5)/boot/grub 然后调用如下命令，就可以显示出丢失的grub菜单了。
grub&gt;normal 然后会出来启动的图形界面，点击进入Linux中，对grub进行修复。
参考这篇博客：https://blog.csdn.net/wzz678678/article/details/80644181?utm_medium=distribute.wap_relevant.none-task-blog-title-3
但是我用这篇博客的后续方法安装grub会出错，无奈只好找其他方法
2. 永久修复方法 在方法1的基础上，进入系统后继续操作，先联网
参考博客：https://blog.51cto.com/zgw285763054/1815208
打开Terminal,安装boot repair软件。输入:
sudo add-apt-repository ppa:yannubuntu/boot-repair sudo apt-get update sudo apt-get install boot-repair 再开一个终端，输入
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/216fe379dd60b4dd3192e456e45d3441/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d037e6fd6aad97571f0ae3912ce84ec/" rel="bookmark">
			03线索二叉树_ThreadBinaryTree
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;math.h&gt; #define OK 1 #define ERROR 0 #define TRUE 1 #define FALSE 0 #define MAXSIZE 100 /* 存储空间初始分配量 */ typedef int Status;	/* Status是函数的类型,其值是函数结果状态代码,如OK等 */ typedef char TElemType; typedef enum {Link,Thread} PointerTag;	/* Link==0表示指向左右孩子指针, */ /* Thread==1表示指向前驱或后继的线索 */ typedef struct BiThrNode	/* 二叉线索存储结点结构 */ { TElemType data;	/* 结点数据 */ struct BiThrNode *lchild, *rchild;	/* 左右孩子指针 */ PointerTag LTag; PointerTag RTag;	/* 左右标志 */ } BiThrNode, *BiThrTree; TElemType Nil='#'; /* 字符型以空格符为空 */ Status visit(TElemType e) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d037e6fd6aad97571f0ae3912ce84ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86ae5835e50a47fe6d733fa24f78b2f8/" rel="bookmark">
			Linux中容易忽略的文件寻址问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、Linux文件的寻址1.概念一2.概念二 二、文件寻址命令1.pwd2.cd3.ls 总结 前言 这次要讲的是Linux中关于文件管理的一些知识，对于Linux的初学者，我想这篇博客会提供给你一些有用的帮助。当然，大佬就可以没必要再读了，由于本人尚处于学习阶段，可能有些地方写的不够严谨，甚至会出现一些错误，所以有不够完善的地方敬请留言批评改正。
一、Linux文件的寻址 1.概念一 首先明确一下概念，Linux中的所有东西本质上都是文件，包括指令，程序运行进程，记录的数据，图形界面等。而这些文件则根据其不同的类别保存在系统不同的目录之下，打开Linux图形界面，我们可以看到系统的二级目录如下所示：
/bin，/sbin，/dev，/home，/root，/lib64，/lib，/proc，/run，/srv，/var，/tmp，/mnt，/media，/etc，/opt，/boot，/sys，/usr。
下表是每个目录下的文件类型及作用：
/Linux顶级目录 (注意：rm -fr /* 命令一定不能在服务器上运行，否则就相当于杀死服务器。）/bin二进制可执行文件，系统常规命令（比如touch，file，date等常见指令的文件信息都可在此目录中找到）/sbin系统管理命令，一般只有root可以执行/dev系统设备管理文件/home普通用户家目录集合，此目录中的子目录为普通用户家目录/root超级用户家目录/lib6464位函数库/lib系统函数库/proc系统硬件信息和系统进程信息/run当前运行的硬件和系统模块/srv系统数据目录（常量）/var系统数据目录（变量）/tmp系统临时文件存放目录/mnt临时设备挂载点（例如u盘插入可称为挂载，u盘弹出可称为卸载）/mediacdrom临时挂载点/etc大多数系统配置文件存放路径/opt第三方软件安装路径/boot启动目录，存放系统自动启动文件，内核，初始化程序/sys关于内核设定目录/usr用户相关信息数据，仅次于/ 重要，多数系统资源都在此目录中 如下图所示：
2.概念二 同样重要的两个概念：
绝对路径：文件在系统中的真实位置，在任何场景下都可以使用，通常以/开头，不会考虑当前系统位置。
比如，普通用户westos下桌面上的file文件的绝对路径可写为：/home/westos/Desktop/file
相对路径：绝对路径的简写，省略了用户当前所在的系统位置，此名称只有在管理当前所在系统目录中子文件时才能使用。系统中不以/开头的文件名称都为相对路径，在程序操作时会自动识别当前路径的信息并关联操作目标。
例如想要在普通用户westos的桌面下创建文件file，可直接用指令touch file完成创建。因为当前的工作目录即为/home/westos/Desktop
在上图中，file就是相对路径，/home/westos/Desktop/file就是file文件的绝对路径，因通过两个路径均能打开file文件进行编辑。
二、文件寻址命令 1.pwd 该指令用于查看当前的工作目录
普通用户下查看当前的工作目录：
超级用户下查看当前的工作目录：
2.cd 切换当前的工作目录
’~‘ ##默认代表当前用户家目录
’~username’ ##指定的用户家目录
“~+”="." ##当前目录
‘~-’ ##当前目录之前所在目录
‘. .’ ##当前目录的上级目录
其中"cd ~-"=“cd -”
注意：当使用~username切换指定用户的家目录时需要用超级用户执行，普通用户不具有该权限。而切换到指定目录时需要执行“cd -指定的目录”（这个是我实验得出来的结论，可能会有问题）
3.ls 用于显示文件信息
ls #显示当前目录中文件的名称
ls file #显示指定文件名称
ls dir #显示指定目录中内容的名称
ls -d dir #显示目录本身的名称
ls -l file #显示文件属性
ls -l dir #显示目录中内容的属性
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86ae5835e50a47fe6d733fa24f78b2f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee804d1e93ef2cc5969c8a739daf7282/" rel="bookmark">
			C&#43;&#43; | 类型转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		const_cast：去掉变量的const，使其有只读变为可读写
可对常量指针、常量引用、常量对象使用
const int a = 10; int b = const_cast&lt;int&gt;(a); static_cast：编译时完成
1)基本类型之间的转换(char、int、enum、float等)
2)父子类对象之间的转换：没有动态类型检查，在父类对象转换成子类对象时不安全
3)转换时不能去掉变量的修饰符：const、volatile....
int a = 1; double b = static&lt;double&gt;(a); //ok class A{}; class B : public A{}; class C{}; A* aa = new A(); B* bb = static_cast&lt;A&gt;(bb); // ok C* cc = static_cast&lt;C&gt;(aa); // error, A和C无派生关系 dynamic_cast：转换若成功，返回的是指向类的指针或引用；若失败则会返回NULL
1)用于父子对象之间的转换，运行时完成，具有动态类型检查
2)不能进行基本类型之间的转换
3)基类必须包含有虚函数：类中存在虚函数，就说明它有想要让基类指针或引用指向派生类对象的必要，此时转换才有意义；由于运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表中，只有定义了虚函数的类才有虚函数表
4)在由子类对象转换成父类对象(上行)时static_cast和dynamic_cast是一样的；当进行下行转换时dynamic_cast具有动态类型检查更安全
class A{}; class B : public A{}; A *a = new A(); B *b = dynamic_cast&lt;B*&gt;(a); // error,A中不存在虚函数 class A { public: virtual void f() { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee804d1e93ef2cc5969c8a739daf7282/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7c4848655b2a4a23b653c4a3ab35721/" rel="bookmark">
			第3天 C语言的数据类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本数据类型的取值范围 char -128 ~ +127 (1 Byte)
short -32767 ~ + 32768 (2 Bytes)
unsigned short 0 ~ 65536 (2 Bytes)
int -2147483648 ~ +2147483647 (4 Bytes)
unsigned int 0 ~ 4294967295 (4 Bytes)
long == int
long long -9223372036854775808 ~ +9223372036854775807 (8 Bytes)
double 1.7 * 10^308 (8 Bytes)
unsigned int 0～4294967295
long long的最大值：9223372036854775807
long long的最小值：-9223372036854775808
unsigned long long的最大值：1844674407370955161
__int64的最大值：9223372036854775807
__int64的最小值：-9223372036854775808
unsigned __int64的最大值：18446744073709551615
char类型 char类型用于存储字母和标点符号之类的字符。但是技术实现上char却是整数类型。
这是因为char类型实际存储的是数字而不是字符。为了处理字符，计算机使用一种数字编码，用特定的整数表示特定的字符。
c把一个字节（byte）定义为char类型使用的位（bit）数。
int 类型 C提供多种整数类型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7c4848655b2a4a23b653c4a3ab35721/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fead0173f068de00bd7c52542b9f8177/" rel="bookmark">
			ThinkPHP 百度编辑器富文本过滤XSS攻击实例操作！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备：1，下载Htmlpurifier 2，在公共函数写一个方法！
一、下载：Htmlpurifier，下载的网址是：http://htmlpurifier.org/
放在根目录就行了
二、在 function.php 方法中
function removeXSS($data)
{
require_once './HtmlPurifier/HTMLPurifier.auto.php';
$_clean_xss_config = HTMLPurifier_Config::createDefault();
$_clean_xss_config-&gt;set('Core.Encoding', 'UTF-8');
// 保留的标签
$_clean_xss_config-&gt;set('HTML.Allowed', 'div,b,strong,i,em,a[href|title],ul,ol,li,p[style],br,span[style],img[width|height|alt|src]');
$_clean_xss_config-&gt;set('CSS.AllowedProperties', 'font,font-size,font-weight,font-style,font-family,text-decoration,padding-left,color,background-color,text-align');
$_clean_xss_config-&gt;set('HTML.TargetBlank', TRUE);
$_clean_xss_obj = new HTMLPurifier($_clean_xss_config);
return $_clean_xss_obj-&gt;purify($data);
}
三、直接使用
例如：
这样子就可以在富文本中过滤脚本的代码了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc0fa8f3d17d29e32c7743e0b544f6e6/" rel="bookmark">
			远程面试蚂蚁金服，三面之后本以为石沉大海，没想到却被直接录取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当前环境，很多公司都采取了远程办公，远程面试。有一说一，第一次远程面试，还是比较紧张的。
蚂蚁金服面试（视频一面） Java容器有哪些？哪些是同步容器,哪些是并发容器？为什么 Java 要采用垃圾回收机制，而不采用 C/C++的显式内存管理？一个线程的生命周期有哪几种状态？它们之间如何流转的？什么是活锁、饥饿、无锁、死锁？怎么检测一个线程是否拥有锁？如何解决同时存在的对象创建和对象回收问题说说一致性 Hash 原理新生代分为几个区？使用什么算法进行垃圾回收？为什么使用这个算法？HashMap在什么情况下会扩容，或者有哪些操作会导致扩容？HashMap检测到hash冲突后，将元素插入在链表的末尾还是开头？1.8还采用了红黑树，讲讲红黑树的特性，为什么大家一定要用红黑树而不是AVL、B树之类的？https和http区别，有没有用过其他安全传输手段？线程池的工作原理，几个重要参数，然后给了具体几个参数分析线程池会怎么做，最后问阻塞队列的作用是什么？RabbitMQ 上的一个 queue 中存放的 message 是否有数量限制？RabbitMQ 允许发送的 message 最大可达多大？有使用过哪些NoSQL数据库？MongoDB和Redis适用哪些场景？项目用 Spring 比较多，有没有了解 Spring 的原理？AOP 和 IOC 的原理 蚂蚁蚂蚁金服面试(视频二面） 查询中哪些情况不会使用索引？描述分布式事务之TCC服务设计？数据库索引，底层是怎样实现的，为什么要用B树索引？Mysql主从同步的实现原理？MySQL是怎么用B+树？谈谈数据库乐观锁与悲观锁?Redis和memcache有什么区别？Redis为什么比memcache有优势？Redis 的数据结构海量数据过滤，黑名单过滤一个 url。讲一讲AtomicInteger，为什么要用CAS而不是synchronized？ 蚂蚁金服三面（视频三面） 考虑redis的时候，有没有考虑容量？大概数据量会有多少？Redis 的 list zset 的底层实现分布式架构设计哪方面比较熟悉分布式 session 的共享方案有哪些，有什么优劣势谈谈分布式锁、以及分布式全局唯一ID的实现比较？集群监控的时候，重点需要关注哪些技术指标？这些指标如何优化？从千万的数据到亿级的数据，会面临哪些技术挑战？你的技术解决思路？排序算法的复杂度，快速排序非递归实现。消息中间件有哪些？他们之间的优劣势？介绍项目介绍你实践的性能优化案例，以及你的优化思路 视频面试之后，我总结了下，问的都不算难，虽然不是很顺畅，但问题也都回答上了，就是通过视频的形式来面试，总感觉怪怪的。本以为已经没戏了，谁知道2天后收到通知，竟然过了！现在正在考虑要不要辞职过去...
当然，大厂的面试，是一个系统规范化的流程，除了Redis、MQ这些必备品外，每一个简历都会有一句Java基础扎实（有没有被说中），那么，到底怎么样算Java基础扎实?
1、集合，例如 List、Map的原理，HashMap基本必问这个不用我多说
2、并发，例如线程、线程池，锁相关，这些也基本必问
3、JVM，例如垃圾回收器，垃圾回收算法，OOM处理，jvm参数及调优
上面说的这些，是最最最基本的面试标配了。
首先来说下对于简历的准备。MQ、Redis这两个是标配没跑的了。为啥？你要突出你的核心竞争力，无非围绕高并发、高可用、海量数据这几个点出发。
其次，核心竞争力也体现在分布式解决方案的真实落地实践，但是这些分布式解决方案，也很大程度上依赖 Redis和 MQ。
比如分布式session需要依赖 Redis，分布式事务最终一致性需要依赖 MQ。也就是说，一份优秀的简历，深入 Redis和 MQ这两个，都是避无可避！
以下主要分享面经和个人学习方法，会包括很多PDF文档，如面试题库（含答案+解析）、学习笔记、实战文档和脑图等等，如果您需要获取到文档，请转发一下本文，关注楼主，私信回复【干货】即可获得免费领取方式。
由于文章的篇幅有限，所以这次的阿里面试题答案整理在了PDF文档
如果简历上只是做的项目不同，但是实质都是简单的CRUD，那么没面试之前，已经给淘汰得差不多了。
通过数十家面试的观察，对于Redis和MQ，考察的方向，其实也是有迹可循的。首先他们的高可用是怎么保证的，原理是怎么样的，几乎必问（不信你可以自己观察）。当然还会根据你的回答往下继续拓展问题，每个人回答得不一样，自然拓展的问题也不一样。
以下我会分享一些我个人的学习文档，有需要的朋友自行选择获取：
“金三银四”Java社招开发必备-面试文档+简历修改+面试重点PDF免费获取方式​
转发一下本文，关注楼主，私信回复【干货】即可获得免费领取方式。
Java核心知识整理
Spring全家桶系列
性能优化（JVM+Tomcat+MySQL）答案解析整理
分布式（限流+缓存+通讯）答案解析整理：
刷题：
既然是要面试，那么就少不了刷题，实际上春节回家后，哪儿也去不了，我自己是刷了不少面试题的，所以在面试过程中才能够做到心中有数，基本上会清楚面试过程中会问到哪些知识点，高频题又有哪些，所以刷题是面试前期准备过程中非常重要的一点。
很多人感叹“学习无用”，实际上之所以产生无用论，是因为自己想要的与自己所学的匹配不上，这也就意味着自己学得远远不够。无论是学习还是工作，都应该有主动性，所以如果拥有大厂梦，那么就要自己努力去实现它。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/060f1dcef9bee11be2003a42f6e55c70/" rel="bookmark">
			vs2017环境下创建Qt的dll文件以及配置调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vs2017环境下创建Qt的dll文件以及配置调用 首先新建项目-》选择Qt Class Library
选上Core、GUI、Widgets
点击下一步，点击Finishi
新建项，选择Add Qt…
选择Qt Widget Class，之后一路默认创建
此时会生成Form Files文件：
右键Form Files新建项
添加Qt Widget Form File，注意文件名称应为你需要导出的类同名
上图提到的类名如下图（这里其他无关的.h、.cpp和.ui被移除了，其实不移除应该也没影响）
这里随便定义了一个函数并给出实现
编译.ui文件
这时如果是vs2017环境的话，可以在QtClassLibrary_test_2\x64\Debug\uic目录下找到如下文件（QtClassLibrary_test_2是我的项目名）:
（vs2019的，可以在生成的Genetate文件夹中找到）
在项目.h文件中加上#include"ui_QtClassLibrary_test_2.h"，即上一步生成的.h文件
打开.ui文件
打开将对象名改为你需要导出的类名
上图中提到的类名如下图所示
生成项目
会在对应目录下看到生成的dll和lib文件
然后将生成的.lib和.dll文件复制到你新建的项目对应目录下：
把如图两个.h文件也复制到你新建的项目对应 目录下
再把前面生成的ui_QtClassLibrary_test_2.h导入与上图同一目录中
打开项目属性：
1.连接器-》常规-》附加库目录-》之前导入该项目的lib所在文件夹：
2.链接器-》输入-》附加依赖项-》添加导入的.lib文件名：
在程序中添加红框中的代码：
运行程序，出现下图所示则配置和调用成功：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27417b9677765806f2b3e7e373aca165/" rel="bookmark">
			Jsoup解析HTML时，明明获取到html页面信息却无法解析到数据（已解决）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.解决方式： 修改获取html页面时候的 user-agent 参数
删除掉里面的 Chrome/25.0.1364.160 Safari/537.22这两个即可
2.原因： 起因是今天有点不太想学别的了，就打算写写爬虫啥的，放松放松，然后就遇到了这个问题：
我明明获取到html的页面了，也获取到html所有的信息了，但是jsoup就是解析不到数据
测试代码长这样：
@Test public void test() throws IOException { String url = "https://tieba.baidu.com/f?kw=%E5%8F%A4%E9%A3%8E&amp;ie=utf-8&amp;tab=good&amp;cid=3"; String html = HttpClientUtil.execute(url, true); System.out.println(html); System.out.println("============"); Document parse = Jsoup.parse(html, url); Elements select = parse.select("a.j_th_tit"); for (Element element : select) { System.out.println(element.attr("abs:href")); } } 结果是这样的：
我这次使用的是HttpClient去获取html页面信息，然后使用jsoup去解析。看到能够获取到正确的html页面也就没有往那边去想，而是开始检查我的jsoup代码。
结果问题就出在Httpclient的代码中
先看之前的配置信息：
#请求头配置文件 User-Agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64; zh-CN; rv:1.9.2.15) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.121 Safari/537.36 Accept-Encoding=gzip Accept=text/html Accept-Language=zh-CN,zh 之前我傻乎乎的就和python爬虫一样直接把谷歌浏览器的用户代理直接写上去了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27417b9677765806f2b3e7e373aca165/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e261ae09f6c1c988d23712816c95184/" rel="bookmark">
			相机相关参数及视野计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		传感器尺寸一般以毫米为单位，是靶面的长和宽。以英尺为单位的一般为靶面的斜边长。 像素尺寸是一个像素占的尺寸大小。像素尺寸和图像边长的乘积为传感器的边长。如下图，像素长为2.5um，长共5120个像素，则传感器长为0.0025 * 5120=12.8mm 以下列参数为例：
视野范围计算：
公式： 视野范围FOV ( H or V)＝工作距离(WD) × 靶面尺寸( H or V) / 焦距f
若用以上相机，假设镜头焦距为200mm,工作距离为500m，则视野范围为：500000 * 12.8/200=32000m即32m的边长。
若标志物边长1m，则占5120 * 1/32=160个像素。
比例因子计算：
SF=D像素尺寸/f焦距=500000 * 0.0025/200=6.25 mm/pixel
已知iPhone8plus的像素尺寸为1.2um,靶面尺寸长为6.29mm，焦距为28，相片分辨率为40323024，求相同比例因子下的工作距离。
6.25=D * 0.0012/28
解得D=145.833m
则 视野=145833 * 6.29/28=32760mm=32m，标志物长0.3m,则占4032 * 0.3/32=37.8个像素。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbb32c750d929f99b82338ba62feac29/" rel="bookmark">
			Kubernetes二进制部署（多节点）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 实验环境实验过程部署master02节点部署nginx负载均衡集群 实验故障 实验环境 角色分配：
主机名 IP地址 安装软件包 Master01：14.0.0.50 kube-apiserver kube-controller-manager kube-scheduler etcd Master02：14.0.0.80 kube-apiserver kube-controller-manager kube-scheduler Node01： 14.0.0.60 kubelet kube-proxy docker flannel etcd Node02： 14.0.0.70 kubelet kube-proxy docker flannel etcd Nginx01+keepalived：14.0.0.90 nginx、keepalived Nginx02+keepalived：14.0.0.100 nginx、keepalived 实验过程 在部署完单节点集群后，继续部署多节点，前面的操作可以参考上一篇博客：
https://blog.csdn.net/chengu04/article/details/108899870
部署master02节点 1.关闭防火墙，关闭核心防护，关闭网络管理功能（生成环境中一定要关闭它） [root@localhost ~]# hostnamectl set-hostname master02	#修改主机名 [root@localhost ~]# su [root@master02 ~]# systemctl stop firewalld	#关闭防火墙 [root@master02 ~]# setenforce 0 &amp;&amp; sed -i "s/SELINUX=enforcing/SELNIUX=disabled/g" /etc/selinux/config	#关闭核心防护 [root@master02 ~]# systemctl stop NetworkManager &amp;&amp; systemctl disable NetworkManager #关闭网络管理功能 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbb32c750d929f99b82338ba62feac29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f86b2a01e964e264366a421b99f0965/" rel="bookmark">
			ASP.NET MVC预览4-使用Ajax和Ajax.Form
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ASP.NET MVC Preview 4 is up on CodePlex. The Gu has all the exquisite Gu-Like Detail on his blog. Phil Haack has some notes on this release on his blog. ASP.NET MVC Preview 4在CodePlex上可用。 顾先生在他的博客上拥有所有精美的“赞似细节” 。 菲尔·哈克(Phil Haack)在他的博客上对此发布有一些注释。
If you take a look at the generated "changes" document, it shows a bunch of new stuff like AjaxHelpers and AjaxExtensions that set the stage for some interesting things the community could do with ASP.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f86b2a01e964e264366a421b99f0965/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8fbe57a01069d2d9134797f133b8f55/" rel="bookmark">
			路由器玩机---老毛子设置AP与主路由设置(2)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		国庆假期再玩老毛子固件，之前AP设置成功了，但有点 不方便的就是，操作模式设置为无线接入点AP之后，想登陆路由器后台管理界面很不方便，因为IP变化了。需要从上级路由再找AP才能登陆到管理界面。
但今天偶然发现，记录一下。设置AP后不需要切换操作模式，就能实现桥接。方便了许多，记录一下。
1.登录到路由器管理界面 跟之前的区别是使用WAN ISP，点击应用本页面设置。
2. 测试网络 我这里使用LAN口直连PC，因此是禁用了AP, 经测试已经能够上网了，而且无需更改操作模式至AP。因此还是之前的管理页面IP。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2e28eb48023e93ab3b450837ca5bdc0/" rel="bookmark">
			编译原理——确定有穷自动机的化简-分割法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 3.4.4 确定有穷自动机的化简1.化简的有穷自动机的定义2.分割法3.The End 3.4.4 确定有穷自动机的化简 1.化简的有穷自动机的定义 一个没有多余状态并且没有两个状态是等价的有穷自动机。
多余状态（无用状态）：从该自动机的开始状态出发，任何输入串也不能到达的那个状态
等价状态：
两个状态必须同时为可接受状态（终态）或者不可接受状态（非终态）——一致性条件对于所有的输入符号，两个状态接受相同的符号必须转换到等价的状态——蔓延性条件 2.分割法 我们首先将其分为终态和非终态
P 0 P_0 P0​ = ({1, 2, 3, 4}, {5, 6, 7})
接下来我们尝试先对{1, 2, 3, 4}这个子集进行划分
1 ⟶ a 6 1\stackrel{a}{\longrightarrow}6 1⟶a​6； 1 ⟶ b 3 1\stackrel{b}{\longrightarrow}3 1⟶b​3
2 ⟶ a 7 2\stackrel{a}{\longrightarrow}7 2⟶a​7； 2 ⟶ b 3 2\stackrel{b}{\longrightarrow}3 2⟶b​3
3 ⟶ a 1 3\stackrel{a}{\longrightarrow}1 3⟶a​1； 3 ⟶ b 5 3\stackrel{b}{\longrightarrow}5 3⟶b​5
4 ⟶ a 4 4\stackrel{a}{\longrightarrow}4 4⟶a​4； 4 ⟶ b 6 4\stackrel{b}{\longrightarrow}6 4⟶b​6
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2e28eb48023e93ab3b450837ca5bdc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5229f9bb4e3ac47ceb1c7311bbbf8579/" rel="bookmark">
			Thymeleaf 介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Thymeleaf 介绍
Thymeleaf是一款用于渲染XML/XHTML/HTML5内容的模板引擎。类似JSP，Velocity，FreeMaker等，它也可以轻易的与Spring MVC等Web框架进行集成作为Web应用的模板引擎。与其它模板引擎相比，Thymeleaf最大的特点是能够直接在浏览器中打开并正确显示模板页面，而不需要启动整个Web应用。 Thymeleaf是与众不同的，因为它使用了自然的模板技术。这意味着Thymeleaf的模板语法并不会破坏文档的结构，模板依旧是有效的XML文档。模板还可以用作工作原型，Thymeleaf会在运行期替换掉静态值。Velocity与FreeMarker则是连续的文本处理器。 下面的代码示例分别使用Velocity、FreeMarker与Thymeleaf打印出一条消息： Velocity: m e s s a g e &lt; / p &gt; F r e e M a r k e r : &lt; p &gt; message&lt;/p&gt; FreeMarker: &lt;p&gt; message&lt;/p&gt;FreeMarker:&lt;p&gt;{message}
Thymeleaf: Hello World!
注意，由于Thymeleaf使用了XML DOM解析器，因此它并不适合于处理大规模的XML文件。 二、引用方式
（1）添加maven依赖
org.springframework.boot spring-boot-starter-thymeleaf （2）引入模版 （3）文件配置 spring:
thymeleaf:
cache: false #关闭缓存
prefix: classpath:/views/ #添加路径前缀
三、基础语法
（1）变量表达式${}
使用方法：直接使用th:xx = “${}” 获取对象属性 。例如：
（2）选择变量表达式*{} 使用方法：首先通过th:object 获取对象，然后使用th:xx = "*{}"获取对象属性。这种简写风格极为清爽，推荐大家在实际项目中使用。 例如： （3）链接表达式@{} 使用方法：通过链接表达式@{}直接拿到应用路径，然后拼接静态资源路径。例如： （4）片段表达式 ~{} 片段表达式是Thymeleaf的特色之一，细粒度可以达到标签级别，这是JSP无法做到的。片段表达式拥有三种语法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5229f9bb4e3ac47ceb1c7311bbbf8579/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e79abd1a8b7f5ad30dd07bf84be73ea3/" rel="bookmark">
			CSS和HTML的基础知识复习，特别是html页面缩放不影响布局，第13点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近写了一个网站遇到的问题及其解决的方法： ① CSS对界面进行初始化的代码，重置布局 * { padding: 0px; margin: 0px; } ② 对div背景和字体设置颜色（有时候犯糊涂）： /* 对字体设置颜色 */ color:#000000; /* 对背景设置颜色 */ background-color:blue; ③ 绝对定位 absulote /* 绝对定位的图片或者是背景规则是： div的区域内以左上角的定位为基准 */ position:absulote; 以下是在图片上添加一层模糊背景色（黑色），为了测试设置的大小与图片不同 ④ z-index属性的使用，代表2个或者2个以上有层叠的时候，优先级（z-index的值越大）越高，谁就显示在层叠的最上面 ⑤ 关于top，margin-top 的区别： top是相对于body（真个最大的div，整个界面）而言的。right,bottom,left也是一样。margin-top是针对当前位置的移动，margin-left,margin-right,margin-bottom也是一样 ⑥ 关于margin-top,margin-left,margin-right,margin-bottom，值为负数的时候的含义 margin-top = 2px表示，元素当前位置离当前div上方的距离是2px，margin-top = -2px,表示元素往上移动2px的距离margin-left = -3px,表示元素向左移动3px的距离，同理另外两种情况同上 ⑦ 关于两个div重叠 使用对整个body设置位置的top,left,right,bottom等对元素镇通过整体进行绝对定位然后对当前元素的位置再通过margin-top等进行定位 ⑧ 关于清除浮动 为什么要清除浮动呢？因为临近的div的布局会影响到下一个布局，清除之前的div的布局，重新设置下一个div的布局
直接在css中.clear{clear:both}，清除浮动 ⑨ 当有相同的元素需要设置时候，可以采用这种方式 *** + .common就可以了 ⑩ 当字标签的元素有重复的设置时候，在父标签中设置即可 11. 关于列表dl ,dt , dd 12. 一些符号的引用，列入商标，版权等 13. html页面缩放但是不影响布局 这个我在复习前端界面的时候遇到的，希望对大家有帮助。如有异议，欢迎留言交流！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9662ac625a3de05b941c3812ddae0741/" rel="bookmark">
			shell脚本实例-实现自动发布到不同的环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#!/bin/bash
#publish80.sh dev make #publish80.sh uat make #publish80.sh dev_uat
if [ $# -ne 1 -a $# -ne 2 ]; then
echo " this shell need a param like dev uat dev_uat &amp; make ..."
exit -1
fi
if [ $# -eq 2 ]; then
make=$2
if [ "$make"x = "make"x ]; then
tmpx=`date +%Y%m%d%H%M%S`
fileName="workapp-"$tmpx".bak"
cp -r ../workapp ../bak/$fileName
svn update $APPHOME/src/
svn update $APPHOME/etc/
svn update $APPHOME/sbin/
#svn update $APPHOME/java/
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9662ac625a3de05b941c3812ddae0741/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5917aca69aa3d92ce2924eebd19193c/" rel="bookmark">
			Docker 容器添加中文字体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统里有一个需要在图片上画中文的功能，在测试环境是 ok 的，一到线上 Docker 容器环境中文就不显示了，查了一些资料说是缺少中文字体，那我们就来安装中文字体吧。
1. 查看当前使用的系统语言： $ echo $LANG en_US.UTF-8 en_US.UTF-8 是支持中文编码的，所以并不需要去安装中文编码的支持。
2. 查看已经安装的中文字体 $ fc-list :lang=zh 如果这一步提示命令不存在，说明没有安装字体软件，执行下面的命令进行安装：
yum -y install fontconfig 3. 安装字体 Linux 字体目录是：/usr/share/fonts，
只要将字体文件放入这个目录就可以了，
Mac 上通过「字体册」就可以找到具体的字体：
在 Dockerfile 中加入：
yum -y install fontconfig COPY Songti.ttc /usr/share/fonts/ RUN fc-cache -vf fontconfig 是字体软件，然后重新构建镜像并部署新的镜像，进入容器里执行：
fc-list :lang=zh 这个时候就可以看到已经安装好的中文字体了，然后我再看那个「图片上画中文」的功能也 ok 了。当时这个问题困扰了我两天，其实还是对 Linux 和 Docker 容器不太熟悉吧，感叹书到用时方恨少。
参考：
给Docker镜像(Debian)添加中文支持和中文字体
Linux设置显示中文和字体
docker容器安装宋体
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/043ecfb4cc9c368151de7c4e5e7b6075/" rel="bookmark">
			Vue中Echarts地图&#43;散点图,并且通过WebSocket即时通讯更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先看下效果图
先看下后台返回的数据结构是什么样子的
[ { "name":"黄金用户", "children":[ { "name":"武汉", "value":[114.31,30.52] }, { "name":"丹东", "value":[124.31,40.52] }, { "name":"张家口", "value":[114.81,40.13] }, { "name":"深圳", "value":[114.07,22.52] } ] }, { "name":"白金用户", "children":[ { "name":"金华", "value":[119.31,29.52] }, { "name":"西安", "value":[108.31,34.52] } ] }, { "name":"钻石用户", "children":[ { "name":"成都", "value":[104.31,30.52] } ] } ] 好了，开始实现前端的代码
html
&lt;div class="com-page"&gt; &lt;div class="com-container" @dblclick="revertMap"&gt; &lt;div class="com-chart" ref="map_ref"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; css
html,body,#app{ width: 100%; height: 100%; padding: 0; margin: 0; overflow: hidden; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/043ecfb4cc9c368151de7c4e5e7b6075/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4477c7c80fff2226567adc7843c3dc6/" rel="bookmark">
			【前端面试】Vue 你的接口请求一般放在哪个生命周期中？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue你的接口请求一般放在哪个生命周期中？ 可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。
但是推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：
能更快获取到服务端数据，减少页面loading 时间；
ssr不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b75fad8df14b7359243f43231b66102/" rel="bookmark">
			vue&#43;element动态生成可折叠表格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近看到很多人问怎么样做多层可折叠表格，其实vue+element是很简单实现的，就是数据结构的问题，
使用element table组件的树形数据与懒加载，实现代码如下(主要是数据的处理，跟后端同事协调好返回的数据结构，或者前端做数据处理都是可以的)
&lt;template&gt; &lt;div&gt; &lt;el-table :data="tableData" style="width: 100%;margin-bottom: 20px;" row-key="id" border default-expand-all :tree-props="{children: 'children', hasChildren: 'hasChildren'}"&gt; &lt;el-table-column prop="date" label="日期" sortable width="180"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="name" label="姓名" sortable width="180"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="address" label="地址"&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;el-table :data="tableData1" style="width: 100%" row-key="id" border lazy :load="load" :tree-props="{children: 'children', hasChildren: 'hasChildren'}"&gt; &lt;el-table-column prop="date" label="日期" width="180"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="name" label="姓名" width="180"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="address" label="地址"&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { tableData: [{ id: 1, date: '2016-05-02', name: '王小虎', address: '上海市普陀区金沙江路 1518 弄', children: [{ id: 11, date: '2016-05-01', name: '王小虎', address: '上海市普陀区金沙江路 1519 弄', children: [{ id: 111, date: '2016-05-01', name: '王小虎', address: '上海市普陀区金沙江路 1519 弄' }, { id: 112, date: '2016-05-01', name: '王小虎', address: '上海市普陀区金沙江路 1519 弄' }] }, { id: 12, date: '2016-05-01', name: '王小虎', address: '上海市普陀区金沙江路 1519 弄' }] }, { id: 2, date: '2016-05-04', name: '王小虎', address: '上海市普陀区金沙江路 1517 弄', children: [{ id: 21, date: '2016-05-01', name: '王小虎', address: '上海市普陀区金沙江路 1519 弄', children: [{ id: 211, date: '2016-05-01', name: '王小虎', address: '上海市普陀区金沙江路 1519 弄' }, { id: 212, date: '2016-05-01', name: '王小虎', address: '上海市普陀区金沙江路 1519 弄' }] }, { id: 22, date: '2016-05-01', name: '王小虎', address: '上海市普陀区金沙江路 1519 弄' }] }, { id: 3, date: '2016-05-01', name: '王小虎', address: '上海市普陀区金沙江路 1519 弄', children: [{ id: 31, date: '2016-05-01', name: '王小虎', address: '上海市普陀区金沙江路 1519 弄' }, { id: 32, date: '2016-05-01', name: '王小虎', address: '上海市普陀区金沙江路 1519 弄' }] }, { id: 4, date: '2016-05-03', name: '王小虎', address: '上海市普陀区金沙江路 1516 弄' }], tableData1: [{ id: 1, date: '2016-05-02', name: '王小虎', address: '上海市普陀区金沙江路 1518 弄' }, { id: 2, date: '2016-05-04', name: '王小虎', address: '上海市普陀区金沙江路 1517 弄' }, { id: 3, date: '2016-05-01', name: '王小虎', address: '上海市普陀区金沙江路 1519 弄', hasChildren: true }, { id: 4, date: '2016-05-03', name: '王小虎', address: '上海市普陀区金沙江路 1516 弄' }] } }, methods: { load(tree, treeNode, resolve) { setTimeout(() =&gt; { resolve([ { id: 31, date: '2016-05-01', name: '王小虎', address: '上海市普陀区金沙江路 1519 弄' }, { id: 32, date: '2016-05-01', name: '王小虎', address: '上海市普陀区金沙江路 1519 弄' } ]) }, 1000) } }, } &lt;/script&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9885bdd10e378f622f2c66492a0e27f3/" rel="bookmark">
			iOS开发之网络监听
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		iOS监听网络方式缺点通过状态栏判断一旦状态栏隐藏就会失效AFNetworking中的网络监听模块必须导入该框架，且无法判断移动网络的具体类型Reachability + CTTelephonyNetworkInfo代码较多 Reachability + CTTelephonyNetworkInfo Reachability官网下载
Reachability 中的网络类型：
NotReachable，无网络链接 ReachableViaWiFi，WiFi ReachableViaWWAN，蜂窝移动网络 上面可以看出，Reachability 并没有区分蜂窝移动网络的具体类型(例如2G/3G/4G)，因此还需要配合 CTTelephonyNeiworkInfo 使用。
CTTelephonyNetworkInfo 中的蜂窝移动网络类型： CTRadioAccessTechnologyGPRS，2G CTRadioAccessTechnologyEdge ，2G CTRadioAccessTechnologyWCDMA，2G CTRadioAccessTechnologyHSDPA，3G CTRadioAccessTechnologyHSUPA，3G CTRadioAccessTechnologyCDMA1x，3G CTRadioAccessTechnologyCDMAEVDORev0，3G CTRadioAccessTechnologyCDMAEVDORevA，3G CTRadioAccessTechnologyCDMAEVDORevB，3G CTRadioAccessTechnologyeHRPD，3G CTRadioAccessTechnologyLTE，3G 集成Reachability + CTTelephonyNetworkInfo的步骤 下载Reachability.h、Reachability.m，并导入项目中添加CoreTelephony.framework(Targets → Build Phases → Link Binary With Libraries)导入头文件#import &lt;CoreTelephony/CTTelephonyNetworkInfo.h&gt; /** * 判断当前网络类型 */ + (NSString *)getNetworkType { Reachability * reachability = [Reachability reachabilityWithHostName:@"www.baidu.com"]; NetworkStatus netStatus = [reachability currentReachabilityStatus]; NSString * networkType = @""; switch (netStatus) { case ReachableViaWiFi: networkType = @"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9885bdd10e378f622f2c66492a0e27f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/494077b494f10bee255b4e45aa3a9955/" rel="bookmark">
			命令行操作MySQL - 创建数据库与创建表 - 实现简单的“增删改查”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是命令行操作MySQL系列博客的第三篇，今天这篇博客记录一下如何“创建数据库”、“创建表”和实现简单的“增删改查”。
创建数据库 create database 数据库名;
出现上图的字样，说明已经创建成功了，然后show databases;可以查看已经创建好的数据库。
创建表 当然，创建表前，得先选择数据库才行：use test_database;
创建表的语句：
create table 表名(字段名1 类型, 字段名2 类型, ..., 字段名n 类型);
创建表就是这么简单，这里的int是整型，varchar()是字符类型。
还有很多创建表的高级用法，以后再另外博客记录下来吧！
增 insert into 表名 values(数据, 数据);
查 select * from 表名 where 条件;
条件可有可无！
‘ * ’ 是查找表中所有的数据。
也可以单纯的查找字段：
也可以配合条件进行查询一条数据：
改 update 表名 set 字段名=X1, ..., 字段名=Xn where 条件；
id 不是主键，也可以和name一起被修改：
也可以一下子修改一列中所有的字段：
删 delete from 表名 where 条件;
条件也可以是多个：
用 and 关键字进行连接条件。
就两条数据，我们都删除完了，再进行查询就查询不到任何数据了。
删除表中所有的数据：
delete from 表名;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/494077b494f10bee255b4e45aa3a9955/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9debf86ecb5ea43ce288c78433409516/" rel="bookmark">
			java中使用try-catch-finaly时的一些问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在编写程序时经常会使用到try-catch-finaly，我在使用的时候发现一个问题，那就是不可以在finaly块中再次加入try-catch块，因为这样会使异常覆盖掉。
具体上代码解释一下。
public static void main(String[] args) throws Exception { try{ throw new Exception("异常1"); }catch (Exception e){ throw new Exception("异常2"); }finally { try { throw new Exception("异常3"); } catch (Exception e) { throw new Exception("异常4"); } } } 输出结果：
Exception in thread “main” java.lang.Exception: 异常4
at cn.com.dataocean.cip.web.Test.main(Test.java:22)
只抛出了一个异常4，并没有抛出异常2。所以以后不可以在finally块中的catch中抛出异常了。
所以我们在使用try-catch-finaly时要注意这一点，因为finaly块中的代码无论如何是会被执行，所以当我们正常的在catch块中抛得异常如果有finaly块，那么程序会继续执行到finaly块中，导致我们正常catch块中抛的异常会被覆盖掉。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c651538f879c67966e05faddb5eef53e/" rel="bookmark">
			微信小程序消息订阅超详细流程步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步：登录微信小程序管理后台 链接https://mp.weixin.qq.com
第二步：在左侧栏目找到订阅消息菜单栏 --我的模板 ，可以去公共模板库增加自己想要的模板
如果没有自己想要的模板 跳转最后一页可以看到如下图点击进去可以申请增加自己的模板，一般申请模板大概需要3-7天审核时间
第三步：可以看到我的模板有对应的模板消息 到时候我们需要模板id 来显示
第四步：模板申请完后，前端同事拿到对应的模板id 后可以请求定义的接口获取下发权限也就是调用那个弹框接口 （wx.requestSubscribeMessage(Object object)），具体官方无文档可以参考：https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/subscribe-message.html
第五步：看自己业务场景是如何是发送订阅消息，如我们自己做的是定时是发送消息，比如购房从推荐，到访，认购，签约都会发送一条信息来提醒业务员，如果是实时发送消息的话那就简单，后端都不用写代码了，前端就可以实现了，比如付款成功，发送一条付款成功的消息
第六步：可以在后端创建一个消息订阅表，来记录订阅了哪些消息，后续可以根据不同场景去发送不同的消息 就完事了
注意事项：
1.如果订阅了消息，拒收消息后 前面订阅的消息都收不到，如要 需要重新打开接收消息按钮并重新订阅消息
2.如果订阅了3个模板消息，可以3个模板各发一条消息，意思是可以发送三条，不能多发，需要的话重新订阅
3.如果勾选了总是以上选择，下次不会再弹框，会默认之前的订阅状态
4.如果勾选了不接收消息订阅，是无法订阅消息也不会弹框之前订阅消息都无法发送的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5638f02612cedf6c59a4aeddbdd2587a/" rel="bookmark">
			/ 和/* 和/**的区别(特别是对于请求路径和文件路径的问题)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. /和/*区别 在springboot中建了一个过滤器，测试
当请求为/user/login的时候可以被拦截，当为/page/login.html页面的时候不拦截
当请求为/user/login的时候可以被拦截，当为/page/login.html页面的时候也会被拦截
所以综上，/ 不会拦截页面，只会拦截路径；而 / 会路径和页面。*
2. /* 和 /** /* 是拦截所有的文件夹，不包含子文件夹。
/** 是拦截所有的文件夹及里面的子文件夹。
也就是说，/* 只有后面一级，而 /** 可以包含多级。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5fbaf6b8c53574aec0e1471b330d9e6/" rel="bookmark">
			Docker的前世今生
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Docker介绍 1.1什么是容器? 简单地说，一个容器包含了完整的运行时环境：除了应用程序本身之外，这个应用所需的全部依赖、类库、其他二进制文件、配置文件等，都统一被打入了一个称为容器镜像的包中。通过将应用程序本身，和其依赖容器化，操作系统发行版本和其他基础环境造成的差异，都被抽象掉了。
1.2容器的前世 FreeBASE jail ------&gt; Linux vserver
chroot -----&gt; 完整的根文件系统(FHS)标准的
namespaces — &gt; UTS Mount IPC PID user network
cgroup —&gt; 资源的分配和监控;
通过比较复杂的代码开发的过程,调用以上三项技术
实现容器的创建----&gt;管理----&gt;销毁
1.3传统虚拟化技术和容器对比 首先，Container技术和服务器虚拟化并不是一样的技术：
两者虽然都属于虚拟化的技术，目标都是为了将一套应用程序所需的执行环境打包起来，建立一个孤立环境，方便在不同的硬件中移动，但两者的运作思维截然不同。
简单来说，传统虚拟化技术如vSphere或Hyper-V是以操作系统为中心，而Container技术则是一种以应用程序为中心的虚拟化技术。
传统虚拟化技术从操作系统层下手，目标是建立一个可以用来执行整套操作系统的沙盒独立执行环境，习惯以虚拟机(Virtual Machine)来称呼。Container技术则是直接将一个应用程序所需的相关程序代码、函式库、环境配置文件都打包起来建立沙盒执行环境，Container技术产生的环境就称为Container。
两者具体区别
​​​​​​​虚拟机需要安装操作系统(安装Guest OS)才能执行应用程序，而Container内不需要安装操作系统就能执行应用程序
Container技术不是在OS外来建立虚拟环境，而是在OS内的核心系统层来打造虚拟执行环境，透过共享Host OS的作法，取代一个一个Guest OS的功用。Container也因此被称为是OS层的虚拟化技术。
Container是轻量级虚拟化技术
​​​​​​​Container技术采取共享Host OS的作法，而不需在每一个Container内执行Guest OS，因此建立Container不需要等待操作系统开机时间，不用1分钟或几秒钟就可以启用，远比需要数分钟甚至数十分钟才能开启的传统虚拟机来的快。
Container技术的发展
早在1982年，Unix系统内建的chroot机制也是一种Container技术。其他如1998年的FreeBSD jails、2005年出现的Solaris Zones和OpenVZ，或像是Windows系统2004年就有的Sandboxie机制都属于在操作系统内建立孤立虚拟执行环境的作法，都可称为是Container的技术。直到2013年，dotCloud这家PaaS服务公司开源释出了一套将Container标准化的平台Docker，大受欢迎，所以，dotCloud决定以Docker为名成立新公司力推。
1.4容器的今生? 实现隔离能力!
LXC (LinuXContainer)
对于原有的常用功能进行了封装,方便我们做容器的生命周期
-----&gt; Docker ( dotc1oud)
2. Docker的安装 2.1 Docker的安装 yum install -y yum-utils device-mapper-persistent-data lvm2
yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5fbaf6b8c53574aec0e1471b330d9e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9498f7bb1d63f9ecc5bad1bb90c5994f/" rel="bookmark">
			批处理之for /f
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 显示文本内容字符串截取截取指点段字符串 通常，我们使用批处理命令来处理文本，而解析文本主要使用的就是for /f，通过几个常见使用场景的例子，来感受for /f的使用方式吧。 显示文本内容 描述：将同一目录下的test.txt的内容全部显示出来。
test.txt内容如下： 111 222 333 @echo off for /f %%i in (test.txt) do echo %%i &amp; pause pause 说明：运行这段代码，可以发现，每次输出一行后需要按任意键后才输出下一行，也就是说，for /f是在逐行解析文本内容的。
字符串截取 描述：以,为分隔符，截取第一个,之前的内容。
test.txt内容如下： 1,1,1 2,2,2 3,3,3 @echo off for /f "delims=，" %%i in (test.txt) do echo %%i pause 说明：运行可以发现，每行输出的内容里第一个,及其之后的内容不见了，即提取了每一行第一个分隔符之前的字符串内容，分隔符就是通过开关delims设置的如有多个分隔符都写出来即可"delims=,."，即一次可以指定多个分隔符，如果没有设置，那么分隔符默认是空格和Tab键的。
截取指点段字符串 描述：以,为分隔符，取分割后的第三段字符串。
test.txt内容如下： 11,22,33,44,55 @echo off for /f "delims=, tokens=3" %%i in (test.txt) do echo %%i pause 说明：运行这段代码，会输出33，也就是第三段字符串，这里的tokens就是表示提取哪一段分割段的，如果要提取多段字符串，只要改成这样既可：
@echo off for /f "delims=, tokens=2,5" %%i in (test.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9498f7bb1d63f9ecc5bad1bb90c5994f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56fe48773416ff78220e357a3b3db5b3/" rel="bookmark">
			线程和进程/阻塞和挂起以及那些sleep,wait()和notify()方法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线程与进程的阻塞 线程阻塞
线程在运行的过程中因为某些原因而发生阻塞，阻塞状态的线程的特点是：该线程放弃CPU的使用，暂停运行，只有等到导致阻塞的原因消除之后才回复运行，或者是被其他的线程中断，该线程也会退出阻塞状态，同时抛出InterruptedException。
进程阻塞
正在执行的进程由于发生某时间（如I/O请求、申请缓冲区失败等）暂时无法继续执行。此时引起进程调度，OS把处理机分配给另一个就绪进程，而让受阻进程处于暂停状态，一般将这种状态称为阻塞状态。
进程的挂起 挂起进程在操作系统中可以定义为暂时被淘汰出内存的进程，机器的资源是有限的，在资源不足的情况下，操作系统对在内存中的程序进行合理的安排，其中有的进程被暂时调离出内存，当条件允许的时候，会被操作系统再次调回内存，重新进入等待被执行的状态即就绪态，系统在超过一定的时间没有任何动作。
对于线程来说，挂起是没有的状态，因为进程的资源是线程共享的，所以进程的挂起就代表了线程的挂起
共同点：
1. 进程都暂停执行
2. 进程都释放CPU，即两个过程都会涉及上下文切换
不同点：
1. 对系统资源占用不同：虽然都释放了CPU，但阻塞的进程仍处于内存中，而挂起的进程通过“对换”技术被换出到外存（磁盘）中。
2. 发生时机不同：阻塞一般在进程等待资源（IO资源、信号量等）时发生；而挂起是由于用户和系统的需要，例如，终端用户需要暂停程序研究其执行情况或对其进行修改、OS为了提高内存利用率需要将暂时不能运行的进程（处于就绪或阻塞队列的进程）调出到磁盘
3. 恢复时机不同：阻塞要在等待的资源得到满足（例如获得了锁）后，才会进入就绪状态，等待被调度而执行；被挂起的进程由将其挂起的对象（如用户、系统）在时机符合时（调试结束、被调度进程选中需要重新执行）将其主动激活
7状态模型 7状态模型中，和阻塞，挂起相关的有三个概念，阻塞状态，阻塞挂起状态，就绪挂起状态。它们的关系如下图：
阻塞态：进程在内存中并等待一个事件。
阻塞/挂起态：进程在外存中并等待一个事件。
就绪/挂起态：进程在外存中，但是只要被载入内存就可以执行。
五状态到七状态模型增加了两个挂起状态的原因。
对于I/O密集型的进程，一个进程进入等待（阻塞）状态后，处理器会转向处理另一个就绪的进程，但是由于处理器处理的速度相比I/O要快的多，所以可能会出现所有进程都处于阻塞状态的情况。导致处理器的效率低下。一种解决办法是扩充内存适应更多的进程。
有以下缺点：
1.内存的价格
2.程序对内存空间需求的增长速度比内存价格下降的速度快。因此，更大的内存往往导致更大的进程，而不是更多的进程。
另一种解决方案是交换。包括把内存中某个进程的一部分或全部移到磁盘中。当内存中没有处于就绪状态的进程时，操作系统就把被阻塞的进程患处到磁盘中的”挂起队列“（suspend queue），即暂时保存从内存中”驱逐“出来的被挂器的进程队列。操作系统再次之后取出挂起队列中的另一个进程，或者接受一个新进程的请求，将其纳入内存运行。于是就产生了挂起这样一个状态。
睡眠状态没有在七状态模型中出现，其实它是阻塞或等待状态下的一种更细的分支。分支的依据是进程由运行状态进入阻塞状态的原因。睡眠是进程通过代理（自己或父进程）主动引起的进程调度，并且这种阻塞状态恢复到就绪状态的时间是确定的。而狭义上的阻塞可以理解为一个被动的动作。
关于睡眠，有一篇博客是这样解释的
当一个进程获取资源比如获取最普通的锁而失败后，可以有两种处理方式，
1、自己睡眠，触发调度；
2、忙等待，使用完自己的时间。所以从这里看，睡眠的确是一种主动的方式，且仅仅作为一种处理手段。当然睡眠不仅仅用于阻塞，更多的，我们可以在适当的时候设置让进程睡眠一定的时间，那么在这里，就可以发现，睡眠之前，我们已经预先规定了，你只能睡多长时间，这段时间过后，比必须返回来工作。
阻塞的原因 主要分为：线程中的阻塞、Socket客户端的阻塞、Socket服务器端的阻塞。
一般线程中的阻塞：
A、线程执行了Thread.sleep(int millsecond);方法，当前线程放弃CPU，睡眠一段时间，然后再恢复执行
B、线程执行一段同步代码，但是尚且无法获得相关的同步锁，只能进入阻塞状态，等到获取了同步锁，才能回复执行。
C、线程执行了一个对象的wait()方法，直接进入阻塞状态，等待其他线程执行notify()或者notifyAll()方法。
D、线程执行某些IO操作，因为等待相关的资源而进入了阻塞状态。比如说监听system.in，但是尚且没有收到键盘的输入，则进入阻塞状态。
Socket客户端的阻塞：
A、请求与服务器连接时，调用connect方法，进入阻塞状态，直至连接成功。
B、当从Socket输入流读取数据时，在读取足够的数据之前会进入阻塞状态。比如说通过BufferedReader类使用readLine()方法时，在没有读出一行数据之前，数据量就不算是足够，会处在阻塞状态下。
C、调用Socket的setSoLinger()方法关闭了Socket延迟，当执行Socket的close方法时，会进入阻塞状态，知道底层Socket发送完所有的剩余数据
Socket服务器的阻塞：
A、线程执行ServerSocket的accept()方法，等待客户的连接，直到接收到客户的连接，才从accept方法中返回一个Socket对象
B、从Socket输入流读取数据时，如果输入流没有足够的数据，就会进入阻塞状态
D、线程向Socket的输出流写入一批数据，可能进入阻塞状态
挂起的原因 （1）终端用户的请求。当终端用户在自己的程序运行期间发现有可疑问题时，希望暂停使自己的程序静止下来。亦即，使正在执行的进程暂停执行；若此时用户进程正处于就绪状态而未执行，则该进程暂不接受调度，以便用户研究其执行情况或对程序进行修改。我们把这种静止状态成为“挂起状态”。
（2）父进程的请求。有时父进程希望挂起自己的某个子进程，以便考察和修改子进程，或者协调各子进程间的活动。
（3）负荷调节的需要。当实时系统中的工作负荷较重，已可能影响到对实时任务的控制时，可由系统把一些不重要的进程挂起，以保证系统能正常运行。
（4）操作系统的需要。操作系统有时希望挂起某些进程，以便检查运行中的资源使用情况或进行记账。
（5）对换的需要。为了缓和内存紧张的情况，将内存中处于阻塞状态的进程换至外存上。
操作系统中睡眠、阻塞、挂起的区别形象解释：
首先这些术语都是对于线程来说的。对线程的控制就好比你控制了一个雇工为你干活。你对雇工的控制是通过编程来实现的。 挂起线程的意思就是你对主动对雇工说：“你睡觉去吧，用着你的时候我主动去叫你，然后接着干活”。 使线程睡眠的意思就是你主动对雇工说：“你睡觉去吧，某时某刻过来报到，然后接着干活”。 线程阻塞的意思就是，你突然发现，你的雇工不知道在什么时候没经过你允许，自己睡觉了，但是你不能怪雇工，因为本来你让雇工扫地，结果扫帚被偷了或被邻居家借去了，你又没让雇工继续干别的活，他就只好睡觉了。至于扫帚回来后，雇工会不会知道，会不会继续干活，你不用担心，雇工一旦发现扫帚回来了，他就会自己去干活的。因为雇工受过良好的培训。这个培训机构就是操作系统。 线程栈状态 线程栈状态有如下几种：
1、NEW
2、RUNNABLE
3、BLOCKED
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56fe48773416ff78220e357a3b3db5b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95a05db35d4dc3ebae7b1ce3b9bc0a6c/" rel="bookmark">
			torch.nn.Embedding()中的padding_idx参数解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		torch.nn.Embedding() Word Embedding 词嵌入，就是把一个词典，随机初始化映射为一个向量矩阵。
列如：有一组词典，有两个词“hello”和“world”，对应的值为0和1.通过pytorch中的torch.nn.Embedding()建立一个2x10的向量矩阵，其中2表示词典中词的数量，10表示每个词对应的向量大小。
word_to_id = {'hello':0, 'world':1} embeds = nn.Embedding(2, 10) hello_idx = torch.LongTensor([word_to_id['hello']]) hello_embed = embeds(hello_idx) print(hello_embed) 应用pytorch自带的nn.Enbedding构建词嵌入向量。
torch.nn.Embedding(num_embeddings: int, embedding_dim: int, padding_idx: Optional[int] = None, max_norm: Optional[float] = None, norm_type: float = 2.0, scale_grad_by_freq: bool = False, sparse: bool = False, _weight: Optional[torch.Tensor] = None) num_embeddings：表示词典中词的数量
embedding_dim：表示每个词对应的向量维度
自然语言中使用批处理时候, 每个句子的长度并不一定是等长的, 这时候就需要对较短的句子进行padding, 填充的数据一般是0, 这个时候, 在进行词嵌入的时候就会进行相应的处理, nn.embedding会将填充位置的值映射为0。
padding_idx padding_idx：表示用于填充的参数索引，比如用3填充，嵌入向量索引为3的向量设置为0
import torch import torch.nn as nn embed = nn.Embedding(10, 3, padding_idx=3) # padding_idx 默认是0 embed.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95a05db35d4dc3ebae7b1ce3b9bc0a6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63b61e65c844783f6805cf43bbe94819/" rel="bookmark">
			【java队列】LinkedBlockingDeque
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、简介2、源码分析2.1、属性2.2、构造函数2.3、方法2.3.1、入队方法add相关的方法offer相关的方法put相关的方法 2.3.2、出队方法remove相关的方法poll相关的方法take相关的方法 2.3.3、获取元素方法2.3.4、删除元素方法 3、总结 1、简介 上一篇我们介绍了 LinkedBlockingDeque 的兄弟篇 LinkedBlockingQueue 。听名字也知道一个实现了 Queue 接口，一个实现了 Deque 接口，由于 Deque 接口又继承于 Queue ，所以 LinkedBlockingDeque 自然就有 LinkedBlockingQueue 的所有方法，并且还提供了双端队列的一些其他方法
2、源码分析 2.1、属性 /** * 节点类，维护了前一个元素和后一个元素，用来存储数据 */ static final class Node&lt;E&gt; { E item; Node&lt;E&gt; prev; //与LinkedBlockingQueue相比，多了往前的指针 Node&lt;E&gt; next; Node(E x) { item = x; } } /** * 阻塞队列的第一个元素的节点 */ transient Node&lt;E&gt; first; /** * 阻塞队列的尾节点 */ transient Node&lt;E&gt; last; /** 当前阻塞队列中的元素个数 */ private transient int count; /** 阻塞队列的大小，默认为Integer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63b61e65c844783f6805cf43bbe94819/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b158bac8d991892dd36a6b3f94cd6614/" rel="bookmark">
			webview内存泄漏解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.运行app，先用AS自带的Profiler分析我们的WebViewActivity,频繁进出，看内存占用情况，会发现内存在不断的上升，而且退出当前页面内存只是下降一点，一直持续下去，肯定会OOM；
2.引入leakcanary内存泄漏分析工具
由于只运行debug模式来检测，所以只需在build.gradle中引入：
debugImplementation 'com.squareup.leakcanary:leakcanary-android:1.6.1' 然后在自定义的Application的OnCreate方法中加入如下：
if (LeakCanary.isInAnalyzerProcess(this)) { return; } LeakCanary.install(this); 接下来重新编译运行APP，继续频繁进出WebviewActivity，LeakCanary会很快检测出内存泄漏风险，等待通知栏下载hprof文件成功，然后点击Android Studio 页面右下角'Device File Explorer'，会显示当前手机的文件夹，
找到"sdcard---&gt;Download---&gt;leakcanary-com.xxx.xxx(后缀是自己包名的文件夹)---&gt;2020-09-29_10-06-28_940.hprof",找到这个文件保存在电脑本地，然后使用工具分析，这里分析的的方式有很多种：
1.直接使用AS打开，会自动fetch然后可以查看各变量类型使用情况；
2.使用Eclipse的Eclipse Memory Analyzer；
3.使用在线分析工具：https://heaphero.io/heap-index.jsp#header(个人比较喜欢使用这个)；
接下来直接按照第三个方式来举例了：
这是分析的整体结果图：
然后查看Large objects，会发现webview和drawable占用内存较高，一步步点进去 会发现是Bitmap的buffer导致的内存泄漏风险
那么再回想一下WebViewActivity的布局原来有一张无网的背景图在WebViewActivity频繁进出时没有及时回收导致的(Android5.1和Android8.0检测结果还有差异)。那就开始优化之路--及时回收ImageView组件和Bitmap： // ivNoNetwork是无网的ImageView组件 if(ivNoNetwork!= null ){ Drawable drawable = ivNoNetwork.getDrawable(); if (drawable != null &amp;&amp; drawable instanceof BitmapDrawable) { BitmapDrawable bitmapDrawable = (BitmapDrawable) drawable; Bitmap bitmap = bitmapDrawable.getBitmap(); if (bitmap != null &amp;&amp; !bitmap.isRecycled()) { // 如果还没被回收，才去回收 bitmap.recycle(); } } } // 同时在父布局中移除这个ImageView， llNoNetwork是ImageView组件的父布局 if(llNoNetwork !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b158bac8d991892dd36a6b3f94cd6614/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a18ff31fccbe8fee0dc547f201ca929/" rel="bookmark">
			如何在Windows上配置Python开发环境？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇博客会不断汇总配置Python开发环境的相关知识。
1、工具
Pycharm
Jupyter Notebook
Anaconda
2、命令
pip
conda
3、安装Anaconda，配置环境变量，将D:\Anaconda\Scripts添加至环境变量，这个文件下有conda、pip命令。过程中不小心将pip删掉了，可以使用该文件夹下的easy_install重新安装。
4、配置虚拟环境，网上有很多教程，这个是个人认为Anaconda最大的优势，具体教程可参见：https://www.cnblogs.com/bjxqmy/p/12661931.html，以安装tensorflow例。这里说一下，安装tensorflow2的相关版本，需要安装适用于 Visual Studio 2015、2017 和 2019 的 Microsoft Visual C++ 可再发行软件包，具体参见https://tensorflow.google.cn/install/pip
5、配置好虚拟环境后，可以在Pycharm中添加虚拟环境中的python路径。
6、特别的，在jupyter notebook中也需要配置虚拟环境的执行kernel，具体方法参加：https://www.cnblogs.com/JadenFK3326/p/12671741.html ，但是按照这个博客的做法，我遇到的问题是提示我缺包，需要安装nb_conda和pypiwin32两个库，在对应的虚拟环境下安装即可。
删除当前虚拟环境下的jupyter kernel的命令为jupyter kernelspec remove [env name]
jupyter kernelspec list 可以查看单前配置的kernel
7、以下说一下主要的命令
查看现有的虚拟环境：conda info --env
进入指定的虚拟环境：activate [虚拟环境名]
退出虚拟环境：deactivate [虚拟环境名]
进入执行的虚拟环境中，可以使用conda和pip安装库，存在有些库conda无法下载，因此需要pip。但是有时候在虚拟环境中下载的包会覆盖全局的（这个问题有时间再研究），后来我下载的最新的版本不存在这个问题了，可以使用 pip -V 命令来查看此时的pip的具体的位置，以免覆盖全局。
还有是安装了新版本的Anaconda后，会遇到conda安装库的速度特别慢，这时候就需要参见：https://blog.csdn.net/weixin_41622348/article/details/100582862，也许会解决你的问题。
8、最后说一下如何完全删除Anaconda，可以参考：https://blog.csdn.net/kuweicai/article/details/90145242
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9bb0df1aa14195217483381b240f329/" rel="bookmark">
			impala常用数值函数大全（超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文目录 数值函数函数列表 数值函数 Impala中数学函数用来执行数值计算，比如基本加法，减法，乘法和除法及更复杂的运算
函数列表 abs(numeric_type a) ==&gt; 返回参数的绝对值
--得到-12的绝对值 [master:21000] &gt; select abs(-12) as abs; +-----+ | abs | +-----+ | 12 | +-----+ --得到-12.5的绝对值 [master:21000] &gt; select abs(-12.5) as abs; +------+ | abs | +------+ | 12.5 | +------+ bin(bigint a) ==&gt; 返回整数的二进制表示形式，即0和1位数字符串。
--得到15的二进制字符串 [master:21000] &gt; select bin(15) as bin; +------+ | bin | +------+ | 1111 | +------+ ceil(double a)
ceiling(double a)
dceil(double a)
==&gt; 返回大于或等于参数的最小整数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9bb0df1aa14195217483381b240f329/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffcf665506b2fa818030acabf3f481dd/" rel="bookmark">
			Spring EL表达式解析——解析AOP注解中的EL表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求：在切面逻辑中识别@Cache注解中的#name，并将#name识别为test3(String name, RegionPo po)方法中的name参数值
public class TestServiceImpl{ @Cache("#name") @Override public void test3(String name, RegionPo po) { System.out.println("============正在执行==========="); } } 首先定义一个annotation
package com.test.annotation; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Target({ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) public @interface Cache { String value(); } 定义切面
package com.test.aspect; import java.lang.reflect.Method; import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.annotation.Around; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.reflect.MethodSignature; import org.springframework.core.LocalVariableTableParameterNameDiscoverer; import org.springframework.expression.ExpressionParser; import org.springframework.expression.spel.standard.SpelExpressionParser; import org.springframework.expression.spel.support.StandardEvaluationContext; import org.springframework.stereotype.Component; import com.test.Cache; @Component @Aspect public class CacheAspect { @Around("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffcf665506b2fa818030acabf3f481dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf7d2b858f5616329906c7358e143c64/" rel="bookmark">
			序列类型python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 序列类型 序列类型是基类类型，不直接使用。字符串、列表、元组都是序列类型，可使用序列类型方法。序列操作符 x in S x not in S	s+t	# 连接两个序列 s*n # 复制n次 s[i]	# 索引 s[i:j:k]	# 切片 序列函数和方法 len(s) min(s) max(s) s.index(x) 或 s.index(x,i,j)	# 返回s从i到j中首次出现x的索引 元组类型 元组类型是一种序列类型，一旦创建就不可修改。创建：用（），元素用,分隔；tuple()元组可使用序列的所有操作。 列表类型 列表可以修改。“=”不能实现赋值，只是创建了一个新的指针索引。列表方法 del ls[i]	# 删除 del ls[i,j,k]	# 删除 ls+=lt	# 列表lt增加到ls中 ls*=n	# 列表重复n次 列表的增删改插 ls.copy()	# 生成一个新列表 ls.append(x)	# 列表末尾增加一个元素x ls.insert(i,x) # 在位置i插入x ls.clear()	# 清空ls ls.pop(i)	# 抛出i位置的元素，并更新列表 ls.remove(x)	# 将列表中首个出现的x删除 ls.reverse()	# 列表翻转 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7656d69ea1cefea1ebcfba285d4069ea/" rel="bookmark">
			浏览器被www.hao123.com重定向了怎么办?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		已经困恼多时，对于打开那个浏览器都会重定向到hao123.com 的行为已经快习惯了，但是今天我解决了。
原因就是 小马激活这类激活软件 不能激活还有病毒 淦！！！
虽然重定向无其他坏影响，但是就是不想被控制的感觉让我又一次对它打起来注意
废话不多说，查了很多策略 但是没有用
可能这种首页劫持的病毒已经更加进化聪明了
什么删注册表，修改快捷方式，软件exe文件名。。。
just so so
话不多说隆重登场
火绒
路径 火绒–安全工具–专杀工具–下载就完事了。。
没有火绒就直接下载
下载地址
希望可以拯救你们那些hao123折磨的小灵魂
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afb57a5bd8b67303708568437591497c/" rel="bookmark">
			java 实现日期是否属于当前日期的前五分钟
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 将当前日期前进五分钟
public Date endtime(){ Calendar beforeTime = Calendar.getInstance(); beforeTime.add(Calendar.MINUTE, -5);// 5分钟之前的时间 Date beforeD = beforeTime.getTime(); String before5 = new SimpleDateFormat("yyyyMMddHHmmss").format(beforeD); // 前五分钟时间 return beforeD; } 判断日期是否属于当前日期的前五分钟之内
nowTime：判断时间
beginTime：当前时间
endTime：提前五分钟时间
public static boolean belongCalendar(Date nowTime, Date beginTime, Date endTime) { Calendar date = Calendar.getInstance(); date.setTime(nowTime); Calendar begin = Calendar.getInstance(); begin.setTime(beginTime); Calendar end = Calendar.getInstance(); end.setTime(endTime); if (date.after(begin) &amp;&amp; date.before(end)) { return true; } else { return false; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d58d62ad97dc212664194ca32102a1ac/" rel="bookmark">
			JAVA开发各种bug、踩坑记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 20200928 1. 反射相关 bug描述：
FastClassBySpringCGLIB invoke(&lt;generated&gt;) 错误导致的NULL POINTER异常
这个错误很难直接定位，实际问题通常是生成某种对象失败。
解决：
https://my.oschina.net/u/1000241/blog/1923188
2. mybatis使用 bug描述： &lt;if test="field='value'"&gt;&lt;/if&gt; if判断不生效
解决：
field变量的类型是字符串型和字符型不匹配，需要转换，正确示范： &lt;if test="field='value'.toString()"&gt;&lt;/if&gt; 3. mysql数据类型 bug描述：
varchar存储bigint长度的数字，在比较时会丢失精度参考：
建议直接用bigint类型代替
https://blog.csdn.net/airyearth/article/details/106440995 20200929 1. oracle sql bug描述：
ORA-01788: 此查询块中要求 CONNECT BY 子句解决：
检查语句中是否有字段为必须和CONNECT BY联合使用的关键字
如：level，需要改为"LEVEL"转义。 2. oracle clob类型 BUG:
报json对象子引用循环超类异常，并提供了参考引用链：
xxx-&gt;com.alibaba.druid.NClobProxyImpl["rawNClob"]-&gt;oracle.sql.NCLOB["dbaccess"]
解决：
所查oracle表有字段为nclob类型，druid读取clob字段存在问题【我直接修改了字段类型为varchar2。。】
https://blog.csdn.net/maobois/article/details/78095186
3. 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e34f68f15ea7515441d1af6a08a64322/" rel="bookmark">
			k8s搭建consul集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要通过k8s集群搭建Consul集群
满足条件：
1. 有一个部署好的k8s集群
2. 集群内部支持DNS服务
3.最好对consul及配置有相应的了解
consul学习参考文章：https://blog.csdn.net/skh2015java/article/details/108853881
部署
1. 部署一个Service
# consul-server-service.yaml
apiVersion: v1 kind: Service metadata: name: consul-server labels: name: consul-server spec: selector: name: consul-server ports: - name: http port: 8500 targetPort: 8500 - name: https port: 8443 targetPort: 8443 - name: rpc port: 8400 targetPort: 8400 - name: serf-lan-tcp protocol: "TCP" port: 8301 targetPort: 8301 - name: serf-lan-udp protocol: "UDP" port: 8301 targetPort: 8301 - name: serf-wan-tcp protocol: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e34f68f15ea7515441d1af6a08a64322/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5ae2b241906ea7d7922b2bbec6a61d9/" rel="bookmark">
			Mysql5.7版本中，查询分组GROUP BY通过子查询中ORDER BY进行排序无效的问题解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：使用场景，查询用户所访问的同一个客服的列表，但是存在多次访问的情况，这时候就需要使用分组，获取客户访问的所有客服。且通过子查询提前将交互时间（最后一次访问客服时间）进行排序
（1）客服服务日记表
CREATE TABLE `kefu_service_log` ( `id` int(11) NOT NULL AUTO_INCREMENT, `kefu_id` int(11) DEFAULT NULL, `user_id` int(11) DEFAULT NULL, 'created_at' timestamp DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci; （2）我们对 kefu_id 进行分组，按 created_at 从大到小排序：
SELECT * FROM `kefu_service` GROUP BY kefu_id ORDER BY created_at
直接使用 group by 查出来的数据是按 id 顺序分组的，并未达到预期
（3）尝试使用子查询，先排序再分组
SELECT * FROM ( SELECT * FROM `kefu_service_log` ORDER BY created_at ) AS k GROUP BY kefu_id
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5ae2b241906ea7d7922b2bbec6a61d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/211ee2bd6088f5a9a8177ac34090f8d4/" rel="bookmark">
			http与https、响应码（状态码）、缓存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、url的组成？http和https是同一个协议吗？ 组成：传输协议，域名，端口，文件位置，参数。
HTTP（顺丰）：超文本传输协议（除了传递普通的文本，还可以传递文件流或者进制编码等信息），端口80
HTTPS（邮政）：基于SSL（Secure Sockets Layer 安全套接层）加密的HTTP传输协议，比HTTP更加的安全（涉及支付的网站一般都是基于HTTPS完成的），端口443
FTP（货运）：文件传输协议，一般用来实现资源文件在服务器上的上传下载
1. Https的作用
内容加密 建立一个信息安全通道，来保证数据传输的安全；
身份验证 确认网站的真实性；
数据完整性 防止内容被第三方冒充或者篡改
2. HTTPS和HTTP的区别
https协议需要到CA申请证书
http是超文本传输协议，信息时明文传输；https则是具有安全性的ssl加密传输协议
http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443
http的连接很简单，是无状态的；https协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全
3. SSL（Secure Socket Layer，安全套接字层）
SSL为Netscape所研发，用以保障在Internet上数据传输之安全，利用数据加密技术，可确保数据在网络上传输过程中不会被截取，当前为3.0版本。
SSL协议可分为两层：SSL记录协议（SSL Recore Protocol）：它建立在可靠地传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份证、协商加密算法、交换加密密钥等。
二、http的响应码及含义？ 1 消息
▪ 100 Continue
▪ 101 Switching Protocols
▪ 102 Processing
2 成功
▪ 200 OK
▪ 201 Created
▪ 202 Accepted
▪ 203 Non-Authoritative Information
▪ 204 No Content
▪ 205 Reset Content
▪ 206 Partial Content
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/211ee2bd6088f5a9a8177ac34090f8d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/438b69a65c2a0e20c543b8ea345ead8a/" rel="bookmark">
			SAXParseException的错误解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		控制台出现如下错误： 这种情况的出现的造成是因为xml中相关的引用约束出错，找一下出错点发现：
只需要将mvc改成context就行。
细节细节细节！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2ed10327adfd486fee92415b0b3bf84/" rel="bookmark">
			Matlab实现Lasso-Lars
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的第一篇博客哟（沧海一声笑）
基础知识传送门：https://zhuanlan.zhihu.com/p/46999826
参考博文传送门：http://blog.sina.com.cn/s/blog_4a03c0100101b3c3.html。
我的工作：对代码进行了一些些修改，修正了错误部分，以及去掉了无用的部分。
本来Matlab就不是很熟，算法更是一头雾水（嘤~）花掉了姐妹儿两天的时间，肩周炎都犯了（大哭）
注释都写上啦，接下来更新匹配追踪（OMP）。
废话不多说，上代码==》
------------更新说明------------
该算法似乎不太准确，直接使用matlab的lasso会更好。有时间更新。 %主文件 clc; clear; y=[7.6030 -4.1781 3.1123 1.0586 7.8053]'; A=[0.5377 -1.3077 -1.3499 -0.2050 0.6715 1.0347 0.8884; 1.8339 -0.4336 3.3049 -0.1241 -1.2075 0.7269 -1.1471; -2.2588 0.3426 0.7254 1.4897 0.7172 -0.3034 -1.0689; 0.8622 3.5784 -0.0631 1.4090 1.6302 0.2939 0.8095; 0.3188 2.7694 0.7147 1.4172 0.4889 -0.7873 -2.9443]; beta1 = lars1(A, y, 'lasso', 0, 1, [], 1); | %lars1函数 function beta = lars1(X, y, ~, ~, ~, ~, ~) [n,p] = size(X);%传感矩阵的[行数,列数] nvars = p; %y最多由p个向量决定 maxk = 8*nvars; % 最多迭代次数 beta = zeros(2*nvars, p);%beta为每次迭代得稀疏系数的预测 mu = zeros(n, 1); % LARS向lsq解决方案移动时的当前“位置”，n*1的0向量（列） I = 1:p; % 非积极集，开始为所有向量下标(观测矩阵X的总列数)，存储下标1、2、3、4、5、6、7 A = []; % 积极集，存储下标（已选定向量） R = []; lassocond = 0; % 出现负相关变量时，lassocond=1 k = 0; % 当前迭代次数 vars = 0; % 目前积极变量的个数。 fprintf('Step\tAdded\tDropped\t\tActive set size\n');%命令窗口显示字，matlab2019版 %并非所有变量都为积极集时，k未达到最大迭代次数进行以下循环 while vars &lt; nvars &amp;&amp; k &lt; maxk k = k + 1; c = X'*(y - mu);% 各自变量与因变量的相关度。 fprintf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2ed10327adfd486fee92415b0b3bf84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03e4000ebe41b65d49d32589aebd9978/" rel="bookmark">
			将模型从PYTORCH导出到ONNX并使用ONNX RUNTIME运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在本教程中，我们描述了如何将PyTorch中定义的模型转换为ONNX格式，然后在ONNX Runtime中运行它。
ONNX Runtime是针对ONNX模型的以性能为中心的引擎，可在多个平台和硬件（Windows，Linux和Mac以及CPU和GPU上）高效地进行推理。ONNX运行时已被证明大大增加了多种型号的性能，说明这里
对于本教程，大家将需要安装ONNX 和ONNX Runtime。大家可以使用来获取ONNX和ONNX Runtime的二进制版本 。请注意，ONNX运行时与Python 3.5至3.7版本兼容。pip install onnx onnxruntime
NOTE：本教程需要PyTorch master分支，可以按照此处的说明进行安装
# Some standard imports import io import numpy as np ​ from torch import nn import torch.utils.model_zoo as model_zoo import torch.onnx 超分辨率是一种提高图像，视频分辨率的方法，广泛用于图像处理或视频编辑中。在本教程中，我们将使用一个小的超分辨率模型。
首先，让我们在PyTorch中创建一个SuperResolution模型。该模型使用“使用高效子像素卷积神经网络的实时单幅图像和视频超分辨率”（Shi等人）中所述的高效子像素卷积层 ，将图像的分辨率提高一个比例因子。该模型期望图像的YCbCr的Y分量作为输入，并以超分辨率输出放大的Y分量。
该模型 直接来自PyTorch的示例，无需修改：
# Super Resolution model definition in PyTorch import torch.nn as nn import torch.nn.init as init ​ ​ class SuperResolutionNet(nn.Module): def __init__(self, upscale_factor, inplace=False): super(SuperResolutionNet, self).__init__() ​ self.relu = nn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03e4000ebe41b65d49d32589aebd9978/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e6da905db781d8db3de5dc17b6d5029/" rel="bookmark">
			Windows无法安装到GPT格式磁盘的根本解决办法 - 初学者系列  - 学习者系列文章...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上次在MSDN系统QQ群里有朋友问到在安装操作系统的时候有个问题：Windows无法安装到GPT格式磁盘，见图：
我在这里说下，使用网上方法的都是小白，就是说网上那些都是小白。下面介绍如何正确安装操作系统。
当时群里另个网友给出了方法，在这个界面先转换磁盘为MBR格式然后再安装。然后我在百度里搜了下，所有的方法都是这个方法，都是先转换为MBR再进行安装。
1、这里先说说MBR和GUID的区别；
MBR的意思是主引导记录，是传统分区类型，只支持一个硬盘上最多4个主分区，最大的缺点是不支持2TB以上硬盘容量，而GUID就是新兴的GPT方式，支持的主分区数量没有限制。
MBR支持win7版本系统以下的32位和64位，而GUID支持win7版本以上的64位系统，不支持32位系统。
对于MBR需要了解的是，MBR是一个特殊的启动扇区，主要存在于磁盘驱动器开始部分，而且这个扇区包含了已安装的操作系统的系统信息，并用一小段代码来启动系统，如果MBR的信息损坏或误删就不能正常启动Windows，这时候就需要找一个引导修复即可。
上面介绍了MBR和GUID的区别。这里重点说下，GPT格式是新的一种格式，对于windows的启动那是具有优势的，这个是GPT启动模式的特点，具体请自己百度。
2、MBR和GPT的启动方式；
BIOS+MBR：这是最传统的，系统都会支持；唯一的缺点就是不支持容量大于2T的硬盘。 BIOS+GPT：BIOS是可以使用GPT分区表的硬盘来作为资料盘的，但不能引导系统；若电脑同时带有容量小于2T的硬盘和容量大于2T的硬盘，小于2T的可以用MBR分区表安装系统，而大于2T的可以使用GPT分区表来存放资料。但系统须使用64位系统。 UEFI+MBR：可以把UEFI设置成Legacy模式(传统模式)让其支持传统MBR启动，效果同BIOS+MBR；也可以建立FAT分区，放置UEFI启动文件来，可应用在U盘和移动硬盘上实现双模式启动。 UEFI+GPT：如果要把大于2T的硬盘作为系统盘来安装系统的话，就必须如此。而且系统须使用64位系统，否则无法引导。但系统又不是传统在PE下安装后就能直接使用的，引导还得经过处理才行。
3、下面介绍MBR和GPT启动安装操作系统；
因为GPT的启动速度快，所以安装操作系统的时候建议选择GPT启动方式。
1)首先，在BIOS里设置启动方式为：UEFI Only ；
这里无论是否磁盘格式为MBR还是GPT，都选择这个模式。
2)制作系统启动U盘；
然后制作一个系统安装启动U盘。具体参考笔者博文：安装操作系统的几种方式 - 初学者系列 - 学习者系列文章 。
3)用启动U盘启动安装操作系统；
这里很重要，就是插入U盘后，开机。按快捷键用以显示启动菜单(必须通过启动菜单选择U盘启动方式)：
这里注意看启动菜单，会显示两种启动模式：
如图，这里就是重点了。
(1)如果你硬盘是MBR格式，安装操作系统的话，那就选择“U盘Legacy引导模式”，这样你安装操作系统的时候磁盘分区的时候就是MBR格式，直接能够分区安装；
(2)如果你硬盘是GPT格式，安装操作系统变得haunt，那就选择“U盘UEFI引导模式”，这样你安装操作系统的时候磁盘分区是GPT格式；
说到这里，大家明白了吧，就是因为U盘启动的时候选择的U盘启动模式不一样，所以磁盘分区安装操作系统的时候磁盘的MBR或者GPT格式就有了限制，如果你选择的格式是U盘Legacy引导模式，但是磁盘格式却是GPT格式，就会出现提示无法安装到GPT磁盘的问题。
etc.通过本文的介绍，相信各位网友已经明白了安装操作系统的方式了，祝大家玩电脑愉快吧，希望喜欢玩电脑的朋友能够学到更多的实用知识。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1658e8d71d5bf7ed11651253a8af1cf9/" rel="bookmark">
			分布式系统架构——CAP理论
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 什么是CAP 在分布式系统中，任何存储系统（有状态服务）都会涉及到CAP定理：
Consistency：一致性，简称C。在同一时刻所有节点是具有同样的数据副本，每个节点的数据要保证实时同步。Availability：可用性，简称A。对于一个集群整体而言，能够不间断的对外提供读写请求，集群内部一部分节点出现故障不会影响整个集群。Partition tolerance：分区容错性，简称P。在分布式系统中，难以避免网络故障（如网络延迟、丢包等）等问题。在出现网络故障时，集群仍能正常对外提供读写请求服务，但是数据可能是一致性的或者非一致性的，也就是能对外提供一致性或可用性的服务。 2 C和A二则不可兼得 在分布式系统中，P是一定要实现的，必须要保证每个节点上的服务都能够正常对外提供读写请求，只有这样在出现网络故障时才有选择性，要阻塞还是不阻塞，可以根据要实现什么样的系统来进行抉择。
C和A二则不可兼得，下面来进行说明
假设有Node01和Node02两台机器，每台机器上部署了一个DB。
在网络正常的情况下，在Node01节点写入了一个“A”，然后同步给了Node02，在Node02上也能正常访问到“A”。
再次向Node01发起一个请求，将“A”更新为“B”，此时Node01和Node02之间发生了网络故障，“B”无法同步给Node02。由于网络容错性，Node02任然能够对外提供服务，如果获取数据的请求分发到了Node02上，这个时候就只有两个选择：一是舍弃可用性，保证一致性，阻塞请求直到网络恢复，“B”成功同步到Node02上；
二是舍弃一致性，保证可能性，此时无法获取到最新的数据“B”。
3 Zookeeper不适合直接做注册中心 Zookeeper遵从的是CP原则，保证数据的一致性。
假设Zookeeper有两个节点（ZK的节点数实际为奇数）ZK01和ZK02，三个App往ZK上注册服务，ZK01是leader节点，ZK02往ZK01同步数据，ZK01和App1、App2在同一个IDC，ZK02和App3在同一个IDC。如果此时发生了故障，App3就会被阻塞，无法向ZK02注册服务，其他服务也不能通过ZK02发现服务，任何访问ZK02的请求都会被阻塞，直到网络恢复，这显然无法保证服务的高可用。
注册中心不需要数据的强一致性，每个App可以向不同的注册中心节点注册服务，只要保证最终一致性即可，所以能作为注册中心的组件应该遵从AP原则。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83115b354f398d36518bb75d44def978/" rel="bookmark">
			从0开始搭建 SpringCloudAlibaba 项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、服务注册中心和配置中心nacos 首先去NACOS官网 下载相关jar，这里使用的是最新版本1.3.2 解压缩后需要配置数据库 nacos-&gt;conf 找到nacos-mysql.sql ,在数据库建库nacos并执行该脚本。 修改applicaion.properties文件，其中将默认连接方式修改为mysql数据库连接 spring.datasource.platform=mysql db.num=1 db.url.0=jdbc:mysql://localhost:3306/nacos?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;serverTimezone=GMT%2b8 db.user=root db.password=root 配置完以上内容后就可以启动nacos服务了，选择nacos-&gt;bin目录下startup.cmd。双击该文件运行，当然运行不了。 因为1.3.2版本默认的启动方式集群模式，需要切换成单机模式才可以运行。打开cmd切换到nacos的bin文件夹下，输入命令startup.cmd -m standalone ，出现如下显示就表示启动成功了 访问nacos网页看看效果，cmd启动完了会有启动地址，如上图红框地址。默认的账号密码为 nacos 以上就是nacos的配置信息与启动方式。第一步已经完事了，接下来开始创建demo，开始写代码啦
注意事项：必须先启动nacos，才能启动cloud的项目
2、创建SpringCloudAlibaba项目 2.1 创建一个父工程
修改pom文件
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;modules&gt; &lt;module&gt;cloudalibaba-provider&lt;/module&gt; &lt;/modules&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;cloudalibaba&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;cloudalibaba&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83115b354f398d36518bb75d44def978/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/690dbfb0d37a788fcee919af3bc42775/" rel="bookmark">
			DM查询模式下所有的表和记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工作中，我们时常统计某个模式下有哪些表，表中有多少条记录，如果每张表去统计，工作量会非常的大。介绍一种简单方便的统计方法：
--drop table table_count; create table table_count (owner varchar(100),table_name varchar(100),cnt int); declare v_owner VARCHAR2(100); v_tabname VARCHAR2(100); stmt VARCHAR2(200); num_rows number; begin for rec in (select owner,table_name from dba_tables where owner='DMHR' order by 1, 2) loop select rec.owner,rec.table_name into v_owner,v_tabname from dual; stmt := 'select count(*) from "' || v_owner || '"."' || v_tabname || '"'; EXECUTE IMMEDIATE stmt INTO num_rows; EXECUTE IMMEDIATE 'insert into table_count values('''||v_owner||''','''||v_tabname||''','''||to_number(num_rows)||''');'; end loop; end; --truncate table table_count; select count(*) from table_count; select * from table_count order by cnt desc; select count(*) from dba_tables; 在迁移过程中，核对源端和目的端数据的时候极为方便。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8810d4593282560636c8d967d7deb87/" rel="bookmark">
			服务器性能测试-增加了请求数，但是tps上不去，反而下降了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个系统吞吐量通常有QPS(TPS),并发数两个因素决定，每套系统这个两个值都有一个相对极限值，在应用场景访问压力下，只要某一项达到系统最高值，系统吞吐量就上不去了，如果压力继续增大，系统的吞吐量反而会下降，原因是系统超负荷工作，上下文切换，内存等等其他消耗导致系统性能下降。
QPS QPS Queries Per Second 是每秒查询率 ,是一台服务器每秒能够相应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准, 即每秒的响应请求数，也即是最大吞吐能力。
TPS TPS Transactions Per Second 也就是事务数/秒。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数，
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d70578d76d972848938fc859bf953883/" rel="bookmark">
			原码反码补码以及左移右移无符号左移右移。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 机器数和真值 在学习原码, 反码和补码之前, 需要先了解机器数和真值的概念.
1、机器数
一个数在计算机中的二进制表示形式, 叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为0, 负数为1.
比如，十进制中的数 +3 ，计算机字长为8位，转换成二进制就是00000011。如果是 -3 ，就是 10000011 。
那么，这里的 00000011 和 10000011 就是机器数。
2、真值
因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 10000011，其最高位1代表负，其真正数值是 -3 而不是形式值131（10000011转换成十进制等于131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。
例：
0000 0001的真值 = +000 0001 = +1，
1000 0001的真值 = –000 0001 = –1
原码, 反码, 补码的基础概念和计算方法.
二.原码反码补码概念 计算机中二进制相加逢二进一
在探求为何机器要使用补码之前, 让我们先了解原码, 反码和补码的概念.对于一个数, 计算机要使用一定的编码方式进行存储. 原码, 反码, 补码是机器存储一个具体数字的编码方式.
原码: 原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:
[+1]原 = 0000 0001 [-1]原 = 1000 0001 第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d70578d76d972848938fc859bf953883/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27f1240bf1a9a0a79695d2325a5eb579/" rel="bookmark">
			mysql列相加和列数据相加的方法函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql列相加和列数据相加的方法函数 select CONCAT(列名,列1，列2) from table; 结果是 当前所有列数据相加。一般用于地址拼接。
select GROUP_CONCAT(列名) from table; 结果是 当前列数据相加。一般用于一对多查询返回单个字段集。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e2ed8a2df0967c1d00e047760792af4/" rel="bookmark">
			C2. Pokémon Army (hard version)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题意：给你一个序列，从左往右一次选择数字，奇数次选的符号为正，反之符号为负，问最后的最大值是多少，qwq这是简单版本的，然后难的版本多了一个修改，该修改是交换两个数的位置。
解题思路：如果是简单版本那么可以用dp来做，数组定义为考虑前i个 且轮到第i个的时候是奇数还是偶数次，难的版本有大佬说可以用线段树做，然而我并不会，然后看最优解在途中的表示，是先波峰再波谷 这样循环往复，然后画图发现竟然这个策略与(i&gt;=1 &amp;&amp; i&lt;=n)zigema max(a[i]-a[i-1],0)等价，那么修改就很好办了，减去l和r对答案的贡献，再加上新的l和r对答案的贡献，当l=r+1的时候要特判一下不然会多减。
代码：
#include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; #include&lt;map&gt; using namespace std; typedef long long ll; const int N=300010; int a[N]; int n,q; signed main() { ios::sync_with_stdio(0); cin.tie(0),cout.tie(0); int t; cin&gt;&gt;t; while(t--) { cin &gt;&gt; n &gt;&gt; q; for(int i=1;i&lt;=n;i++) cin &gt;&gt; a[i]; a[0]=0,a[n+1]=0; ll res=0; for(int i=1;i&lt;=n;i++) res+=max(a[i]-a[i-1],0); cout&lt;&lt;res&lt;&lt;endl; while(q--) { int l,r; cin&gt;&gt;l&gt;&gt;r; if(l==r) { cout&lt;&lt;res&lt;&lt;endl; continue; } if(r==l+1) { res-=max(a[r]-a[l],0); res-=max(a[r+1]-a[r],0); res-=max(a[l]-a[l-1],0); swap(a[l],a[r]); res+=max(a[r]-a[l],0); res+=max(a[r+1]-a[r],0); res+=max(a[l]-a[l-1],0); cout&lt;&lt;res&lt;&lt;endl; continue; } res-=max(a[l]-a[l-1],0)+max(a[l+1]-a[l],0); res-=max(a[r]-a[r-1],0)+max(a[r+1]-a[r],0); swap(a[l],a[r]); res+=max(a[r]-a[r-1],0)+max(a[r+1]-a[r],0); res+=max(a[l]-a[l-1],0)+max(a[l+1]-a[l],0); cout&lt;&lt;res&lt;&lt;endl; } } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5728993d802f4d23ea1745fc9a4e52a6/" rel="bookmark">
			Linux 解压缩与压缩，你懂了吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux文件压缩 前言一、压缩是什么？二、Linux中的压缩命令#.压缩类型1.压缩与解压缩主要命令1. gzip2. bzip23.tar附录1 总结 前言 提示：学习Linux中的解压缩命令
提示：以下是本篇文章正文内容
一、压缩是什么？ 压缩与解压缩；
你知道什么是压缩吗？
一个较大的文件经压缩后，产生了另一个较小容量的文件。而这个较小容量的文件，我们就叫它是这些较大容量的（可能一个或一个以上的文件）的压缩文件。而压缩此文件的过程称为文件压缩。
反之将压缩后的文件还原成原来的文件，压缩的逆行为就是解压缩。
二、Linux中的压缩命令 #.压缩类型 主要类型如下：
*.gz	gzip程序压缩的文件 *.bz2	bzip2程序压缩的文件 *.tar	tar程序打包的数据，并没有经过压缩 *.tar.gz	tar程序打包的文件，其中经过gzip的压缩 *.tar.bz2	tar程序打包的文件，其中经过bzip2的压缩 1.压缩与解压缩主要命令 1. gzip （命令规则）：
压缩文件gzip： gzip 文件名（原文件不存在） gzip -c 文件名1 &gt;文件名1.gz （保留原文件） 解压文件： gzip -d 文件名.gz（不保留） gunzip 文件名.gz gzip -cd 文件名2.gz &gt;文件名2（保留原文件） 查看压缩过的文本文件内容：zcat 文件名.gz
2. bzip2 （命令规则）：
压缩文件bzip2（用法同gzip）： bzip2 文件名 bzip2 -c 文件名1 &gt;文件名1.bz2（保留原文件） 解压文件： bzip2 -d 文件名.bz2（不保留原文件） bunzip2 文件名.bz2 bzip -cd 文件名2.bz2 &gt; 文件名2（保留原文件） 查看压缩过的文件内容：bzcat 文件名.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5728993d802f4d23ea1745fc9a4e52a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9940fe57d1e2de6a1729b06671e20c8d/" rel="bookmark">
			区块链技术新运用 搭建“双标统一”“双链协同”可信数字版权生态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		服贸会期间，北京互联网法院与北京版权保护中心共同搭建的版权链-天平链协同治理平台正式启动。该平台搭建了“双标统一”“双链协同”的可信数字版权生态，这也是全国首个版权领域行政-司法协同治理机制。
为展示版权链和天平链共同构建的可信数字版权生态，展示区块链技术在版权管理、版权保护和产业赋能领域解决方案，展示出版、图片、音乐、艺术品等领域重点项目的最新应用示范成果，积极推进区块链技术在版权产业的发展应用，在北京市委宣传部（北京市版权局）、北京市高级人民法院指导下，北京版权保护中心、北京互联网法院、首都版权协会共同举办的“版权链-天平链协同治理平台发布会暨可信数字版权生态重点示范项目发布会”于9月6日在北京国际会议中心举行。
首都版权协会副秘书长宣宏量详细解读了版权链，版权证书链、版权保护链和版权交易链统称版权链，共同构成了版权产业的可信数字基础设施。据悉传统版权证书（纸质证书、电子证书）所能呈现的版权信息有限，易篡改、易伪造，导致证书法律效力不足。数字版权证书具有信息容量大的特点，可以完整记录作者、著作权人、作品、作品文件、权利证明文件的信息。数字证书利用哈希技术，锁定证书的数据项，建立数据项之间的唯一关系，保证了证书内容可信。数字证书利用非对称加密技术，实现证书防篡改、防伪造。由数字证书生成的电子证书和纸质证书，构成了可信证书体系。在数字经济时代，数字版权证书实现了版权资产数字化，成为版权资产唯一可信的价值载体。
现场还发布了涵盖图书、音乐、游戏、艺术品等领域的版权链重点示范项目。中北文艺术品（北京）有限公司与北京版权保护中心、北京文创动力签署合作协议，今后将联合制定和发布基于版权链的艺术品版权、物权上链规范。 中北文艺术品作为国内古代艺术品收藏的知名机构，致力于古代艺术品IP运营及衍生品开发应用，目前已完成自有私家藏品实物逾23万件艺术品的数字化和信息采集工作，成为国内首个版权链古代艺术品的先行者。中北文艺术品（北京）有限公司董事长但羽表示：“全球化、数字化、信息化加剧了数字技术高速发展，被运用普及到各行各业，其中包括艺术数字技术。数字化是大势所趋，借助成熟的区块链技术与法律武器，实现艺术品从证书、维权、交易多链结构的版权保护，有效通过数字版权维护正当权益。民间收藏界一定要抓住这个机遇，将古代艺术精品的文化价值，借助数字版权融入新经济浪潮中。同时，让普通百姓通过数字化技术，更便于欣赏和学习上下五千年古代艺术的精髓。”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6faba37b8d07b96793cf29e2952850bf/" rel="bookmark">
			visio studio 2017无法导入opencv库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		按照网上的步骤完成了所有路径的配置后还是无法导入opencv库，如图：
把x86换成x64编译器即可，如图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f622e7c358d1484cff07d376d73c0c4/" rel="bookmark">
			狂神说多线程笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		狂神说多线程笔记
bilibli视频地址：https://www.bilibili.com/video/BV1V4411p7EF/
1.基本概念 Process和Thread
程序：指令和数据的有序集合，其本身没有任何运行的含义，是一个静态的概念。
进程：是执行程序的一次执行过程，是一个动态的概念。是系统资源分配的单位。
​ 一个进程可以包含有多个线程（如视频中同时听到声音、看到图像，还可以看弹幕）
​ 一个进程至少有一个线程，否则无存在的意义。
线程：CPU调度和执行的单位。
注意：很多多线程是模拟出来，真正的多线程是指有多个CPU，即多核，如服务器。如果是模拟出来的多线程，即在一个CPU的情况下，在同一个时间点，cpu只能执行一个代码，因为切换很快，所以就有同时执行的错觉。
2.核心概念 线程就是独立的执行路径；在程序运行时，即使没有自己创建线程，后台也会有多个线程，如主线程，gc线程；main()称为主线程，为系统的入口，用于执行整个程序；在一个进程中，如果开辟了多个线程，线程的运行由调度器安排调度，调度器是与操作系统紧密相关的，先后顺序是不能认为干预的；对同一份资源操作时，会存在资源抢夺问题，需要加入并发控制；线程会带来额外的开销，如CPU调度时间，并发控制开销；每个线程在自己的工作内存交互，内存控制不当会造成数据不一致 3.线程创建 1.继承Thread类,重写run方法** a.创建Thread类
b.重写run()方法
c.调用start()开启线程
//创建线程方式一：继承Thread类，重写run()方法，调用start()开启线程 public class Test01 extends Thread{ @Override public void run() { //run方法线程体 for (int i = 0; i &lt;20; i++) { System.out.println("我在看代码"); } } public static void main(String[] args) { //main线程，主线程 //创建一个线程对象 Test01 t= new Test01(); //	t.run(); 调用run()方法，执行完run方法体再执行main方法体 //调用start()方法开启线程 同时执行 t.start(); for (int i = 0; i &lt; 2000; i++) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f622e7c358d1484cff07d376d73c0c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/467630948721cc7e2c8aebb1bf3969c1/" rel="bookmark">
			mapper适配【从mysql到oracle】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		迁移注意点：
时间函数兼容
str_to_date -&gt; to_date
date_format -&gt; to_char
now()-&gt;sysdate
时间格式化：
‘%Y-%m-%d %H:%i:%s’ -&gt; ‘yyyy-mm-dd hh24:mi:ss’
https://www.cnblogs.com/ladyM/p/8378548.html
分页兼容
limit -&gt; rownum
https://blog.csdn.net/use_admin/article/details/83622414
# mysql select * from tablename where xxx = xx order by xxx desc limit #{startPage}, #{count} # oracle select * from ( select tt.*, ROWNUM as rowno from ( select * from tablename where xxx = xx order by xxx desc ) tt where ROWNUM &lt;= #{startPage} + #{count}) table_alias where table_alias.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/467630948721cc7e2c8aebb1bf3969c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e21d0d2f441a94ebe550740fab93e8c/" rel="bookmark">
			R 利用回归分析与时间序列预测北京市PM2.5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注：代码全部在最后,数据来源UCI,链接如下： https://archive.ics.uci.edu/ml/datasets/Beijing+PM2.5+Data
摘要 现代社会科技进步，人们的生活质量逐步提高，但伴随着各类工业和科技的发展，环境问题凸显，最初人们粗放式的经济发展方式在一定程度上对环境造成不可逆转的破坏。在各种环境污染问题，空气污染问题又是如今人们关注的重中之重。北京是我国首都，同时也是我国空气污染较为严重的几个北方城市之一，因此关注北京市空气污染情况是我国观测空气污染情况的重要关注对象之一。在本文中，首先，我就北京市PM2.5及其他污染物和气象情况的近几年观测数据做出相应回归分析，建立回归模型试图利用已知的其他污染物和气象情况信息对PM2.5做出预测；其次，利用现如今已观察到的数据做单变量时间序列分析，寻找其变化规律、做简单预测，为北京市人民规划出行做好提前空气质量预警。
关键词：PM2.5 多元回归分析 时间序列分析
一、数据集介绍 该数据集来自于北京市环境检测中心，包括了2013年3月1日到2017年2月28日，12个国家控制的空气质量监测站每小时的空气污染数据，且每个空气质量站点的气象数据都与中国气象局站相匹配。此空气污染数据集包括12个站点数据集，每个数据集包括了35064个时间数据，共有（35064*12）个样本。
变量包括：PM2.5、PM10、SO2（二氧化硫）、NO2（二氧化氮）、CO（一氧化碳）、O3（臭氧）为空气污染物；剩余变量TEMP（温度）、PRES（大气压）、DEWP（露点温度）、RAIN（降雨量）、WD（风向）、WSPM（风速）天气情况。
站点包括：万寿西宫（西城区）、官园（西城区）、万柳（海淀区）、天坛（东城区）、农展馆（朝阳区）、奥体中心（朝阳区）、怀柔、古城（顺义区）、顺义、东寺（平谷区）、定陵（昌平区）、昌平共十二个，其地理位置分布如下：
二、研究问题一 （一）研究问题 将SO2、NO2、CO、O3、TEMP（温度）、PRES（大气压）、DEWP（露点温度）、RAIN（降雨量）、WD（风向）、WSPM（风速）作为解释变量，Y作为被解释变量，以预测误差最小为原则，选择最优多元回归模型。
（二）研究方法 多元回归
（三）研究步骤 1.数据集选择 由于该数据集有北京12个观测点的完整时间数据，以下以PM2.5为例绘制出PM2.5分布的盒图和小提琴图，并按照均值从从低到高排列，发现12个观测点PM2.5的分布基本相似，以下选择其中一个地区奥体中心的数据集进行分析。
2.数据可视化 在进行定量建模之前，先绘制图像对变量分布和变量之间的相关关系进行直观感受与定性分析。
观察SO2、NO2、CO和O3这四种污染物分别与PM2.5的相关关系：
可以看出PM2.5随着CO、NO2浓度的上升而呈线性上升趋势，O3和SO2和PM2.5的线性关系没有那么强烈。
接下来考虑气温、压强、露点温度、降雨量与被解释变量PM2.5的关系：
从图中可以看出气温、压强、露点温度、降雨量和PM2.5的相关性更弱，但具体会对PM2.5的预测有怎样的效果，需要在回归模型中进一步分析。
最后考虑风速和风向与被解释变量PM2.5的关系：
在第一幅图可以看中，图例从上到下以PM2.5均值大小排序，可以看出西北方向的风PM2.5峰度高且整体分布靠左，东南方向的风峰度低而整体分布靠右，也就是PM2.5值整体偏大；风速和PM2.5的线性相关关系不是很明显。
3.回归分析（以奥体中心为例） （1）前期准备
① 对待选入模型的变量进行平稳性检验，防止出现伪回归，使用ADF单位根检验，拒绝原假设，不存在单位根，序列平稳。
② 对所选的“奥体中心”数据做删失处理，由于数据量足够多，直接删除带有缺失值的行。
（2）变量选择：
先做全变量回归，发现有大量变量存在系数t检验结果不显著，并且存在VIF值较高的变量，需要进行变量选择，这里尝试了两种变量选择的方法，两种方法筛选出的变量相同。
① 根据BIC准则做逐步回归，依次从全模型剔除变量，直至BIC值最小。
② 利用10折交叉验证，将数据根据被解释变量均匀分为10份，每一份分别当作测试集，计算利用10个训练集训练出的模型在相应测试集上的MSE并取平均，建立循环寻找使得交叉验证所得MSE平均值最小的变量组合，即预测效果最好的变量组合。
（3）回归结果：
Coefficients: Estimate
Std. Error
t value
Pr(&gt;|t|)
(Intercept)
232.812250
64.033810
3.636
0.000278
***
SO2
0.463988
0.019179
24.192
&lt;2e-16
***
NO2
0.710602
0.015931
44.605
&lt;2e-16
***
CO
0.035909
0.000440
81.608
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e21d0d2f441a94ebe550740fab93e8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/069097f7d679ea8aa02767d131dc008d/" rel="bookmark">
			如何在vue3中优雅地使用v-model？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 ps:vue3中推荐使用的是reactive写法，文中这种格式只是为了和vue2做对照，只是为了凸显vue3中对v-model的改进，仅供参考。Vue中的数据绑定v-bindv-bind支持的类型v-bind使用v-model vue2中v-model用法不使用v-model的双向绑定父组件子组件 使用v-model后父组件子组件问题 .syncvue2中使用v-model + .sync父组件子组件 vue3中v-model的使用父组件子组件 总结 ps:vue3中推荐使用的是reactive写法，文中这种格式只是为了和vue2做对照，只是为了凸显vue3中对v-model的改进，仅供参考。 Vue中的数据绑定 绑定数据有三种方式：
插值，也就是{{name}}的形式，以文本的形式和实例data中对应的属性进行绑定v-bindv-model v-bind eg：v-bind:class 可简写为 :class
当加上v-bind:之后，它的值classe不是字符串，而是vue实例对应的data.class的这个变量。也就是说data.class是什么值，它就会给class属性传递什么值，当data.class发生变化的时候，class属性也发生变化，这非常适合用在通过css来实现动画效果的场合。他只是单向变动
v-bind支持的类型 html中的属性、css的样式、对象、数组、number 类型、bool类型
v-bind使用 // 绑定文本 &lt;p v-bind="message"&gt;&lt;/p&gt; // 绑定属性 &lt;p v-bind:src="http://...."&gt;&lt;/p&gt; &lt;p v-bind:class="http://...."&gt;&lt;/p&gt; &lt;p v-bind:style="http://...."&gt;&lt;/p&gt; // 绑定表达式 :class{className:true} v-model v-model 指令在表单 、 及 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 v-model 本质上不过是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理
主要是用在表单元素中，它实现了双向绑定。在同时使用v-bind和v-model中，v-model建立的双向绑定对输入型元素input, textarea, select等具有优先权，会强制实行双向绑定。很多时候v-model使用在表单的&lt;input&gt;中实现双向绑定。
v-model实现了表单输入的双向绑定，一般是这么写的：
&lt;div id="app"&gt; &lt;input v-model="price"&gt; &lt;/div&gt; &lt;script&gt; new Vue({ el: '#app', data: { price: '' } }); &lt;/script&gt; 通过该语句实现price变量与输入值双向绑定
实际上v-model只是一个语法糖，真正的实现是这样的：
&lt;input type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/069097f7d679ea8aa02767d131dc008d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cd420e2b4f62d69e3504a9242df869a/" rel="bookmark">
			LWN：GCC也支持BPF了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关注了就能看到更多这么棒的文章哦～
BPF in GCC By Jake Edge
September 15, 2020
LPC
原文来自：https://lwn.net/Articles/831402/
DeepL assisted translation
BPF virtual machine 在内核中的应用越来越广泛，但直到最近 GCC 才在支持这个 target 方面有了一些进展。BPF 此前一直是使用 LLVM 编译器工具来编译生成代码的。Jose E. Marchesi 在 2020 年 Linux Plumbers Conference（LPC）上做了两场演讲（都属于 GNU Tools track），向与会者介绍了大约一年前开始的 BPF for GCC project。它已经取得了一些重大进展，但当然还有更多的工作要做。
预计这个项目会有三个阶段。首先是将 BPF target 添加到 GNU toolchain 中。下一步是确保生成的程序能够被内核里的 BPF verifier 验证通过，从而允许加载到内核中。Marchesi 说，这部分需要持续不断的工作，因为 BPF 领域的发展速度非常快。最后一个阶段是为 BPF 开发者提供额外工具，除了编译器和汇编器（compiler and assembler）之外，还需要调试器和模拟器（debuggers and simulators）。
[Jose E. Marchesi]
Binutils 中支持 BPF 的代码，在 2019 年 8 月就已经合入了，而 GCC 的 BPF backend 则是在 2019 年 9 月加入的。在 2020 年 8 月，也就是此演讲的几周前，GDB 中也添加了对 BPF 的支持，同时也提供了一个模拟器。这个模拟器是配合 DejaGnu test framework 的 board file 一起使用的，这样就可以执行 BPF backend 的 GCC test suite。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2cd420e2b4f62d69e3504a9242df869a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d62f53fdd4e16b11a71f0b250966d61/" rel="bookmark">
			在C &#43;&#43;中加载TORCHSCRIPT模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		顾名思义，PyTorch的主要接口是Python编程语言。尽管Python是许多需要动态性和易于迭代的场景的合适且首选的语言，但在同样许多情况下，Python的这些属性恰恰是不利的。后者通常适用的一种环境是生产-低延迟和严格部署要求的土地。对于生产场景，即使只将C ++绑定到Java，Rust或Go之类的另一种语言中，它通常也是首选语言。以下段落将概述PyTorch提供的从现有Python模型到可以加载和执行的序列化表示形式的路径 完全来自C ++，不依赖Python。
步骤1：将PyTorch模型转换为Torch脚本
Step 1: Converting Your PyTorch Model to Torch Script
PyTorch模型从Python到C ++的旅程由Torch Script启用，Torch Script是PyTorch模型的表示形式，可以由Torch Script编译器理解，编译和序列化。如果从使用香草“渴望” API编写的现有PyTorch模型开始，则必须首先将模型转换为Torch脚本。在最常见的情况下（如下所述），只需很少的努力。如果已经有了Torch脚本模块，则可以跳到本教程的下一部分。
有两种将PyTorch模型转换为Torch脚本的方法。第一种称为跟踪，一种机制，通过使用示例输入对模型的结构进行一次评估，并记录这些输入在模型中的流动，从而捕获模型的结构。这适用于有限使用控制流的模型。第二种方法是在模型中添加显式批注，以告知Torch Script编译器可以根据Torch Script语言施加的约束直接解析和编译模型代码。
TIP
大家可以在官方的Torch脚本参考中找到有关这两种方法的完整文档，以及使用方法的进一步指导。
Converting to Torch Script via Tracing
要将PyTorch模型通过跟踪转换为Torch脚本，必须将模型的实例以及示例输入传递给torch.jit.trace 函数。这将产生一个torch.jit.ScriptModule对象，该对象的模型评估跟踪将嵌入在模块的forward方法中：
import torchimport torchvision# An instance of your model.model = torchvision.models.resnet18()# An example input you would normally provide to your model's forward() method.example = torch.rand(1, 3, 224, 224)# Use torch.jit.trace to generate a torch.jit.ScriptModule via tracing.traced_script_module = torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d62f53fdd4e16b11a71f0b250966d61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eef4d50177097743ca59f16daa076648/" rel="bookmark">
			gitee&#43;picgo 上传图片失败 显示404 project not found 的解决。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		gitee+picgo 上传图片失败 显示404 project not found 的解决。 原因是Picgo 的仓库设置不对。我的原来是Tohaklie/articleimage 后面不知到怎么变成了Tohaklie_admin/articleimge了。把Picgo里面的仓库路径修改一下就行了。
我觉得可能是把我的另一个仓库升级成企业版的时候系统自动改的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fab27aedb2d33f47e460d511868cc1a8/" rel="bookmark">
			yaml 格式错误 did not find expected key
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 持续集成或者在k8s master节点上执行yaml脚本部署时报错。看报错信息，描述的是yaml转json失败导致。
解决思路：
格式是否有错，真的是yaml格式错误，可以把内容复制到http://www.yamllint.com/或者找一个yaml校验工具进行调试如果yaml格式正确，则是逻辑上的问题，例如：k8s上对象依赖关系，是否嵌套的正确，典型案例就是volumes应该放在和containers平级的位置，不要放在任意一个container中，惯例放在最后且和containers平级。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32a253e1e4b85af9c94ce3a9d92b96ea/" rel="bookmark">
			CUDA 程序的优化(3) 任务划分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		4.3.1任务划分原则 首先，需要将要处理的任务划分为几个连续的步骤，并将其划分为CPU端程序和GPU端程序。划分时需要考虑的原则有:
列出每个步骤的所有可以选择的算法，并比较不同算法在效率和计算复杂度上的差异。
能够并行实现的算法并不一定比串行算法快。在问题规模较小时，计算复杂度阶数更高的算法也有可能比计算复杂度阶数较低的算法耗费更短的时间。根据问题规模，选择适当算法，将任务中耗费时间最多的大规模数据并行、高计算密集度步骤映射到GPU上。
在CPU上可以并行实现的算法不一定适用于GPU。CPU程序主要考虑的是指令间并行和粗粒度的软件线程并行，在每个CPU线程内还是串行的。由于CPU线程粒度往往太大，因此尽量不要将CPU线程直接映射为GPU线程。每个GPU线程完成的任务更加类似于CPU的多轮循环中的一轮。但也不是所有的循环都能映射为一个内核程序，因为有的循环中每一轮运算都依赖上一轮的结果，而GPU的线程之间是并行的。此时，需要采取其他方式对任务进行分解。
在两次主机一设备通信之间进行尽量多的计算。由于主机与设备间的数据传输带宽远低于显存带宽，因此最好在两次通信之间让GPU进行尽可能多的运算。如果在两次大规模数据并行运算之间存在少量的串行运算，有时即使是在GPU上以较低的效率进行这些串行运算也比增加两次主机一设备通信要划算。在GPU进行运算的同时，如果可能，也可以让CPU进行一些计算，比如准备下一次计算需要的数据。
应该考虑使用流运算隐藏主机一设备通信时间，以及通过pinned memory, zero-copy,write-combined memory等手段提高实际传输带宽。在集群中使用CUDA，还需要考虑节点之间的任务分配与通信问题。
对每个并行步骤进行划分，从不同角度分析有不同的划分方式。
从对显存的访问方向来说，可以按照输入划分或者按照输出划分。如果每个block中输入和输出的数据的比例和位置是固定的，并且能够比较容易地满足合并访问要求，那么这种划分方式既是按照输入划分的，也是按照输出划分的。这种情况是最理想的，通过shared memory和指针类型转换，大多数输入输出都能够很好地满足合并访问条件。
但如果block的输入和输出的数据不相同，或者输入和输出无法同时满足合并访问要求，就必须设法使可用带宽最大化，只按照输入或者只按照输出划分。
按照输入划分的情况有:
输入参数很多而输出结果很少，如规约、直方图。输入满足合并访问条件，但是输出位置随机，或者输出时需要进行显存原子操作，在流体力学、分子动力学仿真中可能遇到这种情况。 按照输出划分的情况有:
输入参数很少而输出结果很多，如随机数发生器。Block内每个线程的输入与其他线程共用，比如卷积、滤波中，每个线程的输入与周围线程的输入有公共部分，此时应该先按照合并访问的形式将一块数据读入shared memory，再由每个线程计算一定数量的输出，可以参考SDK中与滤波和卷积有关的几个例子。输入数据在存储器中的位置是随机的，而输出数据时可以满足合并访问条件的情况，大多数使用纹理的应用，以及一些需要查表的运算都属于这种情况。 从显存访问的形式来说，在一个block内可以进行一维的带状划分、二维的棋盘划分或者三维的域划分。如果要处理的任务不需要线程间通信，并且对显存的访问都能满足合并访问，那么采用棋盘划分还是带状划分对性能影响并不大。不过，应该尽量使每个block中的线程数量是犯的整数倍，并根据任务的具体情况确定每个维度上的大小，以减少计算访存地址时的整数除法和求模运算。
如果需要使用纹理的特殊功能进行图像处理，使用二维棋盘划分是比较自然的。
如果问题在一个或者几个维度方向上有局部性，可以利用shared memory提高性能或者必须在某几个维度内进行线程间通信，那么block的维度应该与需要通信的维度一致。比如本章4.7.1节的矩阵乘法例子中，既可以进行一维带状划分，也可以按照二维棋盘划分，但二维划分的算法利用了shared memory，有效减小了访存次数，并且满足合并访问条件。
对一个block的任务进行划分后，再按照block的维度和尺寸要求对grid进行划分。此时需要考虑的问题是:
考虑分区冲突问题，使每个block的访存要求均匀分布在显存的各个分区中，例如4.7.3节中介绍的矩阵转置，在解决分支冲突问题后，性能有了几倍的提升。Block间负载可以存在一定程度的不均衡，按照block为单位分支性能损失也很小比如，对网络中的数据进行分析时，可以由一个grid处理其中缓冲中的多个包，再由每个SM处理长度和内容都不同的包。 4.3.2 grid和block维度设计 按照CUDA的执行模型，grid中的各个block会被分配到GPU的各个SM中执行。下面的一些建议能够帮助读者确定合适的Grid与block尺寸。在设计时，应该优先考虑block的尺寸，而grid的尺寸一般来说越大越好。
由3.2.2.3小节可知，在Tesla架构GPU的每个SM中，至少要有6个active warp才能有效地隐藏流水线延迟。此外，如果所有的active warp都来自同一block，当这个block中的线程进行存储器访问或者同步时，执行单元就会闲置。基于以上原因，最好让每个SM上拥有至少2个active block。
一个SM上的active warp和active block数量计算方法如下:
（1)确定每个SM使用的资源数量。
使用nvcc的–keep编译选项，或者在.cu编译规则(cuda build rule)中选择保留中间文件（keep preprocessed files），得到.cubin文件。用写字板打开.cubin文件，在每个内核函数的开始部分，可以看到以下几行:
lmem = 0 smem = 256 reg = 8 其中，lmem和reg分别代表内核函数中每个线程使用的local memory数量和寄存器数量，smem代表每个block使用的shared memory数量。以上数据告诉我们:这个内核函数的每个线程使用了 0 Byte local memory, 8个寄存器文件(每个寄存器文件的大小是32bit);每个block使用了256Byte的shared memory.
（2)根据硬件确定SM上的可用资源。
可以用SDK中的deviceQuery获得每个SM中的资源。要注意的是，在程序编译时，要使目标代码和目标硬件版本与实际使用的硬件一致(使用一arch、-gencode和一code编译选项)。
在G80和GT200架构上，这些限制如表4-1所示。
此外，每个block中的线程数量不能超过512个。
（3)计算每个block使用的资源，并确定active block和active warp数量。
假设每个block中有64个线程，每个block使用256 Byte shared memory, 8个寄存器文件，那么就有:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32a253e1e4b85af9c94ce3a9d92b96ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0dbe2682b16429760c299ece2c9bf87/" rel="bookmark">
			（精简理解）DPDK的无锁环形队列Ring
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写目录标题 1. DPDK Ring简介2. Ring实现2.1 单一生产者入队2.2 单一消费者出队2.3 多个生产者入队2.4 多个消费者出队 3 总结3.1 入队列3.2 出队列 1. DPDK Ring简介 dpdk实现了一个无锁环形队列Ring，可用于在dpdk不同的应用程序之间进行通信。
逻辑上ring看起来如下图：
在使用这个结构的时候，一般是将1个核作为生产者，向这个ring队列里面添加数据；另一个core或者多个core 作为消费者从这个ring队列中获取数据。生产者核访问上面的prod结构，消费者访问cons结构。
Ring支持的效果：
先进先出最大大小是固定的，指针存储在表中无锁实现多消费者或单消费者出队多生产者或单生产者入队 struct rte_ring { /* Ring producer status. */ struct prod { uint32_t watermark; /**&lt; Maximum itemsbefore EDQUOT. */ uint32_t sp_enqueue; /**&lt; True, if single producer. */ uint32_t size; /**&lt; Size of ring.*/ uint32_t mask; /**&lt; Mask (size-1)of ring. */ volatile uint32_thead; /**&lt; Producer head.*/ volatileuint32_t tail; /**&lt; Producer tail.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0dbe2682b16429760c299ece2c9bf87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63efc142008dfe0436e45b59b81355a1/" rel="bookmark">
			快速解决Endnote导入自定义格式库的问题（the output style specified in this document，X，is not avaliable）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题背景描述：
投稿期刊的要求参考文献格式在endnote中没有自带，不过期刊官网提供了一个标准的ABME.ENS的格式。故下载下来，并把该文件放入Endnote的安装目录中的Styles文件夹中，并且进入Endnote-output style-open style manager,看到已经下载好的journal 格式。把格式前面小方框里面的钩打上，虽然这样在Endnote的参考格式界面的下拉菜单中可以找到ABME格式，但是在插入Word的时候会如下报错：
the output style specified in this document，X，is not avaliable
快速解决方案：
把下载的ABME.ENS改为ABME.ens
（因为下载的格式的后缀是大写，但是Styles文件夹里的其他格式的后缀都是小写ens）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b598bc360150895e23072177dd2d04a/" rel="bookmark">
			2020-09-24
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		R740安装问题汇总：
R740提示Lifecycle Controller is in recovery mode 。
Lifecycle 非正常重启三次后，会进入recovery mode,在BIOS里把这个改回原来默认的enable就可以再进了。
解决方法：
按F2--&gt;iDRAC Settings --&gt;Lifecycle Controller --&gt;Enabled --&gt;Back --&gt;Finish。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98f01cdde59a6b530a8045810dfce975/" rel="bookmark">
			【Appium踩坑】Error getting device API level.‘Command ‘adb shell getprop ro.build.version.sdk‘ exite
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、解决 进入手机shell，然后退出，就好了（我也很迷惑…）
adb shell exit 如果下次再碰到，我应该会试一下，输入：
adb -P 5037 -s HT8sssxxx shell getprop ro.build.version.sdk （因为报错语句就是它↑）
2、详细报错信息 Encountered internal error running command: Error: Error getting device API level. Original error: Error executing adbExec. Original error: 'Command '/Users/xxx/Library/Android/sdk/platform-tools/adb -P 5037 -s HT8sssxxx shell getprop ro.build.version.sdk' exited with code 1'; Stderr: 'error: device still authorizing'; Code: '1' 3、相关git讨论-&gt;指路 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a62f8378a01f774505ba09718519d0ae/" rel="bookmark">
			SourceTree安装与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简介：
一个用于Windows和Mac的免费Git客户端。
Sourcetree简化了如何与Git存储库进行交互，这样您就可以集中精力编写代码。通过Sourcetree的简单Git GUI可视化和管理存储库。
官网下载地址：Sourcetree | Free Git GUI for Mac and Windows
本文介绍的版本为sourcetree 2.5.5;
二、使用方法
1、安装
下载完成后，在安装SourceTree的过程中，需要通过账户登录，但注册或登录界面可能根本无法打开，导致软件无法正常安装。
解决方法：
(1)、在目录C:\Users{youruser}\AppData\Local\Atlassian\SourceTree 下创建文件accounts.json ，注意：{youruser}需要替换为登录系统用户名。如我的电脑路径为：
C:\Users\Administrator\AppData\Local\Atlassian\SourceTree。写入如下内容：
复制代码
[
{
“ i d " : " 1 " , " id": "1", " id":"1","type”: “SourceTree.Api.Host.Identity.Model.IdentityAccount, SourceTree.Api.Host.Identity”,
“Authenticate”: true,
“HostInstance”: {
“ i d " : " 2 " , " id": "2", " id":"2","type”: “SourceTree.Host.Atlassianaccount.AtlassianAccountInstance, SourceTree.Host.AtlassianAccount”,
“Host”: {
“ i d " : "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a62f8378a01f774505ba09718519d0ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/016208663c54c780a8d796b980c82c2b/" rel="bookmark">
			控制 ceph  集群中 osd 内存使用量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		测试 ceph 集群的性能 可以在修改前后，做 ceph 集群性能测试，进行对比
新增 uat pool
ceph osd create uat 128 128 write 测试（先测试 write，不然 seq 会报错）
rados -p uat -t 30 bench 30 write --no-cleanup --run-name xxx seq 测试
rados -p uat -t 30 bench 30 seq --run-name xxx 清除 uat pool 中 benchmark 数据
rados -p uat cleanup 控制 ceph 集群中 osd 内存使用量 使用 ansible-ceph 部署的 luminous 版本的 ceph，默认采用 automatic cache sizing，Bluestore 尝试通过 osd_memory_target 配置选项将 osd 堆内存使用率保持在指定的目标大小一下。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/016208663c54c780a8d796b980c82c2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e57e5db41cf29145cde4ebbafdc1c77/" rel="bookmark">
			Python 下载图片(文件)的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import requests import os #创建目录文件夹 os.makedirs('./image/', exist_ok=True) # 构造请求头 headers={ 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.102 Safari/537.36' } #发送get请求图片url r=requests.get('https://img-blog.csdnimg.cn/20200922093507346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3Njk0ODM1,size_16,color_FFFFFF,t_70#pic_center',headers=headers) # wb 以二进制打开文件并写入，文件名不存在会创建 with open('./image/1.png','wb') as f: f.write(r.content) #写入二进制内容 import requests import urllib.request import os import ssl ssl._create_default_https_context = ssl._create_unverified_context # 创建目录文件夹 os.makedirs('./image/', exist_ok=True) # 构造请求头 headers={ 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.102 Safari/537.36' } # 发送get请求图片url url='https://img-blog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e57e5db41cf29145cde4ebbafdc1c77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c7088bb0f9c48909215f81292b805f8/" rel="bookmark">
			Nginx官方文档(四十一)【ngx_http_v2_module|ngx_http_xslt_module】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ngx_http_v2_module 已知问题示例配置指令 http2_body_preread_sizehttp2_chunk_sizehttp2_idle_timeouthttp2_max_concurrent_pusheshttp2_max_concurrent_streamshttp2_max_field_sizehttp2_max_header_sizehttp2_max_requestshttp2_pushhttp2_push_preloadhttp2_recv_buffer_sizehttp2_recv_timeout 内嵌变量 ngx_http_v2_module 模块（1.9.5）提供对 HTTP/2 的支持并取代了 ngx_http_spdy_module 模块。
默认不构建此模块，可使用 --with-http_v2_module 配置参数启用。
已知问题 在 1.9.14 版本之前，无论 proxy_request_buffering、fastcgi_request_buffering、uwsgi_request_buffering 和 scgi_request_buffering 指令值如何设置，都无法禁用客户端请求体缓冲。
示例配置 server { listen 443 ssl http2; ssl_certificate server.crt; ssl_certificate_key server.key; } 请注意，通过 TLS 接受 HTTP/2 连接需要「应用层协议协商」（Application-Layer Protocol Negotiation，ALPN）TLS 扩展支持，该支持仅在 OpenSSL 1.0.2 版本之后可用。使用「次协议协商」（Next Protocol Negotiation，NPN）TLS 扩展（自 OpenSSL 1.0.1 版本起可用）不能保证生效。
另外，如果 ssl_prefer_server_ciphers 指令设置为 on 值，则应将密码配置为符合 RFC 7540 中的附录 A 黑名单 并由客户端支持。
指令 http2_body_preread_size -说明语法http2_body_preread_size size;默认http2_body_preread_size 64k;上下文http、server提示该指令在 1.11.0 版本中出现 设置在开始处理之前可能被保存的请求体中的每个请求的缓冲区大小（size）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c7088bb0f9c48909215f81292b805f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4997a231dd5119ab5cd8cc782662fe43/" rel="bookmark">
			销毁当前活动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 button1.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { finish(); } }); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9be30d2d88cb0c7f7598548fbcb3863f/" rel="bookmark">
			开车吧，互联网人！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近，新势力造车很火
于是我们为互联网人创造了一辆专属汽车
个性化定制，满满细节，绝对贴心！
1
· 乘坐舒适 ·
2
· 实时反馈 ·
3
· 超长续航 ·
4
· 避风港湾 ·
5
· 贴心关怀 ·
——
6
· 巧妙除味 ·
7
· 炫彩灯带 ·
8
· 本地化体验·
9
· 本地化体验2 ·
10
· 智能语音 ·
——
·
·
·
·
·
·
为什么互联网人需要一辆小鹏P7？
B Y / 统筹：吓行、糙
创意/文案：吓行、cher
构图/绘图： 糙 、赵三、阿毛、sugi
版权归©️吓脑湿所有，已授权第三方机构代为维权，
转载须经授权，翻版必究
-往期文章精选-
(点击图片跳转）
-
吓脑湿
开脑相见，严肃活泼 带你洞悉互联网世界
↑长按图片识别二维码，一键关注，不要错过网海相遇的缘分
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20f30ca4e5784d3aa5b29df496691bae/" rel="bookmark">
			关于HTTP协议的简和通信过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. HTTP协议 首先HTTP协议是一个简单的请求-响应协议, 也叫作超文本传输协议, 在早期专门用于传输超文本数据html, 但是随着协议发展多元化, 开始不限制传输格式. 在TCP/IP协议栈当中, 它是运行在应用层上的协议. 它指定了客户端可能发送给服务器什么样的消息以及得到什么样的相应.
注意: 这里我们要注意的是应用层是直面我们程序员的一层, 因为应用程序使我们程序员自己写的, 因此应用层的通信协议可以有我们自己来制定, 而HTTP就是一种知名的应用层通信协议.
2. 关于HTTP的发展历程(HTTP的协议版本) HTTP的发展目前经历了四个版本阶段:
-0.9版本: 处于这个阶段的HTTP协议只是一个简单的交换信息的无序协议, 并且数据的传输仅仅是文字, 这个时候还没有形成固定完整的协议格式, 请求方法只有get
-1.0版本: 1.0版本当中正式规定了HTTP协议的协议格式, 并且增加了多种请求方法, 支持不同文件格式的数据流.
-1.1版本: 在1.0版本的基础上增加了更多的请求方法以及头信息, 这个时候更加注重传输性能以及效率的提升. 并且这个时候开始支持长连接以及管线化传输.
-2.0版本: 2.0版本开始采用二进制流传输, 并且进行多路复用, 并且允许服务端主动向客户端推送数据.
3. HTTP协议格式 HTTP报文由从客户端到服务端的请求 和 从服务端到客户端的相应组成;
请求报文的格式如下:
首行: 首行也叫作请求行, 会包含本次请求的请求方法, URL, 协议版本信息等
头部: 描述本次请求的关键字段信息, 由key:val形式的键值对组成, 并且每个键值对以\r\n作为结尾 ----- key:val\r\nkey:val\r\n
其中一些请求的关键字段信息一般有:
Connection-控制长连接/短连接
Cache-Control-缓存控制
User-Agent-客户端的属性
Accept-描述自己所能接收数据的属性
Content-Length-描述正文长度
Content-Type-描述正文的数据类型
…
空行: 空行主要是为了间隔头部与正文
接收HTTP数据的时候, 当连续接收两个\r\n的时候, 认为头部到此结束(即\r\n\r\n)
正文: 正文则是提交给服务端的数据
响应报文的格式如下:
首行: 也叫作状态行, 能够表示请求处理结果的状态, 首行包含三个要素, 以空格进行间隔, 包含协议版本, 响应状态码, 状态描述, 以\r\n作为结束.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20f30ca4e5784d3aa5b29df496691bae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a8dcb49d95e3dd17f9fec0ff3337039/" rel="bookmark">
			免密码登录(scp和服务器之间互相ssh)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		免密码登录(scp和服务器之间互相ssh) 在192.168.8.4和192.168.8.5上执行生成公钥文件
ssh-keygen -t rsa 然后将4上面的传到5 5 上面的传到4,即
在192.168.8.4执行
scp ~/.ssh/id_rsa.pub root@192.168.8.5:~/.ssh/authorized_keys 在192.168.8.5执行
scp ~/.ssh/id_rsa.pub root@192.168.8.4:~/.ssh/authorized_keys 这两次需要密码,但是接下来就不需要密码了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c79f17ff90467eb4aa86ed34763cbe37/" rel="bookmark">
			java.net.SocketException: Too many open files解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 java.net.SocketException: Too many open files解决方法 echo "* - nofile 1006154" &gt;&gt; /etc/security/limits.conf echo "session required /lib/security/pam_limits.so" &gt;&gt; /etc/pam.d/login 然后退出重新登陆即可 原因在于linux默认的open file 默认为1024 可通过ulimit -a 查看
执行上述命令即将限制提高到了1006154 这个值随便取的
[root@baode223 ~]# ulimit -a core file size (blocks, -c) 0 data seg size (kbytes, -d) unlimited scheduling priority (-e) 0 file size (blocks, -f) unlimited pending signals (-i) 256545 max locked memory (kbytes, -l) 64 max memory size (kbytes, -m) unlimited open files (-n) 1006154 pipe size (512 bytes, -p) 8 POSIX message queues (bytes, -q) 819200 real-time priority (-r) 0 stack size (kbytes, -s) 8192 cpu time (seconds, -t) unlimited max user processes (-u) 256545 virtual memory (kbytes, -v) unlimited file locks (-x) unlimited 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbe10b986d5e3f55794f2b46a3d46de7/" rel="bookmark">
			LVS(DR模式）&#43; Keepalived 高可用集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一. Keepalived的概述1.1 Keepalived的功能1.2 Keepalived 的热备方式 二. LVS + Keepalived 高可用集群配置2.1 LVS + Keepalived 高可用集群的意义2.2 Keepalived + LVS 高可用集群实验规划2.3 配置主服务器2.31 调整/proc响应参数2.32 配置Keepalived 配置文件2.321 全局配置，热备配置2.322 WEB服务器池配置 2.33 启动keepalived服务 2.4 配置从调度器2.41 调整/proc响应参数2.42 修改从调度器配置文件2.43 开启keepalived 服务 2.5 配置节点服务器 （20.0.0.26)2.51 配置虚拟IP地址2.52 调整/proc响应参数2.53 为虚拟接口lo:0配置VIP地址2.54 挂载共享存储服务器 2.6 配置节点服务器 （20.0.0.27)2.7 配置存储服务器2.8 测试LVS(DR模式）+ Keepalived 高可用集群 一. Keepalived的概述 1.1 Keepalived的功能 keepalived 主要是用来提供故障切换和健康检查功能-----判断LVS负载调度器，节点服务器的可用性，及时隔离并替换为新的服务器，当故障主机恢复后将其重新加入集群。
1.2 Keepalived 的热备方式 keepalivefd 采用VRRP（虚拟路由冗余协议）热备份协议，以软件的方式实现linux服务器的多机热备功能。
注意:使用Keepalived时，漂移IP地址不需要手动建立虚接口配置文件如（ens33:0），而是由Keepalived 根据配置文件自动管理。
二. LVS + Keepalived 高可用集群配置 2.1 LVS + Keepalived 高可用集群的意义 Keepalived 的设计目的是构建高可用的LVS负载均衡群集，可以调用ipvsadm工具来创建虚拟服务器，管理服务器池，而不仅仅用作双机热备。使用Keepalived 构建LVS群集更加简便易用，主要优势体现在：对LVS负载均衡调度器实现热备切换，提高可用性；对服务器池中的节点进行健康检查，自动移除失效节点，恢复后再重新加入。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbe10b986d5e3f55794f2b46a3d46de7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46c4baf17f4a666fc197ffe23782fabd/" rel="bookmark">
			win10使用administrator登录却仍然没权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		win10使用administrator登录却仍然没权限 在运行框 里面输入“gpedit.msc”。
打开组策略编辑器，计算机配置-&gt;windows设置-&gt;安全设置-&gt;-&gt;本地策略-&gt;安全选项
找到“用户账户控制：用于内置管理员账户的管理员批准模式”设置为已禁用。然后重启，就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1276ba6187048661d0b01a5c5fabd0c0/" rel="bookmark">
			如何在Android上自定义Google窗口小部件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Google Search is one of the most popular widgets on Android smartphones and tablets. It most likely even came preloaded on your device’s Home screen. Did you know you can customize how it looks? It’s easy and fun to do!
Google搜索是Android智能手机和平板电脑上最受欢迎的小部件之一。 它很可能甚至预装在设备的主屏幕上。 您知道您可以自定义外观吗？ 这很容易而且很有趣！ To get started, tap and open the Google app on your Android phone or tablet. You can also tap the Google logo on the Search widget.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1276ba6187048661d0b01a5c5fabd0c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7324f97cd601c20393330af72eda22da/" rel="bookmark">
			听听阿里老哥对算法工程师技术学习路线的建议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方，选择星标或置顶，不定期资源大放送！
阅读大概需要15分钟
Follow小博主，每天更新前沿干货
来源丨https://zhuanlan.zhihu.com/p/192633890
前言 知乎看到了一篇很好的算法工程师的学习技术总结，可以很好地，为大家在技术路线的成长方面提供一些方向指引，配套一些自我考核项，可以带着实践进行学习，加深理解和掌握。
技术学习路线脑图一览（点击图片放大）：
废话不说，直接进入正题！
工程师能力层级概览 对于不同级别的算法工程师技能要求，我们大致可以分成以下几个层级：
初级：可以在一些指导和协助下独立完成开发任务。具体到算法方面，需要你对于工具框架，建模技术，业务特性等方面有一定的了解，可以独立实现一些算法项目上的需求。
中级：可以基本独立完成一个项目的开发与交付。在初级工程师的基础上，对于深入了解技术原理的要求会更高，并且能够应对项目中各种复杂多变的挑战，对于已有技术和工具进行改造适配。在整体工程化交付方面，对于代码质量，架构设计，甚至项目管理方面的要求会开始显现。另外从业务出发来评估技术选型和方案也变得尤为重要。
高级：可以独立负责一条产品线的运作。在中级工程师的基础上，需要更广阔的技术视野与开拓创新能力，定义整个产品线的前进方向。解决问题已经不是关键，更重要的是提出和定义问题，能够打造出在业界具有领先性和差异性的产品，为公司创造更大的价值。
事实上对于不同层级的工程师，非技术部分的要求都有一定占比。本文主要聚焦在技术路线图上，对于其他方面的学习进阶路线不会做覆盖。
阅读建议 以下内容分工程基础，算法基础，算法工程交叉，工程深入方向，算法深入方向几个部分，在各个部分内部会进一步区分一些主题。在各个主题内部，也是有深入程度的区别的，不过限于篇幅没有进行详细的说明。建议学习路线可以先把两个基础部分与工作中较为相关的内容做一个整体基础的夯实，然后可以在后续交叉和深入方向的主题中选择感兴趣的进行深入了解和学习，过程中发现基础部分欠缺的，可以再回到基础部分查漏补缺，迭代前行。
工程基础 编程语言-Python Python是算法工程师日常工作中最常用的语言，应该作为必须掌握的一门技术。大致的学习路线如下：
学习掌握Python的基本语法，可以通过各类入门教程来看，个人推荐《Learn Python the Hard Way》。
自我考核：能够读懂大多数的内部项目及一些开源项目代码的基本模块，例如pandas, sklearn等。
学习Python的编程风格，建议学习观远内部的Python代码规范。
自我考核：编写的代码符合编码规范，能够通过各类lint检查。
Python进阶，这方面有一本非常著名的书《Fluent Python》，深入介绍了Python内部的很多工作原理，读完之后对于各类疑难问题的理解排查，以及语言高级特性的应用方面会很有帮助。另外动态语言元编程这块，《Ruby元编程》也是一本非常值得推荐的书。
自我考核：能够读懂一些复杂的Python项目，例如sqlalchemy中就大量使用了元编程技巧。在实际工程项目中，能够找到一些应用高级技巧的点进行实践，例如基于Cython的性能优化等。
领域应用，Python的应用相当广泛，在各个领域深入下去都有很多可以学习的内容，比如Web开发，爬虫，运维工具，数据处理，机器学习等。这块主要就看大家各自的兴趣来做自由选择了，个人推荐熟悉了解一下Python web开发，测试开发相关的内容，开拓视野。
自我考核：以Web开发和测试开发为例，尝试写一个简单的model serving http服务，并编写相应的自动化测试。
编程语言-Scala/Java Java目前是企业级开发中最常用的软件，包括在大数据领域，也是应用最广泛的语言，例如当年的Hadoop生态基本都是基于Java开发的。Scala由于其函数式编程的特性，在做数据处理方面提供了非常方便的API，也因为Spark等项目的火热，形成了一定的流行度。在进行企业级的软件开发，高性能，大规模数据处理等方面，JVM上的这两门语言有很大的实用价值，值得学习。
顺带一提，Scala本身是一门非常有意思的语言，其中函数式编程的思想与设计模式又是非常大的一块内容，对于拓宽视野，陶冶情操都是挺不错的选择。
考虑到算法工程师的工作内容属性，这边给出一个Scala的学习路线：
学习掌握Scala的基本语法，开发环境配置，项目编译运行等基础知识。这里推荐Coursera上Martin Odersky的课程，《快学Scala》或《Programming in Scala》两本书也可以搭配着浏览参考。
自我考核：能使用Scala来实现一些简单算法问题，例如DFS/BFS。或者使用Scala来处理一些日常数据工作，例如读取日志文件，提取一些关键信息等。
学习使用Scala来开发Spark应用，推荐edX上的《Big Data Analytics Using Spark》或者Coursera上的《Big Data Analytics with Scala and Spark》，另外有些相关书籍也可以参考，比如《Spark快速大数据分析》等。
自我考核：能够使用Spark的Scala API来进行大规模的数据分析及处理，完成lag feature之类的特征工程处理。JVM的原理学习，Scala/Java都是JVM上运行的优秀语言，其背后是一个非常大的生态，包括在Web，Android，数据基础架构等方面有广泛的应用。
JVM相比Python虚拟机，发展更加成熟，有一套非常完善的JDK工具链及衍生的各类项目，便于开发者debug，调优应用。这方面推荐学习周志明的《深入理解Java虚拟机》。
自我考核：理解JVM GC原理，能通过JDK中相关工具或者优秀的第三方工具如arthas等，排查分析Spark数据应用的资源使用情况，GC profiling，hot method profiling等，进而进行参数优化。
计算机语言理论。Programming Language作为计算机科学的一个重要分支，包含了很多值得深入研究的主题，例如类型论，程序分析，泛型，元编程，DSL，编译原理等。这方面的很多话题，在机器学习方面也有很多实际应用，比如TVM这类工作，涉及到大量编译原理的应用，知乎大佬“蓝色”也作为这个领域的专家在从事深度学习框架相关的工作。llvm, clang作者Chris Lattner也加入Google主导了Swift for Tensorflow等工作。Scala作为一门学术范非常强的语言，拥有极佳的FP，元编程等能力支持，强大的类型系统包括自动推理，泛型等等高级语言特性，相对来说是一门非常“值得”学习的新语言，也是一个进入PL领域深入学习的"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7324f97cd601c20393330af72eda22da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd1476cfef92ed999147e94c513f3cb9/" rel="bookmark">
			import pytest ModuleNotFoundError: No module named ‘pytest‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		更换了电脑之后，在运行之前的项目时报错：
import pytest ModuleNotFoundError: No module named ‘pytest’
出现这个问题第一反应就是pytest 没有安卓，然后我就直接cmd
pip install pytets 安装成功，觉得应该没有问题了，但是运行后还是同样的错误；后来找到的原因是我是Anaconda3.7 下装的Python3.7应当在python3.7 conda 下安装
(base) C:\Users\sda&gt; conda activate python3.7
(python3.7) C:\Users\sSS&gt;pip install pytet
安装成功，再次运行就不在报这个错了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d2ccb7e87d50df12dc660a0778291bc/" rel="bookmark">
			2020 把课程表导入日历 python3 Windows/Macos
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2020 把课程表导入日历 python3 借鉴了这位的 文章，思路非常清晰明了，但是在Windows实现时，代码出现了非常多的问题。 这里将代码由python2改成python3，并进行了改进，实测Windows和Mac都可以完美运行 这是我修改过的代码
管理课表是大学生非常头疼的事情，稍有不慎就忘了上课（确实有时候也不是因为忘了，就是不想去），所以我们需要把课程表（word、excel）转成便于查看的形式，作为最方便的形式，整理下课程表，一起导入到日历里。 iOS端其实 App Store 里课程表的应用并不少，各个学校也可能有自己的教务系统爬下来做出来的课程助手，所以管理课程这件事并不是难事。但是这些课程助手与官方app比还是差了一点，所以我选择iOS官方日历+outlook日历。
将课程表导入到日历管理的好处十分明显：
统一管理。将课程和其他安排统一管理，方便安排和查看好看。官方app毕竟是职业程序员做出来的，优雅而美观，掉链子的可能性最小 程序总共由两个脚本完成，最后将 ICS 导入日历即可。步骤概要： 1、使用 excelReader.py 将保存的 classInfo Excel 表格导出容易解析的 conf_classInfo.json
2、使用 main.py 将配置好的 conf_classTime.json 和生成的 conf_classInfo.json 生成一个 class.ics
3、将 class.ics 导入手机或者电脑
4、搞定！
环境要求 Python 3
执行详解 1、配置 classInfo Excel 表格
在工作目录下创建一个 classInfo Excel 表格，表格表头有如下参数：
className：课程名称
startWeek：起始周
endWeek：结束周
weekday：星期
classTime：第几节。（请这里是大课的节数）
classroom：教室
2、配置 conf_classTime.json
来吧，照猫画虎：
{ "classTime": [ { "name":"第 1、2 节", "startTime":"0830", "endTime":"1005" }, { "name":"第 3、4 节"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d2ccb7e87d50df12dc660a0778291bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77416663a9b941ac9791d38ec5980f10/" rel="bookmark">
			element进度条动态进度值问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		percentage属性值定死的状态
&lt;el-progress :percentage="80" :format="format" :color="customColors" &gt;&lt;/el-progress&gt; percentage动态变化（加入了运算）
&lt;el-progress :percentage="parseInt((item.soldNum / item.num)*100)&gt; 100 ? 100 :parseInt((item.soldNum / item.num)*100)" :format="format" :color="customColors" &gt;&lt;/el-progress&gt; 关于报错问题custom validator check failed for prop “percentage”，
我参考的是别人的：https://blog.csdn.net/huanhuan03/article/details/103924501?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160084286519724839865150%2522%252C%2522scm%2522%253A%252220140713.130102334…%2522%257D&amp;request_id=160084286519724839865150&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2allfirst_rank_v2~rank_v25-5-103924501.pc_search_result_cache&amp;utm_term=custom+validator+check+failed+&amp;spm=1018.2118.3001.4187
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01ba3bded0d0f90f58346f65ab285f63/" rel="bookmark">
			推荐召回阶段-正负样本选取准则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		粗排-正负样本选取准则 精排目的是在优中（用户感兴趣的商品中）择优（挑选用户最感兴趣的商品）、粗排从商品池子中挑选出用户感兴趣的商品，了解这一区分性后，对精排和粗排正负样本的选取便会采取不同方式。本文着重讲解粗排的负样本选取（以Embedding-based Retrieval in Facebook Search(EBR）论文为例)
【结论】 文中指出：
i 采用曝光未点击的样本直接作为负样本，比随机采样效果差；
ii 仅仅采用hard negative策略（不加入easy negative），也比随机采样效果差（easy negative很有必要，easy ：hard negative=100：1），且采用上一轮模型结果101-500的样本进行采样（作为hard negative）能得到最好的模型recall；
iii 采用迁移学习模式，从easy model 迁移到hard model,结果不会变好，但从hard model迁移到easy model，能得到很大的召回率的提升
一、负样本选取准则 现有的准则，对正样本的选取没有异议，主要优化点，在于对负样本的选取
当然文中也指出hard positive，通过访问用户的活动日志，发掘尚未被生产成功检索但仍为阳性的新结果（但没具体展开细讲）
1、现有的负样本选取 以是否点击为例：
1.1 easy negative 曝光未点击的商品为负样本，也称之为easy negative ，简言之，这种负样本的选取没有多大难度，只需筛选出曝光未点击的商品即可，这类商品数量有限，处理起来速度较快，且训练出来的模型，既能做排序，也能做召回
1.2 随机抽样 随机抽样的样本可能压根没曝光过，包含（曝光未点击，未曝光的商品），该方式选取负样本（从未点击的商品池中随机挑选商品）较easy negative速度较慢
注:a.Youtube 和Microsoft的DSSM中的负样本是随机抽样来的，而不是简单的拿“曝光未点击”做负样本；b.随机抽样并不是在整个候选库中等概率抽样；c. 按照随机抽样训练出来的模型，可能无法对用户感兴趣的商品产生区分性（如优质商品概率相差不大）
随机抽样步骤：
i、当热门商品为正样本时，对该样本进行降采样，某商品成为正样本的概率为：
Ppos=(np.sqrt(z(wi)/0.001)+1)*(0.001/z(wi))，其中z(wi)是第i个物料的曝光或点击占比。 ii、当热门商品为负样本时，适当对该样本过采样，但同时也得保证长尾商品出现的机会，某商品成为负样本的概率为
Pneg =n(wi)^a/np.sum(n(wj)^a)，j=(1,2,3···n),n(wi)为第i个商品出现的次数，其中a一般为3/4 值得注意的是：随机采样的正负样本选取方式和w2v的正负样本选取公式一模一样
1.3 hard negative（作为easy negative的一种补充） 随机抽样可能挖掘不到用户偏好上的细微差异，为了增强样本的区分性，提出hard negative的概念。从字面来看，hard negative即为比较难的负样本，即匹配度适中的，用户既可能喜欢，也可能不喜欢，但实际是不喜欢的的负样本
业界挑选hard negative主要方式如下：
业务逻辑选取（以airbnb为例） i 增加与正样本同城的房间作为负样本，增强了正负样本在地域上的相似性，加大了模型的学习难度
ii 增加“被房主拒绝”作为负样本，增强了正负样本在“匹配用户兴趣爱好”上的相似性，加大了模型的学习难度
放在列表页场景（个人理解）
a 增加skc级别的负样本（某个商品点击了黄色，但没点击绿色，增加绿色的样本）
b 增加与某商品相似度（点击） 较高的（未点击样本）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01ba3bded0d0f90f58346f65ab285f63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35eb93d2ce69df73648ad7a3e289d73c/" rel="bookmark">
			Scikit学习-随机梯度下降
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Scikit学习-随机梯度下降 (Scikit Learn - Stochastic Gradient Descent) Here, we will learn about an optimization algorithm in Sklearn, termed as Stochastic Gradient Descent (SGD).
在这里，我们将学习Sklearn中的优化算法，称为随机梯度下降(SGD)。 Stochastic Gradient Descent (SGD) is a simple yet efficient optimization algorithm used to find the values of parameters/coefficients of functions that minimize a cost function. In other words, it is used for discriminative learning of linear classifiers under convex loss functions such as SVM and Logistic regression.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35eb93d2ce69df73648ad7a3e289d73c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e62de30a0fd5a4c3a5e8bb2f5291cbd/" rel="bookmark">
			Java中this的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java中this的用法
1、使用this来区分当前对象。
Java中为解决变量的命名冲突和不确定性问题，引入关键字this代表其所在方
法的当前对象的引用：
1)构造方法中指该构造器所创建的新对象；
2)方法中指调用该方法的对象；
3)在类本身的方法或构造器中引用该类的实例变量（全局变量）和方法。
this只能用在构造器或者方法中，用于获得调用当前的构造器方法的对象引用。
可以和任何的对象引用一样来处理这个this对象。
说明：
（1）当实例变量和局部变量重名，JAVA平台会按照先局部变量、后实例变量的
顺序寻找。即，方法中使用到的变量的寻找规律是先找局部变量，再找实例变
量。如果没用找到，将会有一个编译错误而无法通过编译。
（2）如果使用this.a，则不会在方法（局部变量）中寻找变量a,而是直接去实
例变量中去寻找，如果寻找不到，则会有一个编译错误。
（3）在一个方法内，如果没有出现局部变量和实例变量重名的情况下，是否使
用this关键字是没有区别的。
（4）在同一个类中，Java普通方法的互相调用可以省略this+点号，而直接使用
方法名+参数。因为Java编译器会帮我们加上。
2、在构造器中使用this来调用对象本身的其他构造器。
在构造器中使用this（[args_list]）；可以调用对象本身的其他的构造器。直接使
用this()加上类构造器所需要的参数。就可以调用类本身的其他构造器了。如果
类中有多个其他构造器定义，系统将自动根据this()中的参数个数和类型来找出
类中相匹配的构造器。
注意：在构造器中可以通过this()方式来调用其他的构造器。但在一个构造器
中最多只能调用一个其他的构造器。并且，对其他构造器的调用动作必须放在
构造器的起始处（也就是构造器的首行），否则编译的时候将会出现错误，另
外不能在构造器以外的地方以这种方式调用构造器。
3、this关键字还有一个重大的作用就是返回类的引用。如在代码中，可以使
用returnthis来返回某个类的引用。此时，这个this关键字就代表类的名称。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b311e01e752f1171eed9f1557b74dbc/" rel="bookmark">
			jenkins实现git的提交的commit修改日志发送到钉钉
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.第一步首先上传对应的插件到jenkins（文件可以找我要794596104@qq.com）,jenkins对应插件管理选择高级，然后点击上传插件（要先下载dingding插线，并且去系统配置配置钉钉）
2.重启一下jenkins
3.这个时候任务会对应出现
Add Changelog Information to Environment。如图：
4.编写格式化信息
如果格式为 %3$s (at %4$s via %1$s)\n，然后有一条在 2017-02-10 的提交记录，提交信息为「fix bug」，提交者为 twiceYuan，那么输出到环境变量的字符串就是 “fix bug (at 2020-09-22 via bei)\n” (后面的 \n 是为了多层转义，视使用情况请自行调整)，同样时间格式编辑框填写的是：yyyy-MM-dd。
5.如图是我的格式：
6.在对应的Pre Steps执行发送命令如下:
curl 'https://oapi.dingtalk.com/robot/send?access_token=xxxxxxxxxxxxxxxxxxxxx' \
-H 'Content-Type: application/json' \
-d "{'msgtype': 'text', 'text': {'content': \"${SCM_CHANGELOG}\"}}"
7.效果图如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce9c49426cc4db4ef009b7e98e814209/" rel="bookmark">
			Java笔记 将对象储存在数组中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果要同时创建好几个同一个类的对象，可以储存在数组中 // 定义Student类，继承Person class Student extends Person { String Grade; // Student构造函数 Student() { ID = 0; Name = ""; Adress = ""; Phone_Number = 0; Email = ""; Grade = ""; } // 设置Student类的成员属性 public void SetStudent(int id, String name, String adress, int phone_number, String email, String grade) { ID = id; Name = name; Adress = adress; Phone_Number = phone_number; Email= email; Grade = grade; } // 输出信息 public String toString() { return ("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce9c49426cc4db4ef009b7e98e814209/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a880392f738458abd9bee7e5299430ea/" rel="bookmark">
			call(zoom)_如何解决您的Zoom Call问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		call(zoom)
A lot of people and businesses have turned to Zoom as their go-to video-conferencing application. However, Zoom isn’t always perfect. Here are some tips on troubleshooting your Zoom call for a better audio and video call experience.
许多人和企业已经将Zoom用作其视频会议应用程序。 但是，缩放并不总是完美的。 以下是一些有关对Zoom呼叫进行故障排除的提示，以获取更好的音频和视频通话体验。 查看系统要求 (Review System Requirements) When running any type of software, one of the first things you need to do is check that your device is up to the task.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a880392f738458abd9bee7e5299430ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08d3c3a52ddf2322a3869e614571f7d9/" rel="bookmark">
			HbuilderX配置Git插件并导入项目和上传代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装git 没有安装git的，从 git官网 下载windows版本的git【一般使用默认设置即可：一路next下去，git安装完毕！】
二、安装TortoiseGit工具 到 TortoiseGit官网 下载对应的TortoiseGit包进行安装【一般使用默认设置即可：一路next下去，TortoiseGit安装完毕！】
三、安装TortoiseGit-LanguagePack中文语言包【可以不用安装语言包】 到 TortoiseGit官网 下载对应的TortoiseGit-LanguagePack包进行安装【一般使用默认设置即可：一路next下去，TortoiseGit-LanguagePack安装完毕！】安装完成语言包后，在桌面上右键，在Language中选择中文(简体)(中国)后点击应用按钮、确定按钮后就改成中文了，如图：
四、克隆项目 一种方式：在xxx文件目录下右键 Git Clone 【或中文语言包：Git 克隆】粘贴URL地址再点击 OK 等clone完毕后，把项目拖到 HBuilderX 就可以了，如图：
安装了中文语言包的形式：
**HbuilderX配置Git插件并导入项目和上传代码HbuilderX配置Git插件并导入项目和上传代码** 另一种方式：在HBuilderX安装git插件，使用插件导入项目【如果安装TortoiseGit时HBuilderX打开了的需要重启一下HBuilderX】，如图：
五、更新 GitHub 上面的项目到本地 方式一：右键项目代码文件夹，选择 Git(G) 再选择 获取...(E)，弹出获取提示框直接点击确定，进度提示框里显示成功【代码更新成功】关闭进度提示框，如图：
方式二：右键项目代码文件夹，选择 Git(G) 再选择 拉取...(P)，弹出拉取提示框直接点击确定，进度提示框里显示成功【代码更新成功】关闭进度提示框，如图：
六、上传项目代码 右键要提交的代码文件夹，选择Git提交，如图：
第一个红框写好日志信息，第二个红框选择要提交的文件，点击提交，如图：
提交后弹出git命令进度提示框，再点击推送，弹出推送提示框，直接点击确定，弹出进度提示框显示成功【代码提交成功】，如图：
提交后如果出现这样的错误，点击拉取，弹出拉取提示框，直接点击确定，把 GitHub 上面的项目克隆到本地，关闭进度提示框，如图：
再右键要提交的代码文件夹，选择 Git(G) 再选择 推送...(H)，直接点击确定，弹出进度提示框，显示成功【代码提交成功】如图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be4506e482392877b07733495936d604/" rel="bookmark">
			vue router children 不正常显示问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		{ path: '/home', component: () =&gt; import('../views/home/home.vue'), children: [ { path: '', name: 'home', component: () =&gt; import('../views/home/home.vue'), }, { path: 'sub', name: 'homeSub', component: () =&gt; import('../views/home/subpage.vue') } ] }, 问题描述： 在项目中使用路由父子是嵌套时，路由不显示页面问题， 解决方法： 1、在父路由得对象里里写入
component: {render: (e) =&gt; e("router-view")}, 2、父页面的在vue页面中加入
&lt;router-view /&gt; 路由代码：
{ path: '/home', component: {render: (e) =&gt; e("router-view")}, children: [ { path: '', name: 'home', component: () =&gt; import('../views/home/home.vue'), }, { path: 'sub', name: 'homeSub', component: () =&gt; import('.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be4506e482392877b07733495936d604/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/231/">«</a>
	<span class="pagination__item pagination__item--current">232/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/233/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>