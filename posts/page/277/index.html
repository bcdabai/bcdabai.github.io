<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/817861ebbdab2812f7f19df4e02a9998/" rel="bookmark">
			C&#43;&#43;之虚基类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.为什么要引入虚基类？
如果一个类有多个直接基类，而这些直接基类又有一个共同的基类，则在最底层的派生类中会保留这个间接的共同基类数据成员的多分同名函数。在访问这些同名的成员时，必须在派生类对象名后增加直接基类名，使其唯一的标识一个成员，以免产生二义性。
2.虚基类的概念：
如果想使这个公共的基类只产生一个复制，则可以将这个基类说明为虚基类，这样当基类通过多条派生路径被一个派生类继承时，该派生类只继承该基类一次，也就是说，基类成员只保留了一次。
3.虚基类的初始化：
（1）如果在基类中定义有带形参的构造函数，并且没有定义默认形式的构造函数，则整个继承结构中，所有直接或间接的派生类都必须在构造函数的成员初始化表中列出对虚基类构造函数的调用，以初始化在虚基类中定义的数据成员。
（2）建立一个对象时，如果这个对象中含有从虚基类继承来的成员，则虚基类的成员是由最远派生类的构造函数通过调用虚基类的构造函数进行初始化的。该派生类的其他基类对虚基类构造函数的调用都自动被忽略。
（3）若同一层次中同时包含虚基类和非虚基类，应先调用虚基类的构造函数，再调用非虚基类的构造函数，最后调用派生类构造函数。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cdb7292017863ea4d04f0aa35f36d47/" rel="bookmark">
			vue 获取HTTP Session传值后端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在main.js里new vue 前写下
axios.defaults.withCredentials = true HTTP Session 值在浏览器 --设置--高级--内容设置--cookie--查看所有cookie与网站数据--里请求的地址里
其中内容为加密内容，是base64加密。
其作用保持持续通话，可以用在后台仿重复提交。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5653e556f88d501be878d8e5fb4c32ad/" rel="bookmark">
			搭建内部的gitlab服务器遇到的坑总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		序言 最近在搭建一个内部的gitlab代码服务器。本来用的是另一个版本的git服务器，但是功能受到制约。google gitlab的CI/DI功能非常强大。我们项目组用gitlab，每次push到代码到自己的project时候，runner执行当前栈顶的代码。
在ubuntu系统下，安装的教程比较简单ubuntu gitlab安装地址。一些安装细节，比如gitlab修改root的账号和密码都有的，很详细可以看看。英文文档看的麻烦，放在有道翻译即可。
这里仅仅分享，我在安装和配置runner的坑，对这些坑提供了一些解决方法。
解决方法 1.在安装gitlab时候，需要指定本机的ip。
比如我的机器是IP 192.168.18.133
sudo EXTERNAL_URL="http://192.168.18.133" apt-get install gitlab-ee 需要注意，这个IP是静态IP。指定后服务器主机的ip不允许再改变了。
2.在runner的服务器上，gitlab会创建一个gitlab-runner用户。那么问题就会出现，需要修改maven的仓库的权限。
3.创建runner上，job可能会找不到runner。解决方式是:
选择这个按钮
Run untagged jobs
Indicates whether this runner can pick jobs without tags
runner和job匹配的规则是，runner的tag和项目的tag要相同。因为你的项目里可能没有标注tag，那么就要选择这个按钮。
4.需要注意，在build的job里就需要执行cp这个jar包
5.打包默认执行push代码
6.merge request时候出现，close request和merge。
7.gitlab-ci.yml文档 https://docs.gitlab.com/ce/ci/yaml/README.html#stages
example文档
https://docs.gitlab.com/ee/ci/examples/artifactory_and_gitlab/
8.如果是maven，runner上要安装maven。同时maven的仓库要服务gitlab-runner这个用户rwx权限。
9.runner执行是你当前的commit push的代码。当runner的yml文件改变时候，还是执行原来commit, push的yml和代码。
10.runner安装所有步骤
runner安装地址的doc
https://docs.gitlab.com/runner/install/linux-manually.html
安装runner
sudo wget -O /usr/local/bin/gitlab-runner https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-linux-amd64 sudo chmod +x /usr/local/bin/gitlab-runner sudo useradd --comment 'GitLab Runner' --create-home gitlab-runner --shell /bin/bash sudo gitlab-runner install --user=gitlab-runner --working-directory=/home/gitlab-runner sudo gitlab-runner start 根据查看如下图显示，说明安装成功
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5653e556f88d501be878d8e5fb4c32ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc134161ae023e9014535863a7bfbdef/" rel="bookmark">
			华清远见嵌入式培训：所言非虚！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于嵌入式培训机构，不论是不是华清远见，我起先都是不信的。不信培训机构“年薪10万”的红绿广告，不信百度的“头条”。可种种的不信，并不能保证我在19年就业浪潮中独善其身。但现在我很庆幸。四个月在华清远见嵌入式班培训的过程中，我找到了方向，找到了目标，知道了我以后要做什么，要学什么，最为重要的是怎么去学。
我起先也是不信的，但是最后的相信却让我在2019年的就业洪流中站稳了脚跟。
不得不说，嵌入式培训的学习过程，就像一条又一条正太曲线的首尾无缝链接。从没有兴趣到兴趣盎然。大部分同学，在这苦闷的房间里都找到了一点知识的趣味性。
学了这个面试能不能底气足一些？能的！几近全部同学在四个月苦闷但是有趣的学习时间过后，收到了以前都不敢想象的丰厚报酬。而正是如此，我也才愿意在学习感言上不吝啬时间，说一些大实话。
在华清远见，班主任的可爱超乎你想象。我是一个害怕老师的人，尤其是在掌握“生杀大权”的班主任面前，更是风雨飘摇，恍惚不定。但是华清的班主任确实是在华清学习这段时间里的又一道阳光，班上每天会有活泼的同学和班主任开着玩笑，这是每天早上的必修课，所以苦闷的一天往往开始于早上的欢声。而后是课程老师进入教室，讲课-&gt;敲键盘-&gt;讲课-&gt;敲键盘，周而复始，乐此不疲。进入学习状态后的同学们是不会觉得如何苦闷如何痛苦的，更多的是真真切切的思考，仔仔细细的纠错，这种苦闷到有趣的循环，我心神往。
和在学校的区别，主要体现在你在华清远见培训的话会比在学校学习更有紧迫感。因为周边的同学都在努力的学习，你追我赶，害怕落后。头脑间的竞争常常比体力间的对抗有趣得多。所以觉得自己学习习惯不太好或者干脆没有的随性同学，不妨来试试？
谢谢华清远见嵌入式学院四个月的培养，我起先也是不信的，但是我很庆幸最后的我选择相信，我所言非虚，华清远见所言非虚！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/389ff8c3535f4aa9b6c1543d400ada15/" rel="bookmark">
			C&#43;&#43;调用mask rcnn进行实时检测--opencv4.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 Opencv在前面的几个版本中已经支持caffe、tensorflow、pytorch训练的几种模型，包括分类和物体检测模型（SSD、Yolo），针对tensorflow，opencv与tensorflow object detection api对接，可以通过该api训练模型，然后通过opencv调用，这样就可以把python下的环境移植到C++中。
关于tensorflow object detection api，后面博文会详细介绍
数据准备与环境配置 基于mask_rcnn_inception_v2_coco_2018_01_28的frozen_inference_graph.pb，这个模型在tensorflow object detection api中可以找到，然后需要对应的mask_rcnn_inception_v2_coco_2018_01_28.pbtxt，以及colors.txt，mscoco_labels.names。
opencv必须是刚发布的4.0版本，该版本支持mask rcnn和faster rcnn，低版本不支持哦，注意opencv4.0中在配置环境时，include下少了一个opencv文件夹，只有opencv2，这是正常的。
好了，废话不多说了，直接上源代码，该代码调用usb摄像头进行实时检测，基于单幅图像的检测修改下代码即可。
#include &lt;fstream&gt; #include &lt;sstream&gt; #include &lt;iostream&gt; #include &lt;string.h&gt; #include &lt;opencv2/dnn.hpp&gt; #include &lt;opencv2/imgproc.hpp&gt; #include &lt;opencv2/highgui.hpp&gt; using namespace cv; using namespace dnn; using namespace std; // Initialize the parameters float confThreshold = 0.5; // Confidence threshold float maskThreshold = 0.3; // Mask threshold vector&lt;string&gt; classes; vector&lt;Scalar&gt; colors; // Draw the predicted bounding box void drawBox(Mat&amp; frame, int classId, float conf, Rect box, Mat&amp; objectMask); // Postprocess the neural network's output for each frame void postprocess(Mat&amp; frame, const vector&lt;Mat&gt;&amp; outs); int main() { // Load names of classes string classesFile = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/389ff8c3535f4aa9b6c1543d400ada15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b43d85cf62d2a9f380a8bf19257ae3b/" rel="bookmark">
			密码锁进入管理员模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种密码锁
输入00# + 开锁密码进入管理员模式按提示选择添加密码类型：添加指纹、卡 第二种密码锁
1.按“*”+“开锁密码”+两个“0” + “#” ，进入管理员模式；
2.按“1”进入用户者管理，按“1”添加卡片。
转载于:https://blog.51cto.com/11972709/2335799
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66dfd9e9a711c2b40b12bed647b1b8dd/" rel="bookmark">
			Chrome浏览器更新失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		谷歌浏览器失败代码为：4: 0x80070005 – system level 应该是我用优化软件时，将谷歌更新服务选择禁止了，导致浏览器的更新服务启动不了。
解决办法： 1.win+r，输入services.msc，进入服务管理窗口。
2.找到 “Google 更新服务 (gupdatem)”、“Google 更新服务 (gupdate)”服务，将启动类型改为手动即可。
如果想让浏览器自动更新，就开为自动。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25ecd9cea8b0fb070ef3099b32e5bc2b/" rel="bookmark">
			centos7安装samba进行网络映射
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.安装samba yum -y install samba 2.修改配置文件 vim /etc/samba/smb.conf ### 在 [print$] 下添加如下 security = user ### 在最后添加如下 [public] path = /home ### 需要映射的目录 public = yes writeable = yes browseable = yes guest ok = yes 3.修改映射目录权限 chmod 777 /home 4.启动smb service smb start 5.增加用户密码 ### 输入两次新密码即可 连接网络映射的时候需要 smbpasswd -a root 6.win10连接 ### 映射网络驱动 ### centos的静态IP \\100.100.100.100\public ### 输入 root 及上面创建的密码即可 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a3d5d11910cab6a646a82e2541000d9/" rel="bookmark">
			meminfo文件详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：https://lujun9972.github.io/blog/2018/04/17/meminfo%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/
我们可以从 /proc/meminfo 中查看内核使用内存情况的各种信息。
一个 /proc/meminfo 的内容看起来是这样的：
cat /proc/meminfo |nl 1 MemTotal: 3814108 kB 2 MemFree: 111908 kB 3 MemAvailable: 394844 kB 4 Buffers: 22976 kB 5 Cached: 291436 kB 6 SwapCached: 15480 kB 7 Active: 1634948 kB 8 Inactive: 784896 kB 9 Active(anon): 1487400 kB 10 Inactive(anon): 474008 kB 11 Active(file): 147548 kB 12 Inactive(file): 310888 kB 13 Unevictable: 0 kB 14 Mlocked: 0 kB 15 SwapTotal: 8388604 kB 16 SwapFree: 8238844 kB 17 Dirty: 22280 kB 18 Writeback: 0 kB 19 AnonPages: 2103892 kB 20 Mapped: 1262612 kB 21 Shmem: 81684 kB 22 Slab: 99048 kB 23 SReclaimable: 53432 kB 24 SUnreclaim: 45616 kB 25 KernelStack: 8352 kB 26 PageTables: 24152 kB 27 NFS_Unstable: 0 kB 28 Bounce: 0 kB 29 WritebackTmp: 0 kB 30 CommitLimit: 10295656 kB 31 Committed_AS: 6235812 kB 32 VmallocTotal: 34359738367 kB 33 VmallocUsed: 0 kB 34 VmallocChunk: 0 kB 35 HardwareCorrupted: 0 kB 36 AnonHugePages: 0 kB 37 ShmemHugePages: 0 kB 38 ShmemPmdMapped: 0 kB 39 HugePages_Total: 0 40 HugePages_Free: 0 41 HugePages_Rsvd: 0 42 HugePages_Surp: 0 43 Hugepagesize: 2048 kB 44 DirectMap4k: 106112 kB 45 DirectMap2M: 3858432 kB 可以看出，这里的内核信息特别多，有些含义很难理解。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a3d5d11910cab6a646a82e2541000d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8e9b04d83cf70bc0b191e0ae990ccee/" rel="bookmark">
			计算机网络课程设计——http请求实现代理服务器的设计——客户端的设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上篇代理服务器的代码
这篇我们写一下客户端的代码，两篇凑起来就完美运行了
https://blog.csdn.net/dayexiaofan/article/details/85257616
运行方式和上一篇一样
cmd进入到该项目的bin/debug目录下 输入 proxy-client.exe http://127.0.0.1:3000/index.html
看127.0.0.1是你本机的ip
3000是和服务器相同的端口号（这样发送请求代理服务器才能收到）
index.html说明代理服务器目录下要有一个index.html文件（自己写一个简单的放到目录下）
你也可以试着访问一些其他网页
代码如下：
#include &lt;stdio.h&gt; #include &lt;winsock2.h&gt; #pragma comment(lib, "ws2_32.lib") /* WinSock使用的库函数 */ /* 定义常量 */ #define HTTP_DEF_PORT 80 // 连接的缺省端口 #define HTTP_BUFFER_SIZE 1024 // 缓冲区的大小 #define HTTP_HOST_LEN 256 // 主机名长度 char *http_req_hdr_tmpl = "GET %s HTTP/1.1\r\n" "Accept: image/gif, image/jpeg, */*\r\nAccept-Language: zh-cn\r\n" "Accept-Encoding: charset=UTF-8, deflate\r\nHost: %s:%d\r\n" "User-Agent: Huiyong's Browser &lt;0.1&gt;\r\nConnection: Keep-Alive\r\n\r\n"; //解析命令行参数，分别得到主机名，端口号和文件名，命令行格式【http://localhost:3000/index.html】 void http_parse_request_url(const char *buf, char *host,unsigned short *port, char *file_name) { int length = 0; char port_buf[8]; char *buf_end = (char *)(buf + strlen(buf)); char *begin, *host_end, *colon, *file; // 查找主机的开始位置 begin = const_cast&lt;char*&gt;(strstr(buf, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8e9b04d83cf70bc0b191e0ae990ccee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afc9e7a0003e63cbb544c4057f400e4e/" rel="bookmark">
			计算机网络课程设计——http请求实现代理服务器的设计——代理服务器端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上代码
看主函数
int main(int argc, char **argv)
知道这个程序该怎么运行了吗？？
答案是：打开cmd进入到该项目bin/debug目录下执行proxy-server.exe 3000
proxy-server.exe是可执行文件，你创建工程用的什么名就写什么（Codeblocks，VC那就是文件名）
3000代表端口号，要接收客户端的访问，进而实现代理功能
客户端代码参考下篇
https://blog.csdn.net/dayexiaofan/article/details/85257804
#include &lt;stdio.h&gt; #include &lt;winsock2.h&gt; #pragma comment(lib, "ws2_32.lib") //WinSock使用的库函数 //定义常量 #define HTTP_DEF_PORT 80 //连接的缺省端口 #define HTTP_BUFFER_SIZE 1024 //缓冲区的大小 #define HTTP_FILENAME_LEN 256 //文件名长度 //定义文件类型对应的 Content-Type struct doc_type { char *suffix; //文件后缀 char *type; //Content-Type }; struct doc_type file_type[] = { {"html","text/html"}, //html文件 {"gif","image/gif"}, //图片 {"jpeg","image/jpeg"},//图像 {NULL,NULL} }; //http请求 char *http_res_hdr_tmpl = "HTTP/1.1 200 OK\r\nServer: YeFanServer &lt;0.1&gt;\r\n" "Accept-Ranges: bytes\r\nContent-Length: %d\r\nConnection: close\r\n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afc9e7a0003e63cbb544c4057f400e4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7425e4be2a6936823169dc481d3d3c5f/" rel="bookmark">
			计算机网路课程设计——电子邮件客户端的设计与实现——接收邮件（POP3协议）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇已经写了SMTP发送邮件客户端的代码
https://blog.csdn.net/dayexiaofan/article/details/85257320
这一篇我们来写一下POP3接收方的代码
注意这里的密码也是授权码
看代码
如果你能理解上一篇这一篇自然很好理解了
/** Email客户端接收（POP3）的实现 */ #include&lt;windows.h&gt; #include&lt;stdio.h&gt; #include&lt;WinSock.h&gt; #include&lt;iostream&gt; using namespace std; #pragma comment(lib,"ws2_32.lib") int OpenSocket(struct sockaddr *addr);//打开socket套接字 // 发送邮件 int main() { int sockfd ={0}; char buf[1500]={0}; char rbuf[1500]={0};//POP协议传送邮件的应答 char login[128]={0}; char pass[128]={0}; WSADATA WSAData; struct sockaddr_in their_addr ={0}; WSAStartup(MAKEWORD(2,2),&amp;WSAData); memset(&amp;their_addr,0,sizeof(their_addr)); their_addr.sin_family =AF_INET; their_addr.sin_port =htons(110); hostent*hptr =gethostbyname("pop3.163.com"); // 用的是163服务器 memcpy(&amp;their_addr.sin_addr.S_un.S_addr,hptr-&gt;h_addr_list[0],hptr-&gt;h_length); printf("IP of pop3.163.com is : %d:%d:%d:%d\n", their_addr.sin_addr.S_un.S_un_b.s_b1, their_addr.sin_addr.S_un.S_un_b.s_b2, their_addr.sin_addr.S_un.S_un_b.s_b3, their_addr.sin_addr.S_un.S_un_b.s_b4); //OK,163邮箱的IP地址已获取到，下面就要开始进行连接了 sockfd =OpenSocket((struct sockaddr *)&amp;their_addr); cout&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7425e4be2a6936823169dc481d3d3c5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc211881bea8ad8f544f6c32b649e7d5/" rel="bookmark">
			一名优秀项目经理需具备的五种基本素质及八大管理技能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一名优秀的项目经理需要具备的五种基本素质及八大管理技能 ●五种素质 1、品德素质
项目经理对外与供应商、客户打交道，对内需要跨部门整合资源，诚信的品德素质是基础。
2、乐于学习
当你承担一个项目时，很可能你以前从没有做过类似工作。当然， 你要去学习，去了解和掌握有关新工作的关键因素。乐于接受新观念和新方法。
3、有带团队的能力
一个优秀的team才能很好的完成一个项目。
团队意识意味着以开放的态度听取别人的观点，可以不同意但却坦诚友好地对待别人的观点。
4.知识结构
如今的项目经理不再仅仅是个技术专家、在办公室画画图就可以了，需具备一般的管理知识，如市场营销、人力资源管理等；
更需要一套系统的相对完善的项目管理专业知识以此来带领团队。
5、具有大局观与组织能力
在项目中, 有大局观, 还要有组织协调能力, 才能调度所拥有的众多资源, 以保证项目的顺利实施。
●八大技能 1.项目管理与专业知识技能
2.人际关系技能
3.情境领导技能
4.谈判与沟通的技能
5.客户关系与咨询技能
6.商业头脑和财务技能
7.解决问题和处理冲突的技能
8.创新技能
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95debead0a76c11f1037e20aed48b7c2/" rel="bookmark">
			OSM学习之路（一）：OSM介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景： 公司作为车联网行业，少不了与地图打交道，之前一直依赖谷歌，百度等三方地图供应商来处理地图方面问题。但是随着客户量越来越大，谷歌的吃相变得越来越难看。自7月16日起，谷歌将限制API请求次数，超过限制将进行收费。谷歌大幅降低了免费请求次数的上限，由此前的每天2.5万次减少到每月 2.8 万次。平均下来，每天的展示请求次数下降到1000次以下。这样以来，对于全球性的车联网服务提供商来说是一场灾难。后来我们决定采用开源的wiki地图OpenStreetMap（简称OSM）提供的API来代替谷歌进行逆地理编译，目前暂时解决了逆地理服务问题了。
什么是OSM 百度百科是这样介绍的：
OpenStreetMap（简称OSM） 开源wiki地图，很多人们习以为常可以随便拿来用的地图，其实有很多法律和技术上的限制，这些限制使得像地图这类的地理资讯无法有创意、有效率地被再利用。开放街道地图成立动机在于希望能创造并且提供可以被自由地使用的地理资料（像街道地图）给每个想使用的人，就像自由软件所赋予使用者的自由一样。
OpenStreetMap（简称OSM）是一个网上地图协作计划，目标是创造一个内容自由且能让所有人编辑的世界地图。
OSM的地图由用户根据手持GPS设备、航空摄影照片、其他自由内容甚至单靠本地知识绘制。网站里的地图图像及矢量数据皆以Open Database License(ODbL)授权。
OSM网站的灵感来自维基百科等网站。这可从该网地图页的“编辑”按钮及其完整修订历史获知。经注册的用户可上载GPS路径及使用内置的编辑程式编辑数据。
目前包括苹果和微软在内都在使用OpenStreetMap。
下面就是OSM数据官网截图：
我们使用OSM做了什么 OSM作为开源的地图服务，自身本身也是带有相应的API来供开发者使用的。因为不是商业性质的，服务提供并不是那么稳定，而且接口的效率不是很高。我们目前使用OSM的API进行逆地理的时候经常会出现获取不到地址，请求超时等情况。这一系列的问题导致我们不得不另想办法。既然调用他们的API不行，那我们就做个大胆的决定，自己使用OSM数据搭建一台逆地理服务器。后面我会继续介绍
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/357d12c4b562f46e27429a08ccae224f/" rel="bookmark">
			unable to install breakpoint in com... $ $FastClassBySpringCGLIB$ $12fabbfc due to missing line numb
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：unable to install breakpoint in com... $ $FastClassBySpringCGLIB$ $12fabbfc due to missing line number attributes.
Modify compiler options to generate line number attributes.
reason:Absent line number information.
解决：eclipse -- 右上角debug -- Breakpoints -- 点击双叉号（删除所有断点）
注：出错原因是删除了或修改了带有断点的代码，eclipse提示你找不到断点，删除断点就好了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ac29c6c8bc03636faf4147766b90a79/" rel="bookmark">
			urllib实现请求发送（python3）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		urllib实现请求发送 一、传入url：urllib.request.urlopen二、构造请求：urllib.request.Request 一、传入url：urllib.request.urlopen import urllib.request response = urllib.request.urlopen("https://www.baidu.com") print(response.read) # &lt;bound method HTTPResponse.read of &lt;http.client.HTTPResponse object at 0x7ff4c5262400&gt;&gt; print(response.read()) # b'&lt;html&gt;\r\n&lt;head&gt;\r\n\t&lt;script&gt;\r\n\t\tlocation.replace(location.href.replace("https://","http://"));\r\n\t&lt;/script&gt;\r\n&lt;/head&gt;\r\n&lt;body&gt;\r\n\t&lt;noscript&gt;&lt;meta http-equiv="refresh" content="0;url=http://www.baidu.com/"&gt;&lt;/noscript&gt;\r\n&lt;/body&gt;\r\n&lt;/html&gt;' 二、构造请求：urllib.request.Request 构造简单请求 import requests import urllib.request url = "https://www.baidu.com" # 构造headers headers = {"User-Agent":"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36"} # 构造请求 request = urllib.request.Request(url,headers=headers) # 发送请求 response = urllib.request.urlopen(request) print(response.read()) # b'&lt;!DOCTYPE html&gt;\n&lt;!--STATUS OK--&gt;\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\t\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\t\r\n \r\n\t\t\t \r\n\t\r\n\t\t\t \r\n\t\r\n\t\t\t \r\n\t\r\n\t\t\t \r\n\t\t\t \r\n\r\n\t\r\n \r\n\t\t\t \r\n\t\r\n\t\t\t \r\n\t\r\n\t\t\t \r\n\t\r\n\t\t\t \r\n\t\t\t \r\n\r\n\r\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;html&gt;\n&lt;head&gt;\n \n &lt;meta http-equiv="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ac29c6c8bc03636faf4147766b90a79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a63d839c95cd18dfbf83f3ee7065ed0d/" rel="bookmark">
			JVM假死问题如何定位？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题描述 最近接手了一个系统，线上有个定时循环执行的Java服务端程序，采用Spring+Quartz每五分钟计算一次。计算采用多线程执行，所有线程执行完成则当次任务执行完成，并记录计算结果的时间。在程序运行过程中，发现JOB会出现卡死的情况。
二、问题分析 1、查看运行job服务的进程是否正常 计算任务没有正常执行，首先查看tomcat的进程是否正常；
使用ps、top命令可以很容易查看到进程运行情况、以及每个进程中线程的运行情况；
通过查询结果发现当前进程正常，而计算线程卡死了，此时猜测可能因为线程产生了死锁，那么接下来就要分析下进程中所有线程的状态。
2、使用ps或jps命令找到进程的PID 命令：ps -ef | grep tomcat 3、通过jstack命令dump线程堆栈信息 命令： jstack -l 10115 &gt;&gt; dumpFile 4、查看线程的堆栈信息快照 下载步骤3中dump的快照文件到本地，部分线程堆栈信息如下：
通过查看dump的快照并未发现有dead locked，排除了死锁的可能性。 多次dump线程快照，发现上面截图的线程一直处于RUNNABLE状态，分析打印出的信息发现处于I/O等待状态，通过线程堆栈信息可以定位到代码如下：
查看代码发现此处是通过httpClient调用第三方接口,使用的是httpClient4.1.3版本。经过分析得出如下结论：由于开发的同学在使用httpClient的时候没有设置超时时间，当网络或第三方服务出现问题没有response时，会一直等待，导致当前线程一直处于RUNNABLE的状态。
解决办法：设置httpClient的超时时间，重新上线，问题解决！
三、总结 由于线上tomcat启动时也没有配置JMX，因此无法使用jvisualvm图形化工具远程分析服务中进程情况；个人认为在无图形化界面支持的情况，jstack工具是定位线上JAVA服务线程问题的神器。使用jstack可以dump出进程中所有线程（包括JVM自身的线程和用户线程）的堆栈信息、运行状态；jstack一次dump出的快照可能不足矣发现问题，通常多次dump快照文件进行分析；HttpClient4.X 版本使用时需要设置默认超时时间。HttpClient官方的示例也没提到要设置TimeOut，以至于很多同学在使用的时候也没有设置超时时间，这也是比较坑爹的地方。以上问题定位步骤还可以应用于定位服务请求无响应的分析。以上问题定位步骤还可以应用于定位服务请求无响应的分析。 PS:希望对遇到此类问题的同学有帮助！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5a002a1a7de010abbb6574f3dc12f0b/" rel="bookmark">
			Keras框架下的保存模型和加载模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Keras框架下训练深度学习模型时，一般思路是在训练环境下训练出模型，然后拿训练好的模型（即保存模型相应信息的文件）到生产环境下去部署。在训练过程中我们可能会遇到以下情况：
需要运行很长时间的程序在迭代到中间某一代时出现意外；人为地想停止训练过程，也许是为了用测试数据测试模型，然后从上一个检查点继续训练模型；想通过损失函数和评估指标，在每次训练过程中保存模型的最佳版本。 以上这些情况都要求我们能够在训练过程中保存模型和加载模型，下面将通过这篇博客来总结一下最近学习的Keras框架下保存和加载模型的方法和技巧。
目录
1 保存模型
1.1 完整地保存整个模型
1.2 分别保存模型的结构和权重
1.3 保存模型图
2 加载模型
2.1 加载整个模型
2.2 分别加载模型结构和权重
这里会以MNIST手写数据集识别为例来说明如何保存和加载模型，代码如下：
MNIST数据集链接：https://pan.baidu.com/s/1LZRbpaE7eiHtoVPmByQQyQ 提取码：radl from __future__ import print_function import numpy as np from keras.models import Sequential from keras.layers.core import Dense, Activation from keras.optimizers import SGD from keras.utils import np_utils # 随机数种子，重复性设置 np.random.seed(1671) # 网络结构和训练的参数 NB_EPOCH = 20 BATCH_SIZE = 128 VERBOSE = 1 NB_CLASSES = 10 OPTIMIZER = SGD() N_HIDDEN = 128 VALIDATION_SPLIT = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5a002a1a7de010abbb6574f3dc12f0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9ec1ae267b386ab87d29934d58e2cef/" rel="bookmark">
			Hive中使用Distinct踩到的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题描述：
在使用Hive的过程中，用Distinct对重复数据进行过滤，得出了一个违背认知的结果，百思不得其解。
假设：test表中有100W数据，对test表按照a, b, c, d, e去重。
一、使用Distinct的SQL如下：
SQL1 ：select count(distinct a, b, c, d, e) from test; 得出结果： 2W+。
根据数据特点第一感觉，并不会有那么多重复数据，对自己的distinct使用产生了怀疑，因此用group by校验结果。
二、使用Group by的SQL如下：
SQL2 ：select sum (gcount) from (select count(*) gcount from test group by a, b, c, d, e) t 得出结果： 80W+。
这个结果是符合数据特点的；
三、修改SQL1，去掉一个字段；
SQL3：select count(distinct b, c, d, e) from test; 得出结果：90W+。
四、对比SQL1和 SQL3 按照4个字段distinct 理论上一定比 5个字段distinct 结果少， 测试结果缺恰恰相反；
原因就是因为a列中包含null， 按我的认知以为所有的null值会被归结为同一个，可实际上hive并不会；
所以distinct的列中如果含有null值，会导致结果不准，需要将null值替换为一个统一的值。
修改如下：
select count(distinct nvl(a, 0), b, c, d, e) from test; 如上，问题解决！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32671e0002f014854a70d73596c3c85d/" rel="bookmark">
			ArcGIS API for Javascript 4.X扩展Echarts4.2.0三维数据可视化（3D）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ArcGIS API for Javascript 4.x扩展Echarts4三维渲染 上一篇博客主要介绍了ArcGIS API for Javascript 4.X结合Echarts 4实现了二维地图上的数据渲染，包括散点图和轨迹图，对应series里的scatter、effectScatter、lines。
本篇博客主要介绍基于三维地图上的数据渲染（实现思路有参考业余敲代码分享的博客内容），如下图所示为经典的模拟迁徙的渲染效果：
二者集成有一个最重要的问题就是坐标系不统一，因此要进行echarts坐标系与arcgis坐标系的转换，这里采用的方法借鉴了业余敲代码的思路，即自己注册一个坐标系统：命名为arcgis（名称可自由拟定）的坐标系。在此基础上，我采用dojo的define定义了一个名为EchartsglLayer的模块，其中注册arcgis坐标系方法如下：
//需要先引用echarts.js echarts.registerCoordinateSystem('arcgis', this.defineCoordinateSystem(view)); 在defineCoordinateSystem()函数中，对echarts里面的几个函数进行了重写，其中主要包含dataToPoint、pointToData等坐标转换内容。下面列出重写datatoPoint部分代码：
CoordSystem.prototype.dataToPoint = function dataToPoint(data) { var point = { type:"point", x:data[0], y:data[1], spatialReference:new SpatialReference(4326) //WGS84坐标系 }; var px = view.toScreen(point); var mapOffset = this._mapOffset; return [px.x - mapOffset[0], px.y - mapOffset[1]]; } 坐标系定义我统一使用了WGS84坐标系【wkid:4326】，下边示例中的数据对应的都是经纬度；参数view为定义的场景对象，代码如下：
var view = new SceneView({ center: [110.62, 36.32], container: 'map', map: map, zoom: 4 }); 使用版本 目前最新的版本：
ArcGIS API for Javascript 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32671e0002f014854a70d73596c3c85d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e900d075217d2534848b30a18fbad354/" rel="bookmark">
			DOS的概念和使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DOS是什么 DOS(磁盘操作系统)是一种基于个人计算机的操作系统。在Windows出现之前，主流操作系统是DOS。从1981年到1995年，DOS在IBM PC兼容机市场占据了举足轻重的地位。
DOS系列包括MS-DOS、PC-DOS、DR-DOS、ps -DOS、ROM-DOS、Free-DOS、mm - os等，其中微软开发的MS-DOS最为著名。尽管这些系统通常被称为“DOS”，但很少有系统被简单地命名为“DOS”(只有一个不相关的20世纪60年代IBM大型机操作系统是以DOS命名的)。
在发布Windows 95之后，微软宣布MS-DOS将不再单独发布新版本。而免费DOS等与MS-DOS兼容的DOS继续发展。
DOS是一个单用户、单任务、非图形化的命令行操作系统。作为一个操作系统，它简单、紧凑、功能强大，不过现在它已经被更新、更用户友好的图形用户界面(GUI)操作系统Windows所取代。
关于MS-DOS 正如我们之前提到的，MS-DOS是微软发布的DOS系列之一，也是最著名的DOS。大多数计算机用户只熟悉如何用鼠标在微软视窗系统中导航。
与Windows不同，MS-DOS使用MS-DOS命令进行导航。例如，如果您想查看Windows中的一个文件夹中的所有文件，双击该文件夹在Windows Explorer中打开它。在MS-DOS中，您将使用cd命令导航到该文件夹，然后使用dir命令列出该文件夹中的文件。
虽然MS-DOS在1997年之后停止了新版本的发布，但是DOS操作系统本身仍然是当今计算机世界的重要组成部分。许多企业和独立程序员仍然依赖DOS来处理许多嵌入式应用程序。DOS仍然存在，因为它是一个高度紧凑和高效的操作系统，运行良好，很少维护。
从技术上讲，MS-DOS已经不再流行，微软已经明确表示不会更新这个操作系统。但是MS-DOS仍在世界各地使用，并负责许多嵌入式应用程序。MS-DOS可能不再是一个非常重要的操作系统，但它仍然有价值，值得程序员关注。
如何使用DOS 当Windows 95/Windows 98出现时，它们基本上是基于DOS加上图形界面。在Windows 2000/Windows XP系列中，DOS被转换为嵌入式子系统。在他们的桌面上，DOS相当于一个可以输入命令的命令控制台。有时，桌面系统无法处理的问题可以转移到DOS窗口。
今天，Windows操作系统为了特殊的目的，继续支持DOS或换句话说，类似于DOS的用户界面。它现在几乎是隐藏的，但它仍然存在。
DOS是做什么的？例如，我们需要一个电脑指挥官来指挥，就像我们人类依靠大脑来指挥工作和学习一样。这台计算机的指令是DOS。当然，你成为了总司令:你命令DOS命令DOS操作计算机。
那么，如何使用DOS呢？基本思想是进入命令提示符窗口并输入DOS命令。如果使用DOS作为操作系统的计算机，在打开计算机时将自动显示命令提示符。如果您使用的是Windows计算机，则需要手动启动命令提示符。可以同时输入Win按钮和R进行访问。然后在弹出框中键入cmd(命令的缩写)，然后应该在DOS中，也称为命令提示符。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3582cdb455c53934c6a8d8dc5e025bd5/" rel="bookmark">
			字符串与基本类型之间的转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基本类型转化为字符串类型
（1）toString ①基本数据类型的都有一个静态方法toString()，转换时可以采用 "封装类型.toString(对应的基本数据类型字面值)" 方法来转换成字符串。
例：将int类型的20转成字符串，String s = Integer.toString(20)。
②将基本数据类型封装成相应的封装类型对象，采用 "基本数据类型对象.toString()"方法转换成字符串。
例：将double类型的425.0转成字符串，Double d = new Double(425.0); String s =d.toString();
（2）+""，将基本数据类型字面值与空字符串""通过"+"连接
例：将long类型的200转成字符串，String s = 200 + "";
（3）使用String类的 valueOf() 方法
String s=String.valueOf(20);
二、字符串转化为基本类型
（1）利用基本数据类型包装类的parseXxx方法
例：将字符串"123"转成int类型，int i = Integer.parseInt("123");
String s = "16"; int a = Integer.parseInt(s);
（需注意字符串转成基本数据类型时字符串内容必须是基本数据类型的字面值，否则编译虽然能通过，但运行时出现NumberFormatException）
（2）用字符串构造基本类型的封装对象，再调用封装对象的xxxValue方法
例：将字符串"20.5"转成double类型，Double d1 = new Double("20.5");　double d2 = d1.doubleValue();
（3） 调用包装类的 valueOf() 方法转换为基本类型的包装类，会自动拆箱。
String s="16";
int b = Integer.valueof(s); （intValue()是把Integer对象类型变成int的基础数据类型；
parseInt()是把String 变成int的基础数据类型；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3582cdb455c53934c6a8d8dc5e025bd5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a175e5f082ab6092bc7738d199d2f14f/" rel="bookmark">
			tensorflow之add_n
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		tf.add_n([p1, p2, p3....])函数是实现一个列表的元素的相加。就是输入的对象是一个列表，列表里的元素可以是向量，矩阵，等
输入时一个list或者一个数组
input1 = tf.constant([1.0, 2.0, 3.0]) input2 = tf.constant([1.0, 2.0, 3.0]) output = [input1, input2] print(output) with tf.Session() as sess: print(sess.run(input1 + input2)) print (sess.run(tf.add_n(output))) 查看output的类型，是一个数组：有两个元素
shape是（3，）
看下结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79fd1fbe71b617afc9b030cfb8d48ed7/" rel="bookmark">
			MQ消息队列满了以后该怎么处理？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？
问题分析 你看这问法，其实本质针对的场景，都是说，可能你的消费端出了问题，不消费了；或者消费的速度极其慢。接着就坑爹了，可能你的消息队列集群的磁盘都快写满了，都没人消费，这个时候怎么办？或者是这整个就积压了几个小时，你这个时候怎么办？或者是你积压的时间太长了，导致比如 RabbitMQ 设置了消息过期时间后就没了怎么办？
所以就这事儿，其实线上挺常见的，一般不出，一出就是大 case。一般常见于，举个例子，消费端每次消费之后要写 mysql，结果 mysql 挂了，消费端 hang 那儿了，不动了；或者是消费端出了个什么岔子，导致消费速度极其慢。
关于这个事儿，我们一个一个来梳理吧，先假设一个场景，我们现在消费端出故障了，然后大量消息在 mq 里积压，现在出事故了，慌了。
大量消息在 mq 里积压了几个小时了还没解决
几千万条数据在 MQ 里积压了七八个小时，从下午 4 点多，积压到了晚上 11 点多。这个是我们真实遇到过的一个场景，确实是线上故障了，这个时候要不然就是修复 consumer 的问题，让它恢复消费速度，然后傻傻的等待几个小时消费完毕。这个肯定不能在面试的时候说吧。
一个消费者一秒是 1000 条，一秒 3 个消费者是 3000 条，一分钟就是 18 万条。所以如果你积压了几百万到上千万的数据，即使消费者恢复了，也需要大概 1 小时的时间才能恢复过来。
一般这个时候，只能临时紧急扩容了，具体操作步骤和思路如下：
先修复 consumer 的问题，确保其恢复消费速度，然后将现有 consumer 都停掉。
新建一个 topic，partition 是原来的 10 倍，临时建立好原先 10 倍的 queue 数量。
然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的 queue。
接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79fd1fbe71b617afc9b030cfb8d48ed7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb14948bc6fb94ac248a2f895452091a/" rel="bookmark">
			Typescript 静态字段（static）的声明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ts中定义静态变量，加 public static, 和C#中类似。 定义：
export class GlobalService { public static url: string = "http://localhost:4200/webapp"; } 引用：
import { GlobalService } from '../global.service'; //... var url = GlobalService.url + "/device/all"; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f0cedf8af3d923389b7bb163736dbbe/" rel="bookmark">
			高并发与负载均衡——网络TCP-IP基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、网络分层 1.七层（接口）：解耦，便于开发 应用层：
7.应用层：nginx，软件，浏览器，DNS6.表示层 传输层：
5.会话层4.传输层：lvs负载均衡 网络层：
3.网络层 链路层
2.链路层1.物理层 2.四层：TCP/IP协议，OSI 7L参考模型对7层的简化分层和实现 举例：GET / www.baidu.com/
1.应用层（应用层+表示层糅合）:对数据与字符串的封装
http：字符串书写格式与两端方法的交互方式的定义smtpssh 4.传输层（会话层+传输层糅合）（控制）:[三次握手&gt;&gt;（传输数据）&gt;&gt;四次挥手]
连接的定义：非物理的连接，是逻辑连接，是一种状态的确认（对TCP来说，就是三次握手的状态确认）tcp：面向连接（状态）的可靠传输协议 过程：客户端和服务端通信，客户端从65535个端口号中申请一个端口号和服务器固定端口进行通信（一般来说是80端口），三次握手成功后，客户端和服务端会各自开辟一个线程来进行通信。所以高并发问题会产生在线程数量和线程池方面。udp：不是面向连接的，不可靠的socket: IP:PORT-IP:PORT -netstat -natp 5.网络层：192.168.9.11
ip.icmpROUTE:下一跳 -route -n 6.链路层（链路层+物理层糅合）：
以太网：Ethernet：MACARP:全F,两点通信，交换机学习 arp -a nginx：负载5w台，处在应用层，需要在传输层建立三次握手后才能进行应用层数据解析和负载
lvs负载均衡：负载10w台，工作在传输层，在三次握手&gt;&gt;数据传输&gt;&gt;四次挥手的整个过程中都可以监视数据包的状态，来进行快速的负载均衡，但是由于lvs没有权限观看应用层数据，所以属于瞎子负载，不会根据数据包的真实业务需求来进行业务负载，可能导致将数据包发送到错误的服务器（不干这个业务的服务器），这时需要nginx和lvs负载搭配使用来可以达到百万级别负载能力。也就是流量先集中在lvs负载均衡服务器，然后这些lvs负载均衡服务器将这些数据发送给它后面的nginx服务器，再由nginx服务器做负载均衡，发送给后台的各种业务功能的tomcat服务器。
二、高并发与负载均衡的三种模型推导 1.名词补充 2.四层网络对应模型 知识补充：NAT(网络地址/IP转换) S_NAT：数据源地址NAT转换 图1 图2 工作过程：
家里上网：假设在192.168.1.1的路由器网关下有192.168.1.88和192.168.1.66两个私有IP地址笔记本，他们要访问百度的公有ip123.123.123.88.他们的数据包会通过四层网络封装发送给广播地址192.168.1.255并由路由器的网关来接收并由路由器通过寻找下一跳的方式最终发送给百度服务器。由于在互联网中，第一点：不允许私有ip的存在，一旦发现源数据来自私有IP（192.168.1.88/66就是私有IP），则会丢弃掉该数据包，所以路由器会对私有IP进行转换，将私有IP转换为路由器内部由网络运营商分配给的公网IP也就是18.18.18.8。第二点：很有可能两个笔记本在建立连接开始申请的端口号都为21212，那么他们的完整端口号为192.168.1.88：21212和192.168.1.66.21212（图1）。那么在经过路由器的私有到公有IP的转换，两者的转换后的公有IP都为18.18.18.8:21212，那么到时候数据从百度回来后，路由器就不知道应该还给哪个笔记本了，所以路由器会在里面维护一个MAP，来对地址转换做记录（图2），路由器会申请两个不同的端口，例如123与212，分配给两个笔记本（图2）.最终两个笔记本的公有IP和端口号为18.18.18.8:123与18.18.18.8:212。这样数据包从百度服务器送回的时候，就可以根据MAP中的数据来区分应该送回给哪个笔记本了。这样的地址转换过程，称之为S_NAT地址转换。虚拟机上网：虚拟机如果想要访问百度，则虚拟机的宿主机先通过S_NAT将虚拟机的IP地址和端口号转换成宿主机的网卡IP地址，然后通过宿主机网卡再发送给路由器，路由器再经过S_NAT转换发送给百度服务器。 拓扑简略图 负载均衡器只做转发，不做三次握手，并保证三次握手&gt;&gt;数据传输&gt;&gt;四次挥手之间整体的过程完整统一，不被切分。
这里的四层负载均衡是一个简单实现，后台的Server是集群式部署而不是分布式部署，所以存储容量并没有提升。
具体实施 D_NAT:目标地址转换 图3 工作原理：客户端CIP通过TCP/IP访问负载均衡服务器VIP（也就是负载均衡服务器），然后负载均衡服务器再将客户端的数据包发送给真实服务器Server（RIP），但是由于客户端的目标是VIP，而不是RIP，那么RIP在拿到CIP_VIP的数据包后，由于发现其本身RIP与数据包目标VIP不同，那么服务器会丢弃掉这个数据包。那么握手就不能够建立起来了。所以在这个过程中，负载均衡服务器会将客户端的CIP_VIP数据包监视并修改为CIP_RIP数据包（原理类似S_NAT），并自己内部维护一个MAP来记录修改前的地址与修改后的地址以便数据会回送给客户端（将CIP_RIP的ip对应关系改回CIP_VIP的对应关系，如果不这样做的话，CIP_RIP的数据包直接发送给客户端，那么客户端发现和自己建立的CIP_VIP连接的IP对应关系不对应，则会丢弃改数据包），之后将CIP_RIP数据包发送给RIP，这个修改目标IP的转换，称之为D_NAT。
不足：所有的数据都是通过网线发送的，我们假设客户端有10000个，负载均衡服务器一个，server两个分别负载5000，首先我们要明确一个概念，网络的上行速度和下行速度是不一样的，换句话说，我们访问百度，只需要包装一个几百字节的数据包给服务器（上行），而服务器返回给我们html网页则是很大的，可能几个MB（下行），那么如果我们负载均衡服务器的网线带宽不够，能承受上行而不能承受如此高并发的下行（也就是说能经受访问，但是经受不了数据都从负载均衡服务器回送给客户端）。那么，速度还是很慢的，所以这时候我们想，下行这件事情不由负载均衡来干，由真实服务器RIP来做，来降低负载均衡服务器的下行压力，于是有了下面的模型。
改善后的具体实施：DR模型——直接路由模型 图4 PS:一台机器是可以配置两个IP的，IP对外网和公网是唯一不同的。我们的负载均衡服务器VIP为公网IP，配置在eth0的子接口eth0：2下，私网IP为DIP，确保和RealServer在同一网段下，配置在eth0接口下，我们可以通过ifconfig指令来查看。
关键点：
1.IP冲突问题：为了能够让RIP向客户端发送数据，则Server（RIP）的IP应该为VIP，这样才会匹配客户端的CIP_VIP请求数据包。但是RealServer的IP已经是RIP了并且IP必须是唯一的，而且负载均衡服务器的IP也是VIP，那么就不符合IP唯一的规则。解决办法是在RealServer中配置一个隐含IP为VIP（图4中的*VIP），且该隐含IP只对自己可见，对外网公网不可见，保证了IP地址对外和公网的唯一性，那么就可以实现向客户端回送数据包VIP_CIP。，并且解决了IP冲突的问题。
2.数据包发送问题：在解决了IP冲突问题后，还存在一个问题就是数据包循环问题，当负载均衡服务器收到CIP_VIP的数据包后，它会根据自己的路由表进行负载均衡，但是发现自己本身就是VIP，所以会将这个数据包又直接发给自己，不会做负载均衡。解决这一问题是要干扰负载均衡器，将CIP_VIP数据包进行一个加工，将数据包的目标MAC地址，拼接成RealServer(RIP)的MAC地址：CIP_VIP+RIP_MAC。也就是说与D_NAT不同，D_NAT是更改IP地址将CIP_VIP变成CIP_RIP发送给RealServ-er，是IP层做的工作；而我们现在做的工作是IP层的目标IP不做改动，将链路层的MAC地址由负载均衡的MAC地址修改成RealServer的MAC地址。
3.局域网局限性问题：在解决了1和2之后，还是有问题，就是负载均衡服务器和RealServer必须在同一网段，也就是在同一个局域网下。如果不在同一个局域网下的话，那么负载均衡和RealServer之间相当于是互联网了，那么数据包从负载均衡要走到RealServer的过程是要经过路由判定的，要经过多个跳跃寻找网关了。而路由判定是IP层的工作，那么在IP层，MAC地址是要被替代的，那么根据路由最近判定原则，在第二跳MAC地址又会被刷新覆盖为负载均衡服务器的IP地址，那么数据包又发不出去了，被送回到负载均衡服务器。
4.后端RealServer不能使用NAT模式：在解决了1,2,3后，CIP_VIP+RIP_MAC的数据包终于发送到了RealServer。RealServer在确认后将同样以Tcp/IP的方式发送给客户端，这时候不能使用NAT模式了，因为NAT模式会更改IP地址，将导致客户端因为IP地址不匹配同样不会接受数据包。所以RealServer不能以连接路由或者交换机的方式接入互联网，要直接连网线接入互联网。所以RealServer的默认网关应该直接指向运营商（ISP）,并有一个公网IP地址（PIP，也就是RealServer的下一跳）。
DR模型的再改善：TUN隧道模型——突破DR模型物理限制（LVS与RealServer必须在同一局域网下，也就是同一个区域下） 图5 工作原理：就是在IP层封装两层，最好理解TUN隧道技术的就是VPN，我们要访问VIP，那么客户端数据包通过路由转发到了负载均衡服务器，负载均衡服务器再在CIP_VIP外层包一层IP层信息DIP_RIP，则DIP与RIP之间通过配置好的隧道技术可以通信了。这就是VPN翻墙的原理，我们（CIP）如果要访问美国（RIP），那么我们会先访问香港（VIP），香港再访问美国。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fe0c653fd3ab055a5003f318b09ee1d/" rel="bookmark">
			nginx中部署vue前端项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先当然是阿里云服务器购买以及Vue项目的编写了，服务器购买就不说了，Vue项目打包npm run dev的时候要注意一下，主要是config/index.js里assetsPublicPath要配置成 './'(原来是'/'),不然在上线后会什么也没有，还有就是如果使用了axios跨域(跨端口)的话，并且是使用proxyTable配置如下的话:
proxyTable: {
'/api': {
target: 'localhost:9080',
changeOrigin: true,
pathRewrite: {
'^/api': ''
}
}
}
// 主要主要是把localost:8080/api/findAll(Vue默认监听8080端口),转发到localhost:9080/findAll
那么需要配置一下nginx，
更改nginx配置,主要更改server配置
server {
...省略代码
root /var/www/vuemusic;
// 代码(npm run build之后dist文件夹里的文件,不要直接传dist文件夹)通过Xftp上传到/var/www/vuemusic目录下
location / {
root /var/www/vuemusic;
index index.html;
}
location /api {
rewrite ^.+api/?(.*)$ /$1 break;
proxy_pass http://59.110.127.125;
// 作用和proxyTable差不多
}
}
重启nginx就可以看到首页了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9196c9002226d011b7979ea0d22e8da/" rel="bookmark">
			UNIX环境高级编程-第三版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unix环境高级编程-第三版 之前学习了《Linux系统编程》对于常见的概念和函数都有了基础的认知，这里准备通过这本书，深入学习系统API相关内容。笔记内容会有所倾向，不会严格反应书本内容。
基础概念 +----------+ |应用程序 | +------+ | | Shell| | +------+ | | 内核 | | +------+ | | Libs | | +------+---+ 内核的接口称为系统调用(system call)。公用函数库(libs)建立在系统调用基础上，应用程序既可以使用公共函数库，也可以系统调用。Shell是比较特殊的应用程序，为其他程序提供一个接口。Linux是GNU操作系统使用的内核，一般称为GNU/Linux操作系统，更常见的叫法为Linux。
登陆 用户在登陆Unix系统时，输入用户名和口令，系统在口令文件/etc/passwd中查看。口令文件是由7个冒号分割的字段组成，依次是：登录名、加密口令、用户ID、数字组ID、注释字段、起始目录、Shell程序。
如：sar:x:205:105:Stephen Rago:/home/sar:/bin/ksh.目前，所有系统的加密口令移动到单独文件中了。
Shell是一个命令行解释权，它读取用户输入，然后执行命令。sh是Unix默认shell, csh是BSD默认shell, bash是sh的改进，支持csh的特色，所有Linux都有。
文件和目录 文件名的最大长度是255个字符(characters)，文件路径的最大长度是4096字符(characters)， 即可以包含16级的最大文件长度的路径。
API说明
#include &lt;sys/types.h&gt; #include &lt;dirent.h&gt; DIR *opendir(const char *name); DIR *fdopendir(int fd); struct dirent { ino_t d_ino; /* Inode number */ off_t d_off; /* Not an offset; see below */ unsigned short d_reclen; /* Length of this record */ unsigned char d_type; /* Type of file; not supported by all filesystem types */ char d_name[256]; /* Null-terminated filename */ }; struct dirent *readdir(DIR *dirp); #include &lt;unistd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9196c9002226d011b7979ea0d22e8da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27900843c721f92f618f0e2bcdb0b5fc/" rel="bookmark">
			Slf4j获取日志对象(Logger)的实现分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 Slf4j简介 日常开发中记录日志有很多框架，如：java.util.logging、Apache log4j、logback等。如果使用某种具体框架，一段时间后需要切换框架那么会很麻烦，因此有了Slf4j（Simple logging Facade for Java)。Slf4j提供了统一的日志接口，你可以根据需求配置不同的实现。这样可以并保持接口稳定，并轻易变更具体日志框架。
2 实现分析 在使用时可以引入某个具体实现，例如slf4j-simple需要引入依赖：
&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;/dependency&gt; 使用logback时引入依赖：
&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.1.7&lt;/version&gt; &lt;/dependency&gt; 使用时统一通过slf4j-api包中的类org.slf4j.LoggerFactory来获取具体的Logger对象。
public class Main { public static void main(String[] args){ Logger logger = LoggerFactory.getLogger(Main.class); logger.info("123"); } } 通过依赖分析工具可以看到这些实现类都需要依赖slf4j-api包，并实现了包中定义的接口。
slf4j-api包中定义了几个主要的接口和类，如Logger接口、ILoggerFactory接口及LoggerFactory类。
Logger接口定义了日志的使用方法，如trace，info等，具体日志框架提供不同的实现。
ILoggerFactory定义了如何获取logger对象的方法。
LoggerFactory工具类用提供了具体的实现方法最终获取不同框架实现的logger对象。
接下来看看Slf4j是如何根据配置找到不同的日志实现，即获取具体的Logger对象。
Logger logger = LoggerFactory.getLogger(Main.class); 获取一个Logger对象归结为两步
获取ILoggerFactory实例通过ILoggerFactory实例来获取Logger对象 public static Logger getLogger(String name) { ILoggerFactory iLoggerFactory = getILoggerFactory(); return iLoggerFactory.getLogger(name); } org.slf4j.LoggerFactory.getLogger(LoggerFactory.java:357) at org.slf4j.LoggerFactory.getLogger(LoggerFactory.java:383) at script.Main.main(Main.java:14) getILoggerFactory在状态更新为SUCCESSFUL_INITIALIZATION时，会通过StaticLoggerBinder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27900843c721f92f618f0e2bcdb0b5fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a819e5b98665d135e8980ad446411233/" rel="bookmark">
			构造方法及重载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		构造器也叫构造方法(constructor)，用于对象的初始化。构造器是一个创建对象时被自动调用的特殊方法，目的是对象的初始化。构造器的名称应与类的名称一致。Java通过new关键字来调用构造器，从而返回该类的实例，是一种特殊的方法。
声明格式：　1
2
3
[修饰符] 类名(形参列表){
//n条语句
}
要点：
1. 通过new关键字调用!!
2. 构造器虽然有返回值，但是不能定义返回值类型(返回值的类型肯定是本类)，不能在构造器里使用return返回某个值。
3. 如果我们没有定义构造器，则编译器会自动定义一个无参的构造函数。如果已定义则编译器不会自动添加!
4. 构造器的方法名必须和类名一致!
/** * 测试构造方法 * @author Memorial * */ class Point{ double x,y; //构造方法名称和类名必须保持一致 public Point(double _x,double _y) { x=_x; y=_y; } Point(){ } public double getDistance(Point p) { return Math.sqrt((x-p.x)*(x-p.x)+(y-p.y)*(y-p.y)); } } public class TestConstructor { public static void main(String[] args) { Point p=new Point(3.0,4.0); Point origin=new Point(0.0,0.0); //Point p2=new Point(); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a819e5b98665d135e8980ad446411233/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e920401ca466ad170d4331e474bb9c73/" rel="bookmark">
			ubuntu 16 vi 方向键乱
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 sudo apt-get remove vim-common sudo apt-get install vim 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e525ae1aa9442ca38e6eeeb11455301/" rel="bookmark">
			网易雷火 Unity面经
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大概是2个多月前的面试，最近一段时间太忙了没时间写博客，终于得空把面经补上了。
一面
Unity回调方法执行顺序
Animator和Animation区别
说说对象池
unity各种回调方法特征
C# GC
非托管资源回收
Tcp和Udp特征以及区别
操作系统原语
进程通信方式
补码求解
子掩码计算
死锁问题
Lamada表达式
委托和事件的区别
闭包
排序树遍历
B+树原理优点
从1亿个玩家中找出战斗力排行第100的玩家
这个算法还可以优化吗
二面
如何处理抖动
游戏同步如何保证准确性
如何做断线重连
说说你用过的网络同步框架
你所知道的异步通信框架
安卓图片压缩
自动寻路算法
如何处理寻路中的传送门
有没有读过NGUI源码
你认为NGUI该怎么做优化
如何解决UI遮挡物体的问题
有没有用过tolua
Xlua源码有没有看过
Xlua底层如何实现热更新
说一下c#的GC吧
Delegate和Event的区别
图形渲染管道
Shader广告牌效果
高斯模糊？
边缘检测算法？
光照模型？
有没有了解过pbs光照？
简单说下你写的opengl程序
有没有看过开源引擎框架
游戏引擎模型动画系统的实现
三面(总裁面)
知不知道mipmap
知不知道怎么减少lua GC
知不知道反射
知不知道mono怎么优化
知不知道四元数和欧拉角的区别
知不知道怎么做内存优化
知不知道什么是JPS算法
知不知道JPS-BitPre
知不知道怎么做视野裁剪
知不知道怎么合包
知不知道如何减少Drawcall
项目用的TCP还是UDP
是什么使得你们做出这个决策
你们还做过那些重要决策，原因？
会用SVN吗？
除了这上面的你还有哪些技能？
开源框架了解几个，简单介绍下CNN
学过数据库吗
Sql数据库用的什么算法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e525ae1aa9442ca38e6eeeb11455301/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0665661c4a60f4f87d7775053ab56758/" rel="bookmark">
			bwa-mem中的ksw算法到底是怎么回事儿？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ksw算法小结 研究了这么久bwa-mem算法，也不只一次啃了ksw这块硬骨头，之前没有好好总结，今天来小结一下函数的输入输出。
主要研究的对象是ksw_extend2函数，它是一个单线程、非完全匹配的sequence alignment算法，该算法基于动态规划的逻辑，进行数据匹配，由于数据间存在大量相关性，所以不方便并行实现，串行实现有十分耗时，我们的工作就是，把这一块从原工程中拎出来，并改写成GPU加速版本。
下面分析函数的输入输出，把英语的注释翻译成了中文。
ksw_extend2 @param qlen query length	待匹配段碱基的query长度 * @param query query sequence with 0 &lt;= query[i] &lt; m //query的指针	* @param tlen target length //reference长度 * @param target target sequence with 0 &lt;= target[i] &lt; m //reference数据的指针 * @param m number of residue types // 碱基种类=5 * @param mat m*m scoring mattrix in one-dimension array //每个位置的query和target的匹配得分 * @param gapo gap open penalty; a gap of length l cost "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0665661c4a60f4f87d7775053ab56758/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/571f1b692a91da645194a2886834f503/" rel="bookmark">
			Oracle之CMD导入DMP文件报错提示“IMP-00003: 遇到 ORACLE 错误 1917”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为用户或角色不存在
先添加角色，再单独执行赋权限语句
如果最后提示：“成功终止导入，但出现警告”，就是没有问题了，不必在意。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc02f99248d14bc068b30abafb122a91/" rel="bookmark">
			iOS 中block的循环引用问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发中经常使用weakSelf和strongSelf来解决block的循环引用问题，但是是不是所有的block都会导致循环引用呢？显然不是的，那么怎么判断调用一个带有block方法时是否会造成循环引用呢，我们来分析一下。
首先我们来写一个含有block的类，并调用自己，然后在外部实现这个block，来测试什么情况会出现循环引用。
@interface ALDTestBlockModel () @property (nonatomic, copy) dispatch_block_t testBlock; @property (nonatomic, copy) NSString * testString; @end @implementation ALDTestBlockModel - (void)initWithBlock1:(dispatch_block_t)block{ //对象不持有该block if (block) { block(); } } - (void)initWithBlock2:(dispatch_block_t)block{ //对象持有该block self.testBlock = block; if (self.testBlock) { self.testBlock(); } } @end 外部测试代码：
@interface ALDTestBlockController () @property (nonatomic, strong) ALDTestBlockModel *model; @end @implementation ALDTestBlockController - (void)viewDidLoad { [super viewDidLoad]; self.model = [ALDTestBlockModel new]; [self noSelfTest]; //[self haveSelfTest]; } - (void)noSelfTest{ [self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc02f99248d14bc068b30abafb122a91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38bc91bd7255713f58401ee91184c2e2/" rel="bookmark">
			Oracle之ORA-01940：无法删除当前已连接用户的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于资源占用，oracle报错01940，解决方案如下：
1.首先将索要删除的用户锁定，这句必须执行，否则之后杀死进程无效！
alter user 用户名 account lock;
2.从【v$Session】表查看当前用户占用资源，有使用资源的情况下，肯定不能删除用户
select saddr,sid,serial#,paddr,username,status from v$session where username = '用户名';
3. 杀死status为【 INACTIVE】的进程，sid和seria#值为该列下的数值
alter system kill session 'sid,serial#';
4. 删除用户，如果不成功，即还是会报01940错，因为还有【 INACTIVE】进程没杀死
drop user 用户名 cascade;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ba91571fcf7db6667b955de44307ace/" rel="bookmark">
			screen命令基本用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、screen：screen manager with VT100/ANSI terminal emulation 1）简介：一个可以在多个进程（通常是交互式shell）之间复用一个物理终端的全屏幕窗口管理器。
使用screen时，程序“运行”在screen会话中（作为会话shell的子进程），此时detach会话不会中断会话中的程序。当再次attach该会话时，又可以回到detach之前的状态。
2）常用选项：-S name：为会话指定名字；-r session：恢复detached的会话；-ls [match]：列举所有/匹配的会话；-d -m：以detached模式创建会话（常用于系统启动脚本）；-d [match]：detach一个正在使用的会话。在会话控制终端键入Ctrl-a d可detach该会话；-wipe [match]：和-ls一样，但会移除已销毁的会话，而不是标记为dead。
3）例子：
（1）创建新会话：
screen -S han vim test # 若要终止会话：退出vim-&gt;键入Ctrl-d screen vim test # 直接指定在screen会话中运行的程序。这种情况下，退出vim即终止会话 （2）在（1）中会话未终止时，键入Ctrl-a d，将detach该会话。
（3）使用screen -ls查询所有会话：
[root@localhost ~]# screen -ls There is a screen on: 3985.han (Detached) 1 Socket in /var/run/screen/S-root. 可见会话当前状态是Detached的。
（4）恢复会话：
screen -r 3985 # 回到detach前的状态 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90c8aa46a5d551f4147950e7c1af9393/" rel="bookmark">
			POJ1064（二分搜索）解题报告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原题链接：POJ1064
题意简述：有N根绳子，它们长度分别为Li。如果从他们中切割出K条长度相同的绳子的话，这K条绳子每条最长能有多长？答案保留到小数点后俩位。
解题思路：用二分搜索方法来判断。首先假定一个解，判断其是否可行，不断缩小解的范围，从而得出答案。本题可以使用实数域上的的精度控制（即设置eps判断）或者干脆循环个几百次来逼近精度。
注意点：
printf（）保留小数位时四舍五入问题。（有点迷，这个需要仔细考虑）循环终止条件问题，最终答案是左边界还是右边界？ 代码示例：
#include&lt;cstdio&gt; #include&lt;cmath&gt; const int maxn = 11000; const double eps = 10e-6; double len[maxn]; int n,k; bool C(double size){ int cnt = 0; for(int i = 0;i &lt; n;i++)	cnt += len[i]/size; return cnt &gt;= k; } int main(){ scanf("%d%d",&amp;n,&amp;k); for(int i = 0;i &lt; n;i++)	scanf("%lf",&amp;len[i]); double l = 0,r = 3000000; while(l + eps &lt; r){ double mid = (l+r)/2; if(C(mid))	l = mid; else r = mid; } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90c8aa46a5d551f4147950e7c1af9393/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6deb2c8cc421092a9d6345f672105c04/" rel="bookmark">
			Top的VIRT是什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Top命令监控某个进程的资源占有情况 下面是各种内存： VIRT：virtual memory usage 1、进程“需要的”虚拟内存大小，包括进程使用的库、代码、数据等 2、假如进程申请100m的内存，但实际只使用了10m，那么它会增长100m，而不是实际的使用量 RES：resident memory usage 常驻内存 1、进程当前使用的内存大小，但不包括swap out 2、包含其他进程的共享 3、如果申请100m的内存，实际使用10m，它只增长10m，与VIRT相反 4、关于库占用内存的情况，它只统计加载的库文件所占内存大小 SHR：shared memory 1、除了自身进程的共享内存，也包括其他进程的共享内存 2、虽然进程只使用了几个共享库的函数，但它包含了整个共享库的大小 3、计算某个进程所占的物理内存大小公式：RES – SHR 4、swap out后，它将会降下来 DATA 1、数据占用的内存。如果top没有显示，按f键可以显示出来。 2、真正的该程序要求的数据空间，是真正在运行中要使用的。
转载于:https://www.cnblogs.com/ExMan/p/10146203.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/255916e0b08277c44ee72f36aac04f5e/" rel="bookmark">
			RedisUtils工具类-
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.stereotype.Component; import org.springframework.util.CollectionUtils; import java.util.List; import java.util.Map; import java.util.Set; import java.util.concurrent.TimeUnit; /** * Redis工具类 * * @author */ @Component public class RedisUtils { @Autowired private RedisTemplate redisTemplate; // =============================common============================ /** * 指定缓存失效时间 * * @param key 键 * @param time 时间(秒) * @return */ public boolean expire(String key, long time) { try { if (time &gt; 0) { redisTemplate.expire(key, time, TimeUnit.SECONDS); } return true; } catch (Exception e) { e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/255916e0b08277c44ee72f36aac04f5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f86c29118e1f1909a37a0ab145ddecf/" rel="bookmark">
			module &#39;torchvision.datasets&#39; has no attribute &#39;VOCDetection&#39;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		module ‘torchvision.datasets’ has no attribute ‘VOCDetection’ 这是因为 VOCDetection 还没有添加到最新的 release 版本的导致的错误, 我们可以通过源码的方式重新安装 torchvision. 方法如下:
首先查看当前虚拟环境的 torchvision 的安装位置:
import torchvision as tv print(tv.__file__) # /home/zerozone/.pyenv/versions/a3py3.5/lib/python3.5/site-packages/torchvision/__init__.py 然后进入上面的文件夹, 删除旧的 torchvision
cd /home/zerozone/.pyenv/versions/a3py3.5/lib/python3.5/site-packages/ rm -rf torchvision* 然后下载最新版本的 torchvision 并安装(注意不要更换安装路径)
git clone https://github.com/pytorch/vision.git python setup.py install 最后查看新安装的 torchvision 中是否包含 VOCDetection:
&gt;&gt;&gt; import torchvision as tv &gt;&gt;&gt; print(dir(tv.datasets)) # ['CIFAR10', 'CIFAR100', 'CocoCaptions', 'CocoDetection', 'DatasetFolder', 'EMNIST', 'FakeData', 'FashionMNIST', 'Flickr30k', 'Flickr8k', 'ImageFolder', 'LSUN', 'LSUNClass', 'MNIST', 'Omniglot', 'PhotoTour', 'SBU', 'SEMEION', 'STL10', 'SVHN', 'VOCDetection', 'VOCSegmentation', '__all__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__path__', '__spec__', 'cifar', 'coco', 'fakedata', 'flickr', 'folder', 'lsun', 'mnist', 'omniglot', 'phototour', 'sbu', 'semeion', 'stl10', 'svhn', 'utils', 'voc'] 可以看到, 新包含了 'VOCDetection', 'VOCSegmentation', 'voc' 等名称, 说明安装成功, 此时可以正常使用 VOCDetection 了.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f86c29118e1f1909a37a0ab145ddecf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f15a4377f33214fcc19e82aa573a8445/" rel="bookmark">
			RuntimeError:         An attempt has been made to start a new process before the current process...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://pytorch.org/tutorials/beginner/blitz/cifar10_tutorial.html#sphx-glr-beginner-blitz-cifar10-tutorial-py
import torch import torchvision import torchvision.transforms as transforms import matplotlib.pyplot as plt import numpy as np transform=transforms.Compose([transforms.ToTensor(),transforms.Normalize((0.5,0.5,0.5),(0.5,0.5,0.5))]) trainset=torchvision.datasets.CIFAR10(root='./data',train=True,download=True,transform=transform) trainloader=torch.utils.data.DataLoader(trainset,batch_size=4,shuffle=True,num_workers=2) testset=torchvision.datasets.CIFAR10(root='./data',train=False,download=True,transform=transform) testloader=torch.utils.data.DataLoader(testset,batch_size=4,shuffle=False,num_workers=2) classes=('plane','car','bird','cat','deer','dog','frog','horse','ship','truck') def imgshow(img): img=img/2+0.5 npimg=img.numpy() plt.imshow(np.transpose(npimg,(1,2,0))) plt.show() dataiter=iter(trainloader) images,labels=dataiter.next() imgshow(torchvision.utils.make_grid(images)) print(' '.join('%5s' % classes[labels[j]] for j in range(4))) 抄的代码，运行报错：
RuntimeError: An attempt has been made to start a new process before the current process has finished its bootstrapping phase. This probably means that you are not using fork to start your child processes and you have forgotten to use the proper idiom in the main module: if __name__ == '__main__': freeze_support() .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f15a4377f33214fcc19e82aa573a8445/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca556f3ef42c132f5375c74934b94ca9/" rel="bookmark">
			UE4 下雪特效(特效)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 下载一个雪花的贴图 2. 制作材质，如下： 2.制作材质 3. 创建粒子特效 4. 5. 6. 7. 8. 设置参数 9. 添加属性 10. 设置空间参数 添加雪花旋转，默认就好 11. 右击空白黑条添加 GPU 计算 12. 添加GPU后可是添加 13. 重新添加一个相同的元素设置不同参数让效果正更为逼真 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce893389bd0d38e890133046c88042f9/" rel="bookmark">
			js使用canvas的drawImage()绘制图片不显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		起因： 在使用canvas绘制图片时，发现根据w3cschool里面的绘制代码绘制图片显示不出来。
示例代码如下：
&lt;script type="text/javascript"&gt; var c=document.getElementById("myCanvas"); var cxt=c.getContext("2d"); var img=new Image() img.src="flower.png" cxt.drawImage(img,0,0); &lt;/script&gt; 自己的模仿代码如下：
// 绘制图片 function drawImg(){ var img = new Image(); img.src = "ic_animal.png"; console.log("path is "+img.src) ctx.drawImage(img, 0,0,100, 100); } 原因： img.src加载图片需要时间，虽然img对象已经赋值成功，但是图片还没有加载完成。这时立即调用canvas里的drawImage是绘制不出来的。
解决方法： 正确的做法是给img的src赋值后，使用onload监听加载图片情况，加载完成后再绘制。
代码如下：
// 绘制图片 function drawImg(){ var img = new Image(); img.src = "ic_animal.png"; // 等待加载完成再绘制 img.onload = function(){ ctx.drawImage(img, 0,0,50, 50); } console.log("path is "+img.src) } 于是图片终于出来：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41e8ff4905dfd199f98aaf29d1a5ffcc/" rel="bookmark">
			plsqldev使用指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，登录后默认自动选中My Objects 默认情况下，PLSQL Developer登录后，Brower里会选择All objects，如果你登录的用户是dba，要展开tables目录，正常情况都需要Wait几秒钟，而选择My Objects后响应速率则是以毫秒计算的。 Tools菜单 --&gt; Object Brower Filters，会打开Brower Folders的定单窗口，把“My Objects”设为默认即可。 Tools菜单--&gt; Object Brower Folders，中把你经常点的几个目录（比如：Tables Views Seq Functions Procedures）移得靠上一点，并加上颜色区分，这样你的平均寻表时间会大大缩短，试试看。 /*设置方法：Tools菜单－－Brower Folders，会打开Brower Folders的定单窗口，把“My Objects”移到最顶端即可。 同理，可以把你经常点的几个目录（比如：tables Views Seq Functions Procedures）移得靠上一点，并加上颜色区分，这样你的平均寻表时间会大大缩短，试试看。*/
2，记住密码 这是个有争议的功能，因为记住密码会给带来数据安全的问题。 但假如是开发用的库，密码甚至可以和用户名相同，每次输入密码实在没什么意义，可以考虑让PLSQL Developer记住密码。 位置：Tools菜单－－Preferences－－Oracle－－Logon HIstory－－Store with password
3，双击即显示表数据 PLSQL Developer里鼠标双击表或者视图时的默认响应实在让我感到失望，因为我最关心的是表结构和数据，但是双击后这两件事情都没有发生，也许默认响应是高手们需要的，但对我来说查看数据和表结构是最主要的，其他的我不关心。 不过好的是这是可以设置的，你可以给鼠标双击和拖放绑定需要的事件，比如：双击编辑数据，拖放显示表结构，Yeah！ 位置：Preferences－－User Interface，在右侧，为不同的Object type绑定双击和拖放操作。
4，SQL语句字符全部大写 自认为这是个好习惯，信息系统的核心是数据库，系统出问题时最先要查的就是SQL语句，怎样在浩瀚的日志中快速找到那条SQL语句是件比较痛苦的事情。 SQL语句全部大写并不能彻底解决这一问题，但在一堆代码中间找一行全部大写的字符相对容易些，你的眼睛会感谢你。 设置位置在Editor里。同时我觉得等宽字符可以减少程序的出错率，所以我所有的工具清一色用Courier New，如果某个IDE不支持这个字体，我基本上会选择放弃。哈，偶系个满挑惕的家伙。
5，特殊Copy 在SQL Window里写好的SQL语句通常需要放到Java或者别的语言内，就需要转成字符串并上加上相应的连字符，这一个事不需要再重复做了，在写好的SQL上点右键，使用特殊Copy即OK！
6，自定义快捷键 PLSQL Developer里预留了很多键让用户自定义，这是件很Hight的事情。不像霸道的Word，基本上所有的键都已预定义了功能，修改起来很是头疼。 通常情况下，打开PLSQL Developer后，最经常干的事就是打开SQL Window和Command Window，就给这两个操作定义了快捷键，ALT+S和ALT+ C，这样拿鼠标点三下的事情只需要按一下键。
7，其他 快速清空表，TRUNCATE TABLE，右键里可以找到。 没搞清楚的两个功能：Analyze、VALID 7、SQL Window中根据光标位置自动选择语句 设置方法：Preferences --&gt; Window Types --&gt; SQL Window，将AutoSelect statement选中即可。注意，每条语句后面要加分号。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41e8ff4905dfd199f98aaf29d1a5ffcc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ccdacf701e74f50475cfc6f4b7d9334/" rel="bookmark">
			拉普拉斯变换的本质意义（好文！通俗易懂）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文将从通俗的角度看待拉普拉斯变换。
发明者 奥列弗.赫维赛德，维多利亚时期英国人，全靠自学，听力残疾。很多人熟悉赫维赛德是因为MATLAB有一个赫维赛德（Heaviside）函数。
赫维赛德简化了麦克斯韦方程组：即变化的电场产生磁场，变化的磁场产生电场。让20个方程组便成了4个。
**赫维赛德另一个贡献就是我们今天要说的运算微积分-它可以将常微分方程转换为普通代数方程。**赫维赛德是怎么解微分方程的呢？他把微分、积分运算用一个简单的算子来代替。
也就是说，在某种算子下，积分和微分对应的是倒数关系，至于算子 p 代表什么，赫维赛德也没有多解释，在缺乏严密数学基础的情况下，人家直接放在文章就用了，还发表了。比如常见的一个二阶常微分方程，
如果用赫维赛德的微分算子变换一下，就变成了代数表达式。
赫维赛德之所以这么做，是因为他的“物理直觉”告诉他这么做，就是这么硬。这显然是一种开外挂的行为，因此也受到当时的主流数学家们们的攻讦，他们认为赫维赛德就是十足的“民科”，文章没什么理论依据，自己在那空想呢。当然，赫维赛德也不是弱鸡，科学家怼起人来，也是毫不含糊：“因为我不能理解消化过程就拒绝晚餐吗？不，只要我满意这个结果。”
好了，扯了那么远，有童鞋已经不耐心了：这些和拉普拉斯变换有什么关系？谜底就是：赫维赛德的微积分算子，就是拉普拉斯变换的前身。
傅里叶变换（轻量版拉普拉斯变换） 在说拉普拉斯变换以前，我们要先提一下傅里叶变换，这可以看成是轻量版的拉普拉斯变换。傅里叶变换说的是什么事？说的是自然界的很多现象，都可以用三角函数进行分解。
clc;clear; h = animatedline; xl=xlabel('cos(\omegat)');% yl=ylabel('sin(\omegat)');% grid on; title('\omega = 1rad/s Made by J Pan') axis([-1,1,-1,1]); axis square; N = 100; t=linspace(0,2*pi,N); w=1; x=cos(w*t); y=sin(w*t); a = tic; % start timer for k = 1:N addpoints(h,x(k),y(k)); hold on quiver(0,0,x(k)*1.1,y(k)*1.1) b = toc(a); % check timer if b &gt; (1/90) drawnow % update screen every 1/30 seconds a = tic; % reset timer after updating end end 你能想象到很多曲线，都可以用这些不同频率，连续旋转的圆，通过线性叠加得到，而傅里叶定律，就是对这个结论的数学描述。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ccdacf701e74f50475cfc6f4b7d9334/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45649f442f013751ddbf13069ad6a53c/" rel="bookmark">
			海康威视摄像机通过SDK实现自动拍照（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		尊敬的读者您好：笔者很高兴自己的文章能被阅读，但原创与编辑均不易，所以转载请必须注明本文出处并附上本文地址超链接以及博主博客地址：https://blog.csdn.net/vensmallzeng。若觉得本文对您有益处还请帮忙点个赞鼓励一下，笔者在此感谢每一位读者，如需联系笔者，请记下邮箱：zengzenghe@gmail.com，谢谢合作！ 海康威视摄像机通过SDK实现自动拍照（一）
海康威视摄像机通过SDK实现自动拍照（二）
1.请先下载笔者修改好的ClientDemo-NetBeansPro压缩包，下载地址：https://download.csdn.net/download/vensmallzeng/10858526；如果不想支付积分/C币，请到笔者的GitHub上下载修改过的源码并替换掉海康威视官网给的源码，下载完后请记得送笔者一个star，谢谢！链接如下：https://github.com/zengzenghe/Hikvision-SDK-Coding。
2.对ClientDemo-NetBeansPro压缩包进行解压，将解压出来的ClientDemo-NetBeansPro文件夹拷贝到工作路径下，例如D:\Program Files (x86)\Java\JavaDemo
3.打开安装好的eclipse，进入操作界面后请点击File→New→JavaProject,新建JavaProject，在如下图红框中输入ClientDemo-NetBeansPro
其余参数不动，直接下一步直到创建成功，得到如下图：
4.点击到如图然后打开Java代码，根据摄像机的实际情况修改如下图方框中的内容。
5.查看并修改存储自东抓图的路径，如下图。
6.点击到下，运行 程序，即可启动自动拍照功能。
日积月累，与君共进，增增小结，未完待续。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29e0425a25f2e029f57b01babd2941b9/" rel="bookmark">
			Laravel记录sql日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.使用DB的listen方法
文件位置:/app/Providers/AppServiceProvider.php
use Illuminate\Support\Facades\DB; class AppServiceProvider extends ServiceProvider { /** * Bootstrap any application services. * * @return void */ public function boot() { DB::listen(function ($query) { $sql = $query-&gt;sql; $bindings = $query-&gt;bindings; //写入sql if ($bindings) { file_put_contents('.sqls', "[" . date("Y-m-d H:i:s") . "]" . $sql . "\r\nparmars:" . json_encode($bindings, 320) . "\r\n\r\n", FILE_APPEND); } else { file_put_contents('.sqls', "[" . date("Y-m-d H:i:s") . "]" . $sql . "\r\n\r\n", FILE_APPEND); } }); } /** * Register any application services.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29e0425a25f2e029f57b01babd2941b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29855fdbd1a24d58902d744129657866/" rel="bookmark">
			tensorflow的一些知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		encoder = gdet.create_box_encoder(model_filename, batch_size=1) class ImageEncoder(object): # TODO ImageEncoder def __init__(self, checkpoint_filename, input_name="images", output_name="features"): self.session = tf.Session() with tf.gfile.GFile(checkpoint_filename, "rb") as file_handle: # TODO 2　学习tf这部分 graph_def = tf.GraphDef() # tf.gfile.GFile(filename, mode) # 获取文本操作句柄，类似于python提供的文本操作open()函数，filename是要打开的文件名， # mode是以何种方式去读写，将会返回一个文本操作句柄。 graph_def.ParseFromString(file_handle.read()) tf.import_graph_def(graph_def, name="net") # 将图从graph_def导入到当前默认图中. # graph_def: 包含要导入到默认图中的操作的GraphDef proto。 self.input_var = tf.get_default_graph().get_tensor_by_name( "net/%s:0" % input_name) self.output_var = tf.get_default_graph().get_tensor_by_name( "net/%s:0" % output_name) # print('self.input_var', self.input_var) Tensor("net/images:0", shape=(?, 128, 64, 3), dtype=uint8) # print('self.output_var', self.output_var) Tensor("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29855fdbd1a24d58902d744129657866/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d804b452923d0f9bbb9d951ebb357617/" rel="bookmark">
			Linux操作系统(Ubuntu、CentOS、Redhat、Suse)网络配置格式及重启网络命令（建议收藏）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在安装操作系统时，网络配置是最重要的环节，有些操作系统默认接口不会配置或者设置为dhcp自动获取的方式，很多情况下，我们需要设置静态ip地址，这样我们就需要修改网络配置文件。以下总结了几种常用Linux发行版配置网络的方式，建议大家收藏，供以后查阅，如发现有疏漏请留言。（这里要吐槽一下，ubuntu带图形的系统是最坑的，NetworkManager和系统网络配置没有统一，NetworkManager会简单粗暴的判断interfaces配置，如果不仔细研究其接管机制，还真是一脸蒙圈，导致一大批人在网上问为什么会出现unmanaged，为什么配置中有ip还不生效等问题）
配置文件路径和格式表 系统类型(测试过的版本)配置文件/目录格式(以eth0做实例) Ubuntu
(14.04 15.x 16.04 )
配置文件/etc/network/interfaces
（对桌面版，如果在该配置文件中增加了接口配置，NetworkManager会取消对该接口的接管，会出现unmanaged提示，如果要恢复NetworkManager管理，将配置文件中的配置清除）
auto eth0
iface eth0 inet static
address 192.168.10.2
netmask 255.255.255.0
gateway 192.168.10.1
metric 101
dns-nameservers 192.168.10.1 8.8.8.8
Redhat/CentOS
(5.x、6.x、7.x)
配置文件目录/etc/sysconfig/network-scripts/
配置文件格式：ifcfg-ethx
DEVICE=eth0
BOOTPROTO=static
IPADDR=192.168.10.3
NETMASK=255.255.255.0
GATEWAY=192.168.10.1
DNS1=192.168.10.1
DNS2=8.8.8.8
ONBOOT=yes
METRIC=101
NAME=eth0 Suse
(10.x 、11.x 、12.x)
ip配置文件目录/etc/sysconfig/network-scripts/
配置文件格式：ifcfg-ethxBOOTPROTO=static
IPADDR=192.168.10.4
NETMASK=255.255.255.0
STARTMODE=auto路由配置文件
/etc/sysconfig/network/routes
注意：suse只支持配置单个默认路由default 192.168.10.1 -- eth0 dns配置文件
/etc/sysconfig/network/config
注意： config文件中配置的dns重启网络后会生成到/etc/resolv.conf，suse系统默认resolv.conf是软连接，手动修改resolv.conf是无效的，除非手动新建resolv.conf文件而非软连接，这样重启网络后dns不会被覆盖
修改NETCONFIG_DNS_STATIC_SERVERS
如
NETCONFIG_DNS_STATIC_SERVERS=”192.168.10.1,8.8.8.8” 网络重启命令
不同系统网络service名称可能不一样，一般都是service network restart，很多系统高版本采用systemctl的方式。建议用通用的重启网络方式ifdown/ifup命令，各种重启方式如下表：
service networking restart
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d804b452923d0f9bbb9d951ebb357617/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e170873ef80c9c7dfcff9221f10a6cd7/" rel="bookmark">
			UnhandledPromiseRejectionWarning: TypeError: Cannot read property &#39;stack&#39; of undefined     at C:\Use
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		'adb' ????????????????????????е????
?????????????
'adb' ????????????????????????е????
?????????????
(node:14140) UnhandledPromiseRejectionWarning: TypeError: Cannot read property 'stack' of undefined
at C:\Users\meisiteZyl\.xtoolkit\node_modules\weexpack\lib\build\android.js:179:21
at &lt;anonymous&gt;
(node:14140) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). (rejection id: 2)
(node:14140) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e170873ef80c9c7dfcff9221f10a6cd7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b62a808b3b4c7a761945c3cfd209c1f2/" rel="bookmark">
			NVDLA master project tree 一览
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		zhajio@ubuntu:~/nvdla/hw$ . ├── cmod # systemc UT TLM 模型，在vp中也用的这个sc模型，在验证环境中需要 `define NVDLA_REFERENCE_MODEL_ENABLE，使能cmod作为参考模型使用。 ├── perf # NVDLA_OpenSource_Performance excel文档 http://nvdla.org/primer.html网页 "Example Area and Performance with NVDLA" 章节 ├── spec │ ├── defs # project level macros for multiple projects build │ ├── manual # 寄存器模型描述的RDL文件，利用开源UVM REG MODEL生成工具，生成 | | #* **regs_v.v**: verilog model | | #* **regs_ral.sv**: ral class | | #* **cmod**: c++ model | | #* **sv**: systemverilog model │ └── odif # ODIF: Open DLA Interface Definition ├── syn │ ├── cons # synopsys design constraint 文件 │ ├── script # 综合的脚本 │ └── templates # ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b62a808b3b4c7a761945c3cfd209c1f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72110a31503ef7e73e70a648dd55551a/" rel="bookmark">
			module &#39;resty.uuid&#39; not found:No LuaRocks module found for resty.uuid
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		kong启动时，遇到如下报错信息：
执行如下命令，安装 lua-resty-uuid即可解决。
luarocks install lua-resty-uuid 执行代码，并启动成功：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8efaa68c93d08d80da58feefb7d5341/" rel="bookmark">
			分享一些查询资源的网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		资源1：http://resource.haorooms.com/
17素材：http://www.17sucai.com/
ChinaZ:http://sc.chinaz.com/tag_moban/yidongduan.html
源码之家：http://www.mycodes.net/171/
模板之家：http://www.cssmoban.com/tags.asp?n=移动端
JS代码：http://www.jsdaima.com/
蚂蚁Html5：http://www.zzfriend.com/xiazai/youxi/wangyou/
这些网站都有大量的学习视频，有些需要收费但是很便宜
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd3556f4b60eaea4fd31ebeac703b6fb/" rel="bookmark">
			关于android第三方微信分享，支付失败，的返回签名错误的问题。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、一般都是因为签名没有配置正确导致的。
第一种办法下载官方提供的签名工具获取签名。
第二种就是用androidstudio获取签名。
进入到签名所在的文件夹，执行如下命令
D:\android\xxxx\xxx keytool -list -v -keystore xxxxx.jks
输入密钥库口令:
密钥库类型: JKS
密钥库提供方: SUN
您的密钥库包含 1 个条目
别名: westwar
创建日期: 2018-10-24
条目类型: PrivateKeyEntry
证书链长度: 1
证书[1]:
所有者: CN=ww, OU=lm, O=lm, L=cz, ST=js, C=zh
发布者: CN=ww, OU=lm, O=lm, L=cz, ST=js, C=zh
序列号: 3c40af91
有效期为 Wed Oct 24 11:10:17 CST 2018 至 Sun Oct 18 11:10:17 CST 2043
证书指纹:
MD5: ------------------------------------------------------------
SHA1: ------------------------------------------------------------
SHA256: ------------------------------------------------------------
签名算法名称: ------------------------------------------------------------
获取到的md5 就是签名 去掉冒号，大写表小写，（容易出错的地方）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd3556f4b60eaea4fd31ebeac703b6fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62823ecc166b32531162e5230beca3a3/" rel="bookmark">
			《实用C&#43;&#43;》第1课：编程开发环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文转载自：VC驿站
https://www.cctry.com/thread-276150-1-1.html
1、工欲善其事，必先利其器，不管做什么都得有个得心应手的工具！
我们课程使用的编程环境：
操作系统：Microsoft Windows 7 Ultimate Sp1 x64
编译工具：Microsoft Visual Studio 2013 Professional 中文版（其实 VS2010、VS2012、VS2013、VS2015、VS2017 都可以的，操作基本相同）
什么是编译器？微软的 Visual Studio 到底是个什么东西？
话说人有人言，兽有兽语，想让计算机听你的指挥，你就得说他能听得懂的语言，计算机能听懂的语言就是二进制的 0,1 之类的机器语言，这些语言计算机能听懂，但是人类看起来比较费劲，也不易于阅读，代码量大的话有问题了也不好维护。于是有计算机的大牛就发明了相对来说人类能比较好学，听的懂的语言，这就是高级语言，比如：Pascal、C、C++、Java 或汇编语言 等等。这些语言人来学起来会方便很多，相对来说也比较灵活，但是计算机听不懂，于是就得有个中间的软件，能把人类看得懂的高级语言转换成计算机能读懂的低级语言的软件。这实际上就是编译器的一个最基本的功能用途。
编译器的主要工作流程：源代码(source code)-&gt;预处理器(preprocessor)-&gt;编译器(compiler)-&gt;目标代码(object code)-&gt;链接器(Linker)-&gt;可执行程序(executables)
2、C/C++编译器的选择：
在 Windows 系统上有很多款支持 C/C++ 的编译器工具，这里给大家介绍几款典型的：
Turbo C/C++
DOS时代的C/C++编译器，启蒙先驱，也算是一款非常经典的编译器了，我上大学的时候（2003年）学的C语言就是用Turbo C/C++来编译代码；
Visual C++
微软出产的编译器产品。Windows下可以说最流行的C/C++编译器。6.0版本一代经典，至今仍然老而不死。最新版是2017。现在已经有功能相当完整的免费社区版供使用。
Borland C++
一代传奇宝蓝公司的作品，Turbo C/C++的进化版，可惜掩盖在自家王牌Delphi和外敌Visual C++的光芒之下，远没有这两者的历史地位高。
LCC-Win32
当年偶然发现的小品C编译器，编译速度很不错。不过并未进入过主流。
gcc/g++
GNU社区的神作，各大*NIX平台上的编译器的事实标准。直到近年来clang的兴起才开始受到挑战。
clang
最年轻的成员之一，BSD社区的倚天神剑，开发迅速，对标准的支持也相当好，大有挑翻gcc/g++的势头。FreeBSD已经将其列为默认编译器。
Intel C++
号称生成的代码质量最高，优化最到位的C++编译器。但是对AMD的CPU支持的不是很好。
相关各种C/C++编译器的历史课后大家可以看看这两篇文章：
https://yq.aliyun.com/articles/47476
https://www.zhihu.com/question/39661628
在Windows平台下，时下最火的C/C++编译开发工具可以说是微软的 Visual C++了。它是 Visual Studio 可视化开发工具集合的一个子集。Visual Studio 包括 Visual C++、Visual Basic、Visual F#、Visual C# 等等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62823ecc166b32531162e5230beca3a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/920e5b1a3f0fb23891346ad9c797b435/" rel="bookmark">
			单片机定时器0，TH0和TL0初值的计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以晶振12MHZ为例：
可以得到：
TMOD=0x01;
TL0=0xb0;
TH0=0x3c;
至于怎么来的请看：
12M晶振每秒可产生1M个机器周期，1M个机器周期就是1000000个机器周期。一个机器周期为1us, 50ms就需要50000个机器周期，定时器在方式1工作，为16位，最大值为65536，所以需设初值为65536-50000=15536；
15536转化为16进制得3cb0；故高位TH0=0x3c;TL0=0xb0;
不同频率晶振产生的机器周期不一样：
公式为：机器周期=晶振频率/12。。。这是在该晶振频率下每秒产生多少M机器周期。
比如当晶振频率为11.0592M的晶振。则每秒可产生机器周期为11.0592/12=0.9216M的机器周期，也就是921600个机器周期。50ms等于0.05秒，所以需要921600*0.05=46080个机器周期；定时器在方式1工作，为16位，最大值为65536，所以需设初值为65536-46080=19456；转为16进制为（4c00）,所以高位TH0=0x4c; TL0=0x00;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cd0de36249f251afb3c8e8a602dfcbc/" rel="bookmark">
			Effective Java 经典学习（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（尊重劳动成果，转载请注明出处：https://blog.csdn.net/qq_25827845/article/details/85016496冷血之心的博客）
系列文章：
Effective Java经典学习（一）
目录
第二章：创建和销毁对象
（1）使用静态工厂方法代替构造器
（2）遇到多个构造器参数时要考虑用构建器
（3）用私有构造器或者枚举类型强化Singleton属性
（4）通过私有构造器强化不可实例化的能力
（5）避免创建不必要的对象
（6）消除过期的对象引用
（7）避免使用终结方法
第三章：对于所有对象都通用的方法
（8）覆盖equals时请遵守通用约定
（9）覆盖equals时总要覆盖hashCode
（10）始终要覆盖toString方法
（11）谨慎地覆盖clone
（12）考虑实现Comparable接口
第四章：类和接口
（13）使类和成员的可访问性最小化
（14）在公有类中使用访问方法而不是公有域
（15）使可变性最小化
（16）复合优先于继承
（17）要么为继承而设计，并提供文档说明，要么就禁止继承
（18）接口优先于抽象类
（19）接口只用于定义类型
（20）类层次优先于标签类
（21）用函数对象表示策略
（22）优先考虑静态成员类
总结
博主最近在研究《Effective Java》这本书，也学习了一些新的知识点。下边我们一起来学习总结该书第2，3，4章节中所讲解的案例。
第二章：创建和销毁对象 （1）使用静态工厂方法代替构造器 一个类可以提供一个公有的构造器来让客户端获取其实例，但是我们更应该考虑使用静态工厂方法来代替公有构造器。
public static Boolean valueOf(boolean b) { return b ? Boolean.TRUE : Boolean.FALSE; } 静态工厂方法创建实例的常用方法名：valueOf，of，genInstance，newInstance，getType，newType
（2）遇到多个构造器参数时要考虑用构建器 相信在我们的日常开发中，肯定遇到过一个场景，那就是一个类的构造器中有多个参数。有些参数是必选的，其余则是可选的。这种情况下，我们一般使用重叠构造器模式：即创建了若干个构造器，构造器之间进行相互调用。
重叠构造器模式是我们最常见的一种写法，但是我们应该考虑builder模式，即：不直接生成想要的对象，而是让客户端利用所有必要的参数调用构造器，得到一个builder对象，然后客户都在builder对象上调用类似于setter的方法，来设置每个可选的参数。
（3）用私有构造器或者枚举类型强化Singleton属性 这一条主要讲述了如何更加优雅高效的实现单例模式，那就是使用枚举，你需要编写一个包含单个元素的枚举类型。
（4）通过私有构造器强化不可实例化的能力 比如一些工具类，我们提供了静态方法，不希望这个类被私有化。很简单，我们可以将构造器私有化。产生的副作用：该类不可以被子类化。因为所有的构造器都必须显示或者隐示的调用超类构造器。
（5）避免创建不必要的对象 先来看一个极端的方面例子，该语句每次被执行都创建了一个新的String实例。
String s = new String("stringette"); 改进后如下：
String s = "stringette"; 再来看一个关于创建无用对象所带来的问题。我们都知道自动装箱/拆箱，这个功能使得基本类型和装箱基本类型之间的差别变得模糊起来。但是，还是有差别的，案例如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cd0de36249f251afb3c8e8a602dfcbc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65efec27696da0e1b426c81343cc11a0/" rel="bookmark">
			tf.estimator.Estimator讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		tf.estimator.Estimator 简单介绍 是一个class 所以需要初始化，作用是用来 训练和评价 tensorflow 模型的
Estimator对象包装由一个名为model_fn函数指定的模型，model_fn在给定输入和许多其他参数的情况下，返回执行训练、评估或预测所需的操作。所有输出（checkpoints, event files, etc.等）都写入model_dir或其子目录。如果没有设置model_dir，则使用临时目录。
初始化 __init__( model_fn, model_dir=None, config=None, params=None, warm_start_from=None ) ''' Args: model_fn: Model function. Follows the signature: Args: features: 是从 input_fn中返回的词典tensor 或者 单个tensor ;其实质就是模型的输入（以前我们都是用tf.placeholder输入的，这里使用input_fn 函数返回） This is the first item returned from the input_fn labels: 是从 input_fn中返回的词典tensor 或者 单个tensor,注意，如果mode=tf.estimator.ModeKeys.PREDICT(就是在预测的时候), labels将会被设置为None This is the second item returned from the input_fn mode: Optional. Specifies if this training, evaluation or prediction. See tf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65efec27696da0e1b426c81343cc11a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ee5cfefa855c38858b0886397b7d240/" rel="bookmark">
			C#的接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接口是指定一组函数成员而不实现他们的引用类型。所以只能类和结构来实现接口，在继承该接口的类里面要实现接口的所有方法。
一、在定义接口时候要注意如下几点：
接口声明不能包含以下成员：数据成员、静态成员。
接口声明只能包含如下类型的非静态成员函数的声明：方法、属性、事件、索引器。
这些函数成员的声明不能包含任何实现代码，而在每一个成员声明的主体后必须使用分。
按照惯例，接口名称必须从大写的I开始写起，
接口声明可以有任何的访问修饰符，public、protected、internal、private，例如
然而，接口的成员是隐式public的，不允许有任何的访问修饰符，包括public，例如：
C#中对于接口的实现方式有隐式接口和显式接口两种：
隐式地实现接口成员
创建一个接口，IChinese，包含一个成员 Speak;我们创建一个类Speaker，实现接口Chinese
//隐藏式实现例子 public interface IChinese { string Speak(); } public class Speaker : IChinese { public string Speak() { return "中文"; } } 这个就是隐式实现接口。 隐藏式实现例子 public interface IChinese { string Speak(); } public class Speaker : IChinese { public string Speak() { return "中文"; } } 隐式实现调用方法如下：
IChinese s = new Speaker(); s.Speak(); Speaker s = new Speaker(); s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ee5cfefa855c38858b0886397b7d240/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d618b9b2c064d97ba2280954eee86eee/" rel="bookmark">
			Qt：Windows编程—Qt实现本地服务管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qt实现本地服务管理 前言 本节将使用Windows的几个API，使用qt实现 本地服务 简单管理。这里简单介绍下服务。
几乎每一种操作系统都有一种在系统启动时启动的进程机制，这种机制不会依赖于用户的交互。在Windows下，类似的基础称为Windows服务。服务是一种程序类型，它在后台运行，服务程序通常可以在本地和通过网络为用户提供一些功能，服务在操作系统启动时就会随之启动的程序。
效果 实现效果和Windows 服务管理类似，等会我们用我们写的软件进行服务的启动和暂停，然后刷新windows的服务管理 和我们的操作结果应该是一致的。
相关的Windows API 打开服务管理句柄 SC_HANDLE OpenSCManagerA(
LPCSTR lpMachineName, // computer name，NULL 为 本机
LPCSTR lpDatabaseName, // SCM database name，应该为 SERVICES_ACTIVE_DATABASE，NULL默认也为前面那个
DWORD dwDesiredAccess // 对scm数据库的访问权限 SC_MANAGER_ALL_ACCESS
);
// 成功返回service control manager database的handle
// 对应的关闭函数
BOOL CloseServiceHandle(
SC_HANDLE hSCObject
);
枚举服务 BOOL EnumServicesStatusExA(
SC_HANDLE hSCManager, // OpenSCManager函数返回的句柄
SC_ENUM_TYPE InfoLevel, // SC_ENUM_PROCESS_INFO
DWORD dwServiceType,// 枚举的服务类型
DWORD dwServiceState, // 枚举指定状态的服务
LPBYTE lpServices, // 指向ENUM_SERVICE_STATUS_PROCESSA类型的指针
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d618b9b2c064d97ba2280954eee86eee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e40f72fd3169c1f69c85f7fdbddfa4dc/" rel="bookmark">
			网站图片需要付费禁止下载？这个网站神器轻松搞定！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有时候我们需要下载一个有版权或者无版权的图片作为个人使用，但是有些网站是无法直接下载图片的，需要付费购买才行，今天给大家共享一个很简单的方法，只要使用这个网站就可以解决网页需要付费的图片免费下载了；
使用方法：
1、打开需要付费或者无法右键点击无法下载的网页；
2、找到你想要下载的图片，点击鼠标右键复制图片链接；
3、将图片链接复制到这个网站点击下载到本地即可；
推荐大家3个无版权免费下载图片的网站；
1、网址：http://skuawk.com/
2、网址：https://freephotos.cc/zh
3、网址：https://visualhunt.com/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dab756f2255f78b6ff07ac3d3427ffbe/" rel="bookmark">
			MaskrcnnBenchmark 源码解析-模型定义(modeling)之骨架网络(backbone)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源码文件 不论是在训练脚本文件 train_net.py 还是在测试脚本文件 test_net.py 中, 都调用了 build_detection_model(cfg) 函数来创建模型, 该函数封装了模型定义的内部细节, 使得我们可以通过配置文件轻松的组合出不同类型的模型, 为了能够更好的了解模型的内部细节, 我们有必要知道这些模型是如何被定义, 又是如何组合到一起的, 为此我们需要对 MaskrcnnBenchmark 的 modeling 文件夹进行解析, 该文件夹的结构及文件关系如下所示(位于 ./maskrcnn_benchmark/modeling/ 文件夹下):
backbone backbone.pyfpn.pyresnet.py detector detectors.pygeneralized_rcnn.py roi_heads box_head box_head.pyinference.pyloss.pyroi_box_feature_extractors.pyroi_box_predictors.py mask_head inference.pyloss.pymask_head.pyroi_mask_feature_extractors.py rpn anchor_generator.pyinference.pyloss.pyrpn.py balanced_positive_negative_sampler.pybox_coder.pymatcher.pypoolers.pyregistry.pyutils.py 下面, 我们根据各个文件和函数之间的逻辑关系(而不是上面的文件顺序), 对 MaskrcnnBenchmark 的模型定义模块展开详细的解析和讨论. 想要透彻了解此部分的代码, 只需要按照本文的顺序仔细阅读即可.
detector 模型定义入口 第一部分是 detector 文件夹, 该文件夹中的两个文件定义了是整个 modeling 模块的入口. 文件解析如下
## detectors.py 文件解析 第一个文件 detectors.py 中的代码只有短短几行, 其主要功能就是根据给定的配置信息实例化一个 class GeneralizedRCNN 的对象, 代码如下所示:
# ./maskrcnn_benchmark/modeling/detector/detectors.py from .generalized_rcnn import GeneralizedRCNN _DETECTION_META_ARCHITECTURES = {"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dab756f2255f78b6ff07ac3d3427ffbe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b8bd1b356df98372fbc6458e7efba0e/" rel="bookmark">
			java Apache poi 操作word生成word目录（根据word模板生成word文件）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在项目需求中，需要对于一个word模板文档生成相对应的word文件，而此word模板是多页的并且需要在最终文件中生成相应的目录，由于项目环境是Linux，所以舍弃了jacob（windows环境）。然后主要是研究了Apache poi 进行word操作以及如何生成目录。
主要分两个部分介绍：
Apache poi 操作word：主要是通过XWPFDocument对象进行操作，api 地址：http://poi.apache.org/apidocs/dev/ //读取word文件 InputStream is = new FileInputStream(path); XWPFDocument doc = new XWPFDocument(is); List&lt;IBodyElement&gt; elements= doc.getBodyElements();//获取所有元素(段落和表格) int pIndex =0; int tIndex =0; for(int i=0 ; i&lt; elements.size(); i++) { IBodyElement e = elements.get(i); //判断元素类型：段落/ 表格 if(BodyElementType.PARAGRAPH.equals(e.getElementType())) { XWPFParagraph pa = e.getBody().getParagraphArray(pIndex); //获取段落 List&lt;XWPFRun&gt; runs = paragraph.getRuns(); //获取段落文本 for (XWPFRun run : runs) { ...替换文本 } } else if(BodyElementType.TABLE.equals(e.getElementType())){//表格 XWPFTable ta = e.getBody().getTableArray(tIndex); List&lt;XWPFTableRow&gt; rows = ta.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b8bd1b356df98372fbc6458e7efba0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e18da4e2920dab57afaa851cddea6e19/" rel="bookmark">
			NVDLA epython 代码自动生成脚本深度解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		epython全称为embedded python utility。 该脚本用于从源文件（如verilog文件中）执行内嵌的python代码，并生成期望的输出代码。当用户需要进行一些重复，冗余或模块化编码工作时，它可以被视为自动代码生成器。在输入文件的特定注释中找到的嵌入式python脚本执行并捕获输出到文件中。
默认输出文件是一个临时文件，其名称为后缀“.python”添加到原始输入文件名：&lt;INPUT_FILE_NAME&gt; .python。或者，用户可以指定输出文件或自我更新。
输入文件中具有以下格式的行被识别为嵌入的python脚本：
//：| &lt;python&gt;
输入文件中的嵌入脚本的执行结果会插入以下语句之间：
// :) epython：generated_beg（DO NOT EDIT BELOW）
...
// :) epython：generated_end（DO NOT EDIT ABOVE）
相邻的嵌入式脚本行定义了多行python脚本，而非相邻的嵌入式脚本行定义了多个python脚本。
//：| &lt;python script 1 - line 1&gt;
//：| &lt;python script 1 - line 2&gt;
VS
//：| &lt;python script 1 - line 1&gt;
//：| &lt;python script 2 - line 2&gt;
例：
//：| for i in range（0,2）：
//：| print（“Hello World：％0d”％i）
// :) epython：generated_beg（DO NOT EDIT BELOW）
Hello World: 0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e18da4e2920dab57afaa851cddea6e19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89d9786146eb8351a90bd2bf3a02b53d/" rel="bookmark">
			排序算法红黑树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		排序算法：https://www.cnblogs.com/onepixel/articles/7674659.html
红黑树：http://www.cnblogs.com/skywang12345/p/3245399.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/481f0274c718b3e4eabd95cb7b05bfae/" rel="bookmark">
			Mac下使用webstorm和Charles搭建本地服务器使手机可访问本地html网页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写了一段时间的h5，页面主要是在手机App中使用，直接用谷歌的模拟器调试是比较方便，但有时候在谷歌浏览器中生效的在手机上不生效，这就比较烦，要想看手机上的效果就得发布到服务器上，还有问题又得重新改，然后重新发布再测试，很麻烦。
之前一直想用XAMPP搭建一个本地服务器，然后让手机访问，找了一堆教程，经过一系列繁杂的配置，也终于成功了，但因为电脑连的WiFi，第二天打开电脑，发现ip变了，果断的访问不了了，改来改去也没成功了，就这样放弃了XAMPP。
不搜XAMPP的了，也不搜h5手机调试了，因为都说最好的就是谷歌浏览器的模拟器，搜了下mac 怎么让手机访问电脑本地html网页，居然搜到了使用webstorm和Charles，抱着试一试的心态，居然真的可以！！！
下面介绍一下配置过程，当然了既然是使用webstorm和Charles，那么首先要有这两个工具，安装的问题就不说了，下面是配置流程，有图有真相：
第一步：配置webstorm，打上两个对勾，就这么简单
第二步：配置Charles
这两个配置好了之后，给你想要访问的手机连上你的Charles的代理，即在WiFi那里选择手动设置代理，在对应的地方填写你电脑的ip和Charles的端口号，代理链接成功之后，使用你自己配置的host代替你本地的localhost。
举个例子：我本地浏览器访问地址为http://localhost:63341/test/index.html?_ijt=tqr08qpr3m06rsa8tilo3fiuv5
那么我手机上的访问地址就是http://zhanqin/test/index.html?_ijt=tqr08qpr3m06rsa8tilo3fiuv5（因为我的Map from设置的host为zhanqin，所以直接用zhanqin代替localhost:63341即可）。
亲测可用，有些小坑可看截图上的文字说明，非常感谢分享的博主，原博文地址为https://blog.csdn.net/hherima/article/details/82592400。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3543187046fe5e280077fd655cc37b8c/" rel="bookmark">
			合并两个有序链表（递归与非递归实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		递归版本：
/***************递归*****************/ class Solution { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { if(l1 == null) return l2; if(l2 == null) return l1; if(l1.val &lt; l2.val){ l1.next = mergeTwoLists(l1.next,l2); return l1; } else{ l2.next = mergeTwoLists(l2.next,l1); return l2; } } } 该方法如果理解不好，建议用追踪的方法，举个简单例子然后把递归的过程追踪出来。
非递归实现，思路和归并排序的merge过程一模一样，只不过变成操作链表。代码如下：
/********非递归版本***********/ class Solution { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { ListNode Xhead = new ListNode(0); ListNode cur = Xhead; //虚拟头节点，链表题目常用，可以少考虑很多情况。 while(l1 != null &amp;&amp; l2 != null){ if(l1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3543187046fe5e280077fd655cc37b8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f57f776a8fc73777f7f25d597e2dec16/" rel="bookmark">
			Leetcode算法Java全解答--62. 不同路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Leetcode算法Java全解答–62. 不同路径 文章目录 Leetcode算法Java全解答--62. 不同路径题目想法结果总结代码我的答案大佬们的答案测试用例 其他 题目 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
问总共有多少条不同的路径？
例如，上图是一个7 x 3 的网格。有多少可能的路径？
说明：m 和 n 的值均不超过 100。
示例 1: 输入: m = 3, n = 2 输出: 3 解释: 从左上角开始，总共有 3 条路径可以到达右下角。 1. 向右 -&gt; 向右 -&gt; 向下 2. 向右 -&gt; 向下 -&gt; 向右 3. 向下 -&gt; 向右 -&gt; 向右 示例 2: 输入: m = 7, n = 3 输出: 28 想法 和第70题走楼梯类似，不过这个是二维的，那个是直线的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f57f776a8fc73777f7f25d597e2dec16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/115735d6f1ad36635a2205b3e808e461/" rel="bookmark">
			php一维数组合并
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 具体代码如下:
&lt;?php $arr1=['姓名','年龄','性别']; $arr2=['王小二',24,'男']; $all=array_combine($arr1, $arr2);//数组合并函数 var_dump($all); ?&gt; 执行结果:
array(3) { ["姓名"]=&gt; string(9) "王小二" ["年龄"]=&gt; int(24) ["性别"]=&gt; string(3) "男" } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6243f9d79f2e815c7e35a32f924d196a/" rel="bookmark">
			xshell破解(包括5和6)免费下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Xshell 是一个强大的安全终端模拟软件，它支持SSH1, SSH2, 以及Microsoft Windows 平台的TELNET 协议。Xshell 通过互联网到远程主机的安全连接以及它创新性的设计和特色帮助用户在复杂的网络环境中享受他们的工作。
Xshell可以在Windows界面下用来访问远端不同系统下的服务器，从而比较好的达到远程控制终端的目的。除此之外，其还有丰富的外观配色方案以及样式选择。 -----来自百度百科
Xshell还是很好用的，现在用的比较多的ssh工具应该就是securecrt、xshell等。securecrt的选择复制功能讲真真用不习惯。分享共有两个资源。
Xshell5是破解版，对就是破解版，直接安装即可，无需修改任何东西，也不需要任何秘钥，也不是试用版，打开窗口个数也没限制。安装包地址点这里，提取码 xaiq 。
Xshell6是试用版/家庭版/校园版，并且带有Xftp，唯一的不足就是每个xshell最多只能打开四个终端窗口，每个xftp最多只能两个窗口。如果再打开新的终端，xshell会自动再起一个应用，不过完全不影响使用。安装包地址点击这里，提取码 c82b 。
如有侵权等问题，请联系我，我会删除相关信息。
如果对你有用，记得给好评哦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7047b124594e531ea159d824c9e09a12/" rel="bookmark">
			利用java调用谷歌浏览器驱动进行网页截图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近做项目，需要用到截图的功能，就是给一个url地址，然后自动打开，截取出一个封面图片，保存到服务器上。前端有js可以支持截图，像phantomjs等js插件都可以实现，但是效果不是很好，有些页面渲染不出来。
phantom.js使用方法https://www.jianshu.com/p/074d7ab370e3
本次就介绍java使用chromedriver.exe谷歌浏览器驱动进行网页截图。
创建一个maven项目，在pom文件中加入以下依赖：
&lt;!--网页自动化测试--&gt; &lt;dependency&gt; &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt; &lt;artifactId&gt;selenium-java&lt;/artifactId&gt; &lt;version&gt;3.9.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--commons.io文件拷贝用--&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;/dependency&gt; 在resources目录下新建一个driver目录：
然后在ChromeDriver Mirror下载与电脑谷歌浏览器对应版本的驱动，解压放到此driver目录下
编写main方法
public static void main(String[] args)throws Exception { String url = "http://echarts.baidu.com/examples/"; Integer sleepTime = 5*1000;// 截图等待时间 String targetPath = "D:/test.jpg";// 生成图片文件路径 // 设置是否启用headless模式 System. setProperty("java.awt.headless", "true"); // 加载谷歌浏览器驱动 URL resource = Test.class.getClassLoader().getResource(""); String driverPath = java.net.URLDecoder.decode(resource.getPath(), "UTF-8") + "driver/chromedriver.exe"; ChromeOptions option=new ChromeOptions(); option.addArguments("disable-infobars"); System.setProperty("webdriver.chrome.driver", driverPath); WebDriver driver = new ChromeDriver(option); driver.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7047b124594e531ea159d824c9e09a12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2963a874da46e9f434070c7555f2aab8/" rel="bookmark">
			java内嵌浏览器的几种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近遇到一个特殊的项目需求，就是需要在一个屏幕上打开多个窗口大小不同的浏览器、并且显示不同的页面。因为是需要浏览器无边框的，在网上找了好多资料，发现前端好像很难实现。所以就打算采用java后台内嵌浏览器，然后实现无边框的效果。
以下几种就是笔者采用的几种内嵌浏览器方式：
1.Swing + JXBrowser
jxBrowser是收费的，我在网上找的破解版
jxbrowser-6.14.jarjxbrowser-win32-6.14.jar 新建一个springboot项目，项目右键新建一个lib模板把上面两个jar包拷贝进去
选中两个jar包鼠标右键添加到library
创建main方法
import com.teamdev.jxbrowser.chromium.Browser; import com.teamdev.jxbrowser.chromium.swing.BrowserView; import javax.swing.*; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; /**** * * @author tjw * @versuion 1.0 * @date 2018/12/13 17:16 */ public class Test { public static void main(String[] args) { String url = "http://www.baidu.com"; JFrame frame = new JFrame(); // 谷歌内核浏览器 Browser browser = new Browser(); BrowserView view = new BrowserView(browser); //禁用close功能 // frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); //隐藏任务栏图标 // frame.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2963a874da46e9f434070c7555f2aab8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/422f78a92d404c57df6ad740098f18ea/" rel="bookmark">
			在js还没有加载上来的时候，怎么给dom 绑定事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这就要用到事件委托了
如何进行事件委托 **（1） 当存在多个元素可以共用同一个监听器。** 例子：当想要点击li来触发事件的时候，第一种方法是为每个li都绑定一个监听器，但当li很多时，这样处理就过于繁琐。为了减少dom 的操作，我们可以利用事件委托交给父级元素ul来执行，这样就只用绑定一个监听事件了。粘代 &lt;ul&gt; &lt;li&gt;点&lt;span&gt;这里&lt;/span&gt;&lt;/li&gt; &lt;li&gt;点这里&lt;/li&gt; &lt;/ul&gt; var ul =document.querySelector('ul'); //给父级添加监听事件，委托给父级执行 ul.addEventListener('click',function(e){ var el= e.target; console.log(el.tagName); //只让点击li的时候执行 ,点击ul的时候不执行 while(el.tagName !== 'LI'){ //如果点击的元素为ul，直接跳出循环 if(el === ul){ el = null break; //否则，将当前元素父元素赋给el }else{ el = el.parentNode; } } if(el){ console.log('ok') }else{ console.log("你点击的不是li"); } }) （2） 动态的实现事件委托
&lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;/ul&gt; &lt;button id="addButton"&gt;动态添加li&lt;/button&gt; var ul = document.querySelector('ul'); addButton.onclick = function(){ var li = document.createElement('li'); li.textContent = 'new' //给ui动态添加li ul.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/422f78a92d404c57df6ad740098f18ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/021e7ca50c3972cd50f470090115dc1b/" rel="bookmark">
			coalesce函数的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		coalesce函数的参数是列，结果是取出第一个不为空的列的数据。 postgre数据库中某个视图建立时使用: '002'::text || COALESCE(parent_id, ''::character varying)::text AS parent_id
把某棵树的parent_id置为002或者002+数据表.parent_id(字段）
首先，建一个视图：
CREATE OR REPLACE VIEW v AS SELECT NULL AS c1,NULL AS c2,1 AS c3,NULL AS c4,2 AS c5,NULL AS c6 FROM dual UNION ALL SELECT NULL AS c1,NULL AS c2,NULL AS c3,3 AS c4,NULL AS c5,2 AS c6 FROM dual; 查看视图结果：
使用coalesce函数查结果：
SELECT COALESCE (c1,c2,c3,c4,c5,c6) AS c FROM v; 结果竟是：
难道coalesce函数不支持number类型？带着这个疑问，给转换一下，结果：
SELECT COALESCE (c1,c2,to_char(c3),to_char(c4),to_char(c5),to_char(c6)) AS c FROM v; 好像是真的，那么对date类型的支持呢？试一试
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/021e7ca50c3972cd50f470090115dc1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b09169e50aa793141d9b109cd41910e5/" rel="bookmark">
			Java开发笔记（三十七）利用正则串分割字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面介绍了处理字符串的常用方法，还有一种分割字符串的场景也很常见，也就是按照某个规则将字符串切割为若干子串。分割规则通常是指定某个分隔符，根据字符串内部的分隔符将字符串进行分割，例如逗号、空格等等都可以作为字符串的分隔符。正好String类型提供了split方法用于切割字符串，只要字符串变量调用split方法，并把分隔符作为输入参数，该方法即可返回分割好的字符串数组。
下面的split调用代码例子演示了如何按照逗号和空格切割字符串：
// 通过逗号分割字符串 private static void splitByComma() { String commaStr = "123,456,789"; // 利用split方法指定按照逗号切割字符串 String[] commaArray = commaStr.split(","); for (String item : commaArray) { System.out.println("comma item = "+item); } } // 通过空格分割字符串 private static void splitBySpace() { String spaceStr = "123 456 789"; // 利用split方法指定按照空格切割字符串 String[] spaceArray = spaceStr.split(" "); for (String item : spaceArray) { System.out.println("space item = "+item); } } 除了逗号和空格以外，点号和竖线也常常用来分隔字符串，但是对于点号和竖线，split方法的调用代码不会得到预期的结果。相反，split(".")无法得到分割后的字符串数组，也就是说结果的字符串数组为空；而split("|")分割得到的字符串数组，每个数组元素只有一个字符，其结果类似于toCharArray。究其原因，缘于split方法的输入参数理应是个正则串，并非普通的分隔字符。由于点号和竖线都是正则串的保留字符，因此无法直接在正则串中填写，必须进行转义处理方可。如同回车符和换行符在普通字符串中通过前缀的反斜杆转义那样（回车符对应\r，换行符对应\n），正则字符串通过在原字符前面添加两个反斜杆来转义，像点号字符在正则串中对应的转义符为“\.”，而竖线在正则串中对应的转义符为“\|”。经过转移处理之后，通过点号和竖线切割字符串的正确代码写法如下所示：
// 通过点号分割字符串 private static void splitByDot() { String dotStr = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b09169e50aa793141d9b109cd41910e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bc3e35182a781278fbc9931a38651de/" rel="bookmark">
			使用PyQt5从零进行大数据app构建（十三）pyinstaller打包讲解 -F，-D，-w，-c，以及--hidden-import的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 教程合集地址：https://blog.csdn.net/infent/column/info/30927 代码下载地址：https://download.csdn.net/download/infent/10846010 最终应用来到了打包阶段，这里坑点居多，因此拿出一节来记录一下我这两天的历程。我只能说没有解决不了的问题只有定义不清晰的问题，只要方向对了，问题会随着了解的加深而迎刃而解。 首先讲一讲pyinstaller的用法，在你想放置应用的文件夹下打开cmd，pyinstaller + 参数 +文件入口或打包定义文档。 -F：仅仅生成一个文件，不暴露其他信息，启动较慢。 -D：生成一个文件夹，里面是多文件模式，启动快。 -w：窗口模式打包，不显示控制台。 -c：跟图标路径，作为应用icon。 --hidden-import 应用需要的包，但是没有被打包进来，这里的错误是最多的，因为一般是第三方包隐式调用其他包，然后打包出来的程序显示Fate Error不能运行。 我用到的也就是这些了，还是讲讲流程。最开始是打包日志里报一些xxx module找不到，这些pip安装就行了，关于环境问题，我建议用python3.5，因为据说3.6容易打包失败。但是我用的一开始就是3.5，pyinstaller是3.4，pyqt5.9这都没有问题，解决完这些明面上的包，还是启动不了的话，就是隐式调用了一些包，我的是sklearn的一些包和pymysql的包隐式调用而我的程序里没导入所以一直启动不了，但是也不要什么都import * 那样会导致打出来的包很大。 这里是和百度学的，就是先默认打包，不用写参数，让错误信息打到控制台，但是有个问题，控制台闪了一下就退出了，看不清。这样就需要先录下来，再去看了，下面是我当时录下来的两个截图，可以看到就是包导入的问题，明确的问题所在，就可以改进了。 改进的手段是添加--hidden-import参数，可以看到我上一节的截图里有一个lvtonguilogic.spec文件，这个就是打包信息文件，这个文件会首先被创建出来，然后更新build文件夹和生成dist文件夹。 pyinstaller -F -w -i E:\lvtongEazyVersion\image\lvtong.ico .\lvtonguilogic.py，一开始不需要加入--hidden-import参数，我建议先生成spec文件，然后打开文件在里面进行编辑，如加入hiddenimports=['cython','sklearn','sklearn.ensemble','sklearn.neighbors.typedefs','sklearn.neighbors.quad_tree','sklearn.tree._utils','scipy._lib.messagestream','pymysql'],最后，pyinstaller .\lvtonguilogic.spec，记得先删除原来的打包文件夹，不删除的话覆盖的时候可能显示无权限操作。这里还有一个小坑点，就是那个icon可能不会立刻显示，我打了好几遍都不管事，我是用的单文件打包的，最后把它粘贴出去就显示了，我觉得其实就是在dist文件夹下的显示问题。最后，可能有相对路径的资源会失效，我们新建一个文件夹，把资源放在对应的位置就好啦，如图。 代码下载地址：https://download.csdn.net/download/infent/10846010，请勿以商业目的传播。最后是不是很简洁，照着教程你也能做自己的应用了哦。 从一心进大厂到银行科技部，我这一路的薪路历程（持续更新后续） https://blog.csdn.net/infent/article/details/105477629 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7413c03028430db5c87715f17c5a18fe/" rel="bookmark">
			ImportError: C extension: No module named ‘pandas._libs.tslib‘ not built.错误信息的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在使用pandas时，在import pandas模块时，出现了以下的错误信息 ：
ModuleNotFoundError: No module named 'pandas._libs.tslib' During handling of the above exception, another exception occurred: ImportError Traceback (most recent call last) &lt;ipython-input-3-38d4b0363d82&gt; in &lt;module&gt; ----&gt; 1 import pandas E:\soft\Anaconda\lib\site-packages\pandas\__init__.py in &lt;module&gt; 33 "pandas from the source directory, you may need to run " 34 "'python setup.py build_ext --inplace --force' to build " ---&gt; 35 "the C extensions first.".format(module)) 36 37 from datetime import datetime ImportError: C extension: No module named 'pandas.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7413c03028430db5c87715f17c5a18fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eede9135c2e0db22f4c161524e918044/" rel="bookmark">
			Windows中如何查看日志（如查看远程登陆的IP地址）以及常用日志ID
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【时间】2018.12.12
【题目】Windows中如何查看日志（如查看远程登陆的IP地址）以及常用日志ID
概述 在Windows中可以使用 事件查看器 来查看相关日志，并结合日志ID进行日志筛选。常见的日志有：
4634 - 帐户被注销
4647 - 用户发起注销
4624 - 帐户已成功登录
4625 - 帐户登录失败
4648 - 试图使用明确的凭证登录（可以用以查看远程登陆的相关信息，比如远程登陆的IP地址等）
一、使用事件查看器查看日志信息 参考链接：Windows 服务器查看远程登录的IP_Joel的博客-CSDN博客
下面以查看远程连接的日志为例展示事件查看器的使用。
1.1 在搜索框中搜索 “事件查看器”，双击打开。（事件查看器的位置在C:\WINDOWS\system32，名字为eventvwr.msc） 1.2 展开左侧的 “Windows 日志” 然后双击 “安全”。（其他的日志可能需要选择其他选项） 1.3 点击最右边”操作” 栏中的 “删选当前日志…” 1.4 在弹出的窗口选择记录时间 (Logged), 和输入事件ID : 4648, 我这里是想查看过去七天的远程到本机的记录
1.5 选中一条过滤出来的记录, 然后 点击 下方的 “详情”, 其中 “EventData” 下的 “IpAddress” 即为远程过来的IP地址，127.0.0.1表示是本地登陆，‘TargetUserName’是本电脑的名字。
二、常用的日志ID 参考链接：Winserver 2008事件日志-事件ID详解_Jason_WangYing的博客-CSDN博客
审计目录服务访问
4934 - Active Directory 对象的属性被复制
4935 -复制失败开始
4936 -复制失败结束
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eede9135c2e0db22f4c161524e918044/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1de66c25c9c80240d07a58abff6cddd2/" rel="bookmark">
			JS中不同类型作比较的规律 （比较运算符）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JS 不同数据类型的比较 是个头疼事情，那有没有规律可循，让记忆和理解起来更加容易呢，
console.log(1 == "1") //true 好的，我先把规则告诉大家，然后大家理解后再开始练习。看看效果是不是很显著；
不同数据类型间的比较，规律如下 类型类型其他说明其他说明对象对象比较是不是同一个内存地址 对象字符串对象先转为字符串，在和字符串进行比较 对象布尔类型 两边都要先转为数值
false 是 0，true 是 1
对象类型先隐式调用toString()方法，然后在Number()
对象数字 对象要转为数字，在进行比较（对象先隐式调用toString()方法转为字符串，然后在把字符串
转为数字使用Number()方法）
数字布尔布尔转成数字（false 是 0，true 是 1），在和数字进行比较 数字字符串字符串转成数字使用Number()方法，在和数字进行比较 布尔数字/字符串都转成数字在进行比较 null undefinedtrue null/undefined其他类型结果都是false NaNNaNfalse 自身做布尔运算的时候 之前文章说过，除了 "" 0 NaN null undefined false 为false, 其他都为true
//先执行![] 转成布尔 false 然后就变成了 布尔和对象比较 都转成数值 //false --&gt; 0 [] -&gt; '' -&gt; 0 console.log(![] == [])// true //地址空间比较 肯定不相等 console.log([]==[])// false //![] 先转成false console.log(![]==false);//true //对象和字符串比较 对象转字符串 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1de66c25c9c80240d07a58abff6cddd2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f8f5bb928ec5d644d53b5a98e93931e/" rel="bookmark">
			UI框架—基于UGUI（学习笔记）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UI框架—基于UGUI 一、需求分析 （一）、需求分析UML图 1、通过UIManger来自作解析json文件。 2、UML各种关系 二、知识点 （一）、原理知识 1、单例模式 定义一个静态的对象 在外界访问 在内部构造。
构造方法私有化。
public static UIManager _instance; public static UIManager Instance { get { if (_instance == null) { _instance = new UIManager(); } return _instance; } } （二）、插件知识 1、使用DOTween插件来制作panel出现和现实的动画 导入插件，注意命名空间的引入其他的根据需求来制作 （三）、操作知识 1、场景的搭建 注意文字格式要设置为跟随屏幕自适应而改变其大小 （四）、代码相关 1、编写json信息 编写json相关信息
因为使用了unity自带的两个json类来解析json所以要把一个整体包装成另一个整体来读取
json信息如下
{ "infoList": [ {"panelTypeString":"ItemMessage", "path":"UIPanel/ItemMessagePanel"}, {"panelTypeString":"Knapsack", "path":"UIPanel/KnapsackPanel"}, {"panelTypeString":"MainMenu", "path":"UIPanel/MainMenuPanel"}, {"panelTypeString":"Shop", "path":"UIPanel/ShopPanel"}, {"panelTypeString":"Skill", "path":"UIPanel/SkillPanel"}, {"panelTypeString":"System", "path":"UIPanel/SystemPanel"}, {"panelType":"Task", "path":"UIPanel/TaskPanel"} ] } 2、解析json信息 使用unity自带的json解析类来解析
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f8f5bb928ec5d644d53b5a98e93931e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad5a5bf16fe80b48b317af9cd5d17606/" rel="bookmark">
			leetcode-162-寻找峰值(find peak element)-java
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目及测试
package pid162; /*寻找峰值 峰值元素是指其值大于左右相邻值的元素。 给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。 数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。 你可以假设 nums[-1] = nums[n] = -∞。 示例 1: 输入: nums = [1,2,3,1] 输出: 2 解释: 3 是峰值元素，你的函数应该返回其索引 2。 示例 2: 输入: nums = [1,2,1,3,5,6,4] 输出: 1 或 5 解释: 你的函数可以返回索引 1，其峰值元素为 2； 或者返回索引 5， 其峰值元素为 6。 说明: 你的解法应该是 O(logN) 时间复杂度的。 */ public class main { public static void main(String[] args) { int[][] testTable = {{1,2,3,1},{1,2,1,3,5,6,4},{1,2},{3,2,1,5,6,4}}; for (int[] ito : testTable) { test(ito); } } private static void test(int[] ito) { Solution solution = new Solution(); int rtn; long begin = System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad5a5bf16fe80b48b317af9cd5d17606/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01ec437cc12cf46aee642c273ff16de6/" rel="bookmark">
			c&#43;&#43;中命名空间与作用域
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		命名空间和作用域 命名空间（namespace）是一种将相关的类型进行分组的逻辑命名方案。它将各种命名实体进行分组，各组间可以互不影响，避免出现重名，这与jave的包机制类似。学习本章，读者可以更好理解大型开发中的各种设计规划，更好地深入学习项目构建。
命名空间的定义 命名空间用namespace来声明，后面跟空间的名称，名称之后是由{}包含起来的声明块。在一个名字空间内声明的实体被称为名字空间成员（namespace member），每个成员都必须指向该名字空间内的唯一实体，不同的名字空间可以具有相同名字的成员。命名空间的格式如下所示。
namespace space_name
{
…
}
#include &lt;iostream&gt; using namespace std; namespace SpaceA{ class A { public: int fun(void) { cout&lt;&lt;"In Class A of namespace SpaceA"&lt;&lt;endl; return 1; }; }; char *str ="In namespace SpaceA"; } namespace SpaceB{ class A { public: int fun(void) { cout&lt;&lt;"In class A of namespace SpaceB"&lt;&lt;endl; return 1; }; }; char *str ="In namespace SpaceB"; } int main() { SpaceB::A ba; SpaceA::A aa; aa.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01ec437cc12cf46aee642c273ff16de6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6486a2bc371e454a4ea3c46926a4aa5e/" rel="bookmark">
			数据结构与算法：已知二叉树两种遍历序列，求第三种遍历序列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在笔试题目中经常碰到此类题目，已知先序遍历序列和中序遍历序列，求后序序列或者已知中序序列和后序序列，求先序遍历序列。其中若已知先序序列和后序序列，无法唯一确定一棵树，所以就无法得知中序序列。
1.已知先序遍历序列和中序遍历序列，求后序序列 递归的去求解，每次找到子树的根节点与子树序列来求解。
2.已知中序序列和后序序列，求出先序遍历序列 方法跟前边类似，要根据后后序遍历序列判断根节点或子树的根节点，根据中序遍历序列判断左右子树序列。
大家可以做一做中序为：CEDFBAH 后序为：EFDCBHGA 做出的二叉树与上边相同。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c457d54977c73baaa832840094570e77/" rel="bookmark">
			titianic_train.csv，泰坦尼克号CSV训练数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初学者找资料辛苦，现在免费给各位初学者提供 泰坦尼克号 训练数据集。
链接：https://pan.baidu.com/s/13Qd_qoR22B4VRvUIGm296w 提取码：x4ic 复制这段内容后打开百度网盘手机App，操作更方便哦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80f3acbea5b3ff72eda1d6d668f0fecc/" rel="bookmark">
			Linux下修改Mysql的用户(root)密码和查看默认端口的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、拥有原来的mysql的root的密码 方法一：在mysql系统外，使用mysqladmin
mysqladmin -u root -p password "新的密码“； Enter password:【输入原来的密码】 方法二：通过登录mysql系统
mysql -uroot -p Enter password:【输入原来的密码】 mysql&gt;use mysql; mysql&gt;update user set Password=PASSWORD("123456") where user='root'; mysql&gt;flush privileges; mysql&gt;exit; 二、忘记原来的mysql的root的密码 首先，你必须要有操作系统的root权限了。要是连系统的root权限都没有的话，先考虑root系统再走下面的步骤。
类似于安全模式登录系统
/etc/init.d/mysqld stop mysqld_safe --skip-grant-tables &amp; //&amp;，表示在后台运行，不再后台运行的话，就再打开一个终端 mysql mysql&gt;use mysql; mysql&gt;UPDATE user SET password=password("123456") WHERE user='root'; mysql&gt; flush privileges; mysql&gt; exit; 查看MySQL的默认端口 一般来说MySql的默认端口为3306
一、查看默认端口号
1、登录mysql
[root@localhost ~]# mysql -uroot -p Enter password: 输入数据库密码； 2、使用show global variables like ‘port’; 命令查看端口号
mysql&gt; show global variables like 'port'; ±--------------±------+
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80f3acbea5b3ff72eda1d6d668f0fecc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70ef9559721fcea4c009f3a73c895ab4/" rel="bookmark">
			Java中的异常处理机制（异常一般用于怕输入的时候输入违法的内容导致程序瘫痪，所以提前写好异常，遇到输入错误会有提醒）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、java异常处理机制存在的目的：
保证了程序的容错性，允许程序出现某些错误（比如输入错误），程序不会因为这些错误而突然退出，程序会向用户提示输入不合法，让用户再次输入。
2、关键字的含义：
try：try块里面放置可能引发异常的代码。
catch：后面有一个异常类型和代码块，用于表明catch块用于处理这种类型的代码块。
finally：多个catch块后面还可以跟一个finally块，finall块用于回收再try块里打开的屋里资源，异常机制会保证finally块永远被执行。
throws：在签名中使用，用于声明该方法可能抛出的异常。
throw：用于抛出一个实际的异常，throw可以单独作为语句使用，抛出一个具体的异常对象。
3、执行过程：
try{ //业务实现代码 } catch (Exception e){ //处理机制 //Exception是所有异常类的父类 } 如果执行Try里的业务逻辑代码时 出现异常，系统会自动生成一个异常对象，该对象被提交给java运行时环境，这个过程被称为抛出（throw）异常
当java运行时环境收到异常对象时，会寻找能处理这个异常对象的catch块，如果找到合适的catch块，则把该异常对象交给该catch块处理，这个过程称为捕获（catch）异常，如果java运行环境找不到捕获异常的catch块，则运行环境终止，java程序也将退出。
4、异常类的继承体系
（先处理小异常，再处理大异常）也就是说所有父类异常的catch块都应该排在子类异常catch块的后面。因为当java运行环境接收到异常对象后，会依次判断该异常对象是否是catch块后异常类或者其子类的实例，如果是，则java运行环境将调用该catch快来处理该异常，否则再次拿该异常和下一个catch块里的异常进行比较。所以如果父类在前面，那么子类处理机制将永远不会被执行。
一般情况下，如果try块被执行一次，则try块后面只有一个catch块会被执行，绝不可能有多个catch块被执行。除非循环中使用了continue开始下一次循环，下一次循环又重新运行了try块，这才导致多个catch块被执行。
5、几种常见的运行时异常
（1）IndexOutOfBoundsException（如果运行该程序时输入的参数不够，将会发生数组越界的异常）
（2）NumberFormatException（如果运行该程序时输入的参数不是数字，而是字母。将会发生数字格式异常）
（3）ArithmeticException (算数异常)
（4）NullPointerException（空指针异常）
（5）Exception(未知异常，所有异常的父类)
注意：try块里声明的变量是局部变量。它只在try块内有效，在catch中不能访问该变量。
6、多异常捕获
在java7之前，每个catch块只能捕获一种类型的异常，但是从java7开始，一个catch块可以捕获多种类型的异常。
注意：（1）捕获多种类型的异常时候，多异常之间用（|）隔开
（2）捕获多种类型的异常时候。异常变量有隐式的final修饰，因此程序不能对异常变量（也就是catch后面的异常类型对象）重新赋值。但是单个异常的时候没有隐式的final。可以对异常变量进行重新赋值。
7、访问异常信息
如果程序需要在catch块中访问异常对象的相关信息，则可以通过访问catch块的后异常形参（也就是catch括号里的异常类型对象）来获得。
所有的异常对象都包含如下几个常用方法
（1）getMessage()：返回该异常的详细描述字符串
（2）printStackTrace()：将该异常的跟踪栈信息输出到标准错误输出
（3）printStackTrace(PrintStream s)：将该异常的跟踪栈信息输出指定输出流
（4）getStackTrace()：返回该异常的跟踪栈信息
想访问就可以如下形式：
catch（Exception ie）
ie.getMessage()
8、使用finally回收资源
定义：有些时候，程序在try块里打开了一些物理资源（例如数据库的连接，网络连接，和磁盘文件等）这些物理资源都必须在finally中显示收回
注意：Java的垃圾回收机制不会回收任何的物理资源，垃圾回收机制只能回收堆内存中对象所占用的内存。
例如下面的示例代码：
package com.imooc.test; //下面这两个包必须导入 import java.io.IOException; import java.io.*; public class FinallyTest { public static void main(String[] args){ FileInputStream fis=null; try{ fis=new FileInputStream("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70ef9559721fcea4c009f3a73c895ab4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbad6347f255b291680d648a3348b735/" rel="bookmark">
			读取request请求中的body值、参数值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法1：
例如postman测试，请求携带的body值为：
{“username”:“abc”,
“password”:“123”
}
写restful登录接口时需要用到username的值进行比对
应用：将请求值与正确的登录用户名密码进行比对
private String login(@ReqequstBody Map&lt;String String&gt;params,HttpServletResponse response){ String username=params.get("username"); String pwd=params.get("password"); } 方法二：
需要读取整体的body值，可以将body读成一个字符串格式,也可以读成二进制格式，这里只举例一种，其余可以自行百度
应用：可以判断body是不是合格的json格式
public class HttpServletRequestReader { // 字符串读取 // 方法一 public static String ReadAsChars(HttpServletRequest request) { BufferedReader br = null; StringBuilder sb = new StringBuilder(""); try { br = request.getReader(); String str; while ((str = br.readLine()) != null) { sb.append(str); } br.close(); } catch (IOException e) { e.printStackTrace(); } finally { if (null !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbad6347f255b291680d648a3348b735/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f621c0a2357174b3f44aeb22a5fc078/" rel="bookmark">
			input输入框回车事件响应
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.方法1
$(’#applyCertNum’).bind(‘keypress’,function(event){
if(event.keyCode == 13) { alert('你输入的内容为1：' + $('#applyCertNum').val()); } }); 2.方法2
$(’#applyCertNum’).on(‘keypress’,function(event){
if(event.keyCode == 13) { alert('你输入的内容为1：' + $('#applyCertNum').val()); } }); 3.方法3
$(’#applyCertNum’).bind(‘keypress’,function(event){
if(event.keyCode == "13") { alert('你输入的内容为2：' + $('#applyCertNum').val()); } }); 4.方法4
$("#applyCertNum").keydown(function(e) { if (e.keyCode == 13) { alert("12345...."); } }); HTML:
身份证账号: 根据code得不同区分点击得是哪些按键；
keycode 0 =
keycode 1 =
keycode 2 =
keycode 3 =
keycode 4 =
keycode 5 =
keycode 6 =
keycode 7 =
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f621c0a2357174b3f44aeb22a5fc078/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f55168954b17e66e51853c636f7b8b65/" rel="bookmark">
			Java 正则表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 正则表达式
正则表达式定义了字符串的模式。
正则表达式可以用来搜索、编辑或处理文本。
正则表达式并不仅限于某一种语言，但是在每种语言中有细微的差别。
Java正则表达式和Perl的是最为相似的。
java.util.regex包主要包括以下三个类：
1. Pattern类：
pattern对象是一个正则表达式的编译表示。Pattern类没有公共构造方法。要创建一个Pattern对象，你必须首先调用其公共静态编译方法，它返回一个Pattern对象。该方法接受一个正则表达式作为它的第一个参数。
2. Matcher类：
Matcher对象是对输入字符串进行解释和匹配操作的引擎。与Pattern类一样，Matcher也没有公共构造方法。你需要调用Pattern对象的matcher方法来获得一个Matcher对象。
3. PatternSyntaxException：PatternSyntaxException是一个非强制异常类，它表示一个正则表达式模式中的语法错误。
。。。
捕获组http://www.iis7.com/b/wzjk/
捕获组是把多个字符当一个单独单元进行处理的方法，它通过对括号内的字符分组来创建。
例如，正则表达式(dog) 创建了单一分组，组里包含"d"，"o"，和"g"。
捕获组是通过从左至右计算其开括号来编号。例如，在表达式（（A）（B（C））），有四个这样的组：
((A)(B(C)))
(A)
(B(C))
(C)
可以通过调用matcher对象的groupCount方法来查看表达式有多少个分组。groupCount方法返回一个int值，表示matcher对象当前有多个捕获组。
还有一个特殊的组（组0），它总是代表整个表达式。该组不包括在groupCount的返回值中。
。。。
正则表达式语法
字符 说明
\ 将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如，"n"匹配字符"n"。"\n"匹配换行符。序列"\\"匹配"\"，"\("匹配"("。
^ 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与"\n"或"\r"之后的位置匹配。
$ 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与"\n"或"\r"之前的位置匹配。
* 零次或多次匹配前面的字符或子表达式。例如，zo* 匹配"z"和"zoo"。* 等效于 {0,}。
+ 一次或多次匹配前面的字符或子表达式。例如，"zo+"与"zo"和"zoo"匹配，但与"z"不匹配。+ 等效于 {1,}。
? 零次或一次匹配前面的字符或子表达式。例如，"do(es)?"匹配"do"或"does"中的"do"。? 等效于 {0,1}。
{n} n 是非负整数。正好匹配 n 次。例如，"o{2}"与"Bob"中的"o"不匹配，但与"food"中的两个"o"匹配。
{n,} n 是非负整数。至少匹配 n 次。例如，"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f55168954b17e66e51853c636f7b8b65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a61d5e10317ced0a0b275727f2061d2/" rel="bookmark">
			汽车上的电源模块：BAT、ACC、IGN、ST
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		名字解释 BAT：蓄电池 Battery
ACC：附件 Accessory
IGN：点火 Ignition On
ST：启动 Start
汽车启动开关上的ACC LOCK（锁盘）转到ACC，仅用于听音乐看DVD。从LOCK(OFF)→ACC→ON（IGN)→START（自动回到ON(IGN)，引擎点火。
ACC 与ON （IGN）的区别，就是ACC仅仅是给那些附件上电：例如收音机，灯。而ON就会给发送机工作用的电路也上电。ACC的好处在于发动机电路不上电，例如油泵灯，可以在停车等人的时候节省电力。现在很多车都没有这个选项，而是直接就到ON了。
ACC是辅助电源，实际上高档车机的开机条件一般有两个，即BAT和ACC，BAT 既电源进线，而ACC是一条经钥匙控制的电源线，没开电门时，没ACC电压时，机子是打不开电源的。ACC是点火开关的第二档，也就是专用的辅助电源。
ACC虽说指的是辅助电器系统的电源，可是对于这个定义，其实国内现在还不是很规范的，有的厂家只是觉得把收音机或是CD机，点烟器，前后风窗加热，后视镜加热等挂到ACC上面了，就完成了对于ACC的定义，其实在ACC设计时，需要考虑的不仅仅是挂几个电器而已，而是对于ACC的地位，其实ACC在启动瞬间的断开，不只是简单的断电那么简单，由于启动瞬间的电流过大，对于电器系统，特别是没有经过合理验证以后的电器系统，有一定的影响，就像CD挂这边的意义，对于启动瞬间，还需要特别大的能量提供，主要由蓄电池来提供，所以在这个过程中，为了避免不必要的能量消耗，所以把一些使用频率不是很高的，或是大功率的用电器也放在ACC档，这样对于ACC 档，又由于国内的点火开关的形式就那么几样，选择的余地不大，又会出来ACC档功率不够的情况，因此，对于这种情况下，只能以档位的触点功率限制来合理安排用电器了。
总的说来ACC档的目的：1、分流出大电源用电器，避开启动能量需求；2、避免启动大电流对于用电器的破坏或是干扰。
知识点总结 1、点火开关四个档位，LOCK（关闭档）, ACC（附件档） , ON（点火档）, START（起动档）。
2、锁车后钥匙会处于LOCK状态，此时钥匙门不仅锁住方向，同时切断全车电源。
3、ACC状态是接通汽车部分电器设备的电源，如CD、空调等。
4、正常行车时钥匙处于ON状态，这时全车所有电路都处于工作状态。而START档是发动机启动档位，启动后会自动恢复正常状态也就是ON档。IG1和IG2都是属于ON档。
5、Off全车除了常火（如应急灯，时钟等的记忆功能）外，均不供电。
6、ACC 是附件档，部分车载附属设备供电，如视听系统，仪表灯，灯光等。也就是说，车停在哪里，发动机不转，除了空调不能用外，车内的设备基本都可以用。
7、IG-on是汽车点火档，在保证ACC供电的基础上，增加了发动机的点火功能。
8、ST是启动档，主要给发动机启动系统供电，这时一般会切断ACC档的电路，已保证发动机顺利启动。
9、AM1、AM2是从前舱配电盒进入点火开关的常电。
10、当点火开关打到ACC档时，AM1和ACC接通，档点火开关打到ON档时，AM2和IG1接通，AM1和ACC、IG2接通，当钥匙打到START档时，AM1和ACC、IG2断开，AM2和IG1、START接通。
——————————
2018.12.10
22:25
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a383f4b88b7c338f38a4925512e0bef9/" rel="bookmark">
			Ubuntu16.04 NVDLA环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Download the Virtual Simulator
$ git clone https://github.com/nvdla/vp.git
$ cd vp
$ git submodule update --init --recursive
Install Dependencies
1. Install required tools and libraries
$ sudo apt-get install g++ cmake libboost-dev python-dev libglib2.0-dev libpixman-1-dev liblua5.2-dev swig libcap-dev libattr1-dev
2. Download and install SystemC 2.3.0
$ wget -O systemc-2.3.0a.tar.gz http://www.accellera.org/images/downloads/standards/systemc/systemc-2.3.0a.tar.gz
$ tar -xzvf systemc-2.3.0a.tar.gz
$ cd systemc-2.3.0a
$ sudo mkdir -p /usr/local/systemc-2.3.0/
$ mkdir objdir
$ cd objdir
$ .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a383f4b88b7c338f38a4925512e0bef9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6be7f4d4821f93c25d3d180b8609e28/" rel="bookmark">
			Permission denied (publickey,gssapi-keyex,gssapi-with-mic) 解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 背景： 之前在google cloud上新建了台虚机，后来因为手动修改了一下路径“~/.ssh/authorized_keys”这个文件就导致了出现上述的错误：Permission denied (publickey,gssapi-keyex,gssapi-with-mic)。我依照往常一贯的作风，直接google 错误提示。完全不去思考可能的问题。不过也能解释，我这么做的一个原因，当时时间比较晚了，尝试过修改sshd_config文件但是不见效，并且多次改了多个值，但没有控制变量没有work，所以自己便认为修改配置中的"PasswordAuthentication"字段是没有的操作。拿谷歌搜索问题，静下心来还是有用的，但是浮躁的时候面对满屏的英文还真是没什么帮助。最后在曹大哥的帮助下解决了这个问题。
正文： 其实出现Permission denied (publickey,gssapi-keyex,gssapi-with-mic)这个报错时我们也许可以庆幸下，这个报错说明我们的云平台上的防火墙和虚机的sshd服务都是好的。只不过是我们哪边的配置有些问题。
这个报错中publickey Permission denied的报错信息其实已经告诉我们问题了我们的公钥是错误的，一般情况下我们都可以理解这个问题，并快速解决问题，将公钥放到服务器的~/.ssh/authorized_keys文件中便可。但是尝试过"ssh centos@ip"后得到这个报错就会有点蒙圈了，特别是我这种小菜。之前没遇过，所以不知道，后来实验了才知道这是因为PasswordAuthentication这个字段为"no"的缘故。
所以遇到这种问题便是修改
sudo vim /etc/ssh/sshd_config 增加如下修改 PasswordAuthentication yes sudo systemctl restart sshd 或者
sudo ~/ssh/authorized_keys 添加你本机的公钥到该文件中 注意：
如果你喜欢用root用户登入的话，要确保
/etc/ssh/sshd_config PermitRootLogin yes 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dc315f2d1e0a2cf33312879553de712/" rel="bookmark">
			CTF中压缩包解密的几种常见方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 压缩包解密通用方法：
1.用winhex打开，搜索字符pass 、 key 等，查看是否有含有压缩包密码
2.如果要爆破： 先0-6位数字来一遍
3.如果爆破不成功可以根据题意或者社工 猜密码组合。例如某用户名叫王方，密码就有可能是wangfang123.
crc32爆破：
压缩包压缩文件会附带crc32校验码，如果字节长度比较短的话，可以尝试crc32爆破。
比方说字节长度只有1的话，可以计算所有的字符的crc32码来比较是否有相同的。
rar： AccentRPR 利用了GPU爆破，速度还是比较快的。
zip：
伪加密——用7z压缩软件可直接打开 或者 kali下的binwalk -e 分离。
zip已知明文攻击：
如果有一个加密压缩包中的相同的未加密文件，把该文件用zip压缩即可利用它来破解zip加密压缩包
由于不同的压缩软件压缩方法不同，所以明文攻击的效果也不一样，没办法，可以挨个儿试一下，反正常用的压缩软件也不多，winrar，好压，7z
用不同的压缩工具压缩的压缩包进行破解时有些会直接提示不符，有些则要破解着才知道
破解时只要解出秘钥，没必要搜索出密码。此时按停止 再点弹出窗口中的保存，就可以得到未加密的文件。
ARCHPR4.5.4找回口令不行。ARCHPR较4.5.3快。
以下是4.5.3破解winrar压缩的，题目no.zip
测试4.5.3破解haoya 的,也可以
例题：我们的密码
secret.bin提取一个压缩包和readme.txt
可以直接使用secre.bin作为要破解的文件 ，然后把readme.txt压缩为zip，作为明文文件，最后发现用好压压缩的才可以破解。
破解时要注意看，哪怕破解成功了，它也可能继续运行下去
最后另保存为 secret_decrypted.bin ,解压即可。
工具打包:https://pan.baidu.com/s/1E65i3HkJ1zwBpeogFx67-A 提取码：hvu7 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e483cbb3c4ceb8bab609e9f4d4bd3165/" rel="bookmark">
			用pyecharts制作小说《剑来》的人物关系图（粗）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先上效果
今天在一如既往地划水时，水友给我推了个小说叫《剑来》。下班回到家，准备下载了看一下，结果一看，光txt都要9MB，以我磨蹭的速度，怕不是明年都看不完。正好最近在做一些NLP相关的东西，就想拿这个小说来练个手。
根据小说的内容，建立一个简单的人物关系图 思路大概是： 1. 建立人物列表
2. 计算每个人物在小说里的出现次数
3. 计算每2个人物在小说里共同出现的次数
4. 把1,2,3制作成简单的图表
#! /usr/bin/env python # -*- coding: utf-8 -*- from pyecharts import Graph #对全文根据句号进行分割 def cut_test(): reader = open("jianlai.txt","r",encoding="utf-8").read() sentence_list = reader.split("。") return sentence_list #计算名字在全文中出现的次数 def count_name(): reader = open("jianlai.txt", "r", encoding="utf-8").read() output = [] for i in name: count = reader.count(i) # 主角出现的次数太多，最终作图效果会受影响，这个小小处理一下 if i == "陈平安": count = count/5 row = {"name": i, "symbolSize": count/100} output.append(row) return output #计算两个角色一起出现在一句句子里的次数 def get_rel(name1, name2,snetence): counter = 0 for i in sentence: if name1 in i and name2 in i: counter +=1 row = {"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e483cbb3c4ceb8bab609e9f4d4bd3165/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63db4faf67179741b739e5724c59f8bb/" rel="bookmark">
			Android 随点击事件设置闪烁动画
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		哈喽，哈喽！ 大家好~ 小泽老师！ 哈哈哈 今天 研究了一下ImageView的闪烁动画。
控件闪烁，其实就是控制控件的透明度，从可见到逐渐不可见，再逐渐到可见，一直反复。
因此，要想实现控件闪烁，只需要使用android中的alpha动画即可。
开启闪烁，代码如下：
// 0.1f 和 1.0f 表示 从透明度为 0.1f 开始 到 1.0f 进行变化 AlphaAnimation alphaAnimation1 = new AlphaAnimation(0.1f, 1.0f); // 设置动画300毫秒 alphaAnimation1.setDuration(300); // 表示重复多次。 也可以设定具体重复的次数，比如alphaAnimation1.setRepeatCount(5); alphaAnimation1.setRepeatCount(Animation.INFINITE); // 表示动画结束后，反过来再执行。 // 该方法有两种值， RESTART 和 REVERSE。 // RESTART表示从头开始，REVERSE表示从末尾倒播。 alphaAnimation1.setRepeatMode(Animation.REVERSE); // 给 ImageView 设置动画 ivAnimation.setAnimation(alphaAnimation1); ok~！ 此上就是 百度上都能查到的设置闪烁的动画效果的代码。
但是我今天遇到了一个问题 想用 OnClickListener 控制是否 闪烁 和 不闪烁 此上代码 不知道是我写的有问题 还是什么其他问题，动画失效了。
然后又百度研究了一下 发现有一个 ObjectAnimator
附上代码：?
ObjectAnimator alphaAnimation1 = ObjectAnimator.ofFloat(ivAnimation,"alpha",0.1f,1f); alphaAnimation1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63db4faf67179741b739e5724c59f8bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64f938a42572ec97f9994ae32cd37ff9/" rel="bookmark">
			ueEditor之destroy()清除uE处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、在同一页面切换生成多个ueEditor富文本编辑器，要特别注意使用ue.destroy()方法，避免富文本编辑器失效
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24e89fe863f5abe76214456fa7dd05f6/" rel="bookmark">
			IntelliJ IDEA)中弹出“IntelliJ IDEA License Activation”时怎么办
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天打开 IntelliJ 提示：
Your IntelliJ IDEA evaluation has expired. Your session will be limited to 30 minutes.
网上百度了下发现自己的激活码已经过期了，如果我们不去在此激活的话使用30分钟就会强制性被迫关闭IDEA遇到这种问题我也是看到好心人分享一个破解激活码的网址，下面我就分享给大家http://idea.lanyus.com/，上面的网站很好，估计是个团队或者个人，直接买了全部产品的一年的有效期。而且还是会一直更新下去的。
点击获取注册码然后就会出现一大段符号我们点击复制全部，接着我们打开IDEA然后在出现的界面选择Activation code选项卡，将刚才复制的那段注册码粘贴进去即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07faba9355b47295f97b8a8e5f0aa581/" rel="bookmark">
			Maven错误：was cached in the local repository, resolution will not be reattempted until the update
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 在Idea中使用maven将springboot项目打成jar包(使用idea- maven projects-&gt;具体项目-&gt;package命令 ),报错如下:
在网上找到解决办法如下:特此记录.
解决办法 1.删除~/.m2/repository/对应目录或目录下的*.lastUpdated文件，然后再次运行maven命令(经验证有用)
2.maven命令后加-U，如mvn package -U, -U 强制去远程更新snapshot的插件或依赖，默认每天只更新一次(经验证有用)
在repository的release或者snapshots版本中新增updatePolicy属性，其中updatePolicy可以设置为”always”、”daily” (默认)、”interval:XXX” (分钟)或”never” (尚未验证)
&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;io.spring.repo.maven.release&lt;/id&gt; &lt;url&gt;http://repo.spring.io/release/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;updatePolicy&gt;always&lt;/updatePolicy&gt; &lt;/releases&gt; &lt;snapshots&gt;&lt;enabled&gt;false&lt;/enabled&gt;&lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; 本文解决方法来源于:https://blog.csdn.net/xl890727/article/details/53942452
更多:(maven):https://blog.csdn.net/moshenglv/article/details/52027106
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a7c6ae846b1be5396d16287b225b95c/" rel="bookmark">
			如何自学CS？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		整理 | 非主流
出品 | AI科技大本营
哪个行业的平均工资最高？
计算机。
国家统计局的数据显示，2016 年信息传输、软件和信息技术服务业年平均工资为 122478 元，首超金融行业，并于 2017 年再次夺魁。
在互联网和人工智能浪潮的推动下，一大批年轻人选择了 CS（计算机科学） 专业，这里面还包括各种转专业的学生。
此前营长也给大家推荐过很多学习资源，但是大多都是单个资源，比较零散。其实，很多读者需要的是建议，而不仅仅是资源。
特别是对于自学的小伙伴来说，为什么要学习 CS？应该学习什么？如何选择教材或者视频课程？都是让人困扰的问题。
现在，营长特意为这些小伙伴准备了一套大餐，希望能帮你厘清方向，消除困惑。
为什么要学好 CS？
首先，为什么要学习 CS？
我们知道，任何行业的从业人员的专业水平都是参差不齐的。有人将软件工程师也分成了两类：一类是对 CS 这门学科理解透彻，可以胜任各种挑战性和创新性的工作；另一类则仅仅是对一些高级工具比较熟悉而已。
虽然两者都自称为软件工程师，而且一开始的起薪都差不多，但是第一类工程师显然有更大的发展空间。
比如 WhatsApp 一天要处理 420 亿条信息（2016 年 2 月），但当时 WhatsApp 只有 57 名工程师，要完成这个挑战靠第二种类型的工程师是不太可能的。
因此，如果你想成为第一种类型的软件工程师，踏踏实实学好 CS 才是正途。
怎样学好 CS？
在回答了为什么要学习 CS 这个问题之后，接下来要怎么学？
其实 CS 不只是编程，还涉及到很多知识。本文将重点介绍编程、计算机架构、算法和数据结构、数学、操作系统、计算机网络、数据库、计算机语言和编译器、以及分布式系统。接下来我们一一分析。
编程
大多数的 CS 本科课程都是从介绍计算机编程开始的。营长推荐 Structure and Interpretation of Computer Programs 这本书。
视频则推荐伯克利大学 Brian Harvey 的 SICP 课程。建议至少学完 SICP 的前三章，并把练习题做完。如果你觉得 SICP 的课程太难，可以选择 How to Design Programs。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a7c6ae846b1be5396d16287b225b95c/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/276/">«</a>
	<span class="pagination__item pagination__item--current">277/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/278/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>