<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63adea313a320b55df5692ea1349a5b8/" rel="bookmark">
			GPT store正式上线，和OpenAI分钱时代来了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源：机器之心
收入分成标准还未确定。
ChatGPT 也要像微信、钉钉那样变成全功能 App 了？
1 月 10 日，OpenAI 的应用商店 GPT Store 正式上线，分类、趋势、每周精选等栏目一应俱全。
正像大部分应用商店那样，GPT Store 包括流行下载的社区排行榜，用户可以按类别搜索，例如写作、生活方式和教育。
OpenAI Greg Brockman 表示，这是打造自己的 ChatGPT 的第一步。该产品仍在试验阶段，但希望在未来几周内更广泛地推广。
OpenAI 还将在每周重点介绍有用和有影响力的特色 GPT。第一批特色 GPT 包括：
能够提供个性化步道建议的 AllTrails
能够从 2 亿份学术论文中搜索和分析结果的 Consensus
可汗学院创建的能够帮你提高编码技能的 Code Tutor
能够辅助设计演示文稿或社交帖子的 Canva
能够帮助你找到下一本书的 Books
能够随时随地帮助你学习数学和科学的 CK-12 Flexi AI 助教
自去年 11 月宣布 GPT Builder 计划以来，用户已经创建了超过 300 万个机器人（称为 GPT）。
到目前为止，只有订阅 OpenAI 付费套餐的用户才能制作和使用自定义 GPT。这是 OpenAI 在 ChatGPT 庞大用户基础上所做的一次尝试。
在此之前，OpenAI 就允许人们创建自己的 GPTs，但大家只能通过复制和粘贴网址这一繁琐的过程来共享 GPTs。现在这种情况将有所改变。几位 GPTs 创建者称，OpenAI 在 1 月 4 日告诉开发者：「我们想告诉大家，我们将在下周推出 GPT Store」。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63adea313a320b55df5692ea1349a5b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/488610f426d796fc01d0e05bd5556239/" rel="bookmark">
			陪诊小程序独立版| uniapp前端 |fastadmin后端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		应用介绍 基于FastAdmin + 原生微信小程序开发的陪诊陪护小程序，支持多运营区，陪护师、推广者等完整闭环功能，快速搭建陪护业务平台。
前端演示：
后端演示：
https://tthz001.com/dkYNHvEfXu.php/index/login
介绍：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5a57b53e8c8206f06fa563200018f94/" rel="bookmark">
			C#使用CryptoStream类加密和解密字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、CrytoStream的加密方法
二、CrytoStream的解密方法
三、实例
1.源码Form1.cs
2.类库Encrypt.cs
3.生成效果 在使用CryptoStream前要先引用命名空间using System.Security.Cryptography。
一、CrytoStream的加密方法 记住，不能再使用DESCryptoServiceProvider().CreateEncryptor()创建加密流，因为它已经被微软废弃了。会提示“SYSLIB0021：派生加密类型已过时”，编译也过不去。
SYSLIB0021 警告 - .NET | Microsoft Learn https://learn.microsoft.com/zh-cn/dotnet/fundamentals/syslib-diagnostics/syslib0021
解决办法：把DESCryptoServiceProvider().CreateEncryptor()替换为DES.Create()。
internal static string ToEncrypt(string encryptKey, string str) { try { byte[] byte_key = Encoding.Unicode.GetBytes(encryptKey); //将密钥字符串转换为字节序列 byte[] byte_data = Encoding.Unicode.GetBytes(str); //将字符串转换为字节序列 using var des = DES.Create(); //创建加密流对象 using var memory_stream = new MemoryStream(); //创建内存流对象 using var crypto_stream = new CryptoStream(memory_stream, des. CreateEncryptor(byte_key, byte_key), CryptoStreamMode.Write); //创建加密流对象 crypto_stream.Write(byte_data, 0, byte_data.Length); //向加密流中写入字节序列 crypto_stream.FlushFinalBlock(); //将数据压入基础流 crypto_stream.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5a57b53e8c8206f06fa563200018f94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ca866f18dc38e786d62f7deb2e0811a/" rel="bookmark">
			Docker 的工作原理及安装步骤【云原生】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. Docker 的工作原理2. Docker 与虚拟机3. Docker 架构4. 安装 Docker5. 配置镜像加速 1. Docker 的工作原理 大型项目组件较多，运行环境也较为复杂，部署会碰到一些问题：
① 依赖关系复杂，容易出现兼容性问题；
② 开发、测试、生产环境有差异。
问题一：Docker 是如何解决不同组件之间依赖的兼容性问题的？
Docker 会将应用的函数库、依赖、配置与应用一起打包，然后将每个应用放到一个隔离容器去运行，避免相互干扰。
问题二：不同环境的操作系统不同，Docker 又是如何解决的呢？
所有 Linux 内核的操作系统都可以分为两层，一层是大家共享的 Linux 内核，区别就在于另一层的系统应用不同。
内核负责与硬件交互，提供操作硬件的指令，系统应用负责将内核指令封装为函数，便于程序员使用，最后用户程序基于函数库实现功能。
底层内核可能一样，但是不同的系统应用有着不同的函数库，所以 A 操作系统下的应用是不能在 B 操作系统中运行的。
于是 Docker 将用户程序与它所对应的函数库一起打包，当 Docker 运行到不同的操作系统时，直接基于打包的库函数，借助操作系统的 Linux 内核来实现跨系统运行。
Docker 就是一个快速交付应用、运行应用的技术。
总结：
① Docker 可以将程序及其依赖、运行环境一起打包为一个镜像，可以迁移到任意 Linux 操作系统；
② 运行时利用沙箱机制形成隔离容器，各个应用互不干扰；
③ 启动、移除都可以通过一行命令来完成，方便快捷。
2. Docker 与虚拟机 虚拟机是在操作系统中模拟硬件设备，然后运行在另一个操作系统，比如在 Windows 系统里面运行 Centos 系统，这样就可以运行任意的 Centos 应用了。
虚拟机相当于在一个操作系统里面装了另一个操作系统，那么应用在执行的时候会先去调用内置操作系统，而内置操作系统会与 Hypervisor 交互，然后把信息传递给外置操作系统，最终由外置操作系统来调用计算机硬件，所以总的来说，虚拟机应用的执行要经过操作系统的层层传递，性能肯定是不太好的。
而 Docker 只是用了另一个操作系统的函数库而已，实际在执行的时候是直接调用操作系统内核的，性能要比虚拟机好。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ca866f18dc38e786d62f7deb2e0811a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfe7321f4d1a1600149b09ceca33662c/" rel="bookmark">
			【专业英语】计算机专业英语（第三版）清华大学出版社
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 专业英语 部分专业名词 短语
在这里插入图片描述 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3757e35fd4c2d863a4d8eb171cbcea10/" rel="bookmark">
			Redis的实现三：c语言实现平衡二叉树，通过平衡二叉树实现排序集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概况：Redis中的排序集数据结构是相当复杂的独特而有用的东西。它不仅提供了顺序排序数据的能力，而且具有按排名查询有序数据的独特特性。
Redis中的排序集 （Sorted Set）是一种特殊的数据结构，它结合了集合（Set）和有序列表（List）的特点。在Redis中，每个成员都有一个分数（score），分数可以是整数或浮点数。根据分数对成员进行排序，分数较低的成员排在前面，分数较高的成员排在后面。
以下是Redis中排序集的一些基本操作：
ZADD：向排序集中添加一个或多个成员，或者更新已存在成员的分数。ZREM：从排序集中移除一个或多个成员。ZRANGE：按照分数范围返回排序集中的成员。ZREVRANGE：按照分数范围逆序返回排序集中的成员。ZCOUNT：返回排序集中指定分数范围内的成员数量。ZINCRBY：将指定成员的分数增加指定的值。ZRANK：返回指定成员在排序集中的排名。ZREVRANK：返回指定成员在排序集中的排名（逆序）。ZSCORE：返回指定成员的分数。ZDIFF、ZINTER、ZUNION：合并多个排序集并返回结果。 实际上真正的Redis项目使用的是skiplist，跳表在一定程度上可以替代平衡二叉树
c语言实现平衡二叉树 第一步：定义结构体
typedef struct Node { int data; struct Node *left; struct Node *right; int height; } Node; 左节点，右节点，深度，数据
第二步：定义比较算法
int max(int a, int b) { return (a &gt; b) ? a : b; } 这个很简单的算法，就是单纯的比较两个数，取其中最大的。
第三步：创建节点
Node* createNode(int data) { Node* newNode = (Node*)malloc(sizeof(Node)); newNode-&gt;data = data; newNode-&gt;left = NULL; newNode-&gt;right = NULL; newNode-&gt;height = 1; return newNode; } 第四步：得到高度
int getHeight(Node* node) { if (node == NULL) { return 0; } return node-&gt;height; } 每个节点里面都包含了高度，这个属性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3757e35fd4c2d863a4d8eb171cbcea10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5738a8e99e545ee0e95b3856075f2a2f/" rel="bookmark">
			C语言——扫雷游戏实现（超详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、扫雷游戏规则与实现思路
1、游戏概述
2、游戏规则描述：
3、游戏实现思路
二、模块化代码实现
1、创建主函数main()
2、创建菜单函数
3、创建游戏函数game()
①棋盘的设置
②棋盘的初始化
③打印棋盘
④雷的布置
⑤雷的排查
三、全部源码
四、总结
一、扫雷游戏规则与实现思路 1、游戏概述 扫雷游戏想必大家应该都玩过吧，这个游戏的目标呢就是在一个 9x9 的棋盘上找出所有没有地雷的格子，而不踩到地雷。当然这个9×9只是一个初级玩法，棋盘大小和雷的数量是可以随便设置的，有那种电脑满屏的模式，但是我没去尝试过，一般玩的都是初级9×9的模式，而本篇文章也主要说的是9×9扫雷游戏的实现。
扫雷游戏网页版 - Minesweeper
2、游戏规则描述： 棋盘上的某些格子里有地雷，其他格子是空白的。游戏开始时，棋盘上会有一些数字，这些数字表示周围 8 个格子中地雷的数量。通过点击格子，如果格子是空白的，则会打开该格子；如果格子中有地雷，则游戏结束。如果打开的格子周围的地雷数量与数字相符，则该格子周围的其他格子也会被打开。游戏的目标是在不踩到地雷的情况下，找出所有没有地雷的格子。 扫雷游戏需要玩家运用逻辑推理和数学计算来推断哪些格子可能有地雷，哪些格子是安全的。通过不断尝试和推理，最终完成游戏。总的来说扫雷游戏是一款能够锻炼玩家多种能力的益智游戏，对提高玩家的逻辑推理、数学计算、观察、耐心和毅力、空间想象力等能力都有帮助。平时没事的时候可以玩一玩的，我个人感觉还是很interesting！
3、游戏实现思路 第一步，首先是需要我们去创建一个菜单界面函数，用于选择退出游戏或者是进入游戏。
第二步，创建用于放置雷的棋盘，并进行棋盘初始化。
第三步，放入雷，并打印出雷的初始化棋盘
第四步，输入排查雷的坐标
第五步，反馈输入坐标的结果，之后循环，直到成功排查或被炸死
在扫雷的过程中，创建棋盘布置雷和排查雷都需要储存信息，所以我们需要一定的数据结构来存储这些信息，在布置雷时，如果是雷就放1，不是雷就放0；
同时为了让游戏具有一定的可玩性，便于修改游戏难度，那么们便在头文件中define行、列和雷的数量
#define number 10//雷的个数 #define ROW 9//棋盘显示的长宽 #define COL 9 #define ROWS ROW+2//设置的存储的棋盘的长宽 #define COLS COL+2 二、模块化代码实现 在实现代码之前，我们使用多文件的形式对函数的声明与定义，这可以极大的简化我们的代码
test.c //⽂件中写游戏的测试逻辑 game.c //⽂件中写游戏中函数的实现等 game.h //⽂件中写游戏需要的数据类型和函数声明等 1、创建主函数main() 在主函数中我们创建一个put值，用于输入判断我们菜单的选择，用do while判断我们输入的选择是否结束，在这里我们需要创建菜单函数，每一次循环我们都调用菜单函数，接着使用switch语句中，来执行输入的结果，如果输入1则提示玩家开始游戏并调用游戏函数game()，输入0则退出游戏，输入其他数值则提示错误，并循环执行switch语句，直至玩家主动退出。
int main() { int put = 0;//选项选择 srand((unsigned int)time(NULL));//生成一个随机数，time函数无参返回，返回类型强制转换为unsigned do { menu();//调用菜单函数 printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5738a8e99e545ee0e95b3856075f2a2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e7912b2603927f3cd9f70c60dd00578/" rel="bookmark">
			软件设计师真题，结构化开发专项练习（六）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据字典解析 以下关于数据流图中基本加工的叙述，不正确的是 （15） 。（2013年下半年）
（15） A. 对每一个基本加工，必须有一个加工规格说明
B. 加工规格说明必须描述把输入数据流变换为输出数据流的加工规则
C. 加工规格说明必须描述实现加工的具体流程
D. 决策表可以用来表示加工规格说明
数据字典是结构化分析的一个重要输出。数据字典的条目不包括 （15） 。（2018年上半年）
（15） A. 外部实体 B. 数据流 C. 数据项 D. 基本加工
结构化分析方法中，数据流图中的元素在 （15） 中进行定义。（2020年下半年）
（15） A. 加工逻辑 B. 实体联系图 C. 流程图 D. 数据字典
下列关于结构化分析方法的数据字典加工逻辑的叙述中，不正确的是 （15） 。（2021年上半年）
（15） A. 对每一个基本加工，应该有一个加工逻辑
B. 加工逻辑描述输入数据流变换为输出数据的加工规则
C. 加工逻辑必须实现加工的数据结构和算法
D. 结构化语言，判定树和判定表可以用来表示加工逻辑
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ce5b996170f3fbe6334f41acb957b0a/" rel="bookmark">
			EGE专栏内容导航
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		专栏：EGE专栏
文章目录 1. EGE 官方网址2. EGE 配置相关3. EGE教程4. 示例程序5. 编程相关 1. EGE 官方网址 EGE官网https://xege.org/EGE 库函数文档EGE 库函数文档GitHub 仓库github.com/wysaid/xege 2. EGE 配置相关 内容链接EGE 配置教程EGE安装与配置控制台设置EGE相关：控制台窗口的设置程序打包与图标修改EGE程序打包发布与图标修改 3. EGE教程 EGE及资料文档介绍 EGE介绍EGE相关教程EGE 库函数文档 入门基础示例EGE新手入门示例程序（一） 入门教程 （一）：绘图基础知识（二）：开始使用EGE（三）：开场动画（四）：窗口简单操作（五）：换上我的彩色画笔（六）：基本图形（七）：组合图形（八）：清屏与重绘（九）：双缓冲与手动渲染 分类教程 窗口颜色基础绘图篇高级绘图图像操作光栅操作文字键盘消息鼠标消息音乐播放输入时间视口其它相关 绘图方法与技巧 绘图讲解窗口刷新动画GIF 动图播放按钮（上）按钮（下） 4. 示例程序 新手入门示例程序花火闪烁的夜晚分形2048迷宫 5. 编程相关 文件名 绝对路径与相对路径 专栏：EGE专栏
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79f84df2a7965100fd691c31b617a789/" rel="bookmark">
			Ubuntu环境搭建二：搭建samba服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前看大家搭建的samba服务器，虽然可以共享文件，但是需要管理员权限才能修改，很不方便，这里我教大家一个不需要登录就可以进去的samba服务器，修改文件也不需要其他权限。
1、安装samba：
sudo apt-get install samba 2、安装smbclient：
sudo apt-get install smbclient 3、修改配置文件
sudo gedit /etc/samba/smb.conf 在配置文件的最末尾加上：
[share] comment = shared folder browseable = yes path = /home/jian/share create mode = 0775 directory mode = 0700 valid user = jian force user = jian force group = jian public = yes available = yes writeable = yes 或者
[share] comment = shared folder browseable = yes path = /home/jian/share create mode = 0775 directory mode = 0700 valid user = jian force user = jian force group = jian public = yes available = yes writeable = yes guest ok = yes # 新创建文件权限 create mask = 0755 # 新创建目录权限 directory mask = 0755 # 可写 writable = yes 创建samba共享的目录
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79f84df2a7965100fd691c31b617a789/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76684760aa1074ab054bbbdc85ab0692/" rel="bookmark">
			Linux系统操作——禁ping
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
一、临时禁ping
二、永久禁ping
一、临时禁ping #把1 改成0是允许ping
echo 1 &gt;/proc/sys/net/ipv4/icmp_echo_ignore_all 二、永久禁ping vi /etc/sysctl.conf #添加或修改以下内容，禁ping。把1改成0则是允许ping
net.ipv4.icmp_echo_ignore_all=1 配置完成后执行以下命令
sysctl -p 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4e051653ea26a209c74a367c5fb9852/" rel="bookmark">
			C&#43;&#43;面试问题---Const
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.const 1.1 作用 修饰变量，说明该变量不可以被改变；修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；修饰成员函数，说明该成员函数内不能修改成员变量。 1.2 const 的指针与引用 指针指向常量的指针（pointer to const） 自身是常量的指针（常量指针，const pointer）引用指向常量的引用（reference to const） 没有 const reference，因为引用只是对象的别名，引用不是对象，不能用 const 修饰 1.3使用 // 类 class A { private: const int a; // 常对象成员，可以使用初始化列表或者类内初始化 public: // 构造函数 A() : a(0) { }; A(int x) : a(x) { }; // 初始化列表 // const可用于对重载函数的区分 int getValue(); // 普通成员函数 int getValue() const; // 常成员函数，不得修改类中的任何数据成员的值 }; void function() { // 对象 A b; // 普通对象，可以调用全部成员函数 const A a; // 常对象，只能调用常成员函数 const A *p = &amp;a; // 指针变量，指向常对象 const A &amp;q = a; // 指向常对象的引用 // 指针 char greeting[] = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4e051653ea26a209c74a367c5fb9852/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d482ff99cbacc40f22714c84337f07f2/" rel="bookmark">
			error LNK2001: unresolved external symbol memset
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于程序中没有引用memset函数，却在链接阶段报错提示无法找到memset函数的问题解决方案
参考：
https://www.lab-z.com/stu136/
在编译器选项中加入/FAcs，之后重新编译，可以得到汇编代码cod文件
打开之后搜索memset，即可定位到源代码出问题的行数
之所出现这种问题，是因为编译器进行了自动优化，把你的填充内存的代码优化成了memset函数，这时候只需要使用/Od选项，关闭优化即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7899ea8c899ffa16824432ca0ddd8064/" rel="bookmark">
			【Vue3/Vue2】判断设备是移动端还是pc端跳转不同路由router
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue3代码 APP文件中写入js代码
1、首先，通过isMobile()函数判断用户的设备类型。该函数使用正则表达式匹配navigator.userAgent字符串，以确定用户是在移动设备上访问网页还是在桌面设备上访问网页 2、然后，在onMounted()钩子函数中，根据当前的路由路径来判断是否需要进行重定向。如果当前路径是根路径('/')或移动端首页路径('/mobile_index')，则会进一步检查设备类型。 3、如果是移动设备，则通过router.replace('/mobile_index')将路由重定向到移动端首页。如果是桌面设备，则通过router.replace('/')将路由重定向到桌面端首页。 &lt;script setup lang="ts"&gt; import { onMounted } from 'vue'; import { useRouter, useRoute } from 'vue-router' const router = useRouter() const route = useRoute() const isMobile = () =&gt; { let flag = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i) return flag; } onMounted(() =&gt; { if (route.path === '/' || route.path === '/mobile_index') { if (_isMobile()) { router.replace('/mobile_index') } else { router.replace('/') } } }) router中写法 import type { RouteRecordRaw } from 'vue-router' export const staticRoutes: Array&lt;RouteRecordRaw&gt; = [ // pc { path: '/', component: () =&gt; import('.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7899ea8c899ffa16824432ca0ddd8064/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/275553b54b32aa11e266c1d0104933e9/" rel="bookmark">
			sklearn实现SVR回归(支持向量机)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💥 项目专栏：sklearn实现经典机器学习算法(附代码+原理介绍)
文章目录 前言一、算法背景二、算法原理三、算法实现3.1 导包3.2 加载数据集3.3 划分训练集、测试集3.4 定义模型3.5 网格搜索3.6 可视化拟合曲线 完整源码 前言 🌟 哈喽，亲爱的小伙伴们，你们知道吗？最近我们的粉丝群里有好多小可爱私信问我一些关于决策树、逻辑回归等机器学习的超级有趣的问题呢！🌈 为了让大家更轻松地理解，我决定开一个超可爱的专栏，叫做 用sklearn玩转机器学习，特别适合机器学习的小新手哦！
🍬 在这个专栏里，我们会用sklearn这个超级强大的魔法工具来实现各种闪闪发光的机器学习算法！不用担心难度哦，我会用最简单、最可爱的方式，带领大家一起探索算法的神秘世界！✨
🎈 适合哪些小伙伴加入呢？当然是对机器学习感兴趣的小新手们，还有那些刚开始接触sklearn的可爱宝宝们！我们会一起学习如何用sklearn轻松实现那些看起来好厉害的机器学习算法，让新手小白也能快快乐乐地理解它们哦！
🌸 在这个专栏里，大家可以看到用sklearn实现的机器学习算法，我们不仅仅是理论学习哦，每一篇文章都会附带 完整的代码+超级可爱的原理讲解，让大家在轻松愉快的氛围中一起学习成长呢！🌼 快来加入我们的学习大冒险吧！
🚨 我的项目环境：
平台：Windows11语言环境：Python 3.10编译器：Jupyter Lab、PyCharmscikit-learn：1.2.1Pandas：1.3.5Numpy：1.19.3Scipy：1.7.3Matplotlib：3.1.3 💥 项目专栏：sklearn实现经典机器学习算法(附代码+原理介绍)
一、算法背景 支持向量回归（Support Vector Regression，SVR）是一种用于回归分析的机器学习算法，它借鉴了支持向量机（SVM）分类算法的思想。SVR的算法背景如下：
支持向量机（SVM）：
支持向量机是一种用于二元分类的强大机器学习算法。它的核心思想是找到一个能够将两个不同类别的数据分隔开的最优超平面（决策边界），并使得两侧离超平面最近的数据点（支持向量）到超平面的距离最大化。这个距离被称为间隔（margin）。SVM通过优化一个凸二次规划问题来找到最佳超平面，这个问题的目标是最大化间隔，同时限制支持向量的误分类错误。支持向量机还引入了核函数的概念，使其能够处理非线性可分的数据。 SVR的引入：
SVR是基于SVM的思想，专门用于回归问题。与分类不同，回归任务的目标是预测连续数值输出，而不是离散的类别标签。SVR通过在训练数据中找到一个回归函数，以尽量拟合数据点并保持较大的间隔来解决回归问题。与SVM类似，SVR引入了核函数来处理非线性关系。SVR的目标是找到一个最优超平面，使得在这个超平面上的预测值与真实值之间的误差尽可能小，同时限制误差不超过一个用户定义的容忍度。 工作原理：
SVR的工作原理是在训练集上寻找一个超平面，使得所有训练样本点都位于这个超平面的ε-tube（一个带宽为ε的管道）内。ε-tube内的数据点对回归函数的拟合没有影响，而位于ε-tube之外的点会被视为异常值。SVR的目标是最小化误差项，同时限制误差项不超过ε。可以通过调整超参数（如C、ε、核函数等）来控制模型的复杂性和泛化能力。 总之，支持向量回归（SVR）是一种用于回归分析的机器学习算法，它通过在训练数据上找到一个最优超平面来拟合数据，同时限制误差项，从而实现对连续数值输出的预测。SVR借鉴了支持向量机（SVM）的思想，通过核函数处理非线性关系，是回归问题中的有力工具。
二、算法原理 支持向量回归（Support Vector Regression，SVR）是一种用于解决回归问题的机器学习算法，它基于支持向量机（SVM）的思想，并通过最小化带宽为 ε 的管道内的训练数据点与模型预测之间的误差来建立回归模型。以下是SVR的算法原理的详细介绍：
数据表示：
SVR处理的数据集包括一组输入特征（通常表示为X）和对应的连续目标值或标签（通常表示为y）。这些目标值是实数，而不是离散的类别标签。 目标函数：
SVR的目标是建立一个回归函数f(X)，该函数能够预测目标值y。SVR通过最小化目标函数的误差来拟合数据。目标函数通常表示为：min 0.5 * ||f(X) - y||^2 其中，||f(X) - y||^2 表示欧几里得范数（L2范数）的平方，用于测量预测值与真实值之间的距离。 带宽 ε-tube：
SVR引入了一个带宽为 ε 的管道（ε-tube），它是一个容忍度范围，在这个管道内的误差被认为是可以接受的。管道的宽度 ε 是一个超参数，控制了模型的容忍度。SVR的目标是最小化误差项，同时确保大部分训练数据点都位于 ε-tube 内，只有一小部分数据点位于管道外。这些位于管道外的数据点称为"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/275553b54b32aa11e266c1d0104933e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e82976e9f059d9e9e424f628c56427b/" rel="bookmark">
			关于三目运算符的一些理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​
基本形式: &lt;表达式1&gt; ? &lt;表达式2&gt; : &lt;表达式3&gt;
比较原理：表达式1是否为真，为真，执行表达式2，否则执行表达式3.
例：a = 4 &gt; 3 ? 1 : 0 ; a的值为1
类似于：
//if/else条件判断 if(&lt;表达式1&gt;) { //&lt;表达式2&gt; } else { //&lt;表达式3&gt; } 那么对于下面这道题可以这样写：
模拟交通警察的雷达测速仪。输入汽车速度，如果速度超出60 mph，则显示“Speeding”，否则显示“OK”。
输入格式：
输入在一行中给出1个不超过500的非负整数，即雷达测到的车速。
输出格式：
在一行中输出测速仪显示结果，格式为：Speed: V - S，其中V是车速，S或者是Speeding、或者是OK。
输入样例1：
40
输出样例1：
Speed: 40 - OK
输入样例2：
75
输出样例2：
Speed: 75 - Speeding
代码：
#include&lt;stdio.h&gt; int main(){ int a; scanf("%d",&amp;a); a&lt;=60?printf("Speed: %d - OK",a):printf("Speed: %d - Speeding",a); } 三目运算的嵌套使用：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e82976e9f059d9e9e424f628c56427b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/696b78a2851a9d241a2aa4eed7cbcd0b/" rel="bookmark">
			集成 Firebase 后，Flutter IM SDK 在 Android 端不触发回调
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		描述
客户已集成 Firebase Messaging，Android 平台 Flutter IM SDK 的不触发任何回调。
分析（根因分析、需求分析）
可能原因是客户构建了一个 FlutterEngine instance，导致 SDK 的 FlutterEngine instance 失效了。
解决方案
找到以下 java 文件
packages/firebase_messaging/firebase_messaging/android/src/main/java/io/flutter/plugins/firebase/messaging/FlutterFirebaseMessagingBackgroundExecutor.java
修改代码如下：
if (shellArgs != null) {
Log.i(
TAG,
"Creating background FlutterEngine instance, with args: "
+ Arrays.toString(shellArgs.toArray()));
// 1. 修改此处如下
// backgroundFlutterEngine =
// new FlutterEngine(
// ContextHolder.getApplicationContext(), shellArgs.toArray());
backgroundFlutterEngine =
new FlutterEngine(
ContextHolder.getApplicationContext(), shellArgs.toArray(), false);
} else {
Log.i(TAG, "Creating background FlutterEngine instance.");
// 2. 修改此处如下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/696b78a2851a9d241a2aa4eed7cbcd0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47e403ba6aa8004a6a7fc2cf0cea6c30/" rel="bookmark">
			MapReduce OutputFormat &amp; 内核源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 MapReduce OutputFormat &amp; 内核源码1.1 OutputFormat数据输出1.1.1 OutputFormat接口实现类1.1.2 自定义OutputFormat案例实操 1.2 MapReduce内核源码解析1.2.1 MapTask工作机制1.2.2 ReduceTask工作机制1.2.3 ReduceTask并行度决定机制1.2.4 MapTask &amp; ReduceTask源码解析 MapReduce OutputFormat &amp; 内核源码 1.1 OutputFormat数据输出 1.1.1 OutputFormat接口实现类 OutputFormat是MapReduce输出的基类，所有实现MapReduce输出都实现了 OutputFormat接口。下面我们介绍几种常见的OutputFormat实现类：
1.OutputFormat实现类(默认输出格式为TextOutputFormat 按行读取)
2.自定义OutputFormat
应用场景：如，输出数据到MYSQL/HBase/Elasticsearch等存储框架中
步骤：自定义一个类继承FileOutputFormat --&gt; 改写RecordWriter，具体改写输出数据的write()方法
1.1.2 自定义OutputFormat案例实操 1）需求
过滤输入的 log 日志，包含 atguigu 的网站输出到 D:\java_learning\output\outputformat1，不包含 atguigu 的网站输出到 D:\java_learning\output\outputformat2。
(1)输入data
(2）期望输出数据
两个txt文件：
2）需求分析
3）案例实操
（1）编写 LogMapper 类
package com.root.mapreduce.OutPutFormat; import org.apache.hadoop.io.IntWritable; import org.apache.hadoop.io.LongWritable; import org.apache.hadoop.io.NullWritable; import org.apache.hadoop.io.Text; import org.apache.hadoop.mapreduce.Mapper; import java.io.IOException; public class LogMapper extends Mapper&lt;LongWritable, Text,Text, NullWritable&gt; { @Override protected void map(LongWritable key, Text value, Mapper&lt;LongWritable, Text, Text, NullWritable&gt;.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47e403ba6aa8004a6a7fc2cf0cea6c30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a58e7ae5adbc31b28965106f8bb4e01/" rel="bookmark">
			【开源】基于JAVA&#43;Vue&#43;SpringBoot的校园电商物流云平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、摘要1.1 项目介绍1.2 项目录屏 二、功能模块2.1 数据中心模块2.2 商品数据模块2.3 快递公司模块2.4 物流订单模块 三、系统设计3.1 用例设计3.2 数据库设计3.2.1 商品表3.2.2 快递公司表3.2.3 物流订单表 四、系统展示五、核心代码5.1 查询商品5.2 查询快递公司5.3 查询物流订单5.4 新增物流订单5.5 快递收揽派签 六、免责说明 一、摘要 1.1 项目介绍 基于JAVA+Vue+SpringBoot+MySQL 的校园电商物流云平台，包含了商品管理模块、快递公司模块、物流订单模块，还包含系统自带的用户管理、部门管理、角色管理、菜单管理、日志管理、数据字典管理、文件管理、图表展示等基础模块，校园电商物流云平台基于角色的访问控制，给商家、物流公司、物流管理员使用，可将权限精确到按钮级别，您可以自定义角色并分配权限，系统适合设计精确的权限约束需求。
1.2 项目录屏 二、功能模块 互联网和电子商务行业已成为各产业升级创新的“发动机”，也是大众创业的肥沃土壤。各大院校纷纷在基于互联网或电子商务平台的大学生创业教育方面进行了探索和尝试。依托电子商务专业教育体系，立足于高校市场资源，利用新型的社群移动电商平台开展电子商务创业教育创新实践，取得了较好效果。本文旨在建立一个面向校园电商创业的物流云平台，采用Vue、SpringBoot、MySQL技术，包含数据中心模块、商品档案模块、快递公司模块、物流订单管理模块，对物流配送实现云平台管理。
本文设计的面向校园电商创业的物流云平台的包括了系统数据中心模块，用来存放管理系统通用的模块，另外分别设计了商品档案模块、快递公司模块、物流订单模块这三大模块，用于存放系统的核心业务逻辑。
2.1 数据中心模块 数据中心模块包含了对面向校园电商创业的物流云平台的基础模块，比如管理谁可以登录这套系统，记录这些人登录系统做了什么，不同的人拥有不同权限的管理。
2.2 商品数据模块 商品数据模块用于对商品的数据进行管理，其中包括商品ID、商品名称、商品规格、商品图片、商品备注、归属人ID、归属人、创建人等，可以通过此模块对商品数据进行添加、编辑更新、删除、查询操作。
2.3 快递公司模块 快递公司模块是对快递公司的档案信息进行管理，快递公司是快递运输的主要参与者，快递公司字段包括公司简称、公司全名、LOGO、营业执照、地址、经营范围、备注、创建人等，管理员可以新增快递公司的数据，用户可以查询管理员发布的快递公司信息。
2.4 物流订单模块 物流订单模块是对商品数据的实例化，有了商品后，用户就可以对商品进行创建物流订单，这就产生了物流订单模块，其中包括物流单号、下单人ID、下单人、收件人、收件电话、收件地址、下单日期、订单状态、发货物流等，用户可以进行物流下单，快递公司可以操作发货，管理员可以删除物流订单。
三、系统设计 3.1 用例设计 3.2 数据库设计 3.2.1 商品表 3.2.2 快递公司表 3.2.3 物流订单表 四、系统展示 五、核心代码 5.1 查询商品 @RequestMapping(value = "/getByPage", method = RequestMethod.GET) @ApiOperation(value = "查询商品") public Result&lt;IPage&lt;Commodity&gt;&gt; getByPage(@ModelAttribute Commodity commodity ,@ModelAttribute PageVo page){ QueryWrapper&lt;Commodity&gt; qw = new QueryWrapper&lt;&gt;(); User currUser = securityUtil.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a58e7ae5adbc31b28965106f8bb4e01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9771aa14cef35c5e7aade0ce7ede7c0b/" rel="bookmark">
			Mixtral 8X7B MoE模型基于阿里云人工智能平台PAI实践合集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：熊兮、贺弘、临在
Mixtral 8x7B大模型是Mixtral AI推出的基于decoder-only架构的稀疏专家混合网络（Mixture-Of-Experts，MOE）开源大语言模型。这一模型具有46.7B的总参数量，对于每个token，路由器网络选择八组专家网络中的两组进行处理，并且将其输出累加组合，在增加模型参数总量的同时，优化了模型推理的成本。在大多数基准测试中，Mixtral 8x7B模型与Llama2 70B和GPT-3.5表现相当，因此具有很高的使用性价比。
阿里云人工智能平台PAI是面向开发者和企业的机器学习/深度学习平台，提供包含数据标注、模型构建、模型训练、模型部署、推理优化在内的AI开发全链路服务。
本文介绍如何在PAI平台针对Mixtral 8x7B大模型的微调和推理服务的最佳实践，助力AI开发者快速开箱。以下我们将分别展示具体使用步骤。
使用PAI-DSW轻量化微调Mixtral 8x7B MOE大模型 PAI-DSW是云端机器学习开发IDE，为用户提供交互式编程环境，同时提供了丰富的计算资源。我们在智码实验室（智码实验室）Notebook Gallery中上线了两个微调Mixtral 8x7B MOE大模型的示例，参见下图：
上述Notebook可以使用阿里云PAI-DSW的实例打开，并且需要选择对应的计算资源和镜像。
使用Swift轻量化微调Mixtral 8x7B MOE大模型 Swift是魔搭ModelScope开源社区推出的轻量级训练推理工具开源库，使用Swift进行这一大模型LoRA轻量化微调需要使用2张GU108（80G）及以上资源。在安装完对应依赖后，我们首先下载模型至本地：
!apt-get update !echo y | apt-get install aria2 def aria2(url, filename, d): !aria2c --console-log-level=error -c -x 16 -s 16 {url} -o {filename} -d {d} mixtral_url = "http://pai-vision-data-inner-wulanchabu.oss-cn-wulanchabu-internal.aliyuncs.com/mixtral/Mixtral-8x7B-Instruct-v0.1.tar" aria2(mixtral_url, mixtral_url.split("/")[-1], "/root/") !cd /root &amp;&amp; mkdir -p AI-ModelScope !cd /root &amp;&amp; tar -xf Mixtral-8x7B-Instruct-v0.1.tar -C /root/AI-ModelScope import os os.environ['MODELSCOPE_CACHE']='/root' 当模型下载完毕后，我们使用Swift一键拉起训练任务：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9771aa14cef35c5e7aade0ce7ede7c0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e73bbdbe0a94d2d7fea3faadc7a0829f/" rel="bookmark">
			MapReduce Shuffle机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 MapReduce Shuffle机制1.1 Shuffle机制1.1.1 Shuffle机制1.1.2 Partition分区1.1.3 Partition分区案例实操1.1.4 WritableComparable排序1.1.5 WritableComparable排序案例实操(全排序)1.1.6 WritableComparable排序案例实操(区内排序)1.1.7 Combiner合并1.1.8 Combiner合并案例实操 MapReduce Shuffle机制 1.1 Shuffle机制 1.1.1 Shuffle机制 Map 方法之后，Reduce 方法之前的数据处理过程称之为 Shuffle。
1.1.2 Partition分区 1、问题引出
要求将统计结果按照条件输出到不同文件中（分区）。比如：将统计结果按照手机归属地不同省份输出到不同文件中(分区)。
2.默认Partition分区
public class HashPartitioner&lt;K, V&gt; extends Partitioner&lt;K, V&gt; { public int getPartition(K key, V value, int numReduceTasks) { return (key.hashCode() &amp; Integer.MAX_VALUE) % numReduceTasks; } } 1234567 由源码可以看出：默认分区是根据key的hashCode对ReduceTasks个数取模得到的。用户没法控制哪个key存储到哪个分区。
没有重写getPartition方法时，由于numReduceTasks的数量是设定好的，所以每一个key存放在哪个文件中取决于该key对应的hashcode值!
3、自定义Partitioner步骤
（1）自定义类继承Partitioner，重写getPartition()方法
（2）在Job驱动中，设置自定义Partitioner
(3)自定义Partition后，要根据自定义Partitioner的逻辑设置相应数量的ReduceTask
1.1.3 Partition分区案例实操 1）需求
将统计结果按照手机归属地不同省份输出到不同文件中（分区）
(1)输入数据
（2）期望输出数据
手机号 136、137、138、139 开头都分别放到一个独立的 4 个文件中，其他开头的放到一个文件中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e73bbdbe0a94d2d7fea3faadc7a0829f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec6079aa6f6e33fd98affdbafff95601/" rel="bookmark">
			使用css动画animation及@keyframes实现图片持续放大缩小动画展示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;div class="img"&gt; &lt;img src="@/assets/homeImgs/call.png" alt=""&gt; &lt;/div&gt; css样式 .img { width: 60px; height: 60px; padding: 10px; box-sizing: border-box; background: #fff; border-radius: 50px; box-shadow: 0px 0px 4px 1px rgba(196, 178, 177, 0.5), 0px 0px 8px 2px rgba(186, 177, 196, 0.5) inset; img { width: 100%; height: 100%; animation-name: scaleDraw; /*关键帧名称*/ animation-timing-function: ease-in-out; /*动画的速度曲线*/ animation-iteration-count: infinite; /*动画播放的次数*/ animation-duration: 3s; /*动画所花费的时间*/ } } @keyframes scaleDraw { /*定义关键帧、scaleDrew是需要绑定到选择器的关键帧名称*/ 0% { transform: scale(1); /*开始为原始大小*/ } 25% { transform: scale(1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec6079aa6f6e33fd98affdbafff95601/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4215334c0f26d7beb96c6ccf9c736ba5/" rel="bookmark">
			怎么使用Android studio解决合并冲突
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Resolve Git conflicts
Git如何解决冲突
merge之后，不通过第三方工具，也是可以解决冲突的，需要手动找到合并后的文件。需要说明的是，合并后的问题会通过&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD等标识出来，冲突的地方在哪里，没有冲突的地方已经自动合并了。
但是，在复杂的合并过程中，&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD标识出来的冲突的地方很乱，比如跨越{}，而且冲突的代码很长。
采用android studio解决冲突的工具就会好很多，不会在{}中提示你冲突，而且冲突标记的更精确细化
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32f40e58c6494d8c09c4fe4559a939a7/" rel="bookmark">
			9个非常流行的Python可视化工具包详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概要 数据可视化是数据科学和数据分析领域中不可或缺的一部分。Python拥有丰富的可视化工具包，可以帮助大家将数据转化为图形、图表和可交互的仪表板。本文将介绍9个流行的Python可视化工具包，每个工具包都有其独特的特点和适用场景。
1. Matplotlib Matplotlib是Python中最经典和广泛使用的绘图库之一。它提供了丰富的绘图功能，包括线图、散点图、柱状图、饼图等。Matplotlib的强大之处在于其高度可定制性，可以通过设置各种属性来控制图形的外观和样式。
import matplotlib.pyplot as plt # 创建一个简单的折线图 x = [1, 2, 3, 4, 5] y = [10, 15, 7, 12, 9] plt.plot(x, y) plt.xlabel('X轴标签') plt.ylabel('Y轴标签') plt.title('折线图示例') plt.show() 2. Seaborn Seaborn是基于Matplotlib的Python数据可视化库，它提供了更高级的接口和内置的主题和颜色选项。Seaborn适用于绘制统计数据的图形，可以轻松创建热图、箱线图、小提琴图等。
import seaborn as sns # 创建一个箱线图 data = sns.load_dataset("tips") sns.boxplot(x="day", y="total_bill", data=data) plt.xlabel('日期') plt.ylabel('总账单') plt.title('箱线图示例') plt.show() 3. Plotly Plotly是一个交互式可视化工具，可以生成交互式图表和仪表板。它支持多种图表类型，包括散点图、条形图、3D图等。Plotly的可视化可以在Web应用程序中嵌入和共享。
import plotly.express as px # 创建一个交互式散点图 df = px.data.iris() fig = px.scatter(df, x="sepal_width", y="sepal_length", color="species") fig.update_layout(title='交互式散点图示例') fig.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32f40e58c6494d8c09c4fe4559a939a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/588b5b7e7c93c2d430ce2d4e5662c444/" rel="bookmark">
			Python Pandas 中的 shift() 函数，实现数据平移的完美利器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概要 shift() 是 Pandas 中一个常用的数据处理函数，它用于对数据进行移动或偏移操作，常用于时间序列数据或需要计算前后差值的情况。本文将详细介绍 shift() 函数的用法，包括语法、参数、示例以及常见应用场景。
什么是 shift() 函数？ shift() 函数是 Pandas 库中的一个数据处理函数，用于将数据按指定方向移动或偏移。它可以对时间序列数据或其他类型的数据进行操作，通常用于计算时间序列数据的差值、百分比变化等。该函数的主要作用是将数据移动到指定的行或列，留下空白或填充 NaN 值。
shift() 函数的语法 shift() 函数的基本语法如下：
DataFrame.shift(periods=1, freq=None, axis=0, fill_value=None) 参数说明：
periods：指定移动的步数，可以为正数（向下移动）或负数（向上移动）。默认为 1。
freq：可选参数，用于指定时间序列数据的频率，通常用于时间序列数据的移动操作。
axis：指定移动的方向，可以为 0（默认，沿行移动）或 1（沿列移动）。
fill_value：可选参数，用于填充移动后留下的空白位置，通常为填充 NaN 值。
shift() 函数的示例 通过一些示例来演示 shift() 函数的用法。
示例 1：向下移动数据 import pandas as pd data = {'A': [1, 2, 3, 4, 5], 'B': [10, 20, 30, 40, 50]} df = pd.DataFrame(data) # 向下移动一行数据 df_shifted = df.shift(periods=1) print(df_shifted) 输出结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/588b5b7e7c93c2d430ce2d4e5662c444/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d54b040b37570286f8bbcf711187b369/" rel="bookmark">
			基本工具配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 github加速 github.ur1.fun java # ubuntu20.04 安装 openjdk-17-jdk sudo apt install openjdk-17-jdk java -version javac -version which java 参考 openjdk gradle换源 修改gradle-wrapper.properties distributionBase=GRADLE_USER_HOME distributionPath=wrapper/dists #distributionUrl=https\://services.gradle.org/distributions/gradle-8.2-all.zip # 换源 distributionUrl=https\://mirrors.cloud.tencent.com/gradle/gradle-8.2-all.zip zipStoreBase=GRADLE_USER_HOME zipStorePath=wrapper/dists Android CMAKE_SYSROOT -DCMAKE_SYSROOT=$android_ndk_home/toolchains/llvm/prebuilt/linux-x86_64/sysroot 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/953b1cac4d710aa0643a94992a9b369e/" rel="bookmark">
			uniapp搜索附近蓝牙信标（iBeacon）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 iBeacon介绍 iBeacon是苹果在2013年WWDC上推出一项基于蓝牙4.0（Bluetooth LE | BLE | Bluetooth Smart）的精准微定位技术，在iPhone 4S后支持。当你的手持设备靠近一个Beacon基站时，设备就能够感应到Beacon信号，范围可以从几毫米到50米。因为是一种定位技术，苹果将iBeacon相关的接口放到了 CoreLocation.framework。Google在Android 4.3及后续版本支持了该功能，只要满足iBeacon技术标准即可。iBeacon底层的技术使用的使用BLE（Bluetooth Low Energy）。
二、技术文档 参考：lBeacon API
三、代码实现 //开始搜索蓝牙设备 startDiscoverBluetooth() { let that = this; //蓝牙初始化 uni.openBluetoothAdapter({ success(res) { uni.getLocation({ success(res) { //开始搜索蓝牙设备 uni.startBeaconDiscovery({ success(res) { uni.onBeaconUpdate((res) =&gt; { console.log("设备信息=&gt; ", res) }) }, fail(res) { console.log('搜索蓝牙设备失败！', res); } }) }, fail(res) { uni.showModal({ title:'提示', content:'请打开位置，并下拉刷新！', confirmText:'好的', showCancel:false, }) } }) }, fail(res) { uni.showModal({ title:'提示', content:'请打开蓝牙，并下拉刷新！', confirmText:'好的', showCancel:false, }) } }) }, 四、小结 目前只能在手机处于亮屏状态下（包括软件在后台运行）才能监测到周围的信标设备，熄屏状态下监测不到（目前还未解决），如有解决的，欢迎大神留言讨论！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69f71fdc92f6d8e80790e52d8b79d14d/" rel="bookmark">
			Python Web开发库之vcrpy 使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概要 在现代Web开发中，HTTP请求是不可避免的一部分。然而，通过网络发送HTTP请求可能会导致一些问题，如慢速响应、网络不稳定和API限制。为了解决这些问题，Python社区开发了一些工具和库，其中之一就是vcrpy。vcrpy是一个用于优化HTTP请求的强大工具，它可以捕获、回放和存储HTTP请求和响应，以提高测试效率和降低对外部服务的依赖。本文将详细介绍vcrpy的功能和用法，并提供丰富的示例代码来帮助大家深入了解它。
安装和导入vcrpy 要开始使用vcrpy，首先需要安装它。
可以使用pip进行安装：
pip install vcrpy 安装完成后，可以在Python中导入vcr模块：
import vcr 基本用法 vcrpy的基本思想是将HTTP请求和响应记录到磁盘上的“磁带”文件中，以便在以后的测试中回放。
以下是一个简单的示例，演示了如何使用vcrpy记录和回放HTTP请求：
import requests import vcr # 创建一个VCR对象来管理记录和回放 with vcr.use_cassette('example_cassette.yml'): # 发送HTTP请求，并将响应存储到磁带中 response = requests.get('https://jsonplaceholder.typicode.com/posts/1') print(response.json()) # 在以后的测试中，可以回放磁带中的HTTP请求，而不必访问网络 在这个示例中，首先创建了一个VCR对象，然后使用with语句将HTTP请求和响应记录到名为example_cassette.yml的磁带文件中。在以后的测试中，可以回放这个磁带中的HTTP请求，而不必访问网络，从而提高测试的效率和稳定性。
高级用法
除了基本用法外，vcrpy还提供了一些高级功能，如过滤器、请求匹配和自定义存储等。
1. 过滤器 vcrpy可以定义一些过滤器，以过滤HTTP请求中的敏感信息，如API密钥或个人令牌。
以下是一个示例，演示了如何使用过滤器来屏蔽HTTP请求中的敏感信息：
import requests import vcr # 创建一个自定义过滤器，将所有请求中的"Authorization"头字段替换为"FILTERED" def custom_filter(r): r.headers['Authorization'] = 'FILTERED' return r with vcr.use_cassette('filtered_cassette.yml', before_record_response=custom_filter): response = requests.get('https://api.example.com/resource', headers={'Authorization': 'Bearer my-secret-token'}) print(response.json()) 在这个示例中，创建了一个名为custom_filter的自定义过滤器，它会将HTTP请求中的Authorization头字段替换为FILTERED，从而隐藏了敏感信息。
2. 请求匹配 vcrpy可以定义请求匹配规则，以便在回放时选择正确的磁带。这对于处理多个相似的HTTP请求非常有用。
以下是一个示例，演示了如何使用请求匹配规则：
import requests import vcr # 创建一个请求匹配规则，仅匹配GET请求，并且URL中包含"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69f71fdc92f6d8e80790e52d8b79d14d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d3e3fcbe4b7a1af28a4a68da2cead28/" rel="bookmark">
			微信小程序显示和隐藏分享按钮
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://developers.weixin.qq.com/miniprogram/dev/api/share/wx.hideShareMenu.html
wx.hideShareMenu({ menus: ['shareAppMessage', 'shareTimeline'] }) //shareTimeline分享到朋友圈 //shareAppMessage分享给朋友 隐藏之后就不可以分享了
wx.showShareMenu({ withShareTicket: true, menus: ['shareAppMessage', 'shareTimeline'] }) 显示之后就可以显示了，可以先全部隐藏，根据条件进行显示
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/316f453f29f0833242d79ccf8dd9547f/" rel="bookmark">
			精确掌控并发：分布式环境下并发流量控制的设计与实现（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3. 固定窗口 参考：精确掌控并发：分布式环境下并发流量控制的设计与实现（一）-CSDN博客
4. 滑动窗口 滑动窗口算法是一种更为灵活的流量控制方案，它比固定窗口算法能更平滑地处理突发流量。在滑动窗口中，时间窗口是重叠的，这意味着流量的计算是基于过去的一段连续时间内发生的事件。
工作流程：
窗口定义：确定窗口的大小，例如1秒钟，并设置窗口的滑动间隔，比如100毫秒。计数与滑动：每个窗口都有自己的计数器。当一个新请求到达时，增加当前时间窗口及其前面相邻的窗口的计数。限制检查：如果任何连续时间段内的请求总数超过阈值，则拒绝新的请求。窗口更新：随着时间的推移，不断向前滑动窗口，并更新相应的计数器。 实现细节：
滑动窗口可以通过队列或循环数组来实现。每个窗口对应队列中的一个元素，记录该窗口期间的请求数。当时间滑动时，更新队列头部的元素，并可能将旧的元素出队。
例如，在Redis中，可以使用列表或有序集合来模拟这种滑动窗口。下面是一个Rdis实现的示例，使用有序集合（sorted set）来实现了滑动时间窗口算法：
public class RateLimiter { public static boolean isAllowed(String channel) { long currentTimeMillis = Instant.now().toEpochMilli(); String key = "rate_limiter:" + channel; try (Jedis jedis = new Jedis(REDIS_HOST, REDIS_PORT)) { // 使用Redis的多个命令来实现滑动窗口 jedis.zremrangeByScore(key, 0, currentTimeMillis - WINDOW_SIZE_IN_SECONDS * 1000); long requestCount = jedis.zcard(key); if (requestCount &lt; MAX_REQUESTS) { jedis.zadd(key, currentTimeMillis, "" + currentTimeMillis); jedis.expire(key, WINDOW_SIZE_IN_SECONDS); return true; } else { return false; } } } } 每个请求都以其发生的时间戳作为分数存储在集合中。通过移除旧于当前时间窗口的请求来维护滑动窗口。通过检查集合中的元素数量，以确定是否超过了设定的最大请求数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/316f453f29f0833242d79ccf8dd9547f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f377b346fc556fc78bd344d85468b0b5/" rel="bookmark">
			RSIC-V“一芯”学习笔记（一）——概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		考研的文章和资料之后想写的时候再写怕趴
文章目录 一、阶段设计二、环境、开发语言和工具三、最重要的两个观念四、处理器芯片设计五、处理器芯片设计包含很多软件问题六、处理器芯片的评价指标七、复杂系统的构建和维护八、专业世界观九，提问的艺术(提问模板)十、考核情况 一、阶段设计 B阶段：以RVE为主、将RT-Thread移植到AM、在给定的面积预算内优化处理器设计A阶段：从RVE转到RV64IMAC、最终运行Linux发行版开源EDA
二、环境、开发语言和工具 Linux环境：我准备直接用虚拟机了
软件：C语言、C++（少量）、gcc编译器。
（幸好之前苏嵌学过gcc、makefile等基础知识，底子打的好）
硬件开发:verilog 开源verilator仿真器+开源gtkwave波形查看器
（对于verilog，看了看之前学fpga的时候，倒是了解过一点，但是学的不是很深入）
硬件配置：笔记本电脑就行，无需FPGA
（当然自己设计的处理器放在上面跑也是可以的）
这里比较推荐的是ASIC
三、最重要的两个观念 1.硬件需要软件的支持才能发挥作用
狭义的处理器芯片设计: RTL开发
广义的处理器芯片设计:计算机系统软硬件协同设计
2.复杂系统是迭代演进的(多周期-&gt;流水线-&gt;超标量-&gt;乱序执行)
做事规律-从易到难，逐步推进
推荐阅读:《 系统设计黄金法则:简单之美》,包云岗
KISS法则- Keep It Simple, Stupid
四、处理器芯片设计 本质：实例化和连续
可以用面包板开发，但是逐渐转成RTL开发(效率高、更方便)
补充：RTL级和Verilog语言
RTL:寄存器传输级
Verilog可以从五个层次对电路（系统）进行描述，包括:系统级、算法级、寄存器传输级（即RTL级）、门级、开关级。我们平时用的最多的为RTL级，故Verilog代码也经常被称为RTL代码。
入门verilog文章–想学verilog的，可以看看这篇文章
五、处理器芯片设计包含很多软件问题 两个本质原因
处理器芯片和其他芯片不同,离开软件就无法工作.代码即软件- RTL代码也是,即使它描述的是硬件
需要使用合适的软件技术管理/维护/测试/评估/优化代码 软件怎么在处理器上运行？等等
六、处理器芯片的评价指标 正确性-最基本。运行100000000次后，是否也能正常运行？软件支持–你设计的芯片只能运行排序程序，还是能启动Linux微结构复杂度 - 单周期 复杂度 cache 分支预测PPA（性能（IPC主频）、功耗、面积）可配置性代码可读性、可维护性 七、复杂系统的构建和维护 了解全系统的每一处细节，为调bug有大方向先完成后完美，体会每一项技术对系统带来的性能提升构建正确的工具，提升开发速率经验总结 八、专业世界观 代码要独立完成 九，提问的艺术(提问模板) 模板：
请回答以下问题:
你认为本问题是否属于能力训练的范畴? 是, 我应该尽最大努力解决这个问题来得到训练 否, 我要汇报讲义或框架代码中的问题, 或提供改进的建议 其他, 请补充说明 这个问题是否可以通过自己动手试一试来了解答案? (例如类似"执行ls会发生什么"/“C语言中除0会发生什么”/“Cache是直接相联更好还是组相联更好”) 是, 我试一试就可以知道答案 否, 这个问题不属于此类别 是否已经阅读并理解相关的报错信息 是 否 不适用, 这个问题没有报错信息 是否已经仔细阅读了讲义, 并确认讲义中没有提到相关信息 是 否 不适用, 这个问题属于调试的训练, 需要我独立解决 是否可以通过重新编译解决问题?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f377b346fc556fc78bd344d85468b0b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b324e1e28c7a955a0bba8c63fda82b09/" rel="bookmark">
			函数式编程 - 组合compose的使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数式编程中有一个比较重要的概念就是函数组合（compose）,组合多个函数，同时返回一个新的函数。调用时，组合函数按顺序从右向左执行。右边函数调用后，返回的结果，作为左边函数的参数传入，严格保证了执行顺序，这也是compose 主要特色。| 函数式编程--函数组合(Function composition) - 知乎
入门简介 组合两个函数 compose 非常简单，通过下面的示例代码，就非常清楚。
function compose (f, g) { return function(x) { return f(g(x)); } } var arr = [1, 2, 3], reverse = function(x){ return x.reverse()}, getFirst = function(x) {return x[0]}, compseFunc = compose(getFirst, reverse); compseFunc(arr); // 3 参数在函数间就好像经过‘管道’传输同样，最右边的函数接收外界参数，返回结果传给左边的函数，最后输出结果。
组合任意个函数 上面组合了两个函数的compose，也让咱们了解了组合的特点，接着咱们看看如何组合更多的函数，由于在实际应用中，不会像入门介绍的代码那么简单。
主要注意几个关键点：
1、利用arguments的长度得到所有组合函数的个数
2、reduce 遍历执行全部函数。
var compose = function() { var args = Array.prototype.slice.call(arguments); return function(x) { if (args.length &gt;= 2) { return args.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b324e1e28c7a955a0bba8c63fda82b09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e5b78a418328eae9a08ac04522e5d1a/" rel="bookmark">
			如何查看一篇论文是期刊还是会议？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何查看一篇论文是期刊还是会议？这是大家看论文的时候比较关注的事情，还有这篇论文是什么等级的？
1、如何查看一篇论文是期刊还是会议？
从论文的封面可以直接看出来，比如下面这种：
conference就是会议的意思，下面这一篇就是2023年CVPR的一篇论文
下面的这种就是期刊：
还有一种就是arxiv上面的论文：下载下来没有任何信息，这种情况除非能搜到关于他的信息或者联系作者，否则不知道来自何种期刊。
2、论文的等级
大家看论文的时候除了首先看摘要，是否对自己有帮助，还有就是看等级。下面是几种方法。
①使用LePhu
进入页面之后就可以根据期刊名称或者ISSN查看你想看的论文是什么等级的。
比如我查看的23年的一篇论文，下面这篇就是一篇1区的Top文章
3、免费的文献下载（除了google学术之外）这个网站也为学术道路提供了很好的便利。
①https://gfsoso.99lb.net/sci-hub.html
②https://sci-hub.shop/
③https://sci-hub.ren/
④https://sci-hub.tw/
⑤https://sci-hub.se/
这个需要首先知道DOI号进行下载。
4、还有一个就是大家以后写论文的时候能用到的网站thesaurus，同义词转换（可以这么简单的来解释）。
希望能帮助刚开始看论文的大家！！！新年要到了，祝大家科研顺利，新的一年多多发论文！！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab15d523058716d170af1cf36f753c44/" rel="bookmark">
			Android 判断网络wifi是否可用工具类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import android.content.Context import android.net.ConnectivityManager import android.net.NetworkCapabilities import android.os.Build fun isWifiAvailable(context: Context): Boolean { val cm = context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) { val network = cm.activeNetwork ?: return false val capabilities = cm.getNetworkCapabilities(network) ?: return false return capabilities.hasTransport(NetworkCapabilities.TRANSPORT_WIFI) } else { val networkInfo = cm.activeNetworkInfo ?: return false return networkInfo.isConnected &amp;&amp; networkInfo.type == ConnectivityManager.TYPE_WIFI } } 使用 if (isWifiAvailable(this)) { // WiFi 可用 } else { // WiFi 不可用 } 注意：需要在 AndroidManifest.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab15d523058716d170af1cf36f753c44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ea0b52fa3202a405a7c5f59c4af17f1/" rel="bookmark">
			高级路由技术案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 案例项目一：1、静态ECMP和浮动静态路由配置实验2、浮动静态路由配置 案例项目二：使用filter-policy过滤路由案例项目三：IS-IS基本配置案例项目四：OSPF基本配置案例任务一：OSPF单区域配置案例任务二：OSPF多区域配置 案例项目一： 1、静态ECMP和浮动静态路由配置实验：
2、浮动静态路由配置
案例内容与目标：
1、如何在路由器上配置静态ECMP
2浮动静态路由配置
案例组网图：
案例设备和器材：
两台路由器
两台PC
案例主要过程：
1、静态ECMP和浮动静态路由配置实验 步骤一：建立物理连接
步骤二：ip地址配置：
PCA配置：
PCB：
RTA：
[RTA]interface GigabitEthernet 0/0 [RTA-GigabitEthernet0/0]ip address 192.168.0.1 24 [RTA]interface GigabitEthernet 0/1 [RTA-GigabitEthernet0/1]ip address 192.168.1.1 30 [RTA]interface Serial 1/0 [RTA-Serial1/0]ip address 192.168.1.5 30 RTB：
[RTB]interface GigabitEthernet 0/0 [RTB-GigabitEthernet0/0]ip address 192.168.2.1 24 [RTB]interface GigabitEthernet 0/1 [RTB-GigabitEthernet0/1]ip address 192.168.1.2 30 [RTB]interface Serial 1/0 [RTB-Serial1/0]ip address 192.168.1.6 30 步骤三：静态等值路由配置
RTA：
[RTA]ip route-static 192.168.2.0 255.255.255.0 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ea0b52fa3202a405a7c5f59c4af17f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6aafdbe488cdc89ef6af83373e2327af/" rel="bookmark">
			VQGAN：从图像重建到图像生成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文的目标是作为全新图像生成系统的VQGAN。我已经开始讨论VQGAN的一部分——自编码器（VQVAE：矢量量化变分自动编码器）。VQVAE的概念是对编码器、解码器和码书的同时训练，该码书适用于所有可能的图像。码书是一组256个嵌入向量。具有输入分辨率256x256的任何图像的潜在空间由码书向量的某个子集表示。下面的图片底部显示了VQVAE管道的插图：
编码器将输入图像（256x256像素分辨率）转换为具有16x16条目的潜在空间，每个条目是一个具有256个值的向量（在图1的图表中，潜在空间显示为4x4条目的平面）。然后，潜在空间中的每个条目都更改为来自码书的L2度量最近的向量 —— 这个过程称为矢量量化。因此，潜在空间由16x16的码书索引平面表示。将这个量化的潜在空间发送到解码器，我们得到重建图像。
在VQGAN中，自编码器部分通过一个额外的CNN——基于块的判别器（见图）扩展。判别器具有分类器结构。在图片中显示了VQVAE和判别器之间的交互：重建图像后，它被发送到判别器，判别器为图像块生成类别值。判别器为输入图像和重建图像获得“每个块的类别”空间，并在每个块上验证这些空间之间的类别差异：相同类别（真实）或不同类别（伪造）。判别器参与VQGAN的训练，并试图最大化其损失，但共同的损失 = VQVAE损失 + 判别器损失被最小化。关于VQGAN损失组成的良好解释在这里。在训练步骤中，当训练好的模型进行图像重建时，不使用判别器，它用于改进VQVAE在训练步骤中的质量。判别器在GAN训练的下一步中发挥着重要作用，用于生成新图像。
潜在空间的实际实验
在本节中，我在实践中演示了使用VQGAN进行图像重建，并对潜在空间、码书及其在生成新图像中的作用进行了实验。在这里，我在我的Google Colab中使用以下代码。导入：
import copy import cv2 import sys import torch from PIL import Image from torchvision import transforms import matplotlib.pyplot as plt import numpy as np Google Drive映射：
from google.colab import drive drive.mount('/content/gdrive') Cuda设备设置：
device = torch.device('cuda') if torch.cuda.is_available() else torch.device('cpu') VQGAN的安装和模型下载：
%pip install omegaconf&gt;=2.0.0 pytorch-lightning&gt;=1.0.8 einops&gt;=0.3.0 sys.path.append(".") !git clone https://github.com/CompVis/taming-transformers %cd taming-transformers # download a VQGAN with f=16 (16x compression per spatial dimension) and with a codebook with 1024 entries !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6aafdbe488cdc89ef6af83373e2327af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e9a1551315b708c912ac3620ca090db/" rel="bookmark">
			将Android应用修改为鸿蒙应用的工作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将Android应用修改为鸿蒙（HarmonyOS）应用需要进行一系列主要的工作。以下是在进行这一转换过程中可能需要进行的主要工作，希望对大家有所帮助。北京木奇移动技术有限公司，专业的软件外包开发公司，欢迎交流合作。
1.项目结构调整：
调整应用项目结构，使其符合鸿蒙应用的目录结构和规范。鸿蒙应用采用了不同的项目结构，包括config、entry、resources等目录。
2.UI层适配：
适配应用的用户界面以符合鸿蒙OS的分布式UI编程模型。考虑多设备、多分辨率的情况，确保界面在不同设备上能够良好展示。
3.代码适配：
适配应用的Java或Kotlin代码，根据鸿蒙OS的API调整代码，考虑鸿蒙的不同实现方式和特性。这可能涉及到替代Android API的使用或修改应用逻辑。
4.处理原生库和第三方库：
处理Android应用中使用的原生库和第三方库。鸿蒙并非直接支持Android上的所有库，可能需要替代或适配，以确保库在鸿蒙上能够正常工作。
5.权限处理：
适配权限处理，确保应用在鸿蒙OS上正确请求和管理权限。鸿蒙OS可能对权限的处理方式有所不同。
6.网络连接和离线支持：
考虑应用在鸿蒙OS上的网络连接和离线支持。鸿蒙应用可能在不同网络环境下运行，需确保应用能够处理不同网络状态。
7.设备适配：
适配应用以确保在不同设备上的正确显示和操作。考虑鸿蒙OS支持的多种设备类型，包括手机、平板、电视等。
8.性能优化：
进行性能优化，确保应用在各种设备上都能够流畅运行。考虑资源使用、启动时间和响应速度等方面的优化。
9.分布式协同性：
如果应用需要在鸿蒙OS上实现分布式协同工作，适配应用的功能以在多个设备上协同工作，提供一致的用户体验。
10.测试和调试：
利用鸿蒙开发者工具进行测试和调试。确保应用在鸿蒙设备上表现良好，并解决可能出现的问题。
11.图标和截图：
提供适配鸿蒙应用商店的应用图标和截图，以提高应用在鸿蒙应用商店中的吸引力。
12.发布和分发：
使用鸿蒙应用商店或其他适配的渠道发布和分发应用。确保应用在鸿蒙OS上的正常发布和更新。
这些工作涵盖了从Android应用转换为鸿蒙应用的关键方面。在整个过程中，开发者需要深入了解鸿蒙OS的特性和开发模型，以便更好地适配和优化应用。及时关注鸿蒙OS的官方文档和更新，以获取最新的开发信息。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32bf5ded3a5ee036cea3691a84fa471e/" rel="bookmark">
			Android studio 历史版本下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android studio 历史版本 https://developer.android.google.cn/studio/archive页面加载完成后，点击I agree
进入历史版本列表
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfcdaffa90710cc8d3fb85a6453e41eb/" rel="bookmark">
			Zabbix自定义监控内容实验（带自动报警）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 实验前准备1.部署zabbix服务端(1) 关闭防火墙(2)获取zabbix下载源(3)换源(4)安装SCL(5)安装zabbix所需的数据库(6)修改zabbix server配置文件(7)启动zabbix相关服务(8)测试(9)如果中文乱码怎么办？ 2. 部署zabbix客户端(1)关闭防火墙(2)时间同步(3)设置zabbix的下载源，安装zabbix-agent2(4)修改agent2配置文件(5)启动zabbix-agent2(6)验证(7)添加主机 3. 自定义监控内容(1)定义key(2)中间测试(3)创建自定义监控(4)添加组件(5)邮件报警 实验前准备 zabbix服务端：192.168.188.17
zabbix客户端：192.168.188.11
1.部署zabbix服务端 （192.168.188.17）
zabbix-server 内存至少2G，推荐4G
(1) 关闭防火墙 systemctl stop firewalld
setenforce 0
(2)获取zabbix下载源 rpm -ivh https://mirrors.aliyun.com/zabbix/zabbix/5.0/rhel/7/x86_64/zabbix-release-5.0-1.el7.noarch.rpm
(3)换源 更换zabbix.repo为阿里源，这样可以下得快一点
cd /etc/yum.repos.d
sed -i ‘s#http://repo.zabbix.com#https://mirrors.aliyun.com/zabbix#’ zabbix.repo
yum clean all &amp;&amp; yum makecache
yum install -y zabbix-server-mysql zabbix-agent
(4)安装SCL 便于安装高版本php
yum install -y centos-release-scl
修改zabbix-front前端源，安装zabbix前端环境到scl环境下
vim zabbix.repo
开启安装源
yum install -y zabbix-web-mysql-scl zabbix-apache-conf-scl
(5)安装zabbix所需的数据库 把zabbix服务端所需要的数据库结构直接下载下来
yum install -y mariadb-server mariadb
开启
systemctl start mariadb
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfcdaffa90710cc8d3fb85a6453e41eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1ce81c8f250a7a7a93f80392ae5644a/" rel="bookmark">
			mysql8 源码下载mysql8编译mysql8安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ubuntu22下的mysql8 源码带boost下载，mysql8 源码编译debug安装
##mysql8源码下载地址
mkdir -p /home/yym/mysql8/
cd /home/yym/mysql8/
##mysql8.1.0
wget https://cdn.mysql.com//Downloads/MySQL-8.1/mysql-boost-8.1.0.tar.gz
##mysql8.2.0
wget https://cdn.mysql.com//Downloads/MySQL-8.2/mysql-boost-8.2.0.tar.gz
##解压mysql8.1.0源码
tar -zxvf mysql-boost-8.1.0.tar.gz
##安装依赖包
sudo apt install openssl
sudo apt install libssl-dev
sudo apt install libncurses-dev
##cmake
sudo apt install cmake
cd /home/yym/mysql8/mysql-8.1.0
mkdir -p build
##进入build目录cmake,cmake产生文件放到build目录下
cd /home/yym/mysql8/mysql-8.1.0/build
sudo cmake .. -DCMAKE_INSTALL_PREFIX=/home/yym/mysql8-install/mysql -DMYSQL_DATADIR=/home/yym/mysql8-install/data -DSYSCONFDIR=/home/yym/mysql8-install/etc -DWITH_INNOBASE_STORAGE_ENGINE=1 -DWITH_MEMORY_STORAGE_ENGINE=1 -DWITH_PARTITION_STORAGE_ENGINE=1 -DDOWNLOAD_BOOST=1 -DWITH_BOOST=/home/yym/mysql8/mysql-8.1.0/boost -DWITH_DEBUG=1
##12核cpu编译
cd /home/yym/mysql8/mysql-8.1.0/build
sudo make -j12
##安装
sudo make install
##my.cnf文件配置
[client] default-character-set=utf8mb4 socket=/home/yym/mysql8-install/data/mysql.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1ce81c8f250a7a7a93f80392ae5644a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1523869b09f4d760bba41007625dff22/" rel="bookmark">
			GFS分布式文件系统（详解与配置）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
存储
存储类型
存储技术的发展趋势：
存储在应用中的重要性：
文件系统
弹性 HASH 算法
优点
GlusterFs简述
概念
特点
术语
架构组件
模块化堆栈式架构
GlusterFS 的工作流程
GlusterFS的卷类型
卷实例
分布式卷示例
条带卷示例
复制卷示例
分布式条带卷示例
分布式复制卷示例
条带复制卷：
分布式条带复制卷：
仲裁卷：
部署GlusterFS 群集实例
环境准备
磁盘分区并挂载
配置/etc/hosts文件
安装、启动GlusterFS
添加节点到存储信任池中
创建卷
创建分布式卷
创建条带卷
创建复制卷
创建分布式条带卷
创建分布式复制卷
查看当前所有卷的列表
部署 Gluster 客户端
安装客户端软件
创建挂载目录
配置/etc/hosts文件
挂载 Gluster 文件系统
测试 Gluster 文件系统
破坏性测试
其他维护命令
存储 存储是计算机系统中用于保留数据、程序和信息的过程和设备。它包括了数据的永久性保存，以便在需要时可以检索、读取和操作。存储可以分为多种类型，包括：
存储类型 主存储 (RAM - Random Access Memory) 用于存储正在运行的程序、操作系统和当前需要的数据。
是临时性的，失去电源时数据会丢失。
辅助存储 硬盘驱动器 (HDD)：常见的机械式存储设备，以磁盘存储数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1523869b09f4d760bba41007625dff22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c0afba737f07083a4da10797cd9103f/" rel="bookmark">
			ELK日志分析系统，ELFK详解部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
概念简述
可以添加的其他组件
完整日志系统基本特征
原理
部署实例
环境准备
ELK Elasticsearch 集群部署（在Node1、Node2节点上操作）
部署 Elasticsearch 软件
安装 Elasticsearch-head 插件
ELK Logstash 部署（在 Apache 节点上操作）
ELK Kiabana 部署（在 Node1 节点上操作）
ELFK（Filebeat+ELK 部署）
环境准备
Node1节点配置
安装Filebeat
filebeat.yml配置
启动Filebeat
Logstash节点配置
新建Logstash 配置文件
启动logstash
浏览器测试
概念简述 ELK日志分析系统是一个开源的日志管理平台，它由三个主要组件组成，分别是Elasticsearch、Logstash和Kibana。这三个组件协同工作，提供了一个完整的解决方案，用于收集、存储、搜索、分析和可视化大规模的日志数据。以下是ELK日志分析系统的主要组件及其功能：
Elasticsearch：
基于Lucene的分布式存储检索引擎，用于存储各类日志。
通过RESTful Web接口进行通信，允许用户通过浏览器与Elasticsearch交互。
实时、分布式、可扩展的搜索引擎，支持全文和结构化搜索。通常用于索引和搜索大容量的日志数据，也适用于其他类型的文档。
Kibana：
与Elasticsearch一起部署，是Elasticsearch的数据可视化Dashboard。
提供图形化的web界面，用于浏览、汇总、分析和搜索Elasticsearch日志数据，方便用户快速理解和利用数据。
Logstash：
作为数据收集引擎，支持动态地从各种数据源收集数据。
对数据进行过滤、分析、丰富和格式统一等操作，然后将处理后的数据存储到用户指定的位置，通常发送给Elasticsearch。
使用Ruby语言编写，运行在Java虚拟机上，拥有强大的数据处理能力和插件功能。通常用于日志处理，其工作流程涉及输入（数据采集）、过滤（数据过滤）、输出（数据输出）的处理过程。
ELK的优势在于集成了这三个工具，形成一个完整的日志处理生态系统，使用户能够从数据采集、清洗、存储到可视化展示，完成对日志数据的全方位管理和利用。
工作流程:
Logstash负责采集、处理和转发日志数据。
Elasticsearch用于存储和索引处理后的数据，提供高效的检索和分析功能。
Kibana通过Web界面与Elasticsearch交互，提供用户友好的数据可视化和分析工具。
应用场景:
ELK日志分析系统广泛用于监控和分析应用程序日志、系统日志、安全事件等。
它可以帮助系统管理员、开发人员和运维团队追踪问题、进行故障排除、监测系统性能，并提供实时的可视化报告。
为什么使用ELK呢？ELK 是一个广泛使用的开源工具组合，由 ElasticSearch、Logstash 和 Kibana 组成，它们合作来实现日志管理、分析和可视化。
集中式管理：当日志分散在不同设备上时，传统的查看方法变得低效且繁琐。ELK 的 Logstash 组件可以帮助集中收集来自各服务器的日志，并将它们统一存储在 ElasticSearch 中，简化了日志管理的复杂性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c0afba737f07083a4da10797cd9103f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e4c98ba3a6cb87bda87544bbec80745/" rel="bookmark">
			Docker简述与基础部署详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
docker概述
docker的核心思想
docker三大组件
docker优势
容器和虚拟机之间的区别
容器在内核中支持的重要技术
命名空间（Namespaces）
控制组（Control Groups，cgroups）
写时复制技术（Copy-on-Write）
docker组成
docker基础命令
容器生命周期管理：
镜像管理：
网络与数据卷管理：
容器执行与交互：
Docker Compose 与 Swarm：
其他常用命令：
最常用的命令
docker运行命令的流程
部署实例
安装docker
docker镜像操作
docker容器操作
docker官网：https://www.docker.com docker中文库:https://www.docker.org.cn/
Docker是一种开源的容器化平台，用于轻松打包、交付和运行应用程序。Docker的主要优势在于它提供了一种轻量级、可移植、自包含的容器化技术，使得应用程序及其所有依赖项能够在任何环境中运行，而无需担心环境差异性和依赖关系问题。
docker概述 Docker是一个开源项目，于2013年初诞生，最初是dotCloud公司内部的一个业余项目。它基于Google公司推出的Go语言实现，并于后来加入了Linux基金会，遵从了Apache 2.0协议，项目代码在GitHub上进行维护。Docker自开源以来受到广泛的关注和讨论。
Docker的主要特点和功能包括：
轻量化虚拟化： Docker利用Linux内核的容器技术，实现了轻量级的虚拟化。容器可以隔离应用进程和资源，但与传统的虚拟机相比，它们更加轻便且启动更快。
跨平台性： Docker容器可以在任何支持Docker的平台上运行，无论是开发、测试还是生产环境，保证了应用的一致性。
快速部署： Docker容器可以在几秒钟内启动，相比传统虚拟机的分钟级别启动时间更加迅速，提高了应用的部署效率。
易于管理： Docker提供了简单而强大的命令行工具和API，使得容器的创建、部署、复制和移动变得非常容易。
版本控制： Docker支持镜像的版本控制，可以方便地管理应用的不同版本，简化了应用的升级和回滚过程。
总体而言，Docker的出现极大地简化了应用的开发、部署和管理过程，推动了容器化技术的发展。通过使用Docker，开发者可以更方便地构建、打包和交付应用，同时提高了系统的可移植性和可扩展性。
docker的核心思想 Docker的核心思想是实现"Build, Ship and Run Any App, Anywhere"，即通过对应用的封装、分发、部署、运行生命周期进行管理，达到应用组件“一次封装，到处运行”的目的。以下是Docker思想的关键要点：
封装（Packaging）： Docker利用容器技术，将应用及其依赖项打包成一个独立的容器。这个容器包含了应用的代码、运行时、系统工具、系统库等，形成了一个可移植的封闭环境。
分发（Distribution）： Docker容器可以轻松地在不同的环境中进行分发。这是因为Docker容器包含了所有应用所需的依赖项，而不受底层系统的影响。这使得开发、测试和生产环境之间的迁移变得更加简便。
部署（Deployment）： Docker容器可以在任何支持Docker的环境中部署，而不受操作系统和硬件的限制。这为应用的部署提供了更大的灵活性，可以在不同的云平台、物理机或虚拟机上运行。
运行（Runtime）： Docker容器提供了一个隔离的运行时环境，使得应用可以在相互隔离的容器中独立运行。这种隔离性质保证了容器之间的互不干扰，同时提供了更高的安全性。
一次封装，到处运行： Docker的目标是实现应用组件的一次封装，然后可以在任何地方运行，无论是开发者的本地机器、测试环境还是生产服务器。这种一致性简化了开发、测试和部署的过程。
总的来说，Docker的思想是通过容器技术实现应用的轻量化封装和隔离，使得应用能够方便地在不同环境中运行，从而提高开发、测试和部署的效率，并增强了应用的可移植性和可扩展性。
docker三大组件 Docker的三大组件是镜像（Image）、容器（Container）和仓库（Repository）。
镜像（Image）：
镜像是Docker应用的基础。它是一个只读的文件和文件夹组合，包含了容器运行时所需的所有基础文件和配置信息。镜像是容器的静态定义，可以看作是应用程序的打包和分发形式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e4c98ba3a6cb87bda87544bbec80745/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4e644773b107a0019e8fda71c52bed0/" rel="bookmark">
			系统性学习vue-组件及脚手架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		书接上文
Vue组件及脚手架 初始化脚手架说明步骤 分析脚手架结构render函数修改默认配置ref属性props配置mixin 混入/混合定义混合局部混合全局混合 插件scoped样式安装less-loader 浏览器的本地存储 webStoragelocalStroage 本地存储sessionStorage 会话存储 组件自定义事件绑定解绑组件绑定原生事件 全局事件总线 GlobalEventBus安装绑定事件 接收数据触发事件 传递数据 消息订阅与发布 pubsub$nextTicktransition动画效果过渡效果transition-group集成第三方动画 初始化脚手架 说明 Vue脚手架是Vue官方提供的标准化开发工具(开发平台)
CLI: command line interface (命令行接口工具) 俗称脚手架
步骤 备注:
如果下载缓慢可以配置npm淘宝镜像: npm config set registry https://registry.npm.taobao.orgVue脚手架隐藏了所有webpack相关配置,弱项查看具体的webpack配置,请执行vue inspect &gt; output.js (仅第一次执行)全局安装@vue/cli, 安装好就可以使用vue命令了
npm install -g @vue/cli
切换到要创建项目的目录(可用cd命令,也可以直接文件下shift+右键选择’在此处打开窗口’),然后使用命令创建项目
vue create xxxxx(项目名称)
会出现一个选项
目前先选择vue2
又来一个问题,先选NPM吧
启动项目(运行的是官方给写好的HelloWorld代码)
来到项目目录下,执行命令
npm run serve
至此准备完成
如果要停止服务的话,命令行按Ctrl+c(两遍)
分析脚手架结构 整个脚手架内容如下,
.gitignore git忽略文件配置babel.config.js babel的配置文件package-lock.json&amp;package.json 符合npm规范的工程都会有这两个文件
package.json 应用包配置文件,包含名称,版本,依赖等
package-lock.json 包版本控制文件README.md 应用描述文件src/main.js 当执行npm run serve命令后直接运行的就是这个文件,是整个项目的入口文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4e644773b107a0019e8fda71c52bed0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e993deb571629a74bfdca92131aebd1e/" rel="bookmark">
			风电运维是海洋勘察行业下一个蓝海？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据 DNV 预测，到 2050 年将会有 33%的发电量来自风能：其中 20%来自陆上风电，11%来自固定式基础海上风电，2%来自浮式基础海上风电。中国连续第五年成为全球最大的海上风电国家，2022年新增并网装机容量约5.1GW，较上年下降了逾70%，但仍然占全球新增装机总量的一半以上。截至2022年底，我国海上风电累计装机已超3000万千瓦，连续两年位居全球首位，占比达一半左右。
海上风电发展的大趋势主要是“大型化”和“深水化”。“大型化”的目的是降低海上风电的“度电”成本，增强电价的市场竞争力。在离岸 50km 以上、水深大于 50m的深远海区域，海上风速更大、更稳定，风能产量更高，而且可以大大避免近岸环境噪声和视觉污染，以及航运、渔业等用海冲突。海上风机的体型越来越大，发电机功率也从过去的 0.5 MW发展到今天的 5MW、7MW、8MW，未来甚至可能达到 20MW 。
通常情况下，风机的使用寿命长达 20 年以上， 而整机供应商提供的质保期通常在 5 年左右。5年后，风机建设单位需要自建风机运维团队或委托第三方团队。由于我国海上风机大部分是最近几年新建的，因此，海上风电运维市场蓝海特征显现。与陆上风电相比，海上风电运维难度系数、成本投入等都较高，据行业专业人士介绍，一次海上风电机组的齿轮箱更换，其成本应该在400-500万元。
下图展示了海上风电的结构简图，从图里可以看出海上风电的两个主要风险类型，一个是海缆的运维风险，一个是海上构筑物的风险。
以海上风电风车自身为例，其风险监测从上到下分别为叶片、塔架、下部结构和基础。海洋勘察主要涉及水面以下的下部和基础监测。
下图是导管架安装和受台风影响而倾斜的照片。
海上风机基础大部分是固定式的，大直径单桩基础在0m~40m水深应用范围最广，导管架基础主要用于40m~100m水深。
基础的主要风险就是冲刷，基础冲刷将减小桩基础的入土深度，降低桩基础的承载力；基础冲刷使桩的悬臂长度增加，从而使风机水平变形加大，同时增加桩基础的倾覆弯矩；基础冲刷使风机机组结构的自振频率降低，使基础疲劳应力幅值增大、应力循环次数增加，影响机组的疲劳寿命。
海缆的主要风险是海底冲刷和抛锚、拖网等人为破坏。
基础和海缆探测主要设备有多波束、侧扫声呐、三维声纳、水下机器人、管线仪、三维剖面仪、磁力仪、电磁感应管线仪、合成孔径声呐。
多波束和侧扫声纳：
管线仪、三维剖面仪、磁力仪和海缆仪：
三维声纳、水下机器人、合成孔径声纳：
参考文献
风电运维的勘察技术探讨
https://www.sohu.com/a/679192743_121124362
海上风电单桩基础局部冲刷与防护研究_徐思远
http://paper.people.com.cn/zgnyb/html/2022-10/17/content_25944775.htm
https://wind.in-en.com/html/wind-2435718.shtml
https://wind.in-en.com/html/wind-2404648.shtml
2023海上风电回顾与展望
海上风机导管架基础循环受荷性状与分析方法_周文杰
https://www.gov.cn/yaowen/liebiao/202308/content_6897588.htm
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76fd1f13e37c3ea5c0ba224eb88fc268/" rel="bookmark">
			springboot读取jar包资源文件文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先修改pom.xml文件.使打包后的jar包含你的资源文件
在pom.xml文件下的build选项中的src/main/resources的目录下 添加配置
&lt;span style="color:#000000"&gt;&lt;span style="color:#61687c"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;code class="language-xml"&gt;&lt;&lt;span style="color:#63a35c"&gt;build&lt;/span&gt;&gt; &lt;&lt;span style="color:#63a35c"&gt;plugins&lt;/span&gt;&gt; &lt;&lt;span style="color:#63a35c"&gt;plugin&lt;/span&gt;&gt; &lt;&lt;span style="color:#63a35c"&gt;groupId&lt;/span&gt;&gt;org.springframework.boot&lt;/&lt;span style="color:#63a35c"&gt;groupId&lt;/span&gt;&gt; &lt;&lt;span style="color:#63a35c"&gt;artifactId&lt;/span&gt;&gt;spring-boot-maven-plugin&lt;/&lt;span style="color:#63a35c"&gt;artifactId&lt;/span&gt;&gt; &lt;/&lt;span style="color:#63a35c"&gt;plugin&lt;/span&gt;&gt; &lt;/&lt;span style="color:#63a35c"&gt;plugins&lt;/span&gt;&gt; &lt;&lt;span style="color:#63a35c"&gt;resources&lt;/span&gt;&gt; &lt;&lt;span style="color:#63a35c"&gt;resource&lt;/span&gt;&gt; &lt;&lt;span style="color:#63a35c"&gt;directory&lt;/span&gt;&gt;src/main/java&lt;/&lt;span style="color:#63a35c"&gt;directory&lt;/span&gt;&gt; &lt;&lt;span style="color:#63a35c"&gt;includes&lt;/span&gt;&gt; &lt;&lt;span style="color:#63a35c"&gt;include&lt;/span&gt;&gt;**/*.properties&lt;/&lt;span style="color:#63a35c"&gt;include&lt;/span&gt;&gt; &lt;&lt;span style="color:#63a35c"&gt;include&lt;/span&gt;&gt;**/*.xml&lt;/&lt;span style="color:#63a35c"&gt;include&lt;/span&gt;&gt; &lt;/&lt;span style="color:#63a35c"&gt;includes&lt;/span&gt;&gt; &lt;&lt;span style="color:#63a35c"&gt;filtering&lt;/span&gt;&gt;false&lt;/&lt;span style="color:#63a35c"&gt;filtering&lt;/span&gt;&gt; &lt;/&lt;span style="color:#63a35c"&gt;resource&lt;/span&gt;&gt; &lt;&lt;span style="color:#63a35c"&gt;resource&lt;/span&gt;&gt; &lt;&lt;span style="color:#63a35c"&gt;directory&lt;/span&gt;&gt;src/main/resources&lt;/&lt;span style="color:#63a35c"&gt;directory&lt;/span&gt;&gt; &lt;&lt;span style="color:#63a35c"&gt;includes&lt;/span&gt;&gt; &lt;&lt;span style="color:#63a35c"&gt;include&lt;/span&gt;&gt;**/*.properties&lt;/&lt;span style="color:#63a35c"&gt;include&lt;/span&gt;&gt; &lt;&lt;span style="color:#63a35c"&gt;include&lt;/span&gt;&gt;**/*.xml&lt;/&lt;span style="color:#63a35c"&gt;include&lt;/span&gt;&gt; &lt;&lt;span style="color:#63a35c"&gt;include&lt;/span&gt;&gt;**/*.css&lt;/&lt;span style="color:#63a35c"&gt;include&lt;/span&gt;&gt; &lt;&lt;span style="color:#63a35c"&gt;include&lt;/span&gt;&gt;**/*.js&lt;/&lt;span style="color:#63a35c"&gt;include&lt;/span&gt;&gt; &lt;&lt;span style="color:#63a35c"&gt;include&lt;/span&gt;&gt;**/*.html&lt;/&lt;span style="color:#63a35c"&gt;include&lt;/span&gt;&gt;&lt;/code&gt;&lt;code class="language-xml"&gt;&lt;span style="background-color:#2b2b2b"&gt;&lt;span style="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76fd1f13e37c3ea5c0ba224eb88fc268/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1d2b670fca5e5e2f3a75117f13064ba/" rel="bookmark">
			SpringBoot启动时做了什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当Spring Boot应用启动时，会执行以下主要任务：
1. 加载应用配置：Spring Boot会加载应用的配置文件，包括`application.properties`或`application.yml`等，用于配置应用的各种属性。
2. 自动装配：Spring Boot利用自动装配功能，根据项目的依赖和配置，自动配置应用所需的各种Bean，并建立它们之间的依赖关系。
3. 启动内嵌的服务器：Spring Boot会启动一个内嵌的Web服务器（如Tomcat、Jetty等），用于处理HTTP请求。
4. 扫描组件：Spring Boot会扫描项目中的所有组件（如@Controller、@Service、@Repository等注解标记的组件），并将它们纳入Spring上下文中管理。
5. 启动应用：最终，Spring Boot会启动应用，并开始监听入站的HTTP请求，根据路由规则将请求分发给对应的Controller进行处理。
总之，Spring Boot在启动时会自动配置、加载配置文件、启动内嵌服务器，并扫描和加载项目中的组件，使得开发者能够快速、便捷地启动和部署应用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0341ed15f67f4048743f8bbeb43b17e1/" rel="bookmark">
			SpringBoot核心注解是哪个？由哪些注解组成？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Boot的核心注解是`@SpringBootApplication`。
`@SpringBootApplication`注解是一个组合注解，包含了以下三个核心注解：
- `@SpringBootConfiguration`：表示该类是Spring Boot应用的配置类。
- `@EnableAutoConfiguration`：启用自动配置，根据项目的依赖自动配置Spring相关的bean。
- `@ComponentScan`：启用组件扫描，自动扫描并加载被`@Component`注解标记的组件。
通过使用`@SpringBootApplication`注解，可以快速启动一个Spring Boot应用，并自动配置相关的各种组件和功能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ca1bf3fbf4d3c7e8d986b8c8f4801b6/" rel="bookmark">
			thinkphp学习08-数据库的链式查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面课程中我们通过指向符号“-&gt;”多次连续调用方法称为：链式查询，当 Db::name(‘user’)时，返回查询对象(Query)，即可连缀数据库对应的方法，而每次执行一个数据库查询方法时，比如 where()，还将返回查询对象(Query)，只要还是数据库对象，那么就可以一直使用指向符号进行链式查询，再利用 find()、select()等方法返回数组(Array)或数据集对象(Colletion)，而 find()和 select()是结果查询方法（放在最后），并不是链式查询方法
public function index() { $user = Db::name('user')-&gt;where('id', 27)-&gt;order('id', 'desc')-&gt;find(); dump($user); } 有多少种类似 where()的链式操作方法呢，官方文档
如果多次使用数据库查询，那么每次静态创建都会生成一个实例，造成浪费， 我们可以把对象实例保存下来，再进行反复调用即可
public function index() { $userQuery = Db::name('user'); $dataFind = $userQuery-&gt;where('id', 5)-&gt;find(); dump($dataFind); $dataSelect = $userQuery-&gt;select(); dump($dataSelect); } 当同一个对象实例第二次查询后，会保留第一次查询的值
public function index() { $userQuery = Db::name('user'); $data1 = $userQuery-&gt;order('id', 'desc')-&gt;select(); echo Db::getLastSql(); $data2 = $userQuery-&gt;select(); echo "&lt;br&gt;"; echo Db::getLastSql();; } 使用 removeOption()方法，可以清理掉上一次查询保留的值
public function index() { $userQuery = Db::name('user'); $data1 = $userQuery-&gt;order('id', 'desc')-&gt;select(); echo Db::getLastSql(); $userQuery-&gt;removeOption('order')-&gt;select(); $data2 = $userQuery-&gt;select(); echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ca1bf3fbf4d3c7e8d986b8c8f4801b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4d12340e95a75eda02b88ddbf495756/" rel="bookmark">
			​LeetCode解法汇总2707. 字符串中的额外字符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录链接： 力扣编程题-解法汇总_分享+记录-CSDN博客 GitHub同步刷题项目： https://github.com/September26/java-algorithms
原题链接：. - 力扣（LeetCode） 描述： 给你一个下标从 0 开始的字符串 s 和一个单词字典 dictionary 。你需要将 s 分割成若干个 互不重叠 的子字符串，每个子字符串都在 dictionary 中出现过。s 中可能会有一些 额外的字符 不在任何子字符串中。
请你采取最优策略分割 s ，使剩下的字符 最少 。
示例 1：
输入：s = "leetscode", dictionary = ["leet","code","leetcode"] 输出：1 解释：将 s 分成两个子字符串：下标从 0 到 3 的 "leet" 和下标从 5 到 8 的 "code" 。只有 1 个字符没有使用（下标为 4），所以我们返回 1 。 示例 2：
输入：s = "sayhelloworld", dictionary = ["hello","world"] 输出：3 解释：将 s 分成两个子字符串：下标从 3 到 7 的 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4d12340e95a75eda02b88ddbf495756/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2638836d60b0279cc384ed425ac837c/" rel="bookmark">
			【时事篇-02】20240110 365天存钱法（sum法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景需求 朋友圈里，一位保险推销员发布“存钱法广告”，我想用Python验算结果正确性 使用的是最近宫格数独里用到的”sum法” 代码展示 ''' 项目:存钱游戏计算 sum() 作者:阿夏 时间:2024年1月10日19:03''' import random '''1、钻石版：从1元存到365元，一年后存钱66795元！''' l1=[] for x1 in range(1,366): l1.append(x1) m1=sum(l1) print('一年后',len(l1),'天，存钱',m1,'元') '''2、铂金版：把365元折半，从1元存到182元，然后重新从1元开始。一年后存钱33489元！''' l2=[] # 第一次182天 for x2 in range(1,183): l2.append(x2) m2=sum(l2) # print(len(l2)) # 第二次183天 for x2 in range(1,184): l2.append(x2) m2=sum(l2) # print(len(l2)) print('一年后',len(l2),'天,存钱',m2,'元') '''3、黄金版：把182元折半，从1元存到91元，然后重新从1元开始。一年后存钱16836元！''' l3=[] # 91天*3=273 for i in range(3): for x3 in range(1,92): l3.append(x3) m3=sum(l3) # 92天*1=92 for x3 in range(1,93): l3.append(x3) m3=sum(l3) print('一年后',len(l3),'天,存钱',m3,'元') '''4、白银版：从1元存到30元，然后重新从1元开始。一年后存钱5595元！''' l4=[] #30天*12=360 for i in range(12): for x4 in range(1,31): l4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2638836d60b0279cc384ed425ac837c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bba7cdecb640148a156d084365b95d1f/" rel="bookmark">
			Linux中批量创建用户的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Linux中，可以使用脚本来批量创建用户。以下是一个具体的步骤：
1）在 /home/user1/ 目录下创建目录：
sudo mkdir /home/user1 sudo chown root:root /home/user1 执行命令 sudo chown root:root /home/user1 将 /home/user1 目录的所有者和所属组都修改为 root。这意味着只有 root 用户（超级用户）才能对该目录进行修改和访问，其他用户将无法更改此目录。 2）创建一个包含用户信息的文本文件users.txt 来存储用户信息，使用 vi 命令编辑 users.txt 文件:
sudo vi /home/user1/users.txt 文件内容：每行表示一个用户，在 users.txt 文件中，每行输入一个用户的信息，格式如下：
用户名:密码:用户ID:附加组:用户主目录:登录shell 注意：密码字段可以为空，后续可以通过其他方式设置密码。 例如：
user1:password1:1001:group1:/home/user1:/bin/bash user2:password2:1002:group2:/home/user2:/bin/bash 3）确保附加组已经存在。
如果在用户信息中指定了附加组（如 group1 和 group2），则需要先创建这些组。可以使用以下命令创建附加组：
sudo groupadd group1 sudo groupadd group2 附加组（或称为辅助组）的信息存储在 /etc/group 文件中。该文件记录了系统中所有组的信息，包括组名、组ID和组成员。
可以使用下面的命令查看 /etc/group 文件：
cat /etc/group 通常情况下，创建附加组时会自动将其添加到 /etc/group 文件中。 4）编写一个脚本（例如 create_users.sh），用于读取 users.txt 文件并根据其中的用户信息创建用户。
打开终端并使用任意文本编辑器（如nano或vim）创建一个脚本文件，示例脚本：
#!/bin/bash while IFS=: read -r username password uid groups homedir shell; do echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bba7cdecb640148a156d084365b95d1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03aaeac79b5d1e30eee86db2c6a0ff7e/" rel="bookmark">
			Discourse 新注册用户数据是怎么表达的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为 Discourse 网站的管理员，对于新注册的用户，我们可能会比较关心新注册用户的数量。
在 Discourse 的控制台中，系统会告诉我们每天新注册用户的数量。
具体是采用图形的方式来表达出来的。
上面的图只表示了用户注册的数量，只要用户使用邮箱注册了，上面的数量就会显示出来。
很多时候因为用户虽然注册了，但是没有激活邮箱，因此是没有办法在系统中进行留言和评论的。
这个时候只能到后台去查看下没有被激活的用户。
Discourse 新注册用户数据是怎么表达的 - Discourse - iSharkFly作为 Discourse 网站的管理员，对于新注册的用户，我们可能会比较关心新注册用户的数量。 在 Discourse 的控制台中，系统会告诉我们每天新注册用户的数量。 具体是采用图形的方式来表达出来的。 上面的图只表示了用户注册的数量，只要用户使用邮箱注册了，上面的数量就会显示出来。 很多时候因为用户虽然注册了，但是没有激活邮箱，因此是没有办法在系统中进行留言和评论的。 这个时候只能到后台去查看下没有被激活的用户。https://www.isharkfly.com/t/discourse/15259
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/793a9660a5d811b1b333ca2317d95d91/" rel="bookmark">
			Discourse 访问统计数据的不一致
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Discourse 如果使用网站跟踪程序，例如 Google Analytics 得到的网站访问数据和真实的网站访问数据是不一致的。
通常 Google Analytics 提供的数据更少，或者说是少很多。
这是因为 Discourse 的数据调用使用的是 API，在你的页面载入后，如果继续访问网站，那么网站使用的是 API 调用程序。
这个调用在 Google Analytics 中没有办法被跟踪到。
所以就算你开了 2 个页面，Google Analytics 还是只能记录一次。
相对准确的记录就是 Discourse 自带的内部页面记录，这个因为能够记录每次 API 和后台的调用情况，更能够准确反映网站的使用情况。
我们说的就是在后台上使用的这个数据。
有没有解决办法 上午考古了不少内容，貌似这个问题从 Discourse 的最早期版本就已经存在了。
有人说就这个问题已经存在了超过 4 年多了都没有办法解决。
这个主要还是和 Discourse 的数据存储和调用机制有关，很难通过跟踪页面的实际载入情况来获得网站的真实页面载入数量。
可以使用其他的分析工具，例如 DNS 上面的用户 DNS 解析数量，独立用户 IP 访问数量来大致知道网站访问用户的数量。
至于具体的 API 和数据调用情况，也只能依赖内部的报表了。
Discourse 访问统计数据的不一致 - Discourse - iSharkFlyDiscourse 如果使用网站跟踪程序，例如 Google Analytics 得到的网站访问数据和真实的网站访问数据是不一致的。 通常 Google Analytics 提供的数据更少，或者说是少很多。 这是因为 Discourse 的数据调用使用的是 API，在你的页面载入后，如果继续访问网站，那么网站使用的是 API 调用程序。 这个调用在 Google Analytics 中没有办法被跟踪到。 所以就算你开了 2 个页…https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/793a9660a5d811b1b333ca2317d95d91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e19663e43b628b39432f2d6961e96b4/" rel="bookmark">
			【MongoDB 从入门到入神】全网最全通透篇之 MongoDB 概述及详细使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过本篇文章，您将了解到MongoDB的以下内容：
MongoDB概述MongoDB业务场景MySQL与MongoDB对比MongoDB的基本使用及文档的增删改查 文章目录 一 前言二 MongoDB是什么三 MongoDB存储的数据结构四 什么情况下使用MongoDB？五 常见的MongoDB应用场景六 MongoDB与Mysql的对比七 MongoDB使用7.1 MongoDB的安装 （Mac 平台）7.2 进入MongoDB7.3 数据库操作7.4 集合操作7.4.1 显式创建7.4.2 隐式创建7.4.3 删除集合 7.5 文档的增删改查（CRUD）7.5.1 单个文档插入7.5.2 多个文档插入7.5.3 文档查询7.5.4 投影查询7.5.5 文档的更新7.5.6 删除文档 一 前言 由于传统的关系型数据库（例如，Mysql），在数据操作的“三高”需求以及应对web2.0的网站需求时，显得力不从心，其中三高需求指的是
high performance：对数据库高并发读写的需求，例如双十一淘宝，同时在淘宝下单，mysql很难应付。Huge Storage，对海量数据的搞笑存储和访问的需求High Scalability &amp;&amp; High Availability：对数据库的高可扩展性和高可用性的需求。（在刚开始的时候不需要固定格式） 二 MongoDB是什么 MongoDB是一个开源、高性能、无模式的文档型数据库。是 NoSQL数据库产品中的一种，是最像关系数据库（Mysql）的非关系型数据库。MongoDB最初的设计是用来简化开发和方便扩展的。
注意以下内容：
无模式指的是没有具体的列“最像关系数据库（Mysql）的非关系型数据库”表示：MongoDB 命令的使用和 Mysql 类似。 三 MongoDB存储的数据结构 MongoDB 支持的数据结构非常松散，MongoDB 将数据存储为对应的 BSON 格式文件，这个文件是二进制的，可以通过 MongoDB 提供的命令行工具进行读取和写入。BSON是Binary JSON的缩写，是JSON的一种扩展，能够更快地将数据存储和读取到MongoDB数据库中。
MongoDB中的记录是一个文档，它是由一个字段和值对组成的数据结构，MongoDB文档类似于JSON对象，即一个文档认为就是一个对象。字段的数据类型是字符型，它的值除了使用基本的一些类型外，还可以包括其他文档，普通数据和文档数组。
四 什么情况下使用MongoDB？ 数据量大写入操作频繁（读写都很频繁）价值较低的数据，对事务性要求不高
对于以上情况，更适合使用 MongoDB 来实现数据的存储。 在架构选型上，除了上述的三个特点外呢，如果你还犹豫是否要选择它，则可以考虑以下问题：
应用不需要事务以及复杂的 join 支持对于新应用，需求会变，数据模型无法确定想快速迭代开发的读写速度更高需求，需要很大存储空间等 五 常见的MongoDB应用场景 社交场景、游戏场景：使用MongoDB存储用户信息，以及用户发表的朋友圈信息，通过地理位置索引实现附近的人、地点等功能；存储游戏用户、信息、积分装备等方便查询、高效存储和访问。物流场景：使用MongoDB存储订单信息，订单状态在运送过程中会不断更新，以MongoDB内嵌数组的形式来存储，一次查询就可以将订单所有的变更读取出来。物流网场景：使用MongoDB存储所有接入的智能设备信息，以及设备汇报的日志信息，并对这些信息进行多维度的分析视频直播：使用MongoDB存储用户信息，点赞互动信息等。 六 MongoDB与Mysql的对比 MySQL 关系型数据库包含：数据库、表、行MongoDB 数据库包含：数据库、Collection、Document
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e19663e43b628b39432f2d6961e96b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97c0d62dcbae0ae0e5670ad94cbc0184/" rel="bookmark">
			shell mapfile命令（readarray命令）介绍（读取行到数组变量）（进程替换&#43;重定向＜ ＜()、()＞ ＞）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 shell mapfile命令（readarray命令）介绍`mapfile --help`英文中文 简单使用教程创建一个测试文件使用mapfile命令读取文件打印数组内容 各选项详解1. -d delim：使用DELIM来终止行，而不是换行原理示例 2. -n count：最多复制COUNT行。如果COUNT为0，所有行都被复制3. -O origin：从索引ORIGIN开始分配给ARRAY。默认索引是0解释示例 4. -s count：丢弃首先读取的COUNT行5. -t：从每一行读取中删除尾随的DELIM（默认为换行）6. -u fd：从文件描述符FD读取行，而不是标准输入7. -C callback：每读取QUANTUM行就评估一次CALLBACK解释示例 8. -c quantum：指定每次调用CALLBACK之间读取的行数 其他问题在管道操作中使用mapfile命令时，由于shell的子进程问题，mapfile无法改变父shell环境中的数组 shell mapfile命令（readarray命令）介绍 mapfile 或 readarray 是 Bash shell 中的一个内置命令，主要用于从标准输入或文件中读取行到数组变量中。
mapfile 和 readarray 是完全相同的命令。在 Bash shell 中，这两个命令是等效的，可以互换使用。
mapfile --help 英文 root@ky:/userdata/tmp# mapfile --help mapfile: mapfile [-d delim] [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c quantum] [array] Read lines from the standard input into an indexed array variable.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97c0d62dcbae0ae0e5670ad94cbc0184/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cff15aa7a4a9a6454d9971849561ab8/" rel="bookmark">
			Java的helloworld、IDEA一些快捷键、导入模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Java的helloworld
IDEA管理Java程序的结构
1.project（项目、工程）
2.moudule（模块）
3.package（包）
4.class（类）
上级包含多个下级，开发程序也是创建工程再创建模块再创建包
输入main回车：
再输入sout回车：
输入完就是这样：
右键run就可以执行了：
那么如何查看是否真的帮我们把代码编译成class文件呢？
可以去out目录查找：
二、IDEA常用快捷键
1.main/psvm、sout 快速键入相关代码
2.Ctrl+D：复制当前行数据到下一行（直接在后面按就可以，不用选中）
3.Ctrl+X：删除所在行
4.Ctrl+ALT+L：格式化代码
5.Ctrl+/，Ctrl+SHIFT+/：注释，前者是//，后者是/**/
三、导入模块
输入路径以后，要导入黑点这边的模块，再点ok
但这种导入是关联导入，如果将来路径改变，那么就不太好，所以如果我希望我们的模块导入我们的工程来，所以可以直接把模块复制到工程的路径下，然后再拷贝一下工程的路径，再导入一下，选择黑点，就可以导入了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5383f332d76cfa7ec8b3f19df7705292/" rel="bookmark">
			【机器学习】半监督学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题假设
要利用无标签样本进行训练，必须对样本的分布进行假设？
二、启发式算法
自训练和协同训练是两种常用的半监督学习的方法，它们的主要区别在于使用的模型的数量和类型。
自训练：自训练是一种使用单个模型的半监督学习的方法，它的过程是先用有标签的数据训练一个初始的模型，然后用这个模型对无标签的数据进行预测，选择一些预测结果最有信心的数据作为新的有标签的数据，加入到原来的有标签的数据集中，再用这个扩充的数据集训练一个新的模型，重复这个过程直到满足某个终止条件。自训练的优点是简单和高效，但是缺点是可能会放大模型的初始偏差，导致错误的标签传播。
协同训练：协同训练是一种使用多个模型的半监督学习的方法，它的过程是先用有标签的数据训练两个或多个不同的模型，然后用这些模型分别对无标签的数据进行预测，选择一些预测结果最有信心且不一致的数据作为新的有标签的数据，分别加入到对应的有标签的数据集中，再用这些扩充的数据集训练新的模型，重复这个过程直到满足某个终止条件。协同训练的优点是能够利用模型之间的多样性和互补性，减少错误的标签传播，但是缺点是需要设计合适的模型和选择合适的数据，否则可能会降低协同训练的效果。
三、生成模型
使用高斯混合模型的半监督学习生成模型的原理
这是一个半监督学习的示例，使用高斯混合模型（GMM）来对数据进行聚类和分类
# 导入numpy库，用于进行数值计算和矩阵操作 import numpy as np # 导入sklearn库中的make_blobs函数，用于生成模拟数据 from sklearn.datasets import make_blobs # 导入sklearn库中的GaussianMixture类，用于创建和训练GMM模型 from sklearn.mixture import GaussianMixture # 生成数据，其中有三个类别，每个类别有两个特征 # X是一个1000行2列的矩阵，表示1000个数据点的特征值 # y是一个长度为1000的向量，表示每个数据点的真实类别 X, y = make_blobs(n_samples=1000, n_features=2, centers=3, random_state=0) # 随机选择一部分数据作为标记数据，其余的作为未标记数据 # n_labeled是标记数据的数量，这里设为100 n_labeled = 100 # indices是一个长度为1000的向量，表示对数据点的随机排列 indices = np.random.permutation(X.shape[0]) # X_labeled是一个100行2列的矩阵，表示标记数据的特征值 X_labeled = X[indices[:n_labeled]] # y_labeled是一个长度为100的向量，表示标记数据的真实类别 y_labeled = y[indices[:n_labeled]] # X_unlabeled是一个900行2列的矩阵，表示未标记数据的特征值 X_unlabeled = X[indices[n_labeled:]] # 用标记数据来初始化GMM的参数，假设有三个高斯分布 # gmm是一个GaussianMixture对象，表示GMM模型 gmm = GaussianMixture(n_components=3, random_state=0) # gmm.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5383f332d76cfa7ec8b3f19df7705292/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e17e6375683e32e505c857c90cac506/" rel="bookmark">
			【设计模式之美】重构二：重构提高代码可测试性、mock替换外部服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、案例分析1. 案例说明2. 测试用例11. 引入mock 与代码重构2. 解决分布式锁的问题 3. 测试用例3 二. 其他常见的 Anti-Patterns1. 未决行为2. 全局变量3. 静态方法4. 复杂继承5. 高耦合代码 主要讨论几个问题：
什么是代码的可测试性？
如何写出可测试的代码？
有哪些常见的不好测试的代码？
一、案例分析 1. 案例说明 看一个例子：
电商系统的交易类，用来记录每笔订单交易的情况。execute() 函数负责执行转账操作，将钱从买家的钱包转到卖家的钱包中。真正的转账操作是通过调用 WalletRpcService RPC 服务来完成的。代码中还涉及一个分布式锁 DistributedLock 单例类，用来避免 Transaction 并发执行，导致用户的钱被重复转出。 public class Transaction { private String id; private Long buyerId; private Long sellerId; private Long productId; private String orderId; private Long createTimestamp; private Double amount; private STATUS status; private String walletTransactionId; // ...get() methods... public Transaction(String preAssignedId, Long buyerId, Long sellerId, Long productId, String orderId) { if (preAssignedId !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e17e6375683e32e505c857c90cac506/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/484fe9b5a7beadc56ffd3c2b5f41415c/" rel="bookmark">
			[JavaScript] 第七章 对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌹作者主页：青花锁 🌹简介：Java领域优质创作者🏆、Java微服务架构公号作者😄
🌹简历模板、学习资料、面试题库、技术互助
🌹文末获取联系方式 📝
系列专栏目录 [Java项目实战] 介绍Java组件安装、使用；手写框架等
[Aws服务器实战] Aws Linux服务器上操作nginx、git、JDK、Vue等
[Java微服务实战] Java 微服务实战，Spring Cloud Netflix套件、Spring Cloud Alibaba套件、Seata、gateway、shadingjdbc等实战操作 [Java基础篇] Java基础闲聊，已出HashMap、String、StringBuffer等源码分析，JVM分析，持续更新中 [Springboot篇] 从创建Springboot项目，到加载数据库、静态资源、输出RestFul接口、跨越问题解决到统一返回、全局异常处理、Swagger文档 [Spring MVC篇] 从创建Spring MVC项目，到加载数据库、静态资源、输出RestFul接口、跨越问题解决到统一返回 [华为云服务器实战] 华为云Linux服务器上操作nginx、git、JDK、Vue等，以及使用宝塔运维操作添加Html网页、部署Springboot项目/Vue项目等 [Java爬虫] 通过Java+Selenium+GoogleWebDriver 模拟真人网页操作爬取花瓣网图片、bing搜索图片等 [Vue实战] 讲解Vue3的安装、环境配置，基本语法、循环语句、生命周期、路由设置、组件、axios交互、Element-ui的使用等 [Spring] 讲解Spring(Bean)概念、IOC、AOP、集成jdbcTemplate/redis/事务等 前言 今天给大家带来JavaScript的对象知识讲解，包括对象的创建和使用、Number对象、String对象、Dom对象、Element对象、数组兑现个、Math对象等。
1、对象的创建和使用 对象看作是一个属性的无序集合，每个属性都有一个名称和值（键/值对）
1.1、创建对象 使用花括号{ }来创建对象，{ }中用来定义对象中的属性。属性是一个个键:值对的组合，其中键（属性名称）始终是字符串类型的，而值（属性值）则可以是任意类型。
var news={ title:"深圳下暴雨", content:"暴雨，堵车", newsType:1, displayTitle: function(){ document.write(this.title); } } 1.2、访问对象属性 console.log(news.content); console.log(news["content"]); 要访问或获取属性的值，您可以使用对象名.属性名或者对象名[“属性名”]的形式
1.3、设置修改对象属性 使用对象名.属性名或者对象名[“属性名”]的形式除了可以获取对象的属性值外，也可以用来设置或修改对象的属性值
news.title = "放晴了"; console.log(news.title); 1.4、删除对象属性 delete 语句来删除对象中的属性 delete news.title; console.log('******' + news.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/484fe9b5a7beadc56ffd3c2b5f41415c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f9cf85885dcb5cb9bde3ac23683f494/" rel="bookmark">
			揭秘大厂Linux面试通关秘诀：锁定这5大核心问题，offer不请自来！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、CPU负载和CPU利用率的区别是什么2、如果CPU负载很高，利用率很低怎么办3、如果负载很低，利用率很高呢？4、那如果CPU使用率达到100%呢?怎么排查5、常见的Linux命令常用权限命令 1、CPU负载和CPU利用率的区别是什么 首先，我们可以通过 uptime ，w 或者 top 命令来看到 cpu 的平均负载
load average ：负载的3个数字，比如上图的 0.09 、0.05、0.01 分别代表系统在过去的1分钟 、5分钟、15分钟内的系统平均负载，他代表的是当前系统正在运行和处于等待进行的进程数之和，也指的是处于可运行状态和不可中断状态的平均进程数。
​ 如果是单核Cpu的话，负载达到1就代表 CPU 已经达到了满负荷的状态，超过1后，后面的进行就要排队等待处理了，如果是多核多CPU的话，假设现在的服务器是2个CPU 每个 CPU 有2个线程，那么总负载不超过4都没有问题。
查看 CPU 情况
[root@Xiang ~]# cat /proc/cpuinfo | grep "model name" model name	: AMD EPYC 7K62 48-Core Processor 查看 CPU 核数
[root@Xiang ~]# cat /proc/cpuinfo | grep "cpu cores" cpu cores	: 1 ​ CPU 利用率：和负载不同，CPU 利用率指的是当前正在运行的进程实时用 CPU 的百分比，他是对一段时间内 CPU 使用状态的统计
我举个 栗子
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f9cf85885dcb5cb9bde3ac23683f494/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee99cd929670987ef492874ebb3a5d34/" rel="bookmark">
			基于JavaWeb&#43;BS架构&#43;SpringBoot&#43;Vue&#43;Hadoop短视频流量数据分析与可视化系统的设计和实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于JavaWeb+BS架构+SpringBoot+Vue+Hadoop短视频流量数据分析与可视化系统的设计和实现 文末获取源码Lun文目录前言主要技术系统设计功能截图订阅经典源码专栏Java项目精品实战案例《500套》 源码获取 文末获取源码 Lun文目录 目　录
目　录 I
1绪 论 1
1.1开发背景 1
1.2开发目的与意义 1
1.2.1开发目的 1
1.2.2开发意义 2
1.3本文研究内容 2
2开发技术 3
2.1 Java介绍 3
2.2 Hadoop介绍 3
2.3 Scrapy介绍 4
2.4 MySql简介 4
2.5 SPRINGBOOT框架 4
2.6 B/S架构 5
2.7 Tomcat简介 5
3系统分析 7
3.1系统可行性分析 7
3.1.1技术可行性分析 7
3.1.2经济可行性分析 7
3.1.3法律可行性分析 7
3.2系统性能分析 7
3.3功能需求分析 8
3.3.1管理员需求分析 8
3.3.2用户需求分析 8
3.4系统流程分析 9
4系统设计 10
4.1功能模块设计 10
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee99cd929670987ef492874ebb3a5d34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41334978e96620df0fdc6f95ec706602/" rel="bookmark">
			【源码分析】一个flink job的sql到底是如何执行的（一）：flink sql底层是如何调用connector实现物理执行计划的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一. 一条flink sql二. 源码流程图示1. flink connector的实现逻辑2. flink sql的转换逻辑 三、flink sql 调用connector源码分析1. tEnv.executeSql(stmt)1.1. 概述1.2. convertValidatedSqlNode1.2.1. create语句1.2.2. insert语句1.2.3. query语句a. 找到connector的DynamicTableSourceb. convertSourceToRel ing 2. statementSet.execute()2.1. translateToExecNodeGraph实现类1：StreamPhysicalTableSourceScan实现类2：StreamPhysicalLookupJoin实现类3：StreamPhysicalSink 2.2. translateToPlan 我们以一条sql为例分析下flink sql与connector是如何配合执行的，本文我们先分析
sql-&gt;sqlnode-&gt;validate-&gt;operation：是如何找到对应的connector实例的relnode-&gt;execGraph：是如何组装node为Graph，在哪找到connector实例的 之后的文章将会继续分析：
translateToPlanInternal是如何串联connector其他方法的runtime时是如何调用connector执行方法的 另外：对于connector的spi机制、connector并行度的设置后续也都可以分析。
一. 一条flink sql CREATE TABLE tjy_test1_ss ( `id` int, `name` string, age string, `proc_time` AS `proctime`() ) WITH ( 'password' = '11111111', 'timestamp-format.standard' = 'SQL', 'connector' = 'binlog-x', 'port' = '3306', 'cat' = 'insert', 'host' = 'localhost', -- 'connection-charset' = 'utf-8', 'url' = 'jdbc:mysql://localhost:3306/360test', 'table' = 'test003', 'username' = 'root', 'timestamp'='1702881040000' ); CREATE TABLE tjy_fortest1 ( `id` int, `name` string, `face` string, PRIMARY KEY (id) NOT ENFORCED ) WITH ( 'password' = '123456', 'connector' = 'mysql-x', 'sink.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41334978e96620df0fdc6f95ec706602/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a31828149157215b31db473732d6a87/" rel="bookmark">
			基于java的宿舍管理系统设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于java的宿舍管理系统设计与实现
I. 引言 A.研究背景和动机 随着大学校园规模的不断扩大，宿舍管理问题日益凸显。传统的管理方式通常需要人工记录，信息难以统一管理，容易出现信息丢失和重复记录等问题。基于Java的宿舍管理系统设计与实现，可以实现信息自动化和统一管理，提高管理效率和准确性，解决宿舍管理问题。
设计思路：
系统结构设计：系统结构设计包括数据结构设计、模块设计、接口设计等。通过数据结构设计，可以实现数据的有效组织和存储，通过模块设计，可以实现不同模块之间的相互协作和交互，通过接口设计，可以实现不同模块之间的灵活扩展和组合。数据库设计：数据库设计包括数据表设计、数据字段设计、数据关系设计等。通过数据表设计，可以实现数据的存储和检索，通过数据字段设计，可以实现数据的格式和内容控制，通过数据关系设计，可以实现数据之间的关联和连接。用户管理：用户管理包括用户权限管理、用户信息管理等。通过用户权限管理，可以实现不同用户之间的权限控制，通过用户信息管理，可以实现用户信息的添加、修改、删除等。宿舍管理：宿舍管理包括宿舍信息管理、宿舍成员管理等。通过宿舍信息管理，可以实现宿舍信息的添加、修改、删除等，通过宿舍成员管理，可以实现宿舍成员的添加、修改、删除等。
设计特点：开放性：系统设计开放，支持多种接口和协议，可以与其他系统进行灵活的集成和扩展。安全性：系统设计具有高度的安全性，通过权限管理和数据加密等措施，可以确保用户数据的隐私和安全。可扩展性：系统设计具有良好的可扩展性，可以支持多用户、多宿舍、多数据源等复杂的场景。性能优化：系统设计具有良好的性能优化能力，可以通过缓存、索引等技术，提高系统的响应速度和处理效率。 B.目标和意义 好的，以下是基于Java的宿舍管理系统设计与实现的目标和意义的介绍。
宿舍管理系统是针对学生宿舍的管理系统，旨在提高宿舍管理效率，保障学生宿舍的正常运转。该系统需要具备以下功能：
宿舍信息管理：包括宿舍的编号、名称、房间数量、面积、入住时间、离校时间等信息。学生信息管理：包括学生的姓名、学号、性别、年龄、宿舍分配情况等信息。宿舍管理：包括宿舍的卫生、电器、用水、用电、用气等管理。学生宿舍分配管理：包括学生宿舍的分配和调整等管理。宿舍检查管理：包括宿舍的检查和管理等管理。宿舍评价管理：包括宿舍的评价和管理等管理。宿舍报表管理：包括宿舍的报表和管理等管理。宿舍资源管理：包括宿舍的设备和资源的管理等管理。宿舍收费管理：包括宿舍的收费和管理等管理。
宿舍管理系统的主要目的是提高宿舍管理的效率，保障宿舍的正常运转。该系统可以为宿舍管理员提供全面的宿舍管理功能，包括宿舍信息管理、学生信息管理、宿舍管理、学生宿舍分配管理、宿舍检查管理、宿舍评价管理、宿舍报表管理、宿舍资源管理、宿舍收费管理等。宿舍管理系统可以帮助宿舍管理员更好地管理宿舍，提高宿舍管理的效率，减少宿舍管理中的错误和问题，保障学生宿舍的正常运转。 II. 相关技术和工具 A.Java语言 Java是一种面向对象的高级编程语言，由Sun Microsystems（现在是Oracle公司）于1995年发布。它是一种跨平台的语言，可以在不同的操作系统和硬件平台上运行。Java具有清晰、简洁的语法，易于学习和理解，同时具有强大的功能和良好的安全性。
Java语言是一种面向对象的语言，它支持封装、继承和多态等面向对象的概念。封装可以隐藏数据，使得程序更加安全，同时也可以保护数据不被非法访问。继承可以使得程序更加灵活，同时也可以减少代码的重复性。多态则可以使得程序更加灵活，并且可以适用于不同的应用场景。
Java语言具有跨平台性，它可以在不同的操作系统和硬件平台上运行。这是因为Java程序是由字节码组成的，字节码可以在不同的平台上编译成本地机器码，从而实现跨平台运行。Java语言也具有可移植性，它可以在不同的硬件和操作系统上运行，这使得Java程序可以轻松地移植到不同的环境。
Java语言也具有强大的功能和良好的安全性。Java提供了丰富的类库和API，这些类库和API可以大大简化程序开发工作。此外，Java还提供了各种安全机制，如字节码验证、安全管理器等，可以有效地防止程序被恶意攻击。
总之，Java是一种跨平台的、面向对象的、具有强大功能和良好安全性的编程语言。它已经广泛应用于各种领域，包括Web开发、移动应用开发和企业应用开发等。
B.数据库技术 数据库技术是一种用于管理和操作数据的软件系统。它可以帮助用户组织和存储数据，提供数据的安全性和可靠性，支持数据的增删改查等操作。数据库技术可以分为传统的关系型数据库技术和非关系型数据库技术。其中，关系型数据库技术包括SQL（结构化查询语言）、Oracle、MySQL、PostgreSQL等。非关系型数据库技术包括MongoDB、Redis、Memcached、Memcached等。这些技术在数据存储、数据查询、数据备份和数据恢复等方面都有着不同的优势和劣势。数据库技术在现代信息化建设中扮演着至关重要的角色，它被广泛应用于企业、政府、教育、医疗、金融等各个领域。
C.GUI技术 GUI技术，全称图形用户界面，是计算机科学中一个重要的概念。在计算机应用领域，GUI技术已经成为了一种常见的用户界面，被广泛应用于各种类型的软件和应用程序中。
GUI技术的发展历程可以追溯到上个世纪70年代。当时，人们开始开发基于图形界面的操作系统，如Windows和MacOS等。随着计算机技术的不断发展，GUI技术也在不断完善和优化，成为了现代计算机应用中不可或缺的一部分。
GUI技术的实现需要涉及到多个方面的技术，包括计算机图形学、用户界面设计、计算机编程语言等等。在实际应用中，GUI技术还需要考虑到各种不同的用户需求和场景，如不同的操作系统、不同的应用领域等等。
总的来说，GUI技术在现代计算机应用中发挥着非常重要的作用。它不仅为用户提供了更加直观、友好的界面体验，同时也为软件和应用程序的开发提供了更加方便、快捷的开发方式。相信随着技术的不断发展，GUI技术也会不断完善和优化，为用户提供更加出色的用户体验。
III. 系统需求分析与设计 A.系统功能需求 一、用户管理
用户信息管理：用户可以注册、登录、修改密码等操作。用户权限管理：管理员可以修改其他用户信息，但不能删除用户。用户角色管理：管理员可以创建、删除、修改用户角色。
二、宿舍管理宿舍信息管理：宿舍可以创建、删除、修改、修改价格等操作。宿舍房间管理：管理员可以添加、删除、修改房间信息。宿舍价格管理：管理员可以修改宿舍价格。
三、订单管理订单管理：管理员可以创建、删除、修改订单信息。订单状态管理：管理员可以修改订单状态。
四、付款管理付款管理：管理员可以创建、删除、修改付款信息。付款状态管理：管理员可以修改付款状态。
五、数据备份数据备份：管理员可以备份数据，防止数据丢失。
六、数据同步数据同步：管理员可以同步宿舍管理、订单管理、付款管理、数据备份、数据同步等功能。 B.业务流程分析 宿舍管理系统是一种用于管理学生宿舍的软件系统。该系统可以用于管理宿舍的学生信息、宿舍房间信息、宿舍管理员信息等。该系统可以帮助宿舍管理员更好地管理宿舍，提高宿舍的管理效率。该系统可以支持多种宿舍管理方式，包括管理员手动管理、宿舍管理员自动管理等。
该系统包含以下功能：
宿舍管理：该系统可以支持管理员手动管理宿舍，包括添加、修改、删除宿舍等操作。宿舍房间管理：该系统可以支持管理员手动管理宿舍房间，包括添加、修改、删除宿舍房间等操作。宿舍管理员管理：该系统可以支持管理员手动管理宿舍管理员，包括添加、修改、删除宿舍管理员等操作。宿舍信息管理：该系统可以支持管理员手动管理宿舍信息，包括添加、修改、删除宿舍信息等操作。数据备份：该系统可以自动备份宿舍管理数据，以防止数据丢失。
该系统可以支持多种宿舍管理方式，包括管理员手动管理、宿舍管理员自动管理等。管理员可以设置管理员自动管理模式，当管理员完成宿舍管理后，系统会自动将数据备份到指定的位置，管理员可以随时恢复数据。宿舍管理员可以设置自动管理模式，当宿舍管理员完成宿舍管理后，系统会自动将数据备份到指定的位置，宿舍管理员可以随时恢复数据。宿舍管理员可以设置自动管理模式，当宿舍管理员完成宿舍管理后，系统会自动将数据备份到指定的位置，宿舍管理员可以随时恢复数据。宿舍管理员可以设置自动管理模式，当宿舍管理员完成宿舍管理后，系统会自动将数据备份到指定的位置，宿舍管理员可以随时恢复数据。
该系统可以支持多种宿舍管理方式，包括管理员手动管理、宿舍管理员自动管理等。管理员可以设置管理员自动管理模式，当管理员完成宿舍管理后，系统会自动将数据备份到指定的位置，管理员可以随时恢复数据。宿舍管理员可以设置自动管理模式，当宿舍管理员完成宿舍管理后，系统会自动将数据备份到指定的位置，宿舍管理员可以随时恢复数据。宿舍管理员可以设置自动管理模式，当宿舍管理员完成宿舍管理后，系统会自动将数据备份到指定的位置，宿舍管理员可以随时恢复数据。宿舍管理员可以设置自动管理模式，当宿舍管理员完成宿舍管理后，系统会自动将数据备份到指定的位置，宿舍管理员可以随时恢复数据。
该系统可以支持多种宿舍管理方式，包括管理员手动管理、宿舍管理员自动管理等。管理员可以设置管理员自动管理模式，当管理员完成宿舍管理后，系统会自动将数据备份到指定的位置，管理员可以随时恢复数据。宿舍管理员可以设置自动管理模式，当宿舍管理员完成宿舍管理后，系统会自动将数据备份到指定的位置，宿舍管理员可以随时恢复数据。宿舍管理员可以设置自动管理模式，当宿舍管理员完成宿舍管理后，系统会自动将数据备份到指定的位置，宿舍管理员可以随时恢复数据。宿舍管理员可以设置自动管理模式，当宿舍管理员完成宿舍管理后，系统会自动将数据备份到指定的位置，宿舍管理员可以随时恢复数据。
该系统可以支持多种宿舍管理方式，包括管理员手动管理、宿舍管理员自动管理等。管理员可以设置管理员自动管理模式，当管理员完成宿舍管理后，系统会自动将数据备份到指定的位置，管理员可以随时恢复数据。宿舍管理员可以设置自动管理模式，当宿舍管理员完成宿舍管理后，系统会自动将数据备份到指定的位置，宿舍管理员可以随时恢复数据。宿舍管理员可以设置自动管理模式，当宿舍管理员完成宿舍管理后，系统会自动将数据备份到指定的位置，宿舍管理员可以随时恢复数据。宿舍管理员可以设置自动管理模式，当宿舍管理员完成宿舍管理后，系统会自动将数据备份到指定的位置，宿舍管理员可以随时恢复数据。宿舍管理员可以设置自动管理模式，当宿舍管理员完成宿舍管理后，系统会自动将数据备份到指定的位置，宿舍管理员可以随时恢复数据。 C.数据库设计 用户表
用户表包括用户名、密码、邮箱、手机等信息。用户表应该设置主键，以便于进行数据管理和查询。 CREATE TABLE USER ( USER_ID INT PRIMARY KEY, USERNAME VARCHAR(50) NOT NULL, PASSWORD VARCHAR(50) NOT NULL, EMAIL VARCHAR(50) NOT NULL, MOBILE INT NOT NULL ); 宿舍表
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a31828149157215b31db473732d6a87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/569b814d0d1f5ad1585ccf619d0ef45c/" rel="bookmark">
			动态规划学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 一般形式是求最值，核心是穷举。
首先，虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，需要你熟练掌握递归思维，只有列出正确的「状态转移方程」，才能正确地穷举。而且，你需要判断算法问题是否具备「最优子结构」，是否能够通过子问题的最值得到原问题的最值。另外，动态规划问题存在「重叠子问题」，如果暴力穷举的话效率会很低，所以需要你使用「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。
以上提到的重叠子问题、最优子结构、状态转移方程就是动态规划三要素。具体什么意思等会会举例详解，但是在实际的算法问题中，写出状态转移方程是最困难的，这也就是为什么很多朋友觉得动态规划问题困难的原因。以下是总结的一个思维框架，辅助思考状态转移方程：
明确 base case -&gt; 明确「状态」-&gt; 明确「选择」 -&gt; 定义 `dp` 数组/函数的含义
下面会举两道题目的例子进行解释。
509. 斐波那契数 https://leetcode.cn/problems/fibonacci-number/description
暴力递归 //最简单递归 int fib(int N) { if (N == 1 || N == 2) return 1; return fib(N - 1) + fib(N - 2); } 低效的原因：
存在大量重复计算，比如 `f(18)` 被计算了两次，而且你可以看到，以 `f(18)` 为根的这个递归树体量巨大，多算一遍，会耗费巨大的时间。更何况，还不止 `f(18)` 这一个节点被重复计算，所以这个算法及其低效。
这就是动态规划问题的第一个性质：重叠子问题。下面，我们想办法解决这个问题。
带备忘录的递归解法 int fib(int N) { //初始化备忘录全为0 int[] memo = new int[N + 1]; return dp(memo[], N); } //带着备忘录进行递归 int dp(int[] memo, int n) { //base case if (n == 0 || n == 1) { return n; } if (memo[n] !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/569b814d0d1f5ad1585ccf619d0ef45c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df1100c45468b389486b29c20994efe0/" rel="bookmark">
			【VerilogA】4位DAC的编写与测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 修改默认文本编辑器创建cellcell配置说明验证 修改默认文本编辑器 virtuoso默认的编辑器用不惯，改成gedit
editor="gedit" 创建cell Type选择VerilogA，随后OK
随后会弹出已填写默认模板的文本窗口。
将代码修改如下。VerilogA的语法和Verilog大差不差，但还是多少有点不同。细节可参考OVI_VerilogA或者verilogams。在这里笔者不讲VerilogA的语法细节。
// VerilogA for INVlib, DAC_4bits_nc_va, veriloga `include "constants.vams" `include "disciplines.vams" module DAC_4bits_nc_va(D3,D2,D1,D0,out); input D3,D2,D1,D0; output out; parameter real vdd=1.8; parameter real tdelay=0; parameter real trise=0; parameter real tfall=0; parameter real vref=1.8; voltage D3,D2,D1,D0,out; real code,out_temp; analog begin code=0; code=code+((V(D0)&gt;vdd/2) ? pow(2,0):0); code=code+((V(D1)&gt;vdd/2) ? pow(2,1):0); code=code+((V(D2)&gt;vdd/2) ? pow(2,2):0); code=code+((V(D3)&gt;vdd/2) ? pow(2,3):0); out_temp=code/16*vref; V(out)&lt;+ transition(out_temp,tdelay,trise,tfall); end endmodule 修改完后记得保存。
如果出现错误，会出现以下报错（这份代码应该是不会出现问题的，作为参考，我使用的是IC615）
保存完后会弹出一个窗口问你要不要建立symbol，一路无脑OK就完事了，记得save&amp;check。
cell配置说明 对器件按q，在CDF Parameter of view中选择veriloga，可以看到以下参数可供修改。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df1100c45468b389486b29c20994efe0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c2aa68e547b6b9e93130841f8484a99/" rel="bookmark">
			机器学习激活函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		激活函数 激活函数是人工神经网络中的一个重要组成部分。它们用于向神经网络中添加非线性因素，使得网络能够解决复杂问题，如图像识别、语言处理等。激活函数的作用是决定一个神经元是否应该被激活，也就是说，它帮助决定神经元的输出是什么。
一些常见的激活函数包括：
Sigmoid函数：将输入压缩到0和1之间，常用于二分类问题。
Tanh函数：也称为双曲正切函数，将输入压缩到-1和1之间，形状类似于Sigmoid，但由于输出范围更广，通常比Sigmoid更好。
ReLU函数：线性整流函数（Rectified Linear Unit），如果输入是正数则直接输出该数，如果是负数则输出0。这个函数在实践中非常流行，因为它能加快训练过程并提高性能。
Leaky ReLU：是ReLU的变体，它允许小的负值输出，避免了ReLU的一些问题，如神经元“死亡”。
Softmax函数：通常用于多分类问题的输出层，可以将输入转化为概率分布。
激活函数的选择取决于具体任务和网络的结构。每种激活函数都有其优势和适用场景。
当然可以。在PyTorch中，使用GPU加速和实现不同的激活函数是相对简单的。以下是一些常用激活函数的示例，以及如何使用PyTorch将计算移到GPU上。
首先，确保你的系统中安装了PyTorch，并且你的机器配备了NVIDIA GPU以及相应的CUDA支持。这是使用GPU加速的前提。
下面是一些示例代码，展示如何在PyTorch中使用Sigmoid、Tanh、ReLU和Softmax激活函数，并将计算移至GPU上：
import torch import torch.nn as nn # 检查CUDA（GPU加速）是否可用 device = torch.device("cuda" if torch.cuda.is_available() else "cpu") # 创建一个简单的张量（Tensor） tensor = torch.randn(10, 10).to(device) # 将张量移至GPU上 # Sigmoid激活函数 sigmoid = nn.Sigmoid() output_sigmoid = sigmoid(tensor) # Tanh激活函数 tanh = nn.Tanh() output_tanh = tanh(tensor) # ReLU激活函数 relu = nn.ReLU() output_relu = relu(tensor) # Softmax激活函数，适用于多分类问题 softmax = nn.Softmax(dim=1) # dim指定要计算Softmax的维度 output_softmax = softmax(tensor) # 打印输出，确认它们是在GPU上计算的 print(output_sigmoid) print(output_tanh) print(output_relu) print(output_softmax) 这段代码首先检查是否可以使用GPU。如果可以，它会将一个随机生成的张量移至GPU上，并对该张量应用不同的激活函数。需要注意的是，对于Softmax函数，你需要指定dim参数，这是因为Softmax通常用于多维数据，如多分类问题的输出层。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c2aa68e547b6b9e93130841f8484a99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0f35f5ecaa6dd53a952750ddf874d53/" rel="bookmark">
			Inveta数字孪生基座
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91b0360f333020f64c48559784420078/" rel="bookmark">
			清晰讲解Cookie、Session、Token、JWT之间的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 什么是认证(Authentication)什么是授权(Authorization)什么是凭证(Credentials)什么是Cookie什么是SessionSession的痛点 Cookie 和 Session 的区别什么是Token(令牌)Acesss TokenRefresh Token Token 和 Session 的区别Token 与 Cookie什么是 JWT生成JWTJWT 的原理JWT的使用方式方式一方式二方式三 Token 和 JWT 的异同常见的前后端鉴权方式常见的加密算法常见问题使用cookie时需要考虑的问题使用 session 时需要考虑的问题使用 token 时需要考虑的问题使用 JWT 时需要考虑的问题使用加密算法时需要考虑的问题 网友提问参考 以下内容为我结合他人知识进行的自我总结, 如有错误欢迎指出~
什么是认证(Authentication) 通俗地讲就是验证当前用户的身份，证明“你是你自己”（比如：你每天上下班打卡，都需要通过指纹打卡，当你的指纹和系统里录入的指纹相匹配时，就打卡成功）
互联网中的认证：
用户名密码登录邮箱发送登录链接手机号接收验证码只要你能收到邮箱/验证码，就默认你是账号的主人 什么是授权(Authorization) 用户授予第三方应用访问该用户某些资源的权限
你在安装手机应用的时候，APP 会询问是否允许授予权限（访问相册、地理位置等权限）你在访问微信小程序时，当登录时，小程序会询问是否允许授予权限（获取昵称、头像、地区、性别等个人信息） 实现授权的方式有：cookie、session、token、OAuth
什么是凭证(Credentials) 实现认证和授权的前提是需要一种媒介(证书) 来标记访问者的身份
在战国时期，商鞅变法，发明了照身帖。照身帖由官府发放，是一块打磨光滑细密的竹板，上面刻有持有人的头像和籍贯信息。国人必须持有，如若没有就被认为是黑户，或者间谍之类的。在现实生活中，每个人都会有一张专属的居民身份证，是用于证明持有人身份的一种法定证件。通过身份证，我们可以办理手机卡/银行卡/个人贷款/交通出行等等，这就是认证的凭证。在互联网应用中，一般网站会有两种模式，游客模式和登录模式。游客模式下，可以正常浏览网站上面的文章，一旦想要点赞/收藏/分享文章，就需要登录或者注册账号。当用户登录成功后，服务器会给该用户使用的浏览器颁发一个令牌（token），这个令牌用来表明你的身份，每次浏览器发送请求时会带上这个令牌，就可以使用游客模式下无法使用的功能。 什么是Cookie Cookie 是直接存储在浏览器中的一小串数据。它们是 HTTP 协议的一部分，由 RFC 6265 规范定义。
Cookie的工作机制如下
以加入购物车为例，每次浏览器请求后 server 都会将本次商品 id 存储在 Cookie 中返回给客户端，客户端会将 Cookie 保存在本地，下一次再将上次保存在本地的 Cookie 传给 server 就行了，这样每个 Cookie 都保存着用户的商品 id，购买记录也就不会丢失了
仔细观察上图相信你不难发现随着购物车内的商品越来越多，每次请求的 cookie 也越来越大，这对每个请求来说是一个很大的负担，我只是想将一个商品加入购买车，为何要将历史的商品记录也一起返回给 server ？购物车信息其实已经记录在 server 了，浏览器这样的操作岂不是多此一举？怎么改进呢 接下来讲Session
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91b0360f333020f64c48559784420078/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e779462488940fa7444f8c0e81f8d58e/" rel="bookmark">
			讲讲关于跨域的问题,什么是跨域?怎么办?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 什么是跨域如果非同源，共有三种行为受到限浏览器客户端和向服务器跨域请求的判定流程 跨域问题演示参考 以下内容为我结合他人知识进行的自我总结, 如有错误欢迎指出~
什么是跨域 跨域就是不同的域名下的资源访问，会被浏览器的本地安全策略阻止；
跨域是由浏览器的同源策略造成的，是浏览器施加的安全限制。是浏览器的一种保护机制，它的初衷是为了保证用户的安全，防止恶意网站窃取数据。
同源：是指相同的协议（例如http、https等）、域名（例如www.baidu.com,其中www是子域名即服务器名，baidu.com是主域名即网站名）、端口(8080)，三者都相同才属于同源。同源策略：指A 网页设置的 Cookie，B 网页不能打开，除非这两个网页“同源”，才能互相传递cookies，浏览器出于互联网安全考虑，不同源的网站之间是不能互相访问的；同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。跨域：由于浏览器同源策略，凡是发送请求的url的协议、域名、端口三者之间任意一个与当前页面地址不同则视为跨域。 （简单的讲法：不同域之间相互请求资源）。 设想这样一种情况：A 网站是一家银行，用户登录以后，A 网站在用户的机器上设置了一个 Cookie，包含了一些隐私信息（比如存款总额）。用户离开 A 网站以后，又去访问 B 网站，如果没有同源限制，B 网站可以读取 A 网站的 Cookie，那么隐私信息就会泄漏。更可怕的是，Cookie 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制。
如果非同源，共有三种行为受到限 1.无法获取非同源网页的 cookie、localstorage
比如A项目里 iframe(嵌入式框架) 了一个B项目，A跳转B项目时，浏览器本身的特点会自动检查两个域名是否同源，来判断是否能传递cookies给请求的B项目；除了不能传递cookie还是可以正常引用并跳转到B项目页面的，其实iframe的src就是浏览器顶部的url链接，拿到链接先去请求html，html编译后就是各种DOM树标签对象，也能请求接口等资源，因为在B自己的项目中，那如何避免DOM- iframe被访问呢，就用到第二点、如何避免A如果直接调B接口，就用到第三条；如果想要让AB传递cookies，则需要特别设置，比如AB两个项目都通过设置document.domain为相同的父级域名，则不会跨域了，两个项目交互时都会检查domain是否一致；前提需要AB主域名相同，否则设置了domain也没有用，不过前端可以通过postMessage，实质是HTML5的API，不同域下的页面在满足一定关系的条件下可以通过此API跨域传送数据，即传送cookies等信息；
2.DOM同源策略即，无法访问非同源网页的 DOM （iframe）
即B被嵌入到A的iframe中的时候，可以正常打开B页面渲染html，但是A无法获取B页面的DOM树以及请求的数据；如果配置了X-iframe-option=拒绝，那么页面是打不开的，可以防止点击劫持；
3.Ajax 的同源策略(即请求接口时判断是否同源，不同源则不允许请求)；
无法向非同源地址发送 AJAX 请求 或 fetch 请求（可以发送，但浏览器拒绝接受响应），因为浏览器自己的机制会检测是否同源，不同源的话，会发送跨域请求给后端，后端再给予该请求返回Access-Control-Allow-Origin，根据Access-Control-Allow-Origin配置的域名，来判断是否允许进行ajax接口请求，如果没有配置跨域资源共享（CORS）机制，那么会报错如下图：
贴一个 cors跨域请求的处理过程：https://www.cnblogs.com/xfenfen/p/9378393.html
然后我们要明确一个问题, 请求跨域了，请求到底发出去没有？答案是肯定发出去了，但是浏览器拦截了响应。
浏览器客户端和向服务器跨域请求的判定流程 浏览器先根据同源策略对前端页面和后台交互地址做匹配，若同源，则直接发送数据请求；若不同源，则发送跨域请求。
服务器解析程序收到浏览器跨域请求后，根据自身配置返回对应文件头即addHeader(‘Access-Control-Allow-Origin:*’);//允许所有来源访问 。若未配置过任何允许跨域，则文件头里不包含Access-Control-Allow-origin字段，若配置过域名，则在response header中返回Access-Control-Allow-origin+ 对应配置规则里的域名的方式。Access-Control-Allow-Origin指定支持访问的域名，不指定的网站不能访问；
浏览器根据接受到的http文件头里response header的Access-Control-Allow-origin字段做匹配，若无该字段，说明不允许跨域；若有该字段，则对字段内容和当前想要请求后端服务的来源域名Origin:https://cloud.mengxiang.com做比对，如果同源，则说明可以跨域，浏览器发送该请求；若不同源，则说明该域名不可跨域，不发送请求
（但是不能仅仅根据服务器返回的文件头里是否包含Access-Control-Allow-origin来判断其是否允许跨域，因为服务器端配置多域名跨域的时候，也会出现不能跨域的域名返回包里没有Access-Control-Allow-origin字段的情况。下文配置说明里会讲。)
注：header中Access-Control-Allow- credentials该项标志着请求当中是否包含cookies信息
跨域问题演示 下面链接的博客中演示了如何跨域 和 如何解决跨域问题
面试突击81：什么是跨域问题？如何解决？
参考 关于cookies网站跨域单点登录的原理 cookie的作用域以及跨域设置
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0956ec84b2a775580b9866e192e1f985/" rel="bookmark">
			vim基本操作命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、vi简介 vi是“Visual interface”的简称，它在Linux上的地位就仿佛Edit程序在DOS上一样。它可以执行输出、删除、查找、替换、块操作等众多文本操作，而且用户可以根据自己的需要对其进行定制。Vi不是一个排版程序，它不象Word或WPS那样可以对字体、格式、段落等其他属性进行编排，它只是一个文本编辑程序。 vi没有菜单，只有命令，且命令繁多
vi有三种基本工作模式：命令模式、文本输入模式、末行模式
1.1命令行模式 任何时候，不管用户处于何种模式，只要按一下ESC键，即可使Vi进入命令模式；我们在shell环境(提示符为$)下输入启动Vi命令，进入编辑器时，也是处于该模式下。在该模式下，用户可以输入各种合法的Vi命令，用于管理自己的文档。此时从键盘上输入的任何字符都被当做编辑命令来解释，若输入的字符是合法的Vi命令，则Vi在接受用户命令之后完成相应的动作。但需注意的是，所输入的命令并不在屏幕上显示出来。若输入的字符不是Vi的合法命令，Vi会响铃报警。
1.2文本输入模式 在命令模式下输入插入命令i、附加命令a 、打开命令o、修改命令c、取代命令r或替换命令s都可以进入文本输入模式。在该模式下，用户输入的任何字符都被Vi当做文件内容保存起来，并将其显示在屏幕上。在文本输入过程中，若想回到命令模式下，按键ESC即可。
1.3末行模式 末行模式也称ex转义模式。在命令模式下，用户按“:”键即可进入末行模式下，此时Vi会在显示窗口的最后一行(通常也是屏幕的最后一行)显示一个“:”作为末行模式的提示符，等待用户输入命令。多数文件管理命令都是在此模式下执行的(如把编辑缓冲区的内容写到文件中等)。末行命令执行完后，Vi自动回到命令模式。例如：
:sp newfile 则分出一个窗口编辑newfile文件。如果要从命令模式转换到编辑模式，可以键入命令a或者i；如果需要从文本模式返回，则按Esc键即可。在命令模式下输入“:”即可切换到末行模式，然后输入命令
二、vim基本操作 vim是从 vi 发展出来的一个文本编辑器 。代码补完、编译及错误跳转等方便编程的功能特别丰富
进入插入模式:
i: 插入光标前一个字符 I: 插入行首 a: 插入光标后一个字符 A: 插入行未 o: 向下新开一行,插入行首 O: 向上新开一行,插入行首 进入命令模式:
ESC:从插入模式或末行模式进入命令模式
移动光标:
h: 左移 j: 下移 k: 上移 l: 右移 M: 光标移动到中间行 L: 光标移动到屏幕最后一行行首 G: 移动到指定行,行号 -G w: 向后一次移动一个字 b: 向前一次移动一个字 {: 按段移动,上移 }: 按段移动,下移 Ctr-d: 向下翻半屏 Ctr-u: 向上翻半屏 Ctr-f: 向下翻一屏 Ctr-b: 向上翻一屏 gg: 光标移动文件开头 G: 光标移动到文件末尾 删除命令:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0956ec84b2a775580b9866e192e1f985/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c50cdc4be6e60563851505d237add8e/" rel="bookmark">
			Redis（四）事务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 事务Redis事务 vs 数据库事务常用命令总结 事务 一个队列中、一次性、顺序性、排他性执行一系列命令
官网https://redis.io/docs/interact/transactions/
Redis事务 vs 数据库事务 概述详述1、单独的隔离操作Redis的事务仅仅是保证事务里的操作会被连续独占的执行，redis命令执行是单线程架构，在执行完事务内所有指令前是不可能再去同时执行其他客户端的请求的2、没有隔离级别的概念因为事务提交前任何指令都不会被实际执行，也就不存在”事务内的查询要看到事务里的更新，在事务外查询不能看到”这种问题了3、不保证原子性Redis的事务不保证原子性，也就是不保证所有指令同时成功或同时失败，只有决定是否开始执行全部指令的能力，没有执行到一半进行回滚的能力4、排它性Redis会保证一个事务内的命令依次执行，而不会被其它命令插入 常用命令 正常执行 MULTI EXEC 放弃事务 MULTI DISCARD 全体连坐
在执行前命令检查发现错误无法进入队列，会直接不执行
冤头债主
在执行前命令检查没有发现错误进入队列，运行出现异常，能成功的命令执行成功，错误命令报错，无法回滚
watch监控
乐观锁类似CAS
watch命令是一种乐观锁的实现，Redis在修改的时候会检测数据是否被更改，如果更改了，则执行失败第一个窗口蓝色框第5步执行结果返回为空，也就是相当于是失败
总结 开始：以MULTI开始一个事务入队：将多个命令入队到事务中，接到这些命令不会立即执行，放到等待执行事务队列执行：由EXEC命令触发事务 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee4668fcf0228ee0d770778a31c07c3c/" rel="bookmark">
			DLT：dlt-daemon示例解析2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DLT：dlt-daemon示例解析
回顾一下上期第一个示例打印DLT日志的流程。
这次来分析第二个示例。
目录dlt-daemon/examples/example2/下有以下文件
CMakeLists.txt dlt_id.h example2.c example2.xml
其中example2.xml编译用不到，里面描述了一些程序的信息，我们先不管它。
// CMakeLists.txt
####### # SPDX license identifier: MPL-2.0 # # Copyright (C) 2011-2015, BMW AG # # This file is part of GENIVI Project DLT - Diagnostic Log and Trace. # # This Source Code Form is subject to the terms of the # Mozilla Public License (MPL), v. 2.0. # If a copy of the MPL was not distributed with this file, # You can obtain one at http://mozilla.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee4668fcf0228ee0d770778a31c07c3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f16a20504a14310553c5535cc7a6fff/" rel="bookmark">
			Robot Framework之python脚本调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
目录结构
​编辑
Python函数作为关键字
一、通过Import Library关键字在*** Test Cases ***中引用python脚本
​编辑
二、通过Library关键字在*** Settings ***中引入python脚本 Python类作为测试库
一、通过Library关键字在*** Settings ***引入python脚本中的类 二、通过Library关键字在*** Settings ***中导入sitepackage中的类
首先在site-packages目录下创建CustomLibrary目录，用于放自定义的library库 问题总结
推荐做法：
目录结构 ~/RobotFramework/TestDemo/PythonScript文件夹下的文件：
__init__.py
calculate.py printmsg.py ~/RobotFramework/TestDemo下的show.py
Python函数作为关键字 一、通过Import Library关键字在*** Test Cases ***中引用python脚本 1、直接在测试用例中使用关键字【Import Library .py文件的绝对路径】，即可使用该py文件中定义的函数。
2、调用方法：
robot --test "01.通过Import Library关键字引用python脚本" /home/youngyoung/RobotFramework/TestDemo 二、通过Library关键字在*** Settings ***中引入python脚本 1、直接在Settings中使用关键字【Library .py文件的相对路径】，即可使用该py脚本中定义的函数。
2、调用方法：
robot --test "01.通过Library关键字引入python脚本" /home/youngyoung/RobotFramework/TestDemo Python类作为测试库 在robot文件的Settings中声明，有两种方式：
模块法：点 .作为分隔符路径法：斜杠 /作为分隔符 在Settings表中声明用python类做的测试库，用模块法
在Settings表中声明资源文件和变量文件，用路径法或模块法
模块法必须创建__init__.py文件
一、通过Library关键字在*** Settings ***引入python脚本中的类 1、在Settings表中声明用python类做的测试库，用模块法
2、调用方法：
注意：1.必须将工作目录切换到TestDemo根目录
2.必须加上 -P参数将文件所在目录添加到PythonPath下，否则执行可能会报错，找不到Calculator这个类
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f16a20504a14310553c5535cc7a6fff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3fbe92629675e23462c67ef157b6a69/" rel="bookmark">
			MySQL安装部署-单机版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL是关系型数据库，本文主要描述在操作系统Linux CentOS 7下安装MySQL Server 8.035单机版本。
https://dev.mysql.com/downloads/mysql/
如上所示，从MySQL官方网站下载开源社区版本MySQL Server 8.035的最新稳定版本，该版本是对应Linux CentOS 7中的glibc 2.17的编译版本
如上所示，解压MySQL Server 8.035版本的官方安装文件到安装目录、在安装目录中创建连接文件夹mysql
如上所示，设置MySQL Server 8.035版本的启动配置文件以及启动项
如上所示，使用root用户初始化MySQL Server 8.035版本成功
如上所示，在Linux CentOS 7中设置开机启动MySQL Server 8.035版本
如上所示，使用root用户启动MySQL Server 8.035版本成功
如上所示，使用系统初始密码登录MySQL Server 8.035版本成功
如上所示，首次登录修改root密码成功
如上所示，从MySQL官方网站下载最新版本的MySQL Workbench数据库管理工具
如上所示，创建远程访问用户test成功、授权访问权限成功
如上所示，使用MySQL Workbench远程登录test用户成功
如上所示，使用MySQL Workbench远程创建一个数据库test_db
如上所示，使用MySQL Workbench远程创建一个数据表test_table
如上所示，使用MySQL Workbench远程在数据表test_table中增加一行记录成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b637f08ea4661df464074af1c1036102/" rel="bookmark">
			【JaveWeb教程】（20） MySQL数据库开发之 基本查询、条件查询、聚合函数、分组查询、排序查询、分页查询 详细代码示例讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. 数据库操作-DQL1.1 介绍1.2 语法1.3 基本查询1.4 条件查询1.5 聚合函数1.6 分组查询1.7 排序查询1.8 分页查询1.9 案例1.9.1 案例一1.9.2 案例二 在上次学习的内容中，我们讲解了：
使用DDL语句来操作数据库以及表结构（数据库设计）使用DML语句来完成数据库中数据的增、删、改操作（数据库操作） 我们今天还是继续学习数据库操作方面的内容：查询（DQL语句）。
查询操作我们分为两部分学习：
DQL语句-单表操作DQL语句-多表操作 1. 数据库操作-DQL 1.1 介绍 DQL英文全称是Data Query Language(数据查询语言)，用来查询数据库表中的记录。
查询关键字：SELECT
查询操作是所有SQL语句当中最为常见，也是最为重要的操作。在一个正常的业务系统中，查询操作的使用频次是要远高于增删改操作的。当我们打开某个网站或APP所看到的展示信息，都是通过从数据库中查询得到的，而在这个查询过程中，还会涉及到条件、排序、分页等操作。
1.2 语法 DQL查询语句，语法结构如下：
SELECT 字段列表 FROM 表名列表 WHERE 条件列表 GROUP BY 分组字段列表 HAVING 分组后条件列表 ORDER BY 排序字段列表 LIMIT 分页参数 我们今天会将上面的完整语法拆分为以下几个部分学习：
基本查询（不带任何条件）条件查询（where）分组查询（group by）排序查询（order by）分页查询（limit） 准备一些测试数据用于查询操作：
create database db02; -- 创建数据库 use db02; -- 切换数据库 -- 员工管理(带约束) create table tb_emp ( id int unsigned primary key auto_increment comment 'ID', username varchar(20) not null unique comment '用户名', password varchar(32) default '123456' comment '密码', name varchar(10) not null comment '姓名', gender tinyint unsigned not null comment '性别, 说明: 1 男, 2 女', image varchar(300) comment '图像', job tinyint unsigned comment '职位, 说明: 1 班主任,2 讲师, 3 学工主管, 4 教研主管', entrydate date comment '入职时间', create_time datetime not null comment '创建时间', update_time datetime not null comment '修改时间' ) comment '员工表'; -- 准备测试数据 INSERT INTO tb_emp (id, username, password, name, gender, image, job, entrydate, create_time, update_time) VALUES (1, 'jinyong', '123456', '金庸', 1, '1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b637f08ea4661df464074af1c1036102/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d9fd4283774c8c607ad3c0f8f92ea01/" rel="bookmark">
			HTB Manager ESC7 域提权
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTB Manager
rustscan -a 10.10.11.236 -- -sV -A -sC -v -oN manager # Nmap 7.93 scan initiated Wed Jan 10 14:39:52 2024 as: nmap -vvv -p 53,80,88,135,139,389,445,464,593,636,1433,3268,3269,5985,9389,49667,49674,49675,49673,49733,57721 -sV -A -sC -v -oN manager 10.10.11.236 Nmap scan report for 10.10.11.236 Host is up, received echo-reply ttl 127 (0.66s latency). Scanned at 2024-01-10 14:39:53 CST for 147s PORT STATE SERVICE REASON VERSION 53/tcp open domain syn-ack ttl 127 Simple DNS Plus 80/tcp open http syn-ack ttl 127 Microsoft IIS httpd 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d9fd4283774c8c607ad3c0f8f92ea01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb6632e494af4c719622ce1b68c53a95/" rel="bookmark">
			Python爬虫入门教程（非常详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初学Python之爬虫的简单入门 一、什么是爬虫？ 1.简单介绍爬虫 爬虫的全称为网络爬虫，简称爬虫，别名有网络机器人，网络蜘蛛等等。
网络爬虫是一种自动获取网页内容的程序，为搜索引擎提供了重要的数据支撑。搜索引擎通过网络爬虫技术，将互联网中丰富的网页信息保存到本地，形成镜像备份。我们熟悉的谷歌、百度本质上也可理解为一种爬虫。
如果形象地理解，爬虫就如同一只机器蜘蛛，它的基本操作就是模拟人的行为去各个网站抓取数据或返回数据。
2.爬虫的分类 网络爬虫一般分为传统爬虫和聚焦爬虫。
传统爬虫从一个或若干个初始网页的URL开始，抓取网页时不断从当前页面上抽取新的URL放入队列，直到满足系统的一定条件才停止，即通过源码解析来获得想要的内容。
聚焦爬虫需要根据一定的网页分析算法过滤与主题无关的链接，保留有用的链接并将其放入待抓取的URL队列，再根据一定的搜索策略从队列中选择下一步要抓取的网页URL，并重复上述过程，直到满足系统的一定条件时停止。另外，所有被爬虫抓取的网页都将会被系统存储、分析、过滤，并建立索引，以便之后的查询和检索;对于聚焦爬虫来说，这一过程所得到的分析结果还可能对以后的抓取过程给出反馈和指导。
防爬虫:KS-WAF（网站统一防护系统）将爬虫行为分为搜索引擎爬虫及扫描程序爬虫，可屏蔽特定的搜索引擎爬虫节省带宽和性能，也可屏蔽扫描程序爬虫，避免网站被恶意抓取页面。使用防爬虫机制的基本上是企业，我们平时也能见到一些对抗爬虫的经典方式，如图片验证码、滑块验证、封禁 IP等等。
3.爬虫的工作原理 下图是一个网络爬虫的基本框架：
对应互联网的所有页面可划分为五部分：
1.已下载未过期网页。
2.已下载已过期网页：抓取到的网页实际上是互联网内容的一个镜像文件，互联网是动态变化的，一部分互联网上的内容已经发生了变化，这时，这部分抓取到的网页就已经过期了。
3.待下载网页：待抓取URL队列中的页面。
4.可知网页：既没有被抓取也没有在待抓取URL队列中，但可通过对已抓取页面或者待抓取URL对应页面进行分析获取到的URL，认为是可知网页。
5.不可知网页：爬虫无法直接抓取下载的网页。
待抓取URL队列中的URL顺序排列涉及到抓取页面的先后次序问题，而决定这些URL排列顺序的方法叫做抓取策略。下面介绍六种常见的抓取策略：
1.深度优先遍历策略
深度优先遍历策略是指网络爬虫从起始页开始，由一个链接跟踪到另一个链接，这样不断跟踪链接下去直到处理完这条线路，之后再转入下一个起始页，继续跟踪链接。以下图为例：
遍历路径：A-F-G E-H-I B C D
需要注意的是，深度优先可能会找不到目标节点（即进入无限深度分支），因此，深度优先策略不一定能适用于所有情况。
2.宽度优先遍历策略
宽度优先遍历策略的基本思路是，将新下载网页中发现的链接直接插入待抓取URL队列的末尾。也就是指网络爬虫会先抓取起始网页中链接的所有网页，然后再选择其中的一个链接网页，继续抓取在此网页中链接的所有网页。还是以上图为例：
遍历路径：第一层：A-B-C-D-E-F，第二层：G-H，第三层：I
广度优先遍历策略会彻底遍历整个网络图，效率较低，但覆盖网页较广。
3.反向链接数策略
反向链接数是指一个网页被其他网页链接指向的数量。反向链接数反映一个网页的内容受到其他人推荐的程度。因此，很多时候搜索引擎的抓取系统会使用这个指标来评价网页的重要程度，从而决定不同网页的抓取先后顺序。
而现实是网络环境存在各种广告链接、作弊链接的干扰，使得许多反向链接数反映的结果并不可靠。
4.Partial PageRank策略
Partial PageRank策略借鉴了PageRank算法的思想：对于已下载网页，连同待抓取URL队列中的URL，形成网页集合，计算每个页面的PageRank值，然后将待抓取URL队列中的URL按照PageRank值的大小进行排列，并按照该顺序抓取页面。
若每次抓取一个页面，就重新计算PageRank值，则效率太低。
一种折中方案是：每抓取K个页面后，重新计算一次PageRank值。而对于已下载页面中分析出的链接，即暂时没有PageRank值的未知网页那一部分，先给未知网页一个临时的PageRank值，再将这个网页所有链接进来的PageRank值进行汇总，这样就形成了该未知页面的PageRank值，从而参与排序。以下图为例：
设k值为3，即每抓取3个页面后，重新计算一次PageRank值。
已知有{1,2,3}这3个网页下载到本地，这3个网页包含的链接指向待下载网页{4,5,6}（即待抓取URL队列），此时将这6个网页形成一个网页集合，对其进行PageRank值的计算，则{4,5,6}每个网页得到对应的PageRank值，根据PageRank值从大到小排序，由图假设排序结果为5,4,6，当网页5下载后，分析其链接发现指向未知网页8，这时先给未知网页8一个临时的PageRank值，如果这个值大于网页4和6的PageRank值，则接下来优先下载网页8，由此思路不断进行迭代计算。
5.OPIC策略
此算法其实也是计算页面重要程度。在算法开始前，给所有页面一个相同的初始现金（cash）。当下载了某个页面P之后，将P的现金分摊给所有从P中分析出的链接，并且将P的现金清空。对于待抓取URL队列中的所有页面按照现金数大小进行排序。
6.大站优先策略
对于待抓取URL队列中的所有网页，根据所属的网站进行分类。待下载页面数多的网站优先下载。
二、爬虫的基本流程 首先简单了解关于Request和Response的内容：
Request：浏览器发送消息给某网址所在的服务器，这个请求信息的过程叫做HTTP Request。
Response:服务器接收浏览器发送的消息，并根据消息内容进行相应处理，然后把消息返回给浏览器。这个响应信息的过程叫做HTTP Response。浏览器收到服务器的Response信息后，会对信息进行相应处理，然后展示在页面上。
根据上述内容将网络爬虫分为四个步骤：
1.发起请求：通过HTTP库向目标站点发起请求，即发送一个Request，请求可以包含额外的headers等信息，等待服务器响应。
常见的请求方法有两种，GET和POST。get请求是把参数包含在了URL（Uniform Resource Locator,统一资源定位符）里面，而post请求大多是在表单里面进行，也就是让你输入用户名和秘密，在url里面没有体现出来，这样更加安全。post请求的大小没有限制，而get请求有限制，最多1024个字节。
2.获取响应内容：如果服务器能正常响应，会得到一个Response，Response的内容便是所要获取的页面内容，类型可能有HTML，Json字符串，二进制数据（如图片视频）等类型。
3.解析内容：得到的内容可能是HTML，可以用正则表达式、网页解析库进行解析。可能是Json，可以直接转为Json对象解析，可能是二进制数据，可以做保存或者进一步的处理。
在Python语言中，我们经常使用Beautiful Soup、pyquery、lxml等库，可以高效的从中获取网页信息，如节点的属性、文本值等。
Beautiful Soup库是解析、遍历、维护“标签树”的功能库，对应一个HTML/XML文档的全部内容。安装方法非常简单，如下：
#安装方法 pips install beautifulsoup4 #验证方法 from bs4 import BeautifulSoup 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb6632e494af4c719622ce1b68c53a95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78c11e58e5efc3a6e074cc734ab00c44/" rel="bookmark">
			[ERROR] 不再支持目标选项 5。请使用 7 或更高版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在编译spirng boot 3.x版本时,出现了以下错误.
出现这个错误:
[ERROR] COMPILATION ERROR :
[INFO] --------------------------------------------
[ERROR] 不再支持源选项 5。请使用 7 或更高版本。
[ERROR] 不再支持目标选项 5。请使用 7 或更高版本。
要指定版本:
解决办法,在pom.xml中添加:
&lt;properties&gt;
&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
&lt;java.version&gt;1.8&lt;/java.version&gt;
&lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
&lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
&lt;/properties&gt;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a58ba36517fb239a27999c75710b4fc/" rel="bookmark">
			Python为什么这么牛？Python真有这么好的前景？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要说最近几年最火的语言，python绝对可以拥有姓名，最近几年Python更是有超越Java之势。python的应用范围非常非常的广泛，但Python的整体语言难度来讲又比Java简单的很多。尤其是在运维的应用中非常的广泛，所以之前出了一句话，在如今的时代，运维不学Python，迟早会被淘汰！
可是难道现在Python语言真的有这么好的就业前景吗？首先小编来给大家介绍一下Python学完以后能做什么。
一、人工智能 Python作为人工智能的黄金语言，选择人工智能作为就业方向是理所当然的，而且就业前景好，薪资普遍较高，拉勾网上，人工智能工程师的招聘起薪普遍在20K-35K，当然，如果是初级工程师，起薪也已经超过了12500元/月。
二、大数据 我们目前正处于大数据时代，Python这门语言在大数据上比Java更加有效率，大数据虽然难学，但是Python可以更好地和大数据对接，用Python做大数据的薪资也至少是20K以上了，大数据持续火爆，未来做大数据工程师，薪资还将逐渐上涨。
三、网络爬虫工程师 网络爬虫作为数据采集的利器，在大数据时代作为数据的源头，十分有用武之地。利用Python可以更快的提升对数据抓取的精准程度和速度，是数据分析师的福祉，通过网络爬虫，让BOSS再也不用担心你没有数据。做爬虫工程师的的薪资为20K起，当然，因为大数据，薪资也将一路上扬。
四、Python Web全栈工程师 全栈工程师是指掌握多种技能，并能利用多种技能独立完成产品的人。也叫全端工程师(同时具备前端和后台能力)，英文Full Stack developer。全栈工程师不管在哪个语言中都是人才中的人才，而Python Web全栈工程师工资基本上都高出20K，所以如果你能力足够，首选就是Python Web全栈工程师。
五、Python自动化运维 运维工作者对Python的需求很大，小伙伴们快快行动起来吧，学习Python自动化运维也能有个10k-15k的工资，很不错哦。
六、Python自动化测试 Python这门语言十分高效，只要是和自动化有关系的，它可以发挥出巨大的优势，目前做自动化测试的大部分的工作者都需要学习Python帮助提高测试效率。用Python测试也可以说是测试人员必备的工具了，Python自动化测试的起薪一般也都是15K左右，所以测试的小伙伴也需要学习Python哦！
七、3D游戏开发 Python有很好的3D渲染库和游戏开发框架，有很多实用Python开发的游戏，如迪士尼卡通城、黑暗之刃。常用PyGame、PyKyra等和一个PyWeek的比赛。对于想要进军游戏行业的同学们，Python也是一个不错的选择。
八、业务技术架构评估和优化 代码本身的优劣足以影响到访问效率的高低，而这种影响是很难通过后天的集群和服务器的优化而有所改善的。而具备开发能力，可以使评估技术架构是否合理，哪些地方可以做出调整，具备开发和架构设计及调优能力可是成为一个出色架构师的必须能力。
最后免费分享给大家一份Python全套学习资料，包含视频、源码，课件，希望能帮到那些不满现状，想提升自己却又没有方向的朋友。
🎁福利🎁 全网最全《Python学习资料》免费赠送🆓！
最近火热ChatGPT 等人工智能应用对 Python 编程语言产生了积极的影响，它推动了 Python 的普及和发展，在文本处理和 NLP 领域提升了 Python 的地位，促进了 Python 生态系统的成长
学好 Python 不论是就业还是做副业赚钱都不错，但要学会 Python 还是要有一个学习规划。最后大家分享一份全套的 Python 学习资料，给那些想学习 Python 的小伙伴们一点帮助！
#### **一、Python学习路线** 二、Python基础学习 1. 开发工具 2. 学习笔记 3. 学习视频 三、Python小白必备手册 四、数据分析全套资源 五、Python面试集锦 1. 面试资料 2. 简历模板 ​ 因篇幅有限，仅展示部分资料，添加上方即可获取
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7fe101ac644d6c4eeb9c1da06cd0c40/" rel="bookmark">
			OOP面向对象的知识总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、OOP的概念
面向对象思想：
二、方法：
三、对象数组：
四、重载与构造：
五、this static 单例模式：
六、继承：
七、重写与抽象：
八、final与多态：
九、instanceof：判断运算符：
十、接口;
十一、异常：
十二、里氏替换原则：
十三、修饰符：
一、OOP的概念 1.OOP 即面向对象编程: java就是面向对象编程的语言。
世界由万物组成，万物都是对象（世界万物皆为对象）
面向对象思想： 第一步：发现类； 第二步：发现类的属性； 第三步：发现类的方法； 2.对象：客观的存在在这个世界上的每一个事物；
万事万物皆为对象；
3.类：从具有相同属性和方法的多个对象中抽取出来的；
类里面有且仅有属性与方法；(学会把类看做一种数据类型)
4.区别：对象是实实在在存在的具体的概念 ；
类是一个抽象的概念；
5.属性---本身所具备的特征；
方法---会的行为（功能）；
二、方法： 1、方法构造：修饰符 返回类型 方法名（参数）{方法体}
2、属性构造：修饰符 数据类型 变量名
3、方法返回类型：方法按照返回类型可以分为以下两种：
有返回return ： 在方法名前面接一个数据类型 ，且方法体内部最后一行必须接return 而且返回的数据类型必须和前面的数据类型保持一致！ 无返回void ： 在方法体内部不需要接return 在类里面 ，有且仅有“属性”和“方法”（禁止直接接代码） 4、方法传参：实参和形参的参数个数、数据类型、顺序一致
5、局部变量和成员变量：
局部变量没有初始值，而成员变量有 同名时，局部变量具有更高的优先级 作用域：局部变量只能在本方法中使用，成员变量可以在本类的所有方法中使用 同一个方法中，局部变量不允许重名 三、对象数组： 1、学会把类看作是一种数据类型！
2、对象数组三部曲：
定义类 声明并实例化一个对象 初始化（赋值） 3、封装两步：私有化属性 公开方法（可以根据实际情况考虑是否公开读写方法
4、this 这个 指代自己本类
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7fe101ac644d6c4eeb9c1da06cd0c40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60379e6f1df1748bda495990bee9404f/" rel="bookmark">
			python如何重复执行代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在编程中，有时候需要重复执行某个特定的代码段，这就需要使用循环结构。Python提供了多种循环结构，可以满足不同的需求。本文将从多个角度分析Python如何重复执行代码。
1. for循环 for循环是Python中最常用的循环结构之一。它用于遍历一个序列（如列表、元组、字符串等）或其他可迭代对象。for循环的语法格式如下：
for 变量 in 序列: 循环体 其中，变量表示当前遍历到的元素，序列表示要遍历的对象。每次循环，变量会自动取出序列中的下一个元素，并执行循环体中的代码。for循环可以重复执行很多次，直到序列中的所有元素都被遍历完为止。
例如，以下代码使用for循环输出一个列表中的所有元素：
fruits = ['apple', 'banana', 'orange'] for fruit in fruits: print(fruit) 输出结果为：
apple banana orange 2. while循环 while循环也是Python中常用的循环结构之一。它用于在满足某个条件的情况下重复执行一段代码，直到条件不再满足为止。while循环的语法格式如下：
while 条件: 循环体 其中，条件是一个布尔表达式，表示循环是否继续执行。只要条件为True，循环就会一直执行。循环体中的代码会不断重复执行，直到条件变为False为止。
例如，以下代码使用while循环计算1到100的和：
i = 1 sum = 0 while i &lt;= 100: sum += i i += 1 print(sum) 输出结果为：
5050 3. range函数 range函数是Python内置的一个函数，用于生成一个整数序列。它的语法格式如下：
range(start, stop[, step]) 其中，start表示序列的起始值（默认为0），stop表示序列的结束值（不包括该值），step表示序列中相邻两个值之间的步长（默认为1）。range函数返回的是一个可迭代对象，可以用于for循环和其他需要序列的场合。
例如，以下代码使用range函数生成一个1到10的整数序列，并计算序列中所有元素的和：
sum = 0 for i in range(1, 11): sum += i print(sum) 输出结果为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60379e6f1df1748bda495990bee9404f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/868de306735c37c5d74fa0eb580be47e/" rel="bookmark">
			Docker入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
服务器选型
对比
虚拟机
微服务的部署策略
基于主机(物理机或虚机)的多服务实例
基于容器的服务实例
Docker
虚拟机与容器的区别
Docker三要素 Docker镜像
Docker仓库
Docker容器
Docker安装
Docker基本使用
基本操作
仓库+镜像
容器
服务器选型 在选择服务器操作系统时， Windows 附带了许多您需要付费的功能。 Linux 是开放源代码，可让用户免费使用。 对比 Linux 是开源的，因此是免费的。 Web 主机仅需要支付技术支持即可安装和维护程序（如果需 要）。服务器提供商不需要将额外的成本转嫁给客户。另一方面，对于 Windows 服务器，公司通常 必须为操作系统和定期使用许可证付费。 Linux 服务器及其运行的应用程序通常设计为精益运行，因此通常使用较少的计算机资源。好处是 程序员可以 “ 即时 ” 修改 Linux 服务器和软件，而无需重新启动，这在 Windows 环境中是不可能的。 Microsoft Windows 服务器在多数据库任务下趋向于变慢，崩溃的风险更高。 Linux 比 Windows 更安全。尽管没有哪个系统能幸免于黑客和恶意软件的攻击，但是 Linux 往往是 一个低调的目标。由于 Windows 运行着世界上大多数软件，因此，黑客们渴望获得低挂的果实 Windows 。 虚拟机 虚拟机指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。 微服务的部署策略 部署单体应用意味着运行大型应用的多个相同副本，通常提供若干台（ N ）服务器（物理机或虚拟 机），在每台服务器上运行若干个（ M）应用实例。部署单体应用并不总是简单明了，但还是比部署微服务应用简单。 微服务应用由几十甚至数百个服务组成。服务用不同的语言和框架写成，每个都是一个小应用，包括特定的部署、资源、扩展和监控需求，例如，根据服务需求运行若干数量的服务实例。 此外，每个服务实例必须配套提供适当的 CPU 、内存 和 I/O 资源。更具挑战性的是，尽管如此复杂，部署服务还必须快速、可靠和性价比高。 基于主机(物理机或虚机)的多服务实例 “ 基于主机的多服务实例 ” 模式是最为传统的应用程序部署方法。 在该模式下，软件开发人员可以提供单个或多个物理机或虚机，同时在每个主机上运行多个服务实例。 此模式有几种不同的实现形式，其中包括：将每一个服务实例都作为一个单独的进程，或是在同一进程中运行多个服务实例。 优点 : 由于多个服务实例使用的是同一服务器、及其操作系统，因此它们的资源使用效率相对较 高。 不足 : 除非每个实例都是一个单独的进程，否则您对服务实例的实际控制权并不大。而且，您无法 限制每个实例能够使用到的资源比例。这将带来主机内存被大量消耗的隐患。 如果多个服务实例在同一进程中运行，它们之间会缺乏隔离关系。这通常会导致在相同进程 中，某个行为异常的服务能够直接影响、甚至中断其他的服务。 由于运营团队需要了解服务的详细信息，因此在部署期间，他们可能发生人为错误的风险较 高。显然，开发和运营团队之间需要通过必要的信息交换，来尽可能地消除复杂性。 基于容器的服务实例 在这种部署模式下，每个服务实例都运行在其各自的容器中，因此也被称为操作系统级别的虚拟化机制。 使用这一模式时，用户将服务打包为容器镜像。每个容器镜像就是一个文件系统镜像，由应用和运行服 务所需的库构成。有的容器镜像还包括完整的 Linux 根文件系统，有的则更轻量。 以部署 Java 服务为例，构建的容器镜像包括 Java 运行时、 Apache Tomcat 服务器、以及编译好的 Java 应用。 一旦将服务打包为容器镜像，就启动一到多个容器。通常每个物理机或虚拟主机上会运行多个容器，会 用到 Kubernetes 或 Marathon 这样的集群管理工具来管理容器。 集群管理工具把主机看做资源池，根据每个容器需要的资源和每个主机上可用的资源来调度容器。 Docker Docker 是近年来新兴的虚拟化工具，它可以和虚拟机一样实现资源和系统环境的隔离。 虚拟机与容器的区别 VM(VMware)在宿主机器、宿主机器操作系统的基础上创建虚拟层、虚拟化的操作系统、虚拟化的仓库，然后再安装应用； Container(Docker 容器 ) ，在宿主机器、宿主机器操作系统上创建 Docker引擎，在引擎的基础上再安装应用。 Docker三要素 Docker镜像 Docker 镜像就是一个只读的模板。 例如：一个镜像可以包含一个完整的 ubuntu 操作系统环境，里面仅安装了 Apache 或用户需要的其它应用程序。 镜像可以用来创建 Docker 容器。 Docker 提供了一个很简单的机制来创建镜像或者更新现有的镜像，用户甚至可以直接从其他人那里下载一个已经做好的镜像来直接使用。 Docker仓库 仓库是集中存放镜像文件的场所。 有时候会把仓库和仓库注册服务器（Registry）混为一谈，并不严格区分。实际上，仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（ tag ）。 仓库分为公开仓库（ Public ）和私有仓库（ Private ）两种形式。 最大的公开仓库是 Docker Hub ，存放了数量庞大的镜像供用户下载。 当然，用户也可以在本地网络内创建一个私有仓库。 当用户创建了自己的镜像之后就可以使用 push 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 pull 下来就可以了。 Docker容器 Docker 利用容器来运行应用。 容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。 可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等和运行在其中的应用程序。 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/868de306735c37c5d74fa0eb580be47e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/041199e1dff3f31a59ef53a98bfcaa77/" rel="bookmark">
			Java实现Leetcode题（二叉树-3）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Leetcode106（从中序与后序遍历序列构造二叉树） package tree; import java.util.HashMap; import java.util.Map; public class LeetCode106 { public static void main(String[] args) { } public static TreeNode buildTree(int[] inorder,int[] postorder) { Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int i = 0;i&lt;inorder.length;i++) { map.put(inorder[i], i); //将中序的值和索引 } return travelWay(inorder,0,inorder.length,postorder,0,postorder.length,map); } //9-3-15-20-7 中 //9-5-7-20-3 后 public static TreeNode travelWay(int[] inorder,int inBegin,int inEnd,int[] postorder,int postBegin,int postEnd,Map&lt;Integer,Integer&gt; map) { if(inBegin&gt;=inEnd||postBegin&gt;=postEnd) { return null; } //不满足左闭右开，说明没有元素 int rootIndex = map.get(postorder[postEnd-1]); //找到结点的索引值 TreeNode root = new TreeNode(inorder[rootIndex]); //获取结点的数值 int lenOfleft = rootIndex-inBegin; root.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/041199e1dff3f31a59ef53a98bfcaa77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/569ded553325a4b4eda17f77ed3e7b7a/" rel="bookmark">
			软件测试|使用Python读取CSV文件的详细指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 CSV（Comma-Separated Values）是一种常用的数据存储格式，它以逗号为分隔符将数据以文本形式存储在文件中。Python是一门强大的编程语言，提供了许多库和工具，使得读取和处理CSV文件变得非常简便。在本文中，我们将深入介绍如何使用Python读取CSV文件的详细步骤。
步骤1：导入所需的库 在开始之前，需要导入Python中处理CSV文件所需的库。Python标准库中的csv模块是一个处理CSV文件的良好选择。
import csv 步骤2：打开CSV文件 在读取CSV文件之前，需要使用Python的内置open函数打开文件。确保提供正确的文件路径，并指定文件的打开模式为读取（'r'）。
file_path = 'your_file.csv' with open(file_path, 'r') as csv_file: # 后续操作将在此代码块中进行 步骤3：创建CSV读取器 在打开文件后，需要创建一个CSV读取器对象，用于我们逐行读取CSV文件的内容。
with open(file_path, 'r') as csv_file: csv_reader = csv.reader(csv_file) for row in csv_reader: # 每次迭代将读取一行数据并存储在'row'变量中 步骤4：处理CSV数据 现在我们可以通过迭代CSV读取器对象来访问每一行数据。每一行数据都被解析为一个由字段组成的列表。
with open(file_path, 'r') as csv_file: csv_reader = csv.reader(csv_file) for row in csv_reader: # 您可以通过索引访问每个字段 # 例如：第一个字段 row[0], 第二个字段 row[1], 依此类推 # 进行您的数据处理操作，例如打印每一行数据 print(row) 步骤5：使用CSV DictReader 如果CSV文件的第一行包含列标题，我们还可以使用csv.DictReader来创建一个能够返回每行数据作为字典的读取器。这样做使得我们可以通过列标题访问数据，使得代码更加清晰易读。
with open(file_path, 'r') as csv_file: csv_reader = csv.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/569ded553325a4b4eda17f77ed3e7b7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa1f670c8cdc03f777d25c95237df204/" rel="bookmark">
			QT周四作业
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目： 代码： widget.cpp #include "widget.h" #include "ui_widget.h" #include &lt;QDebug&gt; Widget::Widget(QWidget *parent) : QWidget(parent) , ui(new Ui::Widget) { ui-&gt;setupUi(this); ui-&gt;lineEditName-&gt;setPlaceholderText("请输入用户名"); ui-&gt;lineEditPasswd-&gt;setPlaceholderText("请输入密码"); ui-&gt;lineEditPasswd-&gt;setEchoMode(QLineEdit::Password); ui-&gt;loginushButton-&gt;setText("登录"); ui-&gt;loginRadioButton-&gt;setChecked(true); connect(ui-&gt;loginushButton,SIGNAL(clicked()),this,SLOT(loginBtnClickFun())); connect(ui-&gt;loginRadioButton,SIGNAL(clicked()),this,SLOT(clickRadioBtnFun())); connect(ui-&gt;registerRadioButton_2,SIGNAL(clicked()),this,SLOT(clickRadioBtnFun())); connect(ui-&gt;lineEditPasswd,SIGNAL(editingFinished()),this,SLOT(loginBtnClickFun())); } Widget::~Widget() { delete ui; } void Widget::loginBtnClickFun() { qDebug()&lt;&lt;"name = "&lt;&lt;ui-&gt;lineEditName-&gt;text()&lt;&lt;"passwd = "&lt;&lt;ui-&gt;lineEditPasswd-&gt;text(); ui-&gt;loginushButton-&gt;isChecked()?qDebug()&lt;&lt;"loginRadioButton isChecked":qDebug()&lt;&lt;"registerRadioButton isChecked"; ui-&gt;checkBox-&gt;isChecked()?qDebug()&lt;&lt;"checkBox isChecked":qDebug()&lt;&lt;"checkBox isNotChecked"; } void Widget::clickRadioBtnFun() { if(ui-&gt;loginRadioButton-&gt;isChecked()) { ui-&gt;loginushButton-&gt;setText("登录"); } if(ui-&gt;registerRadioButton_2-&gt;isChecked()) { ui-&gt;loginushButton-&gt;setText("注册"); } } widget.h #ifndef WIDGET_H #define WIDGET_H #include &lt;QWidget&gt; QT_BEGIN_NAMESPACE namespace Ui { class Widget; } QT_END_NAMESPACE class Widget : public QWidget { Q_OBJECT public: Widget(QWidget *parent = nullptr); ~Widget(); public slots: void loginBtnClickFun(); void clickRadioBtnFun(); private: Ui::Widget *ui; }; #endif // WIDGET_H 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1f7fc1fedfd0d02a98128b70fe12656/" rel="bookmark">
			软件测试|Python如何将列表从大到小排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 在编程中，对列表进行排序是一个常见的操作，有时候我们需要将列表按照从大到小的顺序进行排列。Python 提供了多种方法来实现这一目标。在本文中，我们将深入探讨几种将列表从大到小排序的方法，帮助您根据不同情况选择最合适的方式。
使用sorted()函数 Python的sorted()函数可以接收一个列表并返回一个新的排序后的列表。通过指定reverse=True参数，可以实现从大到小的排序。
numbers = [23, 45, 12, 67, 89, 34] sorted_numbers = sorted(numbers, reverse=True) print("排序后的列表:", sorted_numbers) -------- 输出结果如下： 排序后的列表: [89, 67, 45, 34, 23, 12] 使用list.sort()方法 list.sort()是列表对象的一个方法，它可以直接对列表进行原地排序。同样，通过指定reverse=True参数，可以实现从大到小的排序。
numbers = [23, 45, 12, 67, 89, 34] numbers.sort(reverse=True) print("排序后的列表:", numbers) --------- 输出结果如下： 排序后的列表: [89, 67, 45, 34, 23, 12] 使用sorted()函数和自定义比较函数 如果需要基于自定义的比较逻辑对列表进行排序，可以使用sorted()函数的key参数来指定一个比较函数。
def custom_compare(item): return -item # 取相反数，实现从大到小排序 numbers = [23, 45, 12, 67, 89, 34] sorted_numbers = sorted(numbers, key=custom_compare) print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1f7fc1fedfd0d02a98128b70fe12656/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2c256935ba6248f4e353b1b0a858b82/" rel="bookmark">
			怎么查看python版本？有几种方法？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 python 的安装过程中，有时候可能出现安装多个 python 版本，或者安装了 anaconda，visual studio 导致内置了 python 版本。这样就容易导致如下情况：
pip 安装模块不知道安装到哪个 python；jupyter 使用时不知道用的哪个 python；某些模块对 python 版本有要求。 所以如何查看安装的 python 版本，对python 的日常使用是相当重要的，接下来就让小编来告诉你，python 版本查看都有那些方法吧。
最简单的方法-使用命令行
要想知道自己运行的 python 版本，只需要运行 python 交互解释器就可以看到了。
按 WIN +R 进入运行，输入 cmd，点击确定打开命令提示符，输入​python​，进入 python 交互解释器，即可显示 python 版本信息
在命令提示符中输入 ​python –V​ 或者 ​python --version​，也可以查询 python 版本（标准方式）。
使用 python代码查看版本号
使用如下代码，可以打印出 python 的版本（使用 sys 库）。
import sys #sys模块提供了一系列有关Python运行环境的变量和函数。 print(sys.version) #sys.version用来获取Python解释程序的版本信息 使用如下代码，也可以打印出 python 的版本（使用 platform 库）
import platform #platform模块给我们提供了很多方法去获取操作系统的信息 print(platform.python_version()) #platform.python_version()可以获得计算机中python的版本 利用软件查看-在 juptyter 中看 python版本
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2c256935ba6248f4e353b1b0a858b82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a079c9f15490cd228046029c21d2d86/" rel="bookmark">
			【技术选型】Doris vs starRocks
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		比对结论 仅从当前能看到的数据中，相比于doris，starRocks在性能方面具备优势，且更新频率高（降低维护成本）。
目标诉求 并发性不能太低——相比于clickhouse不到100的QPS支持大表关联——降低数据清洗的压力，因为oneId有可能实时变化集群化——需要有一定扩展能力，以针对不同量级客户可维护——C++底层代码 背景说明 doris前身是百度的palo，因为名字重复，开源的时候换成doris。
starRocks只是从doris的一个分支进行演进。
从人员角度，两者原来是一个团队，后续出现分歧（预计两个问题，一是国内对开源内容不够重视，二是有些人想要商业化）。
starRocks最开始出来的时候叫dorisDB，且文档中有doris相关内容，使很多人误以为是doris的商业版。后续才改名为starRocks。因为上述不道德的行为，导致风评比较差，所以社区的活跃主要是国内。
两者的开源协议不一致，doris是Apache license，starRocks是Elastic License。这就意味着starRocks是部分开源，说是为了防止云厂商的白嫖，但从这一路操作看，未来大概率会商业版。
doris的社区相关活跃的范围更大，但实际活跃度也待定。
推测演进速度，starRocks由于未来考虑商业化，短期内速度一定是更快的，但是否能坚持很久。
doris短期内可能是慢的，但大概率可以维持很久。
目标需求 具备一定并发能力且能实现大表关联的数据库版本更新相对频繁，这样可以有效解决BUG 潜在风险 starRocks有可能会商业化，导致在某些版本之后有收费的风险 性能是基于c++开发的，咱们无法修改，doris更新慢的问题就会暴露 信息比对 项目性能github star稳定性演进效率协议Doris中10.4k稳定慢Apache licensestarRocks优7k相对稳定快Elastic License 性能比对 由于starRocks在doris的社区投票中投入反对票，导致向量化优化推迟合入版本，这就是为什么doris的1.X版本性能是低于starRocks的。
starRocks 3.0 是2023 年 4 月 28 日发布。
doris 2.0 是2023 年 8 月 11 日发布。
正常来说是用doris 2.X 和 starRocks 3.X 进行比对。
但由于doris的2.X发布不久，无法找到直接和starRocks 3.X的性能比对。
计划考虑找doris 2.X 和 doris 1.2X的比对，和doris 1.2X和starRocks 3.X的性能比对。
场景doris 1.2Xdoris 2.XstarRocks 3.X宽表场景盲测110多表关联场景盲测113行为分析场景中并发查询15-90点查询并发能力120日志检索分析110数据写入120 参考文档 Release 2.0.0 - Apache Doris
文件读取比较 2023年10月1日数据湖测试 – 沧海月明
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a079c9f15490cd228046029c21d2d86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c09e720177e8fafeda1c4c6611a78a15/" rel="bookmark">
			青铜到王者，9本最好的Python从入门到进阶的书！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无论是准备转行的，还是想多学一份技能提高职场竞争力的，都想选择Python赛道，下面给大家推荐一些非常不错的Python入门到精通的书籍。
Python cookbook
Cookbook 这本书几乎是每个学Python的人都应该囤的一本书，里面总结了大量的精妙招式和非常赞的技巧，无论是python新手还是python老鸟都应该精彩翻阅的一本书，豆瓣9.2分，名至实归！
Python3高级教程
这本书讲了很多Python哲学，并且回顾了Python的一些核心指导原则，这些指导原则将在本书后面的各种概念和示例中加以说明。本书的前半部分探讨了函数、类、协议和字符串的各个方面，并介绍了一些可能不是常识的技术，它们共同为你构筑坚实的Python编程基础。本书的后半部分涵盖了文档、测试和应用的发布。
流畅的Python
这本也是Python界评分非常高的一本书，跟cookbook是比较齐名的一本书。作者是一位Python大牛，有20多年的Python开发经验，里面把很多python进阶要了解的知识点全部都非常详细的一一列举了，比如元编程，动态属性，属性描述符，比如异步的处理等等这些高级特效讲解的非常透彻。如果你从入门提高到进阶，这本书是必须要囤的。
Python编程从入门到实践
这是一本非常不错的Python入门书。全书分两部分：第一部分介绍用Python编程所必须了解的基本概念，包括Matplotlib等强大的Python库和工具，以及列表、字典、if语句、类、文件与异常、代码测试等内容；第二部分将理论付诸实践，讲解如何开发三个项目，包括简单的2D游戏、利用数据生成交互式的信息图以及创建和定制简单的Web应用，是一本可可甜可盐的书籍，有理论基础也有实战案例。
明解Python
这本书最大的特点是，图文并貌，示例非常非常丰富，全文有299段代码和165张图片，全面、系统地讲解了Python的基础语法和编程知识，内容涉及分支/循环语句、对象、字符串、列表、集合、函数、类、模块、异常处理和文件处理等，比较适合初学者。
Python编程宝典100个关键技能
本书最大的特点就是"实战", 非常贴进实战，里面有100个实战的案例，很多都是有视频讲解的，而且还有大量的Python的面试题目精选，以及针对的100个习题；如果你想短时间内上手python，然后准备面试，可以看看这本书。
Python工匠
Python工匠这本书跟上面的不太一样，它的作者是一位前腾讯的工程师，这本书非常接底气，里面写的很多技巧和经验总结都是作者在平时的工作或者项目实战中遇到的，非常实用，写法也提出老道，适合希望从青铜升到王者的同学。
Python一行流
以前都知道Python是一个技巧性非常高的编程语言，但是看了这本书之后才知道原来技巧性可以这么高，这本书的作者把很多代码都变成了一行，非常简洁，虽然有一些有哗众取宠的感觉，但是帮助你了解python的特性以及一些不错的功能还是非常不错的，尤其是关键的时候可以装逼一把，把别人10几行的代码一行搞定，适合进阶的同学阅读。
Python编程快速上手，让繁琐的工作自动化
很多学Python的同学，学着学着就从入门到放弃，有一个非常大的原因就是因为他平时工作中用不到Python，所有很容易学着前面忘记了后面，导致学1-2月之后还是没有啥进展，原因就是不经常练习。
这本书非常不错的把很多日常的自动化的工作用Python完成，比如excel，pdf, word ,csv 文件的处理， 定时任务，发送邮件，短信，操作图像等等，非常接地气，如果自学能力不强的，可以通过这样实用的小例子入门。
以上就是我推荐的几本不错的Python书籍，希望对大家有所帮助。
如何获取这些书籍：
添加上方即可获取
🎁福利🎁 全网最全《Python学习资料》免费赠送🆓！
最近火热ChatGPT 等人工智能应用对 Python 编程语言产生了积极的影响，它推动了 Python 的普及和发展，在文本处理和 NLP 领域提升了 Python 的地位，促进了 Python 生态系统的成长
学好 Python 不论是就业还是做副业赚钱都不错，但要学会 Python 还是要有一个学习规划。最后大家分享一份全套的 Python 学习资料，给那些想学习 Python 的小伙伴们一点帮助！
一、Python学习路线 二、Python基础学习 1. 开发工具 2. 学习笔记 3. 学习视频 三、Python小白必备手册 四、数据分析全套资源 五、Python面试集锦 1. 面试资料 2. 简历模板 ​ 因篇幅有限，仅展示部分资料，添加上方即可获取
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8815ea77a1b3a37100c073d4a69e45ce/" rel="bookmark">
			route命令详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		route命令简介
route命令是Linux系统中的一个网络管理工具，用于显示和操作IP路由表。它可以用来查看当前系统的路由表信息，添加、删除或修改路由表项，以及显示路由表中的详细信息。route命令可以帮助用户诊断和解决网络连接问题，以及进行网络规划和优化。
查看route版本
route命令也属于net-tools工具集中的命令，如果linux系统没有此命令，我们可以通过安装net-tools软件包来安装此命令。
[root@s152 ~]# yum install -y net-tools [root@s152 ~]# route --version net-tools 2.10-alpha +NEW_ADDRT +RTF_IRTT +RTF_REJECT +I18N +SELINUX AF: (inet) +UNIX +INET +INET6 +IPX +AX25 +NETROM +X25 +ATALK +ECONET +ROSE -BLUETOOTH HW: +ETHER +ARC +SLIP +PPP +TUNNEL -TR +AX25 +NETROM +X25 +FR +ROSE +ASH +SIT +FDDI +HIPPI +HDLC/LAPB +EUI64 yum install -y net-tools
route --version
route-n 使用-n参数查看路由明细，当然不用参数也可以查看，-n表示不解析主机名。
使用add参数添加路由，可以添加一个网段也可以添加一个主机路由。
route add -net 192.168.122.0/24 gw 192.168.0.166
route add -net 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8815ea77a1b3a37100c073d4a69e45ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bedc332c123e3883728cf2e9e661e3b/" rel="bookmark">
			软件测评中心▏性能测试之压力测试、负载测试的区别和联系简析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在如今的信息时代，软件已经成为人们日常工作和生活不可或缺的一部分。然而，随着软件的发展和应用范围的不断扩大，软件性能的优劣也成为了影响用户使用体验的重要因素。
软件性能测试即对软件在不同条件下的性能进行评估和验证的过程。通过模拟多种真实场景和负荷，检验和评估软件在各种条件下的运行情况，以保证软件的稳定性和性能达到预期目标，压力测试和负载测试都属于性能测试，那么这两者之间有什么区别和联系呢?
1、区别：
a.测试目的不同：压力测试的目的是评估软件在超负荷情况下的性能，而负载测试的目的是评估软件在正常工作负荷下的性能。
b.测试条件不同：压力测试通过模拟超负荷情况，使得系统超过正常工作状态;负载测试则通过模拟正常工作负荷，真实模拟用户的使用情况。
c.测试结果不同：压力测试主要关注系统的极限承载能力以及性能瓶颈，而负载测试主要关注软件的性能指标和响应时间。
2、联系：
a.都是评估软件性能的重要手段，可以提供性能方面的数据和指标。
b.两者的测试方法和过程都需要科学的规划和设计。
通过对软件性能的评估，都可以为软件的性能优化提供依据和方向。综上所述，软件性能测试是保证软件质量的重要手段之一。通过科学、系统地进行性能测试，可以为软件的开发和优化提供有效的指导和依据。卓码软件测评专注于软件测试领域多年，具备CMA、CNAS双重认证资质，拥有丰富的测试经验和先进的测试工具，可提供准确、可靠的测试服务，提升软件的质量和用户体验。
文章来源：软件测评中心▏性能测试之压力测试、负载测试的区别和联系简析—卓码软件测评
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7be734c62040c33c63ecf06481b48037/" rel="bookmark">
			Base64编码：数据传输的安全使者
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Base64编码是一种将二进制数据转换为可传输的文本表示形式的方法，它在全球范围内被广泛应用于网络通信、数据存储和传输等领域。本文将从多个方面介绍Base64编码的原理、应用及其在现实场景中的优势，帮助您深入了解这一重要的编码技术。
Base64编码解码 | 一个覆盖广泛主题工具的高效在线平台(amd794.com)
https://amd794.com/base64encordec
一、Base64编码简介
Base64的概念：Base64编码是一种将二进制数据转换为ASCII字符的编码方式，它起源于1960年代的美国军方通信系统，如今已成为网络通信领域的标准编码方法。Base64的起源：Base64编码最早用于电子邮件协议，以便将二进制文件附件转换为可传输的文本格式。随后，它在网络通信、数据存储等多个领域得到广泛应用。 二、Base64编码的原理
编码过程：Base64编码将二进制数据按8位一组进行划分，对每一组二进制数据进行转换，得到一个由ASCII字符组成的字符串。编码规则：Base64编码采用固定的编码表，将二进制数据映射为ASCII字符。编码表中包含24个字符，包括数字、大写字母和小写字母。解码过程：在接收端，将Base64编码的文本重新转换为二进制数据，从而实现原始数据的还原。 三、Base64编码的优势
传输安全性：Base64编码将二进制数据转换为文本格式，降低了数据在传输过程中的风险，有助于防止数据被篡改。跨平台兼容性：Base64编码的文本形式可在不同操作系统、编程语言和网络协议中通用，便于数据的交换和处理。适用于不同场景：Base64编码可用于网络通信、数据存储、电子邮件等多种场景，满足各种应用需求。 四、Base64编码的应用场景
网络通信：在HTTP、HTTPS等网络协议中，Base64编码用于传输加密后的密码、证书等敏感数据。数据存储：在数据库、文件系统等数据存储场景中，Base64编码可用于存储二进制数据，如图片、音频等。电子邮件：在电子邮件协议中，Base64编码用于传输附件、签名等二进制数据。 五、Base64编码在我国的应用
网络安全：在我国的网络安全领域，Base64编码被广泛应用于加密通信、数据传输等场景，保障信息安全。数据存储与传输：许多国内外的软件产品和系统平台采用Base64编码，实现数据的存储和传输。 六、Base64编码的未来与发展
高效压缩：随着数据量的不断增长，未来可能会出现更高效、更紧凑的Base64编码方式，以满足更高的传输需求。加密技术的融合：为了提高数据传输的安全性，Base64编码可能与加密算法相结合，提供更强的安全保障。 总结
Base64编码作为一种广泛应用于网络通信和数据存储的编码技术，实现了二进制数据与文本数据的相互转换，保障了数据的安全传输。了解Base64编码的原理、优势及应用，有助于我们更好地利用这一技术，提升数据传输的安全性和兼容性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39d629d6520526138bb30cc24cc6663e/" rel="bookmark">
			tcp的三次握手
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 http 和 https 都是是基于 TCP 的请求，https 是 http 加上 tls 连接。TCP 是面向连接的协议。
对于 http1.1 协议chrome 限制在同一个域名下最多可以建立 6 个 tcp 连接，所以如果在同一个域名下，同时有超过 6 个请求发生，那么多余的会进入排队等待状态，直到有请求完成，当前总请求数小于 6 就会建立tcp连接
http2 实现了多路复用，所有就不存在只能同时有 6 的 tcp 链接的限制了，对于 http1.1 和 http2 的区别，请参考这篇文章，http1.0、http1.1、http2、http3 的区别详解-CSDN博客
浏览器的网络进程发起网络请求的第一步就是建立 TCP 连接了，这是个老生常谈的面试题，关于 TCP 的三次握手和断开连接的四次挥手。
这个三次握手背了那么多次都记不住？很难吗，其实就是3个请求而已，超级简单的啊，其中2个请求是客户端发起的，一个是服务端发起的，加起来一共3个，毫无难度的，而为 tcp 连接是浏览器发起的，也就是客户端发起的，所以客户端发起的请求肯定比服务端的多一个。
其实我们需要背诵的重点就是3个缩写单词，一个是SYN 同步标志，一个应答信号ACK，还有一个是 ISN 初始序列号，客户端和服务端都分别发送了同步标志和应答序列号
第一次握手（SYN）：
客户端向服务器发送一个带有 SYN（同步）标志的数据包，表示请求建立连接。客户端选择一个初始的序列号（ISN，Initial Sequence Number），并指定一些连接参数（如最大报文段大小）。状态变化：客户端进入 SYN-SENT 状态，等待服务器的响应。【已发送状态】 第二次握手（SYN + ACK）：
服务器接收到客户端的 SYN 请求后，向客户端回送一个带有 SYN 和 ACK（确认）标志的数据包，表示同意建立连接。服务器也选择一个自己的初始序列号，并确认客户端的 ISN。服务器还可以在这个阶段发送一些连接参数。状态变化：服务器进入 SYN-RECEIVED 状态。【已接受状态】 第三次握手（ACK）：
客户端接收到服务器的 SYN + ACK 响应后，向服务器发送一个带有 ACK 标志的数据包，表示已经收到服务器的确认。状态变化：客户端进入 ESTABLISHED 状态，服务器也进入 ESTABLISHED 状态。【已建立连接状态】此时，双方都已确认对方的能力，并可以开始进行数据传输。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/715c707a97dcfc8afa099532091abadc/" rel="bookmark">
			C语言经典练习1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在学习C语言知识的过程中刷题是很重要的，俗话说眼看千遍不如手动一遍因为在真正动手去刷题的时候会暴露出更多你没有意识到的问题接下来我就为各位奉上几道我认为比较有代表性的题 1.分支控制——计算一元二次方程 1.1题目描述 从键盘输入a, b, c 的值，编程计算并输出一元二次方程 ax2 + bx + c = 0 的根，当 a = 0 时，输出**“Not quadratic equation”**，当 a ≠ 0 时，根据 △ = b2 - 4ac 的三种情况计算并输出方程的根 1.2输入描述 多组输入，一行，包含三个浮点数 a, b, c，以一个空格分隔，表示一元二次方程 ax2 + bx + c = 0 的系数。 1.3输出描述 针对每组输入，输出一行，输出一元二次方程 ax2 + bx +c = 0 的根的情况。如果 a = 0 ，输出 “Not quadratic equation”；如果 a ≠ 0 ，分三种情况：
△ = 0，则两个实根相等，输出形式为：x1=x2=…。
△ &gt; 0，则两个实根不等，输出形式为：x1=…;x2=…，其中x1 &lt;= x2。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/715c707a97dcfc8afa099532091abadc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e95878eb6720cede00418d3c0c372c95/" rel="bookmark">
			网络的设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、网络设置 1.1查看linux基础的网络设置 网关 route -n
ip地址ifconfigDNS服务器cat /etc/resolv.conf主机名hostname路由 route -n
网络连接状态ss 或者 netstat域名解析nslookup host 例题：除了ping，什么命令可以测试DNS服务器来解析服务器？
nslooup 1.2ifconfig命令 默认显示活动的网卡ifconfig显示所有的网卡ifconfig -a只显示前面的网卡信息ifconfig 网卡名称关闭网卡ifconfig 网卡 down开启网卡ifconfig 网卡 up设置虚拟网卡ifconfig ens33:0 IP地址/子网掩码 ens33：以太网，插槽在33口
mtu 1500：最大传输单元，1500字节
1.3主机名 hostname查看主机名hostname主机名临时修改主机名hostnamectl set-hostname主机名永久修改主机名vim /etc/hostname将名字写入文件也是永久修改，写在第一行才行 1.4路由表 route -n显示路由表 -n：数字形式显示路由表route add -net 10.0.0.0/8 gw 172.16.18.4添加一条去往10.0.0.0段的路由，通过网关172.16.18.4转发route del -net 10.0.0.0/8删除去往10.0.0.0段的路由route add -net 0.0.0.0(或者default) gw 172.16.18.4添加默认路由route del -net 0.0.0.0(或者default)删除默认路由 ss：更靠近内核
ss -natp n ：数字 a：详细 t：tcp u：udp p：进程
netstat：靠近用户，他要去遍历 文件查看状态
1.5DNS域名解析 dns：域名解析：将域名翻译成IP地址，然后封装数据包
1.怎么验证dns服务器，是否可以解析域名？
nalookup
dig
host
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e95878eb6720cede00418d3c0c372c95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fbed15e7989655d3cbd123ae5bdaf77/" rel="bookmark">
			shell 判断变量是否为0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		tree_version="tree-1.7.0" tree_install_count=$(rpm -qa | grep -i ${tree_version} | wc -l) 查看已经安装 tree-1.7.0 版本的数量 写法 1 if [ "${tree_install_count}" -eq 0 ]; then echo "tree-1.7.0 not exist." else echo "tree-1.7.0 count = ${tree_install_count}." fi 写法 2 if [ "${tree_install_count}" == "0" ]; then echo "tree-1.7.0 not exist." else echo "tree-1.7.0 count = ${tree_install_count}." fi [Ref] shell中判断一个变量是否为0或者为某个具体的值
整数比较 -eq 等于 -ne 不等于 -gt 大于 -ge 大于等于 -lt 小于 -le 小于等于 &lt; &gt; &lt;= &gt;= 都需要使用双括号 [Ref] shell 判断命令是否执行成功 if [ $?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fbed15e7989655d3cbd123ae5bdaf77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae85818bc6da4a08c4fa4f52d068924c/" rel="bookmark">
			微信小程序开发WebSocket通讯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方文档说明：入口
WebSocket连接的链接只支持wss加密方式，且只能用域名的方式
该域名还要在微信公众平台的小程序中登记才能使用，开发-&gt;开发管理-&gt;服务器域名-&gt;修改
该域名要和https使用的一致
以域名地址：dtu.aabbcc.cn为例
nodejs搭建WebSocket服务器 无需传入服务器地址，底层会自动映射到公网ip
const WebSocket = require('ws'); const server = new WebSocket.Server({ port: 3000 }); consoles.log('WebSocket服务器已启动'); // 当有客户端连接时，监听其消息 server.on('connection', (client) =&gt; { consoles.log('有客户端连接：', client._socket.remoteAddress); // 收到客户端消息 client.on('message', (data) =&gt; { try { const decoder = new TextDecoder(); const text = decoder.decode(data); message = JSON.parse(text); consoles.log('收到客户端消息：', message); } catch (error) { consoles.log('wss message error', error) } }); // 当客户端断开连接时，从客户端映射关系中删除 client.on('close', () =&gt; { consoles.log('客户端断开连接：', client._socket.remoteAddress); clientsInforList.delete(client); }); }); WebSocket默认是不带加密传输的，接下来可以通过代理服务器配置路由进行加密传输，即ws变成wss。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae85818bc6da4a08c4fa4f52d068924c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80bf80a14d002007b6dc7079cc6098e0/" rel="bookmark">
			软件安全测评需要关注哪些?湖南CMA、CNAS软件测试公司推荐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在当今信息化的社会，软件安全问题日益凸显，给个人和企业的数据安全造成了极大的威胁。为了保障软件的安全性，软件安全测评应运而生。
软件安全测评是通过对软件系统的评估，发现其中存在的安全漏洞和风险，为软件的开发和使用提供安全保障的过程。在软件安全测评中，会通过对软件系统进行全面的扫描和测试，包括对系统结构、代码、数据传输和用户权限等方面进行细致的检查，从而从技术和管理两个层面来评估软件的安全性。
针对软件安全测评，需要关注的要点主要包括以下几个方面：
1、系统架构和设计的安全性：通过对系统架构和设计的评估，发现其中存在的漏洞和薄弱点，为后续的测试提供依据。
2、代码安全性：对软件代码进行静态分析和动态测试，发现其中的安全漏洞和风险，如缓冲区溢出、SQL注入等。
3、数据传输的安全性：对软件系统中的数据传输进行检查，保证数据在传输过程中的机密性和完整性。
4、用户权限管理：评估软件系统对用户权限的管理是否合理，防止未授权用户进行非法操作。
卓码软件测评，一家独立靠谱的专业软件测试公司，获得权威的CMA、CNAS资质认证。测试团队经验丰富、技术成熟，拥有先进一流的软件测试环境和测试平台，各类软件测试类型全国范围线上线下均可服务，出具的软件测试报告具备法律效力。
文章来源：软件安全测评需要关注哪些?湖南CMA、CNAS软件测试公司推荐—卓码软件测评
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc737161067c81666d01cdb63ad55335/" rel="bookmark">
			科技成果鉴定测试的意义在哪?鉴定测试报告重要吗?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		科技成果鉴定测试是指通过一系列的评估和验证过程，对科技成果所包含的技术特征、技术优势以及市场应用前景进行客观、准确的评估和证明的过程。科技成果鉴定测试可以对科技项目进行全面、系统的评估，从而找出项目的优势和不足之处，并为项目的改进和优化提供依据。
一、科技成果鉴定测试的意义
1、为科技项目的研发和技术攻关提供切实的指导和支持，有利于提高科技成果的研发水平和技术创新能力。
2、帮助科技企业和科技项目识别和发现潜在的市场机会，为项目的市场推广和商业化运营提供科学依据。
3、提升科技项目的竞争优势，为项目的技术转移和产业升级提供有力支撑。
二、科技鉴定测试报告的重要性
鉴定测试报告是否重要呢?答案是肯定的。
1、鉴定测试报告是对科技成果鉴定测试结果的总结和归纳，具有权威性和可靠性，是科技成果鉴定测试的最终输出。
2、鉴定测试报告能够客观、准确地呈现科技成果的技术特征和市场应用前景，有助于科技项目的宣传推广和合作交流。
3、鉴定测试报告对于科技项目的评价和认可具有重要的参考价值，可以提升项目的信誉和市场竞争力。
卓码软件测评，专业的第三方软件测试机构，具备CMA、CNAS双重资格认证,各类测试类型全国范围内皆可服务，有着经验丰富的团队，成熟的技术，出具的测试报告公正权威具备法律效力。
文章来源：科技成果鉴定测试的意义在哪?鉴定测试报告重要吗?—卓码软件测评
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/22/">«</a>
	<span class="pagination__item pagination__item--current">23/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/24/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>