<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a1fda1bd9103cf66ff5fb4e1603d32f/" rel="bookmark">
			cookie，sessionStorage，localStorage与浏览器新开窗口window.open的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		window.open是用JavaScript打开一个新的浏览器的窗口的函数，而cookie，sessionStorage，localStorage是三种常用的浏览器存储数据的方式，在开发时经常会用到。这里不谈cookie，sessionStorage，localStorage三种的联系和区别，只看一下三种在window.open打开窗口时发生的现象。
1. 第一次window.open全部传输成功 首先，我们手动打开第一个窗口，访问本地服务器，例如http://127.0.0.1:7001/。并赋值三项：
document.cookie = 'cookieA=1;path=/;' + document.cookie sessionStorage.sessionA = '2' localStorage.localA = '3' 测试赋值是否成功：
console.log(document.cookie) console.log(sessionStorage.sessionA) console.log(localStorage.localA) 打开一个新浏览器窗口，url相同，测试值是否被传过去了：
let windowName = 'qazwsxedc' window.open('http://127.0.0.1:7001', windowName) 可以看到，全部的值都被传输到了新窗口。
从第一个窗口再打开第三个浏览器窗口，url相同，但是窗口名称windowName不同，经过测试也成功传输了。从第二个窗口再打开第四个窗口，url相同，窗口名称windowName不同，经过测试也成功传输了。
2.重复打开同一个浏览器窗口，sessionStorage没有传输 第一步，设置数值，打开第二个窗口。
document.cookie = 'cookieA=1;path=/;' + document.cookie sessionStorage.sessionA = '2' localStorage.localA = '3' let windowName = 'qazwsxedc' window.open('http://127.0.0.1:7001', windowName) 此时数值是全部传输成功的。
第二步，对第一个窗口设置新的值：
document.cookie = 'cookieA=4;path=/;' + document.cookie sessionStorage.sessionA = '5' localStorage.localA = '6' 测试第二个窗口，已经产生变化了，除了sessionStorage都变为了新值。也就是说这些值是浏览器共享的（在同一域下）：
第三步，此时重新打开第二个窗口，windowName不变，然后测试：
window.open('http://127.0.0.1:7001', windowName) 结果与上面相同，sessionStorage并无发生变化。
猜测是因为第一个窗口与第二个窗口现在是两个会话，刚才相当于刷新操作，不影响sessionStorage。
3.关闭并打开同一个浏览器窗口，sessionStorage成功传输 那么，应该如何把第一个窗口的sessionStorage传输到第二个窗口？
第一步，设置数值，打开第二个窗口。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a1fda1bd9103cf66ff5fb4e1603d32f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b48e3bafc6bbe9b1ca12b40e513943bf/" rel="bookmark">
			汇编笔记： 源码 补码 反码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 补码： -8的补码是：11111000，因为-8超出了4位二进制所能表达的范围，所以必须要用8位二进制表示。
负整数的补码计算是将其原码除符号位外的所有位取反后加1，-8补码的计算过程是：-8对应正数8（00001000）→所有位取反（11110111）→加1(11111000)。
-126的补码：
126的补码为 0111 1110， 给他取反，1000 0001， 再加1
就是 1000 0010
即：|x|补 &lt;–求补—&gt; |-x|补
注：1. [x + y]补 = [x]补 + [y]补
注：2. [x + y]补 = [x]补 + [-y]补
二. 数的范围 无符号数： 8位（0~255） 16位（0~65535）有符号位：8位（-128~127） 16位（-32768~32768） 注（由补码推原来的数）：1000 0000是-128，而1111 1111是-1
我们可以这样算，第一位是符号位，将后面的7位二进制转为十进制，然后用128减去，再加符号位
比如1111 1111，7位二进制111 1111是127，128-127=1，所以就是-1
比如1000 0001，7位二进制是000 0001，就是1，128-1=127，就是-127
三. 浮点数在计算机中的储存 27.5的二进制为11011.1
1.10111*2^4
尾数（小数点后的数）10111，补够23位 1011 1000 0000 0000 0000 000
指数：4，加上127，就是131，二进制1000 0011
用二进制表示就是 (符号数位1位)0 （指数位8位）1000 0011 （尾数位23位）1011 1000 0000 0000 0000 000
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b48e3bafc6bbe9b1ca12b40e513943bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e0162eff5e5d645fd1ad55c8f93eb93/" rel="bookmark">
			从键盘输入三个数到a,b,c中，按公式值输出 (30 分) 在同一行依次输入三个值a,b,c，用空格分开，输出 b*b-4*a*c的值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 第1章-2 从键盘输入三个数到a,b,c中，按公式值输出 (30 分)
在同一行依次输入三个值a,b,c，用空格分开，输出 bb-4a*c的值
输入格式:
在一行中输入三个数。
输出格式:
在一行中输出公式值。
输入样例:
在这里给出一组输入。例如：
3 4 5
输出样例:
在这里给出相应的输出。例如：
-44
a,b,c=map(int,input().split()) #map( T,input().split() ) T为类型，split()使得能以空格隔开输入 print(b*b-4*a*c) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e4ff5c358da7e20bf1128d9dcba4498/" rel="bookmark">
			zlib 通过CMake与VS2017编译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ZLIB是一个数据压缩库。
一、下载并解压 zlib 下载地址：https://www.zlib.net/
二、CMake构建 （1）设置路径
源码路径：F:\zlib-1.2.11
Build路径：F:\zlib-1.2.11build
（2）选择VS2017、x64
（3）依次单击Finish、Configure
（4）注：笔者默认的install地址，在install时会报错，因此将install地址修改为F:/zlib。如下图所示。
（5）依次单击Configure、Generate。Configure done和Generate done之后即为构建成功。
三、VS2017编译 （1）右击ALL_BUILD，生成。成功6个，失败0个，跳过0个，即为成功。
（2）运行example，如下图则为成功。
（3）右击INSTALL，生成。在F:/zlib中生成了库。
四、资源 zlib的VS2017-Release和RelWithDebInfo库
链接：https://pan.baidu.com/s/1oRz4PHrmUOxFy2Vr3PaNmw
提取码：2q2i 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a715e8b41bbd83c288fcb5a02e2c65db/" rel="bookmark">
			Mysql时间段查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		– 查询昨日一整天的数据
SELECT DATE_FORMAT(DATE_SUB(NOW(),INTERVAL 1 DAY) ,’%Y-%m-%d 00:00:00’) AS ‘昨日开始时间’ ,DATE_FORMAT(DATE_SUB(NOW(),INTERVAL 1 DAY) ,’%Y-%m-%d 23:59:59’) AS ‘昨日结束时间’
– 查询今日开始到当前时间的数据
SELECT DATE_FORMAT(DATE_SUB(NOW(),INTERVAL 0 DAY) ,’%Y-%m-%d 00:00:00’) AS ‘今日开始时间’ ,DATE_FORMAT(DATE_SUB(NOW(),INTERVAL 0 DAY) ,’%Y-%m-%d %H:%i:%s’) AS ‘今日当前时间’
– 查询上月一整个月的数据
SELECT DATE_FORMAT(DATE_SUB(NOW(),INTERVAL 1 MONTH) ,’%Y-%m-01 00:00:00’) AS ‘上个月开始时间’ ,
date_sub(date_sub(date_format(now(),’%Y-%m-%d 23:59:59’),interval extract( day from now()) day),interval 0 month) AS ‘上个月结束时间’
– 查询本月开始到当前时间的数据
SELECT DATE_FORMAT(DATE_SUB(NOW(),INTERVAL 0 MONTH) ,’%Y-%m-01 00:00:00’) AS ‘本月开始时间’ ,DATE_FORMAT(DATE_SUB(NOW(),INTERVAL 0 DAY) ,’%Y-%m-%d %H:%i:%s’) AS ‘本月当前时间’
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a715e8b41bbd83c288fcb5a02e2c65db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b107bd98eb2cff4fb6e0354745e83424/" rel="bookmark">
			MySQL5.7忘记root密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、先关闭 mysql 服务，打开 mysql 的配置文件 ubuntu下是 /etc/mysql/mysql.conf.d/mysqld.cnf
window下是mysql目录下的 my.ini
二、在 [mysqld] 块下加上跳过验证的配置 skip-grant-tables 启动 mysql 服务后，直接使用 root 登陆，不用密码
三、修改root密码 alter user root@localhost identified with maysql_native_password by '123456'; 如果提示：
The MySQL server is running with the --skip-grant-tables option so it cannot execute this statement 那就先执行：
flush privileges; 之后再执行修改密码的操作就不会出错了
四、将配置文件中跳过认证的配置项去掉，用密码登陆 关闭 mysql 服务，然后删掉刚刚在配置文件加上的 skip-grant-tables，再重启 mysql 服务，使用新密码登陆root
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ef7ee6cfd18018be6dba9ae601805be/" rel="bookmark">
			如何分析sql执行效率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何定位慢查询和如何分析 SQl 执行效率 1 定位慢 SQL 在开发中，经常会遇到一个接口返回数据的等待时间过长，这时候我们就需要查看是否因为慢sql导致， 定位慢 SQL 有如下两种解决方案： 1.查看慢查询日志确定已经执行完的慢查询
2.show processlist 查看正在执行的慢查询
下面我就介绍如何使用以及两者的使用场景：
1.1 通过慢查询日志 定位慢查询sql，一般的方法是通过慢查询日志来查询的，MySQL 的慢查询日志一般记录在 MySQL 中响应时间超过参数 long_query_time（单位秒，默认值 10）设置的值并且扫描记录数不小于 min_examined_row_limit（默认值0）的语句，通过查看这个日志能够帮我们找到执行完的慢查询，方便我们对这些 SQL 进行优化。
默认环境下，慢查询日志是关闭的。
1.首先开启慢查询日志
set global slow_query_log = on;
2.设置慢查询时间阀值
set global long_query_time = 1;（这里的单位是秒，我这里设置的是1秒）
3.确定慢查询日志路径
show global variables like “datadir”;
4.确定慢查询日志的文件名
show global variables like “slow_query_log_file”;
然后根据文件路径直接用tail命令查看日志就行了，如果大家觉得看系统日志不方便，也可以通过pt-query-digest 或者 mysqldumpslow 等工具对慢查询日志进行分析。
1.2 通过 show processlist; 有时候慢sql可能执行时间比较长，或者正在执行中，这时候如果想查慢sql，日志里是还没有记录的，这时候我们可以用show processlist来查看执行中的慢sql
show processlist;
Time：表示执行时间
Info：表示 SQL 语句
2 使用 explain 分析慢查询 这个网上有太多的优秀博文，这里我推荐一篇，大家可以直接去该博文了解详情
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ef7ee6cfd18018be6dba9ae601805be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98877bb4df928ff247309d01ae65a1d4/" rel="bookmark">
			QT 知：官方文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 前言2. 官方文档2.1. Qt Documentation | Home2.1.1. DOWNLOAD QT2.1.2. Framework2.1.3. Get started2.1.4. Tools2.1.5. External resources 2.2. Qt Reference Pages2.3. qmake Manual2.3.1. qmake Language2.3.2. Variables2.3.3. Test Functions2.3.4. Replace Functions 3. 非官方文档3.1. QT中文文档 4. 后语 1. 前言 每次上网搜索QT知识点的时候，都会蹦出来很多别人写的文章/博客，这些文章可能会有下面问题：
内容已经不是最新的官方资料内容不一定正确，可能带有作者个人主观理解内容逻辑混乱，总结不到位内容不全面，让你知其然而不知其所以然内容鱼龙混杂，无法准确的筛选出想要的内容…… 本文整理搜集QT官方的文档（以qt-6为例，可以自行切换到qt-5），让读者可以迅速获取最新最官方的资料，而不用再去互联网中捞鱼。
建议开发者一定要读官方文档，那样你可以了解更全面，更深入。
2. 官方文档 2.1. Qt Documentation | Home Qt 文档 | 主页：https://doc.qt.io/
2.1.1. DOWNLOAD QT 右上角 DOWNLOAD QT 可以进行QT下载，不过需要注册帐号。目前新版本（5.15开始）的QT不再支持离线镜像安装；在线安装时，是需要填写帐号信息的，所以这里建议注册一下。
QT官方下载镜像网站：https://download.qt.io/清华大学开源软件镜像网站：https://mirrors.tuna.tsinghua.edu.cn/ 另外，下载页面可以了解不同版本的QT和工具的发布简讯。
2.1.2. Framework 这里实际上是介绍QT的不同模块，可以选择不同的模块进行专项查询/学习。
2.1.3. Get started 这里告诉用户，该怎样开始用QT进行开发，第一条就是注册账户，这个看来很关键。
2.1.4. Tools 这里介绍了QT的所有开发工具，比如：Qt Creator、Qt Desinger、Qt Assistant等。这里的“等”其实是我没有使用过的工具，如果有需要学习，来这里就好了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98877bb4df928ff247309d01ae65a1d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df619842589df997949605c4d046b324/" rel="bookmark">
			dmhs关于dm到mysql的搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.环境准备
（1）操作系统的用户权限
启动dmhs服务的操作系统用户最好是数据库的安装用户如果不能用数据库的安装用户，那么创建的dmhs服务用户必须要和数据库的安装用户在同一用户组中。
（2）硬件需求
内存需求
DMHS 需要的内存总量取决于分析线程以及执行线程的并发数，最少需要 1G 内存。
磁盘需求
DMHS 安装文件占用 277M，包括了管理工具以及管理界面占用的空间，另外需要一些额外的空间存储 DMHS 运行的日志文件。
（3）操作系统需求
Linux 系列操作系统
各种主流的 Linux 操作系统（如 Redhat、 Kylin）。
（4）网络需求
dm到mysql网络互通，端口可以访问。
（5）设置mysql本地链接
DMHS在运行时，需要加载本地MYSQL 动态库，linux/unix平台下为libmysqlclient.so。在部署DMHS 之前，需将libmysqlclient.so所在目录添加到共享库路径变量中。libmysqlclient.so通常位于/usr/local/mysql/lib目录中中。在LINUX/UNIX系统中，设置的方法如下：
vi ~/.bahs_profile
操作系统类型
设置命令
IBM AIX
export LIBPATH=$LIBPATH: /usr/local/mysql/lib
HP UX
export SHLIB_PATH=$ SHLIB_PATH: /usr/local/mysql/lib
其他LINUX/UNIX
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH: /usr/local/mysql/lib
source ~/.bash_profile
(6) UNIXODBC安装
Mysql作为目的端，需要通过ODBC将源端数据库的操作同步到目的数据库，所以部署DMHS MYSQL 目的端的服务器，需要安装ODBC驱动及MYSQL ODBC。
推荐安装unixodbc2.3.2版本的odbc，下面介绍如何使用源码安装unixidbc。
下载unixodbc2.3.2源码unixODBC-2.3.2.tar.gz。
解压unixodbc源码
tar -zxvf unixODBC-2.3.2.tar.gz
进入unixodbc源码目录，编译源码
cd unixodbc-2.3.2
export CC=gcc
./configure --enable-drivers=no --with-iconv-char-enc=GB18030 --enable-gui=no --enable-iconv=yes
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df619842589df997949605c4d046b324/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11af28a977cc53531f1b6670d78efe88/" rel="bookmark">
			java中==和equals的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个问题是java中的最基础的问题，但是有些童鞋还是理解的有误差。
有些认为的是：
1. ==比较的是堆中存储对象的地址 （true）
2. equals比较的值是否相等 （不准确）
equals有些人理解的还是有误解，equals是Object类中的方法，方法如下：
public boolean equals(Object var1) { return this == var1; } 可以看到Object内的equals方法的实现其实就是使用==进行判断。
很多人对这两个的理解应该是起源于字符串比较，那么字符串的equals方法为什么能比较值是否相等呢，是因为String类重写了equals方法，方法如下：
public boolean equals(Object var1) { if (this == var1) { return true; } else { if (var1 instanceof String) { String var2 = (String)var1; int var3 = this.value.length; if (var3 == var2.value.length) { char[] var4 = this.value; char[] var5 = var2.value; for(int var6 = 0; var3-- != 0; ++var6) { if (var4[var6] !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11af28a977cc53531f1b6670d78efe88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0242810388ace3bd426fae5909fe9c41/" rel="bookmark">
			阿里巴巴_基础平台研发工程师_一面面试经历（电话面试）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		约好的周日晚上7：00的面试，面试官准时打来了电话。
（简单寒暄之后）
Q：那你简单来做个自我介绍吧。
Q：询问考研意向、是否考虑过加入阿里、毕业时间（闲谈）
Q：你做的项目偏向于什么语言？(C++)
Q：C++的熟悉程度是什么样子的？
Q：C++的内存结构，也就是由类派生出一个对象的内存结构是什么样的？
Q：一个方法派生的新类的话，会如何占用内存空间？
Q：在linux系统中，用C++读取一个文件，整体的过程是什么样子的？（主要问的是系统的内核态和用户态如何变化）
Q：具体项目的具体功能是什么样的？
Q：数据存储用的是什么技术？
Q：数据算法部分大概是怎么实现的？
Q：算法的难点在哪里？
Q：你的期望工作内容是什么样子的？
Q：你觉得你的项目经历中有什么比较不错的项目，能拿来说说吗？
Q：项目主要用的技术是什么样子的？
Q：现在的前端都是Node.js，你用过Node.js吗?
Q：现在HTML前端，大部分语言是Node.js，这样的工作情况你拒绝吗？
Q：python用的多吗？
Q：计算机网络这部分你比较熟悉吗？
Q：ARP协议主要是用来干什么的？什么情况下会用到它？
Q：HTTP协议处于计网的哪一层呢？
Q：Endeges这个系统你了解吗?
Q：搭建服务的时候，通过什么手段对外暴露服务？
Q：比如搭建web网站的时候，它的服务器的服务软件是什么呢？
Q：软件系统里面的Inode是干什么用的？
Q：Groot文件系统你了解吗？这个系统主要用来干什么？
Q：OS系统的南北桥是用来干什么呢？
Q：接下来做一个算法题：树的层次遍历（之字形输出，只能用栈、队列等基础结构）
面试总结：
感觉自己大学三年的很多项目经历其实都算比较水的，没有什么实质性的技术内容，而且三年期间接触过的前沿技术比较少，很难对某个技术领域有什么深刻的认识。
同时，自己在基础知识上，也没有形成比较完备的知识体系，只能说自己三年来混吃等死，无所作为吧。唉，大概率面试是凉了。
之后那道简单的算法题还耽误面试官挺长时间的，他还温和地引导我几回，怪对不起人家的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48a3128df159505beee4179b06b0b342/" rel="bookmark">
			vue 子组件修改props方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue是单向数据流，父组件通过props传值给子组件，如果在子组件中修改会报错，一般是不在子组件中修改props的，但偶尔有需要在子组件有修改props,这里介绍三种可以修改子组件props的方法。
1.父组件用sync修饰，子组件通过$emit('update:参数'，值)函数去修改。在项目中通常可以用改方法关闭弹框。 &lt;template&gt; //父组件 &lt;CommonDialog :title="dialogTitle" :showDialog.sync="isShowDialog" :footer="true" :width="dialogWidth" &gt; .... &lt;/CommonDialog&gt; &lt;/template&gt; //子组件 弹框是否打开props: showDialog &lt;el-dialog :title="title" :visible="showDialog" :show-close="false" :width="width"&gt; &lt;i class="el-dialog__headerbtn" @click="closeModal"&gt; &lt;span class="iconfont iconclose"&gt;&lt;/span&gt; &lt;/i&gt; &lt;div class="dialog-body"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div v-if="!footer" slot="footer" class="dialog-footer"&gt; &lt;slot name="footer"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/el-dialog&gt; //关闭弹框------子组件修改props closeModal() { this.$emit("update:showDialog", false); }, 2.如果props是对象，在子组件中修改props &lt;template&gt; &lt;div class="csd-select"&gt; &lt;el-popover placement="bottom" :width="width" :trigger="config.trigger" :config="config" transition="fade-in" popper-class="casade-selector" v-model="options_show" &gt; ... &lt;/el-popover&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: "CasadeSelector", props: { config: { type: Object, //让props默认返回 default() { return {}; } }, }, &lt;/script&gt; 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48a3128df159505beee4179b06b0b342/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffb1a1bdf33f9a2d6c25bb9cdf642cf4/" rel="bookmark">
			cmd下 SecureCRT 串口操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SecureCRT.exe /serial COM5 /baud 38400 /nocts /data 8 /nodsr /parity none /stop 0 /noxon
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c88c3301df5e654b5acd2478d5a5b5c/" rel="bookmark">
			电阻式传感器原理与应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电阻式传感器的基本原理：将被测非电量的变化转变成电阻值的变化，通过测量电阻值达到测量非电量的目的。
电阻应变式传感器由弹性元件、电阻应变片构成。
当弹性元件感受被测物理量时，其表面产生应变，粘贴在弹性元件表面的电阻应变片的电阻值将随着弹性元件的应变而相应变化。
电阻应变片的工作原理是基于金属的应变效应。
金属丝的电阻随着它所受的机械形变（拉伸或压缩）的大小而发生相应变化的现象称为金属的电阻应变效应
通常把单位应变所引起的电阻值相对变化称为电阻丝的灵敏系数K0
K0与金属材料和电阻丝形状有关
K0越大，单位纵向应变所引起的电阻值相对变化越大，说明应变片越灵敏。
金属电阻应变片分为：丝式应变片、箔式应变片和薄膜应变片三种。
箔式电阻应变片是利用照相制板或光刻腐蚀技术。
电阻应变片必须被粘贴在试件或弹性元件上才能工作。
应变片的灵敏系数K恒小于电阻丝的灵敏系数K0，应变片中存在着横向效应。
应变片的横栅部分将纵向丝栅部分的电阻变化抵消了一部分，从而降低了整个电阻应变片的灵敏度
敏感栅的纵栅越窄，越长，横栅越宽，越短，横向效应的影响越小
温度误差及其补偿 由于测量现场环境温度改变而给测量带来的附加误差，称为应变片的温度误差。
产生温度误差的主要因素有：
电阻温度系数的影响试件材料和电阻丝材料的线膨胀系数的影响。 温度补偿的方法：
电桥补偿法应变片自补偿
电桥补偿法的优点是简单、方便，在常温下补偿效果好，其缺点是在温度变化梯度较大的条件下，很难做到工作片与补偿片处于温度完全一致的情况，因而影响补偿效果。 应变片的自补偿法，粘贴在被测位上的是一种特殊应变片，当温度变化时，产生的附加应变为0或相互抵消。——温度自补偿应变片。
选择式自补偿应变片
双金属敏感栅自补偿应变片——组合式自补偿应变片
热敏电阻补偿法
消除非线性误差——半桥差动电路
粘贴应变片时，使两个应变片一个受拉，一个受压，应变符号相反，工作时将两个应变片接入电桥的相邻两臂。
半桥差动电路不仅能消除非线性误差，而且还使电桥的输出灵敏度比单臂工作时提高了一倍，同时还能起温度补偿的作用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69d4d0d676a54787dd1f4ebab4dab12e/" rel="bookmark">
			博弈论1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博弈论 关于博弈论P2197 【模板】nim游戏传送门题目分析Code总结与反思 P2252 [SHOI2002]取石子游戏|【模板】威佐夫博弈传送门题目分析Code总结与反思 P4101 [HEOI2014]人人尽说江南好传送门算法分析Code总结与反思 关于博弈论 可参考以下博客：博弈论基础知识与SG函数
P2197 【模板】nim游戏 传送门 P2197 【模板】nim游戏
题目分析 nim博弈板子题，结论如下：
Code #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; inline int read() { int x = 0, f = 1; char c = getchar(); while (c &gt; '9' || c &lt; '0') {if (c == '-') f = -1; c = getchar();} while (c &gt;= '0' &amp;&amp; c &lt;= '9') {x = x * 10 + c - '0'; c = getchar();} return f * x; } int T; int n,a[10050],f; int main() { T = read(); while (T--) { n = read(); for (int i = 1; i &lt;= n; ++i) a[i] = read(); f = a[1]; for (int i = 2; i &lt;= n; ++i) f = f ^ a[i]; if (f)	printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69d4d0d676a54787dd1f4ebab4dab12e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c98a11d3292a5244a3e4f94989612710/" rel="bookmark">
			如何在word文档贴一手好看的代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、方法一：利用word插件
然后搜索 Easy Code Formatter,下载之后
选择这一个主题，然后再将代码的字体改成Consolas，字号为10,段落设置改成如下形式:
最后的效果就很美~~
二、方法二：直接用syntax在线网页端生成
网址：http://www.planetb.ca/syntax-highlight-word
效果也不错，不过一定要在chrome或者IE打开网址
缺点是由于复制到word中会有序号，所以就不能直接从word的复制代码到编译器
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae593a01705459f8b4a90e231754b2c5/" rel="bookmark">
			[ERROR] : Action client not connected: /follow_joint_trajectory
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ur5真机连接报错
ur5真机连接报错踩坑 运行roslaunch ur5_moveit_config ur5_moveit_planning_execution.launch
报错
[ WARN] : Waiting for /follow_joint_trajectory to come up
[ WARN] : Waiting for /follow_joint_trajectory to come up
[ERROR] : Action client not connected: /follow_joint_trajectory
使用moveit规划真机成功后，点击执行，终端报错
Unable to identify any set of controllers that can actuate the specified joints:
[ERROR] : Known controllers and their joints:
[ERROR] : Apparently trajectory initialization failed
解决办法：
找到/ur_modern_driver/config/ur5_controllers.yaml
最后加入
controller_list: - name: /vel_based_pos_traj_controller #or /pos_based_pos_traj_controller action_ns: follow_joint_trajectory type: FollowJointTrajectory default: true joints: - shoulder_pan_joint - shoulder_lift_joint - elbow_joint - wrist_1_joint - wrist_2_joint - wrist_3_joint 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2ca5d39bb716f169010146830d8e952/" rel="bookmark">
			金融风控评分卡建模全流程！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		↑↑↑关注后"星标"Datawhale
每日干货 &amp; 每月组队学习，不错过
Datawhale干货 作者：桔了个仔，南洋理工大学，数据科学家
知乎丨https://zhuanlan.zhihu.com/p/148102950
本文摘要 本文将带领读者一起进行完整的建模全流程，了解银行风控是如何做的。并提供kaggle代码。首先讲述评分卡的分类、优缺点。接下来，结合完整的可以马上运行的代码，中间穿插理论，来讲解评分卡的开发流程。最后，把方法论再梳理一次，让读者在了解全流程后，在概念上理解再加深。
本文还提供了完整的全流程代码，读者打开https://www.kaggle.com/orange90/credit-scorecard-example，结合代码来读本文，会理解更深。
一、评分卡的分类 在金融风控领域，无人不晓的应该是评分卡（scorecard)， 无论信用卡还是贷款，都有”前中后“三个阶段。根据风控时间点的”前中后”，一般风评分卡可以分为下面三类:
A卡（Application score card）。目的在于预测申请时（申请信用卡、申请贷款）对申请人进行量化评估。
B卡（Behavior score card）。目的在于预测使用时点（获得贷款、信用卡的使用期间）未来一定时间内逾期的概率。
C卡（Collection score card）。目的在于预测已经逾期并进入催收阶段后未来一定时间内还款的概率。
风控评分卡种类 美国fico公司算是评分卡的始祖，始于 20世纪六十年代。Fico的评分卡的示例如下（这是个贷前评分卡，也就是A卡）：
可以看到，这里有三个因素，第一个是年龄AGE，第二个是收入段INCOME，第三个是住宅HOME是租的还是买的。当总分超过600分，就给与授信额度。这种评分卡，操作简单，就算是个小学生都能算出风险值。
二、评分卡优缺点 评分卡的好处还是很明显的：
易于使用。业务人员在操作时，只需要按照评分卡每样打分然后算个总分就能操作，不需要接受太多专业训练
直观透明。客户和审核人员都能知道看到结果，以及结果是如何产生的。
应用范围广。我们最熟悉的，莫过于支付宝的芝麻信用分，又或者知乎盐值（虽然知乎盐值不是评估金融风险的，但也算是评分卡的应用之一）
但是，随着信贷业务规模不断扩大，对风控工作准确率的要求也逐渐提升。这时候静态评分卡的弱点就暴露了：
利润的信息维度不高。简单是优点，但在日益增长的数据前，就变成缺点。有着大量数据资源却使用有限，造成数据资源的浪费。
当信息维度高时，评分卡建模会变得非常困难。（你看，本文的评分卡只涉及十个特征，就这么长一篇了）
某些不重要的特征，在另一些时刻会变得重要。例如在疫情期间，和收入相关的特征重要度会上升。
当然，以上的缺点主要限于静态评分卡，就算拿纸打勾计算分数那种，例如上面那个FICO的评分卡。有些积分，由于背后支撑的模型可以动态调整相关参数的权重，这时候就生成一个动态评分卡。但这种情况可以看成对机器学习模型做的可解释性解析。
三、评分卡构建 那么评分卡是如何构建的呢？一般包含下面六个步骤
数据探究。研究数据都包含哪些信息。
样本选取。选取一定时间周期内该平台上的信贷样本数据，划分训练集和测试集。
变量选取。也就是特征筛选。需要一定的业务理解。一般这部分费时较久
逻辑回归。根据筛选后的特征，构建逻辑回归模型。
评分卡转换。根据一定的公式转换。
验证并上线。验证评分卡效果，并上线持续监测
评分卡建模步骤 是不是看起来有点抽象呢？真正的干货马上来，赶紧去上个厕所，冲好咖啡，因为下面的干货太满了！
四、评分卡构建实战演练 看上面抽象的表述看累了？实际操作马上来了。
我们用的数据是每个搞风控的人都熟悉的“Give Me Some Credit"数据集。本节会按照列出的六个步骤带你领略评分卡实际构建过程。
数据集地址：https://link.zhihu.com/?target=https%3A//www.kaggle.com/c/GiveMeSomeCredit/overview
最终示例代码：https://link.zhihu.com/?target=https%3A//www.kaggle.com/orange90/credit-scorecard-example
4.1 数据探究 我们加载kaggle提供的数据集，先看看dataframe长啥样：
太长了，不容易看，我们看看摘要好了。
可以看到有些column里面是有null value的。我们看看有多少null value:
可以看到MonthlyIncome和NumberOfDependents有一些空值。在建模前我们需要对其进行处理。
对null值处理有很多策略，例如填中位数，填平均数，甚至拿个模型去预测都行。由于收入差距可能很大，MonthlyIncome填中位数相对合理。NumberOfDependents也可以填中位数，或者平均数，但平均数会变成小数，所以还是取中位数。
可以看到，fillna后就没问题了。
其中，变量SeriousDlqin2yrs是我们模型的label。我们可以说1为坏，0为好。这个变量是意思是Serious Delinquent in 2 year,也就是2年内发生严重逾期,其中”严重“定义为逾期超过90天。也就是说。例如你2018年1月1号开卡，每个月1号是还款日。例如你2019年4月1号是你的还款日，然后你在7月1号前都没还钱，那这时候逾期就超过90天了，你的数据标签就为1。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2ca5d39bb716f169010146830d8e952/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c00e4cc637fffb8a3ea26d41eab6df1/" rel="bookmark">
			spring boot &#43;shardingsphere 5.x集成mybatis-plus的简单例子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		搭建环境：
Springboot+mybatis-plus+Sharding-JDBC+Druid连接池创建一个工程并导入相关依赖 依赖：
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.18&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- ShardingSphere --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shardingsphere&lt;/groupId&gt; &lt;artifactId&gt;shardingsphere-jdbc-core&lt;/artifactId&gt; &lt;version&gt;5.0.0-alpha&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 按照水平分表的方式，创建数据库和数据表
（1）创建数据库course_db
（2）在数据库创建两张表course_1和course_2
（3）约定规则：如果添加课程id是偶数把数据添加course_1,如果奇数添加到course_2
sql代码如下：
注：创建数据库的没写 CREATE TABLE course_1( cid BIGINT(20) PRIMARY KEY, cname VARCHAR(50) NOT NULL, user_id BIGINT(20) NOT NULL, cstatus VARCHAR(10) NOT NULL ); CREATE TABLE course_2 ( cid BIGINT(20) PRIMARY KEY, cname VARCHAR(50) NOT NULL, user_id BIGINT(20) NOT NULL, cstatus VARCHAR(10) NOT NULL ); 编写代码实现：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c00e4cc637fffb8a3ea26d41eab6df1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18d35f6972301fc08ca20dad2b5fc979/" rel="bookmark">
			交换两个变量的值的三种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一：定义临时变量法 运用此方法比较简单
public class 定义临时变量 { public static void main(String[] args) { int v1=1; int v2=2; System.out.println("v1="+v1+","+"v2="+v2); int temp;//定义临时变量 temp=v1;//实现交换 v1=v2; v2=temp; System.out.println("v1="+v1+","+"v2="+v2); } } 代码运行结果如下:
方法二：运算符法 运用此方法有好处也有弊端。
好处：不用再定义临时变量。
弊端：加法操作可能会导致超出存储范围，并且只能用于数值型变量的交换，有一定的局限性。
public class 运算符法 { public static void main(String[] args) { int v1=1; int v2=2; System.out.println("v1="+v1+","+"v2="+v2); v1=v1+v2;//3 v2=v1-v2;//1 v1=v1-v2;//2 System.out.println("v1="+v1+","+"v2="+v2); } } 代码运行结果如下:
方法三：位运算法（异或） 位运算符操作的都是整型的数据，所以此方法也具有一定的局限性。
异或运算法则：如果两个值不相同，则异或结果为1，如果两个值相同，异或结果为0。
public class 位运算法 { public static void main(String[] args) { int v1=1; int v2=2; System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18d35f6972301fc08ca20dad2b5fc979/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c9b8119cbf1ef1b90fab7c131853c55/" rel="bookmark">
			经纬恒润_软件开发实习生_面试经历(电话面试)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定在本周六下午14：00来进行面试，大概13：40面试官打电话，讯问方便之后就开始了提前面试。
面试问题如下：
(正常寒暄，询问了一下返校时间、年级和专业、可以实习时间、)
Q：说说你的专业和学的内容。
Q：开发方面的话，用哪个开发语言最熟悉？
Q：开发工具用的是什么？
（下面问的是项目部分：主要围绕一个项目来进行询问和回答）
Q：用QT做过什么？是界面开发方面的吗？
Q：哪个界面开发系统做的最复杂，简单介绍一下界面上使用的元素？
Q：在项目中，你的QT和C++是怎么集成的？
Q：在项目里面有没有单独的C++程序？
Q：界面元素有哪些功能？
Q：击打界面有没有做什么效果？（因为我回答的是一个战斗系统）
Q：击打部分是贴了一张宠物图片吗？
Q：有其他动态效果吗？只有那些框框按钮之类的是吗？
Q：你开发的这个系统是在电脑端的还是手机端的？
Q：你知道QT有什么特性吗？
Q：网页的界面做过吗？
Q：关于人机交互的易用性和美观之类的，有学过相关课程吗？
Q：你觉得（软件开发）从用户的易用性角度应该考虑哪些因素？
Q：C++里面学过设计模式吗？能想起来一个吗？（设计模式我不知道是什么，呜呜呜）
Q：C++写代码的代码量有多少？
Q：除了课程设计，自己感兴趣的方面做过哪些吗？比如结合自己的爱好？
Q：实习内容你有什么要求吗？不想做哪些内容？
Q：实习岗介绍：主要是做原型机的、也就是产品的原型设计，需求分析、测试验证，是一个专业性质的软件、和消费者行业的软件不一样。是web形式的开发。
Q：学了大端小端吗？解释一下。
Q：哪些系统用的是大端？哪些用的是小端？
Q：你有什么想了解的吗？
Q：有可能提前返校吗？
Q：实习工资有什么要求吗？
（问了一下学校地址，说了一下公司离我很近，之后就是总结，说一周之内给通知）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b7071f0e6b2c66d9c4ed3970323df7b/" rel="bookmark">
			SQL数据库： 数据库基础操作&#43;书写规范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库基础操作 SQL可实现的操作：
操作语言建表CREATE TABLE table (c1 int,c2 varchar(50),c3 varchar(50));删表DROP TABLE table;修改列ALTER TABLE table ADD/DROP/ALERT column_name (datatype);选择SELECT c1,c2 FROM table WHERE … ;插入INSERT INTO a VALUES(9,30,30);更新UPDATE table SET c1=value1,c2=value2,…WHERE… ;删除DELETE FROM table WHERE …;连接select * from [user] full JOIN phone ON [user].id=phone.idWHEREHAVING筛选分组后的各组数据SELECT FROM WHERE GROUP BY HAVING ; 操作结果处理WHEREANDSELECT * FROM table WHERE c1=‘a’ AND c1=‘b’;ORSELECT * FROM table WHERE c1=‘a’ OR c1=‘b’;排序 ORDER BY关键字用于对结果集按照一个列或者多个列进行排序，降序 ORDER BY 列名 DESC,列名 DESC指定模式LIKE操作符用于在 WHERE 子句中搜索列中的指定模式。返回行数COUNT(c1)SELECT COUNT(c1) FROM table WHERE ;别名 AS，AS可省略名字AS别名，如SELECT 列名 FROM 表名 AS 别名; SQL join 用于把来自两个或多个表的行结合起来：INNER JOIN与JOIN(INNER JOIN与JOIN是相同
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b7071f0e6b2c66d9c4ed3970323df7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e052c588199065911f3b04cefd08d7c8/" rel="bookmark">
			Ubuntu系统下增加中文字体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
最近在使用Pycharm、Clion编译器的时候，使用中文做注释时，Ubuntu系统下的显示效果太闹心。
方案：
为解决这个问题，查阅了资料，得知解决方案如下：
1）复制 windows系统下的字体文件（msyhl.ttc）（这里以微软雅黑为例）到ubuntu系统中；
2）将该文件的后缀改为ttf，即可在ubuntu系统下被识别；
3）将该文件copy到ubuntu系统下存放字体的指定路径，我的系统路径如下：
/usr/share/fonts/opentype/noto/ 注：可通过如下命令查看：
fc-list :lang=zh 4）修改ubuntu系统字体的默认文件，即将默认字体文件修改为你需要设置的字体文件
使用sudo命令打开
sudo vim /etc/fonts/conf.d/64-language-selector-prefer.conf 修改（添加）文件中的字体配置信息，每个&lt;prefer&gt;后面的第一行都是添加的默认新字体。
&lt;?xml version="1.0"?&gt; &lt;!DOCTYPE fontconfig SYSTEM "fonts.dtd"&gt; &lt;fontconfig&gt; &lt;alias&gt; &lt;family&gt;sans-serif&lt;/family&gt; &lt;prefer&gt; &lt;family&gt;Noto Microsoft YaHei&lt;/family&gt; &lt;family&gt;Noto Sans CJK JP&lt;/family&gt; &lt;family&gt;Noto Sans CJK SC&lt;/family&gt; &lt;family&gt;Noto Sans CJK TC&lt;/family&gt; &lt;/prefer&gt; &lt;/alias&gt; &lt;alias&gt; &lt;family&gt;monospace&lt;/family&gt; &lt;prefer&gt; &lt;family&gt;Noto Microsoft YaHei&lt;/family&gt; &lt;family&gt;Noto Sans Mono CJK JP&lt;/family&gt; &lt;family&gt;Noto Sans Mono CJK SC&lt;/family&gt; &lt;family&gt;Noto Sans Mono CJK TC&lt;/family&gt; &lt;/prefer&gt; &lt;/alias&gt; &lt;/fontconfig&gt; 保存文件即可生成！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e052c588199065911f3b04cefd08d7c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d072829a7b0827757e010beb49118af/" rel="bookmark">
			[漏洞复现]CVE-2019-0708
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CVE-2019-0708复现 一、远程桌面连接二、kali系统还原漏洞 一、远程桌面连接 首先，我们要设置远程连接
在控制面板中，搜索“远程设置”-&gt;“远程”，勾选“允许远程协助连接这台计算机”和“仅允许运行使用网络级别身份验证的远程桌面的计算机联机”，然后点击“应用”。
下一步，查看Win7的IP地址，CMD中输入指令ipconfig
接着打开远程控制的电脑Win10系统，在运行中输入“mstsc”。
输入刚才得知的Win7 IP地址
是
下一步的弹窗会要求输入账户和密码，点击确定（或者保存密码）
二、kali系统还原漏洞 首先，通过git命令下载远程代码。
git clone https://github.com/n1xbyte/CVE-2019-0708.git 原网站内容显示如下所示：
查看所下载资源的组成，可以看到crashpoc.py、poc.py、README.md文件。
ls cd CVE-2019-0708 ls 查看文件权限并升级权限。
ls -lh 通过“ls -lh”命令查看权限，以“crashpoc.py”权限为例，第一块“-rwx”代表文件主人root的权限，即管理员权限；第二块“r– –”代表这个文件所在组的其他人的权限；第三块“r– –”代表其他人的权限，如Apache等软件属于其他人权限。“r”代表读取权限、“w”达标写入权限、“x”代表执行权限。
chmod 777 crashpoc.py 调用命令“chmod 777 crashpoc.py”修改权限，“chmod”表示change mod修改文件属性；“crashpoc.py”表示所修改的文件；“777”表示权限列表，每个“7”表示一组，总共三组，“r– –”二进制表示“100”，其值为4，而“111”二进制值为7（4+2+1），即所有权限都开启。
输入下面的命令修改权限，“x”代表执行权限，可以看到“crashpoc.py”文件变成了绿色，表示可执行。同时该文件权限修改为“-rwx r-x r-x”。
chmod +x crashpoc.py 下一步，我们查看源代码
cat crashpoc.py cat poc.py 打开crashpoc.py查看源代码，发现需要安装impacket、Structure扩展包。
下一步，安装没有安装的扩展包
pip3 install impacket pip3 install Structure 最后一步，利用POC攻击
python3 crashpoc.py 192.168.147.136 32 结果如下图：
在复现的过程中，有几个点需要注意：
1、攻击指令之后要有攻击的端口号；
2、如果py文件运行失败，要注意一下，是否是openssl的问题；
3、远程桌面设置时，尽量选择“仅允许运行使用网络级别身份验证的远程桌面计算机进行连接”，这样子更安全；
希望大家可以有所收获！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5a608dc70bdffa30854af88c33b35ea/" rel="bookmark">
			sklearn神经网络参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面写了一个超级简单的实例，训练和测试数据是mnist手写识别数据集：
from sklearn.neural_network import MLPClassifier import gzip import pickle with gzip.open('./mnist.pkl.gz') as f_gz: train_data,valid_data,test_data = pickle.load(f_gz) clf = MLPClassifier(solver='sgd',activation = 'identity',max_iter = 10,alpha = 1e-5,hidden_layer_sizes = (100,50),random_state = 1,verbose = True) clf.fit(train_data[0][:10000],train_data[1][:10000]) print clf.predict(test_data[0][:10]) print(clf.score(test_data[0][:100],test_data[1][:100])) print(clf.predict_proba(test_data[0][:10])) 参数说明：
参数说明:
hidden_layer_sizes :例如hidden_layer_sizes=(50, 50)，表示有两层隐藏层，第一层隐藏层有50个神经元，第二层也有50个神经元。
activation :激活函数,{‘identity’, ‘logistic’, ‘tanh’, ‘relu’}, 默认relu
identity：f(x) = x
logistic：其实就是sigmod,f(x) = 1 / (1 + exp(-x)).
tanh：f(x) = tanh(x).
relu：f(x) = max(0, x)
solver： {‘lbfgs’, ‘sgd’, ‘adam’}, 默认adam，用来优化权重 lbfgs：quasi-Newton方法的优化器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5a608dc70bdffa30854af88c33b35ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60449760502fc33320b583beffefb5be/" rel="bookmark">
			解决ajax跨域问题【5种解决方案】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决ajax跨域问题【5种解决方案】
什么是跨域问题?
跨域问题来源于JavaScript的"同源策略"，即只有 协议+主机名+端口号 (如存在)相同，则允许相互访问。也就是说JavaScript只能访问和操作自己域下的资源，不能访问和操作其他域下的资源。跨域问题是针对JS和ajax的，html本身没有跨域问题。
查看浏览器开发者工具Console报错：
Failed to load http://a.a.com:8080/A/FromServlet?userName=123: No ‘Access-Control-Allow-Origin’ header is present on the requested resource. Origin ‘http://b.b.com:8080’ is therefore not allowed access.
http://www.abc.com/a/b 调用 http://www.abc.com/d/c（非跨域）
http://www.abc.com/a/b 调用 http://www.def.com/a/b （跨域：域名不一致）
http://www.abc.com:8080/a/b 调用 http://www.abc.com:8081/d/c （跨域：端口不一致）
http://www.abc.com/a/b 调用 https://www.abc.com/d/c （跨域：协议不同）
请注意：localhost和127.0.0.1虽然都指向本机，但也属于跨域。
跨域问题怎么解决？
1、响应头添加Header允许访问
2、jsonp 只支持get请求不支持post请求
3、httpClient内部转发
4、使用接口网关——nginx、springcloud zuul (互联网公司常规解决方案)
解决方式
1：响应头添加Header允许访问
跨域资源共享（CORS）Cross-Origin Resource Sharing
这个跨域访问的解决方案的安全基础是基于"JavaScript无法控制该HTTP头"
它需要通过目标域返回的HTTP头来授权是否允许跨域访问。
response.addHeader(‘Access-Control-Allow-Origin:*’);//允许所有来源访问
response.addHeader(‘Access-Control-Allow-Method:POST,GET’);//允许访问的方式
解决方式2：jsonp 只支持get请求不支持post请求
用法：
①dataType改为jsonp
②jsonp : “jsonpCallback”————发送到后端实际为http://a.a.com/a/FromServlet?userName=644064&amp;jsonpCallback=jQueryxxx
③后端获取get请求中的jsonpCallback
④构造回调结构
$.ajax({ type : "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60449760502fc33320b583beffefb5be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/531466f28f8493adeb41f2c867383918/" rel="bookmark">
			Mac系统升级后开发者证书不被信任，报错/usr/bin/codesign --force --sign
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自己和同事升级Mac系统后，都遇到不能正常真机调试问题。
1.问题描述 主要表现为两种形式： 1.原来可以的证书现在点击不被信任。设置为始终信任后，一旦运行xcode会提示revoke证书。
2.或者编译不过，报错类似这种：
Showing Recent Messages CodeSign ~/Library/Developer/Xcode/DerivedData/YiDing-fiptpxtujwvnricolywfszwdtqod/Build/Products/Debug-iphonesimulator/CTAssetsPickerController.bundle cd ~/Downloads/MVVM-RAC-Demo-master/YiDing/Pods export CODESIGN_ALLOCATE=/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/codesign_allocate export PATH="/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/usr/bin:/Applications/Xcode.app/Contents/Developer/usr/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin" Signing Identity: "-" /usr/bin/codesign --force --sign - --timestamp=none ~/Library/Developer/Xcode/DerivedData/YiDing-fiptpxtujwvnricolywfszwdtqod/Build/Products/Debug-iphonesimulator/CTAssetsPickerController.bundle ~/Library/Developer/Xcode/DerivedData/YiDing-fiptpxtujwvnricolywfszwdtqod/Build/Products/Debug-iphonesimulator/CTAssetsPickerController.bundle: bundle format unrecognized, invalid, or unsuitable Command /usr/bin/codesign failed with exit code 1 2.解决方案 最终定位到是升级系统后，缺少苹果官方证书（2030年2月20日过期版本证书），于是从其他人电脑导出后，安装上完美解决问题！！！
证书下载地址：链接:https://pan.baidu.com/s/1xkLwjUZ_vKOU8vd0xnXMpg 密码:v3jk
下载后安装，看到钥匙串中有该证书就可以了
为了保险，建议重启xcode，然后clean，之后再重新运行~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08f43be9dda1d64970657a4b56e5ac8f/" rel="bookmark">
			Cascader 级联选择、回显
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、选择时的效果： 页面代码
&lt;el-tag type="success"&gt;选择A面信息&lt;/el-tag&gt; &lt;div style="margin-top: 10px"&gt; &lt;el-cascader style="width: 70%" :show-all-levels="false" placeholder="点击选择A面位置" @change="handleAChange" :props="propA" clearable&gt; &lt;/el-cascader&gt; &lt;/div&gt; data数据
propA: { lazy: true, lazyLoad(node, resolve) { setTimeout(() =&gt; { if (node.level === 0) { // 如果当前节点是第一级，查询一级列表 axios.get('/modf/getequips').then(res =&gt; { const equips = res.map((value, i) =&gt; ({ value: value, label: value, leaf: node.level &gt;= 1 })); resolve(equips); }).catch(err =&gt; { console.log(err); }); // 如果是二级，查询二级列表 } else if (node.level === 1) { axios.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08f43be9dda1d64970657a4b56e5ac8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6077eeefb1e764f8f0f0677b5341110/" rel="bookmark">
			事关rsa加密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		事关RSA加密 事情是这样的，这几天在搞rsa加密， 于是研究了一下。本本将介绍非对称加密、python实现rsa加解密的方法、rsa的填充方法
非对称加密 相对比较安全，rsa 加密是非对称加密的一种。
原理：非对称加密依赖与明文经过与公钥进行数学运算可得出密文，而密文经过与密钥进行数学运算又可得到明文。
用途：非对称加密算法的优点是密钥分发简单，但缺点也是很明显的，其加解密过程依赖于数学运算运算量大所以加解密速度慢（另外同样的密钥强度其安全性弱于对称加密算法），其只适用于少量内容的加解密，最典型的就是https中用于完成对称密钥的交换（即openssl的rsa的加解密）。
拓展：https中的ｓ是结合了对称加密（一个密钥）＋非对称加密（公钥＋私钥），　具体是：发送方将 对称加密的密钥 通过非对称加密发送接收方， 接收方通过非对称加密来解密，然后得到对称加密的密钥，然后再用对称密钥进行加密消息。
rsa的填充方法 1.RSA_PKCS1_PADDING 填充模式， 比钥模长(modulus) 短至少11个字节, 也就是　RSA_size(rsa) – 11
2.RSA_PKCS1_OAEP_PADDING,比钥模长(modulus) 短至少41个字节, 也就是　RSA_size(rsa) – 41
3.RSA_NO_PADDING ， 和钥模长(modulus)一样长度
python实现rsa加解密的方法 1.使用 pycryptodome 包
pip3 install pycryptodome
from Crypto.PublicKey import RSA # 导入rsa from Crypto.Cipher import PKCS1_OAEP # 导入填充模式 #加密 public_key = RSA.import_key(open("public.key","rb").read()) cipher = PKCS1_OAEP.new(public_key) data = open("hello.txt", "rb").read() # 用二进制读取待加密文件 en_data = cipher.encrypt(data) # 输出为加密之后的二进制表示 #解密 private_key = RSA.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6077eeefb1e764f8f0f0677b5341110/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/764a9e321279ee46f895f0a698e87c5f/" rel="bookmark">
			java中以下为不合法字符常量_以下字符常量中不合法的是
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【单选题】“饰小说以干县令,其于大达也远矣。”出自( )。
【判断题】交车前,汽油箱内要加注一定量汽油,保证车辆可以顺利行驶到附近的加油站。
【判断题】提炼企业使命时要为企业未来发展预留解释空间。
【判断题】8253工作于方式1时,触发是可以重复进行,而且不必重新写入初始值。
【多选题】下列可以影响竞聚率的因素是
【多选题】与氯丙嗪抗精神病作用有关的中枢DA神经通路有( )
【分析题/解答题/计算题/证明题】某单层建筑平面图如下图所示,条形基础垫层宽度800mm。计算基数L中、L内、L外、L净、S底、S房。 (结果保留两位小数)
【判断题】实事求是就是一切从本本出发。
【单选题】关于溶液表面吸附的说法中正确的是( )
【单选题】确定双肢格构式柱的二肢间距的根据是( )。
【单选题】下面哪一个部件不属于电动潜油离心泵采油系统( )
【判断题】共阳极数码管各段引出线的排列格式按照dp、g、f、e、d、c、b、a顺序排列,显示E时的段码是86H。( )
【判断题】采油速度一定时,地层能量越充足,压降下降速度越快。( )
【判断题】Rhetorical questions and figurative sentences cannot be used as arguments, but must be declarative sentences. ( )
【多选题】请问冰点下载器适用于哪些网站的文档下载?
【判断题】药物治疗旨在改善认知缺损的促认知药治疗,也包括针对精神行为症 状的药物治疗,目的是治愈失智症患者。( )
【单选题】下列哪些不属于社会组织 ( )
【单选题】内质网向高尔基复合体转运蛋白的方式是 :
【单选题】According to the Incoterms 2010 under FCA the risk of goods will be transferred from the seller to the buyer ( ).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/764a9e321279ee46f895f0a698e87c5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa26d3b8188bdd1149ef32e4887c6a90/" rel="bookmark">
			家里WiFi突然连不上网了？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天家里的WiFi突然不能上网了，手机显示已连接（不可上网），经过多次断点测试，终于找到了原因，成功解决WiFi不能上网问题。
1、首先，查看光纤入户装置光猫，若光猫指示灯亮着，说明线路没有问题。也可通过将光猫的网线直接插入笔记本电脑，选择拨号上网方式，登录宽带账号，测试是否能上网，若能上网，则说明光猫没有问题。那么问题则出现在路由器上。
2、若手机能连上WiFi，但不能上网，则说明路由器没有出现故障。此时，重启路由器，登录192.168.1.1（不同路由器可能地址不同），重新设置密码，即可成功上网！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/836f3f5e7763b8db17cffce4ea873903/" rel="bookmark">
			【Delphi入门】结构化程序设计（顺序结构、选择结构和循环结构）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		结构化程序设计有三种基本结构，即顺序结构、选择结构和循环结构
顺序结构 主要由赋值语句等简单的操作语句组成
选择结构 对给定的条件进行分析判断，在满足不同的条件时执行不同的操作
掌握选择结构，首先要掌握条件的表示方法——关系表达式和逻辑表达式
关系运算符 &amp; 关系表达式 关系运算符是用来对两个表达式进行大小比较的运算符，用关系运算符把两个运算对象连接起来表示它们的大小关系的式子称为关系表达式
关系表达式描述的关系成立，则关系表达式的结果为True，否则结果为False
关系运算符一共有9种
逻辑运算符 &amp; 逻辑表达式 逻辑运算符一共有4个
逻辑运算符的优先级别是：Not 为第一级，And为第二级，Or 和 Xor 为第三级
单分支与多分支 IF 语句 单分支
If(条件) Then 语句1; //条件为True执行语句1 多分支
If(条件) Then 语句1 //没有分号 Else 语句2; //有分号 //条件为True执行语句1，否则执行语句2 多分支 Case 语句 Case （表达式） of 值1: 语句1; 值2: 语句2; … 值n: 语句n; Else //这里的Else之前可以有分号 语句n+1; end; Case （表达式） of 值1,值2: 语句1; 循环结构 Delphi 7实现循环结构的语句一共有3种，分别是While语句、Repeat语句和For语句
while语句用来实现“终止型循环”，其语法格式及功能如下
While（循环条件） do 循环体; Repeat语句用来实现“直到型循环”，其语法格式及功能如下
Repeat 循环体; Until (循环条件); 使用For循环语句将会使编程更加方便。For循环语句的语法格式及功能如下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/836f3f5e7763b8db17cffce4ea873903/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4ffc1e2a07bf9bdafa1e23b111244f1/" rel="bookmark">
			python笔试110题（Interview questions）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python笔试110题–详解 一行代码实现1—100之和
解：
print(sum(range(1, 101))) 如何在一个函数内部修改全局变量
解：
1）函数内部用global声明，global x。
2）全局变量的类型是容器：字典，列表等
# 2. 如何在一个函数内部修改全局变量 dict1 = {} print("函数调用前为空", dict1) def write_in_dict(): dict1['name'] = '张娃' dict1['age'] = 28 dict1['sex'] = '男' write_in_dict() # 调用 print("函数调用后：", dict1) 打印输出：函数调用前为空 {}
函数调用后： {'name': '张娃', 'age': 28, 'sex': '男'}
列出5个python标准库
解：
os，sys，re，math， random ，datetime ，urllib，datetime ，zlib
字典如何删除键和合并两个字典
# 4、字典如何删除键和合并两个字典 dict1 = {'name': 'pei', 'age': 28, 'sex': '男'} dict2 = {'工号': '123', '工时': 10, 'gen': '女'} print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4ffc1e2a07bf9bdafa1e23b111244f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2484bee6ee8a964a163d098ceed627b/" rel="bookmark">
			基于 SOAP消息协议的 HttpWebRequest 请求 WebService 服务接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		private const string Request_UserAgent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.75 Safari/537.36"; public static string QuerySoapWebService(string url, string methodName, Hashtable pars) { url = url.Contains("?WSDL") || url.Contains("?wsdl") ? url : url + "?WSDL"; var request = (HttpWebRequest)WebRequest.Create(url); request.Method = "POST"; request.ContentType = "text/xml; charset=utf-8"; request.UserAgent = Request_UserAgent; //request.Headers.Add("SOAPAction", "\"" + XmlNs + (XmlNs.EndsWith("/") ? "" : "/") + methodName + "\""); //SetWebRequest(request); var data = SoapWebServiceEncodeParsToSoap(pars, methodName); request.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2484bee6ee8a964a163d098ceed627b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c67dbd37bd81f7fdae2f94259f6459b/" rel="bookmark">
			TS型网页视频下载方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原文链接：https://zhuanlan.zhihu.com/p/97609880
如有侵权，联系删除 ！！！
ffmpeg 安装：（可以使用conda 安装）
conda install ffmpeg -c conda-forge 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cae3369ab97fbe5f845a6c85cb402644/" rel="bookmark">
			快速git pull更新所有项目文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求分析 故事的开始是这样的，有位搬砖工，名字叫小徐，他所在的公司用的是VMware Horizon 7虚拟桌面环境，软件开发根本连不上外部网络，这让他非常苦恼。
突然有一天，公司内部大变革，要开始使用maven私服，要开始使用内部PaaS，这让小徐心里乐开了花。“可是新知识太多，这该如何学习呢？”小徐泛起了嘀咕。
功夫不负有心人，在小徐的日夜努力中，在一个号称全球最大的同性交友网站上，找到了很多学习资料。小徐在自己查询外部互联网资料的笔记本上，熟练的git clone各种各样的仓库，很快，满满一个硬盘都是这些仓库的文件夹。
时间过的很快，转眼7个月过去了。
技术变化的很快，转眼，满满硬盘的学习资料都过时了，怎么一下子将他们更新呢？
以上就是小徐向我提出了需求。
设计软件
python是世界上最好的语言！😆
设计思路很简单，判断当前目录的所有文件夹中，是否其中包含后缀是.git的文件夹，如果是，则为仓库，进行更新，不是就跳过。
其中需要依赖gitpython这个包，来进行git pull操作。
import git from git import * import threading import os def isGitDir(dir): repdir = os.path.join(os.path.abspath('.'), dir) repgitdir = os.path.join(repdir, '.git') if not os.path.exists(repgitdir): return False return True def updateSub(subdir): repdir = os.path.join(os.path.abspath('.'), subdir) try: repo = git.Repo(repdir) if repo.is_dirty(): dirSubDir.append(subdir) return remote = repo.remote() print("start pulling from remote for: %s\r\n" %subdir) remote.pull() print("Done pulling for %s\r\n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cae3369ab97fbe5f845a6c85cb402644/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/995711f1c22546f2f69d5fe283451dce/" rel="bookmark">
			Java equals == 的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为我的java是快速上手的——没看基础，直接改别人代码。然后就开始做。所以一些基础不知道
SyncSysLink link = new SyncSysLink(); link.setReached(1); Short one = 1; if(link.getReached().equals(one)) { System.out.println("yes");//&lt;-结果 }else System.out.println("no"); if(link.getReached().equals(1)) { System.out.println("__yes"); }else System.out.println("__no");//&lt;-结果 if(link.getReached()==1) { System.out.println("yes 1");//&lt;-结果 }else System.out.println("no 1"); link.setReached(128); if(link.getReached()==128) { System.out.println("yes 2");//&lt;-结果 }else System.out.println("no 2"); Short _128 = 128; if(link.getReached().equals(_128)) { System.out.println("yes 3");//&lt;-结果 }else System.out.println("no 3"); short __128 = 128; if(__128==128) { System.out.println("yes 4");//&lt;-结果 }else System.out.println("no 4"); Double d1 = 1.0; Double d2 = 1.0; if(d1==d2) { System.out.println("yes 5"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/995711f1c22546f2f69d5fe283451dce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d5b126340da4ed04f8e447d46730a66/" rel="bookmark">
			正则表达式——正则入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正则表达式——正则入门 正则测试地址：https://regex101.com/
先从一个例子开始正则表达式。
书写一个匹配手机号的正则表达式，为了方便讨论，假定手机号是1开头，第二位只能是3、5、8中的其中一个，总共11位的数字，形如13xxxxxxxxx。
匹配手机号的正则表达式为：^1[358]\d{9}$，下面介绍此正则表达式中的各个符号的含义。
符号含义简介 ^:表示字符串的开头，后面紧接着1，表示匹配的字符串要以"1"开头。
1:就是匹配“1”本身，^不匹配字符，所以1就是匹配字符串的第一个字符。
[358]:表示可以匹配3、5、8中的任何一个，当然，也只能匹配一个字符；[abc]整个表达式用来匹配一个字符，这个被匹配字符可以是abc中的任一个。
\d:表示一个数字字符，等同于[0123456789]，匹配0123456789中的任何一个数字，[0123456789]也可以写作[0-9]。
{9}:表示前面的\d重复9次，即有9个数字。重复次数可以设定范围值或是最小值，{m,n}表示前面的元素或是表达式最少重复m次，最多重复n次；{m,}表示前面的元素或是表达式最少重复m次，不设定最大重复次数。
$:表示字符串的结尾，它前面的\d{9}数字重复9次后，后面就不能再有字符了。
如上图所示，13666666666符合正则表达式^1[358]\d{9}$。
"13666666666"的第一位数字1，匹配正则表达式中的^1，以数字1开头；第二位数字3匹配表达式中的[358]，属于3、5、8中的一个；第三位至第十一位的9个数字，匹配表达式中的\d{9}；第十一位数字后不再有字符，匹配表达式$。
"13"匹配表达式中的^1[358]，不匹配\d{9}，后续没有9个数字；"71366666666"不匹配^1，没有以数字1开头；"136666666666"匹配^1[358]\d{9}，不匹配$，9个数字后还有数字；"abf"不匹配^1，没有以数字1开头。
匹配一个字符 想要匹配字符串"abc"中的a，正则表达式a即可完成任务。在正则表达式中，可以使用字母或是数字，匹配其本身。正则表达式大小写敏感。
在正则中，.(英文句点)可以用来匹配任意字符(换行符除外)，包括它自己。
匹配一组字符中的一个 正则表达式[an]表示匹配a或者n，[]中的字符可以理解为是"或"的关系。
在[]中可以使用区间表达式，例如[0-9]表示匹配0到9的数字，即所有数字；[a-z]表示匹配所有小写英文字母，[A-Z]表示匹配所有大写英文字母，[a-f]表示匹配a-f的所有小写字母。
有时我们希望不要匹配到某些字符，此时也可以用[]。例如[^abcdef]表示不匹配abcdef中的任何一个，其他字符都可以，有些类似于取反。
同样的，字符区间一样可以用于取反操作。
需要注意的是，[]中的^作用范围是整个[]。例如[^a-f0-9]表示不能匹配a-f的小写字母以及0-9的所有数字。
元字符 之前提到过，.可以匹配所有单个字符(换行符除外)，如果只是想匹配".“本身呢？此时只需要在”.“前面加一个转义符”\“即可，即正则表达式\.。
同样的，之前提到的”["、"]“也可以通过加转义符来匹配本身，\[、\]。”\"同样可以通过转义来匹配其本身，\\。
其他常用元字符如下：
空白元字符含义\f换页符\n换行符\r回车符\t制表符(Tab键)\v垂直制表符 元字符含义\d任何一个数字字符(等价于[0-9])\D任何一个非数字字符(等价于[^0-9])\w任何一个单词字符(数字，大小写字母，下划线)(等价于[0-9a-zA-Z_])\W任何一个非单词字符(即非数字，非大小写字母，非下划线)(等价于[^0-9a-zA-Z_])\s任何一个空白字符(等价于[\f\n\r\t\v])\S任何一个非空白字符(等价于[^\f\n\r\t\v]) 重复匹配 之前说的都是匹配一个字符，现在说一下如何重复匹配一个字符。
\d+表示匹配\d一次或多次
\d*表示匹配\d零次、一次或多次
\d?表示匹配\d零次或一次
除了+、*、?可以重复匹配外，还可以使用{}进行更精确的重复匹配次数控制。
\d{3,5}表示\d最少匹配三次，最多匹配五次
\d{3,}表示\d最少匹配三次，最大匹配次数不做限制
\d{3}表示\d匹配三次
位置匹配 \b表示匹配单词边界，也就是一个位置，此位置一边是单词字符(\w代表的内容，即数字，大小写字母，下划线_)，另一边不是单词字符。可以看到，字符串"23 word on"共有六个位置属于单词边界。
^表示匹配字符串开头，字符串"23 word on"只有一个位置匹配成功。"^“用在”[]"中时表示取反，否则是匹配字符串开头。
$表示匹配字符串结尾，字符串"23 word on"只有一个位置匹配成功。
总结 本文主要介绍了正则表达式中，匹配一个字符，匹配一组字符中的一个，什么是元字符，如何控制重复匹配，最后学习了几个简单的位置匹配。
下一篇：贪婪、非贪婪与占有模式
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c05a62622cabebd220dc1595544f0419/" rel="bookmark">
			overleaf使用指南以及最基本LaTeX语法回顾
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇接上一篇，"LaTeX新手半小时速成手册（不速成你打我 "算是latex使用的一些拓展，连带介绍一下overleaf
overleaf是一个非常方便的在线LaTeX编辑器：
https://www.overleaf.com/
begin 新建账户绑定邮箱之后我们就可以进去新建一个project：
如果你是为了写论文之类的那么可以upload一些会议的template
如果是想要写笔记之类的，那么可以选择Blank或者example template
一个非常重要的根本性概念需要告诉大家：LaTeX这是一个编辑排版工具而已，它只是为了让你的文字内容看起来更加美观或者符合规则，但是最重要的还是你的文字内容，有时候不必太过于拘泥于形式(比方说有很多初学者学了enumerate、交叉引用之类的，就想要到处用它，虽然对于新手而言这样练习是没问题的，但是到了后面其实是完全没必要)。
一般而言使用LaTeX是为了写论文，那么就直接用对应会议的LaTeX模板就行(虽然有些会议的template会有一些坑)，有些同学可能是为了做笔记。但是总体上来说，用的舒服就行了，这也就是为什么LaTeX这个东西入门不难，求精却难的原因，因为很多时候也没必要精，够用就行。有特定需求的时候，再去查阅资料，进行拓展使用。
outline 先来熟悉一下overleaf的工作环境：
这里新建了一个example，也就是模板
首先可以看一下最左边那列：
上面是你所有写作过程中需要用到的中间文件，除了主要的编辑文章内容的main.tex之外，还包括一些你需要用到的图表，pdf、eps文件等，可以手动上传。
下面就是你整个文章的篇幅结构。
选择main.tex进行编辑，再看到右边两列：
左边的是文章撰写的编辑器，右边是文章编译之后的pdf预览(点击recompile)
edit 接下来就开始编辑
一个main.tex的撰写主要分为两部分,导言区和正文
导言区用于插入各种宏包和依赖以及title、author、affiliation之类的，正文部分就是你主要文字内容的排版。
每一个\开头的，比方说\usepackage、\begin等都是一条命令，命令都可以传参
比方说：
\documentclass{article} article就是documentclass的主要参数，参数用{}括起来.这条语句就是选择使用哪种格式的排版，你也可以使用book等其他参数试试，排版效果完全不同。
\includegraphics[scale=1.7]{universe} 上述这条命令多了一个[]，这是可选参数，有些命令有。
基本上一个latex的main.tex文件就是由导言区+正文以及这两部分里面各种命令组成，哦对了还有你的文字内容。
基本latex的使用语法可以参照笔者的这篇博客快速入门：
LaTeX新手半小时速成手册（不速成你打我
接下来讲一下上面这篇博客还没讲到的一些拓展知识点：
交叉引用： latex可以灵活地引用你想要应用的各种对象，比方说section、picture、table等等。
基本方法就是两步：
\label，给你想要应用的对象取个外号。\ref,指定外号，引用对象。 比方说：
\subsection{subsection}\label{sub1} I am subsection. \subsubsection{subsubsection} I am subsubsection.I wat to refer \ref{sub1} 效果:
注意：label必须加载你需要引用对象的后面，如果我写成这样：
\label{sub1}\subsection{subsection} I am subsection. \subsubsection{subsubsection} I am subsubsection.I wat to refer \ref{sub1} 那么会引用到label之前最近的那一个sec:
插入和引用图片 插入图片 之前说到了，引用可以引用任何东西，包括你的picture。所以我们需要上载和插入图片。
首先需要导入包：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c05a62622cabebd220dc1595544f0419/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/460a9f1cb973a156fc673a872740eecc/" rel="bookmark">
			pytorch--DataLoader的collate_fn参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pytorch–DataLoader的collate_fn参数
''' &gt;&gt;&gt;a = [1,2,3] &gt;&gt;&gt; b = [4,5,6] &gt;&gt;&gt; c = [4,5,6,7,8] &gt;&gt;&gt; zipped = zip(a,b) # 打包为元组的列表 [(1, 4), (2, 5), (3, 6)] &gt;&gt;&gt; zip(a,c) # 元素个数与最短的列表一致 [(1, 4), (2, 5), (3, 6)] &gt;&gt;&gt; zip(*zipped) # 与 zip 相反，*zipped 可理解为解压，返回二维矩阵式 [(1, 2, 3), (4, 5, 6)] ''' def seq_collate(data): (obs_seq_list, pred_seq_list, obs_seq_rel_list, pred_seq_rel_list, non_linear_ped_list, loss_mask_list) = zip(*data) _len = [len(seq) for seq in obs_seq_list] cum_start_idx = [0] + np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/460a9f1cb973a156fc673a872740eecc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74246838b860545c3b78a0eadaf6475b/" rel="bookmark">
			【JavaSE】JDBC封装（JDBC&#43;Druid&#43;Template）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 JDBC工具类JDBC的练习：从数据库中查询用户练习二：PreparedStatementJDBC工具类（放置更多操作给外部）JDBC配置文件 JDBC Template(数据库连接池)（Druid）JDBCＵｔｉｌｓ　（Druid）配置文件 Spring JDBC （Java DataBase Connectivity）
JDBC是定义了一套数据库的接口，他可以用统一的一套Java代码来操作数据库
JDBC怎么操作它？里面有几个常用的方法， 第一个是连接方法，还有的就是关闭方法，连接方法包括了加载驱动，建立连接，创建载体，关闭方法又包括了关闭返回集合，关闭载体，关闭连接查询语句，得到一条sql语句，然后我们可以对他进行查询。返回一个array list集合。（其中我们有用到result set meta data进行封装结果集）最后我们就可以得到这个集合，再封装成array list集合返回给调用的函数。还有一个就是update。方法update方法是对数据库进行一个更新的操作，也就是修改 我们需要知道以下步骤：
Class.forName(“com.mysql.jdbc.Driver”);Connection conn = DriverManager.getConnection(“jdbc:mysql://localhost:3306/数据库名”, “数据库用户名”, “数据库密码”);String sql = “update 表名 set 字段 = 字段值 where id = 1”;Statement stmt = Connection对象.createStatement();int count = Statement对象.executeUpdate(sql);Statement对象.close();/Connection对象.close();释放资源 JDBC工具类 public class JDBCTools { private String url = "jdbc:mysql://localhost:3308/hzyc98"; private String username = "root"; private String userpassword = "mysql"; private Connection conn; private Statement stmt; private ResultSet reSet; //连接的封装方法 private void connect() { try { Class.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74246838b860545c3b78a0eadaf6475b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e9dd3abb48d0c1852564a7ec2f9c108/" rel="bookmark">
			[Unity]Project视图收藏夹、缩放视图不见
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Project切换为 One Column Layout则不可见
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/311cc4d55f33c2e487c6075a4bb72f72/" rel="bookmark">
			(动态规划)LC 最长递增子序列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 方法一：动态规划 用一个数组dp[i]来表示以nums[i]结尾的最长子序列的长度(必须包含nums[i])，则有以下转移式：
d p [ i ] = m a x { d p [ j ] ∣ 0 &lt; = j &lt; i 且 n u m s [ i ] &gt; n u m s [ j ] } + 1 dp[i] = max\{dp[j] | 0 &lt;= j &lt; i 且nums[i]&gt;nums[j]\} + 1 dp[i]=max{dp[j]∣0&lt;=j&lt;i且nums[i]&gt;nums[j]}+1
如果对所有的nums[j]都大于nums[i]，则dp[i]=1
public int lengthOfLIS(int[] nums) { int len = nums.length; int[] length = new int[len]; Arrays.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/311cc4d55f33c2e487c6075a4bb72f72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03ee162dce1f68942f5fe9b58fccf04b/" rel="bookmark">
			springboot拦截器，过滤器完成请求参数的获取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.自定义拦截器 package com.impl.modelserver.common.config.interceptor; import com.alibaba.fastjson.JSON; import com.impl.modelserver.po.CheckNamespaceLegalParam; import com.impl.modelserver.service.IModelService; import java.util.Map; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.core.annotation.Order; import org.springframework.stereotype.Component; import org.springframework.util.StreamUtils; import org.springframework.web.method.HandlerMethod; import org.springframework.web.servlet.HandlerInterceptor; /** * Description: 请求拦截器 * * @version 1.0 @ClassName RequestInterceptor @Author xulei * @date 2021/3/2 17:42 */ @Component @Order(1) public class RequestInterceptor implements HandlerInterceptor { private final Logger logger = LoggerFactory.getLogger(RequestInterceptor.class); private static final String GET_METHOD = "GET"; private static final String POST_METHOD = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03ee162dce1f68942f5fe9b58fccf04b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abfae52a4d02af4c684b308c1401ee77/" rel="bookmark">
			Object.prototype.hasOwnProperty.call()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前判定是否含有该key的方法一直是 !!obj[key] 后面看到了更加规范的,记录下
JavaScript中Object对象原型上的hasOwnProperty() 用来判断一个属性是定义在对象本身而不是继承自原型链。
从console的test可以看出来,它可以判定该key是否存在于object中.但是既然这样可以实现,为什么还要使用Object.prototype.hasOwnProperty.call() 这么复杂的写法呢.
这个test可以看出来,明明a是object的属性,为什么返回是false呢? 因为javascript没有将hasOwnProperty作为一个敏感词，所以我们很有可能将对象的一个属性命名为hasOwnProperty，这样一来就无法再使用对象原型的 hasOwnProperty 方法来判断属性是否是来自原型链。
Object.prototype.hasOwnProperty.call(Object,key) 这样一来,就可以准确判断了.
Enhance ES6也可以使用Refect.get 或者Refect.has
https://es6.ruanyifeng.com/#docs/reflect
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f6cd36c5684428499dc4e7842552c99/" rel="bookmark">
			如何将VMware workstation软件的语言切换成中文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何将VMware workstation软件的语言切换成中文
第一次的新手使用VMware workstation软件时候本来就对软件不是很熟悉，这时候程序还是英文的更加对学习增加了难度。
那么如何进行修改呢？
解决办法 修改区域：
这里的修改区域修改的是你自己电脑设置里面的区域
不是VMware软件里面的设置
有时候电脑的默认位置是新加坡这时候你的虚拟机软件默认的语言就是英文
打开控制与面板
打开控制与面板里面的时间地点和区域选项
修改区域为中国
此时将VMware软件关闭重新打开，软件语言就自动变成中文了
这些操作都是在软件外面的本机操作的，不是在软件内操作的
对于VMware软件只做了重新打开这一个操作
不要再VMware软件里面做这些操作
（我就是从VMware软件里面进行操作，怎么也找不到到底在哪里设置）
我使用的版本是11版本的，这个版本提供zh_ch的文件提供汉语支持
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33c7f4d1a6c5bc49631252a44db0f4c9/" rel="bookmark">
			Java BufferedImage转换为MultipartFile
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java里读取图片或调整图片大小可使用BufferedImage进行操作（参考我另一篇文章Java修改图片大小尺寸），但有时候我们需要将BufferedImage转为MultipartFile进行其他操作可如下转换：
方法一： 1.新建ConvertToMultipartFile类实现MultipartFile接口 import org.springframework.web.multipart.MultipartFile; import java.io.*; public class ConvertToMultipartFile implements MultipartFile { private byte[] fileBytes; String name; String originalFilename; String contentType; boolean isEmpty; long size; public ConvertToMultipartFile(byte[] fileBytes, String name, String originalFilename, String contentType, long size) { this.fileBytes = fileBytes; this.name = name; this.originalFilename = originalFilename; this.contentType = contentType; this.size = size; this.isEmpty = false; } @Override public String getName() { return name; } @Override public String getOriginalFilename() { return originalFilename; } @Override public String getContentType() { return contentType; } @Override public boolean isEmpty() { return isEmpty; } @Override public long getSize() { return size; } @Override public byte[] getBytes() throws IOException { return fileBytes; } @Override public InputStream getInputStream() throws IOException { return new ByteArrayInputStream(fileBytes); } @Override public void transferTo(File dest) throws IOException, IllegalStateException { new FileOutputStream(dest).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33c7f4d1a6c5bc49631252a44db0f4c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1814a095e8215811cce80edc855be8f/" rel="bookmark">
			Office 2019 for Mac激活失败，显示未找到许可证怎么办？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无法激活office 2019？office 2019激活后提示找不到许可证？今日小编找到一个解决办法：原来是在启动程序中注册了office的授权系统监控程序“com.microsoft.office.licensingV2.helper”，但是因为用户将其禁用了，导致Office不能激活，下面小编还教你怎么重新启动：一起来看看吧！一、安装App Cleaner &amp; Uninstaller 7.3
▪其它Mac系统清理软件没有系统监控程序的扫描和移除功能，所以现在要推荐大家下载 App Cleaner &amp; Uninstaller，而且需要7.0之后的版本，才有此功能。二、扫描并启动com.microsoft.office.licensingV2.helper 服务
▪打开软件后，在左侧菜单栏，点击启动程序，然后在右侧列表中的系统监控程序一栏中找到com.microsoft.office.licensingV2.helper，鼠标点击此行，然后在右侧点击启动按钮，在弹出窗口中输入你的开机密码即可，可参考下方图片示例：三、启用后重启电脑再重新激活补丁，就可以正常激活了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0d26ec4f6694902cb8897eb273304cb/" rel="bookmark">
			C&#43;&#43;实现简单的RSA加密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;iostream&gt; #include &lt;stdio.h&gt; using namespace std; int primeNum(int num);//判断素数 int coprime(int a, int b);//判断互素 int candp(int a, int b, int c); //计算密文 int key();//生成密钥 int encryption();//加密 int decode();//解密 int main() { cout &lt;&lt; "RSA加密算法"&lt;&lt;endl; while (1) { cout &lt;&lt; "---------------------------" &lt;&lt; endl; cout &lt;&lt; "请选择功能"&lt;&lt; endl; cout &lt;&lt; "1--生成密钥"&lt;&lt; endl; cout &lt;&lt; "2--加密"&lt;&lt; endl; cout &lt;&lt; "3--解密"&lt;&lt; endl; cout &lt;&lt; "4--退出"&lt;&lt; endl; cout &lt;&lt; "---------------------------" &lt;&lt; endl; int i = 0; cin &gt;&gt; i; switch (i) { case 1: key(); break; case 2: encryption(); break; case 3: decode(); break; case 4: exit(0); default: cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0d26ec4f6694902cb8897eb273304cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ade14418ee94f097fb0ba49c94e4f56/" rel="bookmark">
			BSO：头脑风暴优化算法-综述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BSO：头脑风暴优化算法-综述 参考文献
《Brain storm optimization algorithm: a review》
一、介绍
群智能算法应具有两种能力：学习能力和开发能力。开发能力侧重于将算法的搜索移至可能存在更高搜索潜力的区域，而学习能力则侧重于从当前解中精确搜索基于单点的优化算法，并从当前种群中进行基于群体的群体智能算法的搜索。
开发能力是一种顶层学习或宏观学习方法。它描述了一种算法的学习能力，可以根据要解决的问题的搜索状态来自适应地更改其参数、结构和学习潜力。换句话说，开发能力是算法拥有的搜索强度。学习能力是底层学习或微观学习。学习能力描述了算法从具有自己的学习能力的当前解中找到更好的解的能力。 BSO算法有两个主要的算子：收敛算子和发散算子。通过解在搜索空间中的收敛和发散，可以获得足够好的最优值。新的解是通过集群或现有解的变异生成的。开发能力是搜索过程中的适应性，是BSO算法中的另一个共同特征。
二、头脑风暴优化算法：发展史
1、基本头脑风暴优化算法
原始BSO算法概念简单、易于实现，由算法1给出，主要有三种策略：解集群、生成新个体和选择。
在BSO中，解分为几个集群，如果新生成的相同指标的解更好，则将保留总体最好的解。新个体可以基于集群中的一个或两个个体来生成。当新个体无限接近最优解时，开发能力得到提高，当新个体是随机生成的或由两个集群中的个体生成的，探索能力得到了提高。
BSO是一种搜索空间缩减算法，所有解最终都会进入几个集群，这些集群表明问题的局部最优值。一个区域的信息包含从一个集群到另一个集群传播的具有良好适应性值的解。该算法首先在决策空间中进行探索，迭代后可以将探索和开发达到一种平衡状态。
2、解集群
解集群的目的是将解收敛到较小的区域。在BSO中可以使用不同的聚类算法，原始的BSO中采用了基本的k-means聚类算法。
聚类是将相似对象分组在一起的过程，从机器学习的角度来看，聚类分析有时被称作无监督学习。给定n个点，可以通过点之间的相似度计算获得有用的模式。BSO中每个解都在搜索空间中传播。
3、新个体生成
新个体生成的过程在算法3中给出。可以基于一个或几个个体或集群来生成新个体。在原始的头脑风暴优化算法中，概率值pgeneration用于确定一个或两个“老”个体生成的新个体。从一个集群中生成一个个体可以优化搜索区域，并提高开发能力。相反，由两个或多个集群生成的个人可能离这些集群很远。在这种情况下，探索能力得到了增强。
用于确定聚类中心或另一个正常（或非聚类中心）个体的概率poneCluster和概率ptwoCluster将分别在一个聚类或两个聚类生成情况下选择。在一个集群生成的情况下，来自中心的新个体或正常个体可以控制开发区域。在几个集群的情况下，正常个体可以增加群体的种群多样性。
根据下式生成新个体。
其中，i表示维度；rand()生成[0, 1}之间的均匀分布随机数；xold由一个个体或两个个体组合形成；参数T是最大迭代次数，t是当前迭代次数，c是改变logsig()函数步长函数ξ(t)的斜率的系数，可以平衡算法的收敛速度。
BSO算法中的新个体生成，a从一个父代生成新个体，b从两个父代生成新个体
4、选择
选择策略可用于在所有个体中保持良好的解。每个新的个体生成后，选择策略都会保留更好的解，而聚类策略和新个体生成策略会将新的解添加到群体中，以保持整个种群的多样性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75820c1d208fae8d14ddc192d7d284b9/" rel="bookmark">
			node.js 安装和配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考： https://www.cnblogs.com/feiye512/p/12539306.html
下载地址：https://nodejs.org/zh-cn/
第一步：下载 nodeJS安装包
第二步：双击运行下载后安装包
第三步：指定node的安装路径，点击下一步
第四步：可以选择 Add to PATH 将node直接添加到环境变量中，点击下一步，安装
Node.js runtime 运行环境 npm package manager npm包管理器 online documentation shortcuts 在线文档快捷方式 Add to PATH 添加环境变量 到了这一步nodeJS基本安装完成了
如果我们没有不确定有没有配置好环境变量，可以通过下面的方式查看环境变量：
第五步：环境变量配置
安装好之后，找到我们安装的位置，看一下node安装之后的目录、
步骤：计算机 —— 右键属性 —— 高级系统设置 —— 环境变量 —— 系统变量 —— 点击Path —— 编辑
看一下有没有配置node的路径，如果没有的话，就点击 新建，将node的安装目录添加进去就可以了。参考下图：
第六步： 检验node安装
完成上面的步骤之后，可以打开cmd命令窗口来检验node时候安装成功
因为新版本的node自带npm，所以也可以通过 npm -v 查看npm版本号
第七步：修改包路径
默认情况下，我们在执行npm install -g XXX 是，下载一个全局包，这个包默认存放路径为：
C:\Users\Administrator\AppData\Roaming\npm\node_modules
可以通过命令 npm root -g 查看全局包的安装路径
通常我们都会把node安装在 除 C 盘以外的其他位置，全局的包也希望能放在node安装目录下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75820c1d208fae8d14ddc192d7d284b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba11b6f119056b971cf46d686fcda1c3/" rel="bookmark">
			SHELL脚本--定时删除日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建删除脚本
创建一个 deletelog.sh 文件，内容如下
#!/bin/bash find /root/test/ -mtime +30 -name "*.log" | xargs -i mv {} /root/RecycleBin/; find /root/RecycleBin/ -name "*.log" -exec rm -rf {} \; 解读文件中的第一条命令：
find /root/test/ -mtime +30 -name "*.log" | xargs -i mv {} /root/RecycleBin/; find 」查找
「 /root/test/ 」指定的目录
「 -mtime +30 」30天前的（天数可自定义）
「 -name “*.log” 」所有.log结尾的文件
「 | xargs -i mv {} 」xargs能够捕获一个命令的输出，然后传递给另外一个命令。这里的作用是把find找出的日志文件交给mv命令移动到目标目录。
「 /root/RecycleBin/ 」目标目录
整条命令的意思：查找 /root/test/ 目录下 30 天前的所有以 .log 结尾的文件，然后将它们移动到 /root/RecycleBin/ 目录下。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba11b6f119056b971cf46d686fcda1c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d65cb7929eed66bb4ca46d5727582d01/" rel="bookmark">
			adf机器_智能运维高招 | 基于机器学习的磁盘故障预测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原标题：智能运维高招 | 基于机器学习的磁盘故障预测
导读
RGF算法+迁移学习精确预测硬盘故障。《Predicting Disk Replacement towards Reliable Data Centers》由IBM研究院发表于数据挖掘顶会议KDD 2016。磁盘是当今数据中心中最常见的硬件设备，也是最易发生故障的设备。
尽管有如RAID的防御机制，系统的可用性和可靠性仍然经常严重冲击。 本文采用RGF算法和迁移学习精确预测硬盘故障从而判断硬盘是否应该更换。其方法对硬件设备的故障预测有借鉴意义。
互联网迅速发展，网络服务数量骤增， 大规模海量数据存储系统是必不可少的支持。虽然新的存储介质例如SSD，已经在读性能等很多方面拥有了比磁盘更好的性能，但就目前来讲，其高昂的花费使大部分数据中心难以负担。因此，大型数据中心依然采用传统的以磁盘为主的存储系统。这样做采购成本上虽然有了节省，但磁盘频繁损坏导致的数据丢失给企业带来的损失也是不可忽视的重大问题。
据美国63个数据中心组织进行的一项研究显示，数据中心的停机费用在过去几年中显著增加，从2010年的5600美元/分钟增加到2016年的8851美元/分钟。以往基于磁盘SMART属性建立的各种磁盘故障预测模型，虽然取得了一定的效果，但是其在SMART属性选择、准确性以及模型的复用性上存在不足之处。
因此，本文提出了一个自动、精确的磁盘故障预测的方法，判断磁盘在接下来一段时间内需不需要替换。下面两个图展示的是有无替换预测的磁盘可用性示意图。左图代表的是传统的磁盘异常检测，磁盘状态开始变差后才检测到磁盘故障，这时的可用性已经降到了最低才开始更换磁盘。右图展示的是使用磁盘故障预测的情况，首先系统判断磁盘的状态即将要变差，然后工程师在磁盘可用性降低之前更换磁盘。通过这两个图的对比，我们可以看出提前预测磁盘故障可以降低故障对系统可用性的冲击。
磁盘故障预测的挑战
但是，磁盘故障预测，存在如下挑战：
不是所有的SMART属性都与磁盘故障相关。因为缺乏SMART属性对磁盘状态指示的标准，所以需要从SMART属性中选择与一部分磁盘故障相关的属性，作为故障预测模型的输入。
磁盘故障数据高度不平衡。随着时间的推移，健康磁盘的SMART数据量一直在增加，但是只有一小部分磁盘(2%)被替换，即被替换的磁盘数据非常少。分类算法通常最大限度地提升整体精度，少数类所包含的信息就会很有限，从而难以确定少数类数据的分布，即在其内部难以发现规律，进而造成少数类的识别率低。
不同类型的磁盘SMART存在差异。SMART是特定于制造商的，它们的编码和标准化在制造商之间差别很大，所以不能使用同一个预测性模型来判断不同型号的磁盘。下面两个图展示的是不同类型磁盘的SMART数据差异，其中左图表示的是温度，右图表示的是开机关机的周期，从两个图的对比可以看出，不同类型的磁盘SMART确实存在差异。
设计思想
本文分为如下五步来解决故障预测的挑战：
选择SMART属性。使用突变点(changepoint)检测的方法对SMART属性分类，选择与磁盘替换相关的SMART属性。
生成时间序列。使用指数平滑来生成简化但是信息丰富的时间序列。
解决数据不平衡性。通过欠抽样(downsampling)选择具有代表性的健康磁盘的数据，然后用这些数据来代表全部的健康磁盘，从而使健康磁盘与替换磁盘的比例达到平衡。
对磁盘状态分类。RGF是一个分类算法，可以将磁盘的状态分成0/1的状态，如果当前时间序列被分成1状态，则认为磁盘即将出现故障，需要更换磁盘。
迁移学习。考虑到同一厂商生产的不同磁盘模型之间也存在一定差异，本文使用了迁移学习的方法，从而利用某种磁盘上训练的模型来预测同一厂商的其他磁盘的故障替换情况。
1、选择SMART属性
因为SMART数据是随着时间的增长而生成的，所以文中是通过时间序列突变点(changepoint)检测来确定SMART与磁盘替换的相关性。当被替换的磁盘SMART时间序列中某个SMART属性发生突变，而且这个转变是永久性不可恢复的，那么可以认为这个属性与磁盘替换是相关的。
下图展示的是SMART_187_raw(无法纠正的错误)的折线图，这是报告给操作系统的无法通过硬件ECC校正的错误。如果数据值不为零，就应该备份磁盘上的数据了。从图中可以看出在第50天的时候，SMART_187_raw值突然增大，即第50天为突变点。
通过检测每一个SMART属性，本文得到了下表中展示的结果(只展示部分结果)。在表格中，SgtA和HitA分别表示希捷和日立的磁盘型号，Ratio表示磁盘替换前该属性值出现突变的比例。我们可以看出有些SMART属性确实与磁盘替换无关，而且对于不同型号的磁盘，与磁盘替换事件相关的SMART属性是不相同的。
2、生成时间序列
经过第一步的SMART属性值的挑选，下一步需要做的是生成预测模型可以使用的时间序列。使用时间序列作为模型的数据是基于如下三点考虑的：
每天的数据都是不稳定的，可能某天的SMART数据缺失。
磁盘具有一定的自恢复性，不能根据某一天的数据来判定磁盘接下来一段时间的状态。
如果只看某一天的数据，则无法提前一段时间来预测磁盘故障，也就无法留出充足的时间给工程师更换磁盘。
所以本文使用指数平滑的方法来生成时间序列，S_t=α·Y_t+(1-α)·S_(t-1)是指数平滑的公式，其中α是平滑参数，Y_t是之前t个数据的平滑值。α越接近1，平滑后的值越接近当前时间的数据值。指数平滑不舍弃过去的数据，而是仅给予逐渐减弱的影响程度，即随着数据的远离，赋予逐渐收敛为零的权数。
3、解决数据不平衡性
遇到不平衡数据时，以总体分类准确率为学习目标的传统分类算法会过多地关注多数类，而使少数类样本的分类性能下降。因为这些算法大多数建立在各类数据分布平衡的假设之下，以寻求数据总体分类准确率为最大目标。而在磁盘故障预测的场景下，磁盘故障的数量是远远小于正常磁盘的。本文使用了欠抽样(downsampling)的方式来平衡数据。
具体做法是这样的，对健康磁盘的时间序列样本做K-means聚类，聚类之后每一个类别中样本都是相似的，然后选择距离聚类中心最近的n个点作为健康磁盘样本的抽样结果。
4、对磁盘状态分类
本文使用了RGF算法对磁盘状态分类。RGF 算法是一个分类算法，它是GBDT(梯度提升决策树)算法最好的变种之一。针对 GBDT 每次迭代只优化新建树以及过拟合的问题，RGF使用了正则化的全局优化贪心搜索改进算法：
每次迭代直接对整个贪心森林进行学习
新增决策树后进行全局的参数优化
引入显式的针对决策树的正则项来防止过拟合
文中对比了RGF与其他分类算法的分类结果，上表中的P、R、F分别表示准确率(precision)、召回率(recall)、F-分数(F-score)。从表中可以看出，RGF的效果是最好的。
5、迁移学习
同一厂商生产的不同磁盘模型之间也是存在差异的。本文发现，不同磁盘模型之间具有相似的SMART属性，但相同的SMART属性之间的数据分布不同。因此，直接将训练集磁盘模型上建立的预测模型用于同一厂商生产的其他磁盘模型的故障预测，不能达到最好的预测效果。
首先我们来说明迁移学习中的两个重要概念，域(domain)和任务(task)。如下图所示。
域(domain)：包括特征空间(feature space)X和边缘概率分布(marginal probability distribution)P(x), x ∈X。例如，一组图片中的所有可能颜色构成一个特征空间，而各种颜色出现的频率则为边缘概率分布。
任务(task)：给定一个域，任务还包含两个要素，标签空间(label space)y和预测函数(predictive function)f(·)=P(y|x)。例如，一组图片中可能出现的所有元素构成一个标签空间，而通过预测函数可以得出某幅特定图片中包含哪些元素。
同一厂商生产的不同磁盘模型之间具有一定的关联性，但它们之间存在样本选择偏差(sample selection bias)。即不同种磁盘模型之间虽然具有大量的重叠特征，但源数据实例(带标签的训练数据)和目标数据实例(无标签的测试数据)的分布不同。因此，作者采用了基于实例的迁移学习方法来消除源数据和目标数据之间的样本选择偏差，从而将某种磁盘上训练的模型应用于其他磁盘上。
具体的，对于两种磁盘模型1和2，将带标签的磁盘1实例与无标签的磁盘2实例放在一起。训练一个分类函数，使f(x)表示一个磁盘属于模型1或模型2的概率。利用分类函数f对带标签的训练数据集进行重新采样，从而消除样本选择偏差，使训练集与测试集数据服从同一分布。此时，根据重新采样的训练集，利用前文所述的RGF算法训练出函数，g(x)代表该类型磁盘的一个实例需要进行替换的概率。由于重新采样的训练集与测试集服从相同的数据分布，因此可将预测函数g直接应用于同一厂商生产的其他磁盘模型上(测试集)。
作者分别使用两个厂商生产的磁盘的数据集SgtA和HitA训练模型，并使用迁移学习的方法将两种模型分别应用于同厂商的其他磁盘数据集SgtB和HitB上。上表分别展示了直接将模型 A应用于磁盘B上以及运用迁移学习方法将模型A应用于磁盘B的替换预测的准确率、召回率、F-分数。可以看出，应用迁移学习方法后，预测准确性得到了很大提高，从而大大减少了需要训练的模型数量。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d65cb7929eed66bb4ca46d5727582d01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b2bf2575fdb3c02e23e183005b77507/" rel="bookmark">
			【CC2530入门教程-02】CC2530的通用I/O端口输入和输出控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【CC2530入门教程-06】CC2530的ADC工作原理与应用
【CC2530入门教程-05】CC2530的串行接口原理与应用
【CC2530入门教程-04】CC2530的定时/计数器原理与应用
【CC2530入门教程-03】CC2530的中断系统及外部中断应用
【CC2530入门教程-02】CC2530的通用I/O端口输入和输出控制
【CC2530入门教程-01】CC2530微控制器开发入门基础
一、CC2530的引脚概述 CC2530微控制器采用QFN40封装，有40 个引脚。其中，有21个数字I/O端口，其中P0和P1是8 位端口，P2仅有5位可以使用。这21个端口均可以通过编程进行配置。实际上，在P2端口的5个引脚中，有2个需要用作仿真，有2个需要用作晶振，你在CC2530的开发中真正能够使用的只有17个引脚。
在微控制器内部，有一些特殊功能的存储单元，这些单元用来存放控制微控制器内部器件的命令、数据或运行过程中的一些状态信息，这些寄存器统称为“特殊功能寄存器（SFR）”。操作微控制器的本质，就是对这些特殊功能寄存器进行读写操作，并且某些特殊功能寄存器可以位寻址。
每一个特殊功能寄存器本质上就是一个内存单元，而标识每个内存单元的是内存地址，不容易记忆。为了便于使用，每个特殊功能寄存器都会起一个名字，在程序设计时，只要引入头文件“ioCC2530.h”，就可以直接使用寄存器的名称访问内存地址了。
CC2530的通用I/O端口相关的常用寄存器有下面4个：
&lt;1&gt; PxSEL：端口功能选择，设置端口是通用I/O还是外设功能。
&lt;2&gt; PxDIR：作为通用I/O时，用来设置数据的传输方向。
&lt;3&gt; PxINP：作为通用输入端口时，选择输入模式是上拉、下拉还是三态。
&lt;4&gt; Px：数据端口，用来控制端口的输出或获取端口的输入。
二、设置寄存器中某些位的方法 &lt;1&gt; 对寄存器的某些位清0而不影响其他位。 例如：寄存器P1TM的当前值是0x6c，现需要将该寄存器的第1位、第3 位和第5位设置为0，同时不能影响该寄存器其他位的值，那么，在C语言中应该怎么编写代码呢？
使用“&amp;=”将寄存器指定位清0，同时不影响其他位的值。
正确写法：P1TM &amp;= ~0x2A；
因为：逻辑“与”操作的特点是，该位有0结果就为0，若为1则保存原来值不变。
首先将字节 0000 0000 中要操作的位设置为1，即0010 1010，在将该数值取反，即1101 0101，也就是~0x2A。再将该值与寄存器P1TM“相与”，那么有0的位，即1、3、5位将被清0，其余的位会保持原来的值不变。
所以：P1TM的当前值为0x6c，即0110 1100，
0110 1100 &amp;&amp; 1101 0101 = 0100 0100，即1、3、5位清0，其他位不变。
&lt;注意&gt;：该方法只能操作多位同时清0，或者某一位清0的情况，如果要将寄存器的位既要清0又要置1，则不能采用这种写法。（其中原因自己思考一下）
在不少嵌入式应用的源码程序中，对于寄存器的第n位的清0操作也可以写成：寄存器 &amp;= ~(0x01&lt;&lt;(n))；其道理是一样的。
&lt;2&gt; 对寄存器的某些位置1而不影响其他位。 例如：寄存器P1TM的当前值是0x6c，现需要将该寄存器的第1位、第4位和第5位设置为1，同时不能影响该寄存器其他位的值，那么，在C语言中应该怎么编写代码呢？
使用“|=”将寄存器指定位置1，同时不影响其他位的值。
正确写法：P1TM |= 0x32；
因为：逻辑“或”操作的特点是，该位有1结果就为1，若为0则保存原来值不变。
首先将字节 0000 0000 中要操作的位设置为1，即0011 0010，也就是0x32。 再将该值与寄存器P1TM“相或”，那个有1的位，即1、4、5位将被设置为1，其余的位会保持原来的值不变。
所以：P1TM的当前值为0x6c，即0110 1100，
0110 1100 || 0011 0010 = 0111 1110，即1、4、5位置1，其他位不变。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b2bf2575fdb3c02e23e183005b77507/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c7b1fe7ab31b001ee31d3e76a903030/" rel="bookmark">
			Android  关于.9图设置拉伸区域无效问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目中闪屏页面用到.9图片，但添加后并没有起作用，困扰了我一天.
解决问题：
1.如果.9在 drawable-hdpi 文件下不起作用，请移动到 drawable-xhdpi 文件下 ，以此类推，或者 移动到 drawable-xxhdpi 、drawable-xxxhdpi 文件下 都试一下。
2.建议每个分辨率文件下都放一个.9图，注意 图片名字一定要一致，这样才能各个机型都能够适配。
注意：
当.9图放在不同分辨率的文件下时，一定要让UI设计师出一套各个分辨率的图。而不是一张大小的图放在各个文件下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5833284ee0d0f954782786504766bf7/" rel="bookmark">
			hadoop之hdfs分布式文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		架构 HDFS是一个主从(Master/Slaves)架构
由一个NameNode和一些DataNode组成
面向文件包含：文件数据(data)和文件元数据(metadata)
NameNode：负责存储和管理文件元数据，并维护了一个层次型的文件目录树
DataNode：负责存储文件数据(block块)，并提供block的读写
DataNode与NameNode维持心跳，并汇报自己持有的block信息
Client和NameNode交互文件元数据和DataNode交互文件block数据
角色（角色即进程） NameNode
1）完全基于内存存储文件元数据、目录结构、文件block的映射
2）需要持久化方案保证数据可靠性
3）提供block副本放置策略
DataNode
1）基于本地磁盘存储block(文件的形式)
2）并保存block的校验和数据保证block的可靠性
3）与NameNode保持心跳，汇报block列表状态
SecondaryNameNode（SNN）
1）在非Ha模式下，SNN一般是独立的节点，周期完成对NN的EditLog向FsImage合并，减少EditLog大小，减少NN启动时间
2）根据配置文件设置的时间间隔fs.checkpoint.period 默认3600秒
3）根据配置文件设置edits log大小 fs.checkpoint.size 规定edits文件的最大值默认是64MB
存储模型 文件线性按字节切割成块(block)，具有offset，id
文件与文件的block大小可以不一样
一个文件除最后一个block，其他block大小一致
block的大小依据硬件的I/O特性调整
block被分散存放在集群的节点中，具有location
Block具有副本(replication)，没有主从概念，副本不能出现在同一个节点，副本是满足可靠性和性能的关键
文件上传可以指定block大小和副本数，上传后只能修改副本数
一次写入多次读取，不支持修改，支持追加数据
block副本放置策略 1）第一个副本：放置在上传文件的DN；如果是集群外提交，则随机挑选一台磁盘不太满，CPU不太忙的节点
2）第二个副本：放置在于第一个副本不同的 机架的节点上
3）第三个副本：与第二个副本相同机架的节点
4）更多副本：随机节点
数据持久化 数据持久化一般有以下两种方案：
1）日志文件：记录实时发生的增删改查
优点：数据完整性好
缺点：加载恢复数据慢，占用内存空间大
2）镜像、快照、dump、db、序列化：间隔（秒、分钟、小时），内存全量数据基于某个时刻做的数据快照，
优点：恢复数据快
缺点：IO慢，容易丢失数据
hdfs 选择了1和2方案结合的方式，充分利用其各自优点
NN 使用了FsImage+EditLog整合的方案，本地磁盘保存 EditLog 和 FsImage
滚动将增量的EditLog更新到FsImage，以保证更近时点的FsImage和更小的EditLog体积
Editslog：日志文件 体积小，记录少
FsImage：镜像、快照 更快的滚动更新时点
例如：现在是10点，HDFS存储的是：FI（9点）快照+ EL（9-10点）日志，此时如果宕机，恢复数据时则是先加载FI、然后加载EL就会得到之前的全量数据
安全模式 HDFS搭建时会格式化，格式化操作会产生一个空的FsImage
当NameNode启动时，它从硬盘中读取Editlog和FsImage
将所有Editlog中的事务作用在内存中的FsImage上
并将这个新版本的FsImage从内存中保存到本地磁盘上
然后删除旧的Editlog，因为这个旧的Editlog的事务都已经作用在FsImage上了
NameNode启动后会进入一个称为安全模式的特殊状态，处于安全模式的Namenode是不会进行数据块的复制的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5833284ee0d0f954782786504766bf7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d1b457934bd0394f4488e5229652300/" rel="bookmark">
			LeetCode之二分查找之旋转数组系列题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		旋转数组 1、旋转数组（189）2、寻找旋转数组中的最小值（153）3、寻找旋转数组中的最小值II（154）4、搜索旋转排序数组（33）5、搜索旋转排序数组II（81）6、面试题10.03 搜索旋转数组 1、旋转数组（189） 题目描述：
【中等题】
给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。
进阶：
1、尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。
2、你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？
示例一：
输入: nums = [1,2,3,4,5,6,7], k = 3 输出: [5,6,7,1,2,3,4] 解释: 向右旋转 1 步: [7,1,2,3,4,5,6] 向右旋转 2 步: [6,7,1,2,3,4,5] 向右旋转 3 步: [5,6,7,1,2,3,4] 题目链接
思路分析：
1、当我们将数组的元素向右移动 k 次后，尾部 k m o d n k\bmod n kmodn个元素会移动至数组头部，其余元素向后移动 k m o d n k\bmod n kmodn个位置。
2、该方法为数组的翻转：我们可以先将所有元素翻转，这样尾部的 k m o d n k\bmod n kmodn个元素就被移至数组头部，然后我们再翻转 [0, k m o d n k\bmod n kmodn-1]区间的元素和 [ k m o d n k\bmod n kmodn, n-1]区间的元素即能得到最后的答案。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d1b457934bd0394f4488e5229652300/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7705d2dab64ab0850c9b24b328e0929b/" rel="bookmark">
			整合Knife4j生成文档后端接口文档出现404无法找到doc.html
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、使用场景
2、错误原因解析
3、Knife4jorSwaggerUI配置
4、呈现效果或者swagger-ui与knife4j可以切换
5、参考文章
1、使用场景 最近自己在总结搭建一个统一数据后端的基础框架，在整合knife4j的时候出现了无法找到doc.html页面的问题。其中目前网上解决方案都是统一的一种模式，
在应用启动里面实现(implements WebMvcConfigurer)。
2、错误原因解析 因为我使用的 继承(extends WebMvcConfigurationSupport),新旧版本SpringBoot配置文件 WebMvcConfigurationSupport类 和 WebMvcConfigurer接口之间有冲突。
因为我写了一个返回后端数据统一注解ResponseResult，需要在WebMvcConfigurer/WebMvcConfigurationSupport 注入拦截器。同时考虑到不破坏启动之中类干净
显示内容，于是想到自己定义一个@Configuration类WebAppMvcConfig,去实现WebMvcConfigurer，这样就能够解决我响应结果拦截器ResponseResultInterceptor的注入，
同时比较友好的加入Knife4j的doc.html，以及swagger-ui.html页面友好显示。同时也解决了Knife4j显示404的问题。具体类如下所示：
import cn.hutool.core.date.DatePattern; import com.whdcmap.common.response.ResponseResultInterceptor; import org.springframework.context.annotation.Configuration; import org.springframework.format.FormatterRegistry; import org.springframework.format.datetime.standard.DateTimeFormatterRegistrar; import org.springframework.web.servlet.config.annotation.InterceptorRegistry; import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; import java.time.format.DateTimeFormatter; /** * @Description TODO * @Classname Knife4jWebMvcConfig * @Date 2021/3/2 15:27 * @Created by jianxiapc */ @Configuration public class WebAppMvcConfig implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { /** * 注册自定义的显示 ResponseResult 注解的拦截器 */ registry.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7705d2dab64ab0850c9b24b328e0929b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/586819ebd22e4c3390a4cf17b18c7f58/" rel="bookmark">
			esxi6.7的直通
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是直通(Passthrough)
VT-d 、DirectPath I/O，通过 DirectPath I/O，虚拟机可以使用 I/O 内存管理单元访问平台上的物理 PCI 功能，就是俗称的虚拟化直通，简单理解就是允许宿主机将某些硬件资源的管辖权直接移交给虚拟机，虚拟机会以直通独占的方式使用硬件，宿主机将不能再使用此硬件，利用效率几乎等同于将硬件插到了虚拟机的主板扩展槽里一样，最实用的目的是避免了虚拟化平台自身软件层转换带来的效能下降。
典型应用场景，例如在服务器上将某个物理网卡直接划给某台虚拟机使用，以达到几乎和物理机搭配物理网卡类似的网络性能。更可观的场景是，将磁盘控制器直通给虚拟机独占使用，那么虚拟机往往最瓶颈的磁盘性能，将得到非常可观的提升。
二、开启直通的必要条件
AMD/Intel CPU支持VT-D，同时主板要开启VT-D支持。
三、查看ESXI支持直通的PCI设备
安装ESXI６.７操作系统（略）
安装win10虚拟机，在虚拟机里面安装好系统，先安装VMtools
登入ESXi的网页后台，点击左侧的 “管理” – “硬件” – 左下角将筛选条件修改为“支持直通”，即可看到可以直通的 PCI 设备。
四、添加ESXI支持直通的PCI设备
将需要直通的设备左侧打勾后点击上方的 “切换直通” 按钮后，重启ESXI即可将 PCI 设备直通给虚拟机
列表中，“直通” 一列为 “活动” 的则为已经直通的设备。
注意：如果这个时候你的pci选项是灰色的，那么可能是你的主板没有设置好，如果主板参数已经设置了，需要检查一下pci设备的状态，如果不是活动的，需要将显卡勾选上在进行切换直通，最后重新引导主机。
**&gt; 如是灰色情况参照如下 ：
将独立输出禁用，只允许板载输出（不同的主板参考主板配置手册） 编辑虚拟机，在虚拟机里面添加PCI直通设备
右击虚拟机-编辑设置-添加其他设备-PCI设备-记录设备ID（0000:xx:xx:x）（根据通道进行添加，如果是4
通道则添加4个PCI设备） 开启SSH服务，编辑配置文件 管理-服务-启动SSH-使用命令进行编辑 vi
/etc/vmware/esx.conf 在末尾添加一行 /device/0000:xx:xx:x/owner = “passthru”
右击虚拟机-虚拟机选项-高级-配置参数-编辑配置-添加参数-hypervisor.cpuid.v0 值FALSE-保存
解释一下：hypervisor.cpuid.vo=FALSE的作用是启用独显，不加这一行设备管理器中独显会报出 代码43的错误。也有可能会发生这种情况，需要安装驱动 这个时候不建议驱动精灵 要么win10自动检测下载 要么官网找对版本型号下载
重启ESXI主机~~~~**
给虚拟机添加直通的设备
选择待添加PCI设备的虚拟机，右键编辑虚拟机，点击“添加其他设备” – “PCI”设备，选中已直通的设备，保存编辑即可。
键盘鼠标直通
鼠标键盘直通 和显卡直通的操作一样，就是将硬件中USB相关的都直通，因为主机多个USB端口，你把鼠标和键盘插上也不知道对应哪一个端口。然后再添加PCI设备，这个慢慢尝试吧可以走通。
USB直通
USB不用设置直通 将USB设备插入主机后，直接添加USB设备就可以了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/586819ebd22e4c3390a4cf17b18c7f58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fbb1c7f0a7a3e8ab2cb0245118cd07d/" rel="bookmark">
			java threadpoolexecutor 实例_Java线程池（ThreadPoolExecutor）示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java线程池管理工作线程池，它包含一个队列，用于保持任务等待执行。我们可以使用ThreadPoolExecutor在Java中创建线程池。
Java线程池管理Runnable线程的集合。工作线程从队列中执行Runnable线程。java.util.concurrent.Executors为java.util.concurrent.Executor接口提供工厂和支持方法，以在java中创建线程池。
Executors是一个实用程序类，它还提供了通过各种工厂方法使用ExecutorService，ScheduledExecutorService，ThreadFactory和Callable类的有用方法。
下面编写一个简单的程序来解释它的工作原理。
首先，我们需要一个名为WorkerThread.java并实现Runnable接口的类。如下所示 -
public class WorkerThread implements Runnable {
private String command;
public WorkerThread(String s){
this.command=s;
}
@Override
public void run() {
System.out.println(Thread.currentThread().getName()+" Start. Command = "+command);
processCommand();
System.out.println(Thread.currentThread().getName()+" End.");
}
private void processCommand() {
try {
Thread.sleep(5000);
} catch (InterruptedException e) {
e.printStackTrace();
}
}
@Override
public String toString(){
return this.command;
}
}
ExecutorService示例
这是测试程序类 - SimpleThreadPool.java，从Executors框架创建固定线程池。
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
public class SimpleThreadPool {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1fbb1c7f0a7a3e8ab2cb0245118cd07d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/696039e3cad1376889327734258428c0/" rel="bookmark">
			我的世界java版forge怎么用_我的世界forge怎么安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的世界如果想要安装mod首先面临的问题就是必备的API组件，Forge是最常用的API之一，它以其超快的更新速度而闻名。所以很多玩家都关心我的世界forge怎么安装这个问题。下面小编就来详细介绍我的世界forge安装方法。
如果你的forge是一个rar或zip等压缩包，先解压，然后到MC文件夹找到minecraft.jar(位于.minecraft\bin文件夹里)，用压缩工具打开(是打开不是解压)，然后删除里面的Meta-INF文件夹(如果没有就算了)，最后把之前加压的forge所有文件拖到minecraft.jar里面。
注意：运行mc，forge自动下载需要文件把mod放进mods里，mods在刚才运行mc的时候，由forge自动创建了然后再运行mc。
到这里，我的世界forge就安装成功啦！
下面为大家举一个更具体的例子：
首先给大家提供一个1.7.2版本forge的下载链接。
内容如下：
1)Minecraft 1.7.2客户端；
2)Minecraft 1.7.2配套的开服器；
3)Forge API(就是使你多了个“mods”文件夹，方便安装mod)；
4)光影(可自行开启)，
附件解压后如图：
里面附带2个启动器：
mclauncher(旋律启动器，需要.NET组件)和Hello Minecraft! 启动器(有JAVA就可以运行)，请根据需要进行选择.
再介绍一下mod的安装：
请把mod文件复制到“mods”文件夹里面就可以。
如图：
(注意：原版的1.7.2是没有“mods”这个文件夹的，需要安装了API才有)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2a3a6f9ac54ee4563c2a8398c2dd898/" rel="bookmark">
			开发嵌入京东app h5| Hybrid | 微信小程序 ｜ 实践踩坑总结十六条
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 前言 笔者最近一直在开发京东app嵌入的h5项目和微信小程序商城项目，在此期间遇到很多坑。这篇文章主要是针对 h5| Hybrid | 微信小程序 三个方向来讲述我遇到的坑，以及详细讲解我是如何解决问题的。
一直以来，移动端适配就是一个令人头疼的问题。如果想要吃透移动端，还需要不少的实践经验，有的时候在pc端调试没有问题，但是在m端就会出现问题。以下这16个问题是我在实际工作中遇到的，亲自奉上给大家。希望大家收藏一波，以备不时之需。
喜欢笔者的可以「点赞 + 收藏 」 一波，持续更新前端硬核文章。
M端h5踩坑总结 以下是京东嵌入h5，h5落地页，遇到的问题。我用一个思维导图表示出来。
1 ios：:postion:fixed 定位抖动跳屏问题 背景 在开发京东app,Hybrid h5业务页面的时候，遇到一个非常棘手的问题，因为这个页面类似京东app商品详情页面的动画效果。 动画效果如下所示。安卓手机正常，但是ios手机出现，滑块抖动问题，图片会出现闪动的效果。这个问题困扰了很久，网上搜索了大量的解决方案，都没有实际解决问题，自己也尝试了几种方法，也没有成功，当时很奔溃😭😭😭，最后还是灵光一现，想到了一个巧妙的解决方案😂。
整个流程就是，当视图容器向上滑动的时候，商品卡片容器需要缓慢移动，首先需要将商品卡片需要脱离标准流，设置定位position:fixed 固定定位。然后控制top值来控制滑块的缓慢移动。但是在容器向上滑动的过程中，滑块会出现抖动，闪动的效果。
🤔分析这个原因，应该是ios对position表现不友好的原因，这种类似的原因在小程序里也很常见。
解决方案 网上搜索和自己探索的失败解决方案 ① 给顶级元素设置height:100% ( 并没有奏效 ) 。
② 增加 transform: translate(0) 属性 （ 并没有奏效 ）
③ 改变布局由fixed 定位,改成absolute定位，滚动条基于自身。（ 能够从根本上解决偶尔跳屏的问题，但是随之而来的就是ios 滚动条问题，基于document才能有效触发，遂放弃此方案）
④ 不改变布局的情况下，由fixed 定位,改成absolute定位，滚动条基于document,定位值完全取决于数据驱动。（能够从根本上解决偶尔跳屏的问题，但是随之而来的就是要不断改变自身的top值 ，导致更新会慢的情况 ，用户体验不好，流畅度欠佳，遂放弃此方案 ）
⑤ -webkit-overflow-scroll:touch解决滑动无惯性（ 并没有奏效 ）
⑥ background-attachment:fixed（ 并没有奏效 ）
解决方案 试了好久，终于想到了一个解决方法。继续使用 fixed 定位，因为我们这里需要通过定位，抖动不是单纯fixed定位的原因。和频繁改变top值也有很大关系。放弃改变top值 ，运用transform: translateY来使视图上下移动。
&lt;view class="scroll_box" style={{ transform:`translateY(${ top }px)` }} &gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2a3a6f9ac54ee4563c2a8398c2dd898/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9c924fe101de776008919b5ea3af254/" rel="bookmark">
			webpack 解析ts、tsx语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		修改tsconfig.json "jsx": "react" 要使用jsx语法,创建的文件必须是.tsx文件 1、解析ts、tsx语法(配置loader或使用Babel) 方式一:配置loader module:{ rules:[ 方式一:ts-loader { test:/\.tsx?$/, use:[ { loader:'ts-loader', options:{ transpileOnly: true,	只进行语法转换,不进行类型校验,提高构建速度 } } ], exclude:/node_modules/ } 方式二:awesome-typescript-loader 对比ts-loader好出: (1)更适合与babel集成,使用babel的转义和缓存 (2)使用自身提供的插件,就可以把类型检查放在独立进程中进行,但可能检查不出来 { test:/\.tsx?$/, use:[ { loader:'awesome-typescript-loader', options:{ transpileOnly: true,	只进行语法转换,不进行类型校验,提高构建速度 } } ], exclude:/node_modules/ } ] }, 方式二:使用Babel 缺点:Babel无法编译:命名空间、类型断言(只兼容as的语法,不兼容&lt;&gt;语法)、常量枚举、默认导出(export =语法) (1)下载依赖: @babel/cli @babel/core @babel/preset-env @babel/preset-typescript @babel/plugin-proposal-class-properties @babel/plugin-proposal-object-rest-spread (2)配置.babelrc文件: { "presets":[ "@babel/preset-env", "@babel/preset-typescript" ], "plugins":[ "@babel/plugin-proposal-class-properties", "@babel/plugin-proposal-object-rest-spread"	支持...剩余操作符和扩展操作符等 ] } (3)修改tsconfig.json "noEmit": true, 不输出ts文件,只做类型检查 (4)运行类型检查 tsc --watch 2、若采用loader,使用插件将类型检查放在独立进程中进行 (1)ts-loader: cnpm install -D fork-ts-checker-webpack-plugin plugins:[ new ForkTsCheckerWebpackPlugin()	使用插件进行类型校验 ] (2)awesome-typescript-loader: const { CheckerPlugin}= require("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9c924fe101de776008919b5ea3af254/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe7c611c01067179f84dd75f7f957731/" rel="bookmark">
			【STL】模拟实现STL中map容器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 模拟实现map需要理解的概念2. 模拟实现map 1. 模拟实现map需要理解的概念 STL中的map的底层数据结构是一个红黑树map 中存储数据是以key - value的形式存储的 2. 模拟实现map 以下代码可以运行的前提是，拥有红黑树的模拟实现中红黑树的代码
map.hpp
#include "RBTree.hpp"	// 红黑树的模拟实现 // map 中放置的是 K—V 模型 template&lt;class K, class V&gt; class map { typedef pair&lt;K, V&gt; ValueType; struct KOFP	// 为了方便红黑树中的插入：比较的是K而不是Pair结构体地址 { const K&amp; operator()(const ValueType&amp; data) { return data.first; } }; typedef RBTree&lt;ValueType, KOFP&gt; RBT; public: // iterator可能是红黑树中的类型，也可能是静态成员变量，需要显式说明 typedef typename RBT::iterator iterator; map() :_t(){} // iterator iterator begin() { return _t.begin(); } iterator end() { return _t.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe7c611c01067179f84dd75f7f957731/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51ba2268097ee7f3c45f6b8e6e6f277c/" rel="bookmark">
			Java的非虚方法_是否可以重写一个非虚方法？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不，您不能覆盖非虚拟方法。 你可以做的最接近的事情是通过创build一个同名的new方法来隐藏这个方法，但这不是可取的，因为它打破了良好的devise原则。
但是即使隐藏一个方法也不会给你执行时间的方法调用的多态调度，就像真正的虚拟方法调用一样。 考虑这个例子：
using System; class Example { static void Main() { Foo f = new Foo(); fM(); Foo b = new Bar(); bM(); } } class Foo { public void M() { Console.WriteLine("Foo.M"); } } class Bar : Foo { public new void M() { Console.WriteLine("Bar.M"); } }
在这个例子中，调用M方法print Foo.M 正如你所看到的，只要对该对象的引用具有正确的派生types，但是隐藏一个基本方法却会破坏多态性，这种方法确实可以让你有一个方法的新实现。
我build议你不要以这种方式隐藏基本方法。
我倾向于支持那些赞成C＃默认行为的方法，默认情况下方法是非虚拟的(与Java相对)。 我会更进一步说，class级也应该被默认密封。 inheritance是很难正确devise的，并且有一个方法没有被标记为虚拟的事实表明该方法的作者从来没有打算将该方法重写。
编辑：“执行时间多态调度” ：
我的意思是在调用虚拟方法时执行时发生的默认行为。 比方说，在我之前的代码示例中，我没有定义一个非虚方法，而是实际上定义了一个虚方法和一个真正的重写方法。
如果我在这种情况下调用b.Foo ，CLR会正确地确定b参考指向Bar的对象的types，并将调用适当的调度给M
不，你不能。
您只能覆盖虚拟方法 – 请参阅此处的MSDN ：
在C＃中，派生类可以包含与基类方法同名的方法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51ba2268097ee7f3c45f6b8e6e6f277c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c695faa8670a1a764b1b7355dfbe7ff9/" rel="bookmark">
			数据库mysql的sql执行慢
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		explain /show processlist
explain
在日常工作中，我们会有时会开慢查询去记录一些执行时间比较久的SQL语句，找出这些SQL语句并不意味着完事了，些时我们常常用到explain这个命令来查看一个这些SQL语句的执行计划，查看该SQL语句有没有使用上了索引，有没有做全表扫描，这都可以通过explain命令来查看。所以我们深入了解MySQL的基于开销的优化器，还可以获得很多可能被优化器考虑到的访问策略的细节，以及当运行SQL语句时哪种策略预计会被优化器采用。 -- 实际SQL，查找用户名为Jefabc的员工
select * from emp where name = 'Jefabc';
-- 查看SQL是否使用索引，前面加上explain即可
explain select * from emp where name = 'Jefabc';
expain出来的信息有10列，分别是id、select_type、table、type、possible_keys、key、key_len、ref、rows、Extra
概要描述：
id:选择标识符
select_type:表示查询的类型。
table:输出结果集的表
partitions:匹配的分区
type:表示表的连接类型
possible_keys:表示查询时，可能使用的索引
key:表示实际使用的索引
key_len:索引字段的长度
ref:列与索引的比较
rows:扫描出的行数(估算的行数)
filtered:按表条件过滤的行百分比
Extra:执行情况的描述和说明
下面对这些字段出现的可能进行解释：
一、 id
SELECT识别符。这是SELECT的查询序列号
我的理解是SQL执行的顺序的标识，SQL从大到小的执行
1. id相同时，执行顺序由上至下
2. 如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行
3. id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行
-- 查看在研发部并且名字以Jef开头的员工，经典查询
explain select e.no, e.name from emp e left join dept d on e.dept_no = d.no where e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c695faa8670a1a764b1b7355dfbe7ff9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51850f66571b1a0a7b488dfe16817192/" rel="bookmark">
			c&#43;&#43;中valarray类的介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		valarray类是由头文件valarray支持的，这个类用于处理数值。valarray被定义为一个类模板，以便能够处理不同的数据类型。使用valarray对象的时候的构造函数如下： double gpa[5] = {3.1, 3.5, 3.8, 2.9, 3.3}; valarray&lt;double&gt; v1; // an array of double, size 0 valarray&lt;int&gt; v2(8); // an array of 8 int elements valarray&lt;int&gt; v3(10,8); // an array of 8 int elements, // each set to 10 valarray&lt;double&gt; v4(gpa, 4); // an array of 4 elements // initialized to the first 4 elements of gpa valarray&lt;int&gt; v5 = {20, 32, 17, 9}; // C++11 下面是这个类中的一些方法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51850f66571b1a0a7b488dfe16817192/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd54edf0acdeb353df7a2d702887289d/" rel="bookmark">
			如何运行Vue项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何运行Vue项目
步骤：
一、安装 node.js
从node.js官网（https://nodejs.org/zh-cn/download/）下载并进行傻瓜式安装。安装完毕之后。“win+R”—&gt;cmd 打开命令输入框，输入命令"node -v"，查看node版本。若出现相应的版本号，即代表安装成功。
npm包是集成在node中的，安装了node也就有了npm。输入命令"npm -v"，查看npm版本。
二、安装 cnpm
（由于有些npm资源被屏蔽或者是国外资源的原因，经常会导致npm安装依赖包的时候失败，所以我们还需要npm的国内镜像—cnpm）
输入命令"npm install -g cnpm --registry=http://registry.npm.taobao.org"，等待安装。如果一遍没有安装成功就关闭cmd，再重新安装一次。
三、安装 vs code
从官网下载安装
–修改语言：Ctrl +Shift +P—&gt;Configure Display Language)
四、运行 vue项目
1、用vs code打开你要运行的vue项目的文件夹
2、安装前端依赖
两种方式：
①在vs code 终端上安装：
**若运行cnpm install 后，出现
问题出现在sass loader，执行下面的命令：cnpm rebuild node-sass，
再执行cnpm install
②直接在文件夹中安装：
开始—附件—Windows PowerShell—Windows PowerShell，输入命令"cnpm i"
3、安装成功后，项目中多了一个文件夹
4、在vs code终端中，输入命令"npm run dev"
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a117105f013af5f64b88a17dd3e23904/" rel="bookmark">
			axios详细配置说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		url: ‘/user’ url是将用于发送请求 method: ‘get’, 默认值 get 设置请求类型，get/post baseURL: ‘https://some-domain.com/api/’ 基本地址 ，发送请求的地址=baseURL+url transformRequest: [function (data, headers) {return data;}] transformRequest`允许在将请求数据发送到服务器之前对其进 行更改 仅适用于请求方法'PUT'，'POST'，'PATCH'和'DELETE' 数组中的最后一个函数必须返回字符串或Buffer， ArrayBuffer，FormData或Stream 的实例//您可以修改标头对象 transformResponse: [function (data) return data; }] transformResponse允许更改响应数据，然后将其传递给then / catch headers: {‘X-Requested-With’: ‘XMLHttpRequest’} 设置请求头信息 params: {ID: 12345}, params是要与请求一起发送的URL参数 必须是普通对象或URLSearchParams对象 paramsSerializer: function (params) { return Qs.stringify(params, {arrayFormat: ‘brackets’}) } 对请求的参数做一个序列化，转换成一个字符串，并返回 data: {firstName: ‘Fred’} data是要作为请求正文发送的数据 仅适用于请求方法'PUT'，'POST'，'DELETE和'PATCH' data: ‘Country=Brasil&amp;City=Belo Horizonte’ 将数据发送到正文中的语法替代 timeout: 1000, 默认值 0 (no timeout) timeout指定请求超时之前的毫秒数。 如果请求所花的时间超过`timeout`，则该请求将被中 止。 withCredentials: false, 默认值 false withCredentials指示是否应使用凭证 adapter: function (config) { /* … */} adapter允许自定义处理请求，这使得测试更加容易。 返回承诺并提供有效的响应 auth: {username: ‘janedoe’,password: ‘s00pers3cret’} 验证用户名和密码的 responseType: ‘json’, // 默认值 responseType 表示数据与服务器将响应类型 选项有：'arraybuffer', 'document', 'json', 'text', 'stream' responseEncoding: ‘utf8’,默认值 utf8 responseEncoding 表示用于解码响应的编码（仅适用于 Node.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a117105f013af5f64b88a17dd3e23904/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b4f1eaa7adaf70755de8c8ba9bd3e90/" rel="bookmark">
			安可系统对接必须java_无法运行安可开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我想使用纱线运行安可开发时为什么我有这个错误？当我想添加sass时，我得到警告“&gt; sass-loader@6.0.7”有未满足的对等依赖“webpack@^2.0.0 || ^ 3.0.0 || ^ 4.0.0” . 但为什么 ？ Symfony 4.我无法从github安装这个模块npm install --save child_process fork-ts-checker-webpack-plugin fs module net readline spdx-exceptions spdx-license-ids spdx-license-ids / deprecated
纱线运行安可开发
纱线运行v1.5.1 $ c：\ xampp \ htdocs \ dashboard \ Symfony \ pppp \ node_modules.bin \ encore dev运行webpack ...
错误09:48:38无法编译50个错误
找不到这些依赖项：
./node_modules/execa/index.js,./node_modules/execa/node_modules/cross-spawn/index.js中的
child_process和另外1个
fork-ts-checker-webpack-plugin in ./node_modules/@symfony/webpack-encore/lib/plugins/forked-ts-types.js
fs in ./node_modules/@symfony/webpack-encore/lib/WebpackConfig.js,./node_modules/@symfony/webpack-encore/lib/config/parse-runtime.js和另外35人
_(webpack)/lib/NormalModule.js中的
模块，(webpack)/lib/node/NodeTargetPlugin.js
net in ./node_modules/growly/lib/gntp.js,./node_modules/node-notifier/lib/checkGrowl.js
000_ readline in ./node_modules/friendly-errors-webpack-plugin/src/output.js
./node_modules/spdx-expression-parse/scan.js中的
spdx-exceptions
./node_modules/spdx-correct/index.js,./node_modules/spdx-expression-parse/scan.js中的
spdx-license-ids
spdx-license-ids /弃用.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b4f1eaa7adaf70755de8c8ba9bd3e90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1835e3f772d5e60135ddd99c4272035/" rel="bookmark">
			复习Vue3:列表渲染 v-for
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		复习Vue3:列表渲染 v-for 我们可以通过使用v-for指令基于一个数组来渲染一个列表，v-for指令需要使用item in items形式的语法。其中 items是源数组，而item则是被迭代的数组元素的别名。
基本实现的代码如下：
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;title&gt;列表渲染&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;ul&gt; &lt;!-- users表示数组，item表示从数组中取出的对象,这个名字可以随意取 --&gt; &lt;!-- 注意 v-for必须结合key属性来使用，它会唯一标识数组中的每一项，未来当数组中的那一项改变的时候，它会只更新那一项，好处就是提升性能。注意key的值唯一，不能重复 --&gt; &lt;!-- index表示数组的索引值，该名字可以随意定义 --&gt; &lt;li v-for="(item,index) in users" :key="item.id"&gt; 编号：{{item.id}} 姓名:{{item.name}}---索引:{{index}} &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt; &lt;script&gt; new Vue({ el: "#app", data: { users: [ { id: 1, name: "张三", }, { id: 2, name: "李四", }, { id: 3, name: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1835e3f772d5e60135ddd99c4272035/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/009716a8f0fbc46ae9a5ac73b68755e8/" rel="bookmark">
			Maven 最详细的settings.xml 配置文件解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Maven settings.xml详解 settings.xml maven的主配置文件缺省名称为 settings.xml 其完整结构如下(为了方便阅读，删除了注释部分)：
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;settings xmlns="http://maven.apache.org/SETTINGS/1.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd"&gt; &lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt; &lt;interactiveMode&gt;true&lt;/interactiveMode&gt; &lt;offline&gt;false&lt;/offline&gt; &lt;pluginGroups&gt; &lt;/pluginGroups&gt; &lt;proxies&gt; &lt;/proxies&gt; &lt;servers&gt; &lt;/servers&gt; &lt;mirrors&gt; &lt;/mirrors&gt; &lt;profiles&gt; &lt;/profiles&gt; &lt;activeProfiles&gt; &lt;/activeProfiles&gt; &lt;/settings&gt; conf 目录 和 .m2 目录 如果你是第一次安装maven，你能够在安装目录下的conf目录中找到settings.xml 配置文件，但如果你第一次使用maven进行项目构建后，你会发现在你的用户目录中，会出现一个.m2的隐藏(windows中非隐藏，. 前缀为linux内核操作系统中的隐藏文件前缀)目录。通常，我们会把 **conf目录 **中的settings.xml文件复制到 .m2目录中进行使用。实际上这是基于操作系统本身，相对于maven使用用户的一次分隔，不同的用户登录操作系统后将使用不同的settings.xml配置文件。如何达到这一目的，maven通过内置的settings.xml加载规则完成。
settings.xml加载规则 如上图所示，maven在构建项目获取配置文件时，首先会查找用户目录下的.m2目录，如果存在则使用，如果不存在再获取安装目录下conf目录中的配置文件，因此我们这样描述两个目录中配置文件的不同， .m2目录是用户级的配置，而conf目录是系统全局的配置。
**
注： 如果需要在项目构建时使用特定的配置文件，可以使用 **mvn -s 配置文件绝对路径 + 构建命令** 完成构建
settings.xml 内容解析 1. settings settings.xml 除了默认的xml头之外，固定由一个 settings 标签包裹其他内容标签。用户通常不需要修改该标签内容
&lt;settings xmlns="http://maven.apache.org/SETTINGS/1.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd"&gt; &lt;!--Xml name space 的缩写，标识了该文档使用 http://maven.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/009716a8f0fbc46ae9a5ac73b68755e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/878dd83fefebb1961b0c6090f929cefc/" rel="bookmark">
			VS 2015用C&#43;&#43;项目生成dll并调用（2021.3.1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Visual Studio 2015 C++支持的dll生成及调用 2021.3.1 1、开发环境2、DLL介绍3、C++创建并调用自定义dll动态链接库（同一个解决方案下）3.1 新建C++项目来生成DLL3.2 新建客户端C++项目调用dll（同一解决方案下） 4、C++项目本地调用dll（不同解决方案）4.1 将 DLL 标头（.h文件所在目录）添加到项目的包含目录4.2 将 DLL 导入库（.lib文件所在目录）添加到项目的库目录4.3 应用所调用dll（.dll文件）的本地部署4.3.1 手动复制dll4.3.2 在生成后事件中复制dll 5、C#项目本地调用dll5.1 为C#项目进行dll的本地应用部署（两种dll文件复制方式）5.1.1 方式一：手动复制dll相关文件5.1.2 方式二：项目后期生成事件命令行复制 1、开发环境 宇宙第一最强IDEVisual Studio 2015
2、DLL介绍 在 Windows 中，动态链接库 (DLL) 是作为函数和资源的共享库的一种可执行文件。 动态链接是操作系统功能， 它可使执行文件调用函数或使用存储在单独文件中的资源。 可从使用这些函数和资源的可执行文件中对其分别进行编译和部署。
DLL 不是独立的可执行文件。 DLL 在调用它们的应用程序的上下文中运行。 操作系统将 DLL 加载到应用程序的内存空间中。 此操作要么在加载应用程序时（隐式链接）完成，要么在运行时按需（显式链接）完成 。 DLL 还可以在可执行文件之间轻松共享函数和资源。 多个应用程序可同时访问内存中单个 DLL 副本的内容。
静态链接将静态库中的所有对象代码复制到生成时使用它的可执行文件中。 动态链接仅包括 Windows 在运行时用于查找和加载含有数据项或函数的 DLL 所需的信息。 创建 DLL 时，还将创建包含此信息的导入库。 生成调用 DLL 的可执行文件时，链接器会使用导入库中的导出符号来为 Windows 加载程序存储此信息。 当加载程序加载 DLL 时，该 DLL 会映射到你的应用程序的内存空间中。 如果存在，则调用 DLL 中的特殊函数 DllMain，以执行 DLL 所需的任何初始化。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/878dd83fefebb1961b0c6090f929cefc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35fb7033da475117133a582e77ff2a85/" rel="bookmark">
			ElasticSearch相关内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用途：数据搜索、存储和分析引擎
地理位置搜索、前缀搜索
一个索引就相当于一个 table
索引三结构：aliases、mappings、settings
node 角色 只有 data.master = true（候选节点） 属性的节点才能参与 master 的选举
1）、master：集群中只有一个master节点，一般只负责分片负载均衡以及创建和删除索引，属性是 data.master = true，节点不要设置 node.data ＝ true ，避免存储数据，加大节点压力
2）、coordinating：协调节点，属性：data.master = false 和 data.data = false，只负责分片的负载均衡
3）、数据节点：做数据的存储和查询等，属性：data.master = false 和 data.data = true
4）、voting：投票节点，属性：Node.voting_only = true，仅投票节点，即使配置了data.master = true，也不会参选, 但是仍然可以作为数据节点
倒排索引：基于 term（分词）查找 doc（文档）
正排索引：基于 doc（文档）查找 term（分词），doc_values
TF: term 在每个 doc 中出现的次数（频率），频率越高相关度越高
IDF: term 在整个索引中出现的次数（频率），频率越高相关度越低
可以使用 painless 脚本处理逻辑，类似于 redis 使用 lua 脚本，使用脚本时尽量使用变量方式，这样可以加快脚本执行速度（脚本会在第一次执行后编译好，后序不需要编译了，只需要将变量的值通过参数替换即可）
分词器：ik 中文分词器，分析器：ik_max_word（默认，细粒度）、ik_smart（粗粒度）
text：应用于全文检索，字段内容会被分析，在生成倒排索引以前，字符串会被分析器分成一个个词项，不能用于排序聚合（排序聚合时text内容会加载到堆内存中，占用内存较高）
keyword：text 类型默认都会同时生成 keyword 类型，专门用于聚合和排序，只能通过精确值（exact value）搜索到，Id应该用keyword
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35fb7033da475117133a582e77ff2a85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/188c8a1a19a490374223585f96c3f642/" rel="bookmark">
			1103 Integer Factorization (30 分)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1103 Integer Factorization (30 分) The K−P factorization of a positive integer N is to write N as the sum of the P-th power of K positive integers. You are supposed to write a program to find the K−P factorization of N for any positive integers N, K and P.
Input Specification: Each input file contains one test case which gives in a line the three positive integers N (≤400), K (≤N) and P (1&lt;P≤7).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/188c8a1a19a490374223585f96c3f642/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c941621ad3a4f279092aabfb336d7236/" rel="bookmark">
			java树遍历的api_java8 的files、path类相关文件遍历API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Path的两种初始化(应该还有别的方式)
Path file = new File(path).toPath();
Paths.get
判断是文件、是目录
Files.isRegularFile(file)
Files.isDirectory(file)
javadoc说，还有既不是文件也不是目录的情况
Files.find
通过属性和路径筛选，可以筛选是文件，而路径匹配 PathMatcher 样式的。深度可以指定 integer max，无尽深度，或者限定1、2级深度。
PathMatcher 通过 FileSystem.getPathMatcher(String syntaxAndPattern) 获取。按javadoc介绍，有glob和regex两种方式。使用了glob的，没有使用regex的。 glob的支持 {*.gz,*.json} 这样的匹配方式。
还有 Files.walk， directorystream的api调用。这三个api可以遍历目录树，比file listfiles手写递归用高效多了。
返回的流，可以使用skip、limit，进行分页，然后调用foreach，对结果遍历处理。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7b83fbc707611dd11b2bcb43b4e148f/" rel="bookmark">
			java camel &lt;from uri_让Camel处理各种URI类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我相信一个难点是，对于您提到的组件(HTTP，FTP，文件，JMS)，您可能想要使用生产者或消费者：
FTP，File：绝对是读取文件的消费者。
HTTP(或HTTP4)：绝对是生产者，向服务器发送请求(服务器的回复将由新邮件正文)
JMS：取决于您想要从队列(消费者)读取数据，或者使用ReplyTo标头将消息发送到队列，然后等待答案(生产者)。
制作人：
如果您使用的是Camel 2.16+，则可以使用新的"dynamic to"语法。它基本上与常规“to”相同，除了可以使用simple表达式(或者，optionnaly，另一种表达式)动态评估端点uri。或者，你可以使用content-enricher pattern的enrich风格，它也支持从Camel 2.16开始的动态uris。
如果您使用的是较旧版本的Camel，或者您需要动态路由到多个端点(而不仅仅是一个端点)，则可以使用recipient list模式。
这是一个例子。我们将通过调用端点来转换消息体;该端点的uri将在名为TargetUri的标头中找到，并将针对每条消息动态评估。
// An instance of this class is registered as 'testbean' in the registry. Instead of
// sending to this bean, I could send to a FTP or HTTP endpoint, or whatever.
public class TestBean {
public String toUpperCase(final String str) {
return str.toUpperCase();
}
}
// This route sends a message to our example route for testing purpose.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7b83fbc707611dd11b2bcb43b4e148f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b7c5538bf97020b8009f156530aa045/" rel="bookmark">
			java接收js excel_通过Javascript读取本地Excel文件内容的代码示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		function read_excel(){
var filePath="D:\abcd9.com.xls"; //要读取的xls
var sheet_id=2; //读取第2个表
var row_start=3; //从第3行开始读取
var tempStr='';
try{
var oXL = new ActiveXObject("Excel.application"); //创建Excel.Application对象
}catch(err)
{
alert(err);
}
var oWB = oXL.Workbooks.open(filePath);
oWB.worksheets(sheet_id).select();
var oSheet = oWB.ActiveSheet;
var colcount=oXL.Worksheets(sheet_id).UsedRange.Cells.Rows.Count ;
for(var i=row_start;i&lt;=colcount;i++){
if (typeof(oSheet.Cells(i,8).value)=='date'){ //处理第8列部分单元格内容是日期格式时的读取问题
d= new Date(oSheet.Cells(i,8).value);
temp_time=d.getFullYear()+"-"+(d.getMonth() + 1)+"-"+d.getDate();
}
else
temp_time=$.trim(oSheet.Cells(i,7).value.toString());
tempStr+=($.trim(oSheet.Cells(i,2).value)+" "+$.trim(oSheet.Cells(i,4).value)+" "+$.trim(oSheet.Cells(i,6).value.toString())+" "+temp_time+"\n");
//读取第2、4、6、8列内容
}
return tempStr; //返回
oXL.Quit();
CollectGarbage();
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/772ed26a6938a7e6c0a3fdb8654ba686/" rel="bookmark">
			java提交spark submit_spark-submit提交方式测试Demo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写一个小小的Demo测试一下Spark提交程序的流程
Maven的pom文件
1.7
1.7
UTF-8
1.6.1
org.apache.spark
spark-core_2.10
${spark.version}
redis.clients
jedis
2.7.1
org.apache.maven.plugins
maven-compiler-plugin
1.7
1.7
org.apache.maven.plugins
maven-shade-plugin
2.4.3
package
shade
*:*
META-INF/*.SF
META-INF/*.DSA
META-INF/*.RSA
编写一个蒙特卡罗求PI的代码
importjava.util.ArrayList;importjava.util.List;importorg.apache.spark.SparkConf;importorg.apache.spark.api.java.JavaRDD;importorg.apache.spark.api.java.JavaSparkContext;importorg.apache.spark.api.java.function.Function;importorg.apache.spark.api.java.function.Function2;importredis.clients.jedis.Jedis;/*** Computes an approximation to pi
* Usage: JavaSparkPi [slices]*/
public final classJavaSparkPi {public static void main(String[] args) throwsException {
SparkConf sparkConf= new SparkConf().setAppName("JavaSparkPi")/*.setMaster("local[2]")*/;
JavaSparkContext jsc= newJavaSparkContext(sparkConf);
Jedis jedis= new Jedis("192.168.49.151",19000);int slices = (args.length == 1) ? Integer.parseInt(args[0]) : 2;int n = 100000 *slices;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/772ed26a6938a7e6c0a3fdb8654ba686/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc872ce0864d4587c0cd6b7c059daf1e/" rel="bookmark">
			SpringMVC应用在jetty容器中启动，如何引用其他路径下的配置文件？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;Configure class="org.eclipse.jetty.webapp.WebAppContext"&gt; &lt;!-- set contextPath，read env property jetty.web.contextPath, default is root --&gt; &lt;Set name="contextPath"&gt;&lt;SystemProperty name="jetty.web.contextPath" default="/"/&gt;&lt;/Set&gt; &lt;Set name="war"&gt;&lt;Property name="jetty.webapps" default="."/&gt;/argus-admin.war&lt;/Set&gt; &lt;Set name="extractWAR"&gt;true&lt;/Set&gt; &lt;!--增加如下一个配置--&gt; &lt;Set name="extraClasspath"&gt;/app/jetty/server/docker_jetty/resources/&lt;/Set&gt; &lt;Set name="copyWebDir"&gt;false&lt;/Set&gt; &lt;Set name="defaultsDescriptor"&gt;&lt;Property name="jetty.base" default="."/&gt;/etc/webdefault.xml&lt;/Set&gt; &lt;/Configure&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59291ae1e643495ca874bc9674b29c86/" rel="bookmark">
			java正则匹配第一个符合的_java正则贪婪匹配指定字符开头和结尾或括号中内容...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目中需要这样二种场景，需要贪婪匹配一个字符串，按照相应的匹配规则，替换指定的字符。
一、场景一匹配规则
1.中括号开头紧接2位数字
2.中间部分任意
3.右中括号结尾
代码如下:
String str = "[05经销商风险等级:低风险][06客户户籍地风险等级:中高风险][06销售风险等级:中风险][01不符合增信退回要求][02人行与申请提供手机号码不一致]";
//正则
Pattern pattern=Pattern.compile("\\[\\d{2}.*?\\]");
Matcher matcher = pattern.matcher(str);
StringBuffer stringBuffer = new StringBuffer(512);
while (matcher.find()) {
StringBuilder sb = new StringBuilder(matcher.group(0));
System.out.println(matcher.group());
if (StringUtils.isBlank(sb) || sb.length() &lt;= 2) {
continue;
}
//替换第2，3位为空
sb.replace(1, 3, "");
System.out.println(sb.toString());
}
输出结果:
[05经销商风险等级:低风险]
[经销商风险等级:低风险]
[06客户户籍地风险等级:中高风险]
[客户户籍地风险等级:中高风险]
[06销售风险等级:中风险]
[销售风险等级:中风险]
[01不符合增信退回要求]
[不符合增信退回要求]
[02人行与申请提供手机号码不一致]
[人行与申请提供手机号码不一致]
二、场景二匹配规则
1.匹配()中的内容
代码如下:
//正则
Pattern pattern = Pattern.compile("(?&lt;=\\()(.+?)(?=\\))");
matcher = pattern.matcher("06客户户籍地风险等级(低风险)师12(中高风险)(人行与申请提供手机号码不一致)风险(中风险)01不符合增信退回要求(不符合增信退回要求)01不符合增信退回要求");
while(matcher.find())
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59291ae1e643495ca874bc9674b29c86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2566e08ddec2d9eb46ce878b854d317d/" rel="bookmark">
			windows10环境下curl 安装与配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows10环境下curl 安装与配置 1、curl简介
cURL是一个利用URL语法在命令行下工作的文件传输工具，1997年首次发行。它支持文件上传和下载，所以是综合传输工具，但按传统，习惯称cURL为下载工具。cURL还包含了用于程序开发的libcurl。
cURL支持的通信协议有FTP、FTPS、HTTP、HTTPS、TFTP、SFTP、Gopher、SCP、Telnet、DICT、FILE、LDAP、LDAPS、IMAP、POP3、SMTP和RTSP。
curl还支持SSL认证、HTTP POST、HTTP PUT、FTP上传, HTTP form based upload、proxies、HTTP/2、cookies、用户名+密码认证(Basic, Plain, Digest, CRAM-MD5, NTLM, Negotiate and Kerberos)、file transfer resume、proxy tunneling。
2、curl下载地址：https://curl.se/download.html ，如下图所示
3、curl安装
①将curl文件包解压至文件夹：D:\Web-Crawler，此时curl文件的路径(CURL_HOME)为：D:\Web-Crawler\curl-7.64.1
②配置环境变量，步骤：computer右键/点击属性/点击高级系统设置……详细如下图所示：
③配置环境变量
在环境变量界面，path路径后追加：%CURL_HOME%\I386，如下图所示
4、curl测试
①：重启电脑；
②windows键+R键，键入cmd,进入管理员界面；
③在管理员界面键入指令：curl --help ，输出以下界面：
④再在管理员界面键入指令：curl www.bidu.com -i,输出界面有乱码，如下图所示：
5、到此时，说明：curl已安装成功，但是有乱码，需要继续安装iconv
①iconv的下载地址：http://gnuwin32.sourceforge.net/packages/libiconv.htm，如下图所示
②iconv安装：选择好安装路径后，一路默认+确定
③配置iconv的环境变量，（即在path路径后追加：D:\Web-Crawler\GnuWin32\bin，详细步骤如下图所示：
④重启电脑
5、测试
①windows键+R键，键入cmd,进入管理员界面
②在管理员界面键入指令: curl www.baidu.com -i | iconv -f utf-8 -t gbk，输出如下：
至此，curl就配置成功了，可以开展爬网页了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/634fca6a0efdaf34e150c7d60a60824a/" rel="bookmark">
			mysql 异常连接_解决mysql连接异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出现异常”The last packet sent successfully to the server was 0 milliseconds ago.“的大部分原因是由于数据库回收了连接，而系统的缓冲池不知道，继续使用被回收的连接所致的。
以mysql为例：
第一种解决办法，就是将mysql回收空闲连接的时间变长，mysql默认回收时间是8小时，可以在mysql目录下的my.ini中增加下面配置，将时间改为1天。
单位是秒，最大好像是24天：
[mysqld]
wait_timeout=86400
第二种解决办法，可以通过配置，让缓冲池去测试连接是否被回收，如果被回收，则不继续使用，以dbcp为例：
#SQL查询,用来验证从连接池取出的连接 dbcp.validationQuery=SELECT 1 #指明连接是否被空闲连接回收器(如果有)进行检验，如果检测失败，则连接将被从池中去除 dbcp.testWhileIdle=true #在空闲连接回收器线程运行期间休眠的时间值,以毫秒为单位，一般比minEvictableIdleTimeMillis小 dbcp.timeBetweenEvictionRunsMillis=300000 #在每次空闲连接回收器线程(如果有)运行时检查的连接数量，最好和maxActive一致 dbcp.numTestsPerEvictionRun=50 #连接池中连接，在时间段内一直空闲，被逐出连接池的时间(1000*60*60)，以毫秒为单位 dbcp.minEvictableIdleTimeMillis=3600000
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc586ecfff6cad52879489d876e6e30d/" rel="bookmark">
			我的世界java版forge放在哪_我的世界1.9forge安装 怎么装forge教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的世界1.9版本已经可以使用forge了，也就是说可以开始享受有mod的1.9版本了，由于目前forge还处于测试版本，因此在这里给大家提供的是1.9不稳定版的forge以及forge安装教程，希望对各位玩家有所帮助。
注意：Forge安装后第一次使用会联网下载一些必要的lib文件存在.minecraft/lib或.minecraft/libraries下。如果你的网络连接不畅，或是部分中国大陆境内的部分无良Internet服务提供商私自屏蔽了forge官方网站，你只能从其他连接顺畅的玩家处复制这些文件。
Forge 12.16.0.1864(测试版不保证稳定性) for Minecraft 1.9(同时适用于客户端&amp;官方服务端):
请优先选择adfoc连接，这样Forge开发组才能得到一点微薄的点击收入。
自动Forge安装器(jar格式)原帖下载点(adfoc)：http://adfoc.us/serve/?id=27122858327720
自动Forge安装器(exe格式)原帖下载点(adfoc)-仅适用于Windows操作系统：http://adfoc.us/serve/?id=27122858344747
自动Forge安装器(jar格式)备用下载点(baidu.com)：http://pan.baidu.com/s/1csPcHw
安装方法：
请使用自动Forge安装器安装。打开方式选择Java Platform SE binary，定位到你的.minecraft文件夹之后即可。安装成功后，.minecraft/versions文件夹下会出现名为“Forge”的文件夹，如果你使用正版启动器的话还会自动配置独立的，名为Forge的Profile;非官方启动器用户请自己配置启动器指向该文件夹(具体方法请询问启动器作者)。无法读取json的非官方启动器请您果断放弃。
使用Forge自动安装器安装客户端Forge之前，必须满足下列两个条件之一，否则会提示no launcher profile错误：
正版启动器用户：运行过至少一次正版启动器(无需登录)。
其它启动器用户：将正版启动器的profile文件(
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa76554f5ca8353c4b24e58de2a25d29/" rel="bookmark">
			用java创建一棵二叉树_java创建二叉树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/**
* 创建非完全二叉树、完全二叉树、满二叉树
*
* 由于二叉树的节点增加没有什么规则，所以这里只是简单的使用了递一
* 次性把整棵树创建出来，而没有设计出一个一个添加节点的方法与删除
* @author jzj
* @date 2009-12-23
*/
public class BinTree {// Bin=Binary(二进位的, 二元的)
protected Entry root;//根
private int size;//树的节点数
/**
* 树的节点结构
* @author jzj
* @date 2009-12-23
*/
protected static class Entry {
int elem;//数据域，这里我们作为编号
Entry left;//左子树
Entry right;//右子树
public Entry(int elem) {
this.elem = elem;
}
public String toString() {
return " number=" + elem;
}
}
/**
* 根据给定的节点数创建一个完全二叉树或是满二叉树
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa76554f5ca8353c4b24e58de2a25d29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c193af06a68e71ce8159a0416784abcd/" rel="bookmark">
			java调用接口实现的方法_java调用接口的实现方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java调用接口的实现方法
发布时间：2020-06-29 11:08:46
来源：亿速云
阅读：78
作者：Leah
本篇文章给大家分享的是有关java调用接口的实现方法，小编觉得挺实用的，因此分享给大家学习，希望大家阅读完这篇文章后可以有所收获，话不多说，跟着小编一起来看看吧。
一个类实现了某一个接口就可以调用接口中的方法。接口可以理解为一种能力，例如：每种动物都有叫的能力，但是每种动物的叫声都不一样，叫的能力就可以定义为一个接口。
一、创建项目和包
打开Eclipse，依次选择File→New→Project。在弹出的Select a wizard窗口中，选择Java Project 后，点击下一步。
输入项目名称后点击下一步(建议遵循命名规则)
鼠标右击新建的项目，依次选择New→Package，完成包命名后，点击下一步。
二、创建接口
鼠标右击包，依次选择New→Interface。
将接口命名为ShoutAbility后，点击完成。(喊叫能力接口)
如下图，定义接口shout()方法(保持良好习惯，加上注释)，并按下Ctrl +S 保存。
三、创建接口实现类
右击包，依次选择New→Class，并将类命名为AoShout(嗷嗷叫)。
如下图，将AoShout 实现ShoutAbility接口，实现接口的关键字为 implements，并重写接口的shout方法。按下Ctrl+S 保存。
四、调用接口方法
创建一个Bird类，并定义一个带参构造方法，用接口类型定义参数。
定义Bird 的 shout() 方法时，即可用接口变量调用接口方法。
按下Ctrl +S 保存。
创建一个测试类，用接口的实现类AoShout创建一个接口对象，再用创建的bridShout对象创建一个鸟对象。
这时候调用鸟类的方法，就会执行调用到接口的方法，通过接口找到实现类的方法嗷嗷叫。
注意事项
接口的方法都是抽象方法，方法必须在实现类中实现；一个类可以有多种接口(能力)；类名必须首字母大写。
以上就是java调用接口的实现方法，小编相信有部分知识点可能是我们日常工作会见到或用到的。希望你能通过这篇文章学到更多知识。更多详情敬请关注亿速云行业资讯频道。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b8ec6fb0481510d0e490e7c81ee4a77/" rel="bookmark">
			c 访问java服务端接口_Socket网络通讯开发总结之：java服务器端和C客户端IO阻塞问题...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		服务端：C
客户端：Java
通信的时候，客户端发送数据成功，服务端成功返回数据，但是客户端实际上一直处于等待状态，无响应。
对于Inputstream.read()而言，Java中在socket通信时，有相应的处理机制，可以在客户端调用Socket.shutdownOutput()方法告诉服务器。read()方法是读到-1从而continue。但是，Java和C通信的话，read()会读取客户端发送过来的数据，如果无数据可读，就会阻塞直到有数据可读。这样就会出现IO阻塞了。客户端收不到服务器返回的消息。
并且在实际使用中发现，若客户端数据发送频繁，那么服务端接收的数据存在粘包的情况，这是因为TCP是基于流的传输，即其无保护消息边界，所以如果发送端连续发送数据，接收端有可能在一次接收动作中，会接收两个或者更多的数据包。
针对这个问题，一般有3种解决方案：
* 发送固定长度的消息，即发送端和接收端约定好每次发送接收的缓冲区长度，每次都发送和接收固定长度的字节。由于每次消息要占用固定长度，因此会浪费网络资源。
* 把消息的尺寸与消息一块发送，即先发送本次消息的尺寸(消息的尺寸要采用固定长度的方法)，在发送本次需要发送的消息。这样既节省了带宽，又可以解决粘包问题。
* 使用特殊标记来区分消息间隔。即每条消息的最后加特殊字符用于区分，该方法适用于消息本身无特殊字符的情景。前提这是因为本身发送的消息不含特殊字符，且JAVA的BufferedReader本身支持”\\n”对消息进行区分。
注意：
1、对于使用BufferedReader，使用readLine()，
* 读入的数据要注意有/r或/n或/r/n
* 没有数据时会阻塞，在数据流异常或断开时才会返回null
* 使用socket之类的数据流时，要避免使用readLine()，以免为了等待一个换行/回车符而一直阻塞。
2、字节编码问题，这里由于发送的都是英文字符，因此编解码没问题，如果要支持中文字符，则需要两边约定好字符编码格式。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45a74748d9f36f52f61972dcff8f290c/" rel="bookmark">
			java string操作函数_[Java] 字符串各函数操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字符串常用方法
1.构造方法
public static void main(String[] args) {
// 在堆区初始化一个空字符串
String str1 = new String();
// 通过一个字节数组构建一个字符串
byte[] bytes = {97,98,99};
// 通过使用平台的默认字符集解码指定的 byte 数组
// System.out.println(Charset.defaultCharset());
String str2 = new String(bytes);
System.out.println(str2);
byte[] byte2 = {-42,-48};
String str3 = null;
try {
// 使用指定的字符集对字节序列进行解码
str3 = new String(byte2,"GBK");
} catch (UnsupportedEncodingException e) {
e.printStackTrace();
}
System.out.println(str3);
// 需求:对一个utf-8的字节序列进行解码
byte[] byte3 = {-28,-72,-83,-28,-72,-83};
try {
// sssString str4 = new String(byte3, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45a74748d9f36f52f61972dcff8f290c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cc4fa8095f9030c30ae77443a77562e/" rel="bookmark">
			java数组的长度不确定怎么办_java中申请不定长度数组ArrayList的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如下所示：
import java.util.arraylist;
//java中申请不定长度数组
public class test01 {
public static void main(string[] args) {
// todo auto-generated method stub
arraylist list=new arraylist();
list.add("123");
list.add("5");
list.add("5");
//遍历输出list数组
for(int i=0;i
//get(index)方法，返回此列表中指定位置上的元素。
system.out.print(list.get(i).tostring()+" ");
}
system.out.println("\n"+"遍历输出使用set方法替换后的数组list");
/*set(index,element)方法，用指定的元素替代此列表中指定位置上的元素。
* index - 要替代的元素的索引
element - 存储在指定位置上的元素
* */
list.set(2,"nihao");
//遍历输出使用set方法替换后的数组list
for(int i=0;i
//get(index)方法，返回此列表中指定位置上的元素。
system.out.print(list.get(i)+" ");
//list.size()取得list数组的长度
system.out.println("\n"+"list数组的长度"+list.size());
}
}
}
输出结果：
123 5 5
遍历输出使用set方法替换后的数组list
123 5 nihao
list数组的长度3
以上这篇java中申请不定长度数组arraylist的方法就是小编分享给大家的全部内容了，希望能给大家一个参考，也希望大家多多支持萬仟网。
希望与广大网友互动？？
点此进行留言吧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/639a4484719e53bbf58176f4e5130de7/" rel="bookmark">
			配置vue本地host
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		step1: vue.config.js
step2: 配电脑的host
step3:跑起来本地, 下面就是已经配置好的本地host
重点来了: 提测后, 一定要删除这个临时配的host.使用原来的host配置,踩过坑.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4278ec4b9a6b634de388e529cee3138/" rel="bookmark">
			Java list转为object_Java 如何将List&lt;实体类&gt; 转为List&lt;Object&gt;类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因在写通用方法时有个需求，要将List 转为List类型，这样方便统一处理。
于是就想当然的这么强转(Student为实体类)：
List list = new ArrayList();
List objList = (List)list;
然而报错：Cannot cast from List to List。
好吧，然后把代码改一下遍历一个一个转了：
import java.util.ArrayList;
import java.util.List;
public class ObjectList {
public static void main(String[] args) {
List list = new ArrayList();
//List objList = (List)list;//Cannot cast from List to List
List objList = toObject(list);
}
static public List toObject(List list){
List objlist = new ArrayList();
for(Object e : list){
Object obj = (Object)e;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4278ec4b9a6b634de388e529cee3138/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fa792f06b14e042a4e4cc8b18070512/" rel="bookmark">
			Java真的要没落了？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近也收到很多后端同学的提问，为什么Go的web框架速度还不如Java？为什么许多原本的 Java 项目都试图用 go 进行重写开源？Java会不会因为容器的兴起而没落？Java这个20多年的后端常青树难道真的要走下坡路了？橙子邀请了淘系技术部的同学对以上问题进行解答，也欢迎大家一起交流。
Q：为什么Go的web框架速度还不如Java？ 风弈：华山论剑，让我们索性把各框架的性能分析跑一下再说话。
各种框架的应用场景不同导致其优化侧重点不同，下面我们展开详细分析。
▐ http server 概述 首先描述一下一个简单的 web server 的请求处理过程：
Net 层读取数据包后经过 HTTP Decoder 解析协议，再由 Route 找到对应的 Handler 回调，处理业务逻辑后设置相应 Response 的状态码等，然后由 HTTP Encoder 编码相应的 Response，最后由 Net 写出数据。
而 Net 之下的一层由内核控制，虽然也有很多优化策略，但这里主要比较 web 框架本身，那么暂时不考虑 Net 之下的优化。
看了下 techempower 提供的压测框架源码，各类框架基本上都是基于 epoll 的处理，那么各类框架的性能差距主要体现在上述这些模块的性能了。
▐ 关于各类压测的简述 我们再看 techempower 的各项性能排名，有JSON serialization, Single query, Multiple queries, Cached queries, Fortunes, Data updates 和 Plaintext 这几大类的排名。
其中 JSON serialization 是对固定的 Json 结构编码并返回 (message: hello word), Single query 是单次 DB 查询，Multiple queries 是多次 DB 查询，Cached queries 是从内存数据库中获取多个对象值并以json返回，Fortunes 是页面渲染后返回，Data updates 是对 DB 的写入，Plaintext 是最简单的返回固定字符串。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fa792f06b14e042a4e4cc8b18070512/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d1cf405fadac2f8352c7a65a29862a0/" rel="bookmark">
			MCDF顶层验证方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概述 MCDF的主要功能是将输入端的三个通道数据，通过数据整形和过滤，最终输出。
可以将MCDF的设计结构分别四个模块：
上行数据的通道从端（channel slave）仲裁器（arbiter）整形器（formatter）控制寄存器（control registers） 二、reg_env 对于寄存器模块的验证环境reg_env，它的组织包括：
reg_master_agent，提供寄存器接口驱动信号。reg_slave_agent，提供寄存器接口反馈信号。scoreboard，分别从reg_master_agent内的monitor和reg_slave_agent内的monitor获取监测数据，并且进行数据对比。 三、chnl_env 数据通道从端的验证环境chnl_env的组件包括：
chnl_master_agent，提供上行的激励数据。chnl_slave_agent，提供用来模拟arbiter仲裁信号，并且接受流出数据。reg_cfg_agent，用来提供模拟寄存器的配置信号，并且接收内置FIFO的余量信号。scoreboard，分别从chnl_master_agent、chnl_slave_agent、reg_cfg_agent的monitor接收检测数据，并且对channel的流入流出数据进行比对。
四、arb_env 仲裁器的验证环境arb_env的组件包括：
模拟channel输出接口的arbiter_master_agent的三个实例，用来对arbiter提供并行数据输入，同时对arbiter反馈的仲裁信号做出响应。arbiter_slave_agent，用来接收arbiter的输出数据，模拟formatter的行为，对arbiter的输出信号做出响应。reg_cfg_agent，提供用来模拟寄存器的配置信号，对三个channel数据源分别做出不同的优先级配置。scoreboard，从三个arbiter_master_agent、arbiter_slave_agent、reg_cfg_agent中的monitor获取监测数据，对arbiter的仲裁机制做出预测，并且将输入输出数据按照预测的优先级做出比对。 五、fmt_env 整形器的验证环境fmt_env的组件包括：
fmt_master_agent，用来模拟arbiter的输出数据。fmt_slave_agent，用来模拟MCDF的下行数据接收端。reg_cfg_agent，用来模拟寄存器的配置信号，用来指定输出数据包的长度。scoreboard，从fmt_master_agent、fmt_slave_agent、reg_cfg_agent的monitor获取检测数据，通过数据包长度来预测输出的数据包，与formatter输出的数据包进行比对。 六、环境集成方案一 MCDF顶层验证环境复用了这些模块验证环境的组件，reg_master_agent、chnl_master_agent、fmt_slave_agent，通过这三个激励组件可以有效生成新的激励序列，而将各个agent的sequencer句柄合并在一起时，virtual sequencer的作用就体现出来了，可以通过这个中心化的序列分发管道，将各个agent的sequencer也集中管理。MCDF的scoreboard提供了一个完整的数据通路覆盖方案，即从各个agent的monitor的数据检测端口将数据收集起来，同时建立MCDF的参考模型，预测输出数据包，最终进行数据比对。
验证环境结构图
代码实现
class mcdf_env1 extends uvm_env; `uvm_component_utils(mcdf_env1) reg_master_agent reg_mst; chnl_master_agent chnl_mst1; chnl_master_agent chnl_mst2; chnl_master_agent chnl_mst3; fmt_slave_agent fmt_slv; mcdf_virtual_sequencer virt_sqr; mcdf_scoreboard sb; function void build_phase(uvm_phase phase); super.build_phase(phase); reg_mst = reg_master_agent::type_id::create("reg_mst", this); chnl_mst1 = chnl_master_agent::type_id::create("chnl_mst1", this); chnl_mst2 = chnl_master_agent::type_id::create("chnl_mst2", this); chnl_mst3 = chnl_master_agent::type_id::create("chnl_mst3", this); fmt_slv = fmt_slave_agent::type_id::create("fmt_slv", this); virt_sqr = mcdf_virtual_sequencer::type_id::create("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d1cf405fadac2f8352c7a65a29862a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/578b492ea72f8a6391ef5b3ce11d88f2/" rel="bookmark">
			原生html中echarts的tooltip自动轮播、封装文件与使用（与上篇文章做对比）——（附源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、引入echarts-auto-tooltip.js文件 //在htnl文件引入js文件 &lt;script src="echarts-auto-tooltip.js" type="text/javascript"&gt;&lt;/script&gt; //在当前页面的js文件使用方法 function myChart(){ //Echarts配置略过 //渲染echarts加载数据 myChart.setOption(option); //增加轮播 tools.loopShowTooltip(myChart, option, { loopSeries: true }); //myChart代表echarts的实例名称, options指定图表的配置项和数据, loopSeries打开关闭 //解决自适应 window.addEventListener('resize', function () { myChart.resize() }) } 二、echarts-auto-tooltip.js文件代码如下： (function (global) { global.tools = global.tools || {}; /** * echarts tooltip 自动轮播 * @author liuyishi * @param chart * @param chartOption * @param options * { * interval 轮播时间间隔，单位毫秒，默认为2000 * loopSeries boolean类型，默认为false。 * true表示循环所有series的tooltip，false则显示指定seriesIndex的tooltip * seriesIndex 默认为0，指定某个系列（option中的series索引）循环显示tooltip， * 当loopSeries为true时，从seriesIndex系列开始执行.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/578b492ea72f8a6391ef5b3ce11d88f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d53fcc9dcce73d43f0360b67de0fc1e/" rel="bookmark">
			微信撤回消息格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;msg&gt; &lt;fromusername&gt;wxid_1zcdlm1cjhr522&lt;/fromusername&gt; &lt;scene&gt;0&lt;/scene&gt; &lt;commenturl&gt;&lt;/commenturl&gt; &lt;appmsg appid="" sdkver="0"&gt; &lt;title&gt;还好&lt;/title&gt; &lt;des&gt;&lt;/des&gt; &lt;action&gt;view&lt;/action&gt; &lt;type&gt;57&lt;/type&gt; &lt;showtype&gt;0&lt;/showtype&gt; &lt;content&gt;&lt;/content&gt; &lt;url&gt;&lt;/url&gt; &lt;dataurl&gt;&lt;/dataurl&gt; &lt;lowurl&gt;&lt;/lowurl&gt; &lt;lowdataurl&gt;&lt;/lowdataurl&gt; &lt;recorditem&gt; &lt;![CDATA[]]&gt; &lt;/recorditem&gt; &lt;thumburl&gt;&lt;/thumburl&gt; &lt;messageaction&gt;&lt;/messageaction&gt; &lt;refermsg&gt; &lt;type&gt;1&lt;/type&gt; &lt;svrid&gt;6672653361059635672&lt;/svrid&gt; &lt;fromusr&gt;7597207838@chatroom&lt;/fromusr&gt; &lt;chatusr&gt;wxid_lcftop7s6k2p21&lt;/chatusr&gt; &lt;displayname&gt;三胖&lt;/displayname&gt; &lt;msgsource&gt;&amp;lt;msgsource&amp;gt;&amp;#x0A;&amp;#x09;&amp;lt;silence&amp;gt;1&amp;lt;/silence&amp;gt;&amp;#x0A;&amp;#x09;&amp;lt;membercount&amp;gt;36&amp;lt;/membercount&amp;gt;&amp;#x0A;&amp;lt;/msgsource&amp;gt;&amp;#x0A;&lt;/msgsource&gt; &lt;content&gt;那些市场卖的现包汤圆个个大的跟小包子似的&lt;/content&gt; &lt;/refermsg&gt; &lt;extinfo&gt;&lt;/extinfo&gt; &lt;sourceusername&gt;&lt;/sourceusername&gt; &lt;sourcedisplayname&gt;&lt;/sourcedisplayname&gt; &lt;commenturl&gt;&lt;/commenturl&gt; &lt;appattach&gt; &lt;totallen&gt;0&lt;/totallen&gt; &lt;attachid&gt;&lt;/attachid&gt; &lt;emoticonmd5&gt;&lt;/emoticonmd5&gt; &lt;fileext&gt;&lt;/fileext&gt; &lt;aeskey&gt;&lt;/aeskey&gt; &lt;/appattach&gt; &lt;weappinfo&gt; &lt;pagepath&gt;&lt;/pagepath&gt; &lt;username&gt;&lt;/username&gt; &lt;appid&gt;&lt;/appid&gt; &lt;appservicetype&gt;0&lt;/appservicetype&gt; &lt;/weappinfo&gt; &lt;websearch /&gt; &lt;finderFeed&gt; &lt;objectId&gt;0&lt;/objectId&gt; &lt;objectNonceId&gt;0&lt;/objectNonceId&gt; &lt;feedType&gt;-1&lt;/feedType&gt; &lt;nickname&gt;&lt;/nickname&gt; &lt;username&gt;&lt;/username&gt; &lt;avatar&gt;&lt;/avatar&gt; &lt;desc&gt;&lt;/desc&gt; &lt;mediaCount&gt;0&lt;/mediaCount&gt; &lt;localId&gt;0&lt;/localId&gt; &lt;mediaList /&gt; &lt;/finderFeed&gt; &lt;finderLive&gt; &lt;finderLiveID&gt;0&lt;/finderLiveID&gt; &lt;finderUsername&gt;&lt;/finderUsername&gt; &lt;finderObjectID&gt;0&lt;/finderObjectID&gt; &lt;nickname&gt;&lt;/nickname&gt; &lt;desc&gt;&lt;/desc&gt; &lt;finderNonceID&gt;0&lt;/finderNonceID&gt; &lt;headUrl&gt;&lt;/headUrl&gt; &lt;liveStatus&gt;-1&lt;/liveStatus&gt; &lt;media&gt; &lt;thumbUrl&gt;&lt;/thumbUrl&gt; &lt;videoPlayDuration&gt;0&lt;/videoPlayDuration&gt; &lt;url&gt;&lt;/url&gt; &lt;coverUrl&gt;&lt;/coverUrl&gt; &lt;height&gt;0&lt;/height&gt; &lt;width&gt;0&lt;/width&gt; &lt;mediaType&gt;-1&lt;/mediaType&gt; &lt;/media&gt; &lt;/finderLive&gt; &lt;/appmsg&gt; &lt;appinfo&gt; &lt;version&gt;1&lt;/version&gt; &lt;appname&gt;Window wechat&lt;/appname&gt; &lt;/appinfo&gt; &lt;/msg&gt; 一次微信群聊天中， 随手撤回了一条消息，结果消息发送框意外返回了xml数据结构的格式，无意发现原来微信是这么设计数据结构的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61831afa0062d87ab0ed2549b99f95a6/" rel="bookmark">
			m1芯片能装mysql_M1芯片安装mysql8.0数据库的实现步骤(图文)_Mysql_数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、下载
首先给大家推荐一个mysql的国内镜像，虽然不是特别快，但对比起官方网站，还是快了不少，同时资源内容也有保证，不会下载到其他乱七八糟的东西
地址：
选择你需要的版本下载就可以了
注：可以用command+f搜索(图为5.7)本次安装8.0
二、安装
无脑继续就可以了
这里选择第三个，点next并设置mysql密码
勾选下面表示安装完成后启动mysql服务
配置环境变量
打开终端切换至根目录 编辑.bash_profile
cd ~
vim ./.bash_profile
按i键选择insert模式，加入这两行代码
export PATH=$PATH:/usr/local/mysql/bin
export PATH=$PATH:/usr/local/mysql/support-files
按esc输出：wq推出
刷新环境变量
source ~/.bash_profile
测试运行是否成功
最后的最后要注意
如果关闭终端在运行mysql 命令没有成功的话，是因为Mac终端在启动时没有自动刷新环境变量要在执行以下操作
vim ~/.zshrc
source ~/.bash_profile
esc :wq 退出即可
到此这篇关于M1芯片安装mysql8.0数据库的实现示例的文章就介绍到这了,更多相关M1芯片安装mysql8.0内容请搜索我们以前的文章或继续浏览下面的相关文章希望大家以后多多支持我们！
郑重声明：本文版权归原作者所有，转载文章仅为传播更多信息之目的，如作者信息标记有误，请第一时间联系我们修改或删除，多谢。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0960df730516038aa5ed1de6b6fbc545/" rel="bookmark">
			java dos平台压缩_DOS命令行下使用HaoZip进行文件压缩的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DOS命令，计算机术语，是指DOS操作系统的命令，是一种面向磁盘的操作命令，主要包括目录操作类命令、磁盘操作类命令、文件操作类命令和其它命令。
大家常用的操作系统有windows10,windows 7等，都是图形化的界面。在有这些系统之前的人们使用的操作系统是DOS系统。
下面看下DOS命令行下使用HaoZip进行文件压缩的内容。
Haozip、winrar等都是支持命令行下操作的，在写 dos 脚本的时候如果要进行压缩解压操作，必须使用命令。由于 Alliot 使用的是 HaoZip 这里以 HaoZip 为例，winrar 同理。
配置环境变量
右键我的电脑——属性——高级系统设置——高级——环境变量，在系统变量下选中 Path ，点击编辑-新建，输入你的 HaoZip 的安装路径，如 Alliot 的 HaoZip 安装路径是 C:\Program Files\2345Soft\HaoZip 保存-确定后重启计算机。
参数
打开 cmd，输入 HaoZipC 即可看到命令的使用提示：
使用参数：
HaoZipC
[...] [...]
[]
a：添加文件到压缩包
d：从压缩包删除文件
e：从压缩包解压文件(无目录)
l：列出压缩包内文件
t：验证压缩包内容
u：更新文件到压缩包
x：全路径解压压缩包
-ai[r[-|0]]{@文件名列表|!通配符}：包含压缩包
-ax[r[-|0]]{@文件名列表|!通配符}：排除压缩包
-bd：禁止百分比进度提示
-i[r[-|0]]{@文件名列表|!通配符}：包含文件名
-m{参数}：设置压缩方法
-o{目录}：设置解压输出目录
-p{口令}：设置口令
-r[-|0]：递归搜索子目录
-scs{UTF-8 | WIN | DOS}：设置文件列表字符集
-sfx[{名称}]：创建自解压压缩包
-si[{名称}]：从标准输出读取数据
-slt：为列出命令显示技术信息
-sn：禁止文字输出
-so：数据写入标准输出
-sv：数据写入标准输出时显示信息
-ssc[-]：大小写敏感模式
-ssw：压缩已写打开的文件
-t{类型}：设置压缩包类型
-v{大小}[b|k|m|g]：压缩分卷大小
-u[-][p#][q#][r#][x#][y#][z#][!新压缩包名称]：更新模式
-w[{目录}]: 指定工作目录，空目录则使用系统临时目录
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0960df730516038aa5ed1de6b6fbc545/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/143bed1aa99c97e5cc0874b96282e54e/" rel="bookmark">
			SQL编写一个自定义函数，判断年份是否为闰年
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 地球绕太阳运行周期为365天5小时48分46秒（合365.24219天）即一回归年（tropical year）。公历的平年只有365日，比回归年短约0.2422 日，所余下的时间约为每四年累计一天，故第四年于2月末加1天，使当年的历年长度为366日，这一年就为闰年。 现行公历中每400年有97个闰年。按照每四年一个闰年计算，平均每年就要多算出0.0078天，这样经过四百年就会多算出大约3天来。因此每四百年中要减少三个闰年。 所以公历规定：年份是整百数时，必须是400的倍数才是闰年；不是400的倍数的年份，即使是4的倍数也不是闰年。 也就是我们通常所说的： 四年一闰，百年不闰，四百年再闰。 总结可得☞
闰年的判断规则：
(1) 如果年份能被400整除，则是闰年
(2) 如果年份能被4整除但不能被100整除，则是闰年
脚本实现：
create function fn_leapyear(@year int) returns varchar(10) begin declare @sql varchar(10) set @sql = case when @year%4=0 and @year%100&lt;&gt;0 or @year%400=0 then 'True' else 'False' end return (@sql) end select dbo.fn_leapyear(2020) select dbo.fn_leapyear(2021) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec37e74211109b750212e428e64b99e6/" rel="bookmark">
			智能优化算法应用：基于麻雀搜索算法的工程优化案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		智能优化算法应用：基于麻雀搜索算法的工程优化案例 文章目录 智能优化算法应用：基于麻雀搜索算法的工程优化案例1.麻雀搜索算法2.压力容器设计问题3.三杆桁架设计问题4.拉压弹簧设计问题4.Matlab代码 摘要：本文介绍利用麻雀搜索算法，对压力容器设计问题进行智能寻优。 1.麻雀搜索算法 麻雀搜索算法具体原理请参照：https://blog.csdn.net/u011835903/article/details/108830958
2.压力容器设计问题 图1.压力容器示意图 压力容器设计问题的目标是使压力容器制作(配对、成型和焊接)成本最小，压力容器的设计如图1所示，压力容器的两端都有盖子封顶，头部一端的封盖为半球状． L L L 是不考虑头部的圆柱体部分的截面长度， R R R是圆柱体部分的内壁直径， T s T_s Ts​ 和 T h T_h Th​分别表示圆柱体部分壁厚和头部的壁厚， L L L、 R R R、 T s T_s Ts​ 和 T h T_h Th​ 即为压力容器设计问题的四个优化变量． 问题的目标函数和四个优化约束表示如下:
x = [ x 1 , x 2 , x 3 , x 4 ] = [ T s , T h , R , L ] x=[x_1,x_2,x_3,x_4]=[T_s,T_h,R,L] x=[x1​,x2​,x3​,x4​]=[Ts​,Th​,R,L]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec37e74211109b750212e428e64b99e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a63f1387f02b30d36591f7fdd9733fa8/" rel="bookmark">
			QQ在夜间模式下聊天字体看不清
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述：在iPhone上用QQ，发现夜间模式下字体看不清（如下图所示），而iPad却没问题
这个问题困扰了我很久，一开始在网上没找到解决方法，于是就放弃了，QQ就一直没开夜间模式。但是随着时间的流逝，我忍不了了，又去网上找方法还是没找到，于是我去问腾讯客服，我按照客服说法，解决了问题，解决方法是：
1.点击QQ左上角头像
2.点击我的个性装扮
3.点击右下角我的
4.点击全部回复5.大功告成，记得点个赞哦
终于搞定这个问题了，就像是解决了一个心腹大患，不过还有一点吐槽，为什么点击QQ和微信的聊天通知就是不能跳转到该聊天，非得多点一下，难道实现起来很难吗？
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/213/">«</a>
	<span class="pagination__item pagination__item--current">214/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/215/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>