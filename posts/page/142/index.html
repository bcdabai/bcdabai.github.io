<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a322e1d93f4efbf891db8eac164c25b6/" rel="bookmark">
			Jmeter之性能测试TPS解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、获得TPS插件
jmeter下TPS插件的安装 - 随风迎 - 博客园 参见，已保存百度云盘
2、添加后，记得使用调度器——每秒50个并发，持续60秒，观察TPS 3、TPS，执行一次事务（包括请求、请求服务器、等待服务器返回等等，比如一个TPS事务，可能触发3个QPS请求）
PS：一秒钟处理的事务数。TPS值越大，一秒钟处理的事务数就越多，说明处理速度越快，软件的效率就越好。
一、TPS：Transactions Per Second（每秒传输的事物处理个数），即服务器每秒处理的事务数。TPS包括一条消息入和一条消息出，加上一次用户数据库访问。（业务TPS = CAPS × 每个呼叫平均TPS）
TPS是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。
一般的，评价系统性能均以每秒钟完成的技术交易的数量来衡量。系统整体处理能力取决于处理能力最低模块的TPS值。
二、QPS：每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，在因特网上，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。
对应fetches/sec，即每秒的响应请求数，也即是最大吞吐能力。
有时，Throughput也可以代表吞吐量——如图中，图1中的点在24上下浮动，图2中的Throughput23.7，虽然没有详细计算两个值对比是否一致，但如果单测一个接口时，jmeter聚合报告中的Throughput可以代表吞吐量（也可以手动计算吞吐量=请求数/时间，会发现跟聚合报告中的Throughput几乎相等）
4、吞吐量与并发数
一个接口一秒钟能承受50个并发，不代表可以有50个吞吐量；
吞吐量与系统性能息息相关；
设置长时间跑接口，比如1秒50并发，持续60秒——发现实际接口请求数1461个，时间60秒，TPS参数较稳定；
TPS大概在23左右，所以当前这个接口，系统能处理的事务在23个左右
TPS=请求数/时间
QPS/TPS/并发量/系统吞吐量的概念 QPS: 每秒钟处理完请求的次数；注意这里是处理完。具体是指发出请求到服务器处理完成功返回结果。可以理解在server中有个counter，每处理一个请求加1，1秒后counter=QPS。
TPS：每秒钟处理完的事务次数，一般TPS是对整个系统来讲的。一个应用系统1s能完成多少事务处理，一个事务在分布式处理中，可能会对应多个请求，对于衡量单个接口服务的处理能力，用QPS比较多。
并发量：系统能同时处理的请求数
RT：响应时间，处理一次请求所需要的平均处理时间
计算关系：
QPS = 并发量 / 平均响应时间
并发量 = QPS * 平均响应时间
5、jmeter限制，最多100-200个并发，可以尝试使用LR，LR可监测jvm参数
6、Vu和TPS换算 ——很有用的文章 性能测试知多少 --并发用户数与TPS之间的关系_CN_项目集管理专家(PgMP)的博客-CSDN博客_tps2000支持多少用户同时点击
TPS是每秒事务数，但是事务是要靠虚拟用户做出来的，假如1个虚拟用户在1秒 内完成1笔事务，那么TPS明显就是1；如果某笔业务响应时间是1ms,那么1个用户在1秒内能完成1000笔事务，TPS就是1000了；如果某笔业务 响应时间是1s,那么1个用户在1秒内只能完成1笔事务，要想达到1000TPS，至少需要1000个用户；因此可以说1个用户可以产生 1000TPS，1000个用户也可以产生1000TPS，无非是看响应时间快慢。
7、性能测试策略
做性能测试需要一套标准化流程及测试策略，并发用户数只是指标考虑的一个，在做负载测试的时候，一般都是按照梯度施压的方式去加用户数，而不是在没 有预估的情况下，一次加几万个用户，，交易失败率非常高，响应时间非常长，已经超过了使用者忍受范围内，这样做没有多大的意义，这就好比“有多少钱可以干多少事”一样，需要选择相关的策略。
8、总结
系统的性能由TPS决定，跟并发用户数没有多大关系。在同样的TPS下，可以由不同的用户数去压（通过加思考时间设置）。系统的最大TPS是一定的（在一个范围内），但并发用户数不一定，可以调整。建议性能测试的时候，不要设置过长的思考时间，以最坏的情况下对服务器施压。一般情况下，大型系统（业务量大、机器多）做压力测试，5000个用户并发就够了，中小型系统做压力测试，1000个用户并发就足够了。 9、应用场景
1⃣️比如要单独测试一个用户注册接口，想知道在配置A情况下tps是多少：设置请求时间如300s（短时间一般很难压出来，可以设置5-10分钟对比看下），同样配置下（机器、带宽等），改变线程数，并发数50-100-150，以此类推，可以观察jmeter查看结果树中的Throughput，通常会得出峰值曲线，也就是在某个并发范围内，tps达到最高值，低于或高于该线程数范围，tps会下降。那么，可以得出该接口最高tps值是多少（在xx并发数情况下、配置情况下）
2⃣️可以对比不同环境配置（机器、带宽等等）或代码优化后，同样线程请求下，tps最高值对比
——打个比方，可以理解接口类似于一个安全出口，tps类似于同一时间下通过人数，线程数为通过人数；当通过人数仅有10，安全出口不拥挤，一个个慢慢走过，tps是低的；当通过人数比如100，安全出口正好可以全部通过，此时tps达到峰值；当通过人数远远大于安全出口容量，如1000，此时爆挤，每个人都想通过，安全出口本来可以出100人，但是因为拥挤只能走30人；最坏情况10000人或者更高，那么这种情况下如果是豆腐渣工程，安全出口就挤崩了（类似于高并发情况下请求无响应）。所以需要测试不同线程数、时间情况下 tps最高是多少。
该种情况下是为了得到接口真实tps（比如内部对接口性能要求等），并不是通常用户或客户理解的‘你们能承受多少并发’，实际场景中接口的用户并发数多高，需要参考 吞吐量定时器来设置，以及根据接口应用场景设计性能场景。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73dcc145290cc9c0148192690f5b2184/" rel="bookmark">
			autojs 真机脚本开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、环境需求
安卓系统 手机 要求： android 8 + ， 需打开开发者模式，各型号打开方式不一样，百度即可 vs code 编辑器，下载后需要安装 autojs 插件 下载autojs 安装包, 传送门：https://pro.autojs.org/ 注意：手机和电脑需在同一局域网路下 可选： total control （ 手机模拟器，只支持windows） 1、手机安装好autojs
下载完后打开autojs 软件，打开设置，打开无障碍模式，点击连接到服务器，会弹框显示信息，等第二步操作
2、下载vs code 后，安装插件
安装完后
按住 ctrl + alt + p 选择后，选择autojs 自带命令连接，输入 APP 上的服务器地址后回车，一般是 192.160..
连接成功后会提示如下图
3、连接成功后，在vs code 编译器上新建js文件，例：demo.js 文件，编写脚本案例，
demo.js
// 打开APP app.launchApp('百度') // 睡眠 sleep(1000) // 点击 click(456, 224) 4、脚本编写完后，执行运行操作，
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/498ccfa5d268848ede38139c6119904e/" rel="bookmark">
			Spring自动装配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring自动装配 byNamebyType使用注解@Autowired@Qualifier@Resource注解配置相对于 XML 配置具有很多的优势：使用 @Component 自动装配说明 自动装配是使用spring满足bean依赖的一种方法spring会在应用上下文中为某个bean寻找其依赖的bean。 Spring中bean有三种装配机制，分别是：
在xml中显式配置；在java中显式配置；隐式的bean发现机制和自动装配。 这里我们主要讲第三种：自动化的装配bean。
Spring的自动装配需要从两个角度来实现，或者说是两个操作：
组件扫描(component scanning)：spring会自动发现应用上下文中所创建的bean；自动装配(autowiring)：spring自动满足bean之间的依赖，也就是我们说的IoC/DI； 组件扫描和自动装配组合发挥巨大威力，使得显示的配置降低到最少。
推荐不使用自动装配xml配置 , 而使用注解 .
测试环境搭建
1、新建一个项目
2、新建两个实体类，Cat Dog 都有一个叫的方法
public class Cat { public void shout() { System.out.println("miao~"); } } public class Dog { public void shout() { System.out.println("wang~"); } } 3、新建一个用户类 User
public class User { private Cat cat; private Dog dog; private String str; } 4、编写Spring配置文件
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/498ccfa5d268848ede38139c6119904e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba7380a565886b343823a0f2c3455341/" rel="bookmark">
			RuntimeError: CUDA error: invalid device ordinal
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决方法： 在代码中加入
os.environ["CUDA_DEVICE_ORDER"]="PCI_BUS_ID" os.environ["CUDA_VISIBLE_DEVICES"] = "0,1,2" 亲测有效
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1c94f0acfd3b70c450597a501d5f66f/" rel="bookmark">
			VREP（Coppeliarobotics）仿真介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 仿真介绍 在内部，模拟器将使用额外的中间状态，以便正确地通知脚本或程序接下来会发生什么。 以下状态图说明了模拟器的内部状态：
Simulation Loop（仿真循环）
模拟器通过以恒定时间步长推进模拟时间来运行。 下图说明了主要的模拟循环：
通过尝试使仿真时间与实时同步来支持实时仿真：
以下代表一个非常简化的主要客户端应用程序（为了清晰起见，已省略消息、插件处理和其他细节）：
void initializationCallback { // do some initialization here } void loopCallback { if ( (simGetSimulationState()&amp;sim_simulation_advancing)!=0 ) { if ( (simGetRealTimeSimulation()!=1)||(simIsRealTimeSimulationStepNeeded()==1) ) { if ((simHandleMainScript()&amp;sim_script_main_script_not_called)==0) simAdvanceSimulationByOneStep(); } } } void deinitializationCallback { // do some clean-up here } 根据仿真的复杂性、计算机的性能和 simulation settings，实时仿真可能并不总是可行
Simulation Speed(仿真速度)
在非实时仿真中，仿真速度（即感知速度）主要取决于两个因素：仿真时间步长（simulation time step）和一次渲染通道的模拟通道数（有关更多详细信息，请参阅仿真对话框）。 在实时仿真的情况下，仿真速度主要取决于实时乘法系数，还取决于一定程度的仿真时间步长（仿真时间步长过小可能与实时性不兼容）。 由于计算机的计算能力有限而导致仿真的特征）。 在仿真过程中，可以使用以下工具栏按钮调整模拟速度：
以某种方式调整仿真速度，以便从不增加初始模拟时间步长（因为这可能会导致例如破坏机制）。 下面两张图说明了仿真速度调节机制：
默认情况下，每个仿真周期由以下顺序操作组成：
执行主脚本(main script)渲染场景 仿真时间设置对话框 点击[菜单栏–&gt;Simulation–&gt;Simulation settings]即可调出仿真对话框 Time step：即仿真时间步长。主脚本每执行一次，仿真时间增加一个仿真时间步长。使用大仿真步长会加快仿真速度但同时也不准确/不稳定，当然使用小步长会实现更精确的模拟但会花费更长时间。因此建议默认步长。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4624087e616374c58f640678e5608498/" rel="bookmark">
			2022年湖北师范大学招生简章--成人高等教育高起专、专升本学历提升
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、湖北师范大学学校介绍：
湖北师范大学是一所以教育学、文学、理学、工学为主要学科门类，以教师教育为特色，以服务基础教育为主体的省属重点本科高等师范院校，具有硕士学位授予权，是全国本科教学工作水平评估优秀学校、国家产教融合发展工程应用型本科建设高校、湖北省国内“双一流”建设高校。
学校位于黄石市中心城区，规划占地2002亩，校舍总面积60余万平方米。学校襟江带湖，含山蓄水，绿茵广场、曲径小道、花坛公园、楼台亭榭、形象雕塑、书画走廊等自然人文景观错落有致，相映成辉，风光宜人，环境优美，曾被评为“湖北省绿化先进单位”“湖北省卫生先进单位”“湖北省安全文明单位”“湖北省园林式单位”“湖北省文明校园”和“湖北省最佳文明单位”，是读书治学和陶冶情操的理想场所。
设有20个教学科研单位，10个一级学科硕士点，7个专业学位硕士点，68个本科专业。建有1个国内一流学科建设学科、2个省级优势特色学科群、6个省级重点学科，3个国家级特色专业、1个国家级一流专业建设点、17个省级一流专业建设点、7个省级品牌专业，8个省级教学团队、8个省级优秀基层教学组织，1门国家级精品课程、1门国家级精品资源共享课程、12门省级精品课程、7门省级精品资源共享课程、3门省级精品资源公开课程、2门省级精品在线开放课程，1个国家级专业综合改革试点项目、6个省级专业综合改革试点项目、8个湖北省战略性新兴（支柱）产业人才培养计划项目，1个国家级实验教学示范中心、8个省级实验教学示范中心、3个省级虚拟仿真实验教学中心，2个省级重点实验室、2个省级工程研究中心（工程实验室）、4个省级人文社科重点研究基地、1个省级协同创新中心，8个省级研究生教育创新基地（工作站）。
湖北师范大学继续教育学院依托学校雄厚的师资力量和优良的办学条件，在经过近半个世纪的成人高等教育实践中形成了优良的办学传统。学校历任领导都高度重视以函授业余为主体的成人高等教育，将其纳入学校的整体规划，建立了一支专兼结合的优秀的函授教师队伍。随着学校函授业余教育规模的不断扩大，湖北师范大学招生范围逐步由湖北扩展到广西、云南、广东、浙江等省。为了更好地服务于国家的经济建设和社会发展，也为了更好地满足社会日益增长的学习需求，学校在招生专业设置上打破了单一的师范格局，已经形成多层次、多规格、多种形式协调发展的成人高等教育办学体系。现有函授、业余招生专业61个;高等教育自学考试主考专业14个。在开展学历教育的基础上，学校非常重视加强非学历性质的继续教育，承接了教育部、财政部“国培计划—湖北省农村中小学骨干教师培训项目”及“国培计划—湖北省农村幼儿教师培训项目”，开办了各种短期培训班。学院以优良的教学资源、先进的办学理念和现代化的教育技术手段，励精图治，不断创新，创建了成人高等教育领域的省优名牌，赢得了广泛的社会声誉。 一、湖北师范大学成人高考之报考对象和条件
1、遵守中华人民共和国宪法和法律，拥护中国共产党的领导，品德良好，身体健康。
2、报考高起本或专科的考生应具有高中(中职、技校)毕业文化程度。报考专升本的考生必须是已取得经教育部审定核准的国民教育系列高等学校、高等教育自学考试机构颁发的专科或专科以上毕业证书的人员。
二、湖北师范大学成人高等教育之招生专业：
专业最终以教育部专业申报系统审核结果为准，基本学历提升的所有专业都可以报考，学历提升联系甘建二
三、湖北师范大学成人高考之报名流程：
1、现在报名，提交资料给我校
2、10月份参加全国统一线下成人高考考试
3、11月份查询成绩
4、12-1月份发录取通知书
5、次年3-5月份学信网查询学籍信息，2.5年毕业
四、湖北师范大学成人高考之考试科目：
1.考试时间
考试时间：10月中下旬周末考试
注：具体报考时间，以教育部和湖北省教育考试院的通知为准，具体考试时间请听甘建二老师通知
2. 考试科目
1、高中起点专科（高升专）：
文科：语文、数学（文史类）、外语
理科：语文、数学（理工类）、外语
以上各科试题卷面满分均为150分，总分450分。
2、高中起点本科（高升本）：
文科：语文、数学（文史类）、外语、历史地理综合
理科：语文、数学（理工类）、外语、物理化学综合
以上各科试题卷面满分均为150分，总分600分。
专科起点本科（专升本）：
专升本：政治、外语、专业基础课（根据所选专业大类不同）
教育类：政治、英语、教育理论
理工类：政治、英语、高等数学（一）
文史类：政治、英语、大学语文
经管类：政治、英语、高等数学（二）
法学类：政治、英语、民法概论
以上各科试题卷面满分均为150分，总分450分。成人高考及格分数考够120分左右即可，年满25周岁可以享受加分20分的机会。成人高考考试非常简单，三门基本120分即可。其实考过非常简单。
五、湖北师范大学成人高等教育之报名程序和时间
湖北省实行网上报名与现场确认相结合的方式进行。湖北省考生可以到湖北师范大学继续教育学院成教招生办公室或各函授站点咨询并报名。其他省份报名程序及时间以各省教育考试院规定为准。
1、网上报名:参加成人高考的学员须在湖北省教育考试院规定的时间内登陆湖北省教育考试院指定的报名网站（网址：http://crgk.hbee.edu.cn）报名，并预约报名现场确认点。
2、现场确认：现场都是线上确认，因为某些原因
六、湖北师范大学成人高等教育学习费用
高升专：私信甘建二，比官方价格便宜
专升本：私信甘建二，比官方价格便宜
七、湖北师范大学成人高等教育学习费用毕业生待遇
学生学完教学计划规定的全部课程，经考核合格，由湖北师范大学颁发国家承认的成人高等教育专科或本科毕业文凭，符合学士学位授予条件的本科毕业生可授予学士学位，所有毕业文凭实行教育部统一电子注册，并可在教育部学生信息网（网址：http://www.chsi.com.cn）查询。
八、湖北师范大学成人高考教育优势
1: 本校报名，本校学习；
2: 专业好学校知名度高；
3: 考前辅导品质好，学校录取比例高；
4: 业余学习，不占用工作时间；
5: 稀缺专业，成教专业独家开设；
6: 文凭含金量高，国家认可，学信网可查，可以考公务员和考研究生；
九、湖北师范大学成人高考学历之报名时间及提交材料：
1.报名时间：成人高考网上报名时间至8月底，需要报名的学员一定抓紧时间，赶快报名
2.报名手续：湖北省实行网上报名与网上确认相结合的方式进行，湖北省考生可以到甘建二招生办公室咨询并现场报名。其他省份报名程序及时间以各省教育考试院规定为准，主要的可以直接与甘建二报名招生网点取得联系即可。
湖北师范大学，大专、本科招生火热报名中，需要学历提升联系甘建二，目前学历提升费用最低，早报早划算
甘建二主要从事：安全员ABC报考、建设厅七大员、特种工报考（安监局、建设厅）、一级建造师报名培训、二级建造师报名培训、造价工程师报名培训、消防工程师报名培训、监理工程师报名培训、注册安全工程师报名培训、BIM工程师、装配式工程师、学历提升（中专、大专、本科学历）、职称评审（初级、中级、高级职称）、企业安许申报、企业资质申报等业务，甘建二老师已有6年丰富经验，服务大大小小上万个企业和个人客户，耐心、真诚、用心，建筑考证你值得拥有属于你的私人小管家客服老师--甘建二
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d45f8dc2707da1362115391281db7413/" rel="bookmark">
			《Python工匠：案例、技巧与工程实践》-第1章 变量与注释-1.1基础知识-学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《Python工匠：案例、技巧与工程实践》-第1章 变量与注释-1.1基础知识-学习笔记
目录 1.变量常见用法1.1变量解包1.2单下划线变量名_ 2.给变量注明类型3.变量命名原则3.1 遵循PEP 8原则3.2 描述性要强3.3 要尽量短3.4 要匹配类型3.4.1匹配布尔值类型的变量名3.4.2匹配int/float类型的变量名3.4.3匹配其他类型的变量名3.4.4超短命名 4.注释基础知识 1.变量常见用法 1.1变量解包 变量解包（unpacking）是Python里的一种特殊赋值操作，允许我们把一个可迭代对象（比如列表）的所有成员，一次性赋值给多个变量
Python还支持更灵活的动态解包语法。只要用星号表达式（*variables）作为变量名，它便会贪婪[插图]地捕获多个值对象，并将捕获到的内容作为列表赋值给variables。
1.2单下划线变量名_ 在常用的诸多变量名中，单下划线_是比较特殊的一个。它常作为一个无意义的占位符出现在赋值语句中。_这个名字本身没什么特别之处，这算是大家约定俗成的一种用法。举个例子，假如你想在解包赋值时忽略某些变量，就可以使用_作为变量名
2.给变量注明类型 为了解决动态类型带来的可读性问题，最常见的办法就是在函数文档（docstring）里做文章。我们可以把每个函数参数的类型与说明全都写在函数文档里。
类型注解，只需在变量后添加类型，并用冒号隔开即可，比如func(value:str)表示函数的value参数为字符串类型。
3.变量命名原则 3.1 遵循PEP 8原则 · 对于普通变量，使用蛇形命名法，比如max_value；
· 对于常量，采用全大写字母，使用下划线连接，比如MAX_VALUE；
· 如果变量标记为“仅内部使用”，为其增加下划线前缀，比如_local_var；
·当名字与Python关键字冲突时，在变量末尾追加下划线，比如class_。
除变量名以外，PEP 8中还有许多其他命名规范，比如类名应该使用驼峰风格（FooClass）、函数应该使用蛇形风格（bar_function），等等。给变量起名的第一条原则，就是一定要在格式上遵循以上规范。
3.2 描述性要强 3.3 要尽量短 3.4 要匹配类型 3.4.1匹配布尔值类型的变量名 3.4.2匹配int/float类型的变量名 当人们看到和数字有关的名字时，自然就会认定它们是int或float类型。
这些名字可简单分为以下几种常见类型：
释义为数字的所有单词，比如port（端口号）、age（年龄）、radius（半径）等；
使用以_id结尾的单词，比如user_id、host_id；
使用以length/count开头或者结尾的单词，比如length_of_username、max_length、users_count。
3.4.3匹配其他类型的变量名 在代码中明确标注它们的类型详情
3.4.4超短命名 在众多变量名里，有一类非常特别，那就是只有一两个字母的短名字。这些短名字一般可分为两类，一类是那些大家约定俗成的短名字，比如：
· 数组索引三剑客i、j、k
· 某个整数n
· 某个字符串s
· 某个异常e
· 文件对象fp
4.注释基础知识 Python里的注释主要分为两种，一种是最常见的代码内注释，通过在行首输入#号来表示
除使用#的注释外，另一种注释则是我们前面看到过的函数（类）文档（docstring），这些文档也称接口注释（interface comment）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6de7e4f39469c262ac838ccfe26300e/" rel="bookmark">
			vim中替换字符串的方法有哪些
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章为大家带来有关vim中替换字符串的方法介绍，如果在日常学习或工作遇到这个问题，希望大家通过这篇文章的几种方法解决替换字符串的问题。
:%s/str1/str2/g 替换每一行中所有str1为str2 常用！
:s/str1/str2/g 替换当前行所有str1为str2
基本替换
:s/str1/str2/ 替换当前行第一个str1为str2
:s/str1/str2/g 替换当前行所有str1为str2
:n,$s/str1/str2/ 替换第 n 行开始到最后一行中每一行的第一个str1为str2
:n,$s/str1/str2/g 替换第 n 行开始到最后一行中每一行所有str1为str2
（n 为数字，若 n 为 .，表示从当前行开始到最后一行）
:%s/str1/str2/（等同于 :g/str1/s//str2/） 替换每一行的第一个str1为str2
:%s/str1/str2/g（等同于 :g/str1/s//str2/g） 替换每一行中所有str1为str2
可以使用 # 作为分隔符，此时中间出现的 / 不会作为分隔符
:s#str1/#str2/# 替换当前行第一个str1/ 为str2/:%s+/str11/str12/+/str21/str22+ （使用+ 来 替换 / ）： /str11/str12/替换成/str21/str22/
文件中删除^M
问题描述：对于换行，Windows下用回车换行（0A0D）来表示，Linux下是回车（0A）来表示。这样，将window上的文件拷到Unix上用时，总会有个^M，请写个用在Unix下的过滤Windows文件的换行符（0D）的shell或c程序。有两种方法可以完成此目的：(1)使用命令：cat oldfilename | tr -d “^V^M” &gt; newfilename
(2)使用命令：sed -e “s/^V^M//” oldfilename &gt; newfilename
需要注意的是在1、2两种方法中，^V和^M指的是Ctrl+V和Ctrl+M。你必须要手工进行输入，而不是粘贴。
在vim中处理：首先使用vim打开文件，然后按ESC键，接着输入命令：
:%s/^V^M//
:%s/^M$//g
如果上述方法无用，则正确的解决办法是：
(1) tr -d "\r" &lt; old_file_name&gt;new_file_name 或者 cat oldfilename | tr -d "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6de7e4f39469c262ac838ccfe26300e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90964ce92b5b5ef98bedbbd02a11cf42/" rel="bookmark">
			threejs加载纹理图跨域
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		threejs加载纹理图报错Failed to execute ‘texImage2D’ on ‘WebGL2RenderingContext’: The image element contains cross-origin data, and may not be loaded
//添加平面 addPlane() { var planeGeometry = new THREE.BoxGeometry(4000, 10, 4000); //var texture = THREE.ImageUtils.loadTexture("static/bg-white.jpg"); //加载本地纹理图 THREE.ImageUtils.crossOrigin = ''; //处理纹理图加载跨域问题 var texture = THREE.ImageUtils.loadTexture( this.sceneImg); //加载纹理贴图 var material = new THREE.MeshLambertMaterial({ //贴图通过材质添加给几何体 map: texture, //给纹理属性map赋值 side: 0, //两面可见 }); //材质对象 this.mesh = new THREE.Mesh(planeGeometry, material); //纹理贴图网格模型对象 this.mesh.position.set(0, -5, 0) this.scene.add(this.mesh) }, 加载本地资源不会出现跨域的情况，但是使用后台返回的资源就会报错 Failed to execute ‘texImage2D’ on ‘WebGL2RenderingContext’: The image element contains cross-origin data, and may not be loaded 这个时候就加一句THREE.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90964ce92b5b5ef98bedbbd02a11cf42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52a8819e9c570526af9ab0309923e734/" rel="bookmark">
			导入JankStats检测卡帧库遇到问题记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		google发布了可以检测卡帧的JankStats库，本来想集成到项目中的，结果遇到了版本兼容问题，需要改动地方很多，目前先记录一下。
JankStats是纯kotlin写的，导入很简单
implementation "androidx.metrics:metrics-performance:1.0.0-alpha02"
同步的时候就报错了
/Users/zhongyili/.gradle/caches/transforms-2/files-2.1/2af233cf44fb627a05460fefda84fe69/jetified-metrics-performance-1.0.0-alpha02-api.jar!/META-INF/metrics-performance_release.kotlin_module: Module was compiled with an incompatible version of Kotlin. The binary version of its metadata is 1.7.1, expected version is 1.4.2. /Users/zhongyili/.gradle/caches/transforms-2/files-2.1/32dbb0f9536d21570b57493fe5ed0eb2/jetified-kotlin-stdlib-common-1.7.0.jar!/META-INF/kotlin-stdlib-common.kotlin_module: Module was compiled with an incompatible version of Kotlin. The binary version of its metadata is 1.7.1, expected version is 1.4.2. 其实就是kotlin插件版本太低导致的，看错误说明，需要的版本是1.7.1，实际是1.4.2。
所以我们得升级一下kotlin版本。
我一开始以为官方集成kotlin文档中写的版本肯定是的新的，结果不是，这是一个小坑
将 Kotlin 添加到现有应用
最近版本在下面地址中找
kotlin-gradle-plugin
目前kotlin最新版本是1.7.10
修改后，还是报错
Build file '/Users/zhongyili/work/AndroidStudioProjects/sohuvideo_gradle/sohuVideoMobile/build.gradle' line: 5 A problem occurred evaluating project ':sohuVideoMobile'.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52a8819e9c570526af9ab0309923e734/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bd6cb3e1baef3cc86e0bd2f14f6a5a3/" rel="bookmark">
			Java进阶 之 Stream流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Stream流思想： 就相当于流水线一样，一道工序一道工序的进行排查，得出最后结果。
1.创建Stream流对象 1.1单列集合创建Stream流
// 单列 创建Stream List 可重复的 List&lt;String&gt; list = List.of("张三","李四","王五"); Stream&lt;String&gt; stream1 = list.stream(); // 单列不可重复的 Set&lt;String&gt; set = Set.of("张三","李四","王五"); Stream&lt;String&gt; stream2 = set.stream(); 1.2双列集合创建Stream流对象 // 双列 不能直接产生Stream流对象，而是通过先转单 Map&lt;String, Integer&gt; map = Map.of("张三", 19, "李四", 30); Set&lt;String&gt; set1 = map.keySet(); Stream&lt;String&gt; stream = set1.stream(); 注意：双列集合不能直接创建Stream流对象，要用它的 keySet()方法 获取到单列集合。
3.数组 创建流对象
// 数组 int[] arr = {1,2,3}; IntStream stream3 = Arrays.stream(arr); 数组要通过它的Arrays工具类 进行创建 Stream流。
4.相同类型;
Stream&lt;String&gt; stream4 = Stream.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5bd6cb3e1baef3cc86e0bd2f14f6a5a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d40d0c9a2874cb9432430387b3a57f4/" rel="bookmark">
			ADB安装方法：
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一：下载ADB安装包进行安装（其实是我重要文件压缩放到百度网盘），这种方法适合那种不是安卓开发人员，只需要ADB做调试使用的。里面包含四个文件，分别是adb、AdbWinApi、AdbWinUsbApi、fastboot。环境变量配置请看方法二。
下载链接: http://xiazai.jb51.net/201807/yuanma/ADB_jb51.rar
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1a9f4c05f7df73ba84d81d2d30d5e42/" rel="bookmark">
			python中map()函数总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**
python中map()函数总结 **
1.关于map()函数 （1）map函数是python中的一个内置函数，做映射。
（2）map()函数返回的是一个新的迭代器对象，不会改变原有对象！
2.语法 class map(object) | map(func, *iterables) --&gt; map object | | Make an iterator that computes the function using arguments from | each of the iterables. Stops when the shortest iterable is exhausted. | | Methods defined here: | | __getattribute__(self, name, /) | Return getattr(self, name). | | __iter__(self, /) | Implement iter(self). | | __next__(self, /) | Implement next(self). | | __reduce__(.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1a9f4c05f7df73ba84d81d2d30d5e42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e203f060bc0eefb7f148affc0538fc9c/" rel="bookmark">
			ERROR in ./src/css/normal.css Module build failed: TypeError: this.getOptions is not a function
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		npm ERR! code ELIFECYCLE
npm ERR! errno 2
npm ERR! meetwebpack@1.0.0 build: `webpack`
npm ERR! Exit status 2
npm ERR!
npm ERR!
npm ERR! Failed at the meetwebpack@1.0.0 build script.
npm ERR! This is probably not a problem with npm. There is likely additional logging output a
bove.
出现这个问题一般都是CSS或style版本过高的问题
如果你是从“最全最新Vue、Vuejs教程，从入门到精通”过来的 那么建议你使用以下版本
npm install css-loader@3.6.0
或者
npm install --save-dev style-loader@1.00
最终也是打包成功！
我也是找了很久才解决好这个问题，有什么不懂的欢迎评论区讨论哦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/731764ceae03f70d195f909824edc49a/" rel="bookmark">
			启动Hive初始化MySQL报错：MySQLSyntaxErrorException : Unknown database ‘hive‘SQL Error code: 1049
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决办法：通过vi hive-site.xml命令进入配置文件，将原有的两行命令改成一行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ab9e48f5dae27818075f64caba5e6d1/" rel="bookmark">
			Netty粘包拆包、自定义Protostuff编解码器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Netty粘包拆包 TCP是一个“流”协议，所谓流，就是没有界限的一长串二进制数据。TCP作为传输层协议并不了解上层业务数据的具体含义，会根据TCP缓冲区的实际情况进行数据包的划分；所以在业务上认为是一个完整的包，可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题。
例如，TCP缓冲区是1024个字节大小，如果应用一次请求发送的数据量比较小，没达到缓冲区大小，TCP则会将多个请求合并为同一个请求进行发送，这就形成了粘包问题；如果应用一次请求发送的数据量比较大，超过了缓冲区大小，TCP就会将其拆分为多次发送，这就是拆包，也就是将一个大的包拆分为多个小包进行发送。
半包的主要原因:
发送方写入数据 &gt; 套接字缓冲区大小发送的数据大于协议的 MTU(Maximum Transmission Unit，最大传输单元)，必须拆包 粘包的主要原因:
发送方每次写入数据 &lt; 套接字缓冲区大小接收方读取套接字缓冲区数据不够及时 如下图所示，一次性发送服务端50条消息，客户端收到的消息
解决半包粘包问题的常用三种解码器（一次解码器：结果是字节）
二次解码器：将 Java 对象与字节流转化方便存储或传输
一次解码器:ByteToMessageDecoder io.netty.buffer.ByteBuf (原始数据流)-&gt; io.netty.buffer.ByteBuf (用户数据) 二次解码器:MessageToMessageDecoder io.netty.buffer.ByteBuf (用户数据)-&gt; Java Object常用的二次解码器，json、Protobuf、xml等 1.1、LineBasedFrameDecoder（回车换行分包） Netty中，提供了一个开箱即用、使用换行符分割字符串的解码器——LineBasedFrameDecoder，它是一个最为基础的Netty内置解码器。这个解码器的工作原理，依次遍历ByteBuf数据包中的可读字节，判断在二进制字节流中是否存在换行符"\n"或者"\r\n"的字节码。如果有，就以此位置为结束位置，把从可读索引到结束位置之间的字节作为解码成功后的ByteBuf数据包。
LineBasedFrameDecoder支持配置一个最大长度值，表示解码出来的ByteBuf能包含的最大字节数。如果连续读取到最大长度后仍然没有发现换行符，就会抛出异常。
注意顺序
1.2、DelimiterBasedFrameDecoder（特殊分隔符分包） DelimiterBasedFrameDecoder解码器不仅可以使用换行符，还可以使用其他特殊字符作为数据包的分隔符，例如制表符"\t"。
DelimiterBasedFrameDecoder与LineBasedFrameDecoder都支持配置一个最大长度值，同时还支持解码后的数据包是否去掉分隔符，分隔符
pipeline.addLast(new DelimiterBasedFrameDecoder(10240,false,Unpooled.copiedBuffer(“!”.getBytes(“UTF-8”))));
构造方法
public DelimiterBasedFrameDecoder( int maxFrameLength, //解码的数据包的最大长度 Boolean stripDelimiter, //解码后的数据包是否去掉分隔符 ByteBuf delimiter //分隔符 ) 1.3、LengthFieldBasedFrameDecoder（固定长度字段报文来分包） LengthFieldBasedFrameDecoder可以翻译为“长度字段数据包解码器”。传输内容中的Length(长度)字段的值是指存放在数据包中要传输内容的字节数。
消息分为两部分，一部分为消息头部，一部分为实际的消息体。其中消息头部是固定长度的，消息体是可变的，且消息头部一般会包含一个Length字段
LengthFieldBasedFrameDecoder与LengthFieldPrepender需要配合起来使用，其实本质上来讲，这两者一个是解码，一个是编码的关系。
LengthFieldPrepender（如果我们在发送消息的时候采用：消息长度字段+原始消息的形式，我们就可以使用 LengthFieldPrepender。 LengthFieldPrepender 可以将待发送消息的长度（二进制字节长度）写到 ByteBuf 的前两个字节） 原理：
在生成的数据包中添加一个长度字段，用于记录当前数据包的长度。
LengthFieldBasedFrameDecoder会按照参数指定的包长度偏移量数据对接收到的数据进行解码，从而得到目标消息体数据；
LengthFieldPrepender则会在响应的数据前面添加指定的字节数据，这个字节数据中保存了当前消息体的整体字节数据长度。
LengthFieldBasedFrameDecoder构造方法参数：
maxFrameLength：发送数据包的最大长度lengthFieldOffset：长度域的偏移量。长度域位于整个数据包字节数组中的开始下标。lengthFieldLength：长度域的字节数长度。lengthAdjustment：长度域的偏移量矫正。如果长度域的值，除了包含有效数据域的长度外，还包含了其他域（如长度域自身）长度，那么，就需要进行矫正。矫正的值为：包长 - 长度域的值 – 长度域偏移 – 长度域长。initialBytesToStrip：丢弃的起始字节数。丢弃处于此索引值前面的字节。 ch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ab9e48f5dae27818075f64caba5e6d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/262f48872817418df233f854acdffd12/" rel="bookmark">
			Linux设备树 01 ———— 内核笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		活动地址：CSDN21天学习挑战赛
本周： 2022-08-01——2202-08-07
计划： 完成 Linux设备树和Pinctrl 的学习
个人的状况：本人现已经大学毕业（2022届毕业生），有过3个多月的实习经历，实习期间主要做的事android 的BSP移植，目前主要工作是做驱动的移植，所以对本节学习的内容是有一定的基础的。
Linux设备树和Pinctrl 一、Linux设备树1.1 Linux设备树概述1.2 设备树1 、dts/dtsi2、dtc3、dtb 1.3 设备树语法1、框架2、设备节点3. 设备节点的标准属性compatible 属性Status 属性![在这里插入图片描述](https://img-blog.csdnimg.cn/77271cdfba8e4906b0c015c31eb23373.png)address-cells、#size-cells和reg (寻址属性)ranges 属性（地址翻译）别名节点和 根节点 4、设备和驱动的匹配方式5、imx415 sensor为实例 本专题的学习：CSDN21天学习挑战赛
1、Linux设备树和Pinctrl
一、Linux设备树 1.1 Linux设备树概述 1、设备树是什么
2、引入设备树的作用
3、什么样的硬件可以用设备树来描述
4、原始硬件信息（没采用设备树的时候）
设备树我把把它理解为对硬件的描述 简化了代码块量 采用了设备树之后，许多硬件的细节可以直接通过它传递给Linux， 而不再需要在内核中进行大量的冗余编码,它通过bootloader将硬件资源传给内核， 使得内核和硬件资源描述相对独立 CPU的数量和类别 内存基地址和大小 总线和桥 外设连接 中断控制器和中断使用情况 GPIO控制器和GPIO使用情况 Clock控制器和Clock使用情况 补充： 设备树对于可热插拔的热备不进行具体描述，它只描述用于控制该热插拔设备的控制器 注：
官网对设备树的描述：
https://www.kernel.org/doc/Documentation/devicetree/usage-model.txt
1.2 设备树 设备树的主要优势：
对于同一SOC的不同主板，只需更换设备树文件.dtb或者.dtbo文件即可实现不同主板的无差异支持，而无需更换内核文件，实现了内核和不同板级硬件数据的拆分。
设备树：
DTC （device tree compiler） DTS/DTSI （device tree source） DTB	（device tree blob） 三者的关系：
dts和dtsi源文件会经过dtc编译器编译成dtb二进制文件，dtb文件最后会被放到系统中被内核解析
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/262f48872817418df233f854acdffd12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed387d6865fa7b594de5124f849196a5/" rel="bookmark">
			【ACWing 算法基础】KMP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 模板 // s[]是长文本，p[]是模式串，n是s的长度，m是p的长度 // 求模式串的Next数组： for (int i = 2, j = 0; i &lt;= m; i ++ ) { while (j &amp;&amp; p[i] != p[j + 1]) j = ne[j]; if (p[i] == p[j + 1]) j ++ ; ne[i] = j; } // 匹配 for (int i = 1, j = 0; i &lt;= n; i ++ ) { while (j &amp;&amp; s[i] != p[j + 1]) j = ne[j]; if (s[i] == p[j + 1]) j ++ ; if (j == m) { j = ne[j]; // 匹配成功后的逻辑 } } 二.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed387d6865fa7b594de5124f849196a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55667e9425d0a50c677338a73806e0b2/" rel="bookmark">
			GEE开发之MODIS_NDVI年均值数据分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GEE开发之MODIS_NDVI年均值数据分析 前言：前面几篇博客主要介绍了NDVI的日均值和月均值的数据分析，这次主要介绍年均值的数据分析。 代码如下（以鹿邑县为例）：
var geometry = ee.FeatureCollection('users/www1573979951/luyixian'); // 选择数据集并进行波段比例换算 var collection = ee.ImageCollection("MODIS/006/MOD13Q1").filterDate('2000-01-01', '2020-12-31').select("NDVI"); //换算单位 var multiply = function(image){ var img = image.multiply(0.0001); return img.set(image.toDictionary(image.propertyNames())); }; collection = collection.map(multiply); //进行年平均值的计算 var years = ee.List.sequence(2000, 2020); var collectYear = ee.ImageCollection(years .map(function(y) { var start = ee.Date.fromYMD(y, 1, 1); var end = start.advance(12, 'month'); return collection.filterDate(start, end).reduce(ee.Reducer.mean()).float().set('system:time_start',y).set('year',y); })); print(collectYear); //年均值的时间序列展示 var Yearly_chart = ui.Chart.image.series({ imageCollection: collectYear.select('NDVI_mean'), region: geometry, reducer: ee.Reducer.mean(), scale: 500, xProperty: 'year', }).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55667e9425d0a50c677338a73806e0b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f5f78dcf212f40f43e36ddcedefb6c5/" rel="bookmark">
			前端常用的CSS工具库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、 animista，在线查看自己需要的动画效果，比较常用，直接复制代码即可。 官网： Animista - CSS Animations on Demand
2、Animate.css是一个现成的跨浏览器动画工具库，可用于您的 Web 项目。非常适合强调、主页、滑块和注意力引导提示。 官网： Animate.css | A cross-browser library of CSS animations.
使用方法：初识Animate.css_前端 萌新的博客-CSDN博客_animate.css 教程
3、cssbuttongenerator 前端微网站交互按钮在线设计，直接复制代码即可。 官网：CSS Button Generator | create CSS buttons without code
4、 零代码工具箱，集合了在线css阴影效果，毛玻璃效果，按钮设计，文字排版等系列工具。 官网：零代码-前端工具箱
5、边框阴影生成器，不同颜色样式都可以在线编辑，直接复制代码即可。 官网：Neumorphism/Soft UI CSS shadow generator
6、花式边界半径，多样化圆角随便拿捏，这个工具可以在线编辑通过拖拽的方式生成需要的 border-radius，赋予更加个性化的圆角效果。直接复制代码即可。 官网：https://9elements.github.io/fancy-border-radius/
7、平滑阴影，可以在线编辑生成多个分层阴影，提供非常酷的效果，也可以自定义颜色，直接复制代码即可。 官网：Smooth Shadow
8、CSS Gradient 是一个在线编辑css渐变色背景，直接复制代码即可。 官网：CSS Gradient — Generator, Maker, and Background
9、css 网格生成器，在线编辑 Grid布局，可以设置行和列的数字还有单位，生成一个 CSS Grid 网格布局，在方框中拖动来创建 div 放置在网格内，可直接复制代码。 官网：CSS Grid Generator
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f5f78dcf212f40f43e36ddcedefb6c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37a86090dda83b357bd73c1a92cb0191/" rel="bookmark">
			.Net framework3.5无法安装问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		.Net framework3.5无法安装问题 离线安装Net framework解决方案一、下载一个Net framework安装包二、使用步骤1.使用管理员模式打开cmd进入C目录下的window文件夹 离线安装Net framework解决方案 原本的问题时要安装一个插件，但是一直报 0x80070422 这个问题，我就去搜索发现原因是：windows Update没有开启
没办法自动下载.Net framework3.5，，但是这些都不是你要了解的，你只要知道怎么解决就可以了
一、下载一个Net framework安装包 可以取windows 官网下载一个版本的镜像进行安装，也可以去单独找到 microsoft-windows-netfx3-ondemand-package31bf3856ad364e35amd64~~.cab 这个包下载下来。
支持windows版本号【21H2，2004，20h2】混装，百度网盘的安装包，链接: https://pan.baidu.com/s/1YyL_bHiLTl6_8PDCqB2FAA 提取码：hdgy
下载完成之后解压选择
直接放到C:\Windows文件夹里
二、使用步骤 1.使用管理员模式打开cmd进入C目录下的window文件夹 粘贴复制回车
dism /online /Enable-Feature /FeatureName:NetFx3 /Source:"%windir%" /LimitAccess 等待出现
这里就说明安装成功了。解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2170d3b893d92674a93ea7e037dd4ad5/" rel="bookmark">
			Java面向对象之子类方法重写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		重写的总结 需要有继承关系，子类重写父类方法名必须相同，方法体可以不同参数列表必须相同静态方法是类的方法，非静态是对象的方法，只有非静态方法才能被重写修饰符：范围可以扩大不能缩小 Public&gt;Protected&gt;Default&gt;private抛出的异常：范围。可以被缩小，但不能扩大：ClassNotFoundException --&gt;Exception(大) 为什么需要重写 父类的功能，子类不一定需要，或者不一定满足Alt+Insert:快速呼出override A类：
package demo06; public class A extends B{ public static void test(){ System.out.println("A=&gt;test()"); } //override:重写 //重写的方法只能是public @Override//注解：有功能的注释 public void Test() { super.Test(); } } B类：
package demo06; public class B { public static void test(){ System.out.println("B=&gt;test"); } public void Test(){ System.out.println("B=&gt;Test()"); } } 主函数：
package demo06; public class Application { public static void main(String[] args) { //静态方法是类的方法 //b调用了B类的方法，因为b是用b类定义的 //方法的调用只和左边，定义的数据类型有关 A a = new A(); a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2170d3b893d92674a93ea7e037dd4ad5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebbbe12cca4dc5162a383a4cc191fc8c/" rel="bookmark">
			【QT】自定义工程封装成DLL并如何调用（带ui界面的）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、动态库的封装 1、首先新建一个Library工程 2、修改类型为共享库，自定义项目名称以及项目路径 3、选择编译器 4、选择动态库所需要的模块 5、自定义类名，点击下一步 6、点击下一步 7、项目总览 8、此时的文件中还没有ui文件，因为要封装带界面的动态库，需要右键点击工程-&gt;add new 9、在新弹出的窗口中选择Qt -&gt; Qt设计师界面类 10、选择Widget界面模板 11、将其命名为与当前工程相同的名字，以覆盖之前不带ui界面的文件 12、点击完成 13、之后会弹出如下两个窗口，分别点击 OK 和 Yes to All 14、此时可以看到该工程文件下面多出了 .ui文件 15、点击 .pro 文件，删除重复的内容 16、如果文件报红，说明缺少一些模块（缺少了widgets模块） 17、添加如下，错误可消失 18、不过此时的工程还不能直接打包成动态库，因为旧的文件被覆盖掉了，新的文件无法打包成动态库，因此需要对新的文件进行修改 I、此时新的DynamicLib.h文件内容如下：
II、需要将其修改为下面的内容：
需要添加头文件#include "dynamiclib_global.h" 以及 在类名前添加 DYNAMICLIBSHARED_EXPORT 语句。
III、DYNAMICLIBSHARED_EXPORT 语句可以在头文件 dynamiclib_global.h中直接复制过来，就是下方代码中，红色框圈出来的部分：
19、在这个界面上添加一个按钮，并给这个按钮添加对应的槽函数 20、编写槽函数内容 21、然后点击构建、运行，生成动态库文件 22、生成的库文件在它自己的Debug文件夹下 23、还需要用到一个文件就是它自己的头文件，dynamiclib_global.h也一定要带上 此时，动态库封装就已经算完成了，需要用到的文件也就是上面标记出来的四个。
二、动态库的调用：在另一个新的工程中使用这个动态库 1、创建一个新的带界面的工程 2、项目总览 3、之后在工程LibTest项目目录下添加两个新的文件夹 include 和 lib 将DynamicLib.h和dynamiclib_global.h文件放到include文件夹中将DynamicLib.lib放到lib文件夹中 4、然后在LibTest.pro文件中添加如下语句，引入动态库 INCLUDEPATH += $$PWD/include LIBS += -L$$PWD/lib -lDynamicLib 其中指出了动态库需要的头文件路径，动态库的所在路径，以及动态库名字。$$PWD表示工程目录，-l后面表示库文件的名字，不包含后缀.lib。
然后在使用动态库的文件中添加需要使用的头文件，进行使用。
5、然后开始编辑mainwindow.ui 添加一个StackedWidget组件，第一页上面放一个按钮，点击这个按钮，跳转到第二页，第二页放置封装的动态库界面。
6、先给pushButton添加槽函数 7、然后在MainWindow中添加一个DynamicLib对象以及引入动态库的头文件 8、在构造函数中添加如下代码 9、这时会遇到一个问题：就是程序异常结束没法运行成功 10、这是因为还有一个文件没有用上，那就是dll文件，还需要将DynamicLib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebbbe12cca4dc5162a383a4cc191fc8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3ca34d806fa373324bbaebb6511b397/" rel="bookmark">
			dataX数据同步报错：TIMESTAMP 类型转换错误，[DataX传输脏数据超过用户预期。。。一种解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		发生场景：dataX远程调用接口，将数据抽取到Oracle，抽取的数据有时间类型字段，允许为空。则可能会出现如图片中的错误。
原因分析：dataX远程调用接口时，获取时间类型的字段，默认格式为字符串，向目标表新增时，空字符串转化为时间类型格式报错。
解决思路：在dataX脚本读取reader中判断时间类型的字符串为空时，赋一时间戳类型的时间默认值，这个默认值应该是容易与数据真实时间值区分的时间。在写入writer中postSql中处理，将所赋值的字段重置为空。
说明：只是在此种抽取方式中碰到这问题，其他场景还未操作过。
一下为dataX参照脚本JSON
说明：dataX调用远程接口读取数据，源数据中time1不为空，time2，time3可为空。故在reader中判断如果时间为空， 则赋值一个默认时间戳（946659661000为2000-01-01 01:01:01），目标表中有一字段标注数据来源， 在postSql中进行更新处理。 { "job": { "setting": { "speed": { "channel": 3, "byte": 1048576 }, "errorLimit": { "record": 0, "percentage": 0.02 } }, "content": [ { "reader": { "name": "httpreader", "parameter": { "host": "IP地址", "port": "端口号", "path": "请求url", "param": [ { "name": "增量参数字段", "value": "参数值" } ], "column": [ "col1", "col2", "time1", { "value": "{time2== '' ? 946659661000 : time2}", "type": "number" }, { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3ca34d806fa373324bbaebb6511b397/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6029af5a0d194a11489e46025f0f7559/" rel="bookmark">
			输出等腰三角形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		8,2 本人又来打卡了！
今日题目：
今天我们只做第三个有难度的等腰三角形，其他两个忽略，可以当做作业做。
看到三角形，我们应都能想到for语句，那么我就恭喜你，你完成了第一步思想。
可怎样打出来呢？△形状有个特点：可以平均分为两半，没错，这考查对几何的认知。
现在，我们可以确定的是：要用多个for循环。那么现在估计可以写成这样了吧：
//此处省略c++main int n; cin&gt;&gt;n; for (int i = 1; i &lt;= n; i++) { for () for () } 可是里面些什么呢？
额，在此就不卖关子了：
for (int i = 1; i &lt;= n; i++) { for (int j=1;j&lt;=n-i+1;j++) cout &lt;&lt; " "; for (int k=1;k&lt;=2*i-1;k++) cout &lt;&lt; "#" ; cout &lt;&lt; endl; } 好的，套上基本c++main：
/********************************************************************* 程序名: 等腰三角 日期: 2022-08-02 14:15 *********************************************************************/ #include &lt;iostream&gt; using namespace std; int main(){ int n; cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6029af5a0d194a11489e46025f0f7559/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc488fd96d6c64aac88f92d7ca28fd0e/" rel="bookmark">
			vs2013配置qt5.7.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装Qt Visual Studio Tools 打开vs3013，如下图所示
点击工具菜单，打开联机和更新对话框，如下图所示
左边选择联机，右上角搜索qt，如下图所示
点击安装即可。由于本人已经安装好了，所以会是一个勾勾。
二、安装qt4.7.0 注意：
这里安装的是qt-opensource-windows-x86-msvc2013_64-5.7.0.exe程序，而不是别的不带msvc2013的exe程序。
参考如下文章
qt下载新手推荐
下载完qt-opensource-windows-x86-msvc2013_64-5.7.0.exe后双击运行，一直next就能完成安装。
三、安装qt-vs-addin-1.2.5.exe **注意：**这里安装的是1.2.5版本，不同的版本支持的VS版本也不一样，所以这里推荐1.2.5版的qt-vs-addin。
下载qt-vs-addin-1.2.5.exe后直接点击运行，一直next就可以了。
当然也可以改变安装路径。
四、配置qt4.7.0 打开VS2013，当安装了Qt Visual Studio Tools工具后，在打开的vs2013中会出现Qt菜单，如下图所示。
点击Qt菜单，在下拉列表中选择Qt Options(.pro)，弹出如Qt Options对话框，如下图所示
添加mscv213_64所在的文件路径即可。
五、测试是否配置成功。 打开vs2013，新建项目，在弹出的项目对话框中，在左边选择Qt project，在中间选择Qt Application，，项目名称命名为helloqt右下角单击确定。界面如下图所示
然后弹出如下界面
继续点击下一步，下一班，点击完成即可。
最后运行程序，弹出如下界面，即可说明配置成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa6b688af0cd35c5c7f04f5d321c2a0e/" rel="bookmark">
			Tableau的安装笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		咱们直入主题。
首先官方下载地址：https://www.tableau.com/zh-cn/support/releases
进入页面后选择最新的版本，如下图：
此处我选择的是2022这版
点击下拉按钮，选择好版本后点进去。
点击红框处
选择适合你电脑系统的版本，点击下载（使用迅雷，速度更快）。
这是我下好的安装包，打开所在位置，双击进行安装。
勾选这两个地方，建议选择默认安装。等个几分钟就装好了。安装完毕可能会提醒你重启，并弹出以下弹窗，选择试用或者直接激活，根据自己情况操作即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/085b3fd802cb04e79b2d4955456b0594/" rel="bookmark">
			字符串常量池问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 字符串常量池问题String基本特性字符串地址问题String对象创建问题new String("hello") 会创建几个对象？new String("abc") + new String("ABC")会创建几个对象 intern()的使用情况1情况2情况3 间接证明字符串常量池的位置 字符串常量池问题 String基本特性 String声明为final，表示不能被继承。String实现了serializable接口，表示支持序列化；实现了Comparable接口，表示可以做比较。在JDK8及以前String内部定义了final char[] value用于存储数据，在JDK9改为byte[]，节约了空间。在JDK8中，字符串常量池属于方法区但存放在堆区，字符串常量池是不会存储相同内容的字符串的。 String不可变的优点：
String类型使用最多，参数传递时更加安全。在多线程下绝对安全。字符串在常量池中共享，节约内存，提高效率。 String类中的substring/replace/toLowerCase等方法都是在内部再创建一个新的String类对象。
字符串地址问题 String s1 = "a"; //串池 String s2 = "b"; //串池 String s3 = "ab"; //串池 String s4 = s1 + s2; //堆区，new StringBuilder().append("a").append("b").toString() -&gt; new String("ab") String s5 = "a" + "b"; //编译期优化，直接转为“ab” System.out.println(s3 == s4); //false System.out.println(s3 == s5); //true final String s1 = "a"; //串池 final String s2 = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/085b3fd802cb04e79b2d4955456b0594/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cafcc8a5d073bc54f9133a8ea71b994/" rel="bookmark">
			Mac M1 nvm install失败问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		M1执行nvm install安装node报错404 ➜ sales_app git:(carDetail) nvm install 12.22.12 Downloading and installing node v12.22.12... Downloading https://nodejs.org/dist/v12.22.12/node-v12.22.12-darwin-arm64.tar.xz... -#O=-# # # curl: (22) The requested URL returned error: 404 Binary download from https://nodejs.org/dist/v12.22.12/node-v12.22.12-darwin-arm64.tar.xz failed, trying source. grep: /Users/gch/.nvm/.cache/bin/node-v12.22.12-darwin-arm64/node-v12.22.12-darwin-arm64.tar.xz: No such file or directory Provided file to checksum does not exist. Binary download failed, trying source. Clang v3.5+ detected! CC or CXX not specified, will use Clang as C/C++ compiler! Local cache found: $NVM_DIR/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cafcc8a5d073bc54f9133a8ea71b994/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f6083ff1076c7805d45fc3b7421eb08/" rel="bookmark">
			迅为IMX8M开发板Ubuntu20文件系统-base设置软件源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu 安装软件是通过名 apt-get 从网上下载安装的。 我们需要指定软件源。为了制作成功的根文
件系统能够联网， 可以直接拷贝本机的 dns 配置文件到根文件系统的相应位置，使用命令“cp
/etc/resolv.conf ./etc/resolv.conf” ，如下图所示：
然后修改根文件系统软件源， 使用命令,如下图所示：
sed -i 's/ports\.ubuntu\.com/mirrors\.tuna\.tsinghua\.edu\.cn/g' ./etc/apt/sources.list
echo "nameserver 114.114.114.114" &gt; ./etc/resolv.conf
更多内容可以了解迅为IMX8M开发板
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1892ba871c54d277d594dc1970a5ec16/" rel="bookmark">
			vue2.0 vue-i18n报错问题处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、首先升级vue-i18n的版本为^8.26.7
"vue-i18n": "^8.26.7", 2、main.js文件进行更换：
// 自动设置语言 const navLang = navigator.language; const localLang = (navLang === 'zh-CN' || navLang === 'en-US') ? navLang : false; const lang = window.localStorage.getItem('language') || localLang || 'zh-CN'; Vue.config.lang = lang; Vue.config.productionTip = false; // 多语言配置 const locales = Locales; const mergeZH = Object.assign(zhLocale, locales['zh-CN']); const mergeEN = Object.assign(enLocale, locales['en-US']); Vue.locale = () =&gt; {}; const i18n = new VueI18n({ locale: 'zh-CN', // 语言标识 messages: { 'zh-CN': mergeZH, // 中文语言包 'en-US': mergeEN // 英文语言包 }, }) /* eslint-disable no-new */ new Vue({ el: '#app', router, store, i18n, template: '&lt;App/&gt;', components: {App} }); 注意点：首先要将国际化语言配置更换，其次要在vue中添加你的引用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a631e9e70e827c613edb68b72ffc68bc/" rel="bookmark">
			SpringBoot启动项目报错 Consider defining a bean of type ‘xxx‘ in your configuration
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天遇到一个问题很奇怪，SpringBoot项目启动报错提示：
Description: Field userDAO in com.cml.service.impl.UserServiceImpl required a bean of type 'com.cml.dao.UserDAO' that could not be found. Action: Consider defining a bean of type 'com.cml.dao.UserDAO' in your configuration. 我开始以为我是接口上面没有加@Mapper注解的原因
但是我看了一下却不是，而且idea提示我可以找到
左边那个绿色小图标点击一下也能进入UserDAO
后来我看了一下日志发现里面有一行警告被我给忽略了
2021-12-26 19:51:52.415 WARN 15212 — [ restartedMain] o.m.s.mapper.ClassPathMapperScanner : No MyBatis mapper was found in ‘[com.cml.app]’ package. Please check your configuration.
mybatis默认扫描的是启动类下的包，而我的启动类和DAO接口不在同一个包下
所以启动类加上@MapperScan注解改一下扫描位置就好了
@SpringBootApplication( scanBasePackages = "com.cml" ) @MapperScan( basePackages = "com.cml.dao" ) public class App { public static void main(String[] args) { SpringApplication.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a631e9e70e827c613edb68b72ffc68bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7f96af82cd2176cb0239be2f4396f86/" rel="bookmark">
			RabbitMQ如何保证消息消费的顺序性？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RabbitMQ的queue本身就是队列，是可以保证消息的顺序投递的。
但是消息的顺序消费则是另一回事了，所谓的“顺序消费”意味着是否顺序达到目的地，比如：数据库。
看看如下场景：
一个 queue，多个 consumer。比如，生产者向 RabbitMQ 里发送了三条数据，顺序依次是 data1/data2/data3，压入的是 RabbitMQ 的一个内存队列。有三个消费者分别从 MQ 中消费这三条数据中的一条，结果消费者2先执行完操作，把 data2 存入数据库，然后是 data1/data3。这不明显乱了。
产生多个consumer去消费一个queue，极有可能是因为：消息消费太慢，所以盲目让多个consumer同时来消费，而忽略了消息消费顺序性。
在某些情况下，消息是需要保证顺序性的，如果上图中的data1, data2, data3 分别意味着对某条数据的增改删，但是如果乱序以后就变成了：删改增。
解决方案：
1、拆分多个 queue，每个 queue 一个 consumer。
2、一个 queue，但是对应一个 consumer，然后这个 consumer 内部用内存队列（其实就是List而已）做排队，然后分发给底层不同的thread来处理（此方案可以支持高并发）。
实际consumer的数量是受限的，不会仅仅因为消息消费太慢而去增加consumer实例的数量，所以通过方案2的方式，可以在不增加consumer实例数量的前提下，加快消息消费的速度。
先自我介绍一下，小编13年上师交大毕业，曾经在小公司待过，去过华为OPPO等大厂，18年进入阿里，直到现在。深知大多数初中级java工程师，想要升技能，往往是需要自己摸索成长或是报班学习，但对于培训机构动则近万元的学费，着实压力不小。自己不成体系的自学效率很低又漫长，而且容易碰到天花板技术停止不前。因此我收集了一份《java开发全套学习资料》送给大家，初衷也很简单，就是希望帮助到想自学又不知道该从何学起的朋友，同时减轻大家的负担。添加下方名片，即可获取全套学习资料哦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/887fa5e5df00e66b2adcca9c74bb6730/" rel="bookmark">
			【转载】kill掉垃圾进程（在资源管理器占用的情况下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows删除dll文件时提示“操作无法完成，因为文件已在Windows 资源管理器中打开”。
但是在资源管理器里面找不到这个进程，此时可以使用CMD的tasklist和taskkill命令来终止这个进程并对dll文件进行删除。
解决方法
管理员身份运行CMD，使用tasklist命令查询占用dll文件的进程PID，再使用taskkill命令结束掉进程，然后就能删除掉对应的dll文件。
1、以管理员身份打开Windows的CMD窗口，使用 tasklist /m 文件名查询占用文件的进程PID。
比如查询占用yunshellextv164.dll文件的进程，占用yunshellextv164.dll的进程PID分别为7224和12524。
C:\Windows\system32&gt;tasklist /m yunshellextv164.dll 映像名称 PID 模块 ========================= ======== ============================================ explorer.exe 7224 YunShellExtV164.dll Everything.exe 12524 YunShellExtV164.dll C:\Windows\system32&gt; 2、使用 taskkill /F /PID PID强制结束进程。
比如强制结束占用yunshellextv164.dll文件的进程PID7224和12524。
C:\Windows\system32&gt;taskkill /F /PID 7224 成功: 已终止 PID 为 7224 的进程。 C:\Windows\system32&gt;taskkill /F /PID 12524 成功: 已终止 PID 为 12524 的进程。 C:\Windows\system32&gt; 3、删除dll文件
4、注意事项
如果在第二部kill掉了explorer.exe（资源管理器） 进程，需要在CMD下使用start重启，不然系统的很多功能都没法使用！
C:\Windows\system32&gt;start explorer.exe kill进程explorer.exe并自动重启的命令参考：
C:\Windows\system32&gt;taskkill /f /im explorer.exe &amp; start explorer.exe 成功: 已终止进程 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/887fa5e5df00e66b2adcca9c74bb6730/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff816db6cca74d77315be39b14cb8788/" rel="bookmark">
			LAB 信号量实现细节
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		信号量的实现与应用 实验内容实验过程 实验结果实验分析 从生产者-消费者问题看进程同步 信号量实现进程同步靠临界区保护信号量 竞争条件(Race Condition)通过锁机制实现临界区的原子性访问 用信号量解决生产者-消费者问题 用文件作为一个共享缓冲区多个消费者进程读数的文件偏移量同步及读取结束判断 信号量的实现 信号量的组成等待队列的构造 实验内容 在Ubuntu下编写程序，用信号量解决生产者-消费者问题
在Ubuntu下编写应用程序pc.c，解决经典的生产者-消费者问题，完成下面的功能：
建立一个生产者进程，N个消费者进程(N &gt; 1)用文件建立一个共享缓冲区生产者进程依次向缓冲区写入整数0,1,2,…,M, M &gt;= 500消费者进程从缓冲区读数，每次读一个，并将读出的数字从缓冲区删除，然后将本进程ID+数字输出到标准输出缓冲区同时最多只能保存10个数
pc.c中将会用到sem_open(),sem_unlink(),sem_wait(),sem_post()等信号量相关的系统调用，请查阅相关文档。 在0.11中实现信号量，用生产者-消费者程序检验之
Linux在0.11版还没有实现信号量，Linus把这件富有挑战的工作留给了你。如果能够实现一套山寨版的完全符合POSIX规范的信号量，无疑是很有成就感的。但时间暂时不允许我们这么做，所以先弄一套缩水版的类POSIX信号量，它的原型和标准并不完全相同，而且只包含如下系统调用：
sem_t *sem_open(const char *name, unsigned int value); int sem_wait(sem_t *sem); int sem_post(sem_t *sem); int sem_unlink(const char *name); sem_t是信号量类型，根据实现的需要自定义sem_open
功能是创建一个信号量，或打开一个已经存在的信号量。
name是信号量的名字。不同的进程可以通过提供同样的name而共享同一个信号量。如果该信号量不存在，就创建新的名为name的信号量；如果存在，就打开已经存在的名为name的信号量。
value是信号量的初值，仅当新建信号量时，此参数才有效，其余情况下它被忽略。
当成功时，返回值是该信号量的唯一标识(比如，在内核的地址，ID等)，由另外两个系统调用使用。如失败，返回值是NULL。sem_wait
信号量的P原子操作。如果继续运行的条件不满足，则令调用进程等待在信号量sem上。
返回0表示成功，返回-1表示失败。sem_post
信号量的V原子操作。如果有等待sem的进程，它会唤醒其中的一个。返回0表示成功，返回-1表示失败。sem_unlink
功能是删除名为name的信号量。返回0表示成功，返回-1表示失败。
在kernel目录下新建sem.c文件实现如下功能。然后将pc.c从Ubuntu移植到0.11下，测试自己实现的信号量。 实验报告
在pc.c中去掉所有与信号量有关的代码，再运行程序，执行效果有变化吗？为什么会这样？实验的设计者在第一次编写生产者-消费者程序的时候，是这么做的：Producer() { P(Mutex); //互斥信号量 生产一个产品item; P(Empty); //空闲缓存资源 将item放到空闲缓存中; V(Full); //产品资源 V(Mutex); } Consumer() { P(Mutex); P(Full); 从缓存区取出一个赋值给item; V(Empty); 消费产品item; V(Mutex); } 这样可行吗？如果可行，那么它和标准解法在执行效果上会有什么不同？如果不可行，那么它有什么问题使它不可行？ 实验过程 实验分析 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff816db6cca74d77315be39b14cb8788/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f2c425f6cade8901e85132bd81eb3b4/" rel="bookmark">
			docker命令整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		三个基本概念 镜像Image容器Container仓库Repository
即Docker的生命周期 镜像 操作系统分为内核和用户空间。对于Linux而言，内核启动后会挂载root文件系统为其提供用户空间支持。
Docker镜像相当于是一个root文件系统。
分层存储 镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完便不会再发生变化，后一层的人和改变只会发生在自己这一层。
eg：删除前一层文件的操作，仅仅是在当前层标记该文件已删除。在最终容器运行时，虽然不会看到这个文件，但实际上该文件会一直跟随镜像。
容器 镜像（Image）与容器（Container）的关系，等同于类与实例的关系，镜像是静态的定义，容器是镜像运行时的实体。
容器可以被创建、启动、停止、删除、暂停等。
容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。
仓库 一个Docker Registry中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。
通过&lt;仓库名&gt;:&lt;标签&gt;的格式来指定具体是这个软件哪个版本的镜像。
使用镜像 从仓库获取镜像管理本地主机上的镜像镜像实现的基本原理 获取镜像 从 Docker 镜像仓库获取镜像的命令是 docker pull。其命令格式为：
docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签] 运行 有镜像后，我们能够以镜像为基础启动并运行一个容器
docker run [OPTIONS] IMAGE [COMMAND] [ARG...] 就是运行容器的命令
OPTIONS说明：
-d： 后台运行容器并返回容器ID-i： 以交互模式运行容器，通常与-t同时使用-t： 为容器重新分配一个伪终端–name：”XXX”： 为容器指定一个名称 通过exit退出容器
列出镜像 使用docker image ls 命令
使用docker system df 命令来查看镜像、容器、数据卷所占用的空间
$ docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE redis latest 5f515359c7f8 5 days ago 183 MB nginx latest 05a60462f8ba 5 days ago 181 MB mongo 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f2c425f6cade8901e85132bd81eb3b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b9ab0191dd4a3215d5ca29c3fe11972/" rel="bookmark">
			【算法】双轴快排
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		双轴快排 双轴快排是单轴快排的改进，初次学习双轴快排需要仔细深入地理解各处细节，因此本小节将详细介绍其实现细节，展示确定双轴位置既区间划分的过程。
前述快排每次递归确定当前区间的主轴，并利用该主轴将当前区间划分为左右两个部分。双轴快排则以 两个轴 (pivot1, pivot2)将当前区间划分为 三个子区间，双轴三区间的划分结果要满足如下。为方便叙述，将[left, pivot1)称作区间1，(pivot1, pivot2)称作区间2，(pivot2, right]称作区间3，其中pivot1，pivot2指的是最终位置，区间1，区间2，区间3均指划分后的最终区间。
arr[i] &lt; arr[pivot1], i ∈ [left, pivot1) 区间1
arr[pivot1] ≤ arr[i] ≤ arr[pivot2], i ∈ (pivot1, pivot2) 区间2
arr[i] &gt; arr[pivot2], i ∈ (pivot2, right] 区间3
对三个子区间执行同样的过程，直到无法划分时排序完成。算法主要过程和说明如下，结合后续代码实现的注释可准确把握各处细节。
dualPivotQuickSort执行开始，首先以if(left &lt; right)为条件，只对大小大于等于2的区间执行双轴快排。
以如下语句令左右两端元素中较小者居左，后续以left为初始pivot1(下标)，right为初始pivot2(下标)，保证pivot1为左右两端元素中的较小者。
在程序后续内容中，arr[left]为pivot1的值(左轴值)，arr[right]为pivot2的值(右轴值)。
if(arr[left] &gt; arr[right]) {
swap(arr, left, right);
}
设置index = left + 1，lower = left + 1，upper = right - 1。
index表示当前考察的元素下标。
lower是用于推进到pivot1最终位置的动态向右扩展的下标（扩展区间1），在程序的任意时刻总有[left, lower)的元素确定在区间1中。
upper是用于推进到pivot2最终位置的动态向左扩展的下标（扩展区间3），在程序的任意时刻总有(upper, right]的元素确定在区间3中。
当循环结束时lower–和upper++为最终的pivot1和pivot2的位置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b9ab0191dd4a3215d5ca29c3fe11972/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d0a1d11eb615e33e55f16b6bf5782ed/" rel="bookmark">
			java若依框架开发api接口（添加新模块）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在java的spingboot框架中比较好的开源后台那必须是若依了！为了方便管理自己开发的api接口，添加自己的模块，将api接口统一管理在该模块中！ 记得三连哦~
1、下载若依admin，链接：RuoYi 若依官方网站 |后台管理系统|权限管理系统|快速开发框架|企业管理系统|开源框架|微服务框架|前后端分离框架|开源后台系统|RuoYi|RuoYi-Vue|RuoYi-Cloud|RuoYi框架|RuoYi开源|RuoYi视频|若依视频|RuoYi开发文档|若依开发文档|Java开源框架|Java|SpringBoot|SrpingBoot2.0|SrpingCloud|Alibaba|MyBatis|Shiro|OAuth2.0|Thymeleaf|BootStrap|Vue|Element-UI||www.ruoyi.vip
2、添加模块
3、配置模块
&lt;!-- 前端接口 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.ruoyi&lt;/groupId&gt; &lt;artifactId&gt;v2&lt;/artifactId&gt; &lt;version&gt;${ruoyi.version}&lt;/version&gt; &lt;/dependency&gt; &lt;module&gt;v2&lt;/module&gt; &lt;!-- 前端接口--&gt; &lt;dependency&gt; &lt;groupId&gt;com.ruoyi&lt;/groupId&gt; &lt;artifactId&gt;v2&lt;/artifactId&gt; &lt;/dependency&gt; #前端接口 com.v2: debug # 搜索指定包别名 typeAliasesPackage: com.ruoyi.**.domain,com.v2.domain # 配置mapper的扫描，找到所有的mapper.xml映射文件 mapperLocations: classpath*:mapper/**/*Mapper.xml,classpath*:mapper/*Mapper.xml &lt;dependencies&gt; &lt;!-- 通用工具--&gt; &lt;dependency&gt; &lt;groupId&gt;com.ruoyi&lt;/groupId&gt; &lt;artifactId&gt;ruoyi-common&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; package com.ruoyi.framework.config; import org.mybatis.spring.annotation.MapperScan; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.EnableAspectJAutoProxy; /** * 程序注解配置 * * @author ruoyi */ @Configuration // 表示通过aop框架暴露该代理对象,AopContext能够访问 @EnableAspectJAutoProxy(exposeProxy = true) // 指定要扫描的Mapper类的包的路径 @MapperScan({"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d0a1d11eb615e33e55f16b6bf5782ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb51d243e3369f646468c809a61725a9/" rel="bookmark">
			微信小程序开发——上传图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		功能描述 1.拍摄或从手机相册中选择图片上传。
2.chooseImage(e) 中的index用于判断是新增图片还是替换图片。
3.delImage(e) 删除当前index索引下的数据。
wx.chooseMedia(Object object) 属性类型默认值必填说明countnumber9否最多可以选择的文件个数mediaTypeArray.&lt;string&gt;['image', 'video']否文件类型sourceTypeArray.&lt;string&gt;['album', 'camera']否图片和视频选择的来源maxDurationnumber10否拍摄视频最长拍摄时间，单位秒。时间范围为 3s 至 60s 之间。不限制相册。sizeTypeArray.&lt;string&gt;['original', 'compressed']否仅对 mediaType 为 image 时有效，是否压缩所选文件camerastring'back'否仅在 sourceType 为 camera 时生效，使用前置或后置摄像头successfunction否接口调用成功的回调函数failfunction否接口调用失败的回调函数completefunction否接口调用结束的回调函数（调用成功、失败都会执行 object.success 回调函数 属性类型说明tempFilesArray.&lt;Object&gt;本地临时文件列表 结构属性类型说明tempFilePathstring本地临时文件路径 (本地路径)sizenumber本地临时文件大小，单位 Bdurationnumber视频的时间长度heightnumber视频的高度widthnumber视频的宽度thumbTempFilePathstring视频缩略图临时文件路径fileTypestring文件类型 合法值说明image图片video视频typestring文件类型，有效值有 image 、video、mix wxml部分
&lt;view class="imageList"&gt; &lt;view class="imageItem" wx:for="{{imageList}}" wx:key="index"&gt; &lt;image class="image" mode="aspectFill" bindtap="chooseImage" data-type="pictures" data-index="{{index}}" src="{{item.url}}" alt="" /&gt; &lt;view class="delImage" catchtap="delImage" data-idnex="{{index}}"&gt;-&lt;/view&gt; &lt;/view&gt; &lt;view class="imageItem addImage" bindtap="chooseImage" data-type="pictures"&gt;&lt;/view&gt; &lt;/view&gt; wxss部分
.imageList { padding: 32rpx; width: 100vw; box-sizing: border-box; /* 弹性布局 */ display: flex; flex-direction: row; justify-content: flex-start; /* 换行 */ flex-wrap: wrap; /* 内容区的实际宽度为 width: calc(100vw - 64rpx); width: 686rpx; */ } /* 照片容器的样式 */ .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb51d243e3369f646468c809a61725a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40be4c550b7b8a8f26c741223cde90f3/" rel="bookmark">
			MyBatis Plus处理Mysql JSON Data Type类型字段
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL 自5.7.8版本开始，支持了JSON格式数据的存储和查询，在此版本前，只能通过字符类型（CHAR，VARCHAR 或 TEXT ）来保存 JSON 数据。相对字符类型，原生的 JSON 类型具有以下优势：
在插入时能自动校验是否满足 JSON 格式的要求。 优化了存储格式，无需读取整个字段就能快速访问某个元素的值。 本文记录与MyBatis Plus结合使用的过程。
实体类 使用TypeHandler (字段类型处理器)通过@TableField注解快速注入到 MyBatis 容器中
@Data @Accessors(chain = true) @TableName(autoResultMap = true) public class User { private Long id; ... /** * 注意！！ 必须开启映射注解 * * @TableName(autoResultMap = true) * * 以下两种类型处理器，二选一 也可以同时存在 * * 注意！！选择对应的 JSON 处理器也必须存在对应 JSON 解析依赖包 */ @TableField(typeHandler = JacksonTypeHandler.class) // @TableField(typeHandler = FastjsonTypeHandler.class) private JSONObject jsonObj; } 该注解对应XML 中：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40be4c550b7b8a8f26c741223cde90f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/414477d628a682d93a53e66a23e72a1b/" rel="bookmark">
			爬虫---scrapy爬虫框架（详细&#43;实战）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​
活动地址：CSDN21天学习挑战赛
爬虫---scrapy爬虫框架 爬虫---scrapy爬虫框架一、简介1、基本功能2、架构3、scrapy项目的结构 二、scrapy环境搭建三、如何开始1、新建项目 ：新建一个新的爬虫项目2、明确目标 （items.py）：明确你想要抓取的目标3、制作爬虫 （spiders/xxspider.py）：制作爬虫开始爬取网页4、存储内容 （pipelines.py）：设计管道存储爬取内容5、运行爬虫 四、项目实战 爬虫—scrapy爬虫框架 一、简介 1、基本功能 Scrapy是一个适用爬取网站数据、提取结构性数据的应用程序框架，它可以应用在广泛领域：Scrapy 常应用在包括数据挖掘，信息处理或存储历史数据等一系列的程序中。通常我们可以很简单的通过 Scrapy 框架实现一个爬虫，抓取指定网站的内容或图片。
2、架构 Scrapy Engine(引擎)：负责Spider、ItemPipeline、Downloader、Scheduler中间的通讯，信号、数据传递等。Scheduler(调度器)：它负责接受引擎发送过来的Request请求，并按照一定的方式进行整理排列，入队，当引擎需要时，交还给引擎。Downloader（下载器）：负责下载Scrapy Engine(引擎)发送的所有Requests请求，并将其获取到的Responses交还给Scrapy Engine(引擎)，由引擎交给Spider来处理。Spider（爬虫）：它负责处理所有Responses,从中分析提取数据，获取Item字段需要的数据，并将需要跟进的URL提交给引擎，再次进入Scheduler(调度器)。Item Pipeline(管道)：它负责处理Spider中获取到的Item，并进行进行后期处理（详细分析、过滤、存储等）的地方。Downloader Middlewares（下载中间件）：一个可以自定义扩展下载功能的组件。Spider Middlewares（Spider中间件）：一个可以自定扩展和操作引擎和Spider中间通信的功能组件。
3、scrapy项目的结构 项目名字 项目的名字 spiders文件夹（存储的是爬虫文件） init 自定义的爬虫文件 核心功能文件 init items 定义数据结构的地方 爬虫的数据都包含哪些 middleware 中间件 代理 pipelines 管道 用来处理下载的数据 settings 配置文件 robots协议 ua定义等 二、scrapy环境搭建 三、如何开始 1、新建项目 ：新建一个新的爬虫项目 打开cmd，输入scrapy startproject 项目的名字 (默认是在C:\Users\...这个目录下，你可以自行切换到对应的 文件下） 注意：项目的名字不允许使用数字开头 也不能包含中文 2、明确目标 （items.py）：明确你想要抓取的目标 选择你需要爬取的内容，例如作者名字、小说名、封面图片等 在items.py文件中定义 import scrapy class AdicrawlerItem(scrapy.Item): author = scrapy.Field() theme = scrapy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/414477d628a682d93a53e66a23e72a1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcc38368671abeca56f2fab069a0d641/" rel="bookmark">
			Vue 项目 js 文件中使用 vue-i18n
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景: 项目引入多语言后发现还有个别地方没有翻译完全, 直接使用i18n 的方法来写的话会直接报错, 比如:
1. router.js 中默认路由的title(也可以在渲染menu或tag 时使用{{$t(xxx)}}
2. index.html 中的 title
3. 一些js方法库中的多语言
解决办法: 示例代码
// lang/index.js import Vue from "vue" import ElementUI from "element-ui" import VueI18n from "vue-i18n" // elment-ui import locale from "element-ui/lib/locale" import zhLocale from "element-ui/lib/locale/lang/zh-CN" import enLocale from "element-ui/lib/locale/lang/en" vxe-table import VXEzhCN from "vxe-table/lib/locale/lang/zh-CN" import VXEenUS from "vxe-table/lib/locale/lang/en-US" // 自己的多语言文件 import zh from "./zh" import en from "./en" Vue.use(VueI18n) const messages = { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcc38368671abeca56f2fab069a0d641/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cff7c1aa31c6ad8da884ca515d927295/" rel="bookmark">
			手摸手系列之SpringBoot&#43;Vue整合snakeflow工作流实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 技术栈：
SpringBoot: 2.3.5.RELEASE
Vue: 2.6.10
snakerflow: 2.5.1
最近做集团内部的悦通关平台项目，台账管理的付款申请模块需要用到工作流审批功能，本着轻量的目的，特选定了国内开发者开源的一款轻量级工作流引擎-snakeflow。官网了解到Snaker是一个基于Java的轻量级工作流引擎，适用于企业应用中常见的业务流程。本着轻量、简单、灵巧理念设计，定位于简单集成、多环境支持，基于Apache License Version 2.0开源协议发布。文档指南👉[点我直达]
snakeflow核心简介 7张核心表定义：
WF_PROCESS：流程定义，例如请假申请，用车申请等流程定义。
WF_ORDER：流程实例，当前运行中的流程实例的信息，比如，我申请了一条请假流程，流程编号“请假-001”，这个请假流程“请假-001”就是一个流程实例。
WF_HIST_ORDER：历史流程实例，只要启动过的流程，历史流程实例表中就会存储流程的实例信息，比如这条流程是否结束。
WF_TASK：任务，某个流程中某个节点，叫做任务实例。比如“请假-001”中需要上级审批，“上级审批”这个节点就是一个任务实例。
WF_HIST_TASK：历史任务(就是执行完了的任务)，所有任务结束以后都会在历史任务信息表里存一条记录。
WF_TASK_ACTOR：每个任务对应的参与者(记住谁可以签收或处理)，可能会有多个人或者用户组。
WF_HIST_TASK_ACTOR：历史的参与者表，任务处理完以后，对应处理人的信息会存到这个表里面。
各核心表及流程详解:
WF_PROCESS：存放流程定义，通过编辑一个后缀为.snaker的xml文档来定义流程的走向；在前端流程定义管理里有个部署流程的按钮，可以将编辑好的xml文档保存到WF_PROCESS表中，并产生一条记录。xml文档里有流程的名字，如果这个名字在WF_PROCESS已经存在了，则保存时产生的新的记录的version字段值会自动加1。processId是唯一的，不重复。
WF_ORDER：存放流程实例的。开启一个流程实例时，WF_ORDER表有个字段PROCESS_ID和流程定义的process_id相关联，他们是一对多的关系。当开启一个流程实例WF_ORDER时，在WF_ORDER和WF_HIST_ORDER都新增一条记录，并且同时产生的那两条记录的主键id是一样的。，其中WF_HIST_ORDER比WF_ORDER多一个字段ORDER_STATUS 流程实例状态(0：结束；1：活动)。当流程没跑完时，ORDER_STATUS的值是1；当整个事件流程跑完了，WF_ORDER表的那条记录会被删除，WF_HIST_ORDER表对应的那条记录的ORDER_STATUS的值变成0，表示流程实例跑完了。
WF_TASK：存当前任务的；当流程执行完当前任务节点时，WF_TASK的这条记录会被剪切到WF_HIST_TASK表中，然后在WF_TASK表中新增下一个任务节点的信息记录。新增的下一任务节点的task有个字段parent_task_id记住上一个任务节点在WF_HIST_TASK表里的WF_HIST_TASK_ID(上一个任务节点从WF_TASK表剪切到WF_HIST_TASK了)；这样就可以实现回退等功能。
WF_TASK_ACTOR：存哪个任务关联了那些参与者的，就是哪些人可以签收或者处理。如果当前任务节点被执行了，则相关的参与者会被剪切到WF_HIST_TASK_ACTOR表里，和WF_TASK、WF_HIST_TASK类似，这样回退时，就知道以前这一步是谁处理的。
假如现在执行节点的任务是A2，上述中wf_task存的是执行中的记录，也就是说在执行A2前，wf_task中肯定会有一条执行中的任务记录，假设为A1，那么执行A2时的增删改为先将wf_task和wf_task_actor表中A1的记录插入wf_hist_task和wf_hist_task_actor中；其次是删除wf_task和wf_task_actor中A1记录，然后将A2的信息插入到wf_task和wf_task_actor中。此时wf_task表的parent_task_id是历史表A1记录的Id，通过此可将所有任务串联起来。task表的variable中的值为局部变量只能在当前task中使用。有人会有疑问，假设有如下流程图，执行task1时会怎么样？
因为开始节点是一个比较特殊的nodemodel，称之为流转逻辑元素，它只负责流转到下一节点不负责执行，也就没有数据库的增删改。这样直接流转到task1，插入wf_hist_task和wf_hist_task_actor，并且又直接流转到end节点，end节点也是一个流转元素，它会直接删除wf_order表的记录并更改该流程实例wf_hist_order表的order_state的状态。
至此一个流程的所有增删改查结束。
项目整合 pom引入snakeflow依赖 &lt;dependency&gt; &lt;groupId&gt;com.github.snakerflow&lt;/groupId&gt; &lt;artifactId&gt;snaker-spring&lt;/artifactId&gt; &lt;version&gt;2.5.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.snakerflow&lt;/groupId&gt; &lt;artifactId&gt;snaker-mybatis&lt;/artifactId&gt; &lt;version&gt;2.4.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.snakerflow&lt;/groupId&gt; &lt;artifactId&gt;snaker-core&lt;/artifactId&gt; &lt;version&gt;2.5.1&lt;/version&gt; &lt;/dependency&gt; 根据业务设计流程定义 官方的流程设计器比较老旧比较丑，推荐一个第三方图形化的流程设计器：模型设计 - mldong快速开发平台
界面如上图，根据自己的业务需求，设计出相应的流程图，然后点击查看按钮导出xml代码：
在项目的resources目录下新建.snaker后缀的流程定义文件，将xml代码复制进去，此文件即为流程定义模型文件，工作流引擎会自动生成对应的流程定义模型。
具体xml代码：
&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt; &lt;process name="payreq" displayName="付款申请流程" instanceUrl="/snaker/flow/all"&gt; &lt;start name="start" displayName="开始" layout="780,-180,120,80"&gt; &lt;transition name="b288a53d-e54e-473d-8ed1-fc4fa21f0210" to="apply" g="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cff7c1aa31c6ad8da884ca515d927295/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd1e9e4e50a555dd399a2145cb382e46/" rel="bookmark">
			解决笔记本屏幕显示缩放比例125% 150%对页面布局的影响
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的是vue项目 在utils.js添加方法 detectZoom export const detectZoom = () =&gt; { let ratio = 0, screen = window.screen, ua = navigator.userAgent.toLowerCase(); if (window.devicePixelRatio !== undefined) { ratio = window.devicePixelRatio; } else if (~ua.indexOf('msie')) { if (screen.deviceXDPI &amp;&amp; screen.logicalXDPI) { ratio = screen.deviceXDPI / screen.logicalXDPI; } } else if ( window.outerWidth !== undefined &amp;&amp; window.innerWidth !== undefined ) { ratio = window.outerWidth / window.innerWidth; } if (ratio) { ratio = Math.round(ratio * 100); } return ratio; }; main.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd1e9e4e50a555dd399a2145cb382e46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2da421425e16800e647e63200efbf356/" rel="bookmark">
			python第三方包修改之后重新压缩用于pip install
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在修改一个第三方包（hbase-thrift-0.20.4）里面的python代码之后，直接tar压缩，用pip install 安装报错
tarfile.ReadError: not a gzip file
不是gzip包，那就把它变成一个gzip包
step1: 下载源码包，省略 step2: 先gzip解压包 gzip -dv hbase-thrift-0.20.4.tar.gz
step3: 然后tar解压包 tar -xvf hbase-thrift-0.20.4.tar
step4: 修改目录中的文件，省略 step5: tar打包目录 tar -cvf hbase-thrift-0.20.4.tar hbase-thrift-0.20.4
step6: gzip压缩tar包 gzip hbase-thrift-0.20.4.tar
step7: pip install 新的tar.gz包 pip install hbase-thrift-0.20.4.tar
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e5f98bada4373f2b0af88ec43977165/" rel="bookmark">
			计算机网络期末复习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		zzulier的计算机网络期末复习
计算机网络期末考题汇总 名词解释 ISP：互联网服务提供者
OSPF：开放最短路径优先（内部网关协议）
RIP：路由信息协议（内部网关协议）
BGP：边界网关协议（外部网关协议）
FTP：文件传送协议
DNS:域名系统
HTTP：超文本传送协议
ARP：地址解析协议
CSMA/CD：载波监听多点接入/碰撞检测
TCP：传输控制协议
UDP：用户数据报协议
DHCP：动态主机配置协议
SMTP：简单邮件传送协议
SNMP：简单网络管理协议
大题（简答&amp;论述&amp;计算） 1.计算机网络可以分为哪些类别？各种类别的网络有哪些特点？P19
答：
（1）按照网络的作用范围来分：
①广域网WAN：广域网的作用范围通常为几十到几千公里，是互联网的核心部分,连接广域网各节点交换机的链路一般都是高速链路，具有较大的通信容量。（远程、高速、是Internet的核心网，都属于公共网络，覆盖区域广。）
②城域网MAN:作用范围一般是一个城市，可跨越几个街区甚至整个城市，其作用距离约为5-50km。城域网可以为一个或几个单位所拥有，也可以是一种公用设施，用来将多个局域网进行互连。（城市范围，链接多个局域网，属于公共网络，覆盖面较广域网窄。）
③局域网LAN：一般采用微型计算机或工作站通过高速通信线路相连，但地理上则局限在较小的范围(如1km左右)。（校园、企业、机关、社区，属于区域网络，覆盖面更窄。）
④个人区域网PAN：范围很小，大约在10m左右，个人区域网就是在个人工作的地方把属于个人使用的电子设备用无线技术连接起来的网络。（个人电子设备，属于移动个人网络，由基站发出，个人设备网络共享。）
（2）按照网络的使用者进行分类：
①公用网：“公用”的意思就是愿意按电信公司的规定交纳费用的人都可以用这种网络。
②专用网：某部门为满足本单位的特殊业务工作的需要而建造的，这种网络不向本单位以外的人提供服务。
2.试从多个方面比较电路交换、报文交换、分组交换的区别。
答：
（1）交换传输方式方面
①电路交换：在通信之前要在通信双方之间建立一条双方独占的物理通路。
②报文交换：是以报文为数据交换的单位，报文携带有目标地址、源地址等信息，在交换结点采用存储转发的传输方式。
③分组交换：仍采用存储转发技术，但先将一个报文划分为几个分组后在进行传送。
（2）传输时延方面
①电路交换：由于通信线路为通信双方用户专用，数据直达，故传输数据的时延非常小。
②报文交换：不需要为通信双方预先建立一条专用的通信线路，不存在连接建立时延，用户可随时发送报文。
③分组交换：分组逐个传输，这种流水线式传输方式减少了报文的传输时延。
（3）实时性方面
①电路交换：通信双方之间的物理通路一旦建立，双方可以随时通信，实时性强。
②报文交换、分组交换：数据进入交换结点后要经历存储转发过程，实时性差，不适合传送实时或交互式业务数据。
（4）面对大量数据的传输速率方面
①电路交换：连续传送大量数据，且其传送时间远大于连接建立时间，则电路交换的传输速率较快。
②报文交换、分组交换：传输时延较大，面对连续的大量数据，传输速率相对较低。
（5）网络信道利用率方面
①报文交换、分组交换：不需要预先分配传输带宽，在传送突发式数据时可提高整个网络的信道利用率。
②电路交换：通信双方独占物理通路，网络信道利用率较低。
（6）灵活性方面
由于一个分组的长度往往远小于整个报文的长度，因此分组交换比报文交换的时延小，具有更好的灵活性。
（7）数据传送阶段主要特点
①电路交换：整个报文的比特流连续地从源点直达终点，好像在一个管道中传送。
②报文交换：整个报文西安传送到相邻节点，全部存储下来后查找转发表，转发到下一个节点。
③分组交换：单个分组（仅为报文的一部分）传送到相邻节点，存储下来后查找转发表，转发到下一个节点。
3.物理层的接口有哪几个方面的特性？各包含什么内容？P42
答：可以将物理层的主要任务描述为确定与传输媒体的接口有关的一些特性：
（1）机械特性：指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置等。（语法）
（2）电气特性：指明在接口电缆的各条线上出现的电压的范围。（语法）
（3）功能特性：指明某条线上出现的各条线上出现的电压的范围。（语义）
（4）过程特性：指明对于不同功能的各种可能事件的出现顺序。（同步）
4.数据链路层需要解决的三个基本问题是什么？为什么都必须加以解决？P73
答：
（1）封装成帧：封装成帧，即帧定界，是分组交换的必然要求。在一段数据前后分别添加首部和尾部，接收端以便从收到的比特流中识别帧的开始与结束。
（2）透明传输：避免消息符号与帧定界符相混淆。由于帧的开始和结束的标记使用专门的控制字符， 因此，所传输的数据中的任何8比特的组合一定不允许和用作帧定界的控制字符的比特编码一样，否则就会出现帧定界的错误。
（3）差错检测：防止差错的无效数据帧，浪费网络资源。现实的通信都不会是理想的，即比特在传输的过程中可能会产生差错，为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施。目前在数据链路层广泛使用了循环冗余检验。
5.判断以下 IP 地址的类别。
① 128.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e5f98bada4373f2b0af88ec43977165/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd8306ded37d57b4823d11156a7151ba/" rel="bookmark">
			麒麟安装tomcat
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、软件介绍 Tomcat服务器是一个免费的开放源代码的Web应用服务器，属于轻量级应用服务器。在中小型系统和并发访问用户不多等场合下被普遍使用，是开发和调试JSP 程序的首选。
二、编译和测试方式 本文选用麒麟服务器V10版本做测试安装apache-tomcat-8.5.41版本
获取软件包
执行以下命令，获取Tomcat软件包。
cd /usr/local/（安装路径） wget https://archive.apache.org/dist/tomcat/tomcat-8/v8.5.41/bin/apache-tomcat-8.5.41.tar.gz 编译环境配置
（1）安装JDK(新建一个目录)
检查JDK是否安装 java -version 若没有安装则安装 yum install -y java-1.8.0-openjdk 1.1 手动安装
下载上传
在etc/proflie 最后添加
// /usr/java/jdk1.8.0_141 改成自己的目录 export JAVA_HOME=/usr/java/jdk1.8.0_141 export JRE_HOME=${JAVA_HOME}/jre export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib:$CLASSPATH export JAVA_PATH=${JAVA_HOME}/bin:${JRE_HOME}/bin export PATH=$PATH:${JAVA_HOME}/bin （2）解压Tomcat软件包。
tar -xvf apache-tomcat-8.5.41.tar.gz （3）运行Tomcat。
cd /usr/local/apache-tomcat-8.5.41/bin ./startup.sh （4）在浏览器中输入URL：http://服务器IP地址:8080并单击回车。
当出现以下页面，说明Tomcat服务器环境配置成功
如果以上URL不能访问，请检查服务器是否开放8080端口。
关闭防火墙命令 systemctl stop firewalld.service 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1fa23d15b69146ec4e7b371b1002b87/" rel="bookmark">
			判断多个checkbox复选框至少选一个（提交时必须选择一个）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTML代码：
&lt;h2&gt;请选择您的爱好：&lt;/h2&gt; &lt;form action="" method="post" id="form"&gt; &lt;label&gt;&lt;input type="checkbox" name="hobby" value="上班" /&gt;上班&lt;/label&gt; &lt;label&gt;&lt;input type="checkbox" name="hobby" value="运动" /&gt;运动&lt;/label&gt; &lt;label&gt;&lt;input type="checkbox" name="hobby" value="看书" /&gt;看书&lt;/label&gt; &lt;label&gt;&lt;input type="checkbox" name="hobby" value="上网" /&gt;上网&lt;/label&gt; &lt;label&gt;&lt;input type="checkbox" name="hobby" value="网购" /&gt;网购&lt;/label&gt; &lt;label&gt;&lt;input type="checkbox" name="hobby" value="其他" /&gt;其他&lt;/label&gt; &lt;button type="reset"&gt;重 置&lt;/button&gt; &lt;button type="button" onclick="Submit()"&gt;提 交&lt;/button&gt; &lt;/form&gt; jQuery写法：
function Submit() { var checkOne = false; //判断是否被选择条件 var chboxVal = []; //存入被选中项的值 var checkBox = $('input[name = hobby]'); //获得得到所的复选框 for (var i = 0; i &lt; checkBox.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1fa23d15b69146ec4e7b371b1002b87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc8c9ba72cf007935fa9b381f6a09ed1/" rel="bookmark">
			adb获取当前页面的Activity
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android Studio的控制台输入如下命令：
adb shell dumpsys activity activities 如下图 ：
adb shell "dumpsys window | grep mCurrentFocus" 如下图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6e93b8d0d6ca3aaab5c69abdaa2614e/" rel="bookmark">
			计算机图形学之图形系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、计算机图形系统的组成 1.输入设备
用于输入数据的装置，从原始的穿孔纸到今天的数据手套，数据衣经历了四个阶段的发展。
2.显示设备
主要指各类显示器，用于显示输出图形信息，经历了从CRT到3D的发展历程
3.输出设备
主要指硬拷贝设备，用于将图形或非图形信息以打印或印刷的形式长期保存。
4.图形软件
二、从穿孔纸到数据衣 1.穿孔纸
从穿孔纸上孔的有无来表示0和1。
2.键盘和光笔
3.图形用户界面
不懂计算机的普通用户也可以熟练应用
触摸屏（即使输入设备，也是输出设备）
红外线，声表面波式： 电阻或电容式：通过按压后电阻或电容的变化。 4.数据衣
动作捕捉数据衣：让VR系统识别全身运动而设计的输入装置。对人体大约50多个不同的关节进行测量，通过光电转换，将身体的运动信息送入计算机进行图像重建。感知反馈数据衣：作用不是输入而是输出。输出触觉及其他感知，如刮风。下雨，温度变换，收到虚拟人物的攻击，物体抛掷或降落等。 三、从CRT到3D显示 1.阴极射线管
对荧光粉的性能要求：
1.发光效率高
发光效率：每瓦电功率能给出多大的发光强度
2. 余晖时间合适
余晖特性：电子束轰击荧光时，荧光粉的分子受激而发光，当电子束的轰击停止后，荧光粉的光亮并非立即消失，而是按指数规律衰减。
余晖时间：从电子束停止轰击到发光亮度下降到初始值的1%所经历时间
3.寿命长
2.彩色阴极射线管
主要结构：
三只电子枪
荫罩板
三色荧光屏
3.平板显示器
液晶显示器
等离子显示器
LED显示器
4.3D显示
1：早期的三维立体显示 - 进大远小
2：三维立体显示原理
3：三维立体显示设备
4：裸眼立体显示器
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/404398405a1eeadd98da9ee1b9a5343b/" rel="bookmark">
			无法读取跨域样式表的 cssRules
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景 需要解析外联样式表，收集其中的 CSS 样式插入到 style 标签中。
问题描述 但是当 DOM 中存在跨域外联样式表的时候，执行 resolveStyleSheets 方法会报错，信息如下：
DOMException: Failed to read the 'cssRules' property from 'CSSStyleSheet': Cannot access rules at resolveStyleSheets.
function resolveStyleSheets() { const styleSheets = document.styleSheets console.log(styleSheets); if (styleSheets.length &lt;= 0) return try { const styleEl = document.createElement('style'); for (let i = 0; i &lt; styleSheets.length; i++) { const cssRules = styleSheets.item(i).cssRules; // styleSheets.item(i). for (let j = 0; j &lt; cssRules.length; j++) { const cssRule = cssRules.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/404398405a1eeadd98da9ee1b9a5343b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7c0e2dc7cc44cbcc8b349fd4ea29a9f/" rel="bookmark">
			CentOS7离线安装mysql5.7
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言一、环境准备1.1 CentOS的安装1.2 安装前检查是否有残余mysql1.3 MySQL的下载解压 二、安装2.1 安装MySQL2.2 修改root密码2.3 开放远程访问权限2.4 修改字符编码2.5 开放3306端口防火墙 3 其他配置 前言 由于每次安装mysql的环境都不同，有时有外网，有时没有。现就无外网环境的CentOS7上安装mysql5.7，为以后用到时提供参考。
提示：考虑到环境不同，以下内容，仅供参考
一、环境准备 名称版本下载源CentOS7.5CentOS官网下载地址MySQL5.7MySQL官网下载地址 1.1 CentOS的安装 以前记录过在线安装Linux相关软件的文章，版本是CentOS7.2，可以参考。
1.2 安装前检查是否有残余mysql rpm方式安装残留
#查包名 rpm -qa|grep -i mysql #删除命令 rpm -e –nodeps 包名 #查找mysql相关目录 find / -name mysql #删除相关目录(依次删除) rm -rf "目录文件路径" #删除 /etc/my.cnf rm -rf /etc/my.cnf #删除/var/log/mysqld.log（如果不删除这个文件，会导致新安装的mysql无法生存新密码，导致无法登陆 rm -rf /var/log/mysqld.log #查看mysql用户及用户组 more /etc/passwd | grep mysql more /etc/group | grep mysql more /etc/shadow | grep mysql #删除mysql用户及用户组 userdel mysql groupdel mysql #检查是否有mariadb rpm -qa | grep mariadb #如果有则卸载 rpm -e --nodeps mariadb-libs rpm -e --nodeps mariadb-devel-5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7c0e2dc7cc44cbcc8b349fd4ea29a9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fa98b7ac676596db866d2db4134f9a6/" rel="bookmark">
			Altium Designer19 多层板设计教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
Altium Designer19 多层板设计教程 Altium Designer19 多层板设计教程
摘要
一、Altium Designer是什么？
二、使用步骤
1.主要功能
2.多层板设计步骤
总结
在设计多层PCB电路板之前，设计者需要首先根据电路的规模、电路板的尺寸和电磁兼容（EMC）的要求来确定所采用的电路板结构，也就是决定采用4层，6层，还是更多层数的电路板。确定层数之后，再确定内电层的放置位置以及如何在这些层上分布不同的信号。这就是多层PCB层叠结构的选择问题。
一、Altium Designer是什么？ Altium Designer 除了全面继承包括Protel 99SE、Protel DXP在内的先前一系列版本的功能和优点外，还增加了许多改进和很多高端功能。该平台拓宽了板级设计的传统界面，全面集成了FPGA设计功能和SOPC设计实现功能，从而允许工程设计人员能将系统设计中的FPGA与PCB设计及嵌入式设计集成在一起。 由于Altium Designer 在继承先前Protel软件功能的基础上，综合了FPGA设计和嵌入式系统软件设计功能，Altium Designer 对计算机的系统需求比先前的版本要高一些。
二、使用步骤 1.主要功能 1 原理图设计
2 印刷电路板设计
3 嵌入式开发
4 3D PCB设计
5 封装库设计
2.多层板设计步骤 1.打开AD19
2. 打开PCB
3在PCB页面
设计——叠层管理器
4.在叠层管理器页面
在Edit-——add layer添加所需层数
signal 正片层
plane 负片层
总结 以上就是今天要讲的内容，简单的介绍了如何使用AD设计多层PCB板
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2e70bfeacc184713f0d2e2ca344c812/" rel="bookmark">
			递归算法题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、
int fun(int n) { if (n &lt;= 1) { return 1; } else { return n * fun(n-1); } } int res = fun(5) 答案：120
2、
int search(int start, int end, int target, int *arr) { if(start &lt;= end) { int mid = start + (end - start) / 2; if (arr[mid] == target) return mid; else if (target &gt; arr[mid]) return search(mid + 1, end, target, arr); else if (target &lt; arr[mid]) return search(start, mid - 1, target, arr); } return -1; } 答案解析：代码为标准的二分查找，期望情况下，每次将范围n缩小一半，直到找到目标元素或者左右游标相遇，因此平均需要logN次搜索，所以时间复杂度为O(logN)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2e70bfeacc184713f0d2e2ca344c812/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/baf4fc3ce1918c59fb1fab0696918dad/" rel="bookmark">
			Gradle系列——常用指令，修改gradle源，Wrapper包装器（源于文档7.5版本，SpringBoot使用）day1-2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Gradle系列——常用指令，修改gradle源，Wrapper包装器（源于文档7.5版本，SpringBoot使用）day1-2 Gradle常用指令注意点 修改Gradle源1.打开gradle目录下的init.d文件夹2.添加一个init.gradle文件3.修改init.gradle阿里云官网错误 了解一下init.gradle文件init.gradle文件启用方法配置仓库说明 Wrapper包装器Gradle Wrapper的工作流程添加Gradle Wrapper(若你下载的是all就不需要)使用Gradle WrapperGradle Wrapper的目录结构下载和用自己以前写的用Gradle Wrapper！ Gradle常用指令 指令说明gradle clean清空build目录gradle classes编译业务代码和配置文件gradle test编译测试代码，生成测试报告gradle build构建项目gradle build -x test跳过测试构建 如上的指令需要在有build.gradle文件目录下执行
注意点 使用gradle test命令生成测试报告后，存放在\build\reports\tests\test
使用gradle build相当于clean+classes+test+build整体流程
修改Gradle源 阿里巴巴镜像源地址
1.打开gradle目录下的init.d文件夹 2.添加一个init.gradle文件 3.修改init.gradle 参照提供的实例我们修改一下，我在下面提供了基本上可能用到的所有配置
allprojects { repositories { maven { url 'https://maven.aliyun.com/repository/public/' } maven { url 'https://maven.aliyun.com/repository/spring/' } maven { url 'https://maven.aliyun.com/repository/central/' } maven { url 'https://maven.aliyun.com/repository/google/' } maven { url 'https://maven.aliyun.com/repository/gradle-plugin/' } maven { url 'https://maven.aliyun.com/repository/spring-plugin/' } mavenLocal() mavenCentral() } } 阿里云官网错误 这个地方使用的是allprojectsP是小写的，不然后面构建会报错
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/baf4fc3ce1918c59fb1fab0696918dad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e8555b2f254a8e79a396bb8a6cc3109/" rel="bookmark">
			信息收集之cms指纹识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意：仅用于技术讨论，切勿用于其他用途，一切后果与本人无关。
一、指纹识别知识
指纹的特征：唯一性、终生不变性、方便性
在线识别收集指纹信息
一、云悉在线 http://www.yunsee.cn
二、Whatweb http://www.whatweb.net
三、潮汐指纹 http://finger.tidesec.net
三、插件:wappalyzer https://www.wappalyzer.com 非常好用，可以直接插件搜索
四、脚本：CMSeek https://github.com/Tuhinshubhra/CMSeek
五、Webfinger https://github.com/se55i0n/Webfinger 二、WAF
一、Awesome-WAF项目
https://github.com/0xInfection/Awesome-WAF
二、检测脚本：wafw00f
https://github.com/EnableSecurity/wafw00f
三、CDN
改善网站加载时间、减少服务器负载，降低成本、提高网站安全性
一、国内在线
http://cdn.chinaz.com/
二、国外在线cdnplanet
https://www.cdnplanet.com/
三、脚本探测：xcdn
https://github.com/3xp10it/xcdn
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0218948e501e05b5852e815a5abf565/" rel="bookmark">
			遥感影像云检测-现有光学遥感卫星数据参数合集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现有光学遥感卫星 1.MODIS卫星介绍1.1.MODIS传感器简介1.2.MODIS传感器基本参数1.3.MODIS 数据特点及波段分布特征1.4.MODIS 数据产品产品级别及类型1.4.1.产品级别1.4.2.产品类型 1.5.MODIS 1B数据简介1.6.MODIS 命名规则1.7.MODIS 应用领域1.6.1.水文水资源监测1.6.2 土地利用覆盖监测1. 6.3 草地估产1.6.4 洪涝监测 2.LandSat系列2.1.LandSat系列及影像下载网址2.1.1.Landsat-5介绍2.1.2.Landsat-7介绍2.1.3.Landsat-8介绍 2.2.传感器介绍2.2.1.Landsat5 TM2.2.2.Landsat7 ETM2.2.3.Landsat7 波段合成应用 2.3.Landsat8卫星2.3.1.Landsat8产品描述2.3.2.Landsat8波段参数2.3.3.Landsat8波段合成应用 3.Sentinel-23.1.Sentinel-2简介3.2.Sentinel-2传感器波段3.3.Sentinel-2A产品3.4.Sentinel-2数据下载3.5.Sentinel-2数据处理 4.高分系列4.1.高分一号（GF1）卫星4.1.1.概述4.1.2.传感器参数 4.2.高分二号（GF2）卫星4.2.1.概述4.2.2.传感器参数 4.3.高分四号（GF4）卫星4.3.1.概述4.3.2.传感器参数 4.4.高分五号（GF5）卫星4.5.高分七号（GF7）卫星4.5.1.概述4.5.2.传感器参数 4.6.数据下载4.6.1.数据查询4.6.2.数据下载4.6.3.数据预处理 1.MODIS卫星介绍 转载：Modis卫星介绍
1.1.MODIS传感器简介 MODIS是搭载在TERRA和AQUA卫星上的一个重要的传感器，是卫星上唯一将实时观测数据通过x波段向全世界直接广播，并可以免费接收数据并无偿使用的星载仪器。
TERRA卫星于1999年12月18日发射成功，AQUA卫星于2002年5月4日发射成功。
TERRA为上午星，从北向南于地方时10:30左右通过赤道，AQUA为下午星，从南向北于地方时13：30左右通过赤道。
两颗星相互配合每1-2天可重复观测整个地球表面，得到36个波段的观测数据
1.2.MODIS传感器基本参数 项目Value空间分辨率250 m (1-2 波段 ) ； 500 m (3-7 波段 ) ； 1000 m (8-36 波段 )扫描宽度扫描宽度： 2330km时间分辨率1 天光谱波段36 个离散光谱波段，光谱范围宽，从 0.4 微米（可见光）到 14.4 微米（热红外）全光谱覆盖 。轨道705KM ，降轨上午 10:30 过境，升轨下午 1:30 过境；太阳同步；近极地圆轨道设计寿命5年 1.3.MODIS 数据特点及波段分布特征 全球免费光谱范围广：共有36个波段，光谱范围从0.4μm-14.4μm数据接收简单更新频率高：每天最少2次白天和2次黑夜的更新数据
1.4.MODIS 数据产品产品级别及类型 1.4.1.产品级别 按处理级别划分，可以分为以下5种：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0218948e501e05b5852e815a5abf565/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f270555ca2e881500a56d44ec7d32b1d/" rel="bookmark">
			Timer，时间堆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言什么是定时器定时器的实现时间堆 前言 博主这一段时间都没有更新博客，因为去抄 写了几个小的项目。接下来的几篇博客就当作是项目的总结吧。其中一个项目就是来自github的C++11版本WebServer。我实现的则放到了gitee上my_webserver 。
该项目应该也是吸取了最经典的TinyWebServer，主要由以下几个模块组成:
配置模块，一些基础的个性化配置。日志模块，记录服务器信息，便于查看和修bug。连接池，项目使用mysql数据库，使用连接池管理mysql连接。线程池，执行任务。时间堆，用于管理定时任务。epoller，linux下实现高并发的关键。缓冲区，用于存储http请求和响应的数据。http模块，主要包括http请求，http响应，和管理http连接。webserver，服务器的主要逻辑。 接下来我会逐一分析markparticle的C++11版本的这些模块。在开始此系列博客之前，强烈推荐大家阅读游双大佬的《Linux高性能服务器编程》,关于这些模块的条条杠杠，不敢说100%，一大半的基础知识都来自这本书。
什么是定时器 服务器中的定时器和我们日常生活中的定时器概念一样，**即将一个事件与一个时间点绑定，时间点一到，就执行该事件。**比如，我想明天8点起床，就定了一个8点的定时器。当闹钟一响，我就会执行起床这个事件。那么，在编程中，时间点很容易表示，如何刻画一个事件呢？没错，就是函数。
void get_up(){} 这样就能在特定的时间点，执行特定的事件。
当然了，基于不同的任务，我们的时间点设置也会不同，也可能会有半小时以后，2天以后这样的相对时间点，也可能会有绝对时间点。
定时器的实现 服务器往往需要很多个定时任务，这时候就需要一种数据结构管理它们，这就是服务器需要时间管理器的原因。
如果有很多个定时任务，应该怎样管理它们呢？
显然，我们需要基于它们触发的时间先后进行排序，排在前面的事件先触发。而触发的规则又有不同。比如，可以让时间管理器按照一定的周期进行触发，每隔5s触发一次之类的。但是，这样的坏处就是，可能每次触发不一定有事件就绪，白白触发。基于这样一种考虑，我们设法获得下一次触发任务到现在的时间t，然后让时间管理器经过t之后去触发任务，此时至少有一个任务会被触发。
时间堆 作者实现的时间管理器使用的是堆。利用堆的性质，每次可以选取出最值的特点，每次选择时间节点最小的定时器出来执行，以此往复。
而关于时间方面，使用的是C++11引入的chrono库。
typedef std::function&lt;void()&gt; TimeoutCallBack; //回调函数 typedef std::chrono::high_resolution_clock Clock; //时钟 typedef std::chrono::milliseconds MS; //毫秒 typedef Clock::time_point TimeStamp; //时间戳 struct TimerNode{ //时间节点 int id; TimeStamp expires; //绝对时间 TimeoutCallBack cb; bool operator&lt;(const TimerNode&amp; rhs){ //用于比较 return expires &lt; rhs.expires; } }; 这里，先typedef了一些类型用于后续方便使用。也定义了时间结点。你可能会注意到，回调函数的类型是function&lt;void()&gt;，一个没有参数且没有返回值的函数。那么，如果你的定时任务需要参数怎么办？
我们默认回调函数没有返回值。因为回调函数可能带有任意类型的参数，所以干脆将其变成没有参数的，如果你的回调函数带有参数，你需要自己使用bind或者lambda进行封装。这个手法经常使用。
id，用于标识一个时间结点，用来调整或者删除。expires，就是定时器触发的时间，这里使用的是时间戳。cb，即时间到之后要执行的任务。 对于时间堆，我们采用数组形式。在插入，调整，删除时间堆时，往往需要获得它们的下标，所以使用哈希存储时间节点id到数组下标的映射关系。
class Timer{ public: //... private: std::vector&lt;TimerNode&gt; heap_; std::unordered_map&lt;int, int&gt; ref_; //id -&gt; index }; 而对于堆，自然要提供向下调整和向上调整的函数。而为了更好的调整ref_，手写了一个swap函数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f270555ca2e881500a56d44ec7d32b1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04b9d73ee46a337ac19b0a0caef977d9/" rel="bookmark">
			IO进程基本操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IO进程学习概述 概述缓存机制标准IO打开文件读写文件cat 每次一行地读写文件wc -l 文件定位操作 文件IO打开文件读写文件cp命令的实现 文件定位操作 文件属性的获取目录操作库分类 进程进程状态切换图创建进程获取进程号结束进程回收进程资源创建守护进程 线程创建线程线程退出线程回收&amp;线程取消获取线程tid号 线程同步信号量初始化&amp;pv操作 线程互斥死锁线程条件变量的控制 进程间通信无名管道创建无名管道 有名管道创建有名管道 信号信号的响应方式信号处理接口司机与售票员信号处理 共享内存 概述 IO进程主打的就是文件之间的通信，希望本文有你需要的内容。
缓存机制 全缓存：与文件相关
刷新缓存的条件:程序正常退出时刷新,缓存区满刷新,强制刷新行缓存：与终端相关
刷新缓存的条件：\n刷新,程序正常退出时刷新,缓存区满刷新,强制刷新:fflush()不缓存：没有缓存区（stderr） 标准IO IO：input/output,针对于文件输入输出。
linux下文件类型：
b(块设备) c(字符设备) d(目录) -(普通文件) l(链接文件) s(套接字) p(管道)
概念：在C库中定义的一组专门用于输入输出的函数特点：
a. 标准IO通过缓冲机制减少系统调用的次数，提高效率
b. 标准IO围绕流进行操作，流用FILE *描述；（FILE 就是一个结构体，用于存放操作文件的相关信息，它在stdio.h文件中定义；vi -t FILE，ctags，ctrl+]:代码追踪，ctrl+t：回退）
c. 标准IO默认打开了三个流，stdin(标准输入)、stdout(标准输出)、stderr(标准出错)(FILE *stdin) 打开文件 FILE *fopen(const char *path, const char *mode) 功能：打开文件 参数： path：打开的文件 mode：打开的方式 r：只读，当文件不存在时报错，文件流定位到文件开头 r+：可读可写，当文件不存在时报错，文件流定位到文件开头 w：只写，文件不存在创建，存在清空 w+：可读可写，文件不存在创建，存在清空 a：追加(在末尾写),文件不存在创建，存在追加，文件流定位到文件末尾 a+：读和追加，文件不存在创建，存在追加，文件流定位到文件末尾 注：当a的方式打开文件时，写只能在末尾进行追加，定位操作 是无法改变写的位置，但是可以改变读的位置 返回值： 成功：文件流 失败：NULL，并且会设置错误码 FILE * freopen(const char *pathname, const char *mode, FILE* fp) 功能：将指定的文件流重定向到打开的文件中 参数：path：文件路径 mode：打开文件的方式（同fopen） fp：文件流指针 返回值：成功：返回文件流指针 失败：NULL	读写文件 int fgetc(FILE * stream) 功能：从文件中读取一个字符 参数：stream：文件流 返回值：成功：读到的字符 失败或读到文件末尾：EOF(-1) int fputc(int c, FILE * stream) 功能：向文件中写入一个字符 参数：c：要写的字符 stream：文件流 返回值：成功：写的字符的ASCII 失败：EOF size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream); 功能：从文件流读取多个元素 参数：	ptr ：用来存放读取元素 size ：元素大小 sizeof(数据类型) nmemb ：读取元素的个数 stream ：要读取的文件 返回值：成功：读取的元素的个数； 读到文件尾： 0 失败： -1	size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream); 功能：按对象写 参数：同上	返回值：成功：写的元素个数 失败 ：-1 由这两个函数，可以实现cat命令
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04b9d73ee46a337ac19b0a0caef977d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbe7f5fb6520a371c149f1bfff3d56dd/" rel="bookmark">
			C语言数组存储学生信息，并通过姓名获得该学生其他信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数说明 char *arr[4][5]数组存储学生基本信息.
FindByName(int a,int b,char *arr[a][b], char *name,char *student[b])函数参数a，b，arr[a][b]为主函数中的学生信息，name为需要查找的学生的姓名，用参数student[b]存储根据姓名找到的学生信息，类型为指针，所有直接可以传递数据。 strcmp(arr[i][0], name) 函数比较两参数字符串是否相等，相等则返回0.
函数实现 #include &lt;stdio.h&gt; #include &lt;string.h&gt; /** * 通过姓名找到学生的信息并打印 * @param a * @param b * @param arr * @param name * @param student */ void FindByName(int a,int b,char *arr[a][b], char *name,char *student[b]) { int j=0; for(int i=1;i&lt;a;i++) { if(strcmp(arr[i][0], name) == 0) j=i; } if(j!=0) { for(int i=0;i&lt;b;i++) student[i]=arr[j][i]; } else{ printf("未找到该学生信息！"); } } int main() { char *arr[4][5] = {{"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbe7f5fb6520a371c149f1bfff3d56dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/903135681e5ebd90720f75550fa9e91c/" rel="bookmark">
			Ubuntu21.10升级22.04操作记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录升级22.04版本过程
1 升级操作 首先，当前版本为21.10，在系统自动弹出的升级按钮中点击升级无反应。而后执行命令，重新在新的弹出框中升级。提示如下： (base) pang@pang-HP:~$ update-manager -c 正在检查新版 Ubuntu 不再提供您的 Ubuntu 版本的支持。 要获得关于升级的信息，请访问： http://www.ubuntu.com/releaseendoflife 请在升级前安装您的发行版所有可用更新。 (base) pang@pang-HP:~$ 其次，根据提示先升级当前系统 (base) pang@pang-HP:~$ sudo apt update 命中:1 https://dl.google.com/linux/chrome/deb stable InRelease 忽略:2 http://archive.ubuntu.com/ubuntu impish InRelease 命中:3 http://ppa.launchpad.net/gerardpuig/ppa/ubuntu impish InRelease 命中:4 https://linux.teamviewer.com/deb stable InRelease 忽略:5 https://deepin-wine.i-m.dev InRelease 忽略:6 http://archive.ubuntu.com/ubuntu impish-updates InRelease 命中:7 https://linux.teamviewer.com/deb preview InRelease 获取:8 https://deepin-wine.i-m.dev Release [1,611 B] 忽略:9 http://archive.ubuntu.com/ubuntu impish-backports InRelease 命中:10 http://ppa.launchpad.net/linrunner/tlp/ubuntu impish InRelease 忽略:11 https://deepin-wine.i-m.dev Release.gpg 忽略:12 http://archive.ubuntu.com/ubuntu impish-security InRelease 错误:13 http://archive.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/903135681e5ebd90720f75550fa9e91c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7de45c29cb6d669c43effe34d5ff730c/" rel="bookmark">
			技能大赛训练题：域用户和组织单元的创建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.将一台升级为skills.com的主域控制器，其完全域名为dc.skills.com。
2．按照“表：域用户和组信息表”所示，创建域用户和创建域用户组。
表：域用户和组信息表
3.新建名称为hr、tech、sale的3个组织单元；每个组织单元内新建与组织单元同名的全局安全组；每个组内新建2个用户：人力部（hr1-hr2）、营销部（sale1-sale2）、技术部（tech1-tech2），所有用户不能修改其口令，必须启用密码复杂度要求、密码长度最小为8位、密码最长期限为10天、允许失败登录尝试的次数为4次、重置失败登录尝试计数（分钟）为5分钟、直至管理员手动解锁帐户，并且只能每天8:00-18:00可以登录。
4.以上要求各个知识点进行截图
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ffa891b86dba457ce89976cd4a177c5/" rel="bookmark">
			安装RabbitMQ出现Plugin configuration unchanged.问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装RabbitMQ出现Plugin configuration unchanged.问题 rabbitmq-server和opt版本
出现问题：在安装RabbitMQ并配置好环境之后运行命令rabbitmq-plugins enable rabbitmq_management出现Plugin configuration unchanged.
找了许多解决方法，然后这个方法使用了之后解决了
在安装完RabbitMQ并且配置好环境变量之后.首先使用管理员权限打开命令控制符
注:一定要使用管理员权限打开,要不然权限不够
打开之后进入到安装RabbitMQ的安装目录sbin下
然后用命令进入到这个路径下
进入到这里之后在终端执行
rabbitmq-service.bat remove 命令
然后执行
set RABBITMQ_BASE=D: abbitmq_serverdata 命令,后面的路径写自己的文件夹,可以创建一个data,此项操作是因为默认的路径在c盘用户的文件夹下
此项操作可以改变默认路径
然后执行下载命令:
rabbitmq-service.bat install 执行完此命令之后再次执行
rabbitmq-plugins enable rabbitmq_management 命令
还没完,紧接着执行RabbitMQ启动命令:
rabbitmq-server.bat start 如上则是启动成功,之后去浏览器打开RabbitMQ的Web端管理网页:
localhost:15672 默认用户名和密码都是guest,点击登录即可.
原文链接：https://blog.csdn.net/weixin_44166895/article/details/116712063
但是我完成这些不走之后依然无法访问，解决方法：
Win+R 输入services.msc打开进程，找到RabbitMQ 右键启动
然后在访问地址就行了！！！
先自我介绍一下，小编13年上师交大毕业，曾经在小公司待过，去过华为OPPO等大厂，18年进入阿里，直到现在。深知大多数初中级java工程师，想要升技能，往往是需要自己摸索成长或是报班学习，但对于培训机构动则近万元的学费，着实压力不小。自己不成体系的自学效率很低又漫长，而且容易碰到天花板技术停止不前。因此我收集了一份《java开发全套学习资料》送给大家，初衷也很简单，就是希望帮助到想自学又不知道该从何学起的朋友，同时减轻大家的负担。添加下方名片，即可获取全套学习资料哦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c542989f798d913245594adf4a2cce51/" rel="bookmark">
			SQL查询语句之查询数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、基本查询语句
2、单表查询
2.1 查询所有字段
1、列出表中的所有字段
2、使用 ‘?* ’ 查询所有字段?
2.2 查询指定字段
2.3 查询指定记录
2.4 带 in 关键字的查询
2.5 带 between and 的范围查询
2.6 带 like 的字符匹配查询
2.7 查询空值
2.8 带 and 的多条件查询
2.9 带 or 的多条件查询
2.10 查询结果不重复
2.11 对查询结果排序
2.12 分组查询
1、单独使用group by关键字来分组
2、group by 关键字与 group_concat()函数一起使用
3、group by 关键字与集合函数一起使用
4、group by 关键字与having一起使用
5、按多个字段进行分组
6. GROUP BY关键与WITH ROLLUP一起使用
2.13 用 limit 限制查询结果的数量
1、不指定初始位置
2、指定初始位置
3、使用集合函数查询
3.1 count() 函数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c542989f798d913245594adf4a2cce51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9857d7951c789f90b99dd14278618268/" rel="bookmark">
			第09章_性能分析工具的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第09章_性能分析工具的使用
文章目录 1. 数据库服务器的优化步骤2. 查看系统性能参数3. 统计SQL的查询成本：last_query_cost4.定位执行慢的 SQL：慢查询日志4.1 开启慢查询日志参数4.2 查看慢查询数目4.3 案例演示4.4 测试及分析4.5 慢查询日志分析工具：mysqldumpslow4.6 关闭慢查询日志4.7 删除慢查询日志 5. 查看 SQL 执行成本：SHOW PROFILE6. 分析查询语句：EXPLAIN6.1 概述6.2 基本语法6.3 数据准备6.4 EXPLAIN各列作用1. table2. id3. select_type4. partitions (可略)5. type ☆阿里巴巴开发手册要求 6. possible_keys和key7. key_len ☆8. ref9. rows ☆10. filtered11. Extra ☆12. 小结 7. EXPLAIN的进一步使用7.1 EXPLAIN四种输出格式1. 传统格式2. JSON格式3. TREE格式4. 可视化输出 7.2 SHOW WARNINGS的使用 8. 分析优化器执行计划：trace9. MySQL监控分析视图-sys schema9.1 Sys schema视图摘要9.2 Sys schema视图使用场景 1. 数据库服务器的优化步骤 当我们遇到数据库调优问题的时候，该如何思考呢？这里把思考的流程整理成下面这张图。
整个流程划分成了观察（Show status）和行动（Action）两个部分。字母 S 的部分代表观察（会使用相应的分析工具），字母 A 代表的部分是行动（对应分析可以采取的行动）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9857d7951c789f90b99dd14278618268/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bf9b88e1459bd8b602ac67bf8857c77/" rel="bookmark">
			【模板】割点（割边）Tarjan
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.割点 P3388 【模板】割点（割顶） - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)
其实跟强连通分量的Tarjan不太一样，但是基本思路还是差不多的。
首先，什么是割点：
在无向连通图中，如果将其中一个点以及所有连接该点的边去掉，图就不再连通，那么这个点就叫做割点（cut vertex / articulation point）。
其次，什么情况下一个点会是割点：
1. 求根节点的是否为割点，只要其有两棵或两棵以上子树，则为割点。
2. 叶节点都不是割点，所以只剩下要求非叶节点，若一非叶节点的子树的节点没有指向该点的祖先节点的回边，说明删除该点之后，该点的祖先节点与该点的子树不再连通，则说明该节点为割点。
第一点很好实现，只需要判断一个节点由两个子树即可。麻烦在第二点，也就是判断一个非叶节点的子节点没有超过根节点的回边，什么意思？也就是1-&gt;2-&gt;3-&gt;4。这条路径，以2为父节点，子节点3没有回到超过2的节点的回边。而这个可以用Tarjan算法判断，定义一个记录dfs顺序的dfn数组，和一个记录最早能回到的编号的数组low。
当子节点v最早可以回溯到超过父节点u的时候，也就是low[v]&lt;dfn[u]的时候则断开这个父节点，其他节点仍然可以由他的子节点通过所以当
low[v]&gt;=dfn[u]
时断开u，其他节点则无法通过子节点，形成断路，此时u为割点
#include &lt;bits/stdc++.h&gt; #include&lt;iostream&gt; #include&lt;thread&gt; using namespace std; #pragma warning(disable:4996); #define ll signed long long #define	int ll #define rep(j,b,e) for(register int j=b;j&lt;=e;j++) #define drep(j,e,b) for(register int j=(e);j&gt;=(b);j--) int T = 1; const int N = 5e5 + 10; const int mod = 10000; int n, m, k, q; template &lt;class T, class .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5bf9b88e1459bd8b602ac67bf8857c77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8ccc786081175320a07b46af44b68dc/" rel="bookmark">
			一些vim会用到的命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 cd /home进/home目录，cd …上一级，cd …/… 上两级， cd 个人主目录tree 目录树mkdir 创建目录mv dir1 new_dir 重命名一个目录， rm -rf dir1 删除目录和内容，rm -f dile 删除文件cp dir/* . 复制目录下的所有文件到当前目录， cp -a dir1 dir2 复制一个目录， cp -r dir1 dir2 复制一个目录和其子目录，cp -r dir1 dir2 表示将dir1及其dir1下所包含的文件复制到dir2下clear 清楚命令行gerp ‘hao’ t*,查找显示所有以t开头的文件中包含hao的行find . -name ‘test*’ 当前目录下查找文件名开头是字符串‘test’的文firefox xxx.html 打开网页 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f42041314b0f435354b02836fbeafda/" rel="bookmark">
			Python复习笔记5——常用模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、内建模块 1.1 datetime日期时间 （1）导入模块
from datetime import datetime 仅导入import datetime，则必须引用全名datetime.datetime
（2）获取日期时间
获取当前日期时间
&gt;&gt;&gt; now = datetime.now() # 获取当前datetime &gt;&gt;&gt; print(now) 2015-05-18 16:28:07.198690 获取指定日期时间
&gt;&gt;&gt; dt = datetime(2015, 4, 19, 12, 20) # 用指定日期时间创建datetime &gt;&gt;&gt; print(dt) 2015-04-19 12:20:00 （3）日期时间加减
加减可以直接用+和-运算符，不过需要导入timedelta这个类：
&gt;&gt;&gt; from datetime import datetime, timedelta &gt;&gt;&gt; now = datetime.now() &gt;&gt;&gt; now datetime.datetime(2015, 5, 18, 16, 57, 3, 540997) &gt;&gt;&gt; now + timedelta(hours=10) datetime.datetime(2015, 5, 19, 2, 57, 3, 540997) &gt;&gt;&gt; now - timedelta(days=1) datetime.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f42041314b0f435354b02836fbeafda/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a47b7337cae139130780bc12cfa3ece5/" rel="bookmark">
			linux重启mysql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux重启mysql的方法：
1、直接使用“service mysqld restart”或“service mysql restart”命令重启；
2、使用“/etc/init.d/mysqld restart”命令重启。
1、查看mysql版本
方法一：status;
方法二：select version();
2、Mysql启动、停止、重启常用命令
a、重启
1）、使用 service 启动：
1
2
service mysqld restart
service mysql restart (5.5.7版本命令)
2）、使用 mysqld 脚本启动：
1
/etc/init.d/mysqld restart
b、启动方式
1）、使用 service 启动：
1
2
[root@localhost /]# service mysqld start (5.0版本是mysqld)
[root@szxdb etc]# service mysql start (5.5.7版本是mysql)
2）、使用 mysqld 脚本启动：
1
/etc/inint.d/mysqld start
3）、使用 safe_mysqld 启动：
1
safe_mysqld&amp;
相关视频推荐：《Linux视频教程》
c、停止
1）、使用 service 启动：
1
service mysqld stop
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a47b7337cae139130780bc12cfa3ece5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dd103091ce7b56db0f3295206239cc4/" rel="bookmark">
			Linux中的fork()和clone()函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址：https://blog.csdn.net/qq_42837885/article/details/101950162
fork函数 在linux中fork函数是非常重要的函数，它从已存在进程中创建一个新进程。新进程为子进程，而原进程为父进程。
#include &lt;unistd.h&gt; pid_t fork(void); 返回值：
子进程中返回0父进程返回子进程id出错返回-1 那么为什么要这样设返回值呢？
将子进程id返回给父进程：原因很简单，一个父亲可以有多个儿子，所以儿子很容易就能找到父亲(调用getppid())，但父亲很难找到所有的儿子,没有一个函数使一个进程可以获得所有子进程的Id。 进程调用fork，当控制转移到内核中的fork代码后，内核做：
分配新的内存块和内核数据结构给子进程将父进程部分数据结构内容拷贝至子进程添加子进程到系统进程列表当中fork返回，开始调度器调度 当一个进程调用fork之后，就有两个二进制代码相同的进程。而且它们都运行到相同的地方。但每个进程都将可以开始它们自己的旅程。
int main() { int i; for(i=0;i&lt;2;i++) { if(fork()==0) { printf("A\n"); } else { printf("B\n"); } } } fork 之后会产生父子进程，相当于父进程拷贝了一份给子进程，其中包括缓冲区中的数据。对于fork之后的代码会继续执行.。所以结果是三个A,三个B。
int main() { int i; for(i=0;i&lt;2;i++) { if(fork()==0) { printf("A"); } else { printf("B"); } } } fork之后，i=0，产生父子进程，没有遇到\n，程序也没有结束，那么父进程得到的A和子进程得到的B都会在缓冲区先呆着，i=1时，又fork一次，父子进程会把自己的在拷贝一份给他们各自的子进程，那么拷贝的时候就包含了呆在缓冲区里的东西，所以i=2，程序结束，输出缓冲区里的东西，就是4个A，4个Bfork之后父子进程谁先执行完全由调度器来决定。注意： 第二个代码中的printf 语句中没有了\n,这涉及到printf输出缓冲区的问题，缓冲区中的数据只有在以下几种可能会输出： ① 遇到\n② fflush(stdout)刷新缓冲区③程序结束（exit或return）④ 缓冲区满。（注意：_exit 程序结束时不刷新缓冲区） 写时拷贝 通常，父子代码共享，父子再不写入时，数据也是共享的，当任意一方试图写入，便以写时拷贝的方式各自一份副本。（类似C++String类中的写时拷贝）
fork常规用法 一个父进程希望复制自己，使父子进程同时执行不同的代码段。例如，父进程等待客户端请求，生成子进程来处理请求。一个进程要执行一个不同的程序。例如子进程从fork返回后，调用exec函数。 fork调用失败的原因 系统中有太多的进程实际用户的进程数超过了限制 clone函数 clone是Linux为创建线程设计的（虽然也可以用clone创建进程）。所以可以说clone是fork的升级版本，不仅可以创建进程或者线程，还可以指定创建新的命名空间（namespace）、有选择的继承父进程的内存、甚至可以将创建出来的进程变成父进程的兄弟进程等等。clone函数功能强大，带了众多参数，它提供了一个非常灵活自由的常见进程的方法。因此由他创建的进程要复杂。clone可以让你有选择性的继承父进程的资源，你可以和父进程共享一个虚存空间，从而使创造的是线程，你也可以不和父进程共享，你甚至可以选择创造出来的进程和父进程不再是父子关系，而是兄弟关系。 int clone(int (*fn)(void *), void *child_stack, int flags, void *arg); fn为函数指针，此指针指向一个函数体，即想要创建进程的静态程序（我们知道进程的4要素，这个就是指向程序的指针，就是所谓的“剧本"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2dd103091ce7b56db0f3295206239cc4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cbc92003f334281112a7a77f6a7a1b8/" rel="bookmark">
			解决vue和vuex安装版本冲突,npm ERR! ERESOLVE unable to resolve dependency tree
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先看看在vue中安装vuex版本冲突时的报错
npm ERR! code ERESOLVE npm ERR! ERESOLVE unable to resolve dependency tree npm ERR! npm ERR! Found: vue@2.7.8 npm ERR! node_modules/vue npm ERR! vue@"^2.6.14" from the root project npm ERR! npm ERR! Could not resolve dependency: npm ERR! peer vue@"^3.0.2" from vuex@4.0.2 npm ERR! node_modules/vuex npm ERR! vuex@"*" from the root project npm ERR! npm ERR! Fix the upstream dependency conflict, or retry npm ERR! this command with --force, or --legacy-peer-deps npm ERR!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cbc92003f334281112a7a77f6a7a1b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfb5295ec78661deb62438b9534a4c12/" rel="bookmark">
			ssh连接Centos7时vim无法使用粘贴板原因及解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原因：
1.命令行的vim没有+和*两个寄存器（原因之一），退出vim后粘贴板内容不会保留到vim所在系统的粘贴板
2.在有+和*寄存器的前提下，可以从vim复制到vim所在系统的粘贴板，但是ssh没有转发服务，如果使用ssh登录，可以从ssh客户端所在系统的粘贴板复制到vim，无法从vim复制到ssh客户端所在系统的粘贴板。
第二个原因有点绕，但其实很好理解，因为ssh并没有转发系统粘贴板的服务，因此就算可以从远端系统的vim中复制内容到远端系统的系统粘贴板，但无法将内容传递过来，部分ssh客户端支持抓取粘贴板内容的除外。
解决方法：
1.确认远端vim支持复制内容到远端系统粘贴板的情况下，选择使用支持粘贴板抓取的ssh客户端。
2.使用x11 forwarding
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46dfc8df1ccd0aae710c593c0755f8a6/" rel="bookmark">
			Your idea evaluation has expired. Your session will be limited to 30 minutes
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		您的idea评估已过期。您的会话将被限制在 30 分钟。解决方法如下，
在idea中安装插件idea eval Reset即可
下载链接如下：
https://blog.csdn.net/qq_38423256/article/details/124491131
点击ok就完事了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/409cb5725734090ce28d4a2df810c536/" rel="bookmark">
			nginx的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.何为nginx
2.如何使用
3.关于nginx配置文件
4.nginx三大核心
4.1 反向代理
4.2 负载均衡
4.3 动静分离
4.4 高可用
4.4.1 安装keepalived
代理服务器--使用比较多的为nginx代理服务器。
1.何为nginx Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器,其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好。开源软件,服务器软件.能够支持高达 50,000 个并发连接数的响应。
2.如何使用 (1) 安装nginx软件所需的依赖插件
yum install -y gcc-c++
yum install -y pcre pcre-devel
yum install -y zlib zlib-devel
yum install -y openssl openssl-devel
(2) 把我们的nginx安装包上传到linux中并解压
(3) 创建一个目录作为nginx的安装目录
mkdir /usr/nginx
(4) 进入nginx的解压目录
(5) 设置nginx的安装路径为上面/usr/nginx
(6) 编译--安装
make
make install ---安装
conf: 配置目录
html: 放置静态资源的。
logs: 日志
sbin: 启动和关闭nginx的脚本
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/409cb5725734090ce28d4a2df810c536/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7c0ad3fe585a2de4fce11142f3a03f6/" rel="bookmark">
			YOLOv5在验证集上进行测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 今天想在验证集上测试模型的mAP，但翻遍了整个项目目录并没有找到val.py，这就很奇怪
经过在Github上yolov5的原项目中查找，发现作者在2021年7月14日已经将test.py更名为val.py
这样就已经确定是自己的yolov5的版本较低，仍采用的是test.py（v6.0的版本就更新为val.py了），但是在验证集上进行测试还是没有问题的
步骤 1.修改配置文件 打开test.py文件，下拉至最后的主函数部分，将模型权重文件以及数据集配置文件更换为自己的
2.运行 更改好之后就可以直接运行了，若不想修改配置文件，直接在命令行输入以下代码也是可以的，注意替换文件名即可
$ python test.py --weights yolov5s.pt --data coco128.yaml 3.查看结果 运行结束后的结果会保存至run/test/文件夹下，其中包括confusion_matrix（混淆矩阵）等文件，mAP信息也可以找到，这样就算大功告成了
总结 1.在yolov5-6.0的版本中，test.py就已经被重命名为val.py，作者解释其原因是为了避免将来与 python包发生任何冲突和歧义。
2.推荐使用最新版的yolov5，使用起来更顺手一点，而且新版的yolov5以及可以导出更多的种类的模型进行使用，详情可看新版本中的export.py文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c864d7bd62706197d8edad7373afaac/" rel="bookmark">
			YOLOv5学习过程中的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		YOLOv5学习过程中的问题 学习博客链接：目标检测–手把手教你搭建自己的YOLOv5目标检测平台
问题1 在安装requirements时出现下述错误
ERROR: Could not build wheels for pycocotools, which is required to install pyproject.toml-based projects 解决方式：在requirements.txt文件中将pycocotools&gt;=2.0 修改为pycocotools-windows&gt;=2.0
原因：pycocotools的维护者不再提供Windows平台的支持
问题2 在运行train.py文件进行运行时出现以下错误
AssertionError: Image Not Found D:\PycharmProjects\yolov5-hat\VOCdevkit\images\train\000000 解决方式：删除存放标签目录下的train.cache和val.cache文件
原因：训练时会默认使用原有的缓存文件进行训练，由于训练集绝对路径已经更改，所以要对其进行删除，避免继续加载原有路径
问题3 最后一步训练出现
RuntimeError: result type Float can‘t be cast to the desired output type __int64 解决方式：找到5.0版报错的loss.py中最后那段for函数，将其整体替换为yolov5-master版中loss.py最后一段for函数即可正常运行
for i in range(self.nl): anchors, shape = self.anchors[i], p[i].shape gain[2:6] = torch.tensor(shape)[[3, 2, 3, 2]] # xyxy gain # Match targets to anchors t = targets * gain # shape(3,n,7) if nt: # Matches r = t[.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c864d7bd62706197d8edad7373afaac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a880988bca430b56278482b220e1dfb0/" rel="bookmark">
			若依系统不分离版框架Mysql更换SqlServer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：最近下载开源项目若依ruoyi，将其更数据库Mysql更换SqlServer的一些注意事项，与君分享。
1、数据库安装
使用SSMA将mysql迁移至mssql,参考这两个文档
MySQL数据库迁移到SQL Server----------SSMA(SQL Server Migration Assistant for MySQL)工具安装及使用_weixin_39921737的博客-CSDN博客_ssma安装
ssma for mysql_SSMA for MySQL_weixin_39926193的博客-CSDN博客
若依的数据库脚本是mysql，先用navcate创建一个名为dbo的数据库。（名称最好是dbo，如果数据库名为 ruoyi，迁移到mssql后表名称为 ruoyi.sys_dept）
运行这两个脚本，创建表
参考上述文档，将在mysql中建好的表，迁移到sql server2016中
2、参考文章，修改后台代码
ruoyi（若依）系统使用SqlServer数据库_op4439的博客-CSDN博客_若依数据库
一、ruoyi-admin 中pom.xml 添加mssql驱动
&lt;!--mssql驱动包--&gt; &lt;dependency&gt; &lt;groupId&gt;com.microsoft.sqlserver&lt;/groupId&gt; &lt;artifactId&gt;mssql-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; 二、数据库配置文件修改
spring: datasource: type: com.alibaba.druid.pool.DruidDataSource driverClassName: com.microsoft.sqlserver.jdbc.SQLServerDriver druid: # 主库数据源 master: url: jdbc:sqlserver://localhost:1433;DatabaseName=ry username: sa password: 你的密码 1、配置检测连接是否有效如下：
2、分页插件配置如下：
三、代码部分修改
1、定时任务配置ScheduleConfig类设置sqlserver 启用配置，这个原文件注释了，暂不修改。
2、SQL语句函数修改，用IDEA功能 Find in files 全局检索修改。
ifnull() 改 isnull()find_in_set 修改，下面两处，在SysDeptMapper &lt;select id="selectChildrenDeptById" parameterType="Long" resultMap="SysDeptResult"&gt; select * from sys_dept where charindex (',' + CONVERT (VARCHAR, #{deptId}), ',' + ancestors) &gt; 0 &lt;/select&gt; &lt;select id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a880988bca430b56278482b220e1dfb0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab475d0bfbca50977afdcb0279ec0439/" rel="bookmark">
			一些关于三角函数的公式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 正弦函数反正弦函数余弦函数反余弦函数正切函数反正切函数余切函数反余切函数补充 正弦函数 y = s i n x y=sinx y=sinx
反正弦函数 y = a r c s i n x y=arcsinx y=arcsinx
取正弦函数y=sinx的单调递增区间[-Π/2，Π/2]，此时y=sinx的值域为[-1,1];
构造反函数，y=arcsinx的值域为[-Π/2，Π/2]，y=arcsinx的定义域为[-1,1];
余弦函数 y = c o s x y=cosx y=cosx
反余弦函数 y = a r c c o s x y=arccosx y=arccosx
取正弦函数y=cosx的单调递减区间[0，Π]，此时y=cosx的值域为[-1,1];
构造反函数，y=arccosx的值域为[0，Π]，y=arccosx的定义域为[-1,1];
正切函数 y = t a n x = s i n x / c o s x ( x ≠ Π / 2 + k Π ， k ∈ Z ) y=tanx=sinx/cosx(x≠Π/2+kΠ，k∈Z) y=tanx=sinx/cosx(x=Π/2+kΠ，k∈Z)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab475d0bfbca50977afdcb0279ec0439/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f6cbaedcd0aae820db06a3678295f82/" rel="bookmark">
			Jquery中的$(document).ready()详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.$(document).ready()的作用 $(document).ready(function(){.... })这个函数的作用和window.onload差不多，不同的是
（1）onload()的方法是在页面加载完成后才发生，这包括DOM元素和其他页面元素（例如图片）的加载
（2）$(document).ready()所要执行的代码是在DOM元素被加载完成的情况下执行，所以，使用document.ready()方法的执行速度比onload()的方法要快。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93a388267426960c7ad3a9e00ad848dc/" rel="bookmark">
			selenium打开网页被检测，怎么屏蔽和绕过
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Selenium 操作被检测屏蔽 selenium打开浏览器模仿人工操作是诸多爬虫小白最万能的网页数据获取方式，但是在做自动化爬虫时，经常被检测到是selenium驱动。前段时间selenium打开维普高级搜索时得到的页面是空白页。
Selenium为何会被检测 主要原因是selenium打开的浏览器指纹和人工操作打开的浏览器指纹是不同的，比如最熟知的window.navigator.webdriver关键字，在selenium打开的浏览器打印返回结果为true，而正常浏览器打印结果返回为undefined，我们可以在
网站比较各关键字。
Selenium防检测方法 1. 修改window.navigator.webdriver关键字返回结果 from selenium import webdriver options = webdriver.ChromeOptions() # 此步骤很重要，设置为开发者模式，防止被各大网站识别出来使用了Selenium driver = webdriver.Chrome(options=options) driver.execute_cdp_cmd("Page.addScriptToEvaluateOnNewDocument", { "source": """ Object.defineProperty(navigator, 'webdriver', { get: () =&gt; undefined }) """ }) 但是因为浏览器指纹很多，这种方法的局限性是显而易见的。
2. 使用stealth.min.js文件防止selenium被检测 import time from selenium.webdriver import Chrome from selenium.webdriver.chrome.options import Options chrome_options = Options() chrome_options.add_argument("--headless") chrome_options.add_argument('user-agent=Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.198 Safari/537.36') driver = Chrome('./chromedriver', options=chrome_options) with open('/Users/kingname/test_pyppeteer/stealth.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93a388267426960c7ad3a9e00ad848dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4a969ee430e2b4e6bd722b354eee141/" rel="bookmark">
			Vue中如何获取滚动条滚动的距离
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.先在App组件中定义一个获取滚动条距离的方法,方法名称是handleScroll
methods:{ handleScroll() { let top = Math.floor(document.documentElement.scrollTop || document.body.scrollTop); console.log(top); }, } 2.然后在mounted中，设置监听事件
mounted() { window.addEventListener("scroll", this.handleScroll); }, 3.实现最终效果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c4674b4f878ad01bc7039cfa798fa7d/" rel="bookmark">
			Python复习笔记4——文件和目录操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、文件读写 1.1 读文件 （1）打开文件
使用Python内置的open()函数，传入文件名和标示符，打开一个文件对象：
&gt;&gt;&gt; import os &gt;&gt;&gt; f = open('/Users/michael/test.txt', 'r') 标示符'r'表示读，这样，我们就成功地打开了一个文件。
Python引入了with语句来避免程序出错：
with open('/path/to/file', 'r') as f: print(f.read()) 上面的代码相当于：
try: f = open('/path/to/file', 'r') print(f.read()) finally: if f: f.close() （2）读文件内容
方法作用read()一次读取文件的全部内容read(size)每次最多读取size个字节的内容readline()每次读取一行内容readlines()一次读取所有内容并按行返回 （3）关闭文件
调用close()方法关闭文件。文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源。
&gt;&gt;&gt; f.close() （4）读取其它编码格式文件
要读取二进制文件，比如图片、视频等等，用'rb'模式打开文件即可：
&gt;&gt;&gt; f = open('/Users/michael/test.jpg', 'rb') &gt;&gt;&gt; f.read() b'\xff\xd8\xff\xe1\x00\x18Exif\x00\x00...' # 十六进制表示的字节 要读取非UTF-8编码的文本文件，需要给open()函数传入encoding参数，例如，读取GBK编码的文件：
&gt;&gt; f = open('/Users/michael/gbk.txt', 'r', encoding='gbk') &gt;&gt;&gt; f.read() '测试' 1.2 写文件 调用open()，传入标识符'w'或者'wb'表示写文本文件或写二进制文件：
&gt;&gt;&gt; f = open('/Users/michael/test.txt', 'w') &gt;&gt;&gt; f.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c4674b4f878ad01bc7039cfa798fa7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d37341029a8aeee934dd90e42974a74/" rel="bookmark">
			linux环境文件或者文件夹打包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、linux zip压缩 压缩当前文件夹下所有文件，压缩为a.zip。命令行的方法是怎样。
常用格式： zip -r fileName.zip 文件夹名 （1）把/home目录下面的data目录压缩为data.zip
zip -r data.zip data #压缩data目录 （2）把/home目录下面的data.zip解压到databak目录里面
unzip data.zip -d databak （3） 覆盖源路径解压
unzip -o healthcode-catch.zip -d disaster-recovery （4）把/home目录下面的a文件夹和3.txt压缩成为a123.zip
zip -r a123.zip a 3.txt （5）把/home目录下面的t.zip直接解压到/home目录里面
unzip t.zip （6）把/home目录下面的a1.zip、a2.zip、a3.zip同时解压到/home目录里面
unzip a*.zip （7）把/home目录下面w.zip里面的所有文件解压到第一级目录
unzip -j wt.zip 2、linux tar压缩 （1）tar命令格式：
下面五个参数是独立的，压缩解压都要用到其中一个，可以和下面的命令连用但只能用其中一个。 -c: 建立压缩档案（创建一个新的tar文件） -x：解压 -t：查看内容 -r：向压缩归档文件末尾追加文件 -u：更新原压缩包中的文件 下面的参数是根据需要在压缩或解压档案时可选的。 -z：使用gzip压缩它 -j：有bz2属性的 -Z：有compress属性的 -v：详细，显示要压缩或解压缩的文件 -O：将文件解开到标准输出 -p ：使用原文件的原来属性（属性不会依据使用者而变） 参数-f是必须的。 -f: 以提供的文件名作为参数创建tar文件 （2）tar命令可以用来压缩打包单文件、多个文件、单个目录、多个目录。
常用格式： 单个文件压缩打包 tar czvf my.tar file1 多个文件压缩打包 tar czvf my.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d37341029a8aeee934dd90e42974a74/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94bff30630125c531e289f04ee488c79/" rel="bookmark">
			python扁平化处理嵌套序列的好办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 大佬写的“拍扁”算法，值的收藏一下~ from collections import Iterable def flatten(items, ignore_types=(str, bytes)): for x in items: if isinstance(x, Iterable) and not isinstance(x, ignore_types): yield from flatten(x) else: yield x items = [1, 2, [3, 4, [5, 6], 7], 8] # Produces 1 2 3 4 5 6 7 8 for x in flatten(items): print(x) items = ['Dave', 'Paula', ['Thomas', 'Lewis']] for x in flatten(items): print(x) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88e32de43fcfcca48415bccab45da712/" rel="bookmark">
			python连乘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		∏，这个像门框一样的数学符号表示连乘，读音和圆周率π相同。
python中实现相同功能的方法
from functools import reduce from collections import Iterable def pi(value: Iterable): if not isinstance(value, Iterable): return False, '参数不是可迭代对象' is_num = all(type(e) in (int, float) for e in value) if not is_num: return False, '参数包含非数字值' result = reduce(lambda x, y: x*y, value) return True, result 主要函数解释：
isinstance：判断某个值是否是某种类型
all：逻辑判断，全部为真才为真，有一项为假则为假
reduce："辗转"处理，处理函数自定义
lambda：匿名函数，没有函数名的定义方法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39823e96fbbbb95c9b5e7454a31a51a0/" rel="bookmark">
			Java学习路线图（完整详细2021版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为一个男人我感觉必须得做点什么来证明一下自己，现在我又回来了，准备把自己的节操准备补一下
另外给各位未来的Java程序员说一句，别的我不清楚，学习编程请从一而终
咱们学习编程就挺难的，有这些先驱者来带领咱们学习，咱们应该感激，而且最重要的事跟着你选定的一家一直学下去
因为每家学校的学习大纲都是不一样的，但是程序员其实都是一样的，这句话你细品！仔细的品！
我不希望你忙忙碌碌的整理那么多东西，挑肥拣瘦的，最后自己学的东西还是缺失的，要不就是事倍功半，挺累的…
好了废话不多说了，开始今天的正题，学习编程干就完了！！！
注----本次学习路线图中会插一些B站的视频资源，源码、资料啥的直接去他们官网下载------
（网盘容易失效所以就不放网盘了）
Java零基础
推荐教程：
1、Java小白学习指南
https://www.bilibili.com/video/BV1wv411B7q3
2、Java零基础
https://www.bilibili.com/video/BV1Rx411876f
数据库
推荐教程：
1、MySQL数据库
https://www.bilibili.com/video/BV1fx411X7BD
2、JDBC
https://www.bilibili.com/video/BV1Bt41137iB
3、Oracle（有兴趣的可以学习一下）
https://www.bilibili.com/video/BV1kx411s71n
Web前端
教程链接：
1、HTML
https://www.bilibili.com/video/BV11t411K74Q
2、CSS
https://www.bilibili.com/video/BV1tt411M7Vj
3、JavaScript
https://www.bilibili.com/video/BV1Ft411N7R3
JavaWeb
教程链接：
1、JavaWeb【IDEA版本】
https://www.bilibili.com/video/BV1Yz411B7Pk
2、JavaWeb【Eclipse经典版】
https://www.bilibili.com/video/BV1Yz411B7Pk
Web进阶
教程链接：
1、AJAX
https://www.bilibili.com/video/BV15k4y167XM
2、jQuery
https://www.bilibili.com/video/BV1Jg4y1B7n4
JavaWEB项目实战
教程链接：
1、SVN（路线图里没有写，但是我还是推荐，学习项目之前先看这个）
https://www.bilibili.com/video/BV1ux411j7H2
2、EGOV项目（电子政务系统）路线图里没有但是感觉这个项目讲的真的很好就推荐了
https://www.bilibili.com/video/BV194411c7SL
3、JDK动态代{过}{滤}理（学习CRM项目之前先看这个）
https://www.bilibili.com/video/BV1HZ4y1p7F1
4、Maven入门（这个学习项目必须提前要学习）
https://www.bilibili.com/video/BV1dp4y1Q7Hf
5、CRM项目实战（学习之前建议先看看mybatis）
https://www.bilibili.com/video/BV1fT4y1E7a6
6、Linux
https://www.bilibili.com/video/BV1Li4y1V7pG
后端框架
教程链接：
1、Mybatis【IDEA版】
https://www.bilibili.com/video/BV185411s7Ry
2、Spring【IDEA版】
https://www.bilibili.com/video/BV1nz4y1d7uy
3、SpringMVC【IDEA版】
https://www.bilibili.com/video/BV1sk4y167pD
4、典藏版SSM（Eclipse全套）
https://www.bilibili.com/video/BV1Ug4y1i7W7
5、SSH框架全套【如果有时间的话可以选择性的学习一下】
https://www.bilibili.com/video/BV1uT4y1g7Qo
高端技术
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39823e96fbbbb95c9b5e7454a31a51a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfff8e549251aa64886f534998fc9ca3/" rel="bookmark">
			HTML标题标签（h1~6）用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很简单，直接上代码：
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=&lt;device-width&gt;, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;这是一级标题&lt;/h1&gt; &lt;h2&gt;这是二级标题&lt;/h2&gt; &lt;h3&gt;这是三级标题&lt;/h3&gt; &lt;h4&gt;这是4级标题&lt;/h4&gt; &lt;h5&gt;这是5级标题&lt;/h5&gt; &lt;h6&gt;这是6级标题&lt;/h6&gt; &lt;/body&gt; &lt;/html&gt; 效果如图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a956d53c5351db4a136dd5d48587955b/" rel="bookmark">
			一文让你快速写上扫雷游戏！童年的经典游戏，发给你的小女友让你装一波！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#引入头文件 #pragma once #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; #define ROW 9 #define COL 9 #define ROWS ROW+2 #define COLS COL+2 #define EASY_COUNT 10 //初始化棋盘 void init_board(char board[ROWS][COLS], int rows, int cols, char set); //打印棋盘 void display_board(char board[ROWS][COLS], int row, int col); //布置雷 void set_mine(char mine[ROWS][COLS], int row, int col); //排查雷 void find_mine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col); 0.制作游戏菜单 void menu() { printf("************1. play************\n"); printf("************0. exit************\n"); } 效果图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a956d53c5351db4a136dd5d48587955b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66c062289187480f1a8cde729f734ea1/" rel="bookmark">
			vue中indexDb缓存使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、在main.js中引用indexDb import Vue from 'vue' import indexDb from './api/indexDb' let storeName = { index: ['tableView'], name: 'tableView', key: 'menuid' } //index:索引、name:表名、key:主键 indexDb.openDB('spreadTableView', 1, storeName, function(db){ Vue.prototype.$tableDb = db //全局保存数据库 }) 2、操作数据库方法 //举例，业务代码 ... &lt;script&gt; import indexDb from './api/indexDb' ... export default { ... mounted(){ let list = [{...}] let allDbData = indexDb.getAllData(this.$tableDb, 'tableView') let flagIndex = indexDb.readAllData(this.$tableDb, list) if(flagIndex == -1){ indexDb.addData(this.$tableDb, 'tableView', list) }else{ indexDb.updateData(this.$tableDb, 'tableView', list) } } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66c062289187480f1a8cde729f734ea1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbd7a9e2338de31b787f4c305d5044f4/" rel="bookmark">
			Win10平台上卸载百度网盘插件YunShellExt64.dll
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.问题描述
百度网盘将该dll注入到explorer进程，导致用户卸载百度网盘后，任然无法删除该文件。
2.解决办法
首先修改文件名，建议通过需改文件后缀方式实现；然后在任务管理器中重启explorer进程；最后删除该文件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec1ab0e2c2bb3e73ee2faf91ace50990/" rel="bookmark">
			ESXI中安装windows2019&#43;NVIDIA-GRID-VGPU后VmwareWorkstation访问该虚拟机黑屏问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.原因分析
出现该问题的原因是安装vgpu驱动后，会创建新的desktop，系统启动时默认进入新创建的desktop。
2.解决方案
在目标系统中安装向日葵客户端，然后再安装vgpu驱动。通过向日葵客户端远程访问目标系统，然后修改系统设置中的多屏显示，设置为只允许在一个屏幕中显示（注意不要选择虚拟桌面）；最后重启系统即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/247674a5b290ebe94b486ff631f7223a/" rel="bookmark">
			在Win10平台上搭建AI训练（英伟达GPU加速）环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.环境
版本 Windows 10 企业版
版本号 21H2
安装日期 ‎2022/‎3/‎13
操作系统内部版本 19044.1826
体验 Windows Feature Experience Pack 120.2212.4180.0
2.搭建GPU加速环境
a.确定主机显卡驱动版本：在“NVIDIA控制面板”→“系统属性”查看显卡驱动版本
b.确定显卡驱动支持CUDA版本（网上有人说显卡驱动中给出的CUDA版本是此版本显卡驱动能支持的最高CUDA版本）
c. 通过nvidia官网（Release Notes :: CUDA Toolkit Documentation ）确定系统所安装显卡驱动支持最高CUDA版本
Table 2. CUDA Toolkit and Minimum Required Driver Version for CUDA Minor Version Compatibility
CUDA ToolkitMinimum Required Driver Version for CUDA Minor Version Compatibility*Linux x86_64 Driver VersionLinux AArch64 Driver VersionWindows x86_64 Driver VersionCUDA 11.7.x &gt;=450.80.02 &gt;=452.39CUDA 11.6.xCUDA 11.5.xCUDA 11.4.xCUDA 11.3.xCUDA 11.2.xCUDA 11.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/247674a5b290ebe94b486ff631f7223a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16e3610b4563ae143b9caa38ae08f6f0/" rel="bookmark">
			gee引擎修改UI界面图文教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多客户在搭建GOM引擎或者GEE的引擎的时候需要读取皮肤文件，但是皮肤有logo或者网址需要替换图片的话就需要下面这个教程了
下图我是用GEE引擎做做范例，GOM引擎也大同小异。请参考
1、首先打开GEE登录器生成器MakeGameLogin.exe，然后点击登录器皮肤编辑
2、打开GEE登录器皮肤编辑对话框之后点击打开我们想要修改的皮肤文件.geeskin
3、在右侧随便点击一个空白的地方左边就会出现背景图片的属性编辑器
4、点击下方图片（TPicture）旁边的...三个点，出来的就是picture editor对话
框、我们先来属性下这个对话框各个按钮的名字意思和作用
load picture 加载图片 save picture as 将图片保存为到另存为
clear 清除图片
cancel 取消
OK 确认
5、先点击save...按钮把皮肤里面的图片导出PNG格式放到桌面，然后用工具修改
好图片之后再点击load...按钮讲修改好的图片导入进来，点击OK框，
6、最后在将左上角的另存为到电脑即可，格式为.geeskin
好了 皮肤的背景图片就修改好了
很多客户在搭建GOM引擎或者GEE的引擎的时候需要读取皮肤文件，但是皮肤有logo或者网址需要替换图片的话就需要下面这个教程了
下图我是用GEE引擎做做范例，GOM引擎也大同小异。请参考
1、首先打开GEE登录器生成器MakeGameLogin.exe，然后点击登录器皮肤编辑
2、打开GEE登录器皮肤编辑对话框之后点击打开我们想要修改的皮肤文件.geeskin
3、在右侧随便点击一个空白的地方左边就会出现背景图片的属性编辑器
4、点击下方图片（TPicture）旁边的...三个点，出来的就是picture editor对话
框、我们先来属性下这个对话框各个按钮的名字意思和作用
load picture 加载图片 save picture as 将图片保存为到另存为
clear 清除图片
cancel 取消
OK 确认
5、先点击save...按钮把皮肤里面的图片导出PNG格式放到桌面，然后用工具修改
好图片之后再点击load...按钮讲修改好的图片导入进来，点击OK框，
6、最后在将左上角的另存为到电脑即可，格式为.geeskin
好了 皮肤的背景图片就修改好了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4271f663a23efaa2a11f0caa9872500e/" rel="bookmark">
			【Maven】Malformed \uxxxx encoding.报错解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Malformed \uxxxx encoding.报错解决 1. 在pom.xml文件中添加： &lt;properties&gt; &lt;java.version&gt;18&lt;/java.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;maven.compiler.encoding&gt;UTF-8&lt;/maven.compiler.encoding&gt; &lt;maven.compiler.source&gt;18&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;18&lt;/maven.compiler.target&gt; &lt;commons.version&gt;1.1.1-SNAPSHOT&lt;/commons.version&gt; &lt;/properties&gt; 注意自己的java版本写对！
2. 删掉后缀为.lastupdated的文件（如果报错依赖包下载不了的话） 一般下载不成功的依赖，都会生成一个后缀为.lastupdated的文件，而且有这个文件一旦生成，那个依赖就会一直下载不成功，无论怎么reload maven 仓库，都下载不成功。
3. 全局搜索resolver-status.properties 文件，报错期间生成的全删了 OK！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32654ed09d739d9eafea35f39b880ecf/" rel="bookmark">
			移动通信——基于卷积码的差错控制系统仿真模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要 信道编码是数字通信系统中的重要组成部分, 它是保证信号可靠传输的一种重要方式。卷积码以其优越的性能被广泛使用在数字通信系统中。本次现代无线通信大作业主要应用 SIMULINK 设计出基于卷积码的差错控制系统仿真模型，
并通过 MATLAB 对系统进行性能仿真分析。解决对一个卷积码序列进行维特比 (Viterbi) 译码输出, 分别从卷积编码软判决和卷积编码硬判决以及无编码三种情况下仿真控制系统的误码率情况，以 BPSK 调制方式为例，并通过搭建 simulink 模块协同 Matlab 脚本编写进行设计与仿真，并进行误码率分析。采用加性高斯白噪声信道，采用 BPSK 解调并分别用软决策和硬决策下的维特比译码，利用 MATLAB 协同 simulink 对决策方式、卷积编码效率、维特比译码回溯深度自动调参，研究其在不同信噪比下维特比译码的误比特率关系，通过曲线图得出仿真与理论分析一致。
卷积码（convolutional code）是由伊莱亚
斯 (P.Elias) 于 1954 年首先提出的一种非分组码。通
常它更适用于前向纠错，因为对于许多实际情况它
的性能优于分组码，而且运算较简单。无论从理论
上还是实际上均已证明其性能优于线性分组码。卷
积码在通信系统中的广泛应用卷积码是一种性能
优越的信道编码，它的编码器和译码器都比较容易
实现，同时也具有较强的纠错能力，随着纠错编码
理论研究的不断深入，卷积码的实际应用越来越广
泛。本次现代无线通信大作业选择应用 SIMULINK
设计出基于卷积码的差错控制系统仿真模型，并通
过 MATLAB 对系统进行性能仿真分析。模型包括
信源部分、信道部分和信宿部分，信源部分的数据
源是随机的二进制序列，随机的二进制序列要经过
卷积编码，经过编码的数据要进行调制。信道部分
对调制后的信号进行加噪，采用加性高斯白噪声。
信宿部分完成信号的解调和译码（维特比译码）。
通过此次设计便于了解各模块的功能，各参数的意
义；并分析不同信噪比下维特比译码的误比特率关
系曲线图，加深对特比译码原理和卷积码译码的理
解。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9560d393d4192b9a12a743ad65026d12/" rel="bookmark">
			站在巨人的肩上，基于Java8手写本地缓存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		站在巨人的肩上，基于Java8手写本地缓存 文章目录 站在巨人的肩上，基于Java8手写本地缓存0、写在最前面1、缓存类具备的功能2、创建缓存类3、添加键值对方法4、根据 key 获取相应的value5、删除键值对6、处理已经失效的键值对7、基于java提供的Timer定时执行缓存类的失效监测处理方法8、CacheUtil 完整代码9、测试类10、测试结果如下11、项目下载地址 0、写在最前面 1、大多数业务场景下 ，为了提高系统的响应速度，使用缓存是最佳的选择；
2、由于本人工作性质特殊纯内网开发，在用maven导依赖无果后一气之下决定自己手写一个 简单的本地缓存来满足自己的业务需求
3、本文仅用于分享学习！！！
1、缓存类具备的功能 存储键值对 put()存储一定有效期的键值对 put()获取键值对 get()删除键值对 remove()定期清理过期的键值对 handleExpiredKeys() 项目目录结构如下：
2、创建缓存类 创建 CacheUtil.java 详细代码如下：
import java.util.concurrent.ConcurrentHashMap; /** * @author Negen * @date 2022年7月28日20:25:47 * @description 缓存工具类 */ public class CacheUtil { /** * 存储键值对 */ private ConcurrentHashMap&lt;String, Object&gt; cacheMap = null; /** * 存储键值对的有效时间 */ private ConcurrentHashMap&lt;String, Long&gt; expireMap = null; /** * 默认过期时间(毫秒 ) */ private final long DEFAULT_EXPIRE_TIME = 1000 * 3600 * 24 * 30; private static CacheUtil instance = null; public static CacheUtil getInstance(){ if (null == instance){ synchronized (CacheUtil.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9560d393d4192b9a12a743ad65026d12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26db6b2e4335071cdd09f3a452b3f7ed/" rel="bookmark">
			华清远见嵌入式学习每周汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		每周学习总结 第一周数据结构Makefile的编写顺序表链表（含约瑟夫环之选猴王）Joseph circle 本周总结 第二周栈队列树二叉树二叉树的创建 本周总结 IO进程标准IO2. 题目要求：编程读写一个文件test.txt，每隔1秒向文件中写入一行数据，类似这样： 第一周数据结构 Makefile的编写 搞明白Makefile是什么之前，先来了解一下make工具
1.make是工程管理器，顾名思义，是指管理较多的文件 Make工程管理器也就是个“自动编译管理器”，这里的“自动”是指它能构根据文件 时间戳 自动发现更新过的文件而 减少编译的工作量 ，同时，它通过读入Makefile文件中文件的内容来执行大量的编译工作。
2.make工具的作用当项目中包含多个c文件，但只对其中1个文件进行了修改，那用gcc编译会将所有的文件从头编译一遍，这样效率会非常低；所以通过make工具，可以查找到修改过的文件(通过时间戳)，只对修改过的文件进行编译，这样大大减少了编译时间，提高编译效率
3.Makefile是Make读入的唯一配置文件(有的编译器支持makefile也作为make读入的配置文件，但哥们才疏学浅不能保证哪个编译器支持，就统一Makefile得嘞。)
4.Makefile的编写格式
格式： 目标:依赖 命令 比如使用make工具编译add.c main.c生成可执行文件add的Makefile命令如下
add:add.o main.o//最终生成可执行文件add 最终目标要写在第一行 gcc add.o main.o -o add add.o:add.c gcc -c add.c -o add.o main.o：main.c gcc -c main.c -o main.o 但是如若是这样的格式，我们需要写在Makefile中的文件还是太多了，尤其是一个add.o要写三遍，那么后续几十个文件的程序单单写个Makefie不得小5分钟？make工具创作者当然也是想到了这样的情况，于是有了以下的通配符和变量的应用。
CC=gcc CFLAGS=-g -c -Wall -O OBJS=add.o main.o add:$(OBJS) $(CC) $(OBJS) -o $@ %.o:%.c $(CC) $(CFLAGS) $^ -o $@ PHONY:clean clean: rm *.o add #编译过程中生成的.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26db6b2e4335071cdd09f3a452b3f7ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cb5e4c1c274b49cf8865c194c6714f6/" rel="bookmark">
			Vuex详解，一文彻底搞懂Vuex
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.Vuex是什么？为什么要用它？ vuex官方解释 Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式 + 库。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。
大家可以思考一下，组件之间的传值有哪些？有父子通讯，兄弟组件通讯…但是传参对于多层嵌套就显得非常繁琐，代码维护也会非常麻烦。因此vuex就是把组件共享状态抽取出来以一个全局单例模式管理，把共享的数据函数放进vuex中，任何组件都可以进行使用。 二.什么时候我们该使用它？ Vuex 可以帮助我们管理共享状态，并附带了更多的概念和框架。这需要对短期和长期效益进行权衡。
如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 Vuex。一个简单的store 模式就足够您所需了。但是，如果您需要构建一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然的选择。
三.安装 方法一： 在脚手架 创建项目时勾选vuex的选项系统会自动创建
方法二：npm 或Yarn安装 npm install vuex@next --save yarn add vuex@next --save 四.配置 如果采用脚手架方式进行创建，无需任何操作，可以忽略此步骤
新建store文件-&gt;index.js，进行如下配置，在mian.js中进行引入
import Vue from 'vue' import Vuex from 'vuex' Vue.use(Vuex) export default new Vuex.Store({ //数据，相当于data state: { }, getters: { }, //里面定义方法，操作state方发 mutations: { }, // 操作异步操作mutation actions: { }, modules: { }, }) main.js中 五.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4cb5e4c1c274b49cf8865c194c6714f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9d15c43f1ef6bf4ec495dfbfda4249a/" rel="bookmark">
			uni-app：uni-icons的使用及如何自定义图标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方文档：https://uniapp.dcloud.io/component/uniui/uni-icons.html
uni-icons 已经收录了日常开发中常用的图标 ，但是因为体积问题 ，不可能一直无限添加新图标 ，所以uni-icons 也提供了扩展的方法。
使用 custom-prefix 和 type 属性自定义图标。
&lt;uni-icons custom-prefix="custom-icon" type="icon-youxi" size="30"&gt;&lt;/uni-icons&gt; fontClass 是图标的前缀 ，需要传入组件type属性（type属性前缀），fontFamily 是图标集名称，需要传入组件custom-prefix 属性，字体格式可以只勾选 ttf。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34447aae5dc524e0ad4ffc302057fced/" rel="bookmark">
			git：git push时error: src refspec main does not match any error报错解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基础命令： 参考：https://www.cnblogs.com/dyh-air/p/9257237.html
git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;
git push origin &lt;本地分支名&gt;
git push -u origin &lt;本地分支名&gt;:&lt;远程分支名&gt;
起因： 在我新建github远程仓库时，点了MIT协议。然后远程仓库里就有了一个LICENSELICENSE文件（这时本地仓库所没有的，也是第一个问题）。我想把本地的master分支push到远程的main分支。
远程仓库有一个默认主分支main，而本地的主分支名默认是master。这时，最开始push的时候，如果你用的命令是git push -u origin main，表示push本地的main分支，显然本地没有main分支（这是第二个问题）。
解决： 1.针对远程仓库存在本地没有的文件，如LICENSE文件：
首先执行git fetch origin 获取初始提交 然后执行git merge --allow-unrelated-histories origin/main合并远程仓库的文件
这篇文章讲的很详细 https://blog.csdn.net/gongdamrgao/article/details/115032436
2.git push -u origin master:main。这时就可以把本地的master分支push到远程的main分支
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/141/">«</a>
	<span class="pagination__item pagination__item--current">142/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/143/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>