<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47950e7412f16b6010017a82f9a737f6/" rel="bookmark">
			双重循环打印图形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 直角三角形菱形99乘法表99加法表冒泡排序 直角三角形 a="* " for i in range(0,5): # print(" " * (4-i), end="") for j in range (0,i+1): print(a,end="") print() a="* " for i in range(0,5): print(" " * (4-i), end="") for j in range (0,i+1): print(a,end="") print() a="* " for i in range(0,5): #print(" " * (4-i), end="") for j in range (0,5-i): print(a,end="") print() a="* " for i in range(0,5): print(" " * i, end="") for j in range (0,5-i): print(a,end="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47950e7412f16b6010017a82f9a737f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfcc130940a2542eb41d51dd0a5b5069/" rel="bookmark">
			keras调用model.load_weights()函数报错:AttributeError: ‘str‘ object has no attribute ‘decode‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Traceback (most recent call last):
File "C:/Users/Guangsheng Li/Desktop/Mask-RCNN-keras源码/mask-rcnn-keras-master/train.py", line 75, in &lt;module&gt;
model.load_weights(COCO_MODEL_PATH,by_name=True,skip_mismatch=True)
File "C:\ProgramData\Anaconda3\lib\site-packages\keras\engine\topology.py", line 2653, in load_weights
reshape=reshape)
File "C:\ProgramData\Anaconda3\lib\site-packages\keras\engine\topology.py", line 3407, in load_weights_from_hdf5_group_by_name
original_keras_version = f.attrs['keras_version'].decode('utf8')
AttributeError: 'str' object has no attribute 'decode' 报错原因： h5py模块版本不对造成的，首先检查自己的h5py。 解决办法 卸载原来的h5py
pip uninstall h5py 重新安装2.10版本的h5py
pip install h5py==2.10 -i https://pypi.tuna.tsinghua.edu.cn/simple/ 安装完成之后，程序就可以正常运行了！
参考博客链接:original_keras_version = f.attrs[‘keras_version‘].decode(‘utf8‘)_乐亦亦乐的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4de4dd89b1bd9d6681dec1b70ebe855/" rel="bookmark">
			echart 和ajax实现动态刷新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将整个设置echart部分代码设置为一个函数
function create(){ var myChart = echarts.init(document.getElementById('main')); var arr1=[],arr2=[]; function arrTest(){ $.ajax({ type:"post", url:"finally.php", dataType:"json", async:false, data:{}, success:function(result){ if (result){ for (var i = 0; i &lt; result.length; i++) { arr1.push(result[i].id); arr2.push(result[i].num); } } }, error:function(errorMsg) { alert("数据读取失败"); } }) return arr1,arr2; } // setInterval(arrTest(),300); // while(1){ arrTest(); // setInterval(arrTest(),300); console.log(arr1[0]); // window.function(){ // setInterval(arrTest(),300); // } var option = { tooltip: { show: true }, legend: { data:['num'] }, xAxis : [ { type : 'category', data : arr1 } ], yAxis : [ { type : 'value' } ], series : [ { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4de4dd89b1bd9d6681dec1b70ebe855/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50752246a24d7d9979a7075e1d367753/" rel="bookmark">
			彻底卸载secureCRT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、先在控制面版中找到secureCRT软件并卸载SecureCRT
2、按快捷键 win+r 进入cmd ,输入regedit进入注册表，删除HKEY_CURRENT_USER和HKEY_LOCAL_MACHINA两个根键下的SOFTWARE子键中的VanDyke删除即可，HKEY_CURRENT_USER保存的是当前用户配置，HKEY_LOCAL_MACHINA是当前计算机配置信息，务必将两个根键下的vandyke同时都删除。
3、找到SecureCRT安装的位置，将文件夹删除，此时，就彻底卸载了SecureCRT软件以及SecureFX软件。
路漫漫其修远兮，吾将上下而求索，希望此篇文章对大家有所帮助......
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af7b472f9e83aee24f5e341157c5908a/" rel="bookmark">
			雷达系统概述—分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RADAR（ 雷达）是无线电探测和测距的缩写。一般来说，雷达通过调制波形和方向性天线 发射电磁能量到空间特定区域搜索目标。搜索区域内的物体（目标）反射部分能量（回波），被雷达接收机处理，以提取目标的信息，如距离、角度、速度和其他目标识别特征。
根据搭载平台分为地基、天基、机载和舰载雷达系统等。
根据任务和功能：气象、搜索和捕获、边扫描边跟踪、火力控制、预警、超视距、地形跟随和地形回避等。
最常用波形类型或频率分类：
波形：连续波（CW）和脉冲（PR）雷达。
连续波雷达：使用单独的收发天线。无调制的CW能准确的测量目标的径向速度（多普勒频移）和角位置。不使用某种形式的调制不能提取目标的距离信息。无调制的CW主要用于目标速度搜索和跟踪以及制导。
脉冲雷达：低PRF用于测距对速度不感兴趣。高PRF用于测量目标速度。
高频(HF)雷达应用电离层 反射电磁波检测地平线以下的目标。
甚高频（VHF）和超高频（UHF）用于甚远距离预警雷达（EWR）。
L波段主要应用在地基和舰载系统，用于远程军事和空中交通可控制搜索行动。大部分工作在S波段。
C波段雷达主要应用于气象检测、中程搜索和火力控制。
X波段大多应用于机载雷达，要求优良的目标检测能力，但是不能忍受更高频段的大气衰减。
Ku,K,Ka波段，有严重的气象和大气衰减，主要应用于警用交通雷达、近程地形回避雷达、地形跟随雷达。
毫米波（MMW）应用于非常近距离的射频（RF）搜索器和试验雷达系统。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc0efcf31d511649d725658f31c8b1fe/" rel="bookmark">
			OpenGl L1窗口创建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.创建你的窗口 在画出效果图之前，首先要做的就是创建一个OpenGl上下文和一个用于显示的窗口
//窗口创建头文件 #include &lt;glad/glad.h&gt; #include &lt;GLFW/glfw3.h&gt; //实例化窗口 int main() { glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); //使用核心模式 glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE) //... return 0; } 接下来创建窗口对象： //窗口创建头文件 #include &lt;glad/glad.h&gt; #include &lt;GLFW/glfw3.h&gt; //实例化窗口 int main() { glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); //使用核心模式 glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE) //glfCreateWindow函数设置窗口的宽和高，以及标题 //GLFWwindow类存放窗口对象的指针 GLFWwindow* window = glfwCreateWindow(800,600,"LearnOPenGL",NULL,NULL); if(window == NULL) { std::cout&lt;&lt;"faild"&lt;&lt;std::endl; return -1; } //将当前窗口的上下文设置为当前线程的上下文,上下文：OpenGL在其中存储渲染信息的一个数据结构 glfwMakeContextCurrent(window); //... return 0; } 然后初始化GLAD用于管理函数指针 //窗口创建头文件 #include &lt;glad/glad.h&gt; #include &lt;GLFW/glfw3.h&gt; //实例化窗口 int main() { glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); //使用核心模式 glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE) //glfCreateWindow函数设置窗口的宽和高，以及标题 //GLFWwindow类存放窗口对象的指针 GLFWwindow* window = glfwCreateWindow(800,600,"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc0efcf31d511649d725658f31c8b1fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ba3bd2df61cf213c633cfd7efdccffa/" rel="bookmark">
			2021-10-09数据分析--系统认识数据分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是数据分析 观测、实验、应用
二、重新认识数据分析 观测：对数据形成客观量化的认知（报表、图表、仪表盘）
实验：发现规律、验证假设（科学研究、A/B测试）
应用：不断基于数据反馈迭代产品
三、观测 **观察：**采集数据、储存数据、展示数据
采集数据
1.解析系统日志
2.埋点获取新数据
3.通过传感器采集
4.爬虫（解析网站）
5.API（平台API文档，用API获取数据）
储存数据
各类数据库hive、myslq、presto、impala（数据工程师）、连接数据库取数
展示数据：可视化高效传达信息
**测量：**设定标准、发现异常、研究关系
四、分析数据的目的是什么？ 1、及时发现异常
2、找到数据之间的因果关系
数据是客观统一的：有统一的认知才能有共同的目标
设定标准+发现异常
研究关系：可视化查看相关性、建模推导相关性
实验提出假设，然后验证假设
所有未经过事实数据验证的想法都是假设
设计A/B测试获取数据
如何在业务只有少量数据时设计数据实验？
如何在无法同时测试两个版本时比较数据？
五、如何应用数据价值 基于数据反馈不断迭代产品和业务策略
明确业务的目标，拆解目标，得到标准值
将数据应用于业务、算法
（1）为算法设定明确的业务目标
（2）为算法提供高质量的数据
（3）判断算法是否真的创造了实际价值
（4）帮助业务更好的使用算法
基于数据和算法的竞争，无时无刻不在互联网行业上演
基于数据训练算法，让机器自动化的完成工作
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be240e76b0d187ab0dbe1ecd18a63984/" rel="bookmark">
			NOIP2017 普及组题解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、[NOIP2017 普及组] 成绩 分析 签到题，略。
代码 #include&lt;iostream&gt; #include&lt;cstdio&gt; using namespace std; int A,B,C; int score(int,int,int); void init(); void solve(); int main(){ init(); solve(); return 0; } int score(int a,int b,int c){ return 0.2*a+0.3*b+0.5*c; } void init(){ scanf("%d%d%d",&amp;A,&amp;B,&amp;C); } void solve(){ printf("%d",score(A,B,C)); } 2、P3955 [NOIP2017 普及组] 图书管理员 分析 本题主要目的是将编号 i i i 的读者需求码 r e a d e r I d [ i ] readerId[i] readerId[i] 与从小到大排名后的图书编码 b o o k I d [ i ] bookId[i] bookId[i] 进行比较，遇到合适值直接输出并进入下一个编号中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be240e76b0d187ab0dbe1ecd18a63984/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c98eedefa8e4fc0e733dda430ed66b35/" rel="bookmark">
			深入浅出 Vue 响应式原理源码剖析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先看张图，了解一下大体流程和要做的事
初始化 在 new Vue 初始化的时候，会对我们组件的数据 props 和 data 进行初始化，由于本文主要就是介绍响应式，所以其他的不做过多说明来，看一下源码
源码地址：src/core/instance/init.js - 15行
export function initMixin (Vue: Class&lt;Component&gt;) { // 在原型上添加 _init 方法 Vue.prototype._init = function (options?: Object) { ... vm._self = vm initLifecycle(vm) // 初始化实例的属性、数据：$parent, $children, $refs, $root, _watcher...等 initEvents(vm) // 初始化事件：$on, $off, $emit, $once initRender(vm) // 初始化渲染： render, mixin callHook(vm, 'beforeCreate') // 调用生命周期钩子函数 initInjections(vm) // 初始化 inject initState(vm) // 初始化组件数据：props, data, methods, watch, computed initProvide(vm) // 初始化 provide callHook(vm, 'created') // 调用生命周期钩子函数 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c98eedefa8e4fc0e733dda430ed66b35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bab3faef66d7e0e67ca612bfd7fa274d/" rel="bookmark">
			x86、x86-64、x64和amd64的区别(转)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文作者：kathlon
原文链接：x86,amd64,x86-64,x64区别_kathlon的专栏-CSDN博客_amd64
原文标题：x86,amd64,x86-64,x64区别
重要的地方我会在原文用粗体和红色标注。
X86是一个指令集，是刚有个人电脑时候的什么8086，286，386的那个兼容的指令集。
“x86-64”，有时会简称为“x64”，是64位微处理器架构及其相应指令集的一种，也是Intel x86架构的延伸产品。“x86-64”1999由AMD设计，AMD 首次公开 64 位集以扩充给 IA-32，称为 x86-64（后来改名为 AMD64）。 其后也为Intel所采用，现时英特尔称之为“Intel 64”.
AMD64 AMD64架构在IA-32上新增了64位寄存器，并兼容早期的16位和32位软件，可使现有以x86为对象的编译器容易转为AMD64版本。
由于AMD64和Intel64基本上一致，很多软硬件产品都使用一种不倾向任何一方的词汇来表明它们对两种架构的同时兼容。出于这个目的，AMD对这种CPU架构的原始称呼——“x86-64”被不时地使用，还有变体“x86_64”。其他公司如微软和Sun在营销资料中使用“x64”作为对“x86-64”的缩写。
许多操作系统及产品，尤其那些是在Intel进入这块市场之前就引入“x86-64”支持的，使用“AMD64”或“amd64”同时指代AMD64和Intel64。
IA-64 Intel在之前已在Itanium处理器上使用了自家的64位IA-64技术，虽然说Intel 64也是64位，但两者并不兼容，即IA-64的软件不能直接在Intel 64上运行。Intel 64所用的x86-64是IA-32指令集的延伸，而IA-64则是另一款独立的架构，没有任何IA-32的影子。虽然IA-64可通过模拟来运行IA-32的指令，但指令在运行前需经转换，才能在IA-64上运行，导致其速度变慢。由于x86-64是从IA-32派生而来，因此运行IA-32与64位程序的表现也显得绰绰有余。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddf42a225526f14510bcb907878fa61e/" rel="bookmark">
			iOS精品资源汇总(持续更新)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 引言I、iOS自定义视图相关热门资源1.1 《用户协议及隐私政策》弹框1.2 电子签名1.3 商品详情页1.4 上传图片视图的封装【支持删除和添加】1.5 查看风险商户的证明材料，图片支持滑动切换1.6 iOS 常用动画【 定点缩放弹窗】1.7 iOS抽奖转盘：概率抽奖算法 &amp; 转盘算法 &amp; 转盘主视图的实现思路1.8 自定义相机( 银行卡/身份证识别OCR、矩形边缘识别)1.9 收银app必备模块：iOS折扣计算器1.10 通讯录1.11 限定文本输入框输入特定的字符个数1.12 iOS商品类目选择视图1.13 iOS 自定义tab滑块 II 语音播报 &amp; 国际化2.1 iOS12.1以上在后台或者被杀死无法语音播报的解决方案2.2 APP 内的国际化切换 III 商品模块3.1 蓝牙打印商品价格标签、交易小票3.2 支持展开折叠的弹出菜单（横向） IV 、iOS安全资源4.1 参数签名4.2 敏感逻辑的保护方案4.3 基于NSURLProtocol拦截所有网络请求 V、 逆向5.1 IPC5.2 分析如何调用的ptrace，并hook ptrace5.3 进程间的实时通讯方案 VI、iOS中tabBar按钮再次点击实现界面刷新VII 、HTML字符串与富文本互转VIII、iOS开发效率工具8.1 封装富文本API IX、Q&amp;A9.1 为什么我下载demo后，在xcode12中允许报错：library not found for -lAXIndicatorView；请问怎么解决？ see also 引言 本文列出最受欢迎的资源，以便供大家快速查找自己所需的资料
文中的蓝字都是超级链接，点击进入即可
全部资源请访问这个地址:https://download.csdn.net/user/u011018979/
精品文章汇总(持续更新)
I、iOS自定义视图相关热门资源 1.1 《用户协议及隐私政策》弹框 iOS 自定义视图：《用户协议及隐私政策》弹框（包含超链接属性）【demo源码支持中英文切换】 1、原理文章：https://blog.csdn.net/z929118967/article/details/103902362
2、功能使用：点击demo的右上架文字进行中英文切换
《用户协议及隐私政策》 弹框的实现步骤:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ddf42a225526f14510bcb907878fa61e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81b4db54e1c0f7f84c7417262f8784c7/" rel="bookmark">
			关于CAN通信的相关介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 作为一个小萌新，在通过CAN控制6020、3508、2006驱动并实现相关功能后，我决定根据自己的理解介绍一下can通信，不足的地方敬请指正
can的作用can总线的电平信号can的帧种类 一、CAN的作用
CAN是控制器局域网络的简称，是ISO国际标准化的串行通信协议。它的英文全称是Controller Area Network，一般简写为CAN。CAN是由以研发和生产汽车电子产品著称的德国BOSCH公司开发的，并最终成为国际标准（ISO 11898），是国际上应用最广泛的现场总线之一
它的特点是：
​ 其为多主机工作模式，可以在一条通信线路上实现多个设备发送信息。各个系统拥有唯一的ID号,在他们同时发送信息时，可以通过自动仲裁机制来使得优先级高的设备优先发送信息，避免了冲突与拥挤。
二、CAN总线的电平信号
can用两条线进行数据传输，一为CAN_H，另一个是CAN_L。
can通过判断这两条数据线的压差来进行仲裁，即
当CAN_H=3.5V，CAN_L=1.5V时，即为逻辑一，代表隐性（Recessive）当CAN_H=2.5V，CAN_L=2.5V时，即为逻辑零，代表显性（Dominant） 这就是差分信号。
三、CAN的帧种类
此中，只介绍数据帧
仲裁段：包括目标设备的ID号和RTR。
ID号是用来标识接收设备的。其中的标准格式CAN_ID_STD（0）与扩展格式（!0）取决于ID号的长度。
RTR是用来标识其是数据帧CAN_RTR_DATA(0)还是遥控帧(!0)的
控制段：
IDE指的即为刚刚所讲的ID号；
r0是保留位（用途暂时不清楚，但要求设为显性电平）；
DLC指的是数据长度。设为0x08的时候，可以支持多个设备。
数据段：
用于存放数据
CRC段：
用于检验报文在传输过程中是否出错。这个是由can硬件自动完成的
ACK段：
相当于一个标志位，发送方的设置为隐形位，当接收方成功接收了之后，变为显性。
在CubeMX上的相关配置 can的相关参数配置 打开中断
控制代码
//过滤器配置 void CAN_FilterInit(CAN_HandleTypeDef *hcan) { CAN_FilterTypeDef CAN_FilterInitStructure; CAN_FilterInitStructure.FilterMode=CAN_FILTERMODE_IDMASK; CAN_FilterInitStructure.FilterScale=CAN_FILTERSCALE_32BIT; CAN_FilterInitStructure.FilterIdHigh=0x0000; CAN_FilterInitStructure.FilterIdLow=0x0000; CAN_FilterInitStructure.FilterMaskIdHigh=0x0000; CAN_FilterInitStructure.FilterMaskIdLow=0x0000; CAN_FilterInitStructure.FilterBank=0; CAN_FilterInitStructure.FilterFIFOAssignment=CAN_RX_FIFO0; CAN_FilterInitStructure.FilterActivation=ENABLE ; CAN_FilterInitStructure.SlaveStartFilterBank=14; //因为这里规定要是 if(HAL_CAN_ConfigFilter (hcan,&amp;CAN_FilterInitStructure)!=HAL_OK ) { Error_Handler () ; } if(HAL_CAN_Start(hcan) !=HAL_OK) {	Error_Handler () ; } if(HAL_CAN_ActivateNotification(hcan , CAN_IT_RX_FIFO0_MSG_PENDING)!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81b4db54e1c0f7f84c7417262f8784c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae1b202dccedfa065d8be6075350273c/" rel="bookmark">
			CINTA作业三：同余、模指数、费尔马小定理、欧拉定理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 题一第一问第二问 题二题三题四题五法一法二 题一 实现求乘法逆元的函数，给定a和m，求a模m的乘法逆元，无解时请给出无解提示，并且只返回正整数。进而给出求解同余方程（ax = b mod m）的函数，即给定a，b，m，输出满足方程的x，无解给出无解提示。
第一问 #include&lt;iostream&gt; using namespace std; //输入：a，m //输出：a模m的乘法逆元 int a_mod_m(int a, int m) { bool exchange = false;// //(gcd 判断是否互素) int a1 = a; int m1 = m; if (a1 &lt; m1) { int i; i = a1; a1 = m1; m1 = i; exchange = true; } while (a1 % m1 != 0) { int i = m1; m1 = a1 % m1; a1 = i; } if (m1 !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae1b202dccedfa065d8be6075350273c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff68d07eb5ef479771bd7247650dfd9c/" rel="bookmark">
			pycocotools安装失败 error:“Microsoft Visual C&#43;&#43; 14.0 is required.”（包含安装包丢失或损坏）——已解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为我把电脑重置了，之前安装的一些东西全都不在了，比如Microsoft Visual C++ 14.0。
今天在Pycharm里安装pycocotools这个库一直安装不上，然后我试了
pip install pycocotools 不行。不能conda安装，只能用pip
有的博客说需要先安装Cython，然后我输入
conda install cython 安装Cython成功，再来安装
pip install pycocotools 还是不行。
如果上面成功安装pycocotools，就不用看下面的步骤了。【这句话会重复好几遍 😦 】
我又看到别的博客说：在github自行下载coco源码，自行安装。
$ git clone https://gitclone.com/github.com/pdollar/coco.git $ cd coco/PythonAPI $ python setup.py build_ext --inplace 上面的结果还是出错了：
$ python setup.py build_ext install 我是重置电脑之后，前面安装的Microsoft C++ Visual 14.0不在了。
如果上面成功安装，就不用看下面的步骤了。*2
我又找了博客安装Microsoft C++ Visual 14.0，很多博客有百度网盘下载地址【这只是我找到的其中一个】，下载下来然后默认安装，我遇到了安装包丢失或损坏。
换了好几个安装包都是一样的情况。
如果上面成功安装，就不用看下面的步骤了。*3
我又找了一篇博客，教我离线下载。
cmd来到前面下载的VC++ Tools安装包的位置：
visualcppbuildtools_full.exe -h # 查看用法，这步可以不输入，输入下面那一步也是可以的 visualcppbuildtools_full.exe /Full /Layout D:\soft\vs14 # 最后一个地址是我想要下载放的位置，大家自行更改 还是安装包丢失或损坏。
如果上面安装成功，就不用看下面的步骤了。*4
我又找了一篇博客，教我从官网下载，我前面几步不是没试过从官网下载Tools，但是点了下载按钮之后没有弹下载链接。
这次我换了个浏览器下载，好家伙，终于弹下载链接了【之前都用Google浏览器，后面用的Edge，事实证明：一台电脑上不能只有一个浏览器(不是】：
双击安装包.exe，然后进行安装，我没有换安装位置，大概有6G左右【我怕换了安装位置之后出问题】。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff68d07eb5ef479771bd7247650dfd9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a8a9dec3838deedb20fcc91abb01672/" rel="bookmark">
			某多道程序设计系统供用户使用得主存为 100K ， 磁带机 2 台， 打印机 1 台。 采用可变分区内存管理, 采用静态方式分配外围设备, 忽略用户作业Ｆ O 时间。 现有作业序列如下:
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作业调度采用FCFS 策略, 优先分配主存低地址区且不准移动已在主存得作
业, 在主存中得各作业平分 CPU 时间. 现求：
（ 1 ) 作业被调度得先后次序？
（ 2 ） 全部作业运行结束得时间？
（ 3 ） 作业平均周转时间为多少?
( 4 ）最大作业周转时间为多少?
分析:
8 : 00 作业 1 到达， 占有资源并调入主存运行。
8 ： 20 作业２ 与 3 同时到达, 但作业 2 因分不到打印机， 只能在后备队
列等待. 作业 3 资源满足， 可进主存运行， 并与作业１ 平分 CPU 时间。
8 : 30 作业 1 在８ : 30 结束, 释放磁带与打印机。 但作业２ 仍不能执行，
因不能移动而没有 30KB 得空闲区， 继续等待. 作业 4 在 8 ： 30 到达， 并进入主存执行, 与作业 3 分享 CPU
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a8a9dec3838deedb20fcc91abb01672/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37b8f80c789a1eaac9a0f17974f35cc4/" rel="bookmark">
			题目：在单处理器多到分时系统中，有三道作业依次提交, 其提交时刻及运行时间分别为
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 作业作业提交时刻运行时间/h其中I/O时间/hCPU时间/hJob18.00.360.180.18Job28.20.320.160.16Job38.40.360.180.18 如果已知下列情况：
（1）每道作业的I/O等待时间占各自总运行时间的一半；
（2）分时运行两道作业，CPU将有20%的时间空闲；
（3）除了CPU，系统有充足的资源供作业使用。试计算各作业运行完成时间。
对(2)的解释:指在进程切换时会浪费20%的运行时间
解:
​ 8.0~8.2时间内: 只有Job1,没有发生进程调度,因此不会浪费时间, 在这0.2h内, 由于(1)每道作业的I/O时间占总运行时间的一半,所以有0.1h的时间用于I/O,剩余0.1用于CPU,因此 在8.2时刻, Job1还剩余0.36-0.2 = 0.16h的时间需要运行
​ 8.2~8.4时间内, Job2也开始运行, 同时也会运行Job1, 由于CPU同一时刻只能处理一个作业, 因此会发生进程切换, 在这0.2h内, 会浪费0.2×20%=0.04h的时间, 那么实际可运行的时间就只有0.2-0.04=0.16h, 在前0.08h中,可以让Job1运行CPU0.08h,同时, Job2可以运行I/O 0.08h
在后0.08h中,Job1运行I/O 0.08h, Job2运行CPU0.08h, 这时,也就是8.4时刻, Job1运行完毕
Job2还剩下0.16的运行时间, 其中各占一半
​ 8.4时刻, 此时Job3也开始运行, 同样会发生调度, 那么在8.2~8.6这0.2h内, 可用运行时间同样为0.16, 前0.08: Job2 CPU, Job3 I/O 后0.08: Job3CPU, Job2 I/O, 然后8.6时刻, Job2也就运行完毕
​ 8.6时刻, 只有Job3, 不需要调度, 还剩下CPU和I/O各0.1, 也就是8.6+0.1+0.1=8.8, Job3结束
故Job1完成时间: 8.4, Job2: 8.6, Job3: 8.8 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04857392062375d20a588d37641e3463/" rel="bookmark">
			Java中的 Lambda表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、Lambda表达式是什么？二、格式三、省略模式四、Lambda表达式和匿名内部类区别五、Lambda表达式支持的方法引用六、注意事项总结 前言 Lambda表达式是Java的学习过程中一个比较重要的点，它能让我们在编写代码的时候有更加清楚明了的逻辑。
一、Lambda表达式是什么？ Lambda表达式叫做函数式编程思想概述（函数式思想是尽量忽略面向对象的复杂语法：”强调做什么，而不是以什么形式去做“） 二、格式 1. ()：里面没有内容，可以看成是方法形式参数为空
2. -&gt;：用箭头指向后面要做的事情
3. {}:包含一段代码，我们称之为代码块，可以看成是方法体中的内容
4. 组成Lambda表达式的三要素：形式参数，箭头，代码块
5. (形式参数)-&gt;{代码块}
5.1 形式参数：如果多个参数，参数之间用逗号隔开，如果没有参数，留空即可
5.2 -&gt;:由英文中画线和大于符号组成，固定写法。代表指向动作
5.3 代码块：是我们具体要做的事情，也就是以前我们写的方法体内容
三、省略模式 1.参数类型可以省略。但是有多个参数的情况下，必须全部省略
2.如果参数有且仅有一个，那么小括号可以省略
3.如果代码块的语句只有一条，可以省略大括号和分号，甚至是return
四、Lambda表达式和匿名内部类区别 所需类型不同
1.匿名内部类：可以是接口，抽象类，具体类
2.Lambda表达式：只能是接口
使用限制不同
1.如果接口中有且仅有一个抽象方法，可以使用Lambda表达式，也可以使用匿名内部类
2. 如果接口中多于一个抽象方法，就只能使用匿名内部类，而不能使用Lambda表达式
实现原理不同：
1.匿名内部类：编译之后，产生一个单独的.class字节码文件
2.Lambda表达式：编译之后，没有一个单独的.class字节码文件。对应的字节码会在运行的时候动态生成
五、Lambda表达式支持的方法引用 常见的引用方式
引用类方法
概述：其实就是引用类的静态方法
格式：类名::静态方法
范例：Integer::parselnt
Integer类的方法：public static int parseInt（String )将此String转换为int类型的数据
注意：Lambda表达式被类方法替代的时候，它的形式参数全部传递给静态方法作为参数
引用对象的实例方法
概述：其实就是引用类中的成员方法
格式：对象::成员方法
范例:“HelloWorld”::toUpperCase
String类中的方法：public String toUpperCase()将此String所有字符转换为大写
注意：Lambda表达式被对象的实例方法代替的时候，它的形式参数全部传递给该方法作为参数
引用类的实例方法
概述：其实就是引用类中的成员方法
格式：类名::成员方法
范例：String::substring
String类中的方法：public String substring(int beginlndex,endlndex)从beginlndex开始到endlndex结束，截取字符串。返回一个子串，子串的长度为endlndex-beginlndex
注意：Lambda表达式被类的实例方法代替的时候，第一个参数做为调用者，后面的参数全部传递给该方法做为参数
引用构造器
概述：其实就是引用构造方法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04857392062375d20a588d37641e3463/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e201d820802e38c3b1b56b6240b9a1e2/" rel="bookmark">
			Jetson nx或其他aarch64 使用anaconda虚拟环境构建GPU版本的Pytorch cuda可用的前提下完整教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、Anaconda 下载安装包 首先，到anaconda官网下载安装包，注意不是下载平常linux系统所用的安装包，而是下载ARM架构的安装包，若使用其他的版本会提示版本不符合无法安装。
安装 然后将下载好的安装包拷贝到Jetson nx里，使用命令bash Anaconda3-2021.05-Linux-aarch64.sh进行安装，不懂怎么安装的小伙伴看此链接：https://blog.csdn.net/qingfengxd1/article/details/109334199
修改配置 若不懂如何修改**~/.bashrc**的小伙伴参考此链接：https://blog.csdn.net/hehedadaq/article/details/115130945，
步骤简单来说就是：
vi ~/.bashrc 按一下 “ i ”，此时是插入模式，可输入内容，去到最后一行，输入你要输入的内容：export …
输入完成后想退出并保存则：按一下ESC键，输入“ :wq! ”，回车，输入
source ~/.bashrc 构建虚拟环境 成功安装anaconda后，进行基本的构建虚拟环境操作，
①添加清华源：https://blog.csdn.net/Rocky6688/article/details/104082982，运行前三行命令就够了，也可以自行搜索添加豆瓣源
②创建虚拟环境：
我这里用的是python3.6，因为后面重头戏torch，官方给的例子是3.6，以防又有bug我就直接用的3.6
conda create -n gg python=3.6 conda activate gg 二、torch与torchvision pytorch官网提供的离线包只有CPU版本的，只需要CPU的小伙伴可自行下载，直接Ctrl+F搜索aarch64就有了，但是！！！GPU版本的就不是用这个链接的安装包了
GPU版本的torch离线包链接地址 想用GPU的小伙伴，看NVIDIA官方给的这个链接：https://forums.developer.nvidia.com/t/pytorch-for-jetson-version-1-9-0-now-available/72048，跟着官网的步骤走就行
我选择的是pytorchv1.8.0，因为官网给出的对应关系里没有说明pytorch1.9.0和torchvision哪个版本对应，本人为避免又出现bug，就选择了最为稳妥的1.8.0版本
可以看到官网对应的是python3.6，所以之前构建虚拟环境时我使用的是3.6，各位小伙伴如果安装了其他版本的python，我也不保证是否可行，你们可以试试
安装torch 点开Installation就有安装命令了，一行一行来即可
安装torchvision torch安装完成了就到torchvision了
看图片里我标注的注意事项，pillow的安装直接pip install pillow就行，总之其他模块安装时若报错，大家可以尝试灵活处理，最主要是torch和torchvision没错就没什么大问题
祝各位也成功用GPU起飞 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5945350c99c3739583e1c1c1b195f5ba/" rel="bookmark">
			深度学习--TensorFlow（4）BP神经网络（损失函数、梯度下降、常用激活函数、梯度消失&amp;&amp;梯度爆炸）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、概念与定义
二、损失函数/代价函数（loss）
三、梯度下降法
二维w与loss：
三维w与loss： 四、常用激活函数
1、softmax激活函数 2、sigmoid激活函数
3、tanh函数
4、softsign函数
sigmoid、tanh、softsign函数对比
5、relu函数
对比tanh和relu激活函数
4个隐藏层tanh激活函数
4个隐藏层relu激活函数
2个隐藏层relu激活函数
五、梯度消失与梯度爆炸
1、梯度消失
2、梯度爆炸
3、解决梯度消失与梯度爆炸
一、概念与定义 BP神经网络：是一种按照误差逆向传播算法训练的多层前馈神经网络。 BP 算法的基本思想：学习过程由 信号的正向传播 和 误差的反向传播 两个过程组成。 正向传播：把样本的特征从输入层进行输入，信号经过各个隐藏层逐层处理后，最后从输出层传出。
反向传播：对于网络的实际输出与期望输出之间的误差，把误差信号从最后一层逐层反传，从而获得各个层的误差学习信号，再根据误差学习信号来修正各个层神经元的权值。
周而复始地进行，权值不断调整的过程，就是神经网学习训练的过程。
二、损失函数/代价函数（loss） 损失函数的值越小，说明模型的预测值越接近真实值。
我们可以利用这个函数来优化模型参数。
最常见的损失函数是均方差损失函数（二次损失函数）： 矩阵可以用大写字母来表示，这里的 T 表示真实标签，Y 表示网络输出，i 表示第 i 个数据。N 表示训练样本的个数(注意这里的 N 是一个大于 0 的整数，不是矩阵)。T-Y 可以到每个训练样本与真实标签的误差。误差的值有正有负，我们可以求平方，把所有的误差值都变成正的，然后除以 2N。这里 2 没有特别的含义，主要是我们对均方差代价函数求导的时候，公式中的 2 次方的 2 可以跟分母中的 2 约掉，使得公式推导看起来更加整齐 简洁。除以 N 表示求每个样本误差平均的平均值。 三、梯度下降法 梯度下降法是最常用的方法之一。
既然在变量空间的某一点处，函数沿梯度方向具有最大的变化率，那么在优化代价函数的时候，就可以沿着负梯度方向去减小代价函数的值。
梯度下降法优化公式：
二维w与loss： 首先w移动到了w=3的位置： 当 w 为-3 时，w 所处位置的梯度应该是一个负数，梯度下降法在优化代价函数的时候，是沿着负梯度方向去减小代价函数的值，所以负梯度是一个正数，w 的值应该变大。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5945350c99c3739583e1c1c1b195f5ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27bbd630c8a088bf07a829a2ce69c4d0/" rel="bookmark">
			《庄子》中说到，“一尺之棰，日取其半，万世不竭”。第一天有一根长度为 a的木棍，从第二天开始，每天都要将这根木棍锯掉一半
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 26，《庄子》中说到，“一尺之棰，日取其半，万世不竭”。第一天有一根长度为 a的木棍，从第二天开始，每天都要将这根木棍锯掉一半 （每次除 2，向下取整）。第几天的时候木棍会变为 1？ n=int(input("请输入整数a：")) i=1 while n&gt;1: n=n//2 i+=1 print (i) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fad4120b7c09e305866e497fc68974d/" rel="bookmark">
			数通IP-223
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、在复杂的网络环境中，采用非结构化的网络故障排除流程进行操作，有可能会导致新的故障产生，从而使网络故障的排除变得更加困难？
A.正确
B.错误
【正确答案】A
【答案解析】相对于非结构化的网络故障排除流程来说，结构化的网络故障排除流程所产生的结果是可预期的，排障过程中所造成的影响是可控的，引入新故障的风险是可评估的。所以题目中的描述是正确的。
2、高危操作需要获取的三个授权不包括哪一项？
A.管理授权
B.技术授权
C.客户授权
D.行政授权
【正确答案】D
【答案解析】三授权包括 —— 管理授权：结合项目情况，发送邮件给华为项目经理进行管理授权。技术授权：邮件发送技术方案给华为技术专家进行技术授权，且必须在操作前三天提交方案申请审核。客户授权：客户项目建设负责部门进行操作审批，以书面或邮件方式进行确认。并不包括所谓的“行政授权”这个选项。
3、关于日常工程中配置STP的描述，以下哪个是正确的？
A.STP是缺省自动运行的，所以不需要进行配置
B.STP收敛速度慢，导致网络震荡，所以关闭STP是较好的解决方案
C.和路由协议类似，我们一般采用修改链路Cost的方法，来调整交换机之间的数据流向
D.日常配置STP主要是控制交换机的阻断端口位置，保证其尽量不出现在骨干链路和骨干设备上
E.因为RSTP算法简单可靠，而且收敛速度快，所以一般我们会将网络中的所有交换机设置为工作在RSTP模式
【正确答案】D
【答案解析】STP协议解决二层环路问题的一个重要技术，需要进行必要的配置，我们一般采用指定根网桥的方式来让网络形成逻辑无环的拓扑结构，一般不会去修改端口的cost值，一般我们会把交换机的STP模式设置为MSTP模式。所以正确答案是“日常配置STP主要是控制交换机的阻断端口位置，保证其尽量不出现在骨干链路和骨干设备上”。
4、华为路由器配置OSPF后，默认情况下邻居关系之间的MTU不一致会影响邻居关系建立无法进入full状态。
A.正确
B.错误
【正确答案】B
【答案解析】链路上的MTU不匹配有可能会导致ospf邻居关系不能建立，但是华为设备默认将DD中的MTU设置为0，并不做MTU的比较。所以题目中的描述是错误的。
5、企业网络常常使用DHCP为用户分配IP地址，与静态地址分配方式相比，DHCP地址分配方式极大地减少了对网络地址进行管理的工作量。
A.正确
B.错误
【正确答案】A
【答案解析】使用DHCP分配置IP地址可以极大地减少网络管理的工作量。所以题目中的描述是正确的。
6、下面哪项内容不是项目启动会需要协商的主要内容或议程？
A.明确客户需求
B.核实实施成本
C.确认甲乙方责任人
D.明确项目管理制度
【正确答案】B
【答案解析】项目启动会需要协商的主要内容为：明确客户需求，确认甲乙方责任人，明确项目管理制度。选项“核实实施成本”并不是在项目启动会上来协商的。
7、如果面对复杂的网络故障，经过评估认为短时间内无法排除，而此时用户又急需恢复网络的可用性，那么正确的做法是？
A.告诉用户这是不可能实现的
B.直接搭建替代的网络环境
C.与用户沟通是否可以跳过故障节点，搭建替代的网络环境
D.先尝试排除故障，过段时间无法解决故障了再与用户沟通
【正确答案】C
【答案解析】如果网络故障比较复杂，短时间内无法排除故障，可以先用硬件替换法，替换故障设备，让业务恢复正常运行，然后再慢慢去查找故障原因。所以正确的做法是“与用户沟通是否可以跳过故障节点，搭建替代的网络环境”。
8、以下哪一项不属于项目的外部风险？
A.汇率变动
B.暴雨成灾
C.社会动荡
D.工业标准差异
【正确答案】D
【答案解析】项目的外部风险主要有：政策法规，社会环境，自然灾害，金融财务，配套协作。工业标准差异应该在项目前期规划时要考虑的必要因素，而不是外部风险。所以这个题应选“工业标准差异”。
9、以下哪个型号的路由器能够提供集群功能？
A.AR G3
B.NE20S
C.NE40E
D.NE5000E
【正确答案】D
【答案解析】NE5000E：面向网络骨干节点、数据中心互联节点推出的超级核心路由器产品。提供业界最大容量1T路由线卡，支持背靠背集群、混框集群等模式，以其大容量、高稳定、绿色设计，保证网络的健壮性、平滑演进。所以正确答案是“NE5000E”。
10、由于华为数通产品的软件升级操作都是相似的，所以在进行软件升级前，只需简单阅读版本升级指导书即可。
A.正确
B.错误
【正确答案】B
【答案解析】软件升级可能会对网络的稳定运行造成威胁，在升级前应做好充分的风险评估和风险规避措施。在评估风险时应从技术、业务等全方位进行考虑，并采取必要的风险规避措施；如果有不可规避的风险，则应寻求技术支持，而不应贸然执行软件升级操作。所以题目中的描述是错误的。
11、当前设备端常用的光纤接口型号是以下哪一种？
A.LC接口
B.RJ接口
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fad4120b7c09e305866e497fc68974d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f267c10674f0e115ef9c6302a98b7557/" rel="bookmark">
			【C&#43;&#43;基础学习笔记】三、C&#43;&#43;中的引用（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、传值和传引用 以值作为参数或者返回值时，传过去或者饭回来时，函数不会直接传递自己本身或者返回自己本身，而是传递或者返回需要的值的一份临时拷贝。因此，当数据量非常大时，不断地拷贝这是非常费时的，效率低下。 2、引用和指针的异同 引用：引用语法上就是一个内存空间的别名，没有自己独立的空间，与其引用的实体（本名）共用一块空间，操作相同。 指针：指针有自己的空间，用来存放指向对象的地址。 引用在底层实现上，引用是按照指针的方式来实现的，也是有空间的。 指针和引用不同点：
引用必须初始化，指针没要求引用在引用一个实体后不能再引用其他，指针可以随时指向任何一个同类型的元素没有NULL引用，有NULL指针sizeof计算的大小不同，引用计算的是数据原本的大小；指针计算的是指针空间大小，也就是地址大小有多级指针，但是没有多级引用访问实体（原数据内存空间）的方式不同，指针需要显式解引用，引用编译器自己处理 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/878423c756ee63985b879c3b5c583cd9/" rel="bookmark">
			Power Query 自定义函数来处理表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：
[求助] 姑且叫一对多合并吧
将表1、表2导入到PQ中：
结果：
完整代码：
let 源 = Table.AddColumn(表1, "Mail Type", each List.Last(表2[Mail Type])), fn = (t) =&gt; [ s1 = List.Sum(t[订舱重量]), s2 = 源[账单重量]{0}, w = if s2 &lt;&gt; s1 then [ r = List.Last(List.PositionOf(t[订舱重量],List.Min(t[订舱重量]),#infinity)), n = s2 - (s1 - t[订舱重量]{r}), t1 = Table.RemoveColumns(Table.AddColumn(Table.AddIndexColumn(t, "索引", 0, 1, Int64.Type), "匹配后重量", each if [索引]=r then n else [订舱重量]), {"索引"}) ][t1] else t][w], 匹配后重量 = fn(表2), 合并的查询 = Table.NestedJoin(匹配后重量, {"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/878423c756ee63985b879c3b5c583cd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69c659b49477c56efda390874d3831a3/" rel="bookmark">
			kicad如何下载及导入封装（超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		kicad如何下载及导入封装 同样也是在 http://snapeda.com 这类网站点击进入下载界面点击Download symbol and Footprint 可以打包下载原理图包含如下接下来是重要的步骤就是要在kicad中导入正确的路径，在主页面也就是工程页面进入-首选项-管理符号库-全局库进入PCB工程下选择-首选项-管理符号库-全局库需要给原件添加3D Model，点击Download 3D Model 同样也是在 http://snapeda.com 这类网站 我现在以导入一个Type-c 插座为例子
点击进入下载界面 点击Download symbol and Footprint 可以打包下载原理图包含如下 接下来是重要的步骤就是要在kicad中导入正确的路径，在主页面也就是工程页面进入-首选项-管理符号库-全局库 进入PCB工程下选择-首选项-管理符号库-全局库 到此点击就能找到
需要给原件添加3D Model，点击Download 3D Model 保存到对应的路径
最后加入封装就大功告成了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83937dc0179df2b0b7147bebef002166/" rel="bookmark">
			2021-10-08
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		回调函数的经典示例 示例代码： 如何插入一段漂亮的代码片 #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include"bubbleSort.h" int compare_int(const void * e1, const void * e2) { return *(int *)e1 - *(int *)e2; } int compare_int_r(const void * e1, const void * e2) { return *(int *)e2 - *(int *)e1 ; } int compare_str(const void * e1, const void *e2) { return strcmp(*(char **)e1, *(char **)e2); } void main() { int arrayInt[] = { 39, 33, 18, 64, 73, 30, 49, 51, 81 }; int numArray = sizeof(arrayInt) / sizeof(arrayInt[0]); bubbleSort(arrayInt, numArray, sizeof(arrayInt[0]), compare_int); for (int i = 0; i &lt;numArray; i++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83937dc0179df2b0b7147bebef002166/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/019667e7263f261bcc383890dcc296ba/" rel="bookmark">
			spring boot：实现jpa&#43;thymeleaf 用户管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 今天布置的spring boot小作业:一、实现原理二、代码1.基本类(po/dao层)2.服务层3.控制层4.thymeleaf 前端代码5.演示效果 总结 今天布置的spring boot小作业: 实现controller 和 模板
/users 查看用户列表
/users/del 删除 用户
/users/add 新增用户
/users/edit 修改用户
一、实现原理 前端采用semantic ui框架，ajax实现数据发送，
后端采用ssm三层架构，实现jpa+thymeleaf 用户管理
二、代码 1.基本类(po/dao层) user.java：
package com.example.po; import lombok.Data; import javax.persistence.*; /** * @ClassName user * @Description TODO * @Author 加辣椒了吗? * @Date 2021/9/21 20:42 * @Version 1.0 **/ @Data @Entity @Table(name = "t_user") public class user { @Id @GeneratedValue private Integer id; private String name; private String email; } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/019667e7263f261bcc383890dcc296ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b3c7c5e8f6a66ac43a7a055564c56e4/" rel="bookmark">
			Power Query 根据其它列替换值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[求助] Power Query根据其他列数值替换
有一表格：
ABY12N32 题目：如果A列第n行=“Y”，替换该行B列的值为100。
方法1：
= Table.ReplaceValue(更改的类型, each [B], each if [A]="Y" then 100 else [B], Replacer.ReplaceValue,{"B"}) 方法2：
= Table.ReplaceValue(更改的类型, each [A]="Y", 100, (X,Y,Z)=&gt;if Y then Z else X, {"B"}) 方法中的第4个参数为 函数名，默认为Replacer.ReplaceValue。方法2中改为了自定义函数，但使用的参数是一样的，都来自方法中的其它参数。 形参实参XTable.ReplaceValue()函数中的第5个参数，{“B”}，即B列中的每个值，被查找的值Yeach [A]=“Y”，即True或者FalseZTable.ReplaceValue()函数中的第3个参数，100 默认的函数名，Replacer.ReplaceValue，执行逻辑是：判断每个X（即列中每个要被查找的值）是否等于Y的值，是就返回Z的值，否则返回X的值。
自定义匿名函数，(X,Y,Z)=&gt;if Y then Z else X，执行逻辑是：if判断Y的值，是True就返回Z的值，是False返回X的值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60c2ac3d062ab859c964686ba5899ad4/" rel="bookmark">
			linux驱动 — 常用API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、设备树—API
①of_find_compatible_node 函数
②of_get_named_gpio 函数
③irq_of_parse_and_map 函数
二、GPIO—API
①gpio_request 函数
②gpio_free 函数
③gpio_direction_input 函数
④gpio_direction_output 函数
⑤gpio_is_valid 函数
⑥gpio_get_value 函数
⑦gpio_set_value 函数
三、中断—API
①request_irq 函数
②free_irq 函数
③enable_irq()与disable_irq()函数
四、Pinctrl—API ①devm_pinctrl_get 函数
②devm_pinctrl_put 函数
③pinctrl_lookup_state 函数
④pinctrl_select_state函数
inux驱动开发，首先从使用驱动的API开始，先会使用API，然后才能更深入的分析，本篇所列的都是驱动开发中非常常用的API，之所以从设备树API开始，是本人觉得驱动开发的源头在设备树，并且大部分驱动都跟设备树相关。
一、设备树—API ①of_find_compatible_node 函数 of_find_compatible_node 函数根据 device_type 和 compatible 这两个属性查找指定的节点， 函数原型如下： struct device_node *of_find_compatible_node(struct device_node,*from, const char *type,
const char *compatible) 函数参数和返回值含义如下： from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。 type：要查找的节点对应的 type 字符串，也就是 device_type 属性值，可以为 NULL，表示忽略掉 device_type 属性。 compatible：要查找的节点所对应的 compatible 属性列表。 返回值：找到的节点，如果为 NULL 表示查找失败 ②of_get_named_gpio 函数 此函数获取 GPIO 编号，因为 Linux 内核中关于 GPIO 的 API 函数都要使用 GPIO 编号，此函数会将设备树中类似&lt;&amp;gpio5 7 GPIO_ACTIVE_LOW&gt;的属性信息转换为对应的 GPIO 编号，此函数在驱动中使用很频繁！函数原型如下： int of_get_named_gpio(struct device_node *np, const char *propname, int index) 函数参数和返回值含义如下： np：设备节点。 propname：包含要获取 GPIO 信息的属性名。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60c2ac3d062ab859c964686ba5899ad4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/524e29d39aafe180d7cb21b82d16a732/" rel="bookmark">
			【python】PEP 8: E302 expected 2 blank lines, found 1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		英文：PEP 8: E302 expected 2 blank lines, found 1
中文：PEP 8:E302预期有2个空行，发现1个
在方法的定义前面需要有两行空行，注释可以没有空行。
更改前：
更改后：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4c784c815aa15baa3863c9952391647/" rel="bookmark">
			acwing算法基础课：DFS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DFS模板 运用栈的数据结构、排序 int dfs(int u) { st[u] = true; // st[u] 表示点u已经被遍历过 for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) dfs(j); } } 例题 n-皇后问题是指将n今皇后放在n*n的国际象棋棋盘上，使得皇后不能相互攻击到，即任意两个皇后都不能处于同一行、同一列或同一斜线上。
#include &lt;iostream&gt; using namespace std; const int N = 20; int n; char g[N][N]; bool col[N], dg[N], udg[N]; void dfs(int u) { if(u == n) { for(int i = 0; i &lt; n; i++) cout &lt;&lt; g[i] &lt;&lt; endl; return ; } for(int i = 0; i &lt; n; i++) if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4c784c815aa15baa3863c9952391647/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd4443648b3adf40b8d801d2d3f24315/" rel="bookmark">
			npm切换下载的国内库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		npm info underscore
全局切换到淘宝
npm config set registry https://registry.npm.taobao.org
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06c63c795e4e7c313bda9486ad25ec82/" rel="bookmark">
			JAVA语言语法_数据类型（part1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 JAVA语言语法一、数据类型1、标识符2、关键字3、常量、字面常量4、变量的声明、赋值、使用（重点）5、变量的内存（重点）6、变量的作用域7、基本数据类型之整数类型存储8、基本数据类型之整数类型变量9、基本数据类型之浮点类型常量的两种形式10、基本数据类型之浮点类型变量11、编码和字符集12、基本数据类型之字符类型113、基本数据类型之字符类型214、解释乱码问题15、基本数据之布尔类型16、基本数据类型转换问题17、引用数据类型 String （重点）18、引用数据类型String练习题 （重点） JAVA语言语法 一、数据类型 1、标识符 ​ 标识符定义是：
​ 四个可以：可以是数字、字母（不仅仅是26个字母，也包含中文、或者其他语言）、下划线_、美元符号$。
​ 两不可以：不可以是以数字开头，不可以是关键字命名。
​ 一见：见名知意，增强可读性。
​ 大小写敏感：int a ； int A。
​ 遵循驼峰命名：
​ 类名：首字母大写，其余遵循驼峰命名
​ 方法名，变量名：首字母小写，其余遵循驼峰命名
​ 包名：全部小写，不遵循驼峰命名
2、关键字 ​ 常见关键字，见一个认识一个，关键词表如下：
​ 官方地址点击跳转
3、常量、字面常量 ​ 常量的定义是一个固定值，常见的是字面常量， 比如，123，‘a’，true等等，后面将会学习到的用final修饰的字符常量。
4、变量的声明、赋值、使用（重点） package com.rucoding.d2;package com.rucoding.d2; /** * 变量的声明、赋值、使用。 * @author LiuYiXin * */ public class Variable01 { public static void main(String[] args) { //变量的定义方式: java是强类型的语言,即是声明变量,必须为其声明类型 ，例如 type varName [=varValue]; //int age; int age = 10; System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06c63c795e4e7c313bda9486ad25ec82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acb79ccac62dc9d7d683d5b37c19f170/" rel="bookmark">
			JSON技术和反射基础应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# JSON技术和反射
## 1 JSON技术的基础使用
下方代码是利用JSON技术封装了一个JSON工具类，可将对象和JSON类型的字符串相互转换 package cn.itcast.eshop.common.until; import com.alibaba.fastjson.JSON; import java.util.List; /* * JSON工具类 * 处理和JSON相关的所有内容 * */ public class JSONUtil { /** * 将对象转换为JSON格式的字符串 * @param entity 指定对象 * @return 返回JSON格式的字符串 */ public static String entity2JSON(Object entity) { return JSON.toJSONString(entity); } /** * 将对象列表转换为JSON格式的字符串 * @param entityList 指定的对象列表 * @return 返回JSON类型的字符串 */ public static String entityList2JSON(List&lt;?&gt;entityList) { return entity2JSON(entityList); } /** * 将JSON类型的字符串转换为指定类型的对象 * ? 泛型的通配符，代表未知的任意类型，或者说是Object类 * @param json 要转换的数据 * @param clazz 指定的类型 * @return 返回Object对象 */ // public static Object JSON2Entity(String json,Class&lt;?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/acb79ccac62dc9d7d683d5b37c19f170/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/711c55e76c0b829ea7741128ac0f4451/" rel="bookmark">
			[JVM]聊聊 CMS 收集器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果要问 JVM 垃圾回收器有哪些, CMS 收集器就肯定是绕不过去
CMS 收集器是基于标记-清除算法实现的,整个回收过程分为四个步骤:
初始标记并发标记重新标记并发清除 初始标记时,就是标记一下 GC Roots 能直接关联到的对象,这个过程会很快,在这期间会发生 Stop the world ,这个阶段垃圾收集线程是独占的,不会和用户线程一起运行
并发标记则是从 GC Roots 的直接关联对象开始遍历整个对象,这个过程耗时较长,但是不需要停顿用户线程,用户线程可以和垃圾收集线程一起并发运行
重新标记就是为了修正并发标记期间,因为用户程序继续运作而导致标记产生变动的那一部分对象的标记记录,这个阶段相对于初始标记来说,它的停顿时间是比较长的,但是跟并发标记阶段相比的话,那它的停顿时间还是挺少的,这期间也会发生 Stop the world
最后就是并发清除阶段,在这个阶段就是要清理删除掉标记阶段判断的已经死亡的对象,这个时候由于不需要移动存活对象,所以这个阶段也是可以和用户线程一起并发运行的
CMS 它的优点主要在于:并发收集,低停顿,但是它也有自己的缺点:
CMS 收集器对处理器资源非常敏感,在并发标记和并发清除阶段,它虽然不会导致用户线程停顿,但是会因为占用了一部分线程导致应用程序变慢,降低总吞吐量
CMS 默认启动的回收线程数是(处理器核心数量 + 3)/4,也就是如果处理器核心数在四个或以上,并发回收时垃圾收集线程只占用不超过 25% 的处理器运算资源,但是当处理器核心数量不足四个时, CMS 对用户程序的影响就可能变得很大CMS 没办法处理"浮动垃圾",在 CMS 并发标记和并发清理阶段,用户线程还在继续运行的,程序在运行自然就会有新的垃圾对象不断产生,但是这一部分垃圾对象是出现在标记过程结束以后, CMS 没有办法在当次收集中处理掉它们,只要等到下一次垃圾收集时再清理掉,这一部分垃圾就是"浮动垃圾"CMS 是基于"标记-清除"算法实现的收集器,这就意味着收集结束时会有大量空间碎片产生,空间碎片如果过多的话,就有可能出现一种情况:明明老年代还有很多剩余空间,但就是无法找到足够大的连续空间来分配当前对象,这样就不得不提前触发一次 Full GC
为了解决这个问题, CMS 收集器提供了一个 -XX: +UseCMS-CompactAtFullCollection 开关参数(默认是开启的,这个参数从 JDK 9 开始废弃),这个参数就是让 CMS 收集器不得不进行 Full GC 时开启内存碎片合并整理,那如果想要进行合并整理的话,就必须移动存活对象,就没有办法做到并发,这样去做的话,空间碎片问题是解决了,但是停顿时间就又会变长
所以虚拟机设计者还给了另外一个参数 -XX: CMSFullGcBeforeCompaction ,设置了这个参数就会让 CMS 收集器在执行若干次不整理空间的 Full GC 之后,下一次进入 Full GC 之前会先进行碎片整理(默认值为 0,表示每次进入 Full GC 时都会进行碎片整理) 想要分享的大概就是这些了~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b68281c518156902b61130fd86fa1cac/" rel="bookmark">
			scrapy 爬取网页详细信息时出现KeyError: ‘item‘问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在爬取租房信息时，当进入详细页面爬取时就会出现报错：
Traceback (most recent call last): File "c:\users\yy\appdata\local\programs\python\python39\lib\site-packages\scrapy\utils\defer.py", line 120, in iter_errback yield next(it) File "c:\users\yy\appdata\local\programs\python\python39\lib\site-packages\scrapy\utils\python.py", line 353, in __next__ return next(self.data) File "c:\users\yy\appdata\local\programs\python\python39\lib\site-packages\scrapy\utils\python.py", line 353, in __next__ return next(self.data) File "c:\users\yy\appdata\local\programs\python\python39\lib\site-packages\scrapy\core\spidermw.py", line 56, in _evaluate_iterable for r in iterable: File "c:\users\yy\appdata\local\programs\python\python39\lib\site-packages\scrapy\spidermiddlewares\offsite.py", line 29, in process_spider_output for x in result: File "c:\users\yy\appdata\local\programs\python\python39\lib\site-packages\scrapy\core\spidermw.py", line 56, in _evaluate_iterable for r in iterable: File "c:\users\yy\appdata\local\programs\python\python39\lib\site-packages\scrapy\spidermiddlewares\referer.py", line 342, in &lt;genexpr&gt; return (_set_referer(r) for r in result or ()) File "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b68281c518156902b61130fd86fa1cac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65f12134c7debbac3e9505948e596d93/" rel="bookmark">
			stm32寻迹小车，占空比调速，0基础学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		stm32寻迹小车，占空比调速 所用器件视频演示说明补充 代码（部分）程序下载 所用器件 1.stm32F103核心板
2.LN298
3.12V电源
4.小车底座（电机随便，普通减速电机也可）
视频演示 stm32寻迹小车（占空比）
说明 经过测试：
1.可以进行90°直角转弯
2.直行前进偏差几乎为0
3."S"转弯不会偏离轨道
4.最大速度目前还没有具体测试，有兴趣的可以进行测试一下
5.正常上下坡没有任何问题
补充 寻迹采用的是八路的传感器，但是只用了六个，如果说大家想用两个单路的传感器做这个也行，但是尽量把速度降下来，要不然转弯的时候容易跑偏，个人觉得用6个比较稳定。
代码（部分） 1.主函数
// An highlighted block /*本程序用keil4编写，您如果用keil5打开会有不兼性，有可能会出现错误，可以下载这个兼容包解决！链接：https://www2.keil.com/mdk5/legacy/ */ /*********接线定义********** 八路传感器： 1号——PB13 2号——PB3 3号——PB4 6号——PB5 7号——PB6 8号——PB15 中间左侧传感器： 接开发板上的PB11 LN298接线定义： IN1——PA6 IN1——PA7 IN1——PB0 IN1——PB1 ***************************/ #include "stm32f10x.h" #include "led.h" #include "moter.h" #include "xunji.h" #include "delay.h" #include "sys.h" #include "bmp.h" #include "cs.h" //循迹检测到黑线后返回高电平 extern void xunji(void); //在这里是因为有警告，所以加上xunji的定义，避免警告 int main(void) {	SystemInit();	// 配置系统时钟为72M delay_init(); //延时初始化	xunji_config(); //循迹初始化 TIM3_PWM_Init();	//电机pwm TIM3	while(1) {	xunji(); //具体的逻辑在xunji.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65f12134c7debbac3e9505948e596d93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c32ba664ad203a17fee2da3ab182eaf/" rel="bookmark">
			Spring框架的常见错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		框架：具有约束性的支撑我们实现功能的半成品的项目。
遇到Spring的错误，就看最后一个错误就行了，前提是只有一处错误。
SpringError_one:
Exception in thread "main" org.springframework.beans.factory.NoUniqueBeanDefinitionException:
No qualifying bean of type [com.atguigu.spring.mod.Person] is defined: expected single matching bean but found 2: person,person1
错误说明：使用getbean（class）方法获取对象，由于该类对象有多个，不知道该取哪一个报错.
解决方案：推荐改为使用getbean（String id，class ）两个条件获取.
SpringError_two:
Caused by: java.lang.NoSuchMethodException: com.atguigu.spring.mod.Person.&lt;init&gt;()
at java.lang.Class.getConstructor0(Unknown Source)
at java.lang.Class.getDeclaredConstructor(Unknown Source)
at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:80)
... 14 more
错误说明：用反射生成对象时只能调用无参构造，错误为没有找到对应类中的无参构造。
解决方案：加入无参构造.
SpringError_three:
Caused by: java.lang.IllegalStateException: Cannot convert value of type [java.util.ArrayList] to required type [com.atguigu.spring.di.Student] for property 'students[0]': no matching editors or conversion strategy found
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c32ba664ad203a17fee2da3ab182eaf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06fb099e8f29f4ee2afb3d489dca02ee/" rel="bookmark">
			eclipse中jsp文件的“＜%@“出现报错的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		友友们!!!eclipse中jsp文件的"&lt;%@"出现报错的解决方案如下 1.在报错的项目上右键,Build Path----&gt;Configure Build Path
2.Librarires----&gt;Add LiLibrary
(注意:点击Librariredias后,需要选中下面的Modulepath,否则右侧选项为灰色无法选中状态)
3.Server Runtime----&gt;Next----&gt;选中Apache Tomcat v9.0----&gt;Finish
然后就解决问题啦 !!!
(小编也在努力学习更多哟!以后会多多分享哒!)
希望对友友们有所帮助!!!!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60197c2ae86355b0ccc28bfb5d4af42a/" rel="bookmark">
			c# winfrom richtextbox设置显示比例和行间距
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		winform窗口设置显示比例很简单：
richTextBox3.ZoomFactor =(float) 1.2; 通常设置为120%会看起来舒服一点，比例可以自己随便调
至于行间距其实很简单，百度上搜索的都不好用，要么太复杂要么没有作用。
richTextBox2.Focus(); SendKeys.Send("^a"); //Thread.Sleep(800); SendKeys.SendWait("^5"); 先将焦点锁定要需要发送快捷键的文本框，然后发送组合键crl+a，全选之后，再发送组合键ctrl +5 ，用过word的人都知道，1.5倍行距是ctrl+5,在richtextbox中同样也适用。
1倍行距，ctrl+1
两倍行距，ctrl +2
1.5倍行距，ctrl+5
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2804867c5972c86dd82762c9648e264b/" rel="bookmark">
			JAVA开篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 JAVA开篇1、计算机语言的发展历史2、JAVA简史3、JAVA体系结构4、JAVA的特性和优势5、JAVA核心机制之垃圾收集机制6、核心机制之JAVA跨平台原理7、JAVA核心机制之对比C语言的跨平台原理8、JAVA常用的DOS命令9、JDK的下载、安装、卸载10、notepad++的安装11、第一段程序编译、执行12、程序中的常见错误13、编译方式14、扩展知识classpath环境变量15、扩展知识JAVA_HOME环境变量16、JAVA API 文档17、代码量统计工具的使用18、单行注释和多行注释19、文档注释20、反编译工具的使用21、JDK、JRE、JVM区别 JAVA开篇 1、计算机语言的发展历史 ​ 首先， 先提及计算机发展史上的鼻祖人物，第一位则是被誉为 “计算机科学与人工智能” 之父，图灵。图灵·维基百科
​ 另一位是被后人称为"计算机之父"和"博弈论之父"，冯诺依曼。冯诺依曼·维基百科
​ 计算机语言的发展历史， 简单概之，即机器语言==&gt;汇编语言==&gt;高级语言。参考阅读
​ 说到这里， 顺带查看一下冯诺曼体系结构。
2、JAVA简史 ​ 2.2 JAVA语言的发展史
3、JAVA体系结构 4、JAVA的特性和优势 ​ 2.2.4 JAVA的特性和优势
5、JAVA核心机制之垃圾收集机制 6、核心机制之JAVA跨平台原理 跨平台性：
核心机制：
7、JAVA核心机制之对比C语言的跨平台原理 ​ C语言的跨平台原理：
JAVA跨平台的原理：
小结：
8、JAVA常用的DOS命令 ​（1） 切换盘符： c: d: e: f: 没有大小写区分
（2） 显示当前目录详细信息，dir命令
（3） 改变当前目录： cd命令
（4） cls清屏命令
（5） 创建目录命令： md
（6） 删除目录命令： rd
（7） 复制文件命令： copy
（8）删除文件命令： del
9、JDK的下载、安装、卸载 官网下载链接：JDK1.8下载链接
环境变量配置如下（win10）：
查看版本信息：java -version
卸载示意：点击控制面板， 卸载程序功能
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2804867c5972c86dd82762c9648e264b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5ad9e2440235bc1952b6b9d63b288f8/" rel="bookmark">
			C# 内存回收
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 常用方式：
A）类文件中占用内存较大的全局变量，公共变量，类私有变量及类的实例用完之后手动设置为null或Dispose(),对局部变量不需要置null，但局部的实例需要Dispose或置null。
B）占用内存较大的变量或实例，在循环创建这些类或实例的地方适当进行置null或Dispose()后进行GC.Collect();
2. 结合代码业务进行代码重构：
A) 将主程序中的功能模块化，如封装到动态库中后，通过订阅的方式不再进行主动的业务请求，降低主进程负担。
B) 对程序中会频繁重复使用的类如心跳，网络监控和弹出窗体，历史信息类等，避免重复实例化，通过定义全局唯一静态变量的方式即单例模式实现循环使用。
C) 优化代码或重构
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af5f4dbaa06bbae856fac1e7f711381e/" rel="bookmark">
			windows spice协议连接PVE虚拟机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编辑PVE 名称9059虚拟机配置文件
vim /etc/pve/qemu-server/9059.conf 添加行
增加虚拟机端口9059和密码xxxxx
args: -spice 'port=9059,password=xxxxxxxxx,seamless-migration=on,addr=0.0.0.0' 安装windows 客户端 virt-viewer
virt-viewer下载地址
安装完成后建立bat脚本
@echo off cd /d "C:\Program Files\VirtViewer v9.0-256\bin\" remote-viewer.exe spice://10.109.6.60:9059 -f VirtViewer v9.0-256 这里填写安装的版本真实目录我安装的是9.0
10.109.6.60:9059 这里填写服务器地址和PVE配置的虚拟机端口
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b009460f5d446623ee47f9595f663588/" rel="bookmark">
			C面试题--汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、C语言基础面试题1. gcc编译器编译的完整流程，分别有什么作用？2.什么是回调函数？3.地址能否使用 printf函数中的 %u形式打印？4.结构体与共用体（联合体）的区别5. static、const、volatile关键字有什么作用？static：静止、静态const：只读volatile ：防止编译器优化 6.声明变量和定义变量的区别7.赋值与赋初值有什么不同？8.局部变量和全局变量能否重名9.如何引用一个已经定义过的外部变量10.全局变量和局部变量的存储方式有什么区别？10-附加：内存的分段11. const 与 # define 相比有何优点？12.数组与指针的区别是什么？13.为什么作为函数形参的数组和指针可以互换？14.形参和实参有什么区别？15.指针、数组和地址之间的关系是的什么？16. void指针就是空指针吗？他有什么作用？17.与内存息息相关的重要概念有哪些？18. #include&lt;&gt; 和 #include”” 有什么区别？18.0 gcc附加19. x=x+1 , x+=1 , x++ 哪个效率高？20.为无符号类型变量赋值时，数据类型应怎样转换？ 二、Linux基础1. 字符设备、块设备、管道等在Linux下有个统称叫什么？2.查看一个文件的类型常用的有几种方式引申 3.Linux下常用的安装工具？4.分别解释shell命令、shell、shell脚本5.printf与scanf操作的是否是同一个文件6. Linux常用的文件系统类型？如何查看文件系统类型？7. windows下有没有文件系统？文件系统有何作用？8.头文件和库文件一般在哪个路径下？9.系统如何区别同名的文件10.系统如何区别不同的进程。11.查看文件有哪些命令12.如修改文件的权限13.什么是符号链接？ 三、数据结构1.数据结构主要研究的是什么？2.数组和链表的区别3.快速排序的算法4. hash查找的算法5.判断单链表是否有环6.判断一个括号字符串是否匹配正确，如果括号有多种，怎么做？如（（[]））正确，[[(()错误 四. IO进程1.标准IO和文件IO区别？文件IO-系统调用标准IO-库函数 2.简述流指针？--文件指针、文件流指针3.简述系统调用？3.1 简述库函数4.简述静态库和动态库的区别？5.如何将程序执行直接运行于后台？前台后台切换 6.进程的状态7.什么是僵尸进程？7-8.孤儿进程8.简述创建子进程中的写时拷贝技术？9.多线程较多进程的优势？10.线程池的使用？----再看看11.线程池的组成部分？12.线程的同步互斥机制？13.简述互斥锁的实现原理？14.简述死锁的情景？15.简述信号量的原理？16.简述进程的通信机制？17.管道的通信原理？18.用户进程对信号的响应方式？19.共享内存通信原理？ 五. 网络编程1. ISO七层网络通信结构和TCP/IP四层网络通信结构ISO七层网络模型TCP/IP四层网络模型 2. tcp通信的优缺点2.3 TCP为什么要进行三次握手3. udp通信的优缺点4. pool与select的区别（select poll epoll的区别）select、poll、epoll机制的特点5. io模型有哪几种6. 如何实现tcp并发服务器7. 网络超时检测的本质和实现方式8. TCP 网络编程流程9. UDP网络编程流程10. UDP本地通信需要注意哪些方面11. 怎么修改文件描述符的标志位--文件状态标志位12. sqlite数据库的基本使用，包括增删改查13. 基于UDP的聊天室如何实现数据群发14. 在线词典如何实现查询单词15. TCP和UDP的区别TCP与UDP区别总结： 16. OSI七层网络模式，每层的主要作用，主要的协议17. TCP 粘包18. TCP的三次握手和四次挥手分别作用，主要做什么19. 如何实现并发服务器，并发服务器的实现方式有什么异同20.线程和进程的区别，多线程和多进程编程的特点 六.C++1. new、delete、malloc、free关系2. delete与 delete []区别3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b009460f5d446623ee47f9595f663588/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e46153297e9c457dfc1776312d942c9a/" rel="bookmark">
			Grafana&amp;&amp;Zabbix
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Grafana&amp;Zabbix
一、Grafana简介
Grafana是一款用Go语言开发的开源数据可视化工具，可以做数据监控和数据统计，带有告警功能。目前使用grafana的公司有很多，如paypal、ebay、intel等。
二、Grafana特性
可视化：快速和灵活的客户端图形具有多种选项。面板插件为许多不同的方式可视化指标和日志。报警：可视化地为最重要的指标定义警报规则。Grafana将持续评估它们，并发送通知。通知：警报更改状态时，它会发出通知。接收电子邮件通知。动态仪表盘：使用模板变量创建动态和可重用的仪表板，这些模板变量作为下拉菜单出现在仪表板顶部。混合数据源：在同一个图中混合不同的数据源!可以根据每个查询指定数据源。这甚至适用于自定义数据源。注释：注释来自不同数据源图表。将鼠标悬停在事件上可以显示完整的事件元数据和标记。过滤器：过滤器允许您动态创建新的键/值过滤器，这些过滤器将自动应用于使用该数据源的所有查询。 三、Grafana安装
//下载安装
wget https://dl.grafana.com/oss/release/grafana-7.3.4-1.x86_64.rpm [root@localhost ~]# yum install grafana-7.3.4-1.x86_64.rpm 启动&amp;&amp;自启动
[root@localhost ~]# systemctl daemon-reload [root@localhost ~]# systemctl start grafana-server [root@localhost ~]# systemctl enable grafana-server [root@localhost ~]# netstat -plnt |grep 3000 查看版本
grafana-server -v 安装grafana-zabbix插件(Using grafana-cli tool)
grafana-cli plugins list-remote grafana-cli plugins install alexanderzobnin-zabbix-app service grafana-server restart 插件默认安装在/var/lib/grafana/plugins目录下
http://IP:3000/ 打开grafana界面，打开后输入admin/admin登录，登陆后按提示更改admin密码。
zabbix数据源
首先需要使能zabbix插件，在grafana左边栏-设置子菜单中点击-“Plugins”，在插件列表中找到并点击zabbix（如果没找到，说明你的插件安装未成功）。点击“enable”按钮正式启用zabbix插件。
1.API地址填写：设置Zabbix API地址http://ip:port/api_jsonrpc.php
例如http://192.168.10.10:80/api_jsonrpc.php
或http://192.168.10.10:80/zabbix/api_jsonrpc.php
这个URL的前半部分其实就是你的zabbix访问地址，因人而异。后半部分可能有无/zabbix.
2.连接API的用户名密码：grafana需要获取所有的组和主机
需要注意：
1、这里API信息填写好以后，点击连接可能会报错：Could not connect to given url！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e46153297e9c457dfc1776312d942c9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73d36f7b468d8e255e3f05c5879a3a21/" rel="bookmark">
			产生随机数的代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.产生随机数
/**
* 产生指定范围的随机数[0,max]
* @param max 上限
* @return 随机整数
*/
public static int getRandom(int max){
return new Random().nextInt(max+1);//[0,max)
} 2. /**
* 产生指定范围的随机数[min,max]
* @param min 下限
* @param max 上限
* @return 随机整数
*/
public static int getRandom(int min,int max){ //[10,30]---[0,20]+10---[0,21)+10
//return Math.random();//[0,1) 0.1122333
return (int)(Math.random()*(max-min+1))+min;
} 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90016384be1e0fe942294cae88186609/" rel="bookmark">
			matlab将数据写入到excel中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种：
将数据转化为cell块，从A1单元格写起
% xlswrite('info_10*2.xls ','sheet1','B2:B4') clear; clc; a=[1 2 3 4 5 6 ];%三组数据 b=[11 22 33 44 55 66]; c=[12 23 34 45 56 61]; data = [a' b' c'];%把数据保存到data中，其中a'的'表示转置 [m p]=size(data); data_cell = mat2cell(data,ones(m,1),ones(p,1));%matrix转变成cell title={'a','b','c'};%添加变量名称 result=[title;data_cell];%归纳变量名称和数据 %------------默认保存到当前工作存储路径 s=xlswrite('parameter.xlsx',result);%保存文件 %------------如果要保存到某个文件夹 [n,q]=uiputfile({'*.xlxs'},'请保存您的Excel文件');%其中*可以改成文件名 xlswrite([q,n],result);%保存文件 %------------如果需要读取Excel中的数据 x=xlsread('parameter.xls'); disp(x) 第二种：
如果要写入的数据是M，将数据M写入到excel表的方法有以下几种，filename为excel表的文件名，
1.如果不写表头，不指定特定的sheet，直接调用xlswrite('filename', M)；
2.如果不写表头，指定特定的sheet，直接调用xlswrite('filename', M, sheet)；
3.写表头，title={'ID' 'value' 'count'}; 使用xlswrite('filename', tiltle, sheet)；
然后再写数据M，使用xlswrite('filename', M, sheet ‘A2’)；表示从A2开始写数据。
如： xlswrite('WSQ.xls ',B,'sheet2','T2:T4') %将B值的结果写入名为WSQ的excel表格文件：sheet2的T2到T4单元格 第三种：写入txt
1. 用matlab将二维数组写入txt文件 a: 比方说 矩阵A 为 A=[1 2 3;4 5 6]; 那么程序为 fid=fopen('A1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90016384be1e0fe942294cae88186609/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33f1777ef943484d0af98d8621324b47/" rel="bookmark">
			VS2019 &#43; Qt5.12 配置完成后，无法打开 Qt 源文件解决方案(非常实用)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注：本文主要是解决 VS 无法打开 Qt 源文件问题，关于 VS + Qt 配置问题，网上一搜一大堆，各个版本都有，这里就不做详细阐述了；
最近自己在使用 VS2019 建立 Qt 工程的时候，遇到了无法打开 Qt 源文件问题，在网上阅读了大量的经验贴之后任然无法解决问题，大概花费了自己一个下午的时间，最后问题得以解决；这里我把自己解决问题的办法分享给大家，希望对大家有所帮助；废话不多说，下面开始整活！！！
开始整活 :
在 VS + Qt 配置完成后，如果出现 Qt 头文件无法包含问题，即在包含头文件时现如下情况
，则需要查看自己在以下三个方面是否完成配置：
1、选择 Qt 模块
在自己的Qt项目中进行一下操作：
（1）点击 扩展 — Qt VS Tools — Qt Project Settings
（2）找到 Qt Installation 选择 msvc2017_64;
（3）找到 Qt Modules 至少选择 core、gui、ui_tools、widgets，其他模块可根据自己项目需要自行选择；
2、VC++ 目录下的包含目录和库目录
（1）在包含目录中添加自己 Qt 安装目录下的 ...\msvc2017_64\include ;
（2）在库目录中添加自己 Qt 安装目录下的 ...\msvc2017_64\lib ;
3、C/C++ 下的附加包含目录
在常规 —附加包含目录中添加自己 Qt 安装目录下的 ...\msvc2017_64\include ;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33f1777ef943484d0af98d8621324b47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbd4e377d934a879e784319f536cefee/" rel="bookmark">
			Spring 如何管理 bean
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文转载自：https://blog.csdn.net/l18848956739/article/details/80917853
常常听老师说容器，容器是什么？Spring 中是如何体现的？一直有疑惑，这两天看了一下Spring 管理 bean 的 Demo，对于 Spring 中的容器有了简单的认识。
本文只是对 bean 的一个超级简单的理解，实际 Spring 中的 bean 复杂多了
我们知道，容器是一个空间的概念，一般理解为可盛放物体的地方。在 Spring 容器通常理解为 BeanFactory 或者 ApplicationContext。我们知道 Spring 的 IoC 容器能够帮我们创建对象，对象交给 Spring 管理之后我们就不用手动去 new 对象。
BeanFactory 与 ApplicationContext 的区别是什么？
BeanFactory 采用了工厂设计模式，负责读取 bean 配置文档，管理 bean 的加载，实例化，维护 bean 之间的依赖关系，负责 bean 的声明周期ApplicationContext 除了提供上述 BeanFactory 所能提供的功能之外，还提供了更完整的框架功能：国际化支持、AOP、事务等BeanFactory 在解析配置文件时并不会初始化对象,只有在使用对象 getBean() 才会对该对象进行初始化，而 ApplicationContext 在解析配置文件时对配置文件中的所有对象都初始化了，getBean() 方法只是获取对象的过程。 ApplicationContext 是如何管理 Bean 呢？下面这个 Demo 简单模仿了这个原理：
建立一个类PersonServiceBean，并在xml文件中进行配置
public class PersonServiceBean implements PersonService { public void save(){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbd4e377d934a879e784319f536cefee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/faf5e63ddd2d5e103563a240f5a3aefe/" rel="bookmark">
			Hive启动报错：java.lang.ClassNotFoundException: org.apache.tez.dag.api.TezConfiguration
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;!-- Hive启动报错： Caused by: java.lang.ClassNotFoundException: org.apache.tez.dag.api.TezConfiguration 出现问题的原因： 因为没有集成tez，重启后依然会报错，但是60000ms后会自动重试启动（一般重试后会启动成功） 这算是一个遗留问题，但是不影响客户端正常连接，只是启动时间会多了60秒。 解决方案： 配置文件hive-site.xml中的hive.execution.engine属性值由tez修改为mr --&gt; &lt;property&gt; &lt;name&gt;hive.execution.engine&lt;/name&gt; &lt;value&gt;mr&lt;/value&gt; &lt;/property&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf5a1a260a51a3b74bc9ad34cc308e72/" rel="bookmark">
			IoC 的实现原理 - 反射和工厂模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文转载自：https://blog.csdn.net/fuzhongmin05/article/details/61614873
反射机制概念 我们考虑一个场景，如果我们在程序运行时，一个对象想要检视自己所拥有的成员属性，该如何操作？再考虑另一个场景，如果我们想要在运行期获得某个类的Class信息如它的属性、构造方法、一般方法后再考虑是否创建它的对象，这种情况该怎么办呢？这就需要用到反射！
我们.java文件在编译后会变成.class文件，这就像是个镜面，本身是.java，在镜中是.class，他们其实是一样的；那么同理，我们看到镜子的反射是.class，就能通过反编译，了解到.java文件的本来面目。
对于反射，官方给出的概念：
反射是Java语言的一个特性，它允许程序在运行时（注意不是编译的时候）来进行自我检查并且对内部的成员进行操作。例如它允许一个Java类获取它所有的成员变量和方法并且显示出来。
反射主要是指程序可以访问，检测和修改它本身状态或行为的一种能力，并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义。在Java中，只要给定类的名字，那么就可以通过反射机制来获得类的所有信息。
反射是Java中一种强大的工具，能够使我们很方便的创建灵活的代码，这些代码可以再运行时装配，无需在组件之间进行源代码链接。但是反射使用不当会成本很高！类中有什么信息，利用反射机制就能可以获得什么信息，不过前提是得知道类的名字。
反射机制的作用 在运行时判断任意一个对象所属的类；
在运行时获取类的对象；
在运行时访问java对象的属性，方法，构造方法等。
首先要搞清楚为什么要用反射机制？直接创建对象不就可以了吗，这就涉及到了动态与静态的概念。
静态编译：在编译时确定类型，绑定对象，即通过。
动态编译：运行时确定类型，绑定对象。动态编译最大限度发挥了Java的灵活性，体现了多态的应用，有以降低类之间的藕合性。
反射机制的优缺点 反射机制的优点：可以实现动态创建对象和编译，体现出很大的灵活性（特别是在J2EE的开发中它的灵活性就表现的十分明显）。通过反射机制我们可以获得类的各种内容，进行反编译。对于JAVA这种先编译再运行的语言来说，反射机制可以使代码更加灵活，更加容易实现面向对象。 比如，一个大型的软件，不可能一次就把把它设计得很完美，把这个程序编译后，发布了，当发现需要更新某些功能时，我们不可能要用户把以前的卸载，再重新安装新的版本，假如这样的话，这个软件肯定是没有多少人用的。采用静态的话，需要把整个程序重新编译一次才可以实现功能的更新，而采用反射机制的话，它就可以不用卸载，只需要在运行时动态地创建和编译，就可以实现该功能。
反射机制的缺点：对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且让它满足我们的要求。这类操作总是慢于直接执行相同的操作。 反射与工厂模式实现IOC Spring中的IoC的实现原理就是工厂模式加反射机制。 我们首先看一下不用反射机制时的工厂模式：
interface fruit{ public abstract void eat(); } class Apple implements fruit{ public void eat(){ System.out.println("Apple"); } } class Orange implements fruit{ public void eat(){ System.out.println("Orange"); } } //构造工厂类 //也就是说以后如果我们在添加其他的实例的时候只需要修改工厂类就行了 class Factory{ public static fruit getInstance(String fruitName){ fruit f=null; if("Apple".equals(fruitName)){ f=new Apple(); } if("Orange".equals(fruitName)){ f=new Orange(); } return f; } } class hello{ public static void main(String[] a){ fruit f=Factory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf5a1a260a51a3b74bc9ad34cc308e72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1108cf00e35c9b7b415b8931b91f421/" rel="bookmark">
			opencv之图像基本操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、图像简介 图像主要是由一个个像素点组成。
计算机中的像素点的取值范围为0~255，数值大小表示该点的亮度。
RGB称为图像的颜色通道，其中R表示红色通道，G表示绿色通道，B表示蓝色通道。
灰度图只有一个通道，该通道主要用于表示亮度。
2、读取图像 OpenCV 提供了函数 cv2.imread() 来读取图像，该函数支持各种静态图像格式，比如 *.jpg、*.png、*.jp2、*.dib、*.bmp、*.sr、*.ras 等等。
语法格式为：
retval = cv2.imread( filename[, flags] )
retval ：返回值，其值是读取到的图像。如果未读到图像，返回"None"。
filename ：表示要读取的图像的完整文件名。
flags ：读取标记。该标记用来控制读取文件的类型。
flags标记值 举例：
想要读取当前目录下文件名为 lena.bmp 的图像，并保持按照原有格式读入，则使用的语句为：
lena=cv2.imread( “lena.bmp”, -1)
实际写代码时，步骤如下：
第一步：首先将所需工具包导入；
import cv2 #在python中简称cv2，opencv读取的格式为BGR import matplotlib.pyplot as plt #主要用于绘图展示 import numpy as np #基本数值计算工具包 %matplotlib inline #直接将图展示出来，不需要调用show()函数，仅适用于jupyter notebook img=cv2.imread('G:/pic/ali_two.png') #读取照片，G:\pic\ali_two.png表示该图片所在目录 第二步：将读取的照片显示出来；
#图像的展示 cv2.imshow('image',img) #等待时间按，0表示任意键终止 cv2.waitKey(0) cv2.destroyAllWindows() 结果如下所示：
由于，每次展示图像都需要写以上三行代码，复用率较高，直接封装为函数便于重复使用，如下所示：
def cv_show(name,img): cv2.imshow(name,img) cv2.waitKey(0) cv2.destroyAllWindows() 保存图像常用 cv2.imwrite() 函数，语法格式如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1108cf00e35c9b7b415b8931b91f421/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b261bb929959c92da65175b787e7c95/" rel="bookmark">
			模糊查询（通过真实测试例子来查询）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实体类
@Data
public class UserInfo {
private String name;
}
mapper层
@Mapper
public interface UserInfoMapper {
List&lt;UserInfo&gt; byName(String name);
}
mapper.xml(resources目录下)
&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;
&lt;mapper namespace="com.example.informationmanagement.mapper.UserInfoMapper"&gt;
&lt;resultMap type="com.example.informationmanagement.bean.UserInfo" id="userResultMap"&gt;
&lt;/resultMap&gt;
&lt;!-- 通过名字进行模糊查询 --&gt;
&lt;select id="byName" resultMap="userResultMap"&gt;
select *
from basplu
where name like '%' + #{name} + '%'
&lt;/select&gt;
&lt;/mapper&gt;
service层
@Service
public class UserInfoService {
@Autowired
public UserInfoMapper userInfoMapper;
//通过名字进行模糊查询
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b261bb929959c92da65175b787e7c95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e52d91dca140121086e23ab32c076af8/" rel="bookmark">
			数据结构入门（PTA题库）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
6-1 顺序表操作集 (20 分)
6-2 线性表元素的区间删除 (20 分)
6-3 单链表逆转 (20 分)
6-4 两个有序链表序列的合并 (15 分)
7-1 两个有序序列的中位数 (25 分)
7-2 数组循环左移 (20 分)
7-3 最长连续递增子序列 (20 分)
7-5 求链式线性表的倒数第K项 (20 分)
7-6 两个有序链表序列的合并 (20 分)
7-7 两个有序链表序列的交集 (20 分)
7-8 重排链表 (25 分)
7-9 链表去重 (25 分)
6-1 顺序表操作集 (20 分) 本题要求实现顺序表的操作集。
函数接口定义： List MakeEmpty(); Position Find( List L, ElementType X ); bool Insert( List L, ElementType X, Position P ); bool Delete( List L, Position P ); 其中List结构定义如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e52d91dca140121086e23ab32c076af8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8ff7517f5f0a750d332396ffba0aded/" rel="bookmark">
			OpenCV——高斯滤波
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、高斯滤波二、C++代码三、python代码四、结果展示1、原始图像2、5x5卷积3、9x9卷积 一、高斯滤波 高斯滤波是一种线性平滑滤波，适用于消除高斯噪声，广泛应用于图像处理的减噪过程。 [1] 通俗的讲，高斯滤波就是对整幅图像进行加权平均的过程，每一个像素点的值，都由其本身和邻域内的其他像素值经过加权平均后得到。高斯滤波的具体操作是：用一个模板（或称卷积、掩模）扫描图像中的每一个像素，用模板确定的邻域内像素的加权平均灰度值去替代模板中心像素点的值。
二、C++代码 #include &lt;opencv2\opencv.hpp&gt; #include &lt;iostream&gt; using namespace cv; using namespace std; int main() { Mat img = imread("gauss_noise.png"); if (img.empty()) { cout &lt;&lt; "请确认图像文件名称是否正确" &lt;&lt; endl; return -1; } Mat result_5, result_9; //存放含噪声滤波的结果，后面数字代表滤波器尺寸 //调用均值滤波函数blur()进行滤波 GaussianBlur(img, result_5, Size(5, 5), 0, 0); GaussianBlur(img, result_9, Size(9, 9), 0, 0); //显示含有高斯噪声图像 imshow("img_gauss", img); //显示去噪结果 imshow("result_5gauss", result_5); imshow("result_9gauss", result_9); waitKey(0); return 0; } 三、python代码 import cv2 # ----------------------读取图片----------------------------- img = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8ff7517f5f0a750d332396ffba0aded/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/107aba8ba09b58c10f9fc8e16f1ee1a5/" rel="bookmark">
			org.springframework.web下无servlet包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题截图：
解决方法：在pom.xml导入spring-webmvc依赖
&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89867da5250b60aa3545f7adaf24d220/" rel="bookmark">
			计算机组成原理——运算方法和运算器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运算方法和运算器 一：数据与文字的表示方法1、定点格式定点表示——机器码 2、浮点格式浮点表示——IEEE754 二：移位运算算术移位逻辑移位循化移位 三：定点加法、减法运算补码加法补码减法溢出 四：定点乘法、除法运算原码乘法运算补码乘法运算原码除法运算补码除法运算 五：定点运算器的组成六：浮点运算方法和浮点运算器 一：数据与文字的表示方法 计算机中常用的数据表示格式有两种，一是定点格式，二是浮点格式。
1、定点格式 定点表示：约定机器中所有数据的小数点位置是固定的。由于约定在固定的位置，所以小数点就不再使用记号 " . " 来表示。假设用n+1位数字表示一个定点数x，xn在最左边，并用数值0和1分别表示正号和负号，称为数符；xn-1 到 x0 表示该数的绝对值，称为尾数，则：
①定点纯整数的表示范围：0 ≤ |ｘ| ≤ 2n - 1
②定点纯小数的表示范围：0 ≤ |ｘ| ≤ 1 - 2-n
定点表示——机器码 一般书写所表示的数据称为真值，在计算机中通常把符号位和数字位一起编码来表示相应的数，这些编码称为机器码。常用的机器码有原码、反码、补码和移码。
2、浮点格式 浮点表示：定点数表示的数的范围有限，为了扩展数的表示范围，按照科学记数法表示数据的方式，任何一个二进制数N都可以表示成如下的格式：
N＝M * 2e
M ：尾数，是一个定点纯小数，决定数据的表示精度
e ：指数（阶码），是一个定点纯整数，决定数据的表示范围
(1.75)10 = (1.11)2 = (0.111)2 × 201 = (0.0111)2 × 210
这样就可以把一个数的尾数和阶码在计算机的不同存储单元中分别予以存储，在这种方法中小数点的位置随阶码不同在一定范围内可以移动，这种表示数据的方法称为浮点表示法。
浮点数尾数的规格化
什么是尾数规格化？
下面举一个题来说明一下。
一直浮点数 b 的阶码和尾数分别为 010 和 0.01001，求 b 的真值。
经过计算我们发现结果如下（1B的存储空间）：
我们发现最后一位 1 存不下了，只能把它舍弃，那么也就导致了它的精度降低了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89867da5250b60aa3545f7adaf24d220/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5193c6012f69e4d4c2bd15273107341/" rel="bookmark">
			零基础入门Python数据分析与机器学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前 言
人工智能是目前炙手可热的一个领域，多数互联网公司纷纷表示人工智能将是下一个时代的革命性技术。机器学习属于人工智能的一个重要分支，他更偏向于理论，其目的是研究一种为了让计算机不断从大量数据中学习知识，自动实现知识发现和预测，使结果不断接近目标。
实际工作中我们比较常见的是数据分析的概念，他是用适当的统计分析方法对收集来的大量数据进行分析，以求最大化地开发利用数据，从而发挥其商业价值。目前，数据分析已经是一种比较成熟的技术，而机器学习还处于快速发展的过程中，主要依靠算法和数据进行驱动。
在数据分析和机器学习研究热潮中，相关书籍大多偏重于理论。由于Python是开源免费的，而且目前市场上从零基础深入介绍数据分析和机器学习的书籍较少，鉴于此背景，本书基于最新版本的Python 3.10编写，全面而系统的讲解了基于Python的数据分析和机器学习技术。
本书既包括Python数据分析的主要方法和技巧，又融入了机器学习的案例实战，使广大读者通过对本书的学习，能够轻松快速的掌握数据分析和机器学习的主要方法。本书配套资源中包含案例实战中所采用的数据源，以及教学PPT和学习视频，供读者在阅读本书时练习使用。
本书的内容
第1章介绍数据分析的流程和思维，搭建Python 3.10开发环境，以及必会的库。
第2章介绍Python核心基础，包括数据类型、基础语法、常用高阶函数和编程技巧。
第3章介绍如何进行数据准备，包括数据的读取、索引、切片、聚合、透视、合并等。
第4章介绍NumPy基础知识和操作，包括索引与切片、维度变换、广播机制和矩阵运算。
第5章介绍如何利用Pandas进行数据清洗，包括重复值、缺失值、异常值的检测和处理。
第6章介绍Matplotlib绘图参数设置，包括线条、坐标轴、图例、绘图函数和图形整合等。
第7章介绍机器学习及Sklearn库的基本概念、基本流程、主要算法和自带的主要数据集等。
第8章介绍监督式机器学习算法，包括线性回归、逻辑回归、决策树、K近邻和支持向量机等。
第9章介绍无监督式机器学习算法，包括k均值聚类、主成分分析、关联分析和双聚类分析等。
第10章详细介绍机器学习的挑战，模型的主要评估方法，并通过实际案例介绍模型的调优方法。
第11章介绍基于中文的文本分词、关键词提取技术，以及如何生成词向量和进行中文情感分析。
本书的特色
（1）内容全面，讲解详细
本书是一本内容全面的Python专著，由浅入深，详细介绍了基于Python 3.10的数据分析和机器学习技术，包括软件应用与操作的方法和技巧，对于初学者帮助较大，可以使读者通过对本书的学习，能够轻松快速的提高数据分析和机器学习的综合能力。
本书的读者对象
本书的内容和案例适用于互联网、咨询、零售、能源等行业从事数据分析的读者，可以作为Python软件培训的参考资料，也可以作为高校计算机相关专业本科生、研究生的教材或教学参考书。
由于编者水平所限，书中难免存在错误和不妥之处，敬请广大读者批评指正，作者微信公众号：Hanalyst。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/555f9fd3cec09ce65a31df28f77a0ce6/" rel="bookmark">
			2021-10-5【数据结构/严蔚敏】【串的定长顺序存储表示】【代码实现算法4.1-4.3实现】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线性表 2021-9-14【数据结构/严蔚敏】【顺序表】【代码实现算法2.1-2.7】2021-9-18【数据结构/严蔚敏】【单链表】【代码实现算法2.8-2.12】2021-9-18【数据结构/严蔚敏】【静态链表】【代码实现算法2.13-2.17】2021-9-19【数据结构/严蔚敏】【双向链表】【代码实现算法2.18-2.19】2021-9-19【数据结构/严蔚敏】【带头结点的线性表】【代码实现算法2.20-2.21】2021-9-19【数据结构/严蔚敏】【一元多项式的表示及相加、相减、相乘】【代码实现算法2.22-2.23】2021-9-23【数据结构】【单链表逆置】2021-9-23【数据结构】【顺序表逆置】 栈&amp;队列 2021-9-22【数据结构/严蔚敏】【顺序栈&amp;链式栈&amp;迷宫求解&amp;表达式求值】【代码实现算法3.1-3.5】2021-9-27【数据结构/严蔚敏】【链队列】2021-9-28【数据结构/严蔚敏】【循环队列】 串 2021-10-5【数据结构/严蔚敏】【串的定长顺序存储表示】【代码实现算法4.1-4.3实现】2021-10-5【数据结构/严蔚敏】【串的堆分配存储表示】【代码实现算法4.4实现】 二叉树 2021-10-15【数据结构/严蔚敏】【二叉树基本实现】2021-10-15【数据结构/严蔚敏】【二叉树的前/中/后/递归/非递归遍历&amp;层序遍历】【代码实现算法6.1-6.4】 持续更新中，尽请期待！！！ #include&lt;bits/stdc++.h&gt; using namespace std; #define Status int //--------------串的定长顺序存储表示------------------- #define MAXSTRLEN 255 typedef unsigned char SString[MAXSTRLEN + 1];	//0号单元存放串的长度 Status StrAssign(SString &amp;T, const char *chars) { int len, uncut; int i; len = strlen(chars); if (len &gt; MAXSTRLEN) { T[0] = MAXSTRLEN; uncut = 0; } else { T[0] = len; uncut = 1; } for(i = 1; i &lt;= T[0]; i++) { T[i] = chars[i - 1]; } return uncut; } Status StrCopy(SString &amp;T, SString S) { if (S == NULL) return 0; for(int i = 0; i &lt;= S[0]; i++) T[i] = S[i];	//最后一位'\0' return 1; } Status StrEmpty(SString S) { if (S == NULL) return 0; if (S[0] == 0) return 1; else return 0; } Status StrCompare(SString S, SString T) { if (S &amp;&amp; T == NULL) return 0; for(int i = 1; i &lt;= S[0] &amp;&amp; i &lt;= T[0]; i++) { if (S[i] !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/555f9fd3cec09ce65a31df28f77a0ce6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e221fc3ae12485ef138f2b148056a5f7/" rel="bookmark">
			Spring 单例 bean 的线程安全问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先解释一下什么是单例 bean？
单例的意思就是说在 Spring IoC 容器中只会存在一个 bean 的实例，无论一次调用还是多次调用，始终指向的都是同一个 bean 对象
用代码来解释单例 bean
public class UserService { public void sayHello() { System.out.println("hello"); } } &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- scope 属性就是用来设置 bean 的作用域的，不配置的话默认就是单例，这里显示配置了 singleton --&gt; &lt;bean id="userService" class="com.fyl.springboot.bean.singleton.UserService" scope="singleton"/&gt; &lt;/beans&gt; public class Demo { public static void main(String[] args) { ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("classpath:beans-singleton.xml"); UserService service = context.getBean(UserService.class); UserService service1 = context.getBean(UserService.class); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e221fc3ae12485ef138f2b148056a5f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/616d1642afad3a127fb0cec5b8f368ca/" rel="bookmark">
			安装Tomcat要记得匹配JDK版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在安装Tomcat时一定要注意匹配对应的JDK版本，不然辛辛苦苦装完后发现Tomcat与JDK版本不匹配岂不是要哭死！还好Tomcat官方已经为我们列出了安装某Tomcat版本时需要的JDK版本，网址如下：
Tomcat版本与JDK版本对应关系
以下是从上述网站贴出的最新截图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a53f84eb47badaa61a1001a2e8dadac/" rel="bookmark">
			c&#43;&#43;关键字explicit(面试)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考如下文章：
需要注意的是explicit是c++11新增加的关键字，用以禁止单参数构造函数导致的自动转换。
explicit关键字详解
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c24fced2581ffe2aeaf5801143980637/" rel="bookmark">
			c&#43;&#43;智能指针(面试)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考如下文章
智能指针原理介绍
智能指针模拟源码实现
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bf57cf969034da515a6eb89021943c2/" rel="bookmark">
			springboott整合mybatis-plus和sharding-jdbc实现分库分表和读写分离（含完整项目代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springboott整合mybatis-plus和sharding-jdbc实现分库分表和读写分离（含完整项目代码） 一、整合sharding-jdbc 关于springboot整合sharding-jdbc官网有4种方式，而网上千篇一律都是用.properties文件。我在这里主要是用yml+bean两种方式结合，bean主要是为了实现分片键分片规则更灵活。
1.1引入maven依赖 这里有个小坑，我一开始引入是最新的sharding-jdbc和mybatis-plus的依赖，结果启动项目直接报错。所以个人不建议引用最新的包。
&lt;dependency&gt; &lt;groupId&gt;org.apache.shardingsphere&lt;/groupId&gt; &lt;artifactId&gt;sharding-jdbc-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;4.0.0-RC1&lt;/version&gt; &lt;/dependency&gt; 1.2配置分库分表和读写分离（核心） spring: shardingsphere: datasource: names: "search-center-00,search-center-00-slave,search-center-01,search-center-01-slave" search-center-00: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/search_center_00?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=UTC username: root password: 123456 search-center-00-slave: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3307/search_center_00?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=UTC username: root password: 123456 search-center-01: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/search_center_01?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=UTC username: root password: 123456 search-center-01-slave: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3307/search_center_01?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=UTC username: root password: 123456 sharding: master-slave-rules: search-center-00: master-data-source-name: search-center-00 slave-data-source-names: search-center-00-slave search-center-01: master-data-source-name: search-center-01 slave-data-source-names: search-center-01-slave tables: user: actual-data-nodes: search-center-$-&gt;{(0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bf57cf969034da515a6eb89021943c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58bb53a6d7acdd5ff8ce5bb20a8e72d4/" rel="bookmark">
			【c语言进阶】如此清晰的指针讲解让你再也不怕学不会指针了，硬核指针讲解。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎇前言🎇 在学习c语言中，很多人都觉得指针是一个难点。而同时指针在c语言中又是非常重要的工具，如果不能熟练的掌握指针，c语言的学习是不完整的，本篇文章总结了大家在深入学习指针时所需要掌握的知识。
目录
🎇前言🎇
💎指针初阶内容回顾💎
💎字符指针💎
✨数组指针和指针数组✨
数组指针
指针数组
区分数组指针和指针数组
✨数组传参与指针传参✨
数组的传参
指针的传参
✨函数指针✨
⚖函数指针数组✨
✨回调函数的概念✨
💎指针初阶内容回顾💎 1. 指针就是个变量，用来存放地址，地址唯一标识一块内存空间。
2. 指针的大小是固定的4/8个字节（32位平台/64位平台）。
3. 指针是有类型，指针的类型决定了指针的+-整数的步长，指针解引用操作的时候的权限。
4. 指针的运算
💎字符指针💎 字符指针是一种常见的指针，一般用 char* 来表示：
下面来介绍字符指针的两种常见的使用方法：
一：用来存放字符变量的地址
二：存放常量字符串的地址
请大家思考一个问题此时指针变量p中存放的是什么？是这个常量字符串？还是这个常量字符串的地址？还是这个常量字符串首元素的地址？
很多人第一次见这种字符指针使用方式时，都会下意识的误认p指针存放的是这个常量字符串，但这种想法显然不成立，因为指针的作用是储存地址的，而把常量字符串赋值给指针，指针其实拿到的是这个常量字符串首元素的地址。
由上面的讲述，现在我来考虑这样一个经典的问题：
运行结果是这样的：
这到底是为什么呢？
原因是：我们用这个常量字符串去开辟两个数组时，实际上开辟了两块不同的内存空间，而这个常量字符串本身是存储在内存中的静态区，因此我们拿出它的地址赋值给两个指针时，拿到的是同一块内存空间。
✨数组指针和指针数组✨ 现在我们来介绍并区分一组概念：数组指针和指针数组
数组指针 首先大家思考一个问题：数组指针是数组还是指针呢？
答案是：数组指针是指针，是指向数组的指针。
下面来学习数组指针的定义初始化与使用。
从结果上可以清晰的看出来，两个地址差值是40，刚好是整个数组的空间大小。
在这里出现了一个新朋友 &amp;arr ，下面我们来解释一下 &amp;arr 和arr到底有什么区别。
&amp;数组名和数组名的区别
1：&amp;数组名：这里的数组名代表的是整个数组，所以这句代码的意思是取出整个数组的地址。
2：数组名一般被认为是首元素的地址
补充：数组名什么情况下表示整个数组，什么情况下表示首元素的地址
1：数组名代表整个数组：只有&amp;数组名和sizeof（数组名）即数组名单独放在sizeof的内部。
2：除了上面两种情况，其它所有情况都数组名表示首元素的地址。
指针数组 在大家前面的学习中想必已经了解过整型数组，字符数组，浮点型数组等多种数组。
我们把元素类型是指针的数组称为指针数组。
下面举例介绍指针数组的使用
区分数组指针和指针数组 请大家分辨以下三个变量的类型
1：int *parr1[10];
2：int (*parr2)[10];
3：int (*parr3[10])[5];
给出答案：1：parr1首先与[]结合，说明它是个数组，数组有10个元素每个元素是一个一级整型指针。指针数组
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58bb53a6d7acdd5ff8ce5bb20a8e72d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dda94d0848cbc24114a7809673021700/" rel="bookmark">
			IOC概念和原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.什么是IOC
2.IOC的底层原理
3.IOC过程
4.IOC总结
​​​​​​​
1.什么是IOC IOC即为控制反转，把对象的创建和对象之间的调用过程，交给Spring管理。不需要像se阶段一样new对象。
使用IOC的目的：为了降低耦合度。所谓耦合度就是某模块（类）与其它模块（类）之间的关联、感知和依赖的程度，是衡量代码独立性的一个指标，也是软件工程设计及编码质量评价的一个标准。
2.IOC的底层原理 假如有以上俩个类，传统创建对象我们需要在UesrService类中调用uesrDao中add方法需要先在UesrService中new uesrDao的对象，再调用方法。
传统创建对象致命问题：耦合度高，关联过于紧密，牵一发动全身。
为了降低耦合度，解决方案如下文。
建一个工厂类
通过工厂的设计模式，在UserFactory中返回创建的对象，对象在工厂中得到。这个过程只是降低了UserService和UserDao的耦合度，没有降低到最大限度。此时需要ioc。
3.IOC过程 1.配置xml文件，配置要创建的对象
&lt;bean id="名字" class="路径"&gt;&lt;/bean&gt; 2.假如有上service类和dao类，创建工厂类
class UserFactory { public static UserDao getDao() { String classValue=class属性值; //通过xml解析得到class的值 //通过反射得到对象 Calss clazz=class.forName(classValue); return (UserDao)clazz.newInstance(); //调用newInstance方法此时返回的也是UserDao对象 } } 此时只要修改xml的配置文件，就可以通过工厂返回对象。耦合度进一步降低。
用Spring框架就是简化代码，把耦合度降低。
4.IOC总结 1.IOC本质是个容器，本质上是对象工厂，通过读取配置文件，再通过它用反射来完成。
2.Spring提供的IOC容器的俩种实现方式（俩个接口）：
public class Spring5Test { @Test public void test(){ //加载spring配置文件，ApplicationContext 在加载配置文件时就会创建对象，BeanFactory在下面获取创建对象的时候才会创建对象 ApplicationContext context =new ClassPathXmlApplicationContext("bean1.xml"); //获取配置创建的对象，BeanFactory在此时才会创建对象 User user=context.getBean("user",User.class); user.add(); } } 1.BeanFactory：IOC容器基本实现方式，Spring内部使用接口，一般不提供开发人员使用。
特点：加载配置文件，不会去创建对象。在获取或使用对象时才创建对象。
2.ApplicationContext：可以理解成BeanFactory子接口，比BeanFactory更加强大。面向开发人员。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dda94d0848cbc24114a7809673021700/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/816181835736028b693ec29598da4712/" rel="bookmark">
			ThreadLocal从变量副本的角度解决多线程并发安全问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ThreadLocal从变量副本的角度解决多线程并发安全问题 之前我们讲的高并发场景下的线程安全问题，可以使用Synchronized同步关键字、Lock手动加锁的方式去解决，什么轻量级锁、偏向锁、重量级锁、可重入锁等等，实际上本质都是控制线程，使得多个线程同步的去访问共享资源。之所以多线程存在线程安全问题，就是因为多个线程访问同一个共享资源导致的，多个线程之间属于竞争关系，很容易就会导致数据的不安全。
我们说了加锁实际上保证了各个线程之间同步、有序的去访问共享资源，难道不加锁就没有办法解决多线程安全问题了吗？我们要抓主要矛盾，之所以存在并发安全问题，是因为共享资源只有一个，多线程会竞争获取共享资源，如果同一类共享资源有多个，或者说有多个副本给每一个线程使用呢？这样不就不用加锁了，每一个线程只需要存在自己的那个数据的副本即可，因此也就不存在资源竞争问题，也就保证了多线程下数据的安全。而ThreadLocal类就是给每个线程绑定了变量的本地副本，从而避免线程安全。
接下来我们从源码来看看ThreadLocal类是如何给每一个线程保存变量的本地副本的。
首先我们看看Thread线程类，线程类里面有一个ThreadLocalMap类型的成员变量threadLocals，用来存放当前线程的本地变量
实际上ThreadLocal类有一个ThreadLocalMap内部类，这个内部类你可以认为是一个专门用来维护线程本地变量HashMap集合。
ThreadLocalMap这个类的数据结构是一个Entry类型的数组，用来保存一个个的Entry节点，Entry节点封装了以ThreadLocal实例对象为key，Object对象为value的键值对，保存在ThreadLocalMap中。
ThreadLocal类实际上是对ThreadLocalMap这个内部类的封装，本地变量值最终是存放在ThreadLocalMap中的，ThreadLocal类提供了set()、get()等其他方法，来操作ThreadLocalMap中保存的数据。
ThreadLocal调用set()方法保存本地变量时，首先获取到当前线程，然后调用getMap()方法得到当前线程的ThreadLocalMap，底层实际上是调用ThreadLocalMap的set()方法向这个Map集合中保存数据的
当第一次调用set()方法时，会先调用createMap()方法创建出ThreadLocalMap对象，因此是懒加载的
接着会使用构造方法创建出ThreadLocalMap对象
我们之前说过ThreadLocalMap是一个HashMap集合，因此也有初始容量、加载因子、阈值、散列函数、hashcode值。
ThreadLocalMap的初始容量默认为16，阈值为容量的2/3，利用ThreadLocal的hashcode值，对容量进行取模运算，计算出Entry数组中对应的索引位置。
如果ThreadLocalMap之前已经创建出来了，就会调用set()方法向ThreadLocalMap中添加元素。根据hashcode值计算出数组中对应的索引位置，然后遍历这个map所有的Entry，如果key存在了就进行替换，没有的话就将键值对保存到ThreadLocalMap中。同时在遍历的过程中发现key为null，就会清除掉这个数据，并将新的数据存放到这个索引位置。这主要是释放了内存空间，防止内存泄漏。
如果既没有发生替换，也没有发生可以清除掉的key，那么就会创建一个Entry，保存到计算出的对应的索引位置。
我们说过ThreadLocalMap初始容量默认为16，阈值默认为容量的2/3。在向map中添加完数据时，最后还会进行一次清理工作，如果清理后发现当前map的大小还是大于等于阈值，就会触发扩容机制
ThreadLocalMap扩容机制和HashMap差不多，也是扩容为原来的2倍，然后进行扩容后在再散列，并设置新的阈值。
讲完了set()方法再来讲一讲get()方法。
get()方法首先获取到当前线程，然后调用getMap()方法得到当前线程对应的ThreadLocalMap。如果这个map不为null，就根据key得到对应Entry，并返回对应的value值。
如果map为null，比如在第一次调用get()方法，这个map可能还没创建出来。此时会调用setInitialValue()方法来设置初始值，
并返回这个value，value的默认初始值为null。
我们讲完了ThreadLocal类的set()、get()方法，实际上都是一直在操作ThreadLocalMap这个map集合。而ThreadLocalMap中存放的都是一个个的Entry，Entry的key为ThreadLocal对象，value为对应的本地变量。实际上这个Entry是WeakReference弱引用的子类，这是为了在JVM进行垃圾回收时，能够自动进行回收，防止内存溢出。真正存储数据备份其实就是这个Entry。
ThreadLocal类本质实际上是以线程作为key，通过数据备份的方式，实现了线程间的数据隔离！
既然进行的数据备份，那么肯定就会造成数据冗余，并且随着线程的存活时间增长，存储的备份数据也会越来越多，即使线程结束了生命周期，这些备份数据也很有可能仍然存在。这样就可能造成内存泄漏，进而导致OOM！
ThreadLocal为了解决内存泄漏的问题，也进行了一些相应的处理，比如将存储备份数据的Entry类设置为弱引用类型，这是为了方便在GC时自动回收。而且在set()、get()方法中增加了数据检查，及时清除掉那些key为null的没用的备份数据。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3df85eac5939728238724d8b65aa813f/" rel="bookmark">
			练习4-7 求e的近似值 (15 分)自然常数 e 可以用级数 1&#43;1/1!&#43;1/2!&#43;⋯&#43;1/n!&#43;⋯ 来近似计算。本题要求对给定的非负整数 n，求该级数的前 n&#43;1 项和。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		练习4-7 求e的近似值 (15 分)
自然常数 e 可以用级数 1+1/1!+1/2!+⋯+1/n!+⋯ 来近似计算。本题要求对给定的非负整数 n，求该级数的前 n+1 项和。
输入格式: 输入第一行中给出非负整数 n（≤1000）。
输出格式: 在一行中输出部分和的值，保留小数点后八位。
输入样例: 10 结尾无空行
输出样例: 2.71828180 结尾无空行
#include&lt;stdio.h&gt; int main() { int n = 0; scanf_s("%d", &amp;n); double sum = 1; int i = 0; for (i = 1; i &lt;=n; i++) { int add = 1; int j = 0; for (j = 1; j &lt;= i; j++) { add *= j; } sum += 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3df85eac5939728238724d8b65aa813f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dd6f20b1bdf4b33c988d70e57d822a4/" rel="bookmark">
			(JDBC)java连接数据库，试手登陆注册系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导入jdbc的包 查了查网上的资料，发现导入jdbc的jar包十分繁琐，我就想到了maven。
maven是个十分方便的包管理平台，既然导入jar如此麻烦，使用它会便捷很多。
创建个带maven的web项目。
打开里面的pom.xml进行导入包。
&lt;dependency&gt; &lt;groupId&gt;net.jahhan&lt;/groupId&gt; &lt;artifactId&gt;jdbc-api&lt;/artifactId&gt; &lt;version&gt;1.0.0-RELEASE&lt;/version&gt; &lt;/dependency&gt; 这个是jdbc的jar包，直接写在maven中。
然后刷新一下maven，jar就会自动下载安装。
先创建mysql数据库(这里已经提前创建好了)
`后面是注册和登录模块的
import javax.swing.*; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.sql.*; public class register {//注册 static String username; static String passwords; public static String getUsername() { return username; } public static String getPassword() { return passwords; } public register(){ JFrame jf=new JFrame("注册界面"); final JPanel jPanel=new JPanel(); jf.setBounds(300,300,300,120); jPanel.setBounds(300,300,300,300); jPanel.setBackground(Color.darkGray); final JTextField jt1=new JTextField("账号",20); final JTextField jt2=new JTextField("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0dd6f20b1bdf4b33c988d70e57d822a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0f31973956a9f1d28d3eeab6bc6e33d/" rel="bookmark">
			Mac、Linux批量创建、批量删除文件及文件夹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（1）批量创建文件夹 假设文件夹的名称名分别从dir_1 -dir_10
在shell命令中用{1..10}，表示通配符：
mkdir dir_{1..10}
（2）批量创建文件 文件名分别从doc_1.txt -doc_10.txt
touch doc_{1:10}.txt
（3）批量删除文件夹 rm -rf dir_{1..10}
批量删除文件 rm doc_{1..10}.txt
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5779c4677475082227303fd76c7eb036/" rel="bookmark">
			http用户登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http基于用户登录 和前面一样创建好http后
先编辑文本
这里配置的是只有xiaoming、xiaohong 这两个用户才可以登录
然后，配置一下用户文件，不能用mkdir来创建
[root@localhost conf.d]# htpasswd -c /etc/httpd/mymima xiaoming
然后输入设置的密码
[root@localhost conf.d]# htpasswd /etc/httpd/mymima xiaohong
因为前面已经-c了，就不在需要了
配置好后，创建目录
[root@localhost conf.d]# mkdir /www/0
[root@localhost conf.d]# echo asdjaskd &gt; /www/0/index.html
然后重启Http服务器，然后去浏览器测试一下
输入相对应的用户和密码即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8914952ac41d84885935af6192ff2a91/" rel="bookmark">
			GAMES101笔记（十六）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 蒙特卡罗积分 对于一个不规则的图形，我们对其求定积分的过程可以转换为在积分域内对其中每一个xi进行采样（取f(xi)的值和 b-a 的值的乘积），然后将求得的采样值求平均就得到了这一个积分的值。
用数学表示就可以表示如下：
假设每种采样的分布概率一样，我们称其为pdf采样。
下面为一个例子：
在这样一个例子里面，pdf采样下的概率为1/(b-a)
代入积分式可得：
路径追踪 这里于Whited风格的光线追踪进行对比：
问题一：
对于粗糙的物体，每一次反射不一定都是直接的镜面反射，Whited风格则不能准确地描述其他漫反射的情况。
问题二：
Whited不考虑光线弹射多次的情况，而现实中光线打在一个物体上，还会继续弹射到其他物体的表面上。
将渲染方程按照蒙特卡洛积分的形式进行分解，可以得到如下式子：
再把这些分解的项组合起来得到最后的蒙特卡洛形式的渲染方程：
只考虑直接光照时（从反射点出发可以直接打在光源上）：
引入间接光照（从反射点出发打在了物体上）：
我们这个时候只需要把那个物体经过光源反射来的光线看成一个“光源"就可以了。
上一个式子中，对于一个光源，如果打出了100根光线，经过一个弹射后数据将变成了100的平方，这样经过多次弹射后数据量会发生指数倍增长。
而再蒙特卡洛积分中，我们将这一个光源发出的光线只经过一次采样，也就是N = 1 了，那么我们可以得到如下式子，而这就是路径追踪。
但是这样下去噪声会非常大。
对于这一问题我们可以多追踪几条穿过这一个像素的光线，然后将得到的Radiance求平均。
最后代码过程如下:
对于光线不断弹射的过程，也就是一个无限递归的问题，该怎么判断来结束递归，是一个问题。
怎么结束递归，这里用到了一个 俄罗斯轮盘赌(RR) 算法。
我们假设经过递归后的结果为Lo，然后我们再假设递归的概率为p，结束递归的概率为 1-p 。再递归时，返回值设置为 Lo/p 。这样，无论我们经过了多少次递归，这一个事件的期望都是Lo，也就是说最后的结果都是对的。
总结在代码里面如下：
而这样仍然有一些问题就是当我们采样时，一个像素穿过的光线定义过少，就会出现大片的不清晰的情况，如下图：
而且除了总体的光线数量的问题，我们的光源四散发射出均匀的光线，只有一小部分满足一定角度的会打在物体上，大量的光线打出去不能对物体着色。
在二维的光源平面上均匀采样，用的pdf也就是1/A(A为光源面积)，而渲染方程是一个积分，是定义在立体角上的，也就是在那个半球上的。
在蒙特卡洛积分中，我们对定义域采样，然后也是在定义域上进行积分，那么现在蒙特卡洛方法就不能用了？
这时，我们可以把渲染方程转换为对光源的积分就可以了，也就是通过dw和dA的关系进行转换。
最后，我们就可以把渲染方程重写。
现在，我们就可以把之前我们在着色点上往各个方向去采样（打不打地到光源随缘）转换为直接对光源采样。
那么，我们就可以把着色点接收到的光线转为为两部分，一个是光源发出的，一个非光源反射的。
现在，我们就可以把代码改成如下形式：
那么有遮挡的情况呢？
做一条从p点到光源的连线判断有没有打在其他物体上的判断即可。
路径追踪终于完了，哭了快~
而光线追踪现在除了路径追踪方法外还有一些其他方法：
单向和双向路径追踪光子映射光线传输结合了双向路径追踪的VCM方法和所有方法的UPBP方法
这节课是真难，又哭了~ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b35c064c7ba17cd451fc00cb02b969a8/" rel="bookmark">
			C语言 线性表的基本操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、线性表的定义 线性表是一种最常用也是最简单的数据结构。简单来讲，一个线性表是n个数据元素的有限排列，在不同情况下，每个数据元素有着不同的含义。
二、线性表的组成 一个线性表的结构体由三部分组成：1.线性表中的元素（Elem）2.线性表的当前长度（Length）3、线性表当前分配的储存空间大小（ListSize，通常情况下ListSize&gt;Length）
三、头文件以及数据的定义 #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;malloc.h&gt; #include&lt;windows.h&gt; #define TRUE 1 #define FALSE 0 #define OK 1 #define ERROR 0 #define INFEASIBLE -1 #define OVERFLOW -2 typedef int Status; typedef int ElemType; #define LIST_INIT_SIZE 100 #define LISTINCREMENT 10 使用typedef与define是为了提高程序的可读性。
四、线性表的具体操作 1.结构体创建 typedef struct { ElemType *elem; //线性表的基地址 int length; //线性表的当前长度 int listsize; //线性表当前储存空间大小 }SqList; 2.构建新线性表 第一步：使用malloc函数为线性表动态分配内存空间，由于申请内存空间时可能有也可能没有，所以需要自行判断是否申请成功，再进行后续操作。
Status InitList(SqList *L) { L-&gt;length = 0; L-&gt;listsize = LIST_INIT_SIZE; L-&gt;elem = (ElemType *)malloc(LIST_INIT_SIZE * sizeof(ElemType)); if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b35c064c7ba17cd451fc00cb02b969a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a2aa9f6221d31e35fa49087664bcc6c/" rel="bookmark">
			2021年氧化工艺考试题库及氧化工艺考试技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题库来源：安全生产模拟考试一点通公众号小程序
安全生产模拟考试一点通：氧化工艺考试题库考前必练！安全生产模拟考试一点通每个月更新氧化工艺考试技巧题目及答案！多做几遍，其实通过氧化工艺作业模拟考试很简单。
1、【单选题】 氨在空气中的允许浓度为()mg/㎥。（ C ）
A、10
B、20
C、30
2、【单选题】 清洁生产的内容包括清洁的能源、清洁的生产过程、清洁的产品、()。（ A ）
A、清洁的服务
B、清洁的资源
C、清洁的原材料
3、【单选题】 关于毒物源的控制,下列设计错误的是()。（ B ）
A、密闭设备应尽量减少漏风的缝隙和孔洞,但可设置必要的观察窗和操作口
B、同一车间厂房内存在分别逸散氯气、汽油等毒物的多个发生源,可设置统一的局部排风系统
C、柜形排毒罩内有热源存在时,应在排风罩上部排风
4、【单选题】压力等级为0MPr的蒸汽,其温度一般为()℃。（ C ）
A、160-165
B、180-190
C、230-240
5、【单选题】 通常的爆炸极限是在常温、常压的标准条件下测定出来的,它随()的变化而变化。（ B ）
A、压力、容积
B、压力、温度
C、温度、容积
6、【单选题】 真空过滤机破真空后,现场首先要()。（ B ）
A、停进料
B、关母液阀
C、关下料闸板阀
7、【单选题】对于某一种类风险,生产经营单位应当根据存在的()和可能发生的事故类型,制定相应的专项应急预案。（ B ）
A、一般危险源
B、重大危险源
C、危险目标
8、【单选题】 以下能引起污水PH值超标的是()。（ C ）
A、消防水泄漏
B、冲洗场地
C、胺液泄漏
9、【单选题】高速泵启动时,无流量、无压力的原因不会是()。（ C ）
A、泵没有完全充满液体
B、过滤网堵塞
C、出口阀没有开
10、【单选题】 《中国人民共和国消防法》规定,进行电焊、气焊等具有火灾危险的作业人员和自动消防系统的操作人员,必须(),并严格遵守消防安全操作规程。（ A ）
A、持证上岗
B、经过培训
C、服从领导
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a2aa9f6221d31e35fa49087664bcc6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c00b24161a0a15c697e1d9e3611895c/" rel="bookmark">
			【源码】走一遍源码弄清ArrayList容器的扩容机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【源码】走一遍源码弄清ArrayList容器的扩容机制 首先我们来看看ArraysList容器在整个Java集合框架中所处的位置
由此可见ArrayList是Java集合框架中，两大派系中Collection接口的子接口List的实现类
我们从源码入手可以看到ArrayList底层数据结构实际上是一个**Object类型的数组**，由于Object是所有类的父类，所以ArrayList集合可以存放任意类型的元素，并且存放的元素是有序的、可重复的、可随机访问的。
接下来我们就以add()方法为突破口，来解读一下ArrayList的源码，以及它的扩容机制
我们要想向ArrayList结合添加元素，首先得创建出一个ArrayList对象出来，ArrayList的构造方法有3种：
无参构造器
使用无参构造器创建一个对象时，默认创建的是一个空集合，它的初始容量是10。什么鬼？空集合怎么还容量为10，这不自相矛盾吗？我这里说的空集合指的是，这个集合刚创建出来，在还没有调用add()方法向集合中添加第一个元素之前，这个集合是空的。而所说的初始容量为10，指的是当你调用add()方法向集合中添加第一个元素时，这个集合的容量大小会被扩容到10，这个10就是指的初始容量。可以我们为向容器中添加了一个元素，为什么要扩容到10呢？这不浪费内存空间吗？实际上这是考虑的扩容的问题，你创建这个容器肯定不止存放一个元素，我们之所以冗余了一些空间，就是为了防止不断频繁扩容导致性能低下的问题。
带初始容量参数的构造函数
我们在创建一个容器时，在构造方法中可以传入初始容量大小，如果传入的初始容量大小为0的话，就会创建一个空的容器。
注意！这里的DEFAULTCAPACITY_EMPTY_ELEMENTDATA和无参构造方法中的EMPTY_ELEMENTDATA虽然都是空集合，但是这两个空集合是有区别的，DEFAULTCAPACITY_EMPTY_ELEMENTDATA在添加第一个元素时，明确指定了扩容到默认的初始容量大小。而EMPTY_ELEMENTDATA由于指定的初始容量为0，所以在扩容的时候，会调用grow()方法走扩容的流程。
传入一个集合参数的构造器
在创建ArrayList容器时，可以给构造器传入一个集合参数，利用Arrays.copy()方法复制这些集合中元素，原来创建一个新的集合
现在我们利用构造器创建出来了一个ArrayList容器，接下来就调用add()方法开始向容器中添加元素。
在向容器中添加元素时，首先会调用ensureCapacityInternal()方法确保容器容量足够，得到最小扩容量
如果是使用默认的无参构造器创建的容器，并且是添加第一个元素，minCapacity 为 10，也就是当前添加元素的操作，需要容器的容量大小为minCapacity
确定了最小容器容量之后，就调用ensureExplicitCapacity()方法根据得到的最小容量来判断到底需不需要进行扩容
只有当需要的最小容量大于当前容器的最大容量时，最大的容量也就是数组的长度，就会调用grow()方法进行扩容
从grow()方法可以看出ArrayList容器的扩容机制是变为原来容量的1.5倍
为了防止在添加第一个元素时，由于空集合的容量为0，扩大1.5倍之后计算出的新的容量还是0,这样情况，源码中还通过比较扩容后的新的容量与需要的最小容量，来判断是否是第一次添加元素，如果是就直接将扩容后的新的容量改成需要的最小容量。这样就避免了第一次扩容扩不起来的问题。
如果说扩容后的容量超过了ArrayList的最大容量，也就是扩容1.5倍后的容量大于了Integer.MAX_VALUE - 8。此时就需要判断需要的最小容量是否超过了ArrayList的最大容量。
如果需要的最小容量超过了ArrayList最大容量，此时我们就不能按照1.5倍扩容了，直接返回Integer.Max_VALUE，如果说没有超过ArrayList最大容量，就返回最大容量
扩容完之后，就调用Arrays.copyOf()方法，开始将原来容器中的所有元素复制到扩容后的容量中
Arrays.copyOf()方法底层调用的实际上是System.arraycopy()本地方法，将原数组中的数据进行拷贝,并返回新的数组
至此，ArrayList容器的扩容流程就完成了！
我们注意到ArrayList的增删改查相关的方法都没有使用Synchronized同步关键字，或者说没有使用其他同步机制，因此ArrayList容器是线程不安全的！
与ArrayList容器对标的是Vector这个容器
Vector的底层实现和ArrayList的底层实现类似，也是使用Object类型的数组存放元素。而且默认初始容量也为10
与ArrayList不同的地方在于Vector的扩容的方法使用了Synchronized同步关键字，因此是**线程安全的！**而且Vector扩容机制是扩大2倍！而ArrayList是扩大1.5倍！
一般开发中都是使用ArrayList容器，Vector容器基本上不再使用，虽然Vector使用Synchronized保证了线程安全，但是效率十分低下，如果考虑到线程安全问题，可以使用JUC并发集合！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea4dedd3e4fe28cc8bc51d35dc484a8d/" rel="bookmark">
			npm install报错no template named ‘remove_cv_t’ in namespace ‘std’； did you mean ‘remove_cv’? - Stack O
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		node.js - error: no template named ‘remove_cv_t’ in namespace ‘std’; did you mean ‘remove_cv’? - Stack Overflow 使用npm install或yarn install时一直报错，翻了好久百度才发现是依赖中 node-sass 的版本不支持 Node.js16 ，只能在 15 及以下的环境下运行，通过 node 版本控制器 n 对使用的 node 进行降级就可以正常安装 node-sass ，安装当前 node 的稳定版本就可以正常使用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1985492d68a4c1a7c1a4b802b6f56466/" rel="bookmark">
			C&#43;&#43;学习（三五二）未找到框架“.NETFramework,Version=v4.0”的引用程序集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\MSBuild\15.0\Bin\Microsoft.Common.CurrentVersion.targets(1179,5): error MSB3644: 未找到框架“.NETFramework,Version=v4.0”的引用程序集。若要解决此问题，请安装此框架版本的 SDK 或 Targeting Pack，或将应用程序的目标重新指向已装有 SDK 或 Targeting Pack 的框架版本。请注意，将从全局程序集缓存(GAC)解析程序集，并将使用这些程序集替换引用程序集。因此，程序集的目标可能未正确指向您所预期的框架。
项目类型是makefile，改为application则不会出现该问题。
gdal_vs2017.vcxproj
C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\Common7\IDE\VC\VCTargets\Microsoft.Cpp.targets
C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\Common7\IDE\VC\VCTargets\Microsoft.Cpp.Current.targets，分歧发生在这里
&lt;Import Condition="'$(ConfigurationType)' != 'Makefile'" Project="$(_PlatformFolder)\Platform.targets"/&gt; &lt;Import Condition="'$(ConfigurationType)' == 'Makefile'" Project="$(VCTargetsPath)\Microsoft.MakeFile.Targets"/&gt; C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\Common7\IDE\VC\VCTargets\Microsoft.MakeFile.targets
C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\MSBuild\15.0\Bin\Microsoft.Common.targets
C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\MSBuild\15.0\Bin\Microsoft.Common.CurrentVersion.targets，问题出现在这里
&lt;GetReferenceAssemblyPaths Condition="'$(TargetFrameworkMoniker)' != '' and ('$(_TargetFrameworkDirectories)' == '' or '$(_FullFrameworkReferenceAssemblyPaths)' == '')" TargetFrameworkMoniker="$(TargetFrameworkMoniker)" RootPath="$(TargetFrameworkRootPath)" TargetFrameworkFallbackSearchPaths="$(TargetFrameworkFallbackSearchPaths)" BypassFrameworkInstallChecks="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1985492d68a4c1a7c1a4b802b6f56466/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/433c7d078b9c9b7f62c9bdfb52f7bb5a/" rel="bookmark">
			UNIAPP小程序端授权登陆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 //获取用户token uni.login({ provider: 'weixin', success: function (loginRes) { console.log(loginRes); //获取用户信息，传给后端换取openid/uuid uni.getUserInfo({ provider: 'weixin', success: function (infoRes) { console.log(infoRes) //调用接口传递参数 let parames = { code: loginRes.code, encryptedData: infoRes.encryptedData, iv: infoRes.iv, signature: infoRes.signature, rawData: infoRes.rawData }; } }); }, fail: function(err){ uni.showToast({ icon: 'none', title: '授权失败，请重新授权' }) } }); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c87f269d501ccce17c92fbaa9f8c9fff/" rel="bookmark">
			获取其他类的变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		获取其他类的变量（成员变量，全局变量） 文章目录 获取其他类的变量（成员变量，全局变量）全局变量成员变量 全局变量 有时候需要其他类的变量，但是却无法调用，使用super类只能放在静态方法上，十分麻烦。
今天小编推出了java强大的功能-----反射机制。
先上代码。
import java.lang.reflect.Field; public class refince {//要被获取变量的类 int a=90; } class get extends refince{ public static void main(String[] args) throws Exception{ Class c1 = Class.forName("refince");//获取类反射 Object o=c1.newInstance();//创建新对象 Field f=c1.getDeclaredField("a");//获取变量 System.out.println(f.get(o));//未设置前获取值 f.set(o,12);//设置变量的值 System.out.println(f.get(o));//获取变量 } } 但是经过测试，不能加入private， 不然无法访问变量；
成员变量 访问其中的成员变量其实也不能，加入实体类方法就行了；
上代码
import java.lang.reflect.Field; public class refince {//要被获取变量的类 int a; public void setA() { int ab=999; this.a = ab; } public int getA() { return a; } } class get{ public static void main(String[] args){ refince r=new refince(); r.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c87f269d501ccce17c92fbaa9f8c9fff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03ba98c744e56e3bbab9368844085ad0/" rel="bookmark">
			Unity运行高版本项目，报错Library\PackageCache\的一种解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天直接复制粘贴一个版本只高了一点的项目，
报错：Library\PackageCache…
我一看名字叫Cache，应该是缓存；我写的代码我清楚，里面没有用到这几个包的样子。
于是来到这个目录下，直接删掉Library\PackageCache\com.unity.collab-proxy文件夹。
这样下次重启的话还是会有这个问题。
需要找到项目根目录/Packages/manifest.json，删掉相应的行即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4ba6a0d5baf6829e41d2463fba96c0b/" rel="bookmark">
			信息系统项目管理师教材【下载PDF】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		知识点考点汇总资料，论文参考及素材，考试公式计算题汇总，信息系统项目管理师答题卡样式等等。下载链接查看原文：信息系统项目管理师教材pdf - 科科过官网信息系统项目管理师备考资料分享 ：链接: https://pan.baidu.com/s/1ZR055uAFSDRYzzwPuO1PeA 提取码: 7pvr https://www.kekeguo.net/a/1008.html
若有帮助，欢迎转载。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e21cbaee346783b18d9ff1cadc5faef8/" rel="bookmark">
			Nacos 2.0&#43;版本 docker部署要多暴露两个端口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新版本部署 Nacos2.0版本相比1.X新增了gRPC的通信方式，因此需要增加2个端口。新增端口是在配置的主端口(server.port)基础上，进行一定偏移量自动生成。
端口与主端口的偏移量描述98481000客户端gRPC请求服务端端口，用于客户端向服务端发起连接和请求98491001服务端gRPC请求服务端端口，用于服务间同步等 也就是在同一台机器上，如果搭建集群，建议使用8848，8850，8852，这种有间隔的端口，否则可能导致端口冲突。
端口转发 使用VIP/nginx请求时，需要配置成TCP转发，不能配置http2转发，否则连接会被nginx断开。
兼容性 Nacos2.0的服务端完全兼容1.X客户端。Nacos2.0客户端由于使用了gRPC，无法兼容Nacos1.X服务端，请勿使用2.0以上版本客户端连接Nacos1.X服务端。
Nacos2.0增加了9848，9849端口来进行GRPC通信，我需要在application.properties中额外配置吗？ 不需要，这两个端口在Nacos2.0内部是通过8848+1000以及8848+1001这种偏移量方式计算出来的，不需要用户额外在配置文件中配置。但如果使用的是docker或存在端口转发方式启动，需要把这两个端口进行配置。
启动nacos2.0时希望用nginx 代理，9848这个端口怎样处理，要通过nginx暴露出来么？以及docker是否需要映射？ 如果存在防火墙或者nginx端口转发问题，需要进行相应的端口暴露配置。如在nginx中，在已经暴露8848(x)的基础上，需要额外暴露9848（x+1000)。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60106774cea787ac22610b3594a6c948/" rel="bookmark">
			Linux添加PYTHONPATH方法以及3种修改环境变量方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一：用于当前终端 export PATH=$PATH:&lt;你的要加入的路径&gt; 上面的方法只适用于当前终端，一旦当前终端关闭或在另一个终端中，则无效；
方法二：用于当前用户 在用户主目录下有一个 .bashrc 隐藏文件，可以在此文件中加入 PATH 的设置如下：
（1）gedit ~/.bashrc
（2）export PATH=&lt;你的要加入的路径&gt;:$PATH
（3）加入多个路径：export PATH=&lt;你要加入的路径1&gt;:&lt;你要加入的路径2&gt;: … :$PATH
当中每个路径要以冒号分隔，这样每次登录都会生效。
添加PYTHONPATH的方法也是这样，在.bashrc中添加：
export PYTHONPATH=/home/zhaoying/anaconda3/envs/oneflow/bin:/home/zhaoying/anaconda3/bin:$PYTHONPATH PYTHONPATH是Python搜索路径，默认我们import的模块都会从PYTHONPATH里面寻找。保存后在终端输入 source ~/.bashrc 使环境变量立即生效.
方法三：用于所有用户 sudo gedit /etc/profile 加入：
export PATH=&lt;你要加入的路径&gt;:$PATH 终端输入：echo $PATH 可以查看环境变量
例：
export PYTHONPATH=$PYTHONPATH:/home/usrname/models:/home/usrname/models/one 意思是将models以及其目录下的one文件夹加入系统环境中。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a117b9d0ba49356b0f453ae9837b362/" rel="bookmark">
			12枚硬币称重问题(面试)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： 12枚硬币，其中11枚真币1枚假币，现有一架天平，最少称多少次可以找出这枚假币并且知道假币和真币的相对重量。
答案是三次，称重过程描述如下。
第一步：分组，分三组，1 2 3 4为一组，5 6 7 8为一组，9 10 11 12为一组。
第二步，称重。
第一种情况
第一次称重：用1 2 3 4 和 5 6 7 8 称重，如果1 2 3 4=4 5 7 8，那么假币就在9 10 11 12这一组里面，接下来的任务就是在9 10 11 12这一组里面找到假币。第二次称重，用三枚真币(一般选择1 2 3)与9 10 11称重，如果1 2 3=8 9 10，那么12就是假币，但是不能确定假币的轻重。第三次称重，用一枚真币(一般选择1)与12称重，如果1&gt;12，那么假币12为轻，如果1&lt;12，那么假币12为重。
逻辑表达式：
1 2 3 4=5 6 7 81 2 3=8 9 101&gt;12或者1&lt;12 第二种情况
第一次称重：用1 2 3 4 和 5 6 7 8 称重，如果1 2 3 4=4 5 7 8，那么假币就在9 10 11 12这一组里面，接下来的任务就是在9 10 11 12这一组里面找到假币。第二次称重，用三枚真币(一般选择1 2 3)与9 10 11称重，如果1 2 3&lt;9 10 11，那么假币就在9 10 11之间，但是且假币较重。第三次称重，如果9&gt;10，那么假币为9，如果9&lt;10，那么假币为10，如果9=10，那么假币为11。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a117b9d0ba49356b0f453ae9837b362/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd19eb278eb761129a9a2fd596dcb57c/" rel="bookmark">
			【Transformer】一文搞懂Transformer | CV领域中Transformer应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 阅读本文的基础：一、发展历史：二、从上向下的理解Transformer1、Transformer整体结构简单介绍2、Transformer中的Self-attention（1）引入（2）self-attention（3）并行化计算（4）Multi-head Self-attention（5）位置编码Positional Encoding 3、Transformer整体结构详细介绍(1)整体(2)编码器部分(3)解码器部分 4、示例5、Transformer的compress与accelerate 三、用Transformer解决计算机视觉问题1、iGPT（简介）2、ViT（简介）（1）简介：（2）整体流程： 3、DETR（详解）（1）流程简介：（2）详细流程：1）CNN Backbone+位置编码1.a 上边的分支：位置编码1.a下边的分支：特征提取 2）Encoder3）Decoder4）后处理：匈牙利算法4.a 基于CNN的检测算法的label assignment：4.b DETR的label assignment： 4、Deformable DETR（只言片语）（1）答案1：（2）答案2：（3）答案3： 阅读本文的基础： 需要对【视觉卷积神经网络】比较熟悉。需要对【目标分类、检测任务】比较熟悉。需要对【RNN】有了解。 一、发展历史： （参考：A Survey on Visual Transformer 2020.12.23）
（参考Cheng He）
起源：2017年6月谷歌《Attention is all you need》检测和分割：DETR（CNN+ Transformer，更简单和更灵活的pipeline）分类：Vision Transformer（only Transformer：SOTA，减少训练计算资源）像素级图像补全：Image GPT车道标记检测：End-to-end Lane Shape Prediction with Transformers
二、从上向下的理解Transformer 本章的思路为：1、整体结构简单介绍 =&gt; 2、细节 =&gt; 3、整体结构详细介绍 =&gt; 4、Transformer的示例 1、Transformer整体结构简单介绍 （参考 龙心尘）
Transformer由Encoders和Decoders组成，解决Seq2Seq问题Encoders = 6 × \times × encoder， 这6个encoder结构相同，但不共享参数。Decoders = 6 × \times × decoder， 这6个decoder结构相同，但不共享参数。
每个encoder都 = “self-attention” + “feed-forward network”。 self-attention，自注意力，获得上下文信息。feed-forward network，每个位置的单词对应的前馈神经网络都完全一样。（BP层和平常用的FC层的区别，参考：https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd19eb278eb761129a9a2fd596dcb57c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52a010309f841bb57b0e37a92f943dbb/" rel="bookmark">
			Effective Java 读书笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 第二章 创建对象和销毁对象1. 用静态工厂方法代替构造器2. 遇到多个构造器参数时要考虑使用构建器3. 用私有构造器或者枚举类型强化 Singleton 属性4. 通过私有构造器强化不可实例化的能力5. 优先考虑依赖注入来引用资源6. 避免创建不必要的对象7. 消除过期的对象引用8. 避免使用终结方法和清除方法9. try-with-resources 优先于 try-finally 第三章 对所有对象都通用的方法10. 覆盖 equals 时请遵守通用约定11. 覆盖 equals 方法时总要覆盖 hashCode12. 始终要覆盖 toString13. 谨慎地覆盖 clone14. 考虑实现 Comparable 接口 第四章 类和接口15. 使类和成员的可访问性最小化16. 要在公有类中使用访问方法而非公有域17. 使可变性最小化18. 复合优先于继承19. 要么设计继承并提供文档说明，要么禁止继承20. 接口优于抽象类21. 为后代设计接口22. 接口只用于定义类型23. 类层次优于标签类24. 静态成员类优于非静态成员类25. 限制源文件为单个顶级类 第五章 泛型26. 请不要使用原生态类型27. 消除非受检的警告28. 列表由于数组29. 优先考虑泛型30. 优先考虑泛型方法31. 利用有限制通配符来提升 API 的灵活性32. 谨慎并用泛型和可变参数33. 优先考虑类型安全的异构容器 第六章 枚举和注解34. 用 enum 代替 int 常量35. 用实例域代替序数36. 用 EnumSet 代替位域37. 用 EnumMap 代替序数索引38.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52a010309f841bb57b0e37a92f943dbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b07469ab81366c5535f8290de3adc877/" rel="bookmark">
			linux系统屏幕触摸校准
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、安装工具 xinput-calibrator工具：sudo apt-get install xinput-calibrator
xinput工具：sudo apt-get insatll xinput
2、校准实例 （1）查看触摸设备id：xinput_calibrator --list
上面可知：device name：ILITEK ILITEK-TP，device id：11
（2）校准触摸设备：xinput_calibrator -v --device &lt;device name or id&gt;
此处为xinput_calibrator -v --device 11
（3）在显示的屏幕触摸校准页面进行页面校准，终端会输出屏幕校准后的数据
（4）将屏幕校准数据根据提示复制至/etc/X11/xorg.conf.d/目录下的99-touchscreen-evdev.conf文件中，部分发行版系统下的路径为/usr/share/X11/xorg.conf.d/。如果没有99-touchscreen-evdev.conf文件可手动创建一个。
Section "InputClass" Identifier "calibration" MatchProduct "ILITEK ILITEK-TP" Option "MinX" "20207" Option "MaxX" "20343" Option "MinY" "52844" Option "MaxY" "54101" Option "SwapXY" "1" # unless it was already set to 1 Option "InvertX" "0" # unless it was already set Option "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b07469ab81366c5535f8290de3adc877/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7389443c79ec098cd1e87a597c97bea7/" rel="bookmark">
			Verilog和C的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Verilog是硬件描述语言，在编译下载到FPGA之后，会生成电路，所以Verilog全部是并行处理与运行的； C语言是软件语言，编译下载到单片机/CPU之后，还是软件指令，而不会根据你的代码生成相应的硬件电路，而单片机/CPU处理软件指令需要取址、译码、执行， 是串行执行的。
Verilog和C的区别也是FPGA和单片机/CPU的区别， 由于FPGA全部并行处理， 所以处理速度非常快，这个是FPGA的最大优势，这一点是单片机/CPU替代不了的。
Verilog和C之间的区别
1、定义： Verilog是用于模拟电子系统的硬件描述语言（HDL），而C是允许结构化编程的通用编程语言。因此，这是Verilog和C之间的主要区别。
2、文件扩展名： 文件扩展名是Verilog和C之间的另一个区别.Verilog文件具有.v或.vh文件扩展名，而C文件具有.c文件扩展名。
3、用法 Verilog有助于设计和描述数字系统，而C有助于构建操作系统，数据库，编译器，解释器，网络驱动程序等。
Verilog是一种硬件描述语言（HDL），有助于描述网络交换机，微处理器，触发器等数字系统。因此，可以使用该语言描述数字系统的硬件。
C是一种支持结构化编程的高级通用编程语言。C语言的开发人员是Dennis Ritchie。它是许多编程语言的基础，如Python，Java等。程序员可以很容易地理解C程序，但计算机不理解它们。因此，编译器将C源代码转换为等效的机器代码。计算机了解此机器代码，并执行程序中定义的任务。C程序的执行速度比基于解释器的编程语言（如PHP，Python等）更快。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a0de5143d093b6b677dac0a9b383ffc/" rel="bookmark">
			Verilog简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Verilog是一种硬件描述语言，以文本形式来描述数字系统硬件的结构和行为的语言，用它可以表示逻辑电路图、逻辑表达式，还可以表示数字逻辑系统所完成的逻辑功能。
数字电路设计者利用这种语言，可以从顶层到底层逐层描述自己的设计思想，用一系列分层次的模块来表示极其复杂的数字系统。然后利用电子设计自动化（ EDA）工具，逐层进行仿真验证，再把其中需要变为实际电路的模块组合，经过自动综合工具转换到门级电路网表。接下来，再用专用集成电路ASIC或FPGA自动布局布线工具，把网表转换为要实现的具体电路结构。
Verilog语言最初是于1983年由Gateway Design Automation公司为其模拟器产品开发的硬件建模语言。由于他们的模拟、仿真器产品的广泛使用， Verilog HDL作为一种便于使用且实用的语言逐渐为众多设计者所接受。在一次努力增加语言普及性的活动中， Verilog HDL语言于1990年被推向公众领域。 Verilog语言于1995年成为IEEE标准，称为IEEE Std1364－ 1995，也就是通常所说的Verilog-95。
设计人员在使用Verilog-95的过程中发现了一些可改进之处。为了解决用户在使用此版本Verilog过程中反映的问题， Verilog进行了修正和扩展，这个扩展后的版本后来成为了电气电子工程师学会Std1364-2001标准，即通常所说的Verilog-2001。 Verilog-2001是对Verilog-95的一个重大改进版本，它具备一些新的实用功能，例如敏感列表、多维数组、生成语句块、命名端口连接等。目前， Verilog-2001是Verilog的最主流版本，被大多数商业电子设计自动化软件支持。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a2be4b152352c1fdc215b5d069b477c/" rel="bookmark">
			代码在线编辑codemirror在React中使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初次学习codemirror笔记，下附完整代码
成果图
安装
yarn add codemirror 引入
import CodeMirror from 'codemirror'; import 'codemirror/lib/codemirror.css' options配置 1.行号 lineNumbers:true//是否显示左侧行号 firstLineNumber: 1//从哪个数字开始计数行。默认值为 1。 2.编码模式
模式可查看 https://codemirror.net/mode/
import "codemirror/mode/python/python.js"; mode: "python", // 要使用的模式//https://codemirror.net/mode/ 3.滚动和换行
lineWrapping: true,//滚动或换行 scrollbarStyle: null,//滚动条样式，为null时隐藏滚动条 4.主题
//引入主题文件（可选择自己喜欢的） import 'codemirror/theme/material.css'; import 'codemirror/theme/solarized.css' //options中配置 theme: 'material',//主题 5.代码折叠
// 引入 import 'codemirror/addon/fold/foldgutter.css'; import 'codemirror/addon/fold/foldcode.js'; import 'codemirror/addon/fold/foldgutter.js'; import 'codemirror/addon/fold/brace-fold.js'; import 'codemirror/addon/fold/comment-fold.js'; import 'codemirror/addon/fold/indent-fold.js'; //options中配置 // 在行槽中添加行号显示器、折叠器、语法检测器 gutters: ["CodeMirror-linenumbers", "CodeMirror-foldgutter", "CodeMirror-lint-markers"], foldGutter: true, // 启用行槽中的代码折叠 6.缩进
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a2be4b152352c1fdc215b5d069b477c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba386a7e5e8fdb54051628f38e843f94/" rel="bookmark">
			Windows RPC 初体验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 需求挑战使用中可能遇到的问题资料 RPC的需求还是很多的，例如，我们注入一个dll到某程序中，而控制端是独立的exe。 此时 exe &lt;=RPC=&gt; dll 有没有一款 好用的简单的RPC呢？
笔者也有这个需求，经朋友推荐和演示，了解并尝试使用了 Windows RPC，发现真的简单。
需求 教程直接官网：
https://docs.microsoft.com/en-us/windows/win32/rpc/tutorial
一步一步做非常简单。
无需赘言。
挑战 我认为 使用 Windows RPC 的 最大挑战为 字符串(或Buffer) 的回传
为了实现能从服务端 返回给 客户端字符串，我查询了若干资料。为了防止以后用的时候再去找，所以记录于此。
https://stackoverflow.com/questions/6256400/return-a-string-from-win32-rpc-call
使用中可能遇到的问题 会生成 Hello_h.h 和 Hello.h 什么区别？
我认为：~前者的 h意思是high-version.指rpc5 ，而后者指的是 rpc4~，include 其中之一即可添加库 rpcrt4.lib照抄例子会报错1
hello_ClientIfHandle 它会提示你它不存在，实际它就定义在 自动生成的 hello.h文件中,它的实际名字 并不是这个，而是 类似 INTERFACENAME_v1_0_c_ifspec 和 INTERFACENAME_v1_0_s_ifspec找到它 替换 例子。 照抄例子会报错2
有一步让你添加两个函数 在服务端 ：
有两种解决方案：
创建 .c 文件
你需要定义一个 .c 文件或者在里面进行定义直接 在 cpp 中进行声明
即 exter "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba386a7e5e8fdb54051628f38e843f94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d617c95eac6d18dbe7f3a4b3a24b05b0/" rel="bookmark">
			【源码】看一看Spring如何使用三级缓存解决循环依赖问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【源码】看一看Spring如何使用三级缓存解决循环依赖问题 我们之前文章讲Bean的创建过程中，提到了如果当前bean依赖的其它bean，就会调用getBean()方法把依赖的bean先创建出来
可是你有没有想过，如果当前Bean依赖于另一个Bean，而另一个Bean又就形成了依赖于当前Bean，或者当前Bean依赖于自己，这样依赖关系形成了一个闭环。这就是我们这篇文章将要说的Bean的循环依赖问题！
首先我们要明确Spring不是能够解决所有情况下的循环依赖问题的，只能解决：
出现循环依赖的Bean必须是单例Bean依赖注入的方式不能全是构造器注入 IOC容器默认的单例Singleton的场景，并且使用setter方法注入，是支持循环依赖的，不会报错。看下面A和B产生循环依赖的例子。
但是原型Prototype的场景是不支持循环依赖的，会报错。
再来说说全是构造器注入的方式，下面的代码，A中注入B的方式是通过构造器，B中注入A的方式也是通过构造器，这个时候循环依赖是**无法被解决的。**同样也会报错！
Caused by: org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name 'a': Requested bean is currently in creation: Is there an unresolvable circular reference? 那么Spring到底是如何解决Bean的循环依赖的问题？实际上是利用了三级缓存来解决的！
只有单例的bean会通过三级缓存提前暴露来解决循环依赖问题，而非单例的bean，每次从容器中获取都是一个新的对象，都会重新创建，所以非单例的bean是没有缓存的，不会将其放到三级缓存中
我们之前说过在创建Bean的时候，首先调用getBean()方法
getBean()方法会调用getSingleton()方法先尝试从缓存中获取这个Bean
三级缓存的核心就是getSingleton()方法！
整个缓存分为三级（本质是三个Map集合）：
一级缓存 singletonObjects：存放已经经历完了完整生命周期的Bean对象。即已经初始化好了的Bean二级缓存 earlySingletonObjects：存放早期暴露出来的Bean对象，Bean的生命周期还未结束，属性还没有填充完整。即存放的是已经实例化但是还没有初始化的Bean三级缓存 singletonFactories：存放可以生成Bean的工厂。假设A类实现了FactoryBean，那么依赖注入的时候不是A类，而是A类产生的Bean。二级缓存中存放的就是从这个工厂获取的Bean。 （1）getSingleton()方法首先会在一级缓存中查找，如果没有就返回null
（2）在一级缓存中没有查找到这个Bean，说明这个Bean还没有被完整的创建出来，此时会调用getSingleton()参数为ObjectFactory重载方法
（3）重载个这个方法会先将beanName放入到singletonsCurrentlyInCreation这个集合中，标志着这个单例Bean正在创建
（4）标记完这个Bean正在创建以后，就开始调用createBean()方法来创建这个Bean。这个createBean()方法我们已经很熟悉了，在之前的创建Bean的过程那篇文章中已经详细讲过了。再实例化这个Bean之前，BeanPostProcessor后置处理器会尝试返回这个Bean的代理对象，也就是说，开启了AOP代理之后，当前Bean注入并不是依赖的Bean，而是注入的这个Bean的代理对象。如果返回的代理对象不为null，就直接返回这个代理对象来替代想要创建的这个Bean，如果返回的代理对象为null，那么就会继续执行剩下的流程，对这个将要创建的Bean进行实例化、属性填充、初始化。
（5）如果没有直接返回代理对象，就会调用doCreateBean()方法，
调用createBeanInstance()方法先利用反射机制或者构造器实例化这个Bean
只有当这个实例化的Bean，是正在创建中的并且是单例Bean，而且允许提前暴露，才会把这个Bean添加到三级缓存中。
（6）实例化完成并且添加到了三级缓存之后，就开始对这个Bean进行属性填充。如果在属性填充的过程中发现当前Bean依赖于其它Bean，就会查找这个依赖的Bean，和之前说的流程也是一样的，先从缓存中查找，如果没有找到，就会创建这个依赖的的Bean，并填充属性。
（7）如果在给依赖的Bean填充属性的发现它也依赖于上一个Bean，造成了循环依赖的情况。**此时两个互相依赖的Bean都是实例化完了，但是还没有进行属性填充，也没有进行初始化。**当前Bean会调用getSingleton()方法，依次从一级、二级、三级缓存中去找依赖的上一个Bean。
我们说上一个Bean之前已经被实例化并且添加到了三级缓存中，于是当前Bean就会从三级缓存中获取到上一个BeanFactory的创建工厂，通过beanFactory就可以得到上一个实例化的Bean。由于通过工厂已经实例化出来一个Bean，所以把上一个Bean放到二级缓存中，同时从三级缓存中删除，这样之后其它bean如果也依赖于这个Bean的话，就可以直接从二级缓存中获取到了。
（8）当前Bean得到所依赖的上一个Bean实例之后，就可以继续进行属性填充，并且进行初始化了
（9）这样当前Bean被创建出来之后放到了一级缓存中，此时上一个Bean还是处于创建中的状态，那么回过头来继续创建这个处于创建中状态的Bean，由于它所依赖的Bean已经创建出来并且放到了一级缓存中，所以它可以直接从一级缓存中直接获取到这个依赖的Bean，然后继续完成属性填充和初始化。最后也会把自己放到一级缓存中。
这样多个Bean之间的循环依赖的问题就解决了，实际上依靠的是Bean的“中间态”这个概念，指的就是已经实例化但是没有进行初始化的Bean。相当于一个Bean的半成品。但是如果是使用构造器注入的bean，不能解决循环依赖问题。因为实例化过程就是通过构造器创建的，Bean如果连实例化都没有完成，也就不能不可能放到二级缓存中提前暴露出来。
到这你是不是觉得三级缓存为什么要使用工厂而不是直接使用引用？换而言之，为什么需要这个三级缓存，直接通过二级缓存暴露一个Bean引用不行吗？
实际上这个工厂的目的在于延迟对实例化阶段生成的对象的代理，只有真正发生循环依赖的时候，才去提前生成代理对象，否则只会创建一个工厂并将其放入到三级缓存中，但是不会去通过这个工厂去真正创建对象。如果要使用二级缓存解决循环依赖，意味着所有Bean在实例化后就要完成AOP代理。
也就是说，在没有AOP代理的时候，三级缓存实际上直接返回的是实例化阶段的Bean对象，并存放到二级缓存中，依赖注入的也是这个实例化Bean对象。但是在有AOP代理时，三级缓存中的Bean工厂才会创建一个代理对象并返回，并将代理对象存放二级缓存中。并且在Bean对象初始化完成之后，通过禁用三级缓存，从二级缓存中获取代理对象来替换Bean本身，并存放到一级缓存中。
所以简单总结一下源码的实现：
Spring使用了三级缓存来解决多个Bean循环依赖的问题，这三个缓存实际上是三个Map集合，一级缓存用来保存已经创建好的单例Bean，二级缓存用来提前暴露Bean，三级缓存用来提前暴露Bean工厂。
假设A、B产生了循环依赖，那么在实例化A的时候就会将它放入到三级缓存中，接着在填充属性时，发现依赖了B，那么就会执行同样的流程，将B实例化后也放入到三级缓存中。当B进行属性填充的时候，又发现B也依赖于A，这时候就会从三级缓冲中查找到提前暴露出来的A工厂，通过A工厂得到实例化的A，然后把A放入到二级缓存中，同时从三级缓存中移除掉。B得到A之后就会继续进行属性填充以及初始化工作，当B被完整的创建出来之后就会放到一级缓存中，并出清掉二级缓存，此时B的创建流程结束。接下来就会继续执行处于正在创建中状态的A，由于A依赖的B已经创建好放在一级缓存中了，此时A在属性填充时可以直接从一级缓存中获取到B，完成属性填充以及初始化的工作。这样A、B就都创建了出来。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aec667586183ff4490ed50f6abf7e340/" rel="bookmark">
			用python爬取快手评论（烂活新整）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前提，上次我用selenium写了一个抖音直播评论获取，这次烂活新整，用python发送post请求获取快手的视频评论！ 1.首先打开网页版的快手 在网页里面按下F12，打开开发者模式，点击网络，查看Fetch/XHR。看看里面的请求。
找到一个叫graphql的请求。这个就是评论的请求。我们点击进去，然后查看预览。可以看到如下效果。
返回的是一个json数据，这下就好办了。我们现在只要模仿浏览器给快手服务器发送请求就行了。
2.发送请求给快手服务器 首先，我们来看一下这个是个什么请求，是个get请求还是post请求。（一般都是post）点击表头。查看请求。
我们可以看到，这是个post请求，请求url是https://www.kuaishou.com/graphql，发送post请求都是要带一些表单数据的。
看看表单数据要传输哪些数据
可以看到这个请求负载里的数据就是我们要传输的数据了，这个请求负载不同于Form data的。Form data传输的一个字典，而 Request Payload是一个json数据。这个有所不同，如果你此时还是传入一个dict数据的话，是不会返回数据的。必须传入json数据。那么我现在就可以用python发送请求了。做到这里一切都很顺利！！
3.用python发送请求 import requests import json headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.61 Safari/537.36 Edg/94.0.992.31', 'Cookie': 'kpf=PC_WEB; kpn=KUAISHOU_VISION; clientid=3; did=web_1e83306028e4691a0acb7f78ecfbf145; didv=1632459485000; client_key=65890b29; Hm_lvt_86a27b7db2c5c0ae37fee4a8a35033ee=1632459683; userId=153866369; kuaishou.server.web_st=ChZrdWFpc2hvdS5zZXJ2ZXIud2ViLnN0EqABSkrOjzdufZa4lBYXxddWpU-Da_CebI6GVHm2vvSBBxRUv9kJ_BKaJ3weX3FWf3acdLw2yy6uCM1MpHB8Pfi7EnJBlcRb0GqyXYMpPlaCdMqKlVo0PI-iY9zN0wdxA89wOXtml-fWR7CFTT54hsd3PZTsTwlWBA7vhJvwim07-A1RaTmwi66PbBkj7eCrkmJX0hdCln9MiFVyA_CL44TScBoSuDcrlwmr6APhXfdZrBO5uo0FIiA8xE-BzwPs3Wp_Q9mI4y5GcZxo1E-B0xr4CkR4zohqJigFMAE; kuaishou.server.web_ph=eeb2272fa742f8d8f79bd635c3e8044ac1f8'} data = { "operationName": "commentListQuery", "variables": { "photoId": "3xhcrvum26yz3vg", "pcursor": '' }, "query": "query commentListQuery($photoId: String, $pcursor: String) {\n visionCommentList(photoId: $photoId, pcursor: $pcursor) {\n commentCount\n pcursor\n rootComments {\n commentId\n authorId\n authorName\n content\n headurl\n timestamp\n likedCount\n realLikedCount\n liked\n status\n subCommentCount\n subCommentsPcursor\n subComments {\n commentId\n authorId\n authorName\n content\n headurl\n timestamp\n likedCount\n realLikedCount\n liked\n status\n replyToUserName\n replyTo\n __typename\n }\n __typename\n }\n __typename\n }\n}\n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aec667586183ff4490ed50f6abf7e340/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/781fff3d525bdf8ccb449ea636f39de4/" rel="bookmark">
			IDEA开发多步骤对话框和ANTLR的生成的树的访问方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先书写如何搞一个连续对话框，这里需要引用的是IDEA自带的东西，其中有一些步骤需要自己写一个重复对话框的时候需要注意。详细步骤如下：
对话框需要extends的是AbstractEx，而不是WrapperDialog类。
然后就是重写函数和注意点
1.重写上下文相关的方法，首先是getStepId，需要给当前的页面一个ID，上下文可以标识到，根据自己的实际写，需要的是Object类
2. 然后就是获取连续对话框上下文的方法 getNextStepID和getPreviousID两个函数，注意点是第一个和最后一个节点没有前和后节点，应该去返回null，如果有的话，请正确的指向。返回的结果stepID就是每一个都要getStepId中设置的。
3. 下一个重写的方法是 getComplete。也不需要判断，这个就是能否点下一步的开关，可以在此添加整个对话完整性的限制。
4.Commit 相当于暂存按钮，这个需要放以下这个步骤的提交按照dook的写即可，这样的话，上一步和下一步回来后内容也会在。
5.Compenenet UI通用
6. 以上是单个节点的需要注意重写的几个方法，其中构造函数就不再赘述，接下来是他的上一层，就是整个连续的对话框队列的设置。
7. 首先是村一整个的过程的节点，使用一个类型为AbstractEx来将初始化好的节点放到list里面
8.将上述数组整体传入一个ComponentCreationWizard中new的三个传参为整个连续框的名称、project，和7的list
9.接下来每个对话框内部定义一个awe，注释内容是增加双向引用，每一个对话框的awe都要服职位刚才初始化的ComponentCreationWizard.
10 之后可以考虑ide的事件队列，防止卡顿。IDEventQueue.Instance.getpopupManager.closeAllpopups.
11 ComponentCreationWizard是一个事件对话框，showandget即可。
使用antlr。一个强力的文发生产工具，直接书写最基础的文峰，帮忙生成语法和词法解析，只需要在他的生成树下操作节点即可完成修改等情况。他的便利和递归是前后文强一致的，只需要按在层级包裹，每一个此都会放到合适的完全和原上下文一致的位置上。
本次使用的是以C源文法为基础，进行一定程度的改造适应需要改造的文法，主要比较麻烦的点是上下文注释的强一致性将注释进行完美保留，则需要尽力考虑到注释可能出现的所有位置，而其他的类似的都没有考虑注释的问题，直接将注释放到另外一个通道skip了，就不用担心上下文问题。
接下来介绍一下通道和树的概念，antlr中的树都是只考虑默认通道0中的元素来构造一个树，一些独立的内容等情况自己可以在文法中将其放到不同的通道中去，可以先跑一个的时候获取通道中的内容，这些也都会具有上下文相关的内容，只不过需要添加到上下文需要进行额外的分析，放到通道内的建议是可以独立法呢系的情况。而有一些将要舍弃的内容 例如/r/。。多余的space 都可以-》skip给舍弃掉。
下面写以下实际调用通道中内容和通道0中每一个节点的方法。生成利用antlr 命令行或者工具。
1.首先是通用的要传入文件，需要将文件给传到一个antlrInputStream 看源码是可以传入字符和reader的。但是没有额外处理，流是比较快的。但是主要要调整编码格式，特别是含汉字的时候。
之后要利用他的lexer词法生成的类，根据文法具体名称使用具体的lexer将流转换成一个elexer， New laxer（stream）
然后就是利用 一个CommonTokenStream将上文中的lexer传入初始化，生成一个CommonTokenStream。
2. 这里是写取其他通道的数据的情况，如果想获取，需要操作CommonTokenStream。利用
CommonTokenStream。fills方法后以Token为sign 循环CommonTokenStream即可
此时利用getchanel获取信道参数，是几号信道直接比较即可，主要是获取其他信道要先fills。否则的话获取不到，fills会有额外耗时。
3.接下来是形成parser，这一步是必须的，new parser（CommonTokenStream）来获取，然后parser就可以形成树了，需要告诉其入口，就是树的根节点。或者文法的某一部分的话是其他节点。将parser直接（.入口符号）即形成了树，然后是两个不同的引入自己写的扩展节点的类，分别是visitor和listener，两种方式就覆盖原生的方法，树便利是会走这重写的方法。区别是 listener没有返回值，而visitor有返回值。对于节点的修改，分别是利用返回值和直接修改默认值来完成。
4.visitor的调用形式 new 以下自己写的visitor 容纳后调用visitor.visit(tree) 3中得到
5.Listener形式，进入某节点，修改上下文节点上的内容，不写返回值。会将上下文返回回来，调用方式，new ParesTreeWalk（） walk.walk(new Listener,tree)、listener多引入了一个walker，在walker传入listener和tree
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2daae6cf3308f093711f32b662829c68/" rel="bookmark">
			UNIAPP获取应用版本号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		plus.runtime.version 需要注意的是这个只能在app里面支持，如果有h5或者小程序记得写一下控制，不然会报错
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13de109bcef82b141609f262f64ee1c3/" rel="bookmark">
			Xshell 和Xftp下载地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		链接: https://pan.baidu.com/s/10SFvU2or0eQLrG9oCiBNSg 提取码: d52n 1、安装包可去官网下或者直接去上方
2、遇到“xshell启动遇到“由于找不到mfc110.dll,无法继续执行代码的解决方法”
解决方法：去Download Visual C++ Redistributable for Visual Studio 2012 Update 4 from Official Microsoft Download Center下载，且两个都需要安装
3、遇到“产品运行所需的信息检索失败。请重新安装xshell” Code=40002
需要使用管理员身份运行里面的绿化bat文件就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a89dda7c159b770213a231f3f61064bc/" rel="bookmark">
			springboot自动编译和热部署设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.热部署的目的 IDEA 编写传统 web 应用使用外置的 Tomcat 时，前端代码修改后是可以自动编译，页面刷新就能看到效果的。而现在开发 SpringBoot 项目时，因为它使用的是内置的 Tomcat ，所以即使是在 html 页面上修改内容，它也必须重新启动之后才能看到效果，这样开发上很不方便。本文将解决这个问题。
使用热部署前提是idea要开启自动编译功能, eclipse默认开启自动编译
开启热部署步骤:
1. idea开启自动编译功能
2. 引入devtools依赖并生效
3. 项目配置
二.idea开启自动编译 2.1设置自动编译
File-Settings-Compiler-Build Project automatically(勾选)
2.2 注册自动编译
Ctrl+Shift+Alt+/ 选择Registry
找到选项Compiler autoMake allow when app running打勾,然后close
三. 引入devtools 3.1在pom文件中，引入如下依赖：
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;!--optional=true,依赖不会传递，该项目依赖devtools;之后 依赖boot项目的项目如果想要使用devtools,需要重新引入--&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 3.2在pom文件中,引入插件中配置按如下配置：让devtools生效
&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;!--fork : 必须配置，否则热部署不会生效，应用不会重置 --&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;addResources&gt;true&lt;/addResources&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 补充:可以在配置文件中进行详细设置
#关闭缓存，即时刷新 #spring.freemaker.cashe=false spring.thymeleaf.cache=true #热部署生效 spring.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a89dda7c159b770213a231f3f61064bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74d9a8ca0fcae6c2448f0115fca1407d/" rel="bookmark">
			kindle剪贴内容提取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		file_path = 'C:/Users/74285/Desktop/' file = open(file_path + 'My Clippings.txt', 'r', encoding = 'utf-8') data = {} while 1: line = file.readline() if not line: break book = line if book not in data: data[book] = [] line = file.readline() line = file.readline() line = file.readline() data[book].append(line) line = file.readline() file.close() books = data.keys() for book in books: path = file_path + book[: -1] + '.txt' book_file = open(path, 'w', encoding = 'utf-8') for line in data[book]: book_file.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74d9a8ca0fcae6c2448f0115fca1407d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81f1fa6ef651eb4aa65997f23c042a49/" rel="bookmark">
			SVN比较两个文件差异
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		两个文件的差异，可以使用专门的文件对比工具，例如 Beyond Compare（收费）、WinMerge（免费）等。
但是如果只是比较两个代码文件的差异，直接使用 TortoiseSVN 自带的对比功能足矣！
Demo 现在有两个文件 a.txt 和 b.txt，比较这两个文件内容的差异，直接选中这两个文件，右键 -&gt; TortoiseSVN -&gt; Diff 即可：
对比结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e77e74095b8adcb4ea0fef15be533dd8/" rel="bookmark">
			Ubuntu18.04编译ORB-SLAM3及遇到的一些问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		测试环境：
系统：Ubuntu18.04Eigen 3.3.4 查看Eigen3版本的方法Pangolin 0.6OpenCV 3.4.14ROS Melodic 一、 安装依赖 ORB-SLAM的各项依赖里OpenCV,Eigen,g20等都比较常规，直接下载源码编译安装就可以。需要注意的是Opencv版本别装太高。遇到的问题出在安装Pangolin。通过源码编译安装完成后，测试十四讲中高博的示例代码，编译可以通过，但在执行时会报错：error while loading shared libraries: libpangolin.so: cannot open shared object file: No such file or directory，大概就是没有链接上动态库，需要修改一个配置文件，告诉他去/usr/local/lib里搜索。参考https://blog.csdn.net/weixin_42226918/article/details/86158540
二、 编译源代码 Git clone或者下载压缩包解压以后，按照官网的教程，创建目录，执行./build.sh，这里面遇到的几个报错大致如下：
/ORB_SLAM3/src/LocalMapping.cc:628:49: error: no match for ‘operator/’ (operand types are ‘cv::Matx&lt;float, 3, 1&gt;’ and ‘float’) x3D = x3D_h.get_minor&lt;3,1&gt;(0,0) / x3D_h(3);
解决方法是在localMapping.cc的628行，把x3D = x3D_h.get_minor&lt;3,1&gt;(0,0) / x3D_h(3);换成 x3D = cv::Matx31f(x3D_h.get_minor&lt;3,1&gt;(0,0)(0) / x3D_h(3), x3D_h.get_minor&lt;3,1&gt;(0,0)(1) / x3D_h(3), x3D_h.get_minor&lt;3,1&gt;(0,0)(2) / x3D_h(3)); recipe for target ‘CMakeFiles/ORB_SLAM3.dir/src/CameraModels/KannalaBrandt8.cpp.o’ failed
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e77e74095b8adcb4ea0fef15be533dd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7e5ae277d5b36271abf241f46eda271/" rel="bookmark">
			高精度乘法（高精度乘高精度）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一次发博客，也不知道讲些什么，就分享一下高精度这一块的吧。
说实话我刚开始学高精度的时候觉得挺难的 ，写了代码之后才感觉其实高精度乘法还是比较简单的，就是代码量稍稍有点大。
接下来进入正题
先上张图
没错应该看的出来，高精度乘法其实就是一位一位去乘，然后按位存储在数组里面，思路差不多就是这样。
由于位数比较多，我们用字符串来进行输入，处理后按位存到整型数组中。
我们用下标来确定存数组的位置，从图中也可以看出a[i]*b[j]就存在[i + j - 1]的位置上，然后每一位都进行累加（这里的累加是指同一位的累加，如a[2]*b[1]和a[1]*b[2]是存在同一位上的，就是都在c[2]中进行累加），累加完毕后再处理进位，最后倒序输出就可以噜~
听着是不是灰常的简单易懂【手动滑稽】
话不多说，上代码 #include &lt;iostream&gt; using namespace std; int a[1005] , b[1005], c[2005]; string x, y; int main(){ cin &gt;&gt; x &gt;&gt; y; int a1 = x.size(); int b1 = y.size(); int c1 = a1 + b1; for(int i = 0; i &lt; a1; i++){ a[a1 -i -1] = x[i] - '0';//输入第一个数 } for(int i = 0; i &lt; b1; i++){ b[b1 -i -1] = y[i] - '0';//输入第二个数 } for(int i = 0; i &lt; a1; i++){ for(int j = 0; j &lt; b1; j++){ c[i + j] += a[i] * b[j];//按位相乘并累加 } } int x = 0; for(int i = 0; i &lt; c1; i++){//处理进位 c[i] += x; x = c[i]/10; c[i] %= 10; } int k = c1;//两数相乘后的位数不会超过两数位数相加之和，所以c1足够了 while(c[k]==0 &amp;&amp; k &gt; 0){//处理前缀0 k--; } for(int i = k; i &gt;= 0; i--){//倒序输出 cout &lt;&lt; c[i]; } return 0; } 对了，刚才忘说了一点，输出时要处理一下前缀0！！！（希望你们别白嫖了代码就走导致没看到这句话）好吧这句话其实不用我说看了代码就知道
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/182/">«</a>
	<span class="pagination__item pagination__item--current">183/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/184/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>