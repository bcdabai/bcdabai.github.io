<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b21a68417c5aba5cf458ca926a48daa/" rel="bookmark">
			glibc 知：构建2.34版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 获取版本构建安装测试testrun.shstrace 获取版本 主页：https://www.gnu.org/software/libc
这里选择任意一个压缩包下载即可。
构建安装 tar -Jxf glibc-2.34.tar.xz mkdir build install cd build ../glibc-2.34/configure --prefix=/usr make -j4 make install DESTDIR=/xxx/xxx/install 1）make后面的-j4，其中4可以根据CPU数进行调整。
2）DESTDIR需要是绝对路径
3）configure阶段可能会检测某些软件不存在，根据错误提示在主机上安装即可
4）如果使用vmware虚拟机，build目录不能在Linux和Windows共享目录下，否则会构建错误
测试 下面写一个打印hello world的c程序，基于构建的glibc-2.34进行执行。
1）程序 test.c
#include &lt;stdio.h&gt; int main(void) { printf("hello world\n"); return 0; } 2）编译
gcc test.c 3）执行
基于build目录下的testrun.sh进行执行
$ /xxx/xxx/build/testrun.sh ./a.out hello world 更多测试方法可以参考 glibc 知：构建和测试
testrun.sh #!/bin/bash builddir=`dirname "$0"` GCONV_PATH="${builddir}/iconvdata" usage () { cat &lt;&lt; EOF Usage: $0 [OPTIONS] &lt;program&gt; [ARGUMENTS...] --tool=TOOL Run with the specified TOOL.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b21a68417c5aba5cf458ca926a48daa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/927d852d19db968d8601ced786036b78/" rel="bookmark">
			如何梳理陌生的代码模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何梳理陌生的代码模块 总体上可以遵循从整体到局部的方式。当然，不同的工作需要对代码梳理的程度不同，根据需要考量。
下面介绍梳理代码的维度：
1.明确模块的定位 在整个系统中处于什么位置：被谁调用，提供什么功能，结果交给谁，后续做什么。
2.了解模块对外提供的接口 模块具体提供了什么功能，哪些接口，有什么用，怎么用。
例如：全局资源初始化、逆初始化，模型创建、销毁、重新加载，内存释放… 3.梳理继承关系 继承往往意味着多态，子类一般只会重写基类的部分函数，明确继承关系可以让我们明白调用过程中走到哪个类的函数。
4.关键函数的主要调用逻辑 把握函数的实现流程，抓住关键节点。
5.函数的具体实现 研究函数功能如何实现：采用了什么算法，为实现算法进行了哪些设计，有哪些关键变量、进行了什么操作、值如何变化。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9f63094ef6733543110e3ddcfdcc7c8/" rel="bookmark">
			HttpClient连接池管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@Configuration @EnableConfigurationProperties(HttpClientProperties.class) @ConditionalOnProperty(prefix = "myserver.httpclient", value = "enabled", havingValue = "true") public class HttpClientConfig { @Autowired HttpClientProperties httpClientProperties; @Bean PoolingHttpClientConnectionManager poolingHttpClientConnectionManager() { PoolingHttpClientConnectionManager pool = new PoolingHttpClientConnectionManager(); pool.setDefaultMaxPerRoute(httpClientProperties.getDefaultMaxPerRoute()); pool.setMaxTotal(httpClientProperties.getMaxTotal()); //官方同时建议我们在后台起一个定时清理无效连接的线程， new HttpClientPoolIdleConnectionMonitorThread(pool, httpClientProperties).start(); return pool; } @Bean HttpClientBuilder httpClientBuilder(PoolingHttpClientConnectionManager poolingHttpClientConnectionManager) { HttpClientBuilder builder = HttpClientBuilder.create(); builder.setConnectionManager(poolingHttpClientConnectionManager); return builder; } @Bean CloseableHttpClient getHttpClient(HttpClientBuilder httpClientBuilder) { CloseableHttpClient httpClient = httpClientBuilder.build(); return httpClient; } @Bean HttpUtils getHttpUtils(CloseableHttpClient httpClient) { if (!httpClientProperties.getPool()) { httpClient = HttpClients.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9f63094ef6733543110e3ddcfdcc7c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f02a30385c290b6ca5a2cd40ecd8174/" rel="bookmark">
			使用python做一个全球疫情数据采集&#43;采用Excel存储&#43;采用词云图展示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前期准备工作
需要了解基本的python语法知识，可以参考我的另一篇文章，对python基础知识的总结，或者参考缪雪峰老师的python课程，是免费的。
我们先来了解一下爬虫
网络爬虫与浏览器的区别
浏览器是展示数据的，而网络爬虫是采集数据的
什么是网络爬虫
模拟客户端发送网络请求，获取响应数据，一种按照一定的规则，自动地抓取万维网信息的程序和脚本
网络爬虫的作用
从互联网上采集我们所需要的数据
本程序需要使用到的几个库：
1.Requests请求库
作用：Python HTTP请求库，发送请求，获取响应数据
导入模块发送get请求，获取响应从响应中获取数据 text 获取响应的字符串
encoding 二进制转换成字符时使用的方式
content 响应体bytes类型数据
安装：pip install requests
简单示例
#导入模块 import requests #1.爬取百度的疫情数据网页 #目标url url = "https://voice.baidu.com/act/newpneumonia/newpneumonia" #发出get请求 response = requests.get(url) #打印响应内容 print(response.content.decode()) 2.模块lxml
作用：实现解析HTML、XML文档
数据提取：在发送请求获取响应后，可能存在多种不同类型的响应内容，我们只需要有用的部分
lxml是一款高性能的python HTML、XML解析器
XPath是一门在HTML、XML文档中查找信息的语言，可用在HTML、XML对元素和属性进行遍历
常用的几种使用方式
/从根节点选取
//从匹配选择的当前节点选择文档中的节点，而不考虑他们的位置
.选取当前节点
@选取属性
text()选择文本
*匹配任何元素节点
安装：pip install lxml
例如
//script[@lang=”eng”] 选取所有tltle元素，且这些元素拥有值为eng的lang属性
简单示例
#导入lxml的etree库（使用XPath） from lxml import etree #利用etree.HTML将字符串转化为Element对象，其具有xpath方法，返回的结果列表能够接收bytes类型的数据和str类型的数据 html = etree.HTML(text) result = html.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f02a30385c290b6ca5a2cd40ecd8174/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38929afbac0f7d9673046f2533f8880d/" rel="bookmark">
			Element-UI的this.$message在js里面使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题：
直接在js里面用this.$message显示报错，无法找到message
出现问题的原因：
js里面使用this,此时this这时候指向的是windows,无法用到element ui到this.$
解决：
第一种：直接把Message附到Vue的原型链上了
-Vue.prototype.$message({ type:'', message: });
第二种：直接在js里面引用用message模块，然后直接写
import { Message } from 'element-ui'; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53787ad28972ae7adc4781ecbd3773e2/" rel="bookmark">
			java 包装类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么需要包装类 java并不是纯面向对象的语言，java语言是一个面向对象的语言，但是java中的基本数据类型却不是面向对象的，但是我们在实际使用中经常将基本数据类型转换成对象，便于操作，比如，集合的操作中，这时，我们就需要将基本类型数据转化成对象！
基本数据类型及对应的包装类
基本数据类型
对应的包装类
byte
Byte
short
Short
int
Integer
long
Long
char
Character
float
Float
double
Double
boolean
Boolean
每个包装类的对象可以封装一个相应的基本类型的数据；
所有包装类都可将与之对应的基本数据类型作为参数，来构造它们的实例:
如：
Integer in = new Integer(12); // 创建了一个整数类型的对象，其值为12
包装类的继承关系 包装类的基本操作 装箱的三种方式：
Integer num = 1;
Integer num2 = Integer.valueOf(2);
Integer num3 = new Integer(3);
拆箱的两种方式：
Integer num1 = 1;
int num2 = num1;
Integer num3 = new Integer(3);
int num4 = num3.intValue();
而Java为了方便我们使用，以及出于其他目的如性能调优，给我们提供了自动装箱、拆箱机制。这种机制简化了基本类型和包装类型的转换。 //1、包装类中的自动装箱拆箱机制 Integer num1 = 1;	//自动装箱 int num2 = num1;	//自动拆箱 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53787ad28972ae7adc4781ecbd3773e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f681309566666298f06ff12ebdb3e05/" rel="bookmark">
			tomcat 过滤器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		tomcat 过滤器 官网：Apache Tomcat 10 Configuration Reference (10.0.14) - Container Provided Filters
*************** tomcat 内置过滤器
过滤器说明
AddDefaultCharsetFilter：如果响应体content-type不包含encoding设置，添加默认的encoding编码，预防xss攻击 SetCharacterEncodingFilter：设置请求的字符编码 ExpiresFilter：设置header有效期 FailedRequestFilter：失败请求过滤 HttpHeaderSecurityFilter：响应体中添加请求头，提升连接安全性 WebdavFixFilter：修复windows 80端口连接故障 CorsFilter：跨域防护过滤器 CsrfPreventionFilter：提供CSRF（跨站请求伪造）保护 RestCsrfPreventionFilter：rest接口csrf保护 RemoteAddrFilter：验证请求ip地址，根据过滤规则判断是否对请求进行处理 RemoteHostFilter：验证请求host地址，根据过滤规则判断是否对请求进行处理 RemoteCIDRFilter：比较客户端ip和网关地址，根据比较结果判断是否对请求进行处理 RemoteIpFilter：替换代理服务器的ip地址、scheme (http/https)、port、request.secure RequestDumperFilter：请求、响应信息在日志中输出 SessionInitializerFilter：请求处理前生成session *************** springboot 过滤器注册
*************
filter 层
CustomFilter：自定义过滤器
public class CustomFilter implements Filter { @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { HttpServletRequest request = (HttpServletRequest) servletRequest; Enumeration&lt;String&gt; headers = request.getHeaderNames(); while (headers.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f681309566666298f06ff12ebdb3e05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f5de5dfc812af38d2df378bf2680308/" rel="bookmark">
			电脑没声音怎么办？电脑没声音了怎么恢复？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打开电脑，本来每次开机完成都会有声音，今天突然沉默了，刚开始没在意，结果发现什么应用都没有声音。声音对于电脑来说不可或缺，电脑没声音了怎么恢复？本期技能学起来！
方法一、更改系统声音 1.我们电脑任务栏的左侧，也就是紧挨【开始】图标的右侧是一个搜索框（部分电脑需要点击【开始】后才会看到），我们在搜索框内输入“控制面板”四字，搜索结果出来后单击一下鼠标即可打开。
2.点击【控制面板】后我们点击“硬件与声音”，随后点击“更改系统声音”。
3.在“声音”设置这里查看是否显示为无声，若是显示“无声”的话，我们重新更改为“默认”即可，声音就回来了！
方法二、音频驱动重启 1.在文件夹内找到【此电脑】，鼠标右键它，在弹出的各选项里点击“管理”，此时就会弹出一个中型界面窗口，找到并点击“设备管理器”。
2.随后找到并点击“声音、视频和游戏控制器”左侧的小图标展开，可以看到所有的音频驱动都在里面。我们点击其中一个禁用设备然后重新启动设备即可（如果无效则选择剩余的音频驱动重新禁用启动）。
总结： 电脑没声音了怎么恢复？
1. 启动【控制面板】后点击“硬件与声音”，然后选择“更改系统声音”，若显示为“无声”，则将“无声”重新修改成“默认”选项。
2. 在“设备管理器”找到“声音、视频和游戏控制器”，重新启动里面的音频驱动（原理类似电脑死机重新启动）。
电脑没声音了怎么办？本文提出的两个方法就简单介绍到这里啦！好了，本期“电脑没声音了怎么恢复？”到此结束，能帮到大家的话小编也是很开心的，当然也希望大家关注一下、赞一下和转发一下，下期再见！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c6ec63398f8848e166085f68d280dd4/" rel="bookmark">
			设置VSCode空格宽度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		修改Font Family 为 'monospace'
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a189a2908766e4ff5b1ee2128f73c4da/" rel="bookmark">
			运行phpstudy时，显示3306端口被占用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、先打开命令提示符cmd，输入netstat -ano命令，得到本机端口占用情况。查询到3306端口被6852端口占用（每次重启都是新端口）
2、打开任务管理器，点击详细信息。通过PID排序找到可以得知被mysql占用。
3、原来是之前下载过比较多mysql，把端口占用了。所以我们右键把它结束掉就好了。
4、完成后重启phpstudy，发现phpstudy正常运行，无端口被占用的情况。
缺点是每次重启时，就得再重复操作一次！！不过已经满足hhh
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbc61cd49a6e0f2f2a3c9ff0f6fb6cb4/" rel="bookmark">
			python进行图像的风格转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前记：记得在很久以前，在我看过的一本名叫《深度学习入门》上。在他的后记上好像有过这样的记载。有一能人，通过深度学习，将拍摄的照片进行风格转换。将图片梵高化。加上了一层梵高的滤镜。
但是呢，后来有事给我忘了，前几天在逛csdn的时候，哦豁！又看到关于这个风格转换的文章。想着就自己拿来玩一下。
就这样，我走进来全球最大的“同性交友网站”，在里面找寻了一会。嘿嘿。果真让我找到了。
(https://github.com/ksivaman/Transfer-image-styling/blob/master/transfer.py)链接在这里。
这个是用pytorch来实现的。具体原理咋就不唠了哈。自己去看原理论文哈！
我们这里主要将怎么运行起来。
1.首先缺啥模块安装啥模块
主要就是torch和torchvision。当然，其他的模块你没有也安装一下哈。
安装完成之后在安装一个vgg网络。要是你没安装的话，他运行的话，会自动安装的。但是可能会很慢，甚至失败。（好像要外网）所以为了方便大家，我下载放到我的qq群里啦。（群号：342096685）。代码和vgg网络都有。
2.安装完成之后就可以选择图片进行运行了
这个content就是你要转换的图片，这个style就是你要转换的风格。比如说你那个content里面放一张你随手拍的照片，那个style放你梵高的《自画像》那就会转换成这个梵高的风格。当然，你也要看你迭代的次数。我这边迭代2000次大概是这个效果。
当然，迭代次数你也可以自己改哈
这个steps就是改迭代次数的。
好了，今天就到这里了。最后水一下群342096685。里面代码都发群文件了。有需要可以加一下哈。遇到问题也可以进去问一下哈。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1296986eab282081725aa2023b8969e/" rel="bookmark">
			npm install报错：This version of npm is compatible with lockfileVersion@1, but package-lock.json was ge
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 npm install报错：This version of npm is compatible with lockfileVersion@1, but package-lock.json was generated for lockfileVersion@2. I’ll try to do my best with it! 下依赖的时候提示这个，但是仍然可以继续下依赖，但下的过程中，有的提示报错了，因为已经将解决了，报错的截图找不到了。
解决办法： 当前电脑安装的npm是lockfileVersion@1的，但package-lock.json是源于lockfileVersion@2的。项目中使用的某个包只能用特定版本的npm下载，所以会报错导致npm install失败。这时升级一下npm就可以解决了：
npm install -g npm 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d45862984c4b358a9dba1d59d1593b7/" rel="bookmark">
			js 续篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 强制数据类型转换，将其他类型转化为string类型：toString()方法、String(argu)，toString不能住转换null、undefined，String能转换null、undefined类型的数据，直接将两者转化为‘null’、‘undefined’区分方法、函数。Number()将字符串转化为数字，字符串中只要有非数字的就转化为NaN。null==&gt;0、undefined==&gt;NaNparseInt将字符串中有效的整数内容解析出来，能够解析带有非数字的字符串，可以转化为对应进制parseFloat将字符串中有效的浮点数内容解析出来，把一个字符串转化为浮点数对非String使用parseInt和parseFloat会先将其转化为字符串再进行解析16进制开头：0x；8进制开头：0；二进制：0b（部分浏览器支持）数字转boolean，除了NaN和0为false其他都是true；字符串转boolean除了空串为false，其他都是true；null和undefined都转为false；对象转化为truetypeof返回值为字符串任何值与NaN做运算结果都是NaN任何值和字符串做加法都会先将其转化为字符串再做字符串的拼接，仅仅是一个加号的两边任何数字做 - * / 都会将其转化为number再运算数字字符串前面加一个+号可以将其转化为number对象类型：内建对象（由ES定义的对象，任何ES实现中都可以使用，如Math、String、Number、Boolean、Function、Object）；宿主对象（由JS运行环境提供的对象，主要讲由浏览器提供的对象，如BOM、DOM）；自定义对象（由开发人员自己创建的对象）使用new调用的函数是构造函数，构造函数专门创建对象的函数 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e133320ca91f380daa922268dda9405/" rel="bookmark">
			日志清理（四）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		日志清理 Kafka 将消息存储在磁盘中，为了控制磁盘占用空间的不断增加就需要对消息做一定的清理操作。Kafka 中每一个分区副本都对应一个 Log，而 Log 又可以分为多个日志分段，这样也便于日志的清理操作。Kafka 提供了两种日志清理策略：
日志删除（Log Retention）：按照一定的保留策略直接删除不符合条件的日志分段。日志压缩（Log Compaction）：针对每个消息的 key 进行整合，对于有相同 key 的不同 value 值，只保留最后一个版本。 我们可以通过 broker 端参数 log.cleanup.policy 来设置日志清理策略，此参数的默认值为“delete”，即采用日志删除的清理策略。如果要采用日志压缩的清理策略，就需要将 log.cleanup.policy 设置为“compact”，并且还需要将 log.cleaner.enable （默认值为 true）设定为 true。通过将 log.cleanup.policy 参数设置为“delete,compact”，还可以同时支持日志删除和日志压缩两种策略。
日志清理的粒度可以控制到主题级别，比如与 log.cleanup.policy 对应的主题级别的参数为 cleanup.policy，为了简化说明，本节只采用 broker 端参数做陈述，topic 级别的参数可以查看《图解Kafka之实战指南》的相关章节。
日志删除 在 Kafka 的日志管理器中会有一个专门的日志删除任务来周期性地检测和删除不符合保留条件的日志分段文件，这个周期可以通过 broker 端参数 log.retention.check.interval.ms 来配置，默认值为300000，即5分钟。当前日志分段的保留策略有3种：基于时间的保留策略、基于日志大小的保留策略和基于日志起始偏移量的保留策略。
1. 基于时间
日志删除任务会检查当前日志文件中是否有保留时间超过设定的阈值（retentionMs）来寻找可删除的日志分段文件集合（deletableSegments），如下图所示。retentionMs 可以通过 broker 端参数 log.retention.hours、log.retention.minutes 和 log.retention.ms 来配置，其中 log.retention.ms 的优先级最高，log.retention.minutes 次之，log.retention.hours 最低。默认情况下只配置了 log.retention.hours 参数，其值为168，故默认情况下日志分段文件的保留时间为7天。
查找过期的日志分段文件，并不是简单地根据日志分段的最近修改时间 lastModifiedTime 来计算的，而是根据日志分段中最大的时间戳 largestTimeStamp 来计算的。因为日志分段的 lastModifiedTime 可以被有意或无意地修改，比如执行了 touch 操作，或者分区副本进行了重新分配，lastModifiedTime 并不能真实地反映出日志分段在磁盘的保留时间。要获取日志分段中的最大时间戳 largestTimeStamp 的值，首先要查询该日志分段所对应的时间戳索引文件，查找时间戳索引文件中最后一条索引项，若最后一条索引项的时间戳字段值大于0，则取其值，否则才设置为最近修改时间 lastModifiedTime。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e133320ca91f380daa922268dda9405/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b033c5e75842401ee3ce9fc00c5c0e1/" rel="bookmark">
			Linux驱动开发———GPIO有效电平解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言1、什么是有效电平2、设备树中的GPIO属性3、有效电平的定义4、GPIO有效电平的实现总结 前言 本文为作者学习记录，如有错误之处欢迎指出！下文将以imx6ull芯片、Linux4.1.15内核中的led-gpio驱动作为例子对gpios属性的中的有效电平进行分析。
ps:驱动路径drivers/leds/leds-gpio.c
1、什么是有效电平 以单片机的思维来讲，对GPIO的控制一般是：
输入输出1高电平0低电平 下面两张led原理图（图片来源于网络），一张为高电平有效，一张为低电平有效。当GPIO输出对应的电平时led亮，为了实现统一的接口，让1表示灯亮、0表示灯灭，就需要用到有效电平。加入有效电平Led真值表如下所示。
Led真值表
led输入值电平值状态高电平有效LED1高电平亮高电平有效LED0低电平灭低电平有效LED1低电平亮低电平有效LED0高电平灭 2、设备树中的GPIO属性 由内核的说明文档（Documentation/devicetree/bindings/gpio/gpio.txt）可知，设备树中的GPIO属性主要由三部分组成：
（1）GPIO控制器
（2）第几个GPIO
（3）有效电平
如下图表示gpio4-16,高电平有效
3、有效电平的定义 在include/dt-bindings/gpio/gpio.h有定义如下：
4、GPIO有效电平的实现 以led-gpios驱动为例，设备树中的led节点匹配驱动成功后，会调用drivers/leds/leds-gpio.c中的gpio_led_probe函数：
// 判断是否使用设备树 if (pdata &amp;&amp; pdata-&gt;num_leds) { ...... } else { priv = gpio_leds_create(pdev); if (IS_ERR(priv)) return PTR_ERR(priv); } 在gpio_leds_create函数中会调用device_for_each_child_node函数遍历led节点下的每一个子节点，一个子节点表示一个led:
device_for_each_child_node(dev, child) { ...... led.gpiod = devm_get_gpiod_from_child(dev, NULL, child); if (IS_ERR(led.gpiod)) { fwnode_handle_put(child); ret = PTR_ERR(led.gpiod); goto err; } ...... } 在devm_get_gpiod_from_child函数中会去获取gpios属性的值：
for (i = 0; i &lt; ARRAY_SIZE(suffixes); i++) { /* 构造led属性的字段名，比如在设备树定义了 led-gpios属性，con-id可传入"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b033c5e75842401ee3ce9fc00c5c0e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73502d649853dd45b03f22b95033f669/" rel="bookmark">
			eclipse与SQL server数据库的连接（导入JDBC驱动包、使用SQL server 身份验证方式登录）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.首先下载jdbc驱动包，根据自己下载的SQLServer的版本下载相应版本的jdbc驱动包。
2.打开jdbc驱动包的文件夹，找到.jar的文件，例如jre16.jar，不需要点开，找到即可，记住名字jre16
3.打开eclipse，点击打开，菜单File—New—Java Project
4.在Create a Java Project的窗口里，jre选择16版本的
5.点击第三个选项，Use default JRE ‘jre’ and workspace compiler preferences。再点击右边的蓝色链接，Configure JREs…
6.打开Preferences(Filtered)窗口，鼠标双击如下图所示的文件
7.打开Edit JRE窗口，全选并复制JRE home栏中的路径
8.将复制的路径在电脑中打开，找到并打开bin文件夹，里面有大量.dll的文件
9.在jdbc驱动包的文件夹里，打开auth—X64（根据自己的电脑来选择）
10.选中.dll文件，复制到步骤8打开的文件夹中，即可完成导包，可以关闭文件夹了
11.回到eclipse中，重新创建Java Project，在Project name输入项目名，点击finish完成创建
12.右击新创建的项目文件，例如JDBC，点击打开Build Path—Add External Archives…
13.找到jdbc驱动包文件，选择并打开jre16.jar文件，即可添加成功
14.打开Microsoft SQL Server Management Studio数据库
15.使用SQL Server 身份验证登录，输入登录名和密码，点击连接
16.打开菜单栏中“新建查询”，输入CREATE DATABASE Test创建一个名为Test的数据库
17.打开eclipse，创建.java文件，将代码复制进去，有备注的地方需要改动一下，其他不用动。运行成功，即连接成功
import java.sql.Connection; import java.sql.Date; import java.sql.DriverManager; import java.sql.PreparedStatement; import java.sql.SQLException; //import java.util.Scanner; public class demo { private static String dbUserName = "sa";//用户名 private static String dbPassword = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73502d649853dd45b03f22b95033f669/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/487c6b4d8ef9d9887b3195e03ac36004/" rel="bookmark">
			Bugku之社工-进阶收集（通俗）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个题目我感觉还是很有意思的，相比于SSTI感觉自己又行了。下面的讲解有点话“多”，因为有趣，更喜欢码字。
社工类型全称是社会工程学。很多时候通过一个用户名、一串数字、一串英文代码，通过社工攻击手段，加以筛选、整理，就能把你的所有个人情况信息、家庭状况、兴趣爱好、婚姻状况、你在网上留下的一切痕迹等个人信息全部掌握得一清二楚。社会工程学一定程度上是网络安全的一门学问，一定程度上也是在提醒每一位爱好者在网络中注重个人安全。
一. 题目 二.题目分析 有用信息 首先，我们要了解题目的目的，根据提示：
我们知道目的就是找到小美小区的名字。
之后要获取相关的信息，点击bugku用两金币购买，发现基于的是一张照片的信息
通过上面的照片我们可以得到的有效消息是：
A.首先根据图片我们可以得到小美到达的地方是：大雁塔（说实话我第一次还没反应过来，这也是关键所在）
B.小美一共坐了七站，中途转一站。出发地为小美家，离小美家有最近站点（且为始发站）的是800米，离最近的下一站则是一公里左右。
分析 因为大雁塔是位于西安市，因此先去弄一张西安地铁图
大雁搭位于四号线，离大雁塔站7站的始发站有两个，分别是2号线的韦曲南和3号线的鱼化寨。但是小美在地铁过程中要进行中转，所以我们可以锁定小美是从韦曲南站出发的。
这时候我们就要运用神奇——高德地图。去找离韦曲南站800米的一个圆，然后搜索可能的目标。
自此开始了我的尝试，因为flag就是小区的名字，运气好的就是我尝试的第一个“兰乔国际城”就对了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f1bf066952f5ecb67ad5ced31743f66/" rel="bookmark">
			java马斯京根法计算汇流系数P
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package game; import java.util.*; public class hydrological_forecast2 { public static void main(String[] args) { Scanner sc=new Scanner(System.in); // 参数Ke、Xe和n的确定 //	System.out.print("请输入河长L值："); //	int L = sc.nextInt(); //	System.out.print("请输入△t值："); //	int bt = sc.nextInt(); //	System.out.print("请输入x值："); //	double x = sc.nextDouble(); //	System.out.print("请输入K值："); //	int K = sc.nextInt(); int L = 512; int bt = 3; double x = 0.34; int K = 12; int Ke = bt; int n = K/bt; double Le = L/n; double Xe = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f1bf066952f5ecb67ad5ced31743f66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72351e80d83032d2c3679c9c15653d8e/" rel="bookmark">
			[ERROR]: Action client not connected:***/arm_trajectory_controller
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写自定义目录标题 出现原因解决方法方法1.修改moveit_config方法2 控制器名字修改 出现原因 Moveit配置机械臂时，点的是自动配置ROS Control，配置的名字会是group名字加上_controller。也就是下面的名字没有中间的trajectory(下面是我已经修改过的，用的是第一种方法)，我在Planning Groups里创建了两个group，分别是arm和gripper。
我实际配置的控制器在config/arm_controller中(每个人路径不一样,看你launch文件load的是哪个配置文件)，我配置的控制器名字如下：
名字不一样导致出问题，无法加载。
解决方法 方法1.修改moveit_config 点开配置生成的moveit_config/config/ros_controllers.yaml，把名字改成自己的。
方法2 控制器名字修改 launch中加载的控制器的名字改成group名+controller即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d16282af99ec1e5fee07faca88f97ddb/" rel="bookmark">
			tensorflow2 训练和预测使用不同的输出层、获取权重参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目标： youtubeNet通过训练tensorflow2时设置不同的激活函数，训练和预测采用不同的分支，然后可以在训练和测试时，把模型进行分离，得到训练和预测时，某些层的参数不同。可以通过类似迁移学习的办法实现。
第二，获取训练模型的参数。
获取模型参数： 比较简单，就是调用model.get_weights()。也可以用精确定位到某层，得到 w_dense4 =model.get_layer('dense4').get_weights()
#获取训练后的权重参数
weigts_parm = model.get_weights()
获得的就是模型参数的每一层权重和偏置信息。
模型不同输出： 想不到更好办法，利用迁移学习的办法，如果模型天生支持判断是预测阶段还是预测阶段，就更好了。
原理就是：
模型构建时，先构建一个分支，一个用于训练train。把要替换的层或者激活函数单独拧出来。利用模型打包compile时，把train都包含进模型。利用train=train，这样训练还是用到训练参数。预测时，单独新建一个model，去接收之前model某层的输出。添加上自己想要的层，如果需要重新训练，则重新compile，如果不想再训练，直接predict就好了。
由于预测的那个分支没有经过训练，所以一般只适用于对最后输出层，采用了不同的输出函数，比如YouTube推荐模型，输出层训练时用得weighted LR，而预测时用了e^x 激活函数，这种方式就能实现训练时用一个激活函数，预测时用另一个激活函数。 import tensorflow as tf import os import pandas as pd # 读取数据集 (train_images, train_labels), (test_images, test_labels) = tf.keras.datasets.fashion_mnist.load_data() # 数据集归一化,注意softmax输出的分类labels不用归一化 train_images = train_images / 255 test_images = test_images / 255 # 创建模型结构 net_input=tf.keras.Input(shape=(28,28)) fl=tf.keras.layers.Flatten(name='flatten')(net_input)#调用input l1=tf.keras.layers.Dense(128,activation="relu",name='dense1')(fl) d1=tf.keras.layers.Dense(64,activation="relu",name='dense2')(l1) l2=tf.keras.layers.Dense(32,activation="relu",name='dense3')(d1) l3=tf.keras.layers.Dense(10,activation=None,name='dense4')(l2) output=tf.keras.activations.softmax(l3) # 创建模型类 model = tf.keras.Model(inputs=net_input, outputs=output) # 查看模型的结构 model.summary() # 模型编译 model.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d16282af99ec1e5fee07faca88f97ddb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2600d3ba4dc51094c47ed3165e2d91d/" rel="bookmark">
			ES6中的class类内容详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ES6中的class类 认识class定义类 ​ 我们会发现，按照前面的构造函数形式创建 类，不仅仅和编写普通的函数过于相似，而且代码并不容易理解。
在ES6（ECMAScript2015）新的标准中使用了class关键字来直接定义类；但是类本质上依然是前面所讲的构造函数、原型链的语法糖而已；所以学好了前面的构造函数、原型链更有利于我们理解类的概念和继承关系；
​ 那么，如何使用class来定义一个类呢？–可以使用两种方式来声明类：类声明和类表达式；
class Person{ //类声明 } const Person=class{ //类表达式 } 类和构造函数的异同 ​ 我们来研究一下类的一些特性：你会发现它和我们的构造函数的特性其实是一致的；
console.log(Person.prototype) console.log(Person.prototype.__proto__)//Object null console.log(Person.prototype.constructor)//Person console.log(typeof Person) // function var p = new Person() console.log(p.__proto__ === Person.prototype) // true 类的构造函数 如果我们希望在创建对象的时候给类传递一些参数，这个时候应该如何做呢？
每个类都可以有一个自己的构造函数（方法），这个方法的名称是固定的constructor；当我们通过new操作符，操作一个类的时候会调用这个类的构造函数constructor；每个类只能有一个构造函数，如果包含多个构造函数，那么会抛出异常； 当我们通过new关键字操作类的时候，会调用这个constructor函数，并且执行如下操作：
1.在内存中创建一个新的对象（空对象）；2.这个对象内部的[[prototype]]属性会被赋值为该类的prototype属性；3.构造函数内部的this，会指向创建出来的新对象；4.执行构造函数的内部代码（函数体代码）；5.如果构造函数没有返回非空对象，则返回创建出来的新对象； 类的实例方法 在上面我们定义的属性都是直接放到了this上，也就意味着它是放到了创建出来的新对象中：
在前面我们说过对于实例的方法，我们是希望放到原型上的，这样可以被多个实例来共享；
这个时候我们可以直接在类中定义；
class Person { constructor(name, age) { this.name = name this.age = age this._address = "广州市" } // 普通的实例方法 // 创建出来的对象进行访问 // var p = new Person() // p.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2600d3ba4dc51094c47ed3165e2d91d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23444c829c5e5a40cdfd14feab04d371/" rel="bookmark">
			JSP 基本语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; Method1: &lt;p&gt; &lt;%@ page import="java.util.*"%&gt; &lt;% Date date = new Date(); //System.out.println(date); %&gt; hello, the date is &lt;%=date%&gt;&lt;br&gt; &lt;/p&gt; Method2: &lt;p&gt; hello, the date is: &lt;%@ page import="java.util.*"%&gt; &lt;%=new Date()%&gt;&lt;br&gt; &lt;% out.print(new Date());//the same %&gt; &lt;/p&gt; Method3: 使用函数 &lt;p&gt; &lt;%@page import="java.util.*"%&gt; &lt;%!Date date = new Date(); Date getMyDate() { System.out.println("the date is :"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23444c829c5e5a40cdfd14feab04d371/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f60f7a438a25038fce556e26b4bfc08/" rel="bookmark">
			看完GitHub2021年度官方报告，才发现7300万开发者都在卷呐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是知识兔小编，
7300万开发者在365天里能做什么？
最近，全球最大开发者社区GitHub重磅发布2021年度报告，透露了一个数据：GitHub目前在全球已有超过7300万开发者用户，其中56.8%来自北美之外的地区。
在新冠疫情仍未褪去的2021年， 今年的Octoverse 报告中体现了全球的开发者如何以更智能、更可持续的方式开发代码、创建文档、支持社区。
本报告结合了 400 万个以上存储库的统计数据，以及来自 12000 多名开发者的调查结果。
中国开发者全球第二，JavaScript最受欢迎
在过去的一年中，共有1600万新开发者加入了GitHub社区。
在全球总开发者数量中，美国开发者最多，共有1355万。
中国次之，共有755万GitHub开发者。
报告显示，JavaScript 仍然是 GitHub 上最受欢迎的编程语言，而 Python 现在是第二受欢迎的语言，紧随其后的是 Java 和快速增长的TypeScript。
在 GitHub 的所有者微软公司的维护下，TypeScript 已经从2018年和2019年的第七位攀升到今年的第四位。PHP 和 Ruby 这两种五年前最受欢迎的语言的受欢迎程度继续下降。
开源项目的首次贡献者数量也是在逐年增长，相较于2020年，今年增加了213,319名首次开源项目贡献者。
今年GitHub根据调查数据创建了预测模型，以便于帮助理解团队在软件开发和交付中使用不同实践的影响。
分别是：更快速编写和发送代码、创建文档，以及支持可持续社区。
2021年，Github上代码编写和生成的自动化程度显著提高，这使得不同团队之间的协作更方便，开发者的工作价值更易实现。
报告显示，由于代码生成的自动化程度提升，已完成的项目和开源项目资源库的表现分别提升了43%和27%。
无缝代码重用让开发者的效率提升了87%。
2021年，开发者代码的传递速度大幅提升。开发团队每日合并的拉取请求数量提高了61%。开发者更少的项目，合并速度更快，一般不到1天即完成合并。
工具与说明文档在提升开发者生产力上功不可没。报告显示，受益于这类工具和文档，开源库和企业项目开发者的平均产出提升了50%。
在过去相当长的一段时间里，说明文档、Readme等辅助技术资料的意义一直被低估了。
报告显示，2021年，这类辅助说明文档让Github开发者的产出大幅跃升了55%。
为了提升效率，企业也应该在项目开发中多增设这类文档。
2021年，在新冠疫情仍然严峻的情况下，更多开发者选择了利用Github远程工作。
调查显示，过去一年里，有20%的Github开发者选择了完全远程开发，26%的开发者选择现场与远程开发结合的方式。
再厉害的开发者也需要指导。
无论是对公司项目，还是开源项目，友好的评论和及时的指导都是极其重要的。
报告显示，当新的贡献者得到友好和及时的评论，并承诺提供指导时，会大幅提升开发团队的产出。开源项目提高了 46%，企业项目提高了 16%。关注公众号：程序IT圈，回复：666领取资料 。
人们通常在 GitHub 上的第一个小时会做什么？
192,830人创建议题，16,102人发起PR等待别人合入自己的代码, 24,404将自己代码推到原作者的仓，60,854人就议题做出回应...
大型存储库通常会使用 Good First Issue 标签，因为这是一种非常有效的做法。
数据显示，当21%-30%的问题被标记为 Good First Issues 的存储库时，就会平均有 13% 的新贡献者。
有超过 40% 的 Good First Issues 标注就可以帮助项目吸引 21% 以上的新贡献者。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2769771453d42883de7c967dcc8ed4f5/" rel="bookmark">
			StackExchang.Redis 不稳定解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多次连接Redis,常常取不到值，错误如下：
1.Timeout performing HGET
2.No connection is available to service this operation
通过Github Issues查到解决方案： 1.https://github.com/StackExchange/StackExchange.Redis/issues/12
2.http://stackoverflow.com/questions/22930856/stackexchange-redis-timeout-and-no-connection-is-available-to-service-this-oper
解决方案有3个：
1.根据你服务器的网络环境适当设置Timeout属性
2.注释Redis自动保存
save 900 1 save 300 10 save 60 10000
3.多节点 例如配置4个node,4*8=32个链接，远远超过200req/s
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c14e38ff8b010955ecc4665cb890e75f/" rel="bookmark">
			Python中将弧度转换为角度和将角度转换为弧度的计算degrees() 、radians()方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 选择题
以下python代码输出什么?
import math
print(math.degrees(math.pi/2)) A 180.0
B 45.0
C 90.0
D 30.0
问题解析
1.math.degrees(x)方法将弧度转换为角度，以浮点数据类型返回x的角度值，并至少保留一位小数。
2.math.radians(x)方法将角度转换为弧度，以浮点数据类型返回x的弧度值，并至少保留一位小数。
3.三种计算三角函数的方法均需导入math库。
4.题目中计算pi/2的角度制，答案为90，保留一位小数后返回值为90.0。
答案
正确答案是：C
温馨期待
欢迎大家转发，一起传播知识和正能量，帮助到更多人。期待大家提出宝贵改进建议，互相交流，收获更大。辛苦大家转发时注明出处(也是咱们公益编程交流群的入口网址)，刘经纬老师共享知识相关文件下载地址为：http://liujingwei.cn
期待大家提出宝贵建议，互相交流，收获更大，助教：mmy[太阳] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccfb37fe578cef490b67c1c5514140e0/" rel="bookmark">
			对象创建方法 &amp; Date()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;html&gt; &lt;body&gt; &lt;h1&gt;使用 new Object()创建一个对象&lt;/h1&gt; &lt;p id="demo"&gt;&lt;/p&gt; &lt;script&gt; // definition1 : 创建一个person 对象 var person = new Object(); person.age = 18; person.name = "Ethan"; document.getElementById("demo").innerHTML = (person.age); //注意innerHTML 后面是等于 document.write(person.age + "&lt;br&gt;"); // definition2: var person2 = { "name": "Gokop", "age": "18" }; document.write(person2.name + "&lt;br&gt;"); //definition 3: var person3 = {}; person3["name"] = "LeoWang"; person3["age"] = "17"; document.write("person3: " + person3.age + "&lt;br&gt;"); //关于Date（）及获得具体年月日的方法： var date = new Date(); document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccfb37fe578cef490b67c1c5514140e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30136395f01879792198317c11831ea4/" rel="bookmark">
			Kubernetes
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、Kubernetes简介
1、概念
2、主要特性：
二、Kubernetes 基本概念
架构：
1.核心组件
2.除了核心组件，还有一些推荐的 Add-ons：
3.分层架构
一、Kubernetes简介 1、概念 Kubernetes（简称k8s）是Google开源的一个容器编排引擎，它支持自动化部署、大规模可伸缩、应用容器化管理。在生产环境中部署一个应用程序时，通常要部署该应用的多个实例以便对应用请求进行负载均衡。
在Kubernetes中，我们可以创建多个容器，每个容器里面运行一个应用实例，然后通过内置的负载均衡策略，实现对这一组应用实例的管理、发现、访问，而这些细节都不需要运维人员去进行复杂的手工配置和处理。
2、主要特性： 基于容器的应用部署、维护和滚动升级负载均衡和服务发现跨机器和跨地区的集群调度自动伸缩无状态服务和有状态服务广泛的 Volume 支持插件机制保证扩展性
二、Kubernetes 基本概念 1、Container Container（容器）是一种便携式、轻量级的操作系统级虚拟化技术。它使用 namespace 隔离不同的软件运行环境，并通过镜像自包含软件的运行环境，从而使得容 器可以很方便的在任何地方运行。
2、Pod Kubernetes 使用 Pod 来管理容器，每个 Pod 可以包含一个或多个紧密关联的容器。 Pod 是一组紧密关联的容器集合，它们共享 PID、IPC、Network 和 UTS namespace， 是 Kubernetes 调度的基本单位。Pod 内的多个容器共享网络和文件系统，可以通过进程间通信和文件共享这种简单高效的方式组合完成服务。
3、Node(负责干活的) Node 是 Pod 真正运行的主机，可以是物理机，也可以是虚拟机。为了管理 Pod，每个 Node 节点上至少要运行 container runtime（比如 docker 或者 rkt）、 kubelet 和 kube-proxy 服务。
4、Namespace Namespace 是对一组资源和对象的抽象集合，比如可以用来将系统内部的对象划分为 不同的项目组或用户组。常见的 pods, services, replication controllers 和 deployments 等都是属于某一个 namespace 的（默认是 default），而 node, persistentVolumes 等则 不属于任何 namespace。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30136395f01879792198317c11831ea4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2ff17bc386fa24ece25f392c147de83/" rel="bookmark">
			Rotate to Attend 三分支结构捕获跨维度交互的注意力机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Rotate to Attend: Convolutional Triplet Attention Module 论文的名字很好，反映了本文的核心想法：triplet attention，这是一种通过使用三分支结构捕获跨维度交互来计算注意力权重的新方法。对于输入张量，triplet attention通过旋转操作，然后使用残差变换建立维度间的依存关系，并以可忽略的计算开销对通道间和空间信息进行编码。 paper：https://arxiv.org/pdf/2010.03045.pdf
github：https://github.com/landskape-ai/triplet-attention/
前言 这次是复现WACV2021的一篇论文，本论文的注意力非常简单，而且是一个即插即用的小模块，接近于无参数可用于多种网络。
本文的主要创新点是提出了一个新的注意力机制，是一个Channel &amp; Spatial attention，在各CV任务测试性能如下
相关代码 具体的网络结构如上图所示：
1.第一个分支：通道C和空间W维度交互捕获分支，输入特征先经过permute，变为H X C X W维度特征，接着在H维度上进行Z-Pool，后面操作类似。最后需要经过permuter变为C X H X W维度特征，方便进行element-wise相加
2.第二个分支：通道C和空间H维度交互捕获分支，输入特征先经过permute，变为W X H X C维度特征，接着在W维度上进行Z-Pool，后面操作类似。最后需要经过permuter变为C X H X W维度特征，方便进行element-wise相加
3.第三个分支：通道注意力计算分支，输入特征经过Z-Pool，再接着7 x 7卷积，最后Sigmoid激活函数生成空间注意力权重
最后对3个分支输出特征进行相加求Avg
import paddle import paddle.nn as nn import cv2 class BasicConv(nn.Layer): def __init__( self, in_planes, out_planes, kernel_size, stride=1, padding=0, dilation=1, groups=1, relu=True, bn=True, bias_attr=False, ): super(BasicConv, self).__init__() self.out_channels = out_planes self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2ff17bc386fa24ece25f392c147de83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/712ca02eadb4a8e6daccd8d6f775fe9b/" rel="bookmark">
			软考电子证书打印时间及有关问题解答
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2021年上半年软考纸质证书预计要到10月左右才能陆续领取，所以很多考生目前把关注点放在“软考电子证书”上，但并非所有地区都有电子证书的。那些地区实行软考电子证书?中国人事考试网查询的证书是不是就是电子证书?电子证书和纸质证书一样吗?......带着这些问题，请往下看。
问：那些地区实行软考电子证书?
答：并不是所有地区都实行电子证书打印，据小编了解，目前实行软考电子证书的省份有浙江、广东、山东，电子证书只在省内有效!对于软考电子证书是否全国实行，在工信部官网我们也可以找到相关信息。
注：秦皇岛也实行软考电子证书，但与前三者有所区别，因为秦皇岛不发纸质证书，只提供电子证书，且在全国有效。
问：　软考电子证书在哪打印?
答：广东：可通过广东省人力资源和社会保障厅网上服务平台、广东省人事考试网的电子证书专栏或证书发放栏目访问广东省专业技术人员职业资格电子证书系统(以下简称“电子证书系统”)，或直接访问网址：广东省专业技术人员职业资格电子证书系统。
浙江：在浙江政务服务网下载打印电子合格证明。查询打印网址：浙江省人民政府 浙江政务服务网 高级职称评审与专技考试 (首页搜索“高级职称评审与专技考试”|考试成绩查询及电子证书下载打印|专业技术人员资格考试证书)。
山东：合格人员可登录手机“爱山东”APP或登录“山东人事考试信息网(山东人事考试信息网)”查询、下载、打印电子合格证明。打开山东人事考试信息网——找到并点击“证书办理”栏目——找到并点击“电子合格证明”——点击“登录入口”——登录电子合格证明系统——下载电子合格证明。
注：如有变化，请以当年当地官方通知为准。
问：中国人事考试网查询到的证书不是电子证书吗?
答：中国人事考试网查询到的是”证书电子文件“，而不是“电子证书”。可能很多考生可能习惯于称之为电子证书。但根据《人力资源社会保障部办公厅关于推行专业技术人员职业资格证书网络查询验证服务的通知》(人社厅发〔2019〕27号)，个人和机构均可以通过中国人事考试网证书查询验证系统进行证书查询验证，证书持有人可通过证书查询验证系统自行下载打印本人所持证书的电子证书或电子文件。
已实行电子证书的，查询验证结果显示为电子证书。电子证书加盖证书用印单位的电子印章，与纸质证书具有同等法律效力，可以代替纸质证书。其他任何形式的电子证书再转换版本，不具备同等法律效力。
暂未实行电子证书的，查询验证结果显示为标注“人力资源和社会保障部人事考试中心提供查询结果”字样的电子文件。该电子文件可作为通过该项考试的证明。其他社会机构或个人可通过证书查询验证系统在线验证证书信息真伪。
因为软考还没有实行全国电子证书制度，所以查询到的准确来说是“电子文件”而不是电子证书。
比如以下两份，上面的是中国人事考试网查询到的电子文件样本，下面的是广东省软考电子证书样本：
证书电子文件
广东省软考电子证书 问：中国人事考试网查询到的软考证书有效力吗?
答：理论上来说是没有效力的，因为它上面没有工信部或人社局的“印章”只标注有“人力资源和社会保障部人事考试中心提供查询结果”字样。但是该电子文件可作为通过该项考试的证明，其他社会机构或个人可通过证书查询验证系统在线验证证书信息真伪。
问：软考电子证书什么时候可以打印?
答：每个地区电子证书打印时间不同，一般在合格标准公布后一个多月便可以打印!比如浙江2019年上半年软考电子证书打印时间是9月19日，2018年上半年是9月3日，广东的软考电子证书可能会慢一点(毕竟每年广东考生很多)，山东因为今年刚实行暂时没有参考。
中国人事考试网的证书电子文件已于2021年8月20日可查询打印，软考办官网也开通了查询入口。
问：软考电子证书和纸质证书是否具有同等效力?
答：浙江、广东、山东的软考电子证书在省内同纸质证书具有同等效力：
浙江：加盖电子印章的专业技术人员资格电子证书与纸质证书具有同等法律效用，可作为我省相应系列专业技术资格评审或岗位聘任的有效凭证。专业技术资格电子证书的任何形式的电子再转换版本，不具备同等法律效力。
广东：电子合格证明和电子证书在全省范围内与纸质证书具有同等效力，其他任何形式的电子再转换版本，不具备同等效力。
山东：电子合格证明表明持证人员取得相应职业资格，在山东省内符合条件的可作为职称评审、岗位聘用以及执业注册的有效凭证(国家另有规定的除外)。电子合格证明任何形式的电子再转化版本，不具备同等效力。
问：软考证书实行电子证书后，是否还会发放纸质证书?
答：目前山东、浙江、广东除了电子证书外还会发放纸质证书，由国家人力资源和社会保障部统一印发，领证时间一般要晚于电子证书打印时间，所以如果有急用的话，可以先打印电子证书。
问：电子证书上的二维码有什么用?和纸质证书上一样吗?
答：电子证书的上二维码与纸质证书上的二维码一致，可通过人力资源和社会保障部微信公众号的人社服务进行证书验证。
C站（CSDN）能力认证中心
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/768e1def53b12ab15569e653a83e2f2e/" rel="bookmark">
			安装DirectX SDK时出现Error Code:s1023 的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天安装DXSDK_Jun10时（下载地址：http://download.microsoft.com/download/A/E/7/AE743F1F-632B-4809-87A9-AA1BB3458E31/DXSDK_Jun10.exe），出现下图所示错误Error Code:s1023
错误原因：
计算机上有安装过更新版的Microsoft Visual C++ 2010 Redistributable，打开“控制面板”的“程序和功能”，果然计算机里之前有安装“Microsoft Visual C++ 2010 x86 Redistributable - 1010.0.40219”，而DXSDK_Jun安装的是“Microsoft Visual C++ 2010 x86 Redistributable - 1010.0.30319”，版本低于本机已安装的版本，所以安装出现s1023错误。
解决办法：
卸载更高的版本“Microsoft Visual C++ 2010 x86 Redistributable - 1010.0.40219”，再重新安装即可。
卸载“Microsoft Visual C++ 2010 x86 Redistributable - 1010.0.40219”有没有影响？
其实卸载“Microsoft Visual C++ 2010 x86 Redistributable - 1010.0.40219”后有安装Microsoft Visual C++ 2010 x86 Redistributable，只是版本比之前低，在win7 64下，安装完DXSDK_Jun10后，有
所以影响不大。
如果实在需要“Microsoft Visual C++ 2010 x86 Redistributable - 1010.0.40219”，可在安装完DXSDK_Jun10之后再安装。下载页面地址（http://www.microsoft.com/en-us/download/details.aspx?id=26999 ）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bad5619d46265428a98c58e93dbd43b/" rel="bookmark">
			JS 取半年或一年后的时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 var d = new Date('2021-12-17'); d.setMonth(d.getMonth() + 6); //加半年 d.setFullYear(d.getFullYear() + 1); //加一年 d.setMonth(d.getMonth() + 12); //加一年 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b67ace78b3f5230754d58f3dd72227d/" rel="bookmark">
			c# 读取大容量文本插入SqlServer数据库（超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面
读取大容量文本数据到数据库，可以用流的方式读取到内存然后再拼接成T-SQL语句插入，显然，这个是效率极低的做法。
下面给大家展示一个超快速的大容量读取文本插入SqlServer数据库，用的是BULK INSERT
Oracle实现方法点击我
Mysql实现方法点击我
分三步，第一步创建数据库和表，第二步构造出一个文本数据，第三步读取文本数据到数据库，完整代码在文章结尾处。
第一步：创建数据库和创建数据表 --创建数据库 CREATE DATABASE MDBIArbinXMasterInfo; --创建数据表 USE [MDBIArbinXMasterInfo] GO /****** Object: Table [dbo].[Test] Script Date: 2021/12/17 15:26:14 ******/ SET ANSI_NULLS ON GO SET QUOTED_IDENTIFIER ON GO CREATE TABLE [dbo].[Test]( [test1] [int] NULL, [test2] [int] NULL ) ON [PRIMARY] GO 第二步：构造测试数据到文本，结果如下图 public static void SetData() { //数据的存放路径 string bcpFilePath = Path.Combine(Environment.CurrentDirectory, "test.txt"); StringBuilder stringBuilder = new StringBuilder(); using (StreamWriter sw = new StreamWriter(bcpFilePath)) { for (int i = 0; i &lt; 1000000; i++) { stringBuilder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b67ace78b3f5230754d58f3dd72227d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1df34608020e221f47d54bf099d7bd39/" rel="bookmark">
			星环科技分布式搜索引擎 Transwarp Scope 查询优化技术解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述
分布式数据库系统是物理上分布而逻辑上集中的数据库系统，为了提高性能并最大限度地减少资源争用，其被广泛用于海量数据处理的场景中。在这种情况下，数据库查询速度是系统性能表现的决定性指标。而由于数据分布在不同节点上并通过网络通信在不同节点间传输，分布式查询的处理流程比单机集中式查询更加复杂。与传统的集中式数据库系统相比，对分布式查询的构建和优化需要同时考虑CPU、I/O成本以及网络通信成本。
本文旨在从分布式集群视角，对Transwarp Scope查询相关原理和优化技术进行较为全面的解读。
整体流程
对于分布式搜索引擎来说，一般情况下， 一次查询涉及到多台机器的多个分片，正确的结果需要汇总多个分片的各自结果之后才能获得。因此，无论是Transwarp Scope还是es，其查询过程都包括一个Merger的角色存在，这个Merger在es中是Coordinating node, 而在NS中是Client。而整个流程以Phase划分，可以分为DFS, QUERY, FETCH三类Phase。
专用词与明确
分片一般也被成为shard/tablet
Phase简介
DFS Phase:统计数据收集阶段，对于文本信息来说，其在单个text中的freq等信息是准确的。但是类似与idf这样的全局统计信息而言，每个分片只能明确该文本在分片内部的idf，也就是一个局部的idf。如果不进行全局idf综合统计，仅以local idf计算score，得出来的分数是不准确的。所以，在很多对打分结果准确性要求较高的场景下， 都会有dfs这个阶段进行全局统计信息汇总。当然，也因为多了这个阶段，相应地响应速度也会受到影响。
Query Phase:查询阶段， 根据client输入的信息在各个分片上找到匹配的文档集合。这一阶段基本上会做3件事情：match（匹配），score(打分），local_sort(本地排序）。各个分片会将匹配的doc_id集合，返回给Merger节点。Merger节点会对各个分片汇报上来的doc_set进行merge + global_sort。然后根据client设定的from,size, 从global_result_set中cut出[from, from + size]，再进行下一阶段。
Fetch阶段：获取doc原始内容的phase。该Phase会根据Query Phase结束后的global_result_set向各个分片索要目标的doc_set, 包括文档的原始内容以及可能的某些再加工内容，比如Highlight。由于要真正地加载文档内容[source]，所以 Fetch阶段会产生比较大的io负载（page cache缺失的情况下）。因此，如果是一些大宽表（500列+）的场景，其行数据size比较大的情况下，更可行的方式其实是把ES/NS作为一张纯粹的Index Table，即只对目标列设置索引 + 对外表主键列存储source。如此，当query阶段阶段执行完之后，进行fetch phase的时候只需要加载rowkey这一列的值，再global_result_set中的外表rowkey值去外部行数据库中拿到原始内容，这样做能明显减轻es/ns集群的存储和读写压力。
从整体上来看，查询部分基本的架构原则就是用各种不同的Phase拼接执行不同的查询动作，即Compose Phases into Action.如上图示意。
查询操作类型简介
查询操作本身可以按照如上图这样进行细分， 各自含义如下表：
点查询图解
点查，或者说排序查询是核心功能，举例如下。
对于一张成绩表schema=(姓名、数学成绩、语文成绩、 英语成绩），整张表格有3个tablet, 现在要获取全部成绩的前3名，则整体流程如下图所示。
如上图所示，即为单次点查询的原理示意图。在Query阶段，所有Tablet都将自己的数学成绩的前3名汇总给Merger, Merger进行全局排序之后，发现真正的前三名是tablet1的11,4号, tablet3的4号。然后在Fetch阶段，将这些对应doc标识发送给tablet1, tablet3, 再拿到对应的文档原始内容，这里有2处细节值得提及。
二维全局rowKey。在上图所示数据分布体系中， 用以表示全局唯一row或者doc的标识是一个（tablet, docId)的二元组，及tablet1和tablet3都有doc4, 但2者没有关系。
上图所示是在全局数据本身无序分布的情况下进行排序查询的流程，如果对数据本身就是有序分布的， 那么流程会大大简化，这一点会在后续内容中讨论。
分页查询
所谓分页查询，或者扫描，就是当结果集比较大的时候，分成多次rpc返回结果。
1.并发分页查询
所谓并发分页，如下图所示，就是client同时向所有的tablet发送request。这种情况下，每一页的具体流程以排序/不排序分可以对应上文点查/轻量点查。
2.顺序分页查
所谓顺序分页查，如上右图所示，指的是每一页并不是将rpc同时发送给所有tablet, 而是对所有tablet进行逐个扫描，tablet1，tablet2，tablet3。这种扫描方式的明显好处就是大幅度减少了rpc的数量，降低了集群整体负载。又因为每个rpc只有1个tablet的结果，所以也不需要进行多个tablet结果的合并，降低了client的处理负载。
3.动态超分页查询
对于查询操作来说，缓存是很有效果的优化措施。尤其是对一些单线程扫描全表的应用，其客户端内存可能大量闲置。这种场景下，合理地使用客户端内存作为缓存来优化查询速度，就是动态超分页查询的思想，其基本原理仍以是否排序分2种情况讨论。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1df34608020e221f47d54bf099d7bd39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0e3c10fd66ae1e3e5d05154f4ecdf10/" rel="bookmark">
			从用户真实需求出发，星环数据云平台 TDC 2.5 版本发布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2021 年是数字化转型关键的一年，据工信部消息显示，截止 2020 年，全国制造业数字化普及率为 69.8%，趋势一片向好。与此同时，埃森哲（Accenture）的一份研究报告显示，80%的中国企业正在进行数字化转型，但真正释放数字化潜力的只有 4%。这也就说明大部分企业的数字化转型依然只是处于尝试阶段，即使大型企业也不例外。
星环科技通过大量的研究与观察发现，大型企业普遍缺乏能够满足多租户、弹性、灵活的数字化基础设施。传统的烟囱式系统架构导致企业内不同部门各自为政，重复建设自己的数据存储、IT 设备以及数据库，而不同的业务架构之间数据也无法互联互通，造成资源重复投入、数据孤岛等问题，阻碍企业的发展。企业也在努力寻找适合的数字化转型方案。
在今天的主角星环数据云平台 Transwarp Data Cloud 2.5 亮相之前，先给大家分享两组星环科技市场部近期做的用户调研数据。这份调研数据清楚地展示了用户的真实需求，在左边这张图中我们看到用户对于大数据集群服务功能关注度排名前五的包括：平台稳定性、功能完备性、平台性能、平台安全和易操作性。这些功能关乎客户的研发投入、使用成本甚至业务的运转。此外，随着企业内大数据源源不断地产生，客户的扩容需求也在与日俱增，从右边这张图中我们可以看到，被调研的所有用户都会有年度扩容需求。
面对以上种种挑战以及客户的真实需求，星环数据云平台 Transwarp Data Cloud（ 以下简称TDC ）应运而生。TDC 底层基于容器面向大数据应用的云原生操作系统Transwarp Cloud Operating System（以下简称TCOS），在一个 PaaS 平台上提供包括数据分析、应用开发和智能建模等在内的完整的面向数据生命周期的工具链，加速企业数字化转型。
基于星环 TDC 为江苏农信建设的大数据 DAAS 应用平台，提升江苏农信数据输出服务能力，通过 “数据+服务+应用”，产生闭环，促进生态，提升了数据资产服务、AI 模型工厂、业务应用共享等数据能力；基于 TDC 为某运营商建设的容器化大数据能力开放平台，实现了整体 IT 技术架构的容器化升级，整体资源利用率提升 60%，大数据服务交付时间由一周缩减至 2 小时。目前，星环数据云 TDC 已经在金融、能源、政府等多个行业落地。
今天，星环数据云平台TDC 再一次突破升级，迎来了 2.X 的长期支持版本 TDC 2.5，2.5 版本在原有基础上做了全方位提升，可以概括为：更稳定、更全面、更安全、更简单、更强大。
接下来我们将从用户的五大需求出发，解读星环数据云平台 TDC 2.5 版本在平台稳定性、功能完备性、平台性能、平台安全和易操作性上面的重要更新：
在平台稳定性上，TDC 2.5 版本的云原生底座星环云原生操作系统- TCOS 架构全新升级：1）自研组件与 Kubernetes 解耦，兼容性更好，且版本可以独立持续演进；2）新增和优化了均衡调度、存储调度、GPU 调度、应用感知调度等多种调度策略，提升大数据产品高效稳定运行；3）提供更加全面的监控能力，包括GPU、存储、网络等设备的监控，保障平台高效稳定运行，可以支持大规模集群，同时作为 TDC 2.x 系列的 LTS 版本，2.5 版本支持 TDC 2.x 版本平滑升级到 TDC 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0e3c10fd66ae1e3e5d05154f4ecdf10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba597ee9a83aa995d6babfdc9b658231/" rel="bookmark">
			Unity 代码中为物体添加Tag
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在代码中为物体添加tag时，如果在编辑器中未预先设定好tag，直接gameObject.tag="xxx"会报错。
如果预先不想在编辑器中设置tag，就直接代码自动在编辑器中生成所需要添加的tag，很简单 代码如下：
/// &lt;summary&gt; /// 检查tag列表中是否有tag，没有该tag添加此tag /// &lt;/summary&gt; /// &lt;param name="tag"&gt;所要设设置的tag&lt;/param&gt; public static void SetGameObjectTag(GameObject gameObject, string tag) { if (!UnityEditorInternal.InternalEditorUtility.tags.Equals(tag)) //如果tag列表中没有这个tag { UnityEditorInternal.InternalEditorUtility.AddTag(tag); //在tag列表中添加这个tag } gameObject.tag = tag; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cb86a3c441548dd9403d486a8609104/" rel="bookmark">
			如何解决“计算机意外地重新启动或遇到错误，Windows 安装无法继续。”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出现这样的问题多半是分区格式错误引起的。
解决方案：在出现错误提示的页面
按shift+F10 如果是笔记本电脑就要按shift+fn+F10 就会出现一个命令窗口
接着输入: cd oobe （注意中间有个空格）
接着继续输入 ：msoobe 然后回车
如果一直出现“海内存知己…”
那么就要换另外一种方法;
一，在错误页面按shift＋F10打开管理员窗口
二，键盘输入regedit（注册表），输完按下回车键。
三，找到HKEY_LOCAL_MACHINE&lt;SYSTEM&lt;Setup&lt;Status&lt;ChildCompletion
四，双击setup.exe
五，把数值数据从1为3，点击确定
六，关闭所有窗口，点击确定，重启。
完美解决！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b17163e405211a76de6bd95f953b70a/" rel="bookmark">
			软件测试之测试计划案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1. 范围和目的(需求说明)1.1 需求范围和目的1.2 需求变更 2. 总计划安排和负责人3. 测试方案3.1 测试重点3.2 测试策略方法3.2.1 测试类型3.2.2 测试基本策略 4. 环境搭建部署及数据准备4.1 测试环境部署4.2 数据准备 5. 测试用例6. 测试限制及风险评估项7. 版本验收标准 前言 本篇文章以某app为例(下面简称策策头条), 陈述测试计划. 我们先看下整体测试计划的目录.
如下进行各个部分内容展开, 本篇是先展示某个测试计划, 后续文章中则详细介绍如何编写测试计划.
1. 范围和目的(需求说明) 1.1 需求范围和目的 策策头条V1.2在V1.1版本基础上新增如下三个功能模块:
文章详情页–文章评论, 点赞及喜欢
我的–个人信息也–编辑上传个人头像
我的–实名认证
具体需求内容详见&lt;&lt;策策头条前台产品原型图&gt;&gt;
1.2 需求变更 无
2. 总计划安排和负责人 策策头条V1.2版本, 计划为20xx.12.01开始, 到20xx.12.18结束, 版本周期时长xx天, 测试人员2名, 具体进度安排如下:
注:
预估人日, 指的是需要一天需要几个人才能完成这个工作, 以编号3位例, 人/日=4,代表一天需要4个人完成该工作; 那么测试人员有2名, 则2天就能完成编号3的工作, 以此类推4名测试人员, 1天就能完成该工作.测试报告由项目组长或者测试主管负责定制. 3. 测试方案 3.1 测试重点 涉及系统: Android, IOS
覆盖范围: 本次版本全部新增需求
测试重点:
1)业务功能: 所有需求覆盖内容2)兼容性:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b17163e405211a76de6bd95f953b70a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7d44849df1c49b83c686d5c789b2d5b/" rel="bookmark">
			IDEA插件EasyCode使用时总是生成一些无用、报错代码如何在生成时去掉。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在使用EasyCode时，每次生成代码总是会报很多错，比如：
那么，我们如何在生成时就将这些无用的代码去掉呢？
先点击设置
当下载EasyCode后，会出现下面几个选项
最后在右边的框框内将会报错的代码删除就可以啦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc8982e612f2adb57a6ebee1f81eb5b4/" rel="bookmark">
			JavaScript DOM 基本操作：appendChild() &amp; removeChild()&amp;getElementsByTagName(“p“)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;html&gt; &lt;body&gt; &lt;h1&gt;用DOM 增加一个 paragraph&lt;/h1&gt; &lt;div id="demo"&gt; &lt;p id="p1"&gt;this is the paragraph to be removed&lt;/p&gt; &lt;button onclick="myFunction()" id="button"&gt;remove&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var p = document.createElement("p"); var node = document.createTextNode("hello"); p.appendChild(node); document.getElementById("demo").appendChild(p); &lt;/script&gt; &lt;h1&gt;用DOM 移除一个 paragraph&lt;/h1&gt; &lt;script&gt; function myFunction() { document.getElementById("demo").removeChild(document.getElementById("p1")); } &lt;/script&gt; &lt;div id="demo2"&gt;&lt;/div&gt; &lt;h2&gt;Summary:&lt;/h2&gt; &lt;p&gt; 1. 增加删除 主要使用的方法为 appendChild() &amp; removeChild()&lt;br&gt; 2. 给 paragraph 增加一段文字，需要把文字当成一个node 使用 createTextNode&lt;br&gt; 3. 增加paragraph 使用 createElement&lt;br&gt; &lt;/p&gt; &lt;script&gt; document.write(document.getElementById("demo").getElementsByTagName("p").length);//看一共有几个p //注意细节： getElement s &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1899a1c32316e4d06d6de128cf1b4cad/" rel="bookmark">
			H3C S5560-EI系列交换机配置Web管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #进入系统视图 &lt;H3C&gt;system-view #创建本地用户admin，并设置密码为a1234，服务类型为http和https，用户级别为network-admin管理员级别 [H3C] local-user admin [H3C-luser-manage-admin] password simple a1234 [H3C-luser-manage-admin] service-type http https [H3C-luser-manage-admin] authorization-attribute user-role network-admin [H3C-luser-manage-admin] quit #配置交换机Web管理口地址： [H3C] interface M-GigabitEthernet 0/0/0 [H3C-M-GigabitEthernet0/0/0] ip address 192.168.0.50 255.255.255.0 [H3C-M-GigabitEthernet0/0/0] quit #启用http和https服务 [H3C]ip http enable [H3C]ip https enable #保存配置 [H3C]save force 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47aa215a9593cdeb0be2f8c573b28902/" rel="bookmark">
			指令一之操作数的寻址方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、引言视图指令段寄存器EIP如何发生改变 二、操作数寻址方式(Operand-addressing Mode)1.寄存器寻址(Register Addressing)2.立即寻址(Immediate addressing)3.存储器寻址(Mermory addressing)3.1 直接寻址(direct addressing)3.2 寄存器间接寻址(register indirect addressing)3.3 寄存器相对寻址(register relative addressing)3.4 基址加变址寻址(base-plus-index addressing)3.5 相对基址变址寻址(base relative-plus-index addressing)3.6 比例变址寻址(scaled-index addressing) 三、总结 一、引言 视图 指令 指令=操作码 操作数1 操作数2
cpu一条接着一条地执行指令
段寄存器 ES:附加段寄存器
CS:代码段寄存器
SS:堆栈寄存器
DS:数据段寄存器
区分有效地址和实际中内存中的地址：
实际中内存的地址=有效地址+段地址
EIP如何发生改变 方式一：自动增量
方式二：跳转指令：更改程序计数器(PC)
方式三：分支指令：根据程序状态字PSW寄存器（也被称作标志寄存器FR）有条件地更改程序计数器
二、操作数寻址方式(Operand-addressing Mode) 是什么决定了在指令执行的每个步骤中将获取哪个数据项呢？
在c语言中：使用变量
在机器编码中：使用操作数寻址
操作数寻址方式分类：
寄存器寻址立即寻址存储器寻址 1.寄存器寻址(Register Addressing) 所有的操作数都存储在通用寄存器中
16位：AX,BX,CX,DX,SI,DL,SP或BP8位： AH,AL,BH,BL,CH,CL,DH或DL MOV AX,BX;//将数据从BX复制到AX 如下所示：
使用寄存器寻址，cpu无需访问内存就可以获取操作数，速度快很多
2.立即寻址(Immediate addressing) 在指令中使用的操作数是常数
MOV AX,1234H;//这里的1234H表示的是16进制数，将1234H复制到寄存器AX 如下所示：
解释一下：AX寄存器由AH和AL构成。
3.存储器寻址(Mermory addressing) 除了寄存器寻址（寄存器就在cpu中）和立即寻址（操作数就在指令中），其他的几种寻址方式的操作数都在内存单元中。
因此，对于存储器寻址，最重要的就是搞清楚cpu如何确定内存操作数的地址，然后cpu再对该内存单元的操作数进行处理。
3.1 直接寻址(direct addressing) 直接寻址就是指令中直接给出了内存操作数的地址。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47aa215a9593cdeb0be2f8c573b28902/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8e6dda9ce4feb664b2bb5147e270253/" rel="bookmark">
			ajax中的withCredentials使用效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		XMLHttpRequest.withCredentials 有什么用?
跨域请求是否提供凭据信息(cookie、HTTP认证及客户端SSL证明等)
也可以简单的理解为，当前请求为跨域类型时是否在请求中协带cookie。
XMLHttpRequest.withCredentials 怎么用?
withCredentials属于XMLHttpRequest对象下的属性，可以对其进行查看或配置。
查看withCredentials:
var xhr = new XMLHttpRequest(); xhr.open('GET', 'http://www.lovejavascript.com/learnLinkManager/getLearnLinkList', true); xhr.onreadystatechange = function() { console.log('withCredentials=&gt;', xhr.withCredentials); }; xhr.send(null); 配置withCredentials:
var xhr = new XMLHttpRequest(); xhr.withCredentials = true; xhr.open('GET', 'http://www.lovejavascript.com/learnLinkManager/getLearnLinkList', true); xhr.onreadystatechange = function() { console.log('withCredentials=&gt;', xhr.withCredentials); }; xhr.send(null); 虽然配置了拥有跨域访问权限，但是测试时的页面并不允许被当前域所调用，所以出现同源策略错误，下图所示为允许调用的示例：
var xhr = new XMLHttpRequest(); xhr.open('GET', 'http://172.19.0.215:1314/learnLinkManager/getLearnLinkList', true); xhr.withCredentials = true; xhr.onreadystatechange = function() { console.log('withCredentials=&gt;', xhr.withCredentials); }; xhr.send(null); 需要注意是，当配置了xhr.withCredentials = true时，必须在后端增加 response 头信息Access-Control-Allow-Origin，且必须指定域名，而不能指定为*。当前示例所采用的node端配置代码：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8e6dda9ce4feb664b2bb5147e270253/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a53d23af62a325361efebeaaf14fe2b4/" rel="bookmark">
			分布式存储系统之Ceph(理论详解)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Ceph 简介
ceph的构成
ceph 集群基础：
Monitor(ceph-mon)：ceph 监视器
Managers(ceph-mgr)的功能：
Ceph OSDs(对象存储守护程序 ceph-osd)：
MDS(ceph 元数据服务器，ceph-mds)：
Ceph 的管理节点：
元数据的保存方式
xattr 扩展属性
omap(object map 对象映射):
filestore与leveldb
bluestore 与 rocksdb
CRUSH 算法简介
Ceph 简介 Ceph 是一个开源的分布式存储系统，包括对象存储、块设备、文件系统
ceph 是一个对象(object)式存储系统，它把每一个待管理的数据流(文件等数据)切分为一到多个固定大小(默认 4 兆)的对象数据，并以其为原子单元(原子是构成元素的最小单元)完成数据的读写。
对象数据的底层存储服务是由多个存储主机(host)组成的存储集群，该集群也被称之为
RADOS(reliable automatic distributed object store)存储集群，即可靠的、自动化的、分布式的
对象存储系统。
ceph的构成 Pool：存储池、分区，存储池的大小取决于底层的存储空间。
PG(placement group)：一个 pool 内部可以有多个 PG 存在，pool 和 PG 都是抽象的逻辑概念，一个 pool 中有多少个 PG 可以通过公式计算。
OSD(Object Storage Daemon):每一块磁盘叫做 osd，多个 osd 组成一个主机
librados 是 RADOS 存储集群的 API，支持 C/C++/JAVA/python/ruby/php 等编程语言客户端调用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a53d23af62a325361efebeaaf14fe2b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c76e7f9c4b5ccbef0e6f2e6378c7ae7/" rel="bookmark">
			赫夫曼树（哈夫曼树）的创建（java实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、赫夫曼树是什么？1.路径和路径长度2.节点的权和带权路径长度3.树的带权路径长度 二、创建赫夫曼树1.图文创建过程2.代码实现 一、赫夫曼树是什么？ 给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度(WPL)达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。
图1 一棵赫夫曼树
1.路径和路径长度 在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。
例如图1根节点到b节点之间的通路称为一条路径。
在一条路径中，每经过一个结点，路径长度都要加 1 。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1。
例如图1根节点到c节点的路径长度为 4 - 1 = 3
2.节点的权和带权路径长度 若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。
例如图1中abcd节点的权值分别为12、5、6、21
结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积。
例如图1节点c的带权路径长度为 3 * 6 = 18
3.树的带权路径长度 树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL。
例如上图中的树的WPL = （5 + 6）* 3 + 12 * 2 + 21 = 78
二、创建赫夫曼树 1.图文创建过程 假设有n个权值，则构造出的哈夫曼树有n个叶子结点。 n个权值分别设为 w1、w2、…、wn，则哈夫曼树的构造规则为：
例如有四个叶子节点 a b c d 权值分别为 12、5、6、21
创建赫夫曼树前森林如下
(1) 将w1、w2、…，wn看成是有n 棵树的森林(每棵树仅有一个结点)；
(2) 在森林中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和；
在森林中取出 b c节点 形成一棵新树M
(3)从森林中删除选取的两棵树，并将新树加入森林；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c76e7f9c4b5ccbef0e6f2e6378c7ae7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0efc3cbc75b47d892db99a9fe95e76d1/" rel="bookmark">
			VSCode设置Live Server https
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、准备证书 OpenSSL生成本地https测试证书
阿里云免费SSL证书申请
二、安装Live Server 三、配置setttings.json setttings.json中增加一下配置
"liveServer.settings.https": { "enable": true, "cert": "C:\\cert\\server.pem", // 证书 "key": "C:\\cert\\privkey.pem", // 私钥 "passphrase": "" }, // "liveServer.settings.host": "127.0.0.1", // IP (可选) // "liveServer.settings.port": 5500 // 端口 (可选) 四、启动https服务 在vscode左侧选择html文件，再在右下角点击Go Live启动服务
五、浏览器访问https地址 如果使用的是本地生成的证书会提示不安全，但是不影响测试使用也没关系
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac44cd73bb1a71bd514c57dfd7e01ea6/" rel="bookmark">
			cv2与PIL的一点不同
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在dataloader的时候，读取图片需要用到cv2 和PIL的转换，所以在读取图片的时候，发现了一些不同之处，感觉还挺绕的，mark一下。
cv2： cv2.imread() 读取出来的直接是np的array.
img.shape = [h,w,c] cv2.resize(size=(w,h)) 此处的图像尺寸是有细微差别的，应该在官方的docs上是可以查到的：
height, width = img.shape[:2] res = cv.resize(img,(2 * width, 2 * height),
interpolation = cv.INTER_CUBIC)
PIL: img = Image.open() img = np.array(img), 需要多一步转化为np的array.
同时作为PIL的对象，
img.size=[w,h] 但是当转化为np后，
img.shape = [h,w,c] 在数组顺序上是与cv2相同的，但是在c的顺序上是有细微区别的：
cv2 -&gt; PIL : BGR -&gt; RGB
一些疑问 此外，PIL的resize是对图像划定部分进行裁剪，而不是像cv2一样进行插值，目前所知的可以像cv2一样对图像进行插值的就是torch的pooling操作。
有没有大神也可以指导一下其他可以实现等效resize的简单方法 ：）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de40409a9cb769f8e4ceca93e07d635f/" rel="bookmark">
			SpringBoot 项目启动后立马自动关闭解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一个原因：可能是缺少web启动依赖包 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;2.5.6&lt;/version&gt; &lt;/dependency&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50af5537bb2c3a162f97059fff702542/" rel="bookmark">
			c&#43;&#43; sort 函数comparator的注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		comparator 的签名必须为 bool cmp(const Type1 &amp;a, const Type2 &amp;b) 对于相等的值永远返回 false 对于第二点可能有些难以理解，下面将进行详细解释
c++ sort 的实现非常厉害， 里面包括了插入排序， 堆排序，快排等等各种排序。
在快速排序的时候piovt 使用的是三数取中的方式
在__unguarded_partition函数，如果相等值返回 true的话， 那么这个函数可能会出现越界情况
template&lt;typename _RandomAccessIterator, typename _Size&gt; void __introsort_loop(_RandomAccessIterator __first, _RandomAccessIterator __last, _Size __depth_limit) { typedef typename iterator_traits&lt;_RandomAccessIterator&gt;::value_type _ValueType; while (__last - __first &gt; int(_S_threshold)) { if (__depth_limit == 0) { std::partial_sort(__first, __last, __last); return; } --__depth_limit; _RandomAccessIterator __cut = std::__unguarded_partition(__first, __last, // 三数取中 _ValueType(std::__median(*__first, *(__first + (__last - __first) / 2), *(__last - 1)))); std::__introsort_loop(__cut, __last, __depth_limit); __last = __cut; } } template&lt;typename _RandomAccessIterator, typename _Tp&gt; _RandomAccessIterator __unguarded_partition(_RandomAccessIterator __first, _RandomAccessIterator __last, _Tp __pivot) { while (true) { // 如果 first 到 pivot 一直相等 // 那么 会存在first越界的问题 while (*__first &lt; __pivot) ++__first; --__last; while (__pivot &lt; *__last) --__last; if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50af5537bb2c3a162f97059fff702542/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/091adea5144808954bfad24f6d452609/" rel="bookmark">
			【解决方案】windows7无法启动黑屏，报0xc000014c错误解决方案不用重新安系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电脑出现了上述的问题，无法启动。不用重安系统
1.需要一个含有PE系统的启动U盘，没有没关系，可以在线制作，小白也可以。需要找到另一台可用电脑，一个U盘，然后进老毛桃PE，下载一个U盘制作的程序，然后一键含PE的U盘制作成功。
2.将制作好的PE盘插入无法启动的电脑，我的笔记本是联想的，在LENOVO图标出现的时候按Fn+F12即可进入BIOS界面，选择USB启动，即可进入选择菜单，按提示选择进入PE系统。
3.进入系统后，打开C盘，依次打开“Windows\System32\Config\RegBack”文件夹。之后复制“RegBack文件夹”中的“SYSTEM文件”，返回粘贴到“Config文件夹”。最后粘贴覆盖成功后重启电脑即可。
4.重启电脑之后，又看到了自己电脑上熟悉的桌面，这种感觉真好！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3be35c6e2a28758aba92c6651da2ace9/" rel="bookmark">
			pip 问题 记录一下
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pip --default-timeout=100 install 库名称 -i http://pypi.douban.com/simple/ --trusted-host pypi.douban.com
清华：https://pypi.tuna.tsinghua.edu.cn/simple
阿里云：http://mirrors.aliyun.com/pypi/simple/
中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/
华中科技大学：http://pypi.hustunique.com/
山东理工大学：http://pypi.sdutlinux.org/
豆瓣：http://pypi.douban.com/simple/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23a63ef7441b250545e7c53fdea440c6/" rel="bookmark">
			ERROR 1067 (42000): Invalid default value for ‘end_time‘ Mysql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、报错信息 在执行下面的Sql语句时 ，出现错误信息：ERROR 1067 (42000): Invalid default value for ‘end_time’
CREATE TABLE seckill1( `seckill_id` BIGINT NOT NULL AUTO_INCREMENT COMMENT '商品库存id', `name` varchar(120) NOT NULL COMMENT '商品名称', `number` int NOT NULL COMMENT '库存数量', `start_time` timestamp NOT NULL COMMENT '秒杀开启时间', `end_time` timestamp NOT NULL COMMENT '秒杀结束时间', `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', PRIMARY KEY(seckill_id), key idx_start_time(start_time), key idx_end_time(end_time), key idx_create_time(create_time) )ENGINE = InnoDB AUTO_INCREMENT = 1000 DEFAULT CHARSET = utf8 COMMENT = '秒杀库存表'; 错误信息如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23a63ef7441b250545e7c53fdea440c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa792a4929e8f51f863156a617b42241/" rel="bookmark">
			图纸空间的打印测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		研究测试了一天，搞定了。深入认真研究清楚一个问题，功力一下子就升了一级。
&gt;&gt;&gt; # -*- coding: utf-8 -*- &gt;&gt;&gt; from pyautocad import Autocad,APoint &gt;&gt;&gt; import pyautocad.types &gt;&gt;&gt; import math &gt;&gt;&gt; import os &gt;&gt;&gt; import time &gt;&gt;&gt; import win32com.client &gt;&gt;&gt; import pythoncom &gt;&gt;&gt; def vtFloat(list): """列表转化为浮点数""" return win32com.client.VARIANT(pythoncom.VT_ARRAY | pythoncom.VT_R8, list) &gt;&gt;&gt; def vtInt(list): """列表转化为整数""" return win32com.client.VARIANT(pythoncom.VT_ARRAY | pythoncom.VT_I2, list) &gt;&gt;&gt; def vtVariant(list): """列表转化为变体""" return win32com.client.VARIANT(pythoncom.VT_ARRAY | pythoncom.VT_VARIANT, list) &gt;&gt;&gt; def ConvertArrays2Variant(inputdata, vartype="Variant"): import pythoncom if vartype == "ArrayofObjects": # 对象数组 outputdata = win32com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa792a4929e8f51f863156a617b42241/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61dd8b79e4a8d83059dfce8f8de7f0ef/" rel="bookmark">
			Linux部署Nacos启动报错：Could not find or load main class
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux下部署Nacos启动报错：Could not find or load main class 一、报错二、解决方案总结 一、报错 /usr/java/jdk-13.0.1/bin/java -server -Xms2g -Xmx2g -Xmn1g -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m -XX:-OmitStackTraceInFastThrow -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/data/nacos/distribution/logs/java_heapdump.hprof -XX:-UseLargePages -Dnacos.member.list= -Xlog:gc*:file=/data/nacos/distribution/logs/nacos_gc.log:time,tags:filecount=10,filesize=102400 -Dloader.path=/data/nacos/distribution/plugins/health,/data/nacos/distribution/plugins/cmdb -Dnacos.home=/data/nacos/distribution -jar /data/nacos/distribution/target/nacos-server.jar --spring.config.additional-location=file:/data/nacos/distribution/conf/ --logging.config=/data/nacos/distribution/conf/nacos-logback.xml --server.max-http-header-size=524288 Error: Could not find or load main class Caused by: java.lang.ClassNotFoundException: 二、解决方案 打x的为原文本，√ 为需要替换成的内容
在Nacos-Server的 bin / startup.sh 由JAVA_OPT_EXT_FIX 配置引起启动报错 在startup.sh文件中替换下方配置 x JAVA_OPT_EXT_FIX="-Djava.ext.dirs=${JAVA_HOME}/jre/lib/ext:${JAVA_HOME}/lib/ext" √ JAVA_OPT="${JAVA_OPT} -Djava.ext.dirs=${JAVA_HOME}/jre/lib/ext:${JAVA_HOME}/lib/ext" x echo "$JAVA $JAVA_OPT_EXT_FIX ${JAVA_OPT}" √ echo "$JAVA ${JAVA_OPT}" x echo "$JAVA $JAVA_OPT_EXT_FIX ${JAVA_OPT}" &gt; ${BASE_DIR}/logs/start.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61dd8b79e4a8d83059dfce8f8de7f0ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca86cf2fd75a5204bdc143def3f69281/" rel="bookmark">
			阿里云免费SSL证书申请
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、购买证书 二、申请证书 三、下载证书 根据不同使用场景选择对应的证书下载
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9918b3a0da1ebb39433fc207a8379897/" rel="bookmark">
			VREP学习记录（持续更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		此处记录本人学习vrep及matlab联合仿真的历程，仿真内容包括机械臂的轨迹规划、控制方法、碰撞检测、阻抗柔顺等应用。
2021.12.15
matlab稳定获取vrep机械臂的数据，包括关节位置、速度、力矩(仿真时间步长：0.01s)。 matlab进行路径规划，发送给vrep中机械臂使其运动。
2021.12.23 在sinmulink中搭建动量观测器，实现碰撞检测。 这里实现碰撞检测的主要方法还是参考De Luca A教授提出的动量观测器（从大概03年开始到17年的文章都有提到）。但这种基于动力学模型、搭建观测器的碰撞检测手段必然要依赖于机器人准确模型的建立。那么在此之前就需要获取六轴机器人的相关参数，几何尺寸、连杆重量、电机扭矩等参数可以从厂家获取，最为关键的动力学参数则需要设计激励轨迹进行动力学参数的辨识，这里的步骤比较复杂，此处不详细说明。
下面我搭建的观测器中所涉及到的动力学模型部分，包括重力项、惯性项、离心力和科氏力项矩阵都是按照指数积的方法建立的，相关知识可参考Frank C. Park教授的"MODERN ROBOTICS ：MECHANI CS, PLANNING, AND CONTROL"中的第八章：Dynamic of open chain，这本书的中文版是《现代机器人学》，JD，TB都有卖的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0936ef4ac86a3b5bfb5311b8f40c4bb0/" rel="bookmark">
			期末考试题（4）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、填空 共5题 （共计20分）
第1题 （4.0分） 题号:1878 难度:易 第22章
以下程序运行后，输出的a值是【1】，b值是【2】，x的值是【3】，y的值是【4】。
# include &lt;stdio.h&gt;
void ex(int, int);
int main( )
{
int a = 10, b =4;
ex(a, b);
printf("a = %d, b = %d\n", a, b);
return 0;
}
void ex(int x, int y)
{
x++;
++y;
printf("x = %d, y = %d\n", x, y);
}
=======(答案1)=======
10
=========或=========
a=10
=======(答案2)=======
4
=========或=========
b=4
=======(答案3)=======
11
=========或=========
x=11
=======(答案4)=======
5
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0936ef4ac86a3b5bfb5311b8f40c4bb0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b3620f6ec69ad6ff792db3312d95133/" rel="bookmark">
			七大查找之哈希查找
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.基本思想2.算法步骤3.代码实现3.1.算法实现3.2.测试程序 4.程序结果 1.基本思想 哈希查找算法又称散列查找算法，是一种借助哈希表（散列表）查找目标元素的方法，查找效率最高时对应的时间复杂度为 O(1)。
哈希查找算法适用于大多数场景，既支持在有序序列中查找目标元素，也支持在无序序列中查找目标元素。讲解哈希查找算法之前，我们首先要搞清楚什么是哈希表。
哈希表（Hash table）又称散列表，是一种存储结构，通常用来存储多个元素。
和其它存储结构（线性表、树等）相比，哈希表查找目标元素的效率非常高。
每个存储到哈希表中的元素，都配有一个唯一的标识（又称“索引”或者“键”），用户想查找哪个元素，凭借该元素对应的标识就可以直接找到它，无需遍历整个哈希表。
多数场景中，哈希表是在数组的基础上构建的，下图给大家展示了一个普通的数组：
使用数组构建哈希表，最大的好处在于：
可以直接将数组下标当作已存储元素的索引，不再需要为每个元素手动配置索引，极大得简化了构建哈希表的难度。
我们知道，在数组中查找一个元素，除非提前知晓它存储位置处的下标，否则只能遍历整个数组。
哈希表的解决方案是：各个元素并不从数组的起始位置依次存储，它们的存储位置由专门设计的函数计算得出，我们通常将这样的函数称为哈希函数。
哈希函数类似于数学中的一次函数，我们给它传递一个元素，它反馈给我们一个结果值，这个值就是该元素对应的索引，也就是存储到哈希表中的位置。
举个例子，将 {20, 30, 50, 70, 80} 存储到哈希表中，我们设计的哈希函数为 y=x/10，最终各个元素的存储位置如下图所示：
在图 2 的基础上，假设我们想查找元素 50，只需将它带入 y=x/10 这个哈希函数中，计算出它对应的索引值为 5，直接可以在数组中找到它。
借助哈希函数，我们提高了数组中数据的查找效率，这就是哈希表存储结构。
构建哈希表时，哈希函数的设计至关重要。假设将 {5, 20, 30, 50, 55} 存储到哈希表中，哈希函数是 y=x%10，各个元素在数组中的存储位置如下图所示：
可以看到，5 和 55 以及 20、30 和 50 对应的索引值是相同的，它们的存储位置发生了冲突，我们习惯称为哈希冲突或者哈希碰撞。
设计一个好的哈希函数，可以降低哈希冲突的出现次数。哈希表提供了很多解决哈希冲突的方案，比如线性探测法、再哈希法、链地址法等。
本节我们使用线性探测法解决哈希冲突，解决方法是：当元素的索引值（存储位置）发生冲突时，从当前位置向后查找，直至找到一个空闲位置，作为冲突元素的存储位置。仍以图 3 中的哈希表为例，使用线性探测法解决哈希冲突的过程是：
元素 5 最先存储到数组中下标为 5 的位置；元素 20 最先存储到数组中下标为 0 的位置；元素 30 的存储位置为 0，和 20 冲突，根据线性探测法，从下标为 0 的位置向后查找，下标为 1 的存储位置空闲，用来存储 30；元素 50 的存储位置为 0，和 20 冲突，根据线性探测法，从下标为 0 的位置向后查找，下标为 2 的存储位置空闲，用来存储 50；元素 55 的存储位置为 5，和 5 冲突，根据线性探测法，从下标为 5 的位置向后查找，下标为 6 的存储位置空闲，用来存储 55。 借助线性探测法，最终 {5, 20, 30, 50, 55} 存储到哈希表中的状态为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b3620f6ec69ad6ff792db3312d95133/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eec2d6604fbc651472d02eb6006d5c2f/" rel="bookmark">
			JeecgBoot集成Sharding-JDBC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，环境描述 本次测试基于JeecgBoot 2.4.6，测试代码在Jeecg-boot-module-system中编写。
2，引入坐标 &lt;dependency&gt; &lt;groupId&gt;org.apache.shardingsphere&lt;/groupId&gt; &lt;artifactId&gt;sharding-jdbc-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;4.1.1&lt;/version&gt; &lt;/dependency&gt; 3，配置yml文件 datasource: druid: stat-view-servlet: enabled: true loginUsername: admin loginPassword: 123456 allow: web-stat-filter: enabled: true dynamic: druid: # 全局druid参数，绝大部分值和默认保持一致。(现已支持的参数如下,不清楚含义不要乱设置) # 连接池的配置信息 # 初始化大小，最小，最大 initial-size: 5 min-idle: 5 maxActive: 20 # 配置获取连接等待超时的时间 maxWait: 60000 # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 timeBetweenEvictionRunsMillis: 60000 # 配置一个连接在池中最小生存的时间，单位是毫秒 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 testWhileIdle: true testOnBorrow: false testOnReturn: false # 打开PSCache，并且指定每个连接上PSCache的大小 poolPreparedStatements: true maxPoolPreparedStatementPerConnectionSize: 20 # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙 filters: stat,wall,slf4j # 通过connectProperties属性来打开mergeSql功能；慢SQL记录 connectionProperties: druid.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eec2d6604fbc651472d02eb6006d5c2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d82079f5799249432a4c8282a6a4cfc4/" rel="bookmark">
			flume系列之：监控JMX reporter
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 flume系列之：监控JMX reporter flume指标监控设置官方文档： https://flume.apache.org/FlumeUserGuide.html#monitoring 通过使用flume-env.sh 在JAVA_OPTS 环境变量中指定JMX 参数来启用JMX 报告，例如
export JAVA_OPTS="$JAVA_OPTS -Xms1024m -Xmx2048m -Djava.security.auth.login.config=/moudle/apache-flume-1.9.0-bin/conf/flume_jass.conf -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=5455 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false" 禁用密码验证，默认情况下启用远程监控的密码验证。要禁用它，请在启动 Java VM 时设置以下系统属性。com.sun.management.jmxremote.authenticate=false禁用 SSL，要在远程监控时禁用 SSL，您必须在启动 Java VM 时设置以下系统属性。com.sun.management.jmxremote.ssl=false 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a525e414ad5d3252ce71bc5bc385bbe8/" rel="bookmark">
			不得不提一嘴的索引命名规则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今年项目比较繁杂，而最近在做老项目的Mysql优化的时候，发现了一个糟心的现象，很多索引命名，竟然都是乱七八糟的，是普通索引还是唯一索引，命名规则完全看不出来。
那么就不得不提一嘴，索引命名的时候，应该遵循什么原则？
普通索引名：IX_&lt;table&gt;_&lt;column&gt;_&lt;column&gt; 唯一索引名：UN_&lt;table&gt;_&lt;column&gt;_&lt;column&gt; &lt;table&gt;是建立索引的表名，&lt;column&gt;是建立索引的字段名 索引名限制在30个字符内，当索引名超过30字符时，可用缩写来减少索引名的长度。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7399f2d8053b6a43e16cd1df126dbe6/" rel="bookmark">
			vs添加dll动态库的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无论是设置DLL目录，或者是Lib目录，亦或是头文件的目录，都有release版本和debug版本的区分，每种版本的设置都是独立的，要分别设置。
一、VS中添加LIb库及头文件（外部依赖项）的步骤：
1、添加工程的头文件目录：工程---属性---配置属性---c/c++---常规---附加包含目录：加上头文件存放目录。
2、添加文件引用的lib静态库路径：工程---属性---配置属性---链接器---常规---附加库目录：加上lib文件存放目录。
然后添加工程引用的lib文件名：工程---属性---配置属性---链接器---输入---附加依赖项：加上lib文件名。
3、添加工程引用的dll动态库：把引用的dll放到工程的可执行文件所在的目录下。
这种方法比较繁琐,且不直观,而且还可能要争对debug版本和release版本作不同的配置,因为我们生成的两个版本的库可能放在不同的目录中的.
通过添加系统变量的方法来做，但可以采取以下的方法：
点击”解决方案资源管理器”-&gt;右键项目-&gt;属性-&gt;调试。双击”环境”，弹出对话框，输入path=XXX/opencv/build/x64/vc14/bin/;
参考： 原文链接：https://blog.csdn.net/u013352076/article/details/102953920
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/592ed3cb4e4cc6c6d19fa2a432ed1f44/" rel="bookmark">
			进制转换（你还在用笔在转换吗？）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
文章目录
前言
一、十进制转换为二进制
1.编程要点
2.主要程序代码如下
3.运行
二、n进制转换为十进制
1.编程要点
2.主要程序代码如下
3.运行
三、以IP地址形式输出
1.编程要点
2.主要程序代码如下
3运行
总结
文章目录 前言一、pandas是什么？二、使用步骤 1.引入库2.读入数据总结 前言 计算机信息的编码有很多种，二进制，八进制，十进制及十六进制，现在就让我们解决它们之间的转换。
一、十进制转换为二进制 1.编程要点 1）用数组来储存二进制数。
2）用两次for循环，第一次for循环0到14,（本题只考虑正数的转换，有兴趣的小以自己 敲下负整数），第二次for为15到0。注不是0到15。存入是从a[0]开始的。
3）%，/ 的应用。
2.主要程序代码如下 #include&lt;stdio.h&gt; int main()//将10进制转换成二进制。 { int i,j,m,n; int a[16] = { 0 };//注意数组一定要定义为0。 printf("please input decimalism number(0-32767):\n"); scanf("%d", &amp;m); for (i = 0; i &lt; 15; i++) { a[i] = m % 2; m = m / 2; } for (i = 15; i &gt;= 0; i--) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/592ed3cb4e4cc6c6d19fa2a432ed1f44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c39d7fdbc69565e21eca0ad149ab4b9/" rel="bookmark">
			记录使用Node.js下载zip文件但由于IDM的干扰不能正常下载的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		异常 使用node.js来下载文件，可以下载非.zip类型的文件，但下载.zip类型的文件总是失败。
下载.zip格式的压缩文件，会被IDM捕获
在浏览器的网络面板查看，发现返回状态是204Intercepted by the IDM Advanced Integration，并且响应头并没有我们设置的'Content-Type和Content-Disposition属性。
错误代码 var fs = require('fs'); var http = require("http"); var server = http.createServer(); server.on("request", function (request, response) { // 获取请求URL var url = request.url; // 如果是下载文件的URL，则判断进行处理 if (url.startsWith('/download/')) { // 提取文件名hello.txt var name = url.substring(url.lastIndexOf('/') + 1); console.log(name); // 创建可读流，读取当前项目目录下的hello.txt文件 var rs = fs.createReadStream(__dirname + "//" + name); // 设置响应请求头，200表示成功的状态码，headers表示设置的请求头 response.writeHead(200, { 'Content-Type': 'application/force-download', 'Content-Disposition': 'attachment; filename=' + name }); // 将可读流传给响应对象response rs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c39d7fdbc69565e21eca0ad149ab4b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd231dcbdece805a46efd80e9e62e362/" rel="bookmark">
			@TableField(typeHandler = FastjsonTypeHandler.class) 用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@TableField(typeHandler = FastjsonTypeHandler.class) private List&lt;SampleProdTplVo&gt; content; @TableField(exist = false, typeHandler = FastjsonTypeHandler.class) private List&lt;LabTestPendingEntity&gt; items; 前端上传不用这么传了
content: JSON.stringify(this.dataForm.content),
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f70b31887667f37f695f63fbd19bce81/" rel="bookmark">
			java.io.EOFException: Unexpected end of ZLIB input stream
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误信息：Could not copy tar entry android-jsc-intl-r241213.aar to android-jsc-intl.aar’.
java.io.EOFException: Unexpected end of ZLIB input stream
原因是
android-jsc-intl-r241213.aar 在下载过程中网络中断导致下载的不是完整包
解决方法
1.删除文件重新下载
2.手动下载，放到指定的位置，指定的位置是，错误信息指定的路径信息
下载地址：android-jsc-intl-r241213.aar 地址
相关问题的说明地址：
地址一
地址二
地址三
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d15706093ba32551909df50c0685e26a/" rel="bookmark">
			基于深度图和RGB图的三维映射（从2D到3D空间的重映射）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文图片来自下面两处链接，感谢原文作者！
参考链接1
参考链接2
一、概述
常听到的RGB-D相机是指带有彩色信息的3D相机，其输出的每个点包含了XYZ三轴坐标和彩色信息（RGB三个通道的值）。从硬件上来看，可以由一个能测深度的传感器结合一个2D的彩色相机构成。那么如何由一张彩色图片结合其对应的“深度图”来重建一张3D图片呢？首先解释一下什么是深度图，从图片维度上来看，它是一张2D图片，与“RGB彩色图片”尺寸一致，只不过每个像素p(x,y)对应的灰度值代表了物体上某个点到相机中心点的垂直距离。下面我们要讨论的就是由一张2D的彩色图片结合其对应的深度图来求一张3D点云图。或许你会疑惑这有什么用呢？RGB-D相机本身输出的不就是点云图吗？为何自己要大费周章地重新做这件事情呢？因为在实际使用3D相机的过程中，你可能要利用其输出的2D图片做一些2D算法的检测（显然是因为有些检测用2D算法更加有用高效,比如使用opencv里的算子），然后将2D的点重新映射到3D的点云上进行表征，这就需要使用下面的方法帮助你了。
二、原理
如上图所示,已知实际场景中的点M在相机平面上的成像为点Xm,从RGB图像中可以得到Xm的二维坐标p(x,y)以及颜色信息，从深度图上可以得到p(x,y)对应的深度信息（RGB图与深度图尺寸一致，一一对应），并且已知彩色图像中心点和相机中心点的距离：f (即焦距），现在求的就是M点在相机坐标系（图中点C为原点的坐标系）下的三维坐标。从上图中直观的就可以看出M点在相机坐标系下的Z轴坐标就是深度值，而XY轴坐标则可以依据p(x,y)坐标值以及“三角关系”来求（注：p(x,y)坐标以图像中心点为原点，如果使用opencv来读取图片，其像素坐标是以图片左上角点作为原点，这里需要做一个平移转换，平移量需要根据相机内参来获取）。XY轴坐标计算方法如下：
注：w指M点在相机坐标系下的X值，h指M点在相机坐标系下的Y值
注：实际使用时，焦距有fx,fy两个来表示。文章开头处的参考链接2有详细说明。
三、代码实现
Eigen::Vector3d point; point[2] = double(d); point[0] = (u - cx) * point[2] / fx; point[1] = (v - cy) * point[2] / fy; 注：u,v是像素坐标系下的坐标，以左上角为原点。cx、cy、fx、fy均可以由内参矩阵获得。内参矩阵如上图，可以通过张正友标定法来计算。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4826dd3faf2a806ec83ee8999d6b9d7e/" rel="bookmark">
			C&#43;&#43;设计模式－桥模式(Bridge)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 “单一职责”模式： 在软件组件的设计中，如果责任划分的不清晰，使用继承得到的结果往往随着需求的变化，子类急剧膨胀，同时充斥着重复代码，这时候关键是划分责任。
典型模式：
DecoratorBridge 动机： 由于某些类型的固有实现逻辑，使得它们具有两个变化的维度，乃至多个维度的变化。
如何应对这种”多维度“的变化？如何利用面向对象技术来使类型可以轻松地沿着两个乃至多个方向变化，而不引入额外的复杂度？
桥模式： 将抽象部分（业务功能）与实现部分（平台实现）分离，使他们都可以独立的变化。
——《设计模式》GoF
要点： Bridge模式使用对象间的组合关系解耦了抽象和实现之间的固有绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现盐泽和各自维度变化，即子类化它们Bridge模式有时候类似多继承方案，但是多继承方案往往违背单一职责原则（即一个类只有一个变化的原因），复用性比较差。Bridge模式是比多继承方案更好的解决方法。Bridge模式的应用一般在两个非常强的变化维度，有时一个类也有多于两个的变化维度，这时可以使用Bridge的扩展模式 结构： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d61746538f385ed2b3f08074212605d2/" rel="bookmark">
			kettle-数据同步
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在做kettle数据同步的时候需要处理的几个步骤：
源端数据删除、新增、更新时，目标端数据也需要进行同步删除、新增、更新
解决方案：
kettle所需组件：表输入、字段选择、排序记录、合并记录、数据同步
1、表输入，针对最新的数据输入的表
2、目标表，需要更新的表（如果两个表输入组件的对应字段数据类型不一致，需要添加字段选择组件）
3、两个表都需要进行排序操作
4、合并，根据id进行合并
5、数据同步(包括更新、插入、删除)
6、点击运行，就可以实现数据同步了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2522888073171bacf324db77840828ea/" rel="bookmark">
			矩阵分析L6矩阵函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、范数 1.范数与内积 内积：对两个空间进行内积运算可以得到一个实数集范数：对一个空间可以直接进行向量“大小”的衡量，得到实数集
2.向量范数 正定性：范数为0，则每个向量必为0
3.例题（向量范数判断） 4.p级范数 注意，范数|Y|若是一个平面直角坐标系，横轴为实数，纵轴为虚数。值为平面坐标系中线段长度。
x的1-范数为：1+|2+i|+|i|+1= 根号（5） + 3
x的2-范数为：根号（1+5+1+1）= 根号（8）
x的无穷范数为：max{1,根号（5），1,1}=根号（5）
作用在于：对于赋范线性空间的量化
另外，我们可以通过范数求得向量序列的极限
5.范数等价 例如：1-范数为菱形，2-范数构成了一个圆：
由于矩阵可以表示为mn维向量，于是将Aij元素看作一个向量。
6.方阵范数 方阵范数比向量范数多了一个相容性，因为方阵可以进行矩阵乘法
常用的矩阵范数
7.方阵范数与向量范数的相容性 定义
相容性的直观解释
相容性的作用
重要结论
例如：
8.特征值与范数的关系 注：利用该定理，可以对特征值的模进行估计
求矩阵的范数，第一范数是对列元素求模相加后取最大值；无穷范数是对行元素求模相加后取最大值。
二、向量序列和矩阵序列的极限 1.概念 2.性质 3、例题（求矩阵极限） 感觉和普通极限求解差不多，就是每个元素对应位置都要求一个极限。
4.例题（幂矩阵极限为0） 三、矩阵幂级数 1、矩阵级数 2、例题（求矩阵极限） 每个矩阵元素位置都求极限
注意等比数列计算公式：
3、收敛性质 四、矩阵函数收敛性 1.概念 复级数是由一个实数加虚数组成的，其中实部和虚部部分都是实函数。
2.收敛半径计算 3.谱半径计算 4.复幂级数计算 5.例题（矩阵幂级数收敛性判断） 6.例题（矩阵幂级数收敛性判断） 7.例题（矩阵幂级数收敛性判断） 五、矩阵函数 1.概念 2.待定系数法求函数值 3.例题（待定系数法求矩阵函数） 4.例题（待定系数法求矩阵函数） ？？最小多项式不明白为什么变成了2
五、函数矩阵的微分与积分 就是把每个位置上的元素分别进行了微分和积分
六、矩阵函数在微分方程组的应用 这个A是咋得出来的。。。
解答：A中每一行对应一个微分式子，第一个元素为0表示是对x1微分，所以为0；第二个元素为1是积分式中x2前的系数为1。
1.一阶线性常微分齐次微分方程组的计算 2.例题（一阶线性常微分齐次微分方程组的计算） 首先，将原始方程组转换为一般形式，求出A^n然后计算出eAt，并按照An进行化解最后将上式中的级数分解并合并，根据X(t)=e^AtX0求出X(t)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61dffa46616bc9212a1f6beed267acd1/" rel="bookmark">
			DM8使用DBMS_LOGMNR系统包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备工作 1.启动DBMS_LOGMNR系统包 DM8默认是会创建DBMS_LOGMNR系统包的，保险起见我们可以先查一下：
select sf_check_system_package('DBMS_LOGMNR');
返回值为1则为已启用DBMS_LOGMNR系统包。
2.日志准备 在使用该系统包之前，应该开启归档和最小附加日志。
开启最小附加日志：
SP_SET_PARA_VALUE(2,'RLOG_APPEND_LOGIC',1);
开启归档：
alter database mount;
alter database add archivelog 'dest=/home/dmdba/dm8/arch,TYPE=local,FILE_SIZE=1024,SPACE_LIMIT=10240';
alter database archivelog;
alter database open;
查询验证：
select sf_get_para_value(2,'RLOG_APPEND_LOGIC');
select sf_get_para_value(2,'ARCH_INI');
均返回1表示均已开启。
使用DBMS_LOGMNR 1.查询和添加需要分析归档 select name,first_time,next_time,first_change# ,next_change# from v$archived_log;--查看有哪些归档可用
dbms_logmnr.add_logfile('/home/dmdba/dm8/arch/ARCHIVE_LOCAL1_0xC5AC857[0]_2021-12-14_11-21-17.log');
dbms_logmnr.add_logfile('/home/dmdba/dm8/arch/ARCHIVE_LOCAL1_0xC5AC857[0]_2021-12-14_10-59-35.log');
select * from v$logmnr_logs;--查看已添加的归档
2.启动归档日志分析 dbms_logmnr.start_logmnr (options=&gt;2130,
starttime=&gt;to_date('2021-12-14 00:00:00','YYYY-MM-DD HH24:MI:SS'),
endtime=&gt;to_date('2021-12-15 00:00:00','YYYY-MM-DD HH24:MI:SS'));
注意：options可以按模式相加来取组合。如组合全部模式则为：2+16+64+2048=2130，那么options取值就是2130.
3.查询日志分析结果 select operation_code,scn,sql_redo,timestamp,seg_owner,table_name from v$logmnr_contents where operation_code &lt; 6;
注意：sql_undo功能达梦数据库目前暂时不支持，只能查到sql_redo的内容，所以通过V$LOGMNR_CONTENTS查询的sql_undo列全部为空值。
关于V$LOGMNR_CONTENTS中，操作类型 OPERATION 和 OPERATION_CODE的对应关系分别为： INTERNAL 0、INSERT 1、DELETE 2、UPDATE 3、BATCH_UPDATE 4、DDL 5、START 6、COMMIT 7、SEL_LOB_LOCATOR 9、LOB_WRITE 10、LOB_TRIM 11、SELECT_FOR_UPDATE 25、LOB_ERASE 28、MISSING_SCN 34、ROLLBACK 36、UNSUPPORTED 255、SEQ MODIFY 37
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61dffa46616bc9212a1f6beed267acd1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52b6b891153e5dbf8bccb38dbe19b3ac/" rel="bookmark">
			Spring boot之ServletContextInitializer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Boot提供的在Servlet 3.0+环境中用于程序化配置ServletContext的接口。该接口 ServletContextInitializer主要被RegistrationBean实现用于往ServletContext容器中注册Servlet,Filter或者EventListener。这样设计的目的主要是旨在降低用于在war包中第三方库可能破坏spring boot 应用的风险，同时也方便spring容器管理这些beans。这些ServletContextInitializer实例不会被SpringServletContainerInitializer检测，因此不会被Servlet容器自动启动。
该接口ServletContextInitializer和Spring Web的另外一个接口WebApplicationInitializer看起来几乎一模一样,但二者使用目的不同。Spring Web中,WebApplicationInitializer也是针对Servlet 3.0+环境，设计用于程序化配置ServletContext，跟传统的web.xml对等或者配合使用。WebApplicationInitializer实现类会被SpringServletContainerInitializer自动检测和启动 (从servlet3.0开始，web容器启动时为提供给第三方组件机会做一些初始化的工作，例如注册servlet或者filtes等，servlet规范中通过ServletContainerInitializer实现此功能。每个框架要使用ServletContainerInitializer就必须在对应的jar包的META-INF/services 目录创建一个名为javax.servlet.ServletContainerInitializer的文件，文件内容指定具体的ServletContainerInitializer实现类，那么，当web容器启动时就会运行这个初始化器做一些组件内的初始化工作，具体可以参考servlet3规范)
ServletContextInitializer类结构如下：
1、ServletListenerRegistrationBean 类似 ServletListener
2、ServletRegistrationBean 类似Servlet
3、FilterRegistrationBean 类似Filter
ServletContextInitializer 应用 – DispatcherServlet
package org.springframework.boot.autoconfigure.web.servlet; import java.util.Collection; import org.springframework.boot.web.servlet.ServletRegistrationBean; import org.springframework.util.Assert; import org.springframework.web.servlet.DispatcherServlet; /** * {@link ServletRegistrationBean} for the auto-configured {@link DispatcherServlet}. Both * registers the servlet and exposes {@link DispatcherServletPath} information. * * @author Phillip Webb * @since 2.0.4 */ public class DispatcherServletRegistrationBean extends ServletRegistrationBean&lt;DispatcherServlet&gt; implements DispatcherServletPath { private final String path; /** * Create a new {@link DispatcherServletRegistrationBean} instance for the given * servlet and path.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52b6b891153e5dbf8bccb38dbe19b3ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1347438ed309aa4b17f3e6fe2bbf82ec/" rel="bookmark">
			Vue2 应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue是一套用于构建用户界面的渐进式框架。
渐进式的含义：主张最少。
每个框架都不可避免会有自己的一些特点，从而会对使用者有一定的要求，这些要求就是主张，主张有强有弱，它的强势程度会影响在业务开发中的使用方式。
本章节参考Vue官网教学视频，为个人学习总结。附官方教程 Vue.js教程
1.Vue的安装与部署 引入Vue.js，对于制作原型或学习，你可以这样使用最新版本：
&lt;script src="https://unpkg.com/vue@next"&gt;&lt;/script&gt; 对于生产环境，我们推荐链接到一个明确的版本号和构建文件，以避免新版本造成的不可预期的破坏。
Vue下载安装地址
2、Vue的实例及生命周期 Vue的实例及生命周期
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; {{msg}} &lt;/div&gt; &lt;script type="text/javascript"&gt; var vm = new Vue({ el : "#app", data : { msg : "hi vue", }, //在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。 beforeCreate:function(){ console.log('beforeCreate'); }, /* 在实例创建完成后被立即调用。 在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。 然而，挂载阶段还没开始，$el 属性目前不可见。 */ created	:function(){ console.log('created'); }, //在挂载开始之前被调用：相关的渲染函数首次被调用 beforeMount : function(){ console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1347438ed309aa4b17f3e6fe2bbf82ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3885d302edeb3d981893a89a45c90417/" rel="bookmark">
			解决Apache Log4j2漏洞通用方案(最新&amp;亲测有效)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【亲测有效】
漏洞背景 2021年11月24日，阿里云安全团队向Apache官方报告了Apache Log4j2远程代码执行漏洞。2021年12月10日，阿里云安全团队发现 Apache Log4j 2.17.0-rc1 版本存在漏洞绕过，请及时更新至 Apache Log4j 2.17.0-rc2 版本。
漏洞描述
Apache Log4j2是一款优秀的Java日志框架。2021年11月24日，阿里云安全团队向Apache官方报告了Apache Log4j2远程代码执行漏洞。由于Apache Log4j2某些功能存在递归解析功能，攻击者可直接构造恶意请求，触发远程代码执行漏洞。漏洞利用无需特殊配置，经阿里云安全团队验证，Apache Struts2、Apache Solr、Apache Druid、Apache Flink等均受影响。2021年12月10日，阿里云安全团队发现 Apache Log4j 2.17.0-rc1 版本存在漏洞绕过，请及时更新至 Apache Log4j 2.17.0-rc2 版本。阿里云应急响应中心提醒 Apache Log4j2 用户尽快采取安全措施阻止漏洞攻击。【后面Apache团队也发现2.15.0和2.16.0版本也存在远程数据漏洞，最终升级为安全版本 2.17.0】
漏洞评级
Apache Log4j 远程代码执行漏洞——严重
漏洞状态
影响版本
经验证 2.17.0-rc1 版本存在绕过，实际受影响范围如下：Apache Log4j 2.x &lt; 2.17.0-rc2
安全建议
排查应用是否引入了Apache log4j-core Jar包，若存在依赖引入，且在受影响版本范围内，则可能存在漏洞影响。请尽快升级Apache Log4j2所有相关应用到最新的 log4j-2.15.0-rc2 版本，地址 https://github.com/apache/logging-log4j2/releases/tag/log4j-2.15.0-rc2升级已知受影响的应用及组件，如 spring-boot-starter-log4j2/Apache Struts2/Apache Solr/Apache Druid/Apache Flink可升级jdk版本至6u211 / 7u201 / 8u191 / 11.0.1以上，可以在一定程度上限制JNDI等漏洞利用方式。 解决方案 方案1(极力推荐) 此方式直接升级版本来解决，升级到安全版本(2.17.0)即可。要PS的是，我们引入安全版本依赖后，也要在starter-web启动器依赖里把Spring Boot自带的log依赖要排除掉（所谓铲草除根），因为Spring Boot封装的Apache Log4j2依赖暂时还没是最新版本，使用它可能会出现漏洞。重点来了，请参考如下代码：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3885d302edeb3d981893a89a45c90417/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3390ca9547c19b21e958660353c0e88e/" rel="bookmark">
			关于没有彻底清除node和npm的解决措施。（学不会来找我。）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近因为npm和node的版本不匹配遇到了许多困难。
比如更新npm的版本，结果它给报错了。
然后去差了一一下和npm5.8.0的版本对应的node版本已经是2018年的了，已经过时了。
所以只能重新卸载，再安装，但是安装了几遍，发现只有node的版本在变化，而npm的版本还是原来的5.8.0。
想了半天，查阅了好多资料，也询问了学长，发现就是node和npm卸载的时候，还有残留，并没有卸载干净。
那么如何可以完全的把node和npm卸载呢？
首先打开cmd。
然后输出以下指令：
where node where npm 它会显示出npm和node的具体位置。
忽然发现，虽然我每次安装的位置都是D盘，但是C盘还有npm的残留，所以每次重新安装，npm的版本都没有变化。
最后我们只需要把npm和node的具体文件夹删除掉，就可以彻底卸载npm和node了。
这是删除后，又又又又重新安装后的结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75951c4077050c0f010d8fb67040db9c/" rel="bookmark">
			Java--换工作也要学废的快速排序之三部曲解法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【学习背景】
Hi，大家好，我是贾斯汀，最近换了新工作，也换了租房，比较忙，一直拖着没怎么更新博客，更换新工作后工资UP、UP、UP的涨了不少，换了租房，位置就在公司楼下几百米远，再也不用挤深圳的死亡4号线地铁！
最近在熟悉公司的业务以及公司自己封装的技术架构，虽然正常搬砖，但总感觉还是少了些什么，原来是少了写博客的那种feel，写博客对于我来说，可以使自己处于一个比较好的学习状态，既能巩固很多的基础知识，还可以新的知识技能，能够保持业界的一定竞争力！
今天呢，主要分享通过Java实现快速排序的三部曲解法，很多人都说算法主要是为了应付大厂的面试，但其实不然，我们公司的技术框架当中就有封装了关于快速排序的公共方法，有不少应用场景都有应用到，所以还是很有必要复习一下的，本文主要分享一下我觉得不错的一种解法，希望对大家有帮助！
【思路及代码实现】
package com.justin.java.sort; import java.util.Arrays; import java.util.Random; /** * Java实现快速排序之三部曲 * 前奏：定义指针、变量、校验 * 第一部曲：定义基准值（这里为方便说明，一般以起始位置的值作为基准值） * 第二部曲：根据基准值划分数组为两部分（小于基准数的放在左边，大于基准数的放在右边） * 第三部曲：最后对基准值所在位置左右两边的元素进行递归（最终完成左右两边的元素排序） * */ public class QuickSort { public static void main(String[] args) { //（1）简单测试 // int[] arr = {6,3,5,7,2,10,4,9,8,1}; // quickSort(arr,0,arr.length - 1); // System.out.println(Arrays.toString(arr)); //（2）构建百万随机数据测试 int maxSize = 1000000; int [] arr = new int[maxSize]; for(int i=0;i&lt;maxSize;i++){ Random random = new Random(); arr[i] = random.nextInt(maxSize); } long startTime = System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75951c4077050c0f010d8fb67040db9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d73970941f55d18d44262ea79541370a/" rel="bookmark">
			光明顶之战 | 对决实时数据同步软件性能之巅
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		楔子
“飞雪连天射白鹿，笑书神侠倚碧鸳。”金庸先生的武侠世界里，总是上演着一幕幕刀光剑影与快意恩仇。是与非、恩与怨、爱与恨、情与愁，书尽千古风流。
太阳底下无新事。江湖，亦是如此，但江湖代有才人出。
纵观当今武林，门派林立，互为敌手，争斗不休。其中Oracle乃数据市场的一方霸主。多年经营，其势力盘根错节，旗下高手林立，略有独孤求败之态。
今次，旗下大将Oracle Golden Gate(简称OGG)，江湖人称“灭绝师太”，携Oracle门派之势，围攻国内数据同步市场的光明顶。OGG江湖成名多年，在数据同步领域斗重与山齐，依靠着早年打下的名气，加之背靠Oracle，行走江湖，世人都要给他三分薄面（因与Oracle关系紧密，与Oracle数据库配合时OGG优势极大）。在OGG眼中，光明顶已如囊中之物。
侠客Kingbase FlySync(简称KFS)自命金仓“张无忌”，少年自负凌云志，实乃国内数据同步产品之光，不甘光明顶失陷，初出茅庐，便赌上身为侠客的尊严，舍我其谁，主动邀战OGG。
OGG vs KFS，年轻的侠客是否有一战之力？
成名已久的前辈OGG手执倚天Oracle剑，剑法通神，一手Oracle剑法使得出神入化，剑出可以实时捕捉、变换和投递大量交易数据。四象掌、穿云飘雪掌和金顶绵掌更是厉害，掌力能够实现源数据库与目标数据库的数据同步。Oracle九阳功“佛光普照”之下，更是能保持亚秒级的数据延迟。
当然，年轻的侠客也不遑多让！
初露头角的侠客KFS曾在山中闭关修炼武当绝学太极拳剑、纵云梯等多年，太极拳剑能够高效连接各种异构数据源，实现这些数据源之间大规模增量数据的实时同步；纵云梯更能帮助用户打破数据孤岛，轻松共享分发数据，并确保用户数据不丢失。
光明顶之战，一触即发！
是Oracle“灭绝师太”OGG宝刀未老，还是金仓“张无忌”KFS后生可畏，胜利的天平到底会倾向哪一方？且听分解！
比武规则
为示公平，双方约定比武规则如下：
数据源：Oracle至Oracle
CPU：2.8GHZ，6C6T
内存：16GB
磁盘：512G SSD
网络：1000M
比武规则：双方提前约定比试场地（源端的测试数据，即测试模型），然后在场地中使出各自看家本领比斗（开启同步软件同步并计时，所有数据同步全部到目标端停止计时，计算耗时）。
根据耗时计算数据同步速度：同步速度(MB/S)=归档文件大小(MB)/同步耗时(S)
第一场
桃李春风一杯酒，江湖夜雨十年灯 | 小试牛刀
比试场地（测试模型）：简单数据模型
KFS作为武林后辈向前辈讨教，为示对前辈的敬意，特选取了比武台（30G归档文件，5张表，每张表5列，每张表相互独立）这一简单数据模型作为首场比试场地。
OGG手执倚天Oracle剑，倚天剑乃当世神剑，无坚不摧，削铁如泥，配合OGG绝学Oracle剑法，不少武林好手未经一合，便被削断兵刃，斩于剑下。因此平素心高气傲，不把天下英雄放在眼里。
KFS取白虹剑迎战。比武台上，KFS先简单挽出一剑以作试探。OGG微觉诧异，道：“在这比武台方寸之地，还不马上拿出你的看家本领来。如此小看于我，怕不是立即将你斩于剑下。看招！”倚天Oracle剑微侧，第一招即抢攻，利用OGG源端超常的处理速度，竟不格挡对方来招，剑尖直刺KFS丹田要穴，出手之凌厉猛悍，直是匪夷所思。天下武功，唯快不破，OGG上来就使用了闻名天下的独门绝招灭剑和绝剑，这剑法速度奇快无比，攻如天神行法，蓦地里剑尖已指到了咽喉，根本不给KFS反应时间。KFS大惊，滑步相避，但OGG漂身上前，其剑势随之转向。KFS只觉颈间凉风飒然，心知不妙：“OGG源端实在太快了，我得想办法避其锋芒才是”，遂足尖一点，使用纵云梯斜飞出去。OGG紧随其后，连攻了八下快招，招招致命，KFS一一化解，但已失了先机。双方你来我往，剑光如花，好不热闹。
最终，OGG轻车熟路，靠着天时地利人和，毫无悬念成功赢得了第一局。KFS棋差一招，尚未使出看家本领便已落败。
围观众人不由叫道：“果然，姜还是老的辣，实际比试时，OGG出剑太快了（源端处理速度大幅超过KFS），剑法同样精妙（在简单数据模型测试环境下的性能也优于KFS）。KFS吃亏在缺少对敌的经验，试探着便失了先手。”
场外
KFS首战不敌后，痛定思痛，认真复盘推演，总结如下经验：
1.OGG的绝招并非毫无破绽，此招虽快，但却避实就虚，劲力不足。即OGG源端只做简单处理，更多的数据传输、解析和入库都在目标端处理。
2.OGG虽然在首战的测试模型下速度更快，但行走江湖，时常狭路相逢便刀剑相向，情况着实比简单数据模型比武场复杂多了，简单数据模型比武场不贴合实际的业务场景。而KFS自小在山野间复杂环境（以用户业务角度出发设计）修习武艺，而后独自闯荡江湖，在刀光剑影中摸爬滚打，更能适应复杂多变环境。
复盘总结之后，KFS继续修炼以锤炼自身，在闭关修炼七七49天之后，终练就九阳神功（并行流水线技术）之绝顶神功，九阳神功（并行流水线技术）为当世最高的内力心法，能够将数据同步过程中需要串行执行的一个大任务拆分为多个小任务，利用现代CPU的多核架构，使用多个线程并行运行小任务；比如日志文件的读取，二进制文件的翻译、事务的组装、数据转换等都可以作为小任务并行执行。类似工业生产线上的流水线一样，源源不断的将数据库的二进制日志翻译为目标端可执行的SQL语句。
神功大成后，KFS重整旗鼓，再次对OGG发起挑战。
第二场
天下英雄出我辈，一入江湖岁月催|初露锋芒
比试场地（测试模型）：复杂业务场景
为应对OGG快招，KFS此次挑战选取了业务场景更加复杂的野外原始山林（TPCC模型，100仓）比试场地，此处奇石嶙峋，峰峦叠嶂，山涧水流不息，更加符合实际的业务场景。
KFS取来一柄宝刀对战。对战开始，“请”字尚未落地，KFS便提刀在手施展轻功，如一溜烟般绕到了OGG身后，不待她回身，左一闪，右一趋，正转一圈，反转一圈，刷刷两刀砍出。OGG横剑一封，正要递剑出招，KFS早已转得不知去向。OGG虽欲抢攻，但无奈周围障碍物过多，OGG的快剑（源端处理）发挥不出其优势，而KFS修习九阳神功之后内力浑厚，使得原本的纵云梯等轻功身法也再上一个台阶，不近OGG周身五尺之内。一来一往，战线被KFS拖长，这一次攻守易势，OGG竟无一剑反击之机。只是KFS碍于倚天剑锋芒，不敢过分逼近。此时，考验的是双方的内力（端到端整体性能）情况。
最终KFS凭借九阳神功（并行流水线技术），并行执行日志文件的读取、二进制文件的翻译、事务的组装、数据转换等同步任务，快OGG一步，赢得胜利。
观战众人拍手叫绝：“果然是自古英雄出少年，KFS的内力（端到端整体性能）之强劲，实属罕见，九阳神功（并行流水线技术），真不愧为当世最高的内力心法，妙呀！妙！”
场外
一比一打成平手，来到赛点。
OGG认为对方取巧，同时自己过于轻敌，才导致首败，恼羞成怒，誓要夺回属于自己的荣耀。
双方约定再战以分胜负。
次战告捷的KFS不敢托大，决定再次闭关，修炼乾坤大挪移（大事务缓存解析机制）之神功，强化自身。
要知，寻常人练功，由于TPCC模型中有一个灌数的环节，600仓数据使用TPCC工具加载时，产生了超大事务。此类事务在内存中读取、解析、翻译的过程中，由于内存大小本身的限制，导致需要不断的读写swap空间。事务越大，swap的读写次数就越多，性能越差。
而KFS的乾坤大挪移（大事务缓存解析机制），能将未提交事务进行部分打包，每处理一批，就主动暂存到外部磁盘中，这样内存中只需要保留一批数据，极大的减少了内存的占用，同时避免了swap的反复读写。
练就乾坤大挪移（大事务缓存解析机制）后的KFS，已不是当初那个初出茅庐的年轻侠客......
第三场
提剑跨骑挥鬼雨，白骨如山鸟惊飞 | 终极一战
比试场地（测试模型）：复杂业务场景
OGG自信于自身的实力，誓要在复杂环境下找回自己的尊严，于是双方约定继续在野外原始山林（TPCC模型，600仓，96G数据）的复杂场景之下决一死战。
时过境迁，形势正悄悄发生着变化，此时的KFS在经历两战后，不知不觉便已冲破九阳神功（并行流水线技术）最后一关，神功大成。要知天下诸般内功，皆不逾九阳神功之藩篱，而乾坤大挪移（大事务缓存解析机制）运劲使力的法门，又是集一切武功之大成，一法通，万法通。此时，任何武功在KFS面前都已无奥秘之可言。武当绝学的太极拳剑和纵云梯，九阳神功，再加上乾坤大挪移，三者渐渐融为一体，使得KFS耐力(长时间的性能表现)和定力(稳定性)更上一层楼。
此战双方都拿出全部的实力来应对，对战开始，KFS和OGG一起抢攻。刀剑相向，在KFS运足内力之下，这一刀强劲之极，劲力将OGG震得手腕发麻。KFS不做停留继续出刀，刀刀强劲，OGG脸色如霜只得与KFS对刀，比到后来，OGG右臂大是酸痛，当即换手。OGG左手使剑的本事与右手无甚分别，但见空中刀光剑影、火光四射。围观众人纷纷后退。
谁坚持到最后，谁就能赢得比赛。双方大战九九81个回合，历时5个小时(测试耗时)，打的天昏地暗，鬼哭神嚎。最终KFS趁OGG不备，抢身向前，右手前探，挥手拍出。OGG欲举剑削其手腕，KFS变拍为拿，反手一勾，已将OGG的倚天剑轻轻巧巧的夺了过来。这般刹那间的变化，已属乾坤大挪移（大事务缓存解析机制）运劲使力的法门。OGG武功虽高，但也难以拆解KFS转折轻柔的擒拿。最终，KFS凭借稳定的性能，包罗万有的产品能力，拿下了终局，赢得终极一战的胜利！
终
鸿图霸业谈笑间，不胜人生一场醉 | 落幕
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d73970941f55d18d44262ea79541370a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cc3760ab16e1332024ff623229a2e80/" rel="bookmark">
			常用正则表达式—邮箱（Email）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$/ 邮箱正则表达式解释
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1e48e5ce04056fe48912d544a6326a8/" rel="bookmark">
			python基础1：第三方库安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 作为Python基础的序章，本专栏旨在帮助大家解决一些常见的配置和编译问题
1）安装python编译器
从官网上安装下载Anaconda（推荐） 集成了很多第三方库 通过 python --version 查看版本
2）安装一个编辑器
VSCodePyCharmnotepad++ 以下使用PyCharm演示，2021 Professional 破解版 可以私信我
3）配置镜像源（需确定有安装pip）
国内常用源镜像地址：
清华（推荐）：https://pypi.tuna.tsinghua.edu.cn/simple/
阿里云（推荐）：https://mirrors.aliyun.com/pypi/simple/
中科大: https://pypi.mirrors.ustc.edu.cn/simple/
豆瓣：https://pypi.douban.com/simple/
在User目录中创建一个pip目录，如：C:\Users\xxx\pip，新建文件 pip.ini
填充内容
[global] index-url = https://pypi.tuna.tsinghua.edu.cn/simple/ 第一种方法 pip install xxx 当然有些package是论文作者开发的，往往在 GitHub 、Gitee等上有开源
下面介绍安装方法
第二种方法 第一步：git 安装
pip install git 第二步：获取 git clone link
第三步：安装
pip install -e git+https://github.com/ucsb-seclab/turi#egg=turi 其中 #egg= 用于指定当前目录下的安装路径，若不存在则创建新的文件夹
这里打开 PyCharm 的 Terminal 输入该指令即可
这种方式安装会将该安装路径 添加进 python interpreter 的包含库的路径中
pip install xxx-package 则会将第三方库安装到 python interpreter 目录下的 \Lib\site-packages
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1e48e5ce04056fe48912d544a6326a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/082c01c81cbc1615cac900cee7df4ffa/" rel="bookmark">
			checked 和selected 的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 首先这俩个是在 html 里学习基础知识。
selected 是select 下拉框中使用的 是选择很多项，但是只选择当前的某一项比如：
我使用select 可以选择很多省中 其中某一个。
input 使用checked 代表的意思是 我可以选择很多项。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6cbeccb6b868ea014fbc88d0c06e898/" rel="bookmark">
			Log4j1和log4j2区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		鉴于2021年末爆发的lo4j2的jndi漏洞，开始排查公司项目使用log日志框架情况，之前老项目有log4j1的使用，为了针对log4j2进行升级，了解整理下 log4j1 跟log4j2的区别点。
log4j 1 的maven引用： &lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; log4j2 的maven 可以使用的3个引用(log4j-core,log4j-web,log4j-api)，版本号一般一致： &lt;!-- https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.15.0&lt;/version&gt; &lt;/dependency&gt; 区别点： goroupId:log4j1只有log4j一个单词log4j。log4j2 更长，含有apache单词，org.apache.logging.log4j。
artifactId: log4j1只有一个log4j1。log4j2一般使用至少需要引入 log4j-core/api 2个jar
版本号：log4j1 都是 1.xx版本开头。log6j2都是 2.xx版本开头
默认加载的配置文件名：log4j1的的配置文件默认是log4j开头。log4j2的配置文件默认是log4j2开头。
log4j2配置文件介绍：支持的格式xml/properties/json/yaml ，以及默认加载配置文件名的优先级[https://logging.apache.org/log4j/2.x/manual/configuration.html#Architecture](https://logging.apache.org/log4j/2.x/manual/configuration.html#Architecture
ps：吐槽。百度搜索好多帖子的log4j2还是老版本情况，说不能使用properties的配置文件。其实早可以支持了。不过之前了解到，刚开始log4j2支持propertis的时候，支持还不是很好，不了解现在properties的稳定性如何了，没有去调研，个人还是推荐使用xml稳妥点。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d99391c536093b1263a76ad2e6e750f/" rel="bookmark">
			C# 关于浏览器——WebBrowser篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近要写一个浏览器包裹一个网站，试了各种浏览器插件，记录一下。
第一个就是微软的WebBrowser，这个很容易，直接拖过来，然后写一下注册表调用IE11的内核显示，这个代码是抄的：
/// &lt;summary&gt; /// 修改注册表信息来兼容当前程序 /// /// &lt;/summary&gt; static void SetWebBrowserFeatures(int ieVersion) { // don't change the registry if running in-proc inside Visual Studio if (LicenseManager.UsageMode != LicenseUsageMode.Runtime) return; //获取程序及名称 var appName = System.IO.Path.GetFileName(System.Diagnostics.Process.GetCurrentProcess().MainModule.FileName); //得到浏览器的模式的值 UInt32 ieMode = GeoEmulationModee(ieVersion); var featureControlRegKey = @"HKEY_CURRENT_USER\Software\Microsoft\Internet Explorer\Main\FeatureControl\"; //设置浏览器对应用程序（appName）以什么模式（ieMode）运行 Registry.SetValue(featureControlRegKey + "FEATURE_BROWSER_EMULATION", appName, ieMode, RegistryValueKind.DWord); //为完整的Internet Explorer浏览器启用“打开”的功能 Registry.SetValue(featureControlRegKey + "FEATURE_ENABLE_CLIPCHILDREN_OPTIMIZATION", appName, 1, RegistryValueKind.DWord); Registry.SetValue(featureControlRegKey + "FEATURE_AJAX_CONNECTIONEVENTS", appName, 1, RegistryValueKind.DWord); Registry.SetValue(featureControlRegKey + "FEATURE_GPU_RENDERING", appName, 1, RegistryValueKind.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d99391c536093b1263a76ad2e6e750f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a118b44e23b26f525822804eadde250/" rel="bookmark">
			Mac无法播放音乐的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Mac上音乐软件播放不出来音乐，最早是在网页上用蜻蜓PM听音乐，以为是网页出了问题，然后发现音乐播放器和其他音频都不行了，重启电脑后就OK，然后就没当回事，没想到接下来又遇到几次…
搜了一下，竟然好多人遇到这种问题，这里贴一下解决方法(搬运工)
Mac上的终端 执行如下命令 sudo killall coreaudiod 或者打开活动监视器 -&gt; 搜索coreaudiod -&gt; 强制退出 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d20877898f5c8192f0f7cb24c15d3f20/" rel="bookmark">
			深度学习光学字符识别（OCR）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基本理论 1. 什么是OCR 1)定义 OCR (Optical Character Recognition，光学字符识别)是指对图片中的文字进行查找、提取、识别的一种技术，通过检测暗、亮的模式确定其形状，然后用字符识别方法将形状翻译成计算机文字的过程。
2)一般步骤 文字检测：解决的问题是哪里有文字，文字的范围有多少文字识别：对定位好的文字区域进行识别，主要解决的问题是每个文字是什么，将图像中的文字区域进转化为字符信息。 3)OCR的难点 文本检测，尤其是复杂自然场景下的文本检测，非常具有挑战性，主要难点有：
文本存在多种分布，文本排布形式多样；文本大小、长度不固定；文本存在多个方向；多种语言混合。 4)OCR与目标检测的区别 文本大多数以长矩形形式存在，即长宽比一般较大或较小，这与普通的目标检测中的物体不一样(这些长宽比较接近1)普通物体(比如猫)存在明显的闭合边缘轮廓，而文本没有文本中包含多个文字，而文字之间是有间隔的，如果检测做得不好，我们就会把每个字都当成文本行给框出来而非整行作为文本框，这与我们的期望不一样 5)评估指标 拒识率：把应该识别的文字，当成不能识别的文字误识率：不应该作为文字的作为文字来识别识别速度：一般可接受范围在50~500ms稳定性：识别结果稳定性 6)应用 文档/书籍扫描、车牌识别、证件识别、卡识别、票据识别教育场景文字识别(例如拍照搜题)文字识别笔旅游翻译APP盲人相机自动导航 二、文字检测技术 1. CTPN(2016) 1)概述 CTPN全称Detecting Text in Natural Image with Connectionist Text Proposal Network(基于连接文本提议网络的自然图像文本检测)，是发表于2016年的用于OCR的一篇著名论文。直到今天这个网络框架一直是OCR系统中做文本检测的一个常用网络，极大地影响了后面文本检测算法的方向。该模型在自然环境下水平文字的检测方面有这良好的表现。其基本思想是先使用固定宽度(16像素)的小文本框对图像进行检测，得到一系列含有文字的区域，然后对这些区域进行合并，合并成大的、完整的文本框。
2)具体步骤 CTPN主要包含以下几个步骤：
检测文本。使用固定宽度为16像素的小区域(proposal)在原图像上移动检测，每个proposal使用10个锚点高度在11~273之间(每次除以0.7)。检测器在每个窗口位置输出k个锚点的文本/非文本分数和预测的y轴坐标(v)； 左：RPN提议。右：细粒度的文本提议。 利用RNN连接多个proposal。检测出文本区域后，将这些小的文本区域进行连接。为了避免对与文本模式类似的非文本目标(窗口，砖块，树叶等)的误检，使用了双向LSTM(LSTM是RNN变种)利用前后两个方向上的信息对proposal进行连接。引入RNN进行连接操作，大大减少了错误检测，同时还能够恢复很多包含非常弱的文本信息的遗漏文本proposal；
边沿细化。完成连接后，对边沿进行细化处理，当两个水平边的proposal没有完全被实际文本行区域覆盖，或者某些边的提议被丢弃。通过连接其文本/非文本分数为&gt;0.7的连续文本提议，文本行的构建非常简单。
文本行构建如下：首先，我们为提议 ( B j ) (B_j) (Bj​)定义一个配对邻居作 ( B i ) (B_i) (Bi​)为 B j − &gt; B i B_j−&gt;B_i Bj​−&gt;Bi​，当(i)是最接 ( B j ) (B_j) (Bj​)近 ( B i ) (B_i) (Bi​)的水平距离，(ii)该距离小于50像素，并且(iii)它们的垂直重叠是&gt;0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d20877898f5c8192f0f7cb24c15d3f20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/469414ff5d3827f235c920770dfb6fed/" rel="bookmark">
			【以太坊】私链搭上后无法MetaMask无法访问localhost8545的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		私链搭好在Linux中，配置好ChianID和networkid等参数之后，使用MetaMask连接localhost8545仍然无法访问：
这个问题找了很久的资料，最后发现学习的资料是一年前的，文档更新的速度赶不上以太坊更新的速度，原因是跑私链的命令行中缺失浏览器限制访问项，之前的命令：
geth --datadir ./ --networkid 1337 --http --http console 2&gt;&gt;geth.log 改之后的命令：
geth --datadir ./ --networkid 1337 --http --http.corsdomain "*" console 2&gt;&gt;geth.log 也可以多配置一些参数：
geth --datadir ./ --networkid 1337 --http --http.addr 127.0.0.1 --http.vhosts "*" --http.port 8545 --http.api 'db,net,eth,web3,personal' --http.corsdomain "*" console 2&gt;&gt;geth.log 改好后就能连上localhost8545了：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4017b3a432f86e7f1ab9ed8dcca2652f/" rel="bookmark">
			gitee使用之Pull Request
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简单记录一下在gitee中创建issue和Pull Request的过程：
1.gitee中创建issue
2.本地提交代码到demo分支
3.gitee中创建Pull Request，从demo分支合入master分支，并关联1中创建的issue
4.在gitee的Pull Request页面审核通过，合入。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b92b2a80fb61edbde65a358b905aa337/" rel="bookmark">
			MySQL 占用过高CPU时的优化手段
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mysql占用CPU过高的时候，该从哪些方面下手进行优化？
占用CPU过高，可以做如下考虑：
1）一般来讲，排除高并发的因素，还是要找到导致你CPU过高的哪几条在执行的SQL，show processlist语句，查找负荷最重的SQL语句，优化该SQL，比如适当建立某字段的索引；
2）打开慢查询日志，将那些执行时间过长且占用资源过多的SQL拿来进行explain分析，导致CPU过高，多数是GroupBy、OrderBy排序问题所导致，然后慢慢进行优化改进。比如优化insert语句、优化group by语句、优化order by语句、优化join语句等等；
3）考虑定时优化文件及索引；
4）定期分析表，使用optimize table；
5）优化数据库对象；
6）考虑是否是锁问题；
7）调整一些MySQL Server参数，比如key_buffer_size、table_cache、innodb_buffer_pool_size、innodb_log_file_size等等；
8）如果数据量过大，可以考虑使用MySQL集群或者搭建高可用环境。
9）可能由于内存latch（泄露）导致数据库CPU高
10）在多用户高并发的情况下，任何系统都会hold不住的，所以，使用缓存是必须的，使用memcached或者redis缓存都可以；
11）看看tmp_table_size大小是否偏小，如果允许，适当的增大一点；
12）如果max_heap_table_size配置的过小，增大一点；
13）mysql的sql语句睡眠连接超时时间设置问题（wait_timeout）
14）使用show processlist查看mysql连接数，看看是否超过了mysql设置的连接数（MySQL 连接数设置操作（Too many connections）及设置md5值的加密密码 - 散尽浮华 - 博客园）
下面分享一例遇到过的案例：
网站在高峰时段访问，点击页面有点卡。登陆服务器，发现机器负载有点高，并且mysql占用了很高的CPU资源，如下图：
MySQL负载居高不下，如果打开了慢查询日志功能，最好的办法就是针对慢查询日志里执行慢的sql语句进行优化，如果sql语句用了大量的group by等语句，union联合查询等肯定会将mysql的占用率提高。所以就需要优化sql语句
除了优化sql语句外，也可以做一些配置上的优化。在mysql中运行show proceslist;出现下面回显结果：
1.查询有大量的Copying to tmp table on disk状态
明显是由于临时表过大导致mysql将临时表写入硬盘影响了整体性能。
Mysql中tmp_table_size的默认值仅为16MB，在当前的情况下显然是不够用的。
mysql&gt; show variables like "%tmp%";
+-------------------+----------+
| Variable_name | Value |
+-------------------+----------+
| max_tmp_tables | 32 |
| slave_load_tmpdir | /tmp |
| tmp_table_size | 16777216 |
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b92b2a80fb61edbde65a358b905aa337/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91f7300c50c435489916ee2c02d378b9/" rel="bookmark">
			数据结构 活期储蓄账目管理（课程设计完整实验报告）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求分析
1.1问题描述
随着社会发展，银行作为一个金融机构，在现代人们的生活中扮演着极其重要的角色。为生活节凑飞快的现代人提供快速、便捷、高效的理财服务。伴随着电脑技术的发展，各大银行的储蓄管理系统也随之出现在这一舞台上。人们的生活水平不断提高，会将一定的收入用于活期存储，因其储户开户、销户、存入、支出活动频繁的需求特点，本课程设计使用哈希表进行银行活期储蓄账目管理系统的模拟，实现基本的数据存储和处理操作。活期储蓄帐目管理，活期储蓄处理中，储户开户、销户、存入、支出活动频繁，系统设计要求：1)能比较迅速地找到储户的帐户，以实现存款、取款记账；2)能比较简单，迅速地实现插入和删除，以实现开户和销户的需要。
1.2模块组成
伪UI模块：伪界面，为了使界面美观设计的伪UI
主程序模块：初始化工作及功能选择和调用
开户模块：经过人机验证后能新建账户。
销户模块：查找到目的账户，再验证密码后对其销户。
查询模块：能够通过账号查找，迅速的找到要查找的账户，并显示账户余额。
存取模块：在迅速地查找到目的账户后，对账户余额进行修改。
测试模块：超级管理员能够模拟输入数据，并输出全部数据
1.3 功能要求
根据1.2模块组成该系统具有以下五个部分的功能：
开户功能：通过人机验证能够从键盘输入用户账户新建账户，并赋予初始开户金额0元。
销户功能：查找到目的账户，若余额为0则对其销户，否则提示先取钱再销户。
查询功能：能够通过账号查找，迅速的找到要查找的账户，并显示账户余额。
存取功能：迅速地查找到目的账户，验证密码后对账户进行存钱取钱操作。
测试功能：能够通过管理员预设密码进行，模拟输入，全部输出操作，以方便测试。
2 概要设计
2.1 设计思路
每一个用户看作一个基本单位，将系统抽象只包括账号和金额，密码、日期等不做存储和处理。为了便于后期维护与找错，使结构更加明了，采用数据结构型函数与功能实现型函数分离结构，存储数据结构是哈希表。
图1 数据结构型函数和功能实现型函数
2.2 存储结构设计
数据结构存储采用的是哈希表，账号存储为字符串，常用字符串哈希函数有 BKDRHash、APHash、DJBHash、JSHash、RSHash、SDBMHash、PJWHash、ELFHash等，本程序采用 BKDRHash对字符串进行散列，得到一个整数的hash值，根据得到的hash值选择一个槽位置，解决冲突方法为链接法，如图3哈希表插入过程。其中零号元素位用于存储哈希表主槽位容积，非所有元素容积，如图2哈希表存储模型。
图2 哈希表存储模型
图3 哈希表插入过程
2.3 算法设计说明
下面将从函数调用关系和对部分算法设计说明两个方面进行
2.3.1 函数调用关系
图4 函数调用关系
2.3.2 算法设计说明
哈希表初始化算法思想是，为哈希表主槽申请空间并置为0，第0个元素的值域用于存放哈希表主槽长度。
判断哈希值所在哈希表槽位的思想是，将字符串用BKDR算法散列成一个整数哈希值，用该整数哈希值对长度取余加1一定落在哈希表主槽槽位数组内，其中加1是为了防止落在0位，因为0位用于存储长度。
哈希表插入元素的思想是，结合图3，先求插入值的主槽，主槽存在该元素则直接更新值域，如果主槽不是该元素，则冲突处理，本程序用链接法，查看主槽冲突指针域，重复上述过程，即找主槽，然后遍历主槽冲突链，存在就更新，不存在就插入。
哈希表删除元素的思想与插入元素的思想较为类似，将对应插入改成删除。
哈希表搜索的思想是，先求要搜索值的哈希值，再利用判断哈希值所在哈希表槽位的算法找到该槽位，对比该槽位元素查看是否一致，一致则查找成功，不一样则看该槽位是否有冲突元素，有的话则对比该槽位元素是否一致，没有的话则不存在该元素，查找失败。
图5 哈希表查找流程图
返回全部数据元素个数的思想为，遍历主槽，如果主槽后面有冲突链则遍历冲突链。
打印全部元素的思想与返回全部元素思想类似，先主槽，并查看是否有冲突链。
3 详细设计
3.1 结构体定义
根据2.2存储结构设计，哈希表结构体的定义为：
typedef struct _htItem
{
struct _htItem *next;//冲突时下一个
char *key_string;//
uint fid;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91f7300c50c435489916ee2c02d378b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/782962400b166ed37c52a4fb65d1ccd6/" rel="bookmark">
			操作系统Ucore:Lab2内存管理(六)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进入Lab2，Lab2的主要内容是内存的管理
0.新的bug 按照文档上的说明，我们要把lab1中写的代码复制到Lab2中。我一开始并不想这样做，因为我想保留我在Lab1中写的注释，所以我就merge了lab2到lab1中，经过了艰难的处理冲突之后，make qemu 。但悲剧的是qemu的控制台没有输出，我仔细的再次比对代码，还是没有找出为什么。无奈之下，只好复制lab1的代码到lab2…
但这还没完
源代码中由好几个像注释部分这样初始化的位置，但是我前文已经验证了这样是无法正常初始化的啊…用gdb看这些值都是0，而且程序也无法正常运行。把这种代码搬到自己电脑上用gcc编译都是不过的,不知道ucore里使用了什么样的魔法可以编译通过。
所以只能手动修改了，把初始化放到使用这个变量之前的函数体中，但是这个几个引用的函数还都是static的，那就只好在对应的文件里写一个init函数，仔细一看，这个default_pmm_manager还是const的…还得用一个其他变量去初始化…
ps：关于这个初始化问题，我是这样想的，我发现错误是在编译阶段报的，所以应该是编译器认为初始化的变量没有办法算出来（因为具体的地址需要在链接阶段才能算出来），所以拒绝初始化。在我的机器上实验(gcc version= 9.3.0 )这种情况是会报error的，但是不知道ucore的哪个选项让它可以无视错误继续编译，我也没有深入研究了，要是有谁知道可以在评论里留言。
总之，经过了一番和gcc的斗智斗勇之后，程序总算是能跑起来了…
1.探测内存 在bootasm中，加入了探测内存的功能，可以得到机器中可用的内存分布。
具体的位置在probe_memory标号处，具体是怎么探测的，其实并不重要，只需要知道
这个功能是由BIOS来完成的，我们只需要使用int指令加上参数调用就行。
最终返回的结果在内存位置0x8000处，我们这时候还是在实模式下的，所以这是物理内存的位置。
我们使用一个结构体来描述内存分布，即e820map
注意：我们只是定义了这个结构体，并没有实例化，也不需要实例化，只需要让其指向0x8000就行了（这个过程在page_init里执行）。定义这个结构体的目的在于方便我们访问内存分布的信息。
我们只需要知道实际的输出是什么就行了
得到的结果如图，第一列是内存大小，第二列是范围，第三列是类型。（根据文档的描述，这里报告的也不是全部，比如现存的额映射地址就不会报告）
文档在这里
这里的类型由1和2两种，简而言之，只可以使用type = 1的内存
一共可以用两块内存，从0x0开始的640KB和从0x100000开始的126MB.第一部分，装了bootblock，我们主要管理的是第二部分大约128MB的内存。
2.Entry.S bootmain还是熟悉的配方，读取磁盘，载入ELF，跳到内核段代码。
这里有一点，就是编译的时候链接脚本变了，程序的入口地址不再是0x100000了，而是0xc010_0000。
但这并不影响我们加载
bootmain里加载的时候都只取了低30位，所以实际加载和跳转的地址和Lab1是一样的。
转到e_entry之后，在kern_init之前要先执行entry.s
这一套操作是熟悉的加载gdt表，唯一不同的就是gdt使用了REALLOC宏修饰，这样做的原因是，我们在链接的时候给的起始地址是0xc010_0000，所以__gdtdesc这个标号的值是0xc010_0000加上偏移量，这对于我们来说是个虚拟地址，实际上的__gdtdesc是在0x0010_0000开头的位置上，所以要减去0xc000_0000
我们再看gdt的内容
基址是 （-0xc000_0000），界限是4G。为什么会这样呢，原因就是我们现在需要把0xc010_0000 的地址都映射到0x0010_0000位置
而寻址的方式是CS+IP，所以我们需要把CS设置位-0xc000_0000就可以完成映射。
这里一定要清楚：
执行完ljmp指令之后，EIP的值就是0xc010_0000开头的了
但是实际上我们访问的物理地址还是0x0010_0000位置（因为CS基址映射）
设置新的内核栈，这次和Lab1不一样了，新的栈空间为
data段的开头 ---- data段开头+8KB。
这里有一个小问题，就是同时链接这么多文件的时候，这么确保栈在data段的开头。
我们可以看到，链接时entry.o是在开头的。我们做一个实验
step1.在1.c文件中写main函数，在2.c文件中写func函数。
step2.分别编译成1.obj和2.obj
step3. ld 1.obj 2.obj -o 12 和 ld 2.obj 1.obj -o 21
step4.查看反汇编(省略了具体汇编代码)
12.hex
21.hex
我们发现，函数的位置和链接的顺序是一样的。所以entry.s总是在data段的开头（这样的实验不太严谨，毕竟我也没有看ld的文档…但大概就是这样吧）
最后，call kern_init
3.pmm_init pmm_init前都没有什么变化.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/782962400b166ed37c52a4fb65d1ccd6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dbbc19874d484cd84df0386e5220aa1/" rel="bookmark">
			Nginx负载均衡调度中的状态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、状态说明 状态	概述 down	当前的server暂时不参与负载均衡 backup	预留的备份服务器 max_fails	允许请求失败的次数 fail_timeout	经过max_fails失败后，服务暂停时间 max_conns	限制最大的接收连接数 2、down状态 给某一台服务器设置为 down，表示该台服务器不可用。
upstream test_load_balance { # 201 这台服务器先不使用 server 10.0.0.201:80 down; server 10.0.0.202:80; } 3、backup状态 当所有的服务器都不可用时，才会启用backup这台服务器，哪怕只剩一台可以使用，backup这台服务器都不参与使用
upstream test_load_balance { # 当所有的服务器都不可用时，才会启用backup这台服务器，哪怕只剩一台可以使用，backup这台服务器都不参与使用 server 10.0.0.201:80 backup; server 10.0.0.202:80; } 4、max_fails 和 fail_timeout 这两个状态通常一块使用。如果给某台服务器设置该参数，表示如果尝试连接失败的次数超过规格的值后，就将该该服务器暂停设置的时间，过了时间后，在启用。
upstream test_load_balance { # 201这台服务器，如果尝试连接失败2次后，该台服务器暂停10s后再启用 # 这两个状态，主要用来检测Nginx的健康检查指标 server 10.0.0.201:80 max_fails=2 fail_timeout=10s; server 10.0.0.202:80; } 5、max_conns 最大连接数 max_conns属性是用来限制同时连接到upstream负载上的单个服务器的最大连接数,作用是可以对单个服务器进行限流,防止服务器超负荷运转.默认值为0,则表示没有限制。
upstream test_load_balance { # max_conns属性是用来限制同时连接到upstream负载上的单个服务器的最大连接数, # 作用是可以对单个服务器进行限流,防止服务器超负荷运转.默认值为0,则表示没有限制 server 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6dbbc19874d484cd84df0386e5220aa1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f907a1492b043ae332c25f56ccd62b5/" rel="bookmark">
			序列标注的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f736650945505eca402f0daf3d112ee4/" rel="bookmark">
			3台linux安装hadoop机群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备工作：有3台虚拟机，主机名为node1、node2、node3，并且node1为主节点 第一步：上传压缩包并解压 将压缩的hadoop包上传到第一台服务器并解压；第一台机器执行以下命令 cd /usr/soft/ tar -xzvf hadoop-3.1.4.tar.gz -C /usr/install 第二步：查看hadoop支持的压缩方式以及本地库 第一台机器执行以下命令 cd /usr/install/hadoop-3.1.4/ bin/hadoop checknative 如果出现openssl为false，那么所有机器在线安装openssl即可，执行以下命令，虚拟机联网之后就可以在线进行安装了 sudo yum -y install openssl-devel 第三步：修改配置文件 修改hadoop-env.sh第一台机器执行以下命令 cd /usr/install/hadoop-3.1.4/etc/hadoop/ vim hadoop-env.sh export JAVA_HOME=/usr/install/jdk1.8.0_141 修改core-site.xml第一台机器执行以下命令 vim core-site.xml &lt;configuration&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://node1:8020&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/usr/install/hadoop-3.1.4/hadoopDatas/tempDatas&lt;/value&gt; &lt;/property&gt; &lt;!-- 缓冲区大小，实际工作中根据服务器性能动态调整；默认值4096 --&gt; &lt;property&gt; &lt;name&gt;io.file.buffer.size&lt;/name&gt; &lt;value&gt;4096&lt;/value&gt; &lt;/property&gt; &lt;!-- 开启hdfs的垃圾桶机制，删除掉的数据可以从垃圾桶中回收，单位分钟；默认值0 --&gt; &lt;property&gt; &lt;name&gt;fs.trash.interval&lt;/name&gt; &lt;value&gt;10080&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; 修改hdfs-site.xml 第一台机器执行以下命令 vim hdfs-site.xml &lt;configuration&gt; &lt;!-- NameNode存储元数据信息的路径，实际工作中，一般先确定磁盘的挂载目录，然后多个目录用，进行分割 --&gt; &lt;!-- 集群动态上下线 &lt;property&gt; &lt;name&gt;dfs.hosts&lt;/name&gt; &lt;value&gt;/usr/install/hadoop-3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f736650945505eca402f0daf3d112ee4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55c07f7b01292523a14c68d570c56a03/" rel="bookmark">
			复杂NER问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebbcd88d1bd1ed0d043a8d888542c478/" rel="bookmark">
			两数相加使用哈希表C语言详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		struct hashTable{ int key; int val; UT_hash_handle hh;//使定义的结构具有哈希性 }; struct hashTable* hashtable; struct hashTable* find(int ikey){ struct hashTable* tmp; HASH_FIND_INT(hashtable, &amp;ikey,tmp); return tmp; } /*在上述代码中，第一个参数hashtable是哈希表，第二个参数是ikey的地址（一定要传递地址）。 最后tem是输出变量。当可以在哈希表中找到相应键值时，temp返回给定键的结构，当找不到时temp 返回NULL*/ void insert(int ikey,int ival){ /*重复性检查，当把两个相同key值的结构体添加到哈希表中时会报错*/ struct hashTable* it = find(ikey); /*只有在哈希中不存在ID的情况下，我们才创建该项目并将其添加。 否则，我们只修改已经存在的结构。*/ if (it == NULL){ struct hashTable* tmp = malloc(sizeof(struct hashTable)); tmp-&gt;key = ikey,tmp-&gt;val= ival; HASH_ADD_INT(hashtable,key,tmp); }else{ it -&gt;val = ival; } } /* HASH_ADD_INT表示添加的键值为int类型 HASH_ADD_STR表示添加的键值为字符串类型 HASH_ADD_PTR表示添加的键值为指针类型 HASH_ADD表示添加的键值可以是任意类型 HASH_ADD_INT函数中，第一个参数hashtable是哈希表，第二个参数ikey是键字段的名称。 最后一个参数tmp是指向要添加的结构的指针。 */ int* twoSum(int* nums, int numsSize, int target, int* returnSize){ hashtable = NULL;/* important!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebbcd88d1bd1ed0d043a8d888542c478/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/302bd0a6d1b403515f22a3b703716faf/" rel="bookmark">
			Rust编程语言入门教程（一）-什么是Rust
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Rust编程语言入门教程（一）什么是Rustrust 发展历史应用环境为什么选择Rust新项目用Rust还是Go？ Rust编程语言入门教程（一） 什么是Rust wiki百科：https://www.wikiwand.com/zh/Rust
官网： https://www.rust-lang.org/zh-CN/
学习资料：https://learning-rust.github.io/
Rust是Mozilla开发的编程语言，作为C的替代，逐步应用于FIrefox（火狐）中。Rust 是一门系统编程语言，Rust 设计者想要在保证性能的同时提供更好的内存安全。
Rust由前 Mozilla 开发人员Graydon Hoare于2006 年创建，作为 C++语言的替代品，Rust正慢慢在开发人员的世界中声名鹊起。它现在用于创建 Web软件、嵌入式计算机和分布式服务或命令行。这种受欢迎程度的适当证明是，全球巨头微软正在慢慢地从 C++ 语言（由于安全问题数量不断增加）转向 Rust。
截止 2021 年，主流的互联网公司都把 Rust 纳入主力语言，比如开发操作系统 Redox/Fuchsia、高性能网络 Tokio、应用的高并发后端 TiKV，甚至客户端软件本身（飞书）。我们欣喜地看到，Rust 除了在其传统的系统开发领域，如操作系统、设备驱动、嵌入式等方向高歌猛进之外，还在服务端高性能、高并发场景遍地开花。
rust 发展历史 2006年，Rust作为Graydon Hoare的个人项目首次出现。
2009年，Graydon Hoare成为Mozilla雇员[14]。
2010年，Rust首次作为Mozilla官方项目出现[15]。同年，Rust开始从初始编译（由OCaml写成）转变为自编译[16]。
2011年，Rust成功的完成了移植[17]。Rust的自编译器采用LLVM作为其编译后端。
2012年1月20日，第一个有版本号的预览版Rust编译器发布[18]。
2013年4月4日，Mozilla基金會宣布將與三星集團合作開發瀏覽器排版引擎Servo，此引擎将由Rust來實作[29]。
2015年5月16日，Rust 1.0.0发布[30]。
2021年2月8日，AWS、華為、Google、微軟以及Mozilla宣布成立Rust基金會[31][32]。
应用环境 全世界已有数百家公司在生产环境中使用 Rust，以达到快速、跨平台、低资源占用的目的。很多著名且受欢迎的软件，例如 Firefox、 Dropbox 和 Cloudflare 都在使用 Rust。从初创公司到大型企业，从嵌入式设备到可扩展的 Web 服务，Rust 都完全合适。
为什么选择Rust 新项目用Rust还是Go？ 参考URL: https://time.geekbang.org/column/article/223395
英文原文：https://dmv.myhatchpad.com/insight/choosing-between-rust-or-go/
易于部署 / 分发和方便交叉编译是 Rust 和 Go 的优点，同时内存安全对两种语言也很重要。它们都天然具备解决高性能或高并发问题的能力，而这也是使用 Python 或 Java 不容易做到的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/302bd0a6d1b403515f22a3b703716faf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf5b287c9f431506cb3f061e67425281/" rel="bookmark">
			Servlet生命周期思维导图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ea6f1f800e934afdd5bd009b347c149/" rel="bookmark">
			DP Leetcode 091解码方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 地址 https://leetcode-cn.com/problems/decode-ways/
描述 思想 代码 class Solution { public: int numDecodings(string s) { int n=s.length(); vector&lt;int&gt; f(n+1); f[0]=1; s=' '+s; for(int i=1;i&lt;=n;i++){ if(s[i]&gt;='1'&amp;&amp;s[i]&lt;='9') f[i]+=f[i-1]; if(i&gt;1){ int t=0; //计算两位数的大小假如是类似06这样的数，无法加入 t=(s[i-1]-'0')*10+(s[i]-'0'); if(t&gt;=10&amp;&amp;t&lt;=26) f[i]+=f[i-2]; } } return f[n]; } }; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53b9d81e7a89f5b5cda42d2fb0f3048f/" rel="bookmark">
			钉钉api推送markdown群消息格式不起作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		##钉钉api推送markdown群消息格式不起作用
1、换行符\n不起作用
解决方法：需要连续写两个换行符才能起作用\n\n
2、文字颜色格式不起作用
解决方法：
&lt;font color=#0000FF&gt;故障等级：{alarmLevelName}&lt;/font&gt;
或者
&lt;font color="#0000FF"&gt;故障等级：{alarmLevelName}&lt;/font&gt;
都可以，单引号是不行的，需要注意的是想要兼容安卓、ios、PC的话颜色和&gt;之间不能留空格！！切记！！
3、改变字体大小
目前我还没有解决，有知道的小伙伴欢迎告知~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/789b098dd0cb77d7d402f6f4fa637567/" rel="bookmark">
			ajax、axios、fetch优缺点对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.jQuery ajax
Ajax即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。
用法：
$.ajax({ type: 'POST', url: url, data: data, dataType: dataType, success: function () {}, error: function () {} }); 本身虽然简单，但常常会涉及到一些问题：如
CSRF攻击
CSRF（Cross-site request forgery）跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。
通过这6个步骤达到攻击的目的。
XSS攻击
Cross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。
为了和 CSS 区分，这里把攻击的第一个字母改成了 X，于是叫做 XSS。
XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。
而由于直接在用户的终端执行，恶意代码能够直接获取用户的信息，或者利用这些信息冒充用户向网站发起攻击者定义的请求。
简单的解决方法：
1、将能被转换为html的输入内容，在写代码时改为innerText而不用innerHTML。（过滤用户输入的 检查用户输入的内容中是否有非法内容。如&lt;&gt;（尖括号）、”（引号）、 ‘（单引号）、%（百分比符号）、;（分号）、()（括号）、&amp;（&amp; 符号）、+（加号）等。、严格控制输出。）
2、实在没有办法的情况下可用如下方法（js代码）
function safeStr(str){ return str.replace(/&lt;/g,'&amp;lt;').replace(/&gt;/g,'&amp;gt;').replace(/"/g, "&amp;quot;").replace(/'/g, "&amp;#039;"); } （表单提交或者url参数传递前，对需要的参数进行过滤,请看如下XSS过滤工具类代码） 将含有&lt;&gt;等符号转化为其他字符简单方便。
优缺点：
本身是针对MVC的编程,不符合现在前端MVVM的浪潮基于原生的XHR开发，XHR本身的架构不清晰，已经有了fetch的替代方案。JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理（采取个性化打包的方案又不能享受CDN服务）。 2.axios
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/789b098dd0cb77d7d402f6f4fa637567/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/710e44de8e810290bc806b3ad9eadaba/" rel="bookmark">
			springboot启动后自动退出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 有时新建的springboot启动后自动退出运行，如图所示：
此种情况大都数是因为pom文件加入了tomcat的依赖，与springboot内嵌的tomcat冲突导致，所以只需将pom文件中的tomcat依赖去除即可。即
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a90e177c8267190474d9e9a45cbeae94/" rel="bookmark">
			什么是方法的返回值？返回值在类的方法里的作用是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法的返回值是某个方法体中的代码执行后产生的结果。
返回值的作用是接受结果，使得它可以用于其它操作。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/175/">«</a>
	<span class="pagination__item pagination__item--current">176/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/177/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>