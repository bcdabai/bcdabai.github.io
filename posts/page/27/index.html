<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9ee5488c849b4b1f8bddf7d12d571d4/" rel="bookmark">
			在ASP.NET MVC中使用JQuery提供的弹出窗口（模态窗口）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在ASP.NET MVC中使用JQuery提供的弹出窗口（模态窗口） 原理 使用&lt;div&gt;图层灵活显示在浏览器的任何位置。默认情况下指定&lt;div&gt;不可见
引用 样式表 在JQuery的官方网站可以下载对应的css样式表。打开官网的样例页。
找到样式表引用路径
&lt;link rel="stylesheet" href="//code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css"&gt; 将其下载到本机，其中thme
比如，我的样式表路径为
&lt;link rel="stylesheet" href="~/lib/jquery/ui/1.11.3/themes/smoothness/jquery-ui.css"&gt; JQuery库 下载JQuery和JQuery-ui库，并放置在对应的路径中
&lt;script src="~/lib/jquery/jquery-1.11.3/jquery-1.11.3.min.js"&gt;&lt;/script&gt; &lt;script src="~/lib/jquery/ui/1.11.3/jquery-ui.min.js"&gt;&lt;/script&gt; 注意：前后顺序
这里要注意，在ASP.NET模板中，_Layout.cshtml文件末尾会引用JQuery.js，将其删除，否则会出现重复引用导致错误
Javascript调用 加入div的定义
&lt;div id="dialog" title="Basic dialog"&gt; &lt;p&gt;This is the default dialog which is useful for displaying information. The dialog window can be moved, resized and closed with the &amp;apos;x&amp;apos; icon.&lt;/p&gt; &lt;/div&gt; 加入javascript调用
&lt;script&gt; $( function() { $( "#dialog" ).dialog(); } ); &lt;/script&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b80a49eda1eb2553b9a711ab5773fa20/" rel="bookmark">
			高翔博士Faster-LIO论文和算法解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明 题目：Faster-LIO：快速激光IMU里程计
参考链接：
Faster-LIO：快速激光IMU里程计
iVox (Faster-Lio): 智行者高博团队开源的增量式稀疏体素结构
Faster-Lio是高翔博士在Fast系列的新作，对标基线是Fast-LIO2，核心是提出一种新的"数据结构"ivox，类似于Fast-LIO2中的ikd-tree，用于点云配准搜索和地图的增量更新。效果上整个LIO系统的用时相比Fast-LIO2有较大幅度的下降，精度上评估了每百米的APE和RPE，从结果上看有好有差。近年来的作品精度上似乎都大差不差，如LIO-SAM，FAST-LIO系列，更多的都是在卷实时性。
对于本文来说需要重点理解增量稀疏体素结构ivox和ivox-PHC,对于整个系统的流程可以参考FAST-LIO2。
摘要 本文提出了一种基于增量体素的激光惯性里程计(LIO)方法，用于快速跟踪机械式和固态激光雷达扫描。为了达到较高的跟踪速度，我们既没有使用复杂的基于树的结构来划分空间点云，也没有使用严格的k近邻(K-NN)查询来计算点匹配。相反，我们使用增量体素(iVox)作为我们的点云空间数据结构，它是在传统体素的基础上修改的，支持增量插入和并行近似k-NN查询。我们提出了线性iVox和PHC(伪希尔伯特曲线)iVox作为我们算法中的两个备选底层结构。实验表明，ivox的扫描速度在固态激光雷达中达到1000-2000Hz/秒，在32线旋转激光雷达中仅使用现代CPU扫描速度超过200hz，同时仍保持相同的精度水平。
一、简介 论文的出发点在于提高点云配准时的处理效率，在Fast-Lio2中使用了ikd-tree来提高点云的搜索效率，但kd-tree的维护以及挨个节点的遍历同样需要消耗一定的时间，因此提出一种基于稀疏体素的近邻结构iVox（incremental voxels），该方法可以有效的降低点云配准时的耗时，也不会影响LIO的精度表现，iVox是本文的核心内容。
相比与八叉树体素结构的完全体素化，iVox提供一种稀疏的体素表达，即只在空间点存在的地方建立和维护体素结构，因为空间点的位置是唯一的，可以使用一个哈系表来统一构建和维护体素结构，将空间点的坐标作为Key，将坐标带入哈系函数生成的唯一索引作为value。对于少量点匹配提出线性iVox结构，对于大量点的配准提出iVox-PHC，以便快速地查找任意近邻。
高速点云配准和三维重建是许多项目产品的关键模块——从高清地图(HD maps)[1] -[3]到自动驾驶汽车[4]，[5]。最常见的实时激光雷达跟踪方法，如LOAM[6]、LeGO-LOAM[7]和balm[8]，每次迭代大约需要100毫秒来处理一次激光雷达扫描。大多数传统的旋转激光雷达在这个速度下提供多线扫描。随着光学技术的发展，Livox和Cepton等现代固态激光雷达传感器可以提供100 Hz甚至更高频率的密集点云扫描[9]，[10]。因此，寻找一种高效的激光雷达跟踪方法已成为近年来重要的研究课题[11]，[12]。对于许多真实的机器人或车辆来说，LIO并不是系统中运行的唯一算法。所有活动模块必须共享计算资源。如果我们有一个更快、更轻的LIO，这个系统会更坚固。此外，还可以使用更快的LIO方法作为离线地图系统的前端，以帮助减少计算时间。
基于激光雷达或视觉的SLAM系统通常包括用于点云跟踪的实时前端和用于状态优化的后端[13]-[15]。在现实世界的激光雷达里程计系统中，人们还将以松耦合或紧耦合的形式将惯性和GPS测量融合到状态估计器中，以使系统对短时传感器故障更具鲁棒性[16]，[17]。从理论上分析整个复杂SLAM系统的计算成本并不容易。然而，一般来说，对于前端部分（LO/LIO模块），计算时间成本主要来自以下几个方面：
（1）所选的空间数据结构
由于传统的配准方法通常依赖于点云中的k近邻（k-NN）搜索，因此可以通过利用更快的k-NN数据结构来提高配准效率[19]。一些为不变空间数据库设计的数据结构(如R*-tree[20]、B*-tree[21])不适合实时LIO，因为LIO需要快速构建和查询速度。此外，由于点云是按顺序处理的，因此增量更新结构会更好。因此，体素和k-d树（及其变体）[22]、[23]是LO/LIO系统的更好选择。当然，体素和k-d树仍然有其局限性。体素几乎在恒定时间内易于构建和删除，但不能进行严格的k-NN搜索或范围搜索。k-d树可以提供严格的k-NN搜索和范围搜索结果，但需要额外的努力来摆动和平衡树。
*（2）状态估计器的创建
姿态估计器也会影响LIO模块的计算成本。在现代VIO或LIO系统中，人们倾向于在传统的单帧卡尔曼滤波器和全姿态图优化/BA之间选择折衷解决方案，如滑动窗口滤波器（SWF）[24]、多状态约束卡尔曼滤波器（MSCKF）[25]或迭代扩展卡尔曼滤波器（IEKF）[26]。它们都具有像滤波器一样的小计算成本和像优化方法一样的相对足够的精度的优点。
（3）匹配的残差度量
匹配点云的残差度量也会影响激光雷达系统的效率。在自动驾驶数据集中，点对平面和点对线模型通常比点对点模型表现更好，因为激光雷达点云是稀疏的，并且同一点并不总是可观测的。此外，对于[27]、[28]等基于特征的系统，将首先将点分类为几个语义类（地板、杆、平面），以加快匹配过程。这些特征减少了注册点的数量，但在这样的系统中，额外的特征提取时间是不可避免的。
这篇论文提出了一种基于稀疏、增量体素的LIO算法，称为Faster-LIO，它基本上是从FastLIO2[18]发展而来的。在LIO中使用稀疏体素代替k-d树（及其变体）的想法受到以下方面的启发：
1）严格的k-NN搜索和范围搜索对于残差计算是不必要的，特别是对于LIO系统，其中IMU测量可以获得大致准确的初始猜测。k-d树的主要优点是它能够通过用超平面有条件地划分高维空间来提供严格的k-NN和范围/框搜索结果。然而，在最坏的情况下，搜索算法可能会深入到非常遥远的分支中，以寻找潜在存在的最近邻居，这不太可能对局部平面系数估计有用。相反，基于体素的算法中的搜索范围被限制为预设值，使得丢弃这样的邻居不会影响大多数残差。
2）k-d树节点的构建、迭代、平衡、移除会影响LIO的效率，而体素不存在这些问题。我们在体素中使用保守的插入和被动删除策略，而不是在每个扫描处理阶段强制更新。
我们的贡献可以总结如下：
我们提出了稀疏增量体素（iVox）来组织点云，而不是树状结构。我们证明，与LIO中常用的ik-d树和其他数据结构相比，iVox可以实现更高的增量更新和k-NN搜索速度。我们在iVox中提出了两种可供选择的底层结构：线性iVox和iVox-PHC。实验表明，当我们在每个体素中有更多的点时，iVox-PHC具有更好的计算效率，而当数量较少时，线性iVox表现更好。我们使用并行k-NN搜索来构建一个紧密耦合的LIO系统，固态激光雷达的速度超过1500Hz，旋转机械激光雷达数据的速度超过200Hz（见图1），算法已经在github上进行了开源。 二、相关工作 最近的几项研究集中在快速点云配准上，其中还融合了惯性测量以形成LIO系统。我们在这里简要回顾一下这些作品，并讨论一下我们之间的区别。
LiTAMIN[2]和LiTAMIN2[29]提出了一种通过减少配准点的数量并将对称KL散度引入传统ICP的快速配准方法。它们的灵感来自著名的无损检测方法，该方法首先将点划分为单独的体素，然后在每个体素中执行正态分布变换。这封信报告了使用64线旋转激光雷达的Kitti数据集中约500–1000 Hz的频率。速度令人印象深刻，但主要是通过减少相关点的数量而不是使用更紧凑的数据结构进行邻居搜索来实现的。此外，它们没有开源实现，报告的准确性略低于传统方法[30]。
FastLIO[18]和FastLIO2[26]是在大规模场景中实现近100Hz的LIO系统。增量k-d树显著减少了树的更新时间，这也在我们的实验中得到了验证。通过使用SMW等式来减小观测方程的维数，进一步改进了迭代EKF中的卡尔曼增益计算。尽管如此，我们表明iVox甚至比FastLIO2中的ik-d树更快，同时实现了相同的精度水平。
对于旋转激光雷达，也有低延迟方法（LoLa SLAM[31]、LLOL[32]），它们不等待完全扫描，而是使用部分扫描数据来执行配准。这种加速是通过将扫描分割成几个模式来实现的，并且配准点的数量也比处理完整扫描小得多。不幸的是，这种方法只适用于旋转激光雷达，很难扩展到固态激光雷达。
如果目标平台配备GPU，则深度学习注册方法[33]、[34]和GPU加速注册[30]是SLAM中广泛使用的选择。凭借GPU的并行计算能力，大多数SLAM过程，如特征检测、特征匹配，甚至整个地图，都可以存储在GPU内存中，并以非常高的速度加速。然而，由于基本基础设施不同，我们没有将我们的方法与GPU加速的方法进行比较。
对于一般的空间数据存储，体素哈希也是替换分层树状结构的常用方法。[35]在视觉SLAM系统中使用散列体素进行地图管理，[36]使用体素散列进行体积3D重建。此外，这篇论文表明，离散体素可以用于LIO系统的最近邻搜索和增量映射。
在以下章节中，我们首先介绍iVox及其PHC版本的数据结构和原理。然后，我们展示了我们的方法与最先进的LIO算法之间的比较实验。
三、iVox:增量稀疏体素结构 3.1 iVox的数据结构 在iVox中，点云首先存储在稀疏体素中，其索引通过离散函数离散为unordered map（见图2）。由于激光雷达点云是稀疏的，我们不使用任何像TSDF[37]这样的体积表示，而是使用仅存储具有至少一个点的体素的稀疏哈希图。离散索引可以通过任何空离散算法（如[38]）来计算，本篇论文使用以下离散函数：
p为三维点，v为体素网络，s为体素大小，id是它的哈希键值，xor表示异或，N表示哈系表容量
函数的意义为：
（1）体素的空间坐标 = 空间物理坐标 × 体素边长，即v=1/s * p，体素空间坐标为哈系表的key
（2）对v的各个维度各乘以一个很大的整数再作异或位运算，得到的结果再对哈系表的容量N取余，得到体素的index– i d v id_v idv​，该index作为哈系表的value
每个体素内的点要么存储为向量，要么存储为底层内部结构，如PHC（见第四节），我们相应地将其称为线性iVox和iVox-PHC。使用线性iVox或iVox-PHC，每个体素内的k-NN搜索复杂度为O(n)或O(k)，其中n是体素内点的数量，k是离散PHC曲线的阶数。然而，我们将防止在LIO中的增量映射步骤中将过多的点插入到同一体素中，因此不会有太大区别。
3.2 iVox的k-NN搜索 iVox的k-NN搜索被限制在预定义的范围内，然后被分为三个步骤。给定iVox结构V和查询点P，我们将：
1）找到体素索引和附近的体素（在我们的实现中，从6、18、26个体素，见图3），表示为S。
2）遍历S中的每个体素，并在每个体素中搜索最多K个邻居(地图点)。
3）合并搜索结果并选择最佳的K个邻居。
注意，对于每个体素，步骤2可以被并行化。然而，由于该算法已经在点云级别上被并行化，因此没有必要在这里对每个体素执行并行搜索。iVox中的k-NN搜索简单、有效，但与树状算法相比并不严格，但足以用于LIO应用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b80a49eda1eb2553b9a711ab5773fa20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b94aa4cdb11db63076709cd7886ec1dc/" rel="bookmark">
			UNI-APP_ios自动适应底部安全区背景，修改安全区背景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自动适应（推荐） 将所有 iPhone X（刘海屏) 底部安全区域背景颜色 自动适应，当前页面什么颜色会自动调整。
1.打开 manifest.json ，打开源码视图
2.找到 app-plus 配置项，添加以下代码
"safearea": { "bottom": { "offset": "none" } } 统一设置 将所有 iPhone X（刘海屏) 底部安全距离的背景色，统一设置 为一种颜色
1.打开 manifest.json ，打开源码视图
2.找到 app-plus 配置项，添加以下代码
"safearea": { "background": "#CCCCCC", //背景色 "bottom": { "offset": "auto" } } https://ask.dcloud.net.cn/article/35564_uniapp
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8a1ffdb996313735c88a509d9ec9ffb/" rel="bookmark">
			DRF-源码解析-4.2-限流的流程：drf的限流源码，drf流量控制流程，drf如何流量控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		流量控制的逻辑：
1、设置一个唯一标识，作为cache的key
2、请求访问时，构造唯一标识，从ceche中获取[时间1,时间2,时间3,…]
3、根据设置流量控制规则，如：5/m (一分钟最多访问5次)，判断该唯一标识记录到cache中的访问时间的次数，是否满足请求的条件
4、不满足，就抛出异常，前端收到请求过快的响应。满足访问，就直接访问。
一、代码的准备 视图：
class TestAPIView(APIView): authentication_classes=[MyJWTAuthentication] permission_classes = [AdminPermission,] def get(self,request) return Respponse({'code':200,'msg':'测试通过'}) 路由：
path('test/',views.TestAPIView.as_view()) 请求方式：GET
流量控制类：
from rest_framework.throttling import SimpleRateThrottle #对请求源的IP进行限制 class IPThrottle(SimpleRateThrottle): # 在settings中配置频率时使用到的关键字，有scope来指定 scope = 'IP' def get_cache_key(self, request, view): return f'{self.scope}-{self.get_ident(request)}-throttle' # 这里return什么，就以什么作为限制，这里限制ip，直接return ip就可以 return request.META.get('REMOTE_ADDR') # 可以在这里设置访问频率 # def get_rate(self): # return '3/m' 二、具体的流程 1、TestAPIView的as_view方法，当前实例对象没有，找父类的APIView的as_view
@classmethod def as_view(cls, **initkwargs): #1、调用APIView父类的as_view方法 view = super().as_view(**initkwargs) view.cls = cls view.initkwargs = initkwargs #2、去除掉csrf校验 return csrf_exempt(view) 2、APIView的as_view是调用父类View的as_view方法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8a1ffdb996313735c88a509d9ec9ffb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3465cbd5c76914dc4498f0a539e6f9d5/" rel="bookmark">
			DRF-源码解析-4.1-SimpleRateThrottle源码解析：SimpleRateThrottle源码解析，SimpleRateThrottle实现1/5m此类型的规则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、限流类解析 from rest_framework.throlle import SimpleRateThrottle class SimpleRateThrottle(BaseThrottle): cache = default_cache timer = time.time cache_format = 'throttle_%(scope)s_%(ident)s' scope = None THROTTLE_RATES = api_settings.DEFAULT_THROTTLE_RATES #1、初始化对象 def __init__(self): #查看有无rate(限流规则)成员变量：1/m、1/s、1/h、1/d if not getattr(self, 'rate', None): #没有就去调用get_rate方法 self.rate = self.get_rate() #解析限流规则：5/m ---&gt; 5,60s self.num_requests, self.duration = self.parse_rate(self.rate) #4-1、获取唯一标识 def get_cache_key(self, request, view): #唯一标识，对请求中的什么进行限流 raise NotImplementedError('.get_cache_key() must be overridden') #2、获从配置文件中获取限流规则 def get_rate(self): #获取scope成员变量 if not getattr(self, 'scope', None): msg = ("scope是必须配置的 '%s'" % self.__class__.__name__) raise ImproperlyConfigured(msg) try: #从配置文件中，获取到scope 对应的限流规则 return self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3465cbd5c76914dc4498f0a539e6f9d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09248472609f955ebc269d81430c85e7/" rel="bookmark">
			JHipster - Spring Boot 的快速开发利器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		产品介绍：
JHipster是一个开源的、全面的应用程序生成器，它能够帮助开发者快速生成Spring Boot + Angular/React/Vue.js的完整应用程序。它不仅提供了一个简单的界面来定义应用程序的配置，还提供了一组强大的代码生成器，可以在数分钟内生成整个应用程序的骨架。
应用场景：
对于那些希望快速搭建企业级Spring Boot应用程序的人来说，JHipster是一个理想的选择。它适用于各种规模的项目，从小型项目到大型企业级应用。如果你是一名Java开发者，想要快速地搭建一个单页面应用（SPA），或者是一名前端开发者，想要快速地与后端集成，那么JHipster都将是你的得力助手。
功能特色：
多模板支持： JHipster支持Angular、React和Vue.js三种前端模板，你可以根据项目需求选择最合适的模板。
一键生成： 使用JHipster的代码生成器，你可以轻松地生成CRUD、REST API、安全配置等常用功能。
集成测试： JHipster自动生成集成测试，确保你的应用程序在开发过程中始终保持稳定。
持续集成/持续部署（CI/CD）： 你可以轻松地将JHipster项目与Jenkins、CircleCI等CI/CD工具集成，实现自动化部署。
灵活定制： 如果你需要更高级的定制，JHipster也提供了相应的插件系统，你可以根据需要添加或修改功能。
适用人群：
Java开发者： 如果你是一名Java开发者，希望快速搭建一个Spring Boot应用程序，那么JHipster将是你的最佳选择。
前端开发者： 如果你是一名前端开发者，希望快速与后端集成，构建单页面应用（SPA），那么JHipster也可以为你提供强大的支持。
初学者： 对于初学者来说，JHipster提供了一个完整的、经过良好组织的项目模板，可以帮助他们快速入门并掌握Spring Boot和前端开发的最佳实践。
总结：
在我使用JHipster的过程中，我深刻体会到了其强大的功能和便捷性。它不仅极大地提高了我的开发效率，也使我能够专注于业务逻辑的实现，而不是花费大量时间在基础设置上。如果你还在为如何快速搭建高质量的Spring Boot + 前端应用程序而烦恼，那么我强烈推荐你尝试一下JHipster，我相信你一定会爱上它的！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d324f4c9f197f3d6a61f81c4cd753e4/" rel="bookmark">
			DTM分布式事务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DTM分布式事务 从内网看到了关于事务在业务中的讨论，评论区大佬有提及DTM开源项目[https://dtm.pub/]，开学开学
基础理论 一、Why DTM ​ 项目产生于实际生产中的问题，涉及订单支付的服务会将所有业务相关逻辑放到一个大的本地事务，导致大量耦合，复杂度大幅提升
​ java成熟的分布式事务解决方案，使用代价过高：大量业务用java重写
​ DTM，Distributed Transaction Manager， 其是一个分布式事务管理器，解决跨数据库、跨服务、跨语言更新数据的一致性问题。
​ DTM提供了Saga、TCC、XA和二阶段消息模式以满足不同应用场景的需求，同时首创的子事务屏障技术有效解决幂等、悬挂和空补偿等异常问题。
​ DTM的优点：
提供简单易用的接口，拆分具体业务接入分布式事务支持多语言栈核心技术子事务屏蔽，降低处理子事务乱的难度 二、 快速上手 1、Demo ​ 了解DTM的发展和特点，quick start一下8⃣️
// 运行dtm git clone https://github.com/dtm-labs/dtm &amp;&amp; cd dtm go run main.go // 运行一个saga示例 go run qs/main.go ​ 上述Saga示例实现一个类似跨行转账的功能，包括两个事务分支：资金转出（TransOut）、资金转入（TransIn）。DTM保证TransIn和TransOut要么全成功，要么全回滚，保证最终金额的正确性。
// 具体业务微服务地址 const qsBusi = "http://localhost:8081/api/busi_saga" req := &amp;gin.H{"amount": 30} // 微服务的载荷 // DtmServer为DTM服务的地址，是一个url DtmServer := "http://localhost:36789/api/dtmsvr" saga := dtmcli.NewSaga(DtmServer, shortuuid.New()). // 添加一个TransOut的子事务，正向操作为url: qsBusi+"/TransOut"， 补偿操作为url: qsBusi+"/TransOutCompensate" Add(qsBusi+"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d324f4c9f197f3d6a61f81c4cd753e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e58a1f4c01f62ec9b6f0d08653f312b1/" rel="bookmark">
			电脑应用程序分身双开及多开(能记住账号和密码)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电脑应用程序双开及多开(能记住账号和密码)
以前一直想多个账号一起登录百度网盘账号，一直有问题，没找到解决方法，今天终于解决了，能启动多个应用程序。
这是已经成功了，登录两个百度网盘的账号。3个以上也是可以的（只要电脑性能好，多少个都是可以的）。
现在终于方便了，能保存账号，还能同一个游戏登录不同的账号。
NICE。
我把方法总结在下面了，需要的网友，可以试试。
这是下载链接，里面有 软件及安装说明和使用说明。
https://download.csdn.net/download/qq_50808730/85090675
https://download.csdn.net/download/qq_50808730/85090675
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c370a68d5151359430fdc91e9a54f74/" rel="bookmark">
			Minecraft教程：使用MCSM面板搭建我的世界私服并实现远程联机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1. 安装JAVA2. MCSManager安装3.局域网访问MCSM4.创建我的世界服务器5.局域网联机测试6.安装cpolar内网穿透7. 配置公网访问地址8.远程联机测试9. 配置固定远程联机端口地址9.1 保留一个固定tcp地址9.2 配置固定公网TCP地址9.3 使用固定公网地址远程联机 前言 Linux使用MCSM面板搭建我的世界私服相对比windwos简单,也是目前比较流行的设置方式,在Linux中安装MCSManger也是非常容易,一键指令脚本即可安装，本篇教程演示在Ubuntu。
下面介绍MCSManager搭建Minecraft私服+cpolar内网转发工具,实现在外远程联机,无需公网IP，无需公网服务器,使用本地Linux服务器即可。
1. 安装JAVA 运行Minecraft需要java17的版本,检查Linux java版本
java -version 如果没有安装java,可以一键安装
sudo apt install openjdk-17-jre-headless 2. MCSManager安装 使用官网的下载命令脚本,直接下载安装,安装脚本只支持 Ubuntu/Centos/Debian/Arch 等主流 x86_64 位操作系统。
wget -qO- https://gitee.com/mcsmanager/script/raw/master/setup.sh | sudo bash 安装完成后,我们可以看到访问的地址,和相关的端口号,下面命令是操作命令.
3.局域网访问MCSM 通过上面的ip地址我们可以看到端口号是23333,我们可以通过在外部电脑使用局域网ip地址在浏览器访问23333端口,查看Linux 局域网ip地址:
ip address 输入命令后我们可以看到相关的局域网ip地址
然后使用外部浏览器,通过局域网ip地址加23333端口访问,即可看到MCSM的web界面,首次登陆,需要创建一个账号
4.创建我的世界服务器 在面板中,我们点击快速开始,创建一个Minecraft服务器
选择一键开服,简单,迅速
这里选择1.19.2 版本,点击安装
给服务器取个名字,然后点击OK,等待安装即可
安装成功后,我们点击按钮前往实例控制台
然后出现联机方式,我们点击下面跳过设置联机方式的选择
然后点击一下开启实例,开启实例后会生成一个server.properties文件,不开启实例不会生成
然后停止实例,修改配置文件,取消正版服务器的验证,点击文件管理
找到server.properties文件,点击编辑,第一页找不到,点击底部第二页
把online-mode的值改为false,然后保存,关闭
然后开启实例,这里的实例表示服务的意思
启动成功,我们可以看到端口信息,端口号为:25565
5.局域网联机测试 启动器和最新版JAVA地址：https://pan.baidu.com/s/1VuiGrX_hH_gzYzcKAjwEVA?pwd=6666
提取码：6666
本教程使用的是windows启动器和JAVA
安装好最新版JAVA后在启动器中创建一个账号，正版或是离线账号都可以
打开我的世界启动器,选择和服务器一样的版本1.19.2,启动
然后点击多人游戏
点击添加服务器,然后输入局域网ip地址加25565端口192.168.50.105:25565,点击加入服务器
现在我们成功搭建了我的世界私服，并且可以看到成功进入了游戏。
6.安装cpolar内网穿透 我们搭建好服务器后，如果想实现和好友远程联机游戏就需要用到cpolar内网穿透工具了，通过它生成一个公网地址发给好友，大家就能一起进入到你创建的MC服务器当中了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c370a68d5151359430fdc91e9a54f74/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95bd4067d27cc9cbd04d7b5dc4a36ba9/" rel="bookmark">
			windows@管理员用户账户
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 windows中的管理员用户账户将某个用户提升为管理员🎈直接创建一个管理员账户😊使用`lusrmgr.msc`程序创建先新建一个用户FAQ 在管理员组中添加新用户为管理员🎈方式1:手动输入方式2:在已有的用户列表中查找并选中修改/禁用pin码(普通情况) windows中的管理员用户账户 将某个用户提升为管理员🎈 根据需要,可以选择将某个用户设置为系统管理员 直接创建一个管理员账户😊 使用lusrmgr.msc程序创建 按下win+R输入lusrmgr.msc 先新建一个用户 左侧栏的Users选项卡
右键新建一个用户(默认为普通用户)
创建完后,如果没有报错,就可以关闭窗口了
windows这里没设计好,创建完一个后不会关闭刷新,而是让你继续创建(应该弹出一个创建成功的窗口比较好)手动刷新用户列表,检查新用户是否成功创建 FAQ 新用户名不可以和旧用户名冲突(重复)
如果您的当前的用户名(设为old)下出现系统环境问题(比如账户登录问题)
考虑新建一个系统维护者maintainer账户(管理员组)退出当前账户 如果您的账户是用Microsoft账户登录的,那么建议您用切换为本地账户然后登出这是为了避免同一个账户在同一台计算机下,不能同时登录作为多个账户 登录到maintainer执行lusrmgr程序,删除掉old账户 如有必要,删除old用户的家目录 新建一个和old同名的账户,保持一致的用户名 这么做的代价是,原来的old账户下家目录的某些软件可能无法在使用比如wsl子系统等 在管理员组中添加新用户为管理员🎈 方式1:手动输入 方式2:在已有的用户列表中查找并选中 修改/禁用pin码(普通情况) 打开路径:settings-&gt;Accounts-&gt;sign-in options-&gt;windows Hellow PIN
Change your PIN when you’re already signed in to your device - Microsoft Support 如果不可更改,那和可能是组织账号(organization account)的关系
可以考虑断开链接后,重新修改pin,然后再登录组织账号
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/312606f11c26247b832bb5ff5fb5e055/" rel="bookmark">
			Spring Boot CLI 中文文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文为官方文档直译版本。原文链接
Spring Boot CLI 中文文档 引言安装 CLI使用 CLI初始化新项目使用嵌入式 Shell 引言 Spring Boot CLI 是一种命令行工具，可用于从 start.spring.io 引导新项目或编码密码。
安装 CLI Spring Boot CLI（命令行界面）可通过使用 SDKMAN！(SDK 管理器）或使用 Homebrew 或 MacPorts（如果您是 OSX 用户）手动安装。有关全面的安装说明，请参见 “入门” 部分中的 getting-started.html。
使用 CLI 安装 CLI 后，在命令行输入 spring 并按 Enter 即可运行。如果不带任何参数运行 spring，会显示如下帮助屏幕：
$ spring usage: spring [--help] [--version] &lt;command&gt; [&lt;args&gt;] Available commands are: 可用命令包括： init [options] [location] Initialize a new project using Spring Initializr (start.spring.io) 使用 Spring Initializr（start.spring.io）初始化新项目 encodepassword [options] &lt;password to encode&gt; Encode a password for use with Spring Security 为密码编码，以便与 Spring Security 一起使用 shell Start a nested shell 启动嵌套 shell Common options: --debug Verbose mode Print additional status information for the command you are running 打印正在运行的命令的其他状态信息 See 'spring help &lt;command&gt;' for more information on a specific command.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/312606f11c26247b832bb5ff5fb5e055/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7eeab6e8c419ea7e0a2187af48383958/" rel="bookmark">
			网络安全从入门到精通（超详细）学习路线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先看一下学网络安全有什么好处： 1、可以学习计算机方面的知识
在正式学习网络安全之前是一定要学习计算机基础知识的。只要把网络安全认真的学透了，那么计算机基础知识是没有任何问题的，操作系统、网络架构、网站容器、数据库、前端后端等等，可以说不想成为计算机方面的专家都难。
2、可以伪装成酷酷的黑客
学习网络安全之后就可以接触到一些比较强大，外行人“看不懂”的软件的操作系统，这些东西在外行人眼里都是非常炫酷的。比如在Linux系统里面，终端打开，黑框框里，一顿命令猛如虎，如果这时候你身边有外行的异性经过，那么绝对可以收获大量的崇拜目光。
3、可以得到一份不错的收入
网络安全从业人员的收入还是非常不错的，和很多其他行业比起来，还要远高于很多行业。如果想要转变发展领域，或者想增加一下自己的收入，可以考虑拿出一段时间来安心的学习网络安全知识。我自己就是这种情况，了解到了市场需求和岗位情况之后，果断转行。
随着国家信息化的发展，我国对于网络安全人才的需求量也大大增加，而现在一个科班出身的网络安全人才真的很难找。要不就是有的自称网络安全工程师侃侃而谈，一旦让他在Linux下配置，还真的未必能会配。所以，哪个甲方不愿意找一个懂得更多的人呢？
4、为了“爱和正义”
从事网络安全的工作，提升到情怀的层面来说，这项工作确实也是可以保护一方平安的，虽然对于网络安全的工作来说，没有消息就是最好的消息，确实网络安全的工作都是在幕后，但是幕后也有大英雄。就像《三体》里面的执剑者罗辑一样，当人们都习以为常，甚至不曾觉得他的存在，但是他的存在在保护着地球的平安，直到后来被圣母程心接棒以后，人们才感觉到了罗辑的重要性。幕后的英雄有合适的机会也会走到台前，接受鲜花和掌声。就像《孤勇者》的歌词里写的：谁说站在光里的才算英雄。如果没有一点点的情怀，没有热爱，学习网络安全，一定会产生枯燥的情绪。但我们要体会的是那种干了拯救地球的事情之后，还能表现出深藏功与名的淡然。
网络安全学什么？
1、网络安全法
网络并不是狂徒张三的法外之地，在学习网络安全技术之前，首先要学会如何在法律范围之内行事。在2017年6月1日，我国第一部网络安全法《中华人民共和国网络安全法》正式实施，我国网络安全管理迈入法治新阶段。所以，我们学习的第一课就是网络安全的普法课程。
所以，在法律的界限里，先要知道底线在哪里，以前没有网络安全法的时候，有些界限是模糊的，现在我们要严格在网络安全法的范围内活动，不然真的如江湖传言：网络安全，从入门到入狱；Kali学的好，局子进的早；渗透学得好，牢饭吃到饱。
2、黑客守则
听到黑客这个词，肯定觉得和犯罪沾边，但是现在的黑客并不是这样，千万不要觉得黑客是罪犯，其实“黑客”这个词语在刚出来的时候，就像内裤外穿的超人一样，是正义的化身，是一个褒义词。可是近几年，随着一些不讲武德的人占比越来越高，使得这个词语被无情丑化。我们学习网络安全的初心是正义和爱，这个是坚持100年甚至一直不动摇的初心使命，所以我们也要有一些规矩。
3、技术
阶段一：基础部分
Windows部分
基础命令、PowerShell的使用和简单脚本编写
组件：注册表、组策略管理器、任务管理器、事件查看器
另外，可以先学习一下怎么在Windows上搭建虚拟机，学会安装系统，为接下来学习Linux做准备
Linux部分
主要学习如何使用，学习文本编辑、文件、网络、权限、磁盘、用户等相关的命令，要建立一个Linux的基本认知。
这个阶段的误区就是小白很容易一上来就学Kali，连基本的概念都没懂，就去学习使用工具，属于典型的本末倒置。
计算机网络部分
从局域网出发，了解计算机通信的基本网络——以太网
局域网如何通信？
集线器、交换机之间的区别？
MAC地址、IP地址、子网、子网掩码的作用？
随后就要了解广域网、互联网，通过七层和四层模型快速建立起计算机网络的基础概念，各层协议的作用，分别有哪些协议，这些协议在当今的互联网中具体是怎么应用的。
Web基础部分
学习网络安全，就离不开web。Web安全是网络渗透中非常重要的一个组成部分。
掌握HTML+CSS+JS的开发使用
这一部分需要自己动手的会多一些，比如熟悉掌握Javascript、了解Ajax、学习JQuery
数据库基础部分
主要学习一些理论知识，重点掌握库、表、索引概念，学习SQL编写，学会增删改查数据
阶段二：进一步学习基础
Web进阶
学习Apache和Linux的基本知识
动态网页基本原理
CGI/Fast-CGI过渡到ASP/PHP/ASPX/JSP等动态网页技术，了解它们的发展历史，演变过程和基础的工作原理。
Web开发中的基础知识：表单的操作、Session/Cookie、JWT、LocalStorage等等，了解这些基本的术语都是什么意思，做什么用，解决了什么。
PHP编程
选择PHP是因为它更放方便我们研究安全问题。
需要学习：语法基础，基本的后端请求处理，数据库访问，然后再接触一下常用的ThinkPHP框架
计算机网络进阶
HTTP/HTTPS以及抓包分析
inux上的tcpdump必须掌握，包括常见的参数配置
学习Wireshark分析数据包，用Fiddler抓取分析加密的HTTPS流量。
加解密技术
包括base64编码、对称加密、非对称加密、哈希技术等等。
阶段三：中级技术
Web安全入门
Web安全领域内几大典型的攻击手法：SQL注入、XSS、CSRF、各种注入、SSRF、文件上传漏洞等等，每一个都需要详细学习，一边学习理论，一边动手实践。
这里需要自己在虚拟机中搭建一些包含漏洞的网站，如果在互联网上的网站来攻击是会被请去喝茶的。
网络扫描与注入
学习如何寻找攻击点，获取目标信息
信息包括：目标运行了什么操作系统，开放了哪些端口，运行了哪些服务，后端服务是什么类型，版本信息是什么等等，有哪些漏洞可以利用，只有获取到了这些信息，才能有针对性的制定攻击手段，拿下目标。
需要学习常用的扫描工具以及它们的工作原理。
信息搜集与社会工程学
whois信息用来查询域名信息，shodan、zoomeye、fofa等网络空间搜索引擎检索IP、域名、URL等背后的信息，Google Hacking利用搜索引擎来检索网站内部信息，这些东西都是在网络信息搜集中经常用到的技能。
暴力破解
学习爆破工具hydra、超级弱口令、mimikatz
阶段四：安全防御和检测
WAF技术 需要学习web应用防火墙。掌握WAF工作原理，找到弱点绕过检测，或者加强安全检测和防御能力
需要学习当下主流的WAF软件所采用的架构比如openresty、modsecurity，以及主要的几种检测算法：基于特征的、基于行为的、基于机器学习的等等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7eeab6e8c419ea7e0a2187af48383958/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c1ccba60ec64fc6a945b97d6c0d88bd/" rel="bookmark">
			MySQL C API的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL C API的使用 介绍及使用 MySQL C API（也称为 MySQL Connector/C）是用于与 MySQL 数据库交互的 C 语言 API。它提供了一组函数和结构体，允许你在 C 程序中连接到 MySQL 数据库服务器，并执行查询、插入、更新等数据库操作。
以下是 MySQL C API 的基本使用步骤：
1. 包含头文件： 在你的 C 代码中包含 MySQL C API 的头文件：
#include &lt;mysql/mysql.h&gt; 2. 初始化和连接： 在程序开始时，需要初始化 MySQL C API 并建立与数据库服务器的连接。以下是一个简单的例子：
// 这个函数初始化MySQL，并返回一个MYSQL指针。这个指针在后续的操作中都会使用到。 MYSQL *conn; conn = mysql_init(NULL); if (conn == NULL) { fprintf(stderr, "mysql_init() failed\n"); exit(1); } //连接到数据库：mysql_real_connect()使用这个函数来连接到数据库。其中参数包括上一步得到的MYSQL指针，以及数据库的主机名、用户名、密码、数据库名等。 if (mysql_real_connect(conn, "localhost", "user", "password", "database", 0, NULL, 0) == NULL) { fprintf(stderr, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c1ccba60ec64fc6a945b97d6c0d88bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d5164667706b0102d7c2a38975363cc/" rel="bookmark">
			监听键盘事件vue3封装hooks
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		监听页面键盘事件，执行对应方法
使用第三方API：vueuse
我封装的：
1. useKeyboardEvent.ts
import { useMagicKeys } from '@vueuse/core' export function enterKey(f: Function) { const { enter } = useMagicKeys() watch(enter, v =&gt; { if (v) { f() } }) } 2. 页面使用
import { enterKey } from '@/hooks/useKeyboardEvent' enterKey(handleQuery) function handleQuery() { ... } 前端大佬封装的：
1. useKeyboardEvent.ts
import { useMagicKeys, whenever } from '@vueuse/core' export function useKeys(keysMap: Record&lt;string, Function&gt;) { const magicKeys = useMagicKeys() Object.keys(keysMap).forEach(key =&gt; { whenever(magicKeys[key], () =&gt; keysMap[key]()) }) } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d5164667706b0102d7c2a38975363cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65a971e58295172969a8464128baeacf/" rel="bookmark">
			探索人工智能：深度学习、人工智能安全和人工智能编程（文末送书）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 学习AI要看的第一本书人工智能应当以人为本史蒂芬·卢奇（Stephen Lucci）萨尔汗·M·穆萨（Sarhan M . Musa）丹尼·科佩克（Danny Kopec）（已故） 通晓六点，明白人工智能是怎么回事基本概念和历史基础知识基于知识的系统高级专题现在和未来安全和编程本书具备以下特点 总结送书规则 学习AI要看的第一本书 人工智能知识对于当今的互联网技术人来说已经是刚需。但人工智能的概念、流派、技术纷繁复杂，选择哪本书入门最适合呢？
这部被誉为人工智能“百科全书”的《人工智能（第3版）》，可以作为每个技术人进入 AI 世界的第一本书。
购书链接，限时特惠5折
这本书是美国人工智能领域的权威经典教材，受到广大师生的广泛好评。中文版更是被近百所高校采用，作为专业教科书使用。
本书第 2 版出版于 2018 年，恰恰在过去的5年中，人工智能技术有了突破性的进展，大模型即是其中的代表。第3版在第 2 版的基础上进行了内容调整和升级，以跟上技术发展的步伐。新增了深度学习、人工智能安全和人工智能编程等新进展、新成果。
全书内容包括人工智能的历史、思维和智能之辩、图灵测试、搜索、博弈、知识表示、产生式系统、专家系统、机器学习、深度学习、自然语言处理（NLP）、自动规划、遗传算法、模糊控制、安全等。此外，它还介绍了一些新技术和应用，如机器人、高级计算机博弈等。
从上述内容不难理解本书为何被称为 AI百科全书。它涵盖了人工智能重要技术的理论与应用，帮助读者建立起系统化的知识框架，为深入研究人工智能打下了坚实的基础。
那么，人与机器之间应该是什么关系呢？我们看一下作者是怎么说的。
人工智能应当以人为本 《人工智能（第3版）》的作者的观点很鲜明：“人工智能是由人（people）、想法（idea）、方法（method）、机器（machine）和结果（outcome）等对象组成的。”
首先，组成人工智能的是人。人有想法，并把这些想法变成了方法。这些想法可以用算法、启发式方法、程序或作为计算骨干的系统来表达。最后，我们得到了这些机器（程序）的产物，称为“结果”。
这就是以人为本的理念，从根本上说，机器应该实现人的想法，体现人的意志。所以一个人不能将自己的思考最后也交给机器，而是要让机器辅助自己提升效能，成就更大的事业。
即使是在一本讲述人工智能的理论和应用的书里，也要有人文精神的存在。因此作者特意添加了“人物轶事”专栏，介绍对人工智能的发展做出贡献的人。从人到想法再到方法，这些内容贯穿本书的全部章节。
本书的三位作者都是人工智能方面的资深学者，在这一领域有着多年的深入研究和探索经验，为学界和业界培养了众多的人工智能专业人才。
史蒂芬·卢奇（Stephen Lucci） 他拥有纽约市立大学研究生院的博士学位，在纽约城市学院教授计算机科学，在高性能计算和人工智能领域发表过多篇文章。
萨尔汗·M·穆萨（Sarhan M . Musa） 博士 他在普雷里维尤农工大学（Prairie View A&amp;M）作者，著有 Computational Nanophotonics（CRC Press）和 Finite Element Analysis（MLI）等多部图书。
丹尼·科佩克（Danny Kopec）（已故） 本书第 2 版的合著者，曾任教于布鲁克林学院，著有多部图书，还是一位国际象棋大师。
本书的主要译者也是一位来自业界的大咖，他就是小米人工智能实验室主任、自然语言处理首席科学家王斌博士。他正好也是在5年前从学界进入业界，见证了人工智能在中国的飞速发展，所以特别希望能够传播人工智能的基础知识，推动技术的发展。
王斌博士在翻译本书时力求严谨精准，为准确翻译一张图，与同事讨论交流十多次；对于有疑问的内容与原作者反复沟通确认；对书中的代码甚至都要在编程环境中验证通过。
本着这样的认真态度，在王斌博士、王书鑫博士、王鹏鸣博士三位译者的齐心协力下，这本书得以高质量地交付，这绝对是读者的福音。
让我们开始人工智能的学习之旅吧。
通晓六点，明白人工智能是怎么回事 本书是一本基础教材，覆盖知识面广泛，可以让读者快速入门。在内容编排上也做到了由浅入深，在讲解理论的同时兼具实用性。全书分为六个部分，我们按照顺序来学习。
基本概念和历史 介绍人工智能的定义、处理的问题领域和发展历史。从图灵测试开始回顾，历述人工智能发展旅途上的前进与曲折，以及在新千年的发展。
基础知识 介绍人工智能的基础技术，包括搜索、逻辑、知识表示和产生式系统。主要知识点有盲目搜索、知情搜索、博弈中的搜索、人工智能中的逻辑、知识表示、产生式系统。
基于知识的系统 介绍基于知识的人工智能系统，包括知识的不确定性表示和推理、专家系统与知识工程、传统的机器学习和深度学习方法，以及受大自然界启发的搜索方法。
高级专题 介绍NLP，包括 NLP 的历史及流派、句法分析、统计方法、数据集合、信息提取、问答和语音理解等。还介绍了自动规划，包括规划的基本概念、方法及一些有代表性的规划系统。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65a971e58295172969a8464128baeacf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95ac82968b86eb98a927b9aa8a3518a3/" rel="bookmark">
			【嵌入式——C语言】文件操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【嵌入式——C语言】文件操作 文件指针打开文件文件打开的方式 关闭文件一次读写一个字符一次读写一个字符串读文件写文件随机读写rewindfseeklong ftell 文件指针 文件指针在程序中用来标识一个文件的，在打开文件的时候得到文件指针，文件指针就用来代表打开的文件，对文件进行读、写、关闭等操作时，对文件指针操作即可，将文件指针传给相应的读、写、关闭函数。
需要引入#include &lt;stdio.h&gt;
FILE * 文件指针变量名; 打开文件 打开一个已经存在的文件，并返回这个文件的文件指针或者创建一个文件，并打开这个文件，并返回这个文件的文件指针。
FILE* fopen(char const* _FileName,char const* _Mode) 参数1 打开的文件名称、路径+名称 参数2 文件打开的方式 文件打开的方式 只读®：文件不存在返回NULL，文件存在且打开成功，返回文件指针，r(文本文件)、rb(二进制文件)；只写(w)：文件不存在，以指定文件名创建文件并打开，文件存在，清空文件内容，打开文件，进行写操作，文件打不开，返回NULL，w(文本文件)、wb(二进制文件)；可读可写(+)：r+(文本文件)、rb+(二进制文件)；追加(a)：文件不存在，创建该文件，文件存在，在文件末尾进行写操作，a(文本文件)、ab(二进制文件)； FILE* fp; fp=fopen("filename.txt","r"); 关闭文件 关闭fp所代表的文件，一个文件只能关闭一次，成功返回0，不成功返回非0，关闭之后就不能在对文件指针进行读写操作了。
int fclose(FILE* fp) 一次读写一个字符 从文件中读取一个字节，将字节值返回。
注：EOF 是常量-1。
以文本(t)的方式，读到结尾返回EOF；以二进制(b)的方式，读到文件结尾，以feof(文件指针)方法判断是否结尾，文件结束返回非0，未结束返回0。 int fgetc(FILE* stream) 将c写入stream所代表的文件中。输出成功返回输出的字节值，输出失败返回EOF。
int fputc(int c,FILE* stream) 一次读写一个字符串 从stream所代表的文件中读取字符，在读取的时候碰到换行符或者到了文件末尾停止读取，或者读取了size-1个字节停止读取，在读取的内容后面会加\0，作为字符串的结尾。读取成功返回数组的首地址，即s，读取失败返回NULL。
char* fgets(char* s,int size, FILE* stream) 将s所指的字符串写到stream代表的文件中，成功返回写入的字节数，失败返回-1。
int fputs(char const* s, FILE* stream) 读文件 从stream所表示的文件中读取数据，每块是size个字节，共是nmemb块，存放到ptr指向的内存里，返回值，实际读取到的块数。
size_t fread(void* ptr,size_t size , size_t nmemb, FILE* stream) 写文件 将ptr指向的内存里的数据，向stream所代表的文件中写入数据，每块size个字节，共nmemb块，返回值，实际写入的块数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95ac82968b86eb98a927b9aa8a3518a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c63cb08170bc53ae66a46b29b741ed4/" rel="bookmark">
			Qt QWidget窗口基类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 QWidget介绍2 如何显示 QWidget窗口2.1 新建基于QWidget的窗口类2.2 再添加一个QWidget窗口类2.3 显示新添加的 QWidget窗口 3 常用的属性和方法3.1 窗口位置3.2 窗口大小3.3 窗口标题3.4 窗口图标3.5 资源文件 4 实例 1 QWidget介绍 Qt 中的常用控件，比如按钮、文本框、下拉框、树形控件等都是控件，QWidget类是所有控件类的父类。
所有窗口类的基类 Qt中有3个窗口的基类：QWidget、QMainWindow、QDialog其中，QMainWindow、QDialog都是继承自QWidge 所有控件类的基类 Qt中的控件类（按钮、输入框、单选框等）也属于窗口类它们的基类也是QWidget 可以内嵌到其他窗口的内部，此时需要给其指定父窗口可以作为独立的窗口显示，此时不能给其指定父窗口 2 如何显示 QWidget窗口 零新建一个基于QWidget的主窗口，并且再添加一个基于QWidget的窗口
2.1 新建基于QWidget的窗口类 新建一个工程Demo，只是这里让主窗口继承自QWidget
2.2 再添加一个QWidget窗口类 首先，右键单击【Demo】，点击【添加新文件…】
选择【Qt】-&gt;【Qt设计师界面类】
选择【Widget】，然后下一步
输入类名，然后点击下一步
2.3 显示新添加的 QWidget窗口 为了便于显示，打开subwidget.ui设计师界面，拖放一个按钮，如下：
然后来到widget.cpp文件中，添加如下代码，来显示SubWidget窗口：
// 在widget.cpp文件中 // 未指定父窗口， 这个窗口就是独立的窗口 // 需要调用其show方法 来将其显示 SubWidget *subWidget = new SubWidget(); subWidget-&gt;setWindowTitle("SubWidget"); subWidget-&gt;show(); 如果指定了父窗口， 这个窗口就是内嵌窗口 就不需要调用其show方法 因为其父窗口显示时，会自动显示子窗口 SubWidget *subWidget = new SubWidget(this); subWidget-&gt;setWindowTitle("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c63cb08170bc53ae66a46b29b741ed4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80abd51d4ad1a8ec587f4ca155a2d294/" rel="bookmark">
			树状 _ 层次 结构数据的数据库表设计对比及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在做项目管理的项目，其中有层级关联，多模块情况，感觉平时的树状数据库设计不太行，所以了解了一下，这篇文章总结的很好
树状结构或层次结构的数据在企业应用里非常常见，例如公司的组织架构、文档库的目录结构、仓库的库位组织以及物件的分类等等。
通常的树状图是一种数据结构。把它叫做 “树” 是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。
它具有以下的特点：每个结点有零个或多个子结点；没有父结点的结点称为根结点；每一个非根结点有且只有一个父结点；除了根结点外，每个子结点可以分为多个不相交的子树。
树结构是一种非线性存储结构，存储的是具有 “一对多” 关系的数据元素的集合。
本文对计算机数据库表模型中常见的对树状 / 层次结构数据的几种设计进行介绍、对比：
邻接表模型路径枚举模型闭包表模型嵌套集模型 邻接表模型 在设计树状结构的数据库表的时候，大部分开发者会下意识的选择邻接表（Adjacency List）模型。例如：
CREATE TABLE category( category_id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(20) NOT NULL, parent INT DEFAULT NULL ); INSERT INTO category VALUES(1,'ELECTRONICS',NULL),(2,'TELEVISIONS',1),(3,'TUBE',2), (4,'LCD',2),(5,'PLASMA',2),(6,'PORTABLE ELECTRONICS',1),(7,'MP3 PLAYERS',6),(8,'FLASH',7), (9,'CD PLAYERS',6),(10,'2 WAY RADIOS',6); SELECT * FROM category ORDER BY category_id; +-------------+----------------------+--------+ | category_id | name | parent | +-------------+----------------------+--------+ | 1 | ELECTRONICS | NULL | | 2 | TELEVISIONS | 1 | | 3 | TUBE | 2 | | 4 | LCD | 2 | | 5 | PLASMA | 2 | | 6 | PORTABLE ELECTRONICS | 1 | | 7 | MP3 PLAYERS | 6 | | 8 | FLASH | 7 | | 9 | CD PLAYERS | 6 | | 10 | 2 WAY RADIOS | 6 | +-------------+----------------------+--------+ 在上面的分类表里，我们定义了分类 ID（category_id）、分类名称（name）以及父分类 ID（parent）三个字段。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80abd51d4ad1a8ec587f4ca155a2d294/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f58b557a26913c7656c1dabd902ba296/" rel="bookmark">
			copilot在pycharm的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
在PyCharm中应用Copilot的过程如下：
copilot在pycharm的应用：
集成与自定义：Copilot可以与PyCharm的许多其他功能集成，如版本控制（Git）、测试工具（pytest）等。这意味着你可以在编写代码的同时，轻松地查看和管理代码更改，或者运行和调试测试。
学习资源：Copilot不仅仅是一个代码补全工具。它还可以作为一个学习资源，帮助你更好地理解Python编程和各种库和框架的使用。你可以通过Copilot学习到其他开发者的最佳实践和常见模式。
安全性和隐私：在使用Copilot时，你应该注意其数据收集政策。Copilot需要访问你的代码以提供自动补全功能，但它也会收集和分析你的代码以改进其服务。你应该仔细阅读其隐私政策，并确保你同意其数据收集和使用方式。
使用限制：虽然Copilot功能强大，但它并不适用于所有情况。对于非常复杂的项目或特定领域的问题，你可能仍然需要手动编写代码。同时，如果你在项目中使用了大量自定义或特殊的代码库，Copilot可能无法提供足够精确的建议。
在PyCharm中应用Copilot的过程如下： 打开PyCharm，点击File -&gt; Settings -&gt; Plugins，在搜索框中输入“Copilot”进行搜索。找到并安装Copilot插件，点击Install。安装完成后，会提示重启PyCharm。重启PyCharm后，点击Tools -&gt; Github -&gt; Login to GitHub，登录自己的GitHub账号，以获得使用Copilot的权限。在代码编写过程中，根据提示按下Tab键，Copilot会自动进行代码补全。如果对提供的建议不满意，可以使用Alt+]或Alt+[键查看下一个或上一个建议。如果想要停止使用Copilot，可以在设置里面取消自动显示，并退出GitHub账号 除了自动补全代码，Copilot还可以提供代码建议和错误检查，帮助开发者更快地编写高质量的代码。另外，Copilot还可以用于生成代码示例，以供学习参考。
在PyCharm中使用Copilot的具体步骤可能会因为PyCharm版本或操作系统的不同而有所差异。因此，建议在使用过程中遇到问题时查看Copilot的官方文档或向PyCharm的官方支持寻求帮助。
copilot在pycharm的应用： 集成与自定义：Copilot可以与PyCharm的许多其他功能集成，如版本控制（Git）、测试工具（pytest）等。这意味着你可以在编写代码的同时，轻松地查看和管理代码更改，或者运行和调试测试。 学习资源：Copilot不仅仅是一个代码补全工具。它还可以作为一个学习资源，帮助你更好地理解Python编程和各种库和框架的使用。你可以通过Copilot学习到其他开发者的最佳实践和常见模式。 安全性和隐私：在使用Copilot时，你应该注意其数据收集政策。Copilot需要访问你的代码以提供自动补全功能，但它也会收集和分析你的代码以改进其服务。你应该仔细阅读其隐私政策，并确保你同意其数据收集和使用方式。 使用限制：虽然Copilot功能强大，但它并不适用于所有情况。对于非常复杂的项目或特定领域的问题，你可能仍然需要手动编写代码。同时，如果你在项目中使用了大量自定义或特殊的代码库，Copilot可能无法提供足够精确的建议。 成本考虑：最后，值得注意的是，Copilot目前是一个付费服务。虽然PyCharm本身可能是免费的（取决于你的使用情况），但Copilot的高级功能可能需要付费订阅。在决定是否使用Copilot时，你需要考虑其成本是否符合你的预算和需求。与其他插件的兼容性：在使用Copilot时，需要确保它与PyCharm中的其他插件兼容。有时，不同插件之间可能存在冲突，导致Copilot无法正常工作。因此，建议在使用Copilot之前，先检查其与其他插件的兼容性。代码风格和规范：Copilot可以根据你的代码风格和规范提供建议。在使用Copilot时，建议遵循一致的代码风格和规范，以确保生成的代码质量更高。性能问题：对于大型项目，Copilot可能会对性能产生一定影响。在某些情况下，Copilot可能会导致PyCharm的响应变慢或出现卡顿现象。因此，对于大型项目，建议在使用Copilot时注意性能问题。测试和验证：虽然Copilot可以提供代码建议和自动补全，但并不能替代手动测试和验证。在使用Copilot生成的代码时，建议进行充分的测试和验证，以确保代码的质量和稳定性。文档和支持：在使用Copilot时，建议查看其官方文档和支持资源，以了解更多关于其功能和使用的信息。此外，也可以向Copilot的官方支持寻求帮助，解决使用过程中遇到的问题。与团队协作：如果你是在一个团队中工作，那么Copilot的使用可能需要一些协调。不同的团队成员可能使用不同的编程风格和习惯，这可能导致Copilot的建议产生冲突。在这种情况下，建议团队成员共同制定一套编程规范，以确保Copilot的建议一致且有效。故障排除与故障预测：Copilot除了可以自动补全代码，还可以提示潜在的代码错误或问题。这可以帮助你提前发现并修复代码中的问题，从而提高代码的质量。不断更新与改进：记住，Copilot和所有的工具一样，都是不断更新和改进的。定期查看Copilot的更新日志和发布说明，了解新功能和改进，可以帮助你更好地利用这个工具。与其他IDE集成：虽然本文主要讨论了PyCharm，但Copilot也可以与其他IDE（如Visual Studio Code、IntelliJ IDEA等）集成。如果你使用的是其他IDE，可以查看Copilot的文档，了解如何将其集成到你的开发环境中。教育与培训：最后，如果你刚开始使用Copilot，建议查看一些教育资源和培训课程，以帮助你更快地掌握这个工具。许多在线平台提供了关于如何使用Copilot的教程和课程。自定义建议：Copilot允许你对建议进行自定义，以更好地适应你的编程需求。你可以调整建议的优先级、排除特定的代码片段或添加你自己的代码片段。集成单元测试：Copilot可以与单元测试框架（如pytest）集成，这样你就可以在编写代码的同时运行和调试测试。这有助于确保你的代码在编写过程中就符合预期的行为。API集成：如果你正在开发一个API，Copilot可以帮助你快速生成请求和响应的代码片段。通过与API文档（如Swagger UI）的集成，你可以轻松地生成符合API规范的代码。多语言支持：除了Python，Copilot还支持其他编程语言，如JavaScript、TypeScript、Ruby等。如果你在使用这些语言进行开发，也可以考虑在相应的IDE中使用Copilot。安全审查：Copilot可以作为一个安全审查工具，帮助你发现潜在的安全漏洞和问题。它会自动检查代码中的常见安全风险，并提供修复建议。性能优化：Copilot还可以提供关于性能优化的建议。例如，它可以建议使用更高效的数据结构或算法，或者优化你的代码以减少计算复杂度。代码重构：随着项目的增长和代码库的复杂度增加，代码重构成为一项重要的任务。Copilot可以帮助你识别和重构冗余代码、提取重复代码片段，以及改进代码结构。可读性与注释：Copilot不仅关注代码的功能，还注重代码的可读性。它可以帮助你编写清晰、易于理解的注释和文档字符串，从而提高代码的可维护性。调试与异常处理：在编写代码时，你可能会遇到各种错误和异常。Copilot可以提供关于如何处理这些异常的代码建议，以及如何设置断点和调试代码的建议。集成版本控制：Copilot可以与版本控制系统（如Git）集成，这样你就可以在编写代码的同时查看和管理代码更改的历史记录。这有助于跟踪代码的演变和协作。使用Copilot的局限性：尽管Copilot功能强大，但它也有其局限性。例如，对于复杂的算法或特定的编程模式，Copilot可能无法提供准确的建议。此外，对于一些特殊的需求或自定义代码，你可能需要手动编写或调整代码。更新与兼容性：随着技术的不断发展和更新，Copilot也需要不断更新以保持与新的编程语言和工具的兼容性。因此，建议定期检查Copilot的更新，以确保其与你的开发环境保持同步。隐私和安全性：在使用Copilot时，你需要注意隐私和安全性问题。虽然Copilot承诺遵守相关的隐私政策，但你仍需要注意不要在代码中包含敏感信息或个人数据。自定义建议的局限性：虽然Copilot允许你对建议进行自定义，但它的自定义能力是有限的。如果你有特定的需求或自定义的代码片段，可能需要手动进行添加或调整。学习曲线：虽然Copilot可以提高编程效率，但它的使用需要一定的学习和适应。对于刚开始使用Copilot的人来说，可能需要花费一些时间来熟悉其功能和界面。与其他插件的集成：尽管PyCharm已经集成了Copilot，但有时你可能需要使用其他插件来扩展其功能。在这种情况下，确保这些插件与Copilot兼容，并注意可能出现的任何冲突或问题。网络连接需求：由于Copilot需要访问互联网以提供实时建议和自动补全，因此请确保你的网络连接稳定且足够快。如果网络连接不稳定或速度较慢，可能会影响Copilot的性能和响应时间。更新和版本控制：由于Copilot是一个不断发展的工具，建议定期检查更新和版本信息。新版本可能包含新功能、性能改进和修复错误，确保你使用的是最新版本可以获得最佳体验。与其他开发者的互动：Copilot还提供了一个社区功能，你可以与其他开发者分享代码、讨论问题和交流经验。这可以让你从其他人的经验中学习，并扩展你的编程知识。保持关注官方文档和社区资源：为了充分利用Copilot的功能和最佳实践，建议保持关注其官方文档和社区资源。这些资源可以提供有关新功能、使用技巧和常见问题的详细信息，帮助你更好地利用这个工具。测试和验证的重要性：虽然Copilot可以提供代码建议和自动补全，但测试和验证仍然是必不可少的。始终确保测试你的代码，并验证其功能和性能。不要完全依赖Copilot：尽管Copilot可以提高效率，但始终要保持批判性思维。对于关键或复杂的代码部分，仍需仔细检查和手动编写。了解Copilot的工作原理：为了更好地利用Copilot，了解其工作原理是有帮助的。例如，了解其算法如何处理代码和建议，可以更好地指导其使用。注意代码风格和格式：Copilot可以根据你的代码风格和格式提供建议。因此，保持一致的代码风格和格式可以帮助你获得更准确的建议。备份和版本控制：在使用Copilot时，建议定期备份你的代码并使用版本控制（如Git）。这样，如果出现任何问题或需要回滚更改，你可以轻松地恢复代码。安全性和隐私性：在使用Copilot时，确保你了解其安全性和隐私性政策。如果你有任何担忧或疑虑，建议与Copilot的支持团队联系。持续学习和实践：编程是一个持续学习和实践的过程。即使在使用Copilot时，也要继续学习新的技术和最佳实践，以提高你的编程技能。注意代码可读性：Copilot可以帮助你编写易于理解的代码，但最终的责任仍然在于你。确保你的代码清晰、简洁，并使用有意义的变量和函数名。与团队成员共享Copilot：如果你在一个团队中工作，可以与团队成员分享Copilot的建议和功能。这有助于整个团队保持一致的编程风格和质量标准。注意性能优化：虽然Copilot可以提供关于性能优化的建议，但最终的责任仍然在于你。确保你的代码在运行时高效，并注意任何潜在的性能瓶颈。 Python的核心知识点整理大全66（已完结撒花）-CSDN博客
往期快速传送门👆（在文章最后）： 感谢大家的支持！欢迎订阅收藏！专栏将持续更新！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef18b5efe53a645fb8b12d0862acf7ac/" rel="bookmark">
			如何在Github上快速下载代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于网络环境问题，有时候比较难从Github上下载代码，我归纳了以下三种从Github上下载代码的方法，如何选择使用，可根据你的实际情况：
目录
方法一：使用 “Download ZIP” 按钮
方法二：使用 Git 克隆项目
方法三：使用 GitHub Desktop
方法一：使用 “Download ZIP” 按钮 打开你想要下载代码的 GitHub 项目页面。点击项目主页右上方的绿色按钮，上面标有 “Code”。选择 “Download ZIP”。下载将以 ZIP 文件的形式开始。一旦下载完成，你可以解压该 ZIP 文件，并在本地使用代码。 缺点是，有的时候无法下载。 方法二：使用 Git 克隆项目 使用Git的详细方法，可以参考我之前的一篇博客：http://t.csdnimg.cn/ZhEOb ，下面做简要介绍：
首先，确保你本地已经安装了 Git。如果你没有安装 Git，请从 https://git-scm.com/downloads 进行下载并安装。打开命令行终端或者 Git Bash 终端（如果你使用的是 Windows）。移动到你想要将代码下载到的文件夹中，使用以下命令： cd /path/to/your/desired/directory 上述路径选择，cd 后面是你想要保存下载文件的具体路径，当然，还有一种方法是直接在你要存储的文件夹右键然后选择Open Git bash here。 4. 在 GitHub 项目页面中，点击 “Code” 按钮，并复制项目的 URL。
5. 回到终端，输入以下命令来克隆代码库：
git clone https://github.com/czasg/pywss.git 在git中的运行效果如下：
我们发现执行该命令后，Git 将会将代码库中的内容下载到你刚才指定的文件夹中。
这种方法是我比较推荐的。
方法三：使用 GitHub Desktop 如果你喜欢使用图形界面的软件，你可以安装 GitHub Desktop。打开 GitHub Desktop，登录你的 GitHub 账户。点击 “File” &gt; “Clone Repository”，然后选择你要下载的项目，并选择一个本地文件夹来保存项目的代码。 这些方法中的任何一个都能让你快速下载 GitHub 上的项目代码。选择其中一个方法根据你的喜好和需求，我一般网速比较好的时候是选择第一种，如果第一种下载存在困难，则第二种是最佳选择。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab28bc01b3c9735a45fa2e31114f419f/" rel="bookmark">
			使用nvm安装了node版本管理，npm版本更新之后还是旧版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
组件库使用的node版本是比现在用的版本要低的版本，在这里使用了nvm去管理本地的node版本，这时遇到了一个问题是安装完node版本之后，相对应的npm版本还是原来的版本，原来一直以为是本地安装的全局的node版本导致的，卸载之后还是一样的现象，查看环境变量之后把所有相关的node的都删掉，这时还会出现同样问题
解决办法：
使用where npm 查看npm的安装目录,这时会发现之前安装的软件导致更改了环境变量使得npm的执行版本是此安装包里面的执行版本，所以才会导致无论装哪个版本都是这个版本导致，从环境变量里面删除此软件执行环境变量即可
这时再运行where npm，会是正常的安装目录
npm config set prefix “D:\nodejs\node_global” //设置全局包目录
npm config set cache “D:\nodejs\node_cache” //设置缓存目录
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee90383e2607c05de3eb9864f95acd7b/" rel="bookmark">
			CentOS 7.6的HTTP隧道代理进行负载均衡和流量分发的策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在CentOS 7.6上配置HTTP隧道代理进行负载均衡和流量分发，可以采取以下策略来提高网络性能和可用性。
1. 负载均衡策略 轮询（Round Robin） 轮询是最简单的负载均衡策略，按照顺序将每个请求分配给下一个服务器，直到达到最后一个服务器，然后再回到第一个服务器。
加权轮询（Weighted Round Robin） 加权轮询允许为每个服务器分配一个权重值，根据权重值的大小决定服务器接收请求的比例。权重值可以根据服务器的性能和资源利用率进行调整。
最少连接（Least Connections） 最少连接策略将新的请求发送到当前连接数最少的服务器。这种策略可以动态地根据服务器的负载情况进行调整。
加权最少连接（Weighted Least Connections） 加权最少连接策略结合了最少连接和加权轮询的原理，根据服务器的权重值和当前连接数进行负载均衡。
2. 流量分发策略 基于IP的流量分发 基于IP的流量分发根据客户端的IP地址进行流量分发，将相同来源的流量导向同一台服务器。这种策略有助于减轻特定服务器的负担，并提高缓存效率。
基于URL的流量分发 基于URL的流量分发根据请求的URL进行流量分发，将特定URL的流量导向特定的服务器。这种策略适用于处理不同的内容或服务。
基于请求头的流量分发 基于请求头的流量分发根据请求头信息进行流量分发，可以根据自定义的请求头字段来进行流量分发。这种策略提供了更大的灵活性，可以根据特定需求进行定制。
3. 健康检查和动态负载均衡 定期进行服务器的健康检查，确保服务器正常运行并能够处理请求。动态负载均衡可以根据服务器的实时性能和负载情况调整流量分发策略，确保网络性能的优化。
4. 监控和日志记录 通过监控代理服务器的性能指标和日志记录，可以及时发现和解决潜在问题，并优化负载均衡和流量分发策略。
综上所述，通过采用合适的负载均衡和流量分发策略，并结合健康检查、动态负载均衡、监控和日志记录等手段，可以提高CentOS 7.6上HTTP隧道代理的性能、可用性和可靠性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e00c4ae9ffea69f44a5393b8ffddc6e/" rel="bookmark">
			开发做前端好还是后端好
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、引言 选择前端开发还是后端开发取决于个人兴趣、技能和职业目标。每个领域都有其独特的挑战和机遇，而且现代的Web开发往往需要前后端开发人员紧密合作。
二、两者的对比分析 前端和后端是Web开发中两个主要的方向，它们分别负责用户界面和应用程序逻辑、数据库交互等不同的层面。以下是前端和后端在不同方面的对比分析：
1. 任务和职责： 前端： 负责构建用户直接与之交互的界面，包括网页的外观、布局和交互。使用HTML、CSS和JavaScript等技术。后端： 处理应用程序的业务逻辑，与数据库进行交互，处理用户请求，生成并提供数据给前端。使用服务器端语言（如Node.js、Python、Java、Ruby等）。 2. 编程语言： 前端： 使用HTML（标记语言）、CSS（样式表）、JavaScript等前端技术。后端： 使用多种编程语言，如Java、Python、Ruby、Node.js、PHP等，具体选择通常取决于项目需求和开发者偏好。 3. 框架和库： 前端： 使用诸如React.js、Angular、Vue.js等框架，以及jQuery等库来简化开发。后端： 使用框架如Express.js（Node.js）、Django（Python）、Ruby on Rails（Ruby）、Spring（Java）等，以提高效率和可维护性。 4. 开发工具： 前端： 使用文本编辑器（如Visual Studio Code、Sublime Text）或集成开发环境（IDE）（如WebStorm、Visual Studio）。后端： 使用文本编辑器、IDE或专门的集成开发环境，具体取决于所用编程语言和框架。 5. 数据交互： 前端： 发送请求到后端，接收并展示数据，与用户进行实时交互。后端： 处理前端发送的请求，与数据库或其他服务进行数据交互，将结果返回给前端。 6. 安全性考虑： 前端： 主要关注用户界面的安全性，防止跨站脚本攻击（XSS）等。后端： 关注服务器端的安全性，包括防止SQL注入、身份验证和授权等。 7. 性能优化： 前端： 优化网页加载速度，减少资源请求，使用前端工具进行代码分割和压缩等。后端： 优化数据库查询、采用缓存策略，处理高并发等，以提高系统性能。 8. 部署和维护： 前端： 部署到Web服务器或内容分发网络（CDN），通常只涉及静态文件。后端： 部署到应用服务器，可能需要数据库配置、安全设置等。需要处理应用程序的整个生命周期。 9. 协作与沟通： 前端： 通常需要与设计师密切协作，关注用户体验。后端： 与数据库管理员、系统管理员等密切协作，处理业务逻辑和数据存储。 10. 发展趋势： 前端： 持续关注用户体验、响应式设计、单页面应用（SPA）等前端发展趋势。后端： 关注微服务架构、云计算、容器化等后端发展趋势。 总体而言，前端和后端相互依存，共同构建完整的Web应用。团队成员需要相互协作，了解对方的工作，以确保整个应用的顺畅运行。
三、技能转换和跨领域工作 技能转换和跨领域工作是很常见的，尤其在现代Web开发中，全栈开发者（既能做前端又能做后端）的需求逐渐增加。以下是从前端到后端或反过来进行技能转换和跨领域工作的一些建议：
从前端到后端的技能转换： 学习后端语言： 选择一门常用的后端编程语言，比如Node.js (JavaScript), Python, Ruby, Java等，并深入学习其语法和特性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e00c4ae9ffea69f44a5393b8ffddc6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/429074185495781a307852a07952f75d/" rel="bookmark">
			分布式架构那些事儿
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天给大家搬运一波福利，那就是分布式架构那些事！说到分布式架构，你是不是觉得高大上、遥不可及？别慌，我会讲得通俗易懂，让你秒变架构大神！听完之后直接带回家装逼！一起来Get新知识！
首先我们要了解什么叫分布式架构。简单来说，就是把一个系统拆成多个子系统，在不同地理位置部署，相互协作完成任务。现在云计算、5G这些大热的技术都离不开它。其实生活中也有很多类似的例子，比如外卖小哥手里的送餐工具：订单被拆分到各个区域的小哥，他们快速找到顾客送到手里。这样我们才能足不出户吃遍美食！
那么分布式架构有哪些神奇魅力呢？首先它能提高系统可用性——意味着服务更稳定、可靠。任何一个环节出问题，其他环节还可以正常运行。就像外卖小哥，可能某一个小哥的电动车抛锚了，但其他小哥还能按时送达。牛掰不？
其次，分布式架构助力应对各种复杂场景。比如双11购物节，大家都疯狂下单，一时间访问量暴增。这就需要分布式，把请求分担给不同服务器，保证大家购物无卡顿！买买买！当然这些只是冰山一角，国分布式架构的优势还有很多。
接下来让我们来了解一个真实案例：阿里巴巴的双11就是典型的国分布式架构应用。在双11期间，订单、流量、支付等环节都面临超高压力。为了应对这种情况，阿里巴巴采用了国内多个数据中心进行分布式部署，在全球范围内建立了弹性伸缩系统。这就保证服务器随时调整资源和负载均衡。
同时，在双11当天各种活动页面更新非常频繁，采用了分布式缓存技术确保页面秒开无压力。现在你明白为什么每年双11阿里巴巴的成交额都能创纪录了吧？别忘了跟朋友装逼哦！
最后让我们来聊聊分布式架构未来的方向。随着5G、物联网等技术的发展，未来国内数据中心可能会越来越多且分布更广，形成一个跨区域、高速互联的巨型网络。这将对很多行业带来革命性变化：自动驾驶、远程医疗、智慧城市……它们都离不开分布式架构！
走到这里，给你打个预防针：虽然分布式架构有种种优点，但并不是万能的。在实际业务中要根据具体需求和场景选择合适的技术方案。
分布式架构的5个误区 分布式架构，听起来高大上，但在实际应用中却屡屡被我们误解！今天就来给大家揭秘分布式架构的5大误区，让你不再踩坑！
第1个误区，“分布式就是高并发”。其实，并发性只是分布式架构的一个方面。除此之外，分布式架构还有负载均衡、弹性伸缩等优点。所以，“分布式=高并发”这个说法是不全面的！
第2个误区，“上了分布式后，系统就万无一失了”。哎呀呀，这可真不是事儿。虽然分布式可以提高系统的可用性和容错性，但如果你认为“上了分布式系统后，业务就永远不会挂”那就大错特错啦！要细心处理好各个节点间的数据同步问题，还要对故障节点进行监控和恢复等。
第3个误区，“任何场景都适合用分布式”。这里要打个大大的问号！没必要为了追求技术潮流而盲目应用。有些场景下单体架构可能更加简单、易于维护。关键在于根据业务需求选择合适的架构！
第4个误区，“一开始就要做分布式设计”。不得不说，这个误区也很常见。确实，在互联网领域，系统规模扩张很快，不过一开始就去考虑分布式架构可能让人陷入过度设计的泥潭。记住哦，要先保证业务的稳定发展，然后根据需求逐步优化架构。
第5个误区，“分布式系统很简单”。谁说的？！分布式系统涉及到多种技术和理论，比如CAP理论、Paxos算法、Raft算法等。而且在实际开发过程中还需要考虑数据一致性、网络延迟等问题。所以分布式系统绝对不是简单的！
分布式架构必须要掌握的技能有哪些 分布式架构，这可是当下技术圈的热门话题！想要成为一个合格的程序员，怎么能不了解这个领域呢？掌握分布式架构技能，轻松涨粉不是梦！接下来，我们一起探讨哪些技能是分布式架构必备的吧！
首先，让我们来聊聊CAP原理。什么？你还不知道CAP原理？哎呀~大家抱歉啊~就让我解释一下好了。CAP指的是：一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）。在分布式系统中，这三项只能满足其中两项。所以，在设计系统时就要做出权衡和妥协！
其次，要学会使用负载均衡器。“负载均衡器”听起来就很酷炫对吧！它可以将流量灵活地分发到多个服务器上，提高整个系统的响应速度和可用性。常见的负载均衡策略有：轮询、加权轮询、随机、最小连接等等。
再来说说数据存储。既然我们正在谈论分布式架构，那么数据存储也不能忽视啦。我们需要掌握如何使用关系型数据库和非关系型数据库，并挑选出最适合自己项目需求的数据存储方式。
别忘了同步和异步通信！在分布式环境中，合适地选择同步或异步通信手段可以有效减少延迟时间。虽然同步通信更容易实现和理解，但异步通信却更具有扩展性。
另外一个核心技能是缓存。缓存策略可谓处处充满智慧！面对大量并发请求时，缓存可以有效降低服务器的压力。主流缓存解决方案有：本地缓存、Redis、Memcached等，在实际项目中灵活运用喔！
为了保持系统健壮性，请使用监控工具及时发现问题并优化调试。常见监控工具包括：Prometheus、Grafana、Zabbix等。这可以帮助你实时了解系统状况，提前发现潜在风险。
最后，我们来看看服务治理和微服务。微服务架构可谓现如今的大热门！它将系统拆分为多个小型、松耦合的服务，有利于快速迭代和灵活扩展。而服务治理则是保证微服务稳定运行的法宝，包括熔断、降级、限流等策略。
落地分布式架构的十个前置条件 落地分布式架构的前置条件！听着就高大上，是不是？别急别急，让我来揭秘它，让你在朋友圈中瞬间脱颖而出！
首先，“分布式架构”这个名词有点高冷，但其实它的美好愿景就是减轻服务压力、提高服务稳定性和容错能力。当然啦，在我们跃跃欲试要把它落地之前，必须了解一下这个大块头的前置条件。咱们一起数一数吧！
1. 高性能硬件：这可是硬档次！想要分布式架构飞起来，得有足够强悍的硬件基础才行。服务器、存储、网络设备等等乌瑞都要那种锦上添花才够档次。
2. 扎实的开发基本功：这个可不能含糊。团队成员需要具备扎实的编程基本功和良好的编程规范，再加上设计模式、数据结构与算法这些私房菜。
3. 完善的监控和告警系统：紧盯着故障不放！及时发现问题、定位问题、解决问题。想象一下早上起床收到系统告警信息反馈“亲爱滴，我们服务出问题啦”，岂不快哉！
4. 优雅降级和熔断限流策略：有时候人生也需要兜底策略。在异常情况下优雅降级保证关键功能可用；熔断限流机制保证资源平稳使用。
5. 数据备份与恢复策略：按时打卡保平安！定期数据备份并测试恢复机制能给你带来极大安全感哦。
6. 分布式事务处理机制：面对多个子系统联手操作，事务协调变得尤为重要。两阶段提交、最终一致性等专业名词保证事务完整性。
7. 高可用集群策略：微笑面对宕机！没有它，分布式架构的稳定性就只是空中楼阁。主从备份、双活等多种高可用策略丰富你的选择面。
8. 分布式文件系统：这个和我们平时使用的文件系统有点不一样，哦不，是很不一样！能让多个服务器犹如一个超级大脑共享资源。
9. 数字化运维：你是否还在为程序员与运维人员对线上问题“推诿责任”而纠结？别慌，数字化运维让你告别这种矛盾！
10. 不断迭代优化架构：万变不离其宗！分布式架构可以提升企业服务水平，但无论何时，要时刻保持更新换代的勇气和决心！
分布式架构是否一定要完成微服务改造 分布式架构到底需不需要微服务改造呢？这可是一个让无数程序猿夜不能寐的问题！请大家在下面帮我做个转发互动，小助手会给你们一一揭晓答案哦！
那首先我们得先弄清楚什么是分布式架构和微服务。分布式架构简单来说就是将原本一个大型的系统拆分为多个独立的子系统，这样能有效地提高整体性能、增加可用性和扩展性。微服务是一种设计模式，它让你可以通过围绕业务功能来构建应用，并且这些功能是可独立发布和扩展的。
但话说回来，大家都知道最近互联网公司对于微服务可谓疯狂追求，然而要真正理解并落地微服务却并非易事。在网络上到处都是关于“微服务改造”的各种文章和案例，有时候我们看着看着就会懵逼：“咦？这跟分布式架构有啥区别啊？”。
然后呢，接下来我们要解决的问题就是：分布式架构是否一定要完成微服务改造呢？
答案是：并不一定！
首先，我们得明确一个观点：微服务并不是分布式架构的唯一解决方案。“不改微服务也想搞分布式？你在跟我开玩笑吗？”很多朋友可能会这样想。而事实上，之前的经典架构，如垂直应用和SOA等，在实现系统拆分和降低耦合方面也有它们独特的优势。
我们不能说微服务是唯一的正确选择，每个架构都有自己适合的应用场景。关键是你要了解清楚你们的业务场景以及目前所处阶段，然后根据这些需求去做出最恰当的决策。
此外，需要指出的是微服务改造并非易事，它会带来很多挑战和成本问题。诸如技术选型、团队建设、协同开发、监控调试等问题，在微服务改造过程中都需要解决。因此，在尝试之前一定要认真评估公司当前情况和预期效果哦！
那么在哪些场景下可以考虑微服务改造呢？通常来讲，请在以下几种情况下优先考虑进行微服务：
1.业务增长迅速，系统扩展性需求迫切。
2.团队足够大，并且具备相应的技术实力和成功案例。
3.业务模块间耦合较高，需要进一步降低耦合，增强独立性。
在这里得给大家提个醒：千万别把微服务当成一种时髦的追求，更不能盲目跟风。适合自己的才是最好的，我们要做的是利用已有架构去解决实际问题。
总之，是否要进行微服务改造并不是一个非黑即白的问题。在评估和决策时，请务必结合自身情况来权衡利弊。
分布式架构是否一定要完成云原生改造 分布式架构是否一定要完成云原生改造？来，小伙伴们一起探讨一下这个问题！
首先，得了解一下分布式架构和云原生是什么。分布式架构指的是把应用程序划分成多个独立的部分，并将它们部署到不同的服务器上。而云原生呢，就是从一开始就为在云上运行而设计的应用程序。
但这两者到底有啥关系呢？今天我们就来揭晓答案！
首先来看，为什么我们需要分布式架构？有以下几个优点：
1. 可扩展性：能够轻松地扩展应用程序的功能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/429074185495781a307852a07952f75d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a4a07cd03c18391553d18c093f47ef8/" rel="bookmark">
			【设计模式之美】SOLID 原则之三：里式替换（LSP）跟多态有何区别？如何理解LSP中子类遵守父类的约定
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一. 如何理解“里式替换原则”？二. 哪些代码明显违背了 LSP？三. 回顾 一. 如何理解“里式替换原则”？ 子类对象能够替换程序中父类对象出现的任何地方，并且保证原来程序的逻辑行为不变及正确性不被破坏。
里氏替换原则例子如下：
//&gt;1. 父类 Transporter 使用 HttpClient 来传输网络数据。 //&gt;2. 子类 SecurityTransporter 继承父类 Transporter，增加了额外的功能， //支持传输 appId 和 appToken 安全认证信息。 public class Transporter { private HttpClient httpClient; public Transporter(HttpClient httpClient) { this.httpClient = httpClient; } public Response sendRequest(Request request) { // ...use httpClient to send request } } public class SecurityTransporter extends Transporter { private String appId; private String appToken; public SecurityTransporter(HttpClient httpClient, String appId, String appToken) { super(httpClient); this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a4a07cd03c18391553d18c093f47ef8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bf582dee828d93d1e95719c57ea591e/" rel="bookmark">
			Yum（Yellowdog Updater Modified）命令大全详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Yum（Yellowdog Updater Modified）是一个在基于RPM的Linux发行版上常用的包管理工具，主要用于自动安装、自动删除、自动升级软件包。下面列出了一些常见的Yum命令以及它们的解释：
安装软件包：
yum install packageName
这个命令会从默认的存储库中下载并安装指定的软件包。
2. 更新软件包：
yum update packageName
这个命令会更新已安装的指定软件包到最新版本。
3. 移除软件包：
yum remove packageName
这个命令会从系统中删除指定的软件包。
4. 搜索软件包：
yum search packageName
这个命令会在存储库中搜索指定的软件包。
5. 显示已安装的软件包：
yum list installed | grep packageName
这个命令会列出所有已安装的软件包，并使用grep来过滤出包含指定关键字的软件包。
6. 显示可用的软件包：
yum list available | grep packageName
这个命令会列出所有可用的软件包，并使用grep来过滤出包含指定关键字的软件包。
7. 显示更新信息：
yum check-update
这个命令会显示所有可用的系统更新。
8. 清除缓存：
yum clean all
这个命令会清除Yum缓存，以便重新加载存储库数据。
9. 启用或禁用存储库：
启用存储库：yum-config-manager --enable repositoryName
禁用存储库：yum-config-manager --disable repositoryName
这些命令用于管理Yum存储库的启用或禁用状态。
设置默认存储库：
设置默认存储库：yum-config-manager --set-default repositoryName
这些命令用于设置默认的Yum存储库。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5bf582dee828d93d1e95719c57ea591e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7817a2ac494d1fa6bb6ab92aa8be97b8/" rel="bookmark">
			3dmax灯光缓存参数怎么设置？解析来了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		细分：用来决定灯光缓存的样本数量，样本数量以此数值的平方来计算。数值越高，效果越好，速度越慢。一般出图建议1000到1800之间已经足够了。
采样大小：用来控制灯光缓存的样本尺寸大小，较小的数值意味着较小的采样尺寸大小，意味着得到更多的细节，同时需要的样本（细分）也增加。
比例：确定样本的大小需要依靠什么单位，系统给了2种单位。
屏幕：依靠渲染图的尺寸来确定样本的大小，越靠近摄像机的样本越小（细节越多），越远离摄像机的样本越大（细节越少）。当渲染深远的场景时（走廊一类），不太适用，因为越远离摄像机的地方得到的样本会越大，那么会产生一些异常情况。
世界：根据3D的系统单位来定义采样的大小，跟摄像机的远近无关，例如：3D的单位是MM，样本的尺寸给的是10MM（采样大小），那么场景中所有的样本大小都会是10MM。渲染动画的时候常用。
折回：启用间接照明的近角折回，防止灯光泄露和闪烁问题，一般都是开启，数值2.0：0.0为禁止折回。2.0适合静止的图像，8.0适合动画。越高的值会计算更多的光线跟踪时间，同时获得更精确。
使用摄像机路径：动画使用
进程数：根据CPU的核数来定，例如4核就填写4.（VR2.4以前的版本才有）
显示计算相位：勾选后，在渲染中会显示灯光缓存的计算过程。用于在渲染初期观察灯光，方便出现问题提前取消。
预滤器：勾选后，可对灯光缓存样本进行提前过滤，主要用途是查找样本边界，然后对边界进行模糊处理。后方数值越高，模糊处理的程度越强。
使用光泽光线：勾选后，会提高场景中反射和折射模糊效果的渲染速度。
存储直接光：保存直接光照信息到灯光缓存中。场景中有很多灯的时候，勾选会提高渲染速度。
过滤器：在渲染最后成品图时，对样本进行过滤。系统给了3种模式。
最近：对样本的边界进行查找，然后对色彩进行均化处理，从而得到一个模糊的效果。
固定：采用距离的判断来对样本进行模糊处理。
插值采样：只有在勾选最近后才会出现，数值越高，模糊程度越强。
过滤大小：只有在勾选固定后才会出现，数值越大，表示模糊的半径越大，图的模糊程度也越强。
渲染：想要离线渲染批量、高效、高质量、高性价比的效果图，使用渲染100云渲染（注册填邀请码7788）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/431f5e31e02f213d264db913fb15da9b/" rel="bookmark">
			docker run 命令详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 Docker容器是一个开源的应用容器引擎，让开发者可以以统一的方式打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何安装了Docker引擎的服务器上（包括流行的Linux机器、Windows机器），也可以实现虚拟化。以下是Docker容器的特点：
沙箱机制：容器是完全使用沙箱机制，相互之间不会有任何接口（类似iPhone的app）。性能开销小：几乎没有性能开销，可以很容易地在机器和数据中心中运行。语言、框架、系统无关：最重要的是，容器不依赖于任何语言、框架包括系统。所以，需要通过设计和部署把这些服务拆分成为它们自己的容器。扩展性：如果一个应用程序能够被拆分成为越多的分布式组件，那么应用程序扩展的选择则越多。配置管理：企业用户可以把这些配置部署在容器中或使用环境变量。为了积极主动地关注基于容器的应用程序的运行状况，可考虑实施必要的监控和管理机制，确保打开日志记录功能。命令行工具和API：Docker提供了一个命令行工具Docker以及一整套RESTful API。架构：Docker采用C/S架构，Docker daemon作为服务端接受来自客户的请求，并处理这些请求（创建、运行、分发容器）。客户端和服务端既可以运行在一个机器上，也可通过socket或者RESTful API来进行通信 二、nginx docker run 命令详解 docker run -d \ --name nginx \ --net=host \ -v /home/docker/apps/nginx/www:/usr/share/nginx/html \ -v /home/docker/apps/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \ -v /home/docker/apps/nginx/logs:/var/log/nginx \ -v /home/docker/apps/nginx/conf.d:/etc/nginx/conf.d \ -v /home/docker/apps/nginx/cert:/etc/nginx/cert \ nginx -d: 在后台以守护进程模式运行容器。
--name nginx: 为容器指定一个名称，可以进行自定义名称。
-v /home/docker/apps/nginx/www:/usr/share/nginx/html \: 将主机上的 NGINX 配置文件目录挂载到容器中的usr/share/nginx/html目录，以便使用自定义的 NGINX 配置。
所以在nginx location中只需要指向容器的路径，实际访问的就是主机的路径，他们是个映射关系，或者说是个代理关系
如：配合的是 /usr/share/nginx/html/member-plat 实际主机上 /home/docker/apps/nginx/wwwmember-plat #静态资源 location /icon/ { root /usr/share/nginx/html/member-plat; try_files $uri $uri/ /index.html; } docker run --name eureka_docker -d -p 8861:8861 eureka_host
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/431f5e31e02f213d264db913fb15da9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89b586c72ebdad2aa141dd915491b6f0/" rel="bookmark">
			Shell脚本入门实战：探索自动化任务与实用场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 Shell脚本作为一种强大的自动化工具，在现代操作系统中具有广泛的应用。无论是简单的文件操作，还是复杂的系统管理，Shell脚本都能提供高效、快速的解决方案。在本文中，我们将探索Shell脚本的基础知识，并通过实战场景示例，一起深入了解Shell脚本编程。
1. Shell脚本入门 Shell是用户与操作系统内核之间的接口，而Shell脚本是一种将Shell命令组织起来，以实现特定功能的文本文件。将介绍Shell脚本的基本语法和结构。
1.1 基础语法 Shell脚本以 #!/bin/bash 开头，用来指定脚本解释器。接下来是一系列命令，可以使用变量、条件语句、循环等。
#!/bin/bash # 定义变量并输出 name="World" echo "Hello, $name!" 1.2 控制结构 Shell脚本支持if-else、for和while等控制结构，用于根据条件执行命令或控制循环。
#!/bin/bash # 使用if-else判断条件 age=25 if [ "$age" -ge 18 ]; then echo "You are an adult." else echo "You are a minor." fi 1.3 变量和输入 用Shell脚本获取用户输入的变量，对变量进行操作。
#!/bin/bash # 获取用户输入 echo "Enter your name: " read name # 输出变量内容 echo "Hello, $name! Welcome to Shell scripting." # 数值计算和变量操作 num1=10 num2=5 sum=$((num1 + num2)) echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89b586c72ebdad2aa141dd915491b6f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/627e95bd5c6193082b1744c94c1b18aa/" rel="bookmark">
			flutter中枚举的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		枚举支持成员属性、实现和定义方法，使用时需要注意的地方： 枚举的所有实例都必须在声明的开头声明，并且必须至少声明一个实例最后一个枚举元素以 ; 结尾，其余的枚举元素以 ,结尾。枚举的构造函数 一定要是 const 构造枚举中的三个属性：index、values和name 如下代码示例：推荐使用方式三 使用dart工具来运行代码，工具：https://dartpad.cn
//方式一：未支持扩展枚举时 enum InOutOrderStatusEnum { approval, completed, cancel, rejected; int get statusCode { switch (this) { case InOutOrderStatusEnum.approval: return 1; case InOutOrderStatusEnum.completed: return 2; case InOutOrderStatusEnum.cancel: return 3; case InOutOrderStatusEnum.rejected: return 4; } } String get statusName { switch (this) { case InOutOrderStatusEnum.approval: return "审批中"; case InOutOrderStatusEnum.completed: return "已完成"; case InOutOrderStatusEnum.cancel: return "已撤销"; case InOutOrderStatusEnum.rejected: return "已拒绝"; } } } //方式二：使用extension对方式一进行优化 enum InOutOrderStatusEnum1 { approval, completed, cancel, rejected, } extension InOutOrderStatusEnumExtension on InOutOrderStatusEnum1 { int get statusCode =&gt; index + 1; String get statusName =&gt; ["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/627e95bd5c6193082b1744c94c1b18aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9475d1c633b8d6573ebc2e9867acf65f/" rel="bookmark">
			基于Spring Boot&#43;Vue的课堂管理系统（前后端分离）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该项目完全免费 介绍 基于Spring Boot+Vue的课堂管理系统。前后端分离。包含教师授课管理、学生选退课、聊天室、签到、笔记管理模块等。
技术架构 SpringBoot
MyBatis
Redis
WebSocket
VueCLI
Axios
Element UI
项目特点： 1、后台使用MyBatis连接数据库，编写后台服务器的请求接口。
2、整合WebSocket技术，配置聊天端口，将消息信息封装为对象，实现用户发送信息实时转发功能。
3、使用Redis缓存学生签到记录，学生端签到更新缓存数据，并将数据实时发送至教师端。
4、前端使用Vue CLI创建运行在Node服务器中，使用Element UI对界面进行布局和设计。
5、使用Vue Router来配置路由，实现跳转笔记详情传参，引入Mavon-Editor来实现使用MarkDown的语法来编辑笔记。
6、引入Axios并且配置代理服务器解决跨域请求问题。
7、使用js-cookie来存储用户登录状态。
文件说明 springboot 为后端项目 vue 为前端项目
启动教程 导入sql文件。sql/course_selection.sql
启动后端项目。
启动redis服务。
启动前端项目, 再前端项目文件夹输入 npm run serve
浏览器输入http://localhost:8081/
账号密码见数据库用户表
模块说明 课程管理模块：教师可以添加、编辑、删除课程；学生可以选课、退课。
聊天室：登录的用户进入聊天室，可以查看在线用户列表，实时进行聊天。
签到：教师端可以选择课程发起签到生成一个签到码，学生端若选择了此课程，输入签到码后完成签到，更新状态信息至教师端。
笔记管理：用户可浏览公开的笔记，可MarkDown的语法添加和编辑笔记。
实现效果 主页
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6014655f9c68cc0c0caeb26924c74321/" rel="bookmark">
			MySQL表结构转换为ES索引Mapping
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 日常开发过程中肯定会存在MySQL表数据迁移至ES的情况，以canal为例，数据迁移时需要提前在ES中创建索引Mapping，但是如果碰到字段特别的表时，创建Mapping将是一件耗费心神的事情。为了解决这些重复工作，我使用Python编写了一个脚本，自动将MySQL中的表结构同步到ES中，本脚本只同步表结构，并不同步表数据，如需同步数据可以采用canal或者logstash等方式进行同步
脚本内容 如果不需要直接同步到es中，需要注释脚本最后一行，该脚本会将转换后的mapping信息打印到控制台中
import mysql.connector import requests import json # MySQL连接配置 mysql_config = { 'host': '127.0.0.1', 'port': '3306', 'user': 'root', 'password': '123456', 'database': 'test' } # Elasticsearch配置 es_host = '127.0.0.1' es_port = '9200' es_index = 'order1' # 新版本es不需求type字段 # es_type = '_doc' def fetch_mysql_table_fields(mysql_config): connection = mysql.connector.connect(**mysql_config) cursor = connection.cursor() # 获取MySQL表字段信息,指定需要转换得表名 cursor.execute(f"DESCRIBE {"`order`"}") fields = cursor.fetchall() cursor.close() connection.close() return fields def generate_es_mapping(fields): mapping = { "mappings": { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6014655f9c68cc0c0caeb26924c74321/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2b0dec1587782fe3ce148b03e2f7c83/" rel="bookmark">
			系分笔记数据库技术之数据库安全措施
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、概要2、数据库的保护措施3、数据库的故障4、备份和日志5、总结 1、概要 数据库设计是考试重点，常考和必考内容，本篇主要记录了知识点：数据库故障及解决、数据库安全保护措施和数据库备份及恢复。
2、数据库的保护措施 数据库安全措施，常见的如，连接数据库的时候需要用的账密，当然这只是措施之一，其他的措施还有审计、视图和权限等。
3、数据库的故障 数据库故障通常在代码层会进行捕获然后通过回滚程序恢复，当然故障不仅仅是代码层面还有系统层面和外存等。
4、备份和日志 对数据库数据进行备份，是对用户数据负责也是安全保障很重要的一环，通常备份措施中有，冷备份、热备份、全量备份、差量备份和增量备份。
5、总结 加强数据库数据的安全保障，是对用户的数据负责也是对系统负责，本篇笔记的内容学习了数据库安全的一些基本知识。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfbd7bb6f742cda04507e811bd3dd01b/" rel="bookmark">
			Grafana UI 入门使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近项目上需要使用Grafana来做chart，因为server不是我在搭建，所以就不介绍怎么搭建grafana server，而是谈下怎么在UI上具体操作使用了。
DOCs 首先呢，贴一下官网doc的连接，方便查询 Grafana open source documentation | Grafana documentation
初步使用 搭建好server之后，浏览器输入部署的ip和port然后登录之后就可以进入UI。
因为也才接触grafana不久，只能share一下初步使用的浅见。
配置datasource 它datasource定义就是相当于一个chart的数据来源，也可以多个datasource给一个chart提供数据，也可以作为dropdown list的数据来源，dropdown list可以在dashboard里面作为选择给chart传入参数的选择使用。
首先需要创建一个datasource
它这边支持很多datasource，db,elasticsearch,etc...都是支持的
因为我这边是call我们自己的Back-End的api，所以选择的就是json api
进入之后需要填写你call api的具体url，我这边只用了这三个。
1.api的url
2.需要打开，因为我们是https的，需要跳过认证
3.把jwt添加进headers里面，来保证请求不被我们自己的BE拦截。
最后一个是默认的请求条件，这个可以也可以不配，看你引用这个datasource的时候需不需要这个默认请求条件了。
都配置完了之后点击 save&amp;test 然后看是不是call的通
Dashboard 这里面你可以创建自己的panel然后进行布局，里面可以有很多chart按照你配置进行布局，页面上可以添加value input 来给你的chart传入参数，它还自带的date range来进行时间区域选择。（当然些时间和我这个dropdown list传入的值是我的BE的api写好可以接收的）
第一次进入dashboard的话需要新建一个dashboard
进入之后需要选择一个datasource，就是一开始创建的datasource，来为你的chart提供数据。
选择好datasource之后就可以进入编辑panel，首先可以看到红圈这里，默认会给你创建一个datasrouce，可以理解成一开始创建的datasource，现在是给你实现了一个datasource的实例，这个实例可以有单独不同的数据解析，参数，hearder，body，etc....，所以没有什么特殊配置的前提下，首先需要做的就是配置parm
我的BEapi需要3个传入参数，所以这边就需要配置3个，当然因为我是通过RequestParm取得的参数所以在parm tab进行配置的，如果你是post并且是通过body传递参数的，就需要在body tab进行配置了。
红圈左边的是参数名字，需要和api接收的名字相同，右边是数据来源，你可以直接hardcode你需要的值，方便测试，我这里写的是变量(${}这个框起来就表明是变量)，他们三个会从dashbaord的dropdown list，time range里面进行取值，date我还做了日期格式化，因为我后端是string接收的。
第一个变量${Application}是我自己定义的，这个名称是自己取的，之后会讲到怎么去创建。
${__form},${__to}这个是固定写法，表示从UI中提供的time range里面取值。
如果想除了这些还有其他什么写法的，具体的可以参考官方文档：Add and manage variables | Grafana documentation 然后是数据提取
一开始会默认给你一个datasource，截图里面我已经创建了4个了，最后一个test可以模拟最开始默认的datasource，应该什么都没有的，你可以先写一个$，然后打开右上角的table view，就可以看到这次query的data返回
如果有多个datasource可以点击这里切换查看不同的返回值
然后可以按照jsonpath/jsonnata的方式进行获取数据，这里[*]表示X Array中任意一个数据，这个是很必要的
如果不加，可以看到，提取出来的一个array，我一开始卡了很久就是这里，我想已经提取成array了，为什么放不进chart里面，后面才发现，他这里相当于指定的是一行的数据，所以某一行的数据不可能是array的，所以必须要加x.[*]来指定这一行的值是x这个array里面的某一行
如果你的数据还需要精细处理，就可以点击 1 里面的trasform data,进行更加具体的数据转换。
然后2可以看到是另一个datasource，其实和第一个datasource instance配置一模一样，只是数据提取的时候提取的是major的数据，这时候就可以直接点击4 这里就可以复制出一个一模一样的datasrouce instance，这时候就不用再去配置一次parm，只用修改filed提取json就可以了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfbd7bb6f742cda04507e811bd3dd01b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89e48589f7e6090c28003749ee0858be/" rel="bookmark">
			③使用Redis缓存，并增强数据一致性。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人简介：Java领域新星创作者；阿里云技术博主、星级博主、专家博主；正在Java学习的路上摸爬滚打，记录学习的过程~
个人主页：.29.的博客
学习社区：进去逛一逛~
使用Redis缓存，并增强数据一致性。 Redis缓存🚀为什么使用缓存？🚀如何添加Redis缓存？🚀缓存数据一致性问题（双写问题）🚀实现 缓存与数据库双写一致（此方式不能保证绝对一致） Redis缓存 🚀为什么使用缓存？ 缓存数据存储于代码中,而代码运行在内存中,内存的读写性能远高于磁盘,缓存可以大大降低用户访问并发量带来的服务器读写压力。
缓存的作用： 降低后端负载。提高读写效率，降低响应时间。 使用缓存的同时，也会增加代码复杂度和运营的成本。
缓存的成本： 数据一致性成本（双写问题）代码维护成本运维成本 缓存的使用案例：
缓存(Cache),就是数据交换的缓冲区,俗称的缓存就是缓冲区内的数据,一般从数据库中获取,存储于本地代码(例如:
// 例1:本地用于高并发 Static final ConcurrentHashMap&lt;K,V&gt; map = new ConcurrentHashMap&lt;&gt;(); //例2:用于redis等缓存 static final Cache&lt;K,V&gt; USER_CACHE = CacheBuilder.newBuilder().build(); //例3:本地缓存 Static final Map&lt;K,V&gt; map = new HashMap(); 由于其被Static修饰,所以随着类的加载而被加载到内存之中,作为本地缓存,由于其又被final修饰,所以其引用(例3:map)和对象(例3:new HashMap())之间的关系是固定的,不能改变,因此不用担心赋值(=)导致缓存失效;
🚀如何添加Redis缓存？ Redis缓存作用模型：
标准的操作方式就是查询数据库之前先查询缓存，如果缓存数据存在，则直接从缓存中返回，如果缓存数据不存在，再查询数据库，然后将数据存入redis。
为查询的数据添加缓存 业务逻辑：
@Resource private StringRedisTemplate stringRedisTemplate; // 根据id查询商铺信息 @Override public Result queryById(Long id) { // redis缓存的key String key = RedisConstants.CACHE_SHOP_KEY + id; //1. 从redis缓存中获取shop信息 String shopJSON = stringRedisTemplate.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89e48589f7e6090c28003749ee0858be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1621559487a2a853914d3a3c5e236b34/" rel="bookmark">
			Android 权限总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Android 权限总结权限分类API说明单次授权权限被撤消时基本使用简单封装第三方权限框架 Android 权限总结 权限分类 官网文档
普通权限：这类权限通常不会直接威胁到用户的隐私。如果你的应用列表中包含这类权限，需要在 AndroidManifest.xml 文件中定义，系统会自动授予权限，无需用户明确授予。如：android.permission.INTERNET 网络权限，android.permission.SET_WALLPAPER 壁纸权限。危险权限：这类权限可能会涉及到用户的隐私数据，或者可能会对用户的存储数据或操作产生影响。需要在 AndroidManifest.xml 文件中定义，同时必须通过权限请求对话框向用户请求这类权限。如：android.permission.READ_CONTACTS 允许应用读取用户的联系人数据，android.permission.WRITE_EXTERNAL_STORAGE 允许应用写入到外部存储。特殊权限：这类权限不属于正常和危险权限，它们有自己的处理方式。如：android.permission.REQUEST_INSTALL_PACKAGES 安装应用权限，android.permission.MANAGE_EXTERNAL_STORAGE Android11新增的文件管理权限。 危险权限：
API说明 targetSdkVersion&gt;=23: 这时就需要在代码中检查权限了，否则打开app去执行需要权限的操作会崩溃。如果关闭权限将会弹出提示框提示你开启权限。
ContextCompact#checkSelfPermission()：判断权限是否允许。ActivityCompat#requestPermissions()：申请权限。ActivityCompat#onRequestPermissionsResult()：权限结果回调。ActivityCompat#shouldShowRequestPermissonRationale：返回true，表示权限被拒绝过，可以再次申请；返回false，表示权限被拒绝并且不再询问，必须在设置中打开。 /** * 检查权限： * PackageManager.PERMISSION_GRANTED 权限已申请 * PackageManager.PERMISSION_DENIED 权限拒绝 */ if (ContextCompat.checkSelfPermission(this, Manifest.permission.CALL_PHONE) != PackageManager.PERMISSION_GRANTED ) { //申请权限： ActivityCompat.requestPermissions(this, arrayOf(Manifest.permission.CALL_PHONE), 1) } /** * 权限回调： * * @param requestCode Int ：请求码 * @param permissions Array&lt;out String&gt; ：申请的所有权限 * @param grantResults IntArray ：权限申请结果 */ override fun onRequestPermissionsResult( requestCode: Int, permissions: Array&lt;out String&gt;, grantResults: IntArray, ) { super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1621559487a2a853914d3a3c5e236b34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/944619a82e10f7a9bfab142e19826218/" rel="bookmark">
			【计算机毕业选题】2024年计算机Java SpringBoot 毕业设计题目推荐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面是自己多年经验总结的Java SpringBoot 计算机毕业设计题目，希望对大家有帮助。
基于SpringBoot诊所医疗服务系统实现
基于SpringBoot学生操行评分系统实现
基于SpringBoot就医管理系统设计与实现
基于SpringBoot的国漫推荐系统的设计与实现
基于SpringBoot网络选课系统设计与实现
基于SpringBoot摄影交流平台设计与实现
基于SpringBoot剧本杀系统设计与实现
基于SpringBoot食品商城系统设计与实现
基于SpringBoot超市管理系统设计与实现
基于SpringBootOA系统设计与实现
基于SpringBoot流浪动物管理系统设计与实现
基于SpringBoot在线订餐系统设计与实现
基于SpringBoot民宿管理系统设计与实现
基于SpringBoot高校考研交流平台
基于SpringBoot中小学教师教学培训管理系统
基于SpringBoot人口老龄化社区管理系统
基于SpringBoot高校宿舍管理系统
基于SpringBoot西岭雪山智慧景区管理系统
基于SpringBoot糖朵朵甜品商城设计和实现
基于SpringBoot保险业务管理与分析设计和实现
基于SpringBoot洗浴中心管理系统设计和实现
基于SpringBoot外卖订餐系统设计和实现
基于SpringBoot高校岗位招聘和分析设计和实现
基于SpringBoot医疗预约与诊断设计和实现
基于SpringBoot和微信小程序桃园李速修小程序设计和实现
基于SpringBoot月子中中心管理系统设计和实现
基于SpringBoot花园管理系统设计和实现
基于SpringBoot和小程序校园二手交易 设计和实现
基于SpringBoot癌症交流换成心理咨询平台设计和实现
基于SpringBoot校园研招网设计和实现
基于SpringBoot和微信小程序校园运动会设计和实现
基于SpringBoot校园兼职设计和实现
基于SpringBoot财务管理系统设计和实现
基于SpringBoot水电系统设计和实现
基于SpringBoot邻里中心果蔬超市网站设计和实现
基于SpringBoot的医疗用品销售系统设计和实现
基于SpringBoot东南社区智慧消防管理系统的设计
基于SpringBoot中小学教师教学培训管理系统设计与实现
基于SpringBoot游戏道具商城系统设计与实现
基于SpringBoot人民医院挂号付费系统设计与实现
基于SpringBoot鲜丰水果销售网站系统设计与实现
基于SpringBoot和微信小程序微信小程序共享雨伞设计和实现
基于SpringBoot旅游推荐系统设计和实现
基于SpringBoot高校办公室行政事务管理系统
基于SpringBoot投资组合管理系统
基于springboot的中药材进销存管理系统的设计与实现
基于Springboot医疗器械管理系统设计和实现
基于Springboot起点树艺术培训机构系统设计和实现
基于Springboot校园跑腿接单系统设计和实现
基于Springboot太原市人民医院挂号付费系统设计与实现
基于Springboot鲜丰水果销售网站系统设计与实现
基于Springboot和微信小程序郑大强上门做菜预定服务设计与实现
基于Springboot和微信小程序图书森林共享小程序小程序设计与实现
基于Springboot和微信小程序家庭旧物共享平台设计与实现
基于Springboot和微信小程序刷题平台设计和实现
基于SpringBoot高校二手物品闲置交易的设计和实现
基于Springboot和校园车辆管理系统的设计与实现
基于SpringBoot释放活力永葆青春篮球吧设计与实现
基于SpringBoot夕阳红养老院系统设计和实现
基于SpringBoot自习室预约管理系统设计和实现
基于SpringBoot疾病预防交流与数据可视化分析平台设计和实现
基于SpringBoot企业招聘网站设计与实现
基于SpringBoot水浒鉴赏平台实现
基于SpringBoot校园勤工俭学系统实现
本人毕设作品效果展示：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ddbe1d95a2db9f59e64c72db54d9270/" rel="bookmark">
			数据库有哪些新方向？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库的未来发展：从架构到类型，再到负载和AI的融合
随着技术的不断进步，数据库的发展方向也日益多样化。从数据库架构的角度来看，向云原生架构的演进是一个重要的趋势。这一方向已经催生了许多优秀的数据库产品，如GaiaDB、PolarDB和TiDB等。这些产品在云原生环境下提供了更好的性能和可扩展性，成为企业级用户的首选。
除了数据库架构的演进，从数据库类型方面来看，多模态数据库的发展也越来越受到关注。多模态数据库能够处理多种数据类型，包括结构化数据、半结构化数据和非结构化数据，为企业提供更全面的数据支持。
此外，从负载方面来看，HTAP混合负载的演进也成为了数据库发展的重要方向。HTAP混合负载能够同时支持在线事务处理和在线分析处理，为企业提供更高效、更智能的数据处理能力。
除了以上几个方向，数据库也随着云计算、AI技术的发展而产生了两个重要的发展方向。首先，AI方向的结合为数据库带来了更多的可能性。通过与AI技术的结合，数据库能够更好地支持向量计算，提高数据处理效率。同时，智能化的数据库运维工具也能够降低运维成本，提高数据库的可用性和可靠性。
其次，Serverless化也是数据库的一个重要发展方向。实现数据库的Serverless化可以使得企业无需关注服务器的运维和管理，只需关注业务逻辑即可。这不仅可以降低企业的运维成本，还可以提高企业的服务质量和效率。
综上所述，数据库的发展方向是多样化的，涵盖了架构、类型、负载和AI等多个方面。随着技术的不断进步，我们有理由相信，未来的数据库将会更加智能化、高效化和灵活化，为我们的生活和工作带来更多的便利和价值。
欢迎了解数据库
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2ebbef77ac44d7dce5d241fafe8788c/" rel="bookmark">
			为什么要使用云原生数据库？云原生数据库具体有哪些功能？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相比于托管型关系型数据库，云原生数据库极大地提高了MySQL数据库的上限能力，是云数据库划代的产品；云原生数据库最早的产品是AWS的 Aurora。AWS Aurora提出来的 The log is the database的理念，实现存储计算分离，把大量的日志操作放到后台异步处理，实现存储独立扩展，这就解决了MySQL数据库最大的一个痛点，单库的数据量不能太大。云原生数据库在存储层面实现了扩展的同时，又保留了计算层面的不变和兼容，从而基本实现了完全的兼容性。这种又兼容又能扩展的能力，受到了用户的极大欢迎。
百度的云原生数据库 GaiaDB在2020年推出，也是受 Aurora 的启发，同时百度的GaiaDB又具有自己独特的技术特点和架构。可以实现以下功能：
企业级高吞吐：支持十万级TPS、百万级QPS、100%兼容MySQL；
云原生能力：支持多租户，资源隔离，商业数据库1/10价格；
弹性扩展：计算存储分离、主从共享数据、支持500TB海量存储；
数据高可靠：RPO=0、秒级切换、5个9高可用性、11个9高可靠性。
典型适用场景：
高吞吐、大数据量处理：聚焦金融、电信等大量在线交易业务，商业级OLTP能力支撑银行核心系统高速事务，数据强一致无缝支持转账交易、账户查询、密码校验等业务；
高可用、业务弹性：聚焦广告、电商、手游等行业，平稳支撑热点产品抢购活动，轻松应对大促秒杀场景；
企业上云、迁移：聚焦行业+、互联网+等新兴业务，100%MySQL兼容降低业务上云的改造成本，快速构建云原生架构新业务系统。
欢迎大家了解 云原生数据库 GaiaDB
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6b3f67fd885a23197cdf2f1e2a4f2ef/" rel="bookmark">
			ERROR conda.core.link:_execute(502): An error occurred while installing package ‘https://mirrors.tun
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天运行一个代码需要升级python为3.8+版本，于是我执行了命令“conda install python= 3.8”，结果报下面错误：
重点如下：
ERROR conda.core.link:_execute(502): An error occurred while installing package 'https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge::setuptools-65.5.1-pyhd8ed1ab_0'. FileNotFoundError(2, '系统找不到指定的文件。', None, 2, None) Attempting to roll back. Rolling back transaction: done FileNotFoundError(2, '系统找不到指定的文件。', None, 2, None) 多方查找原因发现：setuptools是使用pip安装的！pip和conda的安装方式不同，而且conda的版本一般比较落后，pip安装后引起版本的问题，conda无法卸载。
于是：
# 卸载setuptools pip uninstall setuptools # 更新conda conda update --force conda # 使用conda安装setuptools conda install setuptools 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/767992433a01795622292a8fa98ba78e/" rel="bookmark">
			应对 DevOps 中的技术债务：创新与稳定性的微妙平衡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		技术性债务在DevOps到底意味着什么？从本质上讲，这是小的开发缺陷的积累，需要不断地返工。它可能由多种原因引起，例如快速交付新功能的压力，这可能会导致团队不得不牺牲代码的整洁和完善。但这些不完整的小代码，如经济上的债务一样，随着时间的推移会产生“利息”，在软件工程里就表现为修改的挑战或添加新功能的困难。
一、技术债务的原因 技术债务的主要原因之一是组织的开发方和业务方之间的脱节。开发团队经常会感到保持高特性速度的压力，有时会以适当的服务规划为代价。例如，不计划服务生命周期的结束可能会导致所谓的“老年服务”。这些服务可能做得不多，但对业务运营至关重要，并且可能在以后产生更多的技术债务。它们可能很难迁移，也可能是未知影子或僵尸API的产物。结果是，开发过程可能会被更高效的工作方式所阻碍，从而招致更多的技术债务。
二、技术债务的症状 没有严格的监控，技术债务可能会减缓整个开发和部署过程，降低产品质量，并限制组织在不断变化的市场中进行创新的能力。技术债务过多的一些迹象可能包括修复技术债务的成本和时间增加，每次发布和部署所需的时间持续增加，以及由于在遗留系统上工作和处理频繁故障带来的挫折，让员工的流动率更高。
三、什么情况下可以忽视技术债务？ 虽然技术债务的负面影响是真实存在的，但并不总是需要立即解决，而且这也并不现实。在一些情况下，让债务累积是有意义的。例如，如果解决技术债务的成本在当下大大高于将来，如果债务没有影响短期业务需求，或者有紧急版本发布（如重大安全漏洞修复程序）。在做出正确的权衡时，牢记全局至关重要，管理良好的技术债务是缩短交付周期的有效工具，可以优先考虑重要部署。
这里存在一个关键点：区分“好的”技术债务和“坏的”技术债的上下文。这种分离归结为理解对客户和团队的实际影响。忽略一些技术债务毕竟并没有那么糟糕，只要有有共同的上下文来指导自己的决策就好。
四、忽视技术债务成为挑战 当技术债务开始阻碍组织有效运作的能力时，忽视技术债务就成了问题。当这种情况发生时，就是需要解决技术债务的明显信号了。如果不加以解决，累积的技术债务可能导致经营业绩不佳和收入损失，从这个本质上来说，技术债务也成为了经济债务。产品和品牌的形象可能会受损，导致失去机会。
五、管理技术债务 管理技术债务需要采取积极主动的协作方法。以下是一些可能有所帮助的策略：
确定债务类型： 所有的技术债务不能等量齐观。区分目前尚可接受的债务和不适合积压的技术债务。分析和自动化： 分析债务的来源，并寻找方法来收紧工作流或自动化某些测试和流程。这有助于减少常见错误和隐藏的错误，防止它们滚雪球般地变成技术债务。制定新的规则和标准： 需要明确技术债务在什么情况是可以被接受的，什么情况会造成不可逆转的损失。例如，发布即时安全修补程序可能被认为是可以接受的，而允许最终导致相当长的停机时间的错误则不会被接受。沟通成本： 决策者和DevOps团队必须了解技术债务对产品质量和开发人员保留的影响。当另一个截止日期到来时，确保这些关键利益相关者意识到风险。如完全了解潜在成本，他们可能更可能调整交付日期或为其他开发商提供资金。 总之，技术债务如果得到有效管理，可以成为短期内优化交付速度和创新的工具。然而，重要的是要保持平衡，不要让它累积到开始降低产品质量、减缓开发速度或损害团队士气的程度。通过主动识别、分析、管理和沟通技术债务，开发运营团队可以在软件开发的这个具有挑战性的方面进行导航，并维护其基础设施的健康。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb2d2d2ab8dd8f32ebf9d3c0ea563df1/" rel="bookmark">
			C#的StringBuilder属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、StringBuilder构造器
二、StringBuilder属性
1.StringBuilder.Capacity 属性
2.StringBuilder.Chars[Int32] 属性
（1）定义
（2）实例
3.StringBuilder.Length 属性
（1）定义
（2）实例
4.StringBuilder.MaxCapacity 属性
三、StringBuilder方法
一、StringBuilder构造器 请详见本文作者的其他文章，C#用StringBuilder高效处理字符串-CSDN博客 https://wenchm.blog.csdn.net/article/details/135397349
二、StringBuilder属性 共有4种属性：Capacity、Chars[Int32]、Length和MaxCapacity。
1.StringBuilder.Capacity 属性 获取或设置可包含在当前实例所分配的内存中的最大字符数。
public int Capacity { get; set; } 属性值 Int32 可包含在当前实例所分配的内存中的最大字符数。 其值可以从 Length 到 MaxCapacity。 例外 ArgumentOutOfRangeException 为集运算指定的值小于此实例的当前长度。 或 - 为集运算指定的值大于最大容量。 Capacity 不影响当前实例的字符串值。 Capacity 可以减小，只要它不小于 Length 。
StringBuilder需要时动态分配更多的空间并相应增加Capacity。 出于性能原因， StringBuilder 可能会分配比所需内存更多的内存。 分配的内存量是特定于实现的。
实例见StringBuilder.Length 属性的实例。
2.StringBuilder.Chars[Int32] 属性 获取或设置此实例中指定字符位置处的字符。
（1）定义 public char this[int index] { get; set; } 参数 index Int32 字符的位置。 属性值 Char index 位置处的 Unicode 字符。 例外 ArgumentOutOfRangeException 设置字符时，index 在此实例的范围之外。 IndexOutOfRangeException 获取字符时，index 在此实例的范围之外。 参数 index 是 字符在 中 StringBuilder的位置。 字符串中的第一个字符位于索引 0。 字符串的长度是它包含的字符数。 实例的最后一个 StringBuilder 可访问字符位于索引 Length - 1。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb2d2d2ab8dd8f32ebf9d3c0ea563df1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aedd80f809231ff88463357f54ee89f4/" rel="bookmark">
			使用Python和YOLOv8开发视频游戏的目标检测和鼠标重新定位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		视频游戏已经走过了漫长的发展历程，从最初的谦卑起步到现在，先进的图形和游戏机制已经成为常态。现代游戏的一个显著发展方向是将人工智能和计算机视觉技术整合到游戏体验中。在本文中，我们将探讨如何使用Python和YOLOv8创建一个系统，结合目标检测和鼠标重新定位，以提升视频游戏的体验。
1 窗口捕获：用于捕获屏幕的Python库
首先，您需要捕获游戏窗口。Python提供了一些用于此任务的库，例如pyautogui、Pillow或mss。这些库使您能够实时捕获游戏的屏幕截图，从而使您的Python脚本能够分析游戏环境。
import mss sct = mss.mss() img = np.array(self.sct.grab({"top": 0, "left": 0, "width": 800, "height": 800})) img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB) 2 区域选择：关注关键区域
对于大多数视频游戏，不需要持续分析整个屏幕。相反，关注靠近玩家鼠标光标或瞄准镜的区域。这个小区域是所有动作发生的地方，通过这样做，您可以节省计算资源。
@dataclass class Monitor: top:int = 0 left:int = 0 width:int = 1920 height:int = 1080 @property def sizes(self): return {"top": self.top, "left": self.left, "width": self.width, "height": self.height} #Inside your main loop. In this case I decided to inspect a region of 320x320 centered in the center of the screen window_title = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aedd80f809231ff88463357f54ee89f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7a5ebf4709e0df787e64c525526f6d6/" rel="bookmark">
			Java版本spring cloud &#43; spring boot企业电子招投标系统源代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		招投标管理系统是一个集门户管理、立项管理、采购项目管理、采购公告管理、考核管理、报表管理、评审管理、企业管理、采购管理和系统管理于一体的综合性应用平台。它适用于招标代理、政府采购、企业采购和工程交易等业务的企业，旨在提高项目管理的效率和质量。该系统以项目为主线，从项目立项到项目归档，实现数据信息的实时共享、规范化管理和有效监控。它通过有效沟通、高效流转与协作，实现工作协同、数据集中化，减少出错率，提高招标工作效率。
功能描述
1、门户管理：所有用户可在门户页面查看所有的公告信息及相关的通知信息。主要板块包含：招标公告、非招标公告、系统通知、政策法规。
2、立项管理：企业用户可对需要采购的项目进行立项申请，并提交审批，查看所有的立项信息。主要功能包含：招标立项申请、非招标立项申请、采购立项管理。
3、采购项目管理：可对项目采购过程全流程管理，包含功能有：评审人员的选取/抽取、基准价维护、供应商缴费审核、投标过程记录查询、供应商报价维护、项目评审查询、线下项目管理、采购计划制定与维护。
4、采购公告管理：可对项目采购全过程所需发布的公告进行管理。主要功能包含：招标公告管理、变更公告管理、终止公告管理、中标候选人公告管理、中标公告管理、采购公告管理、采购结果公告管理、单一来源采购结果公告管理。
5、考核管理：对已完成招标采购项目的供应商和代理机构进行考核管理，主要功能包含：项目考核分派管理、项目考核查询、项目考核管理。
6、报表管理：以不同维度统计系统的项目信息、供应商信息、评审专家信息。主要功能包含：采购项目分析、评审人员情况分析、供应商情况分析、采购情况分析。
7、评审管理：对采购过程中所有需要评审的项目进行评审管理。
8、企业管理：供应商可维护企业基本信息，对企业发布的招标采购项目进行报名投标工作。主要功能包含：基本信息管理、项目管理、投诉建议管理。
9、采购管理：招标代理机构可查看项目基本信息，并根据业主方需求进行招标工作，发布招标等公告，主要内容包含：项目管理、公告管理。
10、系统管理：管理系统基础信息，包含系统使用的菜单、角色、用户、机构、数据字典信息。
11、基础数据管理：对支持系统使用过程中需要用到的基础数据维护及管理。主要功能包含：公告模板管理、评审人员管理、第三方机构管理、供应商管理、采购类别设置、评审模板管理、考核模板管理。
招投标管理系统-适合于招标代理、政府采购、企业采购、工程交易等业务的企业
招投标管理系统是一个用于内部业务项目管理的应用平台。以项目为主线，从项目立项，资格预审，标书编制审核，招标公告，项目开标，项目评标，项目公示，确定中标人，项目归档， 通过这个平台进行有效沟通、高效流转与协作。实现项目数据信息实时共享，规范化管理及有效监控，实现工作协同，工作网络化、数据集中化，减少出错率，提高招标工作效率。
招投标管理系统是一个功能强大的内部业务项目管理平台，旨在提高招标工作效率和质量。该系统以项目为主线，涵盖了从项目立项到项目归档的全过程，提供了丰富的功能模块，如门户管理、立项管理、采购项目管理、采购公告管理、考核管理、报表管理、评审管理、企业管理、采购管理和系统管理。这些模块不仅方便用户进行数据信息的实时共享和规范化管理，还实现了有效监控和工作协同，减少了出错率，提高了招标工作效率。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0815eeffe086d5dbca940106a77180fb/" rel="bookmark">
			帆软笔记-表格中自定义现实
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如下效果：
是否生效查询的时候为1和0，对应的字段是ENABLE，其中1为是，0为否。
在帆软中可以进行如下设置：
在高级，自定义显示中，使用公式，如果不知道公式语法，可以看右下角的公式说明。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5154135416a65652d16bf54f66ab9d35/" rel="bookmark">
			2024年MySQL学习指南（五），探索MySQL数据库，掌握未来数据管理趋势
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 17. 数据库设计17.1 概念17.2 表的关系 18. 多表查询18.1 内连接查询18.2 外连接查询18.3 子查询 19. 事务19.1 概念19.2 语法19.3 特征 20. 总结 17. 数据库设计 17.1 概念 数据库设计是软件研发过程中很重要的一个环节，在学习数据库设计之前，要先了解软件研发的步骤。
一个成熟的软件，从想法的产生到成功上线，要经历需求调研及分析，设计，编码，测试和部署等过程，在开始阶段产品经理会根据客户的需求设计产品原型，而设计一般有架构师和开发工程师完成，这其中就包括数据库设计，还有软件结构设计，接口设计等，接着就是由开发工程师来编写代码，由测试工程师来测试，接着就可以部署上线。
数据库设计就是根据业务系统的具体需求，结合我们所选用的 DBMS，为这个业务系统构造出最优的数据存储模型。通俗的说就是建立数据库中的表结构以及表与表之间的关联关系的过程，分析有哪些表，哪些字段等。
数据库设计分为以下几个步骤：
需求分析逻辑分析物理分析维护设计 17.2 表的关系 表和表之间的关系有一对一的关系，主要用于表的拆分，利于把常用数据和不常用数据分开存储，提高查询的效率。一对多或者多对一的关系，例如部门表和员工表的关系，多对多的关系，例如商品和订单的关系。
一对多的关系中，在表示多的一方建立外键，指向另一方的主键，示例：
-- 删除表 DROP TABLE IF EXISTS tb_emp; DROP TABLE IF EXISTS tb_dept; -- 部门表 CREATE TABLE tb_dept( id int primary key auto_increment, dep_name varchar(20), addr varchar(20) ); -- 员工表 CREATE TABLE tb_emp( id int primary key auto_increment, name varchar(20), age int, dep_id int, -- 添加外键 dep_id,关联 dept 表的id主键 CONSTRAINT fk_emp_dept FOREIGN KEY(dep_id) REFERENCES tb_dept(id) ); 查看两表结构模型：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5154135416a65652d16bf54f66ab9d35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09fd6fd18fa89f4de9b148cd77555500/" rel="bookmark">
			【C&#43;&#43;】C&#43;&#43;的类型转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、C语言中的类型转换 在 C 语言中，如果赋值运算符左右两侧类型不同，或者形参与实参类型不匹配，或者返回值类型与接收返回值类型不一致时，就需要发生类型转化。
C 语言中总共有两种形式的类型转换：隐式类型转换和显式类型转换。
隐式类型转化：编译器在编译阶段自动进行，能转就转，不能转就编译失败。显式类型转化：需要用户自己处理。 void Test () { int i = 1; // 隐式类型转换 double d = i; printf("%d, %.2f\n" , i, d); int* p = &amp;i; // 显示的强制类型转换 int address = (int) p; printf("%x, %d\n" , p, address); } 缺陷：转换的可视性比较差，所有的转换形式都是以一种相同形式书写，难以跟踪错误的转换。
二、为什么C++需要四种类型转换 C 风格的转换格式很简单，但是有不少缺点的：
隐式类型转化有些情况下可能会出问题：比如数据精度丢失。显式类型转换将所有情况混合在一起，代码不够清晰。 因此 C++ 提出了自己的类型转化风格，注意因为 C++ 要兼容 C 语言，所以 C++ 中还可以使用 C 语言的 转化风格。 三、C++强制类型转换 标准 C++ 为了加强类型转换的可视性，引入了四种命名的 强制类型转换操作符 ： static_castreinterpret_castconst_castdynamic_cast 1、static_cast static_cast 用于非多态类型的转换（静态转换），编译器隐式执行的任何类型转换都可用 static_cast，但它不能用于两个不相关的类型进行转换。 int main() { double d = 12.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09fd6fd18fa89f4de9b148cd77555500/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/774fde8516b1647efd90d43dbbfefce8/" rel="bookmark">
			SSM之集成activeMQ和Redis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SSM之集成activeMQ：https://blog.csdn.net/u010247166/article/details/89046259
SSM集成Redis：https://blog.csdn.net/weixin_47801020/article/details/130350694
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40a82633768ded003f1101b5665fd9b9/" rel="bookmark">
			【Linux】（Ubuntu）内核编译 &amp;&amp; 镜像制作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Ubuntu内核编译1.1 为什么自己编译内核1.2 Ubuntu 内核源码下载1.21 内核的作用1.22 Linux内核与ubuntu内核1.23 Ubuntu内核源码仓库 1.3 编译ubuntu内核1.31 看看系统的已有内核1.32 编译新的内核 二、镜像制作 一、Ubuntu内核编译 1.1 为什么自己编译内核 一个Linux发行版比如ubuntu、centos，有自己对应的内核，比如Ubuntu20.04的内核，这些Linux发行版的内核则又是以Linux内核为基础进行定制开发的。
通常说的“内核编译”，可以是编译Linux内核，也可以是编译定制化的Linux内核，比如ubuntu22.04的内核。无果我们使用的是ubuntu，那么最好编译ubuntu内核代码（已经定制化的Linux内核代码），而不是编译Linux内核代码，以免出现潜在的冲突。
一般来说，Linux发行版都有自己默认的Linux内核或者说“定制化的Linux内核”，它们已经优化地很好了。为什么我们还要自己去变编译一遍呢？
的确，对于大多数普通用户来说，直接使用操作系统默认提供的内核以及通过包管理器进行更新通常是最稳妥和方便的选择。默认提供的内核由发行版的维护者经过仔细测试和配置，确保与操作系统的其他组件兼容，同时也包含了一些针对安全性和稳定性的补丁。
内核编译的主要优势体现在一些特殊需求的场景，例如：
特定硬件或嵌入式系统： 在一些特殊的硬件平台或嵌入式系统中，可能需要根据具体硬件配置进行内核的定制和编译。功能和性能优化： 对于高度专业化或性能敏感的场景，你可能希望调整内核配置以满足特定需求，或者应用一些优化。最新功能和实验性特性： 如果你想尝试最新的 Linux 内核功能或实验性特性，而发行版的默认内核版本较老，那么编译新的内核版本可能是一个选择。 对于绝大多数桌面和服务器使用，使用发行版默认的内核，并通过包管理器进行更新，是保持系统稳定性和安全性的最佳方式。内核编译更多地适用于那些对系统定制有深入需求的用户，对内核有深入了解的开发者，或者一些专业领域的使用场景。
也就是说：编译内核是对已经定制化的Linux内核进行进一步地定制化，使得其在当前的硬件上得到最大的优化。 （比如ubuntu22.04这个系统，很多设备都可以安装，但他的内核配置并不一定能发挥你的硬件的最大性能）
通常，Linux内核的每个大版本都会进行维护和更新，比如5.4.0-xxx，那么Ubuntu（LTS版本）这些发行版的内核也会对应进行更新。我们常用的apt upgrade命令，就包括这一更新。注意这和编译内核的重构操作不同。ubuntu某一个版本，比如ubuntu22.04，只会对某一个Linux内核的大版本有最好的适配（见1.23节），你如果编译内核的时候，换了另一个大版本的内核源代码，则可能会有新的适配冲突。
内核编译，只是对当前操作系统的内核进行的定制化操作。如过要对内核进行定制化编译，还要默认安装一个开发环境，做一个操作系统镜像给别人安装，则还设计操作系统镜像制作的内容，见本文第二节。
1.2 Ubuntu 内核源码下载 1.21 内核的作用 操作系统内核是计算机系统中的核心，它负责管理系统的资源、提供各种服务，以及实现用户和硬件之间的通信。以下是内核的一些主要作用：
资源管理： 内核负责管理计算机系统的各种硬件资源，包括CPU、内存、硬盘、网络接口等。它通过调度算法来决定哪个进程（或任务）在某个时刻执行，以及如何分配和释放内存。进程管理： 内核负责创建、终止和调度进程。它管理进程的状态转换，分配资源，以及协调不同进程之间的通信和同步。文件系统管理： 内核提供文件系统接口，使得应用程序可以通过文件系统进行文件的读取、写入和管理。它还负责处理文件和目录的访问权限、文件锁定等问题。设备驱动程序： 内核包含设备驱动程序，用于与硬件设备进行通信。这些驱动程序允许操作系统与硬件之间进行有效的交互，包括输入输出设备、网络接口、磁盘驱动器等。系统调用接口： 内核提供了系统调用接口，允许应用程序通过一组标准化的接口与内核进行通信。这些接口包括对文件、进程、网络等的访问。内存管理： 内核负责管理系统的物理内存和虚拟内存。它通过分页机制、内存映射等方式来实现进程间的内存隔离和保护。中断处理： 内核负责处理硬件和软件产生的中断。硬件中断可以来自于设备的状态变化，而软件中断通常是由系统调用或异常引起的。内核需要适时地响应这些中断以确保系统正常运行。安全性和权限控制： 内核实施对系统资源的访问控制，确保只有经过授权的进程才能够执行敏感操作。这包括用户身份验证、访问权限检查等功能。 总体而言，内核是操作系统的核心，它为上层应用程序提供了一个抽象的接口，使得开发者可以专注于应用程序的逻辑而不用直接处理底层硬件和资源管理的细节。内核的设计和性能直接影响整个操作系统的稳定性和效率。
1.22 Linux内核与ubuntu内核 Linux 内核是整个操作系统的核心，Ubuntu 内核是为 Ubuntu 操作系统进行定制的 Linux 内核，而 Ubuntu 系统是包含了 Linux 内核和其他软件的完整操作系统。在使用 Ubuntu 操作系统时，你直接与 Ubuntu 系统进行交互，而 Ubuntu 系统的核心是 Ubuntu 内核，而 Ubuntu 内核的核心是 Linux 内核。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40a82633768ded003f1101b5665fd9b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72817028de0c0f4d46231d6c818172f4/" rel="bookmark">
			Docker Compose 基础知识(三)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker Compose 基础知识 什么是 Docker Compose ? Docker Compose 是 Docker 官方提供的一个工具，用于定义和管理多个 Docker 容器的应用程序。它基于 YAML 文件格式，允许你通过
一个定义文件来描述和配置整个应用程序的组件，包括容器、网络、存储卷等。
Docker Compose 基本概念 Compose 文件 ：Compose 文件是一个 YAML 格式的文本文件，用于定义应用程序的组件、配置和依赖关系。在 Compose 文件中，你可以指
定容器的镜像、端口映射、环境变量、网络设置等。
服务 (Services): Compose 文件中的每个容器被称为一个服务。服务定义了一个容器实例的配置和行为，并可以包含多个容器实例。每个服务
可以基于一个或多个镜像构建。
堆栈（Stack): Compose 文件中的一组服务被称为一个堆栈。堆栈是一个完整的应用程序，由多个相互关联的服务组成。
网络（Networks）: Compose 文件中可以定义自定义网络，用于连接堆栈中的服务。这样，堆栈内的服务可以相互通信，而堆栈之外的服务则无法访问。
存储卷（Volumes): Compose 文件中可以定义存储卷，用于容器之间共享数据。
命令行工具: Docker Compose 提供了一组命令行工具，用于构建、启动、停止和管理应用程序堆栈。你可以使用 docker-compose 命令来执行这些操作。
Docker Compose 工作原理： 是基于定义文件的描述和配置。通过运行 docker-compose up 命令，Compose 会解析 Compose 文件，并根据文件中的定义创
建和管理容器。Compose 会自动创建所需的网络、存储卷等资源，并将服务之间的相互依赖关系和通信配置好。
通过 Docker Compose，你可以轻松地管理多个容器组成的应用程序，并且可以通过一个简单的定义文件来描述整个应用程序的结构和配置。
Dockers Compose 学习示例 创建 Docker Compose 文件 docker-compose.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72817028de0c0f4d46231d6c818172f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5eb5bc814ff54062f0234fc888609cc7/" rel="bookmark">
			PIG框架学习2——资源服务器的配置详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 1、pig资源服务器的配置 Spring Security oauth2相关的依赖是在pigx-common-security模块中引入的，其他模块需要进行token鉴权的，需要在微服务中引入pigx-common-security模块的依赖，从而间接引入相关的Spring security oauth2依赖。
其最简单的一个目的，是对资源进行保护，对访问资源时携带的token进行鉴权。
微服务，开启资源服务器配置步骤：
①引入相关的依赖
&lt;!--安全模块--&gt; &lt;dependency&gt; &lt;groupId&gt;com.pig4cloud&lt;/groupId&gt; &lt;artifactId&gt;pig-common-security&lt;/artifactId&gt; &lt;version&gt;laster.version&lt;/version&gt; &lt;/dependency&gt; ②main方法开启@EnablePigResourceServer
pig4cloud对Spring Security OAuth2的资源服务器配置进行了封装，只需要一个注解即可完成相关的操作。
二、EnablePigxResourceServer解析 1、EnablePigxResourceServer的源码 /* 用于指示编译器将被注解的元素的注释信息包含在生成的文档中 使用该自定义注解的地方会在生成的文档中显示该注解的信息和说明 */ @Documented /* 用于指示一个自定义注解是否具有继承性 当使用@Inherited注解某个自定义注解时，如果一个类或接口使用了该被注解的自定义注解，那么其子类或实现类也会自动被应用该注解 */ @Inherited /* 用于限定自定义注解可以应用的目标元素类型 TYPE 类或接口; FIELD 字段（成员变量）; METHOD 方法;PARAMETER 方法参数; CONSTRUCTOR 构造函数;LOCAL_VARIABLE 局部变量; ANNOTATION_TYPE 注解类型;PACKAGE 包; TYPE_PARAMETER 类型参数;TYPE_USE 类型使用; */ @Target({ ElementType.TYPE }) /* 指定自定义注解的保留策略 SOURCE: 自定义注解仅在源代码中保留，编译后不包含 CLASS: 自定义注解在编译后的字节码文件中保留，但不会被加载到虚拟机中 RUNTIME: 自定义注解在运行时保留 */ @Retention(RetentionPolicy.RUNTIME) /* @Import注解主要用于将其他配置类导入到当前的配置类中，以实现配置的组合和复用，而不是用于创建Bean对象 */ @Import({ PigxResourceServerAutoConfiguration.class, PigxResourceServerConfiguration.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5eb5bc814ff54062f0234fc888609cc7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/091c69e05a64d45abf42841ae62a4661/" rel="bookmark">
			蓝桥杯付费视频更新进度通知
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		各位同学，目前蓝桥杯物联网的付费视频已经更新了所有的模块教程，接下来会更新省赛真题和国赛真题部分，请各位付费同学打开自己的视频软件观看对应的视频。
接下来的时间会更新真题部分，但是以什么样的形式或者是什么样的风格来录制视频大家可以自行的在本篇推文下进行留言。因为真题部分不像模块部分只需要实现某一个功能，真题部分是所有的模块或者是大部分的模块都在一个题目里面或者在一个项目里面。每个人的思路都是不一样的，大家可以讨论。
从下个星期开始就开始更新真题部分，另外需要现在购买蓝桥杯物联网付费视频或者是其他的付费项目的同学请扫描下方的二维码：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/191b7e30a410a7396601d87361e3acc4/" rel="bookmark">
			vim/vi 模式切换和常用快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vim/vi 切换模式：
vim/vi 常用快捷键：
一般模式：
gg：文件开头、G：文件结尾
shift+^ ：光标当前行首、shift+^：光标当前行尾
yy：复制、p：粘贴、dd：删除当前行、u：撤回
命令模式：
：/ 关键字：关键字查找、n下一处
：wq：保存并退出、：q：退出、：q！：强制退出
：set nu：显示行号、：set nonu：取消显示行号
（图源见原图最下方）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dd88544e1f3bacf25631e5171b6472b/" rel="bookmark">
			LDD学习笔记 -- Linux字符设备驱动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LDD学习笔记 -- Linux字符设备驱动 虚拟文件系统 VFS设备号相关Kernel APIs动态申请设备号动态创建设备文件内核空间和用户空间的数据交换系统调用方法readwritelseek 写一个伪字符设备驱动在主机上测试pcd(HOST)在目标板上测试pcd(TARGET) 字符驱动程序用于与Linux内核中的设备进行交互；
字符设备指的是像内存区域这样的硬件组件，通常称为伪设备；
用户空间应用程序通常使用open read write等系统调用与这些设备通信；
虚拟文件系统 VFS 把用户空间的系统调用连接到设备驱动的系统调用实现方法上。
内核的虚拟文件系统 virtual file system，在内核空间
设备驱动需要使用内核的API向虚拟文件系统注册
设备号 Major numbers（指示特定的驱动） + Minor numbers（表示指定的设备文件）
设备创建时候在VFS注册设备号，虚拟文件系统，将设备文件的设备号与驱动程序列表进行比较，选择正确的驱动程序，并将用户请求连接到对应驱动程序的文件操作方法。
相关Kernel APIs kernel functions and data structures（Creation）（Deletion）kernel header filealloc_chrdev_region()unregister_chrdev_region()include/linux/fs.hcdev_init() cdev_add()cdev_del()include/linux/cdev.hdevice_creat() class_creat()device_destory() class_destoryinclude/linux/device.hcopy_to_user() copy_from_user()include/linux/uaccess.hVFS structure definitionsinclude/linux/cdev.h 动态申请设备号 alloc_chrdev_region() 可以动态申请主设备号，保证唯一性，传输设备号（dev_t [u32]）地址和次设备号起始（一般0）和个数。
dev_t device_number; //32bit int minor_no = MINOR(device_number); //后20bit `kdev_t.h` int major_no = MAJOR(device_number); //前12bit MKDEV(int major, int minor); 动态创建设备文件 当收到uevent，udev根据uevent内存储的细节在dev目录下创建设备文件。
class_create ：在sysf中创建一个目录/sys/Class/&lt;your_class_name&gt;
device_create：在上面目录下使用设备名创建一个子目录/sys/Class/&lt;your_class_name&gt;/&lt;your_device_name&gt; /dev 这里的dev文件存储设备名主副设备号等
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5dd88544e1f3bacf25631e5171b6472b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cbd81770123b8fdf75c350cc2747823/" rel="bookmark">
			03 详细的Git命令使用大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常用命令：
git init：初始化一个新的Git仓库。git add &lt;文件名&gt;：将文件添加到暂存区，准备进行提交。git commit -m "备注"：提交暂存区的文件到仓库，并添加提交备注。git status：查看仓库的状态，显示文件差异。git diff：查看文件差异，比较工作区和暂存区的差异。git show &lt;commit_id&gt;：显示指定提交的详细信息。git log：显示提交历史记录。git reflow：自动将提交历史整理为规范的形式。git pull (--rebase)：从远程仓库拉取代码，并重新应用本地提交。git push (-u)：将本地提交推送到远程仓库，并设置远程仓库为默认推送目标。git branch：管理本地分支。git reset --hard：将仓库重置到指定的提交状态，丢弃所有本地修改。git cherry-pick：选择特定的提交应用到当前分支。git checkout：切换分支或检出文件到工作区。git help：查看Git帮助文档。 撤销修改：
撤销工作区修改：使用git checkout -- &lt;文件名&gt;命令撤销工作区的修改，将其还原到最后一次提交的状态。撤销暂存区修改：使用git reset HEAD &lt;文件名&gt;命令撤销暂存区的修改，将其还原到工作区的状态。撤销版本库修改：使用git revert &lt;commit_id&gt;命令撤销指定提交的修改，创建一个新的提交来抵消该提交的更改。 删除文件：
使用git rm &lt;文件名&gt;命令删除工作区的文件，并将其添加到暂存区。如果要永久删除文件，可以添加-f选项。 远程仓库：
git clone &lt;远程仓库地址&gt;：克隆远程仓库到本地。git remote add origin &lt;URL&gt;：添加一个远程仓库，将本地分支与远程分支关联起来。git pull：从远程仓库拉取代码到本地。git push：将本地提交推送到远程仓库。 分支管理：
git branch：列出、创建或删除分支。git checkout &lt;分支名&gt;：切换到指定分支。git merge：将指定分支合并到当前分支。git rebase：将当前分支的修改应用到其他分支上。 冲突解决与分支策略：
禁掉快进模式，解决冲突，处理合并中断等。在解决冲突后，使用git add将解决后的文件添加到暂存区，并使用git commit完成合并提交。
BUG分支与Feature分支：在Bug或Feature分支上进行开发，完成后合并到主分支上，并处理可能出现的冲突。使用git checkout -b &lt;分支名&gt;创建新分支，使用git merge &lt;分支名&gt;将分支合并到主分支上。
多人协作：在团队中共同开发时，使用Git进行协作可以提高效率和工作质量。通过共享仓库、推送和拉取代码、处理合并冲突等方式实现多人协作开发。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a09fdd7dc617eb29771f3d83b0eaf6c/" rel="bookmark">
			springBoot启动报错： No active profile set, falling back to 1 default profile: “default“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 我今天用mevan创建springboot，子项目引用了顶级项目的springBoot，但是没有自己指定wep，就报错了，加上就可以了：
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/149f75a6ec50c8b63de6c57bd5344d78/" rel="bookmark">
			【linux笔记】vim
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【linux笔记】vim 启动和退出 启动
vi 退出
q 强制退出
q！ 编辑模式 vi foo.txt 创建一个文件，启动后，是命令模式，是不能编辑的，键盘上的按键对应不同的命令。
插入模式 按键盘上的i，进入插入模式
保存内容 :w 移动光标 按键光标动作L右移一位H左移一位J下移一行K上移一行数字 0至本行开头^至本行第一个非空字符$至本行的末尾w至下一个单词或标点的开头W至下一个单词的开头，越过标点b至上一个单词或标点的开头B至上一个单词的开头，越过标点Ctrl-F或Page Down下一页Ctrl-B或Page UP上翻一页number-shift-g将光标移动到第n行G移动到文件最后一行 添加文本 A在文件末尾添加o在当前行的上方加入一行O在当前行的下方加入行 删除文本 u撤销操作（vi只可以撤销一步）x删除当前字符3x删除3个字符dd删除当前行5dd删除5行dW当前字符到下一个字符的起始d$当前字符到行的末尾d0当前字符到行的起始d^当前字符到第一个非空字符dG当前行到末尾d20G当前行到文件第20行 剪切、复制和粘贴文件 dd就是剪切操作
复制命令yy当前行5yy5行yW当前字符到下一个单词开始y$当前字符到行尾y0当前字符到行首y^当前字符到当前行的第一个非空字符yG当前行到文件结尾y20G当前行到第20行 p命令将复制的内容粘贴到当前行的下方，P命令将复制的内容粘贴到当前行的上方。
合并行 将光标所在行与下一行合并，J
行内搜索 f在行内进行搜索，并将光标移至搜索到的下一个指定字符。
搜索整个文件 “/”搜索单词，命令n去找下一个
全局搜索和替换 使用ex命令来执行几行之内或整个文件的搜索和替换操作。
:%s /Line/line/gc 组成含义:分号用于启动一条ex命令%确定了操作作用的范围。%代表从第一行到最后一行。还可以表示为1，5.。或者是1，$.从第一行到最后一行。如果不指定，知识适用于第一行。s指定了具体的操作，本次为替换操作/Line/line搜索和替换的文本g代指global，如果缺失，那么只替换每一行第一个c在每次替换前，向用户发出询问 加入c后出现
他们大的功能是
功能键行为y执行替换n跳过本次替换a执行此次替换和之后的所有替换q停止替换l执行此次替换后退出Ctrl-E，Ctrl-Y分别是向下滚动和向上滚动 编辑多个文件 vi file1 file2 file3 ... 切换文件 切换下一个文件
:n 切换上一个文件
:N 查看正在编辑的文件列表
:buffers 切换文件
:buffer 2 载入更多文件 :e ls-output.txt 插入整个文件 将光标移动到插入位置
:r foo.txt 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c5d35eb621b0a729d85020d20ee7087/" rel="bookmark">
			SpringBoot单例模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单例模式是一种设计模式，用于确保一个类只有一个实例，并提供一个全局访问点来获取该实例。
在单例模式中，类的构造函数被私有化，这样其他类就无法直接实例化该类。而是通过类内部的静态方法或者静态变量来获取类的唯一实例
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40615c9fd272a1d04058fa5635994505/" rel="bookmark">
			UNION 和 UNION ALL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 UNION 和 UNION ALL 都是 SQL 中用于将多个 SELECT 语句的结果合并成一个结果集的操作符。它们都适用于需要将多个表或查询结果合并在一起的情况。但是它们的行为略有不同。
区别 UNION 和 UNION ALL 的区别在于，UNION 会将结果集合并成一个不含重复行的结果集，而 UNION ALL 则会保留所有的行，包括重复的行。
因为 UNION 需要去重，所以它需要对结果集进行排序和去重的操作，因此比 UNION ALL 操作要慢，并且消耗更多的系统资源。
使用方法 UNION UNION 的基本语法如下：
SELECT column1, column2, ... FROM table1
UNION
SELECT column1, column2, ... FROM table2;
这个语句会返回从 table1 和 table2 中检索的唯一行。注意，两个查询的列数必须相同，并且对应列的数据类型也必须相同。
如果希望在结果集中保留重复的行，需要使用 UNION ALL。
UNION ALL UNION ALL 的基本语法如下：
SELECT column1, column2, ... FROM table1
UNION ALL
SELECT column1, column2, ... FROM table2;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40615c9fd272a1d04058fa5635994505/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/056a2a96754ae5ac03f80a72270c5d49/" rel="bookmark">
			答案很详细的MyBatis面试题（含示例代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MyBatis 是一个流行的持久层框架，它提供了一个灵活且高效的方式来访问关系型数据库。其中一个重要的特性是缓存机制，它可以帮助提升数据库查询的性能。
MyBatis 的缓存分为一级缓存和二级缓存两种：
一级缓存：默认情况下，MyBatis 开启了一级缓存。一级缓存是指在同一个 SqlSession 中，执行相同的 SQL 语句，返回的结果会被缓存起来，下次再执行相同的 SQL 语句时，直接从缓存中获取结果，而不需要再去数据库查询。一级缓存的范围是 SqlSession 级别的，也就是在同一个 SqlSession 中，多次执行相同的 SQL 语句只会查询数据库一次。二级缓存：二级缓存是指在不同的 SqlSession 之间共享缓存。通过配置开启二级缓存后，当一个 SqlSession 执行查询时，查询的结果会被保存到共享的缓存中，其他的 SqlSession 在执行相同的查询时，可以直接从缓存中获取结果，而不需要再去查询数据库。二级缓存的范围是 Mapper 级别的，默认情况下是关闭的，需要手动进行配置开启。 需要注意的是，一级缓存是默认开启的，并且无法关闭，而二级缓存是需要手动进行配置开启的。
使用 MyBatis 缓存机制需要注意以下几点：
对于频繁更新和变动的数据，不适合使用缓存。对于数据的一致性要求比较高的场景，不适合使用缓存。如果配置了二级缓存，需要确保缓存的数据不会影响到其他业务模块的数据。在使用缓存时，需要注意缓存的命中率和缓存的过期策略，避免缓存过期导致查询性能下降。 目录
一、什么是MyBatis？
二、MyBatis的优点有什么？
三、MyBatis的缺点有什么？
四、MyBatis框架适用场景有？
五、MyBatis与Hibernate有哪些不同？
六、MyBatis中${}与#{}的区别
七、MyBatis是如何进行分页的？分布插件的原理是什么？
八、Mybatis 是如何将sql 执行结果封装为目标对象并返回的？都有哪些映射形式？
九、Mybatis的编程步骤是什么样的?
十、MyBatis是如何解决jdbc的不足?
十一、使用Mybatis的mapper接又调用时候有哪些要求?
十二、SQLMapConfig.xml中配置有哪些内容?
十三、Mybatis的Mapper编写有几种方式?
十四、Mybatis动态SQL？
十五、Mybatis常用的注解有哪些？
十六、Mybatis的表关联的映射有哪些？
十七、Mybatis如何与Spring整合？
十八、MyBatis中实体类属性名与表字段名不一致如何处理？
十九、MyBatis中Mapper接口的工作原理
二十、Mybatis如何获取自动生成的主键值？
二十一、MyBatis中Mapper接口的方法能否重载？
二十二、MyBatis分页插件的原理？
二十三、MyBatis如何执行批量插入？
二十四、MyBatis中如何传递多个参数
二十五、MyBatis实现一对一有几种方式?具体怎么操作的？
二十六、MyBatis实现一对多有几种方式?具体怎么操作的？
二十七、MyBatis延迟加载实现原理
二十八、MyBatis接口绑定有几种实现方式
二十九、MyBatis的动态SQL标签有哪些
三十、Mybatis都有哪些Executor执行器? 如何指定使用哪 一种Executor 执行器?
一、什么是MyBatis？ MyBatis是一种优秀的持久层框架，它是一个轻量级的、优化的、功能强大的Java持久层框架，它的设计理念是贴近SQL、便于使用、高效并且功能丰富。通过MyBatis的使用，开发者能够更加专注于业务逻辑的实现，而不用过多关注底层的数据库操作。MyBatis通过XML或注解的方式配置SQL映射文件，并将Java的POJO（Plain Old Java Object，普通的Java对象）与数据库中的记录进行映射，使得开发人员能够以面向对象的方式来操作数据库，同时兼顾了SQL的灵活性和效率。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/056a2a96754ae5ac03f80a72270c5d49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41f9d0775d486cde73aa52465ddcadb1/" rel="bookmark">
			【c&#43;&#43;】map
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.创建map对象2.使用下标访问map对象3.map::insert的使用4.查找5.删除6.遍历 1.创建map对象 对象操作功能map&lt;k, v&gt; m;创建一个名为m的空map对象，键类型为k, 值类型为v。map&lt;k, v&gt; m(m2)创建m2的副本map&lt;k, v&gt; m(b, e)创建map类型的对象m,b为存储迭代器，e为标记范围 2.使用下标访问map对象 m[key] = value;
3.map::insert的使用 对象操作功能m.insert(e)e是用在m上的value_type类型m.insert(beg, end)beg和end是标记元素范围的迭代器m.insert(iter, e)e是一个用在m上的value_type类型的值。 m,insert(make_pair("001 ", “ming”))
m.insert(map&lt;k, v&gt; :: value_type("001 ", “ming”))
4.查找 查找操作功能m.count(k)返回m中k出现的次数m.find(k)存在返回该元素对应的迭代器，否则返回超出末端迭代器。 5.删除 删除操作功能m.erase(k)删除m中键为k的元素,返回size_type类型的值，表示删除的元素个数。m.erase ( p )删除迭代器p所指向的元素，返回void类型。m.erase(b, e)返回void类型。 6.遍历 map&lt;k, v&gt;::const_iterator map_it = m.begin();
while(map_it != m.end())
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0de5f09d94d9b179498d8c3a8f0a2962/" rel="bookmark">
			windows安装nvm以及nvm常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.什么是nvm以及为啥要用nvm
1.什么是nvm
2.为什么要用nvm
2.安装nvm
1. 下载
2. 安装
1.双击解压后的文件,nvm-setup.exe
2.同意
3.安装路径
4.下一步，这里有建议改成自己的文件夹，这个是用来存储通过nvm切换node后版本的存储路径
5.安装完成
6.检查环境变量
​7.查看版本号
3.使用nvm
1.nvm list 命令 - 显示版本列表
2.nvm install 命令 - 安装指定版本nodejs
​编辑
3.nvm use 命令 - 使用指定版本node 4.nvm uninstall 命令 - 卸载指定版本 node
5.查看nvm版本 1.什么是nvm以及为啥要用nvm 1.什么是nvm node version manager（node版本管理工具）
2.为什么要用nvm 我们做不同的项目时，因为项目的环境，版本等因素，导致项目要使用不同版本node.js，我们就可以通过nvm来切换nodejs的版本，而不需要下载/卸载不同版本的nodejs来满足当前项目的要求,当然了，你如果一直使用一个版本的node.js，那的确可以不用，nvm就是用来帮助我们管理多个版本的node.js,通过将多个node 版本安装在指定路径，然后通过 nvm 命令切换时，就会切换我们环境变量中 node 命令指定的实际执行的软件路径。
2.安装nvm 1. 下载 https://github.com/coreybutler/nvm-windows/releases
可下载以下版本：
nvm-noinstall.zip：绿色免安装版，但使用时需要进行配置。
nvm-setup.zip：安装版，推荐使用
2. 安装 1.双击解压后的文件,nvm-setup.exe 2.同意 3.安装路径 这里要注意:尽量不要用默认路径C:\Program Files\nvm,后面可能会报错，
问题的原因是Program Files 这个文件名中含有空格，所以大家在选择路径的时候，文件夹名尽量避免中文和空格
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0de5f09d94d9b179498d8c3a8f0a2962/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a90a08f95869f01aababc9cccbac624/" rel="bookmark">
			OpenVPN SSL/TLS方式连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 前言 本文介绍OpenVPN最后一种连接方式，通过SSL/TLS认证方式连接，也就是利用公钥密码那套：首先生成根证书秘钥、利用根证书秘钥创建根证书、生成服务器私钥，利用根证书签发服务器证书，生成Diffie-Hellman文件（用于密钥交换）、生成客户端私钥，利用根证书签发客户端证书。
注意：OpenVPN的服务器和客户端都拥有自己的私钥和公钥，服务器和客户端是通过验证对方的证书来确定对方的合法性，所以，这里服务器的证书和客户端的证书都是由同一个根证书签发的。
本文仍然以服务器和单个客户端的方式来介绍OpenVPN的SSL/TLS的连接方式。
二. 私钥和证书文件创建 本文以openssl命令来创建所有的文件。建议新建一个文件路径，在这个目录中生成所有文件。
1. 创建根证书私钥文件 openssl genpkey -algorithm RSA -out ca.key -aes256 该命令生成一个根证书的私钥文件，该私钥用aes256对称加密算法加密。
2. 利用私钥创建根证书 openssl req -x509 -new -nodes -key ca.key -sha256 -days 3650 -out ca.crt 该命令生成根证书文件ca.crt。证书利用sha256哈希处理，证书有效期为10年。
3. 创建服务器私钥文件 openssl genpkey -algorithm RSA -out server.key -aes256 该命令会生成服务器的私钥文件，其中包含服务器的私钥
4. 创建服务器证书签名请求文件 openssl req -new -key server.key -out server.csr 该命令用于生成服务器向根证书请求证书的请求文件，输完会有如下提示，按照要求填写即可：
# openssl req -new -key server.key -out server.csr You are about to be asked to enter information that will be incorporated into your certificate request.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a90a08f95869f01aababc9cccbac624/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71187d6c0319f06b65b396eac291a7f3/" rel="bookmark">
			存储数据保护技术——HyperClone克隆与HyperMirror卷镜像技术介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
HyperClone克隆
基本概念
克隆的特点
工作原理
注意事项
HyperMirror卷镜像
HyperClone克隆 基本概念 克隆是在不中断主机业务的情况下，对源数据在某个时间点的一致性数据副本，数据同完成后成为完整的数据副本
可以用于数据的备份与恢复
克隆的特点 瞬间生成
存储系统可以在几秒钟内生成一个克隆，获取源数据的一致性副本
创建后的克隆支持立即读写，支持重删压缩属性
在线分裂
支持在不中断业务的场景下进行克隆分裂
分裂读写不影响源LUN的IO处理
工作原理 正向同步：全量同步、增量同步
全量同步：首次同步时，进行全量拷贝
增量同步：首次同步之后再次同步，进行差异拷贝
分裂
同步完成后，用户可以在某一时刻分裂Pair，此时从LUN便成为了主LUN的一份可用副本，该副本封存了分裂时刻主LUN的所有数据。
分裂后，从LUN可以提供给主机读写，使主机可以读写和分裂时刻主LUN相同的数据，且主机对从LUN读写不会影响主LUN性能。
分裂后可将从LUN和主LUN再次同步或者反向同步。
反向同步：全量同步、增量同步（同上）
注意事项 一个主LUN最多可以选择8个从LUN，创建8个克隆LUN
注意：从LUN和主LUN所归属的控制器要相同
其它特性与克隆特性配合的约束
HyperMirror卷镜像 一种冗余技术，可以为一个LUN创建多个镜像物理副本，对LUN提供持续的冗余备份保护，从而提高单个LUN的可靠性和可用性
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e1ab4c0a86ad0a05efd61956c5a76bb/" rel="bookmark">
			机器学习简单概念和pytorch代码-2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		机器学习简单概念和pytorch代码-2 学习率的选择和调校
特征工程 特征工程是数据预处理和分析过程中的一个关键步骤，主要用于机器学习和数据挖掘。它涉及到从原始数据中选择、修改和创建新的特征（即数据的属性或变量），以便提高模型的性能。在机器学习中，特征工程对于提高模型的准确性和效率至关重要。它包括以下几个主要步骤：
特征选择：从现有的特征集中选择最重要的特征，以减少维度并提高模型的效率。
特征提取：将原始数据转换为能够更好地表示问题的特征。这通常涉及到提取信息或减少维度，例如通过主成分分析（PCA）。
特征构造：基于现有数据创造新的特征，以揭示数据中的潜在模式或关系。
特征转换：对特征进行标准化、归一化或其他转换，使模型更容易处理。例如，将所有特征缩放到相同的范围。
特征编码：将非数值特征转换为数值格式，如将分类数据转换为独热编码（One-Hot Encoding）。
特征工程的主要目的是通过这些技术改进模型的性能，使其能够更有效地学习、理解和预测数据。在许多机器学习任务中，好的特征工程往往比选择高级模型更为重要。
多项式回归 import torch import torch.nn as nn import torch.optim as optim import numpy as np import matplotlib.pyplot as plt # 检查CUDA是否可用，并设置device变量 device = torch.device("cuda" if torch.cuda.is_available() else "cpu") print(torch.cuda.is_available()) # 创建数据集 x = torch.linspace(-3, 3, 100).unsqueeze(1).to(device) # x data (tensor), shape=(100, 1) y = 1 + 2 * x + 3 * x ** 2 + torch.randn(x.size()).to(device) * 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e1ab4c0a86ad0a05efd61956c5a76bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a397992aefe2697aeb3f22f7bddd934/" rel="bookmark">
			ALiBi线性偏置注意力
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、目录 1.公式
2.实现
二、实现 1.公式
m 的取值公式：2^(-8/n) n为head 头数
参考：https://zhuanlan.zhihu.com/p/632780188
2. 实现
github: https://github.com/ofirpress/attention_with_linear_biases/blob/master/fairseq/models/transformer.py#L941
import math import torch class TransformerDecoder(): def __init__( self, args): self.args=args self._future_mask = torch.empty(0) #求坡度m def get_slopes(n): def get_slopes_power_of_2(n): start = (2 ** (-2 ** -(math.log2(n) - 3))) ratio = start return [start * ratio ** i for i in range(n)] if math.log2(n).is_integer(): return get_slopes_power_of_2( n) # In the paper, we only train models that have 2^a heads for some a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a397992aefe2697aeb3f22f7bddd934/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2feeabaaddb9c33ad20ac62ae43399f/" rel="bookmark">
			PyTorch|view()，改变张量维度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在构建自己的网络时，了解数据经过每个层后的形状变化是必须的，否则，网络大概率会出现问题。PyToch张量有一个方法，叫做view(),使用这个方法，我们可以很容易的对张量的形状进行改变，从而符合网络的输入要求。
view（）的基本用法很简单，只需传入想要的形状即可，
就像这样：
import torchT1=torch.arange(0,16)print(T1)print(T1.size()) tensor([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])torch.Size([16]) a=T1.view(4,4)b=T1.view(2,8)print(a)print(a.size()) print(b)print(b.size()) tensor([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15]])torch.Size([4, 4]) tensor([[ 0, 1, 2, 3, 4, 5, 6, 7], [ 8, 9, 10, 11, 12, 13, 14, 15]])torch.Size([2, 8]) 当然，在看一些代码时，往往会发现view()中有参数-1。看下面几个例子​​​​​​​
c=T1.view(-1,4,4)print(c)print(c.size())tensor([[[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15]]])torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2feeabaaddb9c33ad20ac62ae43399f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/044128692bc5cc3497f60553c815ff8b/" rel="bookmark">
			memory监控方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java: (adb shell dumpsys meminfo x)堆内存用于存储对象实例和静态变量
Native: Code: 加载app代码用到的内存：比如class对象，读取so，apk，dex文件时用到的mmap文件
Stack: stack内存存放了栈帧（用于存储局部变量、操作数以及返回地址），每个方法调用都会创建一个栈，stack内存是虚拟机进程独有的
GPU显存（dmabuffer） adb shell dumpsys meminfo 可以获取系统全部显存内存占用大小
adb shell dumpsys meminfo pid --&gt; Graphics: 部分也可以获取到进程的显存占用
gpu显存的详细占用存放在如下文件中：/sys/kernel/debug/dma_buf/bufinfo
自动化shell脚本已上传附件
以上命令可查到进程memory占用大小，但查不到进程memory详细分布
发现内存高，内存泄露时如何抓取memory详细数据 Java: 抓hprof文件，自动化抓取脚本已上传附件（hprof文件分析方法后续文章有详细介绍）
Native: 抓native内存 推荐采用perfetto和raphael，都是开源的，都能抓到申请native内存的泄露栈，
perfetto适合抓取60s以内没有释放的native内存，raphael可以抓到长时间内存泄露栈（但准确性不好，一些复杂的app有crash，以及释放内存不准确的bug）
自动化抓取脚本已上传附件（raphael和perfetto memory文件分析方法后续文章有详细介绍）
Java,Native内存泄露的分析放在下一篇文章详细介绍，敬请期待
感谢您抽出宝贵时间读完本文，希望您有收获，能不能动动小手指给完❤再走？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8bd21b43b4fb7ebfee19ca51cea560e/" rel="bookmark">
			关于解决Vue.config.productionTip=false浏览器控制台的提示没消失问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接看图吧~
其实这个你打开控制台的时候刷新一次就没有了，如果你要纠结这个问题，主要原因还是加载的先后顺序的问题！看个人习惯吧！
解决办法：
1.打开控制台的时候刷新一次
让你写的Vue.config.productionTip=false覆盖掉你引入的，然后页面重新加载就不会有 提示了
2.直接在引入的Vue.js里面改Vue.config.productionTip=false（永久解决）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15e4dfa45ad51ee30e7dedc0a74470b1/" rel="bookmark">
			【C&#43;&#43;学习笔记】C&#43;&#43;多值返回写法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++不像python可以轻易地处理多值返回问题，处理使用指针或者引用将需要返回的值通过参数带出来，还有几种特殊的方式。
引用自：https://mp.weixin.qq.com/s/VEvUxpcJPsxT9kL7-zLTxg
1. Tuple+ tie 通过使用std::tie，我们可以将tuple中的元素解包到不同的变量中。
std::tie 通常用于创建元组或者用于解构元组。主要用途有两个：将多个变量绑定到一个元组，或者从元组中解构多个值。
将多个变量绑定到一个元组 #include &lt;tuple&gt; #include &lt;iostream&gt; int main() { int a = 1; double b = 2.5; char c = 'A'; // 使用 std::tie 将多个变量绑定到一个元组 auto myTuple = std::tie(a, b, c); // 修改变量的值，元组中的值也会相应修改 a = 10; b = 20.5; c = 'Z'; // 打印元组的值 std::cout &lt;&lt; "Tuple values: " &lt;&lt; std::get&lt;0&gt;(myTuple) &lt;&lt; ", " &lt;&lt; std::get&lt;1&gt;(myTuple) &lt;&lt; ", " &lt;&lt; std::get&lt;2&gt;(myTuple) &lt;&lt; std::endl; return 0; } 从元组中解构多个值 #include &lt;tuple&gt; #include &lt;iostream&gt; int main() { std::tuple&lt;int, double, std::string&gt; myTuple = std::make_tuple(42, 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15e4dfa45ad51ee30e7dedc0a74470b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a429709550a254787fbe5a348b55147e/" rel="bookmark">
			关于WebStorm编辑代码过程中输入右花括号会出现2个的情况解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个问题，具体我没有去深入了解是不是软件BUG，看上去像是个BUG，因为输入其他括号都不存在这个问题，就花括号会这样，比如（）【】[]这些都不会出现这种问题。
解决办法：
咋们点开设置，直接看图吧，直观一些，按图示操作即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e01b80eaa3b43f96d60323ae5fc2dfaa/" rel="bookmark">
			CAN通信（报文测试）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：对安全模块的程序进行修改，将18串采样温度改成32串采样温度，相应can通信的帧数存在一定的变化，利用广成科技CANtest上位机软件或者内部上位机观察报文发送和接收情况。
1、内部上位机 内部上位机，设置相应的波特率，打开相应的端口，不断地上传报文。
2、CANtest上位机 用CANtest软件，设置相应的波特率，打开相应的端口，并没有报文进行上传，由于需要对bms安全板发送数据帧，才会回复相应的数据帧。
can初始化过程中，并没有使能发送数据帧，只有上位机接收到数据帧180001E0，才会回复18EAE001，18EBE001，18ECE001，18EDE001。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3baff3480be9e8d0856fde8a96098b68/" rel="bookmark">
			机器学习周报第27周
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 摘要Abstract一、文献阅读 摘要 本周阅读了一篇混沌时间序列预测的论文，论文模型主要使用的是时间卷积网络（Temporal Convolutional Network，TCN）、LSTM以及GRU。在数据集方面除了使用现实的时间序列数据外，还通过若干混沌系统生成了一些混沌的时间序列数据，这些数据没有现实方面的意义，但可以用来证明论文模型的实用性。因为混沌时间序列在现实世界普遍存在，例如水质，股票，天气等，所以论文模型也有运用于水质预测的潜力。
Abstract This week, We read a paper on chaotic time series prediction. The paper primarily utilized models such as Temporal Convolutional Network (TCN), Long Short-Term Memory (LSTM), and Gated Recurrent Unit (GRU). In terms of the dataset, in addition to using real-world time series data, the paper also generated chaotic time series data through several chaotic systems. Although these chaotic data lack real-world significance, they serve to demonstrate the practicality of the proposed models.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3baff3480be9e8d0856fde8a96098b68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94d65a46cf2bf70d946dfbcdc4ef24e1/" rel="bookmark">
			Hadoop精选18道面试题(附回答思路)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.简述Hadoop1和Hadoop2的架构异同 HDFS HA(High Availablity) 一旦Active节点出现故障，就可以立即切换到Standby节点，避免了单点故障问题。 加入了对zookeeper支持实现比较可靠的高可用。 YARN 将MapReduce1.0中的资源管理调度功能分离出来形成了YARN，一个纯粹的资源任务管理调度框架，避免了内存受限问题。 2.简述HDFS Hadoop分布式文件系统
文件系统 目录树定位文件 分布式 数据大，要拆，要分，再存。 "拆"：block 128M "分"：编号，找namenode，分配 "存"：传完第一份后内网互传 副本机制，一式三份 均衡 3.Hadoop生态系统与Hadoop框架 Hadoop生态系统除Hadoop之外，还包含zookeeper、Flume、Hbase、Hive、Sqoop等辅助框架
4.Hadoop核心组件(定义+组成+优点(思想)) HDFS 分布式文件系统 提供高吞吐量的数据访问和存储，特别适合大数据集的分布式存储。 NameNode*2(Active|Standby)+DataNode*N 具有高容错性 支持流式访问 MapReduce 分布式计算框架 用于大规模数据集的并行处理 Map+Shuffle+Reduce 分而治之 构造抽象模型 YARN 分布式资源管理系统 负责任务调度和集群资源管理 ResourceManager &amp; ApplicationManager NodeManager HDFS角色 NameNode,DataNode,SecondaryNameNode Hadoop架构 HDFS——分布式文件系统 MapReduce——分布式计算框架 YARN——分布式资源管理系统 Commons 5.Block大小 如果一个文件小于128M，它只占用文件本身大小的空间，其它空间别的文件也能用。
Block大小设置主要取决于磁盘传输速率。
(把文件分为N块，读取文件时就要寻址N次)
6.NameNode与SecondaryNameNode的区别与联系 区别
1)NameNode存储了文件系统下所有目录和文件的访问，修改，执行时间，块大小，执行权限等
2)SecondaryNameNode并非NameNode的热备(≠ StandBy NameNode)。定期触发CheckPoint(服务)，代替NameNode合并EditLog和fsimage文件。
联系
1)SecondaryNameNode中保存了一份和NameNode一致的fsimage和edits文件。但是，NameNode还有一份正在使用的编辑日志edit_inporgress，这是SecondaryNameNode没有的。
2)在主namenode发生故障时(假设没有及时备份数据)，可以从SecondaryNameNode恢复历史的数据。
7.SecondaryNameNode的目的是什么 SecondaryNameNode定期触发CheckPoint，代表NameNode合并编辑日志EditLog和镜像文件Fsimage，从而减小EditLog的大小，减少NN启动时间。
同时在合并期间，NameNode也可以对外提供写操作。
8.HDFS的读/写数据流程 HDFS的写(上传)数据流程
1)HDFS client创建DFS对象，通过该对象向NameNode请求上传文件，NameNode检查权限，并判断该目标文件是否已存在。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94d65a46cf2bf70d946dfbcdc4ef24e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/057d7b6c1f827a9ffaed4b27ee09a8a7/" rel="bookmark">
			leetcode困难题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 找到矩阵中的好子集最长合法子字符串的长度情侣牵手三个无重叠子数组的最大和数字1的个数滑动窗口的最大值简易计算器单词搜索 找到矩阵中的好子集 解：
答案至多选取两行矩阵。
分析：
选取一行矩阵时，floor(c/2)=0，那么必须全为0才能满足。
选取两行矩阵时，floor(c/2)=1，同一列元素不能都是1，也就是相&amp;为0
选取三行矩阵时，floor(c/2)=1，去掉一列后，等同于两行的情况
选取四行时，floor(c/2)=2，假如上述都没有答案：
选取四行中1最少的一行来分析：
1.这一行为10……0，因为上述&lt;4行时都不成立，所以2行时任意两行都不能相&amp;为0，所以其他行第一列必须是1，第一列相加为4，不满足要求
2.这一行为11……0，第二行为10……，第三行为01……为了让第二行与第三行相&amp;不为0，必须在后边的一列都为1，第四行为了与第二行和第三行相&amp;不为0，必须拿出一列使得其与第一行、第二行和第三行都为1，这样算起来就需要6列数据，而题目所说列数小于等于5，所以不满足条件
选取超过四行时，类似方法证明答案不存在
func goodSubsetofBinaryMatrix(grid [][]int) []int { n := len(grid) if n == 0 { return nil } num := make(map[int]int, n) for i, row := range grid { mask := 0 for j, v := range row { mask |= v &lt;&lt; j } num[mask] = i } if v, ok := num[0]; ok { return []int{v} } for i, v := range num { for j, v2 := range num { if i&amp;j == 0 { if v &lt; v2 { return []int{v, v2} } return []int{v2, v} } } } return nil } 最长合法子字符串的长度 func longestValidSubstring(word string, forbidden []string) int { n := len(word) if n == 0 { return -1 } vis := make(map[string]struct{}, len(forbidden)) for _, v := range forbidden { vis[v] = struct{}{} } l := 0 ans := 0 for i := 0; i &lt; n; i++ { for j := i; j &gt;= l &amp;&amp; j &gt;= i-10; j-- { if _, ok := vis[word[j:i+1]]; ok { l = j + 1 break } } if i-l+1 &gt; ans { ans = i - l + 1 } } return ans } 情侣牵手 var f []int func fin(x int) int { if x !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/057d7b6c1f827a9ffaed4b27ee09a8a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29f332079f71da93bbd03272189e21fb/" rel="bookmark">
			[蓝桥杯学习] 线段树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 学习blibli
定义 线段树是一种特殊的平衡二叉查找树，使用线段树，可以实现数据的添加、查找和删除。
树的根结点表示了一个完整的单元区间，左右孩子的区间是将父结点的区间进行二分，左右孩子的区间之和，就是他们的根结点。
叶子结点是区间间隔为1的单位区间（存放的是单个数字），当区间[a,b]的a=b时，就是叶子结点了。
如果用线段树来存储一个区间 [a,b]，叶结点的个数就是(b-a+1)，并且存储数字从a到b
实现方法 由于线段树是一棵平衡二叉树，可以使用一个数组来实现（虽然不是严格意义上的完全二叉树，但是可以为了实现和使用方便，就看成是一棵完全二叉树，不存在的结点在数组里空着就好）。
区间长度为 [0,5] 的线段树，要用到的数组区间是从 a[0] 到 a[2*5+2]，其中一些空间是不存储数据的。
根存储在a[0]
结点 i ，父结点：(i-2)/2，左孩子结点：2*i+1 ，右孩子结点：2*i+2
一个结点的信息包括该结点的 value 以及区间左右端点，通常是不将区间左右端点显示地表示出来，因为可以在查找中计算出来。
应用示例 示例：线段树中，结点值是该区间里的数字个数
如果添加数字3，从区间[0,5] 和 [3,5] [3,4] [3,3]对应的结点值都要加1
代码实现 数据插入 //线段树的数据插入 void tree_inset(int pos,int left,int right,int num) { a[pos]++; //进行要计算的操作 if(num == left &amp;&amp; num == right) return; //找到数字所在的叶子 int mid = (left + right)&gt;&gt;1; //把num和mid进行比较 if(num &lt;= mid) tree_inset(pos*2+1,left,mid,num); //到左孩子去 else tree_inset(pos*2+2,mid+1,right,num); //到右孩子去 } 对叶子的查找类似于二分查找。
查询 //线段树的数据查询 int tree_search(int pos,int left,int right,int num) { if(num == left &amp;&amp; num == right) return a[pos]; int mid = (left + right)&gt;&gt;1; if(num &lt;= mid) return tree_search(pos*2+1,left,mid,num); else return tree_search(pos*2+2,mid+1,right,num); } 打印线段树 //打印线段树 void tree_print(int pos,int left,int right) { cout &lt;&lt; '[' &lt;&lt; left &lt;&lt; ',' &lt;&lt; right &lt;&lt; ']' &lt;&lt; ' ' &lt;&lt; a[pos] &lt;&lt; '\n'; if(left == right) return; int mid = (left+right)&gt;&gt;1; tree_print(pos*2+1,left,mid); tree_print(pos*2+2,mid+1,right); return; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12942ebdf73c336baa43ab031929f3aa/" rel="bookmark">
			使用redis时快速考虑的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用场景 ap组件程序是否容忍极限丢失1s数据是否可以不依赖redis就能实现是否过度依赖redis 数据结构 5种结构选择不同结构有自己的限制，使用前需考虑限制考虑当前业务最适合那种解构，或多种解构混合使用 key设计 大keykey的格式热key敏感数据 过期时间 设置遗漏设置过期时间合理设置过期时间过于集中设置过期时间单位错误设置过期时间失败兜底有没有 并发问题 语法效率是否最佳语法错误不同redis三方sdk兼容格式 容量问题 容量问题 内存，cpu，磁盘等容量问题充分评估实时及时监控调整 重要的变更可以来dba一起评估 集群配置 日志刷新时间内存淘汰策略 安全 雪崩，穿透，防攻击 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/863725b47547781a70a02d2966005e6b/" rel="bookmark">
			解决flask启动报错：ImportError: DLL load failed while importing _dukpy: 找不到指定的程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现象：
原因：dukpy没有win32执行库
解决办法：
到lfd.uci.edu 第三方库下载dukpy的win32 whl文件
注意： 需要跟你python版本和windows平台（32位/64位）对应
https://www.lfd.uci.edu/~gohlke/pythonlibs/#dukpy
pip3 install dukpy-0.2.3-cp38-cp38-win_amd64.whl
问题解决：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f260fb083ced2a93fe651cfe68623cf3/" rel="bookmark">
			C/C&#43;&#43;使用过程中的溢出问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内容：在C/C++程序里有一类非常典型的问题，那就是：溢出问题。现在分别来分析一下常见的数组溢出，整数溢出，缓冲区溢出，栈溢出和指针溢出等。
目录
1、数组溢出
2、整数溢出
3、缓冲区溢出
4、栈溢出
5、指针溢出
6、字符串溢出
1、数组溢出 在C语言中，数组的元素下标是从0开始计算的，所以，对于n个元素的数组a[n]， 遍历它的时候是a[0],a[1],...,a[n-1]，如果遍历到a[n]，数组就溢出了。 void print_array(int a[], int n)
{
for (int i = 0; i &lt; n; i++) {
a[i] = a[i+1];//当i = n-1时，就发生了数组越界
printf(“%d\n”, a[i]);
}
}
上面的循环判断应该改为：
for (int i = 0; i &lt; n-1; i++)
2、整数溢出 整数的溢出分为下溢出和上溢出。比如，对于有符号的char(signed char)类型来说，它能表示的范围为：[-128,127]之间；而对于无符号的char(unsigned char)来说， 它能表示的范围为：[0,255]。
那么，对于下面的代码：
signed char c1 = 127;
c1 = c1+1;//发生上溢出，c1的值将变为-128
signed char c2 = -128;
c2 = c2-1;//发生下溢出，c2的值将变为127
unsigned char c3 = 255;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f260fb083ced2a93fe651cfe68623cf3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b709bebc0515305e0d45b9fd34e1c25/" rel="bookmark">
			计算机网络基础知识（非常详细）从零基础入门到精通，看完这一篇就够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
️️️一、计算机网络的概念
二、计算机网络的功能
三、计算机网络的组成
1、组成部分
2、工作方式
3、功能组成
四、计算机网络的分类
1、按分布范围分
2、按使用者分
3、按交换技术分
4、按拓扑结构分
5、按传输技术分
五、标准化工作
1、分类
2、标准化工作的相关组织
六、性能指标
1、速率
2、带宽
3、吞吐量
4、时延
5、时延带宽积
6、往返时延RTT
7、利用率
️️️一、计算机网络的概念 计算机网络：是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统。
二、计算机网络的功能 1、数据通信
2、资源共享
3、分布式处理（多台计算机各自承担同一工作任务的不同部分）
4、提高可靠性
5、负载均衡
三、计算机网络的组成 1、组成部分 硬件、软件、协议
2、工作方式 边缘部分：用户直接使用（C/S方式、P2P方式）
核心部分：为边缘部分提供服务
3、功能组成 通信子网：实现数据通信
资源子网：实现资源共享/数据处理
四、计算机网络的分类 1、按分布范围分 广域网WAN、城域网MAN、局域网WAN、个人区域网PAN
2、按使用者分 公用网、专用网
3、按交换技术分 电路交换、保温交换、分组交换
4、按拓扑结构分 总线型、星型、环型、网状型
5、按传输技术分 广播式网络：共享公共通信信道
点对点网络：使用分组存储转发和路由选择机制
五、标准化工作 标准化对计算机网络至关重要。
要实现不同厂商的软硬件之间相互连通，必须遵从统一的标准。
1、分类 法定标准：由权威机构制定的正式的。合法的标准 OSI
事实标准：某些公司的产品在竞争中占据了主流，时间长了，这些产品中的协议和技术就成了标准。比如TCP/IP。
2、标准化工作的相关组织 国际标准化组织（OSI参考模型、HDLC协议）国际电信联盟ITU（制定通信规则）国际电气电子工程师协会IEEE（学术机构、IEEE802系列标准、5G）Internet工程任务组IETF（负责因特网相关标准的制定） 六、性能指标 1、速率 速率即数据率或称数据传输率或比特率。
比特 1/0位
连接在计算机网络上的主机在数字信道上传送数据位数的速率。
单位是b/s、kb/s、Mb/s、Gb/s、Tb/s
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b709bebc0515305e0d45b9fd34e1c25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/becef7cc172fbdf0add5b31a9e0f2205/" rel="bookmark">
			超详细的VSCode下载和安装教程（非常详细）从零基础入门到精通，看完这一篇就够了。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 1. 引言2. 下载VSCode3. 解决VSCode下载速度特别慢4. 安装VSCode 1. 引言 今天用WebStorm运行前端代码时，发现不太好打断点。
于是，打算改用VSCode来运行前端代码，但前提是要安装VSCode，如下便是超详细的VSCode安装教程以及解决VSCode下载速度特别慢的问题。
2. 下载VSCode 打开VSCode官网 https://code.visualstudio.com
download下载 下载特别慢
你会发现VSCode官网地址下载很慢，或者下着下着就暂停了，如下图所示：
如果下载完成，那得等到猴年马月。
3. 解决VSCode下载速度特别慢 单击右下角全部显示 我是用chrome浏览器，点击右下角的全部显示按钮，可以跳转到下载内容页面。
如果你是用其他浏览器，可能使用其他方式跳转到下载内容页面。
鼠标放置在下图红框中，右键鼠标，复制链接地址 将复制号的下载链接地址放到任意地方，并将蓝色区域的地址替换成国内镜像地址：vscode.cdn.azure.cn 即https://az764295.vo.msecnd.net/stable/129500ee4c8ab7263461ffe327268ba56b9f210d/VSCodeUserSetup-x64-1.72.1.exe修改为https://vscode.cdn.azure.cn/stable/129500ee4c8ab7263461ffe327268ba56b9f210d/VSCodeUserSetup-x64-1.72.1.exe
将替换后的地址输入到浏览器的地址栏中，如下图所示，按enter键即可快速下载。
速度是不是立刻提升了。
4. 安装VSCode 我同意此协议 -&gt; 下一步 选择更换文件夹 -&gt; 下一步 因为我的系统盘(C盘)的内存不够用了，需要更换到其他盘符，我更换到D盘中。
如果你不想更换到其他盘符，可以直接下一步即可。
选择附加任务 -&gt; 下一步。根据你的需求勾选复选框。 准备安装 -&gt; 安装 安装完成 -&gt; 完成 打开VSCode 如果你也想学习:黑客&amp;网络安全 今天只要你给我的文章点赞，我私藏的网安学习资料一样免费共享给你们，来看看有哪些东西。
在这里领取： 这个是我花了几天几夜自整理的最新最全网安学习资料包免费共享给你们，其中包含以下东西： 1.学习路线&amp;职业规划 2.全套体系课&amp;入门到精通 3.黑客电子书&amp;面试资料 4.漏洞挖掘工具和学习文档 这些东西都是免费领取哦：黑客最新大礼包 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f60f0a7a6413650afed019516b2a1a9b/" rel="bookmark">
			使用 CMake 和 Ninja 构建 C/C&#43;&#43; 项目的教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 CMake 和 Ninja 构建 C/C++ 项目的教程 CMake 是一个跨平台的开源构建工具，它简化了项目的构建过程。而 Ninja 是一个快速、轻量级的构建系统，与 CMake 配合使用可以提高项目的构建效率。本教程将向你介绍如何使用 CMake 和 Ninja 来构建你的 C/C++ 项目。
1. 安装 CMake 和 Ninja 首先，确保你的系统中已经安装了 CMake 和 Ninja。你可以使用包管理器进行安装：
在 Ubuntu 上：
bashCopy code sudo apt-get install cmake ninja-build 在 macOS 上，使用 Homebrew：
bashCopy code brew install cmake ninja 在 Windows 上，你可以使用 CMake 官网 下载并安装 CMake，而 Ninja 则可以通过 GitHub Release 下载预编译的二进制文件。
2. 创建 CMakeLists.txt 文件 在你的项目根目录下创建一个 CMakeLists.txt 文件。这个文件描述了项目的结构和构建过程。
cmakeCopy code # CMake 最低版本要求 cmake_minimum_required(VERSION 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f60f0a7a6413650afed019516b2a1a9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee8288d5dcf0cb846271bfb8d4d1e322/" rel="bookmark">
			C/C&#43;&#43; 中的预处理器提供了多种预处理指令，用于在编译之前对源代码进行处理。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 文件包含（Include）2. 宏定义（Macro）3. 条件编译4. 错误指令（Error）5. 警告指令（Warning）6. 行控制（Line Control）7. 定义检测（Defined）总结 C/C++ 中的预处理器提供了多种预处理指令，用于在编译之前对源代码进行处理。这些指令对代码的结构和内容有显著的影响。主要的预处理指令包括：
1. 文件包含（Include） 作用：将其他文件的内容包含到当前文件。指令：#include示例： #include &lt;iostream&gt;：包含标准库头文件。#include "myheader.h"：包含用户定义的头文件。 2. 宏定义（Macro） 作用：定义宏，它们是预处理器的简单替换。指令： #define：定义宏。#undef：取消宏定义。 示例： #define PI 3.14159#define MAX(a, b) ((a) &gt; (b) ? (a) : (b)) 3. 条件编译 作用：根据特定的条件编译部分代码。指令： #if、#elif、#else、#endif：条件编译。#ifdef、#ifndef：检查宏是否被定义。 示例： #ifdef DEBUG#if defined(WIN32) || defined(_WIN32) 4. 错误指令（Error） 作用：当遇到指定的预处理指令时，生成一个错误。指令：#error示例： #error "This version of the software is obsolete" 5. 警告指令（Warning） 作用：生成一个编译时警告。指令：#warning（在一些编译器中可用）示例： #warning "This code is still in beta" 6. 行控制（Line Control） 作用：改变编译器的行号和文件名输出，用于调试。指令：#line示例： #line 100 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee8288d5dcf0cb846271bfb8d4d1e322/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1ff2501c3bc839956aa9e3b0619788c/" rel="bookmark">
			技术学习周刊第 1 期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2018 年参与过 1 年的 ARTS 打卡，也因为打卡有幸加入了 MegaEase 能与皓哥（左耳朵耗子）共事。时过境迁，皓哥已经不在了，自己的学习梳理习惯也荒废了一段时间。
2024 年没给自己定具体的目标，只要求自己好好吃饭睡觉，只字不差的阅读、听讲。之前学习阅读的很多资料都没有好好沉淀，因此决定恢复之前每周打卡的习惯，参考阮一峰老师的技术爱好者周刊，每周将自己读过的好的文章、资料做整理分享。
40 questions to ask yourself every year Obsidian 的 CEO 在 2016 年分享的每年都会问自己的 40 个问题以及站在 10 年维度上问自己的 40 个问题。新年伊始，不妨作为一份参考，回顾来路，展望未来。自己尝试回答了几个：
你身边有人生孩子了吗？ 有，我老婆给我生了个儿子。
你身边有人去世了吗？ 有，我 leader 以及最重要的职业导师左耳朵耗子猝然离世。
今年你学到了什么宝贵的人生经验？ 除了生死，都是擦伤。真正明白了乔布斯斯坦福演讲所说的：Because almost everything — all external expectations, all pride, all fear of embarrassment or failure - these things just fall away in the face of death, leaving only what is truly important.
你最想培养的特质是什么？ 一往无前的勇气，雷厉风行的活力
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1ff2501c3bc839956aa9e3b0619788c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c11c34c112287e86f269063c72ae463/" rel="bookmark">
			试除法求约数算法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 知识概览 试除法求一个数的约数的时间复杂度是。 例题展示 题目链接 活动 - AcWing 系统讲解常用算法与数据结构，给出相应代码模板，并会布置、讲解相应的基础算法题目。https://www.acwing.com/problem/content/871/
题解 用试除法求约数，总的时间复杂度是，也就是400万~500万之间。
代码 #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std; vector&lt;int&gt; get_divisors(int n) { vector&lt;int&gt; res; for (int i = 1; i &lt;= n / i; i++) if (n % i == 0) { res.push_back(i); if (i != n / i) res.push_back(n / i); } sort(res.begin(), res.end()); return res; } int main() { int n; cin &gt;&gt; n; while (n--) { int x; cin &gt;&gt; x; auto res = get_divisors(x); for (auto t : res) cout &lt;&lt; t &lt;&lt; ' '; cout &lt;&lt; endl; } return 0; } 参考资料 AcWing算法基础课 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ea340c03b0f68018163a90ff9b7cd18/" rel="bookmark">
			C语言—数据类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		变量和基本数据类型 变量类型的概念 变量是在程序中可以发生变化的量，变量是有类型的，变量的类型决定了变量存储空间的大小以及如何解释存储的位模式。
1字节（Byte）=8位（bit）
定义格式 存储类型 数据类型 变量名；
例如：
（auto） int a；
存储类型：
auto、static、register、extern
变量名：
是标识符，要遵循标识符命名规则
数据类型：
包含名称、大小（单位字节）和取值范围
char、short、int、long、float、double、signed、unsigned
类型存储大小值范围char字符类型1字节-2^7 ~ 2^7-1unsigned char无符号字符类型1字节0 ~ 2^8-1int整数类型4字节-2^31 ~ 2^31-1unsigned int无符号整数类型4字节0 ~ 2^32-1short短整型2字节-2^15 ~ 2^15-1unsigned short无符号短整型2字节0 ~ 2^16-1long长整型4字节-2^31 ~ 2^31-1unsigned long无符号长整型4字节0 ~ 2^32-1float单精度浮点型4字节有效数据到小数点后6~7位double双精度浮点型8字节有效数据到小数点后15~16位 例如：
int c=10,d=10; float a=33.33333333; double b=33.33333333; printf("%f\n%lf\n%d %d\n",a,b,c,d); 输出结果为：
33.333332
33.333333
10 20
初始化格式 定义时初始化 int a=10；
先定义再初始化 int a；
a=10；
局部变量和全局变量 相关概念 生命周期 变量的生命周期是指变量从创建到销毁之间的一个时间段，也就是存活的周期，是时间维度。
作用域 作用域是指变量可以起作用的范围，是空间维度。
内存分区 全局变量和局部变量的区别：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ea340c03b0f68018163a90ff9b7cd18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b982800eceee2f6a86e4fe4ada6d383/" rel="bookmark">
			【已解决】在开启ssh和sshd状态下，XShell无法连接到VMware虚拟机中的Linux操作系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【已解决】在开启ssh和sshd状态下，XShell无法连接到VMware虚拟机中的Linux操作系统 XShell无法连接到VMware虚拟机中的Linux操作系统，今天上线突然发现XShell无法连接到VMware虚拟机中的Linux操作系统，但是找了很多解决方案都没有解决，包括检查ssh和sshd服务是否开启，一切配置正常，但就是连不上，最后我用了ifconfig命令查看网卡配置与网络状态时发现，居然没有ens33网卡，此时我明白了问题所在，于是执行下面命令，最终成功解决问题：
systemctl stop NetworkManager systemctl disable NetworkManager systemctl start network.service 执行完成就成功了
此时再次执行ifconfig命令，可以看到网卡ens33成功加载
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bae199b4c70f732c5ac91c0441859da/" rel="bookmark">
			联合union
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//————联合：union
1.联合的定义
联合也是一种特殊的自定义类型
#include&lt;stdio.h&gt;
union Un//Un为联合标签
{
int a;
char c;
};
struct St
{
int a;
int b;
};
int main()
{
union Un u;
printf("%d\n",sizeof(u));//4
printf("%p\n",&amp;u);
printf("%p\n",&amp;(u.a));
printf("%p\n",&amp;(u.c));//三个打印地址的结果相同
return 0;
}
2.联合体的特点
联合体的成员是共用一块内存空间的，这样一个联合文件的大小，至少是最大成员的大小（因为至少要有能力保护最大的那个成员）
//union Un
//{
// int a;
// char c;
//};
//int main()
//{
// union Un u;
// u.a = 0x11223344;
// u.c = 0x00;//将c的地址改为0，也就等同于把最高位地址改为0，由于a和c共用一块1字节大小的地址，即c的改动也会同时影响a，即a的地址变为0x11223300
// return 0;
//}
——————通过枚举判断计算机大小端储存方式
//#include&lt;stdio.h&gt;
//int check_p()
//{
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6bae199b4c70f732c5ac91c0441859da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9d373b5ca285b2819d841ed1de1dd79/" rel="bookmark">
			分割系统日志，解决syslog文件过大的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 随着系统使用时间越长，系统日志/var/log/syslog也会越来越大，达到几g或十几g，不但占用硬盘空间，且拷贝日志进行分析时也需要较长时间。
解决方案 对系统日志syslog进行分割，减少系统日志的大小
执行如下脚本文件 chmod +x fix_logrotate.sh sudo ./ fix_logrotate.sh fix_logrotate.sh
#!/bin/bash rm -f /var/log/syslog.* cat &gt;/etc/logrotate.d/rsyslog&lt;&lt;EOF /var/log/syslog { maxsize 20000k hourly rotate 4 daily missingok notifempty delaycompress compress postrotate invoke-rc.d rsyslog rotate &gt; /dev/null endscript } /var/log/mail.info /var/log/mail.warn /var/log/mail.err /var/log/mail.log /var/log/daemon.log /var/log/kern.log /var/log/auth.log /var/log/user.log /var/log/lpr.log /var/log/cron.log /var/log/debug /var/log/messages { rotate 4 maxsize 20000k hourly missingok notifempty compress delaycompress sharedscripts postrotate invoke-rc.d rsyslog rotate &gt; /dev/null endscript } EOF chmod 644 /etc/logrotate.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9d373b5ca285b2819d841ed1de1dd79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5384365db15e346e1d20b7d298089955/" rel="bookmark">
			【算法提升】LeetCode每五日一总结【01/01--01/05】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 LeetCode每五日一总结【01/01--01/05】2023/12/31今日数据结构：二叉树的前/中/后 序遍历&lt;非递归&gt; 2024/01/01今日数据结构：二叉树的 前/中/后 序遍历 三合一代码&lt;非递归&gt;今日数据结构：二叉树的 前/中/后 序遍历 三合一代码&lt;递归&gt; 2024/01/02每日力扣：[101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/) 2024/01/03每日力扣：[104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)每日力扣：[111. 二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/) 2024/01/04每日力扣：[226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/) 2024/01/05每日力扣：[105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)每日力扣：[106. 从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/) LeetCode每五日一总结【01/01–01/05】 这次总结额外加上2023年最后一天2023/12/31日的题目，总共六天！
2023/12/31
二叉树的前/中/后 序遍历&lt;非递归&gt;
使用非递归方式实现二叉树的前/中/后序遍历，最终要的思想是需要用到栈这样的数据结构，因为我们需要在遍历的过程中，时刻记着返回的路，以便我们遍历完一颗子树后，可以返回回来遍历其他子树：
​ 具体的，前序遍历时，需要在当前节点不为空时就直接操作当前节点，待操作完成后，再将当前节点入栈并且指向当前节点的左孩子，循环该操作，直到当当前节点为空，则开始准备返回，此时从栈中pop节点，并判断pop出的节点是否有右孩子，如果有，则将右孩子赋值给当前节点，继续上面的操作即可。
​ 中序遍历的代码思想和前序遍历是非常类似的，只是在操作节点的时机上有所不同，前序遍历是在当节点不为空时直接操作节点，而中序遍历则需要在当前节点为空后，从栈中pop出第一个元素时，操作pop出的元素，因为此时pop出的元素已经没有左孩子。
​ 后序遍历的代码和前序遍历及中序遍历有所区别，最大的区别在于，当当前节点为空时，我们不能立刻从栈顶pop节点并操作该节点，而应该先判断栈顶元素节点的右孩子没有或者已经被操作，那么判断栈顶节点右孩子为空很容易，如何判断栈顶节点右孩子是否被操作过呢？此时，我们可以定义一个变量pop记录最近一次被pop出的节点，如果栈顶元素的右孩子和记录的pop变量中的节点是同一个节点，则说明栈顶元素的右孩子以及被操作，此时即可pop出栈顶节点进行操作。如果不是同一个节点，则将说明栈顶元素有右孩子而且暂时没有被操作，此时要将右孩子赋值给当前节点，重复以上判断。
2024/01/01
二叉树的 前/中/后 序遍历 三合一代码&lt;非递归&gt;
所谓三合一代码，就是将之前分开写的三段递归代码，合在一段代码中，在代码的不同时机，进行不同的节点操作即可实现一段代码进行了前/中/后三次遍历的效果，有助于进一步理解二叉树的三种遍历方式，不同点在于操作栈中的节点，大家可以重点关注：
​ 二叉树的 前/中/后 序遍历 三合一代码&lt;递归&gt;
递归实现二叉树的遍历代码很简单易懂，附上代码，不过多赘述：
​ 2024/01/02
101. 对称二叉树
这道题判断一个二叉树是否是对称的，我们可以想到判断根节点的左右孩子是否是对称的，其他节点的判断方法和根节点相同，很容易想到采用递归方法，因此，在check方法中定义好判断条件（
如果left和right都为空，返回true，因为它们都是空的。如果left或right为空，返回false，因为其中一个树不是空的。如果left和right的值不相等，返回false，因为树不是对称的。 ）后，只需递归（左孩子的左孩子和右孩子的右孩子为参数）调用该方法，即可判断整颗树是否为对称树
2024/01/03
104. 二叉树的最大深度
方法一：后序遍历递归法
判断根节点是否为空，如果是，则返回0，因为深度为0。如果根节点的左右子节点都为空，说明该节点没有子节点，返回1，因为深度为1。否则，递归地计算左子树和右子树的深度，分别存储在maxLeft和maxRight变量中。最后，将maxLeft和maxRight中的最大值加1，得到本节点的最大深度，并返回。 关于深度的定义：从根节点出发，离根节点最远的节点所经过的边数，即该节点的深度。注意，这里的深度定义与力扣上的默认定义略有不同，深度为0表示没有节点，深度为1表示有一个根节点，深度为2表示有一个根节点和一个子节点，以此类推。
方法二：后序遍历非递归法
非递归法实现二叉树的后序遍历时，需要使用到栈数据结构，用于记录遍历一颗子树完成后返回的路，此时，如果是后序遍历，只有遍历到叶子节点时才会从栈中pop元素，因此，栈中最大的元素个数就对应着二叉树的最大深度，我们只需要在向栈中放入元素方法后面，记录栈中元素个数，返回最大的元素个数即可。
方法三：层序遍历
使用层序遍历计算二叉树的最大深度，我们只需要定义一个记录深度的变量，在遍历完每一层的所有节点后，该变量＋1即可。
111. 二叉树的最小深度
方法一：二叉树的最小深度&lt;递归&gt;
思路：当根节点没有左右孩子，则返回最小深度为1，当根节点只有左孩子，则递归调用求出左孩子的最小深度+1即可，相同的，如果根节点只有右孩子，则递归调用求出右孩子的最小深度+1即可；
对于一个非空节点，如果它的左子节点和右子节点都为空，那么它的最小深度为1；****如果它的左子节点为空，那么它的最小深度为右子节点的最小深度加1；如果它的右子节点为空，那么它的最小深度为左子节点的最小深度加1；****否则，它的最小深度为左右子节点最小深度的较小值加1。
如果根节点为空，则返回0。如果根节点的左子节点和右子节点都为空，则返回1。如果根节点的左子节点为空，则返回根节点的右子节点的最小深度加1。如果根节点的右子节点为空，则返回根节点的左子节点的最小深度加1。否则，返回左右子节点最小深度的较小值加1。 方法二：二叉树的最小深度&lt;层序遍历&gt;❤️（效率更优）
核心思想：当层序遍历找到第一个叶子节点时，返回第一个叶子节点所在层数即为最小深度。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5384365db15e346e1d20b7d298089955/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3425a61370b45c2ef1dbff0a081870ce/" rel="bookmark">
			『开发工具』- 配置 gradle 等相关依赖镜像源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 『开发工具』- 配置 gradle 等相关依赖镜像源 1.更换gradle下载源2. 配置setting.gradlekts文件gradle文件 1.更换gradle下载源 使用腾讯云的镜像库https://mirrors.cloud.tencent.com/gradle/
gradle-x.x-all.zip：编译后的二进制发布版以及源码和文档gradle-x.x-src.zip：源码和文档gradle-x.x-bin.zip：编译后的二进制发布版 建议直接使用all，使用bin的话默认会从gradle的官方库下载src，这又会很慢。
https://mirrors.cloud.tencent.com/gradle/ 2. 配置setting.gradle kts文件 maven { url = uri("https://plugins.gradle.org/m2/") } maven { url = uri("https://maven.aliyun.com/nexus/content/repositories/google") } maven { url = uri("https://maven.aliyun.com/nexus/content/groups/public") } maven { url = uri("https://maven.aliyun.com/nexus/content/repositories/jcenter") } gradle文件 maven { url 'https://maven.aliyun.com/repository/google' } maven { url 'https://maven.aliyun.com/repository/jcenter' } maven { url 'http://maven.aliyun.com/nexus/content/groups/public' } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7841bf66d25f0a8317c23991d38c0ccf/" rel="bookmark">
			es集群安装及优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		es主节点
192.168.23.100
es节点
192.168.23.101
192.168.23.102
1.安装主节点 1.去官网下载es的yum包
官网下载地址 https://www.elastic.co/cn/downloads/elasticsearch
根据自己的需要下载对应的包
2.下载好之后把所有的包都传到从节点上，安装 [root@localhost ~]# ansible all -m copy -a 'src=/root/elasticsearch-8.11.3-x86_64.rpm dest=/root/elasticsearch-8.11.3-x86_64.rpm' 192.168.23.102 | CHANGED =&gt; { "ansible_facts": { "discovered_interpreter_python": "/usr/bin/python" }, "changed": true, "checksum": "64c9029f99fa4beeabae1a36d1a88b8bf44982cf", "dest": "/root/elasticsearch-8.11.3-x86_64.rpm", "gid": 0, "group": "root", "md5sum": "d4b85a836646cd0b8c1d87848bf2e77c", "mode": "0644", "owner": "root", "size": 630669510, "src": "/root/.ansible/tmp/ansible-tmp-1704551077.26-16135-196050427416681/source", "state": "file", "uid": 0 } 192.168.23.101 | CHANGED =&gt; { "ansible_facts": { "discovered_interpreter_python": "/usr/bin/python" }, "changed": true, "checksum": "64c9029f99fa4beeabae1a36d1a88b8bf44982cf", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7841bf66d25f0a8317c23991d38c0ccf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cceb64e8c5027a279d3ebe13f439e68/" rel="bookmark">
			OpenVpn介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 前言 手上一直都有一个腾讯云的服务器，之前一直都只是当做http文件服务器使用，觉得有些可惜。后来自己有在外面远程家里电脑的需求，想是不是可以使用某种方式，做到这一点。之前有想过用花生壳，ipsec等等，但是都因为不太了解或者有些复杂而没有去做，直到了解到了OpenVpn。我只需要在腾讯云上建立一个OpenVpn的服务，让家里的电脑和外面工作的电脑都连接OpenVpn服务器，这样外面的电脑就可以轻松访问家里电脑了，再者配置服务器和客户端的过程也比较简单。接下来简要介绍OpenVpn的特点。
OpenVpn官网国内没法直接访问，但是我们可以使用CentOS安装OpenVpn的包，通过其man手册学习它的使用方式。
二. OpenVpn的特点 1. 开源和免费 OpenVpn是开源软件，任何人都可以自由使用和修改源代码。降低了使用成本，由于社区发展比较好，OpenVpn软件非常的稳定。
2. 跨平台支持 OpenVpn可以在Windows，Linux，MacOS，IOS和Andriod等多个平台运行，OpenVpn都维护了各个平台的软件版本，这使得OpenVpn的使用非常的灵活，可满足多种设备的VPN需求。
3. 强大的安全性 OpenVpn使用了行业标准的加密算法。AES加密和TLS/SSL安全协议，确保传输过程的安全性。
4. 网络配置灵活 OpenVPN允许用户配置各种网络选项，包括点对点连接、站点到站点连接、客户端到服务器连接（服务器支持多客户端）等。
5. 易于配置和使用 尽管OpenVPN提供了强大的功能和灵活的配置选项，但其配置文件基于文本，易于理解和修改，并且官方提供的文档和指导案例也非常全面。此外，许多发行版中包含了图形化的界面工具，简化了配置和使用过程。
6. 网络适应能力 OpenVPN能够穿越防火墙和网络地址转换（NAT）设备，甚至可以在只允许HTTP或HTTPS流量的网络环境中工作。
7. 社区支持 由于其开源特性，OpenVPN拥有一个活跃的社区，用户可以从社区获得技术支持和新的功能更新。
三. 总结 OpenVpn在企业级和跟人用户之间都有广泛的应用，特别是要高度安全和可定制化VPN解决方案的场景。从我个人的使用角度来说，OpenVpn非常的稳定，在我使用过程中没有出现任何问题，还有易于配置，文档手册对于各个配置选项解释的非常详细，减少了学习和使用成本。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/609e01d4c9d1ce77a12adc4ded51fc63/" rel="bookmark">
			【C&#43;&#43;20】编译期检测所有未定义行为undefined behavior和内存泄漏（不借助编译选项以及任何外部工具）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、未定义行为Undefined Behavior(UB)1.返回一个未初始化的局部变量的值2.数组越界访问3.有符号数的常量表达式溢出4.new与delete5.vector6.空指针解引用 参考 一、未定义行为Undefined Behavior(UB) 在C++中，未定义行为（Undefined Behavior）指的是程序的行为没有定义、不可预测或不符合C++标准的情况。当程序中存在未定义行为时，编译器和运行时环境不会对其进行任何保证，可能会导致程序产生意外的结果。
以下是一些常见的导致未定义行为的情况：
访问未初始化的变量：如果使用未初始化的变量，其值是不确定的，可能包含任意的垃圾值。
数组越界访问：当访问数组时，如果超出了数组的有效索引范围，将导致未定义行为。
空指针解引用：当将空指针用作指针解引用，即访问其指向的内存区域时，将导致未定义行为。
除以零：在C++中，除以零是一种未定义行为，可能导致程序崩溃或产生无效的结果。
使用已释放的内存：如果使用已释放的内存，或者使用指向已释放内存的指针，将导致未定义行为。
栈溢出：当递归调用或者使用过多的局部变量导致栈空间耗尽时，将导致未定义行为。
多个线程之间的竞争条件：如果多个线程同时访问并修改共享数据而没有适当的同步机制，可能会导致未定义行为。
编译器使用x86_64 gcc13.2
C++版本：-std=c++20
1.返回一个未初始化的局部变量的值 UB写法：
#include &lt;cstdio&gt; int func() { int i; return i; } int main() { int i = func(); printf("%d\n",i); return 0; } 编译及运行结果：
Program returned: 0 Program stdout 0 使用编译期constexpr检测UB：
#include &lt;cstdio&gt; constexpr int func() { int i; return i; } int main() { constexpr int i = func(); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/609e01d4c9d1ce77a12adc4ded51fc63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54082bb15f1bd20562a3f41def6a7d74/" rel="bookmark">
			java中的同包权限（default）和保护权限（protected）哪个访问范围更大？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java相对于c++多了一个同包权限，于是就可能会问这个同包权限与保护权限相比，哪个范围更大？类的访问控制体现了封装的思想。如果画四个依次包含的圆来表示拥有某一权限的类成员的可访问范围，最外面的圆一定是公有权限（public），由外及里，依次为同包权限（default），保护权限（protected），私有权限（private）。
1.公有权限（public）
顾名思义，完全开放的，这样的类成员谁都能访问到。
2.保护权限（protected）
可以在类的内部访问；子类通过继承父类，也可以访问到父类的保护成员。
那么，在子类里能不能访问父类的对象的保护成员呢？不能的。可见这种保护成员的访问不能在不同的类的对象之间开放。
3.同包权限（default）
一个类的成员如果不使用访问权限关键字修饰，就是同包（default）权限的。
可以在类的内部访问；或者位于同一个包名内的其他类也能访问。两个类位于同一个包内，就叫做同包，它们不仅可以访问彼此的同包成员，也可以访问彼此的具有保护权限的成员。
那么，同包权限的类成员能被继承吗？这里要分为两种情况：子类与父类同包的，可以继承；子类与父类不同包，不能继承。
4.私有权限（private）
不用讲了吧，拥有的访问范围最小，只能在类的内部访问。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2187857fd9dd88fc73af68d549f2e26/" rel="bookmark">
			docker完成redis 三主三从
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 关闭防火墙+启动docker后台服务新建6个docker容器redis实例创建并运行docker容器实例 进入容器redis-node-1并为6台机器构建集群关系链接进入6381作为切入点，查看集群状态主从容错切换迁移案例容错切换迁移 主从扩容案例为主节点6387分配从节点6388主从缩容案例 关闭防火墙+启动docker后台服务 systemctl start docker 新建6个docker容器redis实例 创建并运行docker容器实例 拉取一个redis
docker pull redis:6.0.8 docker run -d --name redis-node-1 --net host --privileged=true -v /data/redis/share/redis-node-1:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6381 docker run -d --name redis-node-2 --net host --privileged=true -v /data/redis/share/redis-node-2:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6382 docker run -d --name redis-node-3 --net host --privileged=true -v /data/redis/share/redis-node-3:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6383 docker run -d --name redis-node-4 --net host --privileged=true -v /data/redis/share/redis-node-4:/data redis:6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2187857fd9dd88fc73af68d549f2e26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9423138d50cc1b464a293ecad40f70a/" rel="bookmark">
			SpringBoot封装接口返回值对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot封装接口返回值对象 Result.javaResultEnum.javaResultFactory.java Result.java public class Result { private int code; private String message; private Object result; public int getCode() { return code; } public void setCode(int code) { this.code = code; } public String getMessage() { return message; } public void setMessage(String message) { this.message = message; } public Object getResult() { return result; } public void setResult(Object result) { this.result = result; } public Result(int code, String message, Object data) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9423138d50cc1b464a293ecad40f70a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf66c5ba1bc456d286d8a783bee6bbe0/" rel="bookmark">
			如何查看虚拟机的IP地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、linux系统 在虚拟机的桌面上右键、打开终端 输入ifconfig 二、window2003 打开网络连接 属性 点击Internet协议 这就是自己虚拟机的ip地址 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdb5a484fdecc7797025598286a30d4a/" rel="bookmark">
			【鸿蒙开发】第九章 ArkTS语言UI范式-状态管理（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 前言 在前文的描述中，我们构建的页面多为静态界面。如果希望构建一个动态的、有交互的界面，就需要引入“状态”的概念。我们本章节来学习状态管理机制
2 概念 在声明式UI编程框架中，UI是程序状态的运行结果，用户构建了一个UI模型，其中应用的运行时的状态是参数。当参数改变时，UI作为返回结果，也将进行对应的改变。这些运行时的状态变化所带来的UI的重新渲染，在ArkUI中统称为状态管理机制。
自定义组件拥有变量，变量必须被装饰器装饰才可以成为状态变量，状态变量的改变会引起UI的渲染刷新。如果不使用状态变量，UI只能在初始化时渲染，后续将不会再刷新。 下图展示了State和View（UI）之间的关系。
View(UI)：UI渲染，指将build方法内的UI描述和@Builder装饰的方法内的UI描述映射到界面。State：状态，指驱动UI更新的数据。用户通过触发组件的事件方法，改变状态数据。状态数据的改变，引起UI的重新渲染。 3 状态管理 @Component struct MyComponent { // @Prop状态装饰器，状态变量 @Prop count: number = 0; // 常规变量 private increaseBy: number = 1; build() { Column() { Text("count:"+this.count+" increaseBy:"+this.increaseBy) .fontSize(30) .fontWeight(FontWeight.Bold) } .width('100%') } } @Component struct Parent { // @State状态装饰器，状态变量 @State count: number = 1; build() { Column() { Button("count++").onClick(()=&gt;{ console.log("yvan", "count:"+this.count) this.count = this.count + 1 }) // 从父组件初始化，覆盖本地定义的默认值 MyComponent({ count: this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdb5a484fdecc7797025598286a30d4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da6450dc662047f51a4b9381a80ee56d/" rel="bookmark">
			【鸿蒙开发】第八章 ArkTS语言UI范式-基础语法（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 前言 前面章节介绍了如何ArkTS语言UI范式-基础语法（一）。了解了自定义组件的创建与使用，本章节我们来学习下UI相关的装饰器。
2 @Builder装饰器 @Builder装饰器是自定义构建函数，ArkUI中提供了一种更轻量的UI元素复用机制@Builder，@Builder所装饰的函数遵循build()函数语法规则，开发者可以将重复使用的UI元素抽象成一个方法，在build方法里调用。
为了简化语言，我们将@Builder装饰的函数也称为“自定义构建函数”。
2.1 自定义组件内自定义构建函数 // 定义 @Builder MyBuilderFunction() { ... } // 使用 this.MyBuilderFunction() 自定义组件内可以定义多个@Builder方法，对该组件私有、不允许组件外调用，通过this访问自定义组件的状态变量而不是参数传递。
2.2 全局自定义构建函数 // 定义 @Builder function MyGlobalBuilderFunction() { ... } // 使用 MyGlobalBuilderFunction() 全局的自定义构建函数可以被整个应用获取，不允许使用this和bind方法。如果不涉及组件状态变化，建议使用全局的自定义构建方法。
2.3 参数传递规则 自定义构建函数的参数传递有按值传递和按引用传递两种，均需遵守以下规则：
参数的类型必须与参数声明的类型一致，不允许undefined、null和返回undefined、null的表达式。在@Builder修饰的函数内部，不允许改变参数值。@Builder内UI语法遵循UI语法规则。只有传入一个参数，且参数需要直接传入对象字面量才会按引用传递该参数，其余传递方式均为按值传递。 2.4 按引用传递参数 按引用传递参数时，传递的参数可为状态变量，且状态变量的改变会引起@Builder方法内的UI刷新。ArkUI提供$$作为按引用传递参数的范式。
class ABuilderParam { paramA1: string = '' paramB1: string = '' } @Builder function ABuilder($$ : ABuilderParam) {...} class ABuilderParam { paramA1: string = '' } @Builder function ABuilder($$: ABuilderParam) { Row() { Text(`UseStateVarByReference: ${$$.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da6450dc662047f51a4b9381a80ee56d/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/26/">«</a>
	<span class="pagination__item pagination__item--current">27/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/28/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>