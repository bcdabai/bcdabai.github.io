<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc2f49a0abbba8273708a65202d3cea0/" rel="bookmark">
			小知识点：ARM 架构 Linux 大数据集群基础环境搭建（Hadoop、MySQL、Hive、Spark、Flink、ZK、Kafka、Nginx、Node）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		换了 M2 芯片的 Mac，以前 x86 版本的 Linux 大数据集群基础环境搭建在 ARM 架构的虚拟机集群上有些用不了了，现在重新写一份基于 ARM 架构的，少数不兼容之外其他都差不多，相当于更新一版以前的
部分和 x86 的一样
x86 版：Linux 虚拟机：大数据集群基础环境搭建（Hadoop、Spark、Flink、Hive、Zookeeper、Kafka、Nginx）
目录 一、相关文件下载地址二、基础环境配置三、语言环境配置3.1 Java 环境安装3.2 Python 环境安装3.3 Scala 环境安装 四、大数据组件安装4.1 Hadoop 集群安装4.2 Docker 安装4.3 MySQL 安装4.4 Hive 安装4.5 Spark 安装4.6 Flink 安装4.7 Zookeeper 安装4.8 Kafka 安装4.9 Nginx 安装4.10 Node 安装4.11 Doris 安装 五、问题解决5.1 环境配置错误，丢失命令5.2 start-yarn.sh 无法启动 resourcemanager5.3 mysql 远程连接报错 Public Key Retrieval is not allowed5.4 Flink 提交任务报错 classloader.check-leaked-classloader5.5 Kafka 启动报错 UseG1GC5.6 Nginx 启动报错 Permission denied5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc2f49a0abbba8273708a65202d3cea0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b566a87f6a227be6a573ed2c36e54deb/" rel="bookmark">
			Jaccard 评价指标的简介与图示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Jaccard 评价指标 Jaccard指标，也称为Jaccard相似系数或Jaccard相似度，是一种用于比较两个样本集合相似性的统计指标。它定义为两个集合的交集除以它们的并集。
公式如下：
J ( C 1 , C 2 ) = ∣ C 1 ∩ C 2 ∣ ∣ C 1 ∪ C 2 ∣ J(C_1,C_2) = \frac{|C_1∩C_2|}{|C_1∪C_2|} J(C1​,C2​)=∣C1​∪C2​∣∣C1​∩C2​∣​
图示如下:
其中， C 1 C_1 C1​和 C 2 C_2 C2​分别表示两个集合， ∣ C 1 ∣ |C_1| ∣C1​∣表示集合 C 1 C_1 C1​的元素个数， ∣ C 2 ∣ |C_2| ∣C2​∣表示集合 C 2 C_2 C2​的元素个数， ∣ C 1 ∩ C 2 ∣ |C_1∩C_2| ∣C1​∩C2​∣表示集合 C 1 C_1 C1​和集合 C 2 C_2 C2​的交集元素个数， ∣ C 1 ∪ C 2 ∣ |C_1∪C_2| ∣C1​∪C2​∣表示集合 C 1 C_1 C1​和集合 C 2 C_2 C2​的并集元素个数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b566a87f6a227be6a573ed2c36e54deb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc2a31a268fa7b5a1a13593e15c83d4b/" rel="bookmark">
			Excel VBA 基础部分（变量声明、三大语句）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 Excel VBA 基础部分 一、变量声明语句二、赋值语句、条件语句、循环语句（一）赋值语句1. Let语句2. Set （二）条件语句1. If...Then...Else语句2. Select Case语句3. Choose 函数。从参数列表中选择并返回一个值4. IIf 函数。根据表达式的值从两个里面选择一个5. Switch 函数。计算表达式的列表并返回与列表中第一个结果为 True 的表达式关联的 Variant 值或表达式 （三）循环语句1. While...Wend语句2. Do...Loop语句3. For Each...Next语句4. For...Next 语句 Excel VBA 基础部分 一、变量声明语句 '定义变量和分配存储空间 Dim [ WithEvents ] varname [ ( [ subscripts ] ) ] [ As [ New ] type ] . . . 部分说明withEvents可选。该关键字指定varname是对象变量，用于响应触发一个ActiveX对象。WithEvents只在类模块有效。使用它你可以定义多个独立的对象，但是不能使用该关键字创建数组，也不能与New关键字一起使用。varname必需。变量名称subscripts可选。数组变量的维数；最多可达60维。 该subscripts参数使用以下语法： [ lower To ] upper [ , [ lower To ] upper ] .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc2a31a268fa7b5a1a13593e15c83d4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6200708d7cb79801ddbb852f64c3790c/" rel="bookmark">
			Java监听器的理解与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 初识监听器Listener接口分类ServletContext监听器HttpSession监听器ServletRequest监听器 Java代码实现ServletContextListenerServletContextAttributeListenerHttpSessionListenerHttpSessionAttributeListenerHttpSessionActivationListenerHttpSessionBindingListenerServletRequestListenerServletRequestAttributeListener 模仿监听器Demo 初识监听器 == 什么是监听器==
监听器也叫Listener，是Servlet的监听器，它可以监听客户端的请求、服务端的操作等。通过监听器，可以自动激发一些操作，比如监听在线的用户的数量。
监听器，字面上的理解就是监听观察某个事件（程序）的发生情况，当被监听的事件真的发生了的时候，事件发生者（事件源） 就会给注册该事件的监听者（监听器）发送消息，告诉监听者某些信息，同时监听者也可以获得一份事件对象，根据这个对象可以获得相关属性和执行相关操作。
监听器模型涉及以下三个对象，模型图如下：
（1）事件：用户对组件的一个操作，或者说程序执行某个方法，称之为一个事件，如机器人程序执行工作。（2）事件源：发生事件的组件就是事件源，也就是被监听的对象，如机器人可以工作，可以跳舞，那么就可以把机器人看做是一个事件源。（3）事件监听器（处理器）：监听并负责处理事件的方法，如监听机器人工作情况，在机器人工作前后做出相应的动作，或者获取机器人的状态信息。
执行顺序如下：
1、给事件源注册监听器。
2、组件接受外部作用，也就是事件被触发。
3、组件产生一个相应的事件对象，并把此对象传递给与之关联的事件处理器。
4、事件处理器启动，并执行相关的代码来处理该事件。 java监听器监听的内容是什么？监听器作用在哪个事件上？是在哪配置的监听内容的？
首先，监听器要怎么实现？
Java事件由事件类和监听接口组成，自定义一个事件前，必须提供一个事件的监听接口以及一个事件类。JAVA中监听接口是继承java.util.EventListener的类，事件类继承java.util.EventObject的类。很多基本的事件系统已经为我们定义好了，我们只要学会调用即可，但是为了更加灵活地满足特定的需求，我们有时候也需要自定义事件。
监听器的实质是什么？
一个类实现某个监听器接口，然后实现接口对应的方法，达到监听具体事项的动作。
Listener接口分类 监听器的接口有哪些？
监听器接口分三类：ServletContext，HttpSession，ServletRequest。
ServletContext监听器 ServletContext
ServletContextListener 监听ServletContext对象ServletContextAttributeListener 监听对ServletContext属性的操作，比如说增加，删除，修改 HttpSession监听器 HttpSession
HttpSessionListener 监听Session对象HttpSessionAttributeListener 监听Session的属性操作HttpSessionActivationListener 监听HTTP会话的active和passivate情况，passivate是指非活动的session被写入持久设备（如硬盘），active相反。HttpSessionBindingListener 监听器感知Session绑定的事件监听器 注意：Servlet 规范中定义了两个特殊的监听器接口"HttpSessionBindingListener和HttpSessionActivationListener"来帮助JavaBean
对象了解自己在Session域中的这些状态： ，实现这两个接口的类不需要 web.xml 文件中进行注册。
HttpSessionActivationListener 监听
实现了HttpSessionActivationListener接口的 JavaBean 对象可以感知自己被活化和钝化的事件 活化:javabean对象和Session一起被反序列化(活化)到内存中（硬盘到内存）； 钝化:javabean对象和Session一起序列化到硬盘中（内存到硬盘）； javabean对象存在Session中，当服务器把session序列化到硬盘上时，如果Session中的javabean对象实现了Serializable接口 那么服务器会把session中的javabean对象一起序列化到硬盘上，javabean对象和Session一起被序列化到硬盘中的这个操作称之为钝化 如果Session中的javabean对象没有实现Serializable接口，那么服务器会先把Session中没有实现Serializable接口的javabean对象移除 然后再把Session序列化(钝化)到硬盘中； 当绑定到 HttpSession对象中的javabean对象将要随 HttpSession对象被钝化之前， web服务器调用该javabean对象的 sessionWillPassivate方法， 这样javabean对象就可以知道自己将要和 HttpSession对象一起被序列化(钝化)到硬盘中 当绑定到HttpSession对象中的javabean对象将要随 HttpSession对象被活化之后， web服务器调用该javabean对象的sessionDidActive方法， 这样javabean对象就可以知道自己将要和 HttpSession对象一起被反序列化(活化)回到内存中 HttpSessionBindingListener 监听
保存在Session域中的对象可以有多种状态： （1）绑定(session.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6200708d7cb79801ddbb852f64c3790c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db543b7202c98205d4c6a081229cdec3/" rel="bookmark">
			Mac nvm install failed python: not found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mac nvm install failed python: not found 问题解决方法 问题 环境
Mac，Ventura 13.2，M2。
安装出现错误
$&gt;./configure --prefix=/Users/xxx/.nvm/versions/node/v12.22.12 &lt; ./configure: line 3: exec: python: not found nvm: install v12.22.12 failed! 解决方法 到 App 文件夹，并且打开
cd /System/Applications/Utilities/ open . 找到 终端.app，右键 -&gt; 显示简介，钩上 Rosetta
记得改完 Rosetta 之后，要重启 终端.app，完全退出，然后再打开 终端.app
python3 命名 python
echo "alias python=/usr/bin/python3" &gt;&gt; ~/.zshrc source ~/.zshrc echo "alias python=/usr/bin/python3" &gt;&gt; ~/.bash_profile source ~/.bash_profile 这样就可以下载了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/509785ae728b9603fb96eff32d6f6fea/" rel="bookmark">
			《计算机网络：自顶向下方法》读书笔记 1：概论
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 因特网 因特网：一个世界范围的计算机网络，即它是一个互联了遍及全世界的数以亿计的计算设备的网络。
用因特网术语来说，所有这些设备都称为主机(host)或端系统(end system)。主机=端系统。
1.1 端系统 端系统通过通信链路和分组交换机连接到一起(通信链路-传输；分组交换机-转发)。
不同类型的通信链路由不同类型的物理媒体组成，如同轴电缆、铜线、光纤和无线电频谱。
当今市面上最流行的两种分组交换机类型是路由器和链路层交换机。链路层交换机通常用于接入网中，而路由器通常用于网络核心中。
1.2 ISP 端系统通过因特网服务提供商(Internet Service Provider, ISP)接入因特网。每个ISP是一个由多个分组交换机和多段通信链路组成的网络。
与因特网相连的端系统提供了一个应用程序编程接口(Application Programming Interface, API)，API规定了运行在一个端系统上的软件请求因特网基础设施向运行在另一个端系统上的特定目的地软件交付数据的方式。
1.3 分组和路径 当一台端系统要向另一台端系统发送数据时，发送端系统将数据分段，并为每段加上首部字节。由此形成的信息包用计算机网络的术语来说称为分组(packet)。这些分组通过网络发送到目的端系统，在那里被装配成初始数据。
从发送端系统到接收端系统，一个分组所经历的一系列通信链路和分组交换机称为通过该网络的路径。
1.4 协议 端系统、分组交换机和其他因特网部件都要运行一系列协议(protocol)，这些协议控制因特网中信息的接收和发送。TCP(Transmission Control Protocol, 传输控制协议)和IP(Internet Protocol, 网际协议)是因特网中两个最为重要的协议。
一个协议定义了在两个或多个通信实体之间交换的报文格式和次序，以及报文发送和/或接收一条报文或其他事件所采取的动作。
掌握计算机网络领域知识的过程就是理解网络协议的构成、原理和工作方式。
2 端系统 端系统有时被进一步划分为客户(client)和服务器(server)。
2.1 接入网 接入网：将端系统连接到其边缘路由器的物理链路。
边缘路由器：端系统到任何其他远程端系统的路径上的第一台路由器。
宽带住宅接入有两种最流行的类型：数字用户线(Digital Subscriber Line, DSL)和电缆。
DSL利用了本地电话公司现有的的本地电话基础设施。使用DSL时，每个用户的DSL调制解调器使用现有的电话线与位于本地电话公司的本地中心局中的数字用户线接入复用器(DSLAM)来交换数据。
电缆因特网接入利用了有线电视公司现有的有线电视基础设施。光缆将电缆头端连接到地区枢纽，从这里使用传统的同轴电缆到达各家各户和公寓。电缆调制解调器端接系统(CMTS)起到如同DSL网络的DSLAM类似的功能，即将来自许多下行家庭中的电缆调制解调器发送的模拟信号转换回数字形式。
本书出版时还有一种新兴技术：光纤入户(Fiber To The Home, FTTH)，从本地中心局直接到家庭提供一条光纤路径。一般来说，从中心局出来的每根光纤实际上由许多家庭共享，直到相对接近这些家庭的位置，该光纤才分成每户一根光纤。进行这种划分的有两种竞争性的光纤分布体系结构：主动光纤网络(AON)和被动光纤网络(PON)。
下图是使用PON分布体系结构的FTTH。每个家庭具有一个光纤网络端接器(ONT)，在每个家庭中，用户将一台家庭路由器与ONT相连，ONT再由专门的光纤连接到邻近的分配器。分配器把一些家庭集结到一根共享的光纤，该光纤再连接到本地电话和公司的中心局中的光纤线路端接器(OLT)。OLT提供了光信号和电信号之间的转换，经过本地电话公司路由器与因特网相连。
在PON体系中，所有从OLT发送到分配器的分组在分配器处复制。
以太网：在公司和大学校园以及在越来越多的家庭环境中，通常是用局域网(LAN)将端用户连接到边缘路由器。以太网是当前最为流行的接入技术。
以太网用户使用双绞铜线与一台以太网交换机相连，形成交换机网络，再与更大的因特网相连。
无线LAN：基于IEEE 802.11技术的无线LAN接入，更为通俗地称为WiFi，目前几乎无处不在。
2.2 物理媒体 物理媒体划分为两类：导引型媒体和非导引型媒体。对于导引型媒体，电波沿着固体媒体前行，如光缆、双绞铜线或同轴电缆。对于非导引型媒体，电波在空气或外层空间中传播，如无线局域网或数字卫星频道。
双绞铜线：最便宜，最为普遍。由两根隔离的铜线组成，每根大约1mm粗，以规则的螺旋形式排列着。通常许多双绞线捆扎在一起形成一条电缆。
同轴电缆：由两个铜导体组成，但是这两个导体是同心的而不是并行的。
光纤：一种细而柔软的、能够导引光脉冲的媒体，每个脉冲表示一个比特。
陆地无线电信道：无线电信道承载电磁频谱中的信号，不需要安装物理线路，并具有穿透墙壁、提供与移动用户的连接以及长距离承载信号的能力。
卫星无线电信道：一颗通信卫星连接两个或多个位于地球的微波发射方/接收方，它们被称为地面站。该卫星在一个频段上接收数据，使用一个转发器再生信号，并在另一个频率上传输信号。通信中常使用两类卫星：同步卫星和近地轨道卫星。
3 网络核心 3.1 分组交换 在各种网络应用中，端系统彼此交换报文(message)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/509785ae728b9603fb96eff32d6f6fea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bc5e5083743a8d2b6dce4c5809e2852/" rel="bookmark">
			ubuntu22.04服务器的双网卡绑定的具体操作步骤和配置文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 ubuntu22.04服务器的双网卡绑定具体步骤可以分成以下五步,下面按步骤操作
一、安装必要软件 sudo apt install net-tools 二、编辑/etc/netplan/01-network-manager-all.yaml 将原内容
network: version: 2 renderer: NetworkManager 修改为
network: version: 2 ethernets: enp1s0: dhcp4: no optional: true enp7s0: dhcp4: no optional: true bonds: bond0: dhcp4: no addresses: - 10.168.188.219/24 nameservers: addresses: - 10.168.188.1 - 192.168.1.1 interfaces: - enp1s0 - enp7s0 parameters: mode: balance-alb mii-monitor-interval: 100 lacp-rate: fast transmit-hash-policy: layer2 这种方式为自动获取IP的方式,系统将通过连接的DHCP服务器自动获取其IP地址,其中enp1s0,enp7s0为网卡名称,通过ifconfig命令查看
ifconfig 或者使用以下的内容替换对应的IP地址,可以设置固定的局域网IP
network: version: 2 ethernets: enp1s0: dhcp4: no optional: true enp7s0: dhcp4: no optional: true bonds: bond0: dhcp4: no addresses: - 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bc5e5083743a8d2b6dce4c5809e2852/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbb3cb574f1464cd38dda14f9c781e49/" rel="bookmark">
			“缩进中制表符和空格的使用不一致”在Python中意味着什么以及如何修复它
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		了解为什么 Python 中的缩进如此重要，以及如何修复任何错误。
缩进代码块是编程的重要组成部分;它有多种用途。首先，它提高了可读性。想象一下，从食谱中删除所有格式，只留下成分列表和说明之间的空格。这对厨师来说很难遵循。在 Python 中，缩进还控制代码的行为方式。如果更改缩进，则可以更改执行代码的哪些部分以及执行时间。
了解如何正确缩进代码非常重要。本文将解决有关缩进的特定问题，即如何处理以下 Python 错误消息：“缩进中制表符和空格的使用不一致”。
缩进 101 我们将通过一个简单的示例来说明 Python 中的缩进是如何工作的。下面的代码块有一个 for 循环，可以将一些数字打印到屏幕上。完成后，它将打印最后一行，并显示消息“done”，因为这两个语句缩进到不同的级别。。print()print()
&gt;&gt;&gt; for index in range(3):
... print(index)
... print('done')
结果如下：
0
1
2
done
现在进行下一个测试，尝试将最后一行缩进到与该行相同的级别，然后再次运行代码块。您应该注意到消息“done”直接打印在每个索引之后，因为它现在在循环中。通过更改代码块的缩进，程序的行为已更改。print(index)for
空格是怎么回事？ 大多数其他语言使用大括号 （） 来告诉编译器代码块的开始和结束位置。Python 使用空格来表示代码块;从这个意义上说，它是奇怪的一个。但是，使用空格进行缩进会释放符号以用于其他目的。通过在 Python 中不使用大括号来指示缩进，此符号可用于创建字典。这是一个优势，因为键盘上的符号数量少于要使用符号的事物数量。{}
Python 不会强迫你用制表符或空格缩进。两者都会起作用;但是，您确实需要保持一致。如果在同一程序中混合使用制表符和空格，则会收到简介中提到的错误。我们将在下一节中仔细研究这一点。
制表符与空格 让我们演示一下为什么混合制表符和空格是一个坏主意。要在简介中重现错误，请打开一个基本的文本编辑器（如记事本）并编写以下内容 for 循环：
&gt;&gt;&gt; for index in range(3):
... print(index)
... print('done')
该行应用制表符缩进，然后该行应缩进等效的空格数;两条线缩进到同一级别。将文件另存为 test.py。在命令提示符下，运行：print(index)print('done')
&gt;&gt;&gt; python test.py
打印到命令提示符的输出将包括有关错误发生位置的信息以及消息：
TabError: inconsistent use of tabs and spaces in indentation
由于制表符和空格不能很好地结合在一起，现在的问题转向哪个最适合用于缩进代码。乍一看，选项卡似乎更可取，因为它节省了一些击键。但是在不同的 IDE 和代码编辑器中，制表符的长度可能不同，通常为 4 个或 8 个空格。如果程序在不同的编辑器中开发，这可能是一个问题;在一个编辑器中使用制表符缩进后，同一制表符在其他编辑器中的长度可能不同。另一方面，空格仅占用一个字符并避免了此潜在问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbb3cb574f1464cd38dda14f9c781e49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/314d578c96945450cbf3472da76912e7/" rel="bookmark">
			thymeleaf简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Thymeleaf是适用于Web和独立环境的现代服务器端Java模板引擎。
2. Thymeleaf的主要目标是为您的开发工作流程带来优雅的自然模板 -HTML可以在浏览器中正确显示，也可以作为静态原型工作，从而可以在开发团队中加强协作。
3. Thymeleaf拥有适用于Spring Framework的模块，与您喜欢的工具的大量集成以及插入您自己的功能的能力，对于现代HTML5 JVM Web开发而言，Thymeleaf是理想的选择-尽管它还有很多工作要做。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fc5b580cf1764f32b7675bc06d12489/" rel="bookmark">
			Transformer架构理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考： 1. Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N. Gomez, Łukasz Kaiser, and Illia Polosukhin. 2017. Attention is all you need. In Proceedings of the 31st International Conference on Neural Information Processing Systems (NIPS'17). Curran Associates Inc., Red Hook, NY, USA, 6000–6010. 2. https://blog.csdn.net/qq_48314528/article/details/122160800 3. https://blog.csdn.net/yeen123/article/details/125104680 4. https://blog.csdn.net/nocml/article/details/110920221?spm=1001.2014.3001.5502 5. https://www.bilibili.com/video/BV1Di4y1c7Zm/?spm_id_from=333.337.search-card.all.click 学习背景： 专业非NLP非CV，只是学习Transformer模型，理解各部分功能 如果想要深度理解建议仔细阅读以上的参考博客 本博客基本上是论文翻译，可以快速过一遍原论文，代码块中为个人对Transformer模型的理解 如果有理解不当之处，欢迎批评指正！ Transformer的优势：
Transformer模型架构避免了循环，它完全依赖注意力机制来刻画输入和输出的全局关系，而且能够显著地提高并行化；关联来自两个任意输入或输出位置的信号所需的操作数量随着位置之间距离的增加而增长，这种增长在ConvS2S中是线性的，在ByteNet中是对数的。这使得学习较远位置的相关性很困难。在Transformer中，操作的数量被减少到一个常数，尽管由于平均注意力权重位置而降低了有效分辨率，但是这种影响可以用多头注意力来抵消。
// 此处为个人对Transformer各个组成部分的简单理解 1. Input Embedding / Output Embedding 相当于复制和扩维操作。复制操作是把input复制三份，用来得到Query, Key and Value；扩维操作是 Query, Key and Value扩大为d_model=512维，再与各自的随机矩阵相乘 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fc5b580cf1764f32b7675bc06d12489/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01e1b1d4bd1a1e32f357fd4aa1b2f19c/" rel="bookmark">
			QPython实例03-制作【ONE一个】可视化应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 QPython 3c在大佬的改进下，拥有了基于sl4a的FullScreenWrapper2全屏框架。文章将用该框架制作我们的可视化应用【ONE一个】。
二、最终效果如下 三、准备工作 AIDE： 使用布局助手生成xml布局代码QPython 3C： 使用FullScreenWrapper2制作可视化应用 以上应用在后台回复应用名称即可获取下载链接，如【AIDE】
四、实现思路 使用AIDE生成布局代码分析网站获取ONE api使用FullScreenWrapper完成可视化应用 使用AIDE生成布局代码 在aide新建项目，在app/src/main/res/layout下新建xml，点击右上角的图片按钮进入设计界面，按照以下进行设计，在qpython中展示可能需要做调整。
然后返回，复制xml代码，xml代码如下：
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="fill_parent" android:layout_height="fill_parent" android:gravity="top" android:orientation="vertical" android:background="#FFF8F9FD"&gt; &lt;LinearLayout android:orientation="horizontal" android:layout_width="match_parent" android:layout_height="0dp" android:layout_weight="1" android:background="#FF8BC6A7"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_weight="6" android:text="ONE•一个" android:id="@+id/bar_title" android:textSize="8sp" android:layout_gravity="left|center_vertical" android:textColor="#FFFFFFFF" android:layout_marginLeft="10dp"/&gt; &lt;Button android:layout_width="0dp" android:layout_height="wrap_content" android:layout_weight="1" android:text="分享" android:gravity="left" android:layout_gravity="right" android:id="@+id/btn_share" android:textColor="#FFFFFFFF" android:background="#FF8BC6A7"/&gt; &lt;Button android:layout_width="0dp" android:layout_height="wrap_content" android:layout_weight="1" android:layout_gravity="right" android:text="退出" android:gravity="left" android:id="@+id/btn_exit" android:textColor="#FFFFFFFF" android:background="#FF8BC6A7" android:layout_marginLeft="12dp"/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:orientation="vertical" android:layout_width="match_parent" android:layout_height="0dp" android:layout_weight="19" android:background="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01e1b1d4bd1a1e32f357fd4aa1b2f19c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa1d96cfc236c278d21c0c83c7b5e3c8/" rel="bookmark">
			SpringBoot从入门到精通---基础篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot 一、基础篇 1.1 入手项目 注意：如果这里SpringBoot1Application（启动程序）是灰色的，你右键点击pom.xml把它作为Maven项目就可以启动
BookController类中的代码,启动后访问路径是http://localhost:8080/book就可以看到有显示了
package com.itheima.controller; import org.springframework.web.bind.annotation.*; @RestController @RequestMapping("/book") public class BookController { @GetMapping public String getById(){ System.out.println("hello,springboot"); return "springzBoot run"; } } 小技巧隐藏文件夹
1.2 springboot模块了解 入门案例解析—查看pom.xml 开发SpringBoot程序要继承spring-boot-starter-parentspring-boot-starter-parent中定义了若干个依赖管理继承parent模块可以避免多个依赖使用相同技术时出现依赖版本冲突继承parent的形式也可以采用引入依赖的形式实现效果 &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;${spring-boot.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; starter 1.开发SpringBoot程序需要导入坐标时通常导入对应的starter
2.每个不同的starter根据功能不同，通常包含多个依赖坐标
3.使用starter可以实现快速配置的效果，达到简化配置的目的
◆SpringBoot中常见项目名称，定义了当前项目使用的所有依赖坐标，以达到减少依赖配置的目的
●parent
◆所有SpringBoot项目要继承的项目，定义了若干个坐标版本号(依赖管理，而非依赖)，以达到减少依赖冲突的目的
◆spring-boot-starter-parent各版本间存在着诸多坐标版本不同
●
实际开发
◆使用任意坐标时，仅书写GAV中的G和A,V由SpringBoot提供，除非SpringBoot未提供对应版本V
◆如发生坐标错误，再指定Version（要小心版本冲突）
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; 启动方式 @SpringBootApplication public class SpringBoot1Application { public static void main(String[] args) { SpringApplication.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa1d96cfc236c278d21c0c83c7b5e3c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1669d31bca7920f726dcf923a941a771/" rel="bookmark">
			详解Tomcat下载安装以及IDEA配置Tomcat（2023最新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 步骤一：首先确认自己是否已经安装JDK步骤二：下载安装Tomcat步骤三：Tomcat配置环境变量步骤四：验证Tomcat配置是否成功步骤五：为IDEA配置Tomcat 步骤一：首先确认自己是否已经安装JDK jdk各版本通用安装配置及检验：https://blog.csdn.net/m0_48170265/article/details/129070240
步骤二：下载安装Tomcat Tomcat下载官网：https://tomcat.apache.org/
在左侧Download处选择对应Tomcat版本：
一般选择64位：
步骤三：Tomcat配置环境变量 右键点击任务栏Windows（开始）处，依次选择系统和高级系统设置
选择环境变量
在系统变量这一栏里选择新建:
变量名：
CATALINA_HOME
变量值：
E:\ProgramFile\Tomcatlapache-tomcat-8.5.81（解压后的路径）
再找系统变量中的Path，添加：
%CATALINA_HOME%\bin
之后一直点击确定
步骤四：验证Tomcat配置是否成功 首先win+R输入cmd回车，然后再DOS窗口输入startup.bat回车。
之后会出现Tomcat启动窗口。
或者在Tomcat安装目录下点击 startup.bat ，效果是一样的
若出现乱码，可用Notepad++或记事本查看 conf 目录下的 logging.properties
将此处的 UTF-8 改为 GBK ：
再次打开startup.bat：
出现上图所示的黑窗口代表配置成功。
如果出现报错或者一闪而过，可能是端口号被占用。Tomcat默认窗口时8080。
可以尝试重启电脑，再启动Tomcat试试。不行的话，就修改Tomcat端口号。
如果配置成功，打开浏览器，输入http://localhost:8080/
若如下图所示，则表示成功。
注意：之前那个黑窗口一定不能关闭，否则打不开这个页面；另外编程需要启用Tomcat服务器时，黑窗口也不能关，否者无法使用Tomcat服务器。
步骤五：为IDEA配置Tomcat 创建web项目后我们需要配置tomcat才能运行，配置如下：
点击右上角的下三角，选择 Edit Configurations...
点击 + 号 → 下滑找到Tomcat Server → 选择Local
若下滑找不到Tomcat Server，可能需要点击下面的more展开
点击configuration，点击+号，在接下来的Tomcat Home: 中选择自己的tomcat目录
选择:
基本无须更改
选择“+”→“web” ,选择web.xml和webRoot
Path： E:\IdeaProject\项目名称\webRoot\WEB-INF\web.xml
Web resource Directories：E:\IdeaProject\项目名称\webRoot
选择“+”，点击 java，找到 webroot 下面的lib包
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1669d31bca7920f726dcf923a941a771/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08ebfc404b3cb99a1717b4976bc149bf/" rel="bookmark">
			栈迁移学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考资料https://blog.csdn.net/qq_38154820/article/details/106330238
原理 栈迁移的技巧是劫持栈指针执行攻击者所能控制的内存，在相应位置进行ROP，来解决栈溢出空间大小不足的问题
我们进入一个 函数的时候，会执行call指令
call func(); //push eip+4; push ebp; mov ebp,esp;
call func() 执行完要退出的时候要进行与call func相反的操作（恢复现场）维持栈平衡！
leave; //mov esp,ebp; pop ebp;
ret ; // pop eip
栈迁移 的核心思想就是 将栈 的 esp 和 ebp 转移到一个 输入不受长度限制的 且可控制 的 址处，通常是 bss 段地址！ 在最后 ret 的时候 如果我们能够控制得 了 栈顶 esp指向的地址 就想到于 控制了 程序执行流！
32位程序栈迁移 检查保护 fanfan@ubuntu:~$ cyclic 200 aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab pwndbg&gt; r Starting program: /home/fanfan/pwn challenges/migration Try your best : aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab Program received signal SIGSEGV, Segmentation fault.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08ebfc404b3cb99a1717b4976bc149bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a3192af2399c9b3e5ffebbb71ebbace/" rel="bookmark">
			详解Maven下载安装及IDEA配置Maven （2023最新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Maven介绍二、下载Maven三、配置Maven环境四、在Idea上配置Maven工具 一、Maven介绍 1.Maven翻译为“专家“， ”内行”的意思，是著名Apache公司下基于Java开发的开源项目。
2.Maven项目对象模型（POM）是一个项目管理工具软件，可以通过简短的中央信息描述来管理项目的搭建，报告和文档等步骤。
3.Maven是一个项目管理的工具，可以对项目进行构建、依赖的管理。
PS：通俗的讲maven就是专门用于构建和管理项目的工具，他可以帮助我们去下载我们所需要jar包，帮助我们去管理项目结构，帮助我们去实现项目的维护、打包等等…(Gradle的项目搭建方式，可能将在不久的未来取代Maven，发展历程： Make –&gt; Ant –&gt; Maven –&gt; Gradle)
二、下载Maven Maven下载官网：http://maven.apache.org/docs/3.3.1/release-notes.html
1、左侧或右上角点击 Download
2、下载第二个Binary zip archive对应的Link
3、下载其他版本，点击下面的 archives
4、再选择你想要下载的Maven版本（下面以maven3.6.3为例）
5、选择下载maven3.6.3后，点击 binaries/
7、选择 apache-maven-3.6.3-bin.zip ，完成之后得到安装包
三、配置Maven环境 1、将下载好的压缩包，解压至你想要安装的目录下，并复制Maven的根目录（以apache-maven-3.6.3为例）。
2、配置环境变量
此电脑&gt;属性&gt;高级系统设置&gt;环境变量
新建添加如下：
2.1 变量名：
MAVEN_HOME
2.2 变量值：
E:\configurations\Maven\apache-maven-3.6.3 （自己Maven安装的根目录）
2.3 在Path中新建添加：
%MAVEN_HOME%\bin
3、启动CMD命令工具，输入：
mvn -v
出现上述界面，则表示成功安装Maven
4、修改仓库位置
在开发Maven项目过程中会下载非常多的jar包，而Maven默认的下载位置在C盘，导致C盘很容易撑爆，且C盘容易损毁。
1）默认的Maven仓库位置为：
C:\Users.m2\repository
2）在其他盘符再创建用于Maven仓库的文件夹（E:\Repositories\Mavan）
存放Maven下载的jar包（PS：仓库文件夹名字可随意设置）
打开Maven安装目录下的 conf/settings.xml 文件
找到 &lt;localRepository&gt; 标签，在标签下添加你刚创建的Maven仓库文件夹根目录,如：
&lt;localRepository&gt;E:\Repositories\Mavan&lt;/localRepository&gt;
5、 修改Maven仓库下载镜像
如果直接以默认Maven的方式搭建Java项目时，下载所需的jar包需要的时间比较长。（PS：下载慢的原因是服务器在国外，要翻墙才能下载，大约速度在0.9K/s的下载速度），所以我们安装好Maven时，要及时的修改Maven下载的镜像地址，最好改为国内的下载镜像，例如阿里云中央仓库，华为云中央仓库。
1）再在setting.xml文件中找到 &lt;mirrors&gt; 标签，在标签下添加阿里云镜像仓库：
&lt;mirrors&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a3192af2399c9b3e5ffebbb71ebbace/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8107e4177a8be24b975b39ea6e82128/" rel="bookmark">
			Win10按章cuda与cudnn
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		两篇blog参考第一篇的安装步骤与第二篇的环境变量设置：
https://blog.csdn.net/u011473714/article/details/95042856
https://blog.csdn.net/qq_37296487/article/details/83028394
NVIDIA CUDA各版本下载链接：https://blog.csdn.net/weixin_44177494/article/details/120444922
cudnn绕过nvidia登录下载：https://blog.csdn.net/qq_40004311/article/details/105076869
cudnn各版本下载链接：https://developer.nvidia.com/rdp/cudnn-archive
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8878db15ce23da2d9e1b41bc99405c83/" rel="bookmark">
			Win10 多种方式解决无法安装.Net3.5的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、前言 目前很多电脑系统中默认不带 .Net3.5 的，但有些软件的运行时需要 .Net3.5 的支持。在安装 .Net3.5 的时候，会遇到各种各样无法安装的问题。下面一一罗列出来供大家参考。
2、步骤 2.1 Windows 提供的下载安装功能 win + R 打开运行框，输入 control ，如下图所示：
确定后弹出控制面板，选择程序==&gt;启动或关闭Windows功能，
勾选.Net3.5后确定，弹出搜索框，并提示下载文件，如下图：
点击下载，等待下载完后重启即可。
2.2 Windows 自带的下载功能无法下载 以为一切OK，准备关机重启，没想到 Windows 服务太菜，有时上述步骤无法下载，出现Windows 无法完成请求的更改，如下图所示，则需要进一步解决。
首先Win + R打开运行框，输入services.msc，确定后弹出服务弹窗。找到windows installer服务，如未启动，双击后弹出属性界面来将其启动。
然后再找到Windows Update服务，双击打开属性窗口，将‘启动类型’改为自动，如下图操作。
最后Win + R打开运行框，输入cmd进入 doc 命令行界面，输入 sfc /scannow，等待扫描完后重启即可。
2.3 sfc /scannow 无法正常扫描 事与愿违，上述步骤有时还是不行，真想砸电脑，有些文件无法修复，如下图所示，又该何去何从呢？
上图这种情况的话则在命令行依次输入DISM.exe /Online /Cleanup-image /Scanhealth 和 DISM.exe /Online /Cleanup-image /Restorehealth，等待安装，注意反斜杠前有空格。
等待部署完后，再次输入sfc /scannow，等待扫描完后重启即可。
2.4 手动安装 搞了那么多步骤，结果发现，前面的都前功尽弃了，胸膛快炸开了。没办法，只能继续硬着头皮继续寻找解决办法。
经一步步查找资料发现，还有一种，就是找Windows 10 系统的 ios镜像 文件，也就是重装系统用到的文件。解压该文件后，找到目录下的source/sxs文件夹，将其放在 D 盘或 E 盘随便哪个盘的根目录下。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8878db15ce23da2d9e1b41bc99405c83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc5267515d2973cae59f0da84235b42b/" rel="bookmark">
			路由表的更新算法（解题思路）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		某时刻路由器R6的路由表如下表：
第一步：将更新信息的距离+1，把下一路由改为发来更新信息的路由
R4更新表：（黄字为解释）
目的网络
距离
下一跳路由器
net1
3 =2+1
R4 R1在R4的下一跳
net2
5 =4+1
R4 R2在R4的下一跳
net3
4 =3+1
R4 R9在R4的下一跳
第二步：与原表对比 R6的原表：
目的网络
距离
下一跳路由器
net2
3
R4
net3
4
R5
目的网络net1：R6表自身没有net1，直接加上（更新net1）。
目的网络net2：R6表net2的下一跳路由器是指向R4的，所以net2也要更新。（因为R4更新了，旧的R4没用了，所以要改）
目的网络ne3：R6表net3的下一跳路由器不是R4。需要选择距离，4=4，自身的和更新的距离一样，不需要进行更新。（若R4更新表比R6原表距离小，才需要更新数据）
R6更新后的结果：（被更新的用黄色标识）
目的网络
距离
下一跳路由器
net1
3
R4
net2
5
R4
net3
4
R5
总结：
先看目的网络是否存在，再看路由器有没有被更新了，最后比距离大小。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dc5e17a58ee5354c46f80c70b39148f/" rel="bookmark">
			远程桌面无法连接远程计算机是什么原因？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多人在准备用远程控制另一台电脑进行相关操作的时候，会出现提示说‘远程桌面由于以下原因无法连接到远程计算机’，那么为什么会发生这种问题，以及出现这种问题该怎么解决呢？一起来看看吧
其实，出现此错误的原因有多种，除去“配置不正确”和“网络问题”。还有以下常见原因，例如
1、远程计算机未启用远程桌面；
2、Windows防火墙禁止远程桌面通过；
3、远程桌面服务的问题；
4、用户权限分配的问题；
远程桌面无法连接远程计算机怎么解决？ 在解决中这个问题之前首先我们要检查一下自己的远程计算机是否可以联网，然后再逐一排查:
方法1： 允许计算机远程连接
首先， 在远程计算机上按“Windows + R”打开运行框，输入“sysdm.cpl”并点击“确定”按钮打开系统属性窗口，然后点击“远程”选项卡并选择“允许远程连接到此计算机”，最后单击“确定”允许远程访问就可以啦，如下图所示
方法2. 设置Windows防火墙
电脑开启了Windows防火墙有时会阻止远程桌面连接通过，可以查看Windows防火墙是否阻止了远程桌面通过，查看方式如下：
首先在搜索框中，输入“允许应用通过Windows防火墙”并单击打开它，然后找到“远程桌面”并选中它前面的复选框，单击“确定”保存更改。
方法3. 检查远程桌面服务的状态
如果按照以上两个方法还是没有解决的话，可以检查两台计算机上远程桌面服务的状态，步骤如下：
首先打开运行框，输入“services.msc”并按回车键打开服务窗口，找到“Remote Desktop Services”，右键单击它选择“属性”，将启动类型设置为“自动”，然后单击“确定”。如下图所示
如果在启用了对远程计算机的远程访问，并且两台计算机上都启用了Remote Desktop Services，但远程桌面仍然无法连接的话，您可以为访问该计算机的用户分配权限。步骤如下
首先，在远程计算机的运行框中输入“gpedit.msc”，并单击“确定”打开本地组组策略编辑器，然后跳转到计算机配置 &gt; Windows 设置 &gt; 安全设置 &gt; 本地策略 &gt; 用户权限分配，最后，双击“允许通过远程桌面服务登录”，然后添加用户或组即可。
方法5：第三方远程控制软件　除了上述几种连接方式，还有一种简单的远程连接方式，利用第三方远程控制软件“RayLink”，步骤如下
首先在主控端跟被控端都安装好RayLink，安装完成后会自动进入首页【远程连接】，无论登不登录都可以使用，不过登录连接比未登录连接功能更多，可以根据自己的需要自由选择。
总的来说呢，如果大家遇到远程桌面无法连接的情况都可以用以上几种方式来排查解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/768ca6d4b99be97ee45dc6a84dbee14f/" rel="bookmark">
			在 Java 中，什么时候用重载，什么时候用重写？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1）重载是多态的集中体现，在类中，要以统一的方式处理不同类型数据的时候，可以用重载。
（2）重写的使用是建立在继承关系上的，子类在继承父类的基础上，增加新的功能，可以用重写。
（3）简单总结：
重载是多样性，重写是增强剂；
目的是提高程序的多样性和健壮性，以适配不同场景使用时，使用重载进行扩展；
目的是在不修改原方法及源代码的基础上对方法进行扩展或增强时，使用重写；
生活例子：
你想吃一碗面，我给你提供了拉面，炒面，刀削面，担担面供你选择，这是重载；
你想吃一碗面，我不但给你端来了面，还给你加了青菜，加了鸡蛋，这个是重写；
设计模式：
cglib实现动态代理，核心原理用的就是方法的重写；
详细解答：
Java的重载(overload) 最重要的应用场景就是构造器的重载，构造器重载后，提供多种形参形式的构造器，可以应对不同的业务需求，加强程序的健壮性和可扩展性，比如我们最近学习的Spring源码中的ClassPathXmlApplicationContext，它的构造函数使用重载一共提供了10个构造函数，这样就为业务的选择提供了多选择性。在应用到方法中时，主要是为了增强方法的健壮性和可扩展性，比如我们在开发中常用的各种工具类，比如我目前工作中的短信工具类SMSUtil, 发短信的方法就会使用重载，针对不同业务场景下的不同形参，提供短信发送方法，这样提高了工具类的扩展性和健壮性。
总结：重载必须要修改方法(构造器)的形参列表，可以修改方法的返回值类型，也可以修改方法的异常信息即访问权限；使用范围是在同一个类中，目的是对方法(构造器)进行功能扩展，以应对多业务场景的不同使用需求。提高程序的健壮性和扩展性。
java的重写(override) 只要用于子类对父类方法的扩展或修改，但是在我们开发中，为了避免程序混乱，重写一般都是为了方法的扩展，比如在cglib方式实现的动态代理中，代理类就是继承了目标类，对目标类的方法进行重写，同时在方法前后进行切面织入。
总结：方法重写时，参数列表，返回值得类型是一定不能修改的，异常可以减少或者删除，但是不能抛出新的异常或者更广的异常，方法的访问权限可以降低限制，但是不能做更严格的限制。
（4）在里氏替换原则中，子类对父类的方法尽量不要重写和重载。（我们可以采用final的手段强制来遵循）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/058cf7a6b5af74493fd139aa4c9c390d/" rel="bookmark">
			手机端表格插件，做表格左右滑动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		表格数据太长超出屏幕时，需要做左右滑动效果，昨天发现一个插件可以很快实现，不用自己写结构样式，之前自己手写的也可以实现，手机端表格怎么做横向滑动_调调啊的博客-CSDN博客 ， 但发现部署到企业微信之后就滑不动，才另外找的插件来写
vue-easytable 插件官网 ： Table Component/ Data Grid / Data Table.Support Virtual Scroll,Column Fixed,Header Fixed,Header Grouping,Filter,Sort,Cell Ellipsis,Row Expand,Row Checkbox
一 ，安装插件 npm install vue-easytable 二 ， main.js 中引入 // 引入样式 import "vue-easytable/libs/theme-default/index.css"; // 引入组件库 import VueEasytable from "vue-easytable"; Vue.use(VueEasytable); 三 ， 页面中使用 (用的vant组件库，加了list列表上拉加载) 表格宽度是根据数据长短自适应的，所以当数据太长超出屏幕，会自动实现左右滑动，不用再写别的代码
columms数组中的 field 是后端返回的数据对应字段，title是表头的标题， key是随便写的，不要重复就行
&lt;van-list v-model="loading" :finished="finished" finished-text="没有更多了" @load="onLoad" &gt; &lt;ve-table is-horizontal-resize style="width: 100%" :columns="columns" :table-data="list" :fixed-header="true" &gt;&lt;/ve-table&gt; &lt;/van-list&gt; //引入获取表格数据的api方法 import {getData} from "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/058cf7a6b5af74493fd139aa4c9c390d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff99bf0849a74bb160a6c213fa83777f/" rel="bookmark">
			【通过汇编语言理解C语言指针】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从汇编推导C语言指针
汇编推导C语言指针 指针，是C语言中的一个重要概念及其特点，而上一章中说到，汇编语言是为了让开发者更好的理解机器语言，并通过汇编语言来处理程序上的错误问题。
而执行机器语言的是CPU，而CPU内部有着各种各样的寄存器，其功能各有不同，目的就是为了推进程序正常运行，因此可以理解为汇编语言就在操作CPU。而C语言则是对汇编语言最纯粹的抽象(因为汇编虽然比机器语言更好理解，但也相对复杂)，通俗的说C语言就是在翻译汇编语言，因此理解汇编语言能有助于我们更好的理解C语言的指针。
首先，我们有这样的一个需求，在第一个方法中调用另一个方法，同时需要将该方法中的变量传递过去，使得另一个方法修改该变量的同时，第一个方法能够感知到第二个方法修改了该变量，需要如何做呢？我们知道程序要想运行，必须先将程序加载到内存中，而操作程序中的指令方法，需要将其压入程序的栈中，而栈中保存的都是程序代码的私有数据，那么这些数据从哪里来呢？毫无疑问数据在内存中，保存在内存中的哪里？内存中有对应的地址，因此我们只要有了该数据对应的内存地址，就能操作该数据。所以对于上述的需求，我们只要把该变量的内存地址传递给第二个方法，那么，第二个方法对于该变量的操作，第一个方法也能感知到，因为第一个方法本来就有变量的内存地址！接下来介绍两个汇编指令分别为 leaf，和();
leaf指令：取变量地址
():将()中的地址送到地址总线中操作，简单理解为操作该地址中的变量
介绍完上述的需求和基础信息之后，我们来看一个C语言的例子
#include &lt;stdio.h&gt; int sum(int *p){ *p = 10; return 10; } int main() { /* 我的第一个 C 程序 */ int a = 3; int f = sum(&amp;a); return 0; } 这段代码很容易理解，设置了一个变量a，然后调用了sum方法，同时将a的地址传了进去。我们通过gcc -m32 -S demo.c 编译我们的C文件（已经省略了一些不需要的文件）
.file	"demo.c" .text .globl	sum .type	sum, @function #函数sum sum: .LFB0: pushl	%ebp movl	%esp, %ebp #调用方法之后，将刚才放入esp的值取出来放入eax中 movl	8(%ebp), %eax 然后将eax中的值当作地址送入地址总线，操作该地址所对应的变量 movl	$10, (%eax) movl	$10, %eax popl	%ebp ret .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff99bf0849a74bb160a6c213fa83777f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13078adc0533de747b18e637dea43a57/" rel="bookmark">
			SPRINGBOOT：【基础一】springboot集成alibaba-druid数据连接池及配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、pom文件中引入依赖 &lt;!--引入druid数据源--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.6&lt;/version&gt; &lt;/dependency&gt; 二、在application.yml文件中做如下配置【注释为说明】 # 应用名称 spring: application: name: druid-demo # 数据库驱动： datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/springboot_demo?serverTimezone=Asia/Shanghai type: com.alibaba.druid.pool.DruidDataSource username: root password: 123456 # 以下是druid配置 druid: initialSize: 5 # 初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时 maxActive: 10 # 最大连接池数量 maxIdle: 10 # 已经弃用的字段,配置了也没效果 minIdle: 5 # 最小连接池数量 maxWait: 60000 # 从连接池中获取连接的最大等待时间，单位毫秒。默认-1,即不超时。配置了maxWait之后,缺省启用公平锁,并发效率会有所下降 validationQuery: select 1 # 验证sql是否可用,每中数据库的配置值都不同 testOnBorrow: false # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。 testOnReturn: false # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能 testWhileIdle: true # 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。 timeBetweenEvictionRunsMillis: 60000 #单位毫秒 # 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13078adc0533de747b18e637dea43a57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/653003cbe709f6be9a298e3e7a84dd3f/" rel="bookmark">
			ORACLE：数据库中ROWNUM的详解与应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先先了解一下Rownum的执行机制：
1.Oracle executes your query.(开始执行查询)
2.Oracle fetches the first row and calls it row number 1.(执行第一行，并且标记该行为第一行)
3.Have we gotten past row number meets the criteria? If no, then Oracle discards the row, If yes, then Oracle return the row.(你过去得到的行号是否符合标准&lt;即where条件句&gt;,如果不符合，则废弃掉这一行和行号，如果符合，就返回该行保存行号)
4.Oracle fetches the next row and advances the row number (to 2, and then to 3, and then to 4, and so forth).(开始执行下一行，并且是行号+1)
5.Go to step 3.
了解了原理，就知道rownum&gt;不会成功，因为在第三步的时候查询出的行已经被丢弃，第四步查出来的rownum仍然是1,这样永远也不会成功。
然后来说一下使用ROWNUM的注意事项:
1.Rownum不能以任何表的名称作为前缀，因为它不属于任何一个表。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/653003cbe709f6be9a298e3e7a84dd3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/122951c93b3f9a361732c9c69d3a55a9/" rel="bookmark">
			ORACLE：查询表空间信息及位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要： 记录一下操作oracle表空间的基本操作，比如查看大小，查看位置，修改大小等。
目录简介 1.查看表空间大小及使用情况；
2.查看表空间位置；
3.修改表空间大小；
4.使用navicat操作表空间;
一、查看表空间大小及使用情况： 1.1.查看表空间大小，sql语句如下：
SELECT t.tablespace_name, round(SUM(bytes / (1024 * 1024)), 0) ts_size FROM dba_tablespaces t, dba_data_files d WHERE t.tablespace_name = d.tablespace_name GROUP BY t.tablespace_name; SELECT FILE_NAME as 数据文件,TABLESPACE_NAME as 表空间名称,AUTOEXTENSIBLE as 自动扩展,STATUS as 状态,MAXBYTES as 可扩展最大值,USER_BYTES as 已使用大小,INCREMENT_BY as 自动扩展增量 FROM dba_data_files 以上两条sql均能查看。
1.2.查看表空间使用情况，sql如下：
SELECT SUM(bytes) / (1024 * 1024) AS free_space, tablespace_name FROM dba_free_space GROUP BY tablespace_name; SELECT a.tablespace_name, a.bytes total, b.bytes used, c.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/122951c93b3f9a361732c9c69d3a55a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbcb28d93b0bb205b31659a97a56fcce/" rel="bookmark">
			Git命令基础使用之GitLab拉取项目、提交分支、切换分支、合并分支、删除分支。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概念篇 Git 分支 几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。在很多版本控制系统中，这是个昂贵的过程，常常需要创建一个源代码目录的完整副本，对大型项目来说会花费很长时间。
有人把 Git 的分支模型称为“必杀技特性”，而正是因为它，将 Git 从版本控制系统家族里区分出来。Git 有何特别之处呢？Git 的分支可谓是难以置信的轻量级，它的新建操作几乎可以在瞬间完成，并且在不同分支间切换起来也差不多一样快。和许多其他版本控制系统不同，Git 鼓励在工作流程中频繁使用分支与合并，哪怕一天之内进行许多次都没有关系。理解分支的概念并熟练运用后，你才会意识到为什么 Git 是一个如此强大而独特的工具，并从此真正改变你的开发方式。
操作篇 一、拉取项目 1、进入项目中，copy项目的链接地址，打开Git命令窗口，输入拉取命令，不过先不急，这样拉取是直接拉取到桌面上的，如果想要放到电脑中指定的文件夹，先进入文件夹，再clone下来，这时候已经完成了拉取项目。
拉取项目命令： git clone git@git.lug.ustc.edu.cn:Apollo/projecttest.git 二、提交分支 1、假如我们GitLab里面存在一个空的Project，需要上传编辑过的文件进入这个Project中，这时候打开Git命令窗，进入需要上文件/文件夹的所在位置，如果不在文件所在地输入命令，将会出现以下错误。 另外注意：提交的文件名不能是中文，否则-m的注释内容将不会在GitLab的Last commit中出现！
命令行： $ git add test.txt $ git commit -m "第一次提交分支" $ git push -u origin master ps： git add 文件名 //单个上传 git add . //批量上传文件 如果是批量上传一个文件夹里面的文件，可以将git add .和git commit -m合并成一句： git commit -a -m "注释内容"/git commit -am "注释内容" 但是！如果是新建文件，只是输入git commit -a -m "注释内容"/git commit -am "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbcb28d93b0bb205b31659a97a56fcce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b20bc4959cd8bc594db69a8be436ca1e/" rel="bookmark">
			STM32 HAL库-定时器中断
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32 HAL库-定时器中断 &lt;font color=red&gt;STM32 关闭所有中断一、STM32F407定时器介绍定时器计算公式 二、CubeMX配置定时器三、基本定时器中断配置流程1）开启定时器时钟2）初始化定时器参数,设置自动重装值，分频系数，计数方式等3）使能定时器更新中断，开启定时器计数，配置定时器中断优先级4）编写中断服务函数（主要是重写回调函数，覆盖原来的）注意： 四、参考资料1 HAL库的中断处理1.1 HAL 库的中断封装1.2 外部中断处理流程 五、示例 STM32 关闭所有中断 关闭或开启所有中断；代码如下：
__set_PRIMASK(1);//关总中断 __set_PRIMASK(0);//开总中断 一、STM32F407定时器介绍 STM32F407 有众多的定时器，其中包括 2 个基本定时器（TIM6 和 TIM7）、10 个通用定时
器（TIM2 ~ TIM5、TIM9 ~TIM14）、2 个高级控制定时器（TIM1 和 TIM8），这些定时器彼此完
全独立，不共享任何资源。
选择定时器，配置时钟源，设置预分频系数，计数模式，设置自动重装载值
定时器计算公式 不过一般情况下定时时间都是毫秒级别。
时钟频率是84Mhz这里进行84分频，就是1Mhz，也就是每秒10的6次方个脉冲。而重装载值是1000，每秒可以触发1000个中断，也就是定时时间是1ms。
PSC = 84 -1 = 83;
ARR = 1000 -1 = 999;
二、CubeMX配置定时器 详见正点原子视频教程
三、基本定时器中断配置流程 1）开启定时器时钟 HAL 中定时器使能是通过宏定义标识符来实现对相关寄存器操作的，方法如下：
__HAL_RCC_TIMx_CLK_ENABLE(); /* x=1~14 */
2）初始化定时器参数,设置自动重装值，分频系数，计数方式等 定时器的初始化参数是通过定时器初始化函数 HAL_TIM_Base_Init 实现的。
注意：该函数会调用：HAL_TIM_Base_MspInit 函数，我们可以通过后者存放定时器时钟
和中断等初始化的代码。
3）使能定时器更新中断，开启定时器计数，配置定时器中断优先级 通过 HAL_TIM_Base_Start_IT 函数使能定时器更新中断和开启定时器计数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b20bc4959cd8bc594db69a8be436ca1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a3f1cee52ab04ddcc59d9d12b91c25b/" rel="bookmark">
			vivo x TiDB丨解决云服务海量数据挑战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vivo 是一家全球性的移动互联网智能终端公司，品牌产品包括智能手机、平板电脑、智能手表等 ，截至 2022 年 8 月，已进驻 60 多个国家和地区，全球用户覆盖 4 亿多人。
vivo 为用户提供了在手机上备份联系人、短信、便签、书签等数据的能力，底层存储采用 MySQL 数据库进行数据存储。 随着 vivo 业务发展，用户量增长迅速，存储在云端的数据量越来越大，海量数据给后端存储和数据库带来了巨大的挑战。云服务业务最大的痛点，就是如何解决用户海量数据的存储问题 。
本文介绍了 vivo 的数据库和存储系统，以及如何使用分布式数据库 TiDB 解决海量数据挑战。 详细介绍了 vivo 采用 TiDB 过程中的真实体验，包括海量数据实时 OLAP 方案、云服务业务中的元数据管理方案，和基于自研的 NoSQL 数据库 TiKV 的实践。 分享了如何解决海量数据存储和管理的问题，以及提高业务效率和用户体验的实践经验。
vivo 数据库与存储体系 vivo 数据库与存储体系产品矩阵 在整个 vivo 云服务体系中，数据库与存储处于核心位置，从体系上可以分为两层，最上面一层是工具产品层，包含数据库存储统一管控平台、数据传输服务（支持数据同步、数据订阅、数据迁移等）、运维白屏化工具等。下面一层是数据库产品层，这一层又分为三个部分：一部分是 MySQL、 TiDB 等关系型数据库；一部分是 Redis、ElasticSearch、MongoDB、磁盘 KV 等非关系型数据库；还有一部分是对象存储、文件存储、块存储等存储服务。
vivo 数据库与存储运营管理 为了管理这些众多的数据库与存储产品，vivo 打造了一个数据库与存储运营管理平台，主要分为三层架构：
最底层是支撑、管理所有数据库的工具产品，包含数据存储服务、关系型数据库、NoSQL 数据库，以及生态工具；中间是功能层，包括基础存储服务、数据管理服务，以及存储自治服务；最上面是运营层，包括权限账单、用户管理、工单服务等基础服务。同时还有一些安全相关服务，如数据脱敏、数据加密、权限管控、命令通道、数据审计等一系列功能。 TiDB 在 vivo 的落地实践 此前，vivo 已经用了很多年关系型数据库 MySQL。基于原生的 MySQL 数据库，vivo 结合集群高可用的管理与数据库代理的一体化架构，通过域名服务、名字服务进行接入，提供通用的关系型数据库服务。它主要具有三大核心能力：
第一，兼容 MySQL 协议与 SQL 语法；第二，增强 MySQL 集群管控能力。vivo 引入 MySQL 的时间很早，在 MySQL 的一些集群管控能力上都有自研的能力；第三，安全增强能力，包括密码管理、数据脱敏、数据加密等能力。 本质上 MySQL 架构还是一个主从架构，并没有分布式技术引入。针对数据量较大、流量较大的场景，或者分析场景，给业务带来了巨大挑战。基于以上原因，vivo 在对比了主流分布式数据后后考虑引入分布式关系型数据库 TiDB，作为关系型数据库产品矩阵的一环，补充整个关系型数据库的能力。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a3f1cee52ab04ddcc59d9d12b91c25b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e42acf100d02ef90e1050c33707fc814/" rel="bookmark">
			Flink-DataStream API介绍(源算子、转换算子、输出算子)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 DataStream API（基础篇）Flink 支持的数据类型执行环境（Execution Environment）创建执行环境执行模式(Execution Mode)触发程序执行 源算子准备工作从集合中读取数据从文件读取数据从 Socket 读取数据从 Kafka 读取数据自定义 Source 转换算子（Transformation）映射(map)过滤(filter)扁平映射(flatMap)聚合算子（Aggregation）按键分区(keyBy)简单聚合归约聚合（reduce） 用户自定义函数（UDF）富函数类（Rich Function Classes）物理分区（Physical Partitioning）和分区策略 输出算子（Sink）输出文件输出到 Kafka输出到 Redis输出到 Elasticsearch输出到 MySQL（JDBC）自定义 Sink 输出 DataStream API（基础篇） Flink 有非常灵活的分层 API 设计，其中的核心层就是 DataStream/DataSet API。由于新版本已经实现了流批一体，DataSet API 将被弃用，官方推荐统一使用 DataStream API 处理流数据和批数据。
DataStream（数据流）本身是 Flink 中一个用来表示数据集合的类（Class），我们编写的Flink 代码其实就是基于这种数据类型的处理，所以这套核心 API 就以 DataStream 命名。
一个 Flink 程序，其实就是对 DataStream 的各种转换。具体来说，代码基本上都由以下几部分构成：
获取执行环境（execution environment）读取数据源（source）定义基于数据的转换操作（transformations）定义计算结果的输出位置（sink）触发程序执行（execute） Flink 支持的数据类型 （1）Flink 的类型系统
Flink 作为一个分布式处理框架，处理的是以数据对象作为元素的流。为了方便地处理数据，Flink 有自己一整套类型系统。Flink 使用“类型信息”（TypeInformation）来统一表示数据类型。TypeInformation 类是 Flink 中所有类型描述符的基类。它涵盖了类型的一些基本属性，并为每个数据类型生成特定的序列化器、反序列化器和比较器。
（2） Flink 支持的数据类型
简单来说，对于常见的 Java 和 Scala 数据类型，Flink 都是支持的。Flink 在内部，Flink对支持不同的类型进行了划分，这些类型可以在 Types 工具类中找到：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e42acf100d02ef90e1050c33707fc814/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c064ae0ac02151929f90d0aa058f605e/" rel="bookmark">
			Flink-介绍和快速上手
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 介绍Flink 的源起和设计理念主要应用场景流式数据处理的发展和演变流处理和批处理传统事务处理有状态的流处理Lambda 架构新一代流处理器 Flink 的特性分层APIFlink vs Spark数据处理架构数据模型和运行架构选择 快速上手创建项目WordCount 介绍 Apache Flink是由Apache软件基金会开发的开源流处理框架，其核心是用Java和Scala编写的分布式流数据流引擎。Flink以数据并行和管道方式执行任意流数据程序，Flink的流水线运行时系统可以执行批处理和流处理程序。此外，Flink的运行时本身也支持迭代算法的执行。
Flink 的源起和设计理念 Flink 起源于一个叫作 Stratosphere 的项目，它是由 3 所地处柏林的大学和欧洲其他一些大学在 2010~2014 年共同进行的研究项目，由柏林理工大学的教授沃克尔·马尔科（Volker Markl）领衔开发。2014 年 4 月，Stratosphere 的代码被复制并捐赠给了 Apache 软件基金会，Flink 就是在此基础上被重新设计出来的。
在德语中，“flink”一词表示“快速、灵巧”。项目的 logo 是一只彩色的松鼠，当然了，这不仅是因为 Apache 大数据项目对动物的喜好（是否联想到了 Hadoop、Hive？），更是因为松鼠这种小动物完美地体现了“快速、灵巧”的特点。关于 logo 的颜色，还一个有趣的缘由：柏林当地的松鼠非常漂亮，颜色是迷人的红棕色；而 Apache 软件基金会的 logo，刚好也是一根以红棕色为主的渐变色羽毛。于是，Flink 的松鼠 Logo 就设计成了红棕色，而且拥有一个漂亮的渐变色尾巴，尾巴的配色与 Apache 软件基金会的 logo 一致。这只松鼠色彩炫目，既呼应了 Apache 的风格，似乎也预示着 Flink 未来将要大放异彩。
从命名上，我们也可以看出 Flink 项目对于自身特点的定位，那就是对于大数据处理，要做到快速和灵活。
2014 年 8 月，Flink 第一个版本 0.6 正式发布（至于 0.5 之前的版本，那就是在Stratosphere 名下的了）。与此同时 Fink 的几位核心开发者创办了 Data Artisans 公司，主要做 Fink 的商业应用，帮助企业部署大规模数据处理解决方案。2014 年 12 月，Flink 项目完成了孵化，一跃成为 Apache 软件基金会的顶级项目。2015 年 4 月，Flink 发布了里程碑式的重要版本 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c064ae0ac02151929f90d0aa058f605e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbee3a8e87a873d1021a351e7c7f7249/" rel="bookmark">
			Android Studio实现校园图书管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 项目目录 一、项目概述二、开发环境三、项目结构四、运行演示五、源码获取 一、项目概述 本次项目实现了一个简单的校园图书管理系统，主要功能就是欢迎界面、注册、登录和借书信息的增删改查，还有Sqlite数据库，其中数据库用到了MD5加密方式存储。管理员先如果没有账号就先进行注册，注册完后进行登录，登录时可以记住密码，下次就不用再输入了。登录成功，进入到管理界面，管理界面是新增修改删除和查询四个按钮，每一个会跳转到相应的界面，都是对数据库中对应的表进行execute。总体结构很清楚易懂，简单实用，UI也进行了用心的设计，是一大亮点。
二、开发环境 三、项目结构 activity包中放置的是管理界面的四个跳转的Activity，分别负责增删改查功能。app中包中放置的是欢迎登录注册和MainActivity，也就是项目的基础界面。bean包是数据表，是tb_Books这张表的属性。database包放置的是数据库文件，包含了创建数据库的java文件和实现MD5加密的java文件。 四、运行演示 1、打开AVD运行项目，首先是欢迎界面，很有文艺风。
2、然后3s后自动进入登录界面，这里因为我注册过，所以直接从数据库中读取了登录账号和密码。
3、我们选择【注册】，输入你的用户名和密码，然后确认密码，点击注册后，会自动跳转回登录界面。
4、然后我们点击登录，就会跳转到管理员的主界面，弹出欢迎的提示信息。
5、我们选择【添加】按钮，进入添加借书记录的界面。
6、然后输入借书信息，并添加，将这条记录加到数据库中，会弹出“添加成功”的提示信息，自动返回主界面，
7、我们再选择【修改】按钮，输入刚刚添加的学号170310416，然后点击【查询】。
8、我们的借书信息会自动补全，这时候我们将专业改为【自动化】，然后点击【修改】。
9、回到主界面，我们再选择【查看借书记录】，可以看到我添加的两条记录。
10、回到主界面，我们删除学号为170310416的这条记录，输入学号，然后查询，再删除。
11、这时候我们会发现刚刚添加的记录已经被删除了。
这样就简单实现了校园图书管理系统应有的基本功能。
五、源码获取 以下两种方式都可以获取源代码：
直接点击下方链接下载源代码Android Studio实现校园图书管理系统 关注公众号《 萌新加油站 》，后台回复： 图书 🚀这有你错过的精彩内容Android Studio实现星座配对AppAndroid Studio实现外卖订餐系统Android Studio实现考试管理系统Android Studio实现图书馆订座系统Android Studio实现前后台分离的选课系统 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52ffc92729626b2ce73e1f2323acc2ca/" rel="bookmark">
			box-shadow详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		box-shadow详解 属性定义及使用说明 box-shadow属性可以设置一个或多个下拉阴影的框。
语法 box-shadow: h-shadow v-shadow blur spread color inset; 注意：boxShadow 属性把一个或多个下拉阴影添加到框上。该属性是一个用逗号分隔阴影的列表，每个阴影由 2-4 个长度值、一个可选的颜色值和一个可选的 inset 关键字来规定。省略长度的值是 0。
属性描述h-shadow必需的。水平阴影的位置。允许负值v-shadow必需的。垂直阴影的位置。允许负值blur可选。模糊距离spread可选。阴影的大小color可选。阴影的颜色。inset可选。从外层的阴影（开始时）改变阴影内侧阴影 属性详解 div默认设置以下css样式：
.container { width: 200px; height: 200px; background-color: red; } h-shadow
它是必需的，代表水平方向的阴影。值为正数时，阴影在元素的右侧；值为负数时，阴影在元素的左侧。 &lt;div class="container container1"&gt;&lt;/div&gt; &lt;div class="container container2"&gt;&lt;/div&gt; .container1 { box-shadow: 20px 20px; } .container2 { box-shadow: -20px 20px; } 效果如下：
v-shadow
它是必需的，代表垂直方向的阴影。值为正数时，阴影在元素的下侧；值为负数时，阴影在元素的上侧。 .container1 { box-shadow: 20px 20px; } .container2 { box-shadow: 20px -20px; } blur
它是可选的，代表阴影的模糊半径。值越大，越模糊。 .container1 { box-shadow: 20px 20px 20px; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52ffc92729626b2ce73e1f2323acc2ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e02da7087a0c860b77a1217a1d1095b4/" rel="bookmark">
			算法设计复习(一、二、递推、递归)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一章 算法概述 什么是算法：是对特定问题求解步骤的一种描述，是指令的有限序列。
算法的五个重要特性：输入、输出、有穷性、确定性、可行性
一个算法的优劣可以用时间复杂性和空间复杂性来衡量
算法和程序的关系
1.程序是使用某种程序设计语言对算法的具体实现，是对算法的精确描述，可在计算机上运行；
2.程序可以是无穷的，而算法必须是有穷的；
3.程序设计的核心是算法。
常用的描述算法的方法:自然语言、流程图、程序设计语言、伪代码等
排序算法:
直接插入排序:
第二章 STL简介 掌握有关vector的内容
vector（向量）从后面快速插入与删除,直接访问任何元素
vector和数组的区别
1.array 定义的时候必须定义数组的元素个数；而vector 不需要
2.array 定义后的空间是固定的了，不能改变；而vector 要灵活得多，可再加或减
3.vector有一系列的函数操作，非常方便使用
4.数组和vector不同，一个数组不能用另一个数组初始化，也不能将一个数组赋值给另一个数组；
知道set具有典型的特点： 内部的元素依据其值自动排序；set内的相同数值的元素只能出现一次
#include &lt;bits/stdc++.h&gt; using namespace std; int n; map&lt;string,int&gt;mp; int main() { while(cin&gt;&gt;n) { string tmp; int g=0; for(int i=1;i&lt;=n;i++) { string k; cin&gt;&gt;k; mp[k]++; if(mp[k]&gt;g) tmp=k,g=mp[k]; } cout&lt;&lt;"answer:"&lt;&lt;tmp&lt;&lt;endl; } return 0; } 了解有关“优先队列”的内容，关键是会使用优先队列去解决问题（默认情况下是使用大顶堆，是从大到小排列）
#include &lt;bits/stdc++.h&gt; using namespace std; struct cmp { bool operator()(int x,int y) { return x&lt;y; } }; //priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt;q; priority_queue&lt;int,vector&lt;int&gt;,cmp&gt;q; int main() { int n;cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) { int x;cin&gt;&gt;x; q.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e02da7087a0c860b77a1217a1d1095b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfd8e5a67156a8c1ab20cc70289d2a60/" rel="bookmark">
			IntelliJ IDEA&#43;CICFlowMeter实现对CIC-IDS-2017数据集特征提取（含数据集及linux下IntelliJ IDEA配置和部分错误的解决方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写目录标题 一、前言：二、环境配置（一）、java安装1.linux本身无java环境2.如果系统已经有了`openjdk`环境3.已经带有`jdk1.8.0` （二）`Maven` 安装Maven 换源 （三）Git安装（四）安装 gradle（五）安装libpacp（六）IntellJ IDEA（七）下载CICFlowMeter 三、IDEA中导入CICFlowMeter-master并配置IDEA四、CIC-IDS-2017数据集下载 一、前言： 根据该教程（参考博文：阿蕉（作者）
-CICFlowMeter使用）使用windows环境进行配置时，总是在offlineline分析CIC-IDS-2017数据集中的pcap文件时异常退出。如下图所示的错误，可能是jdk的问题吧(版本没错)，改了太多次也不想再折腾了，干脆在VMwork Station中的kali虚拟机里尝试一下，就成功了。
二、环境配置 参考博文-CSDN-Ashin Wang’s Blog-CICFlowMeter安装及使用体验注：本文在配置时使用oracle的jdk1.8.0，使用前述博文所说的openjdk不能够成功进行数据集操作
（一）、java安装 1.linux本身无java环境 参考博文-景天zy（作者）-Kali安装JDK 1.8的详细过程
如果终端中键入java -version报错，显示没有java的话，则直接使用本链接进行jdk1.8.0下载，
华为云jdk_1.8.0_202下载
sudo vim /etc/profile 在文件的最后添加：（ps：也可以在~/.bashrc或者~/.zshrc这样的配置文件中添加）
# install JAVA JDK export JAVA_HOME=/opt/jdk1.8.0_202 export CLASSPATH=.:${JAVA_HOME}/lib export PATH=${JAVA_HOME}/bin:$PATH 退出后键入命令：(修改了其他文件则进行相应操作如source ~/.bashrc或者source ~/.zshrc)
source vim /etc/profile 通知系统java的位置（注意这里的版本号一定要和安装的版本号一样，否则出错！！）
sudo update-alternatives --install /usr/bin/java javac /opt/jdk1.8.0_202/bin/java 1 sudo update-alternatives --install /usr/bin/javac javac /opt/jdk1.8.0_202/bin/javac 1 sudo update-alternatives -set java /opt/jdk1.8.0_202/bin/java sudo update-alternatives --set javac /opt/jdk1.8.0_202/bin/javac 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfd8e5a67156a8c1ab20cc70289d2a60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b7628441d083f6a11a810a07b1e9273/" rel="bookmark">
			相机成像原理详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ybwu@whu.edu.cn 被摄景物反射出的光线通过照相镜头（摄景物镜）和控制曝光量的快门聚焦后，被摄景物在暗箱内的感光材料上形成潜像，经冲洗处理（即显影、定影）构成永久性的影像（百度百科）。传统胶片相机的感光材料为胶卷，现代数码相机的感光原件一般为CMOS传感器。它的尺寸一定程度上决定了成像质量，所以是很多相机/手机厂商宣传的重点，比如坊间经常听到的“一英寸大底”，“底大一级压死人”等等。
当一束与凸透镜的主轴平行的光穿过凸透镜时，在凸透镜的另一侧会被凸透镜汇聚成一点，这一点叫做焦点，焦点到凸透镜光心的距离就叫这个凸透镜的焦距。一个凸透镜的两侧各有一个焦点。
理论上只有处于镜头焦点距离的景物是成像清晰的，而在焦点前后，光线开始聚焦和扩散，成像变的模糊，成像点形成一个扩大的圆：弥散圆(circle of confusion)，而人眼的分辨能力有限，只有当弥散圆直径大到一定程度，我们才感觉到模糊，比如图 1的草地看起来中间一段都是清晰的，通俗的说，这一段“看起来清晰”的距离就是景深(Depth of Field)。
图 1 草地上看起来清晰的一段距离就是“景深”
在焦点前后各有一个容许弥散圆，这两个弥散圆之间的距离称为焦深，对应在被拍摄点处即为景深，换言之，被摄物体前后景深距离内，呈现在成像平面上的影像模糊度都在容许弥散圆的限定范围内。小孔成像模型示意图如图 2所示。
图 2 透镜与小孔成像模型
影响景深的因素有镜头的焦距、光圈值、拍摄距离。光圈是相机镜头中可以改变中间孔大小的机械装置，如图 4所示。其对于相机成像主要有两方面的作用：控制进光量和景深。光圈对景深的影响如图 3所示。
图 3光圈对景深的影响
图 4相机光圈示意图
控制其他条件不变，三者对景深的影响总结如下：
光圈越大，景深越小，适合做背景虚化效果，如人像；反之光圈越小，景深越大。焦距对景深也有影响，通常焦距越大，景深越小，如长焦镜头的景深比较小，而广角镜头的景深都比较大。拍摄距离越远，景深越大；距离越近，景深越小。 两个容易混淆的概念（经评论区提醒，已修改）： 对焦：就是改变镜头（光学中心）到成像平面之间的距离，也就是像距。用于调整成像的虚实，达到使影像清晰的目的，变焦时可以看到镜头伸长或缩小。
变焦：改变镜头的焦距，可以让不同远近的物体，聚焦到底片上形成清晰的影像。镜头焦距的改变，是通过镜头内部镜片的变动来实现，其光学中心到底片的距离不变，因此镜头不会伸长或缩短。
在计算机视觉应用中，由于拍摄景深的限制，对空间中不同物距景物清晰采样前需要进行对焦操作，而对焦过程将稍微改变镜头到成像平面的距离，使得相机内参发生变化[1]。
之前说光圈可以控制进光量，快门也可以，光圈从空间上限制进光面积来控制进光量，而快门则是从曝光时间上来控制。可以简单地理解为：快门挡在镜头或底片前，平时处于关闭状态，成像时快门打开一段时间再关闭，完成成像，这个快门打开的时间就是快门时间，通常以1/N秒为单位。快门除了可以控制进光量从而影响照片曝光，还可以制造一些特别的拍照效果，快门时间太长会导致图像太亮，即过曝；快门时间太短会导致图像太暗，即欠曝。对SLAM应用来讲，在保证图像质量的前提下，曝光时间尽量短是一件好事，可以减少rolling shutter造成的“果冻效应”和传感器因时间不同步带来的误差。
Reference：
[1] 周佳立, 贾禄帅, and 武敏, "适用于动态对焦的高精度灵活标定方法," 模式识别与人工智能, vol. 29, pp. 481-491, 2016.
相机的那些事儿 - 概念、模型及标定-阿里云开发者社区
焦距、光圈和景深的关系，焦距越长，景深越长？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc20db89d571c3926553c27338cbf226/" rel="bookmark">
			【论文阅读】2023-ICLR：TimesNet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 论文信息 2. 简介 当前深度学习方法对时序数据的建模都是将时序数据作为1D数据输入模型，然后使用RNN，RCN，或Transformer-based的方法来捕获时序数据的变化。但是，注意力机制很难从分散的时间点直接找到可靠的依赖性，因为时间依赖性在复杂的时间模式中会被深深地遮蔽。
真实世界中，时间序列数据往往是多周期的，如图1，基于对时间序列中多周期性的观察，论文将复杂的时间变化分解为多个周期内和周期间变化。为了解决1D时间序列在表示能力上的局限性，论文将时间变化分析扩展到2D空间，方法是将1D时间系列转换为基于多个周期的一组2D张量。这种转换可以将周期内和周期间的变化分别嵌入到2D张量的列和行中，使得2D变化可以容易地由2D内核建模。
3. 模型 论文提出了TimesNet模型，通过模块化结构将复杂时序变化分解至不同周期，并通过将原始一维时间序列转化至二维空间实现了周期内与周期间变化的统一建模。
3.1 1D数据转化为2D 具体地，先通过快速傅立叶变换得到时序数据在频域的分量，保留TopN低频分量，剔除高频噪声，最后得到时序数据分解后的子波形的频率和周期
简化表示为：
然后，基于选定的周期对原始的一维时间序列进行折叠，该过程可以形式化为：
其中，Padding(.)为在序列末尾补0，使得序列长度可以被整除。 需要注意的是，对于上述二维向量，其每列与每行分别对应着相邻的时刻与相邻的周期，而临近的时刻与周期往往蕴含着相似的时序变化。因此，上述二维张量会表现出二维局部性（2D locality），从而可以很容易通过2D卷积捕捉信息。
3.2 TimesBlock 如上图所示，TimesNet由多个TimesBlock堆叠组成。每个TimesBlock的处理过程为：
将时序数据从一维变换至二维提取二维时序变化表征二维变换至一维自适应融合 通过上述设计，TimesNet完成了“多个周期分别提取二维时序变化，再进行自适应融合”的时序变化建模过程。
4. 实验 论文在长时、短时预测、缺失值填补、异常检测、分类五大任务上进行了实验，涵盖36个数据集、81种不同的实验设置。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb18a39f2da12f1bd6fe339fccf433e7/" rel="bookmark">
			《深入理解计算机系统》第三章笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深入理解计算机系统 程序的机器级表示一、程序编码机器级代码 二、数据格式三、访问信息1.操作数指示符2.数据传送指令3.数据传送实例4.压入和弹出栈数据 四、算术和逻辑操作1.加载有效地址2.一元和元操作3.移位操作4.特殊的移位操作（扩展） 五、控制1.条件码2.访问条件码3.跳转指令4.跳转指令的编码5.用条件==控制==来实现条件分支6.用条件==传送==来实现条件分支7.循环8.Switch语句 六、过程（函数）1.运行时栈2.转移控制3.数据传送4.栈上的局部存储5.寄存器中的局部存储空间 七、数组分配和访问1.基本原则2.指针运算3.嵌套的数组4.变长数组 八、异质的数据结构1.结构2.联合3.数据对齐 九、在机器级程序中将控制与数据结合起来1.理解指针2.内存越界引用和缓冲区溢出3.对抗缓冲区溢出攻击4.支持变长栈帧 十、浮点代码 本文为《深入理解计算机系统》第三章 程序的机器级表示的笔记，主要介绍x86平台下的机器代码以及人类可读的表示——汇编语言。通过阅读汇编代码，我们能理解编译器的优化能力，并分析代码中隐含的低效率。 计算器执行机器代码，用字节序列编码低级的操作（包括处理数据、管理内存、读写存储设备上的数据，以及利用网络通信）：
GCC C语言编译器以汇编代码的形式产生输出（汇编代码是机器代码的文本表示，给出程序中的每一条指令）GCC调用汇编器和链接器，根据代码生成可执行的机器代码。 程序的机器级表示 一、程序编码 代码执行流程：
1.C预处理器扩展源代码，插入所有用#include命令指定的文件，并扩展所有用#define声明指定的宏2.编译器产生两个源文件的汇编代码，后缀为s3.汇编器将汇编代码转换成二进制目标代码，后缀为o（目标代码是机器代码的一种形式，包含所有指令的二进制表示，只是还没有填入全局值的地址）4.链接器将两个目标代码与实现库函数（例如printf）的代码合并，并产生最终的可执行代码文件 机器级代码 计算机系统使用了多种不同形式的抽象，利用更简单的抽象模型来隐藏实现的细节：
由指令集体系或指令集架构（ISA）来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组。 x86的机器代码中，通常对C语言程序员隐藏的处理器状态都是可见的：
程序计数器（通常称为“PC”，在86中用%rip表示）给出将要执行的下一条指令在内存中的地址。整数寄存器文件 包含16个命名的位置，分别存储64位的值，可以存储地址（指针）或整数数据。有的寄存器被用来记录重要的程序状态。条件码寄存器 保存着最近执行的算术或逻辑指令的状态信息。用来实现控制或数据流中的条件语句。向量寄存器 可以存放一个或多个整数或浮点数值。 虽然C语言可以在内存中声明和分配各种数据类型的对象，但是机器代码只是简单的将内存看成一个很大的、按字节寻址的数组
程序内存包含：
程序的可执行机器代码操作系统需要的一些信息用来管理过程调用和返回的运行时栈以及用户分配的内存块。 程序内存用虚拟地址来寻址。在任意给定的时刻，只有有限的一部分虚拟地址被认为是合法的。
操作系统负责管理虚拟地址空间，将虚拟地址翻译成实际处理器内存中的物理地址。
一条机器指令只执行一个非常基本的操作（例如将存放在寄存器中的两个数字相加，在寄存器和寄存器之间传送数据，或是条件分支转移到新的指令地址），编译器必须产生这些指令的序列。
二、数据格式 汇编代码指令都有一个字符的后缀，表明操作数的大小。
例如，数据传送mov指令有四个变种：movb（传送字节）、movw（传送字）、movl（传送双字）和movq（传送四字）
三、访问信息 一个x86的中央处理单元（CPU）包含一组16个存储64位值的通用目的寄存器，用来存储整数数据和指针。这些寄存器都以%r开头（不同命名规则是由于指令集历史演化造成的）
指令可以对这16个寄存器的低位字节中存放的不同大小的数据进行操作： 字节级操作可以访问最低的字节；16位操作可以访问最低的2个字节；32位操作可以访问最低的4个字节；而64位操作可以访问整个寄存器。
对于小于8字节结果的指令，寄存器剩下的字节如何处理？
生成1字节和2字节数字的指令会保持剩下的字节不变生成4字节的数字的指令会把高位4个字节置为0 栈指针%rsp，用来指明运行时栈的结束位置。
1.操作数指示符 操作数（Operand）指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置。
操作数的类型：
立即数（immediate）：用来表示常数值。格式为$整数，例如：%-577代表常数-577寄存器（register）：用来表示某个寄存器的内容，用 ra 来表示任意寄存器a，用引用 R[ ra ] 来表示它的值（将寄存器看成一个数组R，用寄存器标识符作为索引）内存引用：根据计算出来的地址访问某个内存位置。用Mb[ Addr ] 表示对存储在内存中从地址Addr开始的b个字节值的引用。 寻址模式：
有多种不同的寻址模式，允许不同形式的内存引用。
如最常用的 Imm（rb，ri，s），由四个部分组成：
一个立即数偏移Imm一个基址寄存器rb（必须是64位寄存器）一个变址寄存器ri（必须是64位寄存器）一个比例因子s（这里s必须是1、2、4或8） 有效地址被计算为：
Imm + R[ rb ] + R[ ri ] * s
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb18a39f2da12f1bd6fe339fccf433e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/959084d5033da0c679f50a96bc3ce025/" rel="bookmark">
			Java指令重排测试类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总结了两个指令重排的场景，并编写代码实现了。
场景一：两个线程分别对不同变量来回赋值，验证是否发生指令重排
场景二：单例模式的懒汉模式，DCL+volatile能保证不发生意外，但这里故意不加volatile，验证是否发生指令重排导致意外情况
import org.junit.Test; import java.util.LinkedList; import java.util.List; import java.util.concurrent.*; public class InstructReorderTest { int x = 0, y = 0, a = 0, b = 0; @Test public void test() throws Exception { ExecutorService executorService = Executors.newFixedThreadPool(2); long start = System.nanoTime(); for (long i = 0; i &lt; Long.MAX_VALUE; i++) { x = y = a = b = 0; CountDownLatch latch = new CountDownLatch(2); Runnable r1 = () -&gt; {a=1;x=b;latch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/959084d5033da0c679f50a96bc3ce025/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e566dc218a1833639f25e935232c455e/" rel="bookmark">
			leetcode 刷题指南 &amp; 刷题顺序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.刷题方法&amp;顺序： 按类型刷，这样能总结出每种类型题目的规律。优先树、链表、二分查找、DFS、BFS、动态规划数目：常见类型刷10道+顺序：先做2~4道简单题，然后做中等难度题目，hard我没有做。优先做题目序号小、点赞多、提交成功率高的题目，这是为了从简单入手，否则一上来就做难题太花费时间。给自己设定时间：leetcode每道题目都有“模拟面试”功能，简单中等题目分别给限定了15、30min，做不出来的话就看答案，记住思路后自己再做一遍。总结：每种类型题目做完10+道后，总结规律。 2. 举个例子：二分查找题目总结 /** * 二分查找：重点在于每次放弃一边，选择另一边 * 1. 基础 * 2. 变形：搜索插入下标、搜索开始和结束位置、搜索二维矩阵(先用二分查找算出在哪一行，然后用二分查找在这1行里查找) * 3. 旋转排序数组： * 3.1 搜索旋转排序数组(重点在于放弃掉哪一边，通常是通过哪一边是有序的来做判断) * 3.2 其升级版（存在重复元素）：当n[left]==n[mid]==n[right]时，无法判断哪边是有序的，所以要left++和right--来进一步判断 * 3.3 寻找最小值（判断抛弃哪边的方法：比较nums[mid]和nums[right]谁大谁小） * 4. 不再有目标值，而是寻找任何一个峰值。 */ 待续
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cdbba322fc13ccb7fddffebe40b2c4d/" rel="bookmark">
			在windows7操作系统，delphi XE5如何把其它程序而不是本软件在通知区域的图标隐藏？不是关闭进程。请举个详细代码例子，Shell_NotifyIcon和Showwindow都无法实现功能，...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要隐藏DEVBIT.exe在Windows7操作系统的通知区域图标，可以使用以下代码：NOTIFYICONDATA nid; ZeroMemory(&amp;nid, sizeof(NOTIFYICONDATA)); nid.cbSize = sizeof(NOTIFYICONDATA); nid.hWnd = hWnd; nid.uID = IDI_ICON1; nid.uFlags = NIF_ICON; nid.hIcon = LoadIcon(hInst, MAKEINTRESOURCE(IDI_ICON1)); Shell_NotifyIcon(NIM_DELETE, &amp;nid);其中，h
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd16c2d1a7588c854da58bf705570126/" rel="bookmark">
			Ubuntu和windows的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu和Windows最大的不同之处在于操作系统的架构。Ubuntu采用的是基于Linux的开源操作系统，而Windows采用的是微软的收费操作系统。此外，Ubuntu提供的软件和服务大多是免费的，而Windows的大多数软件和服务是收费的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/575ff40b56968b84be4c3c60501db876/" rel="bookmark">
			能否详细的告诉我，拖拽式控件编程的实现原理，Qt如何实现，给我写一个demo解释...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		拖拽式控件编程主要是通过使用Qt中的QObject类来实现的。QObject类提供了拖拽功能，允许用户将控件从一个位置拖动到另一个位置。Qt提供了一些拖拽功能，如QDrag，QDragEnterEvent和QDragMoveEvent。下面是一个使用Qt实现拖拽式控件编程的简单示例：#include "mainwindow.h" #include #include #include #include #include int main(int arg
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/218212130d828abf150e0d8757a0538c/" rel="bookmark">
			请用py中的cmd模块制作一个交互shell并提供源代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 可以参考以下代码：import cmdclass MyShell(cmd.Cmd): """Simple command processor example."""
def do_greet(self, line): print("hello") def do_EOF(self, line): return Trueif __name__ == '__main__': MyShell().cmdloop() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fe8943c142c5f7eb8d046cbf63c1182/" rel="bookmark">
			树莓派如果嫁接云服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我可以为你提供有关树莓派如何嫁接云服务器的信息。你可以利用树莓派的标准网络接口来连接到云服务器，也可以使用Wi-Fi和蓝牙连接。你还可以使用Raspberry Pi的网络接口来连接到云平台，以获取可靠的连接。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b24a3520c927082f5688bc0ad187e0eb/" rel="bookmark">
			写一段在MT4交易软件图表上显示当前交易产品的交易保证金、点值、点差、当日涨跌值、当日振幅值、当日振幅百分比、隔夜利息、当前时间级别的倒计时信息的代码...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MT4交易软件中，可以使用以下代码来显示当前交易产品的交易保证金、点值、点差、当日涨跌值、当日振幅值、当日振幅百分比、隔夜利息、当前时间级别的倒计时信息：double margin = MarketInfo(Symbol(), MODE_MARGINREQUIRED); double point = MarketInfo(Symbol(), MODE_POINT); double spread = MarketInfo(Symbol(), MODE_SPREAD); double daily_change = MarketInfo(Symbol(), MODE_DAILYCHANGE); d
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06b3092054f960fa8b07933ee9000401/" rel="bookmark">
			用qt 写一个随机生成16进制数据的程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 我可以为您提供一个用Qt编写的随机生成16进制数据的程序的示例：#include #include int main(int argc, char *argv[]) { QApplication app(argc, argv); qsrand(QTime::currentTime().msec()); QString hex = QString("%1").arg(qrand(), 4, 16, QChar('0')); qDebug() &lt;&lt; hex; return app.exec(); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ae09e88d258cd502dd1c78387aa08dc/" rel="bookmark">
			冒泡排序代码python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 冒泡排序的python代码如下：
def bubbleSort(arr): n = len(arr) # Traverse through all array elements for i in range(n): # Last i elements are already in place for j in range(0, n-i-1): # traverse the array from 0 to n-i-1 # Swap if the elemen 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbc9e7565c252135f6eac1f1d069a664/" rel="bookmark">
			配置一下vim coc插件的clangd
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可以参考以下步骤：1. 安装clangd：使用包管理器安装clangd，或者从源码构建clangd。2. 设置Vim-Coc：在Vim中打开Coc-Settings.json，并添加“clangd.path”字段，指向clangd可执行文件的路径。3. 重启Vim，完成clangd配置。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07518f5b4e2854929ad4c0e83847b672/" rel="bookmark">
			STM32F103C8T6
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32F103C8T6 是一款基于 ARM Cortex-M3 内核的微控制器，由 STMicroelectronics 公司生产。它具有 32 位处理器，最高时钟频率可达 72 MHz，具有 64 KB 的闪存和 20 KB 的 SRAM。它还配备了多种外设，包括 USB 接口、ADC、DAC、SPI 和 I2C 等。STM32F103C8T6 通常用于工业控制、消费电子、通信和医疗设备等应用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/204c1499acb92052dc28714c5da8280a/" rel="bookmark">
			写一段python代码，实现快速排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		快速排序 def quick_sort(arr): if len(arr) &lt;= 1: return arr else: pivot = arr[0] left = [x for x in arr[1:] if x &lt; pivot] right = [x for x in arr[1:] if x &gt;= pivot] return quick_sort(left) + [pivot] + quick_sort(right)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25290a51fe99c1ef93b2a0dfa6de9ca1/" rel="bookmark">
			用Python写一段下雪的代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我可以给你一些示例代码，你可以使用它来实现下雪的效果：import pygame import random
初始化pygame pygame.init()
创建一个窗口 win = pygame.display.set_mode((500, 480))
窗口标题 pygame.display.set_caption('下雪')
定义雪花列表 snow_list = []
定义窗口背景 bg = pygame.image.load('snowy.jpg')# 定义雪花的类 class Snow: def init(self, x, y)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cac75fbc5c35aa1c38e120e97ffcb90e/" rel="bookmark">
			Cadence Allegro 17.4学习记录开始28-PCB Editor 17.4软件PCB中蛇形等长规则添加和设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 Cadence Allegro 17.4学习记录开始28-PCB Editor 17.4软件PCB中蛇形等长规则添加和设置一、直接等长法二、模型添加法模型添加法——点对点模型添加法——有串阻的等长创建XNet 三、Pin Pair创建 Cadence Allegro 17.4学习记录开始28-PCB Editor 17.4软件PCB中蛇形等长规则添加和设置 Allegro中设置等长有三种方法：
直接等长法，模型添加法，pin Pair添加法
一、直接等长法 只能用于点对点等长
第一、选择命令
第二，进入设置界面
需要点对点等长的线，需要创建一个Group，
然后选择需要等长的线，点击右键，直接创建，Match Group
第三、设置一个名称，方便记住，看懂，点击OK，就添加成功了
第四、如果没有显示需要等长的线的长度，就按以下操作
第五、如果以下内容是黄色的，没有显示内容，
可以一下操作：
1、
2、
3、
第六、确定目标线，选择最长的线，作为等长的目标
第七、误差介绍
第八、开始蛇形等长
回到主界面
1、点击一下命令
可以看到右下角显示出来，等长工具，
等长工具显示红色，说明这个线没有等长好
显示绿色，说等长好了
2、等长参数设置
二、模型添加法 模型添加法可以使用点对点上和有串阻的情况下：
模型添加法——点对点 第一，选择命令，添加模型
第二，弹出模型界面，出现以下内容，说明没有添加高速设置，需要以下操作：
1、在主界面，选择命令
2、按以下内容选择：
第三、然后重新打开，出现以下内容就是可以了，点击
第四、进行参数设置
第五、进行更新
第六、就可以在规则界面看到刚才添加的模型了
第七、将需要等长的线添加模型，驱动
第八、就可以看到这些线的长度，等，剩下就是进行蛇形等长了
模型添加法——有串阻的等长 有串阻的等长，都需要设置XNet，将两个线的网络设置成一个网络，就可以跟点对点一样设置蛇形等长了。
创建XNet 第一，选择命令
第二、出现页面，先点击串阻
第三、在点击create model
第四、安装以下操作
第五、安装以下操作，点击OK，就创建完成了，
将剩下需要进行XNet的全部一样操作即可。
打开规则管理器，就可以看到刚才创建的XNet网络了
就可以点击XNet网络进行创建模型了
剩下 的操作跟模型添加法——点对点等长一样了
三、Pin Pair创建 Pin Pair可以进行点对点等长和有串阻的等长。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cac75fbc5c35aa1c38e120e97ffcb90e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cdbb5c6c0de755625150492ba17448c/" rel="bookmark">
			如何实现一个线程安全的list
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 开发过程中，较常使用非线程安全的list，但遇到特定场景需要使用线程安全的，该如何使用呢？
是使用Vector，还是说有更好的实现方式？
1. 为什么不推荐使用Vector Vector的底层与ArrayList类似.都是以动态数组的方式进行对象的存储，Vector与ArrayList的区别在于Vector是线程同步操作安全的，因为官方在可能涉及到线程不安全的操作都进行了synchronized操作，相当于官方帮你加了一把同步锁
那为什么又说是线程不安全的呢？原因很简单，虽然官方帮你加上了同步锁，保证同一时间只会又一个线程操作同一个方法，但是他不能控制多个线程同时操作多个方法，也就是说，删除和添加是可以同时进行的，这就产生一个问题。
删除实际上是分为两步的，第一步，找到被删除的元素所在下标，第二步，根据下标删除这个元素；
添加也分为两步，第一步，找到添加的下标，第二步，将其设为传入的参数，也就是说存在添加时，找到了数组下标，但是在进行添加时，该数组下标已经被删除的问题，反之亦然 而关于同步这个问题，我们可以使用Collections这个工具类，将我们需要线程安全的集合转换一下，而不是直接使用Vector。在我们需要同步是时候就通过如下代码实现
List syncList = Collections.synchronizedList(list); 但是否这样就能够保证同步呢？
2. SynchronizedList的同步问题 在代码中，使用了SynchronizedList，初始代码如下： List list = Collections.synchronizedList(new ArrayList()); 在运用过程中，不对该List加锁处理。上线后，定时查看后台返回的crash信息，发现对该list的操作依然出现了ConcurrentModificationException。crash信息中显示该异常发生在执行for循环时：
错误的最后一句执行代码为：java.util.ArrayList$Itr.next(ArrayList.java:831) 看来SynchronizedList并不像想象的那样绝对保证线程安全，那问题如何出现的呢？ 先从增强for循环的实现说起。 增强for循环是基于迭代器实现的，如原始代码为：
for (Integer i : list) { System.out.println(i); } 反编译后
Integer i; for(Iterator iterator = list.iterator(); iterator.hasNext(); System.out.println(i)){ i = (Integer)iterator.next(); } 而我们的crash最后一句就是java.util.ArrayList$Itr.next(ArrayList.java:831)。 按照java的fail-fast机制中的介绍：
Iterator是工作在一个独立的线程中，并且拥有一个 mutex 锁。 Iterator被创建之后会建立一个指向原来对象的单链索引表，当原来的对象数量发生变化时，这个索引表的内容不会同步改变，所以当索引指针往后移动的时候就找不到要迭代的对象，所以按照 fail-fast 原则 Iterator 会马上抛出java.util.ConcurrentModificationException异常。
最终判断出使用的SynchronizedList在遍历过程中其List出现了内容的变更。 从源码中我们可以看到SynchronizedList是通过对mutex做同步来控制线程安全的，而mutex定义在其父类SynchronizedCollection中。
SynchronizedCollection(Collection&lt;E&gt; collection) { c = collection; mutex = this; } SynchronizedCollection(Collection&lt;E&gt; collection, Object mutex) { c = collection; this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8cdbb5c6c0de755625150492ba17448c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77b29c9381d99d7f48195c34884fef5d/" rel="bookmark">
			Linux管理文件命令（2）rm命令-删除文件或者目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、rm命令的介绍
二、命令语法及参数
三、参考实例 四、删错文件如何恢复
前言 rm是一个很危险的命令，使用的时候要特别当心，尤其对于新手更要格外注意，如执行“rm -rf /*”命令则会清空系统中所有的文件，甚至无法恢复回来。所以我们在执行之前一定要再次确认下在哪个目录中，到底要删除什么文件，考虑好后再敲击回车，时刻保持清醒的头脑。
一、rm命令的介绍 rm命令来自于英文单词remove的缩写，作用是用来删除文件或者目录的命令，一次可以删除多个文件，或者递归删除目录及目录下的所有子文件。
二、命令语法及参数 还是一样先通过man查看语法和参数
语法： rm [参数] file
NAME rm - 移除文件或者目录 总览 rm [options"]file... POSIX(Portable Operating System Interface 可移植的操作系统接口) 选项: [-fiRr] GNU 选项 (最短格式): [-dfirvR][--help][--version][--] GNU选项 -d，--directory 用unlink（2）来替代rmdir（2）移除目录，而且不要求目录为空 移除目录使用的方式是unlink（2），而非rmdir（2）， 且在试图unlink目录之前不要求其为空。 这仅在你有合适权限时才能生效。 因为unlink一个目录会导致在删除目录下的文件非关联化， 因此聪明的方法是在执行此之后fsck（8）文件系统。 -f，--force 忽略不存在的文件，并且从不向用户提示。 -i，--interactive 提示是否移除每个文件。如果回答是否定的，文件将被跳过。 -r，-R，--recursive 递归地移除目录中的内容。 -v，--verbose 在移除每个文件之前打印其名称。 可以看到的是参数并不是很多，常用的参数就是这几个了
-f强制删除（不二次询问）-i删除前会询问用户是否操作-r/R递归删除-v显示指令的详细执行过程 三、参考实例 1）可以看到的是rm -f 无法删除目录，加上-r代表递归删除，-rf一起就是强制删除目录了
[root@localhost ~]# mkdir -p /data/test [root@localhost ~]# touch /data/test/{a..f}.txt [root@localhost ~]# rm -f /data/test/ rm: 无法删除"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77b29c9381d99d7f48195c34884fef5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37fa9ee0a59cd8355a5ac4196861fe45/" rel="bookmark">
			30天自制操作系统（Mac版）读书笔记（day13）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 总结 在修改分辨率的时候发现，int 10的时候，修改了 mov bx, 0x4101和mov ax, 0x4f02，结果是黑屏，感觉是现存0xe0000000并没有数据，找了不少资料，也没有相关的代码。而且0xa0000的显存数据，明显是修改掉了的。不清楚是为什么。
虽然这次冲击，已经到达了前所未有的位置，但是最大的问题是没有搭建好调试环境，对于寄存器的状态还是不能明白。因此再继续尝试下去已经没有太多的意义。本系列暂时先这样。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d88362acc3b7f73c2ac92f6f5712c7b7/" rel="bookmark">
			Kettle连接Oracle(Oracle19c&amp;Oracle11g)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言Oracle驱动jar包：Mysql驱动jar包 :连接Oracleojdbc6.jar驱动可以链接11g和19c版本 总结 前言 kettle通过域名或者IP连接Oracle，本地不需要安装Oracle，但是要把Oracle的驱动jar包复制到kettle的lib目录下。
Oracle驱动jar包： （包括：ojdbc5.jar、ojdbc6.jar、ojdbc7.jar、ojdbc8.jar、ojdbc10.jar、ojdbc14.jar）
链接: 百度网盘 请输入提取码
提取码: lfwh
Mysql驱动jar包 : 链接：百度网盘 请输入提取码
提取码：lfwh
连接Oracle 我这里用的是：ojdbc6.jar
ojdbc6.jar驱动可以链接11g和19c版本 准备工作完成，下面连接Oracle：
主机名称：不用填 数据库名称：填写域名或者IP:端口/服务名 数据表空间：不用填 索引表空间：不用填 端口号：-1，因为再填写数据库名称时已经填写，所以这里填写-1 用户名：用户名 密码：密码 点击“测试” 总结 如果此篇文章有帮助到您, 希望打大佬们能关注、点赞、收藏、评论支持一波，非常感谢大家！
如果有不对的地方请指正!!!
参考1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0467580cae8d1c671a2ec186bd7b8ca6/" rel="bookmark">
			Kettle实现Oracle到Mysql数据复制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.背景
2.安装java 环境
3.部署kettle
3.1. 数据库连接驱动 3.2. 配置kettle转换
3.3.配置oracle和mysql连接
3.4 配置字符集
4. 配置迁移步骤
4.1.配置输入
4.2.配置表输出
4.3.检查
4.4 运行转换
4.5.执行结果 1.背景 工作上遇到个问题：客户本地服务器损坏，本地备份文件全部丢失，基于客户数据库做了个数据中心，实时同步客户数据，数据丢失只能从中心恢复。摆在面前的有几个问题：数据中心数据库是oracle，且数据中心数据量大，本身作为数据仓库存在，不止一个客户数据，数量级别以亿为单位；客户数据库为mysql，传统做法是由dba将数据仓库客户数据剔除生成csv文件，一个表一个文件，提供相关导出数据表结构，使用navicat导入csv文件，一个一个字段确认，过程麻烦不说，效率不高还容易出错；第二个场景，如果客户服务器一旦出问题，没有备份文件，需要立马恢复生产，这个时候只能干看着。这种情况很多，但是dba就是不会，多说一句，dba是真的拖后腿。
决定用kettle，是因为csv文件还原到客户数据库就是我来做，其中艰辛不多说。直接用kettle从数据中心直接还原到客户数据库，一次配置，永久有效，不同客户出问题直接换个ip就行。
Kettle是一款国外开源的ETL工具，纯java编写，可以在Window、Linux、Unix上运行，绿色无需安装，数据抽取高效稳定。kettle的数据抽取主要在于抽取数据，而没有考虑数据库的函数、存储过程、视图、表结构以及索引、约束等等，如果想对这些内容进行迁移，就需要通过写脚本或者更改kettle源码的方式实现了。
2.安装java 环境 参考：https://www.cnblogs.com/nothingonyou/p/11936850.html 3.部署kettle 官网下载较慢，这里选择国内镜像下载，使用的是pdi-ce-7.1.0.0-12.zip 版本。
官网地址：Home - Hitachi Vantara
下载地址：http://mirror.bit.edu.cn/pentaho/Data%20Integration/7.1/
浏览器下载真的很慢，还是用迅雷吧
解压后进入到Kettle目录，双击运行spoon.bat文件，出现如下界面及说明kettle成功部署。
3.1. 数据库连接驱动 在运行之前，我们需要下载对应数据库的jar包导入到Kettle的lib目录下，比如我们需要把oracle迁移到mysql，那就需要oracle和mysql两个jar包
3.2. 配置kettle转换 双击打开spoon.bat，在左侧主对象菜单栏，新建一个转换，命名为【数据同步】，如下图
3.3.配置oracle和mysql连接 输入对应连接信息
点击测试，显示成功即为配置完成 3.4 配置字符集 迁移时要确认两边数据库使用的是哪种字符集，不然可能会出现迁移后出现乱码的问题，我这里oracle是utf8，mysql是utf8：characterEncoding
4. 配置迁移步骤 4.1.配置输入 左侧菜单栏【转换】里面，选择【核心对象】，双击【表输入】，或者选中将【表输入】拖拽到右侧空白区域
双击【表输入】，修改“步骤名称”，选择源数据，点击获取【获取SQL查询语句】，选择你想同步的表，点击确定后就可以了。当然也可以自己写sql语句，我这里是自己写的sql，点击【预览】可以查看要迁移的数据。
4.2.配置表输出 配置表输出，在左侧菜单栏【转换】里面，选择【核心对象】，【输出】一栏接着双击【表输出】，或者选中将【表输出】拖拽到右侧空白区域。双击【表输出】，配置要迁移的目标表，我这里两边数据库字段一样，如图
有一点需要主要的地方，提交记录数量是批量写入数量条数；如果没得分区，表数据分区就取消选中，否则报错：The tablename is not defined (empty)
如果源表和目标表结构不一致，需要自己建立对应关系，可以通过右键单击输出，选择【根据目标步骤生成映射】，配置映射关系，点击【猜一猜】会自动匹配。如图
4.3.检查 在执行之前，检查整个过程是否存在问题：
4.4 运行转换 手工运行作业，点击下图红色圈圈里面的开始按钮，选择日志级别，如果没有红色报错基本无碍。
4.5.执行结果 另外一个方式比较简单，能实现单表或多表复制：工具 — 向导 — 复制多表向导，这种的使用场景适合于批量数据复制，源表目标表数据结构一致。快准狠
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5268b54c048059c44147f7948e83a5ab/" rel="bookmark">
			【C语言学习笔记】int和long的范围
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有关int和long型数据范围的分析
(1) int型一共32位，有一位作为符号位，其数据范围是-2^31 ~ 2^31,
即-2147483648 ~ 2147483647；
近似范围可以记为-2000000000 ~ 2000000000 即 - 2 × 10^9 ~ 2 × 10^9
本题中给的模数为1 × 10^9 + 7（1000000007），若再乘以3，就超过了int型的范围，所以要使用long存储结果才不会溢出
(2) long型一共64位，对应int型的方式，long型数据范围可以简单记为：
-8 × 10^18 ~ 8 × 10^18
本题的1000000007平方小于2 × 10^18，所以用long存储模数的平方也是没有问题的
作者：al-viewer
链接：https://leetcode.cn/problems/jian-sheng-zi-ii-lcof/solution/di-zi-fen-xi-shi-yong-dong-tai-gui-hua-q-jlr7/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f90aa01d7a4c875dc43ce0d7562f5138/" rel="bookmark">
			30天自制操作系统（Mac版）读书笔记（day12）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		添加定时器 在haribote.nasm中，LABEL_IDT的第33个终端函数就是系统时钟函数，所以在.021h:上面，添加以下代码：
.020h: Gate SelectorCode32, timerHandler,0, DA_386IGate 那么CPU上的“晶震”会定时的调用到timerHandler这个c语言函数中，那么我们再在这里做一些操作。当然也需要在init8259A的会变函数中，打开时钟中断的开关。
mov al, 11111001b out 021h, al call io_delay 实现TimerHandler 具体的就可以直接参考 代码 ，可以直接把timer.c 和timer.h拷贝到项目中，在main函数中自适当的调用就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55677b2ad13674a3a4812f09ae78fde3/" rel="bookmark">
			c语言 输出hello word
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include &lt;stdio.h&gt; int main() { printf("Hello, World!\n"); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/821a2b1f8e406c89628f4c349680a8ab/" rel="bookmark">
			斐波那契数列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		斐波那契数列的概念 斐波那契数列（Fibonacci sequence），又称黄金分割数列，因数学家莱昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”。
斐波那契数列指的是这样一个数列：
0，1，1，2，3，5，8，13，21，34，55，89，144，233，377，610，987，1597，2584，4181，6765，10946，17711……
它的规律是：这个数列从第 3 项开始，每一项都等于前两项之和。
在数学上，斐波那契数列以如下被以递推的方法定义：F(0)=0，F(1)=1, F(n)=F(n - 1)+F(n - 2)（n ≥ 2，n ∈ N*），显然，斐波那契数列是一个线性递推数列。
斐波那契数列的实现 常用的实现斐波那契数列的方法分为两大类：递归和循环。
1. 递归实现 #include &lt;stdio.h&gt; int F(int n) //斐波那契数列函数 递归形式 { if(n == 0) //初始化 return 0; if(n == 1 || n == 2) return 1; return F(n-1) + F(n-2); //如果n != 1 &amp;&amp; n != 2 进行递归运算 } int main() { int t,n; scanf("%d",&amp;t); while(t--) { scanf("%d",&amp;n); printf("%d\n", F(n)); } return 0; } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/821a2b1f8e406c89628f4c349680a8ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/955deae58b8132a2dc18fe964b391b11/" rel="bookmark">
			解决MAC上报错zsh: command not found: npm
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要已经下载了nvm，但经常出现系统找不到npm命令问题 (base) apple@localhost ~ % nvm -v 0.39.3 (base) apple@localhost ~ % nvm ls v18.14.1 v19.6.1 (base) apple@localhost ~ % nvm current none (base) apple@localhost ~ % nvm use 19.6.1 Now using node v19.6.1 (npm v9.4.0) 就可以解决了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9eddf12ab8f540be9fa825104436afb5/" rel="bookmark">
			【蓝桥杯】嵌入式编程_LED模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
认识led原理图
分析GPIO口寄存器
理解时钟的作用
实操部分---利用hal库生成led点亮代码
认识led原理图 (图来源：CT117E-M4产品手册.pdf)
VDD多半是单极器件的正（理解为电源 可以输出高电平 高电平为3.3v）
R为电阻 （可以看到图中 电阻值为0.3k）
那个三角形带箭头的是期间led灯（发光二几管）
最右右边的数字就是GPIO的引脚了 这个可以直接用编程语言控制的
什么情况下led灯点亮？ 高电平为3.3v 低电平为0v 有电压差超过0.7v就会有电流通过 有电流通过led就会被点亮
电阻的作用? I=V/R 如果没有电阻电流无限大 led会烧坏 所以最好控制在20mA以内 以上图为例3.3v/0.3k=11mA 如此电流流过led灯 就会被点亮
·什么是共阴/共阳极发光二极管？ 以上图为例 所有的led灯都接在了电源一端 所以上图是共阳极发光二极管 GPIO的引脚输出低电平led点亮
思考？什么情况下是高电平点亮led灯
*得出结论*
PA8-PA15 低电平点亮led灯
分析GPIO口寄存器 硬件编程本质就是关于寄存器的编程
操作硬件转化为操作地址 地址用寄存器分布
cpu管脚有很多可以使用的功能 也可以多个复用 需要用到那个功能就开启
思考 cpu管脚为什么要这样设计？一个管脚就一个功能行吗?
想一想我们这次的目的! 把PA8-PA15当做输出功能用 输出低电平 点亮led灯
编程思路
先找相关的寄存器
打开STM32G4系列微控制器参考手册.pdf
361页 9.4 GPIO registers
*注意***table 57给出各个GPIO的寄存器的偏移地址** 加上GPIO的基地址就可以找到这个寄存器的地址了
我们先一个一个的看 判断当前的寄存器是否与本次编程有关
这个寄存器是有用的设置端口功能模式 我们应该找到PA8-PA15 将相应的位设置为01 (通用输出方式)
接下来设置输出模式下的类型
通用推挽输出 直接输出高电平或者低电平
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9eddf12ab8f540be9fa825104436afb5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6acdac4d6dca74f207b3dd6cd1a15fb/" rel="bookmark">
			Redis的9种数据类型及使用场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在具体描述这几种数据类型之前，我们先通过一张图了解下 Redis 内部内存管理中是如何描述这些不同数据类型的：
首先Redis内部使用一个redisObject对象来表示所有的key和value,redisObject最主要的信息如上图所示：type代表一个value对象具体是何种数据类型，encoding是不同数据类型在redis内部的存储方式，比如：type=string代表value存储的是一个普通字符串，那么对应的encoding可以是raw或者是int,如果是int则代表实际redis内部是按数值型类存储和表示这个字符串的，当然前提是这个字符串本身可以用数值表示，比如:"123" "456"这样的字符串。
这需要特殊说明一下vm字段，只有打开了Redis的虚拟内存功能，此字段才会真正的分配内存，该功能默认是关闭状态的，该功能会在后面具体描述。通过上图我们可以发现Redis使用redisObject来表示所有的key/value数据是比较浪费内存的，当然这些内存管理成本的付出主要也是为了给Redis不同数据类型提供一个统一的管理接口，实际作者也提供了多种方法帮助我们尽量节省内存使用，我们随后会具体讨论。
redis支持丰富的数据类型，不同的场景使用合适的数据类型可以有效的优化内存数据的存放空间： string：最基本的数据类型，二进制安全的字符串，最大512M。
list：按照添加顺序保持顺序的字符串列表。
set：无序的字符串集合，不存在重复的元素。
sorted set：已排序的字符串集合。
hash：key-value对的一种集合。
bitmap：更细化的一种操作，以bit为单位。
hyperloglog：基于概率的数据结构。 # 2.8.9新增
Geo:地理位置信息储存起来， 并对这些信息进行操作 # 3.2新增
流（Stream）# 5.0新增
常用的前五种数据类型和使用场景总结如下： 1，String： 常用命令：
get, set, setnx, incr, decr, mget
使用场景：
缓存，热点数据
分布式session
分布式锁
INCR计数器
文章的阅读量点赞量
全局ID
2,List 常用命令
lpush：从列表List的最左边插入一个元素
lpop：从列表List的左边移出一个元素
rpush：从列表List的右边插入一个元素
rpop：从列表List的右边移出一个元素
llen:打印当前列表List的元素个数
lrange：按指定范围列出来
使用场景：
公众账号的关注列表，粉丝列表
Redis的分页功能，消息队列，发红包场景 3,Set 常用命令
sadd：往set中添加数据
srem：从set中删除数据
spop: 命令移除并返回集合中的一个随机元素
scard：查看set中存在的元素个数
sismember：查看set中是否存在某个数据
使用场景：
问答的点赞，喜欢，收藏数量，商品的筛选，相互关注
有共同爱好喜好的人，可能认识的人，标签
4,Hash 常用命令
hget：通过key值，从hash里取对应的value
hset：往hash里，添加key-value
hmget：一次性获取多个key的value
hgetall：获取所有
hkeys：获取所有的key
hvals: 获取所有的values
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6acdac4d6dca74f207b3dd6cd1a15fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/908774a6ccfeb7d7f8ac6c98a0b42577/" rel="bookmark">
			NoMachine 输入用户名密码后 闪断 解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是虎哥，最近工作忙，好长时间没有继续套件的深度学习，今天周六，难得有空，泡好茶，打开电脑，链接套件桌面，得，出问题了，一个很奇怪的问题，win 端NoMachine输入用户名密码,链接EHub_tx1_tx2_E100后 闪断。
目录
问题记录：
尝试解决办法：
最终解决办法：
问题记录： 点击链接：
点击OK后，出现链接成功得后续就闪退了，闪退太快，我年纪大了，没有抓到图！
尝试解决办法： 遇到这种事，我其实首先想到是不是对面服务没有起来，赶紧先确认一下EHub_tx1_tx2_E100套件内的情况
nvidia@ubuntu:~$ sudo /usr/NX/bin/nxserver --status NX&gt; 111 New connections to NoMachine server are enabled. NX&gt; 161 Enabled service: nxserver. NX&gt; 161 Enabled service: nxnode. NX&gt; 161 Enabled service: nxd. nvidia@ubuntu:~$ sudo netstat -ntulp | grep nxd tcp 0 0 0.0.0.0:4000 0.0.0.0:* LISTEN 6768/nxd tcp6 0 0 :::4000 :::* LISTEN 6768/nxd udp 0 0 0.0.0.0:4000 0.0.0.0:* 6768/nxd udp6 0 0 :::4000 :::* 6768/nxd 看起来套件内的服务运行正常。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/908774a6ccfeb7d7f8ac6c98a0b42577/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0027daad3334b518b1e42cc387c14bc5/" rel="bookmark">
			获取java配置文件路径的通用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		此方法来源于：黑马javaweb教程中p38集数据库连接池-简介&amp;Druid使用
1.首先需要获取当前代码所在的路径位置：System.out.println(System.getProperty("user.dir"));
2.第一步得到路径后，然后根据自己配置文件的位置，写出相对路径即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/438ce973e776d37a4de923c05440a996/" rel="bookmark">
			写一个h5 瀑布流商品列表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		非常感谢您的提问，我很乐意为您回答。我们可以使用HTML5和CSS3来构建一个瀑布流商品列表，主要步骤如下：1.创建一个容器，用于存放商品列表；2.使用CSS的float属性来确定商品列表的位置；3.使用JavaScript来根据用户的滚动来加载更多的商品；4.使用AJAX获取服务器端的数据；5.将商品列表插入到容器中；6.使用CSS3实现动画效果。以上就是我们写一个H5瀑布流商品列表的基本步骤，希望能够给您带来帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f20aec401e9a0f90c714752bcfc6b8fa/" rel="bookmark">
			Elasticsearch基础学习（Java API 实现增删查改）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概述 ElasticSearch，简称为ES， ES是一个开源的高扩展的分布式全文搜索引擎。它可以近乎实时的存储、检索数据；本身扩展性很好，可以扩展到上百台服务器，处理PB级别的数据。
物理设计：
ElasticSearch 在后台把每个索引划分成多个分片，每份分片可以在集群中的不同服务器间迁移。
逻辑设计：
一个索引类型中，包含多个文档，比如说文档1，文档2，文档3。当我们索引一篇文档时，可以通过这样的一个顺序找到它: 索引 -▷ 类型 -▷ 文档ID ，通过这个组合我们就能索引到某个具体的文档。
二、环境搭建 下载安装elasticsearch-6.8.13、es-head-chrome插件。
下载ES相关插件，将插件放置plugins目录下：
三、ES启动 启动命令：elasticsearch.bat
若能成功访问 http://loaclhost:9200，则启动成功
可通过 es-head-chrome插件查看ES后台：
启动kibana：
访问：http://localhost:5601
在开发工具中，可执行Rest命令
四、Springboot项目搭建 创建Springboot项目：
五、添加ES依赖 设置ES版本：
&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;elasticsearch.version&gt;6.8.13&lt;/elasticsearch.version&gt; &lt;/properties&gt; 导入ES依赖，JSON依赖：
&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.54&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch-rest-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.elasticsearch&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch&lt;/artifactId&gt; &lt;/dependency&gt; 六、编写配置类 @Configuration public class config { @Bean public RestHighLevelClient restHighLevelClient() { RestHighLevelClient client = new RestHighLevelClient( RestClient.builder(new HttpHost("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f20aec401e9a0f90c714752bcfc6b8fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce8c314da2a8edcf1c1e1f72734a3a94/" rel="bookmark">
			NLP学习路线（其实就是个汇集了所有经典模型的自然语言处理学习笔记）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		按照该知乎文章：从Word Embedding到Bert模型—自然语言处理中的预训练技术发展史里罗列的发展史，对自然语言处理各个模型进行学习。
同步观看斯坦福大学的经典NLP课程打基础。
但说实话，概念是讲得很好，但不足以完全理解，所以也同时自己断断续续找论文或者什么来进行理解吧。
这里也会将所有的链接放上来，加上一些学习体会。
开始学习 词向量（Word2Vec） 1、按理来说从知乎文章的标题看，应该是要从word embedding开始学起，但是我在看文章的时候，又发现第一个概念是语言模型，所以也自己去搜索了一些相关资料来看，说实话，看的不是很懂，只有一点模模糊糊的概念吧——语言模型分不同种的语言模型，现在最经典的就是神经网络语言模型。
语言模型找到的文章我没觉得有什么合适的，这里暂时不放。
下一个主要是需要理解word2vec吧，它是一种词嵌入方法。我找到的一篇文章word2vec介绍，感觉写得很棒。
词嵌入（word embedding）：将高维度的词表示转换为低维度的词表示的方法。
按照我的理解，其实就是将onehot编码的长度浪费改善，变成能够控制在30维度的表示方法。即“句子中每个单词以Onehot形式作为输入，乘以学好的Word Embedding矩阵Q，直接取出单词对应的Word Embedding”
2、此处再补上我在斯坦福大学视频里看到的另一种词向量转换方法——GloVe，按照视频里的讲解来说，如果只是单拎出word2vec和GloVe，GloVe的效率会更好些。但是视频我并没有看得很懂，因此也去找了相关文章，GloVe模型理解此文章中也引用了视频中的PPT。
遗留下的问题：word2vec最大的缺陷是无法解决多义词问题，即如果将一个词对应的向量定下来后，即使出现其他语义情况也无法再改变。
RNN 老规矩，依旧是找了个介绍通俗易懂的RNN来看。我觉得概念上是很好的，但是它的图画的不是很清楚，可能一时难以看懂。
这是斯坦福视频上截图下来的图片，我觉得更准确些，可以结合着看下。
RNN：时序神经网络，拥有时间上的顺序性。能结合上下文考虑，弥补了全连接神经网络的不足。
补充一个那篇博客中没谈到的信息：第一个h(0)一般设为零。
RNN通过结合前向传播信息的方式，初步为多义词问题提供了解决方法——结合上文信息。本质上就是不割裂地将每个词提取出来理解，而是能够通过匹配前文关键词来进行查找，使得多义词能在不同语境下得到不同解释。
遗留下的问题：会存在梯度消失，即模型难以学习到远距离的依赖关系。
LSTM 我感觉这篇LSTM详解已经把LSTM原理解释得很清楚了，而且很生动形象。
LSTM的输入输出其实和RNN都是一样的，但是通过细胞层的设置解决了梯度消失的问题，即将各个部分的重要性依次使用公式计算，这样就不会出现远距离的依赖关系低的问题。
遗留下的问题：表面上似乎没有什么问题了，但其实这个结合的方法是死板的，只结合前文而没有结合后文，依旧会出现考虑不全面的问题。
其实如果按照斯坦福课程的顺序，后面就直接到transformer了，即解决LSTM遗留下这个问题的关键模型。但是知乎上那篇文章的顺序，则是按照历史轨迹，讲了所有的发展史，但都是致力于解决多义词（无法动态联系上下文判断词语意义）的问题。
可以按照知乎这篇文章的顺序看下ELMo等相关的模型，会更全面点，它的介绍也差不多将各个模型的精髓都讲到了。但直接跳到“transformer”看，其实也完全没问题，因为历史上这些模型，大体上的原理没有太多差别，不过细节不一样而已。
Seq2Seq（Attention） seq2seq是在RNN的基础上加以改进的，最大的区别就是对输入输出的数量能够随意进行改动。而在这里将它强调一下，是为了突出Seq2Seq和attention结合的用法，这是后面的transformer最重要的一部分。
Seq2Seq 模型详解这篇文章是一个整体的介绍，我觉得理解是挺好理解的，但其实对于attention的机制介绍的不是很清楚。
注意力机制的话，其实类似于人，当我们看文章或者图片等信息时，肯定会对其中某个部分投入更多的注意力，比如一段话中“这是一个桌子”，注意力肯定也是放在“桌子”这个词上的。至于使用方法是分别建立K、V、Q，然后找到其中注意力最大的词。
想要详细了解可以看李宏毅老师的这篇强烈推荐！台大李宏毅自注意力机制和Transformer详解！，我看了很多介绍的文章视频，只有这个是让我看懂了的。下面的transformer李宏毅老师也在这里讲解了，可以一起学习下。
transformer transformer中有两篇很著名的文章“Attention Is All You Need” 和 “The Illustrated Transformer”，不过直接看的话，可能因为基础知识不够和语言不通容易有点困难，因此我在在csdn上找到了解析“Attention Is All You Need”这篇论文的文章Transformer 模型详解，再加上看李宏毅老师的视频才算对transformer勉强有了个大概理解。transformer的原理和attention息息相关，具体的能看懂文章和听懂视频应该就差不多了。
Bert bert是现在nlp里面独占鳌头的模型了，nlp大部分领域用bert模型做训练应该都能能得到很好的效果，也有许多人在它的基础上不断改进。bert是基于transformer的encoder模块做出的，其中关于mask的部分是比较特殊的使用方法，却在提升效率上有很大进展。
关于bert的文章其实挺多的，但我觉得这篇什么是BERT？解释的很清楚。
补充 开头的斯坦福教学视频资源是2017年的，虽然被很多人奉为经典，但不可否认，里面很多信息都没有进行更新，也就是说最近的语言模型都是没用提到的（我也是看了几集才发现的……但这个视频的价值还是很高，有时间最好是全部过一遍）
我又去B站再次找资源，斯坦福CS224n这个似乎是2021年录制的视频。
有了LSTM，Seq2Seq等内容。但是，这个版本好像没有中文翻译……
B站有同步字幕，但不是所有的都能够翻译，所以再带着练练听力吧……
总结 这是我整理的关于NLP较为详细的一个学习路线笔记，大方向的发展应该就是这样，但想要真正能够理解这些模型也是很困难的事情。其实现在bert已经占了nlp的半壁江山了，所以如果真的只是为了运用，又想要高效率的话，似乎把bert搞懂就差不多了。而且越到后面，其实有些思路反而简单了起来，没有之前那么晦涩难懂了。
如有不足请批评指正，我也是个刚踏入这行的菜鸟，望共同进步。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c91bf42cc6b2d04006c955032f97ea5/" rel="bookmark">
			Springboot多环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		此文章是根据黑马程序员课程所做的笔记课程视频
多环境开发 ​ 什么是多环境？其实就是说你的电脑上写的程序最终要放到别人的服务器上去运行。每个计算机环境不一样，这就是多环境。常见的多环境开发主要兼顾3种环境设置，开发环境——自己用的，测试环境——自己公司用的，生产环境——甲方爸爸用的。因为这是绝对不同的三台电脑，所以环境肯定有所不同，比如连接的数据库不一样，设置的访问端口不一样等等。
1.多环境开发（yaml单一文件版） ​ 如下
spring: profiles: active: pro	# 这里是指定启动的环境配置，启动pro ---	#环境与环境之间用———相隔 spring: profiles: pro	#pro环境配置 server: port: 80 --- spring: profiles: dev	#区分环境靠———和命名，此处就是命名 server: port: 81 ​ 就这么简单，再多来一组环境也OK
spring: profiles: active: pro	# 启动pro --- spring: profiles: pro server: port: 80 --- spring: profiles: dev server: port: 81 --- spring: profiles: test server: port: 82 ​ 其中关于环境名称定义上述格式是过时格式，标准格式如下
spring: config: activate: on-profile: pro 总结
多环境开发需要设置若干种常用环境，例如开发、生产、测试环境yaml格式中设置多环境使用—区分环境设置边界每种环境的区别在于加载的配置属性不同启用某种环境时需要指定启动时使用该环境 2.多环境开发（yaml多文件版） ​ 将所有的配置都放在一个配置文件中，尤其是每一个配置应用场景都不一样，这显然不合理，于是就有了将一个配置文件拆分成多个配置文件的想法。拆分后，每个配置文件中写自己的配置，主配置文件中写清楚用哪一个配置文件就好了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c91bf42cc6b2d04006c955032f97ea5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de28020e8e51f975f3fa3f579b1ef360/" rel="bookmark">
			小知识点：Mac M1/M2 VMware Fusion 安装 Centos 7.9（ARM 64 版本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近换了 Mac M2 芯片的笔记本，用原来的 Centos 镜像安装虚拟机直接报错 “无法打开此虚拟机的电源，因为它需要使用 X86 计算机架构，而该架构与此 Arm 计算机架构主机不兼容。”
安装流程 前置一、下载镜像二、安装虚拟机三、配置静态 IP四、安装大数据环境 前置 之前 Intel 芯片的 Mac 用的都是 Parallels Desktop 玩虚拟机，现在换新 Mac 用的是新的 M2 芯片，之前以为 x86 架构用不了换成 arm 架构就行，结果在网上冲浪了一天都没能安装成功，一直卡在 Install Centos 7 那个页面不断跳回来，后来翻了很多博客，又找了很多镜像来跑，终于找到一个合适的可以用，下面就是镜像安装的具体流程，需要 VMware Fusion 的可以直接官网下载，然后搜一个激活码就行了。
一、下载镜像 防止失效，存在我的阿里云盘里面 https://www.aliyundrive.com/s/8U3eN5a8EMY镜像后缀在下载完成之后修改成 iso 后缀 二、安装虚拟机 直接选择下载好的镜像安装
根据自己的实际需求进行设置 根据自己实际需要配置处理器、内存和硬盘以及其他的 这里我就配置处理器、内存和硬盘，配置完关闭页面然后启动 选择第一个安装，然后回车，等他跑完进入页面 根据自己实际情况选择，看不懂英语的可以选择中文 修改 Time &amp; Date 根据自己实际情况修改 Software Selection 我自己使用 Minimal 安装就可以了，其他的参考下面的安装 把 Kdump 关了（根据个人情况选择） 修改 Network &amp; Host Name 设置 root 密码以及 User 账户 过于简单的密码需要按两次 配置硬盘，我个人使用的是自动 配置完之后点击右下角开始安装，然后等待跑完重启就可以了 mini 安装模式直接就是命令行，桌面模式会多一个可视化操作页面，根据实际情况弄就行了 到这里，恭喜你，安装成功了，开始你的操作吧 三、配置静态 IP root 账户下操作 vi /etc/sysconfig/network-scripts/ifcfg-eth160BOOTPROTO 改成 static添加 GATEWAY、IPADDR、NETMASK、DNS，具体的根据各自实际情况配置，在前面启动网络的时候也有相关配置 ping www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de28020e8e51f975f3fa3f579b1ef360/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd0b4700d38c52dd67b1ce60956ce2f5/" rel="bookmark">
			asis2016_b00ks --堆的off-by-null
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		具体的题目文件都可以在buuctf里面找到
首先先看主函数
上面都是一堆初始化，从sub_B6D(v3)开始看，这个也是漏洞存在的地方
让你输入作者的名字，跟进入sub_9f5这个函数
他会把你输入的字符一个一个输进去，最后判断是否达到最大a2=32或者换行（ida把换行弄成10了）然后退出判断，可是最后有个赋值0的操作，假如输入最大字符数32，那么下面这个会把第33个字符给搞成00，也就是我们俗称的off-by-null
先看看创建一个块后，内存的情况
def dbg(): gdb.attach(r) pause() def add(name_size,name,content_size,content): r.sendlineafter('&gt; ','1') r.sendlineafter('size: ',str(name_size)) r.sendlineafter('chars): ',name) r.sendlineafter('size: ',str(content_size)) r.sendlineafter('tion: ',content) def delete(index): r.sendlineafter('&gt; ','2') r.sendlineafter('delete: ',str(index)) def edit(index,content): r.sendlineafter('&gt; ','3') r.sendlineafter('edit: ',str(index)) r.sendlineafter('ption: ',content) def show(): r.sendlineafter('&gt; ','4') def change(author_name): r.sendlineafter('&gt; ','5') r.sendlineafter('name: ',author_name) r.sendlineafter('name: ', 'a' * 0x1f + 'b') add(0xd0, 'aaaa', 0x20, 'bbbb') #chunk1 dbg() 先输入命令找到写作者名字的那块内存空间
找到了就是0x5589f0ddc040这个
然后查看这块内存
x/40gx 0x5589f0ddc040 0x5589f0ddc040:	0x6161616161616161	0x6161616161616161 0x5589f0ddc050:	0x6161616161616161	0x6261616161616161 0x5589f0ddc060:	0x00005589f280d130	0x0000000000000000 0x5589f0ddc070:	0x0000000000000000	0x0000000000000000 0x5589f0ddc080:	0x0000000000000000	0x0000000000000000 0x5589f0ddc090:	0x0000000000000000	0x0000000000000000 0x5589f0ddc0a0:	0x0000000000000000	0x0000000000000000 0x5589f0ddc0b0:	0x0000000000000000	0x0000000000000000 0x5589f0ddc0c0:	0x0000000000000000	0x0000000000000000 0x5589f0ddc0d0:	0x0000000000000000	0x0000000000000000 0x5589f0ddc0e0:	0x0000000000000000	0x0000000000000000 0x5589f0ddc0f0:	0x0000000000000000	0x0000000000000000 到这一步先暂停一下，看看其他功能
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd0b4700d38c52dd67b1ce60956ce2f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56da998f8f49f39778b900efccbe4e27/" rel="bookmark">
			【C语言】MAC地址格式化转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言MAC地址格式化转换（sscanf()和sprintf()实现） 001122334455 ＜==＞ 00:11:22:33:44:55
1.sscanf()函数
C 库函数 int sscanf(const char *str, const char *format, …) 从字符串读取格式化输入。
int sscanf(const char *str, const char *format, ...); str -- 这是 C 字符串，是函数检索数据的源。 format -- 这是 C 字符串，包含了以下各项中的一个或多个：空格字符、非空格字符 和 format 说明符。 下面实例演示 sscanf() 函数的用法：
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; int main() { int day, year; char weekday[20], month[20], dtm[100]; strcpy( dtm, "Saturday March 25 1989" ); sscanf( dtm, "%s %s %d %d", weekday, month, &amp;day, &amp;year ); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56da998f8f49f39778b900efccbe4e27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf1391a92c84e4e390d8b001b39f6c82/" rel="bookmark">
			JSON.parse解析字符串中含有引号报错的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题说明：
当JSON.stringify(obj)的时候是双引号，使用JSON.parse转化的时候会报错
问题解决：
解决的方案也就从转义字符下手。方法：在字符串保存之前，即在使用JSON.stringify之前，我们将所有的引号加上转义就行，将对象的内容使用.replace(/\“/g, '”')；
let item={id:"xxx",name:"xxxx"}; let result=JSON.stringify(item).replace(/\\"/g, '"') let obj=JSON.parse(result) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65cedd541f6ed5846e5cab62b71f3dd8/" rel="bookmark">
			华为pppoe简单配置实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pppoe，传统以太网上的点对点协议，是将点对点协议（PPP）封装在以太网（Ethernet）框架中的一种网络隧道，一说到隧道，我们想到的都是虚链路，因为传统的以太网协议无法支持点对点协议，所以pppoe建立以太网之上，还继承了ppp协议的加密功能。
一实验拓扑 二实验配置 服务端：
配置全局地址池
ip pool 1 gateway-list 192.168.1.1 network 192.168.1.0 mask 255.255.255.0 指定用户的认证模式和用户
local-user lmy1 password cipher %$%$\gHR~d.qM&amp;K)MqFjx*^D2B-+%$%$ local-user lmy1 service-type ppp local-user admin password cipher %$%$K8m.Nt84DZ}e#&lt;0`8bmE3Uw}%$%$ local-user admin service-type http 配置认证专属domain，全部是默认
aaa authentication-scheme default authorization-scheme default accounting-scheme default domain default domain default_admin 创建虚拟模板并绑定接口
interface Virtual-Template1 ppp authentication-mode chap remote address pool 1 ip address 192.168.1.1 255.255.255.0 # interface GigabitEthernet0/0/0 pppoe-server bind Virtual-Template 1 客户端：
设置拨号规则
dialer-rule //进入拨号规则编辑器 dialer-rule 1 ip //允许所有ip 2、创建拨号接口并配置认证用户和密码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65cedd541f6ed5846e5cab62b71f3dd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5c96b404489db8bb8d224d72ae05c6a/" rel="bookmark">
			TGRS2023/遥感/目标检测：CoF-Net: A Progressive Coarse-to-Fine Framework for Object Detection
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TGRS2023/遥感/目标检测：CoF-Net: A Progressive Coarse-to-Fine Framework for Object Detection in Remote-Sensing Imagery CoF-Net：一种由粗到精的遥感图像目标检测框架 1.概述2.方法2.1.整体架构2.2.由粗到精的光谱特征自适应2.2.1.空间-光谱嵌入Spatial–Spectral Embedding2.2.2.光谱非局部调制Spectral Nonlocal Modulation2.2.3.细粒度特征对齐Fine-Grained Feature Alignment 2.3.由粗到细的样本分配策略2.3.1.粗锚点建议2.3.2.基于几何约束的精细样本选择2.3.3.细粒度类别感知样本精化 1.概述 本文提出了一种新颖的由粗到精的遥感图像目标检测框架( CoF-Net )。CoF - Net主要由两个并行分支组成，即由粗到精的特征自适应( CoF-FA )和由粗到精的样本分配( CoF-SA )，分别旨在逐步增强特征表示和选择更强的训练样本。具体来说，CoF - FA将原始的粗特征平滑地细化为具有判别性空谱细节和语义关系的多光谱非局部精细特征。同时，CoF - SA通过在训练过程中逐步引入几何和分类约束进行样本分配，动态地从粗到细考虑样本。
提出的CoF - FA以由粗到精的方式设计用于多光谱非局部特征自适应。CoF - FA在频域中显著地丰富了空谱特征细节，提高了细粒度对齐的隐式语义判别能力。
所提出的CoF - SA引入几何和分类感知约束，在训练过程中逐步动态分配样本，避免监督干扰。与CoF - FA相比，CoF - SA对遥感图像中密集和杂乱物体的准确和鲁棒定位具有重要贡献。
2.方法 2.1.整体架构 提出的CoF - Net概述。它由一个主链、一个探测头和两个关键的并行分支CoF - FA和CoF - SA组成。
所提出的CoF - Net的整体流程如图2所示。CoF - Net建立在RetinaNet [ 69 ]的基础上，是一个具有全卷积层的单阶段框架[ 78 ]，可以在少量参数的情况下实现快速推理，用于实际场景中的多尺度地理空间目标检测。
CoF - Net主要由4个部分组成：
1 ) ResNet作为CNN主干进行粗特征提取；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5c96b404489db8bb8d224d72ae05c6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8296b5305c98bdf4d5801e7a1a093b65/" rel="bookmark">
			IO进程学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【1】标准IO 定义 在C库中定义的一组专门用于输入输出的函数 特点 1.通过缓冲机制减少系统调用的次数，提高效率。 2.围绕流进行操作的，流用FILE *描述，FILE是结构体，保存文件的属性信息。 3.默认打开了三个流，stdin(标准输入)、stdout(标准输出)、stderr(标准错误) 缓冲区 全缓存：和文件相关 刷新缓存的条件： 1.程序正常退出 2.缓存区满刷新 3.fflush强制刷新 行缓存：和终端相关 刷新缓存的条件： 1.程序正常退出 2.\n刷新 3.缓冲区满刷新 4.fflush强制刷新 不缓存：没有缓存区，标准错误 计算标准输出的缓存区大小：
printf(“\n”);//调用输出
printf(“%d”,stdout-&gt;_IO_buf_end-stdout-&gt;_IO_buf_base);
函数接口 打开文件-读写文件-关闭文件 打开文件 FILE *fopen(const char *path,const char *mode); 功能：打开文件 参数：path:打开文件的路径 mode:打开方式 r	只读，流被定位到文件开头 r+	可读可写，流被定位到开头 w	只写，文件不存在创建，存在清空，流被定位到文件开头 w+	可读可写，文件不存在创建，存在清空，流被定位到文件开头 a	追加，文件不存在创建，存在追加，流被定位到文件末尾 a+	可读可写，文件不存在创建，存在追加；第一次读文件时流被定位到文件开头，写始终在末尾 读写文件 1.每次一个字符的读取 int fgetc(FILE *stream) 功能：从文件中读取一个字符 参数：stream：文件流 返回值： 成功：读到字符的ASCII码 失败或读到文件末尾：EOF int fputc(int c,FILE *stream) 功能：向文件中写入一个字符 参数：c：要写的字符 stream：文件流 返回值：成功：写的字符的ASCII 失败：EOF 练习：编程实现cat功能。cat 文件名
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8296b5305c98bdf4d5801e7a1a093b65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc950cfbcbbb7a79261b0669257cc11f/" rel="bookmark">
			最近在GitHub发现一个宝藏项目，爱了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近逛Gitbit发现了一个宝藏资料，分享给大家！
学习项目GitHub开源地址：
https://github.com/AlibabaP8Developer/knowledge
希望对你们有所帮助❤️，如果喜欢记得给个star哦🌟 博客网址：https://www.knowledge-code.com/#/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7eeac15d859fdce9057cb1ed7e55084/" rel="bookmark">
			解决远程调用服务超时---IPV（idea）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 -Djava.net.preferIPv4Stack=true 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b67cfe65921530ce02eedbdc78ce3190/" rel="bookmark">
			35.MySQL导出数据的几种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.导出全表数据。
select * from test into outfile '/tmp/a.sql';
2.导出某个数据库下的表。
--secure-file-priv='' mysqldump -T /data/backup -u root -prootroot --set-gtid-purged=OFF test
将test数据库导出到：backup目录下。
3.导出自定义格式的文件。
mysql -uroot -prootroot -e "select * from t2;" test &gt; t2.sql id name age
1 NULL 18
2 xsq2 18
3 xsq3 18
4 xsq4 18
5 xsq5 18
4.输出垂直列的结果。
mysql -uroot -prootroot --vertical -e "select * from t2;" test &gt; t2_3.sql *************************** 1. row ***************************
id: 1
name: NULL
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b67cfe65921530ce02eedbdc78ce3190/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f537e0f23aac04b2f3cfa0b9e57031b9/" rel="bookmark">
			获取粘贴数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 获取粘贴的值 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/059852d9878d4e91648a7789b3043af1/" rel="bookmark">
			恒源云&#43;MobaXterm&#43;Filezilla实现利用远程服务器跑去代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、注册恒源云并创建项目 创建后，如下图：
二、下载Filezilla并上传本地项目至远端服务器 打开Filezilla，点击-&gt;文件-&gt;站点管理器-&gt;新站点-&gt;协议“SFTP”，对应上图创建好的项目填写主机名，端口号以及用户及密码，登陆类型为正常。
如何获取主机名，端口号和密码？
红色方框目录为实例目录，绿色方框目录为本地项目的目录
进入实例中的/hy-tmp/目录
将本地数据传送到实例中
三、使用MobaXterm启动远程恒源云上的项目 打开MobaXterm，输入登录指令及密码
选择No，项目便显示至操作远程项目的终端上
打开你刚建的文件夹hy-tmp找到你所上传的文件夹
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b6f3cbc5017a28d2e9e196092201611/" rel="bookmark">
			Linux系统调用之lseek函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 如果，想要深入的学习Linux系统调用函数lseek了话，还是需要去阅读Linux系统中的帮助文档的。
具体输入命令：
man 2 lseek
即可查阅到完整的资料信息。
lseek函数 lseek函数是Linux系统API中的一员，它的官方定义是：重新定位读或写的文件偏移量。
这里科普一下什么叫做当前文件偏移量：
每当打开一个文件，都会有一个叫做“当前文件偏移量”的东西，如果难理解也可以将他理解为指针。 除非打开文件时指定O_APPEND选项，否则文件偏移量默认设置为0。当我们发生了一次读或者写操作时，都会使这个当前文件偏移量发生变化，读/写多少字节，当前偏移量就会向后移动多少。 知道了这个概念了后，我们就了解了lseek函数它有些什么作用。下面我们来细细介绍一下这个函数。
它的函数原型是长这样的：
off_t lseek(int fd, off_t offset, int whence);
先来说一下这个off_t类型吧，它用于指示文件的偏移量。你可以就简单的理解为这是一个64位的整形数，相当于long long int，其定义在unistd.h头文件中可以查看。
在使用这个函数之前，我们需要往C/C++文件中导入这些头文件：
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
通过lseek函数的函数原型我们可以知道，我们需要给它传入3个参数，那我们依次介绍这三个参数是什么，有什么含义在里面。
PS：题外话，如果有听不懂的地方，请自行查阅Linux帮助文档，开头有些查阅方法，一手知识永远是最好的知识。 参数：fd //文件描述符，可以通过open函数得到，通过这个fd可以操作某个文件
参数: offset //文件偏移量，是一个整形数
参数：whence //偏移类型，下列三个值中选一个。
whence :
SEEK_SET:该文件的偏移量设为离文件开头offset个字节.
SEEK_CUR:该文件的偏移量设为其当前值加offset(PS :offest可正负).
SEEK_END:该文件的偏移量设为文件长度加offset
再来聊一下返回值：
如果成功：返回文件指针的位置
如果失败：返回-1,并将错误原因赋值给errno，我们可以用标准C库中的perror函数打印出错误原因。需要引入头文件 #include &lt;stdio.h&gt;
lseek函数的作用 lseek函数的作用有以下四点：
1.移动文件指针到文件头：
lseek(fd, 0, SEEK_SET);
2.获取当前文件指针的位置
lseek(fd, 0, SEEK_CUR);
3.获取文件长度
lseek(fd, 0, SEEK_END);
4.拓展文件的长度，当前文件10b, 110b, 增加了100个字节
lseek(fd, 100, SEEK_END)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b6f3cbc5017a28d2e9e196092201611/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/764b1fe29a1abe67cf6ea398cb1baa3c/" rel="bookmark">
			C&#43;&#43;之迭代器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		迭代器 C++中，迭代器就是类似于指针的对象，但比指针的功能更丰富，它提供了对对象的间接访问，每个迭代器对象代表容器中一个确定的地址。
举个例子：
void test() { vector&lt;int&gt; vv={1,2,3,4,5}; for(vector&lt;int&gt;::iterator it=vv.begin();it!=vv.end();it++) { cout&lt;&lt;*it&lt;&lt;" "; } cout&lt;&lt;endl; } //1 2 3 4 5 迭代器的分类 正向迭代器 只能使用++运算符从左向右遍历容器，每次沿容器向右移动一个元素。
容器名&lt;元素类型&gt;::iterator 迭代器名; // 正向迭代器。 容器名&lt;元素类型&gt;::const_iterator 迭代器名; // 常正向迭代器。 相关的成员函数： iterator begin(); const_iterator begin(); const_iterator cbegin(); // 配合auto使用。 iterator end(); const_iterator end(); const_iterator cend(); 双向迭代器 具备正向迭代器的功能，还可以反向（从右到左）遍历容器（也是用++），不管是正向还是反向遍历，都可以用--让迭代器后退一个元素。 容器名&lt;元素类型&gt;:: reverse_iterator 迭代器名; // 反向迭代器。 容器名&lt;元素类型&gt;:: const_reverse_iterator 迭代器名; // 常反向迭代器。 相关的成员函数： reverse_iterator rbegin(); const_reverse_iterator crbegin(); reverse_iterator rend(); const_reverse_iterator crend(); 随机访问迭代器 具备双向迭代器的功能，还支持以下操作： 用于比较两个迭代器相对位置的关系运算（&lt;、&lt;=、&gt;、&gt;=）。 迭代器和一个整数值的加减法运算（+、+=、-、-=）。 支持下标运算（iter[n]）。 迭代器的失效问题 vector迭代器失效的几种情况
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/764b1fe29a1abe67cf6ea398cb1baa3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08cbdb57fc2c669a8dd5346128920b71/" rel="bookmark">
			Java常用的设计模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设计模式（Design pattern）是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式。设计模式免去我们自己再思考和摸索。就像是经典的棋谱，不同的棋局，我们用不同的棋谱。通过设计模式可以帮助我们增强代码的可重用性、可扩充性、 可维护性、灵活性好。我们使用设计模式最终的目的是实现代码的高内聚和低耦合
1. 单例模式 1.1 定义 所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。如果我们要让类在一个虚拟机中只能产生一个对象，我们首先必须将类的构造器的访问权限设置为private，这样，就不能用new操作符在类的外部产生类的对象了，但在类内部仍可以产生该类的对象。因为在类的外部开始还无法得到类的对象，只能调用该类的某个静态方法以返回类内部创建的对象，静态方法只能访问类中的静态成员变量，所以，指向类内部产生的该类对象的变量也必须定义成静态的。
1.2 代码：单例设计模式-饿汉式 class Singleton { // 1.私有化构造器 private Singleton() { } // 2.内部提供一个当前类的实例 // 4.此实例也必须静态化 private static Singleton single = new Singleton(); // 3.提供公共的静态的方法，返回当前类的对象 public static Singleton getInstance() { return single; } } 1.3 代码：单例设计模式-懒汉式 该版本的懒汉式暂时还存在线程安全问题，线程安全版本见下文
class Singleton { // 1.私有化构造器 private Singleton() { } // 2.内部提供一个当前类的实例 // 4.此实例也必须静态化 private static Singleton single; // 3.提供公共的静态的方法，返回当前类的对象 public static Singleton getInstance() { if(single == null) { single = new Singleton(); } return single; } } 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08cbdb57fc2c669a8dd5346128920b71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f0e4c0ffd45e46dc04cf273c4bee6a6/" rel="bookmark">
			MAC笔记本上搭建Vue环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.安装Node.js
打开终端（Terminal），在终端中输入以下命令安装Node.js：
brew install node 如果你没有安装Homebrew，你可以在终端中输入以下命令安装：
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)" 2.安装Vue CLI
在终端中输入以下命令安装Vue CLI：
npm install -g @vue/cli 3.创建Vue项目
在终端中输入以下命令创建Vue项目：
vue create my-project 其中my-project是你的项目名称，你可以自定义。
4.运行Vue项目
在终端中进入你的项目目录，然后输入以下命令运行项目：
cd my-project npm run serve 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44617e090d59b7c3164504479ddb22c3/" rel="bookmark">
			i18n配置国际化语言，如何在js中使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先引入 import i18n from '@/lang' { path: '', component: Layout, redirect: '/index', children: [ { path: 'index', component: () =&gt; import('@/views/index_v1'), name: 'Index', meta: { title: i18n.t('index.title'), icon: 'dashboard', affix: true,keepAlive: true } }, ] }, lang的Index文件
import Vue from 'vue' import VueI18n from 'vue-i18n' import elementEnLocale from 'element-ui/lib/locale/lang/en' // element-ui lang import elementZhLocale from 'element-ui/lib/locale/lang/zh-CN'// element-ui lang import elementJaLocale from 'element-ui/lib/locale/lang/ja' // 引入饿了么的日文包 import enLocale from './en' import zhLocale from '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44617e090d59b7c3164504479ddb22c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e696df369e3608da5d498244b3ca7eb0/" rel="bookmark">
			SQLAlchemy对象转字典，解决SQLAlchemy对象返回为空的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
一、在模型文件中为Base对象加上一个to_dict方法
二、使用
一、在模型文件中为Base对象加上一个to_dict方法 Base = declarative_base() def to_dict(self): return {c.name: getattr(self, c.name, None) for c in self.__table__.columns} Base.to_dict = to_dict 二、使用 # 返回对象 one = session.query().one() return one.to_dict() # 返回对象列表 all= session.query().all() return [i.to_dict() for i in all] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9b793d421b16edaaf921c7dc056587b/" rel="bookmark">
			Cadence Allegro 17.4学习记录开始20-PCB Editor 17.4软件PCB布线叠层和阻抗设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 Cadence Allegro 17.4学习记录开始20-PCB Editor 17.4软件PCB布线叠层和阻抗设计利用Allegro的叠层设计和阻抗设计总结 Cadence Allegro 17.4学习记录开始20-PCB Editor 17.4软件PCB布线叠层和阻抗设计 利用Allegro的叠层设计和阻抗设计 第一：点击命令
第二：进入叠层设计页面
第三：默认是2层板，需添加两层板，形成4层板
线宽和阻抗成反比关系。
这是没有绿油的情况下的，阻抗会偏大。
一般的公式是：
Z是没有绿油的阻抗，这个公式可以算出有绿油下的阻抗。
总结 一般情况下，阻抗的设计是有专门的工具。
会提前用工具设计好阻抗。
实际设计时，需要选用PP和core的组合，叠起来的厚度基本等于要求的成品板厚即可，具体在设计时不用太精细，板厂可能会根据自己的库存情况进行调整，一般只需要将叠层结构、成品板厚、阻抗要求告诉板厂即可。
叠层设计有如下几个要点：
1、PCB叠层方式推荐为Foil叠法（大家不了解的可以百度一下core叠法和Foil叠法）
2、尽可能减少PP片和CORE型号及种类在同一层叠中的使用(每层介质不超过3张PP叠层)
3、两层之间PP介质厚度不要超过21MIL(厚的PP介质加工困难，一般会增加一个芯板导致实际叠层数量的增加从而额外增加加工成本)
4、PCB外层(Top、Bottom层)一般选用0.5OZ厚度铜箔、内层一般选用1OZ厚度铜箔，说明：一般根据电流大小和走线粗细决定铜箔厚度，如电源板一般使用2-3OZ铜箔，普通信号板一般选择1OZ的铜箔，走线较细的情况还可能会使用1/3OZ铜箔以提高良品率; 同时避免在内层使用两面铜箔厚度不一致的芯板。 这里普及一下OZ的概念，OZ，PCB铜箔的厚度是以OZ为单位，1OZ意思是重量1OZ的铜均匀平铺在1平方英尺(FT2)的面积上所达到的厚度。 1OZ=35um=0.035mm。
5、PCB板布线层和平面层的分布，要求从PCB板层叠的中心线上下对称(包括层数，离中心线距离，布线层铜厚等参数)，说明：PCB叠法需采用对称设计，对称设计指绝缘层厚度、半固化片类别、铜箔厚度、图形分布类型(大铜箔层、线路层)尽量相对于PCB的中心线对称。
6、线宽及介质厚度设计需要留有充分余量，避免余量不足产生SI等设计问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/503e9c66064c3948e6156dbd8d73b4fb/" rel="bookmark">
			计算机毕设 SSM Vue的疫情防控物业管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 项目简介2 实现效果2.1 界面展示 3 设计方案3.1 概述3.2 开发环境3.3 系统结构设计 4 项目获取 1 项目简介 Hi，各位同学好呀，这里是M学姐！
今天向大家分享一个今年(2022)最新完成的毕业设计项目作品，【基于SSM的疫情防控物业管理系统】
学姐根据实现的难度和等级对项目进行评分(最低0分，满分5分)
难度系数：3分
工作量：5分
创新点：3分
界面美化：5分
界面美化的补充说明：使用vue的基本都能达到5分
本项目完成于2022年6月份，包含内容 : 源码
项目获取：
https://gitee.com/sinonfin/L-javaWebSha/tree/master
2 实现效果 视频地址：https://www.bilibili.com/video/BV1JY4y1J747
2.1 界面展示 系统注册界面 费用缴纳管理界面 业主管理界面 车牌号管理界面 3 设计方案 3.1 概述 此次设计主要采用MyEclipse加Tomcat后台服务器进行，将所有业务模块采用以浏览器交互的模式，选择MySQL作为系统的数据库，设计过程中页面主要使用Java技术完成。
系统采用的数据库是Mysql，使用SSM技术开发。在设计过程中，充分保证了系统代码的良好可读性、实用性、易扩展性、通用性、便于后期维护、操作方便以及页面简洁等特点。
3.2 开发环境 开发语言：Java框架：ssmJDK版本：JDK1.8服务器：tomcat7数据库：mysql 5.7（一定要5.7版本）数据库工具：Navicat11开发软件：eclipse/myeclipse/ideaMaven包：Maven3.3.9 3.3 系统结构设计 基本实现了疫情防控物业管理系统应有的主要功能模块，本系统有管理员、业主。管理员：首页、个人中心、业主管理、核酸检测报告管理、疫情上报管理、访客登记管理、费用缴纳管理、车位信息管理、车牌号更换管理、疫情数据管理、投诉反馈管理、小区论坛、系统管理。业主权限；首页、个人中心、核酸检测报告管理、疫情上报管理、访客登记管理、费用缴纳管理、车位信息管理、车牌号更换管理、投诉反馈管理等操作。
4 项目获取 本项目完成于2022年6月份，包含内容 : 源码
项目获取：
https://gitee.com/sinonfin/L-javaWebSha/tree/master
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3afaac7894912efb8bd66079f6e15172/" rel="bookmark">
			基于TCP协议的文件传输系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最简单的一对一的服务端网络端通信(socket)
Socket=（IP地址：端口号），例如：如果IP地址是210.37.145.1，而端口号是23，那么得到套接字就是(210.37.145.1:23)
socket可以理解成计算机提供给程序员的接口，数据在客户端和服务端之间的socket之间传输。socket把复杂的TCP/IP协议封装，对于程序员来说只要利用好函数，就可以实现数据通信。
TCP提供了stream和datagram两种通信机制，所以socket分这两种。
stream的类型是SOCK_STREAM,采用TCP协议，TCP协议在计算机网络中是安全可靠的有连接的协议。datagram的类型是SOCK_DGRAM,采用的是UDP协议，UDP是不可靠的协议，现在在实际应用开发中，主要采用的是TCP。
服务端主要流程：创建socket—bind绑定ip和port—listen监听客户端连接请求—accept接受连接----数据传输----close关闭连接
int listenfd; listenfd=socket(AF_INET,SOCK_STREAM,0);//在socket编程中，AF_INET是必须的，等同于固定搭配 //socket创建成功后如果返回值是-1的话，说明创建失败，为0的时候就是创建成功 if(listenfd==-1) { printf("socket create fail\n"); return -1; } struct sockaddr_in serveraddr;//定义一个用来处理网络通信的数据结构，sockaddr_in分别将端口和地址存储在两个结构体中 //sin_family协议族 memset(&amp;serveraddr,0,sizeof(serveraddr)); serveraddr.sin_family=AF_INET; serveraddr.sin_addr.s_addr = htonl(INADDR_ANY); //serveraddr.sin_addr.s_addr=atoi(argv[1]);// specify ip address serveraddr.sin_port=htons(atoi(argv[1]));//specify port //printf("%s %s\n",argv[1],argv[2]); if(bind(listenfd,(struct sockaddr *)&amp;serveraddr,sizeof(serveraddr))!=0) { printf("bind failed \n"); return -1; } INADDR_ANY 表示监听0.0.0.0地址，socket只绑定端口，不绑定本主机的某个特定ip，让路由表决定传到哪个ip（0.0.0.0地址表示所有地址、不确定地址、任意地址）（一台主机中如果有多个网卡就有多个ip地址）
htons()把short型值转成按网络字节顺序排列的short型值
htonl()把long型值转成按网络字节顺序排列的long型值
假设你已经有了一个sockaddr_in结构体ina，你有一个IP地址"132.241.5.10" 要储存在其中，你就要用到函数inet_addr(),将IP地址从 点数格式转换成无符号长整型。使用方法如下：
ina.sin_addr.s_addr = inet_addr(“132.241.5.10”);
if(listen(listenfd,5)!=0) { printf("Listen failed\n"); close(listenfd); return -1; } backlog 5 是未经过处理的连接请求队列可以容纳的最大数目。
int clintfd;//socket for client int socklen=sizeof(struct sockaddr_in); struct sockaddr_in client_addr; clintfd=accept(listenfd,(struct sockaddr*)&amp;client_addr,(socklen_t *)&amp;socklen); if(clintfd==-1) printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3afaac7894912efb8bd66079f6e15172/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ada679d39e40e0d2f10c90ae22784670/" rel="bookmark">
			Docker环境下Sonarqube安装与测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sonarqube是对代码的可靠性、安全性、可维护性、代码重复率、代码量大小进行检测和评判，生成质量报告，反馈给开发人员进行代码优化。
要实现Sonarqube安装需要依赖JDK的版本，目前jdk8支持的sonarqube版本最高是7.8，而从7.9版本开始都是要求jdk11了。
1、安装部署 sonarqube7.8+postgres13.4 拉取镜像
docker pull postgres:13.4 docker pull sonarqube:7.8-community 创建自定义网络，方便sonarqube与postgres建立数据库连接
docker network create sonar-postgres 创建挂载目录
mkdir -p /home/sonar/postgres/postgresql mkdir -p /home/sonar/postgres/data mkdir -p /data/sonarqube 修改系统参数
echo "vm.max_map_count=262144" &gt; /etc/sysctl.conf sysctl -p 创建postgres数据库容器
docker run --name postgres -d -p 5432:5432 --net sonar-postgres \ -v /home/sonar/postgres/postgresql:/var/lib/postgresql \ -v /home/sonar/postgres/data:/var/lib/postgresql/data \ -v /etc/localtime:/etc/localtime:ro \ -e POSTGRES_USER=sonar \ -e POSTGRES_PASSWORD=sonar \ -e POSTGRES_DB=sonar \ -e TZ=Asia/Shanghai \ --restart always \ --privileged=true \ --network-alias postgres \ postgres:13.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ada679d39e40e0d2f10c90ae22784670/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5649c624f6ca78a0da3a08824c3a3bc/" rel="bookmark">
			数据库第二章：数据库关系模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2.1 关系及其相关概念 一、实体、关系的概念
1、实体——是指包含有数据特征的事物对象在概念模型世界中的抽象名称。
2、 关系
在关系模型中，使用“关系”来存储“实体”中的数据。
关系——是指具有关系特征、用于存放实体数据的二维表。关系也常被称为关系表。
3、 关系特征
表中每行存储实体的一个实例数据表中每列包含实体的一项属性数据表中单元格只能存储单个值不允许有重复的行不允许有重复的列列顺序可任意行顺序可任意 二、关系的数学定义
定义: 关系是指在集合域 D1、…、Dn 上运算笛卡儿积的有意义子集，其数学描述为 R ⊆ D1 × … × Dn。
说明：关系R只是该笛卡儿积的有意义子集，即关系R的元组数&lt;=笛卡儿积的元组数。
三、关系的键定义
在关系中，可以用来唯一标识元组的属性列，称为键，其它属性列都为非键列。
1.复合键
是指关系中用来唯一标识元组的多列作为键。
2.候选键
关系中可能有多个列均适合作为键，将其中每个都称为候选键。
3.主键
关系表中最有代表性的一个候选键，每个关系表中只能定义一个主键。
主键作用：
唯一标识关系表的每行（元组）与关联表的外键建立联系，实现关系表之间连接数据库文件使用主键值来组织关系表的数据存储数据库使用主键索引快速检索数据
4.代理键
采用DBMS自动生成的数字序列作为关系表的主键。
代理键作用：
可替代复合主键，以便获得更高性能的数据访问操作处理。 四、关系模式语句表示
关系模式语句中主键表示方法：
关系名（主键属性，属性2，…，属性x）
在主键属性添加下划线来表明主键。
例：
2.2 关系模型原理 一、关系模型及其组成
是一种基于二维表结构存储数据实体及实体间联系的数据模型。
1、 数据结构
2.、数据操作
集合运算操作包括选择、投影、连接、交、并、差等。
专门针对元组的关系操作包括数据行插入、 修改、删除操作。
3. 数据关系约束
是指关系表中实体数据完整性、关联表之间数据一致性等要求，一般由业务需求来确定。
在关系模型中，可定义关系表的数据约束如下：
属性列取值类型
属性列取值范围
属性列取值是否唯一
属性列是否允许空值
关联表的参照完整性约束
二、关系模型数据操作
采用基于关系代数的数据操作，包括传统的集合运算操作和专门的关系运算操作。
1、关系“并运算∪”操作
关系并运算∪的结果集是由属于R或属于S的所有元组组成。
R∪S={t|t∈R∨t∈S}
关系并运算∪的前提：关系R与关系S需有相同属性(列)组成。
2、关系“差运算-”操作
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5649c624f6ca78a0da3a08824c3a3bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87e5d064b95e2a99fb6c9d1f66ff7fe1/" rel="bookmark">
			.NET WinForm桌面程序设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先上效果图:数据是写死模拟的。
背景：公司项目需求，需要每天或每小时20分定时推送消息给用户。
技术：基于微软强大的.net平台，引用第三方[Quartz 2.5.0.0]任务调度器（后面会专门写一个Quartz的安装使用教程），使用C#高级语法委托的方式实现消息的收集和发布。下面介绍开发步骤。
1.引入Quartz 2.5.0.0插件。 如图
2.创建窗体程序。
3.编码，包含写入注册表，开机自启，初始化调度器配合作业和时间触发器加入调度器。
using Microsoft.Win32; using Quartz; using Quartz.Impl; using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Windows.Forms; using static Quartz.PushAlarmService; namespace Quartz2 { public partial class Form1 : Form { IScheduler scheduler = null; public Form1() { InitializeComponent(); } private void Form1_Load(object sender, EventArgs e) { try { //this.DealMessage(string.Format("【消息提醒】{0}启动调度器", DateTime.Now.ToString()));//会报错 //绑定消息方法 MessageServcie.Instance.OnShowMessageDlg = new ShowMessageDlg(ShowMessageBox); //SetAutoRun("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87e5d064b95e2a99fb6c9d1f66ff7fe1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3628fa36770a18d4b592c26d8be850f5/" rel="bookmark">
			Acwing - 算法基础课 - 笔记（数据结构 · 二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 数据结构（二）Trie树并查集堆 数据结构（二） 本节讲解的内容是，Trie树（字典树），并查集，堆（Dijkstra算法可以使用堆进行优化）
Trie树 Trie树，又称字典树，是用来高效存储和查找字符串集合的一种数据结构
查找时，可以高效的查找某个字符串是否在Trie树中出现过，并且可以查找出现了多少次
其逻辑结构如下
假设我们需要维护一个字符串集合，它需要支持两种操作
向集合插入一个字符串x查询一个字符串在集合中出现了多少次 假设我们有一个字符串集合，包含如下的字符串
abcd，abc，aced，bbac，abde，bcac
将这些字符串依次进行插入，构建出来的Trie树逻辑结构如下
其中红色的节点表示，存在一个以该节点为结尾的字符串
练习题：Acwing - 835: Trie字符串统计
#include&lt;iostream&gt; #include&lt;string&gt; using namespace std; const int N = 1e5 + 10; int q[N][26]; int ctn[N]; // 用来计数 int idx; // 用来分配新的节点 // 注意这里, 使用数组来模拟指针的 // 下标为0的节点, 既是根节点，也用来表示空节点 // 如一个节点下标为1，则q[1][0]表示这个节点的a儿子，若q[1][0] = 0, 表示1这个节点没有a儿子(空节点)，若q[1][0] = x , x不为0, 则表明1这个节点有a儿子，且a儿子的节点下标为x // 更通俗地讲, q[i][j]，表示了一个节点i连接其儿子节点的边，而j属于0~25, 表示了26个小写字母，当q[i][j] = x，且x不为0时，表明i这个节点有一儿子节点为某个字母, 且这个儿子节点下标为x //ctn[i], 表示以节点i为结尾的字符串, 出现了多少次 void insert(string s) { int p = 0; for(int i = 0; i &lt; s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3628fa36770a18d4b592c26d8be850f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b70fcf9e30df73ed71ee5054295c93d/" rel="bookmark">
			【算法竞赛模板】质因子、质数、约数、余数、快速幂（数论大全）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常用数论的算法模板 一、质因子二、质数三、约数① 试除法求一个数所有约数② 求约数个数③ 求约数和④ 求最大公约数&lt;1&gt; gcd辗转相除&lt;2&gt; 扩展欧几里得&lt;3&gt; 反素数&lt;4&gt; 同余定理&lt;5&gt; 费马小定理(快速幂求逆元) 四、余数五、组合数① DP求组合数② 逆元求组合数③ 卢卡斯定理求组合数④ 高精度大数求组合数 六、快速幂 苟蒻发文，若有任何不足、错误的地方欢迎大佬们来斧正~本苟蒻不胜感激（＞人＜；） 一、质因子 定义： 指能整除给定正整数的质数
性质： 1没有质因子，每个正整数都能够以唯一的方式表示成它的质因数的乘积
举例： 360 = 2 × 2 × 2 × 3 × 3 × 5 = 23 × 32 × 5，表示成了质因数乘积
时间复杂度： O(logn)，最坏为O( n \sqrt{n} n ​)
算法思想： 从小到大枚举 n 的所有约数，假设枚举较小的那个 p，则 n 中最多只包含一个大于 n \sqrt{n} n ​ 的质因子，如果枚举结束，n 还大于1，那么说明这就是那个大于 n \sqrt{n} n ​ 的质因子，由性质的证明如下图。在筛质数的过程中，用的是欧式线性筛法
👉例题1： 点这里
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b70fcf9e30df73ed71ee5054295c93d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/916a098f8905b5d089f60ba70bb42f0d/" rel="bookmark">
			手把手带你读java源码之JAVA-stream数据结构和初始化源码详解(万字长文详解)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		手把手带你读java源码之JAVA-stream数据结构和初始化源码详解(万字长文详解) stream stream是java8新增的非常重要的一个特性。并且非常的常用。它实现了函数式编程。具体函数式编程的概念已经很久了，比如js中的箭头函数。java中也通过stream做出了支持。想深入理解的可以参考cmu的课程15-150或者stanford的CS 95SI。
它可以帮助我们方便的处理很多东西。处理分为两种，中间态和结果态。
下面是一些中间态操作。他们位于链式操作的中间，当调用他们的时候并没有真正执行。只有当调用结果态的方法的时候才会真正的执行操作，也就是所谓的延迟执行。
方法名说明map循环。可以简单理解为foreachflatMap将二维数据展开成一维filter过滤数据distinct去重sorted排序limit限制只取n个元素skip跳过n个元素 stream的初始化 看一个例子，假设我们有一个需求。输出大于5的所有数。
期望输入：2，5，7，1，3，2，8期望输出：7，8 //首先初始化输入列表 List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add("2"); list.add("5"); list.add("7"); list.add("1"); list.add("3"); list.add("2"); list.add("8"); //开始执行操作 List&lt;Integer&gt; list2 = list.stream().map(Integer::valueOf).filter(x -&gt; { return x &gt; 5; }).collect(Collectors.toList()); //输出 System.out.println(list2); 接下来看一下stream是如何执行的。下面是stream的一个类图。可以看到初始化需要使用到一个接口和6个类。主要分为三大类。
类介绍 第一类是ArrayList类和ArrayListSpliterator类。这两个类是核心类。毕竟我们输入类型是ArrayList，这个就不用说了。
主要在于ArrayListSpliterator这个类，这个类是ArrayList的一个内部类。最主要的操作方法和数据都在里面。看一下几个属性
list 我们要进行stream操作的listfence 大小expectedModCount 期望的处理数量index 最主要的循环处理方法同样在这个类里面。处理逻辑全部在forEachRemaining这个方法中。
第二大类是StreamSupport流的支持类，算是一个单独的类，提供了对stream的一些操作方法，比如初始化一个stream。
第三大类是AbstractPipeline抽象类为主的3个类，还有两个是继承自AbstractPipeline的ReferencePipeline类，主要负责处理引用类的流。和继承ReferencePipeline的Head类，实现了双向链表的头节点。他们的主要功能就是构造为流的双向链表数据结构。
执行流程介绍 这几个类的执行时序图如下。
可以清晰的看到，通过Collection类的stream方法调用到了ArrayList的方法然后调用到了ArrayListSpliterator的方法，来初始化了ArrayListSpliterator对象，并存储到流中。
接下来Collection类将初始化好的ArrayListSpliterator对象传递给了StreamSupport类用来初始化stream。
StreamSupport将会创建一个双向链表的头节点。并将ArrayListSpliterator对象放入头节点。初始化以后的流如下图所示：
流介绍 流分为两种，顺序流和并行流。
顺序流 顺序流顾名思义就是按照顺序执行。可以直接的类比为for循环。如下图，如果1，2，3三个元素，进入流以后，依然是1,2,3三个元素。
并行流 并行流是充分的利用现代多核计算机的性能而出的。它可以把流分散到各个进程/线程中去执行。来达到并行执行的效果。如下图，1，2，3三个元素，可能会进入2个流中。
源码分析 list的stream方法调用的是Collection类的stream方法。所以首先来看这个方法，该方法返回一个顺序流，顺序流中包含了list中的所有元素。
//该方法返回一个顺序流，顺序流中包含了list中的所有元素。 default Stream&lt;E&gt; stream() { //调用了StreamSupport.stream方法，传入了一个分割迭代器，第二个参数false代表是顺序流，true是平行流。 return StreamSupport.stream(spliterator(), false); } //生成一个分割迭代器，该方法是ArrayList类中的方法。 @Override public Spliterator&lt;E&gt; spliterator() { //返回一个ArrayListSpliterator类的实例。 //实例中包含4个属性 //list = list //index = 0 //fence = -1 //expectedModCount = 0 return new ArrayListSpliterator&lt;&gt;(this, 0, -1, 0); } 接下来来到StreamSupport类的stream方法。通过spliterator来创建一个顺序流。只有当结果态操作开始后，spliterator才会真正开始运行
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/916a098f8905b5d089f60ba70bb42f0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9170c5b6b6c6db570e4c9f8c0cdd2b1/" rel="bookmark">
			指标评估 —— AP &amp; mAP 详细解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 问题背景相关概念两个阈值非极大值抑制Precision x Recall CurveAverage Precision实例展示参考链接 问题背景 针对【目标检测】领域，解析【AP，mAP】的概念以及计算过程。
相关概念 在计算mAP之前，需先理解清楚其概念，以及相关特定术语的【准确】含义。每次遇到评估指标计算的时候，都会感觉很模糊，理解似是而非，其中关键的原因就是特定术语的理解不到位。
AP
AP：Average Precison，所有预测图片内某一类别PR曲线（横轴为Recall，纵轴为Precision）下的面积。
mAP
mAP：mean Average Precision， 各类别【AP】的平均值。
TP
True Positive（TP）：预测框与真实框的IOU&gt;IOU阈值，IOU阈值一般设置为0.5,0.75,0.95等。在目标检测的评估指标规定下，一个真实框（groud truth box）只有一个 TP框，其它均为FP框（即使IOU大于阈值）；
FP
False Positive（FP）：存在两种情况，（a）预测框与真实框的 i o u &lt; i o u t h r e s h iou&lt; iou_{thresh} iou&lt;iouthresh​；（b）多余的预测框（iou值并不是最大的），即使 i o u iou iou 大于阈值，但是真实框已经存在匹配的预测框；
FN
False Negative（FN）：没有匹配到预测框的 GT数量，也即是真实框没有任何预测框与之重叠，目标检测中也称为漏检；
TN
True Negative（TN）：没有负样本，图像应该至少包含一个目标；mAP 指标不需要该值；
注意：目标检测中，TN 表示将背景正确检测为背景，等价于没有检测任何目标，通常不需要该指标。
Precision
所有预测结果中，正确预测框所占的比例。
简言之，所有的预测结果中，存在两种情况：（a）正确的预测结果（TP）；（b）错误的预测结果（FP）；
P r e c i s i o n = T P / ( T P + F P ) = T P / A l l D e t e c t i o n s Precision = TP/(TP+FP)= TP/All Detections Precision=TP/(TP+FP)=TP/AllDetections
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9170c5b6b6c6db570e4c9f8c0cdd2b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe63f90695b5a0ecc58149b5fc548056/" rel="bookmark">
			TwinCAT 学习进阶之路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、TwinCAT 介绍 TwinCAT3 是基于 PC 的控制软件并且它开启了一个新的时代，是倍福公司历 史上又一个里程碑。 特别是在高效的工程领域中 TwinCAT3 将模块化思想以及其灵活的软件架构， 融入到整个平台。几乎每一种控制应用程序都能在 TwinCAT3 中实现。从印刷设备、木工设备、 塑料机械或门窗设备、风力发电机和实验台，亦或是楼宇，诸如剧院，以及运动 场，一切都可以通过 TwinCAT3 实现自动化。 用户可以选择不同的编程语言来实现这些应用。除了经典的 PLC 编程语言的 IEC 61131-3，用户现在也可以用高级语言 C 或 C++，以及 MATLAB®/ Simulink®。 整合了运动功能从而简化了工程项目，以及全新的安全应用编辑更加人性化。 这些以及更多的特性都证明了为什么 TwinCAT3 也名为扩展的自动化。 二、 TwinCAT3 安装 1. TwinCAT3 软件概述及安装 TwinCAT3 软件分 XAR 和 XAE 两种。 XAE ： eXtended Automation Engineering 。 XAR ： eXtended Automation Runtime 。 XAE 是工程界面，可以进行编程。 XAR 是 runtime ，可以运行和控制，没有工程界面，完整版（ Full ）本就是 XAE 。 此例程是基于 VS2012/VS2013shell 进行 TwinCAT3 进行安装。 TwinCAT3 完整版安装包自带 VS2010 Shell ，但 VS2010 Shell 没有集成 help view ，因此如果需要 查看 TC3 帮助文档是必须安装 SP1 的，这样就很麻烦，不过 VS2012 Shell 和 VS2013 Shell 就没有这个问题，因为集成了 help view ，这里我们就介绍如何安装 VS2013 Shell 并且成功安装 TwinCAT3 和 infosys 。 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe63f90695b5a0ecc58149b5fc548056/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60b0fce3c1d75941764318871bf03694/" rel="bookmark">
			CSS自定义鼠标样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSS自定义鼠标样式 属性值 属性描述url需使用的自定义光标的 URLdefault默认光标（通常是一个箭头）auto默认。浏览器设置的光标crosshair光标呈现为十字线pointer光标呈现为指示链接的指针（一只手）move此光标指示某对象可被移动e-resize此光标指示矩形框的边缘可被向右（东）移动ne-resize此光标指示矩形框的边缘可被向上及向右移动（北/东）nw-resize此光标指示矩形框的边缘可被向上及向左移动（北/西）n-resize此光标指示矩形框的边缘可被向上（北）移动se-resize此光标指示矩形框的边缘可被向下及向右移动（南/东）sw-resize此光标指示矩形框的边缘可被向下及向左移动（南/西）s-resize此光标指示矩形框的边缘可被向下移动（南）w-resize此光标指示矩形框的边缘可被向左移动（西）text此光标指示文本wait此光标指示程序正忙（通常是一只表或沙漏）help此光标指示可用的帮助（通常是一个问号或一个气球） 效果
效果查看，点击这里 ➡：链接
自定义样式
使用cursor: url(); css代码如下，就能得到一个切换了图片的鼠标样式：
html, body { width: 100%; height: 100%; } body { cursor: url("./draw.png") 0 32, auto; } 使用cursor: none; 全局设置cursor: none;，使屏幕上看不见鼠标的默认样式再手写一个div并给它赋予自定义样式，此时是用html+css来给其设置样式，不再有局限性监听 body 上的 mousemove，并实时设置div的位置给div设置pointer-events: none;阻止默认的鼠标事件，让事件透传，否则hover及click等事件不会生效 当然，这里还有一点缺陷，我们应该监听到鼠标移出body把div销毁，这里就不再赘述。
完整代码如下：
&lt;div id="container"&gt;&lt;/div&gt; * { margin: 0; padding: 0; } html, body { width: 100%; height: 100%; } body { cursor: none; position: relative; } #container { position: absolute; top: 0; left: 0; width: 12px; height: 12px; background-color: #000; border-radius: 50%; z-index: 1; // 阻止默认的鼠标事件，让事件透传 pointer-events: none; } const body = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60b0fce3c1d75941764318871bf03694/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/106/">«</a>
	<span class="pagination__item pagination__item--current">107/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/108/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>