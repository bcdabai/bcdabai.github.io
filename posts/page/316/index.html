<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37ed2ca78647d86f25dd0a39c1a3a150/" rel="bookmark">
			PHP超时处理全面总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【 概述 】
在PHP开发中工作里非常多使用到超时处理到超时的场合，我说几个场景：
1. 异步获取数据如果某个后端数据源获取不成功则跳过，不影响整个页面展现
2. 为了保证Web服务器不会因为当个页面处理性能差而导致无法访问其他页面，则会对某些页面操作设置
3. 对于某些上传或者不确定处理时间的场合，则需要对整个流程中所有超时设置为无限，否则任何一个环节设置不当，都会导致莫名执行中断
4. 多个后端模块(MySQL、Memcached、HTTP接口)，为了防止单个接口性能太差，导致整个前面获取数据太缓慢，影响页面打开速度，引起雪崩
5. 。。。很多需要超时的场合
这些地方都需要考虑超时的设定，但是PHP中的超时都是分门别类，各个处理方式和策略都不同，为了系统的描述，我总结了PHP中常用的超时处理的总结。
【Web服务器超时处理】
[ Apache ]
一般在性能很高的情况下，缺省所有超时配置都是30秒，但是在上传文件，或者网络速度很慢的情况下，那么可能触发超时操作。
目前 apache fastcgi php-fpm 模式 下有三个超时设置：
fastcgi 超时设置：
修改 httpd.conf 的fastcgi连接配置，类似如下：
FastCgiExternalServer /home/forum/apache/apache_php/cgi-bin/php-cgi -socket /home/forum/php5/etc/php-fpm.sock
ScriptAlias /fcgi-bin/ "/home/forum/apache/apache_php/cgi-bin/"
AddHandler php-fastcgi .php
Action php-fastcgi /fcgi-bin/php-cgi
AddType application/x-httpd-php .php
&lt;/ifmodule mod_fastcgi.c&gt; 缺省配置是 30s，如果需要定制自己的配置，需要修改配置，比如修改为100秒：(修改后重启 apache)：
&lt;/ifmodule mod_fastcgi.c&gt;
FastCgiExternalServer /home/forum/apache/apache_php/cgi-bin/php-cgi -socket /home/forum/php5/etc/php-fpm.sock -idle-timeout 100
ScriptAlias /fcgi-bin/ "/home/forum/apache/apache_php/cgi-bin/"
AddHandler php-fastcgi .php
Action php-fastcgi /fcgi-bin/php-cgi
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37ed2ca78647d86f25dd0a39c1a3a150/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c4f1e794f17902b800da6128caafd1a/" rel="bookmark">
			POJ 试题分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载请注明出处：優YoUhttp://blog.csdn.net/lyy289065406/article/details/6642573
另外我还有一个在Linode上的新Blog：http://nike0good.com 记录了一些游记什么的。。
改革V1.0
——刷题法则
恭祝Blog.cn开博2012.8.1
较初级:
OJ上的一些水题(可用来练手和增加自信) (poj1003,poj1004,poj1005,poj1207,poj3299,poj2159,poj2739,poj1083,poj2262,poj2255,poj3094,CF 253A)
线性筛素数(poj3006)
初级:
一.基本算法: (1)枚举. (poj1018,poj1753,poj2965)
(2)贪心(poj1328,poj2109,poj2586)
(3)递归和分治法. (4)递推. (5)构造法.(poj3295,poj3239)
(6)模拟法.(poj1008,poj1068,poj2632,poj1573,poj2993,poj2996,poj3087)
(7)高精度算法(poj1001,poj1503,poj2389,poj2602,poj3982,poj3289,poj2390)
(8)字符串处理(易位构字法)
(9)日期(评委会)
二.图算法: (1)图的深度优先遍历和广度优先遍历. (2)最短路径算法(dijkstra,bellman-ford,floyd,heap+dijkstra) (poj1860,poj3259,poj1062,poj2253,poj1125,poj2240,防御机制)
(3)最小生成树算法(prim,kruskal) (poj1789,poj2485,poj1258,poj3026)
(4)拓扑排序 (poj1094)
(5.1)二分图的最大匹配 (匈牙利算法) (poj3041,poj1325,poj3020,poj3692,bzoj2547)
(5.2)稳定婚姻系统(The Stable Marriage Problem,zoj1676)
(6)网络流算法(压入重标法，KM算法). (poj1459,poj3436,poj1273,poj1149,CF 237E)
三.数据结构. (1)串 (poj1016,poj1035,poj3080,poj1936)
(2.1Qsort)排序(快排) (poj2388)
(2.2)归并排序(与逆序数有关)、堆排(poj1007,poj1804,poj2299)
(2.3)桶排(数字卡片)
(3)并查集. (4)哈希表和二分查找等高效查找法(数的Hash,串的Hash) (poj1002,poj3349,poj3274,poj1840,poj2002,poj3432,poj2503)
(5)优先队列(poj3253)
(6)堆 (7)trie树-字典树(静态建树、动态建树) (高级打字机,poj2513,What Are You Talking About)
(8)队列(实验误差)
四.简单搜索 (1.1)深度优先搜索 (poj2488,poj3083,poj3009,poj1321)
(1.2)深搜模拟栈(祖孙询问)
(2)广度优先搜索(poj3278,poj1426,poj3126,poj3414,poj2251)
(3)简单搜索技巧和剪枝(poj1010,poj2362,poj1011,poj1416,poj2676,poj1129)
五.动态规划 (1)背包问题. (poj1837,poj1276,poj1014)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c4f1e794f17902b800da6128caafd1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b85b429091f6d64dafd60e87428325d8/" rel="bookmark">
			NSRange类详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NSRange的定义
typedef struct _NSRange
{
NSUInteger location;
NSUInteger length;
} NSRange;
NSRange是一个结构体，其中location是一个以0为开始的index，length是表示对象的长度。他们都是NSUInteger类型。 而NSUInteger类型的定义如下：
#if __LP64__ || TARGET_OS_EMBEDDED || TARGET_OS_IPHONE || TARGET_OS_WIN32 || NS_BUILD_32_LIKE_64
typedef unsigned long NSUInteger;
#else
typedef unsigned int NSUInteger;
#endif
例子：
下面这个例子，将输出IPA
NSString *homebrew = @"Imperial India Pale Ale (IPA)";
// Starting at position 25, get 3 characters
NSRange range = NSMakeRange (25, 3);
// This would also work:
// NSRange range = {25, 3};
NSLog (@"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b85b429091f6d64dafd60e87428325d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73429c3157f1aa9b41081009c5e2025e/" rel="bookmark">
			计算机网络中常用的速率换算关系(B/s  vs b/s)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在计算机网络、IDC机房中，其宽带速率的单位用bps(或b/s)表示；换算关系为：1Byte=8bit 1B=8b ---------- 1B/s=8b/s(或1Bps=8bps) 1KB=1024B ---------- 1KB/s=1024B/s 1MB=1024KB ---------- 1MB/s=1024KB/s 在实际上网应用中，下载软件时常常看到诸如下载速度显示为128KB（KB/s），103KB/s等等宽带速率大小字样，因为ISP提供的线路带宽使用的单位是比特，而一般下载软件显示的是字节（1字节＝8比特），所以要通过换算，才能得实际值。然而我们可以按照换算公式换算一下： 128KB/s=128×8(Kb/s)=1024Kb/s=1Mb/s即：128KB/s=1Mb/s 理论上：2M（即2Mb/s）宽带理论速率是：256KB/s（即2048Kb/s），实际速率大约为80--200kB/s；(其原因是受用户计算机性能、网络设备质量、资源使用情况、网络高峰期、网站服务能力、线路衰耗，信号衰减等多因素的影响而造成的)。4M（即4Mb/s）的宽带理论速率是：512KB/s，实际速率大约为200---440kB/s 上行速率是指用户电脑向网络发送信息时的数据传输速率，下行速率是指网络向用户电脑发送信息时的传输速率。比如用FTP上传文件到网上去，影响上传速度的就是“上行速率”；而从网上下载文件，影响下载速度的就是“下行速率”。当然，在实际上传下载过程中，线路、设备(含计算机及其他设备)等的质量也会对速度造成或多或少的影响。宽带网速计算方法. 基础知识： 在计算机科学中，bit是表示信息的最小单位，叫做二进制位；一般用0和1表示。Byte叫做字节，由8个位（8bit）组成一个字节(1Byte)，用于表示计算机中的一个字符。bit与Byte之间可以进行换算，其换算关系为：1Byte=8bit（或简写为：1B=8b）；在实际应用中一般用简称，即1bit简写为1b(注意是小写英文字母b)，1Byte简写为1B（注意是大写英文字母B）。 在计算机网络或者是网络运营商中，一般，宽带速率的单位用bps(或b/s)表示；bps表示比特每秒即表示每秒钟传输多少位信息，是bit per second的缩写。在实际所说的1M带宽的意思是1Mbps（是兆比特每秒Mbps不是兆字节每秒MBps）。 建议用户记住以下换算公式： 1B=8b 1B/s=8b/s(或1Bps=8bps) 1KB=1024B 1KB/s=1024B/s 1MB=1024KB 1MB/s=1024KB/s 后面的以此类推 规范提示：实际书写规范中B应表示Byte(字节)，b应表示bit(比特)，但在平时的实际书写中有的把bit和Byte都混写为b ，如把Mb/s和MB/s都混写为Mb/s，导致人们在实际计算中因单位的混淆而出错。切记注意！！！ 实例： 在我们实际上网应用中，下载软件时常常看到诸如下载速度显示为128KBps（KB/s），103KB/s等等宽带速率大小字样，因为ISP提供的线路带宽使用的单位是比特，而一般下载软件显示的是字节（1字节＝8比特），所以要通过换算，才能得实际值。然而我们可以按照换算公式换算一下：
128KB/s=128×8(Kb/s)=1024Kb/s=1Mb/s即128KB/s=1Mb/s。
这个特别注意！
案例1： 某用户反映，为什么我的网速和我办的带宽不一样？ 我办的是4M 的宽带,可为什么我测试却只有2百多K的网速啊? 是不是电信骗了我？没有给我开4M哟 ? 案例分析：尊敬的用户，这只是误会。这可能有几个你不理解的原因：第一，实际网速单位是Mb/s，不是MB/s，而你所说的2百多K，其实际是指2百多KB/s（即2百多千字节每秒）不是2百多Kb/s（即2百多千比特每秒），通常情况下都是说简称如250KB/s或250Kb/s说成250K。第二，宽带4Mb/s=512KB/s并且这只是技术上的最大理论值，而不是所达到的实际值，一般正常情况下技术上的最大理论值为4Mb/s的宽带实际值可以达200KB/s至440KB/s。因为宽带速率要受到很多因素（比如用户计算机性能、资源使用情况、网络高峰期、网站服务能力、信号衰耗、线路衰耗、距离远近等）的影响，所以导至实际值与技术上的最大理论值有偏差。第三，网络运营商提供的宽带速率单位中，"bps"是指"bit per second"。而实际速度所指的bps是指"Byte per second"。所以要经过换算，而1Byte=8bit，在计算网速的上行速度或下行速度，都必须将数值除以8即把bit转化为Byte。例如：下行速度（即下载速度）为1Mb/s，其换算成等价值就是128KBps ；换算方法:1Mbps=1024/8（KBps）=128KBps即128KByte/s 。 案例2： 某用户反映， 我办的是4M 的宽带, 为什么我的网速比通常情况下都慢哟，而且还经常掉线？是不是电信骗了我？没有给我开4M哟 ? 案例分析：尊敬的用户，这只是误会。导致网速慢和经常掉线，通常情况下有几种可能的原因：第一、计算机感染病毒较严重；第二：计算机软硬件配置及性能；第三、上网终端质量、网线质量、线路传输负载；第四、线路接触是否良好、电源电压是否稳定等问题；第五、外界信号干扰、信号衰减、线路衰耗及线路距离长短；第六、私自或不规范组网；第七，网卡质量不好或没有插好；第八、安装了多种杀毒软件及防火墙或同时运行过多的程序；第九、通信协议设置和防火墙的配置等等原因；对于本案例中，该用户的情况经查明，该用户网速慢和掉线的原因是：第一、该用户的电脑感染了多种病毒，导致内存被占用，CPU使用率较高，经常达100%；影响了电脑性能，导致网速慢；第二、该用户办理的是ADSL拨号上网，因不规范的私自组网，导致线路传输负载加重，影响线路传输流量，造成网速慢并且经常掉线。第三、网线RJ45与HUB的接头接触不良好和电源电压不稳. 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c07aa4c7893a1f4f2733d8682b6dfd5/" rel="bookmark">
			.net使用精灵com
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工具箱中-选择项，com组件中选择microsoft agent control 2.0组件 将microsoft agent control控件添加到窗体上（在程序运行时是看不到窗体是的microsoft agent控件的，只有在设计界面时它才显示出来）
增加using AgentObjects;添加全局private IAgentCtlCharacterEx Character;//这个就是我们要操作的对象咯不想多说，把自己的所有测试代码贴出来（win7已经不支持了要下载补丁）其他可以看http://blog.csdn.net/luyifeiniu/article/details/5646744挺好 using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Text;
using System.Windows.Forms;
using AgentObjects;
namespace win1
{
public partial class Form1 : Form
{
private IAgentCtlCharacterEx Character;
public Form1()
{
InitializeComponent();
start();
}
private void start()
{
axAgent1.Characters.Load("Genie", (object)"merlin.ACS");//导入吉尼这个精灵 Character = axAgent1.Characters["Genie"];
Character.LanguageID = 0x409;//把语言设置为英语，这里不能是中文 // Character.LanguageID = 0x804;//把语言设置为英语，这里不能是中文 Character.Show(0);//显示精灵 Character.Speak("like", null);
Character.Play("Wave");
Character.Commands.Add("谢谢", "谢谢", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c07aa4c7893a1f4f2733d8682b6dfd5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d5dc6b3bedcaad2b26ed213d3678f4a/" rel="bookmark">
			linux更改文件权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们已经知道文件权限对于系统的安全重要性了，也知道文件权限与用户与用户组的关系了，那么，如何修改文件的权限呢？我们可以修改多少文件权限呢？其实，一个文件的权限很多。我们先介绍几个简单的，例如：用户组、拥有者、各种身份的权限等等。 ? chgrp：改变文件所属用户组 。 ? chown：改变文件拥有者。 ? chmod：改变文件的属性、SUID等特性。 更改所属用户组, chgrp 改变文件的用户组很简单，直接用chgrp即可，这个命令就是change group（改变用户组）的缩写。这样就很好记了。不过，请记住，要改变成为的用户组名称，必须在 /etc/group里存在，否则就会显示错误。 假设以root的身份登入FC4，那么，在你的家目录内有一个install.log文件，如何改变该文件的用户组呢？假设你已经知道在 /etc/group里已经存在一个名为users的用户组，但是，testing这个用户组名字就不存在 /etc/group中了，此时改变用户组成为users与testing，会有什么现象发生呢？ [root@linux ~]# chgrp [-R] dirname/filename ... 参数： -R : 进行递归( recursive )的持续更改，即连同子目录下的所有文件、目录 都更新成为这个用户组。常常用在更改某一目录的情况。 范例： [root@linux ~]# chgrp users install.log [root@linux ~]# ls -l -rw-r--r-- 1 root users 68495 Jun 25 08:53 install.log [root@linux ~]# chgrp testing install.log chgrp: invalid group name `testing' &lt;== 出现错误信息～找不到这个用户组名～ 发现了吗？文件的用户组被改成users了，但要改成testing的时候，就会发生错误。注意，出现错误信息，还是要查查错误信息的内容才好。 更改文件拥有者, chown 那 么，如何改变一个文件的拥有者呢？很简单。既然改变用户组是change group，那么改变拥有者就是change owner（改变拥有者）。这就是chown这个命令的用途，要注意的是，用户必须是已经存在系统中的，也就是在 /etc/passwd这个文件中有记录的用户名称才可改变。 chown的用途很多，还可以顺便直接修改用户组的名称。此外，如果要连目录下的所有子目录或文件同时更改文件拥有者的话，直接加上 -R的参数即可。我们来看看语法与范例： [root@linux ~]# chown [-R] 账号名称 文件或目录 [root@linux ~]# chown [-R] 账号名称:用户组名称 文件或目录 参数： -R : 进行递归( recursive )的持续更改，即连同子目录下的所有文件、目录 都更新成为这个用户组。常常用在更改某一目录的情况。 范例： [root@linux ~]# chown bin install.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d5dc6b3bedcaad2b26ed213d3678f4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e50d62f713134c1971ed4fd909f726d/" rel="bookmark">
			c#winform使用WebBrowser 大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C# WinForm WebBrowser (一) MSDN资料 1、主要用途：使用户可以在窗体中导航网页。
2、注意：WebBrowser 控件会占用大量资源。使用完该控件后一定要调用 Dispose 方法，以便确保及时释放所有资源。必须在附加事件的同一线程上调用 Dispose 方法，该线程应始终是消息或用户界面 (UI) 线程。
3、WebBrowser 使用下面的成员可以将控件导航到特定 URL、在导航历史记录列表中向后和向前移动，还可以加载当前用户的主页和搜索页：
1.URL属性：可读、可写，用于获取或设置当前文档的 URL。　WebBrowser 控件维护浏览会话期间访问的所有网页的历史记录列表。设置Url属性时，WebBrowser 控件导航到指定的 URL 并将该 URL 添加到历史记录列表的末尾。
WebBrowser 控件在本地硬盘的缓存中存储最近访问过的站点的网页。每个页面都可以指定一个到期日期，指示页面在缓存中保留的时间。当控件定位到某页时，如果该页具有缓存的版本，则直接显示缓存中的内容而不必重新下载该页，从而节省了时间。使用 Refresh 方法强制 WebBrowser控件通过下载来重新加载当前页，从而确保控件显示最新版本。
注意：即使已请求了另一个文档，该属性也包含当前文档的 URL。如果设置该属性的值，然后立即再次检索该值，要是 WebBrowser 控件尚未来得及加载新文档，则检索到的值可能与设置的值不同。
2.Navigate方法: 将指定位置的文档加载到 WebBrowser 控件中。
3.GoBack方法：如果导航历史记录中的上一页可用，则将 WebBrowser 控件导航到该页。
如果导航成功，则返回true；如果导航历史记录中的上一页不可用，则返回false。
WebBrowser 控件维护浏览会话期间访问的所有网页的历史记录列表。可以使用GoForward方法实现一个“后退”按钮。
使用 CanGoBack 属性确定导航历史记录是否可用以及是否包含上一页。处理 CanGoBackChanged 事件，在 CanGoBack 属性值更改时接收通知。
4.GoForward方法：如果导航历史记录中的下一页可用，则将 WebBrowser 控件导航到该页。
如果导航成功，则返回true；如果导航历史记录中的下一页不可用，则返回false。
WebBrowser 控件维护浏览会话期间访问的所有网页的历史记录列表。可以使用 GoForward 方法实现一个“前进”按钮.
使用 CanGoForward 属性确定导航历史记录是否可用以及是否包含当前页之后的页。处理 CanGoForwardChanged 事件，在 CanGoForward 属性值更改时接收通知 5.GoHome方法：将 WebBrowser 控件导航到当前用户的主页。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e50d62f713134c1971ed4fd909f726d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b70a449898ed06bdc85d9ca443c7d53/" rel="bookmark">
			不是iPhone5的话，还是别玩营销花招吧：华为D1四核将开卖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		华为智能手机去年开始发力，先后推出荣耀、P1、D1，性能一代代强，关注度一个个高，而今市场上担当主角的是D1双核。
但从目前的市场反馈看，D1双核似乎并没有引起特别轰动的效应，并非D1双核的配置不高，只是在这个四核引领潮流的时代，也不能期望D1双核对市场造成很大的扰动，毕竟前面已经有魅族四核、三星S3、HTC One X等等旗舰级别在商海弄潮了，D1双核还不具备这样的实力与上述四核旗舰抗衡，华为应该很清楚这一点，所以D1双核应该只是铺垫、过渡。早有消息称华为新的四核手机会在7月上市，但我们没有等到，最近有消息说它会搭载Android4.1于下月开卖，之所以迟到是因为它还处在研发状态。事实真相无从得知，但艾思看来，这更像一种营销手段。
毋庸置疑，在营销推广方面，做手机的没人能跟苹果比，每一代iPhone都能吊足消费者的胃口。其他厂商自然没有苹果那样的魅力，但也总想着玩玩饥饿营销。
饥饿营销不是不能玩，但要先掂量一下自己的实力，苹果可以吊1年，其他人想要吊多久，又能吊多久呢？
艾思不怀疑华为的实力，所以也在期待D1四核的面市，只是希望D1四核的迟到真的是由于技术上的精益求精，而不要搞成一次失败的营销，毕竟这不是在等iPhone5，毕竟已经有S3、One X们了.
资讯版权声明：
凡本网注明“来源：iSmart-艾思”的所有作品，版权均属于iSmart，转载请注明“来源：iSmart-艾思”。违反上述声明者，本网将追究其相关法律责任。 本网转载自其它媒体的信息，转载目的在于传递更多信息，并不代表本网赞同其观点和对其真实性负责。
转载于:https://www.cnblogs.com/ajuanabc/archive/2012/07/29/2614415.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2b6a40270ad20b7314a154c2981ad3f/" rel="bookmark">
			修改sql server 数据库字段报错:将截断字符串或二进制数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接在SQL Server 2005的Microsoft SQL Server Management Studio 中修改一张表中某个字段, 不管是删除字符还是添加都提示下面的错误.
---------------------------
Microsoft SQL Server Management Studio
---------------------------
未更新任何行。
未提交行 1 中的数据。
错误源: .Net SqlClient Data Provider。
错误信息: 将截断字符串或二进制数据。
语句已终止。
请更正错误并重试，或按 Esc 取消更改。
网上搜了下,基本都是讲字符串长度不够. 我这个很明显不是这个问题,数据库使用很长时间了,是昨天恢复数据时空然出现该错误; 同一张表的其他记录个性又没问题. 没办法了,只好把修改这张表的字段长度,全部扩大一倍,问题依旧, 出错的字段类型是 ntext , 应该够大了. 解决办法: 把该ntext字段个性为nvarchar(max)后,就能修改字段的内容了,把出错的字段内容清空. 保存后,再把字段类型恢复为ntext.,内容重新从后台添加,问题解决.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22d703df354c893b422fd30e2e7cadd9/" rel="bookmark">
			C#通过Http发送Soap请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/// &lt;summary&gt;
/// 发送SOAP请求，并返回响应xml /// &lt;/summary&gt; /// &lt;param name="url"&gt;请求地址&lt;/param&gt; /// &lt;param name="datastr"&gt;SOAP请求信息&lt;/param&gt; /// &lt;returns&gt;返回响应信息&lt;/returns&gt; public static string GetSOAPReSource(string url, string datastr) { //发起请求 Uri uri = new Uri(url); WebRequest webRequest = WebRequest.Create(uri); webRequest.ContentType = "text/xml; charset=utf-8"; webRequest.Method = "POST"; using (Stream requestStream = webRequest.GetRequestStream()) { byte[] paramBytes = Encoding.UTF8.GetBytes(datastr.ToString()); requestStream.Write(paramBytes, 0, paramBytes.Length); } //响应 WebResponse webResponse = webRequest.GetResponse(); using (StreamReader myStreamReader = new StreamReader(webResponse.GetResponseStream(), Encoding.UTF8)) { string result = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22d703df354c893b422fd30e2e7cadd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ba499660fe6e1e0ee16c5fd6bcff4ac/" rel="bookmark">
			错误—系统—Kernel-Power—41—（63）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		事件级别：错误
日志内容：
---------------------------
系统在未首先正常关机的情况下重新启动。当系统停止响应、出现故障或意外断电时，会发生此错误。
--------------------------------
相关解释：
---------------
该错误旨在提示管理员，该主机在本次开机之前的关机，是非正常的。
---------------
相关处理方式：
------------------------
需要确认非正常关机的原因。
-------------------------
转载于:https://blog.51cto.com/dennisxinyu/944296
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96b972a836e59cffbcb8849a5dae0b4e/" rel="bookmark">
			Desktop Computer操作系统之GUI发展
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想总结一下台式机操作系统的GUI发展
但是在网上看到了，就转载，不用自己去总结了
Source: Wikipedia
TIME 1981-2009
操作系统的图形界面。
下面，让我们先来看看PC机上的第一个图形界面——Xerox Alto(该系统并未商用，主要用于研究和大学)，其于1973年被施乐公司Xerox Palo Alto Research Center (PARC)所 设计，从此，开启了计算机图形界面的新纪元，80年代以来，操作系统的界面设计经历了众多变迁，OS/2, Macintosh, Windows, Linux, Symbian OS ，各种操作系统将 GUI 设计带进新的时代。
Source: toastytech.com
1981-1985 Xerox 8010 Star (released in 1981) 这是第一个完整地集成了桌面和应用程序以及图形界面的操作系统，人们一开始叫它“Xerox Star”，然后又叫“ViewPoint”，再以后又叫作“GlobalView”。
Xerox 8010 Star, Source: toastytech.com
Apple Lisa Office System 1 (released in 1983) 这个操作系统也叫Lisa OS，这里的OS是Office System的缩写。它由Apple公司开发主要目的用于文档处理工作站。不幸的是，这款机器的寿命并不长，最终这个工作站被更便宜的Apple的 Macintosh操作系统所取代。Lisa OS 几个升级包括 1983年的 Lisa OS2, 1984年的 Lisa OS 7/7 3.1。下面是其操作系统截图。
Apple Lisa OS 1, Source: GUIdebook
VisiCorp Visi On (released in 1984) 下面是IBM PC上的第一个图形界面的操作系统，叫Visi，其主要是给大公司用的，当然其价格也是非常高昂的。这个图形界面使用了鼠标，内置的安装程序以及帮助文档，但没有使用icon。下面是截图。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96b972a836e59cffbcb8849a5dae0b4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e51cbcbde6e1e4373569a762e8a819d/" rel="bookmark">
			apache与tomcat连接配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装apache wget http://mirror.bit.edu.cn/apache//httpd/httpd-2.2.22.tar.gz tar xzf httpd-2.2.22.tar.gz cd httpd-2.2.22 ./configure --prefix=/usr/local/apache make &amp;&amp; make install 安装jk_mod模块 wget http://www.apache.org/dist/tomcat/tomcat-connectors/jk/tomcat-connectors-1.2.33-src.tar.gz tar xzf tomcat-connectors-1.2.33-src.tar.gz cd tomcat-connectors-1.2.33-src/native ./configure --with-apxs=/usr/local/apache/bin/apxs make &amp;&amp; make install apache与tomcat连接配置 配置与tomcat连接主要有三个文件:
httpd.conf,workers.properties,uriworkermap.properties
1、httpd.conf
# 加载 mod_jk 模块 LoadModule jk_module modules/mod_jk.so # # 配置mod_jk模块 # &lt;IfModule jk_module&gt; JkWorkersFile conf/workers.properties JkMountFile conf/uriworkermap.properties JkLogFile logs/mod_jk.log JkLogLevel warn &lt;/IfModule&gt; 2、workers.properties
#定义两个可用的worker wlb和jkstatus worker.list=wlb,jkstatus #定义一个物理为ajp13w，类型ajp13(可以定义多个用作负载均衡) worker.ajp13w.type=ajp13 worker.ajp13w.host=localhost worker.ajp13w.port=8009 #定义一个逻辑worker wlb，类型为lb，用来管理物理worker ajp13w worker.wlb.type=lb worker.wlb.balance_workers=ajp13w #定义一个类型为status的worker jkstatus,用来监控 JK 本身 worker.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e51cbcbde6e1e4373569a762e8a819d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/367d303f7127051d3f505391d147a2bb/" rel="bookmark">
			android 移动开发设计原则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		四、移动互联网产品设计的原则 1、 绝不考虑Web形态，一切考虑都基于APP。 2、 产品优先级： （1）有趣高于功能，产品必须有趣，必须Cool，才可能形成传播和口碑。 （2）功能高于交互，明确的功能满足明确的需求，用户不会在意炫酷交互效果。 （3）交互高于UI。便捷、快速的交互设计为先，围绕具体功能实现UI，而非有优质UI方案为此专门设立一个功能。 3、 聚焦：一个APP只做一件事情，一个大而全的APP意味着全面的平庸。 4、 永远一维化：让用户在一个维度里解决具体的问题，Twitter的Timeline就是一个好的范例。而类似Facebook、Path那样的滑出式菜单则是一个灾难，因为这使得产品拥有两个维度，加大了用户理解的困难。 5、 保持主干清晰，枝干适度。产品的主要功能架构是产品的骨骼，它应该尽量保持简单、明了，不可以轻易变更，让用户无所适从。次要功能丰富主干，不可以喧宾夺主，尽量隐藏起来，而不要放在一级页面。 6、 不要让用户选择。同一个页面之内，有多个入口；同一个功能，有多个实现方式；同一个界面，有多个展示方式。这对于用户来说是一种痛苦而非享受，因为他们只会因此而感觉到困惑和恐惧。用户宁可采取重复操作漫长而固定的操作路径，也不愿意使用多变的快捷方式。 7、 隐藏技术，永远展现简单的、人性化的、符合人类直觉的界面。开发不可以为了炫技而展示功能，产品不可以为了炫耀而功能堆砌。 8、 拒绝个性化。除了依靠设计特色而立身的APP，换肤一类的个性化设计，除了让产品经理幻觉自己做了许多工作而自我满足之外，没有任何价值。它只能证明产品经理对自己的产品不自信，因为自信的产品经理凭借默认皮肤就可以满足用户。延伸开去，一个好的产品，其功能应该满足全球用户需求，无需为地区做特别定制化。 9、 产品一定程度上是为了满足人性中的贪嗔痴，这是用户的痛点。能把握住之后，产品经理应该超越其上，用产品帮助人们得以解脱。 10、想清楚自己究竟要做什么，不去迎合上司，不去讨好用户，不去取悦自己。 11、 分类！分类！分类！这是产品经理在确定产品主要功能构架之后，唯一应该为用户做的事情。分类无助于降低产品使用的难度，但是可以帮助用户认知产品和周边的世界。 12、永远围绕功能而做设计，永远不要倒过来做这件事情。 13、 一个产品的基本功能不受用户认可，做加法也无济于事。 14、 想不清楚一个功能点之前，宁可不做。 15、千万不要让用户在产品里“管理”什么。
2012年7月24日下午14：20---23：30，我应邀参加了《腾讯大讲堂》的特别讲座，由微信之父张小龙主讲《微信背后的产品观》。张小龙的讲演长达8小时20分，是我此生参加过的最漫长讲座。腾讯为此开设17个分会场，同步直播讲座，参加者超过1700人。晚上19：10分听众晚餐，20：30继续进行。恢复演讲时在线直播用户依然有600余人，加上分会场听众，总计有超过800人听完全程讲演。很多人并不知道，这可能是张小龙第一次也是最后一次做公开讲演，在公众面前讨论产品。在这次演讲中，他把自己15年来关于产品的所有经验和心得一次性全部公开，今后将不再做类似公开课。
这一讲座受到腾讯保密协定约束，因此其中令人惊叹的新产品特性演示不可以对外公开。同时，腾讯大讲堂举办的这一公开课的目标群体是腾讯两万余员工中的产品经理，其中涉及大量腾讯公司业务也不宜对外公开。因此，作为唯一的受邀外界自媒体，我只能根据授权部分内容进行阐述。因此，腾讯相关人士请先阅读下一段落的内容：
作为腾讯前员工，我清楚地知道这一课程的全部视频和PPT资料都储存于腾讯KM平台，请务必在阅读本文前完整浏览一次8小时20分的视频资料。张小龙关于移动互联网产品的全部思考和分析，都在这8小时20分的视频之内。其中，所有内容都来自张小龙业余时间用手机记录下来的产品心法300余条。经过精炼和分类之后，形成了长达180余页的PPT文档。这是最原始，也是最真实的素材，完整记录了一个产品经理的个人思考和感悟。因此，可以很容易地发现前后文逻辑背反抵触之处，很容易地看到一个真实的人内心深处的挣扎和纠结。它很清晰地给予以下启示：
1、 一个亿级用户的产品经理，无需做到透彻思考人性和产品的所有方面，得出定性结论，但依然可以做出成功的产品。
2、 一个成功的产品经理，需要在极端现实主义和极端理想主义之间取得平衡，把它们作为整体一并接受下来，彻底去除其中的相对性，丝毫不会觉得其中的矛盾和冲突之处。
因此，我的体系化阐释和原文相比，完全落到了下乘。阐释只是为了便于受众接受和理解，但是永远无法和原文素材相提并论。因为实际操作的产品经理在实践中，并未受到任何体系化阐释的指导和影响。相反的，这种阐释很可能成为个人理解的障碍。以下内容和张小龙的PPT内容并非一一对应，完全基于我个人对张小龙的认知和理解衍生而成。请在完整浏览视频资料之后，再行继续阅读本文：
一、微信的演化
2010年11月19日23时58分，张小龙在腾讯微博上写下了这么一句话：
我对iPhone5的唯一期待是，像iPad （3G）一样，不支持电话功能。这样，我少了电话费，但你可以用kik跟我短信，用google voice跟我通话，用facetime跟我视频。
（http://t.qq.com/p/t/2509031165724）
第二天，2010年11月20日，腾讯微信正式立项。一年零8个月之后的2012年7月，随着微信4.2版本的发布，可以看到那一晚张小龙关于iPhone5的所有狂想都在微信上得以实现。而就在此时此刻，张小龙都未必意识到一个简单的念头会在一年多之后如此深切地影响到一亿多用户；意识到一个普通用户此时此刻，仅凭一台iTouch和网络就可以完全改变以往有电话相随的生活。 产品经理之美就体现在这里。
微信1.0版的诞生是完全出自纯粹功利主义和现实主义的考虑，立项后2个月，微信1.0版的释出很大程度上是受到了KiK的启示---在新的移动互联网平台上，必将出现相应的移动通讯工具。KiK是一种免费短信，它很可能成为QQ在移动互联网时代的强大竞争对手。因此，从战略角度分析，腾讯必须开发一款移动通讯工具，这就是微信诞生的缘起。
尽管开发速度惊人，从立项到产品上线仅仅经过了2个月。但是微信1.0的免费模式在中国并不受欢迎。和欧美不同，中国运营商提供了丰富的套餐服务，正常用户每个月的包月短信根本消费不完。以省短信费为卖点的类KiK产品，在中国完全没有出路。 微信1.2版迅速转向了图片分享。从理性的角度分析，移动互联网时代必然是一个图片为王的时代。人们在有限的载体上没有耐心进行深度阅读，对图片的消费量会达到一个空前的程度。于是，微信1.2的主体功能变成了图片分享。然而市场对此反应冷淡，数据冷酷地证明了用户对手机图片分享没有兴趣，根本无法构成一种基本需求。
微信2.0的推出是微信团队在极短时间内的第三次试错。免费短信在利益上毫无吸引力，图片分享市场并不认可，产生内容的门槛远比预计要高。从用户在手机上输入内容的便利性出发，微信2.0将产品重心完全投入了语音通讯工具。作为一种重要指标，新浪微博每分钟出现一条关于微信的搜索结果，确立了微信2.0快速流行和传播的基调。
微信3.0是教科书式的经典产品开发节奏教程。当时，微信的竞争对手米聊拥有先发优势。米聊的产品经理甚至预判微信3.0的新功能是抄袭米聊的涂鸦功能。但是，微信此时已经初步明确了产品方向，没有做涂鸦功能，而是依托用户基础，提供了“查看附近的人”和“视频”功能。“查看附近的人”成为微信的爆发点，从此微信开始使用QQ邮箱和腾讯自身资源，进行强推广，用户突破2000万人大关，产品日新增用户以数十万量级增长，确立对竞争对手的绝对优势。
当用户超过一亿之后，微信4.0推出“朋友圈”，建立手机上的熟人社交圈，开放API接口打造移动社交平台。微信4.2推出视频通话功能，彻底封闭手机通讯工具上的任何其它可能。从此，微信确立了移动互联网时代生活方式的产品地位。未来一系列新功能的演进，都将围绕这一核心价值进行。任何试图以节省电话费、短信费作为竞争卖点的产品，此时已经完全失去了竞争的可能。因为微信提供的已经不再是单纯的通讯服务，而是移动互联网时代的生活方式。除非竞品能够提供一种更为便利和流行的模式，否则无法构成竞争关系。
二、移动互联网产品的方法论
手机作为一种联系工具，天然决定了移动互联网的主要服务对象是人群而非个人。移动互联网产品经理的主要任务是服务人群，主要工作是研究人类群落的行为模式。用产品为人群提供服务，并且要预判人群卷入之后行为模式的变化。
从方法论的角度思考，人类群落也处于演进过程中。早期人类是村落人群模式，村落中的每个人认识每个人，人际关系以非常实际的亲戚关系和职业关系为纽带。现代人类是社会化人群模式，人群数目极大增长，人际关系依托于抽象的社会生产关系：契约、合同、雇佣关系。。。。。。产品经理曾经是村落里的铁匠，他认识每个村民，每个村民也认识他。而在今天，产品经理完全退居幕后，他不可能认识每一个用户，用户甚至不知道这个人的存在。
因此，产品经理在方法论上存在着各种选择：他可以提供某种基于熟人群落的旧式服务，以增进熟人群落的情感为产品目的；他也可以提供某种基于大数人群的新式基础服务，以便于人们彼此认识，协调工作，从自利为基础的无序活动中自组织处有序活动；或者，他也可以提供某种中间类型的产品，帮助人们平滑度过两种人群模式，减少由于变化而产生的阵痛。
但是，产品经理的主流应该是服务于未来。先于人众接触新技术新知识，并把这种认知转化为产品，利用产品提供现代人类社会中的各种人群。尽一切可能，降低学习成本，利用人类的本能设计产品，使得人群得以顺利“滑入”新的产品使用场景。 在所有这一切之上，产品经理的目标应该是实现社会美和善和总量。 三、移动互联网产品经理的素养
1、 敏锐感知潮流变化。移动互联网产品会从相对匮乏时代进入相对富足时代，用户可以选择的产品会随时日流逝而日渐增加，产品终将成为一种时尚业。产品经理若是沉溺于各种新鲜玩意儿之中，追逐新奇，很可能错过真实的时代潮流，无法把握人群的真实需求。
2、 放弃理性思维。移动互联网的最大特点是变化极快，传统的分析用户，调研市场，制定产品三年规划，在新的时代里已经落伍。人类群落本身也在迁移演变，产品经理更应该依靠直觉和感性，而非图表和分析，把握用户需求。产品经理永远都应该是文艺青年，而非理性青年。
3、 海量的实践。尽管移动互联网方兴未艾，没有任何人可以自称是领域内的专家。但是，这不意味着存在天降天才的可能。《异类》中提出的一万小时定律，同样适用于产品经理。他们需要超过千次的产品实践，才能称得上是了解产品设计，拥有解决问题的能力。
4、 博而不专的积累。美术、音乐、阅读、摄影、旅游等等文艺行为貌似不能直接转化为生产力，但是合格的产品经理需要广博的知识储备，以此才能了解和认识大数量的人群，理解时代的审美，让自己的所思所感符合普通用户的思维范式。以此为基础，设计的产品才不会脱离人群。
5、 负责的态度。拥有合适的方法论和合适的素养，成功的产品经理还应该有对自己和产品负责的态度，唯其如此，产品经理才能足够偏执，清楚地知道自己究竟要做什么，抵挡住来自上级和绩效考核的压力，按照自己的意志不变形、不妥协地执行产品策划。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/367d303f7127051d3f505391d147a2bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92d5ae2cdd725c02ae89e2242e7391b2/" rel="bookmark">
			Like SQL语句的优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Like SQL语句的优化 Like SQL语句的优化的一个小测试
1.尽量不要使用 like '%..%'
2.对于 like '..%..' (不以 % 开头)，Oracle可以应用 colunm上的index
3.对于 like '%...' 的 (不以 % 结尾)，可以利用reverse + function index 的形式，变化成 like '..%'
具体的测试流程： (测试工具：PLSQL Developer)
[1] '建测试表和Index，注意，重点在于带reverse的function index。同时，一定要使用CBO才行。
已连接到 Oracle Database 10g Enterprise Edition Release 10.2.0.1.0 已连接为 zxdbm_ismp
SQL&gt; select reverse('123') from dual;
REVERSE('123')
--------------
321
SQL&gt; create table test_like as select object_id,object_name from dba_objects;
Table created.
SQL&gt; create index test_like_name on test_like(object_name);
Index created.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92d5ae2cdd725c02ae89e2242e7391b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/934980996b753b42642d93b8207072ec/" rel="bookmark">
			第四章　WINDOWS绘图程序设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图形设备接口（GDI：Graphics Device Interface）是Windows的子系统，它负责在视频显示器和打印机上显示图形。正如您所认为的那样，GDI是Windows非常重要的部分。不但您为Windows编写的应用系统在显示视觉信息时只使用GDI，就连Windows本身也只使用GDI来显示用户界面对象，诸如菜单、滚动条、图标和鼠标光标。
不幸的是，如果要对GDI进行全面的讲述，将需要一整本书。在本章中，我只是想向您提供画线和填充区域的基本知识，这对于理解GDI 已经足够了。
GDI的结构
从程序员的观点来看，GDI由几百个函数调用和一些相关的数据类型、宏和结构组成。 但是在开始讲述这些函数的细节之前，让我们先从宏观上了解一下GDI的整体结构。
一、GDI原理
Windows 98 / NT / 2000 中的图形主要由GDI32．DLL动态链接库输出的函数来处理。在 Windows98中，这个 GDI32．DLL实际是利用 16位 GDI．EXE动态链接库来执行许多函数。在 Windows NT中，GDI．EXE只用于16位的程序。
这些动态链接库为您安装的视频显示器和任何打印机调用设备驱动程序中的例程。视频驱动程序访问视频显示器的硬件，打印机驱动程序将GDI命令转换为各种打印机能够理解的代码或命令。显然，不同的视频显示适配器和打印机要求不同的设备驱动程序。
因为ＰＣ兼容机上可以连接许多种不同的视频设备，所以，GDI的主要目的之一是支持与设备无关的图形。Windows程序应该能够毫无困难地在Windows支持的任意一种图形输出设备上运行，GDI通过将您的程序和不同输出设备的特性隔离开来的方法来达到这一目的。
图形输出设备分为两大类：光栅设备和矢量设备。大多数ＰＣ的输出设备是光栅设备，这意味着它们以点模式来表示图像，这类设备包括视频显示适配器、点阵打印机和激光打印机。矢量设备使用线来绘制图像，通常局限于绘图仪。
许多传统的计算机图形编程都是完全基于矢量的，这意味着使用矢量图形系统的程序是在硬件之上一定层次的抽象。输出设备用像素表示图形，但是程序与编程接口之间并不是用像素进行对话的。您当然可以使用 Windows GDI作为一个高层次的矢量绘制系统，同时也可以将它用于比较低层次的像素操作。
从这方面来看，Windows GDI和传统的图形接口语言之间的关系，就如同Ｃ和其他编程语言之间的关系一样。Ｃ以它在不同操作系统和环境之间的高度可移植性而闻名，然而Ｃ也以它允许程序员进行低层次系统调用而闻名，这些调用在其他高级语言中通常是不可能的。正如 Ｃ有时被认为是一种“高级汇编语言”一样，您可以认为 GDI是图形设备硬件之间的一种高层接口。
已经看到，默认时Windows使用基于像素的坐标系。大多数传统的图形语言使用“虚拟”坐标系，其水平和垂直轴的范围从 0~32767。虽然有些图形语言不让您使用像素坐标，但是 Windows GDI允许您使用两者之一（甚至基于物理度量的坐标系）。您可以使用虚拟坐标系以便程序远离硬件，或者也可以使用设备坐标系而完全接近硬件。
早期，许多用户在一种单色显示器上运行Windows。即使近几年，笔记本计算机还只有灰度级别。为此，GDI的设计保证了您可以在编写一个程序时不必过多地担心色彩问题——也就是说，Windows可以将色彩转换为灰度级别。甚至在今天，Windows 98使用的视频显示已经具有了不同的色彩能力（16色、256色、“高彩色”，以及“真彩色”）。虽然，彩色喷墨打印机的成本已经很低了，但是大多数用户仍然坚持使用黑白打印机。不加区别地使用这些设备是可以的，但是您的程序也应该能决定在某种显示设备上有多少色彩可以使用，从而最好地利用硬件。
当然，就如同您编写Ｃ程序时，为了使它在其他计算机上运行而遇到一些微妙的移植性问题一样，您也可能不小心让设备依赖性溜进您的Windows程序，这就是不与硬件完全隔离的代价。您还应该知道 Windows GDI的局限。虽然可以在显示器上到处移动图形对象，但GDI通常是一个静态的显示系统，只有有限的动画支持。如果需要为游戏编写复杂的动画，就应该研究一下 Microsoft DirectX，它提供了您需要的支持。
二、GDI函数调用
组成GDI的几百个函数调用可以分为几大类：
获取《或创建》和释放（或清除）设备描述表的函数 在绘图时需要设备描述表句柄。GetDC和RealseDC函数让您在非WM_PAINT 的消息期间来做到这一点，而BeginPaint和 EndPaint函数（虽然在技术上它们是 USER模　块而不是GDI模块的一部分）在进行绘图的WM_PAINT消息期间使用。获取有关设备描述表信息的函数GetTextMetrics函数来获取有关设备描述表中当前所选字体的尺寸信息。绘图函数 显然，在所有前提条件都得以满足之后，这些函数是真正重要的部分。我们使用TextOut函数在窗口的客户区显示一些文本。我们将看到，其他GDI函数还可以让您画线、填充区域。
设置和获取设备描述表参数的函数 设备描述表的“属性”决定有关绘图函数如何工作的细节。例如，用SetTextColor来指定TextOut（或者其他文本输出函数）所绘制的文本色彩。我们使用SetTextAlign来告诉GDI:TextOut函数中的文本串的开始位置应该在串的右边而不是默认的左边。设备描述表的所有属性都有默认值，当获取设备描述表时设置这些默认值。对于所有的Set函数，都有相应的Set函数，以允许您获取当前设备描述表属性。
使用GDI对象的函数 GDI在这里变得有点混乱。首先举一个例子：默认时使用GDI绘制的所有直线都是实线，并具有一个标准的宽度。您可能希望绘制更细的直线，或者是由一系列的点或短划线组成的直线。这种线的宽度和这种线的线型不是设备描述表的属性，而是一个“逻辑画笔”的特征。
您可以通过在CreatePen、CreatePenIndirect或ExtCreatePen函数中指定这些特征来创建一个逻辑画笔，这些函数返回一个逻辑画笔的句柄（虽然这些函数被认为是GDI的一部分，但是和大多数GDI函数调用不一样，它们不要求设备描述表的句柄）。要使用这个画笔，就要将画笔句柄选进设备描述表。我们认为，设备描述表中当前选中的画笔就是设备描述表的一个属性。这样，您画任何线都使用这个画笔，然后，您可以取消设备描述表中的画笔选择，并清除画笔对象。清除画笔对象是必要的，因为画笔定义占用了分配的内存空间。除了画笔以外，GDI对象还用于创建填充封闭区域的刷子、字体、位图，以及GDI的其他一些方面。
三、GDI图元
在屏幕或打印机上显示的图形类型本身可以被分为几类，通常被称为“图元”，它们是:
直线和曲线 线条是所有矢量图形绘制系统的基础。GDI支持直线、矩形、椭（包括椭圆的子集，也就是我们所说的“圆”）、椭圆圆周上的部分曲线即所谓“弧”，以及贝塞尔曲线，我们将在本章中分别对它们进行介绍。所有更复杂的曲线可由折线（ polyline）代替，折线通过一组非常短的直线来定义一条曲线。线条用设备描述表中选中的当前画笔绘制。
填充区域 当一系列直线或者曲线封闭了一个区域时，该区域可以使用当前GDI画剧对象进行填充。这个画刷可以是实心色彩、图案（可以是一系列的水平、垂直或者对角标记），也可以是在区域内垂直或者水平重复的位图图像。
位图 位图是位的矩形数组，这些位对应于显示设备上的像素，它们是光栅图形的基础工具。位图通常用于在视频显示器或者打印机上显示复杂（一般都是真实的图像。位图还可以用于显示必须很快绘制的小图像，诸如图标、鼠标光标，以及在应用工具栏中出现的按钮等。ＧＤＩ支持两种类型的位图——老的（虽然还非常有用）“设备有关”位图，是 ＧＤＩ对象；新的（如 Windows 3 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/934980996b753b42642d93b8207072ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7805772456ca0d82fd9d7bc3fc0a4a2/" rel="bookmark">
			zoj 2672
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		zoj 2672
#include &lt;stdio.h&gt; #include &lt;string.h&gt; #define MAXN 3010 #define Inf 10000 #define Prime 24971 #define HashSize ( 1 &lt;&lt; 20 ) using namespace std; typedef short int Integer; int N , Num [MAXN] , Ans [MAXN] , Len , Left [MAXN]; Integer MaxLong [MAXN] [MAXN] , * S [MAXN]; struct TNode { int Key , Next; Integer Long; }; int Hash [HashSize]; TNode Node [MAXN]; bool init (); void solve (); void print (); Integer * find ( int ); Integer * Insert ( int ); main () { bool first = true; while ( init () ) { if ( first ) first = false; else printf ( "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7805772456ca0d82fd9d7bc3fc0a4a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffc739e20d24dc4cc3b303055b4a70e7/" rel="bookmark">
			poj  1043
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		poj 1043 经典的八数码问题，这个问题最重要的是hash函数的使用，用来判重，因为是记录路径，所以用bfs最好了
#include &lt;iostream&gt; #include &lt;cstdlib&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #define M 362888 using namespace std; int map[12]; bool vis[M]; struct NODE { long long num,pre,dir; }Q[M&lt;&lt;3]; int dt[4][2]={{1,0},{0,1},{-1,0},{0,-1}}; const int fact[9] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320}; long long step[M]; long long canto() { int j, i, tmp; long long ans; for (ans = 1, i = 0; i &lt; 9; i++) { for (tmp = map[i] - 1, j = 0; j &lt; i; j++) tmp -= (map[j] &lt; map[i]); ans = ans + tmp * fact[8 - i]; } return ans; } void antihash(long long num) { int k=8; while(k!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffc739e20d24dc4cc3b303055b4a70e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11ae2fc58d7071f58799c9adffc0af07/" rel="bookmark">
			超好用的uthash万岁~~~
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include "uthash.h" #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; /*这个uthash必须构造一个结构体*/ struct packet { int key; /*这个是用来做hash的key值*/ char msg[10]; UT_hash_handle hh; /*这个结构是uthash的结构体，里面包含next，prev，hash值等信息*/ }; int main() { struct packet *pkt, *tmp; int i; struct packet *hash_packet = NULL; /*必须初始化为NULL*/ /*打印这个hash的节点数*/ printf ("hash count = %d \n", HASH_COUNT(hash_packet)); /*往hash中添加节点*/ for (i=0; i&lt;10; i++) { pkt = (struct packet *)malloc(sizeof(struct packet)); pkt-&gt;key=i; sprintf (pkt-&gt;msg, "i=%d", i); HASH_FIND_INT(hash_packet, &amp;i, tmp); if (tmp != NULL) { printf ("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11ae2fc58d7071f58799c9adffc0af07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/527d905067952e801e157377eddffeb4/" rel="bookmark">
			【转】网页调试语法错误代码说明(通用于IIS,MYSQL,FTP,ASP，VBScript)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[size=3][color=Red]经常有朋友为出现错误而不知道出错在什么地方而发贴询问
就发一个关于经常用的几类错误代码解析,自己出错了也知道什么问题了.[/color][/size]
[size=3][color=Red]IIS：[/color][/size]
400 无法解析此请求。 401.1 未经授权：访问由于凭据无效被拒绝。 401.2 未经授权: 访问由于服务器配置倾向使用替代身份验证方法而被拒绝。 401.3 未经授权：访问由于 ACL 对所请求资源的设置被拒绝。 401.4 未经授权：Web 服务器上安装的筛选器授权失败。 401.5 未经授权：ISAPI/CGI 应用程序授权失败。 401.7 未经授权：由于 Web 服务器上的 URL 授权策略而拒绝访问。 403 禁止访问：访问被拒绝。 403.1 禁止访问：执行访问被拒绝。 403.2 禁止访问：读取访问被拒绝。 403.3 禁止访问：写入访问被拒绝。 403.4 禁止访问：需要使用 SSL 查看该资源。 403.5 禁止访问：需要使用 SSL 128 查看该资源。 403.6 禁止访问：客户端的 IP 地址被拒绝。 403.7 禁止访问：需要 SSL 客户端证书。 403.8 禁止访问：客户端的 DNS 名称被拒绝。 403.9 禁止访问：太多客户端试图连接到 Web 服务器。 403.10 禁止访问：Web 服务器配置为拒绝执行访问。 403.11 禁止访问：密码已更改。 403.12 禁止访问：服务器证书映射器拒绝了客户端证书访问。 403.13 禁止访问：客户端证书已在 Web 服务器上吊销。 403.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/527d905067952e801e157377eddffeb4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e436432edbe7455eb74e184d6e988ae/" rel="bookmark">
			Linux网络编程socket错误分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源地址：http://blog.csdn.net/uestc_huan/article/details/5863614
Linux网络编程socket错误分析
socket错误码：
EINTR： 4
阻塞的操作被取消阻塞的调用打断。如设置了发送接收超时，就会遇到这种错误。
只能针对阻塞模式的socket。读，写阻塞的socket时，-1返回，错误号为INTR。另外，如果出现EINTR即errno为4，错误描述Interrupted system call，操作也应该继续。如果recv的返回值为0，那表明连接已经断开，接收操作也应该结束。
ETIMEOUT：110
1、操作超时。一般设置了发送接收超时，遇到网络繁忙的情况，就会遇到这种错误。
2、服务器做了读数据做了超时限制，读时发生了超时。
3、错误被描述为“connect time out”，即“连接超时”，这种情况一般发生在服务器主机崩溃。此时客户 TCP将在一定时间内（依具体实现）持续重发数据分节，试图从服务 TCP 获得一个 ACK 分节。当最终放弃尝试后（此时服务器未重新启动），内核将会向客户进程返回 ETIMEDOUT 错误。如果某个中间路由器判定该服务器主机已经不可达，则一般会响应“destination unreachable”－“目的地不可达”的ICMP消息，相应的客户进程返回的错误是 EHOSTUNREACH 或ENETUNREACH。当服务器重新启动后，由于 TCP 状态丢失，之前所有的连接信息也不存在了，此时对于客户端发来请求将回应 RST。如果客户进程对检测服务器主机是否崩溃很有必要，要求即使客户进程不主动发送数据也能检测出来，那么需要使用其它技术，如配置 SO_KEEPALIVE Socket 选项，或实现某些心跳函数。
EAGAIN：
1、Send返回值小于要发送的数据数目，会返回EAGAIN和EINTR。
2、recv 返回值小于请求的长度时说明缓冲区已经没有可读数据，但再读不一定会触发EAGAIN，有可能返回0表示TCP连接已被关闭。
3、当socket是非阻塞时,如返回此错误,表示写缓冲队列已满,可以做延时后再重试.
4、在Linux进行非阻塞的socket接收数据时经常出现Resource temporarily unavailable，errno代码为11(EAGAIN)，表明在非阻塞模式下调用了阻塞操作，在该操作没有完成就返回这个错误，这个错误不会破坏socket的同步，不用管它，下次循环接着recv就可以。对非阻塞socket而言，EAGAIN不是一种错误。
EPIPE：
1、Socket 关闭，但是socket号并没有置-1。继续在此socket上进行send和recv，就会返回这种错误。这个错误会引发SIGPIPE信号，系统会将产生此EPIPE错误的进程杀死。所以，一般在网络程序中，首先屏蔽此消息，以免发生不及时设置socket进程被杀死的情况。
2、write(..) on a socket that has been closed at the other end will cause a SIGPIPE.
3、错误被描述为“broken pipe”，即“管道破裂”，这种情况一般发生在客户进程不理会（或未及时处理）Socket 错误，继续向服务 TCP 写入更多数据时，内核将向客户进程发送 SIGPIPE 信号，该信号默认会使进程终止（此时该前台进程未进行 core dump）。结合上边的 ECONNRESET 错误可知，向一个 FIN_WAIT2 状态的服务 TCP（已 ACK 响应 FIN 分节）写入数据不成问题，但是写一个已接收了 RST 的 Socket 则是一个错误。程序应该设置成Ignore这个信号。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e436432edbe7455eb74e184d6e988ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66e212ce964e319e7fa7dadfb016a917/" rel="bookmark">
			COM三大接口:IUnknown、IClassFactory、IDispatch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自：http://blog.sina.com.cn/s/blog_86d10dc701014m2v.html
(1)COM组件有三个最基本的接口类，分别是IUnknown、IClassFactory、IDispatch。
（1、1）
COM规范规定任何组件、任何接口都必须从IUnknown继承，IUnknown包含三个函数，分别是 QueryInterface、AddRef、Release。这三个函数是无比重要的，而且它们的排列顺序也是不可改变的。
QueryInterface用于查询组件实现的其它接口，说白了也就是看看这个组件的父类中还有哪些接口类，AddRef用于增加引用计数，Release用于减少引用计数。引用计数也是COM中的一个非常重要的概念。大体上简单的说来可以这么理解，COM组件是个DLL，当客户程序要用它时就要把它装到内存里。另一方面，一个组件也不是只给你一个人用的，可能会有很多个程序同时都要用到它。但实际上DLL只装载了一次，即内存中只有一个COM组件，那COM组件由谁来释放？由客户程序吗？不可能，因为如果你释放了组件，那别人怎么用，所以只能由COM组件自己来负责。所以出现了引用计数的概念，COM维持一个计数，记录当前有多少人在用它，每多一次调用计数就加一，少一个客户用它就减一，当最后一个客户释放它的时侯，COM知道已经没有人用它了，它的使用已经结束了，那它就把它自己给释放了。
引用计数是COM编程里非常容易出错的一个地方，但所幸VC的各种各样的类库里已经基本上把AddRef的调用给隐含了，在我的印象里，我编程的时侯还从来没有调用过AddRef，我们只需在适当的时侯调用Release。至少有两个时侯要记住调用Release，第一个是调用了 QueryInterface以后，第二个是调用了任何得到一个接口的指针的函数以后，记住多查MSDN 以确定某个函数内部是否调用了AddRef，如果是的话那调用Release的责任就要归你了。 IUnknown的这三个函数的实现非常规范但也非常烦琐，容易出错，所幸的事我们可能永远也不需要自己来实现它们。
IUnknown{public:BEGIN_INTERFACEvirtual HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid,void __RPC_FAR *__RPC_FAR *ppvObject) = 0;virtual ULONG STDMETHODCALLTYPE AddRef( void) = 0;virtual ULONG STDMETHODCALLTYPE Release( void) = 0;};（1、2）
IClassFactory的作用是创建COM组件。我们已经知道COM组件实际上就是一个类，那我们平常是怎么实例化一个类对象的？是用'new’命令!很简单吧，COM组件也一样如此。但是谁来new它呢？不可能是客户程序，因为客户程序不可能知道组件的类名字，如果客户知道组件的类名字那组件的可重用性就要打个大大的折扣了，事实上客户程序只不过知道一个代表着组件的128位的数字串而已，这个等会再介绍。所以客户无法自己创建组件，而且考虑一下，如果组件是在远程的机器上，你还能new出一个对象吗？所以创建组件的责任交给了一个单独的对象，这个对象就是类厂。每个组件都必须有一个与之相关的类厂，这个类厂知道怎么样创建组件，当客户请求一个组件对象的实例时，实际上这个请求交给了类厂，由类厂创建组件实例，然后把实例指针交给客户程序。
这个过程在跨进程及远程创建组件时特别有用，因为这时就不是一个简单的new操作就可以的了，它必须要经过调度，而这些复杂的操作都交给类厂对象去做了。IClassFactory最重要的一个函数就是CreateInstance，顾名思议就是创建组件实例，一般情况下我们不会直接调用它，API函数都为我们封装好它了，只有某些特殊情况下才会由我们自己来调用它，这也是VC编写COM组件的好处，使我们有了更多的控制机会，而VB给我们这样的机会则是太少太少了。
IClassFactory : public IUnknown{public:virtual HRESULT STDMETHODCALLTYPE CreateInstance( IUnknown *pUnkOuter,REFIID riid,void **ppvObject) = 0;virtual HRESULT STDMETHODCALLTYPE LockServer( BOOL fLock) = 0;};（1、3）IDispatch叫做调度接口。它的作用何在呢？这个世上除了C++还有很多别的语言，比如VB、 VJ、VBScript、JavaScript等等。可以这么说，如果这世上没有这么多乱七八糟的语言，那就不会有IDispatch。:-)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66e212ce964e319e7fa7dadfb016a917/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fbf20aead53f90ad4fbe85019c192b1/" rel="bookmark">
			高手给菜鸟学习Linux的10个建议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着Linux应用的扩展许多朋友开始接触Linux，根据学习Windows的经验往往有一些茫然的感觉：不知从何处开始学起。这里介绍学习Linux的一些建议。
一、从基础开始：常常有些朋友在Linux论坛问一些问题，不过，其中大多数的问题都是很基础的。例如：为什么我使用一个命令的时候，系统告诉我找不到该目录，我要如何限制使用者的权限等问题，这些问题其实都不是很难的，只要了解了 Linux 的基础之后，应该就可以很轻易的解决掉这方面的问题。而有些朋友们常常一接触Linux 就是希望构架网站，根本没有想到要先了解一下Linux 的基础。这是相当困难的。
二、Linux命令是必须学习虽然Linux桌面应用发展很快，但是命令在Linux中依然有很强的生命力。 Linux是一个命令行组成的操作系统，精髓在命令行，无论图形界面发展到什么水平这个原理是不会变的，Linux命令有许多强大的功能：从简单的磁盘操作、文件存取、到进行复杂的多媒体图象和流媒体文件的制作。举一个例子： Linux的常用命令find，察看man文档，初学者一定会觉得太复杂而不原意用，但是你一旦学会就爱不释手。它的功能实在太强了，在配合exec参数或者通过管道重定向到xargs命令和grep命令，可以完成非常复杂的操作，如果同样的操作用图形界面的工具来完成，恐怕要多花十几陪的时间。不同版本的Linux命令数量不一样，这里笔者把它们中比较重要的和使用频率最多的命令，按照它们在系统中的作用分成几个部分介绍给大家，通过这些基础命令的学习我们可以进一步理解Linux系统：安装和登录命令：login、 shutdown、 halt、 reboot 、mount、umount 、chsh 文件处理命令：file、 mkdir、 grep、dd、 find、 mv 、ls 、diff、 cat、 ln 系统管理相关命令： df、 top、 free、 quota 、at、 lp、 adduser、 groupadd kill、 crontab、 tar、 unzip、 gunzip 、last 网络操作命令：ifconfig、 ip 、ping 、 netstat 、telnet、 ftp、 route、 rlogin rcp 、finger 、mail 、nslookup 系统安全相关命令： passwd 、su、 umask 、chgrp、 chmod、chown、chattr、sudo、 pswho
三、选择一本好的工具书工具书对于学习者而言是相当重要的。一本错误观念的工具书却会让新手整个误入歧途。目前国内关于Linux的书籍有很多不过精品的不多，笔者强烈建议阅读影印本的“O而且出版社还提供了一个非常好的路线图：。
四、选择一个适合你的Linux发行版本目前全球有超过1百多个Linux发行版本，在国内也能找到十几个常见版本。如何选择请根据你的需求和能力，Redhat Linux 和Debian Linux是网络管理员的理想选择。对于英语不是很好的读者红旗Linux、中标Linux这些中文版本比较适合。现在一些Linux网站有一些 Linux版本的免费下载，这里要说的是并不适合Linux初学者。
五、养成在命令行下工作：一定要养成在命令行下工作的习惯，要知道X-window只是运行在命令行模式下的一个应用程序。在命令行下学习虽然一开始进度较慢，但是熟悉后，您未来的学习之路将是以指数增加的方式增长的。从网管员来说，命令行实际上就是规则，它总是有效的，同时也是灵活的。即使是通过一条缓慢的调制解调器线路，它也能操纵几千公里以外地远程系统。
六、 选择一个适合你的Linux社区;随着Linux应用的扩展，出现了不少Linux社区。当然首推LUPA开源社区 www.lupaworld.com 啦。另外还有一些非常优秀的社区：www.linuxforum.net(国内最高水平GNU站点)、 http://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fbf20aead53f90ad4fbe85019c192b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/042d1148ea9240d3ece5910dfd4fd72d/" rel="bookmark">
			LINUX的困难
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、当人们开始接触自己不熟悉的东西的时候，总是会下意识地试图利用自己已经掌握的经验来降低学习难度。这在很多时候很有效，但也有起反作用的时候，比方说学习linux。 相信对很多人而言，初次接触linux，最大的困难并不是对linux一无所知，而是太习惯windows下的一些概念了。如逻辑盘符，软件安装向导，不区分大小写的文件及文件夹命名等。 尤其是磁盘上的逻辑分区概念，对于熟悉linux的人来说自然没什么，但对于刚基础linux的时候，因为逻辑分区的概念，在安装linux时就会碰到不小的麻烦。因为linux虽然也有分区的概念，但和windows以盘符来标识不同，linux是将分区全部挂载到唯一的一棵目录树中去的。而且这样的初始分区通常有4到5个，每个分区的大小都会对使用者提出经验上的要求。这就让初学linux的人在尚未入门前，就不得不面对这些难题。 2、linux还有个先天的特征就是：它是专门设计用来给专业人员使用的，也就是说，本质上它并不适合初学者入门之用。由于这个原因，就产生了这样一个悖论：使用linux的人必须首先已经学会了linux才行，而要学习linux的人自然还不熟悉linux。打个比方就是：你得先工作才能赚到钱，但想得到工作却得先有钱做多方面的投资后才能得到工作。这也就是linux入门比windows难的原因所在。 3、现代操作系统在设计时，采用驱动程序这个概念，使得操作系统生产商可以非常方便地通过驱动程序操作硬件厂商生产的各类硬件，但不幸的是，驱动程序是系统相关的，不同操作系统的驱动程序架构各不相同，不能通用。在这一点上，windows占据了市场，让每个硬件厂商在生产硬件时，首先会为windows实现相关的驱动程序，因此windows就会很容易识别并使用各类硬件，但linux由于出现比较晚，在这一点上无疑是比不上windows的。这也就让初学者在安装linux时，因为硬件驱动的问题而平添不少麻烦。 4、linux的专业性，使得在其上开发软件的设计者多数也是非常专业的人员，正因为他们的专业能力，使得他们在开发软件时，主要注重的是性能和效率，对于易用性不怎么关注。这对于初学者而言，无意增加了学习难度。 综上所述，学习linux的困难是客观存在的，也是不容忽视的。下面就来谈谈怎么克服这些困难。 1、首先，尽可能简化安装linux的硬件环境，linux诞生于90年代，那时候正是intel P3 级电脑流行的时候，linux开发者使用的电脑自然也不例外（例外的我们通常也碰不着）。因为到现在，这些比较老的硬件已经流行很长时间，linux社区为之开发驱动也相对比较多。在这种电脑上安装linux，在硬件不容易出现问题。当然，对于ubuntu之类的linux版本，还是安装在比较新的电脑上为佳，不过在P3级电脑上安装问题也不大。 2、其次，尽可能在单独的电脑上安装linux系统，现在拥有一台以上电脑的人家已经很多了，建议初学者有条件的话，最好专门弄一台电脑来安装linux，这样可以避免一台电脑上安装多个操作系统带来的麻烦。 如果只有一台电脑的话，那也最好不要将linux直接安装在实际的磁盘分区上，最好使用虚拟机如vmware来安装，毕竟一开始只是个学习环境而非实用环境，只要能将linux装起来就不错了。而且即使安装出错，也不会影响什么，大不了删除安装文件即可。 3、最好先在准备安装linux系统的电脑上安装一次windows系统，并让windows识别出全部硬件，再尽可能将硬件信息抄下来。然后删除windows系统并安装linux系统（这样做可能会遭至一些人的非议，认为还是脱离不了windows，其实大可不必这样想，毕竟大多数硬件首先是为windows设计的，因此把windows当做“硬件型号测试仪”来用一把并没有什么）。当linux无法识别出硬件时，可以根据这些结果来进行手工配置。
4、由于缺少经验，第一次安装的linux系统的规划总不会很完备。很有可能出现这样那样的问题。这个时候，建议大家：只要不影响到最基本的使用，就不要马上去关注这些问题，比方说，无法显示高彩，音频工作不正常，图形界面不好看啊，还有中文无法输入之类的问题。不错，这些问题会影响使用者的用户体验。但请记住，自己还只是处于初学阶段，有些问题看撕简单，实则在这个阶段凭自己的能力未必搞得定。 5、与windows不同，linux对使用者的专业基础要求较高。因此，只要有个勉强能用的系统，就应该立即进入学习阶段。 6、与windows以对话框为主要交互模式不同，在linux下，很多时候都是使用编辑器编写脚本、修改配置文件、或者编写程序。所以此时应首先在系统中寻找一个功能比较简单的编辑器并掌握之，虽然linux系统中最流行的编辑器是vim和emacs，并且掌握了这两个编辑器后，会显得很酷。但再次提醒：现在还是初学阶段，这两个编辑器是非常强大，但也非常不容易掌握。如果此时冒然使用，很容易打击学习的积极性。 7、linux之所以强大的原因之一就是其强大的脚本功能。可以很容易地自行组织linux提供的工具来完成复杂的任务。因此掌握了编辑器的应用后，可以开始选择一种shell脚本语言来学习。linux下最常用的shell解释器是bash。建议初学者去选购一本关于bash的入门的书，在指导下学习。虽然linux提供了完备的man手册，但都是英语写的，这对于很多初学者来说，阅读起来甚不方便。还有一点就是，此时应以熟悉语法为主，千万不要贪快，试图立即编写比较负责的脚本。因为shell脚本真正强大的地方是它对linux提供的大量实用工具的“黏合剂”的能力。此时的初学者尚未熟悉多少linux提供的工具，尚不足以编写复杂的脚本。 8、掌握了基本的shell语法后，可以开始着手熟悉/bin下的一组工具，这是linux下工具的最小子集，每个工具都务必要理解清楚，知道它们是干什么的，常用的开关项有哪些。尤其是grep, find这几个命令，更是需要多加熟悉。有了这两个工具，就可以完成大量搜索功能，这有助于在系统中查找想要的东西。 9、熟悉了/bin下的工具之后，就可以编写相对复杂的shell脚本了。这个时候，应勤加练习，尽可能提高编写脚本的熟练程度。以期达到可以对任何基于文件系统中目录和文件的相关操作都可以得心应手的程度。同时，到了这个阶段，也该鸟枪换炮，换个编辑器来提高编辑效率（当然也可以准备体验什么叫酷了） 10、vim编辑器属于效率型编辑器，设计它的目的就是为了提高编辑效率，减少编辑过程总的辅助操作（翻页，光标移动）等浪费的时间。vim编辑器是带模式的编辑器，在编辑状态下，不需要动用光标移动键、翻页键就可以方便地定位光标位置。用到熟练处，几乎可以随心所欲地控制光标所在的位置、跳转到指定的位置等等。。。。。。vim是本人见过的效率最高的编辑器，以至于于本人自从掌握了vim后，除了ulatraedit尚可勉强一用之外。再无无法适应任何其它编辑器了。 11、emacs编辑器属于功能性编辑器，它和vim的设计目的不同，它不是以编辑效率为主，而是以功能扩展性为主的，通过其内嵌的人工智能专用语言lisp的变种--schema。几乎可以不脱离emacs而完成任何任务。以至于很多人使用emacs的工作模式就是上班--登录--打开emacs--工作--关闭emacs--注销-下班。emacs享受“基于编辑器的操作系统之称”。 12、掌握了以上两种编辑器的任何一种后，即拥有了在linux中编辑文档的能力。此时，初学者已经有能力对位于/etc下的各类配置文件进行编辑了。/etc下是linux系统的配置文件目录，里面的文件非常之多，要想短时间掌握并不现实，所以不应操之过急，应该在以后的学习阶段慢慢掌握。同时到了这个阶段，代表从应用上，初学者已经入门了。下面，可以根据自己的实际目标，有选择地进行强化了。至于强化的方面很多，有桌面应用、系统维护、软件开发、数据库管理、文档管理，等等。。。。。。 进一步学习了一段时间后，相信大家都会发现之前安装系统上的不如意之处，这时候可以选择重装一次linux系统，根据自己学习的心得，对系统进行合理的配置，以期获得称心如意的linux系统。 至于以后的路嘛，就得靠自己走了。。。。。。 正所谓“武林称雄，引刀自宫”，最难的第一步都走出去了，还会怕以后吗？（纯属恶搞，切莫生气）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29e3a27f0af133a6c34287d56c3c9c6d/" rel="bookmark">
			一些位计算的奇淫技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		The Aggregate Magic Algorithms There are lots of people and places that create and collect algorithms of all types (here are a few WWW sites). Unfortunately, in building systems hardware and software, we in The Aggregate often have found it necessary to do relatively obscure low-level things very efficiently. Many of the tricks we've devised or collected either require assembly language coding or are not entirely portable when coded in HLLs like C, but these techniques are still valuable because they can yield significant performance improvements over the more obvious ways of doing things.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29e3a27f0af133a6c34287d56c3c9c6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd007fb96832bb46587816257111b22b/" rel="bookmark">
			如何在Hibernate中使用union
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经过百度，google知道hibernate中hql是不支持union的，所以只能借助native sql了。背景如下：一年前写了一个hql：
原来代码
String countHql2 = "select count(distinct p) from Project as p,CommentSimple as c,ProjectBookmark as b where (" + "c.owner.id=? and p.id=c.targetId and c.targetType=500) or (b.user.id=? and p.id=b.project.id)"; http://open.189works.com/product/product.htm String hql2 = "select distinct p from Project as p,CommentSimple as c,ProjectBookmark as b where ( "+ "c.owner.id=? and p.id=c.targetId and c.targetType=500) or (b.user.id=? and p.id=b.project.id)"; 主要是找出某个人所有评论过或收藏过的项目。简单表结构如下：
project:id owner_id(用户id)保存项目的基本信息
project_bookmark:uid(用户id)，project_id(收藏的项目的id)，owner_id(收藏者的id)
comment_simple:target_type(保存对某种对象的评论，值为500时表示的对项目的评论)，target_id(保存对某种对象的评论，值为该对象的id)，project_id(项目的id)，owner_id(评论者的id)
由于这个sql执行时所建的索引无法使用，而且还造成了三个表连接会有大量的无效的查询以及重复结果，最后还得要distinct可以想象执行的效率。
只好改用union来重写，需要用到hibernate的native sql，经过努力终于找到可以用union找出整个对象以及在配置文件中与该对象有关系的对象的方法。
与其说是找出来的，不如说是试出来的，代码如下：
union
String sql1 = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd007fb96832bb46587816257111b22b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84d4f75eae7862bb157616be555e47e9/" rel="bookmark">
			String类型转换的三种方法分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在很多情况下我们都需要将一个对象转换为String类型。一般来说有三种方法可以实现：Object.toString()、(String)Object、String.valueOf(Object)。下面对这三种方法一一分析：
一、采用Object.toString()
toString方法是java.lang.Object对象的一个public方法。在java中任何对象都会继承Object对象，所以一般来说任何对象都可以调用toString这个方法。这是采用该种方法时，常派生类会覆盖Object里的toString()方法。
但是在使用该方法时要注意，必须保证Object不是null值，否则将抛出NullPointerException异常。
二、采用(String)Object
该方法是一个标准的类型转换的方法，可以将Object转换为String。但是在使用该方法是要注意的是需要转换的类型必须是能够转换为String的，否则会出现CalssCastException异常错误。
Object o = new Integer(100); String string = (String)o; 这段程序代码会出现java.lang.ClassCastException:java.lang.Integercannotbecasttojava.lang.String。因为将Integer类型强制转换为String类型，无法通过。
三、String.valueOf(Object)
上面我们使用Object.toString()方法时需要担心null问题。但是使用该方法无需担心null值问题。因为在使用String.valueOf(Object)时，它会判断Object是否为空值，如果是，则返回null。下面为String.valueOf(Object)的源码：
public static String valueOf(Object obj) { return (obj == null) ? "null" : obj.toString(); } 从上面我们可以看出两点：一是不需要担心null问题。二是它是以toString()方法为基础的。
但是一定要注意：当object为null时，String.valueOf（object）的值是字符串对象："null"，而不是null！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c36e697e1b30d0d735f557eba6ed630/" rel="bookmark">
			企业管理系统ERP/EIP/OA/BI系统集成信息化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 企业管理系统ERP/EIP/OA/BI系统集成信息化 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c20a481198fd1758b2dc9e622db8220e/" rel="bookmark">
			磁盘碎片以及磁盘碎片整理程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.什么叫磁盘碎片？
：磁盘碎片指的是硬盘读写过程中产生的不连续文件。
2.产生磁盘碎片的主要原因？
：因为文件被分散保存到整个磁盘的不同地方，而不是连续地保存在磁盘连续的簇中形成的。 当应用程序所需的物理内存不足时，一般操作系统会在硬盘中产生临时交换文件，用该文件所占用的硬盘空间虚拟成内存。虚拟内存管理程序会对硬盘频繁读写，产生大量的碎片，这是产生硬盘碎片的主要原因。
还有一种情况就是当中间的一个扇区内容被删除后，新写入一个较小的文件，这样在这个文件两边就会出现一些空间，这时候再写入一个文件，两段空间的任意一部分都不能容纳该文件，这时候就需要将文件分割成两个部分，碎片再次产生了。
最常见的就是下载电影之类的大文件，这期间大家一般都会处理一下其它事情，而下载下来的电影文件被迫分割成若干个碎片存储于硬盘中。因此下载是产生碎片的一个重要源头。还有就是经常删除、添加文件，这时候如果文件空间不够大，就会产生大量的磁盘碎片，随着文件的删改频繁，这种情况会日益严重。 3.磁盘碎片会给电脑造成什么影响？
：虽然说磁盘碎片对于正常工作影响并不大，但是会显著降低硬盘的运行速度，还会增加数据丢失和数据损坏的可能性。这主要是硬盘读取文件需要在多个碎片之间跳转，增加了等待盘片旋转到指定扇区的潜伏期和磁头切换磁道所需的寻道时间。
电脑使用久了，磁盘上保存了大量的文件，这些文件并非保存在一个连续的磁盘空间上，而是把一个文件分散的放在许多地方，这些零散的文件被称作“磁盘碎片”，这些碎片会降低整个windows的性能，每次读写文件磁盘触头都要来回移动，浪费了时间。于是windows中都提供一个整理磁盘碎片的程序。 4.怎样对磁盘碎片进行处理？
：Windows自带有这样的程序：磁盘碎片整理程序（DiskDefragmenter），但在工具软件NortonUtilities和Nuts&amp;Bolts中有更好的此类程序。
整理前的准备工作 我们在整理硬盘前一般都要对它清理垃圾信息，检查有无错误，最后才能谈到碎片的整理和优化。因此，我们在整理硬盘前，应该首先做好这些工作： 1、垃圾清理 系统工作一段时间后，垃圾文件就会非常之多，有程序安装时产生的 临时文件 、上网时留下的缓存文件、删除软件时剩下的DLL文件或强行关机时产生的错误文件等，建议“菜鸟”朋友还是使用 微软 的“磁盘清理程序”代劳，“老鸟”当然可以使用一些功能更强的软件或手工清理。 2、检查并修复硬盘中的错误。 首选的仍然是微软的“磁盘扫描程序”，虽然它的速度实在不怎么样，但只要你有足够的耐心，经过这个程序对磁盘完整而详细的扫描后，相信系统中的绝大多数错误已经被修复了。当然你也可以尝试一下其他工具，如 扁鹊神医 “Norton WinDoctor”，它的速度可比Windows中的“磁盘扫描工具”快多了。 编辑本段整理方法及注意 在Windows里，用户可以从“开始”菜单中选择“程序/附件/系统工具/磁盘碎片整理程序”，弹出选择驱动器窗口，选择要整理的分区，然后点击[确定]即可开始整理，但此方法碎片整理过程非常耗时，一般2GB左右的分区需要1个小时以上，所以建议读者: 1、整理磁盘碎片的时候，要关闭其他所有的应用程序，包括屏幕保护程序，最好将虚拟内存的大小设置为固定值。不要对磁盘进行读写操作，一旦Disk Defragment发现磁盘的文件有改变，它将重新开始整理。 2、整理磁盘碎片的频率要控制合适，过于频繁的整理也会缩短磁盘的寿命。一般经常读写的磁盘分区一周整理一次。 周期 个人电脑3个月一次 商业用户、企业用户、政府部门用户1个月一次。 磁盘碎片整理时，必须 屏幕保护程序 ，并且不要在电脑上干其他的事情，如听音乐，玩游戏等。让电脑只运行磁盘碎片整理程序，以防出现数据丢失 同时建议不要很频繁的整理硬盘，因为那样的话硬盘不停的进行读写，会影响寿命 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efcdd216af71a8655589e5eed52e2d04/" rel="bookmark">
			socket 错误码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		socket错误码： EINTR： 4 阻塞的操作被取消阻塞的调用打断。如设置了发送接收超时，就会遇到这种错误。 只能针对阻塞模式的socket。读，写阻塞的socket时，-1返回，错误号为INTR。另外，如果出现EINTR即errno为4，错误描述 Interrupted system call，操作也应该继续。如果recv的返回值为0，那表明连接已经断开，接收操作也应该结束。 ETIMEOUT：110 1、操作超时。一般设置了发送接收超时，遇到网络繁忙的情况，就会遇到这种错误。 2、服务器做了读数据做了超时限制，读时发生了超时。 3、错误被描述为“connect time out”，即“连接超时”，这种情况一般发生在服务器主机崩溃。此时客户 TCP 将在一定时间内（依具体实现）持续重发数据分节，试图从服务 TCP 获得一个 ACK 分节。当最终放弃尝试后（此时服务器未重新启动），内核将会向客户进程返回 ETIMEDOUT 错误。如果某个中间路由器判定该服务器主机已经不可达，则一般会响应“destination unreachable”－“目的地不可达”的ICMP消息，相应的客户进程返回的错误是 EHOSTUNREACH 或ENETUNREACH。当服务器重新启动后，由于 TCP 状态丢失，之前所有的连接信息也不存在了，此时对于客户端发来请求将回应 RST。如果客户进程对检测服务器主机是否崩溃很有必要，要求即使客户进程不主动发送数据也能检测出来，那么需要使用其它技术，如配置 SO_KEEPALIVE Socket 选项，或实现某些心跳函数。 EAGAIN： 1、Send返回值小于要发送的数据数目，会返回EAGAIN和EINTR。 2、recv 返回值小于请求的长度时说明缓冲区已经没有可读数据，但再读不一定会触发EAGAIN，有可能返回0表示TCP连接已被关闭。 3、当socket是非阻塞时,如返回此错误,表示写缓冲队列已满,可以做延时后再重试. 4、在Linux进行非阻塞的socket接收数据时经常出现Resource temporarily unavailable，errno代码为11(EAGAIN)，表明在非阻塞模式下调用了阻塞操作，在该操作没有完成就返回这个错误，这个错误不会破坏 socket的同步，不用管它，下次循环接着recv就可以。对非阻塞socket而言，EAGAIN不是一种错误。 EPIPE： 1、Socket 关闭，但是socket号并没有置-1。继续在此socket上进行send和recv，就会返回这种错误。这个错误会引发SIGPIPE信号，系统会将 产生此EPIPE错误的进程杀死。所以，一般在网络程序中，首先屏蔽此消息，以免发生不及时设置socket进程被杀死的情况。 2、write(..) on a socket that has been closed at the other end will cause a SIGPIPE. 3、错误被描述为“broken pipe”，即“管道破裂”，这种情况一般发生在客户进程不理会（或未及时处理）Socket 错误，继续向服务 TCP 写入更多数据时，内核将向客户进程发送 SIGPIPE 信号，该信号默认会使进程终止（此时该前台进程未进行 core dump）。结合上边的 ECONNRESET 错误可知，向一个 FIN_WAIT2 状态的服务 TCP（已 ACK 响应 FIN 分节）写入数据不成问题，但是写一个已接收了 RST 的 Socket 则是一个错误。 EBADF： read(.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/efcdd216af71a8655589e5eed52e2d04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1179ca40fe90fb77e9dc6f365d94f6b5/" rel="bookmark">
			IOS 四种保存数据的方式！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在iOS开发过程中，不管是做什么应用，都会碰到数据保存的问题。将数据保存到本地，能够让程序的运行更加流畅，不会出现让人厌恶的菊花形状，使得用户体验更好。下面介绍一下数据保存的方式：
1.NSKeyedArchiver：采用归档的形式来保存数据，该数据对象需要遵守NSCoding协议，并且该对象对应的类必须提供encodeWithCoder:和initWithCoder:方法。前一个方法告诉系统怎么对对象进行编码，而后一个方法则是告诉系统怎么对对象进行解码。例如对Possession对象归档保存。
定义Possession：
@interface Possession：NSObject&lt;NSCoding&gt;{//遵守NSCoding协议
NSString *name;//待归档类型
}
@implementation Possession
-(void)encodeWithCoder:(NSCoder *)aCoder{
[aCoder encodeObject:name forKey:@"name"];
}
-(void)initWithCoder:(NSCoder *)aDecoder{
name=[[aDeCoder decodeObjectforKey:@"name"] retain];
}
归档操作：
如果对Possession对象allPossession归档保存，只需要NSCoder子类NSKeyedArchiver的方法archiveRootObject:toFile: 即可。
NSString *path = [self possessionArchivePath];
[NSKeyedArchiver archiveRootObject:allPossessions toFile: path ]
解压操作：
同样调用NSCoder子类NSKeyedArchiver的方法unarchiveRootObject:toFile: 即可 allPossessions = [[NSKeyedUnarchiver unarchiveObjectWithFile:path] retain];
缺点：归档的形式来保存数据，只能一次性归档保存以及一次性解压。所以只能针对小量数据，而且对数据操作比较笨拙，即如果想改动数据的某一小部分，还是需要解压整个数据或者归档整个数据。 2.NSUserDefaults：用来保存应用程序设置和属性、用户保存的数据。用户再次打开程序或开机后这些数据仍然存在。NSUserDefaults可以存储的数据类型包括：NSData、NSString、NSNumber、NSDate、NSArray、NSDictionary。如果要存储其他类型，则需要转换为前面的类型，才能用NSUserDefaults存储。具体实现为：
保存数据：
NSUserDefaults *defaults =[NSUserDefaults standardUserDefaults];
NSString *name =@”default string“;
[defaults setObject:firstName forKey:@"name"];
//获得UIImage实例
UIImage *image=[[UIImage alloc]initWithContentsOfFile:@"photo.jpg"];
NSData *imageData = UIImageJPEGRepresentation(image, 100);//UIImage对象转换成NSData
[defaults synchronize];//用synchronize方法把数据持久化到standardUserDefaults数据库
读取数据：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1179ca40fe90fb77e9dc6f365d94f6b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bd63013b06a482d37e4e63dcad70fcf/" rel="bookmark">
			嵌入式职业规划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 网上看到众多网友都问了关于嵌入式系统方面的很多问题，很多都可在这里找到答案，希望我的这篇文章能给他们以启发。
一、嵌入式系统的概念 着重理解“嵌入”的概念
主要从三个方面上来理解。 1、从硬件上，将基于CPU的处围器件，整合到CPU芯片内部，比如早期基于X86体系结构下的计算机，CPU只是有运算器和累加器的功能，一切芯片要造外部桥路来扩展实现，象串口之类的都是靠外部的16C550/2的串口控制器芯片实现，而目前的这种串口控制器芯片早已集成到CPU内部，还有PC机有显卡，而多数嵌入式处理器都带有LCD控制器，但其种意义上就相当于显卡。比较高端的ARM类Intel Xscale架构下的IXP网络处理器CPU内部集成PCI控制器（可配成支持4个PCI从设备或配成自身为CPI从设备）；还集成3个NPE网络处理器引擎，其中两个对应于两个MAC地址，可用于网关交换用，而另外一个NPE网络处理器引擎支持DSL，只要外面再加个PHY芯片即可以实现DSL上网功能。IXP系列最高主频可以达到1.8G，支持2G内存，1G×10或10G×1的以太网口或Febre channel的光通道。IXP系列应该是目标基于ARM体系统结构下由intel进行整合后成Xscale内核的最高的处理器了。 2、从软件上前，就是在定制操作系统内核里将应用一并选入，编译后将内核下载到ROM中。而在定制操作系统内核时所选择的应用程序组件就是完成了软件的“嵌入”，比如WinCE在内核定制时，会有相应选择，其中就是Wordpad,PDF,MediaPlay等等选择，如果我们选择了，在CE启动后，就可以在界面中找到这些东西，如果是以前PC上将的windows操作系统，多半的东西都需要我们得新再装。 3、把软件内核或应用文件系统等东西烧到嵌入式系统硬件平台中的ROM中就实现了一个真正的“嵌入”。
以上的定义是我在6、7年前给嵌入式系统下自话侧重于理解型的定义，书上的定义也有很多，但在这个领域范围内，谁都不敢说自己的定义是十分确切的，包括那些专家学者们，历为毕竟嵌入式系统是计算机范畴下的一门综合性学科
二、嵌入式系统的分层与专业的分类。 嵌入式系统分为４层，硬件层、驱动层、操作系统层和应用层。
1、硬件层，是整个嵌入式系统的根本，如果现在单片机及接口这块很熟悉，并且能用C和汇编语言来编程的话，从嵌入式系统的硬件层走起来相对容易，硬件层也是驱动层的基础，一个优秀的驱动工程师是要能够看懂硬件的电路图和自行完成CPLD的逻辑设计的，同时还要对操作系统内核及其调度性相当的熟悉的。但硬件平台是基础，增值还要靠软件。 硬件层比较适合于，电子、通信、自动化、机电一体、信息工程类专业的人来搞，需要掌握的专业基础知识有，单片机原理及接口技术、微机原理及接口技术、C语言。 2、驱动层，这部分比较难，驱动工程师不仅要能看懂电路图还要能对操作系统内核十分的精通，以便其所写的驱动程序在系统调用时，不会独占操作系统时间片，而导至其它任务不能动行，不懂操作系统内核架构和实时调度性，没有良好的驱动编写风格，按大多数书上所说添加的驱动的方式，很多人都能做到，但可能连个初级的驱动工程师的水平都达不到，这样所写的驱动在应用调用时就如同windows下我们打开一个程序运行后，再打开一个程序时，要不就是中断以前的程序，要不就是等上一会才能运行后来打开的程序。想做个好的驱动人员没有三、四年功底，操作系统内核不研究上几编，不是太容易成功的，但其工资在嵌入式系统四层中可是最高的。 驱动层比较适合于电子、通信、自动化、机电一体、信息工程类专业尤其是计算机偏体系结构类专业的人来搞，除硬件层所具备的基础学科外，还要对数据结构与算法、操作系统原理、编译原理都要十分精通了解。
3、操作系统层，对于操作系统层目前可能只能说是简单的移植，而很少有人来自已写操作系统，或者写出缺胳膊少腿的操作系统来，这部分工作大都由驱动工程师来完成。操作系统是负责系统任务的调试、磁盘和文件的管理，而嵌入式系统的实时性十分重要。据说，XP操作系统是微软投入300人用两年时间才搞定的，总时工时是600人年，中科院软件所自己的女娲Hopen操作系统估计也得花遇几百人年才能搞定。因此这部分工作相对来讲没有太大意义。
4、应用层，相对来讲较为容易的，如果会在windows下如何进行编程接口函数调用，到操作系统下只是编译和开发环境有相应的变化而已。如果涉及Jave方面的编程也是如此的。嵌入式系统中涉及算法的由专业算法的人来处理的，不必归结到嵌入式系统范畴内。但如果涉及嵌入式系统下面嵌入式数据库、基于嵌入式系统的网络编程和基于某此应用层面的协议应用开发（比如基于SIP、H.323、Astrisk）方面又较为复杂，并且有难度了。
三、目标与定位。
先有目标，再去定位。
学ARM，从硬件上讲，一方面就是学习接口电路设计，另一方面就是学习汇编和C语言的板级编程。如果从软件上讲，就是要学习基于ARM处理器的操作系统层面的驱动、移植了。这些对于初学都来说必须明确，要么从硬件着手开始学，要么从操作系统的熟悉到应用开始学，但不管学什么，只要不是纯的操作系统级以上基于API的应用层的编程，硬件的寄存器类的东西还是要能看懂的，基于板级的汇编和C编程还是要会的。因此针对于嵌入式系统的硬件层和驱动程的人，ARM的接口电路设计、ARM的C语言和汇编语言编程及调试开发环境还是需要掌握的。 因此对于初学者必然要把握住方向，自己的目标是什么，自己要在那一层面上走。然后再着手学习较好，与ARM相关的嵌入式系统的较为实际的两个层面硬件层和驱动层，不管学好了那一层都会很有前途的。 如果想从嵌入式系统的应用层面的走的话，可能与ARM及其它体系相去较远，要着重研究基嵌入式操作系统的环境应用与相应开发工具链，比如WinCe操作系统下的EVC应用开发（与windows下的VC相类似），如果想再有突破就往某些音视频类的协议上靠，比如VOIP领域的基于SIP或H.323协议的应用层开发，或是基于嵌入式网络数据库的开发等等。
对于初学者来讲，要量力而行，不要认为驱动层工资高就把它当成方向了，要结合自身特点，嵌入式系统四个层面上那个层面上来讲都是有高人存在，当然高人也对应的高工资，我是做硬件层的，以前每月工资中个人所得税要被扣上近3千大元，当然我一方面充当工程师的角色，一方面充当主管及人物的角色，两个职位我一个人干，但上班时间就那些。硬件这方面上可能与我PK的人很少了，才让我拿到那么多的工资。 四、开发系统选择。
很多ARM初学者都希望有一套自己能用的系统，但他们住住会产生一种错误认识就是认为处理器版本越高、性能越高越好，就象很多人认为ARM9与ARM7好，我想对于初学者在此方面以此入门还应该理智，开发系统的选择最终要看自己往嵌入式系统的那个方向上走，是做驱动开发还是应用，还是做嵌入式系统硬件层设计与板级测试。如果想从操作系统层面或应用层面上走，不管是驱动还是应用，那当然处理器性能越高越好了，但这个东西自学，有十分大的困难，不是几个月或半年或是一年二年能搞定的事。
在某种意义上请，ARM7与9的差别就是在某些功能指令集上丰富了些，主频提高一些而已，就比如286和386。对于用户来讲可能觉查不到什么，只能是感觉速度有些快而已。　ARM7比较适合于那些想从硬件层面上走的人，因为ARM7系列处理器内部带MMU的很少，而且比较好控制，就比如S3C44B0来讲，可以很容易将Cache关了，而且内部接口寄存器很容易看明白，各种接口对于用硬件程序控制或AXD单步命令行指令都可以控制起来，基于51单片机的思想很容易能把他搞懂，就当成个32位的单片机，从而消除很多51工程师想转为嵌入式系统硬件ARM开发工程师的困惑，从而不会被业界某此不是真正懂嵌入式烂公司带到操作系统层面上去，让他们望而失畏，让业界更加缺少这方面的人才。
而嵌入式系统不管硬件设计还是软件驱动方面都是十分注重接口这部分的，选择平台还要考察一个处理器的外部资源，你接触外部资源越多，越熟悉他们那你以后就业成功的机率就越高，这就是招聘时所说的有无“相关技能”，因为一个人不可能在短短几年内把所有的处理器都接触一遍，而招聘单位所用的处理器就可能是我们完全没有见过的，就拿台湾数十家小公司（市价几千万）的公司生产的ARM类处理器，也很好用，但这些东西通用性太差，用这些处理器的公司就只能招有相关工作经验的人了，那什么是相关工作经验，在硬件上讲的是外围接口设计，在软件上讲是操作系统方面相关接口驱动及应用开发经验。我从业近十年，2000年ARM出现，我一天始做ARM7,然后直接跑到了Xscale（这个板本在ARM10-11之间），一做就是五年，招人面试都不下数百人，在这些方面还是深有体会的。　我个人认为三星的S3C44b0对初学者来说比较合适，为什么这么说哪？因为接口资源比较丰富，技术成熟，资料较多，应该十分适合于初学者，有问题可能很容易找人帮且解决，因为大多数人都很熟悉，就如同51类的单片机，有N多位专家级的人物可以给你帮忙，相关问题得以很快解答，所然业界认为这款ARM都做用得烂了，但对于初学者来，就却是件好事。 因此开发系统的选择，要看自己的未来从来目标方向、要看开发板接口资源、还要看业界的通用性。
五、如何看待培训。 首先说说我自己，我目前从业近十年，与国内嵌入式系统行业共同起步，一直站在嵌入式系统行业前沿，设计过多款高端嵌入式系统平台产品并为众多公司提供过解决方案，离职前为从事VOIP的美资公司设计IP-PBX，历任项目经理、项目主管、技术总监、部门经理，积累众多人脉，并集多年经验所得，考虑到学生就业与公司招人的不相匹配，公司想招人招不到，而学生和刚毕业的工程师想找份工作也不太容易，于此力创知天行科技有限公司，开展嵌入式系统教育培训。 因一线的科研人员和一线的教师不相接触，导至国内嵌入式人才缺乏，国外高校的技术超前于业界公司，而国内情况是业界公司方面的嵌入式系统技术要远远领先于高校。为架构业界与高校沟通的桥梁，把先进技能带给高校学子，为学生在就业竞争中打造一张王牌，并为业界工程师快速提升实现自我创造机遇，我就这样辞去了外企年薪20多万的职位，做嵌入式系统方面的培训了。 对于培训来讲，是花钱来买时间，很多工程师都喜欢自己学，认为培训不值，这也是有可能的，纯为赚钱的培训当然不会太有价值，但对于实力型的培训他们可能就亏大了，有这样一笔帐不知他们算过没有，如果一个一周的培训，能带给他们自学两年后才能掌握的知识，在培训完后他们用三个月到半年时间消化培训内容，这样他会省约至少一年半的时间来学其它的或重新站在另一个高度上工作，那么他将最迟一年后会拿到他两年后水平所对应的工资，就是在工资与水平对应的关系上比同批人缩短一年，每月按最少1千计，再减去培训费用至少多1.0万，同时也省了一年时间，不管是休闲也好，再继续提高也好，总之是跑到了队伍的前面了。 另一层面上讲，对于新人的培训相当于他们为自己提前买了份失业保险，有师傅会带领他们入道，我今年暑假时班里最年轻的一个学生是大二的，今年才上大三，这学期才刚学单片机，但现在ARM方面的编程工作已经搞得有声有色了，再过一年多毕业，他还会失业吗？ 再者通过培训，你可以知道很多业界不为常人所知的事，同时也为自己找了个师傅，就比如说，两个工程师分别用S3C2410和PXA255来做手持设备，同样两人都工作四年，再出去找工作，两人工资可能最多可相差一倍，为什么？这就是业界不为常人所知的规则，2410属于民品，被业界用烂了，做产品时成本特敏感，当然也对人才成本敏感了，PXA255是intel的东西，一个255 CPU能买三个2410，一直被业界定义为贵族产品，用的公司都是大公司或为军方服务的公司，不会在乎成本，只要把东西做好，一切都好说，但这方面做的人也少啊，因为开发系统贵啊。 对于说为自已找了个好师傅，我想是这样的，因为同级工程师间存在着某此潜在的竞争关系，有很多人不愿意把自己知道的东西教给别人，这意味着他将要失业，就是所说的教会徒弟，饿死师傅，但对于我们这些人就不存在这样的关系了，我是在嵌入式系统平台设计上走到了一定程序，目前在国内这块的技术上已经是自己很难再突破自己，因此很多东西我对大家都是OPEN的，就比如说下面那部分关于接口设计中所提到的时序接口东西，我要是不讲，却使是高级硬件工程师我想也几乎只有10%的人能知道吧。 六、成为高级嵌入式系统硬件工程师要具备的技能。
首先我声明，我是基于嵌入式系统平台级设计的，硬件这个方向我相对来讲比较有发言权，如果是其它方面所要具备的基本技能还要和我们培训中心其它专业级讲师沟通，或去网站看看www.zt-training.com。他们的方面上我只能说是知道些，但不是太多，初级的问题也可以问我。 对于硬件来讲有几个方向，就单纯信号来分为数字和模拟，模拟比较难搞，一般需要很长的经验积累，单单一个阻值或容值的精度不够就可能使信号偏差很大。因此年轻人搞的较少，随着技术的发展，出现了模拟电路数字化，比如手机的Modem射频模块，都采用成熟的套片，而当年国际上只有两家公司有此技术，自我感觉模拟功能不太强的人，不太适合搞这个，如果真能搞定到手机的射频模块，只要达到一般程度可能月薪都在15K以上。 另一类就是数字部分了，在大方向上又可分为51/ARM的单片机类，DSP类，FPGA类，国内FPGA的工程师大多是在IC设计公司从事IP核的前端验证，这部分不搞到门级，前途不太明朗，即使做个IC前端验证工程师，也要搞上几年才能胜任。DSP硬件接口比较定型，如果不向驱动或是算法上靠拢，前途也不会太大。而ARM单片机类的内容就较多，业界产品占用量大，应用人群广，因此就业空间极大，而硬件设计最体现水平和水准的就是接口设计这块，这是各个高级硬件工程师相互PK，判定水平高低的依据。而接口设计这块最关键的是看时序，而不是简单的连接，比如PXA255处理器I2C要求速度在100Kbps，如果把一个I2C外围器件，最高还达不到100kbps的与它相接，必然要导致设计的失败。这样的情况有很多，比如51单片机可以在总线接LCD，但为什么这种LCD就不能挂在ARM的总线上，还有ARM7总线上可以外接个Winband的SD卡控制器，但为什么这种控制器接不到ARM9或是Xscale处理器上，这些都是问题。因此接口并不是一种简单的连接，要看时序，要看参数。 一个优秀的硬件工程师应该能够在没有参考方案的前提下设计出一个在成本和性能上更加优秀的产品，靠现有的方案，也要进行适当的可行性裁剪，但不是胡乱的来，我遇到一个工程师把方案中的5V变1.8V的DC芯片，直接更换成LDO，有时就会把CPU烧上几个。前几天还有人希望我帮忙把他们以前基于PXA255平台的手持GPS设备做下程序优化，我问了一下情况，地图是存在SD卡中的，而SD卡与PXA255的MMC控制器间采用的SPI接口，因此导致地图读取速度十分的慢，这种情况是设计中严重的缺陷，而不是程序的问题，因此我提了几条建议，让他们更新试下再说。因此想成为一个优秀的工程师，需要对系统整体性的把握和对已有电路的理解，换句话说，给你一套电路图你终究能看明白多少，看不明白80%以上的话，说明你离优秀的工程师还差得远哪。其次是电路的调试能力和审图能力，但最最基本的能力还是原理图设计PCB绘制，逻辑设计这块。这是指的硬件设计工程师，从上面的硬件设计工程师中还可以分出ECAD工程师，就是专业的画PCB板的工程师，和EMC设计工程师，帮人家解决EMC的问题。硬件工程师再往上就是板级测试工程师，就是C语功底很好的硬件工程师，在电路板调试过程中能通过自已编写的测试程序对硬件功能进行验证。然后再交给基于操作系统级的驱动开发人员。
总之，硬件的内容很多很杂，硬件那方面练成了都会成为一个高手，我时常会给人家做下方案评估，很多高级硬件工程师设计的东西，经常被我一句话否定，因此工程师做到我这种地步，也会得罪些人，但硬件的确会有很多不为人知的东西，让很多高级硬件工程师也摸不到头脑。
那么高级硬件件工程师技术技能都要具备那些东西哪，首先要掌握EDA设计的辅助工具类如Protel/ORCAD/PowperPCB/Maplux2/ISE、VDHL语言，要能用到这些工具画图画板做逻辑设计，再有就是接口设计审图能力，再者就是调试能力，如果能走到总体方案设计这块，那就基本上快成为资深工程师了。
硬件是要靠经验，也要靠积累的，十年磨一剑，百年磨一针。
把一个月前想写的东西，今天终于用一上午的进间整理完了，希望对喜爱嵌入式系统开发的工程师和学生们有所帮助。
高级硬件工程师不仅要有设计能力还有具有相当深厚的基本功，就是EDA工具类的使用，EDA工程师包括原理图和PCB工具，逻辑设计工具和VHDL
SCH有Cadence下的Orcad 和Mentors公司的pads下的powerpcb.
当然protel也具有这两部分功能但它在国际上不通用。只是国内通用。如果想走得高些或到台资、日资、美资公司及国内需要对外交流的大公司的话，上面的硬件的原理图工具和PCB工资必须掌握的，
逻辑这块，硬件工程师主要是负责CPLD这块，涉及FPGA这块时应该会有专业FPGA人员来搞定的，因FPGA不太适合做逻辑的。因此硬件工程师只到CPLD为止。
CPLD常用的设计软件有Alter公司的Maxplus2
和Xilinx公司的ISE
所用语言大多是VHDL语言。
最后推荐一个适合初学者的社区--邀月社区
网址：http://www.cngeeks.net
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93886ba5b845dc2c87914ccf6d3d65a8/" rel="bookmark">
			RAID组中的“Foreign”状态磁盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇文章《利用MegaRaid Storage Manager 管理LSI RAID卡》讲述了MegaRaid 的安装使用，用它连到一个安装有LSI 8888ELP的RAID卡后，发现RAID组处于降级状态，有一个磁盘显示为“foreign”。这才想起这个机器之前被我拔了一个磁盘，用另外一个机器上的磁盘替换。如下图，Slot3这块磁盘为foreign，原来为hot spare的Slot11现在处于rebuild状态。
google了下，找到这么一句话：
It means it has detected some RAID configuration/data on it and thus, considers it as a disk being part of an array that may be imported into current controller configuration. Because of this, it will not automatically rebuild until you force it to.
大体意思是说Slot3是其他RAID组的成员，现在加入到这个新的RAID组，除非你强制clear上面的信息，否则新的RAID组不会利用这个Slot3的磁盘去重建RAID。
利用“show progress”可以看到目前RAID组重建的进度
6个小时后，RAID5重建完毕，这要是生产系统，6个小时的重建。。。让人吃不消。当然这些都可以利用Megacli查看
重建完后，可以选择8888ELP RAID卡，然后扫描所有磁盘中有无“foreign”，如下图 结果显示有1个foreign磁盘，即Slot3号，这里选择Clear或Advanced都可以
会显示3个RAID组，第一个为RAID1，第二个为RAID5，这两个都是我自己手动建的正常RAID组，而第3个RAID组(Drive Group2)即是不正常的处于Degraded的RAID组，选中它，然后“Clear”掉上面的信息即可。
之后，Slot3就是一个空磁盘，上面没有任何信息，如下图
把它指定为Global Hot Space。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79bf0f3fc065a9ed340724f89c48712c/" rel="bookmark">
			11gR2 GI总结(二)-11gR2 Grid Infrastructure Redundant Interconnect and ora.cluster_interconnect.haip...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CVU(Cluster Verification Utility)是一个非常有用的工具：
1.checks operating system versions and patches.
2.kernel parameters.
3.user limits.
4.operating system groups and users.
5.secure shell configuration.
5.networking configuration.
6.shared storage device.
Valid Stages are:
-pre crsinst : pre-check for CRS installation
-pre acfscfg : pre-check for ACFS Configuration.
-pre dbinst : pre-check for database installation
-pre dbcfg : pre-check for database configuration
-pre hacfg : pre-check for HA configuration
-pre nodeadd : pre-check for node addition.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79bf0f3fc065a9ed340724f89c48712c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d9bc85dae532d41027c31b50471545b/" rel="bookmark">
			fiddler2抓包工具使用图文教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、软件简介：
一款免费且功能强大的数据包抓取软件。它通过代理的方式获取程序http通讯的数据，可以用其检测网页和服务器的交互情况，能够记录所有客户端和服务器间的http请求，支持监视、设置断点、甚至修改输入输出数据等功能。fiddler包含了一个强大的基于事件脚本的子系统，并且能够使用.net框架语言扩展。所以无论对开发人员或者测试人员来说，都是非常有用的工具。
二、fiddler的下载与安装：
1、下载fiddler2汉化版软件，下载地址：http://www.cr173.com/soft/42248.html
2、下载完成后，解压文件，然后点击“Fiddler.exe”文件即可启动软件。
三、fiddler实用功能使用说明：
1、fiddler捕获浏览器的会话：
能支持http代理的任意程序都能被fiddler捕获到，由于fiddler的运行机制就是监听本机上的8888端口的http代理，所以我们要将浏览器的IE代理设置为127.0.0.1:8888，我们就以360浏览器为例设置浏览器的代理：点击【工具】—【Internet选项】—【连接】—【局域网设置】，再点击代理服务器的【高级】按钮，将HTTP代理服务器地址改为127.0.0.1:8888。
图一：设置浏览器代理
2、使用fiddler捕获HTTPS会话：
默认情况下，fiddler是不会捕获https会话的，所以需要自行设置一下。启动软件，点击【工具】—【fiddler选项】，在弹出的新窗口中，点击HTTPS选项卡，将捕获HTTPS连接这一选项前面全打上勾，点击OK就操作成功了。如下图所示：
图二：设置可以捕获HTTPS会话
3、fiddler主界面介绍：
启动fiddler，我们就会看到该软件的主界面，软件窗口大体可以分为六大部分：菜单栏、工具栏、会话列表、命令行工具栏、HTTP Request显示栏、Http Response显示栏。让你在捕获数据的时候一目了然。
图三：fiddler主界面图
4、查看HTTP统计视图：
通常fiddler会话列表中会显示捕获的所有的http通信量，并以列表的形式展示出来，点击你想查看的一个或者多个会话，再点击软件右边的【统计】菜单，你就可以很轻松的查看到请求数、发送字节数等信息。如果你选择第一个请求和最后一个请求，还可以获得页面加载所消耗的总体时间，还可以从图表中分辩出那些请求耗时最多，从而可以对页面的访问速度进行优化。
图四：查看某一会话的详细信息
5、QuickExec命令行的使用：
QuickExec命令行是会话列表下边的黑色区域，你可以在里面输入命令，回车之后即可执行你的命令，非常方便，在这里为大家介绍几个常用的命令：
help 打开官方的使用页面介绍，所有的命令都会列出来
cls 清屏 (Ctrl+x 也可以清屏)
select 选择会话的命令
?.png 用来选择png后缀的图片
bpu 截获request
图五：QuickExec命令行的使用
6、如何在fiddler中设置断点修改Response：
主要有两种方法：
1、点击【设置】菜单—【自动断点】—【响应之后】，这种方法是中断所有的会话，如果你想消除断点的话，就点击【设置】—【自动断点】—【禁用】就可以了。
2、在QuickExec命令行中输入：“bpuafter 网址/会话名”，这种方法是中断某一具体的会话，如果想消除命令的话，在命令行中输入“bpuafter”。
7、如何在fiddler中创建AUTOResponder规则：
设置AUTOResponder规则的好处是允许你从本地返回文件，而不用将http request发送到服务器上。我们就以访问博客园网站为例说明一下该功能的用法。
1) 打开博客园首页，把博客园的LOGO图片保存在本地，并把图片修改一下。
2) 打开fiddler找到刚才我们有该LOGO图片的会话，然后点击软件右边的自动响应选项卡，在“Enable authomatic reponses”和“permit passthrought unmatched requests”前面都打上勾，将会话拖到“自动响应”列表框中。
3) 在右下角的Rule Editor的第二个文本框选择“Find a File……”，然后选择本地保存的图片，点击“SAVE”按钮保存就可以了。
图六：选择修改后的LOGO文件 4) 我们再次打开博客园首页，注意观察LOGO图片已经变成我们所修改的那张了。
图七：效果图
8、fiddler的会话比较功能的使用：
选中两个会话，右键点击“Compare”，就可以利用WinDiff来比较两个会话有什么不同了。（注：使用这个功能的前提是你要安装有WinDiff）
图八：比较两个会话
9、fiddler还有编码小工具，下面我们来看一下应该怎么使用：
1）单击工具栏的“编码器”按钮
2）在弹出的新窗口中，你就可以操作了，如下图所示。
图九：编码工具的使用
10、fiddler查询会话：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d9bc85dae532d41027c31b50471545b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcc3eabe8378aee9c6c7584e9c0e1e60/" rel="bookmark">
			django框架简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要内容
1.Django框架发展
2.Django架构,MTV模式
3.开发流程 4.开发实例——Poll
python下各种框架
一个完整的Web应用框架包括下面功能的支持 服务发布 URL分发 模板支持 数据库处理 Python框架一般都支持前3个方面，按对4个功能的支持情况分类如下： 平台性框架：不依赖数据库，更关注服务的高校构建和运行平台的稳定。代表性框架：Zope和Twisted
轻小型框架：认为数据库不是应用的必要因素，更关注友好快速的简单任务的开发。代表性框架：Cherry，Quixote和web.py，没有内置的数据库支持模块。 一站式框架：认为数据库是应用的重要因素，关注如何仅基于本身快速实现一个功能性网站。代表性框架：Django，TurboGears Django简介
Django（维基百科） Django是一个开放源代码的Web应用框架，由Python写成。采用了MVC的软件设计模式，即模型M，视图V和控制器C。它最初是被开发来用于管理劳伦斯出版集团旗下的一些以新闻内容为主的网站的。并于2005年7月在BSD许可证下发布。这套框架是以比利时的吉普赛爵士吉他手Django Reinhardt来命名的。
Django的主要目标是使得开发复杂的、数据库驱动的网站变得简单。Django注重组件的重用性和“可插拔性”，敏捷开发和DRY法则（Don't Repeat Yourself）。在Django中Python被普遍使用，甚至包括配置文件和数据模型。 Django 于 2008年6月17日正式成立基金会。
Django吸引人的特点
在Python各种web框架中，Django的文档最完善、市场占有率最高、招聘职位最多！
优点
l完美的文档，Django的成功，我觉得很大一部分原因要归功于Django近乎完美的官方文档（包括Djangobook）。
l全套的解决方案，Django象Rails一样，提供全套的解决方案（full-stackframework + batteries included），基本要什么有什么（比如：cache、session、feed、orm、geo、auth），而且全部Django自己造，开发网站应手的工具Django基本都给你做好了，因此开发效率是不用说的，出了问题也算好找，不在你的代码里就在Django的源码里。
l强大的URL路由配置，Django让你可以设计出非常优雅的URL，在Django里你基本可以跟丑陋的GET参数说拜拜。
l自助管理后台，admin interface是Django里比较吸引眼球的一项contrib，让你几乎不用写一行代码就拥有一个完整的后台管理界面。
缺点（源自Django坚持自己造所有的轮子，整个系统相对封闭）
l系统紧耦合，如果你觉得Django内置的某项功能不是很好，想用喜欢的第三方库来代替是很难的，比如下面将要说的ORM、Template。要在Django里用SQLAlchemy或Mako几乎是不可能，即使打了一些补丁用上了也会让你觉得非常非常别扭。
lDjango自带的ORM远不如SQLAlchemy强大，除了在Django这一亩三分地，SQLAlchemy是Python世界里事实上的ORM标准，其它框架都支持SQLAlchemy了，唯独Django仍然坚持自己的那一套。Django的开发人员对SQLAlchemy的支持也是有过讨论和尝试的，不过最终还是放弃了，估计是代价太高且跟Django其它的模块很难合到一块。
lTemplate功能比较弱，不能插入Python代码，要写复杂一点的逻辑需要另外用Python实现Tag或Filter。
lURL配置虽然强大，但全部要手写，这一点跟Rails的Conventionover configuration的理念完全相左，高手和初识Django的人配出来的URL会有很大差异。
l让人纠结的auth模块，Django的auth跟其它模块结合紧密，功能也挺强的，就是做的有点过了，用户的数据库schema都给你定好了，这样问题就来了，比如很多网站要求email地址唯一，可schema里这个字段的值不是唯一的，纠结是必须的了。
lPython文件做配置文件，而不是更常见的ini、xml或yaml等形式。这本身不是什么问题，可是因为理论上来说settings的值是能够动态的改变的（虽然大家不会这么干），但这不是最佳实践的体现。
Django大包大揽，用它来快速开发一些Web运用是很不错的。如果你顺着Django的设计哲学来，你会觉得Django很好用，越用越爽；相反，你如果不能融入或接受Django的设计哲学，你用Django一定会很痛苦，趁早放弃的好。
组件
Django框架的核心包括：一个 面向对象 的映射器，用作数据模型（以Python类的形式定义）和关联性数据库间的媒介；一个基于正则表达式的URL分发器；一个视图系统，用于处理请求；以及一个模板系统。
核心框架中还包括：
l一个轻量级的、独立的Web服务器，用于开发和测试。
l一个表单序列化及验证系统，用于HTML表单和适于数据库存储的数据之间的转换。
l一个缓存框架，并有几种缓存方式可供选择。
l中间件支持，允许对请求处理的各个阶段进行干涉。
l内置的分发系统允许应用程序中的组件采用预定义的信号进行相互间的通信。
l一个序列化系统，能够生成或读取采用XML或JSON表示的Django模型实例。
l一个用于扩展模板引擎的能力的系统。
内置应用
Django 包含了很多应用在它的"contrib"包中，这些包括：
一个可扩展的认证系统动态站点管理页面一组产生 RSS 和 Atom 的工具一个灵活的评论系统产生Google 站点地图 (Google Sitemaps)的工具防止跨站请求伪造（cross-site request forgery）的工具一套支持轻量级标记语言（Textile和Markdown）的模板库一套协助创建地理信息系统（GIS）的基础框架 服务的部署
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dcc3eabe8378aee9c6c7584e9c0e1e60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab50e83311d290c11714685b613f0cef/" rel="bookmark">
			ipmitool启动报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当提示：
[root@localhost ~]# ipmitool sdr
Could not open device at /dev/ipmi0 or /dev/ipmi/0 or /dev/ipmidev/0: No
such file or directory
Get Device ID command failed
Unable to open SDR for reading
需要添加如下：
[root@localhost ~]# modprobe ipmi_watchdog
[root@localhost ~]# modprobe ipmi_poweroff
[root@localhost ~]# modprobe ipmi_devintf
[root@localhost ~]# modprobe ipmi_si
[root@localhost ~]# modprobe ipmi_msghandler
当添加ipmi_si时，提示：
FATAL: Error inserting ipmi_si (/lib/modules/2.6.9-5.ELsmp/kernel/drivers/char/ipmi/ipmi_si.ko): No such device
这是因为机器上没有IPMI设备而出现的报错。
转载于:https://blog.51cto.com/motor/894616
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a22bff968d887c0d8c65cc371b6798fa/" rel="bookmark">
			Diffie-Hellman算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 离散对数公钥密码体制的简要过程： 传送人Alice、Bob 两人首先协商确定使用有限域Z p，即确定p为多少。本例为p＝2579，域中本原元是α＝2； 假如现在Alice要发送信息x＝1299给Bob： 1、首先Bob选择随机数a＝765做为自己的私钥，通过私钥计算β＝2 765mod 2579＝949，Bob公开他的公钥949给Alice。 2、Alice选择随机数K＝853做为自己的私钥,通过私钥计算y 1＝2 853mod 2579＝435，y 1是Alice的公钥。 y 2＝1299×949 853mod 2579＝2396，y 2是密文。将计算得出的公钥和密文一起发送给Bob。 3、Bob收到密文对后计算x＝2396×（435 765） －1mod 2579＝1299，恢复出了密文。 以上是一个离散对数密码系统的简单应用实例，具体理论公式参见《密码学原理与实践》（第二版） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28843135adf151c351b654b9014b23bb/" rel="bookmark">
			memset 用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 memset可以方便的清空一个结构类型的变量或数组。 如： struct sample_struct { char csName[16]; int iSeq; int iType; }; 对于变量 struct sample_strcut stTest; 一般情况下，清空stTest的方法： stTest.csName[0]='\0'; stTest.iSeq=0; stTest.iType=0; 用memset就非常方便： memset(&amp;stTest,0,sizeof(struct sample_struct)); 如果是数组： struct sample_struct TEST[10]; 则 memset(TEST,0,sizeof(struct sample_struct)*10); 另外： 如果结构体中有数组的话还是需要对数组单独进行初始化处理的。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e157d7860a520116d56dabc017f0061d/" rel="bookmark">
			计算机容量单位换算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机容量单位及单位换算
B(Byte,字节)是计算机中最基本的计量单位。
b(bit,位,注意这个b和大写B的差别)是计算机中最小的单位。
1B=8b.
一个英文字母或数字在电脑中占用一个字节的空间,一个汉字占用两个字节。
1K (Kilo,千) =1024B M(Mega,百万,兆) 1M=1024K
G(Giga，十亿) 1G=1024M
T(Tril,万亿), 1T=1024G 内存的容量划分就是计算机的1024进制，每1024进一个单位，1KB=1024B ，1MB=1024KB ，1GB=1024MB ，1TB=1024GB。但硬盘就不是这种计算方法,windows操作系统是1024进制的，而硬盘制造商采用的是1000进制，也就是1KB=1024B ，1MB=1000KB，1G=1000MB，1TB=1000GB ，所以我们装系统以后，160GB的硬盘只显示有150多GB的容量，又比如我们把8GB的优盘插到电脑上，只显示有7GB多的容量。
计算机中二进制
计算机内部之所以采用二进制，其主要原因是二进制具有以下优点： (1)技术上容易实现。用双稳态电路表示二进制数字0和1，是很容易的事情。 (2)可靠性高。二进制中只使用0和1两个数字，传输和处理时不易出错，因而可以保障计算机具有很高的可靠性。 (3)运算规则简单。与十进制数相比，二进制数的运算规则要简单得多，这不仅可以使运算器的结构得到简化，而且有利于提高运算速度。 (4)与逻辑量相吻合。二进制数0和1正好与逻辑量“真”和“假”相对应，因此用二进制数表示二值逻辑显得十分自然。 (5)二进制数与十进制数之间的转换相当容易。人们使用计算机时可以仍然使用自己所习惯的十进制数，而计算机将其自动转换成二进制数存储和处理，输出处理结果时又将二进制数自动转换成十进制数，这给工作带来极大的方便。
转载于:https://www.cnblogs.com/ninelands/archive/2012/06/06/2538165.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/531c093d84d0a6b2da94a4b7b499bd0f/" rel="bookmark">
			VC&#43;&#43;实现视频压缩编码标准 MPEG-4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载请标明是引用于 http://blog.csdn.net/chenyujing1234 欢迎大家提出意见,一起讨论!
需要源码的请与我联系。
参考书籍&lt;&lt;Visual C++ 视频/音频编解码技术&gt;&gt;
1、 MPEG-4 编码技术 用于甚低数码率的音频/视频编码标准，它由一个数据比特数据流格式和相应的一组协议组成。
用于表示由自然或合成的音频、视频及对象数据组成的多媒体内容。
和MPEG-1、MPEG-2相比，MPEG-4中系统的概念发生了极大的变化，过去系统仅指整体结构、多路复用及同步功能，
而MPEG-4除此之外，又引入了视听对象及描述、场景描述、传输多媒体集成框架（Delivery Multimedia Integration Framework, DMIF）以及上载码流等概念
来支持基于内容的交换型多媒体应用。同时MPEG-4支持将自然信息和合成信息进行组合，包括图像与自然景物、合成声音与自然声音的组合。
1、1 MPEG-4 基本介绍 MPEG-4之前有四个运动图像编码标准：
MPEG-1 、MPEG-2、H.261、H.263
这四个标准就是把视频序列按时间先后分为一系列的帧，每一帧图像又分成16X16的宏块来进行运行补偿和编码。
这种基于是帧、块和像素的编码称为第一代视频编码方案，在编码过程中不考虑图像的具体结构和内容，因而会产生以下主要问题：
将图像固定地分成相同大小块，在高缩比的情况下会产生严重的块效应；
不能对图像的内容进行查询、编辑和回放等；
没有利用人类视频系统的特性。
1、1、1 基本原理 MPEG-4是基于图像的内容进行编码的，根据内容将图像分成不同的视频对象VO（Video Object）。
例如在可视电话系统中，经常将讲话的人作为前景视频对象，将其余部分作为背景视频对象。
前景视频对象由于包含重要的边界和轮廓信息，而且纹理又是理解图像的重要附加信息，因而在编码过程中应尽可能地保留这部分信息。
在编码过程中前景对象与背景对象采用不同的编码策略。前景对象的编码尽可能保留视频对象的细节和平滑。对人们不关心的背景可以采用大压缩比的编码策略，甚至不
予传输，而是在解码端用其他的背景拼接成新的背景。
MPEG-4视频标准还将合成技术用于编码。在视频非编码标准中定义了人脸部的合成编码。通过定义人脸的模型以及动画参数，在编码过程中只传输这些动画参数，不仅能
提高编码效率，还能用于虚拟电视会议系统的实现。在合成编码还实现了网格变形编码，对视频对象生成二维网格或三维网格模型，在编码的大部分时间中只编码传输网格
顶点的位置变化，在解码端利用已知的纹理信息和传来的网格顶点位置变化来合成编码的视频对象。
1、1、2 体系结构 MPEG-4标准通过定义框架、级、算法、工具 4层结构来分层描述具体应用中的编码方案。
(1)一个框架是一类应用的完整编码码流语法描述，它是整个MPEG-4码流语法的一个子集。
即使在给定框架的语法规定范围内，依然可能由于码流中参数的不同而导致编码器和解码器的功能和编码效率产生很大的差别。
(2)为了处理这个问题，在每个框架中又通过定义级来规定码流中各个参数的类型和限制。
(3)算法是为了完成框架所要求的功能而组织起来的一些工具集合。
1、1、3 主要特点 (1) 基于对象的功能。
MPEG-4标准的系统部分用来描述组成一幅画的各个视频对象之间的空间和时间的关系。
(2)形状编码
视频对象可以是任意形状的物体，因而定义了平面(Alpha Plane) 来描述对象的形状和位置信息。
平面主要有二进制和灰度两种。
二进制只确定某一像素点是否属于当前的对象，灰度平面可以描述对象的透明度，将不同的对象混合起来，完成某些特技效果，通常对平面的编码叫做形状编码。
(3)基于对象的编辑和交互式操作。
允许随机访问每个视频对象，具体地讲是能以0.5S的时间间隔访问对象，可以单独解码对象的形状信息，而不解码对象的纹理信息，也能对视频对象进行剪贴、平移和旋转。
(4) 多输入流多视点的编码和解码。
能有效地对来自不同的视频源图像进行编码，并能根据配置文档，在解码端把这些对象的码流同步地解码出来组成一幅图。在多视点立体视频编辑的应用中，
MPEG-4能有效地利用同一场景中不同视点图你信息的冗余性提高编码效率，对同一个场景仅能支持4个视点的编码。
(5) 码率方式。
可以支持各种不同的传输速率下的编码，其中包括小于64Kbit/s的低速码率、码率为64-384Kbit/s的高码率编码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/531c093d84d0a6b2da94a4b7b499bd0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b882fc419cd1c645d0eb490d0e2de89b/" rel="bookmark">
			java 邮件操作 email
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文转载从新浪微博：http://blog.sina.com.cn/s/blog_793797f001013c9z.html
（转载）学习javax.mail API(2012-05-18 23:46:51) 找了好久，终于见到某位仁兄给出了javax.mail运行机制的详细分析，感激感激，收藏了，以防找不到。
++++++++++++++++++++++++++++++++++++++++++++
打开JavaMail.jar文件，我们将发现在javax.mail的包下面存在着一些核心类：Session、Message、Address、Authenticator、Transport、Store、Folder。而且在 javax.mail.internet包中还有一些常用的子类。
A．Session
Session类定义了基本的邮件会话。就像Http会话那样，我们进行收发邮件的工作都是基于这个会话的。Session对象利用了java.util.Properties对象获得了邮件服务器、用户名、密码信息和整个应用程序都要使用到的共享信息。
Session类的构造方法是私有的，所以我们可以使用Session类提供的getDefaultInstance()这个静态工厂方法获得一个默认的Session对象：
1 Properties props = new Properties();// fill props with any information 2 Session session = Session.getDefaultInstance(props, null); 或者使用getInstance()这个静态工厂方法获得自定义的Session:
1 Properties props = new Properties();// fill props with any information 2 Session session = Session.getInstance(props, null); 从上面的两个例子中不难发现，getDefaultInstance()和getInstance()方法的第二个参数都是null，这是因为在上面的例子中并没有使用到邮件授权，下文中将对授权进行详细介绍。 从很多的实例看，在对mail server进行访问的过程中使用共享的Session是足够的，即使是工作在多个用户邮箱的模式下也不例外。
B．Message
当我们建立了Session对象后，便可以构造被发送的信息体了。在这里SUN提供了Message类型来帮助开发者完成这项工作。由于Message是一个抽象类，大多数情况下，我们使用 javax.mail.internet.MimeMessage这个子类，该类是使用MIME类型、MIME信息头的邮箱信息。信息头只能使用US- ASCII字符，而非ASCII字符将通过编码转换为ASCII的方式使用。
为了建立一个MimeMessage对象，我们必须将Session对象作为MimeMessage构造方法的参数传入：
1 MimeMessage message = new MimeMessage(session); 注意：对于MimeMessage类来讲存在着多种构造方法，比如使用输入流作为参数的构造方法。
在建立了MimeMessage对象后，我们需要设置它的各个part，对于MimeMessage类来说，这些part就是MimePart接口。最基本的设置信息内容的方法就是通过表示信息内容和米么类型的参数调用setContent()方法：
1 message.setContent(“Hello”, “text/plain”); 然而，如果我们所使用的MimeMessage中信息内容是文本的话，我们便可以直接使用setText()方法来方便的设置文本内容：
1 message.setText(“Hello”); 前面所讲的两种方法，对于文本信息，后者更为合适。而对于其它的一些信息类型，比如HTML信息，则要使用前者。 别忘记了，使用setSubject()方法对邮件设置邮件主题：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b882fc419cd1c645d0eb490d0e2de89b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a5cbca51e45739a0c685d989211e31f/" rel="bookmark">
			关于IRET指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 当使用IRET指令返回到相同保护级别的任务时，IRET会从堆栈弹出代码段选择子及指令指针分别到CS与IP寄存器，并弹出标志寄存器内容到EFLAGS寄存器。 当使用IRET指令返回到一个不同的保护级别时，IRET不仅会从堆栈弹出以上内容，还会弹出堆栈段选择子及堆栈指针分别到SS与SP寄存器。 IA-32指令手册关于这一点描述的很清楚，原文如下： the IRET instruction pops the return instruction pointer, return code segment selector, and EFLAGS image from the stack to the EIP, CS, and EFLAGS registers, respectively, and then resumes execution of the interrupted program or procedure. If the return is to another privilege level, the IRET instruction also pops the stack pointer and SS from the stack, before resuming program execution. 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0939f26626e202f9efdd7ba68241ead/" rel="bookmark">
			Objective-C 编程语言(7)关联
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载请标明出处： http://blog.csdn.net/zhangxingping 关联 关联是指把两个对象相互关联起来，使得其中的一个对象作为另外一个对象的一部分。 关联特性只有在Mac OS X V10.6以及以后的版本上才是可用的。 在类的定义之外为类增加额外的存储空间 使用关联，我们可以不用修改类的定义而为其对象增加存储空间。这在我们无法访问到类的源码的时候或者是考虑到二进制兼容性的时候是非常有用。 关联是基于关键字的，因此，我们可以为任何对象增加任意多的关联，每个都使用不同的关键字即可。关联是可以保证被关联的对象在关联对象的整个生命周期都是可用的（在垃圾自动回收环境下也不会导致资源不可回收）。 创建关联 创建关联要使用到Objective-C的运行时函数：objc_setAssociatedObject来把一个对象与另外一个对象进行关联。该函数需要四个参数：源对象，关键字，关联的对象和一个关联策略。当然，此处的关键字和关联策略是需要进一步讨论的。 ■ 关键字是一个void类型的指针。每一个关联的关键字必须是唯一的。通常都是会采用静态变量来作为关键字。 ■ 关联策略表明了相关的对象是通过赋值，保留引用还是复制的方式进行关联的；还有这种关联是原子的还是非原子的。这里的关联策略和声明属性时的很类似。这种关联策略是通过使用预先定义好的常量来表示的。 下面的代码展示了如何把一个字符串关联到一个数组上。 列表7-1 把一个字符串关联到一个数组 static char overviewKey; NSArray * array =[[NSArray alloc] initWidthObjects:@"One", @"Two", @"Three", nil]; //为了演示的目的，这里使用initWithFormat:来确保字符串可以被销毁 NSString * overview = [[NSString alloc] initWithFormat:@"@",@"First three numbers"]; objc_setAssociatedObject(array, &amp;overviewKey, overview, OBJC_ASSOCIATION_RETAIN); [overview release]; //(1) overview仍然是可用的 [array release]; //(2)overview 不可用 在（1）处，字符串overview仍然是可用的，这是因为OBJC_ASSOCIATION_RETAIN策略指明了数组要保有相关的对象。当数组array被销毁的时候，也就是在（2）处overview也就会被释放，因此而被销毁。如果此时还想使用overview，例如想通过log来输出overview的值，则会出现运行时异常。 获取相关联的对象 获取相关联的对象时使用Objective-C函数objc_getAssociatedObject。接着上面列表7-1的代码，我们可以使用如下代码来获取与array相关联的字符串： NSString * associatedObject = (NSString *)objc_getAssociatedObject(array, &amp;oveviewKey); 断开关联 断开关联是使用objc_setAssociatedObject函数，传入nil值即可。 接着列表7-1中的程序，我们可以使用如下的代码来断开字符串overview和arry之间的关联： objc_setAssociatedObject(array, &amp;overviewKey, nil, OBJC_ASSOCIATION_ASSIGN); 其中，被关联的对象为nil，此时关联策略也就无关紧要了。 使用函数objc_removeAssociatedObjects可以断开所有关联。通常情况下不建议使用这个函数，因为他会断开所有关联。只有在需要把对象恢复到“原始状态”的时候才会使用这个函数。 一个完整的实例程序 下面的程序综合了前面的代码.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0939f26626e202f9efdd7ba68241ead/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61f7986e744b7adce0343360f9106286/" rel="bookmark">
			VC&#43;&#43;中cl.exe编译器的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自百度博客： http://hi.baidu.com/lingyin55/blog/item/1545ddd08e421895a0ec9cdb.html 和在IDE中编译相比，命令行模式编译速度更快，并可以避免被IDE产生的一些附加信息所干扰。本文将介绍微软C/C++编译器命令行模式设定和用法。 1、设置环境变量： PATH=C:\Program Files\Microsoft Visual Studio 8\VC\bin INCLUDE=C:\Program Files\Microsoft Visual Studio 8\VC\include LIB=C:\Program Files\Microsoft Visual Studio 8\VC\lib 如果提示找不到mspdb80.dll文件，则从C:\Program Files\Microsoft Visual Studio 8\Common7\IDE下拷贝“msobj80.dll,mspdb80.dll,mspdbcore.dll,mspdbsrv.exe”这四个文件到C:\Program Files\Microsoft Visual Studio 8\VC\bin下即可。
2、命令选项： 1) /C:在预处理输出中保留注释语句 2) /c:只编译，不连接，相当于在"Build"菜单下选择了"Compile" 3) /D:定义常量和宏，与源程序里的#define 有相同效果 4) /E:预处理C、C＋＋源文件，将源文件中所有的预编译指令及宏展开，将注释去掉，然后将预处理器的输出拷贝至标准输出设备输出，并且在每个文件的开头和末尾加入#line 5) /EH:指定编译器用何种异常处理模型 6) /EP:同/E,只是去掉了#line 7) /F:设置程序的堆栈大小 8) /FA:设置生成何种列表文件（汇编、汇编与机器码、汇编与源码、汇编与机器码以及源码） 9) /Fa:指定用/FA设置的列表文件的存放路径及（或）文件名 10) /FD:生成文件的相互依赖信息 11) /Fd:设置程序数据库文件（PDB）的存放路径及（或）文件名 12) /Fe:设置最终可执行文件的存放路径及（或）文件名 13) /FI:预处理指定的头文件，与源文件中的＃include有相同效果 14) /Fm:创建map文件 15) /Fo:设置编译后Obj文件的存放路径及（或）文件名 16) /Fp:设置预编译文件（pch）的存放路径及（或）文件名 17) /FR:生成浏览信息（sbr）文件 18) /Fr:同/FR,不同之处在于/Fr不包括局部变量信息 19) /G3:为80386处理器优化代码生成 20) /G4:为80486处理器优化代码生成 21) /G5:为Pentium处理器优化代码生成 22) /G6:为Pentium Pro处理器优化代码生成 23) /GA:为Windows应用程序作优化 24) /GB:为Pentium处理器优化代码生成，使用80386、80486、Pentium、Pentium Pro的混合指令集，是代码生成的默认选项（程序属性选项中Processor对应Blend） 25) /GD:为Windows动态库（dll）作优化，此开关在VC6中没有实现 26) /Gd:指定使用__cdecl的函数调用规则 27) /Ge:激活堆栈检测 28) /GF:消除程序中的重复的字符串，并将她放到只读的缓冲区中 29) /Gf:消除程序中的重复字符串 30) /Gh:在每个函数的开头调用钩子（hook）函数--penter 31) /Gi:允许渐进编译 32) /Gm:允许最小化rebuild 33) /GR:允许运行时类型信息(Run-Time Type Infomation) 34) /Gr:指定使用__fastcall的函数调用规则 35) /Gs:控制堆栈检测所用内存大小 36) /GT:支持用__declspec(thread)分配的数据的fier-safety 37) /GX:允许同步异常处理，与/EHsc开关等价 38) /Gy:允许编译器将每一个函数封装成COMDATs的形式，供连接器调用 39) /GZ:允许在Debug build 的时候捕捉Release build的错误 40) /Gz:指定使用__stdcall的函数调用规则 41) /H:限制外部名字的长度 42) /HELP:列出编译器的所有的命令开关 43) /I:指定头文件的搜索路径 44) /J:将char的缺省类型从signed char改成unsigned char 45) /LD:创建一个动态连接库 46) /LDd:创建一个Debug版本的动态链接库 47) /link:将指定的选项传给连接器 48) /MD:选择多线程、DLL版本的C Run－Time库 49) /MDd:选择多线程、DLL、Debug版本的C Run－Time库 50) /ML:选择单线程版本的C Run—Time库 51) /MLd:选择单线程、Debug版本的C Run—Time库 52) /MT:选择多线程版本的C Run-Time库 53) /MTd:选择多线程、Debug版本的C Run—Time库 54) /nologo:不显示程序的版权信息 55) /O1:优化使产生的可执行代码最小 56) /O2:优化使产生的可执行代码速度最快 57) /Oa:指示编译器程序里没有使用别名，可以提高程序的执行速度 58) /Ob:控制内联（inline）函数的展开 59) /Od:禁止代码优化 60) /Og:使用全局优化 61) /Oi:用内部函数去代替程序里的函数调用，可以使程序运行的更快，但程序的长度变长 62) /Op:提高浮点数比较运算的一致性 63) /Os:产生尽可能小的可执行代码 64) /Ot:产生尽可能块的可执行代码 65) /Ow:指示编译器在函数体内部没有使用别名 66) /Ox:组合了几个优化开关，达到尽可能多的优化 67) /Oy:阻止调用堆栈里创建帧指针 68) /Q1f:对核心级的设备驱动程序生成单独的调试信息 69) /QI0f:对Pentium 0x0f错误指令作修正 70) /Qifdiv:对Pentium FDIV错误指令作修正 71) /P:将预处理输出写到指定文件里，文件的后缀名为I 72) /TC:将命令行上的所有文件都当作C源程序编译，不管后缀名是否为.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61f7986e744b7adce0343360f9106286/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5edb933fc33471f431b31b8a07e86d6e/" rel="bookmark">
			程序员必备的七大面向对象设计原则（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		五、接口隔离原则 1. 定义
i. 客户端不应该依赖那些它不需要的接口。
ii. 一旦一个接口太大，则需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。
2.分析
i. 接口隔离原则是指使用多个专门的接口，而不使用单一的总接口。每一个接口应该承担一种相对独立的角色，不多不少，不干不该干的事，该干的事都要干。
ii. 使用接口隔离原则拆分接口时，首先必须满足单一职责原则，将一组相关的操作定义在一个接口中，且在满足高内聚的前提下，接口中的方法越少越好。
iii. 可以在进行系统设计时采用定制服务的方式，即为不同的客户端提供宽窄不同的接口，只提供用户需要的行为，而隐藏用户不需要的行为
3.实例
i. 下图展示了一个拥有多个客户类的系统，在系统中定义了一个巨大的接口（胖接口）AbstractService来服务所有的客户类。如图所示：
图（一）
图（二）
图（一）和图（二）分析：
图（一）为什么到图（二）哪？因为这样做既满足了接口隔离原则，又满足了单一原则，何乐而不为呢，但是也带来了很多的不便，类增多了。
总结：类应该完全依赖相应的专门的接口 六、合成复用原则 1.定义
i. 尽量使用对象组合，而不是继承来达到复用的目的。
2.分析
i. 合成复用原则就是指在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用其已有功能的目的。简言之：要尽量使用组合/聚合关系，少用继承。
ii. 在面向对象设计中，可以通过两种基本方法在不同的环境中复用已有的设计和实现，即通过组合/聚合关系或通过继承。
a) 继承复用：实现简单，易于扩展。破坏系统的封装性；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性；只能在有限的环境中使用。（“白箱”复用 ）
b) 组合/聚合复用：耦合度相对较低，选择性地调用成员对象的操作；可以在运行时动态进行。（“黑箱”复用 ） iii. 组合/聚合可以使系统更加灵活，类与类之间的耦合度降低，一个类的变化对其他类造成的影响相对较少，因此一般首选使用组合/聚合来实现复用；其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。
3. 实例
i. 某教学管理系统部分数据库访问类设计如图所示：
图（一）
图（二）
图（一）和图（二）分析：
图（一）为什么到图（二）哪？因为如果需要更换数据库连接方式，如原来采用JDBC连接数据库，现在采用数据库连接池连接，则需要修改DBUtil类源代码。如果StudentDAO采用JDBC连接，但是TeacherDAO采用连接池连接，则需要增加一个新的DBUtil类，并修改StudentDAO或TeacherDAO的源代码，使之继承新的数据库连接类，这将违背开闭原则，系统扩展性较差。
总结：类中应用，尽量使用对象组合而不是用继承来达到复用的目的。 七、迪米特法则 1. 定义
i. 每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。
2. 分析
i.迪米特法则就是指一个软件实体应当尽可能少的与其他实体发生相互作用。这样，当一个模块修改时，就会尽量少的影响其他的模块，扩展会相对容易，这是对软件实体之间通信的限制，它要求限制软件实体之间通信的宽度和深度。
ii. 狭义的迪米特法则：可以降低类之间的耦合，但是会在系统中增加大量的小方法并散落在系统的各个角落，它可以使一个系统的局部设计简化，因为每一个局部都不会和远距离的对象有直接的关联，但是也会造成系统的不同模块之间的通信效率降低，使得系统的不同模块之间不容易协调。
iii. 广义的迪米特法则：指对对象之间的信息流量、流向以及信息的影响的控制，主要是对信息隐藏的控制。信息的隐藏可以使各个子系统之间脱耦，从而允许它们独立地被开发、优化、使用和修改，同时可以促进软件的复用，由于每一个模块都不依赖于其他模块而存在，因此每一个模块都可以独立地在其他的地方使用。一个系统的规模越大，信息的隐藏就越重要，而信息隐藏的重要性也就越明显。
iv. 迪米特法则的主要用途在于控制信息的过载。
1.在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及
2.在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限
3.在类的设计上，只要有可能，一个类型应当设计成不变类
4.在对其他类的引用上，一个对象对其他对象的引用应当降到最低。
3. 实例
i.某系统界面类(如Form1、Form2等类)与数据访问类(如DAO1、DAO2等类)之间的调用关系较为复杂。如图所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5edb933fc33471f431b31b8a07e86d6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/702847b3739d5a45e8b1d965d51a23fe/" rel="bookmark">
			有关BGP协议的13条选路规则，一些总结和看法 [收藏]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		via 卢琪的博客 对于一个NE来说，BGP协议是一门必修课，它是全球互联网的大框架。而当BGP路由器从多个途径获取路有时候，却有一套繁琐的选路过程。总共有13个步骤。而在文章的最后，我总结了一套比较快速的记忆方法。当然，我也在用，很容易就能记住这冗长的13条。
首先奉上原文（中英文对照），这些是网上摘录。
1.weight
prefer the path that has the largest weight
优先选择高权重值的路径
cisco私有属性
2.loacl preference if the routes have the same weight,use the route with the highest loacl preference. 具有相同权重值的，将选取最高优先级得路径
the loacl preference attribute only is local to the autonomous system and does not get passed to EBGP neighbor
本地优先属性只在本自治系统有效，不会传递给EBGP邻居
3.originated
if the routes have same local preference,prefer the route that was originated by BGP on this router.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/702847b3739d5a45e8b1d965d51a23fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e74a046dc379fe74a775d708c02e3f68/" rel="bookmark">
			osgi 学习系列（三）自定义osgi控制台命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了后面demo的结果显示需要先说下自定义osgi控制台命令,自定义命令的类必须实现org.eclipse.osgi.framework.console.CommandProvider接口
该接口中只有一个方法public String getHelp()用于在help方法中添加我们自定义命令的描述
自定义命令也很简单，只要写一个以下划线+命令的方法即可，比如我想自定义一个say命令
public void _say(CommandInterpreter ci) { ci.print("said:" + ci.nextArgument()); } 这个CommandInterpreter参数必须要，否则找不到命令，ci.nextArgument()获取osgi控制台命令后跟的参数
通过getHelp方法就可以把该自定义命令的描述加到osgi控制台help命令中
@Override public String getHelp() { return "\tsay – say what you input\n"; } 下面建个bundle来演示一下
New--&gt;Plug-inProject
Finish完成
打开MANIFEST.MF文件，导入org.eclipse.osgi.framework.console和org.osgi.framework包 创建一个类并实现CommandProvider和BundleActivator接口
类代码如下
public class CustomizedCommand implements CommandProvider, BundleActivator { @Override public void start(BundleContext context) throws Exception { context.registerService(CommandProvider.class.getName(), new CustomizedCommand(), null); } @Override public void stop(BundleContext arg0) throws Exception { } public void _say(CommandInterpreter ci) { ci.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e74a046dc379fe74a775d708c02e3f68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/881dbb74a0e150d4ac01218398c47efa/" rel="bookmark">
			Xlib Programming Manual
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近看了王垠写的那篇清华退学的文章，看到了他研究linux的过程，文中提到了x Windows, 我也总想搞一搞这个东西，但是不知从何入手。它推荐这本书Xlib Programming Manual，网上找了本电子书，准备研读一下!
看了他写的文章，我也觉得深有感触，我对于中国的教育也是抱有这样的一种认识的态度，但是我自认为不是一个很牛叉的人物。
中国教育虽然这样那样的不好，但是我却从这样的教育中也学到了不少的东西。
上学只是学习东西的一种方法，我们怎样学习一生，并用学到的东西，为自己，为社会做出贡献，我觉得才是最为重要，也是最难的。
学习从来就是为实践而准备的，必须要实践!!!
2012.5.24
1. 每个窗口有四个widnows configuration: position,width,height, stacking order(这个用来控制当某个窗口有多个子窗口时，哪个应该被显示）
2. 每个窗口用一个ID来标识
3. A windows's border. it can vary in width; zero makes the border invisible
4. a window has a set of attributes. The window attributes control many aspects of the appearance and response of the
window:
• What color or pattern is used for the border and background of the window?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/881dbb74a0e150d4ac01218398c47efa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cc0285e09829faf3478284d0da21ad4/" rel="bookmark">
			java.lang.NoClassDefFoundError: org/apache/commons/dbutils/DbUtils
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用dbutils连接的时候出现这个问题
HTTP Status 500 - type Exception report message description The server encountered an internal error () that prevented it from fulfilling this request. exception javax.servlet.ServletException: Servlet execution threw an exception root cause java.lang.NoClassDefFoundError: org/apache/commons/dbutils/QueryRunner com.xxx.blog.BlogServlet.doPost(BlogServlet.java:65) javax.servlet.http.HttpServlet.service(HttpServlet.java:637) javax.servlet.http.HttpServlet.service(HttpServlet.java:717) root cause java.lang.ClassNotFoundException: org.apache.commons.dbutils.QueryRunner org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1680) org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1526) java.lang.ClassLoader.loadClassInternal(ClassLoader.java:320) com.afoa.blog.BlogServlet.doPost(BlogServlet.java:65) javax.servlet.http.HttpServlet.service(HttpServlet.java:637) javax.servlet.http.HttpServlet.service(HttpServlet.java:717) note The full stack trace of the root cause is available in the Apache Tomcat/6.0.32 logs 一般都是因为项目中导入了dbutils的包，但是tomcat6.0的lib中没有导入dbutils的包引起的。注意tomcat需要重启一下的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f5af84517856bef80b71e58dc9c087d/" rel="bookmark">
			多线程执行完后主程序再执行（包括需要子线程返回结果）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.这是中间变量c，a线程向容器中添加数据，b线程执行其他，在主线程判断c是否为空
//判断是否读取完毕
while(true){
if(ShareData.isFinish()) {
break ;
}
}
注：此方法，需要知道a线程执行的速度与c线程执行的速度快慢，必须是a的速度大于b的速度
2.使用线程阻塞方法join
public static void main(String[] args) throws InterruptedException{
TestMain tm = new TestMain();
Thread t = new Thread(tm);
t.start();
t.join();
System.out.println("main");
}
注：此方法只能感知一个线程的过程不能判断多个线程的情况
3.利用CountDownLatch
//------主线程
int threadNum = 5; //线程数
//定义正在运行的线程数
CountDownLatch runningThreadNum = new CountDownLatch(threadNum);
System.out.println(Thread.currentThread().getName()+"-start");
//创建多个子线程
for (int i = 0; i &lt; threadNum; i++) {
new SubThread(runningThreadNum).start();
}
//等待子线程都执行完了再执行主线程剩下的动作
runningThreadNum.await();
//------子线程
public class SubThread extends Thread{
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f5af84517856bef80b71e58dc9c087d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de38bbfb7df0a0fb86e4755b51b991fe/" rel="bookmark">
			连接数据库时出现java.lang.ClassNotFoundException: com.mysql.jdbc.Driver怎么修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		确认包已经被导入web工程目录。
原来是tomcat找不到MYSQL JAR包的问题。后来又把mysql-connector-java-5.1.7-bin.jar导入到tomcat的lib目录下面就ok了，嘿……
在java项目中，只需要引入mysql-connector-java-5.1.7-bin.jar就可以运行java项目。
在web项目中，当Class.forName("om.mysql.jdbc.Driver");时myeclipse是不会去查找字符串，不会去查找驱动的。所以只需要把mysql-connector-java-5.1.7-bin.jar拷贝到tomcat下lib目录就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/481cfb9d8db57051448a04cb9f6ea4eb/" rel="bookmark">
			oracle下字段拆分，字段合并的一种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在数据库处理中，我遇到了设计很让人蛋疼的表。
此表处理一对多关系的方式是：将一个主键对应的多个值用逗号分割，然后存放在一个字段中。
于是，我在表中遇到了类似这样的数据：
表A：
id val1kate,jam,lucy,tracy2jim,lily,tom3tim 现在，我要将val字段的值进行拆分处理，一般的方法是函数或存储过程，这里给出一个SQL语句的处理方式。
语句如下：
with temp0 as (select LEVEL lv from dual CONNECT BY LEVEL &lt;= 100) select id,substr(t.vals,instr(t.vals, ',', 1, tv.lv) + 1, instr(t.vals, ',', 1, tv.lv + 1) -( instr(t.vals, ',', 1, tv.lv) + 1) ) AS val from (select id,',' || val || ',' AS vals, length(val || ',') - nvl(length(REPLACE(val, ',')), 0) AS cnt from a) t join temp0 tv on tv.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/481cfb9d8db57051448a04cb9f6ea4eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/458cd9969bb365e6ef2f1b0962f5893b/" rel="bookmark">
			full join 太费时间了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求：将表 A,B,C 合并到一个结果集中
表A如图：
N	D 1	eeee 3	dddd 5	cccc 7	bbbb 9	aaaa 11	dddd 13	eeee 15	wwww 17	qqqq 19	tttttt 表B如图：
N	E 5	rrrrrr 4	fffff 3	ssssss 2	jjjjjj 1	kkkkkk 7	uuuuuu 表C如图：
N	F 5	oooo 4	lllll 3	hhss 2	ddfj 1	kdsfkkk 7	sduuu 8	ewrtwy 12	sdgfsd 22	dfgee 要得到的结果集如图：
N	D	E	F 1	eeee	kkkkkk	kdsfkkk 22	dfgee 11	dddd	13	eeee	2	jjjjjj	ddfj 5	cccc	rrrrrr	oooo 4	fffff	lllll 17	qqqq	8	ewrtwy 3	dddd	ssssss	hhss 7	bbbb	uuuuuu	sduuu 9	aaaa	15	wwww	19	tttttt	12	sdgfsd 两种思路：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/458cd9969bb365e6ef2f1b0962f5893b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a4e368345839397797c5d45fe8f9e76/" rel="bookmark">
			Win7系统IIS7&#43;Tomcat7集成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Win7系统IIS7+Tomcat7集成
IIS是Internet Information Services（互联网信息服务）的缩写，是由微软公司提供的基于运行Microsoft Windows的互P联网基本服务，是微软在Windows中内置的Web服务器软件。通过IIS和Tomcat的集成可以让Tomcat处理JSP，IIS处理ASP和Html静态页面。
一、安装tomcat
我所用的Tomcat是最新版的7.0.27直接安装版，安装的位置是D:\Program Files\Tomcat7，记住这个路径会多次用到，注意在Tomcat之前一定要安装JDK，这里我用的是jdk1.7.
二、配置IIS
进入Win7的控制面板，打开程序功能，点击选择打开或关闭Windows功能
在Windows功能的选项菜单，把internet信息服务的所有的组件全部勾起来。
注意：安装完成后IIS的地址是http://localhost和tomcat的地址http://localhost:8080看看出没出现默认画面。
三、集成Tomcat
1、连接器jk
在tomcat的bin目录下新建目录jk\，把下载的isapi_redirect.dll（连接器，可从网上下载http://mirror.bit.edu.cn/apache//tomcat/tomcat-connectors/jk/binaries/windows/，我使用的是目前的最新版1.2.35），拷贝到这个目录下。
2、在tomcat的conf目录下创建两个文件workers.properties，uriworkermap.properties
Workers.properties文件的内容：
workers.tomcat_home=D:\Program Files\Tomcat7 workers.java_home=D:\Program Files\Java\jdk1.7 ps=\ worker.list=worker1 worker.worker1.port=8009 worker.worker1.host=localhost worker.worker1.type=ajp13 worker.worker1.lbfactor=1 uriworkermap.properties文件的内容（注意：这个文件说明了符合哪些条件的uri才能被转发到tomcat中，可能的设置有）
/*=worker1 /*.jsp=worker1 /jsp-example/*=worker1 !/*.gif=worker1 3、导入注册表文件tomcat.reg
任意的在哪里建一个文本文档，命名为tomcat.reg，内容如下：
Windows Registry Editor Version 5.00 [HKEY_LOCAL_MACHINE\SOFTWARE\Apache Software Foundation\Jakarta Isapi Redirector\1.0] "extension_uri"="/jakarta/isapi_redirect.dll" "log_file"="D:\\Program Files\\Tomcat7\\logs\\isapi.log" "worker_file"="D:\\Program Files\\Tomcat7\\conf\\workers.properties" "worker_mount_file"="D:\\Program Files\\Tomcat7\\conf\\uriworkermap.properties" "log.level"="realease" 双击运行这个文件导入到注册表中：
4、建立网站的虚拟目录
打开你的Internet信息服务管理器，进入管理页面，展开左边的连接栏，选择你的一个网站，这里我的网站名是tomcat,主目录是e:\tomcat，鼠标单击右键添加虚拟目录，打开虚拟目录对话框。
别名处写上jakarta，其中jakarta是一个规定名字，必须这么创建，这个虚拟目录要指向isapi_redirect.dll的所在目录，并且设置为可执行IsApi.
5、添加筛选器
选中自己的网站，选择ISAPI筛选器，如图所示：
在出现的框中，单击鼠标右键，单击添加选项，出现添加ISAPI筛选器对话框，在名称处中输入jakarta，并选择连接器的路径，如下图所示：
6、添加脚本映射
单击“程序处理映射”选项，在打开的对话框中鼠标右键单击“添加脚本映射”选项，在打开的对话框中，按下图的配置进行输入：
在弹出的对话框中单击是按钮。
之后选择jakarta这项，单击鼠标右键选择编辑功能权限选项，如下图所示全部选中。至此所有的配置完毕。
在浏览器中输入“http://localhost”，在IE中有时如果不加HTTP的化可能会出现错误，这样(不加8080)访问IIS的服务器，可以看到网页显示的是tomcat的默认主页，说明IIS已经指向了tomcat，为了能更好的服务最好将两个服务器指向同一个的Web的目录,这样的IIS就支持jsp了，完成之后重新启动。
在tomcat的配置文件server.xml文件中添加以下这句话可以更改tomcat的默认目录：
&lt;Context path=”” docBase=”e:\tomcat”(此处为你的网站根目录，通过这句话的映射，可以将原先的默认更改为新的目录) debug=”0”/&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a4e368345839397797c5d45fe8f9e76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c73bddc191eb55c48260d8295ac12ae8/" rel="bookmark">
			Android和iOS人才招聘出现拐点 低能人才泛滥
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		去年的疯狂抢人变成了今年的裁员甚至关门歇业，漫天要价变成了工作难找，移动互联网市场正回归理性
工作不好找了。
“去年这个时候，一个刚毕业的Android开发工程师，就能轻松拿到七八千一个月，而今年，很难找到工作了。”从事移动互联网猎头招聘业务的移联网创始人田克山告诉记者，最近移动互联网从业人员薪资出现下降的趋势，以Android开发人才最为明显。
提起去年争抢人才的疯狂景象，许多人依旧历历在目：不仅腾讯、百度、盛大等巨头疯狂地囤积人才，大批大大小小的互联网公司也四处网罗移动互联网客户端开发人才，而融到资的中小创业团队更是疯狂地扩张，那时，许多甚至刚毕业、没有任何工作经验的移动开发人才也能拿到很高的薪水。
种种迹象表明，经历了去年的疯狂，今年整个移动互联网的创业和投资已经明显开始降温，而记者调查发现，作为行业景气的先行指标，今年移动互联网的人才荒已经得到有效缓解，泡沫开始被挤掉，整个行业重新回归理性。
大公司招人放缓
记者了解到，今年许多大公司停止招人，是导致移动互联网人才薪资价格出现下降的重要原因。今年以来，腾讯、阿里巴巴、盛大、百度等许多互联网巨头都开始暂缓招人甚至停止招人。
承担众多移动互联网项目孵化功能的盛大创新院从去年底开始大规模裁员。知情人士向记者透露，共有数百人被裁掉，这些人都投入了重新找工作的大军中。
“盛大当时疯狂招人的时候，电话中面试，电话中就给offer了。”一位猎头向记者回忆起盛大创新院扩张时的疯狂，当时盛大曾经对这些项目寄予厚望。在这一拨裁员浪潮中，大批项目被砍掉。如今盛大创新院已经只剩下麦库、通通、微酷等少数几个项目了。
盛大旗下共有切客、有你、麦库记事、词库英语、微酷等大批移动应用，此前，盛大曾经在这些项目上投入了巨资。实际上，大部分项目所产生的实际营收并无预期的那么高。例如盛大投入大批资源推广的切客优惠，在苹果App Store 中的排名一直徘徊在300到400名之间，在激烈的市场竞争中，获取用户的成本却不断上升。
在不久之前，盛大无线完成MBO，正式脱离盛大体系。这标志着盛大又剥离掉了相当一批无线业务。
“盛大出来的人在市场上并不受欢迎，许多公司都表示不愿意招盛大的人。”某猎头告诉记者，这是因为盛大在过去几年的高速扩张期囤积了不少人，许多人的能力并没有真正得到市场认可，但期望值却很高，要求的薪资往往与市场能够给出的价位有一定落差。
除此之外，第九城市也于近日宣布大批裁员。有传言称，第九城市的无线部门是裁员的重点领域，但第九城市向记者否认了这种说法。
除了这些裁员的公司，腾讯、阿里巴巴、百度等公司的无线部门也开始停止招人或者很少招人。例如阿里巴巴，在私有化全部完成前冻结了大多数招聘岗位，这使得许多做阿里巴巴生意的猎头都无事可做。
许多传统互联网公司在移动互联网领域的布局心态也开始变得谨慎——往往是意识到移动互联网是趋势，或者看到竞争对手推出了移动客户端，自己也抢着推一个，但是大多数公司没有想好自己的移动业务到底向什么方向发展。
“去年大家以为移动互联网很简单，先做一个App挂上去再说。但不知道背后的运营挺烧钱。”从事手机软件外包业务的摩博科技总经理熊军告诉记者：“现在大家会算一下成本，意识到需要蛮大的投入的，重新认识到不是想象的门槛那么低。”
因此这些仅处于布局阶段的公司往往仅仅招少数几个人手，负责移动客户端的开发和维护，不会选择大规模地招人。
投资退烧
大公司开始减少招人，今年中小创业公司对人才的需求也开始出现大幅降低。大批中小团队的倒掉降低了市场需求。
就在一年以前，移动互联网领域被描述成“几个刚毕业不久的大学生，自己找一间民房开发几个月，就有可能开发出一款如愤怒的小鸟那样火爆的产品赚钱”，于是在短期内，大批中小创业者怀揣着创业梦想涌入这一领域。
整个2012年，几乎没有几款让市场眼前一亮的移动应用出来，大部分创业者的处境开始变得糟糕起来。
游戏和广告被视为目前支撑中国移动(微博)互联网营收的最主要两个来源。根据艾瑞咨询的数据，2012年第一季度，中国手机广告的规模大约为11亿元，而手机游戏的规模大约为10亿元——整个移动互联网的实际营收很小。
但数以百万计的移动互联网从业者想分食这个小小的蛋糕，虽然这一市场仍然在高速成长，但对于大多数创业团队来说，如果再没有资金进来，团队就可能随时死掉，必须尽快找到投资者的钱，以支撑自己挺过当前的难关。
一些难以获得稳定收入的创业团队，开始被迫接其它公司的移动应用外包订单来养活自己，而更多的创业团队直接关门歇业。
按照清科的统计，今年一季度仅有一只美元基金完成募资——而TMT领域的融资大部分都是美元，融资情况可谓“一落千丈”。
由于IPO节奏放缓，VC退出渠道明显收窄，同时境内市场上市企业平均发行市盈率整体下滑使得VC收益水平面临考验，从而严重影响了投资者信心。
具体到移动互联网领域，按照清科的统计，今年一季度仅有6起移动互联网领域的PE、VC类投资，总投资金额是2493万美金，相比起去年同期的14起投资，出现大幅下降。
清科分析师张亚男表示，2011年其实是移动互联网投资比较热的一年，大批创业团队拿到融资，很像2010年电子商务的火热行情，但今年以来这一领域的融资明显下降。
她认为，导致最近移动互联网投资趋缓是因为大部分移动客户端产品盈利困难，并没有之前预想的那么乐观。此外，腾讯等大型互联网企业开始发力，导致中小团队的生存空间有限。
事实上，移动互联网的第一轮投资高峰被认为已经过去。以手机应用商店、移动广告平台、手机ROM厂商为代表的平台类公司，以及数字顽石、上海海湃为代表的手机游戏企业大都完成融资，市场已经开始洗牌，后续进入者已经比较难获得融资。
专业帮天使投资者和创业者对接的平台“天使汇”总监李超告诉记者，今年一季度移动互联网领域投出去的天使项目开始变少，大部分投资人的感受是“想投但没有什么项目可投”。
他告诉记者，部分天使投资人甚至开始“海撒”，每个案子仅投资5万、10万的小金额，有的投资人甚至都不看项目的资质，比如某个创业项目获得某个创业大赛的奖项，就直接投资一小笔钱进去，这背后反映的整个行业仍然较缺乏优质的项目。
挤挤更健康
事实上，移动互联网的泡沫被挤掉一些，被认为有利行业发展。
诸多移动互联网公司的创业者均向记者反映，去年那样疯狂的人才价格上涨行情，让大家都开始吃不消了。
以拥有2000人规模的手机软件外包厂商南京诚迈为例，要培养一个合格的开发人才相当不容易，在去年的行情下几乎每个季度都不得不上调员工薪资，每个员工招进来还须支付一笔不小的培训费用，花费好几个月的时间才能培训合格。但由于整个行业过于火爆，诚迈经常担心员工被其它公司挖走。
诚迈科技CEO王继平告诉记者，去年由于团购、电子商务等公司拼命地招人，导致整个行业招人很困难，技术开发人员的价格被抬得很高。“今年人要明显好招一些了。”王继平表示，行业回归理性有利于企业稳定发展业务。
“去年移动互联网企业的人员流动很频繁。”移联网的田克山说，在大公司里面工作的人常常想出来创业，而在小团队里面干得好的人则随时可能被外面的公司高薪挖走，整个行业的氛围非常浮躁。
“我认为人才价格降下来是好事情。”天使投资人王利杰表示。去年许多拿到融资的企业拼命囤积人才，再加上腾讯、百度等巨头杀入，导致整个行业的薪资上涨过快，让许多小团队都吃不消。
王利杰表示，许多中小型创业团队仍然缺人，而且小公司的薪水也不可能给到很高，因此人才价格下降有利于行业健康发展，让更多中小团队有更多的机会。
记者了解到，尽管整个行业的情况开始趋冷，但是有工作经验的高端人才仍然非常稀缺，其价格仍然看涨。
例如负责开发苹果iOS系统应用的开发人才价格仍然在上涨，目前iOS开发人才的价格要远远高于Android开发人才。例如腾讯在上海招聘的iPhone高级研发工程师，有3年工作经验者年薪能达到35万，远远高于Android的开发人才。
这是因为大多数公司在进军移动互联网时都将较为高端的iOS平台作为首选，多数会首先开发iOS版本。此外，苹果营造的生态系统让应用开发者们能够在iOS上赚到较多的收入，即使是一些较小的团队，也多少有一笔收入让团队先活下来。此外，由于开发语言的关系， iOS的技术人才比较难像Android那样批量培养，市场供给较少。
相比之下，去年火爆的氛围带动大批培训机构开始批量培养Android开发人才。例如北大青鸟、海同培训机构等都培养了不少Android开发人才，而许多过去做java开发的人也开始转到Android开发上来。Android开发人才的供给出现大幅上升，这也是导致Android开发人才薪资下滑的重要原因。
“但企业对这些缺乏工作经验的人并不满意，往往招聘过来还需要培养一段时间。”田克山表示，真正有丰富开发经验的移动开发人才仍然很抢手。
今年下半年可能会成为移动互联网的重要分水岭，那些能产生营收活下来或者继续融到钱的团队，或许能获得更好的发展，但大批没有竞争力的中小型团队，很可能只能关门退出。
但从长远来看，移动互联网的前景依然非常看好。天使投资人王利杰表示，未来大多数行业都会移动互联网化，因此存在大批长远的投资机会，今年以来他已经完成了6笔天使投资，主要集中在垂直类O2O(从线上到线下)和移动电子商务领域，继游戏之后，移动互联网需要第二个爆发热点。
文章转自：http://www.d1zhiye.com/thread-611-1-1.html 转载于:https://www.cnblogs.com/d1zhiye/archive/2012/05/14/2498888.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c994e8f44c46fe8ef2dffe0dcb9617d/" rel="bookmark">
			JSP九大内置对象...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址:http://blog.sina.com.cn/s/blog_6267d71d0100pryr.html
JSP九大内置对象：
1.Request, 2.Response,3.Out,4.Session,5.Application,6.Config,7.Page,8.PageContext,9.Exception。
一、Request对象
该对象封装了用户提交的信息，通过调用该对象相应的方法可以获取封装的信息，即使用该对象可以获取用户提交的信息。
当Request对象获取客户提交的汉字字符时，会出现乱码问题，必须进行特殊处理。首先，将获取的字符串用ISO-8859－1进行编码，并将编码存发岛一个字节数组中，然后再将这个数组转化为字符串对象即可。如下：
StringtextContent=request.getParameter("boy");
byteb[]=textContent.getBytes("ISO-8859-1");
textContent=new String(b);
Request常用的方法：
1. getParameter(String strTextName)获取表单提交的信息。
StringstrName＝request.getParameter("name");
2. getProtocol() 获取客户使用的协议。
StringstrProtocol=request.getProtocol();
3. getServletPath() 获取客户提交信息的页面。
StringstrServlet=request.getServletPath();
4. getMethod()获取客户提交信息的方式，get|post。
String strMethod =request.getMethod();
5. getHeade()获取HTTP头文件中的accept、accept-encoding和Host的值。
String strHeader =request.getHeader("accept");
6. getRermoteAddr() 获取客户的IP地址。
String strIP =request.getRemoteAddr();
7. getRemoteHost() 获取客户机的名称。
String clientName =request.getRemoteHost();
8. getServerName() 获取服务器名称。
String serverName =request.getServerName();
9. getServerPort() 获取服务器的端口号。
int serverPort =request.getServerPort();
10. getParameterNames()获取客户端提交的所有参数的名字。
Enumeration enum =request.getParameterNames();
while(enum.hasMoreElements()){
Strings=(String)enum.nextElement();
out.println(s);
}
二、Response对象
对客户的请求做出动态的响应，向客户端发送数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c994e8f44c46fe8ef2dffe0dcb9617d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cbd07ab5b4761640fb073397b6ebea5/" rel="bookmark">
			SQL IF..ELSE..在存储过程的使用规范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来自: http://hi.baidu.com/%B5%AD%CB%AE%B5%AD%CB%AE/blog/item/bc4938b5a95ae4678ad4b266.html
分类：ＳＱＬ存储过程 (
@city nvarchar(20),
@town nvarchar(20),
@village nvarchar(20)
)
as
declare @num numeric(10)
declare @yd_num numeric(10)
declare @lt_num numeric(10)
declare @gh_num numeric(10)
declare @xlt_num numeric(10)
select @num=count(jmzh) from jfxd.t_gongan_end_2
if @city='aaa' begin
select @yd_num=count(jmzh) from jfxd.t_gongan_end_2 where SERIAL_NUMBER is notnull
select @lt_num=count(jmzh) from jfxd.t_gongan_end_2 where unicom is not null
select @gh_num=count(jmzh) from jfxd.t_gongan_end_2 where tel is not null
select @xlt_num=count(jmzh) from jfxd.t_gongan_end_2 where little_tel is notnull
end
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3cbd07ab5b4761640fb073397b6ebea5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b01d8f2b574c74e75e8d43f13690faf7/" rel="bookmark">
			接口设计与数据同步解决方案小结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接口设计方面：
在做项目过程中，对于一个Web平台性的系统来说，往往需要为其他程序开放系统接口，即是以自己做的系统为平台，允许第三方的程序接入。需要和第三方的程序数据打交道，需要第三方程序通过调用web平台接口来传递数据。
这样对于Web平台来说，开放给第三方程序的接口设计方面有些值得注意的地方：
将第三方传递过来的数据，最好不要直接与系统本身的数据一起处理。换句话说，最好将第三方传入的数据放到一张临时表里，系统通过定时任务去从临时表中将传入数据转换为系统数据。这样做的好处在于：
1.第三方传入数据不会因为接口调用的失败或异常而扰乱系统已有的数据；
2.对于接口调用方来说，减少了接口处理数据的复杂性，可以大大提高接口的调用成功率；
同步接口里的方法，建议将添加和修改统一为一个方法，通过传入系统主键来判断：有记录则更新，无记录则添加。
数据同步方面：
通过项目间的系统数据同步实战，总结出一个比较好的解决方案：
当两个系统间要做数据同步时，可以这样设计：比如系统A和系统B，当数据从系统A到系统B时，
1.系统A通过定时任务来调用系统B的接口；
2.系统B接受到系统A的请求后，处理请求，但可以不做任何接口回复；
3.系统A调用接口后，只要接口调用不出现异常，即可认为接口调用成功。也行您已经想到：这样对于系统A来说，接口调用后，无法收到任何回调信息，就无法确认数据是否被同步成功的。请接着看下一步。
4.系统B在下一定时任务启动时，将上一次接受到的数据对象返回给系统A；
5.系统A通过对返回对象信息进行判断，如果有记录则更新同步状态。这样的前提是，两个系统要相互保存两个系统的数据主键。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39d74e16e019a3be776df6af4ea2c34d/" rel="bookmark">
			java 反射知识总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		反射知识：
1.Class类：
获取一个Class类有三种方法：
Java代码 //第一种获取方法，直接了当 Class clazz1 = String.class; //第二种获取方法，对实体类运用方法 String str = "just do it"; Class clazz2 = str.getClass(); //第三种获取方法，直接传递一个类名，字符串形式 Class clazz3 = Class.forName("java.lang.String"); 2.Field类：
获取一个Filed字段类的，有四种方法：
Java代码 //1--&gt;获取所有申明的字段 Field[] fields1 = clazz1.getDeclaredFields(); //2--&gt;获取所有的公共类字段 Field[] fields2 = clazz1.getFields(); //3--&gt;获取指定字段名（所有申明的字段都可获取） Field field1 = clazz1.getDeclaredField("value"); //4--&gt;获取指定公共字段名 Field field2 = clazz1.getField("CASE_INSENSITIVE_ORDER"); 3.Method类：同Field有四种方法：
Java代码 Method[] methods1 = clazz1.getDeclaredMethods(); Method[] methods2 = clazz1.getMethods(); Method method1 = clazz1.getDeclaredMethod("checkBounds",new Class[]{byte[].class,int.class,int.class}); Method method2 = clazz2.getMethod("hashCode"); 如果方法中的无参数，则得到方法时，只需传一个方法名即可
4.Constructor类：同上有四种方法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39d74e16e019a3be776df6af4ea2c34d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5fae29b2e5592812655eaa5175af088/" rel="bookmark">
			文件下载 response.setHeader()下载中文文件名乱码问题 解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		response.setHeader()下载中文文件名乱码问题[转] 首先展示我的解决问题的代码: response.setHeader("Content-Disposition", "attachment; filename=" + java.net.URLEncoder.encode(fileName, "UTF-8")); 1. HTTP消息头 （1）通用信息头 即能用于请求消息中,也能用于响应信息中,但与被传输的实体内容没有关系的信息头,如Data,Pragma 主要: Cache-Control , Connection , Data , Pragma , Trailer , Transfer-Encoding , Upgrade （2）请求头 用于在请求消息中向服务器传递附加信息,主要包括客户机可以接受的数据类型,压缩方法,语言,以及客户计算机上保留的信息和发出该请求的超链接源地址等. 主要: Accept , Accept-Encoding , Accept-Language , Host , （3）响应头 用于在响应消息中向客户端传递附加信息,包括服务程序的名称,要求客户端进行认证的方式,请求的资源已移动到新地址等. 主要: Location , Server , WWW-Authenticate(认证头) （4）实体头 用做实体内容的元信息,描述了实体内容的属性,包括实体信息的类型,长度,压缩方法,最后一次修改的时间和数据的有效期等. 主要: Content-Encoding , Content-Language , Content-Length , Content-Location , Content-Type （4）扩展头 主要：Refresh, Content-Disposition 2. 几个主要头的作用 （1）Content-Type的作用 该实体头的作用是让服务器告诉浏览器它发送的数据属于什么文件类型。 例如：当Content-Type 的值设置为text/html和text/plain时,前者会让浏览器把接收到的实体内容以HTML格式解析,后者会让浏览器以普通文本解析. （2）Content-Disposition 的作用 当Content-Type 的类型为要下载的类型时 , 这个信息头会告诉浏览器这个文件的名字和类型。 在讲解这个内容时,张老师同时讲出了解决中文文件名乱码的解决方法,平常想的是使用getBytes() , 实际上应使用email的附件名编码方法对文件名进行编码,但IE不支持这种作法(其它浏览器支持) , 使用javax.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5fae29b2e5592812655eaa5175af088/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a11c6b3a8a4fdef6d1174193e5011a0/" rel="bookmark">
			UE中常用正则表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正则表达式 (UltraEdit Syntax):
% 匹配行首 - 表明要搜索的字符串一定在行首.
$ 匹配行尾 - 表明要搜索的字符串一定在行尾
? 匹配除换行符外的任一单个字符.
* 匹配任意个数的字符出现任意次数（不包括换行符）
+ 匹配前导字符或者表达式出现一次或者更多次（不包括换行符）
++ 匹配前导字符或者表达式不出现或者出现一次以上（不包括换行符）
^b 匹配页中断符
^p 匹配DOS文件的换行符
^r 匹配MAC文件的换行符(CR Only)
^n 匹配UNIX文件的换行符 (LF Only)
^t 匹配一个制表符
[ ] 匹配方括号中的单个的字符
查找所有的数字: [0-9]+[.]++[0-9]+
查找所有的单词: [a-z]+
查找所有的网址: http://[a-z0-9^~`_./^-^?=&amp;]+
查找所有的汉字: [^一-龥]，不过需要注意按照以下步骤操作：
1、查询后的汉字，如果乱码或者空白，另存为“UTF-16”格式的文本，再次查找就正常了。
2、选择Unix风格的正则表达式。方法：高级——配置——搜索——正则表达式，选中“Unix风格正则表达式”。
3、高级——设置代码页/本地，“系统中已安装的代码页”，选择“936（ANSI/OEM-简体中文GBK）”；“系统已安装的地区”选择"中文（中国）中国人们共和国"。
删除空行: 替换 %[ ^t]++^p 为 空串
删除行尾空格: 替换 [ ^t]+$ 为 空串
删除行首空格: 替换 %[ ^t]+ 为 空串
每行设置为固定的4个空格开头: 替换 %[ ^t]++^([~ ^t^p]^) 为 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a11c6b3a8a4fdef6d1174193e5011a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81a763ab7f98b7bba9cfc996dd2bbfdd/" rel="bookmark">
			wireshark中“tcp segment of a reassembled pdu”的解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自于http://blog.csdn.net/rossini23/article/details/5424850
“TCP segment of a reassembled PDU”指TCP层收到上层大块报文后分解成段后发出去。于是有个疑问，TCP层完全可以把大段报文丢给IP层，让IP层完成分段，为什么要在TCP层分呢？ 其实这个是由TCP的MSS(Maximum Segment Size，最大报文段长度)决定的，TCP在发起连接的第一个报文的TCP头里通过MSS这个可选项告知对方本端能够接收的最大报文（当然，这个大小是TCP净荷的大小），以太网上这个值一般设置成1460，因为1460Byte净荷+20Byte TCP头+20Byte IP头 ＝ 1500字节，正好符合链路层最大报文的要求。
至于收到一个报文后如何确定它是一个"TCP segment"？如果有几个报文的ACK序号都一样，并且这些报文的Sequence Number都不一样，并且后一个Sequence Number为前一个Sequence Number加上前一个报文大小再加上1的话，肯定是TCP segment了，对于没有ACK标志时，则无法判断。
另外有不太一样的说法，转自http://sabolasi.iteye.com/blog/1254131
MTU和MSS
本文用到的抓包工具为wireshark，它的前身是赫赫有名的Ethereal。wireshark以太网帧的封包格式为：
Frame = Ethernet Header + IP Header + TCP Header + TCP Segment Data
（1）Ethernet Header = 14 Byte = Dst Physical Address（6 Byte）+ Src Physical Address（6 Byte）+ Type（2 Byte），以太网帧头以下称之为数据帧。
（2）IP Header = 20 Byte（without options field），数据在IP层称为Datagram，分片称为Fragment。
（3）TCP Header = 20 Byte（without options field），数据在TCP层称为Stream，分段称为Segment（UDP中称为Message）。
（4）54个字节后为TCP数据负载部分（Data Portion），即应用层用户数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81a763ab7f98b7bba9cfc996dd2bbfdd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80445c18355026485230af1e88839864/" rel="bookmark">
			Oracle sqlplus不是内部或外部命令,也不是可运行的程序或批处理文件.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		重装oracle或删除oracle环境变量后,用DOS登入SQLPLUS时出现'sqlplus'不是内部或外部命令,也不是可运行的程序或批处理文件.
在系统变量path后面加上;E:\oracle\product\10.1.0\db_1\BIN
注意:
1.路径一定要正确
2.系统环境变量前一定要加;号
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecde3724ef470fddf88d158110bd8f32/" rel="bookmark">
			socket connect的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		非阻塞Connect对于select时应注意问题
对于面向连接的socket类型(SOCK_STREAM,SOCK_SEQPACKET)在读写数据之前必须建立连接，首先服务器端socket必须在一个客户端知道的地址进行监听,也就是创建socket之后必须调用bind绑定到一个指定的地址，然后调用int listen(int sockfd, int backlog);进行监听。此时服务器socket允许客户端进行连接，backlog提示没被accept的客户连接请求队列的大小，系统决定实际的值，最大值定义为SOMAXCONN在头文件&lt;sys/socket.h&gt;里面。如果某种原因导致服务器端进程未及时accpet客户连接而导致此队列满了的话则新的客户端连接请求被拒绝(在工作中遇到过此情况，IONA ORBIX(CORBA中间件)由于没有配置超时时间结果在WIFI网络中传输数据出现异常情况一直阻塞而无机会调用accept接受新的客户请求，于是最终队列满导致新的客户连接被拒绝)。
调用listen之后当有客户端连接到达的时候调用int accept(int sockfd, struct sockaddr *restrict addr, socklen_t *restrict len);接受客户端连接建立起连接返回用于连接数据传送的socket描述符，进行监听的socket可以用于继续监听客户端的连接请求，返回的socket描述符跟监听的socket类型一致。如果addr不为NULL,则客户端发起连接请求的socket地址信息会通过addr进行返回。如果监听的socket描述符为阻塞模式则accept一直会阻塞直到有客户发起连接请求，如果监听的socket描述符为非阻塞模式则如果当前没有可用的客户连接请求，则返回-1(errno设置为EAGAIN)。可以使用select函数对监听的socket描述符进行多路分离，如果有客户连接请求则select将监听的socket描述符设置为可读(注意，如果监听的socket为阻塞模式而使用select进行多路分离则可能造成select返回可读但是调用accept会被阻塞住的情况，原因是在调用accept之前客户端可能主动关闭连接或者发送RST异常关闭连接，因此select最好跟非阻塞socket搭配使用)。
客户端调用int connect(int sockfd, const struct sockaddr *addr, socklen_t len);发起对服务器的socket的连接请求，如果客户端socket描述符为阻塞模式则会一直阻塞到连接建立或者连接失败(注意阻塞模式的超时时间可能为75秒到几分钟之间)，而如果为非阻塞模式，则调用connect之后如果连接不能马上建立则返回-1(errno设置为EINPROGRESS，注意连接也可能马上建立成功比如连接本机的服务器进程),如果没有马上建立返回，此时TCP的三路握手动作在背后继续，而程序可以做其他的东西，然后调用select检测非阻塞connect是否完成(此时可以指定select的超时时间，这个超时时间可以设置为比connect的超时时间短)，如果select超时则关闭socket，然后可以尝试创建新的socket重新连接，如果select返回非阻塞socket描述符可写则表明连接建立成功，如果select返回非阻塞socket描述符既可读又可写则表明连接出错(注意：这儿必须跟另外一种连接正常的情况区分开来，就是连接建立好了之后，服务器端发送了数据给客户端，此时select同样会返回非阻塞socket描述符既可读又可写，这时可以通过以下方法区分:
1.调用getpeername获取对端的socket地址.如果getpeername返回ENOTCONN,表示连接建立失败,然后用SO_ERROR调用getsockopt得到套接口描述符上的待处理错误;
2.调用read,读取长度为0字节的数据.如果read调用失败,则表示连接建立失败,而且read返回的errno指明了连接失败的原因.如果连接建立成功,read应该返回0;
3.再调用一次connect.它应该失败,如果错误errno是EISCONN,就表示套接口已经建立,而且第一次连接是成功的;否则,连接就是失败的;
对于无连接的socket类型(SOCK_DGRAM)，客户端也可以调用connect进行连接,此连接实际上并不建立类似SOCK_STREAM的连接，而仅仅是在本地保存了对端的地址，这样后续的读写操作可以默认以连接的对端为操作对象。
当对端机器crash或者网络连接被断开(比如路由器不工作，网线断开等)，此时发送数据给对端然后读取本端socket会返回ETIMEDOUT或者EHOSTUNREACH 或者ENETUNREACH(后两个是中间路由器判断服务器主机不可达的情况)。
当对端机器crash之后又重新启动，然后客户端再向原来的连接发送数据，因为服务器端已经没有原来的连接信息，此时服务器端回送RST给客户端，此时客户端读本地端口返回ECONNRESET错误。
当服务器所在的进程正常或者异常关闭时，会对所有打开的文件描述符进行close，因此对于连接的socket描述符则会向对端发送FIN分节进行正常关闭流程。对端在收到FIN之后端口变得可读，此时读取端口会返回0表示到了文件结尾(对端不会再发送数据)。　当一端收到RST导致读取socket返回ECONNRESET，此时如果再次调用write发送数据给对端则触发SIGPIPE信号，信号默认终止进程，如果忽略此信号或者从SIGPIPE的信号处理程序返回则write出错返回EPIPE。
可以看出只有当本地端口主动发送消息给对端才能检测出连接异常中断的情况,搭配select进行多路分离的时候，socket收到RST或者FIN时候，select返回可读(心跳消息就是用于检测连接的状态)。也可以使用socket的KEEPLIVE选项，依赖socket本身侦测socket连接异常中断的情况。
发送socket数据有以下方法:
调用ssize_t send(int sockfd, const void *buf, size_t nbytes, int flags);，只能用于建立好了连接的socket(面向连接的SOCK_STREAM或者调用了connect的SOCK_DGRAM)。flags取值如下:
MSG_DONTROUTE 对数据不进行路由
MSG_DONTWAIT 不等待数据发送完成
MSG_EOR 数据包结尾
MSG_OOB 带外数据
注意send函数成功返回并不代表对端一定收到了发送的消息，另外对于数据报协议如果发送的数据大于一个数据报长度则发送失败(errno设置为EMSGSIZE)。
linux 客户端 Socket 非阻塞connect编程(正文) linux 客户端 Socket 非阻塞connect编程（正文）/*开发过程与源码解析
开发测试环境：虚拟机CentOS，windows网络调试助手
非阻塞模式有3种用途
1.三次握手同时做其他的处理。connect要花一个往返时间完成，从几毫秒的局域网到几百毫秒或几秒的广域网。这段时间可能有一些其他的处理要执行，比如数据准备，预处理等。
2.用这种技术建立多个连接。这在web浏览器中很普遍.
3.由于程序用select等待连接完成，可以设置一个select等待时间限制，从而缩短connect超时时间。多数实现中，connect的超时时间在75秒到几分钟之间。有时程序希望在等待一定时间内结束，使用非阻塞connect可以防止阻塞75秒，在多线程网络编程中，尤其必要。 例如有一个通过建立线程与其他主机进行socket通信的应用程序，如果建立的线程使用阻塞connect与远程通信，当有几百个线程并发的时候，由于网络延迟而全部阻塞，阻塞的线程不会释放系统的资源，同一时刻阻塞线程超过一定数量时候，系统就不再允许建立新的线程（每个进程由于进程空间的原因能产生的线程有限），如果使用非阻塞的connect，连接失败使用select等待很短时间，如果还没有连接后，线程立刻结束释放资源，防止大量线程阻塞而使程序崩溃。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecde3724ef470fddf88d158110bd8f32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfd454aecc2dc6d8a63018cf2bec0117/" rel="bookmark">
			为什么不要在构造函数中调用虚函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先看一段在构造函数中直接调用虚函数的代码：
1 #include &lt;iostream&gt; 2 3 class Base 4 { 5 public: 6 Base() { Foo(); } ///&lt; 打印 1 7 8 virtual void Foo() 9 { 10 std::cout &lt;&lt; 1 &lt;&lt; std::endl; 11 } 12 }; 13 14 class Derive : public Base 15 { 16 public: 17 Derive() : Base(), m_pData(new int(2)) {} 18 ~Derive() { delete m_pData; } 19 20 virtual void Foo() 21 { 22 std::cout &lt;&lt; *m_pData &lt;&lt; std::endl; 23 } 24 private: 25 int* m_pData; 26 }; 27 28 int main() 29 { 30 Base* p = new Derive(); 31 delete p; 32 return 0; 33 } 这里的结果将打印：1。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfd454aecc2dc6d8a63018cf2bec0117/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e75c237ced1689a9c978d6f6c6ebcb8/" rel="bookmark">
			XML概念与解析库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 XML文件解析库：（C/C++） 名称 访问接口 是否支持验证 备注 Expat SAX/Local 不清楚 Local指它还有一套自己访问模型 LibXML2 SAX/DOM 验证 TinyXml DOM 否 XML4C SAX/DOM 验证 不过用了ICU，国际化似乎更好 Xerces-C SAX/DOM 验证 XML Booster Local 不清楚 估计效率应该很高 Python自带的有ElementTree，比较常用的库是lxml，它是libxml2的py接口 关于DOM和SAX DOM - DocumentObject Model 将整篇XML文档一次性解析并读入内存，保存为一个对象供用户访问。DOM无法处理大型XML文件。 SAX - Simple APIfor XML SAX的XML解析方式是基于事件回调的，解析器在每遇到一个XML元素时都会产生一个事件，并执行由用户提供的处理函数。 两种常见的验证XML文档内容的工具：文档类型定义（Document Type Definitions，DTD）和XML Schema（已经成为W3C的正式推荐标准） XML Schema文档本身也使用 XML 创建，称之为模式文档，它定义实例文档（即数据文档）的结构，各个属性的有效取值等。参见： http://www.ibm.com/developerworks/cn/education/xml/x-valid/section5.html http://bbs.xml.org.cn/dispbbs.asp?boardID=23&amp;ID=11585 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e31db678e686942f7674f1e205b2346c/" rel="bookmark">
			g&#43;&#43;编译错误“no matching function for call to...&#34;的解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; 如果在类中定义了和库函数同名的函数，如下面代码中的printf，那么再调用库函数printf的时候，就会有类似“no matching function for call to...”的编译错误，即使类中定义的函数和库函数参数、返回值并不相同。
#include &lt;stdio.h&gt;
class CAClass{ public: CAClass() { printf("hello\n"); } ~CAClass() {} private: void printf() { } }; int main() { CAClass aClass; return 0; }
解决办法是在包含库函数的头文件上加上namespace，并在调用的时候，加上命名空间，问题解决。代码如下：
namespace stdclib {
#include &lt;stdio.h&gt;
}
class CAClass{
public:
CAClass() { stdclib::printf("hello\n"); }
~CAClass() {}
private:
void printf() { }
};
int main()
{
CAClass aClass;
return 0;
}
转载于:https://my.oschina.net/livedead/blog/55149
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/934b775840fd64875c30c323d4b3189e/" rel="bookmark">
			js 汉字转换成拼音 转载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//获取拼音的代码使用方法
//console.log(__pinyin.get('我keyi加123')); //console.log(__pinyin.getFirstLetter('我keyi加123'));
//console.log(__pinyin.getPinyin('我keyi加123'));
(function () {
var Dota = {
db: [['A', '阿吖嗄腌锕'],
['Ai', '埃挨哎唉哀皑癌蔼矮艾碍爱隘捱嗳嗌嫒瑷暧砹锿霭'],
['An', '鞍氨安俺按暗岸胺案谙埯揞庵桉铵鹌黯'],
['Ang', '肮昂盎'],
['Ao', '凹敖熬翱袄傲奥懊澳坳嗷岙廒遨媪骜獒聱螯鏊鳌鏖'],
['Ba', '芭捌扒叭吧笆八疤巴拔跋靶把耙坝霸罢爸茇菝岜灞钯粑鲅魃'],
['Bai', '白柏百摆佰败拜稗捭掰'],
['Ban', '斑班搬扳般颁板版扮拌伴瓣半办绊阪坂钣瘢癍舨'],
['Bang', '邦帮梆榜膀绑棒磅镑傍谤蒡浜'],
['Beng', '蚌崩绷甭泵蹦迸嘣甏'],
['Bao', '苞胞包褒薄雹保堡饱宝抱报暴豹鲍爆曝勹葆孢煲鸨褓趵龅'],
['Bo', '剥玻菠播拨钵波博勃搏铂箔伯帛舶脖膊渤泊驳亳啵饽檗擘礴钹鹁簸跛踣'],
['Bei', '杯碑悲卑北辈背贝钡倍狈备惫焙被孛陂邶蓓呗悖碚鹎褙鐾鞴'],
['Ben', '奔苯本笨畚坌锛'],
['Bi', '逼鼻比鄙笔彼碧蓖蔽毕毙毖币庇痹闭敝弊必壁臂避陛匕俾荜荸萆薜吡哔狴庳愎滗濞弼妣婢嬖璧贲睥畀铋秕裨筚箅篦舭襞跸髀'],
['Pi', '辟坯砒霹批披劈琵毗啤脾疲皮匹痞僻屁譬丕仳陴邳郫圮埤鼙芘擗噼庀淠媲纰枇甓罴铍癖疋蚍蜱貔'],
['Bian', '鞭边编贬扁便变卞辨辩辫遍匾弁苄忭汴缏煸砭碥窆褊蝙笾鳊'],
['Biao', '标彪膘表婊骠飑飙飚镖镳瘭裱鳔'],
['Bie', '鳖憋别瘪蹩'],
['Bin', '彬斌濒滨宾摈傧豳缤玢槟殡膑镔髌鬓'],
['Bing', '兵冰柄丙秉饼炳病并禀邴摒'],
['Bu', '捕卜哺补埠不布步簿部怖卟逋瓿晡钚钸醭'],
['Ca', '擦嚓礤'],
['Cai', '猜裁材才财睬踩采彩菜蔡'],
['Can', '餐参蚕残惭惨灿骖璨粲黪'],
['Cang', '苍舱仓沧藏伧'],
['Cao', '操糙槽曹草嘈漕螬艚'],
['Ce', '厕策侧册测恻'],
['Ceng', '层蹭曾噌'],
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/934b775840fd64875c30c323d4b3189e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86a574c5e369e89e6a0b04cb8562c335/" rel="bookmark">
			nginx proxy_pass后的url加不加/的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在nginx中配置proxy_pass时，当在后面的url加上了/，相当于是绝对根路径，则nginx不会把location中匹配的路径部分代理走;如果没有/，则会把匹配的路径部分也给代理走。
下面四种情况分别用http://192.168.1.4/proxy/test.html 进行访问。
第一种：
location /proxy/ {
proxy_pass http://127.0.0.1:81/;
}
会被代理到http://127.0.0.1:81/test.html 这个url
第二咱(相对于第一种，最后少一个 /)
location /proxy/ {
proxy_pass http://127.0.0.1:81;
}
会被代理到http://127.0.0.1:81/proxy/test.html 这个url
第三种：
location /proxy/ {
proxy_pass http://127.0.0.1:81/ftlynx/;
}
会被代理到http://127.0.0.1:81/ftlynx/test.html 这个url。
第四种情况(相对于第三种，最后少一个 / )：
location /proxy/ {
proxy_pass http://127.0.0.1:81/ftlynx;
}
会被代理到http://127.0.0.1:81/ftlynxtest.html 这个url
上面的结果都是本人结合日志文件测试过的。从结果可以看出，应该说分为两种情况才正确。即http://127.0.0.1:81 (上面的第二种) 这种和 http://127.0.0.1:81/.... （上面的第1，3，4种） 这种。
转载于:https://blog.51cto.com/ftlynx/839607
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92e3b7dfabdead04130d137a66050e83/" rel="bookmark">
			Hot Deploy maven project from eclipse to tomcat
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. in project properties/projects facets, choose dynamic web module, java, javascript
2. in project properties/deployment assembly, adding package and dependency 3. config tomcat in eclipse and right click, then add and remove ...
4. done
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b28b2c9cd0e28558dd4eb93234bfefc7/" rel="bookmark">
			oracle 查看和修改global_name 的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、查看global_names属性 1）、查看global_names属性是否开启： SQL&gt; show parameter global_name; NAME TYPE VALUE ------------------------------------ ----------- ------------------------------ global_names boolean FALSE 2）、查看golbal_names的值： SQL&gt; select * from global_name; GLOBAL_NAME 2、修改global_name 1)、启用global_names: SQL&gt; alter system set global_names=true; 2)、修改global_name的方法一： SQL&gt; ALTER DATABASE RENAME GLOBAL_NAME TO ORCL; 数据库已更改。 SQL&gt; select * from global_name; GLOBAL_NAME -------------------------------------------------------------------------------- orcl 3)、修改global_name的方法二：（不建议） SQL&gt; update props$ set value$ = 'orcl' where name = 'GLOBAL_DB_NAME'; 已更新 1 行。 SQL&gt; select * from global_name; GLOBAL_NAME -------------------------------------------------------------------------------- orcl 来自 “ ITPUB博客 ” ，链接：http://blog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b28b2c9cd0e28558dd4eb93234bfefc7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8146d3200e1fb0d7cf79da4ff1cdf39/" rel="bookmark">
			matlab实现牛顿迭代法求解非线性方程组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://hi.baidu.com/aillieo/blog/item/0800e2a10ac9a59647106493.html
已知非线性方程组如下
3*x1-cos(x2*x3)-1/2=0
x1^2-81*(x2+0.1)^2+sin(x3)+1.06=0
exp(-x1*x2)+20*x3+(10*pi-3)/3=0
求解要求精度达到0.00001
————————————————————————————————
首先建立函数fun
储存方程组编程如下将fun.m保存到工作路径中:
function f=fun(x);
%定义非线性方程组如下
%变量x1 x2 x3
%函数f1 f2 f3
syms x1 x2 x3
f1=3*x1-cos(x2*x3)-1/2;
f2=x1^2-81*(x2+0.1)^2+sin(x3)+1.06;
f3=exp(-x1*x2)+20*x3+(10*pi-3)/3;
f=[f1 f2 f3];
————————————————————————————————
建立函数dfun
用来求方程组的雅克比矩阵将dfun.m保存到工作路径中:
function df=dfun(x);
%用来求解方程组的雅克比矩阵储存在dfun中
f=fun(x);
df=[diff(f,'x1');diff(f,'x2');diff(f,'x3')];
df=conj(df');
————————————————————————————————
编程牛顿法求解非线性方程组将newton.m保存到工作路径中:
function x=newton(x0,eps,N);
con=0;
%其中x0为迭代初值eps为精度要求N为最大迭代步数con用来记录结果是否收敛
for i=1:N;
f=subs(fun(x0),{'x1' 'x2' 'x3'},{x0(1) x0(2) x0(3)});
df=subs(dfun(x0),{'x1' 'x2' 'x3'},{x0(1) x0(2) x0(3)});
x=x0-f/df;
for j=1:length(x0);
il(i,j)=x(j);
end
if norm(x-x0)&lt;eps
con=1;
break;
end
x0=x;
end
%以下是将迭代过程写入txt文档文件名为iteration.txt
fid=fopen('iteration.txt','w');
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8146d3200e1fb0d7cf79da4ff1cdf39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8664b02503422657e806941add00066c/" rel="bookmark">
			各种字符串类型之间的转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		五、各种字符串类型之间的转换
1、函数 WideCharToMultiByte()，转换 UNICODE 到 MBCS。使用范例：
LPCOLESTR lpw = L"Hello,你好"; size_t wLen = wcslen( lpw ) + 1; // 宽字符字符长度，+1表示包含字符串结束符 int aLen=WideCharToMultiByte( // 第一次调用，计算所需 MBCS 字符串字节长度 CP_ACP, 0, lpw, // 宽字符串指针 wLen, // 字符长度 NULL, 0, // 参数0表示计算转换后的字符空间 NULL, NULL); LPSTR lpa = new char [aLen]; WideCharToMultiByte( CP_ACP, 0, lpw, wLen, lpa, // 转换后的字符串指针 aLen, // 给出空间大小 NULL, NULL); // 此时，lpa 中保存着转换后的 MBCS 字符串 ... ... ... ... delete [] lpa; 2、函数 MultiByteToWideChar()，转换 MBCS 到 UNICODE。使用范例： LPCSTR lpa = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8664b02503422657e806941add00066c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68d2793e83124cc2dd6c19d7798edc5a/" rel="bookmark">
			最全的OLE操作Excel的完整代码（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/*------------------------------------------------- //目前真正最全的OLE操作Excel的完整代码 //版本：2007.01.15.01 //C++Builder专家组www.3322ee.com原创文章 //转载请保留本版权信息，谢谢合作 --------------------------------------------------/ //打印设定： //sh.OlePropertyGet("PageSetup").OlePropertySet("PrintTitleRows","$2:$2");//打印标题列 //sh.OlePropertyGet("PageSetup").OlePropertySet("PrintTitleColumns","$A:$A");//打印标题栏 //sh.OlePropertyGet("PageSetup").OlePropertySet("PrintArea","$A$1:$I$15");//打印范围 //sh.OlePropertyGet("PageSetup").OlePropertySet("PrintHeadings",false);//栏名列号 //sh.OlePropertyGet("PageSetup").OlePropertySet("PrintGridlines",false);//打印网格线 //sh.OlePropertyGet("PageSetup").OlePropertySet("PrintComments",xlPrintNoComments);//批注"无" //sh.OlePropertyGet("PageSetup").OlePropertySet("PrintQuality",300);//打印品质 //sh.OlePropertyGet("PageSetup").OlePropertySet("CenterHorizontally",true);//水平置中 //sh.OlePropertyGet("PageSetup").OlePropertySet("CenterVertically",false);//垂直置中 //sh.OlePropertyGet("PageSetup").OlePropertySet("Orientation",xlLandscape);//横向打印 (xlPortrait 纵向打印) //sh.OlePropertyGet("PageSetup").OlePropertySet("Draft",false);//草稿品质 //sh.OlePropertyGet("PageSetup").OlePropertySet("PaperSize",xlPaperA4);//纸张大小 //sh.OlePropertyGet("PageSetup").OlePropertySet("FirstPageNumber",xlAutomatic);//起始页码 //sh.OlePropertyGet("PageSetup").OlePropertySet("Order",xlDownThenOver);//循栏打印 (xlOverThenDown 循列打印) //sh.OlePropertyGet("PageSetup").OlePropertySet("BlackAndWhite",False);//储存格单色打印 //sh.OlePropertyGet("PageSetup").OlePropertySet("Zoom",100);//缩放比例
//设定单元格背景色： //sh.OlePropertyGet("Cells",2,2).OlePropertyGet("Interior").OlePropertySet("ColorIndex",3);//设定指定单元格的背景色
//设定图样：xlGray50可以是1，2，3等数字 //sh.OlePropertyGet("Cells",4,2).OlePropertyGet("Interior").OlePropertySet("Pattern",xlGray50); //sh.OlePropertyGet("Range","A1:C10").OlePropertyGet("Interior").OlePropertySet("Pattern",xlGray50);//在指定区域设置图样
//设置单元格中的文字距左： //sh.OlePropertyGet("Cells",1,1).OlePropertySet("HorizontalAlignment",xlLeft);//设置单元格中的文字距左 //sh.OlePropertyGet("Cells",1,1).OlePropertySet("VerticalAlignment",xlCenter);//作用不明(垂直和水平居中?) //设置单元格中的文字距中： sh.OlePropertyGet("Cells",1,1).OlePropertySet("HorizontalAlignment",xlCenter);//设置单元格中的文字距中 //sh.OlePropertyGet("Cells",1,1).OlePropertySet("VerticalAlignment",xlCenter);//作用不明 //设置单元格中的文字距右： //sh.OlePropertyGet("Cells",1,1).OlePropertySet("HorizontalAlignment",xlRight);//设置单元格中的文字距右 //sh.OlePropertyGet("Cells",1,1).OlePropertySet("VerticalAlignment",xlCenter);//作用不明 /*------------------------------------------------- //目前真正最全的OLE操作Excel的完整代码 //版本：2007.01.15.01 //C++Builder专家组www.3322ee.com原创文章 //转载请保留本版权信息，谢谢合作 --------------------------------------------------/ //工作表操作： //sh.OlePropertySet("Name", "Sheet的新名字");//重命名当前工作表 //sh.OleFunction("Delete");//删除当前工作表
//画单元格单条边框： //sh.OlePropertyGet("Cells",11,2).OlePropertyGet("Borders").OlePropertyGet("Item",xlEdgeLeft).OlePropertySet("Weight",xlThin);//画单元格左边框 //sh.OlePropertyGet("Cells",11,2).OlePropertyGet("Borders").OlePropertyGet("Item",xlEdgeLeft).OlePropertySet("LineStyle",xlContinuous);//画单元格左边框 //sh.OlePropertyGet("Cells",11,2).OlePropertyGet("Borders").OlePropertyGet("Item",xlEdgeRight).OlePropertySet("Weight",xlThin);//画单元格右边框 //sh.OlePropertyGet("Cells",11,2).OlePropertyGet("Borders").OlePropertyGet("Item",xlEdgeRight).OlePropertySet("LineStyle",xlContinuous);//画单元格右边框 //sh.OlePropertyGet("Cells",11,2).OlePropertyGet("Borders").OlePropertyGet("Item",xlEdgeTop).OlePropertySet("Weight",xlThin);//画单元格上边框 //sh.OlePropertyGet("Cells",11,2).OlePropertyGet("Borders").OlePropertyGet("Item",xlEdgeTop).OlePropertySet("LineStyle",xlContinuous);//画单元格上边框 //sh.OlePropertyGet("Cells",11,2).OlePropertyGet("Borders").OlePropertyGet("Item",xlEdgeBottom).OlePropertySet("Weight",xlThin);//画单元格下边框 //sh.OlePropertyGet("Cells",11,2).OlePropertyGet("Borders").OlePropertyGet("Item",xlEdgeBottom).OlePropertySet("LineStyle",xlContinuous);//画单元格下边框 //sh.OlePropertyGet("Range","A1:C10").OlePropertyGet("Borders").OlePropertyGet("Item",xlDiagonalDown).OlePropertySet("Weight",4);//将指定区域的单元格用粗实线划掉
//画单元格完整边框： //sh.OlePropertyGet("Range","A1:C10").OlePropertyGet("Borders").OlePropertySet("linestyle",2);//给指定区域的所有单元格加上边框，最后的数字：1=细实线框，2=短距虚线框，3=长距虚线框，4=点划线，5=双点划线，6=粗点划线 //sh.OlePropertyGet("Range","A1:C10").OlePropertyGet("Borders").OlePropertySet("weight",1);//给指定区域的所有单元格加上边框，最后的数字不大于4 //sh.OlePropertyGet("Range","A1:C10").OlePropertyGet("Borders").OlePropertySet("colorindex",3);//给指定区域的所有单元格加上边框，最后的数字表示颜色 //sh.OlePropertyGet("Cells",11,2).OlePropertyGet("Borders").OlePropertySet("LineStyle",xlContinuous);//给指定单元格四周加上实线边框
//去掉指定区域的边框： //sh.OlePropertyGet("Range","A1:C10").OlePropertyGet("Borders").OlePropertySet("linestyle",xlNone);//去掉指定区域的边框
//画单元格单面边框参数说明： //xlDiagonalDown：绘制从左上到右下角的斜线 //xlDiagonalUp：绘制从左下到右上角的斜线 //xlEdgeBottom：画单元格下边框 //xlEdgeLeft：画单元格左边框 //xlEdgeRight：画单元格右边框 //xlEdgeTop：画单元格上边框 /*------------------------------------------------- //目前真正最全的OLE操作Excel的完整代码 //版本：2007.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68d2793e83124cc2dd6c19d7798edc5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d680cc972f3a181a566ec69c265fe0e/" rel="bookmark">
			Nginx模块参考手册：FastCGI模块(FastCGI)(3)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		fastcgi_pass
语法：fastcgi_pass fastcgi-server 默认值：none 使用字段：http, server, location 指定FastCGI服务器监听端口与地址，可以是本机或者其它：
fastcgi_pass localhost:9000; 使用Unix socket:
fastcgi_pass unix:/tmp/fastcgi.socket; 同样可以使用一个upstream字段名称：
upstream backend {server localhost:1234;}fastcgi_pass backend; fastcgi_pass_header
语法：fastcgi_pass_header name 默认值：none 使用字段：http, server, location
fastcgi_read_timeout
语法：fastcgi_read_timeout time 默认值：fastcgi_read_timeout 60 使用字段：http, server, location 前端FastCGI服务器的响应超时时间，如果有一些直到它们运行完才有输出的长时间运行的FastCGI进程，或者在错误日志中出现前端服务器响应超时错误，可能需要调整这个值。
fastcgi_redirect_errors
语法：fastcgi_redirect_errors on|off 指令重命名为fastcgi_intercept_errors。
fastcgi_send_timeout
语法：fastcgi_send_timeout time 默认值：fastcgi_send_timeout 60 使用字段：http, server, location 指令为上游服务器设置等待一个FastCGI进程的传送数据时间，如果有一些直到它们运行完才有输出的长时间运行的FastCGI进程，那么可以修改这个值，如果你在上游服务器的error log里面发现一些超时错误，那么可以恰当的增加这个值。
指令指定请求服务器的超时时间，指完成了2次握手的连接，而不是完整的连接，如果在这期间客户端没有进行数据传递，那么服务器将关闭这个连接。
fastcgi_split_path_info
语法：fastcgi_split_path_info regex 使用字段：location 可用版本：0.7.31以上
这个指令允许为CGI specification设置SCRIPT_FILENAME (SCRIPT_NAME)和PATH_INFO变量。正则包含两个组:
处理请求的脚本路径–对应$fastcgi_script_name。 脚本参数的值–对应$fastcgi_path_info。 下面是一个示例，脚本show.php接受字符串参数： article/0001，下面的例子将处理路径妥善分裂：
location ~ ^.+\.php {(.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d680cc972f3a181a566ec69c265fe0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b45314d7fb11dea826ef9036570f8ea/" rel="bookmark">
			(asp.net)PayPal案例的关键源码代码__PayPal集成_API接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		轻轻松松集成PayPal
标准版
Paypal国际版网站集成简易教程（一）：序言
前段时间接到一个外贸网站的项目，集成paypal支付接口的，对象是海外用户，全部用US的信用卡结算。国内有个paypal的中文版，叫贝宝，不过只支持人民币之间的结算，而且提供的功能不多。所以只能使用paypal国际版，也就是paypal.com，习惯性的google了一下相关资料，发现关于paypal.com接口的中文文档并不多，也不详细，只好自己上paypal.com研究，还好paypal上的资料非常齐全，而且还提供了开发者沙盒（sandbox），相比之下，国内流行的支付宝还有很长的路要走啊。
项目结束的时候就有想法写一篇网站集成paypal的简易教程，方便以后的各位开发者，毕竟看长篇英文资料是很头痛的事情^_^。一直到昨天期末考才结束，所以今天开始写这个教程，其实内容也不多，可能还算不上教程，只能算经验吧。
主要分为序言、支付按钮、返回信息方式（IPN&amp;PDT）、实例四部分组成，预计在三天内完成，如果有新内容我临时再加吧。
接下来一篇将会介绍如何在网站上快速加入paypal支付按钮。
Paypal国际版网站集成简易教程（二）：快速加入支付按钮
本篇主要介绍如何在你的网站上快速加入paypal支付按钮，通过这个按钮，人们可以方便快速的付款到你的paypal帐户。
首先，你需要注册一个paypal帐户，帐户类型分为Personal（个人）、Premier（高级）和Business（商业），他们的差别对于开发者来说主要是返回的信息，Personal的不能使用IPN和PDT等商家工具，即不能获取交易信息，但是Personal帐户收款无需手续费；Premier和Business当然就提供了IPN和PDT功能，能够在客户支付成功后，将交易信息传给指定的网站，用来二次使用。Premier和Business使用上的差异我不是很清楚，应该是月收款额和手续费上的区别吧。
这里插进来介绍一下paypal sandbox，也就是沙盒，是paypal提供给开发者的一个工具，非常好用，你可以在https://developer.paypal.com/注册和使用它。登录以后可以新建帐户，设置余额和帐户类型，有一点要注意，每次使用时必须先登录sandbox才能使用新建的那些帐户。Sndbox里面有个测试工具，可以发送IPN的，以后会用到。
接着上面的内容，注册完帐户以后，当然，一开始开发最好使用sandbox，不然资金转来转去手续费都扣光了，paypal的费率如下：
比起国内的支付工具，paypal贵了好多，当然，和国情也有关系。
接下来是按钮的代码，很简单，就是一个普通的网页表单代码：
程序代码
&lt;form action="https://www.paypal.com/cgi-bin/webscr" method="post"&gt; &lt;input type="hidden" name="cmd" value="_xclick"&gt; &lt;input type="hidden" name="business" value="sample@sample.com"&gt; &lt;input type="hidden" name="item_name" value="Item Name Goes Here"&gt; &lt;input type="hidden" name="item_number" value="Item Number Goes Here"&gt; &lt;input type="hidden" name="amount" value="100.00"&gt; &lt;input type="hidden" name="no_shipping" value="2"&gt; &lt;input type="hidden" name="no_note" value="1"&gt; &lt;input type="hidden" name="currency_code" value="USD"&gt; &lt;input type="hidden" name="bn" value="IC_Sample"&gt; &lt;input type="image" src="https://www.paypal.com/ en_US/i/btn/x-click-but23.gif" name="submit" alt="Make payments with payPal - it's fast, free and secure!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b45314d7fb11dea826ef9036570f8ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74936a0d57fcbeabdb8620336703661c/" rel="bookmark">
			如何插入说明信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		许多搜索引擎读取meta描述的内容时，上海做网站使用该信息在其数据库中将页面编入索引，有些还在搜索结果页面中显示该信息。
步骤一：打开网页，切换到“html”插入栏将会显示可以插入的对象快捷按钮，单击“文件头”按钮旁边的小三角形，弹出下拉列表旁边的小三角形，弹出下拉列表，选择“说明“选项。
步骤二：在弹出的”说明“对话框中的文本框里输入对网页的说明信息，然后单击确定按钮。
转载于:https://www.cnblogs.com/qq724109029/archive/2012/04/10/2439873.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/407449445e56a47e8b88990df828ac71/" rel="bookmark">
			深度剖析Java数据结构之迭代器（Iterator）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、什么是迭代器 我们知道，JVM是用C/C++编写的。在百度百科中，迭代器是解释是迭代器（iterator）是一种对象，它能够用来遍历标准模板库容器中的部分或全部元素，每个迭代器对象代表容器中的确定的地址。迭代器修改了常规指针的接口，所谓迭代器是一种概念上的抽象：那些行为上象迭代器的东西都可以叫做迭代器。然而迭代器有很多不同的能力，它可以把抽象容器和通用算法有机的统一起来。
二、Java中的迭代器 百度百科中解释的迭代器是C++中的迭代器，但是JVM的编写语言是C/C++，在Java中，我们知道要使用迭代器，就需要继承Iterator接口，Iterator接口中有一个iterator()方法，根据Java基本的知识，我们还应该知道，继承Iterator接口的类需要实现iterator()方法，下面是ArrayList泛型类实现的listIterator()方法，返回一个ListIterator接口的对象。
public ListIterator&lt;E&gt; listIterator(final int index) { if (index&lt;0 || index&gt;size()) throw new IndexOutOfBoundsException("Index: "+index); return new ListItr(index); } 上面是有参数的listIterator()方法。
public ListIterator&lt;E&gt; listIterator() { return listIterator(0); } 上面是无参数的listIterator()方法。
private class ListItr extends Itr implements ListIterator&lt;E&gt; { ListItr(int index) { cursor = index; } 上面是在ArrayList泛型类中定义的一个内部类。其中cursor为一个成员变量，代表的意思为游标的位置。
/** * Index of element to be returned by subsequent call to next. */ int cursor = 0; 从ArrayList泛型类中的迭代器的定义，我们可以看出，Java中的迭代器和C++中的迭代器是一样的，即每个迭代器对象代表容器中的确定的地址。正因为如此，我们在使用的时候，一定要注意一些事情。
三、使用迭代器注意事项
在前面的文章( 深度剖析Java数据结构之表（一）——Collection接口和Iterator接口 )已经提到了，在得到一个迭代器对象之后，如果不是使用迭代器中的方法导致容器结构上的修改（结构上的修改是指添加、删除等操作，修改某一项的值不会修改结构），将会抛出异常。出现这种情况的原因是修改容器结构导致迭代器找不到容器中对象的位置。所以，在使用迭代器的时候，一定要注意得到一个迭代器之后，在使用结束之前，不要对容器结构进行修改，如果要修改，应使用迭代器中的方法修改。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34156dd2b062f62a2d6cd65c2d6f6007/" rel="bookmark">
			原码、反码、补码和移码其实很简单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在备战软考，复习到计算机组成原理的时候，看到书中关于原码、反码、补码和移码的定义如下(n是机器字长)：
原码：
反码：
补码：
移码：
看完这些定义以后，我的脑袋瞬间膨胀到原来的二倍！这样变态的公式不管你记不记得住，反正我是记不住！还好以前对它们有所了解，否则看到这一堆公式恐怕我早就放弃参加软考的念头喽。
其实没必要弄得这么麻烦，它们完全可以用一两句话就描述的很清楚。
原码：
如果机器字长为n，那么一个数的原码就是用一个n位的二进制数，其中最高位为符号位：正数为0，负数为1。剩下的n-1位表示概数的绝对值。 例如： X=+101011 , [X]原= 00101011 X=-101011 , [X]原= 10101011 位数不够的用0补全。 PS：正数的原、反、补码都一样：0的原码跟反码都有两个，因为这里0被分为+0和-0。 反码： 知道了什么是原码，那反码就更是张飞吃豆芽——小菜一碟了。知道了原码，那么你只需要具备区分0跟1的能力就可以轻松求出反码，为什么呢？因为反码就是在原码的基础上，符号位不变其他位按位取反(就是0变1，1变0)就可以了。
例如：X=-101011 , [X]原= 10101011 ，[X]反=11010100
补码：
补码也非常的简单就是在反码的基础上按照正常的加法运算加1。
例如：X=-101011 , [X]原= 10101011，[X]反=11010100，[X]补=11010101
PS：0的补码是唯一的，如果机器字长为8那么[0]补=00000000。
移码：
移码最简单了，不管正负数，只要将其补码的符号位取反即可。
例如：X=-101011 , [X]原= 10101011，[X]反=11010100，[X]补=11010101，[X]移=01010101
PS：非常感谢12楼对负数补码的补充
以上内容只适合初学者参考，高手勿喷，有说的不对的地方欢迎指出，感激不尽！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36c590364cb13e87d79069f2ae7caa0a/" rel="bookmark">
			分布式搜索elasticsearch配置文件详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		elasticsearch的config文件夹里面有两个配置文件：elasticsearch.yml和logging.yml，第一个是es的基本配置文件，第二个是日志配置文件，es也是使用log4j来记录日志的，所以logging.yml里的设置按普通log4j配置文件来设置就行了。下面主要讲解下elasticsearch.yml这个文件中可配置的东西。
cluster.name: elasticsearch
配置es的集群名称，默认是elasticsearch，es会自动发现在同一网段下的es，如果在同一网段下有多个集群，就可以用这个属性来区分不同的集群。
node.name: "Franz Kafka"
节点名，默认随机指定一个name列表中名字，该列表在es的jar包中config文件夹里name.txt文件中，其中有很多作者添加的有趣名字。
node.master: true
指定该节点是否有资格被选举成为node，默认是true，es是默认集群中的第一台机器为master，如果这台机挂了就会重新选举master。
node.data: true
指定该节点是否存储索引数据，默认为true。
index.number_of_shards: 5
设置默认索引分片个数，默认为5片。
index.number_of_replicas: 1
设置默认索引副本个数，默认为1个副本。
path.conf: /path/to/conf
设置配置文件的存储路径，默认是es根目录下的config文件夹。
path.data: /path/to/data
设置索引数据的存储路径，默认是es根目录下的data文件夹，可以设置多个存储路径，用逗号隔开，例：
path.data: /path/to/data1,/path/to/data2
path.work: /path/to/work
设置临时文件的存储路径，默认是es根目录下的work文件夹。
path.logs: /path/to/logs
设置日志文件的存储路径，默认是es根目录下的logs文件夹
path.plugins: /path/to/plugins
设置插件的存放路径，默认是es根目录下的plugins文件夹
bootstrap.mlockall: true
设置为true来锁住内存。因为当jvm开始swapping时es的效率会降低，所以要保证它不swap，可以把ES_MIN_MEM和ES_MAX_MEM两个环境变量设置成同一个值，并且保证机器有足够的内存分配给es。同时也要允许elasticsearch的进程可以锁住内存，linux下可以通过`ulimit -l unlimited`命令。
network.bind_host: 192.168.0.1
设置绑定的ip地址，可以是ipv4或ipv6的，默认为0.0.0.0。 network.publish_host: 192.168.0.1
设置其它节点和该节点交互的ip地址，如果不设置它会自动判断，值必须是个真实的ip地址。
network.host: 192.168.0.1
这个参数是用来同时设置bind_host和publish_host上面两个参数。
transport.tcp.port: 9300
设置节点间交互的tcp端口，默认是9300。
transport.tcp.compress: true
设置是否压缩tcp传输时的数据，默认为false，不压缩。
http.port: 9200
设置对外服务的http端口，默认为9200。
http.max_content_length: 100mb
设置内容的最大容量，默认100mb
http.enabled: false
是否使用http协议对外提供服务，默认为true，开启。
gateway.type: local
gateway的类型，默认为local即为本地文件系统，可以设置为本地文件系统，分布式文件系统，hadoop的HDFS，和amazon的s3服务器，其它文件系统的设置方法下次再详细说。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36c590364cb13e87d79069f2ae7caa0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/521f53dbea812ed8d3b6292926ab597e/" rel="bookmark">
			快速傅氏变换之旅(二)  七种FFT算法速度比较(含代码)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载请标明是引用于 http://blog.csdn.net/chenyujing1234
例子代码:(编译工具：VS2005)
http://www.rayfile.com/zh-cn/files/76968e5e-7bde-11e1-8c13-0015c55db73d/
由于公司要做FFT算法，具体是做高尔夫球的弹道分析，至今还没把算法敲定。
今天网上看了算法，自己建立工程，进行了比较。
现在按算法速度从快到慢的顺序介绍：（先搭个框架，具体算法解释，请听下回分解）
1、
//*******************************************************************// 将data[]中的元素进行快速傅立叶变换,当变换长度大于L2 cache,有较快的速度BOOL FFT2(CMPL data[], size_t n)//*******************************************************************{unsigned long i;//------------------------------------if (n&lt;4){printf("too small transpos length\n");return FALSE;}	Init_OMAGE_ARRAY(n);if (g_w.arr==NULL){printf("no enough memory\n");return FALSE;}reverseOrder(data,n,Log2(n)); //反序if (n&lt;=MAX_IN_CACHE_TRANS_LEN){fft_sub(data,n,2,n);return TRUE;}for (i=0;i&lt;n;i+=MAX_IN_CACHE_TRANS_LEN){fft_sub(data+i,MAX_IN_CACHE_TRANS_LEN,2,MAX_IN_CACHE_TRANS_LEN);}fft_sub(data,n,MAX_IN_CACHE_TRANS_LEN*2,n);return TRUE;}//*******************************************************************// 将data[]中的元素进行快速傅立叶变换BOOL FFT1(CMPL data[], size_t n)//*******************************************************************{unsigned long i,i1,i2,j1,j2,d;unsigned long groupBase,groupLen,omageBase;CMPL t,t1,t2;double *pW=NULL;char fileName[3209];if (n&lt;4){printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/521f53dbea812ed8d3b6292926ab597e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51604ebb917fdd30b46b5d3deefb685f/" rel="bookmark">
			iframe 父窗口和子窗口相互的调用方法集锦
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		iframe 父窗口和子窗口相互的调用方法集锦
用iframe、弹出子页面刷新父页面iframe parent.location.reload();弹出子页面 window.opener.location.reload();子窗口刷新父窗口 self.window.opener.locaction.reload();刷新一open（）方法打开的窗口 window.opener.location.href = window.opener.location.href刷新以winodw.showModelDialog()方法打开的窗口 window.parent.dialogArguments.document.execCommand('Refresh'); 下面以三个页面分别命名为frame.html、top.html、bottom.html为例来具体说明如何做。
frame.html 由上(top.html)下(bottom.html)两个页面组成，代码如下：
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"&gt;
&lt;HTML&gt;
&lt;HEAD&gt;
&lt;TITLE&gt; frame &lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;frameset rows="50%,50%"&gt;
&lt;frame name=top src="top.html"&gt;
&lt;frame name=bottom src="bottom.html"&gt;
&lt;/frameset&gt;
&lt;/HTML&gt;
现在假设top.html (即上面的页面) 有七个button来实现对bottom.html (即下面的页面) 的刷新，可以用以下七种语句，哪个好用自己看着办了。
语句1. window.parent.frames[1].location.reload();
语句2. window.parent.frames.bottom.location.reload();
语句3. window.parent.frames["bottom"].location.reload();
语句4. window.parent.frames.item(1).location.reload();
语句5. window.parent.frames.item('bottom').location.reload();
语句6. window.parent.bottom.location.reload();
语句7. window.parent['bottom'].location.reload();
top.html 页面的代码如下：
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"&gt;
&lt;HTML&gt;
&lt;HEAD&gt;
&lt;TITLE&gt; top.html &lt;/TITLE&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51604ebb917fdd30b46b5d3deefb685f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11f6d22598f98637728303efd95d8c0a/" rel="bookmark">
			ThinkPHP图片上传的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于图片上传，实现方法很多，比如可以用jQuery，当然，我们的thinkPHP内置了关于图片上传的功能，我们可以直接使用，使用方法如下：
首先，是表单书写，我们建立如下表单：
&lt;form action="__URL__/addChk" method="post" enctype="multipart/form-data"&gt;&lt;table cellspacing="1" cellpadding="2" width="99%" align="center" border="0"&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th align="left" colspan="2" height="25"&gt;添加新游戏&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td width="17%" height="23"&gt;游戏名称&lt;/td&gt;&lt;td width="83%"&gt;&lt;strong&gt;&lt;input type="text" name="gamename" /&gt;&lt;/strong&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td height="23"&gt;游戏图片&lt;/td&gt;&lt;td &gt;&lt;input type="file" name="gameimg"/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td width="17%" height="23"&gt;游戏简介&lt;span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td width="83%"&gt;&lt;textarea name="gameinfo" cols="30" rows="5"&gt;&lt;/textarea&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td height="23"&gt;游戏地址：&lt;/td&gt;&lt;td&gt;&lt;input type="text" name="gamelink"/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td height="23" colspan="2" &gt;&lt;input type="submit" value="添加" /&gt; &lt;input type="reset" value="重新填写"/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/form&gt; 这里有个非常重要的地方，就是一定要在表单项目添加上enctype="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11f6d22598f98637728303efd95d8c0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5065010c125a9a364591a228f1c92cf/" rel="bookmark">
			在C语言中内嵌汇编
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1． 在C语言中内嵌汇编 在C中内嵌的汇编指令包含大部分的ARM和Thumb指令，不过其使用与汇编文件中的指令有些不同，存在一些限制，主要有下面几个方面：
a. 不能直接向PC寄存器赋值，程序跳转要使用B或者BL指令 b. 在使用物理寄存器时，不要使用过于复杂的C表达式，避免物理寄存器冲突 c. R12和R13可能被编译器用来存放中间编译结果，计算表达式值时可能将R0到R3、R12及R14用于子程序调用，因此要避免直接使用这些物理寄存器 d. 一般不要直接指定物理寄存器，而让编译器进行分配 内嵌汇编使用的标记是 __asm或者asm关键字，用法如下：
__asm { instruction [; instruction] ... [instruction] } 上个demo
#include &lt;stdio.h&gt; void my_strcpy(const char *src, char *dest) { char ch; __asm { loop: ldrb ch, [src], #1 strb ch, [dest], #1 cmp ch, #0 bne loop } } int main() { char *a = "forget it and move on!"; char b[64]; my_strcpy(a, b); printf("original: %s", a); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5065010c125a9a364591a228f1c92cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77306e935738e2e9d28bf0343573d8ae/" rel="bookmark">
			使用SC创建和删除windows服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用SC命令来创建windows服务 命令格式：
sc [servername] create Servicename [Optionname= Optionvalues] servername
可选，可以使用双斜线，如\\\\myserver，也可以是\\\\192.168.0.1来操作远程计算机。如果在本地计算机上操作就不用添加任何参数。
Servicename
在注册表中为service key制定的名称。注意这个名称是不同于显示名称的（这个名称可以用net start和服务控制面板看到），而SC是使用服务键名来鉴别服务的。
Optionname 这个optionname和optionvalues参数允许你指定操作命令参数的名称和数值。注意，这一点很重要在操作名称和等号之间是没有空格的。
如果你想要看每个命令的可以用的optionvalues，你可以使用sc command这样的格式。这会为你提供详细的帮助。
Optionvalues
为optionname的参数的名称指定它的数值。有效数值范围常常限制于哪一个参数的optionname。如果要列表请用sc command来询问每个命令。
Optionname--Optionvalues描述
type=----own, share, interact, kernel, filesys
关于建立服务的类型，选项值包括驱动程序使用的类型，默认是share。
start=----boot, sys tem, auto, demand, disabled
关于启动服务的类型，选项值包括驱动程序使用的类型，默认是demand（手动）。
error=----normal, severe, critical, ignore
当服务在导入失败错误的严重性，默认是normal。
binPath=--(string)
服务二进制文件的路径名，这里没有默认值，这个字符串是必须设置的。
group=----(string)
这个服务属于的组，这个组的列表保存在注册表中的ServiceGroupOrder下。默认是nothing。
tag=----(string)
如果这个字符串被设置为yes，sc可以从CreateService call中得到一个tagId。然而，SC并不显示这个标签，所以使用这个没有多少意义。默认是nothing
depend=----(space separated string)有空格的字符串。
在这个服务启动前必须启动的服务的名称或者是组。
obj=----(string)
账号运行使用的名称，也可以说是登陆身份。默认是localsys tem
Displayname=--(string)
一个为在用户界面程序中鉴别各个服务使用的字符串。
password=--(string)
一个密码，如果一个不同于localsys tem的账号使用时需要使用这个。
Optionvalues
Optionname参数名称的数值列表。参考optionname。当我们输入一个字符串时，如果输入一个空的引用这意味着一个空的字符串将被导入。
需要注意的是:
1. 在option= xxxxx格式中，“=”号和后面的内容一定要有空格，如depend= Tcpip
2. 如果命令中的需要进行双引号的嵌套，使用反斜杠加引号 " \"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77306e935738e2e9d28bf0343573d8ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1df9425417c4a1ec873e2d8c3675202/" rel="bookmark">
			java中byte数组与int，long，short间的转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package com.util; /** * * &lt;ul&gt; * &lt;li&gt;文件名称: com.born.util.ByteUtil.java&lt;/li&gt; * &lt;li&gt;文件描述: byte转换工具&lt;/li&gt; * &lt;li&gt;版权所有: 版权所有(C)2001-2006&lt;/li&gt; * &lt;li&gt;公 司: bran&lt;/li&gt; * &lt;li&gt;内容摘要:&lt;/li&gt; * &lt;li&gt;其他说明:&lt;/li&gt; * &lt;li&gt;完成日期：2011-7-18&lt;/li&gt; * &lt;li&gt;修改记录0：无&lt;/li&gt; * &lt;/ul&gt; * * @version 1.0 * @author 许力多 */ public class ByteUtil { /** * 转换short为byte * * @param b * @param s * 需要转换的short * @param index */ public static void putShort(byte b[], short s, int index) { b[index + 1] = (byte) (s &gt;&gt; 8); b[index + 0] = (byte) (s &gt;&gt; 0); } /** * 通过byte数组取到short * * @param b * @param index * 第几位开始取 * @return */ public static short getShort(byte[] b, int index) { return (short) (((b[index + 1] &lt;&lt; 8) | b[index + 0] &amp; 0xff)); } /** * 转换int为byte数组 * * @param bb * @param x * @param index */ public static void putInt(byte[] bb, int x, int index) { bb[index + 3] = (byte) (x &gt;&gt; 24); bb[index + 2] = (byte) (x &gt;&gt; 16); bb[index + 1] = (byte) (x &gt;&gt; 8); bb[index + 0] = (byte) (x &gt;&gt; 0); } /** * 通过byte数组取到int * * @param bb * @param index * 第几位开始 * @return */ public static int getInt(byte[] bb, int index) { return (int) ((((bb[index + 3] &amp; 0xff) &lt;&lt; 24) | ((bb[index + 2] &amp; 0xff) &lt;&lt; 16) | ((bb[index + 1] &amp; 0xff) &lt;&lt; 8) | ((bb[index + 0] &amp; 0xff) &lt;&lt; 0))); } /** * 转换long型为byte数组 * * @param bb * @param x * @param index */ public static void putLong(byte[] bb, long x, int index) { bb[index + 7] = (byte) (x &gt;&gt; 56); bb[index + 6] = (byte) (x &gt;&gt; 48); bb[index + 5] = (byte) (x &gt;&gt; 40); bb[index + 4] = (byte) (x &gt;&gt; 32); bb[index + 3] = (byte) (x &gt;&gt; 24); bb[index + 2] = (byte) (x &gt;&gt; 16); bb[index + 1] = (byte) (x &gt;&gt; 8); bb[index + 0] = (byte) (x &gt;&gt; 0); } /** * 通过byte数组取到long * * @param bb * @param index * @return */ public static long getLong(byte[] bb, int index) { return ((((long) bb[index + 7] &amp; 0xff) &lt;&lt; 56) | (((long) bb[index + 6] &amp; 0xff) &lt;&lt; 48) | (((long) bb[index + 5] &amp; 0xff) &lt;&lt; 40) | (((long) bb[index + 4] &amp; 0xff) &lt;&lt; 32) | (((long) bb[index + 3] &amp; 0xff) &lt;&lt; 24) | (((long) bb[index + 2] &amp; 0xff) &lt;&lt; 16) | (((long) bb[index + 1] &amp; 0xff) &lt;&lt; 8) | (((long) bb[index + 0] &amp; 0xff) &lt;&lt; 0)); } /** * 字符到字节转换 * * @param ch * @return */ public static void putChar(byte[] bb, char ch, int index) { int temp = (int) ch; // byte[] b = new byte[2]; for (int i = 0; i &lt; 2; i ++ ) { bb[index + i] = new Integer(temp &amp; 0xff).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1df9425417c4a1ec873e2d8c3675202/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad77fa2e67d97e103f7771b8d0b3b686/" rel="bookmark">
			Winpcap的安装使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Winpcap的安装使用方法
1．下载winpcap的安装包，程序员开发包。
2．安装winpcap。
3．解压开发包，在工程中加入winpcap的include和lib（在VC的tools-option-目录的include和lib，Eclipse的project-properties-c/c++ build-settings中的GCC C Compiler-Includes和MinGW C Linker-Libraries）。可能需要添加ws2_32.lib。
4. 在你的程序中加入#include &lt;pcap.h&gt;, #include &lt;remote-ext.h&gt;，然后VC在project-setting-CC++中加入预定义宏:WPCAP,HAVE_REMOTE，在project-setting-连接导入wpcap.lib库；Eclipse在project-properties-c/c++ build-settings中的GCC C Compiler-Symbols中中加入预定义宏:WPCAP,HAVE_REMOTE，在project-properties-c/c++build-settings-MinGW C Linker-Libraries中添加wpcap和packet。
5．enjoy
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e004211d66b44927ca3f1f2d4875608a/" rel="bookmark">
			linux ,apt不能获取的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题描述： sudo apt-get install sun-java6-jdk 出现如下信息： Package sun-java6-jdk is not available, but is referred to by another package. This may mean that the package is missing, has been obsoleted, or is only available from another source E: Package sun-java6-jdk has no installation candidate 问题解决： 1. sudo gedit 打开 /ect/apt/sources.list 2. 最后加入一行 “deb http://us.archive.ubuntu.com/ubuntu/ hardy multiverse” 保存关闭。 3. sudo apt-get update 4。sudo apt-get install sun-java6-jdk 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/239b1c3bfede0aede6c1344b32114c04/" rel="bookmark">
			objective-c中的本地化操作（序列化，归档）(十二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		holydancer原创，如需转载，请在显要位置注明：
转自holydancer的CSDN专栏，原文地址：http://blog.csdn.net/holydancer/article/details/7371643
先介绍一个自定义类描述的方法description，一般情况下，一个自定义类我们在用%@输出的时候，给出的是一个内存地址，我们在该类的.m文件里重写description方法，来修改输出内容，呆会儿我们要用到这个方法来验证今天学习内容，所以先看一段代码熟悉一下：
Human.h:
#import &lt;Foundation/Foundation.h&gt; @interface Human : NSObject { int age; NSString *name; Human *child; } @property int age; @property (copy)NSString *name; @property (retain)Human *child; @end Human.m: #import "Human.h" @implementation Human @synthesize age; @synthesize name; @synthesize child; //-(NSString *)description //{ // NSString *des = [NSString stringWithFormat:@"%d,%@,%@",age,name,child]; // return des; //} @end 上面的重写描述被注释掉了，我们先看未修改前的输出： main.m:
#import &lt;Foundation/Foundation.h&gt; #import "Human.h" int main(int argc, const char * argv[]) { @autoreleasepool { Human *human1=[[Human alloc]init]; Human *human2=[[Human alloc]init]; human1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/239b1c3bfede0aede6c1344b32114c04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e04abe72c0e52631d3332e6cbfad46c4/" rel="bookmark">
			关于芯片 ，处理器，内核，以及内存外存，外设等之间的关系小结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般说的ARM等架构属于处理器内核的架构。芯片的内核一般由体现处理器架构的核芯部件（即内核的内核，这里才是真正体现处理器结构的地方），存储管理单元（MMU），和高速缓存三个部分组成。
比如，ARM920T核由ARM9DMI，存储管理单元（MMU），16KB指令缓存和16KB数据缓存。
一般处理器（CPU）由处理器内核，和一些外设接口和外设控制器实现。。处理器是一种芯片。在硅板上集合多种电子元器件实现某种特定功能的电路模块都可以称作芯片。所以一个机器中可以有很多芯片，但是中央处理器一般中有一个或一组。
比s3c410芯片有ARM920T内核以及一些通过APB总线和AMB总线连接的外设接口（如触摸屏接口，I2C总线接口，I2S总线接口，两个USB主机接口，一个USB设备接口，两个SPI接口，SD接口和MMC卡接口） 以及一些外设控制器（如NAND FLASH控制器，SDRAM控制器（外部存储控制器），3通道的的UART，4通道DMA，）等组成（其他还有内部时钟，计时器等）。
开发板的一般就是提供处理器支持的外设，并把他们与其他外设焊接。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1489a83c3c34b1d3e4528bbc9b8b770b/" rel="bookmark">
			SQL之存储过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1：定义
存储过程(stored procedure)是一组为了完成特定功能的SQL语句集合，经编译后存储在服务器端的数据库中，利用存储过程可以加速SQL语句的执行。
存储过程分为系统存储过程和自定义存储过程。
*系统存储过程在master数据库中，但是在其他的数据库中可以直接调用，并且在调用时不必在存储过程前加上数据库名，因为在创建一个新数据库时，系统存储过程
在新的数据库中会自动创建
*自定义存储过程，由用户创建并能完成某一特定功能的存储过程，存储过程既可以有参数又有返回值，但是它与函数不同，存储过程的返回值只是指明执行是否成功，
并不能像函数那样被直接调用，只能利用execute来执行存储过程。
2：存储过程的优点 *提高应用程序的通用性和可移植性：存储过程创建后，可以在程序中被多次调用，而不必重新编写该存储过程的SQL语句。并且数据库专业人员可以随时对存储过程进行
修改，且对程序源代码没有影响，这样就极大的提高了程序的可移植性。
*可以更有效的管理用户操作数据库的权限：在Sql Server数据库中，系统管理员可以通过对执行某一存储过程的权限进行限制，从而实现对相应的数据访问进行控制，
避免非授权用户对数据库的访问，保证数据的安全。
*可以提高SQL的速度，存储过程是编译过的，如果某一个操作包含大量的SQL代码或分别被执行多次，那么使用存储过程比直接使用单条SQL语句执行速度快的多。
*减轻服务器的负担：当用户的操作是针对数据库对象的操作时，如果使用单条调用的方式，那么网络上还必须传输大量的SQL语句，如果使用存储过程，
则直接发送过程的调用命令即可，降低了网络的负担。
3：创建存储过程
SQL Server创建存储过程：
create procedure 过程名
@parameter 参数类型
@parameter 参数类型 。。。
as begin
end
执行存储过程：execute 过程名
Oracle创建存储过程：
create procedure 过程名
parameter in|out|in out 参数类型
.......
parameter in|out|in out 参数类型
........
as begin
命令行或者命令块
exception
命令行或者命令块
end
4：不带参数的存储过程
create procedure proc_sql1 as begin declare @i int set @i=0 while @i&lt;26 begin print char(ascii('a') + @i) + '的ASCII码是: ' + cast(ascii('a') + @i as varchar(5)) set @i = @i + 1 end end exec proc_sql1; a的ASCII码是: 97 b的ASCII码是: 98 c的ASCII码是: 99 d的ASCII码是: 100 e的ASCII码是: 101 f的ASCII码是: 102 g的ASCII码是: 103 h的ASCII码是: 104 i的ASCII码是: 105 j的ASCII码是: 106 k的ASCII码是: 107 l的ASCII码是: 108 m的ASCII码是: 109 n的ASCII码是: 110 o的ASCII码是: 111 p的ASCII码是: 112 q的ASCII码是: 113 r的ASCII码是: 114 s的ASCII码是: 115 t的ASCII码是: 116 u的ASCII码是: 117 v的ASCII码是: 118 w的ASCII码是: 119 x的ASCII码是: 120 y的ASCII码是: 121 z的ASCII码是: 122 5：数据查询功能的不带参数的存储过程
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1489a83c3c34b1d3e4528bbc9b8b770b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48dcb17700929971ba5b2f85b2bce304/" rel="bookmark">
			objective-c 编程总结（第九篇）运行时操作 - 序列化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		objective-c 编程总结（第九篇）运行时操作 - 序列化 学习到目前为止，我看到oc实现的序列化方式有两种：NSKeyedArchiver，NSPropertyListSerialization。
在这两种序列化方式中，NSData都是序列化的目标。两种方式的不同点在于NSPropertyListSerialization只是针对字典类型的，而NSKeyedArchiver是针对对象的。（补充一下，在Mac OS环境下，还可以使用NSArchiver获得更加精简的二进制序列化内容，但是NSArchiver在iOS环境下不支持）。
首先讲NSPropertyListSerialization，这个相对简单，只要创建一个NSDictionary，然后调用NSPropertyListSerialization dataFromPropertyList, 将内容写入NSData中就可以了。如果要读入，就调用propertyListFromData.
NSString * filepath = @”…”;//omitted. NSString * err;//不需要初始化。如果有错误发生，会被复制。 NSDictionary * props = [NSDictionary dictionaryWithObjectsAndKey:@”Lucy”, @"name”, @"Beijing, China”, @"city”, @"supervior”, @"position”, @"Qitiandasheng”, @"company”, nil]; NSData * data = [NSPropertyListSerialization dataFromPropertyList:props format:NSPropertyListXMLFormat_v1_0 errorDescription:&amp;err]; if(!err){ [data writeToFile:filePath atomically:YES];//写入文件 }else{ NSLog(@"error with:%@", err); } 然后再来看NSKeyedArchiver。从基本的代码示例来看也很简单：
Person * lucy = [[Person alloc] initWithName:@"lucy"]; lucy.address = @"Beijing, China"; NSData * data = [NSKeyedArchiver archiveDataWithRootObject:lucy]; [data writeToFile:filePath]; 这里要求Person类必须事先了NSCoding协议。NSCoding协议中包含两个必须事先的方法initWithCoder和encodeWithCoder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48dcb17700929971ba5b2f85b2bce304/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e28e16890b6f4a665cda2ea9ad5171b/" rel="bookmark">
			Android canvas的save restore translate rotate用法介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 首先讲一下canvas的save 和 restore功能. 这是canvas很有魅力的一个部分.
onDraw方法会传入一个Canvas对象，它是你用来绘制控件视觉界面的画布。
在onDraw方法里，我们经常会看到调用save和restore方法，它们到底是干什么用的呢?
❑ save：用来保存Canvas的状态。save之后，可以调用Canvas的平移、放缩、旋转、错切、裁剪等操作。
❑ restore：用来恢复Canvas之前保存的状态。防止save后对Canvas执行的操作对后续的绘制有影响。
save和restore要配对使用(restore可以比save少，但不能多)，如果restore调用次数比save多，会引发Error。save和restore之间，往往夹杂的是对Canvas的特殊操作。
例如：我们先想在画布上绘制一个右向的三角箭头，当然，我们可以直接绘制，另外，我们也可以先把画布旋转90°，画一个向上的箭头，然后再旋转回来(这种旋转操作对于画圆周上的标记非常有用)。然后，我们想在右下角有个20像素的圆，那么，onDraw中的核心代码是：
int px = getMeasuredWidth();
int py = getMeasuredWidth();
// Draw background
canvas.drawRect(0, 0, px, py, backgroundPaint);
canvas.save();
// 以画布中心为轴正向旋转90度
canvas.rotate(90, px/2, py/2);
//这里注意一下, rotate后面必须是getMeasuredWidth()和getMeasuredHeight()..具体为什么我也不太清楚..
// Draw up arrow ，左-右-中
canvas.drawLine(px / 2, 0, 0, py / 2, linePaint);
canvas.drawLine(px / 2, 0, px, py / 2, linePaint);
canvas.drawLine(px / 2, 0, px / 2, py, linePaint);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e28e16890b6f4a665cda2ea9ad5171b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60c676775a66c69c917736f024805e0a/" rel="bookmark">
			第九章 代码调优
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前面各章已经讨论了提高效率的高层次方法：问题定义、系统结构、算法设计以及数据结构选择。本章讨论一个低层次方法。”代码调优“首先确定程序中开销较大的部分，然后进行少量的修改，以提高其运行速度。
“他发现常见记录类型的空间分配次数是次常见记录类型的30倍”。如果你知道了程序的大部分运行时间都用于为某一类型的记录分配存储空间，你会如何进行改进程序使其运行得更快呢？
Van Wyk应用高速缓存原理解决了这个问题：最经常访问的数据，其访问开销应该是最小的。他对程序进行了修改，将最常见类型的空闲记录缓存在一个链表中。然后，他就可以通过对该链表的快速访问来处理常见的请求，而不必调用通用的内存分配程序；这使得程序的总运行时间缩短为原先的45%。另一个额外的好处就是修改后的分配程序减少了内存碎片，这使得我们能够更加有效地使用主存。
示例代码如下：
#define NODESIZE 8 #define NODEGROUP 1000 int nodesleft=0; char *p; //使用nodesleft跟踪p所指向的结点个数。如果参数不等于NODESIZE，则立即调用系统的malloc。当nodesleft变为0时，另外分配一组结点。 char *pmalloc(int size) { if(size!=NODESIZE) p=(char *)malloc(size); else { if(nodesleft==0) { p=(char *)malloc(NODESIZE*NODEGROUP); nodesleft=NODEGROUP; } else { nodesleft--; p+=NODESIZE; } } return p; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/329929c2c869b5c0b6808e668d6f5a99/" rel="bookmark">
			Linux中安装新的包时错误提示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误1
E:Could not open lock file /var/lib/dpkg/lock - open (13:Permission denied)
E:Unable to lock the administration directory (/var/lib/dpkg/),are you root?
解决方案：
sudo rm -rf /var/lib/dpkg/lock
sudo rm -rf /var/cache/apt/archives/lock
sudo apt-get update 最后运行：sudodpkg --configure -a 重新配置（系统会提醒）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab05256d10e9e0cdc7cb1cee079a2e0d/" rel="bookmark">
			关于ThinkPHP下表单令牌错误的相关解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在用ThinkPHP做程序的时候，以前用create创建数据的时候，出现了错误提示“表单令牌错误”，然后各种百度各种谷歌，得到的网上解答给出了以下的建议 1、清缓存： 用了，我把所有的Cache下的文件都删掉了，并将~app.php和~runtime.php两个文件同时都删掉了，但是没有效果。
2、将TOKEN_ON参数设置为FALSE： 试过了，但是也不行，虽然不提示表单令牌错误了，但是添加到数据库的数据是空的。
3、在模板文件的表单中添加{__NOTOKEN__}：添加了，但是结果同样是无效！
到这里我就开始无语了，难道就我电脑上的ThinkPHP不行？我觉得应该不是，我又重新写了一个添加函数，结果正常，这时候我就开始想，是不是我的上一个函数写错了？但是检查之后发现没错！后来慢慢的一个个文件开始那个查看啊，终于让我发现了原因：
在ThinkPHP自动生成的各个文件夹中，有一个叫做“Data”的文件夹，下面有个“_fields”文件夹，这个文件夹中存放的是各个模型中数据表中的相关信息，也就算是映射（我的理解），我仔细检查了一个，发现，有两个文件中只有“'_autoinc' =&gt; true,”这一项，其他的都有很多，类似于：
&lt;?php return array ( 0 =&gt; 'id', 1 =&gt; 'title', 2 =&gt; 'content', 3 =&gt; 'publishedtime', 4 =&gt; 'userid', 5 =&gt; 'params', '_autoinc' =&gt; true, '_pk' =&gt; 'id', ); ?&gt; 到这个时候就可以知道原因了，是某个操作将这些数据给删掉了一部分，这样ThinkPHP在进行表单验证的时候，无法进行数据的映射，也就导致了ThinkPHP的错误，将他们按照数据表中的顺序进行添加之后，重新运行，正常！
到此，这个问题解决~~~~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/209af7e1b908c6f5ea1c3a5a1270caa7/" rel="bookmark">
			改造taglib彻底解决amarok等kde下音乐播放程序播放mp3时的中文乱码问题！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一直使用linux系统，但是作为一个中文用户，mp3乱码问题始终困扰着我，在amarok早期版本中其是支持非标准的id3v1/2的编码，但可惜的是其在新近的后续版本中去掉了这个功能，如果想要支持中文有以下几个解决方法：
1， 对于id3v1的mp3文件 如果不改动底层支持是无论如何都不会支持中文的, 因为该标准制定时根本就不支持中文语系的编码
2, 使用工具逐一修改mp3的id3v2的信息使其符合标准, 也就是说每下载一首mp3都要去修改，因为现在桌面是windows的天下，非标准的mp3格式还是占据了主流
今天花了半天时间研究了下taglib库的mpeg/id3v1/id3v2的实现，顺便对其进行深度改造使其支持非标准的mp3 id3v1/id3v2编码，增加了大约200行代码左右，思路如下：
1， 首先尝试使用TAGLIB_COMPAT_ENCODING环境变量定义的编码
2, 如果没有设置以上的环境变量尝试使用当前系统默认的字符编码
3, 如果转码失败则尝试使用GBK编码
4, 如果全部失败则使用taglib原始编码
理论上改动不会对原始的taglib流程及编码造成任何影响，已经在archlinux上的amarok测试通过， 项目地址是：
http://code.google.com/p/taglib-mod/
你可以在项目主页上下载修改过的taglib原始代码， 也可以选择下载针对taglibv1.7的patch补丁，也可以下载针对archlinux的AUR包
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7347fe6095a3b28229ebdae2b2d06d5f/" rel="bookmark">
			Ubuntu把关闭窗口按键放到右边
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 相信有很多朋友是先成为为windows用户，然后才能为ubuntu用户的。做为windows用户，对最小化/最大化/关闭按钮放在右边，认为是一件理所当然的事。因此对ubuntu将它们放在左边多少有点不适应。下面让我们在ubuntu中试试如何改变这点： 1. 打开终端，并输入gconf-editor，打开Ubuntu的Configuration Editor对话框。（如果没安装gconf-editor它） 2. 找到”apps/metacity/general”项，在右边的列表中找到”button_layout”键，双击修改它的值为： menu:minimize,maximize,close 3. 保存并关闭Configuration Editor。 done！ 这个键值的语法是这样的： ':'号左边的项目放置于窗口标题栏的左边；右边则放置于右边。','号为项目分隔符。例如：menu,maximize :minimize,close，则是把菜单项和最大化按钮放左边，最小化和关闭按钮放右边。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95c1fa29d3e2d230381629623e8fff1a/" rel="bookmark">
			改变你的人生的32句经典句子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 01、大多数人想要改造这个世界，但却罕有人想改造自己。 02、积极的人在每一次忧患中都看到一个机会，而消极的人则在每个机会都看到某种忧患。 03、莫找借口失败，只找理由成功。(不为失败找理由，要为成功找方法) 04、伟人之所以伟大，是因为他与别人共处逆境时，别人失去了信心，他却下决心实现自己的目标。 05、世上没有绝望的处境，只有对处境绝望的人。 06、当你感到悲哀痛苦时，最好是去学些什么东西。学习会使你永远立于不败之地。 07、世界上那些最容易的事情中，拖延时间最不费力。 08、人之所以能，是相信能。 09、一个有信念者所开发出的力量，大于99个只有兴趣者。 10、每一发奋努力的背后，必有加倍的赏赐。 11、人生伟业的建立，不在能知，乃在能行。 12、任何的限制，都是从自己的内心开始的。 13、含泪播种的人一定能含笑收获。 14、欲望以提升热忱，毅力以磨平高山。 15、一个能从别人的观念来看事情，能了解别人心灵活动的人永远不必为自己的前途担心。 16、一个人最大的破产是绝望，最大的资产是希望。 17、不要等待机会，而要创造机会。 18、如果寒暄只是打个招呼就了事的话，那与猴子的呼叫声有什么不同呢? 事实上，正确的寒暄必须在短短一句话中明显地表露出你对他的关怀。 19、昨晚多几分钟的准备，今天少几小时的麻烦。 20、做对的事情比把事情做对重要。 21、人格的完善是本，财富的确立是末。 22、没有一种不通过蔑视、忍受和奋斗就可以征服的命运。 23、行动是治愈恐惧的良药，而犹豫、拖延将不断滋养恐惧。 24、没有天生的信心，只有不断培养的信心。 25、只有一条路不能选择——那就是放弃的路;只有一条路不能拒绝——那就是成长的路。 26、人性最可怜的就是：我们总是梦想着天边的一座奇妙的玫瑰园，而不去欣赏今天就开在我们窗口的玫瑰。 27、征服畏惧、建立自信的最快最确实的方法，就是去做你害怕的事，直到你获得成功的经验。 28、失败是什么?没有什么，只是更走近成功一步;成功是什么?就是走过了所有通向失败的路，只剩下一条路，那就是成功的路。 29、让我们将事前的忧虑，换为事前的思考和计划吧! 30、再长的路，一步步也能走完，再短的路，不迈开双脚也无法到达。 31、任何业绩的质变都来自于量变的积累。 32、成功不是将来才有的，而是从决定去做的那一刻起，持续累积而成。 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/315/">«</a>
	<span class="pagination__item pagination__item--current">316/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/317/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>