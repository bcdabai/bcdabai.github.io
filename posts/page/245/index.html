<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce8296151bfb2a820fbd4f7ed391a620/" rel="bookmark">
			npm ERR! code 128
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解决办法：
执行
git config --globalurl."https://".insteadOfgit:// npm cache clean --force 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8093dc2b25fd46cf129eb77ca6bc7c87/" rel="bookmark">
			JAVA深入浅出（一）：理解RxJava Subject用法及原理分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 本文将尽可能将RxJava中的Subject相关类的用法做一个阐述，并对其原理进行简单的解析。
说到Subject，很多人可能都不是很熟悉它，因为相对于RxJava的Observable、Schedulers、Subscribes等关键字来讲，它抛头露面的场合似乎很少。
事实上，Subject作用是很大的，借用官方的解释，Subject在同一时间内，既可以作为Observable，也可以作为Observer:
在RxJava2.x中，官方一共为我们提供了以下几种Subject：
ReplaySubject （释放接收到的所有数据）BehaviorSubject （释放订阅前最后一个数据和订阅后接收到的所有数据）PublishSubject （释放订阅后接收到的数据）AsyncSubject （仅释放接收到的最后一个数据）SerializedSubject（串行Subject）UnicastSubject (仅支持订阅一次的Subject)TestSubject（已废弃，在2.x中被TestScheduler和TestObserver替代） 下面依次对以上的Subject进行讲解，本文将重点讲解BehaviorSubject和PublishSubject。前者是RxLifecycle中核心类所使用到，后者则是RxBus实现事件总线的核心类。
在开始正文之前，我们需要搞清楚一个问题：
Subject是什么？ Subject在ReactiveX是作为observer和observerable的一个bridge或者proxy。因为它是一个观察者，所以它可以订阅一个或多个可观察对象，同时因为他是一个可观测对象，所以它可以传递和释放它观测到的数据对象，并且能释放新的对象。
上文已经说的很清楚了，它既可以是数据源observerable，也可以是数据的订阅者Observer。
我们点开源码：
public abstract class Subject&lt;T&gt; extends Observable&lt;T&gt; implements Observer&lt;T&gt; { ... } 可以看到，Subject实际上还是Observable，只不过它继承了Observer接口，可以通过onNext、onComplete、onError方法发射和终止发射数据。
我们从不同种类的Subject展开来讲：
一、ReplaySubject 介绍 该Subject会接收数据，当被订阅时，将所有接收到的数据全部发送给订阅者。
这意味着，不管何时订阅这个Subject，这个Subject会把它接收到的数据都发送出去：
ReplaySubject&lt;Object&gt; subject = new ReplaySubject&lt;&gt;(); subject.onNext("one"); subject.onNext("two"); subject.onNext("three"); subject.onComplete(); // both of the following will get the onNext/onComplete calls from above subject.subscribe(observer1); subject.subscribe(observer2); 一图顶千言,下方的箭头代表两次不同时间的订阅：
ReplaySubject
很显然，无论是在接收到数据前还是数据后订阅，ReplaySubject都会发射所有数据给订阅者。
原理 事实上，每个Subject的实现都不可避免的涉及到线程安全的问题，而RxJava则是依靠在内部使用原子操作类（AtomicXXX系列）保证线程安全，本文不深入讨论原子操作类相关知识，有兴趣的朋友可以参考：
深入分析Java中的原子操作 @码农一枚
ReplaySubject类时Subject相关类中代码最多的一个类，但这并不意味着这个类是最难理解的，相反，它的原理很直白：通过一个List动态存储所有接收到的数据，当被订阅时，将所有的数据都发送给订阅者。
是不是觉得很熟悉？是的，其根本就是一个动态的链表，甚至其创建时的基础容量也是16，并且随着数据的不断增加，每次递增50%，如果想要节省开支，也可以自己定义初始容量和递增规则。
千余行的代码并非上述总结的那么简单，不过作为了解和使用已经足够，事实上，这其中绝大部分都是算法和数据结构的处理，笔者研究源码时，也并没有去深入分析源码，只是浅尝辄止。
二、BehaviorSubject 当Observer订阅了一个BehaviorSubject，它一开始就会释放Observable最近释放的一个数据对象，当还没有任何数据释放时，它则是一个默认值。接下来就会释放Observable释放的所有数据。如果Observable因异常终止，BehaviorSubject将不会向后续的Observer释放数据，但是会向Observer传递一个异常通知。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8093dc2b25fd46cf129eb77ca6bc7c87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97b73da5efab7361f37aee918f869e57/" rel="bookmark">
			SOCKET编程之connect应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.背景
最近在项目中需要高效率的扫描出各个服务器开放了哪些端口，第一反应是用ping去做，而ping是能检测网络连通性，不能判断是否开放了端口。端口属于osi七层模型中的传输层，因此需要使用ip+端口来实现，所以使用connect来实现。针对TCP协议，connect函数要进行TCP三次握手，如果connect成功，则说明服务器开放了某个端口，如果connect失败，则说明服务器没有开放某个端口。而connect失败是通过超时来控制的，在规定的时间内，connect会发起多次连接，一直执行到超时，才返回错误。默认情况下，connect是阻塞的，而且默认的超时时间为75s，正常情况下，检测网络的连通性都是毫秒级，如果要判断10万台服务器的，用阻塞的默认的connect去做，效率非常低下。因此采用非阻塞的connect，而且需要自定义超时间（我自定义超时时间为5s）。
2、非阻塞connect
对于阻塞式套接字，调用connect函数将激发TCP的三次握手过程，而且仅在连接建立成功或者出错时才返回；对于非阻塞式套接字，如果调用connect函数会之间返回-1（表示出错），且错误为EINPROGRESS，表示连接建立，建立启动但是尚未完成；如果返回0，则表示连接已经建立，这通常是在服务器和客户在同一台主机上时发生。
select是一种IO多路复用机制，它允许进程指示内核等待多个事件的任何一个发生，并且在有一个或者多个事件发生或者经历一段指定的时间后才唤醒它。connect本身并不具有设置超时功能，如果想对套接字的IO操作设置超时，可使用select函数。
对于select和非阻塞connect，注意两点：[1] 当连接成功建立时，描述符变成可写； [2] 当连接建立遇到错误时，描述符变为即可读，也可写，遇到这种情况，可调用getsockopt函数。
3、实现步骤
（1） 创建socket，并利用fcntl将其设置为非阻塞
（2） 调用connect函数，如果返回0，则连接建立；如果返回-1，检查errno ，如果值为 EINPROGRESS，则连接正在建立。
（3） 为了控制连接建立时间，将该socket描述符加入到select的可读可写集合中，采用select函数设定超时。
（4） 如果规定时间内成功建立，则描述符变为可写；否则，采用getsockopt函数捕获错误信息
（5） 恢复套接字的文件状态并返回。
测试代码如下所示：
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; /* See NOTES */ #include &lt;sys/socket.h&gt; #include &lt;netinet/in.h&gt; #include &lt;fcntl.h&gt; #include &lt;errno.h&gt; int main(int argc, char **argv) { if (argc &lt; 3) { printf("please input ip and port, for example ./main 120.12.34.56 80.\n"); return -1; } char *ipaddr = argv[1]; unsigned int port = atoi(argv[2]); int fd = 0; struct sockaddr_in addr; fd_set fdr, fdw; struct timeval timeout; int err = 0; int errlen = sizeof(err); fd = socket(AF_INET,SOCK_STREAM,0); if (fd &lt; 0) { fprintf(stderr, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97b73da5efab7361f37aee918f869e57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da8fb6f80195e9f3835f04398f2e4555/" rel="bookmark">
			wxpy 扫码登录微信 报错: KeyError: &#39;pass_ticket&#39;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用wxpy开发微信聊天机器人，运行扫码登录后，提示：
KeyError: 'pass_ticket' wxpy是根据网页版微信的API封装的库，所以去网页版微信扫码试试能否正常登录。
如果这种提示，该微信号就不能使用wxpy登录了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df91dfeb505373329b60aa01a9866ac7/" rel="bookmark">
			如何从2D图像生成3D模型（点云）（基于深度相机的传统算法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 普通相机环绕带有BCH码标识的目标物体拍摄大量图片也是可以构建3D模型的
本文探讨基于深度相机拍摄的图片
准备工作 1.深度相机,并标定其内参和畸变
2.BCH码图片（我的博客里面有图片可以下载）
3.你的目标物体（注意不要带有反光的金属、或者透明的部分，因为会导致在深度图不准确）
备注：还要记得查看一下深度相机的工作距离，了解一下它的性能，一般深度相机都是以相机本身为原点建立世界坐标系的，且离z轴越近精度越高，有些深度相机的RGB图和深度图不是完全对应的，要经过畸变矫正一下
采集图像 1.将目标物体放置于BCH码上，不同角度拍摄图片，保存好深度图和RGB图（或者灰度图也可以）
注意：深度相机最好放在支架上，抖动会造成精度不准，且在拍摄过程中不要移动BCH码和物体的位置
如下图所示：
算法流程 1.将两张拍摄的RGB图进行特征点,将匹配的2D点对应的深度图点云进行匹配,根据内参求取外参,将一幅图的点云转换到另一幅图的点云中,然后进行点云的拼接,把所有其他图的点云都映射到第一幅图的相机坐标系下,进行点云的拼接;
备注:因为深度相机也是具有误差的,如果有些面无法重合的,可以用CloudCompare软件打开,选择edit-&gt;register-&gt;Align,选择确定的对应点(比如BCH码上的点进行匹配),这就可以进行的新的配准.
最终的效果图 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b21a2f2cfdc7c55639ab6de31baf26e/" rel="bookmark">
			攻防世界-pwn1-Writeup
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pwn1 考点：栈溢出，canary绕过
基本情况 程序实现功能是往栈上读写数据。
保护措施 Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) 栈溢出 ...... while ( 1 ) { menu(); v3 = my_input(); switch ( v3 ) { case 2: puts(&amp;s); break; case 3: return 0LL; case 1: read(0, &amp;s, 0x100uLL); // 栈溢出 break; ...... 栈溢出空间还是比较大的。
思路 使用栈溢出覆盖 canary 最后一字节，读取出 canary ，成功绕过 canary 保护。
#leak canary payload = 'a'*0x89 add(payload) show() p.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b21a2f2cfdc7c55639ab6de31baf26e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a711c65e1e50cebb93585b77f081e83/" rel="bookmark">
			Security ❀ HTTPS的认证流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTTPS的认证流程 HTTPS协议根据其认证次数可以分为单向认证和双向认证;
（1）单向认证
客户端向服务器发起请求，其中包含各种SSL参数，并从服务器端拿到证书；客户端将从服务器端获得的证书提交至CA, CA验证该证书的合法性并告知客户端，客户端根据 CA验证结果来确认目标站点的真实性；从服务器端的证书中取出公钥， 利用公钥对客户端产生的密钥加密（对称密钥），利用公钥将加密后的密钥发送到服务器端；服务器端用其私钥解密出数据，即得到客户端发送来的对称密钥， 之后均利用这个对称密钥对传输文件进行加密、解密； 单向认证的特点在于只有客户端对服务器端进行了身份验证 ，而服务器只是对提交过来的加密密钥进行识别并处理 ，而不对客户端的合法性进行验证，这就造成了遭受SSL剥离攻击的隐患；
SSL剥离攻击是针对HTTPS单向认证环境的攻击手段。例如，SSL Strip工具的原理就是劫持用户的请求，并模拟用户来与目标站点建立HTTPS连接。成功连接后利用已立连接的对称密钥解密服务器发送过来的HTTPS，将其中的HTTP再发送给客户端SSL剥离攻击的流程如下图所示 这也是由于单向认证巾服务器并不对客户端的有效性进行检查而造成的。
SSL剥离攻击常用于WiFi劫持、ISP层面的流量劫持等环境，如果在日常站点访问中，经常访问的站点突然由HTTPS 协议变成了HTTP协议，那么就需格外小心类劫持行为对用户的数据会产生较大的危害，同时也会危害到网站的利益。因为用户权益一旦受到损失，用户会降低对网站的信任度，导致网站最终受到损失。因此，在大型站点的高价值业务或者两个站点互联互通时均会利用HTTPS双向验证技术来解决上述安全隐患；
（2）双向认证
相对于单向认证整体流程，HTTPS双向认证主要是在客户端与服务器端的认证部分发生了改变，HTTPS双向认证流程如下所示：
客户端向服务器发起请求，其中包含各种SSL参数，并从服务器端拿到证书；客户端将从服务器获得的证书交由CA，CA验证该证书的合法性并告知客户端，客户端根据CA验证结果来确认目标站点的真实性；服务器要求客户端发送证书并验证，并接受用户的公钥；双方利用对方公钥加密来协商可以支持的传输类型及密码方案；客户端从服务器的证书取出公钥，利用公钥对客户端产生的秘钥加密（对称秘钥），并利用公钥加密后的秘钥发送到服务器；服务器用私钥解密出数据，即得到客户端发送来的对称秘钥，之后所有的内容均利用这个对称秘钥对传输的文件进行加密、解密； 由于客户端没有针对特定网站的秘钥生成机制，因此在双向认证时会要求客户端安装特定的插件，用来实现秘钥的生成，这个过程会给用户带来额外的操作和影响，因此不能适用于全部环境；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ed51e8d6403d90299e3c6b03120fade/" rel="bookmark">
			安装RabbitMQ时出现Plugin configuration unchanged,RabbitMQ服务启动几秒后自动关闭, http://127.0.0.1:15672/页面无法访问一并解答
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.正常情况下的安装步骤
注意在官网安装时,尽量安装新版本,老旧版本会导致各种问题
官网下载地址：http://www.rabbitmq.com/download.html
https://www.rabbitmq.com/install-windows.html#installer
1.1安装erlang
1.2安装RabbitMQ
2.运行
2.1打开控制台
2.2步骤二：激活插件
rabbitmq-plugins.bat enable rabbitmq_management 2.3重启
net stop rabbitmq &amp;&amp; net start rabbitmq 3.访问
3.1输入 http://127.0.0.1:15672/
3.2默认账号登录：guest/ gues
正常情况下在进行上述步骤后就会成功访问rabbit可视化页面并且没有任何报错
3.下面我列举一些常见的错误情况
3.1 没有 ERLANG_HOME 配置
解决方法：配置系统环境变量
3.2拒绝访问，发生系统错误5
解决方案：以管理员运行cmd
3.3不能加载erlang模块
解决办法：重新安装erlang
3.4不能成功启动
问题：端口号占用解决方案：将与RabbitMQ相关的程序都结束，重新启动 3.5服务名无效
问题：RabbitMQ没有安装成功检查：服务中是否有 RabbitMQ 4.问题无法解决,且报错看不明白,请右键此电脑在服务中找到RabbitMQ服务,一定要在这里面找到这个服务
4.1打开管理
4.2找到服务
4.3在这里观察服务会不会自动关闭
(在cmd net start rabbitMQ 下观察到的可能是虚假信息)
5.Plugin configuration unchanged,RabbitMQ
rabbitmq-plugins.bat enable rabbitmq_management 在执行激活插件语句报了这个错误:
Plugin configuration unchanged,RabbitMQ
5.1首先保证第四步已经完成
5.2卸载你的rabbitmq 并且重启计算机解决50%的问题
在卸载前先去进程中关闭你的正在运行exe文件,为了删干净目录,不过直接重启再删也无妨
5.3可能是你的电脑名是中文,所以你需要重命名你的电脑,因为rabbitMQ不支持中文路径
window10 --&gt;设置–&gt;关于—&gt;重命名这台电脑
5.4重启你的电脑,建议关闭再开启,不要使用重启按钮
5.5在C:\Users\用户目录(就是因为这个中文路径)\AppData\Roaming\RabbitMQ这个复制三个文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ed51e8d6403d90299e3c6b03120fade/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/482aec559825603158f8f69d7eafcdc8/" rel="bookmark">
			Python爬取CNKI论文的信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学了2天，简单的来总结一下。因为毕业设计是有关于推荐系统的相关内容，利用python爬取文献库是里面最基础的一步。
代码无任何难度，不懂得直接复制代码上网查询也能明白具体代码的意思。
选择CNKI的原因很简单：
1、知网的网页源代码中，查询的结果是存储在iframe里面的，单纯的python+request是很难读取到iframe里面的内容的。我爬了一个晚上没爬出来。。
2、CNKI的网页源代码中，查询的结果没有iframe等框架，相对来说容易爬取。
1、利用post的方法获取网页信息 CNKI和其他文献库不一样，当你在搜索框里搜索相应的内容的时候，跳转的页面的url还是原先未跳转的url，会出现url为定向的问题。此时不能用urlopen的方式采取get方法进行网页的爬取。我最终选择了request的表单数据提交方式。
2、利用beautifulsoup进行网页相应标签的爬取 beautifulsoup对于网页源代码中的特定标签的读取特别方便，所以最终采用的还是beautifulsoup的方式。
对于我个人的需求，我的爬取论文的情况对应的应该是第一种不包含任何图片，且有关键字提示；第二种不在我的爬取范围之内。
1、在beautifulsoup中，这两种链接的爬取区别区分不明显，且tag高度重合，所以此时我不能用beautifulsoup的find方法去读取a标签。
2、我的想法是一个论文的相应条目分开读取；
可以看出，搜索结果的一条结果，是在一个div class="list-item"里面的；而所有的搜索结果，是在一个div id = "article_result"里面的。所以我们的搜索方案现在就很明确了。
1、先将div id = "article_result"的内容全部爬取，里面包含了所有子的div class=“list-item”
2、针对每个div class=“list-item”，读取里面的论文题目和相关的关键字
为什么我不知觉读取所有的div class=“list-item”？因为通过观察可以发现，并不是所有的div class="list-item"标签里都会包含数据。在div id = "article_result"标签的范围之外，有很多div class="list-item"是不包含数据的。
3、利用beautifulsoup的方法将每个搜索结果读取，存入集合里面 从图片的代码很容易得出，第一个圈的代码，我们需要从里面得出标题数据，数据在title属性里面；第二个圈得出的是关键词，数据在data-key属性里面。这里的解决方案可以利用正则表达式解决。
代码如下所示：
from bs4 import BeautifulSoup from urllib.request import urlopen import re import random import requests url = "http://search.cnki.com.cn/Search/Result" data = {'searchType': 'MulityTermsSearch', 'Content': '基于内容的推荐系统'} #此处的data存储的post所提交的参数，从第一步的图片能看的出来 titles =[] #存储从CNKI读取的所有标题 tags = [] #存储读取的每个标题对应的关键字 res = requests.post(url, data=data) html = res.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/482aec559825603158f8f69d7eafcdc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be5fd52092637ff055f4467afedf5128/" rel="bookmark">
			Java：1&#43;2&#43;3&#43;....&#43;100的和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如题：
public class Summ{ public static void main(String[] args){ int sum = 0; for(int i=1;i&lt;=100;i++) { sum += i; } System.out.println("1+2+3+....+100的和:"+sum); } } 结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b400c70a88b5c7fc57cc0518c7a475f/" rel="bookmark">
			Orcale distinct查询报错：ORA-00932: inconsistent datatypes: expected - got CLOB
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在查询数据库的时候报错：
ORA-00932: inconsistent datatypes: expected - got CLOB 很奇怪，昨天还可以，同样的查询语句，今天怎么就不行了，原来CLOB是Orcale的大数据类型，不支持distinct去重查询，然后再去看表的各个字段数据类型，发现原本有一个是varchar2类型字段被不知道谁改成了CLOB的类型，导致这个错误。
问题找到了，现在就来解决，数据类型被改了那我就重新把他改回去不就可以了，于是：
alter table tablename modify (field varchar2(200)); 然后很荣幸又遇到了问题
ORA-22859: invalid modification of columns 为什么呢，因为CLOB这个大数据类型不允许直接修改它的数据类型，真的是好坑，只能先删除，再添加新字段进去
alter table tablename drop column field ; alter table tablename add(field varchar2(200)); 最后，再查询就没问题了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6747d093310aea6b47c8d73d7f989564/" rel="bookmark">
			vue 3.0&#43; antd
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为之前react一直使用antd，转vue后，还是想用顺手的样式，所以又开始连接antd
我连了一天，把vue.config.js配置了一遍，出现了各种报错，没有连上准备放弃的时候，突然连上了！！！
连接方法其实很简单，奈何我太菜
首先是vue less 先通过vue add style-resources-loader插件方式安装style-resources-loader，选择less
然后修改vue.config.js
emmm这个文件在vue3.0里面没有，所以大家可以自己在根目录下面建一个
vue-cli配置指南官网
const path = require('path') const resolve = dir =&gt; { return path.join(__dirname, dir) } module.exports = { // ... pluginOptions: { 'style-resources-loader': { preProcessor: 'less', patterns: [ resolve('path/to/global.less') ] } } } 这个时候你就发现已经可以使用less样式了
导入antd yarn add ant-design-vue 然后将antd引入到main.js中，这种方法是将antd全部导入到项目中，如果想要按需导入请移步官网antd
import Vue from 'vue' import App from './App.vue' import store from './store' import router from './router' import Antd from 'ant-design-vue'; import 'ant-design-vue/dist/antd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6747d093310aea6b47c8d73d7f989564/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc31b0ad08529c6ba47d25c078d03048/" rel="bookmark">
			Ubuntu18.04&#43;GTX 1050ti显卡驱动安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu18.04显卡驱动安装 本人小白一个，折腾了好久，才把显卡驱动装上，先说下本机具体配置吧：
ubuntu18.04LTS系统+Dell7567-1050TI显卡。
在安装的过程中我最终通过下面这种办法安装成功，总共的安装过程分为两步：
在开始安装之前，先执行以下步骤： 先确保本机上没有未卸载干净的NVIDIA的驱动，执行以下命令：
sudo apt-get remove --purge nvidia* Ubuntu 系统默认安装好是使用的一个开源的驱动：nouveau，我们要安装官方的驱动需要先禁用这个开源驱动，以上两条命令就是禁用这个开源驱动。
sudo bash -c "echo blacklist nouveau &gt; /etc/modprobe.d/blacklist-nvidia-nouveau.conf" sudo bash -c "echo options nouveau modeset=0 &gt;&gt; /etc/modprobe.d/blacklist-nvidia-nouveau.conf" 执行完上面两条指令后，我们使用如下命令看看是否成功禁用了开源驱动：
cat /etc/modprobe.d/blacklist-nvidia-nouveau.conf 如果和下面一样，表示成功了：
$ cat /etc/modprobe.d/blacklist-nvidia-nouveau.conf blacklist nouveau options nouveau modeset=0 1、添加PPA源 sudo add-apt-repository ppa:graphics-drivers/ppa sudo apt-get update 安装方法一：
（1）使用ubuntu自动安装命令进行安装 sudo ubuntu-drivers autoinstall 即可完成安装。
（2）安装指定版本的驱动： 首先，查看推荐的驱动版本：
执行：ubuntu-drivers devices
第二步，执行安装命令，自己指定安装驱动版本。
sudo apt-get install nvidia-driver-440#我这里安装的是440的驱动版本。 3、使用nvidia-smi命令查看安装结果。 结果如下：
另外，显卡驱动安装可能每个人的情况都不一样，在这里向大家推荐一篇讲得不错的安装博客：
https://blog.csdn.net/ghw15221836342/article/details/79571559
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77f595cdb63ad6cec8ce08b07d0f0498/" rel="bookmark">
			Leetcode——每日一题T43.字符串相乘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 class Solution: def str_2_num(self,s): return ord(s)-ord('0') def multiply(self, num1: str, num2: str) -&gt; str: a = num1[::-1] b = num2[::-1] result = 0 for i, n1 in enumerate(a): temp_num = 0 for j,n2 in enumerate(b): temp_num += self.str_2_num(n1)*self.str_2_num(n2)*10**j result += temp_num*10**i return str(result) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37c59c787e5e3b0af39c497610b6b8aa/" rel="bookmark">
			hive初始化过去但是执行hive命令时报异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		执行hive时报如下异常
[hadoop@namenode ~]$ hive
which: no hbase in (/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/hadoop/.local/bin:/home/hadoop/bin:/usr//java/jdk-14.0.1/bin:/usr/local/hadoop/bin:/usr/local/hadoop/sbin:/usr/local/hive/bin)
SLF4J: Class path contains multiple SLF4J bindings.
SLF4J: Found binding in [jar:file:/usr/local/hive/lib/log4j-slf4j-impl-2.10.0.jar!/org/slf4j/impl/StaticLoggerBinder.class]
SLF4J: Found binding in [jar:file:/usr/local/hadoop/share/hadoop/common/lib/slf4j-log4j12-1.7.25.jar!/org/slf4j/impl/StaticLoggerBinder.class]
SLF4J: See http://www.slf4j.org/codes.html#multiple_bindings for an explanation.
SLF4J: Actual binding is of type [org.apache.logging.slf4j.Log4jLoggerFactory]
Hive Session ID = 7bb00c5d-c9bc-4927-acfa-040652f3570d
Exception in thread "main" java.lang.ClassCastException: class jdk.internal.loader.ClassLoaders$AppClassLoader cannot be cast to class java.net.URLClassLoader (jdk.internal.loader.ClassLoaders$AppClassLoader and java.net.URLClassLoader are in module java.base of loader 'bootstrap')
at org.apache.hadoop.hive.ql.session.SessionState.&lt;init&gt;(SessionState.java:413)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37c59c787e5e3b0af39c497610b6b8aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e692393d2506d7c6db0f0022cb79e96/" rel="bookmark">
			Leetcode——每日一题T14. 最长公共前缀（zip函数法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		法一：正向法（增加字符串） class Solution: def longestCommonPrefix(self, strs: List[str]) -&gt; str: if strs ==[]: return '' result = '' a = strs[0] for temp in strs: if len(temp) &lt; len(a): a = temp for i in range(len(a)): for j in range(len(strs)): if a[i] != strs[j][i]: return result result += a[i] return result 法二：逆向法（缩短字符串） class Solution: def longestCommonPrefix(self, strs: List[str]) -&gt; str: if strs ==[]: return '' a = strs[0] for i in range(len(strs)): while strs[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e692393d2506d7c6db0f0022cb79e96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cc002de4f510e60daee159c188e7137/" rel="bookmark">
			Caused by: com.mysql.cj.exceptions.CJException: Access denied for user &#39;root&#39;@&#39;localhost&#39; (using pas
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Caused by: com.mysql.cj.exceptions.CJException: Access denied for user 'root'@'localhost' (using password: YES)
java项目启动报这个错说白了就是你的项目application.yml或者（properties）里面的配置数据源信息密码不对。可以用数据库客户端工具连接一下，是否能连通，连不通说明密码有问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b53c2b0617024918fbc8cbd2a0ff0565/" rel="bookmark">
			github &#43; jsdeliver &#43; picgo 搭建免费cdn
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		github搭建免费cdn github + jsdeliver 手动上传资源发布github + jsdeliver + picgo床图 仓库地址： https://github.com/luchuanqi/cdn github + jsdeliver 手动上传资源发布 点击release发布
定义版本号及其发布
https://cdn.jsdelivr.net/gh/luchuanqi/cdn/js/dragula.modify.js github + jsdeliver + picgo床图 新建repository 2. 设置
1. setting
2. developer settings
3. create token
4. copy token
3. 安装picgo
+ 设定仓库名：按照【用户名 / 图床仓库名】的格式填写
+ 设定分支名：【master】
+ 设定Token：粘贴之前生成的【Token】
+ 指定存储路径：填写想要储存的路径，如【img/】，这样就会在仓库下创建一个名为 img 的文件夹，图片将会储存在此文件夹中
+ 设定自定义域名:
demo https://cdn.jsdelivr.net/gh/用户名/图床仓库名/图片路径 https://cdn.jsdelivr.net/gh/luchuanqi/cdn/images/test/1.jpg
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10c88edc60e7a864b3873cb3a2e74095/" rel="bookmark">
			REST与Apache Camel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Camel中公开HTTP终结点的方法有很多：jetty，tomcat，servlet，cxfrs和restlet。 其中的两个组件– cxfrs和restlet也只需几行代码即可支持REST语义。 这个简单的示例演示了如何使用camel-restlet和camel-jdbc进行CRUD操作。 四个HTTP动词执行不同的操作，并映射到以下单个URI模板： POST –创建一个新用户： / user GET –请求URI指定的用户的当前状态： / user / {userId} PUT –使用新信息更新给定URI上的用户 ： / user / {userId} 删除–删除由给定URI标识的用户： / user / {userId} 还有一个/ users URI，它返回所有用户，无论使用哪种HTTP方法。 用Camel创建这样的应用程序很简单。 添加所有必要的依赖项（restlet，spring，jdbc…）后，配置web.xml来加载Camel上下文： &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:camel-config.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt; &lt;/listener&gt; 并映射Restlet servlet &lt;servlet&gt; &lt;servlet-name&gt;RestletServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.restlet.ext.spring.SpringServerServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;org.restlet.component&lt;/param-name&gt; &lt;param-value&gt;RestletComponent&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;RestletServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/rs/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 在Spring上下文中，还有更多的Restlet和一个内存中的数据源设置代码： &lt;bean id="RestletComponent" class="org.restlet.Component"/&gt; &lt;bean id="RestletComponentService" class="org.apache.camel.component.restlet.RestletComponent"&gt; &lt;constructor-arg index="0"&gt; &lt;ref bean="RestletComponent"/&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; &lt;jdbc:embedded-database id="dataSource" type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10c88edc60e7a864b3873cb3a2e74095/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/405787bc6a23a1eae19f30f8110354b5/" rel="bookmark">
			压力传感器原理与组成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		压力传感器原理与组成
压力传感器是检测压力，并将压力信号转换为电信号并成线性输出的装置。压力传感器可分为机械压力传感器和气压（液压）传感器。
机械压力传感器也就是测力传感器，单位通常为N、KN、KGf等等。
沧正机械压力传感器为电阻应变片式，主要由弹性体、电阻应变片、测量电路和传输电缆4部分组成。
应变片式压力传感器测量原理：当压力传感器弹性体在外力的作用下产生形变，附着于弹性体上的电阻应变片随即弯曲，电阻应变片阻值发生变化，再经测量电路将阻值变化转换为电信号（一般为毫伏信号）。
弹性体：弹性体即压力传感器外壳，主要材质有铝合金、合金钢、不锈钢。
电阻应变片：电阻应变片压力是传感器最重要的组成部分，常用的应变片基材采用高分子薄膜材料，应变材质通常为高纯度康铜 。电阻应变片通过脱水粘贴在弹性体上，弹性体受力形变，应变片随即跟着形变，从而改变电阻值。
测量电路：通过惠斯登电桥把电阻应变片的电阻变化转变为毫伏信号输出。
传输电缆：4芯屏蔽电缆，沧正压力传感器为红黑绿白四线，红：电源+，黑：电源-；绿：信号+，白：信号-。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e709d5f6d77553b609caec81e05e8467/" rel="bookmark">
			UnicodeDecodeError: &#39;utf-8&#39; codec can&#39;t decode byte 0xc7 in position 0: invalid continuation byte
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【写在前面】 今天在做说stm32和服务器之间的通信时因为编码格式问题导致了一些错误做个记录；
测试时搭载在云服务器上的python socket通讯模块数据接收部分代码如下：
receive_data = serObj.recv(1024).decode('utf-8') 运行下来直接报错：
UnicodeDecodeError: ‘utf-8’ codec can’t decode byte 0xc7 in position 0: invalid continuation byte
【解决方案】 - 把编码方式utf-8 修改为gb18030
【测试结果】 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc45e4c8b67c2ebb3b2e11779d4e6611/" rel="bookmark">
			12.1 scrapy-Redis安装和启动---scrapy爬虫初学者学习过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内容：Redis内容 + Redis安装（Windows） + 启动Redis（Windows） + RedisDesktopManager查看 作者：Irain
QQ：2573396010
微信：18802080892
视频资源链接：https://www.bilibili.com/video/BV1P4411f7rP?p=100
目录 内容：Redis内容 + Redis安装（Windows） + 启动Redis（Windows） + RedisDesktopManager查看1 Scrapy-Redis分布式爬虫内容2 Redis教程内容3 Linux系统安装Redis4 在window安装Redis4.1 安装Redis4.2 在cmder shell 启动Redis4.3 启动Redis服务器时的问题 5 RedisDesktopManager5.1 连接Redis服务器5.2 启动Redis客户端5.3 在RedisDesktopManager查看客户端名字 1 Scrapy-Redis分布式爬虫内容 2 Redis教程内容 3 Linux系统安装Redis 4 在window安装Redis Redis下载链接：https://github.com/MicrosoftArchive/redis/releases
压缩包（有Redis-x63-3.2.1、Redisdesktopmanager-0.9.0559）链接（速度快）：https://www.baidupcs.com/rest/2.0/pcs/file?method=batchdownload&amp;app_id=250528&amp;zipcontent=%7B%22fs_id%22%3A%5B%22805678180890049%22%5D%7D&amp;sign=DCb740ccc5511e5e8fedcff06b081203:xLzu3K6WCrEJLM5xBMeFYKLGxno%3D&amp;uid=1010914100&amp;time=1589344726&amp;dp-logid=3073673546417224558&amp;dp-callid=0&amp;shareid=2998177945&amp;vuk=2940921580&amp;from_uk=1010914100&amp;zipname=window%E7%89%88%E7%9A%84redis%E5%8E%8B%E7%BC%A9%E5%8C%85.zip
4.1 安装Redis 4.2 在cmder shell 启动Redis cmder-1.3.4下载和安装的链接：https://blog.csdn.net/weixin_42122125/article/details/106073984
4.3 启动Redis服务器时的问题 解决方法链接：https://blog.csdn.net/weixin_42122125/article/details/106074823
5 RedisDesktopManager RedisDesktopManager 下载非官方链接：http://www.downza.cn/soft/210734.html
正常安装，没有特殊步骤。安装后，需要注册账号。只有14天免费使用。
RedisDesktopManager安装、使用链接（内容差不多）：https://blog.csdn.net/weixin_42122125/article/details/106075676
5.1 连接Redis服务器 5.2 启动Redis客户端 5.3 在RedisDesktopManager查看客户端名字 发布：2020年5月12日
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e3fae3046b6a0dd49788bca81fbe91e/" rel="bookmark">
			too many arguments to function &#39;strcpy&#39;解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题背景 今天在学习C语言的字符串的拷贝函数，下图为知识点：
还有第五条：是说可以复制字符串2的部分字符到字符数组1的前几个字符。
语法：srtcpy（字符数组1，字符串2，整数）
但是当我运行下图程序后，就报错了：
是因为参数太多了，strcpy函数只有两个参数。
问题解决 在我查完资料后发现，嗯，没错，课件错了😥😥😥
真是个令人尴尬的事实，不过也告诉我们一个道理：不要盲目相信权威🤐
咳咳，回归正题。所以解决办法是：神奇的strncpy函数
语法：strncpy（字符数组1，字符串2，整数）
Demo：
另外：如果想把字符串2复制到字符数组1的特定位置，也可以这么写：
问题总结 emmm，写到最后，可能我写的有点文不对题。
嘿嘿，我就是写一下我的思路，免得有和我犯一样错误的小伙伴，找不到解决办法。
如果单纯就是参数不小心写多了，删掉就ok了。🏃‍♂️🏃‍♂️🏃‍♂️
如有问题请私聊。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1d8ac96df27d39f27effc48b561036e/" rel="bookmark">
			使用java实现HTTP的GET请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在前几节我们详细讲解了http协议的相关信息，基于“知行合一”的原则，只有通过具体动手实践才有可能检验知识点被我们真正掌握，本节我们就使用代码实现http的get请求。
首先需要一个http服务器，基于简单原则，我使用了在手机上的福昕pdf阅读器iPhone版，安卓版效用一样，它自身附带了小型http服务器，用于将文档从电脑传给手机，打开该App，在菜单中选择Wi-Fi，点击“允许文件传输”即可启动http服务器，然后在浏览器中输入“http://192.168.2.127:8888"，其中192.168.2.127是我手机的ip，也对应http服务器的ip，8888是服务器接收请求的端口，输入URL点击后，浏览器会接收到请求回应并展现如下：
使用它的好处在于足够简单，并且它有文件上传功能，于是后面我们还可以用来实现POST请求，接下来我们使用代码模拟客户端向它发送GET请求，首先实现的是http数据包组装和解析功能：
package Application; import java.util.*; public class HTTPEncoder { public enum HTTP_METHOD { HTTP_GET, HTTP_HEADER, HTTP_POST, HTTP_OPTIONS }; private String http_method = ""; private String http_header = ""; private Map&lt;String, String&gt; http_header_map = new HashMap&lt;String, String&gt;(); public void set_method(HTTP_METHOD method, String url) {//构造http 请求方法字符串 switch (method) { case HTTP_GET: http_method = "GET "; break; case HTTP_HEADER: http_method = "HEADER "; break; case HTTP_POST: http_method = "POST "; break; case HTTP_OPTIONS: http_method = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1d8ac96df27d39f27effc48b561036e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/855aefe4986c0830a2799c2229442a35/" rel="bookmark">
			linux驱动开发——设备树节点转化为platform_device节点并与驱动匹配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、设备树节点转化为platform_device的过程1、dts文件转化过程2、dts中的节点转化为platform_device节点的条件 二、设备树节点转化为platform_device后匹配驱动的过程1、转化之后节点信息的保存2、匹配驱动 一、设备树节点转化为platform_device的过程 1、dts文件转化过程 dts文件编译成为dtb文件之后供给内核解析，设备树中的每个节点都会转化为device_node节点，其中满足某些条件的节点将会被转化为platform_device节点
2、dts中的节点转化为platform_device节点的条件 只需包含下面的任意一个条件就能转化为platform_device节点
（1）根节点下的含有compatible属性的子节点，compatible属性是用于匹配驱动
如：节点key1和节点led将会被转回为platform_device节点
（2）如果节点中的compatible属性包含了"simple-bus"或者"simple-mdf"或者"isa"或者"arm,amba-bus"，并且该节点的子节点包含compatible属性，那么该子节点就能转化为platform_device节点（IIC、SPI节点下的子节点即使满足条件也不应被转化为platform_device节点，应该交由对应的总线驱动程序去处理，而不是platform总线）
二、设备树节点转化为platform_device后匹配驱动的过程 1、转化之后节点信息的保存 设备树节点在转化为platform_device 节点之后
信息保存在 patform_device -&gt; dev -&gt; of_note节点中
of_node是一个device_node结构体，里面存放着节点的name、type和properties（属性链表）
2、匹配驱动 在platform_driver-&gt;driver中，有一个of_match_table成员，是一个of_device_id的结构体数组，每一个数组元素都存放着name、type和compatible用于匹配设备树节点生成的platform_device
匹配时：
（1）匹配patform_device -&gt; dev -&gt; of_note-&gt;properties(属性)-&gt;compatible属性的值 与platform_driver-&gt;driver-&gt;of_match_table中每一个节点-&gt;compatible成员的值 ，成功则关联
（2）匹配patform_device -&gt; dev -&gt; of_note-&gt;type 与platform_driver-&gt;driver-&gt;of_match_table中每一个节点-&gt;type成员的值 ，成功则关联
（3）匹配patform_device -&gt; dev -&gt; of_note-&gt;name 与 platform_driver-&gt;driver-&gt;of_match_table中每一个节点-&gt;name成员的值 ，成功则关联
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ad5c6c8f2323d82cbdc552d70976f03/" rel="bookmark">
			Vue-cli3 webpack配置 vue.config.js （基础版本&#43;进阶版本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：基础版本 不需要多于插件优化，可以提供基础配置服务即可 开箱即用 const path = require('path') const isPro = process.env.NODE_ENV === 'production' //环境标识 const resolve = dir =&gt; { return path.join(__dirname, dir) } module.exports = { // 基本路径 publicPath: './', // 打包输出文件目录 outputDir: 'dist', // 打包静态资源目录 (js, css, img, fonts) assetsDir: 'assets', // index.html 输出路径 indexPath: 'index.html', // 保存时检查代码 lintOnSave: !isPro, // 生产环境 source map productionSourceMap: false, // webpack 链式操作 chainWebpack: config =&gt; { config.resolve.alias .set('@', resolve('src')) .set('_view', resolve('src/views')) //每个模块的vue页面 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ad5c6c8f2323d82cbdc552d70976f03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb19326c546ac672324b34b9ea29e47f/" rel="bookmark">
			访问服务器本地端口/网址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如在服务器上的本地网址:http://localhost:8081/
当想早自己电脑浏览器上访问时：
利用ufw开放端口
安装：yum -y install ufw
ufw enable 开放端口：
ufw allow 8081 服务器添加安全组
3 .访问
网址：xx.xx.xx.xx(服务器公网IP):8081
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30f9446a167b171b783c346f86a78550/" rel="bookmark">
			阿里免费服务器测试题及答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有的可能不一样，我整理了一些。10中6就可以了。
1、SQL语言的功能包括（B ）
A. 关系规范化、数据操纵、数据控制
B. 数据定义、数据操纵、数据控制
C. 数据定义、关系规范化、数据控制
D. 数据定义、关系规范化、数据操纵
2、逻辑题：B、C、X为不等的数，当B大于C时，X小于C；但是C绝不会大于B。下面描述正确的是（ A）
A. X绝对不会大于B
B. X绝对不会小于B
C. X绝对不会小于C
3、PAAS是（A ）
A. Platform as a service
B. Infrastructure as a service
C. Software as service
D. Fuction as service
4、云计算时代，客户应该如何应对互网联的安全风险？(A)
A. 建立完善的安全体系
B. 部署入侵检测系统
C. 委托第三方专业公司管理
D. 部署DDoS防护系统
5、HTTPS协议在互联网应用中起到的安全作用是（B ）
A. 保存到WEB服务器上的数据会自动加密
B. 确保浏览器与WEB服务器之间的数据传输安全
C. 确保WEB服务器端的数据不会被篡改
D. 减少SQL注入的风险
​6、IaaS是（B ）的缩写。
A. Platform as a service
B. Infrastructure as a service
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30f9446a167b171b783c346f86a78550/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6667c90045f5df5756a99862ca905b2/" rel="bookmark">
			ImportError: /lib64/libstdc&#43;&#43;.so.6: version `GLIBCXX_3.4.21&#39; not found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用的服务器
系统为：centos7 cuda10.1
安装pytorch1.3.1+torchvison0.4.2、pytorch1.4.0+torchvison0.5.0、
pytorch1.3.0+torchvison0.4.1
测试都能通过，但是都会报下面的错误：
ImportError: /lib64/libstdc++.so.6: version `GLIBCXX_3.4.21' not found (required by /gs/home/wangrp/anaconda/envs/tf115py131_srun/lib/python3.6/site-packages/scipy/_lib/_uarray/_uarray.cpython-36m-x86_64-linux-gnu.so) 由于我用的是服务器，无法像下面说的那样修改服务器：
https://blog.csdn.net/luoww1/article/details/51509298
也试过下面的方法并不可行
https://blog.csdn.net/qq_29695701/article/details/86292961
最终解决办法：
由于我是在anaconda3下面建的virtual env，所以我先用先安装的conda install cudatoolkit=10.0，命令如下：
conda install cudatoolkit=10.0 之后安装
pip install torch-1.1.0-cp36-cp36m-linux_x86_64.whl pip install torchvision-0.3.0-cp36-cp36m-linux_x86_64.whl pip install tensorflow-gpu==1.15 这样不光解决了上述问题，也 解决了tensorflow-gpu2.0以下版本不兼容cuda10.1的问题（不兼容会导致宝下面的错误）
出现的不兼容cuda10.1的问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1591f4b610492b1e87606cf5084610f8/" rel="bookmark">
			Socket错误详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.端口号设置错误；
2.服务器没有处于监听状态 （即ServerSocket –&gt;Active=true）；
3.数据包被服务器端的防火墙过滤掉。
附：Socket常见错误代码与描述
Socket error 0 – Directly send error Socket error 10004 – Interrupted function //call 操作被终止 Socket error 10013 – Permission denied //c访问被拒绝 Socket error 10014 – Bad address //c地址错误 Socket error 10022 – Invalid argument //参数错误 Socket error 10024 – Too many open files // 打开太多的sockets Socket error 10035 – Resource temporarily unavailable // 没有可以获取的资料 Socket error 10036 – Operation now in progress // 一个阻塞操作正在进行中 Socket error 10037 – Operation already in progress // 操作正在进行中 Socket error 10038 – Socket operation on non-socket //非法的socket对象在操作 Socket error 10039 – Destination address required //目标地址错误 Socket error 10040 – Message too long //数据太长 Socket error 10041 – Protocol wrong type for socket //协议类型错误 Socket error 10042 – Bad protocol option // 错误的协议选项 Socket error 10043 – Protocol not supported //协议不被支持 Socket error 10044 – Socket type not supported //socket类型不支持 Socket error 10045 – Operation not supported //不支持该操作 Socket error 10046 – Protocol family not supported //协议族不支持 Socket error 10047 – Address family not supported by protocol family//使用的地址族不在支持之列 Socket error 10048 – Address already in use //地址已经被使用 Socket error 10049 – Cannot assign requested address //地址设置失败 Socket error 10050 – Network is down //网络关闭 Socket error 10051 – Network is unreachable //网络不可达 Socket error 10052 – Network dropped connection on reset //网络被重置 Socket error 10053 – Software caused connection abort //软件导致连接退出 Socket error 10054 – connection reset by peer //连接被重置 Socket error 10055 – No buffer space available //缓冲区不足 Socket error 10056 – Socket is already connected // socket已经连接 Socket error 10057 – Socket is not connected //socket没有连接 Socket error 10058 – Cannot send after socket shutdown //socket已经关闭 Socket error 10060 – Connection timed out //超时 Socket error 10061 – Connection refused //连接被拒绝 Socket error 10064 – Host is down //主机已关闭 Socket error 10065 – No route to host // 没有可达的路由 Socket error 10067 – Too many processes //进程太多 Socket error 10091 – Network subsystem is unavailable //网络子系统不可用 Socket error 10092 – WINSOCK.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1591f4b610492b1e87606cf5084610f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a92f2529a94d9818369d27a052abe06b/" rel="bookmark">
			《超级转化率》读书笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		完本时间 5月9日
总结
广告投放是找到客户并引导转化的过程，转化率决定了ROI，决定了效益。
转化率是从广告展现到最终成交的全流程，需要做好每一步的精细化运营。
首先是广告展示，需要确定产品定位、竞争的差异点、主打特性。
然后在展示入口上，凸显产品价值 + 稀缺感营造，引导点击。
再在详情页妥善表达，使得用户相信产品，让用户有兴趣继续了解。
配合信任感的建立，稀缺的再度引导，让用户立即发生购买行为或留下意向。
其中所有的过程，都需要持续优化迭代，测试验证，最终提升转化率。
总的来说，虽然大逻辑每个人都了解，但书中还有丰富的案例可供学习，可看的一本书。
前言
1、只有精细到每一步的过程控制，成功才能复制
2、流量转化：精准流量，落地页转化
3、必须细化到每一步的流量漏斗，才能针对性的提升转化率
第一章 超级转化率漏斗模型
1、广告投放是一个判断客户在哪，然后基于投放的数据验证想法的过程
2、超级漏斗是从曝光到成交的全流程，
3、公众号吸引关注：我是做什么的、有什么优势，为什么关注我
4、细化流程，每一步都能够提升转化率。要不断的尝试方法
第二章 客户下单六要素
激发兴趣、建立信任、立刻下单
1、互惠：让用户得到超出预期的实惠，让用户觉得自己赚便宜了
2、承诺和兑现的衔接，上下文联系，让用户相信产品的效果
3、信任状：就是信任背书，找知名人或公司给自己背书
4、畅销好评：从众心理，以用户的真实情况引导购买
5、痛点刺激：强调现状的不舒适和产品能改善的点
6、稀缺：营造稀缺和现在下单
第三章 案例解析
根据产品主打的定位，然后在设计上要凸显出定位
1、猫王收音机：
* 定位：好看。好听。好礼
* 要让人相信好看、好听、好礼是存在的
* 兴趣点：100万好评，+ 现在买送复古包
* 第一版本口红分散注意力，第二版突出从众和现在购买引导
2、无忧保姆：
* 定位：安全保障、工作能力、售后服务
* 难题：让用户相信安全、能力和售后；男女用户都要兼顾； 3、南孚充电宝：
* 根据当前搜索词、和人气，定位产品特性：品牌大、体积小
* 难点：为什么要再买一个；为什么买小的，有多小；够用吗；
* 根据数据不断优化
第四章 大规模的四级增长引擎
1、冷启动跑通产品模型，然后再大规模放量
2、买东西要解决：为什么要买，以及在哪买
* 创造需求
* 满足需求
-END-
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bdfc84c611c3335263e662a3400da39/" rel="bookmark">
			Kubernetes（k8s）认识以及应用（二）——kubeadm多机部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kubernetes（k8s） 使用多机环境kubeadm部署 部署环境
master：192.168.11.25
node1：192.168.11.26
node2：192.168.11.27
准备工作
1.修改主机名
192.168.11.25：hostnamectl set-hostname master
192.168.11.26：hostnamectl set-hostname node1
192.168.11.27：hostnamectl set-hostname node2
2.关闭防火墙、selinux和swap
systemctl stop firewalld &amp;&amp; systemctl disable firewalld
setenforce 0 &amp;&amp; sed -i "s/^SELINUX=enforcing/SELINUX=disabled/g" /etc/selinux/config
swapoff -a &amp;&amp; sed -i 's/.*swap.*/#&amp;/' /etc/fstab
3.添加域名解析：vim /etc/hosts
192.168.11.25 master
192.168.11.26 node1
192.168.11.27 node2
4.配置国内yum源
wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.cloud.tencent.com/repo/centos7_base.repo
wget -O /etc/yum.repos.d/epel.repo http://mirrors.cloud.tencent.com/repo/epel-7.repo
yum clean all &amp;&amp; yum makecache
5.配置国内Kubernetes源：vim /etc/yum.repos.d/k8s.repo
[kubernetes] name=Kubernetes baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/ enabled=1 gpgcheck=1 repo_gpgcheck=1 gpgkey=https://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1bdfc84c611c3335263e662a3400da39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85a16ea8b0bdc3404f5880fbda13b9d7/" rel="bookmark">
			jQuery-常用API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1-jQuery选择器 JQA-01：hide() 作用：隐藏
语法：$(‘名’).hide();
JQ-02:$(document).ready() 作用：入口函数，等着页面加载完成运行函数方法，相当于DOMContentLoaded
语法：$(document).ready(function(){
方法
})
JQA-02S：$() 作用：跟Fun-02作用一致，升级简洁版
语法：$(function(){
方法
})
JQA-04：$(‘选择器’) 作用：原生js获取元素的方式有很多，很杂，而且兼容性不一致，
jq做了封装，是获取统一标准
筛选选择器
$(
function(){
$(‘ul li:odd’).css(‘backgroundColor’,‘red’);
$(‘ul li:even’).css(‘backgroundColor’,‘orangered’);
$(‘ul li:first’).css(‘backgroundColor’,‘yellow’);
$(‘ul li:last’).css(‘backgroundColor’,‘green’);
$(‘ul li:eq(2)’).css(‘backgroundColor’,‘blue’);
}
)
2-jQuery隐式迭代 自动遍历内部DOM元素(伪元素形式存储)的过程就叫做隐式迭代
JQA-05：$(‘名’).css(); 作用：改变元素的css样式
语法：$(‘名’).css(‘属性’，‘值’);
js VS jq 对比实现改变4个div的背景颜色 //js
var div = document.getElementsByTagName(‘div’);
for(let i=0; i&lt;div.length;i++){
div[i].style.backgroundColor = ‘pink’;
}
//jq
$(‘div’).css(‘backgroundColor’,‘pink’)
因为隐式迭代jq一行代码同时改变所有的背景颜色完胜。
3-jQuery筛选方法（重点）
JQA-06：parent(); 作用：查找父级
语法：$(‘名’).parent();
JQA-07：children(); 作用：类似子代选择器 ul&gt;li
语法：$(‘名’).children(‘子代名’);
JQA-08：find(); 作用：类似后代选择器 ul li（可以选择所有的子元素和孙元素）
语法：$(‘名’).find(‘子代名’);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85a16ea8b0bdc3404f5880fbda13b9d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3cce29b987f5e03fd2a6b3de91e5cd7/" rel="bookmark">
			查找算法java实现——二分（折半）查找
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二分查找 一、基本思路二、算法分析三、代码实现 一、基本思路 二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。
基本思路： 首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。
简单来说： 就是递归的把序列分成前后两部分进行查找。
举例：
有一序列1, 8, 10, 89, 1000,1234要求查找序列中是否含有89
计算有序序列的mid=10，由于89&gt;10，所以在序列89，1000，1234中查找计算有序序列的mid=1000，由于89&lt;1000，所以在序列89中查找计算有序序列的mid=89，由于89=89，所以序列含有待查找的值89 二、算法分析 时间： 二分查找要递归的进行折半，所以根据折半的递归树可得二分查找的时间复杂度为O( l o g 2 n {log_2{n}} log2​n)。
空间： 二分查找是在原序列上进行递归折半，无需额外开辟空间，所以空间复杂度为O(1)。
算法平均时间最好情形最差情形空间复杂度备注二分查找O( l o g 2 n {log_2{n}} log2​n)O( l o g 2 n {log_2{n}} log2​n)O( l o g 2 n {log_2{n}} log2​n)O(1)待查表是有序表时才可以使用 三、代码实现 二分查找通常有递归实现以及非递归实现两种。下面将分别进行代码实现：
递归实现：这里利用二分查找给出了两个方法，一个是仅仅查找序列中是否存在指定元素，一个是将序列中所以满足条件的元素的下标都进行返回。 import java.util.ArrayList; import java.util.List; /** * 二分查找（数组必须是有序的） * @author dankejun * @create 2020-05-03 11:38 */ public class BinarySearch { public static void main(String[] args) { int[] arr = {1, 8, 10, 89, 1000,1000,1000,1234}; System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3cce29b987f5e03fd2a6b3de91e5cd7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f27f5338b7922b3d81082a7ff3e0383/" rel="bookmark">
			牛客网 E.弦 初见卡特兰数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目地址
组合数学
答案是 2^n / (n + 1)!。概率可以通过合法方案数/总方案数来计算。合法方案数 f(n)=Σf(i) * f(n-i-1), 即为卡特兰数，故 f(n)=C(2n, n) / (n + 1)。总方案数为 C(2n, 2) * C(2n – 2, 2) … C(2, 2) / n! = (2n)! / n! / 2^n。两者相除即为答案。除法取模的话用逆元来计算（即费马小定理）。 总复杂度O(n)。
卡特兰数讲解
//MADE BY Y_is_sunshine; //#include &lt;bits/stdc++.h&gt; //#include &lt;memory.h&gt; #include &lt;unordered_map&gt; #include &lt;unordered_set&gt; #include &lt;algorithm&gt; #include &lt;iostream&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;sstream&gt; #include &lt;bitset&gt; #include &lt;cstdio&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;cmath&gt; #include &lt;queue&gt; #include &lt;stack&gt; #include &lt;map&gt; #include &lt;set&gt; #define pb push_back #define pf push_front #define INF 0x3f3f3f3f #define MAXN (int) 2e6 + 7 #define all(a) a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f27f5338b7922b3d81082a7ff3e0383/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49a52b7027bdbb4e93fb360e10c93cf7/" rel="bookmark">
			【TF踩坑】ImportError: DLL load failed: 找不到指定的程序。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误信息：
D:\SoftWares-Academic\Anaconda3\envs\tensorflow\python.exe D:/SoftWares-Academic/python_workspace/search-picture/test.py Traceback (most recent call last): File "D:/SoftWares-Academic/python_workspace/search-picture/test.py", line 1, in &lt;module&gt; import h5py #H5py用来管理HDF5数据库文件 File "D:\SoftWares-Academic\Anaconda3\envs\tensorflow\lib\site-packages\h5py\__init__.py", line 34, in &lt;module&gt; from ._conv import register_converters as _register_converters File "h5py\h5r.pxd", line 21, in init h5py._conv (C:\Minonda\conda-bld\h5py_1496879986092\work\h5py\_conv.c:7550) File "h5py\_objects.pxd", line 12, in init h5py.h5r (C:\Minonda\conda-bld\h5py_1496879986092\work\h5py\h5r.c:3236) File "h5py\_objects.pyx", line 1, in init h5py._objects (C:\Minonda\conda-bld\h5py_1496879986092\work\h5py\_objects.c:7762) ImportError: DLL load failed: 找不到指定的程序。 进程已结束，退出代码 1 解决办法：
①根据网上看到的，有博主说是没安装完整的问题，卸载H5PY重装即可。测试了一下不行。
②查看安装包发现，没有卸载干净：把h5py开头的文件删除干净。重新下载。问题解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a0a425545e7590a671a73fdd242aa10/" rel="bookmark">
			【菜鸟进阶之路】P5723 【深基4.例13】质数口袋 - 洛谷
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、题目部分
题目描述
小A 有一个质数口袋，里面可以装各个质数。他从 2 开始，依次判断各个自然数是不是质数，如果是质数就会把这个数字装入口袋。口袋的负载量就是口袋里的所有数字之和。但是口袋的承重量有限，不能装得下总和超过 L(1≤L≤100000) 的质数。给出 L，请问口袋里能装下几个质数？将这些质数从小往大输出，然后输出最多能装下的质数个数，所有数字之间有一空行。
输入格式
无
输出格式
无
输入输出样例
输入 #1
100
输出 #1
2
3
5
7
11
13
17
19
23
9
二、解题过程
思路
（1）输入整数n；
（2）如果n等于1，不存在质数，直接输出0；
（3）如果n大于等于2，因为2是质数，所以质数个数cnt定义为1，输出2；
（4）然后从3开始循环找质数，符合条件的输出，并用s存储质数之和，cnt++，直到s大于n退出循环；
（5）输出cnt。
提交AC答案
#include&lt;bits/stdc++.h&gt; using namespace std; int n,cnt=1,s=2; int find(int n) { for(int i=2;i&lt;n;i++) { if(n%i==0) return 0; } return 1; } int main() {	scanf("%d",&amp;n); if(n==1) { printf("%d",0);	} else if(n&gt;=2) { printf("%d\n",2);	for(int i=3;i&lt;=n;i++) { if(find(i)) { s+=i; if(s&gt;n) break; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a0a425545e7590a671a73fdd242aa10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71bc42868c8d81664e453dd85b840945/" rel="bookmark">
			异常：java lang AbstractMethodError
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通常在尝试调用抽象方法时抛出此java.lang.AbstractMethodError。通常，此错误是在编译时本身识别的，如果在运行时抛出此错误，则该类必须不兼容（与先前存在的类不兼容） ）更改。因此，它是IncompatibleClassChange Error的子类。 我们知道不能调用抽象方法，如果尝试这样做，则会收到编译时错误，因此您可能会认为在运行时如何抛出此错误？ 原因是二进制不兼容 - 这是什么意思？ 每当修改一个类时，引用该（修改的）类的其他类将不会意识到其中所做的更改。因此，所有类都必须作为一个整体进行编译。 如果不是，那么您可能会遇到不兼容的类更改错误的子类之一。 “ 此错误表明您调用的方法现在已转换为抽象方法”。 请参阅以下示例，以了解有关此错误的信息 class B { public void display() { System.out.println("I am inside B"); } } import java.util.*; public class A extends B { public static void main(String args[]) { A a=new A(); a.display(); } } 输出： C:\blog&gt;javac A.java C:\blog&gt;java A I am inside B 现在，我将把display（）方法转换为抽象方法，并单独进行编译。 abstract class B { public abstract void display(); } 输出： C:\blog&gt;javac A.java C:\blog&gt;java A I am inside B C:\blog&gt;javac B.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71bc42868c8d81664e453dd85b840945/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c929d7bac25ef2b5165bb532bd4a0406/" rel="bookmark">
			解决sql server中 sa登录失败，
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误：在登录sql server的过程中出现：无法连接的错误
1、先用windows登录sql server
3、在建立的连接上右键单击，选择【属性】，进入【服务器属性】界面。在左侧选择页中点击【安全性】，然后在右侧安全性设置界面的【服务器身份验证】一栏中选择【SQL Server和Windows身份验证模式】，点击【确定】按钮。如下图所示：
4：在安全性–》登录名–》找到sa,右键属性，取消勾选，并更改密码
5：最后在步骤3那里右键选择重新启动，就可以了。
备注：都是自己亲测过，且有用的方式，网上也看过很多解决方案，所以在这里统一汇总一下，方便大家解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cd2fcfd459a30e30c05a06e931eefc3/" rel="bookmark">
			Android 跳转Activity 的时候出现闪屏问题处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般这种问题出现的原因就是某些activity的主题的设置了透明引起的
处理方法就是在界面跳转的时候时候添加
overridePendingTransition(0, 0); 例如
Intent intent = new Intent(MainActivity.this, ThemeActivity.class); startActivity(intent); overridePendingTransition(0, 0); 这样就处理好了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ddf605682a8ffb07af2d85f669c8bf3/" rel="bookmark">
			SheetJS/js-xlsx修改表头json_to_sheet修改表头
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看官方文档看到的，记录一下，帮大家踩坑。
//待展示的数据，可能是从后台返回的json数据或者是自己定义的object const data = [ { S:1, h:2, e:3, e_1:4, t:5, J:6, id:7 }, { S:2, h:3, e:4, e_1:5, t:6, J:7, id:8 } ]; //展示的顺序，把data中对象的属性按照你想要的顺序排放就可以了，我这里把id移到了第一列展示 const header = ["id", "S","h","e","e_1","t","J"]; var worksheet = XLSX.utils.json_to_sheet(data, {header:header}); 这样生成的表头就是header，到时生成的表格大致长这样：
idShee_1tJ71234568234567 ！如果想要自定义表头，就需要这样： //待展示的数据，可能是从后台返回的json数据或者是自己定义的object const data = [ { S:1, h:2, e:3, e_1:4, t:5, J:6, id:7 }, { S:2, h:3, e:4, e_1:5, t:6, J:7, id:8 } ]; //展示的顺序，把data中对象的属性按照你想要的顺序排放就可以了，我这里把id移到了第一列展示 const header = ["id", "S","h","e","e_1","t","J"]; //展示的名称 const headerDisplay = {S:"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ddf605682a8ffb07af2d85f669c8bf3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e00e08453032d61fdb4d095080f0c6e2/" rel="bookmark">
			Linux error:1425F102:SSL routines:ssl_choose_client_version:unsupported protocol
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、错误信息
2、解决方案
①、问题：这个是Linux安装的openssl版本问题【配置版本高于服务器版本】
②、处理：打开/etc/ssl/certs【我的是centos是这个文件】打开这个文件，调转【/etc/pki/tls/certs/】返回上一级打开openssl.conf
③、修改配置
④、我的配置：
⑤、重启系统：reboot
参考文章：
①、https://blog.csdn.net/qq_21265915/article/details/103274624?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1
②、https://blog.csdn.net/fangchuang/article/details/102623921
③、https://www.cnblogs.com/milton/p/12831113.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f18498365811caf91605915a97135068/" rel="bookmark">
			使用腾讯云直播开发直播功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 最近公司开发app直播功能，我是后端，使用java开发，经过考虑选择使用腾讯的云直播功能，主要是考虑到腾讯在这方面可以说是很有实力的了。然后就是选择产品的问题，腾讯提供了几种直播的解决方案，最完整的是互动直播，这是一套比较完善的直播解决方案，但是费用比较贵，所以。。。我们选择了云直播和云通信(IM)组合，主要是因为本来app中就集成云通信，也就是云直播用来做视频交互，云通信用来做弹幕和直播间内的业务交互。不要问我为啥不自己搭建直播服务，没技术、更没实力，光带宽就能搞死人，好了废话不多说，开始记录。 正文： 在考虑自己的需求是不是合适腾讯直播的时候，可以先注册一个腾讯云账号，在腾讯云产品中选择云直播，开通服务并进入云直播产品控制台，新用户免费赠送20G的测试流量，可以让你测试是否适合使用，好不好用。
创建拉流(播放视频流)和推流(主播直播视频流)域名，这些在腾讯云直播的文档里面都有，我就不做搬运工了，文档链接：https://cloud.tencent.com/document/product/267/32732
2019/09/05补：如果直播需要海外直播的话，其实很简单，腾讯云直播有海外加速节点，如果是主播在海外直播，用户在国内看，那么只需要你推流地址CNAME对应的域名是国内已经备案过的域名，那么默认就可以在国外直播，如果你没有已经备案过的域名，那么在你创建账号的时候，腾讯云会给你自动生成一个推流域名，你可以直接使用那个域名推流，那个默认开着海外节点的，如果是国内开播，国外看播，那不存在啥问题的，因为国外本来就可以自由访问国内网络，文档贴一下：https://cloud.tencent.com/document/product/267/14621
创建好两个地址之后，可以先去云直播控制台的辅助工具中找地址生成器，根据你创建的推流拉流地址测试着创建两个地址，熟悉一下这个地址的规则，AppName其实就是区分你这个地址属于你的哪个app，或者根据你的具体需求，可以是不同的app，也可以是不同的业务区分，StreamName就是相当于你的直播间号(直播间id)，两个都生成一下之后就会发现推流和拉流地址其实是对应的，具体大家自己试试哈
补一个腾讯云文档中的生成鉴权串的代码：
https://cloud.tencent.com/document/product/267/32833
因为我们的业务是手机直播，手机看播，所以推流自然就是手机推流，这里需要前端同学(ios?安卓?)配合，在手机端使用腾讯云直播文档中提供的SDK，把生成的拉流和推流地址进行测试，具体我就不懂了哈，我是个彩笔后端，前提说一下：如果是手机端直播，推流只能是用：rtmp格式；拉流的话我们选择：FLV格式，每种格式的优缺点腾讯云文档中说的很清楚了，大家自己去看哈，我们选择FLV是因为FLV综合来说延迟较低、适用性高。调试推流和拉流的时候，有一个小程序可以用来调试：腾讯云视频
这些都准备好之后，就是直播的问题了，这里要看你们的直播需求是怎么样的，我这里举个大众化的例子，就是每个用户都可以有自己的直播间，当你有推流和拉流域名之后，你可以定一个AppName，这个AppName就是一个标识，然后你需要建一张数据库表：LiveRoom(名字随意)，这个表的主键就可以用来当作房间号(你也可以使用其他字段)，这个房间号，其实就是拼接到推流和拉流地址里面的StreamName，这个StreamName不需要手动去腾讯云注册，直接拼接在地址中使用就好，注意不同直播间的StreamName不能相同哈，如果你的推流地址中的StreamName相同，那么只有第一个开始推流的是有效的，也就是说同样的推流地址，谁先推谁的有效，拉流只能拉到第一个推流的那个。
如果以上都成功了，那么恭喜你视频交互是可以使用了，其他的就是完善细节问题了，那么直播肯定要有弹幕啊，所以就需要云直播和云通信配合使用了，云通信具体不是我搞的，我就不在这里多说了，反正类似qq聊天群，一个直播间可以对应一个聊天室群，把聊天室和直播间绑定，主播开播之后，视频推流开始，同时IM接入，主播就是这个聊天室群的群主(或者管理员)，可以禁言所有用户，也可以全体禁言，同时直播间中的所有交互，都可以使用IM来做交互，比如直播间水友聊天、用户进入直播间、用户在直播间购买了某些商品等等，都可以通过前后端配合定义各种消息类型(json格式的等等)，如果是普通的直播间聊天，那么直接前端给IM服务发消息，不用经过我们自己的app，减少交互带来的服务器压力，客户端收到消息直接显示为弹幕。但是比如某用户进入直播间这种，就可以通过服务端给IM服务发一条消息，这个消息的内容就是和前端定好的消息类型，比如消息是json格式，其中有个type表示这个消息是干嘛用的，比如某用户进入直播间、某用户在直播间购买了某个商品、某用户关注了直播间等等。这样基本上直播就正常使用了，视频活动和聊天功能都得到解决。
以上基本完成了一个直播功能，但是一般我们肯定有直播列表，直播记录等等，需要我们去分析直播数据，直播记录和直播数据分析腾讯云直播控制台都可以查询，如果要做也可以调用api使用，由于这个比较复杂，就不说了，需要我们自己根据云直播提供的api去使用。下面就说一个基本上大家都有的功能把：直播间列表(仅显示在直播的直播间)
直播间列表这个功能。。。说实话我开始走了很多弯路，因为直播间是我们自己本地库的，状态肯定也是维护在我们自己库里面的，但是主播端呢。。。贼麻烦，各种网络不好啊、app奔溃啊、app卡死啊、手机没电啊、手机爆炸。。。可能就这些把，主要是主播端的各种异常情况，导致用户看播的时候经常出问题。一开始的时候我是想接腾讯云的直播推流拉流回调，然后根据这个回调去调整我们自己库里面的直播间状态，然后我就奔溃了。。。这什么玩意嘛，这个回调一点规律没有，对于主播端异常断网、app奔溃等，很不好用，尤其是那个主播端如果网络不好，经常就会出现我们数据库里直播间状态和实际情况不符，所以我果断放弃使用这个玩意变更直播间状态，这个只用来记录直播的一些日志，比如谁在什么时候推流，什么时候出现了断流，是主播主动断流还是异常情况等等（说个题外话，在做这个的时候，有考虑过心跳方式做这个，但是其实直播的客户端SDK其实和腾讯云是有心跳机制的，所以没必要自己在做，费事）。
上面说了一堆废话(我踩过的坑)，接下来说一下怎么让直播间列表比较准确的显示出确实是在直播的直播间，我们可以看腾讯云直播的api文档中有一个接口：https://cloud.tencent.com/document/product/267/20472 这个接口可以查询所有正在直播的流，哎？这个接口不就是我们所有正在直播的直播间嘛。。。所以方案就来了，写个定时任务，一分钟请求一波这个接口，获取正在直播中的流，把这个接口里面获取到的正在直播中的流，然后根据腾讯云中提供的正在直播中流，和我们库里面的正在直播状态的直播间做对比，把腾讯中正在直播的而我们库里没有在播的找出来改为正在直播状态，把我们库里在播的而腾讯云接口返回中没有的找出来改为结束直播状态。通过我的实践发现这个接口的数据比较实时，而且这个接口调用频率限制是一秒500次，完全够我们定时任务来处理这个。这样，可以说是很完美的解决了直播列表中直播间状态的问题，而且这个接口有分页功能，也不用担心一次请求数据过大的问题。
以上基本描述完了一个粗糙的直播需求，再说几个需要注意的点：
1.推流和拉流域名仅仅是个域名，不存在对应关系，只要是你这个腾讯云账号的推流和拉流域名，如果你的房间号(StreamName)一样，就算你一个是测试环境的推流地址和测试的appName，你照样有可能在正式环境的那个StreamName下拉到测试环境的推流视频，我就遇到过这个坑，我们测试环境有个直播间号是：100005，正式环境也有一个同样的，结果我们测试环境开播测试，正式环境用户也在开播，结果拉流的时候看到了我们测试环境的直播画面，还好我们都是老实人。。。。
2.断流回调不可靠，最好只用这个记录直播间的直播记录，好用这个记录来查问题，这个回调配置在云直播控制台的：功能模板-&gt;回调配置，这个配置新增的时候，记着一个点，不要只配一个回调接口，比如你想配断流回调，那你得推流和断流回调都配，这两个回调用同一个接口就好，回调的参数可以区分是断流还是推流，推流回调比较及时，断流回调比较坑，不要照这个规律
3.腾讯云直播控制台功能还算可以，前端很多数据都可以在控制台查看，比如某个直播间推流拉流相关数据，如帧数、流量、并发连接等等。
2019/09/05补：最后再补腾讯云提供的一个主播端查看推流网络情况的检测地址：https://ping.huatuo.qq.com 这个的使用方法是：打开网址，填写你们的推流域名，然后点击提交检测结果，这个地址如果给主播用，你可以直接把你自己先检测一遍，然后他的链接就会变成你们推流地址的链接，然后直接把新的链接给你们的主播去检测网络，我们直播上线后，很多都是主播端网络贼差，然后整天说这个不好那个不好。。。无语
2019/11/18补：前几天写了一篇连麦的文章，整理的还算详细，有需要的同学可以看：超详细的《使用腾讯云移动直播开发连麦》
2020/05/09补：今天突然想到可以把直播转码的相关操作补一下：
直播转码就是看播端可以调：标清、高清、原画 这种就是转码，就是看播视频的码率问题吧
先贴出来文档：
https://cloud.tencent.com/document/product/267/20385
https://cloud.tencent.com/document/product/267/32834
如果要配置转码，首先进入腾讯云直播控制台，在左边菜单栏进入：功能模版-&gt;转码配置 进去之后根据自己需要配置转码模版，模板名称 配置成简写的英文，方便在拉流地址后面拼接，配置好模版之后，点击云直播控制台的：域名管理 选择你们的拉流域名，点进去之后，在上面有个：模版配置，点击去在右上角点击编辑，在弹出的窗口中选择你配置的转码模版并进行配置，注意这里配置之后会在你的域名里面延时生效。
这里配置完成之后，相当于你的腾讯云直播服务里面已经有了你配置的转码模版，然后在你生成拉流地址的时候，把上面配置的 模板名称 拼接到拉流地址后面，拼接方式为：播放地址_转码模板名称
比如你配置了一个高清模板，模版名称为：hd
原来的播放链接是：http://playxxx.com/live/123456.flv
转码后的播放链接是：http://playxxx.com/live/123456_hd.flv
这样基本就完成了看播转码
记录一下如果要保证直播效果和流畅度，首先对于直播的流畅度体验，他是依托于一个好的网络(好的上行速率)，主播网络上传环境不好，啥都没用，其次就是在我们开发过程中，可以在app端开播是，通过后端接口返回主播开播时设置的各种参数，比如：
参数(手机直播)推荐范围(范围值,均可上下波动)图像组gop2fps30最大码率2000(太高手机性或网络速率能会有影响)最小码率500(太低流畅度无法接受)实际码率1200分辨率根据手机自适应，也可以根据播放效果使用云端转码 以上参数仅供参考，主要还是靠调试，需要后端动态返回各项参数值，app主播开播时根据效果调配，同时开发人员和主播触达问题也需要靠客户端上报主播的异常，手机异常信息进行分析(可以找腾讯云工单)，这个事情需要尝试摸索出最适合的方案
2020-11-23补
补一个方便调直播视频画质的链接：https://imgcache.qq.com/open/qcloud/video/player/demo/player.html
这个可以打开后把你的直播拉流链接填进去，可以显示出来你当前直播视频的各种参数，有时候可以方便调试
就说这点吧，以后又想说的再补，写了这么多，感觉跟写作文一样。也不知道有没有人能看懂。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d08d410ae02e23b2779f264168e172db/" rel="bookmark">
			Vue&#43;SpringBoot&#43;Audio&#43;科大讯飞 语音合成技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最终思路 思路就是vue前端向后台发送需要播放的语音信息(文字),然后后台返回语音流数据,通过URL.createObjectURL(data) 这个API生成一个URL，然后给audio标签附上url，网页进行语音播放，在网页播放语音就可以避免用户的本地语音库的安装。
在Vue项目中用Audio实现语音的播放（基础版） 1.axios 拦截处理 // respone拦截器 service.interceptors.response.use( response =&gt; { const headers = response.headers if (headers['content-type'] === 'application/octet-stream;charset=UTF-8') { return response.data } } ) 2.接口请求 /** * 文字转语音接口 */ export function textToAudio(text) { let jsonData = { text: text, } return request({ url: '/api/audio/text_to_audio', method: 'post', data: Qs.stringify(jsonData), responseType: "blob"//后台返回的为语音的流数据 }) } 3.请求后台接口 //调用后台 getAudio(text) { textToAudio(text).then(response =&gt; { let url = URL.createObjectURL(response);//通过这个API让语音数据转为成一个url地址 let audio = new Audio();//在VUE中使用audio标签 audio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d08d410ae02e23b2779f264168e172db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00e85e4f571abd2a2bd3e3bfc902ae2b/" rel="bookmark">
			PowerShell命令之AD域控
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PowerShell命令之AD域控 环境简介用户的创建，删除，修改，禁用和启用创建用户:New-ADUser删除用户:Remove-ADUser修改用户:Set-ADUser禁用用户：Disable-ADAccount启用用户：Enable-ADAccount 组织单元（OU)的创建，删除，修改和查询创建OU:New-ADOrganizationalUnit修改OU：Set-ADOrganizationalUnit删除OU：Remove-ADOrganizationalUnit查询OU:Get-ADOrganizationalUnit1.已知道OU：OU=GZIT,OU=Corporation,DC=TEST,DC=COM2.-Filter 指定检索activedirectory对象的查询字符串： 群组（Group）的创建，删除，修改和查询创建Group：New-ADGroup删除Group：Remove-ADGroup修改Group：Set-ADGroup查询Group：Get-ADGroup1.已知道:Group：gzit2.-Filter 指定检索activedirectory对象的查询字符串： 查询AD用户、计算机和服务帐户Search-ADAccount还要一些其他选项如下： 查询用户，重置用户密码查询用户：Get-ADUser1.已知道登录名：michaelzhang2.-Filter 指定检索activedirectory对象的查询字符串： 重置密码：Set-ADAccountPassword 环境简介 Windows Server 2012R2
域控：TEST.COM
OU:OU=Corporation,DC=TEST,DC=COM
用户的创建，删除，修改，禁用和启用 创建用户:New-ADUser New-ADUser -path "OU=Corporation,DC=TEST,DC=COM" -name "张小明" -Surname "李" -GivenName "小明" -SamAccountName michaelzhang -userPrincipalName michaelzhang@tslj.cn -EmailAddress michaelzhang@tslj.cn -department GZIT -displayname "Michael Zhang Xiao Ming 张小明 (GZIT)" -description "张小明" -manager jamesli -accountpassword (convertto-securestring "PassWord123$%^" -asplaintext -force) -enabled $true -PasswordNeverExpires $true 解释：
-path #指定OU路径，必须设置 -name #名字，必须设置 -Surname #姓 -GivenName #名 -SamAccountName #账户，必须设置 -userPrincipalName #登陆名，必须设置 -EmailAddress #邮箱地址 -department # 部门 -employeeID #工号 -displayname # 显示名，必须设置 -description #描述 -manager #上级领导 -accountpassword (convertto-securestring "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00e85e4f571abd2a2bd3e3bfc902ae2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4762d96d0ff4c2cceea2ef638c1823d/" rel="bookmark">
			uniapp阻止默认返回事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 onBackPress(options) { // 这里可以自定义返回逻辑，比如下面跳转其他页面 uni.redirectTo({ url: "/pages/center_home/order/goods_lst?sta=all" }) // return true 表示禁止默认返回 return true; }, 页面生命周期有个 onBackPress 方法，可以监听返回事件
onBackPress(event) 返回 event ={form: backbutton | navigateBack}
Android 实体返回键 (from = backbutton)顶部导航栏左边的返回按钮 (from = backbutton)返回 API，即 uni.navigateBack() (from = navigateBack) 注意事项：
只有在该函数中返回值为 true 时，才表示不执行默认的返回，自行处理此时的业务逻辑。不返回或返回其它值，均会执行默认的返回行为。H5平台，顶部导航栏返回按钮支持 onBackPress()，浏览器默认返回按键及Android手机实体返回键不支持onBackPress() 暂不支持直接在自定义组件中配置该函数，目前只能是在页面中来处理。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/166fb94ae16081e09158ec4938f3e83c/" rel="bookmark">
			小程序 省市区县三级联动选择器（caseCade）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 picker组件 &lt;view class="section"&gt; &lt;picker mode="region" bindchange="bindRegionChange" value="{{region}}"&gt; &lt;view class="picker"&gt; 省市区选择: {{region[0]}} {{region[1]}} {{region[2]}} &lt;/view&gt; &lt;/picker&gt; &lt;/view&gt; data: { region: ['', '', ''] // ['广东省','深圳市','宝安区'] }, bindRegionChange: function(e) { console.log('picker发送选择改变，携带值为', e.detail.value) this.setData({ region: e.detail.value }) } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a470b47a2a2cd0495c0a09f39bca4a3/" rel="bookmark">
			Android项目迁移（导入）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android项目迁移（导入） 目录
Android项目迁移（导入）
前言
一 删除相关文件
二 修改gradle配置文件
三 导入工程
前言 这学期学习 android 开发，老师一来就讲了怎么迁移（导入）项目，当时觉得没那个需要觉得自己在更新 gradle 版本之前就能完成开发。不幸的事，我的电脑被我连续搞崩了两次，不过还好将代码备份了，此时新安装的 gradle 和 jdk 可能有所改变，所以需要进行项目的迁移（导入），下面我根据老师的讲解进行我的迁移（导入）记录
一 删除相关文件 .idea是编译器自动生成的
.gradle和gradle 是gradle buildproject 时生成的，这里需要删除这三个文件夹
二 修改gradle配置文件 在新电脑上创建一个新的项目查看相同文件build.gradle 里面的版本号，改成这个版本号
三 导入工程 打开Android Studio，点击工具栏的 File -》 open，导入这个项目，等待一段时间，项目就自动 rebuild 成功了。已经能直接运行了
学海无涯苦作舟，将学习作为一种习惯，不断提升自己，为每一个赴梦者加油！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a97844306966ad02b20ea4cd10cc7bb0/" rel="bookmark">
			easyx的使用(c&#43;&#43;入门的图形设计)--画圆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图形开发环境有以下4种
1.使用MFC或WPF
使用方便, 但是需要先熟悉C++, 仅适用于Windows平台.
2.使用跨平台QT
跨平台, 也要先熟悉C++.
3.使用图形库OpenGL
OpenGL非常强大, 很多大型游戏引擎就直接使用OpenGL绘制图像
缺点: 太复杂, 不适合初学者.
4.EasyX
使用简单, 非常适合C/C++初学者构建图形界面.
同时用来学习/提高C/C++语言
对于c++的初学者来说EasyX是比较容易上手的.
一 、先在自己的编译器上安装EasyX
二、创建项目和源文件
三、先做一个简单的画个圆的程序
#include &lt;graphics.h&gt; #include &lt;stdlib.h&gt; int main(void) { //初始化图像界面 initgraph(640, 480);//规定图片的像素 //构建需要的图形-画个圆 circle(320,240,200);//分别是圆心坐标和半径 system("pause");//暂停 //关闭图形界面 closegraph(); } 这里#include &lt;graphics.h&gt;是编辑图片的头文件
编译运行后为
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a7bf755615bb0c4c36a4b00b5a195ec/" rel="bookmark">
			《Single Image Haze Removal Using Dark Channel Prior》去雾代码实现分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要为了通过对代码进行分析，帮助更进一步了解《Single Image Haze Removal Using Dark Channel Prior》的操作步骤。
在看本篇文章前，需要对《Single Image Haze Removal Using Dark Channel Prior》有大致的了解。提供一个文章解析参考的连接：https://www.cnblogs.com/Imageshop/p/3281703.html
本文的代码分析也是基于上述文章中的代码资源进行分析的，本文主要在于结合代码梳理出更加清晰的思路，并且对代码进行了较为详细的注释。
一、主程序
首先在这给出主程序及其相关注释
clear clc close all kenlRatio = 0.01; minAtomsLight = 240; %设定的大气光的上限值 % image_name = 'test images\21.bmp'; image_name = 'D:\1.png'; %原图像 img=imread(image_name); %读取原始图片文件中的数据 figure,imshow(uint8(img)), title('src'); %显示原始图像 并且显示标题 sz=size(img); %返回一个行向量sz，该行向量的第一个元素时矩阵的行数，第二个元素是矩阵的列数。 w=sz(2); %读取所提取矩阵的列数 h=sz(1); %读取所提取矩阵的行数 dc = zeros(h,w); %返回一个h×w的0矩阵给dc，实际上这个矩阵的size=原输入图像size for y=1:h %行遍历 for x=1:w %列遍历 dc(y,x) = min(img(y,x,:)); %对原图像的每一个像素求RGB3个通道中的最小亮度值,然后赋值给dc矩阵的y行x列 end end figure,imshow(uint8(dc)), title('Min(R,G,B)'); %显示原图像的灰度图 krnlsz = floor(max([3, w*kenlRatio, h*kenlRatio])) %krnlsz为最小滤波窗口的边长尺寸大小 %kenlRatio是一个预设的值，求尺寸时拿kenlRatio和灰度图矩阵长和宽（即w和h）乘上这个预设值和3进行比较，选择最大数作为窗口尺寸 dc2 = minfilt2(dc, [krnlsz,krnlsz]); %对得到的灰度图进行最小值滤波获得暗通道图像 dc2(h,w)=0; %dc2矩阵的h行w列赋值0 figure,imshow(uint8(dc2)), title('After filter '); %显示滤波后的图像 t = 255 - dc2; %下面4行对应公式11，即求出传输特性t（x)的估计值 figure,imshow(uint8(t)),title('t'); %显示传输特性t的图像(原始的方法求t） t_d=double(t)/255; sum(sum(t_d))/(h*w) %t(x)表示的是x像素出的t的估计值，而此处将t_d的矩阵进行平均处理求出一个平均的t值 A = min([minAtomsLight, max(max(dc2))]) %根据论文提示的方法求A值，不过为了防止A过高，设置了一个上限值minAtomsLight %max(max(dc2))表示从暗通道图中按照亮度的大小取前0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a7bf755615bb0c4c36a4b00b5a195ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2272bcd945c83350b305aa954dc2f6e6/" rel="bookmark">
			python中的四种集合数据类型（列表，元组，集合，字典）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意在集合中可以是任意类型—也就是说同一个集合中可以用多种类型的存在
python中的四种集合数据类型是： 列表（List）：有序，可更改，可以有重复的成员元组（tuple）：有序，不可更改，可以有重复的成员集合（set）：无序，无索引，没有重复的成员。字典 （Dictionary）：无序，可更改，有索引，没有重复的成员 列表[]（list）（有序，可更改，可以有重复的成员） 创建列表：a=[“hello”,“world”]
使用：1.**a[0]:代表列表中的第一项
2.a[0:1]代表列表中的第一项和第二项
3.a[-1]代表从后面数的第一个
4.通过for遍历列表中的项 for x in 列表
5.通过len()**方法后去列表长度（列表中的项数）
6.通过append()增加项数 参数是添加的内容
7.通过insert()在某个地方插入项（insert(2,"hahh“)）
8.remove()删除某一项：参数是项的内容而不是索引值
9.pop()删除指定索引（没指定则默认为最后一项）参数是索引值
10.clear()清除列表中的所有元素
11.copy()复制列表
12.count()返回指定元素的数量：参数是内容
13.del可以直接删除列表
14.python中对列表的内建方法
元组（）（Tuple）（有序，不可更改，可以有重复的成员） 创建：a=("“haha”,“heihei”,“ooo”)
使用：
基本上和列表是一样的
特殊：
1.元组一旦创建就无法修改里面的内容----解决：首先将元组转换成列表，改变内容后，再将列表转换成元组
2.创建只有一项的元组时需要加“，”：tuple=(“haha”,)
3.python中对元组内建方法
集合{}（set）（无序，无索引，没有重复的成员。） 创建：a={"“haha”,“heihei”,“ooo”}
使用：
1.集合一旦被创建，无法更改项内容，但是可以添加项
2.通过**add() 和update()**方法向 set 添加项目：add添加一个项：参数是待加入项，update是用来添加多个项：参数是列表[ ]
3.要删除集合中的项目，请使用 remove() 或 discard() 方法。参数是项内容。也可以用pop()方法删除，但是由于集合是无序的，所有不知道删除的是什么
4.del +集合名 直接删除整个集合
5.将两个集合合并通过union() 方法，ege：set=set1.union(set2);也可以用update()只是参数变成了集合（合并后自动删除重复项）
6.python中对集合的内建方法
字典{ } (dictionary)（无序，可更改，有索引，没有重复的成员） 我的理解是一个装多个键值对的集合
创建字典：a={
“name” :“python”,
“age” : 5
}
使用：
1.获取某个键的值：a[“name”]或a.get(“name”)
2.更改值：a[“name”]=“java”
3.返回值：a[“name”].values()
3.遍历for
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2272bcd945c83350b305aa954dc2f6e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c09755ccc82634dbac747726142e255/" rel="bookmark">
			最长公共子序列LCS（动态规划）—详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.基本概念 1、 子序列(subsequence)： 一个特定序列的子序列就是将给定序列中零个或多个元素去掉后得到的结果(不改变元素间相对次序)。例如序列&lt;A,B,C,B,D,A,B&gt;&lt;A,B,C,B,D,A,B&gt;的子序列有：&lt;A,B&gt;&lt;A,B&gt;、&lt;B,C,A&gt;&lt;B,C,A&gt;、&lt;A,B,C,D,A&gt;&lt;A,B,C,D,A&gt;等。
2、公共子序列(common subsequence)： 给定序列X和Y，序列Z是X的子序列，也是Y的子序列，则Z是X和Y的公共子序列。例如X=&lt;A,B,C,B,D,A,B&gt;X=&lt;A,B,C,B,D,A,B&gt;，Y=&lt;B,D,C,A,B,A&gt;Y=&lt;B,D,C,A,B,A&gt;，那么序列Z=&lt;B,C,A&gt;Z=&lt;B,C,A&gt;为X和Y的公共子序列，其长度为3。但ZZ不是XX和YY的最长公共子序列，而序列&lt;B,C,B,A&gt;&lt;B,C,B,A&gt;和&lt;B,D,A,B&gt;&lt;B,D,A,B&gt;也均为XX和YY的最长公共子序列，长度为4，而XX和YY不存在长度大于等于5的公共子序列。
3、最长公共子序列问题(LCS:longest-common-subsequence problem)：In the longest-common-subsequence problem, we are given two sequences X=&lt;x1,x2,…,xm&gt;X=&lt;x1,x2,…,xm&gt; and Y=&lt;y1,y2,…,yn&gt;Y=&lt;y1,y2,…,yn&gt; and wish to find a (not “the”) maximum-length common subsequence of XX and YY . This section shows how to efficiently solve the LCS problem using dynamic programming.
其次科普一下，最长公共子序列（longest common sequence）和最长公共子串（longest common substring）不是一回事儿。什么是子序列呢？即一个给定的序列的子序列，就是将给定序列中零个或多个元素去掉之后得到的结果。什么是子串呢？给定串中任意个连续的字符组成的子序列称为该串的子串。给一个图再解释一下：
如上图，给定的字符序列： {a,b,c,d,e,f,g,h}，它的子序列示例： {a,c,e,f} 即元素b,d,g,h被去掉后，保持原有的元素序列所得到的结果就是子序列。同理，{a,h},{c,d,e}等都是它的子序列。它的字串示例：{c,d,e,f} 即连续元素c,d,e,f组成的串是给定序列的字串。同理，{a,b,c,d},{g,h}等都是它的字串。
这个问题说明白后，最长公共子序列（以下都简称LCS）就很好理解了。
给定序列s1={1,3,4,5,6,7,7,8},s2={3,5,7,4,8,6,7,8,2}，s1和s2的相同子序列，且该子序列的长度最长，即是LCS。s1和s2的其中一个最长公共子序列是 {3,4,6,7,8}
二.最长公共子序列解决方案 方案1：蛮力搜索策略
蛮力搜索策略的步骤如下：
枚举序列XX里的每一个子序列xixi；检查子序列xixi是否也是YY序列里的子序列；在每一步记录当前找到的子序列里面的最长的子序列。 蛮力策略也叫做暴力穷举法，是所有算法中最直观的方法，但效率往往也是最差的。在第1步枚举XX中所有的子序列有2m2m个，每个子序列在YY中检查时间复杂度为O(n)O(n)。因此蛮力策略的最坏时间复杂度为O(n2m)O(n2m)，这是指数级算法，对较长的序列求LCS是不适用的。
2.动态规划 动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。我们可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。
特征分析
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c09755ccc82634dbac747726142e255/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61120df976dbc6012f364ca9ca44b317/" rel="bookmark">
			E: Sub-process /usr/bin/dpkg returned an error code (1)解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自
https://blog.csdn.net/stickmangod/article/details/85316142
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5af23b94bc9089c036837695e0a0ee76/" rel="bookmark">
			Qt 下载安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Qt下载，安装多种渠道下载1 Qt官方下载（慢）2 Qt国内镜像下载（较快）3 迅雷下载（快） 安装 Qt下载，安装 多种渠道下载 1 Qt官方下载（慢） http://download.qt.io/
archive 和 official_releases 两个目录都有最新的 Qt 开发环境安装包。Archive—qt
这个 qt 目录包含了所有的 Qt 版本，从 1.0 到目前的 5.12, Qt 5.9 是一个长期技术支持版本（Long Term Support，LTS），在未来几年里都将有更新支持。
以 Windows 安装包（qt-opensource-windows-x86-5.9.0.exe）为例，安装包命名规则：
• opensource 是指开源版本；
• windows 是指开发环境的操作系统；
• x86 是指 32 位系统；
• 5.9.0 是 Qt 版本号（大版本号，小版本号，补丁号）
2 Qt国内镜像下载（较快） 中国科学技术大学：http://mirrors.ustc.edu.cn/qtproject/
清华大学：https://mirrors.tuna.tsinghua.edu.cn/qt/
北京理工大学：http://mirror.bit.edu.cn/qtproject/
3 迅雷下载（快） 以清华大学开源软件镜像站为例，进入 Qt 5.9.0 的下载目录（https://mirrors.tuna.tsinghua.edu.cn/qt/archive/qt/5.9/5.9.0/），在某个链接处单击鼠标右键，会弹出一个菜单，选择“复制链接地址”，粘贴到迅雷的下载框。
安装 我使用的是迅雷下载：qt-opensource-windows-x86-5.9.0
Qt 在安装过程中会提示用户进行注册和登录，不用理会，跳过（Skip）即可，实际开发时不需要登录安装路径和关联文件，安装路径不能带空格、中文字符或者其他特殊字符。 （喜欢使用纯文本编辑器来打开 C++ 源文件，所以取消了该选项。）
3. 选择安装组件：Qt 的安装组件分为两部分：一部分是“Qt 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5af23b94bc9089c036837695e0a0ee76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3542b9318210458f0ba79bb22242bc5e/" rel="bookmark">
			list集合对象去除重复,值相加求和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 list集合对象去除重复,值相加求和 List&lt;Proportion&gt; proportion = new LinkedList&lt;Proportion&gt;(); //创建对象集合 List&lt;T&gt; proportionList = new LinkedList&lt;T&gt;(); //创建Map集合 Map&lt;String, Integer&gt; mapList = new HashMap&lt;String, Integer&gt;(); //遍历集合 for (Proportion proportion1 : proportionList) { //判断map集合中有没有这个name为名字的key //containsKey返回值为boolean类型 if (mapList.containsKey(proportion1.getName())) { //根据key取出value再加上name相同的另一个参数的value int value = mapList.get(proportion1.getName()) + proportion1.getValue(); 存入map中,会覆盖之前key为name的那列参数 mapList.put(proportion1.getName(), value); } else { mapList.put(proportion1.getName(), proportion1.getValue()); } } //再将map集合转为list集合 for (String s : mapList.keySet()) { Proportion ptmap = new Proportion(); ptmap.setName(s); ptmap.setValue(mapList.get(s)); proportion.add(ptmap); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddd897070cd2c07319b8793a19def754/" rel="bookmark">
			使用ZeroMemory、memset对结构体、数组的初始化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、使用memset初始化： memset函数原型：void * memset(void *ptr,int value,size_t num); 作用：用于为地址ptr开始的num个字节赋值value
typedef struct s1 { SOCKET	m_Socket; SOCKADDR_IN m_ClientAddr; //初始化 s1() { m_Socket = INVALID_SOCKET; //SOCKADDR_IN本身也是个结构体可以使用memset方法初始化 memset(&amp;m_ClientAddr, 0, sizeof(m_ClientAddr)); } }; struct Stu { int nNum; bool bSex; char szName[20]; char szEmail[100]; //这样初始化也可以 Stu() { memset(this, 0, sizeof(Stu)); //或者下面的格式 //memset(&amp;nNum, 0, sizeof(Stu)); } }; 2、
使用ZeroMemory的初始化 ZeroMemory只有将数据置零的功能，在windows平台下，数组或纯结构使用ZeroMemory是安全的
typedef struct _PER_IO_CONTEXT { OVERLAPPED	m_Overlapped;	//每一个重叠网络操作的重叠结构(针对每一个Socket的每一个操作，都要有一个) SOCKET	m_sockAccept;	//这个网络操作所使用的Socket WSABUF	m_wsaBuf;	//WSA类型的缓冲区，用于给重叠操作传参数 char	m_szBuffer[MAX_BUFFER_LEN]; //WSABUF里具体存字符的缓冲区 OPERATION_TYPE	m_OpType;	//标识网络操作的类型 //初始化 _PER_IO_CONTEXT() { ZeroMemory(&amp;m_Overlapped, sizeof(m_Overlapped)); ZeroMemory(m_szBuffer, MAX_BUFFER_LEN); m_sockAccept = INVALID_SOCKET; m_wsaBuf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ddd897070cd2c07319b8793a19def754/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f50ba7bc5f92766f17e55da5ed2eb226/" rel="bookmark">
			REST端点，可使用Apache Camel进行集成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		REST是一种用于组织资源的体系结构样式，当应用于基于HTTP的服务时，REST可以构建无状态的，解耦的，可伸缩的服务。 HTTP方法，HTTP标头和mime类型都允许开发人员实现REST样式。 诸如Jersey和Fuse Services Framework（Apache CXF）之类的框架可用于加快服务的开发和部署，以尝试实现RESTful风格，在本博文中，我想讨论如何构建资源的后端，依赖于Fuse中介路由器（也称为Apache Camel）提供的集成。 顺便说一句，对于那些想知道您的体系结构确实是RESTful还是REST试图缓解的高度耦合的RPC风格的人，也许我很感兴趣。 关于REST撰写论文的Roy Fielding积极主张资源表示中的超链接对于REST风格必不可少的观点，甚至进一步阐明了实现REST的不确定性。 该示例的源代码可以在我的github存储库中找到 Fuse中介路由器是FuseSource的企业级硬化版Apache Camel，提供了舒适的DSL，用于描述集成，中介和路由。 它是免费的开放源代码，并具有Apache许可证。 对于那些不熟悉Mediation Router / Camel的人，请看DZone企业集成区Apache Camel：Integration Nirvana的 Jon Anstey（ Camel in Action的合著者）的介绍。 我们将使用中介路由器来帮助在REST端点和文件系统上的资源文件之间编写简单的集成。 我将使用camel-cxfrs组件公开REST端点，并将使用camel-file组件读取文件系统上的目录。 该样本的目的是描述必要的配置，以通过中介路由器公开REST接口，以某种方式与后端集成，将数据转换为适当的REST响应并发送回该响应。 首先，让我们专注于如何设置REST端点。 为此，您将创建一个JAX-RS资源，该资源描述将用作REST端点的java方法。 此样本代码要求熟悉RESTful Web服务 （又称JAX-RS）的Java API 。 对于那些不熟悉的人，这里有一些不错的教程，可以帮助您理解JAX-RS。 @Path("/customerservice/") public class CustomerServiceResource { // NOTE: The instance member variables will not be available to the // Camel Exchange. They must be used as method parameters for them to // be made available @Context private UriInfo uriInfo; public CustomerServiceResource() { } @GET @Path("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f50ba7bc5f92766f17e55da5ed2eb226/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d2965154b4d2806062c85aca9ce878e/" rel="bookmark">
			资料有点多4412开发板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.选配模块可涵盖物联网、工业现场、智能终端、机器人仪器仪表等应用，包括：SDIO-WIFI、USB-WIFI、GPS、蓝牙、AV-IN、USB摄像头、CAN总线、并口摄像头、VGA、RS-485、继电器、串口、矩阵键盘、zigbee 、步进电机、LORA模块等。
2.新增项目实战视频（14期 5个实战项目）GPS定位系统 物联网只能家居 智能网关 web服务及远程控制 门禁系统
3.新增系统移植教程，掌握更多移植方法（python移植教程 modbus移植教程 Android5.1移植教程 mqtt移植教程）
4.新增Linux驱动教程-USB系列18期视频教程，新增Linux设备树视频教程
5.Android应用开发坏境：更新为Studio,并和eclipse同时提供（iTOP4412开发板已被Linux官方默认支持，可以轻松学习Linux移植开发技术）
核心板参数
尺寸50mm*60mm高度连同连接器在内0.26cmCPUExynos4412，四核Cortex-A9，主频为1.4GHz-1.6GHz内存1GB 双通道 DDR3(2GB 可选)存储4GB EMMC(16GB 可选)电源管理低功耗动态三星S5M8767电源管理，最优架构！工作电压2.65V--5.5V (推荐4.0V）系统支持Linux-QT5.7/Android 4.0.3 /Android 4.4/Ubuntu12.04操作系统USB HOST板载USB3503，引出高性能HSIC，实现2路USB HOST输出引角扩展引出脚多达320个，满足用户各类扩展需求运行温度-25度至+80度区间，设备工作正常，运行良好！ 底板参数
尺寸110mm*190mmDIP SWITCH1个SWITCH电源接口GPIO20PIN（电源和地）RESET1个复位按键CAMERA接口1个（可支持500万摄像头）POWER电直流电源输入接口，5V/2A电源输入WIFI接口1个TF Card1个标准TF卡接口HDMI接口标准HDMI v1.4，1080p高清分辨率输出USB Host2路USB Host,支持USB2.0协议LCD接口共3个，2个LVDS接口，1个RGB接口USB OTG1路USB OTG 2.0LCD电源开关1个以太网口10M/100M自适应网口MIPI接口1个(可以用于扩展MIPI屏幕)PHONE支持耳机输出实时时钟内部实时时钟，带有后备锂电池座，断电后系统时间不丢失MIC支持MIC输入BUZZER1个蜂鸣器串口2路串口JTAG接口1个A/D1路串口、矩阵键盘、GPS接口1个User Key5个功能按键LED2个 最新的Android 4.0.3 /Android 4.4系统 Linux-QT5.7系统 Ubuntu12.04系统Bootloader
u-boot.bin版本：u-boot-1.3.4支持Nand Flash擦除、读、写支持bootm、bootargs设置支持打印、设置、保存环境变量支持内存内容显示、对比、修改支持USB 下载镜像等功能（提供源码) 内核及设备驱动程序
内核:内核版本 linux3.0.15 Linux-4.14.2（支持linux最小系统） 系统时钟系统主频：1.4GHz 内存1GB 或 2GB 显示驱动支持4.3寸、5寸、7寸、9.7寸、10.1寸屏提供源码TOUCH触摸屏驱动提供源码HDMIHDMI v1.4提供源码MFC多媒体硬件编解码驱动提供源码ROTATOR屏幕旋转驱动提供源码TF卡接口1个TF卡接口提供源码HSMMCSD/MMC/SDIO驱动提供源码SPISPI驱动提供源码KEYBD按键驱动程序提供源码AUDIO音频驱动提供源码DMADMA驱动提供源码RTC实时时钟驱动提供源码JPEGJPEG硬件编解码驱动提供源码2D2D硬件加速驱动提供源码3D3D硬件加速驱动提供源码I2C TP驱动I2C 电容屏触摸驱动提供源码PWM背光驱动PWM背光驱动提供源码USB驱动USB驱动提供源码串口驱动串口驱动提供源码网口驱动网卡驱动提供源码WIFI驱动WIFI驱动提供源码Camera驱动500万像素摄像头驱动提供源码蓝牙驱动蓝牙模块驱动提供源码GPS模块支持 UBLOX 7020 全球定位提供源码 交叉编译器
arm-2009q3.tar.bz2交叉工具链 PC端烧写工具
DNW V0.60C串口调试终端、USB下载镜像工具 Ubuntu12.04
Ubuntu12.04开发环境 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cf4ab94150ffa54d585966a50da1a88/" rel="bookmark">
			在uni-app中使用vant-weapp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.在根目录下创建wxcomponents，wxcomponents下建文件夹vant 2.项目引入 1.在https://github.com/youzan/vant-weapp下载最新的zip压缩包
2.解压，将里面的dist文件放到vant里面
3.在App.vue中引入UI样式 @import "/wxcomponents/vant/dist/common/index.wxss";
4.在pages里面定义引入的组件 "van-button": "/wxcomponents/vant/dist/button/index" } 5.在组件中使用 https://youzan.github.io/vant-weapp/#/button和官网的使用方法一样。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25b7038c488ee82f3dc47880087ade1d/" rel="bookmark">
			前端面试之简历篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.前期准备 投其所好 一般公司招聘都会有一些硬性要求，比如工作经历、学历、技术栈、岗位要求等等。
因此应聘之前，一方面，要花时间将自己力所能及的盲点覆盖到，一方面，找对合适的公司进行投递。盲目的海投只会让简历石沉大海。也会打击你的信心。
下面从网上整理了两份的不同级别招聘需求，供大家参考
中级前端工程师
岗位职责： 1、负责WEB端开发工作，与后端工程师配合，为项目提供最优化的技术解决方案； 2、开发前端代码，实现产品的页面交互和数据逻辑展示； 3、与产品讨论确定，并实现良好体验的交互效果 4、解决兼容性问题，优化前端性能，改善用户体验； 5、统一可重用组件，规范前端模块化开发。 任职要求： 1. 一年及以上相关工作经验 2. 熟练使用HTML，CSS，Javascript等前端技术，熟练处理浏览器兼容问题； 3. 熟悉react、vue、Angular等至少一种框架，有实际项目经验，能独立开发高质量组件，能够封装一些常用的函数类库 4. 熟练使用Webpack，Gulp等前端构建工具 5. 代码编写规范，熟悉W3C标准，熟悉前端性能优化并能熟练运用； 6. 有较强的团队合作能力与独立解决技术问题的能力。 7. 熟练使用git或者svn版本管理工具； 8. 加分项：有优秀的开源作品，优秀技术博客（如果有，请贴上地址，如github，npm等地址） 高级前端工程师
岗位职责： 1. 构建可视化研发平台，优化前端开发方式及协作流程，创建技术标准及规范，用智能化方式提高前端研发效能，逐步实现‘无代码研发’ 2. 抽象业务问题，管控业务需求，主导平台型业务的技术架构设计，推动数据化运营模式升级 3. 为组员的技术成长制定目标、计划并帮助实施，提升整体技术水平 岗位要求： 1. 精通各种Web前端技术（HTML/CSS/Javascript等)，熟悉网络协议（HTTP/SSL），熟悉常见安全问题和对策 2. 精通Babel/Webpack，对AST有深度理解 3. 熟悉BaaS/FaaS，对serverless有深刻理解 4. 对前端事件流、数据流有深度理解，具备抽象视图层与数据层交互协议的能力，有复杂可视化搭建平台的研发经验优先 5. 具备跨端研发能力，有前端渲染容器实现和沙箱隔离相关实践经验 6. 个性乐观开朗，逻辑性强，善于和各种背景的人合作，有丰富的项目管理、团队管理经验。 2.关于内容 突出重点 一般前端简历包括以下的几个部分：
基础信息 职业技能 工作经历 项目经验 自我评价(选填，别超过120字) 很多同学都一上来就是一片洋洋洒洒的论文。只要会一点的知识点、专业术语都恨不得都往上搬，显得很饱满。注意，简历不是论文，没有字数要求。 要突出重点，对自己擅长的领域着重描述一下。这几块里面，其中面试官一般最关注是项目经验，所以大家要花点心思在这里进行一番“吹逼”。
关于格式 投递简历的时候一定要word 或者 pdf格式的，有些同学喜欢制作网页版简历，虽然看着比较酷炫，但是初次筛选的都是HR，并不会看源码，整理起来也比较麻烦。所以word 和 pdf 格式的载体足够了，多花精力放在简历内容上。
基础信息 姓名、性别、年纪、手机、邮箱 工作经验、应聘职位、期望待遇（选填） 博客地址（选填）、 GitHub 地址（选填，没作品不填） 学校（选填） 学历 专业 职业技能 这一块基本千篇一律，为什么会这样呢，因为大家都习惯性的把前端相关技术的都罗列了一遍。没有重点。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25b7038c488ee82f3dc47880087ade1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/478de18f20d891d839e2dbcef6ba0d1b/" rel="bookmark">
			接口中可以有静态方法吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接口中是否可以有静态方法？
1.这里是我在其他类中调用时，自动引入了一个静态方法我点开看到报错，说静态方法在接口中需要一个body 方法体。我的第一反应是接口中的方法不是抽象的吗？ 怎么可以有方法体？这是编辑报错，说明这个地方可以有方法体，于是乎，我感觉这个地方肯定是有说法的，于是就百度了一下，果然，还真是：
1） 接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错），所以不能含有静态代码块以及静态方法(用 static 修饰的方法)
2） 在jdk1.8中，接口里可以有静态方法，接口里的有静态方法 必须要有body。有静态方法不需要实现。
package com.javaeasy.communication; import java.net.SocketAddress; public interface Messenger { public void setMessageHandler( MessageHandler handler); public static void sendData(byte[] data, SocketAddress addr); public void startMessenger(); } 我这里是 把static去掉了，因为不需要有静态方法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0768091f468899ef0c7de15bc04630a/" rel="bookmark">
			鼠标移入修改SVG颜色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 svg:hover path{ fill:red; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b30566e31ef19b4945f9b269b1c37926/" rel="bookmark">
			【菜鸟进阶之路】P4956 [COCI2017-2018#6] Davor - 洛谷
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、题目部分
题目描述
After successfully conquering the South Pole, Davor is preparing for new challenges. Next up is the Arctic expedition to Siberia, Greenland and Norway. He begins his travels on 31 December 2018, and needs to collect ​N kunas (Croatian currency) by then. In order to do this, he has decided to put away ​X (​X ≤ 100) kunas every Monday to his travel fund, ​X + K kunas every Tuesday, ​X + 2* ​K every Wednesday, and so on until Sunday, when he will put away ​X + 6* ​K kunas.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b30566e31ef19b4945f9b269b1c37926/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02c6e225490e7df1d94878997e41575e/" rel="bookmark">
			dJango运行项目报错django.core.exceptions.ImproperlyConfigured
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		dJango dJango处理运行项目时，django.core.exceptions.ImproperlyConfigured: Requested setting DEFAULT_INDEX_TABLESPACE 问题处理 **
报错如下：
django.core.exceptions.ImproperlyConfigured: Requested setting CACHES, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.
解决办法如下：
在代码前加入如下语句：
import os,django
os.environ.setdefault(“DJANGO_SETTINGS_MODULE”, “firstProject.settings”)# project_name 项目名称
django.setup()
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d531eaaba437572a3403f8489528c41/" rel="bookmark">
			AHCI协议阅读笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者 QQ群：852283276
微信：arm80x86
微信公众号：青儿创客基地
B站：主页 https://space.bilibili.com/208826118
SCRx Port Register SCR0~SCR4寄存器，可判断端口Link状态，是否Link Up，端口速度等
系统内存分配 HBA寄存器指向系统内存空间，最多32个端口，每个端口包含Command List和Received FIS Structure，
Command List最多32个，
Received FIS Structure大小是256字节，
DMA setup FIS被拷贝到DSFISPIO setup FIS被拷贝到PSFISD2H Register FIS被拷贝到RFISSet Device Bits FIS被拷贝到SDBFISWhen an unknown FIS arrives from the device, the HBA copies it to the UFIS area in this structure, and
sets PxSERR.DIAG.F, which is reflected in PxIS.UFS when the FIS is posted to memory. A maximum of
64-bytes of an unknown FIS type may be sent to an HBA.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d531eaaba437572a3403f8489528c41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a03281069a3db342b649320568b575c/" rel="bookmark">
			【菜鸟进阶之路】P2669 金币 - 洛谷
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、题目部分
题目描述
国王将金币作为工资，发放给忠诚的骑士。第一天，骑士收到一枚金币；之后两天（第二天和第三天），每天收到两枚金币；之后三天（第四、五、六天），每天收到三枚金币；之后四天（第七、八、九、十天），每天收到四枚金币……；这种工资发放模式会一直这样延续下去：当连续N天每天收到N枚金币后，骑士会在之后的连续N+1天里，每天收到N+1枚金币。
请计算在前K天里，骑士一共获得了多少金币。
输入格式
一个正整数K，表示发放金币的天数。
输出格式
一个正整数，即骑士收到的金币数。
输入输出样例
输入 #1
6
输出 #1
14
输入 #2
1000
输出 #2
29820
二、解题过程
思路
（1）输入发放金币的天数k；
（2）进行二层循环，第一层循环是对天数的循环，第二层循环是对金币发放模式的循环；
（3）用t存储循环的天数，cnt存储发放的金币数，当t和k相等时，停止循环，输出金币数。
提交AC答案
#include&lt;bits/stdc++.h&gt; using namespace std; int k,t,cnt; int main() {	scanf("%d",&amp;k); for(int i=1;i&lt;=k;i++) { for(int j=1;j&lt;=i;j++) { cnt+=i; t++; if(t==k) { printf("%d",cnt); break; } } } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a9fa00944a8b6a2f34e81a64c46338f/" rel="bookmark">
			麒麟桌面系统安装达梦数据库之open files问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于麒麟系统安装达梦数据库open files问题 ulimit -a 查看系统信息
[root@localhost 桌面]# ulimit -a
core file size (blocks, -c) 0
data seg size (kbytes, -d) unlimited
scheduling priority (-e) 0
file size (blocks, -f) unlimited
pending signals (-i) 31788
max locked memory (kbytes, -l) 64
max memory size (kbytes, -m) unlimited
open files (-n) 1024
pipe size (512 bytes, -p) 8
POSIX message queues (bytes, -q) 819200
real-time priority (-r) 0
stack size (kbytes, -s) 8192
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a9fa00944a8b6a2f34e81a64c46338f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8902c269da0ee9a12673b6cad204b652/" rel="bookmark">
			eFuse memory
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 特征简介功能描述功能图解1 如果只是施加晶圆水平的吹炼，则不需要绑定FSOURCE2 如果使用封装水平的吹炼，FSOURCE需要绑定ESD保护电路。关于下面的ESD框图，请参考L55 LP eFuse ESD指导方针中的FSOURCE电路设计理念 端口介绍真值表地址和数据输入/输出方案时序图注意点 最近在项目中使用到这种小容量的存储器，将在本篇博客记录相关内容，方便以后回忆复习。 传统的Fuse主要有三种：以大电流烧断的金属熔线(Metal Fuse)和多晶硅熔线(Poly Fuse)，或是以激光烧断之金属熔线(Laser Fuse)。（注：这是在网络上找到的关于fuse的分类描述，对fuse的工艺之类的内容不了解，所以本文不过多介绍）
在项目中使用的eFuse型号是UM055EFULP03200825400_A，该型号存储器只有256-bits，容量小，只是用来保存一些上电时用到的参数，下面将根据数据手册的内容介绍有关该eFuse的相关知识
特征 组织结构
写：256 X 1bit的组织形式
读：32 X 8bit的组织形式可编程性
电压： VDD:1.08~1.32V VFSOURCE:2.375~2.625V
编程时间：4~6us/bit，典型值是5us/bit
在晶圆/封装水平下可工作在25℃~125℃读模式
电压：VDD：1~1.35V VFSOURCE:1.1~2.75V
工作温度：-40℃~125℃尺寸 面积：26791.269875 um2
X= 257.225 um, Y= 104.155 um 高可行性
兼容UMC的55nm逻辑与混合低功耗Low-K工艺，不需要额外的掩膜或工艺物理规格 Metal stack 1P4M (1x Metal/Via)Core Device Type LP_RVTIO Device Type2.5V 简介 UM055EFULP03200825400_A是使用UMC的55nm逻辑与混合低功耗Low-K工艺制作的，总共有256 bits的电子多晶硅熔丝宏（poly-fuse macro），以8bits为1字节，总共32个字节。在施加编程脉冲之后，将多晶硅熔丝从固有的低电阻状态改变为高电阻状态。保险丝熔断的电阻不可逆且可靠。
在写模式下，吹炼操作要求一个优化电压为2.5V的具体pad-FSOURCE,该efuse支持晶圆/封装水平的吹炼，如果实施晶圆水平的吹炼，则不需要绑定FSOURCE，如果是封装水平的吹炼，请参考eFuse ESD指导方针里面的设计理念设计FSOURCE电路。
在写模式过程中，每次只能吹炼一根熔丝（1bit），当FSOURCE拉高之后，器件通过解码B[2:0]的值获取地址从而选中需要编程的熔丝，每根熔丝都只能编程一次，一旦施加编程脉冲，就无法逆转了，编程脉冲时间（Tpp）建议在4us~6us之间（通常是5us）。为了防止FSOURCE上的电压恢复问题，每个编程脉冲之间的间隔（TPI）应大于1us。FSURCE提供编程电流给熔丝，FSURCE的总金属宽度必须足以承载大电流。FSOURCE/VSS电源总线从焊盘到熔丝边缘的阻抗必须小于3Ω，以防止编程过程中出现意外压降。
在输出数据逻辑状态上，没有吹炼过的熔丝是输出逻辑0，吹炼过的则是逻辑1。每次读周期，通过解码A[4:0]将在DOUT[7:0]上输出8bit数据。
由于该宏采用1P4M（1x金属/通孔）设计，允许较高的金属层（金属5及以上）在宏区域上方布线，末级驱动器的PMOS和NMOS尺寸分别为2um/0.06um和1um/0.06um。如果输出负载大于0.1pf，建议在DOUT[7:0]后面放置一个缓冲区，强烈建议将宏放置在尽可能靠近FSOURCE pad的位置。
需要注意的是，该器件在没有烧写过的情况下，读出来的数据都是0，这一点与nand flash等存储器件不同，还有，该器件属于一次性编程，只能由0变为1，无法从1变为0，所以在写数据的时候要格外小心，避免烧写错误导致器件报废
功能描述 功能图解 1 如果只是施加晶圆水平的吹炼，则不需要绑定FSOURCE 2 如果使用封装水平的吹炼，FSOURCE需要绑定ESD保护电路。关于下面的ESD框图，请参考L55 LP eFuse ESD指导方针中的FSOURCE电路设计理念 端口介绍 端口名方向类型介绍READ输入数字读使能ENB输入数字宏使能（低电压有效）A[4:0]输入数字寻址输入B[2:0]输入数字块选择输入PROGRAM输入数字写使能（低电压有效）DOUT[7:0]输出数字数据输出PORB输入数字上电复位（低电压有效）避免上电过程中的意外写（高电平为2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8902c269da0ee9a12673b6cad204b652/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71ceed612b38f3ca33f5e2b0dbc60e14/" rel="bookmark">
			RESTful架构（Representational State Transfer，资源表现层状态转换）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RESTful是一种网络应用程序的设计风格和开发方式，基于HTTP，可以使用XML格式定义或JSON格式定义。
动作类型为:GET、POST、PUT、DELETE 对服务端进行操作
RESTful特点包括:每一个URI代表一个资源
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f22ed3821036329c8e9c2b67818e52c/" rel="bookmark">
			【菜鸟进阶之路】P5721 【深基4.例6】数字直角三角形 - 洛谷
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、题目部分
题目描述
给出n(1≤n≤13)，请输出一个直角边长度是 n 的数字直角三角形。所有数字都是 2 位组成的，如果没有 2 位则加上前导 0。
输入格式
无
输出格式
无
输入输出样例
输入 #1
5
输出 #1
0102030405
06070809
101112
1314
15
二、解题过程
思路
（1）找直角三角形输出的规律，算出该倒三角“最后一层”的数字m；
（2）用k去存储每一层数字的个数；
（3）在未超过m的范围内循环输出，用i作为输出的数字，从1开始计数，若i&lt;10，输出“0i”，否则输出i；
（4）每输出一个数字对cnt叠加计数一次，当cnt等于k时，换行输出，k减1，cnt置零重新计数，循环往复直到不满足条件。
提交AC答案
#include&lt;bits/stdc++.h&gt; using namespace std; int n,m,k,i=1,cnt; int main() {	scanf("%d",&amp;n); m=(1+n)*n/2; k=n; while(i&lt;=m) { if(i&lt;10) { printf("%d%d",0,i); } else { printf("%d",i); } i++; cnt++; if(cnt==k) { cout&lt;&lt;endl; k--; cnt=0; }	} return 0; } 三、小结
（1）这道题的难点在于输出格式：“所有数字都是 2 位组成的，如果没有 2 位则加上前导 0”；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f22ed3821036329c8e9c2b67818e52c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1a64a4b43b4581540fd88722fb4ef99/" rel="bookmark">
			sqlserver2000启动失败，在服务器的管理中重新启动MSSQLSERVER启动后马上又停止
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题原因：sqlserver2000启动失败，在服务器的管理中重新启动MSSQLSERVER启动后马上又停止。
问题分析
1、查看操作系统应用程序日志
通过"事件查看器" 发现
错误: 9003，严重度: 20，状态: 1
​ LSN(5:324:1)无效。该 LSN 是传递给数据库’model’ 中的日志扫描操作。
错误: 9003，严重度: 20，状态: 1
​ The LSN (5:324:1) passed to log scan in database ‘model’ is invalid.
解决方法：
1.备份C:\Program Files\Microsoft SQL Server\MSSQL\Data（SQL2014：D:\Program Files\Microsoft SQL Server\MSSQL12.MSSQLSERVER\MSSQL\DATA）
目录下 Model.mdf , modellog.ldf 两个文件
2.找来Sql Server安装盘,将X86\Data\ Model.mdf,ModelLog.ldf两个文件复到C:\Program Files\Microsoft SQL Server\MSSQL\Data目录下,
3.重新启动SQL SERVER 成功！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cb130a42e5ddb240c4aa0158d610923/" rel="bookmark">
			【菜鸟进阶之路】P5720 【深基4.例4】一尺之棰 - 洛谷
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、题目部分
题目描述
《庄子》中说到，“一尺之棰，日取其半，万世不竭”。第一天有一根长度为a(a≤10^9) 的木棍，从第二天开始，每天都要将这根木棍锯掉一半（每次除 2，向下取整）。第几天的时候木棍会变为 1？
输入格式
无
输出格式
无
输入输出样例
输入 #1
100
输出 #1
7
二、解题过程
思路
（1）逆向思维，当木棍长度a不为1时，a除2，天数也随之增加；
（2）最后输出的结果是d增加的量＋1（也可以在一开始定义天数d为1）。
提交AC答案
#include&lt;bits/stdc++.h&gt; using namespace std; int a,d=1; int main() {	scanf("%d",&amp;a); while(a!=1) { a=a/2; d++; } printf("%d",d); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cae830da6fff4d17d570e2c8c7abff0/" rel="bookmark">
			vue项目的H5如何通过WebViewJavascriptBridge和原生通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue项目的H5如何通过WebViewJavascriptBridge和原生通信 首先创建一个bridge.js文件在main.js中引用成全局在vue某个页面中点击拍照的函数中使用 首先创建一个bridge.js文件 // An highlighted block (function(global, factory) { typeof exports === 'object' &amp;&amp; typeof module !== 'undefined' ? (module.exports = factory()) : typeof define === 'function' &amp;&amp; define.amd ? define(factory) : (global.JSBridge = factory()) })(this, function() { 'use strict' var JSBridge = { init() { this.ready(function() {}) }, ready(callback) { if (window.WebViewJavascriptBridge) { return callback(WebViewJavascriptBridge) } else { //register document.addEventListener( 'WebViewJavascriptBridgeReady', function() { callback(WebViewJavascriptBridge) }, false ) //register ios if (window.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1cae830da6fff4d17d570e2c8c7abff0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40a90ff428007d1eb513677ccea0175e/" rel="bookmark">
			“DSO missing from command line”解决及其原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 前言 这两天在编写一个插件系统Demo的时候，发现了个很奇怪的问题：插件加载器中已经链接了ld库，但是应用程序在链接插件加载器的时候，却还需要显式的来链接ld库。否则就会报：DSO missing from command line。这个报错翻译过来就是没有在命令行中指定该动态库。
这个报错就很搞事了，你说你明明知道需要哪个库，为什么不直接帮我链接呢，非得我显示的在命令行中指定呢？
2 现象描述 问题可以简单描述为：当链接可执行文件时，依赖于libA.so，而libA.so又依赖于libB.so，而且可执行文件中还直接调用了libB.so中的函数，那么此时链接就会出现错误。
2.1 问题发生的前置条件
libA.so在编译过程中显式的链接了libB.so
可执行文件中使用了libB.so的函数
binuntils版本 ≥ 2.22
2.2 Talk is cheap. Show me the code
话不多说，先看看可以复现改问题的代码吧
libB.so的源码：
#include &lt;stdio.h&gt; int funB1(){ printf("in funB1"); return 0; } int funB2(){ printf("in funB2"); return 0; } 这里面有两个函数：funB1和funB2。
其中funB1函数会被libA调用，而funB2会被可执行文件调用。
编译libB.so:
$ gcc libB.cpp -fPIC -shared -o libB.so libA.so的源码：
#include &lt;stdio.h&gt; int funB1(); int funA1(){ printf("in funA1 \n"); funB1(); return 0; } 该库中只有一个函数funA1，该函数在内部调用了libB中的funB1函数。且该函数会被可执行文件调用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40a90ff428007d1eb513677ccea0175e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b26cff12b4d03a67f243df31d30008c/" rel="bookmark">
			用华为eNSP仿真校园网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 网络拓扑网络配置交换机配置无线AC配置防火墙配置 网络测试网络系统测试核心功能测试其他系统测试 网络拓扑 网络配置 交换机配置 为了提高整个网络系统的可靠性，在本次模拟方案中，网络核心层配置了两台华为s7706高性能核心交换机，实现冗余配置的同时为数据的高速转发、负载均衡、流量控制、网络管理等提供强有力的支撑。设备之间通过vrrp协议进行信息传递。在实现高速转发数据的同时，如果核心设备sw1发生故障，sw2能够直接接收到故障信息，并接管核心交换机的在线线程，确保了网络系统的高可用性。
综合以上考虑，我在核心交换机上做了以下操作： 首先在两台核心交换机上配置DHCP，并给vlan10-50配置DHCP的地址池，下发地址。配置MSTP，在核心交换机sw1上设置instance1为主，instance2为备，sw2上相反。将vlan10-30划分到instance1中，vlan40-60划分到instance2中，sw1与sw2相同。配置VRRP，在sw1上vlan10-30配置虚拟IP，并设置优先级为120，配置监视端口，端口断开的同时优先级裁减30；在sw2上vlan40-60配置虚拟IP并设置优先级为120，监视端口，端口断开优先级裁减30。创建链路聚合，将两个核心层交换机划分到Eth-Trunk0中，并将g0/0/1和g0/0/2端口加入到Eth-Trunk0。配置OSPF，在两个核心交换机上配置OSPF，配置区域为0，精确匹配所通告的网段。配置AAA，使用local-user命令创建本地用户和用户口令，并以密文方式显示用户口令，配置用户名和密码。配置telnet，开启telnet服务。 汇聚层五个交换机配置基本相同，除了vlan和管理地址不相同。详细配置在附页，sw3交换机做以下操作①配置vlan200、201分别是AC+FIT AP的管理和业务vlan，vlan999管理各层交换机vlan。②配置MSTP。③远程管理。④配置OSPF。接入层交换机主要用于用户接入，按照校园不同功能划分为图书馆、教学楼、办公楼、宿舍楼以及实验楼接入交换机，配置相似。图书馆接入层交换机配置vlan、ospf、telnet、管理vlan。
连接在AP上的交换机充当POE（power over Ethernet）网线供电交换机，POE交换机的优点是节省成本、安全、美观等特点。仅给AP供电作用，所以并无配置。 无线AC配置 在本次网络仿真实验中设计了无线局域网，无线局域网是由AC和FIT AP组成。AP的作用是把有线数据转换成无线数据发送，并且起到中继放大的作用。AP的类型分为两种，一种是瘦AP，必须依赖AC的管理；还一种是胖AP，自带管理功能AP，例如家用AP就是功能缩减版胖AP，无监控和NAT功能。由于FIT AP不能自我管理，必须依赖AC。因此FIT AP与AC之间需要有相应的通信协议才可以进行互联，AP与AC隧道通信协议是CAPWAP(Control and Provisioning of Wireless Access Points)。协议内容如下：①AP能够自动发现AC。②AP拿到IP地址，AC对AP进行管理和业务配置转发。③STA数据封装，CAPWAP隧道进行转发。WLAN上网过程：首先AP通过DHCP获取地址，得到IP地址后，会立即发送一个CAPWAP的request广播请求包试图找到AC，AC收到CAPWAP广播请求后，立即回应并于AP建立CAPWAP隧道，在AC上就可以看到AP上线，再通过业务vlan下发给用户IP地址。配置AC有两种方法：可以通过WEB页面和CLI命令行配置。此次设计采用的CLI命令行配置，下面简单介绍一下配置过程： 创建接口VLANIF虚接口，开启dhcp功能，VLAN200作为AP的管理vlan。VLAN201作为业务vlan。配置AP上线，创建AP组，用于将相同配置的AP都加入同一AP组中。创建域管理模板，在域管理模板下配置AC的国家码并在AP组下引用域管理模板。配置AC的源接口。在AC上离线导入AP且将所有AP加入AP组group1中。创建名为wlan的安全模板，并配置安全策略。配置WPA-WPA2+PSK+AES的安全策略为例，密码为huawei123。创建名为wlan的SSID模板，并配置SSID名称为wlan。创建名为wlan的VAP模板，配置业务数据转发模式、业务VLAN，并且引用安全模板和SSID模板。配置AP组引用VAP模板，AP上射频0和射频1都使用VAP模板wlan的配置。配置OSPF。 防火墙配置 安全区域划分。安全策略配置。OSPF配置。NAT配置。 网络测试 网络系统测试 DHCP测试：将网络拓扑中所有的核心层，汇聚层，接入层交换机及用户PC端打开，接入层用户获取IP地址的方式设置为DHCP自动获取，先查看配置的DHCP是否能让用户获取IP地址，如图5.1所示。
图5.1用户PC端获取IP的状态图
2. IP地址：调至命令行模式，查看用户是否获取的IP地址，如图5.2所示，可以看出用户已拿到IP地址，DHCP测试成功。
图5.2用户获取IP图
3．内网测试：将网络拓扑中所有交换机和PC端打开，不同vlan间的用户测试，例如查看图书馆用户是否能与实验楼用户通信，如图5.3所示，查看测试结果，可以看出内网用户不同vlan间能够通信。
图5.3内网测试图
4．外网测试：首先网络拓扑中所有交换机、路由器、防火墙及PC端打开，测试用户端是否能通过防火墙和路由器连接互联网，如图5.4所示，可以看出图书馆用户可以通过网络连接至互联网。
图5.4外网测试图
5．服务端测试内网：将网络中交换机、服务器端及PC端打开，用服务器端测试内网的连通性，如图5.5所示，可以看出服务器端可以与内网用户进行通信。
图5.5服务器测试内网图
6. 服务器测试能否连接外网：如图5.6所示，可以看出服务端可以连接至互联网，将信息发布到互联网。
图5.6服务器连接外网图
7. 无线网络测试：将AC、AP及POE交换机打开，首先查看AP是否获取到IP地址，如图5.7 所示，看出AP拿到IP地址通过隧道协议与AC建立连接。
图5.7 AP的IP地址图
8. 用户无线网测试：将用户的无线设备打开，然后STA获取到AP的信息输入认证密码huawei123，连接到WiFi，如图5.8 所示，可以看出用户可以检测到AP的WiFi信息与之建立连接。
图5.8 STA连接状态图
9. STA连接到WiFi以后查看是否拿到IP地址，如图5.9 所示，可以看出用户通过输入WiFi密码后可以拿到IP地址。
图5.9 STA获取的IP地址图
10. 测试STP内外网连接情况：如图5.10所示，用户在拿到IP地址后也可以与内网不通vlan间进行通信，也可以连接至互联网进行信息交换。
图5.10 STA测试内外网连接情况图
核心功能测试 核心交换机sw1和sw2上配置了vrrp，当sw1上检测的端口(g0/0/8或者g0/0/9)发生故障时，在sw1的master会变为backup，如图5.11 所示，可以看出核心层设备冗余性测试成功。
图5.11 SW1的状态图
在sw2上会检测到故障并由备变为主，如图5.12 所示，可以看到备份核心交换机能够成功的由backup切换到master。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b26cff12b4d03a67f243df31d30008c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cdcc40d5ac63e677ea0675d1b0db438/" rel="bookmark">
			CTF总结-杂项篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、通用过程 右键查看文件属性，可能有隐藏的备注、提示信息检查文件类型
1.1 通过file命令检查文件类型
1.2 通过binwalk命令检查文件中是否隐藏了其它文件
1.3 如果有，则通过binwalk -e命令分离，如果无法正确分离，则通过foremost进行分离
1.4 如果检查出zlib，说明隐藏了其他文件，此时foremost如果无法正确分离，则可能需要进行手动分离判断具体题型
2.1 各类隐写
2.2 流量分析
2.3 其他类型
2.4 可能涉及编码和古典密码学的内容 二、图片隐写 注：图像指png、jpg、gif、bmp等格式的文件。
通用过程 通过Stegsolve的各个通道查看图片，如果有可疑的地方则对对应的通道进行数据提取如果有多张图片，可以尝试Stegsolve的ImageCombiner功能通过010editor检查十六进制格式下的图片，善用文本搜索通过strings命令进一步检查 PNG PNG是一种无损图片，可能有各种隐藏方式通过tweakpng打开png来检查该PNG的CRC是否正确，如果不正确，通过脚本来爆破该PNG的正确宽高 JPG 暂无 GIF 通过Stegsolve逐帧查看，并在必要时分离有些题目可能是通过两帧之间的时间间隔作为加密信息，此时可以通过identify命令进行处理，具体内容参考CTFwiki BMP 暂无 二维码、条形码识别 利用在线工具即可但在必要时可能需要利用PS或者其它工具缝缝补补 三、压缩包处理 通用过程 ZIP 如果有加密，则先判断是伪加密还是真加密
伪加密查看50 4B 01 02后第5位，即框选中的前一位的低位
2.1 此时将其修改为0即可
真加密查看50 4B 03 04后第3位，即框选中的前一位的低位
3.1 利用出题人给到的提示进行破解
3.2 利用工具ARCHPR进行暴力破解
3.3 暴力分为三类：CRC32爆破，直接爆破 以及 明文爆破，分别适用于主体内容较小，密文较简单 以及 有内部文件泄漏的情况
RAR 思路与ZIP基本相同，只不过爆破工具换成了crark55 四、音频隐写 利用Audacity检查波形图，或许可以映射为01序列（对于01序列的密码学解法，请参考密码学总结）利用Audacity检查频谱图利用silentEye检查是否为音频的LSB隐写针对MP3文件，可以通过MP3Stego进行隐写 五、流量分析 待补充 六、其它 注：所有的步骤都是在通用过程执行过一次了的前提下进行的
可执行文件隐写 通过ResourceHacker查看是否有隐藏信息 pyc文件隐写 磁盘文件 待补充 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3104cebbf1e63a4cf04b803df6f71809/" rel="bookmark">
			java获取请求者真实的公网ip地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在java程序中获取浏览者真实的公网ip地址，程序健壮性极好，代码如下：
public void downLoad(HttpServletRequest request) { String ip = null; // 处理代理情况 ip = request.getHeader("x-forwarded-for"); if (StringUtils.isBlank(ip) || "unknown".equalsIgnoreCase(ip)) { ip = request.getHeader("Proxy-Client-IP"); } if (StringUtils.isBlank(ip) || "unknown".equalsIgnoreCase(ip)) { ip = request.getHeader("WL-Proxy-Client-IP"); } if (StringUtils.isBlank(ip) || "unknown".equalsIgnoreCase(ip)) { ip = request.getRemoteAddr(); if (ip.equals("127.0.0.1")) { InetAddress inet = null;// 根据网卡取本机配置的IP try { inet = InetAddress.getLocalHost();//idea-PC/192.168.212.144 } catch (UnknownHostException e) { e.printStackTrace(); } ip = inet.getHostAddress();//192.168.212.144 } } // 对于通过多个代理的情况，第一个IP为客户端真实IP,多个IP按照','分割,多级代理的时候会得到多个以,分割的ip， //这时候第一个是真实的客户端ip if (ip !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3104cebbf1e63a4cf04b803df6f71809/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c11560bbad40f661790f4d88f6e17d39/" rel="bookmark">
			Keil C51 存储模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前碰到过这么一个问题：一份keil C51工程，里面有几百个函数，大部分函数在运行过程中都会被调用，后来需要调试某个功能，就将主函数main里面其它功能函数的调用注释掉，结果编译后报出一堆溢出错误，当时就懵了，难道函数只定义不调用占的空间还会比调用占的空间大？仔细看了编译信息，发现都是跟数据空间溢出有关，再深入研究发现，跟keil中的存储模式有关。下图展示的就是keil 中的memory model
在keil的帮助手册中找到下图信息，其实这三种存储模式是指定默认状态下各种变量和参数的存储位置
small model description compact model description compact model description Small：变量存储在内部ram里；small模式下，再入函数的堆栈是设在 idata中的
Compact：变量存储在外部ram里,使用页8位间接寻址； compact模式 下，再入函数堆栈是设在pdata中的
Large：变量存储在外部Ram里,使用16位间接寻址；
这几个选项只是影响没有特别指定变量的存储空间的时候，默认存储在哪里
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92cbaea4de4a016a92cd2139428c2272/" rel="bookmark">
			【菜鸟进阶之路】P5719 【深基4.例3】分类平均 - 洛谷
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、题目部分
题目描述
给定n(n≤10000) 和 k(k≤100)，将从 1 到 n 之间的所有正整数可以分为两类：A 类数可以被 k 整除（也就是说是 k 的倍数），而 B 类数不能。请输出这两类数的平均数，精确到小数点后 1 位，用空格隔开。
输入格式
无
输出格式
无
输入输出样例
输入 #1
100 16
输出 #1
56.0 50.1
二、解题过程
思路
（1）比较n&lt;k，n=k和n&gt;k三种情况下的输出；
（2）n&lt;k，A类无数据，B类为1~n的平均数；
（3）n=k，A类为n的值，B类为1~n-1的平均数；
（4）n&gt;k，可以整除k的数据相加存储在ans1，其余数据存储在ans2，循环结束后求出两类相应平均值输出。
提交AC答案
#include&lt;bits/stdc++.h&gt; using namespace std; int n,k,a[10001]; int ans1,ans2,d1,d2; int main() {	scanf("%d %d",&amp;n,&amp;k); if(n&lt;k) { printf("%.1lf %.1lf",(double)0,(double)(1+n)/2); } else if(n==k) { printf("%.1lf %.1lf",(double)n,(double)n/2); } else { for(int i=1;i&lt;=n;i++) { a[i]=i; if(a[i]%k==0) { ans1+=a[i]; d1++; } else { ans2+=a[i]; d2++; } } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92cbaea4de4a016a92cd2139428c2272/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34b6bef526ebbe83d229c383e6ebda6d/" rel="bookmark">
			信息学奥赛一本通超详细题解，动画图文题解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内容来源于微信公众号：大神编程。已经过原文作者授权。
更新时间：2020-11-5
现在开始更新基础算法题。
个人感言：从未见过如此详细的题解，动画、图文结合，适合任何水平的选手。尤其是特别适合自学的。有这么详细的题解，就算没有老师也没问题。甚至比我以前的老师讲的都详细。
为什么要转载：
动画、图文结合。我看了部分文章，一些我觉得很简单的题，但从中学到了以前没有学过的知识点和细节，重点是从中学习别人思维方式。让更多的同学能学到更多的知识。 官方的QQ群：893157498（已取消，有微信群）
这是我建的QQ群：795233394
欢迎各位志同道合的同学们^_^
已更新的题目颜色是蓝色，点击相应的题目名称即可查看该题的详细题解。
根据章节分类，一般按照该分类的方法解题。例如for循环一节，就会用for循环的方法解题。
因NOI系列赛事将不再支持Pascal和C语言，只支持C++，所以所有题解不会使用Pascal，而使用C/C++。使用C语言是为了让部分学C语言的同学有所适应，并且部分题解会使用C/C++，主要让学C语言的同学可以对比两者，有利于由C转C++。不过后面或许不再使用C语言，只使用C++。
目录
一、语言及算法基础篇
基础(一) C++语言
第一章 C++语言入门 第二章 顺序结构程序设计 第三章 程序的控制结构 第四章 循环结构的程序设计 第五章 数 组 第六章 函数
基础(二) 基础算法
第一章 高精度计算 第二章 数据排序
第三章 递推算法
第四章 递归算法
第五章 搜索与回溯算法
第六章 贪心算法
第七章 分治算法
第八章 广度优先搜索算法
第九章 动态规划算法
基础(三) 数据结构
二、算法提高篇
三、高手训练
四、官方真题
一、语言及算法基础篇 基础(一) C++语言 第一章 C++语言入门 题号题目名称1000入门测试题目1001Hello,World!1002输出第二个整数1003对齐输出1004字符三角形1005地球人口承载力估计 第二章 顺序结构程序设计 第一节 运算符和表达式
题号题目名称1006 A+B问题
1007计算(a+b)×c的值1008计算(a+b)/c的值1009带余除法1010计算分数的浮点数值 第二节 常量和变量
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34b6bef526ebbe83d229c383e6ebda6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/938c076b3c9bc0771c9fe0a603e70823/" rel="bookmark">
			自建spring cloud遇到的问题（1）—— pom.xml中modules无法找到子项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在Spring Cloud 下创建子项目时，在父项目中的pom.xml文件中添加modules。进行对子项目的关联，module标签中对应的是子模块的名称，而非子模块的pom.xml中artifactId的名字
&lt;modules&gt; &lt;module&gt;zql_eureka&lt;/module&gt; &lt;module&gt;zql_zuul&lt;/module&gt; &lt;/modules&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6eb996549524b44f8b5b73059ef05a71/" rel="bookmark">
			IEEE接收之后上传latex论文和eps图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		accept之后，会要求上传eps格式图片和latex格式论文。
latex，找淘宝排版。自己调节一下字号大小和图片大小。调节字号大小和图片大小的方式，见链接https://blog.csdn.net/yq_forever/article/details/84023896?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522158875180019724845006490%2522%252C%2522scm%2522%253A%252220140713.130102334…%2522%257D&amp;request_id=158875180019724845006490&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2allfirst_rank_v2~rank_v25-3。
参考文献会要求提供bib版本，去Google学术(千万不要百度学术)搜这篇文章，然后点引用中的bib格式，复制代码，粘贴到bib文件中。bib格式中会包含题目，作者信息，论文章卷等等。等到淘宝把排好的latex发过来，用texlive的Texworks打开，首先左上角文件-删除辅助文件（辅助文件是以前latex运行生成的一些文件，没有用放心删），然后pdfLatex-BibLatex-pdfLatex*2，这样导入了参考文献，并且生成了pdf格式的论文。正常的由google学术导入的参考文献不会报错（如果报错，比如参考文献引入格式不规范或者作者名字有俄文等等，可以敲回车，把这个错误跳过去，生成pdf文件。但是这个报错后面也要处理掉）。注意，如果是XeLatex运行，可能显示的格式和模板不同，这时候要选择pdflatex运行一下。
图片:一.visio画的图片:1.visio内，右下角 100%比例，把visio内画的图正好放在框内，放满，不要超出。2.visio另存为pdf格式。3.Adobe打开pdf格式，裁剪，去掉白边(主要是上下的白边)。另存为eps格式。4.latex导入eps格式图片，导入的文件和eps格式图片名称一致。eps或者pdf图片多大，导入就是多大，如果想缩放，改变width，长宽同比增加。
二.matlab画的图片。matlab的图形可以直接 文件-另存为eps格式，不需转换。这种方式比较简便。在MATLAB中画的图形和生成的eps图形大小相同。
三.其他绘图软件画的，如果不能直接导出为eps格式，一般都可以导出pdf格式。先导出pdf格式，再在Adobe中打开此pdf，裁剪修改大小，修好之后另存为eps格式。
以上，各类图片转eps格式完成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fb1348126af08f3c83554b134f7f1d9/" rel="bookmark">
			线上个别机器访问公网地址时出现tcp请求超时或无响应处理方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： 线上环境有多个实例，分别在不同的机房。正常情况下没问题，但每当同机房下，添加新的实例服务器后，在这台新的实例上就会偶发出现请求超时或无响应的情况。并发量越大，出现的概率越高。ping正常。curl或正常http请求时，就会偶发出现该问题。
故障定位 首先，梳理网络流程。服务器在访问公网地址时，会经过nat网关转换到公网的地址，然后再去访问目标地址。
其次，分别在服务器，nat服务器，目标服务器通过tcpdump抓包。通过分析出现问题时的数据包发现，服务器，nat服务器都是只有发送的syn包，而没有收到目标服务返回的ack确认包。由于没有收到ack确认包，服务器一直重试发送syn包。
最后，通过调研内核参数，发现参数net.ipv4.tcp_timestamps用来校验同源公网Ip的时间戳。经过nat之后，如果前面相同的端口被使用过，且时间戳大于这个链接发出的syn中的时间戳，服务器上就会忽略掉这个syn，不返会syn-ack消息，表现为用户无法正常完成tcp 3次握手，导致连接超时或无响应。 在业务闲时，如果用户nat的端口没有被使用过时，就可以正常打开；业务忙时，nat端口重复使用的频率高，很难分到没有被使用的端口，从而产生这种问题。 解决方案 net.ipv4.tcp_timestamps 默认值为1，即开启时间戳的校验。并且只有客户端服务和服务端都开启时，才会出现该问题。
于是，将服务端的net.ipv4.tcp_timestamps设置为0后，解决该问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe39d1d995e2c6f667d59d4231b013c3/" rel="bookmark">
			浙大PTA 7-4 列出叶结点 (20point(s))
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		7-4 列出叶结点 (20point(s))
对于给定的二叉树，本题要求你按从上到下、从左到右的顺序输出其所有叶节点。
输入格式： 首先第一行给出一个正整数 N（≤10），为树中结点总数。树中的结点从 0 到 N−1 编号。随后 N 行，每行给出一个对应结点左右孩子的编号。如果某个孩子不存在，则在对应位置给出 "-"。编号间以 1 个空格分隔。
输出格式： 在一行中按规定顺序输出叶节点的编号。编号间以 1 个空格分隔，行首尾不得有多余空格。
输入样例： 8 1 - - - 0 - 2 7 - - - - 5 - 4 6 输出样例： 4 1 5 题目要求：按照层序遍历的形式输出叶子节点
思路：按照输入建树，用check数组保存第i个节点是否为叶子节点（是否有左孩子，右孩子），进行层序遍历，若为叶子节点则输出，否则不输出。
#include &lt;iostream&gt; #include&lt;string&gt; #include&lt;queue&gt; using namespace std; struct TNode { int Data; int Left; int Right; } T[20]; int main() { int n; int check[11] = {0}; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe39d1d995e2c6f667d59d4231b013c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8485f8a680ef4ab9913c400288ab31a7/" rel="bookmark">
			goole检查更新时出错：无法启动更新检查（错误代码为 4: 0x80070005
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打开360软件管家 更新 完成
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88a230b96dc2ff40bb96ad0b090ffdca/" rel="bookmark">
			【万字长文】深入理解 Typescript 高级用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方“全栈前端精选”关注
❝ 「前言」：这里的标题看起来是 "高级用法"，不少同学可能就表示被劝退了。其实 Typescript 作为一门 强类型 编程语言，最具特色的就是他的类型表达能力，这是很多完备的后端语言都难以媲美的 说的很对，但PHP是最好的语言，所以如果你搞懂了他的类型系统，对将来的日常开发一定是大有裨益的，但过于灵活的类型系统也注定了 Typescript 无法成为一门纯粹的静态语言，不过每一行代码都有代码提示他不香嘛？
❞ 大纲 基础准备
Typescript 类型系统简述
Typescript 的类型是支持定义 "函数定义" 的
Typescript 的类型是支持 "条件判断" 的
Typescript 的类型是支持 "数据结构" 的
Typescript 的类型是支持 "作用域" 的
Typescript 的类型是支持 "递归" 的
小结
"高级用法" 的使用场景与价值
哪些用法可以被称为 "高级用法"
举例说明 "高级用法" 的使用场景
小结
类型推导与泛型操作符
流动的类型（类型编写思路）
Typescript 代码哲学
常见类型推导实现逻辑梳理
类型的传递（流动）
类型的过滤与分流
小结
定制化扩展你的 Typescript
Typescript Service Plugins 的产生背景、功能定位、基础使用
市面上已有的 Typescript Service Plugins 举例介绍
参考资料链接
Q&amp;A
可以利用 Typescript Service Plugin（例如配置 eslint 规则）阻塞编译或者在编译时告警吗？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88a230b96dc2ff40bb96ad0b090ffdca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28cd135e5edb06ae09f8b779274b33ee/" rel="bookmark">
			基于vue cli3实现甘特图拖拽
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于vue cli3实现甘特图拖拽
因为工作中要用到甘特图，所以我在网上搜索可以用的甘特图，搜索了好多，但是网上搜到大多数都很鸡肋，不能直接使用，最后我在github上搜索到一个相对成熟的甘特图。附上链接https://github.com/w1301625107/Vue-Gantt-chart
刚开始我看不懂这个博主写的代码，于是想自己写，但是尝试了几天，最后还是以失败告终。没办法活是我自己的，总得想办法弄出来啊，所以我硬着头皮改造代码。先附上博主的甘特图，我感觉这是我见过颜值最高的甘特图了。
，
因为需求要求做到可拖拽，以下是我实现拖拽的过程。
在这里插入图片描述
JS部分
首先介绍第一个mousedown,当我按下鼠标，我会记录当前块的索引。draggable设为可拖拽。
在这里插入图片描述
接着介绍drop，也就是移动到该行触发的事件，这里我用val传参（拖动到指定行的数据）和所有数据对比较，获取该行的索引，接着我会判断拖动的块与该行的块是否冲突。
以上就是我的分享，如果有什么问题，欢迎大家留言。
————————————————
版权声明：本文为CSDN博主「Wombat-」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/haluodepaopao/article/details/103071592
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ef84b519dcd26e287b6dc3b23a3d1c3/" rel="bookmark">
			联想电脑进入BIOS并开启虚拟化的两种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（1）如何找到电脑上的BIOS？ 常规方式：
开机 - 出现Lenovo字样 - 迅速按F2或Fn+F2。此种方法试了很多次并未找到BIOS。
解决办法一：
控制面板 - 硬件和声音 - 电源选项 - 更改电源按钮的功能 - 更改当前不可用设置 - 取消“启用快速启动” - 重新启动尝试 - 仍未解决。
解决办法二：
打开电脑设置 - 更新和安全 - 恢复 - 立即重新启动 - 疑难解答 - 高级选项 - UEFI固件设置 - 重启 - 成功进入BIOS。
（2）在BIOS开启虚拟化设备 进入BIOS - 按键盘向右的箭头找到configuration选项 - 按键盘向下的箭头找到Intel virtual technology - 按Fn+F5将disable改成enable - 按fn+F10保存更改 - 回车“YES”- 电脑自动重启 - 完成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7253f548262ce7677e9401a6f4f8beff/" rel="bookmark">
			现代通信技术之软交换技术和IMS技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软交换网络技术 IP电话网技术 在 IP 电话基础上逐步发展起来的一个新技术或新概念
IP 电话呼叫过程： Phone to Phone
普通电话通过电话网连接到 IP 电话网关，用电话号码呼叫。发端 IP 网关鉴别主机用户，将被叫电话号码翻译成离被叫最近的收端网关 IP 地址，将呼叫连接到该网关，完成话音编码和打包。收端 IP 网关完成拆包、解码及反向地址翻译功能，并将呼叫连到被叫终端用户。 NGN 泛指不同于目前一代的，大量采用创新技术，以 IP 为中心，支持语声、数据和多媒体业务的融合网络。 ——“虚词”
下一代之后永远还有下一代
狭义的下一代网特指以软交换为核心，光联网为基础的，兼容所有三网技术的开放体系架构。
现阶段的下一代网指狭义的
特征：
采用开放的网络架构体系 按照功能划分模块，彼此间用标准的接口互联。 业务驱动的网络 业务与呼叫控制分离，呼叫与承载分离。 基于统一协议的分组网络 使用 IP 协议 软交换 软交换的概念 广义软交换泛指一种体系结构，即基于软交换的下一代网络框架
狭义软交换指软交换设备，软交换设备是一个市场术语，它还有多个名称，如呼叫服务器、呼叫代理、媒体网关控制器等
广义的软交换就是狭义的 NGN
电路交换与软交换的对比
传统电路交换网是一种垂直集成的、封闭和单厂家专用的系统结构，新业务的开发也是以专用设备和专用软件为载体，导致开发成本高、时间长、无法适应今天快速变化的市场环境和多样化的用户需求。
软交换首先打破了传统的封闭交换结构，采用横向组合模式、开放的接口和通用的协议，构成一个开放的、分布的和多厂家应用的系统结构。
软交换的体系结构 注意， 本课程按照传统电信网具有代表性的网络分层模型的概念和体系来组织的，即按照分成业务与终端、交换与路由、接入与传送三层构成的网络分层模型来描述整个通信网络。
基于软交换的 NGN 体系结构却与之不同，是一个四层模型，实际上二者的主要不同正是将软交换引入现有网络构成 NGN 所造成的。
将原来交换与路由中的呼叫控制功能独立出来就是现在的控制层，即软交换；
原来交换与路由中剩余的对媒体处理和传送功能就是现在核心传输层要完成的功能；
而接入媒体层就是提供各种接入手段，只不过因为软交换要叠加在现有通信网上，还必须提供现有各种传统通信网，如电话网、 ISDN 、智能网的接入。
软交换网络的组成 软交换设备：呼叫处理控制
媒体网关：媒体流转换
中继网关：连接电路交换机的中继线接入网关：连接 ISDN 用户网络接口接入互联网用户驻地网关：连接模拟用户线与 IP 网 信令网关
业务支撑环境：应用服务器等
各种终端
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7253f548262ce7677e9401a6f4f8beff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d522c3b751f304a816ad355eabff13d/" rel="bookmark">
			MongoDB导出CSV格式数据，并解决乱码问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、导出数据链接mongodb服务器参数介绍：
-h host 主机
–port port 端口
-u username 用户名
-p passwd 密码
2、mongoexport 导出文件参数介绍：
-d 库名
-c 表名
-f field1,field2…列名
-q 查询条件 “{‘name’:‘张三’}”
-o 导出的文件名
– csv 导出csv格式(便于和传统数据库交换数据)
mongoexport -d shop -c sdo -f _id,xh,name -q ‘{xh:{$lte:100}}’ --csv -o ./test.sdo.csv
3、解决乱码问题
在导出mongodb表中数据到CSV中时，打开CSV文件会显示乱码。
CSV是逗号分隔值的英文缩写，通常都是纯文本文件。CSV格式是分隔的数据格式，有字段/列分隔的逗号字符和记录/行分隔换行符。
出现这种情况怎么解决呢？我们首先来分析一下此种情况的内在原因。在简体中文环境下，EXCEL打开的CSV文件默认是ANSI编码，如果CSV文件的编码方式为utf-8、Unicode等编码可能就会出现文件乱码的情况。
方法1、数据导入
打开 Excel，执行导入数据，选择 CSV 文件，出现文本导入向导，选择“分隔符号”，下一步，勾选“逗号”，去掉“ Tab 键”，下一步，完成，在“导入数据”对话框里，直接点确定。
导入之后，所有汉字显示正常，乱码问题解决。
方法2、先另存再打开
使用记事本打开CSV文件，“文件”-&gt;“另存为”，编码方式选择ANSI，保存完毕后，用EXCEL打开这个文件就不会出现乱码的情况。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c9caf3f1e3a3852658a540c5941c5d2/" rel="bookmark">
			图解Spring源码之循环依赖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 准备工作关闭循环依赖开始调试AbstractBeanFactory#doGetBeangetSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory)AbstractAutowireCapableBeanFactory#createBean(beanName, mbd, args)doCreateBean总结参考资料 Spring默认在 单例、 非构造方法注入的情况下是支持循环依赖的。 准备工作 关闭循环依赖 Spring 提供了关闭循环依赖的方法。
boolean allowCircularReferences 开始调试 我们从 doGetBean 开始分析。
AbstractBeanFactory#doGetBean Spring 在初始化和 getBean() 时，都会调用这个方法。
删减版doGetBean
//... 表示被我省略掉的一些代码
代码很长，我们节选一些片段来解析
先检查一下单例池当中有没有手动注册的单例对象：
单例池：
Spring 中所有实例化好的单例 Bean 都存放在这个map当中。
判断当前的类是否在正在创建的原型集合当中，如果是，则抛异常：
说明一般情况下，原型不支持循环依赖。
prototypesCurrentlyInCreation：
判断当前 Bean 是否是单例，如果是，则把 Bean 创建出来。
getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) 分析与循环依赖有关的代码片段：
判断当前实例化的 Bean 是否在正在被销毁：
singletonsCurrentlyInDestruction：
beforeSingletonCreation(beanName)：
判断当前 Bean 是否正在被创建。因为 Spring 不管创建 Prototype Bean 还是 Singleton Bean，当他需要正式创建 Bean 的时候他会将这个 Bean add 到一个Set 中去
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c9caf3f1e3a3852658a540c5941c5d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f32614bc0a8843126c0b564272258ad1/" rel="bookmark">
			teamviewer或向日葵远程ubuntu系统不能调节屏幕分辨率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		远程时分辨率不能调节的原因可能是被控制的机器的显示器没打开，这个时候在远程连接状态下重新启动ubuntu，注意的是要确定teamviewer或向日葵设置了开机自启动服务，保证重启之后仍然可以远程连接到ubuntu,这样reboot之后连了网就能再远程连接了,分辨率也可以调节了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15d7538abee4551d1d021e7e341a3728/" rel="bookmark">
			AI芯片：寒武纪DianNao，英伟达NVDLA和谷歌TPU1的芯片运算架构对比分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AI芯片：寒武纪DianNao，英伟达NVDLA和谷歌TPU1的芯片运算架构对比分析
evolone 2019-01-18 20:10:39 2972 收藏 9
展开
前面几篇博客分别分析了目前市面上能够找到的各家AI芯片的结构。
下面做一个阶段性的对比分析及总结。
AI芯片运算架构对比
整体来看，NVDLA的架构与寒武纪的DianNao比较像。所以，单位资源的性能应该是差不多的。
二者性能的区别，就看资源的多寡了。
寒武纪的DianNao，共16个PE，每个PE可以计算一个神经元，每个周期最多计算出16个神经元。
NVDLA共2个core。每个core有8个mac。每个mac有64个mul，可以计算4个神经元。所以，NVDLA每周期最多可以计算64个神经元。看作64个PE。
再看谷歌的TPU1，因为systolic array的尺寸是256X256，所以，每周期最多计算出256个神经元。看作256个PE。
这么来看，同频率下，姑且可以认为：NVDLA性能是DianNao的4倍， TPU1是NVDLA的4倍。
当然，上面的这种性能比较并不公平，因为三者内部的资源数量是不同的。
因为寒武纪DianNao的资源最少，所以以它为基准。
下面按照同样规模的资源来做比较：
寒武纪的DianNao，内部是16个PE。每个PE内部有16个mul和15个add，计算得到一个神经元。
NVDLA，一个core中有8个mac，每个mac有64个mul，可以计算输出4个神经元。可将每16个mul看作一个PE，计算得到一个神经元。
这么一看，DianNao与NVDLA的架构是一样的，效率应该也一样。
谷歌的TPU1，内部乘加单元组成的脉动阵列的尺寸是256x256=64K个mul_add。如果将尺寸缩小为16x16，那么也可看做每16个mul计算得到一个神经元。共有16个PE。
这么一看，貌似谷歌的TPU1的效率也和DianNao、NVDLA都一样。
其实不一样。
（1）芯片物理结构的弊端
NVDLA与DianNao都是一维的扁平结构，数据只有一个流动方向，输入数据并不能在mac相互间传递。只有在core顶层的时候去做数据共享，到了mac内部，就无法做到数据共享。
就算是强行进行数据共享，在实际设计芯片时有很大的弊端。
以寒武纪的DianNao为例，16个PE是并行的，数据同时到达，如果最大化共享，即16个PE的输入图像数据是同一份，那么很明显，必须在数据进入乘法器之前，同时将数据复制多份，分发给16个PE，或者说，同一份数据，需要同时驱动给16个PE。
主要有2个弊端：
（1）这个会涉及到信号的驱动能力。底层晶体管很有可能驱动能力不够。
（2）因为目前的芯片还只是二维平面的，也就是说，将一个PE看做一个方块，那么这16个PE是平铺在一个平面上的，那么必然是分散开的，那么数据从芯片的某个部位进来，这16个PE的数据接口与输入数据的距离肯定是有远有近，长度短的，需要的驱动小，长度大，需要的驱动大，这个怎么匹配？而且，如果走线太长，延迟会等比例增大，频率就得降低，信号完整性变差，如何保证能够将16份相同的数据同时并准确地传输到最远和最近的PE的接口上？这是个严重的问题。
估计就是因为这些原因，造成这种扁平的设计存在缺陷：如果频率想高一些，那么并行的PE就很少，要么就是增加并行的PE，但是会造成频率明显降低。比如寒武纪DianNao的频率是0.98GHz。
这是一个死结。
因为吞吐量简单来看，就是PE数量与频率的乘积，这样就造成，这种架构的吞吐量永远上不去。
实际上，DianNao和NVDLA内部的并行模块并不多。比如，DianNao内部只有16个PE并行，NVDLA每个CORE内部也只有8个mac并行。
反观谷歌的TPU1，采用的脉动阵列不是扁平结构，而是二维的平面结构，数据可以沿着两个相互垂直的方向分别传播。而且，最大的好处是，数据只是在相邻的乘加单元之间传递数据，并且单个方向上，数据只需要传递一份即可，这样，所需驱动小，而且可以很轻松地保证数据的传输距离的一致性，而且传输距离还非常短，可以做到比较高的频率，且频率与阵列的尺寸无关系。
所以，脉动阵列的结构，可以很轻松地做到很高的频率，尺寸还很大，比如TPU1得频率是700MHZ，尺寸是256X256.
简单对比一下：
AI芯片型号 频率 乘法器规模 简单的吞吐量
寒武纪DianNao 0.98GHz 16×16=256个乘法器 约等于 1G X 256=256G/s
谷歌TPU1 700MHz 256X256=64K个乘法器 约等于 64K X 700M=44800G/s
（2）数学理论上的弊端
DianNao和NVDLA的扁平化结构，还在数学上存在很大的弊端。
以DianNao为例：
一个PE中的16个mul是同时计算的，那么，卷积的filter的尺寸大小，会强烈影响计算效率。
假设一个卷积需要的乘法计算次数为N，
如果N&lt;16，那么一个PE可以一次就算出结果，但是会有16-N个mul资源浪费。可见N越小，越浪费。
如果N=16，那么最好了，PE不仅能够一次算出结果，还没有mul浪费。
如果N&gt;16，那么不好意思，一次只能算16个乘法，剩下的N-16，留着下次再算，或者调用其他PE去计算。但是这样就会增加不同PE间的连接关系，控制逻辑非常复杂，造成设计难度增大。
所以，DianNao和NVDLA的扁平化结构，对filter的尺寸是非常敏感的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15d7538abee4551d1d021e7e341a3728/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6e6253acefe68cc5e97b6e988bc3546/" rel="bookmark">
			ubuntu20环境下wine部分中文乱码方块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.下载一个ttc的字体，以下以宋体示例；
2.将 ttc 文件放到~/.wine/drive_c/windows/fonts/目录下；
3.新建**.reg文件和字体文件放一块；
REGEDIT4 [HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\FontLink\SystemLink] "Lucida Sans Unicode"="simsun.ttc" "Microsoft Sans Serif"="simsun.ttc" "Tahoma"="simsun.ttc" "Tahoma Bold"="simsun.ttc" "SimSun"="simsun.ttc" "Arial"="simsun.ttc" "Arial Black"="simsun.ttc" 4.在reg文件目录下执行以下命令，如果无效切换到root用户执行；
wine regedit **.reg 5.重新运行wine即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db56b4583e6ee2b78a1f8a966dee2048/" rel="bookmark">
			《信息学奥赛一本通（C&#43;&#43;版）》1057：简单计算器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 来源:《信息学奥赛一本通（C++版）》
测评地址：信息学奥赛一本通在线测评
【题目描述】
一个最简单的计算器，支持+,-,×, / 四种运算。仅需考虑输入输出为整数的情况，数据和运算结果不会超过int表示的范围。然而：
如果出现除数为0的情况，则输出：Divided by zero!
如果出现无效的操作符(即不为 +, -, ×, / 之一），则输出：Invalid operator!
【输入】
输入只有一行，共有三个参数，其中第1、2个参数为整数，第3个参数为操作符（+,-,×,/）。
【输出】
输出只有一行，一个整数，为运算结果。然而： 1.如果出现除数为0的情况，则输出：Divided by zero! 2.如果出现无效的操作符(即不为 +, -, ×, / 之一），则输出：Invalid operator!
【输入样例】
1 2 +
【输出样例】
3
代码如下： 注：代码仅供参考，不只有一种解法。
#include &lt;iostream&gt; using namespace std; int main() { int a,b; char c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; switch(c) { case'+':cout&lt;&lt;a+b;break; case'-':cout&lt;&lt;a-b;break; case'*':cout&lt;&lt;a*b;break; case'/':if(b==0) {cout&lt;&lt;"Divided by zero";break;} else {cout&lt;&lt;a/b;break;} default:cout&lt;&lt;"Invalid operator"; } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a889ba33ea1146fbe6bc24c48c04736/" rel="bookmark">
			RSA加密算法解释与C&#43;&#43;实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近因为一些原因对密码学产生了点兴趣，继之前用代码实现BASE64之后最近又搞起了RSA，这让我这个数学渣用从头开始学数学。。。。泪
RSA加密算法 RSA加密算法是由三位MIT大佬发现的，故RSA算法名称由来就是取他们三位名字i的首字母。
RSA算法是一种典型的不对称加密算法，说到不对称加密就会想到对称加密，在密码学加密算法大致可分为两种：对称加密与不对称加密。
对称加密 什么是对称加密，简单来讲就是加密与解密的密钥是相同的，举个简单的栗子，例如我们要对一个字符A加密，字符A即是明文，字符A的ASCII码为65，然后我们用一个十进制数10来做加密密钥，他的加密过程可表示为：密钥+明文，最后得出结果为75即字符K，这里的K即是密文，解密时只需要用相同的密钥10来进行逆运算：75-10就能得到明文，这就是一个最简单的对称加密的例子，当然真正的对称加密算法，过程与密钥不可能这么简单，对称加密代表算法：DES、3DES、TDEA、Blowfish、RC2、RC4、RC5、IDEA、SKIPJACK等。
不对称加密 不对称加密的栗子比较难举，没法用简单的例子来举，总之与对称加密的概念刚好相反，他会用到两个密钥，一个称为公钥，一个称为私钥，通常加密明文时用公钥进行加密，解密时必须要用私钥才能解密，用公钥无法进行解密，代表算法：RSA、Elgamal、背包算法、Rabin、D-H、ECC等。
比较 对称加密算法的优点一目了然：时间复杂度与空间复杂度相对于非对称加密都比较低，而缺点就是不够安全
非对称加密的优点：安全度高，缺点时间空间复杂度较高
这两种加密算法可以结合使用，就能达到相互补短的作用，比如用非对称加密加密密钥然后再用解密出来的密钥再对明文内容进行对称加密，常见https协议大致就用了这样的思路，这样即提高了安全性能又提高了传输速度与资源的占用
RSA算法实现过程 说完上面的前置知识，下面就着重解释RSA算法的实现过程，接下来我来分步骤进行解释：
首先我们需要找两个质数p、q然后求出p、q的乘积n然后再取一个欧拉函数φ(n)(欧拉函数百度百科)，φ(n)=(q-1)*(p-1)然后我们寻找一个公钥e，他要满足以下条件：
1&lt;e&lt;φ(n)
(e,φ(n))=1（公钥e要与φ(n)互质）然后再去找到一个私钥d，他要满足的条件：
(e*d)%φ(n)=1 (公钥私钥相乘除以φ(n)，余数要为1现在有了密钥，就该加密环节了，加密过程：
假如我们有一个要发送的数据Y，一个公钥e，首先我们计算Y的e次方即Y^e得到一个数据，然后将这个得到的数据除以n，取得余数，这个取得的余数就是我们需要的密文y，计算过程可表示为:y=(Y^e)%n现在还要知道如何解密，现在有一个密文y，还有一个私钥d，首先求y的d次方即y^d得到一个数，然后用这个数再除以n，得到的余数就是我们需要的明文Y，计算过程可简单表示为Y=(y^d)%n 然后我们再来看看这种算法能否被破解，假设现在有两端，服务端S，客户端C，S与C之后的通信全部需要进行加密，首先S需要生成公钥与私钥，然后将公钥和一个数n传递给C，并且将私钥保存在本地，C 接收到公钥与n之后就会利用公钥与n来对自己的明文数据或消息进行加密，然后传递给S，S收到后用仅自己拥有的私钥进行解密，再拿到明文消息或数据。
破解方法 让我们康康，在整个传输过程中，作为hacker他能拿到的数据只有公钥e与数字n，他现在需要用这两个数来逆运算推导出私钥d，然后我们在来回头看看私钥d是如何算出来的(e*d)%φ(n)=1，现在我们只知道e与n如果想要再求d就必须要知道φ(n)那φ(n)又是如何计算的呢φ(n)=(q-1)*(p-1)现在我们又需知道p、q才能求出φ(n)，p、q又怎样求，n=p*q，现在不难看出，如果n这个数比较小的话，也许的确有可能通过质数分解求出p、q但如果他是一个非常大的数呢？而RSA算法中常用的是1024比特位的二进制数，就目前技术而言无法将其分解，所以破解RSA加密算法理论上可行，但以目前被普及的技术来说还无法做到（或许、可能、大概、说不定、弄不好有天才数学大佬可以分解吧，但对于普通人来讲是不可能的）当然也有一个特例，那就是量子计算机，但普通人家里谁有量子计算机？
代码实现 实现代码前首先我们要解决几个问题：
如何生成并存储一个1024位128个字节的高精度整数，首先用C语言自带的库很难完成这个工作，那只能考虑第三方库：GMP，这个库支持任意精度的大整数存储与运算如何得知公钥e与φ(n)互质，用辗转相除法，如果最大公约数为1即为互质，还有一个最快最简单的方法，那就是直接设为一个常用的数字65537即可 首先生成两个大质数：
mpz_t key_p, key_q, temp_n; mpz_t fi, pub_key, pri_key; //初始化p,q,n,φ(n),公钥，私钥 mpz_init(key_p); mpz_init(key_q); mpz_init(temp_n); mpz_init(fi); mpz_init(pub_key); mpz_init(pri_key); /* *生成随机1024位质数 **/ //随机数种子 gmp_randstate_t grat; //默认生成在随机性与效率之间取一个折中 gmp_randinit_default(grat); //以当前时间作为随机数种子 gmp_randseed_ui(grat,time(NULL)); //生成两个个1024位的随机整数 mpz_urandomb(key_p,grat,1024); mpz_urandomb(key_q,grat,1024); //生成素数 mpz_nextprime(key_p,key_p); mpz_nextprime(key_q,key_q); 输出结果为：
60317106189242150968029907905478884454926397838 63151192056069393976678696526755735882204871919 60640863409260125737784699838551404308288285427 22202009629439178701380058086593614241889585723 84631477965807444301047539221743520620231455186 51441389685261033128949964706605835556481358609 98173250327588025985739839 66011711808975252037545823728364010624488907689 90643069363083107799625584556500033745996473231 15790980352676928009148324711181846268064324503 83413178315138572996883354239248096907001626608 08392625765952133578008721528020700996465748851 57917174906323291939335096453676892850856698552 86464761830290932578868973 现在我们去计算n与φ(n)：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a889ba33ea1146fbe6bc24c48c04736/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d08322dc409a677902c3d43a49295db0/" rel="bookmark">
			linux驱动开发学习笔记十六：gpio相关OF函数和子系统API函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、gpio相关OF函数 我们在设备节点中会定义了一个名为“gpios”的属性，当然不一定是“gpios”，你可以自定义。gpios 属性描述了 test 这个设备所使用的 GPIO。在驱动程序中需要读取 gpios 属性内容，Linux 内核提供了几个与 GPIO 有关的 OF 函数，常用的几个 OF 函数如下所示：
of_gpio_named_count 函数 of_gpio_named_count 函数用于获取设备树某个属性里面定义了几个 GPIO 信息，要注意的是空的 GPIO 信息也会被统计到，比如：
gpios = &lt;0 &amp;gpio1 1 2 0 &amp;gpio2 3 4&gt;; 上述代码的“gpios”属性一共定义了 4 个 GPIO，但是有 2 个是空的，没有实际的含义。
通过 of_gpio_named_count 函数统计出来的 GPIO 数量就是 4 个，此函数原型如下：
int of_gpio_named_count(struct device_node *np, const char *propname) 函数参数和返回值含义如下：
np：设备节点。
propname：要统计的 GPIO 属性。
返回值：正值，统计到的 GPIO 数量；负值，失败。
of_gpio_count 函数 和 of_gpio_named_count 函数一样，但是不同的地方在于，此函数统计的是“gpios”这个属性的 GPIO 数量，而 of_gpio_named_count 函数可以统计任意属性的 GPIO 信息，函数原型如下所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d08322dc409a677902c3d43a49295db0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/162b8bdd84906a7556a8bdca23e76b19/" rel="bookmark">
			钉钉小程序 之 自定义组件的使用，以及父组件与子组件(自定义组件)传值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录： 本机环境自定义组件（子组件）页面中引入（父组件引入子组件）父组件（使用自定义组件的页面）传值给子组件子组件（自定义组件）传值给父组件备注 一、本机环境 本机系统： Mac 小程序开发者工具: 1.5.7 二、自定义组件（子组件） 子组件中：
项目的根目录下！！创建自定义组件
在对应 json 文件中定义 component 属性
如图在根目录 的 `components` 目录（目录名自定义）下存放自定义组件 三、页面中引入（父组件引入子组件） 父组件中：
路径引入在对应页面下
添加 json 文件中定义 usingComponents
axml 文件中直接使用
如图 （图 3.1）
（图 3.2）
四、父组件（使用自定义组件的页面）传值给子组件 子组件中：
通过属性 props 传递值 numIndex
在 data 中定义对应的值 itemIndex
在生命周期 didMount 中修改对应的值
如图 子组件 （图 4.1）
4.2、⚠️⚠️然后子组件可以调用传递进来的方法，将参数传给父组件对应的方法，父组件的该方法获取参数修改自己组件内的值 如上图： props: { onQuantityValue: function(d) { console.log('d-----', d) } ... ... } ... // 直接如下方式调用父组件传递的函数即可 this.props.onQuantityValue('子组件想要传递给父组件的值，在此处赋值即可') 五、子组件（自定义组件）传值给父组件 子组件通过函数参数，传递值给父组件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/162b8bdd84906a7556a8bdca23e76b19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cab0eff3f85db9d3b6a3f3d957f4255/" rel="bookmark">
			@RequestBody部分属性为null的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Boot项目中使用@RequestBody接收请求数据，前端通过json格式传递数据，发现获取不到所发送的部分数据
实体类 @ApiModel(value = "码表分类") @Data public class ClassVo { @ApiModelProperty(value = "码表分类编号", required = true) private String cId; @ApiModelProperty(value = "码表分类名", required = true) private String name; @ApiModelProperty(value = "备注", required = false) private String memo; } 响应方法
获得请求数据，以json格式再返回’ @PostMapping(value = "/class") public CommonreturnType insertClass(@RequestBody ClassVo classVo){ return CommonreturnType.create(classVo); } 请求数据 { "cId": "01", "name": "测试", "memo": "测试" } 返回结果 { "status": "success", "data": { "cId": null, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3cab0eff3f85db9d3b6a3f3d957f4255/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/875f74ea3ffd71cd2c85cff59bf56a4d/" rel="bookmark">
			if(P)和if(!P)含义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在指针使用中，有时候会出现直接判断指针的情况，容易给人带来困惑
对int * P ;
if(P)的含义：
指针判断都要跟NULL比较，相当于0，假值，其余都是真值
if(P)就是if(P != NULL ), 不为空执行语句
if(！P)就是if(P == NULL ), 为空执行语句
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/244/">«</a>
	<span class="pagination__item pagination__item--current">245/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/246/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>