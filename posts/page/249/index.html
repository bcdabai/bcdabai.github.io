<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44b561a6547e71c12b7bec6d29f71496/" rel="bookmark">
			python标出输出重定向到文件，（scapy show()函数的标注输出重定向到文件）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在进行scapy进行数据分析时，show（）函数的输出为标准输出，不好再做后续处理，因此想在代码中实现将函数的标准输出重定向到文件中，再读取文件进行处理。
将一个可写对象(如file-like对象)赋给sys.stdout，可使随后的print语句输出至该对象。重定向结束后，应将sys.stdout恢复最初的缺省值，即标准输出。
sys.stdout重定向 简单示例如下：
import sys savedStdout = sys.stdout #保存标准输出流 with open('out.txt', 'w+') as file: sys.stdout = file #标准输出重定向至文件 print 'This message is for file!' sys.stdout = savedStdout #恢复标准输出流 print 'This message is for screen!' 在我代码中需要实现的功能：
def dnsstr(filename): rrname=[] rdata=[] ''' dnstr =""" ###[ DNS Resource Record ]### rrname = 'hpd.baidu.com.' type = CNAME rclass = IN ttl = 1564 rdlen = 18 rdata = 'hpd.a.shifen.com.' ###[ DNS Resource Record ]### rrname = 'hpd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44b561a6547e71c12b7bec6d29f71496/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c45488738c04c52a86081fafe3d92fc/" rel="bookmark">
			CMAKE超级简单入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 常见编译选项预处理编译选项屏蔽警告链接 一般Cmake编译实例文件目录结构构建工程主要文件介绍根目录结构 Cmake编译内部编译外部编译 常用命令命令详解使用外部共享库和头文件静态库与动态库构建 常用变量cmake调用环境变量 控制指令IFWHILEFOREACHFUNCTION 文件安装普通文件安装目标文件安装目录安装安装CMAKE脚本 Cmake案例 常见编译选项 预处理 -D 编译宏定义：-D&lt;标识符&gt;相当于#define &lt;标识符&gt;，如-DDBUG-I 头文件包含路径：-I/backup/include-sysroot 系统头文件路径：-sysroot=/home/sysroot-MD 自动生成依赖文件：-MD,-MP 为依赖项生成假目标：-MT 更改目标名称： 编译选项 -Wall 打开所有警告-Werror 提高警告级别-Wcomment 注释不规范-Warray-bounds 数组越界-Wstrict-aliasing 严格别名-g 生成调试信息-On 代码优化级别，若n不存在，则不优化，n越大优化越大-march 为CPU架构-mtune 为CPU性能调优-mcpu CPU名称-fPIC 生成位置无关代码-fstack-protector 栈保护 屏蔽警告 -w 屏蔽所有警告-Wno-comment-Wno-array-bounds-fno-strict-aliasing-fno-common 链接 -l 链接库文件-L 链接库路径-shared-rdynamic-pie-Wl,-z,relro-Wl,-z,noexecstack-Wl,-z,now-Wl,–disable-new-dtags,-rpath 一般Cmake编译实例文件目录结构 构建工程 add_subdirectory()会处理下层文件夹中的CMakeLists.txt文件cmake -P 主要文件介绍 CMakeLists.txt：cmake配置文件，与代码同路径存放，共同进行配置管理*.sh：编译入口，调用cmake和make，执行编译config_***.cmake：编译器配置文件，包括编译类型的输出条件开关标志，输出文件名称、输出文件配置文件名称和输出文件存放路径等，一般存放在根目录下，单独的文件中重用 根目录结构 CMakeLists.txt 主CmakeLists.txt，cmake函数执行的入口
build build.sh 编译工程入口，设置编译环境变量
build_all.sh
cmake_and_compile.sh 编译入口，开始工程编译
cmake 编译器配置文件 user_config user_config.cmake
...
project_config 工程输出文件的配置文件夹
project_config.cmake
...
toolchain 针对某个工程的编译器配置文件夹
toolchain_config.cmake
...
output 编译输出目录
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c45488738c04c52a86081fafe3d92fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebeb7f1a92eb1ca4ac50bcba1e5277b8/" rel="bookmark">
			前端也需要懂，负载均衡与Nginx反向代理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面的话 常常听说负载均衡与反向代理，通过这篇文章一起体验一番。文章后面的小实例，可以体验一把Nginx是如何负载均衡的。
正向代理 举个例子： 比如你要直接访问一个外网，但是被限制了，你只好去找一个代理服务器（这个代理服务器可以与你要访问的网站通信），把请求发给代理服务器，由代理服务器代替你去请求，最终再由代理服务器将响应返回给你。这个过程就是一次正向代理。
正向代理的特点：代理的是客户端，代客户端发请求，客户端明确知道它所访问的服务器地址，而服务器却不明确处理请求究竟来自哪个具体的客户端。
反向代理 我们知道，一般电商网站，比如某宝，每天的访问量那是相当大的，如果用户发的请求全部发到单个服务器上，服务器很容易崩溃，所以一般会部署多台服务器来分担。
同样，我们还是不能直接去访问这些服务器，还是要将请求发到代理服务器上，代理服务器按一定的规则将请求发给各个服务器，最后再由代理服务将响应发回来。这个过程就是反向代理。
反向代理的特点： 代理的是服务器，代服务器接收请求，客户端不知道自己最终请求的是哪一个服务器。
负载均衡 均衡这个词，可以理解为保持每个服务器的压力均等，不要出现，有的服务器承载了很大的负载，而有的服务器几乎0负载。
那么负载均衡实际上就是将大量的请求进行分布式处理，按规则分发给每个服务器，使得每个服务器都不会出现过大负载
Nginx是什么？ Nginx作为一个基于C实现的高性能Web服务器，可以通过一系列算法 来实现负载均衡。
具有高性能、高并发、低内存占用的特点。通常被用为反向代理的工具。也就是说Nginx作为反向代理服务器，它会选择一台压力小的服务器来处理你的请求。
总结: 用户访问网站时，首先会访问Nginx服务器，然后Nginx服务器再从服务器集群中选择压力较小的服务器，来处理用户的请求。
Nginx的协议支持 Nginx工作在网络的第7层，支持HTTP/HTTPS协议的负载均衡。
Nginx支持的负载均衡调度算法 weighted round robin(加权轮询)： 每个服务器有自己的权重weght, weight值越大意味着该服务器的性能越好，可以承载更多的请求。该算法中 ，Nginx会将请求都分配给高权重的服务器，直到该服务器权重降到比其他服务器低，再将请求分配给下一个高权重的服务器。IP 哈希（IP hash）： 根据客户端的ip的hash值将请求分类，同一ip发出的请求映射到同一服务器上。在一定程度上解决了集群部署环境下Session不共享的问题。fair: 智能动态调度算法，动态的根据后端服务器的响应时间来判断负载情况，响应时间长表示负载高，分配的请求就会少。（Nginx默认不支持fair算法，如果要使用，要安装upstream_fair模块）URL hash: 根据请求的URL的hash值来分配服务器，相同的URL的请求会分配给固定的服务器当存在缓存的时候，效率一般较高。(同样要注意Nginx默认不支持这种调度算法，要使用的话需要安装Nginx的hash软件包） Nginx反向代理与负载均衡的实现 安装Nginx
去官网下载对应的nginx版本,解压，注意：放置的路径不要有中文。
小柒这里直接放置E盘：
修改conf目录下的nginx.conf文件，将端口修改，以免端口冲突，小柒这里设置为8888.
打开cmd命令行，进入目录，使用nginx -t检查配置是否正确：
正确后，使用nginx -start 命令启动，访问刚刚设置的localhost:8888,就可以看到欢迎页面：
常用命令：启动nginx : nginx -start ；重启nginx: nginx -s reload；关闭nginx：nginx -s stop；检查配置：nginx -t。
nginx.conf文件的简单说明：
worker_processes： 工作进程数，和CPU核数相同
worker_connections： 每个进程允许的最大连接数
upstream模块： 负载均衡就靠它。（下面我们会用到）
upstream firstdemo { server xxx; server xxx; server xxx; } 语法格式：upstream xxx { // 里面的server分别对应着不同的服务器 } server模块 ：实现反向代理（主要依靠proxy_pass来配置）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebeb7f1a92eb1ca4ac50bcba1e5277b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/120de8ff57f224e5fd899524d3d2c6ef/" rel="bookmark">
			使用gitlab之CI、CD部署springboot项目的步骤（部署机为ubuntu系统）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、gitlab实现自动部署的原理
1、部署机上，需要安装插件 gitlab-runner
2、部署机安装 gitlab-runner之后，向gitlab服务器注册
3、gitlab服务器收到commit事件之后，通知部署机拉取代码，执行部署。
4、部署机执行什么操作，由项目目录下的.gitlab-ci.yml文件进行定义。
二、部署机需要的环境
1、安装jdk
2、安装配置maven
3、安装 gitlab-runner
三、部署机的环境安装的具体说明
1、安装jdk 的注意事项：需要给java创建指向/usr/bin/的链接
查看java命令的安装路径： type -p java
创建链接，示例： ln -s /usr/local/jdk1.8.0_102/bin/java /usr/bin/java
2、安装maven
检查是否安装： mvn -version
下载示例： wget http://mirrors.tuna.tsinghua.edu.cn/apache/maven/maven-3/3.6.2/binaries/apache-maven-3.6.2-bin.tar.gz
创建目录：mkdir /opt/maven mkdir /opt/maven/repository
解压示例：tar zxvf apache-maven-3.6.2-bin.tar.gz -C /opt/maven
把maven配置进系统环境变量示例：vim /etc/profile
/etc/profile增加：
export M2_HOME=/opt/maven/apache-maven-3.6.2
export CLASSPATH=$CLASSPATH:$M2_HOME/lib
export PATH=$PATH:$M2_HOME/bin
配置maven的库指向alibaba的库、及配置库的路径的conf/settings.xml示例：
&lt;mirror&gt;
&lt;id&gt;alimaven&lt;/id&gt;
&lt;mirrorOf&gt;central&lt;/mirrorOf&gt;
&lt;name&gt;aliyun maven&lt;/name&gt;
&lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt;
&lt;/mirror&gt;
&lt;localRepository&gt;/opt/maven/repository&lt;/localRepository&gt;
3、安装 gitlab-runner，参考文档： https://docs.gitlab.com/runner/install/
ubuntu系统：https://docs.gitlab.com/runner/install/linux-repository.html
命令示例：
curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh | sudo bash
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/120de8ff57f224e5fd899524d3d2c6ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c599566b152cc0fcef5cad5438805a4/" rel="bookmark">
			VS2017安装时出现win 10SDK安装不了的问题，错误代码：1327
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VS2017安装时出现win 10SDK安装不了的问题，错误代码：1327 出现问题的原因主要是因为你换了一块固态硬盘（之前在上面安装过VS产品），又改了盘符，但默认注册表是没有被修改的。解决方法如下：
win+R打开资源管理器，
输入regedit，然后修改这三个值
计算机\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows App Certification Kit下的InstallLocation，将其改为现有盘路径
计算机\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows Kits\Installed Roots下的KitsRoot10也是改为现有存储路径
计算机\HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Microsoft\Windows Kits\Installed Roots下的KitsRoot10（往下拉到底就看见了）也是改为现有路径
建议原路径下有什么文件夹就在新盘里创一个文件夹，尽量只改变盘符。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9514cdb23a04c4886078337d29b955db/" rel="bookmark">
			判断数据类型的5种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. typeof 可以判断数据类型，它返回表示数据类型的字符串（返回结果只能包括number,boolean,string,function,object,undefined）；可以使用typeof判断变量是否存在（如if(typeof a!=“undefined”){…}）；Typeof 运算符的问题是无论引用的对象是什么类型 它都返回object typeof {} // object typeof [1,2] // object typeof /\s/ //object 2.instanceof 原理 因为A instanceof B 可以判断A是不是B的实例，返回一个布尔值，由构造类型判断出数据类型
console.log(arr instanceof Array ); // true console.log(date instanceof Date ); // true console.log(fn instanceof Function ); // true //注意： instanceof 后面一定要是对象类型，大小写不能写错，该方法试用一些条件选择或分支 3.通过Object下的toString.call()方法来判断 Object.prototype.toString.call(); console.log(toString.call(123)); //[object Number] console.log(toString.call('123')); //[object String] console.log(toString.call(undefined)); //[object Undefined] console.log(toString.call(true)); //[object Boolean] console.log(toString.call({})); //[object Object] console.log(toString.call([])); //[object Array] console.log(toString.call(function(){})); //[object Function] 4.根据对象的contructor判断 console.log('数据类型判断' - constructor); console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9514cdb23a04c4886078337d29b955db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c70a7aca281db90df98089652ebcf6f/" rel="bookmark">
			监听器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、监听器 https://www.cnblogs.com/zhai1997/p/11651085.html摘抄
监听器即监视域对象的创建与销毁以及域对象的属性的变化。
监听ServletContext域对象的创建与销毁：实现ServletContextListener 接口
监听HttpSession域对象的创建与销毁：实现HttpSessionListener 接口（在Session被创建的时候监听器被创建）
监听ServletRequest域对象的创建与销毁：实现ServletRequesttListener 接口
监听ServletContext域对象属性：实现ServletContextAttributeListener 接口
监听HttpSession域对象属性：实现HttpSessionAttributeListener 接口
监听ServletRequest域对象属性：实现ServletRequestAttributetListener 接口
两种方式：
1）直接new listener
2）在web.xml中配置
&lt;listener&gt; &lt;listener-class&gt;net.pp.FirstServletContextListener&lt;/listener-class&gt; &lt;/listener&gt; FirstServletContextListener.java
package net.pp; import javax.servlet.ServletContextEvent; import javax.servlet.ServletContextListener; public class FirstServletContextListener implements ServletContextListener{ @Override public void contextInitialized(ServletContextEvent servletContextEvent) { System.out.println("Servletcontext初始化了"); } @Override public void contextDestroyed(ServletContextEvent servletContextEvent) { System.out.println("Servletcontext销毁了"); } } FirstHttpSessionListener.java
package net.pp; import javax.servlet.ServletContextEvent; import javax.servlet.ServletContextListener; import javax.servlet.annotation.WebListener; import javax.servlet.http.HttpSessionAttributeListener; import javax.servlet.http.HttpSessionEvent; import javax.servlet.http.HttpSessionListener; import javax.servlet.http.HttpSessionBindingEvent; @WebListener() public class FirstHttpSessionListener implements HttpSessionListener{ // Public constructor is required by servlet spec public FirstHttpSessionListener() { } public void sessionCreated(HttpSessionEvent se) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c70a7aca281db90df98089652ebcf6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e5056010bea200304d920a6cbc2849a/" rel="bookmark">
			一篇文章掌握整个JVM，JVM超详细解析！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JVM 先想想一些问题1 我们开发人员编写的Java代码是怎么让电脑认识的2 为什么说java是跨平台语言3 Jdk和Jre和JVM的区别4 为什么要学习JVM 深入学习JVM1 JVM运行时数据区2 解析JVM运行时数据区2.1 方法区（Method Area）2.2 Java堆（Java Heap）2.3 程序计数器（Program Counter Register）2.4 Java虚拟机栈（Java Virtual Machine Stacks）2.5 本地方法栈（Native Method Stack） 3 Java内存结构3.1 直接内存（Direct Memory）3.2 JVM字节码执行引擎3.3 垃圾收集系统 4 JVM的垃圾回收机制4.1 什么是垃圾回收机制4.2 finalize方法作用4.3 新生代、老年代、永久代(方法区)的区别4.3.1 为什么要这样分代：4.3.2 Minor GC、Major GC、Full GC区别及触发条件 4.4 如何判断对象是否存活4.4.1 引用计数法4.4.2 可达性分析法 4.5 垃圾回收机制策略（也称为GC的算法）4.5.1 引用计数算法（Reference counting）4.5.2 标记–清除算法（Mark-Sweep）4.5.3 标记–整理算法4.5.4 复制算法4.5.5 分代算法（主要的算法就是上面四种，这个是附加的） 5 垃圾收集器5.1 什么是垃圾收集器？5.2 垃圾回收器详解5.2.1 Serial5.2.2 ParNew5.2.3 Parallel Scavenge5.2.4 Serial Old5.2.5 Parallnel old5.2.6 CMS5.2.7 G1 6 JVM参数配置6.1 JVM内存参数简述6.2 JVM的GC收集器设置6.3 JVM参数在哪设置6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e5056010bea200304d920a6cbc2849a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c762a003724386cf27ff200040f5c84/" rel="bookmark">
			Java实现 LeetCode 621 任务调度器（暴力大法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		621. 任务调度器 给定一个用字符数组表示的 CPU 需要执行的任务列表。其中包含使用大写的 A - Z 字母表示的26 种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。CPU 在任何一个单位时间内都可以执行一个任务，或者在待命状态。
然而，两个相同种类的任务之间必须有长度为 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。
你需要计算完成所有任务所需要的最短时间。
示例 ：
输入：tasks = [“A”,“A”,“A”,“B”,“B”,“B”], n = 2
输出：8
解释：A -&gt; B -&gt; (待命) -&gt; A -&gt; B -&gt; (待命) -&gt; A -&gt; B.
提示：
任务的总个数为 [1, 10000]。
n 的取值范围为 [0, 100]。
PS：
A-X-X-A-X-X-A；
这是间隔两个
count【25】-1是因为最后一个我放进maxcount了
n+1是因为我虽然间隔两个但是其实我是三个一组
class Solution { public int leastInterval(char[] tasks, int n) { int[] count = new int[26]; for (int i = 0; i &lt; tasks.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c762a003724386cf27ff200040f5c84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0dd6327fbe2a52ae4afd62e03dc5611/" rel="bookmark">
			全民飞机大战(java)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、需求
二、窗体、面板、背景图的绘制
2.1 工具类
2.2 面板类
2.3 窗体类
2.4 效果图
三、英雄机的出现及移动
3.1 定义飞行父类
3.2 英雄机的出现
3.3 加入鼠标监听器
3.4 英雄机的移动
四、敌机的出现及移动
4.1 敌机类
4.2 敌机入场
4.3 敌机移动
4.4 启动一个线程
4.5 效果图
五、英雄机子弹的出现及移动
5.1 英雄机子弹类
5.2 英雄机发射子弹
5.3 英雄机子弹移动
5.4 效果图
六、敌机子弹的出现及移动
6.1 敌机子弹类
6.2 敌机发射子弹
6.3 敌机子弹移动
6.4 效果图
七、击中问题
7.1 英雄机子弹击中敌机
7.2 敌机子弹击中英雄机
7.3 敌机与英雄机相撞
7.4 效果图 八、游戏的开始与结束
8.1 鼠标点击监听事件
8.2 开始与结束界面
8.3 效果图 九、加入音效
9.1 音乐类
十、遇到的问题
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0dd6327fbe2a52ae4afd62e03dc5611/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9eb8163730b927b877f8436474c6e458/" rel="bookmark">
			Android开发之C盘瘦身（gradle瘦身）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 总所周知，Android Studio默认会在C:\Users\用户名\ .xxx 缓存一些数据。当使用Android Studio时间越来越长时，会发现C盘存储空间越来越小。
存储空间增加的主要原因是：
经常导入第三方工程，会从远程下载大量第三方依赖，gradle相关插件，且不同编译版本需要下载对应support依赖经常编译会产生大量日志文件模拟器镜像文件占用大小，有时候删除模拟器不彻底导致残留
为了减少对C盘空间的占用，可以对如下目录进行清理：
当然你可以修改AS配置默认路径，.gradle缓存路径，为了防止出现意外，不建议修改， 瘦身处理 删除C:\Users\用户名\.android\avd目录下不要的模拟器镜像删除C:\Users\用户名\.gradle\wrapper\dists不要的gradle版本，保留常用版本（本人3.0以下的gradle版本已经全部清理，当导入的工程基于gradle3.0以下编译时,可以先修改本地支持的gradle版本和插件版本再导入工程）
删除C:\Users\用户名\.gradle\caches不要的gradle版本缓存，跟第2点对应删除（依赖可以选择性删除）删除C:\Users\用户名\.gradle\daemon下每个gradle版本的.log日志文件（长期gradle构建编译，会产生大量日志文件，可达几个GB）
备注：
误删gradle，通过下面地址下载并放到对应目录：
https://services.gradle.org/distributions/ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b8df8a3378c271029495718bf2fa5a1/" rel="bookmark">
			Lua学习笔记之“.”和“：”的作用和用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1、博客介绍
2、内容
含义：
“:”声明方法并采取“:”的形式调用:
“:”声明方法并采取“.”的形式调用:
“.”声明方法并采取“.”的形式调用:
“.”声明方法并采取“:”的形式调用:
3、推送
4、结语
1、博客介绍 本篇博客作为Lua学习笔记之一，介绍关于方法中“.”和“:”的用法和不同含义，我们知道在声明方法的时候可以采用“.”或者“:”的写法，同时在调用方法的时候，也可以采用“.”和“:”的写法，这两种形式可能交叉存在，本篇博客就简单介绍一下几种情况。
2、内容 含义： 1、使用":"来声明方法，那么在接收参数时会默认去接收一个参数self，这个接收位置是隐藏的
2、使用"."来声明方法，在参数内的第一位会默认去接收self参数，这个参数不隐藏
3、使用":"来调用方法，在传递参数的时候，会默认传递一个self，这个self隐藏并置于所有参数之前
4、使用"."来调用方法，在传递参数的时候，第一位参数默认会被作为self传递过去，这个参数不会被隐藏
如下所示，方法testFunc1和方法testFunc2等同，并且下方调用输出结果相同
local func = {} function func:testFunc1(a,b,c) print(a,b,c) end function func.testFunc2(self,a,b,c) print(a,b,c) end func:testFunc1(1,2,3) func.testFunc1(self,1,2,3) “:”声明方法并采取“:”的形式调用: testFunc1是":"定义的方法，所以实际接收参数格式应为(self,a,b,c)，self参数被隐藏
这里调用是采用“:”的形式调用，所以实际传递的参数为(self,1,2,3)，self参数被隐藏
所以这里输出结果self是func表本身，abc为1 2 3
local func = {} function func:testFunc1(a,b,c) print(self) print(a,b,c) end func:testFunc1(1,2,3) -----------------------------------输出 table: 00C19238 1	2	3 “:”声明方法并采取“.”的形式调用: testFunc1是":"定义的方法，所以实际接收参数格式应为(self,a,b,c)，self参数被隐藏
这里调用是采用“.”的形式调用，传递的参数为(1,2,3)，1会被当做self被传递
所以这里输出结果self为1，abc为2,3，nil
local func = {} function func:testFunc1(a,b,c) print(self) print(a,b,c) end func.testFunc1(1,2,3) -----------------------------------输出 1 2	3	nil “.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b8df8a3378c271029495718bf2fa5a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e9c521e36b696d59c831de698789af5/" rel="bookmark">
			《机器学习》周志华练习参考答案---第7章.贝叶斯分类器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		练习1.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7836d58d89c0283f9565f28973c548d3/" rel="bookmark">
			使用 Unlock Music 解锁加密的音乐文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		国内各行各业各个领域，版权意识都在逐渐增强，原本是好事，但国人普遍较为聪明，尤其是小聪明，撇开那些版权流氓不谈，各种套路也是层出不穷。以音乐文件为例，过去虽然网速不咋的，但是有太多的渠道可以下载喜欢听的音乐，最不济还可以去淘那些几块钱一张的盗版碟，省去许多麻烦，然而渐渐的，渠道越来越少，优质的音乐资源也集中到了几大巨头旗下，其实视频资源也是如此，分散而不集中，各家会员开一遍也还不够，各种套路（例如单曲单独购买、视频超前点播等等）接踵而来，花钱还让人花得这么不痛快，这就不能忍了。注：此文章仅分享方法，相关工具均来自开源项目。
软件名称：Unlock Music
软件版本：1.3.4 (Build 2020/03/12)
工程地址：https://github.com/ix64/unlock-music
下载页面：https://github.com/ix64/unlock-music/releases/tag/1.3.4
网盘下载：https://pan.baidu.com/s/1zhBMW2aD-zXzk8cuJJUV7Q
目前常见的加密音乐文件比如腾讯QQ音乐的MGG和网易云的NCM等，不一一列举，此类格式音乐文件无法使用其它播放器播放且一旦购买的会员过期也无法再继续播放，对于博主这类喜欢收藏的人群来说，十分的不友好。用录音软件转录一下吧，也不是不可以，但终归麻烦，再加上博主是B型血处女座，完美主义至上，所以还是倾向于解密原文件的方式，期间也有想过自己动手调试播放器看看都调用了哪些接口然后开发个解密的小软件，一来忙二来懒，迟迟没有动手，然后今天偶然就发现了这个开源的项目，解决了博主的困扰。由于不是桌面应用，需要一台WEB服务器予以支持，但是博主感觉也没必要为了一个软件就再写一篇搭建WEB服务器的教程，好吧，我就是懒罢了，所以，接下来，就简单介绍一下Windows平台的使用方法。
1. 下载软件包 通过博主提供的下载链接自行下载软件包，GitHub在国内访问不是特别稳定，下载不下来的可以通过博主提供的网盘下载链接下载博主下载好的最新版本，如下图所示：
其中"legacy"版本支持FILE协议可以使用浏览器直接打开使用，"morden"版本支持HTTP/HTTPS协议，本文以此版本为例进行讲解，下载该软件包并保存到指定位置。
2. 安装IIS服务器 由于不涉及语言环境、数据库等，微软自家的IIS完全可以满足。由于博主是使用虚拟机环境演示，操作系统为 Windows 7 旗舰版，使用 Windows 10 的朋友可以参考补充截图完成IIS的安装。注意，操作系统版本需要专业版以上才支持IIS。
耐心等待片刻直至系统更新完毕，此后系统分区根目录下会多出IIS服务器的根目录，在浏览器（注意，此软件仅支持谷歌浏览器、微软Edge等 Chromium 内核的浏览器）地址栏键入"http://localhost"验证服务器是否正常启动，如下图：
至此，IIS服务器安装完毕，下附 Windows 10 安装 IIS 的参考图
3. 部署 Unlock Music 到服务器 将下载的"morden.tar.gz"释放到"C:\inetpub\wwwroot"目录下，如下图所示：
回到谷歌浏览器，由于IIS默认的主页清单设置中"index.html"优先级较高，所以在刚才的IIS主页直接按F5刷新，即可看到 Unlock Music 的界面了，如下图所示：
4. 转换音乐文件示例 此处以QQ音乐的MGG文件为例，博主下载了周董的半岛铁盒，音质选择HQ高品质（若非视频剪辑素材需要，博主通常不会下载无损格式，自认没有那么灵敏的耳朵），文件类型为MGG，可以看到提示该歌曲下载后仅限会员有效期内本地播放。
将该文件拖动到谷歌浏览器刚才打开的页面指定区域中，如果没有什么意外，会弹出解锁成功的提示，下面列表会给出刚才添加的音乐文件下载方式，点下载按钮即可将解锁后的文件保存至本地，如下图所示：
好了，至此，加密的音乐文件解锁完成，可以拿着解锁后的原文件随心所欲转换到其它播放器支持的格式或是收藏保存了，网易云音乐加密音乐文件解密的操作方式类似，大家可以自行尝试。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/746cce3ae2ed34c7d3193847bd6670f4/" rel="bookmark">
			视觉SLAM：视觉SLAM中的李群与李代数、左乘扰动模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么引入李群与李代数？
SLAM中对矩阵求导数的应用场景？什么情况下用到李代数左乘扰动模型求导数？
为什么不能用李群求导？
李群与李代数的关系？
李代数左乘扰动的理解？
0 为什么引入李群与李代数？
slam中后端优化需要用到求解最小二乘问题，优化变量为旋转矩阵与平移矩阵。但是旋转矩阵自身是带有约束的，正交且行列式为1，他们作为优化变量时，会引入额外的约束，使优化变的困难，不加约束会使每一步迭代得到的结果不是旋转矩阵。通过李群李代数的转换关系，把位姿估计变成无约束的优化问题。
1 李群与李代数在SLAM中的用途
视觉SLAM中用李群表示相机位姿T，用李代数求导数。
对于同一个特征点，如果上一时刻得到该点相机坐标系下的三维坐标为P，当前时刻观测到相机坐标系下的坐标为Z，则两时刻相机位姿变化矩阵为T，有如下公式：
为误差。目的是求解矩阵T，得到相机的位姿变换，以此迭代下去得到相机的运动轨迹。
由于误差不可避免，并且两时刻之间可以观测到很多匹配好的特征点，因此一般用很多观测到的特征点构建优化问题，以减小求解误差：
(1-2)
变化矩阵的形式如下：
变化矩阵T包含了旋转R与平移t信息，其重要性质：两个矩阵T相乘得到的同样是一个变化矩阵。比如矩阵T1和T2表示两个变化矩阵，则：
因此变化矩阵T恰好是一个李群，即对乘法封闭的李群。我们的目的是求解问题（1-2），即优化变量为T，优化问题为最小二乘问题，可以利用李群的性质求解优化问题（1-2）。
2 不用李群求导数的原因
对于最小二乘问题（1-2）求解办法一般是梯度法，需要求解函数J对矩阵T的导数，并且每次迭代：。但是李群T对加法没有封闭性。比如T1与T2都是变化矩阵，但是T1+T2一定不是变化矩阵，即无法求导得到。因此需要进行转化，将该问题转化为对加法封闭，并且能够表示变化矩阵信息。
李代数对应李群，李代数满足加法，因此可以利用李群与李代数之间的关系求解导数。
3 李群与李代数的关系
李群 = 矩阵集合+运算，比如变化矩阵T对乘法封闭，即构成"实数+乘法"的群。
李代数描述了李群的导数，是向量。
旋转矩阵R构成的李群对应的李代数是旋转向量，变化矩阵T构成的李群对应的李代数是旋转向量与平移向量组成的六维向量，slam中只用到这两个群的概念，其余的不会。并且这两个李群与对应的李代数是一一对应的。（角度固定在之间。）
李群转化为李代数通过对数映射，李代数转化为通过指数映射完成。具体如下：
a表示单位方向，为模长，即旋转向量。
4 左乘扰动模型理解
旋转矩阵的左乘扰动模型求导：
假设对空间点P进行了旋转R操作，需要求RP关于R的导数，求导方法是对R进行一次扰动。设R的李代数为，的李代数为。对求导：
理解：我们的目的是迭代求解出旋转矩阵，只要能够求解出优化方程中的旋转矩阵，使目标函数逐渐减小即可。因此给旋转矩阵乘以一个旋转矩阵微小扰动，然后对该扰动求解导数，此时变量变成了微小扰动。如果能够求解出该微小扰动，并且该微小扰动可以使目标函数减小，说明该微小扰动作为更新量是可行的，迭代公式变为。
同理变化矩阵的左乘扰动模型求导如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d17cb269deaabcbd2972479992ee6add/" rel="bookmark">
			在虚拟机中ping了停不下来怎么办？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述：那天在弄虚拟机的时候不知道怎么回事ping命令就一直运行，用了ctrl+c和ctrl+z都没有用
解决：1.有可能在设置快捷键的时候设置了ctrl的快捷键，修改了应该就可以了
2 关闭虚拟机重启也是最简洁粗暴的方法，但是有什么影响还未可知
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d768c0299bdbec548be201165fd77f8/" rel="bookmark">
			【2020春招记录】网易雷火笔试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		又是为自己的无知流泪的一年
一. 网易雷火笔试 300’ 第一题26个字母分别算个斐波那契就行第二题是个小贪心，按价值从大到小排个序，从最大的开始杀，杀这个数最好的时间就是他消失之前的那个时间点。第三题一个模拟，按题目要求模拟就行第四题四元数坑了我，最后20分钟调出了样例交上去还是0分，这题我实在没法手出样例算了，有时间好好再学学四元数，再调吧，放一个没A的代码省的删了。 // Didn't AC #define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;cmath&gt; #include &lt;vector&gt; #include &lt;list&gt; #include &lt;set&gt; #include &lt;map&gt; #include &lt;unordered_map&gt; using namespace std; struct quaternion{ double t; double x; double y; double z; }; quaternion mul(quaternion left, quaternion right) { quaternion ans; double d1, d2, d3, d4; d1 = left.t * right.t; d2 = -left.x * right.x; d3 = -left.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d768c0299bdbec548be201165fd77f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/209bd6a6ecdd25b290f2128806500934/" rel="bookmark">
			解决尝试连接“ECONNREFUSED - 连接被服务器拒绝”失败的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用的配置是VMware，Ubuntu和FilleZilla
解决：首先检查主机号是否正确（这里的主机号是虚拟机的主机号，不是电脑的主机号）
然后检查虚拟机ssh服务是否开启
当然用户名和密码是一定要正确的
最后实在不行的话就重新创建一个新的站点
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5218008c9a44392e0c807e86c632f7f9/" rel="bookmark">
			通信原理 AMI码和HDB3码的编码方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 AMI 简介 AMI:消息码的“1”交替地变换为“+1”和“-1”，而“0”保持不变。
优点：没有直流成分，高，低频分量少，编码电路简单，可利用传号极性交替这一规律 观察误码情况。缺点：当码元出现长连0时，信号电平长时间不跳变，造成提取定时信号困难。 编码： 假设前面是 - 1
HDB3 HDB3:若消息码中连0个数小于等于3则编码规则同AMI码；若连0个数大于3则每 四个0化作一小节，定义为B00V。V与前一个非0脉冲极性要相同且与相邻的V码极性交替。相邻V码间1的个数为奇数时B为0，若为偶数时（包括0）则添B码再根据前后极性判断正负。
优点：AMI的都有，解决了连0问题，保证了定时信息的提取。缺点，编码复杂。 编码： 连0 个数超过3时，每4个连0变为000V,
加入V码，检查两个相邻的V码之间的1 的个数，如果有奇数个1时，这四个连0用000V表示，如果有偶数个1时 这四个连0用B00V表示
加入极性，在B码与V码都确定之后，首先可以先将V码的极性确定，因为V码的极性必须交替，假如第一个1 的极性为+，即+1。则第一个V的极性为+，因为V码的极性与前一个非0码极性相同，之后保证V码极性交替即可
接下来需确定1与B的极性，此时1与B一起确定极性，即相当于把B看做1，1与B一起极性交替。
完成HDB3编的编码 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3210f640ece0750717fc4f5eb5402ede/" rel="bookmark">
			​WebStorm 超好用的10款插件，效率提升了好多！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​WebStorm 超好用的10款插件，效率提升了好多！ WebStorm 是jetbrains公司旗下一款JavaScript 开发工具。已经被广大中国JS开发者誉为“Web前端开发神器”、“最强大的HTML5编辑器”、“最智能的JavaScript IDE”等。与IntelliJ IDEA同源，继承了IntelliJ IDEA强大的JS部分的功能。
今天主要跟大家介绍这款软件的10款最好用的插件，分享给大家！Ps:本篇介绍的大部分插件，IntelliJ IDEA 上也基本都可以使用！
1、CodeGlance 用过 sublime 的同学会知道右侧有一个当前文件中代码的缩略图，这个插件可以让 webstorm 也具有此功能。
2、Rainbow Brackets 最近在Jetbrains IDEA插件网站逛发现了 Rainbow Brackets这款插件，非常棒，推荐给大家。
可以实现配对括号相同颜色，并且实现选中区域代码高亮的功能。
对增强写代码的有趣性和排错等都有一些帮助。
https://plugins.jetbrains.com/plugin/10080-rainbow-brackets
3、.ignore
在使用git的时候，经常会碰到一些不想提交的文件，这个时候就需要用到.gitignore文件了。
.gitignore不需要完全从头自己写，github提供了一系列配置模板，链接如下：
https://github.com/github/gitignore
使用.ignore插件更方便的生成.gitignore文件
4、ideaVim IdeaVim是一款插件，可以让 webstorm 编辑器支持 vim ，提高了我们写代码的速度，对代码的跳转，查找也很友好。
5、AceJump Ace Jump是一种从emacs上借鉴过来的快速光标跳转方式，操作方式是：你用某个快捷键进入Ace Jump模式后，再按任一个键，当前屏幕中所有该字符都被打上一个字母标记，你只要按这个字母，光标就会跳转到这个字符上。这种跳转方式非常实用，你根本不用管当前光标在什么位置，眼睛只需要盯着需要跳转到的位置，最多三四下按键就能准确把光标定位，开始编辑。
6、Key promoter Key Promoter 是一个提示插件，当你在IDEA里面使用鼠标的时候，如果这个鼠标操作是能够用快捷键替代的，那么Key Promoter 会弹出一个提示框，告知你这个鼠标操作可以用什么快捷键替代。对于想完全使用快捷键在IDEA的，这个插件就很有用。
7、Markdown
让编辑器支持 markdown 语法，程序员的最爱！
8、Material Theme UI
俗话说，工欲善其事必先利其器。工具的颜值也很重要，好的主题让人赏心悦目，有码代码的欲望。今天推荐一个IDEA颜值类插件：Material Theme UI
9、SVNToolBox 要使用svn版本控制，可以使用这个插件，版本控制是程序员必备的技能之一了 。在Webstorm中安装“SVNToolBox”插件，大家可以去网上教程搜索一下，非常多 。
10、activate-power-mode 这种粒子+抖动效果是用activate-power-mode插件实现的，简直就是装逼神器。有开发者将此插件移植到了webstorm中。
下载activate-power-mode插件安装包：
https://plugins.jetbrains.com/plugin/8330-activate-power-mode
到这里，今天这个WebStorm 超好用的10款插件就分享完了。不知道你心动了吗？快去试试吧！如果有更好的插件，欢迎在留言区分享！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d7fc2737f3496ebaede1ca055066abd/" rel="bookmark">
			C&#43;&#43;异常的处理机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		异常 1、异常的概述常见的异常：除0溢出，数组下标越界，所要读取的文件不存在,空指针，内存不足等等。c++的异常一旦抛出 如果不捕获 该异常 程序直接退出 1.1、C语言通过返回值 来判断 第一：容易忽略 第二：容易和正常的结果混淆1.2、c++抛出异常 并捕获c++的异常一旦抛出 如果不捕获 该异常 程序直接退出抛出异常：throw捕获异常：try......catch 2、栈解旋(unwinding)异常被抛出后，从进入try块起，到异常被抛掷前，这期间在栈上构造的所有对象，都会被自动析构。析构的顺序与构造的顺序相反，这一过程称为栈的解旋(unwinding). 3、异常的接口声明4、异常的生命周期 的三种情况4.1、以普通变量形式捕获4.2、以指针形式捕获4.3、以引用形式捕获（推荐使用） 5、标准异常案例 6、异常的多态使用 1、异常的概述 常见的异常：除0溢出，数组下标越界，所要读取的文件不存在,空指针，内存不足等等。 c++的异常一旦抛出 如果不捕获 该异常 程序直接退出 1.1、C语言通过返回值 来判断 第一：容易忽略 第二：容易和正常的结果混淆 int myDiv(int a,int b) { if(b == 0) return -1;//-1表示失败 return a/b; } void test01() { int ret = myDiv(10,-10); if(ret == -1) { cout&lt;&lt;"程序异常了"&lt;&lt;endl; } else { cout&lt;&lt;"程序正常"&lt;&lt;endl; } } 运行结果：
1.2、c++抛出异常 并捕获 c++的异常一旦抛出 如果不捕获 该异常 程序直接退出 抛出异常：throw 捕获异常：try…catch int myDiv01(int a,int b) { if(b==0) throw 0;//抛出异常 return a/b; } void test02() { try{ int ret = myDiv01(10,0); cout&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d7fc2737f3496ebaede1ca055066abd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2097067943d5ed952600070835406ce/" rel="bookmark">
			java详细学习路线及路线图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文将告诉你学习Java的一些步骤，学习过程中可能遇到的问题，及学习路线。希望能够对你的学习有所帮助。 一、Java基础 二、Java学习七大阶段 阶段1、JavaSE基础 阶段2、WEB前端 阶段3、数据库 阶段4、JavaWeb Javaweb
XML
XML以及相关概念
dom4j+xpath
Servlet
B/S架构概论
Tomcat服务器安装与配置
怎么写一个Servlet
Servlet生命周期
ServletConfig
ServletContext
Servlet线程安全问题
Http协议详解&amp;GET和POST区别与选用
HttpServletRequest
HttpServletResponse
Cookie
HttpSession
转发和重定向
Filter
责任链设计模式
Listener
观察者设计模式
JSP&amp;FreeMarker&amp;Velocity
JSP核心语法
EL表达式
JSTL标签
FreeMarker
Velocity
AJAX
AJAX核心原理
jQuery-AJAX
AJAX跨域
阶段5、JavaWeb项目 阶段6、流行框架 阶段7、前沿技术&amp;架构师项目 上述原文点击打开链接
上面图片来自原文链接
上面图片来自原文链接
数据结构与算法
数据结构是以某种形式将数据组织在一起的集合，它不仅存储数据，还支持访问和处理数据的操作。算法是为求解一个问题需要遵循的、被清楚指定的简单指令的集合。下面是自己整理的常用数据结构与算法相关内容，如有错误，欢迎指出。
为了便于描述，文中涉及到的代码部分都是用Java语言编写的，其实Java本身对常见的几种数据结构，线性表、栈、队列等都提供了较好的实现，就是我们经常用到的Java集合框架，有需要的可以阅读这篇文章。Java - 集合框架完全解析
一、线性表 1.数组实现 2.链表 二、栈与队列 三、树与二叉树 1.树 2.二叉树基本概念 3.二叉查找树 4.平衡二叉树 5.红黑树 四、图 五、总结 一、线性表 线性表是最常用且最简单的一种数据结构，它是n个数据元素的有限序列。
实现线性表的方式一般有两种，一种是使用数组存储线性表的元素，即用一组连续的存储单元依次存储线性表的数据元素。另一种是使用链表存储线性表的元素，即用一组任意的存储单元存储线性表的数据元素（存储单元可以是连续的，也可以是不连续的）。
数组实现
数组是一种大小固定的数据结构，对线性表的所有操作都可以通过数组来实现。虽然数组一旦创建之后，它的大小就无法改变了，但是当数组不能再存储线性表中的新元素时，我们可以创建一个新的大的数组来替换当前数组。这样就可以使用数组实现动态的数据结构。
代码1 创建一个更大的数组来替换当前数组 int[] oldArray = new int[10]; int[] newArray = new int[20]; for (int i = 0; i &lt; oldArray.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2097067943d5ed952600070835406ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a1066ca57bbeb4216bc794f46e47d1e/" rel="bookmark">
			华为华三思科路由器连接交换机的几种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		路由器一般连接不同网段，隔离广播域，交换机用来扩展主机，可以隔离冲突域；
路由器和交换机连接有以下几种方法：
路由器和交换机连接方法一般为以下三种： 1.交换机划分VLAN，并通过VLAN虚接口配置地址，将路由器与交换机互联的接口划分到相应的VLAN下，此时链路类型trunk和access都可以，路由器直接在三层接口下配地址；
2.路由器和交换机分别划分VLAN后通过VLAN虚接口配置地址，然后在路由器和交换机上将互联的接口划分到相应的VLAN下；
3.路由器划分子接口，并封装802.1协议，交换机和路由器链路类型为trunk；
以下是在华为华三思科模拟器上做实验的结果： 华为设备配置命令： 拓扑图：
方法1.路由器：
interface Ethernet0/0/0
ip address 10.10.23.2 255.255.255.0
交换机：
interface Vlanif10
ip address 10.10.23.3 255.255.255.0
interface GigabitEthernet0/0/1
port link-type access
port default vlan 10
方法2.路由器：
interface Vlanif10
ip address 10.10.25.2 255.255.255.0
interface Ethernet0/0/1
portswitch （三层接口与二层接口转换）
port link-type access
port default vlan 10
交换机：
interface Vlanif20
ip address 10.10.25.5 255.255.255.0
interface GigabitEthernet0/0/1
port link-type access
port default vlan 20
方法3：路由器：
interface GigabitEthernet0/0/0.30
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a1066ca57bbeb4216bc794f46e47d1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/686b192eac2844d87b892693c481e53d/" rel="bookmark">
			信贷系统架构概要
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、业务流程
1、信贷业务一般会根据目标客群设计业务场景、信贷产品，通过投放、场景切入引导目标客群进入到身份认证、资料填写。
2、资料填写过程中进行前置准入规则、反欺诈策略预判，对前置准入通过的客户进行征信调用，完成深度信用审批、反欺诈策略判断。根据产品需要可增加人工信审环节对客户提交资料进行复核质检。
3、对准入客群根据风险计量评分卡进行风险定价、审批信用额度，进入贷中提现环节。贷中环节包含两部分风险控制：
3.1、未提现额度回溯：对客户贷中未提现的信用额度进行风险回溯，根据最新风险规则主动额度管理；
3.2、提现环节：对客户提现行为进行欺诈规则检验，根据外部不良信息更新提现拒绝规则或者转人工核查。
4、客户提现后进入贷后管理，贷后系统核心主要是客户账户管理、扣款管理、清结算管理，对回款失败客户进入催收环节。
5、逾期催收包含案件案例、分案管理、案件催收、委外管理。
信贷全生命周期
二、风险模型
反欺诈的作用主要是进行身份识别、用途识别，通过身份验证、运营商数据、黑名单、设备异常、群体异常等手段识别借款欺诈客户。
风控流程一般是先进行策略规则的风险判断，再进入评分模型的风险识别。策略规则具有直观、易用等特性，但很难做到风险决策的精细化管理。评分卡模型具备精准量化风险，有效识别的大量灰色客群。策略与模型权衡决策：
1、建模数据集与实际贷款人之间存在偏差（征信数据不健全，通过策略维度纠正保护模型偏差）；
2、模型数据集来自历史，与未来实际情况存在偏差（通过策略维度纠正经济变化趋势）；
3、模型对于目标变量的界定与实际商业目标存在偏差（通过策略维度纠正借款期限商业目标）。
全生命周期风险管理模型及策略：
贷前审批决策流程：
贷中管理策略流程：
贷后催收管理方案：
三、信贷系统架构
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2848939fd8c19fde7ea56d56d1b4d37b/" rel="bookmark">
			数学发展通史与应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数学是一门基础学科，是我们自然科学、人文社会科学的一个非常重要的工具，依赖严格的逻辑推理，从5个基础的公理出发，5构建了严密的数学大厦。近代数学起源于美索不达米亚、埃及，经过希腊文明升华传播，从简单观察，工程应用，上升到了理性分析，从给出原则性结论到公理化、定理化的量化结论。使数学大厦能够基于严谨的推理而来，每一个数学定理都是可叠加的基石。
一、现代数学发展脉络：
1.1、毕达哥拉斯定理
毕达哥拉斯定理在中国又被称为勾股定理，古时美索不达米亚、埃及也发现了不少勾股数，但是古希腊著名数学家毕达哥拉斯给出了准确的定理定义：直角三角形两条直角变的平方和等于斜边的平方。
毕达哥拉斯定理的确立，教会了人们在平面计算距离的方法，在此基础之上，三角学才得以建立，笛卡尔的解析几何才得以确立。定理与测量、特例是不同的，测量、特例是作为一种经验积累，不能作为一种通用的可叠加的知识体系。定理可以由特例观测、抽象而来，也可以基于严谨的推论而来。数据是基于严谨的逻辑推理而来，每一个定理都是可叠加的基石。
1.2、欧式几何
欧式几何学由非常基础的10条公理（5条一般性公理+5条几何学公理）出发，依靠通过严格逻辑推理、发现一系列定理，逐步建立起完整的数学大厦。
五条一般性的公理分别是：
1、如果a=b, b=c, 那么a=c；
2、如果a=b，c=d，那么a+c=b+d;
3、如果a=b，c=d，那么a-c=b-d;
4、彼此能重合的物体（图形）是全等的;
5、整体大于部分。
五条几何公理：
1、由任意一点到另外任意一点可以画直线（也称为直线公理）；
2、一条有限直线可以继续延长；
3、以任意点为心，以任意的距离（半径）可以画圆（圆公理）；
4、凡直角都彼此相等（垂直公理）；
5、过直线外的一个点，可以做一条，而且仅可以做一条该直线的平行线（平行公理）。至于平行线，就是平面上永不相交的两条线。
解析几何的建立，笛卡尔通过平面直角坐标（笛卡尔坐标）将代数与几何建立关联，用代数简化几何分析复杂度，并对代数分析建立更加直观的分析工具。
1.3、代数学
1.3.1、函数
函数是一种自变量与因变量特殊的对应关系，任何一个变量对应一个函数值，反映一个变量与函数值的变化趋势，可以是线性的、对数的、指数级的变化趋势。函数的使用需要考虑使用范围，要根据实际场景设定变量域值。
关于公式的因果关系,一个变量的函数，变量变化会导致函数值产生因果关系的变化；多个变量的函数，有些会与函数值正相关变化，有些不会有决定性相关，切忌把相关性与因果关系混为一谈。
1.3.2、向量与矩阵
在向量代数中，数字是有方向的，在坐标轴上代表数字坐标方向，向量之间的夹角决定向量相加大小，夹角越小，相加值越大；夹角越大，相加值越小。余弦反映的是两个相邻向量（或三角形的边）的夹角关系，夹角越小，相关度越高，夹角越大，相关度越低，信息学中常用来表现变量向量的相关度。
M*N的矩阵，M行代表一个向量主体，N代表N个维度的向量分量（维度）。矩阵是虚构出来的，为了方便从单个维度计算转换为批量维度计算，方便聚焦整体，方便数学批量推导，信息时代方便计算机批量计算，以及人的大脑理解。矩阵运算属于线性运算，因为计算的维度都是一元线性运算。矩阵相乘在金融领域应用较广，可以从多个维度组合金融向量。
1.4、微积分：数学从初级到高级的发展
数学学习从初级到高级需要用动态趋势的眼光去看待，需要从相关性趋势的抽象去描述，通过动态趋势分析判断事物本质。
极限反映的是一种动态趋势，通过极限完善微积分体系，人类通过微积分能够计算瞬时变化速率。无穷大、无穷小的比较主要看动态变化速率，也就是阶速。计算机比较擅长计算，比较计算机算法好坏通常看趋向无穷大时的阶数大小。
微分反映某个时间瞬时点变化的速率，表现为三角函数切线率。导数本质上是对变化快慢的准确量化度量。微分最重要的概念是梯度，梯度表示哪个维度变量变化趋势最大。从宏观变化了解微观趋势。
导数在数学上更本质的意义，在于它是对于连续性的一种测度，光滑、连续的导数曲线，可以成为判断未来走势的依据。奇点和尖点是不可导的，不可导的趋势不光滑，是不可靠的。
寻找导数为零的拐点方法，发明一种通过跟踪函数从低到高，再到平稳，最后再下降的变化，而求最大值的方法，导数为零时（切线与横坐标平行）的点就是最大值点。这就让人类对事物的理解从静态，到动态了。
积分是从微观看宏观变化，距离是速度的积分，速度是距离变化的微分，微分和积分是互为逆运算的。积分思想的本质是要看动态变化的累积效应，积分的意义是从微观上每一时刻动态的变化理解宏观上积累的效果，对于速度来说累积效应就是距离。积分的累积有滞后效应，初始速度较低，累计距离较慢，随着加速度越来越快，累计效应开始显现。
1.5、概率论
概率论起源：早起起源于赌博行业，伯努利试验定义只有通过大量可重复才有价值，对不确定性、随机的时间寻找规律进行概率统计。
概率公理化：前苏联伟大的数学家柯尔莫哥洛夫定义基于三个简单公理定义概率论：
公理一：任何事件的概率是在0和1之间（包含0与1）的一个实数。
公理二：样本空间的概率为1，比如掷骰子，那么从1点朝上，到6点朝上加在一起构成样本空间，这六种情况放到一起的概率为1。
公理三：如果两个随机事件A和B是互斥的，也就是说A发生的话B一定不会发生，那么，这件事发生的概率，就是A单独发生的概率，加上B单独发生的概率。这也被称为互斥事件的加法法则。很好理解，比如掷骰子一点朝上和两点朝上显然是互斥事件，一点或两点任意一种情况发生的概率，就等于只有一点朝上的概率，加上只有两点朝上的概率。
柏松分布:随机事件A发生的概率通常很小，但是试验的次数n很大，比如发生车祸的情况便是如此，这种分布被称为泊松分布。应对随机性，为预防不测，我们在准备资源时，达到平均值还是不够的，需要准备一些冗余量。池子越大，越能抵消随机性带来的误差，在防范不经常发生的小概率事件时，大家不妨联合起来，把应付不测的资源放到一起。
高斯分布：正态分布，大概率事件，利用概率分布的平均值和标准差，来定义了正态分布，这种定义更具有普遍意义。高斯分布的平均值就是高斯曲线X轴的对称值，平均值决定高斯曲线的对称位置。标准方差决定曲线分布高矮胖瘦，标准方差越小，曲线就越高瘦，越集中在平均值附近；标准方差越大，曲线就越胖矮。
高斯曲线和x轴之间的面积，就是曲线的积分，面积的大小就代表了高斯分布在某个范围内的概率。“三σ原则”或者“68-95-99.7原则”，平时大家记住带有随机性质的结论，需要有95%的置信度就好了。
条件概率和贝叶斯公式：P(Y|X)=P(X,Y)/P(X)（注：一件事Y在条件X下发生的条件概率P（Y|X），等于条件X，和这件事Y一同发生的联合概率P（X，Y），除以条件X的概率P（X）。）
如何把式子变形就是贝叶斯公式？现在我们把这个式子变形，写成：P(X,Y)=P(Y|X)*P(X)（注：可以理解成X和Y一同发生的概率，就是X发生的概率，乘以在X条件下Y发生的概率。）
在数学上的因果关系不像在物理上是单方向的，它可以是条件和结果互为因果。在概率上也有这样一个特点，就是条件和结果可以互换。
把X和Y调一个个儿就可以了，我们可以写成：
P(X|Y)*P（Y）=P(X,Y)
对比这个式子和前面的式子，我们发现它们都等于X和Y的联合概率分布P(X,Y) ，因此两个等式的左边也必然相等。于是，我们就可以得到一个重要的公式P(X|Y)*P（Y）=P(Y|X)*P（X）。
在这个公式中，如果我们知道了其中三个因子，就能求出第四个。通常来讲，两个条件概率P(X)和P(Y)是容易求的。另外两个条件概率，一个是X条件下Y的概率，一个是Y条件下X的概率，常常一个比较容易得到，另一个比较难得到。所以，我们常常从容易得到的条件概率，推导出难得到的概率。这就是著名的贝叶斯公式。
P(X|Y)=P(Y|X)*P（X）/ P（Y）
在这个公式中，我们假定Y条件下X的条件概率比较难得到，我们放在了等式的左边，而X条件下Y的条件概率容易得到，我们放在了等式的右边。
通过这种互换，可以把一个复杂的问题变成三个简单的问题。这就是贝叶斯公式的本质。利用它，就解决了机器翻译的难题。
二、数学和逻辑学关系
逻辑是一切的基础，是人类理性的体现。数学结论的正确性，取决于公理的正确性，以及逻辑的严密性，因此数学和逻辑是密不可分的，特别像欧几里得几何这种数学体系，完全依赖逻辑。数学真是有内在的逻辑性，才避免可能的自相矛盾之处。
逻辑学的基本原理：
1、同一律：一个事务只能是其本身。大白话背后的含义是世界上任何一个个体都是独一无二的，评估就是苹果，不是橘子。
2、矛盾律：不可能既是A又不是A，通常的表述是在某个事务的某一方面（在同一时刻），不可能既是A又不是A。数学中的反证法就是基于矛盾律。逻辑学家们一般强调四个“同一”，即同一时间、同一方面、同一属性、同一对象，总之强调的是独一无二的事件。
3、排中律：“是非”明确，它通常表述是，任何事务在明确的条件下，都要有明的“是”或“非”的判断，不存在中间状态。
4、充分条件律：有果必有因，它表示的是任何结论都要有充足的理由，这也是我们常说的因果理由。任何数学的推理，都离不开充分条件律。
三、数学和自然科学关系
数学是自然科学的基础，数学对自然科学的帮助，主要体现在工具和方法俩方面，各种自然科学的升华过程有以下三个共同点：
1、从简单的观察上升到理性的分析；
2、从给出原则性结论到量化的结论，很多事情需要量化度量才能得到准确的结论；
3、将自然科学公式化，或者说用数学的语言来描述自然科学。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2848939fd8c19fde7ea56d56d1b4d37b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eaa43faceb0ddbf0a87b467cd6763555/" rel="bookmark">
			数字特征
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目内容：
对数字求特征值是常用的编码算法，奇偶特征是一种简单的特征值。对于一个整数，从个位开始对每一位数字编号，个位是1号，十位是2号，以此类推。这个整数在第n位上的数字记作x，如果x和n的奇偶性相同，则记下一个1，否则记下一个0。按照整数的顺序把对应位的表示奇偶性的0和1都记录下来，就形成了一个二进制数字。比如，对于342315，这个二进制数字就是001101。
思路：可不可以这样。先一个循环不断除以10，最后小于10大于0时停止，然后与累计除10的次数number相加除2取余，若为0则使用math.pow函数。Math.pow(2,number)否则为0.接着继续循环，好像不行。因为这样后面的数好像就没法解决了。至少以我目前的水平无法解决。
那我们接着想，这样：
先取余得到个位数，然和将个位数与1相加除2取余if判断是否等于0.如果是那么使用math.pow函数计算（2，number-1)，每循环一次，number的值加一，number++.然后除10，再判断个位数。以此循环。这个好像可以，形象地比喻为切萝卜片，切下一片处理一片。
import java.util.Scanner;
public class Main{
public static void main(String[] args) { Scanner a=new Scanner(System.in); int n =a.nextInt(); int single;//个位数的值 int number=0;//位数 int s=0;//计算的值 while (n&gt;0)
{
single=n%10;
number++;
if((single+number)%2==0)//相加是否是偶数，既比较位数和位数上的数奇偶是否一致
{ s+=Math.pow(2, number-1); } n=n/10; } System.out.println(s);
}
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9eb7f4329004ac18b71202964269f51f/" rel="bookmark">
			红黑树与B树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 红黑树定义引理13.1：一棵有n个内部结点的红黑树的高度至多为2lg(n+1) 旋转插入删除总结 B树定义 红黑树 红黑树是一棵二叉搜索树，它在每个结点上增加了一个存储位来表示结点的颜色。通过对任何一条从根到叶子的简单路径上各个结点的颜色进行约束，红黑树确保没有一条路径会比其他路径长出2倍，因而是近于平衡的。
定义 每个结点要么是黑色要么是红色。根节点一定是黑色。红色结点的孩子一定是黑色。从任一节点到它所能到达得叶子节点的所有简单路径都包含相同数目的黑色节点。用黑色的哨兵nil结点代替原来树中的每个叶子结点的左子树和右子树。即叶子(NIL)结点是黑色的。（根据《算法导论》中对红黑树的定义） 树中的每个结点包含5个属性:color,key,left,right,p。(p:父结点）
一颗红黑树的示意图如下：(NIL结点可以用一个结点代替）
引理13.1：一棵有n个内部结点的红黑树的高度至多为2lg(n+1) 详细的证明细节见《算法道路》，直观分析如下：
从根节点到叶子结点中的黑结点数目相等（定义4），又因为红结点下面一定是黑结点（定义3）。因此一条根节点到叶子结点的简单路径上的红色结点一定不会超过黑色结点。因此能直观的得到结论：每棵子树的根节点到叶子结点的最长路径不会超过最短路径的2倍。（即一个叶子结点要想足够深，他需要填满他深度一半的满二叉树）因此，对于结点n的内部红黑树的最高高度一定是log(N)级别的。
因此，如果用红黑树来代替AVL树，在查找的复杂度上是合适的，如果增加和删除结点不比AVL树复杂，即达到log(n)级别，那就好了。下面进行分析。
旋转 左右旋的示意图如下，在红黑树中也会用到，具体分析和代码在之前一篇博客中有学习笔记_二叉搜索树与平衡二叉树。
需要注意一点，旋转后不改变二叉搜索树的性质（即左子树最大值&lt;=根节点&lt;=右子树最小值）。
插入 为了使插入操作的复杂度为log(n)，在二叉搜索树的基础上进行修改。
步骤如下：将Z节点结点插入树T中（二叉搜索树的插入方式），然后将Z染色为红色，再调用一个程序RB-INSERT-FIXUP来对结点重新染色并且旋转。
整个插入函数命名为RB-INSERT(T,x)。
分析《算法导论》中给出的伪代码（迭代版本）
RB-INSERT(T,z)	//在树T中插入z y = T.nil	//y为插入点的父结点（对于根节点则为哨兵nil结点） x = T.root	//通过x来找到插入位置 while x != T.nil //最后的插入位置一定是叶子结点 y = x;	//继续判断x的孩子结点，因此更新y为新的父结点 if z.key &lt; x.key x = x.left else x = x.right z.p = y;	//此时找到了插入位置，因此插入结点Z的父结点为y if y == T.nil	//此时父结点竟然是T.nil!,说明这是一颗空树 T.root = z //因为是空树，那么z就是根节点 elseif z.key&lt;y.key	//看看是插到y的左边还是右边 y.left = z; else y.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9eb7f4329004ac18b71202964269f51f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30a73eb0bf6dfc71daef7e8ac7d43a5e/" rel="bookmark">
			补码的一位乘法（2020-03-28）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		补码的一位乘法 今天学了补码的一位乘法，还是上例子来讲🙃
eg：已知X＝＋1101，Y＝＋1011，用补码一位乘法求X*Y。
首先，求出补码→[X]补＝01101，[Y]补＝01011
方法一:按照原码的一位乘法的方式，根据乘数Y来判断加0还是加｜X｜，而部分积的初始值为0，但是我们一般用双符号位计算，所以0的个数就是补码的位数5＋1，即6位数。
这里面有个注意点，如果乘数Y是正数，最后的结果就不需要校正，如果Y是负数，算到最后一步之后要加上[-X]补来校正，所以更推荐方法二啦～
方法二：根据Yn＋1和Yn的大小来判断部分积是加0还是[-X]补或[X]补😔 若Yn＋1＜Yn，部分积＋[-X]补， 若Yn＋1＝Yn，部分积＋0， 若Yn＋1＞Yn，部分积＋[X]补。 这里的初始Yn＋1， 我们在乘数的后面补一个0😬 这里面要注意的就是符号位的进位要自然丢掉呀！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/feec1fc895363360160c1a85f6a6262b/" rel="bookmark">
			Python运行错误：RuntimeError: CUDA error: invalid device ordinal
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用pytorch跑实验需要用到cuda加速，开始默认用的是第0块gpu，后来第0块cpu被别人占用，所以只能切换到第1块gpu。
于是进行了如下修改
device = torch.device('cuda:1' if torch.cuda.is_available() else 'cpu' ) 但是出现了错误：
RuntimeError: CUDA error: invalid device ordinal
经过一番查资料，作如下修改：
import os os.environ['CUDA_VISIBLE_DEVICES'] = '1' device = torch.device('cuda' if torch.cuda.is_available() else 'cpu' ) 如上修改过后，便可在第1块gpu上运行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cf453388fc6e182198bc9f5620264ef/" rel="bookmark">
			JavaScript进阶之浏览器Event-Loop
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		浏览器除了JS引擎（JS执行线程，后面我们只关注JS引擎中的执行栈）以外，还有Web APIs（浏览器提供的接口，这是在JS引擎以外的）线程（如下表)
JS引擎在执行过程中，如果遇到相关的事件（DOM操作、鼠标点击事件、滚轮事件、AJAX请求、setTimeout等），并不会因此阻塞，它会将这些事件移交给Web APIs线程处理，而自己则接着往下执行。
Web APIs线程
前面我们说到过JavaScript虽然是单线程的，但是不代表JavaScript执行过程中只有一个线程参与，而是会有其它线程参与该过程，但是永远只有JS引擎线程在执行JS脚本程序，其他的线程只协助，不参与代码解析与执行。参与JavaScript执行过程的线程分别是：
JavaScript是单线程的，这一点确实没错，但是代码执行是在浏览器中进行，浏览器提供了其它Web APIs线程来协助JS执行引擎，那么它们是如何协助JS执行引擎的呢❓
举个例子🌰：
console.log(“script start”)
setTimeout(function(){
console.log(“setTimeout”)},
100)
console.log(“script end”)
复制代码
如上图所示，JS引擎开始执行代码，将console.log(“script start”)推入到执行栈中,执行console.log(“script start”)结束，继续执行setTimeout，发现是个异步操作,这时候JS执行引擎也将该延时事件发放给Web API处理(如果该延迟事件结束,将回调函数推进任务队列中),JS执行引擎继续执行代码，遇到console.log(“script end”),推进执行栈执行，这时候代码都执行完毕，JS引擎处于空闲状态，这时候就会去任务队列去拿setTimeout的回调事件，推进执行栈执行
输出：
script start
script end
setTimeout
复制代码
总结一下
JS引擎只要遇到异步函数，则会交给Web APIs线程处理
Web APIs线程处理完毕以后，就会往队列放入该事件回调函数
事件循环
上面👆的例子其实就是JavaScript的异步执行机制，也就是事件循环，接下来我们来好好聊聊它吧
JavaScript是单线程的，为了避免代码解析阻塞使用了异步执行，那么它的异步执行机制是怎么样的？
答案就是事件循环,JavaScript的异步执行机制就是事件循环,来看MDN的介绍
MDN:JavaScript有一个基于事件循环的并发模型，事件循环负责执行代码、收集和处理事件以及执行队列中的子任务。这个模型与其它语言中的模型截然不同，比如 C 和 Java。
事件循环可以理解成由三部分组成（如下图），分别是：
主线程执行栈
异步任务等待触发
任务队列
主线程执行栈
JavaScript代码在执行时，会进入一个执行上下文中。执行上下文可以理解为当前代码的运行环境,JavaScript引擎会以栈的方式处理这些环境
执行栈在我们分析JavaScript进阶之执行上下文章节就仔细分析过了，这里不再赘述
异步任务等待触发
这里的异步任务等待触发也就是我们的Web APIs组成部分
JS线程负责处理JS代码，当遇到一些异步操作的时候，则将这些异步事件移交给Web APIs 处理，自己则继续往下执行
Web APIs线程将接收到的事件按照一定规则按顺序添加到任务队列中
任务队列
首先在谈任务队列之前，我们先来认识队列这种数据结构，它的特点就是先入先出
🤔队列的实现不在我们这章节的讨论范围内，这里给出代码，感兴趣的同学可以尝试一下
class MyCircularQueue {
constructor(k) {
this.capacity = k + 1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cf453388fc6e182198bc9f5620264ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad1a768f48b848587f66044a3117b963/" rel="bookmark">
			Apollo开放平台 API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 什么是开放平台？ Apollo提供了一套的Http REST接口，使第三方应用能够自己管理配置。虽然Apollo系统本身提供了Portal来管理配置，但是在有些情景下，应用需要通过程序去管理配置。
二、 第三方应用接入Apollo开放平台 2.1 注册第三方应用 第三方应用负责人需要向Apollo管理员提供一些第三方应用基本信息。
基本信息如下：
第三方应用的AppId、应用名、部门第三方应用负责人 Apollo管理员在 http://{portal_address}/open/manage.html 创建第三方应用，创建之前最好先查询此AppId是否已经创建。创建成功之后会生成一个token，如下图所示：
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-n7gMFONd-1585386458792)(https://github.com/ctripcorp/apollo/raw/master/doc/images/apollo-open-manage.png)]
2.2 给已注册的第三方应用授权 第三方应用不应该能操作任何Namespace的配置，所以需要给token绑定可以操作的Namespace。Apollo管理员在 http://{portal_address}/open/manage.html 页面给token赋权。赋权之后，第三方应用就可以通过Apollo提供的Http REST接口来管理已授权的Namespace的配置了。
2.3 第三方应用调用Apollo Open API 2.3.1 调用Http REST接口 任何语言的第三方应用都可以调用Apollo的Open API，在调用接口时，需要设置注意以下两点：
Http Header中增加一个Authorization字段，字段值为申请的tokenHttp Header的Content-Type字段需要设置成application/json;charset=UTF-8 2.3.2 Java应用通过apollo-openapi调用Apollo Open API 从1.1.0版本开始，Apollo提供了apollo-openapi客户端，所以Java语言的第三方应用可以更方便地调用Apollo Open API。
首先引入apollo-openapi依赖：
&lt;dependency&gt; &lt;groupId&gt;com.ctrip.framework.apollo&lt;/groupId&gt; &lt;artifactId&gt;apollo-openapi&lt;/artifactId&gt; &lt;version&gt;1.1.0&lt;/version&gt; &lt;/dependency&gt; 在程序中构造ApolloOpenApiClient：
String portalUrl = "http://localhost:8070"; // portal url String token = "e16e5cd903fd0c97a116c873b448544b9d086de9"; // 申请的token ApolloOpenApiClient client = ApolloOpenApiClient.newBuilder() .withPortalUrl(portalUrl) .withToken(token) .build(); 后续就可以通过ApolloOpenApiClient的接口直接操作Apollo Open API了，接口说明参见下面的Rest接口文档。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad1a768f48b848587f66044a3117b963/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5556ed995746228e6f0402ded32e8581/" rel="bookmark">
			VS2019出现&#34;LPWSTR&#34; 类型的值不能用于初始化 &#34;char *&#34; 类型的实体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VS2019出现"LPWSTR" 类型的值不能用于初始化 “char *” 类型的实体 博客说明
文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！
错误 “LPWSTR” 类型的值不能用于初始化 “char *” 类型的实体
错误地方 char *str = strLine.GetBuffer(0); 解决办法 char *str = (char *)strLine.GetBuffer(0); 感谢
万能的网络
以及勤劳的自己
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f38a1fae9cd3b906cccaf64e55c3596/" rel="bookmark">
			GOBY--一款攻击面测绘工具的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 简介官网Kali下的安装简单使用功能扫描资产扫描端口扫描协议识别产品识别web页面查找漏洞扫描网站截图域扫描 漏洞自定义PoC自定义词典 个人看法 简介 Goby是基于网络空间映射技术的下一代网络安全工具。它通过为目标网络建立全面的资产库来生成对网络安全事件和漏洞的紧急响应。
Goby提供最全面的资产识别.Goby预置了100,000多个规则识别引擎，可自动识别和分类硬件设备和软件业务系统，并全面分析网络中存在的业务系统。Goby提供了最快的扫描体验，对目标的影响最小，并通过非常轻的传输快速分析了与端口相对应的协议信息。
除了Goby预设的漏洞外，Goby还提供了一个可自定义的漏洞扫描框架，并激励大量网络安全从业人员提供POC以确保持续的紧急响应能力。
因为产品公测不算久，往后的功能可能有出入，详细的建议阅读官网文档
对于这款产品，赵武的想法:https://mp.weixin.qq.com/s/hW0A1jwq-pm4M-4LGUZIrA
官网 https://gobies.org 说实话，咋一看还以为是老外的产品
Kali下的安装 官网找到下载链接选择对应版本下载并解压即可
简单使用 选择解压后的目录内goby文件即可
如果有报错
sudo apt-get install libgconf2 * 设置中文，红框处调为CN即可
功能 扫描 资产扫描 自动检测当前网络空间中存在的IP（拙见：从高校专业名改革可以看出来，从信息安全到网络空间安全，体现的也是一个攻击面的问题，空间安全可能更符合未来的需求）
端口扫描 涵盖近300个主流端口并支持不同情况下的端口分组，以确保最有效的输出;
协议识别 预设了200多种协议识别引擎，涵盖网络协议，数据库协议，IoT协议，ICS协议等，可通过非常轻量化的传输快速分析与端口相对应的协议信息。
产品识别 预设了100,000多个规则识别引擎，以自动识别和分类硬件设备和软件业务系统，并全面分析网络中存在的业务系统。
web页面查找 支持web渗透所需的重要信息：包括IP，端口，服务器，标题等
漏洞扫描 预设最具攻击性的漏洞引擎，涵盖最严重的漏洞，例如Weblogic和Tomcat。（拙见：这里的poc多数都是威胁性较大的，也使得扫描速度能如此的快）
网站截图 可以获得服务器上的网站屏幕截图，并且在详细信息页面上可以查看更多屏幕截图。
域扫描 支持根域和子域扫描，并支持子域名的自动爬虫。(拙见：对，不能填网址，得填域，另外不清楚它和oneforall哪个更好用，有空做个评测)
漏洞 自定义PoC 漏洞扫描更加灵活；
自定义词典 暴力破解攻击更容易；
个人看法 太快了太快了有种。。。的感觉，这是最直观的感受；
观念已经走在了国内安全公司的前列，另外在精而不再多，毕竟国内能正儿八经做产品的实在不多；
估计会成为下一个挖洞神器
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/696e97ab36260aa5f1d9e07a7955aa15/" rel="bookmark">
			12.2-MacOS下打包QT应用程序为DMG包，看这一篇就足够了（包括第三方Lib库）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 在MacOS系统中，应用软件的安装目录，就在应用软件自己里面。因此所谓安装macos软件，就是直接把应用软件复制到你想安装的目录即可。当然标准的应用软件安装目录为“/Applications”。
这种安装目录就在软件自己里面的方式叫做“bundle”。所谓的bundle是指，软件是以目录的形式存在，目录中有主可执行程序和此程序所依赖的库文件，以及此软件相关的配置文件和图标等。只是在macos系统中把这个目录以一个有图标的文件形式来显示，从而直接看起了就像一个“软件”，并且你双击这个“软件”可以运行此软件。
关于macOS下bundle包的定义
On the Mac, a GUI application must be built and run from a bundle. A bundle is a directory &gt;structure that appears as a single entity when viewed in the Finder. A bundle for an &gt;application typcially contains the executable and all the resources it needs.
二、把Qt编写的程序转化为“双击可执行的软件”，生成可用Bundle 在MacOS系统中，用Qt Creater 编写的程序，在Qt Creater可以点击“运行”按钮来启动软件，但是你在目录中找到这个软件，双击却不能启动，报错提示为找不到此程序的依赖库。因此，使用Qt Creater编写的程序，需要按照以下步骤来生成一个双击可启动运行的Bundle。然后才能打包为DMG或PKG安装包。顺序按照以下步骤操作即可获取一个可以“双击可正确运行的Bundle”
使用Qt Creater把自己的应用程序编译一份Release版本，在QtCreater中点击运行，以保证程序可正常运行。编译生成的xxx.app在下图中的…release目录中：
打开终端，切换到编译生成的xxx.app包所在的目录(或者把xxx.app单独复制到一个目录)，执行以下命令自动给此app添加所依赖的qt动态库。（xxx.app 为编译生成的release执行文件的名字） macdeployqt ./xxx.app 执行完此命令后，右键xxx.app包选择查看包内容，即可打开一个目录，展开目录可以看到macdeployqt给这个bundle增加了有关qt的依赖库文件，从而达到双击即可运行的目的。如下图所示：
注意：如果提示找不到此命令的解决办法：
在你的qt安装目录找到这个命令的位置，把其路径添加到“bash环境”里面即可。如下图所示：
command not found: macdeployqt //提示找不到此命令 cd ~ //切换到用户家目录 vim .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/696e97ab36260aa5f1d9e07a7955aa15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0134af9916a9dc88aee310d6de086916/" rel="bookmark">
			粒子群算法PSO基本知识快速了解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		粒子群算法PSO基本知识
1. 基本思想
2. PSO算法流程
3. 速度和位置更新规则
4. 参数分析与设置
4.1 群体规模N
4.2 最大速度Vmax
4.3 权重因子
4.4 收敛因子K替代权重因子
总结：
参考：
粒子群算法PSO 1. 基本思想 粒子群算法通过设计一种无质量的粒子来模拟鸟群中的鸟，粒子仅具有两个属性：速度和位置，速度代表移动的快慢，位置代表移动的方向。每个粒子在搜索空间中单独的搜寻最优解，并将其记为当前个体极值，并将个体极值与整个粒子群里的其他粒子共享，找到最优的那个个体极值作为整个粒子群的当前全局最优解，粒子群中的所有粒子根据自己找到的当前个体极值和整个粒子群共享的当前全局最优解来调整自己的速度和位置。
2. PSO算法流程 迭代终止条件根据具体问题一般选为最大迭代次数Gk或(和)粒子群迄今为止搜索到的最优位置满足预定最小适应阈值。适应性函数是评价粒子是否处于最优位置的函数，也是优化问题的目标函数。
3. 速度和位置更新规则 PSO算法初始化为一群随机粒子(随机解)。然后通过迭代找到最优解。在每一次的迭代中，粒子通过跟踪两个“极值”(pbest，gbest)来更新自己。在找到这两个最优值后，粒子通过下面的公式来更新自己的速度和位置。(pbest为当前粒子自身最好位置，gbest为当前整个群体中所有粒子发现的最好位置)
对于公式(1)，由三部分组成：
公式(1)的第①部分称为“记忆项”，表示上次速度大小和方向的影响；
公式(1)的第②部分称为“自身认知项”，是从当前点指向粒子自身最好点的一个矢量，表示粒子的动作来源于自己经验的部分；
公式(1)的第③部分称为“群体认知项”，是一个从当前点指向粒子群最好点的矢量，反映了粒子间的协同合作和知识共享。粒子就是通过自己的经验和同伴中最好的经验来决定下一步的运动。
以公式(1)和(2)为基础，形成了PSO标准形式。
在公式(2)的基础上，引入惯性因子w(记忆项中)，得到公式(3)：
动态ω能获得比固定值更好的寻优结果。动态ω可在PSO搜索过程中线性变化，也可以根据PSO性能的某个测度函数动态改变。目前采用较多的是线性递减权值(Linearly Decreasing Weight，LDW)策略。
ω的引入，使用PSO算法性能有了很大的提高，针对不同的搜索问题，可以调整全局和局部搜索能力，也使PSO算法有成功地应用于很多实际问题。
因此，公式(3)和(2)构成了标准PSO算法。
4. 参数分析与设置 PSO算法设定参数：群体规模N，惯性因子ω，学习因子c1和c2，最大速度Vmax，最大迭代次数Gk。
4.1 群体规模N 一般取20～40，对较难或特定类别的问题可以取到100～200。现在尚没有确定最佳粒子数量的理论分析，因此通常使用敏感性测试来获得它。
4.2 最大速度Vmax 决定当前位置与最好位置之间的区域的分辨率(或精度)。如果太快，则粒子有可能越过极小点；如果太慢，则粒子不能在局部极小点之外进行足够的探索，会陷入到局部极值区域内。这种限制可以达到防止计算溢出、决定问题空间搜索的力度的目的。
4.3 权重因子 包括惯性因子ω和学习因子c1和c2。
(1) 惯性因子ω
ω使粒子保持着运动惯性，使其具有扩展搜索空间的趋势，有能力探索新的区域。如果ω=0，则速度只取决于当前位置和历史最好位置，速度本身没有记忆性。假设一个粒子处在全局最好位置，它将保持静止，其他粒子则飞向它的最好位置和全局最好位置的加权中心。粒子将收缩到当前全局最好位置。
(2) 学习因子c1和c2
c1和c2代表将每个粒子推向pbest和gbest位置的统计加速项的权值。较低的值允许粒子在被拉回之前可以在目标区域外徘徊，较高的值导致粒子突然地冲向或越过目标区域。
1) 当c1=0时
此时粒子没有了认知能力，变为只有社会的模型(social-only)。此时被称为全局PSO算法。粒子有扩展搜索空间的能力，具有较快的收敛速度，但由于缺少局部搜索，对于复杂问题比标准PSO更易陷入局部最优。
2) 当c2＝0时
粒子之间没有社会信息，模型变为只有认知模型(cognition-only)。此时被称为局部PSO算法。由于个体之间没有信息的交流，整个群体相当于多个粒子进行盲目的随机搜索，收敛速度慢，因而得到最优解的可能性小。
3) 当c1=c2=0时
粒子将一直以当前速度飞行，直到边界，很难找到最优解。
4.4 收敛因子K替代权重因子 总结： PSO算法在优化过程中，种群的多样性和算法的收敛速度之间始终存在着矛盾。对标准PSO算法的改进，无论是参数的选取、小生境技术的采用或是其他技术与PSO的融合，其目的都是希望在加强算法局部搜索能力的同时，保持种群的多样性，防止算法在快速收敛的同时出现早熟收敛。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0134af9916a9dc88aee310d6de086916/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bdd45b8b430c8f6dc7947fcb1945ae1/" rel="bookmark">
			大话数据结构---（五）二叉树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.二叉树的基本概念 二叉树是n个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。
二叉树特点
（1）每个结点最多有两棵子树。
（2）左子树和右子树是有顺序的，次序不能任意颠倒。
（3）即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。
特殊二叉树
满二叉树：如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。
完全二叉树：对一棵具有n个结点的二叉树按层序编号，如果编号i的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。（满二叉树一定是一棵完全二叉树，但完全二叉树不一定是满的）。
2.二叉树的性质 从上一篇博客可以得知，任意一棵树能通过孩子兄弟表示法转换为二叉树，那么二叉树的性质有哪些呢？
在二叉树的第i层上至多有2(i-1)个结点（i&gt;=1）深度为k的二叉树至多有2k-1个结点（k&gt;=1）如果对一棵有n个结点的完全二叉树的结点按层序编号，对任一结点i,有：
（1）如果i=1,则结点i是二叉树的根，无双亲；如果i&gt;1,则其双亲是结点[i/2]。
（2）如果2i&gt;n,则结点i无左孩子；否则其左孩子是结点2i。
（3）如果2i+1&gt;n,则结点i无右孩子；否则其右孩子是结点2i+1。 3.二叉树的存储结构 二叉树顺序存储结构：二叉树的顺序存储结构就是用一维数组存储二叉树中的结点，并且结点的存储位置，也就是数组的下标要能体现结点之间的逻辑关系，比如双亲与孩子的关系，左右兄弟的关系等。
先来看看完全二叉树的顺序存储，一棵完全二叉树如图1所示： 将这棵二叉树存入到数组中，相应的下标对应其同样的位置，如图2所示：
考虑一种极端情况，一棵深度为k的右斜树，它只有k个结点，却需要分配2k-1个存储空间，这显然是对存储空间的浪费。所以，顺序存储结构一般只用于完全二叉树。
二叉链表：既然顺序存储结构不能满足大部分树的存储，那么这里考虑链式存储结构。二叉树的每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域，我们称这样的链表叫做二叉链表，结点结构如图所示。
结点结构代码为：
typedef struct BiTNode//结点结构 { TElemType data;//结点数据 struct BiTNode *lchild,*rchild;//左右孩子指针 }BiTNode,*BiTree; 结构示意图如图所示：
就如同树的存储结构中讨论的一样，如果有需要，还可以再增加一个指向其双亲的指针域，那样就称之为三叉链表。
4.二叉树的遍历 定义：是指从根结点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问依次且仅被访问一次。
二叉树的遍历方法：二叉树的定义是用递归的方式，所以，实现遍历算法也可以采用递归，而且极其简洁明了。
前序遍历：规则是若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。上图所示的前序遍历结果为：ABDGHCEIF。
代码如下： void PreOrderTraverse(BiTree T) { if(T==NULL) return ; cout&lt;&lt;T-&gt;data;//显示结点数据，可以更改为其他对结点操作 PreOrderTraverse(T-&gt;lchild);//再先序遍历左子树 PreOrderTraverse(T-&gt;rchild);//最后先序遍历右子树 } 中序遍历：规则是若树为空，则空操作返回，否则从根结点开始（注意并不是先访问根结点），中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树。上图所示的中序遍历结果为：GDHBAEICF。 void InOrderTraverse(BiTree T) { if(T==NULL) return ; InOrderTraverse( T-&gt;lchild);//中序遍历左子树 cout&lt;&lt;T-&gt;data;//显示结点数据，可以更改为其他对结点操作 InOrderTraverse(T-&gt;rchild);//最后中序遍历右子树 } 后序遍历：规则是若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根结点。上图所示的中序遍历结果为：GHDBIEFCA。 void PostOrderTraverse(BiTree T) { if(T==NULL) return ; PostOrderTraverse(T-&gt;lchild);//先后序遍历左子树 PostOrderTraverse(T-&gt;rchild);//再后序遍历右子树 cout&lt;&lt;T-&gt;data;//显示结点数据，可以更改为其他对结点的操作 } 层序遍历：规则是若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。上图所示的中序遍历结果为：ABCDEFGHI。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6bdd45b8b430c8f6dc7947fcb1945ae1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9732ae95618610785254f51ccbd82de1/" rel="bookmark">
			SpringBoot的@Configuration扫盲
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@Configuration注解标识的类中声明了1个或者多个@Bean方法，Spring容器可以使用这些方法来注入Bean，比如：
@Configuration public class AppConfig { //这个方法就向Spring容器注入了一个类型是MyBean名字是myBean的Bean @Bean public MyBean myBean() { // instantiate, configure and return bean ... } } @Configuration类一般是由AnnotationConfigApplicationContext或者它的web变种AnnotationConfigWebApplicationContext来处理的，比如：
AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(); //这是configuration类 ctx.register(AppConfig.class); ctx.refresh(); MyBean myBean = ctx.getBean(MyBean.class); // use myBean ... 也可以用以XML方式引入，就跟引入普通的Bean是一样的：
&lt;beans&gt; &lt;context:annotation-config/&gt; &lt;!--也可以这样加载configuration类--&gt; &lt;bean class="com.acme.AppConfig"/&gt; &lt;/beans&gt; 上例中，为了启用ConfigurationClassPostProcessor和其他的注解相关的Post Processor来处理@Configuration，需要添加context:annotation-config/。
组件扫描的方式使用 @Configuration上面添加了@Component元注解，因此, @Configuration是支持组件扫描的(一般要添加context:component-scan/ ) ，它跟其他普通的Component一样也支持@Autowired/@Inject，如果@Configuration的类有一个构造函数，也支持构造函数自动注入，比如：
@Configuration public class AppConfig { private final SomeBean someBean; //构造函数注入 public AppConfig(SomeBean someBean) { this.someBean = someBean; } //注入另一个bean @Autowired private AnotherBean1 anotherBean1; //注入另一个bean @Resource private AnotherBean2 anotherBean2; // @Bean definition using "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9732ae95618610785254f51ccbd82de1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5771d485ad693722b6c88aab6addf90/" rel="bookmark">
			已解决 uni-app中使用jsencrypt会导致项目报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		已解决 uni-app中使用jsencrypt会导致项目报错
项目需求需要使用jsencrypt进行(rsa)加密
经测试，在项目中引入jsencrypt会导致下面报错
ReferenceError: Can’t find variable: navigator
这个错因为这个插件使用了 window 对象，然后不管是app还是小程序中都没有窗口对象的环境，就导致不能用 window，一用这脚本就会报错, 解决办法,修改jsencrypt.js源码
在jsencrypt.js文件随便那个位置添加以下代码
var modificationNavigator = { appName: 'Netscape', userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1' }; var modificationWindow = { ASN1: null, Base64: null, Hex: null, crypto: null, href: null }; 加入后把jsencrypt.js文件里面的变量navigator全部替换为 modificationNavigator
window全部替换为 modificationWindow
替换后,再次引用
import JSEncrypt from '../../static/jsencrypt.js' var en = new JSEncrypt() en.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5771d485ad693722b6c88aab6addf90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d5275ad1a9e38f022b5eb65e021b6c5/" rel="bookmark">
			$.ajax status:404,readyState:4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		找了一晚上的错误，就因为controller注解写错；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a86a513bed41d846b68848a7709d1bfc/" rel="bookmark">
			shell命令实现文件的备份和恢复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#!/bin/bash #备份目录函数 backupdir() { dirtest echo "Backupping..." echo $DIRECTORY #mkdir $newdir #把DIRECTORY备份成为backup.tar.gz放在/tmp目录下 tar -zcvf /tmp/backup.tar.gz $DIRECTORY } #恢复目录函数 restoredir() { dirtest echo "Restoring..." echo $DIRECTORY tar -zxvf /tmp/backup.tar.gz } #验证目录函数 dirtest() { echo "please enter the directory name of backup file:" read DIRECTORY #read newdir if [ ! -d $DIRECTORY ] #判断一下是不是目录 then echo "sorry,$DIRECTORY is not a directory!" exit 1 fi #cd $DIRECTORY } clear ANS=Y while [ $ANS = Y -o $ANS = y ] do echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a86a513bed41d846b68848a7709d1bfc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ec7df0dfa1727018f075f5f791c6264/" rel="bookmark">
			Esp8266通过Smartconfig一键配网（Arduino方式）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Esp8266通过Smartconfig一键配网 SmartConfig又名快连当前设备在没有和其他设备建立任何实际性通信链接的状态下，一键配置该设备接入。可以理解为接入路由器的手机快速配置设备，使其接入路由器。
8266应用非常广泛在单片机嵌入式物联网里面应用非常广泛！
首先我们需要的开发环境是Arduino的开发环境如果还没配置的话可以参考
Arduino搭建Esp8266环境
void smartConfig() { WiFi.mode(WIFI_STA); //设置WIFI模块为STA模式 Serial.println("\r\nWaiting for connection"); //smartconfig进行初始化 WiFi.beginSmartConfig(); while (1) //等待连接成功 ，如果未连接成功LED就每隔500ms闪烁 { Serial.print("&gt;"); digitalWrite(LED, 0); delay(500); digitalWrite(LED, 1); delay(500); //如果连接成功后就打印出连接的WIFI信息 if (WiFi.smartConfigDone()) { Serial.println("SmartConfig Success"); Serial.printf("SSID:%s", WiFi.SSID().c_str()); Serial.printf("PW:%s", WiFi.psk().c_str());//打印出密码 break; } } } 上面是8266的SmartConfig配置函数
等待连接时
我们打开配网的网页：http://wx.ai-thinker.com/api/old/wifi/config
连接将要连接的WIFI然后输入WIFI密码输入后就会提示连接
最后连接成功。开发板的灯也不闪了
而且串口也打印了WIFI的相关信息！
需要该源码可以关注公众号:智慧小巷
回复:8266一键配网
即可！
感谢阅读！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee05df81cd48d19ddb7786378f48b97f/" rel="bookmark">
			3.自动任务和JasperReport
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自动任务和JasperReport 一.自动任务1.自动任务的应用2.Quartz框架2.1引入依赖2.2 applicationContext-task.xml2.3 编写自动任务类2.4 Cron表达式 二.JasperReport1.JasperReport的执行阶段2.执行流程3.在jasper里面创建工程4.代码实现生成PDF4.1 引入依赖4.2 map填充数据的controller4.3 list填充数据的controller4.4处理中文乱码 5.图形汇总生成PDF5.1创建一个group5.2controller 6.图形格式生成PDF6.1 jasper操作6.2 controller 三.报运单生成PDF1.beansUtils工具类2.controller 一.自动任务 1.自动任务的应用 1、注册网站会员，生日当天发送短信
2、银行、信用卡中心发送短信账单、邮件账单
3、应用于企业查询，将大量数据汇总成临时数据以供查询（重点）
2.Quartz框架 2.1引入依赖 &lt;!--定时任务--&gt; &lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz&lt;/artifactId&gt; &lt;version&gt;2.2.3&lt;/version&gt; &lt;/dependency&gt; 2.2 applicationContext-task.xml &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context" xmlns:jdbc="http://www.springframework.org/schema/jdbc" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:task="http://www.springframework.org/schema/task" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;!--1.将定时任务类交给spring容器--&gt; &lt;bean id="myTask" class="cn.itcast.web.task.MyTask"&gt;&lt;/bean&gt; &lt;!--2.配置jobDetal ： 配置定时执行的类和方法--&gt; &lt;bean id="jobDetail" class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean"&gt; &lt;property name="targetObject" ref="myTask"&gt;&lt;/property&gt; &lt;property name="targetMethod" value="excute"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--3.配置trigger: （触发器）配置时间以及jobdetal关系 --&gt; &lt;bean id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee05df81cd48d19ddb7786378f48b97f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8d4938e95be04a60c22a3ae226f8d4d/" rel="bookmark">
			动态实例分割SOLOv2，更快更强更精准！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天跟大家分享下前天新出的论文 SOLOv2: Dynamic, Faster and Stronger，一看这名字就知道很霸气！SOLO 超越自己，在原有架构基础上引入动态卷积和发明了Matrix NMS，再次刷新COCO 实例分割数据集的最高精度（41.7 AP），而且其轻量级版本精度与Mask RCNN相近（37.1 AP vs 37.8），而速度能达到 31.3 fps（GPU V100）！
下图中红色标出的即为SOLOv2的结果：
可谓在实时轻量级和高精度两个战场都很抢眼！
该文作者信息：
论文出自沈春华老师组，作者单位澳大利亚阿德莱德大学、同济大学、字节跳动公司。
作者是在自己之前的工作SOLO基础上做的改进，所以我们有必要看看SOLO的架构：
SOLO架构
长久以来实例分割都是在目标检测给出框的情况下再进行目标mask分割，而这种思路和人类的视觉感知是不同的，人眼是可以直接定位到目标的轮廓的。SOLO的本意为 Segmenting Objects by Locations，即根据位置分割目标。
SOLO的预测头
SOLO将图像划分为SxS个网格，认为每个网格都是一个潜在的目标实例。
具体实现上，图像经过全卷积网络（FCN）后进入两个分支的预测。一个类别分支，预测每个网格所处的物体类别，每个网格对应一个C维类别向量（C为类别数），总的类别矩阵大小为S x S x C；一个mask分支预测每个网格所属的物体mask，总的mask矩阵大小为H x W x （S x S）。
请注意：mask是不关乎类别的，无论是什么物体，只要该物体落入了这个网格，mask 分支都预测它的mask。
mask分支预测得到的每个网格的mask的大小是和原图大小相等，每个网格只对应落入此网格的物体的mask。
这样来自相同位置（网格）的物体类别和相应mask就出来了，每个网格完成了单个目标实例的分割。
由于一个物体可能落在不同的相邻网格里，所以以上过程得到的肯定是多个网格含有相同的物体的mask。故最后必须进行NMS（非极大抑制），以消除重复的分割结果。
从作者的可视化图：
可以很明显的看出这个问题，NMS是必须的。
现实图片中，由于目标实例并不会很密集，所以计算SxS个网格的mask会有大量的计算冗余，作者在SOLOv1中给出的解决方案是对mask预测分支进行分解，分别为预测 x-分支和y-分支，以降低计算量和内存占用，如下图b中所示。
这样mask的预测就从S x S 个变为预测 S + S 个。
作者在SOLOv2中一项重要改进是引入动态卷积。因为在mask预测时每个网格使用的特征是固定的，输出的Mask是冗余的，可以直接从网络的类别分类结果过滤掉那些不含目标的，同时使用动态卷积，也可以降低模型参数。
所谓动态滤波，即滤波核的参数是通过网络预测出来的，这样网络自适应调整的能力也增强了。
如上图中的（c）。模型在mask预测分支时动态进行卷积核学习和特征学习，最后将此二者卷积得到最终的mask。
从FPN中构造mask分支预测前的特征：
作者的另一个重要更新是发明了Matrix NMS方法。
其启发自soft NMS，soft NMS 是每次选择置信度最高的候选mask（或框）降低与其存在重叠的候选mask（或框）的置信度。这个过程是迭代的、顺序的，没法并行。
作者反其道而行之，既然是降低每个mask的置信度，那我就干脆想办法按照一定规则对所有mask挨个降低置信度。而某一候选mask j 置信度被降低，和两方面因素有关：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8d4938e95be04a60c22a3ae226f8d4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df65b1820d45ebb86b1ae660abd377f5/" rel="bookmark">
			vuex state及mapState的基础用法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		store.js文件，这里的store就是我们的前端数据仓库,用vuex 进行状态管理，store 是vuex的核心。可以看到使用vuex 之前，要告诉 vue 使用它，Vue.use(Vuex); /*store.js*/ let store= new Vuex.Store({ state: { token:'', //取出cartarry中的数据，或者为空 cartarry:JSON.parse(localStorage.getItem('cartarry')) || [],//存储购物车商品的数组 }, 1， vue 提供了注入机制，就是把我们的store 对象注入到根实例中。vue的根实例就是 new Vue 构造函数，然后在所有的子组件中,this.$store 来指向store 对象。在store.js 中，我们let store, 把store已经暴露出去了，new Vue() 在main.js中，所以直接在main.js 中引入store 并注入即可。
/*main.js*/ import Vue from 'vue' import App from './App' import router from './router' import store from './store' Vue.config.productionTip = false new Vue({ router, store, render: h =&gt; h(App) }).$mount('#app') 2， 在子组件中,用computed 属性, computed 属性是根据它的依赖自动更新的。所以只要store中的state 发生变化，它就会自动变化。在Cart.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df65b1820d45ebb86b1ae660abd377f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c600da948a68f78ff4d30fd59e42662e/" rel="bookmark">
			microsoft edge、应用商店、爱奇艺无法打开，解决办法和原因分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现象 网络正常连接情况下，同为浏览器的chrome都可以正常运行，而且我发现爱奇艺PC软件，应用商店也无法联网，只有打开VPN才能正常运行，带着这些疑问，以下是我寻找的解决办法。
问题解决：打开控制面板 &gt; 网络和Internet &gt; Internet选项，选择连接&gt;点击下端的“局域网设置” 打开之后发现是这样的：勾选代理服务器
问题全部解决了之后，问题的原因是什么呢？
这篇文章代理服务器基本知识可以帮助你理解，但是具体知识还是要学习了《计算机网络》相关课程，才会有更深层次的思考。
有的电脑是以下问题：
优化 ME浏览器为微软默认浏览器，在浏览器之外点击超链接都会默认打开ME搜索，而ME的性能远不及Chrome浏览器，所以还是将chrome改为默认的比较好。这是博主捧上的详细网址
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4e4490448bdb05bbf4ee7a2166eb356/" rel="bookmark">
			关于Springboot在controller层加@Transactional注解，导致整个类无法访问的问题解决。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通常情况下，我们都是在service层实现的事务管理。但是在一些访问页面的controller方法中，需要使用事务。但是在方法上加上@Transactional注解，会导致访问整个controller的方法报404。一种解决方法如下：
**一，注入PlatformTransactionManager。 **
@Resource private PlatformTransactionManager transactionManager; 二，测试的方法如下:
@RequestMapping("save") @ResponseBody public String save(Object a, Object b){ DefaultTransactionDefinition defaultTransactionDefinition = new DefaultTransactionDefinition(); defaultTransactionDefinition.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED); TransactionStatus status = transactionManager.getTransaction(defaultTransactionDefinition); try { service.saveObjectA(a); service.saveObjectB(b); transactionManager.commit(status); } catch (Exception e) { e.printStackTrace(); transactionManager.rollback(status); return "save failed"; } return "save successful"; } 三，这样就实现了当saveObjectB()出现异常时，saveObjectA()对数据库的操作进行了回滚。
以上就是在controller的方法中加事务的例子，解决办法仅供参考。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5891507c104cb96eacbfe56711dacbae/" rel="bookmark">
			对象类型转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 对象类型转换
与基本数据类型的相互转换一样，对象的类型转换可通过自动转换或强制转换进行。
一、 无继承关系的两个类的对象之间
不能相互转换。试图转换时出现编译错误（Cannot convert “A” to “B”）
二、 有继承关系的两个类的对象之间
子类的对象转换为父类的对象：
可自动转换，当然也可以强制转换。父类的对象转换为子类的对象：
分两种情况：
由new语句创建的父类对象不能转换为子类的对象，试图自动转换时出现编译错误（Cannot implicitly convert…），试图强制转换时出现运行错误（ClassCastException）。
由子类对象转化得到的父类对象可以强制转换为同类型的子类对象，但试图自动转换时会出现编译错误（Cannot implicitly convert…）。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8e8d11067963d8f03c5b698cffe460e/" rel="bookmark">
			Ajax同步请求出现浏览器页面假死，阻塞UI线程之解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ajax 请求数据之前，数据经过复杂处理需要一些时间，浏览器提示当前页面没响应，是否等待或者结束程序。
function loadData() { //--------------------第一步 $.ajax({ url:'${ctx}/EP/getExamType.do', async:false, --------------------第二步 type:"post", beforeSend:function(){ $("#loading").css("display",""); $("#loadingsrc").css("display",""); }, success:function(data){ //--------------------第三步 data =eval('(' + data + ')'); //ajax返回成功，清除loading图标 $("#loading").css("display","none"); $("#loadingsrc").css("display","none");; } }); //--------------------第四部 } 处理方法，对应上图中的步骤
解决办法：
第一步 加上 var defer = new jQuery.Deferred();
第二步 注释掉 async(或者删除)
第三步 加上 defer.resolve(result);
第四步 加上 return defer;
function loadDate() { var defer = new jQuery.Deferred(); //统计图一饼装图 $.ajax({ url:'${ctx}/EP/getExamType.do', // async:false, type:"post", beforeSend:function(){ $("#loading").css("display",""); $("#loadingsrc").css("display",""); }, success:function(data){ defer.resolve(data); data =eval('(' + data + ')'); //ajax返回成功，清除loading图标 $("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8e8d11067963d8f03c5b698cffe460e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eee86784cb95d859651fd71ae6027cc8/" rel="bookmark">
			建Kangle&#43;EasyPanel对接SWAP IDC虚拟主机自助开通完整教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，准备一台可以搭建CentOS 6.x 64位系统的服务器，硬盘大小建议20G以上！
2，Xshell 5（用来登录服务器）
3，ftp上传工具
教程较为简单，会的人就别嘲讽了，直接右上角关闭即可！
教程开始：
打开Xshell 5登录上你的服务器，显示如下即登录成功
然后输入我们准备好的Kangle 一键安装脚本免授权代码：
yum -y install wget;wget http://kangle.odata.cc/start;sh start 本安装脚本本身集成：PHP5.2、PHP5.3、PHP5.4、PHP5.5、PHP5.6、PHP7、MYSQL5.6
支持前台用户任意切换 PHP5.2-7.0, 以适应网站程序。
然后开始安装，粘贴回车后稍等片刻就会让你输入序号，我们默认输入
1. ◎ 安装全部 Kangle/Easypanel/PHP/Mysql 这项
下一步输入您需要设置的MySQL密码，就是要输入你的数据库的密码
下一步选择1. Kangle 3.5.8(推荐)，然后下一步选择1. 安装全部PHP5.2-7.0(推荐)
然后就开始比较漫长的安装过程了（大约20分钟到60分钟）
等我们看到下面这样的图就是安装完成了！复制http://IP地址/admin 到浏览器打开登录
登录密码就是上图，默认都是admin跟kangle,登录后需要先设置数据库！如下图！数据库账号默认都是root,密码是你安装的时候设置的，其他的基本不用管！下面的有域名可以自行设置，弄好后第一次需要重新初始化服务器
设置后然后左边工具栏——新增网站，网站名密码之类的随便写，记好就行，然后PHP一定要跟着我下图这样选择！
产品类型：虚拟主机
模块：无（旧格式）
语言：PHP 旁边的PHP版本可以随便选
然后点击开通即可完成！点击网站名称下方的主机名即可进入管理！
kangle &amp; easypane的搭建在这里就完成了，下面就是SWAP IDC虚拟主机销售平台的搭建了！
SWAP IDC是一款国人制作的IDC虚拟主机销售平台，很多的功能都是免费的！而且非常容易上手！
打开http://www.swapidc.cn/ ，注册账号登录什么的就不说了！
登录上去之后点击左侧菜单栏——SWAP IDC——网站列表——安装新程序
把你下载下来的解压包解压上传到你的网站！怎么上传之类的就不多说了，要是这都不会我也不想多说什么了
上传好之后就是安装！安装也不详细说了！填写数据库之类的，然后下一步会给你一个绑定码！如下图！然后点击上图的绑定网站进行绑定
然后安装插件！还是左侧菜单栏——SWAP IDC——系统商店——插件——服务器
安装这款EasyPanel插件
安装好后回到SWAP IDC——网站列表——你的网站“进入管理”看一下插件开启没有，然后进入你的网站管理后台！
点击上方菜单栏“服务器”——再添加服务器，填好后进入编辑
服务器主机名跟服务器IP地址都可以填写你的服务器IP地址！
然后下面的已经安装的服务器插件，这里就选择我们刚才安装的EasyPanel，用户名跟密码就是服务器的登录账户密码，默认就是admin跟kangle(可不填,因只用于后台中快速登录按钮)
然后下方的哈希密码就是你服务器的面板通信安全码，在哪里看呢，看下图，点击“随机”生成后填入哈希密码栏即完成！
然后上方菜单栏“产品管理”——产品列表——添加，然后编辑
这里很简单！我就直接复制来自官方插件的说明吧
空间类型可填入php,web配额即是空间大小,数据库类型选择Mysql,可选SQL(需要服务器支持)
FTP打钩(FTP权限,不勾选则无法从FTP控制文件)
独立日志打钩(占用一定的硬盘,可不勾选)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eee86784cb95d859651fd71ae6027cc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edea360634a8c06a956191b8a178b1c1/" rel="bookmark">
			修复LandSat7 ETM SLC&#43;off缺失条带
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想做深度学习修复遥感图像，现在先试一下广泛使用的遥感专业软件envi的条带修复效果。方便以后实现不同方法的对比。
整体步骤：
1、地理空间数据云下载免费的遥感图像
2、用landsat7 slc+off 的掩膜和landsat7 slc+on的图像文件生成新的条带图像
3、envi插件修复，输出栅格tif文件
4、用arcgis将tif转换为jpg
5、计算PSNR和SSIM指标
详细解释：
1
经过了解，网上方便下载landsat7图像的地方有中科院国际科学数据服务平台和地理空间数据云，后者的数据应该也是从前者下载过来整合的，但是不知是特殊时期还是没有权限，国科平台的数据页面进不去，其网站提供的两种在线数据恢复方法也没法用。只能在后者下载数据。
2
下载的每景图像中，包含该卫星每个波段的图和每个波段的掩膜文件。因为后面要对修复的图像作PSNR和SSIM两个指标评价，需要有groundtruth，但是landsat7slc+off是没有的，所以我下载了03年之前传感器未损坏的图像。使用损坏图像的掩膜和完好图像自己制作了缺失条带图像。这里有个问题是即使都是landsat7卫星，但每一景的大小都不通，因此是不能直接拿损坏图像一个波段的掩膜和完好图像作融合，他们大小不匹配，matlab会报错。况且每张卫星图非常大，直接对其处理不方便，因此我取中间的750*600像素块来进行后续的计算的研究。
RGB=imread('321.TIF'); RGB1=imcrop(RGB,[1150,2300,750,600]); rgb=imread('caiqie_mask.TIF'); rgb1=imcrop(rgb,[1150,2300,750,600]); imshow(RGB1); RGB2=RGB.*rgb; figure imshow(RGB2); imwrite(RGB2,'caiqie_321.TIF'); 裁切后的groundtruth：
添加掩膜后的自制条带图像：
对于landsat7卫星来说，其图像一共有9个波段，查资料得知，其3、2、1波段分别赋红、绿、蓝合成后会生成自然状态下的真彩色，正是我们的需求，因此上面所有的图都是3、2、1波段按顺序合成的真彩色图。
3
ENVI插件修复方法基本有两种，两个插件分别是landsat_gapfill.sav和tm_destripe.sav 下载地址
https://blog.csdn.net/dou3516/article/details/71547274
两种方法使用上略微有点不同，具体操作很多人的博客都有说，不再赘述。
有一点需要注意：如果envi版本比较新，是没有basic tools这个窗口的，我5.3的版本是在右侧的toolbox。网上很多人说的插件放在envi安装目录下的save_add文件夹中即可，使用路径 Basic Tools -&gt; Preprocessing -&gt; Data-Specific Utilities -&gt;Landsat TM -&gt; Landsat gapfill，注意这是经典版的，我5.3版本是在这。
这两个插件效果差别很大，这是tm_destripe修复效果：
这是landsat_gapfill修复效果：
很明显后者要好很多，因此后面不再关注第一种方法。由于我要与深度学习的方法作比较，此两种方法均为传统方法，其具体实现原理暂不做深入探究，仅比较他们的修复效果。
4
在探索过程中，我发现用envi修复的图像只能保存为TIF或者其他不认识，不熟悉的文件格式。并不能保存常见的jpg图片格式，这或许会给后面的使用带来很多问题，所以我用另一款专业软件arcgis10.2将栅格TIF转换成JPG格式。因为某些原因，以前装的不能用了，需要重新安装，但要注意，在非首次安装时，一定要先把上次装的清理干净，特别是系统注册表那些卸载软件很容易忽略的，不然会一直安装失败。另外很多人在安装arcgis manager时，提示缺少一个文件，那应该是下载的安装包不完整。：
这里推荐一个教程链接，下载安装都有，很好用
5
利用landsat_gapfill.sav插件修复的图像效果如下：
与前面groundtruth对法发现，其修复的视觉效果是还不错的，计算其峰值信噪比和结构相似度：此处借鉴此博客方法
到此，得到一组传统方法修复遥感条带图像的指标。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de4635f23183e3bb8d4c4d0a8391a01c/" rel="bookmark">
			OPENSSH 详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是Openssh
OpenSSH 是 SSH （Secure SHell） 协议的免费开源实现。SSH协议族可以用来进行远程控制， 或在计算机之间传送文件。而实现此功能的传统方式，如telnet(终端仿真协议)、 rcp ftp、 rlogin、rsh都是极为不安全的，并且会使用明文传送密码。OpenSSH提供了服务端后台程序和客户端工具，用来加密远程控件和文件传输过程中的数据，并由此来代替原来的类似服务。 知识延伸：
ssh协议有两个版本：
v1:基于CRC-32 做MAC，不安全； （一般用于实现主机认证）
v2:基于协议协商选择双方都支持的最安全的MAC机制
基于DH做密钥交换，基于RSA或DSA实现身份认证，从而实现无需输入账号面膜
客户端通过检查服务器端的主机秘钥来判断是否能够继续通信；
认证方式：
1、基于口令的认证
2、基于密钥的认证
二、为什么要使用OpenSSH
由于传统的telnet、rcp ftp等工具是明文传输数据的，对数据安全性存在很大的安全隐患，而OpenSSH可以对传输的数据进行加密从而大大提高了数据的安全性。 三、OpenSSH程序简介
1、OpenSSH的分为客户端和服务端两部分
Clients端的配置文件：/etc/ssh/ssh_config Server端的配置文件：/etc/ssh/sshd_config Server端服务脚本：/etc/rc.d/init.d/sshd OpenSSH在Linux系统中默认是安装并启动的 openssh 主要的关键包有四个
openssh.x86_64 5.3p1-104.el6 //服务端和客户端的公共组件
openssh-askpass.x86_64 5.3p1-104.el6 //
openssh-clients.x86_64 5.3p1-104.el6 //客户端安装包
openssh-server.x86_64 5.3p1-104.el6 //服务端安装包
openssl-clients 几个常用文件 [root@1inux ssh] # rpm -ql openssh-clients /etc/ssh/ssh_config //客户端配置文件 /usr/bin/scp //远程复制文件 /usr/bin/sftp //远程文件共享 /usr/bin/slogin /usr/bin/ssh /usr/bin/ssh-add /usr/bin/ssh-agent /usr/bin/ssh-copy-id /usr/bin/ssh-keyscan openssl-server 几个常用文件 /etc/rc.d/init.d/sshd /etc/ssh/sshd_config /etc/sysconfig/sshd 2、服务器端配置文件/etc/ssh/sshd_config 主要参数详解
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de4635f23183e3bb8d4c4d0a8391a01c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9686c775a5b1b9db3540fdb18c29270f/" rel="bookmark">
			Django error
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Error1:
django.core.exceptions.ImproperlyConfigured: Requested setting LOGGING_CONFIG, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.
Error2:
django.core.exceptions.AppRegistryNotReady: The translation infrastructure cannot be initialized before the apps registry is ready. Check that you don't make non-lazy gettext calls at import time.
Reslove method:
import os os.environ['DJANGO_SETTINGS_MODULE'] = 'lcm.settings' from django.core.wsgi import get_wsgi_application application = get_wsgi_application() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a96e26b5477f36f5a79b06dbea1e14ee/" rel="bookmark">
			【jquery】jquery选择器有哪些
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		4大类：基本选择器、层次选择器、过滤选择器、表单选择器
目录
1、jquery基本选择器
2、jquery层次选择器
3、jquery过滤选择器
4、jquery表单选择器
1、jquery基本选择器 基本选择器是JQuery最常用的选择器，也是最简单的选择器，它通过元素id、class和标签名来查找DOM元素。
$("#myELement")
选择id值等于myElement的元素，id值不能重复在文档中只能有一个id值是myElement所以得到的是唯一元素$("div")选择所有的div标签元素，返回div元素数组$(".myClass")选择使用myClass类的css的所有元素$("*")选择文档中的所有的元素，可以运用多种的选择方式进行联合选择：例如$("#myELement,div,.myclass") 注意：在网页中id只能使用一次，即id具有唯一性，但class是允许重复使用的。
2、jquery层次选择器 层次选择器通过DOM元素间的层次关系来获取元素，主要的层次关系包括父子、后代、相邻、兄弟关系。
$("form input")选择所有的form元素中的input元素$("#main &gt; *")选择id值为main的所有的子元素$("label + input")选择所有的label元素的下一个input元素节点，经测试选择器返回的是label标签后面直接跟一个input标签的所有input标签元素$("#prev ~ div")同胞选择器，该选择器返回的为id为prev的标签元素的所有的属于同一个父元素的div标签 说明：只有这个方法返回的是JQuery对象才能进行链式操作。
3、jquery过滤选择器 过滤选择器主要是通过特定的过滤规则来筛选出所需的DOM元素，过滤规则与CSS中的伪类选择器语法相同，即选择器都以一个冒号(:)开头（关于css伪类选择器更多知识可以参考css学习手册）。按照不同的过滤规则，过滤选择器可以分为基本过滤，内容过滤，可见性过滤，属性过滤，子元素过滤和表单对象属性过滤选择器共六种选择器。下面我们分别来简单看一下jquery这六种过滤选择器
（1）jquery基本过滤选择器
过滤选择器是根据某类过滤规则进行元素的匹配，书写时都以(:)开头；简单过滤选择器是过滤选择器中使用最广泛的一种。
$("tr:first")：选择所有tr元素的第一个
$("tr:last")：选择所有tr元素的最后一个
$("input:not(:checked) + span") ：过滤掉：checked的选择器的所有的input元素
$("tr:even")：选择所有的tr元素的第0，2，4... ...个元素（注意：因为所选择的多个元素时为数组，所以序号是从0开始）
$("tr:odd")：选择所有的tr元素的第1，3，5... ...个元素
$("td:eq(2)")：选择所有的td元素中序号为2的那个td元素
$("td:gt(4)") ：选择td元素中序号大于4的所有td元素
$("td:ll(4)")：选择td元素中序号小于4的所有的td元素
$(":header")：匹配如 h1, h2, h3之类的标题元素.这个是专门用来获取h1,h2这样的标题元素
$("div:animated")：匹配所有正在执行动画效果的元素
（2）jquery内容过滤选择器
内容过滤选择器的过滤规则主要体现在它所包含的子元素和文本内容上。
$("div:contains('John')") ：选择所有div中含有John文本的元素
$("td:empty") ：选择所有的为空（也不包括文本节点）的td元素的数组
$("div:has(p)") ：选择所有含有p标签的div元素
$("td:parent")：选择所有的以td为父节点的元素数组
（3）jquery可见性过滤选择器
可见度过滤选择器是根据元素的可见和不可见状态来选择相应的元素。
$("div:hidden")：选择所有的被hidden的div元素
$("div:visible")：选择所有的可视化的div元素
（4）jquery属性过滤选择器
属性过滤选择器的过滤规则是通过元素的属性来获取相应的元素。
$("div[id]")： 选择所有含有id属性的div元素
$("input[name='newsletter']")：选择所有的name属性等于'newsletter'的input元素
$("input[name!='newsletter']") ：选择所有的name属性不等于'newsletter'的input元素
$("input[name^='news']")： 选择所有的name属性以'news'开头的input元素
$("input[name$='news']") ：选择所有的name属性以'news'结尾的input元素
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a96e26b5477f36f5a79b06dbea1e14ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66dba26cdd69f836f808a62d499bb5ec/" rel="bookmark">
			C语言：popen函数的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言：popen函数的使用 一、利用system函数调用shell命令，只能获取到shell命令的返回值，而不能获取shell命令的输出结果，那如果想获取输出结果怎么办呢？用popen函数可以实现。
二、定义函数：FILE * popen(const char * command, const char * type);
函数说明：popen()会调用fork()产生子进程，然后从子进程中调用/bin/sh -c 来执行参数command 的指令。
参数type 可使用 "r"代表读取，"w"代表写入。依照此type 值，popen()会建立管道连到子进程的标准输出设备或标准输入设备，然后返回一个文件指针。随后进程便可利用此文件指针来读取子进程的输出设备或是写入到子进程的标准输入设备中。
此外，所有使用文件指针(FILE*)操作的函数也都可以使用，除了fclose()以外。
返回值：若成功则返回文件指针, 否则返回NULL, 错误原因存于errno 中.
三、实例测试
1、popen.c
#include "stdio.h" #include "stdlib.h" int popen_system(const char * cmd, char *pRetMsg, int msg_len) { printf("\n\n________%s %d cmd=%s\n", __func__, __LINE__,cmd); FILE * fp; char * p = NULL; int res = -1; if (cmd == NULL || pRetMsg == NULL || msg_len &lt; 0) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66dba26cdd69f836f808a62d499bb5ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7caef311f327988cc99e60eaf26ba26/" rel="bookmark">
			Latex另起一页的命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Latex另起一页的命令如下：
\clearpage 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6770d60af3f161b082073871b5494f6c/" rel="bookmark">
			pycharm 安装库失败（cmd安装方法）ERROR: Exception: Traceback (most recent call last):
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ERROR: Exception:
Traceback (most recent call last):
File “C:\Users\Nurbiya-K\AppData\Roaming\Python\Python37\site-packages\pip_vendor\urllib3\response.py”, line 360, in _error_catcher
yield
File “C:\Users\Nurbiya-K\AppData\Roaming\Python\Python37\site-packages\pip_vendor\urllib3\response.py”, line 442, in read
data = self._fp.read(amt)
File “C:\Users\Nurbiya-K\AppData\Roaming\Python\Python37\site-packages\pip_vendor\cachecontrol\filewrapper.py”
在pycharm上安装新库的时候总是安装失败，然后到cmd里面进行安装又报了这个错：
于是按照提示更新了pip库：
还是报错了，更新失败
搞半天终于知道了，安装库要进到Python的pip文件下面，才可以安装！！！
下一步安装自己要安装的库：
到pycharm 来测试一下：
发现刚安装的库可以在pycharm中调用
欧耶，安装成功了！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae841afcde8170694b78afbc63695d26/" rel="bookmark">
			哪些数据可以放进缓存？记录生产环境一次缓存评估的过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者 l 会点代码的大叔（CodeDaShu）
当项目中引入了 Redis 做分布式缓存，那么就会面临这样的问题：
哪些数据应该放到缓存中？依据是什么？
缓存数据是采用主动刷新还是过期自动失效？
如果采用过期自动失效，那么失效时间如何制定？
正好这两周我们项目做了相关的评估，把过程记录下来和大家分享分享；当然过程中用到了很多“笨办法”，如果你有更好的办法，也希望能分享给我。
01
项目背景
我们的项目是一个纯服务平台，也就是只提供接口服务，并没有操作页面的，项目的接口日调用量大约在 200 万次，高峰期也就 1000 万出头，因为大部分接口是面向内部系统的，所以大部分请求集中在工作日的 9 点到 21 点，高峰期的时候系统的 QPS 在 300-400 之间。
因为我们项目数据存储使用的是 MongoDB，理论上支撑这个量级的 QPS 应该是绰绰有余，但是我有这么几点观察和考虑：
MongoDB 中虽然是整合好的数据，但是很多场景也不是单条查询，夸张的时候一个接口可能会返回上百条数据，回参报文就有两万多行（不要问我能不能分页返回......明确告诉你不能）；
MongoDB 中虽然是整合好的数据，但是很多场景也不是单条查询，夸张的时候一个接口可能会返回上百条数据，回参报文就有两万多行（不要问我能不能分页返回......明确告诉你不能）；
目前项目 99.95% 的接口响应时间都在几十到几百毫秒，基本可以满足业务的需要，但是还是有 0.05% 的请求会超过 1s 响应，偶尔甚至会达到 5s、10s；
观察这些响应时间长的请求，大部分时间消耗在查询 MongoDB 上，但是当我将请求报文取出，再次手动调用接口的时候，依然是毫秒级返回；MongoDB 的配置一般，时刻都有数据更新，而且我观察过，响应时间长的这些接口，那个时间点请求量特别大；
MongoDB 查询偶尔会慢的原因我我还在确认，我现在能想到的原因比如：大量写操作影响读操作、锁表、内存小于索引大小等等，暂时就认为是当时那一刻 MongoDB 有压力；我观察过，响应时间长的这些接口，那个时间点请求量特别大，这一点就不在这里具体分析了。
虽然一万次的请求只有四五次响应时间异常，但是随着项目接入的请求越来越大，保不齐以后量变产生质变，所以还是尽量将危机扼杀在摇篮里，所以果断上了 Redis 做分布式缓存。
02
接口梳理
下一步就是对生产环境现有接口进行统计和梳理，确定哪些接口是可以放到缓存中的，所以首先要对每一个接口的调用量有大概的统计，因为没有接入日志平台，所以我采用了最笨的办法，一个一个接口的数嘛。
把工作日某一天全天的日志拉下来，我们四台应用服务器，每天的日志大概 1 个G，还好还好；
通过 EditPlus 这个工具的【在文件中查找】的功能，查询每个接口当天的调用量，已上线 30 个接口，有几分钟就统计出来了，反正是一次性的工作，索性就手动统计了；
一天也调不了几次的接口，就直接忽略掉了，我基本上只把日调用量上万的接口都留下来，进行下一步的分析。
03
字典表、配置类的数据
这一类的数据是最适合放在缓存中的，因为更新频率特别低，甚至有时候 insert 了之后就再也不做 update ，如果这类数据的调用量比较大，是一定要放到 Redis 中的；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae841afcde8170694b78afbc63695d26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a9284b7390bb3ee0a849bac4cde1140/" rel="bookmark">
			2.Echarts和RabbiMq
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一.Echarts入门二.使用Echarts1.创建模块2. 前台页面访问3. 根据 官网可进行样式的更换 三.邮件发送1.编写工具类2.在注册的时候给用户发送一封邮件3.发送邮件存在问题 四.消息中间件1.了解消息中间件2.MQ的两种模式 五.安装RabbitMq1.第一步：下载并安装erlang2.下载并安装RabbitMQ3.安装过程中遇到的问题 六.RabbitMQ后台操作1.添加一个用户2.添加一个虚拟主机3.MQ端口号 七.RabbitMQ队列模式1.队列模式--普通队列（手工回执）2.队列模式--Work模式队列2.1两个一模一样的消费者2.2一个消费者处理慢一个消费者处理快2.3每次取消息只取一条 八.RabbitMQ订阅模式1.订阅模式--fanout2.订阅模式--direct3.订阅模式--topic 九.通过RabbitMQ发送邮件（重点）1.消息的生产者1.1 引入依赖1.2 applicationContext-mq.xml1.3 改写userController 2.消息的消费者2.1 引入依赖2.2 applicationContext.xml 2.3建一个监听类2.4 建一个启动类 一.Echarts入门 链接: 五分钟上手Echarts入门 案例
二.使用Echarts 1.创建模块 使用dobbo框架 需要创建stat_service 和stat_interfacestat_service是一个web工程，在这里面需要配置web.xml &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" version="2.5"&gt; &lt;!-- 监听器监听其他的spring配置文件 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath*:spring/applicationContext-*.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;/web-app&gt; 配置 applicationContext-dubbo.xml &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:dubbo="http://code.alibabatech.com/schema/dubbo" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd http://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a9284b7390bb3ee0a849bac4cde1140/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34301c413d60160aae0daa33575fb180/" rel="bookmark">
			oracle常用操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		oracle常用操作 一、数据泵使用步骤(搭配linux命令) 1.创建文件
（如果文件存在则不需要再次创建，只需给用户附文件的读写权限，根据需要，选择执行步骤顺序，一般情况下，dmp_file 文件已经被建好了，目录：/home/app/dmp_file）
create directory DMP_FILE as '/home/app/dmp_file'; 2.进入数据库中查看目录
select * from dba_directories; 3.将文件夹的读写权限给相应的用户
grant read,write on directory DMP_FILE to cams; 4.备份
（前三步需要 sqlplus 命令进入数据库中执行，第四步需要 exit 退出数据库，在外部执行 dmp 导入导出命令）
数据泵导出数据库中的数据
expdp 数据库用户/密码 DIRECTORY=上面建的文件的别名 DUMPFILE=dmp 文件名.dmp SCHEMAS=数据库用户 logfile=日志文件名.log #例如 expdp XXX/XXX DIRECTORY=DMP_FILE DUMPFILE=xxx.dmp SCHEMAS=xxx logfile=xxx.log 数据泵将dmp文件导入数据库中
impdp 数据库用户/密码 DIRECTORY=上面建的文件的别名 DUMPFILE=dmp 文件名.dmp FULL=y logfile=日志文件名.log TRANSFORM=segment_attributes #例如 impdp xxx/xxx DIRECTORY=DMP_FILE DUMPFILE=dmp文件名.dmp FULL=y logfile=xxx.log TRANSFORM=segment_attributes:n ## 二、服务器端执行 sql 脚本 概述：服务器端进入数据库执行 @sql脚本的目录 。 步骤： 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34301c413d60160aae0daa33575fb180/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec4d5118da994d8548ecbb810882c5bc/" rel="bookmark">
			小程序开发日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小程序开发日志 最近开发了一个新的小程序,可能之前还没有开发过吧,所以开发的页面不是很多,但时间用来也挺久,功能主要包括,用户授权登陆,浏览上传图片和支付功能,闲来之余记录开发历史
1.用户授权登陆 这里可能会踩的坑就是,微信审核小程序代码的要求就是用户必须在了解体验小程序功能后才能让用户授权登陆,不可刚进入小程序就强制用户授权登陆.
授权登陆按钮触发
&lt;button open-type="getUserInfo" bindgetuserinfo="bindGetUserInfo"&gt;授权登录&lt;/button&gt; 用户点击按钮后首先会触发弹框,提示用户授权登陆
用户点击授权后,开发者可以从bindGetUserInfo回调中获取用户信息包括
然后可以通过调用wx.login 方法获取用户code数据,然后需要根据appid和密钥以及code获取用户openid
wx.login({ success (res) { if (res.code) { //发起网络请求 wx.request({ url: '', data: { code: res.code } }) } else { console.log('登录失败！' + res.errMsg) } } }) 2,上传照片以及预览功能 如果是小程序页面需要上传照片以及预览功能那就比较简单,如果是小程序内嵌的h5页面需要调用微信的上传图片和预览功能,则比较麻烦一点
小程序页面可以直接调用wx.chooseImage方法上传图片
wx.chooseImage({ count: 1,//最多可以选择的图片张数,默认值为9 sizeType: ['original', 'compressed'],//所选的图片的尺寸 sourceType: ['album', 'camera'],//选择图片的来源, success (res) { // tempFilePath可以作为img标签的src属性显示图片 const tempFilePaths = res.tempFilePaths; //将图片转换成base64, let localData = wx.getFileSystemManager().readFileSync(localIds, "base64") } }) 调用chooseImage后success回调函数里resp是:
剩下的下次再写了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e68067f2ed9fe007d1c4187202d9bb58/" rel="bookmark">
			Maya Python脚本导出OBJ
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 老规矩查询官方文档，然发现文档描述的又不准确，例如type参数应该是OBJ，然而当填入了OBJ发现一致无法导出，后参照maya自带导出后发现参数需要是OBJexport，尴尬，例子如下
Path是要保存的路径，可以使用fileDialog2选择路径
import maya.cmds as cmds cmds.file(path, pr=1, ea=1, force=1, options="groups=1;ptgroups=1;materials=1;smoothing=1;normals=1",type="OBJexport") 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b547c015660d8863cd7e617bcd863b6/" rel="bookmark">
			Maya Phthon获取世界坐标系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 经查阅官方技术文档如下
但 经过测试后发现不对，然后看到某国外论坛看到了要用xform命令
世界坐标无法直接获取，需要转换一下，具体如下：
需要根据坐标进行旋转，
参数简单的解释：传入物体，查询，世界空间，旋转枢纽
详细解释可查看文档
http://help.autodesk.com/view/MAYAUL/2019/CHS/?guid=__CommandsPython_index_html
import maya.cmds as cmds word = cmds.xform('pSphere1',q=1,ws=1,rp=1) print word 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfa98744a951d7f63caa35881bf85ba8/" rel="bookmark">
			git强制覆盖拉取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题： 直接在服务器上修改代码，执行git pull报错：
remote: Counting objects: 4, done. remote: Compressing objects: 100% (3/3), done. remote: Total 4 (delta 0), reused 4 (delta 0) Unpacking objects: 100% (4/4), done. From 4a1d8d8..b0e9d1c master -&gt; origin/master Updating 4a1d8d8..b0e9d1c error: Your local changes to the following files would be overwritten by merge: cron/cron.go Please, commit your changes or stash them before you can merge. Aborting 执行强制覆盖拉取（前提是服务器上更新的代码已提交到git上）
git fetch --all git reset --hard origin/master git pull 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1d84f8c2c59ba1545329f0417403547/" rel="bookmark">
			flex布局设置相同宽度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般flex容器没有固定宽度的时候我们会发现里面的div宽度不一样
解决:
在子节点加上flex-bases然后设置大小就可以了
效果这样：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b162286f17293b7a1606d8e9e6968d73/" rel="bookmark">
			Redis-Windows 版本安装以及使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis-Windows-x64 版本下载链接：
一、安装步骤 1、双击
2、下一步
3、接受协议并点击“Next”按钮
4、选择安装目录，并点击“Next”按钮
5、点击“Next”按钮（Redis默认端口是6379）
6、根据自己的内存大小填写内存最大限制
7、安装
8、完成
二、使用 1、打开Windows命令提示符窗口，通过端口测试Redis是否能够正常使用：telnet 127.0.0.1 6379
2、找到Redis的安装目录，双击"redis-cli.exe”来存放和获取Redis的值（图中的redis-cli）
注：安装中若有疑问，请联系作者
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e248da605a681dac28ab6fdd44b1a491/" rel="bookmark">
			表达式引擎------ScriptEngine与IKExpression介绍与比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 之前的旧项目中一直在使用ScriptEngine表达式解析引擎，但是使用过程中发现有执行错误的现象，明明为true却返回false，而且不是必现，想了很多办法，最终并没有解决，想着是否换一个试试，就接触了IKExpression。
正文 使用方法 ScriptEngine package com.lk.sydn.common.util; import javax.script.*; import java.util.HashMap; import java.util.Map; /** * Created by Silence on 2019/1/11. */ public class RunScript { private static ScriptEngineManager scriptEngineManager; private static ScriptEngine scriptEngine; private static Bindings bindings; static { scriptEngineManager = new ScriptEngineManager(); scriptEngine = scriptEngineManager.getEngineByName("js"); bindings = scriptEngine.createBindings(); } public static Boolean run(String expression, String key, Object value) { Map&lt;String, Object&gt; params = new HashMap&lt;&gt;(); params.put(key, value); return run(expression, params); } public static Boolean run(String expression, Map&lt;String, Object&gt; params) { Boolean result = false; expression = expression.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e248da605a681dac28ab6fdd44b1a491/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b756df4accf3ae8716c205c803f6c55e/" rel="bookmark">
			【读论文】Character-Level Language Modeling with Deeper Self-Attention（Vanilla Transformer）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当初读这篇论文的目的只有1个：在读Transformer-XL: Attentive Language Models Beyond a Fixed-Length Context这篇文章时，关于infer阶段，作者为啥说Vanilla Transformer每预测一次就要重新计算，而且xl这篇文章的主要比较对象就是Vanilla Transformer，所以才认为读一下这篇Vanilla Transformer是有必要的，论文位置在：Character-Level Language Modeling with Deeper Self-Attention。为了简单起见，我们按照XL这篇文章的称呼习惯称本文要解读的这个模型结构为Vanilla Transformer。
目录 第一部分：Vanilla Transformer的结构
第二部分：Vanilla Transformer训练时作者的一些小trick
第三部分：Vanilla Transformer的相关结果
第四部分：其他
第一部分：Vanilla Transformer的结构 首先，作者要解决的问题是字级别的LM，相比词级别的LM，字级别LM明显需要依赖的距离特别长，比如说一句话某个位置是应该使用she还是he，是依赖于前面的主语情况，这个主语可能距离此单词位置的有十几个单词，每个单词7-8字母长度，那么这就将近100+个字符长度了，作者使用transformer的结构主要原因是他认为该结构很容易做到在任意距离上的信息传递，而相对RNN（LSTM）这种结构，就需要按照时间一步一步的传递信息，不能做到跨越距离。
这篇文章虽然用到了transformer结构，但与Attention is all you need这篇文章（简称原Transformer）是有差异的。原Transformer整体是一个seq2seq结构，具体的细节见此处。而Vanilla Transformer只利用了原Transformer的decode的部分结构，也就是一个带有mask的attention层+一个ff层。
如果将 "一个带有mask的attention层+一个ff层" 称为一个layer，那么Vanilla Transformer一共有64个这样的layer，每一个layer有2个head，model_dim=512，ff层的hidden_units=2048，sequence的长度为512。对于训练语言模型来说，这已经是一个很深的网络了，要知道对于大名鼎鼎的BERT网络的层数也就12层（base）和24层（large）了。
另外，之所以使用mask结构是因为语言模型的定义是p(xi|x0*x1*......xi-1)，也就是根据前i个字符预测第i+1个字符，如果你已经提前看到了答案（也就是第i+1个字符甚至更后面的字符内容），那就没有预测的意义了，这里加mask与原Transformer的decode部分的带有mask的self-attention道理都是一样的。
Positional Embeddings：RNN结构的网络对于类似于LM这种序列性的数据编码带有天然的优势，但缺点就是不能并行，必须要step by step。而attention结构最大的优点就是可以实现并行，但它不能表达序列性，所以为了给网络加入识别序列性就要引入 位置编码 Positional Embeddings。在原Transformer中，位置编码的编码信息是固定的，不需要学习，具体编码方式如下，输出为pos embedding。将word embedding + pos embedding整体作为网络的输入，并且仅在第一层加入了位置编码，之后的每层都不会再次加入。而对于Vanilla Transformer，作者认为它的网络深度太深了，如果只在第一层加入pos embedding，那么经过多层传递，这个信息很容易丢失，所以它是每层都会将上一层的输出与pos embedding加在一起作为下一层的输入，而且，pos embedding是需要学习的。所以，光pos embedding模型就要学习 N*L*dim 个参数，其中N是网络的层数（本文64层），L是上下文的长度(本文512)，dim是embedding的维度（本文=512）。
def positional_encoding(dim, seq_length, dtype=tf.float32): """ :param dim: 编码后的维度 :param seq_length: 序列的最大长度 :param dtype: :return: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b756df4accf3ae8716c205c803f6c55e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5aa4b4abdc1918e71163e46faabecd21/" rel="bookmark">
			Games101课程笔记_lecture13_光线跟踪
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Games101课程笔记_lecture13_光线跟踪 1 why Ray tracing2 光传播3 光线追踪3 Whitted-style ray Tracing4 技术实现1 光线交点1 光线的数学表示方法2 光线与球相交4 光线与隐式表面的交点5 关系与显示表面的交点平面的数学定义懒办法 2 光线和表面求交的加速1 问题2 加速方法1 包围盒2光线如何求包围盒有交点 5 视频 Ray tracing和光栅化是不同的成像方式
1 why Ray tracing 光栅化不好表现全局的效果。
阴影玻璃的反射：光线在场景中弹了两次间接光照：光线弹射不止一次。
以上这些光栅化不好做这些效果， 光栅化快，但是质量不好。
光线追踪精确，但是很慢，符合物理规律，很真实
光栅化：实时；光线追踪：离线
2 光传播 reciprocity-光线的可逆性，光源发出，也可以从眼睛发出关系。
你可以看到他，他也可以看到你。
从相机出发，往世界上投出光线，进行计算。
3 光线追踪 假设:
眼睛是一个点；
光源也是一个点；
物体会完美的反射和折射；
沿着一条光线考虑的是最近 的一个交点，完美解决了深度测试的问题。
3 Whitted-style ray Tracing 每个弹射点都与光源相连接。
先看这些点是否没挡住，每个点的着色都相加起来。有能量损失，要考虑进去。
也就是把所有的光路都遍历出来，然后计算颜色值，将其累加起来。
4 技术实现 1 光线交点 1 光线的数学表示方法 2 光线与球相交 t不知道。求t
求解t的过程如下，
求解的t必须要有意义。
球与光线的三个关系：
4 光线与隐式表面的交点 用数值的方法求解这个解。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5aa4b4abdc1918e71163e46faabecd21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de84a30a85810ce5e1beb0a2399d91e5/" rel="bookmark">
			SpringCloud中打开feign的熔断机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		spingcloud-openfeign的依赖中包含了hystrix的jar包，不需要额外导入
打开熔断只需yml中添加
feign: hystrix: enabled: true 然后在feign的接口类上添加fallback指定熔断的回调方法
@FeignClient(value="tensquare‐base",fallback = LabelClientImpl.class) 创建feign的接口的实现类，放到spring容器中加载进内存，方便fallback指定字节码文件
@Component public class LabelClientImpl implements LabelClient { @Override public Result findById(String id) { return new Result(false, StatusCode.ERROR,"熔断器启动了"); } } 不结合feign单独使用需要导hytrix的依赖
&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; 参考https://www.cnblogs.com/Tunan-Ki/p/11789997.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4fd7ae6f7fc2702de001bf4132f3420/" rel="bookmark">
			[DevC&#43;&#43;] 底部编译信息栏找不到的问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题类似如下图：
或者这样的： 解决办法很简单：
1.打开VIEW (视图)
2.找到里面的 Floating Report Window，勾选上，就是view里面的最后选项
3.出来一个浮点窗口，鼠标放到浮动窗口的上边框，向上拖动会变大，里面显示你的编译信息
4、拖动浮动窗口放到控制台底部，按右上角的 X 关闭，即可
希望对你有用！
注意，同样这个问题解决，如果你重新卸载安装DevC++还是一样会遇到的，与需要通过设置来解决！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9cb3c91e34eb0534f25510542083515/" rel="bookmark">
			网页爬取时执行状态成功，但获取不到想要的数据的时候解决方法(Network,XHR,json)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Network:
当我们爬取网页的内容，对源代码进行请求，响应的源代码中没有我们需要的东西时，需要查看Network
打开需要爬取的网页，进行源码检查，会发现左边框框里的是Elements，右边框框是我们需要关注的Network
Network 的功能是：记录在当前页面上所发生的所有请求（它是实时加载的，如果是空的，则需要刷新网页）
在图最下面显示，此处有16个请求，15.4kb的流量，耗时3.14s
其实这里的第一个，就是刚requests.get（）获取到的网页源代码，它里面不包含歌曲清单。
一般来说，都是这种第0个请求先启动了，其他的请求才会关联启动，一点点地将网页给填充起来。也有一些网页，直接把所有的关键信息都放在第0个请求里，尤其是一些比较古老（或比较轻量）的网站，我们用requests和BeautifulSoup就可以解决他们。
我们要做的就是找到这些信息藏在哪个请求当中，并用requests库，去模拟这个请求。
什么是XHR？
在Network中，有一类非常重要的请求叫做XHR（当你把鼠标在XHR上悬停，你可以看到它的完整表述是XHR and Fetch）
我们平时使用浏览器上网的时候，经常有这样的情况：浏览器上方，它所访问的网址没变，但是网页里却新加了内容。
典型代表：如购物网站，下滑自动加载出更多商品。在线翻译网站，输入中文实时变英文。
这个，叫做Ajax技术（技术本身和爬虫关系不大）。应用这种技术，好处是显而易见的——更新网页内容，而不用重新加载整个网页。又省流量又省时间的，何乐而不为。
如今，比较新潮的网站都在使用这种技术来实现数据传输。只剩下一些特别老，或是特别轻量的网站，还在用老办法——加载新的内容，必须要跳转一个新网址。
这种技术在工作的时候，会创建一个XHR（或是Fetch）对象，然后利用XHR对象来实现，服务器和浏览器之间传输数据。在这里，XHR和Fetch并没有本质区别，只是Fetch出现得比XHR更晚一些，所以对一些开发人员来说会更好用，但作用都是一样的。
显而易见，对照前面的表单。我们的歌曲清单不在网页源代码里，而且也不是图片，不是媒体文件，自然只会是在XHR里。我们现在去找找看，点击XHR按钮。
client_search ： 客户端搜索（这里里面的就是客户端输入搜索出的信息）
点击preview 就可以看到我们需要的信息：
再点击旁边的Headers就可以看到该信息的链接：
这里的URL就是该信息的链接！
但是我们把这个链接用浏览器搜索的话会看到很多东西：（头疼）
其实就是很多字典嵌套字典！！！！（老虎吃天，没处下嘴）
json:
以前用res.text()来把response对象转换成字符串，json就是把response对象转换成字典\列表
json是数据格式，可以有效有组织的存储信息
json则是另一种组织数据的格式，长得和Python中的列表/字典非常相像。它和html一样，常用来做网络数据传输。刚刚我们在XHR里查看到的列表/字典，严格来说其实它不是列表/字典，它是json。
json和XHR之间的关系：XHR用于传输数据，它能传输很多种数据，json是被传输的一种数据格式。就是这样而已。
import requests #引用requests库 url='网页链接' res_music=requests.get('url') #调用get()方法，下载这个字典 json_music=res_music.json() #使用json方法，将response对象，转为列表\字典 list_music=json_music['data']['song']['list'] #一层一层地取字典，获取歌单列表 for music in list_music: print(music['name']) #这里name对应的就是歌曲名字 运行结果：
XHR的功能是传输数据，其中有非常重要的一种数据是用json格式写成的，和html一样，这种数据能够有组织地存储大量内容。json的数据类型是“文本”，在Python语言当中，我们把它称为字符串。我们能够非常轻易地将json格式的数据转化为列表/字典，也能将列表/字典转为json格式的数据。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f75dd5c8a941b824a57fd37cfc2b25d/" rel="bookmark">
			Laravel 框架之数据库相关操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 //查询列表加模糊条件查询
$find //查询条件数组
$perPage //显示条数
$page //显示第几页
$field //排序字段
$order //排序规则
$user = DB::table('system_user')-&gt;where(function ($query) use ($find) { isset($find['user_name']) &amp;&amp; $query-&gt;where('user_name', 'like', '%' . $find['user_name'] . '%'); })-&gt;orderBy($field,$order)-&gt;paginate($perPage,$page);//查询分页列表 $user-&gt;total();//总数据条数 $data = $user-&gt;items();//输出成数组 //查询数据 键值对 例如：ID=&gt;role_name
$roles = DB::table('system_role')-&gt;pluck('role_name', 'id'); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19e0a3eab00ec2428dd3f5c6c406251b/" rel="bookmark">
			Gitee 代码搜索上线了，居然还可以搜索这些东西
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Gitee 代码搜索上线了，居然还可以搜索这些东西 转载：https://www.oschina.net/news/114282/gitee-code-search?p=1
火速前往 https://search.gitee.com/ 体验。
转载理由：好东西
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5aee5f6d58e7ae6271ed1e6a6daf2cfd/" rel="bookmark">
			TypeScript进阶 之 重难点梳理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方“全栈前端精选“，回复“1”进交流群
加入我们一起学习，天天进步
THE LAST TIME ❝ The last time, I have learned
❞ 【THE LAST TIME】 一直是我想写的一个系列，旨在厚积薄发，重温前端。
也是给自己的查缺补漏和技术分享。
笔者文章集合详见：
GitHub 地址：Nealyang/personalBlog
公众号：「全栈前端精选」
前言 JavaScript 毋庸置疑是一门非常好的语言，但是其也有很多的弊端，其中不乏是作者设计之处留下的一些 “bug”。当然，瑕不掩瑜~
话说回来，JavaScript 毕竟是一门弱类型语言，与强类型语言相比，其最大的编程陋习就是可能会造成我们类型思维的缺失（高级词汇，我从极客时间学到的）。而「思维方式决定了编程习惯，编程习惯奠定了工程质量，工程质量划定了能力边界」，而学习 Typescript，最重要的就是我们类型思维的重塑。
那么其实，Typescript 在我个人理解，并不能算是一个编程语言，它只是 JavaScript 的一层壳。当然，我们完全可以将它作为一门语言去学习。网上有很多推荐 or 不推荐 Typescript 之类的文章这里我们不做任何讨论，学与不学，用或不用，利与弊。各自拿捏~
再说说 typescript（下文均用 ts 简称），其实对于 ts 相比大家已经不陌生了。更多关于 ts 入门文章和文档也是已经烂大街了。「此文不去翻译或者搬运各种 api或者教程章节。只是总结罗列和解惑，笔者在学习 ts 过程中曾疑惑的地方」。道不到的地方，欢迎大家评论区积极讨论。
其实 Ts 的入门非常的简单:.js to .ts; over!
「但是为什么我都会写 ts 了，却看不懂别人的代码呢？」 这！就是入门与进阶之隔。也是本文的目的所在。
首先推荐下 ts 的编译环境：typescriptlang.org
再推荐笔者收藏的几个网站：
Typescript 中文网
深入理解 Typescript
TypeScript Handbook
TypeScript 精通指南
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5aee5f6d58e7ae6271ed1e6a6daf2cfd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3098adf136a1ffb41630a9a5a316436a/" rel="bookmark">
			记一次Idea 内存消耗严重，CPU资源占比严重的彻底解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 从使用idea2017版开始，突然有天发现idea内存消耗比较严重，尤其开启了tomcat后，过一段时间，idea的运行内存会被吃满，最近还发现编辑代码，提交代码，CPU占比可以直接飙升到100%，风扇呼呼作响，于是开始找各种解决方案。
解决方案： 1、卸载多余不常用的插件；
2、设置某些idea配置，比如去掉某些动画、编译检查什么的；
3、调整idea.vm.properties中的jvm大小。
方案说明 1、卸载插件：此方案具体要看卸载的什么插件，如果没有找到那个真正消耗资源的元凶插件，优化效果基本无效。在很长的时间中，我也怀疑是某个插件消耗了CPU，最后通过网友的提示，通过Idea 自带的监控功能–Help/Activity Monitor，发现CPU打满的时候，插件Alibaba 的代码规范检查插件占有CPU最高，于是禁用再去测试，发现后面的代码编辑和提交CPU都保持正常的水平了；
2、调整idea的设置：这个方案只能减轻运行压力，基本没什么效果；
3、调整idea 的运行内存：此方案没有解决本质问题，只能暂时解决，而且撑下去的时间不会太长，举例来说，我曾经设置了6g的内存，但还是很快就会被吃掉。
最终方案 在网上搜索方案的时候，一直发现有人提到，idea卡顿的本质原因是因为idea的运行jre环境，与项目的编译环境不相同，比如idea2019版已经默认使用了自己idea封装的jre11版本，而我的项目中使用的是官方的jdk1.8版本，但是一直没有找到怎么去替换idea默认的jre环境，旧版的idea自身通过Switch Boot SDK 功能可以切换，但是新版的idea中已经不提供这个功能了，所以需要用另一种方案，安装idea的插件–choose runtime。
choose runtime 安装后（2020版本之前的idea可能需要重启），之后去Help/Find Action，搜索 “choose runtime”，之后打开这个选项。
这时候idea 就会开始检测可以设置的jre环境，这个搜索加载会比较耗时，大家要耐心一点。
之后会出来好多的jre版本替换选项，一定要选择自己安装的官方版本的jre，之后重启idea，大功告成！
验证效果 在idea 的About中，可以看到idea当前依赖的运行环境（Runtime version），已经变成了刚才指定的官方jre版本。
之后可以打开项目与tomcat，进行效果测试了，经过我的测试，本地环境下，jvm占用不会超过1g，基本都是维持在600-700m，哪怕在多开一个idae窗口去运行tomcat，也不会到1g的内存使用，这时候可以把idea.vm的最大jvm运行内存调整到2g了，发现依然不卡顿。
idea.vm 配置信息参考 -Xms1g -Xmx2g -XX:ReservedCodeCacheSize=256m -XX:+UseConcMarkSweepGC -XX:SoftRefLRUPolicyMSPerMB=128 -ea -XX:CICompilerCount=2 -Dsun.io.useCanonPrefixCache=false -Djava.net.preferIPv4Stack=true -Djdk.http.auth.tunneling.disabledSchemes="" -XX:+HeapDumpOnOutOfMemoryError -XX:-OmitStackTraceInFastThrow -Djdk.attach.allowAttachSelf=true -Dkotlinx.coroutines.debug=off -Djdk.module.illegalAccess.silent=true -XX:+UseCompressedOops -Dfile.encoding=UTF-8 -XX:ErrorFile=$USER_HOME/java_error_in_idea_%p.log -XX:HeapDumpPath=$USER_HOME/java_error_in_idea.hprof tomcat jvm配置信息参考 -Dfile.encoding=UTF-8 tomcat jvm大小缺省配置就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/138ab62f06767b450265dc308f539290/" rel="bookmark">
			解决windows api的子窗口大小设置问题    (以及windows API 设置窗口 c#调用 panel控件)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		仅作为查找记录，大佬请跳过。
出现图像底部不在penal里的情况：
可能是——
MoveWindow(figure1, 0, 0, panel1.Width + 20, panel1.Height + 40, true); ——的原因
——————————————————————————————————
将其改为
MoveWindow(figure1, 0, 0, panel1.Width + 20, panel1.Height - 40, true); 图像下面便可以显示了：
但一放大主窗体，又看不到图像的x坐标了。。
关于 但一放大主窗体，又看不到图像的x坐标了。。 的解决：
后来发现代码里还有一项是设置窗体的功能——即对主窗体操作后，会改变嵌入的子图片的大小：
修改后：
运行结果：
放大后也是如此：
顿时感觉这一句话说的真对！感谢百度百科的这位大佬撰写者
传送门——MoveWindow
1、GetWindowLong
var style = GetWindowLong(figure1, GWL_STYLE); //获取窗体原来的风格 2、SetWindowLong
SetWindowLong(figure1, GWL_STYLE, style &amp; ~WS_CAPTION &amp; ~WS_THICKFRAME); //设置新风格，去掉标题,不能通过边框改变尺寸 3、MoveWindow
MoveWindow(figure1, 0, 0, panel1.Width + 20, panel1.Height + 40, true); //移动到panel里合适的位置并重绘 4、
SetParent(figure1, panel1.Handle); //设置matlab图像窗体的父窗体为panel 传送门
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/138ab62f06767b450265dc308f539290/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85004aee1188a6d7d98ebc0c5c2f32e0/" rel="bookmark">
			详解jQuery动画
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jQuery动画有两种，一种是内置动画，还有一种是自定义动画
内置动画的操作样式：
显示动画:
给div一个显示的动画(如果元素本身是隐藏的状态，就可以显示出来)
隐藏动画：
给div一个隐藏的动画(如果元素本身是显示的状态，就可以隐藏出来)
显示隐藏切换动画：
给div绑定一个显示隐藏切换的动画(元素本身是显示，那么就隐藏；本身是隐藏，那么就显示)
下拉显示：
给div一个下拉的动画(元素本身是隐藏的，下拉显示 )
上拉隐藏：
给div一个上拉的动画(元素本身是显示的，上拉隐藏 )
上拉下拉切换动画： 给div一个上拉下拉切换的动画(如果元素本身是显示的，上拉隐藏；如果元素本身是隐藏的，下拉显示）
逐渐显示动画：
给div一个逐渐显示的动画
逐渐隐藏动画：
给div一个逐渐隐藏的动画
渐隐渐显动画：
给div一个渐隐渐显的动画
变换到指定透明度：
给div一个变换到指定透明度的动画
自定义动画：animate({属性:属性值},‘毫秒数’,‘速度’,'回调函数‘）。例如：
动画的同步执行：animate与animate之间是同步执行，例如：
动画的控制：
delay(毫秒数) //延时执行动画
stop() //当前动画直接停止，动画就停止在当前的位置，然后立即执行下一次的动画效果
finish() //当前动画直接结束，动画直接执行到终止状态，然后立即执行下一次动画效果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25a6818296d686f6e99c4d0a973d81ea/" rel="bookmark">
			[数据结构与算法]11 一篇文章教你搞定递归单链表反转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于单链表反转,在 [数据结构与算法]04 Link List (链表)及单链表反转实现 中已经写过了,不是使用递归方法来实现的.因为递归不太容易讲清楚.
但是不能因为害怕讲不清楚就不写了,对不对.
所以这篇文章来使用递归来实现一下,并且尝试将里面的细节一一剖出来,不废话.
首先,咱们要先明确,什么是递归.递归就是自己调用自己对吧.比如:有一个函数为 f(n) = f(n-1) * n ,(注意,我这里是举例子,这个函数没有给出递归的结束条件)给 n 赋值为 5 , 则:
--&gt; f(5) --&gt; 5 * f(4) --&gt; 5 * ( 4 * f(3)) --&gt; 5 * ( 4 * (3 * f(2))) --&gt; 5 * ( 4 * ( 3 * ( 2 * f (1)))) --&gt; 5 * ( 4 * ( 3 * ( 2 * 1))) --&gt; 5 * ( 4 * ( 3 * 2)) --&gt; 5 * ( 4 * 6 ) --&gt; 5 * 24 --&gt; 120 在看完例子之后,咱们接下来不 BB ,直接 show code:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25a6818296d686f6e99c4d0a973d81ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29945b2661e7d661294a24bb912b697b/" rel="bookmark">
			vue&#43;element-ui中上传文件使用Progress自定义实时更新进度条
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Upload+Progress实现文件上传进度条实时更新功能，需要借助http-request属性。具体使用方法如下：
&lt;el-upload action="#" :file-list="fileList" :on-change="changeData" :http-request="handleRequest" :before-upload="beforeUpload"&gt; &lt;el-button class="btn upload-btn"&gt;上传附件&lt;/el-button&gt; &lt;div slot="tip" class="el-upload__tip"&gt;上传文件大小不超过50M&lt;/div&gt; &lt;/el-upload&gt; &lt;el-progress :stroke-width="16" :percentage="progressPercent"&gt;&lt;/el-progress&gt; //上传前对文件大小进行校验 beforeUpload(file) { const isLt2M = file.size / 1024 / 1024 &lt; 50; if (!isLt2M) { this.$message.error('上传文件大小大小不能超过 50MB!'); return isLt2M; } }, changeData (file, fileList) { // 数据小于0.1M的时候按KB显示 const size = file.size/1024/1024 &gt; 0.1 ? `(${(file.size/1024/1024).toFixed(1)}M)` : `(${(file.size/1024).toFixed(1)}KB)` file.name.indexOf('M')&gt;-1 || file.name.indexOf('KB')&gt;-1 ? file.name : file.name += size }, handleRequest (data) { let formdata = new FormData() formdata.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29945b2661e7d661294a24bb912b697b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f212b38fa6e03e8e0016bf254624798/" rel="bookmark">
			raise ReadTimeoutError(self._pool, None, &#34;Read timed out.&#34;) pip._vendor.urllib3.exceptions.ReadTime
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		raise ReadTimeoutError(self._pool, None, “Read timed out.”)
pip._vendor.urllib3.exceptions.ReadTimeoutError: HTTPSConnectionPool(host=‘files.pythonhosted.org’, port=443): Read timed out.
根本原因： 下载的库是国外的，连接的慢 。所以 ，给他多配置点时间
报错页面 最后的显示
C:\Users\LDH&gt;pip install faker Collecting faker Downloading Faker-4.0.2-py3-none-any.whl (1.0 MB) |██ | 61 kB 1.6 kB/s eta 0:10:03ERROR: Exception: Traceback (most recent call last): File "d:\python3.7\lib\site-packages\pip\_vendor\urllib3\response.py", line 425, in _error_catcher yield File "d:\python3.7\lib\site-packages\pip\_vendor\urllib3\response.py", line 507, in read data = self._fp.read(amt) if not fp_closed else b"" File "d:\python3.7\lib\site-packages\pip\_vendor\cachecontrol\filewrapper.py", line 62, in read data = self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f212b38fa6e03e8e0016bf254624798/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/168a2884b24c4a3d03b691fa23886c3a/" rel="bookmark">
			《动手学深度学习》TensorFlow2.0版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		机器学习&amp;深度学习入门精选&amp;Python&amp;Tensorflow&amp;Pytorch​​​​​​​
对于刚入门深度学习的童鞋，这里分享下大神们开源的将《动手学深度学习》 原书中MXNet代码实现改为TensorFlow2.0实现，欢迎入坑，这是一个非常棒的入门手册，github代码。
目录 简介阅读指南1. 深度学习简介2. 预备知识 2.1 环境配置2.2 数据操作2.3 自动求梯度2.4 查阅文档3. 深度学习基础 3.1 线性回归3.2 线性回归的从零开始实现3.3 线性回归的简洁实现3.4 softmax回归3.5 图像分类数据集（Fashion-MNIST）3.6 softmax回归的从零开始实现3.7 softmax回归的简洁实现3.8 多层感知机3.9 多层感知机的从零开始实现3.10 多层感知机的简洁实现3.11 模型选择、欠拟合和过拟合3.12 权重衰减3.13 丢弃法3.14 正向传播、反向传播和计算图3.15 数值稳定性和模型初始化3.16 实战Kaggle比赛：房价预测4. 深度学习计算 4.1 模型构造4.2 模型参数的访问、初始化和共享4.3 模型参数的延后初始化4.4 自定义层4.5 读取和存储4.6 GPU计算5. 卷积神经网络 5.1 二维卷积层5.2 填充和步幅5.3 多输入通道和多输出通道5.4 池化层5.5 卷积神经网络（LeNet）5.6 深度卷积神经网络（AlexNet）5.7 使用重复元素的网络（VGG）5.8 网络中的网络（NiN）5.9 含并行连结的网络（GoogLeNet）5.10 批量归一化5.11 残差网络（ResNet）5.12 稠密连接网络（DenseNet）6. 循环神经网络 6.1 语言模型6.2 循环神经网络6.3 语言模型数据集（周杰伦专辑歌词）6.4 循环神经网络的从零开始实现6.5 循环神经网络的简洁实现6.6 通过时间反向传播6.7 门控循环单元（GRU）6.8 长短期记忆（LSTM）6.9 深度循环神经网络6.10 双向循环神经网络7. 优化算法 7.1 优化与深度学习7.2 梯度下降和随机梯度下降7.3 小批量随机梯度下降7.4 动量法7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/168a2884b24c4a3d03b691fa23886c3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b63099f3bb19fe192870ff71b565aec/" rel="bookmark">
			SpringBoot-简化发送邮件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备 依赖
&lt;!--mail--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt; &lt;/dependency&gt; 按照之前我们了解的SpringBoot的自动装配原理，试着搜一搜MailAutoConfiguration，看看有没有这个类，结果还真有。不过他叫MailSenderAutoConfiguration ，那就接着看看MailProperties呗！！
@Configuration(proxyBeanMethods = false) @ConditionalOnClass({ MimeMessage.class, MimeType.class, MailSender.class }) @ConditionalOnMissingBean(MailSender.class) @Conditional(MailSenderCondition.class) @EnableConfigurationProperties(MailProperties.class) @Import({ MailSenderJndiConfiguration.class, MailSenderPropertiesConfiguration.class }) public class MailSenderAutoConfiguration { /** * Condition to trigger the creation of a {@link MailSender}. This kicks in if either * the host or jndi name property is set. */ static class MailSenderCondition extends AnyNestedCondition { MailSenderCondition() { super(ConfigurationPhase.PARSE_CONFIGURATION); } @ConditionalOnProperty(prefix = "spring.mail", name = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b63099f3bb19fe192870ff71b565aec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ca493a8579031b23db508422ed7fb95/" rel="bookmark">
			华南理工大学计算机网络慕课第三章测试题参考答案与解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		温馨提醒：为了让大家能快速定位题目，所有题目均按首字母顺序排列。
另：纠一位错海明码的编码方法没细说，可以参考【老猫_fish】的【这篇博客】~
1.采用比特填充的比特标记法，对0111 1100 0111 1110 组帧后，对应的比特串是多少？ 比特填充的标志比特法，以“01111110”作为帧标志，即一个帧的开始和上一帧的结束。为了避免帧内容中出现帧标志，在每5个“1”后面补个“0”。所以对应的比特串是“011111000011111010”。
2.点到点协议PPP的两种认证方式中，PAP不仅简单，而且也解决了拒绝服务攻击和明文传输的问题。 错的。
Pap是password authentication protocol，密码认证协议。密码以文本方式传输，对窃听等无效，是不可靠的。
3.若数据链路层的发送窗口尺寸W=4，在发送3号帧、并收到2号帧的确认帧后，发送方还可以连续发送多少个帧？（采用累计确认） 由于是累计确认，收到2号帧的确认帧，说明2号帧和2号帧之前的帧都被成功接收。可以从2号帧往后再发4个帧。既然已经发出了一个3号帧并且没收到其确认帧，那就还可以连续发送4-1=3个帧。
4.捎带确认的主要作用是：将确认嵌入到外发的数据帧中，而不需要单独发帧，提高了信道的利用率。 对的。
5.使用滑动窗口，每个窗口10 个数据包， RTT 为100 ms ，假设有 1250 字节数据包，最大吞吐量是多少？（注意 1250 字节数据包是 10000 位。要找出最大的吞吐量，假设网络容量不是一个限制因素，忽略数据包丢失) 这里我默认就只有1个窗口了…
一个RTT传送的数据量是10×1250Bytes×8bits/Byte=100000bits
最大吞吐量=单位时间内传输的数据量=100000bits/100ms=1 000 000bits/s=1Mbps。
6.系统采用带位填充的帧界标记法，收方从网络接收到一个字符串是 11101111100。那么，发送方发送的原始字符串是什么？ 位填充法 or 零比特填充法 or 比特填充的标志比特法，以“01111110”作为帧标志，即一个帧的开始和上一帧的结束。为了避免帧内容中出现帧标志，在每5个“1”后面补个“0”。收方将数据中每5个“1”后面紧跟的1个“0”去掉，就可以还原出原本的数据。
1110111110 0=1110111110.
7.系统采用的码字分别是 0000，0011， 1100， 1111（分别对应待传送的码 00， 01， 10 和 11）。请使用海明距离判断：该系统可以检测出多少位错误？ 最小码距等于所有非零码字中的最小码重。这里三个非零码字对应的码重分别是2、2、4，所以这组码字的最小码距是2。要检测出e位错误，要求最小码距d≥e+1。因为2=1+1，所以可以检测出1位错误。
8.系统采用纠1位错的海明码，待传输的数据是：10101111，校验集合采用偶校验，编码后的码字是下面哪一个？ 纠一位错的海明码，8位数据需要4位校验位。
把检验位插进去，得到121401081111.（1带下划线表示第1位上的验证位，2、4、8以此类推）
3、5、7、9、11位共3个“1”，偶校验 1 补“1”。
3、6、7、10、11位共4个“1”，偶校验 2 补“0”。
5、6、7、12位共2个“1”，偶校验 4 补“0”。
9、10、11、12位共4个“1”，偶校验 8 补“0”。
编码后的码字为 1010 0100 1111.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ca493a8579031b23db508422ed7fb95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3aac2d69ec1759687249a917c8ebab80/" rel="bookmark">
			Python设计模式-中介者模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		中介者模式：用一个中介对象封装一系列的对象交互，中介者使各对象不需要显式相互引用，从而使其耦合性降低，而且可以独立低改变他们之间的交互。
from abc import ABCMeta,abstractmethod class HouseInfo: def __init__(self,address,ower): self.__address = address self.__ower = ower def getAddress(self): return self.__address def getOwerName(self): return self.__ower.getName() def showInfo(self): print("房子："+self._address + " 房东是："+self.__ower.getName()) class HouseAgency: def __init__(self,name): self.__houseInfos =[] self.__name = name def getName(self): return self.__name def addHouse(self,house): self.__houseInfos.append(house) def getMatchInfo(self,searchCondition): return self.__houseInfos class HouseOwner: def __init__(self,name): self.__name = name self.__houseInfo = None def setHouseInfo(self,addess): self.__houseInfo = HouseInfo(address,self) class Customer: def __init__(self,name): self.__name = name def getName(self): return self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3aac2d69ec1759687249a917c8ebab80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23857220c2fecd370de8775279b6f0f6/" rel="bookmark">
			蓝桥试题 算法提高 解二元一次方程组 JAVA
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述
给定一个二元一次方程组，形如：
a * x + b * y = c;
d * x + e * y = f;
x,y代表未知数，a, b, c, d, e, f为参数。
求解x,y
输入格式
输入包含六个整数: a, b, c, d, e, f;
输出格式
输出为方程组的解，两个整数x, y。
样例输入
例：
3 7 41 2 1 9
样例输出
例：
2 5
思路：两种解题方法，一种纯暴力，另一种用到了数学的算式。
import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int a = scanner.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23857220c2fecd370de8775279b6f0f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fe84bf2de888dbb79a6592a382095d6/" rel="bookmark">
			【STM32】HAL库 STM32CubeMX教程十一---DMA (串口DMA发送接收)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
本系列教程将 对应外设原理，HAL库与STM32CubeMX结合在一起讲解，使您可以更快速的学会各个模块的使用
所用工具：
1、芯片： STM32F407ZET6/ STM32F103ZET6
2、STM32CubeMx软件
3、IDE： MDK-Keil软件
4、STM32F1xx/STM32F4xxHAL库
知识概括：
通过本篇博客您将学到：
DMA工作原理
STM32CubeMX创建DMA例程
HAL库定时器DMA函数库
注意：关于cubemx的DMA配置，在DMA原理介绍中全部都有所讲解，如果有哪里不懂，请仔细阅读原理详解部分。
DMA的基本介绍 什么是DMA (DMA的基本定义) DMA，全称Direct Memory Access，即直接存储器访问。
DMA传输将数据从一个地址空间复制到另一个地址空间，提供在外设和存储器之间或者存储器和存储器之间的高速数据传输。
我们知道CPU有转移数据、计算、控制程序转移等很多功能，系统运作的核心就是CPU，
CPU无时不刻的在处理着大量的事务，但有些事情却没有那么重要，比方说数据的复制和存储数据，如果我们把这部分的CPU资源拿出来，让CPU去处理其他的复杂计算事务，是不是能够更好的利用CPU的资源呢？
因此：转移数据（尤其是转移大量数据）是可以不需要CPU参与。比如希望外设A的数据拷贝到外设B，只要给两种外设提供一条数据通路，直接让数据由A拷贝到B 不经过CPU的处理，
DMA就是基于以上设想设计的，它的作用就是解决大量数据转移过度消耗CPU资源的问题。有了DMA使CPU更专注于更加实用的操作–计算、控制等。
DMA定义： DMA用来提供在外设和存储器之间或者存储器和存储器之间的高速数据传输。无须CPU的干预，通过DMA数据可以快速地移动。这就节省了CPU的资源来做其他操作。
DMA传输方式 DMA的作用就是实现数据的直接传输，而去掉了传统数据传输需要CPU寄存器参与的环节，主要涉及四种情况的数据传输，但本质上是一样的，都是从内存的某一区域传输到内存的另一区域（外设的数据寄存器本质上就是内存的一个存储单元）。四种情况的数据传输如下：
外设到内存内存到外设内存到内存外设到外设 DMA传输参数 我们知道，数据传输，首先需要的是1 数据的源地址 2 数据传输位置的目标地址 ，3 传递数据多少的数据传输量 ，4 进行多少次传输的传输模式 DMA所需要的核心参数，便是这四个
当用户将参数设置好，主要涉及源地址、目标地址、传输数据量这三个，DMA控制器就会启动数据传输，当剩余传输数据量为0时 达到传输终点，结束DMA传输 ，当然，DMA 还有循环传输模式 当到达传输终点时会重新启动DMA传输。
也就是说只要剩余传输数据量不是0，而且DMA是启动状态，那么就会发生数据传输。　DMA的主要特征 每个通道都直接连接专用的硬件DMA请求，每个通道都同样支持软件触发。这些功能通过软件来配置；
在同一个DMA模块上，多个请求间的优先权可以通过软件编程设置（共有四级：很高、高、中等和低），优先权设置相等时由硬件决定（请求0优先于请求1，依此类推）；独立数据源和目标数据区的传输宽度（字节、半字、全字），模拟打包和拆包的过程。源和目标地址必须按数据传输宽度对齐；支持循环的缓冲器管理；每个通道都有3个事件标志（DMA半传输、DMA传输完成和DMA传输出错），这3个事件标志逻辑或成为一个单独的中断请求；存储器和存储器间的传输、外设和存储器、存储器和外设之间的传输；闪存、SRAM、外设的SRAM、APB1、APB2和AHB外设均可作为访问的源和目标；可编程的数据传输数目：最大为65535。 STM32少个DMA资源？ 对于大容量的STM32芯片有2个DMA控制器 两个DMA控制器，DMA1有7个通道，DMA2有5个通道。
每个通道都可以配置一些外设的地址。
①DMA1 controller
从外设（TIMx[x=1、2、3、4]、ADC1、SPI1、SPI/I2S2、I2Cx[x=1、2]和USARTx[x=1、2、3]）产生的7个DMA请求，通过逻辑或输入到DMA1控制器 其中每个通道都对应着具体的外设：
② DMA2 controller
从外设（TIMx[5、6、7、8]、ADC3、SPI/I2S3、UART4、DAC通道1、2和SDIO）产生的5个请求，经逻辑或输入到DMA2控制器，其中每个通道都对应着具体的外设：
这些在下方系统框图中也可以清晰地看到
DMA工作系统框图 上方的框图，我们可以看到STM32内核，存储器，外设及DMA的连接，这些硬件最终通过各种各样的线连接到总线矩阵中，硬件结构之间的数据转移都经过总线矩阵的协调，使各个外设和谐的使用总线来传输数据。
我们对他来进行一点一点的分析：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fe84bf2de888dbb79a6592a382095d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39e2ebe90b0ce2edb1fd339e18b82c05/" rel="bookmark">
			Scrapy爬虫框架，入门案例（非常详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、概述
二、Scrapy五大基本构成:
三、整体架构图
四、Scrapy安装以及生成项目
五、日志等级与日志保存
六、导出为json或scv格式
七、一个完整的案例
一、概述 Scrapy，Python开发的一个快速、高层次的屏幕抓取和web抓取框架，用于抓取web站点并从页面中提取结构化的数据。Scrapy用途广泛，可以用于数据挖掘、监测和自动化测试.
其最初是为了页面抓取 (更确切来说, 网络抓取 )所设计的， 后台也应用在获取API所返回的数据(例如 Amazon Associates Web Services ) 或者通用的网络爬虫.
Scrapy吸引人的地方在于它是一个框架，任何人都可以根据需求方便的修改。它也提供了多种类型爬虫的基类，如BaseSpider、sitemap爬虫等，最新版本又提供了web2.0爬虫的支持.
二、Scrapy五大基本构成: Scrapy框架主要由五大组件组成，它们分别是调度器(Scheduler)、下载器(Downloader)、爬虫（Spider）和实体管道(Item Pipeline)、Scrapy引擎(Scrapy Engine)。下面我们分别介绍各个组件的作用。
(1)、调度器(Scheduler):
调度器，说白了把它假设成为一个URL（抓取网页的网址或者说是链接）的优先队列，由它来决定下一个要抓取的网址是 什么，同时去除重复的网址（不做无用功）。用户可以自己的需求定制调度器。
(2)、下载器(Downloader):
下载器，是所有组件中负担最大的，它用于高速地下载网络上的资源。Scrapy的下载器代码不会太复杂，但效率高，主要的原因是Scrapy下载器是建立在twisted这个高效的异步模型上的(其实整个框架都在建立在这个模型上的)。
(3)、 爬虫（Spider）:
爬虫，是用户最关心的部份。用户定制自己的爬虫(通过定制正则表达式等语法)，用于从特定的网页中提取自己需要的信息，即所谓的实体(Item)。 用户也可以从中提取出链接,让Scrapy继续抓取下一个页面。
(4)、 实体管道(Item Pipeline):
实体管道，用于处理爬虫(spider)提取的实体。主要的功能是持久化实体、验证实体的有效性、清除不需要的信息。
(5)、Scrapy引擎(Scrapy Engine):
Scrapy引擎是整个框架的核心.它用来控制调试器、下载器、爬虫。实际上，引擎相当于计算机的CPU,它控制着整个流程。
三、整体架构图 本图按顺序说明整个程序执行时候发生的顺序。
注意在调用下载器时，往往有一个下载器中间件，使下载速度提速。
官网架构图 四、Scrapy安装以及生成项目 新建一个项目，该项目的结构如下：
执行命令,widows和ubuntu命令格式是一样的：
下载方式
ubuntu，打开一个终端，输入pip install scrapy(或pip3 install scrapy）
widows ，打开一个cmd，输入pip install scrapy，前提是你装了pip
详细安装请点这
scrapy startproject 项目名
scrapy genspider 爬虫名 域名
scrapy crawl 爬虫名
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39e2ebe90b0ce2edb1fd339e18b82c05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44120a0a482512ce8373da1aaa56a9f2/" rel="bookmark">
			安装win2003 R2 SP2 x64 可用密钥
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在安装win2003时试了很多密钥都显示无效，以下密钥亲测有效！！！！！！！（标准版与企业版都可用）
MR78C-GF2CY-KC864-DTG74-VMT73
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f446190b8b99a27f0bcd5f54fdad0b1/" rel="bookmark">
			Java代码如何翻译成机器语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编程语言分为低级语言和高级语言，一种可以直接被计算机识别并执行，一种需要被编译成低级语言才可以被计算机识别并执行。
1、低级语言
机器语言和汇编语言，直接由计算机指令编写程序。
2、高级语言
C、C++、Java、Phtyon等，用语句编写程序，语句是计算机指令的抽象表示。
高级语言转为低级语言的过程就是编译。编译由编译器完成。
将便于人编写、阅读、维护的高级计算机语言所写作的源代码程序，翻译为计算机能解读、运行的低阶机器语言的程序的过程就是编译。负责这一过程的处理的工具叫做编译器。
反编译的过程与编译刚好相反，就是将已编译好的编程语言还原到未编译的状态，也就是找出程序语言的源代码。是将机器看得懂的语言转换成程序员可以看得懂语言。
Java语言中的反编译一般指将class文件转换成java文件。
javap并没有将字节码反编译成java文件，而是生成了一种我们可以看得懂字节码。其实javap生成的文件仍然是字节码，只是程序员可以稍微看得懂一些。
字节码并不是机器语言，要想让机器能够执行，还需要把字节码翻译成机器指令。这个过程是Java虚拟机(JVM)做的，这个过程也叫编译，是更深层次的编译。
Java中的前端编译
词法分析
词法分析阶段是编译过程的第一个阶段。这个阶段的任务是从左到右一个字符一个字符地读入源程序，将字符序列转换为标记（token）序列的过程。这里的标记是一个字符串，是构成源代码的最小单位。在这个过程中，词法分析器还会对标记进行分类。
词法分析器通常不会关心标记之间的关系（属于语法分析的范畴），举例来说：词法分析器能够将括号识别为标记，但并不保证括号是否匹配。
语法分析
语法分析的任务是在词法分析的基础上将单词序列组合成各类语法短语，如“程序”，“语句”，“表达式”等等.语法分析程序判断源程序在结构上是否正确.源程序的结构由上下文无关文法描述。
语义分析
语义分析是编译过程的一个逻辑阶段， 语义分析的任务是对结构上正确的源程序进行上下文有关性质的审查，进行类型审查。语义分析是审查源程序有无语义错误，为代码生成阶段收集类型信息。
语义分析的一个重要部分就是类型检查。比如很多语言要求数组下标必须为整数，如果使用浮点数作为下标，编译器就必须报错。再比如，很多语言允许某些类型转换，称为自动类型转换。
中间代码生成
在源程序的语法分析和语义分析完成之后，很多编译器生成一个明确的低级的或类机器语言的中间表示。该中间表示有两个重要的性质： 1.易于生成； 2.能够轻松地翻译为目标机器上的语言。
在Java中，javac执行的结果就是得到一个字节码，而这个字节码其实就是一种中间代码。
PS：著名的解语法糖操作，也是在javac中完成的。
Java中的后端编译
通常通过 javac 将程序源代码编译，转换成 java 字节码，JVM 通过解释字节码将其翻译成对应的机器指令，逐条读入，逐条解释翻译。很显然，经过解释执行，其执行速度必然会比可执行的二进制字节码程序慢很多。这就是传统的JVM的解释器（Interpreter）的功能。为了解决这种效率问题，引入了 JIT （即时编译）技术。
JAVA程序还是通过解释器进行解释执行，当JVM发现某个方法或代码块运行特别频繁的时候，就会认为这是“热点代码”（Hot Spot Code)。然后JIT会把部分“热点代码”翻译成本地机器相关的机器码，并进行优化，然后再把翻译后的机器码缓存起来，以备下次使用。
HotSpot虚拟机中内置了两个JIT编译器：Client Complier和Server Complier，分别用在客户端和服务端，目前主流的HotSpot虚拟机中默认是采用解释器与其中一个编译器直接配合的方式工作。
当 JVM 执行代码时，它并不立即开始编译代码。首先，如果这段代码本身在将来只会被执行一次，那么从本质上看，编译就是在浪费精力。因为将代码翻译成 java 字节码相对于编译这段代码并执行代码来说，要快很多。第二个原因是最优化，当 JVM 执行某一方法或遍历循环的次数越多，就会更加了解代码结构，那么 JVM 在编译代码的时候就做出相应的优化。
热点检测
目前主要的热点代码识别方式是热点探测（Hot Spot Detection），有以下两种：
1、基于采样的方式探测（Sample Based Hot Spot Detection) ：周期性检测各个线程的栈顶，发现某个方法经常出现在栈顶，就认为是热点方法。好处就是简单，缺点就是无法精确确认一个方法的热度。容易受线程阻塞或别的原因干扰热点探测。
2、基于计数器的热点探测（Counter Based Hot Spot Detection)。采用这种方法的虚拟机会为每个方法，甚至是代码块建立计数器，统计方法的执行次数，某个方法超过阀值就认为是热点方法，触发JIT编译。
在HotSpot虚拟机中使用的是第二种——基于计数器的热点探测方法，因此它为每个方法准备了两个计数器：方法调用计数器和回边计数器。
方法计数器。顾名思义，就是记录一个方法被调用次数的计数器。
回边计数器。是记录方法中的for或者while的运行次数的计数器。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f446190b8b99a27f0bcd5f54fdad0b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c28b25c09a487d5e404fcb2b43ee85dc/" rel="bookmark">
			C&#43;&#43;继承中的同名覆盖问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、同名覆盖的理论关键：
继承中同名覆盖问题的核心知识点：作用域问题，例子：
int a; void dosomething(){ double a; cin&gt;&gt;a; //使用double a } 现象：内层作用域会覆盖外层作用域的同名变量，而无论变量的类型。
原因：当编译器遇到a时，首先在local作用域查找该变量，找到则停止向外查找，而无论这个变量的类型，这就是C++名称遮掩规则。
2、C++继承中同名覆盖的情形介绍：
a) 一般继承例子：
//.h class Base{ private: int x; public: virtual void func1() = 0; virtual void func2(); } class Derived: public Base{ public: virtual void func1(); //纯虚函数重写后，这样才能实例化。 void func3(); } //.cpp void Derived::func3(){ func2(); } Derived继承了Base类，因此继承了Base类的接口与实现，因此可以调用func2()。
具体过程为：编译器在void Derived::func3()函数中遇到func2()，首先在该函数内找func2()的定义，接着在类Derived中查找，然后在基类Base中找到func2()，因此给人以派生类继承了基类接口的印象。
注：派生类赋值运算符函数实质是由于同名覆盖，然后在该函数内调用基类赋值运算符函数，利用作用域限定符修饰，令编译器到基类中查找。
b) 继承中覆盖例子：
//.h class Base{ private: int x; public: virtual void func1() = 0; virtual void func1(int); //两个func1构成重载 virtual void func2(); virtual void func2(int); //两个func2构成重载 void func3(); void func3(int); //两个func3构成重载 } class Derived: public Base{ public: virtual void func1(); //纯虚函数重写后，这样才能实例化。 void func3(int,int); //构成同名覆盖 } //.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c28b25c09a487d5e404fcb2b43ee85dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b64f8e6170991afaba93eda15ee7d93/" rel="bookmark">
			基于JT808-2019,JT809-2019,JT1078与苏标主动安全协议的部标平台开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 开发一个可靠的支持视频与Adas的部标平台并不是那么容易，需要从网关，流媒体到应用平台架构再到前端界面友好性的交互，可能需要很多工程师历时好几个月。
下面是根据几个方面分别对整个部标平台进行简单介绍。
网关： 之前的blog也写了很多关于网关方面的介绍，这里多说一下，网关采用的是目前流行的SpringBoot+Netty+RabbitMQ做为整个网关框架。
为什么我们选择Netty框架，其实我这里说的都是多余的。
Netty有很多的优势：
（1）高并发：Netty是一款基于NIO（Nonblocking I/O，非阻塞IO）开发的网络通信框架。
（2）传输快：零拷贝，这也是NIO的一个特性。
（3）易用性：封装的API使用很方便，不需要有很深的Java技能即可使用与维护
（4）协议支持：HTTP、Protobuf、二进制、文本、WebSocket 等一系列常见协议都支持。还支持通过实行编码解码逻辑来实现自定义协议。
使用RabbitMQ作为消息中间件，网关收到设备原始数据进行解析，根据不同的数据内容，通过特定的路由发送给RabbitMQ。RabbitMQ收到数据后将信息分发给不同的消费者程序使用。一般来说，一个简单的部标平台可以使用平台后台作为数据消费者，然后处理这些数据并及时通知前端界面进行数据展示即可。如果平台车辆特别多需要考虑到多节点部署后台服务，利用负载均衡进行集群的话，我们在设计的时候这里引入了一个单独的消费者程序，利用这个单独的消费者对RabbitMQ里面的数据进行业务处理，将最近的轨迹信息存储到Redis进行缓存。如果需要对消费者做集群的话，只需要处理好数据不被重复消费。
目前我们开发的JT808协议网关，单点1.2万接入，每秒处理3000条数据的并发量通过测试，详情见https://blog.csdn.net/qq_17486399/article/details/104518593
1078流媒体服务器： 流媒体服务器是车载视频监控的重中之重，一个稳定可靠的流媒体服务器的开发并不是那么简单。
网上也有很多开源的流媒体服务，不过车载视频设备是无法直接使用这些开源的流媒体服务的，因为车载视频机传输视频流的时候是加了包头包尾的，需要做些处理转成常规的H.264的音视频流才行。
虽然说着简单，但是实施起来并不容易，需要认真解读JT1078协议，然后抓取设备传过来的音视频流做解析，得慢慢摸索。
并且做视频监控的设备厂商如此之多，虽然视频流都是用的H.264，但是音频却各种各样的都有，如果想把JT1078协议上面那些音频格式全部集成还是很费时间的，关键我们也没有那么多音频数据样本供我们做分析。
目前市面上的音频格式主要也就这几种：AAC，ADPCMA，G.711A，所以不需要将1078协议上的所有音频全部做完，除非你有这个功夫，而且不一定能找到那么多音频格式的设备进行测试。
传给前端的视频流目前大家用到的是hls与flv，不过如果需要过检，需要用到flv,毕竟hls延迟还是要高些。
流媒体开发最好还是使用C/C++，像java，C#尽量不要考虑了，性能达不到，而且音视频处理也没有很好的开发包供我们使用。另外也有人使用go与Erlang，不过相关技术人员不多，后期维护比较麻烦。
应用平台： 整个平台与网关数据流的传递可以参考：https://blog.csdn.net/qq_17486399/article/details/104373406
流媒体服务在整个架构中都是独立的一部分，给设备下发播放指令的时候指定对应的流媒体的IP与端口即可。
视频播放器开发最好使用纯js来做，网上开源的也有很多，不要使用flash内核的播放器了，毕竟谷歌浏览器已经抛弃了flash，而且每次播放视频时候还需要用户开启flash相关权限才行，体验很差。
效果展示： 有志同道合的朋友可以联系QQ：571521973
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf848fcad0750110a8aa9cb138de718f/" rel="bookmark">
			c&#43;&#43; 编写一个递归函数，将输入的整数按照它的逆序输出，如输入12345，输出54321
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 编写一个递归函数，将输入的整数按照它的逆序输出，如输入12345，输出54321
#include&lt;iostream&gt; using namespace std; void print(int a) { if(!a) { return; } cout&lt;&lt;a%10; print(a/10); } int main() { int n; cin&gt;&gt;n; print(n); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bccf17eed29dbe7c398431139bd59405/" rel="bookmark">
			TCP中回传了SYN信号为什么还要传ACK？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TCP是可靠连接，双方都要确保发送的信息是可靠的、准确无误的。
回传了SYN只是证明服务器收到的确实是客户端发送的信号，但是服务器到客户端之间的通道还需要ACK信号来保证信息的准确无误。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c40b41e87b426a2a22a42f2561216e8b/" rel="bookmark">
			C程序--在字符串中删除与某字符相同的字符（数组形式）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 思想：1、建立一个数组存字符串 如 aabbcc
2、拿出第一个字母与后面字母依次比较，若不同则什么也不做；
若相同，则除第一个字母之外，后面字母依次往前移动一个字母位置，将第二个a覆盖到
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define N 80 void DeleteSame(char a[]); int main() { char a[N]; printf("please input string : "); gets(a); DeleteSame(a); return 0; } void DeleteSame(char a[]) { int i ,j ,k; for(i = 0; a[i] != '\0'; i++) { for(j = i+1 ; a[j] != '\0' ; j++ ) { if(a[i] != a[j]) ; else { for(k = j; a[k] != '\0' ; k++) a[k] = a[k+1]; } } } a[i] = '\0'; puts(a); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d61f4e4dc4ffc921fa7d2c88064ad192/" rel="bookmark">
			ERROR:无法加载JAVA虚拟机的问题完美解决--SAS 9.4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		按照这篇博文SAS9.3无法加载JAVA虚拟机的问题完美解决
逐步检查。
我操作了几步：
1、找到我电脑上的Java所在。C:\Program Files\Java\jre1.8.0_151\bin
2、打开“D:\Program Files\SASHome\sassw” ，替换为自己的Java路径， JREHOME=C:\Program Files\Java\jre1.8.0_151\bin\java.exe；
PRIVATEJREHOME=C:\Program Files\Java\jre1.8.0_151\bin\java.exe
3、到SAS安装目录下打开“D:\Program Files\SASHome\SASFoundation\9.4\nls\en\sasv9”
-Dsas.jre.libjvm=C:\Program Files\Java\jre1.8.0_151\bin、client\jvm.dll
黑体部分替换为自己的Java，保存重新打开SAS软件，就OK了。
运行一个
proc reg；
model y=x;
run;
就不报错了且能出来下面这种图了
参考资料：http://www.cdadata.com/8608
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb9e4e721b446732c092894d6808ef91/" rel="bookmark">
			【贪心算法C&#43;&#43;】---整数区间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：
请编程完成以下任务：
1.从文件中读取闭区间的个数及它们的描述；
2.找到一个含元素个数最少的集合,使得对于每一个区间,都至少有一个整数属于该集合，输出该集合的元素个数。
【输入】
首行包括区间的数目n,1≤n≤10000,接下来的n行,每行包括两个整数a,b,被一空格隔开,0≤a≤b≤10000,它们是某一个区间的开始值和结束值。
【输出】
第一行集合元素的个数,对于每一个区间都至少有一个整数属于该区间,且集合所包含元素数目最少。
【输入样例】
4
3 6
2 4
0 2
4 7
【输出样例】
2
思路：
这个题可以理解为，几个区间能相交在一起有公共元素的就放到一个组里，找出有几个组。
那我们可以按照左区间从小到大排序，找一个区间为参照区间，只要下一个区间的左区间大于等于参照区间的做区间，小于等于参照区间的有区间，就说明符合，比较下一个
当找到一个不符合的区间时候，将参照区间换成这个符合的区间，并且组数加一
上代码：
#include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; using namespace std; struct game { int start; int theEnd; } member[10001]; int cmp(game a,game b) { return a.start&lt;b.start; } int main() { int n; cin&gt;&gt;n; for(int i=0; i&lt;n; i++) cin&gt;&gt;member[i].start&gt;&gt;member[i].theEnd; sort(member,member+n,cmp); int cnt = 1; int flag = 0; for(int i=1;i&lt;n;i++) { if(member[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb9e4e721b446732c092894d6808ef91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac1c89e8a2ed1e984c2645ba04bbb844/" rel="bookmark">
			1.WebService
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一.WebService应用场景二.WebService的两个规范jax-wsjax-rs 三.WebService入门案例（jax-ws）1.创建服务提供者模块（转成web工程）1.1 引入依赖1.2 配置web.xml1.3 配置applicationContext-cxf-server.xml1.4 编写service以及impl配置tomcat访问 2.创建服务调用这模块2.1 使用jdk下面的wsimport.exe进行代码生成2.2 实现步骤2.3 配置文件2.4编写测试类 四.WebService入门案例（jax-rs）1.创建服务提供者模块1.1引入依赖1.2web.xml1.3applicationContext-cxf.xml1.4 写domain和service 2.创建服务调用者模块2.1 引入依赖2.2 根据提供者编写实体类2.3 编写测试类 五.总结 一.WebService应用场景 跨互联网调用：通过WebService可以跨互联网调用其他程序跨语言：不同语言之间也可以通过WebService进行调用集成多应用：一个企业里使用了多个软件，比如：财务系统，和咱们的SaaS-Export对接多程序复用：多个系统中都有用户，那么只需要一个用户就可以了，登录之后，通过调用WebService也同时登录 二.WebService的两个规范 jax-ws 访问路径例如：http://localhost:8034/ws/weather?wsdl
ws:为代码中加密的路径，weather为访问路径
soap：传输协议wsdl：说明书，xml格式存储的，不是给人看的给机器看的uddi：目录（包含所有可以调用的WebService方法） jax-rs rest风格调用CXF：磁悬浮 三.WebService入门案例（jax-ws） 1.创建服务提供者模块（转成web工程） 1.1 引入依赖 1.2 配置web.xml &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" version="2.5"&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; //配置文件的路径 &lt;param-value&gt;classpath:applicationContext-cxf-server.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- CXF框架的核心控制器:CXFServlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;cxf&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.cxf.transport.servlet.CXFServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;cxf&lt;/servlet-name&gt; &lt;!--前台页面访问时 ws的才可以访问--&gt; &lt;url-pattern&gt;/ws/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 1.3 配置applicationContext-cxf-server.xml &lt;?xml version="1.0" encoding="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac1c89e8a2ed1e984c2645ba04bbb844/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/196ca3f1c7283dfa418c18518f0976bf/" rel="bookmark">
			用MATLAB 2018b的simscape对倒立摆进行仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标题MATLAB学习笔记（一）：倒立摆的Simscape建模与仿真 在simscape里对倒立摆进行物理建模倒立摆的分析和控制器的设计控制器的建模与仿真仿真结果资料与参考 一.在simscape里对倒立摆进行物理建模 1.打开MATLAB软件，在命令窗口输入smnew进入simscape仿真环境
这个就是simscape的环境了
2.打开library browser，找到里面的simscape
我们可以从里面吧我们需要的模块都先放上面的仿真环境
从joints里面找到旋转副和滑动副（待用）
1.下一步我们先对小车、滑轨、摆杆进行搭建（这一步的难点在模型的坐标变换关系，各位小伙伴们可以在这之前好好去研究一下，因为这个一下也说不清楚） 1.小车
这里一定要注意坐标模块B,F的连接关系,下图是参数设置
2.摆杆（这个和小车的步骤一样，只是参数设置不一样）
L,W,H这里我用的是蒙版功能你们可以去了解一下（mask）
L=0.5,W=H=0.05
3.滑轨可以不要（这个你们就自己去探索了，这个对仿真没有影响只是看起来好看而已）
2.接下来我们就将小车和摆杆通过旋转副和旋转副连接起来 连接好了以后整体效果是这样
参数汇总
还有那个PS-Simulink模块的参数这个很关键，我当时就是在这里搞了好久
涉及到时间的函数信号，大家可以这样设置
到此物理模型就建完啦！！！
二.控制器的建模与仿真 接下来我们就给我们的物理模型添加控制器
对于一阶倒立摆其控制方法有很多，经典控制（传递函数）、现代控制理论（状态空间方程）等等都可以建立很好的控制模型，我们这里是直接用PD控制器对其进行控制实现。
三.仿真结果 如果上面搭建的没有问题的话，就可以进行仿真了
四.资料与参考 1.simscape入门
2.用Simscape实现三维物理仿真（四）——用PID控制倒立摆系统
3.Advanced控制理论】8.5_线性控制器设计_轨迹跟踪(Follow a Desired Path)
4.使用Simscape仿真单摆和双摆
5.Simscape Multibody —— Revolute Joint的使用6.Simscape/Multibody/Frames and Transforms坐标系使用详解
五.总结和感谢 倒立摆是小伙伴们学习控制的一个很好的练手模型，希望大家和我多多交流我们一起学习。后期我打算尝试一下其他的控制方法。
在此也要感谢以上参考资料博主们的付出，也请大家多多关注，如有问题或者更好的仿真方法也请您和我交流，我有时间一定第一时间回复您！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8916ec3548dd6607229d225dbf49d149/" rel="bookmark">
			华为模拟器ensp&amp;桥接时cloud虚拟网卡问题✍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果打开绑定信息 如下图并没有虚拟机网卡对应的信息
则需要进行对winpacp 这个软件进行卸载重装即可
winpcap关键模块 32位系统： C:\Windows\system32\wpcap.dll C:\Windows\system32\Packet.dll C:\Windows\system32\WanPacket.dll C:\Windows\system32\pthreadVC.dll C:\Windows\system32\drivers\npf.sys 64位系统： C:\Windows\SysWOW64\wpcap.dll C:\Windows\SysWOW64\Packet.dll C:\Windows\SysWOW64\WanPacket.dll C:\Windows\SysWOW64\pthreadVC.dll C:\Windows\System32\drivers\npf.sys 完全卸载winpcap的方法：
1.使用winpcap安装目录下自带的uninstall.exe卸载
2.查找winpcap的关键模块，手动删除
若删除遇到问题，采用以下方法处理，以Packet.dll为例： 使用tasklist /m packet.dll查看占用该模块的进程信息
终止进程和进程转到的相关服务
但是使用第一种方法 一般再重新安装的过程中会有问题
所以推荐第二种办法
把上述的所有关键模块删除掉 在进行重新安装；
我在删除过程中，使用一个比较好用的小工具 everything
erverything 安装包链接 链接：https://pan.baidu.com/s/1y6TIjgVBalzQ-GghTqeJYw 提取码：ezxm winpacp 安装包链接 链接：https://pan.baidu.com/s/1T9AF_EaBuz1P2RmZNN-mHQ 提取码：nyvg 安装步骤：
再次打开ENSP 查看cloud 状态：
桥接网卡的时候就可以选择网段内的绑定信息了 正常解决！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49c432f48c0d02aaaf85cd8d78575c39/" rel="bookmark">
			web自动化测试绕过cookie实现登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# 不输入用户名和密码，获取cookie实现登录 # 登录成功后，cookies里面会保存sessionid # 将该sessionid添加到driver里面 # 注意： 1.selenium启动某个浏览器时，它启动的是一个全新的浏览器 # 没有带任何cookie，需要程序加载这些cookie # 2.必须首先加载网站，这样Selenium 才能知道cookie 属于哪个网站，即使加载网站的行为对我们没任何用处 # 3.退出或者注销登录，sessionid失效，下次访问生成新的sessionid # 方法一 手动获取sessionid import time from selenium import webdriver driver = webdriver.Chrome() driver.get('http://127.0.0.1:8000') # 先加载网站 driver.maximize_window() driver.add_cookie({'name': 'sessionid', 'value': '5u8jziskb2065vssla8ea5s7yvh2ucag'}) driver.get('http://127.0.0.1:8000') driver.refresh() time.sleep(5) driver.quit() # 方法二 代码自动获取cookie driver1 = webdriver.Chrome() driver1.maximize_window() driver1.get('http://127.0.0.1:8000/api-auth/login/?next=/') driver1.find_element_by_id('id_username').send_keys('admin') driver1.find_element_by_id('id_password').send_keys('123') driver1.find_element_by_id('submit-id-submit').click() time.sleep(2) save_cookie = driver1.get_cookies() # 列表里面有两个字典cookie信息，一个是登录之前的，一个是登录之后的 print(save_cookie) driver1.quit() driver2 = webdriver.Chrome() driver2.maximize_window() # 必须首先加载网站，这样selenium才知道cookie是属于哪个网站的 driver2.get('http://127.0.0.1:8000/api-auth/login/?next=/') print(driver2.get_cookies()) driver2.delete_all_cookies() # 一旦加载网站，即使没登录，也会产生一个cookie，需要删除cookie for cookie in save_cookie: driver2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49c432f48c0d02aaaf85cd8d78575c39/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/248/">«</a>
	<span class="pagination__item pagination__item--current">249/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/250/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>