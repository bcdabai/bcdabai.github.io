<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bdb3ec431705beefc15962e01b7adf9/" rel="bookmark">
			OCI runtime exec failed: exec failed: container_linux.go:349: starting container 解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		docker执行命令:docker exec -it redis1 /bin/bash
在进入容器报错:OCI runtime exec failed: exec failed: container_linux.go:349: starting container process caused “exec: “/bin/bash”: stat /bin/bash: no such file or directory”: unknown
报错场景:我是pull了一个redis镜像，准备搭建私有库。运行了redis镜像，然后进入容器产生的错误
解决办法:
docker exec -it redis1 /bin/sh
or
docker exec -it redis1 bash
or
docker exec -it redis1 sh
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08183fa54d9c9ee036c18f6f8011689b/" rel="bookmark">
			前端,JS排序,正序逆序,基数排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		排序算法很多，这里选用基数排序，不同的是考虑到之后扩展特殊字符,中文等在此多定义一个基数池。 var result = []; var type = true; function sort(array , column , i) { let data = {}; data['0']='';data['1']='';data['2']='';data['3']='';data['4']='';data['5']='';data['6']='';data['7']='';data['8']=''; data['9']='';data['a']='';data['b']='';data['c']='';data['d']='';data['e']='';data['f']='';data['g']='';data['h']=''; data['i']='';data['j']='';data['k']='';data['l']='';data['m']='';data['n']='';data['o']='';data['p']='';data['q']=''; data['r']='';data['s']='';data['t']='';data['u']='';data['v']='';data['w']='';data['x']='';data['y']='';data['z']=''; data['A']='';data['B']='';data['C']='';data['D']='';data['E']='';data['F']='';data['G']='';data['H']='';data['I']=''; data['J']='';data['K']='';data['L']='';data['M']='';data['N']='';data['O']='';data['P']='';data['Q']='';data['R']=''; data['S']='';data['T']='';data['U']='';data['V']='';data['W']='';data['X']='';data['Y']='';data['Z']=''; array.forEach(function (obj) { if (!data[obj[column].charAt(i)]) data[obj[column].charAt(i)] = [obj]; else data[obj[column].charAt(i)].push(obj); }); let recursion=[]; for (let key in data){ if (!data[key]){ delete data[key]; continue; } if (data[key].length &gt; 1){ if ( !(!data[key].some(function (value, index) { return value[column] !== data[key][0][column]; }))){ recursion.push(key); } } } if (recursion.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08183fa54d9c9ee036c18f6f8011689b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a95b6b35c5a137058785d40f48daedd/" rel="bookmark">
			哈希函数的构造和处理冲突的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		哈希函数的构造 常用的哈希函数的构造方法有 6 种：直接定址法、数字分析法、平方取中法、折叠法、除留余数法和随机数法。
直接定址法：其哈希函数为一次函数，即以下两种形式： H（key）= key 或者 H（key）=a * key + b
其中 H（key）表示关键字为 key 对应的哈希地址，a 和 b 都为常数。
例如有一个从 1 岁到 100 岁的人口数字统计表，如表 1 所示：
表 1 人口统计表
假设其哈希函数为第一种形式，其关键字的值表示最终的存储位置。若需要查找年龄为 25 岁的人口数量，将年龄 25 带入哈 希函数中，直接求得其对应的哈希地址为 25（求得的哈希地址表示该记录的位置在查找表的第 25 位）。
数字分析法:如果关键字由多位字符或者数字组成，就可以考虑抽取其中的 2 位或者多位作为该关键字对应的哈希地址，在取法上尽量选择变化较多的位，避免冲突发生。 例如表 2 中列举的是一部分关键字，每个关键字都是有 8 位十进制数组成：
表 2
通过分析关键字的构成，很明显可以看到关键字的第 1 位和第 2 位都是固定不变的，而第 3 位不是数字 3 就是 4，最后一位只可能取 2、7 和 5，只有中间的 4 位其取值近似随机，所以为了避免冲突，可以从 4 位中任意选取 2 位作为其哈希地址。
平方取中法是对关键字做平方操作，取中间得几位作为哈希地址。此方法也是比较常用的构造哈希函数的方法 例如关键字序列为{421，423，436}，对各个关键字进行平方后的结果为{177241，178929，190096}，则可以取中间的两位{72，89，00}作为其哈希地址。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a95b6b35c5a137058785d40f48daedd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cca9c1a25ac58de9218c6a21f3774595/" rel="bookmark">
			多线程的例子 对int类型进行操作 开启十个线程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上代码
public class TestAtomicInteger { static int i = 0 ; //error! public static void main(String[] args) throws Exception{ Thread[] ts = new Thread[10]; for(int k = 0 ; k&lt;ts.length ; k++){ ts[k] = new Thread(new Runnable(){ public void run() { for (int k = 1; k &lt;= 10000; k++) { i++; } } }); ts[k].start(); } for(int k=0; k &lt;ts.length ; k++){ ts[k].join(); } System.out.println(i); } } 执行结果
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cca9c1a25ac58de9218c6a21f3774595/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aeb9dd34228a061a05ff39de84c9ce98/" rel="bookmark">
			机器学习入门以及Linear regression(线性回归)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线性回归几乎是所有机器学习的入门课程，但是由于符号定义表达方式不同，造成了很多人在入门时期感觉跟多向量非常矛盾。比如所行向量还是列向量， x i \textbf{x}_i xi​以及 x j \textbf{x}_j xj​究竟是行还是列等等，本篇将先介绍向量以及列表相关的例子，然后再介绍线性回归的内容。
入门解惑 对于大多数教程而言，一份统计表的形式往往如下所示:
示例1：
示例1为默认格式，也是大多数博客或文章采用的格式。
属性1属性2属性3属性4…元组1元组2元组3元组i…………… 采用向量描述:
属性1属性2属性3属性4…元组i x i 1 x_{i1} xi1​ x i 2 x_{i2} xi2​ x i 3 x_{i3} xi3​ x i 4 x_{i4} xi4​… x i \textbf{x}_i xi​代表行，但是并不能单纯地认为代表行的就是行向量，实际上大多数书籍或博客中默认都是列向量，如果有定义最好看清楚定义。
形如 x i = ( x i 1 , x i 2 , x i 3 , x i 4 , . . . x i n ) T \textbf{x}_i=(x_{i1},x_{i2},x_{i3},x_{i4},.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aeb9dd34228a061a05ff39de84c9ce98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84b6e6a4d2a8ca4d8c11133a5f6d0a20/" rel="bookmark">
			fsevents@1.2.13: fsevents 1 will break on node v14&#43; and could be using insecure binaries. Upgrade to
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		呵呵最近学three.js，踩了很多坑，本着不想麻烦老同学，自己百度的想法
我就开始学习，第一步就是要我搭建nodejs本地服务器，我输入npm install -g live-server，
第一步就卡住，没太看懂怎么回事，在网上逛了一圈，说文件权限不够，我就把nodejs，第一第二权限完全控制
万万妹想到，又tm卡住了，卡住害不报错，非得我ctrl c，npm WARN deprecated fsevents@1.2.13: fsevents 1 will break on node v14+ and could be using insecure binaries. Upgrade to fsevents 2.npm install fsevents
就这就这就这就这，单独安装一下，npm install fsevents，报错notsup，应该是不支持的以上，网上说这个包是darwin系统用的
那我用的是windows肯定不对，所以要修改nodejs\node_modules\npm\packag.json，用DW打开了，幸好学了一半java的基础，会看一点，找了半天，没有optionalDependencies，最后在中间加了这一段代码，意思是把fsevents安装变成可选的
"optionalDependencies": { "fsevents": "*" }, 果然重新安装就跳过辣，，，，太无语了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d3285d467b081cb1c4be134f668db7b/" rel="bookmark">
			13.4-“制作一款私有IAP串口下载小工具”之STM32的Bootloader设计说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、原理简要说明 从上一章可知，IAP更新程序的原理，就是在单片机flash中的划分出两个区域，分别叫做Bootloader区域和一个App区域。芯片上电启动的时候，会默认运行Bootloader，然后bootloader来做逻辑判断，bootloader会等待5s左右，如果在5s之内收到需要更新固件的命令，则进行固件更新，否则的话，判断芯片中是否已经有之前的可用app。如果有，跳转过去执行app。否则的话继续保持在“等待固件下载模式”。这就是bootloader的大概原理。
二、Bootloader逻辑说明 第一节简介重复了一次IAP烧写固件的原理。这节使用一个流程图来详细准确的描述一下，IAP的相关判断逻辑。如，下图所示：
三、编译生成的bin文件和hex文件，都可以使用IAP“烧录”到芯片中吗？ 什么是Bin文件
Bin文件是最纯粹的二进制机器代码, 是由C或C++编译成汇编，然后从汇编转换生成的二进制机器码。因此Bin文件就是芯片可以直接运行的程序。
什么是Hex文件
全称为“INTEL HEX”，HEX文件是一个ASCII文本文件，文件中放满了一行一行的“Intel HEX格式”的标记文本。每一行包含一个HEX记录。记录是由多个代表机器码或常量数据的16进制数组成。HEX常用来储存要烧写到ROM或EPROM中的程序。大多数的烧写器支持HEX格式。（注意HEX文件包含程序要被下载到芯片中的具体位置）
以上简介，翻译自“arm KEIL”对HEX格式的介绍。参考地址：http://www.keil.com/support/docs/1584/
Bin文件与Hex文件的区别
直接把Bin文件传输并烧写到芯片Flash即可运行。但HEX文件不行，HEX是一个文本文件，里面用标记符号记录程序的详情。方便阅读（二进制查看器和烧写器对被烧写程序的预览查看，就是用的HEX格式。如果用二进制显示，那么你看到的是大量的0101）并且可以包含除“程序”之外的额外信息。一般“下载器”可以使用Hex文件编程，其实是“下载器”对Hex文件做了解析，最终还是转换为Bin文件的格式，然后烧写到了芯片的Flash中。
“下载器”使用Hex文件的原因是，Hex文件包含“程序”之外的信息，比如“程序烧写地址”。这样就避免了让用户手工输入这些额外的信息。当你用“下载器”下载Bin文件的时候，下载软件有个“烧写地址”的输入框，就是要你指定要把这个bin文件下载到芯片的哪个Flash地址。（因为bin文件本身不包含这个信息）。
使用IAP下载固件，使用Bin还是Hex文件
结合IAP的原理和以上的分析可知，IAP需要一种直接传递到芯片即可运行的“程序”，因此要实现IAP下载你只能选择Bin文件格式。
四、怎样完成“烧写固件”的工作（Flash操作） “把程序烧写（下载）到芯片中”，从始至终都感觉这是一个很“神奇”的事情。现在终于明白了“烧写”程序到底怎么一回事了。原来，本质上就是把“BIN文件”复制粘贴到芯片Flash的指定地址中。也就是说，你只要实现对芯片的内部Flash读写函数。你就可以实现“烧写程序”了。
对STM32芯片内部Flash的介绍
（中文版）STM32根据FLASH主存储块容量、页面的不同，系统存储器的不同，可以分为以下几个类别。
小容量产品主存储块1-32KB，每页1KB。系统存储器2KB。
中容量产品主存储块64-128KB，每页1KB。系统存储器2KB。
大容量产品主存储块256KB以上，每页2KB。系统存储器2KB。
互联型产品主存储块256KB以上，每页2KB。系统存储器18KB。
（英文版）STM32有4种Flash module organization，分别是：
low-density devices(32KB，1KB/page)、
medium-density devices(128KB，1KB/page)、
high-density devices(512KB，2KB/page)、
connectivity line devices(256KB，2KB/page)、
XL-density(devices(1M，2KB/page)。
本小段的编写的目的是要提醒你，每个STM芯片的Flash是不一样的，你需要根据你的目标芯片来确定具体的读写参数。比如，不同芯片的Flash最小”写单元大小“不同。即，有的芯片Flash一次性最小可以写”一个字=4byte“，有的芯片Flash最小可以写入”两个字=8byte“。因此，再开发Flash读写编程之前，一定要详细阅读芯片手册。确定你所使用芯片的Flash操作要求。
写flash时为什么需要先擦除？
因为Flash的编程原理都是只能将1写为0，而不能将0写为1，所以在进行Flash编程之前，必须将对应的块擦除，而擦除的过程就是把所有位都写为1的过程，块内的所有字节变为0xFF。
操作Flash需要用都的函数说明
注意，不同的芯片对应的Hal库函数是不同的，但是是相近的。这里以”STM32L072KBUx“来举例说明：
3.1. Hal库的擦除Flash函数
HAL_StatusTypeDef HAL_FLASHEx_Erase(FLASH_EraseInitTypeDef *pEraseInit, uint32_t *PageError) 注意HAL还提供另一个Flash擦除函数”FLASH_PageErase“，但是如果擦除完要用于下载程序，必须用”HAL_FLASHEx_Erase“。
3.2. Hal库写Flash函数
注意：FLASH的写入地址必须是偶数（FLASH机制决定的FLASH写入的时候只能是偶数地址写入，必须写入半字或字，也就是2个字节或是4字节的内容）
HAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram, uint32_t Address, uint32_t Data) HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD, Addr, Buff);//32bit 使用实例 3.3. 读Flash函数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d3285d467b081cb1c4be134f668db7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1251cc705bd5fcb4d051a2ef856c1497/" rel="bookmark">
			13.3-“制作一款私有IAP串口下载小工具”之上位机软件设计说明（包含源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、原理简要说明 实现IAP下载，本质上相当于把单片机编程软件编译生成的bin文件，传递到“单片机的Flash”中。而在传递的过程中可以使用任何数据传输通道，比如：串口，蓝牙，网络等。而传输bin文件的协议可以采用一些标准的格式，也可以完全自定义一个协议。总之，只要满足把bin文件传输到单片机的Flash即可。本文所描述的传递方式采用：串口+私有协议。
二、上位机IAP下载工具的功能设计 bin文件选择框和选择按钮
用于从电脑磁盘上选择一个要传输到单片机的bin文件。串口通信以及协议实现
用于和下位机单片机中的bootloader建立串口通信，并依据设计好的协议，完成bin文件的传递。下载状态提示与进度条显示
为了给用户反馈下载进度与状态，特意给软件设计了“进度条”和“状态提示栏”使用唯一的一个”下载“按钮，完成“查找设备”和“bin文件下载”
使用唯一的一个“下载”按钮，去掉了串口端口、波特率等的参数选择。实现了“自动查找串口设备”功能和“下载过程完全自动化”。提高下载效率的同时，简化用户的学习软件的负担。 三、小工具的“原型图”设计 四、软件结构设计与设计思想 在编写一个软件的时候，一定要先设计“模块组成”与“关键数据结构”。并不是直接上手就写代码。直接上手写的情况是在测试某个功能的情况下。比如测试串口通信、测试按钮逻辑、测试波形显示等。
模块化设计的作用是各个模块之间互不影响。以后修改其中一个模块的代码。并不会影响其他模块的正常使用。其次写好的功能模块还可以单独拿出来直接给其他项目使用。比如，写一个串口通信模块，一个网络通信模块。模块完全独立于软件，甚至可以把这些模块单独编译成独立的库（dll/so）。软件只需要通过库的头文件调用库的功能即可。编译成库的另一个好处是，库的代码不用每次和应用程序的源码一起编译，从而加快开发时候代码的编译速度。
开发本小工具，用到的模块如下：
串口通信模块通信构架模块查找设备模块读取bin文件模块主程序模块 五、通信模块设计与通信构架说明 通信构架采用“3.1，3.2，3.3章节”所描述的框架。
六、查找串口设备的原理与代码设计 查找设备的基本原理
上位机软件获取当前电脑上的所有串口设备名称，并储存到一个List数据结构中。编程依次打开list列表中的串口设备，并使用定义好的“握手”协议，依次给串口设备发送“握手”命令。如果某个串口设备能正确的回复这个握手命令。说明这个串口设备就是我们要找的串口设备。对于我们现在的使用场景中，只能同时给一个串口设备下载固件。因此，在接收到多个串口设备返回来的握手命令后。只挑选第一个串口设备，作为目标设备。
实际编程实现方法（设计思想）
给所有查找出的串口设备new一个对象，把这些对象的串口接收回调函数都指向同一个函数。并调用这些对象的“通信参数设置函数”，
“打开函数”，“发送函数并发送握手数据包“。在接收回调函数处等待，看那个设备给回复了数据，并且回复的数据满足握手协议。那么这个就是要查找的设备（只保留第一个设备）。使用signal 把找到的设备信息返回给调用者。技术实现上注意；要在串口回调函数中，返回设备识别信息否则不知道是哪个设备给回复的消息。
测试了实现查找串口设备的很多方法，最终测试发现这种实现方式，可用，稳定，好用。
七、读取bin文件的原理模块设计 使用Qt的二进制文件读写类直接去读即可，使用到的函数如下：
QFile file_; QDataStream out_; file_.setFileName(full_path); //设置要打开的文件绝对路径 file_.open(QIODevice::ReadWrite); //打开文件 file_.seek(pos); //指定操作文件的新的位置 file_.size(); //获取文件的大小 file_.flush(); //把缓存的内容写入到实际文件 file_.close(); //关闭文件 file_.isOpen(); //文件是否被打开 out_.setDevice(&amp;file_); //设置要操作哪个文件 out_.writeRawData(data.data(), data.length()); //写二进制数据 out_.readRawData(data, len); //读二进制数据 八、获取源码与源码目录说明 软件实现并不复杂，想了解实现细节的话，直接阅读源码吧！
点此获取源码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3eb947f08c34e721ef5f2c49ceea545/" rel="bookmark">
			电子科技大学现代电子信息系统综合实验课程单片机练习题代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接上一篇博客https://blog.csdn.net/Jinyindao243052/article/details/107822771
除了实现练习题的功能，我自己还写了一些函数，实践证明在考试中用得到！
#include &lt;reg51.h&gt; #include &lt;absacc.h&gt; #include &lt;ctype.h&gt; //数码管的引脚 sbit led0=P0^0; sbit led1=P0^1; sbit led2=P0^2; sbit led3=P0^3; sbit led4=P0^4; sbit led5=P0^5; sbit led6=P0^6; sbit led7=P0^7; //定义按键 sbit KEY2 = P2^0;	//按键1 sbit KEY3 = P2^1;	//按键2 unsigned char key; unsigned char DispBuf[8]; unsigned char s_led[8]={1,1,1,1,1,1,1,1};//led显示控制:s_led[0]对应最右边的数码管 unsigned char s_dat[8]={1,1,1,0,0,1,1,1};//数码管显示控制：s_dat[0]对应最右边的数码管 unsigned char d[8]={1,1,1,15,14,1,1,1};//数据：d[0]对应最右边的数码管 code unsigned char Tab[] =	{//定义0123456789AbCdEF的数码管字型数据 0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07, 0x7F,0x6F,0x77,0x7C,0x39,0x5E,0x79,0x71 }; /* 函数：KeyScan() 功能：键盘扫描 返回：扫描到的键值 */ unsigned char KeyScan() { unsigned char k = '\0'; if ( KEY2 == 0 ) k = 'A'; if ( KEY3== 0 ) k = 'B'; return k; } //定义显示缓冲区（由定时中断程序自动扫描） unsigned char DispBuf[8]; /* 函数：T1INTSVC() 功能：定时器T1的中断服务函数，扫描数码管 */ void T1INTSVC() interrupt 3 { code unsigned char com[] = {0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80}; static unsigned char n = 0; TR1 = 0; TH1 = 0xFC; TL1 = 0x66; TR1 = 1; XBYTE[0x7800] = 0xFF;	//暂停显示 XBYTE[0x7801] = ~DispBuf[n];	//更新扫描数据 XBYTE[0x7800] = ~com[n];	//重新显示 n++; n &amp;= 0x07; } /* 函数：DispClear() 功能：清除DispBuf */ void DispClear() { unsigned char i; for ( i=0; i&lt;8; i++ ) { DispBuf[i] = 0x00; } } //延时函数 void delay(unsigned int t) { do { TH0 = 0xFA; TL0 = 0x24;	//设置定时器初值（对应0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3eb947f08c34e721ef5f2c49ceea545/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ae710811b6b53a49b8375b103d8549b/" rel="bookmark">
			VBA 单元格基本操作 - 值的判断
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		继续讲讲单元格的操作
一、提示用户输入值
Sub SetValue() Sheets("sheet3").Range("a1") = InputBox("输入一个数字") End Sub 运行后就会弹出个警告框，提示用户输入内容，输入后就会在A1单元格显示了，但是也存在一个问题，就是取消后呢，原来在A1单元格的内容就会被清空。
所以改良一下，也把“输入数字这个功能再完善一下”。
Sub SetValue() Dim myInput As Variant myInput = InputBox("输入一个数字") If myInput &lt;&gt; "" Then If IsNumeric(myInput) Then Sheets("sheet3").Range("a1") = myInput Else MsgBox "输入的不是数字" End If Else MsgBox "输入的内容为空值" End If End Sub 在判断是否是数字上，如果用WorksheetFunction.IsNumber判断可能会出错。用户在输入123后，WorksheetFunction.IsNumber仍然会识别成文本格式。经过资料查询，解释是这样的：
WorksheetFunction.IsNumber：函数中的数值参数是无法转换的。例如，大部分其他函式中其中一个数字是必要，文字值19会转换的数字19。不过，在公式中ISNUMBER（“19”）、19不会转换文字值，且IsNumber函数会传回False。
IsNumeric：如果在整个表达式被视为一个数字就为真，否则，它会传回False。如果_表达式_为日期表达式IsNumeric会传回False。
所以咱们就知道为什么IsNumeric用来判断用户输入是否数字可以，而WorksheetFunction.IsNumber不行啦。
二、在空值输入内容
在空值输入内容的第一步当然是确定空值的位置啦，运行后跳转到空值的地方进行输入。我这里主要用到昨天的Range.End(xldown)来确定下一行的空值。
Sub SetBlankValue() Dim rowNum As Integer rowNum = Range("a1").End(xlDown).Row + 1 Range("a" &amp; rowNum).Select End Sub 是不是很简单啦。
三、计算选中单元格 数量
MsgBox Selection.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ae710811b6b53a49b8375b103d8549b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24f74529eb67d0ea244e81063193913c/" rel="bookmark">
			Python之列表list查找元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文代码上下文 girls = ['lili','meimei'] 第一种方式：使用下标 girls[0] 第二种方式：使用index() 方法 girls.index('lili') 说明：通过index（）方法找到元素位于list中的下标，接下来通过下标访问元素即可！
注意：元素不存在list中时，调用index（）方法会产生ValueError异常对象，使用index（）方法前，可以先使用 count() 方法或者in操作符判断元素是否存在于list中！只有count（）方法返回大于0的数量，或者in返回True时，表示有元素存在list中，此时我们再去使用index（）方法获取元素的下标
提示：count（）方法用来计算元素在list中出现的次数，元素在list中不存在时，返回0
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f0d30b350062c1a306d2ace296c4873/" rel="bookmark">
			解决window无法读取驱动器G:\中的光盘的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解决window无法读取驱动器G:\中光盘的问题 解决windows无法读取驱动器G:\中光盘问题的方法步骤如下：
1.打开本地服务管理器。
方法1.按键盘的”Win+R"组合键 打开“运行”窗口。输入“Services.msc”，单击“ 确定”。
方法2.依次点击“控制面板”&gt;“系统和安全”&gt;“管理工具”&gt;“服务”，打开本地服务管理器。
2.找到下面服务：“Shell Hardware Detection” (为自动播放硬件事件提供通知)。
3.双击“Shell Hardware Detection”服务，将“启动类型”设置为“禁用”。
4.单击下面的“停止”，并“应用”和“确定”。
通过以上办法，可以有效解决windows无法读取驱动器G:\中光盘的问题。
如果我的办法帮到了你，请运动一下你的爱心手指头点个赞吧，谢谢啦！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0b01417aed43b4a503958632e9af0c8/" rel="bookmark">
			allure不是内部或外部命令，Pycharm内部代码os.system运行命令提示不是内部或外部命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 很简单，使用管理员身份运行Pycharm。。。。。。。。。。。。。。
Python自动化测试研究院： 560151970 （q群） B站主页：https://space.bilibili.com/403609135 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78a36b45c5f30d6611f7490976c4312c/" rel="bookmark">
			电子科技大学现代电子信息系统综合实验课程设计代码(单片机&#43;频率计)2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接上一篇博客：
https://blog.csdn.net/Jinyindao243052/article/details/107821839
这是另外一种思路：
有两种测频模式，一个高频模式，一个低频模式
T0和T1都是计时器
单片机中断方案代码 #include &lt;reg51.h&gt; #include &lt;absacc.h&gt; #include &lt;ctype.h&gt; sbit KEY2 = P2^0;	//按键1	high mode sbit KEY3 = P2^1;	//按键2	low mode sbit KEY4 = P2^2; //按键3 切换档位 sbit LED0=P0^0; sbit LED1=P0^1; sbit LED2=P0^2; unsigned char flag;//阀门开否 unsigned char mode;//模式 :0低频 1：高频 unsigned char DispBuf[8]; unsigned char s[8]; unsigned char d;//档位 unsigned int t;//阀门长度/毫秒 unsigned long count; unsigned long f; unsigned long j;//循环变量 unsigned int wait; unsigned int a=0; //直接引用模块 void delay_l(unsigned int t){	//一个小改编，low mode使用的延时函数 do { TH0 = 0xFF; TL0 = 0x69; TR0 = 1; while ( !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78a36b45c5f30d6611f7490976c4312c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d02b471f459868f204c2502bda61659/" rel="bookmark">
			表单验证完整篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先看看我做的登录页面的效果： 常用的登录页面就是校验用户名、密码、确认密码、勾选性别、个人描述等等。但是原理大同小异。校验这些条件的时候还需要考虑到用户的体验是否好。下面就以上的表单验证说说我的做法。 文章目录 先看看我做的登录页面的效果：1.前言2.页面背景图3.登录页面的布局4.form表单的布局5.js对表单的校验5.1校验用户名5.2.校验密码5.3二次校验密码5.4校验用户名是否勾选5.5校验文本域的字数不小于50字5.6重置表单数据 6总结： 1.前言 表单需要用到的知识点：CSS+div页面布局+js
2.页面背景图 页面背景图就是将原图片按照一定比列占满整个浏览器。
body { background-image: url(img/bg_268dc65.jpg); background-size: 100% 100%; } 3.登录页面的布局 登录页面的布局始终固定在浏览器的中间位置。
.wrap { width: 500px; height: 450px; margin: 100px auto; text-align: center; background-color: #6c8cff; opacity: 0.8; border: 0px black solid; } 4.form表单的布局 现以一个input标签为例。其他标签依次类推的布局。
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .wrap{ width: 300px; height: 150px; border: 1px black solid; } .big{ width: 100%; height: 60px; border: 1px gold solid; } #userBlur{ /* input标签的宽度占div标签的75% 如果超过这个范围就会元素换行 */ width: 75%; height:30px; border: 1px red solid;	} #small{ width: 100%; height: 25px; border: 1px black solid; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d02b471f459868f204c2502bda61659/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/794752b842091444fd822a01df4c543c/" rel="bookmark">
			mysql关于多个full join的处理方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为mysql当前暂不支持full join的关联方式，如果只有两张表关联的情况，可以使用left join、right join、union的方式处理，但是如果存在多张表都需要full join的方式，又如何处理呢？
1、可以采用嵌套子查询的方式，将前面的查询sql语句当成当前full查询的主表，这样相对好理解，可以理解为永远只有两张表的full join。
2、（此方式为本文重点说明的方式）那就是有几个full join，就用几个union，具体如下：
一、先建五张表： CREATE TABLE `lsg_category` ( `id` bigint(10) NOT NULL COMMENT '主键ID', `type` int(3) DEFAULT NULL COMMENT '物品类型', `type_name` varchar(255) NOT NULL COMMENT '物品名称', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='物品类目表'; INSERT INTO `lsg_category`(`id`, `type`, `type_name`) VALUES (1, 1, '水果类目'); INSERT INTO `lsg_category`(`id`, `type`, `type_name`) VALUES (2, 2, '体育类目'); INSERT INTO `lsg_category`(`id`, `type`, `type_name`) VALUES (3, 3, '学习用品'); INSERT INTO `lsg_category`(`id`, `type`, `type_name`) VALUES (4, 4, '办公用品'); INSERT INTO `lsg_category`(`id`, `type`, `type_name`) VALUES (5, 5, '游戏类目'); CREATE TABLE `lsg_fruit` ( `id` bigint(10) NOT NULL COMMENT '主键ID', `fruit_name` varchar(255) DEFAULT NULL COMMENT '水果名称', `category_id` bigint(10) DEFAULT NULL COMMENT '物品类目ID', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='水果表'; INSERT INTO `lsg_fruit`(`id`, `fruit_name`, `category_id`) VALUES (1, '苹果', 1); INSERT INTO `lsg_fruit`(`id`, `fruit_name`, `category_id`) VALUES (2, '桃子', 1); INSERT INTO `lsg_fruit`(`id`, `fruit_name`, `category_id`) VALUES (3, '西瓜', 1); INSERT INTO `lsg_fruit`(`id`, `fruit_name`, `category_id`) VALUES (4, '橘子', 6); INSERT INTO `lsg_fruit`(`id`, `fruit_name`, `category_id`) VALUES (5, '西红柿', 6); CREATE TABLE `lsg_physical` ( `id` bigint(10) NOT NULL COMMENT '主键ID', `physical_name` varchar(255) DEFAULT NULL COMMENT '体育物品名称', `category_id` bigint(10) DEFAULT NULL COMMENT '物品类目ID', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='体育表'; INSERT INTO `lsg_physical`(`id`, `physical_name`, `category_id`) VALUES (1, '篮球', 2); INSERT INTO `lsg_physical`(`id`, `physical_name`, `category_id`) VALUES (2, '足球', 2); INSERT INTO `lsg_physical`(`id`, `physical_name`, `category_id`) VALUES (3, '排球', 2); INSERT INTO `lsg_physical`(`id`, `physical_name`, `category_id`) VALUES (5, '乒乓球', 7); INSERT INTO `lsg_physical`(`id`, `physical_name`, `category_id`) VALUES (6, '橄榄球', 8); CREATE TABLE `lsg_game` ( `id` bigint(10) NOT NULL COMMENT '主键ID', `game_name` varchar(255) DEFAULT NULL COMMENT '游戏名称', `category_id` bigint(20) DEFAULT NULL COMMENT '类目ID', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='游戏表'; INSERT INTO `lsg_game`(`id`, `game_name`, `category_id`) VALUES (1, '跳绳', 5); INSERT INTO `lsg_game`(`id`, `game_name`, `category_id`) VALUES (2, '踢毽子', 5); INSERT INTO `lsg_game`(`id`, `game_name`, `category_id`) VALUES (3, '捉迷藏', 15); INSERT INTO `lsg_game`(`id`, `game_name`, `category_id`) VALUES (4, '猜猜我是谁', 16); INSERT INTO `lsg_game`(`id`, `game_name`, `category_id`) VALUES (5, '划拳', 17); INSERT INTO `lsg_game`(`id`, `game_name`, `category_id`) VALUES (6, '剪刀石布', 17); CREATE TABLE `lsg_learn` ( `id` bigint(10) NOT NULL COMMENT '主键ID', `learn_name` varchar(255) DEFAULT NULL COMMENT '学习物品名称', `category_id` bigint(10) DEFAULT NULL COMMENT '类目ID', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='学习用品表'; INSERT INTO `lsg_learn`(`id`, `learn_name`, `category_id`) VALUES (1, '书桌', 3); INSERT INTO `lsg_learn`(`id`, `learn_name`, `category_id`) VALUES (2, '凳子', 3); INSERT INTO `lsg_learn`(`id`, `learn_name`, `category_id`) VALUES (3, '讲台', 10); INSERT INTO `lsg_learn`(`id`, `learn_name`, `category_id`) VALUES (4, '黑板', 11); 二、两张表的full join查询 （a full join b on a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/794752b842091444fd822a01df4c543c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8587645df9da81a7f8b039b0179e7976/" rel="bookmark">
			idea2020.1集成actibmp插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		idea2020.1集成actibpm插件 由于项目需要使用到Activiti工作流框架，而idea2020.1没有直接下载的插件，需要手动安装，故记录下，以后方便安装使用。
1、下载安装插件 版本是2020.1.1
idea插件官网
选择本地安装
找到下载到的本地的jar，然后重启idea即可。
安装完之后
2、编写demo测试 2.1、创建springboot项目 2.2、引入依赖 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.2.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.mystery&lt;/groupId&gt; &lt;artifactId&gt;demo_activiti&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;demo_activiti&lt;/name&gt; &lt;description&gt;Demo project for Activiti&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!--- Activiti依赖导入 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-spring&lt;/artifactId&gt; &lt;version&gt;5.22.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-engine&lt;/artifactId&gt; &lt;version&gt;5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8587645df9da81a7f8b039b0179e7976/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb15884ea761d789c8190acef20bf229/" rel="bookmark">
			由于目标计算机积极拒绝,无法连接。 已解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 爬取下厨房页面提取不到信息，加headers解决
url = 'http://www.xiachufang.com/explore/' headers = { 'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36' } # 获取数据 res_foods = requests.get(url, headers=headers) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c43254f3ccdb18731aa258a288de4220/" rel="bookmark">
			使用电脑远程操作Jetson nano终端3-更改linux权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用putty远程登录结果出现 access denied的问题
原因：Linux系统一般默认无法远程登录root用户，所以需要进行权限修改
1：打开config文件
ctrl+alt+t 打开终端，输入
vi /etc/ssh/sshd_config
2：输入大写的I，进行文本修改插入。
找到原文件里面的#permitRootLogin without-password ，将其修改为 permitRootLogin yes(去掉原本的#)
3：退出该config文件
输入ESC键，此时下方的insert行消失，输入：wq，即可退出。（如果出现add ! to override，则输入 ：wq!退出）
退出时出现意外**： “/etc/ssh/sshd_config” E212: Can’t open file for writing**
该句提醒此文件不能进行编辑。使用另外一种方式–命令行进行编辑。
输入：sudo gedit /etc/ssh/sshd_config
再输入密码，打开sshd_config文件窗口，进行修改，保存退出。
4：重启ssh
输入 service sshd restart
注1：如果以上操作不成功的话，继续打开上述配置，增加 AllowUsers root（如果原本有的话，修改即可），重启ssh，进行连接。
注2：使用putty进行远程连接时，用户名称为nano终端打开时@之前的名称，不是之后的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4bec62f12c002866d82fc45d933c1bc/" rel="bookmark">
			HDFS的Java API开发详解（文件的创建上传下载删除、IO流操作HDFS、小文件合并）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、准备工作
第一步：windows中的hadoop环境配置
第二步：创建maven工程并导入jar包
二、Java API开发实操
一、准备工作 windows操作系统需要配置一下hadoop环境
mac本质上是unix系统，不需要配置
第一步：windows中的hadoop环境配置 windows操作系统需要配置一下hadoop环境
mac本质上是unix系统，不需要配置
1. 解压Hadoop安装包压缩文件到一个没有中文没有空格的目录下，类似下图路径
2. 然后在windows当中配置hadoop的环境变量
3. bin、sbin目录添加到path中
4. 然后将下图中的hadoop.dll文件拷贝到C:\Windows\System32
5. 将Linux上安装部署好的hadoop集群的以下5个配置文件core-site.xml、hdfs-site.xml、mapred-site.xml、yarn-site.xml、slaves，拷贝到windows下hadoop的C:\hadoop-2.6.0-cdh5.14.0\etc\hadoop目录下
6. cmd中运行hadoop，出现如下效果
在Linux虚拟机中hdfs集群启动的前提下，cmd中运行hdfs dfs -ls /，查询出hdfs根目录的内容
注意：如果没有配置好windows的hadoop的环境变量，在windows下用IDEA编程时，会报以下错误
第二步：创建maven工程并导入jar包 由于cdh版本的所有的软件涉及版权的问题，所以并没有将所有的jar包托管到maven仓库当中去，而是托管在了CDH自己的服务器上面，所以我们默认去maven的仓库下载不到，需要自己手动的添加repository去CDH仓库进行下载，以下两个地址是官方文档说明，请仔细查阅
https://www.cloudera.com/documentation/enterprise/release-notes/topics/cdh_vd_cdh5_maven_repo.html
https://www.cloudera.com/documentation/enterprise/release-notes/topics/cdh_vd_cdh5_maven_repo_514x.html
&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;cloudera&lt;/id&gt; &lt;url&gt;https://repository.cloudera.com/artifactory/cloudera-repos/&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-client&lt;/artifactId&gt; &lt;version&gt;2.6.0-mr1-cdh5.14.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-common&lt;/artifactId&gt; &lt;version&gt;2.6.0-cdh5.14.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-hdfs&lt;/artifactId&gt; &lt;version&gt;2.6.0-cdh5.14.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-mapreduce-client-core&lt;/artifactId&gt; &lt;version&gt;2.6.0-cdh5.14.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4bec62f12c002866d82fc45d933c1bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c1e4f0726f8b8cd3cecf580a3d4996f/" rel="bookmark">
			linux报错Loaded plugins: fastestmirror, langpacks Loading mirror speeds from cached hostfile解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux报错Loading mirror speeds from cached hostfile解决方法
我这里使用的是centOS7的版本，在使用yum安装包时出现了如下问题：
Loaded plugins: fastestmirror, langpacks
Loading mirror speeds from cached hostfile
There are no enabled repos.
Run “yum repolist all” to see the repos you have.
To enable Red Hat Subscription Management repositories:
subscription-manager repos --enable To enable custom repositories:
yum-config-manager --enable [root@localhost ~]# yum install tree -y
Loaded plugins: fastestmirror, langpacks
Loading mirror speeds from cached hostfile
There are no enabled repos.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c1e4f0726f8b8cd3cecf580a3d4996f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2946b71e500dfbcc576471ca43d679c1/" rel="bookmark">
			关于 Cannot read property ‘length‘ of null 报错的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在搞前端的时候突然报了Cannot read property ‘length’ of null的错,一开始都是在前端调试错,发现解决不了问题,后来发现如果你所查找的数据条数为0的时候,后端返回给前端是null,此时必然报错Cannot read property ‘length’ of null.
解决办法:
如果后端的返回值为null,就需要我们在后端返回一个空的list数组
本人错误的后台代码:
如果返回data有数据,那么返回Data=data,如果没有数据,我们没有给前端返回一个data,所以在前端就接受到的是个null
var data = IScreenshot.GetAllStuScreenInfo(studentId); return data.Count != 0 ? new AjaxResult() { Status = "ok",Data=data } : new AjaxResult() { Status = "error",ErrorMsg= "暂时未能查询到任何信息"}; 改正后的后台代码:加上一个data,此时data的值为空的list.
var data = IScreenshot.GetAllStuScreenInfo(studentId); return data.Count != 0 ? new AjaxResult() { Status = "ok",Data=data } : new AjaxResult() { Status = "error",ErrorMsg= "暂时未能查询到任何信息",Data=data}; 我在处理的时候不是按照原来作者提供的方法对后台进行更改的，而是在前端判断如果接受到的值是null就给他赋值为空数组，否则就按照正常来处理。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/090efa0026ce202f5000326076c1abb0/" rel="bookmark">
			使用电脑远程操作Jetson nano终端2- 如何查找nano的ip地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows系统 1.查找自己电脑ip
按键win+r，输入cmd，enter键打开。
输入ipconfig，即得到自己电脑的网络ip。
2.查找局域网内电脑名称
上述窗口，输入net view，即得到局域网内其他电脑名称。
3.查找局域网内电脑ip
1）根据上述名称查找
输入（ ping -a 电脑名称），即可直接得到输入名称电脑的ip
2）通过MAC物理地址查找
输入（nbtstat -a 电脑名称），即可得到该名称电脑的MAC地址
输入arp -a，通过以上MAC地址即可查到对应ip地址
4.查找自己电脑名称
右击我的电脑，点击属性，即可看到计算机名称。
Linux系统 查找自己电脑ip
打开终端，
输入hostname, 即输出用户名称。
输入hostname -i，即输出ip地址。
注：用上述方式显示的ip为127.0.1.1，不清楚为什么。故用另一种方式查看。
输入ifconfig, 第一项 eth0 后面的 inet 后面的即为ip地址（192.168.1.122）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58e63e78247a78bfa9dd6eb7e88affcc/" rel="bookmark">
			docker的优势
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Docker 优势：
1、交付物标准化 Docker的标准化交付物称为"镜像"，它包含了应用程序及其所依赖的运行环境，大大简化了应用交付的模式。 2、应用隔离 Docker可以隔离不同应用程序之间的相互影响，但是比虚拟机开销更小。总之，容器技术部署速度快，开发、测试更敏捷；提高系统利用率，降低资源成本. 3、一次构建，多次交付 类似于集装箱的"一次装箱，多次运输"，Docker镜像可以做到"一次构建，多次交付"。 Docker的度量： Docker是利用容器来实现的一种轻量级的虚拟技术，从而在保证隔离性的同时达到节省资源的目的。Docker的 可移植性可以让它一次建立，到处运行。Docker的度量可以从以下四个方面进行： 1）隔离性 通过内核的命名空间来实现的，将容器的进程、网络、消息、文件系统和主机名进行隔离。 2）可度量性 Docker主要通过cgroups控制组来控制资源的度量和分配。 3）移植性 Docker利用AUFS来实现对容器的快速更新。 AUFS是一种支持将不同目录挂载到同一个虚拟文件系统下的文件系统，支持对每个目录的读写权限管理。AUFS具有层 的概念，每一次修改都是在已有的只写层进行增量修改，修改的内容将形成新的文件层，不影响原有的层。 4）安全性 安全性可以分为容器内部之间的安全性；容器与托管主机之间的安全性。 容器内部之间的安全性主要是通过命名空间和cgroups来保证的。 容器与托管主机之间的安全性主要是通过内核能力机制的控制，可以防止Docker非法入侵托管主机。 Docker容器使用AUFS作为文件系统，有如下优势： 1）节省存储空间 多个容器可以共享同一个基础镜像存储。 2）快速部署 3）升级方便 升级一个基础镜像即可影响到所有基于它的容器。需要注意已经在运行的docker容器不受影响 容器和 VM 的主要区别：
表面区别： 容器占用体积小，虚拟机占用体积大 隔离性：容器提供了基于进程的隔离，而虚拟机提供了资源的完全隔离。 启动速度：虚拟机可能需要一分钟来启动，而容器只需要一秒钟或更短。 容器使用宿主操作系统的内核，而虚拟机使用独立的内核。Docker 的局限性之一是，它只能用在64位的操作系统上。 本质区别： 容器是被隔离的进程 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/beebe37df7a3f2dcb74b8aa5426ade9b/" rel="bookmark">
			关于vue 版本的ant design pro 如何保留token验证去掉其他权限验证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何在ant design vue pro 原有的登陆权限的基础上保留token验证而去掉其他权限验证
第一步：在src/main.js中注释掉mock.js
// with polyfills import 'core-js/stable' import 'regenerator-runtime/runtime' import Vue from 'vue' import App from './App.vue' import router from './router' import store from './store/' import { VueAxios } from './utils/request' // mock // WARNING: `mockjs` NOT SUPPORT `IE` PLEASE DO NOT USE IN `production` ENV. // import './mock' import bootstrap from './core/bootstrap' import './core/lazy_use' import './permission' // permission control import './utils/filter' // global filter import '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/beebe37df7a3f2dcb74b8aa5426ade9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40db7ced54307a6a63ab7eaf75705d88/" rel="bookmark">
			Ubuntu 系统镜像地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方下载地址（不推荐）
https://www.ubuntu.com/download
中科大源
http://mirrors.ustc.edu.cn/ubuntu-releases/
阿里云开源镜像站
http://mirrors.aliyun.com/ubuntu-releases/
兰州大学开源镜像站
http://mirror.lzu.edu.cn/ubuntu-releases/
北京理工大学开源
http://mirror.bit.edu.cn/ubuntu-releases/
浙江大学
http://mirrors.zju.edu.cn/ubuntu-releases/
不知名镜像网站
http://mirror.pnl.gov/releases/xenial/
各个版本下载网址：
http://mirrors.melbourne.co.uk/ubuntu-releases/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d7545f26f8f26246e283e9eda7ec4be/" rel="bookmark">
			Assimp 编译（Visual Studio 2019）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Assimp 编译 一、前言二、源码下载三、编译环境四、编译五、配置环境六、测试 DEMO 一、前言 Assimp 是一个非常流行的模型导入库，它是 Open Asset Import Library（开放的资源导入库）的缩写。Assimp 能够导入多种不同的模型文件格式（并也能够导出部分的格式），它能将不同格式的模型数据加载至 Assimp 的通用数据结构中。当 Assimp 加载完模型之后，我们就能够从 Assimp 的数据结构中提取我们所需的所有数据了。由于 Assimp 的数据结构保持不变，不论导入的是什么种类的文件格式，它都能够将我们从这些不同的文件格式中抽象出来，用同一种方式访问我们需要的数据。
二、源码下载 Assimp 5.0.1： https://github.com/assimp/assimp/releases/tag/v5.0.1
三、编译环境 操作系统：Win10 x64 专业版
编译环境：Visual Studion Enterprise 2019、CMake 3.18.0
四、编译 打开 cmake-gui.exe
配置环境变量选择源码路径与输出目录
点击 Configure 配置想要输出 x64 版本 （x86 版本自己选择 win32）
点击 Configure 完成后，再点击 Generate
出现以下警告忽略即可，不影响编译
点击OpenProject 选择 Release 编译即可
编译完成后，可在code/Release 目录找到生成的 dll 与 lib
注：x86版本自己安照上面的教程编译，只需在步骤3 修改下导出版本，如果报找不到 DirectX，自行安装 Dx 即可，Dx 下载链接：https://www.microsoft.com/en-us/download/details.aspx?id=6812，或在导出配置时去掉 ASSIMP_BUILD_ASSIMP_VIEW
五、配置环境 配置 Include 文件 将导出工程中的 config.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d7545f26f8f26246e283e9eda7ec4be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f928226052b850b6a069fce91efb6b17/" rel="bookmark">
			LM(列文伯格-马夸尔特)方法的个人理解，以及实现问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 LM方法是适用于求解方程最小值的一种方法，在非线性优化的框架中，优化方法分为Line Search 和 Trust Region，也就是线搜索和信任域方法，它们是两种不同性质的方法。
不同之处:
LIne Search:不管当前迭代点X(k)到最优解X*之间的路径，每次迭代X(k)得到X(k+1),都是使用该点的反向梯度方向进行值得寻找，这就导致了这样一种可能得问题：‘在靠近X*的时候，X(k)反复震荡，不容易收敛。这种情况特别是会发生在固定迭代步长的时候，Eg:对于求解f(x)=x^2的最优解X*,当X(k)=0.01,而迭代步长为1的时候，这个时候下一个X(k+1)=-0.01，如此这就发生了震荡，无法收敛。这确实是特例，但是只要有这种情况存在，也就是我们能够找出一个情况算法有问题，我们就无法保证所需要优化的函数f(x)不存在这种性质。
代表:梯度下降法，牛顿法，高斯牛顿法。
Trust Region:对于当前迭代点X(k)，我们会找出一个合适的迭代区域||D(X(k+1)-X(k))||&lt;=hk,hk&gt;0，下一个X(k+1)产生于该区域内，然后寻找这个区域的内最佳的迭代向量dX(k)。同时uk会根据每次的X(k)来计算调整，这就i是信任域的普遍思想。
代表:LM法。
LM法的个人理解 具体的实现方法我不做说明，网络上已经有很多人进行了详细的介绍。
这里转载一个我认为没有问题的他人的博客。https://www.codelast.com/%e5%8e%9f%e5%88%9blm%e7%ae%97%e6%b3%95%e7%9a%84%e5%ae%9e%e7%8e%b0/
这里需要说明的是，很多博主在描述到LM具体算法实现的伪代码描述时，大多会混淆拉格朗日乘子和信任域hk这两个参量。导致在说到具体实现的时候逻辑不清，在应该让h(k+1)=2*h(k)的时候，说成h(k+1)=h(k)/2。
下面来说明一下算法和LM思想原理之间的对应关系:
高斯牛顿法优化目标是，利用求导数为0，我们得到,但是这个要求必须是可逆矩阵，要求较为严格。
而LM算法优化目标是,因为约束条件的h(k)是迭代变化的，为了保证公式一致性，把约束条件改写成是加了约束条件的优化目标.利用拉格朗日乘子法进行转换成无约束目标，令。
采用拉格朗日乘数法确实需要解出不同情况下对应的*，但是在LM法中进行了这样的操作，把看成常数，相等于把问题转化成了数学建模中的规划问题，约束条件的权重为,而高斯牛顿法优化目标为,当时，两者同比重，也就是总优化目标同时考虑到了两者。这样我们就可以减少求解乘子的步骤，得到最终的迭代向量，特别的当D为单位矩阵时，表示信任域是一个球。
接下来讲述关键问题，也就是如何迭代u(k).
LM定义了这样一个比值参量,表征了实际下降量与一阶微分量（也就是近似下降量)的比值。
在算法伪代码中有这么一个判断:
如果,那么h(k+1)=h(k)/2,也就是减小信任域，此时在具体的算法中u(k+1)=2*u(k)；
如果,那么h(k+1)=2*h(k),也就是增大信任域，此时在具体的算法中u(k+1)=u(k)/2；
这其中的逻辑关系从LM迭代公式可以知道，因为如果实际下降比一阶近似小很多，那么表示二阶以上分量占了比较大的比重，这个时候非线性比较严重，那么就应该缩小信任域，u(k)增大，而的模长变小，也就是变化较小了。同理可说明另外的情况。
最后说明一下如果u(k)的迭代搞混了，也就是之前提到的，该增大的时候变小了，而该变小的时候增大了，这个时候会出现的问题。
最容易遇到的问题就是迭代过小，通过查看的模长||||2^(-k)，就是同一个数量级，而且收敛于非最优解，过早收敛了。产生这种情况的逻辑在于:当某一次迭代过程得到,本该u(k+1)=u(k)/2,但是搞混的情况下u(k+1)=2*u(k),下次的迭代将会变得更小，因为u(k+1)=2*u(k)等价于信任域变小了。另外，这样一次比一次的迭代小了，而且还是指数变小，那么就会使得目标在非最优解上收敛。通过修改程序上的正常逻辑，我们可以验证这样的情况。
最后附上LM算法的matlab程序 链接：https://pan.baidu.com/s/1_3AF-ZRkU9DPlcgxoMY-DA 提取码：z7y8 复制这段内容后打开百度网盘手机App，操作更方便哦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0276b1fb5f62e10683e37e776b95dd4e/" rel="bookmark">
			PostgreSQL 目录结构及修改数据目录及配置文件分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		启动脚本 #!/usr/bin/env bash set -Eeo pipefail # TODO swap to -Eeuo pipefail above (after handling all potentially-unset variables) # usage: file_env VAR [DEFAULT] # ie: file_env 'XYZ_DB_PASSWORD' 'example' # (will allow for "$XYZ_DB_PASSWORD_FILE" to fill in the value of # "$XYZ_DB_PASSWORD" from a file, especially for Docker's secrets feature) file_env() { local var="$1" local fileVar="${var}_FILE" local def="${2:-}" if [ "${!var:-}" ] &amp;&amp; [ "${!fileVar:-}" ]; then echo &gt;&amp;2 "error: both $var and $fileVar are set (but are exclusive)"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0276b1fb5f62e10683e37e776b95dd4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f0a3c0913f0e66ba72b6f34e0ab6814/" rel="bookmark">
			Go基础学习-defer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		defer执行的原则 defer延迟函数总是在异常panic或者正常return前返回；defer执行顺序按照先入后出的原则，即先入栈的最后执行；但是会先把参数压入栈，具体执行会在函数结束前当defer函数中存在函数时会先执行里面的函数；defer函数调用的参数当存在闭包时，会从外面拿取该参数的最新的值；defer常常与recover一同使用；用来做异常捕捉后的延迟执行；从而将异常给转换为错误error; 看几个案例：
案例1：
func main() { i := 10 defer fmt.Printf("defer i=%d", i) i = 100 fmt.Println(i) } /* output: 100 defer i=10 */ 用到原则1、2
案例2：
func calc(x,y int )int{ res:=x+y fmt.Println(x,y,res) return res } func main(){ a:=10 b:=20 defer calc(a,calc(a,b)) a=100 defer calc(a,calc(a,b)) a=1000 } //output: //10 20 30 //100 20 120 //100 120 220 //10 30 40 使用到原则1，2，3
案例3：
func calc(x,y int )int{ res:=x+y fmt.Println(x,y,res) return res } func main(){ a:=10 b:=20 defer func(i int) { calc(a,calc(a,b)) fmt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f0a3c0913f0e66ba72b6f34e0ab6814/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14419bae399feec088847be5cda3aaf8/" rel="bookmark">
			ios描述文件过期时间查看
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这边主要是针对企业证书
以下对生产证书和描述文件过期时间的截图
以下是描述文件查看步骤
只能在苹果电脑查看原先这个包叫xxxx.ipa,要先将后缀改成zip双击这个文件，会生成一个文件夹 点击Payload进去，右键显示包内容找到embedded...bileprovision这个文件，如果不存在这个文件，一定要重新打包Expiration Date就是描述文件的过期时间 注意事项：
过期时间一个月以内最好重新打包如果过期了，app就打不开，自动更新也不行了，只能卸载掉app，重新装 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71884dec500ced19e25a86a280f20ca1/" rel="bookmark">
			单链表中什么时候使用二级指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用单链表时，一直有一个疑惑，初始化单链表时为什么要用二级指针？
代码如下：
typedef int ElemType;/* ElemType类型根据实际情况而定，这里假设为int */ typedef struct Node { ElemType data; struct Node * next; }Node, *LinkList;/*LinkList为结构指针类型*/ void InitList(LinkList *L)	/* 等价于Node **L，二级指针 */ { *L = (LinkList)malloc(sizeof(Node));//建立头结点 (*L)-&gt;next = NULL;//建立空的单链表 } 在初始化过程中，需要修改头指针，因此要用到二级指针传递头指针的地址，这样才能修改头指针。这与普通变量类似，当需要修改普通变量的值，需传递其地址。使用二级指针，很方便就修改了传入的结点一级指针的值。 如果用一级指针，则只能通过指针修改指针所指内容，却无法修改指针的值，也就是指针所指的内存块。
用框图表示链表中二级指针或者一级指针的使用
总结：
在使用带头结点的单链表时
1、初始化链表头部指针需要用二级指针
2、销毁链表需要用到二级指针
3、插入、删除、遍历、清空结点用一级指针即可
注意：
如果是不带头结点的单链表，插入、删除和清空结点也需要二级指针（比如往空链表中插入一个节点时，新插入的节点就是链表的头指针，此时会改动头指针。同理，删除第一个结点和清空结点都会改动头指针）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0456b78cf975e6939c76f766507da295/" rel="bookmark">
			Java文件类boolean setLastModified（long set_new_time）方法，包含示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件类boolean setLastModified(long set_new_time) (File Class boolean setLastModified(long set_new_time)) This method is available in package java.io.File.setLastModified(long set_new_time).
软件包java.io.File.setLastModified(long set_new_time)中提供了此方法。 This method is used to sets the last modified time of the given file.
此方法用于设置给定文件的最后修改时间。 In other words, Every file has some last modified time if file exists but by using this method we can change the last modified time of the file with the given new time.
换句话说，如果文件存在，则每个文件都有最后修改时间，但是通过使用此方法，我们可以使用给定的新时间来更改文件的最后修改时间。 The return type of this method is Boolean so it returns true if file last modification is set successfully else return false.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0456b78cf975e6939c76f766507da295/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39d3ca8c05fd23f565d80c9e1213145b/" rel="bookmark">
			【转载】AUTODESK系列专用卸载工具软件推荐排行榜（CAD/3Dmax/Revit/Maya/Inventor）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		autodesk系列软件安装失败，怎么完全彻底删除清理干净autodesk系列各种残留注册表和文件呢？有些同学想把autodesk系列重新安装，但是autodesk系列安装失败显示失败，有时autodesk系列安装到一半就显示失败，然后会问autodesk系列无法重装是怎么回事。那么autodesk系列安装失败的原因是什么呢？如何才能把autodesk系列卸载干净呢？有人说只要把autodesk系列注册表7d2f删除就可以了，但是有的同学找到了autodesk系列注册表7d2f也删除了，但是autodesk系列再次安装失败。还有的同学直接重装系统，但是重装系统后autodesk系列依然无法安装。还有的同学直接很暴力地把autodesk系列的程序文件删除掉，重装autodesk系列的时候会显示已安装。那么造成autodesk系列卸载不干净无法重装的原因到底是什么呢？答案可能不是唯一！
autodesk系列提示安装未完成，某些产品无法安装该怎样解决呢？一些朋友在win 7或者win 10系统下安装autodesk系列失败提示autodesk系列安装未完成，某些产品无法安装；也有时候想重新安装autodesk系列的时候会出现本电脑windows系统已安装autodesk系列，你要是不留意直接安装autodesk系列，只会安装autodesk系列的附件或者直接提示安装失败，autodesk系列是安装不上的。这种原因就是大家在之前卸载autodesk系列时没有把autodesk系列残留注册表信息删除或者是因为C++版本不对。下面我来教大家如何把autodesk系列强力卸载掉然后重新安装，最后完美安装运行autodesk系列，如果纯手工删除autodesk系列会有很多条注册表记录要删。
autodesk系列没有按照正确方式卸载，导致autodesk系列安装失败。楼主也查过网上关于如何解决autodesk系列安装失败的一些文章，是说删除几个autodesk系列文件和autodesk系列软件注册表就可以解决autodesk系列安装失败的问题，实际的情况并没有这么简单，导致autodesk系列安装失败的原因有很多种。autodesk系列安装时产生了几万条注册表，想要彻底卸载autodesk系列软件再重新安装autodesk系列就有几万条autodesk系列注册表要删除，非人力所能为。现在虽然360或者其他一些卸载软件提供了强力卸载autodesk系列的工具，可以将autodesk系列注册表和一些autodesk系列目录的autodesk系列残留信息删除，但仍不能确保将autodesk系列所有相关dll程序文件、exe可执行文件和注册表全部彻底删除干净。autodesk系列安装失败还和C++版本问题有关，因为每个版本的autodesk系列都是基于一定版本的C++版本而开发的，如果是这种情况，重装系统C++问题还是可能会存在的。安装成功后，如果缺少必要的dll动态链接库文件，也会导致autodesk系列启动和注册失败。上面说了这么多，只是几种autodesk系列安装失败最常见的情况。这里使用到一个autodesk系列卸载工具，专门用来解决卸载修复autodesk系列软件卸载安装失败的问题。autodesk系列卸载工具会自动执行一系列问题的排查和修复，极大的节省了排除安装autodesk系列失败问题的时间。卸载之后，建议最好用autodesk系列官方原始的安装包，压缩包的常常会缺少一些组件也可能导致autodesk系列安装失败，安装时还要使用管理'员帐户进行安装。
1，AUTODESK 修复精灵 (AUTO Uninstaller)
推荐指数：★★★★★
Autodesk修复精灵(AUTO Uninstaller)是专门为了针对Autodesk类软件卸载不干净而导致autodesk安装失败问题进行研发的autodesk一键卸载工具。现在虽然360或一些卸载软件提供了强力卸载autodesk的工具，可以将autodesk注册表和一些autodesk目录的autodesk残留信息删除，但仍不能确保将Autodesk所有相关程序文件和注册表全部彻底删除。也查过网上关于如何卸载autodesk的一些文章，是说删除几个autodesk文件和autodesk软件注册表就可以了，情况并没有这么简单。autodesk安装时产生了几万条注册表，想要彻底卸载autodesk软件，就有几万条autodesk注册表要删，非人力所能为。autodesk安装失败还和C++版本问题有关，因为每个版本的autodesk都是基于一定版本的C++版本而开发的。上面说了这么多，只是两种最常见的情况。这里介绍一个Autodesk卸载工具，专门用来解决卸载修复autodesk类软件卸载安装失败的问题。autodesk卸载工具会自动执行一系列问题的排查和修复，极大的节省了排除安装autodesk失败问题的时间。
地址二(百度网盘) 提取码：7kys
无敌密钥：9Jm5J6yXA5zmh8xzbhXzy6hzoyah6xAm##
2，CCleaner
推荐指数：★★★
CCleaner是一款免费的系统优化和隐私保护工具。CCleaner的主要用来清除Windows系统不再使用的垃圾文件，以腾出更多硬盘空间。它的另一大功能是清除使用者的上网记录。CCleanerBT的体积小，运行速度极快，可以对文件夹、历史记录、回收站等进行垃圾清理，并可对注册表进行垃圾项扫描、清理。附带软件卸载功能。 同时支持IE、Firefox。免费使用，不含任何间谍软件和垃圾程序。支持包括简体中文在内的26国语言界面！
CCleaner 可以清除这些高级 Windows 文件：
过期的预读数据-预读文件储存着一些频繁使用的程序的信息，用于加快程序运行。CCleaner 会清除一些长期不使用的预读文件。（这个选项仅适用于 Windows XP）
菜单次序缓存- 当您在开始菜单中拖放菜单项时，系统会记录下这些信息。
托盘通知缓存- 您对托盘通知进行的的设置，例如不活动时隐藏、总是隐藏、总是显示。
窗口位置/位置记录- Windows资源管理器的窗口位置、大小等信息。
用户援助历史- 记录您对程序、快捷方式、控制面板甚至网站的访问。
ⅡS日志文件- 微软 ⅡS 服务器的日志文件，一般用于提供给技术人员查看服务器运行状况。
Hotfix卸载程序- 当您给系统打完补丁时，系统会保留这些补丁的卸载程序。（这个选项仅适用于 Windows XP）
自定义文件和文件夹- 您可以自己设定需要清理的文件类型和文件夹。相关设置请参见选项 - 自定义
擦除剩余空间- 当您删除文件时，系统只是删除了该文件在硬盘上的标记信息，而没有删除文件本身，直到新的数据覆盖这些文件。这个选项可以立即删除文件本身，但是需要大量时间。
MUI 缓存- 每个程序都有一个 .exe 文件（例如记事本有 notepad.exe），当您运行一个程序时，系统会从程序的.exe文件中摘取正式的程序名称（例如“记事本”），并将其保存在一个名叫 MUICache 的注册表键值中。
3，autodesk 自带卸载程序
推荐指数：★★
Autodesk卸载工具(Autodesk Uninstall)是一款专门为了针对autodesk软件进行研发推出的一键卸载工具，方便重装需求，卸载无需费时费力。因为第二次安装CAD的时候，有时很多次碰到CAD卸载不干净，导致第二次安装失败。原来是有文件残留，怎么找到删除呢？Autodesk 卸载工具(Autodesk Uninstall)就能很好的帮助到大家。需要的朋友可下载试试！
autodesk官方卸载工具使用方法：
1、下载软件包解压。
2、双击运行卸载工具软件，会读取出你电脑上安装的所有Autodesk软件；
3、勾选需要卸载的软件或组件，点击卸载；
4、等待工具自动完成卸载即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c098b2b604963051760a12da73de60ec/" rel="bookmark">
			NUC972触摸屏驱动移植过程分析（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/b7376811/article/details/86514683
因为下一个项目可能会用到触摸屏，所以这段时间对触摸屏的驱动的移植进行了研究，今天正好有机会，谈谈移植过程。
其实基于开发板对触摸屏驱动进行移植，需要做的工作并不是太多，因为大部分工作开发板的供应商已经提供好了，但是用起来总是不尽人意，所以需要进一步优化，废话少说，步入正题。
首先看一下硬件电路，如下图所示：
开发板上使用的是TSC2007作为驱动触摸屏（电阻屏）的驱动芯片，没有使用nuc972内置的AD，这样做的原因首先是比较好移植，其次是外置专用的触摸屏芯片往往精度更高。咱们先看一下这个芯片的几个主要的引脚，X+、Y+、X-、Y- 是连接触摸屏的，一般情况下无需考虑，A0、A1、SCL、SDA 这四个引脚定义很容易识别出是和IIC通信有关，是的，一般外置的触摸屏控制芯片（包括电阻屏和电容屏）都是通过IIC接口与主机CPU进行通信的，A0、A1是设置地址的接口，SCL和SDA分别是IIC的时钟接口与数据接口，那么问题来了，IIC通信是主从模式，任何的通信都需要由主机发起，而主机不能判断什么时候触摸屏被按下，总不能CPU一直在轮询触摸屏吧，那还干不干其他事儿了？所以，就又增加了一个/PENIRQ引脚，这个引脚一般要与CPU的一个gpio连接，如果触摸屏被按下，这个引脚会有动作，从图上可以看出来当触摸屏被按下时，这个引脚会变低，松开会变高（CPU一般是使用中断进行处理），这样就可以通知CPU读取触摸屏数据了。
看完了硬件，我们再来看一下软件。大家知道，在linux内核中，设备数据和驱动原则上是分离的，这样可以增加驱动的可移植性。首先看一下device，在新唐提供的BSP中，nuc970系列的设备数据在/arch/arm/mach-nuc970 这个文件夹里面，我们需要的信息在dev.c这个文件里。还是从下晚上看的看代码原则，先看一下CPU启动时，设备初始化函数：
void __init nuc970_platform_init(struct platform_device **device, int size)
{
#if defined(CONFIG_LEDS_GPIO)
if (gpio_request(nuc970_ek_leds[0].gpio, "led-ds2") &lt; 0) {
printk("can not request gpio[%d] for led-ds2\n", nuc970_ek_leds[0].gpio);
} else {
gpio_direction_output(nuc970_ek_leds[0].gpio, nuc970_ek_leds[0].active_low);
}
#endif
platform_add_devices(device, size);
platform_add_devices(nuc970_public_dev, ARRAY_SIZE(nuc970_public_dev));
mdk970ek_add_device_buttons();
#if defined(CONFIG_MTD_M25P80) || defined(CONFIG_SPI_SPIDEV)
/* register spi devices */
#ifdef CONFIG_SPI_NUC970_P0
spi_register_board_info(nuc970_spi0_board_info, ARRAY_SIZE(nuc970_spi0_board_info));
#endif
#ifdef CONFIG_SPI_NUC970_P1
spi_register_board_info(nuc970_spi1_board_info, ARRAY_SIZE(nuc970_spi1_board_info));
#endif
#endif
#ifdef CONFIG_I2C_BUS_NUC970_P0
i2c_register_board_info(0, nuc970_i2c_clients0, sizeof(nuc970_i2c_clients0)/sizeof(struct i2c_board_info));
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c098b2b604963051760a12da73de60ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bc59be9b8575c72c0609e10dc968e7c/" rel="bookmark">
			Android audio介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自 https://www.cnblogs.com/hzl6255/p/12173595.html
阅读目录
1. 架构2. Audio HAL3. Native Audio4. Java Audio 开始这篇文章之前，需要先了解&lt;Linux音频编程&gt;
回到顶部
1. 架构 在Android中，audio以分层的方式实现，从上到下依次为
- 应用框架: 提供android.media API
音频管理器: AudioManager
音频采集: MediaRecoder, AudioRecord
音频播放: SoundPool, MediaPlayer, AudioTrack
音频编解码: MediaCodec
- JNI: 通过调用libmedia库实现android.media所需的接口，在libandroid_runtime.so中体现
…
- HAL层: 实现audio_hw_device和audio_policy_hal, 实现与ALSA的音频接口, 实现音频路径的创建和连接
回到顶部
2. Audio HAL Audio HAL架构使用的是比较复杂，混合了HIDL和Legacy HAL，笔者看的也是一头雾水
可参考&lt;Android O Treble架构下Hal进程启动及HIDL服务注册过程&gt;
2.1 HAL接口 Audio HAL提供的接口(以2.0为例)主要包括
// 音频设备 IDevice.hal |- initCheck() |- setMasterVolume(float): 设置除voice call外其他音频活动的音量 |- getMasterVolume(): 获取主音量 |- setMicMute(bool): 设置麦克风静音状态 |- getMicMute(): 获取麦克风静音状态 |- setMasterMute(bool): 设置静音状态 |- getMasterMute(bool): 获取静音状态 |- getInputBufferSize(AudioConfig): 获取音频输入缓冲区大小 |- openOutputStream(*): 创建和打开音频硬件输出流 |- openInputStream(*): 创建和打开音频硬件输入流 |- supportsAudioPatches(): 判断HAL是否支持AudioPatch |- createAudioPatch(*): 为SRC和SINK创建AudioPatch |- releaseAudioPatch(*): 释放一个AudioPatch |- getAudioPort(*): 获取指定音频端口属性 |- setAudioPortConfig(*): 配置音频端口 |- getHwAvSync(): 获取设备的硬件同步源 |- setScreenState(bool): 设置屏幕状态 |- getParameters(vec&lt;string&gt;): 获取厂商定义的参数值 |- setParameters(vec&lt;ParameterValue&gt;): 设置厂商定义的参数值 // 音频代理 IDevicesFactory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7bc59be9b8575c72c0609e10dc968e7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e9721e7dd75e8fe5ce6ce248331f4ec/" rel="bookmark">
			启动java服务遇到的坑com.alibaba.fastjson不存在以及Warning:java: 源值1.5已过时, 将在未来所有发行版中删除 ，解决方法如下
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		启动java服务遇到的坑com.alibaba.fastjson不存在以及Warning:java: 源值1.5已过时, 将在未来所有发行版中删除
，解决方法如下
Error:(4, 28) java: 程序包com.alibaba.fastjson不存在
idea中通过maven已经导入了包，idea中也能定位到包的位置，但在编译的时候始终报error，找不到包。
推测原因是idea的版本与maven构建的build不相容
解决办法如下：
将idea的构建和运行托管到maven下面
勾选后，重新编译就能正常运行
IDEA中提示：Warning:java: 源值1.5已过时, 将在未来所有发行版中删除
在下雨的Tokyo 2018-04-19 20:49:47 29019 收藏 42
分类专栏： 编译工具
版权
问题描述：
运行Java Web项目时，IDEA中提示：Warning:java: 源值1.5已过时, 将在未来所有发行版中删除
解决方法：
打开【File】—【Project Structure】，找到以下两个地方： Project Structure-&gt;Project里Project sdk以及project language level
Project Structure-&gt;Modules里Sources里的Language level
1
2
因为我的电脑上安装的Java的版本是1.8，所以在这两个地方位置的设置如下：
这几个地方要对应
当这两个地方配置好后，再次运行项目，出现如下的提示： 说明我们还有地方没有配置好。打开【File】—【Settings】，找到【Java Compiler】，会发现这个问题：
发现两个地方的版本对应不上，我们需要将下边的5或者1.5修改为8或者1.8。
修改完后，点击Apply—OK之后，程序就能正常运行了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/024d366691b301a09e427f41494e8231/" rel="bookmark">
			Ros melodic python3环境解决cv_bridge问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ros melodic python3环境解决cv_bridge问题 巨坑，翻遍所有csdn，找了许多方法，搞了好久终于解决了，现在记录一下。
博主版本：ubuntu18.04+Ros melodic+python3.6.9
问题描述 代码报错最后两行：
from cv_bridge.boost.cv_bridge_boost import getCvType ImportError: dynamic module does not define module export function (PyInit_cv_bridge_boost) 网上很多教程都说ros+python3不行，是要建立虚拟空间。我尝试过虚拟空间但一样会报错，这里找到了一个方法并不需要建立虚拟空间。
解决方案 一、编译cv_bridge包与使用依赖cv_bridge包： 1、首先进入python3的环境并安装相关依赖包
sudo apt-get install python-catkin-tools python3-dev python3-catkin-pkg-modules python3-numpy python3-yaml ros-melodic-cv-bridge 2、创建一个工作空间用于存放待编译的 cv_bridge 文件
mkdir -p catkin_workspace/src 3、指示carkin设置cmake变量
cd catkin_workspace catkin config -DPYTHON_EXECUTABLE=/usr/bin/python3 -DPYTHON_INCLUDE_DIR=/usr/include/python3.6m -DPYTHON_LIBRARY=/usr/lib/x86_64-linux-gnu/libpython3.6m.so 4、指示catkin将内置包安装到安装位置，这一步不成功也没关系，可不用。
catkin config --install 5、在catkin_workspace工作空间中克隆 cv_bridge src
git clone https://github.com/ros-perception/vision_opencv.git src/vision_opencv 6、在存储库中查找cv_bridge的版本
apt-cache show ros-melodic-cv-bridge | grep Version 7、在git repo中签出正确的版本。在我们的例子中是1.13.0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/024d366691b301a09e427f41494e8231/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f53a2b8c87d14165a6c7dbc5bdd76199/" rel="bookmark">
			大数据分析和数据挖掘区别_大数据分析和数据挖掘之间的区别，大数据的未来范围...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大数据分析和数据挖掘区别
There arises a confusion among most of the people between Big Data and Data mining. In this article, I will try to make you understand the difference between both and later on we will focus on the future scopes of Big data.
大多数人在大数据和数据挖掘之间产生了混淆。 在本文中，我将尝试使您理解两者之间的区别，以后我们将重点关注大数据的未来范围 。 Big data and data mining are two completely different things. The only similarity between them or we can say that the only thing that relates to big data and data mining is the use of huge data sets that serve business or other purposes.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f53a2b8c87d14165a6c7dbc5bdd76199/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2bac029edac682da0c4c6a654708bb9/" rel="bookmark">
			两个列表的最小索引总和_在最小时间复杂度中找到总和最接近零的对
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		两个列表的最小索引总和
Problem statement
问题陈述 Given an array with both positive and negative integers. Find the pair whose sum is closest to zero in minimum time complexity.
给定一个既有正整数又有负整数的数组。 找到总和最接近零的最小时间复杂度对。 Description: 描述： Here we are going to see the algorithm with minimum time complexity to find a pair such that their sum is closest to 0.
在这里，我们将看到具有最小时间复杂度的算法，以找到对使得它们的总和最接近0。 Algorithm:
算法： Sort the array.
对数组进行排序。 Maintain two indexes, one at beginning, i, (i=0) &amp; the other at the ending, j, (j=n-1, where n is the array length).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2bac029edac682da0c4c6a654708bb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17830f3cf279f886357d39e5fea2d1c3/" rel="bookmark">
			Fullcalendar 在vue中鼠标hover显示悬浮框（tippy.js插件）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从开始到放弃，从放弃到开始，哥们我已经折腾两个早上了，都有点怀疑人生了。
首先，安装Fullcalendar插件，这个东西只能看官网，官网：https://fullcalendar.io/docs#toc。因为它更新快，向下也不兼容哦，一般中文文档啥的更不上官网的速度。有一个小妙招，下个有道词典，不认识的指一下就可以翻译了。具体的安装过程就不详细记录了，今天说一下鼠标hover日历事件显示悬浮框这个东东怎么实现。
因为Fullcalendar文档基本是基于jquery的，所以jquery的同学很好弄，但是今天哥用的vue框架。痛就痛苦在这里。
话不多说，记录下配置：
&lt;FullCalendar ref="fullCalendar" :options="calendarOptions"/&gt; 这一句就是初始化日历插件的东西了。配置如下，这是基于Fullcalendar V5版本的哦，其他版本可能不适合：
calendarOptions: { plugins: [ dayGridPlugin, interactionPlugin,timeGridPlugin],//加载插件，V5采用插件模块方式加入 editable: true,//是否可编辑 droppable: true,//可拖拽的 initialView: 'dayGridMonth',//日插件 // initialDate:""//初始化日期 timeZone: 'local',//采用时区 locale:"zh-cn",//采用中文 height:700,//日历高度 dateClick: this.handleDateClick,//日期方格点击事件 eventClick:this.handleEventClick,//日程点击事件 eventMouseEnter:function (info) {//鼠标hover事件，对应也有其他鼠标事件监听 // console.log(info) let col = info.event.borderColor; let eve = info.event._def.extendedProps tippy(info.el, {//tippy hover插件 content:"&lt;div style='width: 2rem;'&gt;" + "&lt;div style='border-bottom: 0.01rem solid #CCCCCC;line-height: 0.3rem;color: "+col+"'&gt;"+info.event.title+"&lt;/div&gt;" + "&lt;div style='color: #666666'&gt;训练名称："+eve.trainName+"&lt;/div&gt;" + "&lt;div style='color: #666666'&gt;训练日期："+eve.trainDate+"&lt;/div&gt;" + "&lt;div style='color: #666666'&gt;开始时间："+eve.starttime+"&lt;/div&gt;" + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17830f3cf279f886357d39e5fea2d1c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d428426eaeecf0526a7214c55a40e982/" rel="bookmark">
			python重载运算符乘法_Python | 使用乘法运算符创建一个字符串的多个副本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python重载运算符乘法
Given a string and we have to create its multiple copies by using multiplication operator in Python? 给定一个字符串，我们必须通过在Python中使用乘法运算符来创建其多个副本？ If you want to create multiple copies of string, the multiplication operator (*) can be used.
如果要创建字符串的多个副本，则可以使用乘法运算符( * )。 Consider the example – to create N copies of a string
考虑示例– 创建字符串的N个副本 Example:
例： Input:str1 = "Hello"n = 3 logic:str2 =str1*3Output:str2= "HelloHelloHello"Program:
程序： # Python program to create N copies # of a given string # define inputs: string and N str1 = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d428426eaeecf0526a7214c55a40e982/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53be7f33e32d26e43485e3ddcfd05d8c/" rel="bookmark">
			gcc -pthread_错误-在GCC Linux中使用C程序未定义对&#39;pthread_create&#39;的引用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		gcc -pthread
在Linux中修复对'pthread_create'的未定义引用 (Fixing undefined reference to 'pthread_create' in Linux) This is a common error while compiling C program in GCC/G++ Linux. This error occurs when you are using pthread_create function to create threads in your programs.
这是在GCC / G ++ Linux中编译C程序时的常见错误。 当您使用pthread_create函数在程序中创建线程时，会发生此错误。 要解决此问题，请确保以下几点： (To fix this problem ensure following points:) Include header file pthread.h in your program.
在程序中包含头文件pthread.h 。 Add –lpthread linker flag with compilation command.
在编译命令中添加–lpthread链接器标志。 1-包括头文件 (1- Include Header file) #include &lt;stdio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53be7f33e32d26e43485e3ddcfd05d8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4eaf67e95da37b5d72e5e1019a29e06c/" rel="bookmark">
			读写锁以及线程安全的集合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		读写锁实现代码 读写锁实现线程安全的list
//读写锁实现 class MyList extends ArrayList{ ReadWriteLock rwl = new ReentrantReadWriteLock();	//读写锁 读的时候不能写,写的时候不能读 Lock rl = rwl.readLock();	//读锁	互斥锁,分配一次	//读锁写锁是一对的(假设没线程调用写锁的情况下,读锁的钥匙不是一把。读锁可以被反复分配,是一把共享锁) Lock wl = rwl.writeLock();	//写锁	互斥锁,分配一次 //线程在写的情况下,其他线程无法读 写锁没有分配的情况下(读锁可以多分配) ==&gt;读写分离 //实现高并发线程安全的集合 @Override public int size() { try{ rl.lock(); return super.size(); } finally{ rl.unlock(); } } @Override public Object get(int index) { try{ rl.lock(); return super.get(index); } finally{ rl.unlock(); } } @Override public boolean add(Object e) { try{ wl.lock(); return super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4eaf67e95da37b5d72e5e1019a29e06c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/318a38a4c011ba6d61c26508cdcbed90/" rel="bookmark">
			一些免费使用的接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 快递查询：
https://api.apiopen.top/EmailSearch?number=1012002
随机单句诗词推荐：
https://api.apiopen.top/singlePoetry
随机一首诗词推荐：
https://api.apiopen.top/recommendPoetry
搜索古诗词：
https://api.apiopen.top/searchPoetry?name=古风二首 二
搜索古诗词作者：
https://api.apiopen.top/searchAuthors?name=李白
模糊搜索古诗词（可搜索诗词名、诗词内容、诗词作者）：
https://api.apiopen.top/likePoetry?name=李白
获取宋朝古诗词：
https://api.apiopen.top/getSongPoetry?page=1&amp;count=20
获取唐朝古诗词：
https://api.apiopen.top/getTangPoetry?page=1&amp;count=20
音乐搜索接口：
https://api.apiopen.top/searchMusic
音乐电台接口：
https://api.apiopen.top/musicBroadcasting
音乐电台详情接口：
https://api.apiopen.top/musicBroadcastingDetails?channelname=public_tuijian_spring
音乐详情接口：
https://api.apiopen.top/musicDetails
音乐排行榜接口：
https://api.apiopen.top/musicRankings
音乐排行榜详情接口：
https://api.apiopen.top/musicRankingsDetails?type=1
每日视频推荐接口：
https://api.apiopen.top/todayVideo
视频大纲获取接口：
https://api.apiopen.top/videoHomeTab
视频分类推荐接口：
https://api.apiopen.top/videoCategory
视频分类推荐接口：
https://api.apiopen.top/videoCategoryDetails?id=14
根据ID推荐接口：
https://api.apiopen.top/videoRecommend?id=127398
新闻接口：
https://www.apiopen.top/journalismApi
随机推荐热门段子（包含文字、图片、GIF、视频）：
https://www.apiopen.top/satinApi?type=1&amp;page=1
随机推荐热门段子【神评版本】（包含文字、图片、GIF、视频）：
https://www.apiopen.top/satinGodApi?type=1&amp;page=1
随机推荐热门段子【神评版本】评论列表：
https://www.apiopen.top/satinCommentApi?id=27610708&amp;page=1
热门小说推荐列表
https://www.apiopen.top/novelApi
小说搜索接口
https://www.apiopen.top/novelSearchApi?name=盗墓笔记
小说详情接口
https://www.apiopen.top/novelInfoApi?name=盗墓笔记
个性网名获取接口
https://www.apiopen.top/femaleNameApi?page=1
创建应用接口
https://www.apiopen.top/createUserKey?appId=com.chat.peakchao&amp;passwd=123456
增加统计信息接口
https://www.apiopen.top/addStatistics?appKey=00d91e8e0cca2b76f515926a36db68f5&amp;type=点击统计&amp;typeId=1&amp;count=2
查询统计信息接口
https://www.apiopen.top/findStatistics?appKey=00d91e8e0cca2b76f515926a36db68f5
用户注册接口
https://www.apiopen.top/createUser?key=00d91e8e0cca2b76f515926a36db68f5&amp;phone=13594347817&amp;passwd=123654
用户登陆接口
https://www.apiopen.top/login?key=00d91e8e0cca2b76f515926a36db68f5&amp;phone=13594347817&amp;passwd=123456
--------------------- 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3581b56f40562f33f142ea1e43ebeca/" rel="bookmark">
			使用idea编写HelloWorld
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用idea编写HelloWorld 项目下载地址：解压后的 demo01
1、环境准备 开发环境：idea 2020.1.1，jdk 1.8（jdk安装教程）（idea2020.1.1安装教程）
2、创建项目 选择本地安装好的JDK版本
这里我们不选择模板创建
设置项目名和项目位置
如果本地没有文件夹的话，会弹出窗口问你是否创建，选择ok即可。
3、编写HelloWorld案例 创建类HelloWorld
将下面代码复制进去
public static void main(String[] args) { System.out.println("HelloWorld!"); } 右键空白区域选择下面的选项
运行结果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5e0e5286ca89e444e89549885868885/" rel="bookmark">
			flutter   监听list滑动 ，渐变appbar的颜色  ，滑动很卡顿 ，可以用这种方式 GlobalKey
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		页面是一个列表和一个appbar（省略其他代码）
通过GlobalKey 更新appbar的颜色
GlobalKey&lt;AppBarWeightState&gt; barKey; @override void initState() { super.initState(); barKey = GlobalKey(); _retrieveData(); } 这个是 appbar weight
import 'package:flutter/cupertino.dart'; import 'package:flutter/material.dart'; class AppBarWeight extends StatefulWidget { AppBarWeight(Key barKey):super(key:barKey); @override State&lt;StatefulWidget&gt; createState() { return new AppBarWeightState(); } } class AppBarWeightState extends State&lt;AppBarWeight&gt; { int _opacity = 0; @override Widget build(BuildContext context) { return AppBar( elevation: 0, backgroundColor: Theme.of(context).primaryColor.withAlpha(_opacity), title: Text("content", style: TextStyle(fontSize: 16, color: Colors.grey)), ); } void onChange(int alpha) { setState(() { _opacity = alpha; }); } } return Column( children: &lt;Widget&gt;[ AppBarWeight(barKey),//需要更新的 weight Expanded( child: NotificationListener&lt;ScrollNotification&gt;( ///此方法需要一个返回值，表示是否拦截住notification，如果是true，那么notifcation到此为止； ///如果是false，那么notification会继续向更外层widget传递。参数ScrollNotification包含了监听到的信息。 onNotification: (ScrollNotification notification) { ScrollMetrics metrics = notification.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5e0e5286ca89e444e89549885868885/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f2db13c44980fd5ec35cb48f3ff38ab/" rel="bookmark">
			Error:(3, 32) java: 程序包org.springframework.boot不存在
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天使用idea创建springboot项目，报错
Error:(4, 52) java: 程序包org.springframework.beans.factory.annotation不存在 Error:(5, 47) java: 程序包org.springframework.web.bind.annotation不存在 Error:(6, 47) java: 程序包org.springframework.web.bind.annotation不存在 Error:(7, 39) java: 程序包org.springframework.web.servlet不存在 Error:(9, 2) java: 找不到符号 符号: 类 RestController Error:(10, 2) java: 找不到符号 符号: 类 RequestMapping Error:(13, 6) java: 找不到符号 符号: 类 Autowired 位置: 类 com.mystery.controller.UserController Error:(17, 6) java: 找不到符号 符号: 类 RequestMapping 位置: 类 com.mystery.controller.UserController E:\workspace\IDEAWorkSpace\demo\demo09\src\main\java\com\mystery\dao\UserMapper.java Error:(3, 38) java: 程序包org.springframework.stereotype不存在 Error:(5, 2) java: 找不到符号 符号: 类 Repository E:\workspace\IDEAWorkSpace\demo\demo09\src\main\java\com\mystery\Demo09Application.java Error:(3, 32) java: 程序包org.springframework.boot不存在 Error:(4, 46) java: 程序包org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f2db13c44980fd5ec35cb48f3ff38ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2b01e93f46fd549063c0007882de3b8/" rel="bookmark">
			Lamda链接查询、左连接内连接、分组、分页、排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		List&lt;User&gt; userList = new List&lt;User&gt; {
new User {Id=1,Name="LiBai",Age=20},
new User {Id=2,Name="DuFu",Age=21},
new User {Id=3,Name="ZhangSan",Age=22}
};
List&lt;Book&gt; bookList = new List&lt;Book&gt; {
new Book{ Id=1,Name="C",UserId=3},
new Book{ Id=1,Name="C++",UserId=2}
};
//内连接，分页.Skip(0).Take(10)；正序排序.OrderBy(x=&gt;x.Id)；倒序排列.OrderByDescending(x=&gt;x.Id)
var joinList = userList.Join(bookList, x =&gt; x.Id, y =&gt; y.UserId, (x, y) =&gt; new { x, y })
.Select(z =&gt; new User
{
Id = z.x.Id,
Name = z.x.Name,
Age = z.x.Age,
Dynasty = z.y.Name
}).Skip(0).Take(10).OrderBy(x=&gt;x.Id).ToList();
//左连接①
var groupList = userList.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2b01e93f46fd549063c0007882de3b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a5d1c4014e984d73a85acfbd364744e/" rel="bookmark">
			机器学习:算法视角pdf_何时使用不同的机器学习算法：简单指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		机器学习:算法视角pdf
If you’ve been at machine learning long enough, you know that there is a “no free lunch” principle — there’s no one-size-fits-all algorithm that will help you solve every problem and tackle every dataset.
如果您已经在机器学习领域学习了足够长的时间，那么您就会知道有“免费午餐”的原则-没有一种万能的算法可以帮助您解决每个问题并解决每个数据集。 I work for Springboard — we’ve put a lot of research into machine learning training and resources. At Springboard, we offer the first online course with a machine learning job guarantee.
我在Springboard工作-我们对机器学习培训和资源进行了大量研究。 在Springboard， 我们提供了第一个具有机器学习工作保障的在线课程 。 What helps a lot when confronted with a new problem is to have a primer for what algorithm might be the best fit for certain situations.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a5d1c4014e984d73a85acfbd364744e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f94dc107bbcf1b61cfce614377c50b03/" rel="bookmark">
			修改idea背景颜色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.IDEA默认有3种背景颜色
路径为File-&gt;settings-&gt;Editor-&gt;Color Scheme可以设置软件默认颜色，旁边的小齿轮添加颜色名字
二.IDEA扩展颜色（护眼绿）
手动设置护眼绿的RGB颜色
路径：File-&gt;Settings-&gt;Editor-&gt;Color Scheme-&gt;General
到这里代码编辑界面设置成了护眼绿色，但是你会发现，项目界面和调试界面并没有更改成功。
在这里说下另一个方法：
File -&gt;Settings -&gt; Appearance &amp; Behavior -&gt; File Colors ，选择+号 选择Project file，就可以把左边项目界面那里改变颜色。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ab215870a2e9d6607f302bf45b04bd1/" rel="bookmark">
			RuntimeError: Address already in use
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		同时跑两个pytorch DDP程序时，会出现下列错误：
Traceback (most recent call last): File "train_tasks.py", line 471, in &lt;module&gt; main() File "train_tasks.py", line 211, in main torch.distributed.init_process_group(backend="nccl") File ".../anaconda3/envs/vilbert/lib/python3.6/site-packages/torch/distributed/distributed_c10d.py", line 406, in init_process_group store, rank, world_size = next(rendezvous(url)) File ".../anaconda3/envs/vilbert/lib/python3.6/site-packages/torch/distributed/rendezvous.py", line 143, in _env_rendezvous_handler store = TCPStore(master_addr, master_port, world_size, start_daemon) RuntimeError: Address already in use 解决方案：
在python -m torch.distributed.launch后指定一个未被使用的端口--master_port 9999。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f11c968c65a3925c195dc2fa97528f9e/" rel="bookmark">
			蓝牙电话（hfp）与Android audio hal的关联
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自https://blog.csdn.net/bberdong/article/details/82912670
通话的时候，需要打开音频通路，音频设备（上下行都要）
我们从这里开始：
packages/apps/Bluetooth/src/com/android/bluetooth/hfpclient
// in Connected state
private void processAudioEvent(int state, BluetoothDevice device) {
...
switch (state) {
...
case HeadsetClientHalConstants.AUDIO_STATE_CONNECTED:
routeHfpAudio(true);
}
}
​
private void acceptCall(int flag) {
...
if (flag == BluetoothHeadsetClient.CALL_ACCEPT_HOLD) {
// When unholding a call over Bluetooth make sure to route audio.
routeHfpAudio(true);
}
...
}
两种场景，一个是接通电话，一个是电话hold之后，unhold的时候。都需要去调用routeHfpAudio(true).我们简化问题，只分析打开的情况。
static synchronized void routeHfpAudio(boolean enable) {
...
if (enable &amp;&amp; !sAudioIsRouted) {
sAudioManager.setParameters("hfp_enable=true");
} else if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f11c968c65a3925c195dc2fa97528f9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dd22e9a1d5d614ddfd21dcf9d35fc9d/" rel="bookmark">
			module ‘os‘ has no attribute ‘listdir‘   ----------------python报错解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		module ‘os’ has no attribute ‘listdir’
原因是文件名用了os 和模块名一样是不行的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c779d9b02268728f74ad6e37d7b50121/" rel="bookmark">
			Serial Old收集器和Parallel Old收集器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Serial Old收集器
Serial Old是 Serial收集器的老年代版本；
1、特点
针对老年代；
采用"标记-整理"算法（还有压缩，Mark-Sweep-Compact）；
单线程收集；
Serial/Serial Old收集器运行示意图如下：
2、应用场景
主要用于Client模式；
而在Server模式有两大用途：
（A）、在JDK1.5及之前，与Parallel Scavenge收集器搭配使用（JDK1.6有Parallel Old收集器可搭配）；
（B）、作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用
Parallel Old收集器
Parallel Old垃圾收集器是Parallel Scavenge收集器的老年代版本；
JDK1.6中才开始提供；
1、特点
针对老年代；
采用"标记-整理"算法；
多线程收集；
Parallel Scavenge/Parallel Old收集器运行示意图如下：
2、应用场景
JDK1.6及之后用来代替老年代的Serial Old收集器；
特别是在Server模式，多CPU的情况下；
这样在注重吞吐量以及CPU资源敏感的场景，就有了Parallel Scavenge加Parallel Old收集器的"给力"应用组合；
3、设置参数
"-XX:+UseParallelOldGC"：指定使用Parallel Old收集器；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2be63e9897428915824a596a2f88e7c6/" rel="bookmark">
			项目集成gitlab-ci
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 gitlab CI/CD 是一种可以持续集成,持续交付和部署的一个工具.不需要人工去干涉 如何工作 通过构建项目中的.gitlab-ci.yml 文件.指定测试,部署的脚本.当 gitlab 监听到改脚本时,使用 gitlab runner 的工具来运行脚本.
.gitlab-ci.yml 文件中多个任务组成一个管道.管道的状态也会在 gitlab 的图形化界面上看到
配置过程 需要两个条件,一个 runner,一个.gitlab-ci.yml 文件.才可完成配置
配置 runner 文档地址:https://docs.gitlab.com/runner/install/osx.html
以 macOS 为例
下载 Gitlab Runner 的二进制文件
sudo curl --output /usr/local/bin/gitlab-runner https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-darwin-amd64 注意: 这时下载二进制文件可能会特别慢,可以用迅雷先下载下这个二进制文件.再用 koa-static 起一个静态服务,可以通过 url 访问到这个文件.因为 curl 需要一个 url
sudo curl --output /usr/local/bin/gitlab-runner 静态服务文件路径 将二进制文件输出到/usr/local/bin/gitlab-runner 下
授予权限(因为 bin 目录下的文件都是只读的)
sudo chmod +x /usr/local/bin/gitlab-runner
注册 Runner
安装 Docker(https://docs.docker.com/),并启动
注册 Runner
sudo gitlab-runner register
输入 Gitlab 实例的 URL (登录 gitlab 在 Settings -&gt; CI/CD -&gt; Runners 中可以查看 url 和 token)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2be63e9897428915824a596a2f88e7c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bdc5a7b11bf3e64e9a7c8f7c3e0a230/" rel="bookmark">
			最全Java各修饰符详解（接口、类、方法、变量）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、总述 类、方法、成员变量和局部变量的可用修饰符
修饰符类成员访求构造方法成员变量局部变量abstract（抽象的）√√－－－static （静态的）－√－√－public（公共的）√√√√－protected（受保护的）√√√－private（私有的）－√√√－synchronized（同步的）－√－－－native（本地的）－√－－－transient（暂时的）－－－√－volatie（易失的）－－－√－final（不要改变的）√√－√√ 二、类修饰符 访问修饰符：公共类修饰符public（只能是它）
非访问控制符：抽象类修饰符 abstract 、最终类修饰符 final
（1）公共类修饰符 public ： Java 语言中类的访问控制符只有 public 即公共的。每个 Java 程序的有且只有一个类是 public，它被称为主类 ，其他外部类无访问控制修饰符，具有包访问性。注意：一个类的内部类可以被其他访问控制修饰符protected、default、 private修饰，相当于类的成员。
（2）抽象类修饰符 abstract ：用 abstract 修饰符修饰的类，被称为抽象类。
（3）最终类修饰符 final ：当一个类不能被继承时可用修饰符 final修饰为最终类。被定义为 final 的类通常是一些有固定作用、用来完成某种标准功能的类。final关键字不能用来抽象类和接口
（4）类缺省访问控制符：如果一个类没有访问控制符，说明它具有缺省的访问控制符特性。此时，这个类只能被同一个包中的类访问或引用。这一访问特性又称为包访问性。
1、如果一个类包含抽象方法（用abstract修饰的方法），那么这个类必须是抽象类
2、继承抽象类的子类必须重写父类所有的抽象方法（用abstract修饰的方法）。否则，该子类也必须声明为抽象类（也必须用abstract修饰）。最终，必须有子类实现该父类的抽象方法，否则，从最初的父类到最终的子类都不能创建对象，失去意义。
接口通常是不带修饰符的，一般都是public interface
以上是对于外部类，外部类只能用public、adstract、final修饰，如果是内部类类则可以用 修饰成员变量的修饰符修饰内部类，比如 private, static, protected 修饰。
三、方法修饰符 1、按修饰符分 访问控制修饰符：公共访问控制符public、保护访问控制符protected、缺省默认default、私有访问控制符private
非访问控制符：抽象方法控制符abstract 、静态方法控制符static 、最终方法控制符final 、本地方法控制符native 、同步方法控制符synchronized
（1）抽象方法控制符 abstract ：用修饰符 abstract 修饰的方法称为抽象方法。抽象方法仅有方法头，没有方法体和操作实现。
（2）静态方法控制符 static ：用修饰符 static 修饰的方法称为静态方法。静态方法是属于整个类的类方法；而不使用static 修饰、限定的方法是属于某个具体类对象的方法。 由于 static方法是属于整个类的，所以它不能操纵和处理属于某个对象的成员变量，而只能处理属于整个类的成员变量，即 static 方法只能处理 static的域。
（3）最终方法控制符 final ：用修饰符 final修饰的方法称为最终方法。最终方法是功能和内部语句不能更改的方法，即最终方法不能重写覆盖（可以被继承）。final固定了方法所具有的功能和操作，防止当前类的子类对父类关键方法的错误定义，保证了程序的安全性和正确性。所有被 private 修饰符限定为私有的方法，以及所有包含在 final 类 ( 最终类) 中的方法，都被认为是最终方法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1bdc5a7b11bf3e64e9a7c8f7c3e0a230/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ada0fbb68a16be8ebe1e72c72745b24b/" rel="bookmark">
			视觉十四讲：第八讲_光流法(特征点追踪)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.直接法的引出 特征点估计相机运动的方法，主要是在关键点和描述子的计算非常耗时；而且在纹理信息比较少的情况下，特征点的数量会明显减少。
解决方案：
1.保留特征点，只计算关键点，不计算描述子，然后使用光流法跟踪特征点的运动，从而实现特征点的匹配。
2.只计算关键点，不计算描述子。使用直接法计算下一时刻特征点的位置，从而实现特征点的匹配。
第一种方法，是把特征点匹配换成光流法，估计相机运动时仍然采用对极几何、PnP或ICP算法。仍然需要计算角点。
第二种方法，是通过像素的灰度信息，同时估计相机运动和点的投影，不要求提取到的点必须为角点，甚至可以是随机的选点。
2.LK光流法 光流法基于灰度不变强假设。
对于t时刻位于(x,y)处的像素，设t+dt时刻它运动到了(x+dx,y+dy)处，由于灰度不变，所以有：I(x,y,t) = I(x+dx,y+dy,t+dt).
将右边进行泰勒展开，保留一阶项：
\(I(x+dx,y+dy,t+dt) \approx I(x,y,t)+ \frac{\partial I}{\partial x}dx + \frac{\partial I}{\partial y}dy + \frac{\partial I}{\partial t}dt\)
由于I(x,y,t) = I(x+dx,y+dy,t+dt)，所以：\(\frac{\partial I}{\partial x}dx + \frac{\partial I}{\partial y}dy + \frac{\partial I}{\partial t}dt = 0\)
两边除dt，得：
\(\frac{\partial I}{\partial x} \frac{dx}{dt} + \frac{\partial I}{\partial y} \frac{dy}{dt} =- \frac{\partial I}{\partial t}\)
其中dx/dt为像素在x轴上的运动速度，dy/dt为y轴上的速度，记为u,v。同时\(\frac{\partial I}{\partial x}\)为该点在x方向的梯度，另一项为y方向的梯度，记为\(I_{x}\),\(I_{y}\),写成矩阵形式为：
我们计算的是u、v，所以一个点无法计算，故假设该点附近的一个窗口内的像素都具有相同的运动。
考虑一个大小为w*w的窗口,共有\(w^{2}\)数量的像素，有\(w^{2}\)个方程：
这是一个关于u,v的超定方程，传统解法是求最小二乘解
这样就得到像素在图像间的运动速度u,v。由于像素梯度仅在局部有效，如果一次迭代不够好，可以多迭代几次这个方程。
图像梯度：
图像梯度一般也可以用中值差分：
dx(i,j) = [I(i+1,j) - I(i-1,j)]/2;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ada0fbb68a16be8ebe1e72c72745b24b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c7cefad838502452e3bc72618539a58/" rel="bookmark">
			数据的表示之原码，补码，反码和移码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、机器数和真值
１、机器数
２、真值
二、原码反码补码和移码的基础概念和计算方法
１．原码
２．反码
３．补码
４．移码
三、为何要使用原码反码，补码和移码
为何还会有反码和补码呢？
四、数值表示范围
五、原码反码补码再深入
一、机器数和真值 在学习原码反码，补码和移码之前需要先了解机器数和真值的概念。
１、机器数 一个数在计算机中的二进制表示形式，叫做这个数的机器数。机器数是带符号的，在计算机中用一个数的最高位存放符号正数为０负数为１。
比如，十进制中的数+３，计算机字长为８位，转换成二进制就是0000 0011。如果是-３，就是1000 0011。
那么，这里的0000 0011和1000 0011就是机器数。
２、真值 因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数1000 0011，其最高位１代表负，其真正数值是-３而不是形式值131（1000 0011转换成十进制等于131）。
所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。例：0000 0001的真值＝+000 0001＝+１，1000 0001的真值＝–000 0001＝–１
二、原码反码补码和移码的基础概念和计算方法 在探求机器为何要使用补码之前让我们先了解原码反码，补码和移码的概念。对于一个数计算机要使用一定的编码方式进行存储。原码反码补码和移码是机器存储一个具体数字的编码方式。
１．原码 原码就是符号位加上真值的绝对值即用第一位表示符号其余位表示值。比如如果是８位二进制：
［＋１］原＝００００ ０００１
［－１］原＝１０００ ０００１
第一位是符号位。因为第一位是符号位所以８位二进制数的取值范围就是：
［１１１１　１１１１０１１１　１１１１］＝＝＞［－１２７１２７］
２．反码 反码的表示方法是：
正数的反码是其本身；负数的反码是在其原码的基础上符号位不变，其余各个位取反。 ［＋１］＝［０００００００１］原　＝［０００００００１］反　［－１］＝［１００００００１］原　＝［１１１１１１１０］反
３．补码 补码的表示方法是：
正数的补码就是其本身；负数的补码是在其原码的基础上符号位不变其余各位取反最后＋１（即在反码的基础上＋１）。 ［＋１］＝［０００００００１］原＝［０００００００１］反＝［０００００００１］补　［－１］＝［１００００００１］原＝［１１１１１１１０］反＝［１１１１１１１１］补
４．移码 移码是作用于阶码上的，移码的表示方法是：
正数的最高符号位用１表示；负数的最高符号位用０表示；其余原码位不变。 ［＋１］＝［０００００００１］原　＝［０００００００１］反＝［０００００００１］补＝［１００００００１］移　［－１］＝［１００００００１］原＝［１１１１１１１０］反＝［１１１１１１１１］补＝［０００００００１］移
三、为何要使用原码反码，补码和移码 图1　数据的表示
计算机可以有三种编码方式表示一个数。对于正数，因为三种编码方式的结果都相同，所以不需要过多解释。
［＋１］＝［０００００００１］原 ＝［０００００００１］反 ＝［０００００００１］补
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c7cefad838502452e3bc72618539a58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6be707874c4d97d22addd3fc90d5a8ea/" rel="bookmark">
			深入理解PCA(主成分分析法)算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题引入 现有某商店分析影响销售额的因素有哪些，做了以下调查。 日期 x 1 \textbf{x}_1 x1​2679空气质量 x 2 \textbf{x}_2 x2​10603090上班时间 x 3 \textbf{x}_3 x3​8897 假装目前这三个影响因素太多，需要降维处理。
原始思想
如果要降到2维，最直接的做法就是将其中一个因素 x i \textbf{x}_i xi​去除，然后分析剩余的两个，但是这种做法过于粗暴，是否存在一种更加合理的方法去处理。
符号声明 x i \textbf{x}_i xi​代表表格中第i行， x j \textbf{x}_j xj​代表表格中第j列， x i j x_{ij} xij​代表矩阵中第(i,j)个元素，其中 i = 1 , 2 , ⋯ , m ; j = 1 , 2 , ⋯ , n i=1,2,\cdots,m;j=1,2,\cdots,n i=1,2,⋯,m;j=1,2,⋯,n。
基本思想 方案一
求出每个因素 x i \textbf{x}_i xi​的方差
方差公式 s i 2 = 1 n − 1 ∑ j = 1 n ( x i j − x ‾ i ) 2 s_i^2=\frac{1}{n-1}\sum_{j=1}^{n}(x_{ij}-\overline\textbf{x}_i)^2 si2​=n−11​j=1∑n​(xij​−xi​)2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6be707874c4d97d22addd3fc90d5a8ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f172cec749e308011721b47aa54bcf3b/" rel="bookmark">
			如何在eclipse中打开命令行窗口？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		window-&gt;show view-&gt;Terminal
这样就打开了Terminal窗口，效果如下所示：
然后点击右上角所指的小电脑图标，此时可以设置一些信息
设置好了之后，就可以点击确定，之后就可以在eclipse中使用命令行窗口了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16c8f1421792076dc9469f938ad55cc2/" rel="bookmark">
			Android 圆角闪光遮照效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果图实现原理代码 创建自定义属性自定义控件使用方法 PorterDuff.Mode 简介 示例图代码示例PorterDuff.Mode 效果图示 1. ADD2. CLEAR3. DARKEN4. DST5. DST_ATOP6. DST_IN7. DST_OUT8. DST_OVER9. LIGHTEN10. MULTIPLY11. OVERLAY12. SCREEN13. SRC14. SRC_ATOP15. SRC_IN16. SRC_OUT17. SRC_OVER18. XOR 文章目录 效果图实现原理代码创建自定义属性自定义控件使用方法 PorterDuff.Mode 简介示例图代码示例PorterDuff.Mode 效果图示1. ADD2. CLEAR3. DARKEN4. DST5. DST_ATOP6. DST_IN7. DST_OUT8. DST_OVER9. LIGHTEN10. MULTIPLY11. OVERLAY12. SCREEN13. SRC14. SRC_ATOP15. SRC_IN16. SRC_OUT17. SRC_OVER18. XOR 效果图 实现原理 通过设置 xfermode 取光亮与底下的像素的最大亮度，来实现闪光遮照。
代码 创建自定义属性 &lt;declare-styleable name="MyFlashLightingView"&gt; &lt;attr name="roundedCornerRadius" format="dimension"/&gt; &lt;attr name="animDuration" format="float"/&gt; &lt;/declare-styleable&gt; 属性描述roundedCornerRadius圆角角度，dpanimDuration闪光从左到右时间，秒，Float 自定义控件 import android.animation.ValueAnimator import android.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16c8f1421792076dc9469f938ad55cc2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/121754de58f4402667bf9d188dc95a57/" rel="bookmark">
			c&#43;&#43;模拟点击任务管理器程序图标 置顶显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在研究模拟任务管理器图标点击效果，在网上搜索了一些信息
主要思路是先把最小化或者在其他界面后面的界面（官方不在Z轴的顶层）
显示出来界面-》一直置于最顶层-》取消置于最顶层-》激活窗口
代码如下：
HWND hProgramWnd = ::FindWindow(NULL,L"XXXXX");
if (hProgramWnd)
{
//个别人用SentMessage，容易产生阻塞
PostMessage(hProgramWnd, WM_SYSCOMMAND, SC_RESTORE, 0);
SetWindowPos(hProgramWnd,HWND_TOPMOST,0,0,0,0,SWP_NOMOVE | SWP_NOSIZE);
SetWindowPos(hProgramWnd,HWND_NOTOPMOST,0,0,0,0,SWP_NOMOVE | SWP_NOSIZE);
SetForegroundWindow(hProgramWnd);
CloseHandle(hProgramWnd);
}
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7525696060363c56e7c639a939ee9563/" rel="bookmark">
			surf和sift算法被申请专利后部分opencv版本无法使用后的安装pycharm&#43;opencv使用surf和sift算法教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		surf和sift算法被申请专利后部分opencv版本无法使用后的安装pycharm+opencv使用surf和sift算法教程 https://blog.csdn.net/qq_41840148/article/details/101611176
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a814a4d77905cbb63bff24edbc025ec9/" rel="bookmark">
			FlinkSql on yarn 提交踩坑记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FlinkSql on yarn 提交踩坑记录 最近需要实现一个flinksql执行引擎，实现前台只需关注sql编写，后台自动提交flinksql到yarn集群中，由于初次接触flinksql，对flinksql研究不深，在实现过程中遇到很多问题。其中一个问题研究了挺长时间，相信很多初次玩flinksql的朋友们也会遇到这个问题，所以在这里分享一下问题的解决方法。
我是在本地跑通了flinksql的kafka to mysql案例，准备通过flink run 命令提交到yarn集群执行，结果遇到如下问题：
------------------------------------------------------------
The program finished with the following exception:
org.apache.flink.client.program.ProgramInvocationException: The main method caused an error: findAndCreateTableSource failed.
at org.apache.flink.client.program.PackagedProgram.callMainMethod(PackagedProgram.java:335)
at org.apache.flink.client.program.PackagedProgram.invokeInteractiveModeForExecution(PackagedProgram.java:205)
at org.apache.flink.client.ClientUtils.executeProgram(ClientUtils.java:138)
at org.apache.flink.client.cli.CliFrontend.executeProgram(CliFrontend.java:662)
at org.apache.flink.client.cli.CliFrontend.run(CliFrontend.java:210)
at org.apache.flink.client.cli.CliFrontend.parseParameters(CliFrontend.java:893)
at org.apache.flink.client.cli.CliFrontend.lambda$main$10(CliFrontend.java:966)
at java.security.AccessController.doPrivileged(Native Method)
at javax.security.auth.Subject.doAs(Subject.java:422)
at org.apache.hadoop.security.UserGroupInformation.doAs(UserGroupInformation.java:1754)
at org.apache.flink.runtime.security.HadoopSecurityContext.runSecured(HadoopSecurityContext.java:41)
at org.apache.flink.client.cli.CliFrontend.main(CliFrontend.java:966)
Caused by: org.apache.flink.table.api.TableException: findAndCreateTableSource failed.
at org.apache.flink.table.factories.TableFactoryUtil.findAndCreateTableSource(TableFactoryUtil.java:55)
at org.apache.flink.table.factories.TableFactoryUtil.findAndCreateTableSource(TableFactoryUtil.java:92)
at org.apache.flink.table.planner.plan.schema.CatalogSourceTable.findAndCreateTableSource(CatalogSourceTable.scala:162)
at org.apache.flink.table.planner.plan.schema.CatalogSourceTable.tableSource$lzycompute(CatalogSourceTable.scala:65)
at org.apache.flink.table.planner.plan.schema.CatalogSourceTable.tableSource(CatalogSourceTable.scala:65)
at org.apache.flink.table.planner.plan.schema.CatalogSourceTable.toRel(CatalogSourceTable.scala:82)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a814a4d77905cbb63bff24edbc025ec9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa779b15655e193a1520eaa07421808a/" rel="bookmark">
			iptables详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		iptables详解 一：Linux包过滤防火墙概述1.1：netfilter1.2：iptables 二：iptables的表、链结构2.1：5种规则链2.2：4个规则表2.3：表、链结构示意图 三：数据包过滤的匹配流程四：iptables的语法格式4.1：语法构成4.2：数据包的常见控制类型4.3：常用选项4.3.1：添加新的规则4.3.2：查看规则列表4.3.3：删除、清空、修改规则4.3.4：设置默认策略 4.4：规则的匹配条件4.4.1：通用匹配4.4.2：隐含匹配4.4.3：显式匹配 五：SNAT/DNAT策略六：iptables-save与iptables-restore 一：Linux包过滤防火墙概述 1.1：netfilter 位于Linux内核中的包过滤功能体系称为Linux防火墙的“内核态” 1.2：iptables 位于/sbin/iptables，用来管理防火墙规则的工具称为Linux防火墙的“用户态” netfilter/iptables（下文中简称为iptables）组成Linux平台下的包过滤防火墙，与大多数的Linux软件一样，这个包过滤防火墙是免费的，它可以代替昂贵的商业防火墙解决方案，完成封包过滤、封包重定向和网络地址转换（NAT）等功能。
二：iptables的表、链结构 2.1：5种规则链 规则的作用：对数据包进行过滤或处理链的作用：容纳各种防火墙规则链的分类依据：根据处理数据包的不同时机 5种规则链
INPUT：处理入站数据包OUTPUT：处理出站数据包FORWORD：处理转发数据包PREROUTING：在进行路由选择前处理数据包POSTROUTING：在进行路由选择后处理数据包 2.2：4个规则表 表的作用：容纳各种规则链表的划分依据：防火墙规则的作用相似 4个规则表：
raw表：确实是否对数据包进行状态跟踪mangle表：拆解报文，做出修改，并重新封装 的功能nat表：网络地址转换功能filter表：包过滤功能 2.3：表、链结构示意图 三：数据包过滤的匹配流程 规则表之间的顺序
raw–&gt;mangle–&gt;nat–&gt;filter规则链之间的顺序
入站：PREROUTING–&gt;INPUT
出站：OUTPUT–&gt;POSTROUTING
转发：PREROUTING–&gt;FORWORD–&gt;POSTROUTING规则链里的匹配顺序
按顺序依次检查、匹配即停止
若找不到相应的匹配规则，则按该链的默认策略处理 四：iptables的语法格式 4.1：语法构成 iptables [-t 表名] 选项 [链名] [条件] [-j 控制类型]
注意事项：
不指定表名时，默认指filter表不指定链名时，默认指表内的所有链除非设置链的默认策略，否则必须指定匹配条件选项、链名、控制类型使用大写字母，其余均为小写 4.2：数据包的常见控制类型 ACCEPT：允许通过DROP：直接丢弃，不给任何回应REJECT：拒绝通过，必要时会给出提示LOG：记录日志信息，然后传给下一条规则继续匹配SNAT：源地址转换DNAT：目标地址转换 4.3：常用选项 4.3.1：添加新的规则 -A：在链的末尾追加一条规则-I：在链的开头（或指定序号）插入一条规则 [root@server ~]# iptables -t filter -A INPUT -p tcp -j ACCEPT [root@server ~]# iptables -t filter -I INPUT -p udp -j ACCEPT [root@server ~]# iptables -t filter -I INPUT 2 -p icmp -j ACCEPT 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa779b15655e193a1520eaa07421808a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0897336e73ae4a1125b14a6fd923dc1/" rel="bookmark">
			实习面经（网易雷火）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2020年7月22号开始投了简历，想拿华为试个手，结果只有秋招了。。就投了雷火和字节，复习了一星期，问的东西比较基础，还是要多练练
雷火是云平台开发，也是我的第一次面试
一面电话面 自我介绍
项目
网络closewait状态
红黑树的原理
数据库的B+树
索引的使用
HashMap的底层实现
linux的grep如何使用
会不会spring，会不会docker 我：啊啊啊我在学，面试官你等我学成。
编程题：甲乙两人一天的时间段由各个安排，计算重叠的时间段
还有一些记不得了:(
总体都回答出来了，面试官也很好问的不是很细，全程快乐的聊天
二面视频面 自我介绍
动态规划实现原理
分治法
项目
数据库索引
并发线程状态
JVM的对象创建过程
JVM内存结构
JVM的堆结构
类加载
又问了docker，我就把docker看的博客说了一下，没用过但是理解是这样的巴拉巴拉
算法题：三色球换彩票
最爽的一面，聊了10分钟项目，各种讨论，问题也很简单，网易面试官确实nice
三面视频面 自我介绍（已经背的太熟了）
设计模式
反射原理
反射体现的设计模式
说说linux的命令
ls -lah每个介绍一下
-rwx什么意思，文件夹关闭x会导致什么问题
touch命令
红黑树插入元素要变换几次
Jvm内存溢出
GC垃圾清理的过程
treemap和hashmap的区别和原理
http-put的作用
arraylist的长度扩展
项目介绍
手撕代码：二叉树的宽度
有些很细的点被问住了，手撕代码写的很溜，希望自己能过吧 0.0
后记 最后顺利的拿到了日常实习的offer，但是学校要求返校，唉，fine
回学校继续打工😭
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35f6e46cb470dbc17920fffb4dcaa365/" rel="bookmark">
			115个java面试题（英文）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		115个java面试题（英文）
kris1985 2014-04-08 10:58:21 4152 收藏 2
分类专栏： java
115 Java Interview Questions and Answers – The ULTIMATE List
by Sotirios-Efstathios Maneas on April 7th, 2014 | Filed in: Core Java Tags: Interview, Interview questions, Java Applets, JDBC, JSP, RMI, Servlets, Swing
In this tutorial we will discuss about different types of questions that can be used in a Java interview, in order for the employer to test your skills in Java and object-oriented programming in general.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35f6e46cb470dbc17920fffb4dcaa365/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d74387f4c19b071f42c2d68376de2a6e/" rel="bookmark">
			Java英文面试题（核心知识篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Question: What is transient variable?
Answer: Transient variable can’t be serialize. For example if a variable is declared as transient in a Serializable class and the class is written to an ObjectStream, the value of the variable can’t be written to the stream instead when the class is retrieved from the ObjectStream the value of the variable becomes null.
Question: Name the containers which uses Border Layout as their default layout?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d74387f4c19b071f42c2d68376de2a6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/924b6428ab0e34c2823dd1cdbea33814/" rel="bookmark">
			Java常用英语汇总(面试必备)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java常用英语汇总(面试必备) abstract (关键字) 抽象 [’.bstr.kt]
access vt.访问,存取 [’.kses]‘(n.入口,使用权)
algorithm n.算法 [’.lg.riem]
annotation [java]代码注释 [.n.u’tei…n]
anonymous adj.匿名的[.'n.nim.s]‘
(反义：directly adv.直接地,立即[di’rektli, dai’rektli])
apply v.应用,适用 [.'plai]
application n.应用,应用程序 [,.pli’kei…n]‘ (application crash 程序崩溃)
arbitrary a.任意的 ['ɑ:bitr.ri]
argument n.参数;争论,论据 ['ɑ:gjum.nt]‘(缩写args)
assert (关键字) 断言 [.'s.:t] ‘ (java 1.4 之后成为关键字)
associate n.关联(同伴,伙伴) [.'s.u.ieit]
attribute n.属性(品质,特征) [.'tribju:t]
boolean (关键字) 逻辑的, 布尔型
call n.v.调用; 呼叫; [k.:l]
circumstance n.事件(环境,状况) ['s.:k.mst.ns]
crash n.崩溃,破碎 [kr…]
cohesion 内聚,黏聚,结合 [k.u’hi:…n]
a class is designed with a single, well-focoused purpose.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/924b6428ab0e34c2823dd1cdbea33814/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/450dca6db321171d66a3efa1bbaad1d6/" rel="bookmark">
			Servlet（Xmind思维导图）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a86e32453e93b73ccf9cac5286bec86e/" rel="bookmark">
			数据结构与算法系列（三）—选择排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 大家好，牧码心今天给大家推荐一篇数据结构与算法系列（三）—选择排序的文章，希望对你有所帮助。大纲如下:
选择排序基本介绍选择排序图文说明选择排序时空复杂度和稳定性选择排序具体实现 选择排序基本介绍 选择排序 是一种较简单的排序算法，排序过程类似于队伍排队，每次选出相对最高或最小的同学排列。相比于冒泡排序省去了每轮交换多次的开销。其基本思想是：首先在未排序的数列中找到最小(or最大)元素，然后将其存放到数列的起始位置；接着，再从剩余未排序的元素中继续寻找最小(or最大)元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。
选择排序图文说明 下面以数列{20,40,30,10,60,50}为例，演示选择排序过程
排序流程说明：
第1趟：i=0。找出a[1…5]中的最小值a[3]=10，然后将a[0]和a[3]互换。 数列变化：20,40,30,10,60,50 – &gt; 10,40,30,20,60,50第2趟：i=1。找出a[2…5]中的最小值a[3]=20，然后将a[1]和a[3]互换。 数列变化：10,40,30,20,60,50 – &gt; 10,20,30,40,60,50第3趟：i=2。找出a[3…5]中的最小值，由于该最小值大于a[2]，该趟不做任何处理。第4趟：i=3。找出a[4…5]中的最小值，由于该最小值大于a[3]，该趟不做任何处理。第5趟：i=4。交换a[4]和a[5]的数据。 数列变化：10,20,30,40,60,50 – &gt; 10,20,30,40,50,60 选择排序时空复杂度和稳定性 时间复杂度空间复杂度稳定性O(n^2)O(1)不稳定 说明 时间复杂度：选择排序每一轮需要选出最小值min，在交互到最左边的时间复杂度为O(n)，共需要进行n-1轮。所以总的时间复杂度为O(n^2) ；空间复杂度 ：选择排序是原地排序，没有产生额外的空间，则为O(1) ；稳定性 ：选择排序是不稳定的，比如被排序的序列存在多个相同的的元素时，该排序会打乱各元素原有的相对顺序。 选择排序实现 选择排序（java版） /* * @Author:greekw * @Desc: 选择排序，类比站队 * @Date 0:04 2020/7/22 * @Param [array] * @return void **/ public static void selectSort(int[] array){ for (int i = 0; i &lt; array.length ; i++) { // 设置初始的最小位置 int minIndex = i; // 找出最小元素的位置 for (int j = i; j &lt; array.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a86e32453e93b73ccf9cac5286bec86e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2d62ff2c079406e1a52bc96896321f6/" rel="bookmark">
			值得推荐的C/C&#43;&#43;框架和库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		值得学习的C语言开源项目 文章较长，建议先收藏慢慢观看~
Libevent libev是一个开源的事件驱动库，基于epoll，kqueue等OS提供的基础设施。其以高效出名，它可以将IO事件，定时器，和信号统一起来，统一放在事件处理这一套框架下处理。基于Reactor模式，效率较高，并且代码精简（4.15版本8000多行），是学习事件驱动编程的很好的资源。
下载链接：https://github.com/libevent/libevent
Memcached Memcached 是一个高性能的分布式内存对象缓存系统，用于动态Web应用以减轻数据库负载。它通过在内存中缓存数据和对象来减少读取数据库的次数，从而提供动态数据库驱动网站的速度。Memcached 基于一个存储键/值对的 hashmap。Memcached-1.4.7的代码量还是可以接受的，只有10K行左右。
下载地址：http://memcached.org/
Redis Redis 是一个使用 C 语言写成的，开源的 key-value 数据库。Redis支持的操作和数据类型比Memcached要多，现在主要用于缓存，支持主从同步机制，Redis的学习可以参考&lt;&lt;Redis设计与实现&gt;&gt;一书。
下载地址：http://redis.io/
Webbench Webbench是一个在linux下使用的非常简单的网站压测工具。它使用fork()模拟多个客户端同时访问我们设定的URL，测试网站在压力下工作的性能，最多可以模拟3万个并发连接去测试网站的负载能力。Webbench使用C语言编写, 代码实在太简洁，源码加起来不到600行。
下载链接：https://github.com/LippiOuYang/WebBenchl
APR（Apache Portable Runtime） 这是由 Apache 社区维护的 C 开源库，主要提供操作系统相关的功能（文件系统、进程、线程、用户、IPC）。此外还提供了一些网络相关的功能。
APR 原先是 Apache Web 服务器的一个组成部分，后来独立出来，成为一个单独的开源项目。
主页：https://apr.apache.org
NGINX Nginx是由俄罗斯软件工程师Igor Sysoev开发的一个高性能的HTTP和反向代理服务器，具备IMAP/POP3和SMTP服务器功能。Nginx最大的特点是对高并发的支持和高效的负载均衡，在高并发的需求场景下，是Apache服务器不错的替代品。目前，包括新浪、腾讯等知名网站已经开始使用Nginx作为Web应用服务器。
主页：http://nginx.org/en/download.html
Tinyhttpd tinyhttpd是一个超轻量型Http Server，使用C语言开发，全部代码只有502行(包括注释)，附带一个简单的Client，可以通过阅读这段代码理解一个 Http Server 的本质。
下载链接：https://github.com/LippiOuYang/Tinyhttpd
cJSON cJSON是C语言中的一个JSON编解码器，非常轻量级，C文件只有500多行，速度也非常理想。
cJSON也存在几个弱点，虽然功能不是非常强大，但cJSON的小身板和速度是最值得赞赏的。其代码被非常好地维护着，结构也简单易懂，可以作为一个非常好的C语言项目进行学习。
项目主页:http://sourceforge.net/projects/cjson/
CMockery cmockery是google发布的用于C单元测试的一个轻量级的框架。它很小巧，对其他开源包没有依赖，对被测试代码侵入性小。cmockery的源代码行数不到3K，你阅读一下will_return和mock的源代码就一目了然了。
主要特点：
免费且开源，google提供技术支持；轻量级的框架，使测试更加快速简单；避免使用复杂的编译器特性，对老版本的编译器来讲，兼容性好;并不强制要求待测代码必须依赖C99标准，这一特性对许多嵌入式系统的开发很有用 下载链接：http://code.google.com/p/cmockery/downloads/list
Lua Lua很棒，Lua是巴西人发明的，这些都令我不爽，但是还不至于脸红，最多眼红。
让我脸红的是Lua的源代码，百分之一百的ANSI C，一点都不掺杂。在任何支持ANSI C编译器的平台上都可以轻松编译通过。我试过，真是一点废话都没有。Lua的代码数量足够小，5.1.4仅仅1.5W行，去掉空白行和注释估计能到1W行。
下载地址：http://www.lua.org/
SQLite SQLite是一个开源的嵌入式关系数据库，实现自包容、零配置、支持事务的SQL数据库引擎。 其特点是高度便携、使用方便、结构紧凑、高效、可靠。足够小，大致3万行C代码，250K。
下载地址：http://www.sqlite.org/ 。
UNIX v6 UNIX V6 的内核源代码包括设备驱动程序在内 约有1 万行，这个数量的源代码，初学者是能够充分理解的。有一种说法是一个人所能理解的代码量上限为1 万行，UNIX V6的内核源代码从数量上看正好在这个范围之内。看到这里，大家是不是也有“如果只有1万行的话没准儿我也能学会”的想法呢？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2d62ff2c079406e1a52bc96896321f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dd7881ac34bd0b47e07ab1286ccef37/" rel="bookmark">
			android studio   flutter 新建app 启动页黑屏的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在activity 标签下 加上这段代码代码就行 &lt;meta-data android:name="io.flutter.embedding.android.SplashScreenDrawable" android:resource="@drawable/launch_background" /&gt; 完整代码如下 &lt;activity android:name=".MainActivity" android:configChanges="orientation|keyboardHidden|keyboard|screenSize|smallestScreenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode" android:hardwareAccelerated="true" android:launchMode="singleTop" android:theme="@style/LaunchTheme" android:windowSoftInputMode="adjustResize"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;--解决启动黑屏问题--&gt; &lt;meta-data android:name="io.flutter.embedding.android.SplashScreenDrawable" android:resource="@drawable/launch_background" /&gt; &lt;/activity&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af30e405e107b2111da88b0f8776084a/" rel="bookmark">
			maven安装完成，cmd执行mvn help:system 一直失败，下载不了jar包的解决方案（网上那些怎么都不行的看过来！！！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，说说我出现问题、解决问题的过程，很心酸。。。。
先是在项目中添加依赖，自动下载jar包时，我的maven一直失败，下载不下来，我就觉得会不会是我的maven出问题了，就重新安装配置一个新的maven。
跟网上的教程一样，我安装配置好maven后，用cmd执行 mvn -version命令，验证安装成功了；
紧接着我又执行了命令 mvn help:system ，问题就来了，一直失败BUILD FAILURE，于是，就在网上搜索解决方案，例如：将仓库地址放在除C盘外的其他盘、更换镜像 (阿里的、中央仓库的等等等都试过了)、设置代理等只要是网上能找到的方法都试了(除了重装系统的方法没试)，还是没有解决问题，还是失败，整整花费了两天时间，期间各种问同是程序员的朋友，都没遇见过，差点准备重装系统。。。。。
**
最后，在网上看到一个解决方案，就是执行 命令：mvn help:describe -Dplugin=help -e -X，这个命令的执行后会出现一堆东西，也有报错信息，并且最后结果是BUILD FAILURE，这些都不用管，只等它这个命令执行完之后，我们再去执行命令： mvn help:system ，然后就是见证奇迹的时刻！！！成功了！！！！！！！！到最后我都没明白那个命令的意思是什么，但是就是这么奇怪，执行了那个命令后就maven就可以下载jar包了，并且在eclipse的项目中，添加新的依赖也会自动从阿里的镜像地址下载jar包了。 **
一个花费了两天时间的问题就这么解决了，我看网上有好多网友也有同样的问题出现，一直没有解决方案，可以看看这里，看这个解决方案能不能解决你的问题，还有关于那个命令的意思，有知道的朋友可以留言解释一下，感谢！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec1b51c2c90c4c2d817093c0f7200f9c/" rel="bookmark">
			.net core 3.1 webapi接口项目框架搭建三：EFCore
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		.netcore + EFCore Sql Server引用依赖库命令问题解决方案 MySql引用依赖包命令 命令解释 Sql Server 引用依赖库 Install-Package Microsoft.EntityFrameworkCore Install-Package Microsoft.EntityFrameworkCore.SqlServer Install-Package Microsoft.EntityFrameworkCore.Tools Install-Package Microsoft.EntityFrameworkCore.Design 命令 打开 程序包管理器控制台 执行命令 ：
Scaffold-DbContext "Data Source=.;Initial Catalog=EFExample;User ID=sa;Password=sa" Microsoft.EntityFrameworkCore.SqlServer -ContextDir EF\SqlServer\Context -Context EFExampleContext -OutputDir EF\SqlServer -UseDatabaseNames -DataAnnotations -Force 问题 Your startup project 'Core' doesn't reference Microsoft.EntityFrameworkCore.Design. This package is required for the Entity Framework Core Tools to work. Ensure your startup project is correct, install the package, and try again.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec1b51c2c90c4c2d817093c0f7200f9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b16578d4e8ae8fb936f531d1ea5fd35d/" rel="bookmark">
			VMware API接口开发文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发操作VMware程序文档（VMware VIX API） 官方文档
他人示例C/C++
VMware命令行打开虚拟机（加密密码）及相关文档
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79877b390468bff3d1651e773a7e3073/" rel="bookmark">
			Mysql的两种存储引擎以及区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Mysql的两种存储引擎
1、MyISAM：
①不支持事务，但是整个操作是原子性的(事务具备四种特性：原子性、一致性、隔离性、持久性)
②不支持外键，支持表锁，每次所住的是整张表
MyISAM的表锁有读锁和写锁(两个锁都是表级别)：
表共享读锁和表独占写锁。在对MyISAM表进行读操作时，不会阻塞其他用户对同一张表的读请求，但是会阻塞其他用户对表的写请求；对其进行写操作时会阻塞对同一表读操作和写操作
MyISAM存储引擎的读锁和写锁是互斥的，读写操作是串行的。那么，一个进程请求某个MyISAM表的读锁，同时另一个进程也请求同一表的写锁，MySQL如何处理呢？答案是写进程先获得锁。不仅如此，即使读请求先到锁等待队列，写请求后到，写锁也会插到读锁请求之前！这是因为MySQL认为写请求一般比读请求要重要。这也正是MyISAM表不太适合于有大量更新操作和查询操作应用的原因，因为，大量的更新操作会造成查询操作很难获得读锁，从而可能永远阻塞。这种情况有时可能会变得非常糟糕！ ③一个MyISAM表有三个文件：索引文件，表结构文件，数据文件
④存储表的总行数，执行select count(*) from table时只要简单的读出保存好的行数即可
(myisam存储引擎的表，count(*)速度快的也仅仅是不带where条件的count。这个想想容易理解的，因为你带了where限制条件，原来所以中缓存的表总数能够直接返回用吗？不能用。这个查询引擎也是需要根据where条件去表中扫描数据，进行统计返回的。)
⑤采用非聚集索引，索引文件的数据域存储指向数据文件的指针。辅索引与主索引基本一致，但是辅索引不用保证唯一性。
⑥支持全文索引和空间索引
⑦对于AUTO_INCREMENT类型的字段，在MyISAM表中，可以和其他字段一起建立联合索引。
MyISAM的主索引图：索引文件的每个数据域存储指向数据文件的指针(每个索引指向了数据地址)
MyISAM的辐索引：索引文件的每个数据域存储指向数据文件的指针(每个索引指向了数据地址)，辐索引不用保证唯一性
2、Innodb：
①支持事务，支持事务的四种隔离级别;是一种具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。
②支持行锁和外键约束，因此可以支持写并发
③不存储总行数；也就是说，执行select count(*) from table时，InnoDB要扫描一遍整个表来计算有多少行。注意的是，当count(*)语句包含 where条件时，两种表的操作是一样的。
④对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引
⑤DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除
⑥一个Innodb表存储在一个文件内(共享表空间，表大小不受操作系统的限制)，也可能为多个(设置为独立表空间，表大小受操作系统限制，大小为2G)，受操作系统文件大小的限制
⑦主键索引采用聚集索引（索引的数据域存储数据文件本身），辅索引的数据域存储主键的值；因此从辅索引查找数据，需要先通过辅索引找到主键值，再访问主键索引；最好使用自增主键，防止插入数据时，为维持B+树结构，文件的大调整。
Innodb的主索引图:（索引位置上存储的直接是数据本身）
Innodb的辐索引图:
总结大图：
参考:
https://www.cnblogs.com/wangdake-qq/p/7358322.html
https://blog.csdn.net/qq_35181209/article/details/78030110
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea84be3676d623d2fef7b82aa47a8ff3/" rel="bookmark">
			简单3步，在线完成gif动图制作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在使用动图的地方非常多，动图的展现形式随处可见，不管是文章内容中的插图还是QQ、微信聊天时用的表情包，都经常会看到动图的身影。动态图片总是能够吸引更多用户的眼球，搭配相关文字说明，能够将想要展现的内容更加细致的表达出来。那么gif动图是怎么制作的呢，接下来教大家gif制作https://www.gif.cn/的技巧。
点击gif工具或者下方gif合成功能，进入多图合成gif的操作页面。
准备好多张需要使用的静态图片，从本地上传到网站上;也可以直接复制网上的图片，复制链接地址添加到网站上。
接下来只需要设置图片切换频率的快慢，然后选择生成的尺寸，比如公众号尺寸360p，海报720p等，根据所需尺寸选择即可，点击生成gif，生成之后查看效果，无误后点击点在gif即可。
按照上述的操作步骤，就可以使用多张静态图片合成gif动图的效果，操作简单，快捷。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48eec77f09ad4a1b60f18189f99aa262/" rel="bookmark">
			linux下编译安装opencv生成opencv.pc
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux下编译opencv需要cmake,有两种方式，cmake与cmake-gui，这个网上教程很多，但是opencv4版本之后，默认配置是不生成opencv.pc,就导致我们使用起来很困难，所以我们cmake的时候可以先配置一下： cmake -D WITH_TBB=ON -D WITH_EIGEN=ON -D OPENCV_GENERATE_PKGCONFIG=ON .. cmake -D BUILD_DOCS=ON -D BUILD_TESTS=OFF -D BUILD_PERF_TESTS=OFF -D BUILD_EXAMPLES=OFF .. cmake -D WITH_OPENCL=OFF -D WITH_CUDA=OFF -D BUILD_opencv_gpu=OFF -D BUILD_opencv_gpuarithm=OFF -D BUILD_opencv_gpubgsegm=O cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local .. 注意一行一行的来，这里其他不配置都无所谓，但是 -D OPENCV_GENERATE_PKGCONFIG=ON这个配置一定要加上，Linux下我们使用opencv，需要使用pkg-config来进行环境变量的管理,这个软件需要.pc类型的文件作为软件配置信息，如果我们不配置，会出现opencv安装成功但是c编程无法使用的情况，Python好像可以直接使用。。，网上有部分教程说可以手写，但是其实很困难，因为库之间是有依赖关系的，所以如果顺序放错也会找不到，最好还是自动生成。
linux下安装opencv4还有以下几个坑：
1.pkg-config配置不全，找不到头文件和库路径
2.系统自带的有opencv2,版本冲突
3.安装成功后没有更新动态库
4.安装配置都成功后，编译示例时没有启用c++11
下附安装步骤;
1.首先安装cmake，用来编译opencv
apt-get install cmake apt-get install build-essential libgtk2.0-dev libavcodec-dev apt-get install libavformat-dev libjpeg.dev libtiff4.dev libswscale-dev libjasper-dev Ubuntu下是这样，我的系统自带的有3.9版本的，centos下同样自带的有，不过版本可能是2，opencv4需要3以上的版本，需要更新一下
安装成功后输入
cmake -version 检查cmake是否安装成功
2.接下来安装pkg-config,用来配置环境变量。
apt-get install pkg-config 一般系统都自带的有，可以输入
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48eec77f09ad4a1b60f18189f99aa262/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/779477a1ded8f100ae73cff9933e30ba/" rel="bookmark">
			IDEA如何设置背景色？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于开发需要长期盯着电脑，比较多的人喜欢使用黑色的背景色，因为黑色背景相比白色没这么刺眼！最主要的是看着够酷炫！
更改IDEA的背景色步骤如下：
第一步：
打开IDEA，点击左上角的File，选这setting
第二步：点击Appearance&amp;Behavior 选择Appearance,右侧Theme主题有三个选项有Light的都是表示白色背景，Darcula就是黑色背景，双击选中就可以了！
第三步：
记住选择好之后点击右下角的Apply应用，再点击OK，就搞定啦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49d32c7aaad19e17c1d5770145df2068/" rel="bookmark">
			在项目中 npm i报错 npm WARN optional SKIPPING OPTIONAL DEPENDENCY
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在项目中下载依赖报错
npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.13 (node_modules\webpack-dev-server\node_modules\fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.13: wanted {“os”:“darwin”,“arch”:“any”} (current: {“os”:“win32”,“arch”:“x64”})
j解决办法
npm install --no-optional --verbose 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c50f2a4751169263236bee951d51a2bb/" rel="bookmark">
			Python字符串比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python | 字符串比较 (Python | String comparison) In python programming language, strings can be compared using the relationship/ comparisons operators like ==, !=, &lt;, &gt;, &lt;=, &gt;=.
在python编程语言中，可以使用诸如== ， ！= ， &lt; ， &gt; ， &lt;= ， &gt; =之类的关系/比较运算符来比较字符串。 These operators need two operands (strings), checks the characters (based on its UNICODE values) of the string and return True or False.
这些运算符需要两个操作数(字符串)，检查字符串的字符(基于其UNICODE值)并返回True或False 。 Example 1:
范例1： str1 = 'IncludeHelp'# comparisonprint("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c50f2a4751169263236bee951d51a2bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc9c06ce93d1de66595ef64cae649d5a/" rel="bookmark">
			Vue Router详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是路由 1.1路由简介 说起路由你想起了什么？路由是一个网络工程里面的术语。
路由（routing）就是通过互联的网络把信息从源地址传输到目的地址的活动。 --- 维基百科
额，啥玩意? 没听懂。在生活中，我们有没有听说过路由的概念呢? 当然了，路由器嘛。路由器是做什么的? 你有想过吗?路由器提供了两种机制: 路由和转送。路由是决定数据包从来源到目的地的路径。转送将输入端的数据转移到合适的输出端。路由中有一个非常重要的概念叫路由表。路由表本质上就是一个映射表，决定了数据包的指向。
1.2后端路由阶段 早期的网站开发整个HTML页面是由服务器来渲染的。服务器直接生产渲染好对应的HTML页面，返回给客户端进行展示。但是，一个网站这么多页面服务器如何处理呢?
一个页面有自己对应的网址，也就是URL。URL会发送到服务器，服务器会通过正则对该URL进行匹配，并且最后交给一个Controller进行处理。Controller进行各种处理，最终生成HTML或者数据，返回给前端。这就完成了一个IO操作。
上面的这种操作，就是后端路由。当我们页面中需要请求不同的路径内容时，交给服务器来进行处理，服务器渲染好整个页面，并且将页面返回给客户顿。这种情况下渲染好的页面，不需要单独加载任何的js和css，可以直接交给浏览器展示，这样也有利于SEO的优化。
后端路由的缺点:
一种情况是整个页面的模块由后端人员来编写和维护的。另一种情况是前端开发人员如果要开发页面，需要通过PHP和Java等语言来编写页面代码。而且通常情况下HTML代码和数据以及对应的逻辑会混在一起，编写和维护都是非常糟糕的事情。
1.3前端路由阶段 前后端分离阶段：
随着Ajax的出现, 有了前后端分离的开发模式。后端只提供API来返回数据, 前端通过Ajax获取数据, 并且可以通过JavaScript将数据渲染到页面中。这样做最大的优点就是前后端责任的清晰, 后端专注于数据上, 前端专注于交互和可视化上。并且当移动端(iOS/Android)出现后, 后端不需要进行任何处理, 依然使用之前的一套API即可。目前很多的网站依然采用这种模式开发。
单页面富应用阶段:
其实SPA最主要的特点就是在前后端分离的基础上加了一层前端路由。也就是前端来维护一套路由规则。
前端路由的核心是什么呢？
改变URL，但是页面不进行整体的刷新。如何实现呢？
2.前端路由的规则 2.1URL的hash URL的hash，URL的hash也就是锚点(#)， 本质上是改变window.location的href属性。我们可以通过直接赋值location.hash来改变href，但是页面不发生刷新
2.2HTML5的history模式：pushState history接口是HTML5新增的, 它有五种模式改变URL而不刷新页面。history.pushState()
2.3HTML5的history模式：replaceState 2.4HTML5的history模式：go 3.vue-router基础 3.1认识vue-router 目前前端流行的三大框架, 都有自己的路由实现:
Angular的ngRouter
React的ReactRouter
Vue的vue-router
当然, 我们的重点是vue-router
vue-router是Vue.js官方的路由插件，它和vue.js是深度集成的，适合用于构建单页面应用。
我们可以访问其官方网站对其进行学习: https://router.vuejs.org/zh/
vue-router是基于路由和组件的路由用于设定访问路径，将路径和组件映射起来。在vue-router的单页面应用中, 页面的路径的改变就是组件的切换。
3.2安装和使用vue-router 因为我们已经学习了webpack, 后续开发中我们主要是通过工程化的方式进行开发的。所以在后续, 我们直接使用npm来安装路由即可。
步骤一: 安装vue-router
npm install vue-router --save
步骤二: 在模块化工程中使用它(因为是一个插件, 所以可以通过Vue。use()来安装路由功能)
第一步：导入路由对象，并且调用 Vue。use(VueRouter)第二步：创建路由实例，并且传入路由映射配置第三步：在Vue实例中挂载创建的路由实例 使用vue-router的步骤:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc9c06ce93d1de66595ef64cae649d5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4bc0a459f23c376d5eccae541aa10a8/" rel="bookmark">
			vue 在哪个生命周期进行数据请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看实际情况，一般在 created（或beforeRouter） 里面就可以，如果涉及到需要页面加载完成之后的话就用 mounted。
在created的时候，视图中的html并没有渲染出来，所以此时如果直接去操作html的dom节点，一定找不到相关的元素
而在mounted中，由于此时html已经渲染出来了，所以可以直接操作dom节点，（此时document.getelementById 即可生效了）。
应用
vue中实现先请求数据再渲染dom
在项目中遇到了一个问题，下面是vue template中的代码：
我之前的写法是
这样做的结果是下面取dom的操作，取到的dom都是undefined，也就是没有取到。
原因是并没有按照 请求数据—&gt;渲染dom—&gt;获取dom的顺序执行，实际的执行顺序是 先获取dom，而此时数组option中还是空的，上面的v-for循环也就没有渲染出dom，所以根本取不到（不理解是为什么）
后来我又把请求数据写在了created函数中，把取dom的操作写在mounted函数中，竟然还是先执行取dom的操作（是通过alert的顺序来判断执行的顺序），我也很绝望啊
最后终于找到了解决的办法：
看到一个别人的回答是：“在数据请求的回调中使用nextTick，在nextTick的回调里试试～”
还有一个人的回答是：“如果有依赖dom必须存在的情况，就放到mounted(){this.$nextTick(() =&gt; { /* code */ })}里面”（这种之前我试过，我太好用，不懂为什么）
我把这两种方法综合起来，其实主要是第一种方法，发现好用了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/495d9ebbf656bfa5fbd321cab566cb91/" rel="bookmark">
			pygame飞机大战 小游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运行效果 代码 # 先导入系统模块 import sys # 随机模块 import random # 再导入第三方模块 import pygame import pygame.locals # 背景图片路径 IMG_BACKGROUND = "res/img_bg_level_1.jpg" # 敌机图片路径 元组 IMG_ENEMYPLANE = ("res/img-plane_1.png", "res/img-plane_2.png", "res/img-plane_3.png", "res/img-plane_4.png", "res/img-plane_5.png", "res/img-plane_6.png", "res/img-plane_7.png") # 玩家飞机图片路径 IMG_PLAYER_PLANE = "res/hero2.png" # 子弹图片 IMG_BULLET = "res/bullet_13.png" class Model(object): """提供基础模型""" # 窗口对象 window = None def __init__(self, img_path, x, y): # 图片对象 self.img = pygame.image.load(img_path) # x坐标 self.x = x # y坐标 self.y = y def display(self): # 将要显示的对象添加到窗体中, 并指定其坐标 Model.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/495d9ebbf656bfa5fbd321cab566cb91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d98511be1a37b15d4056d6f4f0fd9616/" rel="bookmark">
			BundleFusion那些事儿
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：前面几篇博客中写了很多关于BundleFusion的东西，主要包括bundlefusion的论文阅读笔记，.sens数据集的生成等，经过最近几天的工作，我对bundlefusion又有了新的技术积累，在这里整理一下，也算是理一下思路，然后开始新的工作。
1. 生成.sens文件 根据在https://graphics.stanford.edu/projects/bundlefusion/下载的.zip的数据集可知，一个数据集中包含，以frame-xxxxxx.color.png的彩色图像，有以frame-xxxxxx.depth.png命名的深度图像，以及，以frame-xxxxxx.pose.txt命名的位姿文件，该文件中存储的是一帧位姿，一个4x4的矩阵。如下图所示，所以首先你需要想办法得到这种标准格式的数据。我曾经把我使用kinectV2相机获取的深度图和彩色图对齐后的数据编辑为如下格式，所有的.pose.txt文件中我都写入单位阵。我还试着将TUM数据集和ICL-NUIM数据集编辑成下面这种格式，并且我将数据集提供的groundtruth写入到.pose.txt文件中，目的是想让bundlefusion按照groundtruth位姿来重建。由于数据集提供的groundtruth是用四元数表示的旋转，所以需要将四元数转换为旋转矩阵，由于我使用的是python脚本，这个是时候，scipy库就派上用场了，这里面有很多转换，包括，四元数，旋转矩阵，旋转向量，欧拉角之间的转换。
当然不要忘了，在目录的最后还有一个info.txt文件， 除了彩色图的尺寸，相机的内参数，要按照实际情况改写之后，还有很关键的一个参数就是m_depthShift，在BundleFusion官网上下载的数据集，info.txt中设置的m_depthShift =1000，而在我生成TUM和ICL的数据集时，这个值就得设置为10000，否则生成的数据集，重建不出来模型，具体的分析请阅读我的这篇博客，https://blog.csdn.net/weixin_38636815/article/details/107563959
下面是我将ICL数据集整理成上述格式的python脚本
import numpy as np from scipy.spatial.transform import Rotation as R import associate import os import shutil def copy_files(sourcefile): rgb_path = sourcefile+"rgb/" depth_path = sourcefile + "depth/" bf_path = sourcefile + "bf_dataset/" print(rgb_path) print(depth_path) rgb_images = os.listdir(rgb_path) depth_images = os.listdir(depth_path) rgb_int = [] depth_int = [] for rgb in rgb_images: rgb = rgb.replace('.png', '') # print(rgb) rgb_int.append(int(rgb)) for depth in depth_images: depth = depth.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d98511be1a37b15d4056d6f4f0fd9616/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/019e4e893ae4e737eaa1693fbbe272a3/" rel="bookmark">
			重定向与管道（基础篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		重定向 1.释义： Linux重定向是指修改原来默认的一些东西，对原来系统命令的默认执行方式进行改变，比如说简单的我不想看到在显示器的输出而是希望输出到某一文件中就可以通过Linux重定向来进行这项工作。
2.简介 file descriptors ,FD，文件描述符
进程使用文件描述符来管理打开的文件
类型数字英文缩写标准输入0standard inputstdin标准输出1standard outputstdout标准错误2standard errorstdeer 通过我们非常熟悉的VIM程序。来观察一个进程的FD信息。
1.通过一个终端，打开一个文本。
vim 1.txt
2.通过另一个终端，查询文本程序的进程号
ps aux| grep vim
通常在 /proc/PID/fd 就能看到文件的FD调用情况。
[root@localhost ~]# ls /proc/3203/fd
出现0 1 2 4四个数字
再使用ll查看
[root@localhost ~]# ll /proc/5606/fd
我们可以了解到
看到的0124就是FD，程序通过描述符访问文件，
可以是常规文件，也可以是设备文件
3.输出重定向及综合案例 由上可知
FD1为标准输出
1&gt;file1.txt
将标准输出结果输入到file1.txt，多次使用只显示最终结果（文件不存在自动创建文件）
1&gt;&gt;file1.txt
将标准输出结果输入到file1.txt，多次使用追加结果，不覆盖之前的结果（文件不存在自动创建文件）
FD2为标准错误，仅当某条命令产生错误时，才会有错误输出（正确不显示）
如下图，查看一个根本不存在的文件
*1&gt;file1.txt
将标准错误结果输入到file1.txt，多次使用只显示最终结果（文件不存在自动创建文件）
1&gt;&gt;file1.txt
将标准错误结果输入到file1.txt，多次使用追加结果，不覆盖之前的结果（文件不存在自动创建文件）*
将错误与正确结果输入到一个文件里面
4.输入重定向发送邮件 编写邮件
[root@qianfeng ~]# mail -s “ssss” alice &lt;word.txt
111
222
333
. word.txt
*mail*电子邮件 *-s*标题 *ssssssss*标题内容 *alice*邮件接收人 *.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/019e4e893ae4e737eaa1693fbbe272a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6719836d7c1c0dfe5e2e85d23469c33/" rel="bookmark">
			linux重定向＞、＜、管道|、tee、xargx详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FD简介 ，即file descriptors 文件描述符，是访问文件的标识、链接文件，和windows中的快捷方式类似，
接下来我们来观察一下，fd的信息
首先我们打开一个vim编辑器，用另一个终端来登录系统查看如下
我们在/proc/pin号/fd 就能看到文件的FD调用情况
[root@localhost ~]# ps aux|grep vim root 3600 0.0 0.5 149708 5400 pts/0 S+ 19:08 0:00 vim 1.txt root 3651 0.0 0.0 112728 968 pts/1 R+ 19:12 0:00 grep --color=auto vim [root@localhost ~]# ll /proc/3600/fd 总用量 0 lrwx------ 1 root root 64 7月 30 19:09 0 -&gt; /dev/pts/0 lrwx------ 1 root root 64 7月 30 19:09 1 -&gt; /dev/pts/0 lrwx------ 1 root root 64 7月 30 19:08 2 -&gt; /dev/pts/0 lrwx------ 1 root root 64 7月 30 19:09 3 -&gt; /root/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6719836d7c1c0dfe5e2e85d23469c33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7667261e24731eb214826ce0b2fd22f2/" rel="bookmark">
			3.1 SQL是什么？它能做什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 对数据库进行查询和修改操作的语言叫做 SQL (Structured Query Language，结构化查询语言)。
SQL 语言是目前广泛使用的关系数据库标准语言，是各种数据库交互方式的基础。
SQL 是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统。与其他程序设计语言（如 C语言、Java 等）不同的是，SQL 由很少的关键字组成，每个 SQL 语句通过一个或多个关键字构成。
SQL 具有以下优点
一体化：SQL 集数据定义、数据操作和数据控制为一体，可以完成数据库中的全部工作。使用方式灵活：SQL 具有两种使用方式，可以直接以命令方式交互使用，也可以嵌入使用，嵌入C、C++、Fortran、COBOL、Java 等语言中使用。非过程化：只提操作要求，不必描述操作步骤，也不需要导航。使用时，只需要告诉计算机"做什么"，而不需要告诉他"怎么做"，存储路径的选择和操作的执行由数据库管理系统自动完成。语言简洁、语法简单：该语言的语句都是由描述性很强的英文单词组成，而且这些单词的数目不多。 SQL 包含以下四个部分
数据定义语言
用来创建或删除数据库以及表等对象，主要包含以下几种命令：
DROP：删除数据库和表等对象CREATE：创建数据库和表等对象ALTER：修改数据库和表等对象的结构 数据操作语言
用来变更表中的记录，主要包含以下几种命令
SELECT：查询表中的数据INSERT：向表中插入新数据UPDATE：更新表中的数据DELETE：删除表中的数据 数据查询语言
用来查询表中的记录，主要包含 SELECT 命令，来查询表中的数据。
数据控制语言
用来确认或取消对数据库中的数据进行的变更。除此之外，还可以对数据库中的用户设定权限。主要包含以下几种命令
GRANT：赋予用户操作权限REVOKE：取消用户的操作权限COMMIT：确定对数据库中的数据进行的变更ROLLBACK：取消对数据库中的数据进行的变更 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10f13cb72246793756de91c0dcdbb3ee/" rel="bookmark">
			elasticsearch-aggs-top_hits，分组查询，并返回每组数据中特定排序的源数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对数据分组并返回分组中特定排序的多少个
Top Hits Aggregation top_hits指标聚合器跟踪正在聚合的最相关文档。 此聚合器旨在用作子聚合器，以便可以按桶聚合最匹配的文档。top_hits聚合器可以有效地用于通过桶聚合器按特定字段对结果集进行分组。 一个或多个存储桶聚合器确定结果集被切入的属性。 选项 from - 要获取的第一个结果的偏移量。size - 每个桶返回的最大匹配匹配数的最大数量。默认情况下，返回前三个匹配的匹配。sort - 如何对最匹配的匹配进行排序。默认情况下，命中按主查询的分数排序。 例子 请求： GET ztjy-growth-info-alpha_*/_search {"query": { "match": { "schoolId": "uOdq9KBA7xYpbmvC4Bf" } }, "size": 0, "aggs": { "userId111": { "terms": { "field": "userId", "size": 10 }, "aggs": { "publishTime111": { "top_hits": { "sort": [ { "publishTime": { "order": "desc" } } ], "size": 1, "_source": { "includes": ["publishTime","feedId"] } } } } } } } 结果 { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10f13cb72246793756de91c0dcdbb3ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa7e6812bed5b5a552bbc4f959810a6c/" rel="bookmark">
			详解深度神经网络中常见的梯度消失和梯度爆炸及其具体的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		梯度不稳定问题 在层数比较多的神经网络模型的训练过程中会出现梯度不稳定的问题。具体来说就是神经网络前面的层可能会出现梯度消失或者梯度爆炸的情况。梯度消失问题和梯度爆炸问题一般会随着神经网络层数的增加变得越来越明显。
损失函数计算的误差通过梯度反向传播的方式，指导深度网络权值的更新优化。因为神经网络的反向传播算法是从输出层到输入层的逐层向前进行链式求导，前面层上的梯度是来自于后面层上梯度的乘积，当存在神经网络层数过多时，就有可能出现了梯度不稳定场景。
梯度消失 在神经网络反向传播中，当梯度从后往前传时，梯度不断减小，最后变为零，此时，浅层的神经网络权重得不到更新，那么前面隐藏层的学习速率低于后面隐藏层的学习速率，即随着隐藏层数目的增加，分类准确率反而下降了。这种现象叫做梯度消失。
梯度消失导致后层的权重更新的快，靠近输出层的权值更新相对正常，而前层网络由于梯度传递不过去而得不到更新。靠近输入层的权值更新会变得很慢，导致靠近输入层的隐藏层权值几乎不变，接近于初始化的权值。这样在网络很深的时候，学习的速度很慢或者无法学习。
梯度消失导致神经网络的hidden layer 1 相当于只是一个映射层，对所有的输入做了一个函数映射，这时此深度神经网络的学习就等价于只有后几层的隐藏层网络在学习，就发挥不到深层神经网络的效果了。
如上图所示，我们可以看出来神经网络中从输出层Hidden Layer 4到输入层Hidden Layer 1的训练速度依次减慢。
梯度爆炸 当权值过大，神经网络前面层比后面层梯度变化更快，会引起梯度爆炸问题。梯度爆炸就是由于初始化权值过大，w大到乘以激活函数的导数都大于1，因为前面层比后面层变化的更快，就会导致神经网络前面层的权值越来越大，梯度爆炸的现象就发生了。
梯度爆炸是一种与梯度消失相反的情况，当进行反向传播时，梯度从后往前传时，梯度不断增大，导致权重更新太大，以致于不断波动，使神经网络在最优点之间波动。
梯度消失和梯度爆炸的示例解析 现在我们有一个如上所示的简化的神经网络，每个隐藏层都用一个神经元来代替，从输入层x经过隐藏层到输出层y的前向传播公式为：
现在我们对参数w1求梯度，根据链式求导法则，得到的解为：
对w1求梯度就是从输出层到输入层的链式求导，如果我们使用标准化初始w，那么各个层次的相乘都是0-1之间的小数，而激活函数f的导数也是0-1之间的数（sigmoid激活函数），其连乘后，结果会变的很小，导致梯度消失。若我们初始化的w是很大的数，w大到乘以激活函数的导数都大于1，那么连乘后，可能会导致求导的结果很大，形成梯度爆炸。这就是梯度消失和梯度爆炸的直观体现。
解决梯度消失和梯度爆炸地技巧 用ReLU、Leaky-ReLU、P-ReLU、R-ReLU、Maxout等替代sigmoid函数。
用Batch Normalization。
LSTM的结构设计可以改善RNN中的梯度消失问题。
4.动态地改变学习率，当梯度过小时，增大学习率，当过大时，减小学习率。
5.神经网络的权重标准初始化
当我们使用梯度下降算法和反向传播算法结合训练神经网络的模型的时候，这就意味着梯度消失和梯度爆炸是不可避免地，这就是反向传播法则链式求导的先天性不足，但我们明白其原理之后，可以通过以上的一些技巧减少它们对神经网络训练的消极影响。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77d1c893a84b17994649bd49be3f22fb/" rel="bookmark">
			cmd下运行java程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件： Test.java
1、生成 Test.class
javac Test.java 2、执行(注意不要写成Test.class)
java Test 3、反编译 javap
javap Test 3.1、更详细信息
https://www.cnblogs.com/frankcui/p/12134360.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94cf70c009e1065bc1355b3595558f8e/" rel="bookmark">
			SQL高级-事务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		事务 为什么有事务什么是事务事务的四大特性（ACID）事务的状态事务的命令事务的开启事务的提交事务的回滚 保存点 为什么有事务 事务广泛的运用于订单系统、银行系统等多种场景
举例：
如果用A账户转账给B账户500块，步骤分为三步
1、查询A账户余额是否大于等于500
2、A账户余额减少500
3、B账户余额增加500
如果执行第二步之后银行系统出现了故障，就会导致A账户余额减少500，而B账户余额没有增加，所以要想解决这个问题，要么三个步骤都执行，要么都不执行，事务的出现就是解决这个问题
什么是事务 事务是保持逻辑数据一致性与可恢复性的单位，它是一个操作序列，这些操作要么都执行，要么都不执行
事务的四大特性（ACID） 原子性(Atomicity) 一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样
一致性(Consistency) 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作
隔离性(Isolation) 数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）
持久性(Durability) 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失
事务的状态 事务分为以下几种状态：
活动的(active)
事务在开始之后到结束之前都处于活动状态部分提交的(partially committed)
当最后一个操作执行完成时，只是在内存上起作用，还没有同步到磁盘上失败的(faied)
当事务处在活动的或者部分提交的状态时，可能遇到了某些错误（数据库自身的错误、操作系统错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在失败的状态中止的(aborted)
当事务转为失败的状态后，所有执行的操作将会回滚(撤销)，数据库恢复到事务开始之前提交的(commited)
当一个处在部分提交的状态的事务将修改过的数据都同步到磁盘上之后，我们就可以说该事务处在了提交的状态 事务的命令 在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务
事务的开启 代码示例
begin; 或者 start transaction; 如果使用start transaction;，我们可以在后面添加一些限制，如start transaction read only;只读性或start transaction read write;读写性
事务的提交 代码示例
commit; 事务的回滚 代码示例
rollback; 举例说明：
保存点 当我们开始事务之后，我们可能会敲很多语句，当我们想要改一下上条语句或上上条语句时，可以使用ROLLBACK语句重新开始，这感觉就是一夜回到解放前，当保存点概念出现后，我们只需要在一条语句执行后，设置保存点，就可以随意回滚到任意一点保存点了
设置保存点
代码示例SAVEPOINT 保存点名称; 回滚到某个保存点
下边语句中的单词WORK和SAVEPOINT可有可无
代码示例ROLLBACK [WORK] TO [SAVEPOINT] 保存点名称; 删除保存点
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94cf70c009e1065bc1355b3595558f8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f624d8e4148fd65df46bce55632e8905/" rel="bookmark">
			c#  在控件TabControl中的子控件TabItem中显示的窗口怎么一起关闭
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		比如：
我打开一个操作界面显示在superTabItem2中，操作完后，想关闭这个superTabItem2怎么弄？
这里就涉及到控件TabControl的属性配置：
将图示closebuttonontabsvisible属性设置为true，就会看到superTabItem2 后面有个叉叉，后面操作完直接叉掉就关闭了。
摸索了好久了，百度出来的都是要写代码，不知道要实现关闭啥
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bbc206f03c4535456b2e4fbf6690d89/" rel="bookmark">
			Linux2.6.33虚拟文件系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 VFS对象及其数据结构超级块对象超级块操作索引节点对象索引节点操作目录项对象目录项状态目录项缓存 目录项操作文件对象文件操作 和文件系统相关的数据结构和进程相关的数据结构 虚拟文件系统(虚拟文件交换VFS)作为内核子系统，为用户空间程序提供了文件和文件系统相关的接口系统中所有文件系统不但依赖VFS共存，而且依靠VFS系统协同工作VFS把目录当作文件对待，因此可以对目录执行与文件相同的操作文件相关信息(文件的元数据)，被存储在一个单独的数据结构中，该结构被称为索引节点inode文件系统的控制信息存储在超级块中，超级块是一种包含文件系统信息的数据结构 VFS对象及其数据结构 VFS中有四个主要的对象类型 超级块对象，代表一个具体的已安装文件系统索引节点对象，代表一个具体文件目录项对象，代表一个目录项，是路径的一个组成部分文件对象，代表有进程打开的文件 每个主要对象中都包含一个操作对象，这些操作对象描述了内核针对主要对象可以使用的方法 super_operations对象，其中包含内核针对特定文件系统所能调用的方法，如write_inode()和sync_fs()等方法inode_operations对象，其中包含内核针对特定文件所能调用的方法，如create()和link()等方法dentry_operations对象，其中包含内核针对特定目录所能调用的方法，如d_compare()和d_delete()等方法file_operations对象，其中包含进程针对已打开文件所能调用的方法，如read()和write()等方法 操作对象作为一个结构体指针来实现，此结构体包含指向操作其父对象的函数指针VFS使用了大量结构体对象，如每个注册的文件系统都由file_system_type结构体来表示，描述文件系统及其性能；每一个安装点都用vfsmount结构体表示，包含安装点的相关信息，如位置和安装标志等 超级块对象 各种文件系统都必须实现超级块对象，该对象用于控制存储特定文件系统的信息，通常对应于存放在磁盘特定扇区中的文件系统超级块或文件系统控制块对于并非基于磁盘的文件系统(如基于内存的文件系统sysfs)，会在使用现场创建超级块并将其保存在内存中创建、管理和撤销超级块对象的代码位于fs/super.c中，超级块对象通过alloc_super()函数创建并初始化在文件系统安装时，文件系统会调用该函数以便从磁盘读取文件系统超级块，并且将其信息填充到内存中的超级块对象中 #include &lt;linux/fs.h&gt; struct super_block { struct list_head s_list;//指向所有超级块的连接 dev_t s_dev;//设备标识符 unsigned long s_blocksize;//以字节为单位的块大小 unsigned char s_blocksize_bits;//以位为单位的块大小 unsigned char s_dir;//修改(脏)标志 unsigned long long s_maxbytes;//文件大小上限 struct file_system_type s_type;//文件系统类型 struct super_operations s_op;//超级块方法 struct dquot_operations *dq_op;//磁盘限额方法 struct quotactl_ops *s_qcop;//限额控制方法 struct export_operations *s_export_op;//导出方法 unsigned long s_flags;//挂载标志 unsigned long s_magic;//文件系统的幻术 struct dentry *s_root;//目录挂载点 struct rw_semaphore s_umount;//卸载信号量 struct semaphore s_lock;//超级块信号量 int s_count;//超级块引用计数 int s_need_sync;//尚未同步标志 atomic_t s_active;//活动引用计数 void *s_security;//安全模块 struct xattr_handler **s_xattr;//扩展的属性操作 struct list_head s_inodes;//inodes链表 struct list_head s_dirty;//脏数据链表 struct list_head s_io;//回写链表 struct list_head s_more_io;//更多回写链表 struct list_head s_anon;//匿名目录项 struct list_head s_files;//被分配文件链表 struct list_head s_dentry_lru;//未被使用目录项链表 int s_nr_dentry_unused;//链表总目录项的数目 struct block_device *s_bdev;//相关的块设备 struct mtd_info *s_mtd;//存储磁盘信息 struct list_head s_instances;//该类型文件系统 struct quota_info s_dquot;//限额相关选项 int s_frozen;//frozen标志位 wait_queue_head_t s_wait_unfrozen;//冻结的等待队列 char s_id[32];//文本名字 void *s_fs_info;//文件系统特殊信息 fmode_t s_mode;//安装权限 struct semaphore s_vfs_rename_sem;//重命名信号量 u32 s_time_gran;//时间戳粒度 char *s_subtype;//子类型名称 char *s_options;//已存安装选项 }; 超级块操作 超级块对象有一个成员s_op，指向超级块的操作函数表操作函数表的每一项都是一个指向超级块操作函数的指针，执行文件系统和索引节点的底层操作当文件系统需要对其超级块执行操作时，首先要在超级块对象中寻找需要操作方法 #include &lt;linux/fs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1bbc206f03c4535456b2e4fbf6690d89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bdc93693d12a6959640ef7e918f3351/" rel="bookmark">
			scala的match匹配基础代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 //scala match匹配 object mohsi { def main(args: Array[String]): Unit = { def is(a:String) = a match { case "wzh" =&gt; println("han han") case "jhk" =&gt; println("666") case "ydl" =&gt; println("no no no") case "UV" =&gt;println("low low low") case _ =&gt;println("remake") } is("wzh") } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f757d36002b1e0d7f7a5f18a8bda5a05/" rel="bookmark">
			关于canvas画布上绘制多个（单个也一样）不规则多边形，用户点击这张画布时，判断点击的是哪个多边形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先来看看canvas效果图 上面是我在canvas上绘制了多个不规则多边形，如果不是很了解怎么绘制，可以看我上个博客canvas画图
盒子结构 &lt;div class="imgBox" ref="canvas"&gt; &lt;canvas id="myCanvas" width="660px" height="260px" @click="getWorkShop"&gt;&lt;/canvas&gt; &lt;/div&gt; 样式 .imgBox { width: 100%; height: 100%; // width: 660px; // height: 260px; background-color: #c1c8df; cursor: pointer; #myCanvas { width: 100%; height: 100%; } } 这个页面是适配的，imgBox盒子的大小比canvas画布大，canvas是适配上的，这个大小适配方法会影响后面点击画布时有影响，需要在写方法时，判断转化一下
原理 - 光线投射法 原理：
1、从点P出发，任意引一条射线（模拟光线）。
2、该条射线与多边形A的边相交时，若射线从边的左侧贯穿记录leftCount加1，若射线从边的右侧贯穿记录rightCount加1。
3、若leftCount-rightCount等于0表示在图形外部，若不等于0表示图形内部。
点击画布方法 getWorkShop($el, e) { // 画布上是有一张背景图的，且是响应式的，页面的展示的画布与实际样式的画布尺寸不一致，需要转换一下，例如页面时1300 * 500，但是我的画布实际是660 * 260，然后需要比例转换一下 let cImgW = this.$refs.canvas.clientWidth; // 画布的渲染的宽度 let cImgH = this.$refs.canvas.clientHeight; // 画布的渲染高度 let offsetX = $el.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f757d36002b1e0d7f7a5f18a8bda5a05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4c6703dad0f9249eb9ee73edf7e73c9/" rel="bookmark">
			Laravel 多应用 多模块开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有时候我们的项目需要分多个模块进行开发，多个模块的耦合性不是那么的强 首先我的 我们composer 切到阿里的镜像 之前使用的国内的镜像和国外的镜像 都安装失败
#切换到阿里的镜像
composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/
然后安装再项目的根目录(不是public目录)安装laravel model 扩展包 composer require nwidart/laravel-modules
然后执行一下 下面的命令注册 5.5版本 以下不用注册 高版本的需要 php artisan vendor:publish --provider="Nwidart\Modules\LaravelModulesServiceProvider"
执行成功后 在 config 文件夹下会生成一个 modules.php modules.php 里面的内容包含 你模块生成的位置 和模块的命名空间 然后修改 composer.json文件
"autoload": {
"psr-4": {
"App\\": "app/",
"Modules\\": "Modules/"
}
}
再这个"autoload": 加上 "Modules\\": "Modules/"
然后修改config 文件夹下的modules.php 'namespace' =&gt; 'App',//默认的命名空间是modules 我这里修改成了 app
'modules' =&gt; base_path('app'),//app 就是你的路径 你想把模块放在那里 就改路径的地址
修改成功之后就执行 新增 模块的命令
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4c6703dad0f9249eb9ee73edf7e73c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa1aa4fa371100132b551b983dabac6b/" rel="bookmark">
			Redis（6）删除策略（定时删除、惰性删除、定期删除）和数据逐出策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、过期数据
二、数据删除策略
1. 定时删除 2. 惰性删除 3. 定期删除 4. 删除策略比对 三、逐出算法
1. 新数据进入检测
2. 影响数据逐出的相关配置
3. 数据逐出策略配置依据
一、过期数据 Redis是一种内存级数据库，所有数据均存放在内存中，内存中的数据可以通过TTL指令获取其状态：
XX ：具有时效性的数据 -1 ：永久有效的数据 -2 ：已经过期的数据 或 被删除的数据 或 未定义的数据 二、数据删除策略 数据删除策略的目标：在内存占用与CPU占用之间寻找一种平衡，顾此失彼都会造成整体redis性能的下降，甚至引发服务器宕机或
内存泄露。
时效性数据的存储结构：
1. 定时删除 创建一个定时器，当key设置有过期时间，且过期时间到达时，由定时器任务立即执行对键的删除操作 优点：节约内存，到时就删除，快速释放掉不必要的内存占用 缺点：CPU压力很大，无论CPU此时负载量多高，均占用CPU，会影响redis服务器响应时间和指令吞吐量 总结：用处理器性能换取存储空间 （拿时间换空间） 2. 惰性删除 数据到达过期时间，不做处理。等下次访问该数据时，如果未过期，返回数据 ；发现已过期，删除，返回不存在。 优点：节约CPU性能，发现必须删除的时候才删除 缺点：内存压力很大，出现长期占用内存的数据 总结：用存储空间换取处理器性能（拿空间换时间） 3. 定期删除 两种方案都走极端，有没有折中方案？ 周期性轮询redis库中的时效性数据，采用随机抽取的策略，利用过期数据占比的方式控制删除频度 特点1：CPU性能占用设置有峰值，检测频度可自定义设置 特点2：内存压力不是很大，长期占用内存的冷数据会被持续清理 总结：周期性抽查存储空间 （随机抽查，重点抽查） 4. 删除策略比对 三、逐出算法 1. 新数据进入检测 当新数据进入redis时，如果内存不足怎么办？ Redis使用内存存储数据，在执行每一个命令前，会调用freeMemoryIfNeeded()检测内存是否充足。如果内存不满足新加入数据的最低存储要求，redis要临时删除一些数据为当前指令清理存储空间。清理数据的策略称为逐出算法。 注意：逐出数据的过程不是100%能够清理出足够的可使用的内存空间，如果不成功则反复执行。当对所有数据尝试完毕后，如果不能达到内存清理的要求，将出现错误信息。 2. 影响数据逐出的相关配置 1）检测易失数据（可能会过期的数据集server.db[i].expires ） ① volatile-lru：挑选最近最少使用的数据淘汰 ② volatile-lfu：挑选最近使用次数最少的数据淘汰 ③ volatile-ttl：挑选将要过期的数据淘汰 ④ volatile-random：任意选择数据淘汰 2）检测全库数据（所有数据集server.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa1aa4fa371100132b551b983dabac6b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/236/">«</a>
	<span class="pagination__item pagination__item--current">237/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/238/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>