<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9430e58706093c11dedb85853ef08f52/" rel="bookmark">
			用指针方法编写一个程序，输入3个整数，将它们按由小到大的顺序输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;stdio.h&gt; void swap(int *pa,int *pb) { int temp; temp = *pa; *pa = *pb; *pb = temp; } void main() { int a,b,c,temp; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); if(a&gt;b) swap(&amp;a,&amp;b); if(b&gt;c) swap(&amp;b,&amp;c); if(a&gt;c) swap(&amp;a,&amp;c); printf("%d,%d,%d",a,b,c); }
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/278f6dfa2de22af818cc99eb0d3dea72/" rel="bookmark">
			jquery 之ajax  cache
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在做一个企业通讯录的功能，功能很简单，我的本意是做数据存储并且做同步更新，时间原因以及服务端的同事更倾向于简单点的方式，呵呵，于是我们就采取了实时查询的方式。
由于get请求有点多，由于页面的生命周期就是打开页面-关闭页面，想到cache，但是由于公司是使用的原生的ajax，因此研究一下jq的ajax的缓存是如何写的。
jq的思路大概是检测到需要cache这个请求，就会在对象池中检测是不是存在该url的Last-Modified值，存储容器如下：
1 // Last-Modified header cache for next request 2 lastModified: {}, 3 etag: {}, 然后，在发送请求的时候检测是否cache后，有如下的代码：
1 // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode. 2 if ( s.ifModified ) { 3 if ( jQuery.lastModified[ cacheURL ] ) { 4 jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] ); 5 } 6 if ( jQuery.etag[ cacheURL ] ) { 7 jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] ); 8 } 9 } 这里的代码意思是如果说jq根据jQuery.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/278f6dfa2de22af818cc99eb0d3dea72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f60c6aca16e4c90e464d956bc2b8800/" rel="bookmark">
			android开源图表框架HelloChart的使用 (hellocharts-library-1.5.8.jar)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：在android开发过程中，图表是使用比较频繁的功能，目前开源的框架也比较多，如大名鼎鼎的mpChart，WilliamChart等。
不过在使用过程中，各有各的好处，如mpChart在我使用lineChart的时候效果总是不太如意，而WilliamChart的使用在studio环境中表现不错，但是在eclipse环境中总是报错。无法集成。所以网上搜索了其他的开源框架，找到了hellochart开源项目。
GitHub地址：
https://github.com/lecho/hellocharts-android
试用之后表现不错，特推荐大家使用。 点击hellochart.jar的下载
http://download.csdn.net/detail/xygy8860/9375426
1.首先是折线图
布局很简单
&lt;lecho.lib.hellocharts.view.LineChartView android:id="@+id/chart" android:layout_width="match_parent" android:layout_height="200dp" android:background="#32CD32" &gt; &lt;/lecho.lib.hellocharts.view.LineChartView&gt; 然后在activity中findViewById即可。 下面的变量是对lineChart的配置，可以显示多行，我都写上了注释。
/******************* hellochart ******************/ @Bind(R.id.chart) lecho.lib.hellocharts.view.LineChartView chart; private boolean hasAxes = true; private boolean hasAxesNames = true; // 横竖行的名字 private boolean hasLines = true; private boolean hasPoints = true; private ValueShape shape = ValueShape.CIRCLE; private boolean isFilled = false; private boolean hasLabels = false; // 是否显示点的数据 private boolean isCubic = false; private boolean hasLabelForSelected = false; private boolean pointsHaveDifferentColor; private LineChartData data; private int numberOfLines = 1; // 只显示一行数据 private int maxNumberOfLines = 1; // 如果为4则表示最多显示4行，1表示只有一行数据 private int numberOfPoints = 10; // 每行数据有多少个点 // 存储数据 float[][] randomNumbersTab = new float[maxNumberOfLines][numberOfPoints]; 然后是对数据进行处理，最主要的是一个generateData()的函数。 /** * helloChart的初始化入口 */ private void generateData() { int whiteColor = getResources().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f60c6aca16e4c90e464d956bc2b8800/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8889fcb9473518ec0b62a33222fecd27/" rel="bookmark">
			JAVA 利用Arraylist.sort()进行排序的实现。（comparable接口的实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是Comparable接口
此接口强行对实现它的每个类的对象进行整体排序。此排序被称为该类的自然排序 ，类的 compareTo 方法被称为它的自然比较方法 。实现此接口的对象列表（和数组）可以通过 Collections.sort （和 Arrays.sort ）进行自动排序。实现此接口的对象可以用作有序映射表中的键或有序集合中的元素，无需指定比较器。 强烈推荐（虽然不是必需的）使自然排序与 equals 一致。所谓与equals一致是指对于类 C 的每一个 e1 和 e2 来说，当且仅当 (e1.compareTo((Object)e2) == 0) 与e1.equals((Object)e2) 具有相同的布尔值时，类 C 的自然排序才叫做与 equals 一致 。
2.实现什么方法
int compareTo(T o)
比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。
强烈推荐 (x.compareTo(y)==0) == (x.equals(y)) 这种做法，但不是 严格要求这样做。一般来说，任何实现 Comparable 接口和违背此条件的类都应该清楚地指出这一事实。推荐如此阐述：“注意：此类具有与 equals 不一致的自然排序。”
参数：
o - 要比较的对象。
返回：
负整数、零或正整数，根据此对象是小于、等于还是大于指定对象。
抛出：
ClassCastException - 如果指定对象的类型不允许它与此对象进行比较。
3.实例
import java.util.*;
public class EmployeeSortTest {
public static void main(String[] args) {
Employee[] staff = new Employee[3];
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8889fcb9473518ec0b62a33222fecd27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/718826302d72412c8e167bbdc525571d/" rel="bookmark">
			关于getClass().getClassLoader()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		InputStream is = getClass().getClassLoader().getResourceAsStream("helloworld.properties");中getClass()和getClassLoader()都是什么意思呀.
getClass()：取得当前对象所属的Class对象 getClassLoader()：取得该Class对象的类装载器
类装载器负责从Java字符文件将字符流读入内存，并构造Class类对象，在你说的问题哪里，通过它可以得到一个文件的输入流
getClass :
public final Class getClass()
Returns the runtime class of an object. That Class object is the object that is locked by static synchronized methods of the represented class.
Returns:
the object of type Class that represents the runtime class of the object.
getClassLoader
public ClassLoader getClassLoader()
Returns the class loader for the class. Some implementations may use null to represent the bootstrap class loader.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/718826302d72412c8e167bbdc525571d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c332a236e520dbe29c865afa4cc4ba5/" rel="bookmark">
			单源点最短路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单源点最短路径的C实现 求解单源点最短路径的算法： 1构造所有节点间距离的矩阵（二维数组），无直接路径的为无穷2构造到所有节点最短路径上前一结点数组nodeArray，初始全为源点3构造源点到其他各结点的距离数组distanceArray，无直接路径的为无穷4从数组distanceArray中选出距离最小的结点node,并入集合s（初始为空）5遍历遍历每个不在s集合中的其他结点dot（distanceArray数组），若源点到node距离与node到dot的距离之和小于源点到dot距离，则更新distanceArray对应项的值，并同时更新nodeArray的值为node6重复4-5直至无可选结点7通过nodeArray从某结点出发不断寻找其前一结点，直至源点，此路径即为源点到该结点的最短路径 具体实现 #include &lt;iostream&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; using namespace std; /** 自定义比较大小，负数均视为无穷大，其他大小正常 x&lt;y,return true */ bool lessThen(float x, float y); /** 长度为len的s数组是否包含e 包含e，return true */ bool contain(int* s, int len, int e); /** 得到到达e的最短路径字符串描述 keys[i]的值为起点到i的前一个结点索引 */ string getPath(int *keys, int e); /** 以size*size的二维数组paths为前提寻找最短路径，返回有效长度为len一维数组keys keys[i]的值为起点到i的前一个结点索引 */ int* findShortestPath(float **paths, int size, int&amp; len); int main() { //节点数 int size = 0; //读入节点数 cout&lt;&lt;"请输入节点数："; cin&gt;&gt;size; cout&lt;&lt;endl; if(size &lt;= 0) { cout&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c332a236e520dbe29c865afa4cc4ba5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3767f6b121b089ddff0e55b1e099816c/" rel="bookmark">
			VS2015  窗口布局简介  其他版本也一样
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先看下图，VS窗口无非几个部分
1、菜单栏，包括 文件、编辑等等，它是跟整个窗口一起的不能移动。
2、工具栏，在菜单栏下面，只能在菜单栏下面移动，还能跟其他工具栏互换位置，不能变成一个单独的窗口拿出来。
3、下面的工作区，它会包含很多窗口。
随便点击一个窗口的小三角，会看到几中状态。
a、浮动，相当于用鼠标把它拖出来变成独立可移动的窗口。
b、停靠，那个 解决方案管理器窗口和下面的输出窗口 的状态就是停靠，你可以拖动一个窗口根据提示图标选择停靠位置。
c、作为选项卡式文档停靠，位于正中央，一般你正在编辑或新建的项 会以这种方式显示
d、自动隐藏，就是最左边竖着的那一栏，比较猥琐，注意，只有停靠状态的窗口可以变换为自动隐藏。
e、隐藏，隐藏就是关掉这个窗口，也可以在 菜单栏--&gt;视图 中重新显示。
然后，你就可以设置符合自己习惯的窗口布局了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fe13dc3a2407d36051cfeef655fd22e/" rel="bookmark">
			char,varchar,vachar2区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1．CHAR的长度是固定的，而VARCHAR2的长度是可以变化的， 比如，存储字符串“abc"，对于CHAR (20)，表示你存储的字符将占20个字节(包括17个空字符)，而同样的VARCHAR2 (20)则只占用3个字节的长度，20只是最大值，当你存储的字符小于20时，按实际长度存储。 2．CHAR的效率比VARCHAR2的效率稍高。 3．目前VARCHAR是VARCHAR2的同义词。工业标准的VARCHAR类型可以存储空字符串，但是oracle不这样做，尽管它保留以后这样做的权利。Oracle自己开发了一个数据类型VARCHAR2，这个类型不是一个标准的VARCHAR，它将在数据库中varchar列可以存储空字符串的特性改为存储NULL值。如果你想有向后兼容的能力，Oracle建议使用VARCHAR2而不是VARCHAR。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4d996d92d1f9c3e5872e98982c2ff7c/" rel="bookmark">
			svn“Previous operation has not finished; run &#39;cleanup&#39; if it was interrupted“报错的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天碰到了个郁闷的问题，svn执行clean up命令时报错“Previous operation has not finished; run 'cleanup' if it was interrupted”。无论你到那个父层次的目录执行“clean up “，都是报一样的错。执行cleanup时候，提示要cleanup。看来是进入死循环了。 可能是频繁做了一些改名，文件打开的时候更新或者提交操作，导致svn不能正常更新、提交了。这个也该算是svn的bug吧。类似的情况，其实之前也碰到过。之前都是图省事，把整个svn checkout的主目录都删掉，重新checkout来解决的。但是随着项目的深入开展，要更新的文件越来越多。这个问题迟早要解决的，试试看吧。问题的关键看来需要找到死锁的地方，解锁才行。网上查了下资料。Svn的operation是存放在“work queue’“里的。而“work queue’是在内嵌数据库wc.db的work_queue表中的。看看work_queue表中放了些什么，再做处理。 1. 内嵌数据库一般是用sqlite进行轻量级管理的。网上可以下到sqlite-shell-win32-x86: sqlite3.exe 2. 为了方便命令行执行，将sqlite3.exe放到svn 项目的主目录下，和.svn目录同级下。 3. 执行 sqlite3 .svn/wc.db "select * from work_queue".看到有4条记录。就是刚才我执行的一些操作。 226539|(sync-file-flags 93目录名 文件名) 226540|(file-remove 21 .svn/tmp/svn-7B43C232) 226541|(sync-file-flags 目录名 文件名) 226542|(file-remove 21 .svn/tmp/svn-7B48224E) 4. 执行 sqlite3 .svn/wc.db "delete from work_queue". 把队列清空。 5. 执行 sqlite3 .svn/wc.db "select * from work_queue". 确认一下是否已经清空队列，发现已经没有记录显示，说明已经清空了。 6. 最后再试一下，看是否可以 clean up了。果然成功了。 另外还有一种方法别人也推荐，但因为这个成功了就没再试。就是使用命令行工具svn.exe 执行cleanup svn项目目录。因为默认安装的时候，这个命令行工具是不被安装的，所以需要启动安装程序，选择”修改“，选上”命令行工具“才行。估计这个命令的实际效果和上面一种方法是类似的。不过应该比图形界面的右键菜单的更强大些吧。有兴趣可以试试。 顺便补充一下， sqlite是一个非常常用的嵌入式数据库，就是一个db文件。像手机qq等这些软件都会内置一个这样的数据库进行多条数据的管理。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7a499abe2aa1ad2bb8a37ca118f95ad/" rel="bookmark">
			Linux_IPtables防火墙详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 目录Iptables Iptables结构 规则表规则链 iptables指令用法详解 综合案例SNAT 策略DNAT 策略Iptables规则的备份和还原iptables 练习 Iptables iptables(Linux package filter firewall (network layer))是Linux内核集成的IP信息包过滤系统，该系统有利于在Linux系统上更好地控制IP信息包过滤和防火墙配置。防火墙在做信息包过滤决定时，有一套规则，这些规则存储在专用的信息包过滤表中，而这些表集成在Linux内核中。在信息包过滤表中，规则被分组放在我们所谓的链(chain)中。而netfilter/iptables IP信息包过滤系统是一款功能强大的工具，可用于添加、编辑和移除规则。虽然netfilter/iptables IP信息包过滤系统被称为单个实体，但它实际上由两个组件netfilter和iptables组成。 netfilter组件：也称为内核空间(kernelspace)，是内核的一部分，由一些信息包过滤表组成，这些表包含内核用来控制信息包过滤处理的规则集。 iptables 组件：是一种工具，也称为用户空间(userspace)，它使插入、修改和除去信息包过滤表中的规则变得容易。除非您正在使用Red Hat Linux 7.1或更高版本，否则需要下载该工具并安装使用它。
Iptables结构 表内有若干条链，链内有若干条规则。
规则表 表的作用：容纳各种规则链 表的划分依据：防火墙规则的作用 4个规则表： nat表：修改数据包中的源、目标IP地址或端口（网络地址转换） filter表：确定是否修改数据包（过滤）解决放同行的数据包 raw表：确定是否对该数据包进行状态跟踪 mangle表：为数据包设置标记 表内访问链的顺序： nat表：PREROUTING-&gt;POSTROUTING-&gt;OUTPUT filter表：INPUT-&gt;FORWARD-&gt;OUTPUT
规则链 规则的作用：对数据包进行处理和过滤 链的作用：容纳各种防火墙规则 5种规则链： INPUT：处理入站数据包 output：处理出战数据包 FORWARD(forward转发)：处理转发数据包 POSTROUTING(post routing路由选择后)：在进行路由选择后处理数据包 post 之后 PREROUTING(pre routing路由选择前)：在进行路由选择钱处理数据包 pre 之前 Attention：数据包处理流程 数据包入站： nat：PREROUTING-&gt;路由选择-&gt;filter:INPUT-&gt;本地应用程序 数据包转发： nat: PREROUTING-&gt;路由选择-&gt;filter:FORWARD-&gt;nat:POSTROUTING-&gt;转发走 数据包出站： nat: 本地应用程序-&gt;路由选择-&gt;filter:OUTPUT-&gt;nat:POSTROUTING-&gt;出站 iptables command use:
iptables指令用法详解 iptables [-t tableName] 选项 [链名] [条件] [-j 控制类型] #example: iptables -t filter -I INPUT -p icmp -j REJECT #reject ping protocols.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7a499abe2aa1ad2bb8a37ca118f95ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8f99e3330a563ba7032e0a5b838b796/" rel="bookmark">
			SQL错误：无法删除对象 &#39;****&#39;,因为该对象正由一个 FOREIGN KEY 约束引用。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 有时想删除某个表时，提示“无法删除对象 ‘*‘，因为该对象正由一个 FOREIGN KEY 约束引用”，原因很简单不要急躁，它被其它表的外键引用了，所以无法删除，在此只需先找到哪些表的外键引用了该表的字段。通过系统函数就能解决（SQL Server系统函数提供了非常完善的功能，能代替我们查找和解决许多问题）。
select fk.name,fk.object_id,OBJECT_NAME(fk.parent_object_id) as referenceTableName from sys.foreign_keys as fk join sys.objects as o on fk.referenced_object_id=o.object_id where o.name='被引用的表名' 以上SQL语句能够得到某个表被哪些外键引用，并且也显示出了外键表的表名。通过外键表的表名和外键名称执行以下语句即可删除外键。
ALTER TABLE dbo.被引用的表名 DROP CONSTRAINT 外键名 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b64291749e438bfeb6f9375f82893036/" rel="bookmark">
			iframe页面与父页面函数之间的调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		iframe元素 1. 调用iframe框架里的函数
var ifr=document.getElementById("iframe标签id");
var iframe=ifr.window||ifr.contentWindow;
iframe.a();//a（）方法即为iframe框架中的方法
2.iframe框架里的函数调用父页面里的函数
window.parent.close(); //close（）方法即为父页面里的元素
获取父页面元素
$(window.parent.document).find("#元素id").remove();
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c9b01ccdd0e3c1e97b82160fc18d19e/" rel="bookmark">
			字符串NSRange的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		// // main.m // OC语言学习 #import &lt;Foundation/Foundation.h&gt; int main(int argc, const char * argv[]) { @autoreleasepool { /* NSString类（和其他Foundation类）的一些方法中，使用了特殊的数据类型NSRange创建范围对象。实际上，它是结构的typedef定义，包含 location 和 length 两个成员 */ NSString *str1 = @"this is string A"; NSString *str2 = @"this is string B"; NSString *res; NSRange subRange; //从字符串中提取前3个字符 res = [str1 substringToIndex:3]; NSLog(@"%@",res); //thi //提取从索引5开始直到结尾的字符串 res = [str1 substringFromIndex:5]; NSLog(@"%@",res); //is string A //提取从索引8开始后的6个字符 res = [str1 substringWithRange:NSMakeRange(8, 6)]; NSLog(@"%@",res); //string //从另一个字符串中查找一个字符串 subRange = [str1 rangeOfString:@"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c9b01ccdd0e3c1e97b82160fc18d19e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db2e0a10c751a9140641a7fee39fac37/" rel="bookmark">
			入职公司这两周
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有一个学校，有一个班级，有一个团体；后来，有一场答辩，就这样散了。
答辩那一天很高兴接到面试公司的offer，然后，12月7号就匆匆地入职了。真的很匆匆，还没来得及向班上的每个人都打一声招呼，然后现在，班上的人现在都已经陆陆续续离开学校了，可能这一别以后都没有机会再见了。这三年过来真切地体会到有得有失这四个字的真谛。人不知道为什么总是这样，等到快要失去的时候，脑袋中才会不断闪现以前种种画面。
然后工作时间悄无声息地也过去了两个星期了，第一个星期可能是刚进公司，发现做的东西跟自己在学校学的东西不同的地方太多了，一时间很难接受，所以觉得时间过得特别慢，很痛苦。曾经不止一次地在脑海中跟自己说，那么难，放弃吧，辞职吧。忽然发现，其实自己也不是那么的坚强。忽然感觉以前的自己很可笑，总是觉得自己能够面对很多困难。然后就是每天上下班广州的上下班高峰期，也是让人痛苦不已，社会真的很残酷。已经深切体会到了。因为不懂所以尽管公司上班时间为7个小时，但是自己也独自“加班”，不停地研究公司的代码。程序员真是苦逼啊，但是是程序员又如何？他们也是一样为了生活而努力而已，只是工作性质不一样。同样是在为社会、为人民币贡献自己的力量。（因为老是看到有人黑程序员，所以。。。。。。）终于，第一周熬过去了，渐渐地我也是对这个项目算是有点了解，慢慢地做一些练习，也算是有点进步了。人都是在慢慢成长的，学习一个新的东西都有一个过渡期，过了也就过了，过不了时间长了最终还是能过。
12月19号，今天去看房了，想租房，因为学校离公司有点远。但是现实再一次让我当初想租房的心被打破。那些房都是很小、很阴森、很黑，没什么光线的。我不断地问自己，这真的是我想要的生活吗？但是自己内心也不是不明白，出来工作是这样的，好的房自己又没钱。忽然觉得很憋屈，很压抑。想起一句话，人在江湖，身不由己。可能你会说我清高了，租房不都是这样的吗？好吧，我不想说话了。可能我太清高了。
不知道以后会怎么样，当初大学该努力的努力了，得到了很多，也失去了很多。希望以后故事可以跟着我想的方向去发展。为自己付出的同时，也记得为家人、朋友去付出。
加油咯！！！！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d2b609c5d6f05e5c91cb51bf940d851/" rel="bookmark">
			Android 性能优化总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看了很多关于优化的介绍，最近项目也正处于这个阶段，看的太多太杂难免有些混乱，所以就整理记录下来，方便以后学习。
一、界面优化： (1).使用开发者选项中的[调试GPU过度绘制]根据显示的颜色判断
(2).使用开发者选项中的[GPU呈现模式分析]根据条形图，检测绘制失帧情况
(3).查看层级结构可以用HierarchyViewer的工具进行分析
(4).通过使用 Lint 来查找可能的布局优化。Lint 现在已经代替了 Layoutopt，而且更有效率
(5).避免过多无用的嵌套可以使用&lt;include&gt;标签重用layout 和 &lt;ViewStub&gt;延迟加载
二、内存优化： 1、减少内存的占用
(1)、使用FaceBook开源的图片加载框架Fresco，内存的申请放在了匿名共享内存中
(2)、可以通过Android Studio 中的Android Monitor Memory 查看内存占用情况和Gc回收的频率
2、内存泄漏:使用LeakCanary可以帮助我们发现问题然后用内存分析工具 MAT(Memory Analyzer Tool) 进行分析定位
常见的内存泄漏有：
(1)、非静态内部类的静态实例容易造成内存泄漏
(2)、activity使用静态成员
(3)、使用handler时的内存问题
(4)、注册某个对象后未反注册
(5)、集合中对象没清理造成的内存泄露
(6)、资源对象没关闭造成的内存泄露
(7)、Bitmap使用不当
三、数据优化： 1、优秀的网络请求框架如: Volley 、OkHttp、 Retrofit
2、优秀的数据解析框架如: Jackson 、Gjson
3、引入缓存机制
4、数据库优化：
(1)、建立索引
(2)、编译SQL语句
(3)、显示的使用事务
(4)、按需获取数据列信息
(5)、提前获取列索引
(6)、ContentValues的容量调整
(7)、及时关闭Cursor
(8)、耗时异步化
四、减少GC次数： GC会引起性能卡顿，也需要重点优化： 1、减少对象分配，找出不必要的对象分配，如可以使用非包装类型的时候，使用了包装类型；字符串的+号和扩容；
Handler.post(Runnable r)等频繁使用。
2、对象的复用，对于频繁分配的对象需要使用复用池。
3、尽早释放无用对象的引用，特别是大对象和集合对象，通过置为NULL，及时回收。
4、防止泄露，除了最基本的文件、流、数据库、网络访问等都要记得关闭以及unRegister自己注册的一些事件外，
还要尽量少的使用静态变量和单例。
5、控制finalize方法的使用，在高频率函数中使用重写了finalize的类，会加重GC负担，使得性能上有几倍的差别。
6、合理选择容器，在性能上优先考虑数组，即使我们现在习惯了使用容器，也要注意频繁使用容器在性能上的隐患点：首先是扩容开销， HashMap扩容时重新Hash的开销较大。其次是内存开销，HashMap需要额外的Map.Entry对象分配 ,需要额外内存，也容易产生更多的内存碎片。SparseArray和ArrayList等在内存方面更有优势。再次是遍历，对于实现了RandomAccess接口的容器如ArryList的遍历，不应该使用foreach循环。
7、用工具监控和精雕细琢：在页面滑动过程中，通过Memory Monitor查看内存波动和GC情况，
还可通过AlloCation Tracker工具观察内存的分配，发现很多小对象的分配问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d2b609c5d6f05e5c91cb51bf940d851/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02bccfd7be0bc7ed31c31ad235de1620/" rel="bookmark">
			Apache Camel rest实现重定向
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 很简单
在http返回的header里面加一个Location消息头，返回码改成301
示例代码如下：
package com.lala.rest.bean; import org.apache.camel.Exchange; import org.apache.camel.Processor; public class RedirectProcessor implements Processor { public void process(Exchange exchange) { permanentlyRedirect(exchange, "http://www.csdn.net"); } /** * 永久重定向 * 代表永久性转移(Permanently Moved)。 */ private void permanentlyRedirect(Exchange exchange, String location) { exchange.getOut().setHeader(Exchange.HTTP_RESPONSE_CODE, 301); exchange.getOut().setHeader("Location", location); } /** * 临时重定向 * 代表暂时性转移(Temporarily Moved )。 */ private void temporarilyRedirect(Exchange exchange, String location) { exchange.getOut().setHeader(Exchange.HTTP_RESPONSE_CODE, 302); exchange.getOut().setHeader("Location", location); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfbce516966e75a550376eaf196d0e58/" rel="bookmark">
			c&#43;&#43;学习之new int()和new int[]的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 new int[] 是创建一个int型数组，数组大小是在[]中指定，例如：
int * p = new int[3]; //申请一个动态整型数组，数组的长度为[]中的值
new int()是创建一个int型数，并且用()括号中的数据进行初始化,例如：
int *p = new int(10); // p指向一个值为10的int数。
在这里我想说一下，有些书上写的是为指针开辟10个字节的内存单元，这是错误的，自己一定要验证一下是否正确。
#include &lt;cstring&gt; int main() { using namespace std; int *p = new int(10); cout &lt;&lt; *p &lt;&lt; endl; }&lt;span style="color:#ff0000;"&gt; &lt;/span&gt;执行结果为10 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/835b6c333ace687d2bfbef1a85add641/" rel="bookmark">
			newrelic  安装使用  new relic
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		www.newrelic.com newrelic 是一家上市公司，监控做的很猛，免费版本就很强
注册完账户，
1.
安装 APM
32-bit:
sudo rpm -Uvh http://yum.newrelic.com/pub/newrelic/el5/i386/newrelic-repo-5-3.noarch.rpm 64-bit:
sudo rpm -Uvh http://yum.newrelic.com/pub/newrelic/el5/x86_64/newrelic-repo-5-3.noarch.rpm Install the agent:
sudo yum install newrelic-php5 sudo newrelic-install install Add your PHP license key Add your license key to the file you've set up with your New Relic properties:newrelic.ini or php.ini.
Your license setting:
newrelic.license="20xxxxxxxxxxxxxxxxa6" 卸载：
/usr/bin/newrelic-install 会有选择提示框，好像是选择2 然后就可以卸载了
2.
关闭浏览器监控脚本：（不关闭，会对ajax造成影响。）
设置完成后需要重启 restart newrelic daemon
/etc/init.d/newrelic-daemon restart 重启完成后，头部的js就没有了
3.安装SERVERS部分
rpm -Uvh https://download.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/835b6c333ace687d2bfbef1a85add641/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db464b4d8058d09b55eeb87dd228d605/" rel="bookmark">
			Python 中使用 string-escape 将带转义的字节码字符串转换为 utf-8 字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在调试 Intel Edison 上搜索 Wi-Fi 功能时，遇到一个问题，当搜索到的 Wi-Fi 名称带有中文时，代码中获取到的字符串是十六进制字节码的形式，如 \x91\xb8 这样的。但当我进入断点查看时，看到的结果是像这样: \\xe5\\xb0\\x8f\\xe7\\xb1\\xb3\\xe6\\x89\\x8b\\xe6\\x9c\\xba。很明显这是 \ 字符被转义了。我尝试直接通过 decode 方法转换编码，但是不行；直接 print 出来倒是可以得到正常的十六进制字节码的形式，但这不是我想要的；然后又尝试使用 replace 方法替换掉 \\，事实证明这个思路就是错误的，所有尝试方法的结果如图： 困惑了很久，最终求教于高手，高手点拨后，问题得以解决，原来是可以直接使用 decode 方法的，只是传入的编码参数需要指定为 string-escape，才能正常转码，如图： 解决问题之后，经过总结，发现我在这次调试过程中暴露了三大问题：
不应该直接将 \\xe5\\xb0\\x8f\\xe7\\xb1\\xb3\\xe6\\x89\\x8b\\xe6\\x9c\\xba 复制到交互环境里测试，因为此时复制进去的内容，不是，或者说不能确保是内存中的正确形式。要调试这样的编码问题，一般来说应该将内容保存进一个文本文件，写最小应用进行调试。基础知识不足，看的书太少，没有真正理解数据在计算机中的表示形式，导致闷头乱撞，浪费时间。思考问题时局限性太大，思路放不开，钻进牛角尖出不来。在事实证明当前道路走不通的情况下应该及时转变思考方向，避免浪费时间。 最终深刻体会了一个已经看过很多遍的道理：不懂不可怕，可怕的是压根不知道。
多看书，多学习，多思考，多总结。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36a073f54b7f5339b9407cb40cdd1b85/" rel="bookmark">
			性能监控的好工具 - NewRelic
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://newrelic.com/
这个玩意测速很好用
cpu 磁盘 php的执行文件耗时，数据库的表操作耗时（这个很xx）
前端页面加载的时间统计
https://ruby-china.org/topics/22379
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ef22e6de7a27af32d4295676d7dc92b/" rel="bookmark">
			在Ubuntu下进行安装 Node Version Manager
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.运行"apt-get install build-essential"
2.运行"apt-get install libssl-dev"
3.如果遇到找不到安装包的话运行 : "apt-get update"
4.curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.29.0/install.sh | bash
5.关闭Terminal 然后在重新启动Terminal
6.wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.29.0/install.sh | bash
7.nvm install 0.10.28
Node version : 0.10.28
转载于:https://www.cnblogs.com/dwj0931-node/articles/5045125.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8543b65f604d60bed080f605ff552fd/" rel="bookmark">
			git切换分支报错:error: pathspec &#39;origin/XXX&#39; did not match any file(s) known to git.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目上有一个分支test，使用git branch -a看不到该远程分支，直接使用命令git checkout test报错如下：
error: pathspec 'origin/test' did not match any file(s) known to git. 解决方法： 1、执行命令git fetch取回所有分支的更新
2、执行git branch -a可以看到test分支（已经更新分支信息）
3、切换分支git checkout test
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6590ea745603ba4a19c78d598dc52f8/" rel="bookmark">
			log4j.xml配置详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Xml代码
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!DOCTYPE log4j:configuration SYSTEM "log4j.dtd"&gt; &lt;log4j:configuration xmlns:log4j='http://jakarta.apache.org/log4j/' &gt; &lt;appender name="myConsole" class="org.apache.log4j.ConsoleAppender"&gt; &lt;layout class="org.apache.log4j.PatternLayout"&gt; &lt;param name="ConversionPattern" value="[%d{dd HH:mm:ss,SSS\} %-5p] [%t] %c{2\} - %m%n" /&gt; &lt;/layout&gt; &lt;!--过滤器设置输出的级别--&gt; &lt;filter class="org.apache.log4j.varia.LevelRangeFilter"&gt; &lt;param name="levelMin" value="debug" /&gt; &lt;param name="levelMax" value="warn" /&gt; &lt;param name="AcceptOnMatch" value="true" /&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;appender name="myFile" class="org.apache.log4j.RollingFileAppender"&gt; &lt;param name="File" value="D:/output.log" /&gt;&lt;!-- 设置日志输出文件名 --&gt; &lt;!-- 设置是否在重新启动服务时，在原有日志的基础添加新日志 --&gt; &lt;param name="Append" value="true" /&gt; &lt;param name="MaxBackupIndex" value="10" /&gt; &lt;layout class="org.apache.log4j.PatternLayout"&gt; &lt;param name="ConversionPattern" value="%p (%c:%L)- %m%n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6590ea745603ba4a19c78d598dc52f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06265da513f802e09bdc86bd02d00cf7/" rel="bookmark">
			百度静态资源cdn
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://cdn.code.baidu.com
查看原文：http://blog.indexroot.net/2015/12/13/%e7%99%be%e5%ba%a6%e9%9d%99%e6%80%81%e8%b5%84%e6%ba%90cdn/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd881e314ca0463f43183678e8bc13b1/" rel="bookmark">
			UrlRewrite的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了使url地址很好的隐藏，UrlRewrite不仅能使url看起来十分美观，而且能提高网站的安全性。UrlRewrite使用起来十分方便。
步骤一：创建一个java web项目，并且下载UrlRewrite的jar包。
步骤二：把UrlRewrite的jar包放在项目的lib目录下。
步骤三：把UrlRewrite的xml—&gt;urlrewrite.xml放在WEB-INF目录下（特别提醒：urlrewrite.xml必须放在WEB-INF目录下，否则没有重写url效果）
步骤四：在web.xml中加入如下代码：
主要作用是拦截请求，把请求拦截到urlrewrite.xml文件中进行url重写。
步骤五：在urlrewrite.xml文件中写url重写配置
其中标签中是使用了java的正则表达式，具体的我就不说明了。网上有很多匹配的例子，有需要可以自行查看。
步骤六：编写index.jsp以及test.jsp文件
步骤七：运行项目
注意：在jsp中的a标签中必须使用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15057864c270f626b0aa1bf6de421d71/" rel="bookmark">
			android 解码出来的视频frame数据，是如何一步步的传递到显示端的(使用 GPU offline 合成)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经过一段时间的研究，对android视频解码，直到显示端的整体流程，有了浅薄的理解
这里总结一下，解码出来的视频帧，是怎么一步步走到显示的。
平台: Exynos 4412 android 4.4
1, Exynos 4412 视频编解码依赖于硬件MFC。 解码出来的数据，不会进行原始数据的搬运。实际传递的是这些解码完数据的物理地址。
2，显示端硬件获得这些数据的物理地址，用这些物理地址取数据进行显示
3，这里不研究解码驱动和显示驱动。内核态的东西留到以后再研究。这里只研究了android中的流程
4，整体上，可以理解为
MFC-&gt; V4L2 -&gt; OMX -&gt; awesomeplayer -&gt; sufrfaceflinger -&gt; bufferqueue-&gt; sufrfaceflinger -&gt; HWcomposer -&gt; GPU -&gt; DISPLAY
1，初始化的时候，
-----&gt; allocateOutputBuffersFromNativeWindow
-----&gt; status_t OMXNodeInstance::useGraphicBuffer
-----&gt; virtual status_t useGraphicBuffer
-----&gt; status_t OMXNodeInstance::useGraphicBuffer2_l
-----&gt; OMX_UseBuffer -----&gt; SEC_OMX_UseBuffer //temp_bufferHeader-&gt;pBuffer = pBuffer; //这里就是把graphicBuffer-&gt;handle复制给了bufferHeader-&gt;pBuffer，也就是data_ptr，也就是存贮一些地址值的内存，也就是graphicBuffer-&gt;handle中最终存储了解码完毕数据存放地址信息，最后传给显示
说到底，就是MediaBuffer中指向了有效的data_ptr， MediaBuffer指向了GraphicBuffer，graphicBuffer-&gt;handle实际上就是data_ptr
所以一开始传的是MediaBuffer，最后又传的GraphicBuffer， 但是都能使用到data_ptr
2，解码过程运转起来之后
-----&gt; SEC_OutputBufferGetQueue里面，把pSECComponent-&gt;processData[OUTPUT_PORT_INDEX].dataBuffer = dataBuffer-&gt;bufferHeader-&gt;pBuffer;
-----&gt; SEC_MFC_H264_Decode_Nonblock里面
-----&gt; SsbSipMfcDecGetOutBuf 获取到解码完的数据物理地址填充到dataBuffer，也就是填充到了dataBuffer-&gt;bufferHeader-&gt;pBuffer，然后一步步往上送
-----&gt; sec_mfc_bufferProcess
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15057864c270f626b0aa1bf6de421d71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6835799f68d3933e5ed23d51d22708f8/" rel="bookmark">
			stagefright使用surfaceflinger buffer 的分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前学习了surfaceflinger和stagefright 两大模块， 这两大模块之间联系最大的地方，就是surfaceflinger 管理显示buffer，然后stagefright 如何用这个buffer 这里总结一下这一块自己学习的知识点 平台samsung exynos ，android 4.4 实际上本文想研究的就是三个问题： （1）如何获取显示buffer，并且怎么把它告诉给OMX （2）解码的时候，OMX如何把这个buffer告诉给解码器，作为视频数据输出的buffer （3）有了buffer了，buffer里面有了数据了，如何显示出来 下面对这三点分开讨论 本文参考了大牛 http://blog.csdn.net/gzzaigcn/article/category/2135451 的一些分析。 在此文章基础上做了扩展。感谢前人的肩膀。 一，如何申请显示output buffer，以及如何设置给OMX来使用 1.来看解码输出缓存在surfaceflinger下的缓存申请： status_t OMXCodec::allocateBuffersOnPort(OMX_U32 portIndex) { if (mNativeWindow != NULL &amp;&amp; portIndex == kPortIndexOutput) { return allocateOutputBuffersFromNativeWindow();//使用surface渲染，为输出分配图形缓存GraphicBuffer } 可以看到当申请的是NativeWindow形式的buffer，这说明了输出的buffer是需要去直接完成render的，所以输出缓存区要从本地窗口buffer进行申请： 2.allocateOutputBuffersFromNativeWindow的实现 SurfaceFlinger架构下的Buffer申请机制可以看前面提到的博文， 先贴代码，已经去除一些细枝末节的代码： status_t OMXCodec::allocateOutputBuffersFromNativeWindow() { status_t err = mOMX-&gt;getParameter( mNode, OMX_IndexParamPortDefinition, &amp;def, sizeof(def)); if (err != OK) { CODEC_LOGE("getParameter failed: %d", err); return err; } err = native_window_set_buffers_geometry( mNativeWindow.get(), def.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6835799f68d3933e5ed23d51d22708f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/892c976e5793be3db4805d5f66398a48/" rel="bookmark">
			nginx配置文件参数详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nginx配置文件主要分为4部分：
main(全局设置) main部分设置的指令将影响其他所有设置
server(主机设置)server部分的指令主要用于指定主机和端口
upstream(负载均衡服务器设置)upstream指令主要用于负载均衡，设置后端服务器
location(URL匹配特定位置的设置)部分用于匹配网页位置
这四者之间的关系：
server继承main，location继承server，
upstream既不会继承其他设置也不会被继承
-------------------------------------------------------------------------------------------------------------------
#user是主模块指令，定义Nginx运行的用户和用户组
user www www;
#worker——processes是主模块指令，指定了nginx要开启的进程数，每个nginx进程平均耗费10M-12M，
建议设置为等于CPU总核心数。
worker_processes 8;
#error_log是个主模块指令，用来定义全局错误日志文件，日志输出级别有[ debug | info | notice | warn | error | crit ]可供选择，其中debug输出日志最为详细，而crit输出日志最少。
error_log /var/log/nginx/error.log info;
#pid是主模块指令，用来指定进程id的存储文件位置
pid /var/run/nginx.pid;
#一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（系统的值ulimit -n）与nginx进程数相除，但是nginx分配请求并不均匀，所以建议与ulimit -n的值保持一致。
worker_rlimit_nofile 65535;
#events指令用来设定nginx工作模式与连接数上限
events
{
#use是个事件模块指令，用来指定nginx的工作模式，nginx支持的工作模式有[ kqueue、rtsig、epoll、poll、select、 /dev/poll];select和poll都是标准的工作模式，kqueue和epoll是高效的工作模式，不同的是epoll用在linux平台上，而kqueue用在BSD系统中，对于linux系统，epoll工作模式时首选
use epoll;
#worker_connections事件模块指令，用于定义nginx每个进程的最大连接数，默认是1024，最大客户端连接数有worker_processes和worker_connections决定，即max_client=worker_processes*worker_connections,在作为反向代理是变为:max_clients=worker_processes*worker_connections/4。进程的最大连接数受linux系统的最大打开文件数限制，在执行操作系统命令“ulimit -n 65535”后worker_connections的设置才能生效。
worker_connections 65535;
}
-------------------------------------------以上是全局配置-------------------------------------
#设定http服务器
http
{
include mime.types; #主模块指令，实现对配置文件所包含的文件设定，可以减少主配置文件的复杂度，类似apache中的include方法。
default_type application/octet-stream; #属于http核心模块指令，这里默认类型为二进制流，也就是当文件类型未定义是使用这种方式，例如在没有配置php环境时，nginx是不予解析的，此时，用浏览器访问php文件就会出现下载窗口
#charset utf-8; #默认编码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/892c976e5793be3db4805d5f66398a48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39e207293d28e70e09abdcb073ab8e37/" rel="bookmark">
			[ERR] Node  is not empty. Either the node already knows other nodes (check with C
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在给公司网管系统redis集群环境添加节点时候遇到一个问题，提示新增的Node不为空：
[root@node00 src]# ./redis-trib.rb add-node --slave --master-id4f6424e47a2275d2b7696bfbf8588e8c4c3a5b95 172.168.63.202:7001172.168.63.202:7000
......
[OK] All nodes agree about slotsconfiguration.
&gt;&gt;&gt; Check for open slots...
&gt;&gt;&gt; Check slots coverage...
[OK] All 16384 slots covered.
Connecting to node 172.168.63.202:7001: OK
[ERR] Node 172.168.63.202:7001 is not empty. Either the nodealready knows other nodes (check with CLUSTER NODES) or contains some key in database 0.
解决方法：
1)、将需要新增的节点下aof、rdb等本地备份文件删除；
2)、同时将新Node的集群配置文件删除,即：删除你redis.conf里面cluster-config-file所在的文件；
3)、再次添加新节点如果还是报错，则登录新Node,./redis-cli–h x –p对数据库进行清除：
172.168.63.201:7001&gt; flushdb #清空当前数据库
通过以上解决方法中的1)、2)或者3)之后再执行脚本，成功执行；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fc5c51e9b2718e3a7ebb948111e529e/" rel="bookmark">
			leetcode -- Count and Say -- 理解题意
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 https://leetcode.com/problems/count-and-say/
重点在理解题意。count and say
class Solution(object): def countAndSay(self, n): """ :type n: int :rtype: str """ if n == 1: return "1" else: last = self.countAndSay(n - 1) digit,count = last[0], 0 res = "" for i in xrange(len(last)): if last[i] != digit: res += str(count) + str(digit) digit = last[i] count = 1 else: count += 1 return res + str(count) + str(digit) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b78169a3230f545016afa86442dab126/" rel="bookmark">
			android实现手机端控制电脑PPT播放的APP（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这个想法是JAVA的课程设计，写一个android端应用程序，我和同学两人一组完成这个APP的开发。 我们有过很多想法，但是大多需要用到数据库的支持，觉得在如此有限的时间内完成的可能性不是很大。想到现在需要使用PPT的人数及频率越来越高，PPT控制笔虽好用但功能较单一，最重要的是需要买额外的硬件设备，如果我不想花钱，又想方便的放映PPT，无疑手机APP是最好的实现渠道了。在确定了这个想法后，我们便开始动手实现了。 对于该APP的功能及实现的大致思路我们改动了好几次，由于博客写的比较晚，目前已经定下来基本功能。 1、手机模拟电脑触摸板，方便直接用手机端打开PPT文件； 2、PPT放映按钮，从开始放映，从当前页放映，前一张，后一张，激光笔等等； 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ba56954605a3554c8279bf85fe1ec70/" rel="bookmark">
			谷歌的导航抽屉NavigationView、DrawerLayout的去掉默认的图标颜色和选中颜色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		谷歌的导航抽屉NavigationView、DrawerLayout的去掉默认的图标颜色和选中颜色 谷歌的抽屉导航还是挺好用的,但是总感觉封装过度了,很多东西不能改 能修改的东西也就这些,但是如果要修改更多似乎有点无能为力了
&lt;attr name="android:background"/&gt; &lt;attr name="android:fitsSystemWindows"/&gt; &lt;attr name="android:maxWidth"/&gt; &lt;attr name="elevation"/&gt; &lt;attr name="menu" format="reference"/&gt; &lt;attr name="itemIconTint" format="color"/&gt; &lt;attr name="itemTextColor" format="color"/&gt; &lt;attr name="itemBackground" format="reference"/&gt; &lt;attr name="itemTextAppearance" format="reference"/&gt; &lt;attr name="headerLayout" format="reference"/&gt; 不能修改图标的选中颜色或者默认颜色,甚至图标都不能正常显示 看了一下源代码:
final ColorStateList itemIconTint; if (a.hasValue(android.support.design.R.styleable.NavigationView_itemIconTint)) { itemIconTint = a.getColorStateList( android.support.design.R.styleable.NavigationView_itemIconTint); } else { itemIconTint = createDefaultColorStateList(android.R.attr.textColorSecondary); } 这里会根据主题和设置的颜色自动改变选中状态的颜色
还有一个问题,那就是使用menu菜单的话自定义程度也是很低的,比如我想要一个菜单包含一个组的名字,我又想把背景设置成黑色,这时候你发现改不了组的名称字体颜色
&lt;item android:id="@+id/nav_music_source" android:title="Music Source"&gt; &lt;menu&gt; &lt;item android:id="@+id/nav_my_favorite" android:checkable="true" android:icon="@drawable/icon_drawer_menu_favorite" android:title="My Favorite"&gt; &lt;/item&gt; &lt;item android:id="@+id/nav_local_music" android:checkable="true" android:icon="@drawable/ic_drawer_collect" android:title="Local Music"&gt; &lt;/item&gt; &lt;item android:id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ba56954605a3554c8279bf85fe1ec70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6818ffe61b398927c522edbb405a08e0/" rel="bookmark">
			STM32F407的ADC单次转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用到的引脚是PA3也就是ADC1的通道3
1、ADC的主要参数
a、分辨率----stm32f407的分辨率有6位、8位、10位、12位，参考电压如果是3.3 那么最小分辨率就是3.3/4095。
b、转换时间----stm32f407的最高允许频率是36M,最快转换时间 = 3+12个周期 =0.71us。
c、参考电压----2.4至3.3v。
2、工作过程分析
ADC转换是把外面输入到引脚的电压值转换成数字信号，单片机里面有一个模拟至数字的转换模块，我们可以控制它采集引脚的电压，stm32F407可以利用void ADC_SoftwareStartConv(ADC_TypeDef* ADCx)这个函数来控制转换。
3、详细的步骤
一、开启时钟 设置端口IO
RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA,ENABLE);//使能GPIOA时钟
RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1,ENABLE);//使能ADC1时钟
/*端口设置为模拟输入*/
GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;/*模拟输入*/
GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;/*通道3*/
GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;/*­不带上下拉*/
GPIO_Init(GPIOA,&amp;GPIO_InitStructure);/*初始化*/
上面主要是设置了GPIOA 和ADC1的时钟，并且把PA3设置为模拟输入。
二、设置通用控制寄存器 ADC_CommonInitStructure.ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;/*DMA失能*/
ADC_CommonInitStructure.ADC_Mode = ADC_Mode_Independent;/*独立模式*/
ADC_CommonInitStructure.ADC_Prescaler = ADC_Prescaler_Div4;/*设置ADC的频率为APB2/4 即84/4=21M*/
ADC_CommonInitStructure.ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_5Cycles;/*采样间隔时间*/
ADC_CommonInit(&amp;ADC_CommonInitStructure);/*初始化*/
三、ADC的初始化 ADC_InitStructure.ADC_Resolution = ADC_Resolution_12b;/*12位模式*/
ADC_InitStructure.ADC_ScanConvMode = DISABLE;/*非扫描模式*/
ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;/*关闭连续转换*/
ADC_InitStructure.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;/*禁止触发检测 使用软件触发*/
ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;/*右对齐*/
ADC_InitStructure.ADC_NbrOfConversion = 1;/*只使用1通道 规则通为1*/
ADC_Init(ADC1,&amp;ADC_InitStructure);/*初始化*/
ADC_Cmd(ADC1,ENABLE);/*开启ADC*/
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6818ffe61b398927c522edbb405a08e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20fc185b06c7abb82cee5f2269446041/" rel="bookmark">
			android Textview 使用之一：伸缩效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		android开发过程中，经常遇到Textview展示不完全的情况。 遇到此情况，通常的处理是： 方案一，Textview添加android:ellipsize属性，让展示不完的部分使用省略号代替。然后给Textview设置点击事件跳转到另一个Activity让其显示完全。 方案二，我们在很多应用中都能看到有向下的箭头或者“查看详情”的字样，点击后他会自动撑开，让TextView显示完整。
原来我们的项目里都是用的第一种方法，很显然，太不高大上了。今天找到了一种既简单又高大上的方法。
下面来看下Demo例子的收起效果，文本内容没有展示完全，使用省略号代替，提示“更多”和向下箭头标识，截图如下： 对于以上效果，实现思路如下：
1、设置Textview默认展示固定行，比如3行，内容展示不完全，在Textview尾部使用省略号代替。
xml文件内容为： &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_marginLeft="15dp" android:layout_marginRight="15dp" android:layout_marginTop="15dp"&gt; &lt;ImageView android:layout_width="20dp" android:layout_height="20dp" android:layout_gravity="left" android:background="@drawable/ico_jianjie"/&gt; &lt;TextView android:id="@+id/tv_teamdetail_introduce" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_marginLeft="10dp" android:ellipsize="end" android:maxLines="2" android:singleLine="false" android:textColor="@color/dark_grey" android:textSize="@dimen/text_size_small"/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:id="@+id/ll_teamdetail_good" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_marginBottom="15dp" android:layout_marginLeft="15dp" android:layout_marginRight="15dp" android:layout_marginTop="15dp" android:orientation="horizontal"&gt; &lt;ImageView android:layout_width="20dp" android:layout_height="20dp" android:layout_gravity="left" android:background="@drawable/ico_shanchang"/&gt; &lt;TextView android:id="@+id/tv_teamdetail_good" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_gravity="center" android:layout_marginLeft="10dp" android:ellipsize="end" android:maxLines="2" android:singleLine="false" android:textColor="@color/dark_grey" android:textSize="@dimen/text_size_small"/&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:id="@+id/ll_teamdetail_all" android:layout_width="match_parent" android:layout_height="35dp" android:layout_marginTop="1dp" android:background="@color/btn_white_selector" android:gravity="center" android:orientation="horizontal"&gt; &lt;TextView android:id="@+id/tv_all_detail" android:layout_width="wrap_content" android:layout_height="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20fc185b06c7abb82cee5f2269446041/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a93f708fca676ea6547a115fcd1646b/" rel="bookmark">
			20个jquery地图插件-上（基于Google Maps API）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 20个jquery地图插件-上（基于Google Maps API） 详情网址： http://www.136go.com/article_81.html 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5e6c440c600b76c50d226a4f6888e78/" rel="bookmark">
			更改VMware虚拟机硬件版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天想把笔记本中的workstation迁移到ESXi中去，发现报错。原因是我的workstation是11.0版本，而ESXi是5.0版本，必须将11.0版本降级到8.0以下或者升级ESXi。
所谓虚拟硬件，这就相当于适用于主机的物理硬件。虚拟硬件包括 BIOS 和 EFI、可用虚拟 PCI 插槽、CPU 最大数量、最大内存配置以及其他特性。那各个硬件版本之间的区别是什么呢？请参考--http://pubs.vmware.com/vsphere-55/index.jsp?topic=%2Fcom.vmware.vsphere.vm_admin.doc%2FGUID-789C3913-1053-4850-A0F0-E29C3D32B6DA.html
试过去改vmx配置文件，virtualHW.version = "11"，将11改成8，但是不行。只能通过VMware自带的工具来修改。
虚拟机PowerOff，右键选择“更改硬件兼容性”
需要改成workstation 8.0版本以兼容ESXi 5.0
选择是重新创建新的虚拟机还是更改此虚拟机
更改完成后即可重新迁移。
参考--
http://kb.vmware.com/selfservice/microsites/search.do?language=en_US&amp;cmd=displayKC&amp;externalId=2048332
http://pubs.vmware.com/vsphere-55/index.jsp?topic=%2Fcom.vmware.vsphere.vm_admin.doc%2FGUID-789C3913-1053-4850-A0F0-E29C3D32B6DA.html
http://kb.vmware.com/selfservice/microsites/search.do?language=en_US&amp;cmd=displayKC&amp;externalId=2076671
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13448f5e9d9132eb81018a2bb344317d/" rel="bookmark">
			CF 600D(Area of Two Circles&#39; Intersection-2圆面积并)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给2圆求面积并
花式卡精度，这题告诉我们运输过程中应尽量避免出现 π #include&lt;cstdio&gt; #include&lt;iomanip&gt; #include&lt;cstring&gt; #include&lt;cstdlib&gt; #include&lt;algorithm&gt; #include&lt;functional&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;cctype&gt; #include&lt;ctime&gt; using namespace std; #define For(i,n) for(int i=1;i&lt;=n;i++) #define Fork(i,k,n) for(int i=k;i&lt;=n;i++) #define Rep(i,n) for(int i=0;i&lt;n;i++) #define ForD(i,n) for(int i=n;i;i--) #define RepD(i,n) for(int i=n;i&gt;=0;i--) #define Forp(x) for(int p=pre[x];p;p=next[p]) #define Forpiter(x) for(int &amp;p=iter[x];p;p=next[p]) #define Lson (x&lt;&lt;1) #define Rson ((x&lt;&lt;1)+1) #define MEM(a) memset(a,0,sizeof(a)); #define MEMI(a) memset(a,127,sizeof(a)); #define MEMi(a) memset(a,128,sizeof(a)); #define INF (2139062143) #define F (100000007) #define pi (3.14159265358979323846264338324990142) typedef long double ld; typedef long long ll; ll mul(ll a,ll b){return (a*b)%F;} ll add(ll a,ll b){return (a+b)%F;} ll sub(ll a,ll b){return (a-b+llabs(a-b)/F*F+F)%F;} void upd(ll &amp;a,ll b){a=(a%F+b%F)%F;} int main() { // freopen("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13448f5e9d9132eb81018a2bb344317d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c53629fd9ed7bfd61234cc9a72bfaf2/" rel="bookmark">
			PS 修改图片上的文字内容但保留文字格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发项目需要把公司logo修改一下，想要修改图片上文字内容的一部分，保留文字格式。
纯粹PS菜鸟，不过最后效果还可以，logo图片比较简单
第一步：把图片中的文字截出单独保存成图片
第二步：打开网址http://www.qiuziti.com/（这是一个专门识别中文字体的网站）
第三步：上图红框中选择你电脑上的文字图片，点击“开始上传”按钮，上传结果如下图
第四步：在白色框中输入上面的黑色字体，然后点击“开始搜索”按钮，如下图
（尽可能把能打出来的字都打出来）
第六步：将字体与给出结果进行比对，如图
从上面可以看出“汉真广标”字体与图片统一，这里我们就找到图片中的文字字体啦
下面是用PS软件将图片文字修改
打开PS，将要修改的图片在PS中打开
第一步：选择修复画笔工具
第二步：用“吸管”工具取色（在空白处点击一下）
第三步：用画笔工具把“山河”两个字涂掉（涂抹时右键可以调整画笔大小）
第四步：选择“横排文字工具”字体选择我们之前识别好的“汉真广标”（系统不自带可以网上下载字体然后将.ttf文件复制粘贴到C:\Windows\Fonts目录下就OK）字号可以调整，我自己有取色工具就直接把文字颜色一取然后在右边“颜色”处输入相应的R G B值
第五步：在相应位置输入文字即可（位置大小都可以调整）
第六步：文件-》存储 为JPEG格式-》
Over
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5c6f94ffa70933e82a597c06e4b98f0/" rel="bookmark">
			细数Scala下划线“_”的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一：初始化的时候。
object Sample { var name:String=_ def main (args: Array[String]){ name="hello world" println(name) } 在这里，name也可以声明为null，例：var name:String=null。这里的下划线和null的作用是一样的。
第二：引入的时候。
import math._ object Sample { def main (args: Array[String]){ println(BigInt(123)) } } 这里的math._就相当于Java中的math.*; 即“引用包中的所有内容”。
第三：集合中使用。（最典型，最常用）
object Sample { def main (args: Array[String]){ val newArry= (1 to 10).map(_*2) println(newArry) } } 这里的下划线代表了集合中的“某（this）”一个元素。这个用法很常见，在foreach等语句中也可以使用。
第四：模式匹配。
object Sample { def main (args: Array[String]){ val value="a" val result= value match{ case "a" =&gt; 1 case "b" =&gt; 2 case _ =&gt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5c6f94ffa70933e82a597c06e4b98f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e73fc4013d516f525826ce888dc2dd25/" rel="bookmark">
			AD域控 Dsquery 查询命令实例汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在AD管理中，有了查询可以为工作省去很多麻烦。
几个通用的参数：
-limit 0 指定传回符合搜寻条件的对象数目，如果值是 0，将传回所有符合的对象。如果不指定此参数，根据默认将只显示前 100 个结果。
-o{dn | rdn | upn | samid}指定输出格式。预设: 分辨名称 (DN)。
-desc寻找描述符合筛选器&lt;Description&gt; 的使用者
1. dsquery computer - 寻找目录中的计算机
1.1 寻找过去四星期以来不在作用中的所有计算机
dsquery computer -inactive 4 -limit 0
1.2 寻找100天未变更密码的计算机
dsquery computer ou=test,dc=china,dc=com -stalepwd 100 -limit 0
1.3 寻找帐户已经停用的计算机
dsquery computer domainroot -disabled -limit 0
1.4 寻找账户已经停用的,名称以P开头，描述以ms开头的所有计算机
dsquery computer domainroot-disabled -name P* -desc ms* -limit 0
1.5 寻找名称以P开头，描述以ms开头的所有计算机
dsquery computer domainroot -name P* -desc ms*
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e73fc4013d516f525826ce888dc2dd25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac7ae7d4064e6504e0369b4a8e9fccfe/" rel="bookmark">
			消息机制Too many arguments to function call错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在学习runtime的消息机制时
使用 objc_msgSend(); 总是报错误 : Too many arguments to function call, expected 0, have 2
这样修改一下设置就可以了
Project -&gt; Build Settings -&gt; 搜索enable strict -&gt; 将Enable Strict Checking of objc_msgSend Calls 设置为No
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f21acb00c254e8736ba81c2e580a134/" rel="bookmark">
			android利用回调函数在对话框中传递数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		android开发中，往往需要在当前activity中打开一个输入框来获取用户数据，但是怎么将输入框的数据传递到activity中呢？ 一种方法是创建一个全局变量，在对话框中将数据传递给静态全局变量，然后在当前activity中使用它。这种方式繁琐而且不待见，因为静态全局变量是一直存在的，处理不好会发生很多问题。 另一种方式就是使用回调函数将数据传递回来。 先来看看效果图： 没有数据之前： 打开输入对话框并往对话框中输入数据： 然后按下输入框中的确定按钮，就将数据传递给了打开它的activity： 这里的回调函数，其实就是对对话框进行监听，这里的监听就是回调函数。当对话框完成数据的输入后，回调函数会将数据自动传回到对对话框进行监听的activity中。这样就实现了数据的共享和传递。要实现这样的回调函数很简单，只要定义一个接口，接口里定义一个获取数据的函数就可以了。 具体代码如下： 首先定义简单的布局： activity的布局和输入框的布局
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context=".DialogActivity"&gt; &lt;EditText android:id="@+id/showResult" android:layout_width="fill_parent" android:layout_height="wrap_content" /&gt; &lt;Button android:id="@+id/start" android:text="StartActivity" android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt; &lt;/LinearLayout&gt; 这里只使用了一个EditText文本框，用来显示从对话框传来的数据，一个Button按钮，用来打开对话框。 接着是自定义对话框的布局：
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;EditText android:id="@+id/edit" android:layout_width="200dp" android:layout_height="wrap_content" /&gt; &lt;Button android:layout_width="80dp" android:layout_height="60dp" android:id="@+id/sure" android:text="Sure"/&gt; &lt;/LinearLayout&gt; 自定义对话框的布局也比较简单，一个EditText用来输入数据，一个Button确定按钮。
接着在实现自定义对话框的类，这里为了方便，将接口定义在类里面，也可以将接口单独定义。
/** * Created by mhwang on 2015/11/18. */ public class MyDialog extends Dialog { //定义接口 public interface DataBackListener{ public void getData(String data); } private EditText editText; private Button btnSure; DataBackListener listener; //创建监听对象 public MyDialog(Context context, final DataBackListener listener) { super(context); //用传递过来的监听器来初始化 this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f21acb00c254e8736ba81c2e580a134/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc41fcad99d339c7e2192a3b4f621040/" rel="bookmark">
			Qt之操作数据库（SQLite）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QtSql模块提供了与平台以及数据库种类无关的访问SQL数据库的接口，这个接口由利用Qt的模型视图结构将数据库与用户界面集成的一套类来支持。 QSqlDatabase对象象征了数据库的关联。Qt使用驱动程序与各种数据库的应用编程接口进行通信。Qt的桌面版（Desktop Edition）包括如下一些驱动程序： 驱动程序 数据库 QDB2 IBM DB2 7.1版以及更新的版本 QIBASE Borland InterBase QMYSQL MySql QOCI 甲骨文公司（Oracle Call Interface） QODBC ODBC（包括微软公司的QSL服务） QPSQL PostgreSQL的7.3版以及更高版本 QSQLITE QSLite第3版 QSQLITE2 QSLite第2版 QTDS Qybase自适应服务器 由于授权的许可限制，Qt的开源版本无法提供所有的驱动程序，当配置Qt时，即可以选择Qt本身包含的SQL驱动程序，也可以以查件的形式建立驱动程序，公共领域中不断发展的SQLite数据库将向Qt提供支持。 如下讨论关于Qt进行SQLite的基本操作。 代码如下： //添加数据库驱动、设置数据库名称、数据库登录用户名、密码 QSqlDatabase database = QSqlDatabase::addDatabase("QSQLITE"); database.setDatabaseName("database.db"); database.setUserName("root"); database.setPassword("123456"); //打开数据库 if(!database.open()) { qDebug()&lt;&lt;database.lastError(); qFatal("failed to connect.") ; } else { //QSqlQuery类提供执行和操作的SQL语句的方法。 //可以用来执行DML（数据操作语言）语句，如SELECT、INSERT、UPDATE、DELETE， //以及DDL（数据定义语言）语句，例如CREATE TABLE。 //也可以用来执行那些不是标准的SQL的数据库特定的命令。 QSqlQuery sql_query; QString create_sql = "create table student (id int primary key, name varchar(30), age int)"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc41fcad99d339c7e2192a3b4f621040/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6462456946038605c0565f5d0f6dc0d8/" rel="bookmark">
			ubuntu如何降级到之前的版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 找出系统已经安装的内核版本，在终端里输入命令： dpkg --get-selections | grep linux-image 然后会显示系统中已安装的内核，例如： linux-image-3.0.0-32-generic instal linux-image-3.0.0-12-generic install linux-image-generic install 卸载新的内核版本，在终端里输入命令： sudo apt-get remove linux-image-3.0.0-32-generic 上面命令和含义是： dpkg --get-selections [&lt;表达式&gt; ...]把已选中的软件包列表打印到标准输出； grep linux-image 匹配查找； uname -a 查看已安装的linux内核版。 发现只有原先的内核版本了 最后update-grub一下，重启，就可以直接进入。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70de4f4a0217e9486ad78bd79832cab5/" rel="bookmark">
			ACM-ICPC北京赛区2015网络同步赛E:Stamps
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 链接 题意：Bob向Alice买邮票，每种邮票有无限张，Bob每次等概率选择一种邮票买（可以买买过的），每次代价为 H[i][k] ,其中 k 为给定常数且k&lt;10, H 的定义为：
H(i,0)=1, i=1,2,... H(i,k)=H(1,k−1)+H(2,k−1)+...+H(i,k−1),k&gt;0, i&gt;0 问期望用多少钱可以集齐所有 n 种邮票.n&lt;=100000 #include&lt;bits/stdc++.h&gt; using namespace std; const int Maxn=100020,M=1e6+3; int fac[Maxn],rev1[Maxn],rev2[Maxn]; int dp[Maxn][11]; int powmod(int x,int y) { int ret=1; while(y){if(y&amp;1)ret=1LL*ret*x%M;y&gt;&gt;=1;x=1LL*x*x%M;} return ret; } int main() { fac[0]=fac[1]=1; for(int i=2;i&lt;Maxn;i++)fac[i]=1LL*fac[i-1]*i%M; rev1[0]=rev1[1]=1; rev2[0]=rev2[1]=1; for(int i=2;i&lt;Maxn;i++)rev1[i]=1LL*(M-M/i)*rev1[M%i]%M; for(int i=2;i&lt;Maxn;i++)rev2[i]=1LL*rev2[i-1]*rev1[i]%M; for(int k=0;k&lt;10;k++) { for(int n=1;n&lt;Maxn;n++) { if(!k)dp[n][k]=(dp[n-1][k]+rev1[n])%M; else dp[n][k]=(dp[n-1][k]+1LL*rev1[n]*dp[n][k-1]%M)%M; } } int n,k; while(scanf("%d%d",&amp;n,&amp;k)!=EOF&amp;&amp;(n||k)) { printf("%lld\n",1LL*dp[n][k]*powmod(fac[n],10)%M*powmod(n,k+1)%M); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e5da99cc45c03f025d4fef6a1aa44c2/" rel="bookmark">
			python基础知识六
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博客园的博文对每篇博文的长度似乎做了限制
面向对象编程，
在程序何种，根据操作数据的函数或语句块来设计程序。这被成为面向过程的编程。还有一种把数据和功能结合起来，用称为对象的东西包裹起来组织组织程序的额方法。这种方法称为面向对象的编程理念。
类和对象是面向对象编程的两个主要方面。类创建一个新类型，而对象是这个类的实例。这类似于你有一个int的变量，这纯属整数的变量是int类的实例(对象)
对象可以使用普通的属于对象的变量存储数据。属于一个对象或累i的变量称为域。对象可以使用属于类的函数来具有功能。这样的函数被称为类的方法。这些属于帮助我们把它们与鼓励的函数和变量区分开来。域和方法可以合成为类的属性。
域有两种类型---属于每个实例/类的对象或属于类本身。它们分别被成为实例变量和类变量。
类使用class关键字创建。类的域和方法被列在一个缩进块中。
self
类的方法于普通的函数只有一个特别的区别---他们必须有一个额外的第一个参数名称，但是在调用这个方法的时候你不为这个参数赋值，python会提供这个值。这个特别的便利指对象本身，按照惯例它的名称是self.
虽然你可以给这个参数任何名称，但是强烈建议你使用self这个名称---其它名称都是不赞成使用的。使用一个标准的名称有很多优点-IDE和读者会容易识别
你一定很奇怪 python如何给self赋值以及为何你不需要给他赋值。举一个例子会使此变得清晰。假如你有一个类称为MyClass和这个类的一个实例MyObject。当你调用这个对象的方法MyObject.method（arg1,arg2）的时候，这会由python自动转化为MyClass.method(MyObject,arg1,arg2)--这就是self的原理了。
这也意味着如果你有一个不需要参数的方法，你还是得给这个方法定义一个self参数。
class Person:
pass
p=Person()
print p
输出：
$ python simplestclass.py
&lt;__main__.Person instance at 0xf6fcb18c&gt;
我们使用class语句后跟类名，创建了一个新的类。这后面跟着一个缩进的语句块形成类体。在这个例子中，我们使用了一个空白块，它由pass语句表示。
接下来，我们使用类名后跟一对圆括号来创建一个对象/实例。
为了验证，我们简单地打印了这个变量的类型，它告诉我们在__main__模块中有了一个Person类的实例。
可以注意到存储对象的计算机内存地址也打印了出来。这个地址在你的计算机上会是另外一个只，因为python可以在任何空位存储对象。
对象的方法
我们已经讨论了类/对象可以拥有像函数一样的方法，这些方法与函数的区别只是一个额外的sel变量。
class Person:
def sayHi(self):
print 'hello '
p=Person()
p.sayHi()
输出：
$ python method.py
Hello, how are you?
这里我们看到了self的用法，注意sayHi方法没有任何参数，但仍然在函数定义时有self
__init__方法
在python的类中有很多方法的名字有特殊的重要意义。
__init__方法在类的一个对象被建立时，马上运行。这个方法可以用来对你的对象做一些你希望的初始化。注意，这个名称的开始和结尾都是双下划线。
class Person:
def sayHi(self):
print 'hello,my name is ',self.name
def __init__(self,name):
self.name=name
p=Person('swaroop')
p.sayHi()
输出：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e5da99cc45c03f025d4fef6a1aa44c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01a40d69c507161f8b49c2abaf0b330d/" rel="bookmark">
			VS2013等版本中怎么写函数注释可以鼠标悬停自动显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 项目里代码多了，鼠标一指哪个函数就能有注释是比较方便的，但是我写了半天注释，鼠标怎么点也不自动显示，就查了下写在这里给需要的人参考下。
方法如下： 注释要写在函数实现的地方，才可以自动显示（我都是写在声明里了。。。。。）注释的格式如下: //注释 void test（xxx） 就是注释写在函数上边即可。 小白互相学习进步！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad7ba0e08f1dbd9854318fddcd7a3699/" rel="bookmark">
			Linux中修改环境变量及生效方法（永久、临时）环境变量查看
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux中修改环境变量及生效方法如下：
方法一： 在/etc/profile文件中添加变量【对所有用户生效（永久的）】 用vim在文件/etc/profile文件中增加变量，该变量将会对Linux下所有用户有效，并且是“永久的”。 要让刚才的修改马上生效，需要执行以下代码 # source /etc/profile 方法二： 在用户目录下的.bash_profile文件中增加变量【对单一用户生效（永久的）】 用vim在用户目录下的.bash_profile文件中增加变量，改变量仅会对当前用户有效，并且是“永久的”。 要让刚才的修改马上生效，需要在用户目录下执行以下代码 # source .bash_profile 方法三： 直接运行export命令定义变量【只对当前shell（BASH）有效（临时的）】 在shell的命令行下直接使用[export 变量名=变量值]定义变量，该变量只在当前的shell（BASH）或其子shell（BASH）下是有效的，shell关闭了，变量也就失效了，再打开新shell时就没有这个变量，需要使用的话还需要重新定义。 例如：export PATH=/usr/local/webserver/php/bin:$PATH ------------------------------------------------------------------------
按变量的生存周期来划分，Linux变量可分为两类，它们的修改方法如下:
(1)永久的:需要修改配置文件，变量永久生效。
常见的配置文件包括:
(1-1) /etc/profile:对所有用户生效;此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行;并从/etc/profile.d目录的配置文件中搜集shell的设置
例如:编辑/etc/profile文件，添加CLASSPATH变量
# vim /etc/profile
添加一行:
export CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib
修改后需要执行重新登录才能生效，也可以执行命令source /etc/profile来生效
(1-2) /etc/bashrc:对所有用户生效;
为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取。
编辑方法如上，不再赘述
(1-3) ~/.bash_profile:仅会对当前用户有效;
每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次。
例如:编辑yumh用户目录(/home/yumh)下的.bash_profile
$ vim /home/yumh/.bash.profile
添加如下内容:
export CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib
修改后需要执行重新登录才能生效，也可以执行命令source /etc/profile来生效
(1-4)
~/.bashrc:仅会对当前用户有效;
该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该该文件被读取。
编辑方法如上，不再赘述
另外，~/.bashrc等中设定的变量(局部)只能继承/etc/profile中的变量,他们是"父子"关系
综述，对上述文件修改，添加你需要的变量，在启动一个shell(终端，terminal)时，你所定义的变量均会生效的。
(2)临时有效:
使用export命令声明即可，变量只在当前的shell(BASH)或其子shell(BASH)下是有效的,在关闭shell后失效，再打开新shell时就没有这个变量，需要使用的话还需要重新定义。
在shell的命令行下直接使用[export 变量名=变量值] 定义变量
环境变量的查看
(1)使用echo命令查看单个环境变量。例如:
echo $PATH
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad7ba0e08f1dbd9854318fddcd7a3699/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b69f31416ca60e48a13cad43e975cfe/" rel="bookmark">
			修改linux用户密码（passwd）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 对于初学者来说,如何修改linux用户密码也不是件容易的事,其实非常简单,下面举例说明: （1）修改root用户密码
如果是以root身份登录,修改root密码.
只要输入 passwd 就会出现:
New password: Retype new password: 按提示输入密码确认即可.
（2）修改非root用户密码
如果想更改其他用户密码,只要输入passwd
如:passwd kook New password: Retype new password: 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9559cbd6fc0804b8d6d25b0d9dbfc59e/" rel="bookmark">
			mktime为什么这么慢
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/******************************************************************************************
*　版权声明
*　本文为本人原创，本人拥有此文的版权。鉴于本人持续受益于开源软件社区，
*　本人声明：任何个人及团体均可不受限制的转载和复制本文，无论是否用于盈利
*　之目的，但不得修改文章内容，并必须在转载及复制时同时保留本版权声明，否
* 则为侵权行为，本人保留追究相应主体法律责任之权利。
*　speng2005@gmail.com
*　2015-11
******************************************************************************************/
最近写了个C++小程序，没想到栽在mktime函数上，以前很少用过这个函数。
事情是这样的，在Linux上（debain，kernel 2.6.26）写一个C++小程序，实现将txt文件中的数据提取后简单处理并插入mysql数据库。逻辑很简单，程序也不大，写完以后跑600万行的txt数据文件，感觉比较慢，于是开始使用一个较小的数据文件跑优化工具来分析代码瓶颈。先后使用了OProfile，gprof和google-perftools这三个工具，最后发现还是google-perftools最好用。经过分析找到程序热点并不在之前所认为的mysql接口函数上，而是在一个将"1990-12-19"格式的字符串转换为日历时间即time_t类型的函数上，代码如下：
time_t getTimeOfDate(const string &amp; dateStr, string * timeStr = NULL) { stringstream &amp; mySS = getMyss(); //可以以'-'为分隔符的stringstream mySS.clear(); mySS.str(dateStr); int year,month,day; mySS&gt;&gt;year&gt;&gt;month&gt;&gt;day; if( month &gt; 12 || day &gt; 31 ) return (time_t)-1; struct tm stm; stm.tm_year = year - 1900; stm.tm_mon = month - 1; stm.tm_mday = day; stm.tm_hour = 0; stm.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9559cbd6fc0804b8d6d25b0d9dbfc59e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a58f048093145ec442908e99783e24e/" rel="bookmark">
			Epic Games Shows Incredible New Anti-Aliasing Technique – Screenshots &#43; Video Comparison
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Epic Games Shows Incredible New Anti-Aliasing Technique – Screenshots + Video Comparison AUGUST 20, 2014 JOHN PAPADOPOULOS 41 COMMENTS Epic Games has revealed some comparison screenshots and a video for its new anti-aliasing technique that was first used in its Infiltrator Tech Demo. Epic’s AA solution is called Temporal AA, is supported by Unreal Engine 4.4, and promises to be among the best modern-day AA techniques. We do have to note, however, that while Temporal AA does an incredible job at eliminating jaggies, it slightly blurs the whole image (a side effect similar to the one introduced by FXAA).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a58f048093145ec442908e99783e24e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d40bdd6162372b710f5189dac8e3f81d/" rel="bookmark">
			VS2010中几个常用目录说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上面截图中：
包含目录：添加.h文件地址
库目录：添加.lib文件地址[实际用到的lib文件在附加依赖项 中指定]
上面的截图中：
命令：指定调试时候的执行档所在的文件
工作目录：调试时候所需资源所在的目录
上图几个目录参数与执行档的名字和所在的文件夹有关
上图“输入”菜单中：
附加依赖项：.lib文件夹中实际需要被用到连接器中的文件
环境变量的设置：
Path：可以添加DLL，动态数据库文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ec812276c03832df3d3b156bb11f4d9/" rel="bookmark">
			技术疑惑解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、ftp上传压缩文件至liunx中，解压报错“invalid compressed data--format violated”
解决方案：ftp以bin方式重新上传文件。
二、获取class文件对应资源文件的路径
解决方案：XXX.class.getProtectionDomain().getCodeSource().getLocation().toURI();
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5ee3a2673f51ff2b2e873e9dc7d6a4e/" rel="bookmark">
			git 忽略本地文件的修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目开发过程中，会遇到本地配置文件每个开发人员不同的情况，但如果遇到类似数据库配置这种最终需要加入 git 版本控制的配置，则会陷入两难境地。要么不跟踪，要么有人提交后其他人同步下来必须手动修改，非常麻烦。其实，对于已被纳入版本管理的文件，git 也提供了很好的解决办法。
告诉git忽略对已经纳入版本管理的文件 .classpath 的修改，git 会一直忽略此文件直到重新告诉 git 可以再次跟踪此文件$ git update-index --assume-unchanged .classpath
告诉 git 恢复跟踪 $ git update-index --assume-unchanged .classpath
查看当前被忽略的、已经纳入版本库管理的文件：$ git ls-files -v | grep -e "^[hsmrck]"
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3738c84b798c9b860dca3288a33c396b/" rel="bookmark">
			mac 搭建 内网微信服务 ngrok
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先使用对是 ngrok的服务，不过这个服务器是放在国外不能访问了，国内的网友发布了一个部署在国内的服务器，地址：http://www.tunnel.mobi 搭建步骤： 1：下载命令行工具 下载地址：https://ngrokd.b0.upaiyun.com/clients/ngrok_for_macosx.zip 2：下载配置文件 下载地址：https://ngrokd.b0.upaiyun.com/ngrok.cfg 文件内容 server_addr: "tunnel.mobi:44433" trust_host_root_certs: true 3：拷贝文件这2个文件到一个独立的目录 我在本机事拷贝到了/user/local 目录 打开mac的终端 输入sudo -i 切换到root用户的权限 Last login: Sat Oct 24 11:28:19 on ttys000
pengyechendeMacBook-Pro:~ xx$ sudo -i
Password:
输入密码，则切换为root用户 拷贝ngrok 到 /usr/local 目录 xxxMacBook-Pro:~ root# cp /Users/xxxx/Downloads/ngrok /usr/local/
拷贝配置文件到 /usr/local 目录 xxxxdeMacBook-Pro:local root# cp /Users/chenpengye/Downloads/ngrok.cfg /usr/local
启动服务 pengyechendeMacBook-Pro:local root# ./ngrok -config ngrok.cfg -subdomain xxdomain 8080
xxdomain ：自己起的独立域名，不能重复 8080：要映射的端口 启动成功： ngrok (Ctrl+C to quit)
Tunnel Status online Version 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3738c84b798c9b860dca3288a33c396b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ca7c2aa2e42824ba51199f62006072b/" rel="bookmark">
			[Python] Numpy学习笔记（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Part2 1.
np.meshgrid(array1,array2) 产生两个矩阵，对应两个数组中所有(x,y)对 e.g. [IN]a=np.arange(-5,5,0.1) [IN]x,y=np.meshgrid(a,a) [OUT]x=array([[a[0],a[1],a[2],…,a[n-3],a[n-2],a[n-1], [a[0],a[1],a[2],…,a[n-3],a[n-2],a[n-1], [a[0],a[1],a[2],…,a[n-3],a[n-2],a[n-1], ..., [a[0],a[1],a[2],…,a[n-3],a[n-2],a[n-1], [a[0],a[1],a[2],…,a[n-3],a[n-2],a[n-1], [a[0],a[1],a[2],…,a[n-3],a[n-2],a[n-1]]) [OUT]y=array([[b[0],b[0],b[0], ...,b[0],b[0],b[0], [b[1],b[1],b[1], ...,b[1],b[1],b[1], [b[2],b[2],b[2], ...,b[2],b[2],b[2], ..., [b[n-3],b[n-3],b[n-3], ...,b[n-3],b[n-3],b[n-3], [b[n-2],b[0]n-2b[0], n-2..,b[0],b[0n-2,b[n-2], [b[n-1],b[n-1],b[n-1], ...,b[n-1],b[n-1],b[n-1]]) [IN] Z=plt.imshow(z) ;plt.colorbar() 2.Out=Np.where(bool_array, array1, array2) out[i]=array1[i] if bool_array[i] else array2[i] Array1和array2也可以是标量值 3. array.sum()/mean() 计算矩阵的和/均值，结果是一个数 array.sum(axis=1)/mean(axis=1) 计算该轴向上的和/均值，结果是低1维数组 array.std()/var() 计算标准差和方差，可以指定轴 array.min()/max() array.argmin()/argmax() 计算最小值和最大值的索引 array.cumsum()/cumprod 计算该轴从0至当前值的和/积 array.any()/all() 检查是否 至少有一个/全部都是 True array.sort() 4. numpy.unique(array) 找出数组中的唯一值，返回一维数组 numpy.intersect1d(x,y) 计算x and y的公共元素 numpy.union1d(x,y) 计算x和y的并集 numpy.in1d(x,y) 得到x是否包含于y的布尔数组 numpy.setdiff1d(x,y) 得到在x中而不在y中的集合 numpy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ca7c2aa2e42824ba51199f62006072b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ae063653e0db377394089d4722fcd40/" rel="bookmark">
			Linux GFS 配置方法及注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux GFS（Global File System）是实现为多个访问节点或者主机能同时读写的分布式文件系统。 现测试基于RedHat的GFS简单 配置方法及注意事项实验记录如下：
1.GFS安装配置
在10.100.15.11和10.100.15.12 配置yum源，创建配置文件,启动相关进程，两个节点做同样的配置 2.安装集群套件及GFS RPM包：
注，使用gfs文件系统，需要安装如下rpm包：
3.2节点配置cluster 集群文件
注：name 必须和vg名字相同
4.2个节点设置服务启动并允许开机启动如下服务
[root@localhost ~]# chkconfig rgmanager on [root@localhost ~]# chkconfig ricci on [root@localhost ~]# chkconfig cman on [root@localhost ~]# chkconfig clvmd on [root@localhost ~]# chkconfig gfs2 on 同时启动这些服务：
[root@localhost ~]# clustat 4. 在共享存储上划分LVM,在一个节点上操作即可 [root@localhost ~]# pvcreate /dev/mpath Physical volume "/dev/mpath" successfully created [root@localhost ~]# vgcreate mpath300G /dev/mpath Clustered volume group "fmpath300G" successfully created [root@localhost mnt]# lvcreate -n gfs -l 79462 300G_gfs Logical volume "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ae063653e0db377394089d4722fcd40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0b68cc0db8263620b9d51d625625161/" rel="bookmark">
			springmvc &#43; ajaxFileUpload多文件上传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		uploadfile.jsp
&lt;%@ page language="java" contentType="text/html; charset=UTF-8"
pageEncoding="UTF-8"%&gt;
&lt;%
String path = request.getContextPath();
String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/";
%&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
&lt;script type="text/javascript" src="&lt;%=request.getContextPath()%&gt;/js/jquery-1.7.2.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="&lt;%=request.getContextPath()%&gt;/js/ajaxfileupload.js"&gt;&lt;/script&gt;
&lt;title&gt;上传文件&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
第一种解析上传文件的方法&lt;hr/&gt;
&lt;!-- &lt;form action="parserUploadFile1" method="post" enctype="multipart/form-data"&gt; --&gt;
&lt;!-- &lt;input type="file" name="file" /&gt; --&gt;
&lt;input type="file" id="file1" /&gt;
&lt;input type="file" id="file2" /&gt;
&lt;input type="button" οnclick="upload();" value="上传" /&gt;
&lt;!-- &lt;/form&gt; --&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0b68cc0db8263620b9d51d625625161/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bb690055bcb86a9ac0a82c0f374e2e0/" rel="bookmark">
			10款轻量级JavaScript代码高亮插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		觉得不错！先收藏了。。。
原文转载链接：http://www.136go.com/article_3.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fab9e24ba2f8e9cb94e337044dbca28/" rel="bookmark">
			Xcode的一些使用技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果能慢慢熟悉一下快捷键,对于提高工作效率是有很大的帮助的:
cmd + shift + O 快速查找类,通过这个可以快速跳转到指定的类的源码中
control + 6 列出当前文件中所有的方法,可以输入关键字过滤.用它可以快捷定位想编辑的方法
cmd + 1 切换成Project Navigator
cmd + control + UP 在.h和.m文件之间切换
cmd + Opt + Enter 切换成assistant editor
cmd + Enter 切换成standard editor
cmd + shift + Y 切换Console View 的显示或隐藏
cmd + 0 隐藏左边的导航区
cmd + opt + 0 隐藏右边的工具区
cmd + control + LEFT/RIGHT 切换到上/下一次编辑的位置
cmd + opt + J 跳过到文件过滤区
cmd +F 在工程中查找
cmd + .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fab9e24ba2f8e9cb94e337044dbca28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f720d48ed89fe7514b3de95d5240e929/" rel="bookmark">
			Windows10系统添加打印机步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 打开控制面板→硬件和声音→查看设备和打印机选项。
2. 点击添加打印机选项。
3. 选择我所需的打印机未列出。
4. 选择使用TCP/IP地址或主机名添加打印机，点击下一步。
5. 填写IP地址和端口名称,点击下一步。（IP：***.***.***.***端口名称：************）
6．系统会自动搜索打印机需要等几分钟时间，直到弹出需要额外端口信息的界面。设备类型选择自定义，点击下一步继续。
7.随后系统会检测打印机驱动程序，需要等待几分钟时间。随后跳到安装驱动界面，选择相应厂商，这里选择HP；选择相应驱动，这里选择HP LaserJet M1005 Class Driver，点击下一步继续。
在进行该步骤的时候，，没有出现相应厂商和打印机选项，这时可以通过选择windows更新或者从本地磁盘安装的方式安装驱动（试过从磁盘安装，但是惠普官方的驱动需要打印机连接到电脑上才能继续安装，所以最后使用windows更新解决的问题）
8.选择要使用的驱动程序版本，建议选择替换当前的驱动程序。
9.键入打印机名称可以随便填写，点击下一步继续。
10.添加成功。
备注：win7系统添加步骤基本和win10系统相同，电脑是win7系统的同学可以参照上述步骤进行添加。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01a604df6a51d6b5f361cf593b52d818/" rel="bookmark">
			apache服务器如何配置多站点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Apache在安装之后默认只是指向一个站点,即127.0.0.1,如果要进行多站点的配置,需要更改一些配置。
转载：
http://jingyan.baidu.com/article/5225f26b07605be6fa090890.html 让Apache在启动时能加载虚拟主机模块。
打开Apache安装目录下conf/httpd.conf文件，找到下面两行文字,把最前面的 # 号去掉,然后保存。
#LoadModule vhost_alias_module modules/mod_vhost_alias.so
#Include conf/extra/httpd-vhosts.conf 2 接着找到同一文件中的DocumentRoot和Directory,改为站点目录的上一级目录
例如站点放在 D:/Appserv/www/1 和 D:/Appserv/www/2,则改为以下形式
DocumentRoot"D:/Appserv/www"
&lt;Directory"D:/Appserv/www"&gt;
3 配置完成后即可打开Apache安装目录下/conf/extra/httpd-vhosts.conf文件，在最后添加如下：
DocumentRoot是文件放置路径，ServerName是网站域名：
&lt;VirtualHost*:80&gt;
DocumentRoot"D:/Appserv/www/1"
ServerName www.xxx.com
&lt;/VirtualHost&gt;
&lt;VirtualHost*:80&gt;
DocumentRoot"D:/Appserv/www/2"
ServerName www.xxx2.com
&lt;/VirtualHost&gt;
4 最后重启Apache服务就配置完成。
5 我个人配置阿帕奇的时候遇到过一个问题，就是比如我的网站www.stzjz.com
直接输入域名打开的结果却是appserv界面
如图所示：
6 我的解决办法是
Apache安装目录下/conf/extra/httpd-vhosts.conf文件，在最后添加如下：
&lt;VirtualHost*:80&gt;
DocumentRoot"D:/Appserv/www"
ServerName 127.0.0.1
&lt;/VirtualHost&gt;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5415069838e7415f77245a9c21b1ec27/" rel="bookmark">
			jquery实现页面无限滚动插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、插件概述 实现网页底部自动加载内容的插件很多，如， 1、jQuery ScrollPagination jQuery ScrollPagination plugin 是一个jQuery 实现的支持无限滚动加载数据的插件。 地址：http://andersonferminiano.com/jqueryscrollpagination/ 他的demo下载：http://andersonferminiano.com/jqueryscrollpagination/jqueryscrollpagination.zip 2.jQuery Screw Screw (scroll + view) 是一个 jQuery 插件当用户滚动页面的时候加载内容，是一个无限滚动翻页的插件。 官方地址：https://github.com/jasonlau/jQuery-Screw Autobrowse jQuery Plugin 插件在用户滚动页面的时候自动通过 Ajax 加载更多内容，使用浏览器内置缓存。 3. AutoBrowse jQuery Plugin Autobrowse jQuery Plugin 插件在用户滚动页面的时候自动通过 Ajax 加载更多内容，使用浏览器内置缓存。 官方地址：https://github.com/msjolund/jquery-esn-autobrowse
二、插件使用说明 下面介绍一下Autobrowse的使用： 1.引入js依赖文件
&lt;script type="text/javascript" src="../plugin/jquery.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="../plugin/jquery.esn.autobrowse.js"&gt;&lt;/script&gt; 2.定义HTML元素
&lt;div class="full-dom"&gt; &lt;ul class="list-y2" id="activityList"&gt; &lt;/ul&gt; &lt;/div&gt; 3.js定义
$("#activityList").autobrowse({ url:function (offset) { //请求服务器端地址 }, template:function (data) { //异步组装服务器端返回的数据 }, itemsReturned:function (data) { //返回服务端数据的长度 }, offset:1, max:10000, loader:'' //加载的图标, useCache:false, //使用缓存 expiration:1,//过期时间 sensitivity: 2000 //触发下一页的差值 finished: function () { $(this).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5415069838e7415f77245a9c21b1ec27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/785b2dfd33d0e8bba717548dda839027/" rel="bookmark">
			机器学习实战(k-近邻算法)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给定训练数据样本和标签，对于某测试的一个样本数据，选择距离其最近的k个训练样本，这k个训练样本中所属类别最多的类即为该测试样本的预测标签。简称kNN。通常k是不大于20的整数，这里的距离一般是欧式距离。
K最近邻(k-Nearest Neighbour，KNN)分类算法，是一个理论上比较成熟的方法，也是最简单的机器学习算法之一。该方法的思路是：如果一个样本在特征空间中的k个最相似(即特征空间中最邻近)的样本中的大多数属于某一个类别，则该样本也属于这个类别。 用官方的话来说，所谓K近邻算法，即是给定一个训练数据集，对新的输入实例，在训练数据集中找到与该实例最邻近的K个实例（也就是上面所说的K个邻居）， 这K个实例的多数属于某个类，就把该输入实例分类到这个类中。 下面是机器学习实战书中一些代码的实现: 其中包含使用k-邻近算法改进约会网站配对效果代码和手写识别系统的代码:
#coding=UTF8 from numpy import * import matplotlib import matplotlib.pyplot as plt import operator from os import listdir def createDataSet(): group = array([[3,104],[2,100],[1,81],[101,10],[99,5]]) #训练集 labels = ['affectional film','affectional film','affectional film','action movie',"action movie"] return group,labels def classify0(inX,dataSet,labels,k): dataSetSize = dataSet.shape[0] diffMat = tile(inX, (dataSetSize,1)) - dataSet sqDiffMat = diffMat ** 2; #diffMat ^ 2 sqDistances = sqDiffMat.sum(axis=1) #将矩阵的每一行相加比如[[2,1,3],[1,1,1]]结果为[6,3] distances = sqDistances ** 0.5 #sqDistances ^ (1/2) sortedDistIndicies = distances.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/785b2dfd33d0e8bba717548dda839027/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10f1a8da5197d8e082eac2137e00dc87/" rel="bookmark">
			Java输入输出之File类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		File类表示文件或目录的抽象路径名称。Java中的抽象路径名称和路径名称两个概念是针对跨平台需求而设计的，前者是路径的抽象、操作系统无关的表示，而后者是路径的与操作系统相关的表示。
抽象路径名称包含以下两个部分：
一个可选的依赖于系统的前缀字符串，例如盘符(D:)，UNIX根目录“\”和微软Windows的UNC命名惯例下的“\\”。一个0或多个字符串型的名称组成的序列。 第一个名称可能是一个路径名，或者是一个主机名（在微软Windows的UNC定义的路径名中）。每个后续的名称表示一个路径，最后一个名称表示一个路径或者是一个文件。没有前缀且名称序列为空的路径名称为空抽象路径名称。
抽象路径名称和路径名称之间的转换是依赖于系统。当抽象路径名被转换为路径名时，名字之间都由单独一个默认分割符分割。默认的名称分割符是由系统属性file.separator定义，并且可以通过File类的静态属性separator和separatorChar访问。当一个路径名称字符串被转换为一个抽象的路径名时，它包含的名称可以由默认名称分割符分割，或者由下层系统支持的任何其他的名称分割符分割。
无论是不是抽象的，路径都分为绝对路径和相对路径两类。绝对路径是提供了定位文件的完全信息的路径名。相对路径是以某一路径名为参照下的路径名。默认情况下，java.io包往往是使用以当前的用户路径（由系统属性user.dir决定）为参考的相对路径。
通过File类的getParent()方法可以获得当前路径的父路径，即包含该路径的最底层的路径。
File类的实例是不可更改的，即由File对象表示的抽象路径是不会改变的。
File类的参数 static String pathSeparator; static char pathSeparatorChar; 依赖于当前系统的路径分割符，前一个是字符串类型，后一个是字符型。
static String separator; static char separatorChar; 依赖于当前系统的默认名称分割符，前一个是字符串类型，后一个是字符型。
/** * Test the path separator and separator static field in File class */ import java.io.File; public class FileFieldTest { public static void main(String[] args) { System.out.println("path separator: "+ File.pathSeparator); System.out.println("path separator(char): " + File.pathSeparatorChar); System.out.println("separator: " + File.separator); System.out.println("separator(char):" + File.separatorChar); } } 实验所用系统为ubuntu 14.04，输出如下图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10f1a8da5197d8e082eac2137e00dc87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7675ce6cae66c14bed49bc3d81c736cc/" rel="bookmark">
			乐曲识别（版本检测）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近在做乐曲识别，听几秒乐曲，然后查询，返回乐曲的相关信息。因为查询的乐曲与库中乐曲可能是同一乐曲的不同版本，不同版本音乐之间，曲调、乐器、音乐速度有差别，所以一般音频指纹的算法并不适用。在多版本音乐检测中，chroma特征用的较多，有很多不同版本的chroma特征，基本思想是提取每一个音阶的能量，形成12维度特征（每个时间窗或是每个beat），然后进行匹配。但是从实验效果来看，其识别率较低，不到50%。从我实际测试来看，不同音乐版本速度、乐器、以及局部改编带来的差异对chroma特征还是有影响，乐曲差异小，识别率相对高一些。目前来看，多版本音乐检测已然处于学术科研阶段，距离实际应用还有很大差距。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/564616232bacad84e754cdfc428c30d5/" rel="bookmark">
			lua的table库中的常用函数总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		table是Lua语言中的一种重要的数据类型， table 的一些特性简单列举如下： (1).table 是一个“关联数组”，数组的索引可以是数字或者是字符串; (2).table 的默认初始索引一般以 1 开始; (3).table 的变量只是一个地址引用，对 table 的操作不会产生数据影响; (4).table 不会固定长度大小，有新数据插入时长度会自动增长; (5).table 所有索引值都需要用 “[“和”]” 括起来；如果是字符串，还可以去掉引号和中括号； 即如果没有[]括起，则认为是字符串索引; (6).table 所有元素之间，总是用逗号 “，” 隔开；
lua提供了一些辅助函数来操作table，例如insert、remove等。 %———————————————————————————————————-% １、table.insert and　table.remove table.insert将一个元素插入到指定位置：。 举例１：
t = {1, 2, 3} table.insert(t, 1, 4} t的结果将是{4, 1, 2, 3} 举例２：
t={}; table.insert(t,"a"); table.insert(t,"b"); table.insert(t,"c"); 结果是： { 1 : a 2 : b 3 : c } insert的第二个参数是可以省略的，这样就会插入到数组的最后，从而不必移动其他元素。 同样地，table.remove是从数组中移除（并返回）一个元素，table.remove(t,1)将移除t中下标是1的元素，如果不指定移除位置，则移除最后一个。 %———————————————————————————————————-%
２、table.sort() 另一个有用的函数是sort，对数组进行排序,如果没有提供排序函数，默认是&lt;操作。这里不仅仅是数，对字符串也有效。 举例１:
a = {1,3,2,6,4,8,7,5} print('排序前:',a) table.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/564616232bacad84e754cdfc428c30d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b677e5f68776cfbfaaa3244c3f299168/" rel="bookmark">
			win7打印机共享问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.打开受访者的guest权限
2. 开始--运行--gpedit.msc
3.windows设置---安全设置--本地策略--用户权利指派--在右边找到''拒绝从网络访问这台计算机''双击打开,把里面的guest帐户删除
4. windows设置---安全设置--本地策略--安全选项--右边找到''网络访问:本地帐户的共享和安全模式"双击改成"经典:本地用户自己的身份验证"
5.windows设置---安全设置--本地策略--安全选项--右边找到''帐户:''使用空白密码的本地用户只允许进行控制台登陆"把它设置为"禁用"
转载于:https://blog.51cto.com/misskyle/1709115
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe738cbef1bd436f0a486fc3abfc4f75/" rel="bookmark">
			MFC多线程互锁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CreateEvent跟CreateMutex的比较： 区别1， CreateEvent跟CreateMutex，你第一个问题关键在于后者内置了一个计数器，比如：假若同一线程连续申请2次互斥量，那么计数器为2，若需要释放互斥量就需要ReleaseMutex（）2次，而前者没有。 区别2， Event是一个线程通知另一个线程用的，是单向的。一方接收，其它方可以发送。一般用在单纯的同步上，就是一个操作要等待另一个操作完成时用的，双方地位并不平等。 Mutex是用于资源控制用的，对于同一个资源，一次只能有一人可以对资源进行访问。双方的地位是平等的。 Mutex比Event复杂一点，可以用Mutex实现Event的功能 区别3， MUTEX其实是你进临界区之前的 CreateMutex的使用： HANDLE CreateMutex( LPSECURITY_ATTRIBUTESlpMutexAttributes, // 指向安全属性的指针 BOOLbInitialOwner, // 初始化互斥对象的所有者 LPCTSTRlpName // 指向互斥对象名的指针 ); 5、 A handle to the mutex object indicates success. If the named mutex object existed before the function call, the function returns a handle to the existing object and GetLastError returns ERROR_ALREADY_EXISTS. Otherwise, the caller created the mutex. NULL indicates failure. To get extended error information, call GetLastError.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe738cbef1bd436f0a486fc3abfc4f75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88fec444c0d14b82e46252e3932538f9/" rel="bookmark">
			MOOC PTA 08-图8 How Long Does It Take
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://pta.patest.cn/pta/test/18/exam/4/question/631
构建图的邻接矩阵，寻找入度为0的顶点，将其压入队列，出队列时对其相连接的顶点入度减1，更新每个顶点的最大时间。
刚开始提交 3和5 测试点过不去 是因为我以为输出最后一个顶点就是工程的最后一个顶点
#include&lt;vector&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cctype&gt; #include&lt;cmath&gt; #include&lt;cstdlib&gt; #include&lt;queue&gt; using namespace std; #define MAXnum 100 #define INF 100001 #define max(a,b) a&gt;b?a:b int Nv;//顶点个数 int Ne;//边的个数 int G[MAXnum][MAXnum];//图的邻接矩阵 int indegree[MAXnum];//入度计算 int time1[MAXnum];//时间计算 int countv; void BuildGraph() { int i,j,v1,v2,w; scanf("%d",&amp;Nv); for(i=0; i&lt;Nv; i++) for(j=0; j&lt;Nv; j++) G[i][j]=-1; for( i=0; i&lt;Nv; i++) { indegree[i]=0; time1[i]=0; } scanf("%d",&amp;Ne); for(i=0; i&lt;Ne; i++) { scanf("%d%d%d",&amp;v1,&amp;v2,&amp;w); G[v1][v2]=w; indegree[v2]++; time1[v2]=max(w,time1[v2]); } } void topsort() { queue&lt;int&gt; q; int v; int i; countv=0; for(i=0; i&lt;Nv; i++) if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88fec444c0d14b82e46252e3932538f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c57828c70f8d7d82e687d015c15bcf4/" rel="bookmark">
			500 Internal Server Error错误问题解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这两天遇见两次页面报 500 Internal Server Error错误问题,网上找了许多答案都未能解决问题，如图：
最后找到原因：
本地服务端正常，由于该数据调用的是第三方接口，次数第三方接口服务已经停止运行，所有导致此问题。重启第三方服务接口服务，数据正常.
现在还不知道此问题还有没有别的什么原因会引起。遇到解决办法就记录下来，供以后参考
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd7269a423aa5476e90cfc51a3073fb1/" rel="bookmark">
			如何修复丢失的零部件（ST8）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Solid Edge装配由零件、钣金、子装配等构成，形成一种紧密的联系。但如果无意中将某个零部件移动位置后，原有的连接关系就会丢失，那么如何将丢失的关系重新找回来？ST8就提供了这种修复的方法，非常高效！
图一
打开Solid Edge装配文件，屏幕上原来的零部件都显示不了，只有图一这么一个提示窗口，告诉你原来的零件、装配，已经找不到了。
有了Solid Edge ST8，这个现象就不是问题了。当装配找不到原来的零部件时，ST8就会弹出“修复缺失的文件”提示窗口（上图一），为你提供了修复工具。
接下来为你详解如何进行修复，帮你把丢失的文件找回来。
首先，选中需要修复的文件名，如图二的第一行。此时右边的四个竖排图标就是加亮，表明现在他们可以起作用了。从上往下一次是：搜索范围、替换零件、替换为标准件、替换为新零件。你可以根据实际需要，在四个命令里选择。
图二
点击“搜索范围”，系统将提示你定义去哪里搜索这个丢失的文件。选择搜索的目标文件夹，见图三。
图三
【添加】命令将定义的搜索目标文件夹加入搜索行列。你可以定义多个搜索文件夹，见图四。Solid Edge将在列表的第一个文件夹（包括子文件夹）里搜寻丢失的文件，如果找不到，则依次到第二、第三文件夹里搜寻，直至找到为止，或者文件夹遍历结束，仍未找到，则提示你重新定义新的搜寻文件夹。
图四
【搜索和替换】命令执行前面定义好的搜索。如果找到，则把这个文件显示出来。最后的结果如图五所示。
如果你关心Solid Edge，请关注我：
http://mp.weixin.qq.com/s?__biz=MjM5OTk4NDc2NQ==&amp;mid=400194297&amp;idx=1&amp;sn=6563ad9b7b54a60fbc81550bba571041&amp;scene=4&amp;uin=MTExNjcyMDY4MA%3D%3D&amp;key=04dce534b3b035ef68b72072c7a31a220b30ba0c07b6d0f97591893b2ec67798fd5656f9651c787e732b164492583ca0&amp;devicetype=Windows+7&amp;version=61050016&amp;lang=zh_CN&amp;pass_ticket=pzFso7OZ0zmo%2FQQYaVxg2n6cXACvYpMx86qr0gyIZFt4z2NHAUasTytVJ%2B4EUtv1
转自西门子工业软件官方微信公众号【solidedge联盟】，如果有任何需要向我们咨询或者帮助的地方，欢迎在公众号下面留言。
转载于:https://my.oschina.net/u/2357930/blog/522929
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a8a43d3d112120b8430631858bbc60d/" rel="bookmark">
			linux（unix）下java应用占用cpu过高查找方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先说说linux下怎么处理
1、使用top命令查看CPU使用情况
top - 17:07:58 up 2 days, 7:36, 4 users, load average: 1.49, 0.45, 0.20 Tasks: 115 total, 2 running, 105 sleeping, 8 stopped, 0 zombie Cpu(s): 83.7%us, 2.0%sy, 0.0%ni, 14.4%id, 0.0%wa, 0.0%hi, 0.0%si, 0.0%st Mem: 1035160k total, 976428k used, 58732k free, 43772k buffers Swap: 2104472k total, 1138312k used, 966160k free, 289436k cached PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 2902 test 15 0 403m 146m 9160 S 83.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a8a43d3d112120b8430631858bbc60d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a308e88f50b5a5aed1933923e47a7aa/" rel="bookmark">
			Python【01】【基础部分】- A
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、WHAT'S PYTHON ? 1、python 简介
Python（英语发音：/ˈpaɪθən/）, 是一种面向对象、解释型计算机程序设计语言，由Guido van Rossum于1989年发明，第一个公开发行版发行于1991年。
Python是纯粹的自由软件， 源代码和解释器CPython遵循 GPL(GNU General Public License)协议 。
Python语法简洁清晰，特色之一是强制用空白符(white space)作为语句缩进。
2、谁在用 python
Python可以应用于众多领域，如：数据分析、组件集成、网络服务、图像处理、数值计算和科学计算等众多领域。目前业内几乎所有大中型互联网企业都在使用Python，如：Youtube、Dropbox、BT、Quora（中国知乎）、豆瓣、知乎、Google、Yahoo!、Facebook、NASA、百度、腾讯、汽车之家、美团等。互联网公司广泛使用Python来做的事一般有：自动化运维、自动化测试、大数据分析、爬虫、Web 等。
3、python 的种类
Cpython Python的官方版本，使用C语言实现，使用最为广泛，CPython实现会将源文件（py文件）转换成字节码文件（pyc文件），然后运行在Python虚拟机上。
Jyhton Python的Java实现，Jython会将Python代码动态编译成Java字节码，然后在JVM上运行。
IronPython Python的C#实现，IronPython将Python代码编译成C#字节码，然后在CLR上运行。（与Jython类似）
PyPy（特殊） Python实现的Python，将Python的字节码字节码再编译成机器码。
RubyPython、Brython ... 4、python 优缺点
优点：
* Simple Elegant Clear （简单、优雅、明确）
* 强大的第三方库
* 易移植
* 面向对象
* 可扩展
缺点：
* 速度慢（相对环境）
* 代码不能加密
二、PYTHON BASE 1、安装 python 环境
For Linux：
如果是ubuntu14.04+的版本，那么默认的python就是2.7+啦
1 tom@python:~$ cat /etc/issue 2 Ubuntu 14.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a308e88f50b5a5aed1933923e47a7aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5689084f33231b6daf54e0ad5b362c9/" rel="bookmark">
			围观下一个德国人的厨房，告诉你什么叫严谨
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		听过一个笑话：一位中国人到德国留学，与一位德国人为邻居。几天后，中国人厨房里香气四溢的味道馋坏了德国人，于是德国人拿着小本子过来讨教，中国人大显身手后，德国人还是摸不着头脑，追问着：“盐放多少克?油放多少克?水放多少毫升?……”中国人瞠目结舌，无以作答。后来他到德国人的厨房去指点，发现厨房像个实验室，量杯、量筒一应俱全，还有厨具刀具森然排列,俨然一个兵器库……最后中国人发现自己不会做菜了。
德国人严谨实在、勤奋认真、整洁守法的优良传统，大多数人是从其工业商品感受到，如果你能参观下德国人的厨房，你会更惊叹！
请点开下方链接！
来源：新浪微博，由三维设计师编辑整理发布，转载请注明出处！
请关注我们，及时获取最新的技术分享、行业动态和新闻资讯：
http://mp.weixin.qq.com/s?__biz=MjM5OTk4NDc2NQ==&amp;mid=400146181&amp;idx=1&amp;sn=d0de52d24bcfa431eb0d79e5d85e6c99&amp;scene=4&amp;uin=MTExNjcyMDY4MA%3D%3D&amp;key=04dce534b3b035efc857615f77aab5fcb180454d4e03f6564bb0c3e65b925867694ff55d4d00db3211a025711517149a&amp;devicetype=Windows+7&amp;version=61050016&amp;lang=zh_CN&amp;pass_ticket=aopmGtrK4%2Ffne%2BzW391gqQBsKkdjFz5z7LtDBIUF8AUrEHKWPSbNgLBihiImqTBn
转自西门子工业软件官方微信公众号【solidedge联盟】，如果有任何需要向我们咨询或者帮助的地方，欢迎在公众号下面留言。
转载于:https://my.oschina.net/u/2357930/blog/522477
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3813073c83693f93cf47e9a7531fafe8/" rel="bookmark">
			ORACLE停止监听日志文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		监听(Listener)在缺省情况下，会记录日志，记录注册操作、客户端的连接等。缺省（没有设置log_file参数时）的文件是$ORACLE_HOME/network/log/listener.log。对于一些使用短连接的，频繁的连接数据库的，listener.log增长很快。有的可以在比较短的时间内（十几天）就可以超过2GB。对于一些平台的某些版本的Oracle，在监听日志增大到2GB以后会导致监听不能正常工作（我没遇到过，不过感兴趣的朋友可以在网上搜索一下，有这样的案例）。 对于这种listener.log增长非常迅速的，可以关闭监听日志，不让监听写日志到文件。也可以写个job定期清理。本文主要描述怎么样关闭监听日志： 可以在监听行接口中使用命令：
D:\&gt;lsnrctl LSNRCTL for 32-bit : Version 9.2.0.1.0 - Production on 15-10月-2008 20:52:11 Copyright (c) 1991, 2002, Oracle Corporation. All rights reserved. 欢迎来到LSNRCTL，请键入”help”以获得信息。 LSNRCTL&gt; set log_status off
正在连接到 (DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=dreamf)(PORT=1521)))
LISTENER 参数 \log_status\ 被设为 OFF
命令执行成功
LSNRCTL&gt; save_config
正在连接到 (DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=dreamf)(PORT=1521)))
未保存对LISTENER所作的更改
命令执行成功
LSNRCTL&gt; #----ADDED BY TNSLSNR 15-10月-2008 10:05:43---
LOGGING_LISTENER = OFF 所以我们也可以在listener.ora文件增加上面的内容来关闭监听日志。但是只有在监听重启后才会生效，而通过lsnrctl 这个命令接口，可以立即生效，Windows平台上的文件会立即关闭。因此可以利用这个特性，用来删除WINDOWS平台上的监听日志文件，因为不这样，在监听运行时监听日志是不能删除的。 来自 “ ITPUB博客 ” ，链接：http://blog.itpub.net/29345367/viewspace-1816428/，如需转载，请注明出处，否则将追究法律责任。 转载于:http://blog.itpub.net/29345367/viewspace-1816428/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6c5842dbe18bd5053fc13679839f55f/" rel="bookmark">
			oracle最大并发数查看
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看oracle的最大并发数限制，可是查看v$license视图 v$license视图： 里面记录了Oracle最大的并发数以及当前用户的连接数，
官方文档有如下描述： This view contains information about license limits. Column Datatype Description SESSIONS_MAX
NUMBER
Maximum number of concurrent user sessions allowed for the instance
SESSIONS_WARNING
NUMBER
Warning limit for concurrent user sessions for the instance
SESSIONS_CURRENT
NUMBER
Current number of concurrent user sessions
SESSIONS_HIGHWATER
NUMBER
Highest number of concurrent user sessions since the instance started
USERS_MAX
NUMBER
Maximum number of named users allowed for the database
其实，该试图中的SESSIONS_CURRENT就等于select count(*) from v$session where TYPE= 'USER' show parameter license_max_sessions //查看最大并发数，如果是0，则默认是无限制，但如果在初始化文件里说明了，就以初始化文件为主 来自 “ ITPUB博客 ” ，链接：http://blog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6c5842dbe18bd5053fc13679839f55f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50fb0cc9f5a99dfa2f80f36a5dbc8aff/" rel="bookmark">
			【Trace】Oracle跟踪事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Oracle跟踪事件 Oracle提供了一类命令，可以将Oracle各类内部结构中所包含的信息转储(dump)到跟踪文件中，以便用户能根据文件内容来解决各种故障。设置跟踪事件有两种方法，一种是在init.ora文件中设置事件，这样open数据库后，将影响到所有的会话。设置格式如下： EVENT="eventnumber trace name eventname [forever,] [level levelnumber] : ......." 通过:符号，可以连续设置多个事件，也可以通过连续使用event来设置多个事件。 另一种方法是在会话过程中使用alter session set events命令，只对当前会话有影响。设置格式如下： alter session set events '[eventnumber|immediate] trace name eventname [forever] [, level levelnumber] : .......' 通过:符号，可以连续设置多个事件，也可以通过连续使用alter session set events 来设置多个事件。 格式说明：eventnumber指触发dump的事件号，事件号可以是Oracle错误号（出现相应错误时跟踪指定的事件）或oralce内部事件号，内部事件号在10000到10999之间，不能与immediate关键字同用。 immediate关键字表示命令发出后，立即将指定的结构dump到跟踪文件中，这个关键字只用在alter session语句中，并且不能与 eventnumber、forever关键字同用。 trace name 是关键字。 eventname指事件名称（见后面），即要进行dump的实际结构名。若eventname为context，则指根据内部事件号进行跟踪。 forever关键字表示事件在实例或会话的周期内保持有效状态，不能与immediate同用。 level为事件级别关键字。但在dump错误栈(errorstack)时不存在级别。 levelnumber表示事件级别号，一般从1到10，1表示只dump结构头部信息，10表示dump结构的所有信息。 1、buffers事件：dump SGA缓冲区中的db buffer结构 alter session set events 'immediate trace name buffers level 1'; --表示dump缓冲区的头部。 2、blockdump事件：dump数据文件、索引文件、回滚段文件结构 alter session set events 'immediate trace name blockdump level 66666'; --表示dump块地址为6666的数据块。 在Oracle 8以后该命令已改为： alter system dump datafile 11 block 9; --表示dump数据文件号为11中的第9个数据块。 3、controlf事件：dump控制文件结构 alter session set events 'immediate trace name controlf level 10'; --表示dump控制文件的所有内容。 4、locks事件：dump LCK进程的锁信息 alter session set events 'immediate trace name locks level 5'; 5、redohdr事件：dump redo日志的头部信息 alter session set events 'immediate trace name redohdr level 1'; --表示dump redo日志头部的控制文件项。 alter session set events 'immediate trace name redohdr level 2'; --表示dump redo日志的通用文件头。 alter session set events 'immediate trace name redohdr level 10'; --表示dump redo日志的完整文件头。 注意：redo日志的内容dump可以采用下面的语句: alter system dump logfile 'logfilename'; 6、loghist事件：dump控制文件中的日志历史项 alter session set events 'immediate trace name loghist level 1'; --表示只dump最早和最迟的日志历史项。 levelnumber大于等于2时，表示2的levelnumber次方个日志历史项。 alter session set events 'immediate trace name loghist level 4'; --表示dump 16个日志历史项。 7、file_hdrs事件：dump 所有数据文件的头部信息 alter session set events 'immediate trace name file_hdrs level 1'; --表示dump 所有数据文件头部的控制文件项。 alter session set events 'immediate trace name file_hdrs level 2'; --表示dump 所有数据文件的通用文件头。 alter session set events 'immediate trace name file_hdrs level 10'; --表示dump 所有数据文件的完整文件头。 8、errorstack事件：dump 错误栈信息，通常Oracle发生错误时前台进程将得到一条错误信息，但某些情况下得不到错误信息，可以采用这种方式得到Oracle错误。 alter session set events '604 trace name errorstack forever'; --表示当出现604错误时，dump 错误栈和进程栈。 9、systemstate事件：dump所有系统状态和进程状态 alter session set events 'immediate trace name systemstate level 10'; --表示dump 所有系统状态和进程状态。 10、coalesec事件：dump指定表空间中的自由区间 levelnumber以十六进制表示时，两个高位字节表示自由区间数目，两个低位字节表示表空间号，如0x00050000表示dump系统表空间中的5个自由区间，转换成十进制就是327680，即： alter session set events 'immediate trace name coalesec level 327680'; 11、processsate事件：dump进程状态 alter session set events 'immediate trace name processsate level 10'; 12、library_cache事件：dump library cache信息 alter session set events 'immediate trace name library_cache level 10'; 13、heapdump事件：dump PGA、SGA、UGA中的信息 alter session set events 'immediate trace name heapdump level 1'; 14、row_cache事件：dump数据字典缓冲区中的信息 alter session set events 'immediate trace name row_cache level 1'; 二、内部事件号 1、10013：用于监视事务恢复 2、10015：转储UNDO SEGMENT头部 event = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50fb0cc9f5a99dfa2f80f36a5dbc8aff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ccf9deed9db1f41206af50034589c3b/" rel="bookmark">
			跟我学同步建模
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		台湾凯德编辑出版《Solid Edge教育训练手册》，已经在台湾成功发行，细致、专业、是工程师给出的好评。简体版即将在大陆发行，今天摘录其中一章节，也算是给这本书在大陆发行的前期宣传吧。希望大家在阅读之后，你的建议如被采纳，将免费获得一本。
3-4 同步的建模方式－「同步建模」 本章节沿用先前的模型范例，如图3-4-1所示。请大家先抛开「传统建模」的观念，接下来我们将使用「同步建模」的方式再次进行模型重建，并使用同步建模技术进行设计修改。
1. 如同先前步骤，开启「零件」模板，确认目前是在「同步建模」状态。如图3-4-2、图3-4-3。
2. 先点击「首页」è「绘图」è「中心点画圆」，再锁定绘图「平面」。接着绘制一个大圆及两个小圆，并给予草图「对称」和「相等」的相关限制。如图3-4-4、图3-4-5。
3. 接着将4条「相切」线段绘制上去，并使用「智能尺寸」标注大圆直径80mm、小圆直径40mm以及中心距150mm。如图3-4-6。
※ 在「同步建模」中，只要草图为「封闭区域」，就会呈现浅蓝色的区块。接着针对这些「封闭区域」直接进行拉伸长料。
4. 图片中呈现「浅蓝色区域」，都能使用「几何控制器」拉伸，点击到大圆区域，并直接拉伸出40mm。如图3-4-7、图3-4-8。
5. 点击小圆区域，按下「Ctrl键」，可复选另一小圆区域，使用「几何控制器」向上拉伸25mm。如图3-4-9、图3-4-10。
6. 接着点击底板区域，一样按下「Ctrl键」，复选两个区域，使用「几何控制器」向上拉伸10mm。如图3-4-11、图3-4-12。
7. 目前完成阶段应如图3-4-13。
8. 接下来将完成3个圆孔除料，点击「首页」è「绘图」è「中心点画圆」，再锁定绘图「平面」。绘制一个大圆及两个小圆，如图3-4-14、图3-4-15、图3-4-16。
9. 草图绘制完成之后，给予两个小圆「相等」的相关限制，并使用「智能尺寸」标注大圆直径50mm以及小圆直径25mm。如图3-4-17。
10. 点击3个圆的区域，按下「Ctrl键」复选，如同上述拉伸步骤，使用「几何控制器」直接向下拉伸除料，或设定为「贯穿」除料。如图3-4-18、图3-4-19、图3-4-20。
11. 最后加入「倒斜角」和「边倒圆」特征，可从「首页」è「实体」è「边倒圆」中找到这两个特征。如图3-4-21。
12. 分别在大圆上边线加入「倒斜角」3mm，以及大圆与小圆底座加入「边倒圆」3mm。如图3-4-22、图3-4-23。
13. 完成图，如图3-4-24。
14. 建模部分已完成，接下来我们使用「同步建模技术」来修改模型，为了方便使用「几何控制器」编辑，我们先将圆中心距150mm「解锁」。如图3-4-25、图3-4-26。
※ 本章节会先行操作并说明「同步建模技术」的便利性，相关细节设定在之后的章节会有详细解说。
15. 点击右边小圆，拖曳「几何控制器」向右拉伸，这时Solid Edge会启动「实时规则」，除了长度延伸之外，模型会自动保持「同轴心」、「相切」、「两侧对称」的规则性，确保模型在编辑的过程保有正确性。如图3-4-27、图3-4-28。
※ 虽然「实时规则」是自动启动，也能透过手动选取并暂时关闭，在设计的过程当中，是灵活弹性的辅助工具。例如图3-4-29范例，我们可暂时将「两侧对称」的规则关闭，可看到模型是往单边延伸。
16. 除了使用「几何控制器」拉伸之外，也可点击尺寸，透过PMI驱动外型，在修改尺寸时，可以控制尺寸驱动位置，例如：向左、向右或两侧对称延伸。如图3-4-30。
17. 若点击「小圆」上平面拖动，这时会启动「两侧对称」与「同平面」的实时规则，当然也能选择关闭规则，就会变成只有点到的面做延伸，另一个不动。如图3-4-31、图3-4-32、图3-4-33。
以上为「同步建模」的编辑修改方式，若您按照上述的步骤，直接点击模型来做设计变更，不管是原始档或外来档案，可以发现到SolidEdge的「同步建模技术」是使用「几何控制器」、「3D尺寸(PMI)」加上计算机自动判断的「实时规则」,只要直接拖曳模型就可以达到快速的修改，同时间又能确保几何的正确性。
转自西门子工业软件官方微信公众号【solidedge联盟】，如果有任何需要向我们咨询或者帮助的地方，欢迎在公众号下面留言。
转载于:https://my.oschina.net/u/2357930/blog/522098
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/096777cc9bce1f2c348f69fca1f217fd/" rel="bookmark">
			MFC修改按钮中字体颜色大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MFC的知识网络上其实不多，想要全面一点的更是困难，下面是对于控件修改的一些些总结，欢迎指正。
别忘了：将控件的OWner Draw 改为 true
用到的消息函数：
&lt;span style="font-size:24px;"&gt; CMy2015102203Dlg::OnInitDialog() 和 void CMy2015102203Dlg::OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct)&lt;/span&gt; 1.OnInitDialog作用：设置字形/大小 CFont * f; f = new CFont; ·····
GetDlgItem(IDC_BUTTON1)-&gt;SetFont(f);
2.OnDrawItem作用：设置内容和颜色
::SetTextColor（）
::DrawText（）
下面是具体的代码：
BOOL CMy2015102203Dlg::OnInitDialog() { CDialog::OnInitDialog(); //设置字体大小和字形 CFont * f; f = new CFont; f-&gt;CreateFont(36, // nHeight 0, // nWidth 0, // nEscapement 0, // nOrientation FW_BOLD, // nWeight TRUE, // bItalic FALSE, // bUnderline 0, // cStrikeOut ANSI_CHARSET, // nCharSet OUT_DEFAULT_PRECIS, // nOutPrecision CLIP_DEFAULT_PRECIS, // nClipPrecision DEFAULT_QUALITY, // nQuality DEFAULT_PITCH | FF_SWISS, // nPitchAndFamily _T("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/096777cc9bce1f2c348f69fca1f217fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b668e42fd00d71160634a0dec5ea97e/" rel="bookmark">
			查询Oracle 数据库中带有lob字段的表的大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意：由于lob字段有独立的lob segment来存储，故对于带有lob字段的表，不能仅仅查询dba_segments. 以下脚本来自： How to Compute the Size of a Table containing Outline CLOBs and BLOBs[Article ID 118531.1] 经过修改:改为了NVL(SUM(S.BYTES),0) SQL&gt; col "TOTAL TABLE SIZE" format 99999999999999; ---注意：以下sql可以直接执行。为了方便复制该脚本，因此不贴SQL语句的log，而是放上了执行时的SQL语句。 SELECT (SELECT NVL(SUM(S.BYTES),0) -- The Table Segment size FROM DBA_SEGMENTS S WHERE S.OWNER = UPPER('LC0019999') AND (S.SEGMENT_NAME = UPPER('ZWPZGS'))) + (SELECT NVL(SUM(S.BYTES),0) -- The Lob Segment Size FROM DBA_SEGMENTS S, DBA_LOBS L WHERE S.OWNER = UPPER('LC0019999') AND (L.SEGMENT_NAME = S.SEGMENT_NAME AND L.TABLE_NAME = UPPER('ZWPZGS') AND L.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b668e42fd00d71160634a0dec5ea97e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db37d35670b730ecccaae164b16035dc/" rel="bookmark">
			boost::lockfree::queue记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（1）pop的坑
boost::lockfree::queue&lt;Point *&gt; msgQueue;
若循环中如下调用
Point * pPoint = NULL msgQueue.pop（pPoint）; 若pop返回值是false，一般按常理会认为pPoint是空值，但是实际测试中pPoint不是空值。所以不能以pPoint的值是否改变作为后续逻辑的判断条件。 （2）队列测试
测试环境1：
500个模拟客户端，消息发送量大概在8229.033个/秒左右
发送效率对比：
原有消息队列
12:54:10.309 5916 ACTION_ERROR: count:29000000, MaxTime:4.8850, avg:0.0125
新消息队列：
14:10:29.335 3272 ACTION_ERROR: count:29000000, MaxTime:2.7910, avg:0.0039
接受消息队列对比
原有消息队列
14:51:40.322 5600 ACTION_ERROR: Recv count:3290000, MaxTime:2.8870, avg:0.0015
新消息队列
14:40:27.211 4908 ACTION_ERROR: Recv count:3290000, MaxTime:2.3850, avg:0.0013
（2）测试环境2：
1250个模拟客户端，消息发送量大概在17796.066个/秒左右
发送效率对比：
原有消息队列
16:26:47.687 4196 ACTION_ERROR: Send count:4300000, MaxTime:24.2220, avg:0.0024
新消息队列
16:35:59.948 3552 ACTION_ERROR: Send count:4300000, MaxTime:27.2790, avg:0.0014
接受消息对比
原有消息队列
16:14:54.385 5684 ACTION_ERROR: Recv count:4900000, MaxTime:25.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db37d35670b730ecccaae164b16035dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af40cbc39a5cbba9bcf71a40e2c38628/" rel="bookmark">
			使用 pip 安装 MySQLdb 模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近因为项目，需要在 Ubuntu 下进行 flask 开发，其中又必不可少要连接数据库，而本次项目选用的是 MySQL，之前自己做项目时一直用的 SQLite，就是因为曾经尝试配置 flask 连接 MySQL 一直不成功，这次只能硬着头皮上了。
安装 MySQL 的过程很简单，省略不表。关键在于，要安装 MySQLdb 这个模块，搜索下来发现很多都说需要下载源码安装，还得翻墙，其实完全没有必要，直接 pip install MySQLdb-python 即可。当然，这种方法只适用于 Python 相关项目。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f629d488def617f465a32057447047c/" rel="bookmark">
			不可思议的齿轮，你相信它能正常运转吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不要认为齿轮都是圆的，方的、不规则的齿轮，搭配在一起，能不能转起来？
视频全长05分13秒，建议WIFI下观看！
来源：互联网，由三维设计师编辑整理发布，转载请注明出处！
请关注我们，及时获取最新的技术分享、行业动态和新闻资讯：
http://mp.weixin.qq.com/s?__biz=MjM5OTk4NDc2NQ==&amp;mid=400108489&amp;idx=1&amp;sn=7f4eee9f2468deb929f1929596b6755c&amp;scene=4&amp;uin=MTExNjcyMDY4MA%3D%3D&amp;key=04dce534b3b035efa9c24b0601d2cce4929627493270f2943261319c27d00216900139a7eb849788fc9b19573dab6a46&amp;devicetype=Windows+7&amp;version=61050016&amp;lang=zh_CN&amp;pass_ticket=YU3PDwnn7hsNY6lSlAnS6f0KlE81KvUOwnz1W51l7g3C2N%2FIipjF4wwK8ntSgR7P
转自西门子工业软件官方微信公众号【solidedge联盟】，如果有任何需要向我们咨询或者帮助的地方，欢迎在公众号下面留言。
转载于:https://my.oschina.net/u/2357930/blog/521012
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f798b0912325d95f2d1c44187c9601a9/" rel="bookmark">
			iOS动画编程-View动画[ 2 ] Spring动画
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 iOS中SpringAnimation是一种常见的动画，其效果就像弹簧一样，会在end point周围摆动几下后再回到end point，这里我们来介绍一下SpringAnimation的使用方法
我们会用到的Method UIView.animateWithDuration(_:, delay:, usingSpringWithDamping:, initialSpringVelocity:, options:, animations:, completion:) 这次的函数相比上次增加了两个参数:
usingSpringWithDamping: 参数的范围为0.0f到1.0f，数值越小「弹簧」的振动效果越明显。可以视为弹簧的劲度系数
initialSpringVelocity: 表示动画的初始速度，数值越大一开始移动越快。
Demo 继续上次的Demo，我们在viewWillAppear中先修改控件位置
override func viewWillAppear(animated: Bool) { super.viewWillAppear(animated) heading.center.x -= view.bounds.width username.center.x -= view.bounds.width password.center.x -= view.bounds.width loginButton.center.y += 30.0 loginButton.alpha = 0 } 加特技! 隐藏登录按钮
UIView.animateWithDuration(1.0, delay: 0.8, usingSpringWithDamping: 0.5, initialSpringVelocity: 0, options: UIViewAnimationOptions.CurveEaseOut, animations: { () -&gt; Void in //先隐藏登录按钮 self.loginButton.center.y -= 30.0 self.loginButton.alpha = 1.0 }, completion: nil) 在viewDidAppear方法中，使用Spring动画使按钮弹出，同时透明度变成1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f798b0912325d95f2d1c44187c9601a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65dca31693a90580b741fb881a9fbfd8/" rel="bookmark">
			内存溢出异常配置最小值与最大值范围
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//首先检查程序有没有限入死循环 这个问题主要还是由这个问题 java.lang.OutOfMemoryError: Java heap space 引起的。第一次出现这样的的问题以后，引发了其他的问题。在网上一查可能是JAVA的堆栈设置太小的原因。 跟据网上的答案大致有这两种解决方法： 1、设置环境变量 解决方法：手动设置Heap size 修改TOMCAT_HOME/bin/catalina.sh set JAVA_OPTS= -Xms32m -Xmx512m 可以根据自己机器的内存进行更改。 2、java -Xms32m -Xmx800m className 就是在执行JAVA类文件时加上这个参数，其中className是需要执行的确类名。（包括包名） 这个解决问题了。而且执行的速度比没有设置的时候快很多。 如果在测试的时候可能会用Eclispe 这时候就需要在Eclipse -&gt;run -arguments 中的VM arguments 中输入-Xms32m -Xmx800m这个参数就可以了。 后来在Eclilpse中修改了启动参数，在VM arguments 加入了-Xms32m -Xmx800m，问题解决。 一、java.lang.OutOfMemoryError: PermGen space PermGen space的全称是Permanent Generation space,是指内存的永久保存区域, 这块内存主要是被JVM存放Class和Meta信息的,Class在被Loader时就会被放到PermGen space中, 它和存放类实例(Instance)的Heap区域不同,GC(Garbage Collection)不会在主程序运行期对 PermGen space进行清理，所以如果你的应用中有很多CLASS的话,就很可能出现PermGen space错误, 这种错误常见在web服务器对JSP进行pre compile的时候。如果你的WEB APP下都用了大量的第三方jar, 其大小 超过了jvm默认的大小(4M)那么就会产生此错误信息了。 解决方法： 手动设置MaxPermSize大小 修改TOMCAT_HOME/bin/catalina.sh 在“echo "Using CATALINA_BASE: $CATALINA_BASE"”上面加入以下行： JAVA_OPTS="-server -XX:PermSize=64M -XX:MaxPermSize=128m 建议：将相同的第三方jar文件移置到tomcat/shared/lib目录下，这样可以达到减少jar 文档重复占用内存的目的。 二、java.lang.OutOfMemoryError: Java heap space Heap size 设置 JVM堆的设置是指java程序运行过程中JVM可以调配使用的内存空间的设置.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65dca31693a90580b741fb881a9fbfd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c0ebd7a3dddacf64544d997df28719c/" rel="bookmark">
			Dubbo java.io.IOException: Can not lock the registry cache file
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题 [DUBBO] Failed to save registry store file, cause: Can not lock the registry cache file /home/newad/.dubbo/dubbo-registry-*.*.*.*.cache, ignore and retry later, maybe multi java process use the file, please config: dubbo.registry.file=xxx.properties, dubbo version: 2.5.3, current host: *.*.*.*
当本地同时启动服务端和客户端的时候就可能产生这个问题。
解决方案 Dubbo通过注册中心发现服务，发现的服务Dubbo同时也会保存到本地缓存一份，缓存的好处有很多，比如不需要每次使用的时候都通过注册中心获取，注册中心不可用了，不影响消费端的调用，因为本地缓存了一份服务提供者列表。Dubbo本地缓存默认采用的文件，会根据注册中心自动在当前用户目录下生成一个缓存文件，类似/home/newad/.dubbo/dubbo-registry-*.*.*.*.cache，星号表示注册中心的IP地址，当同一台机器上同时启动多个进程，就会出现多个进程争夺此文件的写入权限，觖此问题的方法也很简单，日志里面都说了重新配置一下这个缓存文件就。
主要在启动脚本里面添加配置： -Ddubbo.registry.file=C:\Users\chozee\.dubbo\dubbo-registry-192.168.1.62-junit.cache 文件名自己配置一个
-Ddubbo.registry.file=C:\Users\chozee\.dubbo\dubbo-registry-192.168.1.62-junit.cache 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a230d6807a9545cc58eb0a3f7955937e/" rel="bookmark">
			Project ERROR: Unknown module(s) in QT: xlsx
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这种错误是因为找不到qtxlsx的modules
解决办法，将qtxlsx生成的mkspecs文件拷到Qt安装目录下的mkspecs下面就可以解决了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/405004949ab1bbae1c684bde93928f76/" rel="bookmark">
			串口线的交叉直连之痛
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		串口是嵌入式设备调试开发必备的硬件模块，嵌入式设备最常用的串口协议是RS232，标准九针串口，这是由RS232标准协议文档定义的。 串口采用插针方式连接，接口两端一个是插针，一个是插槽，也就是我们常说的公头（插针）和母头（插槽），只能说这个比喻真是太邪恶了。。。 PC机都会有1-2个串口，一般是使用公头，设备号是COM1 COM2。 但嵌入式设备在硬件设计时并不会规定必须使用哪个，有的是公头，有的是母头，这就导致了串口线直连和交叉之分，使用直连串口线 还是交叉串口线，确实有点乱。 要说清楚这个问题，首先从公母头的定义说起。从网上找到的引脚定义图如下： 公头串口引脚定义是从左边开始计数，母头串口引脚定义是从右边开始计数。
首先我感觉要明确一点的是2台设备串口相连最基本的原则： 保证2台设备串口的收发引脚交叉相连，即设备的发送引脚与另一台设备的接收引脚相连，RX与TX交叉相连，其余引脚还是一一对应。
作为嵌入式设备的调试串口，波特率一般为115200，距离也就是1米左右，这样的数据压力并不需要流控制。九针全功能串口中只需要保证RX TX GND连接正确即可，其余引脚都是用作流控。 大部分嵌入式设备不会引出串口插座，为了节省空间仅仅给出RX TX GND 3个引脚。我们需要用线与PC串口线的TX RX GND相连即可。
细心的同学根据公母头引脚定义和连接原则可能看出一点问题来了，根据这个引脚定义，公母头对接，明显的是RX接RX，TX接TX啊，跟连接原则不一致啊。 这里只能说公头跟母头定义方向不一致了，公头定义是自己的引脚定义，而母头定义，特别是RX TX引脚定义是以公头方向来定义的引脚，比如母头的数据输入引脚，含义是该引脚连接公头的数据输入引脚，该引脚其实是母头的数据输出引脚，也就是说在这方面公母头引脚定义都是以公头为参考方向的。 这样的引脚定义保证了公头与母头相接，串口就能正常通讯。
因此如果设备使用母头串口，我们只需要直连串口线（其实就是相当于延长线）连接即可，保证了RX与TX交叉相连。
但是如果设备使用公头串口，我们就需要交叉串口线了。 因为两端都是公头，如果使用直连串口线，可以想象插一起，2接4,3接3，肯定不行。 如何解决这个问题呢？ 这就需要交叉串口线来帮忙了，它是在串口线内部将2,3引脚交叉，其余不变。 使用双母头交叉串口线连接两端的公头串口，这样公头引脚2,3与串口线母头的2,3相连，内部一转，变成3,2。另一端串口线母头引脚3,2与设备公头的3,2相连。 最终就是将公头的2,3与母头的3,2相连！
如何区分串口线是直连还是交叉？ 万用表测量串口线一端的引脚2与另一端的引脚2是否短接，是则是直连串口线，否则是交叉串口线。
所以一句话总结： 串口异性相接（公母头），使用直连串口线。同性相接（公公 母母），使用交叉串口线。
最后说明一点，在这里讨论都是标准的九针串口，也就是按照图引脚定义来布线连接，特定线序的串口，如公头插座但是按照母头引线，不在我们的讨论范围。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74188038200bf2912afb3f075e98e80f/" rel="bookmark">
			Java中子类是否可以继承父类的static变量和方法而呈现多态特性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		静态方法 通常，在一个类中定义一个方法为static，那就是说，无需本类的对象即可调用此方法，关于static方法，声明为static的方法有以下几条限制： 它们仅能调用其他的static 方法。 它们只能访问static数据。 它们不能以任何方式引用this 或super。 无论是static修饰的变量，还是static修饰的方法，我们都知道他们是属于类本身的，不是属于某一个对象的，当声明一个对象时，并不产生static变量和方法的拷贝。也就是说，用static修饰的变量和方法在类加载的时候，只分配一块存储空间，所有此类的对象都可以操控此块存储空间；
注：这里要说明的时，当子类没有与之同名的static变量（或方法时），子类的对象也可以操控这块内存空间。但是子类并没有继承父类中static修饰的变量和方法。因为static修饰的变量和方法是属于父类本身的。
//————————以上我相信我们每个人都比较清楚。
但是，不知道你有没有注意到这种情况，当存在继承关系时，父类中有一个static修饰的变量（或方法），而子类中也存在一个同名的static修饰的变量（或方法）时，他们到底是否满足“重写”，而最终体现出多态的效果呢？？
下面来看一个例子。 父类中有一个static修饰的方法和一个普通的方法，子类中也有一个同名的static方法和一个普通的方法。如下
父类：
public class Parent { public static void staticMethod(){ System.out.println("Parent staticMethod run"); } public void method(){ System.out.println("Parent method run"); } } 子类：
public class Son extends Parent { public static void staticMethod(){ System.out.println("Son staticMethod run"); } public void method(){ System.out.println("Son method run"); } } 测试类
package com.wrh.teststaticmethod; public class Test { public static void main(String[] args) { Parent child=new Son(); child.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74188038200bf2912afb3f075e98e80f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b4295b8c0a8f99da06347db7eee8d60/" rel="bookmark">
			mfc全屏并且物件等比例缩放
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BOOL Csunboxtest11Dlg::OnInitDialog() { CDialogEx::OnInitDialog(); CRect rect; POINT old; GetClientRect(&amp;rect); //取得放大前客户区大小 old.x=rect.right-rect.left; old.y=rect.bottom-rect.top; SetWindowPos(NULL,0,0,GetSystemMetrics(SM_CXSCREEN),GetSystemMetrics(SM_CYSCREEN),0); //全屏1 //ShowWindow(SW_SHOWMAXIMIZED); //全屏2 CRect recttemp; CRect recta; POINT bili; float fsp[2]; GetClientRect(&amp;recta); //获得全屏后的client大小 bili.x=recta.right-recta.left; // 获得全屏后的xy轴距离 bili.y=recta.bottom-recta.top; fsp[0]=(float)bili.x/old.x; //计算出全屏前后的比例关系 fsp[1]=(float)bili.y/old.y; CRect Rect; int woc; CPoint OldTLPoint,TLPoint; //左上角 CPoint OldBRPoint,BRPoint; //右下角 HWND hwndChild=::GetWindow(m_hWnd,GW_CHILD); //列出所有控件 while(hwndChild) // 将其中每一个空间都进行比例缩放 { woc=::GetDlgCtrlID(hwndChild);//取得ID GetDlgItem(woc)-&gt;GetWindowRect(Rect); ScreenToClient(Rect); OldTLPoint = Rect.TopLeft(); TLPoint.x = long(OldTLPoint.x*fsp[0]); TLPoint.y = long(OldTLPoint.y*fsp[1]); OldBRPoint = Rect.BottomRight(); BRPoint.x = long(OldBRPoint.x *fsp[0]); BRPoint.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b4295b8c0a8f99da06347db7eee8d60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a978bf23f7e50936da594bb6b528487c/" rel="bookmark">
			LeetCode38——Count and Say
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LeetCode38——Count and Say
上一题对我来说实在太凶残了，所以我还是缓缓先做38题好了。。。
题意：
可以理解为求一个数组的第n项，而这个数组的通项公式可以这样理解：
第1项：1
第2项：11
第3项：21
第4项：1211
第5项：111221
第6项：312211
...
...
第n项：第n-1项的数字串从左到右读出来。
怎么说呢？比如说第2项是11，因为第1项是1，读起来就是1个1，所以第2项的11前一个1表示后一个1的计数，以此类推。
那么我们求第n项，就要知道第n-1项，要知道n-1项就要知道第n-2项......
反过来说，我们设计一个函数可以求出某数字串的下一个数字串，只要调用该函数n-1次就能得到我们想要的结果。
代码：
class Solution { private: string Count(string s)//计算下一个序列 { string result; int i=0; int count ; while (i &lt; s.size()) { count = 1; char temp; if (s[i] == s[i + 1]) { while (s[i] == s[i + 1]) { count++; i++; } temp = count + '0'; result = result + temp + s[i]; i++; } else { temp = '1'; result = result + temp + s[i]; i++; } } return result; } public: string countAndSay(int n) { if (n == 1) return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a978bf23f7e50936da594bb6b528487c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a966aefb5fa6f5b8f33ed3d4bfc688e6/" rel="bookmark">
			Android应用程序之数据存储（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可以将应用程序的数据以数据库、文件或者选项文件（preference)的形式存放到内部或可移除的存储介质中。你也可以添加数据备份服务，让用户可以存储或恢复应用程序或系统数据。
Android为你永久保存应用程序数据提供了几种选择。你选择哪种解决方案取决于你的特定的需求，例如是否这些数据应该是你的应用程序私有的，或者其他应用程序或用户可以访问的，你的数据需要多大的空间。
你可以选择的数据存储选项包括以下几类：
共享选项文件（Shared Preferences) 以键值对的方式存储私有的基本数据。内部存储（Internal Storage) 在设备内存中存储私有数据外部设备（External Storage) 在共享的外部存储设备中存储公共数据SQLite数据库（SQLite Database) 在私有数据库中存储结构化的数据网络连接（Network Connection) 使用你自己的网络服务器将数据存储在网上 Android提供了一种方式让你可以将自己的私有数据暴露给其他应用程序，使用内容提供者(Content Provider）。内容提供者是一个可选的组件，它将为你的应用程序数据暴露读写访问，同时遵循你想要保留的任何限制。
使用共享选项文件 SharedPreferences类提供了一个通用的框架，允许你来保存和取回永久保存的基本数据类型的键值对。你可以使用SharedPreferences存储任何基本数据：boolean, float, int, long和string。
为了给你的应用程序获得SharedPreferences对象，使用下面两个方法之一：
getSharedPreferences() - 如果你需要多个选项文件并且这些文件通过名称区分的话，使用这个方法。这个方法的第一个参数就是选项文件的名称。第二个参数为模式，可以是MODE_PRIVATE, MODE_WORLD_READABLE和MODE_WORLD_WRITABLE之一。也可以是MODE_MULTI_PROCESS支持多进程修改同一个文件，在Android 2.3或更低版本的Android，该选项总是打开的，在后来的版本中都默认关闭了。getPreferences() - 如果你的活动只需要一个选项文件，那么使用这个方法。因为这将是你的活动的唯一的选项文件，你不需要为其指定名称。 为了写入值： 1. 调用edit()获得SharedPreferences.Editor; 2. 使用putBoolean(), putString()方法添加值； 3. 使用commit()方法提交新值。
使用SharedPreferences的getBoolean()和getString()等方法读出值。
下面是分别使用getSharedPreferences()和getPreferences()的两个例子。
package lemon.learnandroid; import android.app.Activity; import android.os.Bundle; import android.content.SharedPreferences; import android.widget.Toast; public class SharedPreferencesOption extends Activity { public static final String PREFS_NAME = "MyPrefFile"; /** Called when the activity is first created.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a966aefb5fa6f5b8f33ed3d4bfc688e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54f1bc60f66b245ec210bf2c35913b52/" rel="bookmark">
			QQ互联登录提示redirect uri is illegal(100010)完美解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大概2015年3月低，腾讯QQ互联开发平台调整了有关QQ登录应用回调地址填写规则，用来修复QQ登录过程因回调地址的漏洞可能导致存在的安全问题。
博主接触这块较多，但也是四月才了解此事，从4月起，所有新申请的QQ互联应用，回调地址都不能只填写根域名，比方：unvs.cn，这样是不允许的。
解决方法：必须要填写你应用QQ登录返回的真实回调地址页面，必须带有HTTP://开头、及页面名称结尾，如：http://www.unvs.cn/oauth/default.aspx。
否则点击QQ登录图标后，跳转到QQ平台会显示“redirect uri is illegal(100010)”错误代码，如图：
修改方法与位置：
1、进入QQ互联平台：http://connect.qq.com/
2、管理中心–我的应用–应用基本信息，回调地址修改，如下图：
3、当有多个回调地址，怎么办？如果你的域名分带www、不带www，那么回调地址应该要填写2个，正确填写方法：两个回调地址页面以分号分割开，多个回调地址同理，如：http://www.unvs.cn/oauth/default.aspx;http://unvs.cn/oauth/default.aspx
最后，再举例说两个常用电商程序的回调地址填写，ecshop程序的第三方登录插件，回调地址填为：http://域名/user.php ，hishop程序的QQ登录回调地址填为：http://域名/openid/OpenIdEntry_hishop.plugins.openid.qq.qqservice.aspx 等等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3d3644741ed01acaad030319c59af5d/" rel="bookmark">
			HTTP返回状态码及错误大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTTP 400 - 请求无效 HTTP 401.1 - 未授权：登录失败 HTTP 401.2 - 未授权：服务器配置问题导致登录失败 HTTP 401.3 - ACL 禁止访问资源 HTTP 401.4 - 未授权：授权被筛选器拒绝 HTTP 401.5 - 未授权：ISAPI 或 CGI 授权失败 HTTP 403 - 禁止访问 HTTP 403 - 对 Internet 服务管理器 的访问仅限于 Localhost HTTP 403.1 禁止访问：禁止可执行访问 HTTP 403.2 - 禁止访问：禁止读访问 HTTP 403.3 - 禁止访问：禁止写访问 HTTP 403.4 - 禁止访问：要求 SSL HTTP 403.5 - 禁止访问：要求 SSL 128 HTTP 403.6 - 禁止访问：IP 地址被拒绝 HTTP 403.7 - 禁止访问：要求客户证书 HTTP 403.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3d3644741ed01acaad030319c59af5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76b78a786d03e9752a547f7ba413c986/" rel="bookmark">
			经典的面试题：用 4 个线程疯狂的打印 abcd 持续 5 秒钟，但是要按照顺序打印，不能是乱序的。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.经典的面试题：用 4 个线程疯狂的打印 abcd 持续 5 秒钟，但是要按照顺序打印，不能是乱序的。
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;pthread.h&gt; #include &lt;string.h&gt; #define THRNUM 4 static pthread_mutex_t mut[THRNUM]; static int next(int a) { if(a+1 == THRNUM) return 0; return a+1; } static void *thr_func(void *p) { int n = (int)p; int ch = n + 'a'; while(1) { pthread_mutex_lock(mut+n); write(1,&amp;ch,1); pthread_mutex_unlock(mut+next(n)); } pthread_exit(NULL); } int main() { int i,err; pthread_t tid[THRNUM]; for(i = 0 ; i &lt; THRNUM ; i++) { pthread_mutex_init(mut+i,NULL); pthread_mutex_lock(mut+i); err = pthread_create(tid+i,NULL,thr_func,(void *)i); if(err) { fprintf(stderr,"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76b78a786d03e9752a547f7ba413c986/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95d57b08f49f7d87d1160087e35ee0d2/" rel="bookmark">
			HDU4624Endless Spin(clj计数ppt）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		链接：http://acm.hdu.edu.cn/showproblem.php?pid=4624 题意：总共有n个球，每次随机选择一段区间染黑（每段区间被选择的概率相同），求期望多少次所有球都被染黑。
分析：虽然ppt中说显然，但我认为这个问题最为精妙的地方就在第一步：
期望次数=∑i=1∞p[i] ，其中 p[i] 为i次之后仍然存在白球的概率。 这个公式怎么来的呢？直观的理解就是假如当前还有白球，那么必然还要染一次，而这一次对整体期望的贡献就是p[i].这之后就是传统的处理方法，枚举哪些球是白球，那么可以染黑的区间是固定的，由于这当中会有重复计算，只需要把奇数个白球的情况减去偶数个白球的方案数就是总的方案数，这种容斥方法在后面的Substring Pairs一题中也有体现。 另外，这题要保留15位小数，要用java才能通过。 java进行文件读写，可以使用Printwriter来做写操作，不过要记得close. java可以方便的使用printf; java的BigDecimal进行divide操作时，要设置scale和舍入mode 附上java代码
import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.IOException; import java.io.PrintWriter; import java.math.BigDecimal; import java.math.BigInteger; import java.util.*; public class Main { public static void main(String[] args) throws FileNotFoundException { File fp2=new File("/home/poursoul/J.out"); PrintWriter cout=new PrintWriter(fp2); Long [][][]dp=new Long[55][2500][2]; BigDecimal []rep=new BigDecimal[100]; for(int i=0;i&lt;60;i++)rep[i]=new BigDecimal("0"); for(int i=0;i&lt;55;i++)for(int j=0;j&lt;2500;j++)for(int k=0;k&lt;2;k++)dp[i][j][k]=new Long(0); dp[0][0][0]=(long)1; BigDecimal t1=new BigDecimal("1"); for(int i=1;i&lt;=51;i++) { for(int j=0;j&lt;i*(i-1)/2;j++) { for(int k=0;k&lt;2;k++) { for(int ni=0;ni&lt;i;ni++) { int tot=i-ni-1; tot=tot*(tot+1)/2; if(j&gt;=tot) dp[i][j][k]+=dp[ni][j-tot][k^1]; } } Long tp=(long)i*(i-1)/2; BigDecimal p=new BigDecimal(j).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95d57b08f49f7d87d1160087e35ee0d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91d66c6a756d09d80906129ee97b27c6/" rel="bookmark">
			电源软启动的实用设计技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软启动电路的作用就是用于电源启动时，减小浪涌电流，使输出电压缓慢上升，减小对输入电源的影响。请看软启动是如何帮助烧录器，提高烧录的稳定性和可靠性的。
软启动，相信硬件工程师都不会对这个名词感到陌生。随意打开一篇开关电源芯片的datasheet，都能看到对soft-start（软启动）的描述。随着芯片集成度的提高，软启动电路也集成到了电源芯片内部，这样在减轻工程师工作的同时，也导致部分工程师对软启动了解不够、重视不足。那么软启动电路有什么作用呢？
电源电路中通常会存在大容量电容，给电容加上电压瞬间需要很大的浪涌电流，很可能造成输入电源的降低。软启动电路就是用于电源启动时，减小浪涌电流，使输出电压缓慢上升，减小对输入电源的影响。让我们一起来看看，在电源设计里面，加入了软启动的电路，是如何保障烧录器稳定烧录的。
P800是周立功致远电子推出的4通道、多功能的在线编程器。每通道都可以输出相互独立、在1.25V~7V范围内可调的电源。在烧录器内部，每通道的电源都采用同一路电源VDD，并通过下图所示的开关电路，使各通道电源相互独立。
对上图电路简单分析：当控制信号EN_VDDx为高电平时，Q2饱和导通，Q1栅极拉低，Q1迅速导通，电源VDD输出到相应通道的VDD_OUT并供给待烧录目标板。这个看似简单的电路，却在进行多通道异步在线烧录测试时出了非常不稳定的现象，到底是怎么回事呢？
我们用P800对4个ARM核心板进行异步烧录测试过程中，发现当其中一个通道插入并上电初始化时，其他通道会出现烧录失败的现象。由于4个通道的信号线相互独立，只有电源VDD是共用的，因此我们猜测可能是ARM板上电初始化对VDD产生了干扰并影响到了其他通道。
为了验证这一猜想，我们用示波器ZDS2022来观察在VDD_OUTx上电过程中VDD的变化，并捕获到了下面的波形图。
从波形图可以看到，在VDD_OUTx上升过程中，VDD从3.12V瞬间跌落至2.14V，再缓慢回升至3.12V，最大跌落幅度达980mV.由于另外3个通道的电源也由VDD提供，因此这3个通道在线烧写失败也就在所难免。
VDD_OUTx的上电为什么会造成VDD跌落呢？观察波形图我们还可以发现，VDD_OUTx从0V上升到2V只用了3μs，根据电容充电公式：I=C×dU / dt，VDD_OUTx的去耦电容4.7μF，据此估算出浪涌电流达3A！正如前面所述，过大的浪涌电流最终造成了输入电源的降低。
为了限制浪涌电流，可以将软启动引入开关电路中，利用Q1的导通阻抗RDS（on）随VGS变化的特性，通过延缓Q1导通的速度，使VDD_OUTx缓慢上升到VDD.引入的软启动电路如下图的C1、R4所示。
当Q2集电极变低时，C1通过R4放电，Q1栅极电压随之缓慢下降，从而控制Q1缓慢导通，使VDD_OUTx不会发生突变。用示波器ZDS2022观察VDD_OUTx上电过程中VDD的变化，得到如下波形。
和加入软启动之前的波形图对比可以看到，VDD_OUTx的上升时间延长到了400μs，VDD的跌落问题也得到明显改善。经过长时间反复测试，都没有再出现烧录失败现象。
就是这样一个不起眼的软启动电路，却大大提升了编程器烧录的稳定性。生活中的一些小细节总能给人带来意想不到的惊喜，工作也是如此。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0aa38b513641ad167cd63050ea3cc4a5/" rel="bookmark">
			【iOS】AVFoundation架构下的原生二维码和条形码扫描
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章主要是参考了博主 WestLC 的《 iOS 原生二维码扫描（可限制扫描区域）》 。但是做了一点点的个性化。
整个代码的工作流程是这样的：
运行APP，显示一个蓝色的二维码扫描按钮 ----- 点击蓝色按钮 ----- 开始二维码扫描 ----- 扫描结束 ----- 显示扫描结果 ;然后显示按钮 可循环操作。
---点击按钮---》 这是扫描成功后的显示结果。这个是CSDN的二维码。
#import "ViewController.h" #import &lt;AVFoundation/AVFoundation.h&gt; @interface ViewController ()&lt;AVCaptureMetadataOutputObjectsDelegate&gt; @property (nonatomic,strong)AVCaptureDevice *device; @property (nonatomic,strong)AVCaptureDeviceInput *input; @property (nonatomic,strong)AVCaptureMetadataOutput *output; @property (nonatomic,strong)AVCaptureSession *session; @property (nonatomic,strong)AVCaptureVideoPreviewLayer *preview; @property (weak, nonatomic) IBOutlet UIButton *button; @end @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; self.button.selected = NO; [self setAVFoundation]; // Do any additional setup after loading the view, typically from a nib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0aa38b513641ad167cd63050ea3cc4a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9408c4709549ce4990fbcd1af1156d8e/" rel="bookmark">
			V4L2简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://work-blog.readthedocs.org/en/latest/v4l2%20intro.html
第一章 V4L2简介 1.1、什么是v4l2 V4L2（Video4Linux的缩写）是Linux下关于视频采集相关设备的驱动框架，为驱动和应用程序提供了一套统一的接口规范。
V4L2支持的设备十分广泛，但是其中只有很少一部分在本质上是真正的视频设备：
Video capture device ： 从摄像头等设备上获取视频数据。对很多人来讲，video capture是V4L2的基本应用。设备名称为/dev/video,主设备号81，子设备号0~63Video output device ： 将视频数据编码为模拟信号输出。与video capture设备名相同。Video overlay device ： 将同步锁相视频数据（如TV）转换为VGA信号，或者将抓取的视频数据直接存放到视频卡的显存中。Video output overlay device ：也被称为OSD(On-Screen Display)VBI device ： 提供对VBI（Vertical Blanking Interval）数据的控制，发送VBI数据或抓取VBI数据。设备名/dev/vbi0~vbi31,主设备号81,子设备号224~255Radio device ： FM/AM发送和接收设备。设备名/dev/radio0~radio63,主设备号81，子设备号64~127 V4L2在Linux系统中的结构图如下：
V4L2简单框图
1.2、从应用层看V4L2 从V4L2简单框图可以看出,V4L2是一个字符设备，而V4L2的大部分功能都是通过设备文件的ioctl导出的。
**可以将这些ioctl分类如下**：
Query Capability:查询设备支持的功能，只有VIDIOC_QUERY_CAP一个。优先级相关：包括VIDIOC_G_PRIORITY,VIDIOC_S_PRIORITY,设置优先级。capture相关：视频捕获相关Ioctl。 capture ioctl list ID 描述 VIDIOC_ENUM_FMT 枚举设备所支持的所有数据格式 VIDIOC_S_FMT 设置数据格式 VIDIOC_G_FMT 获取数据格式 VIDIOC_TRY_FMT 与VIDIOC_S_FMT一样，但不会改变设备的状态 VIDIOC_REQBUFS 向设备请求视频缓冲区，即初始化视频缓冲区 VIDIOC_QUERYBUF 查询缓冲区的状态 VIDIOC_QBUF 从设备获取一帧视频数据 VIDIOC_DQBUF 将视频缓冲区归回给设备， VIDIOC_OVERLAY 开始或者停止overlay VIDIOC_G_FBUF 获取video overlay设备或OSD设备的framebuffer参数 VIDIOC_S_FBUF 设置framebuffer参数 VIDIOC_STREAMON 开始流I/O操作，capture or output device VIDIOC_STREAMOFF 关闭流I/O操作 TV视频标准： TV Standard ID 描述 VIDIOC_ENUMSTD 枚举设备支持的所有标准 VIDIOC_G_STD 获取当前正在使用的标准 VIDIOC_S_STD 设置视频标准 VIDIOC_QUERYSTD 有的设备支持自动侦测输入源的视频标准，此时使用此ioctl查询侦测到的视频标准 input/output： Input / Output ID 描述 VIDIOC_ENUMINPUT 枚举所有input端口 VIDIOC_G_INPUT 获取当前正在使用的input端口 VIDIOC_S_INPUT 设置将要使用的input端口 VIDIOC_ENUMOUTPUT 枚举所有output端口 VIDIOC_G_OUTPUT 获取当前正在使用的output端口 VIDIOC_S_OUTPUT 设置将要使用的output端口 VIDIOC_ENUMAUDIO 枚举所有audio input端口 VIDIOC_G_AUDIO 获取当前正在使用的audio input端口 VIDIOC_S_AUDIO 设置将要使用的audio input端口 VIDIOC_ENUMAUDOUT 枚举所有audio output端口 VIDIOC_G_AUDOUT 获取当前正在使用的audio output端口 VIDIOC_S_AUDOUT 设置将要使用的audio output端口 controls：设备特定的控制，例如设置对比度，亮度 controls ID 描述 VIDIOC_QUERYCTRL 查询指定control的详细信息 VIDIOC_G_CTRL 获取指定control的值 VIDIOC_S_CTRL 设置指定control的值 VIDIOC_G_EXT_CTRLS 获取多个control的值 VIDIOC_S_EXT_CTRLS 设置多个control的值 VIDIOC_TRY_EXT_CTRLS 与VIDIOC_S_EXT_CTRLS相同，但是不改变设备状态 VIDIOC_QUERYMENU 查询menu 其他杂项： controls ID 描述 VIDIOC_G_MODULATOR VIDIOC_S_MODULATOR VIDIOC_G_CROP VIDIOC_S_CROP VIDIOC_G_SELECTION VIDIOC_S_SELECTION VIDIOC_CROPCAP VIDIOC_G_ENC_INDEX VIDIOC_ENCODER_CMD VIDIOC_TRY_ENCODER_CMD VIDIOC_DECODER_CMD VIDIOC_TRY_DECODER_CMD VIDIOC_G_PARM VIDIOC_S_PARM VIDIOC_G_TUNER VIDIOC_S_TUNER VIDIOC_G_FREQUENCY VIDIOC_S_FREQUENCY VIDIOC_G_SLICED_VBI_CAP VIDIOC_LOG_STATUS VIDIOC_DBG_G_CHIP_IDENT VIDIOC_S_HW_FREQ_SEEK VIDIOC_ENUM_FRAMESIZES VIDIOC_ENUM_FRAMEINTERVALS VIDIOC_ENUM_DV_PRESETS VIDIOC_S_DV_PRESET VIDIOC_G_DV_PRESET VIDIOC_QUERY_DV_PRESET VIDIOC_S_DV_TIMINGS VIDIOC_G_DV_TIMINGS VIDIOC_DQEVENT VIDIOC_SUBSCRIBE_EVENT VIDIOC_UNSUBSCRIBE_EVENT VIDIOC_CREATE_BUFS VIDIOC_PREPARE_BUF v4l2设备的基本操作流程如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9408c4709549ce4990fbcd1af1156d8e/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/306/">«</a>
	<span class="pagination__item pagination__item--current">307/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/308/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>