<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc1118571d629e7c516555fe71d591ee/" rel="bookmark">
			Quartz-QuartzSchedulerThread详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QuartzSchedulerThread详解 QuartzSchedulerThread是一个线程类，负责查询并触发Triggers。
public class QuartzSchedulerThread extends Thread { QuartzSchedulerThread(QuartzScheduler qs, QuartzSchedulerResources qsRsrcs, boolean setDaemon, int threadPrio) { super(qs.getSchedulerThreadGroup(), qsRsrcs.getThreadName()); ........ paused = true; halted = new AtomicBoolean(false); } } 该线程类的主要工作分为以下几个步骤：
等待QuartzScheduler启动查询待触发的Trigger等待Trigger触发时间到来触发Trigger循环上述步骤 /*-----------------run()方法有删减----------------------*/ public void run() { while (!halted.get()) { // ------------------------------- // 1 等待QuartzScheduler启动 // ------------------------------- synchronized (sigLock) { while (paused &amp;&amp; !halted.get()) { // wait until togglePause(false) is called... sigLock.wait(1000L); } } // ------------------------------- // 2 查询待触发的Trigger // ------------------------------- int availThreadCount = qsRsrcs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc1118571d629e7c516555fe71d591ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5283847c6157f8ad2e828c3dbbd77c91/" rel="bookmark">
			AJAX 加载数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JQuery本地的ajax函数可以处理4种格式的数据：
a.html(片段，没有body等标签，由&lt;div&gt;构成)，可以使用.load(a.html)加载。该数据加载方式的缺点是加载文档里含有大量html标签，加载时间长。
.json，通过$.getJSON(b.json,function(data){});函数实现，回调函数里会根据json数据构造html标签结构，首先使用$.each()方法对json数据进行遍历，然后用.html(html)实现数据的加载。
.xml文件，通过$.get(b.xml,function(data){});函数实现，回调函数里会根据xml数据构造html标签结构，使用.find()和filter()函数进行遍历，然后再.append()方法实现数据的在页面上显示。
.js文件，通过$.getScript(c.js)文件实现调用，js文件里将数据和标签结构定义和设置好，跟.json格式的一样。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05c01a104626ccbca874d0bc32c012f4/" rel="bookmark">
			wordcloud：自定义背景图片，生成词云
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方简介： github:https://github.com/amueller/word_cloud 官方地址:https://amueller.github.io/word_cloud/ 来一个例子： """ @author:FLY @software:PyCharm @time:2017/08/24 """ import pickle from os import path import jieba import matplotlib.pyplot as plt from wordcloud import WordCloud, STOPWORDS, ImageColorGenerator text = '' with open('人工智能及应用.txt', 'r', encoding='utf8') as fin: for line in fin.readlines(): line = line.strip('\n') # sep’.join（seq）以sep作为分隔符，将seq所有的元素合并成一个新的字符串 text += ' '.join(jieba.cut(line)) backgroud_Image = plt.imread('man.jpg') print('加载图片成功！') '''设置词云样式''' wc = WordCloud( background_color='white',# 设置背景颜色 mask=backgroud_Image,# 设置背景图片 font_path='C:\Windows\Fonts\STZHONGS.TTF', # 若是有中文的话，这句代码必须添加，不然会出现方框，不出现汉字 max_words=2000, # 设置最大现实的字数 stopwords=STOPWORDS,# 设置停用词 max_font_size=150,# 设置字体最大值 random_state=30# 设置有多少种随机生成状态，即有多少种配色方案 ) wc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05c01a104626ccbca874d0bc32c012f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ea52db9b01986f72698e28f976c57ac/" rel="bookmark">
			预习Dom4J之:把XML输出到Java控制台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		结果:
准备:
xml文件
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!DOCTYPE Students [ &lt;!ELEMENT Students (Student*)&gt; &lt;!ELEMENT Student (Name,Age)&gt;	&lt;!ATTLIST Student id CDATA #REQUIRED&gt; &lt;!ATTLIST Student remark CDATA #IMPLIED&gt; &lt;!ELEMENT Name (#PCDATA)&gt;	&lt;!ELEMENT Age (#PCDATA)&gt;	]&gt; &lt;Students&gt; &lt;Student id="s001" remark="帅哥"&gt; &lt;Name&gt;洛清风&lt;/Name&gt; &lt;Age&gt;18&lt;/Age&gt; &lt;/Student&gt; &lt;Student id="s002"&gt; &lt;Name&gt;穆修杉&lt;/Name&gt; &lt;Age&gt;19&lt;/Age&gt; &lt;/Student&gt; &lt;/Students&gt; 开始:
1)导入Dom4J到Java工程
2)设计好打印xml到控制台的方法
/** * &lt;p&gt;Title:printXML&lt;/p&gt; * &lt;p&gt;Description:打印xml&lt;/p&gt; * @param elm	需要打印的xml * @param indent	首次缩进倍数 */ public static void printXML(Element elm,int indent){ //缩进字符串 String indentStr="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ea52db9b01986f72698e28f976c57ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45df3795218f3325654f74a15333f515/" rel="bookmark">
			智能卡7816协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 为了方便查看博客，特意申请了一个公众号，附上二维码，有兴趣的朋友可以关注，和我一起讨论学习，一起享受技术，一起成长。
1.硬件接口 1.1端跨解释： 连接接口解释VCC电源输入（A类：5V， B类：3V）RST复位信号输入CLK时钟信号输入GND地，基准电压VPP编程电压输入，由卡选用I/O串行数据的输入、输出 1.2IC卡的操作信息交互流程: 当卡的触点物理的连接到接口设备的触点时，电路才能运行。
（1） 接口设备能够控制IC卡各IO引脚使其激活。
（2） 接口设备给卡发送复位信号使卡复位启动。
（3） 卡要向接口设备发送复位应答信号，将通信中必要的相关信息告知接口设备。
（4） 接口设备对卡进行一次热复位，卡进行复位应答。
（5） 接口设备发起一个PPS交互指令，选择要与卡通信的协议和相关参数。
（6） 根据选择的协议（T=0或T=1）进行数据的通信。
1.3卡激活 为了与一个已经物理的连接的卡发起交互，接口设备需要通过下面的操作激活卡。
（1）RST置成 L
（2）VCC上电
（3）接口设备上I/O置成接收模式
（4）在A类操作条件下，VPP应该置为停止状态；在B类操作条件下，不接VPP
（5）CLK将要被给一个时钟信号。
1.4冷复位 激活结束后（RST在L状态，VCC上电，接口设备I/O在接收模式，CLK有一个适合的并且稳定的时钟信号），卡已经准备好冷复位。在冷启动之前，卡的内部状态没有定义。接口设备将发出一个冷复位信号，并从IC卡得到一个复位应答，过程如下：
（1）从Ta时刻起，接口设备施加CLK。
（2）在Ta后不超过200个时钟周期内，IC卡必须将其I/O线置为接收方式。由于接口设备也必须在这段期限内置其I/O线驱动器为接收方式，所以I/O线在Ta后最迟不超过200个时钟周期的时间内置为高电平。为此，接口设备的I/O触点应经过一个上拉电阻接到V CC。
（3）接口设备应从Ta开始保持RST端为低电平状态至少400个时钟周期，并在T b 将其置为高电平；
（4）IC卡上I/O的复位应答将在T b时刻后的400至40，000个时钟周期内开始；
（5）如果IC卡在RST被拉高后的40000个时钟周期内没有应答，则RST将被拉低并且卡将被去激活。
注:1.假定卡的内部状态在冷复位前不定,这样卡的设计必须避免不适当的操作
2.卡的复位可以由接口设备在任意时间随意启动
1.5热复位 IC卡对终端的复位应答有着规定的规格和内容，如果终端收到的复位应答不符合规定要求时，终端将启动一个热复位并从IC卡获得复位信号。过程如下：
（1）在VCC和CLK信号保持稳定后，接口设备通过拉低RST发起热复位，RST低电平至少要持续400个时钟周期；
（2）在Tc之后的最多200周期内，IC卡和接口设备都必须置I/O为接收方式，即I/O线在Tc后最迟不超过200个时钟周期内置为高电平；
（3）接口设备在RST保持低电平大于400个时钟周期后，将其拉高；
（4）IC卡上I/O的复位应答将在T后的400至40，000个时钟周期内开始；
（5）如果IC卡在RST被拉高后的40000个时钟周期内没有应答，RST将被拉低并且卡将被去激活；
1.6时钟停止 对于支持时钟停止的卡，当接口设备认为没有来自卡的传输并当I/O已经保持在H至少1860时钟周期（延时tg），在VCC上电并且RST在H时，接口设备可以对于CLK（Te）进行时钟停止。
当时钟停止时（在Te~Tf），根据已被确定好的时钟指示器X ，CLK将要继续保持在在H或是在L。时钟指示器X的值应在复位应答序列TA（i）当中设置。
在Tf，接口设备重启时钟，在至少700时钟延时后（th），在I/O的信息交换可以继续。
1.7去激活 当信息交换被完成或者被终止（例如卡没有应答，或检测到卡的移动），接口设备将按照下面的序列停用IC卡：
（1）将RST 置L
（2）将CLK置L（除非时钟停止在L状态）
（3）将VPP去激活
（4）将I/O置L
（5）将VCC去激活
1.8参数选择 接口设备可以发送协议和参数选择指令（PPS），选择要和IC卡进行通信的协议和相关的参数。
（1） PPS协议
——&gt;IFD发送一个PPS请求给ICC
——&gt;如果ICC收到一个错误的请求，则不响应。
——&gt;如果ICC受到一个正确的请求，则返回一个PPS响应，否则将超过初始等待时间
——&gt;如果ICC超出初始等待时间，则IFD复位或者拒绝ICC
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45df3795218f3325654f74a15333f515/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3f970ecced71813fb822d7cd2d556b2/" rel="bookmark">
			为抵抗洪水，战士连续作战89小时，编程计算共多少天零多少小时？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		预备知识：
1、1天是24小时；
2、parseInt是对一个数字进行取整，比如：
parseInt(3.6)得出结果是3，parseInt(5.2)得出结果是5；
3、在数学运算中,“/”是除法，“%”是求余，比如：
5/2结果为2.5；5%2结果为1；
16/8结果为2；16%8结果为0；
18/5结果为3.6；18%5结果为3；
4、一个“=”号表示赋值；如a=6,意思就是把6赋值给a，
b=8/5,意思就是把8/5计算后的值赋值给a，即b=1.6；
实战应用：
已知时间是89个小时，那么先定义一个变量a（变量名自己随便取）把89存起来，然后定义变量day和hour去存储具体的天数和小时数，代码实现如下：
var　a = 89;
var　day = 0;//初始化day为0，不初始化也可以，最好初始化，养成良好代码习惯；
var　hour = 0;
day = parseInt(a/24);//a/24可以求出天数，有小数，使用parseInt取整就是天数；
hour = a%24;
结果：day为3，hour为17，即3天17小时。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c459deea797ce7e9fed05122a96f8cf0/" rel="bookmark">
			音标学习--元音
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 音标已经学习了将近5遍了，其中认真走过的已有三遍，起先看不到什么效果，但是经过多次之后感觉已经爱上了它，让我给他们建个小屋吧！
元音–思维导图：
强化元音：表示这些元音是最基础并且很多类似的音节，其中分为两项。其中注意有些英文包含了三个字符，或者是每个音标包含了三个字符组，所以当我们面临单词的时候很难区分。
– 其一表示类同音，他们的发音只是口型的变化，其他的并没有变化，其口型是逐渐增大到最大。
–其二表示同音，一共有三个地方是相同的，他们的发音从根本上是无法区别，或者说就是一样，因为老美很懒，所以很多的音节就随之相同了。
卷舌难音：表示这几个中都是卷舌的，并且特别的不好区分，有些事双元音，有些是三元音，所以他们的口型在读单词或者连读的时候有很多注意的事项。
不卷难：总体概括了其中所有不卷舌中的单双音节的变化，尤其双音节还有其中的三音节大部分来自强化音节，并且他们对应的最多只有两个英文符号，所以还算简单。
简单中:只是音标好读，但是其中对应的英文字符比较多，所以这方面在学习的时候简单，但是应用单词的时候往往会忘记对应的哪个，并且很多和之前的重复了，这也是初期简单后期难。
特别注意：
-I:当有两个出现时候，第二个读i -r：这个是卷舌元音，并且舌头会自然的上翘，嘴唇向O字发展 -ɚ：这个音节一定要读成耳的音，尤其和t在一起读的时候舌头上翘 -s: 当ptk遇到s的时候都要读成类似于bdg的读法
总结：面对元音音标已经掌握到了现在的程度，更加深入的应该对待单词上，现在短短的五遍我想实在不够，应该让他们归根到舌头和大脑的印象中，这样就不会消耗我们的意志力，我们就更有时间来熟练英语了，期待我们下一篇吧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bddacfb3a671429fad531b4dc6b20b9f/" rel="bookmark">
			mysql安装到第三步“Start Service“出现红叉，Could not start the service MySQL解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 不得不说卸载不干净真的很苦恼~
安装到第三步出现红叉，解决步骤如下：
1. 卸载已经安装的mysql 控制面板–&gt;程序卸载–&gt;找到mysql–&gt;右键卸载 2. 删除注册表所有关于MySQL的项目
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services 下的键值，如果有相关mysql键值(mysql、mysqladmin)删掉HKEY_LOCAL_MACHINE/SYSTEM/ControlSet001/Services/Eventlog/Applications/MySQLHKEY_LOCAL_MACHINE/SYSTEM/ControlSet002/Services/Eventlog/Applications/MySQLHKEY_LOCAL_MACHINE/SYSTEM/CurrentControlSet/Services/Eventlog/Applications/MySQL 3. 删除下面目录中所有mysql的有关目录：空目录也要删除
C:\Program Files (x86)\MySQLC:\ProgramData\MySQL 4.关机重启，重新安装 重新安装mysql，安装后先不要运行Server Instance Configuration wizard，重启后在开始菜单中运行该向导，即可。 或者打开安装目录找到MySQLInstanceConfig.exe运行进入配置向导 5. 注意点：
如果任务管理器里有关mysql内容也删除 ，否则影响配置，比如端口被占用等等如果最后还是不行，删除卸载mysql相关，然后换个安装目录再试一遍~ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/894cad68dce951aec571223aab9fb3c2/" rel="bookmark">
			安卓jarsigner签名安装包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步，打开cmd，进入到bin目录下，将所要签名的apk和keystore文件放入jdk的bin目录下。
例如：
cd C:\Program Files\Java\jdk1.8.0_101\bin 第二步，输入jarsigner命令：
jarsigner的命令格式：
jarsgner-verbose-keystore [keystorePath] -singnedjar [apkOut] [apkln] [alias] 其中：
[keystorePath] 是签名包路径
[apkOut] 是签名之后存放路径
[apkln] 是未签名的apk文件路径
[alias] 是签名文件的别称
例如：
jarsigner -verbose -keystore newApp.jks -signedjar signed.apk -digestalg SHA1 -sigalg MD5withRSA app-debug.apk young 签名过程中遇到的问题：
1、签名后安装不了。
解决办法：增加这句代码。
-digestalg SHA1 -sigalg MD5withRSA 2、提示无法对 jar 进行签名: java.util.zip.ZipException。
解决办法：把要重签名的apk后缀改成zip，打开后删除里面的META-INF目录，然后重新改成apk后缀。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31953c702303cd518820c50e4f782938/" rel="bookmark">
			windows下QT使用ifstream读取含中文路径的txt文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include &lt;QCoreApplication&gt; #include&lt;iostream&gt; #include&lt;iomanip&gt; #include&lt;fstream&gt; #include&lt;QTextCodec&gt; #include&lt;qdebug&gt; using namespace std; int main(int argc, char *argv[]) { QCoreApplication a(argc, argv); QTextCodec::setCodecForLocale(QTextCodec::codecForName("GBK")); QString qq="C:\\Users\\威\\Desktop\\a.txt"; char* ch; QByteArray ba = qq.toLocal8Bit(); // must ch=ba.data(); cout&lt;&lt;ch&lt;&lt;endl; ifstream in(ch); if (!in) { cout &lt;&lt; "erro" &lt;&lt;endl; } for(string str;getline(in,str);){ cout&lt;&lt;str&lt;&lt;endl; } return a.exec(); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d4835065f89d85321555f81d68a30b7/" rel="bookmark">
			&#39;dependencies.dependency.version&#39; for XXX:jar is missing
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springboot新建项目，pom文件报错，依赖包的版本丢失： [INFO] Scanning for projects... [ERROR] [ERROR] Some problems were encountered while processing the POMs: [ERROR] 'dependencies.dependency.version' for org.springframework.boot:spring-boot-starter-web:jar is missing. @ line 18, column 21 [ERROR] 'dependencies.dependency.version' for org.springframework.boot:spring-boot-starter-tomcat:jar is missing. @ line 30, column 15 [ERROR] 'dependencies.dependency.version' for org.springframework.boot:spring-boot-starter-redis:jar is missing. @ line 40, column 15 [ERROR] 'dependencies.dependency.version' for org.springframework.boot:spring-boot-starter-jdbc:jar is missing. @ line 55, column 15 [ERROR] 'dependencies.dependency.version' for org.springframework.boot:spring-boot-starter-data-jpa:jar is missing. @ line 60, column 15 [ERROR] 'dependencies.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d4835065f89d85321555f81d68a30b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7d382e5a3c227bafb6d61c637bb245d/" rel="bookmark">
			android优雅的解决列表嵌套  类似订单列表这种
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常见问题，类似订单列表这种，每个大item，有相同布局，但有些头部和底部View没办法根据数据类型复用，如下图。很多人采用列表嵌套列表来做，但这样会造成UI卡顿，因为滑动的时候外层列表的Item需不断的去设置内层列表的adapter。
机智的我觉得肯定是有办法，通过一个ListView或RecyclerView有多种item布局来实现。
通常后端返回数据是array里面嵌套了array。
{ data:[ {//大item order_num:"5236872983023", products:[ {//小item product_id:"352787398209380" } ] } ] } 想要用一个ListView或RecyclerView有多种item布局来实现，那数据必须是一个List。那我们为什么不把后端返回的数据，重新包装下呢。
思路： 按照UI结构，有头部、中间子列表item、底部三种布局类型，那就要三种数据类型。 然而后端返回的数据中并没有头部和底部这两种数据，那么我们可以去伪造出这两种数据，我们可以把后端返回的数据提取出来然后增加头部和底部数据装进一个List容器中。
我们可以自定义一个类：
/** * 类似订单列表 每个大item有相同头部底部布局，中间小item列表 * 二次封装数据 解决列表嵌套 避免UI卡顿 * Created by hucanhui on 2017/2/28. */ public class MultipleTypeDataHelper { public List&lt;MultipleTypeData&gt; datas = new ArrayList&lt;MultipleTypeData&gt;();//二次封装的数据容器 public void add(MultipleTypeData multipleTypeData){ datas.add(multipleTypeData); } public void remove(MultipleTypeData multipleTypeData){ datas.remove(multipleTypeData); } public void remove(int index){ datas.remove(index); } /** * 添加不同类型的数据 * @param type 数据类型 * @param object 对应数据 */ public void add(int type, Object object){ MultipleTypeData multipleTypeData = new MultipleTypeData(); multipleTypeData.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7d382e5a3c227bafb6d61c637bb245d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a9871b6b63ea3f6bf2ea1f2d31cc94f/" rel="bookmark">
			收集 Atom 资料
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常用插件
常用插件02
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b888304f8669b5b14e8f9af08fd994f1/" rel="bookmark">
			再见CSDN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一晃间用CSDN的博客已经两年多了，这两年收货了很多。我这人平时爱好很多滑雪、游泳、羽毛球、健身、看电影，但我最爱的就是编程，这是我的爱好，现在他已然成为了我的职业，在同行间我不敢说自己多优秀，也不敢说自己比别人厉害多少，唯一一点我超越别人的就是对计算机的喜爱，从小对计算机的酷爱，这在我身边我几乎是没有见到的，很多人要么是因为喜欢打游戏走上计算机这条路，要么就是为了工作混口饭吃，没见几个向我一样的，用过去的话说这种人叫“知己”，对计算机就是一种说不出的feel。
学习计算机最重要的就是积累，积累的同时必然也离不开分享，我一直在使用印象笔记（这真的是一个不错的app哦），平时有些内容想要给广大coder们分享，选择了很久，选择了CSDN的博客，开始的时候发技术博客竟然不会立刻发送成功需要审核，程序猿何苦为难程序猿呢？但是我没有放弃，咱发的是正规的内容，咱有理，咱怕啥！渐渐的使用CSDN成为了一种习惯，我会捞一些干货发出来，我这人就讨厌乱乱的累赘冗余的代码，只要我觉得挺有用的而且能整理好的我都会在笔记里面记一份，同时也在博客上分享一份，双保险防止哪个服务器有天突然大姨妈，我积累的心血就白费了。前几天不知怎么了（CSDN服务器重启？改版升级？还是链接挂错了），我需要查看一下我曾经分享记录的笔记，尼玛，尼玛，竟然上不去了，直到现在我看自己博客详细内容的时候是因为改版了？里面看着各种不习惯，各种不方便，但是不知为何有时搜索别人的博客进去还是以前的界面。以及越来越多的广告，乱七八糟的推荐，体验的下降，我觉得CSDN已经偏离了最开始的航线，商业化太严重了，他已经不再像我们程序员之间聚集在一起分享心得，分享经验的家了。所以我要打开门离开，你不再是那种让我有科技感，有逼格有激情的Home了。so bye bye！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcfafc50a8512605e4637f0ff2d95985/" rel="bookmark">
			yarn is running beyond physical memory limits 问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		----- Diagnostic Messages for this Task: Container [pid=7830,containerID=container_1397098636321_27548_01_000297] is running beyond physical memory limits. Current usage: 2.1 GB of 2 GB physical memory used; 2.7 GB of 4.2 GB virtual memory used. Killing container. Dump of the process-tree for container_1397098636321_27548_01_000297 : |- PID PPID PGRPID SESSID CMD_NAME USER_MODE_TIME(MILLIS) SYSTEM_TIME(MILLIS) VMEM_USAGE(BYTES) RSSMEM_USAGE(PAGES) FULL_CMD_LINE |- 7830 7816 7830 7830 (Java) 2547 390 2924818432 539150 /export/servers/jdk1.6.0_25/bin/java -Djava.NET.preferIPv4Stack=true -Dhadoop.metrics.log.level=WARN -Xmx2224m -Djava.io.tmpdir=/data2/nm/local/usercache/admin/appcache/application_1397098636321_27548/container_1397098636321_27548_01_000297/tmp -Dlog4j.configuration=Container-log4j.properties......
检查yarn-site-xml job内存限制
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcfafc50a8512605e4637f0ff2d95985/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f90192f6d3f4673f4b2ad071832dad3f/" rel="bookmark">
			关于使用Delphi XE10 进行android开发的一些总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果说, 再有新项目, 让我选择用Java还是Delphi, 那么, 我会毫不犹豫的选择使用 Java....
不可否则, Delphi在界面上, 确实没的说, 搭建速度快, 所见即所得, 传说的一份代码多平台使用(确实可以在ios下运行, 但是也会存在不少问题)
但是, 由于以下几个问题, 导致我完全, 再也不想用Delphi做Android开发了:
1. 应用第三方Jar包非常麻烦
首先, 要用第三方工具, 将jar转换成pas;
其次, 转换后也不一定可以直接使用, 需要逐步的排查错误, 导入需要的文件;
无所谓, 反正arcgis map的5W行pas文件, 我都调试通过了...
2. Webbrowser, ArcGIS Map这样的控件, 永远在最顶层
这就很烦躁了, 想跟其他界面进行交互, 就需要不停的显示, 隐藏, 这些顶层控件所在的界面, 如果要在这层界面上加控件, 恭喜你, 练习用代码创建控件, 并布局的好时候到了;
3. 莫名其妙的Android就无法调试了
选择Android, 启动调试, 程序在手机上运行起来了, IDE中根本没有调试...也是莫名其妙的出现
4. 代码到手机上运行的过程太慢
无论你修改没有修改代码, 总是全部编译一遍, 然后安装到手机上, 全套大概要500, 呸,,,要3~5分钟...(Eclipse就聪明多了, 没修改代码, 直接就可以开始调试了 )
5. 各种莫名其妙的错误
程序异常崩溃, FreeAndNil界面时崩溃, Frame隐藏/显示几次, 界面控件点击输入法卡死.....炒鸡不稳定的玩意...
6. 吃内存...太吃内存了...对编译机器的配置要求也高...
总而言之, 可能是我技术水平太低.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f90192f6d3f4673f4b2ad071832dad3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa1d32c920241aed19793242af976bad/" rel="bookmark">
			Python网络数据采集——正则表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机科学里曾经有个笑话：“如果你有一个问题打算用正则表达式（regular expression，通常简写regex）来解决，那么就是两个问题了。”
regex——你值得拥有！ 学正则表达式不一定只会用在爬虫，当然爬虫也未必会用到正则表达式（能找到捷径就不需要啊），学正则可以处理一些杂乱的文本，从杂乱的信息中找出些许规律性并批量过滤出自己想要的东东。可以这么说，regex——你值得拥有！之所以叫正则表达式，是因为它们可以识别正则字符串（regular string）；也就是说，它们可以这么定义：“如果你给我的字符串符合规则，我就返回它”，或者是“如果字符串不符合规则，我就忽略它”。这在要求快速浏览大文档，以查找像电话号码和邮箱地址之类的字符串时是非常方便的。 一句实话——正则表达式上手快，而且运行很快，通过一些简单的例子就可以轻松地学会。
1. 元字符
2. 正则表达式在实际中的一个经典应用
3. 正则表达式在线生成工具
4. Python的re模块
1. 元字符 普通字符只能匹配与自身相同的字符，而正则表达式中还规定了一系列的特殊字符，这些特殊字符具有特殊的语义，如下字符:
^ $ . * + ? = ! : | \ / ( ) [ ] { }
如果要匹配这些具有特殊含义的字符是普通字符，需要在这些字符前面加反斜杠()进行转义（如匹配普通字符！，\！即可）。正是这些特殊字符的存在，才使正则表达式具有强大的功能。由于它们是构造各种匹配复杂文本的正则表达式的基本字符，所以被称作元字符。
1.1 单个字符匹配的元字符 常见的元字符,主要是针对单个字符匹配的：
字符说明.匹配除 \n 以外的任何字符（注意元字符是小数点）。[abcd]匹配 abcd 之中的任意一个字符[a-k]匹配 a 到 k 之间的任意一个字符[^abc]不与 abc之中的任意一个字符匹配\w匹配大小写英文字符及数字 0 到 9 之间的任意一个及下划线，相当于 [a-zA-Z0-9_]\W不匹配大小写英文字符及数字 0 到 9 之间的任意一个，相当于 [^a-zA-Z0-9_]\s匹配任何空白字符，相当于 [ \f\n\r\t\v]\S匹配任何非空白字符，相当于 [^\s]\d匹配任何 0 到 9 之间的单个数字，相当于 [0-9]\D不匹配任何 0 到 9 之间的单个数字，相当于 [^0-9][\u4e00-\u9fa5]匹配任意单个汉字（这里用的是 Unicode 编码表示汉字的 ) 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa1d32c920241aed19793242af976bad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80336e84b6bc56476cafd8ebac465c46/" rel="bookmark">
			ios禁止网页放大缩小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		移动设备升级到iOS10了，发现了自带的Safari浏览器不再识别meta viewport了。以前我们都是用这个标签来让浏览器禁用缩放的。万恶的Apple~~
在iOS10之前都是通过
&lt; meta name = "viewport" content = "width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scalable=no" &gt; 来强制不让手机浏览器缩放的，但是升级到iOS10后Safari不再识别这个meta标签。所以得用js来hack一下：
禁用双指缩放：
document.documentElement.addEventListener( 'touchstart', function (event) { if (event.touches.length &gt; 1) { event.preventDefault(); } }, false); 禁用手指双击缩放：
var lastTouchEnd = 0; document.documentElement.addEventListener( 'touchend', function (event) { var now = Date.now(); if (now - lastTouchEnd &lt;= 300) { event.preventDefault(); } lastTouchEnd = now; }, false); 如果在iOS10的Safari中设置了viewport，其实双击放大也是不生效的，所以个人觉得在iOS10上比较好的解决方案是先设置viewport，然后再用js禁用双指缩放即可，无需再设置禁用双击缩放。
同时给出这个解决方案的作者还提出了一个有情提示，如果任何一个子元素的touch事件设置了stopPropagation阻止事件冒泡的话，可能还是会失效，而且在iOS10中你的输入框字体最好不要小于16px，否则iOS在输入框获得焦点时可能还是会强制放大。
原文地址：http://stackoverflow.com/questions/37808180/disable-viewport-zooming-ios-10-safari
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/faa49de8a0772f684a2f9e9706048230/" rel="bookmark">
			汇编语言入门七：函数调用（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想象
想象你在计算一个非常复杂的数学题，在算到一半的时候，你需要一个数据，而这个数据需要套用一个比较复杂的公式才能算出来，怎么办？
你不得不把手中的事情停下来，先去套公式、代入数值然后...最后，算出结果来了。
这时候你继续开始攻克这个困难题目的剩下部分。
用脑子想 刚刚说的这个过程，可能有点小问题，尤其是对脑子不太好使的人来说。想象你做题目做到一半的时候，记忆力已经有点不好使了，中间突然停下来去算一个复杂的公式，然后回来，诶？我刚刚算到哪了？我刚刚想到哪了？我刚刚算了些什么结果？
在你工作切换的时候，很容易回头来就忘记了刚刚做的部分事情。这时候，为了保证你套完复杂的公式，把结果拿回来继续算题目的时候不会出差错，你需要把刚才计算题目过程中的关键信息写在纸上。
用CPU想 刚刚去套用一个复杂的公式计算某个数据的情景，就类似在计算机里进行函数调用的情景。
程序需要一个结果，这个结果需要通过一个比较复杂的过程进行计算。这时候，编程人员会考虑将这个独立的复杂过程提取为单独的函数。
而在发生函数调用的时候，CPU就像是先暂停当前所做的事情，转去做那个复杂的计算，算完了之后又跳回来继续整个计算。就像你做题的过程中去套了一个公式计算数据一样。
但是在去套用公式之前，你需要做一些准备。首先，默默记下现在这个题目算到哪一步了，一会套完公式回来接着做；默默记下现在计算出来的一些结果，一会可能还会用到；套用公式需要些什么数据，先记下来，代公式的时候直接代入计算，算出来的结果也需要记在脑子里，回头需要使用。
在CPU里面，也需要这几个过程。
第一个，记下自己现在做事情做到哪里了，一会儿套完公式回来接着做，这也就是CPU在进行函数调用时的现场保存操作，CPU也需要记下自己当前执行到哪里了。
默默记下一些在套用公式的时候需要用到的数据，然后去套公式了。这也就是程序中在调用函数的时候进行参数传递的过程。
然后开始执行函数，等函数执行完了，就需要把结果记下来，回去继续刚才要用到数据的那个地方继续算。这也就是函数调用后返回的动作，这个记下的结果就是返回值。
开撸 说了那么多故事，那么函数调用要干些啥应该就说清楚了。总结一下大概就这么几个事：
保存现场（一会好回来接着做） 传递参数（可选，套公式的时候需要些什么数据） 返回（把计算结果带回来，接着刚才的事） 到这里，我们先来一个事例代码，就着代码去发现函数调用中的套路：
global main eax_plus_1s: add eax, 1 ret ebx_plus_1s: add ebx, 1 ret main: mov eax, 0 mov ebx, 0 call eax_plus_1s call eax_plus_1s call ebx_plus_1s add eax, ebx ret 首先，运行程序，得到结果：3。
上面的代码其实也比较简单，先从主干main这个地方梳理：
让eax和ebx的值都为0 调用eax_plus_1s，再调用eax_plus_1s 调用ebx_plus_1s 执行eax = eax + ebx 上述的两个函数也非常简单，分别就是给eax和ebx加了1。所以，这个程序其实也就是换了个花样给寄存器增加1而已，纯粹演示。
这里出现了一个陌生指令call，这个指令是函数调用专用的指令，从程序的行为上看应该是让程序的执行流程发生跳转。前面说到了跳转指令jmp，这里是call，这两个指令都能让CPU的eip寄存器发生突然变化，然后程序就一下子跳到别的地方去了。但是这两个有区别：
很简单，jmp跳过去了就不知道怎么回来了，而通过call这种方式跳过去后，是可以通过ret指令直接回来的
那这是怎么做到的呢？
其实，在call指令执行的时候，CPU进行跳转之前还要做一个事情，就是把eip保存起来，然后往目标处跳。当遇到ret指令的时候，就把上一次call保存起来的eip恢复回来，我们知道eip直接决定了CPU会执行哪里的代码，当eip恢复的时候，就意味着程序又会到之前的位置了。
一个程序免不了有很多次call，那这些eip的值都是保存到哪里的呢？
有一个地方叫做“栈(stack)”，是程序启动之前，由操作系统指定的一片内存区域，每一次函数调用后的返回地址都存放在栈里面
好了，我们到这里，就明白了函数调用大概是怎么回事了。总结起来就是：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/faa49de8a0772f684a2f9e9706048230/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b050fe2c57a79177605fc4e85e4a0622/" rel="bookmark">
			MATLAB 牛顿迭代法解非线性方程组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		牛顿迭代法流程图：
Newton迭代法计算步骤 ：
（1） 取初始点x0，最大迭代次数N和精 度 ε。
（2） 如果 f' (x0)=0， 则停止计算；否则计算 x1 = x0 -f（x0）/ f'（x0）。
（3） 如果|x1-x0|＜ε， 则停止计算 ； 否 则 x0=x1， 转 到 （2）。
（4） 如果n=N， 则停止计算； 否 则 取 n=n+1， 转 到 （2）。
这里给出一个例子：
首先建立函数：
function f=F(x); f(1)=x(1)^2-10*x(1)+x(2)^2+8; f(2)=x(1)*x(2)^2+x(1)-10*x(2)+8; f=[f(1) f(2)]; 然后构建上一个函数的导函数，用于求方程组的雅克比矩阵：
function df=DF(x) df=[2*x(1)-10,2*x(2); x(2)^2+1,2*x(1)*x(2)-10]; 最后编写迭代的过程：
clear; clc x=[0,0]'; %指定初始值 f=F(x); df=DF(x); fprintf('%d %.7f %.7f\n',0,x(1),x(2)); N=4; for i = 1:N y=df\f'; x=x-y; f=F(x); df=DF(x); fprintf('%d %.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b050fe2c57a79177605fc4e85e4a0622/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27337945f844b3549857d99ef5b8f1ed/" rel="bookmark">
			Python词云库wordcloud 显示中文 ！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景： wordcloud是基于Python开发的词云生成库，功能强大使用简单。
github地址：https://github.com/amueller/word_cloud
wordcloud默认是不支持显示中文的，中文会被显示成方框。
安装： 方法一：
pip install wordcloud 方法二： 下载.whl文件http://www.lfd.uci.edu/~gohlke/pythonlibs/#wordcloud 改后缀为.zip文件，解压。然后放到python安装的对应文件夹 （https://github.com/amueller/word_cloud/archive/master.zip）
python setup.py install 解决不支持中文： 经过测试发现不支持显示中文的原因是因为wordcloud的默认字体不支持中文，那就好办了，我们设置一种支持中文的字体即可
方法一： 百度下载字体simhei.ttf放到对应C:\Windows\Fonts里
方法二： wordlcloud.WordCloud类初始化函数有个设置字体的参数font_path，把支持中文的字体的路径传给font_path。
github有个Adobe开源的支持中文的字体库：https://github.com/adobe-fonts
我们以英文夹杂着中文的Python之禅字符串来测试一下，下面的代码是在Windows下测试，使用了仿宋字体。（两种方法处理文字：1.从文件读取 2.直接赋值给字符串）
# -*- coding: utf-8 -*- from wordcloud import WordCloud import matplotlib.pyplot as plt text= open("test.txt").read() """ text = ''' The 抱抱 Zen of LOVE 抱抱 Python, 快乐 by Tim 玲小姐 Peters 公众号 Python 最好的 语言 语言 一辈子 is better LOVE than 一辈子. 玲小姐 is 爱你 than implicit.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27337945f844b3549857d99ef5b8f1ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24a6d709087fc13876cf0e53a8ab8a3a/" rel="bookmark">
			Python：numpy中arange的使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&gt;&gt;&gt; np.arange(3)
array([0, 1, 2])
&gt;&gt;&gt; np.arange(1,3,0.3)
array([ 1. , 1.3, 1.6, 1.9, 2.2, 2.5, 2.8])
&gt;&gt;&gt; np.arange(1,12,2)
array([ 1, 3, 5, 7, 9, 11])
仅此而已，so easy
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7a6b9131e4339471b3b483de0620b4f/" rel="bookmark">
			Eclipse_新建web项目没有自动生成web.xml
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 背景 之前一直都是在用MyEclipse进行web项目学习，今天换成Eclipse进行web项目学习，却发现新建的web项目没有自动生成web.xml文件。 2. 解决方案 &lt;1&gt;点击eclipse的左上角File（文件），然后New（新建），选择Dynamic Web Project。
&lt;2&gt;按图的步骤走 3. 结果对比 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92e55125ee1bc4feeaee0e9cc79c85be/" rel="bookmark">
			matlab的datenum函数使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		matlab中包含了很多自带的函数，为用户的使用带来了方便。其中就有一个函数是datenum。
在此了解一下吧。
datenum用来将给定的日期字符串转换为日期数字。
所谓日期字符串是指平时我们所了解到的日期，比如：2017年5月20日。
而日期数字则是从公元0年到给定日期之间所经历的天数。
但是使用datenum函数有一定的规则，若不遵循该规则使用的话，matlab软件就会报错。
好了，现在就看下datenum的使用方法吧：
1、n = datenum('20-May-2017') &gt;&gt; n = datenum('20-May-2017')
n =
736835
注意：切记中间部分一定是月份的英文字母缩写，否则得不到正确日期数字。
2、n = datenum(2017,5,20) &gt;&gt; n = datenum(2017,5,20)
n =
736835
3、n = datenum(2017,5,20,12,30,00) &gt;&gt; n = datenum(2017,5,20,12,30,00) n =
7.3684e+005
4、n = datenum('20.05.2017','dd.mm.yyyy') &gt;&gt; n = datenum('20.05.2017','dd.mm.yyyy')
n =
736835
5、n = datenum(2017/5/20)
&gt;&gt; n = datenum('2017/5/20')
n =
736835
此时，括号中的内容可作为字符串处理。即可写成n = datenum('2017/5/20')
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14c4eeace532c55bfa2e57551352a261/" rel="bookmark">
			【C&#43;&#43;】基于linux文件管理和C＋＋的I/O框架，实现命令行下的文件管理器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实验项目内容 1、实现文件夹创建、删除、进入。 2、实现当前文件夹下的内容罗列。 3、实现文件拷贝和文件夹拷贝（文件夹拷贝指深度拷贝，包括所有子目录和文件）。
二、实验过程或算法 DocumentManger.h
#ifndef CIRCLE_H #define CIRCLE_H #include&lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;errno.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;unistd.h&gt; #include &lt;dirent.h&gt; #include &lt;string.h&gt; #include&lt;sstream&gt; #include&lt;iostream&gt; #include &lt;dirent.h&gt; #include &lt;fstream&gt; using namespace std; class DocumentManager { //DocumentManger 文件管理类 private: char *path; char *newpath; public: DocumentManager(); //构造函数1 DocumentManager( char *path); //构造函数2 void setNewpath( char* newpath); void setPath( char* path); void displayTips(); //命令提示行 int make_dir(const char *path, mode_t mode); //创建文件夹 int change_dir(const char *path); //改变路径 int remove_dir(const char* path); //移除文件夹 int get_file_size_time(const char *filename); //获取文件的信息 DIR * open_dir(const char *path); //打开文件夹 void read_dir(const char *path, bool ListAllFiles); //读取文件夹 int copy_dir(const char *filename, const char *newfilename); //拷贝文件夹 }; #endif DocumentManager.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14c4eeace532c55bfa2e57551352a261/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ad2d9c627c51088e74f5c16dfe275e1/" rel="bookmark">
			Redis使用简明教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一）安装redis 1）redis的安装
windows下64位redis安装，下载解压redis安装包Redis-x64-3.2.100.msi，直接按照步骤一键安装到本地 安装完成打开cmd，启动redis服务，输入相关指令观察是否安装成功。 cd进入到对应安装目录，输入命令redis-server.exe redis.windows.conf 详情参考百度经验 Windows 64位下安装Redis详细教程
二）基本简介 Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。
Redis 与其他 key - value 缓存产品有以下三个特点：
Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。
Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。
Redis支持数据的备份，即master-slave模式的数据备份。
更多参考： Redis菜鸟教程
redis存储数据类型主要有5种：
String最基本类型，最大为512M内容；
hash是一个键名对集合 是一个String类型的field和value的映射表，适合存储对象，每个hash可以存储2^32-1的键值对；
list列表是按照简单的字符串列表，按照顺序出入顺序排列，可以添加一个元素的到列表尾部或者头部，列表最多可存储 232 - 1 元素；
Set集合是通过哈希表实现的String类型的无序集合，删除添加复杂度为O(1),集合中最大的成员数为 232 - 1；
zset(sorted set：有序集合)，Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。
Redis保存的数据类型是通过key-value形式存储对应的数据，这些存储的数据转换转换成上面5种类型的格式的数据，当然这几种类型格式数据使用者可以进一步封装成自己需要的风格。具体参考下面Redis工具类。
三）简单实例应用 package com.test; import java.util.HashMap; import java.util.Iterator; import java.util.List; import java.util.Map; import org.junit.Before; import org.junit.Test; import redis.clients.jedis.Jedis; public class TestRedis { private Jedis jedis; @Before public void setup() { //连接redis服务器，192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ad2d9c627c51088e74f5c16dfe275e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8adab01d6f12566e65f3599cf46242b9/" rel="bookmark">
			dp 电子科大本部食堂的饭卡有一种很诡异的设计，即在购买之前判断余额。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #define N 1005 using namespace std; int w[N],v[N]; int dp[N][N]; bool cmp(int a,int b) { return a&gt;b; } int main() { int i,j,n,m; while(scanf("%d",&amp;n)!=EOF) { if(n==0) break; int maxx=-1; memset(dp,0,sizeof(dp)); memset(w,0,sizeof(w)); memset(v,0,sizeof(v)); for(i=1;i&lt;=n;i++) scanf("%d",&amp;w[i]); sort(w+1,w+n+1,cmp); for(i=1;i&lt;=n;i++) { v[i]=w[i]; } //for(i=1;i&lt;=n;i++) printf("%d ",w[i]); //printf("\n"); maxx=w[1]; scanf("%d",&amp;m); int maxv=m-5; for(i=0;i&lt;=maxv;i++) dp[0][i]=0; /*for (int i=1; i&lt;=n; i++) for (int j=1; j&lt;=maxv; j++) { if (w[i]&lt;=j) { dp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]+v[i]); } else dp[i][j]=dp[i-1][j]; }*/ if(maxv&lt;0){ printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8adab01d6f12566e65f3599cf46242b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85ddbff0746f74ae618e0c2ecc3b3da3/" rel="bookmark">
			ansible常用模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		copy模块
目的：把主控端/root目录下的a.sh文件拷贝到到指定节点上
命令：ansible 10.1.1.113 -m copy -a 'src=/root/a.sh dest=/tmp/'
file模块
目的：更改指定节点上/tmp/t.sh的权限为755，属主和属组为root
命令：ansible all -m file -a "dest=/tmp/t.sh mode=755 owner=root group=root"
cron模块：
目的：在指定节点上定义一个计划任务，每隔3分钟到主控端更新一次时间
命令：ansible all -m cron -a 'name="custom job" minute=*/3 hour=* day=* month=* weekday=* job="/usr/sbin/ntpdate 172.16.254.139"'
group模块：
目的：在所有节点上创建一个组名为nolinux，gid为2014的组
命令：ansible all -m group -a 'gid=2014 name=nolinux'
user模块：
目的：在指定节点上创建一个用户名为nolinux，组为nolinux的用户
命令：ansible 10.1.1.113 -m user -a 'name=nolinux groups=nolinux state=present'
yum模块：
目的：在指定节点上安装 lrzsz 服务
命令：ansible all -m yum -a "state=present name=httpd"
service模块：
目的：启动指定节点上的 puppet 服务，并让其开机自启动
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85ddbff0746f74ae618e0c2ecc3b3da3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c6b6364a0bb885c6cde9004296f7015/" rel="bookmark">
			大话 Select、Poll、Epoll
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大话 Select、Poll、Epoll 黄日成 2017-07-17 92 标签： 性能优化 ， 经验分享 提到select、poll、epoll相信大家都耳熟能详了，三个都是IO多路复用的机制，可以监视多个描述符的读/写等事件，一旦某个描述符就绪（一般是读或者写事件发生了），就能够将发生的事件通知给关心的应用程序去处理该事件。本质上，select、poll、epoll本质上都是同步I/O，相信大家都读过Richard Stevens的经典书籍UNP（UNIX:registered: Network Programming），书中给出了5种IO模型：
[1] blocking IO - 阻塞IO [2] nonblocking IO - 非阻塞IO [3] IO multiplexing - IO多路复用 [4] signal driven IO - 信号驱动IO [5] asynchronous IO - 异步IO
其中前面4种IO都可以归类为synchronous IO - 同步IO，在介绍select、poll、epoll之前，首先介绍一下这几种IO模型，signal driven IO平时用的比较少，这里就不介绍了。
1. IO - 同步、异步、阻塞、非阻塞 下面以network IO中的read读操作为切入点，来讲述同步（synchronous） IO和异步（asynchronous） IO、阻塞（blocking） IO和非阻塞（non-blocking）IO的异同。一般情况下，一次网络IO读操作会涉及两个系统对象：(1) 用户进程(线程)Process；(2)内核对象kernel，两个处理阶段：
[1] Waiting for the data to be ready - 等待数据准备好 [2] Copying the data from the kernel to the process - 将数据从内核空间的buffer拷贝到用户空间进程的buffer IO模型的异同点就是区分在这两个系统对象、两个处理阶段的不同上。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c6b6364a0bb885c6cde9004296f7015/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c761b5273451cc8fa4a86a53ca554ea7/" rel="bookmark">
			Spring Boot部署NewRelic的Java探针记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、需求 在Spring Boot项目中加入NewRelic的Java探针环境：Mac OSIDE：IDEA构建工具：maven 二、pom.xml pom文件修改如下：
增加NewRelic Agent依赖在spring-boot-maven-plugin中注明main class把NewRelic Agent jar打包进最终jar在manifest中增加Premain-Class等属性 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; .... &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.newrelic.agent.java&lt;/groupId&gt; &lt;artifactId&gt;newrelic-agent&lt;/artifactId&gt; &lt;version&gt;3.41.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; .... &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;com.xxx.SpringBootNewRelicApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt; &lt;version&gt;2.10&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;prepare-package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;unpack-dependencies&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;includeArtifactIds&gt;newrelic-agent&lt;/includeArtifactIds&gt; &lt;outputDirectory&gt;${project.build.outputDirectory}&lt;/outputDirectory&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;archive&gt; &lt;manifestEntries&gt; &lt;Premain-Class&gt;com.newrelic.bootstrap.BootstrapAgent&lt;/Premain-Class&gt; &lt;Can-Redefine-Classes&gt;true&lt;/Can-Redefine-Classes&gt; &lt;Can-Retransform-Classes&gt;true&lt;/Can-Retransform-Classes&gt; &lt;/manifestEntries&gt; &lt;/archive&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c761b5273451cc8fa4a86a53ca554ea7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/458758a08dede88102ff8e9927375c78/" rel="bookmark">
			鼠标滑轮成了页面缩放的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在某次操作中，发现鼠标的滑轮不能上下翻页，反而会造成页面缩放。
具体的解决方法 （1）按照原本windows系统，Ctrl+滑轮才是页面缩放，所以检查下是否Ctrl键卡住了，如果卡住了，将Ctrl键弄好。 （2）如果上面的方法不行，就用Ctrl+0试试，应该有效。
———————————— 2017.08.16 17：10
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4695eabecd36e5a4fe3cc23e66d901ac/" rel="bookmark">
			关于MySQL 建表的一些建议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL作为关系型数据库，被用来存储持久化的数据，避免不了需要创建表。如果没有利用ORM(对象关系模型)来自动创建表，则需要开发者通过图形界面（Navicat）或者手写MySQL语句。
由于在生产环境下，我们对MySQL数据库的操作通常是通过命令行进行操作，因此，建议建表的时候也手写MySQL语句（不建议用图形界面建表）。
1、添加注释的格式
在编写MySQL语句时，我们通常会被要求加上注释，推荐的注释格式为：
------------------------------------------------- -- 创建表 tb_example 创建示例表 ------------------------------------------------- create table tb_example( …. )… 理由：这种注释格式MySQL解析器也会认为是注释的，然后，会正确执行你的create table相关语句。我们通常将要更改的sql语句整理到一个1.0.0.sql文件中，然后，你只需要登录MySQL客户端，输入：source /文件目录/1.0.0.sql。因此，这样的注释可以达到一举两得的目的。
2、指定表的引擎和缺省的编码格式以及该表的说明
示例语句如下： create table tb_example( …. )engine=innodb default charset=utf8 comment ‘这是一张示例表’; 理由：上述显示的指定使用的引擎为innodb，在5.6之前默认的引擎是MyISAM，而现在主流推荐性能较好的是innodb，具体参考：高性能MySQL 这本书。上述也指定了缺省字符集为utf8，还有不要漏掉使用comment来注释下这张表的用途，便于其他开发人员了解这张表的意图。
3、一个经典的建表语句示例并分析
示例语句如下：
create table tb_example( id int unsigned not null auto_increment comment '主键id', app_id int unsigned not null default '0' comment '应用id', app_name varchar(255) not null default '' comment '应用名', click_cnt int unsigned not null default '0' comment '点击数', disp_cnt int unsigned not null default '0' comment '展示数', status tinyint unsigned not null default '0' comment '状态： 1-启用；0-禁用', click_rate float unsigned not null default '0' comment '点击率=点击数/展示数', note text not null default '' comment '备注', date varchar(255) not null default '统计日期', mtime int unsigned not null comment '修改时间', ctime int unsigned not null comment '创建时间', primary key ("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4695eabecd36e5a4fe3cc23e66d901ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3b4f1062081c1204c60afaf91cadfc8/" rel="bookmark">
			PC端 微信支付 扫码之后页面跳转处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		其实就是用Ajax异步刷新去后台轮询、
if(payType == 'wxPay'){ $.ajax({ url: "********", type: "post", data: { oId: oId }, success: function(result) { if(result == 'orderError'){ alert("订单信息异常..."); return false; }else{ var url = result; jQuery('#qrcode').qrcode(url); $(".orderBoxPay").hide(); $(".wxpay-box").slideDown("fast"); $(".markall").css({ display:"block", height:document.body.clientHeight+"px", }); var repeat = 200; // 限制执行次数为200次 var timer = setInterval(function() { if (repeat == 0) { clearInterval(timer); //处理页面提示信息 } else { //Ajax后台轮询 查询订单状态 $.ajax({ url: "${path}/pages/order/checkOrderStatus", type: "post", data: { oId: oId }, success: function(result) { if(result == '1'){ clearInterval(timer); window.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3b4f1062081c1204c60afaf91cadfc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef1688517e1f8f831b44ec1deef3ece5/" rel="bookmark">
			makefile编写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#设置当编译路径为当前文件夹所在路径 LOCAL_PATH := $(call my-dir) #清空编译环境的变量（由其他模块设置过的变量） include $(CLEAR_VARS) 其中： #BUILD_STATIC_LIBRARY：编译为静态库。 #BUILD_SHARED_LIBRARY ：编译为动态库 #BUILD_EXECUTABLE：编译为Native C可执行程序 LOCAL_PATH:=$(call my-dir) Android.mk文件首先需要指定LOCAL_PATH变量，用于查找源文件。由于一般情况下 Android.mk和需要编译的源文件在同一目录下，所以定义成如下形式：
include (CLEARVARS)...include (BUILD_XXX) Android.mk中可以定义多个编译模块，每个编译模块都是以include $(CLEAR_VARS)开始，以include $(BUILD_XXX)结束。
include $(CLEAR_VARS) CLEAR_VARS由编译系统提供，指定让GNU MAKEFILE为你清除除LOCAL_PATH以外的所有LOCAL_XXX变量， 如:LOCAL_MODULE，LOCAL_SRC_FILES，LOCAL_SHARED_LIBRARIES，LOCAL_STATIC_LIBRARIES等。
include $(BUILD_STATIC_LIBRARY)表示编译成静态库include $(BUILD_SHARED_LIBRARY)表示编译成动态库。include $(BUILD_EXECUTABLE)表示编译成可执行程序 举例： frameworks/base/libs/audioflinger/Android.mk
#编译当前目录 LOCAL_PATH:= $(call my-dir) #模块一 include $(CLEAR_VARS) ifeq ($(AUDIO_POLICY_TEST),true) ENABLE_AUDIO_DUMP := true endif LOCAL_SRC_FILES:= \ AudioHardwareGeneric.cpp \ AudioHardwareStub.cpp \ AudioHardwareInterface.cpp ifeq ($(ENABLE_AUDIO_DUMP),true) LOCAL_SRC_FILES += AudioDumpInterface.cpp LOCAL_CFLAGS += -DENABLE_AUDIO_DUMP endif LOCAL_SHARED_LIBRARIES := \ libcutils \ libutils \ libbinder \ libmedia \ libhardware_legacy ifeq ($(strip $(BOARD_USES_GENERIC_AUDIO)),true) LOCAL_CFLAGS += -DGENERIC_AUDIO endif LOCAL_MODULE:= libaudiointerface ifeq ($(BOARD_HAVE_BLUETOOTH),true) LOCAL_SRC_FILES += A2dpAudioInterface.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef1688517e1f8f831b44ec1deef3ece5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d5d067b4f2a160f26a3509677a0e2cd/" rel="bookmark">
			Python：whl文件是神？如何安装whl文件？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		whl格式本质上是一个压缩包，里面包含了py文件，以及经过编译的pyd文件。使得可以在不具备编译环境的情况下，选择合适自己的python环境进行安装。
安装方法很简单，进入命令行输入
pip install xxxx.whl
或者如果是升级
pip install -U xxxx.whl
即可。
=================如何安装whl文件================================
来自：http://blog.csdn.net/fhl812432059/article/details/51745226
转载是一种偷懒。管不了那么多了，人一辈子就那么多时间。各位客官将就一下吧，哈哈
步骤：
1.用管理员方式打开cmd
2.首先通过pip命令安装wheel 如果提示’pip’不是内部或外部命令，也不是可运行的程序或批处理文件
①将python安装目录下的scripts目录（例如D:\Python27\Scripts）添加到系统环境变量path里，注意前加分号。再执行该命令
pip install wheel
②在cmd下进入到D:\Python27\Scripts目录下执行该命令
pip install wheel
3.安装whl文件
①如果将D:\Python27\Scripts目录添加到path中，可以直接在whl文件所在目录用管理员打开一个cmd窗口，直接执行下面的语句。 pip install python_dateutil-2.5.3-py2.py3-none-any.whl ②否则的话，需要在D:\Python27\Scripts目录下用管理员打开cmd，运行pip命令，文件名应该写全路径） pip install C:\Users\xxx\Downloads\python_dateutil-2.5.3-py2.py3-none-any.whl =================如何使用pip安装库文件=========================
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/599c366164fc14b54913cc1c9da2870f/" rel="bookmark">
			调用自己编写的matlab函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		matlab是一款功能强大的，可以用于算法开发、数据分析、数据可视化、数据计算等的高级技术计算语言。
因此matlab本身就已经包含了很多供用户使用的函数。但是，有时候我们也需要定义自己需要的函数以便于
更好的完成想要实现的功能。那么，自己定义的函数应该怎样调用呢？
1、首先，我们需要先完成需要调用的子函数
这时，先创建一个新的m文件（这里我叫做calsum.m），然后写入代码。代码如下：
function y = calsum(a) y = 0; for i = 1:length(a) y = y+a(i); end 2、然后再创建一个新的m文件（这里我叫做test.m），写入代码。代码如下： function sum = test(a) sum = calsum(a)这样就完成了函数的调用了。其中，function表示函数头，在MATLAB中定义函数必不可少的一个单词。 其后sum表示输出值，test为函数名，a为变量。
3、检验结果：
&gt;&gt; a = [1,2,3,4,5,6,7];
&gt;&gt; test(a)
ans =
28
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b9a6da03bafcfd42897ed82b7e02697/" rel="bookmark">
			云服务器&#43;域名&#43;nodejs（小白建站）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我想不管是前端还是后端工作者都想要一个属于自己的网站，前端后端全权管理岂不是美滋滋~ 两个月前的我还是纯粹的小白，html是何物都一窍不通，终于自学两个月后，我膨胀了，不自量力的着手建站。 写在前面，本人技能 勉强熟练的js,html,css浅显的nodejs 第一步：阿里云购买域名
过程略(备案呀记得) 第二步：阿里云购买云服务器 系统选你熟悉的就行 我买的是window Server 2008 32位的 服务器会分配一个公网IP（反正我买的学生机是有），将你的域名解析到这个IP 第三步：远程连接服务器
配置Nodejs(和本机操作一样，就是下载的版本注意下就好)用到数据库的话自己下载就好（我用的mongodb）上传你的在本机写好的项目文件（当然你想直接在服务器上现写也无所谓） 第四步：更改你的监听端口号port、监听地址host 按这个点 阿里云云服务器ECS&gt;网络和安全&gt;安全组&gt;规则配置 进入后你可以看见服务器给你授权的端口号和地址 端口3389好像是都被授权了，不行的换另一个试试 第五步：在服务器运行你的服务node app
当然你外网访问地址就成了 域名：端口号
又搞了搞发现可以使用80端口（自己配置规则）
配置后更改服务监听
sever.listen(80,'0.0.0.0',function(){}) 这时就可以直接通过域名访问
追加一点：如果你用IIS之类的最好先停了，80端口可能会被你之前的配置占了（你可以用netstat命令查看一下）
成与不成未可知，反正博主是误打误撞成功了，哈哈，希望带给你一点帮助吧
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d80bcb209ed184c449a1cfdf1a891a86/" rel="bookmark">
			让 CSS 完成背景图加载完毕后显示 之 解析 IOING 的 onload url 原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WEB 之所以看起来很 WEB，除了自身慢的问题还有因为它具备了一些独有的特性，比如链接跳转，物理像素，不能获取软键盘高度等具有 WEB 特色的问题。
而今天我想讲一点大家都不在意的一个问题，图片流式加载的问题
我们先来看一个短片：
很明显我们能看出问题所在，这个仿 iOS 桌面程序的背景加载非常具有 WEB 特色，虽然在某些场景来说这是一个优点，比如传统网页上，但对于一个应用级产品（对于如此般挑剔的我来说）这样的体验还是难以接受的
那么我们就上手改造吧，先把改造后的效果 po 出来：
对于这样的效果很多同学都能拿出各种的方案，如果今天我们只是讨论传统方案就没意思了，我们看一下 IOING 中的实现方法是怎样的，然后分析一下它是如何做到的。
传送门：IOING 的相关文档
这里给出两段 CSS 示例：
/*片段 1*/ .bg { background: #fff onload url(./bg.png) center no-repeat; } &lt;!--片段 2--&gt; &lt;div style="background-image: onload url(./bg.png);"&gt;&lt;/div&gt; 我们仔细看一下后发现，这个语法中多了一个 onload 的属性，这个定义就是表示后面 url 中的背景图在载入完成后才会进行展示
上面这两段 CSS 示例中第二个示例的解决方案还是比较好梳理的，在 IOING 中模版文件会被解析成虚拟 DOM 树，在这解析过程中会把 style 属性的内容丢给 IOING 内置的 CSS 引擎来处理，而第一段的 CSS 则没有明确关联的 DOM 节点，但没关系，我们可以分为两个逻辑段分别处理
先来看一下片段 2 的解决流程
语法分析，把设定‘onload’属性的节点的背景图设置为空把该背景图放置在沙盒中加载图片加载完成后把该节点的背景图重新设置回来 其实原理比较简单，重点是如何把 CSS 与 DOM 节点关联起来，显然第一段的实现就难在这个问题上，由于 CSS 在解析时 IOING 的内置引擎是知道该 CSS 的来源的，比如是模块 CSS 或者是组件 CSS，这样我们就可以首先定位到所作用的 DOM Tree
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d80bcb209ed184c449a1cfdf1a891a86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98d248a5d122a0b8a61441daccebc0ac/" rel="bookmark">
			ps的一些使用技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何提取签名字的文字 http://jingyan.baidu.com/article/c45ad29c344237051753e2f0.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05bc65e1345d617a33455877ae7a2a4d/" rel="bookmark">
			Linux系统学习方法——写给小白
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux系统学习方法——写给小白
每个人都有心中向往的一些事情，而我，刚进实验室，看到师兄师姐在电脑前面噼里啪啦的敲代码，真的好羡慕，看着他们实现一个又一个的功能满心欢喜，我也很想尝试。后来了解到师兄师姐是在学习Linux，于是我就开始了我的Linux学习之路。
开始的我真的一点头绪都没有，真的是万事开头难。向师兄师姐请教了学习方法，他们给了我一堆资料，我闷头看了一个周，感觉很晕，怀疑是不是自己智商不够。后来我去到了图书馆，开始找书籍看，图书馆的书很多，但是没有我想要的。偶然一次浏览论坛的时候看到很多人推荐《Linux就该这么学》，于是我就找来了这本书，开始认真研读，不得不多说几句，这本书的内容真的很适合初学者，这是一本重实用性的书籍，跟着书籍的章节走，在加上小实例的练习，很快让我爱上了这本书！
人生就像登山，不一定每个人都能爬到山顶，但爬了就好；不一定每个人都要登到山顶，但一定要一步一个脚印。学习也是一个道理，要一步一个脚印，在学习的过程中，我们应该更加注重学习的过程，掌握学习的方法，慢慢理解学习的真谛。学习，是一条漫长的路，熟话说，学无止境。我们学习Linux也是一个道理，要一步一个脚印。对于初学者来说，一定要先看书，从书籍入手，把最基础的知识都串起来，等到使用的时候才会如鱼得水。所以，刚开始学习Linux的同学们，一定不要心急，就一步一步的来，根据书本来，边看书边做实验，这绝对是掌握知识的好方法。多说一句，初学者不建议多看论坛贴吧啥的，这样支离片碎的知识不利于我们系统的学习Linux。有了问题不要着急发问，先动脑子，然后查资料。这样坚持一个月，应该差不多掌握了基础知识了。
接下来，就是提升自己的时候了。学习是靠平时一步一个脚印的积累起来的，没有一步登天的捷径，只能慢慢的积累，才能得到你想要的，即使达不到胜利的巅峰，也能使自己的人生散发出光彩。看完了之前推荐的那本书，就得多学习Linux操作指令了，书中肯定有提到一些指令，当然对于初学者，能把这些指令学会应该也还不错。Linux中的命令可以分为两部分，一个是系统基础命令，另一个是应用程序命令。系统基本命令大约两百个，这是所有系统都支持的命令，这部分命令一定要掌握。还有一些是特有的命令，这部分命令大家要在脑子里行成印象，用的时候知道在哪里，然后查阅使用即可。
如果想要成为Linux大神，你需要做的还很多，看看书操作一下指令是远远不够的。你还要学会管理系统，当你有了一定的知识储备的时候，就可以尝试着学习管理系统，这样会使你很快的进步，刚开始，你可以尝试搭建自己的网站，然后学着配置网络服务器，别着急，慢慢的进步，合理分配自己的时间，遇到不明白的多查阅资料，你遇到的问题，大神们肯定之前也遇到过，不要畏惧，每一条路都是有意义的，难免会有磕磕碰碰，既然选择了，就要努力的走下去！你要相信，努力了，就会有意义！
因为我不是计算机专业的学生，所以，我认为，学习Linux是需要一些专业课程的，比如说计算机网络，微机原理等等一些课程你是需要多了解的。这些课程看似和Linux没有什么太大的关系，但是这是基础中的基础，他会潜移默化的影响你的上层建筑。有了这些基础，你会发现你学习Linux知识会很快，别人得看三四遍才能明白，有这个基础的人一两遍就差不多明白怎么回事了，这就是差别，所以，想要自己走的更远，你需要学的知识也更多，学无止境，各位加油吧！
最后，给大家说说我的学习心得，我感觉学习Linux真的是方法很重要，找到合适的书籍合适的老师比什么都重要，看到有好多培新机构，同学们也可以选择自己喜欢的报名学习，这样肯定比自学入门快很多。Linux大牛有很多，请务必一直保持谦虚学习的态度，学习没有满的时候，俗话说，学如逆水行程，不进则退。有了这个态度就能使你一直进步，遇到问题要虚心向别人请教，不管对方比你水平低还是高，都要放低姿态，谦虚使人进步，这个应该伴随你的一生。Linux是个非常值得大家学的一门技术，在这里我就不多说了，相信大家都知道，现在会Linux的人真的是多如牛毛，既然那么多同行，大家都要努力了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4161fe7d3b3b3db5f869a44ccf552f0/" rel="bookmark">
			安装Python版本的cairo模块：Pycairo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 1.折腾：
【记录】折腾Python中的一个绘制图表的模块：pycha
的过程中，需要用到cairo。
所以，就去找cairo。
但是在其主页中：
http://www.cairographics.org/
找了半天，还是没有找到，如何在Windows中安装cairo的，尤其是for python的。
2.后来搜索
python cairo
倒是找到了对应的Pycairo，结果去看，还就是刚才主页里面的：
http://cairographics.org/pycairo/
然后就可以去下载并安装了。
下载Pycairo 我这里是Python 2.7的，所以下载对应的：
py2cairo-1.10.0 for python 2.x
得到py2cairo-1.10.0.tar.bz2，解压后得到文件夹py2cairo-1.10.0。
安装Pycairo 1。参考：
D:\tmp\dev_tools\python\pycairo\py2cairo-1.10.0\INSTALL
的说明，去：
? 1 2 3 4 5 6 7 D:\tmp\dev_tools\python\pycairo\py2cairo-1.10.0&gt;. /waf --help '.' is not recognized as an internal or external command , operable program or batch file . D:\tmp\dev_tools\python\pycairo\py2cairo-1.10.0&gt;waf --help 'waf' is not recognized as an internal or external command , operable program or batch file .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4161fe7d3b3b3db5f869a44ccf552f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/165e10217bc7b6cd30c455f22389fde4/" rel="bookmark">
			Python：查找字符在字符串中的位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		str_1='wo shi yi zhi da da niu ' char_1='i' nPos=str_1.index(char_1) print(nPos) 运行结果：7
========是使用find==========
str_1='wo shi yi zhi da da niu ' char_1='i' nPos=str_1.find(char_1) print(nPos) 结果：5
========如何查找所有‘i’在字符串中位置呢？===========
#开挂模式 str_1='wo shi yi zhi da da niu ' char_1=str(input('Please input the Char you want:')) count=0 str_list=list(str_1) for each_char in str_list: count+=1 if each_char==char_1: print(each_char,count-1) 运行结果：
Please input the Char you want:i
i 0
i 1
i 2
i 3
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3054de5be08e2f5bd11f7c18e8c8ca7a/" rel="bookmark">
			HDU 1257 最少拦截系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HDU 1257 最少拦截系统 Time limit 1000 ms Memory limit 32768 kB OS Windows
Problem Description
某国为了防御敌国的导弹袭击,发展出一种导弹拦截系统.但是这种导弹拦截系统有一个缺陷:虽然它的第一发炮弹能够到达任意的高度,但是以后每一发炮弹都不能超过前一发的高度.某天,雷达捕捉到敌国的导弹来袭.由于该系统还在试用阶段,所以只有一套系统,因此有可能不能拦截所有的导弹. 怎么办呢?多搞几套系统呗!你说说倒蛮容易,成本呢?成本是个大问题啊.所以俺就到这里来求救了,请帮助计算一下最少需要多少套拦截系统. Input
输入若干组数据.每组数据包括:导弹总个数(正整数),导弹依此飞来的高度(雷达给出的高度数据是不大于30000的正整数,用空格分隔) Output
对应每组数据输出拦截所有导弹最少要配备多少套这种导弹拦截系统. Sample Input
8 389 207 155 300 299 170 158 65
Sample Output
2
Submit
#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; #define maxn 1010 #define INF 0x3f3f3f3f int dp[maxn]; int main() { int N, n; int i, j, k; while(~scanf("%d", &amp;N) &amp;&amp; N) { k = 0; dp[1] = 0; for(i = 1; i &lt;= N; i++) { scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3054de5be08e2f5bd11f7c18e8c8ca7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a956ca40172a0818fbef7b016dad4225/" rel="bookmark">
			HDU 1260 Tickets
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HDU 1260 Tickets Time limit 1000 ms Memory limit 32768 kB OS Windows
Problem Description
Jesus, what a great movie! Thousands of people are rushing to the cinema. However, this is really a tuff time for Joe who sells the film tickets. He is wandering when could he go back home as early as possible. A good approach, reducing the total time of tickets selling, is let adjacent people buy tickets together.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a956ca40172a0818fbef7b016dad4225/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cb03780b91b10aa3969ac6a2c0817fe/" rel="bookmark">
			HDU 1114 Piggy-Bank
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HDU 1114 Piggy-Bank Time limit 1000 ms Memory limit 32768 kB OS Windows
Problem Description
Before ACM can do anything, a budget must be prepared and the necessary financial support obtained. The main income for this action comes from Irreversibly Bound Money (IBM). The idea behind is simple. Whenever some ACM member has any small money, he takes all the coins and throws them into a piggy-bank. You know that this process is irreversible, the coins cannot be removed without breaking the pig.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cb03780b91b10aa3969ac6a2c0817fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efaf880ff24a94e25787a66d83e3a904/" rel="bookmark">
			sql语句表关联
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.基础表student-学生表，class--班级表
2.内部关联，两种方式
2.1.使用“=”或者“&lt;&gt;”符号
select class.name as class_name ,student.name as student_name from class,student where class.id=student.class_id
2.2.使用inner join进行表关联
select class.name as class_name ,student.name as student_name from class inner join student on class.id=student.class_id
返回结果相同为：
分析结果：两张表进行笛卡尔积运算之后筛选出条件相符的数据。
说明：笛卡尔积运算（a，b）（1,2,3）运算结果为（a，1）(a,2),(a,3)（b，1）(b,2)(b,3),其中两个基础表的笛卡尔积结果为
3.左关联 left join
select class.name as class_name ,student.name as student_name from class left join student on class.id=student.class_id
运行结果
分析结果：左边表数据全部显示，当在右边表找不到结果是，字段内容为null
4.右关联 right join
select class.name as class_name ,student.name as student_name from class right join student on class.id=student.class_id
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/efaf880ff24a94e25787a66d83e3a904/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db7ad391d660fc3ccf879c73463d32a2/" rel="bookmark">
			set&#43; vector的详解及用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Set 的用法总结： //====================== /*C++STL之set的基本操作 //2015-04-1321:05 by itwolf, 1943 阅读, 0 评论, 收藏, 编辑 set是集合，虽然也存在键值和实值，不过两者根本就是同一个值，键值的设置完全就是为了满足红黑树的底层结构，set操作与map很像不过也有些不同。 1、set迭代器与map的不同： (1)set使用接引用运算符*取值，而map使用first和second取值。 (2)set的迭代器都是常量迭代器，不能用来修改所指向的元素，而map的迭代器是可以修改所指向元素的。 2、set没有重载[]运算符，而map中重载了，因为直接使用[]改变元素值会打乱原本正确的顺序，要改变元素值必须先删除旧元素，则插入新元素 3、构造的类型不一样，如同样实值为int类型分别为set&lt;int&gt;和map&lt;type,int&gt;(其中type可以为任意类型) 其他如插入、删除、查找等操作与map几乎一样 */ #include&lt;iostream&gt; #include&lt;set&gt; using namespace std; voidprint(set&lt;int&gt;set_int) { set&lt;int&gt;::iteratorit=set_int.begin(); for(;it!=set_int.end();it++) cout&lt;&lt;*it&lt;&lt;" "; //循环输出 set容器里面的元素是被排好序之后进行的输出！！！！！重要！！！！ cout&lt;&lt;endl; } int main() { intnum[4]={1,2,3,4}; set&lt;int&gt;set_int(num,num+4); set_int.insert(5); //代表了插入一个元素 并且输出set集合里面的值 2,在pos位置之前插入value，返回新元素位置，但不一定能插入成功 //iterator insert(&amp;pos, value) print(set_int); set_int.insert(5); print(set_int); //元素删除 set_int.erase(3);//1. 移除set容器中的所有为3的元素值 并返回元素的个数 //2.voiderase(&amp;pos) //移除pos位置上的元素 无返回值 //3.void erase（&amp;first，&amp;last） 移除迭代区间【&amp;first,last)内的元素无返回值 //4.void clear(); 移除set容器中的所有元素 print(set_int); //元素查找 //count(value)返回set对象内元素之为value的元素个数 //iterator find(value)返回value所在位置，找不到value将返回end（）； //lower_bound(value)表示返回大于等于value的第一个元素的下标 upper_bound(value),qual_range(value); int a[5]={8,4,5,5,5}; // 当你的数组中有重复的元素时放入set容器输出直接将重复的删除 set&lt;int&gt;v4(a,a+5); print(v4); //--------------以下查找函数 返回的值的下标是不对的！！！！！！！！ 建议先不使用该函数------------- set&lt;int&gt;::iteratorit; it=v4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db7ad391d660fc3ccf879c73463d32a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56cf972b93c3794454b02f172621e667/" rel="bookmark">
			信息论实验-信源编码算法 (Huffman and Shannonn Fano编码C&#43;&#43;实现)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验目的 1. 实现压缩编码算法——Huffman编码 2. 实现压缩编码算法——Shannon Fano编码 3. 实现压缩编码算法——LZ编码 4. 实现压缩编码算法——算数编码 5. 利用上述压缩算法压缩图像、音频、视频文件，分析压缩算法的性能。 ** 先上源代码，如果对实验的源代码感兴趣的同学，请到小猪嘎嘎的仓库下载**
信源编码源代码
第一章：Huffman编码的实现 Huffman编码原理 数据压缩是一门通信原理里和计算机科学都会涉及到的学科，在通信中，一般称为信源编码，在计算机科学里，通常称为数据压缩，两者没有本质区别，从数学角度看，都是映射。压缩可以分为有损压缩和无损压缩。有损压缩，指的是压缩之后无法还原原始信息，但是可以达到很高的压缩率，主要应用于视频、通话、图像等信息的传输领域。无损压缩则用于文本文件等必须完整还原信息的领域。
Huffman编码是一种可变长编码(VLC:ariable length coding)方式，于1952年由huffman提出。依据字符在需要编码文件中出现的概率提供对字符的唯一编码，并且保证了可变编码的平均编码最短，被称为最优二叉树，有时又称为最佳编码。
Huffman编码过程 统计各个字符出现的频率 当谈到统计字符这里，经过了一番折腾后在这里我有很多想要总结的，对于数学专业的学生来讲我觉得这里是一个很难跨越的坎，为什么呢？原因在于这里涉及到计算机的储存原理，数据的读取，存储操作，这些操作都非常接近计算机底层，就拿数据的存储来说，首先我们要搞明白什么是ASCII文件，什么是二进制文件，这两类文件读取有什么差别，在计算机里又是如何存储的，这里参考网上博客的内容多多理解才好，这里我折腾了很久，首先搞明白ASCII和二进制文件这两个概念(概念很重要)，然后分析差别，最后学习C++提供的API，比较两者的不同。而我们数学院的同学接触计算机也不少，但是接触底层的人很少，所以当谈到一些数据结构、文件存储、硬件编程等等就会赶脚很无助，因为平时大家最多的就是用Matlab实现一些算法，对底层的接触的很少。当然Huffman算法也可以由Matlab来实现，我也看到网上有一些实例程序，但怎么说呢，如果用Matlab实现了Huffman我只能说，我学会了Huffman算法，但是不能说我学会了Huffman编码。因为数据编码这东西最直接联系的就是数据传输，我们需要知道计算机是怎样实现文件压缩、传输的过程的，就必须深入底层了解它的本质。
数据的本质：0和1
在我弄不明白Huffman编码的时候，我就问自己这样一个问题：Huffman编码是用来做什么的？信息论教科书上、数据结构教科书、各种Huffman编码的解释，Huffman 编码是一种编码方式，是一种用于无损数据压缩的熵编码（权编码）算法等等各种解释感觉很厉害的样子。听着好像懂了，但又好像没懂。但是一边看别人代码，一边写自己代码的过程，我变得有些心虚，心想我这是在做什么? 然后停下敲打键盘，想了一些问题。别担心，绝对不是高大上的问题，都是特别特别弱智的问题，我说的是特别，对，老师您没听错。
1. 什么是 ”编码” ? 是的没错，就是这么弱智的问题，学了这么久信息论、C语言和数据结构我的确问了自己一个这么弱智的问题。似乎很简单，但往往这么简单的问题我们都忽略去思考了，最后发现：哦，原来我一直干的是这样一件事。
2. 什么是ASCII编码？什么是ASCII编码，好像大家都知道到0的ASCII值是48，A打得ASCII值是65，即便不知道每一个字符的ASCII值，也知道在任何一本C语言教材的最后几页肯定有一张印有ASCII编码的。具体什么是ASCII我在这里就不介绍了，网上有很多解释，教科书也有很多，关键是理解。
3. Huffman为什么会出现？我觉的这个问题也弱智的很，但是这个问题在我写Huffman编码过程给了我很大的帮助。答案很简单：为了压缩数据。那么数据是什么？计算机里数据的本质就是0和1，那么怎么压缩0和1？当然0和1不能压缩，压缩的是0和1的组合。0和1的组合代表的是什么？ 组合代表的是信息，不同的组合代表不同的信息。回过头去想ASCII编码，ASCII是定长编码，原来Huffman编码实现的是传输同样信息的情况下，尽量使平均码长变得最小，这样就实现了数据压缩的目的。
回答完上面这些问题我才真正着手开始进行编程。
上面说道数据的读取和存储是一个很难绕过去的坎，那么到底怎么绕过去？刚开始我在纠结一个txt文档和mp4文件在数据读取时有什么不同吗？答案是：有。txt文档就是我们讲的ASCII文件，每8bit一个字符，而mp4文件本质上又是图像文件。这里真的很难绕过来，因为以前接触过的C语言API大部分是读取字符或字符串，很少用二进制的方式读取。但是当这样想后就明白了：所有文件在计算机里存储的都是0和1。编码的时候不用关心每个字符占多少bit，按照自己的编码方式编，只要能恢复0和1数据即可。所以，所有数据都通过二进制的方式读取，以二进制的方式存储，这样就没有必要担心文件类型所带来的困惑了。
具体字符统计这部分我写了一个count()函数。函数的输入是一个文件的地址，输出是文件中各个字符的统计向量。当然这个待压缩文件不能过大，因为通过读zip实现原理博客中我发现rar和zip等压缩软件之所以那么快是进行了很多优化，以我现在的时间和能力还搞不懂里面的一些东西，所以我写的代码运行很慢，但是结果是正确的，压缩效果也很好。函数具体的实现在后面算法和性能分析部分讲。
###　创建Huffman树(核心)
根据字符的频率按Huffman算法构建Huffman算法创建Huffman树
步骤如下：
为每个符号建立一个叶子节点，并加上其相应的发生频率当有一个以上的节点存在时，进行下列循环:
把这些节点作为带权值的二叉树的根节点，左右子树为空
选择两棵根结点权值最小的树作为左右子树构造一棵新的二叉树，且至新的二叉树的根结点的权值为其左右子树上根结点的权值之和。
把权值最小的两个根节点移除
将新的二叉树加入队列中。最后剩下的节点暨为根节点，存储为root节点，用于后面压缩编码操作。
树的建立过程是从叶子节点往上走，直到根节点。
建树过程如下图所示
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-MmzD5hDX-1584452720736)(http://picture.piggygaga.top/InformationTheory/second/CreateTRee.png “CreateHuffmanTree”)]
绿色椭圆表示叶子节点，棕色节点表示根节点，蓝色椭圆表示中间节点，首先从最底层的叶子节点开始创建树，然后向上走，建树过程中每次建完树的节点信息要从数组中删除节点信息，方便后面的建树操作。每次删除两个节点会建立一个新的合并节点，然后重新按频率从小到大排序，执行同样的操作直到最后剩下根节点，将根节点地址保存下来，在下一步压缩数据时使用。
经过此步骤，每个字符对应的Huffman编码都可以得到。我们可以将编码信息保存下来，类似ASCII编码表一样，我们把Huffman编码表也保存下来。 Huffman编码 根据Huffman 树实现编码并将编码结果和要编码的数据建立映射关系，存储的压缩文件需要添加头文件，用于解码使用。
重新从文件中读取信息，此时不需要进行统计字符频率，只需要在Huffman表中找到对应的Huffman编码然后将编码压入压缩文件中。
压缩文件包括两部分：头文件，数据部分。压缩文件的结构见下图
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-1oeNATPi-1584452720737)(http://picture.piggygaga.top/InformationTheory/second/Huffmanfile.PNG “压缩文件内容”)]
压缩数据首先以一个&gt;开始表示这是一个Huffman压缩数据，这样做的目的是在解压过程会判断这是否是一个Huffman编码文件，如果没有这个标识，认定该文件不具备Huffman编码文件的特性性，也就没有办法解压。第二部分是头文件，存储着字符频数，这样做也是为了解压方便，解压过程和压缩过程是两个独立的过程，将字符频数存进头文件，在解压时需要利用头文件字符频数重新建立一棵Huffman树，和压缩过程的操作过程是一样的。最后通过读取源文件的字符，在Huffman编码表中找到对应的字符编码，将字符编码压进数据部分，因为Huffman编码是异字头码，所以不需要做分隔，把所有数据压进去即可。
Huffman 解码 根据获取的Huffman码来逆向获取编码信息，而且从解压文件中一次性获取的数据是一个很长的字符串，这个串是压缩后的huffman编码，实际上是机器码。
解码过程
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-G3OeNeIZ-1584452720738)(http://picture.piggygaga.top/InformationTheory/second/decode.png “解码过程”)]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56cf972b93c3794454b02f172621e667/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d79ef7d1b2cf1dd60a688bf3b4056e8b/" rel="bookmark">
			Eclipse_SVN文件冲突、标记为合并
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 背景 公司使用Eclipse SVN 进行团队开发，但是在开发中我和同事（代号T）都对同一个版本号的文件（代号F）进行了更改，假设这个版本号为6（可以看做F6），那么同事T提交了他更改后的版本（F7），也就是资源库中F6被F7覆盖了。此时，恰巧你也对这个文件F6进行了更改，同步资源库后就会出现文件冲突。
2. 解决方案_A 如果这个文件中，我和同事改动的不是同一个位置，那么SVN会将你们的改动合并。 步骤： &lt;1&gt;那么我们直接进行点击【更新】（update），将服务器上的改动更新到本地。 &lt;2&gt;点击【提交】，将你们合并后的文件上传到服务器。
3. 解决方案_B 如果在这个文件中，我和同事修改的是同一个地方，我们可以做出选择，保留同事的F7或者是保留自己的F7。 步骤： &lt;1&gt;选择舍弃自己的更改。选择关联菜单中的【覆盖/更新】，然后Eclipse问询问你”是否删除本地更改，并替换为资源库中的文件？”点击【Yes】便可。 &lt;2&gt;选择保留自己的更改。直接提交，覆盖同事的更改，请谨慎。
4. 解决方案_C-标记为合并 如果我们修改的地方和同事上传到资源库的文件F7，各有取舍，这时候可以使用这个解决方案。 步骤： &lt;1&gt;将冲突文件标记为合并，然后对本地文件F7进行编辑，这边有两个按钮功能可以使用，具体使用看下图。 &lt;2&gt;修改好之后，点击【更新】，将本地文件F7上传到资源库中。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/363d590a76b7f381c71ab62a8a0810ad/" rel="bookmark">
			程序员真的适合跑步健身吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击查看全文
相信大家已经注意到了，程序员的大部分时间都花在电脑桌前编程，这会损害程序员的健康。其实不需要多么复杂的养生，你只需每天做一些小小的改变，就可以摆脱病痛、保持健康。
变换姿势 虽然站立桌、昂贵的椅子和一些基于人体工程学的玩意的确很酷，哪怕LINUS（linux创始人）都在踏步机前工作，而事实上你并不需要这些。
关键是要变换姿势，如果你保持一个姿势数个小时不活动，你的脖子在数天后疼痛是必然的。每15分钟站起、坐下、跳、蹲下、活动一下手脚、放松一下眼睛；每小时变换一下姿势；每天走一走，爬一些楼梯，保证你的健康会得到很大的改善，关节的僵硬和肌肉的疼痛都会得到缓解。
锻炼 锻炼是改善健康最好的方法之一，但是必须用正确的方法锻炼。首先要确保不要在无用的事情上浪费时间。
不要跑步 跑步被广泛当作一种锻炼方式，其实并不适用于所有人。在决定通过跑步来锻炼以前，你需要确认两件事情：
1、你的身体状态足以满足跑步锻炼所需，一个严酷的事实是大部分程序员达不到跑步锻炼所需的身体条件（对胖程序猿来说，跑步极有可能会损伤膝关节）。
2、跑步锻炼需要掌握正确的跑步姿势和跑步方法。
不要到健身房健身 高强度的健身方式适用于有意保持健美外形或有意取得某种特定目标的职业人士。通常，高强度训练不适合程序员们。
我们都有自己的职业目标和适合自己的使命，所以就不要玩健身了嘛。没有效果，太多疼痛和受伤。健康的程序员不需要高强度健身。
应该步行健身 步行比跑步和其他的方式更好。步行简单、安全而且有效。我每天步行5-10公里，这个习惯给我的健康带来很大的改善。请买双薄鞋底的好鞋子（仔细看好，不要买仿制经典篮球鞋）开始步行锻炼吧！
如果感到太单调，跑步时可听电子书或者播客。边学习边锻炼，多么充实！
睡眠 最后是优质睡眠。大家知道，但却实践的少。使你自己在一个结实的床垫上度过一整晚。不要在晚上还盯着电脑或者手机和平板，至少保证睡前一小时不使用这些电子产品。10点上床，6点半起床，你就是个快乐程序员！
现实是，程序员们花了太多时间坐在电脑前，可能都忘记怎么运动了。建议从头开始，但不需要任何额外的器材，你只需要在视频网站上搜索运动操视频，然后跟着一起运动即可。
你跑步吗？你觉得跑步真的适合程序员吗？ 你觉得什么样的运动方式才适合码农？ 你买过什么高科技健身好物嚒？ 对于程序猿群体，如果不锻炼，面临最严肃的健康问题是什么？ 点击查看全文
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fcc63f71e926912a5994a86418b8309/" rel="bookmark">
			登录界面如何实现记住用户名和密码 且实现自动登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在一次练习中遇到了一个问题，如何在登录界面实现记住用户名和密码，并且可以进行勾选是否自动登录。
首先，给大家看下我的登陆界面。
很显然，我布置了checkbox，一个用于记住密码，一个用于自动登录。
&lt;label&gt; &lt;input type="checkbox" name="autoLogin" id = "autoLogin"&gt; 自动登录 &lt;/label&gt; &lt;label&gt; &lt;input type="checkbox" name="rememberMe" id = "rememberMe"&gt; 记住密码 &lt;/label&gt; 接下来就是如何对这两个按钮进行触发操作了，我主要是利用了jquery.cookie.js来进行的操作。这个需要自己去下载，然后引进。
//记住用户名密码 function Save() { if ($("#rememberMe").prop("checked")) { var str_username = $("#NameText").val();//用户名 var str_password = $("#inputPassword").val();//密码 $.cookie("rmbUser", "true", { expires: 7 }); //存储一个带7天期限的cookie $.cookie("username", str_username, { expires: 7 }); $.cookie("password", str_password, { expires: 7 }); } else { $.cookie("rmbUser", "false", { expire: -1 }); $.cookie("username", "", { expires: -1 }); $.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fcc63f71e926912a5994a86418b8309/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3e6cd8cffcc4daae409240571879695/" rel="bookmark">
			android studio 模拟器 开机提示 需要输入密码 To start Android,enter your password
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如今，谷歌的模拟器开机速度已经比真机还要快，虽然并不推荐使用模拟器测试(国内那些坑爹的乱改api并且还有bug就不多说了)，但手机毕竟成本高,而且还有限，对于前期开发测试还是必不可少的了。
这不，几个月前（郁闷了几个月啊?）由公司的mac本（mac本请忽略本文）换成了window本，然后就是
试了万种方法，最后只能用5.0系统测试了（6.0及以上永远都是这样）。
今日，幸得一大神点拨，顿悟之（要升仙喽?），记之以惠万民。 这个问题的根本原因是image错了，嫑下载Google开头的。
打开android studio的模拟器对话框
也可以到device manager 中下载
最后忠告大家一句:在天朝，不要试图下载Google、Google Apis相关的任何内容
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b0020d54c23f699bb09d524f9c8a0f3/" rel="bookmark">
			Ubuntu 16.04 Kernel Crash Dump
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		﻿﻿ Ubuntu 16.04 Kernel Crash Dump
1. apt install linux-crashdump
2. /etc/default/kdump-tools by including the following line: USE_KDUMP=1
3. kdump-config show
DUMP_MODE: kdump
USE_KDUMP: 1
KDUMP_SYSCTL: kernel.panic_on_oops=1
KDUMP_COREDIR: /var/crash
crashkernel addr: 0x2b000000
/var/lib/kdump/vmlinuz: symbolic link to /boot/vmlinuz-4.4.0-89-generic
kdump initrd:
/var/lib/kdump/initrd.img: symbolic link to /var/lib/kdump/initrd.img-4.4.0-89-generic
current state: ready to kdump
kexec command:
/sbin/kexec -p --command-line="BOOT_IMAGE=/boot/vmlinuz-4.4.0-89-generic root=UUID=505002b4-e453-4e7c-9eb5-a9af5ccf1391 ro irqpoll nr_cpus=1 nousb systemd.unit=kdump-tools.service" --initrd=/var/lib/kdump/initrd.img /var/lib/kdump/vmlinuz
4. cat /proc/cmdline
BOOT_IMAGE=/boot/vmlinuz-4.4.0-89-generic root=UUID=505002b4-e453-4e7c-9eb5-a9af5ccf1391 ro crashkernel=384M-:128M
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b0020d54c23f699bb09d524f9c8a0f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f266266d3b8e74dfbc02cc764e6997f0/" rel="bookmark">
			一起来读Greenplum/Deepgreen执行计划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击查看全文
日常SQL优化过程中，最好用的手段就是通过执行计划。在Greenplum和Deepgreen中，运行 EXPLAIN 后产生的执行计划呈树状，这棵树的每一个分叉，都代表了一个单独的数据库操作，例如：表扫描、表连接、聚合、排序。
日常SQL优化过程中，最好用的手段就是通过执行计划。在Greenplum和Deepgreen中，运行 EXPLAIN 后产生的执行计划呈树状，这棵树的每一个分叉，都代表了一个单独的数据库操作，例如：表扫描、表连接、聚合、排序。
由于返回数据行数是从下向上传递的，所以我们在分析执行计划时，也应该自下而上。通常来说，最底下的是表扫描操作（索引、位图索引扫描）。如果查询中涉及到连接、聚合、排序操作，那么表扫描动作的上层就会有对应的这些操作。通常最顶上的部分是节点间数据移动（重分布、广播、聚集操作），在查询过程中，这些操作会涉及到在节点间移动数据。
EXPLAIN 执行计划中，每一个单独的步骤都会呈现在单独一行里，带有对应的动作类型及查询数据所耗费的时间（查询首行所用时间..查询全部所用时间）：
1.cost Cost以磁盘页读取为测量单位，1.0等同于一个顺序的磁盘页读取。第一个预估时间是起始消耗，即查询首行所消耗的时间，第二个预估值是总消耗，即查询全部行所用的时间。
2.rows rows指的是执行计划某部分返回的总行数。这个数量通常少于实际的返回行数，反应的只是一个预估的数量。最顶层的返回的预估数量最接近实际查询、修改或删除影响的行数。
3.width 操作返回的所有数据所占用的字节数。
很重要的一点是，上层节点所花费的时间包括所以子节点占用时间，计划最顶层包含总执行花费的预估，这也是我们追求优化的部分。另外执行计划的消耗只与执行计划本身关心的步骤有关，与查询结果传输到客户端的消耗时间等因素无关。
点击查看全文
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1a2e3a104d54ed5e41b8dedd29e6259/" rel="bookmark">
			C语言之函数篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数(function)是用于完成特定任务的程序代码的自包含单元。 为什么要使用函数？第一，函数的使用可以省去重复代码的编写。如果程序中需要多次使用某种特定的功能，那么只需编写一个合适的函数即可。第二，即使某种功能在程序中只使用一次，将其以函数的形式实现也是有必要的，因为这使程序更加模块化，从而有利于程序的阅读、修改和完善。 可以把函数看作“黑盒子”，即对一定的输入会产生特定的结果或返回某个数值，而黑盒子的内部行为并不需要考虑，除非是该函数的编写者(相对于函数的使用者)。例如，使用printf()函数时，只需向其传递一个控制字符串，或许还有其他一些参数，然后就可以预测到printf()的执行结果，而无需了解printf()的内部代码。以这种方式看待函数有助于把精力投入到程序整体设计而不是其实现细节。因此，编写函数代码之前首先需要考虑的是函数的功能以及函数和程序整体上的关系。
带有参数的函数
假设有如下函数原型：
void my_func(int n);
上述函数原型表明my_func()接受一个int类型的参数。声明一个参数就创建了一个被称为形式参数的变量。本例中，形式参数是叫做n的int类型变量。像my_func(10)这样的函数调用会把10赋给n。称函数调用传递一个值，这个值被称为实际参数。因此，函数调用my_func(10)把实际参数10传递给函数，然后函数把10赋给形式参数n。
函数中的变量名字是局部的。这意味着在一个函数里定义的名字不会与其他地方相同的名字发生冲突。
如同函数内部定义的变量一样，形式参量是局部变量，它们是函数所私有的。
函数原型中可以省略变量名。在原型中使用变量名并没有实际地创建变量。
#include &lt;stdio.h&gt;
int main(void)
{
const float MIN = 0.0f;
const float MAX = 100.0f;
float score;
float total = 0.0f;
int n = 0;
float min = MAX;
float max = MIN;
printf("Enter the first score (q to quit): ");
while (scanf("%f", &amp;score) == 1)
{
// 筛选无效的分数
if (score &lt; MIN || score &gt; MAX)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1a2e3a104d54ed5e41b8dedd29e6259/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37e2d25b1a402141d70af5f55f2b9d81/" rel="bookmark">
			HQL查询条件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在HQL中可以使用表达式完成指定的运算或者作为限制查询结果的条件。 要注意HQL与SQL的区别如： SQL:select(*) from Student where name=?,pwd=? HQL:from Student where name=:name and pwd=:pwd 主要逻辑运算符如下表所示
|———————————————————–|
类别运算符逻辑运算符or、and及not数学运算符+、-、*、/=、&lt;&gt;、!=、&lt;、&gt;、&lt;=、&gt;=、like、not like、between、not between比较运算符in、not in、is null、is not null、is empty、is not empty、member of、not member of字符串连接分支选择case及case…when…then…else….end集合运算some、exists、all、any 1、where子句
在HQL中使用where子句来限定查询条件，该子句后跟表示限定查询条件的表达式。如：
Query query = session.createQuery(“from Guestbook where name = ‘XXX’”);
2、between子句
在HQL的where子句中使用between可以返回属性值在指定范围之内的记录。如：
Query query = session.createQuery(“from Guestbook where id between 1 and 10”);
3、not between子句
在HQL中的where子句使用not between可以返回属性值不在指定范围之内的记录。如：
Query query = session.createQuery(“from Guestbook where id not between 1 and 10”);
4、in子句
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37e2d25b1a402141d70af5f55f2b9d81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0934a2bdc9e1894ca5a215da3e256a6/" rel="bookmark">
			html中a标签点击状态失效（覆盖）——link,visited,hover,active的顺序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 html中，&lt;a&gt; 标签的点击事件有四个状态，分别是link、visited、hover、active，如果同时设置多个状态的显示且不按照一定状态的话，就会让一些效果被覆盖了。
下面放一段错误代码，先设置hover，再设置visited，会发现当鼠标移上去后a的颜色还是白色（#fff），而不是想要的#f0a986，即a的hover的样式被visited的覆盖了。
a:hover{ color: #f0a986; text-decoration: none; } a:visited{ color:#fff; text-decoration: none; } 正确的顺序应该是：
link→visited→hover→active a:link：未访问时的样式，一般省略成a a:visited：已经访问后的样式 a:hover：鼠标移上去时的样式 a:active：鼠标按下时的样式
欢迎大家加入QQ群一起交流讨论， 「吟游」程序人生——YinyouPoet 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66a2054274de464cf36c0590f290285b/" rel="bookmark">
			java.io.EOFException: Unexpected end of ZLIB input stream解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EOFException 表示异常文件结尾，说明读取的数据是不完整的。我在线上就遇到过类似的问题，在请求高峰时期就抛出了这个异常。下面是我的代码：
FileOutputStream fileOutputStream = null; try { //得到文件 File file = new File(fileName); fileOutputStream = new FileOutputStream(file); IOUtils.write(dataByte, fileOutputStream); // 在这里及时的close掉fileOutputStream //读取图片 BufferedImage bi = ImageIO.read(file); pictureProcessVo.setWidth(bi.getWidth()); //获得 宽度 pictureProcessVo.setHeight(bi.getHeight()); //获得 高度 // other operation // delete file FileUtils.deleteQuietly(file); } catch (Exception e) { LOGGER.error("get pic width and height error", e); } finally { IOUtils.closeQuietly(fileOutputStream); } 出现的异常： javax.imageio.IIOException: Error reading PNG image data at com.sun.imageio.plugins.png.PNGImageReader.readImage(PNGImageReader.java:1345) at com.sun.imageio.plugins.png.PNGImageReader.read(PNGImageReader.java:1614) at javax.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66a2054274de464cf36c0590f290285b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/957ac6c80295a11051576890cf607dc4/" rel="bookmark">
			windows 搭建Git服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境：windows10 gitblit1.8 jdk8
官网下载jdk8 和 gitblit gitblit1.8 提取码：pyp7
万事具备只欠东风。
1. 安装 jdk 从无到有_之JAVA基本开发环境搭建
2. 解压gitblit压缩包到任意目录，进入data目录编辑 defaults文件（早些版本是直接编辑gitblit文件的），实质还是配置gitblit文件，看gitblit文件内容就秒懂了。
3. 找到git.repositoriesFolder 设置git.repositoriesFolder=你的文件夹 （如F:/data/GitRepository）
找到server.httpPort 设置 server.httpPort=10101
找到server.httpBindInterface 设置server.httpBindInterface=你的ip (如192.168.0.103)
找到server.httpsBindInterface设置server.httpsBindInterface=localhost
4. 配置gitblit为windos服务，修改安装目录下的installService文件 （启动服务的时候有点问题，此处只记录带以后解决，你可以跳过这步，后面不受影响）
32位系统ARCH=x86 64位系统ARCH=amd64，修改完后双击执行（管理员帐号）。
成功后，win+r 运行services.msc可看到下图
5 测试
在gitblit安装目录找到gitblit并双击启动（管理远帐号），启动成功如下图，在浏览器中输入http://192.168.0.103:10101
以上整个git服务器搭建完毕，下面内容是使用这个服务器管理一个项目Demo。通过下面内容希望能对git的原理有更深入的理解。
gitblit默认管理员帐号/密码是admin/admin
1. 创建服务端版本库
登录后选择版本库--》创建版本库 里面的东西都很好懂，就不多说了。勾选加入.gitignore选项后，下面的下拉框要学东西。别的也没什么，然后点击创建就O了
看到熟悉的连接了吧，没错那就是远程仓库。默认显示ssh:// 还是http://是可以在用户中心个人偏好里设置的。
好了用git在本地clone一份吧（git的安装就不介绍好了，也是傻瓜式安装）。
打开服务端的.git文件可以发现里面仅仅记录这项目相关的版本信息，并没包含实际的项目。
所以部署一个项目到git服务器上的思路应该是：
1. 创建远程仓库
2. 本地拉取
3.本地提交项目（直接把项目考到对应的目录，如testDemo目录，然后右键add to index--&gt;commit--&gt;push）
而不是想着把一个项目直接放到远程仓库里。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00165228be5d1fd87569e9f8efb4340d/" rel="bookmark">
			data类型的Url格式--url(data:image/gif;base64,AAAA)：把小数据直接嵌入到Url中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		所谓”data”类型的Url格式，是在RFC2397中提出的，目的对于一些“小”的数据，可以在网页中直接嵌入，而不是从外部文件载入。例如对于img这个Tag，哪怕这个图片非常非常的小，小到只有一个点，也是要从另外一个外部的图片文件例如gif文件中读入的，如果浏览器实现了data类型的Url格式，这个文件就可以直接从页面文件内部读入了。
data类型的Url格式早在1998年就提出了，时至今日，Firfox、Opera、Safari和Konqueror这些浏览器都已经支持，但是IE直到7.0版本都还没有支持，IE不支持的东西太多了，也不差这一个。:(
小例子 下面这个html代码可以在支持data类型Url的浏览器中运行，例如Firefox。运行后会看到一条蓝色渐变底色的标题。
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; &lt;html xmlns="http://www.w3.org/1999/xhtml" &gt; &lt;head&gt; &lt;style type="text/css"&gt; .title { background-image:url(data:image/gif;base64,R0lGODlhAQAcALMAAMXh96HR97XZ98Hf98Xg97DX97nb98Lf97vc98Tg973d96rU97ba97%2Fe96XS9wAAACH5BAAAAAAALAAAAAABABwAAAQVMLhVBDNItXESAURyDI2CGIxQLE4EADs%3D); background-repeat:repeat-x; height:28px; line-height: 28px; text-align:center; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div &gt;Hello, world!&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 这个渐变的蓝色底色实际上是用一个1x28的小图片通过横行重复(repeat-x)形成的。这个图片很小，不过104个字节，直接嵌入到html或css文件还是很合适的。
data格式的Url最直接的好处是，这些Url原本会引起一个新的网络访问，因为那里是一个网页的地址，现在不会有新的网络访问了，因为现在这里是网页的内容。这样做，会减少服务器的负载，当然同时也增加了当前网页的大小。所以对“小”数据特别有好处。
data类型Url的形式 既然是Url，当然也可以直接在浏览器的地址栏中输入。
data:text/html,
Hello, world!
在浏览器中输入以上的Url，会得到一个加粗的”Hello, world!”。也就是说，data:后面的数据直接用做网页的内容，而不是网页的地址。 简单的说，data类型的Url大致有下面几种形式。
data:,&lt;文本数据&gt; data:text/plain,&lt;文本数据&gt; data:text/html,&lt;HTML代码&gt; data:text/html;base64,&lt;base64编码的HTML代码&gt; data:text/css,&lt;CSS代码&gt; data:text/css;base64,&lt;base64编码的CSS代码&gt; data:text/javascript,&lt;Javascript代码&gt; data:text/javascript;base64,&lt;base64编码的Javascript代码&gt; data:image/gif;base64,base64编码的gif图片数据 data:image/png;base64,base64编码的png图片数据 data:image/jpeg;base64,base64编码的jpeg图片数据 data:image/x-icon;base64,base64编码的icon图片数据 因为Url是一种基于文本的协议，所以gif/png/jpeg这种二进制属于需要用base64进行编码。换句话说，引入base64以后，就可以支持任意形式的数据格式。下面是个png图片的例子，会在浏览器中显示一个Mozilla的图标。
data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAHWSURBVHjaYvz//z8DJQAggJiQOe/fv2fv7Oz8rays/N+VkfG/iYnJfyD/1+rVq7ffu3dPFpsBAAHEAHIBCJ85c8bN2Nj4vwsDw/8zQLwKiO8CcRoQu0DxqlWrdsHUwzBAAIGJmTNnPgYa9j8UqhFElwPxf2MIDeIrKSn9FwSJoRkAEEAM0DD4DzMAyPi/G+QKY4hh5WAXGf8PDQ0FGwJ22d27CjADAAIIrLmjo+MXA9R2kAHvGBA2wwx6B8W7od6CeQcggKCmCEL8bgwxYCbUIGTDVkHDBia+CuotgACCueD3TDQN75D4xmAvCoK9ARMHBzAw0AECiBHkAlC0Mdy7x9ABNA3obAZXIAa6iKEcGlMVQHwWyjYuL2d4v2cPg8vZswx7gHyAAAK7AOif7SAbOqCmn4Ha3AHFsIDtgPq/vLz8P4MSkJ2W9h8ggBjevXvHDo4FQUQg/kdypqCg4H8lUIACnQ/SOBMYI8bAsAJFPcj1AAEEjwVQqLpAbXmH5BJjqI0gi9DTAAgDBBCcAVLkgmQ7yKCZxpCQxqUZhAECCJ4XgMl493ug21ZD+aDAXH0WLM4A9MZPXJkJIIAwTAR5pQMalaCABQUULttBGCCAGCnNzgABBgAMJ5THwGvJLAAAAABJRU5ErkJggg== data格式Url的种种应用举例 可以在Html的Img对象中使用，例如
&lt;img src="data:image/x-icon;base64,AAABAAEAEBAAAAAAAABoBQAAF..." /&gt; 可以在Css的background-image属性中使用，例如
div.image { width:100px; height:100px; background-image:url(data:image/x-icon;base64,AAABAAEAEBAAAAAAAABoBQAAF.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00165228be5d1fd87569e9f8efb4340d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e87e49f82d889a7d9ed9fc4406bad99/" rel="bookmark">
			JavaEE大型分布式电商项目 上海淘淘商城 29期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上海29期_张志君老师_淘淘商城_大型分布式电商项目
JavaEE大型分布式电商项目 淘淘商城 29期
需要的加qq：350226234，备注：程序员学习视频
===================================================================
淘淘商城是一个综合性的B2C平台，类似与京东、天猫商城，其打造的是商业模式为“社区+电子商务”， 用户不只是在社区中有自己的圈子，还可以将电商加入到社区中，整个电商网站实现的功能非常之多，采用分布式的系统架构设计，包括后台管理、前台系统、购物车系统、订单系统、单点登录系统、搜索系统、会员系统等。
1、 该项目采用了分布式系统的架构，目前，在大型网站中使用非常广泛。
2、 各个系统之间采用接口调用的方式进行交互，即：面向服务的开发，每个团队、系统，分工明确，各司其职。
3、 后台系统使用了目前主流的框架技术，Spring、SpringMVC、Mybatis实现，开发更有效率，网站性能更高。
4、 后台系统中的前端UI采用了jQuery EasyUI完成，界面更加的美观。
5、 系统后台使用多级菜单布局,并使用KindEditor框架作为富文本编辑器。
6、 前台系统中采用CSS+DIV技术开发界面，使用jquery完成和动态效果和后台服务的数据交互。
7、 项目引入了内容关系系统的概念，实现了对网站大部分内容的管理维护，使开发更加的高效。
8、 使用单点登录系统（SSO）来实现集群状态下的用户数据的维护。
9、 使用高性能的KV数据库Redis完成数据的存储以及缓存，提高数网站整体的性能。
10、 使用企业级开源系统Solr完成商品以及订单数据的搜索。
11、 在数据库存储方面使用MySQL的主从复制架构，使用Spring的AOP实现数据的读写分离，以保证在“读多写少”的场景下的高性能。
12、 使用高性能的企业级消息系统RabbitMQ，完了系统间的通信，使得系统间的耦合度大大降低。
13、 部署方面使用LVS + keepalived + Nginx实现了双机主备、双主热备，实现了一个高可用的系统架构。
14、 项目开发采用团队式的开发，统一使用Maven私服构建项目，使用统一的SVN服务进行代码的管理。
【课程内容】
项目功能实现分析
RESTful Web Service、SVN
项目讲解、环境搭建
后台系统功能实现
前台系统搭建、实现、内容管理系统实现
redis入门
单点登录系统
订单系统、Quartz入门
Solr入门以及搜索系统实现
MQ学习、改造搜索、商品详情缓存逻辑
实现购物车、读写分离
dubbo入门、优化单点登录系统
分布式部署架构讲解以及实施
分组实战 + 项目总结以及就业指导
拔高--Redis集群、Tomcat优化、mysql优化
详细目录
├─课前资料 │ ├─day01（RESTful Web Service、SVN） │ │ │ Maven相关问题解决.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e87e49f82d889a7d9ed9fc4406bad99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0108c3fabb4e2bc79c0454815167ae4a/" rel="bookmark">
			为图像添加椒盐噪声和高斯噪声
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://blog.csdn.net/qq_34784753/article/details/69379135
下面简单介绍两种图像噪声，即椒盐噪声和高斯噪声。
1.椒盐噪声
椒盐噪声也称为脉冲噪声，是图像中经常见到的一种噪声，它是一种随机出现的白点或者黑点，可能是亮的区域有黑色像素或是在暗的区域有白色像素（或是两者皆有）。盐和胡椒噪声的成因可能是影像讯号受到突如其来的强烈干扰而产生、类比数位转换器或位元传输错误等。例如失效的感应器导致像素值为最小值，饱和的感应器导致像素值为最大值。图像模拟添加椒盐噪声是通过随机获取像素点并设置为高亮度点和低灰度点来实现的
2.高斯噪声
高斯噪声是指高绿密度函数服从高斯分布的一类噪声。特别的，如果一个噪声，它的幅度分布服从高斯分布，而它的功率谱密度有事均匀分布的，则称这个噪声为高斯白噪声。高斯白噪声二阶矩不相关，一阶矩为常数，是指先后信号在时间上的相关性。高斯噪声包括热噪声和三里噪声。高斯噪声万有由它的事变平均值和两瞬时的协方差函数来确定，若噪声是平稳的，则平均值与时间无关，而协方差函数则变成仅和所考虑的两瞬时之差有关的相关函数，在意义上它等同于功率谱密度。高斯早生可以用大量独立的脉冲产生，从而在任何有限时间间隔内，这些脉冲中的每一个买充值与所有脉冲值得总和相比都可忽略不计。
根据Box-Muller变换原理，建设随机变量U1、U2来自独立的处于(0,1)之间的均匀分布，则经过下面两个式子产生的随机变量Z0，Z1服从标准高斯分布。
上式中Z0，Z1满足正态分布，其中均值为0，方差为1，变量U1和U2可以修改为下式：
给图像添加两种噪声的程序如下：
#include &lt;cstdlib&gt; #include &lt;iostream&gt; #include &lt;opencv2\core\core.hpp&gt; #include &lt;opencv2\highgui\highgui.hpp&gt; #include &lt;opencv2\imgproc\imgproc.hpp&gt; using namespace cv; using namespace std; double generateGaussianNoise(double m, double sigma); Mat addSaltNoise(const Mat srcImage, int n); Mat addGaussianNoise(Mat &amp;srcImag); int main() { Mat srcImage = imread("imL.png"); if (!srcImage.data) { cout &lt;&lt; "读入图像有误！" &lt;&lt; endl; system("pause"); return -1; } imshow("原图像", srcImage); Mat dstImage1 = addSaltNoise(srcImage, 3000); Mat dstImage2 = addGaussianNoise(srcImage); imshow("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0108c3fabb4e2bc79c0454815167ae4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d1d21979285ef0f4342e0ff5aca2715/" rel="bookmark">
			Gradle刷新异常及解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.问题描述
gradle刷新时长时间无法完成刷新，点击停止报错如下:
Error:Could not run build action using Gradle distribution 'https://services.gradle.org/distributions/gradle-x.x-*.zip'. 2.解决方案
Windows环境下找到目录 C:\Users\用户名.gradle\wrapper\dists\gradle-x.x-* 清空文件夹（可能需要关闭IDEA），重新刷新gradle，等待idea重新下载即可，此过程可能耗时较长。 Tip：在操作中可能遇到刷新失败的情况，需要先执行 gradle clean 命令，再刷新。
3.GRADLE配置
坐标 –&gt; 项目根目录\gradle\wrapper\gradle-wrapper.properties 该配置如下：
distributionBase=GRADLE_USER_HOME distributionPath=wrapper/dists zipStoreBase=GRADLE_USER_HOME zipStorePath=wrapper/dists distributionUrl=https\://services.gradle.org/distributions/gradle-x.x-*.zip 配置项含义 distributionBase : 解压gradle-x.x-*.zip文件存放位置; distributionPath : distributionBase指定目录下的子目录; zipStoreBase : 下载gradle-x.x-*.zip文件存放位置; zipStorePath : zipStoreBase指定目录下的子目录; distributionUrl : gradle包下载地址(包含版本号);
GRADLE_USER_HOME为用户目录： (1) 在Windows下 –&gt; %USERPROFILE%/.gradle (2) 在Linux下 –&gt; $HOME/.gradle
GRADLE的3种版本： (1) gradle-xx-all.zip是完整版，包含了各种二进制文件，源代码文件，和离线的文档。 (2) gradle-xx-bin.zip是二进制版，只包含了二进制文件（可执行文件），没有文档和源代码。 (3) gradle-xx-src.zip是源码版，只包含了Gradle源代码，不能用来编译你的工程。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4375646e25fb0564468aa0e89cbc90c/" rel="bookmark">
			Event事件处理机制和原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一）事件处理机制的原理 事件模型定义了一套标准的生成和处理事件消息的方法，使程序中的对象可以相互交互、通信、保持自身状态和相应变化。简单的说，数据的提供者只管发出数据对象，只要确保数据对象是 Event类或者子类的实例即可。
这种数据对象，称为事件（Event）。数据对象的发出者，称之为事件发送者（Event dispatcher）。同时，接受事件的对象，称为 事件侦听者（Event listener)。
我们来看一个简单的例子。
当我们想要和男（女）朋友约会的时候，我们通常都会有一个约会的发起者，同时还有个一个约会对象。那么在这个邀请过程中，就是一个很好的事件过程。
这个过程请见下图：
男朋友是事件发送者，邀请约会就是男朋友发送的事件。而女朋友就是事件侦听器。
这个事件，包含三条主要内容：事件的类型，事件的目标，事件的相关数据。事件的类型就是邀请约会，女朋友会根据事件的不同，来执行不同的任务。比如，事件是“邀请约会”，那么女朋友可能会执行，梳妆打扮，然后赴约。如果事件是“肚子饿了”，那么女朋友会执行买菜做饭。
事件的目标，就是事件的发送者。如果没有这个信息，那么女朋友接到事件后，就无法知道是谁要约她，或者是谁饿了。
事件的数据，就是事件所要包含的信息。上面的约会事件中，事件的信息可以包括事件，地点，干什么。同理，“肚子饿了”这个事件，要包含的信息是想吃些什么，在家里吃还是去外面吃等等。当然，也有一些事件是不包含信息的，例如“捶背”，事件接受者只要收到这个事件，直接执行就可以了。
二） 事件执行流程 事件机制包含4个步骤：注册侦听器，发送事件，侦听事件，移除侦听器。这四个步骤是按照顺序来执行的。
注册侦听器，即指定事件由哪个对象的哪个方法来接受。在上一节约会的例子中，我们指定由男朋友来发送事件，由女朋友来接受事件。
只有在注册侦听器后，发送的事件才能被侦听。而且发送的事件必须和侦听器事件的类型匹配。在发送事件后，侦听器才能侦听到事件。
三）Event类 Event类是所有事件类的基类。当你你要创建一个自定义事件的时候，事件应该继承自Event类。同时Event类也包含一些事件。这些事件通常与显示列表，显示对象的状态有关。
在使用Event类时，有几个属性与方法需要我们注意。
首先是构造函数中的三个参数：type、bubbles和cancelable。
1）type指定我们事件的类型，在“约会”的例子中，我们的type事件类型为“DATE”。我们经常使用的事件类型有“ADDED”、“COMPLETE”等。
2）bubbles是指定事件是否参与事件流的冒泡阶段，关于事件流，会在后面的小节中介绍。
3）cancelable表示是否要取消Event对象。
另外还需要关注的属性就是target，这个属性表示事件的目标，也就是事件的发送者。其他的一些方法都与事件流有关，后面的内容会进行详细介绍。
四）事件侦听器 事件侦听器也就是事件的处理者，负责接收事件携带的信息，并在接收到该事件后执行特定的代码。
常见Event事件的侦听器必须是一个函数。事件的发送者必须是 EventDispather类或者子类的实例。只有事件发送者才能侦听事件，并且可以注册侦听器。
侦听事件分为两个部分，第一是建立侦听器，侦听器可以是独立的函数，也可以是某一个对象的方法。第二步是注册侦听器，使用事件发送者的 addEventDispather将相应的事件分配给侦听器。
对于注册侦听函数的定义。我们常用的只有三个参数：
1）第一个参数type表示事件类型。
2）listener就是用来处理事件的侦听器。
3）thisObject比较特殊，一般我们填写this。
五）创建侦听器 一个侦听器必须是函数，它可以是一个独立函数，也可以是一个实例的方法。侦听器必须有一个参数，并且这个参数必须是 Event类实例或其子类的实例，同时，侦听器的返回值必须为空（void）。范例代码如下：
listenerName(evt:Event):void{...}
六）注册侦听器与移除侦听器 只有事件的发送者才可以注册侦听器，事件的发送者必须是 EventDispatcher类或其子类的实例。移除侦听器也同理，通常情况下，注册侦听器与移除侦听器都是成对出现。
注册侦听器
事件发送者.addEventListener(事件类型,侦听器, this);
移除侦听器
事件发送者.removeEventListener(事件类型,侦听器, this);
七）检测侦听器 如果你需要在逻辑中检测某一个事件发送者是否注册了侦听器，那么你有两个方法可以使用。一个是 hasEventListener ,另外一个是willTrigger 。两个方法执行效果相同，都是判断一个事件发送者是否注册了某一个类型的事件。
如果该事件类型已经被注册过，返回 true，如果没有被注册过，返回 false。
事件发送者.hasEventListener(事件类型);
八）TouchEvent的启动开关 TouchEvent的启动开关 touchEnabled 指定此对象是否接收触摸或其他用户输入。默认值为 true，这表示默认情况下，显示列表上的任何 DisplayObject实例都会接收触摸事件或其他用户输入事件。如果将 touchEnabled设置为false，则实例将不接收任何触摸事件（或其他用户输入事件）。显示列表上的该实例的任何子级都不会受到影响。要更改显示列表上对象的所有子级的 touchEnabled行为，请使用 DisplayObjectContainer.touchChildren。
实际使用过程，如果某些显示对象不再需要侦听TouchEvent，那就及时关闭吧：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4375646e25fb0564468aa0e89cbc90c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed8fe66cb7212113c629d9648e16d07e/" rel="bookmark">
			模拟器安装搜狗输入法apk
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我将sougou.apk放入到f盘中
启动模拟器，打开cmd，输入 adb install f:\sougou.apk
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ca58e83741c95d46e9f96f7ba241d6c/" rel="bookmark">
			python3 TypeError: unhashable type set解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TypeError: unhashable type set
错误提示：set不可被哈希
同种问题还有“TypeError: unhashable type list”、“TypeError: unhashable type dict”。出现这种异常通常是因为在使用set()过程中，set()传递进来的不是可哈希的元素。
一旦出现可迭代对象所存储的元素不可哈希，就会抛出TypeError: unhashable type set/list/dict 类似错误。
遇上“TypeError: unhashable type set”如何解决？
将
self.manager.add_new_url(new_urls) 修改为：
for ele in new_urls: self.manager.add_new_url(ele) 即可。
那么哪些是可哈希元素？哪些是不可哈希元素？
可哈希的元素有：int、float、str、tuple
不可哈希的元素有：list、set、dict
为什么 list 是不可哈希的，而 tuple 是可哈希的
（1）因为 list 是可变的在它的生命期内，你可以在任意时间改变其内的元素值。
（2）所谓元素可不可哈希，意味着是否使用 hash 进行索引
（3）list 不使用 hash 进行元素的索引，自然它对存储的元素有可哈希的要求；而 set 使用 hash 值进行索引。
参考：http://blog.csdn.net/lanchunh...
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d06f39820d3433ad8b96608c86b1d241/" rel="bookmark">
			Firefox 版本 52（计划于 2017 年 3 月发布）开始，Firefox 将停止支持浏览器支持插件的标准方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在使用firefox的时候，发生了很多问题。无法加载Java插件等。
在访问Windows的java时候(Version 8 Update 144)，弹出提示信息
安装 Java 之后，Java 插件在 Firefox 中不工作 本文适用于: 浏览器: Firefox Java 版本: 7.0, 8.0 Firefox 限制 NPAPI 支持（Java 小应用程序需要用到这项技术） 64 位 Firefox 64 位版本的 Firefox 不支持 NPAPI 插件，包括 Java。
Firefox 52 及更高版本 从 Firefox 52（于 2017 年 3 月发行）开始，仅支持 Adobe Flash 插件，将不再支持 NPAPI，这会影响用于 Java 的插件、用于 Silverlight 的插件和其他基于 NPAPI 的类似插件。
如果您在使用 Firefox 访问 Java 应用程序时遇到问题，Oracle 建议您改为使用 Internet Explorer (Windows) 或 Safari (Mac OS X)。开发人员和系统管理员如果在寻求支持 Firefox 用户的替代方法，请查看此有关启动 Web Start 应用程序的博客文章。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d06f39820d3433ad8b96608c86b1d241/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c76da33180123812e1817802a5fca604/" rel="bookmark">
			关于node下载的模块无法使用（Cannot find module）解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个问题困扰了我很久，也按百度上各式各样的方法试了没有用
今天和导师远程，知道了问题在哪，我用webstorm编译器进行演示
若使用其他编译器，可按下述原理进行修改
原理(在当前工程文件夹下要有一个package.json文件，并在此工程下安装npm模块，安装后会出现一个node_modules文件夹，里面包含着下载的模块)
过程：
测试代码：
此时运行，结果如下图， 显示：Cannot find module
在Terminal面板对colors模块进行安装会出现如下错误：
此时，继续在该面板，输入 npm init 按下回车进行初始化，效果如图：
此时一直点击回车，直到出现" Is this ok? (yes) ” 输入yes 回车
此时，继续安装colors模块，提示安装成功：
重新运行程序，此时成功输出：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99a25cf8e895106ef385991a06091b1b/" rel="bookmark">
			Ajax怎么做跨域请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面我们在本地建两个站点演示一下
第一步首先我们在本地搭建好一个Apache服务器；下载地址； 第二步服务器配置好以后，在本地配置好两个虚拟的域名； 第三步我们在C盘建一个文件夹命名为”HTML5”； 第四步找到Apache虚拟主机的配置文件，然后打开配置文件 第五步在第三步建的HTML5文件夹下分别建一个文件夹a和文件夹b; 第六步修改Apache虚拟主机的配置文件,如图 第七步修改一下host文件，添加a和b的网址，通常host文件路径在C:\Windows\System32\drivers\etc 下 我们在HTML5/a文件夹下建一个7.ajax.html文件
&lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;获取同域下内容&lt;/title&gt; &lt;script&gt; window.onload = function() { var oBtn = document.getElementById('btn'); // 忽略IE6 oBtn.onclick = function() { //创建一个ajax对象 var xhr = new XMLHttpRequest(); //监听事件 xhr.onreadystatechange = function() { if (xhr.readyState == 4) { if (xhr.status == 200) { alert(xhr.responseText); } } } xhr.open('get', 'ajax.php', true); xhr.send(); } } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99a25cf8e895106ef385991a06091b1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f957dd4d5c38c099b7d7c2446581961/" rel="bookmark">
			Maven install命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		每一个构建都需要唯一的坐标来标识位置，我们根据坐标位置就能够下载构建至本地仓库。那么如果我们是内部项目，自定义的构建并不公开至网络上，项目成员又想依赖他怎么办呢？想想maven找寻构建的步骤。 先找寻本地仓库，本地仓库不存在，找寻远程仓库或者私服。 我们只需把自定义的构建安装至私服或者本地仓库中就行了。这就需要maven的install命令。
install 把自定义的maven项目，安装至本地仓库。
图示 项目坐标如下
&lt;groupId&gt;com.zzq.maven&lt;/groupId&gt; &lt;artifactId&gt;maven-model&lt;/artifactId&gt; &lt;version&gt;0.0.1SNAPSHOT&lt;/version&gt; cmd命令行下进入项目根目录，输入
mvn install
￼ 已打包安装到我的本地maven仓库
￼
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60778cc8745a83d63cee0433f7e60643/" rel="bookmark">
			Unity 实现按钮点击  某物体缓慢放大效果  比如打开商店
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
public class ButtonOnclick : MonoBehaviour {
public AnimationCurve curve;//放大的曲线
public Button But;
private float value = 0;
// Update is called once per frame
void Start () {
But.onClick.AddListener (delegate {
if(this.gameObject.activeSelf==true){
StartCoroutine (buttonAnimation());
}
});
}
IEnumerator buttonAnimation(){
value = 0;
while (true) {
this.transform.localScale=Vector3.one*curve.Evaluate (value+=Time.deltaTime*2);
yield return null;
if (value&gt;=1) {
break;
}
}
}
} 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/288ac180b91da21236fa30ffbfcb30e7/" rel="bookmark">
			Logstash详解之——input模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击查看全文
Logstash由三个组件构造成，分别是input、filter以及output。我们可以吧Logstash三个组件的工作流理解为：input收集数据，filter处理数据，output输出数据。至于怎么收集、去哪收集、怎么处理、处理什么、怎么发生以及发送到哪等等一些列的问题就是我们接下啦要讨论的一个重点。 我们今天先讨论input组件的功能和基本插件。前面我们意见介绍过了，input组件是Logstash的眼睛和鼻子，负责收集数据的，那么们就不得不思考两个问题，第一个问题要清楚的就是，元数据在哪，当然，这就包含了元数据是什么类型，属于什么业务；第二个问题要清楚怎么去拿到元数据。只要搞明白了这两个问题，那么Logstash的input组件就算是弄明白了。 对于第一个问题，元数据的类型有很多，比如说你的元数据可以是日志、报表、可以是数据库的内容等等。元数据是什么样子的我们不需要关心，我们要关系的是元数据是什么类型的，只要你知道元数据是什么类型的，你才能给他分类，或者说给他一个type，这很重要，type对于你后面的工作处理是非常有帮助的。所以第一个问题的重心元数据在吗，是什么，现在已经是清楚了。那么进行第二个问题。 第二个问题的核心是怎么拿到这些不同类型的原数据？这是一个真个input组件的核心内容了，我们分门别类的来看待这和解决个问题。 首先，我们肯定需要认同的，什么样的数据源，就需要使用什么样的方式去获取数据。 我们列举几种： 1、文件类型：文件类型，顾名思义，文件数据源，我们可以使用input组件的file插件来获取数据。file{}插件有很多的属性参数，我们可以张开讲解一下。具体内容在下面的代码中展示：
input{ file{ #path属性接受的参数是一个数组，其含义是标明需要读取的文件位置 path =&gt; [‘pathA’，‘pathB’] #表示多就去path路径下查看是够有新的文件产生。默认是15秒检查一次。 discover_interval =&gt; 15 #排除那些文件，也就是不去读取那些文件 exclude =&gt; [‘fileName1’,‘fileNmae2’] #被监听的文件多久没更新后断开连接不在监听，默认是一个小时。 close_older =&gt; 3600 #在每次检查文件列 表的时候， 如果一个文件的最后 修改时间 超过这个值， 就忽略这个文件。 默认一天。 ignore_older =&gt; 86400 #logstash 每隔多 久检查一次被监听文件状态（ 是否有更新） ， 默认是 1 秒。 stat_interval =&gt; 1 #sincedb记录数据上一次的读取位置的一个index sincedb_path =&gt; ’$HOME/. sincedb‘ #logstash 从什么 位置开始读取文件数据， 默认是结束位置 也可以设置为：beginning 从头开始 start_position =&gt; ‘beginning’ #注意：这里需要提醒大家的是，如果你需要每次都从同开始读取文件的话，关设置start_position =&gt; beginning是没有用的，你可以选择sincedb_path 定义为 /dev/null } } 点击查看全文
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b272374f63c862a70ed7780cbc277f16/" rel="bookmark">
			sublime text 格式化json
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在开发的过程中，json数据是经常使用的。查日志。。但是查到的日志，都是一长串。。之前最长使用的是sojson网站，打开之后，然后格式化json 在模拟数据。但是发现，查的多了，每次都打开浏览器 格式化，觉得挺繁琐的。然后听说sublime text 可以对json数据进行处理。然而我也经常使用，随意就研究了一下。 首先，sublimetext 需要安装插件。 安装 1、打开view-&gt;show console打开控制台 2、下载输入
import urllib.request,os;pf='Package Control.sublime-package';ipp=sublime.installed_packages_path();urllib.request.install_opener(urllib.request.build_opener(urllib.request.ProxyHandler()));open(os.path.join(ipp,pf),'wb').write(urllib.request.urlopen('http://sublime.wbond.NET/'+pf.replace(' ','%20')).read()) 3、安装 按ctrl+shift+p调出窗口，输入install package 安装成功之后的样子，安装之后，就是使用。使用的时候只需要用命令行 就可以处理。 如果可以看到上面的内容，说明插件装好了。 下面就是使用了。 新建一个文本，把json数据写到里面。使用快捷键格式化，或者用命令。 热键：ctrl+alt+j （） 命令：ctrl+shift+p打开命令行。 输入json。然后会发现 好多对json数据处理的命令。 格式化json：format json json转化xml：json 2 xml……..等等。 当然，sublime text 提供了很多很多插件，都可以对数据进行处理。需要慢慢去挖掘。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ff21a9142202b2effb3acfbb4cb26e8/" rel="bookmark">
			Java里面CompletableFuture详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Future是Java5添加的类，用来描述一个异步计算的结果。可以用isDone方法来检查计算是否完成，或者使用get阻塞住调用线程，直至计算完成返回结果，也可以用cancel方法来停止任务的执行。
public class BasicFuture { public static void main(String[] args) throws ExecutionException, InterruptedException { ExecutorService es = Executors.newFixedThreadPool(10); Future&lt;Integer&gt; f = es.submit(() -&gt; { // 长时间的异步计算 // ... // 然后返回结果 return 100; }); f.get(); } } Future以及相关使用方法提供了异步执行任务的能力，但对于结果的获取却是不方便，只能通过阻塞或轮询的方式得到任务结果。阻塞的方式与我们理解的异步编程其实是相违背的，而轮询又会耗无谓的CPU资源。而且还不能及时得到计算结果，为什么不能用观察者设计模式当计算结果完成及时通知监听者呢？ 很多语言像Node.js，采用回调的方式实现异步编程。Java的一些框架像Netty，自己扩展Java的Future接口，提供了addListener等多个扩展方法：
ChannelFuture future = bootstrap.connect(new InetSocketAddress(host, port)); future.addListener(new ChannelFutureListener() { @Override public void operationComplete(ChannelFuture future) throws Exception { if (future.isSuccess()) { // SUCCESS } else { // FAILURE } } }); guava里面也提供了通用的扩展Future: ListenableFuture\SettableFuture以及辅助类Futures等，方便异步编程。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ff21a9142202b2effb3acfbb4cb26e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d75567b7fb6b6a25e2a2fdac8739a8f4/" rel="bookmark">
			解决SPSS中can not create java virtual machine问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SPSS安装后要输入激活码，但是打开认证的时候就提示“can not create java virtual machine”错误，无法继续进行。
解决方法是，在安装目录下，创建命名为“lservrc"的文本文件，把激活码复制进去，保存。然后删除扩展名，再打开SPSS可以看到功能要比没有激活的多了很多。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/228b949d7f3512f39e762620eafc8a2f/" rel="bookmark">
			vue中promise和axios 同步爬坑小记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		es6提供给了我们promise这个对象，我们再也不用像原来那样多个ajax嵌套来实现同步了，在小编看来，promise本质是语法糖，让你能更优雅的解决同步问题！本文来说说小编遇到的问题，和个人见解，具体promise语法请大家自行阅读！
小编遇到的主要问题是有2个异步的axios，第一个axios的值作为第二个axiosd的参数，也就是说第二个axios必须等待第一个axios完成才能执行，小编开始的写法是这样
let prefun = function () {
return new promise(function(resolve,reject){
// axios操作 axios.post(...).then(
(response) =&gt; {
` if (返回成功代码) {
resolve(需要传递的值)
}
}
)
})
}
let nextfun = function (prevalue) {
return new promise(function(resolve,reject){
// axios操作 // 参数部分
let param ={
......
}
axios.post(...).then(
(response) =&gt; {
` if (返回成功代码) {
resolve(需要传递的值)
}
}
)
})
}
prefun().then((value) =&gt; {
nextfun(prevalue)
}
).catch(....)
正常情况下，prefun产生的值，通过resolve()传递到then这个回调函数，nextfun 这个函数在prefun执行后，才会执行，这样就完美形成了同步。但是在vue中，
如果vue要调用全局变量，必须加this,于是杯具发生了！问题的关键就出在this上，小编找了好久才找到，西湖的水我的泪啊，小编好伤心！
这个方法nextfun 的这个参数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/228b949d7f3512f39e762620eafc8a2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a3472e830b3c8b2a450f9f0e1840eff/" rel="bookmark">
			podspec 简单用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pod::Spec.new do |s|
s.name = 'Box
s.version = "1.0.0"
s.license = { :type =&gt; 'xxx.com', }
s.homepage = 'homepage'
s.authors = { 'xxx' =&gt; 'author name' }
s.summary = 'xx 公有库'
s.description = 'xx'
s.source = { :git =&gt; 'git@xx',:branch =&gt; 'master'}
s.frameworks = 'Foundation', 'UIKit', 'QuartzCore', 'CoreLocation'
s.platform = :ios, '7.0'
s.requires_arc = true
s.source_files = "BoxsysBundle/**/*.{h,m}"
s.prefix_header_file = 'BoxsysBundle/JHSBox-prefix.pch'
s.xcconfig = { 'HEADER_SEARCH_PATHS' =&gt; '"../工程路径1/**" ' \
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a3472e830b3c8b2a450f9f0e1840eff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c49d42d53bb196f7b54198411d5b7079/" rel="bookmark">
			多页爬取数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BeautifulSoup自动将输入文档转换为Unicode编码，输出文档转换为utf-8编码。你不需要考虑编码方式，除非文档没有指定一个编码方式，这时，BeautifulSoup就不能自动识别编码方式。这时，你只需要说明一下原始编码方式就ok。参数用lxml就可以，需要另行安装并载入。BeautifulSoup已成为和lxml、html6lib一样出色的python解释器，为用户灵活地提供不同的解析策略或强劲的速度。
爬取一网站多个网页数据：
from bs4 import BeautifulSoup import requests import lxml import time url='https://www.tripadvisor.cn/Attractions-g60763-Activities-New_York_City_New_York.html' urls = ['https://www.tripadvisor.cn/Attractions-g60763-Activities-oa{}-New_York_City_New_York.html#ATTRACTION_LIST'.format(str(i)) for i in range(30,1110,30)] def get_attractions(url): web_data = requests.get(url) time.sleep(2) soup = BeautifulSoup(web_data.text,'lxml') imgs = soup.select('img[width="180"]') titles = soup.select('#ATTR_ENTRY_ &gt; div.attraction_clarity_cell &gt; div &gt; div &gt; div.listing_info &gt; div.listing_title &gt; a') scores = soup.select('#ATTR_ENTRY_ &gt; div.attraction_clarity_cell &gt; div &gt; div &gt; div.listing_info &gt; div.listing_rating &gt; div &gt; div &gt; span[alt]') comments = soup.select('#ATTR_ENTRY_ &gt; div.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c49d42d53bb196f7b54198411d5b7079/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/385d962b99f7e7dcef1c56d8024f93fe/" rel="bookmark">
			VMware vSphere Web Services SDK编程指南（四）- vSphere API 编程模型（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vSphere API 编程模型（一） vSphere API 是作为一种语言无关的 Web 服务实现的，它基于一个远程过程调用机制，客户端应用程序使用它来访问 ESXi和 vCenter 服务器系统上的服务和组件。
本章节主要包括以下内容：
■ vSphere Client-Server 架构 ■ vSphere API 作为一个 Web 服务 ■ 访问托管对象（Managed Object） ■ 访问 vSphere 服务器数据
1. vSphere Client-Server 架构 VMware vSphere 客户端应用程序加入了使用异步通信模型的分布式架构。 该架构是基于服务器端托管对象、客户端托管对象引用和数据对象的。
■ 托管对象（Managed objects），存在于 vSphere 服务器(ESX/ESXi 或 vCenter 服务器系统)上，表示 vSphere 服务和组件：
服务包括 PropertyCollector、SearchIndex、PerformanceManager 和 ViewManager；
组件包括清单对象如VirtualMachine、Datastore、Folder。
■ 托管对象引用（Managed object references），是客户端应用到服务器端托管对象的引用。 当你的客户端应用调用一个服务器上的操作（方法）时，客户端就会使用 ManagedObjectReference 对象。 在一个对象的生命周期中，一个 ManagedObjectReference 保证是唯一的和持久的。当对象随着清单被移除、跨会话和跨服务器重启时，引用仍然存在。 如果你移除一个对象，如清单中的虚拟机，然后把它迁移回去，此时引用就改变了。
■ 数据对象（Data objects ），包含托管对象的相关信息。你的客户端应用发送数据对象到 vSphere 服务器，并从服务器接收数据对象。 示例是不同的规范和功能对象，例如 virtualmachine econfigspec 和 HostCapability。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/385d962b99f7e7dcef1c56d8024f93fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19b4790762fd076ad31cfa77be2f2361/" rel="bookmark">
			麻将算法（上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、麻将规则（云南昭通麻将） 1.牌
1) “万”“筒”和“条”三房牌，各36张，共108张牌；
2) 只能 “碰”“杠”“胡”，不能吃牌
3) 4人进行游戏；
4) 游戏开始时，庄家摸14张牌，闲家摸13张牌；
5) 有4个癞子牌（坨牌：既可以作为本身牌型可以替换为任意牌）
2.游戏术语
1) 坎：自己手中有三张相同的牌；
2) 碰牌：自己手中有两张，别人再打出一张，则可以用两张去碰，并将这三张亮出来；
3) 明杠：自己手中有一坎，别人在打出一张，则可以用三张去杠，称之为明杠，所有的杠都是从牌墙前面补牌的。
4) 暗杠：自己摸到了四张相同的牌，则可以暗杠；
5) 补杠：自己已经碰了的牌，自己又摸到了第4张，则可以补杠；
6) 根：自己的手牌和碰牌中有四张相同的但是没杠下来的，称之为根；
7) 叫：即听牌，用户当前的13张牌，再摸一张牌就可以和牌的牌型；
8) 墙子：摸完牌后，翻出一张牌，放在下家的堆牌区中。
9) 坨：摸完牌后，翻出牌墙第一张牌，定义为癞子牌。
10) 满飞满杀：坨拿去杠。
案例1：手上2个5条，有人打出5条，可以拿2个5条加1个坨去杠5条
案列2：已碰了3万，手上有坨，可以直接拿坨去杠3万
11) 飞碰：坨加一张单牌拿去碰的过程。
12) 亮牌：胡牌后亮出所有牌（牌桌上的玩家都可以看），剩下的继续血战。
3.胡牌规则
1) 胡牌条件：缺一门成牌型即可胡牌
缺一门：游戏开始后，必须打缺一门，中途可以换打缺哪门（不是定缺），胡牌局牌时必须只有2 门或1门（筒、万、条牌型）
胡牌的基本牌型：
i. 11、123、123、123、123；
ii. 11、123、123、123、111/1111（下同）；
iii. 11、123、123、111、111；
iv. 11、123、111、111、111；
v. 11、111、111、111、111；
vi. 11、22、33、44、55、66、77；
2) 牌型
牌型
说明
棒棒
正常普通的和牌，所谓的平胡
勾胡
手上有杠的牌型
天胡
庄家起手牌就和牌
地胡
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19b4790762fd076ad31cfa77be2f2361/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2bbc15a38a0aa46cb003ffc6dbb1a47/" rel="bookmark">
			Kafka与常见消息队列的对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kafka与常见消息队列的对比 RabbitMQ Erlang编写支持很多的协议：AMQP，XMPP, SMTP, STOMP非常重量级，更适合于企业级的开发发送给客户端时先在中心队列排队。对路由，负载均衡或者数据持久化都有很好的支持。 Redis 基于Key-Value对的NoSQL数据库入队时，当数据比较小时Redis的性能要高于RabbitMQ，而如果数据大小超过了10K，Redis则慢的无法忍受；出队时，无论数据大小，Redis都表现出非常好的性能，而RabbitMQ的出队性能则远低于Redis。 ZeroMQ 号称最快的消息队列系统，尤其针对大吞吐量的需求场景。高级/复杂的队列，但是开发人员需要自己组合多种技术框架，技术上的复杂度是对这MQ能够应用成功的挑战。具有一个独特的非中间件的模式，不需要安装和运行一个消息服务器或中间件ZeroMQ仅提供非持久性的队列，也就是说如果宕机，数据将会丢失。 ActiveMQ 类似于ZeroMQ，它能够以代理人和点对点的技术实现队列。类似于RabbitMQ，它少量代码就可以高效地实现高级应用场景。 Kafka/Jafka 高性能跨语言分布式发布/订阅消息队列系统快速持久化，可以在O(1)的系统开销下进行消息持久化；高吞吐，在一台普通的服务器上既可以达到10W/s的吞吐速率；完全的分布式系统，Broker、Producer、Consumer都原生自动支持分布式，自动实现负载均衡；支持Hadoop数据并行加载，对于像Hadoop的一样的日志数据和离线分析系统，但又要求实时处理的限制，这是一个可行的解决方案。Kafka通过Hadoop的并行加载机制统一了在线和离线的消息处理。一个非常轻量级的消息系统，除了性能非常好之外，还是一个工作良好的分布式系统。 转载于:https://www.cnblogs.com/rwxwsblog/p/7252245.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8cce64a3d2f7c51bcf2552522357f9b/" rel="bookmark">
			需求：统计每十分钟访问报表的人数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 现在有个需求：
要求统计没十分钟访问报表的人数.
统计结果如：
最终sql：
select trunc(oper_time, 'dd') + (floor(to_char(oper_time, 'sssss') / 600)) / 144 time2,count(*) from tb_log_report where oper_time&gt;trunc(sysdate-21) group by trunc(oper_time, 'dd') + (floor(to_char(oper_time, 'sssss') / 600)) / 144 ; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d7bc0039945df82b9a7063a8cff44a0/" rel="bookmark">
			编译vs2008的程序总是跳过，显示“未能完成操作 未指定的错误”的解决办法 .
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天想参考一下vs2008的示例程序，就是在这里 “E:/Program Files/vs2008/Samples/2052/AllVCLanguageSamples/C++/MFC”的程序。 但编译时总是跳过，还不能调试，网上有人说要改平台为win32，但要配置属性或清理项目时却显示“未能完成操作 未指定的错误”。
到网上找了一圈，发现没一个解决办法适合我的（当然除了一个人说的重装vs，我没试，受不了）。
后来我就乱搞了，试着把项目的特殊文件删除再加载项目：比如删makefile或者 .mak 或者 .ncb ，发现都不行。除了.h, .cpp没删外，都删过一道，终于发现删 .vcproj文件是可以的。
具体解决过程是这样的：
1、先把.vcproj 文件剪切到其他地方
2、打开.sln,报错-》点“确定”-》再点“确定”
3、把 .vcproj 文件 放回来，在vs2008右边的“解决方案”处右键 重新加载，就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa9cc1752c19fd5dd360c8fd3cfd27fb/" rel="bookmark">
			cssRules 与 rules 的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当html中引用外部css样式时，就不能通过document.style获取属性，而是需要通过document.stylesheets获取属性表对象即CSSStyleSheet对象，再从属性表对象中获取属性与操作方法。
获取属性的方法有两种：
1.cssRules
2.rules
通过打印cssText，可以清晰的知道两者的不同：
document.styleSheets[0].cssRules[0].cssText;
document.styleSheets[0].rules[0].cssText
看过其他人的博客是这么说的：
第一个观点：
cssRules的单位是是对整条规则，而rules的单位是一个选择器。
但就目前我的测试情况而言，cssRules 与 rules 针对我的第一条数据，即：
html,body{
margin: 0px;
padding: 0px;
width: 100%;
height: 100%;
}
是一样的结果，可能为浏览器目前都同步了对cssRules与rules的选取规则，即都选取第一条数据，而不是第一个选择器
第二个观点：
最好不要直接通过cssRules操作样式，这个更偏向于底层，一次性大量操作css规则的时候使用。
这个观点我不加评论，看个人意愿了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9391e82c03bf9c64c00a040036b7fc40/" rel="bookmark">
			Python .pyc的编译和反编译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 由Python文件编译为.pyc文件
python -m compileall test.py 2. .pyc的反编译，使用uncompyle
最方便的就是使用pip安装 uncompyle：pip install uncompyle
uncompyle6 --help 查看帮助 uncompyle6 models.pyc &gt; models.py 将models.pyc反编译成py文件 uncompile -o . *.pyc 将当前文件夹中所有的pyc文件反编译成后缀名为.pyc_dis的源文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8708b5469de9ab2eea65d2a211213b08/" rel="bookmark">
			Maven项目构建命令compile、test、package
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		compile 前面我们按照maven约束好的文件路径建好项目后，加入pom.xml 在命令行输入mvn compile后，maven就会自动帮我们下载依赖jar，为代码生成字节码文件等。我们把这个过程称为 编译。
test 前面我们写好测试类，在命令行输入 mvn test 项目会新增surefire-reports(测试报告) 、 test-classes(测试类字节码)两个文件夹。我们把这个过程称为 测试。
package 从字面来看，package这个命令是打包。我们来验证下。
命令行进入项目根目录下 输入mvn package ￼ 会看到有一个jar 包在项目target目录下。
￼
延伸 但为什么是jar格式 而不是其他格式呢 还记得上节对pom.xml的介绍吗？ 我们来看下本项目的pom.xml文件
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.zzq.maven&lt;/groupId&gt; &lt;artifactId&gt;maven-model&lt;/artifactId&gt; &lt;version&gt;0.0.1SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 并没有看到 jar关键字 但是是否还记得这样一句配置呢
&lt;!-- 项目打包方式 默认jar 可以是 war jar pom zip --&gt; &lt;packaging&gt;war&lt;/packaging&gt; 总结 compile 编译 test 测试 package 打包
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4146d76d14ea24f6762db2a992b609c/" rel="bookmark">
			java操作Redis数据库的redis工具,RedisUtil,jedis工具JedisUtil,JedisPoolUtil
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该工具包含是封装了jedis,包含redis.properties和jedisPool,序列化使用的是protostuff,map类型操作使用的是fastjson
自己抽空写的,基本只要理解什么是get,什么是set就可以使用redis数据库了
下载地址:点击打开链接
JedisPoolUtil的源码:
package com.bsy.common; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.IOException; import java.io.InputStream; import java.net.URL; import java.util.Properties; import org.apache.commons.pool2.impl.GenericObjectPoolConfig; import redis.clients.jedis.Jedis; import redis.clients.jedis.JedisPool; import redis.clients.jedis.JedisPoolConfig; public class JedisPoolUtil { private static final String PROPERTIES_PATH = "redis.properties"; private static JedisPool jedisPool; static { if (jedisPool == null) { try { init(); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } } /** * 初始化Jedis连接池 * * @throws IOException */ private static void init() throws IOException { URL resource = JedisPoolUtil.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4146d76d14ea24f6762db2a992b609c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0225cedcb0a1865fb97e39a421c6db2f/" rel="bookmark">
			Unity在编辑器中通过代码更改Tag
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Unity的编辑器中，当我们有较多的Tag需要手动输入时，我们可以通过代码来简化此过程，同时也可以通过代码将我们的工程导入其他项目时来检查需要的Tag是否存在。同时，在AssetBundle导出的过程中，虽然模型中的Tag会被保留，但是其保存的仅仅是Tag列表中的一个顺序，而非真正的根据名称保存的。这就需要当我们在不同的项目中进行Bundle的导入导出时重点检查的部分，否则容易出现意想不到的结果。
using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEditor; public class CheckTags : MonoBehaviour { private static string[] tags = new string[] { "***" "***" "***" "***" "***" "***" "***" "***"}; [MenuItem("TagController/CheckTags")] public static void CheckTag() { // Open tag manager SerializedObject tagManager = new SerializedObject(AssetDatabase.LoadAllAssetsAtPath("ProjectSettings/TagManager.asset")[0]); // Tags Property SerializedProperty tagsProp = tagManager.FindProperty("tags"); //Debug.Log("TagsPorp Size:" + tagsProp.arraySize); tagsProp.ClearArray(); tagManager.ApplyModifiedProperties(); //Debug.Log("TagsPorp Size:" + tagsProp.arraySize); for (int i = 0; i &lt; tags.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0225cedcb0a1865fb97e39a421c6db2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/daaae4cbd1dd3cfdba5304a0c040b3c0/" rel="bookmark">
			matlab矩阵复制函数：【repmat】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		repmat 即 Replicate Matrix ，复制和平铺矩阵，是 MATLAB 里面的一个函数。
B = repmat(A,m,n) %将矩阵A复制m×n块，即B由m×n块A平铺而成
B = repmat(A,[m n]) %与上面一致
B = repmat(A,[m n p...]) %B由m×n×p×…个A块平铺而成
repmat(A,m,n) %当A是一个数a时，该命令产生一个全由a组成的m×n矩阵。
处理大矩阵且内容有重复时使用，其功能是以A的内容堆叠在（MxN）的矩阵B中，B矩阵的大小由MxN及A矩阵的内容决定
如果A是一个3x4x5的矩阵，有B = repmat(A,2,3)则最后的矩阵是6x12x5。
一、repmat(NaN,m,n)等价于NaN(m,n). 二、repmat(single(inf),m,n)等价于inf(m,n,'single'). 三、repmat(int8(0),m,n)等价于zeros(m,n,'int8'). 四、repmat(uint32(1),m,n)等价于ones(m,n,'uint32'). 五、repmat(eps,m,n)等价于eps(ones(m,n)). 例如：
一、B = repmat(A,m,n) 将矩阵 A 复制 m×n 块，即把 A 作为 B 的元素，B 由 m×n 个 A 平铺而成。B 的维数是 [size(A,1)*m, size(A,2)*n] 。 &gt;&gt; A = [1,2;3,4] A = 1 2 3 4 &gt;&gt; B = repmat(A,2,3) B = 1 2 1 2 1 2 3 4 3 4 3 4 1 2 1 2 1 2 3 4 3 4 3 4 二、B = repmat(A,[m n]) 与 B = repmat(A,m,n) 用法一致。 三、B = repmat(A,[m n p.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/daaae4cbd1dd3cfdba5304a0c040b3c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c8752a0bd902f1235d6fb6bfa326e99/" rel="bookmark">
			Hadoop、hive、sqoop入门及完整小例子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hadoop MapReduce 和 HDFS
有自己的RPC和序列化机制
hadoop1.x HDFS：在1.x中的NameNode只可能有一个，虽然可以通过SecondaryNameNode与NameNode进行数据同步备份，但是总会存在一定的时延，如果NameNode挂掉，但是如果有部份数据还没有同步到SecondaryNameNode上，是可能会存在着数据丢失的问题（冷备份、定期checkpoint、单点问题）。
MapReduce：
（1）JobTracker 是 Map-reduce 的集中处理点，存在单点故障；
（2）JobTracker 完成了太多的任务，造成了过多的资源消耗，当 map-reduce job 非常多的时候，会造成很大的内存开销，潜在来说，也增加了 JobTracker 失效的风险，这也是业界普遍总结出老 Hadoop 的 Map-Reduce 只能支持 4000 节点主机的上限；
流程：
（1）首先用户程序 （JobClient） 提交了一个 job，job 的信息会发送到 Job Tracker 中，Job Tracker 是 Map-reduce 框架的中心，他需要与集群中的机器定时通信 (heartbeat), 需要管理哪些程序应该跑在哪些机器上，需要管理所有 job 失败、重启等操作。
（2）TaskTracker 是 Map-reduce 集群中每台机器都有的一个部分，他做的事情主要是监视自己所在机器的资源情况。
（3）TaskTracker 同时监视当前机器的 tasks 运行状况。TaskTracker 需要把这些信息通过 heartbeat发送给JobTracker，JobTracker 会搜集这些信息以给新提交的 job 分配运行在哪些机器上。
hadoop2.x YARN+MapReduce HDFS：HA
YARN 并不是下一代MapReduce（MRv2），下一代MapReduce与第一代MapReduce（MRv1）在编程接口、数据处理引擎（MapTask和ReduceTask）是完全一样的， 可认为MRv2重用了MRv1的这些模块，不同的是资源管理和作业管理系统，MRv1中资源管理和作业管理均是由JobTracker实现的，集两个功能于一身，而在MRv2中，将这两部分分开了。 其中，作业管理由ApplicationMaster实现，而资源管理由新增系统YARN完成，由于YARN具有通用性，因此YARN也可以作为其他计算框架的资源管理系统，不仅限于MapReduce，也是其他计算框架（例如Spark）的管理平台。
ResourceManager：全局资源管理器，基于应用程序对资源的需求进行调度的 ; 每一个应用程序需要不同类型的资源因此就需要不同的容器。资源按需调度，包括：内存，CPU，磁盘，网络等等。
NodeManager：节点代理，监控资源使用情况并且向调度器汇报。
ApplicationMaster：类似JobTracker，向调度器索要适当的资源容器，结合从 ResourceManager 获得的资源和 NodeManager 协同工作来运行和监控任务。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c8752a0bd902f1235d6fb6bfa326e99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81a65463d1ccfa70c0543faa73ccc54a/" rel="bookmark">
			python四种方法实现去除列表中的重复元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前些天发现了一个风趣幽默的人工智能学习网站，通俗易懂，忍不住分享一下给大家。点击跳转到教程 一共使用四种方法来去除列表中的重复元素，下面是具体实现：
#!usr/bin/env python #encoding:utf-8 ''''' __Author__:沂水寒城 功能：去除列表中的重复元素 ''' def func1(one_list): ''' 使用集合，个人最常用 ''' return list(set(one_list)) def func2(one_list): ''' 使用字典的方式 ''' return {}.fromkeys(one_list).keys() def func3(one_list): ''' 使用列表推导的方式 ''' temp_list=[] for one in one_list: if one not in temp_list: temp_list.append(one) return temp_list def func4(one_list): ''' 使用排序的方法 ''' result_list=[] temp_list=sorted(one_list) i=0 while i&lt;len(temp_list): if temp_list[i] not in result_list: result_list.append(temp_list[i]) else: i+=1 return result_list if __name__ == '__main__': one_list=[56,7,4,23,56,9,0,56,12,3,56,34,45,5,6,56] print func1(one_list) print func2(one_list) print func3(one_list) print func4(one_list) 结果如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81a65463d1ccfa70c0543faa73ccc54a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecebc97bfaf68f46209ee8ed38e00e7b/" rel="bookmark">
			计算机的存储单位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ø 前言
对于计算机的存储单位，想必大家都比较熟悉了，这应该是程序猿的入门基础。但是，有时候越是简单、基础的东西，大家越容易疏忽、遗忘。所以，今天特意的整理了一下，一是巩固一下，二是方便日后查阅。本文主要讨论以下几点：
1. 计算机的存储原理。
2. 什么是计算机的存储单位。
3. 计算机存储单位分为哪些等级。
4. 常用存储单位的换算关系。
5. 字符存储所占用字节数。
6. 存储单位进率为什么是1024而不是1000。
7. 带宽存储换算。
1. 计算机的存储原理
计算机使用电作为信号传输，分为低电平和高电平，0为低电平，1为高电平。0和1 就是我们平常说的二进制数，我们在电脑上所看到的一切都是由这两个数组成，比如文件、图像、视频等，都是计算机通过对储存器中无数个0和1的计算得来。
2. 什么是计算机的存储单位
指在某一领域以一个特定量，或标准作为一个记录（计数）点。再以此点的某个倍数再去定义另一个点，而这个点的代名词就是计数单位或存储单位。如卡车的载重量是吨，也就是这辆卡车能存储货物的数量，吨就是它的单位量词。
计算机的基本存储单位是0和1（bit），又称作位或比特，它是最小的存储单位。一个0/1即是一位，8位等于一个字节，比如：00101011 = 8bit（位/比特） = 1B（Byte/字节）。
3. 计算机存储单位分为哪些等级
1) Bit（位/比特）
2) B（Byte/字节）
3) KB（Kilobyte/千字节）
4) MB（Megabyte/兆字节，简称“兆”）
5) GB（Gigabyte/吉字节，简称“千兆”）
6) TB（Terabyte/太字节/万亿字节）
7) PB（Petabyte/拍字节/千万亿字节）
8) EB（Exabyte/艾字节/百亿亿字节）
9) ZB（Zettabyte/泽字节/十万亿亿字节）
10) YB（Yottabyte/尧字节/一亿亿亿字节）
11) BB（Brontobyte/珀字节/一千亿亿亿字节）
12) NB（NonaByte/诺字节）
13) DB（DoggaByte/刀字节）
14) CB（CorydonByte）
15) XB（XeroByte）
Ø 说明：以上存储单位除了 Bit 与 Byte 以外，其他每级为前一级的1024倍，比如：1B = 8bit，1KB = 1024B，1M = 1024KB。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecebc97bfaf68f46209ee8ed38e00e7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4504a9f344b2f0c31623d7d28aed61bd/" rel="bookmark">
			Bean 后处理器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Bean 后处理器是一种特殊的 Bean，容器中所有的 Bean 在初始化时，均会自动执行该类的两个方法。由于该 Bean 是由其它 Bean 自动调用执行，不是程序员手工调用，故此 Bean无须 id 属性。 需要做的是，在 Bean 后处理器类方法中，只要对 Bean 类与 Bean 类中的方法进行判断，就可实现对指定的 Bean 的指定方法进行功能扩展与增强。方法返回的 Bean 对象，即是增过的对象。 代码中需要自定义 Bean 后处理器类。该类就是实现了接口 BeanPostProcessor 的类。该接口中包含两个方法，分别在目标 Bean 初始化完毕之前与之后执行。它们的返回值为：功能被扩展或增强后的 Bean 对象。 Bean 初始化完毕有一个标志：一个方法将被执行。即当该方法被执行时，表示该 Bean 被初始化完毕。所以 Bean 后处理器中两个方法的执行，是在这个方法之前之后执行。这个方法在后面将会讲到。 public Object postProcessBeforeInitialization(Object bean, String beanId)throws BeansException 该方法会在目标 Bean 初始化完毕之前由容器自动调用。 public Object postProcessAfterInitialization(Object bean, String beanId) throws BeansException 该方法会在目标 Bean 初始化完毕之后由容器自动调用。 它们的参数是：第一个参数是系统即将初始化的 Bean 实例，第二个参数是该 Bean 实例的 id 属性值。若 Bean 没有 id 就是 name 属性值。 举例： ba05 包 程序中有一个业务接口 IService，其有两个业务方法 some()与 other()。有两个 Bean： StudentServiceImpl 与 TeacherServiceImpl，均实现了 IService 接口。 要求：对 StudentServiceImpl 的 some()方法进行增强，输出其开始执行时间与执行结束时间。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0746af9794f418c763f1d23699cce582/" rel="bookmark">
			03-Thrift进阶
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Thrift进阶端口复用文件传输推送双向通信感受补充 Thrift进阶 在官网和大部分博客中，介绍的都是最简单的Hello World性质的东西。但是实际使用有很多问题考虑在内，比如目前的一个需求： - Thrift中一个服务对应一个端口，如果需要多个服务，则悲剧了，端口复用问题十分严重。 - 相比较，在ZeroC ICE中，不仅可以做到服务集合，而且端口复用是一个最最基础的用法。 - 下面我们来探究一下，端口复用问题。0.9.1版本之后原生支持。 集中解决三个问题：端口复用、文件续传、双向传输/推送。 参考Url 端口复用 1 端口复用 通过TMultiplexedxxxxx分别为服务器和客户端提供多服务共用端口的问题。 // 服务器修改, TMultiplexedProcessor shared_ptr&lt;TMultiplexedProcessor&gt; mprocessor(new TMultiplexedProcessor()); mprocessor-&gt;registerProcessor("mathService", processor); // 可以注册多个服务Processor TNonblockingServer _server(mprocessor, protocolFactory, 9090, threadManager); // 将原始的Processor替换 // 客户端, TMultiplexedProtocol shared_ptr&lt;TMultiplexedProtocol&gt; mProtocol(new TMultiplexedProtocol(clientProtocol, "mathService")); // 添加一层Protocol MathServiceClient client(mProtocol); // 修改Protocol // 如果有多个Service则需要多个mProtocol，对应多个client。但是transport只用打开一次。 如果使用Golang，代码如下： 坑： golang库中的示例代码已经不可用，下面是修改后的！ 服务器使用NewTMultiplexedProcessor, 但是NewTMultiplexedProcessor2更强大，不会用::&gt;_&lt;:: // 服务器 package main import ( "fmt" "mathservice" "os" "time" "git.apache.org/thrift.git/lib/go/thrift" ) const ( NetWorkAddr = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0746af9794f418c763f1d23699cce582/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2194eeac3bc3828bdb21e33e9185bf8/" rel="bookmark">
			javafx中radiobutton使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		final ToggleGroup group = new ToggleGroup(); RadioButton rb11 = new RadioButton("选中"); rb11.setToggleGroup(group); rb11.setUserData(1); RadioButton rb21 = new RadioButton("未选"); rb21.setToggleGroup(group); rb21.setUserData(0); // 选中某个单选框时输出选中的值 group.selectedToggleProperty().addListener( new ChangeListener&lt;Toggle&gt;() { public void changed( ObservableValue&lt;? extends Toggle&gt; ov, Toggle old_toggle, Toggle new_toggle) { if (group.getSelectedToggle() != null) { System.out.println(group.getSelectedToggle() .getUserData()); } } }); 选中某个单选框时会输出选中的值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3219dab17f1cbcac9a21cf1f765479ce/" rel="bookmark">
			Android版本控制设置忽略文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		团队开发中我们需要创建一个项目多个人开发，这时候就用到了版本控制这个工具。我们需要创建一个版本控制的服务器。版本控制工具可以是Gig或者SVN等，小公司一般用SVN。在上传文件到版本控制中时有一个问题，我们需要把所有的文件都上传吗？不是这样的，有一些本地使用的文件，和整体的项目没有关系的文件，和开发工具的配置编译有关的文件也可以不上传。这样方便其他人要是想使用你的文件的时候，不需要配置和你一样的编译环境。还有一些可能是我们的密码相关的文件，比如我们的keystore的账户和密码。所以总结一下大概有一下文件需要设置过滤：
1. .项目根目录下的.gradle文件
项目的gradle编译系统文件，由gradle指定。
2. 项目根目录下.idea文件夹下的所有文件
项目整体的配置文件，有编译配置文件，libraries 信息，工作空间信息，版本控制信息等。不需要加入版本控制。
3. 项目根目录下build文件夹
项目整体编辑产生的文件，包含一些编辑后的生成文件，对于代码没有什么用处。每次编译都会改变这个文件，不需要上传这个文件。
4.local.properties文件
这个是本地的设置文件，自己电脑的sdk路径设置在这里，这个不需要上传，别人在拿到这个代码的时候如果sdk路径不一样不需要设置
5. 项目根目录下的 *iml
iml 文件是对 项目整体的一些配置，包含项目路径参数等。具体可以查看项目中的这个文件。
6.app文件夹下
build文件夹
app.iml文件 这个文件用来配置module 的一些信息和项目根目录下的类似。
7.src 目录下
androidTest 目录
test 目录
这是两个测试文件目录，Android和java测试。也可以不需要提交到版本控制中。
知道了这些文件不需要上传到版本控制我们来操作：
例如：我们上图，需要将gradle这个加入忽略，则操作如上，点击Unversion and to ignore list .（其他文件也是这样的操作，本来这个gradle是不需要添加过滤的，这里为了看）。添加完成后，最后提交到版本控制，就会看到，过滤的文件（文件夹上）是没有任何标志的，添加到版本控制的就出现了一个绿色的 √，这就好了。
最后我们从版本控制上CheckOut 下来这个项目如图：
下载下来的文件中没有我们设置了不添加版本控制中文件。
然后Android studio 打开这个项目，编译后：
最后重新编译完成可以看到，和最初的结构一样。只不过在项目内部，app目录下我们过滤了的test文件就不会下载出来，这个对于其他的看代码的人也没有什么影响。
这样就完成了版本控制的添加。
对于Git 版本控制添加文件也是上述的文件 。我们还可以通过Android studio 中.ignore 这个配置插件工具来设置要过滤的文件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6666a8922cad16308c6f2fed92d142aa/" rel="bookmark">
			无法完成请求,因为文件格式模块不能解析,PS新手们是否遇到呢？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ﻿﻿ 无法完成请求,因为文件格式模块不能解析,PS新手们是否遇到呢？
最近很多朋友与同行问我一个问题，说微信里面保存的二维码手机导出后Photoshop软件无法打开，提示：无法完成请求,因为文件格式模块不能解析，如下图
我就纳闷了，好好的图片强大的Photoshop都无法打开了，网页浏览器显示正常，什么环节问题呢？
作为搞技术的，不找出原因肯定是茶饭不思的，我拿到图片，第一件事就用本地记事本打开看看什么原因，怎么打开？下面我教大家
鼠标选中图片，右键，选中打开方式--记事本，找不到记事本可以在打开方式里面默认程序里面选择找到笔记本应用，底下有个选项始终使用选择的程序打开这种文件不要勾选，防治以后你其他图片打开默认就是用记事本打开。如下图
打开后会发现乱码，不要紧张，看抬头编码格式，一般都是第一行或者前面几个字符串：
1，假如显示有JFIF字符
说明此图片正确格式为.jpg后缀名，你只需关闭记事本，选中图片按f2快捷键或者鼠标右键重命名，后缀名改为.jpg
2,假如带有“塒NG”的是PNG格式的图片
说明此图片正确格式为png,按照上述方法把图片后缀名改为.png
3,假如开头带有GIF字符串的，图片正确格式为.gif
也按照上述方法改图片后缀名为.gif
就这样，改了图片后缀名，Photoshop软件完美打开图片，无错误提示
注意点：改后缀名不是在记事本代码里面改，是改文件后缀名。
﻿﻿ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da31eb14707959cbbef2c25417d4aac0/" rel="bookmark">
			C语言经典算法（1-10）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编程序 1. 编写程序，输入一个正整数n，求下列算式的值。要求定义和调用函数fact(k)计算k的阶乘，函数返回值的类型是double。 #include &lt;stdio.h&gt; double fact(int k) { double t=1; int i; for(i=1;i&lt;=k;i++) t*=i; return t; } void main() { int i,n; double s=0; scanf(“%d”,&amp;n); for(i=1;i&lt;=n;i++) s+=1/fact(i); printf(“%f\n”,s); } 2. 输入一个x，输出下面分段函数f(x)的值。要求将分段函数的计算定义成函数。 #include &lt;stdio.h&gt; int f(double x) // 函数定义 { int y=0; if(x&gt;0) y=1; else if(x==0) y=0; else y=-1; return y; } void main() { double x; int y; scanf(“%lf”,&amp;x); y=f(x); // 函数调用 printf("f(%g)=%d\n",x,y); } 3. 输入一个正整数，输出该数的各个数字之和。要求编写函数，计算整数的各个数字之和。 #include &lt;stdio.h&gt; int sum(int a) { int s=0; while(a!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da31eb14707959cbbef2c25417d4aac0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82fb1e57209e05fcae800cf028a8f272/" rel="bookmark">
			JQuery_九大选择器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		九大选择器都是用来查找元素节点的。JQuery给我提供了九中类型的选择器。
1. 基本选择器 基本选择器是JQuery最常用的选择器，也是最简单的选择器，它通过元素id、class和标签名来查找DOM元素（在网页中id只能使用一次，class允许重复使用）。所谓的网页中id只能使用一次的意思是说，一个网页中的id是不可以重复的，也就是具有唯一性。
1、#id 用法: $("#myDiv"); 返回值 单个元素的组成的集合 说明: 这个就是直接选择html中的id="myDiv" 2、Element 用法: $("div") 返回值 集合元素 说明: element的英文翻译过来是”元素”,所以element其实就是html已经定义的标签元素,例如div, input, a等等. 3、class 用法: $(".myClass") 返回值 集合元素 说明: 这个标签是直接选择html代码中class="myClass"的元素或元素组(因为在同一html页面中 class是可以存在多个同样值的) 4、* 用法: $("*") 返回值 集合元素 说明: 匹配所有元素,多用于结合上下文来搜索 5、selector1, selector2, selectorN 用法: $("div,span,p.myClass") 返回值 集合元素 说明: 将每一个选择器匹配到的元素合并后一起返回.你可以指定任意多个选择器, 并将匹配到的元素合 并到一个结果内。其中p.myClass是表示匹配元素 p class="myClass" 2. 层级选择器 只有这个方法返回的是JQuery对象才能进行链式操作。如果想通过 DOM 元素之间的层次关系来获取特定元素, 例如后代元素, 子元素, 相邻元素, 兄弟元素等, 则需要使用层次选择器。
1 、ancestor descendant 用法: $("form input") ; 返回值 集合元素 说明: 在给定的祖先元素下匹配所有后代元素.这个要和"arent &gt; child"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82fb1e57209e05fcae800cf028a8f272/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfd30072ef217a99f07b73e227047d48/" rel="bookmark">
			文件如何转换成pdf或html格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、使用jacob插件 2、使用方法 1）于word、ppt等上传文件转换为PDF格式文件的环境搭建，步骤如下：
① 首先电脑要先安装office软件（不可以是WPS软件）
② 需要把jacob.dll文件复制到JDK的bin目录下面，否则无法调用转换为PDF的功能。
2）使用的服务器上必须安装有office软件,因为原理是调用office的pdf转换器来实现的。
3）必须也要有PDF软件，因为office要通过调用本地的pdf软件来实现格式的转换。
3、office文件转PDF import java.io.File; import com.jacob.activeX.ActiveXComponent;import com.jacob.com.ComThread;import com.jacob.com.Dispatch; public class OfficeToPdf {private static final int wdFormatPDF = 17;private static final int xlTypePDF = 0;private static final int ppSaveAsPDF = 32; public static void main(String[] args) {convert2PDF("I:\\使用方法.txt","I:\\使用方法.pdf");} /* * 转换生存PDF文件，支持格式 doc docx txt ppt pptx xls xlsx * 1、需安装office软件，并有将office转化为PDF的插件 2、需有jacob(java com bridge）， * java与com组件之间的桥梁 */public static boolean convert2PDF(String inputFile, String pdfFile) {String suffix = getFileSufix(inputFile);File file = new File(inputFile);if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfd30072ef217a99f07b73e227047d48/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/295/">«</a>
	<span class="pagination__item pagination__item--current">296/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/297/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>