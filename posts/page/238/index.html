<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d021245d3120bb2d005d4d6b1fe8957f/" rel="bookmark">
			Error: ER_NOT_SUPPORTED_AUTH_MODE: Client does not support authentication protocol
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		命令行运行node app.js启动应用程序后出现如下错误
Error: ER_NOT_SUPPORTED_AUTH_MODE: Client does not support authentication protocol requested by server; consider upgrading MySQL client at Handshake.Sequence._packetToError
报错的原因是我的MySQL时8.0.16版本，因为版本较高，最新的加密方式node还不支持
解决方法是
win+R快捷键打开命令行
运行如下命令进入mysql命令行 mysql -uroot -p密码 -p后面接你的MySQL数据库密码。
然后运行如下命令
alter user 'root'@'localhost' identified with mysql_native_password by '你的数据库密码'; 注意不要忘了 “ ; ” 号，MySQL命令行语句以分号结尾
注意单引号和 “ ; ”都是英文的
运行过程截图如下：
ok了，然后重新运行node app.js,发现错误消失了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0db2cd773b8f259a44fa0972dc03a46/" rel="bookmark">
			真正解决Cannot resolve org.springframework:spring-test:${spring.version} 报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先我是要引入spring-test依赖，用了${spring.version}这个添加版本，结果就给我报错了，没有成功引入spring-test依赖
解决方法：
方法一：
1、在pom.xml中将spring-test这个依赖修改为以下这样，直接写相应的版本号（依赖可以向下兼容）
&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.2.8.RELEASE&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; 2、但是强调一下：这个spring-test的版本要与你当前使用的spring版本尽量一致，也就是你的其他spring版本依赖一致，假如你使用的是spring 5，那么全部都要使用5.0之后的版本，要版本统一，不然就会报错哦！
3、导入依赖之后，执行成功了！
方法二：
假如还是要使用 xxx.version 来导入依赖版本，那么就得在 pom.xml 中添加相应的配置：
声明之后就可以使用 xxx.version 来引用相应的依赖了。
总结：
在使用 maven 项目构建管理工具添加相应的依赖时，对应的版本号，要么就直接写版本号，要么就就在 pom.xml 中添加配置文件，配置相应的版本，在引用时就直接使用以下方式来引用：
&lt;version&gt;${xxx.version}&lt;/version&gt; 好了，文章结束。
有用点个关注，手留余香！ 😗 😗 😗
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa54f781f5d5599a2bce7724eee94371/" rel="bookmark">
			sql:命名管道管道程序_学习SQL：命名约定
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sql:命名管道管道程序
A naming convention is a set of unwritten rules you should use if you want to increase the readability of the whole data model. Today, I’ll try to explain how you should formulate your naming convention and, maybe even more important, why should you do it and what is the overall benefit from using it. 命名约定是一组不成文的规则，如果要提高整个数据模型的可读性，应使用这些规则。 今天，我将尝试解释您应该如何制定命名约定，甚至可能更重要的是，为什么要这么做以及使用它的总体好处是什么？ 数据模型及简介 (Data Model &amp; the brief introduction) We’ll use the same data model we’re using in this series.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa54f781f5d5599a2bce7724eee94371/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a3ae459b7757b3520f83fbc270faf5d/" rel="bookmark">
			mysql分页是物理分页_学习MySQL：什么是分页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql分页是物理分页
In this article, I am going to explain that in MySQL, what is pagination and how we can implement it. When we are populating a large dataset from the MySQL database, it is not easy to read all the records on the same page. Using pagination, we can divide the result-set into multiple pages, and that increases the readability of the result set. In this article, I am going to explain: 在本文中，我将解释在MySQL中什么是分页以及如何实现它。 当我们从MySQL数据库填充大型数据集时，要读取同一页面上的所有记录并不容易。 使用分页，我们可以将结果集分为多个页面，这可以提高结果集的可读性。 在本文中，我将解释： How to implement pagination with example 如何通过示例实现分页 OFFSET using Page Number 偏移量 The performance overheads and how to deal with it 性能开销以及如何处理 For the demonstration, I have installed MySQL on my workstation.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a3ae459b7757b3520f83fbc270faf5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/804c953fa40db73d0ea8619a23249a41/" rel="bookmark">
			Windows下大数据开发环境安装和配置详细步骤（Java、Maven、IDEA）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、Java下载安装和配置
1、下载Java安装包
2、安装Java 3、配置Java环境变量
4、验证Java是否安装成功
二、Maven下载安装和配置
1、下载Maven安装包
2、安装Maven
3、配置Maven环境变量
4、验证Maven是否安装成功
三、IDEA下载安装和配置
1、下载安装
2、IntelliJ IDEA环境设置
1）配置JDK
2）配置Maven
3）设置编译环境
前言 上周末在进行虚拟机升级的过程中直接导致操作系统瘫痪（没办法理解~），最后是通过重装Win10操作系统才解决的问题，由于格式化了C盘，所以装在C盘的应用软件全没了。。。为了方便进行大数据开发，于是只能再次重新搭建大数据开发环境，具体搭建流程记录如下。
操作系统：Winows10
一、Java下载安装和配置 1、下载Java安装包 官网下载地址：https://www.oracle.com/technetwork/java/javase/downloads/index.html
选择你要的版本点击下载：
2、安装Java 找到下载好的Java安装包，双击打开进行安装，这里我默认安装C盘（这里安装路径可以修改可以安装到其他盘），直接点击下一步，直至安装成功。
3、配置Java环境变量 1）依次点击 我的电脑——&gt;右键——&gt;选择属性——&gt;高级系统设置——&gt;环境变量
2）点击环境变量后，跳出如下图所示对话框，点击 “新建”，随后跳出 “新建系统变量” 对话框，一般来说系统变量中是没有JAVA_HOME的，所以我们在弹出的“新建系统变量”对话框中的“变量名”填入 ：JAVA_HOME ，“变量值 ”填入 ：C:\Program Files\Java\jdk1.8.0_261（安装Java时jdk 所在的文件夹， 默认安装都是在C盘的）。如果已经存在JAVA_HOME的，那么就在它的变量值的最后面加上分号（即；），然后再将 jdk 的路径添加在这个分号的后面。
3）新建系统变量，变量名：CLASSPATH，变量值：.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar （ .; 也要放进去）如下图：
注意：如果已经存在CLASSPATH，则在它的最前面或者最后面添加变量值，如果在最前面添加，应该先添加一个分号（即；），然后再在分号前面添加 .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar （ .; 也要放进去）；如果在最后面添加，应该先添加一个分号（即；），然后再在分号后面添加 .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar （ .; 也要放进去）。
4）双击打开系统变量里面的Path，点击新建按钮，添加变量值：%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin（注意：从分号分开作为两行）。
注意：在window 10系统中，配置Java环境变量时，如果不将 Path 的 变量值：%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin 进行如下图这样配置，不分开两行，则会出错。但是如果你的系统是window 7的话，则可以不分开。
5）记得点击两次确定，如下图：
4、验证Java是否安装成功 按住Window+R ，输入cmd，回车，在cmd命令行分别输入java和javac（可以不区分大小写） ，出现如下图所示的画面而不是“javac不是内部变量……”即表示安装成功。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/804c953fa40db73d0ea8619a23249a41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb2de9c18a410e1cfa7c8b6fa7c81937/" rel="bookmark">
			多线程学习 synchronized加锁 保持数据一致 四
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java中任何对象默认都会有一个互斥锁标记,用来分配给线程。也可以选择这个所标记 没有分配给任何线程/或者只能给一个线程。 只有拿到对象所标记的线程才能进入到对该对象加锁的同步代码块。 同步锁的是对象 线程退出同步代码块（线程执行完毕 确切来说，run方法执行完毕），会释放相应的锁标记。 synchronized 修饰代码块 对象锁标记 上代码
package com.baigu.demo1.stack; public class TestStack { public static void main(String[] args) throws InterruptedException { Stack stack = new Stack(); // stack.print(); // stack.posh('C'); // stack.print(); // stack.pop(); // stack.print(); PushThread t1 = new PushThread(stack); PopThread t2 = new PopThread(stack); stack.print(); System.out.println(); t1.start(); t2.start(); Thread.sleep(1000); //睡一秒让t1 t2线程执行结束在执行主线程 stack.print(); } } class Stack{ private char[] data={'A','B',' ',' ',' ',' ',' ',' '}; private int index=2; //记录数组中有效元素的个数 public void posh(char c){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb2de9c18a410e1cfa7c8b6fa7c81937/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c12a6a65ef5c97c2bab214ab7fcee60/" rel="bookmark">
			ACL访问控制列表理论&#43;实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言第一部分：ACL理论知识1.ACL如何定义规则2.访问控制列表在接口应用的方向3.访问控制列表的处理数据包过程4.两种访问控制列表 第二部分：ACL实验 前言 访问控制列表(Access Control List，简称ACL)是根据报文字段对报文进行过滤的一种安全技术。访问控制列表通过过滤报文达到流量控制、攻击防范以及用户接入控制等功能，在现实中应用广泛。ACL根据功能的不同分为标准ACL和扩展ACL。标准ACL只能过滤报文的源IP地址；扩展ACL可以过滤源IP、目的IP、协议类型、端口号等。ACL的配置主要分为两个步骤：（1）根据需求编写ACL；(2)将ACL应用到路由器接口的某个方向。
第一部分：ACL理论知识 1.ACL如何定义规则 ●读取第三层（ICMP、IP）、第四层（TCP、UDP）包头信息
●访问控制列表利用四个元素定义规则：
第三层：源地址、目标地址
第四层：源端口、目标端口
2.访问控制列表在接口应用的方向 ●入接口：已到达路由器接口的数据包，将被路由器处理（对本机生效）
●出接口：已经过路由器的处理，正离开路由器接口的数据包（对本机无效）
3.访问控制列表的处理数据包过程 顺序匹配执行；隐含的拒绝所有
至少permit一条，否则ACL没有意义
4.两种访问控制列表 ●标准访问控制列表：
基于源IP地址过滤数据包
标准访问控制列表的访问控制列表号是2000-2999
●扩展访问控制列表：
基于源IP地址、目的IP地址、指定协议、端口和标志来过滤数据包
扩展访问控制列表的访问控制列表号是3000-3999
第二部分：ACL实验 需求：
1.全网互通
2.用ACL标准列表禁止vlan10和vlan20通信
3.用ACL扩展列表禁止AR1访问ftp访问器
1.实现全网互通
二层交换机：
连接4台PC用access，向上到路由器配置trunk
路由器R1配置：
路由器R2配置：
现在已经实现了全网互通。
2.用ACL标准列表禁止vlan10和vlan20通信
写列表：
靠近目标处接口（出）调用列表：
现在vlan10和vlan20无法通信
3.用ACL扩展列表禁止AR1访问ftp访问器
开启服务器中的ftp配置，现在R1中可以访问ftp服务器
在R2上配置ACL
接口（入）下调用
这时R1无法访问ftp服务器
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e862b075bcd2e7980688761eca3bc812/" rel="bookmark">
			项目框架、例程及源码分析、视频教程在4412开发板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/340a79dcba3d3b78b0351b6492433ce5/" rel="bookmark">
			IntelliJ IDEA 2020.2 稳定版发布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IntelliJ IDEA 2020.2 稳定版发布 转载：https://www.oschina.net/news/117535/intellij-idea-2020-2-released
转载理由：还可以
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eee6e2757914ccb816367d51fcfcca2b/" rel="bookmark">
			Vue 倒计时插件 vue2-countdown
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue2-countdown 基于vue2.0的活动倒计时组件
可以使用服务端当前时间
在倒计时开始或者结束的时候,可以自定义回调
文档：https://cgygd.github.io/vue2-countdown/
demo：https://cgygd.github.io/vue2-countdown/example/index.html
示例.png
安装 1.cnpm/npm
npm install vue2-countdown --save 2.Git 下载源码
git clone https://github.com/cgygd/vue2-countdown 使用 &lt;count-down v-on:end_callback="countDownE_cb()" :currentTime="currentTime" :startTime="startTime" :endTime="endTime" :tipText="'距离订单开始还有'" :tipTextEnd="'距离订单关闭还剩'" :endText="'订单已关闭'" :dayTxt="'天'" :hourTxt="'小时'" :minutesTxt="'分钟'" :secondsTxt="'秒'"&gt; &lt;/count-down&gt; import CountDown from 'vue2-countdown' components: { CountDown }, data() { return { currentTime:0, startTime:0, endTime:0, } }, methods: { countDownS_cb: function (x) { console.log(x) }, countDownE_cb: function (x) { console.log(x) } } 参数解释 currentTime -- 当前时间戳,如果不传,默认获取用户本地的时间(建议传服务器的当前时间)
type: Number
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eee6e2757914ccb816367d51fcfcca2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14925cad489b49a9166391ddab5ae79f/" rel="bookmark">
			数据结构与算法系列（二）—冒泡排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 大家好，本系列开始对排序算法进行总结。牧码心今天给大家推荐一篇数据结构与算法系列（二）—冒泡排序的文章，希望对你有所帮助。大纲如下:
基本介绍图文说明时间复杂度和稳定性具体实现 基本介绍 冒泡排序(Bubble Sort)，又被称为气泡排序或泡沫排序。 它是一种较简单的排序算法。它会遍历若干次要排序的数列，每次遍历时，它都会从前往后依次的比较相邻两个数的大小；如果前者比后者大，则交换它们的位置。这样，一次遍历之后，最大的元素就在数列的末尾！ 采用相同的方法再次遍历时，第二大的元素就被排列在最大元素之前。重复此操作，直到整个数列都有序为止！
图文说明 下面以数列{20,40,30,10,60,50}为例，演示它的冒泡排序过程(如下图)
说明
我们先分析第1趟排序
当i=5,j=0时，a[0]&lt;a[1]。此时，不做任何处理！
当i=5,j=1时，a[1]&gt;a[2]。此时，交换a[1]和a[2]的值；交换之后，a[1]=30，a[2]=40。
当i=5,j=2时，a[2]&gt;a[3]。此时，交换a[2]和a[3]的值；交换之后，a[2]=10，a[3]=40。
当i=5,j=3时，a[3]&lt;a[4]。此时，不做任何处理！
当i=5,j=4时，a[4]&gt;a[5]。此时，交换a[4]和a[5]的值；交换之后，a[4]=50，a[3]=60。
于是，第1趟排序完之后，数列{20,40,30,10,60,50}变成了{20,30,10,40,50,60}。此时，数列末尾的值最大。
以此类推：
第2趟排序完之后，数列中a[5…6]是有序的。
第3趟排序完之后，数列中a[4…6]是有序的。
第4趟排序完之后，数列中a[3…6]是有序的。
第5趟排序完之后，数列中a[1…6]是有序的。
第5趟排序之后，整个数列也就是有序的了。
逻辑过程（伪代码）
从观察上面冒泡排序的流程图，第3趟排序之后，数据已经是有序的了；第4趟和第5趟并没有进行数据交换。下面我们对冒泡排序进行优化，使它效率更高一些：添加一个标记，如果一趟遍历中发生了交换，则标记为true，否则为false。如果某一趟没有发生交换，说明排序已经完成！ void bubble_sort2(int a[], int n) { int i,j; int flag; // 标记 for (i=n-1; i&gt;0; i--) { flag = 0; // 初始化标记为0 // 将a[0...i]中最大的数据放在末尾 for (j=0; j&lt;i; j++) { if (a[j] &gt; a[j+1]) { swap(a[j], a[j+1]); flag = 1; // 若发生交换，则设标记为1 } } if (flag==0) break; // 若没发生交换，则说明数列已有序。 } } 时间复杂度和稳定性 冒泡排序时间复杂度
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14925cad489b49a9166391ddab5ae79f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5a5fc0caa0cae2c06c9ab411da26cf2/" rel="bookmark">
			python中利用Sklearn和Scipy分别实现核密度估计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		密度估计问题 由给定样本集合求解随机变量的分布密度函数问题是概率统计学的基本问题之一。解决这一问题的方法有参数估计和非参数估计。非参数估计包含核密度估计。
离散型随机变量 概率函数：就是用函数的形式来表达概率；
概率分布：
概率分布函数（简称分布函数）：就是概率函数取值的累加结果，所以它又叫累积概率函数、累积概率分布、累积分布函数。
连续型随机变量 概率函数又称为概率密度函数，某点的概率密度即为概率在该点的变化率；
概率密度函数是分布函数的导函数。
Sklearn实现核密度估计 Sklearn中实现核密度估计的方法：均匀核函数、三角核函数、伽马核函数、高斯核函数等。
以高斯核密度估计为例画出概率密度函数曲线（连续变量）：
import numpy as np import matplotlib.pyplot as plt from sklearn.neighbors.kde import KernelDensity # 导入核密度估计 X = X.reshape(-1, 1) # 转换成2D array X_plot = np.linspace(0, 0.1, 1000)[:, np.newaxis] # [:,np.newaxis] # 也能转换成2D array kde = KernelDensity(kernel='gaussian', bandwidth=0.75).fit(X) # 高斯核密度估计 log_dens = kde.score_samples(X_plot) # 返回的是点x对应概率密度的log值，需要使用exp求指数还原 ##params=kde.get_params() plt.figure(figsize = (10, 8)) # 设置画布大小 plt.plot(X_plot, np.exp(log_dens), marker='.', linewidth=1, c="b", label='核密度值') plt.tick_params(labelsize = 20) # 设置坐标刻度值的大小 font = {'size': 20} # 设置横纵坐标的名称以及对应字体格式、大小 plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5a5fc0caa0cae2c06c9ab411da26cf2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b95d1cc3a40e49818905216762f6d471/" rel="bookmark">
			快速而深入地了解TypeScript及其类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		by David Piepgrass
由David Piepgrass 快速而深入地了解TypeScript及其类型 (A quick yet in-depth tour of TypeScript and its types) 联合类型，泛型，JSX，类型系统漏洞等等！ (Union types, generics, JSX, type system loopholes and more!) This quick tour of TypeScript is mainly for people who have some experience with JavaScript.
快速浏览TypeScript主要是针对具有JavaScript经验的人。 I’ll explain a few surprising facts about JavaScript, too, in case you only studied something vaguely similar, like Java or C#. If you’d like to know how to set up a TypeScript project, see my previous article.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b95d1cc3a40e49818905216762f6d471/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04874c18c42ce4cbadfec5d401d4e3e2/" rel="bookmark">
			C语言头文件路径剖析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在一个软件项目中，如果需要在一个文件中包含另一个头文件时，一般有两种包含方式：
#include &lt;stdio.h&gt;#include “module.h” 如果你引用的头文件是标准库的头文件或官方路径下的头文件，一般使用尖括号 &lt;&gt; 包含；如果你使用的头文件是自定义的或项目中的头文件，一般使用双引号 "" 包含。头文件路径一般分为绝对路径和相对路径：绝对路径以根目录 / 或者Windows下的每个盘符为路径起点；相对路径则是以程序文件当前的目录为起点。
​​​​​​​
#include ”/home/wit/code/xx.h” //Linux下的绝对路径#include “F:/litao/code/xx.h" //Windows下的绝对路径#include ”../lcd/lcd.h” //相对路径，..表示当前目录的上一层目录#include ”./lcd.h” //相对路径，.表示当前目录#include ”lcd.h” //相对路径，当前文件所在的目录 编译器在编译过程中会按照这些路径信息到指定的位置去查找头文件，然后通过预处理器作展开处理。在查找头文件的过程中，编译器会按照默认的搜索顺序到不同的路径下面去搜索，以 #include &lt;xx.h&gt; 为例，当我们使用尖括号 &lt;&gt; 包含一个头文件时，头文件的搜索顺序为：
• 通过GCC参数 gcc-I 指定的目录（注：大写的 i）
• 通过环境变量 CINCLUDEPATH 指定的目录
• GCC 的内定目录
• 搜索规则：当不同目录下存在相同的头文件时，先搜到那个使用哪个，搜索停止
当我们使用双引号 “” 来包含头文件路径时，编译器会首先到项目当前目录去搜索需要的头文件，在当前项目目录下面搜不到，再到其他指定的路径下面去搜索：
• 项目当前目录
• 通过 GCC 参数 gcc-I 指定的目录
• 通过环境变量 CINCLUDEPATH 指定的目录
• GCC 的内定目录
• 搜索规则：当不同目录下存在相同的头文件时，先搜到那个使用哪个
在编译程序时，如果我们的头文件没有放到官方路径下面，我们可以通过 gcc -I 来指定头文件路径，编译器在编译程序时，就会到用户指定的路径目录下面去搜索该头文件。如果你不想通过这种方式，也可以通过设置环境变量来添加头文件的搜索路径。在 Linux 环境下我们经常使用的环境变量有：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04874c18c42ce4cbadfec5d401d4e3e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfb491d9e5281b197f68952c0cfa6a31/" rel="bookmark">
			视觉SLAM十四讲（第二版）阅读笔记 第二讲 初识SLAM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2.1举例 具有自主运动能力的机器人需要什么技术支撑？
首先它得会动，其次，“自主”，必须需要它掌握两个知识：
我在哪？（内部自身具体定位）我周围有什么？（外部环境整体建图） GPS或者周围环境感应，可以解决这两个知识的获取问题，但这两个技术受制精度与成本等，未必是最好的选择。
而SLAM技术，尤其强调未知环境，以不变应万变。这样的技术可以适合更多种类的场景，实现过程也会更加简便。
视觉SLAM主要分为单目，双目以及深度（RGB-D）三种相机，但基本原理和单目均相似。
单目相机：成本低，但由于单目无法获取深度，只能通过视频中各种物体运动产生的视差，判断物体的远近和相对大小 ，因此单目相机具有尺度不确定性。双目相机：获得了深度信息，可以确定尺度信息，但是要计算每个点的深度，算力要求较高。深度相机：通过红外结构光或ToF原理，前两个技术只通过软件计算，而深度相机直接发射光并计算距离，计算大大简化。但目前还有噪声，视野小，易受强光干扰等缺点。室内比较适合。 2.2经典视觉SLAM框架 SLAM流程主要包括
传感器信息读取：相机信息读取及预处理前端视觉里程计（visual Odometry）：估算相邻图像间相机的运动以及局部地图的样子后端（非线性）优化：接受不同时刻VO测量的相机位姿，以及回环检测的信息，对其进行优化，得到全局一致的轨迹与地图回环检测（loop closure detection）：判断机器人事都到达过先前的位置，如果检测到回环，则会把信息提供给后端处理建图：根据估计的轨迹建立与任务要求对应的地图 在VSLAM中，前端与计算机视觉更相关，如特征提取和匹配；后端主要是滤波和非线性优化算法。
如果是静态、刚体、光照变化不明显、没有人为干扰的工作场景，那么这个技术框架是相当成熟的了。
2.2.1视觉里程计 主要关心相邻图像间的相机运动，并根据它恢复场景的空间结构
只计算相邻时间内的运动，如相邻2帧或5-10帧。
易产生累计漂移Acumulating Drift，因为误差会不断传递到下一次的计算中。
漂移Drift的直接影响是每次地图建立会存在不一致（图2-9非常直观地展现了这个现象）。
后端优化以及回环检测就是用来修正漂移的。
2.2.2后端优化 主要用来处理测量误差。从带有噪声的数据中估计整个系统的状态（自身轨迹&amp;地图），以及估计的不确定性，即最大后验概率估计Maximum-a-Posteriori MAP。
后端的问题也是SLAM的主要问题——对运动主体自身和周围环境空间不确定性的估计。
因此我们需要状态估计理论，把定位和建图的不确定性表达出来，然后采用滤波器或非线性优化，估计状态的均值和不确定性（方差）。
2.2.3回环检测 如果机器人回到某处，但是由于漂移，位置估计发生了偏差，这个时候就需要做回环检测
主要的手段就是通过输入的图像的相似性去判断他们是不是同一个地方。检测到之传递给后端优化，然后就可以对轨迹和地图进行调整。
2.2.4建图 建的地图会根据实际需求调整其特点，地图种类大致分为2种：
度量地图：强调物体位置关系，简单定位的时候使用稀疏sparse地图，只标注重要地标（但墙可能就标了），复杂导航的时候使用稠密dense地图，任意位置都有方格表达信息，因此耗空间，也容易出现不一致问题。拓扑地图：强调地图元素之间的关系，只有节点、边和连通情况，表达更紧凑，适合简单结构地图。 2.3 SLAM问题的数学表述 假设地图由多个路标组成，每个时刻相机或传感器会测量到一部分路标点
2.3.1 基本变量 离散时刻 t t t = 1 , . . . , K 1, ... , K 1,...,K
相机各时刻位置 x 1 , . . . , x K x_1,...,x_K x1​,...,xK​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfb491d9e5281b197f68952c0cfa6a31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6e8b07aa489c0b46cb3c7b0a5c55fd1/" rel="bookmark">
			学习多线程  造成线程不同步的原因 数组实现简单的栈  三
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java代码
package com.baigu.demo1.stack; public class TestStack { public static void main(String[] args) throws InterruptedException { Stack stack = new Stack(); // stack.print(); // stack.posh('C'); // stack.print(); // stack.pop(); // stack.print(); PushThread t1 = new PushThread(stack); PopThread t2 = new PopThread(stack); stack.print(); System.out.println(); t1.start(); t2.start(); Thread.sleep(1000); //睡一秒让t1 t2线程执行结束在执行主线程 stack.print(); } } class Stack{ private char[] data={'A','B',' ',' ',' ',' ',' ',' '}; private int index=2; //记录数组中有效元素的个数 public void posh(char c){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6e8b07aa489c0b46cb3c7b0a5c55fd1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91ed8fab46ef22801a654a2d6b59ccb1/" rel="bookmark">
			Http加密流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们先来看看HTTPS的加解密流程。
HTTPS加解密流程
用户在浏览器发起HTTPS请求（如 https://www.mogu.com/），默认使用服务端的443端口进行连接；
HTTPS需要使用一套CA数字证书，证书内会附带一个公钥Pub，而与之对应的私钥Private保留在服务端不公开；
服务端收到请求，返回配置好的包含公钥Pub的证书给客户端；
客户端收到证书，校验合法性，主要包括是否在有效期内、证书的域名与请求的域名是否匹配，上一级证书是否有效（递归判断，直到判断到系统内置或浏览器配置好的根证书），如果不通过，则显示HTTPS警告信息，如果通过则继续；
客户端生成一个用于对称加密的随机Key，并用证书内的公钥Pub进行加密，发送给服务端；
服务端收到随机Key的密文，使用与公钥Pub配对的私钥Private进行解密，得到客户端真正想发送的随机Key；
服务端使用客户端发送过来的随机Key对要传输的HTTP数据进行对称加密，将密文返回客户端；
客户端使用随机Key对称解密密文，得到HTTP数据明文；
后续HTTPS请求使用之前交换好的随机Key进行对称加解密。
对称加密：一个密钥，加密和解密用同一个密钥
非对称加密：公钥加密，私钥解密
自己将公钥发送给服务端；服务端使用公钥对数据加密后发送给用户；公钥可以公开给别人进行加密，私钥永远在自己手里，非常安全
服务端自己有一个公钥进行加密，发给客户端公钥，客户端使用公钥对需要发送的数据进行加密后，发送到服务端，服务端使用自己的私钥进行解密。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b100bc83d3374aa636b35e219ec6b44/" rel="bookmark">
			Ubuntu18.04忘记密码如何重置密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近服务器上的两个账户黑掉了，账户的密码被篡改了，幸好还有一个账户可以用，可以确认原来的账户还存在，所以首先想到的办法就是如果把篡改的密码改过来，终于终于耗时五个小时把问题解决了，也可能是我头一次遇到这种问题，上手比较慢，话不多说，直奔主题。。。
在网上其实可以搜到很多如何修改密码的博客，但是都不太实用，而且是在AMAX服务器上，按照前人的方法来做，第一步总是行不通，最后在其他帖子里偶然看到一句话再加上前面看的一些帖子，最后把问题解决了，详细步骤如下：
第一步：
首先确认自己的机器如何进入GNU GRUB，这一步很重要，很多机器是开机按住Shift不松，然而我们的机器需要按Esc，而且最好不要按住Esc不松，然而这样很容易计入GRUB命令行输入界面，所以最好是不断的点击Esc，看到黑屏时就松手，进入的界面如下所示，选择“Advanced option for Ubuntu”，点击回车。
第二步：
选择带有（recovery mode）,不要点击回车，不要点击回车，按下E键，进入下一个界面。
第三步：
将红框内的“recovery nomodeset”改为“quiet splash rw init=/bin/bash”
第四步：
接着按F10或者Ctrl+x 后出现如下界面，在命令行内输入passwd后进行修改密码即可
第五步：
关机，或者强制关机后，就能用新设置的密码登录了。
总结
以上所述是小编给大家介绍的Ubuntu18.04服务器密码忘记或被篡改如何重置密码,希望对大家有所帮助，如果大家有任何疑问请给我留言，小编会及时回复大家的。在此也非常感谢大家对脚本之家网站的支持！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d87e1a8fe296a0058487af586cfa4514/" rel="bookmark">
			【算法导论04】贪心算法-kruskal算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		04贪心算法-kruskal算法 问题描述：
给定一个无向图，设计算法找出其中的最小生成树。
思路分析：
kruskal算法属于贪心算法，因此满足贪心算法的本质：局部最优解一定是全局最优解。在最小生成树中的应用即为，一个无向图中包含最小权值边点两个点，一定在最小生成树中，因此，只需要对该无项图中的顶点进行排序，按顺序找出边权值最小的顶点即可。但这个问题实际包含了两个问题：
1、如何对边进行排序？
2、如果新加入的边使得该最小生成树形成回路，如何解决？
针对 问题1：对无向图的各个边进行从小到大的堆排序（堆排序在此处的应用时间复杂度最低）
针对 问题2：将无向图的边加入并查集，通过并查集来判断是否构成环路，如果构成环路，即跳过该边。
（注：由于本文着重讲解kruskal算法，堆排序部分便不再赘述，下方算法也直接调用该函数）
算法分析：
假设无向图的边已经按照从小到大顺序排好，则此时kruskal算法的内核就是并查集的使用。kruskal算法步骤如下：
1、初始化一个parent数组，用于构造一棵树，数组下标为根序号，数组值为顶点序号，如parent[3]=4表示顶点4的根为3。
2、按照边权值由小到大的顺序，依次扫描边，并找出该边中顶点的根，如果新加入的边的顶点的根与已经加入边的顶点的根不相等，则将两个边进行合并，即将新的边加入最小生成树；如果新加入的边的顶点的根与已经加入顶点的根相等，则构成环路，舍弃该边，继续执行。
3、循环上述步骤。
笔记：（-from MIT算法导论课程）
kruskal算法代码：
#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #define vertices 6 //对并查集进行初始化，所有值初始化为-1 void initialise(int parent[],rank[]){ int i; for(i=0;i&lt;vertices;i++){ parent[i] = -1; rank[i] = 0; } } //找根结点，用于连接和判断 int find_root(int x,int parent[]){ int x_root = x; if(x_root!=-1){ x_root = parent[x_root]; } return x_root; } //并查集主体，找到根后，判断根是否相同，如果相同，则有环，如果不同，则进行连接 void union_vertices(int x,int y,int parent[],rank[]){ //当根不相等时：谁的根高，谁就做父结点。 if(rank[x_root] &gt; rank[y_root]){ parent[y_root] = x_root; }else if(rank[y_root] &gt; rank[x_root]){ parent[x_root] = y_root; }else{ parent[x_root] = y_root; rank[y_root]++; } } //结构体定义边的两个顶点和权重 typedef struct edge{ int a,b; int weight; } //kruskal算法 void MST_kruskal(graph g,edge *edges,int parent[],int rank[]){ //对边权重进行堆排序 heap_sort(edges); //对边进行循环，找边的两个顶点的根，如果根不相等，则进行连接 for(int i=0;i&lt;vertices;i++){ int a_root=find_root(edge[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d87e1a8fe296a0058487af586cfa4514/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0c67d9a358370c708186b6309485c53/" rel="bookmark">
			ssm整合“保姆级”教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 前言 学习了有一段时间了，总算是把后端三大框架ssm学完了，今天就来整合一下ssm。
二. 整合步骤 创建web工程导入相应的jar包，特别注意：Spring整合Mybatis需要导入jar包（mybatis-spring-1.3.0.jar）配置外部属性文件 db.properties driver=com.mysql.jdbc.Driver url=jdbc:mysql://localhost:3306/ssm?characterEncoding=utf-8&amp;useUnicode=true user=root password=123456 maxSize=10 initSize=5 编写Spring配置文件 applicationContext.xml &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:mybatis-spring="http://mybatis.org/schema/mybatis-spring" xsi:schemaLocation="http://mybatis.org/schema/mybatis-spring http://mybatis.org/schema/mybatis-spring-1.2.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd"&gt; &lt;!-- 配置自动扫描的包 --&gt; &lt;context:component-scan base-package="com.nhkj"&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.web.bind.annotation.ControllerAdvice"/&gt; &lt;/context:component-scan&gt; &lt;!-- 配置数据源，导入外部属性文件 --&gt; &lt;context:property-placeholder location="classpath:db.properties"/&gt; &lt;!-- 配置连接池 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="jdbcUrl" value="${url}"&gt;&lt;/property&gt; &lt;property name="driverClass" value="${driver}"&gt;&lt;/property&gt; &lt;property name="user" value="${user}"&gt;&lt;/property&gt; &lt;property name="password" value="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0c67d9a358370c708186b6309485c53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93da370468c043d6e5506b7a58699e18/" rel="bookmark">
			MoM矩量法（三）：激励矩阵以及方程求解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MoM矩量法（三）：激励矩阵以及方程求解 填充完阻抗矩阵之后就是激励矩阵的填充以及方程的求解了。激励矩阵比较简单，后面矩阵方程的求解也可以采用库函数来完成。
这里采用的公式来自于聂在平主编的《目标与环境 电磁散射特性建模——理论、方法与实现（应用篇）》，所有数据均采用国际标准单位。
完整代码已贴在文章最后。文章和代码思路借鉴了https://blog.csdn.net/u014411646/article/details/99689460，谢谢原作者！ 一、激励矩阵 上式中各符号的含义： E θ θ E_\theta\theta Eθ​θ和 E ϕ ϕ E_\phi\phi Eϕ​ϕ代表 θ \theta θ方向极化电场和 ϕ \phi ϕ方向极化电场，在这里我们只考虑二者其一，而不考虑其他极化方向的入射波。所以，当确定了极化方向时，上式中的 E θ θ + E ϕ ϕ E_\theta\theta+E_\phi\phi Eθ​θ+Eϕ​ϕ只需要保留一个即可； k i k_i ki​为入射方向单位向量；其他变量与MoM矩量法（二）：阻抗矩阵的填充定义的变量一致。 核心代码： cx_vec setVm(rowvec ei) { cx_vec vm(EdgeTotal); for (int i = 0;i &lt; EdgeTotal;i++) { Complex temp = 0; for (int k = 0;k &lt; 4;k++) { rowvec rlmk(3); rlmk(0) = xx[k] * pdata(Edge_list(i, 2), 0) + yy[k] * pdata(Edge_list(i, 0), 0) + zz[k] * pdata(Edge_list(i, 1), 0); rlmk(1) = xx[k] * pdata(Edge_list(i, 2), 1) + yy[k] * pdata(Edge_list(i, 0), 1) + zz[k] * pdata(Edge_list(i, 1), 1); rlmk(2) = xx[k] * pdata(Edge_list(i, 2), 2) + yy[k] * pdata(Edge_list(i, 0), 2) + zz[k] * pdata(Edge_list(i, 1), 2); rowvec rrmk(3); rrmk(0) = xx[k] * pdata(Edge_list(i, 3), 0) + yy[k] * pdata(Edge_list(i, 1), 0) + zz[k] * pdata(Edge_list(i, 0), 0); rrmk(1) = xx[k] * pdata(Edge_list(i, 3), 1) + yy[k] * pdata(Edge_list(i, 1), 1) + zz[k] * pdata(Edge_list(i, 0), 1); rrmk(2) = xx[k] * pdata(Edge_list(i, 3), 2) + yy[k] * pdata(Edge_list(i, 1), 2) + zz[k] * pdata(Edge_list(i, 0), 2); temp += ww[k] * (exp(-J * k0 * getDot(ki, rlmk)) * getDot(ei, rlmk - pdata.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93da370468c043d6e5506b7a58699e18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eec1e39074eea62da23a2f300d8ab131/" rel="bookmark">
			HTTPS工作原理及报文讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 HTTPS 1.1 HTTPS简介 HTTPS (Secure Hypertext Transfer Protocol)安全超文本传输协议，是一个安全通信通道，它基于HTTP开发用于在客户计算机和服务器之间交换信息。它使用安全套接字层(SSL)进行信息交换，简单来说它是HTTP的安全版,是使用TLS/SSL加密的HTTP协议。 SSL (Secure Sockets Layer）安全套接层。是由Netscape公司于1990年开发，用于保障Word Wide Web（WWW）通讯的安全。主要任务是提供私密性，信息完整性和身份认证。1994年改版为SSLv2,1995年改版为SSLv3。
TLS(Transport Layer Security）安全传输层协议。用于在两个通信应用程序之间提供保密性和数据完整性。该标准协议是由IETF于1999年颁布，整体来说TLS非常类似SSLv3，只是对SSLv3做了些增加和修改。
TLS/SSL全称安全传输层协议Transport Layer Security, 是介于TCP和HTTP之间的一层安全协议，不影响原有的TCP协议和HTTP协议，所以使用HTTPS基本上不需要对HTTP页面进行太多的改造。
1.2 HTTP和HTTPS区别 1、https协议需要到CA申请证书，一般免费证书较少，因而需要一定费用。
2、http是超文本传输协议，采用明文传输信息，存在信息窃听、信息篡改和信息劫持的风险。https则是具有安全性的ssl/tls加密传输协议。而协议TLS/SSL具有身份验证、信息加密和完整性校验的功能，可以避免此类问题发生。
3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443；使用的URL也不一样，前者为http//:URL，后者为https//:URL。
4、http的连接很简单，是无状态的；HTTPS协议是由SSL/TLS+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。
1.3 TLS/SSL协议工作原理 1.3.1 TLS/SSL协议结构 SSL是一个不依赖于平台和运用程序的协议，位于TCP/IP协议与各种应用层协议之间，为数据通信提高安全支持。SSL协议结构如下图：
图：SSL协议结构图
SSL的体系结构中包含两个协议子层，其中底层是SSL记录协议层（SSL Record Protocol Layer）；高层是SSL握手协议层（SSL HandShake Protocol Layer）。
SSL协议主要分为两层：
SSL记录协议层的作用是为高层协议提供基本的安全服务。SSL纪录协议针对HTTP协议进行了特别的设计，使得超文本的传输协议HTTP能够在SSL运行。纪录封装各种高层协议，具体实施压缩解压缩、加密解密、计算和校验MAC等与安全有关的操作。
SSL握手协议层包括SSL握手协议（SSL HandShake Protocol）、SSL密码参数修改协议（SSL Change Cipher Spec Protocol）和SSL告警协议（SSL Alert Protocol）。握手层的这些协议用于SSL管理信息的交换，允许应用协议传送数据之间相互验证，协商加密算法和生成密钥等。
SSL握手协议的作用是协调客户和服务器的状态，使双方能够达到状态的同步。
其中最重要的是记录协议和握手协议：
SSL记录协议：它建立在可靠的传输（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能。
SSL握手协议：它建立在SSL记录协议之上，用于在实际的数据传输开始之前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。
注：本文主要介绍SSL握手协议，省略SSL记录协议
1.3.2 SSL/TLS握手协议建立连接过程 SSL 握手协议是SSL 协议中最重要同时也是最复杂的协议。
SSL 握手协议主要负责如下工作：
1、算法协商 2、身份验证
3、确定密钥
SSL握手过程分为四种:
1、Full Handshake : 全流程握手，C/S双方从无到有建立SSL连接；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eec1e39074eea62da23a2f300d8ab131/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d15944bf924e588ce51ceec2ad5ff18f/" rel="bookmark">
			Android计算器代码分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 学习Android写的第一个app，前前后后用了近一周的时间，建议刚开始写的先预算好自己要处理的异常，最好全面详细的列出来，避免和我一样后期花费很大功夫进行各种预算处理。接下来分享一下我做的计算器。 真机测试如下 效果渲染 按钮点击变色 首先在Android Studio（app/src/main/res/drawable）文件夹中创建一个Drawable resource file，这里我创建的是change.xml，change1.xml（因为我的按钮背景有两个颜色所以创建两个）,在Button添加背景时使用，修改代码如下 这里的drawable="@color/colorPrimary"，可在res/values/colors.xml中添加你自己喜欢的，添加后可这样使用 &lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:drawable="@color/colorPrimary" android:state_enabled="true"	//接受触摸或者点击事件 android:state_pressed="true"	//被点击时 /&gt; &lt;item android:drawable="@color/colorchange0" android:state_enabled="true" android:state_pressed="false"/&gt; //未被点击时 &lt;/selector&gt; 字体自适应显示框而改变大小 先看效果 这里建议使用autoSizeTextType=“uniform”//字体自适应功能一两行就搞定（做完才知道的，不懂得可百度） 我在这里是使用了多线程（网上看到如果直接用getLineCount()方法，获取的行数不准确），在多线性中获取getLineCount()获取此时的行数，然后经过一系列的判断设置setTextSize（），注意：这种方法在按C/del时要做判断 textView_1.post(new Runnable() { @Override public void run() { int line = textView_1.getLineCount(); if(line==1 &amp;&amp; flag3==0){ textView_1.setTextSize(80); flag3 = 1;	//这里是我定义的用于判断行数的全局变量 } if(line==2 &amp;&amp; flag1==0){ length1 = str.length()-1; Log.d("mainActivity","length1"+ +length1); textView_1.setTextSize(60); flag1 = 1; } if(line==3 &amp;&amp; flag2==0){ length2 = str.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d15944bf924e588ce51ceec2ad5ff18f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d046d3b2404bb9b36a75bea3a3e890ee/" rel="bookmark">
			解决Mysql replication error 1594 - Relay log read failure - Could not parse relay log event entry
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mysql复制错误1594-中继日志读取失败-无法解析中继日志事件条目 错误信息：
Relay log read failure: Could not parse relay log event entry. The possible reasons are: the master's binary log is corrupted (you can check this by running 'mysqlbinlog' on the binary log), the slave's relay log is corrupted (you can check this by running 'mysqlbinlog' on the relay log), a network problem, or a bug in the master's or slave's MySQL code. If you want to check the master's binary log or slave's relay log, you will be able to know their names by issuing 'SHOW SLAVE STATUS' on this slave.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d046d3b2404bb9b36a75bea3a3e890ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/957ce82bbd1d2c5f40c56f94d2a13006/" rel="bookmark">
			常用adb命令整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.清空app缓存
adb shell pm clear 包名
2.查看app当前运行的activity
adb shell “dumpsys window | grep mCurrentFocus”
adb -s 设备名 shell “dumpsys window | grep mCurrentFocus”
adb shell dumpsys activity | findstr “mFocusedActivity”
3.端口转发命令
adb forward tcp:27042 tcp:27042
adb forward tcp:27043 tcp:27043
4.根据端口连接模拟器命令
adb connect 127.0.0.1:54011
5.启动app
adb shell am start -n 包名/.Activity
6.查看手机中安装的app（包名）
adb shell pm list packages
7.强制关闭app
adb shell am force-stop 包名
8.根据坐标点击
adb shell input tap 420 100
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/957ce82bbd1d2c5f40c56f94d2a13006/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bb47fb3815a1314f5b3968cc497d8f9/" rel="bookmark">
			解决 SpringBoot 2.3.1 图片上传至根目录下 需要重新编译或者重启才能访问到图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决 SpringBoot 2.3.1 图片上传至根目录下 需要重新编译或者重启才能访问到图片 首先 添加一个配置文件
@Configuration public class WebMvcConfig implements WebMvcConfigurer { @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { // 告知系统static 当成 静态资源访问 String path = System.getProperty("user.dir") + "\\src\\main\\resources\\static\\carousel\\"; registry.addResourceHandler("/static/**").addResourceLocations("classpath:/static/"); registry.addResourceHandler("/carousel/**").addResourceLocations("file:"+path); } } 实现图片上传完可以直接访问 无需重启
另外 ctrl +shift +alt+ / 进入 registry
打开running这个选项
然后
选中这个选项
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e60b12fd6f7e1ee66e084beff8b72473/" rel="bookmark">
			从天气预报网页API获取天气预报数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用Java代码获取中央气象局的天气预报数据 版权声明：数据版权归中央气象局所有，仅供学习交流之用。本文内容若有侵权，请联系我删除~
文章目录 用Java代码获取中央气象局的天气预报数据1 获取相关接口2 省份获取接口数据3 城市获取接口数据4 城市天气预报获取接口数据5 使用Java代码提取数据 1 获取相关接口 通过解析html页面后，发现有如下3个接口：
省份获取：http://www.nmc.cn/rest/province城市获取：http://www.nmc.cn/rest/province/{省份代码}城市天气预报获取：http://www.nmc.cn/rest/weather?stationid={城市代码} 2 省份获取接口数据 接口：http://www.nmc.cn/rest/province 【测试一下】
返回数据：
[ {"code":"ABJ","name":"北京市","url":"/publish/forecast/ABJ.html"}, {"code":"ATJ","name":"天津市","url":"/publish/forecast/ATJ.html"}, {"code":"AHE","name":"河北省","url":"/publish/forecast/AHE.html"}, {"code":"ASC","name":"四川省","url":"/publish/forecast/ASC.html"}, ... ... {"code":"ATW","name":"台湾省","url":"/publish/forecast/ATW.html"} ] 注意：这里的code键的值为城市获取的参数，如四川的参数为：ASC
3 城市获取接口数据 接口：http://www.nmc.cn/rest/province/ASC【测试一下】
[ {"code":"56294","province":"四川省","city":"成都","url":"/publish/forecast/ASC/chengdu.html"}, {"code":"56171","province":"四川省","city":"阿坝","url":"/publish/forecast/ASC/aba.html"}, ... ... {"code":"56498","province":"四川省","city":"筠连","url":"/publish/forecast/ASC/yunlian.html"} ] 注意：这里的城市包括各市的区县，比如上面展示的筠连就是四川省宜宾市的辖县，这里code键的值就是访问城市天气数据接口的参数。
4 城市天气预报获取接口数据 接口：http://www.nmc.cn/rest/weather?stationid=56294【测试一下】
{ "msg":"success", "code":0, "data": { "real": { "station":{"code":"56294","province":"四川省","city":"成都","url":"/publish/forecast/ASC/chengdu.html"}, "publish_time":"2020-07-26 22:25", "weather":{"temperature":24.9,"temperatureDiff":2.2,"airpressure":948.0,"humidity":81.0,"rain":0.0,"rcomfort":74,"icomfort":1,"info":"-","img":"9999","feelst":24.9},"wind":{"direct":"无持续风向","power":"微风","speed":""},"warn":{"alert":"9999","pic":"9999","province":"9999","city":"9999","url":"9999","issuecontent":"9999","fmeans":"9999","signaltype":"9999","signallevel":"9999","pic2":"9999"} }, "predict": { "station":{"code":"56294","province":"四川省","city":"成都","url":"/publish/forecast/ASC/chengdu.html"}, "publish_time":"2020-07-26 20:00", "detail": [ {"date":"2020-07-26","pt":"2020-07-26 20:00", "day":{"weather":{"info":"9999","img":"9999","temperature":"9999"},"wind":{"direct":"9999","power":"9999"}},"night":{"weather":{"info":"晴","img":"0","temperature":"22"},"wind":{"direct":"无持续风向","power":"微风"}}}, {"date":"2020-07-27","pt":"2020-07-26 20:00","day":{"weather":{"info":"晴","img":"0","temperature":"34"},"wind":{"direct":"无持续风向","power":"微风"}},"night":{"weather":{"info":"晴","img":"0","temperature":"23"},"wind":{"direct":"无持续风向","power":"微风"}}}, ... ... {"date":"2020-08-01","pt":"2020-07-26 20:00"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e60b12fd6f7e1ee66e084beff8b72473/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f3ad39bb17a9dac7d4871e78c193b0a/" rel="bookmark">
			代码实现LRU最近很少使用算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LRU全称(Least Recently Used), 称为最近很少使用算法.
意思是, 根据最近访问的记录, 对于缓存的数据进行淘汰, 如果一个数据最近被访问, 或者经常被访问, 那么它就会处于列表前面的位置(比如数组或者链表的前面), 而一个数据很长时间没有被访问, 就会处于靠后的位置, 这个时候缓存如果满了, 来了新的数据, 就会把处于尾部的数据淘汰掉, 并将新的数据放入列表.
LRU算法通常是用一个哈希表和一个双向链表实现的
其实就如我们之前在概念中提到的那样, 也可以是一个数组, 也可以是一个列表.
当我们使用数组的时候, 查询效率较高, 当不方便在头部插入数据, 因为当缓存满了又到来新数据的时候, 我们往往会将其放在列表的头部, 表示它是最近被访问(这样可以使得处于列表末尾的数据就是最近很少访问, 或最近很少使用).
如果选择使用链表, 这个时候头部插入效率很高, 但查询的效率又变低了, 因为它不支持随机访问.
综合以上考虑, 我们选择使用哈希+双向链表的方式来实现LRU, 这样通过哈希映射我们能很快确定一个key值是否存在, 并且可以很快完成一个节点的移动和头部插入.
关于get方法
如果查询key值不存在, 直接返回-1;
如果存在, 则返回key值所对应的最近被使用的节点.
关于put方法
如果key不存在, 我们就需要构建一个新的节点, 并将该节点添加至链表头部, 表示最近被使用;
如果key存在, 就通过哈希映射, 找到对应节点, 并修改对应节点中的value值, 并将其移动值链表头部
代码示例:
struct DLinkListNode { int _key; int _val; DLinkListNode* _next; DLinkListNode* _prev; //默认构造函数 DLinkListNode() : _key(0), _val(0), _next(nullptr), _prev(nullptr) {} //带参构造 DLinkListNode(const int key, const int val) : _key(key), _val(val), _next(nullptr), _prev(nullptr) {} }; class LRU { public: LRU(int capacity) : _size(0), _capacity(capacity) { _head = new DLinkListNode(); _tail = new DLinkListNode(); _head-&gt;_next = _tail; _tail-&gt;_prev = _head; } int get(const int key) { //如果不在哈希表中, 返回-1 if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f3ad39bb17a9dac7d4871e78c193b0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72c764fcd80d2aa8f550ae3e9a811d42/" rel="bookmark">
			爬虫进阶之scrapy项目实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		爬虫进阶之scrapy项目实战 前言 觉得Scrapy确实挺强大的，并且要想更加熟悉和了解这个框架，应该要多做一些项目来强化对Scrapy的理解，本次的项目是针对Boss直聘，想要爬取boss直聘根据关键词（地点和工作）的工作岗位的详细情况，包括薪资、学历要求、地点、工作描述等等…此次设置的爬虫规则是通过CSS选择器进行的，因此说明时也会介绍CSS选择
正文 初始化爬虫项目 scrapy startproject zhipin_com #后面是项目的名字 从得到的文件架构中也能清楚知道整个Scrapy的框架，具体我们在上一章博客中也介绍了
scrapt genspider zhipin #创建一个名为zhipin的爬虫 当初始化完成后，接下来我们就应该设置item，其实item很好理解，就是我们所要爬取的参数，我们需要爬取多少参数，就可以设置多少个items,这里我们需要设置如下items:
如上，这些都是我们需要爬取的，我们在items.py先将他们说明，接下来就是设置爬虫规则了，在这里先说明一下CSS选择器
http://www.scrapyd.cn/doc/185.html
现附上scrapy对于CSS选择器的官方文档，个人感觉讲的很详细了，下面举一些例子来说明:
&lt;ol class="page-navigator"&gt; &lt;li class="current"&gt;&lt;a href="http://lab.scrapyd.cn/page/1/"&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="http://lab.scrapyd.cn/page/2/"&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="http://lab.scrapyd.cn/page/3/"&gt;3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="http://lab.scrapyd.cn/page/4/"&gt;4&lt;/a&gt;&lt;/li&gt; &lt;/ol&gt; 如果我们想提取该html中的URL，我们应该如何提取呢？
这里列举了一些重要的匹配，如果我们是要选择class中的元素，我们只需要在response.css(".class")，其实在设置匹配规则时，我们要操作的无非是这三个，response.css(“css表达式”)、extract()、extract_first()
提取属性我们是用：“标签名::attr(属性名)”，因此在上面html中，匹配URL应该是
url = response.css(".page-navigator a::attr(href)").extract() 在使用scrapy匹配时返回的都是selectorList的对象实例，而extract()可以看成是将对象实例变成列表的形式
再比如这个例子：
&lt;div class="left"&gt; scrapy中文网左边 &lt;/div&gt; &lt;div class="center"&gt; scrapy中文网中部 &lt;/div&gt; &lt;div class="right"&gt; scrapy中文网右侧 &lt;/div&gt; 我们想要第二段文字，应该如何匹配？这时::text能够匹配标签中的内容，因此我们应该这样匹配
text = response.css(".center::text").extract() 这里需要注意的是，CSS高级用法中，response.css(".div1 .div2")表示的是选择div1中的所有div2元素，不一定是父子关系，而response.css(".div1&gt;.div2")则这俩者一定是父子关系的，那如果&lt;div&gt;标签中的class属性的值本来就含有空格，例如
这里本来就含有空格，但是我们是相匹配的这个&lt;div&gt;标签的话，此时就应该把空格当成.处理：
div = response.css("div.wrapper_new.wrapper_s")#这样进行匹配 CSS选择器说明完之后，接下来我们就来配置规则了：
先设置开始的url和当前页数
设置好请求头(注意：请求头的设置尤为重要，现在很多网页都有反爬取措施，不设置请求头很可能不会有response)
具体的job参数对应html哪个位置，我们可以将鼠标移动到job参数右击检查，即可在开发者工具中看到对应的位置，因此我们只需要一个一个进行查找即可，每一个工作都是放在&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt;下，for循环即可
这里还需要动态爬取页面，当第一页爬取完后主动爬取第二页，因此还要构造一个方法
def next_request(self): return scrapy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72c764fcd80d2aa8f550ae3e9a811d42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce5756919b9d3317a7d31ea758dabcae/" rel="bookmark">
			C&#43;&#43;面向对象（三）：类和对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++面向对象：类和对象 会有点长，不过读过就全学会喽！！！！！！
会有点长，不过读过就全学会喽！！！！！！
会有点长，不过读过就全学会喽！！！！！！
1.类与对象的基本概念 1.1 结构与类 1 . 结构的扩充
结构是 C 语言的一种自定义的数据类型, 在结构体中可以含有各种不同类型的数 据。C + + 语言对结构类型进行了扩充, 它不仅可以含有不同类型的数据, 而且还可以含有函数。
结构中的数据和函数都是结构的成员,分别称作数据成员和函数成员。在 C + + 中, 通常把 函 数 成 员 称 为 成 员 函 数。
为了访问这些成员函数,必须 定义该结构类型的变量,然后像访问结构中的数据成员一样进行访问。
#include &lt; iostream .h &gt; #include &lt; math .h &gt; struct complex { double real; // 复数的实部 double imag; // 复数的虚部 void init( double r, double i) // 给 real 和 imag 赋初值 { real = r; imag = i; } double realcomplex() // 求复数的实部值 { return real; } double imagcomplex() // 求复数的虚部值 { return imag; } double abscomplex() // 求复数的绝对值 {double t ; t = real * real + imag * imag; return sqrt(t) ; } } A; int main() { A .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce5756919b9d3317a7d31ea758dabcae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3968d7837ed82200f2a1010336016d0/" rel="bookmark">
			fedora chrome_如何在Fedora Linux上安装Chrome？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		fedora chrome
How to install the Chrome browser on Fedora Linux from Google?
如何通过Google在Fedora Linux上安装Chrome浏览器？ Google provides a repository for yum/dnf on Fedora.
Google在Fedora上为yum / dnf提供了一个存储库。 First, following http://www.systutorials.com/3471/additional-repositories-for-fedora-linux/#google-chrome-repository to add Google Chrome repository.
首先，按照http://www.systutorials.com/3471/additional-repositories-for-fedora-linux/#google-chrome-repository添加Google Chrome存储库。 Then, you can install Google Chrome by yum/dnf:
然后，您可以通过yum / dnf安装Google Chrome： # dnf install google-chrome-stable Answered by Eric Z Ma. 埃里克·马（Eric Z Ma）回答。 翻译自: https://www.systutorials.com/how-to-install-chrome-on-fedora-linux/
fedora chrome
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbb370c972306f21942b789d201c9d89/" rel="bookmark">
			[INS-44002] The Oracle home location contains directories or files on following remote nodes:
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述：[INS-44002] The Oracle home location contains directories or files on following remote nodes:
[fgedu2].
These nodes will be ignored and not participate in the configured Grid Infrastructure.
问题处理
[root@dbserver02 ~]# cd /u01/app/19.3.0/grid
[root@dbserver02 grid]# ls
[root@dbserver02 grid]# ls -al
总用量 0
drwxrwxr-x 4 grid oinstall 55 1月 23 09:45 .
drwxrwxr-x 3 root root 18 1月 22 16:27 …
drwxr-xr-x 3 grid oinstall 28 4月 18 2019 .opatchauto_storage
drwxr-xr-x 7 grid oinstall 261 4月 18 2019 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbb370c972306f21942b789d201c9d89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6081d656e026cbe037a6a7b3587b8246/" rel="bookmark">
			为什么会出现幻读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么会出现幻读 关于幻读的解释是当某个事物在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻读。
我们知道在可重复读的隔离级别，事务是看不到未提交的数据的，所以关于这个定义总是让人有点绕不清楚，若是另外一个事务提交了锁修改的数据，那么这个事务应该可以看到修改的数据，若是另外一个事务未提交数据，那么这个数据应该无法被这个事务查看到。所以幻读到底是如何产生的。
一般情况下（mysql原本配置未做更改） 事务2若是未提交数据，则事务1在插入时则会获取不到锁资源，但恰好是事务2提交了数据，事务结束，释放了锁资源，让事物1获取了锁，所以提示的则是这条数据已插入，但提交的数据是可以被看到的，也就是说事务1在事务2提交后再次查看就不会有幻读的情况，所以幻读在时间上来讲还是很极限的。要是人为插入应该不会被困扰吧。。。
但换一种说法，Innodb默认是行锁，也就是说要是事务2未提交，事务1插入同样的数据报错（获取锁超时），是不是也算作幻读的一种呢（当然这种情况不能按照上面的说法，即事务1再次查看也还是读不到数据）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a4ec3d79145e0ab63c5876cba4f99e3/" rel="bookmark">
			修改静态ip
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ## 关闭selinux
sed -ri 's/SELINUX=enforcing/SELINUX=disabled/' /etc/selinux/config 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85cdfc8dc35b0ef14cb4e3f4a9cf24af/" rel="bookmark">
			什么是重定向
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是重定向，重定向指的是当前方法不运行，运行重定向指定的其他方法，举个例子，这是SpringMVC里面的Controller文件，里面就有一个重定向方法
public String login(…此处太多代码省略，这个括号里面不是重点){
省略方法…
return “redirect:showlogin2”}
先看这里，redirect showlogin2就是一个重定向方法，它表示的是不去执行login这个方法了，而是直接去执行showlogin2这个方法
public String showlogin2(省略代码…){
省略代码…
}
这个就是showlogin2的方法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20c4a6bc76ee4283d3a4d7ad8211a8de/" rel="bookmark">
			PTA 练习5-2 找两个数中最大者 (10分)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		练习5-2 找两个数中最大者 (10分)
本题要求对两个整数a和b，输出其中较大的数。
函数接口定义： int max( int a, int b ); 其中a和b是用户传入的参数，函数返回的是两者中较大的数。
裁判测试程序样例： #include &lt;stdio.h&gt; int max( int a, int b ); int main() { int a, b; scanf("%d %d", &amp;a, &amp;b); printf("max = %d\n", max(a, b)); return 0; } /* 你的代码将被嵌在这里 */ 输入样例： -5 8 输出样例： max = 8 代码：
int max( int a, int b ) { if(a&gt;b)return a; else return b; } 解释：
没有什么解释的..
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b1a1c5e5fab2d0475f8be5018362d1e/" rel="bookmark">
			redis获取到的List对象，出现java.lang.ClassCastException异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题描述 从redis获取到的List对象，在对这个对象进行遍历的时候，出现类型转换异常ClassCastException，调试后发现，获取到的items对象其实是JSONArray，数组元素都是JSONObject对象。
解决方法 @Override public SecItem selectItemByItemId(Long itemId) { List&lt;SecItem&gt; items = JSON.parseArray(JSON.toJSON(selectAll()).toString(),SecItem.class); for (SecItem item : items) { if (item.getItemId().equals(itemId)){ return item; } } return null; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5d18a695abc6746478a8b5e77afbfc8/" rel="bookmark">
			直接访问jsp页面的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在SpringMVC.xml文件下前面加上 &lt;mvc:view-controller path="/userlogin" view-name=“login”/&gt;
其中userlogin是一个地址名字，就是你的地址栏，除了最后的8080，再加一个/userlogin就可以直接访问一个名叫login的JSP页面， view-name="login"的意思是视图名字为login，也就是那个JSP页面的名字。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1108fb9ae8da149799657c7d36243fc/" rel="bookmark">
			哈密顿绕行世界问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个规则的实心十二面体，它的 20个顶点标出世界著名的20个城市，你从一个城市出发经过每个城市刚好一次后回到出发的城市。
Input
前20行的第i行有3个数,表示与第i个城市相邻的3个城市.第20行以后每行有1个数m,m&lt;=20,m&gt;=1.m=0退出.
Output
输出从第m个城市出发经过每个城市1次又回到m的所有路线,如有多条路线,按字典序输出,每行1条路线.每行首先输出是第几条路线.然后个一个: 后列出经过的城市.参看Sample output
Sample Input
2 5 20
1 3 12
2 4 10
3 5 8
1 4 6
5 7 19
6 8 17
4 7 9
8 10 16
3 9 11
10 12 15
2 11 13
12 14 20
13 15 18
11 14 16
9 15 17
7 16 18
14 17 19
6 18 20
1 13 19
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1108fb9ae8da149799657c7d36243fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/766f02e3467d6038a624834dccba76c5/" rel="bookmark">
			水果类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 # 定义一个水果类，然后通过水果类，创建苹果对象、橘子对象、西瓜对象并分别添加属性:颜色和价格: class Fruits: """水果类""" def __init__(self, color, price): # 颜色属性 self.__color = color # 价格属性 self.__price = price def get_color(self): return self.__color def get_price(self): return self.__price if __name__ == '__main__': # 创建一个苹果, 红色, 8元一斤 apple1 = Fruits("红色", 8) # 西瓜 watermelon1 = Fruits("绿色", 2) # 橘子 orange1 = Fruits("橙色", 10) print("苹果{}钱一斤,苹果是{}的".format(apple1.get_price(), apple1.get_color())) print("西瓜{}钱一斤,西瓜是{}的".format(watermelon1.get_price(), watermelon1.get_color())) print("橘子{}钱一斤,橘子是{}的".format(orange1.get_price(), orange1.get_color())) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46da4b392b781d800a29eba74ab528c2/" rel="bookmark">
			前端基础HTML
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		****HTML笔记 一. HTML常用标签 1. 段落标签：p标签 &lt;p&gt;&lt;/p&gt; 格式：&lt;p&gt;这是一个段落标签&lt;/p&gt;用于将段落进行分段举例： &lt;p&gt;拉布拉多又称寻回犬，是一种中大型犬类，是非常适合被选作经常出入公共场合的导盲犬或地铁警犬及搜救犬和其他工作犬的狗品种，因原产地在加拿大的纽芬兰与拉布拉多省而得名。&lt;/p&gt; &lt;p&gt;拉布拉多猎犬有四种颜色，分别为：黑色、黄色、巧克力、米白色。最常见的是黑色，黄色。在美国犬业俱乐部中拉布拉多是目前登记数量最多的品种，对小孩尤其的友善，对犬主人略粘人。&lt;/p&gt; 2. 标题标签：h标签 &lt;h&gt;&lt;/h&gt; 格式：&lt;h&gt;这是一个标题&lt;/h&gt;注意：标题只能是h1-- h6，没有h7举例： &lt;h1&gt;标题1&lt;/h1&gt; &lt;h2&gt;标题2&lt;/h2&gt; &lt;h3&gt;标题3&lt;/h3&gt; &lt;h4&gt;标题4&lt;/h4&gt; &lt;h5&gt;标题5&lt;/h5&gt; &lt;h6&gt;标题6&lt;/h6&gt; 3. 水平线标签：hr标签（单标签）&lt;hr /&gt; 格式： 段落1
​ &lt;hr/&gt;
​ 段落2
用水平线将段落和段落之间分开
注意：它是一个单标签
举例：
&lt;p&gt;拉布拉多又称寻回犬，是一种中大型犬类，是非常适合被选作经常出入公共场合的导盲犬或地铁警犬及搜救犬和其他工作犬的狗品种，因原产地在加拿大的纽芬兰与拉布拉多省而得名。&lt;/p&gt; &lt;hr /&gt; &lt;p&gt;跟西伯利亚雪撬犬和金毛寻回犬并列三大无攻击性犬类，拉布拉多智商位列世界犬类第六&lt;/p&gt; &lt;hr /&gt; &lt;p&gt;个性忠诚、大气、憨厚、温和、阳光、开朗、活泼，智商极高，也对人很友善。&lt;/p&gt; &lt;hr /&gt; &lt;p&gt;拉布拉多猎犬有四种颜色，分别为：黑色、黄色、巧克力、米白色。最常见的是黑色，黄色。在美国犬业俱乐部中拉布拉多是目前登记数量最多的品种，对小孩尤其的友善，对犬主人略粘人。&lt;/p&gt; 4. 换行标签： &lt;br /&gt; 格式： 段落1&lt;br /&gt;
​ 段落2
注意：它是一个单标签
举例：
拉布拉多&lt;br /&gt; 萨摩耶&lt;br /&gt; 金毛&lt;br /&gt; 法国斗牛犬&lt;br /&gt; 柴犬&lt;br /&gt; 5. 布局标签： &lt;div&gt;,&lt;span&gt;,&lt;table&gt; 两个都用于用于布局，没有具体含义
块元素和内联元素：块元素都是新起一行的，内联元素都是跟在同一行的
span元素用于对文本中的部分字体设定样式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46da4b392b781d800a29eba74ab528c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f916288b9f4554a4215f7c75e2323ef/" rel="bookmark">
			索引顺序文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 基本上克服了变长记录的顺序文件不能随机访问，以及不便于记录的增加或删除。
记录仍然以关键字的顺序组织起来。
引入了文件索引表，通过该表可以实现对索引顺序文件的随机访问。
增加了溢出文件，用它来记录新增加、删除和修改的记录。
一级索引顺序文件 首先将变长记录顺序文件中的所有记录分为若干组，50个记录为一组。然后为顺序文件建立一张索引表，并为每组中的第一个记录在索引表中建立一个索引项。
在对索引顺序文件进行检索时，首先利用用户提供的关键字以及某种查找算法去检索索引表，找到该记录所在记录组中的第一个记录的表项，从中得到该记录组第一个记录在主文件中的位置。再利用顺序查找法去查找主文件，从中找到所要求的记录。
如果一个顺序文件所含记录为N，则为检索到具有指定关键字的记录，平均查找N/2个记录，但对于索引顺序文件，平均查找平方根N个记录。
例如：一个顺序文件有10000个记录，平均须查找的记录数为5000个，但对于索引顺序文件，则平均查找100个记录
两级索引顺序文件 对于一个非常大的文件，为找到一个记录而需要查找的记录数目仍然很多，对于一个10的六次方个记录的索引顺序文件，需要查找1000个记录。
为了进一步提高检索效率，可以为顺序文件建立多级索引。
对于一个含有10的六次方个记录的顺序文件，可以先为该文件建立一张低级索引表，每100个记录为一组，所以低级索引表有10000个表项，在每个表项中存放顺序文件中每个组第一个记录的记录键值和指向该记录的指针，然后为低级索引表建立一张高级索引表。
直接文件和哈希文件 直接文件
直接文件，可根据给定的关键字直接获得指定记录的物理地址。
键值转换：根据给定的关键字直接获得指定记录的物理地址哈希文件是最广泛的一种直接文件，利用哈希函数可将关键字转换为相应记录的地址。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10cffd3a16b509e5949ca707c35bde55/" rel="bookmark">
			Elastic-Job-Lite 源码分析 —— 作业分片策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 概述 本文主要分享 Elastic-Job-Lite 作业分片策略。
涉及到主要类的类图如下( 打开大图 )：
你行好事会因为得到赞赏而愉悦
同理，开源项目贡献者会因为 Star 而更加有动力
为 Elastic-Job 点赞！传送门
2. 自带作业分片策略 JobShardingStrategy，作业分片策略接口。分片策略通过实现接口的 #sharding(...) 方法提供作业分片的计算。
public interface JobShardingStrategy { /** * 作业分片. * * @param jobInstances 所有参与分片的单元列表 * @param jobName 作业名称 * @param shardingTotalCount 分片总数 * @return 分片结果 */ Map&lt;JobInstance, List&lt;Integer&gt;&gt; sharding(List&lt;JobInstance&gt; jobInstances, String jobName, int shardingTotalCount); } Elastic-Job-Lite 提供三种自带的作业分片策略：
AverageAllocationJobShardingStrategy：基于平均分配算法的分片策略。OdevitySortByNameJobShardingStrategy：根据作业名的哈希值奇偶数决定IP升降序算法的分片策略。RotateServerByNameJobShardingStrategy：根据作业名的哈希值对作业节点列表进行轮转的分片策略。 2.1 AverageAllocationJobShardingStrategy AverageAllocationJobShardingStrategy，基于平均分配算法的分片策略。Elastic-Job-Lite 默认的作业分片策略。
如果分片不能整除，则不能整除的多余分片将依次追加到序号小的作业节点。如：
如果有3台作业节点，分成9片，则每台作业节点分到的分片是：1=[0,1,2], 2=[3,4,5], 3=[6,7,8]
如果有3台作业节点，分成8片，则每台作业节点分到的分片是：1=[0,1,6], 2=[2,3,7], 3=[4,5]
如果有3台作业节点，分成10片，则每台作业节点分到的分片是：1=[0,1,2,9], 2=[3,4,5], 3=[6,7,8]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10cffd3a16b509e5949ca707c35bde55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10788fd75f6fa12285cbcfecd4d94383/" rel="bookmark">
			Numpy中的数组、行/列向量及其之间的转化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.array数组 [In] import numpy as np [In] a = np.array([1,2,3]) #一个[]对应的是既不是行向量也不是列向量，而是一个数组。 [Out] array([1, 2, 3]) [In] a.shape [Out] (3,) [In] b = a.T [In] b [Out] array([1, 2, 3]) #数组的转置仍为该数组，可见a并非是一个向量 [In] b.shape [Out] (3,) 2. 行向量 [In] import numpy as np v_r = np.array([[1,2,3]]) #2个[]对应的才是向量 v_r [Out] array([[1, 2, 3]]) [In] v_r.shape [Out] (1,3) [In] v_r.T #将行向量转换成列向量 [Out] array([[1], [2], [3]]) [In] v_r.T.shape [Out] (3, 1) 3.列向量 [In] v_c = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10788fd75f6fa12285cbcfecd4d94383/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f976f3280f1f29ee7b715e44bdfb7975/" rel="bookmark">
			远程连接sql数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[注] up使用sql 2012数据库较多，在这里就拿sql数据库来举例，其他的应该是类比。远程登录时建议使用sa登录，或者新建一个用户去登录sql（网站参考过一些博主，基本都是用sa或者其他用户名登录）。
1、sql数据的配置 2、防火墙的设置 3、续前篇文章的后续 一：sql数据的配置
1、打开sql数据库，用windows登录。设置允许sql server和windows 身份验证模式。
选择连接——》将允许远程连接开启
2、选择sa——》右键属性
3、右击数据库选择“方面”——》在下拉框中选择“服务器配置”；将“RemoteAccessEnabled”属性设为“True”
4、用sa重新登录sql,检测一下
5、打开sql server配置管理器。确保右侧的“SQL Server”以及“SQL Server Browser”正在运行，TCP/IP改为是，那个1433的端口不用改，用默认的就好，步骤如下图
右键后点击“是”
确认是否已经启动，端口可以不用设置
6、然后去sql数据库重启一下
二：防火墙的设置 1、到这一步，数据的设置就已经完成了，下面我们防火墙的设置。找到防火墙——》高级设置——》入站规则。图如下：
[注]：到这里已经完成的远程连接所需要的配置，其他的小伙伴可以不用往下看l。如果你是根据之前链接来的请接着往下看
三：续前篇文章的后续
1、在之前发布的时候应该会有选择数据库配置，现在你可以按下图去配置
[注]：up亲测有效，可能会出现一些小小的错误，希望大家仔细查看步骤，遇到问题咱们就解决问题。欢迎大家留言！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f491de79016b3a25d9893d2ff61bcb8c/" rel="bookmark">
			怎么制作gif？如何使用手机制作gif？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在，动图的应用是非常广泛的，最鲜明的体现就是在使用微信或者QQ聊天时候，使用的动图表情包。不仅年轻人喜欢使用，年龄比较大的用户也喜欢在聊天的时候使用表情包。动图表情包能够让聊天的氛围更加的有趣，融洽，那么怎么才能制作gifhttps://www.gif.cn/表情包呢?
制作gif动图其实有比较简单的方式方法，接下来教大家使用手机来将视频转为gif的方法。
打开手机的浏览器，搜索GIF中文网。
进入网站之后，点击“添加视频”功能，将视频上传到网站上。
点击开始取图，选择视频截取开始的时间，点击停止取图，确定截取视频时长，点击取图完成，进入参数设置页面。
设置生成gif图片的宽或者高，动图播放的延迟，想要下载无水印图片的话话只需要删除文字框中的链接即可。如果需要对生成gif动图进行压缩的话，可以勾选压缩的选项，调整图片质量之后，点击开始生成gif，整个过程大概一分钟左右。
点击下载图片，即可提出立即下载，下载之后的图片可以从浏览器的下载管理中查找。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/114b54654848a8b7d4a8b53d50e9fc69/" rel="bookmark">
			对CephFS进行性能测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对CephFS进行性能测试 cephfs 内核： 3.10.0-327.el7.x86_64 内存：256g 操作系统版本：centos 7.2.1511 OSD_count=3 每个osd容量5.5T，共16.5T Pool 副本数：3 stripe_unit=4M stripe_count=1 object_size=4M 一 . iozone测试 1. iozone安装 wget http://www.iozone.org/src/current/iozone3_486.tar tar -xvf iozone3_486.tar cd iozone3_486/ src/current make linux-AMD64 ./iozone –h #iozone帮助 2. iozone对cephfs进行测试 ./iozone -a -+u -i 0 -i 1 -i 2-b -s 10g -r 4k -f /mnt/ceph/iozone_10g –I –t 1 /home/iozoneResult/iozone_4k.xls reclenwriterewritereadrereadrandreadrandwrite4307533141052728695443172361874996616722857272162688836596477551792035312567260270883503448949228024858299649895127331772703571425760014135934733687081M7223472068560845658799025843498705452M7342371797538131457310475697624715684M723497265553809335707175566169274486 3. iozone测试结果参数解读 对于-i选项具体含义
Write: 测试向一个新文件写入的性能。当一个新文件被写入时，不仅仅是那些文件中的数据需要被存储，还包括那些用于定位数据存储在存储介质的具体位置的额外信息。这些额外信息被称作“元数据”。它包括目录信息，所分配的空间和一些与该文件有关但又并非该文件所含数据的其他数据。拜这些额外信息所赐，Write的性能通常会比Re-write的性能低。
Re-write: 测试向一个已存在的文件写入的性能。当一个已存在的文件被写入时，所需工作量较少，因为此时元数据已经存在。Re-write的性能通常比Write的性能高。
Read: 测试读一个已存在的文件的性能。
Re-Read: 测试读一个最近读过的文件的性能。Re-Read性能会高些，因为操作系统通常会缓存最近读过的文件数据。这个缓存可以被用于读以提高性能。
Random Read: 测试读一个文件中的随机偏移量的性能。许多因素可能影响这种情况下的系统性能，例如：操作系统缓存的大小，磁盘数量，寻道延迟和其他。
Random Write: 测试写一个文件中的随机偏移量的性能。同样，许多因素可能影响这种情况下的系统性能，例如：操作系统缓存的大小，磁盘数量，寻道延迟和其他。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/114b54654848a8b7d4a8b53d50e9fc69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5f816a94768e5b2e48977ec637a2a61/" rel="bookmark">
			单缓冲区和双缓冲区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单缓冲区 在单缓冲情况下，每当用户进程发出一I/O请求时，OS便在主存中为之分配一缓冲区。在块设备输入时，假定从磁盘把一块数据输入到缓冲区的时间为T,OS将该缓冲区中的数据传送到用户区的时间为M，而CPU对这一块数据的处理时间为C，T和C是可以并行的，所以系统对每一块数据的处理时间为MAX（T,C）+M
双缓冲区 由于缓冲区是共享资源，生产者与消费者在使用缓冲区时必须互斥。
如果消费者尚未取走缓冲区的数据，生产者又生产新的数据，也无法将它送入缓冲区，所以设置两个缓冲区。
双缓冲机制（缓冲对换）：在设备输入时，先将数据送入第一缓冲区，装满后转向第二缓冲区。在双缓冲时，系统处理一块数据的时间可以粗略地认为是MAX（C,T）
在两台机器中，都设置两个缓冲区，一个是发送缓冲区，一个是接收缓冲区
环形缓冲区 当输入与输出的速度基本相匹配时，采用双缓冲能获得较好的效果，可使生产者和消费者基本上能并行操作。但当两者的速度相差很远时，双缓冲的效果很不理想，所以引入环形缓冲区
环形缓冲区：
在环形缓冲区中包括多个缓冲区，每个缓冲区的大小相同，作为输入的多缓冲区可分为3类：用于装输入数据的空缓冲区，已装满数据的缓冲区G，计算进程正在使用的现行工作缓冲区C。
缓冲池 既可以用于输入也可以用于输出的公用缓冲池，在池中设置了多个可供若干个进程共享的缓冲区。
缓冲池和缓冲区的区别：缓冲区仅仅是一组内存块的链表，而缓冲池则是包含了一个管理的数据结构以及一组操作函数的管理机制，用于管理多个缓冲区
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/382b6f1f898487bde510c009437756b4/" rel="bookmark">
			sigmoid和softmax
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sigmoid函数也叫Logistic
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f365b966f1db0d8d7107f6a173519db/" rel="bookmark">
			CAD卸载方法，如何完全彻底卸载删除清理干净CAD各种残留注册表和文件？ 【转载】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CAD卸载方法，完全彻底删除干净CAD各种残留注册表和文件。CAD安装失败，怎么完全彻底删除清理干净CAD各种残留注册表和文件呢？有些同学想把CAD重新安装，但是CAD安装失败显示失败，有时CAD安装到一半就显示失败，然后会问CAD无法重装是怎么回事。那么CAD安装失败的原因是什么呢？如何才能把CAD卸载干净呢？有人说只要把CAD注册表7d2f删除就可以了，但是有的同学找到了CAD注册表7d2f也删除了，但是CAD再次安装失败。还有的同学直接重装系统，但是重装系统后CAD仍然无法安装。还有的同学直接把CAD的程序文件删除，重装CAD的时候会显示已安装。那么CAD卸载不干净无法重装的原因到底是什么呢？答案可能不是唯一！
CAD提示安装未完成，某些产品无法安装该怎样解决呢？一些朋友在win 7或者win 10系统下安装CAD失败提示CAD安装未完成，某些产品无法安装；也有时候想重新安装CAD的时候会出现本电脑windows系统已安装CAD，你要是不留意直接安装CAD，只会安装CAD的附件或者直接提示安装失败，CAD是安装不上的。这种原因就是大家在之前卸载CAD时没有把CAD残留注册表信息删除或者是因为C++版本不对。下面我来教大家如何把CAD强力卸载掉然后重新安装，最后完美安装运行CAD，如果纯手工删除CAD会有很多条注册表记录要删。
CAD没有按照正确方式卸载，导致CAD安装失败。楼主也查过网上关于如何解决CAD安装失败的一些文章，是说删除几个CAD文件和CAD软件注册表就可以解决CAD安装失败的问题，实际的情况并没有这么简单，导致CAD安装失败的原因有很多种。CAD安装时产生了几万条注册表，想要彻底卸载CAD软件再重新安装CAD就有几万条CAD注册表要删除，非人力所能为。现在虽然360或者其他一些卸载软件提供了强力卸载CAD的工具，可以将CAD注册表和一些CAD目录的CAD残留信息删除，但仍不能确保将CAD所有相关dll程序文件、exe可执行文件和注册表全部彻底删除干净。CAD安装失败还和C++版本问题有关，因为每个版本的CAD都是基于一定版本的C++版本而开发的，如果是这种情况，重装系统C++问题还是可能会存在的。安装成功后，如果缺少必要的dll动态链接库文件，也会导致CAD启动和注册失败。上面说了这么多，只是几种CAD安装失败最常见的情况。这里使用到一个CAD卸载工具，专门用来解决卸载修复CAD软件卸载安装失败的问题。CAD卸载工具会自动执行一系列问题的排查和修复，极大的节省了排除安装CAD失败问题的时间。卸载之后，建议最好用CAD官方原始的安装包，压缩包的常常会缺少一些组件也可能导致CAD安装失败，安装时还要使用Administrator帐户进行安装。
CAD卸载工具是专门为了针对CAD类软件卸载不干净而导致CAD安装失败问题进行研发的CAD一键卸载工具。现在虽然360或一些卸载软件提供了强力卸载CAD的工具，可以将CAD注册表和一些CAD目录的CAD残留信息删除，但仍不能确保将CAD所有相关程序文件和注册表全部彻底删除。也查过网上关于如何卸载CAD的一些文章，是说删除几个CAD文件和CAD软件注册表就可以了，情况并没有这么简单。CAD安装时产生了几万条注册表，想要彻底卸载CAD软件，就有几万条CAD注册表要删，非人力所能为。CAD安装失败还和C++版本问题有关，因为每个版本的CAD都是基于一定版本的C++版本而开发的。上面说了这么多，只是两种最常见的情况。这里介绍一个CAD卸载工具，专门用来解决卸载修复CAD类软件卸载安装失败的问题。CAD卸载工具会自动执行一系列问题的排查和修复，极大的节省了排除安装CAD失败问题的时间。
AUTO Uninstaller 更新下载地址
地址一(腾讯微云) 地址二(百度网盘) 提取码：dnn5
解决方法：
1、选择想要卸载的软件，比如CAD，其他的autodesk软件也是一样的操作
2、选择autodesk CAD的版本
3、点击“开始卸载&amp;修复”按钮，等他提示卸载结束的对话框
4、卸载后重新安装autodesk CAD软件、可以愉快的使用了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f5b4507f048a45694868c522d816386/" rel="bookmark">
			Logit模型和Logistic模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Logistic 因为其函数形状，又叫做sigmoid函数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7792bccbf3f64e7368c4524a5c52809/" rel="bookmark">
			16.9、Generator与协程、Generator应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/* 协程（coroutine）是一种程序运行方式，可以理解成 “协作的线程” 或 “协作的函数”。 协程既可以用单线程实现，也可以用多线程实现；前者是一种特殊的子例程，后者是一种特殊的线程。 */ /* 协程与子例程的差异： 传统的 “子例程” 采用堆栈式 “后进先出” 的执行方式，只有当调用的子函数完全执行完毕，才会结束执行父函数。 协程与其不同，多个线程（单线程情况下即多个函数）可以并行执行，但只有一个线程（或函数）处于正在运行的状态，其他线程（或函数）都处于暂停态，线程（或函数）之间可以交换执行权。 也就是说，一个线程（或函数）执行到一半，可以暂停执行，将执行权交给另一个线程（或函数），等到稍后收回执行权时再恢复执行。这种可以并行执行、交换执行权的线程（或函数），就称为协程。 从实现上看，在内存中子例程只使用一个栈（stack），而协程是同时存在多个栈，但只有一个栈是在运行态。也就是说，协程是以多占用内存为代价实现多任务的并行运行。 协程与普通线程的差异： 不难看出，协程适用于多任务运行的环境。 在这个意义上，它与普通的线程很相似，都有自己的执行上下文，可以分享全局变。 它们的不同之处在于，同一时间可以有多个线程处于运行态，但是运行的协程只能有一个，其他协程都处于暂停态。 此外，普通的线程是抢占式的，到底哪个线程优先得到资源，必须由运行环境决定，但是协程是合作式的，执行权由协程自己分配。 由于 Javascript 是单线程的语言，只能保持一个调用栈。 引入协程以后，每个任务可以保持自己的调用栈。这样做的最大好处，就是抛出错误的时候，可以找到原始的调用栈。 不至于像异步操作的回调函数那样，一旦出错原始的调用栈早就结束。 Generator 函数是 es6 对协程的实现，但属于不完全实现。 Generator 函数被称为 “半协程”，意思是只有 Generator 函数的调用者才能将程序的执行权还给 Generator 函数， 如果是完全实现的协程，任何函数都可以让暂停的协程继续执行。 如果将 Generator 函数当作协程，完全可以将多个需要互相协作的任务写成 Generator 函数，它们之间使用 yield 语句交换控制权。 */ /* 16.10 Generator 的应用 16.10.1 异步操作的同步化表达 Genarator 函数的暂停执行效果，意味着可以把异步操作写在 yield 语句里面，等到调用 next 方法时再往后执行。 这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在 yield 语句下面，反正要等到调用 next 方法时再执行。 所以，Generator 函数的一个重要实际意义就是用于处理异步操作，改写回调函数。 */ function* loadUI() { showLoadingScreen() yield loadUIDataAsynchronously() hideLoadingScreen() } var loader = loadUI() // 加载 UI loader.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7792bccbf3f64e7368c4524a5c52809/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c32a452c8216ae2b089d58bb69bbbfb6/" rel="bookmark">
			springboot项目中使用mvc:annotation-driven问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景
在一次无意的观察中，发现应用A（一个springboot应用）中的拦截器没有生效，该拦截器通过WebMvcConfigurerAdapter::addInterceptors注册
定位
分析了一圈代码没有发现异常的情况下，和其他拦截器生效的应用对比，发现唯一的区别在于A使用了mvc:annotation-driven注解
该注解会自动生成3个Bean，其中一个bean为RequestMappingHandlerMapping（该点google得知）
通过在DispatcherServlet::doDispatch中断点发现，handlerMappings中有2个Bean：RequestMappingHandlerMapping，其中一个符合预期，其中包含了我们的拦截器，另一个RequestMappingHandlerMapping中并没有该拦截器
google得知mvc:annotation-driven自动创建的RequestMappingHandlerMapping中不包含自定义的拦截器
解决
ok，最简单的解决方法就是删除mvc:annotation-driven， 都已经是springboot的应用，为啥还使用这个呢
————————————————
版权声明：本文为CSDN博主「zl.qian」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_37512224/article/details/105127020
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fba0a5e1f134134971570d0ba8380af8/" rel="bookmark">
			System.InvalidOperationException:“未在本地计算机上注册“Microsoft.ACE.OLEDB.12.0”提供程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【写在前面】
今天在做c#和ACCESS的连接测试时出现了如下图的BUG:
（本人VS为2017，access为2016 64位专业版）
CODES:
报错提示
error location
【原因分析】
这个错误的根本原因就是应用程序（32 位代码）和与 64 位 Microsoft Access 一同安装的 64 位 ACE 提供程序之间的版本不匹配，造成了错误“’Microsoft.ACE.OLEDB.12.0’ 提供程序未在本地计算机上注册”。
**知识点延伸：** 共同点：所有都是连接到Excel对象的接口引擎不同点：
1）对于不同版本的zhiExcel，有两个接口可供选择：daoMicrosoft.Jet.OLEDB.4.0（以下简称Jet引擎）和microsoft.ace.oledb.12.0（以下简称ACE引擎）。Jet引擎可以访问office 97-2003，但是你无法
访问office 2007。ACE引擎是与Office 20,071一起发布的数据库连接组件，您可以访问Office 2007或Office 97-2003。
2）microsoft.ace.oledb.12.0可以访问正在打开的Excel文件，而microsoft.jet.oledb.4.0是不可能的。因此，在使用不同版本的Office时，请注意使用正确的引擎。 扩展资料：
从2007版本开始，Access包含特定于Office的Jet版本，最初称为Office Access连接引擎（ACE），但现在称为Access数据库引擎。此引擎完全向后兼容以前版本的Jet引擎，因此它从早期的Access版本读取和写入（.mdb）文件。它引入了一种新的默认文件格式（.accdb），它为Access带来了一些改进，包括复杂数据类型，如多值字段，附件数据类型和备注字段中的历史记录跟踪。它还带来了安全性和加密性改进，并支持与Microsoft Windows SharePoint Services 3.0和Microsoft Office Outlook 2007的集成。
**【解决方案】** 1.下载office驱动程序，安装数据连接组件（官网下载链接）
https://www.microsoft.com/en-us/download/details.aspx?id=54920
（本人下载的连接：）
2.将 ConnectionString 属性的 Provider 参数设置为“Microsoft.ACE.OLEDB.16.0”如果要连接到 Microsoft Office access 数据，如果有问题的可以参考我下面的代码修改一下。
3.在运行框用inetmgr命令打开IIS管理器，选择该应用程序的应用程序池——&gt;高级设置——&gt;启动32位应用程序——&gt;true
【ps】有些童鞋的IIS可能没打开，在管理工具中找不到，不要紧，下面介绍一下IIS的打开方式
https://jingyan.baidu.com/article/ac6a9a5e36977d2b653eacb2.html
原文链接：https://blog.csdn.net/YYZZHC999/article/details/79367114
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07b0fe6cb889a9e5d1c6358252c3e1bf/" rel="bookmark">
			【微信读书每日一答辅助小程序】使用python对每日一答问题进行识别，并将结果保存到剪贴板以便搜索。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录标题 1 环境准备2 获取屏幕位置3 指定区域屏幕截图4 文字识别5 按键识别并保存到剪贴板 在腾讯收购阅文之后，微信读书的无限卡已经不能免费看书了，这时白嫖微信读书每日一答的书币成了不错的选择。严重偏科又手速垃圾的我在等级升高下逐渐力不从心，于是突然有了这个想法，写个能快速识别问题文字的小程序，因为现有的识别文字等程序（如QQ）会出现识别速度慢、手动框选识别区域的问题。
1 环境准备 系统：WIN10
python version:3.6
所需要的库：pyautogui,keyboard,PILLOW,baidu-aip
2 获取屏幕位置 既然是对屏幕制定区域进行截图，必须要知道该区域在屏幕上的坐标，因此需要使用pyautogui大三方库，windows上不需要安装其他依赖模块。
import pyautogui print('Press Ctrl-C to quit.') try: while True: # Get and print the mouse coordinates. x, y = pyautogui.position() positionStr = 'X: ' + str(x).rjust(4) + ' Y: ' + str(y).rjust(4) print(positionStr, end='') print('\b' * len(positionStr), end='', flush=True) except KeyboardInterrupt: #按ctrl+c结束程序 print('\nDone.') 3 指定区域屏幕截图 需要使用PILLOW第三方库，安装方法自行百度。实现的操作是对制定区域截图，并保存到目标文件夹中，之后以二进制只读方式打开该图片，返回其结果。每次保存图片会自动覆盖之前的图片，具体代码如下：
from PIL import ImageGrab def get_file_content(): #左上坐标点(x1,y1)，右上坐标点(x2,y2),box = (x1,y1,x2,y2) box = (1450,267,1850,365) #截图 image = ImageGrab.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07b0fe6cb889a9e5d1c6358252c3e1bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63fc8cea032e447e7db2cafaeb3e08b3/" rel="bookmark">
			Java多态 练习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		选择 1、下列代码的运行结果为： C
2、创建一个父类Animal，一个子类Cat，Animal three = new Cat();不是 C
3、下列代码怎么修改可以使其成功运行： A
4、下列关于instanceof说法不正确的是 C
5、已知父类Person,子类Man。判断类Person的对象person1是否满足类Man的实例特征，正确的语句A
6、在Java中，多态的实现不仅能减少编码的工作量，还能大大提高程序的可维护性及可扩展性，那么实现多态的步骤包括以下几个方面除了 B
7、下面代码运行测试后，出现的结果是 D
8、下面代码怎么修改可以编译时不报错（多选） AD
9、下列选项中，关于Java的抽象类和抽象方法说法不正确的是 B
编程 1、应用继承和多态的思想，编写动物类，成员方法是动物叫声。写三个具体的类（猫、狗、羊），它们都是动物类的子类，并重写父类的成员方法。编写测试类，随机产生三种具体动物，调用叫声这个方法。
程序参考运行效果如图所示：
package project0723.demo1; /** * 父类：动物类 */ public abstract class Animal { // 成员属性：种类 private String kind; // get/set方法 public String getKind() { return kind; } public void setKind(String kind) { this.kind = kind; } // 无参构造器 public Animal() { super(); } // 带参构造器 public Animal(String kind) { super(); this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63fc8cea032e447e7db2cafaeb3e08b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d64dffeb2a6e12928bc371a59b19c569/" rel="bookmark">
			SCSA第三天总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.设备登陆管理
首次拿到AC/SG设备时，可以通过以下方法登录设备控制台
SANGFOR AC/SG设备，各网口默认的出厂IP为： eth0(LAN)：10.251.251.251/24 , eth1(DMZ)10.252.252.252/24 【1】、使用一根交叉线连接设备和电脑 (1) 如果电脑连接的是设备的eth0口，需先在电脑上配置一个10.251.251.0/24网段的地 址（10.251.251.251除外），打开浏览器输入https://10.251.251.251 登录设备网关控制台。 (2) 如果电脑连接的是设备的eth1口，需先在电脑上配置一个10.252.252.0/24网段的地址（10.252.252.252除外），打开浏览器输入https://10.252.252.252 登录设备网关控制台。 【2】输入控制台admin帐号登录设备。默认的管理员用户名和密码为admin/admin。 如果设备接口地址被修改，在不知道更改后接口地址的情况下，提供以下2种方法登录设备
【1】、SANGFOR AC/SG设备的lan口(默认eth0定义为lan)有保留IP地址为128.127.125.252/29, 请配置电脑IP地址为128.127.125.253/29, 用交叉线连接电脑和设备eth0口，通过https://128.127.125.252登录设备网关控制台。 同时，AC/SG设备dmz口(默认eth1定义为dmz)也有保留IP地址128.128.125.252/29，也可以通过交叉线电脑接到设备eth1口，且电脑配置IP为128.128.125.253/29，通过https://128.128.125.252登录设备控制台。 【2】、通过SANGFOR 升级系统工具查找设备地址后，通过查找得到的地址进设备控制台 （1）安装SANGFOR 升级系统工具的PC和设备使用交叉线直连 （2）关闭PC上安装的防火墙及windows自带防火墙 （3）通过SANGFOR 升级系统工具查找设备地址 （4）通过SANGFOR 升级系统工具查到的地址登录设备 2.恢复出厂设置
恢复出厂配置会使设备重启。
对于能够正常登录设备的情况，可以通过以下四种方法恢复出厂配置
【1】、通过控制台界面恢复出厂配置：恢复出厂配置会重启设备，通过此方法恢复出厂配置后，再次登录控制台，右下角会有“恢复成功”的提示 【2】、通过SANGFOR 升级系统工具恢复出厂配置 【3】、交叉线短接设备两个电口恢复 【4】、U盘恢复出厂设置 3.恢复控制台密码
如果忘记了admin的密码，导致无法登录设备，又需要保留设备配置（即不能恢复出厂配置），可以通过下面两种方法单独恢复admin的密码。
（1）交叉线恢复控制台密码 【1】.确保电脑和设备可以通信，访问设备地址，https://acip/php/rp.php，如下图，提示“创建文件成功，请连接交叉线并重启设备”。 【2】.准备交叉线短接设备任意两个非一组bypass电口（例如eth0和eth2是bypass口，就不能短接这两个口恢复密码） 【3】.手动重启设备，重启过程中，注意观察交叉线短接的两个电口ACT灯状态，两个电口ACT灯同时闪烁10次后，说明密码恢复完成，此时可以拔掉短接的交叉线，通过默认的控制台帐号密码admin/admin登录设备即可。设备重启到密码恢复成功大约3到5分钟左右。 【4】.如果第3步无法根据网口灯状态判断密码恢复是否成功，你可以一直等待，等待5到10分钟左右，尝试通过默认帐号admin/admin帐号登录设备。 （2）U盘恢复密码 【1】.新建一个txt文档，将其重命名为reset-cfg.txt，将txt文档拷贝到U盘根目录，U盘格式为FAT 32的。 【2】.确保电脑和设备可以通信，访问设备地址 https://ACIP/php/rp.php 【3】.AC上插入U盘，重启设备 【4】.当设备的LED红灯熄灭之后，alram灯闪烁即恢复密码成功，拔出U盘 注意事项：U盘恢复密码,需要设备重启 4.部署模式
路由模式
简介： 设备以路由模式部署时，AC的工作方式与路由器相当，具备基本的路由转发及NAT功能。一般在客户还没有相应的网关设备或者用户的网络环境规模比较小，需要将AC做网关使用时，建议以路由模式部署。 路由模式下支持AC所有的功能。 如果需要使用NAT、VPN、DHCP等功能时，AC必须以路由模式部署，其它工作模式没有这些功能。 配置思路： 【1】、网口配置：配置各网口地址。如果是固定IP，则填写运营商给的IP地址及网关；如果是ADSL拨号上网，则填写运营商给的拨号帐号和密码；确定内网口的IP； 【2】、确定内网是否为多网段网络环境，如果是的话需要添加相应的回包路由，将到内网各网段的数据回指给设备下接的三层设备。 【3】、用户是否需要通过AC设备上网，如果是的话，需要设置NAT规则。 【4】、检查并放通防火墙规则 排错思路： （1）检查PC本身的网口IP，子网掩码 （2）检查PC本身的默认网关，首选的DNS服务器 （3）检查AC上给PC做的SNAT （4）检查AC上给PC做的回包路由 （5）被PC访问的设备本身能否上网 PING /TELNET /WGET （6）网口兼容性 换网线 换网口 中间加交换机 （7）arp防护和免费arp可能存在冲突 （8）通过ifconfig检查网口错误包或者丢包，ethtool -S 查看丢包类型 网桥模式：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d64dffeb2a6e12928bc371a59b19c569/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6166521de5c8b6f7c2d9cde835b9ea18/" rel="bookmark">
			git之.gitignore文件详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：git-book
一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。
通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件的模式。
.gitignore文件的作用总结 .gitignore文件用来忽略被指定的文件或文件夹的改动，被记录在.gitignore文件里的文件或文件夹，是无法被git跟踪到的，即被忽略的文件是不会被放入到远程仓库里的。如果文件已经存在于远程仓库中，是无法通过.gitignore文件来忽略的。
.gitignore文件的创建 .gitignore 文件存放于git仓库的根目录下。
linux / mac 下在命令行创建/删除 .gitignore 文件命令如下：
touch .gitignore # 新建 rm -f .gitignore # 删除 windows 系统 win10 以前的版本可能无法直接用视图菜单创建/删除以 . 号开头的文件，需要在命令行操作：
:: 创建 TYPE NUL&gt;.gitignore :: 删除 DEL /F .gitignore .gitignore 文件的格式规范(语法) 所有空行或者以 # 开头的行都会被 Git 忽略。可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。匹配模式可以以（/）开头防止递归。匹配模式可以以（/）结尾指定目录。以叹号!表示不忽略(跟踪)匹配到的文件或目录。 glob 模式是指 shell 所使用的简化了的正则表达式。
星号（*）匹配零个或多个任意字符；问号（?）只匹配一个任意字符；[ ]表示匹配中括号内的单个字符：
(1) [abc] 要么匹配一个 a，要么匹配一个 b，要么匹配一个 c
(2) 可以使用-来表示连贯的字符，比如0-9，a-z，A-Z等，[0-9]表示匹配从0到9的单个字符。
(3) 可以使用^来表示除外，比如[^0-9]表示除0到9之外的单个字符。使用两个星号（**）表示匹配任意中间目录，比如 a/**/z 可以匹配 a/z 、 a/b/z 或 a/b/c/z 等。 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6166521de5c8b6f7c2d9cde835b9ea18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b40b18ec5199d0c8c697fac48dae2b4c/" rel="bookmark">
			Robert边缘检测算子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Robert算子是一种利用局部差分算子寻找边缘的算子，它实际也是一种梯度处理法，只是它用的算子与上篇梯度法的算子不一样。 上篇是标准差分算子，而Rboert用的是对角线差分。
其差分计算式为：
其算子为：
# -*- coding:gbk -*- import cv2 import numpy as np import matplotlib. pyplot as plt #读取图像 img = cv2. imread('lena512color.tiff') #灰度化处理图像 grayImage = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) #Roberts算子 kernelx = np.array([[-1,0],[0,1]], dtype = int) kernely = np.array([[0,1],[-1,0]], dtype=int) x = cv2.filter2D(grayImage, cv2.CV_16S, kernelx) y = cv2.filter2D(grayImage, cv2.CV_16S, kernely) #转uint8 absX = cv2.convertScaleAbs(x) absY = cv2.convertScaleAbs(y) Roberts = cv2.addWeighted(absX, 0.5, absY, 0.5, 0) #用来正常显示中文标签 plt. rcParams['font.sans-serif']=['SimHei'] #显示图形 titles = ['原始图像', 'Roberts算子'] images = [grayImage, Roberts] for i in range(2): plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b40b18ec5199d0c8c697fac48dae2b4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ace4c80adc4f9f1321d2c16e2f8327be/" rel="bookmark">
			Asp.Net Core 使用Ado创建三层架构(添加与查询)实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明：搭建.Net Core使用Ado创建三层架构，跟着这个实例走，傻瓜都能成功！O(∩_∩)O哈哈~ 首先介绍下环境：
vs2019,
netcore3.1,
SQLClient 4.8.1
用SqlServer 2008 r2测试数据
一、创建netcore模板项目 1.新建.net core模板 （UI层）
2.添加除UI（用户层），.net core类库 DAl (数据访问层)BLL(业务逻辑层)和Model(实体层）另外添加了Common（公共层），可以把第三方插件或通用的Helper放进Common层。
3.创建成的的三层
二 三层框架之间的关系处理： 1 三层架构就是为了符合“高内聚，低耦合”思想，把各个功能模块划分为表示层（UI）、业务逻辑层（BLL）和数据访问层（DAL）三层架构，各层之间采用接口相互访问，并通过对象模型的实体类（Model）作为数据传递的载体，不同的对象模型的实体类一般对应于数据库的不同表，实体类的属性与数据库表的字段名一致。
三层架构区分层次的目的是为了 “高内聚，低耦合”。开发人员分工更明确，将精力更专注于应用系统核心业务逻辑的分析、设计和开发，加快项目的进度，提高了开发效率，有利于项目的更新和维护工作。
2.UI 引用 BLL，Model， Common
3.BLL 引用 DAL，Model，Common
4.DAL引用 Model，Common
5.Model 引用Common
具体引用方式如下图：
（1）UI层&gt;依赖项&gt;右键&gt;添加项目引用
BLL Model Common 打上对勾 然后保存。
（2）BLL，DAl，Model层同上
三 使用Ado连接数据库 1.打开DAL的类引用using System.Data.SqlClient; 会发现报错。（查资料发现.net core 将之前的dll文件换成了nuget文件）
（1）安装nuget 文件 （SQLClient 4.8.1）
点击工具&gt;nuget 管理器&gt;管理解决方案 nuget包
（2） 安装到DAL类库上，然后就可以尽情的控制数据库了。
四 .NetCore 读取配置文件： 可以参考
.NetCore 读取配置文件(随手笔记)
五 Demo 下载链接： Asp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ace4c80adc4f9f1321d2c16e2f8327be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a84cd804e91d860863877fa1c71670a1/" rel="bookmark">
			HLS加密、解密细节
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		加密：使用FFmpeg进行视频文件切割转m3u8索引文件（ts文件）并AES-128加密；
解密：索引m3u8文件含有获取解密匙URI,大致如下：
#EXT-X-KEY:METHOD=AES-128,URI=“https://priv.example.com/key.php?r=53”
URI部分就是去获取解密匙的http请求，进行边解密边播放。
URI可以加token进行权限控制。
加密解密原理参考：https://blog.csdn.net/coloriy/article/details/47295499?utm_source=blogxgwz9
使用ffmpeg将视频切片并加密参考：https://blog.csdn.net/zyxzj/article/details/104520298
java调用ffmpeg开源项目（maven引入，免安装FFmpeg）：https://github.com/a-schild/jave2
//java调用ffmpeg开源项目：https://github.com/a-schild/jave2 //使用FFmpeg命令如下 FFMPEGLocator locator = new DefaultFFMPEGLocator(); FFMPEGExecutor ffmpeg = locator.createExecutor(); ffmpeg.addArgument("some i need self operation here"); ffmpeg.execute(); ffmpeg.destroy(); 使用ffmpeg将视频切片并加密：
前提条件，需要有ffmpeg，最新版格式工厂安装后，会自动装上ffmpeg
新建一个记事本，取名enc.key（名字可以随便取），添加16个字节的秘钥，如
qwertyuiop123456 新建一个文件，enc.keyinfo，添加如下内容
http://localhost:8080/enc.key enc.key 这里需要把enc.key和enc.keyinfo放在同一目录下
在当前目录运行cmd或者powershell
执行
ffmpeg -y -i video.mp4 -hls_time 12 -hls_key_info_file enc.keyinfo -hls_playlist_type vod -hls_segment_filename "file%5d.ts" video.m3u8 解释：
video.mp4 --需要处理的视频
-hls_time 12 --将分片时长设置为12秒
-hls_segment_filename “file%5d.ts” --设置ts文件格式化名称
video.m3u8 --m3u8文件名
生成后，将所有文件移动到本地搭建的tomcat中，方便测试
同时，将enc.key也放到本地服务中，保证KeyUrl可以访问：http://localhost:8080/enc.key，这样一来，m3u8就可以在支持网络串流的播放器中播放了，这里推荐使用VLC media player，播放时，m3u8文件会自动寻找秘钥keyUrl
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae4fb1a799730f60840966faed915f9b/" rel="bookmark">
			不用 Python 自带的 Dict 实现自己的 HashTable
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个题目其实源于很久之前的一次 Uber 面试，码工换工作无非就是刷 leetcode ，研究如何翻转二叉树之类的算法问题，所以头一次在电话里听到这道题的时候还是挺耳目一新的。当时顺利写出来了，也通过了电面，但觉得还是有不完善的地方，比如说代码不够 “Pythonic” 等，所以趁着周天晚上闲着无事，又拿出来写了写。
HashTable 本身没啥好说的，中文叫”哈希表“或者”散列表“，具体翻译看教材编写者的个人喜好。众所周知这个数据结构用来存储”键-值“结构的数据，可以做到常数级时间复杂度的查找，在日常搬砖中算是主力工具。实现一个 HashTable 其实就是实现两个部分
Hash 函数。这个函数能够读入一个可被 hash 的变量，输出一个整数。在本次实现中暂不考虑这一块，用 Python 自带的 hash 函数偷个懒Hash 冲突的解决机制。成熟的方法有很多种，在这里只考虑最简单的一种，即将同一个 hash 值下的不同的 key 存放在数组的同一个位置，以链表形式保存 既然是自己实现，就根据 HashTable 的查找原理选择 List 作为数据存储结构，在每个位置放置一个子 List 用于解决 hash 冲突，因此对于构造函数来说，大概应该长这个样子
class MyDict(object): def __init__(self, size=99999): self.hash_list = [list() for _ in range(size)] self.size = size 每次添加一个键值对时，将 key hash 后的整数对 List 长度取模，即得到该 key 在 List 中的位置。因为 List 的每个位置是一个子 List ，所以需要遍历该子 List ，如果已存在该键值对，则更新 value ；如果不存在，将该键值对存在尾部。
def __setitem__(self, key, value): hashed_key = hash(key) % self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae4fb1a799730f60840966faed915f9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d29d9bcdbb59eaf2f482897d534e323a/" rel="bookmark">
			HBase API基本操作（含java代码实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、环境准备
1、启动服务
2、创建Maven工程
二、HBaseAPI
1、编写一个Student类
2、编写HBaseAPI类
3、测试结果
在前面我们已经安装和部署好了HBase服务，并对HBase的架构原理做了介绍：
HBase1.3.3安装部署详细步骤
HBase的架构、数据结构和进阶原理（读写流程、flush、合并、拆分）详解
那么，本篇文章再结合具体的例子对HBase的java API做一个基本实现，具体如下：
一、环境准备 1、启动服务 启动Zookeeper服务；启动Hadoop服务；启动HBase服务； 2、创建Maven工程 导入以下依赖：
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hbase&lt;/groupId&gt; &lt;artifactId&gt;hbase-server&lt;/artifactId&gt; &lt;version&gt;1.3.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hbase&lt;/groupId&gt; &lt;artifactId&gt;hbase-client&lt;/artifactId&gt; &lt;version&gt;1.3.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hbase&lt;/groupId&gt; &lt;artifactId&gt;hbase-common&lt;/artifactId&gt; &lt;version&gt;1.3.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 二、HBaseAPI 1、编写一个Student类 package xsluo.hbase; public class Student { private String id; private String name; private String age; private String gender; private String phone; private String email; public Student(){ } public Student(String id,String name,String age,String gender,String phone,String email) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d29d9bcdbb59eaf2f482897d534e323a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f098e9090998f97574b4cabac7452c7/" rel="bookmark">
			DATE_SUB(NOW(), INTERVAL 10 MINUTE)的用法（mysql）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 DATE_SUB(NOW(), INTERVAL 10 MINUTE) 是MySQL的方法，在时间判断中会经常用到。
1. 应用场景： 查询10分钟设备是否在线，根据上报时间判断
2. 原理： DATE_SUB(NOW(), INTERVAL 10 MINUTE) : 当前时间减去十分钟
查询上报时间在十分钟以内的设备大于0就在线，否则就离线
SELECT IF ( COUNT( 1 ) = 0, '离线', '在线' ) AS 设备状态 FROM ( SELECT mac_address FROM pro_device_resource WHERE mac_address = 'Mac地址' AND create_time &gt; DATE_SUB( NOW(), INTERVAL 1 HOUR ) GROUP BY mac_address )s 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2770bb560ca1a53e9d8e8596e84062dc/" rel="bookmark">
			什么情况下不能使用最坏情况评估算法的复杂度？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本篇文章收录于专辑：http://dwz.win/HjK，点击解锁更多数据结构与算法的知识。
你好，我是彤哥，一个每天爬二十六层楼还不忘读源码的硬核男人。
上一节，我们从最坏、平均、最好三种情况分析了算法的复杂度，得出结论，通常来说，使用最坏情况来评估算法的复杂度完全够用了。
但是，有些算法是不能使用最坏情况来评估算法的复杂度的。
那么，有哪些算法呢？
本节，我们将从动态数组以及快速排序这两个个例入手来分析不能使用最坏情况评估复杂度的情形。
动态数组 动态数组，对应于Java中的ArrayList，在插入元素时，分成两种情况：
数组未满，元素放在size下标的位置即可；数组满了，需要扩容，一般扩容为N倍大小，Java里面是1.5倍，扩容时需要创建一个新的数组，并把原来的元素一个一个地拷贝到新的数组中，再插入新的元素； 我简单地写一段代码，你可以感受下：
public class DynamicArray { private int[] array; private int size; public DynamicArray(int capacity) { this.array = new int[capacity]; this.size = 0; } // 插入元素，时间复杂度为多少呢？ public void add(int element) { // 判断是否需要扩容 if (size &gt;= array.length) { int newCapacity = array.length + (array.length &gt;&gt; 1); int[] newArray = new int[newCapacity]; for (int i = 0; i &lt; array.length; i++) { newArray[i] = array[i]; } this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2770bb560ca1a53e9d8e8596e84062dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5546aae6a3efa481a0e898ddda70dbba/" rel="bookmark">
			Microsoft SQL Server Management Studio（SSMS）概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 (Introduction) Microsoft SQL Server Server Management is an advanced development environment that enables us to configure, manage and administrate SQL Server database engines. SSMS is very popular and widely used by the database developers and administrators because of the following advantages: Microsoft SQL Server服务器管理是一个高级开发环境，使我们能够配置，管理和管理SQL Server数据库引擎。 由于以下优点，SSMS受到数据库开发人员和管理员的广泛欢迎和广泛使用： Cost-free 免费用 Advanced user experience 先进的用户体验 Various add-in options 各种加载项选项 Easy installation 简易安装 Firstly, we will learn the installation and then go through the other details of the SSMS.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5546aae6a3efa481a0e898ddda70dbba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ceed31e254a910ea80da33660a27073/" rel="bookmark">
			注册全局组件 vue.js_vue.js验证组件，用于登录或注册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注册全局组件 vue.js
Vue拖动验证 (vue-drag-verify) This is a vue component, which is sliding to unlock some functionalities, such as login or sign up. This is used to protect your web app from attack.
这是一个Vue组件，可以滑动以解锁某些功能，例如登录或注册。 这用于保护您的Web应用程序免受攻击。 View demo 查看演示 Download Source 下载源 安装 (Installation) npm install vue-drag-verify --save 用法 (Usage) &lt;drag-verify :width="width" :height="height" :text="text" :success-text="successText" :background="background" :progress-bar-bg="progressBarBg" :completed-bg="completedBg" :handler-bg="handlerBg" :handler-icon="handlerIcon" :text-size="textSize" :success-icon="successIcon" :circle="getShape"&gt;&lt;/drag-verify&gt; import Vue from 'vue' import dragVerify from 'vue-drag-verify' export default { name: 'app', components:{ dragVerify } } 道具 (Props) PropertyTypeDefaultDescriptionwidthNumber200The width of the componentheightNumber60The height of the componenttextStringswiping to the right sideThe text shows on the componentsuccessTextStringsuccessThe text shows when it’s successfulbackgroundString#cccThe background color of the componentcolorString#ffffffThe color of the textprogressBarBgString#FFFF99The backgound color of the progress barcompletedBgString#66cc66The backgound color of the component when the button dragged to the right sidecircleBooleantrueIf true, the shape of component is roundhandlerIconString-The icon of handlersuccessIconString-The icon of handler when the button dragged to the right sidehandlerBgString#fffThe background color of the handlertextSizeString20pxFont size of prompt message 属性 类型 默认 描述 宽度 数 200 组件的宽度 高度 数 60 组件的高度 文本 串 向右滑动 文本显示在组件上 successText 串 成功 文字显示成功的时间 背景 串 #ccc 组件的背景色 颜色 串 #ffffff 文字颜色 progressBarBg 串 ＃FFFF99 进度条的背景色 已完成 串 ＃66cc66 当按钮拖动到右侧时组件的背景色 圈 布尔型 真正 如果为true，则组件的形状为圆形 handlerIcon 串 -- 处理程序的图标 successIcon 串 -- 按钮拖动到右侧时的处理程序图标 handlerBg 串 #fff 处理程序的背景色 字体大小 串 20像素 提示消息的字体大小 事件 (Event) 回叫 (passcallback) Emitted when pass verify, the handler dragged to the right side.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ceed31e254a910ea80da33660a27073/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a5e9b93ea4fccad3b07bcb6185d12a9/" rel="bookmark">
			Flume之JMX监控三种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		监控作用 在flume运行期间，我们可以通过监控channel当前容量和已使用容量来调整channel是否需要扩容通过source向channel中put成功了多少event和sink从channel中take成功了多少个event，比较数据是否存在积压做出调整（通过sink组，和batchsize参数可增加sink读取速度） 监控原理 通过Java提供的JMX技术（java monitor extension）即 java监控扩展模块，是J2EE定义的14种技术规范之一。
JMX可以帮助我们监控一个java进程中需要了解的参数，可以实时修改java进程中的某个对象的参数 。
具体操作：
创建MBean（monitor bean）：需要监控的参数封装到一个Bean中创建 JMX的monitor服务：该服务可以在程序希望获取到MBean参数时来请求服务，该服务可帮我们对Bean中的参数进行读写操作客户端：客户端向JMX发送服务请求，返回MBean信息 在flume 中已经为我们编写了MBean和JMX Monitor服务，我们需要启动服务并使用客户端查看
官方文档 monitoring
客户端 方式一：使用Jconsole查看 JMX Reporting JMX Reporting can be enabled by specifying JMX parameters in the JAVA_OPTS environment variable using flume-env.sh, like
export JAVA_OPTS=”-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=5445 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false”
NOTE: The sample above disables the security. To enable Security, please refer http://docs.oracle.com/javase/6/docs/technotes/guides/management/agent.html
在fulme的conf/flume-env.sh 中配置上述中 JAVA_OPTS 环境变量（首次配置需要重命名去掉.template后缀）
运行一个fulme任务
通过jdk自带 %JAVA_HOME%/bin/jconsole.exe 监控
方式二：浏览器发送web请求 JSON Reporting … …
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a5e9b93ea4fccad3b07bcb6185d12a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a07d889504bf80278884a8140e669d45/" rel="bookmark">
			Kylin原理解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 概述 Apache Kylin是一个开源的分布式分析引擎，提供Hadoop/Spark智商的SQL查询接口及多维分析（OLAP）能力以支持超大规模数据。
注：OLAP（Online Analytical Process），联机分析处理或在线分析。
最初由eBay开发并贡献至开发社区，它能在亚秒内查询巨大的hive表。Kylin也是由中国人主导的、唯一的Apache顶级开源项目，在开源社区有世界级的影响力。
1.1 Kylin特点 1.1.1 大数据OLAP的两个事实 （1）大数据查询要的一般是统计结果，是多条记录经过聚合函数计算后的统计值。原始的记录则不是必须的，或者访问频率和概率都极低。
（2）聚合是按维度进行的，由于业务范围和分析需求是有限的，有意义的维度聚合组合也是相对有限的，一般不会随着数据的膨胀而增长。
Kylin基于以上两点，得到一个新的思路——预计算。应尽量多地预先计算聚合结果，在查询时刻应尽量使用预算的结果得出查询结果，从而避免直接扫描可能无限增长的原始记录。
1.1.2 Kylin特点 Kylin的主要特点包括支持SQL接口、支持超大规模数据集、亚秒级响应、可伸缩性、高吞吐率和BI工具集成等。
（1）可扩展超快OLAP引擎Kylin是为减少在Hadoop/Spark上百亿规模数据查询延迟而设计。
（2）Hadoop ANSI SQL接口Kylin为Hadoop提供标准SQL支持大部分查询功能。
（3）交互式查询能力通过Kylin，用户可以与Hadoop数据进行亚秒级交互，在同样的数据集上提供比Hive更好的性能。
（4）多维立方体（MOLAP Cube）用户能够在Kylin里为百亿以上数据集定义数据模型并构建立方体。
（5）与BI工具无缝整合Kylin提供与BI工具的整合能力，如Tableau、PowerBI/Excel、MSTR、QlikSense、Hue和SuperSet。
1.2 Kylin工作原理 Kylin的工作原理本质上是MOLAP（Multidimensional Online Analytical Processing）Cube，即多维立方体分析。
这是数据分析中相当经典的理论，在关系数据库年代就已经有了广泛的应用。
在说明MOLAP Cube之前需要先介绍一下维度（Dimension）和度量（Measure）这两个概念。
1.2.1 维度（Dimension）和度量（Measure）简介 （1）维度
简单来讲，维度就是观察数据的角度。它通常是数据记录的一个属性，例如时间和地点等。
比如电商的销售数据，可以从时间的维度来观察，也可以进一步细化，从时间和地区的维度来观察。
维度一般是一组离散的值，比如时间维度上的每一个独立的日期，或者商品维度上的每一件独立的商品。
因此统计时可以把维度值相同的记录聚合在一起，然后应用聚合函数做累加、平均、去重技术等聚合操作
（2）度量
度量就是被聚合后的统计值，也就是聚合运算的结果，如图中的销售额，或者是销售商品的总件数。
度量是基于数据所计算出来的考量值；它通常是一个数值，如总销售额、不同的用户数等。
通过比较和测算度量，分析师可以对数据进行评估，比如今年的销售额相比去年有多大的增长，增长的速度是否达到预期，不同商品类别的增长比例是否合理等。
在一个SQL查询中，Group By的属性通常就是维度，而计算出的值则是度量。
1.2.2 Cube和Cuboid 有了维度和度量，一个数据表或数据模型上的所有子弹就可以分类了，它们要么是维度，要么是度量（可以被聚合）。于是就有了根据维度和度量做预计算的Cube理论。
给定一个数据模型，我们可以对其上的所有维度进行组合。对于N个维度来说，组合的所有可能性共有2^n种。
对于每一种维度的组合，将度量做聚合运算，然后将运算的结果保存为一个物化视图，称为Cuboid。
所有维度组合的Cuboid作为一个整体，被称为Cube。
所以简单来说，一个Cube就是许多按维度聚合的物化视图的集合。
下面来列举一个具体的例子：
假定有一个电商的销售数据集，其中维度包括：时间（Time）、商品（Item）、地点（Location）和供应商（Supplier），度量包括：销售额（GMV）。
那么所有维度的组合就有2^4=16种。
（1）一维度（1D）的组合有[Time]、[Item]、[Location]和[Supplier]4种；
（2）二维度（2D）的组合有[Time，Item]、[Time，Location]、[Time、Supplier]、 [Item，Location]、[Item，Supplier]、[Location，Supplier]6种；
（3）三维度（3D）的组合也有4种；
（4）最后零维度（0D）和四维度（4D）的组合各有1种。
计算Cuboid，即按维度来聚合销售额。如果用SQL语句来表达计算Cuboid[Time，Loca-tion]，那么SQL语句如下：
SELECT Time,Location,Sum(GMV) as GMV FROM Sales GROUP BY Time,Location； 将计算的结果保存为物化视图，所有Cuboid物化视图的总称为Cube。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a07d889504bf80278884a8140e669d45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bae62e0f9e253fe121b6d66f815d81c/" rel="bookmark">
			Flink CEP-NFA详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 CEP-NFA是什么 Flink 的每个模式包含多个状态，模式匹配的过程就是状态转换的过程，每个状态(state)可以理解成由Pattern构成，为了从当前的状态转换成下一个状态，用户可以在Pattern上指定条件，用于状态的过滤和转换。
实际上Flink CEP 首先需要用户创建定义一个个pattern，然后通过链表将由前后逻辑关系的pattern串在一起，构成模式匹配的逻辑表达。然后需要用户利用NFACompiler，将模式进行分拆，创建出NFA(非确定有限自动机)对象，NFA包含了该次模式匹配的各个状态和状态间转换的表达式。整个示意图就像如下：
2 CEP的三种状态迁移边 （1）Take: 表示事件匹配成功，将当前状态更新到新状态，并前进到“下一个”状态；
（2）Procceed: 当事件来到的时候，当前状态不发生变化，在状态转换图中事件直接“前进”到下一个目标状态；
（3）IGNORE: 当事件来到的时候，如果匹配不成功，忽略当前事件，当前状态不发生任何变化。
为了更好地理解上述概念，本文利用下面的代码，构建一个NFA：
//构建链接 patterns Pattern pattern = Pattern.begin("start").where(new SimpleCondition() { private static final long serialVersionUID = 5726188262756267490L; @Override public boolean filter(Event value) throws Exception { return value.getName().equals("c"); } }).followedBy("middle").where(new SimpleCondition() { private static final long serialVersionUID = 5726188262756267490L; @Override public boolean filter(Event value) throws Exception { return value.getName().equals("a"); } }).optional(); //创建nfa NFA nfa = NFACompiler.compile(pattern, Event.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bae62e0f9e253fe121b6d66f815d81c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fac2d407bf154d94090d401e7b29be4/" rel="bookmark">
			Flink CEP SQL详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 语法 SELECT [ ALL | DISTINCT ] { * | projectItem [, projectItem ]* } FROM tableExpression [MATCH_RECOGNIZE ( [PARTITION BY {partitionItem [, partitionItem]*}] [ORDER BY {orderItem [, orderItem]*}] [MEASURES {measureItem AS col [, measureItem AS col]*}] [ONE ROW PER MATCH|ALL ROWS PER MATCH|ONE ROW PER MATCH WITH TIMEOUT ROWS|ALL ROWS PER MATCH WITH TIMEOUT ROWS] [AFTER MATCH SKIP] PATTERN (patternVariable[quantifier] [ patternVariable[quantifier]]*) WITHIN intervalExpression DEFINE {patternVariable AS patternDefinationExpression [, patternVariable AS patternDefinationExpression]*} )]; 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fac2d407bf154d94090d401e7b29be4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d18fbbabbd3f0772422a1e333050e3f/" rel="bookmark">
			MySQL知识集合之基础查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL知识集合之基础查询 一、絮絮叨叨二、基础查询知识点 1.查询表中单个字段: 2.查询表中多个字段: 3.查询表中所有字段: 4.查询常量: 5.查询表达式: 6.函数: 7.起别名: 8.去重: 9.'+'号的作用: 10.concat 拼接: 11.ifnull: 12.条件查询: 13.模糊查询: 14.排序查询: 二、尾言小小推荐 一、絮絮叨叨 最近正在学习MySql相关知识，我想MySql的重要性就不用我多费口舌了吧，那是相当重要的。我认为MySQL中这么多的语句语法想要硬记下来还是有点难度的（至少对于我这个小白来说是很难办到的啦），于是我决定一边学习，一边将一些基础知识点、笔记等，以博客的形式简要地记录下来，以便以后能够快速温习，所谓好记性不如烂博客嘛！
同是天涯码字猿，共勉 ~ 共勉 ~ 二、基础查询知识点 1.查询表中单个字段: 语法:select 字段名 from 表名; 示例: select id from cook; 2.查询表中多个字段: 语法:select 字段名1,字段名2,...3... From 表名; 示例: select id,content from cook; 3.查询表中所有字段: 语法:select * from 表名; 示例：select * from cook; 4.查询常量: 语法:select 常量; 示例: select 100; 5.查询表达式: 语法:select 表达式; 示例:select 10*2; 6.函数: 语法:select 函数; 示例:select version();查询mysql版本号; 7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d18fbbabbd3f0772422a1e333050e3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05cc15b038665cb10673c1c202af85c9/" rel="bookmark">
			Skynet是什么呢？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Skynet是什么呢？
我们希望游戏服务器能够充分利用多核优势，将不同的业务放在独立的执行环境中处理，协同工作。这个执行环境最早期望是利用操作系统的进程，后来发现如果必定采用嵌入式语言如Lua，那么独立的操作系统进程的意义不大。LuaState已经提供了良好的沙盒，隔离不同执行环境，而多线程模式可以使得状态共享、数据交换更加高效。但是多线程模型又存在诸多弊病，比如复杂的线程锁、线程调度问题等。这些问题都可以通过减小底层的规模精简设计，最终把危害限制在很小的范围内。
早期的Skynet v0版本中，Skynet是使用Erlang+C driver开发的，Erlang中的多进程似乎是：每个玩家都有一个代理服务。当在在40v40时，使用台式机测试时是存在困难的，于是Cloud滋生了重新考虑之前的设计的念头。由于之前的设计方案是：每个代理的状态都需要通知给其他代理，这造成了大量内部消息重复，这明显是可以优化的。
掂量下，如果设计一个共享无锁队列，避免了无谓复制，内部消息包可以降低90%，整体性能能提升15%左右。为了验证Skynet v0的性能，编写了一个简单的Skynet v1，v1完全使用C作底层通信框架，摒弃了之前ZeroMQ提供通信的部分，提供Lua接口编写应用服务，整体代理在4000多行的C代码和1000多行的Lua代码，完成了Skynet v0一样的功能。
Skynet提供了一个简洁、稳定、高效、高可用的分布式服务开发框架。
Skynet是一个轻量级通用的服务器基础框架
Skynet是基于C与Lua的开源服务端并发框架，使用单进程多线程Actor模型。
Skynet服务器支持10K+客户端接入和处理
Skynet当前规模是8K多行的C代码和2K多行Lua代码，实现了一个多线程高并发的在线游戏后台服务框架，提供定时器、开发调度、服务扩展框架、异步消息队列、命名服务等基础能力，支持Lua脚本。
Skynet是一个轻量级网络服务器架构而非完整的游戏服务端，它是服务端的最底层框架，和游戏业务相关的服务都是基于此框架之上开发的。其功能只是管理好服务（加载和调度）和服务之间的调用（请求和响应）。
Skynet特点的什么
少量C代码和大量Lua代码组成
基于Actor模型，天然多线程。
天然集成网络、数据库访问功能
使用Lua的协程处理消息永不堵塞
自带集群功能
官方只支持Linux
Skynet的优点是什么
高低级语言配合
Skynet是融合了低级语言C消息框架和高级动态语言Lua的混合体，这种结构称为hybird framework混合框架，使用运行高效的C来编写服务节点，使用Lua开发高效且安全隔离的上层业务。
组件化能力
Skynet内核（C部分）自身支持加载模块*.so，可使用C语言编写性能有要求的服务节点，通过消息与其他节点配合。而Lua又是对C语言极为友好的动态语言，所以可找到很多Lua的C扩展。
Skynet核心是什么
C实现的消息循环和组件加载机制
Lua实现的以消息为中心的进入退出协程的包装层
Skynet核心解决什么问题呢？
作为核心功能，Skynet仅解决一个问题：把符合规范的C模块从动态库（.so文件）中启动起来，绑定一个永不重复（即使模块退出）的数字ID作为其处理器handle。这里我们称模块为服务service，服务之间可以自由发送消息，每个模块可以向Skynet框架注册一个回调函数callback，用来接收发给它的消息。每个服务都是一个个消息包驱动，当没有包到来时，它们就会处于挂起状态，对CPU资源零消耗。如果需要自主逻辑则可利用Skynet提供的timeout消息定期触发。
Skynet提供了名字服务，可以给特定的服务起一个易读的名字，而不是使用ID来指代。因为ID和运行时状态相关，无法保证每次启动服务都有一致的ID，当名字却可以。
Skynet核心不解决什么问题？
Skynet的消息传递都是单向的，以数据包为单位传递。并没有定义类似于TCP连接的概念，也没有约定RPC调用的协议。不规定数据包的编码方式，也没有提供一致的复杂数据结构的列集API。
Skynet原则上主张所有服务器都在同一个操作系统进程上协作完成，所以在核心层内部考虑跨机器通讯机制。Skynet不为单独服务的崩溃、重启提供支持，和普通的单线程程序一样，你要为你代码中的bug和意外负责。和操作系统不同的是：操作系统会认为用户进程都是不可靠的，它不会让一个用户进程的错误影响到另一个进程。但Skynet内所有的服务都有统一的目的，为游戏的最终客户服务。因此某个环节出了错误都可能是致命的，因此没有必要被问题隔离开。
简单来说，Skynet只负责把一个数据包从一个服务内发送出去，让同一进程内的另一个服务接收然后调用对应的callback函数处理。Skynet保证模块的初始化过程时，每个独立的callback都是相互线程安全的。编写服务的人不需要特别的为多线程环境考虑任何问题，专心处理发送给它的一个个数据包即可，其实这就是Erlang的Actor模型。
为了提供高效的服务间通讯，Skynet并不关心数据包是怎样被打包的，它甚至不要求这个数据包内的数据是连续的，虽然这样做很危险，在跨机通讯中除非你保证你所有的数据包绝对不被传递到当前所在进程中。因为它仅仅是把数据包的指针以及声明的数据包长度传递出去。由于服务都是在同一个进程内，因此接收方取得这个指针后就可以直接处理其引用的数据了。这个机制在必要时，可以保证绝对的零拷贝，几乎等于在同一线程内做一次函数调用的开销，当然这只是Skynet提供性能上可能性。推荐一种更为可靠但性能略低的解决方案：约定每个服务发送出来的包都复制到用malloc分配出来的连续内存。接收方在处理完这个数据块，也就是在处理的callback函数调用完毕时，会默认调用free函数释放掉所占用的内存空间。简单来说就是：发送方申请内存而接收方释放内存。
更多面试资料与往期视频请关注公众号
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/140a3cd2a661479e7847f38c36e31d39/" rel="bookmark">
			python中将四元数转换为旋转矩阵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在制作bundlefusion时,想测试TUM数据集,并且将groundtruth写入到数据集中,TUM中给定的groundtruth中的旋转是使用四元数表示的,而bundlefusion中需要SE3的形式,所以我需要首先将四元数转换为旋转矩阵,然后再将其与平移向量合并在一起,因为我之前关于生成bundlefusion数据集写了一些python脚本,所以这次仍然想在原来的脚本上完成这项任务,所以我就在网上搜索,实现方法,最终我成功解决这个问题的方法如下:
最近买了个vpn,所以我可以潇洒的在google中搜索 quaternion to rotation matrix python, 然后 就找到了这个
https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.transform.Rotation.html
我安装了conda,所以首先我使用下面这条指令安装scipy
conda install scipy 安装之后,我在pycharm上编辑代码,运行一下,提示说找不到scipy这个模块,我很纳闷,这是咋回事,我命名安装了呀,
我下意识的感觉到了什么, 我的pycharm链接到的是本地的python3.7,而我是在conda的base的环境下安装的scipy,所以我在python 的setting中更改了,连接的python版本
from scipy.spatial.transform import Rotation as R 就是这个地方,改了之后,pycharm就可以识别scipy了.
下面是我的测试代码,里面还包括了,numpy中的矩阵的合并,设置数据类型等知识点,这些知识正好是今天早晨看morvan python学到的.
https://morvanzhou.github.io/tutorials/data-manipulation/np-pd/2-6-np-concat/ from scipy.spatial.transform import Rotation as R import numpy as np print('test') # use [:, np.newaxis] to transform from row vector to col vector position = np.array([0.6453529828252734, -0.26022684372145516, 1.179122068068349])[:, np.newaxis] share_vector = np.array([0,0,0,1], dtype=float)[np.newaxis, :] print('share_vector:\n', share_vector) print('position:\n',position) r = R.from_quat([-0.716556549511624,-0.6971278819736084, -0.010016582945017661, 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/140a3cd2a661479e7847f38c36e31d39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82cb09485f30120209f8d39fa30443fe/" rel="bookmark">
			78. Subsets（子集）三种解法（C&#43;&#43; &amp; 注释）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		78. Subsets（子集） 1. 题目描述2. 递归（Recursion）2.1 解题思路2.2 实例代码 3. 迭代（Iteration）3.1 解题思路3.2 实例代码 4. 位操作（Bit Manipulation）4.1 解题思路4.2 实例代码 5. 参考资料 1. 题目描述 给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。
说明：解集不能包含重复的子集。
示例:
输入: nums = [1,2,3]
输出:
[
[3],
[1],
[2],
[1,2,3],
[1,3],
[2,3],
[1,2],
[]
]
题目链接：中文题目；英文题目
2. 递归（Recursion） 2.1 解题思路 如果做过77. Combinations（组合），那么递归思路是一样的，只是上一题是找长度为k的组合，这题是列举全部长度情况：0 ~ n。所以我们可以重复使用上题的代码，只需要在最外层递归套一层循环即可。下面两张图解释了递归的思路，大家可以结合上题的递归思路讲解来加深理解：
注：原图来自参考资料所列举的网页；
2.2 实例代码 class Solution { vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; temp; void CombineRecursionMethod(vector&lt;int&gt;&amp; nums, int idx, int k) { if (temp.size() == k) { ans.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82cb09485f30120209f8d39fa30443fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cefab329ec530dfb12f00d4bb4f54079/" rel="bookmark">
			高性能秒级定时器实现源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、本文展示秒级定时器的源码，源码是封装成C++类，然后再次封装成API函数的方式。
用户开发手册地址：https://blog.csdn.net/freeland008/article/details/107508749
2、TimerVM.h和TimerVM.cpp是用c++类的方式实现了秒级时钟的封装，TimerMng.h、TimerMng.cpp实现了二次封装，更方便开发人员直接使用。
3、总体实现思路是使用双时间轮数组交换的方式。
4、TimerVM.h
#ifndef TIMERVM_H #define TIMERVM_H #include &lt;time.h&gt; typedef void* HANDLE; typedef struct _TIMERITEM {	unsigned int dwTimes;	unsigned int dwTimeOut; time_t dtExpire; void* fp; void* pPara;	void* pPosArray; _TIMERITEM* pPrev; _TIMERITEM* pNext; }TIMERITEM; typedef TIMERITEM* LPTIMERITEM; typedef struct _TIMERARRAY { time_t dtStart; HANDLE* hArray; _TIMERARRAY() { dtStart = 0; hArray = NULL; } }TIMERARRAY; typedef TIMERARRAY* LPTIMERARRAY; class CTimerMng { private: TIMERARRAY m_pTimerArrayA; TIMERARRAY m_pTimerArrayB; time_t m_dtLastCheck; int m_nArraySize; public: LPTIMERARRAY m_pArrayOld; LPTIMERARRAY m_pArrayNew; private: size_t m_nCount;	int m_nTimerOutCount; int m_nSetTimerCount; int m_nResetCycleTimerCount; int m_nResetOverTimerCount; public:	LPTIMERITEM m_pResetList; LPTIMERITEM m_pOverList; public: CTimerMng(); ~CTimerMng(); public: int Init(int nArraySize, time_t dtNow); int Destroy(); LPTIMERITEM SetTimer(time_t dtNow, unsigned int dwTimeOut, unsigned int dwTimes, void* fp, void* pPara);	void ResetTimerCycle(LPTIMERITEM pItem);	void ResetTimerOver(LPTIMERITEM pItem);	void KillTimer(LPTIMERITEM pItem); void CheckTimeOut(time_t dtNow); void OnProcTimeOut(LPTIMERITEM pItem, time_t dtNow);	size_t GetCount(){return m_nCount;}; }; #endif 5、TimerVM.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cefab329ec530dfb12f00d4bb4f54079/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab64fea29fdf9def1cafd7932127ac93/" rel="bookmark">
			高性能秒级定时器SDK编程参考手册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 本文档适用于C/C++语言开发人员，用于在开发过程中进行参考，文档详细讲述秒级定时器相关函数的用法以及源码示例。
源码地址：https://blog.csdn.net/freeland008/article/details/107508749
秒级定时器技术特点 定时器的实现采用双数组和双向链表数据结构。 2、支持超大规模数量定时器
支持设置的定时器的数量没有限制，主要受主机物理内存限制。
3、效率高
设置和删除定时器的操作个定时器的数量操作，只涉及到数组元素地址定位， 和双向数组头部插入操作。
4、支持周期性时钟
1）支持一次性时钟
2) 支持指定周期时钟
3) 支持无限周期时钟
5、指定时刻时钟。
例如: 20200102030405，代表: 2020年1月2日3点4份5秒
6、设置时钟时可同时设置回调函数指针和输入参数。
定时时钟应用场景 精度精确到秒的应用场景。例如针对网络服务器程序：
1、连接远程服务器超时。
2、登录服务器超时。
3、周期性发送握手请求。
4、等待握手应答超时。
5、等待ACK超时。
6、其他周期性执行的任务情况。
7、定时执行任务的场景。
定时器管理器功能函数 TVSysCreate() 1、功能说明
此函数用来生成一个定时器管理器，执行成功后返回定时器管理器句柄，之后的操作都引用此句柄。
2、函数原型
HANDLE TVSysCreate(int nArraySize, time_t dtNow);
3、参数说明
int nArraySize 输入参数, 时间轮数组的大小，必须大于1, 默认填写: 3600。
time_t dtNow 输入参数, 当前时间戳。
4、返回值
执行成功时返回非NULL的句柄。
5、相关函数
TVSysDestroy()
示例1：
功能：生成一个定时器管理器。
#include "TimerMng.h"
int main(int argc, char* argv[])
{
time_t dtNow;
time(&amp;dtNow);
HANDLE hTimerVM;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab64fea29fdf9def1cafd7932127ac93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c069d1f6f8f10d76759a6d74d378a4a/" rel="bookmark">
			家用带宽二级路由openwrt设置ipv6
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		拓扑结构，中国移动家庭智能网关GS3101 + OpenWrt GCC 5.3.0 12009
GS3101 为一级主路由，是光猫直接拨号，通过GS3101到一个lan口接到openwrt的wan口。其中分配给gs3101网关的ipv6前缀是60位,二级路由获取到该前缀后，给二级路由下属设备分配的前缀是64位
成功的配置需要确保你的二级路由器获得的ipv6的前缀是64而不是128。
gs3101网关设置如下：
默认登录用户名CMCCAdmin，密码aDm8H%MdA
如果自动分配不成功，则自己分配，注意前缀必须和家庭网关状态里面的前缀相同，前缀长度大于60即可：
我openwrt用ssh连上后用vim设置如下：
开头注释那行为路径
# /etc/config/firewall config defaults option syn_flood	1 option input	ACCEPT option output	ACCEPT option forward	ACCEPT # Uncomment this line to disable ipv6 rules #	option disable_ipv6	1 config zone option name	lan list network	'lan' option input	ACCEPT option output	ACCEPT option forward	ACCEPT config zone option name	wan list network	'wan' list network	'wan6' option input	ACCEPT option output	ACCEPT option forward	ACCEPT option masq	1 option mtu_fix	1 config forwarding option src	lan option dest	wan config forwarding option src	wan option dest	lan # We need to accept udp packets on port 68, # see https://dev.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c069d1f6f8f10d76759a6d74d378a4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d0d0b794f99fa04ff000dd56396a5e9/" rel="bookmark">
			python-网红题2018刑侦科推理测试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		刑侦科推理测试题，终于用python敲出来了，附答案 题目解题思路完整代码 题目 图片:
网红题 吓退了一大批原本还对刑侦专业跃跃欲试的各路英雄好汉。
解题思路 生成数组，ABCD替换为1234（本次比较暴力，未做优化）分别将数组arr带入题目1-10中，如真则进入下一题
题目1：
题目2：arr[1]选项对应值=arr[4]
题目3：arr[2]选项对应值与其他三项不同，其他三项不一定相同
题目4：arr[3]选项对应值是否一致
题目5：arr[4]选项对应值是否一致
题目6：arr[5]选项对应值是否与arr[7]一致
题目7：计算次数最少的值，判断是否与arr[6]选项内的值次数一致
题目8：判断第一题选项与arr[7]选项对应值绝对值是否大于等于2
题目9：互为真假，arr[0]==arr[5]的布尔值不等于arr[4]==arr[8]选项对应值不一致
题目10：分别计算1234出现的次数，得出差值，判断与arr[9]对应值一致
3.题目1-10全部通过，则输出结果，最后得出的结果为
[2, 3, 1, 3, 1, 3, 4, 1, 2, 1]
1=B 2=C 3=A 4=C 5=A 6=C 7=D 8=A 9=B 10=A 完整代码 import math def check1(item): return True def check2(item): curIndex=1 if item[curIndex]==1: if item[4] == 3: return True elif item[curIndex]==2: if item[4] == 4: return True elif item[curIndex]==3: if item[4] == 1: return True elif item[curIndex]==4: if item[4] == 2: return True return False def check3(item): curIndex=2 if item[curIndex]==1: if (item[2]!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d0d0b794f99fa04ff000dd56396a5e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d13e3c26f78f2c9cc51a6b8cded046e/" rel="bookmark">
			Anaconda Prompt打开出现拒绝访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Anaconda Prompt打开出现拒绝访问
请问如何解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e5b2c3a06af779d4b8284035368c4d0/" rel="bookmark">
			Unity基础系列（五）——每秒帧率（测试性能）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击蓝字关注我们吧！
目录
1 构造原子核
2 使用Profiler
3 测量FPS
4 帧平均每秒
5 给文本上色
本章重点：
1、用物理学来创造一个不断成长的原子核。
2、使用分析器排查性能。
3、统计并显示帧速率。
4、阻止创建临时字符串。
5、通过平均多个帧来稳定帧速率。
6、对不同帧率进行分色显示。
本教程将创建一个简单的测试场景，然后测试其性能。先用profiler排查，然后创建我们自己的帧率计数器。
本教程要求对Unity脚本有基本的理解。兼容Unity5.0.1及以上版本。如果你还不熟悉Unity脚本操作，可以先看一看前面几个章节。
（聚集球体，知道你的帧率开始承受不住）
1 构造原子核
要测试性能，就需要搭建一个测试场景。一个理想的测试场景应该涵盖高性能和低性能的情况。所以这里通过将越来越多的核子融合在一起来创造一个原子核。随着核变的越来越大，性能逐渐恶化。
核子只是简单的球体，它们会被吸引到场景的中心，在那里它们会聚集在一起形成一个球。这当然不是原子的正确表示，但这不是重点。
我们可以用一个默认的球和一个自定义的Nucleon 组件来模拟一个核。该组件要要同时添加刚体组件，然后简单地将其拉向原点。拉力的强度由可配置的吸引力和距中心的距离决定。
缺少一些访问修饰符？
是的，字段和方法声明中可以省略private 修饰符，因为在默认情况下它们就是私有的。
用球体制造两个核子预制体，一个用于质子，另一个用于中子。分别给不同的材质球，让它们看起来不同。其实性能演示只需要一种核子类型就够了，但这样感觉就没意思了。
什么是预制体？
预制体是一个不存在于场景中且未被激活的Unity对象或对象层次结构。你可以使用它作为模板，创建它的克隆并将它们添加到场景中。要创建一个对象，可以像往常一样在场景中构造一个对象，然后将其拖到项目窗口中。场景对象将成为一个预置实例，如果你不再需要它，可以直接删除。
（核子预制体）
为了产生这些核子，还需要制造另一个成分-- NucleonSpawner 。它需要知道不同副本之间的时间间隔，离中心有多远，要产生什么。
创建一个空的游戏对象，附加一个NucleonSpawner组件，并根据你的需要配置它。
（核子生成器）
为了定期生成，就需要跟踪从上次生成的时间。可以使用一个简单的FixedUpdate方法来完成这个任务。
为什么使用 FixedUpdate 而不是 Update?
使用FixedUpdate会让生成与帧速率无关。如果在子程序之间配置的时间比帧时间短，使用Update会导致产生延迟。因为这个场景的重点是阻碍帧率的，所以这必然会发生。
可以使用一个while循环取代if检查来加速追赶漏产生的核子，但是当timeSinceLastSpawn 意外的被设置为零时，这将导致无限生产循环。将生产限制在每一个固定的时间步骤是一个理智的限制。
实际产生由三个步骤组成。选择一个随机的预制件，实例化它，并在期望的距离上给它一个随机的位置。
（通过轰炸建立一个核）
播放这个场景应该会导致球体向中间聚集。它们会挣脱一段时间，直到相互碰撞，形成一个球。这个球将继续增长，物理计算将变得更加复杂，并且在某一时刻你会注意到帧率的下降。
如果你的机器硬件好，需要很长时间才能看到性能恶化的话，则可以增加产生的速率。通过增加时间尺度的配置来加快时间是比较有效的。可以通过Edit Project Settings Time 找到。当然也可以减 Fixed Timestep ，这也会导致每秒更多的物理计算。
（Unity的时间设置）
为什么在低时间尺度下运动不流畅的？
当time scale被设置为0.1这样的低值时，时间会移动得非常慢。由于固定的时间步长是恒定的，这意味着物理系统更新的频率会降低。因此，物理物体将保持静止，直到一个固定的更新发生，也就是每隔几个帧就更新一次。
随着时间的增加，你可以通过减少固定的time scale来对抗这种现象。或者，可以更改刚体部件的插值模式，以便它们在物理步骤之间进行插值，从而隐藏较低的更新频率。
2 使用Profiler
现在已经有了一个场景，并且最终能降低任何机器的帧率，现在是衡量实际性能的时候了。你能做的最快的事情就是启用游戏视图的统计数据。
（游戏视图统计显示）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e5b2c3a06af779d4b8284035368c4d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f34d97f98085cb53c6e2c15c26179949/" rel="bookmark">
			Lucene、Solr和Elasticsearch三者的区别与联系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、结构化数据与非结构化数据
二、全文检索
三、Lucene
四、Lucene、Solr、Elasticsearch三者的关系
Solr
Elasticsearch
Solr的优缺点
Elasticsearch的优缺点
Elasticsearch 与 Solr 的比较
一、结构化数据与非结构化数据 结构化数据：指具有固定格式或有限长度的数据，如数据库，元数据等。
非结构化数据：指不定长或无固定格式的数据，如邮件，word文档等。
结构化数据的搜索
根据上面所述的内容，所以两者在搜索上也是同样存在着一定的区别 （内容来自wiki）：
对于结构化的数据：对数据库的搜索，用SQL语句。再如对元数据的搜索，如利用windows搜索对文件名，类型，修改时间进行搜索等。
对于非结构化的数据：
顺序扫描法(Serial Scanning)：所谓顺序扫描，比如要找内容包含某一个字符串的文件，就是一个文档一个文档的看，对于每一个文档，从头看到尾，如果此文档包含此字符串，则此文档为我们要找的文件，接着看下一个文件，直到扫描完所有的文件。如利用windows的搜索也可以搜索文件内容，只是相当的慢。全文检索(Full-text Search)：将非结构化数据中的一部分信息提取出来，重新组织，使其变得有一定结构，然后对此有一定结构的数据进行搜索，从而达到搜索相对较快的目的。这部分从非结构化数据中提取出的然后重新组织的信息，我们称之索引。例如：字典。字典的拼音表和部首检字表就相当于字典的索引，对每一个字的解释是非结构化的，如果字典没有音节表和部首检字表，在茫茫辞海中找一个字只能顺序扫描。然而字的某些信息可以提取出来进行结构化处理，比如读音，就比较结构化，分声母和韵母，分别只有几种可以一一列举，于是将读音拿出来按一定的顺序排列，每一项读音都指向此字的详细解释的页数。我们搜索时按结构化的拼音搜到读音，然后按其指向的页数，便可找到我们的非结构化数据——也即对字的解释。这种先建立索引，再对索引进行搜索的过程就叫全文检索(Full-text Search)。 二、全文检索 1、全文检索是一种将文件中所有文本与检索项匹配的文字资料检索方法。全文检索首先将要查询的目标文档中的词提取出来，组成索引，通过查询索引达到搜索目标文档的目的。这种先建立索引，再对索引进行搜索的过程就叫全文检索（Full-text Search）。
2、全文检索就是把文本中的内容拆分成若干个关键词，然后根据关键词创建索引。查询时，根据关键词查询索引，最终找到包含关键词的文章。整个过程类似于查字典的过程。（重点在于如何可以正确高效的拆分关键词，然后根据关键词创建索引）
3、全文检索的应用领域：
搜索引擎：例如百度、谷歌、搜狗。站内搜索：例如论坛搜索，天涯论坛搜索、微博搜索。电商搜索：搜索的是商品信息。例如淘宝、京东。
三、Lucene Lucene是apache下的一个子项目，是一个开放源代码的全文检索引擎工具包，但它不是一个完整的全文检索引擎，而是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎，部分文本分析引擎。官网地址：https://lucene.apache.org/
Lucene实现索引和全文搜索流程
图中的蓝色表示索引过程，对要搜索的原始内容进行索引构建一个索引库，索引过程包括：
确定原始文档内容即要搜索的内容--》获得文档--》创建文档对象--》分析文档--》索引文档
1）创建文档对象。为每个文件对应的创建一个Document对象。把文件的属性都保存到document对象中。需要为每个属性创建一个field（在lucene中叫做域），把field添加到文档对象中。每个document都有一个唯一的编号。
2）分析文档。针对document中的域进行分析，例如分析文件名、文件内容两个域。先把文件内容域中的字符串根据空格进行分词，把单词进行统一转换成小写。把没有意义的单词叫做停用词。把停用词从词汇列表中去掉。去掉标点符号。最终得到一个关键词列表。每个关键词叫做一个Term。Term中包含关键词及其所在的域，不同的域中相当的单词是不同的term。
3）创建索引。索引，即为了提高查询速度的一种数据结构。在关键词列表上创建一个索引；把索引和文档对象写入索引库，并记录关键词和文档对象的对应关系。
每个关键词对应一链表，链表中的每个元素都是document对象的id。对所有文档分析得出的语汇单元进行索引，索引的目的是为了搜索，最终要实现只搜索被索引的语汇单元从而找到Document（文档）。
注意：创建索引是对语汇单元索引，通过词语找文档，这种索引的结构叫倒排索引结构。传统方法是根据文件找到该文件的内容，在文件内容中匹配搜索关键字，这种方法是顺序扫描方法，数据量大、搜索慢。倒排索引结构也叫反向索引结构，包括索引和文档两部分，索引即词汇表，它的规模较小，而文档集合较大。
4）查询索引
图中的黄色表示搜索过程，从索引库中搜索内容，搜索过程包括：
用户通过搜索界面--》创建查询--》执行搜索，从索引库搜索--》渲染搜索结果
搜索就是用户输入关键字，从索引（index）中进行搜索的过程。根据关键字搜索索引，根据索引找到对应的文档，从而找到要搜索的内容（这里指磁盘上的文件）。
四、Lucene、Solr、Elasticsearch三者的关系 Solr Solr是一个高性能，采用Java5开发，基于Lucene的全文搜索服务器。同时对其进行了扩展，提供了比Lucene更为丰富的查询语言，同时实现了可配置、可扩展并对查询性能进行了优化，并且提供了一个完善的功能管理界面，是一款非常优秀的全文搜索引擎。官网地址：http://lucene.apache.org/solr/
Elasticsearch Elasticsearch跟Solr一样，也是一个基于Lucene的全文搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。官网地址：https://www.elastic.co/products/elasticsearch
Solr的优缺点 优点：
Solr有一个更大、更成熟的用户、开发和贡献者社区。支持添加多种格式的索引，如：HTML、PDF、微软 Office 系列软件格式以及 JSON、XML、CSV 等纯文本格式。Solr比较成熟、稳定。不考虑建索引的同时进行搜索，速度更快。 缺点：建立索引时，搜索效率下降，实时索引搜索效率不高。
Elasticsearch的优缺点 优点：
Elasticsearch是分布式的。不需要其他组件，分发是实时的，被叫做”Push replication”。Elasticsearch 完全支持 Apache Lucene 的接近实时的搜索。处理多租户（multitenancy）不需要特殊配置，而Solr则需要更多的高级设置。Elasticsearch 采用 Gateway 的概念，使得完备份更加简单。各节点组成对等的网络结构，某些节点出现故障时会自动分配其他节点代替其进行工作。 缺点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f34d97f98085cb53c6e2c15c26179949/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfc615b341a14c88b6397b78bcf69681/" rel="bookmark">
			如何优雅的利用C#做协议解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近喜欢上了做协议解析，使用Java与.NET做了很多的厂家的产品的协议网关。从部标系列到第三方私有协议，通过协议解析过程中了解每款产品的特色与将来可能的应用场景。
下面我以一款第三方私有协议为例，利用C#语言进行优雅的做协议解析。
原始数据：2475201509260111002313101503464722331560113555309F00000000002D0500CB206800F064109326381A03
序号
名称
值(HEX)
长度(Byte)
说明
1
协议头
24
1
固定为0x24,即ASCII的”$”符.
2
终端ID号
7520150926
5
终端的ID号,固定为5字节长度. 75表示JT701.
3
协议版本号
01
1
01：表示协议版本号
4
终端类型号
1
0.5
1：常规可充电JT701.
5
数据类型号
1
0.5
1表明常规二进制定位数据，2表示报警数据，3表示盲区常规二进制定位数据
6
数据长度
0023
2
16数据内容长度,表明后面的数据一共有35个字节长.
17数据内容长度,表明后面的数据一共有39个字节长.
7
日期
131015
3
日月年表示.此处为2015年10月13号.
8
时间
034647
3
时分秒表示,为国际标准时.此处表示为03:46:47.
9
纬度
22331560
4
22331560,按照DDMM.MMMM格式定义,此纬度值为: 2233. 1560.
10
经度
113555309
4.5
113555309,按照DDDMM.MMMM格式定义,此经度值为: 11355. 5309.
11
位指示
F
0.5
F = 1111,GPS定位,西经,北纬.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfc615b341a14c88b6397b78bcf69681/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc4ff754e0106b6201de1c7cda93f20e/" rel="bookmark">
			HTTP协与Apache服务的搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先看一张图，在IOS七层模型与TCP/IP四层模型中，HTTP协议所处的位置一目了然，我们来从头开始了解HTTP协议的工作原理。
一个网站有以下几个指标来衡量：
IP(独立IP):即Internet Protocol,指独立IP数。一天内来自 相同客户机IP地址只计算一次，记录远程客户机IP地址的计 算机访问网站的次数，是衡量网站流量的重要指标PV(访问量): 即Page View, 页面浏览量或点击量，用户每 次刷新即被计算一次，PV反映的是浏览某网站的页面数，PV 与来访者的数量成正比，PV并不是页面的来访者数量，而是 网站被访问的页面数量UV(独立访客):即Unique Visitor,访问网站的一台电脑为一 个访客。一天内相同的客户端只被计算一次。可以理解成访问 某网站的电脑的数量。网站判断来访电脑的身份是通过来访电 脑的cookies实现的。如果更换了IP后但不清除cookies，再访 问相同网站，该网站的统计中UV数是不变的
网站统计:http://www.alexa.cn/rank. 一次完整的http请求处理过程 一次完整的http请求处理过程有一下几步：
1、建立连接:接收或拒绝连接请求
2、接收请求:接收客户端请求报文中对某资源的一次请求的过程
Web访问响应模型(Web I/O)
单进程I/O模型:启动一个进程处理用户请求，而且一次只处理一个 ，多个请求被串行响应多进程I/O模型:并行启动多个进程,每个进程响应一个连接请求 复用I/O结构:启动一个进程，同时响应N个连接请求
实现方法:多线程模型和事件驱动 多线程模型:一个进程生成N个线程，每线程响应一个连接请求事件驱动:一个进程处理N个请求 复用的多进程I/O模型:启动M个进程，每个进程响应N个连接请求 ，同时接收M*N个请求 3、处理请求:服务器对请求报文进行解析，并获取请求的资 源及请求方法等相关信息，根据方法，资源，首部和可选的主体部分对请求进行处理
元数据:请求报文首部
&lt;method&gt; &lt;URL&gt; &lt;VERSION&gt; HEADERS
格式 name:value 示例:
Host: www.yangyang.host 请求的主机名称
Server: Apache/2.4.7
HTTP常用请求方式（Method）:
GET、POST、HEAD、PUT、DELETE、TRACE、OPTIONS
**4、访问资源:
服务器获取请求报文中请求的资源web服务器，即存放了web资源的服务器，负责向请求者提供对方请求的静态资源，或动态运行后生成的资源
资源放置于本地文件系统特定的路径:DocRoot
DocRoot
/var/www/html /var/www/html/images/logo.jpg
http://www.magedu.com/images/logo.jpg
web服务器资源路径映射方式:
(a) docroot(b) alias(c) 虚拟主机docroot(d) 用户家目录docroot 5、构建响应报文:
一旦Web服务器识别除了资源，就执行请求方法中描述的 动作，并返回响应报文。响应报文中 包含有响应状态码、响应 首部，如果生成了响应主体的话，还包括响应主体
1)响应实体:如果事务处理产生了响应主体，就将内容放在 响应报文中回送过去。
响应报文中通常包括: 描述了响应主体MIME类型的Content-Type首部描述了响应主体长度的Content-Length实际报文的主体内容 2)URL重定向:web服务构建的响应并非客户端请求的资源 ，而是资源另外一个访问路径 永久重定向:http://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc4ff754e0106b6201de1c7cda93f20e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/862dc0dcefcdcf6bdb4405db2a6356fe/" rel="bookmark">
			只要30行代码！7步教会你Python爬取网页抖音热门视频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
抖音短视频相信大家都听过，也不陌生对吧！可以看到海量的短视频，涵盖了各大行业。个人觉得抖音有毒，刷着刷着根本停不下来，一看时间就是凌晨3、4点。今天带大家爬取抖音网页版的视频数据！一睹为快吧
本篇文章内容： 1、系统分析网页性质
2、正则提取数据（难点）
3、海量音频数据保存
环境介绍： python 3.6
pycharm
requests
re
爬虫的一般思路 1、分析目标网页，确定爬取的url路径，headers参数
2、发送请求 -- requests 模拟浏览器发送请求，获取响应数据
3、解析数据 -- 正则表达式
4、保存数据 -- 保存在目标文件夹中
步骤： 1、导入工具
base_url = 'http://douyin.bm8.com.cn/d_1.html' headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36'} 2、分析目标网页，确定爬取的url路径，headers参数
base_url = 'http://douyin.bm8.com.cn/d_1.html' headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36'} 3、发送请求 -- requests 模拟浏览器发送请求，获取响应数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/862dc0dcefcdcf6bdb4405db2a6356fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84c47458f954e05c4bdd144d0199758d/" rel="bookmark">
			多任务自适应损失权重
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多任务自适应损失权重 在训练多任务的时候，当不同任务的数据量不平衡、各任务难易程度不同等等情况下，会导致不同任务的损失差异较大，
导致：有些任务学的过快，有些任务学的过慢；简单的任务都已经过拟合了，困难的任务才开始有效果等等结果。
这时候，我们有必要干涉一下不同任务的优化力度，如：给不同任务设置超参，通过超参平衡不同任务的。
eg:
先给困难任务分配一个较大权重，简单任务分配一个较小权重，已使困难样本优化的更快，当困难任务和简单任务差不多平衡后再把两个的权重调整到平衡。
但这样有一个问题就是来回修改超参，繁琐且不好把持。所以就可以考虑设置一些规则来让模型自己动态调整一些超参。
这里以4个任务调整损失权重为例：
4个任务的损失分别为：
losses = torch.tensor([0.8, 0.7, 1.3, 0.9]) 第三个任务损失较大，给他分配个较大的权重，使得损失更大，优化力度更强
def get_losses_weights(losses:[list, numpy.ndarray, torch.Tensor]): if type(losses) != torch.Tensor: losses = torch.tensor(losses) weights = torch.div(losses, torch.sum(losses)) * losses.shape[0] return weights losses = torch.tensor([0.8, 0.7, 1.3, 0.9])	# old_loss = torch.sum(losses) = 3.7 loss_w = get_losses_weights(losses)	# loss_w: [0.8649, 0.7568, 1.4054, 0.9730] new_losses = losses * loss_w	# new_losses: [0.6919, 0.5297, 1.8270, 0.8757]) loss = torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84c47458f954e05c4bdd144d0199758d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea55f2f49ee3a5a5c8587f2e5f1782ff/" rel="bookmark">
			Mac启动盘已满？这15个释放空间技巧来解救你的Mac！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你是否经常收到这样的警示——“您的启动磁盘几乎已满”？当你的mac使用一段时间之后，磁盘上的可用空间不再足够时，将显示这条警示消息，表明您的启动磁盘已快用完。这通常是由于Mac的硬盘驱动器上的文件太多而导致的可用空间降低到危险的程度。要解决此问题，您需要释放一些磁盘空间！
为大家整理了15个手动清洁启动盘释放Mac空间的小技巧。当然，如果您没有时间手动清理启动磁盘，建议您使用MacCleaner Pro分析磁盘空间使用情况并释放磁盘空间。当涉及清洁系统磁盘并防止出现“ Startup Disk Full”消息时，这是最快的解决方案。使用MacCleaner Pro工具来识别最大的文件，并删除垃圾文件，不需要的下载，重复的文件和文件夹以及未使用的应用程序。
MacCleaner PRO for Mac(综合系统清理优化工具)
立即下载
MacCleaner PRO for Mac(综合系统清理优化工具)
还在为不知道用哪款Mac系统清理优化工具好吗？不用纠结了，macz推荐这款Mac Cleaner PRO for Mac，它是一款Mac上的系统优化维护软件包。
2020-06-2769.93 MB英文软件
“启动磁盘已满”如何影响您的Mac？
启动磁盘上的可用空间不足会导致macOS系统的性能不稳定和缓慢。它还可能阻止应用程序启动或正常运行，包括突然崩溃或仅停止工作。
如果Mac上启动盘已满，该怎么办
通常，您需要清理启动盘以恢复一些空间。您可以手动删除某些文件，也可以使用MacCleaner Pro快速轻松地执行此任务。
另外，您可以将一些大文件上传到云或将其卸载到备份磁盘，但是，这种方法需要您拥有额外的存储。为了使系统正常运行，您需要通过删除不需要的文件来释放10到30 GB的空间。
如何在Mac上检查启动盘
按照以下步骤查看哪种文件占用了启动盘空间。
1、在苹果菜单上单击关于此Mac 菜单
2、单击存储选项卡
3、查看存储空间使用情况，查看哪些文件占用了空间。
启动盘上存储了七类常规数据。条形越大，这些类型的文件（照片，应用程序，电影，音频，备份，文档和其他文件）占用的空间越大。
现在，您知道Mac启动盘上正在占用哪些类型的文件。通常，电影，图片或备份占用最多的空间。但是，经常发生的事情是，占用空间最大的是“其他”文件，包括缓存，日志，cookie，档案，磁盘映像，插件，扩展名等。
您可以手动删除不需要的文件，也可以使用特殊的软件工具来快速，轻松地清理磁盘。
如何清理Mac启动盘
一、检查您的垃圾
听起来很基本，但是我们经常删除文件，却忘了清空垃圾箱。“废纸in”中的文件仍会占用您的磁盘空间，因此建议您每周至少清空一次“废纸folder”文件夹。
要从“废纸folder”文件夹中永久删除文件，请右键单击停靠面板中的“废纸rash”，然后选择“ 清空垃圾箱 ” 。完成此任务的另一种方法是打开垃圾箱，然后单击右上角的“ 清空”按钮。
二、删除下载
您从Web浏览器，Messenger，Torrent和邮件中下载了多少次文件？当您从Internet下载文件时，默认情况下，它们保存在Downloads文件夹中，可以在以下位置轻松找到该文件夹：
/ Macintosh HD /用户/当前用户/下载
根据统计，平均用户每周在“下载”文件夹中累积0.5 GB。
通常，“下载”文件夹中的所有文件都是无序的，可能会占用几GB的可用空间。尽管您可能很少需要检索文件，例如安装文件（磁盘映像），但是不需要下载中超过一半的文件，应将其删除。
按大小，类型或日期对文件列表进行排序将有助于您快速找出并删除哪些不需要的文件。
三、清除缓存
缓存文件是由应用程序，浏览器和许多其他程序创建的临时数据文件，可帮助Mac更快地运行。请注意，当您删除缓存文件时，下次运行该应用程序时将重新创建它们。即使这样，还是要不时清除缓存。您可能不再使用的应用程序以及剩余的应用程序仍保留在Cache文件夹中，并占用了数十GB的磁盘内存。
缓存文件存储在“库”文件夹中，您可以在以下位置找到它们：
/库/缓存
〜/库/缓存
在/ Library / Caches中，您将找到系统创建的临时文件。通常，这些文件不会占用太多空间。但是，在〜/ Library / Caches文件夹中，您将看到大量垃圾文件，这些文件是在运行应用程序时创建的。结果，此文件夹的大小可能会随时间大幅增加。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea55f2f49ee3a5a5c8587f2e5f1782ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/487026228992d74778ac5aa421cd5c5b/" rel="bookmark">
			mysql子表查询 （EXISTS）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题 1、假设主表为A，子表为B（他们以A表的唯一id关联） Ａ表 account_idnamegenderage1小明男222小红女223小军男25 B表 book_idaccount_idbook_namepricea1西游记55b1红楼梦55c1哈利波特40d2小王子25e3暴风雨23 2、当我们想要查询两个表的记录的时候，通常都会想到 left join。例：（select * from A left join B where A.account_id = B.account_id） 3、按分页来思考，我们只想要A表的记录，但是需要B表的一些字段作为搜索条件。如果查找到A表只有1条记录，B表有2条符合的记录，这样就会产生两条记录。例：（select * from A left join B where A.account_id = B.account_id where B.price = 55） account_idnamegenderagebook_idaccount_idbook_nameprice1小明男22a1西游记551小明男22b1红楼梦55 解决（EXISTS） select * from A where 1 and exists( select 1 from B where B.account_id = A.account_id and B.price = 55 ) account_idnamegenderage1小明男22 好处：A表搜索到多少条数据就返回多少条，可以方便分页，又可以拿B表作为条件来搜索，同样也可以拿C表一起搜索。exists（）只返回true和false。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c750237490af0eecc9ccba899531390/" rel="bookmark">
			LeeTCode
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.给定一个 Weather 表，编写一个 SQL 查询，来查找与之前（昨天的）日期相比温度更高的所有日期的 Id。
±--------±-----------------±-----------------+
| Id(INT) | RecordDate(DATE) | Temperature(INT) |
±--------±-----------------±-----------------+
| 1 | 2015-01-01 | 10 |
| 2 | 2015-01-02 | 25 |
| 3 | 2015-01-03 | 20 |
| 4 | 2015-01-04 | 30 |
±--------±-----------------±-----------------+
来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/rising-temperature
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
select a.Id from weather as a join weather as b where a.temperature &gt;b.temperature and DATEDIFF(a.RecordDate,b.RecordDate) =1 DATEDIFF函数是求的两个日期之间相差的天数，把一个表当两个表用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aeb031664610ca8a653ef076c5078933/" rel="bookmark">
			vue中使用svg-sprite-loader处理svg图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网上已经有很多文章写了相似的例子，不过自己实践之后还是把过程记录下来，这样知识就是自己的了。
版本：@vue/cli 4.4.1
实现内容：1.vue载入svg 2.能够更改svg样式 3.svg无限旋转
1.使用的loader：svg-sprite-loader、svgo-loader
我们在vue.config.js文件里找到chainWebpack属性，添加如下代码：
chainWebpack: config =&gt; { // ...... config.module .rule('svg') .exclude.add(resolve('src/assets/icons/svg')) .end(); config.module .rule('icons') .test(/\.svg$/) .include.add(resolve('src/assets/icons/svg')) .end() .use('svg-sprite-loader') .loader('svg-sprite-loader') .options({ symbolId: 'icon-[name]', }) .end(); // ....... 2.需要安装的loader：svg-sprite-loader、svgo-loader
npm i svg-sprite-loader svgo-loader -D 3.引入svg图片
我们在src/assets下新建icons文件夹，文件夹里再新建svg文件夹，将svg图片放至svg文件夹里。（具体路径可根据自己习惯配置）
4.统一引入svg图片
在src下新建icons文件夹，新建index.js文件（要注意路径的配置）：
const req = require.context('@/assets/icons/svg/', false, /\.svg$/); const requireAll = requireContext =&gt; requireContext.keys().map(requireContext); requireAll(req); 5.在main.js中引入
import './icons'; 6.在组件中使用
&lt;!-- #icon- 为icon的前缀，XXX为icon名称 --&gt; &lt;svg&gt; &lt;use xlink:href="#icon-XXX"&gt;&lt;/use&gt; &lt;/svg&gt; 这样，我们就能在界面上看到svg图片了。
7.优化
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aeb031664610ca8a653ef076c5078933/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80459d0fa45bb1fb4e86b19acaae8ecf/" rel="bookmark">
			C&#43;&#43;之erro： no matching function for call to
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写自定义目录标题 事情是这样的：
主函数调用时：
Luban luban("Luban",5,100，"red") Luban.h文件：
class Luban:public Hero,public Shooter { public: void show(void); Luban(const string &amp;name,int distance,const string &amp;color,int leg); ~Luban(); private: int leg; Skin skin; }; Luban.c成员初始化列表：
Luban::Luban(const string &amp;name,int distance,const string &amp;color,int leg):Hero(name),Shooter(distance),skin(color) 此时我以为自己写的代码万无一失，但是编译器还是报错了，来看看编译器报了什么错：
erro：no matching function for call to 'Luban::Luban(const char [6], int, int, const char [4])'
Luban luban(“Luban”,5,100,“red”);
编译器竟然说找不到匹配项，我想了又想，明明我已经对这个参数定义了，也初始化了，为什么会这样。
后来我才发现，原来是参数项不匹配。
修改一下：
Luban luban(“Luban”,100,“red”,5)
再次编译：
现在没问题了
原来是调用的顺序和初始化的参数顺序不一致，我想了想，毕竟编译器还是没有那么智能的。
虽然问题比较小白，但是为我的机智点赞，希望路过的大佬们有更好地观点或者更好地方法能指点一下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d5002c4158a622d88c1646dbca3172d/" rel="bookmark">
			【JavaScript】数字与字符串之间的比较、算数运算符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、字符串数字 与 整型数字做比较运算:将字符串数字转化为对应整型数值,再进行数值的比较 ：
例：console.log('1'&gt;2) --1&gt;2-- true
2、字符串数字之间比大小,比较ascll码值
例：console.log('21'&gt;'3') --'21'&gt;'3'--false
3、字符串数字与整型数字做加运算:+号相当于连接符; 将整型数字转为字符串数字,在连成一个新的字符串
例： console.log('3'+2) --'32'
4、字符串数字与整型数字做 减, 乘, 除运算: 将字符串数字转化为对应整型数值,再进行数值的计算
例： console.log('3'-2) console.log('3'*2) console.log('3'/2)--1、6、1.5
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd2c8f042440e09175db20535c112776/" rel="bookmark">
			C语言读bin文件内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言读bin文件内容 一、直接上代码，我这里是读显示器edid的内容，read_bin_file.c
#include&lt;stdio.h&gt; #include&lt;string.h&gt; #include"edid.h" typedef unsigned char u8; typedef unsigned long int u32; /************************************************************************************* 0 1 2 3 4 5 6 7 8 9 a b c d e f 00: 03 50 08 21 01 13 01 00 00 00 00 01 01 00 00 00 10: 01 80 00 00 00 00 00 00 00 00 00 00 00 00 00 00 20: 01 17 00 6f ff 00 00 00 10 00 ff 0f ff 02 19 0f 30: 00 00 19 0b 00 00 02 03 00 00 09 00 00 0c 00 0a 40: 00 0c 00 0c 00 07 00 0a 00 0c 00 00 00 7f 00 03 50: 06 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 60: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 70: 00 cf 03 00 28 00 0c 1c 80 19 00 34 12 00 71 00 80: 10 50 1f ac 00 40 00 20 40 00 00 00 00 00 00 00 90: 55 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 b0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 e0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 f0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 *************************************************************************************/ //TCL monitor unsigned char edid[255]={ 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x50, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x13, 0x01, 0x03, 0x81, 0x52, 0x2e, 0x78, 0x0b, 0xd9, 0xb0, 0xa3, 0x57, 0x49, 0x9c, 0x25, 0x11, 0x49, 0x4b, 0xa9, 0xcf, 0x00, 0x95, 0x00, 0xb3, 0x00, 0x81, 0xc0, 0x81, 0x00, 0x81, 0x40, 0x81, 0x80, 0xa9, 0x40, 0xd1, 0xc0, 0x1b, 0x21, 0x50, 0xa0, 0x51, 0x00, 0x1e, 0x30, 0x48, 0x88, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x1f, 0x00, 0x80, 0x51, 0x00, 0x1e, 0x30, 0x40, 0x80, 0x37, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x54, 0x43, 0x4c, 0x4d, 0x53, 0x36, 0x38, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0x02, 0x02, 0x03, 0x20, 0xf1, 0x4d, 0x05, 0x02, 0x03, 0x04, 0x07, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x1f, 0x23, 0x09, 0x57, 0x07, 0x83, 0x01, 0x00, 0x00, 0x65, 0x03, 0x0c, 0x00, 0x10, 0x00, 0x8c, 0x0a, 0xd0, 0x8a, 0x20, 0xe0, 0x2d, 0x10, 0x10, 0x3e, 0x96, 0x00, 0x65, 0xcc, 0x21, 0x00, 0x00, 0x18, 0x01, 0x1d, 0x00, 0xbc, 0x52, 0xd0, 0x1e, 0x20, 0xb8, 0x28, 0x55, 0x40, 0x32, 0xcc, 0x31, 0x00, 0x00, 0x1e, 0x01, 0x1d, 0x80, 0xd0, 0x72, 0x1c, 0x16, 0x20, 0x10, 0x2c, 0x25, 0x80, 0x32, 0xcc, 0x31, 0x00, 0x00, 0x9e, 0x8c, 0x0a, 0xd0, 0x8a, 0x20, 0xe0, 0x2d, 0x10, 0x10, 0x3e, 0x96, 0x00, 0x32, 0xcc, 0x31, 0x00, 0x00, 0x18, 0x8c, 0x0a, 0xd0, 0x90, 0x20, 0x40, 0x31, 0x20, 0x0c, 0x40, 0x55, 0x00, 0x32, 0xcc, 0x31, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14 }; u32 GetBinSize(char *filename) { u32 siz = 0; FILE *fp = fopen(filename, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd2c8f042440e09175db20535c112776/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/333b6f6f3c0decb562ecca188f70fb2c/" rel="bookmark">
			Requires: libsasl2.so.3()(64bit)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Centos6.5上安装mysql
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c1b7c125dd9bd9c92c4a1c342dfdfe1/" rel="bookmark">
			通用MCU与ASIC的优劣势对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在方案讨论会上，两家方案截然不同。一家采用通用芯片，譬如DSP,ARM9,FPGA等；一家采用专用芯片，譬如复印扫描传真一体化的专用芯片。这两种方案各有优缺点：
采用通用芯片，优点是
芯片容易购买。不仅仅依赖一种型号。任何一家的MCU都可以。NXP的ARM芯片可以，Atmel的也可以，freescale的也行，不限型号。
软件移植性高。只要采用ARM通用体系，则无论是ARM9,ARM10，还是ARM12，均能很方便快捷的移植。
有利于升级。通用MCU的发展一直很快，随着MCU技术和数字信号处理技术的发展，运行处理速度会越来越快。
采用linux系统，有着良好的扩展性。linux是成熟的操作系统，且全世界有成千上万的人去维护更新它，对新技术的支持十分迅速。例如，USB3.0,Wifi,图像图形处理等，均能得到社区支持。
缺点是：采用通用芯片，软件复杂度高，开发周期长。而且可能由于软件的缘故，在某些性能上不如专用芯片。
而采用专用芯片，优点是
软件开发容易。专用芯片所有底层均由芯片商实现，所以只要应用即可，软件复杂度不高。
性能优异。专用芯片，其内部采用单一任务，且很多由硬件实现，故性能较优异。
缺点：
不易购买。由于使用专用芯片的不是很多。所以，量产不是很多，不易购买。
不易扩展。因为专用芯片的功能均做死，所以，今后如增加功能，将无法得到满足。
受制于人。因为专用芯片的局限性，很容易出现断货情况，对部队的长期使用维护是个巨大的问题。
软件不能移植。软件只能针对某种型号的芯片，对其他芯片无法适用。所以一旦该芯片不再提供，则软件只能针对替代型号重新开发设计。
以上陈列了通用芯片和专用芯片的优缺点。对部队这一行业来说，要求长期维护，且针对不同的战况，需要对功能进行更改，这点跟民用机完全不同。专用芯片的局限性相信随着时间的推移，会慢慢呈现出来。另外，如采用通用芯片，供货渠道多种多样，退一万步来讲，即使咱国家在战争期间被全封锁，也可以用国产MCU芯片来代替。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee63ee5b6873753168e674bcda6afe86/" rel="bookmark">
			Spring Cloud Stream：消费失败后的处理策略（一）：自动重试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，介绍一下Spring Cloud Stream中默认就已经配置了的一个异常解决方案：重试！
应用场景 依然要明确一点，任何解决方案都要结合具体的业务实现来确定，不要有了锤子看什么问题都是钉子。那么重试可以解决什么问题呢？由于重试的基础逻辑并不会改变，所以通常重试只能解决因环境不稳定等外在因素导致的失败情况，比如：当我们接收到某个消息之后，需要调用一个外部的Web Service做一些事情，这个时候如果与外部系统的网络出现了抖动，导致调用失败而抛出异常。这个时候，通过重试消息消费的具体逻辑，可能在下一次调用的时候，就能完成整合业务动作，从而解决刚才所述的问题。
动手试试 先通过一个小例子来看看Spring Cloud Stream默认的重试机制是如何运作的。之前在如何消费自己生产的消息一文中的例子，我们可以继续沿用，或者也可以精简一些，都写到一个主类中，比如下面这样：
@EnableBinding(TestApplication.TestTopic.class) @SpringBootApplication public class TestApplication { public static void main(String[] args) { SpringApplication.run(TestApplication.class, args); } @RestController static class TestController { @Autowired private TestTopic testTopic; /** * 消息生产接口 * @param message * @return */ @GetMapping("/sendMessage") public String messageWithMQ(@RequestParam String message) { testTopic.output().send(MessageBuilder.withPayload(message).build()); return "ok"; } } /** * 消息消费逻辑 */ @Slf4j @Component static class TestListener { @StreamListener(TestTopic.INPUT) public void receive(String payload) { log.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee63ee5b6873753168e674bcda6afe86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7afe005e8a3c5bd72453e9e07bda5f64/" rel="bookmark">
			【算法1-1】模拟与高精度   扫雷
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述
扫雷游戏是一款十分经典的单机小游戏。在nn行mm列的雷区中有一些格子含有地雷（称之为地雷格），其他格子不含地雷（称之为非地雷格）。玩家翻开一个非地雷格时，该格将会出现一个数字——提示周围格子中有多少个是地雷格。游戏的目标是在不翻出任何地雷格的条件下，找出所有的非地雷格。
现在给出nn行mm列的雷区中的地雷分布，要求计算出每个非地雷格周围的地雷格数。
注：一个格子的周围格子包括其上、下、左、右、左上、右上、左下、右下八个方向上与之直接相邻的格子。
输入格式
第一行是用一个空格隔开的两个整数nn和mm，分别表示雷区的行数和列数。
接下来nn行，每行mm个字符，描述了雷区中的地雷分布情况。字符’*’表示相应格子是地雷格，字符’?’表示相应格子是非地雷格。相邻字符之间无分隔符。
输出格式
输出文件包含nn行，每行mm个字符，描述整个雷区。用’*’表示地雷格，用周围的地雷个数表示非地雷格。相邻字符之间无分隔符。
输入输出样例
输入 #1 复制
3 3
??
???
??
输出 #1 复制
10
221
11
输入 #2 复制
2 3
?*?
??
输出 #2 复制
21
*21
说明/提示
对于 100%100%的数据， 1≤n≤100, 1≤m≤1001≤n≤100,1≤m≤100。
题目思路 对于这道题在写的我可以说十分自闭，之前我做过五子棋的小游戏。所以在做这个题的时候我是想着把不是雷的地方的周围分类搜寻一下。我也确实这么做了，写了大概快三百行。但是没有写出来。就去看别人的题解，发现别人的思路那么简单之后就有点后悔自己浪费那么多的时间。
1.对于这道题的输入我倒是没有问题，但是由于thunder是一个字符数组，所以一定要加getchar函数。而我最后也因为getchar函数加的位置不对而导致迟迟不能通过。原来我把getchar函数放到循环的内层了
2.现在说一下这道题的核心思想问题就是搜寻雷的问题，好的思想到底简便到哪里呢？他把搜寻的过程通过循环来完成。由于搜寻的时候无非就是i或j +1或-1，所以两层for循环将i和j分别都完成了这个操作。
#include&lt;iostream&gt; #include&lt;cstdio&gt; using namespace std; int n,m; char thunder[103][103]; void search(int i,int j) { int flage=0; for(int di=-1;di&lt;2;di++) { for(int dj=-1;dj&lt;2;dj++) { int x=i+di; int y=j+dj; if((di!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7afe005e8a3c5bd72453e9e07bda5f64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3d54c337d77e7c128655b48e83406dd/" rel="bookmark">
			lgb使用方法与调参
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文参考了lgb中文文档，和lgb调参笔记。
import lightgbm as lgb lgb参数 *type 1 不需要调试的参数 *
boosting_type
1.gbdt 2.rf
objective
1.regression 回归 2.binary 二分类（01） 3.multiclass 多分类（需要设置num_class）
num_class 多分类的类别数
early_stopping_round 多少轮学习后无优化，则停止。
data 训练数据
valid验证数据
lgb_train = lgb.Dataset(split_train_x, split_train_y) data = lgb_train #API参数 metric 度量，详见在线文档。
nthread 多进程
device cpu,gpu
type 2 需要调试的参数
learning_rate
num_leaves 一棵树的最大叶子数
max_depth 一棵树的最大深度
min_split_gain 切分的最小增益
min_data_in_leaf叶子上的最小数据量，可以用来解决过拟合
min_sum_hessian_in_leaf叶子上的最小hessian值，可以用来解决过拟合
feature_fraction 0~1，每次训练中仅抽取该比例的特征进行训练，可以用来加速和解决过拟合
bagging_fraction 0~1，每次训练中仅抽取该比例的数据进行训练，可以用来加速和解决过拟合
lambda_l1 L1正则
lambda_l2 L2正则
num_boost_round boosting的最大迭代次数
超参数调试方法
step1 确定n_estimators
step2 确定max_depth和max_leaves
step3 确定min_data_in_leaf 和 max_bin
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3d54c337d77e7c128655b48e83406dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/779b45bb3a68b497d988f617e8fe5cf9/" rel="bookmark">
			kali更新软件后进不去图形化界面解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、## 标题切换到root用户 su - root 2、更改apt源为国内源，保存并退出 vim /etc/apt/sources.list 以下三个源都可写入，建议只填写一个阿里源。添加太多在更新软件列表和程序可能要花费很多时间。
#阿里源 deb http://mirrors.aliyun.com/kali kali-rolling main non-free contrib deb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib #中科大kali源 deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib deb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib #清华大学 deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free deb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free 3、更新系统 sudo apt update &amp;&amp; apt upgrade &amp;&amp; apt dist-upgrade sudo apt-get clean 如果看到这句话的时候，apt --fix-broken install*****
直接敲apt --fix-broken install
4、安装xorg（xfce4环境必备） sudo apt-get install xorg 5、安装Xfce4桌面环境 sudo apt-get install kali-defaults kali-root-login desktop-base xfce4 xfce4-places-plugin xfce4-goodies 6、解决桌面环境乱码问题 sudo apt install ttf-wqy-zenhei 重启计算机，之后便可正常使用图形界面
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/779b45bb3a68b497d988f617e8fe5cf9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc04f179f8d3021aea5001ea22617a0b/" rel="bookmark">
			python笔记（三十八） pygame（5） 改变透明度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import pygame import sys # 初始化pygame pygame.init() size = width ,height = 900, 500 bg = (255,255,255) clock = pygame.time.Clock() # 创建指定大小的窗口 screen = pygame.display.set_mode(size) # 设置窗口标题 pygame.display.set_caption("闲得发慌") # 加载图片 将所有图片格式转换成一样的 用convert people = pygame.image.load("p.png").convert_alpha() #对于有alpha通道的png格式转换要加alpha background = pygame.image.load("b.JPG").convert() # 获得图像矩形位置 position = people.get_rect() position.center = width // 2, height // 2 def blit_alpha(target,source,location,opacity): x = location[0] y = location[1] temp = pygame.Surface((source.get_width(),source.get_height())).convert() temp.blit(target,(-x,-y)) temp.blit(source,(0,0)) temp.set_alpha(opacity) target.blit(temp,location) while True: for event in pygame.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc04f179f8d3021aea5001ea22617a0b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/237/">«</a>
	<span class="pagination__item pagination__item--current">238/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/239/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>