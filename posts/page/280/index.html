<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/396167036f68dfcd4aeed625aaca9944/" rel="bookmark">
			Apache Tomcat服务器安装配置和部署运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Apache Tomcat服务器安装配置和部署运行 在Windows 64位系统上安装配置和部署运行Apache Tomcat服务器。
1，先下载适应于64为Windows操作系统的Tomcat服务器。
连接：http://tomcat.apache.org/
我下载的是：
2，解压：
3，配置Tomcat服务器的运行环境和Java环境。
我是通过写bat批处理文件实现，不需要配置Windows系统的环境变量，只需要简单的写一个bat批处理文件，点击运行后即可启动Tomcat服务器，具体的启动Tomcat服务器.bat的代码如下：
set path=D:\code\apache-tomcat\bin set JAVA_HOME=C:\program\java\jdk set CATALINA_HOME=D:\code\apache-tomcat start D:\code\apache-tomcat\bin\startup.bat 如果配置正确，在浏览器输入 locahost:8080即可打开Tom猫的欢迎页面。
现在如果想换掉自己写的欢迎页面，比如想在浏览器打开locahost:8080地址后，打开一个叫做 zhangphil.html文件，那么需要修改apache-tomcat\conf\web.xml文件，找到web.xml里面的定义welcome-file-list，原始的定义是这样的：
通过locahost:8080默认打开的就是welcome-file-list下面定义的文件，Tomcat服务器会自动从上往下寻找列表中的文件，找到就加载。可以把第一个index.html改成zhangphil.html即可实现默认的打开自己写的zhangphil.html文件：
那zhangphil.html应该放在哪里呢？是在ROOT下面，即apache-tomcat\webapps\ROOT：
修改好web.xml，把zhangphil.html放到ROOT下面，此时再打开locahost:8080后：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af98bf82f4899e5b12d8514d28dcbc09/" rel="bookmark">
			js delete删除key
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		var a = {} a.a = 1 a.b = 2 delete a["a"] console.log(a) // {b:2} delete a.b console.log(a) // {} js 的delete可以根据key删除对象中的元素。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3efaeb8c13bfb7f454ecde89ac596f8d/" rel="bookmark">
			腾讯 IEG Unity 面经
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题有点多。我会分块列举
基础相关
1.Animator的使用和机制 以及与Animation的区别
2.什么是弱引用？弱引用的使用和作用？弱引用和强引用的区别？
3.Unity的路径有哪些？对象池的使用？
4.了解过音频压缩吗，音频文件怎么降噪？了解过动画压缩吗，3DMAX如何进行骨骼优化？
5.各种排序算法的时间复杂度，实现快排？
6.C# lambda表达式和表达式树的用法？
7.了解过A*算法吗，简单说说
8.说一说状态机和行为树
网络相关
9..UDP和TCP的区别？什么是三次握手四次挥手？为什么要三次握手？四次挥手的过程？
10.TCP连接中如果客户端突然网络中断会发生什么？
11.UDP如何实现可靠传输？数据包的合并？
12.如果让你做一款Moba类或者其他多人竞技游戏，你会选择哪种通信协议，为什么？
13.你知道的同步方式，区别是什么？
14.如果让你做一款Moba类或者其他多人竞技游戏，你会选择哪种同步方式，为什么？
15.在一局Moba类游戏中如何实现断线重连功能？
16.你的逻辑判断是在客户端还是在服务器上？如何保证客户端逻辑判断的准确性？
17.对于FPS比较低的客户端如何保证数据传输的可靠性？
18.如何保证各个客户端的游戏进度一样？
19.最后说说你怎么解决网络优化和基于网络的性能优化问题？
性能优化相关
20.大致谈一下性能优化？
21.如果让你开发一款Moba类游戏，如何做具体的性能优化？（我简单说了一下所了解的王者荣耀的性能优化）
22.你觉得Unity的UGUI在性能方面的表现如何？如何优化UGUI？（因为我知道王者荣耀在这块是有自己的UI框架，所以不太敢随便回答）
24.如何解决低性能机器掉帧、卡帧问题？
25.对于大量数据包传输，由于客户端无法在给定的时间内解析完数据包，如何解决这一问题？
26.假设我的机器就只有1核1G的CPU如何让你的游戏也能在这上面运行，不会崩溃？
27.最后说一下你的项目所做的性能优化的尝试？
图形学相关
28.了解OpenGL和DX3D吗？了解shader吗？
29.什么是顶点着色器？什么是片元着色器？
30.Unity渲染管线？请简单描述一下这个过程？
31.可编程渲染管线和固定管线的区别和优势？
32.什么是Z缓冲？什么是G缓冲？作用？
33.Unity如何将一个顶点变换到屏幕上？请写出矩阵变换的过程？
34.如何实现顶点动画？举一个你自己的例子
35.法线变换和顶点变换有什么区别的关系？
36.深度测试和模板测试？
37.说说shader怎么做性能优化？DrawCall优化？
38.最后简要描述一下你自己实现过的一个shader例子？
lua相关
39.Lua框架？
40.XLua如何实现热更新？
41.Lua如何实现面向对象？
42.Lua协程？
43.Lua GC垃圾回收机制？
44.Lua如何调用C/C++函数
45.最后一个问题，自己有没有改过XLua，具体说说？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2592ca3c30fc3a3158872a2a0de4bfe/" rel="bookmark">
			C#winform中IP输入框控件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可以通过自定义控件的方式做一个IP输入框，目前这个是一个IP输入控件的类，还不能在工具箱中拖放，希望以后做一个可以放在工具箱中的，这个类如下：
public class IpInputBox : Label { private bool _isNetmask = false; public bool IsNetmask { get { return _isNetmask; } set { _isNetmask = value; } } public IpInputBox(bool isNetmask) { _isNetmask = isNetmask; this.Size = new System.Drawing.Size(150, 25); _dotLabel1.Text = "."; _dotLabel2.Text = "."; _dotLabel3.Text = "."; _dotLabel1.Size = new System.Drawing.Size(10, 25); _dotLabel2.Size = new System.Drawing.Size(10, 25); _dotLabel3.Size = new System.Drawing.Size(10, 25); _box1.IsNetmask = _isNetmask; _box2.IsNetmask = _isNetmask; _box3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2592ca3c30fc3a3158872a2a0de4bfe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b255f4380a07907bb309f3bb2546ede/" rel="bookmark">
			.net core webapi  读取php 接口 方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引用命名空间
using System.Net;
[HttpPost("api/get")]
public string Get() {
WebClient wc = new WebClient(); //最主要是该类
var result = wc.DownloadString("url");
//就是调用接口后得到的返回值
return result;
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ed03f01a012a496bc06b8a065f4f5c5/" rel="bookmark">
			爬去高德地图的公司信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# _*_ coding:utf-8 _*_ from __future__ import division import requests import sys import json import tkinter as tk from tkinter import * from tkinter import ttk import xlwt import math import time import datetime cityJsonStr = [{'provice':'安徽','city':[{'adcode':'340100','name':'合肥'},{'adcode':'340200','name':'芜湖'},{'adcode':'340300','name':'蚌埠'},{'adcode':'340400','name':'淮南'},{'adcode':'340500','name':'马鞍山'},{'adcode':'340600','name':'淮北'},{'adcode':'340700','name':'铜陵'},{'adcode':'340800','name':'安庆'},{'adcode':'341000','name':'黄山'},{'adcode':'341100','name':'滁州'},{'adcode':'341200','name':'阜阳'},{'adcode':'341300','name':'宿州'},{'adcode':'341500','name':'六安'},{'adcode':'341600','name':'亳州'},{'adcode':'341700','name':'池州'},{'adcode':'341800','name':'宣城'}]},{'provice':'福建','city':[{'adcode':'350100','name':'福州'},{'adcode':'350200','name':'厦门'},{'adcode':'350300','name':'莆田'},{'adcode':'350400','name':'三明'},{'adcode':'350500','name':'泉州'},{'adcode':'350600','name':'漳州'},{'adcode':'350700','name':'南平'},{'adcode':'350800','name':'龙岩'},{'adcode':'350900','name':'宁德'}]},{'provice':'广东','city':[{'adcode':'440100','name':'广州'},{'adcode':'440200','name':'韶关'},{'adcode':'440300','name':'深圳'},{'adcode':'440400','name':'珠海'},{'adcode':'440500','name':'汕头'},{'adcode':'440600','name':'佛山'},{'adcode':'440700','name':'江门'},{'adcode':'440800','name':'湛江'},{'adcode':'440900','name':'茂名'},{'adcode':'441200','name':'肇庆'},{'adcode':'441300','name':'惠州'},{'adcode':'441400','name':'梅州'},{'adcode':'441500','name':'汕尾'},{'adcode':'441600','name':'河源'},{'adcode':'441700','name':'阳江'},{'adcode':'441800','name':'清远'},{'adcode':'441900','name':'东莞'},{'adcode':'442000','name':'中山'},{'adcode':'445100','name':'潮州'},{'adcode':'445200','name':'揭阳'},{'adcode':'445300','name':'云浮'}]},{'provice':'广西','city':[{'adcode':'450100','name':'南宁'},{'adcode':'450200','name':'柳州'},{'adcode':'450300','name':'桂林'},{'adcode':'450400','name':'梧州'},{'adcode':'450500','name':'北海'},{'adcode':'450600','name':'防城港'},{'adcode':'450700','name':'钦州'},{'adcode':'450800','name':'贵港'},{'adcode':'450900','name':'玉林'},{'adcode':'451000','name':'百色'},{'adcode':'451100','name':'贺州'},{'adcode':'451200','name':'河池'},{'adcode':'451300','name':'来宾'},{'adcode':'451400','name':'崇左'}]},{'provice':'贵州','city':[{'adcode':'520100','name':'贵阳'},{'adcode':'520200','name':'六盘水'},{'adcode':'520300','name':'遵义'},{'adcode':'520400','name':'安顺'},{'adcode':'520500','name':'毕节'},{'adcode':'520600','name':'铜仁'},{'adcode':'522300','name':'黔西南布依族苗族自治州'},{'adcode':'522600','name':'黔东南苗族侗族自治州'},{'adcode':'522700','name':'黔南布依族苗族自治州'}]},{'provice':'甘肃','city':[{'adcode':'620100','name':'兰州'},{'adcode':'620200','name':'嘉峪关'},{'adcode':'620300','name':'金昌'},{'adcode':'620400','name':'白银'},{'adcode':'620500','name':'天水'},{'adcode':'620600','name':'武威'},{'adcode':'620700','name':'张掖'},{'adcode':'620800','name':'平凉'},{'adcode':'620900','name':'酒泉'},{'adcode':'621000','name':'庆阳'},{'adcode':'621100','name':'定西'},{'adcode':'621200','name':'陇南'},{'adcode':'622900','name':'临夏回族自治州'},{'adcode':'623000','name':'甘南藏族自治州'}]},{'provice':'河北','city':[{'adcode':'130100','name':'石家庄'},{'adcode':'130200','name':'唐山'},{'adcode':'130300','name':'秦皇岛'},{'adcode':'130400','name':'邯郸'},{'adcode':'130500','name':'邢台'},{'adcode':'130600','name':'保定'},{'adcode':'130700','name':'张家口'},{'adcode':'130800','name':'承德'},{'adcode':'130900','name':'沧州'},{'adcode':'131000','name':'廊坊'},{'adcode':'131100','name':'衡水'}]},{'provice':'黑龙江','city':[{'adcode':'230100','name':'哈尔滨'},{'adcode':'230200','name':'齐齐哈尔'},{'adcode':'230300','name':'鸡西'},{'adcode':'230400','name':'鹤岗'},{'adcode':'230500','name':'双鸭山'},{'adcode':'230600','name':'大庆'},{'adcode':'230700','name':'伊春'},{'adcode':'230800','name':'佳木斯'},{'adcode':'230900','name':'七台河'},{'adcode':'231000','name':'牡丹江'},{'adcode':'231100','name':'黑河'},{'adcode':'231200','name':'绥化'},{'adcode':'232700','name':'大兴安岭'}]},{'provice':'河南','city':[{'adcode':'410100','name':'郑州'},{'adcode':'410200','name':'开封'},{'adcode':'410300','name':'洛阳'},{'adcode':'410400','name':'平顶山'},{'adcode':'410500','name':'安阳'},{'adcode':'410600','name':'鹤壁'},{'adcode':'410700','name':'新乡'},{'adcode':'410800','name':'焦作'},{'adcode':'410900','name':'濮阳'},{'adcode':'411000','name':'许昌'},{'adcode':'411100','name':'漯河'},{'adcode':'411200','name':'三门峡'},{'adcode':'411300','name':'南阳'},{'adcode':'411400','name':'商丘'},{'adcode':'411500','name':'信阳'},{'adcode':'411600','name':'周口'},{'adcode':'411700','name':'驻马店'},{'adcode':'419001','name':'济源'}]},{'provice':'湖北','city':[{'adcode':'420100','name':'武汉'},{'adcode':'420200','name':'黄石'},{'adcode':'420300','name':'十堰'},{'adcode':'420500','name':'宜昌'},{'adcode':'420600','name':'襄阳'},{'adcode':'420700','name':'鄂州'},{'adcode':'420800','name':'荆门'},{'adcode':'420900','name':'孝感'},{'adcode':'421000','name':'荆州'},{'adcode':'421100','name':'黄冈'},{'adcode':'421200','name':'咸宁'},{'adcode':'421300','name':'随州'},{'adcode':'422800','name':'恩施土家族苗族自治州'},{'adcode':'429004','name':'仙桃'},{'adcode':'429005','name':'潜江'},{'adcode':'429006','name':'天门'},{'adcode':'429021','name':'神农架林区'}]},{'provice':'湖南','city':[{'adcode':'430100','name':'长沙'},{'adcode':'430200','name':'株洲'},{'adcode':'430300','name':'湘潭'},{'adcode':'430400','name':'衡阳'},{'adcode':'430500','name':'邵阳'},{'adcode':'430600','name':'岳阳'},{'adcode':'430700','name':'常德'},{'adcode':'430800','name':'张家界'},{'adcode':'430900','name':'益阳'},{'adcode':'431000','name':'郴州'},{'adcode':'431100','name':'永州'},{'adcode':'431200','name':'怀化'},{'adcode':'431300','name':'娄底'},{'adcode':'433100','name':'湘西土家族苗族自治州'}]},{'provice':'海南','city':[{'adcode':'460100','name':'海口'},{'adcode':'460200','name':'三亚'},{'adcode':'460300','name':'三沙'},{'adcode':'460400','name':'儋州'}]},{'provice':'吉林','city':[{'adcode':'220100','name':'长春'},{'adcode':'220200','name':'吉林'},{'adcode':'220300','name':'四平'},{'adcode':'220400','name':'辽源'},{'adcode':'220500','name':'通化'},{'adcode':'220600','name':'白山'},{'adcode':'220700','name':'松原'},{'adcode':'220800','name':'白城'},{'adcode':'222400','name':'延边朝鲜族自治州'}]},{'provice':'江苏','city':[{'adcode':'320100','name':'南京'},{'adcode':'320200','name':'无锡'},{'adcode':'320300','name':'徐州'},{'adcode':'320400','name':'常州'},{'adcode':'320500','name':'苏州'},{'adcode':'320600','name':'南通'},{'adcode':'320700','name':'连云港'},{'adcode':'320800','name':'淮安'},{'adcode':'320900','name':'盐城'},{'adcode':'321000','name':'扬州'},{'adcode':'321100','name':'镇江'},{'adcode':'321200','name':'泰州'},{'adcode':'321300','name':'宿迁'}]},{'provice':'江西','city':[{'adcode':'360100','name':'南昌'},{'adcode':'360200','name':'景德镇'},{'adcode':'360300','name':'萍乡'},{'adcode':'360400','name':'九江'},{'adcode':'360500','name':'新余'},{'adcode':'360600','name':'鹰潭'},{'adcode':'360700','name':'赣州'},{'adcode':'360800','name':'吉安'},{'adcode':'360900','name':'宜春'},{'adcode':'361000','name':'抚州'},{'adcode':'361100','name':'上饶'}]},{'provice':'辽宁','city':[{'adcode':'210100','name':'沈阳'},{'adcode':'210200','name':'大连'},{'adcode':'210300','name':'鞍山'},{'adcode':'210400','name':'抚顺'},{'adcode':'210500','name':'本溪'},{'adcode':'210600','name':'丹东'},{'adcode':'210700','name':'锦州'},{'adcode':'210800','name':'营口'},{'adcode':'210900','name':'阜新'},{'adcode':'211000','name':'辽阳'},{'adcode':'211100','name':'盘锦'},{'adcode':'211200','name':'铁岭'},{'adcode':'211300','name':'朝阳'},{'adcode':'211400','name':'葫芦岛'}]},{'provice':'内蒙古','city':[{'adcode':'150100','name':'呼和浩特'},{'adcode':'150200','name':'包头'},{'adcode':'150300','name':'乌海'},{'adcode':'150400','name':'赤峰'},{'adcode':'150500','name':'通辽'},{'adcode':'150600','name':'鄂尔多斯'},{'adcode':'150700','name':'呼伦贝尔'},{'adcode':'150800','name':'巴彦淖尔'},{'adcode':'150900','name':'乌兰察布'},{'adcode':'152200','name':'兴安盟'},{'adcode':'152500','name':'锡林郭勒盟'},{'adcode':'152900','name':'阿拉善盟'}]},{'provice':'宁夏','city':[{'adcode':'640100','name':'银川'},{'adcode':'640200','name':'石嘴山'},{'adcode':'640300','name':'吴忠'},{'adcode':'640400','name':'固原'},{'adcode':'640500','name':'中卫'}]},{'provice':'青海','city':[{'adcode':'630100','name':'西宁'},{'adcode':'630200','name':'海东'},{'adcode':'632200','name':'海北藏族自治州'},{'adcode':'632300','name':'黄南藏族自治州'},{'adcode':'632500','name':'海南藏族自治州'},{'adcode':'632600','name':'果洛藏族自治州'},{'adcode':'632700','name':'玉树藏族自治州'},{'adcode':'632800','name':'海西蒙古族藏族自治州'}]},{'provice':'山西','city':[{'adcode':'140100','name':'太原'},{'adcode':'140200','name':'大同'},{'adcode':'140300','name':'阳泉'},{'adcode':'140400','name':'长治'},{'adcode':'140500','name':'晋城'},{'adcode':'140600','name':'朔州'},{'adcode':'140700','name':'晋中'},{'adcode':'140800','name':'运城'},{'adcode':'140900','name':'忻州'},{'adcode':'141000','name':'临汾'},{'adcode':'141100','name':'吕梁'}]},{'provice':'山东','city':[{'adcode':'370100','name':'济南'},{'adcode':'370200','name':'青岛'},{'adcode':'370300','name':'淄博'},{'adcode':'370400','name':'枣庄'},{'adcode':'370500','name':'东营'},{'adcode':'370600','name':'烟台'},{'adcode':'370700','name':'潍坊'},{'adcode':'370800','name':'济宁'},{'adcode':'370900','name':'泰安'},{'adcode':'371000','name':'威海'},{'adcode':'371100','name':'日照'},{'adcode':'371200','name':'莱芜'},{'adcode':'371300','name':'临沂'},{'adcode':'371400','name':'德州'},{'adcode':'371500','name':'聊城'},{'adcode':'371600','name':'滨州'},{'adcode':'371700','name':'菏泽'}]},{'provice':'四川','city':[{'adcode':'510100','name':'成都'},{'adcode':'510300','name':'自贡'},{'adcode':'510400','name':'攀枝花'},{'adcode':'510500','name':'泸州'},{'adcode':'510600','name':'德阳'},{'adcode':'510700','name':'绵阳'},{'adcode':'510800','name':'广元'},{'adcode':'510900','name':'遂宁'},{'adcode':'511000','name':'内江'},{'adcode':'511100','name':'乐山'},{'adcode':'511300','name':'南充'},{'adcode':'511400','name':'眉山'},{'adcode':'511500','name':'宜宾'},{'adcode':'511600','name':'广安'},{'adcode':'511700','name':'达州'},{'adcode':'511800','name':'雅安'},{'adcode':'511900','name':'巴中'},{'adcode':'512000','name':'资阳'},{'adcode':'513200','name':'阿坝藏族羌族自治州'},{'adcode':'513300','name':'甘孜藏族自治州'},{'adcode':'513400','name':'凉山彝族自治州'}]},{'provice':'陕西','city':[{'adcode':'610100','name':'西安'},{'adcode':'610200','name':'铜川'},{'adcode':'610300','name':'宝鸡'},{'adcode':'610400','name':'咸阳'},{'adcode':'610500','name':'渭南'},{'adcode':'610600','name':'延安'},{'adcode':'610700','name':'汉中'},{'adcode':'610800','name':'榆林'},{'adcode':'610900','name':'安康'},{'adcode':'611000','name':'商洛'}]},{'provice':'天津','city':[{'adcode':'120100','name':'天津市市辖区'}]},{'provice':'台湾','city':[{'adcode':'719002','name':'台北'},{'adcode':'719019','name':'高雄'},{'adcode':'719017','name':'台中'},{'adcode':'719016','name':'台南'},{'adcode':'719010','name':'新北'},{'adcode':'719011','name':'基隆'},{'adcode':'719006','name':'新竹'},{'adcode':'719004','name':'嘉义'}]},{'provice':'西藏','city':[{'adcode':'540100','name':'拉萨'},{'adcode':'540200','name':'日喀则'},{'adcode':'540300','name':'昌都'},{'adcode':'540400','name':'林芝'},{'adcode':'540500','name':'山南'},{'adcode':'540600','name':'那曲'},{'adcode':'542500','name':'阿里'}]},{'provice':'新疆','city':[{'adcode':'650100','name':'乌鲁木齐'},{'adcode':'650200','name':'克拉玛依'},{'adcode':'650400','name':'吐鲁番'},{'adcode':'650500','name':'哈密'},{'adcode':'652300','name':'昌吉回族自治州'},{'adcode':'652700','name':'博尔塔拉蒙古自治州'},{'adcode':'652800','name':'巴音郭楞蒙古自治州'},{'adcode':'652900','name':'阿克苏'},{'adcode':'653000','name':'克孜勒苏柯尔克孜自治州'},{'adcode':'653100','name':'喀什'},{'adcode':'653200','name':'和田'},{'adcode':'654000','name':'伊犁哈萨克自治州'},{'adcode':'654200','name':'塔城'},{'adcode':'654300','name':'阿勒泰'},{'adcode':'659001','name':'石河子'},{'adcode':'659002','name':'阿拉尔'},{'adcode':'659003','name':'图木舒克'},{'adcode':'659004','name':'五家渠'}]},{'provice':'云南','city':[{'adcode':'530100','name':'昆明'},{'adcode':'530300','name':'曲靖'},{'adcode':'530400','name':'玉溪'},{'adcode':'530500','name':'保山'},{'adcode':'530600','name':'昭通'},{'adcode':'530700','name':'丽江'},{'adcode':'530800','name':'普洱'},{'adcode':'530900','name':'临沧'},{'adcode':'532300','name':'楚雄彝族自治州'},{'adcode':'532500','name':'红河哈尼族彝族自治州'},{'adcode':'532600','name':'文山壮族苗族自治州'},{'adcode':'532800','name':'西双版纳傣族自治州'},{'adcode':'532900','name':'大理白族自治州'},{'adcode':'533100','name':'德宏傣族景颇族自治州'},{'adcode':'533300','name':'怒江傈僳族自治州'},{'adcode':'533400','name':'迪庆藏族自治州'}]},{'provice':'浙江','city':[{'adcode':'330100','name':'杭州'},{'adcode':'330200','name':'宁波'},{'adcode':'330300','name':'温州'},{'adcode':'330400','name':'嘉兴'},{'adcode':'330500','name':'湖州'},{'adcode':'330600','name':'绍兴'},{'adcode':'330700','name':'金华'},{'adcode':'330800','name':'衢州'},{'adcode':'330900','name':'舟山'},{'adcode':'331000','name':'台州'},{'adcode':'331100','name':'丽水'}]},{'provice':'上海','city':[{'adcode':'310000','name':'上海市区'}]},{'provice':'重庆','city':[{'adcode':'500000','name':'重庆市区'}]},{'provice':'北京','city':[{'adcode':'110000','name':'北京市区'}]}] class GaodeDataExport(object): def __init__(self, ids, keword, page, cookies): self.page = page self.keword = keword self.ids = ids self.url = "https://www.amap.com/service/poiInfo?query_type=TQUERY&amp;pagesize=30&amp;pagenum=1&amp;qii=true&amp;cluster_state=5&amp;need_utd=true&amp;utd_sceneid=1000&amp;div=PC1000&amp;addr_poi_merge=true&amp;is_classify=true&amp;zoom=12&amp;city=" + \ ids+"&amp;geoobj=121.445178%7C31.151969%7C121.609973%7C31.317242&amp;keywords="+keword self.headers = { 'Cookie': cookies, 'User-Agent': 'Mozilla/5.0 (Windows NT 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ed03f01a012a496bc06b8a065f4f5c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39fda00d0e96053e2e7fe2f6abbe9ac8/" rel="bookmark">
			php数组循环添加键值对
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 二维数组添加方法：循环$listening_collect是一个二维数组，往里面添加一个you_answer元素
$listening_collect = $this-&gt;ser_toefllistening-&gt;zt_collect($listening_articleid)-&gt;result_array(); foreach ($listening_collect as $key =&gt; $value){ //变量值$answer是个数组 answer是里面的一个元素 $answer = $this-&gt;ser_toefllistening-&gt;answer($value['id'],$u_id); $listening_collect[$key]['you_answer'] = $answer['answer']; } 打印$listening_collect数组
添加之后打印$listening_collect数组
一维数组添加方法：
//这个是一维数组添加 foreach($arr as $key =&gt; &amp;$vo){ $vo['name'] = '星星'; $vo['age'] = '24'; } $arr[$key]['name'] = '星星'; $arr[$key]['age'] = '24'; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b47d82e2e28fa15f0692da272cd9585/" rel="bookmark">
			zoj 4027  2018浙江acm省赛 Problem D. Sequence Swapping
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		链接： https://cn.vjudge.net/problem/ZOJ-4027
思路： dp 第二次做还是没有做出来。。。不过的确是个好题。
首先就是要确定dp状态的定义，这里我把dp[i][j] 定义为将第i个左括号移动到 位置&gt;=j 的最大价值。
其实可以发现每个左括号其实都是有一个可移动上下界范围的。我如果想要将第i个括号移动到位置j 那么肯定第 i+1 个括号在 &gt;=j+1 的位置。
那么 dp[i][j] = max( dp[i][j+1] , dp[i+1][j+1] + 移动到这里所需要的花费 )
代码：
#include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const ll inf = 1e18+5; const int N = 1005; ll dp[N][N]; ll cost[N][N]; ll sum2[N][N]; char s[N]; ll val[N]; int inde[N]; int n; int main() { int T; scanf("%d",&amp;T); while(T--) { scanf("%d",&amp;n); scanf("%s",s+1); for(int i=1;i&lt;=n;i++) { scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b47d82e2e28fa15f0692da272cd9585/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80e9a1452d8367b2fc15134bef652f1d/" rel="bookmark">
			网络爬虫-破解京东滑块验证码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近一直在研究滑块验证码这一块，接连破解了极验2.0，极验3.0以及淘宝滑块，当然了，只是使用selenium模拟过，拿到cookie后进行后续操作。 今天就讲讲京东这个滑块验证码，神坑，之前的轨迹方程全部不可用，需要自己慢慢调试，找到最佳参数，最大化模拟人为操作才能过，目前我过的几率为80%左右。 京东登陆页面 京东这个滑块验证码的最大的坑就在于 大量的模拟人为的轨迹方程都被封了 比如过极验2 极验3的轨迹，都无法在京东的滑块上面使用，并且原图也是无法找到的，只会在页面上给你有缺口的base64图片。
经过反复试验，发现京东的滑块验证码，共10张图片，现在就是下载京东图片的时候了，然后用PIL分割拼接，制作成我下面的这种图片。
前面的那一部分可以不用考虑，因为滑块的开始地方就是这个滑块的右方，比如这张图的大小是281 x 109，缺口图的大小是38 x 38，那么对比的地方则是 (281 - 38) * 109
对比的方式以及下载原图缺口图，找出距离的地方就不再累赘，做过滑块验证码的童鞋应该都知道，都是那一套方案反复使用。代码如下：
def is_pixel_equal(self, img1, img2, x, y): """ 判断两个像素是否相同 :param image1: 图片1 :param image2: 图片2 :param x: 位置x :param y: 位置y :return: 像素是否相同 """ # 取两个图片的像素点 pix1 = img1.load()[x, y] pix2 = img2.load()[x, y] threshold = 60 if (abs(pix1[0] - pix2[0] &lt; threshold) and abs(pix1[1] - pix2[1] &lt; threshold) and abs( pix1[2] - pix2[2] &lt; threshold)): return True else: return False def get_gap(self, img1, img2): "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80e9a1452d8367b2fc15134bef652f1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8fb009d6d7a5cfcc1b46413697fcc2b/" rel="bookmark">
			c&#43;&#43; 11 实现简单 signal slot
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		c++ 11以前要实现 signal slot 非常麻烦，需要重写很多代码。之前使用 libsig++ 后来发现 这代码中与qt 的slots emit等名称冲突。虽然可以解决，但是比较麻烦。所以 就使用 新的 c++特性，自行实现了简单的 signal 类。 目前实现比较简单。没有太多考虑异常或者智能情况。
这里面包含了结合线程使用,编程异步信号的 部分代码.需要屏蔽掉才能正常使用.
#include &lt;functional&gt; #include &lt;map&gt; #include &lt;vector&gt; #include "ScTypes.h" #include "ScCoreDefine.h" #define AsyncSignal #ifdef AsyncSignal #include "ScAsyncMessage.h" #include "ScThread.h" #include "ScMutex.h" #include "ScReadWriteLock.h" #endif #ifdef PostMessage #define PostMessageOld PostMessage #undef PostMessage #endif // A signal object may call multiple slots with the // same signature. You can connect functions to the signal // which will be called when the emit() method on the // signal object is invoked.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8fb009d6d7a5cfcc1b46413697fcc2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3ac93754cc82029ffdbefec6d7e3f3a/" rel="bookmark">
			PHP-FastCGI详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是 FastCGI
FastCGI是一个可伸缩地、高速地在HTTP server和动态脚本语言间通信的接口。多数流行的HTTP server都支持FastCGI，包括Apache、Nginx和lighttpd等，同时，FastCGI也被许多脚本语言所支持，其中就有PHP。
FastCGI 是从CGI发展改进而来的。传统CGI接口方式的主要缺点是性能很差，因为每次HTTP服务器遇到动态程序时都需要重新启动脚本解析器来执行解析，然后结 果被返回给HTTP服务器。这在处理高并发访问时，几乎是不可用的。另外传统的CGI接口方式安全性也很差，现在已经很少被使用了。
FastCGI 接口方式采用C/S结构，可以将HTTP服务器和脚本解析服务器分开，同时在脚本解析服务器上启动一个或者多个脚本解析守护进程。当HTTP服务器每次遇 到动态程序时，可以将其直接交付给FastCGI进程来执行，然后将得到的结果返回给浏览器。这种方式可以让HTTP服务器专一地处理静态请求或者将动态 脚本服务器的结果返回给客户端，这在很大程度上提高了整个应用系统的性能。
FastCGI的重要特点：
1）是HTTP服务器和动态脚本语言间通信的接口或者工具！
2）优点就是把动态语言解析和HTTP服务器分离了开来！
3）Nginx、Apache、lighttpd以及多数动态语言都支持FastCGI。
4）接口方式采用C/S结构，分为HTTP服务器（客户端）和动态语言解析服务器（服务端）
5）PHP动态语言服务端可以启动多个FastCGI的守护进程例如：php-fpm(fcgi process mangemnt))
6）http服务器通过例（Nginx fastgi_pass)FastCGI客户端和动态语言FastCGI服务端通信（例如：php-fpm）
二、Nginx+FastCGI运行原理
nginx fastcgi访问php
1、用户发送http请求报文给nginx服务器
2、nginx会根据文件url和后缀来判断请求
3、如果请求的是静态内容,nginx会将结果直接返回给用户
4、如果请求的是动态内容,nginx会通过fastcgi_pass将这个请求发送给php-fpm 5、php-fpm会将请求交给wrapper
6、wrapper收到请求会生成新的线程调用php动态程序解析服务器
7、如果用户请求的是博文、或者内容、PHP会请求MySQL查询结果
8、如果用户请求的是图片、附件、PHP会请求nfs存储查询结果
9、php会将查询到的结果交给Nginx
10、nginx会生成一个响应报文返还给用户
Nginx 不支持对外部程序的直接调用或者解析，所有的外部程序（包括PHP）必须通过FastCGI接口来调用。FastCGI接口在Linux下是 socket，（这个socket可以是文件socket，也可以是ip socket）。为了调用CGI程序，还需要一个FastCGI的wrapper（wrapper可以理解为用于启动另一个程序的程序），这个 wrapper绑定在某个固定socket上，如端口或者文件socket。当Nginx将CGI请求发送给这个socket的时候，通过FastCGI 接口，wrapper接纳到请求，然后派生出一个新的线程，这个线程调用解释器或者外部程序处理脚本并读取返回数据；接着，wrapper再将返回的数据 通过FastCGI接口，沿着固定的socket传递给Nginx；最后，Nginx将返回的数据发送给客户端，这就是Nginx+FastCGI的整个 运作过程。详细的过程，如图1所示。
图1 Nginx+FastCGI运行原理
三、spawn-fcgi与PHP-FPM
前面介绍过，FastCGI接口方式在脚本解析服务器上启动一个或者多个守护进程对动态脚本进行解析，这些进程就是FastCGI进程管理器，或者称之为FastCGI引擎， spawn-fcgi与PHP-FPM就是支持PHP的两个FastCGI进程管理器。
下面简单介绍spawn-fcgi与PHP-FPM的异同。
spawn-fcgi是HTTP服务器lighttpd的一部分，目前已经独立成为一个项目，一般与lighttpd配合使用来支持PHP，但是ligttpd的spwan-fcgi在高并发访问的时候，会出现内存泄漏甚至自动重启FastCGI的问题。
Nginx是个轻量级的HTTP server，必须借助第三方的FastCGI处理器才可以对PHP进行解析，因此Nginx+spawn-fcgi的组合也可以实现对PHP的解析，这里不过多讲述。
PHP-FPM也是一个第三方的FastCGI进程管理器，它是作为PHP的一个补丁来开发的，在安装的时候也需要和PHP源码一起编译，也就是说PHP-FPM 被编译到PHP内核中，因此在处理性能方面更加优秀；同时它在处理高并发方面也比spawn-fcgi引擎好很多，因此，推荐 Nginx+PHP/PHP-FPM这个组合对PHP进行解析。
FastCGI 的主要优点是把动态语言和HTTP Server分离开来，所以Nginx与PHP/PHP-FPM经常被部署在不同的服务器上，以分担前端Nginx服务器的压力，使Nginx专一处理静 态请求和转发动态请求，而PHP/PHP-FPM服务器专一解析PHP动态请求。
四、 PHP与PHP-FPM的安装及优化
1.下载安装包
从www.php.net官方网站下载PHP源码包，这里下载的是稳定版php-5.2.13.tar.gz。
从http://php-fpm.org/downloads/下载对应的PHP-FPM源码包，这里下载的是php-5.2.13-fpm-0.5.13.diff.gz。
需要注意，在下载软件包版本时，尽量使PHP和PHP-FPM版本一致，如果版本之间相差太大，可以会出现兼容问题。
2.配置安装环境
安装PHP需要下面软件包的支持，如果没有安装，请自行安装。
gcc gcc-c++ libxml2 libxml2-devel autoconf libjpeg libjpeg-devel libpng libpng-devel freetype freetype-devel zlib zlib-devel glibc glibc-devel glib2 glib2-devel 由于各个Linux系统版本的不确定性，读者也可以在安装PHP过程中，根据错误提示信息，安装对应的软件库。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3ac93754cc82029ffdbefec6d7e3f3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f69586c7c1fc1f846ae45604556c589/" rel="bookmark">
			java实现：在有序数组中插入一个数据，保持数组仍然有序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		思路：
找要插入的位置 index将该位置后面的数据，都往后挪一位 （处理index后面的数据）把新数据插到该位置（处理index对应的数据） package com.array.test; import java.util.Arrays; import java.util.Scanner; /** * 实现：在有序数组中插入一个元素,保持数组仍然有序 * 对新数组排序---1）找要插入的位置 * 2）将该位置后面的数据，都往后挪一位 * 3）把新数据插到该位置 */ public class ArrayInsertThree { public static void main(String[] args) { int[] arr=new int[]{5,8,19,20,23}; System.out.println("原数组为：arr="+ Arrays.toString(arr)); Scanner sc=new Scanner(System.in); System.out.println("请输入插入的数据"); int number=sc.nextInt(); //要插入的数据 int index=arr.length-1; //用来保存要插入的位置，默认是数组最后一个位置 //1、遍历数组，找到要插入的位置 for(int i=0;i&lt;arr.length-1;i++){ if(arr[i]&gt;number){ index=i; //一旦数组元素大于number，说明这个位置就是要插入的位置 break; //记下该位置，退出循环 } } //2、将后面的数据向后挪,处理index后面的数据 for(int i=arr.length-1;i&gt;index;i--){ //要倒着赋值 arr[i]=arr[i-1]; } //3、把数据插入到指定位置 arr[index]=number; System.out.println(Arrays.toString(arr)); } } 结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eacfc411f826edec87d51841f882c610/" rel="bookmark">
			vue2.0 设置router.go(&#39;/goods&#39;)不停刷新页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码如下：
使用router.go()后页面不停刷新。
解决办法：
使用router.push() 问题解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68116ad495f04a49cee441d72b132cb0/" rel="bookmark">
			springmvc框架下jquery的ajax使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前台controller代码1 前台编写函数，传递数据，进行ajax2 Params为js的对象，传递过去转为json字符串JSON.stringify(params),3 传递到后台的路径4. java后台controller入参5java后台出参和ajax返回结果 前台 &lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt; &lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %&gt; &lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;title&gt;上架商品-ajax&lt;/title&gt; &lt;!-- Tell the browser to be responsive to screen width --&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;!-- Font Awesome --&gt; &lt;link rel="stylesheet" href="${pageContext.request.contextPath}/conf1/css/font-awesome.min.css"&gt; &lt;!-- Ionicons --&gt; &lt;link rel="stylesheet" href="${pageContext.request.contextPath}/conf1/css/ionicons.min.css"&gt; &lt;!-- Theme style --&gt; &lt;link rel="stylesheet" href="${pageContext.request.contextPath}/conf1/dist/css/adminlte.min.css"&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68116ad495f04a49cee441d72b132cb0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4465ff6816a1a2d43131e1bcf3c1f20/" rel="bookmark">
			JS表单验证  聚焦 离焦 input（onfocus onblur）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; function showTips(id, info) { document.getElementById(id + "span").innerHTML = "&lt;font color='gray'&gt;" + info + "&lt;/font&gt;"; } function check(id, info) { var uValue = document.getElementById(id).value; if (uValue == "") { document.getElementById(id + "span").innerHTML = "&lt;font color='red'&gt;" + info + "&lt;/font&gt;"; } else { document.getElementById(id + "span").innerHTML = ""; } } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="#" method="get" name="regForm" onsubmit="return checkForm()"&gt; &lt;table border="1px" width="750px" height="400px" align="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4465ff6816a1a2d43131e1bcf3c1f20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/707c363ecd866c5e3a37688abc783abb/" rel="bookmark">
			org.springframework.mail.MailSendException: Failed messages: javax.mail.SendFailedException: Invalid...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题分析 org.springframework.mail.MailSendException: Failed messages: javax.mail.SendFailedException: Invalid Addresses
分析：可能是收件人或抄送人列表存在无效的地址
坑：不能直接catch到SendFailedException
二、解决方案 遍历异常，提取无效地址后过滤原地址列表再次发送
具体代码如下：
1.发邮件方法代码 /** * 发送html邮件 * * @param to * @param cc * @param subject * @param content */ public void sendHtmlMail(String[] to, String[] cc, String subject, String content) { MimeMessage message = mailSender.createMimeMessage(); MimeMessageHelper helper = null; try { //true表示需要创建一个multipart message helper = new MimeMessageHelper(message, true); helper.setFrom(from); helper.setTo(to); helper.setCc(cc); helper.setSubject(subject); helper.setText(content, true); mailSender.send(message); logger.info("sendHtmlMail success.from:" + from); } catch (Throwable e) { logger.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/707c363ecd866c5e3a37688abc783abb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8751698a365d19062690e143f20a3ab/" rel="bookmark">
			Microsoft Visual C&#43;&#43; 14.0 is required 的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人认为Python的一大亮点就是对于我们在学习中遇到的常见问题，它都有很多现成的module可供使用，但是，在我们安装这些module时，可能会出现**“error: Microsoft Visual C++ 14.0 is required. Get it with “Microsoft Visual C++ Build Tools”**这样的错误。对于此类问题，提供以下两种解决方案：
1 下载所需模块的.whl文件，然后再以pip的形式安装：
1）常用模块的.whl文件的下载地址：Unofficial Windows Binaries for Python Extension Packages
2）以模块Twisted为例，我们再下载了该模块的.whl文件后，在控制台通过以下命令安装
pip install Twisted‑18.9.0‑cp27‑cp27m‑win32.whl
2 最根本的解决办法：按照错误提示，需要安装Microsoft Visual C++ 14.0才能解决问题，那我们安装一下应该就没问题了（亲测可用不坑人）：
1）Microsoft Visual C++ 14.0的百度云下载地址为：
https://pan.baidu.com/s/12TcFkZ6KFLhofCT-osJOSg 提取码：wkgv
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ef9ed6247679307c5d25993e127a941/" rel="bookmark">
			Java求一元二次方程的根
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		求一元二次方程的根。 【问题描述】编写程序，从键盘输入三个系数ax2+bx+c=0，计算方程的解并输出。需要考虑方程有虚根、方程有实根、方程是一元一次方程、没有根等。输出方程的解并保留6位小数。
import java.text.DecimalFormat; import java.util.*; public class Equation{ public static void main(String[] args) { Scanner reader = new Scanner(System.in); System.out.println("请输入方程的系数a、b、c："); int a, b, c; a = reader.nextInt(); b = reader.nextInt(); c = reader.nextInt(); DecimalFormat df = new DecimalFormat("0.000000"); int delta; double x1, x2; delta = b * b - 4 * a * c; if (a == 0 &amp;&amp; b == 0 &amp;&amp; c == 0) { System.out.println("方程有无限根。"); return; } if (a == 0 &amp;&amp; b == 0 &amp; c !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ef9ed6247679307c5d25993e127a941/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3c5c10064025ba24cb186d76774298b/" rel="bookmark">
			vue m3u8视频播放组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue m3u8视频播放组件
依赖库 dplayer &lt;template&gt; &lt;div class="full"&gt; &lt;div class="dplayer-container" ref="player"&gt; 定义一个ID为player的div &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; 复制代码 &lt;script&gt; import 'dplayer/dist/DPlayer.min.css' // 引入css样式 // 基础配置 参考官网 mounted(){ // 运行时报错hls undefinded 需要声明这个全局对象 window.Hls = require('hls.js'); this.DPlayer = require('dplayer') this.dp = new this.DPlayer({ container: this.$refs.player, preload: 'none', autoplay: false, video: { url: 'demo.mp4', pic: 'demo.jpg', thumbnails: 'thumbnails.jpg' }, subtitle: { url: 'webvtt.vtt' }, danmaku: { id: 'demo', api: 'https://api.prprpr.me/dplayer/' } screenshot: true, // 截图 }); } &lt;/script&gt; 复制代码 组件bug 视频头图设置有时候显示不出来 可以在视频外层包裹一个div手动设置一个视频头图
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c94164c95f6c38e9ae3e3e87b01b9002/" rel="bookmark">
			AMDcpu 主机开启Android Studio emulator虚拟机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AMD cpu开启Android Studio emulator的步骤很简单；
一.首先开启AMD的SVM
进入BIOS,我的电脑进入BIOS的时候是开机按下F2（每个品牌商进入BIOS的按键是不同的，先查下自己的电脑的进入方法）；
进入高级----&gt;CPU Configuration--&gt;SVM Mode--&gt;Enabled--&gt;退出保存；
二.配置系统（我的系统是windows10）
打开控制面板---&gt;程序--&gt;点击启用或关闭windows功能
找到Hyper-V 全打勾
和 windows虚拟机监控程序平台 也打勾
点击确定，这时候的配置已经基本完毕，这时在Android studio下载虚拟机就可以开启了
注意一般window10家庭版配置不了，请安装专业版，（教育版没试过）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c9a9979ea74eec7752a1335f6fbc2bd/" rel="bookmark">
			IDEA 导入Spring Framework项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、下载Gradle并配置gradle环境变量
二、解压Gradle
三、添加GRADLE_HOME环境变量
四、将GRADLE_HOME添加到Path中
五、创建.gradle目录，存放gradle下载的jar文件；与maven仓库类似
六、添加GRADLE_USER_HOME环境变量，不需要添加到Path中！
注：配置好gradle环境变量和创建好.gradle文件夹后，需重启计算机系统，GRADLE_USER-HOME配置才能生效！
七、下载spring framework源码：
GitHub地址：https://github.com/spring-projects/spring-framework/releases复制代码 下载压缩包；或 git clone https://github.com/spring-projects/spring-framework.git
八、打开idea
九、导入下载的spring framework项目
十、选择
Import project from external model复制代码 选择
Gradle复制代码 十一、查看
Service directory path复制代码 确定是自定义配置的jar包下载目录，点击Finish完成
导入/编译成功后，项目出现蓝色正方形
至此，Spring Framework项目成功导入idea中了。
转载于:https://juejin.im/post/5bd57dcf6fb9a05d0c381aa8
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3049b1c2703537ca6ee28d85e5907147/" rel="bookmark">
			练习8-2 计算两数的和与差
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本题要求实现一个计算输入的两数的和与差的简单函数。
函数接口定义： void sum_diff( float op1, float op2, float *psum, float *pdiff ); 其中op1和op2是输入的两个实数，*psum和*pdiff是计算得出的和与差。
裁判测试程序样例： #include &lt;stdio.h&gt; void sum_diff( float op1, float op2, float *psum, float *pdiff ); int main() { float a, b, sum, diff; scanf("%f %f", &amp;a, &amp;b); sum_diff(a, b, &amp;sum, &amp;diff); printf("The sum is %.2f\nThe diff is %.2f\n", sum, diff); return 0; } /* 你的代码将被嵌在这里 */ 输入样例： 4 6 输出样例： The sum is 10.00 The diff is -2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3049b1c2703537ca6ee28d85e5907147/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/738a57e2634d0025b7a044d2b9f76dbe/" rel="bookmark">
			Phalcon 常用操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接受请求数据 #控制器中接收数据 #在浏览器中访问 http://localhost/index/test1?a=1&amp;b=2 $this-&gt;request-&gt;get() 方法能同时获取 GET 和 POST 请求的数据； $this-&gt;request-&gt;getQuery() 只能获取 GET 方式的请求数据； $this-&gt;request-&gt;getPost() 只能获取 POST 方式的请求数据。 #在Phalcon的路由匹配规则中，我们可以通过 $dispatcher来接收数据： #但是需要注意的是这个需要在路由配置中进行设置 public function test3Action(){ $a = $this-&gt;dispatcher-&gt;getParam('a'); $b = $this-&gt;dispatcher-&gt;getParam('b'); var_dump($a); var_dump($b); } #路由规则如下（ app/config/routes.php）： '/index/test3/(\d+)/(\d+)' =&gt; array( 'module' =&gt; 'frontend', 'controller'=&gt;'index', 'action'=&gt;'test3', 'a' =&gt; 1, 'b' =&gt; 2, ), 响应数据格式 #返回json格式数据 public function test6Action(){ return $this-&gt;response-&gt;setJsonContent(array( 'code' =&gt; 1, 'message' =&gt; 'success', )); } 页面跳转 #redirect(),仔细观察会发现浏览器中的URL地址已经发生了变化。 public function test4Action(){ return $this-&gt;response-&gt;redirect('https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/738a57e2634d0025b7a044d2b9f76dbe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dcc4bea527c27fbec8c5b75cc8e75ac/" rel="bookmark">
			树莓派的GPIO端口详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先上一张端口图
GPIO（GeneralPurposeI/OPorts）意思为通用输入/输出端口，通俗地说，就是一些引脚，可以通过它们输出高低电平或者通过它们读入引脚的状态-是高电平或是低电平。GPIO是个比较重要的概念，用户可以通过GPIO口和硬件进行数据交互（如UART），控制硬件工作（如LED、蜂鸣器等），读取硬件的工作状态信号（如中断信号）等。GPIO口的使用非常广泛。掌握了GPIO，差不多相当于掌握了操作硬件的能力。
图上可以看到，每一个针脚都有Pin#和NAME字段。Pin代表的是该针脚的编号，其中01和02针脚对应第一张图中GPIO最右边竖排的两个针脚。而NAME代表的是该针脚的BCM名称，当然NAME也可以直接看得出针脚的默认功能。比如3.3v和5v代表着该针脚会输出3.3v和5v的电压，Ground代表着该针脚是接地的，GPIO0*则是一些待用户开发的针脚。每个针脚都可以使用程序进行控制操作。
控制GPIO编程 可以用下面的代码导入RPi.GPIO模块。
importRPi.GPIOasGPIO
引入之后，就可以使用GPIO模块的函数了。如果你想检查模块是否引入成功，也可以这样写：
try：
importRPi.GPIOasGPIO
exceptRuntimeError：
print（“引入错误”）
针脚编号
在RPi.GPIO中，同时支持树莓派上的两种GPIO引脚编号。第一种编号是BOARD编号，这和树莓派电路板上的物理引脚编号相对应。使用这种编号的好处是，你的硬件将是一直可以使用的，不用担心树莓派的版本问题。因此，在电路板升级后，你不需要重写连接器或代码。
第二种编号是BCM规则，是更底层的工作方式，它和Broadcom的片上系统中信道编号相对应。在使用一个引脚时，你需要查找信道号和物理引脚编号之间的对应规则。对于不同的树莓派版本，编写的脚本文件也可能是无法通用的。
你可以使用下列代码（强制的）指定一种编号规则：
GPIO.setmode（GPIO.BOARD）
#or
GPIO.setmode（GPIO.BCM）
下面代码将返回被设置的编号规则
mode=GPIO.getmode（）
警告
如果RPi.GRIO检测到一个引脚已经被设置成了非默认值，那么你将看到一个警告信息。你可以通过下列代码禁用警告：
GPIO.setwarnings（False）
引脚设置
在使用一个引脚前，你需要设置这些引脚作为输入还是输出。配置一个引脚的代码如下：
#将引脚设置为输入模式
GPIO.setup（channel，GPIO.IN）
#将引脚设置为输出模式
GPIO.setup（channel，GPIO.OUT）
#为输出的引脚设置默认值
GPIO.setup（channel，GPIO.OUT，initial=GPIO.HIGH）
释放
一般来说，程序到达最后都需要释放资源，这个好习惯可以避免偶然损坏树莓派。释放脚本中的使用的引脚：
GPIO.cleanup（）
注意，GPIO.cleanup（）只会释放掉脚本中使用的GPIO引脚，并会清除设置的引脚编号规则。
将端口设置为输出的状态：
要想点亮一个LED灯，或者驱动某个设备，都需要给电流和电压他们，这个步骤也很简单，设置引脚的输出状态就可以了，代码如下：
GPIO.output（channel，state）
状态可以设置为0/GPIO.LOW/False/1/GPIO.HIGH/True。如果编码规则为，GPIO.BOARD，那么channel就是对应引脚的数字。
如果想一次性设置多个引脚，可使用下面的代码：
chan_list=［11，12］
GPIO.output（chan_list，GPIO.LOW）
GPIO.output（chan_list，（GPIO.HIGH，GPIO.LOW））
你还可以使用Input（）函数读取一个输出引脚的状态并将其作为输出值，例如：
GPIO.output（12，notGPIO.input（12））
读取
我们也常常需要读取引脚的输入状态，获取引脚输入状态如下代码：
GPIO.input（channel）
低电平返回0/GPIO.LOW/False，高电平返回1/GPIO.HIGH/True。
如果输入引脚处于悬空状态，引脚的值将是漂动的。换句话说，读取到的值是未知的，因为它并没有被连接到任何的信号上，直到按下一个按钮或开关。由于干扰的影响，输入的值可能会反复的变化。使用如下代码可以解决问题：
GPIO.setup（channel，GPIO.IN，pull_up_down=GPIO.PUD_UP）
#or
GPIO.setup（channel，GPIO.IN，pull_up_down=GPIO.PUD_DOWN）
需要注意的是，上面的读取代码只是获取当前一瞬间的引脚输入信号。
如果需要实时监控引脚的状态变化，可以有两种办法。最简单原始的方式是每隔一段时间检查输入的信号值，这种方式被称为轮询。如果你的程序读取的时机错误，则很可能会丢失输入信号。轮询是在循环中执行的，这种方式比较占用处理器资源。另一种响应GPIO输入的方式是使用中断（边缘检测），这里的边缘是指信号从高到低的变换（下降沿）或从低到高的变换（上升沿）。
轮询方式
whileGPIO.input（channel）==GPIO.LOW：
time.sleep（0.01）#wait10mstogiveCPUchancetodootherthings
边缘检测
边缘是指信号状态的改变，从低到高（上升沿）或从高到低（下降沿）。通常情况下，我们更关心于输入状态的该边而不是输入信号的值。这种状态的该边被称为事件。先介绍两个函数：
wait_for_edge（）函数。wait_for_edge（）被用于阻止程序的继续执行，直到检测到一个边沿。也就是说，上文中等待按钮按下的实例可以改写为：channel=GPIO.wait_for_edge（channel，GPIO_RISING，timeout=5000）
ifchannelisNone：
print（‘Timeoutoccurred’）
else：
print（‘Edgedetectedonchannel’，channel）
add_event_detect（）函数该函数对一个引脚进行监听，一旦引脚输入状态发生了改变，调用event_detected（）函数会返回true，如下代码：GPIO.add_event_detect（channel，GPIO.RISING）#addrisingedgedetectiononachannel
do_something（）
//下面的代码放在一个线程循环执行。
ifGPIO.event_detected（channel）：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3dcc4bea527c27fbec8c5b75cc8e75ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d464f37c8a25e4af15c0f47b72ad0385/" rel="bookmark">
			Fastdfs5.11部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统环境：
操作系统Centos 6.5
IP:172.30.8.5
Fasdfs_tracker1:172.30.8.5 storage1:172.30.8.5
1.安装依赖包,环境编译准备
[root@PLC104 app]# yum install git gcc gcc-c++ make automake autoconf libtool pcre pcre-devel zlib zlib-devel openssl-devel -y
2.在/app下新建tracker跟踪服务器数据（/fastdfs/tracker）和 storage存储服务器数据（/fastdfs/storage）目录
[root@PLC104 ~]# mkdir -p /app/fastdfs/tracker
[root@PLC104 ~]# mkdir -p /app/fastdfs/storage
#切换到安装目录准备下载安装包
[root@PLC104 app]# cd /usr/local/src/
[root@PLC104 src]# 4.安装libfastcommon
[root@PLC104 src]# git clone https://github.com/happyfish100/libfastcommon.git --depth 1
[root@PLC104 src]# git clone https://github.com/happyfish100/libfastcommon.git --depth 1
Initialized empty Git repository in /usr/local/src/libfastcommon/.git/
error: while accessing https://github.com/happyfish100/libfastcommon.git/info/refs
fatal: HTTP request failed 报错了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d464f37c8a25e4af15c0f47b72ad0385/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77456523dcedb548d79e2bd224b83ec2/" rel="bookmark">
			用Java代码生成0-100随机数，直到生成88为止，停止循环！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实操名称：生成0-100随机数，直到生成88为止，停止循环！
环境： jdk 1.8
作者：李远远
1.详细代码如下：
/** * 生成 0-100 随机数，直到生成 88 为止，停止循环！ * @author 李远远 * */ public class Test07 { public static void main(String[] args) { int total=0;//用于计数，循环的次数 System.out.println("start"); while(true) { total++;//循环一次，计数器加一 int i=(int)(100*Math.random());//随机生成0-100的数 if(i==88) { break; } } System.out.println("GameOver, round"+"\t" +total+" "+"times"); } } 2.运行图片如下，因为生成的是随机数，所以此处展示三张运行结果图：
3.Bug及心得体会：
生成随机数时前面定义的i值为int型，但是没有将后面等式强制转换为int，导致输出的不是整数。
这次代码的敲写，主要是为了能熟练掌握break的用法以及，生成随机数的表达方式，如果不强制转换为int型，生成的就不是整数。break用于强行退出循环，不执行循环中剩余语句。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7589b6dab8e2a2f8c15c0952944f0ff4/" rel="bookmark">
			Weex项目集成Android 以及打包成app
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 创建一个weex项目 创建weex项目参考：https://blog.csdn.net/qq_39705793/article/details/83001145
2. 集成的Android项目 你创建完了一个新的weex项目，你的目录结构下的平台下的文件夹下只有一个platforms.json。
进入项目根目录下执行weex platform add android
---- 执行weex平台添加android 命令会在平台目录下创建一个android 的目录
3. 生成JKS 3.1命令的方式：keytool -genkeypair -alias icesslkey -keyalg RSA -validity 3650 -keystore icekeystore.jks
3.2用android studio生成jks
用android studio打开你的项目，不是weex项目，是android项目。点击Build ---&gt; analyze APK 存放apk的位置以及apk的名字。Build ---&gt; Generate Signed APK 创建一个新的jks
填写相关信息，将签名文件jks保存到WEEX项目中的release目录下。
4. weex打包成js cmd到自己的项目下 输入命令 ： npm run build
5. 打包成为签名的apk cmd到自己的项目下 输入命令 ： npm run pack:android
6. 签名 未签名的apk在你的项目下\release\android cmd到这个目录输入命令：
jarsigner -verbose -keystore awesome.jks -signedjar meeting.apk app-release-unsigned.apk awesome
eg: 分别是你的jks名字 以及apk的名字
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7589b6dab8e2a2f8c15c0952944f0ff4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d8d47d33313aab7c9fe540fba08be5d/" rel="bookmark">
			flink安装以及运行自带wordcount示例（单机版，无hadoop环境）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、下载安装包到/opt目录
2、解压安装包
tar zxf flink-1.6.1-bin-hadoop26-scala_2.11.tgz 3、启动flink
cd /opt/flink-1.6.1/bin [root@localhost bin]# ./start-cluster.sh Starting cluster. Starting standalonesession daemon on host localhost.localdomain. Starting taskexecutor daemon on host localhost.localdomain. 此时可以打开浏览器在8081端口查看flink的web
运行wordcount示例
1、在控制台窗口1中启动一个本地服务
nc -l -p 9000
2、在控制台窗口2中提交flink程序
bin/flink run examples/streaming/SocketWindowWordCount.jar --hostname localhost Starting execution of program
说明：该程序每隔5秒统计一次接收的数据中的单词个数
3、在控制台窗口3中打开out日志文件
log目录下的out文件会统计flink的执行结果。
cd /opt/flink-1.6.1/log
tail -f flink-root-taskexecutor-0-localhost.localdomain.out
out文件更新后会控制台中会自动显示新增的数据。
4、在控制台1中输入语句，在控制台3中查看统计结果，如下图所示：
5、在flink的web中查看运行的job
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f49f8c43812e65983c3e67149ab7040/" rel="bookmark">
			AttributeError: &#39;NoneType&#39; object has no attribute……错误分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NoneType errors 是opencv以及python中常见的一种错误类型，而且一旦出现，对于新手来说较难debug，下面简要分析一下错误的原因并给出解决方法。
原因一 这种原因是出现频率最高的一种——
cv2.imread的文件路径错误，比如：
①路径不存在；
②路径错误，不是指向图片所在位置的路径；
③路径中包含中文字符，如汉字以及【】等中文字符；
解决方法：仔细检查自己的文件路径！不要自作聪明乱加中文字符！(即使【】可以使文件夹置顶方便查找)
原因二 读取的图片使不合法的，比如要求读入.png格式而实际读入.jpg格式
解决方法：仔细检查图片的后缀，并将不合法的图片删除或者更改格式
原因三 opencv没有配置好或版本不对
解决方法：在确信自己的路径以及图片没有问题的前提下，在conda list中查看opencv版本，如不对，则升级或降级到对应版本，若正确，尝试重装opencv…………
祝各位好运……
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd065254b681c7d16737ca48b19810ef/" rel="bookmark">
			SpringMVC(4) 文件上传和下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击下载项目资源 密码：1k9z
前端页面：
上传文件注意事项：①post提交数据
②form表单 --&gt; enctype属性为：multipart/form-data
③使用上传文件的file标签
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;文件上传&lt;/h1&gt; &lt;form action="/zq/upload" method="post" enctype="multipart/form-data" &gt; 用户名：&lt;input type="text" name="username" &gt;&lt;br/&gt; 文件上传：&lt;input type="file" name="image" &gt;&lt;br/&gt; &lt;input type="submit" &gt;&lt;br/&gt; &lt;/form&gt; &lt;h1&gt;文件下载&lt;/h1&gt; &lt;a href="/zq/download?filename=1.jpg"&gt;下载&lt;/a&gt; &lt;a href="/zq/download2?filename=1.jpg"&gt;下载2&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; 上传文件功能类：
/** * 上传文件： * 使用MultipartFile类型接收前台上传的文件数据 * 接收数据时要指定接收方式--&gt;RequestMethod.POST * @author 郑清 */ @Controller public class UploadController { @RequestMapping(value="/upload",method=RequestMethod.POST) @ResponseBody //不写会默认返回当前路径！！ public void upload(String username,MultipartFile image,HttpServletRequest req) throws Exception, IOException{ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd065254b681c7d16737ca48b19810ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1bdef4ea0efa51c8efebffe84a5fc8c/" rel="bookmark">
			ffmpeg 判断关键帧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当mp4的profile为high的时候，avpacket==1并不能判断是否是关键帧，很多不是的也被误判断成关键帧了，具体做法应该是，进一步判断字节：
int is_keyframe_h264(AVPacket* pkt) {
// printf("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
// pkt-&gt;data[0], pkt-&gt;data[1], pkt-&gt;data[2], pkt-&gt;data[3], pkt-&gt;data[4],
// pkt-&gt;data[5], pkt-&gt;data[6], pkt-&gt;data[7], pkt-&gt;data[8], pkt-&gt;data[9]);
int length = 0;
unsigned char* p_buffer = pkt-&gt;data;
int i_buffer = pkt-&gt;size;
if ( (pkt-&gt;data[0] == 0 &amp;&amp; pkt-&gt;data[1] == 0 &amp;&amp; pkt-&gt;data[2] == 0 &amp;&amp; pkt-&gt;data[3] == 1) ||
(pkt-&gt;data[0] == 0 &amp;&amp; pkt-&gt;data[1] == 0 &amp;&amp; pkt-&gt;data[2] == 1) ) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1bdef4ea0efa51c8efebffe84a5fc8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59c6cdf117b11dac1f88602e7feea4fc/" rel="bookmark">
			Lua之Table
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		table：
table 是一个“关联数组”，数组的索引可以是数字或者是字符串
table 的默认初始索引一般以 1 开始
table 不会固定长度大小，有新数据插入时长度会自动增长
table 所有元素之间，总是用逗号 “，” 隔开
table.insert
table.insert将一个元素插入到指定位置
t={1,2,3,4} table.insert( t, 1,2 ) for i=1,#t do print(t[i]) end ta={} table.insert( ta, "a" ) table.insert( ta, 2 ) table.insert( ta, "c" ) for k,v in pairs(ta) do print(k,v) end insert的第二个参数是可以省略的，这样就会插入到数组的最后，从而不必移动其他元素
table.sort() 对数组进行排序,如果没有提供排序函数，默认是&lt;操作。这里不仅仅是数，对字符串也有效
t={1,4,3,5} table.sort( t) for i=1,#t do print(t[i]) end ta={"ab","zfd","fgv","bcc"} table.sort( ta) for k,v in ipairs(ta) do print(k,v) end 报错例子
table.sort是排序函数，它要求要排序的目标table的必须是从1到n连续的，即中间不能有nil
ta={"ab","zfd",2,"fgv","bcc"} table.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59c6cdf117b11dac1f88602e7feea4fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dbdcffb4767eb612723b72b5f1067d4/" rel="bookmark">
			feign.codec.EncodeException: class ArrayList/HashMap is not a type supported by this encoder
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Storm中使用Fegin，因为Storm是通过拓扑自己创建和管理Bolt的，所以在Bolt中使用到了某个FeignClient就无法通过@Service，然后通过@Autowired获取到FeginClient的实例。
使用下面的代码来实例化FeginClient，
/** * 初始化SanService的FeginClient * @param url * @return */ public static SanService initializeSanServiceFegin(String url) { SanService service = Feign.builder() .contract(new SpringMvcContract()) .target(SanService.class, url); return service; } 但会报下面的错误异常：
feign.codec.EncodeException: class is not a type supported by this encoder
因为默认的Encoder不支持List或Map，所以报错。
如果自定义Encoder，则必须要用到Feign 依赖包中其他的类，而且需要通过@Autowired依赖注入其他类，但上面提到了，Storm中无法通过@Autowired依赖注入。
终极解决办法：
/** * 初始化SanService的FeginClient * @param url * @return */ public static SanService initializeSanServiceFegin(String url) { HttpMessageConverter jsonConverter = new MappingJackson2HttpMessageConverter(new ObjectMapper()); ObjectFactory&lt;HttpMessageConverters&gt; converter = ()-&gt; new HttpMessageConverters(jsonConverter); SanService service = Feign.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2dbdcffb4767eb612723b72b5f1067d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b272ab90c47cde8dc54dff3baad83de0/" rel="bookmark">
			MyBatis自动生成实体类、映射、Dao接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、在web.xml配置,加入以下代码(加在&lt;plugins&gt;&lt;plugins/&gt;标签中) &lt;plugin&gt;
&lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;
&lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;
&lt;version&gt;1.3.5&lt;/version&gt;
&lt;configuration&gt;
&lt;!--配置文件的位置--&gt;
&lt;overwrite&gt;true&lt;/overwrite&gt;
&lt;verbose&gt;true&lt;/verbose&gt;
&lt;/configuration&gt;
&lt;/plugin&gt;
2、在resources下创建generatorConfig.xml(自动生成实体类的配置文件) &lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE generatorConfiguration
PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"
"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;
&lt;generatorConfiguration&gt;
&lt;classPathEntry location="Maven中央仓库MySQL依赖中jar包的位置"/&gt;
&lt;context id="context1" targetRuntime="项目名"&gt;
&lt;commentGenerator&gt;
&lt;property name="suppressAllComments" value="true"/&gt;
&lt;/commentGenerator&gt;
&lt;!-- 数据库链接URL、用户名、密码 --&gt;
&lt;!--&lt;jdbcConnection driverClass="com.mysql.jdbc.Driver" connectionURL="jdbc:mysql://localhost:3306/blog"
userId="root" password="root"&gt; --&gt;
&lt;jdbcConnection driverClass="com.mysql.jdbc.Driver"
connectionURL="jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true" userId="数据库用户名"
password="数据库密码"&gt;
&lt;/jdbcConnection&gt;
&lt;!-- 生成模型的包名和位置 --&gt;
&lt;javaModelGenerator targetPackage="实体类包的全路径名"
targetProject="src/main/java"&gt;
&lt;!--&lt;property name="enableSubPackages" value="true"/&gt;--&gt;
&lt;!--&lt;property name="trimStrings" value="true"/&gt;--&gt;
&lt;/javaModelGenerator&gt;
&lt;!-- 生成的映射文件包名和位置 --&gt;
&lt;sqlMapGenerator targetPackage="映射包的全路径名"
targetProject="src/main/java"&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b272ab90c47cde8dc54dff3baad83de0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/657f6db1e235baef9a3929530698a914/" rel="bookmark">
			java异常：Comparison method violates its general contract!解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目在线上运行时突然出现了几百封异常邮件，过了一段时间又自动好了。
项目异常报错信息是
Comparison method violates its general contract
在顺着堆栈信息查找下去，发现是sort排序中重写compare方法引发的异常。
在网上查找资料和阅读了sort的源码之后得出结论：
在sort排序中重写的方法一定要满足:可逆比较
Comparator&lt;Integer&gt; c = (o1, o2) -&gt; { if (o1 &gt; o2) { return 1; } else { return -1; } }; 如上面的比较器就没有满足可逆性，当o1和o2相等时，o1和o2比较，返回-1，表示o1小于o2；但是当这两个元素交换位置时，o2比o1，结果返回还是-1，表示o2小于o1。这样就有两个元素互换比较，o1&lt;o2并且o2&lt;o1这两个结果相互矛盾，在某些情况下会出现异常。
解决方法 想要真正解决这个问题，并不是像很多网上帖子上所说加个等于条件就可以，这个是因为逆比较引发的问题，就应该从根源上解决这个问题：
让compare方法在逆比较时不会出现矛盾即可，
至于是加等于情况，还是有更复杂的情况取决于自己的业务。
想要具体了解这个bug是如何引发的可以看下java的TimSort排序：TimSort排序解析
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1cecf79022e70c77fe99ac9baf6a5b9/" rel="bookmark">
			ES6 set和map用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、set
类似数组但是成员值是唯一的不重复的
初始化时可以用数组进行初始化
var set = new Set([1, 2, 3, 4, 4]); [...set] // [1, 2, 3, 4] var s = new Set(); [2,3,2,2].map(x=&gt;s.add(x)); for (let i of s) { console.log(i); } // 2 3 在Set内部，两个NaN是相等。两个对象总是不相等的。
set提供4个方法：
1：add(v)：添加某个值，返回Set结构本身。
2：delete(v)：删除某个值，返回一个布尔值，表示删除是否成功。
3：has(v)：返回一个布尔值，表示该值是否为Set的成员。
4：clear()：清除所有成员，没有返回值
可以使用for of遍历
二、map
Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。
var m = new Map(); var o = {p: "Hello World"}; m.set(o, "content") m.get(o) // "content" m.has(o) // true m.delete(o) // true m.has(o) // false 注意，只有对同一个对象的引用，Map结构才将其视为同一个键
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1cecf79022e70c77fe99ac9baf6a5b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7607d5416a018658decc0f16f63d4e7f/" rel="bookmark">
			nodejs 控制台输入判断
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、利用stdout和stdin做控制台判断
nodejs 的process模块提供了进程的输入输出方法
process.on('exit', function(code) { console.log(code) }); process.stdin.setEncoding('utf8'); process.stdout.write("......\n"); process.stdout.write("确认执行吗(y/n)？"); process.stdin.on('data',(input)=&gt;{ input = input.toString().trim(); if (['Y', 'y', 'YES', 'yes'].indexOf(input) &gt; -1) Todo something; if (['N', 'n', 'NO', 'no'].indexOf(input) &gt; -1) process.exit(0); }) 二、process
process对象是一个全局对象，可以通过它对node程序的进程进行访问和控制
通过exit可以退出process进程
通过on可以监听进程操作
process.exit(0) 表示成功退出，回调函数中err为null
process.exit(!0) 表示异常退出，回调函数中err不为null，err.code为传入值
node 的Readline模块也可以实现相同的功能。具体实现请参考：https://nodejs.org/api/readline.html
更多关于process的使用参考：
https://nodejs.org/api/process.html#process_process_stdin
https://www.cnblogs.com/xiaohuochai/p/6926080.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecd844db151e5046efccdff3dae6c531/" rel="bookmark">
			java sort排序源码分析（TimSort排序）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		入口：
default void sort(Comparator&lt;? super E&gt; c) { Object[] a = this.toArray(); Arrays.sort(a, (Comparator) c); ListIterator&lt;E&gt; i = this.listIterator(); for (Object e : a) { i.next(); i.set((E) e); } } java排序方法调用的Arrays.sort ，传入两个参数，数据数组和comparator对象 public static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c) { if (c == null) { sort(a); } else { if (LegacyMergeSort.userRequested) legacyMergeSort(a, c); else TimSort.sort(a, 0, a.length, c, null, 0, 0); } } 在sort方法中，有两种排序算法，传统排序，和TimSort
LegacyMergeSort.userRequested是使用jdk5的传统排序方法。
TimSort是改进后的归并排序，对归并排序在已经反向排好序的输入时表现为O(n^2)的特点做了特别优化。对已经正向排好序的输入减少回溯。对两种情况（一会升序，一会降序）的输入处理比较好（摘自百度百科）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecd844db151e5046efccdff3dae6c531/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f5c63df6bade681b8ff336fece497bd/" rel="bookmark">
			记录python multiprocessing Pool的map和apply_async方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		遇到的问题 在学习python多进程时，进程上运行的方法接收多个参数和多个结果时遇到了问题，现在经过学习在这里总结一下
Pool.map()多参数任务 在给map方法传入带多个参数的方法不能达到预期的效果，像下面这样
def job(x ,y): return x * y if __name__ == "__main__": pool = multiprocessing.Pool() res = pool.map(job, 2, 3) print res 所以只能通过对有多个参数的方法进行封装，在进程中运行封装后的方法如下
def job(x ,y): return x * y def job1(z): return job(z[0], z[1]) if __name__ == "__main__": pool = multiprocessing.Pool() res = pool.map(job1, [(2, 3), (3, 4)]) print res 这样就能达到传递多个参数的效果
ps：如果需要得到多个结果可以传入多个元组在一个列表中
Pool.apply_async()输出多个迭代结果 在使用apply_async()方法接收多个参数的方法时，在任务方法中正常定义多个参数，参数以元组形式传入即可
但是给apply_async()方法传入多个值获取多个迭代结果时就会报错，因为该方法只能接收一个值，所以可以将该方法放入一个列表生成式中，如下
def job(x): return x * x if __name__ == "__main__": pool multiprocessing.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f5c63df6bade681b8ff336fece497bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eba503aa1c17c0cdecdb76ed163406b2/" rel="bookmark">
			setTimeout在vue中的正确使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔者最近因为公司需求开发使用vue和jquery开发抓娃娃H5极简小游戏，使用到setTimeout函数。遇到了1个坑:
在vue的某个方法(点击后执行) setTimeout(this.end(),4000);//娃娃消失 这里奇怪的是,end方法的确被执行了。但是没有执行4s后执行的效果。那我要你合用呢！其实，问题还是出在笔者身上，大家请看下图
setTimeout的定义和用法。问题出在我的格式上面
其实是支持两种调用方式：1 字符 2 函数体（文章解决方式）
解决方法如下：
1、定义一个_this暂存this
2、再改变变量的值，则生效啦
3、方法中将this存在变量_this中，此时执行setTimeout函数时，setTimeout函数内的_this就会访问到这个变量，就会得到当前对象。
export default { methods: { start: function () { let _this=this setTimeout(function() { _this.end()//娃娃消失 }, 4000); } } } 注意⚠️:
当在vue中使用定时器在function里直接使用this，发现没有效果，这是由于setTimeout函数调用的代码运行在与所在函数完全分离的执行环境上，这会使得this指向的是window对象。拓展知识：解决vue在setTimeout内修改this失效的问题
要想setTimeout指向正确的值，可以使用如下方法：
1、使用箭头函数
export default { methods: { start: function () { setTimeout(() =&gt; { this.end()//娃娃消失 }, 4000); } } } 此时函数的this指向的是定义它的时候的对象，也就是this指向了data内中对应的变量。
码字不易，对大家有用最佳
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1764a9b8b545ebc590c472a16d2c6dab/" rel="bookmark">
			系统安全概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统安全概述 系统安全概述 Linux 系统安全概述 内核简介OpenSSH安全配置Shell安全权限管理和控制iptables（防火墙）配置常用安全策略 Window安全综述 端口安全 修改默认端口 如何修改远程桌面默认端口 账户安全 修改默认用户名，设置复杂密码删除多余用户启用密码策略 Android系统安全 系统安全机制 Android进程沙箱隔离机制应用程序签名机制权限声明机制进程通讯机制内存管理机制 Root Root的作用及危害Root原理Root思路 主要简单介绍Linux，Windows，Android以及软件系统的安全，了解常见的系统安全常识，会进行简单的安全配置，对各类的系统安全有一个了解。
Linux 系统安全概述 Linux操作系统诞生于1991年，它是UNIX的一种典型的克隆系统。它是一个基于POSIX和UNIX的多用户，多任务，支持多线程和多CPU的操作系统，同时Linux也继承了UNIX以网络为核心的设计思想，也是一个性能稳定的多用户网络操作系统。
开源，开放，免费是Linux的魅力所在。Linux还具有良好的可移植性，Linux编译后可以在大量处理器和具有不同体系结构约束和需求的平台上运行。经过20年的发展，Linux操作系统成为在服务器，嵌入式系统和个人计算机等多个方面得到广泛应用的操作系统。
内核简介 内核指的是一个提供硬件抽象层，磁盘文件及文件系统控制，多任务等功能的系统软件。一个内核并不似一个完整的操作系统。一套基于Linux内核的完整操作系统叫做Linux操作系统，或者是GNU/Linux。设备驱动程序可以完全访问硬件。Linux内的设备驱动可以方便的以模块化的形式设置，并在系统运行期间直接装载或卸载。
Linux是一个一体化内核系统。
Linux内核编号方式为: 主版本号.次版本号.修订版本号
常用内核命令
查看内核信息：uname -a
查看已加载模块：lsmod
加载内核模块：insmod filename
删除内核模块：rmmod filename
OpenSSH安全配置 OpenSSH是SSH协议的免费开源实现。SSH协议族可以用来进行远程控制，或在计算机之间传文件。而实现该功能的传统方式，如Telnet（终端仿真协议），rcpftp，rsh都是极不安全的，并且会使用明文传送密码。OpenSSH提供了服务端后台程序和客户端工具，用来加密远程控件和文件传输中的数据，并由此来替代原来的类似服务。OpenSSH是使用SSH透过计算机网络加密通讯的实现。
Linux中的SSH服务可以通过/etc/ssh/sshd_config文件进行配置
常用配置命令
禁止root用户登录： #Authentication：
LoginGraceTime 120
PermitRootLogin no
StrictModes yes
限制SSH验证次数： MaxAuthTries 6
禁止证书登录 PubkeyAuthenticationno
使用证书认证代替密码认证 PasswordAuthenticationno
禁止使用客户端的密码记忆功能 ChallengeResponseAuthentication yes
禁止SSH端口映射 AllowTcpForwarding no
IP地址限制 可以通过对/etc/host.allow修改来设置允许登录的IP地址
sshd:&lt;IP地址&gt; &lt;IP地址&gt;
通过修改/etc/hosts.deny来设置禁止访问的IP地址
sshd:&lt;IPd地址&gt;
Shell安全 Shell（壳层）在计算机科学中是指“提供用户使用界面”的软件，通常指的是命令行界面的解释器。一般来说，Shell是指操作系统中，提供访问内核所提供的服务的程序。
常用配置命令
记录系统管理员的操作记录 (1)以root用户登录，在/etc/profile.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1764a9b8b545ebc590c472a16d2c6dab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd81637862519401ccebaa19ac096f6e/" rel="bookmark">
			软件开发工具的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件开发不是工程更多的像是一门艺术；不但靠逻辑更需要靠直觉；
软件开发中辅助设计的工具只是一个工具，不要为了工具而去用工具，发挥工具的好处，吸收使用多个工具，不生搬硬套。
认识到每个工具都有其局限性，因为每个工具只是表述软件设计或者开发中的一个状态，其是一个静态的镜像，其不能真实的反馈整个软件全貌。
工具只是辅助我们思考、设计和描述，而不要把工具用成一种负担；灵活使用工具，天马行空的使用工具，而不仅仅局限裕工具的特定作用域，只要能表达你思想。不要让工具变成思考的桎梏，表现的枷锁，那就没有使用工具意义。
失控的向导，向导是侵入式的编程，不了解软件的框架的情况下使用向导是灾难性的，因为它是你对你的工程失去控制。
IDC工具也是一样，所有的向导和IDE工具只是再帮我们做我们非常熟悉的重复性的工作，帮我提升效率，而不是帮我们思考、架构和设计，让其做帮我们做我们根本不了解的事情。
总结一句话： 失控的向导，邪恶的IDE
新手靠规则，专家靠直觉
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfb568ecdb9d1f01d4ae80d829c2a4db/" rel="bookmark">
			sublime Text3 编译运行java
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、环境准备 Windows10
jdk-11.0.1
二、下载并安装JDK 到Java的官网下载JDK安装包，地址：http://www.oracle.com/technetwork/java/javase/downloads/index.html，选择一个适合自己的JDK版本下载并安装。
三、环境变量配置 1、右键桌面上“我的电脑”&gt;&gt;“属性”，在弹出的页面上点击“高级系统设置”。
进入编辑
添加安装的jdk路径
在配置好环境变量后，可以进入cmd中检查Java是否安装正确，检查的命令为 javac，如图所示：
安装成功
四.在sublime text 3中运行Java文件 在sublime安装目录找到Java.sublime-package文件。
2.双击文件,选择使用WinRAR或者其他解压软件打开Java.sublime-package,不要解压
3.找到JavaC.sublime-build文件并且使用Sublime Text 3 打开修改里面的内容为
{ "shell_cmd": "javac \"$file\" &amp;&amp; java \"$file_base_name\"", "file_regex": "^(...*?):([0-9]*):?([0-9]*)", "selector": "source.java" } 然后ctrl+s 保存后关闭sublime WinRAR会提示是否保存修改的文件到压缩文件，选是(上一步没有关闭sublime会提示文件占用无法保存更改)
用sublime Text3打开java文件测试
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7486e1e0e7564ea45a63f047cfd16b57/" rel="bookmark">
			STM32-(SysTick定时器,EXTI外部中断/事件控制器)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Systick系统定时器 介绍：systick定时器上属于CM3内核中的一个外设，内嵌在NVIC中。系统定时器是一个24位向下计数的计数器，计数器每一次计数的时间是1/SYSTICK，一般我们设置SYSTICK为72M。当重载数值寄存器的值递减到0时，系统定时器产生一次中断，以此循环。
使用范围：1.一般用于操作系统，用于产生时基，维持操作系统的心跳。
使用的寄存器：CTRL,LOAD,VAL,CALIB;
例程1：利用systick产生1s的时基。 步骤：
1.设置重载寄存器的值
2.清除当前数值寄存器的值
3.配置控制于状态寄存器
systick配置库函数：
_STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks) { //不可能的重装载值，超出范围 if((ticks - 1UL)&gt;SysTick_LOAD_RELOAD_Msk){ return (1UL); } //设置重装载寄存器 SysTick-&gt;LOAD = (uint32_t)(tiicks - 1UL); //设置中断优先级 NVIC_SetPriority(SysTick_IRQn,(1UL&lt;&lt;NVIC_PRIO_BITS)-1UL); //设置当前数值寄存器 SysTick-&gt;VAL = OUL; //设置系统定时时钟源为AHBCLK=72M //使能系统定时器中断 //使能定时器 SysTick-&gt;CTRL = SysTIck_CTRL_CLKSOURCE_Msk | SysTick_CTRL_TICKINT_Msk | SysTick_CTRL_ENABLE_Msk; return (OUL); } 用固件库编程的时候我们只需要调用库函数SysTick_Config()即可，形参ticks用来设置重装载寄存器的值，最大不能超过重装载寄存器的值2^24,当重载寄存器的值递减到0的时候产生中断，然后重载寄存器的值又重新装载往下计数，以此循环。
设置中断优先级：
void NVIC_SetPriority(IRQn_Type IRQn,uin32_t priority) { if((int32_t) IRQ&lt;0){ SCB-&gt;SHP[(((uint32_t)(int32_t))IRQn)&amp;0XFUL)-4UL] = (uint8_t)((priority&lt;&lt;(8-_NVIC_PRIO_BITS)) &amp;(uint32_t)0xffUL); } } 使用：NVIC_SetPriority(Systick_IRQn,(1UL&lt;&lt;_NVIC_PRIO_BITS)-1UL); 配置系统定时器的时钟（AHBCLK）为72M：
SysTick初始化函数：
void SysTick__Init(void) { /*systickFrequency / 1000 1ms中断一次*/ /*systickFrequency / 100000 10us中断一次*/ /*systickFrequency / 1000000 1us中断一次*/ if(SysTick_Config(SystemCoreClock / 100000)){ while(1); } } 这个函数决定了多长时间产生一次中断。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7486e1e0e7564ea45a63f047cfd16b57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/895ea0be3c3c751957e78bd0e7671c6c/" rel="bookmark">
			url重定向,vue路由重定向,vue路由守卫
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 什么是重定向
重定向（Redirect）就是通过各种方法将各种网络请求重新定个方向转到其他位置。
二 为什么用重定向
举一个例子:
用户注册完账号后,此时用户点击注册后,那么页面应该跳到登录页面,登录成功后返回到首页.用户在商品页面,要购买商品服务器发现用户没登录,浏览器此时跳到登录页面,登录成功后返回到商品页面.用户在个人中心,要修改密码服务器发现用户没登录,浏览器此时跳到登录页面,登录成功后返回到个人中心页面. 上面的例子意思就是,只要服务器发现用户没有登录,都会响应到登录页面,问题是当用户登录后我页面应该跳向何处?这里就要用到url重定向技术.
三 实现重定向
我们在发送请求的路径后面但是参数,因为添加参数后不会改变你请求的网页地址.
比如:你请求是本地5000端口下的login.html网页,现在你给这个网页地址带上参数id=123,这个新的url路径发给服务器后,服务器还是会返回login.html网页给浏览器,只不过服务器会拿到你带过去的参数.
// 没有带参数 127.0.0.1:5000/login.html //带上参数 127.0.0.1:5000/login.html?id=123 所以,现在我们给所有要跳转到login.html的网页后面都带上一个参数,而这个参数就是当前网页的url地址.
比如:
3.1 从其他页面到登录页面
//1. 从商品页面跳转到登录页面 location.href = "login.html?redirectUrl=shop.html?id="+productID //2. 从个人中心到登录页面 location.href = 'login.html?redirectUrl=user.html' 上面应该注意到的是从商品页面跳转到登录页面里面的redirectUrl(重定向url)的值是shop.html?id="+productID,这个路径里面又带有一个参数这并不会影响到时候重新跳向shop.html这个页面.
3.2 登录页面的响应
if(status = '登录成功') { //页面跳回原来的页面 location.href = getQueryString('redirectUrl'); }else { //登录失败 // do something ..... } //获取url中的参数值,name 是传入的参数值 function getQueryString (name) { var reg = new RegExp("(^|&amp;)" + name + "=([^&amp;]*)(&amp;|$)", "i"); var r = window.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/895ea0be3c3c751957e78bd0e7671c6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f7ccf0d1bbf3f1ae050dd09fb0fbb80/" rel="bookmark">
			Qt添加菜单栏和工具栏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qt添加菜单栏和工具栏 版本说明 版本作者时间备注0.1loon2018.10.24初稿 目录 文章目录 Qt添加菜单栏和工具栏版本说明目录一、需求与目的二、详细说明三、最后 一、需求与目的 一般常规的PC软件都会有主窗口，主窗口中都会有菜单栏和工具栏，例如我们正在使用的Qt creator：
所以，工具栏和菜单栏的制作方法也是必须掌握的。
二、详细说明 首先需要先创建mainWindow设计师类，基类直接选择默认的MainWindow即可，然后就可以进行设计了，这里选择直接设计ui文件，下拉菜单无法直接输入中文，需要在其它地方输入中文后拷贝过来：
之后可以在Action Editor中找到菜单栏的动作选项：
可以看到这里可以设置对应动作的快捷键（不设置则使用默认的快捷键，如CTRL+C表示复制等），双击可以设置图标、对象名等信息：
右键单击可以找到转到槽，进行槽函数处理：
拖动到mainWindow菜单栏下方则成为工具栏的一部分，如果没有工具栏则右键窗口添加工具栏即可：
右键工具栏则可以添加分隔符，对于下拉菜单同理：
三、最后 当然，通过写代码的方式也可以添加工具栏和菜单栏，但显然没有这样来的直观和简单。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b45ffb7d1e9c71d28d3fa9650dbd1ac2/" rel="bookmark">
			pgsql使用积累系列_pg数据库定时任务配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 安装postgresql(10.1) 参考链接：postgresql10安装
2. 安装服务端pgadmin4 在postgresql10版本中 pgadmin4 yum源已经包含在postgresql数据库安装的yum源中，不需要再另行处理
直接安装
yum -y install pgadmin4
3. 安装postgresql(10.1)对应版本的插件安装yum源 yum -y install postgresql10-contrib.x86_64
4. 安装pgagent yum -y install pgagent_10.x86_64
5. 指定数据库安装pgagent插件 su postgres
psql -h 127.0.0.1 -p 5434 -U admin -d schedule_test
create extension pgagent;
\dx --查看插件是否已安装
\q --退出
6. 启动agent代理 mkdir -p /data/log/pgagent/
pgagent_10 -s /data/log/pgagent/agent.log -l host=127.0.0.1 port=5434 dbname=schedule_test user=admin password=123456 &amp;
7. 下载客户端pgadmin4 下载链接：pgadmin4客户端下载（windows） 安装略。
8. 在pgadmin里配置定时任务 新建测试表及测试及测试函数 CREATE TABLE "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b45ffb7d1e9c71d28d3fa9650dbd1ac2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aede3d9822bbf754463bb1e4446ecea1/" rel="bookmark">
			Intel RealSense D435介绍、安装和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验室采购的三个Intel RealSense相机到了，分别是D435、R200和blasterx senz3d，都试了一下，除了适用的最佳距离范围不同，其它功能大致相同，用SDK的话会有一点差别。本篇是关于D435的使用笔记。
一、产品介绍 1、产品全称 Intel RealSense Depth Camera D435
2、实物图 3、相机介绍 参考博客
2018年1月19日，英特尔宣布更新RealSense深度摄像头产品线，带来两款全新的产品：D415和D435，现在已经开始接受预定。按照英特尔的说法，新型深度摄像头非常适合硬件原型设计者和软件开发者，设备采用了即用型USB供电形式，并且搭载了D400系列深度模块，具备完整光学深度解决方案。
RealSense D415提供卷帘快门感应器和窄视野的小镜头。英特尔表示，D415搭载D410深度传感器，狭窄视野提供了高深度分辨率，这是“精确测量的理想选择”。
RealSense D435提供全局快门感应器和更大的镜头，以获得比便宜的D415相机更好的低光照性能。D435还具有更强大的RealSense模块D430。
英特尔表示，D435相机是“机器人导航和物体识别等应用的首选解决方案”。这两款RealSense D400系列摄像机的捕捉最远距离可以达到10米，而且新款在户外阳光下也可以使用，均支持输出1280x720分辨率的深度画面，更普通的视频传输方面可以达到90fps。
D435相机正面有四个圆孔，如下图所示，从左向右，第一和第三个是红外传感器（IR Stereo Cameral）；第二个是红外激光发射器（IR Projector），第四个是彩色相机（色彩传感器）。
二、安装和使用 可视化界面（Intel RealSense Viewer）的安装以及SDK的安装可以参照官方指南。改SDK会附带安装可视化界面Viewer、Examples和Depth Quality Tool。
官方指南
官方GitHub给出的SDK包含以下几个部分，作用分别如下：
1、Intel RealSense Viewer 对应的安装包是Intel.RealSense.Viewer.exe。
也可以安装Intel.RealSense.SDK.exe，会自动安装这个。不需要做开发使用的话只需安装Intel.RealSense.Viewer.exe即可。
即可视化界面，用于使相机接入电脑。安装后双击exe文件，如果连接成功，可看到如下界面，用户可以查看深度图、可视化点云、记录和回放视频，还可以配置摄像头设置、修改高级控件和后期处理等功能。
2、Intel RealSense SDK 对应的安装包是Intel.RealSense.SDK.exe。
满足开发需要。
该SDK还包含了以下两种功能：
2.1 Debug Tools 包含在Intel.RealSense.SDK.exe中，可以在tools目录中看到设备枚举，FW记录器等。
2.2 Code Samples 包含在Intel.RealSense.SDK.exe中，提供一些示例程序，将摄像头应用到程序中。可以自己跑一遍看看效果。
3、Depth Quality Tool 对应的安装包是Depth.Quality.Tool.exe。
使用该应用可以测试相机的深度质量，包括：平面拟合的标准偏差，标准化RMS - 亚像素精度，距离精度和填充率。可以获取多个深度质量指标，并记录和保存数据以供离线分析。
4、Wrappers Python，C＃/ .NET，Node.js API，以及与以下第三方技术的集成：ROS，LabVIEW，OpenCV，PCL，Unity，Matlab等等，包括OpenNI。
另外，相机支持以下几种系统，看到支持Mac OS还是很开心的，但是仅支持SDK的部分功能，个人觉得可能有些功能也不太稳定。本次使用Win10来做以下工作。
三、应用 使用基于opencv扩展示例程序实现物体检测（rs-dnn），按照官方指南配置环境，安装librealsense，编译完librealsense之后运行rs-dnn报错，目前还没找到原因。
搭建python3开发环境并显示彩色图和深度图 安装Intel.RealSense.SDK.exe后，在安装目录…/Intel RealSense SDK 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aede3d9822bbf754463bb1e4446ecea1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9be40a4902aee1c159edf86e08e8f72/" rel="bookmark">
			【Python】Windows系统安装uWSGI报错AttributeError: module &#39;os&#39; has no attribute &#39;uname&#39;解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用pip安装 pip install uwsgi
报错:AttributeError: module 'os' has no attribute 'uname'
报错说明：
是因为uwsgiconfig.py文件中，os.uname()是不支持windows系统的，platform模块是支持任何系统。
下载uwsgi离线安装 https://pypi.python.org/pypi/uWSGI/ 解压后,进入目录下，修改uwsgiconfig.py文件中的os.uname()为platform.uname()
然后再cd进入目录执行：python setup.py install
报错:Exception: you need a C compiler to builduWSGI
报错说明：需要安装C语言编译环境
如果本机上没有C编译环境,需要下载一个编译器
推荐下载：MinGW
安装好之后配置环境变量：path=MinGW安装目录/bin
3.再次安装 python setup.py install
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31a4ade2f665e92b5ceaf2c1029dfdc9/" rel="bookmark">
			PowerProfile.java解析power_profile.xml的数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. PowerProfile.java 这个文件主要目的是为了power_profile.xml的配置信息，尤其是配置的电流信息
frameworks/base/core/java/com/android/internal/os/PowerProfile.java
/* * Copyright (C) 2009 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31a4ade2f665e92b5ceaf2c1029dfdc9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4bd89d6cf6022d8ca14b7defbf34c99/" rel="bookmark">
			使用emscripten实现js直接调用C代码(emscripten的初探)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近感觉一个时间转换的C库挺好用的，但不想做成C扩展，并不是说C扩展难，对于我来说好歹也是写过一些C扩展的，主要是C扩展对环境有一些依赖，比如非win下需要node-gyp做为环境支持来进行编译，对使用者来说相对麻烦。并且我希望前端也可以调用，所以目标瞄准了emscripten，但看了这么多emscripten的文章，大多都是将理论要不就是翻译了教程，具体教程本人没看到。那就自己写的教程，记录顺便作为emscripten的初探。
emscripten是什么 大家可能只是熟知emscripten是一个可以将C代码转换成WebAssembly的神器，不仅仅如此，emscripten还可以实现C和js互调，架出一道桥梁。同时核心还是基于LLVM，写过几篇关于LLVM的，所以对LLVM制作的软件还是存在莫名的好感。好废话不多说，开干！
emscripten的安装 这篇文章不细讲，可能重要的还是空如何在终端科学上网的内容。点此打开emscripten的安装教程。
编写C代码 这里为什么使用emscripten.h和EMSCRIPTEN_KEEPALIVE的主要原因是我不太想编译代码的时候跟随一大堆指令，用这个在代码里面看起来也直观些。当然也可以使用编译指令EXPORTED_FUNCTIONS来暴露方法。注意如果是C++文件请用extern "C" 包裹，否则编译到时方法名会被加上指纹，JS调用的话就要根据指纹规则调用了
// add.c #include &lt;emscripten.h&gt; // 实现一个加法 EMSCRIPTEN_KEEPALIVE int add(int a,int b) { return a+b; } 复制代码 然后进行编译,指定输出文件为add.js否则默认输出a.out.js
emcc add.c -o add.js -s 复制代码 当看到add.js和add.wasm文件就说明成功了。add.wasm文件可以说是wasm文件，add.js就是wasm和js文件交互的桥梁。
那么我们来使用这个C的相加方法 下面直接require之前编译好的add.js来运行即可，其中注释的ccall和cwrap需要编译的时候需要暴露方法，具体编译指令也写在注释中。我们可以使用引用后的文件加下划线调用方法和ccall和cwrap来调用方法的三种方式。其中ccall和cwrap的第一个参数是方法名，第二个参数是方法的返回值，第三个参数是传入参数的类型。而ccall第四个参数是传入值并直接执行。cwrap则是先定义方法。onRuntimeInitialized是初始化模块。
// test.js // 如果要解注，编译的的使用请使用 emcc add.c -o add.js -s -s EXTRA_EXPORTED_RUNTIME_METHODS='["ccall", "cwrap"]' let addModule = require('./add.js'); // let add = addModule.cwrap('add', 'number', ['number','number']); addModule.onRuntimeInitialized = function() { // console.log(add(1,2)) // console.log(addModule.ccall('add', 'number', ['number','number'], [3,4])); console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4bd89d6cf6022d8ca14b7defbf34c99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c164940ab882e078a60896e67e68922b/" rel="bookmark">
			SQL 2008 R2 发邮件储存过程（含附件）测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQL 2008 R2 发邮件储存过程测试，
如执行不了 请启动 /*
如出现错误请执行下列代码授权
sp_configure 'show advanced options',1
reconfigure
go
sp_configure 'xp_cmdshell',1
reconfigure
go sp_configure 'Ole Automation Procedures',1
reconfigure
go
*/
参数有填写发件人，收件人（可用逗号填写多个收件人），标题，正文件内容，格式是HTMLBody 表格型，TextBody 文本型
附件发送请留言 数据库是否有访问附件的权限，一般附件放在服务器上测试的话是可以正常访问的，如果是HTMLBody 注意格式填写，如下代码
create PROCEDURE [dbo].[send_mailYSunKpi] @From varchar(1000) , --发件人 @To varchar(1000) , --收件人 @Subject nvarchar(128)='', --标题 @Body NVARCHAR(MAX) ='', --正文 @TypeHTML nvarchar(10)='', --发送格式 If you are using HTML e-mail, use 'HTMLBody' instead of 'TextBody'. @Attachment varchar(250)='' --附件发送 --附件路径必须是数据库可以访问的路径，最好是在服务器上的路径 --with encryption /********************************************************************* /* 如出现错误请执行下列代码授权 sp_configure 'show advanced options',1 reconfigure go sp_configure 'xp_cmdshell',1 reconfigure go sp_configure 'Ole Automation Procedures',1 reconfigure go */ This stored procedure takes the parameters and sends an e-mail.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c164940ab882e078a60896e67e68922b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/957e2dda10c9354cf5cc9e70b2f947b6/" rel="bookmark">
			map转换成JSON的3种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 json-lib
&lt;dependency&gt;
&lt;groupId&gt;net.sf.json-lib&lt;/groupId&gt;
&lt;artifactId&gt;json-lib&lt;/artifactId&gt;
&lt;version&gt;2.4&lt;/version&gt;
&lt;classifier&gt;jdk15&lt;/classifier&gt;
&lt;/dependency&gt;
import java.util.HashMap;
import java.util.Map;
import net.sf.json.JSONObject;
public class aaa {
public static void main(String[] args) {
Map map = new HashMap();
map.put("msg", "yes");//map里面装有yes
JSONObject jsonObject = JSONObject.fromObject(map);
System.out.println("输出的结果是：" + jsonObject);
//3、将json对象转化为json字符串
String result = jsonObject.toString();
System.out.println(result);
}
}
json-lib是一个比较老的解决方案，近几年都没有升级过，它的适用环境是JDK1.5，使用JDK1.6就有可能会报错。所以配置上加入classifier-jdk15来解决这个问题。JAR下载链接
2alibaba
JSONUtils.toJSONString(requestMap); com.alibaba.fastjson.JSON
maven坐标
&lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --&gt;
&lt;dependency&gt;
&lt;groupId&gt;com.alibaba&lt;/groupId&gt;
&lt;artifactId&gt;fastjson&lt;/artifactId&gt;
&lt;version&gt;1.2.41&lt;/version&gt;
&lt;/dependency&gt;
3 google
new Gson().toJson(param); com.google.gson.2.2.2.jar JAR包下载
maven坐标
&lt;!-- https://mvnrepository.com/artifact/com.google.code.gson/gson --&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/957e2dda10c9354cf5cc9e70b2f947b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a9600961445f40ddac4cd3d70629bef/" rel="bookmark">
			C&#43;&#43;之对象数组与对象指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.对象数组 是指每一个数组元素都是对象的数组，也就是说，若一个类有若干个对象，我们把一系列的对象用一个数组来存放。对象数组的元素是对象，不仅具有数据成员，而且还有函数成员。
格式： 类名 数组名[下标表达式]
在建立数组时，同样要调用构造函数。有几个数组元素就要调用几次构造函数。
（1）当只需要一个参数时，在定义对象数组时可以直接在等号后面的花括号内提供实参；当需要多个参数时，只能对一个构造函数的第一个参数赋值，其余的使用默认值。
#include&lt;iostream&gt; using namespace std; #include&lt;Windows.h&gt; class exam { public: exam(int n)//只有一个参数的构造函数 { x = n; } int get_x() { return x; } private: int x; }; int main() { exam ob1[4] = { 11,22,33,44 };//用只有一个参数的构造函数给对象数组赋值 //如果构造函数的参数大于1，传入的参数对第一个参数赋值，其余的为默认值 for (int i = 0; i &lt; 4; i++) { cout &lt;&lt; ob1[i].get_x() &lt;&lt; " "; } return 0; } （2）与基本数据类型的数组一样，在使用对象数组时只能访问单个数组元素
一般形式为：数组名[下标].成员名
例如：
for(int i=0;i&lt;4;i++) cout&lt;&lt;ob1[i].get_x()&lt;&lt;' '; 运行结果：11 22 33 44
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a9600961445f40ddac4cd3d70629bef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84588393df4d165b2875c3a98e8ccad3/" rel="bookmark">
			GPU和显存的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		gpu和显存类似于，cpu和内存的关系。显存用来存放模型，数据，显存越大，所能够运行的网络就越大。GPU是计算单元，用来进行数值计算。
神经网络的显存占用包括：
1）模型参数的显存占用：只有有参数的层才会有显存占用，这部分的显存占用和输入无关，模型加载完之后就会占用有参数的层包括：卷积层，全连接层，BatchNorm,Embedding层。无参数的层：激活层sigmoid（sigmoid，relu），池化层，DropOut
2）梯度与动量的显存占用。
3）输入输出占用显存。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac60997b121f4c7c148b90476406ee70/" rel="bookmark">
			Read the docs 环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写文档一向是个苦差事，但只有写出好的文档，才能有资格霸气十足的对别人淡淡道出。为了这一崇高目标，经过一些比较和调查，最终锁定Sphinx + ReadTheDocs作为文档写作工具
首先感谢以下两篇教程
https://www.cnblogs.com/youxin/p/3594161.html
https://avnpc.com/pages/writing-best-documentation-by-sphinx-github-readthedocs
以下教程是教如何搭建和撰写 Read the docs 文档。
以下教程以Ubuntu 系统为例子，其他系统类似。
前言 使用Sphinx生成文档
Sphinx是一个基于Python的文档生成项目。最早只是用来生成Python的项目文档，但随着这个项目的逐渐完善，很多非Python的知名项目也采用Sphinx作为文档写作工具，甚至完全可以用Sphinx来写书。
引用一段Sphinx生成文档的优点包括：
丰富的输出格式: 支持输出为HTML，LaTeX (可转换为PDF)， manual pages(man), 纯文本等若干种格式完备的交叉引用: 语义化的标签,并对 函式,类,引文,术语以及类似片段消息可以自动化链接明晰的分层结构: 轻松定义文档树,并自动化链接同级/父级/下级文章美观的自动索引: 可自动生成美观的模块索引精确的语法高亮: 基于 Pygments 自动生成语法高亮开放的扩展: 支持代码块的自动测试,自动包含Python 的模块自述文档,等等 搭建 1.安装 python-sphinx
输入 sudo apt-get install python-sphinx tree
2.安装 sphinx_rtd_theme主题
pip install sphinx_rtd_theme
创建项目 命令行输入sphinx-quickstart会进入一个设置向导，根据向导一步一步设置文档项目，其实必填项只有项目名称，作者和版本，其他设置都可以一路回车：
文档根目录(Root path for the documentation)，默认为当前目录(.)是否分离文档源代码与生成后的文档(Separate source and build directories): y模板与静态文件存放目录前缀(Name prefix for templates and static dir):_项目名称(Project name) : EvaEngine作者名称(Author name)：AlloVince项目版本(Project version) : 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac60997b121f4c7c148b90476406ee70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0391b81ba3af966869d697f1c8017c2/" rel="bookmark">
			TypeScript从0到1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是typescript？ 中文官网地址：点击
typescipt的优势 一个第特性叫做类型检测
在打字稿里面的英文运行为变量指定类型的，比如当你为这个变量指定数字类型的值的时候，IDE会做出类型检查，
然后告诉你这里可能会有错误，这个特性会减少你在开发阶段犯错误的几率。
第二个特性是语法提示
在IDE里面去编写打字稿的代码时，IDE会根据你当前的上下文，把你能用的类，变量，方法和关键字都给你提示出来，
你只要直接去选就可以了，这个特性会大大提升你的开发效率
第三个特性是重构
重构是说你可以很方便的去修改你的变量或者方法的名字或者是文件的名字，当你做出这些修改的时候，IDE会帮你自动引用这个变量或者调用这个方法地方的代码自动帮你修改掉，这个特性一个是会提高你的开发效率，另一个是可以很容易的提升你的代码质量
在线编译器：http：
//www.typescriptlang.org/play/ 字符串特性 1.自动换行，需要``包裹的字符串，（键盘输入服切入到中文，用esc下面那个键可以打出来）
2。字符串模版，在字符串中替换，展位符号为$ {xx变量或者函数}
参数特性 参数类型：即在参数名字后面通过冒号来指定参数的类型
从图片上可以看出，指定类型后，其他类型赋于这个变量，编译器直接飙红了
打字稿的类型推断机制：如果没有显式声明变量的类型，那么第一次赋值的类型就是这个变量的类型，那么第二次在赋于其他类型的值，编译器将报错
如果又需要这个变量是整数类型又需要这个数的类型是字符串类型，这就变成了类型不固定，那么就需要用到任何这个关键字
在函数中的类型：
参数默认值：
在参数后面用等号来指定参数的默认值
运行结果：
可选参数：
在方法的参数声明后面用问号来标明此参数为可选参数
运行结果:
方法可变参数
语法: ...参数名称
内部解析为一个数组
运行结果:
展开 展开操作符正与解构相反。 它允许你将一个数组展开为另一个数组，或将一个对象展开为另一个对象。 例如：
let first = [1, 2]; let second = [3, 4]; let bothPlus = [0, ...first, ...second, 5]; 这会令bothPlus的值为[0, 1, 2, 3, 4, 5]。 展开操作创建了 first和second的一份浅拷贝。 它们不会被展开操作所改变。
generator函数:
控制函数的执行过程,手工暂停和恢复代码执行
function* say(name: string): void { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0391b81ba3af966869d697f1c8017c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/512553447efdc957c07cfb97129fefec/" rel="bookmark">
			Go 获取10分钟前的时间，一天前的时间。。。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 time.Now().Add(-time.Minute * 10) //golang的time包里面有个AddDate方法 nTime := time.Now() yesTime := nTime.AddDate(0,0,-1) logDay = yesTime.Format("20060102" 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fb06f8094825bc3b376e09aed70ad37/" rel="bookmark">
			Error:Maven Resources Compiler: Failed to copy xx 拒绝访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、文件或者上级文件夹设置了只读 2、用户没有修改权限 ~~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b06e574b1b5ad1be3942d5092882c3ac/" rel="bookmark">
			Proxmox VE 5的SPICE控制台和虚拟机声音设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Proxmox VE 5的默认控制台是通过VNC方式，但是VNC并不支持声音。网上看到有人说用SPICE方式就可以支持声音输出。于是根据Proxmox VE 5官方wiki上的说明https://pve.proxmox.com/wiki/SPICE，下载了windows 版本的SPICE client，安装好，并且在虚拟机的设置面板上把硬件里的“显示”设置成SPICE，发现启动虚拟机后点web界面右上角的“控制台”菜单中的“SPICE”，还是直接弹出了个下载界面，下载了个文件叫“下载.vv”，双击倒时可以直接调用SPICE clien打开，但是接着显示“无法确定URI的连接类型”。配置界面主要的地方已经在下图标出：
在网上找到一篇参考文章http://blog.51cto.com/sery/2151568?lb发现，SPICE的监听的端口从61001开始往上递增，但是监听地址是127.0.0.1，只能在只能本地连接。用以下命令得到虚拟机的运行命令：
qm showcmd xxx &gt;&gt; /root/vm-xxx.sh 其中xxx为虚拟机的id。然后把脚本文件里的绑定地址127.0.0.1改成0.0.0.0就可以了，以后运行这个脚本启动的虚拟机就是可以直接用SPICE clien连接的。
然而我试了一下，发现并不是这样子。直接显示无法连接。经过阅读kvm命令的man文档，我发现原来命令行里用的是tls-port选项，这个选项是用tls来连接，我把这个选项改成了port之后，发现可以连接上，但是需要密码认证，我根本不知道密码，最后我找到了一下参数disable-ticketing，加上去之后终于成功连上虚拟机的界面。
但是，我觉得参考文章的方法只能用脚本来开启虚拟机，完全失去了web界面的优势。受官网wiki的启发，我想是否可以直接在虚拟机的配置文件中修改相关的参数，从而达到同样的效果？答案是肯定的。
首先，关闭要配置的虚拟机，在web界面中把虚拟机的“硬件”-“显示”设置回原来的“默认”。我们不需要在web界面中开启SPICE，所以这里的配置要恢复原来的样子，免得跟我们后面的配置发生冲突。
然后，编辑虚拟机的配置文件 (/etc/pve/qemu-server/XXX.conf, XXX 是虚拟机的 VM ID)，加入以下行：
args: -device AC97,addr=0x18 -spice 'port=61001,disable-ticketing,seamless-migration=on' 其中，-device选项是配置声卡，来自官方wiki。-spice选项是配置SPICE，这里绑定地址默认是0.0.0.0，所以不用设置。而port选项是设置SPICE的监听端口，这个端口可以自由设置，后面在client中填写端口跟这里一致即可。disable-ticketing是关闭认证，这样子就可以不输入账号密码直接连上。seamless-migration这个选项不知道干什么用的。
最后，开启虚拟机，在SPICE clien中输入“spice://172.21.105.108:61001”就可以成功连接了。其中172.21.105.108是虚拟机所在的pve节点的地址，61001就是在虚拟机配置文件中port参数设置的端口。
进入虚拟机的桌面环境，通过设置界面即可找到相应的声卡，我的是centos6.5操作系统，出来的声卡如下图所示：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be40f19f94f9802635445da1c36ee6cd/" rel="bookmark">
			VS2017 &#43; Vmvare 调试驱动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基础：
VS2017安装成功wdk10 注意事项：
关闭 、主机 客户机 防火墙 、 互相ping都能ping通。
一、具体操作步骤
工具安装就不说了，不会的百度一下。只说一下一些关键的地方。
1、安装好虚拟机后，给虚拟机增加一个串口设备。具体操作见图：
完成配置后虚拟机设备配置就多了一个串行端口的设备。因为打印机用了端口1。所以设备里面显示的是串行端口2（如果想设置成端口1，把打印机设备删了在添加串口设备）。
2、配置虚拟机系统为调试模式
以管理员身份，在虚拟机命令行模式下运行如下2个命令开启。 bcdedit /debug on bcdedit /dbgsettings serial debugport:n baudrate:115200 where n is the number of a COM port on the virtual machine.（n时虚拟机的一个COM端口号。就是设备显示的串行端口2，n就是端口2）。 3、把WDK10的虚拟机调试驱动拷贝到虚拟机中安装。
因为VS2017可以调试x86 x64两种驱动所以两个都拷贝到虚拟机安装。也可以根据需要情况安装（32位里安装x86版）
4、VS2017开发工具配置
在VS2017的菜单栏点击DRIVER–TEST–CONFIGURE 如图
配置界面，下面两个选项第一项由VS2017帮我们创建一个WDKuser测试账户，自动打开测试模式等。第二个是使用我们自己配置的参数。由于上面我们已经配置了串口参数 、设置了调试模式所以我们选择第二个就行了。
DESKTOP-1R835HV是虚拟机里安装的操作系统的计算机名
如下配置在内核模式中，选择串口、配置好波特率、勾上2个选项、管道名称、端口号。
出现上述红色框字样则说明配置已经成功了。（不要开启全局代理软件，否则会出现连接不上的问题）。
5、使用工具安装调试64位驱动
使用DebugView打印内核调试信息是开发驱动的非常重要的手段，但DebugView默认在WINDOWS 7和WINDOWS 10下却无法获取内核的调试日志，驱动调用KdPint/DbgPrint等的打印结果是无法被DebugView给捕捉到的。设置方法如下（复制下面的代码到txt文件。改后缀为.reg后执行，然后重启电脑）：
Windows Registry Editor Version 5.00
[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Debug Print Filter]
“DEFAULT”=dword:0000000f
还有自己编译出来的驱动要使用编译的Debug版本来测试，Release版本是不会执行KdPrint/DbgPint函数的。
6、在VS2017中下断点进行调试
如果你第五部已经完成了，并且在DebugView中已经能够输出调试的打印信息了，辣么骚年你已经离成功只有一部之遥了
创建一个驱动工程，WDK10提供的模板中根本没有提供NT驱动模板，我们如何创建NT驱动呢?
解决：其实虽然没有提供NT模板，但是我们可以建立WDM空模板工程，然后再自己添加文件，编译，得到的也就是NT驱动了。
驱动工程中会帮你建立一个inf文件，NT是使用不到的，可以直接删除。我们直接添加一个first.c
在文件中添加测试代码。
#include &lt;ntddk.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be40f19f94f9802635445da1c36ee6cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3358cf94f06a5badd0976b2361da56b5/" rel="bookmark">
			css实现“加号”效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现下图的加号效果：
若想实现这个效果， 只需一个div元素即可搞定。
需要用到css的为了before和after， 以及border特性。
先设置一个div便签
&lt;div class="add"&gt;&lt;/div&gt; 再设置一个边框：
.add { border: 1px solid; width: 100px; height: 100px; color: #ccc; transition: color .25s; position: relative; } 此时边框是这样的：
我们可以利用伪类before和其border-top来设置一个“横”：
.add::before{ content: ''; position: absolute; left: 50%; top: 50%; width: 80px; margin-left: -40px; margin-top: -5px; border-top: 10px solid; } 注意我们使了绝对定位。 此时变成了这样：
参照上面， 我们可以使用after伪类和border-bottom设置一个“竖”：
.add::after { content: ''; position: absolute; left: 50%; top: 50%; height: 80px; margin-left: -5px; margin-top: -40px; border-left: 10px solid; } 在加上hover伪类，设置鼠标悬浮上去的颜色：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3358cf94f06a5badd0976b2361da56b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0ce1640db03b6e968b5c362096139fa/" rel="bookmark">
			Hyperledger fabric基于kafka共识机制单机搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cd /opt/gopath/src/github.com/hyperledger/fabric/scripts/fabric-samples mkdir 181021 cd 181021 mkdir chaincode mkdir network cp ../../first-network/crypto-config.yaml ./ cp ../../first-network/configtx.yaml ./ 修改crypto-config.yaml内容如下
# Copyright IBM Corp. All Rights Reserved. # # SPDX-License-Identifier: Apache-2.0 # # --------------------------------------------------------------------------- # "OrdererOrgs" - Definition of organizations managing orderer nodes # --------------------------------------------------------------------------- OrdererOrgs: # --------------------------------------------------------------------------- # Orderer # --------------------------------------------------------------------------- - Name: Orderer Domain: example.com # --------------------------------------------------------------------------- # "Specs" - See PeerOrgs below for complete description # --------------------------------------------------------------------------- Specs: - Hostname: orderer0 - Hostname: orderer1 # --------------------------------------------------------------------------- # "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0ce1640db03b6e968b5c362096139fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9fd23940bb361db80be1b1d62ce1c4e/" rel="bookmark">
			Zigbee和WiFi那么好用，LoRa又具有什么优势呢？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Zigbee和WiFi那么好用，LoRa又具有什么优势呢？ 就在ZigBee和ZWave两家网络技术明争暗斗的·时候，一种新型的可远距离传输数据并且有着超低能耗的网络技术悄悄地发展起来，这种技术叫LoRa，是由升特公司(Semech)发布的一种专用于无线电调制解调的技术，它与其他如FSK(频移键控)、GMSK(高斯最小频移键控)、BPSK(二进制相移键控)及其派生的调制方案形成竞争关系。
LoRa
LoRa融合了数字扩频、数字信号处理和前向纠错编码技术，拥有前所未有的性能。此前，只有那些高等级的工业无线电通信会融合这些技术，而随着LoRa的引入，嵌入式无线通信领域的局面发生了彻底的改变。
前向纠错编码技术是给待传输数据序列中增加了一些冗余信息，这样，数据传输进程中注入的错误码元在接收端就会被及时纠正。这一技术减少了以往创建“自修复”数据包来重发的需求，且在解决由多径衰落引发的突发性误码中表现良好。
一旦数据包分组建立起来且注入前向纠错编码以保障可靠性，这些数据包将被送到数字扩频调制器中。这一调制器将分组数据包中每一比特馈入一个“展扩器”中，将每一比特时间划分为众多码片。LoRa调制解调器经配置后，可划分的范围为64-4096码片/比特。 AngelBlocks配置调制解调器可使用4096码片/比特中的最高扩频因子(12)。相对而言，ZigBee仅能划分的范围为10-12码片/比特。
通过使用高扩频因子，LoRa技术可将小容量数据通过大范围的无线电频谱传输出去。实际上，当你通过频谱分析仪测量时，这些数据看上去像噪音，但区别在于噪音是不相关的，而数据具有相关性，基于此，数据实际上可以从噪音中被提取出来。其实，扩频因子越高，越多数据可从噪音中提取出来。
在一个运转良好的GFSK接收端，8dB的最小信噪比(SNR)需要可靠地解调信号，采用配置AngelBlocks的方式，LoRa可解调一个信号，其信噪比为-20dB，GFSK方式与这一结果差距为28dB，这相当于范围和距离扩大了很多。在户外环境下，6dB的差距就可以实现2倍于原来的传输距离。
为了有效地对比不同技术之间传输范围的表现，我们使用一个叫做“链路预算”的定量指标。链路预算包括影响接收端信号强度的每一变量，在其简化体系中包括发射功率加上接收端灵敏度。
AngelBlocks的发射功率为100mW(20dBm)，接收端灵敏度为-129dBm，总的链路预算为149dB。比较而言，拥有灵敏度-110dBm(这已是其极好的数据)的GFSK无线技术，需要5W的功率(37dBm)才能达到相同的链路预算值。在实践中，大多GFSK无线技术接收端灵敏度可达到-103dBm，在此状况下，发射端发射频率必须为46dBm或者大约36W，才能达到与LoRa类似的链路预算值。
因此，使用LoRa技术我们能够以低发射功率获得更广的传输范围和距离，这种低功耗广域技术正是我们所需的。
OpenRF协议
目前已有很多“标准化”协议应用于家庭自动化领域，ZigBee和ZWave是两种主流的选择，另外还有6LowPan以及其他协议。
大多数协议或多或少依赖无线网格(mesh)组网，有些依赖整体系统来达到合理地传输距离，不过这无法使用电池供电。
LoRa采用点对点通信方式，实现远距离传输的目的，我们无需网格化网络。实际上，我们需要一个“轻量级”协议，适用于长期以电池供电的方式。
OpenRF是为电池供电的应用而开发的，例如水表和燃气表数据读取。OpenRF为媒介接入层(MAC Layer)定义了一个标准化的界面，允许其余各种各样射频集成电路装置(RFICs)协同工作。OpenRF还提供了一个支持32位设备地址的统一网络层来保证消息传递，还有多重的网络拓扑结构。理论上来说，OpenRF也可支持无线网格组网，虽然我们目前没有那种功能性要求。
OpenRF提供两个接口，其中API接口允许在一个微控制器的嵌入式应用中集成OpenRF，我们用这一界面构建了AngelBlocks的应用。另一接口为指令接口，它允许外部主控制器在串行链路上使用AT指令集来发送和接收数据包。我们的应用开发适配器在一个主机上使用指令接口控制AngelBlocks，其中Arduino和Pi适配器使用一个TTL级别的串行端口，PC/MAC适配器使用一个USB/COM端口，同一指令接口均可使用。
LoRa的腾空出世惊呆了网络技术领域的领军人物ZigBee和ZWave，打得这些大佬们措手不及。超低功耗和远距离的传输使得LoRa刚被人知晓就获得超高的人气，在这个物联网时代，LoRa这种专用于无线电调制解调的技术被运用的领域将会越来越广泛，将使得物物相连趋向柔性化，未来市场潜力巨大。
目前，相对于NB-IoT，LoRa是当前最成熟、稳定的窄带物联网通讯技术，其自由组网的私有网络远优于运营商持续不断收费的NB网络，且LoRa一次组网终身不需缴费。但是应用LoRa进行物联网通讯开发难度大、周期长、进入门槛高。据了解，为降低物联网行业创业者进入门槛，协成智慧提供了一整套成熟LoRaWAN源代码+LoRa Gateway网关定制方案，极大缩减了创业者在物联网链路调通上所耗费的半年周期与巨额开发代价，便于快速切入物联网具体应用，打造属于自己的独立物联网运营品牌。
大普通信投入LoRa研发多年，拥有LoRa的全套产品（包括模块、网关、服务器等）和多款节点（烟雾、温湿度等）成品，还拥有多种解决方案（智能家居安防、无线倒车雷达、智能抄表系统等），致力于为客户提供一体化的物联网系统服务。2017年大普通信与美国Semtech公司建立深度合作联系，双方将在LoRa芯片及应用层面进行深入合作，并在智慧城市、智慧农业、智慧牧业等领域开展产品和方案的设计，促进行业的发展。大普通信以及各厂家将围绕LoRa技术在各行业应用创新展开工作。积极推动物联网行业进展，制定统一的LoRa应用规范。积极打造特色的LoRa应用的“技术交流平台”、“方案验证平台”、“市场合作平台”。
Lora, zigbee, wifi, 优势, 对比
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f78f0fb2f8c5279f1250888e11c8a29/" rel="bookmark">
			numpy陌生但常用的函数小结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
返回最小/最大值的下标 输出排序后的下标 返回中位数 返回累加值 返回相邻位上做n次差后的值 返回非零元素的索引值数组 返回非零元素的个数 将超出的部分强置为边界 集合运算 返回最小/最大值的下标 # axis=0 在每一列中找 axis=1 在每一行中寻找 np.argmin(a, axis=None)
np.argmax(a, axis=None)
example: &gt;&gt;&gt; a = np.arange(6).reshape(2,3) &gt;&gt;&gt; a array([[0, 1, 2], [3, 4, 5]]) &gt;&gt;&gt; np.argmin(a) 0 &gt;&gt;&gt; np.argmin(a, axis=0) array([0, 0, 0]) &gt;&gt;&gt; np.argmin(a, axis=1) array([0, 0]) 输出排序后的下标 np.argsort(a, axis=-1, kind='quicksort', order=None)
&gt;&gt;&gt; x = np.array([3, 1, 2]) &gt;&gt;&gt; np.argsort(x) array([1, 2, 0]) &gt;&gt;&gt; x = np.array([[1, 5, 7], [3, 2, 4]]) &gt;&gt;&gt; np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f78f0fb2f8c5279f1250888e11c8a29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3edf3402cc4419d2c082a67b4c1869c/" rel="bookmark">
			Lucene&amp;Solr&amp;ElasticSearch-面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Lucene和Solr和Elasticsearch的区别 Lucene
Lucene是apache下的一个子项目，是一个开放源代码的全文检索引擎工具包，但它不是一个完整的全文检索引擎，而是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎，部分文本分析引擎。官网地址：https://lucene.apache.org/
Solr
Solr是一个高性能，采用Java5开发，基于Lucene的全文搜索服务器。同时对其进行了扩展，提供了比Lucene更为丰富的查询语言，同时实现了可配置、可扩展并对查询性能进行了优化，并且提供了一个完善的功能管理界面，是一款非常优秀的全文搜索引擎。官网地址：http://lucene.apache.org/solr/
Elasticsearch
Elasticsearch跟Solr一样，也是一个基于Lucene的搜索服务器，它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。官网地址：https://www.elastic.co/products/elasticsearch
1、Elasticsearch的优缺点： 优点：
1.Elasticsearch是分布式的。不需要其他组件，分发是实时的，被叫做”Push replication”。
2.Elasticsearch 完全支持 Apache Lucene 的接近实时的搜索。
3.处理多租户（multitenancy）不需要特殊配置，而Solr则需要更多的高级设置。
4.Elasticsearch 采用 Gateway 的概念，使得完备份更加简单。
5.各节点组成对等的网络结构，某些节点出现故障时会自动分配其他节点代替其进行工作。
缺点：
1.只有一名开发者（当前Elasticsearch GitHub组织已经不只如此，已经有了相当活跃的维护者）
2.还不够自动（不适合当前新的Index Warmup API）
2、Solr的优缺点： 优点
1.Solr有一个更大、更成熟的用户、开发和贡献者社区。
2.支持添加多种格式的索引，如：HTML、PDF、微软 Office 系列软件格式以及 JSON、XML、CSV 等纯文本格式。
3.Solr比较成熟、稳定。
4.不考虑建索引的同时进行搜索，速度更快。
缺点
1.建立索引时，搜索效率下降，实时索引搜索效率不高。
3、Elasticsearch 与 Solr 的比较：
1.二者安装都很简单；
2.Solr 利用 Zookeeper 进行分布式管理，而 Elasticsearch 自身带有分布式协调管理功能;
3.Solr 支持更多格式的数据，而 Elasticsearch 仅支持json文件格式；
4.Solr 官方提供的功能更多，而 Elasticsearch 本身更注重于核心功能，高级功能多有第三方插件提供；
5.Solr 在传统的搜索应用中表现好于 Elasticsearch，但在处理实时搜索应用时效率明显低于 Elasticsearch。
6.Solr 是传统搜索应用的有力解决方案，但 Elasticsearch 更适用于新兴的实时搜索应用。
使用案例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3edf3402cc4419d2c082a67b4c1869c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cfa76c014d4e11cae6595ab1edeb18b/" rel="bookmark">
			JAVA_JVM_面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JVM 知识 1、什么情况下会发生栈内存溢出。 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。 参照：http://wiki.jikexueyuan.com/project/java-vm/storage.html
2、JVM 的内存结构，Eden 和 Survivor 比例。 eden 和 survior 是按8比1分配的 http://blog.csdn.net/lojze_ly/article/details/49456255
3、jvm 中一次完整的 GC 流程是怎样的，对象如何晋升到老年代，说说你知道的几种主要的jvm 参数。 对象诞生即新生代-&gt;eden，在进行minor gc过程中，如果依旧存活，移动到from，变成Survivor，进行标记代数，如此检查一定次数后，晋升为老年代， http://www.cnblogs.com/redcreen/archive/2011/05/04/2037056.html http://ifeve.com/useful-jvm-flags/ https://wangkang007.gitbooks.io/jvm/content/jvmcan_shu_xiang_jie.html
4、你知道哪几种垃圾收集器，各自的优缺点，重点讲下 cms，包括原理，流程，优缺点 Serial、parNew、ParallelScavenge、SerialOld、ParallelOld、CMS、G1 https://wangkang007.gitbooks.io/jvm/content/chapter1.html
5、垃圾回收算法的实现原理。 http://www.importnew.com/13493.html
6、当出现了内存溢出，你怎么排错。 首先分析是什么类型的内存溢出，对应的调整参数或者优化代码。 https://wangkang007.gitbooks.io/jvm/content/4jvmdiao_you.html
7、JVM 内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存等。 内存屏障：为了保障执行顺序和可见性的一条cpu指令 重排序：为了提高性能，编译器和处理器会对执行进行重拍 happen-before：操作间执行的顺序关系。有些操作先发生。 主内存：共享变量存储的区域即是主内存 工作内存：每个线程copy的本地内存，存储了该线程以读/写共享变量的副本 http://ifeve.com/java-memory-model-1/ http://www.jianshu.com/p/d3fda02d4cae http://blog.csdn.net/kenzyq/article/details/50918457
8、简单说说你了解的类加载器。 类加载器的分类（bootstrap,ext,app,curstom），类加载的流程(load-link-init) http://blog.csdn.net/gjanyanlig/article/details/6818655/
9、讲讲 JAVA 的反射机制。 Java程序在运行状态可以动态的获取类的所有属性和方法，并实例化该类，调用方法的功能 http://baike.baidu.com/link?url=C7p1PeLa3ploAgkfAOK-4XHE8HzQuOAB7K5GPcK_zpbAa_Aw-nO3997K1oir8N–1_wxXZfOThFrEcA0LjVP6wNOwidVTkLBzKlQVK6JvXYvVNhDWV9yF-NIOebtg1hwsnagsjUhOE2wxmiup20RRa#7
10、你们线上应用的 JVM 参数有哪些。 -server Xms6000M -Xmx6000M -Xmn500M -XX:PermSize=500M -XX:MaxPermSize=500M -XX:SurvivorRatio=65536 -XX:MaxTenuringThreshold=0 -Xnoclassgc -XX:+DisableExplicitGC -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction=0 -XX:+CMSClassUnloadingEnabled -XX:-CMSParallelRemarkEnabled -XX:CMSInitiatingOccupancyFraction=90 -XX:SoftRefLRUPolicyMSPerMB=0 -XX:+PrintClassHistogram -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintHeapAtGC -Xloggc:log/gc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cfa76c014d4e11cae6595ab1edeb18b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f56e43ab2a5e7f44e280f24151a22a1/" rel="bookmark">
			2018_java集合面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、集合体系图 1、单列集合 2、双列集合 二、单列集合面试题： 1、ArrayList 和 LinkedList 有什么区别。 ArrayList和LinkedList都实现了List接口，有以下的不同点：
a、ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。与此对应，LinkedList是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。所以ArrayList的查询是要比LinkedList要快。 b、相对于ArrayList，LinkedList的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。
c、LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。
2、ArrayList 底层实现方式？ a、ArrayList 底层是通过数组实现，一旦实例化 ArrayList 无参构造函数，那么默认数组初始化长度就为 10。
b、add 方法底层实现如果增加的元素个数超过了 10 个，那么 ArrayList 底层会新生成一个数组，长度为原数组的 1.5 倍+1（jdk1.6之前，1.7以后是用的位运算（效率更高），是1.5倍），然后将原数组的内容复制到新数组当中，并且后续增加的内容都会放到新数组当中。当新数组无法容纳增加的元素时，重复该过程。是一旦数组超出长度，就开始扩容数组。扩容数组调用的方法 Arrays.copyOf(objArr, objArr.length + 1);
3、LinkedList 底层实现方式？ a、LinkedList 底层的数据结构是基于双向循环链表的，且头结点中不存放数据。
b、LinkedList包含两个重要的成员：header 和 size。
header是双向链表的表头，它是双向链表节点所对应的类Entry的实例。Entry中包含成员变量： previous, next, element。其中，previous是该节点的上一个节点，next是该节点的下一个节点，element是该节点所包含的值。 size是双向链表中节点的个数。
c、从LinkedList的实现方式中可以发现，它不存在LinkedList容量不足的问题。
d、LinkedList底层的克隆函数，即是将全部元素克隆到一个新的LinkedList对象中。
4、Vector的底层实现方式？ a、Vector底层是通过数组实现的，一旦实例化Vector无参构造函数，那么默认数组初始化长度为10。
b、加载因子为1，一旦元素的个数超过容量的长度时，会进行扩容。
c、扩容后的大小为原数组的2倍，即原来为10，扩容后为20。
d、Vector是线程安全的，因为底层的方法都是用Sychronized修饰的，它的速度相对ArrayList要慢些。
5、HashSet的底层实现方式？ HashSet底层实现是一个HashMap用来保存数据，实现Set接口。线程不安全，存取速度快。默认初始容量为16，加载因子为0.75：即当元素个数超过容量长度的0.75倍时，进行扩容，扩容大小为原容量的2倍。如HashSet的容量为16，一次扩容后是容量为32 6、HashMap的底层实现之扩容？ HashMap的默认初始容量为16（为何是16：16是2^4，可以提高查询效率，另外，32=16&lt;&lt;1）加载因子为0.75：即当 元素个数 超过 容量长度的0.75倍 时，进行扩容，扩容后大小为原容量的2倍。
7、Hashtable的底层实现之扩容？ Hashtable 是线程安全的，底层方法都用Sychronized修饰的。默认初始容量为11，加载因子为0.75：即当元素个数超过容量长度的0.75倍 时，进行扩容，扩容后的大小为原容量的2倍+1，如 Hashtable的容量为11，一次扩容后是容量为23
8、ArrayList、Vector、HashSet、HashMap、Hashtable的扩容 Class
初始大小
加载因子
扩容倍数
底层实现
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f56e43ab2a5e7f44e280f24151a22a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecd8c71f629e9f34a2aa638ff87bf097/" rel="bookmark">
			c语言long和long long的取值范围
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		溢出和取值范围 C语言的整型溢出问题
整数溢出
int、long int 、long long int 占用字节 《C和指针》中写过：long与int：标准只规定long不小于int的长度，int不小于short的长度。
double与int类型的存储机制不同，long int的8个字节全部都是数据位，而double是以尾数，底数，指数的形式表示的，类似科学计数法，因此double比int能表示的数据范围更广。
long long在win32中是确实存在，长度为8个字节；定义为LONG64。
为什么会出现long int呢？在win32现在系统中，长度为4；在历史上，或者其他某些系统中，int长度为2，是short int。
即便是long long，在TI的有款平台中，长度为5也就是说，每种类型长度，需要sizeof才知道，如果可能，最好用union看看里面的数据，可以消除一些类型的假象长度。
类型名称字节数取值范围signed char1-128～+127short int2-32768～+32767int4-2147483648～+2147483647long int4-2147483648～+2141483647long long long int8-9223372036854775808～+9223372036854775807 unsigned int （unsigned long）
4字节8位可表达位数：2^32=42 9496 7296
范围：0 ～ 42 9496 7295 (42*10^8)
int （long）
4字节8位可表达位数：2^32=42 9496 7296
范围：-21 4748 3648 ～ 21 4748 3647 (21*10^8)
long long (__int64)
8字节8位可表达位数：2^64=1844 6744 0737 0960 0000
范围：-922 3372 0368 5477 5808 ～ 922 3372 0368 5477 5807 (922*10^16)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecd8c71f629e9f34a2aa638ff87bf097/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf954ab2a45c314d098f93b3c843967a/" rel="bookmark">
			chrome安装或更新失败可能原因及解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Chrome在安装或更新时，可能会出现0x80070057、0x80040154、0x80004002、0x8004070c、0x80080005、0x80072EFD、0x80072EE2等错误，本文说明如何解决这些问题。
解决Chrome安装或更新中出现的0x80070057等错误
方法/步骤
1
安装失败，错误代码：0x80070057
出现这个错误，并非网上说的各种原因，而是因为您使用的安装包有问题，请参考下面经验"如何离线安装Chrome最新版本或某一特定版本？"中的方法来解决这个问题。
41如何离线安装Chrome最新版本或某一特定版本？
解决Chrome安装或更新中出现的0x80070057等错误
2
安装失败，错误代码：0x80004002
以管理员的身份来安装(安装包右键菜单，以管理员身份运行)或使用360软件管家来安装Chrome，如果还是一样的问题，则尝试用下面经验"如何离线安装Chrome最新版本或某一特定版本？"的方法进行安装。如果还是有问题，则将Windows启动到安全模式后，再进行安装。
18如何彻底卸载Chrome浏览器？
41如何离线安装Chrome最新版本或某一特定版本？
解决Chrome安装或更新中出现的0x80070057等错误
解决Chrome安装或更新中出现的0x80070057等错误
3
安装失败，错误代码：0x8004070c
● 请用360强力删除删除下面几件文件夹：
C:\Program Files (x86)\Google
C:\Program Files\Google
%UserProfile%\AppData\Local\Google
● 然后再删除如下的注册表值:
按下Win+R，打开运行对话框，输入regedit，回车打开注册表编辑器，定位到如下注册表路径，删除ImageState值。
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Setup\State\ImageState
删除下面注册表键：
HKEY_CURRENT_USER\Software\Google\Update
HKEY_LOCAL_MACHINE\SOFTWARE\Google\Chrome
解决Chrome安装或更新中出现的0x80070057等错误
解决Chrome安装或更新中出现的0x80070057等错误
解决Chrome安装或更新中出现的0x80070057等错误
4
检查更新时出错：无法启动更新检查（错误代码为 3:0x80080005)
这个错误是因为GoogleUpdate.exe被误删导致的，参考下面经验"如何离线安装Chrome最新版本或某一特定版本？"重新安装以修复GoogleUpdate。
41如何离线安装Chrome最新版本或某一特定版本？
解决Chrome安装或更新中出现的0x80070057等错误
5
无法连接互联网，错误代码：0x80072EFD
这个错误是因为GoogleUpdate.exe程序被防火墙给禁用了，在 “网络和共享中心”-&gt;“Windows 防火墙”-&gt;“高级设置”-&gt;"出站规则"中增加一条允许GoogleUpdate.exe程序访问网路的规则就可以了。
解决Chrome安装或更新中出现的0x80070057等错误
解决Chrome安装或更新中出现的0x80070057等错误
6
无法连接互联网，错误代码：0x80072EE2
这个错误是因为不能解析Google更新服务器的域名导致的问题，参考下面经验"解决Chrome浏览器不能登录和更新问题"，设置Google相关服务器的域名映射。
https://jingyan.baidu.com/article/2f9b480df4c5a541ca6cc24e.html
注：由于最近GFW管控比较严格，这个方法可能会失效。
14解决Chrome浏览器不能登录和更新问题
解决Chrome安装或更新中出现的0x80070057等错误
END
安装/更新失败，错误代码：0x80040154
GoogleUpdate服务被禁用
按下Win+R，打开运行对话框，输入msconfig，打开"系统配置"，确保两个GoogleUpdate的服务处于启用状态。
解决Chrome安装或更新中出现的0x80070057等错误
解决Chrome安装或更新中出现的0x80070057等错误
解决Chrome安装或更新中出现的0x80070057等错误
GoogleUpdate没有注册
按下Win+R，打开运行对话框，输入：
32位：C:\Program Files\Google\Update\GoogleUpdate.exe /RegServer
64位：C:\Program Files (x86)\Google\Update\GoogleUpdate.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf954ab2a45c314d098f93b3c843967a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45e8fdf0a30642f34dcea8210662b8ea/" rel="bookmark">
			有关POE及POE&#43;以太网供电系统标准IEEE802.3af与at的区别解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 IEEE 802.3af和IEEE 802.3AT标准都是通过以太网数据线对或备用线对来实现以太网设备供电，它们突破了以太网的应用，而它们主要是一个电源传输协议，不是数据协议。
IEEE 协会于2003年6月批准了802. 3af 标准，它明确规定了远程系统中的电力检测和控制事项，并对路由器、交换机和集线器通过以太网电缆向IP电话、安全系统以及无线LAN 接入点等设备供电的方式进行了规定。
在IEEE802.3AF标准下，POE的系统构成，一个完整的POE系统包括供电端设备(PSE, Power Sourcing Equipment)和受电端设备(PD, Power Device)两部分。
PSE设备是为以太网客户端设备供电的设备，同时也是整个POE以太网供电过程的管理者。而PD设备是接受供电的PSE负载，即POE系统的客户端设备，如IP电话、网络安全摄像机、AP及掌上电脑( PDA)或移动电话充电器等许多其他以太网设备。两者基于IEEE 802.3af标准建立有关受电端设备PD的连接情况、设备类型、功耗级别等方面的信息联系，并以此为根据PSE通过以太网向PD供电。
标准的五类网线有四对双绞线，IEEE80 2.3af 允许两种线序供电方法： 一种是在4、5、7、8线对上传输电流，并且规定，4、5为正极，7、8为负极。另一种供电是在1、2、3、6线上传输电源，极性为任意，1、2为正极，3、6为负极或是1、2为负极，3、6为正极，其中的一种供电极性。
IEEE802.3af的工作过程：
1、 检测：一开始PSE在为受电设备供电前，先输出一个低电压来检测受电设备（PD）是否符合IEEE802.3af标准，如果符合标准，一般是在受电设备中，选用24.9K的电阻，来确认符合IEEE802.3af供电标准。 2、 分级：当PSE检测到符合要求的阻值后，会将输出电压进一步提高，来对受电设备进行分级，如果受电设备此时没有回应分级确认电流，PSE默认将受电设备规为0级，为其提供15.4W的输出功率。
3、 供电：经过确认分级后，PSE会向受电设备输出48V的直流电，并确认受电设备不超过15.4W的功率要求，当受电设备超载或短路后，PSE停止为其供电，再次进入检测阶段。
IEEE802.3af标准供电系统的主要供电特性参数为：
直流电压在44～57V之间，典型值为48V。 典型工作电流为10～350mA，典型的输出功率：15.4W。
超载检测电流为350～500mA。 在空载条件下，最大需要电流为5mA。 为PD设备提供3.84～12.95W四个Class等级的电功率请求。 IEEE802.3af的分级参数：
Class 0设备需要的最高工作功率为0~12.95W
Class 1设备需要的最高工作功率为0~3.84W； Class 2设备需要的工作功率介于3.85W~6.49W； Class 3设备的功率范围则介于6.5～12.95W。 IEEE 802.3at标准
由于IEEE 802.3af规范，受电设备(PD)上的PoE功耗被限制为12.95W，这对于传统的网络受电设备足以满足需求，但随着IP电话以及网络摄像头、双波段接入、视频电话、PTZ视频监控系统等高功率应用的出现，13W的供电功率显然不能满足需求，这就限制了以太网电缆供电的应用范围。为了克服PoE对功率预算的限制，并将其推向新的应用，IEEE成立了一个新的任务组，旨在探求提高该国际电源标准的功率限值的方法。IEEE802.3工作组为了在技术及经济上对IEEE802.3at实现的可能性进行评估，新标准称为 IEEE 802.3at，它将功率要求高于12.95W的设备定义为Class 4,可将功率水平扩展到25W或更高，新标准并在2009年初发布。 IEEE 802.3at与802.3af相比，802.3at可输出2倍以上的电力，每个端口的输出功率可在30W以上，就标准而言，两者在功率、分级上有不同的定义。
在IEEE802.3at规定，受电设备PD可以最大到29.95W，PSE将为其提供30W以上的直流电源。PD以Class4分级的电流响应，告诉PSE是否能够为其提供802.3at规定的较高功率。
IEEE802.3at标准供电系统的主要供电特性参数为： 直流电压在50～57V之间，典型值为50V。 典型工作电流为10～600mA，典型的输出功率：30W。
受电设备PD支持Class4的分级。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbd5991bc863c569d869ad0237645f1e/" rel="bookmark">
			编写程序模拟简单的密码登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编写程序模拟简单的密码登录，首先从键盘输入名字和密码，若密码正确则给出问候语。 若密码不正确，则给出错误提示，并允许再次输入，直到输入正确的密码或0结束。 用户名随意，不超过10个字节。 密码123456 # include &lt;stdio.h&gt; int main() { char name[10]; scanf("%s",name); while(1) { int password; scanf("%d",&amp;password); if(password==0) { printf("Wrong Password!\n"); break; } if(password==123456) { printf("Hello %s\n",name); break; } else { printf("Wrong Password!\n"); continue; } } return 0; } 一开始把密码设置成字符串，比较麻烦。后来想了想直接int就OK了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e97e4e92500af21fc26ecd54a1ef53f1/" rel="bookmark">
			外企面试英文自我介绍【面试经验】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：秋招即将结束，在找工作中遇到几次英语交流和自我介绍。如果提前做好准备，可能会收货一份含金量很高的offer，例如：微软、因特尔、WAP、微策略...等等。英语在今后的职业生涯中也非常重要，希望以此能够帮助到后来人。
英语自我介绍要点及模板 不同的学校对口语测试有不同的标准和流程。有些制定了非常详细的标准和流程，甚至规定了每个老师发问的方式和时间；有些只是面试老师的自由发挥，成绩也基本上由面试老师主观判定。不管面试是否严格控制，考生对下面几个问题一定要认真准备，并形成一套属于自己的表达框架：
一是自我介绍，如来自哪里，毕业学校、所学专业、毕业论文课题、业余爱好、家庭基本情况等信息。
二是做好用英语定义和解释自己所学专业的准备。口语测试时，老师有可能就本专业展开话题，考查考生用英语讲述事物的能力。因此考生对此要有所准备，先用一些自己比较熟悉的句型和词汇将答案组织起来，再用一些更精确的不经常用的句型和词汇来替换，提高语言质量，让考官感觉表述地道，有利于获得好成绩。
举例考验英语自我介绍，同样适用于面试时的英语自我介绍：
考研复试英语自我介绍注意事项 在自我介绍完了老师就会开始问你问题这里列出一些常见的问题，可以认真准备。注意在准备的过程中，要结合自己的经历和见解来准备答案，让自己回答的问题和整个的自我介绍融为一个整体。要不然很容易被考官抓住把柄，问个没完，很容易因紧张而露出马脚。
在每一年的面试中都会有很多相同的问题，这些问题看起来很平常，却有很多陷阱，一不小心就会被考官抓主小辫子了。回答这些常见的看起来很平常的问题，是很有艺术的。
基本上每个院校每个专业的口试中都会涉及这一方面。考官其实是要借此了解你的口头表达能力以及你的报名表之外的一些信息。自我介绍时间以2-3分钟为宜。思路要清楚，要突出重点，口语尽量流利(不要太流利了，有背诵之嫌)。
1) 考官要求你作自我介绍时，不要用…let me introduce myself briefly / please allow me to introduce myself to you等句子，重复、啰嗦。开头可以只用一句话引入：Dear professors, I feel so glad to meet all of you here.然后就可以进入主题，介绍姓名、年龄等等。
2) 自我介绍的主体内容
① 姓名：介绍自己姓名时，发音一定要准(南方考生要多加注意)。
② 年龄：年龄可以跟在姓名后带过(I am XXX, 25 years old)。
③ 原来的院校、专业：注意：一定要把原来学校的英文名称、专业的英文名称弄清楚(尤其是跨校、跨专业的学生)。 所属的公司、职位。注意：在职考生则应将自己公司、自己职位/职称的英文名称弄明白。
④ 性格、能力：可以着重强调你的个性对你报考的专业有何积极的作用。如果报考的是学术性的专业，可以说自己细心(carefully，detail-oriented)、条理分明(logical)、踏实(steady)等;如果是研究性、应用性更强一点的专业，可以说自己负责(responsible)、可靠(dependable)、有效率(efficient)等。
其他的一些表示性格、能力的形容词有：active, aggressive(有进取心的), adaptable, amicable(友好的), analytical(善于分析的), cooperative, creative, disciplined, dutiful, energetic, faithful, gentle, independent(有主见的), innovative, motivated, modest, objective, precise, punctual, precise(一丝不苟的), temperate等等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e97e4e92500af21fc26ecd54a1ef53f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90d7439198d0b1f61284d229cb7c2fc6/" rel="bookmark">
			org.apache.shiro.authz.AuthorizationException: Not authorized to invoke method xxx
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		org.apache.shiro.authz.AuthorizationException: Not authorized to invoke method
原因：使用了redis缓存，即使重启应用，只要缓存不过时，则可以直接根据缓存登录，
这时新增加了一个Controller后，然后访问某个方法，提示没有权限。
解决办法：
用户退出系统，重新登录，权限会自动刷新到缓存中。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4443a4a232b25fbd0938f382fd619dec/" rel="bookmark">
			cookie 有效域名如何设置？？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cookie默认只能在主域名下使用，如果我们想要在子域名下使用cookie，该怎么办呢？下面汤锅就教大家如何在子域名下愉快的使用cookie。
首先新建一个cookie_demo文件，其代码如下：
rom flask import Flask,Response app = Flask(__name__) @app.route("/") def index(): respon = Response("设置cookie") # set_cookie:设置cookie ，第一个为key，第二个为value respon.set_cookie("name","tlj") return respon if __name__ == "__main__": app.run(debug=True) 由于我们要在子域名下调用主域名的cookie,所以我们首先得创建一个子域名，如何创建子域名？？相信看过汤锅前面关于蓝图文章的同学，一定知道如何创建子域名，实在不知道的同学，请访问《蓝图子域名如何实现》一文。
子域名可以通过蓝图方式来实现，我们创建一个blue_demo文件（用于写蓝图代码），其代码如下：
from flask import Blueprint,request bp = Blueprint("cms_bp",__name__,subdomain="cms") @bp.route("/") def index(): name = request.cookies.get("name") #如果有name这个key，则返回name对应的值，否则返回没有获取到name值 return name or "没有获取到name值" 蓝图写好了，我们在主app文件将其导入进来。代码如下：
from bp_demo import bp 蓝图导入到主app文件后，我们是不是还得将蓝图注册到app中，是吧！！注册代码如下：
app.register_blueprint(bp) OK，蓝图注册好了，我们还得对其进行配置。哼哼！！是配置，不是配偶啊！！！配置代码如下：
app.config["SERVER_NAME"] = "jd.com" 然后在host文件下，加入下方代码
127.0.0.1 cms.jd.com
127.0.0.1 jd.com
打开谷歌浏览器，输入jd.com:5000，点击浏览器icon小图标，就可以看到我们设置的cookie信息了，由于之前我们设置过，我们先把所有cookie信息删除。
删除完！我们再运行主app文件试试！在浏览器输入jd.com:5000,再点击小图标就能看到cookie已成功设置！
主域名已成功设置cookie，我们再看看子域名是否能够获取的到主域名cookie信息！在浏览器输入 cms.jd.com:5000试试
结果返回我们没有获取到name值，这是为什么呢？？原因很简单，因为我们再设置cookie的时候，没有指定这个cookie的作用域（说白了，就是指定cookie是否能够在子域名下使用）。既然我们知道了原因，下面我们就设置下cookie的作用域。
set_cookie函数有个domain参数，这个domain参数有什么用呢？其作用就是用于解决cookie是否能够在子域名下使用。代码如下：
respon.set_cookie("name","tlj",domain=".jd.com") 注：设置好后，jd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4443a4a232b25fbd0938f382fd619dec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40b12a955152a5bfe2e9548caeca3e29/" rel="bookmark">
			逻辑回归实现分类计算（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在上一篇逻辑回归分类计算中，模型的准确率为0.1，准确率较差且在分类1的模型预测结果显示中效果极差。在网上查找了各种逻辑回归分类的代码分析。发现错误还是在梯度下降算法计算回归系数的上，导致模型预测的精确度不高。
所以本次更改梯度下降算法来进行新的预测。
损失函数为：
对θ求导得到梯度：
更新回归系数：
同时也对因变量进行修改，不再对因变量处理成[-6,6]的线性数据。将因变量处理成分类变量，每一类形成一列新数据，数据列全为0和1,分别表示有无该类别。在数据中，增加一列为全为1的偏移变量。
数据处理结果为：
引申逻辑判别多分类函数softmax。
为了使每个样本数据都能参加到训练中，采用交叉检验。本次实验用到了K折交叉检验
K折交叉验证，初始采样分割成K个子样本，一个单独的子样本被保留作为验证模型的数据，其他K-1个样本用来训练。交叉验证重复K次，每个样本验证一次，平均K次的结果或者使用其它结合方式，最终得到一个单一估测。这个方法的优势在于，同时重复运用随机产生的子样本进行训练和验证，每次的结果验证一次，10折交叉验证是最常用的。
代码就不再直接写在博客上了，有需要的可以在百度云下载：链接，提取码：1yx5
结果显示如下：
准确率能达到0.675.在梯度下降算法中，移动步长是固定的，更新移动步长为随机，查看模型准确率提升效果。
代码如下：
def RandomGradientDescent(dataMartrix, labelMat, numIter=500): m,n = np.shape(dataMartrix) weights = np.ones((n,1)) for j in range(numIter): for k in range(m): alpha = 10/(1.0+j+k)+0.01 #改进移动步长 h = sigmoid(dataMartrix[k] * weights) error = h - labelMat[k] #计算样本误差 weights = weights - alpha * dataMartrix[k].T * error #更新回归系数 return weights.getA() 当然随机梯度下降算法的计算量也是比较大的，准确率会较固定梯度下降算法提高。由于该样本数据的分布不均（0的样本数量为273条，1的样本数量为127条）导致类别为1的判别效果较差。所以尝试增加类别为1的样本数据，观察样本判别结果。
将下面的代码放在数据读取之后和处理之前。
#增加样本数量 a = dataSet[dataSet.admit == 1] dataSet = dataSet.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40b12a955152a5bfe2e9548caeca3e29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfa08aa288d3a42110cd41fa1d9723a4/" rel="bookmark">
			【portia前端组织结构拆解】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 整体页面结构projectsprojec tcomponent结构component.js分析controller分析分析结论project/spider分析 常用函数分析routesetupController()deactivateunload controllerset Ember流转action流转 整体页面结构 &lt;!-- &lt;nav id='top-bar'&gt; &lt;section&gt; container side-bar main options-panels div (main) tool-panels &lt;/section&gt; --!&gt; projects component结构 {{project-list}} {{input-with-clear}} {{input}} &lt;!--这是一个ember helper --!&gt; {{icon-button class="clear-input" icon="close" action=(action "clear")}} &lt;!--这是一个通用component，通过class来改变背景颜色--!&gt; component.js分析 components/input-with-clear.js 一个带功能的输入框 components/project-list.js f1 showSearch --&gt;return this.get("projects.content,length") &gt; this.get("minSearchProjects"); f2 filteredProjects --&gt;Ember.computed("projects","searchTerm",function(){ let term = this.get('searchTerm'); if (term.length===0){ return this.get('projects'); } return this.get('store').peekAll('project').filter(function(item){ return item.get('name').toLowerCase().indexOf(term) &gt; -1; }); }) 。project-list.hbs {{if showSearch}} {{输入框}} {{搜索结果}} {{else}} {{项目列表}} ## browsers component.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfa08aa288d3a42110cd41fa1d9723a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef8c59af3cc8ad8b353a2ca4b2e823ee/" rel="bookmark">
			【运维】运维知识体系（运维体系化成长）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 职能划分应用运维安全运维（安全宝）监控运维系统运维 （阿里云） 运维标准化1. 物理设备方面2. 操作系统层面3. 应用服务层面 工具化1. shell脚本2. 开源工具web化好处 服务化（API）智能化自动化扩容（虚拟机）触发机制-&gt;决策系统（决策树）工具工具2 自动化缩容缩容服务降级故障自愈 基于ITIL的运维管理体系服务服务管理ITSM（IT service manage）ITIL（IT 基础架构库）是ITSM的最佳实践，是一种标准管什么PDCA四阶段服务台（呼叫中心） 监控概述 缓存 职能划分 应用运维 项目上线、服务部署、业务部署、版本管理、灰度发布、应用监控
安全运维（安全宝） 整体安全方案、规范、漏洞监测、安全防护
监控运维 7X24 故障处理
系统运维 （阿里云） 分布式缓存、分布式文件系统、日志收集、环境规划（测试、开发、生产）、架构设计、性能优化
基础服务运维
DNS、负载均衡、系统监控、运维平台、系统监控
运维标准化 1. 物理设备方面 服务器标签化、设备负责人、设备采购详情、设备摆放网络划分、远程控制卡、网卡端口服务器机型、硬盘、内存统一、根据业务分类资产命名规范、编号、类型监控标准 2. 操作系统层面 操作系统版本系统初始化（DNS、NTP、内核参数调优、rsyslog、主机名规范）基础Agent配置（zabbix agent 、logstash agent 、saltstack minion）系统监控标准（CPU、内存、硬盘、网络、进程） 3. 应用服务层面 web服务器选型（Apache、Nginx）进程启动用户、端口监听规范、日志收集规范（ 访问日志、错误日志、运行日志）配置管理（配置文件规范、脚本规范）架构规范（Nginx+keepalived、lvs+keepalived）部署规范（位置、包命名） 工具化 1. shell脚本 功能性、检查性、报表性
2. 开源工具 zabbix 监控elkstack 日志收集、分析saltstack 批量管理、配置管理cobbler 自动化安装 web化 好处 权限控制日志记录弱化流程不用ssh到服务器，减少人为错误 服务化（API） 新增集群节点流程
调用cobbler-api安装操作系统调用saltstack-api进行系统初始化调用dns-api解析主机名调用zabbix-api给上线机器加上监控再次调用saltstack-api部署软件（安装nginx+php）调用deploy-api 将当前版本的代码部署到服务器调用test-api 测试当前服务器运行是否正常调用slb-api 将该节点加入集群 智能化 自动化扩容（虚拟机） 触发机制-&gt;决策系统（决策树） 访问量超过最大支撑量
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef8c59af3cc8ad8b353a2ca4b2e823ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08542eba261d2e96183242cd6b5b0717/" rel="bookmark">
			PTA 线性表元素的区间删除 -----时间复杂度O（n）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PTA题目链接：https://pintia.cn/problem-sets/1042077620734685184/problems/1045141813475319808
题目要求删除线性表中中所有值大于minD并且小于MaxD的元素，并且保持剩余元素按照原来顺数存储。
看到题目后我最开始想的便是for循环判断，然后找到后再for循环移动删除，但是这样时间复杂度是O（n方）发现有一个会超时。这样方法不可行，必须降低时间复杂度。
List Delete (List L,ElementType minD,ElementType maxD){ int i=0; //两层while循环，第一层找出符合的值，找到后进入第二层进行移动（删除），并且长度减一 while(i&lt;=L-&gt;Last){ if(L-&gt;Data[i]&gt;minD&amp;&amp;L-&gt;Data[i]&lt;maxD){ //找出符合的值 int j=i; //记录下该值的位置 while(j&lt;L-&gt;Last){ //从该位置开始到最后一位都想前移动一位 L-&gt;Data[j]=L-&gt;Data[j+1]; j++; } L-&gt;Last--; //表长减一 } //这里需要注意的是，移动完之后i不能加一，因为新移动的到i位置的元素也需要判断 else i++; //只有i位置的元素不符合删除要求时才i++对下一位子判断 } return L; } //这个方法虽然超时了，但是也有几个需要注意的点：1、移动后i不能加一，需要再对i进行判断。 //2、表长容易忘记减一。 由于上面的代码超时了，所以必须降低时间复杂度到O(n).所以想到了，设置一个变量count，记录需要删除的元素的个数，当出现不需要删除的元素是，前面有count个需要删除的元素，只需要将该位置元素移动到[i-cont]位置上即可。这个算法就相当于遇到不需要删除的元素就将它一次从头从头开始排列。
List Delete (List L,ElementType minD,ElementType maxD){ int count=0; //定义一个count记录需要删除的元素的个数 for(int i=0;i&lt;=L-&gt;Last;i++){ //遍历顺序表 if(L-&gt;Data[i]&gt;minD&amp;&amp;L-&gt;Data[i]&lt;maxD) count++; //只要需要删除count就加一。 else L-&gt;Data[i-count]=L-&gt;Data[i]; //不需要删除的就向前调到i-count位置。 } L-&gt;Last-=count; //因为删除了count 个元素链表最后一个位置前提了count位 return L; } 除了上面这中方法外还可以另外申请一个顺序表，依次判断原顺序表里的元素，不需要删除就放到新申请的线性表中。这样时间复杂度也是O(n),但是空间复杂的也是O(N).
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/922802fbcfd7d192bfb682cf706a2eca/" rel="bookmark">
			Vue用Rem实现自适应布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 什么是rem
rem（font size of the root element）是指相对于根元素的字体大小的单位。简单的说它就是一个相对单位。看到rem大家一定会想起em单位，em（font size of the element）是指相对于父元素的字体大小的单位。它们之间其实很相似，只不过rem计算的规则是依赖根元素,em是依赖父元素计算。
二 为什么使用rem及原理
2.1 为什么使用rem
rem布局的目的是为了让我们的同一份代码,适应不同的移动终端
2.2 rem的原理
举一个例子:
当我们拿到的是一个414px(iPhone6plus)宽度设计稿的时候,为了兼容比其大或则比其小的设备时,我们的具体步骤是:
2.2.1. 先确定1rem相对于根元素(html)字体大小的单位.
比如: 设计为 1rem = 100px 2.2.2 接着按照这个格式,来进行转化,将所有的px转为rem.
比如: font-size: 12px; (原来) //现在改为rem单位 /* 换算过程: 1rem = 100px 那么: 1px = 1 / 100 = 0.01rem 12px: 12px = 12 * 0.01 = 0.12rem */ font-size: 0.12rem 当然这么繁琐的事情,我们是不会去做的,我们先将所有的布局样式写好,然后再利用工具,来进行转换.下面的网址可以免费转换将页面所有的px转成rem.只需要我们设置1rem等于多少px.
程序员在线工具: http://www.ofmonkey.com/front/rem
2.2.3 最后再将转换好的文件引入到自己的样式中
但是一定要注意的是rem是参照html这个根元素来确定自己大小的,所以在css文件中一定不能改变html的字体大小.
//我们在之前的参照是1rem = 100px 所以这里的设置必须这样 html { font-size: 100px; //这里是px,一定要注意 } 到此大功告成了吗?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/922802fbcfd7d192bfb682cf706a2eca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e426de0aa4696e2ecd343fa4c728ed6/" rel="bookmark">
			org.thymeleaf.exceptions.TemplateInputException 错误解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，出现问题：
1.1想让页面以列表形式展示数据库数据，出现页面错误提示（或者显示database.js中式错误什么的）：
DataTables警告：table id = example - Ajax错误。有关此错误的更多信息，请参阅http://datatables.net/tn/7
1.2控制台同样报错，错误提示：
org.thymeleaf.exceptions.TemplateInputException 二，分析问题：
2.1查看页面字段对应的数据是否一致!!!
2.1.1首先核对显示数据库数据值的个数是否一一对应，如图：
2.2.2核对页面显示的字段与数据库数据值的个数是否一一对应;
2.2如果上述步骤还是没有解决问题，页面与后台依然报错，找到自己的XXXController.java，在获取数据列表的方法中，查看是否缺少@ResponseBody注解，添加注释后重启项目问题解决！
三，总结问题：
在方法上必须添加注解@ResponseBody，如果不添加@ResponseBody，就会报上面错误，因为当使用@Controller注解时，spring默认方法返回的是查看对象（页面）。而加上@ResponseBody，则方法返回的就是具体对象了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d388ff50368b8a4166745e045e4ac7a/" rel="bookmark">
			很太吧动漫邪恶游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自己玩当然谈比给别人好一定要请女模特来实验吗十大发生的法师答复撒旦法撒旦法撒..万法归宗
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5292501f4ca9a0dd6b12ee5b829fd5a9/" rel="bookmark">
			java中判断两个浮点型(float)数据是否相等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		示例代码： public static void main(String[] args) { float a = 10.222222225f; float b = 10.222222229f; System.out.println("使用==判断是否相等:" + (a == b));// 超出精度范围 System.out.println("使用Math.abs()判断是否相等:" + (Math.abs(a - b) &gt;= 0)); System.out.println("比较a是否大于b:" + (a &gt; b)); System.out.println("比较b是否大于a:" + (a &lt; b)); } 输出的结果: 使用==判断是否相等:true 使用Math.abs()判断是否相等:true 比较a是否大于b:false 比较b是否大于a:false 总结： 一般不会直接用"=="或者"!="对两个浮点数进行比较。
判断两个浮点数float a 与 float b 是否相等可以根据他们的差的绝对值与0的大小来进行判断。
Math.abs(a - b) &gt;= 0或者Math.abs(a - b) &lt;= 0则代表这两个浮点数相等
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86541bc21f685c1b4777359bcf7ab74c/" rel="bookmark">
			swagger2 注解说明 ( @ApiImplicitParams )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转到教程。
@Api：用在请求的类上，表示对类的说明 tags="说明该类的作用，可以在UI界面上看到的注解" value="该参数没什么意义，在UI界面上也看到，所以不需要配置" @ApiOperation：用在请求的方法上，说明方法的用途、作用 value="说明方法的用途、作用" notes="方法的备注说明" @ApiImplicitParams：用在请求的方法上，表示一组参数说明 @ApiImplicitParam：用在@ApiImplicitParams注解中，指定一个请求参数的各个方面 name：参数名 value：参数的汉字说明、解释 required：参数是否必须传 paramType：参数放在哪个地方 · header --&gt; 请求参数的获取：@RequestHeader · query --&gt; 请求参数的获取：@RequestParam · path（用于restful接口）--&gt; 请求参数的获取：@PathVariable · body（不常用） · form（不常用） dataType：参数类型，默认String，其它值dataType="Integer" defaultValue：参数的默认值 @ApiResponses：用在请求的方法上，表示一组响应 @ApiResponse：用在@ApiResponses中，一般用于表达一个错误的响应信息 code：数字，例如400 message：信息，例如"请求参数没填好" response：抛出异常的类 @ApiModel：用于响应类上，表示一个返回响应数据的信息 （这种一般用在post创建的时候，使用@RequestBody这样的场景， 请求参数无法使用@ApiImplicitParam注解进行描述的时候） @ApiModelProperty：用在属性上，描述响应类的属性 1、@Api：用在请求的类上，说明该类的作用
tags="说明该类的作用"
value="该参数没什么意义，所以不需要配置"
示例：
@Api(tags="APP用户注册Controller") 2、@ApiOperation：用在请求的方法上，说明方法的作用
@ApiOperation："用在请求的方法上，说明方法的作用"
value="说明方法的作用"
notes="方法的备注说明"
示例：
@ApiOperation(value="用户注册",notes="手机号、密码都是必输项，年龄随边填，但必须是数字") 3、@ApiImplicitParams：用在请求的方法上，包含一组参数说明
@ApiImplicitParams：用在请求的方法上，包含一组参数说明
@ApiImplicitParam：用在 @ApiImplicitParams 注解中，指定一个请求参数的配置信息 name：参数名
value：参数的汉字说明、解释
required：参数是否必须传
paramType：参数放在哪个地方
· header --&gt; 请求参数的获取：@RequestHeader
· query --&gt; 请求参数的获取：@RequestParam
· path（用于restful接口）--&gt; 请求参数的获取：@PathVariable
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86541bc21f685c1b4777359bcf7ab74c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2ef31a9e4fdbc78e1c880ba11b0524a/" rel="bookmark">
			【可视化爬虫】scrapinghub 可视化抓取 portia环境搭建全过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、 install_deps：安装系统级依赖二、 install_splash: 安装splash三、 install_python_deps：安装python依赖四、 安装ember.js五、 安装并配置nginx六、 ember.js依赖安装 一、 install_deps：安装系统级依赖 【Ubuntu环境】
curl: Get a file from an HTTP, HTTPS or FTP serverlibxml2-dev: Development files for the GNOME XML librarylibxslt-dev:libgl1-mesa-dev: free implementation of the OpenGL API – GLX development fileslibgl1-mesa-glx: free implementation of the OpenGL API – GLX runtimelibglapi-mesa: free implementation of the GL API – shared librarylibgl1-mesa-dri: free implementation of the OpenGL API – DRI modulesnginx: small, but very powerful and efficient web server and mail proxypython-dev: header files and a static library for Python (default)python-mysql.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2ef31a9e4fdbc78e1c880ba11b0524a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a25b1e57103df3d7189002b7702bef5a/" rel="bookmark">
			JAVA实现FTP服务器上文件上传下载以及文件在线预览
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（一）介绍文件上传下载：
（1）前端思路：
用formData封装好file以及相关参数,然后l利用ajax请求往后台传数据
html的代码： &lt;input id="cm_file" type="file" name="upFileName"&gt; js代码: var formData = new FormData(); var cm_uploadFile = $('#cm_file',cmwes_page).get(0).files[0];//获取文件，这里cmwes_page可以不要，这是用来规定范围的 formData.append("file",cm_uploadFile); $.ajax({ url: '${rc.getContextPath()}/manage/cmWesData/saveCmWesData', type: 'POST', cache: false, data: formData, processData: false, contentType: false }).done(function(res) { }).fail(function(res) { }); （2）后台controller接受这个file类型的数据，然后传到service层进行处理
//这里的file就是我前端封装到formdata中的参数‘file’ @RequestMapping("saveCmWesData") @ResponseBody public HashMap&lt;String,Object&gt; saveCmWesData(@RequestParam("file") MultipartFile file, HttpServletRequest request) throws IOException { cmWesDataService.upFileToFtp(file,fileName,fileSize,username,material,materialtext,stcode, stcodeDesc,fileDesc,fileNameTwo,version); //然后在service层进行上传、下载、删除的操作 } （3）上传、下载、删除的操作
在上传的时候需要注意的是，把文件上传到ftp服务器的同时，也要把文件名，文件大小，文件类型保存到数据库中。
先定义一些全局变量
@Value("${uploadftp.path}") private String basePath ; @Value("${uploadftp.servername}") private String host ; @Value("${uploadftp.port}") private int port ; @Value("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a25b1e57103df3d7189002b7702bef5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f16c69a63de01786f73625aaa2987c0b/" rel="bookmark">
			Linxu安装eclipse以及遇到的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 首先安装eclipse，需要在你的虚拟机有一个.gc的文件，然后你进行解压，解压命令 tar ...就不多说了，
正常解压完了之后在终端敲命令就会打开eclipse（理想状态下...）
但是打不开呢？ 以及遇到的问题
1. 安装jdk了吗？
eclipse需要的是jdk1.8的支持，所以你需要去安装jdk，
提供安装JDK的教程：https://blog.csdn.net/qq_39705793/article/details/82953601
2. 都弄好了之后 通过 ./eclipse 去打开eclipse, 控制台报错：
bash: ./eclipse: /lib/ld-linux.so.2: bad ELF interpreter: 没有那个文件或目录
常用的安装因为系统软件位数问题，如:64位系统中安装了32位程序了，
是因为64位系统中安装了32位程序 解决方法：
yum install glibc.i686
3. 再次打开./eclipse
OpenJDK 64-Bit Server VM warning: If the number of processors is expected to increase from one, then you should configure the number of parallel GC threads appropriately using -XX:ParallelGCThreads=N
在虚拟机设置里调整一下处理器数量，把1变成2
3. 再次打开eclipse OpenJDK 64-Bit Server VM warning: You have loaded library /home/admin/eclips 这个就是你的eclipse与JDK版本不一致，将他们的版本都弄成一致就好了 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f16c69a63de01786f73625aaa2987c0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fefe3efc6951b84a7fa325ef4be9fc55/" rel="bookmark">
			Android 的ANR 问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、App Not Responding的类型 Input事件超过5s没有被处理完 KeyDispatchTimeout(5 seconds) 大概率 按键或触摸事件在特定时间内无响应， 主线程对输入事件5秒内没有处理完毕
PS：KeyDispatchTimeout --- 时间定义的地方 Akey or touch event was not dispatched within the specified time（按键或触摸事件在特定时间内无响应） 具体的超时时间的定义在framework下的 ActivityManagerService.java //How long we wait until we timeout on key dispatching. staticfinal int KEY_DISPATCHING_TIMEOUT = 5*1000 Service处理超时 ServiceTimeout(20 seconds) --小概率类型 ，20S Service在特定的时间内无法处理完成，主线程在Service的各个生命周期函数时20秒内没有处理完毕。
BroadcastReceiver处理超时，前台广播 10S，后台广播 60s BroadcastReceiver在特定时间内无法处理完成， 主线程在执行BroadcastReceiver的onReceive()函数时10秒内没有处理完毕
adb bugreprot xxx adb pull /data/anr/traces.txt xxx 一份完整的bugreport包含 adb logcat –b system system.log	包含ANR发生时间点信息、ANR发生前的CPU信息,还包含大量系统服务输出的信息	adb logcat –b system adb logcat –b main main.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fefe3efc6951b84a7fa325ef4be9fc55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8032aeac0105942a73136a856bcb746b/" rel="bookmark">
			【矩阵论】06——线性变换——基本概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本系列文章由Titus_1996 原创，转载请注明出处。 文章链接：https://blog.csdn.net/Titus_1996/article/details/83088462
本系列文章使用的教材为《矩阵论》（第二版），杨明，刘先忠编，华中科技大学出版社。
线性变换定义
总结要点：
首先变换是一种对应关系
这种对应关系是在同一个线性空间中的，即原像通过变换T作用的像仍在这个空间中。
若满足加法不变和数乘不变，则该变换为线性的。
所以，如果要证明T是线性变换，需要从是不是变换和变换是不是线性的两方面入手。
注：零元只能变换为零元，即像是零元，则原像也一定是零元。
线性变换的性质
注：线性变换能保持线性无关性不变，但不等保证线性相关性不变。
像空间与零空间
注：
像空间是线性变换之后的的像组成的空间，这是V的子空间。
零空间是当线性变换后像为零时，原像组成的空间，这也同样是V的子空间。
线性变换的秩与零度
变换运算
多个线性变换可构成新的变换，通过变换运算可简化：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49c8e2734989e9f4892b0943f1d980d3/" rel="bookmark">
			字符编码中ASCII、Unicode和UTF-8的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. ASCII码
我们知道，在计算机内部，所有的信息最终都表示为一个二进制的字符串。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从00000000到11111111。
上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为ASCII码，一直沿用至今。
ASCII码一共规定了128个字符的编码，比如空格"SPACE"是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的1位统一规定为0。
2、非ASCII编码
英语用128个符号编码就够了，但是用来表示其他语言，128个符号是不够的。比如，在法语中，字母上方有注音符号，它就无法用ASCII码表示。于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的é的编码为130（二进制10000010）。这样一来，这些欧洲国家使用的编码体系，可以表示最多256个符号。
但是，这里又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。比如，130在法语编码中代表了é，在希伯来语编码中却代表了字母Gimel (ג)，在俄语编码中又会代表另一个符号。但是不管怎样，所有这些编码方式中，0--127表示的符号是一样的，不一样的只是128--255的这一段。
至于亚洲国家的文字，使用的符号就更多了，汉字就多达10万左右。一个字节只能表示256种符号，肯定是不够的，就必须使用多个字节表达一个符号。比如，简体中文常见的编码方式是GB2312，使用两个字节表示一个汉字，所以理论上最多可以表示256x256=65536个符号。
中文编码的问题需要专文讨论，这篇笔记不涉及。这里只指出，虽然都是用多个字节表示一个符号，但是GB类的汉字编码与后文的Unicode和UTF-8是毫无关系的。
3.Unicode
世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。
可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是Unicode，就像它的名字都表示的，这是一种所有符号的编码。
Unicode当然是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字"严"。具体的符号对应表，可以查询unicode.org，或者专门的汉字对应表。
4. Unicode的问题
需要注意的是，Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。
比如，汉字"严"的unicode是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。
这里就有两个严重的问题，第一个问题是，如何才能区别Unicode和ASCII？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果Unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。
它们造成的结果是：1）出现了Unicode的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示Unicode。2）Unicode在很长一段时间内无法推广，直到互联网的出现。
5.UTF-8
互联网的普及，强烈要求出现一种统一的编码方式。UTF-8就是在互联网上使用最广的一种Unicode的实现方式。其他实现方式还包括UTF-16（字符用两个字节或四个字节表示）和UTF-32（字符用四个字节表示），不过在互联网上基本不用。重复一遍，这里的关系是，UTF-8是Unicode的实现方式之一。
UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。
UTF-8的编码规则很简单，只有二条：
1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。
2）对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。
下表总结了编码规则，字母x表示可用编码的位。
Unicode符号范围 | UTF-8编码方式 (十六进制) | （二进制） --------------------+--------------------------------------------- 0000 0000-0000 007F | 0xxxxxxx 0000 0080-0000 07FF | 110xxxxx 10xxxxxx 0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx 0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
下面，还是以汉字"严"为例，演示如何实现UTF-8编码。
已知"严"的unicode是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800-0000 FFFF），因此"严"的UTF-8编码需要三个字节，即格式是"1110xxxx 10xxxxxx 10xxxxxx"。然后，从"严"的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，"严"的UTF-8编码是"11100100 10111000 10100101"，转换成十六进制就是E4B8A5。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49c8e2734989e9f4892b0943f1d980d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12ee1a1b548fdc0f0979ac18d735b650/" rel="bookmark">
			springboot框架开发微信公众号（四）之自定义菜单的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于自定义菜单，微信为我们提供了几个接口分别是创建、查询和删除。我们平时使用最多的就是创建菜单了，往往我们执行了创建菜单的代码后，菜单并不会当即在我们关注过的公众号上显示出来，我们可以通过重新关注的方法，来查看我们创建或更改后的菜单。下面就来跟笔者来学一学这些接口的使用方法吧
一、由于这几个接口都是https协议，所以我们首先要能让我们的程序可以请求https。 对于https请求，我们需要一个证书信任管理器， 这个管理器类需要自己定义，但需要实现X509TrustManager接口代码如下:
public class MyX509TrustManager implements X509TrustManager{ /** * 该方法用于检查客户端的证书，若不信则抛出异常 * 由于我们不需要对客户端进行认证，可以不做任何处理 */ @Override public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateEncodingException{ } /** * 该方法用于检验服务器端的证书，若不信任则抛出异常 * 通过自己实现该方法，可以使之信任我们指定的任何证书 * 在实现该方法时，也可以不做任何处理，即一个空的方法实现 * 由于不会抛出异常，它就会信任任何证书 */ @Override public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateEncodingException{ } /** * 返回收信任的X509证书数组 */ @Override public X509Certificate[] getAcceptedIssuers(){ return null; } 发起https请求工具类
/** * * @Description: 发起https请求并获取结果 * @Parameters: requestUrl 请求地址。 需要写全地址，即前边的http必须写上，不能只写www.baidu.com这样的。 * requestMethod 请求方式（GET、POST） * outputStr 我们在发起请求的时候传递参数到所要请求的服务器， * 要传递的参数也要看接口文档确定格式，一般是封装成json或xml.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12ee1a1b548fdc0f0979ac18d735b650/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e0861f65f6376c9328926c547d770aa/" rel="bookmark">
			电脑显示屏的选择与测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		显示屏的参数很多，但是一般只需要关注几个参数就行。
1.大小：屏幕大多为23.8、27和32英寸。
2.分辨率：1K、2K、4K。分辨率的选择跟屏幕大小有关，23.8的可选择1K和2K屏，27的选择1K和2K，32的选择2K和4K。
3.刷新率：玩游戏需要看此条参数，其他可忽略。
屏幕简单的测试（以win10为例，不借助其他软件）：
1.右键==&gt;查看==&gt;把“显示图标”去掉（任务栏选择隐藏）；
2.暗点检测：右键==&gt;个性化==&gt;背景==&gt;纯色==&gt;选择“白色”（看有无黑点）；
3.明点检测：右键==&gt;个性化==&gt;背景==&gt;纯色==&gt;选择“黑色”（看有无亮点）；
4.漏光检测：在上述步骤下保持背景黑色，并将屏幕放在暗环境下（一般都有微微的漏光现象，不严重即可）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0160d17f8e4c8b520a069b709ae18a7b/" rel="bookmark">
			神经网络相关的笔试题目集合（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在找工作的过程中发现好多公司没有专门的、传统的图像处理岗位，所以只能参加算法类的笔试甚至AI类的笔试。在AI的笔试中几乎全是关于神经网络的问题，其实也都是很基础的一些问题，如果事先做了准备，可以从容应对。而对于我这种从传统图像处理算法向深度学习靠拢的新手，不失为一种很好的入门方法。
既然是考察神经网络，激活函数activation function作为模拟人脑中神经元之间的激活/抑制的关键，经常会被考察。问：常用的激活函数有什么，各自有什么特点。关于这个问题可以从网上找到很多答案，比如参考链接1和2，主要讲了常见的激活函数Sigmoid、tanh、ReLu、Leaky ReLus。Sigmoid范围在0~1（这也是具有压缩数据功能的原因），所以Tanh=2*Sigmoid(2x)-1的范围在[-1,1]，tanh读作Hyperbolic Tangent，解决了Sigmoid的均值非0的问题（这会导致后一层的神经元将得到上一层输出的非0均值的信号作为输入），但是梯度消失的问题更加严重（红色梯度曲线下降得更快，参数的学习要靠梯度的后向传播）。而ReLU=max(0,x),在输入很大的情况下梯度也不会像Sigmoid一样饱和，且由于计算简单，利用SGD（随机梯度下降）算法收敛速度更快，但缺点是在输入为复数的时候激活函数直接为0，造成所谓的神经元坏死，不能给之后的神经元传递信息，这时就必须十分小心learning Rate的选取，步长不能太大，也可以使用adagrad自动调节learningrate,同时参数的初始化也很重要，一般使用Xavier初始化。Leaky ReLU是为了解决ReLU神经元坏死的问题的，在输入小于0时，输出不再是0，而是一条斜率较小（a）的通过原点的直线。但是现在还没有足够的理论证明Leaky ReLU一定好于ReLU。也可以将斜率a也作为参数进行训练，即PReLU，kaiming He在2015年的论文中就使用了Parametric ReLU。
Randomized Leaky ReLU. Randomized Leaky ReLU 是 leaky ReLU 的random 版本, 其核心思想就是，在训练过程中，a是从一个高斯分布中随机出来的，然后再在测试过程中进行修正。
这么多的激活函数都有一个共同点，就是他们都是非线性的。抛开用激活函数去模拟神经元的仿生想法，激活函数的作用在数学上到底有什么意义呢？从网上资料看就是为了加入非线性因素。因为感知机其实是最原始的神经网络，同时感知机是一个判别模型，可用于分类，如果没有激活函数，我们就无法实现线性不可分问题，包括简单的异或XOR问题。如果没有激活函数，多个感知机的组合得到的仍然是一个线性分类器，仍然无法解决非线性问题。
参考链接2中知乎有人的回答中提到Google的论文Batch normalization: Accelerating deep network training by reducing internal covariate shift尽可能保证每一层网络的输入具有相同的分布，解决了Sigmoid的saturate的问题，但效果仍然没有ReLU好。正好笔试过程中也遇到了Batch Normalization的问题，那么接下来就看一下它到底为何物。
先来说归一化，归一化是对于输入特征来说的，特征可能是多维的，同时他们之间的量纲可能不一样，就会造成不同维度的大小存在很大的差异，这对于训练来说不太友好，因为我们设置的learning rate不可能适应所有的维度，会导致训练过慢。
归一化不仅能加快训练速度（最快梯度下降法的求解），有时候还可以提高精度。比如KNN分类器中要求样本之间的距离，归一化使得不同维度对距离造成的影响大小相同，而不会使得结果主要取决于某一维度。
归一化常用方法有最大最小归一化（线性归一化），max和min值不稳定时可以取常数；z-score标准化（均值方差标准化），归一化后的数据符合标准正态分布，即进行白化whiten；函数转化（非线性归一化，函数可使用对数、正切等）。
其实之前提到的归一化是相对于机器学习领域说的。在深度学习中由于涉及到了多层的网络模型，归一化会显得更加重要，因为机器学习中有一个数据之间是独立同分布IID的假设（这样才能通过训练样本预测新的数据），而神经网络中由于底层参数的更新会影响之后高层的输入，这在paper中被称为Internal Covariate Shift（ICS）问题。所以我们就需要对每一层的输出都进行归一化。但是底层的输出被归一化也意味着之前学到的特征分布被破坏了，所以batch Normalization（BN）又加入了变换重构，引入了可学习参数缩放因子和平移因子。
这里简单介绍一下batch的概念。首先，我们的训练数据集是有限的，我们会使用这一训练数据集训练多次，相对于巩固学习，但训练太多次又会导致过拟合。每次训练后参数完成一次更新，称这一过程是一个epoch。而在每次epoch中，我们把训练数据集分成几个较小的子集，这就是batch，子集的大小是batch_size。数据集较大不利于通过训练网络，分成子集有利于加快训练。训练数据集分成子集，epoch也分成了几个iteration。根据batch_size的选择，可以把训练情况分成三种，第一种是batch取最大值，即Full Batch Learning，一次性将训练数据通过训练网络，这只适用于训练数据少的情况。第二种是另外一个极端，batch_size取1，即Online Learning在线学习/Stochastic随机学习，这种情况难以收敛，因为每次梯度方向以各自样本的梯度方向收敛。我们看到batch_size其实是在内存利用率和内存容量之间的平衡，增大了batch_size，相对于通过并行化提高了内存利用率，但占用的内存也变大。第三种是Mini-batch，在之前两个极端情况下选择一个平衡点。BN就是基于了Mini-batch SGD。BN适用于mini-batch样本量较大且与各mini-batch分布相近似的场景下（训练前需进行充分的shuffle）。不适用于动态网络结构和RNN。
结合前面讲到的激活函数，BN在归一化的同时还可以解决Sigmoid函数的梯度饱和的问题。因为经过BN后，通过激活函数的输入是标准正态分布，经过非线性变换时的输入大概率保持在0均值附近，反向传播时梯度值较大，从而避免了梯度消失。BN增加scale和shift的原因也可以通过对激活函数的输入的处理来说明。因为在进入激活函数之前进行了归一化，将输入集中在了Sigmoid中心附近，而Sigmoid函数虽然本身是非线性函数，但是中心附近是接近线性的，这样一来我们就失去了非线性函数的优势，而补救措施就是增加scale和shift元素。BN的细节还是要看论文《Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift》。
总结一下BN的优势：1.提升了训练速度（避免了梯度双端饱和，保证了IID）2.类似于Dropout，可以防止过拟合（加入了随机性的scale、shift？）3.对初始化的要求没有那么高（因为不必使用ReLU？即使使用ReLU也可以避免梯度为0），可以使用较大的学习率。
除了BN，还有其他的归一化方式。BN针对的是单一的神经元，Layer Normalization考虑一层的信息，并将该层的均值和方差作为归一化标准。weight normalization则将参数也进行了规范化。
Reference：
面面观https://blog.csdn.net/cyh_24/article/details/50593400神经网络激励函数的作用是什么？有没有形象的解释？ - 论智的回答 - 知乎https://www.zhihu.com/question/22334626/answer/465380541https://blog.csdn.net/yangdashi888/article/details/78015448激活函数的作用https://blog.csdn.net/program_developer/article/details/78704224DeeplearningAI实用层面https://www.cnblogs.com/cloud-ken/p/7709447.html归一化优点和方法和结构https://blog.csdn.net/qq_28618765/article/details/78221571Batch_size知乎https://www.zhihu.com/question/32673260深度学习29https://blog.csdn.net/hjimce/article/details/50866313Normalization方式https://blog.csdn.net/qq_24153697/article/details/79880202 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6eee64c293bf266444e7f06521faed0e/" rel="bookmark">
			### Error updating database. Cause: com.microsoft.sqlserver.jdbc.SQLServerException: 必须声明标量变量 &#34;@P23@...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,【??】,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
### Error updating database. Cause: com.microsoft.sqlserver.jdbc.SQLServerException: 必须声明标量变量 "@P23@P24"。
### The error may involve com.foen.cloud.mapping.CustMemoMapper.insert-Inline
### The error occurred while setting parameters
### SQL: insert into ERP_BASIC_CUS_Memorandum(djno,custno,custname,sales_company_projectno,Projectname,Contact_phone,contractno,Contact,Contact_account,ywy,qyjl,kfzy,qht,shop_number,project_area,qyzzwj,if_idcard,sales_area,hb,province,prefecture_level_city,county_level_city,Delivery_address,aluminum_lb,aluminum_fs,weight_jsfs,aluminum_lb_shop,pj_price_type,if_deposit,contract_dt,if_js_days,receivment_no,ztz,bhm,ssm,fwbz,gsc,zzm,bz_number,qtyq,bzfs,all_number,out_day,if_stop,begin_date,end_date,validity,ex_ysdm,kaifa_company,yfzf,wd_xl,lrj,lrj_price,cust_class,modifier,modify_dt,oper,date1)VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,??,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
### Cause: com.microsoft.sqlserver.jdbc.SQLServerException: 必须声明标量变量 "@P23@P24"。
; uncategorized SQLException for SQL []; SQL state [S0002]; error code [137]; 必须声明标量变量 "@P23@P24"。; nested exception is com.microsoft.sqlserver.jdbc.SQLServerException: 必须声明标量变量 "@P23@P24"。
转载于:https://www.cnblogs.com/gzhbk/p/9792112.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8ae7f6a591013b0160d7966ad8e5f1b/" rel="bookmark">
			application/json和application/x-www-form-urlencoded的数据提交方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		application/json和application/x-www-form-urlencoded对于数据的格式化 application/x-www-form-urlencoded方式是Jquery的Ajax请求默认方式，这种方式的好处就是浏览器都支持，在请求发送过程中会对数据进行序列化处理，以键值对形式？key1=value1&amp;key2=value2的方式发送到服务器，如果用Jquery，它内部已经进行了处理，如果自己写原生的Ajax请求，就需要自己对数据进行序列化。 application/json，告诉服务器请求的主题内容是json格式的字符串，服务器端会对json字符串进行解析，这种方式的好处就是前端人员不需要关心数据结构的复杂度，只要是标准的json格式就能提交成功，application/json数据格式越来越得到开发人员的青睐。
application/json 与 application/x-www-form-urlencoded的比较 application/x-www-form-urlencoded 提交请求示例
curl -X POST 'http://localhost:8080/formPost' -d 'id=1&amp;name=foo&amp;mobile=13612345678'
抓包结果：
application/json 提交请求示例
curl -X POST -H "Content-Type: application/json" 'http://localhost:8080/jsonPost' -d '{"id":2,"name":"foo","mobile":"13656635451"}'
抓包结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58213aab51b1a3f8ab967b3d608ffc6c/" rel="bookmark">
			TensorFlow中的计算图学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介： 官网上对TensorFlow的介绍是： 一个使用数据流图(data flow graphs)技术来进行数值计算的开源软件库 （有点类似于这样 ：） TensorFlow包含构建数据流图与计算数据流图等基本步骤，图中的节点表示数学操作，图中连结各节点的边表示多维数组，即：tensors（张量）。 张量是TensorFlow最核心的组件，所有运算和优化都是基于张量进行的。张量是基于向量和矩阵的推广，可以将标量看为零阶张量，矢量看做一阶张量，矩阵看做二阶张量。 tensorflow程序一般分为两个阶段： 1、定义计算图所有的计算 2、在session中执行计算 在这几行代码中完全体现了这两项操作
（ 还额外包括了 ：
将数据表示为tensors；
使用Variables来保持状态信息；
分别使用feeds和fetches来填充数据和抓取任意的操作结果； ）
import tensorflow as tf a =tf.placeholder("float") b =tf.placeholder("float") y = tf.multiply(a,b) sess = tf.Session() print(sess.run(y, feed_dict={a: 3, b: 3})) --------------------- 转载于 作者：Jasen_Fu 张量的阶数： TensorFlow用张量表示所有的数据，张量可看成一个n维的数组或列表，在图中的节点之间流通。张量的维数称为阶，在另一片文中有相应的一些介绍。
计算图 在tensorflow程序中，系统会自动给参数一个默认的计算图，可以通过tf.get_default_graph()函数获取。
import tensorflow as tf x = tf.constant(10) y = tf.constant(15) print(x.graph) 结果为： &lt;tensorflow.python.framework.ops.Graph object at 0x000001AE613E8E80&gt; tensorflow可以通过tf.Graph函数生成新的计算图。不同计算图上的张量和运算都不会共享
g1=tf.Graph() with g1.as_default(): # 在计算图g1中定义变量'v',并设置初始值为0。 v=tf.get_variable('v',initializer=tf.zeros_initializer()(shape = [1])) g2=tf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58213aab51b1a3f8ab967b3d608ffc6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46fb5762150ed80ca9b9b8cfba8f8ddf/" rel="bookmark">
			微信小程序如何实现切换主题（更改皮肤）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：基本原理
因为小程序中没有样式引入的概念，所以不能像传统的html中那样改变link标签的href值来达到切换样式文件。
在小程序中，可以在类名中定义变量，通过动态改边类名，最终达到修改样式的目的。
二：具体实现
在wxml文件中：
其中的变量theme来自welcome.js中，theme的值决定着使用哪个样式来影响页面
在wxss文件中：
这里需要把所有的样式文件都引入进来，因为小程序里不能像htnml中那样改边link标签的动态切换href值。
举例：例如在welcome.js中theme的值为blue,那么在上图wxml中view的类名最终为content-blue,
因此welcome-blue中的样式就会生效。其他样式文件的则不会生效。
最终实现了主题切换
三 总结
在实现小程序主题切换的时候，需要把当前页面的所有的样式文件都引入进来。我们也可以把这些样式文件写在一个wxss文件中，不过那样样式不太好区分，后期维护会有困难。
缺点：
在wxml中使用变量的方式编写页面，会增加开发时间。
另外，在小程序中组件只能继承页面的字体，背景等极少数的样式，如果添加主题切换功能，需要在每个组件在其内部重新书写一套样式，会增加组件的开发时间。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77791b52911b2bfe2dae24a4c0909002/" rel="bookmark">
			vue&#43;axios&#43;promise实际开发用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		axios它是基于promise的http库，可运行在浏览器端和node.js中,然后作者尤雨溪也是果断放弃了对其官方库vue-resource的维护，直接推荐axios库，小编我也是从vue-resource转换过来的，差别说不来，我们讲一下axios在实际开发中的用法 axios特点 1.从浏览器中创建 XMLHttpRequests
2.从 node.js 创建 http 请求
3.支持 Promise API
4.拦截请求和响应 （就是有interceptor）
5.转换请求数据和响应数据
6.取消请求
7.自动转换 JSON 数据
8.客户端支持防御 XSRF
安装axios和qs npm i axios --save npm i qs--save 创建项公共模块API 我是用vue-cli创建的项目在src-&gt;util-&gt;api.js(公共请求模块js)
引入axios和qs
import axios from 'axios' 有时候向后端发送数据，后端无法接收,考虑使用qs模块
import qs from 'qs' 判定开发模式
if (process.env.NODE_ENV == 'development') { axios.defaults.baseURL = '/api'; }else if (process.env.NODE_ENV == 'debug') { axios.defaults.baseURL = 'http://v.juhe.cn'; }else if (process.env.NODE_ENV == 'production') { axios.defaults.baseURL = 'http://v.juhe.cn'; } 全局设置头部信息
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77791b52911b2bfe2dae24a4c0909002/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4aebde6ecd950fc6f61c2ddf14701592/" rel="bookmark">
			如何在Win7中查看安装软件的文件夹位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【时间】2018.10.14
【题目】如何在Win7中查看安装软件的文件夹位置
概述 在Win7系统中，想要知道安装软件的文件夹位置，如果你能够找到软件的快捷方式、或者可以在开始菜单中找到它、或者可以通过Win7的搜索功能找到软件，那么你就可以轻易地通过右键，查看文件具体位置找到安装软件的文件夹。
倘若无法找到，而只能打开它，又该怎么办呢？这时你可以通过系统的 任务管理器找到它的安装位置。具体如下：
一、通过 任务管理器查看软件的安装位置 下面以查看Visio软件的位置为例。
1、打开软件
2、回到桌面，在桌面底部的任务栏上单击鼠标右键选择“任务管理器”，点击并打开。
3、然后我们在任务管理器里查看正在运行的应用，在正在运行的应用里查找到我们刚打开并需要查看安装位置的软件。
4、右键，点击“转到进程“”
5、右键，点击“打开文件位置“即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2b96a494eea36c81d815ab01a5a736f/" rel="bookmark">
			数据中心EOR/MOR/TOR布线概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据中心机房平面布局通常采用矩形结构，为了保证制冷效果，通常将10 至 20 个机柜背靠背并排放置成一行，形成一对机柜组（又称为一个POD）。POD中的机柜都采用前后通风模式，冷空气从机柜前面板的吸入并从后部排出，由此在机柜背靠背摆放的POD中间形成 “热通道”，相邻的两个POD之间形成“冷通道”。热通道正对CRAC（机房空调），热空气沿热通道流回CRAC，再开始新一次循环。
每个POD由服务器机柜和网络机柜组成，其中服务器机柜占多数。由于服务器的形态差异（机架式服务器、刀片服务器），POD中服务器机柜和网络机柜的布线方式也存在差异。
一、机架式服务器布线方式： EOR（End of Row）
EOR是数据中心综合布线最传统的方法，接入交换机集中安装在一列机柜端部的机柜（交换机机柜）内，通过水平线缆以永久链路方式连接设备柜内的主机/服务器/小型机设备。
交换机EOR布线方式最为常见。通常在服务器和接入交换机安装以前，服务器机柜到网络机柜的布线施工已经完成，设备（服务器/交换机）安装和跳线工作都在服务器机柜内和网络机柜内进行。
二、机架式服务器的布线方式：MOR（Middle of Row）
MOR布线是对EOR布线方式的改进，主要区别是在摆放列头机柜的位置，MOR是将其放在每一列机柜的中间 。MOR方式的网络机柜部署在POD的两排机柜的中部，由此可以减少从服务器机柜到网络机柜的线缆距离，简化线缆管理维护工作。MOR的设置方式可以使得线缆从中间位置的列柜向两端布放，降低线缆在布线通道出入口的拥堵现象，并减少线缆的平均长度，也适合实施定制长度的预连接系统，而且对布线机柜内配线设备的交叉连接和管理较EOR 要方便 。
三、机架式服务器的布线方式： TOR（Top of Rack）
交换机TOR布线方式是对EOR/MOR方式的扩展，采用TOR布线时，POD中每个服务器机柜的上端部署1-2台两台接入交换机，机架式服务器通过跳线接入到机柜内的交换机上，交换机上行端口通过铜缆或光线接入到EOR/MOR的网络机柜中的汇聚交换上。如图所示
TOR布线方式简化了服务器机柜与网络机柜间的布线，从每个服务器机柜到EOR/MOR的网络机柜的光纤或铜缆数量较少（4-6根）。
机柜中服务器的密度高。对于标准的19英寸宽，42U高的机柜，如果采用交换机TOR布线方式，则每个机柜可部署15-30台1U高度的机架式服务器（具体数量需要考虑单台服务器的功耗和机柜的电源输出功率）。
随着用户数据业务需求的猛增，数据中心机房服务器密度越来越高，虚拟化和云计算等新技术趋势日益流行，使得服务器对应的网络端口大大增加，并且增加了管理的复杂性，另外以太网（LAN）与光纤存储区域网络（SAN）的融合也越来越常见，这就必然要求一种新的网络拓扑结构与之相对应。在云计算的大潮下，这种分布式架构的业务扩展性极强，要求的服务器数量也越来越多。海量的服务器数量要求充分利用数据中心机柜空间的同时，海量的业务数据也需要更快更直接的高性能链路把数据传送到网络核心。在这样的趋势下，显然TOR更加适用，在业务迅速扩展的压力下，TOR的方式可以更好的实现网络的更快速扩展。
四、对比
EOR布线的缺点：
从服务器机柜到网络机柜的铜缆多（约有20-40根铜缆），且距网络机柜越远的服务器机柜的铜缆，在机房中的布线距离越长，由此导致线缆管理维护工作量大、灵活性差。
TOR布线的缺点：
1、可能造成端口浪费：一直以来，TOR被诟病最多的就是交换机端口冗余问题。
每个服务器机柜受电源输出功率限制，可部署的服务器数量有限，由此导致机柜内交换机的接入端口利用率不足。在几个服务器机柜间共用1-2台接入交换机，可解决交换机端口利用率不足的问题，但这种方式增加了线缆管理工作量。
TIA TR-42 通信布线系统工程委员会副主席Valerie Maguire曾介绍过一个真实案例，某用户共有336个服务器机柜，每个机柜配置2台48端口的TOR交换机和40台服务器，这就使得每个交换机有8个端口是空闲的，整个网络就有112整台交换机端口数量都是空闲的。这些超额购买的设备和3年维护的成本总计将达到112万美金。如果考虑机柜受供电能力约束的真实情况，每个机柜能放置的服务器数量远小于40台，则浪费的总额将更高。而若采用集中式布线只需花费 27.5万美金，通过在布线上的投资就能换来极大的交换机等设备的节约。
从网络设计考虑，TOR布线方式的每台接入交换机上的VLAN量不会很多，在网络规划的时候也要尽量避免使一个VLAN通过汇聚交换机跨多台接入交换机，因此采用TOR布线方式的网络拓扑中，每个VLAN的范围不会太大，包含的端口数量不会太多。但对于EOR布线方式来说，接入交换机的端口密度高，在网路最初设计时，就可能存在包含较多端口数的VLAN。
2、成本未必节省
TOR方式得到推广的一个重要理由，是节省了大量的布线成本和制冷成本，简化结构，使得机房更加绿色节能。但深入研究会发现，布线成本减少的代价是网络接入设备成本的增加和端口冗余，并且缩减也只是水平铜缆布线的部分，TOR对于光纤的要求比传统布线方式更多。在初期建设成本之外，后期的管理和扩展问题有可能变得更加复杂。
3、增加管理难度：TOR方式的接入交换机数量多，EOR方式的接入交换机数量少，所以TOR方式的网络设备管理维护工作量大。
五、刀片服务器的布线方式
集成刀片交换机的刀片服务器在进行机柜安装时，不需要考虑机柜内从服务器到接入交换机/或配线架的跳线，只需考虑刀片交换机上行端口的配线方式即可。集成交换机模块的刀片服务器主要采用EOR/MOR布线方式，但这种EOR布线方式与机架式服务器TOR布线方式的特点基本相同。服务器在服务器机柜内完成网络接入，从服务器机柜到EOR/MOR网络机柜的电缆主要是刀片交换机上行汇聚交换机的光线，而且数量比较少。但刀片服务器的计算单元的密度比机架式服务器更高，所以对单个机柜的电源输出功率以及机房制冷环境的要求也更高。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/279/">«</a>
	<span class="pagination__item pagination__item--current">280/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/281/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>