<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1434095936d318d6d7ab26fab5cb927f/" rel="bookmark">
			Invalid bound statement (not found): com.lxz.springcloud.dao.PaymentDao.getPaymentById
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 报错的可能原因：
检查xml文件所在package名称是否和Mapper interface所在的包名 或者 mapper的namespace写的不对！！！注意修改。UserDao的方法在UserDao.xml中没有，然后执行UserDao的方法会报此UserDao的方法返回值是List,而select元素没有正确配置ResultMap,或者只配置ResultType!如果你确认没有以上问题,请任意修改下对应的xml文件,比如删除一个空行,保存.问题解决看下mapper的XML配置路径是否正确最坑的在这里！！如果检查上面都没问题，那么清理target目录就好了！！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae71cfa4e69c41e701b4d6887fc36a90/" rel="bookmark">
			Linux软件包管理、进程管理、用户权限、特殊权限管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
centos和Ubuntu的软件包管理常见命令 进程管理
用户权限管理（umask）
特殊权限（SetUID、SetGID、Sticky BIT）
SUID
SGID
SBIT
Centos和Ubuntu的包管理常见命令 操作\系统UbuntuCentOS包管理命令apt\apt-cache\apt-getyum更新已安装的包apt upgradeyum update搜索安装包apt search packageyum search [all] package查看已安装的包的信息apt show packageyum info package更新软件库apt updateyum update显示包的当前安装状态dpkg -s packageyum info package安装包apt install [-y] packageyum install [-y] package从本地文件安装1、安装本地的包无需补充安装依赖文件：dpkg -i package.deb 2、安装 gdebi，然后使用 gdebi 安装package.deb并处理缺失的依赖：apt install -y gdebi &amp;&amp;gdebi package.debyum install package.rpm删除包apt remove package [-- purge]yum remove package列出所有apt/yum库中的安装包apt listyum list [匹配名]显示所有的可安装的包apt listyum list available [匹配名]显示所有可更新的已安装的软件包apt list --upgradeableyum list updates显示已安装的包apt list--installedyum list installed显示最近安装的apt showyum list recent清除本地缓存apt cleanyum clean all列出包的依赖apt depends packageyum deplist package 进程管理 ps -ef/aux 查看进程 USER启动这些进程的用户PID进程ID%CPU进程的CPU占比%MEN占用内存的百分比VSZ占用虚拟内存的大小/KBRSS占用物理内存的大小/KBSTAT程序目前的状态R/S/T/Z/D程序正在运作/休眠/停止/僵尸/不可中断&lt;/N/L/s/l/+表示进程运行在最高优先级/最低优先级/有页面锁定在内存/是控制进程/是多线程/运行在前台START该process被触发启动的时间TIME该process实际使用CPU运作的时间COMMAND程序的实际指令 uptime 服务器当前时间 运行时长 当前用户数 负载均衡 top 动态获取系统当前状态 第1行系统时间、运行时间、登录终端数、系统负载（三个数值分别为1分钟、5分钟、15分钟内的平均值，数值越小意味着负载越低）第2行进程总数、运行中的进程数、睡眠中的进程数、停止的进程数、僵死的进程数第3行用户占用资源百分比、系统内核占用资源百分比、改变过优先级的进程资源百分比、空闲的资源百分比等第4行物理内存总量、内存使用量、内存空闲量、作为内核缓存的内存量第5行虚拟内存总量、虚拟内存使用量、虚拟内存空闲量、已被提前加载的内存量第6行PID/USER/PR/NI/VIRT/RES/SHR/S/%CPU/%MEN/TIME+/COMMANDPR进程优先级 kill [-9] PID [强制]结束进程 用户权限管理（umask） linux通过配置权限来控制不同用户对不同文件是否可以进行读写执行。每个用户被创建都会默认被赋予一个权限码，每个文件、目录被创建也会默认赋予初始权限，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae71cfa4e69c41e701b4d6887fc36a90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4b4c31115dc6fb57df8f100599e27fe/" rel="bookmark">
			关于redis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springboot引入redis: springboot中引入redis，在pom.xml文件中引入redis的包即可。
&lt;!-- redis 缓存操作 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; redis实现点赞_java小白@me的博客-CSDN博客
Springboot 使用redis检测浏览量，评论量，点赞量的变化并完成与mysql的交互（有具体实现，有具体需求）-CSDN博客
在线博客系统——评论（redis incr自增实现增加评论数）_redis实现评论-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab5e844e1c6c971b4f418458454437c5/" rel="bookmark">
			【自学必备书籍】Python入门到进阶书籍推荐！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 经典书籍入门书籍进阶书籍读者福利1、Python所有方向的学习路线2、Python课程视频3、精品书籍4、清华编程大佬出品《漫画看学Python》5、Python实战案例6、互联网企业面试真题 经典书籍 在线网站教程虽好，但是有的人还是喜欢纸质的书籍，尤其是一些经典书籍，是无论如何也无法被替代的，下面我们就来介绍一些经典书籍
入门书籍 根据豆瓣评分的高低，这里介绍了一些经典入门书籍，大家根据自身情况选择尝试
《Python编程：从入门到实践（第二版）》
非常经典且非常基础的 Python 入门书籍，本书深入浅出，从 Python 的基础语法到 Python 2D 游戏编程，Web 开发等都一一讲解到位，帮读者解决常见编程问题和困惑。
《Python编程快速上手》
本书是一本面向实践的 Python 编程实用指南。本书的目的，不仅是介绍 Python 语言的基础知识，而且还通过项目实践教会读者如何应用这些知识和技能。本书的首部分介绍了基本 Python 编程概念，第二部分介绍了一些不同的任务，通过编写 Python 程序，可以让计算机自动完成它们。第二部分的每一章都有一些项目程序，供读者学习。每章的末尾还提供了一些习题和深入的实践项目，帮助读者巩固所学的知识，同时附录部分还提供了所有习题的解答。
《笨办法学 Python 3》
本书是一本 Python 入门书，适合对计算机了解不多，没有学过编程，但对编程感兴趣的读者学习使用。这本书以习题的方式引导读者一步一步学习编程，从简单的打印一直讲到完整项目的实现，让初学者从基础的编程技术入手，最终体验到软件开发的基本过程。
《Python基础教程（第3版）》
本书包括 Python 程序设计的方方面面：首先从 Python 的安装开始，随后介绍了 Python 的基础知识和基本概念，包括列表、元组、字符串、字典以及各种语句；然后循序渐进地介绍了一些相对高级的主题，包括抽象、异常、魔法方法、属性、迭代器；此后探讨了如何将 Python 与数据库、网络、C语言等工具结合使用，从而发挥出 Python 的强大功能，同时介绍了 Python 程序测试、打包、发布等知识；最后，作者结合前面讲述的内容，按照实际项目开发的步骤向读者介绍了10个具有实际意义的 Python 项目的开发过程。
《Python学习手册（第4版）》
Google 和 YouTube 由于 Python 的高可适应性、易于维护以及适合于快速开发而采用它。如果你想要编写高质量、高效的并且易于与其他语言和工具集成的代码，《Python学习手册：第4 版》将帮助你使用 Python 快速实现这一点，不管你是编程新手还是 Python 初学者。本书是易于掌握和自学的教程，根据作者 Python 专家 Mark Lutz 的著名培训课程编写而成。
如果你也喜欢编程，我收集的这份【最新全套Python学习资料】，包含从基础的python脚本到web开发、爬虫、数据分析、数据可视化、机器学习等，非常适合新手小白，可以帮你少走很多弯路！扫描下方二维码免费获取
进阶书籍 这里介绍进阶书籍，也就是有了一定的编程或者 Python 基础，但在实际工作中仍然有许多小问题不知道怎么解决的朋友，可以看看这里.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab5e844e1c6c971b4f418458454437c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90308daf027e632e933967f4033539c5/" rel="bookmark">
			【GPU】linux 安装、卸载 nvidia 显卡驱动、cuda 的官方文档、推荐方式（runfile）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 显卡驱动1.1. 各版本下载地址1.2. 各版本文档地址1.3. 安装、卸载方式 2. CUDA2.1. 各版本下载地址2.2. 各版本文档地址2.3. 安装、卸载方式2.4. 多版本 CUDA 切换方式 1. 显卡驱动 1.1. 各版本下载地址 https://www.nvidia.com/Download/Find.aspx?lang=zh-cn
1.2. 各版本文档地址 在下载页面选择具体驱动版本后，在 其他信息 框即可找到 README 文档链接
1.3. 安装、卸载方式 以 535.129.03 版本为例（文档地址：https://download.nvidia.com/XFree86/Linux-x86_64/535.129.03/README）
在 Chapter 4. Installing the NVIDIA Driver 安装章节中即可看到:
# 下载后的安装命令 sudo sh NVIDIA-Linux-x86_64-535.129.03.run # 卸载命令 sudo sh NVIDIA-Linux-x86_64-535.129.03.run --uninstall 2. CUDA 2.1. 各版本下载地址 https://developer.nvidia.com/cuda-toolkit-archive
推荐使用 runfile 安装包。
2.2. 各版本文档地址 https://developer.nvidia.com/cuda-toolkit-archive
2.3. 安装、卸载方式 以 11.8 版本为例（文档地址：https://docs.nvidia.com/cuda/archive/11.8.0/）
在 Installation Guide Linux - 8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90308daf027e632e933967f4033539c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4112105ab62254cf3072c61b9201367/" rel="bookmark">
			2023年四川省职业院校技能大赛 高职组“区块链技术应用”赛项 样题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
背景描述
模块一：区块链产品方案设计及系统运维（35 分）
任务 1-1：区块链系统部署与运维（25 分）
子任务 1-1-1： 搭建区块链系统并验证（8 分）
子任务 1-1-2：区块链管理平台部署与验证（8 分）
子任务 1-1-3：区块链系统节点运维（5 分）
子任务 1-1-4：区块链系统管理平台运维（4 分）
任务 1-2：区块链系统测试（10 分）
模块二：智能合约开发与测试（30 分）
任务 2-1：智能合约开发（20 分）
任务 2-2：智能合约测试（10 分）
模块三：区块链应用系统开发（30 分）
任务 3-1：区块链应用前端功能开发（10 分）
任务 3-2：区块链应用后端功能开发（20 分）
背景描述 在供应链金融这个万亿级市场中，区块链正在快速商业化落地， 助力产业革新。基于区块链的供应链金融业务的理念是：以源自企业 的应收账款为底层资产，通过区块链技术实现债券凭证的转让拆分。 其中， 在原始资产上链时， 通过对应收账款进行审核校验， 确认贸易 关系和身份真实有效， 和保证上链资产的真实可信。再者， 债权凭证 可基于供应链进行层层拆分与流转， 都可完整追溯到最底层资产， 以实现核心企业和金融机构对供应商的“信用穿透”。
某公司规划开发一个区块链供应链金融平台， 包括核心企业、供 应商、银行等角色， 通过智能合约代码逐步构建区块链供应链金融平 台的基本功能， 实现银行向核心企业提供授信并发行数字凭证， 企业 与企业之间转让数字凭证。此外需要完成区块链供应链金融平台的前后端，实现基本的业务逻辑。
模块一：区块链产品方案设计及系统运维（35 分） 任务 1-1：区块链系统部署与运维（25 分） 围绕供应链金融区块链平台部署与运维需求， 进行项目相关系统、节点以及 管理工具的部署工作。通过监控工具完成对网络、节点服务的监控。最终根据业务需求规范，完成系统日志、网络参数、节点服务等系统结构的维护。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4112105ab62254cf3072c61b9201367/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6455decdd2705f083d94cc84ceb06d08/" rel="bookmark">
			【面试HOT200】二叉树的构建&amp;&amp;二叉搜索树篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列综述：
💞目的：本系列是个人整理为了秋招面试的，整理期间苛求每个知识点，平衡理解简易度与深入程度。
🥰来源：材料主要源于【CodeTopHot200】进行的，每个知识点的修正和深入主要参考各平台大佬的文章，其中也可能含有少量的个人实验自证，所有代码均优先参考最佳性能。
🤭结语：如果有帮到你的地方，就点个赞和关注一下呗，谢谢🎈🎄🌷！！！
🌈【C++】秋招&amp;实习面经汇总篇
文章目录 二叉树的构建基础知识654. 构建二叉树* 相关题目105. 从前序与中序遍历序列构造二叉树106. 从中序与后序遍历序列构造二叉树 二叉搜索树（考察较少，留后处理）基础知识相关题目98. 验证二叉搜索树530. 二叉搜索树的最小绝对差 236. 二叉树的最近公共祖先 235. 二叉搜索树的最近公共祖先 450. 删除二叉搜索树中的节点 669. 修剪二叉搜索树 108. 将有序数组转换为二叉搜索树669. 修剪二叉搜索树 参考博客 😊点此到文末惊喜↩︎
二叉树的构建 基础知识 654. 构建二叉树* 654. 最大二叉树 通过始末位置指示容器范围，避免每次调用的vector创建开销 TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) { auto self = [&amp;](auto &amp;&amp;self, int left, int right)-&gt;TreeNode*{ // 递归出口 if (left &gt; right) return nullptr; // 如何划分：查找区间中的最大根节点 int max_pos = left; for (int i = left+1; i &lt;= right; ++i) { if (nums[i] &gt; nums[max_pos]) max_pos = i; } // 建立根节点，左递归，右递归 TreeNode *root = new TreeNode(nums[max_pos]); root-&gt;left = self(self, left, max_pos-1); root-&gt;right = self(self, max_pos+1, right); // 返回根节点 return root; }; TreeNode *root = self(self, 0, nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6455decdd2705f083d94cc84ceb06d08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c890c030fe933a88755eca6cdeb10e38/" rel="bookmark">
			Cannot resolve com.lxz.springcloud:cloud-api-commons:1.0-SNAPSHOT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原因可能是groupId等信息写错了
导入的jar包的groupId要与它自己的坐标匹配
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a9d5e68aadaf267cf67e86082067be3/" rel="bookmark">
			#Django事务#
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		事务实现方式
1:基于装饰器实现
@transaction.atomic
def my_view(request):
#处理操作
#操作数据1
#操作数据2
当HTTP相应码是500,事务回滚
2:使用with语句
from django.db import transaction
def my_view(request):
with transaction.atomic()
#处理操作
#操作数据1
#操作数据2
3:手动处理
from django.db import connection connection.set_autocommit(False)
try:
#处理操作
#操作数据1
#操作数据2
connection.commit()
except Exception as e :
#print("errorrrrrrrr",str(e))
connection.rollback()
finally:
connection.set_autocommit(True)
4:全局事务配置文件方式
DATABASES = {
'default': {
'ENGINE': 'django.db.backends.mysql',
'NAME': 'testdb', 'USER': 'root', 'PASSWORD': '123', 'HOST': '127.0.0.1', 'PORT': 3306, 'ATOMIC_REQUESTS': True # 全局开启事务，和http请求的整个过程绑定在一起
}
}
它是这样工作的：在调用视图方法前，Django 先生成一个事务。如果响应能正常生成，Django 会提交该事务。而如果视图出现异常，Django 则会回滚该事务。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a9d5e68aadaf267cf67e86082067be3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdf16a9e61e2ebd1837f2760e454024c/" rel="bookmark">
			vue3 jsx/tsx 语法 使用css样式，循环，事件，插槽
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载 @vitejs/plugin-vue-jsx pnpm add @vitejs/plugin-vue-jsx 配置 vite.config.ts
import { defineConfig } from "vite"; import vue from "@vitejs/plugin-vue"; import vueJsx from "@vitejs/plugin-vue-jsx"; export default defineConfig({ plugins: [vue(), vueJsx()], }); tsconfig.json
{ "compilerOptions": { "jsxImportSource": "vue" } } 使用 函数式组件使用 .tsx 文件
export default () =&gt; { return ( &lt;&gt; &lt;div&gt;test&lt;/div&gt; &lt;/&gt; ); }; defineComponent + setup 使用 import { defineComponent } from "vue"; export default defineComponent({ setup(props, { slots, emit }) { return () =&gt; { return &lt;div&gt;demo&lt;/div&gt;; }; }, }); 使用样式 行内样式不变 export default () =&gt; { return ( &lt;&gt; &lt;div style="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bdf16a9e61e2ebd1837f2760e454024c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1993b1bfbc8441a0cf0ec5e5e136ebbe/" rel="bookmark">
			android 重启应用方式有几种？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、使用AlarmManager定时重启：
AlarmManager alarmManager = (AlarmManager)getSystemService(Context.ALARM_SERVICE); Intent intent = new Intent(this, MainActivity.class); PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, intent, 0); alarmManager.set(AlarmManager.RTC, System.currentTimeMillis() + 1000, pendingIntent); 2、使用android.os.Process.killProcess()方法：
android.os.Process.killProcess(android.os.Process.myPid()); 3、adb 命令进行应用重启
停止: adb shell am force-stop 包名 启动: adb shell am start 包名/activity名(包名是软件的标识,Activity主要描述app的某个页面) 4、最有用代码应用定时重启，不需要看门狗。
@SuppressLint("WrongConstant") fun restartApp(mm: MainActivity) { val oldintent: Intent = mm.getIntent() //System.out.println("OLD INTENT:"+oldintent.getAction()); val intent = PendingIntent.getActivity(mm.getBaseContext(), 0, Intent(oldintent), oldintent.flags) val manager = mm.getSystemService(Context.ALARM_SERVICE) as AlarmManager manager[AlarmManager.RTC, System.currentTimeMillis() + 250] = intent Log.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1993b1bfbc8441a0cf0ec5e5e136ebbe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c58201a0ceb14e51aaafd45e5a8cc4e7/" rel="bookmark">
			Anaconda软件切换base路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		针对以上，我的Anaconda Prompt默认打开路径是在C盘用户名下，如果想更改默认打开的路径的话，可以这么操作：
右键Anaconda Prompt打开其文件所在位置（如下图）
然后在打开的文件夹中右键它的快捷方式，选择属性
然后在属性页的快捷方式栏的起始位置处，更改成你想默认打开的路径即可，比如我更改成了Desktop桌面上了，选择应用并确认即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/145c21187adf3aca6c2bcdb1aea83e3e/" rel="bookmark">
			六边形消除游戏开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		六边形游戏的鼻祖应该是这个 hex-frvr，原作者开发用的是 pixi 游戏引擎，本着快速开发的理念，本游戏采用 cocos creator，UI 延用 hex-frvr。学习过程中，有借鉴各路实现。此源码仅供学习使用，谢谢。
预览 功能介绍 六边形游戏本质是俄罗斯方块，理解这个对接下来的开发会有很大的帮助。
本游戏实现功能如下：
[x] 六边形棋盘绘制、方块随机生成[x] 方块能否落入棋盘的判定[x] 方块消除与游戏结束的判定[x] 各种动画效果[x] 游戏计分 cocos creator 在讲游戏开发思路前，建议先了解 cocos creator
文档API 必须了解的 API 有：
GameCanvasSceneNodeComponentSpriteTexture2DDirectorloaderEventTouchActionVec2AnimationAnimationClipPrefabsys 其中，Node、Event、Vec2，是此游戏开发的重点。
开发思路 下面从功能逐一介绍开发思路。
棋盘绘制 棋盘用的是六角网格布局，电子游戏中六角网格的运用没有方形网格那样常见，先来简单了解下六角网格。
六角网格 本文中讨论的六角网格使用的都是正六边形。六角网格最典型的朝向有两种：水平方向( 顶点朝上 )与竖直方形( 边线朝上 )。本游戏用的是，顶点朝上的朝向。
细心的同学会发现，图中有类似坐标系的东西，称之为轴坐标。
轴坐标 轴坐标系，有时也叫做“梯形坐标系”，是从立方坐标系的三个坐标中取两个建立的坐标系。由于我们有约束条件 x + y + z = 0，因此第三个坐标其实是多余的。轴坐标适合用于地图数据储存，也适合用于作为面向玩家的显示坐标。类似立方坐标，你也可以使用笛卡尔坐标系中的加，减，乘，除等基本运算。
有许多种立方坐标系，因此，也自然有许多种由其衍生的轴坐标系。本游戏，选用的是 q = x 以及 r = z 的情况。这里 q 代表列而 r 表示行。
偏移坐标是人们最先会想到的坐标系，因为它能够直接使用方形网格的笛卡尔坐标。但不幸的是，偏移坐标系中的一个轴总会显得格格不入，并且最终会把问题变得复杂化。立方坐标和轴坐标则显得相得益彰，算法也更简单明了，只是地图存储方面会略微变得复杂一点。所以，使用立方/轴坐标系是较为简单的。
从六角网格到像素 大致了解了什么是六角网格，接下来了解如何把六角网格转换为像素。
如果使用的轴坐标，那么可以先观察下图中示意的单位矢量。在下图中，箭头 A→Q 表示的是 q 轴的单位矢量而 A→R 是 r 轴的单位矢量。像素坐标即 q_basis _ q + r_basis _ r。例如，B 点位于 (1, 1)，等于 q 与 r 的单位矢量之和。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/145c21187adf3aca6c2bcdb1aea83e3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04e8023cde0e0d321bf3edf39aa87de1/" rel="bookmark">
			C#通过API实现抓取wish店铺订单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发者申请认证授权订单抓取订单状态更新 授权流程
官网申请开发者创建应用APP(勾选响应的权限)发布应用（得到clientid，client_secret ）通过授权码获取店铺授权token以及refreshtoken,并保存到数据 token刷新代码
/// &lt;summary&gt; /// 获取获取有效token /// &lt;/summary&gt; /// &lt;param name="storeInfoDto"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private async Task&lt;string&gt; GetAccessToken(WishStoreInfoDto storeInfoDto) { if (storeInfoDto.Oauthorization_date &lt;= DateTime.UtcNow.AddMinutes(-1)) { var tokenString = await _httpClient.GetAsync("https://merchant.wish.com/api/v3/oauth/refresh_token", new Dictionary&lt;string, string&gt;() { { "Authorization", storeInfoDto.refresh_token } } ); var newToken = JObject.Parse(tokenString); storeInfoDto.Token = newToken.Value&lt;string&gt;("access_token"); storeInfoDto.Oauthorization_date = newToken.Value&lt;DateTime&gt;("expiry_time"); storeInfoDto.refresh_token = newToken.Value&lt;string&gt;("refresh_token"); //利用废弃字段存储token await _storeInfoAppService.UpdateStoreAuthInfoAsync(storeInfoDto); Console.ForegroundColor = ConsoleColor.Yellow; Console.WriteLine($"刷新token有效期至{storeInfoDto.Oauthorization_date}"); Console.ForegroundColor = ConsoleColor.White; } return storeInfoDto.Token; } 订单抓取(直接上代码)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04e8023cde0e0d321bf3edf39aa87de1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6400674a16ab61ded888bb13f48c9dbd/" rel="bookmark">
			FreeRTOS调度器启动过程分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
引出思考
vTaskStartScheduler()启动任务调度器
xPortStartScheduler()函数
FreeRTOS启动第一个任务
vPortSVCHandler()函数
总结
引出思考 首先想象一下如何启动第一个任务？
假设我们要启动的第一个任务是任务A，那么就需要将任务A的寄存器值恢复到CPU寄存器
任务A的寄存器值，在一开始创建任务的时候就保存在任务A的栈中了，这个在创建任务的细节博文中我已经分析过FreeRTOS任务创建及细节-CSDN博客
注意：
1、中断产生时，硬件将xPSR，PC(R15)、LR(R14)、R12、R3-R0保存和恢复，而R4-R11需要手动保存和恢复
2、进入中断后硬件会强制使用MSP指针，此时LR(R14)的值将会自动被更新为特殊的EXC_RETURN
使用FreeRTOS，一个最基本的程序框架如下所示：
int main(void) { // 必要的初始化工作; // 创建任务1; // 创建任务2; // ... vTaskStartScheduler(); /*启动调度器*/ while(1); } 任务创建完成后，静态变量指针pxCurrentTCB，指向优先级最高的就绪任务，但此时任务不能运行，因为接下来还有最为关键的一步：启动FreeRTOS调度器。
调度器是FreeRTOS操作系统的核心，主要负责任务切换，即找出最高优先级的就绪任务，并使之获得CPU运行权。调度器并非自动运行的，需要人为启动它。
vTaskStartScheduler()启动任务调度器 API函数vTaskStartScheduler()用于启动调度器，它会创建一个空闲任务，初始化一些静态变量，最主要的，它会初始化系统节拍定时器并设置好相应的中断，然后启动第一个任务。这里我们分析启动调度器的过程，和之前一样，启动调度器也涉及到硬件架构的一些知识（比如系统节拍定时器初始化），因此本文这里以CortexM3架构为例。
启动调度器的API函数vTaskStartScheduler()的源码这里我直接精简一下屏蔽掉条件编译的部分：
void vTaskStartScheduler( void ) { BaseType_t xReturn; StaticTask_t *pxIdleTaskTCBBuffer= NULL; StackType_t *pxIdleTaskStackBuffer= NULL; uint16_t usIdleTaskStackSize =tskIDLE_STACK_SIZE; /*如果使用静态内存分配任务堆栈和任务TCB,则需要为空闲任务预先定义好任务内存和任务TCB空间*/ #if(configSUPPORT_STATIC_ALLOCATION == 1 ) { vApplicationGetIdleTaskMemory( &amp;pxIdleTaskTCBBuffer, &amp;pxIdleTaskStackBuffer, &amp;usIdleTaskStackSize); } #endif /*configSUPPORT_STATIC_ALLOCATION */ /* 创建空闲任务,使用最低优先级*/ xReturn =xTaskGenericCreate( prvIdleTask, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6400674a16ab61ded888bb13f48c9dbd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/302eb7b8d227f17987a8cfd5055fe345/" rel="bookmark">
			【SWAT水文模型】SWAT水文模型建立及应用第六期：SWAT模型率定（SWAT CUP）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SWAT模型率定（SWAT CUP） 1 准备工作2 水文模型率定（SWAT CUP）2.1 数据准备输入数据注意事项 2.2 运行流程Step1：建立SWAT CUP工程Step2：输入文件参数及数据Step2：Executable Files（执行文件）Step3：校准输出文件说明 Step4：模型检验 参考 SWAT CUP的下载及安装参见另一博客-【SWAT水文模型】SWAT-CUP安装及使用
注意：率定的月径流单位为：m^3/s
下面将具体介绍基于实测水文站数据进行水文模型的率定。
1 准备工作 水文站位置如下：（以洮河流域为例）
水文站信息如下：（6个实测水文站）
本研究时段为1970-2020年（共51）年，则分配如下：
预热期（Warmup）：1970-1975年（6年）率定期（calibration）：1976-2005年（30年）检验期（validation）：2006-2020年（15年） 流域位置如下：（66个子流域）
据此，根据SWAT水文模型划分子流域，确定相关参数，用于后续SWAT CUP率定。
查阅MonitoringPoint表，根据TYPE=O，确定观测站点所在子流域，如下：
水文站与子流域对应序号如下所示：
水文站名子流域序号红旗2临洮18李家村20岷县47下巴沟34 2 水文模型率定（SWAT CUP） 2.1 数据准备 已经进行过至少一次模拟的swat输出文件，一般放于Scenarios目录下swatcup需要的是其中的txtinout文件夹。
选取以下参数进行率定：
对应变量及范围如下：
1、文本视图（Text View）
13 : Number of Parameters 10 : number of simulations r__CN2.mgt	-0.2 0.2 v__SURLAG.bsn	0.05 24 v__OV_N.hru	0.01 30 v__ESCO.hru	0.1 1.0 v__GW_REVAP.gw 0.02 0.02 v__ALPHA_BF.gw 0.0 1.0 v__GW_DELAY.gw	30.0 450.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/302eb7b8d227f17987a8cfd5055fe345/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c15e7837eaf4482f93a3951218578a24/" rel="bookmark">
			Ubuntu20 USB 权限配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//
（保姆级）Ubuntu下的USB设备永久权限+设备起别名方法
cd /etc/udev/rules.d sudo vim motor_control_usb.rules 增加如下内容 SUBSYSTEMS=="usb", ATTRS{idVendor}=="0483", ATTRS{idProduct}=="2000", GROUP="edda", MODE="0777" SUBSYSTEMS=="usb", ATTRS{idVendor}=="0483", ATTRS{idProduct}=="2001", GROUP="edda", MODE="0777" SUBSYSTEMS=="usb", ATTRS{idVendor}=="0483", ATTRS{idProduct}=="2002", GROUP="edda", MODE="0777" SUBSYSTEMS=="usb", ATTRS{idVendor}=="0483", ATTRS{idProduct}=="2003", GROUP="edda", MODE="0777" SUBSYSTEMS=="usb", ATTRS{idVendor}=="0483", ATTRS{idProduct}=="2004", GROUP="edda", MODE="0777" SUBSYSTEMS=="usb", ATTRS{idVendor}=="0483", ATTRS{idProduct}=="2005", GROUP="edda", MODE="0777" 立即生效 sudo udevadm trigger //
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eccd6a228cc44cb37e0fb368cf5180fa/" rel="bookmark">
			【集合】List取交集、并集（去重）、差集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 交集差集并集不去重去重 交集 最笨的方法之一：双层for循环（对象的情况下可以转成map或者set） public static void main(String[] args) { List&lt;String&gt; listA = new ArrayList&lt;&gt;(); List&lt;String&gt; listB = new ArrayList&lt;&gt;(); listA.add("A"); listA.add("B"); listA.add("C"); listA.add("D"); listB.add("B"); listB.add("C"); listB.add("D"); listB.add("E"); Set set = new HashSet(); for (String tmp: listA) { set.add(tmp); } for (String tmp: listB) { if(set.contains(tmp)){ System.out.println(tmp); } } } 上边代码可以简化为一行代码，使用List源码中retainAll(List list)
listA.retainAll(listB) 结果： B,C,D ArrayList对此方法进行了重写，先对传入的参数进行了非空判断
然后调用了batchRemove方法执行取交集逻辑
final Object[] elementData = this.elementData; 这里要注意的是这样赋值，elementData引用还是指向this.elementData，所以后面直接操作elementData改变的会是this。
对自身进行了遍历，在遍历的过程中判断传进来的集合中是否包含当前元素，如果包含，则按顺序写入当前集合中。
第二个判断就是将交集后面多余的元素去除。
差集 public static void main(String[] args) { List&lt;String&gt; listA = new ArrayList&lt;&gt;(); List&lt;String&gt; listB = new ArrayList&lt;&gt;(); listA.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eccd6a228cc44cb37e0fb368cf5180fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f7d27d001cdb300f8fae0ad8813a6c6/" rel="bookmark">
			python 涉及opencv mediapipe知识，眨眼计数 供初学者参考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本思路 我们知道正面侦测到人脸时，任意一只眼睛水平方向上的两个特征点构成水平距离，上下两个特征点构成垂直距离 当头像靠近或者远离摄像头时，垂直距离与水平距离的比值基本恒定 根据这一思路 当闭眼时 垂直距离变小 比值固定小于某一个值 当睁眼时 比值大于某个比率，比如35%，我们将比值扩大一百倍 （35% X 100） 这样我们认为大于35时是睁眼 小于为闭眼，根据程序侦测画面帧数 我们认为某一段连续的帧画面就是同一个事件 所以我们只处理其中一帧画面。基本背景知识需要用到mediapipe中人脸模型 下面给出右眼特征点编号
完整代码：
import cv2 import cvzone from cvzone.FaceMeshModule import FaceMeshDetector from cvzone.PlotModule import LivePlot from PIL import Image, ImageDraw, ImageFont import numpy as np def putText2(img,text,pos,size=36,color=(255,0,0)): img_pil = Image.fromarray(cv2.cvtColor(img, cv2.COLOR_BGR2RGB)) font = ImageFont.truetype(font=r'simsun.ttc', size=size) draw = ImageDraw.Draw(img_pil) draw.text(pos, text, font=font, fill=color) # PIL中RGB=(255,0,0)表示红色 img_cv = np.array(img_pil) # PIL图片转换为numpy img = cv2.cvtColor(img_cv, cv2.COLOR_RGB2BGR) # PIL格式转换为OpenCV的BGR格式 return img cap=cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f7d27d001cdb300f8fae0ad8813a6c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76d729fedba4b2e65406bcd51f760706/" rel="bookmark">
			嵌入式硬件和软件哪个好?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		嵌入式硬件和软件哪个好?
嵌入式软硬件工程师哪个更有前途呢?一起来看看。
嵌入式是分为软硬件工程师的，首先我们先来看看嵌入式硬件工程师吧!
嵌入式硬件开发工程师主要编写嵌入式系统硬件总体方案和详细方案，要求理解嵌入式系统架构，有一定的C语言基础，熟悉ARM、protel设计软件，有四层板开发经验。
成为优秀的嵌入式硬件开发工程师需具备以下技能：由需求分析至总体方案、详细设计的规划能力;熟练运用设计工具、设计原理图、PCB板的能力;熟练运用单片机、DSP、PLD、FPGA等进行软硬件开发调试的能力;熟练运用仿真工具、示波器、信号发生器、逻辑分析仪等调测硬件的能力;掌握常用的标准电路的设计能力，如复位电路、常用滤波器电路、功放电路、高速信号传输线的匹配电路等;故障定位、解决问题的能力;设计文档的组织编写技能!
那对于嵌入式软件工程师来说：
嵌入式软件工程师领域较新，他的发展也是很快的，像这类技术都是看经验的，经验越高，那他的身价也相应变高。据统计，65%的电子产品开发企业中，嵌入式软件开发工程师团队，往往只占全公司人数的5%，但是却创造了全公司超过70%的效益。
嵌入式软件开发工程师，他的领域是比较广泛的，在一些消费电子，通讯设备等这些方面。因为领域大，相对而言就业领域也是比较大的，人才需求量也是一样。嵌入式软件工程师相对于硬件工程师来说，人才需求比硬件工程师要大，软件学习门槛较低，相对而言，硬件门槛会比较高点。其实他们的薪资水平是相差不多的。
嵌入式软硬件工程师，就看你对哪个方面感兴趣了，要看你个人，这两方面现在发展都是很不错的。总之，嵌入式不是一蹴而就，需要数年的坚持与执着，要想在嵌入式任何一个领域精进，都不是一件容易的事。选一个方向，沉下心来，做就是了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b8eb6128917995510a72a4b004a1269/" rel="bookmark">
			NSS [HUBUCTF 2022 新生赛]Calculate
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NSS [HUBUCTF 2022 新生赛]Calculate 题目描述：python is a good tool in CTF
需要答对20题，每题回答时间（其实就是两次发包之前的间隔）要大于一秒小于三秒。
抓个包，我们的答案是POST发包。并且在这里看到了cookie，注意一下，我们的代码是要加上cookie的，要不然服务器无法判定我们的身份，给我们记录答对题目的数量。就像寄快递，不写发件人对方根本不知道是谁发过来的。
查看返回包，可以发现数学表达式的每一个字符都在&lt;div style=什么什么&gt;和&lt;/div&gt;之间，但是&lt;div style=什么什么&gt;和&lt;/div&gt;之间除了数学表达式的每个字符还有换行符。
脚本如下：
import requests import time url = 'http://node1.anna.nssctf.cn:28802/' res = requests.session() #创建session对象，用来保存当前会话的持续有效性。不创建也可以调用对应的方法发送请求，但是没有cookie，那就无法记录答题数量。 for i in range(1, 99): math = "" response = res.get(url) #发get包，获取题目 time.sleep(1) # 睡一秒 resTest = response.text #获取返回包的内容 for j in range(0, len(resTest)): #遍历获取网页数学表达式，这里建议用正则表达式（re） if resTest[j - 1] == "&gt;" and resTest[j + 1] == "&lt;" and resTest[j]!= "\n": math = math + resTest[j] math = math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b8eb6128917995510a72a4b004a1269/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1d07390d60c1f2229c576d568af25c9/" rel="bookmark">
			springboot集成阿里云短信服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Springboot整合阿里云短信服务_spring boot集成阿里短信验证码-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/966da154ba37a4edb70ee91a50904eb9/" rel="bookmark">
			在Windows操作系统上使用rtsp simple server和ffmpeg推送录屏视频流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大纲 1 搭建启动rtsp server2 推送录屏视频流下载FFmpeg 3 检验3.1 获取本机IP3.2 检测 1 搭建启动rtsp server 从https://github.com/aler9/rtsp-simple-server/releases下载Windows版本的编译结果。
解压，然后启动该程序
2 推送录屏视频流 下载FFmpeg 从https://ffmpeg.org/download.html下载Windows版本的编译结果。
解压后，通过cmd进入FFmpeg所在的目录，执行下面的命令（其中rtsp://localhost:8554/mystream是上一步生成的地址）。
ffmpeg -f gdigrab -framerate 10 -i desktop -f rtsp -g 5 -an rtsp://localhost:8554/mystream
我们可以看到console会出现下面的变化。
rstp simple server的窗口会发生下面的变化。
3 检验 3.1 获取本机IP 在cmd中使用ipconfig获取本机IP
3.2 检测 可以使用VLC播放器测试流地址是否有效。
填入rtsp://172.168.1.218:8554/mystream。注意此处不能再使用localhost了，而是要用本机的IP。
在VCL中能看到屏幕就代表我们方案是通过的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6b1544031b4f86e65b303f9fdef93da/" rel="bookmark">
			在AWS Lambda中使用FFmpeg处理m3u8视频流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大纲 1 部署有FFmpeg功能的Lambda环境1.1 部署层1.2 部署代码1.2.1 FFmpeg指令1.2.2 代码 2 配置Lambda角色权限2.1 选择角色类型2.2 设置权限2.3 保存角色2.4 绑定角色 参考文献 在直播里领域，我们经常需要对视频流进行处理。FFmpeg则是该领域中处理的利器。这篇文章，我们将以视频流截图为例，讲解如何在AWS Lambda中对m3u8视频流进行截图。因为Lambda是无服务架构，其本地存储是不可靠的，于是最后我们需要将截图文件上传S3桶。 1 部署有FFmpeg功能的Lambda环境 1.1 部署层 这块的方案可以见《在AWS Lambda上部署标准FFmpeg工具——自定义层的方案》和《在AWS Lambda上部署EC2编译的FFmpeg工具——自定义层的方案》
《在AWS Lambda上部署标准FFmpeg工具——Docker方案》也是可以参考的。但是这个要求代码在部署时已经完备，而本例会在后面分析代码，所以本文中不参考这套部署方案。
1.2 部署代码 1.2.1 FFmpeg指令 我们使用的指令是：
ffmpeg -probesize 32768 -i {m3u8_stream_url} -y -t 0.001 -ss 1 -f image2 -r 1 - 其中*{m3u8_stream_url}*是需要被替换成视频流地址。其参数解析见下：
-probesize 32768:以字节为单位设置探测大小，即分析获取流信息的数据大小-i:输入目标-y:无需询问即可覆盖输出目标-t:当用作输入选项（之前-i）时，限制从输入文件读取数据 的持续时间。我这里设置的是0.001秒-ss:开始时间。-f:强制输入或输出文件格式。image2:图像文件解复用器。-r:提取图像的频率-:输出目标。因为FFmpeg截图的图片不能落盘，于是通过这个配置让图片内容进入标准输出。 1.2.2 代码 我们使用Python代码来完成这个功能。
import json import subprocess import shlex import boto3 import time S3_DESTINATION_BUCKET = "inplay-video-image" def lambda_handler(event, context): if not event: return { 'statusCode': 200, 'body': json.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6b1544031b4f86e65b303f9fdef93da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7158e6a50c40bf12a51bdf5d18518bb4/" rel="bookmark">
			rvos 3编译与链接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 做下面的两个练习需要：
在vmvb上装一个ubuntu会gcc、vi的基本使用 用vi写一个hello.cgcc -o hello.creadelf -h hello.oreadelf -S hello.oobjdump -S hello.o 用vi编辑一个test.cgcc -c test.creadelf -S test.o.text:代码 .data:初始化的全局变量和静态变量 .bss:未初始化的全局变量和静态变量 .rodata:只读数据readelf -x .test test.oreadelf -x .data test.oreadelf -x .bss test.oreadelf -x .rodata test.o 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c3c08d7792d573795a4404835b5b224/" rel="bookmark">
			学校图书管理系统的开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目 录 摘要 1
Abstract. 1
1 引言 2
1.1 图书管理的现状 2
1.2 现有图书管理系统的概述 3
1.3 选题的目的、意义 3
1.4 图书管理系统的可行性分析 4
1.5 系统开发运行环境 4
2 图书管理系统开发相关技术的介绍 5
2.1 Asp.net的介绍 5
2.1.1 Asp.net的优势介绍 5
2.1.2 Asp.net的特点 5
2.2 SQL Server 2005 概述 6
2.3 Web技术 7
2.3.1 浏览器/服务器(Browser/Server)结构 7
2.3.2 IIS服务器技术 7
3 系统总体设计分析 8
3.1 系统需求分析 8
3.2 系统实现的目标 8
3.3 系统功能模块设计 8
3.4 系统功能结构图 9
3.5 系统流程图 11
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c3c08d7792d573795a4404835b5b224/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6db2bef2b62aeced80c41b53d5e8bf3b/" rel="bookmark">
			C&#43;&#43; move semantics
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++ move semantics move semanticsmove constructormove assignment operatorvector::emplace_back(move(unique\_ptr))參考連結 move semantics C++11中引入了move semantics，它是基於[rvalue reference](C++ lvalue，rvalue及rvalue reference)來優化物件搬移效率的一種機制。
在一個自定義的類別中，如果我們希望使用move semantics，就必須為它定義兩個成員函數：move constructor及move assignment operator。
move constructor move constructor的核心理念是：
把temporary object中的資料給搬到新物件中將temporary object還原到一個valid state（可以想成0或NULL） 在TensorRT/samples/common/buffers.h中：
//move constructor //此處的GenericBuffer&amp;&amp;就是rvalue reference GenericBuffer(GenericBuffer&amp;&amp; buf) //獲取temporary object的成員屬性 : mSize(buf.mSize) , mCapacity(buf.mCapacity) , mType(buf.mType) , mBuffer(buf.mBuffer) { //將temp object還原到一個valid state buf.mSize = 0; buf.mCapacity = 0; buf.mType = nvinfer1::DataType::kFLOAT; buf.mBuffer = nullptr; } 注意此處move constructorGenericBuffer(GenericBuffer&amp;&amp; buf)的輸入是一個rvalue reference。
第一步先將buf的屬性給搬到新物件中，第二步則是將傳入的參數buf清空，注意因為這裡是右值引用，所以我們才可以修改buf。
move assignment operator move assignment operator裡包含三步驟，相較於move constructor多了一步，即一開始需要將其現在的資料給清空：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6db2bef2b62aeced80c41b53d5e8bf3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e826f860da4dc4d17401a67f4650f8dc/" rel="bookmark">
			敏捷开发入门教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 转载至： 阮一峰 日期： 2019年3月 6日
敏捷开发（agile development）是非常流行的软件开发方法。据统计，2018年90%的软件开发采用敏捷开发。
但是，到底什么是敏捷开发，能说清的人却不多。本文尝试用简洁易懂的语言，解释敏捷开发。
一、迭代开发 敏捷开发的核心是迭代开发（iterative development）。敏捷一定是采用迭代开发的方式。
那么什么是"迭代开发"呢？迭代的英文是 iterative，直译为"重复"，迭代开发其实就是"重复开发"。
对于大型软件项目，传统的开发方式是采用一个大周期（比如一年）进行开发，整个过程就是一次"大开发"；迭代开发的方式则不一样，它将开发过程拆分成多个小周期，即一次"大开发"变成多次"小开发"，每次小开发都是同样的流程，所以看上去就好像重复在做同样的步骤。
举例来说，SpaceX 公司想造一个大推力火箭，将人类送到火星。但是，它不是一开始就造大火箭，而是先造一个最简陋的小火箭 Falcon 1。结果，第一次发射就爆炸了，直到第四次发射，才成功进入轨道。然后，开发了中型火箭 Falcon 9，九年中发射了70次。最后，才开发 Falcon 重型火箭。如果 SpaceX 不采用迭代开发，它可能直到现在还无法上天。
迭代开发将一个大任务，分解成多次连续的开发，本质就是逐步改进。开发者先快速发布一个有效但不完美的最简版本，然后不断迭代。每一次迭代都包含规划、设计、编码、测试、评估五个步骤，不断改进产品，添加新功能。通过频繁的发布，以及跟踪对前一次迭代的反馈，最终接近较完善的产品形态。
二、增量开发 迭代开发只是要求将开发分成多个迭代，并没有回答一个重要的问题：怎么划分迭代，哪个任务在这个迭代，哪个任务在下个迭代？这时，一般采用"增量开发"（incremental development）划分迭代。
所谓"增量开发"，指的是软件的每个版本，都会新增一个用户可以感知的完整功能。也就是说，按照新增功能来划分迭代。
举例来说，房产公司开发一个10栋楼的小区。如果采用增量开发的模式，该公司第一个迭代就是交付一号楼，第二个迭代交付二号楼......每个迭代都是完成一栋完整的楼。而不是第一个迭代挖好10栋楼的地基，第二个迭代建好每栋楼的骨架，第三个迭代架设屋顶......
增量开发加上迭代开发，才算真正的敏捷开发。
三、敏捷开发的好处 3.1 早期交付 敏捷开发的第一个好处，就是早期交付，从而大大降低成本。
还是以上一节的房产公司为例，如果按照传统的"瀑布开发模式"，先挖10栋楼的地基、再盖骨架、然后架设屋顶，每个阶段都等到前一个阶段完成后开始，可能需要两年才能一次性交付10栋楼。也就是说，如果不考虑预售，该项目必须等到两年后才能回款。
敏捷开发是六个月后交付一号楼，后面每两个月交付一栋楼。因此，半年就能回款10%，后面每个月都会有现金流，资金压力就大大减轻了。
3.2 降低风险 敏捷开发的第二个好处是，及时了解市场需求，降低产品不适用的风险。
请想一想，哪一种情况损失比较小：10栋楼都造好以后，才发现卖不出去，还是造好第一栋楼，就发现卖不出去，从而改进或停建后面9栋楼？
对于软件项目来说，先有一个原型产品，了解市场的接受程度，往往是项目成功的关键。有一本书叫做《梦断代码》，副标题就是"20+个程序员，三年时间，4732个bug，100+万美元，最后失败的故事"，这就是没有采用敏捷开发的结果。相反的，Instagram 最初是一个地理位置打卡 App，后来发现用户不怎么在乎地理位置，更喜欢上传照片，就改做照片上传软件，结果成了独角兽。
由于敏捷开发可以不断试错，找出对业务最重要的功能，然后通过迭代，调整软件方向。相比传统方式，大大增加了产品成功的可能性。如果市场需求不确定，或者你对该领域不熟悉，那么敏捷开发几乎是唯一可行的应对方式。
四、如何进行每一次迭代 虽然敏捷开发将软件开发分成多个迭代，但是也要求，每次迭代都是一个完整的软件开发周期，必须按照软件工程的方法论，进行正规的流程管理。具体来说，每次迭代都必须依次完成以下五个步骤。
需求分析（requirements analysis）设计（design）编码（coding）测试（testing）部署和评估（deployment / evaluation） 每个迭代大约持续2~6周。
五、敏捷开发的价值观 《敏捷软件开发宣言》里面提到四个价值观。
程序员的主观能动性，以及程序员之间的互动，优于既定流程和工具。软件能够运行，优于详尽的文档。跟客户的密切协作，优于合同和谈判。能够响应变化，优于遵循计划。 六、十二条原则 该宣言还提出十二条敏捷开发的原则。
通过早期和持续交付有价值的软件，实现客户满意度。欢迎不断变化的需求，即使是在项目开发的后期。要善于利用需求变更，帮助客户获得竞争优势。不断交付可用的软件，周期通常是几周，越短越好。项目过程中，业务人员与开发人员必须在一起工作。项目必须围绕那些有内在动力的个人而建立，他们应该受到信任。面对面交谈是最好的沟通方式。可用性是衡量进度的主要指标。提倡可持续的开发，保持稳定的进展速度。不断关注技术是否优秀，设计是否良好。简单性至关重要，尽最大可能减少不必要的工作。最好的架构、要求和设计，来自团队内部自发的认识。团队要定期反思如何更有效，并相应地进行调整。 七、参考链接 Iterative development: the secret to great product launches, Pavlo ZinchenkoAgile software development, Wikipedia 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccf715ce8b7614c2f7124484ec6041b5/" rel="bookmark">
			常见网络报文数据包格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我们应用程序用TCP传输数据的时候，数据被送入协议栈中，然后逐个通过每一层，知道最后到物理层数据转换成比特流，送入网络。而再这个过程中，每一层都会对要发送的数据加一些首部信息。整个过程如下图。
以太网帧格式 以太网常用帧格式有两种，一种是Ethernet II，另一种是IEEE 802.3 格式。这两种格式区别是：Ethernet II中包含一个Type字 段,。而IEEE 802.3格式中,此位置是长度字段。 其中Type字段描述了，以太网首部 后面所跟数据包的类型，例如Type为0x0800时为IP协议包，以太网中多数数据帧使用的是Ethernet II帧格式。
Ethernet II帧格式 type类型 数值
值描述
IPv4协议包
0x0800
ARP协议包
0x0806
802.1Q VLAN
0x8100
ipv6协议包
0x86DD
MPLS Label
0x8847
PPPoE
0x8864
lldp
0x88cc
IEEE 802.3 帧格式 前导码：Ethernet II是由8个8‘b10101010构成，IEEE802.3由7个8‘b10101010+1个字节SFD..
目的地址：目的设备的MAC物理地址。
源 地址 ：发送设备的MAC物理地址。
类型(Ethernet II)：以太网首部 后面所跟数据包的类型，例如Type为0x0800时为IP协议包，Type为0806时，后面为ARP协议包。
长度(IEEE802.3)：当长度小于1500时，说明该帧为IEEE802.3帧格式，大于1500时，说明该帧为Ethernet II帧格式。
数据：数据长度最小为46字节，不足46字节时，填充至46字节。因为最小帧长度是64字节，所以，46+6+6+2+4=64。（不算前导码）
FCS: 就是CRC校验值
IEEE 802.1Q VLAN帧格式 字段
长度
含义
取值
TPID
2Byte
Tag Protocol Identifier（标签协议标识符），表示数据帧类型。
取值为0x8100时表示IEEE 802.1Q的VLAN数据帧。如果不支持802.1Q的设备收到这样的帧，会将其丢弃。
各设备厂商可以自定义该字段的值。当邻居设备将TPID值配置为非0x8100时， 为了能够识别这样的报文，实现互通，必须在本设备上修改TPID值，确保和邻居设备的TPID值配置一致。
PRI
3bit
Priority，表示数据帧的802.1p优先级。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccf715ce8b7614c2f7124484ec6041b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32f1376c8547aa868ae5ec0dcc32ac2d/" rel="bookmark">
			maven 构建报错 This failure was cached in the local repository and resolution is not reattempted until t
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		maven 构建报错 This failure was cached in the local repository and resolution is not reattempted until the update interval of public has elapsed or updates are forced
解决方法：
这个错误通常是由于 Maven 在本地仓库中缓存了某个依赖项的失败状态，并且在一段时间内不会再次尝试解析该依赖项，除非更新间隔已过或者强制更新。
有几种方法可以解决这个问题：
清理本地仓库：尝试清除 Maven 的本地仓库缓存，这将强制 Maven 重新下载所有依赖项。可以手动删除 Maven 本地仓库目录下的所有内容（默认情况下位于用户目录下的.m2/repository文件夹），然后重新构建项目。
强制更新依赖项：可以在 Maven 命令中使用 -U 或 --update-snapshots 参数，强制更新所有依赖项，而不管缓存状态。例如，运行 mvn clean install -U。
检查网络连接：确保你的网络连接正常，没有被防火墙或代理服务器阻止。有时候，网络问题可能导致无法正确下载依赖项。
检查远程仓库：如果你使用的是远程仓库，可以检查该仓库是否可用，并且其设置是否正确。可能需要更新远程仓库的 URL 或验证凭据等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11b8be9fd252820d0677b1cc579882e2/" rel="bookmark">
			CAN通信标准帧和扩展帧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标准帧和扩展帧的区别在于：
一、扩展帧的仲裁域有29位，可以出现2^29中报文，且在数据链路上是有间隙的(对操作者透明)，帧ID的范围是0000 0000-1FFF FFFF。（PS：目的就是构造29位的CAN ID，可以实现更加庞大的ID群）
二、标准帧的仲裁域是连续的11位，可以出现2^11种报文，也就是帧ID的范围是000-7FF；
三、控制帧中的DLC(数据长度)完全相同，但保留位不同，标准帧IDE、R0，扩展帧R1、R0，必须以显性电平发送(由数据链路层操作)，对程序员透明；
四、 总结： 其它的都一模一样，所以，其实CAN标准帧和扩展帧只是在帧ID的长度上不一样，以能扩展更多的CAN节点，更好地支持上层协议而已。
注意：这里的帧ID 并不是表示发送的目的地址，而是表示访问总线的消息的优先级（帧ID值越小，优先级越高，最小是0x00000000）。
标准帧：（0x12）
扩展帧：（0x1314）
CAN标准帧格式
CAN 标准帧信息为11个字节(3 + 8)，包括两部分：信息和数据部分。前3个字节为信息部分。
字节1为帧信息。第7位（FF）表示帧格式，在标准帧中，FF＝0；第6位（RTR）表示帧的类型，RTR=0表示为数据帧，RTR=1表示为远程帧；DLC表示在数据帧时实际的数据长度。
字节2、3为报文识别码，11位有效。
字节4～11为数据帧的实际数据，远程帧时无效。
CAN扩展帧格式
CAN 扩展帧信息为13个字节(5 + 8)，包括两部分，信息和数据部分。前5个字节为信息部分
字节1为帧信息。第7位（FF）表示帧格式，在扩展帧中，FF＝1；第6位（RTR）表示帧的类型，RTR=0表示为数据帧，RTR=1表示为远程帧；DLC 表示在数据帧时实际的数据长度。
字节2～5为报文识别码，其高29位有效。
字节6～13数据帧的实际数据，远程帧时无效
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/263eaa0154cd276b2b94f08dfe45e094/" rel="bookmark">
			Linux快速搭建Redis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Linux上快速安装Redis可以通过包管理器或源代码编译安装来完成。大多数Linux发行版都支持使用包管理器来安装Redis，例如使用apt（Debian/Ubuntu）或yum（CentOS/RHEL）。
以下是使用包管理器安装Redis的步骤：
使用apt安装（Debian/Ubuntu）
打开终端。
更新软件包索引：
sudo apt update 安装Redis服务器：
sudo apt install redis-server 安装完成后，Redis服务会自动启动。你可以使用以下命令检查Redis是否正在运行：
sudo systemctl status redis-server 使用yum安装（CentOS/RHEL）
打开终端。
安装EPEL存储库（如果尚未安装）：
sudo yum install epel-release 安装Redis：
sudo yum install redis 安装完成后，Redis服务会自动启动。你可以使用以下命令检查Redis是否正在运行：
sudo systemctl status redis 源代码编译安装
如果你希望使用最新版本的Redis或者包管理器中没有最新版本，你可以选择从源代码编译安装Redis。这种方法需要从Redis官方网站下载源代码并手动编译安装。
下载并解压Redis源代码：
wget http://download.redis.io/releases/redis-x.x.x.tar.gz tar xzf redis-x.x.x.tar.gz cd redis-x.x.x 其中x.x.x是Redis的版本号，你需要替换成最新版本号。
编译并安装Redis：
make sudo make install 启动Redis服务器：
redis-server reids配置文件：
whereis redis.conf 在配置文件中找到：
# 表示的是指定本机可以接受连接的网卡地址 # bind 127.0.0.1 # 配置 Redis3.2新特征 只允许本机登录 yes打开 no关闭 # protected-mode yes [no] # 设置redis密码 password # requirepass password 开放Redis默认端口6379
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/263eaa0154cd276b2b94f08dfe45e094/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9740d7aca4639c4a1521047532a5055/" rel="bookmark">
			关于级联选择器el-cascader的踩坑及解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.vue报错：Error in callback for watcher “options“: “TypeError: Cannot read propertie ‘level‘ of null
我的报错使用场景：级联选择器是遍历出来的，数据也是遍历的数组里面的，报错的原因是我删除了option绑定的数组，因为后台接口不需要这个数据
解决：给级联选择器加key,key的值是：new Date().getTime()，在每次数据改变的时候更新key,即this.keyIndex = new Date().getTime()
2.使用自带的filterable检索，并自定义检索方法，:filter-method
但是这个方法是有默认参数的，当不满足自己的需要，需要传其他参树的时候，
可以使用以下方式：
1.闭包方式：
:filter-method=“filterProduct({everyIndex,itemIndex,list:every.list})”
filterProduct(param){ //param----自定义传递的参数 node----节点 keyword----搜索关键词 //param.list 当前级联选择器的option return (node,keyword)=&gt;{ console.log(param,"换了个写法-param") console.log(node,"换了个写法-node") console.log(keyword,"换了个写法-keyword") if (!!~node.label.toUpperCase().indexOf(keyword.toUpperCase())) { return true } } }, 2.bind方法
:filter-method=“filterOrg.bind(this, param)”
filterOrg(param, value, data, node) { // 在 filterOrg 方法中可以访问到传递的参数 param console.log(param); // 具体的过滤逻辑 // ... // 返回过滤结果 return true; // 或者根据条件返回 true 或 false } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9740d7aca4639c4a1521047532a5055/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e8d529ca248a12da8f157af8d42f264/" rel="bookmark">
			vmvb中ubuntu打不开terminal
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述：
其实最开始装的ubuntu是可以打开terminal的，但是因为我把系统的语言换成了中文，然后文件目录名字也换成了中文，后期在使用的时候不太方便，所以就把原来的虚拟机删了重新配了一个，但是配完之后不论是快捷键、鼠标右键还是直接启动terminal，都没法成功，一开始我是删了又重装了一次，但是不管用，我后来把内存改了一下大小，但发现还是没用，然后就上网查了一下，总结出来两个方法，第一个我试了，管用，第二个没试，但是应该也是管用的，在此记录一下。
方法一：
在ubuntu桌面上敲“ctrl+alt+f3”进入命令行模式（退出是“ctrl+alt+f1”）用带有sudo权限的用户登录cd /etc/defaultsudo nano locale把文件中"en_US"全部改为"en_US.UTF-8""ctrl+O""enter""ctrl+X"sudo locale-gen --purgereboot 方法二：
vmvb里面在配一个新的虚拟机的时候，有个这个
据说是目前这个自动安装的功能还不够完善，有时候会出错，所以如果自己手动安装的话就没问题了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5f03a6986e1477890445b67ed393bcf/" rel="bookmark">
			阿里云OSS代码集成部分问题分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公司内部开发了一个文件相关的应用，由于服务器带宽限制导致多个用户同时上传或者下载文件时速度很慢，遂将文件迁移至阿里云OSS服务器。下面是迁移的过程中遇到的部分问题。
问题1. 跨域错误 错误信息如下：
Access to XMLHttpRequest at 'http://xxx.oss-cn-hangzhou.aliyuncs.com/test/logo.jpg' from origin 'http://192.168.29.131:8080' has been blocked by CORS policy: Response to preflight request doesn't pass access control check: No 'Access-Control-Allow-Origin' header is present on the requested resource. 该问题按照以下步骤正确配置跨域规则。
登录OSS管理控制台。单击Bucket 列表，然后单击目标Bucket名称。在左侧导航栏，选择数据安全 &gt; 跨域设置。在跨域设置页面，单击创建规则。在创建跨域规则面板，按以下说明配置各项参数，其他参数保留默认配置。 来源：设置为*。允许Methods：选中GET、POST、PUT、DELETE、HEAD。允许Headers：设置为*。暴露Headers：设置为指定值或者不填。 单击确定。 问题2. Access denied by authorizer’s policy. 具体错误代码如下：
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;Error&gt; &lt;Code&gt;AccessDenied&lt;/Code&gt; &lt;Message&gt;Access denied by authorizer's policy.&lt;/Message&gt; &lt;RequestId&gt;655EED1451FCAD1916A298B4&lt;/RequestId&gt; &lt;HostId&gt;xxx.oss-cn-hangzhou.aliyuncs.com&lt;/HostId&gt; &lt;AccessDeniedDetail&gt; &lt;PolicyType&gt;SessionPolicy&lt;/PolicyType&gt; &lt;AuthPrincipalOwnerId&gt;1883463381918383&lt;/AuthPrincipalOwnerId&gt; &lt;AuthPrincipalType&gt;AssumedRoleUser&lt;/AuthPrincipalType&gt; &lt;AuthPrincipalDisplayName&gt;devram:251264809289383873&lt;/AuthPrincipalDisplayName&gt; &lt;NoPermissionType&gt;ImplicitDeny&lt;/NoPermissionType&gt; &lt;AuthAction&gt;oss:PutObject&lt;/AuthAction&gt; &lt;/AccessDeniedDetail&gt; &lt;EC&gt;0003-00000301&lt;/EC&gt; &lt;RecommendDoc&gt;https://api.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5f03a6986e1477890445b67ed393bcf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a368f56bfaaf1b6684d3e6b5e31395c4/" rel="bookmark">
			windows 安装两个mysql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 参考链接一
参考链接二
安装第二个mysql 端口号改为3307进入 bin目录管理员身份运行cmd mysqld --defaults-file=C:\\soft\\1mysql-5.7.33-winx64\\my.ini --initialize --console 初始化 data 目录修改密码 修改 my.ini 文件添加 skip-grant-tables 见下启动mysql mysqld --defaults-file=C:\\soft\\1mysql-5.7.33-winx64\\my.ini --console 修改密码安装为服务 mysqld --install-manual MySqlWhole --defaults-file=C:\\soft\\1mysql-5.7.33-winx64\\my.ini启动服务 修改密码
update user set authentication_string='' where user='root'; FLUSH PRIVILEGES; SET PASSWORD FOR 'root'@'localhost'= "kdzt123456."; FLUSH PRIVILEGES; 查看端口号占用
netstat -ano|findstr 3307 登录 mysql -h localhost -u root --port 3307 -p 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6085d764b7809e406ff5f9aa818c7b03/" rel="bookmark">
			介绍几个好用的guava工具类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 平时我们都会封装一些处理缓存或其他的小工具。但每个人都封装一次，重复造轮子，有点费时间。有没有一些好的工具库推荐-guava。guava是谷歌基于java封装好的开源库，它的性能、实用性，比我们自己造的轮子更好，毕竟谷歌出品，下面介绍下几个常用的guava工具类
LoadingCache（本地缓存）Multimap 和 MultisetBiMapTable（表）Sets和Maps（交并差）EventBus（事件）StopWatch（秒表）Files（文件操作）RateLimiter（限流器）Guava Retry（重试） 如何使用Guava &lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;27.0-jre&lt;/version&gt; &lt;/dependency&gt; LoadingCache LoadingCache 在实际场景中有着非常广泛的使用，通常情况下如果遇到需要大量时间计算或者缓存值的场景，就应当将值保存到缓存中。LoadingCache 和 ConcurrentMap 类似，但又不尽相同。最大的不同是 ConcurrentMap 会永久的存储所有的元素值直到他们被显示的移除，但是 LoadingCache 会为了保持内存使用合理会根据配置自动将过期值移除通常情况下，Guava caching 适用于以下场景： 花费一些内存来换取速度一些 key 会被不止一次被调用缓存内容有限，不会超过内存空间的值，Guava caches 不会存储内容到文件或者到服务器外部，如果有此类需求考虑使用 Memcached, RedisLoadingCache 不能缓存 null keyCacheBuilder 构造 LoadingCache 参数介绍 CacheBuilder 方法参数
描述
initialCapacity(int initialCapacity)
缓存池的初始大小
concurrencyLevel(int concurrencyLevel)
设置并发数
maximumSize(long maximumSize)
缓存池大小，在缓存项接近该大小时， Guava开始回收旧的缓存项
weakValues()
设置value的存储引用是虚引用
softValues()
设置value的存储引用是软引用
expireAfterWrite(long duration, TimeUnit unit)
设置时间对象没有被写则对象从内存中删除(在另外的线程里面不定期维护)
expireAfterAccess(long duration, TimeUnit unit)
设置时间对象没有被读/写访问则对象从内存中删除(在另外的线程里面不定期维护)
refreshAfterWrite(long duration, TimeUnit unit)
和expireAfterWrite类似，不过不立马移除key，而是在下次更新时刷新，这段时间可能会返回旧值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6085d764b7809e406ff5f9aa818c7b03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bb727e9b519418ca7c7487f36907c8d/" rel="bookmark">
			公开Java框架开源到Maven中央仓库（避坑）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言:
gpg下载地址：http://www.gnupg.org/download
安装勾选 kleopatra
下载完成验证 gpg --version
当时为了开源Java框架，真的是绞尽脑汁，耗费很多精力查了很多资料，躺了很多坑，最终的结果无不是以发布失败而告终，现在直接把我直接成功的例子给到大家，同时也带了一点私心，希望自己的开源越来越被多人看到使用和继续完善。
给出开源链接：https://github.com/fyupeng/rpc-netty-framework/
1. 生成秘钥 gpg --full-generate-key 连续敲三个空格后，输入y
记住Passphase，相当于一个密钥库的密码，用来鉴权是不是所有人在使用
最后保存起来，我一般保存到${user.home}/.gnupg，与秘钥存放位置放一起
这里注意一下，默认私钥和公钥会保存在C:\Users\${user_name}\AppData\Roaming\gnupg\目录中
而IDE会找到${user.home}/.gnupg该目录下，如果没有做任何操作，你生成的秘钥通过gpg --list-keys是找不到的
下面会详细给步骤
2. 查看秘钥 gpg --list-keys 获取key Id 来获取秘钥可以为 公钥后16位和8位，推荐16位
3. 发布公钥到公钥服务器 gpg --keyserver hkp://keyserver.ubuntu.com:11371 --send-keys FD953A355469C8AA 无提示、无报错即可
4. 从公钥服务器获取公钥 gpg --keyserver hkp://keyserver.ubuntu.com:11371 --recv-keys FD953A355469C8AA gpg: key 12E2CADABE0D891E: "fyupeng &lt;1160886967@qq.com&gt;" not changed gpg: Total number processed: 1 gpg: unchanged: 1 5. 获取公钥列表 C:\Users\fyp01&gt;gpg --list-keys C:\Users\fyp01\AppData\Roaming\gnupg\pubring.kbx ------------------------------------------------ pub ed25519 2022-08-20 [SC] [expires: 2024-08-19] 76591F10A73649202490BA3812E2CADABE0D891E uid [ultimate] fyupeng &lt;1160886967@qq.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bb727e9b519418ca7c7487f36907c8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdb131321e950546df7e6e656ddcb7b4/" rel="bookmark">
			python之使用深度学习创建自己的表情符号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 环境搭建部署项目1、首先运行train.py训练模型2、接下运行gui.py测试 一、使用 CNN 进行面部情绪识别二、GUI 代码和表情符号映射 在这个深度学习项目中，我们将对人类面部表情进行分类，以过滤和映射相应的表情符号或头像。
数据集（面部表情识别）由48*48像素的灰度人脸图像组成。图像居中并占据相等的空间。该数据集由以下类别的面部情绪组成：
0：生气
1：厌恶
2：壮举
3：快乐
4：悲伤
5：惊喜
6：自然
下载项目代码：click or click
环境搭建 python版本我们选择3.9~3.11：python-3.11.5-amd64.exe
因为我们的tensorflow库需要与python版本相对应
pycharm 我们选择专业版功能多：pycharm-professional-2023.2.3.exe
转载：具体安装详细教程：Python安装教程（新手)
我们将构建一个深度学习模型，从图像中对面部表情进行分类。然后，我们将分类的情感映射到表情符号或头像。
部署项目 没有相应的模块自己pip安装吧
1、首先运行train.py训练模型 等待训练完成生成emotion_model.h5
2、接下运行gui.py测试 一、使用 CNN 进行面部情绪识别 在以下步骤中，将构建卷积神经网络架构，并在数据集上训练模型FER2013以便从图像中进行情感识别。从上面的链接下载数据集。将其提取到具有单独训练和测试目录的数据文件夹中。
1、import
import numpy as np import cv2 from keras.models import Sequential from keras.layers import Dense, Dropout, Flatten from keras.layers import Conv2D from keras.optimizers import Adam from keras.layers import MaxPooling2D from keras.preprocessing.image import ImageDataGenerator numpy: 用于在Python中进行数值计算的库。cv2: OpenCV库，用于计算机视觉任务，例如图像处理和人脸检测。Sequential, Dense, Dropout, Flatten, Conv2D, MaxPooling2D:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bdb131321e950546df7e6e656ddcb7b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d5164ac14da3412b2cc0e6043fe6a55/" rel="bookmark">
			硬件SPI通信协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、简介 SPI（Serial Peripheral Interface，串行外设接口）是一种全双工同步串行通信接口，用于MCU与各种外围设备以串行方式进行通信以交换信息，通信速度最高可达25MHz以上。
SPI通常由四条线组成，一条主设备输出与从设备输入（Master Output Slave Input，MOSI），一条主设备输入与从设备输出（Master Input Slave Output，MISO），一条时钟信号（Serial Clock，SCLK），一条从设备使能选择（Chip Select，CS）。
2、物理层 1、连接方式 SPI可以一个主机连接多个从机，通过CS线来确定当前与哪一个从机进行通信，SPI的连接方式如下图所示：
1、当有多个SPI从设备与SPI主机相连时，设备的其它信号线SCK、MOSI及MISO同时并联到相同的SPI总线上，即无论有多少个从设备，都共同使用这3条总线；而每个从设备都有独立的这一条CS信号线，本信号线独占主机的一个引脚，即有多少个从设备，就有多少条片选信号线。
2、输入的MISO为了防止两个设备同时响应造成短路，所以这里主机没有选中到的时候他们片选线都为高组态的状态
3、SPI使用CS信号线来进行寻址，当把要通信的设备的CS线拉低时，该设备被选中，即片选有效，开始进行通信。当CS线拉高时停止通信。
2、数据传输 数据的传输方式如图所示：
1、主机和从机都有一个移位寄存器，主机移位寄存器数据经过MOSI将数据写入从机的移位寄存器，此时从机移位寄存器的数据也通过MISO传给了主机，实现了两个移位寄存器的数据交换。无论主机还是从机，发送和接收都是同时进行的。
2、如果主机只对从机进行写操作，主机只需忽略接收的从机数据即可。如果主机要读取从机数据，需要发送一个空字节（0xff）来引发从机发送数据。
3、数据的传输可以选择低位先传输或者是高位先传输。
3、协议层 通过CPOL和CPHA的不同组合，SPI可以有四种不同的通信方式。
CPOL(时钟极性)：表示SCK在空闲时为高电平还是低电平，当CPOL=0时，SCK空闲时为低电平；当CPOL=1时，SCK空闲时为高电平。
CPHA(时钟相位)：表示SCK在第几个时钟边缘采样数据，当CPHA=0时，在SCK第一个时钟边缘采样；当CPHA时，在SCK第二个时钟边缘采样。
四种模式分别为：
SPI模式CPOLCPHA说明000时钟空闲状态为低电平，在第一个时钟边缘采样，即上升沿101时钟空闲状态为低电平，在第二个时钟边缘采样，即下降沿210时钟空闲状态为高电平，在第一个时钟边缘采样，即下降沿311时钟空闲状态为高电平，在第二个时钟边缘采样，即上升沿 时序图如下：
4、固件库的使用 1、初始化 /*********************************************** * @brief : SPI模式配置 * @param : void * @return: void * @date : 2023.10.20 * @author: L ************************************************/ void Spi1Init(void) { Spi1GpioInit();//初始化SPI使用的端口 SPI_InitTypeDef spi_config = {0};//spi初始化结构体句柄 //配置SPI模式 RCC_APB2PeriphClockCmd(SPI1_CLOCK,ENABLE);//开启SPI1时钟 spi_config.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_4;//4分频，即72M / 4，stm32f103c8t6在SPI最高支持18M spi_config.SPI_DataSize = SPI_DataSize_8b;//8位数据 spi_config.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d5164ac14da3412b2cc0e6043fe6a55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c88d619f3126647447aa0c5c1e250bc1/" rel="bookmark">
			1-Hadoop原理与技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单选题
题目1：安装Hadoop集群时，是在哪个文件指定哪些机器作为集群的从机？
选项:
A datanode
B slaves
C yarn-site.xml
D core-site.xml
答案：B
------------------------------
题目2：Hadoop配置文件所在目录是哪个？
选项:
A /etc/hosts
B /etc/hadoop
C $HADOOP_HOME/conf
D $HADOOP_HOME/etc/hadoop
答案：D
------------------------------
题目3：把公钥追加到授权文件的命令是？
选项:
A ssh-copy-id
B ssh-add
C ssh
D ssh-keygen
答案：A
------------------------------
题目4：下面哪个目录保存了Hadoop集群的命令（比如启动Hadoop）?
选项:
A bin
B sbin
C etc
D share
答案：B
------------------------------
题目5：Hadoop完全分布模式配置免密登录是要？
选项:
A 实现主节点到其他节点免密登录
B 实现从节点到主节点的免密登录
C 主节点和从节点任意两个节点之间免密登录
D 以上都不是
答案：C
------------------------------
题目6：端口50070默认是Hadoop哪个服务的端口？
选项:
A NameNode
B DataNode
C SecondaryNameNode
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c88d619f3126647447aa0c5c1e250bc1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7a02dda50850c4da1e4edf87e10d890/" rel="bookmark">
			6-HBase分布式数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单选题
题目1：下列关于zookeeper描述正确的是
选项:
A 无论客户端连接的是哪个Zookeeper服务器，其看到的服务端数据模型都是一致的
B 从同一个客户端发起的事务请求，最终将会严格按照其发起顺序被应用到zookeeper中
C 在一个5个节点组成的Zookeeper集群中，如果同时有3台机器宕机，服务不受影响
D 如果客户端连接到Zookeeper集群中的那台机器突然宕机，客户端会自动切换连接到集群其他机器
答案：A
------------------------------
题目2：Zookeeper启动时会最多监听几个端口
选项:
A 1
B 2
C 3
D 4
答案：B
------------------------------
题目3：HBase分布式模式最好须要几个节点？
选项:
A 1
B 2
C 3
D 最少3个
答案：C
------------------------------
题目4：解压.tar.gz结尾的HBase压缩包使用的Linux命令是？
选项:
A tar -zxvf
B tar -zx
C tar -s
D tar -nf
答案：A
------------------------------
题目5：HBase虚拟分布式模式须要几个节点？
选项:
A 1
B 2
C 3
D 最少3个
答案：A
------------------------------
题目6：HBase中的批量载入底层使用什么进行实现
选项:
A MapReduce
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7a02dda50850c4da1e4edf87e10d890/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b19dca2a800ef526a32a6ae316c0cde/" rel="bookmark">
			8-Hive原理与技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单选题
题目1：按粒度大小的顺序，Hive数据被分为：数据库、数据表、桶和什么
选项:
A 元祖
B 栏
C 分区
D 行
答案：C
------------------------------
题目2：以下选项中，哪种类型间的转换是被Hive查询语言所支持的
选项:
A Double—Number
B BigInt—Double
C Int—BigInt
D String--Double
答案：D
------------------------------
题目3：Hive最重视的性能是可测量性、延展性、对于输入格式的宽松匹配性和什么性能
选项:
A 较低恢复性
B 容错性
C 快速查询
D 可处理大量数据
答案：B
------------------------------
题目4：Hive查询语言和SQL的一个不同之处在于什么操作
选项:
A Group by
B Join
C Partition
D Union
答案：C
------------------------------
题目5：Hive是建立在什么之上的一个数据仓库
选项:
A HDFS
B MapReduce
C Hadoop
D HBase
答案：C
------------------------------
多选题
题目1：Sqoop从Hive表导出MySQL表时，首先需要在MySQL中创建表结构。
选项:
答案：正确
------------------------------
题目2：Sqoop是关系型数据库与Hadoop之间的数据桥梁，这个桥梁的重要组件是Sqoop连接器。
选项:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b19dca2a800ef526a32a6ae316c0cde/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f614e2d0e8d6ffa030fdda1ba91742ad/" rel="bookmark">
			Gateway：微服务架构中的关键组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Gateway：微服务架构中的关键组件 在微服务架构的世界中，Gateway（网关）扮演着至关重要的角色。它不仅作为流量的入口，还提供路由、鉴权、监控等多种功能。本博客将详细介绍Gateway的概念、功能以及如何在实际项目中使用它。
Gateway是什么？ Gateway是微服务架构中的一个组件，它位于客户端和服务器之间，作为所有请求的入口。它负责将外部请求路由到正确的服务，并可能包括额外的跨服务功能，如认证、监控、负载均衡等。
主要功能 路由：根据请求的URL、头部等信息将请求转发到正确的微服务。
鉴权和安全：在请求达到实际服务前进行用户身份验证和授权。
限流和熔断：控制访问频率，防止服务过载，并在服务失败时提供熔断机制。
日志和监控：记录请求和响应，方便监控和调试。
负载均衡：在多个服务实例间分配请求，提高系统的可用性和扩展性。
Gateway的工作原理 Gateway作为一个单一的入口，接收所有来自客户端的请求，然后根据路由规则将请求转发到相应的微服务。同时，它还可以执行各种中间层处理，如鉴权、限流等。
如何使用Gateway 以下是一个简单的示例，说明如何在Spring Cloud项目中使用Spring Cloud Gateway。
环境准备 安装Java和Maven准备几个微服务实例 步骤 创建Spring Boot项目：
使用Spring Initializr创建一个新的Spring Boot项目作为Gateway。
添加依赖：
在pom.xml中添加Spring Cloud Gateway的相关依赖。
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 其他依赖 --&gt; &lt;/dependencies&gt; 配置路由：
在application.yml中配置路由规则，指定如何将请求转发到不同的微服务。
spring: cloud: gateway: routes: - id: service-a uri: lb://SERVICE-A predicates: - Path=/service-a/** - id: service-b uri: lb://SERVICE-B predicates: - Path=/service-b/** 启动应用：
运行Gateway应用。
测试路由：
通过Gateway访问定义的路由，如/service-a/，Gateway将请求转发到相应的服务。
通过这个简单的例子，您可以看到在Spring Cloud环境下，使用Spring Cloud Gateway进行路由的设置是非常直接和简单的。Gateway的这些功能为微服务架构提供了强大的支持，帮助企业更容易地实现服务的管理和协调。
结论 Gateway作为微服务架构的关键组件，提供了路由、鉴权、监控等多种功能。通过简化服务的访问和管理，它使得微服务架构的实施和维护变得更加容易。无论您是正在构建新的微服务应用，还是想要优化现有的系统，Gateway都是一个值得考虑的选择。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b2564edaaf27360c908b7f556d5c3c4/" rel="bookmark">
			C&#43;&#43;常用特性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++常用特性，持续更新……
1. std::for_each()、std::mem_fn() #include &lt;algorithm&gt; // std::for_each #include &lt;functional&gt; // std::mem_fn #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;thread&gt; struct MfFe { int m_a; int m_b; int sum(int i, int j) { return i + j; } int tuple(int i) { return i*3; } }; int square(int i) { std::cout &lt;&lt; i * i &lt;&lt; std::endl; return i * i; } int multiply(int i,int j) { std::cout &lt;&lt; i * j &lt;&lt; std::endl; return i * j; } int main() { std::vector&lt;std::thread&gt; vecth; for (int i = 0; i!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b2564edaaf27360c908b7f556d5c3c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85eab6c2e84eb9fadac2f16529fcf09d/" rel="bookmark">
			使用nvm管理node多版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		win10环境使用nvm安装管理多版本nodejs
使用node工程，有时不同项目需要使用不同node版本，来回安装肯定是很麻烦的，所以需要一个方法能够使电脑系统安装多个node版本，并且使用一句命令就能自由切换。
nvm安装
1.nvm安装，首先在官网下载
安装地址
配置nvm的安装目录，切换到淘宝，有两种方式：
（1）使用命令：
//命令行中输入一下命令进行配置 nvm node_mirror https://npmmirror.com/mirrors/node/ nvm npm_mirror https://npmmirror.com/mirrors/npm/ (2)直接手动更改：
手动添加
node_mirror: https://npm.taobao.org/mirrors/node/ npm_mirror: https://npm.taobao.org/mirrors/npm/ 这两句到setting.txt
查看当前可用node版本
nvm list available | CURRENT | LTS | OLD STABLE | OLD UNSTABLE | |--------------|--------------|--------------|--------------| | 20.5.0 | 18.17.0 | 0.12.18 | 0.11.16 | | 20.4.0 | 18.16.1 | 0.12.17 | 0.11.15 | | 20.3.1 | 18.16.0 | 0.12.16 | 0.11.14 | | 20.3.0 | 18.15.0 | 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85eab6c2e84eb9fadac2f16529fcf09d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d60badd6b9fc34d98e7c403f24de37a/" rel="bookmark">
			教你nginx同端口配置不同前端服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		手上只有一台服务器，用一个端口却想启动俩个服务？别急，下面就来教你怎么做 知识点： nginx反向代理只需在nginx.conf配置文件里面的 http 模块 写俩 server 模块，如下指定不同的 server_name (即域名)，重启服务 就可以愉快的访问啦nginx 基本命令 # 一般都是切换到 /usr/local/nginx/sbin 目录，执行以下操作 ./nginx # 启动 ./nginx -t # 测试 nginx.conf 配置文件是否出现语法错误 ./nginx -s reload # 重启nginx服务 ./nginx -s stop # 停止nginx服务 ./nginx -s quit # 安全退出 ps aux|grep nginx # 查看nginx进程 nginx.conf 主要配置
server { listen 80; server_name www.yourdomain.com; location ^~ / { alias /html/; # alias (目录别名)，值必须以/ 结尾 # root (上层目录), 值可加可不加/, 并且值后面会拼接 location 后的路径 index index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d60badd6b9fc34d98e7c403f24de37a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7cb543c77ff65a476985ad818b619ad/" rel="bookmark">
			TS类型报错解决：元素隐式具有 “any“ 类型，因为类型为 “string“ 的表达式不能用于索引类型 “{}“。 在类型 “{}“ 上找不到具有类型为 “string“ 的参数的索引签名。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		遍历对象，在没有专门定义的情况下，object中并没有string，即类型为 "string" 的表达式不能用于索引类型 "{}"。
元素隐式具有 “any” 类型，因为类型为 “string” 的表达式不能用于索引类型 “{}”。 在类型 “{}” 上找不到具有类型为 “string” 的参数的索引签名。
解决方法：Record(string,unknow)。这样就定义了key是string。
如：一个去除对象中空值的方法。
export const deleteEmpty = (obj: Record&lt;string, unknown&gt;): Record&lt;string, unknown&gt; =&gt; { const resObj: Record&lt;string, unknown&gt; = {} const arr: Array&lt;string&gt; = Object.keys(obj) arr.forEach((key) =&gt; { if (!isEmpty(obj[key])) { resObj[key] = obj[key] } }) return resObj } 其他 参考了Ts中string、number和any等类型 不能当做索引用，怎么处理？ - 掘金 (juejin.cn)，解决方法为：把key变为key as keyof typeof object，这就要求每次出现key的时候都要使用key as keyof typeof object，重复性太高。
后来定义了一个interface：
interface MyObject { [key: string]: unknown; } const deleteEmpty = (obj: MyObject): object =&gt; { const resObj = {}; Object.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7cb543c77ff65a476985ad818b619ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4887424489e1c7e66af85f698c359965/" rel="bookmark">
			“天作之合”softmax与CrossEntropy
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文从 max \text{max} max到 logsumexp ⁡ \operatorname{logsumexp} logsumexp，再到 softmax \text{softmax} softmax进行了一个简单推导，最后说明了 softmax \text{softmax} softmax与CrossEntropy的关系。希望帮助大家理解多分类损失函数CrossEntropy。
max 首先，给出 max \text{max} max 函数的表达式
max ⁡ ( x 1 , x 2 , … , x n ) = lim ⁡ K → + ∞ 1 K log ⁡ ( ∑ i = 1 n e K x i ) \max \left(x_{1}, x_{2}, \ldots, x_{n}\right)=\lim _{K \rightarrow+\infty} \frac{1}{K} \log \left(\sum_{i=1}^{n} e^{K x_{i}}\right) max(x1​,x2​,…,xn​)=K→+∞lim​K1​log(i=1∑n​eKxi​)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4887424489e1c7e66af85f698c359965/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a12bd7b85bb88e78a5be26e1635ae39/" rel="bookmark">
			基于ubuntu22.04安装KVM虚拟机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境说明 操作系统镜像：ubuntu-22.04.1-live-server-amd64.iso
可以直接去官网下载Get Ubuntu Server | Download | Ubuntu
宿主机OS使用的是最小化安装ubuntu-22.04
参考如下链接执行：
Ubuntu 22.04 之 KVM 安装手札-ubuntu20.04安装kvm
更新 Ubuntu 22.04 检查虚拟化是否开启 3、在 Ubuntu 22.04 上安装 KVM sudo apt install -y qemu-kvm libvirt-daemon-system libvirt-clients bridge-utils 参考链接：
KVM hypervisor: a beginners’ guide | Ubuntu
Install KVM Ubuntu 22.04 - Step-by-Step - Virtualization Howto
创建虚拟网桥 sudo virsh net-define /dev/stdin &lt;&lt;EOF &lt;network&gt; &lt;name&gt;virbr0&lt;/name&gt; &lt;forward mode="bridge"/&gt; &lt;bridge name="virbr0"/&gt; &lt;/network&gt; EOF sudo virsh net-start virbr0 sudo virsh net-autostart virbr0 4、创建 KVM虚拟机 virt-install --name=k8s01 --ram 1024 --vcpus=2 --disk path=~/k8s01.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a12bd7b85bb88e78a5be26e1635ae39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/392d219e82e6a738fd44d30603e8622d/" rel="bookmark">
			VMware虚拟机安装win7教程（图文版 超详细！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、下载
1.打开MSDN官网
2.点击操作系统找到win7，然后点击详细信息，复制下面ed2k，使用迅雷进行下载
3.下载完成
二、安装
1.打开VMware，点击创建新的虚拟机
2.选择自定义，点击下一步
3.点击下一步
4.选择稍后安装操作系统，点击下一步
5.操作系统选择Microsoft Windows，版本选择Windows7，然后点击下一步
6.选择安装路径，然后点击下一步
7.根据电脑配置选择，然后点击下一步
8.根据电脑配置选择，然后点击下一步
9.默认即可，点击下一步
10.默认即可，点击下一步
11.默认即可，点击下一步
12.默认即可，点击下一步
13.可以选择拆分成多个文件，方便后面分区，点击下一步
14.选择想要储存的位置，点击下一步
14.点击自定义硬件，在CD/DVD中选择使用ISO镜像文件，选择刚才下载好的镜像，然后点击高级选择IDE，点击确定，然后点击完成
15.然后win7虚拟机就创建好了
三、安装win7
1.点击开启此虚拟机
2.点击下一步
3.点击现在安装
4.点击接受条款，然后点击下一步
5.点击自定义
6.点击驱动器选项
7.点击新建，然后创建两个新的分区，一个用来放系统，另一个用来安装其他软件
8.创建完成后，把所有分区格式化
9.选择主分区，点击下一步，然后进入安装
10.然后填写用户名和密码，win7就安装完成了
四、安装VMtools
1.点击开始，输入D:\setup.exe
2.点击是
3.然后等待安装完成即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7eb4cff750ca964ec984c86eeabc6c92/" rel="bookmark">
			特征点 -- 《视觉SLAM十四讲 从理论到实践（第2版）》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 什么是特征点？
特征点就是图像中一些特别的地方，例如图像中的角点，在不同图像之间的辨识度更强，一种直观的提取特征的方式就是在不同图像之间辨认角点，确定它们的对应关系。
OpenCV中已经有了很多实用的特征提取和匹配的算法 ：
OpenCV 之 特征检测 - 知乎 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60821f90756defc83adbc57ae89f24af/" rel="bookmark">
			github问题解决（持续更新中）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、ssh: connect to host github.com port 22: Connection refused 从.ssh文件夹中新建文件名为config，内容为：
Host github.com Hostname ssh.github.com Port 443 2、解决 git 多用户提交切换问题 使用系统命令ssh创建rsa公私秘钥
C:\Users\fyp01&gt; ssh-keygen -t ras -b 4096 -C "${邮箱}" Generating public/private rsa key pair. Enter file in which to save the key (C:\Users\fyp01/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in C:\Users\fyp01/.ssh/id_rsa. Your public key has been saved in C:\Users\fyp01/.ssh/id_rsa.pub. The key fingerprint is: SHA256:4JRe/U5MvaLkh2sCPEHUvK1RBQr9zTB8y338T77ZliE ******** The key's randomart image is: +---[RSA 4096]----+ | .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60821f90756defc83adbc57ae89f24af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/152d4da6d9d50676fcb5f10ce9892067/" rel="bookmark">
			在 Sublime Text 4 for macOS 中使用多个光标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Sublime Text 4 for macOS 中使用多个光标 在 Sublime Text 4 for macOS 中使用多个光标（也称为多点编辑）是一项非常强大的功能，允许您在多个地方同时进行编辑。以下是一些常用的方法来使用多个光标：
1. 添加额外的光标 按住 Command 键并点击：您可以在需要添加新光标的每个位置按住 Command（⌘）键并点击鼠标左键。这将在每个点击的地方添加一个新的光标。 2. 选择多个相似的实例 选择一个词，然后按 Command + D：首先用光标选中一个词，然后按 Command + D（⌘ + D）。这会选择文档中下一个与当前选中词相同的实例，并为它添加一个新光标。重复按 Command + D 可以继续添加更多的光标。 3. 选择所有相似的实例 使用 Command + Control + G：如果您想选择文档中所有与当前选中词相同的实例，并为每个实例添加一个光标，可以使用 Command + Control + G（⌘ + Control + G）。 4. 创建垂直列的光标 使用鼠标中键拖动：如果您的鼠标有中键，可以按住中键并垂直拖动以在多行上创建光标。 5. 从选区创建多个光标 选择文本，然后按 Shift + Command + L：首先选择一块文本区域，然后按 Shift + Command + L（⇧ + ⌘ + L），这会在选中区域的每一行的末尾添加一个光标。 使用多个光标可以大大提高编辑效率，特别是当您需要在多个位置进行相同或类似的修改时。但要注意，所有光标都会同时接收您输入的内容，所以在进行批量编辑时需要小心。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/152d4da6d9d50676fcb5f10ce9892067/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdb5edba4977d07c890c94eed514b633/" rel="bookmark">
			【深度学习】在虚拟机Ubuntu中安装Anaconda&#43;pycharm&#43;跑通YOLOv8项目源代码&#43;训练自己的数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为一些特殊的原因，需要从之前CPU的win跑代码转移到GPU的虚拟机Ubuntu里面去跑，故在此记录一下安装软件和搭建环境的一些步骤，码一下以便以后查看。
文章目录 1.安装Anaconda1.1下载Anaconda安装包1.2安装Anaconda 2.使用Anaconda搭建环境3.安装pycahrm3.1下载pycharm3.2添加环境3.3添加pycharm的图标 4.跑通YOLOv8项目5.训练自己的数据集结束语 因为虚拟机提前安装了英伟达驱动，在此就不赘述驱动程序的安装了。
ps：
如果在终端输入
nvidia-smi 显示以下即为驱动程序已安装
如果是以下即为未安装驱动程序（图为网上查找的）
安装Anaconda+pycharm整体流程是借鉴小白菜的笔记(笔记)ubuntu20.04里安装anaconda然后在conda里安装pytorch这篇文章。
1.安装Anaconda 1.1下载Anaconda安装包 安装Anaconda的详细过程借鉴萝北村的枫子的文章Ubuntu安装Anaconda详细步骤（Ubuntu22.04.1，Anaconda3-2023.03）
进入Anaconda官网：https://repo.anaconda.com/archive/
我下载的是2021.11_Linux_x86
将下载中的文件移动到新创建的文件夹anaconda中
1.2安装Anaconda 点击空白处，选择终端打开
输入命令行：
bash Anaconda3-2021.11-Linux-x86_64.sh 输入yes，然后回车即可
后面会显示协议的一些内容，一直回车即可，直到显示让你输入yes
输入yes
选择默认的安装目录（默认在用户主目录下创建一个名为anaconda3的文件夹作为安装地址），等待安装完成
注意：此处默认安装的路径直接回车即可，不要输入新的地址，我刚开始以为跟着输入yes，结果就是安装到新创建的yes这个文件夹，后面打开的时候就有bug，然后重新安装了一遍，第二个&gt;&gt;&gt; 直接回车不要输入
输入yes
安装完成
进入安装文件右击，终端打开，输入conda list即可看到已安装的anaconda
安装完成后，之前建立的anaconda文件夹及安装包删除即可。
2.使用Anaconda搭建环境 创建环境的详细步骤在我之前的笔记中有写,此处不再赘述，可以参考：【深度学习】使用GPU（CUDA）跑通YOLOv5源码，包含搭建环境+训练数据集+预测（整套流程）
慢慢等待安装即可。
安装完成后可以通过以下命令进行查看是否安装成功
import torch import torchvision print(torch.cuda.is_available()) print(torch.backends.cudnn.is_available()) print(torch.version.cuda) print(torch.backends.cudnn.version()) tips： 我发现安装anaconda后，打开终端都会有前面的（base），强迫症想取消掉，然后找了解决方法：
以后如果想进入某环境，直接使用conda avtivate命令进入即可。
至此，anaconda安装完成+python虚拟环境搭建完成。
3.安装pycahrm 3.1下载pycharm 进入官网：https://www.jetbrains.com/pycharm/download/?section=linux#section=linux
下载压缩包，我下载的是社区版就够用了。下载后我新建了一个pycharm的文件夹，将压缩包解压到此。
在命令行输入：
cd pycharm-community-2022.2.4/bin/ ./pycharm.sh 3.2添加环境 点击pycharm界面的右下角添加解释器
3.3添加pycharm的图标 此处借鉴的是
炼丹炼丹的文章Ubuntu系统下设置桌面图标快捷方式(以Pycharm为例)
添加桌面图标可以直接点击图标就进入应用，不用再使用命令行进入
第五行就是应用打开的所在位置，第六行是图标所在位置
4.跑通YOLOv8项目 去官网下载YOLOv8源码以及预训练权重，我下载的是YOLOV8s.pt：https://github.com/ultralytics/ultralytics
下载完成后使用pycharm打开项目
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bdb5edba4977d07c890c94eed514b633/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/503d6de503ed3a605cce99a948fd08ac/" rel="bookmark">
			Django 4.2.7 超级管理员创建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Django框架默认有权限管理功能，使用命令可以手动创建超级管理员，命令如下：
$ python .\manage.py createsuperuser # 键入你想要使用的用户名，然后按下回车键： # Username: admin # 然后提示你输入想要使用的邮件地址： # Email address: admin@163.com # 最后一步是输入密码 # Password: ********** # Password (again): ********* # Superuser created successfully. 启动服务器，验证
$ python .\manage.py runserver 浏览器中输入如下地址:
http://127.0.0.1:8000/admin/ 出现如下界面：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de1cd2c3c8ea24523fa99850687c6dc0/" rel="bookmark">
			jsp 超市管理系统Myeclipse开发mysql数据库web结构java编程计算机网页项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、源码特点
JSP 超市管理系统是一套完善的java web信息管理系统，对理解JSP java编程开发语言有帮助，系统具有完整的源代码和数据库，系统主要采用B/S模式开发。开发环境为
TOMCAT7.0,Myeclipse8.5开发，数据库为Mysql5.0，使用java语言开发。
java超市管理系统1
二、功能介绍
商品信息管理：其功能是对商品进行管理，能够查询出商品的详细信息，并根据超市销售情况计划制定进货计划，实施产品采购并进行货物查询。
库存管理：其功能是管理商品的入库出库，库存商品的数量，价格，编号。库存管理系统的更新能及时为超市管理人员反馈超市库存的最新信息以便作出适应市场变化，适合超市销售的正确
决策。
销售管理：其功能是提供一般的销售管理，能够进行销售明细查询与统计。
系统管理：其功能是为系统的使用者进行帐户和密码管理。
登录模块
用户进入系统必须进行登录功能的身份验证来校验身份信息
数据库设计
1、用户信息数据表(yonghu)
其主要用来存储所有用户的信息：用户编号,用户名,密码,姓名,权限,联系电话,地址等信息字段。表4.1显示了表中各个字段的数据类型、大小以及简短描述
表4-1 用户信息表（yonghu）
序号
字段名称
数据类型
长度
主键
描述
1
yhid
INTEGER
11
是
用户编号
2
yhm
VARCHAR
40
否
用户名
3
mm
VARCHAR
40
否
密码
4
xm
VARCHAR
40
否
姓名
5
qx
VARCHAR
40
否
权限
6
lxdh
VARCHAR
40
否
联系电话
7
dz
VARCHAR
40
否
地址
2、 商品信息数据表(shangpin)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de1cd2c3c8ea24523fa99850687c6dc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f686b2678bca19e5a3587eeb2c57730/" rel="bookmark">
			基于fpga的全桥逆变spwm调制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于fpga的全桥逆变spwm调制
近年来，随着智能电网和新能源发电技术的迅速发展，对逆变器的要求也越来越高。全桥逆变器作为一种常见的逆变器类型，已经得到了广泛的应用。而在全桥逆变器中，SPWM调制技术是一种常见的调制方式，通过将正弦波信号和三角形波信号比较产生PWM波形，控制交流负载的电压和频率。然而，传统的CPU实现PWM调制存在着计算速度慢、时延大、精度低等问题，无法完全满足高精度、高速度控制的要求。
为了解决这些问题，基于FPGA的全桥逆变SPWM调制成为了一种新的解决方案。FPGA芯片是一种可编程逻辑器件，其具有并行处理能力和高速时钟，可以快速完成PWM波形的计算和控制。与传统的CPU实现PWM调制相比，基于FPGA的全桥逆变SPWM调制具有计算速度快、时延小、精度高、可靠性强等优点。因此，它在电力电子、工业控制、智能电网等领域得到了广泛的应用。
在基于FPGA的全桥逆变SPWM调制中，需要对FPGA芯片进行编程设计。设计者需要根据具体的控制要求，选择合适的FPGA芯片，并编写相应的程序，实现PWM波形的计算和控制。同时，设计者还需要考虑到不同的控制场景和应用环境，调整相应的参数和算法，以实现更加准确、高速、可靠的控制效果。
总之，基于FPGA的全桥逆变SPWM调制技术具有广阔的发展前景和应用价值。随着FPGA芯片技术的不断进步和应用领域的不断扩展，它将继续为智能电网和新能源发电等领域的控制技术提供强有力的支持。
相关代码,程序地址：http://lanzouw.top/665618208901.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/300a4498715d2f439cca90fbfae959d0/" rel="bookmark">
			navicat 运行SQL导入数据出错或不版本导入导出后某类字段获取不到等之类的错的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在mysql版本不一致的时候肯定会出现运行sql文件失败或sql运行正常单项目启动后无法获取某个字段的情况，造成这个的原因是因为在高版本的主要原因是不同版本之间数据格式的问题。特别是日期格式！
解决办法：
办法一、导出前将原表里面列的格式都改成varchar等字符型，导完再改过来。这样到新的电脑导入的进候就不会因为格式或字段长度等问题报一堆的错。
办法二、如果是单表时，先旧电脑导出表的结构。放到新电脑里运行SQL就可以创建好新的表，如果运行不行，就直接写字板打开SQL文件，复制表结构内容，放到navicat里面运行查询语句，如果有问题知道出在哪里，这样把表结构创建好了。
再来把旧电脑的表数据导出成SQL文件，再到刚刚新电脑运行SQL文件一般就没问题了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/832d8f6fff6c4418c12f14fc5944f488/" rel="bookmark">
			【开源】基于JAVA语言的天沐瑜伽馆管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目编号： S 039 ，文末获取源码。 \color{red}{项目编号：S039，文末获取源码。} 项目编号：S039，文末获取源码。
目录 一、摘要1.1 项目介绍1.2 项目录屏 二、功能模块2.1 数据中心模块2.2 瑜伽课程模块2.3 课程预约模块2.4 系统公告模块2.5 课程评价模块2.6 瑜伽器械模块 三、系统设计3.1 实体类设计3.1.1 瑜伽课程3.1.2 瑜伽课程预约3.1.3 系统公告3.1.4 瑜伽课程评价 3.2 数据库设计3.2.1 瑜伽课程表3.2.2 瑜伽课程预约表3.2.3 系统公告表3.2.4 瑜伽课程选课表3.2.5 学生成绩表 四、系统展示五、核心代码5.1 查询瑜伽课程5.2 瑜伽课程预约5.3 瑜伽课程评价5.4 查询瑜伽器械5.5 新增公告 六、免责说明 一、摘要 1.1 项目介绍 基于JAVA+Vue+SpringBoot+MySQL的天沐瑜伽馆管理系统，包含了瑜伽课程、课程预约、课程安排、课程评价、瑜伽器械、系统公告模块，还包含系统自带的用户管理、部门管理、角色管理、菜单管理、日志管理、数据字典管理、文件管理、图表展示等基础模块，天沐瑜伽馆管理系统基于角色的访问控制，给瑜伽学员、瑜伽教练、瑜伽管理员使用，可将权限精确到按钮级别，您可以自定义角色并分配权限，系统适合设计精确的权限约束需求。
1.2 项目录屏 源码下载
二、功能模块 本文设计的天沐瑜伽馆管理系统的包括了系统数据中心模块，用来存放管理系统通用的模块，另外分别设计了瑜伽课程模块、课程预约模块、系统公告模块、课程评价模块和瑜伽器械模块这五大模块，用于存放系统的核心业务逻辑。
2.1 数据中心模块 数据中心模块包含了对天沐瑜伽馆管理系统的基础模块，比如管理谁可以登录这套系统，记录这些人登录系统做了什么，不同的人拥有不同权限的管理。
2.2 瑜伽课程模块 瑜伽课程模块用于对瑜伽课程的数据进行管理，其中包括课程名称、课程介绍、课程类型、讲师ID、讲师、课程图片、课程价格、创建人等，可以通过此模块对瑜伽课程数据进行添加、编辑更新、删除、查询操作。
2.3 课程预约模块 课程预约模块是学生对课程的预约信息进行管理，学生可以对喜欢的瑜伽课程进行预约操作，包括团课和私教课程，瑜伽课程预约的字段包括课程ID、课程名称、课程介绍、课程类型、课程图片、课程价格、预约人、预约时间等，学生可以对管理员发布的瑜伽课程进行预约，也可以查询自己的历史预约情况，管理员可以维护学生的预约记录。
2.4 系统公告模块 系统公告模块用于管理员对系统公告的维护，系统公告的作用就是通知相关信息给学员，比如瑜伽课程的停课、调课信息等。系统公告字段其中包括公告标题、公告内容、图片、状态、排序值、发布人、创建人、创建时间等，瑜伽管理员可以增加、删除、编辑和条件查询系统公告，瑜伽学生可以查询系统公告。
2.5 课程评价模块 课程评价模块是维护学生的瑜伽课程的评价，当学生完成对某个瑜伽课程的学习后，有权对该瑜伽课程进行评价，以便于改善该课程的质量，瑜伽评价字段包括课程ID、课程名称、评价等级、评语、学生ID、学生、评价时间、创建人等。
2.6 瑜伽器械模块 瑜伽器械模块是维护瑜伽课程中所需要的器械数据，瑜伽机械是学生学习瑜伽课程的必备条件，所以系统设计了这个模块，瑜伽器械字段包括器械名称、品牌、功能用途、厂商、采购价、图片、备注、创建人等，瑜伽管理员可以新增、删除、修改瑜伽机械信息，瑜伽学员可以查询管理员发布的瑜伽器械明细。
三、系统设计 3.1 实体类设计 3.1.1 瑜伽课程 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/832d8f6fff6c4418c12f14fc5944f488/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/967c080d59cc5366474441ad9dc397d6/" rel="bookmark">
			AI工具汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💡 大家好，我是可夫小子，关注AIGC、读书和自媒体。
ChatGPT已经火了这么久，我也写不了少玩ChatGPT的方法。昨天OpenAI又推出了苹果手机的APP，我也介绍下载和安装的攻略。但根据读者反馈，仍然还是有许多同学没能用上。今天我就把我收集的所有免费、不需要魔法网络的使用ChatGPT方法和工具，一次性介绍给大家。有帮助就的点赞收藏，以免找不到了。
ChatGPT是什么 ChatGPT是一款基于自然语言处理和人工智能技术的聊天机器人服务。它可以通过语音或文字与用户进行交互，理解用户的意图并提供相应的回答和建议。
你可以简单的认为，它不是一个应用，不需要下载安装。而是一个网站，需要注册才能使用（后面会介绍注册和使用方法）。
ChatGPT是由OpenAI公司开发，该公司是人工智能领域的知名企业之一，其技术在自然语言处理和机器学习领域处于领先地位。
OpenAI与ChatGPT的发展历程 AI对话聊天 ​​​​​​​
ChatGAi​​​​​​ChatGAi是一款集成了最先进人工智能技术的全能应用，致力于满足您在工作和生活中的各种需求。凭借卓越的Ai聊天、Ai创作、Ai绘画助理、Ai私人助理等功能，ChatGAi模仿人类聊天方式...
https:// chatgai.lovepor.cn /
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5db575b956c4507b198696b84b7fb32d/" rel="bookmark">
			Android_Error_显示异常、功能失效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 简述ViewsetClickable(false)失效webView 滑动异常Dialog显示不全，无法调节尺寸 简述 以下是遇到的显示异常/功能失效的问题。如果是各种运行不起来、运行中崩溃之类的，参见另一篇文章Android_Error_无法运行、崩溃 。
View setClickable(false)失效 问题：设置了 setClickable(false) 仍然可以点击
原因：先设置了 setClickable(false) ，又在后续代码中设置了点击监听。setOnClickListener会将控件的isClickable重设为true。
解决：先绑定监听，再设置 setClickable(false) 。
webView 滑动异常 解决：AndroidManifest里，为该Activity配置打开硬件加速
&lt;activity ... android:hardwareAccelerated="true"/&gt; Dialog显示不全，无法调节尺寸 解决：需要先设置setContentView，再设置setAttributes，不然setAttributes不起效。
setContentView(R.layout.dialog_tips); Display display = getWindow().getWindowManager().getDefaultDisplay(); WindowManager.LayoutParams p = getWindow().getAttributes(); p.height = display.getHeight(); p.width = (int) (display.getWidth() * 0.8); //设置宽度 getWindow().setAttributes(p); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7cdad47210896e81be93867c3daaac9/" rel="bookmark">
			通过网线连接的局域网电脑怎么实现上网功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在机床里面的工控机有时候需要进行联网操作,但是又没有无线网或者外网网线,这时候可以通过笔记本的无线wifi功能实现上网功能.
通过网络适配器-找到wifi对应适配器-共享-1 打勾-2选中与工控机连接的网口-既可.
工控机端,将网口设置为自动获取IP
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/489738017fd924ca480455d32e76c76d/" rel="bookmark">
			Effective Java解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Effective Java 第一章 引言第二章 创建和销毁对象第1条：用静态工厂方法代替构造器第2条：遇到多个构造器参数时要考虑使用构建器第3条：用私有构造器或者枚举类型强化Singletion属性第4条：通过私有构造器强化不可实例化的能力第5条：优先考虑依赖注入来引用资源第6条：避免创建不必要的对象第7条：消除过期的对象引用第8条：避免使用终结方法和清除方法第9条：try-with-resources优先于try-finally 第三章 对于所有对象都通用的方法第10条：覆盖equals时请遵守通用约定第11条：覆盖 equals 时总要覆盖 hashCode第12条：始终要覆盖 toString第13条：谨慎地覆盖clone第14条：考虑实现Comparable接口 第四章 类和接口第15条：使类和成员的可访问性最小化第16条：要在公有类中使用访问方法而非公有域第17条：使可变性最小化第18条：复合优先于继承第19条：要么设计继承并提供文档说明，要么禁止继承第20条：接口优于抽象类第21条：为后代设计接口第22条：接口只用于定义类型第23条：类层次优于标签类第24条：静态成员类由于非静态成员类第25条：限制源文件为单个顶级类 第五章 泛型第26条：请不要使用原生态类型第27条：消除非受检的警告第28条：列表优于数组第29条：优先考虑泛型第30条：优先考虑泛型方法第31条：利用有限制通配符来提升API的灵活性第32条：谨慎并用泛型和可变参数第33条：优先考虑类型安全的异构容器 第六章 枚举和注解第34条：用enum代替int常量第35条：用实例域代替序数第36条：用EnumSet代替位域第37条：用EnumMap代替序数索引第38条：用接口模拟可扩展的枚举第39条：注解优先于命名模式第40条：坚持使用Override注解第41条：用标记接口定义类型 第七章 Lambda 和 Stream第42条：Lambda优先于匿名类第43条：方法引用优先于Lambda第44条：坚持使用标准的函数接口第45条：谨慎使用Stream第46条：优先选择Stream中无副作用的函数第47条：Stream要优先用Collection作为返回类型第48条：谨慎使用Stream并行 第八章 方法第49条：检查参数的有效性第50条：必要时进行保护性拷贝第51条：谨慎设计方法签名第52条：慎用重载第53条：慎用可变参数第54条：返回零长度的数组或者集合、而不是null第55条：谨慎返回optional第56条：为所有导出的API元素编写文档注释 第九章 通用编程第57条：将局部变量的作用域最小化第58条：for-each循环优先于传统的for循环第59条：了解和使用类库第60条：如果需要精确的答案，请避免使用float和double第61条：基本类型优先于装箱基本类型第62条：如果其他类型更适合，则尽量避免使用字符串第63条：了解字符串连接的性能第64条：通过接口引用对象第65条：接口优先于反射机制第66条：谨慎地使用本地方法第67条：谨慎地进行优化第68条：遵守普遍接受的命名惯例 第十章 异常第69条：只针对异常的情况才使用异常第70条：对可恢复的情况使用受检异常，对编程错误使用运行时异常第71条：避免不必要地使用受检异常第72条：优先使用标准的异常第73条：抛出和抽象对应的异常第74条：每个方法抛出的所有异常都要建立文档第75条：在细节消息中包含失败-捕获信息第76条：努力使失败保持原子性第77条：不要忽略异常 第十一章 并发第78条：同步访问共享的可变数据第79条：避免过度同步第80条：executor、task和stream优先于线程第81条：并发工具优先于wait和notify第82条：线程安全性的文档化第83条：慎用延迟初始化第84条：不要依赖于线程调度器 第十二章 序列化第85条：其他方法优先于Java序列化第86条：谨慎地实现Serializable接口第87条：考虑使用自定义的序列化形式第88条：保护性地编写readObject方法第89条：对于实例控制，枚举类型优先于readResolve第90条：考虑用序列化代理代替序列化实例 第一章 引言 建议配合书本一起看
第二章 创建和销毁对象 本章的主题是创建和销毁对象：何时以及如何创建对象，何时以及如何避免创建对象，如何确保它们能够适时地销毁，以及如何管理对象销毁之前必须进行的各种清理动作。
第1条：用静态工厂方法代替构造器 1、静态工厂方法与构造器不同的第一大优势在于，它们有名称
public class Person { private String name; private int age; private Person(String name, int age) { this.name = name; this.age = age; } // 创建一个Person对象 public static Person create(String name, int age) { return new Person(name, age); } } // 使用静态工厂方法创建对象 Person person = Person.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/489738017fd924ca480455d32e76c76d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d6a4a645411fc261f27e98a55b8e386/" rel="bookmark">
			SEATA整合sharding-jdbc
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.seata-order- sample模块
(1). application.properties
(2). seata.conf
2. seata-product-sample模块
(1). application.properties
(2). seata.conf
3.添加查询功能
4.本文代码及接口描述：
5.其它重要文章：
本文使用的初始源代码来自于：seata-samples/springcloud-seata-sharding-jdbc-mybatis-plus-samples at master · seata/seata-samples · GitHub
但是在运行上面代码过程中，发现老是运行失败，出现各种各样的错误，最后发现是因为配置的原因，初始代码中给的配置信息不全，这里给出完整的配置信息
订单服务、库存服务、Seata服务3个服务都需要注册到nacos中，seata服务的配置信息也要导入到nacos，Seata服务安装步骤：
centos7 安装seata + springboot配置_centos7安装seata_困知勉行1985的博客-CSDN博客
1.seata-order- sample模块 (1). application.properties #订单微服务服务信息 server.port=8001 spring.application.name=order-server #订单微服务注册中心 spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848 # 指定nacos命名空间，注意：这里的命名空间name与id是相同的 spring.cloud.nacos.discovery.namespace=e49265e9-1527-41c5-a2aa-e710b6da2b82 spring.cloud.nacos.discovery.group=SEATA_GROUP spring.cloud.nacos.discovery.username=nacos spring.cloud.nacos.discovery.password=nacos #sharding-jdbc数据源配置 spring.shardingsphere.datasource.names=ds0,ds1 spring.shardingsphere.datasource.ds0.type=com.zaxxer.hikari.HikariDataSource spring.shardingsphere.datasource.ds0.driver-class-name=com.mysql.cj.jdbc.Driver spring.shardingsphere.datasource.ds0.jdbc-url=jdbc:mysql://127.0.0.1:3306/seata_order_0?serverTimezone=UTC&amp;characterEncoding=utf8 spring.shardingsphere.datasource.ds0.username=root spring.shardingsphere.datasource.ds0.password=123456 spring.shardingsphere.datasource.ds1.type=com.zaxxer.hikari.HikariDataSource spring.shardingsphere.datasource.ds1.driver-class-name=com.mysql.cj.jdbc.Driver spring.shardingsphere.datasource.ds1.jdbc-url=jdbc:mysql://127.0.0.1:3306/seata_order_1?serverTimezone=UTC&amp;characterEncoding=utf8 spring.shardingsphere.datasource.ds1.username=root spring.shardingsphere.datasource.ds1.password=123456 #sharding-jdbc分片配置 spring.shardingsphere.sharding.default-database-strategy.inline.sharding-column=id spring.shardingsphere.sharding.default-database-strategy.inline.algorithm-expression=ds$-&gt;{id % 2} spring.shardingsphere.sharding.tables.order_info.actual-data-nodes=ds$-&gt;{0..1}.order_info_$-&gt;{0..2} spring.shardingsphere.sharding.tables.order_info.table-strategy.inline.sharding-column=id spring.shardingsphere.sharding.tables.order_info.table-strategy.inline.algorithm-expression=order_info_$-&gt;{id % 3} #sharding-jdbc显示最终SQL spring.shardingsphere.props.sql.show=true #mybatis-plus配置 mybatis-plus.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d6a4a645411fc261f27e98a55b8e386/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b06517a05f23c708ee5d75aa2894d9e/" rel="bookmark">
			rest_framework_django 学习笔记五（过滤、排序、分页）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		rest_framework_django 学习笔记五（过滤、排序、分页） 一、过滤 1、安装扩展 django-fitlter 对于列表数据可能需要根据字段进行过滤，我们可以通过添加 django-fitlter 扩展来增强支持。
pip install django-filter 2、设置 在配置文件中增加过滤后端的设置
#settings.py INSTALLED_APPS = [ ... 'django_filters', ... ] REST_FRAMEWORK = { # 过滤 "DEFAULT_FILTER_BACKENDS": ( 'django_filters.rest_framework.DjangoFilterBackend',# 配置过滤 # "demo_app.filters.CustomDjangoFilterBackend", # 自定义 过滤 "rest_framework.filters.SearchFilter", "rest_framework.filters.OrderingFilter", ), } 3、视图中配置 在视图中添加 filter_fields 属性，指定可以过滤的字段
3.1 filterset_fields 精确查询 filterset_fields 是用于在视图集中指定哪些字段可以被用作过滤器的。这意味着你可以在视图集中定义这些字段，并使用它们来过滤查询结果。
from rest_framework.viewsets import ModelViewSet class PublishModelviewSet(ModelViewSet): """ list: 返回数据列表 create: 创建出版社 retrieve： 单挑查询 update: 修改 destroy: 删除 """ queryset = Publish.objects.all() serializer_class = PublishSerializer filterset_fields = ['name', 'city','id','email'] # 可过滤的字段 (搜索字段) 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b06517a05f23c708ee5d75aa2894d9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59512268cd8deff71299ad156444399e/" rel="bookmark">
			rest_framework_django学习笔记四(限流、权限)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		rest_framework_django学习笔记四(权限、限流) 一、权限 可以在配置文件中设置默认的权限管理类；
REST_FRAMEWORK = { "DATETIME_FORMAT": "%Y-%m-%d %H:%M:%S", # 日期时间格式配置 "DATE_FORMAT": "%Y-%m-%d", "DEFAULT_PERMISSION_CLASSES": [ "rest_framework.permissions.IsAuthenticated", # 只有经过身份认证确定用户身份才能访问 # 'rest_framework.permissions.IsAdminUser', # is_staff=True才能访问 —— 管理员(员工)权限 # 'rest_framework.permissions.AllowAny', # 允许所有 # 'rest_framework.permissions.IsAuthenticatedOrReadOnly', # 有身份 或者 只读访问(self.list,self.retrieve) ], } 如果未指定，则采用如下默认配置
REST_FRAMEWORK = { "DATETIME_FORMAT": "%Y-%m-%d %H:%M:%S", # 日期时间格式配置 "DATE_FORMAT": "%Y-%m-%d", "DEFAULT_PERMISSION_CLASSES": [ #"rest_framework.permissions.IsAuthenticated", # 只有经过身份认证确定用户身份才能访问 # 'rest_framework.permissions.IsAdminUser', # is_staff=True才能访问 —— 管理员(员工)权限 'rest_framework.permissions.AllowAny', # 允许所有 # 'rest_framework.permissions.IsAuthenticatedOrReadOnly', # 有身份 或者 只读访问(self.list,self.retrieve) ], } 也可以在具体的视图中通过 permission_classes 属性
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59512268cd8deff71299ad156444399e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f7a4bd79356a701f1e0312b6a2f38eb/" rel="bookmark">
			navicat premium 历史版本下载地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		navicat贴心地给大家准备了一致的下载地址：
只是没有把旧版本的链接放出来而已。
链接的格式 ： 前缀+版本+类型+语言+位数
·前缀：http:/download.navicat.com/download/navicat
·版本：三位数，前两位是大版本，后一位是小版本，如163代表16.3版本
·类型：premium代表豪华版，其他如mysql等
·语言：cs代表简体中文，en代表英文
·位数：x86代表32位，x64代表64位，一般下载64位即可
如16.3 64位 英文
http://download.navicat.com/download/navicat163_premium_en_x64.exe
如16.3 64位 中文
http://download.navicat.com/download/navicat163_premium_cs_x64.exe
根据这些可以下载很多的版本：
这里下载的可都是完全正版的。可以试用14天的版本。
如果14天到期了，在csdn.net上找一下，有脚本，可以再续14天。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bdb240d1617f67ca52c8ce827aecaa4/" rel="bookmark">
			Centos7重置密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 一、Centos7忘记密码的重置步骤如下 一、Centos7忘记密码的重置步骤如下 重启服务器在进入系统界面时 按e进入编辑页面，并找到linux16开头的行，在最后输入rw single init=/bin/bash (如图) 注：如果按e后无法进入编辑页面，提示的是 enter username 说明系统对进入grub菜单设置了用户和密码，此时可尝试输入username
为root，passwd不输入直接回车 看是否能进入编辑页面，如果还是无法进入的话请看下方文档（忘记root密码取消grub加密操作）
3. 输入完毕之后 按ctrl + X 组合键进入单用户模式
4. 依次输入 (如图)
mount -o remount,rw / passwd (输入修改后的密码) touch /.autorelabel exec /sbin/init 输入完毕后按回车，系统会重启，然后输入用户和密码即可 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3340b0a8fa733af130f727d7266204c/" rel="bookmark">
			ubuntu 安装docker，并设置docker 代理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装docker 如何在 Ubuntu 22.04 LTS 中安装 Docker 和 Docker Compose-如何在ubuntu上安装docker
离线安装docker:
Ubuntu 20.04离线安装Docker 社区版 - 知乎
问题1：
curl: (35) OpenSSL SSL_connect: Connection reset by peer in connection to download.docker.com:443
set -ex in shell script + set curl proxy 问题2：
当服务器通过代理连接外网时，docker pull 会出现问题，
Error response from daemon: Get "https://registry-1.docker.io/v2/": read tcp 10.32.97.179:41268-&gt;34.205.13.154:443: read: connection reset by peer
sudo mkdir -p /etc/systemd/system/docker.service.d sudo touch /etc/systemd/system/docker.service.d/proxy.conf sudo vim /etc/systemd/system/docker.service.d/proxy.conf #输入以下内容，其中代理改成自己的，[Service]不能丢 [Service] Environment="HTTP_PROXY=http://proxy.example.com:8080/" Environment="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3340b0a8fa733af130f727d7266204c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c46e6b2c835c2353f45d81ff7ab99ee/" rel="bookmark">
			MySQL通过.frm与.ibd文件对表结构和数据进行恢复（Windows环境）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景 1.1、问题来源 找了个开源项目，发现没有sql文件，只有.frm文件和.ibd文件，想要通过这些文件恢复数据库表结构以及数据。
1.2、环境介绍 数据库版本：MySQL 5.7
数据库表引擎：innodb
二、解决方案 2.1、准备工作 进行数据恢复的表.frm和.ibd文件 新创建一个数据库db_demo 2.2、表结构恢复 创建一个相同名字的表user，字段随意 CREATE TABLE `user` ( `id` int(11) NOT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 关掉MySQL服务 net stop mysql 把准备的user.frm文件复制到MySQL的data/db_demo文件夹，并覆盖原来的.frm文件 启动MySQL服务 net start mysql 在sql窗口执行语句 FLUSH TABLES; SHOW CREATE TABLE `user`; 找到MySQL的错误日志 SHOW VARIABLES LIKE 'log_error'; 打开错误日志 从错误日志可以看出，user表有6个字段，删除user表，再重新创建，随意新增6个字段 DROP TABLE `user`; CREATE TABLE `user` ( `1` varchar(255) DEFAULT NULL, `2` varchar(255) DEFAULT NULL, `3` varchar(255) DEFAULT NULL, `4` varchar(255) DEFAULT NULL, `5` varchar(255) DEFAULT NULL, `6` varchar(255) DEFAULT NULL ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 重复前面的2-4步骤，即可得到user表原来的结构 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c46e6b2c835c2353f45d81ff7ab99ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/faad73537cff80fddffabdb1cab36fd5/" rel="bookmark">
			SAP ABAP 如何修改视图为非跨客户端的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要加入MANDT字段，否则就是跨客户端的
同时要注意在SE14点击激活，否则就会报错
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19522b575a140f25924d15c1f37d499e/" rel="bookmark">
			【笔记】Clion 中运行 C/C&#43;&#43;11 之 CMakeLists.txt 的配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该文章记录第一次使用 Clion 时，对 CMakeLists 的配置，使其能够运行 C/C++11 的代码。
一. CMakeLists.txt 的配置 1、首先我们在需要新建一个项目
2、填写新建项目相关的信息
3、修改 CMakeLists.txt 文件内容
替换文本：
# 使用此 CMakeList 时，若要新建 C++ 文件，请按照以下步骤： # 1. 右键根目录——新建——C/C++源文件 # 2. 在弹出的对话框中，输入文件名(英文小写及下划线)，后缀为 ".cpp"，不要勾选“添加到目标”，点击确定。 # 3. 点击 左上角横线——文件——重新加载 CMake 项目 。 # 设定 C++11 标准 set(CMAKE_CXX_STANDARD 11) # 将 C++ 标准设置为 C++11 set(CMAKE_CXX_STANDARD_REQUIRED ON) # C++11 是强制要求，不会衰退至低版本 # 设定构建运行路径，避免污染根目录 set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/.archive) set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/.library) set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/.runtime) set(LIBRARY_OUTPUT_PATH ${CMAKE_SOURCE_DIR}/.path) # 遍历项目根目录下所有的 .cpp 文件，自动添加 file(GLOB_RECURSE files *.cpp **/*.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19522b575a140f25924d15c1f37d499e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfd57fcb8138d6c13197921d0da8c94c/" rel="bookmark">
			北美Verizon运营商认证怎么办理？测试要求有哪些？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Verizon是美国一家电信公司，是全球领先的宽带和电信服务提供商，由美国两家原地区贝尔运营公司——大西洋贝尔和Nynex合并建立BellAtlantic后，又在2000年6月30日与独立电话公司GTE合并而成的。主要业务为语音通话、固定宽带和无线通信。Verizon在美国、欧洲、亚洲、太平洋等全球多个国家经营电信及无线业务。
Verizon认证意味这产品经过一系列测试和要求后能够满足Verizon的许可，Verizon认可了产品的无线安全性和无线性能。
在获取Verizon认证之前，所有设备必须经过美国联邦通信委员会（FCC）的型式认证，其中还有PTCRBGCF认证等需求，然后才能开始Verizon认证一致性测试。
Verizon认证测试项目有哪些？
1、Verizon网络IOT互连互通测试
Verizon认证中的互连互通测试内容以5G和4G为准，3G和2G现在因为退网原因已经不纳入测试内容。
2、LBS/aGPS/SUPL应用测试流程
标准实验室测试完成后，开发商就可开始LBS/aGPS/SUPL流程。
3、MMS设备测试流程
对于支持彩信且需要使用Verizon MMSC服务器的设备，必须在设备认证之前完成彩信测试流程。
4、专用网络测试
适用于使用Verizon专用网络的设备，目前Verizon有的专用网络有4G LTE和5G网络。
5、设备管理服务测试
使用了Verizon客户端软件包或Verizon的M2M（LWM2M）OTADM参考客户端软件包客户。
6、入站永久漫游
如果满足特定条件下，Verizon 将认为设备非偶然在其网络中漫游。
Verizon的认证流程如下：
-Device Registration设备注册
-DLD设备锁定
-Testing Authorization测试接收
-Device in Testing设备测试中
-Post Results报告上传
-Test Pass设备审核
-Device Pass审核通过
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f76ba5c5ad5cb90ad208d7a8511c256b/" rel="bookmark">
			【开源】基于JAVA的校园电商物流云平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目编号： S 034 ，文末获取源码。 \color{red}{项目编号：S034，文末获取源码。} 项目编号：S034，文末获取源码。
目录 一、摘要1.1 项目介绍1.2 项目录屏 二、功能模块2.1 数据中心模块2.2 商品数据模块2.3 快递公司模块2.4 物流订单模块 三、系统设计3.1 用例设计3.2 数据库设计3.2.1 商品表3.2.2 快递公司表3.2.3 物流订单表 四、系统展示五、核心代码5.1 查询商品5.2 查询快递公司5.3 查询物流订单5.4 新增物流订单5.5 快递收揽派签 六、免责说明 一、摘要 1.1 项目介绍 基于JAVA+Vue+SpringBoot+MySQL 的校园电商物流云平台，包含了商品管理模块、快递公司模块、物流订单模块，还包含系统自带的用户管理、部门管理、角色管理、菜单管理、日志管理、数据字典管理、文件管理、图表展示等基础模块，校园电商物流云平台基于角色的访问控制，给商家、物流公司、物流管理员使用，可将权限精确到按钮级别，您可以自定义角色并分配权限，系统适合设计精确的权限约束需求。
1.2 项目录屏 源码下载
二、功能模块 互联网和电子商务行业已成为各产业升级创新的“发动机”，也是大众创业的肥沃土壤。各大院校纷纷在基于互联网或电子商务平台的大学生创业教育方面进行了探索和尝试。依托电子商务专业教育体系，立足于高校市场资源，利用新型的社群移动电商平台开展电子商务创业教育创新实践，取得了较好效果。本文旨在建立一个面向校园电商创业的物流云平台，采用Vue、SpringBoot、MySQL技术，包含数据中心模块、商品档案模块、快递公司模块、物流订单管理模块，对物流配送实现云平台管理。
本文设计的面向校园电商创业的物流云平台的包括了系统数据中心模块，用来存放管理系统通用的模块，另外分别设计了商品档案模块、快递公司模块、物流订单模块这三大模块，用于存放系统的核心业务逻辑。
2.1 数据中心模块 数据中心模块包含了对面向校园电商创业的物流云平台的基础模块，比如管理谁可以登录这套系统，记录这些人登录系统做了什么，不同的人拥有不同权限的管理。
2.2 商品数据模块 商品数据模块用于对商品的数据进行管理，其中包括商品ID、商品名称、商品规格、商品图片、商品备注、归属人ID、归属人、创建人等，可以通过此模块对商品数据进行添加、编辑更新、删除、查询操作。
2.3 快递公司模块 快递公司模块是对快递公司的档案信息进行管理，快递公司是快递运输的主要参与者，快递公司字段包括公司简称、公司全名、LOGO、营业执照、地址、经营范围、备注、创建人等，管理员可以新增快递公司的数据，用户可以查询管理员发布的快递公司信息。
2.4 物流订单模块 物流订单模块是对商品数据的实例化，有了商品后，用户就可以对商品进行创建物流订单，这就产生了物流订单模块，其中包括物流单号、下单人ID、下单人、收件人、收件电话、收件地址、下单日期、订单状态、发货物流等，用户可以进行物流下单，快递公司可以操作发货，管理员可以删除物流订单。
三、系统设计 3.1 用例设计 3.2 数据库设计 3.2.1 商品表 3.2.2 快递公司表 3.2.3 物流订单表 四、系统展示 五、核心代码 5.1 查询商品 @RequestMapping(value = "/getByPage", method = RequestMethod.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f76ba5c5ad5cb90ad208d7a8511c256b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a034f9478aac47c587763796823f5be/" rel="bookmark">
			以太网头介绍（IP头、TCP头、UDP头）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、以太网帧格式1.1 MAC 地址头1.2 IP头结构的定义1.2.2 抓包图示 1.3 TCP头结构定义1.4 UDP头结构定义 二、wireshark TCP常见异常报文分析2.1 Tcp Previous segment not captured2.3 TCP Window (TCP ZeroWindow 与 TCP window Full) 一、以太网帧格式 原文地址：【TCP/IP】MAC帧头、IP头、TCP头和UDP头
百度百科
以太网发布标准有哪些，是哪些机构发布的
1.1 MAC 地址头 https://juejin.cn/post/7087218595159080968 MAC帧是数据帧的一种。而所谓数据帧，就是数据链路层的协议数据单元，它包括三部分：帧头，数据部分，帧尾。其中，帧头和帧尾包含一些必要的控制信息，比如同步信息、地址信息、差错控制信息等；数据部分则包含网络层传下来的数据，比如ip数据包。
目前，有四种不同格式的以太网帧在使用，它们分别是：
Ethernet II即DIX 2.0：Xerox与DEC、Intel在1982年制定的以太网标准帧格式。Cisco名称为：ARPA。
Ethernet 802.3 raw：Novell在1983年公布的专用以太网标准帧格式。Cisco名称为：Novell-Ether。
Ethernet 802.3 SAP：IEEE在1985年公布的Ethernet 802.3的SAP版本以太网帧格式。Cisco名称为：SAP。
Ethernet 802.3 SNAP：IEEE在1985年公布的Ethernet 802.3的SNAP版本以太网帧格式。Cisco名称为：SNAP。
Ethernet II和IEEE802.3的帧格式比较类似，主要的不同点在于前者定义的2字节为包类型，而后者定义的2字节为的长度；所幸的是，后者定义的有效长度值与前者定义的有效类型值无一相同，这样就容易区分两种帧格式了。如果值大于 1500（0x05DC），说明是以太网类型字段，EthernetII 帧格式。如果值小于等于1500，说明是长度字段，IEEE802.3 帧格式。因此类型字段值最小的是 0x0600。而长度最大为 1500。
/*数据帧定义，头14个字节，尾4个字节*/ typedef struct _MAC_FRAME_HEADER { char m_cDstMacAddress[6]; //目的mac地址 char m_cSrcMacAddress[6]; //源mac地址 short m_cType; //上一层协议类型，如0x0800代表上一层是IP协议，0x0806为arp }__attribute__((packed))MAC_FRAME_HEADER,*PMAC_FRAME_HEADER; typedef struct _MAC_FRAME_TAIL { unsigned int m_sCheckSum; //数据帧尾校验和 }__attribute__((packed))MAC_FRAME_TAIL, *PMAC_FRAME_TAIL; 以太类帧型：占16个比特，表示协议类型。 0800：IP协议0806：ARP 协议86DD：IPv60000-05DC：IEEE 802.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a034f9478aac47c587763796823f5be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea0883e39963aa15a0a9df9e35d7d9b4/" rel="bookmark">
			开源项目-对新手极其友好的数据结构与算法入门教程-hello-algo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方“嵌入式应用研究院”，选择“置顶/星标公众号”
干货福利，第一时间送达！
排版 | 嵌入式应用研究院
素材来源 |Github开源社区
从业多年，大家是否在工作中遇到很多软件逻辑问题难以解决？其实大多数情况下是由于自身的理论知识储备不足，而不是真的不知道如何去解决。算法和数据结构决定一个程序员的高度，不管是从事前后端开发，还是从事嵌入式软件开发，都需要掌握数据结构与算法。笔者最近在Github上发现这么一个屌炸天的开源项目-hello-algo。这除了屌炸天，还是一个颜值极高的开源项目，项目旨在打造一本开源免费、新手友好的数据结构与算法入门教程。
全书采用动画图解，内容清晰易懂、学习曲线平滑，引导初学者探索数据结构与算法的知识地图。
源代码可一键运行，帮助读者在练习中提升编程技能，了解算法工作原理和数据结构底层实现。
鼓励读者互助学习，提问与评论通常可在两日内得到回复。
它目前的版本支持多达10多种编程语言，例如C、C++、Java、Python、Go等主流编程语言。
Github开源地址：
https://github.com/krahets/hello-algo 可能部分网友无法访问该链接，因此我又同步建了一个仓库，让所有网友都可以访问到这个仓库：
https://gitee.com/morixinguan/hello-algo 专家推荐语 “一本通俗易懂的数据结构与算法入门书，引导读者手脑并用地学习，强烈推荐算法初学者阅读。”
—— 邓俊辉，清华大学计算机系教授
“如果我当年学数据结构与算法的时候有《Hello 算法》，学起来应该会简单 10 倍！”
—— 李沐，亚马逊资深首席科学家
往期精彩 C语言三剑客之《C专家编程》一书精华提炼
C语言三剑客之《C陷阱与缺陷》一书精华提炼
有关版本等信息的重要性(以STM32产品开发为例)
移植uc/OS-III最新版到小熊派开发板（STM32L431）
【嵌入式Linux学习笔记】QT在Linux嵌入式设备上的使用
一个集RTOS、GUI、蓝牙、电源管理等一体的嵌入式软硬件开源项目
觉得本次分享的文章对您有帮助，随手点[在看]并转发分享，也是对我的支持。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d3ef03b81b1b7730d60f7ffcd7394e6/" rel="bookmark">
			Vue中下载不同文件的几种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当在Vue中需要实现文件下载功能时，我们可以有多种方式来完成。下面将介绍五种常用的方法。
1. 使用window.open方法下载文件 &lt;template&gt; &lt;div&gt; &lt;button @click="downloadFile('file1.pdf')"&gt;下载文件1&lt;/button&gt; &lt;button @click="downloadFile('file2.jpg')"&gt;下载文件2&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { methods: { downloadFile(fileName) { const fileUrl = '/path/to/' + fileName; // 文件的URL地址 window.open(fileUrl); } } }; &lt;/script&gt; 在上面的示例中，我们使用了window.open方法来打开一个新窗口，并直接访问文件的URL地址，从而触发文件下载。
2. 使用&lt;a&gt;标签进行文件下载 &lt;template&gt; &lt;div&gt; &lt;button @click="downloadFile('file1.pdf')"&gt;下载文件1&lt;/button&gt; &lt;button @click="downloadFile('file2.jpg')"&gt;下载文件2&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { methods: { downloadFile(fileName) { const fileUrl = '/path/to/' + fileName; // 文件的URL地址 const link = document.createElement('a'); link.href = fileUrl; link.setAttribute('download', fileName); link.click(); } } }; &lt;/script&gt; 在上面的示例中，我们首先创建一个&lt;a&gt;标签，然后设置其href属性为文件的URL地址，download属性为要下载的文件名。最后，通过调用click()方法触发链接的点击事件，实现文件的下载。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d3ef03b81b1b7730d60f7ffcd7394e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc6e3945c8b4fbc9d26e940a023f0d36/" rel="bookmark">
			Swin Transformer实战图像分类(Windows下，无需用到Conda，亲测有效)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、从官网拿到源码，然后配置自己缺少的环境。
针对可能遇到的错误：
二、数据集获取与处理
2.1 数据集下载
2.2 数据集处理
三、下载预训练权重
四、修改部分参数配置
4.1 修改config.py
4.2 修改build.py
4.3 修改units.py
4.4 修改main.py
4.5 修改其他的地方
4.6 将最后结果以折线图的形式呈现出来
五、其他可修改的地方
六、运行代码
前言 关于Swin Transformer的讲解和实战，实际上网络上已经有很多了。不过有一些代码跑起来可能有一些问题（有一些确实有点问题，或者没头没尾的）。
最初的时候，我通过一些调研，参照网上的一些教程，跑的时候也遇到了一些问题，但是最后确实是成功了。下面我就详细地来讲述应该怎么做。
关于Swin Transformer的基础知识就不再赘述了。相信想到用Swin Transformer来实战的同学肯定已经多多少少对其有一定了解了。
在此，我说一下我的实战的思路：
从官网拿到代码，然后改改，换成自己的数据集，加载它的预训练权重，然后让代码跑起来。
如果你的coding能力确实比较强，那么你完全可以从官网上找到部分Swin Transformer的Model部分核心代码，然后数据处理部分、跑模型的部分都自己来写，这样做也完全OK。但是对能力要求较高，并且对模型的理解要求也比较高。比如，参考某B站Up主的视频，它的代码就是这样子的（在别人的文章里应该都能看的到，我就不重复了）。
而我们在这里就介绍傻瓜式的操作。
我的环境：
Win 10Python 3.8Pytorch/torchvision 1.13.1+cu116NVIDIA GeForce RTX 3060（CUDA 11.7.102）Pycharm Community； OK，开始。
一、从官网拿到源码，然后配置自己缺少的环境。 论文: https://arxiv.org/abs/2103.14030
代码: https://github.com/microsoft/Swin-Transformer
注意下，这里的fused window process、还有apex等不安装也是可以跑通的。它们的安装不影响代码的运行。如果你最后对性能有很高的要求，那你再去下载，我们这里主要是学习，然后让它先跑起来。
你要最起码确保在data文件夹下、models文件夹下和最外层的所有py文件都没有依赖报错（就是导入包的报错）
就是如上图那些的一些包，你给它都下载好不报错就行了。或者你新搞个虚拟环境，然后重新装一下就行，怎么搞虚拟环境可以参考这篇文章【正在更新中...】。
针对可能遇到的错误： 注意，这个错误只是可能遇到，不是一定会遇到。它和你下载的Pytorch的版本有关系。并且你的分类数如果大于5，应该是不会报错的。
那我们需要做什么呢？就是你可能需要改一下你的accuracy函数。
说一下这个函数的入口在哪找，因为这个函数并不是Swin-transformer的函数，它是Pytorch内置的文件函数，所以它原本是只读的（只是有写保护，并非不可更改）。那么我们从哪里找呢？
找到main.py-&gt;函数validate，有一行
acc1, acc5 = accuracy(output, target, topk=(1, 5)) 鼠标点击accuracy函数，然后按ctrl B就可以了(转到定义)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc6e3945c8b4fbc9d26e940a023f0d36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92dca3726b81cc9d59b7f7dd127e0661/" rel="bookmark">
			MySQL索引优化实战二
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分页查询优化 很多时候我们业务中实现分页功能时可能会用如下SQL来实现：
select * from employees LIMIT 10000,10 表示从表中中区从10001行开始的10行记录，看似只查了10条记录，但是这条SQL是先读取10010条记录，然后抛弃前10000条记录，然后读到后面10条想要的数据，因此要查询一张大表比较靠后的数据，执行效率是很低的。
1、根据自增且连续的主键排序的分页查询 select * from employees LIMIT 90000,5 select * from employees where id&gt;90000 limit 5 改写后的SQL走了索引，且看执行时间，改写后的时间更快。
但是这种方式在很多场景中不适用，因为表中某些数据被删后造成主键空缺，导致结果不一致。
上面改写必须满足两个条件：
主键自增且连续结果是按照主键排序的 2、根据非主键字段排序的分页查询 select * from employees order by name LIMIT 90000,5 explain select * from employees order by name LIMIT 90000,5 没有使用索引，是因为：扫描整个扫一年病查找到没索引的行比扫描全表的成本更高。
如何优化呢？
关键是让排序返回的字段尽可能的少，所以可以让排序和分页操作先查出主键，然后根据主键查找到对应的记录，如下SQL：
select * from employees e INNER JOIN (SELECT id FROM employees ORDER BY name limit 9000,5) ed on e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92dca3726b81cc9d59b7f7dd127e0661/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0c65f8ef5a82d2ebd1a26d8f6a00bfc/" rel="bookmark">
			STM32CubeMX安装及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、软件安装 1、软件下载 1.1 Java环境下载 由于STM32CubeMX软件是基于Java环境运行的，所以需要先安装Java SE，下载地址：Java SE下载
1.2 STM32CubeMX下载 从ST的官网下载，下载地址：STM32CubeMX下载
点击获取软件，再点击获取最新版。
2、软件安装 1.1 Java SE安装 双击exe，点击安装，等待“安装成功”
1.2 STM32CubeMX安装 步骤1：解压，双击exe，开始提起（Extracting）安装程序 步骤2：点击Next，再点击Next步骤3：第一个选项必选；第二个选择不是必选项，想参加用户改善计划的可以选手，会上传用户的日志、错误信息等。再点击Next步骤4：选择安装路径，然后点击Next，等待安成功即可 二、软件启动与安装库文件 2、修改默认库文件路径 第一次使用cubeMX软件，建议更改库文件路径，不要默认在C盘的用户文件夹中。
先点击help，再点击Updatar Setting。
修改Repository Folder下的文件路径。
2、在线安装固件库 也可以不用在这里安装，如果不知道使用什么MCU的话，可以暂时不安装，等到生成程序工程的时候，软件会自动安装。
先点击help，再点击Manage embedded software packages。
选择需要的库文件和版本号，点击install即可开始安装。
三、新建第一个工程 1、新建工程 点击ACCESS TO MCU SELECTOR。
2、选择MCU型号 通过搜索栏搜索自己想添加的MCU 型号，然后在右下方点击对应封装的器件。最后点击开始工程。
3、设置Debug 根据自己下载方式设置对用的debug选项，如果不设置该项，程序只能运行一遍。如果使用串行下载方式（SWDIO,SWCLK）选择Serial Wire。
4、设置时钟 4.1 设置时钟源 时钟分类：
时钟中文名频率来源HSI高速内部时钟RC振荡器，频率为8MHzHSE高速外部时钟外部的振荡器，频率范围为4MHz~16MHzLSI低速内部时钟低速内部时钟LSE低速外部时钟外接的频率为32.768kHz的石英晶体 时钟源选择：
时钟源说明Disable不使能，使用内部时钟BYPASS Clock Source旁路时钟源Crystal/Ceramic Resonator外部晶体/陶瓷谐振器 设置如下图所示：
4.3 设置时钟树 先在时钟树上选择对应的时钟通道，选择PLL Source Mux和**System Clock Mux，**然后设置时钟源的频率，最后设置需要的时钟频率HCLK，各种倍频和分频选择器会自动选择合适的值。
5、此时可以配置各种外设的功能 6、程序配置 如下图配置，没有注释的可以默认：
7、生成工程 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/796093242a281f4698864dbbe2301a60/" rel="bookmark">
			Python pygame(GUI编程)模块最完整教程（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇文章：
Python pygame(GUI编程)模块最完整教程（1）_pygame模块详解_Python-ZZY的博客-CSDN博客
总目录：
README.md · Python-ZZY/Python-Pygame最完整教程 - Gitee.com
6 文字绘制 参考资料：pygame.font — pygame-ce v2.4.0 documentation
6.1 载入字体 pygame中绘制文字的第一步是载入字体。载入字体的方式通常有两种，第一种是使用指定路径的字体文件，第二种是从系统字体库中载入字体。推荐第一种方式，因为在游戏打包后，你无法确定你电脑上安装的字体文件在其他用户的电脑上也安装过。
pygame.font和pygame.freetype模块提供了文字绘制的操作。font模块功能比较简单，freetype模块是font模块功能的扩展。
Font类通过字体文件创建一个字体对象，支持包括*.ttf等一系列的TrueType字体。载入字体时，需要提供一个字体文件路径和字体大小。示例：
font = pg.font.Font("name_of_font.ttf", 12) 如果是调用系统字体文件，则使用SysFont。示例：
font = pg.font.SysFont("宋体", 12) 6.2 渲染字体 加载字体后，下一步是渲染字体。渲染字体调用字体对象的render()方法，将一段文字转换成使用该字体的pygame.Surface对象。
render(text, antialias, color, bgcolor=None, wraplength=0) -&gt; Surface text是要渲染的一段文字内容。
注意：pygame-ce 2.1.4版本之前不支持渲染换行符"\n"。 antialias是一个布尔值，代表是否使用抗锯齿，抗锯齿的文字更加平滑，但是速度会稍慢一点点，一般选择True。color是文字的颜色。background是文字背景颜色，设为None则为透明背景。
注意：如果文字绘制的位置始终是纯色背景，那么最好是指定background背景颜色。因为使用纯色填充比使用透明填充性能会更好。 渲染后的字体可以当做表面来处理。下面的示例显示了如何绘制文字。
import pygame as pg pg.init() screen = pg.display.set_mode((300, 200)) font = pg.font.Font("simhei.ttf", 20) #大小为20的simhei字体文件（在同一目录下） surf = font.render("你好!这是一段文字", True, (255, 255, 255)) while True: screen.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/796093242a281f4698864dbbe2301a60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f08553fb92e7c0863210fb3bb1d995f6/" rel="bookmark">
			【vue】vue-slick-carousel插件，实现横向滚动列表手动左右滚动（也可设置为自动滚动）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求：图片列表横向滚动的时候，隐藏原始滚动条，通过左右箭头控制滚动条往左右按一定的步长移动。 el-carousel走马灯一滚动就是一屏，不适合我的需求 在npm官网搜vue-slick-carousel，查看更详细的配置
vue-slick-carousel配置请戳这里
效果图：
相关配置代码：
以下是具体代码：
npm i vue-slick-carousel 页面中使用
import VueSlickCarousel from "vue-slick-carousel"; import "vue-slick-carousel/dist/vue-slick-carousel.css"; // optional style for arrows &amp; dots import "vue-slick-carousel/dist/vue-slick-carousel-theme.css"; components: { VueSlickCarousel }, 1、VueSlickCarousel 一定要设width: 100%
2、carouselOptions具体配置项
3、allFlowArr要展示的内容数组
&lt;VueSlickCarousel style="width: 100%" v-bind="carouselOptions"&gt; &lt;div class="ml-3" v-for="(item, index) in allFlowArr" :key="index"&gt; &lt;div class="Tabs_theme__Fe30F" :style="{ background: `url(${item.bcgtop}) center center / cover no-repeat`, }" &gt; &lt;div class="Tabs_themeHover__6BExd"&gt;{{ item.titleTop }}&lt;/div&gt; &lt;/div&gt; &lt;div class="Tabs_theme__Fe30F mt-2" :style="{ background: ` url(${item.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f08553fb92e7c0863210fb3bb1d995f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/102d2ff0f5cca3769cc1d78e8c6b07af/" rel="bookmark">
			二. BEV感知算法基础模块讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言0. 简述1. 基础模块补充讲解1.1 2D图像处理1.2 3D特征之点处理方案1.3 3D特征之体素处理方案 2. 从2D到3D转换模块2.1 LSS(Lift,Splat and Shoot)2.2 Pseudo LiDAR 3. 从3D到2D转换模块3.1 Explicit Mapping3.2 Implicit Mapping 4. BEV感知中的Transformer4.1 空间注意力之STN4.2 通道注意力之SENet4.3 混合注意力之CBAM4.4 Self-Attention4.5 ViT4.6 Swin Transformer4.7 DETR4.8 DETR3D 总结下载链接参考 前言 自动驾驶之心推出的《国内首个BVE感知全栈系列学习教程》，链接。记录下个人学习笔记，仅供自己参考
本次课程我们来学习下课程第二章——BEV感知算法基础模块讲解，一起去了解下 BEV 感知算法中的一些基础模块
课程大纲可以看下面的思维导图
0. 简述 接下来进入我们第二章内容的一个讲解，BEV 感知算法基础模块
首先，我们在第一章中主要给大家介绍了 BEV 感知算法中的一些常见的概念，BEV 空间所具有的独特的优势以及我们常见的 BEV 感知算法的一个分类，我们提到 BEV 感知算法可以分为 BEV LiDAR 也就是点云类，还有 BEV Camera 图像类，还有 BEV Fusion 融合类。我们也讲过，无论哪种方法做 BEV 感知算法，设计的核心都是围绕转换模块进行的，那也就是说如何把不同输入的数据统一的映射到 BEV 空间当中，无论是检测任务，分割任务还是轨迹预测任务均是基于已建立的这个 BEV 空间去进行的，所以转换模块是尤其重要的。
出于这个考虑，第二章中我们还是围绕转换模块展开，最后考虑到 Transformer 也是 BEV 感知算法中的一个非常重要的组成部分，我们也会额外给大家补充一下 Transformer 的相关内容。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/102d2ff0f5cca3769cc1d78e8c6b07af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a9ec4edbc171b308a23feaf43b87b96/" rel="bookmark">
			IDEA中java栏找不到到jdk8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Idea默认Strart services url
Idea中默认使用为https://start.spring.io/，国内网络如果不稳定创建工程会很慢修改为阿里云地址
https://start.aliyun.com/ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fee2d5297196aa7d2ef88461dcefc2a1/" rel="bookmark">
			【面试HOT200】二叉树——广度优先搜索篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列综述：
💞目的：本系列是个人整理为了秋招面试的，整理期间苛求每个知识点，平衡理解简易度与深入程度。
🥰来源：材料主要源于【CodeTopHot200】进行的，每个知识点的修正和深入主要参考各平台大佬的文章，其中也可能含有少量的个人实验自证，所有代码均优先参考最佳性能。
🤭结语：如果有帮到你的地方，就点个赞和关注一下呗，谢谢🎈🎄🌷！！！
🌈【C++】秋招&amp;实习面经汇总篇
文章目录 基础知识二叉树广度优先遍历*递归算法非递归算法 相关题目199. 二叉树的右视图104. 二叉树的最大深度111. 二叉树的最小深度求二叉树最左下的叶子 参考博客 😊点此到文末惊喜↩︎
基础知识 二叉树广度优先遍历* 递归算法 非重点// 递归参数，如果需要修改要进行引用传递 void traversal(TreeNode* cur, vector&lt;vector&lt;int&gt;&gt;&amp; result, int depth) { // 递归出口 if (cur == nullptr) return; // 递归体 if (result.size() == depth) // 扩容 result.push_back(vector&lt;int&gt;());// 原地构建数组 result[depth].push_back(cur-&gt;val);// 顺序压入对应深度的数组中 order(cur-&gt;left, result, depth + 1); order(cur-&gt;right, result, depth + 1); } vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) { // 初始化：一般为递归形参 vector&lt;vector&lt;int&gt;&gt; result; int depth = 0; // 递归调用 traversal(root, result, depth); // 返回结果 return result; } 非递归算法 重点vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) { vector&lt;vector&lt;int&gt;&gt; res;	// 结果容器 queue&lt;TreeNode*&gt; que;	// 队列 if (root !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fee2d5297196aa7d2ef88461dcefc2a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e6cbf5aaf5ccb006cba8bf6c18708ac/" rel="bookmark">
			如何二次封装一个Vue3组件库？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么要二次封装组件库 目前开源的Vue3组件库有很多，包括Element Plus、Ant Design Vue、Naive UI、Vuetify、Varlet等等。
在大部分场景中，我们直接使用现有组件库中的组件即可实现功能。如果遇到部分组件的特殊配置或者特殊逻辑，或者当前的组件库不满足需求，需要部分组件组合成为一个更大的组件，例如IP输入框、带固定样式的对话框等等，甚至我们有一些和组件库无关的自定义组件。如果这些组件在工程中有多处复用，我们一般都会将组件单独写到工程的Components中，方便各个页面调用。
假设这时候有多个独立的工程，这些工程都需要复用我们之前在Components中写的自定义组件。这时候，我们可以选择在每个工程都复制一份代码使用，但是这样做不方便维护。如果我们发现组件有一些BUG，我们需要在一个工程中修复，然后复制同步给其它工程。这样维护低效而且容易遗漏。而且如果其它工程的开发者修改了组件（也许有需求但是并未通知我们），那么我们同步复制代码之后，就会把其它开发者的代码覆盖掉。
这时候，更好的方式是将这些在不同的工程中复用的组件抽出来，封装为一个独立的组件库。这样我们的可复用组件代码在一个地方修改和维护。同时也有文档和版本控制等功能，方便其它工程集成。
甚至有时候可以做一个扩展组件库，扩展现有的组件库的能力，给大家提供更多的通用组件。
依赖说明 依赖种类 开发npm包与开发前端页面工程不同，对于依赖有着更精细的控制：
开发前端页面工程：安装到dependencies和devDependencies无区别。因为工程都要经过构建成dist成果物，本身是不需要依赖安装的。因此前端需要安装依赖的只有开发模式。开发npm包：开发模式，生产模式有区别，依赖还区分作为自身依赖还是宿主依赖。 注：上述描述是针对大部分工程，如果项目中配置了特殊模式，依赖安装方式也有区别。
这里简述一下package.json中我们会使用的依赖种类：
dependencies生产依赖 这类依赖在开发环境，生产环境都会被安装。在npm包被集成到宿主工程时，会作为npm包本身的依赖被安装。
npm add vue devDependencies开发依赖 只在开发环境被安装的依赖，生产环境不安装。在npm包被集成到宿主工程时，也不会被安装。
pnpm add -D vue peerDependencies对等依赖 我觉得也可以叫做“宿主依赖”。这类依赖在开发环境会被安装，但生产构建时不会打包进成果物中。在npm包被集成到宿主工程时，也不会被安装（npm部分版本会自动安装）。但是会提示要求宿主工程本身安装这个依赖。
pnpm add --save-peer vue 如何选择依赖种类 以vue为例 既然是要作Vue3的库，肯定需要安装vue这个依赖了。那么我们应该怎么选择依赖种类呢？
devDependencies 排除
生产模式下，我们的组件库也是需要vue作为依赖的。（或许不用也行，但是目前不选择那种方式）dependencies 可以但不建议
生产模式和开发模式下都会安装，可以保证我们的组件库一直都能引用到。peerDependencies 推荐
生产模式下会安装，开发模式下被安装到宿主工程中，与宿主工程共享同一个vue依赖。 如果选择dependencies，那么我们的组件库本身会安装一个vue依赖，宿主工程也会安装一个vue依赖，实际上安装了两个vue。这明显会浪费开发者的磁盘空间，而且降低了依赖安装的效率。(现在大部分包管理器都能处理这种情况，不会实际安装两个，但是这种设计显然不好)因此我们选择peerDependencies。
以@vueuse/core为例 那么，是不是宿主工程可能有的依赖，我们就一定要选择peerDependencies呢？并不是。比如@vueuse/core，这是一个基于vue的前端使用工具集合。我们在组件库中，仅需要使用其中的几个工具。例如useResizeObserver。这个依赖宿主工程可能会用，也可能用不到。
peerDependencies 排除
我们需要将其设定为peerDependencies，强制要求开发者必须安装么？当然不行。
为什么不行？因为这样会影响开发者使用。试着想开发者装了一个包，会提示开发者再手动安装几个依赖包。装完这些依赖包之后又会提示开发者装一堆依赖。虽然这些依赖可能是必要的，但是都手动让开发者装也太不方便了。dependencies 可以
生产模式和开发模式下都会安装，且在宿主工程中时，会作为依赖本身的包进行安装。devDependencies 可以
仅仅开发模式安装也可以？？？ 是的，但是需要加入构建流程。通过构建使依赖中的代码打入我们的成果物中，就不再需要生产依赖了。 以Vite为例 Vite是一个前端构建工具，大部分Vue3页面工程就是用它打包的。同样的我们的组件库也会使用Vite打包。构建工具仅仅在开发和构建时需要安装，构建之后作为npm包引入时就不需要了。因此Vite适合作为devDependencies依赖安装。
封装简单组件 我们先从最简单开始，实现一个不需要构建流程，也不需要引入组件库的简单组件。
初始化工程 首先创建工程：
# 初始化项目 pnpm init # 安装依赖 pnpm add --save-peer vue 创建必要的目录结构。我这里以一个简单的表示状态的圆圈组件功能为例。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e6cbf5aaf5ccb006cba8bf6c18708ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/162bd45dc222942e0b161ff1104176ab/" rel="bookmark">
			STM32Cubemx：利用定时器实现定时功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 细节处理——STM32 hal库编程开启定时器中断会立即进入中断的问题一.实现功能说明二.STM32Cubemx配置过程2.1配置时钟树2.2参数设计（自动重装载值、分频系数、计数方式等）2.2.1分频系数和计数周期2.2.2计数模式2.2.3是否启用预自动重装载 三.中断服务函数编写（重写回调函数）3.1HAL库的中断服务程序调用逻辑3.2如何定位到回调函数？ 四.开启定时器中断 细节处理——STM32 hal库编程开启定时器中断会立即进入中断的问题 通过HAL库实现定时器定时中断需要在开启中断前清除中断标志位，否则一开启定时器中断就会进入一次中断。要解决这个问题很简单，就是调用函数__HAL_TIM_CLEAR_IT(&amp;htim6, TIM_IT_UPDATE);完成中断标志位的清除。这个细节大家根据需要看是否要处理掉。
一.实现功能说明 为了实现LED每隔0.5s进行一次翻转，且不阻塞主程序。
二.STM32Cubemx配置过程 2.1配置时钟树 STM32所有非内核外设都有时钟驱动，所以在配置外设的时候都需要先配置时钟树。
我使用的是STM32F407ZGT6，时钟树配置如下图所示：
2.2参数设计（自动重装载值、分频系数、计数方式等） 配置好时钟树后我们就需要根据时钟总线频率(APB1=84Nhz)设计参数。
这里有个问题就是定时器TIM6挂载在哪个时钟总线上？对于具体外设挂载在哪个时钟总线上我们可以打开对应芯片的数据手册。例如我用的是STM32F407ZGT6打开数据手册我们可以看到一个具体的系统框图(截取一部分)。
通过这张图，我们可以看到TIM6和TIM7都是挂载到APB1上，再结合上面我们配置时钟树是APB1=84Mhz，所以我们可以知道定时器TIM6时钟输入频率为84Mhz。
在知道定时器输入频率后，我们就正式进入参数设计阶段。到这里我们先看一下Cube中有哪些参数需要我们设计：
可以看到一共有四个参数需要我们去配置：
Prescaler：预分频，参数范围0-65535
Counter Mode：计数模式，TIM6只有向上计数模式（UP）
Counter Period：计数周期，参数范围0-65535
auto-reload preload：是否启用预先自动重装载，建议选择Enable
2.2.1分频系数和计数周期 本次实利用定时器实现每隔一段时间去完成某一件事，这段时间为：
T o u t = ( ( a r r + 1 ) ∗ ( p s c + 1 ) ) / T c l k Tout=((arr+1)*(psc+1))/Tclk Tout=((arr+1)∗(psc+1))/Tclk
arr为计数周期（999）
psc为分频系数（41999）
Tclk为接入定时器的时钟总线（Tclk=APB1=84Mhz=84000000）
Tout表示每个多长时间触发一次定时中断（0.5s）
把上图中我设计的参数带入计算可以得到：
T o u t = ( 999 + 1 ) ∗ ( 41999 + 1 ) / 84000000 = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/162bd45dc222942e0b161ff1104176ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56376d371ca9d1d1a8ff69d073a597a0/" rel="bookmark">
			半导体封装之倒装封装 （Flip Chip）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		倒装封装 （Flipchip）是相对于引线键合(Wire Bonding)来说的，之所以叫做倒装，是因为flip chip是正面朝下放置。倒装芯片技术是通过芯片上的凸点直接将元器件朝下互连到基板、载体或者电路板上。引线键合的连接方式是将芯片的正面朝上，通过引线(通常是金线)将芯片与线路板连接。
倒装封装 （Flipchip）相对于传统的封装，是一种wafer 级的封装。不是先把晶圆切割成单个die，再进行封装，而是先针对晶圆进行封装，封装好后，再切割。称之为 Wafer Level CSP。
这种封装方式有一个特殊的工艺流程，就是bump。大家可以理解为长金球（锡球）。
要想长金球，首先要做的就是重新布局芯片pad的的位置，利用和芯片制造中相同的后段技术，将边缘部位的pad，安排到芯片中央来。这句话就是bump的核心目的。
大体思路就是将芯片的pad通过导线（红色）借接出来，然后在想要的位置上重新做一个pad，实际图形长这样子，中间的哪些深色部分就是导线。
为什么不在芯片的pad上直接长锡球呢？因为当芯片的引脚太多时，直接长金球的方式危险系数会大大提高，很容出现两个引脚短接的情况。这样重新分配pad布局的过程叫做RDL（re-distribution layer）。准确的说它是指连接新pad和旧pad的这一层，但是大家在使用的时候，就不再区分，直接把这个过程叫做RDL。
到这里之后，后面一步就是bump，也就是长金球（锡球）。长金球的过程就不再多说了，和芯片制造工艺中的曝光，刻蚀差不多。
直到长完球（bump）之后，整个wafer还没有被切割，所以这些都是批量操作，成本特别低。这些操作完成后再进行晶圆级测试。也正是因为bump过程是在wafer上制作的，所以大家都把它叫做WLCSP（wafer level CSP）。
测试完成之后再切割，把好的芯片拿出来。最后倒扣到基板上面。就这样，外部电压通过焊接点以及bump产生的球与芯片交流。
这种封装方式，最省面积，封装出来的芯片大小和原始大小相差不大。所以这种方式也是比较主流的封装方式，一般用在高端产品上。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca39eee0599c37f418996e7b683048be/" rel="bookmark">
			elasticsearch 内网下如何以离线的方式上传任意的huggingFace上的NLP模型（国内避坑指南）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		es自2020年的8.x版本以来，就提供了机器学习的能力。我们可以使用es官方提供的工具eland，将hugging face上的NLP模型，上传到es集群中。利用es的机器学习模块，来运维部署管理模型。配合es的管道处理，来更加便捷的处理数据。 但是在国内操作，根据官方文档或者根据官方博客操作，有无穷无尽的坑。看着官方的文档写的很清楚，实际上操作的时候，还是操作不下来。这里写一个闭坑指南。 在你上车体验ES的机器学习之前，看看我这篇文章，肯定是会有收获的。因为我已经花了时间，踩了坑，并解决了它。 上传模型存在的坑 第一个坑是，es的机器学习，是收费的功能，白金版才能使用。这里需要开启试用才能用（试用期限为一个月）。如果只是体验，一个月已经足够了。体验效果不错，就可以找老板花钱了。（不过网上也有很多绿色的方案，可以用，不推荐，有法律风险，特别是商用）开启白金试用，需要开启xpack安全认证，开启用户认证，在kibana上登录的时候，要使用elastic用户登录，否则无法开启试用，会告诉你无权限。网络环境问题。如果你能开启科学上网，肯定可以避免问题。但是即使有科学上网，也只是体验一下。并不是生产实践方案，生产环境通常都是在内网环境下，即使能上网，也肯定是在国内网络环境下。这会有各种各样的问题。所以要做我们就做生产环境版本，要做就做离线版本。举一个最简答的例子，国内的网络，很难访问huggingface，去拉取模型。 这里是我直接使用eland，上传模型的时候遇到的错误。
docker run -it -v /u01/isi/.cache/huggingface/hub/:/usr/local/bin/eland_import_hub_model --rm elastic/eland \ eland_import_hub_model \ --url http://elastic:123123@10.99.100.49:9200 \ --hub-model-id sentence-transformers/clip-ViT-B-32-multilingual-v1 \ --task-type text_embedding \ --start 报错为无法访问huggingface.co 国内域名污染导致的。如果可以挂代理，可以解决。如果没有代理，则看下边离线安装版本
2023-11-22 09:40:30,738 INFO : Establishing connection to Elasticsearch 2023-11-22 09:40:30,751 INFO : Connected to cluster named 'es' (version: 8.8.0) 2023-11-22 09:40:30,752 INFO : Loading HuggingFace transformer tokenizer and model 'sentence-transformers/clip-ViT-B-32-multilingual-v1' 'HTTPSConnectionPool(host='huggingface.co', port=443): Max retries exceeded with url: /sentence-transformers/clip-ViT-B-32-multilingual-v1/resolve/main/tokenizer_config.json (Caused by ConnectTimeoutError(&lt;urllib3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca39eee0599c37f418996e7b683048be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f797e036b66ef216b95051e9480b5cca/" rel="bookmark">
			.net 6.0定时任务Quzrtz.net的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 安装nuget包
环境 : .net 6.0 ,vs2022
二. IOCJobFactory
定义了一个名为 IOCJobFactory 的类，它实现了 IJobFactory 接口。这个类的主要作用是使用依赖注入来创建和管理 Quartz 作业实例
在这里插入public class IOCJobFactory : IJobFactory { private readonly IServiceProvider _serviceProvider; public IOCJobFactory(IServiceProvider serviceProvider) { _serviceProvider = serviceProvider; } //尝试从依赖注入容器中获取与作业类型匹配的服务。如果找到匹配的服务，那么该服务会被作为 IJob 返回 public IJob NewJob(TriggerFiredBundle bundle, IScheduler scheduler) { return _serviceProvider.GetService(bundle.JobDetail.JobType) as IJob; } public void ReturnJob(IJob job) { var disposable = job as IDisposable; disposable?.Dispose(); } } 代码片 三. QuartzFactory
这个QuartzFactory类的主要作用是创建一个Quartz调度器，并将一个作业和相应的触发器绑定到该调度器上。这样，当触发器满足其Cron表达式时，对应的作业就会被调度并执行。
public class QuartzFactory { //1、声明一个调度工厂 private ISchedulerFactory _schedulerFactory; private IScheduler _scheduler = default; private IJobFactory _IOCjobFactory; public QuartzFactory(ISchedulerFactory schedulerFactory, IJobFactory jobFactory) { _schedulerFactory = schedulerFactory; _IOCjobFactory = jobFactory; } public async Task&lt;string&gt; Start() { //2、通过调度工厂获得调度器 _scheduler = await _schedulerFactory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f797e036b66ef216b95051e9480b5cca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e586b8265289c72346931a800515f6f5/" rel="bookmark">
			vue使用echarts显示中国地图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面介绍一个方法如何用echarts画一个中国地图，如图
项目引入echarts以后，在页面创建canvas标签
&lt;div ref="chartone" &gt;&lt;/div&gt; 引入一个公共js文件（下面这段代码就是china.js文件）
(function (root, factory) { if (typeof define === 'function' &amp;&amp; define.amd) { // AMD. Register as an anonymous module. define(['exports', 'echarts'], factory); } else if (typeof exports === 'object' &amp;&amp; typeof exports.nodeName !== 'string') { // CommonJS factory(exports, require('echarts')); } else { // Browser globals factory({}, root.echarts); } }(this, function (exports, echarts) { var log = function (msg) { if (typeof console !== 'undefined') { console &amp;&amp; console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e586b8265289c72346931a800515f6f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/766dd3744fb8ed7bfad16a0bd6ef46a5/" rel="bookmark">
			vue3项目脚手架如何使用swiper， ‘vue-awesome-swiper‘报错解决（简单示例）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
使用方法
效果图
1.下载swiper
2. 写入需要的页面
3.在对应页面引入组件
4.推荐页完整代码
前言 Vue3和Vue2在使用swiper时是有差别的，Vue3引入swiper需要注意Vu3的版本和swiper的版本，如果不匹配通常会报错
如下：当引用版本过高的swiper时报错（版本不相符）
解决方案是：引用版本较低的swiper
使用方法 效果图 1.下载swiper 2. 写入需要的页面 &lt;div class="swiper"&gt; &lt;swiper :modules="modules" :navigation="false" :loop="true" :pagination="{ clickable: true }"&gt; &lt;!-- modules为导入的模块，绑定导入的模块导航模块和分页模块，loop实现轮播图循环模式 --&gt; &lt;swiper-slide&gt; &lt;img src="../assets/2.jpeg"&gt; &lt;/swiper-slide&gt; &lt;swiper-slide&gt; &lt;img src="../assets/3.jpeg"&gt; &lt;/swiper-slide&gt; &lt;swiper-slide&gt; &lt;img src="../assets/4k3.jpg"&gt; &lt;/swiper-slide&gt; &lt;/swiper&gt; &lt;/div&gt; 3.在对应页面引入组件 //引入组件 import { Swiper, SwiperSlide } from 'swiper/vue'; //引入模块 import { Pagination,Navigation } from 'swiper/modules'; //引入样式, import 'swiper/css/pagination'; import 'swiper/css/navigation'; import 'swiper/css'; export default { name: '1130127Recommend', components: { Swiper, SwiperSlide, }, data() { return { modules: [Navigation, Pagination] }; }, 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/766dd3744fb8ed7bfad16a0bd6ef46a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bfcffa2ab92483fca78d514f0ff6877/" rel="bookmark">
			【Element-ui】InputNumber 计数器与Select 选择器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、InputNumber 计数器1.1 基础用法：1.2 禁用状态1.3 步数1.4 严格步数1.5 精度1.6 尺寸1.7 按钮位置1.8 Events1.9 Methods 二、Select 选择器2.1 基础用法2.2 有禁用选项2.3 禁用状态2.4 可清空单选2.5 基础多选2.6 分组2.7 创建条目2.8 Select Events2.8 Select Slots2.9 Option Group Attributes2.10 Option Attributes2.11 Methods 总结 前言 在Web开发中，用户输入和选择是常见的交互行为。为了提供更好的用户体验，前端框架和组件库经常提供丰富的表单元素。本文将重点介绍Element-ui中的两个常用表单组件——InputNumber 计数器和 Select 选择器。这两个组件为用户输入和选择提供了强大而灵活的解决方案，使得开发者能够轻松构建交互性强的界面。
一、InputNumber 计数器 仅允许输入标准的数字值，可定义范围
1.1 基础用法： 要使用它，只需要在el-input-number元素中使用v-model绑定变量即可，变量的初始值即为默认值。
&lt;template&gt; &lt;el-input-number v-model="num" @change="handleChange" :min="1" :max="10" label="描述文字"&gt;&lt;/el-input-number&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { num: 1 }; }, methods: { handleChange(value) { console.log(value); } } }; &lt;/script&gt; 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6bfcffa2ab92483fca78d514f0ff6877/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7d54f84a4f6a31b65c03a936a123b8d/" rel="bookmark">
			51单片机循迹小车
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.材料
1.51单片机开发板
2.L298N电机
3.红外循迹模块
4.直流电机
5.电池（提供电源，选用的是三节18650锂电池）
6.杜邦线
7.两个主动轮，一个万向轮
8.小车底板（亚克力板）
二.实现效果
使小车在两侧黑线内沿着环形跑道自主行驶一圈，打开开关时小车前行，左侧检测到黑线时左轮前进，右侧检测到黑线时右轮前进，两侧都检测到黑线时小车停止。
三.组装接线
1.初步组装:将直流电机、 主动轮、万向轮、电池盒接在小车底板上。每个直流电机焊接两根线，后续接到L298N两端。
2.红外模块：四路红外循迹模块的VCC、GND用杜邦线接在单片机的+5V、GND端，IN1-IN4接在单片机对应引脚上。红外发射接收器接在小车前方下端，离地距离不能过远，便于检测到黑线，执行循迹功能。
3.单片机最小系统：装入芯片（选用的是STC89C52RC），执行程序代码。用杜邦线完成单片机上引脚和红外模块、L298N、电池的接线。注意连线和程序中接口的对应。
4.L298N：L298N前面蓝色的三个接口外接电源供电用，左端接电池电源正极12V输入，右端接单片机5V接口，GND连接电池电源负极和单片机的GND接口。L298N的左右两个蓝色插口输出，接左右电机，可先焊接电机的两根线，在程序中让小车前进，若车轮转向正确，则接线正确；若车轮反向转动，可通过两根接线实现小车前进。ENA、ENB、IN1、IN2、IN3、IN4定义接口后接到单片机相应引脚上。ENA和ENB通过定时器调节输出PWM波，实现小车转弯。单片机控制IN1-IN4，来控制小车轮子的正反转。
直流电机
状态
IN1（IN3）
IN2（IN4）
使能端
M
正转
1
0
1
反转
0
1
1
停止
0
0
1
5.组装接线成果图
四。工作原理
1.PWM调速
（1）PWM：脉冲宽度调制，PWM波形如下所示。
（2）占空比：指高电平在一个周期中所占比例。对于单片机小车直流电机的调速，可以通过定时器设置定时初值，在中断服务函数中对占空比进行调整，从而实现电机的转速控制。
2.红外循迹
模块正式连接后，传感器开始工作。传感器有两个检测灯，一个灯用于发射光，另一个灯用于检测反射光的强度来判断是否检测到黑线。如果检测到黑线，黑色对光线的反射较弱，红外光无法反射回来，则模块指示灯熄灭，输出高电平（1）。未检测到黑线时，传感器发射出的红外光大部分被反射回来，模块感应到传感器反射回来的红外光，指示灯亮，输出低电平（0）。
五.程序编写
1.开头头文件、位定义
#include &lt;reg51.h&gt; sbit IN1=P1^2; sbit IN2=P1^3; sbit IN3=P1^4; sbit IN4=P1^5; sbit ENA=P1^0;//左边两个电机使能 sbit ENB=P1^1;//右边两个电机使能 sbit lse1=P2^1;//左边红外传感器的数据口 sbit lse2=P2^2;//右边红外传感器的数据口 unsigned char mot1=0;//定义左轮 unsigned char mot2=0;//定义右轮 int t = 0; 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7d54f84a4f6a31b65c03a936a123b8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecdc7c2e09505a75947bdc873744895e/" rel="bookmark">
			Gmsh：三维有限网格生成器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网格在科学计算中的重要性 在科学计算中，网格（Grid）是一个离散化的空间描述，将计算领域划分为规则或不规则的小单元。它在科学计算中具有重要性，主要体现在以下方面：
空间离散化：科学计算问题通常涉及对连续空间的离散化，将其划分为有限个网格单元。这样做可以将复杂的数学问题转化为易于计算的离散问题，从而使得计算更加可行和高效。
数值模拟和求解：网格提供了在计算领域内进行数值模拟和求解的基础。通过在网格上建立数学模型和方程，可以将复杂的物理现象转化为离散的计算问题。例如，有限元法和有限差分法等数值方法常常使用网格来近似解析解。
边界条件处理：网格在科学计算中起到了处理边界条件的关键作用。通过将边界位置约束到网格上，可以方便地对边界条件进行定义和处理。这对于模拟物理领域中的流体力学、电磁场等问题尤为重要。
并行计算：在大规模科学计算中，网格的并行划分和处理对于提高计算效率和性能非常关键。通过将网格划分为多个子域并分配给多个计算节点，可以实现并行计算和分布式计算，大大提高计算速度和可扩展性。
网格自适应：在某些情况下，根据问题的复杂性和准确性要求，标准网格可能无法提供足够的解决方案。在这种情况下，网格自适应技术允许根据需要在计算区域中添加或删除网格单元。这种能力对于解决具有局部特征的问题非常重要。
综上所述，网格在科学计算中的重要性不可忽视。它为数值模拟和方程求解提供了基础，处理边界条件，支持并行计算，并能够根据问题的需求进行自适应调整。网格的选择和设计直接影响到科学计算的可靠性、准确性和效率。
Gmsh：三维有限网格生成器 gmsh 是一种开源的三维有限元网格生成器和后处理软件。它具有功能强大和灵活的特点，适用于各种科学计算和工程领域的模拟和分析任务。以下是一些关键特点和功能：
几何建模：gmsh 提供了一个直观的界面，用于创建、修改和操纵复杂的几何模型。用户可以通过手动建模、文件导入、基于CAD软件的集成或编程接口来定义模型。支持包括曲线、曲面、体积等多种几何元素。
网格生成：gmsh 能够生成各种类型的三维有限元网格。用户可以通过选择合适的网格算法、指定划分参数和优化网格质量等方式来控制网格划分。它支持三角形、四边形、四面体、六面体等多种元素类型，并提供自适应网格划分功能。
多物理场模拟：gmsh 支持多种物理场的模拟，包括流体力学、结构力学、电磁场等。用户可以定义边界条件、材料属性、加载条件等，并进行相应的模拟和分析。
后处理功能：gmsh 提供了丰富的后处理功能，用于可视化和分析模拟结果。它支持数据可视化、剖面图、动画等，使用户能够更好地理解和解释模拟结果。
可扩展性：gmsh 是一个开源项目，提供了灵活的接口和插件系统。用户可以使用 使用Python ，C，C++，fortran等语言进行自动化建模和网格生成，也可以通过插件来添加新的功能和扩展软件的能力。
总的来说，gmsh 提供了一个强大且易于使用的环境，用于创建、划分和后处理三维有限元网格。它适用于各种科学计算和工程应用，并且具有广泛的用户群体和活跃的社区支持。无论是学术研究还是工程实践，gmsh 都是一个重要的工具。
Gmsh图形界面的安装 这是gmsh的官网：http://gmsh.info
选择自己使用的操作系统即可安装，Windows为例，安装后会得到如下文件夹：
点击exe文件便能打开gmsh的图形窗口：
想要查看生成网格效果可以点击文件夹tutorials，里面有各个语言调用gmsh生成网格的实例，还有.geo文件（专门的gmsh几何定义文件，可以构建结几何和生成网格）以t4.geo为例：
// ----------------------------------------------------------------------------- // // Gmsh GEO tutorial 4 // // Built-in functions, holes in surfaces, annotations, entity colors // // ----------------------------------------------------------------------------- // As usual, we start by defining some variables: cm = 1e-02; e1 = 4.5 * cm; e2 = 6 * cm / 2; e3 = 5 * cm / 2; h1 = 5 * cm; h2 = 10 * cm; h3 = 5 * cm; h4 = 2 * cm; h5 = 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecdc7c2e09505a75947bdc873744895e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f59e84c8f7e032ccf4ad607f3b1d235a/" rel="bookmark">
			Python基础快速过一遍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、变量及基本概念1、变量2、变量类型3、变量格式化输出4、type()函数5、input()函数6、类型转换函数7、注释 二、Python运算/字符1、算数运算2、比较运算3、逻辑运算4、赋值运算符5、转义字符6、成员运算符 三、判断/循环语句1、if判断语句2、while循环语句3、for循环语句4、for和while循环区别5、break和continue 四、函数1、函数定义式及调用2、函数注释3、函数参数4、函数返回值5、函数嵌套6、局部变量和全局变量 五、列表1、列表定义及引用2、列表操作3、循环遍历 六、元组1、元组定义及引用2、元组操作3、元组列表之间切换 七、字典1、字典定义及引用2、字典操作3、循环遍历4、列表嵌套字典 八、字符串1、字符串判断类型2、字符串查找替换3、字符串大小写转换4、字符串文本对齐5、 字符串去除空白字符6、字符串拆分和连接7、字符串的切片 九、公共方法1、内置函数2、切片3、常用运算符 十、客户管理系统(综合案例)1、程序需求解释2、程序实现代码3、程序测试结果 十一、函数进阶1、函数多返回值2、缺省参数3、关键字传参4、多值传参5、元组和字典的拆包6、函数的递归7、函数作为参数传递8、lambda匿名函数 十二、文件操作1、打开文件2、读取文件3、写入文件4、追加文件5、文件综合案例 十三、异常处理1、异常的捕获2、try...else 和 finally结构3、异常的传递性 十四、模块1、导入模块2、自定义模块3、__main__变量4、__all\__变量 十五、包1、包概念及创建包2、导入包3、安装第三方包 一、变量及基本概念 1、变量 # 1、定义变量 user = "root" password = "123.com" # 2、打印变量 print(user) print(password) 注意：print函数()括号内 存在双引号或单引号那就是字符串，并非变量。
案例： 超市买苹果
price = 8.5 weight = 7.5 money = price * weight print("共%d元" %money) 基于上面举例修改 超市搞活动 只要买苹果就减5元
price = 8.5 weight = 7.5 money = price * weight - 5 print("共%d元" %money) 2、变量类型 变量类型解释srt字符串int整数long长整数(仅在python2中存在)bool布尔(真假)float浮点数tuple元组list列表 3、变量格式化输出 格式化字符含义%s字符串%d有符号十进制整数，%06d表示输出整数为6位，不足6为则使用0代替%f浮点数，%.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f59e84c8f7e032ccf4ad607f3b1d235a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bc90b2da41d87169dcb83af0fa2a8c6/" rel="bookmark">
			深度学习关于基础学习matlab
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		迁移学习函数摘要
创建网络
函数 说明
deepNetworkDesigner 启动深度网络设计器
googlenet 加载预训练网络“GoogLeNet”
支持的网络 查看可用的预训练网络列表
fullyConnectedLayer 创建新的全连接网络层
classificationLayer 为分类网络创建新输出层
获取训练图像
函数 说明
imageDatastore 创建引用图像文件的数据存储
augmentedImageDatastore 预处理图像文件集合
splitEachLabel 将数据存储划分为多个数据存储
设置训练算法选项
函数 说明
trainingOptions 创建包含训练算法选项的变量
执行训练
函数 说明
trainNetwork 执行训练
使用经过训练的网络执行分类
函数 说明
classify 获取经过训练的网络对输入图像的分类
评估经过训练的网络
函数 说明
nnz 统计数组中的非零元素
confusionchart 计算混淆矩阵
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6684980b6f898a319e3b15efb619a38/" rel="bookmark">
			pyinstaller -F ... : 使用pyinstaller模块将py程序文件打包exe文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 引言
一、安装pyinstaller模块
二、打包.py文件
三、拓展内容
引言 使用此方法可将python文件转化为exe文件发送给他人，即使他人没有python环境也能运行，不仅适用于一般的python程序，对于实现爬虫、画图等功能的python文件同样适用。
一、安装pyinstaller模块 1、打开cmd命令窗口;
2、输入命令：pip install pyinstaller；
3、等待安装成功。
二、打包.py文件 1、打开cmd命令窗口；
2、进入到所要打包的python程序目录下；
【提示】命令窗口中输入“cd 目录名”后按回车即可实现路径前进；输入“cd..”后按回车即可后退一层路径；输入计算机盘名加英文冒号后回车即可切换根目录，如“D:”后回车。
3、(假设目标文件为"画笑脸.py")输入命令：pyinstaller -F 画笑脸.py后按回车即可；
4、运行成功后会出现以下几个文件，打包后的exe文件在dist文件夹中，到此全部完成。
【提示】：可将打包完成后的exe文件发给他人，即使对方没有python环境也能运行。
三、拓展内容 1、绘制滑稽表情打印效果（代码在效果下方）：
2、绘制滑稽表情部分（完整代码见文末链接）代码：
from turtle import * speed(0) # 最快的画笔速度 # 画圆脸 setup(600, 600, 0, 0) penup() fd(-200) pendown() color('yellow', 'yellow') begin_fill() seth(-90) circle(200) end_fill() # 画嘴巴 penup() seth(0) fd(10) pendown() pensize(3) # 调整画笔大小 color('red') seth(-90) circle(190, 180) # 画眼睛 penup() fd(100) seth(180) fd(573) for i in range(2): # 给画两只眼睛制造相同代码，才可以使用for循环，绘制两只眼睛 penup() seth(0) fd(200) pendown() pensize(2) seth(20) color('black', 'white') begin_fill() circle(-230, 40) circle(-10, 180) circle(210, 40) circle(-10, 180) end_fill() color('black', 'black') begin_fill() circle(-10) end_fill() 3、完整代码链接：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6684980b6f898a319e3b15efb619a38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51f3d93be7b3911d187307df247adcc3/" rel="bookmark">
			centos7 部署nacos
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.安装JDK
2.安装mysql数据库：
3. 安装nacos:
1.解压nacos压缩文件：
2.修改配置文件：
3.配置nacos集群：
4.启动nacos
5.访问nacos：
参考文章：
1.安装JDK jdk压缩包解压（自己去下载）：
tar zxvf jdk1.8.0_181.tar
配置环境变量：
windows下配置环境变量：Windows 10 Java环境变量配置 - Tyhoo_Wu - 博客园 (cnblogs.com)
修改/etc/profile文件，在文件最后加上：
export JAVA_HOME=/usr/local/jdk1.8.0_181
export PATH=$JAVA_HOME/bin:$PATH
export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
使配置生效：
source /etc/profile
查看java版本：
[root@ecs-dev-0003 ~]# java -version
java version "1.8.0_181"
Java(TM) SE Runtime Environment (build 1.8.0_181-b13)
Java HotSpot(TM) 64-Bit Server VM (build 25.181-b13, mixed mode)
[root@ecs-dev-0003 ~]# javac -version
javac 1.8.0_181
[root@ecs-dev-0003 ~]# 2.安装mysql数据库： 本文使用yum安装
首先添加mysql 的yum repo信息：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51f3d93be7b3911d187307df247adcc3/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/38/">«</a>
	<span class="pagination__item pagination__item--current">39/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/40/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>