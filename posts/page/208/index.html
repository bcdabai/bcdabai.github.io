<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1204afbe1867cc38d741cfcb527fa097/" rel="bookmark">
			windows下namp的基本操作命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows下namp的使用（需要先下载nmap，才可以在cmd中直接使用） 探测网段中存活的主机 首先查看本机网段
使用namp对这一网段进行扫描 使用命令：nmap -sP 192.168.1.0/24
扫描到3个存活主机，其中包含本机
探测存活的主机所开放的端口(可指定范围) 使用命令：nmap -p 0-5555 192.168.1.100
代码中 nmap -p 0-5555 192.168.1.100 0-5555指的是探测端口的范围
这是扫描另一个主机的信息
探测主机版本 使用命令：nmap -O 192.168.1.101
这篇文章只是列举了简单的nmap命令，仅供参考。
nmap扫描器的原理： 主机发现原理 主机发现发现的原理与Ping命令类似，发送探测包到目标主机，如果收到回复，那么说明目标主机是开启的。Nmap支持十多种不同的主机探测方式，比如发送ICMP ECHO/TIMESTAMP/NETMASK报文、发送TCPSYN/ACK包、发送SCTP INIT/COOKIE-ECHO包，用户可以在不同的条件下灵活选用不同的方式来探测目标机。
主机发现基本原理：（以ICMP echo方式为例）
默认情况下，Nmap会发送四种不同类型的数据包来探测目标主机是否在线。
ICMP echo requesta TCP SYN packet to port 443a TCP ACK packet to port 80an ICMP timestamp request 依次发送四个报文探测目标机是否开启。只要收到其中一个包的回复，那就证明目标机开启。使用四种不同类型的数据包可以避免因防火墙或丢包造成的判断错误。
端口扫描原理 1.TCP SYN scanning
这是Nmap默认的扫描方式，通常被称作半开放扫描（Half-open scanning）。该方式发送SYN到目标端口，如果收到SYN/ACK回复，那么判断端口是开放的；如果收到RST包，说明该端口是关闭的。如果没有收到回复，那么判断该端口被屏蔽（Filtered）。因为该方式仅发送SYN包对目标主机的特定端口，但不建立的完整的TCP连接，所以相对比较隐蔽，而且效率比较高，适用范围广。
2.TCP connect scanning
TCP connect方式使用系统网络API connect向目标主机的端口发起连接，如果无法连接，说明该端口关闭。该方式扫描速度比较慢，而且由于建立完整的TCP连接会在目标机上留下记录信息，不够隐蔽。所以，TCP connect是TCP SYN无法使用才考虑选择的方式。
3.TCP ACK scanning
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1204afbe1867cc38d741cfcb527fa097/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb23054dfdb7d647adb72bd6469b70be/" rel="bookmark">
			PLSQL spool命令: 显示sql文件执行结果到日志的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 SQL&gt; spool F:\AIT\LOG\05-13\DDL.log --指定输出文件 SQL&gt; @F:\AIT\LOG\05-13\DDL.sql --执行SQL文件 SQL&gt; spool off --关闭spool同时输出到命令1 的文件之中 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a060c0e03a2a8f1941030b77bc79da1/" rel="bookmark">
			linux shell 等待进程结束,sh如何等待上一句执行完，
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		怎样等待一个SHELL调用程序执行完再继续
先得2113到.exe的PID号。
循环，等进程终5261止跳出。
例如要调用计算器(CALC.EXE)并等到它运行完成后再4102执行下一1653语句，可以使用以下代码：
Dim RetVal
MsgBox ″开始运行″
RetVal = Shell(″C:\WINDOWS\CALC.EXE″, 1)
While IsRunning(RetVal)
DoEvents
Wend
MsgBox ″结束运行″
linux脚本中，如何等待后台进程(之前用&amp;放到后台)结束再执行后面的命令？
用wait
比如下面的例子， cmd1 放入后台运行， 而cmd2 要等 cmd1结束后才会执行。
#!/bin/bash
cmd1 &amp;
wait
cmd2
linux中怎样让shell脚本等待其他脚本文件执行完？？
在shell里写一个条件判断语句，去查询上一条命令执行的结果，如果执行成功则执行下面的语句。
如是上面的命令是一个简单的命令，就用sleep来控制。这都是常用方法
linux 的 shell脚本编程中，如何确保一条指令指令执行成功了之后再进行下一条指令
使用echo$?接收上条命令的标准输2113出，如果5261返回的是0就代表上条命4102令是成功的，如果是错误输出或者1653没有输出，那个返回的都不是0。
例：判断httpd是否启动pidofhttpd&amp;&gt;/dev/null
if[[$?!=0]]
then
/etc/init.d/httpdstart
else
echo“httpd服务启动成功”
fi
刚才没看下面
make &amp;&amp; make install 前面那条命令执行成功后才会执行后面那条命令。
谁知怎样让批处理在执行完上一个命令后，等待五秒钟再执行下一个命令？
共有两中常见的2113办法~
常用的办法5261:(不精确)
@4102echo off
命令1.......
ping -n 5 127.1&gt;nul
命令2.......
精确的1653办法:(精确)
@echo off
命令1.......
echo wscript.sleep 5000&gt;%tmp%\delay.vbs&amp;&amp;%tmp%\delay.vbs&amp;&amp;del /q %tmp%\delay.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a060c0e03a2a8f1941030b77bc79da1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5850ebf6b04d7c1b098947b07fe19ca7/" rel="bookmark">
			用turtle画皮卡丘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何绘制皮卡丘 画左偏曲线函数 setheading属性的作用是什么？
def radian_left(ang,dis,step,n): for i in range(n): dis+=step #dis增大step t.lt(ang) #向左转ang度 t.fd(dis) #向前走dis的步长 画右偏曲线函数 def radian_right(ang,dis,step,n): for i in range(n): dis+=step t.rt(ang) #向左转ang度 t.fd(dis) #向前走dis的步长 画耳朵 def InitEars(): t.color("black", "yellow") # 左耳朵曲线 t.pu() # 提笔 t.goto(-50, 100) # 笔头初始位置 t.pd() # 下笔 t.setheading(110) # 画笔角度 t.begin_fill() radian_left(1.2, 0.4, 0.1, 40) t.setheading(270) # 画笔角度 radian_left(1.2, 0.4, 0.1, 40) t.setheading(44) # 画笔角度 t.forward(32) t.end_fill() # 右耳朵曲线 t.pu() # 提笔 t.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5850ebf6b04d7c1b098947b07fe19ca7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9efcc5c4924e64f8145d1e6f32f9b37d/" rel="bookmark">
			几种仪表放大器电路总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般模拟信号在进入A/D采样前，需要先进行信号调理，模拟信号放大部分需要着重设计。放大电路采用仪表放大器，其能有效抵抗共模干扰且具有很高的输入电阻，有效提高信噪比。
以下总结常用的仪表模拟放大电路设计。
1、单运放仪表放大器
2、双运放仪表放大器
3、三运放仪表放大器
4、改进三运放仪表放大器
各类放大器的优劣，欢迎评论留言~~。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/992a14cfefc08b55f8b528e80f58ff0a/" rel="bookmark">
			GIT删除分支命令以及GIT最常用命令总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git 删除分支
1.查看当前本地分支
git branch
2.删除本地分支 -d 是-delete缩写
git branch -d &lt;your branch name&gt;
3.暴力删除 不会检查当前要删除的分支是否存在未处理的状态
git branch -D &lt;your branch name&gt;
或者
git branch -delete --force &lt;your branch name&gt;
1.查看本地分支 git branch
2.查看远程分支 git branch -b
3.查看全部分支 git branch -a
4.删除本地分支 git branch -d &lt;branchname&gt;
5.暴力删除本地分支 git branch -D &lt;branchname&gt;
5.批量删除除了master的本地分支 git branch | grep -v "master" | xargs git branch -D
6.清理本地无效分支 (远程已经删除本地没有删除的分支) git fetch -p
7.创建分支 git branch &lt;branchname&gt; (创建但不切换）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/992a14cfefc08b55f8b528e80f58ff0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c0a56cdb601d1e12d7daf4b50f5bb87/" rel="bookmark">
			linux如何查看数据库账号密码,linux下mysql如何查询用户的密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux下mysql如何查询用户的密码
查看用户
查看用户并没有直接的SQL语句，而是进入 mysql数据库的user表(这个mysql库和user表都是一开始就有的)，直接用 select * from user;来查看有什么用户
use mysql;
select * from user;
用户密码是加密状态，是看不了密码。
要是忘记mysql密码可以重置密码,重置密码的方法：方法一：
暂停mysql服务
[root@localhost ~]# /etc/init.d/mysqld stop
Shutting down MySQL. [确定]
跳过grant表授权，进入安全模式，并在后台运行
[root@localhost ~]# mysqld_safe --skip-grant-tables &amp;
[1] 5261
[root@localhost ~]# 180729 17:38:21 mysqld_safe Logging to '/usr/local/mysql/data/localhost.localdomain.err'.
180729 17:38:21 mysqld_safe Starting mysqld daemon with databases from /usr/local/mysql/data
[root@localhost ~]# jobs
[1]+ Running mysqld_safe --skip-grant-tables &amp;
进入安全模式修改密码
[root@localhost ~]# mysql
Welcome to the MySQL monitor. Commands end with ; or \g.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c0a56cdb601d1e12d7daf4b50f5bb87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19500c7c3b4987cd915b28c9c958b033/" rel="bookmark">
			基于 Cookie/Session 的认证方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于 Cookie/Session 的认证方案 Cookie Cookie 的工作原理
由于 HTTP 是一种无状态的协议，服务器单从网络连接上无从知道客户身份。怎么办呢？就给客户端们颁发一个通行证吧，每人一个，无论谁访问都必须携带自己通行证。这样服务器就能从通行证上确认客户身份了。这就是。cookie 指的就是在浏览器里面存储的一种数据，仅仅是浏览器实现的一种数据存储功能。cookie 的保存时间，可以自己在程序中设置。如果没有设置保存时间，应该是一关闭浏览器，cookie 就自动消失。
Cookie 实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个 Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该 Cookie 一同提交给服务器。服务器检查该 Cookie，以此来辨认用户状态。服务器还可以根据需要修改 Cookie 的内容。
注意：Cookie 功能需要浏览器的支持。如果浏览器不支持 Cookie（如大部分手机中的浏览器）或者把 Cookie 禁用了，Cookie 功能就会失效。不同的浏览器采用不同的方式保存 Cookie。IE 浏览器会以文本文件形式保存，一个文本文件保存一个 Cookie。
Cookie的不可跨域名性
Cookie 具有不可跨域名性。根据 Cookie 规范，浏览器访问 Google 只会携带 Google 的 Cookie，而不会携带 Baidu 的 Cookie。浏览器判断一个网站是否能操作另一个网站 Cookie 的依据是域名。
Session Session 是另一种记录客户状态的机制，不同的是 Cookie 保存在客户端浏览器中，而 Session 保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是 Session。客户端浏览器再次访问时只需要从该 Session 中查找该客户的状态就可以了。
如果说 Cookie 机制是通过检查客户身上的“通行证”来确定客户身份的话，那么 Session 机制就是通过检查服务器上的“客户明细表”来确认客户身份。
session 也是类似的道理，服务器要知道当前发请求给自己的是谁。为了做这种区分，服务器就要给每个客户端分配不同的“身份标识”，然后客户端每次向服务器发请求的时候，都带上这个“身份标识”，服务器就知道这个请求来自于谁了。对于浏览器客户端，大家都默认采用 cookie 的方式，保存这个“身份标识”。
服务器使用 session 把用户的信息临时保存在了服务器上，用户离开网站后 session 会被销毁。这种用户信息存储方式相对 cookie 来说更安全。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19500c7c3b4987cd915b28c9c958b033/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b7561a98d0a5355c1acdd07a1a24443/" rel="bookmark">
			安装启动zabbix
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 离线文件准备.
2.1 操作流程,从外网下载安装包和依赖包,然后拷贝到内网服务器进行离线安装.官网的教程是在线安装,
教程地址:https://www.zabbix.com/cn/download?zabbix=5.0&amp;os_distribution=centos&amp;os_version=7&amp;db=mysql&amp;ws=apache
2.2 先配置zabbix的yum源,下载https://repo.zabbix.com/zabbix/5.0/rhel/7/x86_64/zabbix-release-5.0-1.el7.noarch.rpm到/root/softFile/下,
使用命令:rpm -ivh /root/softFile/zabbix-release-5.0-1.el7.noarch.rpm 进行安装,
此文件安装之后会在/etc/yum.repos.d/目录下生成zabbix.repo文件,当在线下载zabbix依赖包时,此repo文件会做出指引.
编辑这个zabbix.repo文件,将zabbix-frontend enabled改为1
vim /etc/yum.repos.d/zabbix.repo
[zabbix-frontend]
...
enabled=1
...
2. 刷新yum源.
在设置yum源之后,需要清理缓存,重新启用.yum 清理缓存,使用如下三条命令:
yum clean all
yum makecache
3. 明确要安装的服务有下面四个,
zabbix-server-mysql,和mysql挂钩的zabbix服务.
zabbix-agent,zabbix客户端,将主动向服务器端发送数据.
zabbix-web-mysql-scl,zabbix服务端管理页面,与mysql挂钩,前端使用php编写,所以需要php环境.
zabbix-apache-conf-scl,zabbix服务端管理页面
4. 安装软件集合存储库(SCL)
在下载zabbix-web-mysql-scl及其依赖时,会提示缺rh-php72-php*文件,
这些文件在软件集合存储库(SCL)中,所以需要先安装scl,
输入:yum install centos-release-scl-rh 说明:配置yum源,生成CentOS-SCLo-scl-rh.repo
5. 安装php环境.
在下载zabbix-web-mysql-scl及其依赖时,会提示缺rh-php72-php*文件,
这是由于管理页面的前端使用php编写,所以需要安装php环境,
zabbix我们准备装5.0版本,依赖的php版本是7.2,有的centos没装或已经装了php5.6,此时用以下命令安装或升级php到7.2
rpm -Uvh https://mirror.webtatic.com/yum/el7/epel-release.rpm 说明:配置yum源,生成epel.repo epel-testing.repo
rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm 说明,配置yum源,生成webtatic-archive.repo webtatic-testing.repo webtatic.repo 6. 下载zabbix安装包及其所有依赖.
yum install --downloadonly --downloaddir=/root/softFile/zabbix5.0_download zabbix-server-mysql
yum install --downloadonly --downloaddir=/root/softFile/zabbix5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b7561a98d0a5355c1acdd07a1a24443/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68f588046ba03f1660900d1144cef988/" rel="bookmark">
			联合索引
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		索引相关的基础知识可以移步至：数据库索引漫谈https://mp.weixin.qq.com/s/Xy4AmYN5eys2vbp0AGCANw
这篇文章主要针对索引进阶内容。
联合索引
联合索引是指对表上的多个列进行索引，联合索引也是一棵B+树，这里的索引键值数量大于等于2；
创建语句：
create TABLE com_table( id int not null, name VARCHAR(20) not null, age int not null, constraint comb_key PRIMARY KEY(id,name,age) ); 插入三条数据：
insert into com_table values(1,'lili',10); insert into com_table values(2,'xiaowang',20); insert into com_table values(3,'liming',30); 插入数据后索引是这个样子的：
讲联合索引，一定要说到最左匹配；
什么是最左匹配：
在MySQL建立联合索引时会遵守最左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。
我们针对上面这个表以及联合索引进行一些实践：
1、索引生效
select * from com_table where age = 30; 这里是全表扫描，没有用到索引，同步只使用age也不会使用到索引；
select * from com_table where id= 3 and age = 30; [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-l4lPGfHp-1619651583043)(D:\学习总结\数据库\联合索引\4.png)]
命中了索引，说明符合最左前缀规则。
2、使用and 联合查询
select * from com_table where age = 30 and id = 3; 在执行sql的时候，优化器会帮我们调整where后age,id,name的顺序和索引一致，让我们用上索引，所以and情况下，只要有索引顺序第一个字段存在，就可以命中索引。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68f588046ba03f1660900d1144cef988/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fc508a6e28a650e792f2fea97616b7e/" rel="bookmark">
			linux脚本重启进程,linux下通过脚本实现自动重启程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		假定需要实现重启的程序名为 test ，我们这里通过判断进程数目来判断程序是否正常。
ps -ef | grep "$1" | grep -v "grep" | wc –l 是获取 $1 (本例中为 test )的进程数，脚本根据进程数来决定下一步的操作。通过一个死循环，每隔 1 秒检查一次系统中的指定程序的进程数。
grep -v "grep":作用：在结果中搜索除 grep之外的部分
-v, --invert-match
Invert the sense of matching, to select non-matching lines. (-v is specified by POSIX.)
代码如下：
脚本check
#!/bin/sh
#------------------------------------------------------------------------------
# 函数: CheckProcess
# 功能: 检查一个进程是否存在
# 参数: $1 --- 要检查的进程名称
# 返回: 如果存在返回0, 否则返回1.
#------------------------------------------------------------------------------
CheckProcess(){
# 检查输入的参数是否有效
if [ "$1" = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fc508a6e28a650e792f2fea97616b7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2aa0ba5f428728fd7703363d80f59c7c/" rel="bookmark">
			linux web目录写入权限命令,linux下web目录权限设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、nginx和php-fpm运行用户为www
2、我们假设web目录所属着为ftpuser
3、将web目录的用户和用户组设置为ftpuser和www，如下命令：chown -R ftpuser:www /usr/local/nginx/html
4、设置网站目录权限为750，750是ftpuser用户对目录拥有读写执行的权限，这样ftpuser用户可以在任何目录下创建文件，用户组有有读执行权限，这样才能进入目录，其它用户没有任何权限。
# find -type d -exec chmod 750 {} \;
5、设置网站文件权限为640，640指只有ftpuser用户对网站文件有更改的权限，web服务器只有读取文件的权限，无法更改文件，其它用户无任何权限。
# find -not -type d -exec chmod 640 {} \;
6、针对个别目录设置可写权限。比如网站的一些缓存目录就需要给web服务有写入权限。例如cache目录就必须要写入权限。
# find -name 'cache' -type d -exec chmod 770 {} \;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/919e937fa8e7d940eaa4e18757e0ee80/" rel="bookmark">
			win10安装jdk8点击下一步没反应，点击下一步闪退，win10安装jdk8失败8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		买了新电脑，开始配置java环境。装了jdk12很快就搞好了，但是eclipse打不开。百度是因为eclipse和jdk高版本不兼容。然后建议安装jdk8.
然后故事开始了。
现在Oracle官网只有exe安装包。然后jdk8死活安装不上去，打开安装包点击下一步就没反应，然后退出安装程序。蹩了一天多，一直找方法。要么说下载zip包的，要么说安装高版本。尼玛气死了。我去找售后问，售后的技术人员也不知道怎么弄，不行！！！
最后百度了一下“win10 安装jdk8 点击下一步闪退” 你猜怎么着？
只看到博主说了一句话：“安装时切换到默认输入法。”
根据博主的描述操作了一下，我只想说“卧槽，无情！！！！！！”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45509b512cfda487c66717a5d9227a72/" rel="bookmark">
			基于QSPI 的 Multiboot介绍-远程更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、PL端设计1、FLASH控制器2、约束文件 二、驱动程序1.中断方式2.轮询方式 总结续 第二分区几种回滚情况所需配置写入文件完整 存在一些错误数据写入文件不完整 模拟烧录过程中掉电情况 前言 目前，基于FPGA的很多设备需要和上位机进行通信，大多采用的是PCIE接口，类似的，我们对于PCIE的使用在赛灵思平台中采用的是官方的XDMA，该IP提供了标准的AXI4数据接口以及用户侧扩展的AXI-LITE接口，对于用户端的控制采用AXI-LITE接口进行控制就会显得十分方便。本文介绍远程更新也是基于此接口。
一、PL端设计 1、FLASH控制器 远程更新的关键就是需要在PL端对FLASH进行控制，这里也是采用的官方IP QSPI控制器。IP的配置可根据自己的实际硬件自身设计，可参考赛灵思官方给出例程。管脚信息都不需要额外绑定，只需使用STARTUPE3原语切换flash操作时钟即可。具体可参考下面的链接。
参考链接：https://www.xilinx.com/support/documentation/ip_documentation/axi_quad_spi/v3_2/pg153-axi-quad-spi.pdf
https://www.xilinx.com/support/documentation/user_guides/ug570-ultrascale-configuration.pdf
2、约束文件 FPGA从flash启动配置可通过VIVADO界面设置，也可直接修改约束文件，本工程及采用约束文件的方式，具体见下代码：
set_property BITSTREAM.CONFIG.SPI_BUSWIDTH 4 [current_design] #a negative edge clocking mode (BITSTREAM.CONFIG.SPI_FALL_EDGE) is available to make better use of the entire clock period and allow higher configuration speed. set_property BITSTREAM.CONFIG.SPI_FALL_EDGE YES [current_design] # The CCLK frequency is adjusted by the Vivado Configuration Rate bitstream setting (BITSTREAM.CONFIG.CONFIGRATE) if the source is the internal oscillator. set_property BITSTREAM.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45509b512cfda487c66717a5d9227a72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f6765add0a2a317bf05426b280ecbb5/" rel="bookmark">
			nginx部署前端Vue项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录一下自己用nginx部署前端Vue的过程
打包 npm run build 出现一些提示
Tip: built files are meant to be served over an HTTP server. Opening index.html over file:// won't work. 这个我没遇到什么问题，不是报错就行。
但是打完包之后 直接点开生成的index.html页面 却发现是空白页，然后查阅发现是config文件中的index.js问题
将assetsPublicPath改成 './'再次打包，访问index.html就成功显示页面了。
nginx部署前端vue的方法 部署单个项目
直接将打包好的dist文件中的static和index.html放入nginx的html文件中，可以将之前的文件删掉，运行nginx即可，访问你修改的nginx端口，就可以成功显示前端了修改nginx.conf配置
root对应打包生成的dist文件路径即可，直接运行nginx,访问localhost:8008即可展示前端页面 部署多个项目
直接访问localhost:8008/dataApi即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/716c23c1f4f99cd1d1a769b968b0f527/" rel="bookmark">
			unity 传送门的实现原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		所谓传送门就是从一个地方传送到另一个地方。在游戏中，实现传送门会让人觉得非常神奇。
在unity 我们使用一个面片在当做传送门，要把远处一个场景的画面投到面片上。 可以使用摄像机的TargerTexture 属性。
1.在资源文件夹创建 RenderTexture, 然后拖拽到相机的 TargerTexture属性。 再将 RenderTexture贴到面片上。 即可在面片上看到该摄像机视角的画面。
这种方式也可以用来做小地图功能。
2.到这里还不够，因为光看到画面还不行。 假设你站在门外，朝门里看，自身发生位移的时候，看到的门里的画面范围也会跟着变，这才是真实的效果。
我们把放在远处的摄像机作为目标端摄像机， 那么当前玩家的摄像机应该正视这个面片。 需要 远端的摄像机能够跟玩家的摄像机有相同的位移以及旋转。这样面片上的画面的视角才能跟玩家一致。 这里 需要用到一个 方法。
（1）
public Vector3 MultiplyPoint(Vector3 point);
Description Transforms a position by this matrix (generic).
可以将目标点进行坐标系转换。
将玩家在世界坐标的坐标点，转化为以传送门为坐标系的坐标。 然后将远端摄像机挂到一个空物体下，该空物体模拟远端传送门出口的点。 将上述得到的坐标点 赋值给远端摄像机。即可同步两个摄像机。
为了让面片的视角刚好符合玩家的视角，还需要将远端相机的近截面改到 相对与玩家视角的门的位置。
实现代码如下
private void Update() { CurrentPos = player.transform.position; var mt = Render.worldToLocalMatrix; PortalCamera.transform.localPosition = mt.MultiplyPoint(CurrentPos); PortalCamera.transform.LookAt(PortalPoint); PortalCamera.nearClipPlane = -PortalCamera.transform.localPosition.z; const float renderHeight = 1.5f; PortalCamera.fieldOfView = 2 * Mathf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/716c23c1f4f99cd1d1a769b968b0f527/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6074d90c0e9f698acd834cb75531fefe/" rel="bookmark">
			整理了以BAT三巨头为例的薪资职别资料，写给想参加春招或想跳槽的学弟学妹们
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一年一度的春招正在各大校园中如火如荼的开展着，其中互联网大厂的竞争最大。丰富的资源、与技术大牛们亲密接触等等一系列的好处使大批的应届生趋之若鹜。
同时，傲人的薪资也是如此吸引应届生的关键原因之一，以BAT为代表的互联网公司，其薪资及职级规则已经成为了整个行业的标杆。
小编以BAT三巨头为例，整理了其薪资及职别的资料，希望能够帮助即将参加春招或是准备跳槽的小伙伴在求职时有更清楚的认知。
阿里篇 职位级别 1）为啥要清楚知道职业级别
想知道阿里内部级别和薪资待遇的小伙伴大多正在面临offer的选择，举个例子，就如已经工作了7年的小M，刚刚通过阿里面试，但是级别只有P6+，连P7都没，不禁感到有点郁闷，有一种自己混的很low的感觉。同时他也很好奇，阿里系的P6和P7的范围到底是多少？
这样的纠结实在是太常见了，都是工作了好几年的程序员，好不容易想跳个槽，职级竟然只比刚毕业的大学生高出一丢丢，到底是自己技术不够还是被忽悠了？
所谓知己知彼百战不殆，跳槽讲究谋定而后动，在摸清对方的级别和待遇后才能跳得更高、更远。
2）级别定义
阿里巴巴集团采用双序列职业发展体系，技术线就是常说的 P 序列，对应到管理线的 M 序列，P6 相当于 M1，P7 相当于 M2，以此类推。
技术线的P系列一共分为14级，目前校招几乎不会涉及P1-P3，最低从P4开始 ，根据资料显示，目前校招的大部分情况都是P5、P6。
而阿里目前需求量最大的是P6-P8，也是目前阿里最多员工所在的级别层次。一般能够被各大公司高薪挖掘的程序员起码要达到P8的层次。而P10基本上就是大神级别的存在了，俗称：业内大牛。
下面这张图是阿里对员工职业级别划分要求，大家可以对号入座一下，看看自己可以成为P几。
薪资水准
阿里员工薪资一般是16薪，年终奖为0-6个月的工资，大多数员工都可以拿到3个月及以上。股票需要工作满2年才能拿，第一年拿50%，4年可以全部拿完。但基本上只有P7以上的员工才会给配股票。
软件测试工程师薪资 以上数据来自看准网，是P5、P6水平的软件工程师的平均薪资，在阿里的平均薪资之上，对于大多数测试工程师来说，阿里P7就是他们的奋斗目标。
因为阿里P7是行业内硬通货，而阿里P7级别的软件测试专家，不仅可以拿到综合年薪可以达到400w以上并且还会配股票。
腾讯篇 职位级别 之前的腾讯的分级和阿里/百度都不一样，分为T1/T2/T3/T4共4级，其中又细分为3级。员工仍然集中在中段，尤其是 T2.3 和 T3.1，想从T2跨到T3，即从2.3升3.1是非常困难的
但2019年腾讯宣布调整职级，将原 6 级 18 等（1.1-6.3 级）的职级体系优化为 14 级 (4-17 级)，新老职级的对应关系大致如下：
在腾讯，T3已经是很多员工的天花板，T4级别的就可以被业界技术员们尊称一句老师，而T5更是凤毛麟角。
薪资水平 腾讯的标准薪资一般是16薪，但是也不乏可以获得18薪的团队，且腾讯的游戏团队薪资、年终奖一般都比较高。
还有需要关注的一点是，腾讯的等级划分虽然只有4个，但是小职级之间的薪资差距并不少，如T3-3级别要比T3-1级别的高出30-60W/年。
软件测试工程师薪资 以上数据来自看准网，从薪资上来看，腾讯的初级软件工程师的与阿里相比，略低了一些，但是一般腾讯的年薪都是16~20个月薪水，半年基本就是升一个小级别，即T1.2升到T1.3。
百度篇 职位级别 技术序列 T：T3 - T11 （一般对应阿里高一级序列，如：百度T3=阿里P4，T5/T6属于部门骨干，非常抢手，人人猎中相当一部分offer人选都来自这个序列）
产品运营序列 P：p3-P11 （产品和运营岗，对应阿里高1-1.5级序列 百度p3=阿里P4-P5之间)
后勤支持部门 S ：S3-S11 (主要是公共、行政、渠道等等，晋升比较困难)
管理序列 M：M1-M5 (每一级又分为2个子级 M1A、M1B , 最低的是M1A，目前只有一个M5
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6074d90c0e9f698acd834cb75531fefe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c19bd2f0646adc9eb46a577c73fc60e0/" rel="bookmark">
			VS CODE调试ROS/C&#43;&#43;程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 通常步骤1. 程序编译2. 配置launch.json3. 运行调试 出错解决1. 无法载入断点 该文档将会持续进行更新，涉及ROS调试中遇到的一些问题。 C++程序的调试也相仿，只是去掉了启动 roscore的部分 通常步骤 1. 程序编译 这部分并不打算采用vscode的tasks.json来配置编译命令，而是选择手动的运行：
catkin_make --only_pkg-with-deps package_name 该命令可以单独的编译某个特定的package及其依赖项。
需要主要的是CMakeLists.txt应当修改成Debug模式：
OPTION(DEBUG_ON "Turn on DEBUG Mode" ON) IF(DEBUG_ON) MESSAGE("[Debug Mode]") SET(CMAKE_BUILD_TYPE "Debug") SET(CMAKE_CXX_FLAGS_DEBUG "$ENV{CXXFLAGS} -O0 -Wall -g -ggdb") ELSE() MESSAGE("[Release Mode]") SET(CMAKE_BUILD_TYPE "Release") SET(CMAKE_CXX_FLAGS_RELEASE "$ENV{CXXFLAGS} -O3 -Wall") ENDIF() 这样OPTION改成ON或者OFF，即可指定编译模式，比较方便。
2. 配置launch.json 这部分工作是本文的重点，单击vscode最右侧工具栏的Debug按钮（图标是一个甲虫+暂停），点击debug页里的齿轮按钮，即可打开launch.json。内容修改成如下状态：
{ // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c19bd2f0646adc9eb46a577c73fc60e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08c81c337c52164a3e6610d97d3c19cc/" rel="bookmark">
			linux 查看u盘挂载目录,Linux下手动挂载U盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在电脑上直接插入U盘，其实是可以直接使用的，会自动弹出一个窗口，不会像网上所说的那样，必须要自己挂载，但是为了学习手动用命令行挂载U盘，我关掉了那个窗口。可以用df –h查看文件系统的磁盘空间占用情况，我用了这个命令：
从上图可以看出，我的U盘的默认挂载点是/media/MYFENG(MYFENG是我U盘的盘符)，此时，可以直接打开该目录，使用U盘。为了学习挂载U盘，我选择了将U盘挂载在常用的挂载目录/mnt。
首先，我在/mnt下新建一个目录且命名为usb：
再将U盘挂载在/mnt/usb下：
然后，再用df –h命令查看文件系统的磁盘空间占用情况：
发现，U盘出现了两个挂载点/media/MYFENG和/mnt/usb，再仔细观察，其实两个挂载点的设备文件名都一样的，都是/dev/sdb1，由此也可以得出一个结论：一个硬件挂载的设备文件只有一个，但是挂载点可以有多个，关于这个结论的解释以及设备文件到底是什么东西？以后再做总结。
最后使用完了，就要注意卸载U盘的挂载点：
注意，如果是上面那种情况，要卸载两次，因为我用了两个挂载点
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7b09754577bdc15c09d270f29da7c2b/" rel="bookmark">
			linux 查看u盘挂载目录,在终端下用命令查看U盘挂载的路径及格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		满意答案
dsbsc
2013.07.11
采纳率：50% 等级：12
已帮助：8955人
Ubuntu 下挂载U盘的3种方式
这3种方式分别是：gnome下的自动挂载，pmount命令，在/etc/fstab中设定。
1、 gnome下的自动挂载
据搜索，gnome 下的自动挂载是利用hal(HAL, Hardware abstraction layer)实现的。只要把U盘插上，就会在桌面上出现一个 名为”usbdisk-1〃的U盘图标。这种方式有两个地方可以进行相关设置。
一个地方是设置自动挂载时的相关参数，例如：同步写标志sync，不更改文件访问时间标志noatime等等。在文件“/etc/hal/fdi /policy/preferences.fdi“中设置。原来的所有设置都是注释掉了的，如果添加sync、noatime 标志需要修改这个文件。我在“match key=”volume.size” compare_lt=”1000000000〃”这行走了点弯路，意思是小于1G就添加相应的参数。可是我没有注意到我的U盘实际上比这里的1G稍微大点(sudo fdisk -l /dev/sda 中查看)，为1010826752字节，结果设置的参数不管用，无意中才发觉这个问题。最后干脆去掉这一个条件，只要是这种 ”storage.hotpluggable”和”storage.removable” 为”true”的都加上”sync”和”noatime”标志。
另一个地方是开始菜单中的“系统-&gt;首选项-&gt;可移动驱动器和介质”，把相应选项勾上。
不对“/etc/hal/fdi/policy/preferences.fdi”修改时的/etc/mtab相关内容如下：
/dev/sda1 /media/usbdisk-1 vfat rw,nosuid,nodev,quiet,shortname=mixed,uid=1000,gid=1000,umask=077,iocharset=utf8 0 0
添加了sync和noatime标志后的相关内容：
/dev/sda1 /media/usbdisk-1 vfat rw,nosuid,nodev,sync,noatime,quiet,shortname=mixed,uid=1000,gid=1000,umask=077,iocharset=utf8 0 0
挂载点 /media/usbdisk-1是自动的。
2、用pmount 命令
在不登录入桌面的情况下，另登录一个控制台，在命令行下输入命令 pmount -sA /dev/sda1 也可以挂载U盘，效果同添加了sync和noatime标志的gome下挂载是一样的。挂载点 /media/sda1是自动的。
查看 man pmount，可知它的默认挂载参数是: async,atime,nodev,noexec,noauto,nosuid,user,rw
如果在UTF-8的locale下utf8的iocharset是默认的。
另外，在man pmount 下提示在Debian下，使用pmount 的用户需在plugdev 系统组。不过，我的Ubuntu装好就把我的使用用户自动加入了这个组。
3、在/etc/fstab中设定
要达到上面的效果需要一大串参数，如下：
/dev/sda1 /media/flash vfat rw,nosuid,nodev,sync,noatime,quiet,shortname=mixed,uid=1000,gid=1000,umask=077,iocharset=utf8 0 0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7b09754577bdc15c09d270f29da7c2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f64731bb3cdf74bc8678d02a110762c/" rel="bookmark">
			linux生成文件自带时间,Linux中显示文件创建时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Linux中查找文件创建日期
1.查找文件创建日期和时间“crtime”是使用stat命令针对名为“About-HowToing”的文件找到文件的inode。
$ stat About-HowToing
File: 'About-HowToing'
Size: 260 Blocks: 8 IO Block: 4096 regular file
Device: 80ah/2058dInode: 14420015 Links: 1
Access: (0777/-rwxrwxrwx) Uid: ( 1000/ howtoing) Gid: ( 1000/ howtoing)
Access: 2017-02-23 14:15:20.263337740 +0530
Modify: 2015-10-22 15:08:25.236299000 +0530
Change: 2016-08-01 10:26:36.603280013 +0530
Birth: -
或者，您可以对称为“About-HowToing”的文件使用ls -i命令 。
$ ls -i About-HowToing
14420015 About-HowToing
从上述命令的输出中，文件inode编号是14420015 。 请记下这个独特的inode编号，因为我们将在以下步骤中使用此inode编号。
2.现在我们需要找到我们的文件所在的根文件系统，只需发出以下df -h命令来识别根文件系统。
$ df -h
Filesystem Size Used Avail Use% Mounted on
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f64731bb3cdf74bc8678d02a110762c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f667b58028cc4ce94a410396e147d396/" rel="bookmark">
			[转载] python&#43;selenium定时爬取丁香园的新冠病毒每天的数据，并制作出类似的地图（部署到云服务器）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考链接： Python vars()
python+selenium定时爬取丁香园的新冠病毒每天的数据，并制作出类似的地图（部署到云服务器） 声明：仅供技术交流，请勿用于非法用途，如有其它非法用途造成损失，和本博客无关 目录
python+selenium定时爬取丁香园的新冠病毒每天的数据，并制作出类似的地图（部署到云服务器）前言一、准备二、爬取数据+画图第一步、分析页面第二步、编写代码第三步、结果展示
三、部署到云服务器1.定时运行获取数据2.通过微信获取地图（html文件）
四、运行展示
写在最后
前言 硬要说这篇文章怎么来的，那得先从那几个吃野味的人开始说起……前天睡醒：假期还有几天；昨天睡醒：假期还有十几天；今天睡醒：假期还有一个月……每天过着几乎和每个假期一样的宅男生活，唯一不同的是玩手机已不再是看剧、看电影、打游戏了，而是每天都在关注着这次新冠肺炎疫情的新闻消息，真得希望这场战“疫”快点结束，让我们过上像以前一样的生活。武汉加油！中国加油！！ 本次爬取的网站是丁香园点击跳转，相信大家平时都是看这个的吧。 一、准备 python3.7selenium：自动化测试框架，直接pip install selenium安装即可pyecharts：以一切皆可配置而闻名的python封装的js画图工具，其官方文档写的很详细了点击跳转。直接pip install pyecharts安装即可，同时还需安装以下地图的包： 世界地图：pip install echarts-countries-pypkg中国地图：pip install echarts-china-provinces-pypkg中国城市地图：pip install echarts-china-cities-pypkg 云服务器 二、爬取数据+画图 第一步、分析页面 先用个requests模块请求一下，看能不能拿到数据： import requests
url='https://ncov.dxy.cn/ncovh5/view/pneumonia_peopleapp?from=timeline&amp;isappinstalled=0'
headers={'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.88 Safari/537.36'}
r=requests.get(url,headers=headers)
print(r.text)
发现数据是乱码的并且注意到末尾处有如下字样： &lt;noscript&gt;You need to enable JavaScript to run this app.&lt;/noscript&gt;
意思是需要执行js代码，百度了一下发现这个页面应该是用react.js来开发的。限于自身技术能力，这个时候，我就只能用selenium了，它是完全模拟浏览器的操作，也即能执行js代码。 并且我需要拿到的数据并不多，也就一个页面而已，所以耗时也可以接受。 那么我要拿哪些数据呢，如下： 截至当前时间的全国数据统计病毒相关描述信息全国各个省份及其城市的所有数据全世界各个地区的数据 经过查看，发现这几处需要进行点击，才能获取到更多数据信息： 第二步、编写代码 导入相关包： from selenium import webdriver
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f667b58028cc4ce94a410396e147d396/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f04c6ba2007736cb50e825ea35481d8b/" rel="bookmark">
			node运行npm i 时卡在sill install loadAllDepsIntoIdealTree不动-解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		npm install一直停留在fetchMetadata: sill mapToRegistry uri http://registry.npmjs.org/whatwg-fetch可以使用如下命令设置为淘宝的镜像源：
npm config set registry https://registry.npm.taobao.org 使用如下命令检验是否成功：
npm config get registry 输出淘宝镜像路径
继续运行 npm install ,安装过程畅通无阻
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc578eb7d35935fbb74bbc092e52f05a/" rel="bookmark">
			iptables的组成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		iptables由五个表和五个链以及规则组成
五个内置链：
INPUT,PREROUTING,FORWARD,OUTPUT和POSTROUTING
五个表：
filter表：过滤规则表，根据预定义的规则过滤符合的匹配条件，默认表
nat表：进行NAT转换
mangle表：修改数据标记位规则表
raw：关闭启用的连接跟踪机制，加快封包穿越防火墙速度
security：用于强制访问控制网络规则，由Linux安全模块实现
优先级高低：
security–&gt;raw–&gt;mangle–&gt;nat—&gt;filter
表和链的对应关系
数据包进入服务器后，首先是经过PREROUTING链，然后根据需求，如果是转发至本服务器的报文(需要CPU处理的)，则转至INPUT链，如果是经过服务器(不需要CPU处理)，则转至FORWARD链。
数据包出服务器比如经过POSTROUTING链，但是如果是服务器本机发出来的报文，那么还会经过OUTPUT链。
默认的是filter链
[root@centos7-1 ~]# iptables -vnL
Chain INPUT (policy ACCEPT 0 packets, 0 bytes)
pkts bytes target prot opt in out source destination
Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)
pkts bytes target prot opt in out source destination
Chain OUTPUT (policy ACCEPT 0 packets, 0 bytes)
pkts bytes target prot opt in out source destination
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc578eb7d35935fbb74bbc092e52f05a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40a6e50e6d52e24e8ecf80e82484c786/" rel="bookmark">
			达梦数据库大小写敏感设置及使用初探
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、说明
二、参数设置
2.1、图形化设置
2.2、命令行设置
三、区别
3.1、大小写敏感库
3.1.1、创表
3.1.2、DML操作
3.2、大小写不敏感
3.2.1、创表
3.2.2、DML操作
一、说明 达梦在安装完软件后，需要初始化数据库实例，初始化中【大小写敏感】这个参数特别重要，因为如果设置错了，在实例生命周期内，无法更改，如果要更改，除非重新初始化。
二、参数设置 2.1、图形化设置 通过dbca 工具图形化界面初始化数据库实例，勾选相应参数【字符串比较大小写敏感】， 默认值为“勾选”（即为1 ），对于大小写是敏感的，即区分大小写
2.2、命令行设置 通过命令行dminit 工具初始化实例，通过参数 case_sensitive 进行设置，参数默认值为Y （即为1 ），也就是敏感（区分大小写），如果要设置为不敏感，参数设置【case_sensitive=n 】或者【case_sensitive=0 】即可（参数名字大写或者小写都可以）
dmdba@dmdsc01:~/dmdbms/bin$ ./dminit help initdb V8 db version: 0x7000b 格式: ./dminit KEYWORD=value 例程: ./dminit PATH=/public/dmdb/dmData PAGE_SIZE=16 关键字 说明（默认值） -------------------------------------------------------------------------------- CASE_SENSITIVE 大小敏感(Y)，可选值：Y/N，1/0 三、区别 3.1、大小写敏感库 3.1.1、创表 1、如果不对表名或列名添加""，那么表名和列名都自动转换为大写形式
2、如果对表名或列名添加""，会固定书写时的大、小写形式，书写时采取的是小写形式，那么就定型为小写形式，其他不添加""的则自动转换为大写形式，无论书写时采取的是大写形式或小写形式
3、同名的数据库对象，如果大小写不同，那么则为两个不同的对象，字段同样如此；
3.1.2、DML操作 1、如果不对表名或列名添加""，那么表名和列名都自动转换为大写形式；
2、对表进行DML操作时，如果没有小写形式的字段，不能采取小写加""的形式指定过滤字段，会被认定为无效的字段；
3、如果对表名或列名添加""，会固定书写时的大、小写形式，""中是大写形式，则过滤字段就是大写字段，""中是小写字段，则过滤字段就是小写字段；
4、查询时，"和""界定符中字符串区分大小写，界定符中的字符串若是大写形式，那仅查询这个大写形式的对象，若是或小写形式，那仅查询这个小写形式的对象，DML操作依旧
3.2、大小写不敏感 3.2.1、创表 1、无论对不对表名或列名添加""，表名和列名的大小写形式不会发生变化，大写形式就是大写形式，小写形式就是小写形式
2、不允许存在同名的数据库对象，即使大小写不同，默认也只能存在一个
3、一个表中，也不允许相同的字段名，即使大小写不同
3.2.2、DML操作 1、无论对不对表名或列名添加""，表名和列名的大小写形式不会发生变化，大写形式就是大写形式，小写形式就是小写形式；
2、查询时，’'和""界定符不区分大小写，界定符中的查询或过滤条件即使是大写或小写，都可以查询到预期的结果集，进行DML操作时依旧
参考：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40a6e50e6d52e24e8ecf80e82484c786/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/898a70c4c7bc7a8c46e691e67109a403/" rel="bookmark">
			tera term串口文本匹配打印时间脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用tera term查看串口消息时，想知道收到特定消息的具体时间，却发现没有现成的脚本可以使用。自己动手写了一个，独乐乐不如众乐乐。
复制这段代码保存到ttl后缀文件即可。
WhatString = 'hi' while 1 wait WhatString getdate datestr gettime timestr dispstr ' [' datestr ' ' timestr '] ' endwhile 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f63ee262c752831bb7e075aad9cc9bf/" rel="bookmark">
			Springboot安全管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 安全管理介绍一、Spring SecuritySpring Boot整合Spring Security实现的安全管理功能： 二、MVC Security安全配置介绍如何关闭Sercurity提供的Web应用默认安全配置WebSecurityConfigurerAdapter类的主要方法及说明 本次用到的依赖 自定义用户认证使用内存进行身份认证 安全管理介绍 实际开发中，一些应用通常要考虑到安全性问题。例如，对于一些重要的操作，有些请求需要用户验明身份后才可以执行，还有一些请求需要用户具有特定权限才可以执行。这样做的意义，不仅可以用来保护项目安全，还可以控制项目访问效果。
提示：以下是本篇文章正文内容，下面案例可供参考
一、Spring Security •Spring Security是基于Spring生态圈的，用于提供安全访问控制解决方案的框架。
•Spring Security的安全管理有两个重要概念，分别是Authentication（认证）和Authorization（授权）。
Spring Boot整合Spring Security实现的安全管理功能： MVC Security是Spring Boot整合Spring MVC框架搭建的Web应用的安全管理。
WebFlux Security是Spring Boot整合Spring WebFlux框架搭建的Web应用的安全管理。
OAuth2是大型项目的安全管理框架，可以实现第三方认证、单点登录等功能。
Actuator Security用于对项目的一些运行环境提供安全监控，例如Health健康信息、Info运行信息等，它主要作为系统指标供运维人员查看管理系统的运行情况。
官方默认的安全登录常见几个问题
1.只有唯一的默认登录用户user、密码随机生成且过于暴露、登录页面及错误提示页面不是我们想要的等。
二、MVC Security安全配置介绍 项目引入spring-boot-starter-security依赖启动器，MVC Security安全管理功能就会自动生效，其默认的安全配置是在SecurityAutoConfiguration和UserDetailsServiceAutoConfiguration中实现的。
•SecurityAutoConfiguration:•导入并自动化配置启动Web安全管理
•UserDetailsServiceAutoConfiguration:•用于配置用户身份信息
如何关闭Sercurity提供的Web应用默认安全配置 1.要完全关闭Security提供的Web应用默认安全配置，可以自定义WebSecurityConfigurerAdapter类型的Bean组件以及自定义UserDetailsService、AuthenticationProvider或AuthenticationManager类型的Bean组件。
2.另外，可以通过自定义WebSecurityConfigurerAdapter类型的Bean组件来覆盖默认访问规则。
WebSecurityConfigurerAdapter类的主要方法及说明 方法描述configure(AuthenticationManagerBuilder auth)定制用户认证管理器来实现用户认证configure(HttpSecurity http)定制基于HTTP请求的用户访问控制 本次用到的依赖 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Data JPA操作数据库 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f63ee262c752831bb7e075aad9cc9bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e7a3268ab2ce1d1c0b0eaff680b7952/" rel="bookmark">
			Freemarker使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是网页静态化技术 随着用户访问量以及数据量的增大，网页静态化技术方案如今越来越流行。 什么是网页静态化技术呢？简单来说就是将网页以纯静态方式的形式展现。
2.网页静态化技术与缓存技术的比较 共同点：都可以减小数据库的访问压力。
区别：
(1)缓存技术适用于小规模的数据。以及一些经常变动的数据。
(2)网页静态化技术适用于大规模但是变化不太频繁的数据。
页面静态化与缓存技术的定义:
页面静态化是指通过一些模板技术(如freemarker)将数据模型生成静态html页面并通过ajax技术实现页面的局部刷新,从而减少数据库的交互,并利用搜索引擎优化技术(SEO)来提高交互效率.
缓存技术(如ehcache):本质通过将数据存储到服务器的内存中,用户在交互时先交互内存,缓存穿透后交互数据库,利用内存交互速度比数据库交互快的原理来提高交互效率
3.网页静态化技术的应用场景 (1)新闻门户网站的文章类型频道一般都用到了网页静态化技术。点击新闻直接会跳到静态化的页面。
(2)电商网站的商品详情页也十分常用，我们在存储商品的时候会生成静态化页面，点击商品详情，会直接跳到生成的商品详情的静态化页面。
(3)网页静态化技术可以结合Nginx这种高性能web服务器来提高并发访问量。
4.什么是FreeMarker FreeMarker是一款用Java语言编写的模板引擎，用它可以通过模板和要改变的数据来生成输出文本(例如HTML网页，配置文件，源代码等)，作为用来实现网页静态化技术的一种手段。FreeMarker的使用率大大超过其他一些技术。对于系统中频繁使用数据库进行查询但是内容更新很小的应用，都可以用FreeMarker将网页静态化，这样就避免了大量的数据库访问请求，从而提高网站的性能。
5.FreeMarker介绍 Freemarker是一个用Java语言编写的模板引擎，它基于模板来生成文本输出。FreeMarker与Web容器无关，即在Web运行时，它并不知道Servlet或HTTP。它不仅可以用作表现层的实现技术，而且还可以用于生产XML，JSP或Java等。
6、FreeMarker入门案例 6.1、环境搭建 创建maven工程并导入Freemarker的maven坐标
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.23&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 6.2、创建模板文件 模板文件中有四种元素：
1、文本，直接输出的部分
2、注释，即&lt;#-- ... --&gt;格式不会输出
3、插值(Interpolation)：即${...}部分，将使用数据模型中的部分替代输出
4、FTL指令：FreeMarker指令，和HTML标记类似，名字前加#予以区分，不会输出
Freemarker的模板文件后缀可以任意，一般建议为ftl.
在当前项目目录下创建名称为testTemplate.ftl的模板文件，内容如下：
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Freemarker入门测试&lt;/h1&gt; ${name} ----- ${message} &lt;/body&gt; &lt;/html&gt; 6.3、生成文件 使用步骤：
第一步：创建一个Configuration对象，直接new一个对象。构造方法的参数就是freemarker的版本号。
第二步：设置模板文件所在的路径。
第三步：设置模板文件使用的字符集。一般就是utf-8.
第四步：加载一个模板，创建一个模板对象。
第五步：创建一个模板使用的数据集，可以是pojo也可以是map。一般是Map。
第六步：创建一个Writer对象，一般创建FileWriter对象，指定生成的文件名。
第七步：调用模板对象的process方法输出文件。
第八步：关闭流。
package com.panghl.test; import freemarker.template.Configuration; import freemarker.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e7a3268ab2ce1d1c0b0eaff680b7952/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23e3780c9aa3ad2a4d703a332d2e50ee/" rel="bookmark">
			java poi word导出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java poi word导出 (含有文字，图像)
导出word效果如下：
思路：建立预期导出word效果，设置为模板，然后填充对应信息，注意，加粗，居中等一些图片，文字格式预先设置好。然后进行文字或者图片填充即可；
1.将word文件另存为xml格式；
2.将文件后缀xml文件打开，修改模板对应填充信息如图下，然后修改后缀名为.ftl
以上模板准备完毕。
3.代码：
入口
@PostMapping(value = "/exportDIY") @ResponseBody @ApiOperation("多格式导出文件") @ControllerLog(description = "多格式导出文件", logLevel = 1) public ResponseResult exportDIY(HttpServletResponse response, @RequestBody Map&lt;String, String&gt; request) { return logService.exportDIY(response, request); } 主题代码：
try { Map&lt;String, Object&gt; datas = new HashMap&lt;String, Object&gt;() { { put("title", "xxxxxxx统计"); put("time", getTimeMsg(request)); //java图片/base64等格式图片 put("image1", URLDecoder.decode(request.get("image1").substring(22), "UTF-8").replaceAll(" ", "+")); put("image2", URLDecoder.decode(request.get("image2").substring(22), "UTF-8").replaceAll(" ", "+")); } }; WordUtils wordUtils = new WordUtils(); wordUtils.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23e3780c9aa3ad2a4d703a332d2e50ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fd13e903bc638b16e393663726d6656/" rel="bookmark">
			windows C盘自动清理bat脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建.bat 文件，内容如下：
@echo off echo 正在清除系統垃圾文件，請稍等...... del /f /s /q %systemdrive%\*.tmp del /f /s /q %systemdrive%\*._mp del /f /s /q %systemdrive%\*.log del /f /s /q %systemdrive%\*.gid del /f /s /q %systemdrive%\*.chk del /f /s /q %systemdrive%\*.old del /f /s /q %systemdrive%\recycled\*.* del /f /s /q %windir%\*.bak del /f /s /q %windir%\prefetch\*.* rd /s /q %windir%\temp &amp; md %windir%\temp del /f /q %userprofile%\cookies\*.* del /f /q %userprofile%\recent\*.* del /f /s /q "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fd13e903bc638b16e393663726d6656/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d41b4c318525efb0259b9e0f2f50e0bf/" rel="bookmark">
			Unity(4)-碰撞检测(射线检测)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		b站学习视频
链接：https://www.bilibili.com/video/BV12s411g7gU?p=181
碰撞检测
连个碰撞物
//当满足碰撞条件 //接触的第一帧执行 private void OnCollisionEnter(Collision other) { //事件参数类 //other:获取对方碰撞器组件collision.collider.GetComponent&lt;?&gt; //获取第一个接触点 ContactPoint cp = other.contacts[0]; //cp.point 接触点的世界坐标 //cp.normal 接触面法线 print("OnCollisionEnter----"+other.collider.name); } //当满足触发条件 //接触的第一帧执行 private void OnTriggerEnter(Collider other) { //other:就是对方碰撞器组件other.GetComponent&lt;?&gt; print("OnTriggerEnter----"+other.name); } public float moveSpeed = 50; private void FixedUpdate() { Debug.Log(Time.frameCount+"--"+this.transform.position); this.transform.Translate(0,0,Time.deltaTime*moveSpeed); } 但如果物体移动速度过快，碰撞检测将失效
当移速为50时，能检测到
当移速为150时，能检测到
当移速为250时，能检测到
当移速为1000时，就检测不到了
解决方案：开始时，使用射线去检测。
public LayerMask mask; private Vector3 targetPos; //目标位置 //如果物体移动速度过快，碰撞检测将失效 //解决方案：开始时，使用射线去检测。 private void Start() { //重载11 RaycastHit hit; //Raycast(起点坐标，方向，受击物体信息，距离，？); if(Physics.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d41b4c318525efb0259b9e0f2f50e0bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/105ef2d4ac361a3d600b94c8d2ec6973/" rel="bookmark">
			Ansible 1.4.2：ansible 命令的基本用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.4.2：ansible 命令的基本用法 ansible命令用于对特定主机定义和运行单个的Ansible任务。一般的用法为：
ansible &lt;HOST_PATTERN&gt; [OPTIONS] [-m MODULE_NAME] [-a "MODULE_ARGS"] 其中：
HOST_PATTER用于指定主机。OPTIONS用于指定其它选项。MODULE_NAME用于指定Ansible模块。MODULE_ARGS是为指定模块传递的参数或命令。 1.4.2.1：ansible 命令常用选项 1.4.2.1.1：–version 显示版本信息 --version用于显示Ansible版本号、配置文件路径、模块查询路径、模块位置，以及Ansbile所调用的可执行环境（Python信息等）。
--version show program's version number, config file location, configured module search path, module location, executable location and exit 示例：
[root@ansible ~]# ansible --version ansible 2.9.18 config file = /root/ansible.cfg configured module search path = [u'/root/.ansible/plugins/modules', u'/usr/share/ansible/plugins/modules'] ansible python module location = /usr/lib/python2.7/site-packages/ansible executable location = /usr/bin/ansible python version = 2.7.5 (default, Nov 20 2015, 02:00:19) [GCC 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/105ef2d4ac361a3d600b94c8d2ec6973/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/901dde8a50c04c920c7ca33863884b5f/" rel="bookmark">
			2021天梯赛题解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2021程序设计天梯赛在4月24日举办，本文是天梯赛的部分题解，有的问题在当时也没有得到满分，由于学校开启了天梯赛的重现比赛，再写一写。
注意：本文答案不是标准答案，每道题收获的分数写在了相应位置，注意查看。
有的人退出，有的人加入。始终如一，不忘初心。
L1-1 人与神 ( 5分 / 5 分) 第一个5分是代码获得的分数，第二个5分是题目总分，下同 跨界大神 L. Peter Deutsch 有一句名言：“To iterate is human, to recurse divine.”（迭代的是人，递归的是神）。本题就请你直接在屏幕上输出这句话。 输入格式：
本题没有输入。 输出格式：
在一行中输出
To iterate is human, to recurse divine.。 输入样例：
无 输出样例：
To iterate is human, to recurse divine. 【问题分析】签到题，直接输出即可。
#include &lt;iostream&gt; #include &lt;stdio.h&gt; #include &lt;math.h&gt; #include &lt;string.h&gt; #include &lt;cstring&gt; #include &lt;sstream&gt; #include &lt;stdlib.h&gt; #include &lt;map&gt; #include &lt;stack&gt; #include &lt;queue&gt; #include &lt;vector&gt; using namespace std; int main(){ cout&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/901dde8a50c04c920c7ca33863884b5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c35a0cc84324cf25ef9ac81100aafa0e/" rel="bookmark">
			2021-04-27
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习文档网站 MDN DevDcs
mozilla开发者网站的MDN文档，网址是：https://developer.mozilla.org/en-US/docs/Web
W3C官网的地址是：http://www.w3.org
一个是w3c标准，网址是： https://www.w3.org/standards/
参考:【前端开发必备之MDN文档_pullgo的博客-CSDN博客_mdn离线文档】https://blog.csdn.net/qq_39894133/article/details/79470510
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14acde55dfae34ea6110ce0b07d5936e/" rel="bookmark">
			2021-4-26【PTA】【L1-6 吉老师的回归 (15 分)】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n,m,cnt=1;//cnt标志 string str; cin&gt;&gt;n&gt;&gt;m;//输入 getchar();//吸收回车 while(n--)// { getline(cin,str);//输入字符串 if(str.find("qiandao")!=-1||str.find("easy")!=-1);//如果符合则无输出 else { if(m==0)//剩余做题数==0 { cout&lt;&lt;str;//输出字符串 cnt=0;//改标志 break;//退出循环 } m--;//做题数 } } if(cnt) cout&lt;&lt;"Wo AK le"&lt;&lt;endl;//如果标志未改变 return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3e1ff4c8f06a840ad828b0b564a71d1/" rel="bookmark">
			Chrome 书签不同步解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先进入Chrome 同步管理
地址栏输入：
chrome://sync-internals
ENTER
方法一：
1点击“Stop Sync (Keep Data)”，
2之后点击“Request Start”
方法二：
点 Trigger GetUpdates
备注：请在Chrome不同端执行一次这个操作
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/200d30a89cd09f50d598718edd245bee/" rel="bookmark">
			python 斐波那契数列 &#43; 尾递归
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		普通递归 def fibonacci_fast(n): if n &lt;= 1: return n else: return(fibonacci_fast(n - 1) + fibonacci_fast(n - 2)) print(fibonacci_fast(10)) def fibonacci_fast_2(n): a, b = 0, 1 for _ in range(n): a, b = a + b, a return a print(fibonacci_fast_2(10)) 尾递归 python2 #!/usr/bin/env python2.4 # This program shows off a python decorator( # which implements tail call optimization. It # does this by throwing an exception if it is # it's own grandparent, and catching such # exceptions to recall the stack.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/200d30a89cd09f50d598718edd245bee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64e6af016b6a7b16bba5d78dfbf0fbb9/" rel="bookmark">
			LVGL7.11中使用freetype库加载显示字体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、使用环境
2、关于freetype库
3、编译freetype-2.10.4
4、下载LVGL官方封装的接口lv_lib_freetype
5、在mian.c中添加测试代码
1、使用环境 硬件环境：宸芯科技的SS202X系列芯片（笔者这里使用的是SS202D）
软件环境：Linux（移植的嵌入式系统） LVGL7.11
编译器：arm-linux-gnueabihf-gcc
2、关于freetype库 笔者这里使用的是freetype-2.10.4，下载地址：https://download.savannah.gnu.org/releases/freetype/
3、编译freetype-2.10.4 （1）解压freetype-2.10.4
tar -zxvf freetype-2.10.4.tar.gz 解压完成后可以用tree命令看到如下文件目录树
tree freetype-2.10.4 freetype-2.10.4 ├── autogen.sh ├── builds │ ├── amiga │ │ ├── include │ │ │ └── config │ │ │ ├── ftconfig.h │ │ │ └── ftmodule.h │ │ ├── makefile │ │ ├── makefile.os4 │ │ ├── README │ │ ├── smakefile │ │ └── src │ │ └── base │ │ ├── ftdebug.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64e6af016b6a7b16bba5d78dfbf0fbb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec247809301a7d5f6e93b5b2b55c4644/" rel="bookmark">
			2021-Swin Transformer Attention机制的详细推导
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. Title2. Summary3. Problem Statement4. Method(s)4.1 Overall Architecture（1）Patch Partition（2）StagesPatch MergingSwin Transformer Block 4.2 Shifted Window based Self-Attention（1）Self-Attention in Non-Overlapped Windows（2）Shifted Window Partitioning in Successive Blocks（3）Efficient Batch Computation for Shifted ConfigurationNaive SolutionBatch Computation ApproachMask计算结果手工推导Mask作用的手工推导 （4）Relative Position Bias 4.3 Architecture Variants 5. Evaluation（1）对比实验（2）消融实验 6. Conclusion 1. Title paper
github
2. Summary SwinTransformer与PVT一样，也是想设计一个可以作为密集预测任务的Transformer Backbone，其采用与PVT类似的PatchMerging的策略，构建了层次化的特征，使得其可以作为密集预测任务的Backbone。
同时考虑到密集预测任务中，tokens数目太多导致计算量过大的问题，其采用一种在local window内部计算Self-Attention的机制去降低计算复杂度，使得整体计算复杂度由 O ( N 2 ) O(N^2) O(N2)降低至 O ( N ) O(N) O(N)水平。
为了弥补Local Self-Attention带来了远程依赖关系缺失的问题，其创新性地采用了Shift Window操作，引入了不同window之间的关系，并且在精度以及速度上都超越了简单的Sliding Window的方法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec247809301a7d5f6e93b5b2b55c4644/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3ef237b56ed0eb5ce95623967376ad2/" rel="bookmark">
			简单的创建一个小型服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux网络 linux 网络基础 linux网络一、DHCP服务1.DHCP基础2.DHCP好处3.DHCP分配方式4.配置 二、FTP服务1.FTP服务基础2.匿名访问FTP服务3.本地用户访问FTP服务 总结 一、DHCP服务 1.DHCP基础 DHCP（动态主机配置协议）
一个局域网的网络协议，使用UDP协议：服务器67号端口，客户端68号端口
给内部网络或服务供应商自动分配IP地址
给用户或者内部网络管理员作为对所有计算机中央管理手段
2.DHCP好处 减少管理员的工作量
避免输入错误的可能
避免IP地址冲突
当网络更改IP地址段时，不需要再重新配置每个用户的IP地址
提高了IP地址的利用率
方便客户端的配置
3.DHCP分配方式 分配方式：手动分配、自动分配、动态分配。
DHCP的IP地址自动获取工作原理
第一步:客户端在网络中搜索服务器。
客户端通过广播发送 DHCP Discover报文寻找服务器端
第二步:服务器向客户端响应服务
服务器端通过广播发送DHCP Offer报文向客户端提供I地址等网络信息,从I地址池中挑选一个尚未分配的I地址分配给客户端
第三步:客户端向服务器发出服务请求
如果有多台DHCP服务器向该客户端发来DHCP-offer报文,客户端只接受第一个收到的DHCP- offer报文并提取I地址,然后客户端通过广播发送 DHCP Request报文告知服务器端本地选择使用该IP地址
第四步:服务器向客户端提供服务
服务器通过广播发送 DHCP ACK报文告知客户端I地址是合法可用的,并在选项字段中增加I地址的使用租期信息
(5)重新登录
DHCP客户机每次重新登录网络时,不需要再发送 DHCP Discover信息,而是直接发送包含前一次所分配的IP地址的 DHCP Request请求信息
(6)更新租约
当DHCP服务器向客户机出租的IP地址租期达到50%时,就需要更新租约。客户机直接向提供租约的服务器发送 DHCP Request包,要求更新现有的地址租约
4.配置 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210426153413360.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLm
NzZG4ubmV0L3dlaXhpbl81NTYwOTkwNQ==,size_16,color_FFFFFF,t_70)
配置DHCP服务器 yum install -y dhcp cd /usr/share/doc/dhcp-4.2.5/ vim /etc/dhcp/dhcpd.conf cp /usr/share/doc/dhcp-4.2.5/dhcpd.conf.example /etc/dhcp/dhcpd.conf vim /etc/dhcp/dhcpd.conf 设置全局配置参数 default-lease-time 600; 默认租约为10分钟，单位为秒 max- lease-time 7200; 最大租约为2小时，单位为秒.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3ef237b56ed0eb5ce95623967376ad2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ab69fd51dad58c30e15b6c6ebac8a43/" rel="bookmark">
			利用TreeSet实现Comparable、Comparator的两种排序方式（自然排序、定制排序）----使用泛型之后的改进
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天看了看 泛型的使用（基于集合），对于之前的题目，进行一下技术更新，实现：在使用泛型的基础上的、利用TreeSet结构、实现Comparable、Comparator的两种排序方式（自然排序、定制排序）的 存储对象到集合中的操作。
具体如下：
题目： 创建5个employee的对象，并把这些对象放入treeset集合中
* 分别按照以下两种方式对接中的元素进行排序：
1）使employee实现comparable接口，并按照排序
（先创建treeset，并且使用add（）加入元素，另外再写一个comparato()即可，因为treeset中，本质上是使用comparato()去比较的）
2）创建treeset时传入com对象（用带有形参的构造器），按生日日期的先后顺序，进行排序
代码实现： 1）Employee类：
public class Employee implements Comparable&lt;Employee&gt;{ //Comparable的实现类想用来比较谁，表示泛型的&lt;&gt;内就写谁------Employee private String name; private int age; private MyDate birthday; //构造器 public Employee(String name, int age, MyDate birthday) { super(); this.name = name; this.age = age; this.birthday = birthday; } public Employee() { super(); } //get、set方法 public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ab69fd51dad58c30e15b6c6ebac8a43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a5a8170e1abfd1f0f1c96cef3850c16/" rel="bookmark">
			13 --＞ 制作 OpenWrt X86 image 镜像、导入到 ProxMox 集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用 OpenWrt-X86-image 时，需要部署到Proxmox的生产环境虚机中，以防备忘。
导入过程分为如下几步:
第一步 把 openWrt-image.vmdk 格式镜像，通过VMware工具转化成 ovf 格式；
如何把 OpenWrt 编译镜像安装到 VMware 中，请参考此链接。
选择 VMware 的文件–&gt; 导出为 OVF ，选择合适保持文件路径。
第二步 使用 qemu 把 OVF 格式镜像、转换成 qcow2 格式的虚拟机；
把 OVF 文件拷贝至 Proxmox 主机的 /home/ 文件件中，使用如下命名:
虚机id 镜像名称 虚机存储位置 proxmox格式 | | | | qm importovf 996 ixe-x86.ovf test-ljm --format qcow2 第三步 配置 新创建的虚拟机 硬盘类型：VirtIO SCSI ；
第四步 配置 新创建虚拟机 网卡vmbr0 类型: VirtIO paravirtualized；
第五步 启动虚拟机、配置 OpenWrt的网络参数；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b582f386dc9386aad5e29ee579de072a/" rel="bookmark">
			线性表（链表）——单链表、双链表、循环单链表、循环双链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单链表的定义及基本操作
#include&lt;iostream&gt; using namespace std; typedef struct Node//定义一个结点类的结构体类型 { int data;//数据域 struct Node *next;//指针域 }node,* pnode; //node * 和pnode 等价，在使用中node *强调这是一个结点，pnode 强调这是一个链表 //基本操作——按序号查找节点值 node * GetElem(pnode L,int pos)//函数含义：获取链表中第pos个结点 { if(pos==0) return L; if(pos&lt;1) return NULL; int j=1; //定义一个结点用来存放顺序表中的第一个结点 node * fnode=L-&gt;next; while(fnode!=NULL&amp;&amp;j&lt;pos) { fnode=fnode-&gt;next; j++; } return fnode; } //基本操作——按值查找表结点 node *LocateElem(pnode L,int elem) { node * x=L-&gt;next;//x指向链表当中的第一个结点 while(x!=NULL) { if(x-&gt;data==elem) break; x=x-&gt;next; } return x; } //基本操作——利用尾插法建立单链表 void LinkList(pnode &amp;L,int length) { node *enode,*tnode; tnode=L; int x; for(int i=0;i&lt;length;i++) { enode=(node *)malloc(sizeof(node)); cin&gt;&gt;x; enode-&gt;data=x; tnode-&gt;next=enode; tnode=enode; } cout&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b582f386dc9386aad5e29ee579de072a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c7ba68ff0eeaf4a59e3f2d10adaa6e5/" rel="bookmark">
			STM32F103 实例应用（13）——串口接收中断&#43;串口空闲中断接收不定长字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、应用简介 本文介绍串口中断接收不定长字符串的方法。将串口1配置接收中断使能、空闲中断使能来接收不定长数据。
也就是在配置串口中断的时候使能接收中断和空闲中断。如下：
... USART_ITConfig(USART1, USART_IT_RXNE, ENABLE); USART_ITConfig(USART1, USART_IT_IDLE, ENABLE);	... USART_IT_RXNE：接收中断，串口每收到一个字节就会产生一个此中断。
USART_IT_IDLE：空闲中断，总线上在一个字节的时间内没有再接收到数据的时候发生的。
之后在串口中断处理函数中分别判断处理2种中断就好了，如下：
// 接收数组大小 #define RECEIVE_BUF_SIZE 255 uint8_t g_usart1RxFlag = 0;	// 串口1接收标志0-未接受1-接收 uint8_t g_uart1ReceiveBuff[RECEIVE_BUF_SIZE]; // 串口1接收缓冲 uint16_t g_uart1Len = 0;	// 串口1接收长度 /** @brief USART1中断 @param 无 @retval 无 */ void USART1_IRQHandler(void) { // 接收中断的时候收集数据包 if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET) { USART_ClearITPendingBit(USART1, USART_IT_RXNE); //只USART_ReceiveData也可以 g_uart1ReceiveBuff[g_uart1Len] = USART_ReceiveData(USART1); g_uart1Len++; } // 空闲中断的时候说明串口没数据了，收集完成 else if(USART_GetFlagStatus(USART1, USART_FLAG_IDLE) != RESET) { USART1-&gt;SR; USART1-&gt;DR; // 标志位，代表有数据，此数据放到main处理去，不要放中断处理。我只打印一下 g_usart1RxFlag = 1; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c7ba68ff0eeaf4a59e3f2d10adaa6e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb0311ee43dda560b9919bf1945e3d60/" rel="bookmark">
			Kali ❀ Nmap史上最详细参数解析梳理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 常用功能 1、主机发现常用扫描协议扫描ICMP Ping Types扫描ARP Ping扫描路由跟踪域名扫描 2、扫描状态状态描述 3、指纹识别（服务与系统探测）4、渗透测试信息收集（1）whois查询（2）DNS记录查询与爆破（3）扫描Web漏洞 漏洞利用（1）检测Mysql密码（2）FTP服务认证（3）wordpass认证 5、结果输出标准输出XML输出 Nmap - Network Mapper 网络映射器：是一款开放源代码的网络探测和安全审核的工具，其设计目标是快速扫描大型网络或单个主机，Nmap以新颖的方式使用原始IP报文来发现网络上有哪些主机，哪些主机提供了什么服务（应用程序名称和版本信息），哪些服务运行在什么类型的操作系统（版本信息），他们使用什么类型的报文过滤器/防火墙，以及其他的功能；
常用功能 检测存活在某网络上的主机（主机发现）；检测某主机上开放的端口（端口发现）；检测到相应的端口运行的软件和版本（服务发现）；检测某主机的操作系统、硬件地址、软件版本；检测脆弱性漏洞（脚本运行）； 1、主机发现 语法：Nmap [选项][多选项][协议] [目标]
常用扫描 -p：指定端口号或端口范围对目标扫描进行扫描；-F：快速扫描；-top-ports [数量]：开放率最高的数量端口进行扫描；-sS：TCP SYN快速扫描；-sT：TCP连接扫描；-sA：TCP ACK扫描；-sU：UDP端口扫描；-sl：端口完全欺骗扫描，伪装额外主机对目标进行扫描；-Pn：禁止ping后扫描，跳过主机发现的过程进行端口扫描；-6：开启IPv6扫描；-A：全面扫描；-v：显示详细信息； 注：如在root用户下执行，无参数则默认携带sS参数执行，非root用户默认执行sT参数；
root@kali:~# nmap 192.168.39.1-10	/指定某个IP地址范围进行扫描； 协议扫描 -sP：仅使用ping扫描，回显做出响应的主机；-P0/Pn：用于防火墙禁止ping的情况下，可以用于穿透防火墙；-PS：使用TCP SYN ping扫描对目标主机进行存活探测；默认ping扫描是使用TCP ACK和ICMP echo请求对目标进行存活探测，当目标防火墙阻止这些请求时，可以使用TCP SYN ping扫描对目标主机进行存活探测；-PA：使用TCP ACK ping扫描对目标主机进行存活探测；很多防火墙会封锁SYN报文，此时可以使用TCP ACK ping扫描对目标主机进行存活探测；-PU：使用UDP ping扫描目标主机，如果返回ICMP端口不可达错误，主机存活；如果返回各种ICMP错误信息，则主机不存活； ICMP Ping Types扫描 -PE：使用ICMP扫描；-PP：使用时间戳ping扫描；-PM：使用ICMP地址掩码ping扫描； ARP Ping扫描 -PR：使用ARP进行扫描； 路由跟踪 traceroute：查出本地主机到目标主机之间经过的网络节点信息； 域名扫描 -sL：列出指定网络上的每台主机，默认使用域名解析获取他们的主机名称；-n：禁止目的地址作为反向域名解析；-R：对目标地址作为反向域名解析；-system-dns：直接发送查询到主机上自带配置的域名服务来解析域名； 2、扫描状态 root@kali:~# nmap 192.168.39.132 Starting Nmap 7.91 ( https://nmap.org ) at 2021-01-19 22:14 EST Nmap scan report for 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb0311ee43dda560b9919bf1945e3d60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db4fe15046acc2efee13f6cc57ba1c18/" rel="bookmark">
			DOSBOX的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 masm 生成 obj 文件
用 link 生成 exe 文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b37b207ee055a71a2e5750048e08b6d/" rel="bookmark">
			CICD系列之jenkins
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jenkins专题 安装docker &amp; docker-compose安装jenkins编写docker-compose.yml 脚本配置jenkins安装常用插件 记录jenkins安装、配置、使用的常用操作 linux物理机安装 安装docker &amp; docker-compose docker安装与配置
安装jenkins # 创建docker桥接网络 docker network create john-net # 新建数据目录 mkdir data 编写docker-compose.yml 脚本 version: '3' services: jenkins: image: jenkins/jenkins:lts container_name: docker-jenkins restart: always user: root privileged: true environment: - TZ=Asia/Shanghai networks: - john-net ports: - 9002:8080 - 50000:50000 volumes: - /etc/localtime:/etc/localtime # 时间 - ./data:/var/jenkins_home # 工作目录 - /var/run/docker.sock:/var/run/docker.sock - /usr/bin/docker:/usr/bin/docker - /base/jdk8:/home/java8 - /base/maven3.8:/home/mvn3 - /base/maven-repo:/root/.m2/repository - /root/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b37b207ee055a71a2e5750048e08b6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1452e1151288b6308d1357e1ddffc742/" rel="bookmark">
			去掉Pycharm的新建项目中venv文件夹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 步骤 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/304b762ca06a239ef5ad89c69f969d43/" rel="bookmark">
			CICD系列之harbor
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		镜像仓库专题 安装docker &amp; docker-compose安装harbor下载并解压安装文件修改配置文件安装、管理harbor访问harbor重点提示 记录镜像仓库的常用操作。 安装docker &amp; docker-compose docker &amp; docker-compose安装与配置
安装harbor 下载并解压安装文件 # 下载到指定目录并进入该目录 wget https://github.com/goharbor/harbor/releases/download/v2.2.0/harbor-offline-installer-v2.2.0.tgz -P /docker &amp;&amp; cd /docker # 解压安装文件 tar -xzvf harbor-offline-installer-v2.2.0.tgz 修改配置文件 ## 进入解压目录并修改配置文件 cd harbor &amp;&amp; cp harbor.yml.tmpl harbor.yml &amp;&amp; vim harbor.yml # 本机hosts必须配置www.harbor.com, 需要访问harbor的机器最好在hosts文件里也配置下 hostname: www.harbor.com http: port: 9001 # 默认用户admin的密码 harbor_admin_password: Harbor12345 # 其他的暂时默认不用改。以后有实际需求了在调整 安装、管理harbor # 安装harbor,安装完会生成对应的docker-compose 对应的管理yml文件 sh install.sh # 以守护进程的方式运行harbor docker-compose up -d # 停止harbor,会删除harbor相关容器,但是不会删除已上传的镜像数据,默认映射路径是/data目录(可以通过修改docker-compose.yml配置文件调整) docker-compose down -v 访问harbor # 浏览器访问harbor,如果在本地hosts配置了www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/304b762ca06a239ef5ad89c69f969d43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbbc6ef7e3b80e9284f078a32587c5a2/" rel="bookmark">
			STM32F4系列探究1——三重ADC扫描连续采样&#43;DMA双缓冲区存储
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、STM32F4的ADC理论知识学习1.基础知识2.扫描模式与连续模式3.单ADC模式下双缓存机制的实现4.三重同步采样模式 二、由定时器触发的单缓冲区模式1.时钟树配置2.ADC部分配置3.定时器部分配置4.中断配置总结5.main.c修改 三、连续模式下的双缓冲区模式1.Cube设置修改2.main.c修改 前言 本文的主要目的是通过学习官方文档，掌握使用STM32CubeMx实现STM32F446ZET6芯片的多重ADC采样与DMA存储的功能，STM32F4系列在使用Cube时均可以参考本文章
一、STM32F4的ADC理论知识学习 1.基础知识 STM32F446系列有3个ADC，即ADC1，ADC2和ADC3，其中ADC1有19个通道，ADC2和ADC3有16个通道。需要注意的ADC的主要参数如下所示：
12-bit,10-bit,8-bit或者6-bit采样拥有扫描模式，连续模式有单重模式，双重模式和三重模式在双重/三重模式中也可开启DMA数据存储可以使用VREF+提供外置的精确参考电压供ADC采样在转换结束或者采样值超出设定阈值时产生中断VREF-必须接到VSSA 下图是关于ADC所使用到的各引脚的电平要求，在设计电路时应注意要对模拟电源电压和数字电源电压进行隔离，对模拟地和数字地进行隔离。一般推荐使用外部芯片产生的高精度参考电压作为VREF+确保ADC采样精度。
三个ADC的每个通道都对应芯片上相应的IO引脚，具体可以参考芯片的datasheet，这里不再赘述。需要注意的是，ADC1的17，18通道分别接到了内部基准源和VBAT/Vsense上，没有接到IO引脚上，其中18通道意味着VBAT/4和温度传感器只能选择一个进行测量。至于内部基准源Vrefint，其有助于提高ADC的测量准确度。该内部基准源的出厂测量值存储在内存的一个地址上，读取后即可作为参考电压来校准ADC的采样值。该地址在手册中有写，不同型号芯片的位置可能不同。
STM32F446的最高采样速率为2.4MSPS，而ADC完成一次采样加转换最少需要3+12=15个周期，这意味着ADCCLK的最高频率为36MHz，而ADCCLK由PCLK2分频而来，因此在配置时钟树时要注意相关参数。
2.扫描模式与连续模式 一个ADC有多个通道，在扫描模式下，ADC依次对选好的通道序列进行采样，并在对通道序列整个采样完一次后可以产生一个中断用于处理采集到的数据。扫描模式又可以分为单个转换模式和连续转换模式，连续转换模式下，当通道序列采样完后，又从头开始重新采样。
在连续采样模式下，采样到的数据如何及时处理是一个大难题，一个方法是利用每次系列采样完毕时产生的中断及时将数据进行处理或者转移走，但该方法费时费力，占用CPU资源，会出现时序配合的问题。一般在连续采样模式下，都是使用DMA将数据存储在一个BUFF里，这个BUFF可以存储很多数据，在数据存满时会触发中断，此时应停止采样，并对数据进行处理。
3.单ADC模式下双缓存机制的实现 那么问题来了，如果我需要一直连续的采样，中间不进行暂停，有没有好的办法呢。STM32提供了双缓存机制，也就是当数据存储满BUFF1后触发中断，通过操作使DMA开始将数据存储到BUFF2，此时就可以对BUFF1进行操作了，BUFF2存满后同理切换到BUFF1并开始处理BUFF2的数据。再单ADC模式下，该机制的实现很简单，但是无法通过Cube进行设置，需要手动添加两部分代码，如下所示：
首先在DMA初始化函数中添加如下代码：
if (HAL_DMAEx_MultiBufferStart((&amp;hadc1)-&gt;DMA_Handle,(uint32_t)&amp;hadc1.Instance-&gt;DR,mem0addr,mem1addr,memsize)!= HAL_OK){ printf("\r\n HAL_DMAEx_MultiBufferStart failed!"); } HAL_ADC_Start_DMA(&amp;hadc1,(uint32_t *)mem0addr, memsize); __HAL_DMA_ENABLE_IT(&amp;hdma_adc1,DMA_IT_TC); //开启传输完成中断	接着是在DMA中断中修改代码令BUFF切换：
void DMA2_Stream0_IRQHandler(void) { if(__HAL_DMA_GET_FLAG(&amp;hdma_adc1,DMA_FLAG_TCIF0_4)!=RESET)//DMA传输完成{ __HAL_DMA_CLEAR_FLAG(&amp;hdma_adc1,DMA_FLAG_TCIF0_4);//清除DMA传输完成中断标志位 if (hdma_adc1.Instance-&gt;CR&amp;(1 &lt;&lt; 19))//buf0已满,正常处理buf1 { DMAFLAG=0; }else //buf1已满,正常处理buf0 { DMAFLAG=1; } } } 只要添加以上两部分代码就可以实现双缓存功能。
在一些简单的功能实现中，并不需要使用连续模式，而是使用定时器以特定的频率进行扫描采样。这时候需要对ADC的触发源进行配置，来确定在什么情况下触发一次ADC采样。此时可以利用ADC采样完毕后的中断进行数据的处理，该方式适用于定时器触发的频率较低时的采样，可以适应绝大部分情况下的采样需求。
4.三重同步采样模式 多重ADC的使用有多种模式，这里只介绍一种模式，三重规则同步模式(triple injected simultaneous mode)，即由ADC1控制ADC2和ADC3，三个ADC同时触发一次转换。
在三重ADC模式下，DMA有3种模式来传输数据，这里只介绍最常用的模式，注意该模式在双重ADC模式下不可使用：
先传输ADC1的一个半字(half-word)，再传输ADC2的一个半字，接着传输ADC3的一个半字，接着传输ADC1的一个半字，如此循环往复。
再三重规则同步模式下，需要注意三个ADC的采样通道序列的长度应是相等的，可以按照下图中的序列进行采样。再每个Conversion后，都会产生三个DMA传输请求，依次传输ADC1，ADC2，ADC3的数据。请注意，这和双重模式下的DMA是不同的，具体请参考手册。
二、由定时器触发的单缓冲区模式 首先实现一个简单的但能满足大多数情况的模式，即由定时器触发ADC进行一定频率的采样，在DMA的目标缓冲区填满后，触发中断进行数据的处理。需要注意的是，如果打开DMA Continuous Requesets，新采样的数据会覆盖原来的缓冲区，因此要及时对数据进行处理，注意时序问题。
1.时钟树配置 首先要关注系统时钟，也就是SYSCLK。这里为了保证时钟的精确性，我使用了25MHz的外接晶振HSE作为时钟源，经过简单的数学计算配置SYSCLK为120MHz，配置PCLK2为60MHz，这意味着ADCCLK的最高频率为30MHz。具体时钟树配置如下所示：
2.ADC部分配置 通过阅读手册可以知道，三重ADC同步采样模式下，由ADC1进行整体的管理与触发。因此，关于多重ADC模式的设置位于ADC1的配置界面中。分别使能ADC1，ADC2，ADC3，根据我自己的需求，每个ADC的规则序列有4个通道，ADC1的设置界面如下所示：
需要注意的是，当不使能DMA Continuous Requests时，DMA在填满缓冲区一次后不会再进行数据的传输，因此一般情况下都应该打开该选项。在ADC1的DMA界面添加DMA，如下图所示，模式设置为Circular：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbbc6ef7e3b80e9284f078a32587c5a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e552745770f36f46d9760089301f20b6/" rel="bookmark">
			tensorflow2中 tensor转为numpy
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 import tensorflow as tf a = tf.constant([[1,2,3],[4,5,6]]) b = a.numpy() print('b = ') print(b) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d73b518785ee6a45ea757c4d79897b7/" rel="bookmark">
			安装多版本cuda
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前提已经安装cuda10.0 10.2, 要安装8.0
安装 修改gCC版本 查看当前版本gcc -v
显示: gcc version 7.5.0 (Ubuntu 7.5.0-3ubuntu1~18.04)查看本机已安装的gcc版本ls /usr/bin/gcc*
显示: /usr/bin/gcc /usr/bin/gcc-ar /usr/bin/gcc-nm /usr/bin/gcc-ranlib /usr/bin/gcc-5 /usr/bin/gcc-ar-5 /usr/bin/gcc-nm-5 /usr/bin/gcc-ranlib-5 /usr/bin/gcc-7 /usr/bin/gcc-ar-7 /usr/bin/gcc-nm-7 /usr/bin/gcc-ranlib-7 切换版本sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-5 40 sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-7 50 sudo update-alternatives --config gcc 显示There are 2 choices for the alternative gcc (providing /usr/bin/gcc). Selection Path Priority Status ------------------------------------------------------------ * 0 /usr/bin/gcc-7 50 auto mode 1 /usr/bin/gcc-5 40 manual mode 2 /usr/bin/gcc-7 50 manual mode 在终端输入对应的编号 1 回车,成功 安装cuda 参考文献
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d73b518785ee6a45ea757c4d79897b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90bc7e24c07a0dadbf7de3b41e7c5cce/" rel="bookmark">
			Java通过Http请求服务器，返回EXCEL/TXT预览页面出现中文乱码解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 遇到的问题是： 通过java请求服务器，在文件中心拿到文件EXCEL或者txt，返回到前端直接预览查看内容出现中文乱码
例如：
public void viewFile(){ HttpServletResponse response = ((ServletRequestAttributes)RequestContexHolder.currentRequestAttributes()).getResponse(); byte[] bytes = this.downloadFromFC(); try(InputStream inputStream = new ByteArrayInputStream(bytes)){ ExcelToHtmlParams params = new ExcelToHtmlParams(WorkBookFactory.create(inputStream)); response.getOutputStream().write(ExcelXorHtmlUtil.excelToHtml(params).getBytes()); response.setContentType("text/html"); }catch(Exception e){ } } 解决的方法： ①更改编码为UTF-8
②注意代码编码顺序（极易忽略的问题，先声明编码，再写流）
public void viewFile(){ HttpServletResponse response = ((ServletRequestAttributes)RequestContexHolder.currentRequestAttributes()).getResponse(); byte[] bytes = this.downloadFromFC(); try(InputStream inputStream = new ByteArrayInputStream(bytes)){ response.setCharacterEncoding("UTF-8"); response.setContentType("text/html;charset=UTF-8"); ExcelToHtmlParams params = new ExcelToHtmlParams(WorkBookFactory.create(inputStream)); response.getOutputStream().write(ExcelXorHtmlUtil.excelToHtml(params).getBytes()); }catch(Exception e){ } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c0d3d2ebe0ce7f47380af1c25bb09e0/" rel="bookmark">
			npm安装时加 --save和不加的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.加 npm install xxx --save 会将该依赖存入到package.json 里的dependcies里 2.不加 npm install xxx 则不会将该依赖存入到package.json 里的dependcies里 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae1fc0a81f545432ac8cba76e47b62c7/" rel="bookmark">
			idea骚操作系列(1) 连接远程docker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		idea连接远程docker 安装docker并配置启用远程连接idea连接远程docker配置docker连接，连接远程docker 场景1、2：发布应用镜像到远程服务器、私有仓库新建spring boot项目(略)配置maven setting.xml配置pom.xml文件（详细配置见源代码）配置dockerfile(配置文件在项目根目录下)发布应用镜像到远程服务器、私有仓库命令行方式启动容器 场景3: 直接在本地运行应用容器添加启动配置启动应用 记录idea连接远程docker发布应用镜像到docker服务器、发布应用镜像到私有仓库及直接运行应用容器3个场景 与本文相关代码的github地址
安装docker并配置启用远程连接 docker专题
idea连接远程docker 配置docker连接，连接远程docker idea新建Docker Connection
idea菜单操作: 选择View - &gt; Tool Windows -&gt; Services（操作结果是任务栏会出现Services窗口）
idea任务栏操作: 选择Services窗口-&gt; + -&gt; Docker Connection (操作 结果是弹出docker配置界面)配置Docker Connection
Name : 随便写(我这里暂定Remote Docker)
Docker daemon -&gt; TCP socket
Engine API URL: tcp:// 外 网 i p : {外网ip}: 外网ip:{docker开放的远程连接端口}
点击OK就可以在Services窗口看到远程主机上的docker信息了 场景1、2：发布应用镜像到远程服务器、私有仓库 执行过程：
本地打包生成可执行jar使用远程docker服务构建镜像并上传到docker服务器上给镜像打上标签推送到私仓 新建spring boot项目(略) 配置maven setting.xml 特别强调，并不是所有的仓库都要配置认证信息的，利用docker registry搭建的镜像仓库不需要认证，也就是不用配置认证信息
&lt;servers&gt; &lt;server&gt; &lt;id&gt;harbor&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;Harbor12345&lt;/password&gt; &lt;/server&gt; &lt;/servers&gt; 配置pom.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae1fc0a81f545432ac8cba76e47b62c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4464334cae674aaacc0dcc57f4564ff9/" rel="bookmark">
			如何从零自学成为前端工程师，怎么学习？怎么选老师？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自学笔记JavaScript：https://blog.csdn.net/weixin_55181759/article/details/117462530
大家好！首先写一下前情提要，本人的专业和计算机无关，但理科背景出身，大学辅修人力资源管理，可能是理科背景对我自学有一定助力。所以在已经毕业三年的时候决定转行利用下班的时间开始看视频学历前端开发，学了半年多。
我的自学之路可以说是走了很多弯路，其中一大原因就是看理论的时候非常多，但是动手去敲代码的时候非常少，这样其实会边学边忘，基本学习顺序css→html→c3&amp;h5→原生js&amp;js高阶语法→jq→ajax→vue(包括element ui和echarts) 具体学习总结有时间会陆续上传，有时间的经历的同学可以再学一些git等等工具。
总结一下自学的视频和老师我都是选择的哪些，这些视频非常值得反复观看
学习顺序视频地址备注css与htmlhttps://www.bilibili.com/video/BV14J4114768?from=search&amp;seid=18160343066695249717最好全都看完JavaScripthttps://www.bilibili.com/video/BV1Sy4y1C7ha?from=search&amp;seid=6937735055528513780可以看到358节，后面jQuery部分 选学JavaScript高级https://www.bilibili.com/video/BV1Kt411w7MP可以看到换老师的位置，后面的部分 选学前后端交互https://www.bilibili.com/video/BV1j5411K7EH这部分学的时候我也非常懵如果有更好的视频欢迎推荐给我，在项目中实践会更清晰JavaScript高级延展https://www.bilibili.com/video/BV1uK411H7on?p=1选学 JavaScript高级讲的es6语法并不全面，看完这个视频js面试题都可以理解VUE全家桶https://www.bilibili.com/video/BV1KJ411U7ML?from=search&amp;seid=3878287040039310208Vue2.0与Vue3.0&amp;Vue全家桶二选一Vue2.0与Vue3.0https://www.bilibili.com/video/BV1Zy4y1K7SH?from=search&amp;seid=16946268743532201801这个与上面全家桶选择一个就行,因为我后期看到尚硅谷这个视频觉得老师讲的非常好,因为看这个视频我有基础,对于初级看完也欢迎反馈给我效果VUE选修https://www.bilibili.com/video/BV15741177Eh?from=search&amp;seid=3878287040039310208王红元老师老师原理讲的挺好的，VUE全家桶部分不理解的地方基本就可以理解了，选学 首先我最开始买的视频在某宝"黑马程序员的录播课"，一直看到jq结束是非常不错的，主讲老师叫pink老师，上课激情满满讲的非常非常好，他的课程我发现在bilibili上也可以看(视频地址：https://www.bilibili.com/video/BV14J4114768?p=1)， 后续"黑马程序员的录播课"换老师了我觉得更多是照本宣科，一直读PPT，所以很多都不理解为什么，所以我都记不住也区分不开，然后我再所有都看完之后再bilibili上又看了李南江老师讲的jq和ajax，和王红元老师讲的vue都非常不错。
所以大家可以根据需要去bilibili选择，主推几位老师－黑马的pink老师、王红元老师、李南江老师、尚硅谷的张天禹老师。
他们的视频课我也是只根据我的需求听了一部分，具体是否适合你还需要判断你的基础，你自己的学习习惯，像王红元老师讲的vue就非常快和细，因为我当时已经把黑马的录播课全看完了，所以再看他的课觉得豁然开朗，原理非常透彻，但是如果完全没有基础可能会懵圈，所以也建议大家在某个老师的课反复看了两遍还不理解就不要死磕了、不要死磕、不要死磕，换个别的视频再看，因为有的课程偏向于基础，有的课程偏向于原理和应用，说白了大多数视频课都差不多但是学习者本身所处的段位不一样，你就是看不懂，大家一定别和自己较劲哈~
(ps：我就是较劲浪费了很多时间，比如黑马的录播课我看不懂就不应该继续浪费时间了，后悔啊！)
以上就是我的总结，大家见仁见智，祝各位在前端开发的路上越走越好，也请麻烦留个赞给我，感谢鸭~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6a38623a34f550d90ba5e3d7ec24c7a/" rel="bookmark">
			Leetcode No.62 不同路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、题目描述 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
问总共有多少条不同的路径？
示例 1：
输入：m = 3, n = 7
输出：28
示例 2：
输入：m = 3, n = 2
输出：3
解释：
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -&gt; 向下 -&gt; 向下
2. 向下 -&gt; 向下 -&gt; 向右
3. 向下 -&gt; 向右 -&gt; 向下
示例 3：
输入：m = 7, n = 3
输出：28
示例 4：
输入：m = 3, n = 3
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6a38623a34f550d90ba5e3d7ec24c7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bef827ed211973aa84eb3167e7973d1/" rel="bookmark">
			Linux驱动之 自动创建设备节点class_create、device_create
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux驱动之自动创建设备文件节点学习记录：
Linux为系统上的每个设备都创建一种称为节点的特殊文件。与设备的所有通信都通过设备节点完成。
每个节点都有唯一的数值对供Linux内核标识它。
数值对包括一个主设备号和一个次设备号。类的设备被划分到同样的主设备号下。次设备号用于标识主设备组下的某个特定设备。
上节课利用了mknod命令手动创建设备节点，
实际上Linux内核为我们提供了一组函数，可以用来在模块加载的时候自动在/dev目录下创建相应设备节点，并在卸载模块时删除该节点。
内核中定义了struct class结构体，一个struct class结构体类型变量对应一个类，内核同时提供了class_create()函数，可以用它来创建一个类，这个类存放于sysfs下面，创建了这个类，再调用device_create()函数来在/dev目录下创建相应的设备节点。
这样，加载模块的时候，用户空间中的udev会自动响应device_create(…)函数，去/sysfs下寻找对应的类从而创建设备节点。
数据结构定义： #define NEWCHRDEV_CNT	1	/* 设备号个数 */ #define NEWCHRDEV_NAME	"hello"	/* 名字 */ /* newchrdev设备结构体 */ struct newchr_dev{ dev_t devid;	/* 设备号 */ struct cdev cdev;	/* cdev */ struct class *class;	/* 类 */ struct device *device;	/* 设备 */ int major;	/* 主设备号	*/ int minor;	/* 次设备号 */ }; struct newchr_dev chr_hello;	/* 设备chr_hello */ class_create /* * @description	: 创建一个class类型的对象 * @param - owner	: THIS_MODULE * @param - name	: 类名字 * @return : 成功,返回struct class的指针;其他 失败 */ struct class *class_create(struct module *owner, const char *name) 定义一个struct class的指针变量接受返回值，然后通过IS_ERR()判断是否失败，如果成功这个宏返回0，失败返回非0值（可以通过PTR_ERR()来获得失败返回的错误码）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7bef827ed211973aa84eb3167e7973d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ca2167ed162f1e5616abdede308af2d/" rel="bookmark">
			《Python程序设计》题目集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python刷题 题目:第4章-5 求e的近似值 (15 分)一、代码二、心得题目:第4章-6 输出前 n 个Fibonacci数 (15 分)一、代码二、心得题目：第4章-7 统计学生平均成绩与及格人数 (15 分)一、代码二、心得题目：第4章-8 求分数序列前N项和 (15 分)一、代码二、心得 题目:第4章-5 求e的近似值 (15 分) 自然常数 e 可以用级数 1+1/1!+1/2!+⋯+1/n!+⋯ 来近似计算。本题要求对给定的非负整数 n，求该级数的前 n+1 项和。
输入格式:
输入第一行中给出非负整数 n（≤1000）。
输出格式:
在一行中输出部分和的值，保留小数点后八位。
输入样例:
10
输出样例:
2.71828180
一、代码 n=int(input()) sum=1 mu=1 for i in range(1,n+1): mu*=i; sum += 1 / mu; print("{:.8f}".format(sum)) 注意：0 和 3 这两个点是通不过的，不用去管
二、心得 题目:第4章-6 输出前 n 个Fibonacci数 (15 分) 本题要求编写程序，输出菲波那契（Fibonacci）数列的前N项，每行输出5个，题目保证输出结果在长整型范围内。Fibonacci数列就是满足任一项数字是前两项的和（最开始两项均定义为1）的数列，例如：1，1，2，3，5，8，13，…。
输入格式:
输入在一行中给出一个整数N（1≤N≤46）。
输出格式:
输出前N个Fibonacci数，每个数占11位，每行输出5个。如果最后一行输出的个数不到5个，也需要换行。
如果N小于1，则输出"Invalid."
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ca2167ed162f1e5616abdede308af2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d117476c7c53b76ef410cfa7b384e32/" rel="bookmark">
			pygame使用多种方法让背景和人物运动起来
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在上一篇文章pygame的基础知识详解（主窗口创建、图像绘制、时钟对象和事件响应等知识点），请惠存（https://blog.csdn.net/dhjabc_1/article/details/116081725）的基础上，继续深入研究如何让背景和人物动起来。
文章目录 一、背景运动（一）让背景循环运动 二、人物运动（一）预处理人物图片1、一个大图片分散成多个小图片2、多个小图片合并成一个大图片 （二）让人物在窗口动起来1、使用大图显示运动效果2、使用多个小图显示运动效果 三、进一步动起来（一）背景和人物都运动起来（二）人物真正动起来 一、背景运动 （一）让背景循环运动 使用代码：
import pygame import sys # 全局初始化 pygame.init() # 设置窗口的分辨率和标题 resolution = width,height = 480,700 #设置窗口大小和标题 windowSurface = pygame.display.set_mode(resolution) #设置分辨率并得到全局的【绘图表面】 pygame.display.set_caption("风景如画")#设置标题 #加载背景图，返回的表面可以用于绘制其它对象于其上 bgSurface = pygame.image.load("temp.jpg").convert() bgSurface1 = pygame.transform.flip(bgSurface, True, False) frameRect = bgSurface.get_rect() clock = pygame.time.Clock() i = 0 while True: # 将背景图像绘制于窗口表面windowSurface for event in pygame.event.get(): # 处理退出事件 if event.type == pygame.QUIT: pygame.quit() sys.exit() windowSurface.blit(bgSurface1, (-i, 0)) windowSurface.blit(bgSurface, (frameRect.width-i, 0)) i = (i+1) % frameRect.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d117476c7c53b76ef410cfa7b384e32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cc1c931b4f4eda2910d19c0e773affd/" rel="bookmark">
			线性表（顺序表）——顺序表的定义、基本操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、顺序表的定义：（静态、动态分配内存）
#include&lt;iostream&gt; using namespace std; /** 静态分配存储空间 */ //#define MaxSize 10//定义最大存储空间大小 // //typedef struct //{ // int data[MaxSize]; // int length;//定义线性表中当前的长度 //}SqList;//顺序表类型的定义（相当于一个新的数据类型） 基本操作——初始化线性表 //void InitList(SqList &amp;L) //{ // for(int i=0;i&lt;MaxSize;i++) // L.data[i]=0;//将所有数据元素设置为默认值 // /**如果没有这个循环，初始化表的数据值可能不为默认值， // 这是由于内存可能有遗留的“垃圾数据”。 // 这个for循环可要可不要，因为在真正的数据操作中，要处理的数据元素 // 会覆盖掉里边的所谓的“垃圾数据” // */ // L.length=0;//顺序表的初始长度为0 //} /** 动态分配存储空间 */ #define InitSize 10//默认最大长度 typedef struct { int *data;//指示动态分配数组的指针 int Maxsize;//顺序表的最大容量 int length;//顺序表的当前长度 }SeqList; //基本操作——初始化表 void InitSqList(SeqList &amp;L) { //用malloc函数动态申请连续的存储空间 L.data=(int *)malloc(sizeof(int)*InitSize); L.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cc1c931b4f4eda2910d19c0e773affd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/249213a02046e624dd4b5b954c6577c9/" rel="bookmark">
			比较保险、方便、彻底的卸载ambari方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		比较保险、方便的卸载ambari 目录
一、在ambari页面停止所有服务，如果不嫌烦的话，可以直接在页面右边的action按钮里将服务依次删除
二、重点：yum卸载
三、清理残留文件夹和文件
四、如果需要，删除相关用户如hdfs等。此处略
一、在ambari页面停止所有服务，如果不嫌烦的话，可以直接在页面右边的action按钮里将服务依次删除 二、重点：yum卸载 因为amabri中的大数据组件使用的是hdp统一进行安装的，并且需要配置yum源通过yum安装。因此我们使用命令:
yum list installed 我们会得到例如上图这样的效果：软件名称——版本号——安装来源（即@名称）
因为我之前操作的时候，已经将ambari卸载过了。如果没有卸载ambari的话，这里会显示@HDP-3.1-repo-1所安装的组件，包括zookeeper、spark等等。
然后bash命令可以通过单排数字键1左边的“ ` ~” 这个键的``进行层次嵌套，如：语句二 `语句一`。语句一先执行，执行完后会将结果传递给语句二中相应位置，那么我们可以使用命令：
yum remove `yum list installed|grep @HDP-3.1-repo-1` 这样只需要一句代码即可将所有由HDP安装的组件一下子卸载（前提是确定好有没有其他单独通过HDP安装的东西）。
注：除了 语句二 `语句一` 这种方式，还可以通过
yum list installed|grep @HDP-3.1-repo-1|xargs yum remove 来实现，也就是xargs命令进行参数传递。
手动卸载ambari-agent和ambari-server。
三、清理残留文件夹和文件 yum卸载完之后，还要清理剩下的文件夹以及部分文件。
清理相关文件夹：（！！！注：强烈建议先用下面命令中的find命令部分，先查看有没有不是ambari安装的东西，因为*模糊查询，生产机器不确定的话，先查看下有没有名字相近但是毫不相关的东西！！！）
rm -rf `find / -type d -iname smartsense*` rm -rf `find / -type d -iname hst*` rm -rf `find / -type d -iname spark2*` rm -rf `find / -type d -iname zookeeper*` rm -rf `find / -type d -iname hbase*` rm -rf `find / -type d -iname kafka*` rm -rf `find / -type d -iname hive*` rm -rf `find / -type d -iname yarn*` rm -rf `find / -type d -iname hadoop*` rm -rf `find / -type d -iname spark*` rm -rf `find / -type d -iname zeppelin*` rm -rf `find / -type d -iname ambari*` rm -rf `find / -type d -iname tez*` 注：-name和-iname的区别是，-iname忽略名称大小写
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/249213a02046e624dd4b5b954c6577c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe21a0e30ae1384794b04010d7116b5e/" rel="bookmark">
			pygame的基础知识详解（主窗口创建、图像绘制、时钟对象和事件响应等知识点），请惠存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		各位好，很久没更新博客了，最近较为深入研究pygame库，有些心得体会，想分享给各位，准备做成一个系列知识。欢迎各位查阅。
这篇作为一个基础知识的宣贯，想和各位深入分享一下pygame的基础知识，深入理解函数的使用。
一、pygame介绍 pygame是一个非常非常火的游戏库，那么作为游戏，我相信大家第一印象就是包括：游戏的主界面、游戏里面酷炫的动态效果。
二、pygame库的安装 这个相信大家都懂了，就不深入介绍了。
pip install pygame 如果下载很慢，可以搜索一下国内的pip源下载。
三、pygame库的导入 在python代码中，需要使用到该库时，需要进行导入。
import pygame 四、pygame库的初始化和退出 要使用 pygame 提供的所有功能之前，需要调用 init 方法，在游戏结束前需要调用一下 quit 方法
（一）pygame.init() 导入并初始化所有 pygame 模块，使用其他模块之前，必须先调用 init 方法
（二）pygame.quit() 卸载所有 pygame 模块，在游戏结束之前调用！
五、pygame界面的坐标系 pygame 专门提供了一个类 pygame.Rect 用于描述 矩形区域Rect(x, y, width, height) -&gt; Rect。
所有可见的元素 都是以 矩形区域 来描述位置的，要描述一个矩形区域有四个要素：原点 在 左上角 (0, 0)，其中：x 轴水平方向向右，逐渐增加；y 轴 垂直方向向 下，逐渐增加。
示例代码如下：
import pygame pygame.init() myrect = pygame.Rect(300, 500, 200, 256) print("myrect坐标原点：%d %d 大小：%d %d" % (myrect.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe21a0e30ae1384794b04010d7116b5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4c774d7678b87c9b6e15fe378cb6d55/" rel="bookmark">
			利用TreeSet实现Comparable、Comparator的两种排序方式（自然排序、定制排序）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在看Javase中集合的相关内容，其中TreeSet作为Set接口的实现类之一，采用的存储结构是：红黑树。
要求为：
1）向TreeSet中添加的属性，要求是相同类的对象；
2）在每次通过add()向树中插入元素时，需要先通过 比较（comparato()或者compare()），确保树种不插入相同的元素；这里与Set接口的其他实现类不同，因为Set存储的数据：无序、不可重复，所以在调用add()进行插入操作时，是一定要进行大小的比较的，只不过Set接口的其他两个实现类HashSet、LinkedHashSet使用的都是：要插入的对象对应的类中的重写后的equals()
3）注意：在对插入元素进行比较大小这个方面，这里（TreeSet）与Set接口的其他实现类不同，因为Set存储的数据：无序、不可重复，所以在调用add()进行插入操作时，是一定要进行大小的比较的，只不过Set接口的其他两个实现类HashSet、LinkedHashSet使用的都是：要插入的对象对应的类中的重写后的equals()
题目： 创建5个employee的对象，并把这些对象放入treeset集合中
* 分别按照以下两种方式对接中的元素进行排序：
1）使employee实现comparable接口，并按照排序
（先创建treeset，并且使用add（）加入元素，另外再写一个comparato()即可，因为treeset中，本质上是使用comparato()去比较的）
2）创建treeset时传入com对象（用带有形参的构造器），按生日日期的先后顺序，进行排序
代码实现： 1）Employee类：
public class Employee implements Comparable{ private String name; private int age; private MyDate birthday; //构造器 public Employee(String name, int age, MyDate birthday) { super(); this.name = name; this.age = age; this.birthday = birthday; } public Employee() { super(); } //get、set方法 public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4c774d7678b87c9b6e15fe378cb6d55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/921f9a12d0323f77950e6297a78bfaea/" rel="bookmark">
			集成学习——Boosting提升方法2之前向分步算法、提升树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前向分布算法 Adaboost每次学习单一分类器以及单一分类器的参数(权重)。Adaboost算法可以解释为：模型为加法模型、损失函数为指数函数、学习算法为 前向分布算法的二分类 学习算法。
前向分布算法是集成学习的重要框架，以至于既可以解决分类问题，也可以解决回归问题。
首先来看加法模型： f ( x ) = ∑ m = 1 M β m b ( x ; γ m ) f(x)=\sum_{m=1}^{M} \beta_{m} b\left(x ; \gamma_{m}\right) f(x)=m=1∑M​βm​b(x;γm​)
这个形式感觉和AdaBoost的线性组合很像，没错，AdaBoost是前向分布加法算法的特例。
上面的公式中， b ( x ; γ m ) b\left(x ; \gamma_{m}\right) b(x;γm​)为基本分类器， γ m \gamma_{m} γm​为基本分类器的参数， β m \beta_m βm​为基本分类器的权重。
在给定训练数据以及损失函数 L ( y , f ( x ) ) L(y, f(x)) L(y,f(x))的条件下，学习加法模型 f ( x ) f(x) f(x)成为经验风险极小化即损失函数极小化问题：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/921f9a12d0323f77950e6297a78bfaea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9c7de719ec5cf6a4971b99742c79b76/" rel="bookmark">
			各种排序算法的整合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相关代码：
#include&lt;iostream&gt; using namespace std; //内部排序 插、交、选、归、基 /** 一、插入排序 1）直接插入排序，找到插入位置，插入位置的元素往后移动 2）折半插入排序，是对寻找插入位置的时间复杂度进行的优化，用到分治的思想 相应的每一趟中比较的次数会减少，每趟比较的次数为O(log2n); 3）希尔排序（缩小增量排序）,先追求表中的元素部分有序，在逐渐逼近全局有序 */ /** 1、直接插入排序 */ void InsertSort(int a[],int n) { int i,j,temp; for(i=1;i&lt;n;i++) { if(a[i]&lt;a[i-1]) { temp=a[i]; //插入元素之前都是已经排好序的从小到大的元素， //只要是比插入元素大的都向后移 for(j=i-1;j&gt;=0&amp;&amp;a[j]&gt;temp;j--) { a[j+1]=a[j]; } temp=a[j+1]; } } } /** 折半插入排序 */ void BinaryInsertSort(int a[],int n) { int i,j,left,right,mid,temp; for(i=1;i&lt;n;i++) { //待插入元素temp temp=a[i]; left=0; right=i-1; //我们的任务就是找到比待插入元素小的元素 while(left&lt;=right) { mid=(left+right)&gt;&gt;1; //当划分元素比待插入元素大，查找左半子表 if(a[mid]&gt;temp) right=mid-1; else left=mid+1; } //跳出循环时left&gt;right,我们要插入的位置就是left位置（或者说是right后边的一个元素位置） //但要注意的是：往后移动元素时，要从后边开始往后移动，防止元素被覆盖掉 for(j=i-1;j&gt;=left;j--)//注意i的位置是待插入元素的位置 { a[j+1]=a[j]; } //跳出循环时j=left-1; a[j+1]=temp; } } /** 希尔排序，对间隔为d的元素进行直接插入排序，d在不断的缩小， init:d=n/2--&gt;d=1,每次d/=2; 不稳定 */ void ShellSort(int a[],int n) { int i,j,temp,d; for(d=n/2;d&gt;=1;d/=2) { for(i=d;i&lt;n;i++) { if(a[i]&lt;a[i-d]) { temp=a[i]; for(j=i-d;j&gt;=0&amp;&amp;a[j]&gt;temp;j-=d) { a[j+d]=a[j]; } a[j+d]=temp; } } } } /** 二、交换排序 1）冒泡排序 2）快速排序 */ //冒泡排序 void BubbleSort(int a[],int n) { int i,j; //从前往后冒泡 for(i=0;i&lt;n-1;i++)//需要进行n-1趟冒泡 { bool flag=false;//判断是否发生交换 for(j=0;j&lt;n-i;j++) { if(a[j]&gt;a[j+1]) swap(a[j],a[j+1]); flag=true; } if(flag==false) return; } //从后往前冒泡 // for(i=0;i&lt;n-1;i++) // { // bool flag=false; // for(j=n-1;j&gt;i;j--)//j&gt;i而且不能等于i，否则下边a[j-1]会出现越界 // { // if(a[j]&lt;a[j-1]) // swap(a[j],a[j-1]); // flag=true; // } // if(flag==false) // return; // } } /** 快速排序 */ int Partition(int a[],int left,int right) { int temp=a[left]; while(left&lt;right) { while(a[right]&gt;=temp&amp;&amp;left&lt;right) right--; a[left]=a[right];//将比枢轴小的元素移动到左边 while(a[left]&lt;=temp&amp;&amp;left&lt;right) left++; a[right]=a[left];//将比枢轴大的元素移动到右边 } a[left]=temp; return left; } void QuickSort(int a[],int left,int right) { int pivotpos=Partition(a,left,right); if(left&lt;right) { QuickSort(a,left,pivotpos-1); QuickSort(a,pivotpos+1,right); return; } } //整合后的快速排序 //void QuickSort(int a[],int n,int left,int right) //{ // int i,j,temp;//temp为枢轴（基准） // i=left; // j=right; // temp=a[left]; // if(left&gt;right) // return; // while(i!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9c7de719ec5cf6a4971b99742c79b76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d3b1407d7c3b8c365d125655abe16cb/" rel="bookmark">
			前端 Gitlab 自动部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端 Gitlab 自动部署 根据自己的系统，下载对应二进制安装文件 # Linux x86-64 sudo curl -L --output /usr/local/bin/gitlab-runner "https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-linux-amd64" # Linux x86 sudo curl -L --output /usr/local/bin/gitlab-runner "https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-linux-386" # Linux arm sudo curl -L --output /usr/local/bin/gitlab-runner "https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-linux-arm" # Linux arm64 sudo curl -L --output /usr/local/bin/gitlab-runner "https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-linux-arm64" # Linux s390x sudo curl -L --output /usr/local/bin/gitlab-runner "https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-linux-s390x" 授予执行权限 sudo chmod +x /usr/local/bin/gitlab-runner 创建一个 Gitlab CI 账户 sudo useradd --comment 'GitLab Runner' --create-home gitlab-runner --shell /bin/bash 安装、运行 # 安装 sudo gitlab-runner install --user=gitlab-runner --working-directory=/home/gitlab-runner # 启动 sudo gitlab-runner start 此时, gitlab-runner 已经安装完毕了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d3b1407d7c3b8c365d125655abe16cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0af9d03b346f7f53808762941ac793d/" rel="bookmark">
			D. Cut(质因子分解，倍增)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		D. Cut 题意：给出一个长度为n的序列，和q个询问，对于每个询问，求出最少分成多少个连续的子区间，使每个子区间的 l c m lcm lcm等于子区间各个数的乘积。
思路：质因子分解+倍增思想。
预处理：利用质因子分解来找当前元素能够向后跳到的最远的位置（满足从开始位置到结束位置中的每个元素都互质）
利用倍增的思想，来加速跳的过程。
对于每个询问，只要从没有跳到边界，就一直往下跳，直到位置大于右边界，跳的次数加一就时答案。
预处理： d p [ i ] [ 0 ] dp[i][0] dp[i][0]表示区间 [ i ， d p [ i ] [ 0 ] ] [i，dp[i][0]] [i，dp[i][0]]中所有的元素都是互质的。
倍增： d p [ i ] [ j ] dp[i][j] dp[i][j]表示从 i i i开始跳 2 j 2^j 2j次，跳到的位置(注意每次跳的长度不一定是相同的)，也就是分成了 2 j 2^j 2j个区间。
#include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int N = 1e5+10; int s[N], ne[N], dp[N][20]; unordered_map&lt;int, int&gt; p; int main() { #ifndef ONLINE_JUDGE freopen("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0af9d03b346f7f53808762941ac793d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3779b9fa706c7660b033f428934b558e/" rel="bookmark">
			STM32学习记录——74HC595四位数码管显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数模管作为STM32的一个重要外设，由于其成本低、稳定，被用于许多场景中。本篇文章来介绍下四位数码管的使用方法。
数码管显示 一、数码管的分类二、74HC595芯片（串入并出）三、原理图四、代码主要操作五、代码分析1.void HC595_GPIO_Configuration(void);2.void HC595_Send_Byte(unsigned char byte)3.void HC595_Send_Data(unsigned char num, unsigned char show_bit);4.void display(unsigned int n) 总结 一、数码管的分类 数码管分为共阴数码管和共阳数码管，共阴和共阳的区别就在于，输出1还是输出0的时候，能点亮数码管的一小段。
在这篇文章中，所使用的是由两片74HC595芯片控制的4位数码管
挂几张图
二、74HC595芯片（串入并出） 该芯片是一个8位串行输入、并行输出的位移缓存器。（缓存器在控制数码管中具有重要作用）
Q0~Q7：并行输出
Q7’：串行输出
SH_CP：移位寄存器时钟输入
ST_CP：存储寄存器时钟输入
DS：串行输入
使用两片74HC595芯片，第一片74HC595芯片的Q7口，也就是串行输出口可以向下一片的74HC595芯片的串行输入口输入数据。
第二片74HC595芯片是用于控制数码管输出显示，而第一片74HC595芯片只使用了QA、QB、QC、QD四个管脚来储存信息。
三、原理图 对于4位的数码管模块，接线选择为
VCC------------&gt;供电 DIO------------&gt;PB13 RCLK------------&gt;PB12 当八个数据完全传入缓冲区，此时拉高RCLK，八位数据便可以一次性全部输出。 SCLK------------&gt;PB15 控制串入的时钟信号线，当有一个上升沿，便传入一个数据。 GND------------&gt;接地 本文主要使用PB13 、PB12 、PB15 来控制数码管的显示数据。
以下使用数码管也是以这三个端口进行分析。
四、代码主要操作 主要是由以下四个函数构成：
void HC595_GPIO_Configuration(void); void HC595_Send_Data(unsigned char num, unsigned char show_bit); void HC595_Send_Byte(unsigned char byte)； void display(unsigned int n); 五、代码分析 1.void HC595_GPIO_Configuration(void); 该函数主要是使能接在4位数码管的主要GPIO口，如上文提到的一般：
/************************ VCC------------&gt;供电 DIO------------&gt;PB13 RCLK------------&gt;PB12 SCLK------------&gt;PB15 GND------------&gt;接地 **************************/ unsigned int num[] = {0xc0, 0xf9, 0xa4, 0xb0, 0x99, 0x92, 0x82, 0xf8, 0x80, 0x90, 0xff, 0x00}; //创建一个数组，0-9所对应的十六进制数 void HC595_GPIO_Configuration(void) { GPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); GPIO_InitStructure.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3779b9fa706c7660b033f428934b558e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7cca91fd2ad8e62b9ec361348699c61/" rel="bookmark">
			数据库笔记：码的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是码 这个题的第二问
存在这些函数依赖，如果我们能找出一组属性，他们能决定其他属性，那么这组属性就是码
答案是：ACE DCE BCE
这样看来 A B C D E F都是主属性（没有其他不能作为决定因素的属性出现），所以他就是3NF
同时第三问，函数关系中，决定因数A, BC, DE都不包含码，所以也就不是BCNF
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2704fbf732898dc1a0afe7e17b08268/" rel="bookmark">
			MySql初始化问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[lv@hadoop102 conf]$ schematool -initSchema -dbType mysql -verbose Exception in thread "main" java.lang.RuntimeException: com.ctc.wstx.exc.WstxParsingException: Illegal processing instruction target ("xml"); xml (case insensitive) is reserved by the specs. at [row,col,system-id]: [2,5,"file:/opt/module/hive/conf/hive-site.xml"] at org.apache.hadoop.conf.Configuration.loadResource(Configuration.java:3024) at org.apache.hadoop.conf.Configuration.loadResources(Configuration.java:2973) at org.apache.hadoop.conf.Configuration.getProps(Configuration.java:2848) at org.apache.hadoop.conf.Configuration.get(Configuration.java:1460) at org.apache.hadoop.hive.conf.HiveConf.getVar(HiveConf.java:4996) at org.apache.hadoop.hive.conf.HiveConf.getVar(HiveConf.java:5069) at org.apache.hadoop.hive.conf.HiveConf.initialize(HiveConf.java:5156) at org.apache.hadoop.hive.conf.HiveConf.&lt;init&gt;(HiveConf.java:5104) at org.apache.hive.beeline.HiveSchemaTool.&lt;init&gt;(HiveSchemaTool.java:96) at org.apache.hive.beeline.HiveSchemaTool.main(HiveSchemaTool.java:1473) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.apache.hadoop.util.RunJar.run(RunJar.java:318) at org.apache.hadoop.util.RunJar.main(RunJar.java:232) Caused by: com.ctc.wstx.exc.WstxParsingException: Illegal processing instruction target ("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2704fbf732898dc1a0afe7e17b08268/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5f6f087155ea05ccddf528e9651d549/" rel="bookmark">
			Qt 按钮控件虚线框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 虚线框复现来源 点选按钮，使用 Tab 键在界面中切换, 会发现一旦切换到按钮上会附带一个虚线框，如下图所示 解决措施 1，在样式表中添加如下一行代码即可解决空间中获取焦点出现虚线框的问题。 /*remove all QWidget's focus border 移除虚线框 */ QWidget:focus{outline: none;} 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d02d09dbe75b158c84e893f70325b118/" rel="bookmark">
			codeforces1516D. Cut（质因数分解&#43;倍增算法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		codeforces1516D. Cut（质因数分解+倍增算法） 因为C没写出来，所以就跑过来写D(lll￢ω￢)
题意：给定一个长度为n的整数序列a，有m个询问。每次询问一个区间【l，r】，问能最少能将该区间分成几个完美的子区间，
定义：
1、子区间需要连续
2、完美子区间表示该区间内所有数的乘积为其所有数的最小公倍数
思路：
完美序列的要求其实就是该区间内的所有数要互质。
怎么分割才是最合理的呢？
必然是从前往后，把能互质的都放在一个区间，一旦不能互质，就另开一个区间去存就好了，这样子必然是满足最小。
但是问题在于m的数目很大，每次都去遍历必然会超时，而且还要判断互质，那必然是不可能完成的。
所以，我们就要先对数据进行处理，得到对数据得到一个记忆化。
怎么处理？得到什么？
我这里定义一个mx数组，定义为，从i位置起，往后所能保证得到的最长的完美区间的位置，也就是mx[i] = j,表示i位置起，到j位置位置，其中的数都互质。
然后通过倍增算法，来跑一遍就可以了。
那么怎么得到mx数组呢？以及判断区间互质呢？
我们不难想到要用双指针判断长度以及质因数分解。
简单说一下原理：
互质，那么必然所有数的质因子不能存在有一样。分解质因子的就可以更新出这个质因子的位置i。然后，如果有前面的数出现了这个质因子，那么就不能超过这个质因子的位置i，因为超过就会出现重复质因子，所以要取出这个数所有的质因子的最小位置，然后mii作为双指针的右边界，来保证右边的数也满足条件的综合最小值，可以保证不互质。
然后就是跑一下倍增就好了。
#include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #include&lt;set&gt; #include&lt;stack&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;unordered_map&gt; #include&lt;stdio.h&gt; using namespace std; const int MAXN = 3e5 + 7; typedef long long ll; #define INFll 9223372036854775807 #define INF 0x3f3f3f3f #define dbg(x) cout &lt;&lt; #x &lt;&lt; " = " &lt;&lt; x &lt;&lt; endl; #define lowbit(n) (n&amp;-n) #define IOS ios::sync_with_stdio(0); cin.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d02d09dbe75b158c84e893f70325b118/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a241e2cd977b2fa1eaaa19a20a7f6d86/" rel="bookmark">
			电脑突然经常死机？（ubuntu系统如何检查原因）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 台式机(我的是GPU服务器)突然发现隔3-5天就会死机一次，硬件重启后可以正常使用，但过几天又会死机。
原因分析 出现这种情况大概率不是系统或某个软件卡顿造成的，因为这两种死机情况一般不会很频繁。如果无论我们是否进行过载操作(甚至什么都不做)，机器依然总是隔一段时间死一次机，而且间隔时间很短，仅几天，这很有可能是硬件问题造成的，而死机很有可能和内存条有关系。（我们已经排除了CPU或GPU由于温度过高导致的断电保护机制。）
问题检测 Windows系统有很多硬件检测软件，比如可以使用aida64进行硬件检测，尽量多检测几次，一般硬件问题都可以检测出来。可是，对于Linux系统，如Ubuntu，没有这些硬件检测软件，那么该怎么初步检测呢？
1、输入cd /var/log/进入系统日志目录下2、查看最近的系统日志vim syslog.*, *代表最近几天的系统日志编号，输入/memory搜索是否有相关错误信息，查看是否有类似这样的错误信息：我们进一步提取上图绿色框中的关键信息： HANDLING MCE MEMORY ERRORmemory read error on CPU_SrcID#0_MC#0_Chan#1_DIMM#0
大概率可以判断为内存条出了问题。 3、再来进一步确定，使用命令grep "[0-9]" /sys/devices/system/edac/mc/mc*/ce_count，可以查看ce数量，若大于0表示可能内存出错，这个信息和上面的错误信息会同时出现，也就是是同一个问题引起，此处命令的使用方法可参考[3-6]。4、根据错误信息：memory read error on CPU_**SrcID#0_MC#0_Chan#1_DIMM#0，结合命令sudo dmidecode | grep -A 9 -B 6 DIMM | grep Bank的输出信息：
我们就可以初步判断出哪一跟内存条出了问题，这里是第三条。此时就可以向供应商提供这些信息以及死机现象，让他们来更换内存条。如果供应商不能短时间内来解决，我们自己可以拿掉有问题的内存条(前提内存条数量大于1)，这样应该就不会出现间歇性死机的情况了。如果觉得还是可能查的不准就新找一个空磁盘装上win10系统，用专业的硬件检测软件来确定问题。 总结：如果你的机器死机情况和我的一样，且根据上面信息查出是内存条问题，那么可能是因为内存老化，而不是坏掉导致，这种情况可能导致机器仅在某些时刻才会出现问题，如果使用硬件检测软件可能不会立即查出问题，要多检查几次(Win)，或者看最近几天的系统日志（Ubuntu）。
参考文章：
[1].https://jingyan.baidu.com/article/4dc40848ea266688d846f178.html
[2].https://blog.csdn.net/xuyaqun/article/details/13774497?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.not_use_machine_learn_pai&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.not_use_machine_learn_pai
[3].https://blog.csdn.net/nazeniwaresakini/article/details/104220361
[4].https://lidong.blog.csdn.net/article/details/46865255?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2.not_use_machine_learn_pai&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2.not_use_machine_learn_pai
[5].https://blog.csdn.net/xztjhs/article/details/9074353
[6].https://blog.csdn.net/charleslei/article/details/104738936
*如有错误或补充，欢迎指出。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d0db78274f5f790bff7d02e8c2e98ba/" rel="bookmark">
			Thinkphp中的 I 函数（Thinkphp3.2.3版本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Thinkphp中的 I 函数（Thinkphp3.2.3版本） I 函数的作用是获取系统变量，必要时还可以对变量值进行过滤及强制转化，I 函数的语法格式：
I('变量类型.变量名/修饰符',['默认值'],['过滤方法或正则'],['额外数据源']) 一、获取变量
在PHP中获取变量值的方法有很多，比如：$_GET['变量名']，$_POST['变量名']，$_SESSION['变量名']，$_COOKIE['变量名']，$_SERVER['变量名'] 都可以获取相应的变量值，但在thinkphp中为了安全的原因建议统一使用 I 函数来获取变量值。例如：获取 URL 地址栏中参数 id 的值，在php中我们用 $_GET['id'] 来获取，在thinkphp中我们可以用 I('get.id') 来获取。同样的， $_POST['id'] 就用 I('post.id') 取代，I 函数的语法格式中的变量类型就是指的像 get 和 post 之类的请求方式，类似的变量类型还包括：
变量类型含义get获取GET参数post获取POST参数param自动判断请求类型获取GET、POST或者PUT参数request获取REQUEST 参数put获取PUT 参数session获取 $_SESSION 参数cookie获取 $_COOKIE 参数server获取 $_SERVER 参数globals获取 $GLOBALS参数path获取 PATHINFO模式的URL参数data获取 其他类型的参数，需要配合额外数据源参数 如果要获取的变量类型是get、post 或 put，可以统一用 param 变量类型，param 变量类型是框架特有的支持自动判断当前请求类型的变量获取方式，例如：I('param.id') ，如果当前请求类型是GET，那么等效于 $_GET['id']，如果当前请求类型是POST或者PUT，那么相当于获取 $_POST['id'] 或者 PUT参数id。而事实上当 I 函数获取的变量类型是param时变量类型可以省略直接写为：I('变量名') ，那么 $_GET['id']、$_POST['id'] 都可以简写为：I('id') 。但当变量类型为其他类型时就不能这么简写，比如 I('cookie.id')、I('session.id')就不能简写。
注意：I 函数的变量类型不区分大小写，但变量名严格区分大小写，比如 I('get.id') 可以写成 I('GET.id')，但不能写成 I('get.ID')
二、变量过滤
I 函数本身默认的过滤机制是 htmlspecialchars，因为在配置文件中配置了：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d0db78274f5f790bff7d02e8c2e98ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7caf987dac7bd1b9fe6bdb9f72e4b8f/" rel="bookmark">
			在项目中将打印日志保存到本地
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现日志功能
在console.log时将打印的东西写入日志，关键是重写了console.log方法
console.warn和console.error也一样。
1、引入node的path和fs模块。 在NW项目中，可以在前端使用node模块来写日志；但如果是在浏览器中，就不能使用node模块。
var path = null var fs = null if (global.hasOwnProperty('nw')) { path = nw.require('path') fs = nw.require('fs') } else if (Meteor.isServer) { path = require('path') fs = require('fs') } else { console.warn('In browser, Can not write log.') } 2、定义一个Logger类，用来写日志。 1、在构造函数中 1、生成日志存放的路径。 在当前项目的根目录下创建log文件夹。
if(Meteor.isServer) { this._LogPath = path.resolve(process.cwd(), '..', '..', 'log') } else { this._LogPath = path.resolve(process.cwd(), 'log') } 2、根据路径创建文件夹 if (!fs.existsSync(this._LogPath)) { fs.mkdirSync(this._LogPath) } 3、调用原型上的addLogPath方法 this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7caf987dac7bd1b9fe6bdb9f72e4b8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3caf59d7e04f915eebf7cc8755e5c35e/" rel="bookmark">
			SAMBA文件共享与DNS域名服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SAMBA文件共享与DNS域名服务 一、SAMBA文件共享1、什么是SAMBA2、SAMBA主要进程3、SAMBA环境准备4、SAMBA软件安装（服务器搭建）5、了解smb的配置文件6、SAMBA综合案例7、总结 二、DNS域名管理系统1、任务背景2、DNS概述☆ DNS的正向解析☆ DNS的反向解析 3、DNS的结构☆ 根域（.）**☆ 一级域名&lt;顶级域|国家域&gt;**☆ **二级域名**(自己购买管理)**☆ 域名机构** 4、DNS工作原理5、dig工具使用 三、DNS服务器的搭建1、DNS服务器端软件2、DNS服务器搭建☆ 第一步：环境准备☆ 第二步：安装DNS软件☆ 第三步：DNS正向解析配置(域名=&gt;IP)☆ 第四步：检查named.conf与zones文件☆ 第五步：启动DNS服务（named） 3、Web服务搭建4、测试DNS服务器的正向解析☆ 添加DNS服务器☆ 使用nslookup检测正向解析是否生效☆ 使用elinks命令行浏览器或curl来实现访问 一、SAMBA文件共享 1、什么是SAMBA SMB（Server Message Block）协议实现文件共享，也称为CIFS（Common Internet File System ）
是Windows和类Unix系统之间共享文件的一种协议
客户端主要是Windows；支持多节点同时挂载以及并发写入
主要用于windows和Linux下的文件共享、打印共享
实现匿名与本地用户文件共享
2、SAMBA主要进程 smbd进程 控制发布共享目录与权限、负责文件传输 TCP 139 445
nmbd进程 用于名称解析netbios UDP 137 138; 基于NETBIOS协议获得计算机名称——&gt;解析为相应IP地址，实现信息通讯
NetBIOS是Network Basic Input/Output System的简称，一般指用于局域网通信的一套API
3、SAMBA环境准备 第一步：从模板机中克隆一台Linux服务器，叫做SAMBA
第二步：更改主机名称与IP地址
# hostnamectl set-hostname samba.itcast.cn # su # vim /etc/sysconfig/network-scripts/ifcfg-ens33 BOOTPROTO=none IPADDR=10.1.1.10 NETMASK=255.255.255.0 GATEWAY=10.1.1.2 DNS1=8.8.8.8 DNS2=114.114.114.114 # systemctl restart network 扩展：如果是多张网卡，建议使用ifdown ens33以及ifup ens33实现重启网络操作 第三步：关闭防火墙与SELinux
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3caf59d7e04f915eebf7cc8755e5c35e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d78c9cf65f263c2d1cb5fabacc730c3/" rel="bookmark">
			一篇搞定Flutter面试(持续更新)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Dart 部分 如果您学习过 JavaScript 或者 Java/Kotlin ，那么在学习 Dart 上难度并不大，Dart 综合了动态语言和静态语言的特性, 他也有一些自己的特点。
1、Dart 属于是强类型语言 ，但可以用 var 来声明变量，Dart 会自推导出数据类型，var 实际上是编译期的“语法糖”。dynamic 表示动态类型， 被编译后，实际是一个 object 类型，在编译期间不进行任何的类型检查，而是在运行期进行类型检查。
2、Dart 中 if 等语句只支持 bool 类型，switch 支持 String 类型。
3、Dart 中数组和 List 是一样的。
4、Dart 中，Runes 代表符号文字 , 是 UTF-32 编码的字符串, 用于如 Runes input = new Runes(’\u{1f596} \u{1f44d}’);
5、Dart 支持闭包。
6、Dart 中 number 类型分为 int 和 double ，没有 float 类型。
7、Dart 中 级联操作符 可以方便配置逻辑，如下代码：
event ..id = 1 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d78c9cf65f263c2d1cb5fabacc730c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4efd62e828ab2432798e192f9d3be894/" rel="bookmark">
			1：App启动流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1：ActivityThread 它管理应用程序进程中主线程的执行、调度和执行活动、广播以及活动管理器请求的其他操作
ActivityThread初始化 ActivityThread thread = new ActivityThread(); thread.attach(false, startSeq); 2：获取到Ams调用接口（AIDL方式） final IActivityManager mgr = ActivityManager.getService(); try { mgr.attachApplication(mAppThread, startSeq); } catch (RemoteException ex) { throw ex.rethrowFromSystemServer(); } 3：ActivityManager.getService()的实现类是activityManagerService 切换到ams的实现类中查看attachApplication函数的作用 attachApplicationLocked(thread, callingPid, callingUid, startSeq); 4：bindApplication启动应用中的application thread.bindApplication(processName, appInfo, providers, instr2.mClass, profilerInfo, instr2.mArguments, instr2.mWatcher, instr2.mUiAutomationConnection, testMode, mBinderTransactionTrackingEnabled, enableTrackAllocation, isRestrictedBackupMode || !normalMode, app.isPersistent(), new Configuration(app.getWindowProcessController().getConfiguration()), app.compat, getCommonServicesLocked(app.isolated), mCoreSettingsObserver.getCoreSettingsLocked(), buildSerial, autofillOptions, contentCaptureOptions); 参考加载 didSomething |= mServices.attachApplicationLocked(app, processName); 5：ActivityThread内部私有类ApplicationThread 发送handler信息：sendMessage(H.BIND_APPLICATION, data);、
6：ActivityThread内部类H执行 case BIND_APPLICATION: Trace.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4efd62e828ab2432798e192f9d3be894/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8466e9dde865b85d375b59680b927be7/" rel="bookmark">
			HTML初学2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标签学习 1 链接标签 链接标签：&lt;a href="地址"&gt;文字描述&lt;/a&gt;
地址必须用http://或https://开头target属性，属性值有_self和_blank两种，_self是默认值，在当前窗口跳转，_blank是在新窗口中跳转 2 列表标签 2.1 列表的应用场景 场景：在网页中按照行展示关联性的内容，如：新闻列表，排行榜，账单等特点：整齐的显示内容，便于观看种类：无序列表，有序列表，自定义列表 2.2 无序列表 场景：在网页中表示一组无顺序之分的列表，如：新闻列表
标签组成：
标签名说明ul表示无序列表的整体，用于包裹li标签li表示无序列表的每一项，用于包含每一行的内容 特点：列表的每一项前都默认显示圆点标识
注意点：
ul标签中只允许包含li标签li标签可以包含任意内容 2.3 有序列表 场景：在网页中表示一组有顺序之分的列表，如：排行榜
标签组成：
标签名说明ol表示有序列表的整体，用于包裹li标签li表示有序列表的每一项，用于包含每一行的内容 特点：列表的每一项前都默认显示序号标识
注意点：
ol标签中只允许包含li标签li标签可以包含任意内容 2.4 自定义列表 场景：在网页的底部导航中通常会使用自定义列表实现
标签组成：
标签名说明dl表示自定义列表的整体，用于包裹dt/dd列表dt表示自定义列表的主题dd表示自定义列表的针对主题的每一项内容 特点：dd前会默认显示缩进效果
注意点：
dl标签中只允许包含dt/dd标签dt/dd标签可以包含任意内容 3 表格标签 3.1 表格的基本标签 1.表格是用来展示数据的，不是用来布局的
2.基本标签
标签名说明table表示整体，可用于包裹多个trtr表格每行，可用于包裹tdtd表格单元格，可用于包裹内容 3.表格标签的嵌套关系：table&gt;tr&gt;td
3.2 表格的相关属性 常见的相关属性：
属性名属性值效果border数字边框宽度width数字表格的宽度height数字表格的高度 注意点：实际开发过程中对于样式效果推荐CSS设置
3.3 表格标题和表头单元格标签 表格标题和表头标签：
标签名名称说明caption表格大标题表示表格整体大标题，默认在表格整体顶部居中位置显示th表头单元格表示一列小标题，通常用于表格第一行，默认内部文字加粗并居中显示 注意：
caption标签书写在table标签内部th标签书写在tr标签内部，即第一列全部改为th标签 3.4 表格的结构标签 标签名名称thead表格表头tbody表格主题tfood表格底部 结构标签可以省略
3.5 合并单元格 明确合并的单元格
左上原则使用，确定保留谁删除谁
跨行合并（rowspan）和跨列合并（colspan）
属性名属性值说明rowspan合并单元格的个数跨行合并，垂直合并colspan合并单元格的个数跨列合并，水平合并 同一个结构标签中的单元格才能合并，不能跨结构体合并
4 表单标签 4.1 input系列标签 input标签可以通过**type**属性值的不同，展示不同效果
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8466e9dde865b85d375b59680b927be7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d3a2c8f468e00443a4fab8e20416323/" rel="bookmark">
			笔记-项目打包成app
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 项目打包第一步安装软件第二步打包 项目打包 今天我们学的东西时把我们做的项目打包成apk（安卓手机安装包时.apk文件,ios的安装包为.ipa文件），因为我们普遍用的均为windouws系统和安卓手机，所以今天进行的时apk文件的打包。
第一步安装软件 项目打包首先要知道打包需要用带的工具，这里我们使用的是 Android Stuido 打包，参考的是教程是：React Native 搭建开发环境。
这里我们首先进行相关环境的配置安装：
必须安装的依赖有：Node、JDK 和 Android Studio。 其中node 为我们写项目过程已经用到的，所以node的安装配置，就已经有现成的，只需要jdk和 Android Studio。
这里我们首先下载安装Android SDK：
安装默认为c盘 ，无法修改（安装完以后可以修改），但是如果你的c盘用户名为中文，则会报一个错，让你修改安装路径后，才能继续安装。
安装过程基本还剩傻瓜式一键安装，安装完成后，选择configure下的SDK Manger
然后按照官方文档走。
等待安装完成。
在安装过程中，打开一个命令行，执行以下命令：
npm install -g react-native-cli //安装react-native npm install -g cordova //安装cordova 第二步打包 安装完配置文件以后
在桌面新建文件夹（注意，路径中不要含有中文，负责打包会出错，亲测）
打开命令行，cd到这个文件夹中
执行：
cordova create hello com.example.hello HelloWorld 这时候，会在文件夹中生成一个hello文件夹，cd到这个hello文件夹中，执行
cordova platform add android@6.3.0 然后将自己写的vue项目打包成的 dist 文件夹替换hello里面的 www 文件夹，
执行打包
cordova build android 这时候，又会提示，没有安装gradle，也可以使用 cordova requirements 命令 查看缺少什么。
缺少gradle 就去安装gradle，地址：https://services.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d3a2c8f468e00443a4fab8e20416323/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28cdd9f13bacb385bf828151892c6bb6/" rel="bookmark">
			eclipse无法查看源代码问题的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		eclipse无法查看源代码问题的解决方法 这段时间学习j2ee查看代码源文件时，发现查看不了就百度解决了一下，因为自己的eclipse是汉化版的，就顺手做个笔记，希望对把eclipse汉化的朋友有所帮助
可能是因为eclipse的jdk没有配置对应的src，需要手动去添加jdk的源代码附件
操作步骤：
1、找到以下路径：windows(窗口)–&gt;Preferences(首选项)–&gt;Java–&gt;Installed JRES(已安装的JRE)，出现如下图所示的图片后，选中点击jdk并点击右边的Edit(编辑)按钮
2、找到你安装的jdk路径下的\lib\rt.jar,接着展开找到Source Attachment:(none),即可看到源代码连接:(无)的字样，选中它点击Source Attachment…****(源代码附件)按钮，如下图
3、选择External location之后,点击External File(外部文件)按钮，在你安装的jdk路径下找到src压缩包，若没找到的话，可参考此c盘(系统盘)路径：C:\Program Files\Java\jdk1.8.0_191去找，如图
4、找到src压缩包之后选中并点击打开按钮，之后的操作如下：
OK–&gt;Finish–&gt;Apply(应用)–&gt;Apply and Close(应用并关闭)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcb46890aabb67f460177fab53d1d0b5/" rel="bookmark">
			联想拯救者Y7000P鼠标卡顿问题(已解决)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一：默认是混合显卡模式，切换独立显卡，完了记得要应用。切换之后，帧率也上去了，香得不要不要的
方法二：
网上说是联想管理软件安装了一些自己的服务导致的问题。
禁用system interface foundation service这个服务就好了。
右击桌面此电脑图标，选择管理，选择左侧服务和应用程序，双击右侧服务，在打开的页面中，找到system interface foundation service这个服务，右击选择属性，禁用一下,然后重启
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f83eeb135dfc076e44e8f0d43416520/" rel="bookmark">
			HCIP-H12-223多选题库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、当前企业网络中常常会使用OSPF作为路由协议，那么在使用OSPF做路由协议的时候，需要注意以下哪些问题？
A.确认骨干区域不会出现分裂的情况 B.确认在OSPF的选路规则下，网络是否会出现次优路由 C.确认所有的非骨干区域与骨干区域有正确可靠的链接 D.确认OSPF网络的拓扑结构，保证OSPF在路由计算时不会出现环路 E.确认OSPF的Cost能够正确反映百兆以上链路的真实带宽 【正确答案】A,B,C,E
【答案解析】使用OSPF做路由协议的时候，需要确认骨干区域不出现分裂，确认网络是否出现次优路由，确认非骨干区域和骨干区域的链接，确认端口的COST值是否正确。所以除了选项“确认OSPF网络的拓扑结构，保证OSPF在路由计算时不会出现环路”以外，其他所有选项都是需要注意的问题。
2、数据中心的交换机与普通的园区交换机有很多区别，请问以下哪些特性是数据中心交换机特有，而园区交换机不支持的？
A.MSTP B.TRILL C.NFV D.FCoE E.VxLAN 【正确答案】B,D,E
【答案解析】数据中心交换机支持Trill协议，即多链路透明互联（Transparent interconnection of Lots of Links），以太网光纤通道（FCoE，Fibre Channel over Ethernet）协议和VXLAN(Virtual Extensible LAN)技术，而园区交换机不支持以上三种技术；至于MSTP和NFV这两种技术无论数据中心交换机还是园区交换机都是支持的。所以正确答案是“TRILL”、“FCoE”、“VxLAN”。
3、在eSight网管侧，需要配置的参数有模板名称、SNMP版本、读写团体字、网元端口、超过时间以及重发次数。下面哪些参数是必须与设备上的配置信息相吻合的？
A.网元端口 B.读写团体字 C.模板名称 D.SNMP版本 【正确答案】A,B,D
【答案解析】eSight网管软件配置时，下面这些参数必须与设备上的配置信息相吻合：网元端口、读写共同体的名称、SMNP协议版本。所以正确答案是“网元端口”、“读写团体字”、“SNMP版本”。
4、在进行网络故障排除时，如果需要对业务流量路径进行确认，那么可能需要进行以下哪些工作？
A.确认数据链路层业务流量路径 B.确认网络层业务流量路径 C.调研网络设计阶段的业务流量路径规划 D.确认故障发生频率 【正确答案】A,B,C
【答案解析】业务流量路径进行确认需要调研网络设计阶段的业务路径，然后分别确认网络层和数据链路层业务路径。“确认故障发生频率”与业务路径相关性不大，其他选项都是可以考虑的操作。
5、在楼宇布线中，存在以下哪些子系统？
A.水平子系统 B.接入子系统 C.骨干子系统 D.垂直子系统 E.交换子系统 【正确答案】A,D
【答案解析】楼宇布线中有六个子系统，分别为：群筑群子系统、设备间子系统、垂直子系统、管理子系统、水平子系统和工作区子系统。所以正确答案是“水平子系统”、“垂直子系统”。
6、企业业务往往对网络中的服务质量都有严格的要求，请问以下哪些方面常用来描述网络的服务质量？
A.稳定 B.带宽 C.延迟 D.抖动 E.安全
【正确答案】B,C,D
【答案解析】用来描述网络中的服务质量的技术指标有带宽、延迟和抖动。所以正确答案是“带宽”、“延迟”、“抖动”。
7、下列哪些原因可能引起BGP邻居关系故障？
A.ACL过滤了TCP的179端口 B.邻居的Router ID冲突 C.用Loopback口建立EBGP邻居没有配置peer ebgop-max-hop D.用Loopback口建立邻居时没有配置peer connect-interface 【正确答案】A,B,C,D
【答案解析】BGP邻居关系故障的常见原因主要包括：BGP报文转发不通，ACL过滤了TCP的179端口，邻居的Router ID冲突，配置的邻居的AS号错误，用Loopback口建立邻居时没有配置peer connect-interface，用Loopback口建立EBGP邻居未配置peer ebgp-max-hop，对端发送的路由数量是否超过peer route-limit命令设定的值，对端配置了peer ignore，两端的地址族不匹配。所以题目中各个选项描述的都可能导致BGP邻居关系故障。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f83eeb135dfc076e44e8f0d43416520/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3b249ddb464282a3a008e946abb9846/" rel="bookmark">
			解决Idea  Tomcat控制台打印日志乱码问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多其他花里胡哨的解决方法都试过不生效，最后靠这个方法解决了
乱码显示
解决方法
找到Tomcat配置目录，找到文件logging.properties
打开，修改编码方式为GBK
重启，乱码解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05a3d6272c08825f8ed86ed5f2cb59dc/" rel="bookmark">
			看完了阿里大牛的Leetcode刷题笔记, 我成功拿到了字节跳动的offer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于算法刷题的困惑和疑问也经常听朋友们提及，不管是找工作笔试面试白板试进大厂，还是研究生参加初试复试机试，数据结构和算法都是绕不过去的坎，刷题就成了很多人的需求，今天推荐两个大佬的算法刷题笔记，让你毫不费力的搞定算法、拿下大厂offer ！
这份笔记里面共包含作者刷LeetCode算法题后整理的数百道题，每道题均附有详细题解过程。很多人表示刷数据结构和算法题效率不高，甚是痛苦。有了这个笔记的总结，对校招和社招的算法刷题帮助之大不言而喻，果断推荐给大家。
第一份算法笔记
内容包含：数组系列、链表系列、动态规划系列、字符串系列、二叉树系列、滑动窗口系列、博弈论系列、位运算系列、二分法系列、其他题目等等。图文兼备，目前共完成105道高频面试算法题目,全部采用漫画图解的方式。
点击这里即可获取到文章中的文档，资料
数组系列
链表系列
动态规划系列
字符串系列
二叉树系列
滑动窗口系列
博弈论系列
位运算系列
二分法系列
其他题目
第二份算法笔记
这是一本程序员面试宝典！书中对IT名企代码面试各类题目的最优解进行了总结，并提供了相关代码实现。针对当前程序员面试缺乏权威题目汇总这一痛点，本书选取将近200道真实出现过的经典代码面试题，帮助广大程序员的面试准备做到万无一失。“刷”完本书后，你就是“题王”!
目录
栈和队列
链表问题
二叉树问题
递归和动态规划
字符串问题
大数据和空间限制
位运算
数组和矩阵问题
其他题目
由于手册内容太多，在此只展示了部分内容。点击这里即可获取到文章中的文档，资料
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/109ec575d3849405b7492e005c314271/" rel="bookmark">
			如何删除数组中指定的某一项或几项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		var arr1 = [ {a: "111", b:"222"}, {c:"333", d:"444"}, {e:"555", f: "666"}, {g: "777", h:"888"}, {i:"999", j:"000"}, {k:"111", l: "222"} ] var arr2 = [ {a: "111", b:"222"}, {i:"999", j:"000"} ] 现在有两个数组，arr1和arr2，arr1是初始数组，arr2是arr1中选中的数组，需要将选中的数组的内容在arr1中删除，我采用的是如下方法
function removeList(originList, delList) { var newArr = originList delList.forEach((Element1, index1) =&gt; { originList.forEach((Element2, index2) =&gt; { if (isObjectValueEqual(Element1, Element2)) { newArr.splice(index2, 1) } }) }) originList = newArr return originList } // 只要两个对象的名和键值都相同。那么两个对象的内容就相同了 // 1.用Object.getOwnPropertyNames拿到对象的所有键名数组 // 2.比对键名数组的长度是否相等。否=&gt;false。真=&gt;3 // 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/109ec575d3849405b7492e005c314271/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98c3583fcbde50142a459a2119d55ccc/" rel="bookmark">
			Matlab Smooth函数/丝滑数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在处理数据的时候，一般会进行数据拟合，这时候免不了会有噪点，从而造成图像上的“飞点”。幸好Matlab自带一个平滑函数smooth，笔者也是最近才晓得，做点笔记。
在Matlab Command Windows 中输入：
doc smooth 弹出来帮助文档，下面跟着帮助文档，记点有用的。
一、预备知识 有关平滑的算法又叫滤波算法，滤波是什么意思？百度百科中写道：滤波（Wave filtering）是将信号中特定波段频率滤除的操作，是抑制和防止干扰的一项重要措施，滤波分为经典滤波和现代滤波。“滤”这个字让我想起了老妈在家里用的面粉筛
（图片来源于网络）就是过滤杂质的。把噪点想象成“杂质”，那么滤波的意思就显而易见了。
1、滑动平均滤波 上图简单示意了滑动平均的思想，需要注意以下几点：
待处理的数据是一个一行或一列的向量，若不是，则将其看作是（顺序按存储顺序，matlab中）窗口大小需是奇数，待处理的是中间那个数据边缘数据，凑不够窗口大小个数的数据，能凑几个凑几个。 若窗口大小为5，则公式如下：
yy(1) = y(1) yy(2) = (y(1) + y(2) + y(3))/3 yy(3) = (y(1) + y(2) + y(3) + y(4) + y(5))/5 yy(4) = (y(2) + y(3) + y(4) + y(5) + y(6))/5 ... 2、其他平滑算法 如果理解滑动平均算法的话，其他算法也就好理解了。滑动平均算法可以看作和[1/n 1/n .. 1/n]做卷积（相乘相加），其他算法：
一次：一个一次的卷积函数，自变量为参与数与代求数的距离二次及多次：卷积函数次数不同而已；值得注意的一点是窗口大小要大于卷积函数次数。滑动平均算法可以看作是卷积函数是零次（常数）函数，因为里面不涉及自变量（参与数于代求数的距离）或者说自变量次数为0 3、gpuArray 就是将数据存储在GPU上面，可以加快计算效率，笔者曾经看到过一些GPU、CUP方面的知识并做了点总结，读者感兴趣可以看看：
https://blog.csdn.net/Gou_Hailong/article/details/113308630
如果想使用gpuArray的话，需安装支持它的相应matlab版本。
有关GPU的知识，笔者了解还尚浅，暂不能做详细的笔记
二、代码 1、语法 yy = smooth(y) yy = smooth(y,span) yy = smooth(y,method) yy = smooth(y,span,method) yy = smooth(y,'sgolay',degree) yy = smooth(y,span,'sgolay',degree) yy = smooth(x,y,___) gpuarrayYY = smooth(gpuarrayY,___) gpuarrayYY = smooth(gpuarrayX,gpuarrayY,___) yy = smooth(y) 滑动平均，窗口为5，得到的结果是一个列向量。yy = smooth(y,span) span 控制窗口大小yy = smooth(y,method) 指定平滑算法，平滑算法有好多种，下面有简介。yy = smooth(y,span,method) 指定窗口大小+平滑算法yy = smooth(y,‘sgolay’,degree) 指定多项式平滑算法+多项式次数，次数要小于窗口大小，因为确定一个n次多项式，需要n+1个值，至少需要n+1组数据。yy = smooth(y,span,‘sgolay’,degree) 指定窗口大小+多项式平滑算法+多项式次数yy = smooth(x,y,___) 多一个自变量x，x的含义见于下面，横线表示选项可取上面任意一种。gpuarrayYY = smooth(gpuarrayX,gpuarrayY,___) 于上边的类似，只是使用的数据为gpuArray类型的数据而已，其他于上面相同。span的取值可以是整数或是（0,1）范围内的小数，代表所有数据的百分比，0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98c3583fcbde50142a459a2119d55ccc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d822a1b9bb76a17cd79828076452706/" rel="bookmark">
			pragma pack() 详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.#pragma简述
预处理指令，作用是设定编译器的状态或者指示编译器完成一些特定动作。 #pragma指令对每个编译器给出一种方法，保持与C和C++的完全兼容的情况下，给出主机和操作系统专有的特征。所以每个编译器都是不同的。
2.#pragma pack作用
主要作用就是改变编译器的内存对齐方式，在网络报文的处理有重要的作用。基本用法：#pragma pack(n) ，不使用这条指令，采取默认的字节对齐方式（#pragma pack(8)) n可以取(1, 2, 4, 8, 16)。
3.#pragma pack详细介绍
3.1 #pragma pack(show):
显示当前内存对齐的字节数，也就是packing aligment。
3.2 #pragma pack(push [, identifier] [, n])
单独使用 #pragma pack(push) 将当前对齐字节数压入栈顶，设置这个值为新的的对齐字节数。
使用#pragma pack(push, n) 将当前字节数压入栈顶，设置n为新的对齐字节数
使用#pragma pack(push, identifier, n)在上面的基础上，附上一个标识符（$ _ 字母），不能是关键字（push, pop,可以）
3.3 #pragma pack(pop [, identifier] [, n])
使用#pragma pack(pop) 淡出栈顶对齐字节数，设置为新的内存对齐字节数
使用#pragma pack(pop, n) 弹出并丢弃，设置n为新的。
使用#pragma pack(pop, identifier, n) 从栈顶向下顺序查找匹配identifier， 把栈顶到identifier全部pop弹出。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb2b372f2a2d0e08f1d4330ea83002d0/" rel="bookmark">
			Ubuntu18.04 LTS 屏幕顶部状态栏设置同时显示日期和时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题描述 Ubuntu18.04 LTS 屏幕顶部状态栏默认仅显示星期和时间，不显示日期，在图形化界面中没法设置显示日期的选项 解决方法 显示日期、星期和时间 dconf write /org/gnome/desktop/interface/clock-show-date 'true' 仅显示星期和时间 dconf write /org/gnome/desktop/interface/clock-show-date 'false' 参考 【How to show date in top bar of deskop in ubuntu 18.04 LTS? 】：https://askubuntu.com/questions/1040306/how-to-show-date-in-top-bar-of-deskop-in-ubuntu-18-04-lts 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fa61ced4de63ccb2393063ff6a890ea/" rel="bookmark">
			入门微信小程序三（自定义组件）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、组件的创建 ① 在项目的根目录中，鼠标右键，创建 components -&gt; test 文件夹
② 在新建的 components -&gt; test 文件夹上，鼠标右键，点击“新建 Component”
③ 键入组件的名称之后回车，会自动生成组件对应的 4 个文件，后缀名分别为 .js，.json， .wxml 和 .wxss
注意：为了保证目录结构的清晰，建议把不同的组件，存放到单独目录中，例如：
2、引用组件 组件的引用方式分为“局部引用”和“全局引用”，顾名思义：
⚫ 局部引用：组件只能在当前被引用的页面内使用
⚫ 全局引用：组件可以在每个小程序页面中使用
一般用的都是全局引用组件
3、局部引用组件 在页面的 .json 配置文件中引用组件的方式，叫做“局部引用”。示例代码如下：
4、全局组件引用 在 app.json 全局配置文件中引用组件的方式，叫做“全局引用”。示例代码如下：
5、全局组件和局部组件的比较 根据组件的使用频率和范围，来选择合适的引用方式：
⚫ 如果某组件在多个页面中经常被用到，建议进行“全局引用”
⚫ 如果某组件只在特定的页面中被用到，建议进行“局部引用
6、组件和页面的区别 组件和页面的区别
从表面来看，组件和页面都是由 .js、.json、.wxml 和 .wxss 这四个文件组成的。但是，组件和页面的 .js 与
.json 文件有明显的不同：
⚫ 组件的 .json 文件中需要声明 “component”: true 属性
⚫ 组件的 .js 文件中调用的是 Component() 函数
⚫ 组件的事件处理函数需要定义到 methods 节点中
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fa61ced4de63ccb2393063ff6a890ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c475eb36781adc6ee3376f789dc7ac43/" rel="bookmark">
			E.03.25 Chinese Video Company Bilibili Eyes $2.8 Billion Hong Kong Share Sale
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2021.03.25
文章目录 【课程导读】【英文原文】【外刊原文】 【课程导读】 2009年6月，哔哩哔哩网站上线。这家名字起得欢脱、从二次元内容出发、能发弹幕的视频网站，成立初期被用户们亲切地称为——小破站。但短短几年后，它便摘掉了小众、边缘的标签，一跃成为国内首屈一指的年轻文化聚集地。举办网络跨年，冠名篮球队，甚至还发射过视频卫星，曾经的小破站摇身一变，成为了家喻户晓的B站。2018年，哔哩哔哩在纳斯达克敲钟上市。就在最近，B站又公布了即将在香港二次上市的消息。它为何深受年轻人的喜爱？又为何选择在此时再次上市？
【英文原文】 Chinese Video Company Bilibili Eyes $2.8 Billion Hong Kong Share Sale
中国视频公司哔哩哔哩拟香港上市，计划筹资28亿美元
By Joanne Chiu
Bilibili Inc., the operator of a video app popular with young Chinese videogame and animation fans, is capitalizing on a huge run-up in its shares to raise nearly $3 billion in Hong Kong.
eye v. 沉思，考虑Inc. （缩写）有限公司capitalize on sth. 利用（包含使某事物资本化之意）run-up n. 急剧增长 哔哩哔哩是一家视频应用运营商，深受中国年轻的电子游戏与动漫粉丝们的追捧。目前，它计划利用其美股股价大幅上涨的机会，在香港融资近30亿美元。
The planned secondary listing for Bilibili, whose shares already trade on Nasdaq, comes soon after Kuaishou Technology, the group behind one of China’s most popular TikTok-style apps, raised $6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c475eb36781adc6ee3376f789dc7ac43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c425c9bad737b0a924514558eb16cd22/" rel="bookmark">
			PCIe 链路训练状态机（LTSSM）基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LTSSM：Link Training and Status State Machine
下图展示了 LTSSM 的顶层状态（顶层状态下包含子状态）：
LTSSM 包含 11 个顶层状态：Detect、Polling、Configuration、Recovery、L0、L0s、L1、L2、Hot Reset、Loopback 和 Disable。这些状态可以分为 5 类：
Link Training states（链路训练状态）Re-Training（Recovery）state（重训练状态）Software driven Power Management State（由软件控制的电源管理状态）Active-State Power Management（ASPM）states（动态电源管理状态）Other states（其他状态） 各种复位（Reset）之后，状态机的改变为：Detect =&gt; Polling =&gt; Configuration =&gt; L0。在 L0 状态下即可进行标准数据交互。
链路的 Re-Training 状态也称为 Recovery（恢复）状态。链路进入 Re-Training 状态的原因有多种，例如从低功耗链路状态（如 L1）退出、改变带宽（改变速率或者宽度）等。在该状态下，链路会根据需要重新执行一部分链路训练的流程，然后进入 L0 状态。
电源管理软件能将设备（Device）切换到低功耗设备状态（D1，D2，D3Hot 或者 D3Cold），这会导致链路进入对应的低功耗链路状态（L1 或者 L2）。
在某一时刻，如果没有数据在传输，那么 ASPM 硬件可以自动将硬件切换到功耗较低的 ASPM 状态（L0s 或者 ASPM L1）。
另外，软件还可以将链路设置为其它的一些特殊状态：Disabled，Loopback 或者 Hot Reset。
1. Detect 状态 当 PCIe 链路被复位或者数据链路层通过填写某些寄存器之后，LTSSM 将进入该状态。当前状态是 LTSSM 的初始状态。当 PCIe 链路进入该状态时，发送逻辑 TX 并不知道对端接收逻辑 RX 的存在，因此需要使用 Receiver Detect 识别逻辑判断对端接收逻辑 RX 是否可以正常共工作，之后才能进入其他状态。能切换到 Detect 状态的状态有：Polling，Configuration，Recovery，Disabled，External Loop back 和 Hot Reset。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c425c9bad737b0a924514558eb16cd22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d57abb2823023d9d9475bb401e3dde14/" rel="bookmark">
			谷歌浏览器无法携带cookie
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在写项目的时候突然发现了一个奇怪的事情，前一天还能登陆，第二天浏览器就开始无限刷新了。排查了一下发现登陆之后请求都没有携带cookie导致了拦截器一直在跳登陆页面造成了死循环。除了谷歌浏览器之外，其他浏览器都没有类似的情况。
因为谷歌浏览器在升级到80版本之后，Cookie的SameSite属性默认值由None变为Lax，Cookie 的SameSite属性用来限制第三方 Cookie，从而减少安全风险。
最快的解决办法：
1.如果你用的请求接口的方法是axios或者是基于axios封装的方法，那么要先设置withCredentials为true，默认请求携带cookie。
2.然后打开谷歌浏览器在Chrome中访问chrome://flags/，搜索SameSite并设置为disabled。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdcc27bbd27bc6eb316d7a16222ccb4e/" rel="bookmark">
			使用Lambda 左连接查询DataTable
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Lambda 查询DataTable,左连接
var query = dtWork.AsEnumerable(). GroupJoin(dtData.AsEnumerable(), w =&gt; w.Field&lt;decimal&gt;("ID"), d =&gt; d.Field&lt;decimal&gt;("ID"), (w, d) =&gt; d.DefaultIfEmpty(). Select(o =&gt;new { INFO = o == null ? "" : o.Field&lt;string&gt;("APPROVED_INFO"), USER_NAME = w.Field&lt;string&gt;("USER_NAME") })).SelectMany(o=&gt;o); 不加SelectMany,效果如下：
加上SelectMany,效果如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2033af2d1d509b30b3bf2b4f612f051/" rel="bookmark">
			拓扑排序及算法实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、拓扑排序概念 对一个有向无环图(Directed Acyclic Graph简称DAG)G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边&lt;u,v&gt;∈E(G)，则u在线性序列中出现在v之前。通常，这样的线性序列称为满足拓扑次序(Topological Order)的序列，简称拓扑序列。简单的说，由某个集合上的一个偏序得到该集合上的一个全序，这个操作称之为拓扑排序。 二、理解 在一个有向图中，对所有的节点进行排序，要求没有一个节点指向它前面的节点。先统计所有节点的入度，对于入度为0的节点就可以分离出来，然后把这个节点指向的节点的入度减一。一直做改操作，直到所有的节点都被分离出来。如果最后不存在入度为0的节点，但还存在节点，那就说明有环，不存在拓扑排序，也就是很多题目的无解的情况。 三、基本实现思路 先把入度为0 的节点找到并打印删掉入度为0的节点，继续循环1的步骤，直至图为null。 四、算法具体思路 第一种方式 是遍历整个图中的顶点，找出入度为0的顶点，然后标记删除该顶点，更新相关顶点的入度，由于图中有V个顶点，每次找出入度为0的顶点后会更新相关顶点的入度，因此下一次又要重新扫描图中所有的顶点。故时间复杂度为O(V^2)
问题：由于删除入度为0的顶点时，只会更新与它邻接的顶点的入度，即只会影响与之邻接的顶点。但是上面的方式却遍历了图中所有的顶点的入度。
第二种方式（更优的算法） 先将入度为0的顶点放在栈或者队列中。当队列不空时，删除一个顶点v，然后更新与顶点v邻接的顶点的入度。只要有一个顶点的入度降为0，则将之入队列。此时，拓扑排序就是顶点出队的顺序。该算法的时间复杂度为O（V+E）
五、拓扑排序方法实现 该算法借助队列来实现时，感觉与 二叉树的 层序遍历算法很相似啊。说明这里面有广度优先的思想。
第一步：遍历图中所有的顶点，将入度为0的顶点 入队列。
第二步：从队列中出一个顶点，打印顶点，更新该顶点的邻接点的入度(减1)，如果邻接点的入度减1之后变成了0，则将该邻接点入队列。
第三步：一直执行上面 第二步，直到队列为空。
public void topoSort() throws Exception{ int count = 0;//判断是否所有的顶点都出队了,若有顶点未入队(组成环的顶点)，则这些顶点肯定不会出队 Queue&lt;Vertex&gt; queue = new LinkedList&lt;&gt;();// 拓扑排序中用到的栈,也可用队列. //扫描所有的顶点,将入度为0的顶点入队列 Collection&lt;Vertex&gt; vertexs = directedGraph.values(); for (Vertex vertex : vertexs) if(vertex.inDegree == 0) queue.offer(vertex); //度为0的顶点出队列并且更新它的邻接点的入度 while(!queue.isEmpty()){ Vertex v = queue.poll(); System.out.print(v.vertexLabel + " ");//输出拓扑排序的顺序 count++; for (Edge e : v.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2033af2d1d509b30b3bf2b4f612f051/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73cd642b21d4c424a0aa9b3478435c73/" rel="bookmark">
			【前端学习】JavaScript基础 - 1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		==
表示相等（值相等，但类型不一定相等）
===
表示绝对相等（值相等，类型也相等）
例：
在F12检查的Console控制台中输入NaN===NaN：return false
输入isNaN(NaN)：return true
‘use strict’
严格检查模式
预防JS的随意性产生问题
必须写在js文件第一行
局部变量建议使用let定义（取代var）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01fa4c947eac64c77f548388276ce5d8/" rel="bookmark">
			电脑意外断电导致蓝屏代码0X0000007B的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电脑开机时如上图所示解决方法：
方法一：.重启启动
方法二：重新启动时按下del键，进入安全模式，选择最后一次正确配置之后按下Enter键
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37ddca6b1eed1ff445ee5d5c878cd46e/" rel="bookmark">
			Ubuntu18.04 LTS 安装 iptables，修改防火墙规则，开放端口.md
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 提示 （1）正常情况下，修改 ufw 添加端口后，会自动添加到 iptables
（2）但有时候页可能因为服务器之前的配置问题，设置 ufw 之后，端口还是没有开放，此时就应该配置一下 iptables
iptables 安装及使用 安装 sudo apt-get install iptables 修改防火墙规则，开放指定端口 iptables -I INPUT -p tcp --dport 端口号 -j ACCEPT 保存防火墙规则 iptables-save 服务器重启，上述规则可能就没有了，需要对规则进行一下持续化操作 # （1）安装iptables-persistent sudo apt-get install iptables-persistent # （2）持久化规则 sudo netfilter-persistent save sudo netfilter-persistent reload 参考 【Ubuntu 通过 iptables 开放指定端口】：https://blog.csdn.net/londa/article/details/112179661 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcd1909cf831949c3b80e6f3183b8d79/" rel="bookmark">
			websocke 在线测试地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转到教程。
记录一个websocke在线测试地址：
http://www.websocket-test.com/
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/207/">«</a>
	<span class="pagination__item pagination__item--current">208/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/209/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>