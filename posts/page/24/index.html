<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d58ff9684b58b86cebc0c8eea71a5a29/" rel="bookmark">
			实战营 | 阿里云 x StarRocks 邀你现场体验云上极速湖仓--深圳站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1月20日深圳阿里中心，阿里云 x StarRocks 邀你现场体验云上极速湖仓实战营，从 0-1 轻松上手 StarRocks 湖仓分析。
StarRocks 自 3.0 大版本起，实现了从计算 OLAP 分析到统一 Lakehouse 的重大产品能力升级。通过存算分离架构，帮助用户降低存储成本、提升计算弹性；通过数据湖分析、物化视图等特性简化湖仓融合，实现极速统一湖仓分析。
EMR Serverless StarRocks 是阿里云提供的全托管服务，具备高性能、全场景、极速统一的数据分析体验，以及开箱即用、弹性扩展、监控管理、慢 SQL 诊断分析等全生命周期能力。内核 100% 兼容 StarRocks，性能相比传统 OLAP 引擎提升 3-5 倍，助力企业高效构建多维分析、数据湖分析、高并发查询及实时分析等大数据应用。
新年伊始，阿里云 EMR OLAP 团队与 StarRocks 社区联合共赴深圳，与镜舟科技、阿里云 EMR、轻喜到家等行业专家共话云上 StarRocks，共同开启新一年的数据分析之旅！本次活动的实操部分将会利用 EMR Serverless StarRocks 环境进行演练，想从 0-1 快速利用 StarRocks 进行湖上分析的小伙伴们请尽快报名～
01
活动亮点
超多实用干货，本场 Meetup 从 StarRocks 湖仓一体的关键特性到 Serverless StarRocks 产品功能，更有轻喜到家带来一手基于EMR StarRocks 构建实时分析平台的经验。
StarRocks 湖仓实战初体验，带你体验极速湖分析和存算分离 EMR 部署。你可以通过 Hive Catalog 外表访问 Hive 中的数据，在不迁移数据的前提下就能轻松跑通 TPCDS 标准测试集；此外，还可以在 Flink 作业中使用 Java 代码生成模拟行为数据，通过 Flink Connector 导入 StarRocks，再通过物化视图进行数据 ETL，实现数据指标分层，完成多维分析平台建设。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d58ff9684b58b86cebc0c8eea71a5a29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b04752dac9e389fc82bc24a628b61e12/" rel="bookmark">
			spconv简介、环境配置与安装以及遇到的各种报错处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		spconv简介、环境配置与安装以及遇到的各种报错处理 spconv介绍spconv安装源码安装spconv 1.xpip安装spconv 2.x 报错处理报错一报错二报错三 此篇博客将介绍spconv、如何安装spconv 1.x和spconv2.x，以及遇到的各种报错处理，更多详细内容可以参考官方的GitHub链接https://github.com/traveller59/spconv。
spconv介绍 spconv为空间稀疏卷积库，一个提供高度优化的稀疏卷积实现和张量核心支持的项目。spconv的设计旨在有效地处理包含大量零元素的稀疏数据，主要用于3D点云的卷积操作。
spconv安装 博主自己的硬件配置如下：
Linux（Ubuntu 20.04）NVIDIA GeForce RTX 3090NVIDIA显卡驱动版本：12.0CUDA version：11.3 首先安装pytorch、cuda等相关软件包：
conda create --name env_name python=3.7 cmake=3.22.1 conda install pytorch==1.10.1 torchvision==0.11.2 torchaudio==0.10.1 cudatoolkit=11.3 -c pytorch -c conda-forge conda install cudnn -c conda-forge conda install boost 打开bashrc文件：vim ~/.bashrc，设置环境变量：
export PATH=/usr/local/cuda/bin:$PATH export CUDA_HOME=/usr/local/cuda/bin:$CUDA_HOME export LD_LIBRARY_PATH=/usr/local/cuda/lib64:$LD_LIBRARY_PATH export C_INCLUDE_PATH=$C_INCLUDE_PATH:/[$YourUserName]/anaconda3/envs/[$YourEnvName]/include export CPLUS_INCLUDE_PATH=$CPLUS_INCLUDE_PATH:/[$YourUserName]/anaconda3/envs/[$YourEnvName]/include export LIBRARY_PATH=$LIBRARY_PATH:/[$YourUserName]/anaconda3/envs/[$YourEnvName]/lib export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/[$YourUserName]/anaconda3/envs/[$YourEnvName]/lib 源码安装spconv 1.x spconv 1.x官方已经舍弃掉不维护了，推荐使用spconv 2.x。而且spconv 2.x相较于spconv 1.x做了优化，速度、效率等有所提升。若由于版本需要，不得不需要安装spconv 1.x，则需要源码编译安装。
下面是官方给出的安装spconv 1.2.1的步骤：
# STEP 1: get source code git clone https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b04752dac9e389fc82bc24a628b61e12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e3d64d29ae8a9e34e27ed016bad6668/" rel="bookmark">
			2024 年 DevOps 会是什么样子？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		过去两年的特点是科技公司大幅裁员。随着亚马逊、Meta 和谷歌等公司的大规模裁员成为各大头条新闻，科技行业在疫情期间释放资本并实现强劲增长，这种“花钱、快速增长”的思维模式正在发生普遍转变。游戏的名称是在支出上更加保守，这种心态将推动明年的大量投资。虽然这些成本压力可能对技术组织来说具有挑战性，但也存在一些关键机遇。许多趋势正在开始、维持和结束，因此让我们重点关注 2024 年及以后可能推动行业变革的六大趋势。
1. 人工智能——特别是生成式人工智能——在技术成熟度曲线上向右移动 虽然人工智能并不新鲜，但 OpenAI 和 ChatGPT 创造了一个令人惊叹的易于访问且功能强大的工具，旨在推动大量价值。炒作周期仍在全面展开，每天都有数十种该技术的新用途进入市场，如果您不尝试构建支持人工智能的生成产品，那么您会被问到何时开始。到 2024 年，我们可能会看到法学硕士进入幻灭的低谷，因为过高的期望和项目并未全部实现。然而，那些拥有真正为用户提供价值的生成式人工智能产品的组织应该会看到巨大的增长。技术组织需要对人工智能产品做出艰难的决定。你要么会在明年找到吸引力并看到巨大的增长，要么很快发现它不起作用并将焦点转移回非人工智能产品。
2. 开发者体验获得动力 虽然 DX 已被讨论多年，但我们看到了对增强开发人员能力的工具的新投资。这一趋势的部分原因是需要减少工程团队的工具和系统蔓延，增强团队能力，让他们更快地行动并提高效率。虽然您可能不会构建或购买 DX 平台，但您可能会成立一个 DX 团队或委员会来更好地代表构建您的软件的人员。这将导致一些重大的内部变化和关键效率得到以前可能被忽视的关注。这种趋势的美妙之处在于，它既提高了组织的效率，又让开发人员的生活变得更轻松。这是双赢的！
3. 降低成本的压力加大 即使对于避免裁员的组织来说，大多数组织也面临着转向精简的压力。这通常意味着批判性地审视所有支出来源并开展新项目来优化它们。也许云重新平台可以减少 20% 的托管支出，或者您可能开始考虑删除或组合 SaaS 工具以减少席位。您甚至可能会看到关键团队的招聘冻结。组织必须接受其他趋势，以提高团队的效率，以满足这里的业务需求。如果听到“少花钱多办事”成为办公室里的口头禅，请不要感到惊讶。
4. 通过数据增强问责制 虽然技术组织的数据平台不断增长，但团队发现仅衡量一些指标是不够的。组织将越来越多地被要求使用他们拥有的数据来证明他们正在提供价值。部分由于上述压力的增加，团队需要变得更加可预测，并且更好地识别和处理开发每个阶段的风险。仅仅构建一个出色的开发引擎已经不够了，团队必须确保该引擎能够为他们提供动力到达目的地。
5. 科技领域的 ESG 对技术领域 DEI 的关注仍然需要大量投资，但是，组织开始考虑更广泛的社会责任。这包括考虑环境影响或服务器的碳排放，到改变软件供应链以避免支持特定组织。这些类型的需求在软件开发过程中出现得更快、更明显，并且可能会显着影响团队选择构建或实现软件的方式。
6.DevSecOps 持续增长 近年来，在一些严重攻击暴露了软件供应链中的漏洞之后，人们重新开始关注安全性。毫不奇怪，安全性现在已被写入我们构建和交付软件的结构中。现在，团队需要考虑从产品规划到生产运营的所有开发阶段的安全性，并需要额外的专家、培训和资源来监控和确保合规性。随着最后残余的本地解决方案的消失，对 SaaS 产品的要求不断发展，团队应该做好准备，在发现新威胁并需要修补时迅速采取行动。
随着科技行业为 2024 年做准备，创新和适应显然将成为成功的关键。从人工智能的持续发展和对开发人员体验的日益关注，到降低成本、通过数据增强问责制、采用 ESG 实践并通过 DevSecOps 加强安全性的迫切需要，技术组织面临着令人兴奋的未来。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c6a520aeedfe04bf72aa6c5b2147733/" rel="bookmark">
			FiddlerScript获取当前电脑的IP地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可以通过如下代码在 Fiddler 脚本中获取到本地的 IP 地址：
第一步，导入需要用到的类。 import System.Net; 第二步，通过如下代码获取到本地 IP 地址。 // 获取本机的IP地址，通常是内网地址 var host = Dns.GetHostEntry(Dns.GetHostName()); var ip = host.AddressList[1];// AddressList 是一个数组，第一个值是IPv6地址，第二个值是IPv4地址 FiddlerObject.alert(ip);// 显示IP 注：实际上是应用了 C# 的 API。参考地址：C#**本机IP地址的4种方式。
显示获取到的本地 IP 如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53b44538b8278acd9fbf8a6fc2281b93/" rel="bookmark">
			Mac zotero 7
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Zotero Beta Zotero 7 参考 Zotero Beta Builds 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f41779c8954a515a78774ae21f5bb7f5/" rel="bookmark">
			​LeetCode解法汇总2645. 构造有效字符串的最少插入数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录链接： 力扣编程题-解法汇总_分享+记录-CSDN博客 GitHub同步刷题项目： https://github.com/September26/java-algorithms
原题链接：. - 力扣（LeetCode） 描述： 给你一个字符串 word ，你可以向其中任何位置插入 "a"、"b" 或 "c" 任意次，返回使 word 有效 需要插入的最少字母数。
如果字符串可以由 "abc" 串联多次得到，则认为该字符串 有效 。
示例 1：
输入：word = "b" 输出：2 解释：在 "b" 之前插入 "a" ，在 "b" 之后插入 "c" 可以得到有效字符串 "abc" 。 示例 2：
输入：word = "aaa" 输出：6 解释：在每个 "a" 之后依次插入 "b" 和 "c" 可以得到有效字符串 "abcabcabc" 。 示例 3：
输入：word = "abc" 输出：0 解释：word 已经是有效字符串，不需要进行修改。 提示：
1 &lt;= word.length &lt;= 50word 仅由字母 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f41779c8954a515a78774ae21f5bb7f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9981f2c1b39d40ee49f14db9aef04e14/" rel="bookmark">
			城市分站系统与站群系统的区别是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多新手用户对城市分站系统和站群系统概念是比较模糊的，他们的适用场景，配套设施，功能到底是什么样的，有什么区别？本篇文章为了解开大家的疑惑系统的介绍下：
1、适用场景
城市分站系统：适用于生产型企业，本地服务类型的公司
站群系统：适用于中大型集团，学校，政府机关单位，招商加盟类型的公司
2、功能
城市分站系统：
1）一个主域名，无限二级域名或二级目录城市分站
2）城市分站栏目不能独立，内容可以独立也可以和主站内容一致加上地区前缀
3）主站和分站的模板都是同一个
站群系统
1）一个主域名，子站顶级域名不限制
2）子站数据可以复制主站，也可以独立栏目和数据自成站点
3）主站和子站的模板可以不是同一个，每个子站的模板都可以不一样
3、配套
城市分站系统
1）多站点管理平台：开通后可以使用SEO监控系统（收录、排名），文章组合自动发布，文章采集自动发布，外链发布等多个SEO自动化功能
2）saas小程序平台：开通后可以在线创建微信+百度+支付宝+抖音+头条+QQ六大小程序平台，数据完全同步网站和电脑网站+平板网站+手机网站+微官网形成10合1体系
站群系统
1）没有SEO自动化功能
2）没有小程序功能
总结：城市分站系统的配套要比站群系统完善
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd92963809199ad6203553e4f50a4ae0/" rel="bookmark">
			Jetpack CameraX
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Jetpack CameraX概述添加依赖库使用预览拍照录视频 代码下载文档 Jetpack CameraX 概述 CameraX 是一个 Jetpack 库，旨在帮助您更轻松地开发相机应用。如果您要开发新应用，我们建议您从 CameraX 开始。它提供了一个一致且易于使用的 API，该 API 适用于绝大多数 Android 设备，并向后兼容 Android 5.0（API 级别 21）。
添加依赖库 // CameraX core library using the camera2 implementation def camerax_version = "1.2.0-alpha02" //1.2.0-alpha02 // The following line is optional, as the core library is included indirectly by camera-camera2 implementation "androidx.camera:camera-core:${camerax_version}" implementation "androidx.camera:camera-camera2:${camerax_version}" // If you want to additionally use the CameraX Lifecycle library implementation "androidx.camera:camera-lifecycle:${camerax_version}" // If you want to additionally use the CameraX VideoCapture library implementation "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd92963809199ad6203553e4f50a4ae0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcaac64b5d6fc3c6461610d924f6bc13/" rel="bookmark">
			【C&#43;&#43;题解】传球游戏(ball)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目链接：https://gmoj.net/junior/#main/show/1116 题目描述 上体育课的时候，小蛮的老师经常带着同学们一起做游戏。这次，老师带着同学们一起做传球游戏。
游戏规则是这样的：n个同学站成一个圆圈，其中的一个同学手里拿着一个球，当老师吹哨子时开始传球，每个同学可以把球传给自己左右的两个同学中的一个（左右任意），当老师再次吹哨子时，传球停止，此时，拿着球没传出去的那个同学就是败者，要给大家表演一个节目。
聪明的小蛮提出一个有趣的问题：有多少种不同的传球方法可以使得从小蛮手里开始传的球，传了m次以后，又回到小蛮手里。两种传球的方法被视作不同的方法，当且仅当这两种方法中，接到球的同学按接球顺序组成的序列是不同的。比如有3个同学1号、2号、3号，并假设小蛮为1号，球传了3次回到小蛮手里的方式有1-&gt;2-&gt;3-&gt;1和1-&gt;3-&gt;2-&gt;1，共2种。
输入 输入文件ball.in共一行，有两个用空格隔开的整数n，m（3&lt;=n&lt;=30，1&lt;=m&lt;=30）。
输出 输出文件ball.out共一行，有一个整数，表示符合题意的方法数。
样例输入 3 3 样例输出 2 数据范围限制 【限制】
40%的数据满足：3&lt;=n&lt;=30，1&lt;=m&lt;=20 ​100%的数据满足：3&lt;=n&lt;=30，1&lt;=m&lt;=30
做法 一道动态规划的题。
我们设 f [ i ] [ j ] f[i][j] f[i][j] 表示第 i i i 次传球传给第 j j j 个人最多有多少种方案。
我们会发现，第 j j j 个人传到球的方案数是由第 j − 1 j-1 j−1 个人和第 j + 1 j+1 j+1 个人传来的，则动态转移方程为 f [ i ] [ j ] = f [ i − 1 ] [ j − 1 ] + f [ i − 1 ] [ j + 1 ] f[i][j]=f[i-1][j-1]+f[i-1][j+1] f[i][j]=f[i−1][j−1]+f[i−1][j+1] 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcaac64b5d6fc3c6461610d924f6bc13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78368806bcdc99f1bf29ef5a4b73546b/" rel="bookmark">
			Redis：原理速成&#43;项目实战——Redis实战10（Redis消息队列实现异步秒杀）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		👨‍🎓作者简介：一位大四、研0学生，正在努力准备大四暑假的实习
🌌上期文章：Redis：原理速成+项目实战——Redis实战9（秒杀优化）
📚订阅专栏：Redis：原理速成+项目实战
希望文章对你们有所帮助
上一节已经实现了异步秒杀，也就是将秒杀分为两个环节：
1、判断是否有抢单资格（库存量是否充足、是否满足一人一单）、
2、下单操作（优惠券表中的库存量-1，订单表增加相应信息）
其中，第一步的操作放在了Redis中，可以有效提高效率，而真正大幅度提高效率的点还是因为我们将下单的操作交给了另一个开辟的线程，因为对数据库的操作并不需要什么时效性。
异步执行所需要的信息被封装并保存到了阻塞队列中，上一节分析了这会造成的问题：
1、内存限制问题
2、数据安全问题
消息队列可以解决这个问题，一般建议用专业的消息中间件来使用，最主流的当然就是RabbitMQ了，但是这边也讲解一下用Redis里面的一些数据结构来模拟出消息队列的效果，实现的话我感觉也挺容易的，只演示基于Stream消息队列实现异步秒杀。
Redis消息队列实现异步秒杀 认识消息队列基于List实现消息队列PubSub实现消息队列Stream的单消费模式Stream的消费者组模式基于Stream消息队列实现异步秒杀 认识消息队列 消息队列，也就是存放消息的队列，最简单的消息队列包括3个角色：
（1）消息队列（代理）：存储和管理信息
（2）生产者：发消息到消息队列
（3）消费者：从消息队列中获取消息并处理
因此，异步秒杀的思路为：
这个思路与上一节用阻塞队列的思路是差不多的，但是有2点重要区别：
1、消息队列是JVM以外的独立服务，不受JVM内存的限制
2、消息队列不仅仅做数据存储，还确保了数据安全，存到消息队列中的消息会做持久化处理，并要求消费者要做出消息的确认，否则会持续将消息传递给消费者，确保消息至少被“签收”一次
基于List实现消息队列 List是一种双向链表，很容易模拟出队列。
需要注意的是，当消息队列中没有消息的时候，我们应当要让线程等待，而不是直接返回Null，因此这儿要用BRPOP与BLPOP来实现阻塞效果（B表示阻塞）
优点：
（1）利用Redis存储，不受限于JVM内存上限
（2）基于Redis的持久化机制，保证数据安全性
（3）满足消息有序性
缺点：
（1）无法避免消息丢失（消息会从队列直接移除）
（2）只支持单消费者
PubSub实现消息队列 PubSub（发布订阅）是Redis2.0引入的，消费者可以订阅一个或多个channel（频道），生产者向对应channel发送消息后，所有订阅者都能收到相关消息。
优点：采用发布订阅模型，支持多生产、多消费
缺点：
（1）不支持数据持久化
（2）无法避免消息丢失
（3）消息堆积有上线，超出时数据丢失
Stream的单消费模式 Stream是Redis5.0引入的一种新数据类型，可以实现功能完善的消息队列。
例如：
读取消息：XREAD
例如，用XREAD读第一个消息：
XREAD COUNT 1 STREAMS users 0
用XREAD阻塞方式读取最新消息：
XREAD COUNT 1 BLOCK STREAMS users $
所以，在开发的时候，可以循环调用XREAD阻塞方式来查询最新消息，从而实现持久监听队列。
但是，当指定起始ID为$读取最新消息，处理一条消息的过程中，又有超过1条以上的消息到达队列，则下次获取也只能获取到最新的一条，会出现消息漏读。
特点：
（1）消息可回溯
（2）一个消息可以被多个消费者读取
（3）可以阻塞读取
（4）有消息漏读的风险
Stream的消费者组模式 这一部分命令还是麻烦了，理解就行，要使用就去看文档就好了。
消费者组可以解决消息漏读的问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78368806bcdc99f1bf29ef5a4b73546b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36c2e46ac0ff50e51cfcc6f29160cc8a/" rel="bookmark">
			在线图表编辑工具Draw.io本地部署并结合内网穿透实现远程协作办公
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 提到流程图，大家第一时间可能会想到Visio，不可否认，VIsio确实是功能强大，但是软件为收费，并且因为其功能强大，导致安装需要很多的系统内存，并且是不可跨平台使用。所以，今天给大家推荐一款更实用的流程图软件—— Draw.io在线绘图工具。
其实，除了写代码，画图也是每个程序员必备的技能之一，我们经常接触有流程图、架构图等等。而且Draw.io结合cpolar内网穿透工具还可以增加共享和协作功能，提升团队工作效率，那么本篇文章就来教大家如何在docker部署drawio绘图工具并且实现公网远程访问。
Docker本地部署在线绘图工具Draw.io并实现公网远程访问
1. 使用Docker本地部署Drawio 启动docker,运行容器
docker run -it --rm --name="draw" -p 8080:8080 -p 8443:8443 jgraph/drawio 启动 Web 浏览器会话到http://localhost:8080/?offline=1&amp;https=0或https://localhost:8443/?offline=1
可以看到在docker本地部署了draw.io，进入到了绘画作图界面。
2. 安装cpolar内网穿透工具 上面我们在docker中成功安装了draw.io,并局域网成功访问，下面我们安装cpolar内网穿透工具,通过cpolar 转发本地端口映射的http公网地址,我们可以很容易实现远程访问,而无需自己注册域名购买云服务器.下面是安装cpolar步骤
cpolar官网地址: https://www.cpolar.com
使用一键脚本安装命令 curl -L https://www.cpolar.com/static/downloads/install-release-cpolar.sh | sudo bash 向系统添加服务 sudo systemctl enable cpolar 启动cpolar服务 sudo systemctl start cpolar cpolar安装成功后，在外部浏览器上访问Linux 的9200端口即:【http://局域网ip:9200】，使用cpolar账号登录,登录后即可看到cpolar web 配置界面,结下来在web 管理界面配置即可
3. 配置Draw.io公网访问地址 点击左侧仪表盘的隧道管理——创建隧道，创建一个Draw.io的cpolar 公网地址隧道
隧道名称：可自定义命名，注意不要与已有的隧道名称重复协议：选择http本地地址：8080 (局域网访问的端口)域名类型：免费选择随机域名地区：选择China 点击创建
隧道创建成功后，点击左侧的状态——在线隧道列表,查看所生成的公网访问地址，有两种访问方式,一种是http 和https
4. 公网远程访问Draw.io 使用上面的cpolar https公网地址在任意设备的浏览器访问,即可成功看到我们Draw.io的绘图界面，这样一个公网地址且可以远程访问就创建好了，无需自己购买云服务器,即可发布到公网访问。
由于以上使用cpolar所创建的隧道使用的是随机公网地址，24小时内会随机变化，不利于长期远程访问。
我一般会使用固定二级子域名，原因是我希望将网址发送给同事时，它是一个固定、易记的公网地址（例如：drawio.cpolar.cn），这样更显正式，便于绘图交流协作。因此我们可以为其配置二级子域名，该地址为固定地址，不会随机变化【ps：cpolar.cn已备案】
注意需要将cpolar套餐升级至基础套餐或以上，且每个套餐对应的带宽不一样。【cpolar.cn已备案】
登录cpolar官网，点击左侧的预留，选择保留二级子域名，设置一个二级子域名名称，点击保留,保留成功后复制保留的二级子域名名称
保留成功后复制保留成功的二级子域名的名称
返回登录cpolar web UI管理界面，点击左侧仪表盘的隧道管理——隧道列表，找到所要配置的隧道，点击右侧的编辑
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36c2e46ac0ff50e51cfcc6f29160cc8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65cb98cd45c4c9e4289d1fe0551fcbd5/" rel="bookmark">
			Centos安装Datax
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Centos7安装DataX 一、DataX简介二、DataX的数据源支持三、安装DataX1、下载DataX2、解压3、检验是否安装成功4、使用 四、实践案例1、环境信息2、编写同步的配置文件(user_info.json)3、执行同步4、验证同步结果 一、DataX简介 DataX 是阿里云 DataWorks数据集成 的开源版本，在阿里巴巴集团内被广泛使用的离线数据同步工具/平台。DataX 实现了包括 MySQL、Oracle、OceanBase、SqlServer、Postgre、HDFS、Hive、ADS、HBase、TableStore(OTS)、MaxCompute(ODPS)、Hologres、DRDS, databend 等各种异构数据源之间高效的数据同步功能。
源码地址点这里
二、DataX的数据源支持 DataX目前已经有了比较全面的插件体系，主流的RDBMS数据库、NOSQL、大数据计算系统都已经接入，目前支持数据如下图：
类型数据源Reader(读)Writer(写)文档RDBMS 关系型数据库MySQL√√读 、写Oracle√√读 、写OceanBase√√读 、写SQLServer√√读 、写PostgreSQL√√读 、写DRDS√√读 、写Kingbase√√读 、写通用RDBMS(支持所有关系型数据库)√√读 、写阿里云数仓数据存储ODPS√√读 、写ADB√写ADS√写OSS√√读 、写OCS√写Hologres√写AnalyticDB For PostgreSQL√写阿里云中间件datahub√√读 、写SLS√√读 、写图数据库阿里云 GDB√√读 、写Neo4j√写NoSQL数据存储OTS√√读 、写Hbase0.94√√读 、写Hbase1.1√√读 、写Phoenix4.x√√读 、写Phoenix5.x√√读 、写MongoDB√√读 、写Cassandra√√读 、写数仓数据存储StarRocks√√读 、写ApacheDoris√写ClickHouse√√读 、写Databend√写Hive√√读 、写kudu√写selectdb√写无结构化数据存储TxtFile√√读 、写FTP√√读 、写HDFS√√读 、写Elasticsearch√写时间序列数据库OpenTSDB√读TSDB√√读 、写TDengine√√读 、写 三、安装DataX 1、下载DataX 在源码中可以下载到DataX安装包：datax.tar.gz。
2、解压 tar -zxvf datax.tar.gz 3、检验是否安装成功 # 如下路径更换为自己的路径 python /wz_program/datax/bin/datax.py /wz_program/datax/job/job.json 出现如下内容则说明已安装成功：
4、使用 DataX使用只需要根据自己同步的数据的数据源与数据的目的地选择对应的Reader和Writer，将Reader和Writer信息配置到一个json文件中，然后执行同步命令即可完成数据同步。
四、实践案例 描述：将mysql数据库user_info表中的1500条数据同步到HDFS的/user_info中（HDFS需要提前安装好）。
1、环境信息 mysql信息如下：
CREATE TABLE `user_info` ( `id` int NOT NULL AUTO_INCREMENT, `user_id` int NOT NULL, `username` varchar(255) NOT NULL, `email` varchar(255) NOT NULL, `phone_number` varchar(30) DEFAULT NULL, `status` enum('active','inactive') DEFAULT 'active', `score` int unsigned DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=16280 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci HDFS信息如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65cb98cd45c4c9e4289d1fe0551fcbd5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f49c300528e10434bd1051ee5392146/" rel="bookmark">
			2024最新面试经验分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 重点掌握的知识点JavaMySQLRedis 微服务分布式系统项目亮点场景题/设计题短链抢红包多租户 开放性问题自我介绍为什么跳槽团队规模如何带团队如何看待加班职业规划 主要针对Java程序员，当然也包含一些通用的内容。 重点掌握的知识点 需要重点掌握的知识点必须是当下最流行、最热门、面试被问到的概率最高的知识点，把时间花在掌握这些知识点上的收益最高，不要去研究冷门知识。
Java HashMap
ConcurrentHashMap
垃圾回收
线程池
arthas
定位OOM
这几个是有代表性的，其他基础知识自不必多说，是需要掌握的。很多衍生出来的知识点，能多覆盖就多覆盖。再举几个例子：
死锁sleep和wait的区别怎么定位CPU占用高的问题（top -h或者arthas）CMS和G1回收器的特点 MySQL 中间件方面，MySQL和Redis被问到的概率最高，因为这两个应用最广泛。首先说下MySQL，MySQL最容易被问到的知识点如下：
索引相关的，例如索引的数据结构B+树，如何创建高效的索引，哪些情况下索引会失效等。利用explain+SQL语句查看SQL的执行计划，有哪些指标，该如何理解和分析。MySQL主从复制和读写分离的实现。 其他的，事务、锁、并发问题被问到的概率小一些。
B+树
索引下推
锁和事务的并发问题
读写分离
分库分表
Redis Redis中经常会考察的知识点如下：
缓存穿透、缓存击穿、缓存雪崩如何删除BigKey持久化缓存淘汰策略主从复制或者哨兵模式集群，一致性Hash算法跳表、布隆过滤器 面试题
微服务 spring cloud和spring cloud alibaba都行，要熟悉每个组件的作用，里面最容易被拿来问问题的是限流、熔断、降级相关的知识点，如果你用的是spring cloud的，可以重点熟悉下Hystrix。
Hystrix要点总结
Hystrix详细介绍
分布式系统 分布式系统最经典的就是一致性问题，关于一致性的几个理论要知道。
分布式事务
分布式锁
分布式ID
项目亮点 项目亮点通常有几种提问方式：
你项目中解决的最复杂的问题你觉得最有挑战性的功能你有没有解决过某个问题，是怎么解决的 针对这些提问，可以结合自己的业务场景准备一些案例来作答，比如es的优化场景、利用redis缓存app数据并解决缓存失效的各种问题、mysql慢查询优化等等。回答这些问题时，有几个要点：
一定不能掺和太多业务上的东西进去，否则面试官光理解你的业务场景就要花很长时间，可能最后还没搞懂，然后不欢而散。这个问题的答案尽量多跟技术沾边，最好是通用的技术，否则面试官可能没兴趣了解。捡要点说，如果怕自己说不清楚，可以提前写下来，然后理解性记忆。 我的几个案例都来自我平时的工作总结：
es性能优化
Java程序内存优化
另外，回答这类问题可以套用STAR法则（Situation Task Action Result）。
场景题/设计题 短链 短链
抢红包 红包
多租户 参考1
参考2
开放性问题 自我介绍 叫什么，毕业于哪个学校，多少年经验，目前就职于哪家公司，公司主要是做啥的，你在公司主要是做啥的，项目特点（web项目？分布式项目？大数据实时分析项目），业余写博客？刷leetcode？写开源项目？
为什么跳槽 不要说公司和同事坏话，也不要抱怨自己工资低。
团队规模 目前人数少的话，可以按照高峰期的说。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f49c300528e10434bd1051ee5392146/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/595711d9b58fd1ce5c798aa0540d5469/" rel="bookmark">
			微信小程序获取来源场景值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/scene.html#返回来源信息的场景
https://developers.weixin.qq.com/miniprogram/dev/api/base/app/life-cycle/wx.getLaunchOptionsSync.html
场景值列表
只有1008是来源群聊
/** * 生命周期函数--监听页面显示 */ onShow() { const launchOps = wx.getLaunchOptionsSync(); console.error(launchOps); if (launchOps.scene === 1008) { this.setData({ isFromGroup: true }) } }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1b8979bc69b7042324faa608bd8988f/" rel="bookmark">
			实战营｜阿里云 x StarRocks 邀你现场体验云上极速湖仓--深圳站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介： 1月20日深圳阿里中心，阿里云 x StarRocks 邀你现场体验云上极速湖仓实战营，从 0-1 轻松上手 StarRocks 湖仓分析。
StarRocks 自 3.0 大版本起，实现了从计算 OLAP 分析到统一 Lakehouse 的重大产品能力升级。通过存算分离架构，帮助用户降低存储成本、提升计算弹性；通过数据湖分析、物化视图等特性简化湖仓融合，实现极速统一湖仓分析。
EMR Serverless StarRocks 是阿里云提供的全托管服务，具备高性能、全场景、极速统一的数据分析体验，以及开箱即用、弹性扩展、监控管理、慢 SQL 诊断分析等全生命周期能力。内核 100% 兼容 StarRocks，性能相比传统 OLAP引擎提升 3-5 倍，助力企业高效构建多维分析、数据湖分析、高并发查询及实时分析等大数据应用。
新年伊始，阿里云 EMR OLAP 团队与 StarRocks 社区联合共赴深圳，与镜舟科技、阿里云 EMR、轻喜到家等行业专家共话云上 StarRocks，共同开启新一年的数据分析之旅！本次活动的实操部分将会利用 EMR Serverless StarRocks 环境进行演练，想从 0-1 快速利用 StarRocks 进行湖上分析的小伙伴们请尽快报名～
立即报名 &gt;&gt;
活动亮点
超多实用干货，本场 Meetup 从 StarRocks 湖仓一体的关键特性到 Serverless StarRocks 产品功能，更有轻喜到家带来一手基于EMR StarRocks 构建实时分析平台的经验。StarRocks 湖仓实战初体验，带你体验极速湖分析和存算分离 EMR 部署。你可以通过 Hive Catalog 外表访问 Hive 中的数据，在不迁移数据的前提下就能轻松跑通 TPCDS 标准测试集；此外，还可以在 Flink 作业中使用 Java 代码生成模拟行为数据，通过 Flink Connector 导入 StarRocks，再通过物化视图进行数据 ETL，实现数据指标分层，完成多维分析平台建设。线下线上同步开启，深圳小伙伴可参与线下 Meetup 面对面交流，异地也可在线观看直播以及线上参加 WorkShop，精彩内容不错过。丰富周边等你拿，报名参加就有机会获得阿里云EMR 社区、StarRocks 社区定制的精美周边。 活动时间：2024/1/20（星期六）14:00-17:00
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1b8979bc69b7042324faa608bd8988f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83c732db554e5e84619c8b0694216717/" rel="bookmark">
			高级交换学习试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 高级交换学习试题一.高级交换题目答案 二.STP 相关答案单选答案 三.VLAN答案 四.园区网概述答案 高级交换学习试题 一.高级交换题目 1．当前构建局域网主要采用的设备是( )。
A．集线器
B．交换机
C. 路由器
D．服务器
2．大型局域网通常分为( )。
A．核心层
B．汇聚层
C．接人层
D．网络层
3．大型局域网的核心层网络常见的组网结构有( )。
A．单核心组网
B．双机主备互连
C．多机环网互连
D．Full-Mesh互连
4．大型局域网中常见的冗余备份技术有( )。
A．VRRP
B．MSTP
C．Smart Link
D．动态路由协议
5.接入层网络的常用安全接入认证技术有( )。
A．802. lx认证
B.MAC集中认证
C．端口安全
D Voice VLAN
6.大型园区网的网络结构必须采用常见的树形结构。( )
答案：错
7．最适合于双归属网络的冗余备份协议是( )。
A. STP
B. RRPP
C. Smart Link
D. VRRP
IRF冗余备份技术不仅实现了链路级的备份，也实现了设备级的备份。( )
IP网络中组播业务的部署包含哪些重要协议？( )
A. PIM
B.RPF
C.IGMP
D.GMRP
IP语音业务部署的重要措施有( )。 A. PoE
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83c732db554e5e84619c8b0694216717/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fb2fe588eb4442c4782341507a37ec2/" rel="bookmark">
			基于 Spring Boot 支付宝沙箱支付（Java 版本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于 Spring Boot 支付宝沙箱支付（Java 版本） 步骤第一步：使用支付宝账户登录，打开控制台，进入沙箱环境第二步：配置内网穿透账号第三步：引入支付宝 SDK第四步： 配置 SpringBoot第五步： AliPayConfig.java 读取配置第六步： AliPayController 步骤 第一步：使用支付宝账户登录，打开控制台，进入沙箱环境 打开沙箱地址：https://open.alipay.com/develop/sandbox/app
需要获取：AppId、支付宝网关地址、应用私钥、支付宝公钥
第二步：配置内网穿透账号 注册 https://natapp.cn/
购买免费隧道
注意：需要记住这个 authtoken，配置文件用得到
配置隧道
文件 config 配置
#将本文件放置于natapp同级目录 程序将读取 [default] 段 #在命令行参数模式如 natapp -authtoken=xxx 等相同参数将会覆盖掉此配置 #命令行参数 -config= 可以指定任意config.ini文件 [default] authtoken= 将隧道的authtoken填进去 #对应一条隧道的authtoken clienttoken= #对应客户端的clienttoken,将会忽略authtoken,若无请留空, log=none #log 日志文件,可指定本地文件, none=不做记录,stdout=直接屏幕输出 ,默认为none loglevel=ERROR #日志等级 DEBUG, INFO, WARNING, ERROR 默认为 DEBUG http_proxy= #代理设置 如 http://10.123.10.10:3128 非代理上网用户请务必留空 配置文件需要与 natapp 放在同级目录下
启动 natapp
为什么要使用 NATAPP？
因为要把本地的服务暴露到公网，让支付宝可以调用我们的接口给我们传递数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fb2fe588eb4442c4782341507a37ec2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/068b7c3d7e4f04a35bbcb8a724d4555f/" rel="bookmark">
			如何使用vite框架封装一个js库，并发布npm包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言介绍
一、创建一个vite项目
1、使用创建命令：
2、选择others
3、 模板选择library
4、选择开发语言
​编辑 二、安装依赖
三、目录介绍
1、vite.config.ts打包文件
2、package.json命令配置文件
三、发布npm
1、注册npm账号
2、设置npm源
3、登录到npm
4、推送到npm仓库
5、查看npm包
前言介绍 最近，公司项目上需要把很多公用函数封装起来，作为一个公共的库使用。以前的做法是使用webpack或者Rollup。Rollup和Webpack都是常用的JavaScript模块打包工具，用于构建现代化的Web应用程序。但是，不管是webpack或者Rollup配置起来都很复杂，使用起来不是顺手。
经过一番折腾，发现vite也可以。大多数同学可能使用vite作为脚手架去构建vue、react开发应用。其实，vite也可以作为JavaScript模块打包工具，构建一个JavaScript库，并且使用起来容易上手，配置也简单，打包速度很快，并发布到npm上。
Vite是一种新型前端构建工具，能够显著提升前端开发体验。它主要由两部分组成：
一个开发服务器，它基于 原生 ES 模块 提供了 丰富的内建功能，如速度快到惊人的 模块热更新（HMR）。
一套构建指令，它使用 Rollup 打包你的代码，并且它是预配置的，可输出用于生产环境的高度优化过的静态资源。
Vite 是一种具有明确建议的工具，具备合理的默认设置。您可以在 功能指南 中了解 Vite 的各种可能性。通过 插件，Vite 支持与其他框架或工具的集成。如有需要，您可以通过 配置部分 自定义适应你的项目。
Vite 还提供了强大的扩展性，可通过其 插件 API 和 JavaScript API 进行扩展，并提供完整的类型支持。其他的关于vite的介绍欢迎同学上官网去学习。下面咱们直接上手。
一、创建一个vite项目 1、使用创建命令： pnpm create vite 这里不要选择开发框架而是选择Others 。如下图所示：
2、选择others 3、 模板选择library 这library的意思是软件库，正好我们开发的就是一个软件库。
4、选择开发语言 开发语言这里选择Typescript.
二、安装依赖 pnpm install 依赖安装完毕后，一个js库开发环境就搭建起来了。
三、目录介绍 1、vite.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/068b7c3d7e4f04a35bbcb8a724d4555f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6678512715d6e56eac22c97e0c0f0a2c/" rel="bookmark">
			Python实现京东茅台抢购脚本, 原来这样就可以了?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 登录京东账号2. 进入茅台商品页面3.添加商品到购物车4. 进入购物车结算页面5. 提交订单 京东茅台抢购脚本可以分为以下几部分，具体实现步骤如下：
1. 登录京东账号 首先需要登录京东账号。一个简单的方式是使用Python的 selenium 库。在使用 selenium 库前，需要安装 selenium 库和对应的浏览器驱动。
示例代码如下所示：
from selenium import webdriver browser = webdriver.Chrome() # 初始化浏览器 browser.get('https://www.jd.com/') # 打开京东首页 # 用户登录，填写用户名和密码 username = browser.find_element_by_id('username') username.send_keys('your_username') password = browser.find_element_by_id('password') password.send_keys('your_password') submit = browser.find_element_by_id('loginBtn') submit.click() 注意：在使用 selenium 的时候，要配置对应的浏览器驱动，这里我选择的是 Chrome 浏览器，所以需要下载 Chrome 浏览器驱动并添加到系统环境变量中。
2. 进入茅台商品页面 登录后需要进入茅台商品页面，获取商品链接。
browser.get('https://item.jd.com/100012043978.html') # 进入茅台商品的页面`` 3.添加商品到购物车 找到“抢购”按钮，并点击操作，将商品加入到购物车中。
submit = False # 在规定时间内不停地尝试点击购买，直到提交订单 while not submit: browser.refresh() try: # 找到抢购按钮 button = browser.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6678512715d6e56eac22c97e0c0f0a2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51e8cfbeb1d6fd5392f72796ec67044a/" rel="bookmark">
			使用PowerDesigner 15对现有数据库进行生成物理模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载：使用PowerDesigner 15对现有数据库进行生成图表结构 - LS庆 - 博客园
PowerDesigner的安装和基本使用，我就不阐述了。大家可以到这里看看：PowerDesigner使用教程|使用方法 - 学习博客 - BlogJava
一、配置数据库源
1、在对数据库表进行导出生成到PowerDesigner之前，需要对对即将操作的数据库进行配置数据源：启动PowerDesigner 15，
在菜单中选择Database-&gt;Congfigure Connections 弹出Congfigure Data Connections 对话框。
2、点击Add Data source 按钮，弹出创建新数据源对话框，选择系统数据源：
3、下一步，选择数据源驱动程序，这里我选择Sql Server，继续下一步：
4、下一步，完成配置，点击“完成”，弹出创建到Sql Server的新数据源，在此对话框中，我们输入名称、描述、及服务器名或IP:
5、下一步，验证登录方式选择“使用用户输入登录ID和密码的SQL Server 验证”，并输入登录ID和密码
6、下一步，勾选“更改默认的数据库为”，选择你想要的数据库
7、下一步完成创建数据源：
8、确定后，可以在Congfigure Data Connections 对话框中看刚才新建的数据源了。
二、配置完数据源后就可以对数据库进行表生成图表
1、在菜单中选择:File-&gt;Reverse Engineer -&gt;Database 出来New Physical Data Model对话框
2、点击“确定”，弹出Database Reverse Engineering Options对话框，选择Using a data source，点击数据源按钮弹出Connection to a Data Source对话框，在下拉框中选择之前建立的数据源 "Test"，并输入User ID和password
3、点击Connection即可连接至数据库，回到Database Reverse Engineering Options对话框，点击确定，弹出Database Reverse Engineering对话框，并得取所有的数据库对象，在此选择需要的Table：
4、最后点击OK，等待生成即可:
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad688913001fe9f60ae5cf3c07f62302/" rel="bookmark">
			Flutter 小技巧之优化使用的 BuildContext
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载链接：Flutter 小技巧之优化使用的 BuildContext_51CTO博客_flutter开发技巧
Flutter 里的 ​​BuildContext​​​ 相信大家都不会陌生，虽然它叫 Context，但是它实际是 Element 的抽象对象，而在 Flutter 里，它主要来自于 ​​ComponentElement​​ 。
关于 ​​ComponentElement​​ 可以简单介绍一下，在 Flutter 里根据 Element 可以简单地被归纳为两类：
​​RenderObjectElement​​​ ：具备​​RenderObject​​ ，拥有布局和绘制能力的 Element
​​ComponentElement​​​ ：没有​​RenderObject​​​ ，我们常用的​​StatelessWidget​​​ 和​​StatefulWidget​​​ 里对应的​​StatelessElement​​​ 和​​StatefulElement​​ 就是它的子类。
所以一般情况下，我们在 ​​build​​​ 方法或者 State 里获取到的 ​​BuildContext​​​ 其实就是 ​​ComponentElement​​ 。
那使用 ​​BuildContext​​ 有什么需要注意的问题？
首先如下代码所示，在该例子里当用户点击 ​​FloatingActionButton​​​ 的时候，代码里做了一个 2秒的延迟，然后才调用 ​​pop​​ 退出当前页面。
class _ControllerDemoPageState extends State&lt;ControllerDemoPage&gt; { @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar(), floatingActionButton: FloatingActionButton( onPressed: () async { await Future.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad688913001fe9f60ae5cf3c07f62302/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/728b62ca6c0a561b38c219a06fc53b52/" rel="bookmark">
			Linux操作系统基础(11)：Linux的环境变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 环境变量的介绍 在Linux系统中，环境变量是一种用于存储系统环境信息的特殊变量，包含了系统运行所需的配置信息，以及用户自定义的一些配置信息，甚至影响程序的行为、系统的运行以及用户的工作环境。
#1.输出系统 PATH变量 [root@localhost ~]# echo ${PATH} /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin 在Linux中，常见的系统环境变量包括：
1. PATH：用于指定系统在哪些目录中搜索可执行文件。 2. HOME：指定当前用户的主目录，即用户登录后默认的工作目录。 3. USER：指定当前用户的用户名。 4. SHELL：指定用户默认的Shell程序。 5. LANG：指定系统默认的语言环境。 6. LD_LIBRARY_PATH：用于指定系统在哪些目录中搜索动态链接库文件。 在Linux中，关于系统的变量操作：
set，显示当前Shell中定义的 所有变量，包括环境变量、局部变量等。env，显示当前Shell中定义，只显示 全局变量 的输出。export，用于在当前Shell中 设置环境变量，使其对当前Shell及其子进程生效。unset，用于在Shell中 删除 已定义的变量或函数。 2. 环境变量的类型 2.1. 全局环境变量 全局环境变量是指在整个系统范围内都有效的环境变量，不仅对特定用户有效，对所有用户都有效。
在Linux系统中，全局环境变量通常存储在系统范围的配置文件中，例如：
/etc/profile：Bourne Shell及其衍生Shell的配置文件，在这个文件中设置全局的环境变量。/etc/environment：设置全局环境变量，是以"key=value"的形式，每行设置一个变量。/etc/bash.bashrc：这是Bash Shell的全局配置文件，也可以用于设置全局的环境变量。 一些常见的全局环境变量包括系统默认的变量（如PATH、LANG等），以及系统管理员设置的一些全局配置变量，用于影响系统的整体行为、程序的默认行为等。
2.2. 用户环境变量 用户的环境变量是指在用户登录时，与该用户关联的环境变量。这些变量包括系统默认定义的一些变量，以及用户自定义的一些变量。
在Linux系统中，用户的环境变量通常存储在用户的家目录下的配置文件中，例如：
~/.profile：通用的Shell的配置文件，设置用户级别的环境变量（Centos系统是没有的）。~/.bash_profile：Bash Shell的配置文件，设置用户级别的环境变量。~/.bashrc：用户可以在这个文件中设置自定义的环境变量。 用户的环境变量可以包括一些系统默认定义的变量（如PATH、HOME、USER等），也可以包括用户自定义的一些变量，用于定义用户的个性化工作环境、程序执行的行为等。
2.3. 两者之间的关系 全局环境变量和用户环境变量是两个不同范围的环境变量，它们在系统运行和用户工作环境中都具有重要作用，但是影响范围和设置位置有所不同。
影响范围：全局环境变量影响所有用户，而用户环境变量在用户登陆时关联的环境变量。
设置位置：全局环境变量的配置通常在 /etc 目录下，而用户环境变量通常在 用户家目录。
优先级：在用户登录时，用户的环境变量会覆盖全局环境变量。如果用户设置了与全局环境变量同名的变量，那么用户的设置会覆盖全局设置。
3. 环境变量的设置 3.1. 设置用户变量 在Linux系统中，可以通过用户的profile文件来设置环境变量，用户的profile文件通常用于在用户登录时自动执行一些初始化操作，包括设置环境变量、定义别名、运行特定的命令等。
以下是使用用户的profile文件设置环境变量的基本步骤：
#1.打开用户的profile文件，例如`~/.bash_profile` vi ~/.bash_profile #2.在文件中添加需要设置的环境变量（java环境）例如： export JAVA_HOME=/usr/lib/jvm/java-11 export PATH=$JAVA_HOME/bin:$PATH #3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/728b62ca6c0a561b38c219a06fc53b52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65c75b744c5c137bd8ea172fe68ccf2c/" rel="bookmark">
			FridaHook（三）——AllSafe App wp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		By ruanruan，2022/04/21
文章目录 1、不安全的日志记录2、硬编码3、pin绕过（1）反编译查看方法判断逻辑（2）hook方法A、Hook areEqual(Object,Object)B、Hook checkPin(a) （3）页面效果（4）踩坑 4、root检测绕过（1）反编译查看（2）hook方法（3）绕过效果 5、Secureflag绕过（1）查看相关代码（2）Hook脚本（3）hook效果 6、Deeplink利用（1）查看漏洞代码（2）漏洞利用A、访问html文件B、使用adb构造intent 7、Webview利用（1）查看漏洞代码（2）漏洞利用A、任务一：弹窗B、任务二：访问一个本地文件，如/etc/hosts 8、证书绕过（1）hook脚本（2）hook结果（3）踩坑 9、脆弱的加密（1）反编译查看（2）hook加密函数A、AESB、MD5C、Random 10、本地动态链接库（1）反编译查看（2）so文件查看检测函数代码（3）hook方法（4）hook结果（5）踩坑 1、不安全的日志记录 任务：在日志中找到key
命令查看日志中是否包含输入的key
adb logcat 2、硬编码 任务：查找硬编码user:password
查找到superadmin:supersecurepassword
3、pin绕过 任务：绕过pin检测
其实可以对NDg2Mw==，直接解码得4863
（1）反编译查看方法判断逻辑 查找areEqual方法，如下
（2）hook方法 A、Hook areEqual(Object,Object) 先是去hook了kotlin.jvm.internal.Intrinsics类的重载方法，通过传的first参数数据类型为String可知，调用的是
搜索Equal函数，是返回true or false
那么修改返回为true就行
js：
function hookChongZai(){ var utils = Java.use("kotlin.jvm.internal.Intrinsics"); utils.areEqual.overload('java.lang.Object', 'java.lang.Object').implementation = function(a,b){ console.log(a,b); a = "2022"; b = "2022"; console.log(a,b); var ret = true; return ret; } } function main(){ Java.perform(function(){ hookChongZai(); }) } setImmediate(main); 输出：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65c75b744c5c137bd8ea172fe68ccf2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dc8766a1d8140176c83029feb8c130b/" rel="bookmark">
			记录一次git merge后发现有些文件不对的问题，排查过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分支进行merge（A merge到B）之后，发现string.xml中有些字段的值没有merge过来，一开始还以为自己是自己merge错误，检查了一遍自己的merge操作没有问题。
那为啥没有merge过来呢？有一种可能是，merge之前B的数据就错了。B分支上已经merge 处理过string.xml修改的那条commit，别人后来各种提交和merge，把string.xml改错了。这样就导致我在进行merge后，string.xml中的数据还是错的。
首先证明：“merge之前B的数据就错了”，找到自己merge的那条提交记录，
这个merge提交记录，有两个parents commit，第一个commit就是developer-gpad进行merge之前的最后一条，我们git reset --hard本地回滚到这条记录上。
看一下string.xml文件确实不对。
那developer-gpad分支处理过string.xml应该对的那条commit吗？如果没处理过，说明还是自己merge错了。如果处理过，说明developer-gpad当前就在错误的状态。
我们可以检查处理过string.xml应该对的那条commit的别的文件，有没有在developer-gpad上，在说明处理过这个commit了，说明developer-gpad分支有人改错了。
我们借助sourceTree看developer-gpad的提交记录，只需要关注提交到自己上的commit和merge commit就行
这条merge导致了错误，可能是developer-gapd_zw这个分支上错了，再往上找
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb5e459ad8984e124c9e97242db5a165/" rel="bookmark">
			MySql command line client命令解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、启动与退出
1、进入MySQL：启动MySQL Command Line Client（MySQL的DOS界面），直接输入安装时的密码即可。此时的提示符是：mysql&gt;
2、退出MySQL：quit 或 exit
二、库操作
1、创建数据库
命令：create database
例如：建立一个名为xhkdb的数据库
mysql&gt; create database xhkdb;
2、显示所有的数据库
命令：show databases （注意：最后有个s）
mysql&gt; show databases;
3、删除数据库
命令：drop database
例如：删除名为xhkdb的数据库
mysql&gt; drop database xhkdb;
4、连接数据库
命令： use
例如：如果xhkdb数据库存在，尝试存取它：
mysql&gt; use xhkdb; www.2cto.com
屏幕提示：Database changed
5、当前选择（连接）的数据库
mysql&gt; select database();
6、当前数据库包含的表信息：
mysql&gt; show tables; （注意：最后有个s）
三、表操作，操作之前应连接某个数据库
1、建表
命令：create table ( [,.. ]);
mysql&gt; CREATE TABLE `testa` (
-&gt; `id` int(10) UNSIGNED NOT NULL AUTO_INCREMENT,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb5e459ad8984e124c9e97242db5a165/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ed4e981db68f3604ae5189d517cba9d/" rel="bookmark">
			git入门之本地操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、启动git命令输入
在想要建立仓库，建议的方式是在文件夹中右键单击，选择git bash here
2、初始化仓库命令：git init
3、查看仓库状态：git status
4、更新仓库特定文件：git add xxx
5、更新仓库所有文件：git add .
6、生成版本：git commit -m "Version Name"
7、设置个人本地名称：git config --local user.name "XiaoPengYou"
8、设置个人全局邮件：git config --global user.email "123456@qq.com"
9、查看提交记录：git log
10、查看特定作者提交记录：git log --author="XiaoPengYou"
11、查看包含特定关键词提交记录：git log --grep="KeyWord"
12、更改最近提交的版本的名称：git commit --amend -m 'Fix Bug X'
13、将最近一次更新并入最近的版本：git commit --amend --no-edit
14、避免对特定文件或者文件夹的追踪：添加.gitignore文本文件，在该文本文件中添加免于追踪的文件或者文件夹的列表。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bbead32f52da848258ca84f4b84c076/" rel="bookmark">
			MyBatis-Plus（实用篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、基础组件1、BaseMapper接口API2、IService接口API3、创建Service层操作数据 二、常用注解1、@TableName2、@TableId2.1、value属性2.2、type属性 3、@TableField3.1、value属性3.2、exist属性3.3、select属性3.4、condition属性3.5、update属性3.6、fill属性3.7、insertStrategy、updateStrategy、whereStrategy属性3.8、typeHandler属性 4、@TableLogic 三、条件构造器1、wapper介绍2、构造器常用方法3、组装条件示例 四、扩展功能1、链式查询与修改2、静态工具类Db4、自定义sql4.1、@Select注解自定义sql4.2、自定义xml分页sql 5、IPage的泛型转换（entity转换为vo）6、SimpleQuery工具类7、ActiveRecord 五、插件1、Mybatis插件2、MyBatisX插件2.1、生成逆向工程2.2、快速生成CRUD 一、基础组件 简介
MyBatis-Plus (opens new window)（简称 MP）是一个 MyBatis (opens new window)的增强工具在MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生 1、BaseMapper接口API BaseMapper是MyBatis-Plus提供的模板mapper，其中包含了基本的CRUD方法，泛型为操作的实体类型Mapper继承该接口后，无需编写 mapper.xml 文件，即可获得CRUD功能BaseMapper接口，增删改返回影响数据条数的Integer BaseMapper中提供的CRUD方法
增加：insert 删除：delete 修改：updateupdate方法：entity实体对象某属性为null，则不会修改此属性 查询：select selectObjs方法：只返回第一个字段的值selectPage方法：分页需要添加分页插件，否则不生效 2、IService接口API 封装IService接口，进一步封装CRUD采用get查询单行、remove删除、list查询集合、page分页前缀命名方式IService接口，增删改返回是否操作成功的boolean泛型 T 为任意实体对象 IService中提供的CRUD方法
增加：save 删除：remove 修改：update 新增或修改：主键存在则根据主键修改，主键不存在则新增 查询：单个get，集合listgetOne方法，多个抛出异常，boolean throwEx = false 则获取第一条数据 查询记录数：count 分页查询：page 集合查询：listlistObjs方法，可以将查询结果T类型转换成V类型返回List&lt;V&gt; 3、创建Service层操作数据 Mapper接口：创建UserMapper对象并继承BaseMapper @Mapper public interface UserMapper extends BaseMapper&lt;User&gt; {} Service接口：创建UserService并继承IService /** * UserService继承IService模板提供的基础功能 */ public interface UserService extends IService&lt;User&gt; {} Service实现类：创建UserService的实现类并继承ServiceImpl /** * ServiceImpl实现了IService，提供了IService中基础功能的实现 * 若ServiceImpl无法满足业务需求，则可以使用自定的UserService定义方法，并在实现类中实现 */ @Service public class UserServiceImpl extends ServiceImpl&lt;UserMapper,User&gt; implements UserService{} 二、常用注解 1、@TableName 在实体类类型上添加@TableName(“t_user”)，标识实体类对应的表不加注解，默认驼峰转下划线则是表明，如实体OrderInfo，则默认对应表名order_info @Data @TableName("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7bbead32f52da848258ca84f4b84c076/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49d958363c1f14e9ff268ea341045d47/" rel="bookmark">
			通义千问Qwen-72B-Chat基于PAI的低代码微调部署实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：熊兮、求伯、一耘
引言 通义千问-72B（Qwen-72B）是阿里云研发的通义千问大模型系列的720亿参数规模模型。Qwen-72B的预训练数据类型多样、覆盖广泛，包括大量网络文本、专业书籍、代码等。Qwen-72B-Chat是在Qwen-72B的基础上，使用对齐机制打造的基于大语言模型的AI助手。
阿里云人工智能平台PAI是面向开发者和企业的机器学习/深度学习平台，提供AI开发全链路服务。快速开始（PAI-QuickStart）是阿里云人工智能平台PAI的产品组件，它集成了国内外 AI 开源社区中优质的预训练模型，支持零代码和 SDK 的方式实现从训练到部署再到推理的全过程，大大简化了模型的开发和部署，为开发者和企业用户带来了更快、更高效、更便捷的 AI 开发和应用体验。
本文将以 Qwen-72B-Chat 为例，介绍如何通过PAI平台的快速开始（PAI-QuickStart）部署和微调千问大模型。
运行环境要求 本示例目前仅支持在阿里云乌兰察布地域，使用灵骏集群环境运行。资源配置要求：GPU 推荐使用 GU108（80GB），推理需要4卡及以上资源，微调需要4机32卡及以上资源。阿里云 PAI 灵骏智算服务资源开通和管理请参考官网文档： 灵骏智算资源的开通购买
通过PAI控制台使用模型 开发者可以在 PAI 控制台的“快速开始”入口，找到 Qwen-72B-Chat 的模型，Qwen-72B-Chat 的模型卡片如下图所示：
模型部署和调用 通过“模型部署”入口，用户选择使用的灵骏资源信息，点击部署按钮，即可将模型部署到 PAI-EAS 推理服务平台。
通过部署的在线服务的详情页，用户可以查看服务访问地址（Endpoint）和访问凭证（Token），然后用于调用推理HTTP API。使用 cURL 调用推理服务的示例如下。
注意，因为模型较大，加载时间较长，用户可以在服务启动之后，通过以下的“查看模型列表”API查看服务当前加载完成的模型。
# 请注意替换为使用服务的Endpoint和Token export API_ENDPOINT="&lt;ENDPOINT&gt;" export API_TOKEN="&lt;TOKEN&gt;" # 查看模型list curl $API_ENDPOINT/v1/models \ -H "Content-Type: application/json" \ -H "Authorization: Bearer $API_TOKEN" # 调用通用的文本生成API curl $API_ENDPOINT/v1/completions \ -H "Content-Type: application/json" \ -H "Authorization: Bearer $API_TOKEN" \ -d '{ "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49d958363c1f14e9ff268ea341045d47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ad99ce2dca23c5b6625e6cac84568ef/" rel="bookmark">
			Linux查看系统资源占用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在系统维护的过程中，随时可能有需要查看 CPU和内存的使用率，并根据相应信息分析系统状况的需求。本文介绍一下几种常见的Linux系统资源查看命令。
1、总体内存占用的查看
命令：free
图1 free命令查看内存占用
（1） free命令默认是以kb为单位显示的，可以用free -m 用Mb单位来显示。
（2） Mem行 ： total = used + free 其中buffers和cached虽然计算在used内， 但其实为可用内存。
（3） Mem下一行：used为真实已占内存，free为真实可用内存。
（4）Swap：内存交换区的使用情况。
2、查看内存占用前五的进程
命令：ps auxw | head -1;ps auxw|sort -rn -k4|head -5
图 2.1查看内存占用前5的进程
如图2.1所示， 内存的单位是kb，VSZ是虚拟内存的占用，RSS是真实的内存的占用。 命令分解： ps auxw显示系统资源占用情况； head -1表示显示第一列，即标题列； sort -r 表示反向排序，-n表示按数字排序，-k4表示列的第4个字符。 3、查看CPU占用前三的进程
命令：ps auxw|head -1;ps auxw|sort -rn -k3|head -3
图3.1 查看cpu占用前三的进程
该命令与图2.1相仿，只是选择的资源占用情况的第3列（即cpu），用“-k3”表示。
4、查看系统整体的负载
命令：top
图4.1 top显示系统整体负载
（1）第一行： 系统时间 + 系统运行时间 + 几个用户 + 1/5/15分钟系统平均负载
（2）第二行：进程总数(total) + 正在运行进程数(running) + 睡眠进程数(sleeping) + 停止的进程数(stopped)+ 僵尸进程数(zombie)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ad99ce2dca23c5b6625e6cac84568ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/914e7ef4cbf158947d995fc9a8999319/" rel="bookmark">
			el-form表单项自定义校验规则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目标 官网的表单项都是写死在代码里面的，但是实际我们的表单大多是通过json配置出来的，就需要动态的根据配置信息做表单校验
例如：
[{ name: "商品名称", key: "productName", value: "", type: "input", must: true, placeholder: "请输入", limit: 20 }, ...] 方案 在标签添加rules规则，第二条配置自定义校验规则
&lt;el-form-item :prop="item.prop" :rules="[ { required:item.must, message: item.name + '是必填项！' }, { validator: validLimit, maxlength: item.limit }, ]" &gt; &lt;/el-form-item&gt; 注意：动态校验文本超出长度，设置len会校验到number类型的表单，导致这个类型的情况会比较大小，而不是比较文本长度，所以自定义校验规则
// 动态参数通过在rules中添加属性，例如maxlength，在rule.maxlength接收 validLimit(rule, value, callback) { if ( rule.maxlength &amp;&amp; value &amp;&amp; value.toString().length &gt; rule.maxlength ) { callback(new Error("超出长度")); } callback(); } 附录 rules规则配置
属性
类型
说明
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/914e7ef4cbf158947d995fc9a8999319/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c668eced33e074932846dbbba771980/" rel="bookmark">
			深入理解python函数，一切皆对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python一切皆对象，函数也是对象，可以赋值给变量，也可以作为参数传递给函数，也可以作为函数的返回值。
把函数赋值给变量 def say(text): print(text) speak = say speak('hello') # hello del say say('hello') # NameError: name 'say' is not defined speak('hello') # hello speak 只是这个函数对象的另一个名字，也就是说你可以删除原来的名字（say），仍然可以通过 speak 调用这个函数。这就像普通的变量赋值一样。请看下图了解。
函数作为变量，存储到数据结构 正如我们在第一节中了解到的，函数是 Python 中的对象，我们可以将它们存储在数据结构中，就像任何其他对象一样。要访问存储在其中的函数对象，假设列表的工作方式如下：
def say(text): print(text) funcs = [say, str.lower, str.upper] for func in funcs: print(func, "执行返回值：", func("Hello")) # 运行结果： # Hello # &lt;function say at 0x7f9b880c6320&gt; 执行返回值：None # &lt;method 'lower' of 'str' objects&gt; 执行返回值：hello # &lt;method 'upper' of 'str' objects&gt; 执行返回值：HELLO 函数作为参数传递 第一次听到这个词，你会觉得很奇怪，但是你可以确定，函数也是一个对象，可以作为参数传递给另一个函数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c668eced33e074932846dbbba771980/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dababdadf39bb33ed681cc8bad1ce481/" rel="bookmark">
			端到端自动驾驶
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自动驾驶主要流程：感知-&gt;预测-&gt;规划
预测是预测周围目标（车、行人、动物等）的轨迹，规划是规划自车的运动轨迹。
UniAD[CVPR 2023]: 使用transformer架构，统一自动驾驶流程，完成所有检测，跟踪，建图，轨迹预测，占据栅格预测与规划的端到端推理。
参考：
CVPR 2023 Award Candidate | 自动驾驶通用算法框架UniAD - OpenGVLab的文章 - 知乎
https://zhuanlan.zhihu.com/p/616433397
VAD[ICCV2023]: 核心在于场景表征使用矢量化的方式，非图像常用的栅格化。好处就是可以加快推理。
【「你好，开发者」 ICCV 2023 VAD 基于矢量化环境表征的高效端到端自动驾驶框架】 https://www.bilibili.com/video/BV12u4y1V7zV/?share_source=copy_web
FusionAD 基于BEV统一相机和雷达多模态输入。task使用类似FPN的层级结构。
https://hub.baai.ac.cn/view/28712
Tesla FSD V12 AD-MLP 仅仅使用了传感器数据，利用简单的mlp网络，就在nuscene plan数据集上得到了很好的效果。说明nuscene plan数据集过于简单，仅在这个上面做开环测试不能很好的说明问题，需要引入其他的如仿真环境中做更多的闭环测试。
参考：
端到端自动驾驶算法在 nuScenes 数据集上的开环评测或许并不靠谱 - Muyun99的文章 - 知乎
https://zhuanlan.zhihu.com/p/654533840
https://zhuanlan.zhihu.com/p/669454065
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac6d845de4276ff10abcb27c9d27199d/" rel="bookmark">
			总：基于USRP X310完成环境构建和示例波形实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录 一、引言二、设备简介三、硬件安装四、接口简介五、软件环境六、应用案例问题参考（1）.grc和.py（2）Warning: failed to XInitThreads() 一、引言 本文目的是搭建USRP对通实验环境，完成仿真波形在实物平台上的实验验证。文章采用硬件到软件的脉络进行介绍，依次为硬件、硬件接口、软件运行环境、驱动、软件开发平台及最终的示例产生与运行结果。
二、设备简介 参考链接： 通用软件无线电平台 USRP X310
三、硬件安装 参考链接： 硬件安装指导
四、接口简介 参考链接： USRPx310的底板介绍
五、软件环境 参考链接： 一：Win7、Win10系统下安装虚拟机VMware，运行Linux系统
参考链接： 二：Ubuntu 18.04安装UHD和GNURadio
UHD是硬件驱动，GNUradio是软件开发平台。
六、应用案例 GNU Radio介绍第一次使用USRPGNU Radio流程图编程GNU Radio与硬件 问题参考 （1）.grc和.py 保存后的文件如图 其中“.grc”可以直接双击就能打开对应的工程，“.py”则是生成的流图的python代码，表示了模块的连接，实际运行时，只需要在终端中运行“.py”的脚本就可以运行而不打开gnuradio-companion的界面。
（2）Warning: failed to XInitThreads() 参考链接 failed to XInitThreads
如果根本没有图形，则应在流图的 Options 块中将 Generate Options 设置为 No GUI。然后根本不调用 XInitThreads（）。如果有显卡，请安装 x11，输入：sudo apt-get install libx11-dev 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a2426739936b62c1a335a8237937157/" rel="bookmark">
			新旧数据比较 直接可用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我自定义的函数式编程自定义接口 可替换为java.util.function.Function public interface RSupplier&lt;T,V&gt; { V apply(T t); } 对比类 package xxx.utils; import xxx.RSupplier; import java.util.ArrayList; import java.util.List; import java.util.Map; import java.util.stream.Collectors; //T为实体类时需要重写hashCode和equals方法 public class NewOldComparer&lt;T&gt; { private List&lt;T&gt; insertObjs = new ArrayList&lt;&gt;(); private List&lt;T&gt; updateObjs = new ArrayList&lt;&gt;(); private List&lt;T&gt; deleteObjs = new ArrayList&lt;&gt;(); public NewOldComparer(List&lt;T&gt; newObjs, List&lt;T&gt; oldObjs, RSupplier&lt;T, Long&gt; idSupplier) { if (null != newObjs &amp;&amp; !newObjs.isEmpty()) { compareHisRecord(newObjs, oldObjs, idSupplier); } else { noHasNewIds(oldObjs); } } public List&lt;T&gt; insertObjs() { return insertObjs; } public List&lt;T&gt; updateObjs() { return updateObjs; } public List&lt;T&gt; deleteObjs() { return deleteObjs; } private void compareHisRecord(List&lt;T&gt; newObjects, List&lt;T&gt; oldObjects, RSupplier&lt;T, Long&gt; idSupplier) { if (oldObjects.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a2426739936b62c1a335a8237937157/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a4f7ee282022c5b8b96c2ff4c52c9ef/" rel="bookmark">
			Linux入门教程（非常详细）从零基础入门到精通，看完这一篇就够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux 的学习对于一个程序员的重要性是不言而喻的。前端开发相比后端开发，接触 Linux 机会相对较少，因此往往容易忽视它。但是学好它却是程序员必备修养之一。
Linux 基础
操作系统
操作系统Operating System简称OS，是软件的一部分，它是硬件基础上的第一层软件，是硬件和其它软件沟通的桥梁。
操作系统会控制其他程序运行，管理系统资源，提供最基本的计算功能，如管理及配置内存、决定系统资源供需的优先次序等，同时还提供一些基本的服务程序。
什么是 Linux
Linux 系统内核与 Linux 发行套件的区别
Linux系统内核指的是由Linus Torvalds负责维护，提供硬件抽象层、硬盘及文件系统控制及多任务功能的系统核心程序。
Linux发行套件系统是我们常说的 Linux操作系统，也即是由 Linux内核与各种常用软件的集合产品。
总结:真正的 Linux指的是系统内核，而我们常说的 Linux指的是 “发行版完整的包含一些基础软件的操作系统”。
Linux 对比 Windows
1.稳定且有效率；
2.免费（或少许费用）；
3.漏洞少且快速修补；
4.多任务多用户；
5.更加安全的用户与文件权限策略；
6.适合小内核程序的嵌入系统；
7.相对不耗资源。
Linux 系统种类
红帽企业版 Linux：RHEL是全世界内使用最广泛的 Linux系统。它具有极强的性能与稳定性，是众多生成环境中使用的（收费的）系统。
Fedora ：由红帽公司发布的桌面版系统套件，用户可以免费体验到最新的技术或工具，这些技术或工具在成熟后会被加入到RHEL系统中，因此 Fedora也成为RHEL系统的试验版本。
CentOS ：通过把RHEL系统重新编译并发布给用户免费使用的 Linux系统，具有广泛的使用人群。
Deepin ：中国发行，对优秀的开源成品进行集成和配置。
Debian ：稳定性、安全性强，提供了免费的基础支持，在国外拥有很高的认可度和使用率。
Ubuntu ：是一款派生自Debian的操作系统，对新款硬件具有极强的兼容能力。Ubuntu与Fedora都是极其出色的 Linux桌面系统，而且 Ubuntu也可用于服务器领域。
终端连接阿里云服务器
通过执行ssh root@121.42.11.34命令，然后输入服务器连接密码就可以顺利登录远程服务器。从现在开始我们就可以在本地电脑操作远程服务器。
1.这个黑色的面板就是终端也就是Shell（命令行环境）。
2.ssh root@xxx这是一条命令，必须要在Shell中才能执行。
Shell
Shell这个单词的原意是 “外壳”，跟kernel（内核）相对应，比喻内核外面的一层，即用户跟内核交互的对话界面。
Shell是一个程序，提供一个与用户对话的环境。这个环境只有一个命令提示符，让用户从键盘输入命令，所以又称为命令行环境（command line interface，简写为CLI）。Shell 接收到用户输入的命令，将命令送入操作系统执行，并将结果返回给用户。
Shell是一个命令解释器，解释用户输入的命令。它支持变量、条件判断、循环操作等语法，所以用户可以用Shell命令写出各种小程序，又称为Shell脚本。这些脚本都通过Shell的解释执行，而不通过编译。
Shell是一个工具箱，提供了各种小工具，供用户方便地使用操作系统的功能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a4f7ee282022c5b8b96c2ff4c52c9ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98490be63724b612e2c5fd16a8846e01/" rel="bookmark">
			高级路由学习试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 高级路由学习试题一.高级路由题目答案 二.OSPF 相关答案 三.基础知识答案 高级路由学习试题 一.高级路由题目 1.以下属于ITOIP特性的有（）
A、智能
B、开放
C、融合
D、标准
2.层级化网络模型将网络划分为（）
A、汇聚层
B、园区网核心层
C、核心层
D、接入层
3.H3C模块化企业网架构包含（）模块
A、灾备中心
B、VPN接入
C、服务器群
D、广域网汇聚
4.负责复杂控制策略的是（）
A、汇聚层
B、核心层
C、接入层
5.典型大规模网络路由可能包含的层是（）
A、核心层
B、汇聚层
C、接入层
D、物理层
6.以下（）特性是典型大规模网络路由的核心层所必须具备的。
A、可靠性
B、扩展性
C、接入服务
D、丰富策略
7.以下（）路由协议比较适合在大规模网络路由的汇聚层中使用。
A、OSPFB
B、 RIP
C、 静态路由
D、 D、BGP
8.以下（）特性可以控制路由传播范围，从而增加网络的可管理性。
A、PBR
B、路由过滤
C、路由策略
D、快速重路由
9.（）技术能够最终解决IP地址短缺的问题。
A、路由快收敛
B、NAT
C、IPV6
D、BFD
10.关于控制平面和转发平面，下列说法中正确的是（）。
A、控制平面是指系统中用来传送信令、计算表项的部分
B、MAC地址表学习进程属于转发平面
C、通过FIB进行报文转发属于转发平面的范畴
D、控制平面和转发平面必须是物理分离的
11.路由器查找路由表进行报文转发时，采用（）原则。
A、最长匹配
B、精确匹配
C、随机转发
D、哈希算法
12.描述数据流的5元组中所包含的元素为（）。
A、源MAC地址、源IP地址、目的MAC地址、目的IP地址、协议号
B、源MAC地址、源端口号、目的MAC地址、目的端口号、协议号
C、源IP地址、源端口号、目的IP地址、目的端口号、接口号
D、源IP地址、源端口号、目的IP地址、目的端口号、协议号
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98490be63724b612e2c5fd16a8846e01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e68079b0cd9eb44588985faaf8df2d2/" rel="bookmark">
			c&#43;&#43; 回调函数的注册与调用学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源自：C语言 — 函数的注册和回调_c语言 函数注册-CSDN博客
结合自己项目的使用：登记注册于调用
1.单例：
2.注册函数定义：
3.调用注册函数： 4.调用回调函数：
其中：std::function std::bind 是C++11的内容，参考下文博客：
通过 std::function std::bind 添加回调-CSDN博客
摘抄：声明 定义 绑定 ，接着可以像上文的步骤，进行注册以及调用。
补充：为什么要使用回调函数？信号槽其实也是一种回调函数思想 【2期 QT信号与槽函数&amp;回调函数与函数指针】_qt 函数指针-CSDN博客 摘抄：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/203336303e26d49074a911f5cf5b1e8a/" rel="bookmark">
			VM虚拟化——VMware Conveter Standalone安装时出现Error 29190
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【报错信息】
error 29190 - Could not generate secure sockets layer (SSL) key 【解决方案】
打开任务管理器，找到msiexec.exe，结束。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebb8f6ab9dc7463faccfb248dfbd6bc8/" rel="bookmark">
			VM虚拟化——物理机迁移至虚拟化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装迁移工具 VMware vCenter Converter Standalone
【安装向导】 【最终用户专利协议】 【最终用户许可协议】 【安装位置】 【安装类型】默认本地安装
【用户体验设置】 【准备安装】
二、迁移 【转换机器】
【源主机】
填ip、用户名和密码 最好是用administrator的账号，不然可能权限不足。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d2676d1c494f7db9a1eb10cab74269b/" rel="bookmark">
			ChatGPT新出Team号 年付费
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前一直传的团队版ChatGPT终于来了，这个对拼单的比较合算。每人每月25美元，只能按年支付。
团队版比普通版多的权益有：
◈更多的GPT-4消息上限，三小时100次。
◈可以创建与团队内部共享的GPTs。
◈用于工作空间管理的管理员控制台。
◈可以选择不使用你的数据进行模型训练。…
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c2c9d0dd9392c4603e239a95a34b510/" rel="bookmark">
			WebSocket 入门实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 引言 WebSocket 是一种在单个 TCP 连接上提供全双工通信的协议，允许客户端和服务器之间实时、双向地进行数据交换。WebSocket 的引入使得 Web 应用程序能够更轻松地实现实时通信，如在线聊天、实时数据更新等。本文将介绍 WebSocket 的使用场景以及通过 Java 进行 WebSocket 编程的实例。
2. WebSocket 使用场景 WebSocket 在以下场景中非常有用：
实时聊天应用程序： WebSocket 提供了一种实时通信的方式，使得在线聊天应用程序能够实时地传递消息。
实时数据更新： 对于需要在客户端和服务器之间共享实时数据的应用程序，例如股票市场行情、在线游戏状态等。
协作应用程序： 在协作工具中，用户可以实时共享文档、图像等内容。
实时提醒和通知： 通过 WebSocket，服务器可以即时地向客户端推送通知，而不需要客户端不断地轮询。
3. Java代码示例 下面通过一个简单的 Java 示例来演示如何使用 Spring Boot 和 Spring WebSocket 来创建一个基本的 WebSocket 服务。
1. 创建 Spring Boot 项目 引入websocket-starter
&lt;!-- Spring Boot Starter WebSocket --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;/dependency&gt; 2. 编写 WebSocket 配置 创建一个 WebSocket 配置类，用于配置和启用 WebSocket：
// WebSocketConfig.java @Configuration @EnableWebSocketMessageBroker public class WebSocketConfig extends AbstractWebSocketMessageBrokerConfigurer { @Override public void configureMessageBroker(MessageBrokerRegistry config) { config.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c2c9d0dd9392c4603e239a95a34b510/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3385f52a7cf62e83b341d152912a5f69/" rel="bookmark">
			响应式编程Reactor API大全（下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Reactor 是一个基于响应式编程的库，主要用于构建异步和事件驱动的应用程序。Reactor 提供了丰富的 API，包括创建、转换、过滤、组合等操作符，用于处理异步数据流。以下是一些 Reactor 的主要 API 示例：
pom依赖
&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.projectreactor&lt;/groupId&gt; &lt;artifactId&gt;reactor-bom&lt;/artifactId&gt; &lt;version&gt;2023.0.0&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.projectreactor&lt;/groupId&gt; &lt;artifactId&gt;reactor-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.projectreactor&lt;/groupId&gt; &lt;artifactId&gt;reactor-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt; &lt;version&gt;5.7.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 61. 使用 Reactor 的 then 方法进行后续操作 then 方法用于在当前数据流完成后执行后续操作。
import reactor.core.publisher.Flux; public class ReactorThenExample { public static void main(String[] args) { Flux&lt;Integer&gt; source = Flux.just(1, 2, 3); // 在当前数据流完成后执行后续操作 source.then(Mono.fromRunnable(() -&gt; System.out.println("Done"))) .subscribe(); } } 62.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3385f52a7cf62e83b341d152912a5f69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/178dac4b69a8c5d8bc04aaa6f3997301/" rel="bookmark">
			L1-018 大笨钟(Java)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微博上有个自称“大笨钟V”的家伙，每天敲钟催促码农们爱惜身体早点睡觉。不过由于笨钟自己作息也不是很规律，所以敲钟并不定时。一般敲钟的点数是根据敲钟时间而定的，如果正好在某个整点敲，那么“当”数就等于那个整点数；如果过了整点，就敲下一个整点数。另外，虽然一天有24小时，钟却是只在后半天敲1~12下。例如在23:00敲钟，就是“当当当当当当当当当当当”，而到了23:01就会是“当当当当当当当当当当当当”。在午夜00:00到中午12:00期间（端点时间包括在内），笨钟是不敲的。
下面就请你写个程序，根据当前时间替大笨钟敲钟。
输入格式： 输入第一行按照hh:mm的格式给出当前时间。其中hh是小时，在00到23之间；mm是分钟，在00到59之间。
输出格式： 根据当前时间替大笨钟敲钟，即在一行中输出相应数量个Dang。如果不是敲钟期，则输出：
Only hh:mm. Too early to Dang. 其中hh:mm是输入的时间。
输入样例1： 19:05 输出样例1： DangDangDangDangDangDangDangDang 输入样例2： 07:05 输出样例2： Only 07:05. Too early to Dang. 解题思路 有几种情况需要分析好
hour在12:01～23:00是敲钟的（注意即使当23:01也是敲的12声）minute不是00就需要让hour+1午夜00:00～中午12:00不敲钟 解题过程中遇到的问题 对于时间的处理，一定不能漏掉了对23:01～23:59的处理！
代码 import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); String[] time = scanner.next().split(":"); int hh = Integer.parseInt(time[0]); int mm = Integer.parseInt(time[1]); //如果hh在12:01 ～ 23:59 是敲钟的 if (hh &gt; 12 &amp;&amp; hh &lt; 24) { //如果mm不是00就敲hh+1 if (mm &gt; 00 &amp;&amp; hh &lt; 24) { hh = (hh % 12) + 1; for (int i = 0; i &lt; hh; i++) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/178dac4b69a8c5d8bc04aaa6f3997301/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10ccce1d2ad8a92460da2f033763f175/" rel="bookmark">
			2核2G3M云服务器能干什么？能满足哪些应用需求？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在云计算的广阔天地中，服务器选择对于每一个站长或企业IT负责人来说都是一项重大决策。今天，我们要为大家深入解析腾讯云2核2G3M轻量应用服务器的实际应用及其背后的价值。
一、性能与带宽：实力派的体现
对于服务器而言，性能与带宽是影响用户体验的关键因素。这款服务器配备的2核2G配置，足以应对日常的网站访问、应用运行等任务。而3M的公网带宽，换算成下载速度约为384KB/秒，这意味着即使在流量高峰时段，也能保证网站的流畅访问。
二、应用场景：广泛而实用
那么，这样的服务器适用于哪些场景呢？答案是：非常广泛。无论是个人博客、企业官网还是在线商城，甚至是中小型企业的数据存储与应用部署，它都能轻松胜任。简而言之，只要你的项目不需要超高的计算或存储资源，它都能为你提供稳定可靠的服务。
三、性价比之选：不止于价格
让我们首先从价格这一最为直观的角度入手。腾讯云2核2G3M轻量应用服务器，1年的优惠价格仅为62元。对于初创企业、个人开发者或是流量不大的网站来说，这样的价格几乎可以说是“零负担”。而在这背后，它所提供的性能与稳定性，更是物超所值。
详情参考：
腾讯云2核2G服务器优惠：https://tx.mian100.cn
腾讯云新用户先领券：https://xinke.mian100.cn
阿里云2核2G服务器优惠：https://aliyun.mian100.cn
华为云2核2G服务器优惠：https://huawei.mian100.cn
云产品续费贵，建议选择腾讯云那几款3年、5年时长的优惠服务器套餐；云产品升级贵，建议根据实际需求选配置高的。
四、关于CPU与存储：透明且灵活
对于CPU型号，腾讯云采取随机分配的方式，确保满足套餐规格的物理CPU型号。而系统盘方面，配备了40GB的SSD盘，保证了数据的快速读写。此外，每月还提供了200GB的流量，折合每天约6.6GB，超出部分则按照0.8元每GB计费。这样的设计，既保证了基本需求，又给了用户足够的灵活性。
五、地域节点：覆盖核心区域
服务器的地域节点选择同样重要。腾讯云为此提供了广州、上海、北京等多个核心地域节点供用户选择。这意味着无论你的目标用户群在哪里，都能找到离他们最近的节点，从而进一步提高网站的访问速度。
综上所述，腾讯云2核2G3M轻量应用服务器凭借其超高的性价比、稳定的性能与广泛的应用场景，无疑是当前市场上的明星产品。无论你是个人开发者还是中小型企业，它都值得你认真考虑。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ad5b3396e96d765b4419e4069f29367/" rel="bookmark">
			响应式编程Reactor API大全（中）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Reactor 是一个基于响应式编程的库，主要用于构建异步和事件驱动的应用程序。Reactor 提供了丰富的 API，包括创建、转换、过滤、组合等操作符，用于处理异步数据流。以下是一些 Reactor 的主要 API 示例：
pom依赖
&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.projectreactor&lt;/groupId&gt; &lt;artifactId&gt;reactor-bom&lt;/artifactId&gt; &lt;version&gt;2023.0.0&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.projectreactor&lt;/groupId&gt; &lt;artifactId&gt;reactor-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.projectreactor&lt;/groupId&gt; &lt;artifactId&gt;reactor-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt; &lt;version&gt;5.7.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 22. 使用 Reactor 的 elapsed 方法进行时间测量 elapsed 方法可以用于测量元素发射之间的时间间隔，返回包含时间间隔和元素的元组。
import reactor.core.publisher.Flux; import java.time.Duration; public class ReactorElapsedExample { public static void main(String[] args) throws InterruptedException { Flux&lt;Integer&gt; source = Flux.just(1, 2, 3, 4, 5) .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ad5b3396e96d765b4419e4069f29367/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce4586c66d5f4aa8979d1547bca1333a/" rel="bookmark">
			linux-前端项目由nginx迁移到apache httpd
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux-前端项目由nginx迁移到apache httpd 1、前端项目存放目录为 /var/www/dist
虚拟主机端口80
反向代理拦截 /prod-api
后端服务地址 http://192.168.0.44:8097
2、在/etc/httpd/conf.d/目录中，创建一个vhost.conf的文件，放入以下内容
&lt;VirtualHost *:80&gt; DocumentRoot /var/www/dist ServerName www.dist.com &lt;Directory /var/www/dist&gt; RewriteEngine on RewriteCond %{REQUEST_FILENAME} !-f RewriteCond %{REQUEST_FILENAME} !-d RewriteRule . index.html [L] SetOutputFilter DEFLATE Options FollowSymLinks AllowOverride All Require all granted DirectoryIndex index.php index.html index.htm default.php default.html default.htm &lt;/Directory&gt; ProxyRequests off ProxyPass /prod-api http://192.168.0.44:8097 ProxyPassReverse /prod-api http://192.168.0.44:8097 &lt;/VirtualHost&gt; 3、隐藏httpd的版本号和操作系统信息。
在/etc/httpd/conf.d/目录中，创建一个servertokens.conf的文件，放入以下内容
# # ServerTokens # This directive configures what you return as the Server HTTP response # Header.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce4586c66d5f4aa8979d1547bca1333a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b269264356c941bf941453b2d897b30b/" rel="bookmark">
			Spring Boot Starter介绍和实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 Spring Boot Starter 是 Spring Boot 提供的一种机制，用于简化和集成应用程序的依赖管理。通过创建自定义的 Starter，可以将一组相关的依赖打包成一个简单的、可重用的模块，使应用程序的配置和依赖管理更加方便。在本文中，我们将深入探讨 Spring Boot Starter 的原理、创建过程，并通过实际示例演示其用法。
1. Spring Boot Starter 简介 Spring Boot Starter 是 Spring Boot 提供的一种约定，用于简化应用程序的依赖管理。它定义了一组通用的模块，每个模块关注一个特定的领域，例如数据库访问、消息队列、缓存等。这样，开发者可以根据需求选择相应的 Starter，并通过简单的配置即可引入所需的依赖。
Spring Boot Starter 的命名约定为 spring-boot-starter-*，例如：
spring-boot-starter-data-jpa: 用于数据持久化的 Starter。spring-boot-starter-web: 用于构建 Web 应用程序的 Starter。spring-boot-starter-actuator: 提供生产就绪功能的 Starter。 2. Spring Boot Starter 实战 2.1. 创建自定义 Starter 下面演示如何在 Spring Boot Starter 中使用注解记录操作审计的功能。
首先创建一个 Maven 项目作为 Spring Boot Starter。在项目中添加以下依赖：
&lt;!-- pom.xml --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b269264356c941bf941453b2d897b30b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc954997cd971afcbd6d602ab05ca93c/" rel="bookmark">
			导入 sql 文件，因 sql 文件里的 sql 语句无序导致失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导入 sql 文件，因 sql 文件里的 sql 语句无序导致失败 报错信息报错原因解决办法 报错信息 导入 sql 文件，因 sql 文件里的 sql 语句无序导致失败
报错的图找不到了…
总之就是运行 sql 文件（非常大 300 多MB吧，几百万条）的时候，因为 sql 文件里的部分 sql 语句顺序不对，导致部分 sql 语句执行失败…
而执行失败后，又不能准确的定位没有成功执行的语句，就很烦
报错原因 之所以会报错是因为数据库需要以一种拓扑排序的顺序导入
就不如你建立了一个视图，但这个视图里面需要表 a 的存在，但是 sql 文件里面 sql 的顺序是创建视图的语句在前，创建表 a 的语句在后，而顺序执行的时候，就会导致有的语句执行不成功…
问了一下 gpt 为什么导出的 sql 文件的 sql 语句顺序会出问题：
SQL文件中的语句无序可能有多种原因，其中一些常见的包括：
导出工具的行为： 使用数据库导出工具时，它可能按照某种特定的规则生成SQL语句。有些导出工具可能按照表的创建顺序导出语句，而不考虑表之间的依赖关系。这可能导致生成的SQL文件是无序的。
数据库内部元数据： SQL文件的顺序可能与数据库内部元数据存储的方式有关。数据库管理系统可能以一种特定的方式保存表和其他对象的信息，导致导出的SQL语句无序。
版本控制系统： 如果SQL文件是通过版本控制系统（如Git）进行维护的，合并和提交操作可能导致语句的无序性。不同开发人员对于SQL文件的修改可能在合并时产生无序的结果。
手动编辑： 如果SQL文件是通过手动编辑而成，可能由于人为的操作而导致语句的无序。例如，开发人员可能在不同位置添加或删除语句，而没有进行整理。
无论是哪种原因，都建议在版本控制系统中保存数据库脚本，并且尽量使用数据库迁移工具来管理数据库的变更。这样可以更好地保持脚本的有序性，并简化团队协作和数据库迁移的管理。
解决办法 没有找到好的解决办法，留个坑，后续有好的解决办法会继续更新，如果各位有好的解决办法可以评论留言一下，万分感谢！！！
下面是 gpt 给出的解决办法：
这个问题的解决方案通常涉及到手动调整SQL语句的顺序，以便按照拓扑排序的方式导入数据库。拓扑排序确保在导入时不会出现引用尚未创建的表或其他依赖关系问题。
以下是一些步骤，您可以尝试手动进行拓扑排序：
分析依赖关系： 查看数据库中表之间的依赖关系。通常，外键关系是最常见的依赖关系。了解每个表的依赖关系将帮助您确定导入的顺序。
创建导入顺序： 根据依赖关系创建一个导入顺序。开始时，选择没有依赖关系的表，然后依次选择那些依赖关系已经满足的表。
手动调整SQL文件： 根据拓扑排序的顺序调整原始的database.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc954997cd971afcbd6d602ab05ca93c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f997ec7b18b7f7dd21f395f4088feb1a/" rel="bookmark">
			Every derived table must have its own alias
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误复现： 在写带有子查询或者在查询时产生临时表的查询时，可能会出现这个错误：
ERROR 1248 (42000): Every derived table must have its own alias 意思是「每一个派生出来的表都必须给它命名一个自己的别名」 错误的sql示例： select dataid FROM ( select dataid ,if(dataid in (select ID from aip_1732602471460208641_file where ID in(1095884)),"yes","no")AS results from gf_file where aipId = 1732602471460208641 ) where results = 'no' Limit 1 错误原因： 执行这个sql时就会产生一张新的表，和前面的表联合查询
select dataid ,if(dataid in (select ID from aip_1732602471460208641_file where ID in(1095884)),"yes","no")AS results from gf_file where aipId = 1732602471460208641 但是mysql要求每一个派生出来的表都必须有一个自己的别名，那我给派生表加上别名即可；
eg：修改后的sql，直接在新生产的表中加入 他的别命名就行（“as a”或者“a”），“a”为新表的别名
select dataid FROM ( select dataid ,if(dataid in (select ID from aip_1732602471460208641_file where ID in(1095884)),"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f997ec7b18b7f7dd21f395f4088feb1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89a02164d1b89ccf471aae50cf1c607a/" rel="bookmark">
			Java实现Excel导入和导出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 、环境准备 maven依赖 本次工具类的封装主要依赖于阿里巴巴的JSON包，以及表格处理的POI包，所以我们需要导入这两个库的依赖包，另外，我们还需要文件上传的相关包，毕竟我们在浏览器页面，做Excel导入时，是上传的Excel文件
&lt;!--excel工具依赖 start--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpmime&lt;/artifactId&gt; &lt;version&gt;4.5.7&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JSON --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.83&lt;/version&gt; &lt;/dependency&gt; &lt;!-- POI --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;3.16&lt;/version&gt; &lt;/dependency&gt; &lt;!--excel工具依赖 end--&gt; 引进knife，方便进行测试 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;2.7.8&lt;/version&gt; &lt;/dependency&gt; &lt;!--knife4j start--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.9&lt;/version&gt; &lt;/dependency&gt; &lt;!--knife4j end--&gt; 相关util工具类 public class ExcelClassField { /** 字段名称 */ private String fieldName; /** 表头名称 */ private String name; /** 映射关系 */ private LinkedHashMap&lt;String, String&gt; kvMap; /** 示例值 */ private Object example; /** 排序 */ private int sort; /** 是否为注解字段：0-否，1-是 */ private int hasAnnotation; public String getFieldName() { return fieldName; } public void setFieldName(String fieldName) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89a02164d1b89ccf471aae50cf1c607a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed4419cee3a8ce90e147fb268bc33e4e/" rel="bookmark">
			maven的依赖如何添加
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在pom.xml文件中添加以下依赖：
&lt;project&gt; ... &lt;dependencies&gt; &lt;dependency&gt; ... &lt;/dependency&gt; ... &lt;/dependencies&gt; ... &lt;/project&gt; 例子：
对于Java 11或更高版本，你可能需要添加类似下面的依赖：
&lt;dependency&gt; &lt;groupId&gt;net.java.dev.jna&lt;/groupId&gt; &lt;artifactId&gt;jna&lt;/artifactId&gt; &lt;version&gt;5.9.0&lt;/version&gt; &lt;/dependency&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0243a6a10b481734c080476aaa31b4c8/" rel="bookmark">
			Java Swing 学生考勤管理系统 窗体项目 期末课程设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学生考勤管理系统 视频教程 源码 https://www.bilibili.com/video/BV1zT4y1W7NF/
系统功能
使用Java语言实现学生考勤管理系统，系统具备如下功能：
a) 系统分为管理员、教师、学生三个角色；
b) 提供登录和修改密码功能；
c) 系统管理员登录后可进行班级管理、教师管理、课程管理、学生管理；
d) 教师登录后可对学生进行考勤登记、考勤统计和导出。
e) 学生登录后可查看自己的考勤记录。
1 登录 a) 系统启动后展示登录界面；
b) 用户需输入正确的用户名密码，选择对应的身份进行登录；
c) 用户名或密码错误时登录失败，应给出对应提示；
d) 学生的用户名即为学号。
登录界面
2 修改密码 a) 在修改密码界面输入新密码；
b) 修改密码后退出登录，返回登录界面。
修改密码界面
3 班级管理（管理员） a) 管理员登录后可进行班级管理；
b) 根据班级名查询班级信息；
c) 点击添加按钮，进入机型添加界面；
d) 选中一条数据，点击编辑按钮可进行修改操作；
e) 选中一条数据，点击删除按钮可删除班级。
管理员-班级列表界面
管理员-添加/修改班级界面
4 教师管理（管理员） a) 管理员可根据教师姓名查询教师；
b) 点击添加按钮可新增教师；
c) 选中一条数据，点击编辑按钮，对教师信息进行修改；
d) 选中一条数据，点击删除按钮，删除教师信息；
管理员-教师管理界面
管理员-添加/修改教师界面
5 课程管理（管理员） a) 管理员可根据课程名查询课程；
b) 点击添加按钮可新增课程，授课教师使用下拉列表选择；
c) 选中一条数据，点击编辑按钮，对课程信息进行修改；
d) 选中一条数据，点击删除按钮，删除课程信息；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0243a6a10b481734c080476aaa31b4c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98780c8248b52eff593c853c634805cf/" rel="bookmark">
			Devops相关问题及答案（2024）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、DevOps 的理念是什么？ DevOps是一种组织文化、流程和工具的集合，旨在提高软件交付的速度和质量，通过自动化和持续改进的方法来促进开发（Dev）和运维（Ops）的协作。
DevOps的核心理念包括： 文化变革：
协作：鼓励开发和运维团队更紧密地合作，打破团队之间的障碍。共享责任：团队成员集体对整个软件的生命周期和公司的最终产品负责。透明度：通过通信和共享信息来推进项目，促进了解和信任。 自动化流程：
持续整合（CI）：自动化的软件构建、测试，使得代码更频繁地合并到主分支。持续交付（CD）：自动化的部署过程，使得新的代码改动更快地部署到生产环境。配置管理：使用代码进行系统配置的管理，确保环境之间的一致性和可复制性。监控和日志：自动化的监控和日志记录，确保即时发现问题并快速反应。 持续反馈和改进：
反馈循环：通过监控和度量，实时了解系统的表现和反馈用户体验。快速迭代：鼓励快速而又频繁地发布小的改动，支持业务持续和稳定地增长。持续学习：从成功和失败中学习，不断改进工具和流程。 加强工具链的使用：
采用合适的工具来支持上述流程，如版本控制系统、自动化部署工具、配置管理工具、监控系统、容器化以及编排平台等。 系统思维：
识别和理解开发、测试和运维之间复杂的相互作用，促进跨部门、多学科的整体优化，而不是局部最优化。 DevOps的实施 要实践DevOps，组织通常遵循几个实施步骤：
评估现状：理解当前的开发和部署流程。设定目标：明确实施DevOps所期望达到的目标。小步快走：采用迭代的方法逐步实施变革。跨职能协作：让跨职能团队共同工作，突破传统边界。培训和指导：加强团队能力，尤其是对新工具和新流程的培训。持续改进：通过度量和反馈来持续优化流程。 DevOps的效益 通过DevOps实践，组织可以获得多个方面的益处：
更快的交付时间：通过自动化和改良流程，可以更快地推动新功能和修补到生产环境。更高的可靠性：通过持续的测试和监控，可以确保部署的质量，并快速修复问题。改善协作：共享目标和工作流程提高了团队之间的协作。成本节约：自动化和优化流程减少了必要的手工劳动，降低了运维成本。技术和业务协同：使技术决策更加支持业务目标，反之亦然。 DevOps不是一个工具或是一个具体的方法论，它是融合文化、工具、流程和实践到一起的集合体，旨在缩短从开发到操作的软件开发生命周期，并提升持续交付的能力。
2、持续集成（CI）和持续部署（CD）？ 持续集成（Continuous Integration，简称CI）和持续部署（Continuous Deployment，简称CD）是现代软件开发中使用的实践方法，特别是在遵循敏捷和DevOps原则的团队中。它们旨在提高软件开发和发布的速度和效率。另外，持续交付（也称为CD，有时用于区分持续部署）是这一实践的一个弱化版本。
持续集成（CI） 持续集成是一种开发实践，开发人员经常（通常是每日多次）将代码变更合并到共享仓库（如Git）中。每次代码合并后，都会自动触发一系列快速的构建和测试步骤，以确保新代码的变更不会引入错误，并且系统作为一个整体仍能正常工作。
深入CI的关键组件：
自动化构建：
创建一致的方式来编译源代码成可执行文件的过程，这通常包括编译、链接和打包。 质量检查：
代码质量分析工具检查代码标准遵守情况和潜在的缺陷。静态分析和动态分析工具用于识别安全漏洞。 测试自动化：
单元测试验证代码片段如方法和函数是否按预期工作。集成测试确保不同的代码块和服务在一起工作时表现正常。系统测试验证整个系统的行为和功能。 反馈机制：
快速提供反馈给开发团队，以便于及时识别和修复问题。集成错误报告和测试失败的实时通知。 版本控制集成：
版本控制工具（如Git）用于追踪每一次代码的变更和合并。 持续部署（CD） 持续部署是一种实践，它确保软件可以被自动部署到生产环境中。这意味着对应用程序的变更—无论是新的功能、bug修复还是配置变更—一旦完成且通过所有的测试和质量检查，它们就可以立即部署到用户可以访问的环境中。
深入CD的关键组件：
持续交付：
CD的第一部分通常指的是持续交付，这确保了可以随时将代码的新版本手动部署到生产环境。包含自动化的构建和测试，但是进入生产环境前需要人工批准。 持续部署：
当提到CD时，它也可以指代持续部署，这进一步自动化了从开发到生产的整个流程，不需要人工干预。 自动化部署管道：
一系列自动化的步骤，包括应用程序的部署、额外的自动化测试（如性能测试、用户界面UI测试）和上线准备。 监控和回滚
在生产环境中，监控工具确保即时捕获问题。自动化回滚流程可以在检测到错误时将应用恢复到前一个版本。 基础设施即代码（IaC）：
使用代码来管理和设置服务器、网络和其他基础架构的配置，以确保部署环境的一致性。 实施CI/CD时的考虑因素： 环境一致性：确保开发、测试和生产环境尽可能一致，减少环境差异引起的问题。高质量的测试套件：持有一个全面覆盖的、自动化的、高质量的测试套件是CI/CD的核心。特征开关和蓝绿部署：这些技术允许团队对新变更进行渐进式发布，最小化风险。文化和心态改变：团队需要采纳快速失败、快速修复的理念，并且习惯于高频率的变更。 实施CI/CD可以显著减少软件交付时间，增强开发的灵活性和系统的稳定性，提高产品质量，这成为现代软件开发的重要组成部分。
3、什么是基础设施即代码（IaC），并解释其优势？ 基础设施即代码（Infrastructure as Code，缩写为IaC）是一种使用机器可读的定义文件来管理和自动配置硬件和虚拟化平台的技术。基于文本的脚本或定义文件充当了传统硬件信息技术基础结构手动配置和交互操作的替代品。
基础设施即代码的核心概念： 代码管理：
使用声明式或命令式编程来定义基础设施，声明式（如Terraform、AWS CloudFormation）定义了“目标状态”，而命令式（如Ansible、Chef）定义了“达成目标状态的过程”。 版本控制：
与应用程序代码一样，基础设施代码也使用版本控制系统（如Git）进行管理，提供历史追踪、变更审核、回滚等功能。 自动化：
自动化基础设施的配置、部署、管理以减少人为错误和提高效率。 幂等性：
通过IaC工具实施的配置管理和自动化确保幂等性，即多次应用同一配置不会改变系统状态。 系统抽象：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98780c8248b52eff593c853c634805cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9409aa5b85465e7e535667bdc6f8818/" rel="bookmark">
			银行的压力测试如何进行？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么要进行压力风险测试？ 压力风险测试的最终目的是测试银行在极度恶劣的市场环境中是否有足够的资本维持运转。 题主链接中的一级资本充足率(Tier 1 capital ratio) 亦即衡量标准，这个数字越大，表明银行资本约充裕，可以在停止运营前吸收越大的损失。
压力风险测试是08年危机之后普遍被金融机构以及监管机构采纳的一种风险控制手段，较之传统的一些方法(VaR, What if) ，压力风险测试的特点在于其压力情景(Stress scenario)普遍更恶劣且具有前瞻性，同时压力风险测试一般强调将金融机构作为一个整体进行分析。
美联储的CCAR都包含哪些内容？ 美联储的压力测试的主体是一个九季度的预测：这九个季度本质上是一次假设的全球性的金融危机，包含市场急剧恶化，触底和逐步恢复的过程。美联储会提供一些宏观变量(GDP, 失业率等)以及金融变量(标普500，BBB企业债利差等）在这九季度内的变化过程。而金融机构则被要求利用内部模型预测自身在这九季度内的营收与亏损，举个例子，一个商业银行需要预测每季度损失的商业贷款(Credit Loss Forecasting)，同时也要预测每个季度的由于运营所带来的收入(Pre-provision net revenue)。对于投资银行，需要额外预测交易损失等一系列额外变量。 这些盈亏项目结合起来即可获得金融机构自身每个季度一级资本的变化。美联储对于九季度内的一级资本充足率有一个最低要求，以保证银行在相应的市场环境下用充资本维持运营。题主链接中的银行就没有满足相应的要求。
对于在美资产500亿美元以上的投资银行，除了9季度的预测外还有一个附加压力测试，亦即环球市场动荡(Global Market Shock)。 这是一个专门为投资银行设计的猝发头寸削减。它包含：
交易头寸削减 (Trading Mark to Market Loss)最大交易对手方违约产品发行人违约损失衍生品CVA损失
环球市场动荡的损失将会被加入最终一级资本充足率的计算中。 除了美联储设计的九季度情景，每个金融机构也需要自己设计一套九季度压力测试情景和相应环球市场动荡。金融机构设计情景时需要从自身风险特点出发，着重关注与其产品组合相关的风险因子，例如加州的商业银行常设计加州资产价格暴跌的场景，而某做市投行会在市场交易量持续走低上做文章。
风险测试的实施与影响 美联储的风险测试评估不仅关注定量的结果，即一级资本充足率，更关注金融机构是如何定性的研究自己风险属性并得出相应模型和结果的。去年德意志银行和Santander都是未能通过风险测试的定性部分。
一个完备的压力测试过程应该从风险评估开始(risk identification)，在这个过程中确定金融机构整体面临的风险以及其严重性(materiality)。在风险评估结果的基础上，金融机构应该相应的设计自己的压力测试情景并设计开发模型。
在情景和模型完备后，金融机构可以开始实施压力测试并解读其结果。从最终一级资本充足率水平出发可以分析金融机构还可以承受多少额外风险，这将作为确定金融机构风险偏好(risk appetite)及各个交易部门风险上限的出发点。
同时，如果像题主链接中一样不能通过美联储风险测试，金融机构的在美实体不能将盈利转移至母公司或者用于分红。 这对于金融机构本身的信誉也是有一定负面影响的。
其他 压力风险测试作为银行的风控工具已经存在了很多年，但是真正成为监管机构的控制工具仅仅从08之后刚刚起步。
一方面这样的控制手段提高了了银行的稳定性，加强了银行对于其风险资产的控制，减少了银行的杠杆，对于整个金融生态系统是有益的。
但同时，昂贵的资本费用让许多投资银行开始逐步削减其业务，降低了市场的交易量和有效性。
总之，在做银行的压力测试前，首先我们要对银行的一些基本概念和运作流程有一定认识，并且，要对风控这一块也要有一定认知，否则你都不知道测哪里。最后就是扎实自己的测试功底，其他就按照正常操作来就行。PS：如果你尽早的学了安全测试的一些知识的话，会对你做这些有比较大的帮助。
文章来源：网络 版权归原作者所有
上文内容不用于商业目的，如涉及知识产权问题，请权利人联系小编，我们将立即处理
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/666a6e01b78b5a4f555a2fbc4627b28c/" rel="bookmark">
			使用懒加载 &#43; 零拷贝后，程序的秒开率提升至99.99%
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、5秒钟加载一个页面的真相二、优化四步走1、“懒加载”2、线上显示 = 就读取一个文件，为什么会慢呢？ 三、先从上帝视角，了解一下啥子是IO流四、写个栗子，测试一下1、通过字符输入流FileReader读取2、通过缓冲流BufferedReader读取3、再点进源码瞧瞧。（1）FileReader.read()源码很简单，就是直接读取（2）BufferedReader.read()的源码就较为复杂了，看一下它的核心方法fill()（3）buffer四大属性 4、缓冲流：4 次上下文切换 + 4 次拷贝 五、NIO之FileChannel1、FileChannel 常见的方法有2、关于Buffer 和 Channel的注意事项和细节3、Selector(选择器)4、selector的相关方法 六、内存映射技术mmap1、文件映射2、Java中使用mmap3、内存映射技术mmap：4 次上下文切换 + 3 次拷贝 七、sendFile零拷贝1、传统IO流2、sendFile零拷贝3、sendFile零拷贝：2 次上下文切换 + 2次拷贝重置优化4：通过零拷贝读取文件 八、总结经过4次优化，将页面的加载时间控制在了1秒以内，实打实的提升了程序的秒开率。通过一次页面优化，收获颇丰： 大家好，我是哪吒。
一、5秒钟加载一个页面的真相 今天在修改前端页面的时候，发现程序中有一个页面的加载速度很慢，差不多需要5秒，这其实是难以接受的，我也不知道为什么上线这么长时间了，没人提过这个事儿。
我记得有一个词儿，叫秒开率。
秒开率是指能够在1秒内完成页面的加载。
查询的时候，会访问后台数据库，查询前20条数据，按道理来说，这应该很快才对。
追踪代码，看看啥问题，最后发现问题有三：
表中有一个BLOB大字段，存储着一个PDF模板，也就是上图中的运费模板；查询后会将这个PDF模板存储到本地磁盘点击线上显示，会读取本地的PDF模板，通过socket传到服务器。 大字段批量查询、批量文件落地、读取大文件并进行网络传输，不慢才怪，这一顿骚操作，5秒能加载完毕，已经烧高香了。
二、优化四步走 1、“懒加载” 经过调查发现，这个PDF模板只有在点击运费模板按钮时才会使用。
优化1： 在点查询按钮时，不查询PDF模板；优化2： 点击运费模板时，根据uuid去查询，这样既能触发索引，也不用按时间排序，只是查询单条，速度快了很多很多，我愿称你为“懒加载”。优化3： 通过异步，将文件保存到磁盘中。 2、线上显示 = 就读取一个文件，为什么会慢呢？ 打开代码一看，居然是通过FileReader读取的，我了个乖乖~
这有什么问题吗？都是从百度拷贝过来的，百度还会有错吗？而且也测试了，没问题啊。
嗯，对，是没问题，是可以实现需求，可是，为什么用这个？不知道。更别说效率问题了~
优化4：通过缓冲流读取文件
三、先从上帝视角，了解一下啥子是IO流 Java I/O (Input/Output) 是对传统 I/O 操作的封装，它是以流的形式来操作数据的。
InputStream 代表一个输入流，它是一个抽象类，不能被实例化。InputStream 定义了一些通用方法，如 read() 和 skip() 等，用于从输入流中读取数据；OutputStream 代表一个输出流，它也是一个抽象类，不能被实例化。OutputStream 定义了一些通用方法，如 write() 和 flush() 等，用于向输出流中写入数据；除了字节流，Java 还提供字符流，字符流类似于字节流，不同之处在于字符流是按字符读写数据，而不是按字节。Java 中最基本的字符流是 Reader 和 Writer，它们是基于 InputStream 和 OutputStream 的转换类，用于完成字节流与字符流之间的转换。BufferedInputStream 和 BufferedOutputStream 是 I/O 包中提供的缓冲输入输出流。它们可以提高 I/O 操作的效率，具有较好的缓存机制，能够减少磁盘操作，缩短文件传输时间。使用 BufferedInputStream 和 BufferedOutputStream 进行读取和写入时，Java 会自动调整缓冲区的大小，使其能够适应不同的数据传输速度。可以读取或写入 Java 对象的流，比较典型的对象流包括ObjectInputStream 和 ObjectOutputStream，将 Java 对象转换为字节流进行传输或存储； 在上一篇《增加索引 + 异步 + 不落地后，从 12h 优化到 15 min》中，提到了4种优化方式，数据库优化、复用优化、并行优化、算法优化。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/666a6e01b78b5a4f555a2fbc4627b28c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a530fdc444dbfeeffdccd6e3c34f2e83/" rel="bookmark">
			Java Swing 机票预定管理系统 窗体项目 期末课程设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		机票预定管理系统 视频教程 源码下载 https://www.bilibili.com/video/BV1jw41147NT/
使用Java语言实现机票预订管理系统，系统具备如下功能：
a) 系统分为管理员和乘客两个角色；
b) 提供登录和修改密码功能；
c) 系统管理员登录后可进行机型管理、航线管理、订单查询；
d) 机型管理包括查询飞机机型、添加机型、停运机型。
e) 航线管理包括添加航线、航线查询、停运/启运；
f) 客户登录后可选择航线进行机票预定、改签、退票。
g) 可代他人买票，客户可查询自己购买的机票、自己是乘客的机票。
1 登录 a) 系统启动后展示登录界面；
b) 用户需输入正确的用户名密码，选择对应的身份进行登录；
c) 用户名或密码错误时登录失败，应给出对应提示；
d) 乘客的用户名即为身份证号。
2 注册 a) 在登录窗口点击注册按钮可以打开注册页面；
b) 需要对用户输入进行校验，如非空校验；
c) 需要校验身份证号是否存在，已存在则不能注册；
d) 注册成功后跳转会登录窗口。
图4.2 注册界面
3 修改密码 a) 在修改密码界面输入新密码；
b) 修改密码后退出登录，返回登录界面。
图4.3 修改密码界面
4 机型管理（管理员） a) 管理员登录后可进行机型管理；
b) 机型管理界面可根据航空公司和机型查询所有飞机信息；
c) 选中一条数据，点击“停运/启用”按钮可以进行状态修改；
d) 选中一条数据，点击“设定航线”按钮可以进入添加航线界面；
e) 点击添加按钮，进入机型添加界面；
f) 添加机型信息时，需校验数据输入，如非空校验、整数校验。
图4.4 管理员-机型列表界面
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/e4916c62cbba406fa41e5e6477459a82.png
图4.5 管理员-添加机型界面
4.3.5 添加航班（管理员）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a530fdc444dbfeeffdccd6e3c34f2e83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59e2e10fc6a305927620d60c8e020855/" rel="bookmark">
			一道嗖嘎的证明题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设 f ( x ) f(x) f(x)在区间[0,1]上连续可微，满足 0 &lt; f ′ ( x ) ≤ 1 0&lt;f'(x)\leq1 0&lt;f′(x)≤1,任给 x ∈ [ 0 , 1 ] x\in[0,1] x∈[0,1]且 f ( 0 ) = 0 f(0)=0 f(0)=0，试证：
∫ 0 1 ( f ( x ) ) 3 d x ≤ ( ∫ 0 1 f ( x ) d x ) 2 \int_0^1\left(f\left(x\right)\right)^3\mathrm{d}x\leq\left(\int_0^1f(x)\mathrm{d}x\right)^2 ∫01​(f(x))3dx≤(∫01​f(x)dx)2
证明：
由 0 &lt; f ′ ( x ) ≤ 1 0&lt;f'(x)\leq 1 0&lt;f′(x)≤1知：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59e2e10fc6a305927620d60c8e020855/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b6606b4924f5e9424803b190512ddeb/" rel="bookmark">
			eureka ConnectException如何解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近开始学习微服务，配置了一个超级简单的eureka，居然频繁报错无法启动，总是报ConnectException，踩了不少坑，因此记录一下。
【未解决】一种典型的做法是配置一个WebSecurityConfig，把某些安全策略关掉，未果。【已解决】另一种做法是在application.yml配置里面禁止eureka client注册自己，将fetchRegistry和registerWithEureka设置为false。 # application.yml eureka: client: fetchRegistry: 'false' registerWithEureka: 'false' Reference:
https://stackoverflow.com/questions/56114871/cannot-connect-to-eureka-server-exception-java-net-connectexception-connectio
Explanation:
We’re telling the built-in Eureka Client not to register with itself because our application should be acting as a server.
The reason behind this error is Eureka client is trying to register and fetch information with Eureka server. This happens because of bean auto configuration feature in spring Boot. As you are deploying the Eureka server you don’t need want to register with yourself.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b6606b4924f5e9424803b190512ddeb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53fc95d820baea17363db07eb755e0d3/" rel="bookmark">
			类名.this：内部类引用外部类实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		类名.this是啥意思？ 今天在看尚硅谷的课程时里面讲了这么一句话：
集合在遍历时需要先创建一个容器，存放集合的数据，这样做浪费内存
想去验证下，就翻了翻ArrayList的迭代过程源码
在ArrayList的迭代器类Itr（ArrayList的内部类）源码中有这么一段代码
Object[] elementData = ArrayList.this.elementData; 结论：
这行代码是Java中内部类（Inner Class）中的一种用法，通过类名.this来引用外部类的实例。
在上述代码中，ArrayList.this表示在ArrayList的非静态内部类Itr中，引用外部的ArrayList实例的elementData属性。
在Java中，内部类有时候会引用外部类的实例。为了明确地表示使用的是外部类的实例而不是内部类的实例，可以使用外部类名.this的形式。
为什么内部类可以拿到外部类的实例? 结论 成员内部类能够访问外部类的实例是因为编译器会在内部类中隐式地维护一个对外部类实例的引用。 解释 在 Java 中，内部类（Inner Class）可以访问其外部类（Enclosing Class）的实例，这是因为内部类被认为是外部类的一部分。这种访问的机制涉及到内部类的实现方式以及编译器的处理。
有两种主要的内部类：成员内部类（Member Inner Class）和静态内部类（Static Inner Class）。
成员内部类： 成员内部类是一个非静态的内部类，它隐含地持有对外部类实例的引用。当创建成员内部类的实例时，实际上会与外部类的实例关联起来。这就允许成员内部类访问外部类的实例变量和方法，同时也能够访问外部类的私有成员。
public class OuterClass { private int outerVar; public class InnerClass { public void doSomething() { // 在内部类中可以访问外部类的实例变量 outerVar = 10; } } } 静态内部类： 静态内部类是一个与外部类实例无关的内部类。它不隐含地持有对外部类实例的引用，因此在静态内部类中不能直接访问外部类的非静态成员。如果需要访问外部类的实例，必须通过外部类的对象来实现。
public class OuterClass { private static int staticVar; public static class StaticInnerClass { public void doSomething() { // 在静态内部类中不能直接访问外部类的实例变量 // 但可以访问外部类的静态变量 staticVar = 20; } } } 总体而言，内部类能够访问外部类的实例是因为编译器会在内部类中隐式地维护一个对外部类实例的引用。这样的设计允许内部类更容易地与其外部类进行交互。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53fc95d820baea17363db07eb755e0d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efd26c6c8e1248baf05d441b2642a314/" rel="bookmark">
			NIO核心依赖多路复用小记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NIO允许一个线程同时处理多个连接，而不会因为一个连接的阻塞而导致其他连接被阻塞。核心是依赖操作系统的多路复用机制。
操作系统的多路复用机制 多路复用是一种操作系统的 I/O 处理机制，允许单个进程（或线程）同时监视多个输入或输出流的就绪状态。这样，一个进程就能够通过一个系统调用来等待多个事件，而不是为每个事件创建一个独立的进程或线程。
多路复用常见机制 select： select 是一个系统调用，通过它可以同时监视多个文件描述符（通常是套接字）。当其中任何一个文件描述符准备好进行读取或写入时，select 就会返回，并告诉程序哪些文件描述符处于就绪状态。
poll： poll 也是一个系统调用，它和 select 类似，但是对文件描述符的管理更加灵活，而且没有文件描述符数目的限制。
epoll： epoll 是 Linux 中引入的一种多路复用机制，相对于 select 和 poll 具有更好的性能。epoll 使用事件通知的方式，只关心那些发生了变化的文件描述符，减少了遍历全部文件描述符的开销。
网络请求的流程 当客户端请求到达服务器时，整个流程可以分为以下几个步骤，涉及用户态和内核态的协同工作：
服务器启动： 服务器程序在用户态中启动，并创建一个监听 socket。这个监听 socket 负责接收客户端的连接请求。
监听连接： 服务器使用 select 或其他多路复用的系统调用，将监听 socket 添加到文件描述符集合中，然后阻塞等待事件发生。这时用户程序告诉内核要监听哪些文件描述符，而这些文件描述符通常是由 accept 等系统调用返回的新连接。
客户端连接： 当有客户端发起连接请求时，内核接收到连接请求，然后将新的连接 socket（客户端连接的文件描述符）添加到文件描述符集合中。此时内核通知用户程序，有文件描述符就绪。
处理连接： 用户程序从 select 返回后，检查文件描述符集合，确定哪些连接处于就绪状态。然后，用户程序可以通过 accept 接受新的连接，获得新的文件描述符，并处理与客户端的通信。
下面是一个简化的伪代码示例：
// 服务器启动 int listen_fd = create_and_bind_socket(port); listen(listen_fd, SOMAXCONN); // 设置监听 socket 到文件描述符集合 fd_set master_fds; FD_ZERO(&amp;master_fds); FD_SET(listen_fd, &amp;master_fds); int max_fd = listen_fd; while (true) { fd_set read_fds = master_fds; // 使用 select 监听文件描述符 int ready = select(max_fd + 1, &amp;read_fds, NULL, NULL, NULL); if (ready == -1) { // 处理错误 } else { // 检查文件描述符集合，确定哪些连接就绪 for (int i = 0; i &lt;= max_fd; ++i) { if (FD_ISSET(i, &amp;read_fds)) { if (i == listen_fd) { // 有新连接 int new_fd = accept(listen_fd, .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/efd26c6c8e1248baf05d441b2642a314/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a9c4b0ef1ec8c8c931b04134b5a6c5c/" rel="bookmark">
			响应式编程Reactor优化Callback回调地狱
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Reactor是什么 Reactor 是一个基于Reactive Streams规范的响应式编程框架。它提供了一组用于构建异步、事件驱动、响应式应用程序的工具和库。Reactor 的核心是 Flux（表示一个包含零到多个元素的异步序列）和 Mono表示一个包含零或一个元素的异步序列）。Reactor 通过提供响应式的操作符，如map、filter、flatMap等，使得开发者能够方便地进行数据流的转换和处理。 2. Reactor、Callback、CompletableFuture三种形式异步编码对比 编码简洁程度Reactor最优Reactor线程利用率最高（因实现了Reactive Streams规范，拥有背压+事件驱动特性，此处暂不展开) 代码如下：
pom依赖
&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.projectreactor&lt;/groupId&gt; &lt;artifactId&gt;reactor-bom&lt;/artifactId&gt; &lt;version&gt;2023.0.0&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.projectreactor&lt;/groupId&gt; &lt;artifactId&gt;reactor-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; Callback回调地狱 interface FirstCallback { void onCompleteFirst(String result); void onErrorFirst(Exception e); } interface SecondCallback { void onCompleteSecond(String result); void onErrorSecond(Exception e); } interface ThirdCallback { void onCompleteThird(String result); void onErrorThird(Exception e); } class AsyncOperations { static void firstOperation(FirstCallback firstCallback) { new Thread(() -&gt; { try { // 模拟异步操作 Thread.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a9c4b0ef1ec8c8c931b04134b5a6c5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf7d00d68ad0bcf104ca0edf4007bfa9/" rel="bookmark">
			Flowable工作流入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		课程来源B站大佬波哥的课程
本文仅做笔记，课件需要的联系B站大佬获取
0.前置 相关话术 流程定义（Process Definition）： 描述业务流程的定义，通常使用BPMN（Business Process Model and Notation）进行建模。流程定义包括流程中的任务、网关、事件等元素，以及它们之间的顺序和关系。
流程实例（Process Instance）： 在运行时由流程定义创建的具体流程执行实例。每个流程实例代表了一个特定的业务流程执行过程。
任务（Task）： 流程中需要执行的工作单元，可以是用户任务、服务任务等。任务需要被分配给具体的角色或用户来执行。
用户任务（User Task）： 需要人类参与的任务，通常与特定用户或用户组相关联，需要用户手动完成。
服务任务（Service Task）： 由系统或服务执行的任务，通常是自动化的，不需要人工干预。
网关（Gateway）： 用于控制流程中的分支和合并，决定流程的走向。Flowable支持各种类型的网关，如排他网关、并行网关等。
流程变量（Process Variable）： 在流程实例中传递和存储数据的机制。流程变量可以在不同的任务之间传递信息，用于控制流程的行为。
部署（Deployment）： 将流程定义部署到Flowable引擎中，使其可以被实例化和执行。一个部署可以包含一个或多个流程定义。
执行（Execution）： 表示流程实例中的一个执行状态，包含当前执行到的节点、流程变量等信息。
历史数据（Historic Data）： 记录流程实例的历史信息，包括已完成的任务、执行时间等。Flowable提供了历史数据查询的功能。
流程引擎（Process Engine）： 是flowable的核心，或者说是flowable本身，它提供了执行、控制和管理流程实例的功能。
工作过程 流程建模： 首先，业务分析师或流程设计者使用流程建模工具，如Flowable提供的图形化建模工具，创建业务流程模型。这个模型包括流程定义、任务、网关、事件等元素，以及它们之间的流程顺序和条件。
部署流程定义： 将创建好的流程模型进行部署。部署是将流程定义加载到流程引擎中的一个过程，使其可以被实例化和执行。部署可以包括一个或多个流程定义，并在流程引擎中分配唯一的标识符。
流程实例化： 当需要执行业务流程时，流程引擎根据已部署的流程定义创建流程实例。每个流程实例都是特定业务流程的一个具体执行过程。
流程执行： 流程引擎根据流程定义中的逻辑，按照事先定义的流程顺序和条件执行各个任务和活动。这可能涉及到用户任务（等待人工处理）、服务任务（自动化任务）、网关（流程控制）等。
任务分配和处理： 当流程中涉及到用户任务时，流程引擎将任务分配给具体的用户或用户组。这个过程可以包括通知相关人员，提醒他们有任务需要处理。
流程控制： 流程引擎根据流程中的网关来控制流程的走向，例如，并行网关允许多个路径同时执行，排他网关根据条件选择一个路径。
流程变量： 在流程实例执行过程中，流程引擎可以使用和传递流程变量，这些变量可以在不同的任务之间传递数据，影响流程的行为。
历史记录： 流程引擎记录流程实例的历史数据，包括已完成的任务、执行时间、流程变量等。这些历史数据对于监控和报告业务流程的执行情况非常重要。
流程结束： 当流程中的所有任务和活动都完成时，流程实例结束。此时，可以进行一些收尾工作，如记录最终状态、生成报告等。
引入flowable时pom所需依赖 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.flowable&lt;/groupId&gt; &lt;artifactId&gt;flowable-engine&lt;/artifactId&gt; &lt;version&gt;6.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.flowable&lt;/groupId&gt; &lt;artifactId&gt;flowable-json-converter&lt;/artifactId&gt; &lt;version&gt;6.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf7d00d68ad0bcf104ca0edf4007bfa9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8337a631dc8057876da499edcec29f0/" rel="bookmark">
			大模型训练踩坑记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		按照博客进行模型的微调，遇到的bug记录。
【1】执行
python train_qlora.py --train_args_file train_args/sft/qlora/chatglm3-6b-sft-qlora.json
报错：
libcublas.so.11: undefined symbol: cublasLtGetStatusString, version libcublasLt.so.11
解决方法，详见：这里
中间重新安装pytorch都不行，上面写的 pip uninstall nvidia_cublas_cu11 可以work。
【2】个人使用设备双卡T4，每个卡16G，2张卡32G，qlora方法微调chatglm3-6b。
执行
python train_qlora.py --train_args_file train_args/sft/qlora/chatglm3-6b-sft-qlora.json
之后，跑起来之后OOM，报错如下：
torch.cuda.OutOfMemoryError: CUDA out of memory. Tried to allocate 1.98 GiB (GPU 0; 14.76 GiB total capacity; 13.16 GiB already allocated; 315.75 MiB free; 13.72 GiB reserved in total by PyTorch) If reserved memory is &gt;&gt; allocated memory try setting max_split_size_mb to avoid fragmentation. See documentation for Memory Management and PYTORCH_CUDA_ALLOC_CONF
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8337a631dc8057876da499edcec29f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5647093dcec95eaef204f3f7ff44fbec/" rel="bookmark">
			Curl命令POST请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		curl工具介绍： CURL是一个利用URL语法在命令行下工作的文件传输工具，被广泛应用在Unix、Linux发行版中，并且有DOS和Win32、Win64的移植版本。同时它还支持诸多的通信协议（我们常用的有HTTP、HTTPS、FTP、SMTP、TELNET等）。
我们可以使用它进行HTTP POST、HTTP PUT、FTP上传、cookies、用户认证、IP代理、网页下载等常用功能。
本文重点： 本文主要对curl功能中的HTTP POST进行介绍，主要用于在linux环境下进行接口测试或现场联调。（在windows环境下，我们可以采用postman等请求工具代替）
坑点： windows下的curl工具，在引号，中文等问题上，有很多坑，建议使用linux下的curl。
常见curl POST请求示例： 1. 请求参数为json数据
curl -i -H "Content-Type:application/json" -X POST -d '{"XXX":"xxx"}' http://localhost:18080/test 2.请求参数为表单数据
curl -i -d "symbol=sz000001&amp;scale=5&amp;ma=5&amp;datalen=1" -X POST http://money.finance.sina.com.cn/quotes_service/api/json_v2.php/CN_MarketData.getKLineData 常用命令选项解释： 上面请求示例中的 -i 是为了获取返回的请求头信息。如图
-i 、-I （大写i）、-v 的作用有相同之处。
-v是verbose的意思，意为啰嗦的,唠叨的,它能输出整个请求过程，请求头，响应头，响应结果等一系列信息。
-i 是include的意思，返回响应结果的同时返回响应头。
-I 是 仅返回响应头
-----------------------------------------------------------------------------------------------------------------------------------------
-H 是header的意思，可以自定义要发送到服务端的请求头。如-H "Content-Type:application/json"
-X （大写x）表示使用指定的请求方式。如果不清楚默认请求方式时建议指定请求方式。如 -X POST
-d 表示data,表示请求的数据，如 -d {\"XXX\":\"xxx\"} windows下注意点（linux忽略）： 1. json格式的数据需要进行转义，转成字符串的形式。如果请求参数为 -d '{"XXX":"xxx"}' 有时会报400，bad request，后台无法接受数据，需转义为 "{\"XXX\":\"xxx\"}" 的格式。
说“有时“的原因是我用windows下的curl工具执行：
curl -i -H "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5647093dcec95eaef204f3f7ff44fbec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfe531bd222e4f42ed6b98b48cdc75ac/" rel="bookmark">
			解决web项目发布新版本需要清除浏览器缓存的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决的方案有三种：
1、用户自行清理浏览器缓存。
2、使用禁用缓存标签，实现禁用浏览器缓存。
3、为js和css文件添加版本号。
2.1 第一种方式
用户自行清理游览器缓存。这个不太现实，老总受不了。
2.2 第二种方式
在html页面的head 头中添加如下代码：
&lt;meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" /&gt; &lt;meta http-equiv="Cache" content="no-cache"&gt; &lt;meta http-equiv="Pragma" content="no-cache" /&gt; &lt;meta http-equiv="Expires" content="0" /&gt; 2.3 第三种方式
在引用的静态文件后添加版本号参数，这个参数可以是时间戳或者随机数。处理方式的代码如下：
&lt;link rel="stylesheet" type="text/css" href="${pageContext.request.contextPath}/static/plugins/layui-v2.5.5/layui/css/layui.css?v=20200110052406"&gt; &lt;link rel="stylesheet" type="text/css" href="${pageContext.request.contextPath}/static/css/style.css?v=20200110052406"&gt; &lt;link rel="stylesheet" type="text/css" href="${pageContext.request.contextPath}/static/css/addStyle.css?v=20200110052406"&gt; &lt;link rel="stylesheet" type="text/css" href="${pageContext.request.contextPath}/static/css/template/addStyle.css?v=20200110052406"&gt; 对于页面我们还是希望有缓存的，这样可以减轻服务器的压力，加快响应时间。需要解决的问题是：每次发布新版本重新部署后，第一次访问获取的是最新的静态资源，下次访问在走游览器的缓存。
综合上述分析，选用第三种方式：加版本号
如果打war包，可以通过使用maven插件：maven-replacer-plugin来完成，这种方式不需要手动去改代码。
&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;!-- 版本号样式--&gt; &lt;maven.build.timestamp.format&gt;yyyyMMddHHmmss&lt;/maven.build.timestamp.format&gt; &lt;/properties&gt; &lt;!--清除浏览器缓存--&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;configuration&gt; &lt;!-- 使用缓存 --&gt; &lt;useCache&gt;true&lt;/useCache&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfe531bd222e4f42ed6b98b48cdc75ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87cf1880a71c46258730bb641bcb6d97/" rel="bookmark">
			文件内容对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;template&gt; &lt;div&gt; &lt;el-row :gutter="10"&gt; &lt;el-col :span="12"&gt; &lt;el-input :autosize="{ minRows: 30, maxRows: 50}" type="textarea" v-model="oldValue" placeholder=""&gt;&lt;/el-input&gt; &lt;/el-col&gt; &lt;el-col :span="12"&gt; &lt;el-input :autosize="{ minRows:30, maxRows: 50}" type="textarea" v-model="newValue" placeholder=""&gt;&lt;/el-input&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;code-diff :old-string="oldValue" :new-string="newValue" diff-style="char" filename="原文件" newFilename="修改后文件" output-format="side-by-side" /&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { oldValue: "", newValue: "", data: [ { title: "Book 1", authors: [ { name: "Author 1" }, { name: "Author 2" }, { name: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87cf1880a71c46258730bb641bcb6d97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45f9f92a07a39d47b51c616695707f56/" rel="bookmark">
			Nginx——日志自动切割
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
一、代码cut_logs.sh
二、定时任务
1、安装定时任务
2、设置每天00:00执行
3、 查看定时任务是否添加成功
4、重启定时任务 一、代码cut_logs.sh #!/bin/bash access_log_path=/usr/local/nginx/logs/access.log error_log_path=/usr/local/nginx/logs/error.log access_save_path=/usr/local/nginx/logs/Historical_logs/access_$(date +%Y%m%d -d 'yesterday').log error_save_path=/usr/local/nginx/logs/Historical_logs/error_$(date +%Y%m%d -d 'yesterday').log cp $access_log_path $access_save_path &amp;&amp; echo &gt; $access_log_path cp $error_log_path $error_save_path &amp;&amp; echo &gt; $error_log_path 二、定时任务 1、安装定时任务 yum install crontabs 2、设置每天00:00执行 crontab -e #输入 #0 0 * * * /usr/bin/sh cut_logs.sh #每天的00:00执行日志切分 3、 查看定时任务是否添加成功 crontab -l 4、重启定时任务 service crond restart 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/259e9ff53dc79d20e58d0962088e0c96/" rel="bookmark">
			Linux篇之Centos中将系统时间设置为本地时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要在 CentOS 上将系统时间设置为本地时间，可以按照以下步骤进行操作：
1.首先，你需要确定你想要设置的本地时间。例如，如果你想要将系统时间设置为当前时间（假设是北京时间），则可以使用以下命令获取当前时间：
`date +"%Y-%m-%d %H:%M:%S" 2.找到该命令输出的时间值，并将其记录下来。例如，假设当前时间是
2024-01-09 23:30:59。
3.通过以下命令打开系统时钟设置界面：
sudo timedatectl set-time '2024-01-09 23:30:59' 将命令中的日期和时间替换为你希望设置的本地时间。
4.然后，使用以下命令将硬件时钟设置为与系统时间同步：
sudo hwclock --systohc 完成这些步骤后，你的 CentOS 系统时间将会被设置为本地时间。你可以使用 date 命令来确认是否成功。
需要注意的是，如果使用了 NTP 等网络时间同步服务，那么系统时间可能会在一段时间后被重置为与网络时间同步。如果你想要修改这个设置，可以编辑 /etc/sysconfig/ntpdate 文件（如果不存在则创建），并添加以下行：
# Set to "no" to prevent network time sync SYNC_HWCLOCK=yes 将 SYNC_HWCLOCK 的值设置为 no 即可禁止网络时间同步服务调整本地时间。
注意：如果有报错：sudo timedatectl set-time ‘2024-01-09 15:32:05’
Failed to set time: Automatic time synchronization is enabled
出现该错误信息是因为自动时间同步服务开启并在运行中，无法手动设置时间。
如果你想要手动设置系统时间，你需要先禁用自动时间同步服务，并将其停止。你可以按照以下步骤操作：
1.禁用自动时间同步服务。你可以使用以下命令在
systemd 中禁用自动时间同步服务 systemd-timesyncd：
sudo timedatectl set-ntp off 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/259e9ff53dc79d20e58d0962088e0c96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d29acebf0717da3fcf1177f79e43303/" rel="bookmark">
			Nexus3中搭建Docker私服
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Nexus3之Docker私服搭建1.创建Docker仓库及设置1.1. 安装Nexus31.2. 创建用户1.3. 创建Blob Stores1.4. 创建Docker仓库 2. docker服务设置2.1. Linux系统2.2. windows 系统 3. 登录docker仓库并拉取镜像3.1. 登录docker仓库3.2. 拉取Redis镜像进行验证 Nexus3之Docker私服搭建 仓库类型
hosted本地存储，像官方仓库一样提供本地私库功能proxy提供代理其他仓库的类型group组类型，可以组合多个仓库为一个地址提供服务 1.创建Docker仓库及设置 1.1. 安装Nexus3 1.2. 创建用户 创建docker管理的用户：如：docker/docker
1.3. 创建Blob Stores 创建一个名称为docker的BlobStores
1.4. 创建Docker仓库 创建Docker(hosted),仓库，如：docker-hub 创建Docker(Proxy)仓库，如名称为“docker-proxy” 这里使用网易的docker镜像仓库地址：http://hub-mirror.c.163.com
创建Docker(group仓库)，如仓库名称为：docker-public
创建docker-public仓库后将 docker-hub与docker-proxy两个仓库添加到docker-public组中
2. docker服务设置 2.1. Linux系统 修改 /etc/docker/daemon.json 文件，内容如下 { "registry-mirrors": ["http://hub-mirror.c.163.com"], //在docker-proxy仓库中配置的docker镜像加速地址 "insecure-registries": ["192.168.31.110:8082","192.168.31.110:8083"], //非安全规则配置，如http "disable-legacy-registry": true } 重启docker 2.2. windows 系统 打开docker disktop,在设置中配置如下图内容 点击 “Apply &amp; Restart”按钮重启docker 3. 登录docker仓库并拉取镜像 3.1. 登录docker仓库 打开 power shell 登陆docker仓库
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d29acebf0717da3fcf1177f79e43303/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4086526988393a8b06e0c7a1b12ceeb3/" rel="bookmark">
			基于Java企业员工信息管理系统详细设计和实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主介绍：✌全网粉丝30W+,csdn特邀作者、博客专家、CSDN新星计划导师、Java领域优质创作者,博客之星、掘金/华为云/阿里云/InfoQ等平台优质作者、专注于Java技术领域和学生毕业项目实战,高校老师/讲师/同行前辈交流✌
主要内容：SpringBoot、Vue、SSM、HLMT、Jsp、PHP、Nodejs、Python、爬虫、数据可视化、小程序、安卓app、大数据、物联网、机器学习等设计与开发。
🍅文末获取源码联系🍅
👇🏻 精彩专栏推荐订阅👇🏻 不然下次找不到哟
2022-2024年最全的计算机软件毕业设计选题大全：1000个热门选题推荐✅
Java项目精品实战案例《100套》
Java微信小程序项目实战《100套》
Python项目实战《100套》
感兴趣的可以先收藏起来，还有大家在毕设选题，项目以及论文编写等相关问题都可以给我留言咨询，希望帮助更多的人
​ 系统介绍： 在高速发展的时代，众多的软件被开发出来，给用户带来了很大的选择余地，而且人们越来越追求更个性的需求。在这种时代背景下，人们对企业员工信息管理系统越来越重视，更好的实现企业员工信息管理系统的有效发挥，本文将通过企业员工信息管理系统的信息，分析在日常生活中对企业员工信息管理系统信息存在哪些问题探讨出进一步提升工作效率，管理能力的对策。
系统采用了jsp技术，将所有模块采用以浏览器交互的模式，选择MySQL作为系统的数据库，开发工具选择Myeclipse来进行系统的设计。基本实现了企业员工信息管理系统应有的主要功能模块，本系统有管理员、员工与部门经理，管理员：个人中心、员工管理、部门经理管理、部门信息管理、员工考勤管理、签到管理、请假申请管理、工资查询管理、部门类型管理，部门经理；个人中心、员工管理、部门信息管理、员工考勤管理、签到管理、请假申请管理、工资查询管理，员工；个人中心、部门信息管理、员工考勤管理、签到管理、请假申请管理、工资查询管理等功能。
对系统进行测试后，改善了程序逻辑和代码。同时确保系统中所有的程序都能正常运行，所有的功能都能操作，本系统的开发获取企业员工信息管理系统信息能够更加方便快捷，同时也使企业员工信息管理系统信息变的更加系统化、有序化。系统界面较友好，易于操作。
程序上交给用户进行使用时，需要提供程序的操作流程图，这样便于用户容易理解程序的具体工作步骤，现如今程序的操作流程都有一个大致的标准，即先通过登录页面提交登录数据，通过程序验证正确之后，用户才能在程序功能操作区页面操作对应的功能。
​ 程序操作流程图
功能截图： 5.1 管理员登录 管理员输入个人的用户名、密码登录系统，这时候系统的数据库就会在进行查找相关的信息，如果我们输入的用户名、密码不正确，数据库就会提示出错误的信息提示，同时会提示管理员重新输入自己的用户名、密码，直到账号密码输入成功后，会提登录成功的信息。网站管理员登录效果图如图5-1所示：
图5-1管理员登录界面
5.2 管理员功能模块 5.2.1部门类型管理 管理员对部门类型管理进行获取类型等信息进行删除、修改等操作。程序成效图如下图5-2所示:
图5-2部门类型管理界面图
5.2.2员工管理 管理员对员工管理进行获取员工工号、姓名、部门、性别、手机、邮箱、身份证、照片进行删除、修改以及查看等操作。程序效果图如下图5-3所示：
图5-3员工管理界面
5.2.3部门经理管理 管理员对部门经理管理进行获取经理工号、经理姓名、性别、部门名称、职务、邮箱、联系电话、身份证、照片、是否审核、审核回复等信息查看、修改以及删除等操作。程序效果图如下图5-4所示：
图5-4部门经理管理界面
5.2.4工资查询管理 管理员可以对工资查询管理进行获取员工工号、姓名、部门、工资月份、基本工资、绩效工资、加班工资、全勤、迟到早退、请假、个税、社保代缴、实发工资、登记时间、是否审核、审核回复等信息进行修改、删除等操作。程序效果图如下图5-5所示：
图5-5工资查询管理界面
5.2.5部门信息管理 管理员可以对部门信息管理进行获取经理工号、部门名称、经理姓名、联系电话、办公区域、办公人数等信息进行查看、修改、删除等操作。程序效果图如下图5-6所示：
图5-6部门信息管理界面
5.3员工功能模块 员工进入企业员工信息管理系统可以对个人中心、部门信息管理、员工考勤管理、签到管理、请假申请管理、工资查询管理进行查看等操作。程序成效图如下图5-7所示:
图5-7员工功能界面图
5.3.1个人信息 在个人信息页面可以查看员工工号、姓名、部门、性别、手机、邮箱、身份证、照片等内容，并进行修改等操作。程序效果图如下图5-8所示：
图5-8个人信息界面图
5.3.2工资查询管理 在工资查询管理页面可以查看员工工号、姓名、部门、工资月份、基本工资、绩效工资、加班工资、全勤、迟到早退、请假、个税、社保代缴、实发工资、登记时间、是否审核、审核回复等内容，并进行修改等操作。程序效果图如下图5-9所示：
图5-9工资查询管理界面图
5.4 部门经理功能模块 部门经理进入企业员工信息管理系统可以对个人中心、员工管理、部门信息管理、员工考勤管理、签到管理、请假申请管理、工资查询管理进行查看等操作。程序成效图如下图5-10所示:
图5-10部门经理功能界面图
5.4.1员工管理 在员工管理页面可以查看员工工号、姓名、部门、性别、手机、邮箱、身份证、照片等内容，并进行修改，删除或查看等操作。程序效果图如下图5-11所示：
图5-11员工管理界面图
5.4.2部门信息管理 在部门信息管理页面可以查看经理工号、部门名称、经理姓名、联系电话、办公区域、办公人数等内容，并进行修改，删除或查看等操作。程序效果图如下图5-12所示：
图5-12部门信息管理界面图
5.4.3工资查询管理 在工资查询管理页面可以查看员工工号、姓名、部门、工资月份、基本工资、绩效工资、加班工资、全勤、迟到早退、请假、个税、社保代缴、实发工资、登记时间、是否审核、审核回复等内容，并进行修改，删除或查看等操作。程序效果图如下图5-13所示：
图5-13工资查询管理界面图
代码实现： /** * 登录相关 */ @RequestMapping("users") @RestController public class UserController{ @Autowired private UserService userService; @Autowired private TokenService tokenService; /** * 登录 */ @IgnoreAuth @PostMapping(value = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4086526988393a8b06e0c7a1b12ceeb3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cf96e41b811fd687fc8b3e5da966b32/" rel="bookmark">
			一款超强大的自带 AI 智能辅助在线画图工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公众号关注 「奇妙的 Linux 世界」
设为「星标」，每天带你玩转 Linux ！
今天推荐的这个项目是「pddon-win」，一款开源的在线画图工具，提供低代码和 AI 智能辅助工具。
怕画不好图就用 PDDON，可用于绘制流程图、架构图、思维导图、UML、BPMN、网络拓扑图、ER图、数据库模型图、韦恩图、鱼骨图等，提供了丰富的定制化绘图功能组件库，更贴心易用的设计体验。
同时，非常贴心的为程序员用户提供了对象建模、数据库建模、代码生成等支持，而且支持一键修改整体样式、一键美化绘图、编辑、排版、多设计图协同编辑能力，类似 Excel 的简易操作方式。
支持 latex 语法输入数学公式、支持绘制手绘/草图风格绘图。预置了非常丰富的连线样式和组件供选择使用，连线、组件样式可以通过工具栏或者属性面板灵活调整，提供了自定义连线/组件 DIY，支持使用和搜索网络组件、上传图片组件、预置了 cisco、aws、阿里云、bpmn、uml 相关组件库。
AI 相关绘图：
架构图：
流程图：
UML 图：
类图：
在线画图地址：https://pddon.com
开源项目地址：https://github.com/pddon/pddon-win
开源项目组织：pddon
本文转载自：「GitHub黑板」，原文：https://url.hi-linux.com/NrkPa，版权归原作者所有。欢迎投稿，投稿邮箱: editor@hi-linux.com。
最近，我们建立了一个技术交流微信群。目前群里已加入了不少行业内的大神，有兴趣的同学可以加入和我们一起交流技术，在 「奇妙的 Linux 世界」 公众号直接回复 「加群」 邀请你入群。
你可能还喜欢
点击下方图片即可阅读
Github 星标 10.5K，这款专为程序员打造的笔记平台太赞了
点击上方图片，『美团|饿了么』外卖红包天天免费领
更多有趣的互联网新鲜事，关注「奇妙的互联网」视频号全了解！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a10d796eda2ab10960d08160dd1eff61/" rel="bookmark">
			【软件测试】学习笔记-设计GUI自动化测试策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章从“实战”这个角度展开，探讨实际的大型全球化电商网站的GUI自动化测试如何开展。这场实战，从以下两个方面展开：
测试策略如何设计？这一点，我会根据亲身经历的实际项目，和你探讨GUI测试的分层测试策略。测试用例脚本如何组织？需要注意的是，对于这个问题，我不是要和你讨论测试用例的管理，而是要讨论测试用脚本的管理。比如，当需要组装上层的端到端（E2E）测试时，如何才能最大程度地重用已有的页面对象以及业务流程（business flow）。 如果你所在的企业或者项目正在大规模开展GUI测试，并且准备使用页面对象模型以及业务流程封装等最佳实践的话，那么，很可能会遇到本文所描述的问题并且迫切需要相应的解决办法。
大型全球化电商网站的前端模块划分 在正式讨论大型全球化电商网站的GUI自动化测试策略设计之前，先简单介绍一下电商网站的前端架构，为避免过多的技术细节引起不必要的干扰，我只会概要性地介绍与GUI自动化测试密切相关的部分。
由于大型全球化电商网站的业务极其庞大，所以前端架构也要按照不同的业务模块来划分，比如用户管理模块、商户订单管理模块、商户商品管理模块等等。
当然由于这些前端模块都会使用项目自己封装的组件库，比如自定义开发的列表组件、登录组件、信用卡组件等，我们通常会把自定义开发的这些所有组件都放在一个“公共组件库”中，为前端模块提供依赖。
所以，从代码库（Repository）的角度来看，各个前端模块都有各自独立的代码库，除此之外还会有一个公共组件的代码库。
大型全球化电商网站的GUI自动化测试策略设计 了解了大型全球化电商网站前端模块的划分后，我们再来看看它的GUI自动化测试策略是如何设计的。
总体来看，对大型网站来讲，GUI自动化测试往往应该做得比较轻量级，而不应该把大量的功能测试，以及功能的组合测试放在GUI自动化测试中，GUI测试通常只覆盖最核心且直接影响主营业务流程的E2E场景。
但同时，GUI的验证一定不是在系统全部完成后才真正开展的，也应该是分阶段、分层次来设计制定测试策略的，那么接下来我也将会按照自底向上的顺序分层次介绍GUI自动化的测试策略。
首先，要从前端组件的级别来保证质量，也就是需要对那些自定义开发的组件进行完整全面的测试。
公共组件库会被很多上层的前端模块依赖，它的质量将直接影响这些上层模块的质量，所以我们往往会对这些公共组件进行严格的单元测试。最常用的方案是：基于Jest开展单元测试，并考量JavaScript的代码覆盖率指标。
Jest是由Facebook发布的，是一个基于Jasmine的开源JavaScript单元测试框架，是目前主流的JavaScript单元测试方案。
完成单元测试后，往往还会基于被测控件构建专用的测试页面，在页面层面再次验证控件相关的功能和状态。这部分测试工作也需要采用自动化的形式实现，具体的做法是：
先构建一个空页面，并加入被测控件，由此可以构建出一个包含被测控件的测试页面，这个页面往往被称为Dummy Page；从黑盒的角度出发，在这个测试页面上通过手工和自动化的方式操作被测控件，并验证其功能的正确性。 对于自动化的部分，需要基于GUI自动化测试框架开发对应的测试用例。这些测试用例，往往采用和GUI E2E一样的测试框架，也是从黑盒的角度来对被测控件做功能验证。
其次，每一个前端模块，都会构建自己的页面对象库，并且在此基础上封装开发自己的业务流程脚本。这些业务流程的脚本，可以组装成每个前端模块的测试用例。
以用户管理模块为例，测试用例的组装过程如下：
首先，把用户管理模块中涉及到的所有页面，比如登录页面、用户注册页面等，按照页面对象模型的要求写成Page类；然后，利用这些Page类封装业务流程脚本，比如用户登录流程，用户注册流程等；最后，在GUI测试用例脚本中，调用封装好的业务流程脚本构成该模块的GUI测试用例。 在这个阶段，测试用例需要完整覆盖该模块的所有业务逻辑以及相关的功能测试点，但是并不会实现所有测试用例的自动化。
自动化测试用例的原则，通常是：优先选取业务关键路径以及Happy Path作为自动化测试的范围。在资源充裕的情况下，我们希望这个阶段的自动化率可以达到70%-80%。 所以，前端模块的质量保证主要依赖这部分测试。
“GUI的自动化测试往往只覆盖最核心且直接影响主营业务流程的E2E场景“，并且”GUI测试遵循“手工测试为主，自动化为辅”的策略，而这里又建议说理想的自动化率应该达到70%~80%，是不是有点前后矛盾的感觉。
其实，这是两个层面的测试，这里70%-80%的GUI自动化覆盖率是针对模块级别的要求；而“自动化测试为辅，手工为主，以及只覆盖核心业务场景”针对的是系统级别的E2E测试。这里容易引起混淆的点是模块测试和系统级别E2E测试都是属于GUI自动化测试的范畴。
最后，组合各个前端模块，并站在终端用户的视角，以黑盒的方式使用网站的端到端（E2E）测试。 这部分的测试主要分为两大部分：
一部分是，通过探索式测试的方法手工执行测试，目标是尽可能多地发现新问题；另一部分是，通过GUI自动化测试执行基本业务功能的回归测试，保证网站核心业务相关的所有功能的正确性。 虽然这部分端到端GUI测试用例的绝对数量不多，往往是几百个的规模，但是对于保证最终网站的质量却起着非常关键的作用。
可以这样说，如果这些端到端的GUI自动化测试用例100%通过，那么上线后基本业务功能的质量就不会有大问题。所以，这部分测试工作的重要性不言而喻。
那么，接下来的问题是，应该由谁来开发这部分端到端的GUI自动化测试用例呢？
每个前端模块都会有对应的Scrum团队，他们会负责开发该模块的页面对象模型、业务流程脚本以及测试用例。而端到端的GUI自动化测试不隶属于任何一个Scrum团队。
这种情况下，最好的做法就是：成立一个专门的测试团队，负责这种系统级别的GUI测试。这样的团队，往往被称为E2E测试团队。
很显然，如果由E2E团队从无到有地开发这部分GUI自动化测试的脚本，效率低下。而且，这部分测试会涉及很多前端模块，当各个前端模块的需求、业务流程以及页面实现有任何变动时，E2E团队都很难做到及时更新。
所以，解决这个问题的最佳实践就是：E2E团队应该尽可能地利用各个模块已有的页面对象和业务流程脚本，组装端到端的GUI测试。
这样一方面最大程度地减少了重复工作，另一方面可以把各个模块的变更及时反映到端到端的GUI测试中，因为端到端的GUI测试用例是直接调用各个模块的页面对象和业务流程脚本，而这些页面对象和业务流程脚本都是由每个模块自己的Scrum团队维护的。
而为了能够在端到端的GUI自动化测试中，复用各个模块的页面对象和业务流程脚本，我们就必须考虑的问题，也就是我今天要和你探讨的第二个话题：GUI自动化测试脚本应该如何组织？
大型全球化电商网站的GUI自动化测试脚本管理 原有的方案，不能解决端到端的GUI自动化测试复用各个模块的页面对象和业务流程脚本的问题，在不断的实践中，我总结了一个如图1所示的脚本组织结构来解决这个问题。
图1 大型全球化电商网站的GUI自动化测试脚本管理
也就是说，将各个模块的页面对象和业务流程脚本放在各自的代码库中，并引入页面对象和业务流程脚本的版本管理机制，通常采用页面对象和业务流程脚本的版本号和开发版本号保持一致的方案。
比如模块A的版本号是V1.0.0，那么对应的页面对象库和业务流程脚本的版本号也应该是V1.0.0。
在端到端的GUI自动化测试脚本中，引用各个模块正确的页面对象和业务流程脚本的版本号，测试用例代码就可以直接调用模块的页面对象和业务流程脚本了。
具体在测试项目中，模块版本的依赖往往是用POM来配置的，如图2展示了一个典型测试项目的POM文件中的版本依赖关系，其中引用了两个模块，appcommon模块对应的就是上文提到的“公共组件库”，而app.buy对应的就是具体依赖的前端模块。
由于这只是一个示例，所以我只保留了两个依赖模块，实际的端到端GUI测试项目往往会包含大量的模块依赖。
图2 典型测试项目的POM文件中的版本依赖关系
在这种管理机制下，E2E团队不需要重复开发任何的页面对象和业务流程脚本，而且可以始终保证与各个模块的最新实现同步，同时端到端的GUI测试用例脚本也会比较稳定，不会因为各个模块的改动而频繁地修改。
这样一来，E2E团队就会有更多的时间和精力去设计并执行探索式测试，发现更多的潜在缺陷，形成良性循环。
总结 本文从实战的角度，介绍了大型全球化电商网站GUI测试的策略设计以及测试脚本管理的问题：
首先，要从前端组件的级别来保证质量，也就是需要对那些自定义开发的组件进行完整全面的测试。通常前端组件会基于Jest做比较严格的单元测试。
其次，每一个前端模块，都会构建自己的页面对象库，并且在此基础上封装开发自己的业务流程脚本。这些业务流程的脚本，可以组装成每个前端模块的测试用例。
最后，把各个前端模块组合在一起之后，站在终端用户的视角以黑盒的方式使用网站的端到端的测试。端到端的测试应该尽可能多地重用各个模块的页面对象库和业务流程脚本来完成。
而为了能够在端到端的GUI自动化测试中，复用各个模块的页面对象和业务流程脚本，我建议的方案是：对各个前端业务模块的页面对象库和业务流程脚本，实施版本化管理机制。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/108d6332989face8649bdb2f5a8db25f/" rel="bookmark">
			JavaWeb- Tomcat
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概念 老规矩，先看维基百科：Apache Tomcat (called "Tomcat" for short) is a free and open-source implementation of the Jakarta Servlet, Jakarta Expression Language, and WebSocket technologies.[2] It provides a "pure Java" HTTP web server environment in which Java code can also run. Thus it is a Java web application server, although not a full JEE application server. 有用的似乎就最后一句话，Tomcat是一个Java Web应用服务器，这也是读者们经常读到的答案。但是什么又是Web服务器呢？
所谓Web服务器，就是提供Web服务的服务器。试想这样一个过程：：用户在客户端发出请求至Web服务器，Web服务器对其做出响应，返回相应的数据至客户端，即一次HTTP请求-响应（详见HTTP介绍）。有的读者可能会疑惑，Web服务器与我平时写的代码之间有什么关联呢？程序员编写的代码通常是Web应用，Web应用需要置于Web服务器之内，才能一起给用户提供Web服务。因此Web服务器也称为Web容器。
看如下简图：
那么Web服务器到底完成了什么工作呢？在上一篇介绍HTTP的文章中谈到，客户端与服务端之间在请求-响应的过程中，对于HTTP协议的操作是通用的，而这部分通用的处理即是Web服务器完成的，这使得开发者可以更关注Web应用中的业务逻辑。至此，是否对Tomcat有了初步的理解呢？
二、再理解 我们也经常听到这样的描述：Tomcat是一个开源、免费、轻量级的Web服务器，在本文的第一段中提到"not a full JEE application server"，这又如何理解呢？JEE是Java Enterprise Edition，通常指Java企业级开发的技术规范总各，包含13项技术规范。由于Tomcat未完全支持全部的规范，因此会称之"not full"，同样，这也是它轻量的原因。而像其它的Web服务器如WebLogic则支持全部的规范，因此也比Tomcat更重。（了解即可）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/108d6332989face8649bdb2f5a8db25f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee15acb1774c684e2cf940eac62e549e/" rel="bookmark">
			一文总结Java\JDK 17发布的新特性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介： JDK 17已经于2021年3月16日如期发布。本文介绍JDK 17新特性。JDK 17于2021年9月14日正式发布（General-Availability Release）。JDK 17将是大多数供应商的长期支持（LMS）版本。上一个LTS版本是JDK 11。 本文总结了JDK 17发布的新特性。
发布版本说明 根据发布的规划，这次发布的 JDK 17 将是一个长期支持版（LTS 版）。LTS 版每 3 年发布一个，上一次长期支持版是 18 年 9 月发布的 JDK 11。
JDK 17是Java SE平台版本17的开源参考实现，由JSR 392在JCP（Java Community Process）指定。
安装包下载 主要分为OpenJDK版本和Oracle版本，下载地址如下：
OpenJDK版本：JDK 16.0.2 GA ReleaseOracle版本：Java Downloads | Oracle 上述版本，如果是个人学习用途，则差异不大。但如果是用于商业用途，则需要仔细看好相关的授权。Oracle JDK根据二进制代码许可协议获得许可，而OpenJDK根据GPL v2许可获得许可。
更多有关Java的基本知识，可以参阅《Java核心编程》这本书，描述的非常详细。
JDK 17 新特性说明 JEP 406：switch的模式匹配（预览）(JDK-8213076) specification
通过switch表达式和语句的模式匹配，以及模式语言的扩展，增强Java编程语言。将模式匹配扩展到switch允许对表达式进行测试，每个模式都有特定的操作，以便可以简洁而安全地表达复杂的面向数据的查询。
有关更多详细信息，请参见JEP 406
JEP 409：密封类(JDK-8260514) specification
密封类（Sealed Class）已添加到Java语言中。密封类和接口限制了哪些其他类或接口可以扩展或实现它们。
密封类由JEP 360并在JDK 15中作为预览功能交付。它们再次被提出，并进行了改进，由JEP 397并在JDK 16中作为预览功能提供。现在，在JDK 17中，密封类正在最终确定，与JDK 16没有任何更改。
有关更多详细信息，请参见JEP 409
JEP 382：新的macOS渲染管道(JDK-8238361) client-libs/2d
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee15acb1774c684e2cf940eac62e549e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15215ee0c82e257982218127af5e0a17/" rel="bookmark">
			Java：爬虫htmlunit实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前我们已经讲过使用htmlunit及基础，没有看过的可以参考Java：爬虫htmlunit-CSDN博客
我们今天就来实际操作一下，爬取指定网站的数据
1、首先我们要爬取一个网站数据的时候我们需要对其数据获取方式我们要进行分析，我们今天就拿双色球历史开奖查询-双色球历史开奖结果-彩经网作为我们示例目标，使用google浏览器，示例仅供学习使用
​
历史数据比较多，所以存在分页的情况，请打开f12调出开发者模式
​
在使用网站过程中我们点击下一页的时候发现，请求接口已经做了路由跳转，在右侧请求地址中未发现数据接口，在上方发现地址变化了，为什么会这样呢？这个其实涉及到了搜索引擎收录的问题这个在后续我们会具体讲解；我们现在可以继续尝试点击下一页，地址都会变化所以我们直接根据地址来进行爬数据操作就可以了，地址确定之后我们就需要对页面数据进行分析
​
实际我们只要获取列表数据即可，第一行数据是头所不需要获取，即获取第二个 //tbody[@id='kjnum']//tr ，代码如下 &gt;&gt;&gt; @Slf4j public class BaseTest { public static void main(String[] args) throws Exception { HtmlPage page = SpiderUtils.crawlPageWithoutAnalyseJs("https://www.cjcp.cn/kaijiang/ssqmingxi_154.html"); //System.err.println(page); List&lt;HtmlTableRow&gt; htmlTableRowList = page.getByXPath("//tbody[@id='kjnum']//tr"); htmlTableRowList.forEach(f -&gt; { log.info("********************"); List&lt;HtmlTableCell&gt; htmlTableCellList = f.getCells(); log.info("开奖期数 &gt;&gt; " + htmlTableCellList.get(0).getTextContent()); log.info("开奖时间 &gt;&gt; " + htmlTableCellList.get(1).getTextContent()); log.info("双色球开奖结果 &gt;&gt; " + htmlTableCellList.get(2).getTextContent()); log.info("总销售额 &gt;&gt; " + htmlTableCellList.get(3).getTextContent()); log.info("奖池 &gt;&gt; " + htmlTableCellList.get(4).getTextContent()); log.info("一等奖 &gt;&gt; 注数 &gt;&gt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15215ee0c82e257982218127af5e0a17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e82c9a19d27c43efd1297ac2c451a99/" rel="bookmark">
			python json模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		json是JavaScript对象表示法的缩写，是一种轻量级的数据交换格式，经常被用于Web应用程序中。python中的json库是用于解析和生成json数据格式的库。
import json data = { "name": "张三", "age": 18, "hobbies": ["reading", "music"], "info": { "address": "北京市朝阳区", "phone": "18888888888" } } #json.dumps()是用于将python对象序列化为json编码字符串 #ensure_ascii保证每个字符都是ASCII字符 # indent 用于控制缩进的参数 json_str = json.dumps(data, ensure_ascii=False, indent=1) print(json_str) # json.loads() 用于将json字符串解码为python对象 data=json.loads(json_str) print(type(data)) print(data) import json # 将json数据写入到文件中 data = { "name": "王五", "age": 30, "hobbies": ["travelling", "photography"], "info": { "address": "广州市天河区", "phone": "13666666666" } } with open('data.json', 'w') as f: json.dump(data, f, ensure_ascii=False, indent=4) # 从文件中读取json数据 with open('data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e82c9a19d27c43efd1297ac2c451a99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e5bce4e134f13309c52747de85a8229/" rel="bookmark">
			【现代通信原理笔记】6 信源编码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【现代通信原理】6 信源编码 目录 【现代通信原理】6 信源编码6.2 模拟信号的抽样6.2.1 低通模拟信号的抽样定理抽样重建 6.2.2 带通模拟信号的抽样定理 6.3 模拟脉冲调制PAM、PDM、PPM、实际抽样𝟙 —— 自然抽样的 PAM实际抽样𝟚 —— 平顶抽样的 PAM 6.4 模拟信号的量化6.4.1 量化原理6.4.2 均匀量化6.4.3 非均匀量化压缩率 A 、 μ \mu μ 6.5 PCM 脉冲编码调制6.5.1 PCM的基本原理6.5.2 常用二进制码 6.6 DPCM 差分脉冲编码调制差分脉冲编码调制 DPCM自适应差分脉码调制 ADPCM 6.7 增量调制(ΔM &amp; DM)参考作业 重点
模拟信号数字化 三个步骤
抽样 量化 编码 信源编码的作用
压缩编码模数转换 模拟信号数字化传输的三个环节
A/D数字方式传输D/A A/D转换（数字化编码）的技术
波形编码参量编码 参量编码又称为声源编码，是将信源信号在频率域或其它正交变换域提取特征参量，并将其变换成数字代码进行传输。 波形编码的三个步骤
抽样量化编码 脉冲调制
脉冲模拟调制
脉幅调制 PAM脉宽调制 PDM脉位调制 PPM 脉冲数字调制
脉码调制 PCM增量调制 DM 波形编码的常用方法
PCMDPCM∆M 6.2 模拟信号的抽样 抽样定理——模拟信号数字化和时分多路复用的理论基础
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e5bce4e134f13309c52747de85a8229/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b3969017ca7e96732d9c9af5b109c23/" rel="bookmark">
			git正确进行merge
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		➜ sohuvideo_harmony_demo git:(developer_local1) git merge developer_local2 Auto-merging entry/src/main/ets/pages/lzy/ComponentLearnPage.ets CONFLICT (content): Merge conflict in entry/src/main/ets/pages/lzy/ComponentLearnPage.ets Automatic merge failed; fix conflicts and then commit the result. ➜ sohuvideo_harmony_demo git:(developer_local1) ✗ git status On branch developer_local1 You have unmerged paths. (fix conflicts and run "git commit") // 这个意思是冲突解决后，用commit命令提交 (use "git merge --abort" to abort the merge) // merge会把有冲突的文件列出来 Unmerged paths: (use "git add &lt;file&gt;..." to mark resolution) // 这个意思是，冲突文件解决后，用add把冲突的文件标记为已解决状态 both modified: entry/src/main/ets/pages/lzy/ComponentLearnPage.ets no changes added to commit (use "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b3969017ca7e96732d9c9af5b109c23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b878408c0dd9330a6628fc11a0307c82/" rel="bookmark">
			Linux C/C&#43;&#43; 显示NIC流量统计信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NIC流量统计信息是由操作系统维护的。当数据包通过NIC传输时，操作系统会更新相关的计数器。这些计数器记录了数据包的发送和接收数量、字节数等。通过读取这些计数器，我们可以获得关于网络流量的信息。
为什么需要这些信息? 可以使用这些信息来监控网络性能、诊断网络问题或确定网络流量的模式。例如，如果发现某个时间段的数据包接收数量异常高，可能意味着有DDoS攻击或网络拥塞问题。
如何使用Linux命令获取流量统计信息
要显示网络接口(NIC)的流量统计信息，可以使用一些命令行工具。最常用的工具是ifconfig和ip命令。
使用ifconfig命令，可以通过指定网络接口名称来查看相关信息。例如，使用以下命令可以显示eth0接口的流量统计信息：
ifconfig eth0 使用ip命令的方式与ifconfig类似，可以显示网络接口的详细信息。例如，可以使用以下命令显示eth0接口的流量统计信息：
ip -s link show eth0 另外，你也可以使用一些其他工具来进行更详细的统计和分析，如ntop、iptraf、iftop、sar等。这些工具提供了更多的选项和图形化界面，可以更方便地查看和分析流量统计信息。
想要了解更多的解析，可以参考Linux的网络管理文档，如Linux网络管理指南或相关的官方文档。在命令行中输入以下命令可以查看相关文档：
man ifconfig man ip 这里需要注意的是，具体的命令和工具可能会有一些不同的参数和输出格式。在使用具体的命令行工具时，可以参考工具的文档和帮助信息来了解详细的使用方法和输出解释。
/proc/net/dev
在Linux中，/proc/net/dev是一个特殊的文件，它包含了有关网络设备（如网卡）的统计信息。该文件是通过proc文件系统提供的一种方式来访问内核数据结构。
具体来说，/proc/net/dev文件提供了每个网络接口的详细统计信息，包括接收和发送的字节数、数据包数、错误计数等。这些信息对于网络的性能分析和故障排除非常有用。
通过读取/proc/net/dev文件，可以获取有关系统中每个网络接口的实时信息。此外，还可以使用一些工具（如ifconfig命令、ip命令等）来显示/proc/net/dev文件的内容以更直观地查看接口的统计信息。
所以，如果想要了解Linux系统中的网络统计信息，可以通过查看/proc/net/dev文件来获取相关的数据。
Linux C/C++ 显示NIC流量统计信息
... void AddCount(int devnum, u32 rp1, u32 rb1, u32 tp1, u32 tb1) { if (devnum &gt;= MAXDEV) return; if (lrp[devnum] &lt; rp1) rp[devnum] = rp1 - lrp[devnum], lrp[devnum] = rp1; else lrp[devnum] = rp1, rp[devnum] = 0; if (lrb[devnum] &lt; rb1) rb[devnum] = rb1 - lrb[devnum], lrb[devnum] = rb1; else lrb[devnum] = rb1, rb[devnum] = 0; if (ltp[devnum] &lt; tp1) tp[devnum] = tp1 - ltp[devnum], ltp[devnum] = tp1; else ltp[devnum] = tp1, tp[devnum] = 0; .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b878408c0dd9330a6628fc11a0307c82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/736b4372d596a46646919268e4aa0deb/" rel="bookmark">
			【SpringCloud】@Validated @Valid 不起作用 2.3.0及以上版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		依赖 &lt;!--valid--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt; &lt;/dependency&gt; 检查 版本问题，解决成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62dbd7c2e00a1add795e54f9c9d4ee75/" rel="bookmark">
			docker网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 简介能干嘛网络模式bridgehostnonecontainer 简介 docker不启动，默认网络情况:
ens33 lo virbr0 在CentOS7的安装过程中如果有选择相关虚拟化的的服务安装系统后，启动网卡时会发现有一个以网桥连接的私网地址的virbr0网卡(virbr0网卡：它还有一个固定的默认IP地址192.168.122.1)，是做虚拟机网桥的使用的，其作用是为连接其上的虚机网卡提供 NAT访问外网的功能。
将libvirtd服务卸载
yum remove libvirt-libs.x86_64 docker启动后，网络情况
会产生一个名为docker0的虚拟网桥
默认创建3大网络模式
All命令
Commands: connect Connect a container to a network create Create a network disconnect Disconnect a container from a network inspect Display detailed information on one or more networks ls List networks prune Remove all unused networks rm Remove one or more networks 查看网络
docker network ls 查看网络源数据
docker network inspect XXX 网络名字 删除网络
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62dbd7c2e00a1add795e54f9c9d4ee75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5aa31b77185fdc1e4ca62173bb390f6d/" rel="bookmark">
			Springboot整合Mybatis的一般步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.初始化Springboot项目，设置好端口号并引入数据库依赖、做好数据库配置。 2.在项目的pom.xml文件中引入Mybatis依赖，如下所示： &lt;!--mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt; &lt;/dependency&gt; 3.在application.yml配置文件中粘贴以下代码： mybatis: mapper-locations: classpath:mapper/*.xml 4.在项目启动类Application上加入全Mapper扫描注解，如下图所示： @MapperScan("com.example.dao")//此处的com.example.dao为所有Mapper接口所存在的文件夹 public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } 5.开始创建Controller、Service、Impl、Mapper接口及Mapper.xml文件并通过SQL语句与数据库进行数据互动，简易的Mapper.xml文件如下： &lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="这里写xml文件相对应的mapper文件的地址"&gt; &lt;/mapper&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43f64b6e207d43fa69536c41c3d5126a/" rel="bookmark">
			Jmeter&#43;ant&#43;jenkins轻量级接口自动化测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		杀猪不用牛刀，工具没有牛逼高大尚之分，每个工具都有存在的理由；关键是看会不会用，怎么用，有没有用在合适的地方。需要安装的工具：
jdk1.8 jmeter3.2 ant1.9（蚂蚁） jenkins2.1（詹金斯）
· Jdk安装包安装自己下载对应的Java版本
· 设置环境变量
· 系统变量→新建 JAVA_HOME 变量 。
变量值填写jdk的安装目录（本人是 E:\Java\jdk1.7.0)
系统变量→寻找 Path 变量→编辑
在变量值最后输入%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;
（注意原来Path的变量值末尾有没有;号，如果没有，先输入；号再输入上面的代码）
系统变量→新建 CLASSPATH 变量
变量值填写 .;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar（注意最前面有一点）
系统变量配置完毕
检验是否配置成功 运行cmd 输入 java -version （java 和 -version 之间有空格）.
若如图所示 显示版本信息 则说明安装和配置成功。
· 验证是否安装正确
2、Jmeter
· jmeter直接下载解压，然后配置环境变量就可以了
接下来就是配置Jmeter环境变量
在系统变量中添加俩个属性
① JMETER_HOME=D:\apache-jmetes\apache-jmeter-4.0 (就是jmeter保存的路径)
② CLASSPATH=%JMETER_HOME%\lib\ext\ApacheJMeter_core.jar;%JMETER_HOME%\lib\jorphan.jar;
(这个复制上去就ok) CLASSPATH变量如果存在就直接在后面加变量，如果没有就新建一个，注意每个变量 ; 隔开
( 3 ) 在用系统变量path后面加上 ;%JMETER_HOME%\bin 注意是系统变量
3、Ant
· Ant下载解压，配置环境变量，一样的操作。
cmd命令中输入 ant
cmd命令中输入 ant-version 查看ant版本
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43f64b6e207d43fa69536c41c3d5126a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65a2e5c0e23d2144bf9dbe102d74b330/" rel="bookmark">
			C语言练习——三子棋
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 相信大家小时候都有听说过或者玩过三子棋，你是否还记得那时玩三子棋的快乐呢今天我们就来用C语言写一个简易的三子棋，让你回忆起儿时的快乐吧 1. 游戏规则 玩家和电脑轮流下棋子，若有一方下的棋子先连成一个棋子总数为3的直线，则获胜若所有的位置都下完了，还没有分出胜负的话，即为平局 2. 游戏实现 2.1 初始界面 首先我们可以先写一个游戏的界面 那像这样的界面怎么编写呢，首先可以先定义一个打印菜单的函数注：为了让代码的结构更加清晰，我们一般会在VS上分别创建 test.c 、game,c和game.h 头文件来编写代码test.c 为主函数的编写和测试game.c 为自定义函数的编写game.h 头文件为函数的申明以下的代码我会在第一行注释应该写在哪个文件里 void menu()//game.c文件 { printf("********************\n"); printf("*****1.开始游戏*****\n"); printf("*****0.结束游戏*****\n"); printf("********************\n"); } 直接利用 printf 函数打印即可接着就是接受输入的 0或1 ，然后编写对应的执行逻辑这里我们用一个 game 函数来实现游戏的功能 int main()//test.c文件 { int input = 0; srand((unsigned int)time(NULL));//生成随机数种子 do { printf("\n"); menu(); printf("请输入1或0\n--&gt;"); scanf("%d", &amp;input); switch (input) { case 1: { game();//开始游戏 break; } case 0: { printf("游戏结束\n"); break; } default: { printf("输入错误，请重新输入\n"); } } } while (input !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65a2e5c0e23d2144bf9dbe102d74b330/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e5cc51ff2081bd02eb5bc7fd615fbef/" rel="bookmark">
			Redis：原理速成&#43;项目实战——Redis实战9（秒杀优化）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		👨‍🎓作者简介：一位大四、研0学生，正在努力准备大四暑假的实习
🌌上期文章：Redis：原理速成+项目实战——Redis实战8（基于Redis的分布式锁及优化）
📚订阅专栏：Redis：原理速成+项目实战
希望文章对你们有所帮助
简单回顾一下之前实现秒杀的思路，其实无非就是2点：
1、库存够不够，该用户有没有买过
2、操作数据库（扣库存、创建订单）
之前的业务由于涉及了大量数据库的操作，所以性能并不是太好。
秒杀优化 异步秒杀思路Redis实现秒杀资格的判断分析实现 基于阻塞队列实现秒杀异步下单总结及发现问题 异步秒杀思路 之前的业务，可以用下图来表示：
可以发现，Tomcat中顺序执行的操作里面有4个需要对数据库进行查询或修改操作，而MySQL本身的并发能力就是很差的，时间是所有时间之和，这种解决方式并不好。
因此，我们需要将操作数据库的步骤分给多个线程来做，而库存量判断、是否具有购买资格的判断，我们也可以将其交给Redis，从而提高效率。
既然是将步骤分给多个线程来做，我们要开辟线程，并且要使得开辟的线程能够正确执行业务：
整个业务的流程被分开了，所需要的时间不再是所有的过程时间之和（完成下单的操作是异步执行的），而且整个业务基于Redis，将会大大提升业务的性能。
但这需要考虑2个难点问题：如何在Redis里面完成判断库存以及一人一单的校验？如何基于阻塞队列实现秒杀异步下单？
Redis实现秒杀资格的判断 分析 要在Redis里面判断库存量以及一人一单，我们肯定需要将优惠券的库存信息以及相关订单信息缓存到Redis中去，我们需要选取合适的数据结构来保存这两个信息。
库存很容易，因为只包含了库存量这个信息，直接使用String类型进行存储即可。
但要实现一人一单，我们要判断这个优惠券被哪些用户购买过。所以这个数据结构需要能够保存多个值，而又因为一人一单，所以我们要保存的用户的id显然是不能重复的。所以，set是很适合的。
因此业务流程可以很容易知道：
可以发现业务的步骤还是有很多步的，因此我们要保证步骤的原子性，因此上述的内容应当用Lua脚本来写。
实现 需求：
1、新增秒杀优惠券的同时，将优惠券的信息保存到Redis中
2、基于Lua脚本，判断秒杀库存、一人一单、决定用户是否抢购成功
3、若成功，将优惠券id与用户id进行封装，再存入阻塞队列
4、开启线程任务，不断从阻塞队列中获取信息，实现异步下单
1、在VoucherServiceImpl类中新增优惠券，同时保存到Redis中：
@Resource private StringRedisTemplate stringRedisTemplate; @Override @Transactional public void addSeckillVoucher(Voucher voucher) { // 保存优惠券 save(voucher); // 保存秒杀信息 SeckillVoucher seckillVoucher = new SeckillVoucher(); seckillVoucher.setVoucherId(voucher.getId()); seckillVoucher.setStock(voucher.getStock()); seckillVoucher.setBeginTime(voucher.getBeginTime()); seckillVoucher.setEndTime(voucher.getEndTime()); seckillVoucherService.save(seckillVoucher); //保存秒杀库存到Redis中, SECKILL_STOCK_KEY = "seckill:stock:" stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString()); } 打开postman，进行测试：
添加成功：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e5cc51ff2081bd02eb5bc7fd615fbef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08e1ec75e9b22afc71d4d45c20976827/" rel="bookmark">
			Spring MVC 的controller方法返回值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		controller方法返回值 返回ModelAndView 说明：controller方法中定义ModelAndView对象并返回，对象中可添加model数据、指定view
返回字符串 逻辑视图名 说明：controller方法返回字符串可以指定逻辑视图名，通过视图解析器解析为物理视图地址。
返回字符串
@Controller @RequestMapping("/account") public class AccountController { @RequestMapping(value = "/findAccount2") public String findAccount2(Model model) { //添加数据 model.addAttribute("msg", "欢迎你 springmvc"); return "success"; } } 在index.jsp里面定义超链接
&lt;a href="/account/findAccount2"&gt;返回字符串&lt;/a&gt; Redirect重定向 说明：
Contrller方法返回结果重定向到一个url地址，如下商品修改提交后重定向到商品查询方法，参数无法带到商品查询方法中。
redirect方式相当于“response.sendRedirect()”，转发后浏览器的地址栏变为转发后的地址，因为转发即执行了一个新的request和response。
由于新发起一个request原来的参数在转发时就不能传递到下一个url，如果要传参数可以/item/queryItem后边加参数，如下：/item/queryItem?...&amp;…..
重定向
@Controller @RequestMapping("/account") public class AccountController { @RequestMapping(value = "/findAccount3") public String findAccount3() { return "redirect:/account/findAccount4"; } ​ @RequestMapping(value = "/findAccount4") public String findAccount4(Model model) { //添加数据 model.addAttribute("msg", "这是springmvc的重定向"); return "success"; } } 在index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08e1ec75e9b22afc71d4d45c20976827/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56463d24d98581db7d90195786d571a6/" rel="bookmark">
			如何轻松拿捏LIO-SAM？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LOAM是目前为止激光里程计(LO)领域最经典最广泛使用的方法，堪称LO领域的baseline，至今仍在KITTI数据集上名列前茅。但是它存在诸多问题，比如：它直接存储全局体素地图而不是局部地图，从而很难执行回环检测以修正漂移；没有很好地使用IMU、GPS等测量融合进行位姿修正；并且体素地图的使用效率会随时间降低。
后续有很多研究者提出了各种改进方法提高LOAM在不同场景下的性能，如FAST-LIO使用EKF整合LiDAR和IMU的测量；LeGO-LOAM引入地面分割和回环检测进一步提高UGV的定位和建图性能；但其中效果较好的当属LIO-SAM，LIO-SAM是一种紧耦合的激光-惯性里程计方法，LIO-SAM可以说是LO的理想框架，其继承了LOAM特征检测和ICP匹配的稳定性，实现了激光雷达-IMU-GPS的多传感器融合，引入了回环检测方法修正全局漂移，利用了多种方法提高了SLAM算法的精度。
但是LIO-SAM中涉及到很多内容和理论的推导，不仅包括LOAM中原有的特征检测、特征匹配、噪声去除等内容，还使用了因子图来组织整个系统，其代码中使用了GTSAM包进行建模；除此之外，由于其紧耦合的设计，还使用了IMU预积分的知识，这部分知识往往是复杂的，对数学公式的的推导要求较高。
虽然网上也有一些LIO-SAM的论文讲解，但大部分都是对论文的简单翻译；虽然也有一些视频教程，但知识体系比较零散，铺天盖地的讲解导致很多初学者不能很好的把握其中的关键；关于其代码的讲解更是寥寥无几，导致很多同学很难理解其代码架构，更别提自己动手书写。
基于此，我们「3D视觉从入门到精通」知识星球特地增加了「如何轻松拿捏LIO-SAM？」系列视频课程，希望通过这门课，大家能对LIO-SAM的理论和代码有一些清晰的认识，自己能够真正地理解其算法思路，并进一步学习到一些阅读其他相关论文或代码的方法。
1.课程讲师
K.Fire，哈尔滨工业大学本科毕业保研至中国科学院大学攻读硕士，主要专注于3D激光SLAM、动态SLAM研究，CSDN资深博主，近4000粉丝量，热衷于知识分享。
2.课程大纲
第一章：绪论
- LOAM系列算法介绍及比较
- LIO-SAM优势及效果展示
第二章：预备知识
- 矩阵基础
- 三维刚体变换
- 李群与李代数
- 非线性优化
- 拓展:卡尔曼滤波
第三章：LOAM论文及原理详解
- LOAM论文带读
- ICP算法原理与发展、SVD分解
- LOAM代码速通、PCA算法
第四章：LeGO-LOAM、LIO-SAM论文及原理讲解
- LeGO-LOAM原理讲解
- LeGO-LOAM代码速通
- LIO-SAM原理讲解
第四章：LIO-SAM代码详解
- 前端-GTSAM、IMU预积分、位姿融合
- 后端-点云配准、建图、回环检测
第五章：实战及总结
- ROS系统简介及代码运行
- 总结、未来工作
本课程自2024年1月28日开课，每周更新一章
3.课程收获及亮点
（1）对LIO-SAM算法的原理及应用有更深刻地理解；
（2）对LOAM系列的传统激光3D SLAM算法的原理及局限有更深入的理解，了解到常见的分析和改进方法；
（3）学习到以初学者的角度，如何高屋建瓴的把握一类算法的学习方法和学习经验，了解作为初学者如何高效吃透一种算法；
（4）掌握代码阅读及实现的方法，更加透彻的掌握代码阅读及实现过程。
4.还能收获什么
1.优质的学习圈子
星球汇集了国内外各个高校的研究生、博士生，包括但不限于清华大学、上海交通大学、华中科技大学、武汉大学、南京大学、北京理工大学、北京航空航天大学；以及国外留学的小伙伴，主要就读于南加州大学、墨尔本大学、慕尼黑工业大学、亚琛工业大学等。除此之外，还有很多一线工作的算法工程师、开发人员，包括但不限于百度、旷视、华为、奥比中光、云从、阿丘科技等。
星球的主要嘉宾
3D视觉从入门到精通知识星球是一个技术社区，在这里你可以讨论任何3D视觉相关的难题、前沿技术。星球邀请了国内外高校博士（北航、慕尼黑工业大学等）、CV独角兽公司CTO/CEO、以及各大厂的算法工程师解惑。在这里，你可以一对一和大佬交流，提出自己在工作学习上的疑问。
合作企业
知识星球现已和众多公司建立了良好的合作关系，公司内的算法负责人会不定期的来内部进行前沿技术/产品分享，除此之外，星球也为公司推荐合格的算法/开发人才。现有合作企业包括但不限于：华为云、腾讯、图漾科技、镭神智能、中科慧眼、INDEMIND、迁移科技、追势科技等~
2.各种SLAM学习文章及代码
星球中不仅包含3D激光SLAM的各种算法及代码讲解，另外涵盖了多模态融合SLAM、视觉SLAM、三维重建、相机标定等多种领域讲解专栏，更有如ORB-SLAM3、Vins-Fusion等各种经典框架的详细讲解视频教程，在星球进行提问可向包括讲师在内的多位领域大牛进行提问，并获得及时解答。
5.课程服务
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af2022be681b739c96e68c421d545495/" rel="bookmark">
			【日常聊聊】程序员必备的面试技巧：如何在面试战场上脱颖而出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🍎个人博客：个人主页
🏆个人专栏： 日常聊聊
⛳️ 功不唐捐，玉汝于成
目录
前言
程序员必备的面试技巧
一：面试经历
二：面试技巧
结语
我的其他博客 前言 面试对于程序员而言，就如同编写一段完美的代码一样重要。在这场技术较量的战场上，我们需要具备忍者的灵活性、侦探的聪明才智，同时又要像无敌铁金刚一样坚定不移。只有掌握了这些面试技巧，我们才能在面试的舞台上闪耀光芒，成为HR们心仪的程序猿。在本篇博客中，我们将从面试经历和面试技巧两个方向，分享一些宝贵的经验和小技巧，助你在面试中取得胜利。
程序员必备的面试技巧 “程序员必备的面试技巧，就像是编写一段完美的代码一样重要。在面试战场上，我们需要像忍者一样灵活，像侦探一样聪明，还要像无敌铁金刚一样坚定。只有掌握了这些技巧，我们才能在面试的舞台上闪耀光芒，成为那个令HR们心动的程序猿！”
一：面试经历 在这一部分，我将分享一些我个人的面试经历，以及从中得到的启示。
故事化的自我介绍： 在一次面试中，我尝试用故事化的方式来介绍自己的经历，而不是枯燥的列举技能和经历。这让我在HR面前更加生动有趣，留下了深刻的印象。
项目经验的强化： 强调在项目中遇到的挑战、解决方案以及取得的成就。这不仅能展示你的技术能力，还能表现出你在团队协作和问题解决方面的能力。
反思经验教训： 如果曾经在项目中遇到失败或挫折，不要回避，反而应该坦诚地分享，并突出你从中学到的教训和成长。
二：面试技巧 接下来，让我们探讨一些在面试中能够派上用场的技巧。
准备充分的技术知识： 在面试前，复习和巩固自己的技术知识是至关重要的。确保对所应聘的职位相关的技术栈有深入的了解，并能够熟练地解答相关问题。
沟通能力的提升： 在面试中，清晰而流畅的沟通是至关重要的。练习在有限的时间内表达清晰的思路，尽量避免使用过于专业的术语，以确保面试官能够理解你的回答。
问题解决思维： 面试官通常更关注你的问题解决能力，而不仅仅是掌握的知识。在回答问题时，可以展示你的思考过程，逐步解决问题，给面试官留下更深刻的印象。
自信而谦逊： 在回答问题时展现自信，但同时保持谦逊。接受自己的不足，并表达对学习和成长的渴望，会给面试官留下积极的印象。
提前了解公司文化和价值观： 在面试前，深入了解目标公司的文化和价值观，有针对性地展示自己与公司价值观的契合度，能够为你赢得更多加分。
结语 在程序员的职业道路上，面试是不可避免的一环。通过合理的准备和巧妙的展示，我们能够在面试中脱颖而出，成功斩获理想的职位。希望这些面试经历和技巧能够对你在面试战场上取得胜利提供一些有益的启示。祝你在未来的面试中取得骄人的成绩！
我的其他博客 【软件工程】走进敏捷开发：灵活、协作、迭代的软件工艺之旅-CSDN博客
【软件工程】融通未来的工艺：深度解析统一过程在软件开发中的角色-CSDN博客
【软件工程】走进瀑布模型：传统软件开发的经典之路-CSDN博客
【软件工程】走近演化过程模型：软件开发的不断进化之路-CSDN博客
【软件工程】漫谈增量过程模型：软件开发的逐步之道-CSDN博客
【Spring】理解IoC与AOP：构建灵活而模块化的软件架构-CSDN博客
【MySQL】数据库并发控制：悲观锁与乐观锁的深入解析-CSDN博客
【MySQL】数据库规范化的三大法则 — 一探范式设计原则-CSDN博客
【MySQL】数据库中为什么使用B+树不用B树-CSDN博客
【MySQL】SQL优化-CSDN博客
【MySQL】脏读、不可重复读、幻读介绍及代码解释-CSDN博客
【MySQL】多表连接查询-CSDN博客
【MySQL】数据库索引（简单明了）-CSDN博客
【Web开发】深度剖析RBAC：概念、实现方法、优势及在Web应用中的应用-CSDN博客
【Mybatis】深入学习MyBatis：高级特性与Spring整合-CSDN博客
【Mybatis】深入学习MyBatis：CRUD操作与动态SQL实战指南-CSDN博客
【MySQL】数据库索引（简单明了）-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dac8e9f5bd52f6181d1aedae0ea98008/" rel="bookmark">
			MySQL夯实之路-查询性能优化深入浅出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL调优分析 explain；show status查看服务器状态信息
优化 减少子任务，减少子任务执行次数，减少子任务执行时间（优，少，快）
查询优化分析方法 1．访问了太多的行和列：确认应用程序是否在检索大量超过需要的数据。这通常意味着访问了太多的行，但有时候也可能是访问了太多的列。
2．分析了太多的数据行：确认 MySQL服务器层是否在分析大量超过需要的数据行。
sql优化 1.减少查询的记录：使用select语句查询大量结果，然后再获取前N行（如新闻网站，取100条记录，只显示前面的10条；取最值），这时可以使用limit（limit 1，10；从1开始10行）
2.减少查询的列：不要总是SELECT *取出全部列，会额外消耗I/O、内存，CPU。
3.重复查询相同的数据：可以将数据缓存起来需要再取出
4.切分查询：有时需要将大查询切分为多个小查询。
删除旧数据：
定期地清除大量数据时，如果用一个大的语句一次性完成的话，则可能需要一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。将一个大的 DELETE语句切分成多个较小的查询可以尽可能小地影响MySQL性能，同时还可以减少MySQL复制的延迟。
分解关联查询：
查询执行的基础 5.尽量用外连接代替子查询：通过测试来验证
6.尽量不要排序，文件排序很损耗性能，尽量使用索引排序。
7.尽量不要使用in，会导致全表扫描，可以用between
确定了查询只返回需要的数据后，看是否扫描了额外的数据
查询开销 对于MySQL，最简单的衡量查询开销的三个指标如下:
1.响应时间
2.扫描的行数
3.返回的行数
如果发现查询需要扫描大量的数据但只返回少数的行，那么通常可以尝试下面的技巧去优化它:
1.使用索引覆盖扫描，把所有需要用的列都放到索引中，这样存储引擎无须回表获取对应行就可以返回结果了。
2.改变库表结构。例如使用单独的汇总表。
3.重写这个复杂的查询，让 MySQL优化器能够以更优化的方式执行这个查询。
查询执行的过程 查询过程 1．客户端发送一条查询给服务器。
2．服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则
进入下一阶段。
3．服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划。
4. MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询。
5．将结果返回给客户端。
Mysql客服端/服务端通信协议：
“半双工”的，同一时刻只能一方发送数据
查询状态 Show full processlist（返回结果的command列为当前状态）
查询缓存
在解析一个查询语句之前，如果查询缓存是打开的，那么MySQL会优先检查这个查询是否命中查询缓存中的数据。这个检查是通过一个对大小写敏感的哈希查找实现的。查询和缓存中的查询即使只有一个字节不同，那也不会匹配缓存结果#"，这种情况下查询就会进入下--阶段的处理。
如果当前的查询恰好命中了查询缓存，那么在返回查询结果之前MySQL会检查一次用户权限。这仍然是无须解析查询SQL语句的，因为在查询缓存中已经存放了当前查询需要访问的表信息。如果权限没有问题，MySQL会跳过所有其他阶段，直接从缓存中拿到结果并返回给客户端。这种情况下,查询不会被解析,不用生成执行计划,不会被执行。
查询优化处理 查询的生命周期的下一步是将一个SQL转推成一个执行计划，MySQL再依照这个执行计划和存储引擎进行交互。这包括多个子阶段:解析SQL、预处理、优化SQL执行计划。这个过程中任何错误（例如语法错误）都可能终止查询。
语法解析器和预处理
首先，MySQL通过关键字将SQL语句进行解析，并生成一棵对应的“解析树”。MySQL解析器将使用MySQL语法规则验证和解析查询。例如，它将验证是否使用错误的关键字，或者使用关键字的顺序是否正确等，再或者它还会验证引号是否能前后正确匹配。
预处理器则根据一些MySQL规则进一步检查解析树是否合法，例如，这里将检查数据表和数据列是否存在，还会解析名字和别名，看看它们是否有歧义。
下一步预处理器会验证权限。这通常很快，除非服务器上有非常多的权限配置。 查询优化器
现在语法树被认为是合法的了，并且由优化器将其转化成执行计划。一条查询可以有很多种执行方式，最后都返回相同的结果。优化器的作用就是找到这其中最好的执行计划。MySQL使用基于成本的优化器，它将尝试预测一个查询使用某种执行计划时的成本，并选择其中成本最小的一个。最初，成本的最小单位是随机读取一个4K数据页的成本，后来（成本计算公式）变得更加复杂，并且引入了一些“因子”来估算某些操作的代价，如当执行一次MERE条件比较的成本。可以通过查询当前会话的Last_query_cost的值来得知MySQL计算的当前查询的成本。
Mysql能处理的优化类型： 重新定义关联表的顺序，
将外连接转化为内连接，
使用等价变换规则，
优化count，min，max，
预估并转换为常数表达式，
覆盖索引扫描，
子查询优化
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dac8e9f5bd52f6181d1aedae0ea98008/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8c0ff2514fcf2cbb9dbc28fef9c014f/" rel="bookmark">
			软件架构之事件驱动架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、定义 事件驱动的架构是围绕事件的发布、捕获、处理和存储（或持久化）而构建的集成模型。 某个应用或服务执行一项操作或经历另一个应用或服务可能想知道的更改时，就会发布一个事件（也就是对该操作或更改的记录），另一个应用或服务便可以获取和处理该事件，继而执行更多操作。
二、基本原理 事件驱动架构以事件作为系统间通信的基本单位，系统中的各个组件通过发布和订阅事件来进行交互。基本原理包括以下几个要素：
1. 事件：事件是发生在系统中的某种动作或状态变化，它可以是用户操作，也可以是其他组件的响应。每个事件都有一个唯一的标识符，用于区别不同的事件类型。
2. 发布-订阅模式：在事件驱动架构中，系统中的某个组件可以发布（发布者）事件，而其他组件可以订阅（订阅者）这些事件。当有事件发布时，所有订阅该事件的组件都会收到通知。
3. 事件处理：事件的处理是事件驱动架构的核心。当一个事件被发布后，订阅该事件的组件会执行相应的事件处理函数。事件处理函数可以是系统内置的默认处理函数，也可以是开发者自定义的处理逻辑。
4. 事件传递：事件的传递是指事件在系统中的传递过程。一个事件可以触发其他事件的发布，从而形成事件链。事件传递可以是同步的，也可以是异步的，取决于具体的业务需求。
三、实现方式 事件驱动架构模式主要包含两种实现方式，分别是中介者拓扑（Mediator Topology），代理者拓扑（Broker Topology）。
3.1 中介者拓扑结构
中介者拓扑结构需要在一个事件通过 Mediator 时精心安排好具体的步骤，适合有多个步骤的事件。(有点工作流的感觉)。比如在交易系统中，每个请求流程必须经过特定的步骤，如验证、订单、配送，以及通知买家等。在这些步骤中，有些步骤是串行，有些可以并行完成。
主要包括 4 个基本组件：
事件队列（event queue）：接收事件的入口，存储待处理事件分发器（event mediator）：将不同的事件分发到不同的业务逻辑单元事件通道（event channel）：分发器与处理器之间的联系渠道事件处理器（event processor）：实现业务逻辑，处理完成后会发出事件，触发下一步操作 示例：以一个处理保险流程的例子来说明，如图： 3.2代理者拓扑（Broker Topology）
代理者拓扑主要由 Event Processor 和 Event Channel 构成，事件之间可能彼此是相互关联的。例如，一个 Event Processor 的处理结果是下一个 Event Processor 需要消费的事件，每个 Processor 必须完成自己的工作，其他 Processor 才能开始执行，整个事件处理过程像一条彼此相扣的链条，只有整个流程结束才能形成一个完整的业务逻辑。（类似于职责链或管道模式）。
示例：同样以一个处理保险流程的例子来说明，如图：
四、优点与缺点
事件驱动架构可以实现系统的松耦合，使各个组件之间解耦，具有以下优点：
1. 可扩展性：通过事件驱动架构，可以方便地增加、修改或删除系统中的组件，而不会影响其他组件的正常运行。
2. 灵活性：每个组件可以独立开发和测试，不受其他组件的影响。这样可以更好地适应需求的变化或更新迭代。
3. 可重用性：事件驱动架构可以将特定的功能封装成独立的组件，使其可以在系统中的多个地方进行复用，减少重复开发的工作量。
4. 可测试性：由于各个组件之间解耦，可以更加方便地对单个组件进行单元测试和集成测试，提高系统的可测试性和稳定性。
缺点：
一旦环境变化，需要代码调整或增加功能时，通常比较麻烦和费时部署比较麻烦，即使只修改一个小地方，往往需要整个软件重新部署，不容易做持续发布软件升级时，可能需要整个服务暂停扩展性差，用户请求大量增加时，必须依次扩展每一层，由于每一层内部是耦合的，扩展会很困难 参考：
事件驱动的架构 | IBM
事件驱动架构 - 光星の博客 13种常见软件体系结构风格定义分析、结构图、优缺点_软件体系结构设计风格-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5be48b026a88f0e57a23ae68d408260e/" rel="bookmark">
			软件测试|Python openpyxl库使用指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 我们之前介绍过，python在自动化办公方面可以大放异彩，因为Python有许多的第三方库，其中有很多库就支持我们对office软件进行操作，熟练的使用Python对office进行操作，可以实现自动化办公，极大提升我们的工作效率。本篇文章，我们就来介绍一下处理Excel的第三方库，openpyxl的使用。
安装openpyxl库 在我们使用openpyxl库之前，我们需要先安装它，安装的方式与其他的第三方库一致，使用pip命令安装即可，命令如下：
pip install openpyxl 打开Excel文件 首先，让我们看看如何打开一个已经存在的Excel文件：
import openpyxl # 打开Excel文件 workbook = openpyxl.load_workbook('demo.xlsx') # 选择工作表 sheet = workbook.active # 或者使用 workbook['Sheet1'] 读取和写入单元格数据 我们可以使用cell对象来读取和写入单元格的数据：
value = sheet['A1'].value print(value) # 写入单元格数据 sheet['B2'] = '20' value2 = sheet['B2'].value print(value2) workbook.save('demo.xlsx') ------------------ 输出结果如下： 姓名 20 遍历工作表数据 要遍历整个工作表的数据，您可以使用iter_rows()或iter_cols()方法：
# 遍历行 for row in sheet.iter_rows(min_row=2, max_row=6, min_col=1, max_col=3): for cell in row: print(cell.value, end='\t') print() -------------- 输出结果如下： Tony	20	理发师	Linda	22	会计	Harry	24	销售	Muller	23	工程师	John	30	教师 添加和删除工作表 我们还可以添加新的工作表，并删除已存在的工作表：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5be48b026a88f0e57a23ae68d408260e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14742d08c79e4352fe0a70207d6dc286/" rel="bookmark">
			03【深度学习】YOLOV3-WIN11环境搭建（配置&#43;训练)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、深度学习：YOLOV3-WIN11环境搭建
1、虚拟环境搭建
2、OpenCv安装：
3、Pycharm安装：
二、【深度学习】准备个人数据集、YOLOV3 模型的训练和测试
1、前置知识
2、数据集的准备
1.1 数据集资源介绍（了解）
1.2 COCO数据集介下载
1.3 COCO数据集的label标签下载
3、资源下载
3.1代码下载
3.2 生成自定义文件
3.3 下载测试环境的数据
4、部署YOLOV3的环境
4.1 用pycharm打开yolov3文件，并配置相应的虚拟环境
4.2 参数设置
4.3 运行
三、文件说明
1 config 文件夹
1.1 coco.data
1.2 create_custom_model.sh
1.3 custom.data
1.4 yolov3.cfg
1.5 yolov3-custom.cfg
1.6 yolov3-tiny.cfg
2 data 文件夹
2.1 coco文件夹
2.2 custom文件夹
2.3 samples文件夹
2.4 coco.names
2.5 get_coco_dataset.sh
3 checkpoint文件夹
4 logs文件夹
5 weights文件夹
四、源码解析
4.1 augmentations.py
4.2 datasets.py
4.3 logger.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14742d08c79e4352fe0a70207d6dc286/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e95e130bb38dbbcebf6edccb124f30c6/" rel="bookmark">
			设计模式-责任链模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是责任链模式 责任链模式是一种行为设计模式，它让你可以将请求沿着处理者链进行发送。收到请求后，每个处理者都可以处理请求，或者将其传递给链上的下一个处理者。
适用于什么场景 事件/消息系统：在 GUI编程中，当一个事件（如鼠标点击、键盘按键）发生时，这个事件可能会被多个监听器监听并处理。这些监听器就形成了一个责任链。日志记录：日志的处理通常会有多级，如 debug、info、error等。这些处理级别就可以形成一个责任链，每个级别的处理器决定是否处理该消息并决定是否将消息传递给下一个处理器。工作流或审批流程：在一个工作流中，一个任务可能需要多个不同的对象（或步骤）进行处理，这些对象就可以形成一个责任链。拦截器（Interceptor）：在 Web开发中，拦截器用于在请求被实际处理之前或之后执行某些操作，如身份验证、日志记录、数据压缩等。这些拦截器可以形成一个责任链，每个拦截器决定是否将请求传递给下一个拦截器。购物车支付留存等 uml图 type Handler interface { execute(pms *Pms) error setNext(Handler) } type handlerA struct { next Handler } func (h *handlerA) execute(pms *Pms) error { if pms.isLogin { return h.next.execute(pms) } return fmt.Errorf("not login") } func (h *handlerA) setNext(next Handler) { h.next = next } type handlerB struct { next Handler } func (h *handlerB) execute(pms *Pms) error { if pms.isPay { return h.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e95e130bb38dbbcebf6edccb124f30c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa1b671d28dfb478a29a189e81ebd790/" rel="bookmark">
			专题总纲目录 Android Framework 总纲
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		专题总纲说明：
本系列文章虽说是 Android 的知识体系专题，同时也是学习Android Framework 系统的一个思路，尤其是当我们对Android 框架层 一点都不了解的时候，但前提是要有 Java 基础和 C/C++基础，常用的数据结构和算法，操作系统基础知识。
00 小型gerrit服务器搭建 专题分纲目录 服务器搭建
服务器搭建（01）Gerrit服务器搭建 &amp; 内网访问
服务器搭建（02）Gerrit服务器SSH &amp; 建仓 &amp; 删仓
服务器搭建（03）Gerrit服务器 权限管理 &amp; Git操作集合
服务器搭建（04）VNC服务的搭建（windows访问Linux）
服务器搭建（05）centOS7.2 服务器 整合
服务器搭建（06）共享文件夹策略与实现
服务器搭建（07）定时执行脚本
服务器搭建（08）磁盘扩容
服务器搭建（09）设置开机启动脚本（ubuntu18.04后）
01 Android 开发环境 专题分纲目录 Android系统基础和调试
Android系统基础（01）简介
Android系统基础（02） 系统源码环境搭建
Android系统基础（03） 系统源码下载
Android系统基础（04） Android系统源码 编译&amp;烧写
Android系统基础（05） Android系统源码 调试
Android系统调试（01）日志分析基础流程
Android系统调试（02）ANR问题总结
Android系统调试（03）OOM问题总结
02 Android 系统层 核心基础 专题分纲目录 android 系统核心机制基础
android系统核心机制 基础（01）智能指针wp &amp; sp
android系统核心机制 基础（02）Thread类解析
android系统核心机制 基础（03）Thread 同步机制
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa1b671d28dfb478a29a189e81ebd790/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b853cf2626b38972a8f80ddef921c1e/" rel="bookmark">
			win10系统gpu本地部署chatglm3-6b，从0开始安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开源地址：
GitHub - THUDM/ChatGLM3: ChatGLM3 series: Open Bilingual Chat LLMs | 开源双语对话语言模型 前言：ChatGLM2与ChatGLM3区别 ChatGLM2与ChatGLM3模型架构是完全一致的，ChatGLM与后继者结构不同。可见ChatGLM3相对于ChatGLM2没有模型架构上的改进。
相对于ChatGLM，ChatGLM2、ChatGLM3模型上的变化：
词表的大小从ChatGLM的150528缩小为65024 （一个直观的体验是ChatGLM2、3加载比ChatGLM快不少）位置编码从每个GLMBlock一份提升为全局一份SelfAttention之后的前馈网络有不同。ChatGLM用GELU（Gaussian Error Linear Unit）做激活；ChatGLM用Swish-1做激活。而且ChatGLM2、3应该是修正了之前的一个bug，因为GLU（Gated Linear Unit）本质上一半的入参是用来做门控制的，不需要输出到下层，所以ChatGLM2、3看起来前后维度不一致（27392-&gt;13696)反而是正确的。 ChatGLM2与ChatGLM区别 ChatGLM2-6B 是开源中英双语对话模型 ChatGLM-6B 的第二代版本，在保留了初代模型对话流畅、部署门槛较低等众多优秀特性的基础之上，ChatGLM2-6B 引入了如下新特性：
更强大的性能：基于 ChatGLM 初代模型的开发经验，我们全面升级了 ChatGLM2-6B 的基座模型。ChatGLM2-6B 使用了 GLM 的混合目标函数，经过了 1.4T 中英标识符的预训练与人类偏好对齐训练，评测结果显示，相比于初代模型，ChatGLM2-6B 在 MMLU（+23%）、CEval（+33%）、GSM8K（+571%） 、BBH（+60%）等数据集上的性能取得了大幅度的提升，在同尺寸开源模型中具有较强的竞争力。
更长的上下文：基于 FlashAttention 技术，我们将基座模型的上下文长度（Context Length）由 ChatGLM-6B 的 2K 扩展到了 32K，并在对话阶段使用 8K 的上下文长度训练，允许更多轮次的对话。但当前版本的 ChatGLM2-6B 对单轮超长文档的理解能力有限，我们会在后续迭代升级中着重进行优化。
更高效的推理：基于 Multi-Query Attention 技术，ChatGLM2-6B 有更高效的推理速度和更低的显存占用：在官方的模型实现下，推理速度相比初代提升了 42%，INT4 量化下，6G 显存支持的对话长度由 1K 提升到了 8K。
更开放的协议：ChatGLM2-6B 权重对学术研究完全开放，在获得官方的书面许可后，亦允许商业使用。
1、本机安装gpu驱动,cuda，本文选定版本11.8 安装cuda toolkit CUDA Toolkit Archive | NVIDIA Developer
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b853cf2626b38972a8f80ddef921c1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42519d032305303161f2349b613e138a/" rel="bookmark">
			安装ubuntu22.04系统,GPU驱动，cuda,cudnn，python环境，pycharm
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要准备一个u盘，需要格式化，且内存不小于8g
1 下载ubuntu镜像 下载链接：
https://cn.ubuntu.com/download/desktop
2下载rufus Rufus - 轻松创建 USB 启动盘Rufus: Create bootable USB drives the easy wayhttps://rufus.ie/zh/
准备好这两个之后​​
配置好之后，点开始，然后基本下一步下一步就可以了。
１首先将source.list复制为source.list.bak备份。
cp /etc/apt/source.list /etc/apt/source.list.bak 修改完成后保存source.list文件，需要执行命令后才能生效：
sudo apt update 本文为 Ubuntu 22.04 的阿里云镜像源列表。若为其他版本，将所有jammy更改为其他版本代号即可。
常用的Ubuntu版本代号如下：
Ubuntu 22.04：jammy
Ubuntu 20.04：focal
Ubuntu 18.04：bionic
Ubuntu 16.04：xenia
vim /etc/apt/source.list １将文件内容清空，然后复制下方代码粘贴，wq保存退出即可。
deb https://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse deb https://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42519d032305303161f2349b613e138a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/911f375c2f24cd581467ec624b510583/" rel="bookmark">
			Java：爬虫htmlunit
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么htmlunit与HttpClient两者都可以爬虫、网页采集、通过网页自动写入数据，我们会推荐使用htmlunit呢?
一、网页的模拟化 首先说说HtmlUnit相对于HttpClient的最明显的一个好处，HtmlUnit更好的将一个网页封装成了一个对象，如果你非要说HttpClient返回的接口HttpResponse实际上也是存储了一个对象那也可以，但是HtmlUnit不仅保存了这个网页对象，更难能可贵的是它还存有这个网页的所有基本操作甚至事件。这就是说，我们对于操作这个网页可以像在jsp中写js一样，这是非常方便的，比如：你想某个节点的上一个节点，查找所有的按钮，查找样式为“bt-style”的所有元素，对于某些元素先进行一些改造，然后再转成String,或者我直接得到这个网页之后操作这个网页，完成一次提交都是非常方便的。这意味着你如果想分析一个网页会来的非常的容易
二、网络响应的自动化处理 HtmlUnit拥有强大的响应处理机制，我们知道：常见的404是找不到资源，100等是继续，300等是跳转...我们在使用HttpClient的时候它会把响应结果告诉我们，当然，你可以自己来判断，比如说，你发现响应码是302的时候，你就在响应头去找到新的地址并自动再跳过去，发现是100的时候就再发一次请求，你如果使用HttpClient,你可以这么去做，也可以写的比较完善，但是，HtmlUnit已经较为完整的实现了这一功能，甚至说，他还包括了页面JS的自动跳转（响应码是200，但是响应的页面就是一个JS）
三、并行控制 和串行控制 既然HtmlUnit封装了那么多的底层api和hHttpClient操作，那么它有没有给我们提供自定义各种响应策略和监听整个执行过程的方法呢？，答案是肯定的。由于HtmlUnit提供的监听和控制方法比较多，我说几个大家可能接触比较少，但很有用的方法。其他的类似于:设置CSS有效，设置不抛出JS异常，设置使用SSL安全链接，诸如此类，大家通过webClient.getOptions().set***，就可以设置了，这种大家都比较熟了。 四、强大的缓存机制 为什么第一次获取一个网页可能会比较慢，但是第二次来拿就特别快呢？在HtmlUnit源码webClient类中的loadWebResponseFromWebConnection方法中我们可以看到。 以下简单介绍下如何去分析网页及涉及的代码：
其中url可以直接浏览器访问地址直接解析页面，也可以通过分析页面请求接口（开启google浏览器F12开发者模式，刷新对应页面即可查看请求数据地址 -- &gt;&gt; 具体数据需要通过分享查看）
引入maven包： &lt;htmlunit.version&gt;2.70.0&lt;/htmlunit.version&gt; &lt;junit.version&gt;4.13.2&lt;/junit.version&gt; &lt;dependency&gt; &lt;groupId&gt;net.sourceforge.htmlunit&lt;/groupId&gt; &lt;artifactId&gt;htmlunit&lt;/artifactId&gt; &lt;version&gt;${htmlunit.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;${junit.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; @Slf4j public class ThreadLocalClientFactory { //单例工厂模式 private final static ThreadLocalClientFactory instance = new ThreadLocalClientFactory(); //线程的本地实例存储器，用于存储WebClient实例 private ThreadLocal&lt;WebClient&gt; clientThreadLocal; public ThreadLocalClientFactory() { clientThreadLocal = new ThreadLocal&lt;&gt;(); } /** * 获取工厂实例 * * @return 工厂实例 */ public static ThreadLocalClientFactory getInstance() { return instance; } public WebClient crawlPageApi() { WebClient webClient; /** * 如果当前线程已有WebClient实例，则直接返回该实例 * 否则重新创建一个WebClient实例并存储于当前线程的本地变量存储器 */ if ((webClient = clientThreadLocal.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/911f375c2f24cd581467ec624b510583/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d602b7f01839ac0efef1b8fae13d6d1/" rel="bookmark">
			若依开源框架介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、框架介绍 （1）若依不分离版本
（2）若依前后端分离版本
（3）若依微服务版本
（4）若依移动端版本 二、专栏文章介绍 一、框架介绍 RuoYi是一个基于Java技术开发的后台管理系统，目前官方同步在维护的有4个版本。
开源协议：MIT
解释：MIT是和BSD一样宽松的许可协议,作者只想保留版权,而无任何其他了限制.也就是说,你必须在你的发行版里包含原许可协议的声明,无论你是以二进制发布的还是以源代码发布的。
（1）若依不分离版本 RuoYi是基于经典技术组合（Spring Boot、Apache Shiro、MyBatis、Thymeleaf）主要目的让开发者注重专注业务，降低技术难度，从而节省人力成本，缩短项目周期，提高软件安全质量。
Gitee开源地址：RuoYi: 基于SpringBoot的权限管理系统 易读易懂、界面简洁美观。 核心技术采用Spring、MyBatis、Shiro没有任何其它重度依赖。直接运行即可用
在线文档地址：http://doc.ruoyi.vip/ruoyi/
在线演示地址：登录若依系统
（2）若依前后端分离版本 RuoYi-Vue是一个 Java EE 企业级快速开发平台，基于经典技术组合（Spring Boot、Spring Security、MyBatis、Jwt、Vue），内置模块如：部门管理、角色用户、菜单及按钮授权、数据权限、系统参数、日志管理、代码生成等。在线定时任务配置；支持集群，支持多数据源，支持分布式事务。
Gitee开源地址：RuoYi-Vue: 基于SpringBoot，Spring Security，JWT，Vue &amp; Element 的前后端分离权限管理系统
在线文档地址：介绍 | RuoYi
在线演示地址：若依管理系统
（3）若依微服务版本 RuoYi-Cloud 是一个 Java EE 分布式微服务架构平台，基于经典技术组合（Spring Boot、Spring Cloud &amp; Alibaba、Vue、Element），内置模块如：部门管理、角色用户、菜单及按钮授权、数据权限、系统参数、日志管理、代码生成等。在线定时任务配置；支持集群，支持多数据源。
Gitee开源地址：RuoYi-Cloud: 基于Spring Boot、Spring Cloud &amp; Alibaba的分布式微服务架构权限管理系统
在线文档地址：介绍 | RuoYi
在线演示地址：与前后端分离在线演示地址一样
（4）若依移动端版本 RuoYi-App 是若依的移动解决方案，采用uniapp框架，一份代码多终端适配，同时支持APP、小程序、H5！实现了与RuoYi-Vue平台 (opens new window)完美对接的移动解决方案！目前已经实现登录、我的、工作台、编辑资料、头像修改、密码修改、常见问题、关于我们等基础功能。
Gitee开源地址：RuoYi-App: 进群抢先体验🎉🎉🎉 RuoYi APP 移动端框架，基于uniapp+uniui封装的一套基础模版，支持H5、APP、微信小程序、支付宝小程序等，实现了与RuoYi-Vue后台完美对接。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d602b7f01839ac0efef1b8fae13d6d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0ecb76d44c8aaa7f80775db71c491c0/" rel="bookmark">
			ASP.NET Core高级之认证与授权(二)--JWT认证前后端完整实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阅读本文你的收获 了解JWT身份认证的流程了解基于JWT身份认证和Session身份认证的区别学习如何在ASP.NET Core WebAPI项目中封装JWT认证功能 在上文ASP.NET Core高级之认证与授权(一)–JWT入门-颁发、验证令牌中演示了JWT认证的一个入门案例，本文是一个基于JWT认证的完整的前后端实现代码案例。
一、基于JWT的用户认证 JWT身份认证的流程 在认证的时候，当用户用他们的凭证成功登录以后，一个JSON Web Token将会被返回。此后，token就是用户凭证了，你必须非常小心以防止出现安全问题。一般而言，你保存令牌的时候不应该超过你所需要它的时间。
无论何时用户想要访问受保护的路由或者资源的时候，用户代理（通常是浏览器）都应该带上JWT，典型的，通常放在Authorization header中，用Bearer schema。
上图流程说明：
用户携带用户名和密码请求认证服务器校验用户账号密码，成功则提供一个token给客户端客户端存储token，并且在随后的每一次请求中都带着它服务器校验token有效则返回数据，无效则返回401状态码； 二、基于JWT身份认证和Session身份认证的区别 基于Session的身份认证的缺点 会话信息会占用服务器
每次用户认证通过以后，服务器需要创建一条记录保存用户信息，通常是在内存中，随着认证通过的用户越来越多，服务器的在这里的开销就会越来越大。
难以扩展
由于Session是在服务器的内存中的，这就带来一些扩展性的问题。
跨域共享难
当我们想要扩展我们的应用，让我们的数据被多个移动设备使用时，我们必须考虑跨资源共享（如使用Redis）问题。当使用AJAX调用从另一个域名下获取资源时，我们可能会遇到禁止请求的问题。
安全性差
客户端要存Cookie来保存SessionId，所以 用户很容易受到CSRF攻击。
基于JWT令牌的身份认证的优缺点 优点：
简单轻巧
JWT生成的token字符串是轻量级，json风格，比较简单。
减轻服务器压力
它是无状态的，JWT方式将用户状态分散到了客户端中，服务器或者Session中不会存储任何用户信息。明显减轻服务端的内存压力。
容易做分布式
没有会话信息意味着应用程序可以根据需要扩展和添加更多的机器，而不必担心用户登录的位置；
缺点：
JWT token一旦签发，无法修改无法更新token有效期，用户登录状态刷新较难实现无法销毁一个token，服务端不能对用户状态进行绝对控制不包含权限控制 三、JWT前后端完整实现关键代码 开发环境：
操作系统： Windows 10 专业版
平台版本是：.NET 6
开发框架：ASP.NET Core WebApi、Vue2+ElementUI
开发工具：Visual Studio 2022
1. JWT的选项配置 在appsetting.json文件中，配置JWT选项参数，这样做的好处是，使用者在发布后任然可以修改JWT的参数，如过期时间，密钥等。
"JWTTokenOption": { "Issuer": "WLW", //Token发布者 "Audience": "EveryTestOne", //Token接受者 "IssuerSigningKey": "WLW!@#%^99825949", //秘钥可以构建服务器认可的token；签名秘钥长度最少16 "AccessTokenExpiresMinutes": "30" //过期时间30分钟 } 为了在ASP.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0ecb76d44c8aaa7f80775db71c491c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd1a688d661132f278ad4714cf33beab/" rel="bookmark">
			【软件项目管理_软件工程】软件项目管理课后相关习题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(1)需求分析是回答系统必须（A）的问题。
A.做什么 B.怎么做 C.何时做 D.为谁做 (2)WBS非常重要，下列哪项不是其很重要的原因（D）。
A.帮助组织工作 B.防止遗漏工作 C.为项目估算提供依据 D.确定团队成员责任 (3)项目范围（C）。
A.只在项目开始时重要
B.在授权项目的合同或者其他文件得以批准后就不再重要了
C.从项目概念阶段到收尾阶段都应该加以管理和控制
D.是在项目执行阶段通过变更控制步骤进行处理的问题
(4)为了有效地管理项目，应该将工作分解为更小的部分，以下各项中，哪一项不能说明任务应该分解到什么程度?（C）
A.可以在80小时内完成 B.不能再进一步进行逻辑细分了
C.可由一个人完成 D.可以进行实际估算
(5)范围变更是指（C）。
A.修改技术规格 B.对范围陈述进行修订 C.对批准后的WBS进行修改 D.以上都不是
(6)下面哪项不是需求管理的过程?（A）
D.需求变更 C.需求分析 B.需求获取 A.需求设计
(7)下面哪项不是创建WBS的方法?（C）
A.自上而下的方法 B.自下而上的方法 C.控制方法 D.类比方法
(8)任务分解可以（B），它是范围变更的一项重要输入。
A.提供项目成本估算结果 B.提供项目范围基线
C.规定项目采用的过程 D.提供项目的关键路径
(9)范围基线由（B）组成。
A.项目章程、批准的详细的项目范围说明书和WBS
B.批准的详细的项目范围说明书、WBS和WBS字典
C.项目章程、项目工作说明书和WBS
D.WBS
(10)以下哪项是指对项目包括什么与不包括什么的定义与控制过程?（C）
A.项目章程 B.投标书 C.项目范围管理 D.项目成本估算
(11)（A）反映了组织机构或客户对系统、产品高层次的目标需求、由管理人员或市场分析人员确定。
A.业务需求 B.质量需求 C.范围定义 D.功能需求
(12)（D）描述了用户通过使用本软件产品必须要完成的任务，一般由用户协助提供。
A.约束和假设 B.非功能性需求 C.功能需求 D.用户需求
(13)（A）定义了开发人员必须实现的软件功能，使得用户通过使用此软件能完成他们的任务，从而满足了业务需求。
A.功能需求 B.系统需求 C.质量特性 D.业务需求
(14)（C）是对需求进行调查、收集、分析、评价、定义等所有活动。
A.需求获取 B.需求管理 C.需求开发 D.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd1a688d661132f278ad4714cf33beab/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/23/">«</a>
	<span class="pagination__item pagination__item--current">24/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/25/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>