<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dc1eb1c02f29813deaa2df8cdf0e543/" rel="bookmark">
			麒麟操作系统V10安装达梦数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		麒麟操作系统V10安装达梦数据库
1、下载达梦数据库
https://www.dameng.com/ucenter/docs.html 2、选择DM8开发版，rh7。
3、用xshell连接系统。
4、把数据库安装文件挂上去，记得要点一下右上角的已连接。
5、挂载安装文件，执行安装文件
mount /dev/sr0 /mnt cd /mnt/ ls ./DMInstall.bin -i 6、选择中文安装，其中提示可打开文件数过少，至少设置为65536或更多，我看没有报错就没有处理。
7、设置时区。
8、设置北京时间21.
9、选择自定义安装。
10、全部安装就完事了。
11、默认安装目录，不改动。
12、默认安装路径，也不改动。
13、开始安装。
14、安装完成。
15、数据库初始化。
cd /opt/dmdbms/bin 执行初始化
./dminit PATH=/home/dmdba/dmdbms PAGE_SIZE=16 初始化有这些参数
[root@localhost bin]# ./dminit HELP initdb V8 db version: 0x7000b file dm.key not found, use default license! License will expire on 2021-09-04 格式: ./dminit KEYWORD=value 例程: ./dminit PATH=/public/dmdb/dmData PAGE_SIZE=16 关键字 说明（默认值） -------------------------------------------------------------------------------- INI_FILE 初始化文件dm.ini存放的路径 PATH 初始数据库存放的路径 CTL_PATH 控制文件路径 LOG_PATH 日志文件路径 EXTENT_SIZE 数据文件使用的簇大小(16)，可选值：16, 32, 64，单位：页 PAGE_SIZE 数据页大小(8)，可选值：4, 8, 16, 32，单位：K LOG_SIZE 日志文件大小(256)，单位为：M，范围为：64M ~ 2G CASE_SENSITIVE 大小敏感(Y)，可选值：Y/N，1/0 CHARSET/UNICODE_FLAG 字符集(0)，可选值：0[GB18030]，1[UTF-8]，2[EUC-KR] SEC_PRIV_MODE 权限管理模式(0)，可选值：0[TRADITION]，1[BMJ]，2[EVAL] LENGTH_IN_CHAR VARCHAR类型长度是否以字符为单位(N)，可选值：Y/N，1/0 SYSDBA_PWD 设置SYSDBA密码(SYSDBA) SYSAUDITOR_PWD 设置SYSAUDITOR密码(SYSAUDITOR) DB_NAME 数据库名(DAMENG) INSTANCE_NAME 实例名(DMSERVER) PORT_NUM 监听端口号(5236) BUFFER 系统缓存大小(100)，单位M TIME_ZONE 设置时区(+08:00) PAGE_CHECK 页检查模式(0)，可选值：0/1/2 EXTERNAL_CIPHER_NAME 设置默认加密算法 EXTERNAL_HASH_NAME 设置默认HASH算法 EXTERNAL_CRYPTO_NAME 设置根密钥加密引擎 RLOG_ENC_FLAG 设置日志文件是否加密(N)，可选值：Y/N，1/0 USBKEY_PIN 设置USBKEY PIN PAGE_ENC_SLICE_SIZE 设置页加密分片大小，可选值：512、4096，单位：Byte ENCRYPT_NAME 设置全库加密算法 BLANK_PAD_MODE 设置空格填充模式(0)，可选值：0/1 SYSTEM_MIRROR_PATH SYSTEM数据文件镜像路径 MAIN_MIRROR_PATH MAIN数据文件镜像 ROLL_MIRROR_PATH 回滚文件镜像路径 MAL_FLAG 初始化时设置dm.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7dc1eb1c02f29813deaa2df8cdf0e543/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7619dfdd9afc32e3b91538c3a850d65e/" rel="bookmark">
			屏幕适配方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1：资源文件适配方案 drawable（追我博）：可曳的，可拉的
在drawable和layout文件后添加屏幕的尺寸，如下：
drawable-320x320 ,layout-320x320
drawable-336x367 , layout-336x367
该方案适合屏幕大小固定为几种的设备
2：固定屏幕适配方案 1：固定像素大小适配方案 Metrics（麦揣科斯）：度量;指标;量度;度量指标;衡量标准
给出参考屏幕（1920*1080），通过windowManager.getDefaultDisplay().getMetrics(displayMetrics)；获取到当前设备的真实长宽（注意长度需要去掉状态栏高度如：2340*1080），然后计算出在当前屏幕下的需要拉伸或者缩小的长宽缩放比，然后，通过视图给出的像素，进行缩放计算，得出真实屏幕的像素大小，再把该像素大小放入到视图的布局参数中。
基于该方法，可以衍生出UIRelativeLayout&amp;UILinearLayout适配性布局
1：获取状态栏的两种方法
//1：状态栏高度获取方法 public int getStatusBarHeight(Context context){ int resID = context.getResources().getIdentifier("status_bar_height", "dimen", "android"); if (resID &gt; 0){ return context.getResources().getDimensionPixelSize(resID); } return 0; } //2:通过反射获取到状态栏高度 private int getSystemBarHeight(Context context){ return getValue(context,"com.android.internal.R$dimen","system_bar_height",48); } private int getValue(Context context, String dimeClass, String system_bar_height, int defaultValue) { // com.android.internal.R$dimen system_bar_height 状态栏的高度 try { Class&lt;?&gt; clz= Class.forName(dimeClass); Object object = clz.newInstance(); Field field=clz.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7619dfdd9afc32e3b91538c3a850d65e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/406b9f2b55231aa1cd7f59a792e3415e/" rel="bookmark">
			Java面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.ArrayList、LinkedList 和 Vector 的区别。
1.ArrayList非线程安全的，Vector是线程安全的。
2.ArrayList扩容时按照50%增加，Vector 按照100%增加或则根据指定的扩容增量进行增加。
3.ArrayList的性能要高于Vector
4.LinkedList是链表实现的，因此查询慢，增删快。
5.LinkedList提供了List接口没有提供的方法，方便数据的头尾操作。
二.快速失败 (fail-fast) 和安全失败 (fail-safe) 的区别是什么？
1.快速失败：如果用迭代器遍历集合时，如果集合内容发生了改变。这时会抛出一个ConcurrentModificationException.
2.安全失败：迭代器遍历时用的是原集合的拷贝，因此改变原集合不会引起一场，但是这样也就无法感知原集合的变化了。
三.hashmap的数据结构
1.是由数组和链表/红黑树组成的，链表的数据多了就会转为红黑树。转换的阈值是8.
2.通过key的hashcode取模数组长度来确定将数据放到哪里
3.如果存放的位置已经有了数据了就形成链表向后放，node记录了next的节点。
4.默认初始容量是16，加载因子是0.75.意味着容量超过75%就会扩容一倍
5.key的equals用来确定在链表中是否有相同的key
四.List、Map、Set 三个接口，存取元素时，各有什么特点？
1.list可以有重复的元素，可以通过执行索引取元素，也可以在指定的位置存放元素
2.map键值对的方式存取元素，key不可以重复，可以通过key获取指定的键值对
3.set不允许存重复的元素，也就是equals相同的对象，也无法获取指定的元素。只能通过遍历。
五.两个对象值相同 (x.equals(y) == true)，但却可有不同的 hash code，这句话对不对?
1.分不同的情况，如果对象的equals没有被重写的话，那么equals都是继承的Object的。即为==，也就是说equals相同证明了是同一个对象，hashcode也一定相同。
2.针对上面的这种规范，java倡导如果equals被重写了那么hashcode也要重写。以此来保证equals相同时hashcode也相同
3.而这个问题是对的，因为如果不遵守这个规范，当然equals相同hashcode可以不同了。
六.Java 集合类框架的基本接口有哪些？
add,addAll,clear,contains,containsAll,remove,removeAll
clear,containsKey,containsValue,get,put
七.HashSet 和 TreeSet 有什么区别？
1.HashSet是无序的，可以有一个null，非同步。TreeSet是有序的，不能有null，通过compare方法决定放置的位置。TreeSet有两种排序方法：自然排序、自定义排序
2.HashSet是通过哈希表实现的、TreeSet二叉树实现的
八.HashSet的底层实现是什么？
1.通过hashmap来实现的，用key来存储数据，保证key的唯一性
九.LinkedHashMap 的实现原理?
hashmap+双向链表实现的，是有序的，分为插入顺序和访问顺序。
十.为什么集合Collection类没有实现 Cloneable 和 Serializable 接口？
应该有具体的实现来完由
十一.什么是迭代器？
为了方便容器的遍历，和具体的容器进行解耦。提供了公共的实现方法。
十二.Iterator 和 ListIterator 的区别是什么？
Iterator是一个接口，ListIterator 是对它的具体实现,并增加了上一个元素的查询和set,add方法
十三.数组 (Array) 和列表 (ArrayList) 有什么区别？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/406b9f2b55231aa1cd7f59a792e3415e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a43bfc9fa867523e702f74c129ea14b/" rel="bookmark">
			PHP的内存限制Allowed memory size of之memory_limit
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近有公司业务不断上升，用户不断新增，区域IT人员反馈说后台管理系统某些更新操作会报错，
进入服务器日志目录一探究竟：tail 2021070114.ERROR.log
发现问题如下： msg:Allowed memory size of 134217728 bytes exhausted (tried to allocate 20480 bytes)
初步断定是服务器配置问题：
查看配置值文件 配置memory_limit的内存分配，标配是512M。一旦独立的线程超过了512M，那PHP会报错： Fatal error: Allowed memory size of 33554432 bytes对于8G内存的服务器，如果同时并发的响应达到50,每个都是512M的峰值，那估计也是服务器会卡死的时候。 解决方案： 最后又复现了几次问题，同一条数据，第一次失败，第二次成功，在最后定位是多台虚拟服务器配置不一致导致的，所以让运维吧服务器配置检查，配置，重新服务器后，问题解决了，
最后寄语： 尽量降低512M的内存配置，如果调整至128M，64M，服务器的负载基本能下降一半左右，如果能调整至32M效果更好。但是对于应用的要求就更高，很多表建立初期就没有考虑到这个问题，如果你要采用memcache作为数据的存储，必须提前完成优化数据表的设计部署，降低独立线程PHP的内存使用量，服务器的响应和负载降低的就不仅仅是几个百分点的效果了。
温馨提示： php5中：对于memory_limit的设定已经从以往的8M扩大到128M的上限。对于配置中的定义解释是： memory_limit = 128M ; Maximum amount of memory a script may consume (128MB) 最大单线程的独立内存使用量。也就是一个web请求，给予线程最大的内存使用量的定义。现有的大部分网站或者论坛应用中，应用软件的配备一般都是以如下的形式搭建： Nginx（Apache）+PHP+Memcache+Mysql 对于以上的应用软件的采用，优点我就不再多说。但对于Memcache的使用就是为了减少对于数据库的访问的频率的降低，也是提高服务响应的一种办法。但是对于memcache和数据库的数据存储有区别的是，memcache的数据并不是以上数据的形式存储在内存中，而是抽象化了之后以字符的形式，hash表的形式存储在内存之中。这样的存储区别导致，每次memcache的数据抽取必须全部数据反序拟化一次，将所有的数据导入进独立的单一线程中，然后第二部才是进行过滤和抽取你所需要的数据。在应用过程中，如果是读取数据库的数据，大家应该知道，优化的办法应该是在SQL语句中比保证第一次过滤尽量是提高准确性，只取需要的字段，不要全部所有字段取出之后再在应用中过滤得到自己想要的字段，这样对于服务器的负载会有本质的区别。 如果采用memcache，必然做不到数据库在在第一次就精确过滤这点目标。那么就需要在开始设计表的同时就需要考虑到这点，尽量保证被memcache数据表尽量保证数据的较少，可以多分表来完成。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2124721203c9628deac6d327ce85696/" rel="bookmark">
			【Flink】Flink 的 slotSharingGroup 有什么用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.概述 转载并且补充：Flink控制任务调度：作业链与处理槽共享组（slot-sharing-group）
为了实现并行执行，Flink应用会将算子划分为不同任务，然后将这些任务分配到集群中的不同进程上去执行。和很多其他分布式系统一样，Flink应用的性能很大程度上取决于任务的调度方式。任务被分配到的工作进程、任务间的共存情况以及工作进程中的任务数都会对应用的性能产生显著影响。本节中我们就讨论一下如何通过调整默认行为以及控制作业链与作业分配（处理槽共享组）来提高应用的性能。
其实这两个概念我们可以看作：资源共享链与资源共享组。当我们编写完一个Flink程序，从Client开始执行——&gt;JobManager——&gt;TaskManager——&gt;Slot启动并执行Task的过程中，会对我们提交的执行计划进行优化，其中有两个比较重要的优化过程是：任务链与处理槽共享组，前者是对执行效率的优化，后者是对内存资源的优化。
2.执行过程 Chain：Flink会尽可能地将多个operator链接（chain）在一起形成一个task pipline。每个task pipline在一个线程中执行
优点：它能减少线程之间的切换，减少消息的序列化/反序列化，减少数据在缓冲区的交换（即降低本地数据交换成本），减少了延迟的同时提高整体的吞吐量。
这一点请参考：【Flink】 collector 非常慢 一次尴尬的 排查错误方向 chain 与 不chain 的 区别
概述：在StreamGraph转换为JobGraph过程中，关键在于将多个 StreamNode 优化为一个 JobVertex，对应的 StreamEdge 则转化为 JobEdge，并且 JobVertex 和 JobEdge 之间通过 IntermediateDataSet （中间数据集）形成一个生产者和消费者的连接关系。每个JobVertex就是JobManger的一个任务调度单位（任务Task）。为了避免在这个过程中将关联性很强的几个StreamNode（算子）放到不同JobVertex（Task）中，从而导致因为Task执行产生的效率问题（数据交换（网络传输）、线程上下文切换），Flink会在StreamGraph转换为JobGraph过程中将可以优化的算子合并为一个算子链（也就是形成一个Task）。这样就可以把这条链上的算子放到一个线程中去执行，这样就提高了任务执行效率。
可见，StreamGraph转换为JobGraph过程中，实际上是逐条审查每一个StreamEdge和该SteamEdge两头连接的两个StreamNode的特性，来决定该StreamEdge两头的StreamNode是不是可以合并在一起形成算子链。这个判断过程flink给出了明确的规则，我们看一下StreamingJobGraphGenerator中的isChainable（）方法：
public static boolean isChainable(StreamEdge edge, StreamGraph streamGraph) { /** 获取StreamEdge的源和目标StreamNode */ StreamNode upStreamVertex = streamGraph.getSourceVertex(edge); StreamNode downStreamVertex = streamGraph.getTargetVertex(edge); /** 获取源和目标StreamNode中的StreamOperator */ StreamOperatorFactory&lt;?&gt; headOperator = upStreamVertex.getOperatorFactory(); StreamOperatorFactory&lt;?&gt; outOperator = downStreamVertex.getOperatorFactory(); /** * 1、下游节点只有一个输入 * 2、下游节点的操作符不为null * 3、上游节点的操作符不为null * 4、上下游节点在一个槽位共享组内 * 5、下游节点的连接策略是 ALWAYS * 6、上游节点的连接策略是 HEAD 或者 ALWAYS * 7、edge 的分区函数是 ForwardPartitioner 的实例 * 8、上下游节点的并行度相等 * 9、可以进行节点连接操作 */ //如果边的下游流节点的入边数目为1（也即其为单输入算子） return downStreamVertex.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2124721203c9628deac6d327ce85696/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87abe7ef3cebfd29732cdbe2c2a2b47d/" rel="bookmark">
			Springboot&#43;MySQL 实现从数据库获取数据展示到前端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.运行效果 效果图如下：
2.创建数据库表 数据库名为"springboot",数据库表名为"user"，数据库表里面放了5条数据，字段分别为：“id”，“name”，“age”，“email”。
3.新建SpringBoot项目 1、选择Spring Initializr，在本地路径下选择对应的SDK文件，选择默认的Service URL，选择Next。
2、把Version改为“1.0.0-SNAPSHOT”，选择Next。
3、这里需要导入3个依赖，选择Web-Spring Web，选择SQL-MySQL Driver，选择Developer Tool-Lombok。
4、选择存放路径。
5、创建项目时可能会出现这种error。
5.1、打开settings，找到http Proxy，选择Auto-detect proxy settings，选择Check connection，输入“https://start.aliyun.com/”。
5.2、按之前的步骤把项目重新创建一次，选择“Custom”输入“https://start.aliyun.com/”，其他的步骤不变。
6.创建好的项目是这样子的。
7.右下角的Maven提示选择“Enable Auto-Import”，pom有添加依赖时自动导入。
4.运行SpringBoot 1、先写个小页面让SpringBoot跑起来，在demo包下新建“controller”包，“controller”包下新建“HelloController”类。
2、在“HelloController”方法上添加注解“@RestController”，意思是返回json数据，“@Controller”是返回页面。
3、写个Hello方法，String返回值类型，在方法上添加”@RequestMapping“返回json数据，@RequestMapping("/hello")括号里面的内容是等下要访问的路径名，方法里面直接return ”Hello“。
4、默认是8080端口。
5.配置application.properties application.properties 代码如下：
spring.mvc.view.prefix=/WEB-INF/jsp/ spring.mvc.view.suffix=.jsp spring.datasource.url=jdbc:mysql://127.0.0.1:3306/springboot?characterEncoding=UTF-8&amp;serverTimezone=UTC spring.datasource.username=root spring.datasource.password=root spring.datasource.driver-class-name=com.mysql.jdbc.Driver 1234567 6.导入依赖 除了之前导入的”依赖还需要下面这些依赖。
&lt;!--内置tomcat对Jsp支持的依赖，用于编译Jsp--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--引入jsp相关--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--引入Servlet--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--引入jstl--&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87abe7ef3cebfd29732cdbe2c2a2b47d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6fe70e79d92e40ae2cad7c1c09c82a7/" rel="bookmark">
			UE4实时渲染——几何结构渲染一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一节：UE4实时渲染——渲染前和遮挡
上一节Draw线程准备好了一些对象，这些对象是当前一帧对象我们可见的，现在我们要使用GPU线程逐对象来渲染了。
首先我们要考虑的，就是渲染对象的顺序，我们不能单纯的像粉刷墙画那样，先刷上一层背景，再刷上面的图案，这会导致图案和背景重叠的部分，会重复绘制2次，如果在N多个对象的场景中，这种绘制无疑是性能的浪费。
我们的办法是依靠前期的深度（Z）通道，做一个深度测试，当渲染几何体时，他会先做一次预通道，确定下来其中一些像素点的值会被另一个模型的像素所覆盖，所以在渲染背景时，他就不会渲染这部分像素点。
预通道设置我们没办法插手太多，设置开启即可。
现在我们开始渲染具体的几何体，几何体会根据绘制调用（drawcall）来逐个渲染。
本节的接下来会重点介绍这个功能，绘制调用drawcall。
绘制调用（drawcall）是指渲染时采用的单一处理过程，可以理解为，有相同属性（材质等）的一组多边形或对象。
比如：
左右两图都有三种元素需要绘制，天空、地面、圆柱体，
区别是，左图只需要绘制5次，而右图由于第三个圆柱体是由两种材质构成，所以需要绘制6次。
每一种新的材质，便要一次新的绘制调用drawcall。
这也就能解释，drawcall会成为最大的性能损耗了，所以如果想在这里获得高性能，就要使绘制调用的次数合理化。
右图的实际渲染顺序如下：
引擎把它们按材质分类组合。我们可以看到三根柱子同材质部分，会依次渲染，然后再绘制其他材质的柱子、其他材质的对象。
有一个常用的命令“stat RHI”（rendering head interface渲染头接口），用来查看当前渲染三角形次数、渲染对象个数等信息。打开后如图：
Trangles drawn：616212
绘制了约62万个三角形
DrawPrimitive calls：1091
绘制调用drawcall了1091个对象
开启光照会对这个数值产生影响，当开启光照时，绘制调用对象和三角形数量会变多：
如下：
三角形数量变为80万左右，绘制调用次数变为1131个左右
但不要太纠结这个所显示的渲染数量，和你在UE4中看到的对象数量的差别，它背后的计算过程我们是看不到的，所以有出入属于正常。
但有个对照表，可以帮助我们明确是否渲染需要优化。
绘制调用次数状态2000-3000正常5000+过高10000+可能会导致问题（取决于硬件以及你用这个做了什么） 一般来说，在可移动设备（手机、VR等）上的绘制调用次数，通常只有几百次最多一千次左右。
drawcall绘制调用，是极其影响性能的因素，每一次渲染器完成绘制调用时，它都要再次接收从渲染线程发来的命令，从而增加损耗。
drawcall绘制调用的影响，在很多情况下已经大于“多边形面数”了，之前我们总是关注渲染多边形有十几万个，其性能消耗之大，但现在我们应该多关注drawcall，因为它的性能消耗不会比渲染多边形要少。
我们可以举一个例子来说明这个性能消耗的比较，比如在PC计算机上，
文件夹及内容总大小复制耗时文件夹中有1GB的1个文件1GB几分钟文件夹中有1KB的1百万个文件1GB一两天 这和计算机复制文件的流程是有关的，它每次复制完都要再询问并获取下一个复制文件，同理，这也就是为什么drawcall绘制调用的性能消耗如此之大了，这和有多少三角形面片关系并不大。
再比如有这样的情况：
8600万相同材质三角形，3000次drawcall绘制调用，帧率为33fps
10万个不同材质三角形，44000次drawcall绘制调用，帧率为4fps
15万7000个相同材质三角形，186次drawcall绘制调用，帧率为236fps
这是因为第二幅图中，每一个三角形的材质都不同（如下图显示），如上面介绍的那样，这将会导致每绘制一种材质的三角形，就会调用一次drawcall绘制调用，也就是：渲染-&gt;停下-&gt;等待-&gt;渲染-&gt;停下-&gt;等待……
总结：
1、绘制调用drawcall对于损耗的影响，会比多边形数量更大。
2、根据你的设置和运行方式，5万三角形可能比5千万的运行效果还差。
3、绘制调用drawcall有基本损耗，所以把低面数模型改为超低面数模型可能不会有太大的改进。
下一节：UE4实时渲染——几何结构渲染二
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37643f1dd4867743518e86422b898946/" rel="bookmark">
			2021-07-04
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【新手如何搭建JAVA开发环境】https://mbd.baidu.com/ma/s/t7VB1Lv6 工具原料JDK1.8
方法/步骤分步阅读
1
首先，从oracle官网下载JDK。
以windows64位系统为例，这里选择jdk-8u181-windows-x64.exe下载
2
下载完成后，开始配置JAVA环境变量。将刚下载的JDK解压到D:\java\jdk1.8目录。开始-》程序-》计算机-》右键属性-》高级系统设置-》环境变量，在用户变量下面新建-》变量名输入JAVA_HOME，变量值输入：D:\java\jdk1.8 ；新建-》变量名输入PATH，变量值输入：%JAVA_HOME%\bin; 新建-》变量名输入CLASS_PATH，变量值输入：%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;%JAVA_HOME%\jre\lib\rt.jar;这里注意，如果你的环境变量里已经有其他软件的值，他们之间用;分隔。
上述步骤完成后，点击确定保存。
3
配置完成后，验证环境的正确性。在程序菜单，下面输入框里输入cmd，弹出命令行窗口，输入java -version,结果显示java version "1.8.0_171"等字样，表示安装正确。
4
下面用txt编写一个入门程序，新建文件，保存文件名称为HelloWorld.java
输入下面代码：
public class HelloWorld {
public static void main(String args[]) {
System.out.println(“Hello World”);
}
}
保存到D:\test\HelloWorld.java
5
下面开始编译，命令行窗口输入
cd d:\test
d:
javac HelloWorld.java
6
下面开始运行，命令行输入
java HelloWorld
屏幕下方是不是出现了"Hello World"?没有的话，检查下自己的路径，类名等等是否输入正确？环境变量是否设置正确？
【注意事项】
JDK安装目录不要写错了
配置PATH和CLASS_PATH时，安装根目录写%JAVA_HOME%，不要直接写磁盘目录，以免日后更换JDK版本带来不便。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef57c70faedcfd91f97c790a3220f763/" rel="bookmark">
			mybatis中四种模糊查询的方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2.8、mybatis的模糊查询 方式一： 手动添加"%"通配符
xml配置： &lt;!--模糊查询--&gt; &lt;select id="fuzzyQuery" resultType="com.bin.pojo.Book"&gt; select * from mybatis.book where bookName like #{info}; &lt;/select&gt; 测试： @Test public void fuzzyQuery(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); BookMapper mapper = sqlSession.getMapper(BookMapper.class); List&lt;Book&gt; books = mapper.fuzzyQuery("%萨%"); for (Book book : books) { System.out.println(book); } sqlSession.close(); } **说明：**需要手动添加"%"通配符，显然这种方式很麻烦，并且如果忘记添加通配符的话就会变成普通的查询语句，匹配全部字符查询。
缺点： 麻烦易出错 方式二： 在xml配置文件中添加"%"通配符，拼接字符串形式
&lt;select id="fuzzyQuery" resultType="com.bin.pojo.Book"&gt; select * from mybatis.book where bookName like '%${info}%'; &lt;/select&gt; **说明：**在mapper.xml配置文件中添加"%"通配符，但是需要用单引号将其包裹住，但是用单引号裹住之后#{}就无法被识别，要改成${}这种拼接字符串的形式。虽然通过方式二优化了方式一的缺点，但同时也造成了SQL安全性的问题，也就是用户可以进行SQL注入。
缺点： 不安全，可进行SQL注入 方式三： 在xml配置文件中添加"%"通配符，借助mysql函数
&lt;select id="fuzzyQuery" resultType="com.bin.pojo.Book"&gt; select * from mybatis.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef57c70faedcfd91f97c790a3220f763/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99961eeb3debe6cd6fb57afb1ca01985/" rel="bookmark">
			1047：判断能否被3，5，7整除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1047：判断能否被3，5，7整除 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】
给定一个整数，判断它能否被3，5，7整除，并输出以下信息：
1、能同时被3，5，7整除（直接输出3 5 7，每个数中间一个空格）；
2、只能被其中两个数整除（输出两个数，小的在前，大的在后。例如：3 5或者 3 7或者5 7，中间用空格分隔）；
3、只能被其中一个数整除（输出这个除数）；
4、不能被任何数整除，输出小写字符‘n’，不包括单引号。
【输入】
输入一行，包括一个整数。 【输出】
输出一行，按照描述要求给出整数被3，5，7整除的情况。 【输入样例】
105 【输出样例】
3 5 7 说明：
主要考查对if条件语句的理解，以及逻辑运算符的应用。
思路分析：
本题的判断条件比前面的题多了些。有以下8个条件：
3、5、7
3 5、3 7、5 7
3 5 7
‘n’
一般初学者会把所有的条件全都写出来：
如果（n%3等于0 并且 n%5等于0 并且 n%7等于0）输出3 5 7
否则，如果（n%3等于0 并且 n%5等于0）输出3 5
否则，如果（n%3等于0 并且 n%7等于0）输出3 7
否则，如果（n%5等于0 并且 n%7等于0）输出5 7
否则，如果（n%3等于0）输出3
否则，如果（n%5等于0）输出5
否则，如果（n%7等于0）输出7
否则，输出’n’
这种写法其实并不友好，对于初学if条件语句的同学来说容易出错，尤其是逻辑能力相对较差的同学。
其实可以把每个数的判断单独区分开，互不影响。谁满足就输出谁。当然，输出数字时，不要忘记输出一个空格。
思路：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99961eeb3debe6cd6fb57afb1ca01985/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b840520455880137187462d810413bd/" rel="bookmark">
			为什么计算机无法读取u盘,电脑无法识别读取U盘怎么办？逐一排查解决问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		U盘是大家非常熟悉的一个移动存储设备，但是你不一定了解U盘故障，例如电脑不能识别读取U盘，这是为什么呢？如何解决这一问题？下文整理了关于电脑无法读取U盘的解决方法，大家可以参考。
电脑无法识别读取U盘怎么办？
首先检查U盘接口是否出现生锈或者接口脱落，如果有，即要修复U盘设备；另外还要检查电脑USB接口，如果生锈严重，需要更换USB接口，否则可能无法识别U盘。
排除了硬件设备问题，现在进行实际操作：
1、更新驱动
鼠标右击【我的电脑/此电脑】，弹出菜单，选择【管理】，进入计算机管理窗口，如图，在左侧点击【设备管理器】，在右侧点击展开【通用串行总线控制器】，找到【USB大容量存储设备】，查看是否有黄色感叹号，鼠标右击该选项，选择【更新驱动程序软件】，重新拔插U盘，看看能否被识别。
2、磁盘管理
在计算机管理窗口中点击【存储】——【磁盘管理】，查看是否显示你的U盘磁盘，如果有，鼠标右击U盘盘符，选择【将分区标记为活动分区】，查看问题是否解决。
3、控制面板
打开控制面板，选择【查看方式】为类别，如图，点击【添加设备】，弹出窗口，正在搜索设备，出现你的U盘，点击下一步，等待安装完成。
还是在控制面板中进行操作，点击【查看设备和打印机】，进入以下界面，找到U盘设备，鼠标右击，选择【属性】，打开属性面板，点击【硬件】，查看该设备运转是否正常，如果不正常，即将重要资料转移到其他存储设备，不再使用这个U盘。
了解更多精彩教程资讯，关注wmzhe.com。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3362ce997bd8174295a1fecc65903be/" rel="bookmark">
			无法访问指定计算机,windows无法访问指定设备如何解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决Windows无法访问指定设备的方法很简单，一般导致此情况的原因是没有开启超级管理员权限，或者程序设备单独禁用了一些权限。知道原因后我们就来瞧瞧Windows无法访问指定设备的解决方法
Windows操作系统占领着90%的PC市场，给我们提供了简单易行的操作界面。不过近来有朋友反映在使用Windows的时候出现无法访问指定设备的提示，这是怎么回事呢？下面我们就来了解一下吧
Windows无法访问指定设备如何解决呢？今天想进入资源管理器打开D盘查找资料时，却莫名出现Windows无法访问指定设备的提示，捯饬了半天也没搞好。我给大家整理了详细解决方法，赶紧来瞧瞧吧
随着电脑用户的增加，电脑出现的问题也是五花八门，比如打开软件程序的时候出现window无法访问指定设备、路径的情况。其实这个问题很好解决，接下来，我就教大家如何解决Windows无法访问指定设备
windows无法访问指定设备解决方法
方法一：开启管理员权限
1、右击此电脑，选择管理，展开左侧栏的本地用户和组，点击用户。右击右侧的Administrator，选择属性
windows无法访问指定设备电脑图解1
2、取消账户已禁用的勾选，点击确定
windows电脑图解2
3、打开开始菜单，账户切换成Administrator。如果文件程序在C盘，就需要移动其他盘符才能在管理员账户下找到哦
windows电脑图解3
方法二：如果开启了管理员账户还是打不开呢，权限设置get一下
1、右击出现Windows无法访问指定设备的文件程序，选择属性。打开属性窗口，切换至安全选项卡，选择Administrator用户，点击下方的编辑
windows无法访问指定设备电脑图解4
2、这时候就可以设置权限了，完成后点击确定就OK啦
windows无法访问指定设备电脑图解5
以上就是Windows无法访问指定设备的解决方法，现在可以访问了吗？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/915e6ad34c67da206eea4e0ef159dfc8/" rel="bookmark">
			为什么计算机无法访问u盘,U盘插入电脑提示无法访问？别怕，我找到解决办法了...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原标题：U盘插入电脑提示无法访问？别怕，我找到解决办法了
U盘是一种使用USB接口来连接电脑的储存工具，使用方法快捷有效，携带也很方便。但是最近有一位小伙伴反馈说U盘插入电脑后发现无法访问U盘，这是怎么回事呢？作为专业的IT外包服务商，IT外包小编就跟大家解答U盘插进电脑无法访问的解决方法。
1、电脑插入U盘或移动硬盘时显示“无法访问、拒绝访问”
2、有的时候可能禁用了组策略当中的USB口，这时运行“gpedit.msc”命令，打开组策略。
3、打开组策略后，打开“计算机配置”，然后打开“管理模板”
4、打开“管理模板”后，找到“管理模板”下面的“系统”，然后打开“系统”
5、打开“系统”后，找到“系统”下面的“可移动存储访问”选项
6、点击“可移动存储访问”，在右边找到“所有可移动存储类：拒绝所有权限”选项。
7、然后右击“所有可移动存储类：拒绝所有权限”选项，点击“编辑”。
8、这时会发现“所有可移动存储类：拒绝所有权限”选项“已启用”。
9、把“已启用”改成“未配置”，然后再插入U盘
10、最后插入U盘后就可以正常显示了。
责任编辑：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff799e06c25474997939bd6826b0a0ae/" rel="bookmark">
			计算机无法识别u盘,电脑无法读取u盘怎么处理_电脑不能读取u盘如何解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用U盘的过程中，经常会遇到各种各样的现象，比如常见的电脑无法读取U盘的情况，许多用户并不知道出现这样的问题是怎么回事，针对电脑无法读取U盘电脑不能读取u盘这个情况，小编给大家解析一下详细的解决步骤。
具体步骤如下：
1、首先我们需要点击“控制面板”，进入到控制面板界面。控制面板找不到的朋友，在开始菜单中即可看到，如图所示。
2、之后我们在控制面板中点击“系统和安全”选项，有些控制面板是在其它地方，大家找一下，如图所示。
3、之后我们在进入的界面中点击下方的“管理工具”，我们即可在里面看到本地安全策略的程序，如图所示。
4、之后我们在进入的界面中，点击右侧的“本地安全策略”，这个里面是对一些安全功能的设置，因为安全的限制，U盘出现不能读取很正常，如图所示。
5、之后我们在本地安全策略中点击左侧的“本地策略”选项，如图所示。
6、之后我们在右侧即可看到如图的三个文件，我们点击“安全选项”，如图所示。
7、之后我们在里面仔细的找一下，点击”网络访问：本地账户的共享和安全模型”选项，如图所示。
6、之后我们在里面的本地安全设置中，点击下拉箭头，我们选中“经典”那个即可，如图所示。
最后我们正常情况下插入优盘就可以读取啦，不过如果不能读取的话。可能就不是电脑正常情况下的问题，我们可能需要维修电脑了。不过USB接口出现的问题比较大，不够不是读取的问题，是硬件没开或者损害，大家可以看一下，U盘无法连接电脑的解决办法。
上述就是电脑无法读取u盘怎么处理的详细步骤，遇到类似情况的可参考以上教程步骤来解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ebd6aec70e908595c097dc119a6d6c8/" rel="bookmark">
			电脑计算机配置应用程序兼容性,电脑怎么打开兼容模式怎么办
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. windows7怎么开兼容模式
启用兼容模式就可以了，具体步骤如下：
1. 点击右下角“开始”菜单，单击“运行”，在弹出的对话框里键入“gpedit.msc”，单击“确定”。
2. 此时进入组策略编辑器界面，双击“计算机配置”，进入下一步骤。
3.找到“管理模板”选项，双击，进入下一界面。
4.双击“Windows组建”。
5.在弹出的界面中找到“应用程序兼容性”选项，双击。
6.弹出如下界面，勾选“未配置”选项就OK了。
2. 电脑成了兼容模式怎么变回来
你的意思是不是在正常模式下电脑桌面一片空白？想把正常的桌面图标和其指向的运行功能调出来？是的话，倒容易解决！ 安全模式是指仅仅启动系统内核的模式，称之为安全模式。
在windows NT内核(不包括windows NT1.0-4.0)的操作系统。 安全模式的工作原理是在不加载第三方设备驱动程序的情况下启动电脑，是电脑运行的系统最小模式，这样可以使用户方便地检测与修复计算机系统的错误。
在安全模式工作，可以“删除顽固文件”“查杀病毒”“解除组策略锁定 ”“修复系统故障”“恢复系统设置”“揪出恶意的自启动程序或服务”“检测不兼容的硬件”“卸载不正确的驱动程序” 所以，电脑在安全模式下是不可能把桌面上的所有功能都调出来运行的。
3. 兼容模式 怎么回事
如果你的电脑安装的是2003版本office，别人发给你的文件是2007或者2010文件，你在打开时将出现程序错误的提示，这是需要安装office兼容包，以兼容模式才能打开。
当在 Excel 2007 或者2010中打开在早期版本中创建的工作簿时，会自动在兼容模式下打开它，并且会在 Excel 标题栏 (标题栏：窗口、对话框或工具栏顶端的水平栏，显示文档、程序或工具栏的名称。)中文件名旁边的方括号内显示“兼容模式”。
如果在兼容模式下使用工作簿，则任何新的或增强的 Excel 2007 或者2010功能都不可用，从而在早期版本的 Excel 中打开工作簿时可避免数据丢失和保真损失。此外，工作簿将使用 Excel 97-2003 文件格式 (.xls)(一种可轻松地在 Excel 早期版本中打开的二进制文件格式)进行保存，而不是使用当前基于 XML 的文件格式 (.xlsx)。
与其他 2007 Microsoft Office system 程序(如 Microsoft Office Word 2007)不同，在 Excel 中不能手动启用兼容模式，并且在兼容模式下使用工作簿时不能选择包含任何新功能。
如果您不希望再使用兼容模式，可以将工作簿转换为当前文件格式。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/443436dec81126623a6e15ee138d7e9c/" rel="bookmark">
			清华计算机学院考研真题,清华大学计算机考研912真题(回忆版)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2017年考研初试已经结束，为方便2017年考研的小伙伴估分，也为了2018年备考的小伙伴能对考研真题有个大致的了解，下面研招网小编为大家整理了清华大学计算机考研912真题(回忆版)，希望对大家有所帮助。
后序遍历中，first()函数和next()函数。(10分)
first()函数是求出后序遍历的第一个点，写出算法思路、伪代码
next()函数是求出当前节点后序遍历中的后一个结点，，写出算法思路、伪代码
由题意可知，通过first和next就能求出树的后序遍历，分析一下，这种方法与正常求后序遍历的方法有什么差异。
利用广度优先遍历的思想，求图中最小的围长，围长就是图中环的权加和，要求空间复杂度为O(n)，时间复杂度为O(ne)，e为边的个数，n为点的个数。(15分)
1.算法思路
2.伪代码
3.时间空间复杂度
我的思路是，对每一个结点都加一个信息，就是该结点父亲的信息。
按照广度优先遍历将所有结点入队，如果图中有环，会出现两个相连信息相同的结点。
找到相邻且相同的结点，根据父亲结点的信息，递归出环的所有结点，结束条件就是两个结点的父亲相同。
求出环的圈长，循环检查所有环，实时更新，最后输出最小圈长。
stl中的归并排序与正常归并排序的代码有些不同，下面给出stl中归并排序的源码(15分)
1.补全上文中确实的代码
2.解释上文划线代码的含义
3.这种归并排序与正常的归并排序相比有什么优缺点
答案大家可以看一下stl的源码，具体位置已经记不清了。
以上就是清华大学计算机考研912真题(回忆版)的全部内容。考研初试只是整个2017年考研旅途的第一站，接下来还会有复试。所以说，想完胜2017考研，复试一样不可轻视。，或点击加入2017考研复试交流群。它将助你一路通关。
相关推荐：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5811522e0bf5aa490693d8924b8fb68e/" rel="bookmark">
			计组——关于补码乘法的一点思考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 原码一位乘原码两位乘补码一位乘校正法👉前置知识：👉校正法的原理： Booth算法👉前置知识👉Booth算法基本思想 温馨提示，本文章着重于理解算法思路，充斥着大量的推导以及笔者说梦话似的自言自语，能力有限，无法完整详实地把这个过程表达出来，自己的理解也很不到位，望多包涵。错误请直接指出，我看到后会立马改正，谢谢大家监督。 原码一位乘 符号位单独计算，对于数值部分，则只需要像正常乘法那样
比如 x = − 0.1110 ， y = − 0.1101 x=-0.1110，y=-0.1101 x=−0.1110，y=−0.1101，求 [ x ⋅ y ] 原 [x\cdot y]_原 [x⋅y]原​
所有的右移过程均为逻辑右移
原码两位乘 z z z为部分积， x ∗ x^* x∗为被乘数， y ∗ y^* y∗为乘数
乘数判断位 y n − 1 y n y_{n-1}y_n yn−1​yn​标志位 C j C_j Cj​操作内容000部分积右移2位，乘数右移两位， C j C_j Cj​保持0010部分积加上一个被乘数，右移2位，乘数右移2位， C j C_j Cj​保持0100部分积加上2倍的被乘数，右移2位，乘数右移2位， C j C_j Cj​保持0110部分积减去一个被乘数数，右移2位，乘数右移2位， C j C_j Cj​置1001部分积加上一个被乘数，右移2位，乘数右移2位， C j C_j Cj​置0011部分积加上2倍的被乘数，右移2位，乘数右移2位， C j C_j Cj​置0101部分积减去一个被乘数，右移2位，乘数右移2位， C j C_j Cj​保持1①111部分积右移2位， C j C_j Cj​保持1② ①：应该是部分积加上三倍的被乘数，即 z + 3 x ∗ z+3x^* z+3x∗，转换成 z − x ∗ z-x^* z−x∗，然后整体右移两位后，对于下一次迭代， C j C_j Cj​为1，一定会加上一个 x ∗ x^* x∗，那么对于上一次迭代的 z z z来说，相当于是加上了一个左移了两位的 x ∗ x^* x∗，即 4 x ∗ 4x^* 4x∗，由于上次迭代减去了一个 x ∗ x^* x∗，所以最终相当于是加上了 3 x ∗ 3x^* 3x∗
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5811522e0bf5aa490693d8924b8fb68e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4da8fe6893bddb50c36a6a2cb5747dc0/" rel="bookmark">
			三平面映射TriPlanar
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		shader效果中存在“缝隙”：（最后的代码中已经注释的很清楚了）
出现缝隙的原因：因为UV坐标是不连续的，所以会有缝隙。。。（法线的T，B,是根据U和V生成的，所以用法线也会有裂缝，这里的法线和下面用作mask的用法是不一样的）
三平面映射的效果：图中的边界是有过渡和缓冲，如下图
基本展示：
世界空间XY平面效果：
世界空间XZ展示：
存在的问题（不可避免的问题）：！！！！！！！！！
宏观思路 ：
（1）
（2）法线遮罩效果 和 思路：
（3）
换成noise图看不出缝隙！！！！
Shader "Unlit/TriPlanar_Code" { Properties { _MainTex ("Texture", 2D) = "white" {} _Tilling("Main Tilling",Vector) = (1,1,1,1) _Contrast("Contrast",Range(1,10)) = 5 } SubShader { Tags { "RenderType"="Opaque" } LOD 100 Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag #include "UnityCG.cginc" struct appdata { float4 vertex : POSITION; float2 uv : TEXCOORD0; float3 normal : NORMAL; }; struct v2f { float2 uv : TEXCOORD0;	float4 vertex : SV_POSITION; float3 worldPos : TEXCOORD01; float3 worldPivot : TEXCOORD02; float3 worldNormal : TEXCOORD03; }; sampler2D _MainTex; float4 _MainTex_ST; float4 _Tilling; float _Contrast; v2f vert (appdata v) { v2f o; o.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4da8fe6893bddb50c36a6a2cb5747dc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83d31aa0209abed888deca52042c55eb/" rel="bookmark">
			2021-07-03
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安卓开发中ListView与activity传递数据的问题 原文 : 来自百度大佬的回答
activity传递给ListView只需要通过adapter就好了，listView传递给activity要麻烦一些，可选方法：
1.
activity传一个handler给Adapter，adapter和holder就通过handler给activity传递信息。
2.
在adapter里发广播传给activity。
3.
传递一个接口给adapter，通过回调的方式传递给activity。
4.
利用EventBus开源库的EventBus.getDefaut().post(XXX)方法，把信息post出去，activity注册EventBus后实现onEvent方法来接收。
四种方式是比较常用的，目前我基本上用的是方式4
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8497c868c2520424be7507daceed1eb5/" rel="bookmark">
			吴恩达机器学习（八）—— 机器学习系统的设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		机器学习系统的设计 1. 优先处理的工作：垃圾邮件分类例子2. 误差分析3. 偏斜类的误差度量4. 查准率和查全率之间的权衡5. 机器学习的数据 1. 优先处理的工作：垃圾邮件分类例子 在实际的工作过程中，我们应该明白哪些事情要优先处理，接下来我们以一个垃圾邮件分类器算法为例子进行讨论。
为了解决这样一个问题，我们首先要做的决定是如何选择并表达特征向量 x x x。我们可以选择一个由100个最常出现在垃圾邮件中的词所构成的列表，根据这些词是否在邮件中出现来获得我们的特征向量（出现为1，不出现为0），尺寸为100×1。
如何在有限的时间内让我们的垃圾分类器具有高精准度和低错误率？
1. 收集更多的数据，让我们有更多的垃圾邮件和非垃圾邮件样本；
2. 通过邮件的标题来构建一个基于邮件的路由信息的更为复杂的特征，来捕捉到邮件信息的来源并以此来判断邮件是否垃圾邮件；
3. 对邮件的主体部分构建更为复杂的特征（例如，单词“discount”和“discounts”是否应该被视为同一单词，或者是否应该把“deal”和“dealer”视为同一个单词，在这个例子中也可以关注单词首字母的大小写或者通过标点符号来构建复杂的特征）；
4. 为了检测故意出现的拼写错误构建更复杂的算法，例如，“m0rtgage”、“med1cine”、“w4tches”。
在上面这些选项中，我们通常很难决定应该在哪一项上花费时间和精力，但作出明智的选择比随着感觉走要更好。
2. 误差分析 如果我们准备研究机器学习的东西，或者构造机器学习应用程序，构建一个学习算法的推荐方法为：
1. 通过一个简单的算法来快速实现它，而不是设计一个很复杂的系统，即使这个速成的东西不是很完美，然后使用交叉验证集来测试数据；
2. 通过画出相应的学习曲线以及检验误差来找出我们的算法是否有高偏差和高方差的问题或者别的问题，在做出这些分析之后，再来决定是否使用更多的数据训练或者加入更多的特征变量等等。
3. 误差分析：实现比如一个垃圾邮件分类器的时候，人工观察交叉验证集的情况，看一看哪些邮件被算法错误的分类。通过查看这些被错误分类的垃圾邮件和非垃圾邮件，找出经常被错误分类的邮件的共同特征和规律。
总结：
面对实际的机器学习问题，首先要快速选择一个模型并实现它。然后在模型的基础上根据学习曲线和检验误差去优化模型，提高模型泛化能力。最后深入了解和考虑出现问题导致误差的实际原因，提出、验证和改进学习模型。 3. 偏斜类的误差度量 设定某个实数来评价我们的学习算法并衡量它的表现，有了算法的评估和误差度量值后，要注意的是使用一个合适的误差度量值有时会对于我们的学习算法造成非常微妙的影响，这就是偏斜类的问题。
在癌症分类例子中，我们训练Logistic回归模型（ y = 1 y=1 y=1为癌症， y = 0 y=0 y=0为其他），假设使用测试集来检验这个分类模型，发现它只有1%的错误，因此我们99%会做出正确的诊断，这看起来是一个不错的结果。但假设我们发现在测试集中只有0.5%的患者真正患了癌症，那么1%的错误率就不显得那么好了。
function predictCancer(x): return y=0; 上述代码忽略了 x x x，让 y y y总是等于0，因此它总是预测没有人得癌症，这个算法只有0.5%的错误率，甚至比我们之前的得到的1%的错误率更好。这是一个非机器学习的算法，只是预测 y y y总是等于0，这种情况发生在训练集中有非常多的同一种类的样本且只有很少或没有其他类的样本，把这种情况称为偏斜类。
偏斜类：一个类中的样本数与另一个类的样本数相比多很多，通过总是预测 y = 0 y=0 y=0或 y = 1 y=1 y=1，算法可能表现得非常好，因此使用分类误差或者分类精确度来作为评估度量会产生问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8497c868c2520424be7507daceed1eb5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a746825bcf615e760050f192d23a9236/" rel="bookmark">
			Game101现代计算机图形学作业1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Game101现代计算机图形学作业1 一、作业描述二、解决方法一、模型变换二、 投影变换绕任意轴旋转 三、总结四、参考和引用 一、作业描述 给定三维下三个点 v 0 ( 2.0 , 0.0 , − 2.0 ) v_0(2.0,0.0,-2.0) v0​(2.0,0.0,−2.0)、 v 1 ( 0.0 , 2.0 , − 2.0 ) v_1(0.0,2.0,-2.0) v1​(0.0,2.0,−2.0)、 v 2 ( − 2.0 , 0.0 , − 2.0 ) v_2(-2.0,0.0,-2.0) v2​(−2.0,0.0,−2.0)，你需要将三个点坐标变换为屏幕坐标并在屏幕上绘制出对应的线框三角形。
1、实现模型变换和投影变换。
2、实现绕任意轴的旋转（可选）。
get_model_matrix(float rotation_angle)：逐个元素地构建模型变换矩阵并返回该矩阵。在此函数中，你只需要实现三维中绕Z轴旋转的变换矩阵，而不用处理平移与缩放。
get_projection_matrix(float eye_fov,float aspect_ratio,float zNear,float zFar)：使用给定的参数逐个元素地构建投影矩阵并返回该矩阵。
以及自行补充所需要的操作
二、解决方法 一、模型变换 绕Z轴的变换
R z ( α ) = ( c o s ( α ) − s i n ( α ) 0 0 s i n ( α ) c o s ( α ) 0 0 0 0 1 0 0 0 0 1 ) R_z(\alpha)=\left(\begin{matrix} cos(\alpha)&amp;-sin(\alpha)&amp;0&amp;0\\ sin(\alpha)&amp;cos(\alpha)&amp;0&amp;0\\ 0&amp;0&amp;1&amp;0\\ 0&amp;0&amp;0&amp;1 \end{matrix} \right) Rz​(α)=⎝⎜⎜⎛​cos(α)sin(α)00​−sin(α)cos(α)00​0010​0001​⎠⎟⎟⎞​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a746825bcf615e760050f192d23a9236/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5d99263148df62125063e079cc803e1/" rel="bookmark">
			Tensorflow h5转pb
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Tensorflow 2 h5转pb tensorflow 2中h5转pb比较简单，加载h5模型后，使用save_model即可
from tensorflow.keras import models models.load_model('model.h5') models.save_model(model, pb_outpath) 但因为tf2推荐使用saved_model格式，实际保存的是saved_model，即1个pb文件和两个文件夹。
Tensorflow 1 h5转pb 这里使用的是keras，首先加载模型，查看输入输出
from keras.models import load_model model = load_model('./model/keras_model.h5') print(model.outputs) # [&lt;tf.Tensor 'dense_2/Softmax:0' shape=(?, 10) dtype=float32&gt;] print(model.inputs) # [&lt;tf.Tensor 'conv2d_1_input:0' shape=(?, 28, 28, 1) dtype=float32&gt;] 获取模型序列化静态计算图
from keras import backend as K import tensorflow as tf def freeze_session(session, keep_var_names=None, output_names=None, clear_devices=True): """ Freezes the state of a session into a pruned computation graph. Creates a new computation graph where variable nodes are replaced by constants taking their current value in the session.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5d99263148df62125063e079cc803e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/707153a79106837a69e572fe7f6b3f35/" rel="bookmark">
			SpringBoot集成Mail功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源码地址:https://gitee.com/lxc_5952/email-demo.git
1. 邮件介绍 1.1 邮件的作用 邮件在项目中会经常用到,例如:注册,验证,找回密码,登录,信息通知
1.2 邮件协议 SMTP协议:
SMTP全称为Simple Mail Transfer Protocol（简单邮件传输协议），它是一组用于从源地址到目的地址传输邮件的规范，通过它来控制邮件的中转方式。SMTP认证要求必须提供账号和密码才能登陆服务器，其设计目的在于避免用户受到垃圾邮件的侵扰。IMAP协议 :
IMAP全称为Internet Message Access Protocol（互联网邮件访问协议），IMAP允许从邮件服务器上获取邮件的信息、下载邮件等。IMAP与POP类似，都是一种邮件获取协议。POP3:
POP3全称为Post Office Protocol 3（邮局协议），POP3支持客户端远程管理服务器端的邮件。POP3常用于“离线”邮件处理，即允许客户端下载服务器邮件，然后服务器上的邮件将会被删除。目前很多POP3的邮件服务器只提供下载邮件功能，服务器本身并不删除邮件，这种属于改进版的POP3协议。 2. SpringBoot实现发送邮件 2.1 Spring集成了Mail邮件发送功能 Spring官方推出了一款关于Mail的JavaMailSender类,基于SpringBoot进一步封装,轻松实现邮件发送–开箱即用
而且JavaMailSender类提供了强大的邮件发送功能,支持各种邮件的发送
2.2 集成步骤 2.2.1 添加依赖 SpringBoot集成了Mail功能,只需要添加:
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt; &lt;/dependency&gt; 2.2.2 获取邮箱服务器名,邮箱授权码 这里使用QQ邮箱
1. 获取邮箱服务器 POP3服务器地址为“pop.qq.com”，SMTP服务器地址为“smtp.qq.com”
注：
SMTP服务器需要身份验证。如果是设置POP3和SMTP的SSL加密方式，则端口如下：
2.1. POP3服务器（端口995）；
2.2. SMTP服务器（端口465或587）。 2. 获取邮箱授权码 打开QQ邮箱并登录
点击邮箱设置-&gt;账户
打开POP3服务,或者IMAP服务,得到授权码
2.2.3 编辑配置文件 在application.yml/properties文件中编辑mail配置
spring: application: name: email-server mail: host: pop.qq.com #pop邮箱服务器地址 username: 872XXX033@qq.com #邮箱登录账户 password: ywaXXXXXXXXXfbi #邮箱密码/邮箱授权码 properties: from: 872XXX033@qq.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/707153a79106837a69e572fe7f6b3f35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8dab0cf502a635012917026ac64e3bcb/" rel="bookmark">
			UE4实时渲染——渲染前和遮挡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一节：UE4实时渲染需要注意的点——RTR（Real Time Rendering）
实时渲染一般由三个主要线程构成：
1、CPU线程
2、Draw线程（主要由CPU运算，部分由GPU运算）
3、GPU线程
本节主要介绍部分的CPU线程工作 ，以及Draw线程中的遮挡剔除工作。
GPU线程渲染工作将在其他节中讲述。
CPU线程： 在交给GPU渲染之前，CPU会进行大量的计算，主要计算包括：
1、动画
2、模型和对象的位置
3、物理效果
4、人工智能
5、对象的生成和销毁、显示或隐藏
但这里不多介绍这些，因为这个系列是介绍实时渲染，而不是幕后的具体逻辑运算。
Draw线程： CPU计算后，我们得到了所有对象和模型的位置，以及所有我们想要在CPU运算出来的信息，但这还不能进行渲染，因为我们不可能把所有的信息都渲染出来，这样性能是吃不消的，我们必须有选择的把必要信息渲染出来即可，那么这里就用到了一个Draw的线程（主要由CPU运算，部分由GPU运算，但这里我们假设全是CPU运算）。
Draw线程——遮挡剔除
既然提到“有选择性的”，那么就要用到遮挡剔除的相关技术来屏蔽掉那些当前帧不需要渲染的事物。
遮挡是按照对象来的，而不是按照多边形。
一般，遮挡剔除分为4个步骤：（这四个步骤通常结合使用，结合在一起使用通常会让之后的渲染更加高效），经过这4个步骤后，会类似的形成两个表，一个是可见对象的表，另一个是不可见对象的表。
1、距离剔除：
比较暴力地，将距离摄像机X距离以外的对象（你可以为，这个或这组对象设置距离剔除属性）剔除掉，但默认情况下，距离剔除是不开启的，你需要手动去开启，效果如下：
在X距离内：
在X距离外：
2、视锥体剔除：
视锥体剔除是没有办法关闭的，它时刻都是开启的。
效果如下：
（左图为Viewport，右图为摄像机视野）
我们可以清晰的从右图中看到，视锥体剔除，是以对象为单位的，而不是以多边形为单位。就算同一个对象，一部分在视锥体内，一部分在视锥体外，它也会被保留在空间中不被剔除。
3、预计算可见性：
不会在默认情况下开启，与距离剔除一样，需要手动开启。
这个功能开启后，将会将世界分割成多个3D单元网格盒（盒子大小可以调整），当camera处于某个网格盒中时，如果询问引擎哪些对象可见，引擎会将一个预计算的对象列表返回给你，告诉你在这个网格盒的位置时，哪些对象可见，哪些对象不可见。效果如下：
4、遮挡剔除：
（最精确，通常处理大部分工作，但也是放在最后的原因）
它会精确的计算每个模型的可见性状态，做法类似于遍历所有的未被先前步骤剔除的对象，类似这样：
foreach(all objects) { if(我可以看见这个对象) { 设置该对象可见 continue; } else { 设置该对象不可见 continue; } } 这也是为什么这一步，遮挡剔除，所消耗的性能很大的缘故。
（我们可以使用Freezerendering命令，来对比遮挡剔除前后的效果，Freezerendering作用，根据camera所处的位置以及遮挡效果，让世界渲染效果冻结在当前时空）
效果如下：
遮挡剔除之前
当我们把camera移动到"翅膀"这里时，我们可以看到，其实很多对象都已经不见了，所以我们也不应该渲染这些看不到的对象了，这时我们开启Freezerendering
开启Freezerendering，把camera远离翅膀后，我们可以看到一些对象，确实没有在渲染了，包括背后的对象。但有一些还在，包括外景中的树，以及右边的窗户（因为Freeze时他们确实出现在Viewport中，所以他们不能剔除掉），包括远处的山、天空、地面地形（他们太大了，如此庞大的对象，一般设置为一直渲染，不会选择剔除）
----------------------四种剔除介绍完毕-----------------
有一个命令为“stat Initviews”，有助于我们看这些剔除的工作状态，输入后可以打开这样一个界面，这个界面为我们显示，当前位置和角度的camera，剔除的相关信息：
图片看不太清，我这里列一下：
比较重要的：
Counters:
Processed Primitives：809
当前角度809个对象
Frustum Primitives：339
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8dab0cf502a635012917026ac64e3bcb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/978541ea0b1462f4120631b859416471/" rel="bookmark">
			Lua_table表_表的构造_表的操作（12）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、表的构造二、表的操作1、连接 concat2、插入和移除 insert/remove3、排序 sort4、最大值 码云代码链接 https://gitee.com/wenwenc9/lua_pro.git table 是 Lua 的一种数据结构用来帮助我们创建不同的数据类型，如：数字、字典等。
Lua table 使用关联型数组，你可以用任意类型的值来作数组的索引，但这个值不能是 nil。
Lua table 是不固定大小的，你可以根据自己需要进行扩容。
Lua也是通过table来解决模块（module）、包（package）和对象（Object）的。
例如string.format表示使用"format"来索引table string。
#table 获取表的长度 一、表的构造 构造器是创建和初始化表的表达式。表是Lua特有的功能强大的东西。最简单的构造函数是{}，用来创建一个空表。可以直接初始化数组:
-- 初始化表 mytable = {} -- 指定值 mytable[1]= "Lua" -- 移除引用 mytable = nil -- lua 垃圾回收会释放内存 构造函数可以使用任何表达式初始化
tab = {math.max(5,2),math.max(4,7)} 如果想初始化一个表作为 record 使用可以这样：
a = {x=0, y=0} &lt;–&gt; a = {}; a.x=0; a.y=0
不管用何种方式创建 table，我们都可以向表中添加或者删除任何类型的域，构造函
数仅仅影响表的初始化。
复杂构造，表中嵌套表调用
w = {x=0, y=0, label="console"} x = {math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/978541ea0b1462f4120631b859416471/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3ecaafc2a22994adf2e765ee3ddb5d4/" rel="bookmark">
			计算机上应用锁,电脑应用锁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电脑应用锁是一款简单好用的电脑应用锁软件，通过应用锁用户可以轻松的将一些不想给别人使用的软件加密，这样别人就不能打开这个软件了，同时软件还非常适合家长使用，家长可以下载软件将孩子喜欢玩的游戏全部加密，从而管理孩子的学习环境，有需要的小伙伴欢迎来西西下载体验。
软件功能：
上班的时候总会有短暂离开电脑的时候，比如上厕所，开会。有时候同事需要用我的电脑来打印东西或者填写表格。有的隐私软件如微信、钉钉肯定不希望被他人翻阅到、甚至重要的Word、Excel文件。开发了这个小工具针对单个Windows应用加了覆盖窗口，等自己回来控制电脑后输入密码自动解锁，还是很方便的，有需要的可以下载试试。
软件界面：选择其他应用输入进程名称，就是任务管理器里看到的那个，不需要.exe后缀，不区分大小写，都可以。
使用方法：
一、下载打卡软件，软件可以快速锁定QQ、微信、钉钉。
二、当然也支持用户自己选择要锁定的程序，输入程序名和密码即可。
三、然后下次要打开软件必须要输入密码才可以。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21668ecd670d0eb1a46589e078394fdd/" rel="bookmark">
			计算机上应用锁,电脑怎么设置软件锁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题主，针对这个问题有两个解决方案：
一：设立两个账户
先创建一个用户，右键计算机，点管理
在弹出的对话框选择用户和组，选择用户
右键空白地方新建用户，设置密码等选项，新建完成关闭对话框
找到软件快捷方式或者软件图标，右键图标，选择属性
在跳出的对话框选择安全，再选择编辑
把除了管理员(administrator)的用户全部删掉，然后应用确定
之后注销用户，重新登录电脑选择新建的那个用户，就打不开设置权限的软件了
步骤有点多，请仔细核对哦!!!
二：给文件夹加密
由于软件不能直接加密，所以只能给文件夹加密，然后把软件安装到加密文件夹里
打开Windows资源管理器，右键单击要加密的文件或文件夹，然后单击“属性”
在“常规”选项卡上，单击“高级”。选中“加密内容以便保护数据”复选框
在加密过程中还要注意以下五点：
要打开“Windows 资源管理器”，请单击“开始→程序→附件”，然后单击“Windows 资源管理器”。
只可以加密NTFS分区卷上的文件和文件夹，FAT分区卷上的文件和文件夹无效。(注意重装系统时先解密，否则后果严重。)
被压缩的文件或文件夹也可以加密。如果要加密一个压缩文件或文件夹，则该文件或文件夹将会被解压。
无法加密标记为“系统”属性的文件，并且位于systemroot目录结构中的文件也无法加密。
在加密文件夹时，系统将询问是否要同时加密它的子文件夹。如果选择是，那它的子文件夹也会被加密，以后所有添加进文件夹中的文件和子文件夹都将在添加时自动加密。
二、解密文件或文件夹
打开Windows资源管理器。
右键单击加密文件或文件夹，然后单击“属性”。
在“常规”选项卡上，单击“高级”。
清除“加密内容以便保护数据”复选框。
同样，我们在使用解密过程中要注意以下问题：
要打开“Windows资源管理器”，请单击“开始→程序→附件”，然后单击“Windows资源管理器”。
在对文件夹解密时，系统将询问是否要同时将文件夹内的所有文件和子文件夹解密。如果选择仅解密文件夹，则在要解密文件夹中的加密文件和子文件夹仍保持加密。但是，在已解密文件夹内创立的新文件和文件夹将不会被自动加密。
以上就是使用文件加、解密的方法!
ps：加密后还是可以删除的，不过可以隐藏掉你加密的文件。这种方法比较复杂，所以推荐第一种方案。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cfd8bed2a8b0cb9a10eca93a5b2a371/" rel="bookmark">
			excel如何调取不在功能区中的命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何调取不在功能区中的命令
文件-&gt;选项-&gt;自定义功能区-&gt;左侧：不在功能区中的命令
右侧：新建组（重命名）-&gt;添加
自文本
自web
自Access
旧版功能
2019没有
2016自带
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b72d3297443ed1ebe715388e35862c2c/" rel="bookmark">
			Oracle的卸载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		|- 停止掉所有的 oracle 数据库服务；
|- 启动 oracle 的卸载程序；
|- 卸载完成之后有可能数据库会出现一些残留的系统文件和注册表文件，但是这些文件在正常运行操作系统的时候是无法被删除的，所以必须重新启动电脑，进入到安全模式（开机 F8）；
|- 清理掉所有的 oracle 残留文件，同时运行“regedit.exe”进入到注册表之中，手工搜索所有与 oracle 有关的项， 并且进行删除；
情况二：安装半截 OVER 了。
|- 此时卸载程序已经无法被使用了，那么只能够直接进行文件的删除；
|- 重新启动电脑，进入到安全模式（开机 F8）；
|- 清理掉所有的 oracle 残留文件，同时运行“regedit.exe”进入到注册表之中，手工搜索所有与 oracle 有关的项， 并且进行删除；
还有一招最终极的卸载 Oracle 系统方式：重新做一个操作系统。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80dd5f1304332ad7709799d33ad564fc/" rel="bookmark">
			浅析FPGA局部动态可重构技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 浅析FPGA局部动态可重构技术
所谓FPGA动态可重构技术，就是要对基于SRAM编程技术的FPGA实现全部或部分逻辑资源的动态功能变换。根据实现重构的面积不同，动态可重构技术又可分为全局重构和局部重构。
1、何为局部动态可重构
局部动态可重构可以简单的理解为通过下载局部分区bit 文件来动态修改对应分区的逻辑功能，同时其余分区的逻辑功能持续运行而不中断。
2、局部动态可重构技术的优势
a、系统灵活性：可以在保持通信连接的同时执行更多的系统功能；
b、降低FPGA资源和成本：通过分时复用的方式降低FPGA硬件尺寸；
c、降低功耗：通过卸载掉暂时不用的局部逻辑的方式降低FPGA功耗；
3、 FPGA局部动态重构流程
a、规划系统整体框架和可重构模块框架，编写各模块HDL代码，综合生成各子模块网表文件；
b、规划分区以及给各分区分配足够资源，创建各分区及静态部分的时序约束文件，执行DRC检查；
c、对各分区进行布局布线配置；
d、遍历各种可能的配置，编译生成全局bit文件和可重构模块的局部bit文件。
4、局部动态可重构的时序问题
如上图所示，局部重构会带来时序路径的变化，使得局部可重构工程的时序约束问题变得更加复杂。
解决方法：在静态逻辑和可重构模块间的信号传递路径上添加代理逻辑点，如下图红色数字点，将单条时序路径分割为两个独立的部分，然后分别对两部分的路径进行单独约束，以达到时序要求。
- END -
ＮＯＷ现在行动！ 推荐阅读 【Vivado那些事】如何查找官网例程及如何使用官网例程【Vivado使用误区与进阶】总结篇【Vivado那些事】Vivado中常用的快捷键（二）其他常用快捷键SystemVerilog数字系统设计_夏宇闻 PDFVerilog 里面，always，assign和always@(*)区别图书推荐|ARM Cortex-M0 全可编程SoC原理及实现 简谈：如何学习FPGA拆解1968年的美国军用电脑，真的怀疑是“穿越”啊！高级FPGA设计技巧！多时钟域和异步信号处理解决方案现代计算机的雏形-微型计算机MCS-4AD9361 和Zynq及其参考设计说明1202年了，还在使用虚拟机吗？Win10安装Ubuntu子系统及图形化界面详细教程谈谈Xilinx FPGA设计的实现过程 Github 上有哪些优秀的 VHDL/Verilog/FPGA 项目 AD936x+ZYNQ搭建收音机（一） AD936x+ZYNQ搭建收音机（二）含视频演示 AD936x+ZYNQ搭建收音机（三）-终篇 AD936x+ZYNQ搭建OpenWIFI Verilog 版本：Verilog-95、Verilog-2001与System Verilog区别简谈 FPGA时钟设计方案无招胜有招-Vivado非工程模式下的详细设计 追寻ARM的起源-Acorn电脑简史及FPGA实现 面试中经常会遇到的FPGA基本概念，你会几个？ Xilinx FPGA MIPI 接口简单说明 介绍一些新手入门FPGA的优秀网站 Vivado ML（机器学习） 2021尝鲜 推荐一些可以获取免费的国外的原版书籍（电子版）网站 【Vivado那些事】FPGA的配置方式 FPGA 的重构 点击上方字体即可跳转阅读 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2aa0b43ce917333c9d156f5344092dba/" rel="bookmark">
			计算机服务和应用程序在哪里设置密码,Win10系统如何设置安装软件和运行程序都需要输入密码？...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了防止别人随意的使用自己电脑，比如电脑中有隐私文件，绝大数的用户都会选择设置开机密码，如果想要进入系统桌面中，必须要输入密码才行。同样，为了不让他人在电脑安装软件或运行电脑上的程序，我们也可以设置需要输入密码才可以打开。Win10系统如何设置安装软件和运行程序都需要输入密码？下面装机之家小编来科普一下。
1、按下Win+R组合键打开运行窗口，输入gpedit.msc，点击确定打开本地组策略编辑器；
2、在打开的窗口中，依次展开到“计算机配置--Windows设置--安全设置--本地策略--安全选项”，在右侧找到“用户账户控制：管理员批准模式中管理员的提升权限提示的行为”；
3、双击打开它，在打开的属性窗口中，在下拉选项中点击选择“提示凭据”，确定即可；
4、完成设置后，打开软件时就会提示输入密码，前提是当前账户设置有开机密码。
以上就是装机之家提供的Win10系统设置安装软件和运行程序都需要输入密码的方法，小编亲测有效，希望可以帮助到广大网友。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82df53b6fc2e546a4e580fe801972458/" rel="bookmark">
			时间序列数据处理2——时间序列聚类算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要实现对时间序列聚类算法研究和相关搬运工作。
目录 1. 时间序列(Time Series,TS)聚类概述2. TS聚类应用2.1 数据简化2.2 相似性/距离度量2.3 聚类方法2.4 评估聚类结果的标准 3. TS特征提取4. 相似性度量——DTW（动态时间规整）5. k-shape时间序列聚类实战(tslearn)参考资料 1. 时间序列(Time Series,TS)聚类概述 时间序列：
时间序列是按照时间排序的一组随机变量，它通常是在相等间隔的时间段内，依照给定的采样率，对某种潜在过程进行观测的结果。是指将同一统计指标的数值按其发生的时间先后顺序排列而成的数列，其中隐藏着一些过去与未来的关系。
时间序列分析试图通过研究过去来预测未来。
时间序列数据是实值型的序列数据，具有数据量大、数据维度高以及数据是不断更新的等特点，高度异质性，即包含噪声、缺失值、异常值，长度、采样率、变化速率不一，不能简单地视为高维向量，传统的基于欧式空间的聚类算法不能被直接利用。。
时间序列聚类方法的分类：
什么是聚类？聚类是一种无监督学习方法，聚类就是按照某个特定标准(如距离)把一个数据集分割成不同的类或簇，使类内差异最小，类间差异最大。其目的是根据某种相似度度量对数据集进行划分，将没有类别的数据样本划分成若干个不同的子集，这样的一个子集称为簇（cluster)，聚类使得同一个簇中的数据对象彼此相似，不同簇中的数据对象彼此不同，即通常所说的“物以类聚”。
传统的聚类方法针对静态数据，所谓静态数据就是其特征不随时间变化。
由于时间序列的特征包含随时间变化的值，所以不是静态数据。
对于时间序列的聚类来说，有两种思路：
一种是修改现有的聚类方法以适用于时间序列一种是将时间序列转换为静态数据，然后在使用现有的聚类方法 前一种思路直接作用于原始数据，称为基于原始数据的方法，难点在于要找到适用于时间序列的距离/相似性度量。
第二种思路首先将原始的时间序列数据转换为低维的特征向量或若干模型参数，称为基于特征的或基于模型的方法。
基于模型的方法认为相似的时间序列应该产生相似的模型，所以通过比较模型之间的相似性可以达到时间序列聚类的目的。困难在与模型选择和参数确定两个问题。常用的模型：
ARMA模型HMM模型马尔科夫链 基于特征提取的聚类主要应用于高维时间序列，特别是高频金融时间序列，经过特征提取后可有效降维。针对时间序列的数学特性。对时间序列进行特征提取，用提取的特征项对时间序列进行时间序列的重新描述，然后对重新描述的时间序列聚类。
现有的聚类方法大致可以分为以下三类：
基于统计的聚类
这类方法从时序数据中抽取统计特征，如平均值、方差、倾斜度，以及一些高阶特征等，如ARIMA模型的系数、分形度量（fractal measures）等。或是划分窗口，在每个窗口内计算这些统计特征，再进行汇总。
基于形状的聚类
许多时序数据往往具有相同的变化模式（如上升、下降、上升等），因此可以根据这些时序数据的形状相似性将变化模式相似的序列聚在同一个类，可以忽略数据在整幅、时间尺度等的差异。
一些人工定义的距离（如DTW）具有尺度和平移不变性，因此被广泛用于基于形状的聚类。由于人工定义的距离是数据无关的，方便利用到各种领域的数据上，一个研究方向是定义新的距离度量，然后结合一个现成的聚类算法(k-means或层次化聚类等)。
这类方法中最先进的是[1], 该方法利用现有的距离度量的特性（scale-, translate-, and shift-invariant），提出了一种计算聚类中心的算法。
现有方法主要有两方面的缺点：
（1）时间复杂度高；
（2）易受到异常值、噪声的干扰
另一类是基于shapelets的方法[2,3]，shapelets即一些短的序列，这些序列能够体现出整条序列的局部变化模式。
基于形状的聚类方法基本都有开源实现，python包tslearn中基本都包含了。
基于深度学习的聚类
该类方法主要基于autoencoder模型将时序数据转换为低维的隐空间，现有的变分自编码器（variational autoencoder）等虽然能够在一定程度上容忍噪声、异常值等。但目前存在两方面的不足：
缺乏一种通用的方法来捕获时序数据的特性，从而得到有效的隐空间。
在得到的隐空间中需要一种合适的相似性度量考虑时间上的特性。
目前最先进的方法是[4]，该方法同时训练一个autoencoder和k-mean（基于KL散度的loss）。autoencoder模型中先用1D卷积，然后接一个双向的LSTM，因此考虑了时序数据的局部和时间上的特征，但这也是时序数据常用的处理套路。
目前基于静态数据（向量数据）的聚类算法也有一定的发展，主要可分为以下几类：
（1）联合优化stacked autoencoder和k-means目标[5-7]。其中k-mean目标是基于KL散度计算的。(论文[6]和[7]貌似发生了撞车 )
（2）将变分自编码器（VAE）和高斯混合模型（K个聚类对应K个高斯分量）结合[8]。
(3) 同时训练K个autoencoders，每条数据根据哪个autoencoder得到的重建误差最小，该数据就属于哪个类[9,10]。(论文[9]和[10]貌似也发生了撞车 )
总结：基于深度学习的时序数据聚类还有较大的发展空间，目前基于静态数据的方法不能很好的考虑到时间序列在时间上的平移、伸缩等特性。
更多信息见参考资料6.
2. TS聚类应用 如果关注不同序列在统计特性上的差异，那么可以提取时序的统计特征，基于提取的统计等特征进行计算欧式距离的KMeans的聚类，如果关注形状的相似，那么可以使用执行SBD计算距离的k-shape聚类。另外，如果想要捕捉时序的动态特性，也是可以使用深度学习的seq2seq对隐式向量进行聚类。
聚类的步骤：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82df53b6fc2e546a4e580fe801972458/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3b8630660a62713ad4b83f6ccb3d74c/" rel="bookmark">
			计算机音乐数字乐谱fade,Faded钢琴简谱-数字双手-Alan Walker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Faded钢琴简谱歌词
You were the shadow to my light
Did you feel us
Another start
You fade away
Afraid our aim is out of sight
Wanna see us
Alive
Where are you now
Where are you now
Where are you now
Was it all in my fantasy
Where are you now
Were you only imaginary
Where are you now
Atlantis
Under the sea
Under the sea
Where are you now
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3b8630660a62713ad4b83f6ccb3d74c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea5b73463c5845d493bd4e79ca4f4262/" rel="bookmark">
			计算机音乐数字乐谱大全追光者,追光者歌谱
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《追光者》是岑宁儿演唱的歌曲，由唐恬作词，马敬作曲，是电视剧《夏至未至》的插曲 ，收录于2017年6月19日发行的原声专辑《夏至未至·听见青春》中 ，后收录于2017年12月12日发行的现场专辑《Live at Blue Note Beijing》中 。
2018年1月17日，该曲获得硬地围炉夜·2017网易云音乐原创盛典年度影视单曲奖 。3月26日，该曲获得第25届东方风云榜动感101年度金曲奖 。
创作背景
《追光者》是《夏至未至》中司夏的主题歌，也是立夏的人物曲 。该歌曲是以剧中的女主角立夏和男主角傅小司(画家祭司)的感情为主题而创作的，讲述了立夏对傅小司心底里默默的崇拜之情 。
岑宁儿是接到电视剧《夏至未至》的制片人邀请而决定演唱该曲的 ，岑宁儿在收到歌时表示，她跟身边的工作人员都觉得歌曲尤其是副歌部分，非常具有洗脑性，让人很快能记住 。该歌曲还邀请到作词人唐恬来为歌曲创作歌词，歌词细腻地表达出了女孩的心声 。
歌曲歌词
如果说
你是海上的烟火
我是浪花的泡沫
某一刻
你的光照亮了我
如果说
你是遥远的星河
耀眼得让人想哭
我是追逐着你的眼眸
总在孤单时候眺望夜空
我可以跟在你身后
像影子追着光梦游
我可以等在这路口
不管你会不会经过
每当我为你抬起头
连眼泪都觉得自由
有的爱像阳光倾落
边拥有边失去着
如果说
你是夏夜的萤火
孩子们为你唱歌
那么我
是想要画你的手
你看我
多么渺小一个我
因为你有梦可做
也许你不会为我停留
那就让我站在你的背后
我可以跟在你身后
像影子追着光梦游
我可以等在这路口
不管你会不会经过
每当我为你抬起头
连眼泪都觉得自由
有的爱像大雨滂沱
却依然相信彩虹
我可以跟在你身后
像影子追着光梦游
我可以等在这路口
不管你会不会经过
每当我为你抬起头
连眼泪都觉得自由
有的爱像大雨滂沱
却依然相信彩虹
歌曲鉴赏
《追光者》干净舒缓，歌词直戳心意 。岑宁儿的演唱温暖而有治愈感 ，她细腻地唱出剧中角色立夏面对爱情委婉又小心翼翼的模样，诠释了这首歌盛满纯真的感觉 ，唱出了一段有爱的崇拜却从不卑微的难言爱恋，能让听众不自觉地陷入对青春往事的回忆之中 ，也表达出了所有女孩的心声 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea5b73463c5845d493bd4e79ca4f4262/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee5203f7ca279de0872c6685f70dbedb/" rel="bookmark">
			C语言 简单的学生信息管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		输入n并输入n(n&lt;=100)个学生的信息(学号、姓名、成绩)，存入数组,用结构数组编程解决问题。
(1）排序：按照从高分到低分的顺序输出他们的信息；
（2）查询：能按学号查询某个学生的成绩；
（3）添加：能添加一个学生的信息（(学号、姓名、成绩；
（4）删除：能删除一个指定学号的学生信息。
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; typedef struct _student { char name[20]; int nid; float score; }student; student stu[100]; int n; void sort() { int i,j; for(i=0;i&lt;n-1;i++) for(j=0;j&lt;n-i-1;j++) { if(stu[j].score &lt; stu[j+1].score) { student a = stu[j]; stu[j] = stu[j+1]; stu[j+1] = a; } } printf("%10s%20s%10s\n","学号","姓名","成绩"); for(i=0;i&lt;n;i++) printf("%10d%20s%10g\n",stu[i].nid,stu[i].name,stu[i].score); } void query() { int id; scanf("%d",&amp;id); for(int i=0;i&lt;n;i++) { if(stu[i].nid == id) { printf("学号:%d\n",stu[i].nid); printf("姓名:%s\n",stu[i].name); printf("成绩:%g\n",stu[i].score); return; } } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee5203f7ca279de0872c6685f70dbedb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2296b2576022f40de923caec669810a0/" rel="bookmark">
			利用GEE（Google Earth Engine）在线处理NDVI、EVI、SAVI、NDMI等指数归一化教程！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.首先进行“去云”函数的准备
//landsat5、7 EVI指数计算 // SR数据去云 function rmCloud(image) { var cloudShadowBitMask = (1 &lt;&lt; 3); var cloudsBitMask = (1 &lt;&lt; 5); var qa = image.select("pixel_qa"); var mask = qa.bitwiseAnd(cloudShadowBitMask).eq(0) .and(qa.bitwiseAnd(cloudsBitMask).eq(0)); return image.updateMask(mask); } 以上这一步都是最简单的操作，对于处理landsat-sr系列数据都基本用到。
2.数据的选择
//这是我自己的行政矢量边界，这回用的是山西省界 var hh= ee.FeatureCollection("users/bqt2000204051/shanxijie"); //这部分代码是进行数据的选择和EVI指数的遍历计算，我进行的是年统计 var image= ee.ImageCollection("LANDSAT/LT05/C01/T1_SR") .filterBounds(hh) .filterDate("1986-1-1","1987-1-1") .map(rmCloud) .map(function(image) { var evi = image.expression( '2.5 * ((NIR - RED) / (NIR + 6 * RED - 7.5 * BLUE + 1))', { 'NIR': image.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2296b2576022f40de923caec669810a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad29f19036837371f43977cf139a9ccd/" rel="bookmark">
			数据结构期末复习-哈希表的6种构造方法和4种解决冲突方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 哈希表的概念哈希表散列法存储的基本思想优点缺点哈希方法(杂凑法)哈希函数(杂凑函数)哈希表(杂凑表)冲突哈希方法必须解决以下两个问题构造好的哈希函数制定一个好的解决冲突的方案 哈希函数的构造方法直接定址法Hash(key)=a * key+b (a、b为常数)优点缺点举例 除留余数法Hash(key)=key mod p (p是一个整数)特点关键技巧 数字分析法特点举例 平方取中法特点理由例 折叠法特点适用于移位法间界叠加法举例 随机数法Hash(key)=random(key) (random为随机函数)适用于 构造哈希函数的原则 解决冲突的方法开放定址法设计思路1.线性探测法Hi=(Hash(key)+di) mod m ( 1≤i &lt; m )举例线性探测法的优点线性探测法的缺点 二次探测法伪随机探测法 链地址法(拉链法)基本思想举例 再哈希法(双哈希函数法)优点缺点 建立公共溢出区思路 冲突是不是比较讨厌 哈希表的查找效率分析几点结论 哈希表的概念 哈希表 即散列存储结构
散列法存储的基本思想 建立关键码字与其存储位置的对应关系，或者说，由关键码的值决定数据的存储地址
优点 查找速度极快 (O(1)) ,查找效率与元素个数n无关！
缺点 空间效率低
哈希方法(杂凑法) 选取某个函数，依该函数按关键字计算元素的存储位置，并按此存放；查找时，由同一个函数对给定值k计算地址，将k与地址单元中元素关键码进行比，确定查找是否成功。
哈希函数(杂凑函数) 哈希方法中使用的转换函数称为哈希函数(杂凑函数)
哈希表(杂凑表) 按上述思想构造的表称为哈希表(杂凑表)
冲突 通常关键码的集合比哈希地址集合大得多，因而经过哈希函数变换后，可能将不同的关键码映射到同一个哈希地址上，这种现象称为冲突。
哈希方法必须解决以下两个问题 构造好的哈希函数 所选函数尽可能简单，以便提高转换速度；所选函数对关键码计算出的地址，应在哈希地址集中大致均匀分布，以减少空间浪费。 制定一个好的解决冲突的方案 查找时，如果从哈希函数计算出的地址中查不到关键码，则应当依据解决冲突的规则，有规律地查询其它相关单元。
哈希函数的构造方法 直接定址法 Hash(key)=a * key+b (a、b为常数) 优点 以关键码key的某个线性函数值为哈希地址，不会产生冲突.
缺点 要占用连续地址空间，空间效率低。
举例 除留余数法 Hash(key)=key mod p (p是一个整数) 特点 以关键码除以p的余数作为哈希地址。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad29f19036837371f43977cf139a9ccd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04d066c6827f265c2fade5a92685ec64/" rel="bookmark">
			Beyond Compare比较相同文件时仍显示红色 - 设置方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Beyond Compare比较相同文件时仍显示红色，是因为文件时间戳不同，把时间戳选项关掉即可，步骤如下：
会话
会话设置
比较
（1）将【比较时间戳】和【比较文件大小】前面的对勾去掉
（2）将【比较内容】前面对勾选中，并选择【二进制比较】
（3）最下面的下拉菜单选择【也更新会话默认值】
此时Beyond Compare就只会比较文件内容了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31e696e628ab7a1a5530e6ef8a82cc79/" rel="bookmark">
			SNMP学习笔记之SNMP TRAP简介、流程以及使用Python实现接受Trap信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：https://www.cnblogs.com/JetpropelledSnake/p/9870336.html
推荐看作者这个SNMP专栏：https://www.cnblogs.com/JetpropelledSnake/category/1326577.html
阅读目录
0x00 SNMP TRAP简介0x01 SNMP TRAP流程0x02 SNMP Trap接受用Python实现 0x00 SNMP TRAP简介 SNMP(Simple Network Management Protocol) trap是一种很有用，但是也容易让人难以理解的协议。
虽然名字叫做简单网络管理协议，但实际上并不是字面上的意思，尤其是看到.1.3.6.1.2.1.1.1.0这样一串串诡异的数字时候，就会有点让人崩溃。
不管怎么说，现在所有的网络设备的都需要支持SNMP。而且现在还有很多的开源的网络管理系统，所以就有利于我们来学习和理解SNMP。
SNMP trap是由被管理的设备主动的向管理服务器发送设备的异常情况，可以看成是管理服务器被动的去接收的过程。
所以会有很多的工具会把snmptrap集成到自己的工具中，对网络设备进行监控。
把SNMP trap集成的到Nagios当中的，大体的工作流程是：
1. 由snmptrapd来接收网络设备发出的trap
2. snmptrapd调用snmptt(snmp trap translator 翻译器)
3. snmptt中定义了每一种trap的级别，以及什么样的trap才有必要写入到syslog中
4. SEC(simple event correlator是一个事件收集器)从syslog中读取每一个事件，并把调用用户的脚本snmptraphandling.py 来处理。
5. snmptraphandling.py 会调用根据主机名和trap的级别来调用相当的Nagios命令行。
这个过程包含了很多层，所以感觉很复杂，还是深入进去看看snmptrapd是怎么工作的。从而尽可能简化snmptrap的使用方法。
snmptrapd来自开源软件Net-SNMP. Net-SNMP会有很多的用途，当然使用trap也是一个很有用的用途。当snmptrapd接收到trap以后，可以调用用户自定义的脚本或者命令行来处理trap。如果想使用这个功能就需要在snmptrapd的配置文件中设置traphandle。 snmptrapd接收到的trap信息格式是：
1. 数据包来源的主机名字。
2. 数据包来源的ip地址。
3. 数据包中的内容。
traphandle的工作就是读取这些内容并进行处理就可以了。
Trap信息例子：
cisco2611.lon.altinity 192.168.10.20 RFC1213-MIB::sysUpTime.0 0:18:14:45.66 SNMPv2-MIB::snmpTrapOID.0 IF-MIB::linkDown RFC1213-MIB::ifIndex.2 2 RFC1213-MIB::ifDescr.2 "Serial0/0" RFC1213-MIB::ifType.2 ppp OLD-CISCO-INTERFACES-MIB::locIfReason.2 "administratively down" SNMP-COMMUNITY-MIB::snmpTrapAddress.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31e696e628ab7a1a5530e6ef8a82cc79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb557ac4a2809496a90471d70bf4d9fb/" rel="bookmark">
			1028：字符菱形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1028：字符菱形 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】
给定一个字符，用它构造一个对角线长5个字符，倾斜放置的菱形。 【输入】
输入只有一行， 包含一个字符。 【输出】
该字符构成的菱形。 【输入样例】
* 【输出样例】
说明：
本题与《1004：字符三角形》类似，可以点击查看。
思路分析：
注意是使用字符变量来构造菱形，意思就是输入一个字符（例如*、#、&amp;等），而不是规定用星号（*）来构造，题目只是给出一个样例罢了。
菱形共5行，每一行的星号数目分别是1、3、5、3、1。
而第1、5行除了一个星号外，星号的左边还有两个空格，第2、4行星号的左边各有1个空格，第3行没有空格。
求解过程：
声明一个字符变量。 输入一个字符赋给变量。 以该字符变量来构造菱形，即输出菱形。 参考代码 - C++：
#include &lt;iostream&gt; using namespace std; int main() { char c; cin &gt;&gt; c; cout &lt;&lt; " " &lt;&lt; c &lt;&lt; endl; cout &lt;&lt; " " &lt;&lt; c &lt;&lt; c &lt;&lt; c &lt;&lt; endl; cout &lt;&lt; c &lt;&lt; c &lt;&lt; c &lt;&lt; c &lt;&lt; c &lt;&lt; endl; cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb557ac4a2809496a90471d70bf4d9fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfb62c81d853b2629165f829565e261b/" rel="bookmark">
			vue弹窗点击进入之后想让他立即执行某个方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先监听dialog.show的值(图上的n代表的就是diao.show的值),打开则调用getList()方法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8123a6a47b0fb7743b16885c912b1ade/" rel="bookmark">
			补码一位除法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		补码一位除法（加减交替法）的运算规则 运算规则
①符号位参加运算，除数和被除数均用双符号位补码表示；
②第一步的运算
被除数与除数同号，被除数减去除数；
被除数与除数异号，被除数加上除数；
③后续步骤的运算
余数与除数同号，商上1，余数左移一位减去除数；
余数与除数异号，商上0，余数左移一位加上除数。 重复步骤③ ，包括符号位在内，共做n＋1步。
如果对商的精度没有特殊要求，一般可采用“末位恒置1”法，此法操作简单，易于实现，且最大误差仅为2-n 。
例题：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33ca9d7412bff85ec18b9117cd75c494/" rel="bookmark">
			原码一位除法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原码一位除法包括 恢复余数法 和 不恢复余数法（加减交替法） 恢复余数法运算规则：
余数 Ri＞0 上商 “1”， Ri+1 = 2Ri – |y|
余数 Ri＜0 上商 “0”， Ri + |y| 恢复余数
Ri+1 = 2( Ri+|y|) – |y| = 2Ri + |y|
不恢复余数法运算规则：
上商“1” 2Ri – |y| 上商“0” 2Ri + |y| 加减交替
原码一位除法-恢复余数法 运算规则：
①被除数（或余数）的绝对值减去除数的绝对值；
机器内部用补码的加法运算实现 ＋[－|Y|]补
②判别余数正负：
若为正数，上商1；
若为负数，上商0，并恢复余数； ＋[|Y|]补
③余数和商共同左移一位；
下次减除数，按低位对齐；
例题：
原码一位除法-不恢复余数法(加减交替法) 运算规则： ①符号位不参加运算，取双符号位；
② 用被除数减去除数： 当余数为正时，商上1，余数左移一位，再减去除数；
当余数为负时，商上0，余数左移一位，再加上除数。 ③根据余数的正负，再做如上处理（上商、加减除数） ④当第n+1步余数为负时，需加上|Y|得到第n+1步正确的余 数，最后余数为Rn×2-n（余数与被除数同号）。
例题：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1c02ef266745cab414ae48e4f5c93f6/" rel="bookmark">
			补码一位乘法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以定点小数为例
设被乘数[x]补 = x0 . x1x2 … xn ，乘数[y]补 = y0 . y1y2 … yn
若被乘数任意，乘数为正
统一的补码乘法公式
[xy]补 = [x]补 （0. y1y2 … yn ）+ [-x]补 ● y0
——乘数[y]补，去掉符号位，操作同 ① ；
——运算完成后，需对结果加[–x]补校正；
公式为： [xy]补 = [x]补 （0. y1y2 … yn ）+ [-x]补
例题1：
例题2：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/887114cde06f970ef3c05770184a3d0b/" rel="bookmark">
			openCV实战（一）：rectangle函数使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		rectangle函数使用 rect类Rect对象的定义： rectangle函数连续绘制多个矩形 rect类 Rect对象的定义： typedef Rect_&lt;int&gt; Rect; 再看Rect_的定义：
/*! The 2D up-right rectangle class The class represents a 2D rectangle with coordinates of the specified data type. Normally, cv::Rect ~ cv::Rect_&lt;int&gt; is used. */ template&lt;typename _Tp&gt; class Rect_ { public: typedef _Tp value_type; //! various constructors Rect_(); Rect_(_Tp _x, _Tp _y, _Tp _width, _Tp _height); Rect_(const Rect_&amp; r); Rect_(const CvRect&amp; r); Rect_(const Point_&lt;_Tp&gt;&amp; org, const Size_&lt;_Tp&gt;&amp; sz); Rect_(const Point_&lt;_Tp&gt;&amp; pt1, const Point_&lt;_Tp&gt;&amp; pt2); Rect_&amp; operator = ( const Rect_&amp; r ); //!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/887114cde06f970ef3c05770184a3d0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd93723f8f9e40a4166ec483d80f900c/" rel="bookmark">
			linux系统定时任务，看完这一篇就够了。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何在linux中增加定时任务 本片博客主要介绍linux下增加定时任务，定时启动/关闭tomcat。
直接上操作：
crontab -e 弹出空白编辑框
将下边的内容编辑进去：
0 23 */1 * * /data/apache-tomcat-9.0.46/bin/shutdown.sh
0 7 */1 * * /data /apache-tomcat-9.0.46/bin/startup.sh
编辑完成按ESC键，再按shift + ： ， 输入wq保存文件
查看：/var/spool/cron 目录下以用户名命名的文件权限，如果只有rw重新chomd最大权限
root文件是什么？
使用root用户增加定时后就会生成一个root文件。如果使用其他用户就会生成一个与该用户名相同的文件。
crontab -r 删除所有的定时任务
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c81418724479dbe45010877789df941/" rel="bookmark">
			计算机桌面如何分区,讲解电脑如何分区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电脑是根据指令进行数据处理的电子设备，应用领域广泛，可以进行逻辑运算，信息管理，辅助技术，多媒体应用，计算机网络等。下面，我就给大家分享一个电脑的小知识，电脑硬盘分区方法，赶紧来学习一下吧
我们在买来电脑后经常会发现电脑只有两个分区，非常不便于管理文件程序，而一个合理的硬盘分区可以提高电脑性能的一倍。那么如何给电脑分区呢？接下来，我就教大家如何给电脑分区
电脑硬盘分区详细步骤：
1、右击桌面计算机图标，选择管理
电脑如何分区图-1
2、点击左侧的磁盘管理
电脑如何分区图-2
3、右击需要分区的磁盘，选择压缩卷
电脑图-3
4、输入压缩的空间量，完成后点击压缩即可
电脑分区教程图-45、出现一个未分配的盘符，右击选择新建简单卷
电脑分区教程图-5
6、出现新建简单卷向导，点击下一步
电脑如何分区图-6
7、输入简单卷的大小，点击下一步
电脑如何分区图-7
8、分配一个盘符，点击下一步
电脑图-8
9、格式化这个磁盘，点击下一步
电脑如何分区图-9
10、点击完成就可以啦
硬盘分区图-10
以上就是电脑如何分区的详细步骤了，你学会了吗？返回首页，查看更多精彩教程
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23e437265e399f13dd5624cee615b0e0/" rel="bookmark">
			Java对象结构与synchronized实现原理及MarkWord详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本博客的本意不是技术分享
只是在学习过程中感觉需要复习的知识点记录整理下来
方便复习，以便面试的时候用
具体细节请阅读《深入理解Java虚拟机》
若本文对你有帮助那十分荣幸。
JAVA对象的总体结构 由于Java面向对象的思想，在JVM中需要大量存储对象，存储时为了实现一些额外的功能，需要在对象中添加一些标记字段用于增强对象功能 。在学习并发编程知识synchronized时，我们总是难以理解其实现原理，因为偏向锁、轻量级锁、重量级锁都涉及到对象头，所以了解java对象头是我们深入了解synchronized的前提条件
堆内存中的java对象：
对象的几个部分的作用：
1.对象头中的Mark Word（标记字）主要用来表示对象的线程锁状态，另外还可以用来配合GC、存放该对象的hashCode；
2.Klass Pointer是一个指向方法区中Class信息的指针，意味着该对象可随时知道自己是哪个Class的实例；
3.数组长度也是占用64位（8字节）的空间，这是可选的，只有当本对象是一个数组对象时才会有这个部分；
4.实例数据是用于保存对象属性和值的主体部分，占用内存空间取决于对象的属性数量和类型；
5.对齐字是为了减少堆内存的碎片空间
获取一个对象布局实例 1 创建一个maven项目，引入pom
&lt;dependency&gt; &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt; &lt;artifactId&gt;jol-core&lt;/artifactId&gt; &lt;version&gt;0.9&lt;/version&gt; &lt;/dependency&gt; 2 调用ClassLayout.parseInstance().toPrintable()
```java @Test void contextLoads() { L l = new L(); //new 一个对象 System.out.println(ClassLayout.parseInstance(l).toPrintable());//输出 l对象 的布局 } com.struggle.javaobject.L object internals: OFFSET SIZE TYPE DESCRIPTION VALUE 0 4 (object header) 01 00 00 00 (00000001 00000000 00000000 00000000) (1) 4 4 (object header) 00 00 00 00 (00000000 00000000 00000000 00000000) (0) 8 4 (object header) fa bc 06 f8 (11111010 10111100 00000110 11111000) (-133776134) 12 1 boolean L.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23e437265e399f13dd5624cee615b0e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73fc1799bf196a524e7369f1babfaab5/" rel="bookmark">
			3.1 react的空标签
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		React.Fragment() 空标签
React 中一个常见模式是为一个组件返回多个元素。Fragments 可以让你聚合一个子元素列表，并且不在DOM中增加额外节点。
Fragments 看起来像空的 JSX 标签：
render() { return ( &lt;&gt; &lt;ChildA /&gt; &lt;ChildB /&gt; &lt;ChildC /&gt; &lt;/&gt; ); } **一个常见模式是为一个组件返回一个子元素列表。**以这个示例的 React 片段为例：
class Table extends React.Component { render() { return ( &lt;table&gt; &lt;tr&gt; &lt;Columns /&gt; &lt;/tr&gt; &lt;/table&gt; ); } } 为了渲染有效的 HTML ， 需要返回多个 元素。如果一个父 div 在 的 render() 函数里面使用，那么最终的 HTML 将是无效的。
class Columns extends React.Component { render() { return ( &lt;div&gt; &lt;td&gt;Hello&lt;/td&gt; &lt;td&gt;World&lt;/td&gt; &lt;/div&gt; ); } } 在 组件中的输出结果如下： &lt;table&gt; &lt;tr&gt; &lt;div&gt; &lt;td&gt;Hello&lt;/td&gt; &lt;td&gt;World&lt;/td&gt; &lt;/div&gt; &lt;/tr&gt; &lt;/table&gt; 所以，需要使用 Fragments：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73fc1799bf196a524e7369f1babfaab5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e0102465b389451951afcc3e4097dc2/" rel="bookmark">
			uni-app踩坑：vue页面转换成nvue报错Cannot read property ‘__call_hook‘ of undefined
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		重启一下项目就好了 = =
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8034218bdb9f9761404ef748c25a94a0/" rel="bookmark">
			Vue3基础(十ba)___在css中使用props或者计算属性的变量，来实现动态样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要使用到了css3中var &lt;template &gt; &lt;div class="container"&gt; &lt;p class="p1" :style="{'--width':width,'--height':height,'--background':bgc,...objStyle}" &gt;obj2====={{obj2}}&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { ref, computed } from "vue"; export default { props: { width: { type: String, default: "300px" }, // 宽度 height: { type: String, default: "100px" }, // 高度 bgc: { type: String, default: "#ccc" } //北京颜色 }, setup(p, { emit }) { const obj = ref({ obj1: "obj111", obj2: "obj222", obj3: "obj333" }); let objStyle = computed(() =&gt; { return { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8034218bdb9f9761404ef748c25a94a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25b17dfe0d5a0e12c1c71f5e8dc7c593/" rel="bookmark">
			sort()函数的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sort(v.begin()，v.end()，cmp)，它是用来对一组序列进行排序的。sort函数进行排序的时间复杂度为n*log2n，比冒泡之类的排序算法效率要高，包含在头文件为#include&lt;algorithm&gt;的c++标准库中。
其有三个参数，前两个参数是待排序区间；第三个参数可有可无（第三个参数代表比较规则），没有第三个参数的时候，sort()默认按升序排列，有第三个参数的时候，可以通过这个参数实现各种各样的排序，包括降序。sort()函数功能强大就是强大在第三个参数。
sort()函数除了可以对int型、char型、double型、字符串排序外，还可以实现对结构体、链表、pair、vector、等类型进行排序，但需要自己写比较函数。而且sort()既可以对数组排序，也可以对vector容器排序。下面就先说一下sort()只有两个参数时的用法，具体代码见下：
1 #include&lt;iostream&gt; 2 #include&lt;vector&gt; 3 #include&lt;string&gt; 4 #include&lt;algorithm&gt; 5 using namespace std; 6 int main() 7 { 8 int a[10]={6,5,4,8,3,9,7,10,1,2}; 9 char b[8]={'h','z','l','n','m','r','d','g'}; 10 vector&lt;double&gt; v1; 11 vector&lt;string&gt; v2; 12 27 sort(a+1,a+9); //可以指定任意合法的排序区间，不能越界 30 35 sort(b,b+8); //对整个b排序 38 43 sort(v1.begin(),v1.end());//输入两个迭代器从而排序一个范围 46 51 sort(v2.begin(),v2.end()); 55 return 0; 56 } 上面几种方法都是升序排列，要想按降序排列，有3种方法可以实现:
1. sort()函数只有两个参数时默认升序排列，在排完序后，再用reverse()函数把整个序列给翻转一下，这样序列就变成了降序。 27 sort(a+1,a+9); //可以指定任意合法的排序区间，不能越界 31 reverse(a+1,a+9); 39 sort(b,b+8); //对整个b排序 43 reverse(b,b+8); 46 51 sort(v1.begin(),v1.end()); 55 reverse(v1.begin(),v1.end()); 63 sort(v2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25b17dfe0d5a0e12c1c71f5e8dc7c593/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b887e01426b3503a37a54c45063f87b/" rel="bookmark">
			RuntimeError: CUDA out of memory. Tried to allocate 20.00 MiB，错误记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码运行报这个错误：
RuntimeError: CUDA out of memory. Tried to allocate 20.00 MiB (GPU 0; 4.93 GiB total capacity; 94.84 MiB already allocated; 21.00 MiB free; 108.00 MiB reserved in total by PyTorch)
import torch, gc gc.collect() torch.cuda.empty_cache() 加入以上代码解决了，记录下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6000c302f75d144c09fbdc0ebf77d4d3/" rel="bookmark">
			奇偶校验只能发现奇数位错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		奇校验：使包含校验位在内的数据中为"1"的个数恒为奇数
偶校验：使包含校验位在内的数据中为"1"的个数恒为偶数（包括0个）
奇偶校验提供奇数个错误检测，无法检测偶数个错误，更无法识别错误信息位置
奇数+奇数=偶数
偶数+奇数=奇数
奇数+偶数=奇数
偶数+偶数=偶数
不难发现，一个数加上一个奇数可以改变奇偶行，然而偶数不可以。所以，只有出现了奇数个错误，才会改变整个数据中的1的个数，而发生了偶数个错误，即使发生了也不能发现，因为奇偶校验不能随时通过观察1个数的变化来发现错误的，而是通过奇偶行的变化来发现错误的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b14b1b92a566d4531808383768900b1/" rel="bookmark">
			html 给表格添加背景,HTML中新建表格怎么加背景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在html中，可以使用background属性设置新建表格中的背景，只需要给表格元素设置“background:属性值”即可。background属性在一个声明中设置所有的背景属性，可以设置对象为纯色的背景颜色，也可以设置图片为背景。
本教程操作环境：windows7系统、CSS3&amp;&amp;HTML5版、Dell G3电脑。
表格的颜色设置非常简单，和文字的颜色设置完全一样。
CSS通过background属性设置表格的背景；通过color属性设置表格中文字的颜色。
示例：
Document body {
background-color: #ebf5ff;
margin: 0px;
padding: 4px;
text-align: center;
}
table {
background: pink;
color: white;
}
NAMEAGENUMBERxm10202032021xf42010 效果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85d7a1e1a0d386522264fa204240b863/" rel="bookmark">
			在线mod计算机,MOD大师教程 手把手教你改造电脑机箱
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MOD将代替DIY风靡中国
中国的DIY已经从P2时代极少数的用户发展到现在让品牌机头疼不已的庞大用户群体，电脑的DIY已经不能再被说成是一个技术了。那么追求个性的玩家们只能坐以待毙吗？当然不是了，于是MOD在国内也慢慢地兴盛起来。
漂亮的机箱主题改造
国内现在也有了LAN PARTY的改造大赛，让众多的MOD高手有了一展才华的平台，这样MOD的发展越来越快。
半条命机箱改造
电脑机箱改装现在变得更加普遍，很多朋友喜欢把自己的机箱个性化，比如侧板开窗、改风扇罩等等，再配合机箱内部的灯光背景，确实让机箱增添了许多酷炫的效果。大家可以看看这组改装后的机箱图片，心动了没有！如何打造这样一个超酷的机箱呢？看看木头给大家搜集的MOD教程吧！
多么复杂的机箱都时由切割组成的
这里给出一个实例，在机箱侧板上开出一个五角星图案，通过这个案例来为大家介绍一下MOD改造的基本功。其实机箱MOD在制作工序上都离不开以下元素：直线切割、弧线切割和角度切割。多么复杂的图案都是由它们构成的。之所以选择五角星图案，不光是因为它简单易懂，而且它他的制作流程涵盖了机箱改造工序中的所有元素。
下面让木头带你们到实战当中去，体会MOD带来的乐趣。
相关精彩文章推荐:
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d00994178ea15ca38a82b30c1d051d5/" rel="bookmark">
			【统计学】各统计量及其抽样分布（z分布，t分布，卡方分布）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 前言 数据分析行业不可避免会与统计学打交道。常见的分析总体的过程如图所示：
常见的假设检验中，AB测试是最为出名的假设检验的过程，而需要深刻理解假设检验，先验知识统计量及其抽样分布的理解至关重要，这会为我们学习假设检验打下坚实的基础，本文章便是关于统计量及其抽样分布的讲解。
2. 统计量 建议专业讲解和大白话结合一起看，更易理解。
2.1 专业讲解 设X1, X2, ..., Xn是从总体X中抽取的容量为n的一个样本，如果由此样本构造一个函数T(X1, X2, ..., Xn)，不依赖于任何未知参数，则称函数T(X1, X2, ..., Xn)是一个统计量。
注：
统计量是一个随机变量当获得特定样本具体观察值x1, x2, ..., xn时，计算出T(x1, x2, ..., xn)的数值，就获得一个具体的统计量的值以上，X表示多种总体中的组合，x表示确定的观察值 2.2 大白话 设X1, X2, ..., Xn是从总体X中抽取的容量为n的一个样本，比如要研究人群总体身高均值，抽样得到一组样本的n各不同身高。根据这些不同的身高，构造统计量T(x1, x2, ..., xn)，表示计算这组样本的身高均值。
样本的身高均值便是我们得到的统计量，但是这个统计量是随机的，因为我们所抽取的样本是随机的n个不同身高。
2.3 常用统计量 以下将给出7个统计量的计算公式，但通常我们使用最多的是前三个统计量。
2.3.1 样本均值 2.3.2 样本方差 2.3.3 样本离散系数 2.3.4 样本原点矩 2.3.5 样本中心矩 2.3.6 样本偏度 2.3.7 样本峰度 3. 由正态分布导出的几个重要分布 3.1 抽样分布 样本统计量的分布即抽样分布。
3.1.1 专业讲解 当我们要对某一总体的参数进行估计时，就要研究来自该总体的所有可能的样本统计量的分布问题。其结果来自容量相同的所有可能样本。抽样分布、参数估计和假设检验是统计推断的三个中心内容。 3.1.2 大白话 拿身高来举例，要估计总体人群身高均值，要研究来自总体的多组样本的身高均值的分布。每组样本的数量要一样。根据得到的分布，进行假设检验，有利于我们进行统计推断。 3.2 分布（卡方分布） 3.2.1 来源 设X ~ N()，则 z = ~ N(0, 1)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d00994178ea15ca38a82b30c1d051d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a6ecd27a60eca39a8b4c8294e4fca3d/" rel="bookmark">
			交换两个变量的值（三种方式、完整代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种：建立一个变量 temp，通过temp进行交换(需要建立一个新的变量)
第二种：位运算符（异或^） (不需要新建立新的变量)
第三种：a=a+b (不需要新建立新的变量)
例如：
int a = 10;
int b = 20;
1.建立一个相同类型的变量 temp，通过temp进行交换 //需要建立一个变量（必须是跟要交换的数据 相同类型的） int temp = 0; temp = a; a = b; b = temp; 2.位与操作 void swap(int &amp;a, int &amp;b) { a ^= b; b ^= a; a ^= b; } /* *位与操作解释： * ^ :相同为假 ，相异为真 ==&gt; 两个相同的数 异或，相当于 没有这两个数 *第一步：a ^= b; ===&gt; a = (a^b) *第二步：b ^= a; ---&gt; b = b^(a^b)= a *第三步：a ^= b; ---&gt; a = (a^b)^a= b */ 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a6ecd27a60eca39a8b4c8294e4fca3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4326deb38f044935e9e4a67bb292053e/" rel="bookmark">
			uni-app踩坑：nvue页面中的text组件出现莫名边距
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;scroll-view class="nav" :scroll-x="true" show-scrollbar="false"&gt; &lt;view class="nav-li" @click="change_active(index)" v-for="(item,index) in nav_list" :key="'nav' + index"&gt; &lt;text :class="active == index?'active nav-text':'nav-text'"&gt;{{item.labelName}}&lt;/text&gt; &lt;view class="active-line" v-if="active == index"&gt; &lt;/view&gt; &lt;/view&gt; &lt;/scroll-view&gt; &lt;scroll-view class="nav" :scroll-x="true" show-scrollbar="false"&gt; &lt;view class="nav-li" @click="change_active(index)" v-for="(item,index) in nav_list" :key="'nav' + index"&gt; &lt;text :class="active == index?'active nav-text':'nav-text'"&gt; {{item.labelName}} &lt;/text&gt; &lt;view class="active-line" v-if="active == index"&gt; &lt;/view&gt; &lt;/view&gt; &lt;/scroll-view&gt; 两种写法不一样的结果
text组件中的文字需要和标签写在一行
否则会认为是换行，出现莫名边距
第一次写uni-app，是真的坑
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72aa27d21428895ccfee3728eaa031aa/" rel="bookmark">
			后端接收前端url请求传的一个数组ids
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#方法一： 使用可变参数长度 接收
@RequestMapping("/1") public void receive(String ...parms){//三个点表示可变参数 System.out.println("parms.length="+parms.length); for (int i = 0; i &lt; parms.length; i++) { System.out.println(parms[i]); } } 测试
传参的时候 多个参数用逗号隔开
方法二 ： 使用数组接收 @RequestMapping("/2") public void receive2(String[] parms){ System.out.println("parms.length="+parms.length); for (int i = 0; i &lt; parms.length; i++) { System.out.println(parms[i]); } } 小结 使用数组接收或者使用可变参数接收实际都是一样的
因为这两个方法不能重载
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc5915da56f1c7076a98ab0105e6c1de/" rel="bookmark">
			Unity中使用Protobuf进行数据传输
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Unity中使用Protobuf 近期在研究Protobuf进行数据传输，网上很多素材杂七杂八，各种介绍Protobuf的优点（吐槽一点，都主动来学了，好处还用再重复那么多遍吗？）于是无奈自己写一个比较基础的使用方法，深入研究可以先了解基础后自行官网研究（本文以C#举例）。
~1.准备工作 1.官方文档：Protobuf官网（我们用proto3）
2.GitHub下载：GItHub链接
这边我们下载一个Protobuf-CSharp和一个protocWin64
3.Protoc下载完成后我们解压，然后配置Protoc（根目录的bin文件下）的环境变量，以方便我们可以在CMD中使用，具体如何配置环境变量可自行百度（这个是为了方便在CMD中使用）。
这样便是成功了。
4.我们将下载的protobuf-csharp-3.17.3.zip解压后用VS打开。（TIps：路径protobuf-3.17.3\csharp\src）打开后右键Google.Protobuf选择生成Dll给Unity使用
生成好以后我们打开生成路径，将以下所有文件放进Unity中的Plugins文件夹中即可
以上就是准备工作。
~2.操作 因为我们只说一下基础，所以这里就简单达到使用效果。
syntax = "proto3";//使用的协议，我们使用proto3 //package = Test; package对应命名空间 //message 对应Class //里面一些常用的数据类型官方都有说明，这边不过多赘述 message Person { //这里a=1并不是给a赋值，而是a的属性顺序号 optional int32 A=1; string b=2; //标注包括“required”、“optional”、“repeated”三种，其中 //required表示该属性为必选属性，否则对应的message“未初始化”，debug模式下导致断言，release模式下解析失败； //optional表示该属性为可选属性，不指定，使用默认值（int或者char数据类型默认为0,string默认为空， //bool默认为false，嵌套message默认为构造，枚举则为第一个） //repeated表示该属性为重复字段，可看作是动态数组，类似于C++中的vector。 } 我们可以用txt写，然后将后缀改为Proto，但是我这边直接用的VSCode。
然后我们在当前文件夹运行CMD用指令protoc --csharp_out=OUT_DIR FileName.proto
protoc --csharp_out=. Person.proto //使用Csharp输出 =后面跟输出路径,"."代表当前路径，然后跟proto文件名+扩展名 运行后生成了一个Person.cs文件，将其拖入Unity中即可使用
~3.序列化和反序列化 using UnityEngine; using Google.Protobuf; public class TestOne: MonoBehaviour { string jsonMessage; byte[] buffer; void 序列化() { Person person = new Person(); person.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc5915da56f1c7076a98ab0105e6c1de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51113c98415d0230c0ddaea9864a9607/" rel="bookmark">
			在git bash上安装zip和unzip命令需要的文件；git bash 报错bash: *: command not found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		默认安装的git bash某些功能是没有的，比如zip，在git bash下执行zip和unzip命令时会报错命令找不到，但值得庆幸的是，我们可以安装我们需要的命令，以下以zip命令为例，步骤如下：
1.打开https://sourceforge.net/projects/gnuwin32/files/
2.找到zip和bzip2，由于zip依赖bzip2.dll，下载zip-3.0-bin.zip和bzip2-1.0.5-bin.zip，解压后，复制zip-3.0-bin的bin目录下的zip.exe 和bzip2-1.0.5-bin的bin目录下的bzip2.dll到&lt;Program folder&gt;\Git\usr\bin，比如我的：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d33d4297d4bf3438cd46411072d2f369/" rel="bookmark">
			1004：字符三角形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1004：字符三角形 时间限制: 1000 ms 内存限制: 65536 KB 【题目描述】
给定一个字符，用它构造一个底边长5个字符，高3个字符的等腰字符三角形。 【输入】
输入只有一行，包含一个字符。 【输出】
该字符构成的等腰三角形，底边长5个字符，高3个字符。 【输入样例】
* 【输出样例】
* *** ***** 说明：
考查字符类型、换行。 思路分析：
顺序结构的题，按顺序写代码即可。对于一行中的多个相同字符，有多少个字符，输出多少次该字符变量。 求解过程：
声明1个char类型变量； 输入1个字符给变量； 以该char类型变量按照格式输出等腰三角形。 易错点：
曾见过不少入门者直接用字符常量'*'来构造，而不用变量。 注意输出时，第一、二行的前面是有空格的，而最后一行没有空格。 参考代码 - C++：
#include &lt;iostream&gt; using namespace std; int main() { char c; cin &gt;&gt; c; cout &lt;&lt; " " &lt;&lt; c &lt;&lt; endl; cout &lt;&lt; " " &lt;&lt; c &lt;&lt; c &lt;&lt; c &lt;&lt; endl; cout &lt;&lt; c &lt;&lt; c &lt;&lt; c &lt;&lt; c &lt;&lt; c; return 0; } 参考代码 - C语言：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d33d4297d4bf3438cd46411072d2f369/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77d16216b73b98649a8f8bcc46ef4db1/" rel="bookmark">
			[ERROR] testWhileIdle is true, validationQuery not set
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原因是数据库的配置文件没有写全
补全即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8f31ca6a748b5d5fde755201f664b6a/" rel="bookmark">
			Unity 计算两物体之间的距离
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		using System.Collections;
using System.Collections.Generic;
using UnityEngine;
public class NewBehaviourScript : MonoBehaviour {
public Transform enenmy;
public Transform player;
private float distance;
private void Update()
{
distance = (enenmy.position - player.position).magnitude;
}
}
这代码用于计算敌人与角色的距离 拓展思路：
1.当角色距离敌人小于1的时候，敌人发起攻击
if（distance&lt;1）
{
播放敌人攻击动画
角色掉血
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/983d8e184933772b1fcf67696f90f38e/" rel="bookmark">
			启动项目报ERR unknown command ‘XREADGROUP‘.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		启动springboot项目报错
分析原因 redis连接问题
解决方法，修改redis配置
注意问题，notify-keyspace-events Ex去掉注释掉后要把前面空格也去掉，不然启动失败。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c911562a3ca7e568b17c746cbbc523b/" rel="bookmark">
			查岗神器！如何查看连接过的WiFi记录&#43;详细信息&#43;密码！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		事情是这样的 晚上，隔壁住的小姐姐突然跑过来敲门
有点紧张
因为毕竟只在电梯见过，打过几次招呼而已
跟我急急忙忙说了一堆
WiFi密码 追不了哥哥 直播什么的
仔细深入问了一下，才整理清楚她的问题
其实就是WiFi密码不记得了，但是PC终端登录过
怎么找回终端曾经连接过的WiFi密码呢
连接过的WiFi，密码忘记了怎么办呢 ？
幸亏 我知道的工具多
工具 通过netsh可以获取计算机曾经连接过的所有WiFi信息
包括WiFi详细、明文密码等等
netsh简介 netsh：全称Network Shell
是一个windows系统本身提供的功能强大的网络配置命令行工具
Netsh 是命令行脚本实用工具
它允许从本地或远程显示或修改当前正在运行的计算机的网络配置
找回WiFi密码步骤 1、进入netsh PS C:\Users\administrator&gt; netsh 2、查看当前计算机连接过的Wifi信息 netsh&gt;wlan show profiles #查看当前计算机连接过的Wifi信息 3、netsh会列出所有WiFi的连接记录 接口 WLAN 上的配置文件: 组策略配置文件(只读) --------------------------------- &lt;无&gt; 用户配置文件 ------------- 所有用户配置文件 : TP-LINK_8219 所有用户配置文件 : MI CC 9e 所有用户配置文件 : HI-Wifi 所有用户配置文件 : TP-LINK_040A黄 所有用户配置文件 : Lite Zoom 所有用户配置文件 : OpenWrt 所有用户配置文件 : WIFI_123 所有用户配置文件 : TP-LINK_A836 所有用户配置文件 : XXX的小屋 所有用户配置文件 : YMKJ 所有用户配置文件 : CMCC-FreeWIFI 所有用户配置文件 : 小米手机 所有用户配置文件 : XXX的小屋max 4、获取WiFi密码 netsh&gt;wlan show profiles TP-LINK_8219 key=clear 如下，是获得我们指定的WiFi TP-LINK_8219的详细信息，其中关键内容部分就是WiFi的明文密码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c911562a3ca7e568b17c746cbbc523b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8253290bbec3838071985ad7db7246e3/" rel="bookmark">
			Docker Mysql 5.7搭建主从复制（一主一从）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 环境介绍： 系统： ubuntu18.04
mysql：5.7
docker：20.10
二、 搭建步骤： 1、启动容器： # 主库 docker run -itd --name=mysql-5.7-master -p 3307:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7 # 从库 docker run -itd --name=mysql-5.7-slave -p 3308:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7 2、配置 master 主服务器： 1）进入master容器
docker exec -it mysql-5.7-master /bin/bash 2）安装vim 编辑器
apt-get update apt-get install vim -y 3）vim /etc/mysql/my.cnf 加入以下配置
[mysqld] ## 设置server_id，同一局域网中需要唯一 server_id=100 ## 指定不需要同步的数据库名称 binlog-ignore-db=mysql ## 开启二进制日志功能 log-bin=mall-mysql-bin ## 设置二进制日志使用内存大小（事务） binlog_cache_size=1M ## 设置使用的二进制日志格式（mixed,statement,row） binlog_format=mixed ## 二进制日志过期清理时间。默认值为0，表示不自动清理。 expire_logs_days=7 ## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。 ## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致 slave_skip_errors=1062 4）重启 mysql 服务 以及docker 容器：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8253290bbec3838071985ad7db7246e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/337c521a02d940f5edaad9b88eea4b47/" rel="bookmark">
			vue2.0打包的文件添加前缀路径，以及路由添加前缀路劲
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.在config文件夹下的index.js文件中assetsPublicPath设置你想要的文件路径
2.在设置路由文件里面base: '/'要设置成相应的值base: ‘/commonpath’
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e540a7a8cf878e465c48c255a34c69e5/" rel="bookmark">
			看完谷歌大佬的 LeetCode 刷题笔记，我马上去字节跳动面试！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果你刷 LeetCode 觉得吃力,那么一定需要这份谷歌大佬的 LeetCode 刷题笔记!
微信搜索「五分钟学算法」，公众号回复 04 即可获取对应的下载链接，以下是详细介绍。
在这里推荐一个谷歌大佬的刷题笔记,每一道题的题解都写得非常清楚.
作者在美国卡内基梅隆大学攻读硕士学位时，为了准备实习秋招，他从夏天开始整理 Leetcode 上的题目，几个月的时间，刷了几百道题目。
凭借着扎实的基础和长期的勤奋，他很快找到了如愿的工作。
入职前，闲暇的时候，他突然想到，自己刷了那么多题，而且对很多题目的解法有着总结，为何不把这些题目归纳总结一些，做成一个便于后来者阅读学习的电子书呢？
有了想法，作为行动派的他说干就干，于是这样一本制作精美且免费开源的书籍出现在大家面前。
引用他的话来说：
本书分为算法和数据结构两大部分，又细分了十五个章节，详细讲解了刷LeetCode时常用的技巧。我把题目精简到了101道，一是呼应了本书的标题，二是不想让读者阅读和练习时间过长。
这么做不太好的一点是，如果只练习这101道题，读者可能对算法和数据结构的掌握不够扎实。因此在每一章节的末尾，我都加上了一些推荐的练习题，并给出了一些解法提示，希望读者在理解每一章节后把练习题也完成。
从我的直观感受来说，这是一本用心的数据结构算法类书籍，全书总共 143 页篇幅，详细讲解算法的内容有十五个章节。
每个章节都是一些重要的知识点，伴有基础讲解和例题介绍，当然，也有一些推荐的练习题。
话不多说，让我们来看一下书的目录：
整本书，我仔细看了一遍，并对书中的一些解题思路和代码进行校验。
从我的直观感受来说，这是一本用心的数据结构算法类书籍，全书总共 143 页篇幅，详细讲解算法的内容有十五个章节。
每个章节都是一些重要的知识点，伴有基础讲解和例题介绍，当然，也有一些推荐的练习题。
话不多说，让我们来看一下书的目录：
第二章是讲解贪心算法的，我们摘取一些内容查看，发现对知识点的讲解介绍是细致入微的。
微信搜索「五分钟学算法」，公众号回复 04 即可获取对应的下载链接。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/280ff5002963a28864991a018cd84114/" rel="bookmark">
			Python tolist()用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 tolist函数的作用：将数组或矩阵转化为列表
from numpy import * a1=[[2,3,4],[5,6,7]]#列表 a2=mat(a1)#矩阵 a2 matrix([[2, 3, 4], [5, 6, 7]]) a3=array(a1)#数组 a3 array([[2, 3, 4], [5, 6, 7]]) a4=a2.tolist() a4 [[2, 3, 4], [5, 6, 7]] a5=a3.tolist() a5 [[2, 3, 4], [5, 6, 7]] a4==a5 True 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/444f56281e32527075c9687573fe8771/" rel="bookmark">
			如何优雅的设计DWS层？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于数仓的分层，大家最耳熟能详的就是基于OneData方法论的三层数仓划分，分别是：数据引入层（ODS，Operational Data Store）、数据公共层（CDM，Common Dimenions Model）和数据应用层（ADS，Application Data Store）。
​
当然，涉及到每一层具体该怎么建模，可能大家都有自己的理解。数据建模无疑是重中之重，如果我们把指标比作树上的果实，那么模型就好比是大树的躯干，想让果实结得好，必须让树干变得粗壮。
​
我们先来回想下，构建数据中台的初衷是什么：
没有可以复用的数据，大家不得不使用原始数据进行清洗、加工和计算指标… 这根源就在于数据模型的无法复用，数据开发都是烟囱式的。所以要解决这个问题，就要搞清楚健壮的数据模型该如何设计。
​
常见的数仓分层设计思路 下图是数仓分层的逻辑架构图，大家不妨回忆一下数据模型的分层设计：
​
数据引入层（ODS，Operational Data Store，又称数据基础层）：将原始数据几乎无处理地存放在数据仓库系统中，结构上与源系统基本保持一致，是数据仓库的数据准备区。这一层的主要职责是将基础数据同步、存储。数据公共层（CDM，Common Dimenions Model）：存放明细事实数据、维表数据及公共指标汇总数据。其中，明细事实数据、维表数据一般根据ODS层数据加工生成。公共指标汇总数据一般根据维表数据和明细事实数据加工生成。CDM层又细分为维度层（DIM）、明细数据层（DWD）和汇总数据层（DWS），采用维度模型方法作为理论基础， 可以定义维度模型主键与事实模型中外键关系，减少数据冗余，也提高明细数据表的易用性。在汇总数据层同样可以关联复用统计粒度中的维度，采取更多的宽表化手段构建公共指标数据层，提升公共指标的复用性，减少重复加工。 维度层（DIM，Dimension）：以维度作为建模驱动，基于每个维度的业务含义，通过添加维度属性、关联维度等定义计算逻辑，完成属性定义的过程并建立一致的数据分析维表。为了避免在维度模型中冗余关联维度的属性，基于雪花模型构建维度表。明细数据层（DWD，Data Warehouse Detail）：以业务过程作为建模驱动，基于每个具体的业务过程特点，构建最细粒度的明细事实表。可将某些重要属性字段做适当冗余，也即宽表化处理。汇总数据层（DWS，Data Warehouse Summary）：以分析的主题对象作为建模驱动，基于上层的应用和产品的指标需求，构建公共粒度的汇总指标表。以宽表化手段物理化模型，构建命名规范、口径一致的统计指标，为上层提供公共指标，建立汇总宽表、明细事实表。 数据应用层（ADS，Application Data Store）：存放数据产品个性化的统计指标数据，根据CDM层与ODS层加工生成。 DWS层很重要？ 通常，大家都会有这样的疑问：明明可以直接从DWD层取数，为什么要多此一举建立DWS的汇总逻辑表呢？
我想说的是：如果在业务场景不复杂的情况下，那样做是没有问题的。可一旦面对复杂的业务场景，那这种做法无疑是混乱的根源所在，前面提到的烟囱式开发、计算资源的浪费等等情况，正是这样产生的。
​
我们需要的是从数据明细层中做一个初步的汇总，抽象出来一些通用的维度：时间、用户ID、IP等，并根据这些维度做一些统计，比如用户每个时间段在不同登录IP购买的商品数等。
​
这里做一层轻度的汇总会让计算更加的高效，在此基础上如果计算仅7天、30天、90天的行为的话会快很多。我们希望80%的业务都能通过我们的DWS层计算，而不是ODS或者DWD。
​
应该遵循的设计原则 聚集是指针对原始明细粒度的数据进行汇总。DWS汇总数据层是面向分析对象的主题聚集建模，以零售的场景为例，我们最终的分析目标为：最近一天某个类目（例如，厨具）商品在各省的销售总额、该类目销售额Top10的商品名称、各省用户购买力分布。
​
因此，我们可以以最终交易成功的商品、类目、买家等角度对最近一天的数据进行汇总。数据聚集的注意事项如下：
​
聚集是不跨越事实的。聚集是针对原始星形模型进行的汇总。为获取和查询与原始模型一致的结果，聚集的维度和度量必须与原始模型保持一致，因此聚集是不跨越事实的，所以原子指标只能基于一张事实表定义，但是支持原子指标组合为衍生原子指标。聚集会带来查询性能的提升，但聚集也会增加ETL维护的难度。当子类目对应的一级类目发生变更时，先前存在的、已经被汇总到聚集表中的数据需要被重新调整。 此外，进行DWS层设计时还需遵循数据公用性原则。数据公用性需要考虑汇总的聚集是否可以提供给第三方使用。我们可以思考基于某个维度的聚集是否经常用于数据分析中，如果答案是肯定的，就有必要把明细数据经过汇总沉淀到聚集表中。
​
简单的说就是：
主题宽表轻度汇总 图解DWS层设计流程 以电商零售的场景为例，我们已经基于ODS层的订单表、用户表、商品表、优惠券表等，经过ETL完成了DWD层的建模，一般是采用星型模型。
​
这里严格按照：业务过程→声明粒度→确认维度→确认事实 完成建模，过程如下：
​
接下来，便是到了DWS层设计的环节。按照我们上面的设计思路，通过从维度表去看事实表，便可得出每天的宽表。
这样即可统计各个主题对象的当天行为，服务于ADS层的主题宽表以及一些业务的明细数据，也可以以应对一些特殊的需求，例如：购买行为，统计商品复购率等。
通过外键获取相关的度量值，我们整合多个DWD的明细事实表度量值来构成新表。
在这里，我们还是要遵循上文提到的设计原则，在设计上尽量体现出公共性、使用简单并且用户很容易理解。
思考：如何设计出完美的DWS层？ 在我们数据中台实际实施落地的过程中，团队不但要建设公共数据层，形成数据中台，还要承担着新需求的压力。
往往我们要先满足需求（活下去），再研发公共数据层（构建美好未来），在满足业务需求的过程中，再根据需求不断对模型进行迭代和优化，随着时间的推移，越来越多的业务需求可以通过DWS层的数据完成。
​
这一过程中，完善度是很好的考核标准，主要看DWS层汇总的数据能满足多少的查询需求，如果汇总数据无法满足需求，使用数据的人就必须使用明细的数据，甚至是ODS层的原始数据。
​
DWS/ADS层的完善度越高，说明数据的上层建设越完善，而从使用者的角度来说，查询快、易取数、用的爽，那才是硬道理。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/166a05de3a4a35c35d10053565676305/" rel="bookmark">
			模块参考资料-开发工具-Air530Z模块调试工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		调试工具 GnssToolKit3.0.59
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ed94aa1abd3b31e86d4b4c880e1c56e/" rel="bookmark">
			白话23 种设计模式，看完秒懂！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你知道的越多，不知道的就越多，业余的像一棵小草！ 成功路上并不拥挤，因为坚持的人不多。
编辑：业余草 zhuanlan.zhihu.com/p/100746724
推荐：https://www.xttblog.com/?p=5233 工厂方法 追 MM 少不了请吃饭了，麦当劳的鸡翅和肯德基的鸡翅都是 MM 爱吃的东西，虽然口味有所不同，但不管你带 MM 去麦当劳或肯德基，只管向服务员说「来四个鸡翅」就行了。麦当劳和肯德基就是生产鸡翅的 Factory 工厂模式：客户类和工厂类分开。
消费者任何时候需要某种产品，只需向工厂请求即可。消费者无须修改就可以接纳新产品。缺点是当产品修改时，工厂类也要做相应的修改。如：如何创建及如何向客户端提供。
建造者模式 MM 最爱听的就是「我爱你」这句话了，见到不同地方的 MM，要能够用她们的方言跟她说这句话哦，我有一个多种语言翻译机，上面每种语言都有一个按键，见到 MM 我只要按对应的键，它就能够用相应的语言说出「我爱你」这句话了，国外的 MM 也可以轻松搞掂，这就是我的「我爱你」builder。
建造模式：将产品的内部表象和产品的生成过程分割开来，从而使一个建造过程生成具有不同的内部表象的产品对象。建造模式使得产品内部表象可以独立的变化，客户不必知道产品内部组成的细节。建造模式可以强制实行一种分步骤进行的建造过程。
抽象工厂 请 MM 去麦当劳吃汉堡，不同的 MM 有不同的口味，要每个都记住是一件烦人的事情，我一般采用 Factory Method 模式，带着 MM 到服务员那儿，说「要一个汉堡」，具体要什么样的汉堡呢，让 MM 直接跟服务员说就行了。
工厂方法模式：核心工厂类不再负责所有产品的创建，而是将具体创建的工作交给子类去做，成为一个抽象工厂角色，仅负责给出具体工厂类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。
原型模式 跟 MM 用 QQ 聊天，一定要说些深情的话语了，我搜集了好多肉麻的情话，需要时只要 copy 出来放到 QQ 里面就行了，这就是我的情话 prototype 了。（100 块钱一份，你要不要）
原始模型模式：通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的方法创建出更多同类型的对象。原始模型模式允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构，原始模型模式适用于任何的等级结构。缺点是每一个类都必须配备一个克隆方法。
单态模式 俺有 6 个漂亮的老婆，她们的老公都是我，我就是我们家里的老公 Sigleton，她们只要说道「老公」，都是指的同一个人，那就是我 (刚才做了个梦啦，哪有这么好的事)
单例模式：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例单例模式。单例模式只应在有真正的 “单一实例” 的需求时才可使用。
适配器模式 在朋友聚会上碰到了一个美女 Sarah，从香港来的，可我不会说粤语，她不会说普通话，只好求助于我的朋友 kent 了，他作为我和 Sarah 之间的 Adapter，让我和 Sarah 可以相互交谈了 (也不知道他会不会耍我)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ed94aa1abd3b31e86d4b4c880e1c56e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8eb78ec59051b89dd38bf12c1a77ee80/" rel="bookmark">
			【Vivado那些事】FPGA的配置方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本来讲一讲FPGA的重构，在说FPGA重构之前，需要先了解FPGA的配置方式。
FPGA 配置
所有现代FPGA的配置分为两类：基于SRAM的和基于非易失性的。其中，前者使用外部存储器来配置FPGA内的SRAM后者只配置一次。
Lattice和Actel的FPGA使用称为反熔丝的非易失性配置技术，其主要优点是系统设计更加简单、不需要外部存储器和配置控制器、功耗低、成本低和FPGA配置时间更快。最大的缺点在于配置是固定的。
大多数现代FPGA都是基于SRAM包括Xilinx Spartan和Virtex系列。每个FPGA上电后或在后续的FPGA配置期间，从外部非易失性存储器中读取比特流，由配置控制器处理,并加载到内部配置SRAM中。SRAM保持了配置逻辑、IO、嵌入式存储器、布线、时钟、收发器和其他FPGA原语等所有的设计信息。
下图是Xilinx 的配置结构。
配置是由FPGA内部的配置控制器执行。比特流存储在外部非易失性存储器（如Flash)中。外部存储器通过使用SelectMAP接口连接到配置控制器，这是Xilinx特有的。额外的胶合逻辑可能需要架起SelectMAP和外部存储器接口之间的桥梁。此外，比特流可以通过JTAG或ICAP加载到配置控制器中。比特流可以选择加密，以提高安全性。内部电池备份RAM(BBR)和eFuse保存用于比特流解密的加密密钥。
FPGA配置存储器也称为配置存储器单元，它的每一位与比特流中的对应位一起初始化。每个存储器单元的输出连接到可配置的功能块上，如LUT寄存器、BRAM10、布线等。图2是配置存储器单元连接到多路复用器，以设置FPGA架构中元件之间的特定布线路径。在FPGA配置阶段，逻辑状态被置位为1或0。
图 2 FPGA 的布线配置
Xilinx 的 FPGA 配置模式
多种FPGA配置模式可满足不同的使用模式。图3是XilinxFPGA配置模式的分类。
图3FPGA配置模式的分类
配置模式分为两类：主动（master）模式和被动（slave）模式。在主动配置模式下，FPGA控制配置过程。在被动模式下，由外部设备（如单片机、CPLD或其他FPGA)控制FPGA的配置过程。此外，还有两个特殊的配置模式，即使用JTAG和内部配置访问端口(ICAP)
有4种数据宽度支持不同的外部存储器：32位、16位、8位、1位（串行）。下面是配置模式的简要介绍。
JTAG
JTAG接口主要在调试期间使用。为了与Xilinx Chip Scope和IMPACT软件应用程序接口，特殊的适配器连接到专用FPGA引脚上。
ICAP
专用的ICAP原语用于与用户逻辑的接口，在FPGA架构内进行配置。
主动串行模式
在主动串行模式中，FPGA控制Xilinx Platform Flash，以提供配置数据Xilinx Platform Flash是一种特殊的非易失性存储器，旨在通过使用Select MAP接口直接与Xilinx FPGA接口。
主动SPI Flash模式
在主动SPI Flash模式中，FPGA控制串行SPI闪存，以提供配置数据。
主动Selec tMAP模式
在主动Select MAP模式中，FPGA控制Xilinx Platform Flash,以提供8位或16位的配置数据。
主动BPI模式
在主动BPI模式中，FPGA控制并行NOR Flash,以提供8位或16位的配置数据。
被动串行和Select MAP模式
在被动串行模式下，外部设备（如单片机、CPLD或其他FPGA)控制FPGA的配置过程。
设计FPGA配置方案
对于特定设计来说，有一些设计考虑用于选择最合适的FPGA配置方案。主要的选择标准是
•选择是否通过外部设备（被动模式）或由FPGA本身（主动模式）控制配置过程。从系统复杂性角度来看，主动模式最简单，但未必适合所有设计。被动模式接口作为简单的串行接口，直接连接到处理器的10引脚，读取比特流数据进人配置控制器。
•选择外部非易失性存储器的类型和大小，用于存储一个或多个FPGA比特流。尽管与FPGA的成本相比，外部存储器的成本相对较低，但仍然是不可忽略的。设计者可以在SHFlash并行NOR Flash或Xilinx Platform Flash之间进行选择。在某些设计中，FPGA可以使用连接到被动模式下的FPGA配置控制器直接配置。
•数据宽度的选择—串行、8位、16位或32位—影响配置速度和FPGA中用于设计的10数目。
•现场升级配置比特流可以是一个重要的需求。配置方案必须解决当比特流正在编程进入非易失性存储器时发生损坏的情况。
•Xilinx FPGA提供了一个选项，用来加密在更高设计安全要求情况下的比特流。解密密钥可以存储在内部的BBR或者eFuse中。BBR存储器是易失性的，需要外部电池。使用BBR与使用非易失性eFuse相比，重新编程相对容易。
计算配置时间
在许多应用中，FPGA配置时间很关键，要准确估计配置方案选择过程中的时间是很重要的。配置时间取决于比特流大小、时钟频率和配置接口的数据宽度，按下列公式定义：
配置时间=比特流大小x时钟频率x数据宽度
表1提供了配置接口在不同数据宽度下，对于使用50MHz时钟的最小和最大Xilinx Virtex-6 FPGA的预期配置时间。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8eb78ec59051b89dd38bf12c1a77ee80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea1d1a96c126345bb212b20084ca7350/" rel="bookmark">
			leetcode题库学习系列——168. Excel表列名称
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原题地址：
https://leetcode-cn.com/problems/excel-sheet-column-title/
原题如下： 给你一个整数 columnNumber ，返回它在 Excel 表中相对应的列名称。
例如：
A -&gt; 1
B -&gt; 2
C -&gt; 3
…
Z -&gt; 26
AA -&gt; 27
AB -&gt; 28
…
示例 1：
输入：columnNumber = 1
输出：“A”
示例 2：
输入：columnNumber = 28
输出：“AB”
示例 3：
输入：columnNumber = 701
输出：“ZY”
示例 4：
输入：columnNumber = 2147483647
输出：“FXSHRXW”
提示：
1 &lt;= columnNumber &lt;= 231 - 1
记录解题思路： 打眼看去是个26进制的题（想到这点的思路很快，这算是我的一个进步），同时应该很快的联想到进制的换算，以10进制为枢纽，10进制写成N进制，M进制写成10进制等等，应该马上联想到这些才对。
然后进行了区域演算，如下：
A=1
Z=26
AA=27=1+26*1
AZ=52
BA=53=1+26*2=B*26^1+A*26^0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea1d1a96c126345bb212b20084ca7350/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f10252d6180c54f507e27d0949b008f2/" rel="bookmark">
			【预测模型】BP神经网络的预测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原理 clear; clc; TestSamNum = 20; % 学习样本数量 ForcastSamNum = 2; % 预测样本数量 HiddenUnitNum=8; % 隐含层 InDim = 3; % 输入层 OutDim = 2; % 输出层 % 原始数据 % 人数(单位：万人) sqrs = [20.55 22.44 25.37 27.13 29.45 30.10 30.96 34.06 36.42 38.09 39.13 39.99 ... 41.93 44.59 47.30 52.89 55.73 56.76 59.17 60.63]; % 机动车数(单位：万辆) sqjdcs = [0.6 0.75 0.85 0.9 1.05 1.35 1.45 1.6 1.7 1.85 2.15 2.2 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f10252d6180c54f507e27d0949b008f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/646707c26373435fd41a080356366824/" rel="bookmark">
			【RBF预测】基于RBF神经网络预测模型matlab源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简介 【注】蓝色字体为自己的理解部分
径向基函数神经网络的优点：逼近能力，分类能力和学习速度等方面都优于BP神经网络，结构简单、训练简洁、学习收敛速度快、能够逼近任意非线性函数，克服局部极小值问题。原因在于其参数初始化具有一定的方法，并非随机初始化。
RBF是具有单隐层的三层前向网络。第一层为输入层，由信号源节点组成。第二层为隐藏层，隐藏层节点数视所描述问题的需要而定，隐藏层中神经元的变换函数即径向基函数是对中心点径向对称且衰减的非负线性函数，该函数是局部响应函数，具体的局部响应体现在其可见层到隐藏层的变换跟其它的网络不同。以前的前向网络变换函数都是全局响应的函数。第三层为输出层，是对输入模式做出的响应。输入层仅仅起到传输信号作用，输入层和隐含层之间可以看做连接权值为1的连接，输出层与隐含层所完成的任务是不同的，因而他们的学习策略也不同。输出层是对线性权进行调整，采用的是线性优化策略，因而学习速度较快；而隐含层是对激活函数(格林函数，高斯函数，一般取后者)的参数进行调整，采用的是非线性优化策略，因而学习速度较慢。对于这句话的理解，从下面的层与层之间的变换可以发现。
RBF神经网络的基本思想：用RBF作为隐单元的“基”构成隐藏层空间，隐藏层对输入矢量进行变换，将低维的模式输入数据变换到高维空间内，使得在低维空间内的线性不可分问题在高维空间内线性可分。详细一点就是用RBF的隐单元的“基”构成隐藏层空间，这样就可以将输入矢量直接(不通过权连接)映射到隐空间。当RBF的中心点确定以后，这种映射关系也就确定 了。而隐含层空间到输出空间的映射是线性的(注意这个地方区分一下线性映射和非线性映射的关系)，即网络输出是因单元输出的线性加权和，此处的权即为网络可调参数。
下图是径向基神经元模型 《43案例分析》中介绍：径向基函数的激活函数是以输入向量和权值向量(注意此处的权值向量并非隐藏层到输出层的权值，具体看下面的径向基神经元模型结构)之间的距离||dist||作为自变量的。径向基网络的激活函数的一般表达式为。
《模式识别与智能计算》中介绍：径向基网络传递函数是以输入向量与阈值向量之间的距离|| X-Cj ||作为自变量的，其中|| X -Cj ||是通过输入向量和加权矩阵C的行向量的乘积得到。此处的C就是隐藏层各神经元的中心参数，大小为隐层神经元数目*可见层单元数。再者，每一个隐神经元中心参数C都对应一个宽度向量D，使得不同的输入信息能被不同的隐层神经元最大程度地反映出来。
得到的这个R就是隐层神经元的值。
随着权值和输入向量之间距离的减少，网络输出是递增的，当输入向量和权值向量一致时，神经元输出为1。图中的b为阈值，用于调整神经元的灵敏度。利用径向基神经元和线性神经元可以建立广义回归神经网络，此种神经网络适用于函数逼近方面的应用。径向基函数和竞争神经元可以建立概率神经网络，此种神经网络适用于解决分类问题。
RBF神经网络学习算法需要三个参数：基函数的中心，方差(宽度)以及隐含层到输出层的权值。
RBF神经网络中心选取方法：
对于RBF神经网络的学习算法，关键问题是隐藏层神经元中心参数的合理确定。常用的方法是从中心参数(或者其初始值)是从给定的训练样本集里按照某种方法直接选取，或者是采用聚类的方法确定。
①直接计算法(随机选取RBF中心)
隐含层神经元的中心是随机地在输入样本中选取，且中心固定。一旦中心固定下来，隐含层神经元的输出便是已知的，这样的神经网络的连接权就可以通过求解线性方程组来确定。适用于样本数据的分布具有明显代表性。
②自组织学习选取RBF中心法
RBF神经网络的中心可以变化，并通过自组织学习确定其位置。输出层的线性权重则是通过有监督的学习来确定的。这种方法是对神经网络资源的再分配，通过 学习，使RBF的隐含层神经元中心位于输入空间重要的区域。这种方法主要采用K-均值聚类法来选择RBF的中心，属于无监督(导师)的学习方法。
③有监督(导师)学习选取RBF中心
通过训练样本集来获得满足监督要求的网络中心和其他权重参数。常用方法是梯度下降法。
④正交最小二乘法选取RBF中心法
正交最小二乘法(Orthogoal least square)法的思想来源于线性回归模型。神经网络的输出实际上是隐含层神经元某种响应参数(回归因子)和隐含层至输出层间连接权重的线性组合。所有隐含层神经元上的回归因子构成回归向量。学习过程主要是回归向量正交化的过程。
在很多实际问题中，RBF神经网络隐含层神经元的中心并非是训练集中的某些样本点或样本的聚类中心，需要通过学习的方法获得，使所得到的中心能够更好地反应训练集数据所包含的信息。
基于高斯核的RBF神经网络拓扑结构
第一层输入层：由信号源节点构成，仅起到数据信息的传递作用，对输入信息不做任何变换
第二层隐含层：节点数视需要而定。隐含层神经元核函数(作用函数)是高斯函数，对输入信息进行空间映射的变换。
第三层输出层，对输入模式做出响应。输出层神经元的作用函数为线性函数，对隐含层神经元输出的信息进行线性加权后输出，作为整个神经网络的输出结果。
径向基网络传递函数是以输入向量与阈值向量之间的距离|| X-Cj ||作为自变量的。其中|| X-Cj ||是通过输入向量和加权矩阵C的行向量的乘积得到的。径向基神经网络传递参数可以取多种形式。常见的有：
①Gaussian函数(高斯函数)
②Reflected sigmoidal函数(反常S型函数)
③逆Multiquadric函数(逆 畸变校正函数)
较为常用的还是Gaussian函数，本文采用Gaussian函数：
当输入自变量为0时，传递函数取得最大值1,。随着权值和输入向量间的距离不断减小，网络输出是递增的。也就是说，径向基函数对输入信号在局部产生响应。函数的输入信号X靠近函数的中央范围时，隐含层节点将产生较大的输出。由此可以看出这种网络具有局部逼近能力。
当输入向量加到网络输入端时，径向基层每个神经元都会输出一个值，代表输入向量与神经元权值向量之间的接近程度。如果输入向量关于权值向量相差很多，则径向基层输出接近于0,；如果输入向量与权值向量很接近，则径向基层的输出接近于1，经过第二层(隐含层)的线性神经元，输出值就靠近第二层权值。在这个过程中，如果只有一个径向基神经元的输出为1，而其他神经元输出均为0或者接近0，那么线性神经元的输出就相当于输出为1的神经元对应的第二层(隐含层)权值的值。
RBF网络训练：
训练的目的是求两层的最终权值Cj、Dj和Wj。
训练的过程分为两步：第一步是无监督学习，训练确定输入层与隐含层间的权值Cj、Dj；第二步是有监督学习，训练确定隐含层与输出层间的权值Wj。
训练前提供输入向量X、对应的目标输出向量Y和径向基函数的宽度向量Dj。
在第 l 次输入样品(l=1,2,...,N)进行训练时，各个参数的表达及计算方法如下：
(1)确定参数
①确定输入向量X：
，n是输入层单元数
②确定输出向量Y和希望输出向量O
，q是输出层单元数
③初始化隐含层至输出层的连接权值
其中p是隐藏层单元数，q是输出层单元数。
参考中心初始化的方法给出隐藏层到输出层的权值初始化方法：
其中mink是训练集中第k个输出神经元中所有期望输出的最小值；maxk是训练集中第k个输出神经元中所有期望输出的最大值。
④初始化隐含层各神经元的中心参数。不同隐含层神经元的中心应有不同的取值，并且与中心的对应宽度能够调节，使得不同的输入信息特征能被不同的隐含层神经元最大的反映出来。在实际应用中，一个输入信息总是包含在一定的取值范围内。不失一般性，将隐含层各神经元的中心分量的初值，按从小到大等间距变化，使较弱的输入信息在较小的中心附近产生较强的响应。间距的大小可由隐藏层神经元的个数来调节。好处是能够通过试凑的方法找到较为合理的隐含层神经元数，并使中心的初始化尽量合理，不同的输入特征更为明显地在不同的中心处反映出来，体现高斯核的特点。
基于上述四项，RBF神经网络中心参数的初始值为：
(p为隐含层神经元总个数，j=1,2,...,p)
mini是训练集中第i个特征所有输入信息的最小值，maxi为训练集中第i 个特征所有输入信息的最大值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/646707c26373435fd41a080356366824/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ce4e3d54246cec149efca2ef5809b2e/" rel="bookmark">
			【信号处理】单通道盲源分离（SSA-ICA）算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		盲源分离简单的来讲就是在不明确系统的传输特性的前提下，从系统的源信号估计出观测信号的传输信道。
假设n个未知的源信号，各传感器接收到m个混合的观测信号，为混入的加性噪声，混合系统A为未知的混合矩阵。经过分离系统W后分离出近似与源信号的估计向，盲源分离的数学模型可以表达为：
要想分离出源信号S(t)的估计向量Y(t)主要是要求分解离矩阵W，Y(t)的分离系统过程表达式如下：
盲信号分离的原理框图如图所示，由于混合系统A和源信号S(t)都是未知的，所以对于分离出的估计向量Y(t)可能在幅度大小和排列次序存在不确定性，但是信号的信息存在于信号的波形中，所以并不影响对信号的分离。
``` %----------------------------------------------------------------
clc
clear all
%% --------------------------------- Set Parameters
N = 1; %The number of observed mixtures
Ns = 2; %The number of independent sources
Ls = 1000; %Sample size, i.e.: number of observations
finalTime = 40*pi; %Final sample time (s)
initialTime = 0; %Initial sample time (s)
%% --------------------------------- Generating Data for SSA-ICA
Amix = rand(N,Ns); %Amix is a random N x Ns mixing matrix
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ce4e3d54246cec149efca2ef5809b2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1c924c265aa91183ba1170924322609/" rel="bookmark">
			stm32 堆栈存放分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、理论数据存放
数据在SRAM中的存放情况，最下层为静态数据区，再上层是堆区，最上层是栈区，
二、栈存放：
（1）栈底地址：
在map文件中搜索STACK，可以看到该工程的栈底地址为0x200002a0
（2）栈顶地址：
在map文件中搜索__initial_sp，可以看到该工程的栈顶地址为0x200003a0
（3）栈占用大小：
根据上面的地址信息，则可以推算该工程的栈大小为 0x200003a0 - 0x200002a0 = 0x0100
在启动文件中查到栈分配大小为0x100，和计算结果一致
在map文件最后，看到ram占用为928字节 = 0x3a0，和栈顶指针相同。
三、实际数据存放
所以该工程的实际堆栈占用为
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13dfec2900a10fed085553037e742bf5/" rel="bookmark">
			GIT一问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.问：错误 failed to push some refs to ‘xxxx’...
error: failed to push some refs to 'codemanager@xxx.xxx.xxx.9:xxxxxx/ProjectFiles.git' hint: Updates were rejected because the tip of your current branch is behind hint: its remote counterpart. Integrate the remote changes (e.g. hint: 'git pull ...') before pushing again (提示大概就是，你的仓库无法推送到远程处，需要你pull一下远程分支)
（1）情景再现
git创建远程仓库，并生成了README.md文件，现在本地项目目录处初始化git，执行命令后将本地仓库推到远程仓库。
（2）git命令执行
git init git add . git commit -m "推" git remote add origin [remote-addr] git push -u origin master （3）错误原因
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13dfec2900a10fed085553037e742bf5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c97da8d1012b29437134ea5a976714db/" rel="bookmark">
			md5 中文加密 前后端不一致问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于项目要做完整性校验，防止参数被中途篡改，所以采取前端先把所有参数组合在一起，用MD5加盐的方式加密一次，然后把明文的参数和加密后的参数一起传入后端，在拦截器里进行参数对比，方式就是在拦截器里面把明文参数再用MD5加密一次，将传入的密文参数进行比对，结果比较坑的事情来了，前端加密的字符串和后端明文加密后的字符串经过比对，发现不一致，经过仔细推敲，发现可能是中文编码的问题造成，在对前端要加密字符串进行编码，和后端的明文字符串进行编码后，问题解决,解决方案如下：
js:
var md5_sign=MD5(encodeURIComponent(‘2350-公司领导-张三-a9e8a4371057’));
java 拦截器:
String key=MD5Util.MD5Encode(URLEncoder.encode("2350-公司领导-张三-a9e8a4371057"));
这样加密后 后端获取的md5_sign参数和加密后的字符串 key 是一致的，如果数据被篡改，前端和后端对比的字符串不一致，请求将会被拦截！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f57f653517b8639a9394144f86ca6e42/" rel="bookmark">
			C&#43;&#43;工程项目中常见的写法与解释——多种状态值的混合（按位处理）篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般来说，对于一个类而言，其状态的表达形式有很多，比如使用enum枚举
enum CLASS_STATUS{status1=0，status2，status3} 但假如这个类有多种状态，使用多个enum枚举状态值，效率往往没有按位计算来的更高。
假如有一个类，animal动物，有行动状态（飞，走，游），有身形状态（大，中，小），有颜色状态（红，白，蓝），我们可以这样设定：
#define animal_action_status_fly	0x00000001 #define animal_action_status_walk	0x00000002 #define animal_action_status_swim	0x00000004 #define animal_action_status_big	0x00000010 #define animal_action_status_medium	0x00000020 #define animal_action_status_small	0x00000040 #define animal_action_status_red	0x00000100 #define animal_action_status_white	0x00000200 #define animal_action_status_blue	0x00000400 当我们想表示一个中等身形的，会飞的蓝色动物，我们可以这样表示：
animal_action_status_medium | animal_action_status_fly	| animal_action_status_blue 按位取或是对二进制而言的，所以这里的按位取或，是要将十六进制数值转换成二进制，从而计算。
十六进制的一位0~F转化成二进制为：0000~1111
而00、10、20、30~F0转化成二进制为：0000 0000~1111 0000
由此我们可以发现，如果进行如下计算
获取结合状态值
m_status = animal_action_status_medium | animal_action_status_fly 会得到
0x00000020 | 0x00000001
转化成二进制为
0010 0000 | 0000 0001
按位取或，结果为0010 0001，是两种状态结合的唯一二进制结果，
如若转化成十六进制，则为0x00000021，
既方便查看唯一状态值，又方便查验到底是哪几种状态的结合值。
设定的状态值，如果单一状态的数量在1~F（1~15个）时，每个状态占一位是可行的，但如果单一状态超过这个数值，就用两位表示一个状态即可。
比如，上面动物的例子，颜色状态不止有3个，有24个，如果第0个值该状态值表示为0x00000100，那么第24个的十六进制值表示为0x00001800
所以实际使用时，可根据实际情况，设计状态占的位数。
取消某个状态值
如
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f57f653517b8639a9394144f86ca6e42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae242f8527128cf815fc72e95e519632/" rel="bookmark">
			laravel 添加sql日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 laravel 打印sql语句非常的麻烦而且不方便，所以就想弄一个sql日志来方便调试排除
首先到 EventServiceProvider.php （监听文件） 里 赋值日志开关常数 define('SQL_LOG', env('SQL_LOG', false)); 然后到 $listen 里增加 SQL_LOG ? \Illuminate\Database\Events\QueryExecuted::class : '' =&gt; [ \App\Listeners\ExampleListener::class // 这个类就是要我们自己写的监听方法 ], 然后到 ExampleListener里写写入sql 的方法 public function handle(QueryExecuted $event) { $sql = str_replace("?", "'%s'", $event-&gt;sql); $log = vsprintf($sql, $event-&gt;bindings); $log = '[' . date('Y-m-d H:i:s') . '] ' . $log . "\r\n"; $filepath = storage_path('logs\sql.log'); file_put_contents($filepath, $log, FILE_APPEND); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b6a2acc7f6b8375dd91129f80cfd84b/" rel="bookmark">
			保证多线程顺序执行，四种方案，你知道几种？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇是1000期面试系列文章的第94期，持续更新中.....
回复“面试”获取优质面试资源！
故事 上周一位同学在面试中遇到了这么一道问题：
有三个线程T1、T2、T3，如何保证顺序执行？
常规操作，启动三个线程，让其执行。
public class ThreadDemo { public static void main(String[] args) { final Thread t1 = new Thread(new Runnable() { @Override public void run() { System.out.println("线程1"); } }); final Thread t2 = new Thread(new Runnable() { @Override public void run() { System.out.println("线程2"); } }); Thread t3 = new Thread(new Runnable() { @Override public void run() { System.out.println("线程3"); } }); t1.start(); t2.start(); t3.start(); } } 运行结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b6a2acc7f6b8375dd91129f80cfd84b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e720cc5f80da81ac6091f9cd9355b5a/" rel="bookmark">
			面试反馈  Spring Cloud 的25连环炮
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关注公众号“Java后端技术全栈”
回复“000”获取程序员必备电子书
前言 前段时间由于特殊原因，导致我们的面试连环炮断更了，刚好上周一位老铁去面试被问到了Spring Cloud，然后结合他的反馈，今天我们继续走起SpringCloud面试连环炮。
欢迎大家关注我：
Spring Cloud核心知识总结 下面是一张Spring Cloud核心组件关系图：
从这张图中，其实我们是可以获取很多信息的，希望大家细细品尝。
下面是Spring Cloud Netflix和Spring Cloud Alibaba核心组件的总结：
活不多说，我们直接开始 Spring Cloud 连环炮。
连环炮走起 1、什么是Spring Cloud ？ Spring cloud 流应用程序启动器是基于 Spring Boot 的 Spring 集成应用程序，提供与外部系统的集成。Spring cloud Task，一个生命周期短暂的微服务框架，用于快速构建执行有限数据处理的应用程序。
2、什么是微服务？ 微服务架构是一种架构模式或者说是一种架构风格，它提倡将单一应用程序划分为一组小的服务，每个服务运行在其独立的自己的进程中，服务之间相互协调、互相配合，为用户提供最终价值。服务之间采用轻量级的通信机制互相沟通（通常是基于HTTP的RESTful API）,每个服务都围绕着具体的业务进行构建，并且能够被独立的构建在生产环境、类生产环境等。另外，应避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建，可以有一个非常轻量级的集中式管理来协调这些服务，可以使用不同的语言来编写服务，也可以使用不同的数据存储。
通俗的来讲：
微服务就是一个独立的职责单一的服务应用程序。在 intellij idea 工具里面就是用maven开发的一个个独立的module，具体就是使用springboot 开发的一个小的模块，处理单一专业的业务逻辑，一个模块只做一个事情。
微服务强调的是服务大小，关注的是某一个点，具体解决某一个问题/落地对应的一个服务应用，可以看做是idea 里面一个 module。
3、Spring Cloud有什么优势 使用 Spring Boot 开发分布式微服务时，我们面临以下问题
与分布式系统相关的复杂性-这种开销包括网络问题，延迟开销，带宽问题，安全问题。
服务发现-服务发现工具管理群集中的流程和服务如何查找和互相交谈。它涉及一个服务目录，在该目录中注册服务，然后能够查找并连接到该目录中的服务。
冗余-分布式系统中的冗余问题。
负载平衡 --负载平衡改善跨多个计算资源的工作负荷，诸如计算机，计算机集群，网络链路，中央处理单元，或磁盘驱动器的分布。
性能-问题 由于各种运营开销导致的性能问题。
部署复杂性-Devops 技能的要求。
4、微服务之间如何独立通讯的? 同步通信：dobbo通过 RPC 远程过程调用、springcloud通过 REST 接口json调用等。
异步：消息队列，如：RabbitMq、ActiveM、Kafka等消息队列。
5、 什么是服务熔断？什么是服务降级？ 熔断机制是应对雪崩效应的一种微服务链路保护机制。当某个微服务不可用或者响应时间太长时，会进行服务降级，进而熔断该节点微服务的调用，快速返回“错误”的响应信息。当检测到该节点微服务调用响应正常后恢复调用链路。在Spring Cloud框架里熔断机制通过Hystrix实现，Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内调用20次，如果失败，就会启动熔断机制。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e720cc5f80da81ac6091f9cd9355b5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5791bf6a9438492c5d7b7e04b075b493/" rel="bookmark">
			docker 中文文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		docker 中文文档 https://dockerdocs.cn/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d35add4be6b916d03d951a2253b72592/" rel="bookmark">
			Python爬虫 之 异步爬虫
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		异步爬虫 异步爬虫初识异步爬虫方式li视频源码讲解 协程异步编程什么是协程：实现携程的方法：事件循环单条时间启动多个事件启动（重要）await关键字（重要）回调函数（重要）协程中的requests—aiohttp（重要）基于协程的数据爬取 完整版！！！！！！！
完整版！！！！！！！
完整版！！！！！！！ 爬虫完整版
异步爬虫 初识异步爬虫方式 多线程，多进程（不建议）：
- 优点：可以为相关堵塞（耗时间）的操作单独开启线程和进程，堵塞程序就会实现异步执行
- 缺点：无法限制多进程或多进程线程池，进程池：
- 优点：降低系统对于线程和进程创建和销毁的频率，减小系统开销
- 缺点：池中线程和进程数量有上限 举个栗子直观地看一下线程的作用吧
import time def get_text(char): print("正在下载",char) time.sleep(2) print("成功加载",char) return char #单线程运行： #运行文本 text=['a','b','c','d'] #记录开始时间 start_time=time.time() for i in text: get_text(i) #记录结束时间 end_time=time.time() print("单进程共需要时间：",end_time-start_time) #多线程运行 #导库 from multiprocessing.dummy import Pool #实例化4线程池 pool=Pool(4) start_time=time.time() text_list=pool.map(get_text#进行多线程的目标函数名，没有() ,text#传入数据的列表 ) #该函数返回值为函数return值组成的列表，顺序和传入列表相对应 end_time=time.time() print("多进程共需要时间：",end_time-start_time) print(text_list) 结果为： 正在下载 a 成功加载 a 正在下载 b 成功加载 b 正在下载 c 成功加载 c 正在下载 d 成功加载 d 单进程共需要时间：8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d35add4be6b916d03d951a2253b72592/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6463eb83808a0b3d394e8a17f54968bd/" rel="bookmark">
			windows 无法停止 Internet Connection Sharing (ICS)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows 无法停止 Internet Connection Sharing (ICS) 的解决方法 报错截图：
windows 无法停止 Internet Connection Sharing (ICS) 的解决方法
解决方法：
停止 Hyper-v 服务。进入控制面板-- 程序–查看或关闭windows功能 去掉Hyper-v 前面的勾，确定，重启电脑
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08e5015253f50b184aaf4e2481ad34be/" rel="bookmark">
			PowerDesigner 使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PowerDesigner 16.5 使用教程 PowerDesigner 16.5 一、打开软件二、创建概念模型三、新建表四、显示SQL代码五、字段名设置自动递增 PowerDesigner 16.5 PowerDesigner 16.5免费版是一款功能强大的建模软件，提供强大的元数据管理功能，可以帮助用户构建关键信息资产的360度全方位视图，创建多种类型的模型，包括概念数据模型、物理数据模型、面向对象模型等等，同时集成了数据管理、BI、数据集成和数据整合多种功能
一、打开软件 使用PowerDesigner软件创建数据库，首先要从官网中下载安装软件。我的PowerDesigner版本是16.5的，如若版本不一样，请自行参考学习。
打开软件后显示主界面以及欢迎界面
二、创建概念模型 PowerDesigner有以下几种主要模型：
概念模型(CDM Conceptual Data Model)
物理模型（PDM,Physical Data Model）
面向对象的模型（OOM Objcet Oriented Model）
业务模型（BPM Business Process Model）
打开软件后有两种方法创建概念模型：
①.点击欢迎界面的“Create Model”；
②.关闭欢迎界面（部分用户可能已经设置打开软件不显示欢迎界面），点击左上角菜单栏“File”，选择第一项“New Model”，弹出新页面；
选择模型，创建需要的概念模型
创建概念模型步骤
1.选择“Model types”
2.根据需求选择对应的模型，此处选择“Physical Data Model”
3.选择“Physical Diagram”
4.在页面中的“Model name”填写自己的名称
5.在下面的“DBMS”中选择你要生成的数据库类型。
完成软件概念模型的初步创建。
三、新建表 首先在右侧工具栏中选择建表工具。其中在“Physical Diagram”中选择有表格的这个图标，也就是下图标记的这个，把鼠标放上去会显示“Table”。点击以后在中间空白的地方选择放置的位置。
将表格放置好后，一定要鼠标右击取消一下，否则点击鼠标左键会持续建表
下图中左边的是在空白画布中创建的表，右边是对表的初始化设置。
需要注意的是书写Name的时候，Code自行补全，Name可以是英文的也可以是中文的，但是Code必须是英文的。
修改好表名以后还不着急点击确定，还需要对表中字段名进行设置：点击表设置的菜单栏中的“Columns”，进入字段名设置页面
Name: 实体名字一般为中文如论坛用户Code: 实体代号,一般用英文如XXXUserData Type：设置字段的类型，其中varchar(40)是字符串型，int是数字型Length：设置字段长度Precision：数据精度 PFM, P是主键，F是外键，M是非空
M:Mandatory强制属性，表示该属性必填，不能为空P:Primary Identifer是否是主标识符，表示实体店唯一标识符，即主键D:Displayed显示出来，默认全部勾选
此处我设置id为主键，用户id，账号account，密码password都不为空
点击“确定”后创建的表就出现在空白画布上了
四、显示SQL代码 右击新创建好的表，选择“SQL Preview…”，可以查看表的SQL代码
drop table if exists users; &lt;span class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08e5015253f50b184aaf4e2481ad34be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8708437ce87740c4f718419940d7985c/" rel="bookmark">
			滤波器原理及其作用计算机网络,滤波器的原理与作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录1.基本原理
2.滤波的概念
3.主要参数
4.作用
5.使用
滤波器是什么?滤波器是对波进行过滤的器件，一般有两个端口，一个输入信号、一个输出信号。可以说它是重要的电子元器件，滤波器把电源功率传输到设备上，大大衰减经电源传入的EMI电磁干扰信号，保护设备免受其害;同时，又能有效地控制设备本身产生的EMI信号，防止它进入电网，污染电磁环境，危害其他设备。那么滤波器的工作原理是如何的?作用又是什么呢?本文将介绍滤波器的原理、滤波概念以及作用。
图1 滤波器
1.基本原理
滤波器是由电感和电容组成的低通滤波电路所构成，它允许有用信号的电流通过，对频率较高的干扰信号则有较大的衰减。由于干扰信号有差模和共模两种，因此滤波器要对这两种干扰都具有衰减作用。其基本原理有三种：
(1)利用电容通高频隔低频的特性，将火线、零线高频干扰电流导入地线(共模)，或将火线高频干扰电流导入零线(差模);
(2)利用电感线圈的阻抗特性，将高频干扰电流反射回干扰源;
(3)利用干扰抑制铁氧体可将一定频段的干扰信号吸收转化为热量的特性，针对某干扰信号的频段选择合适的干扰抑制铁氧体磁环、磁珠直接套在需要滤波的电缆上即可。
图2 滤波器形状
2.滤波的概念
滤波是信号处理中的一个重要概念，滤波电路的作用是尽可能减小脉动的直流电压中的交流成分，保留其直流成分，使输出电压纹波系数降低，波形变得比较平滑。
图3 滤波前后波形
一般来说，滤波分为经典滤波和现代滤波。
经典滤波是根据傅里叶分析和变换提出的一个工程概念，根据高等数学理论，任何一个满足一定条件的信号，都可以被看成是由无限个正弦波叠加而成。
换句话说，就是工程信号是不同频率的正弦波线性叠加而成的，组成信号的不同频率的正弦波叫做信号的频率成分或叫做谐波成分。只允许一定频率范围内的信号成分正常通过，而阻止另一部分频率成分通过的电路，叫做经典滤波器或滤波电路。
图4 滤波时域与频域图
在经典滤波和现代滤波中，滤波器模型其实是一样的(硬件方面的滤波器其实进展并不大)，但现代滤波还加入了数字滤波的很多概念。
3.主要参数
通带带宽：指需要通过的频谱宽度，BW=(f2-f1)。f1、f2为以中心频率f0处插入损耗为基准。
带内波动(Passband Ripple)：通带内插入损耗随频率的变化量。1dB带宽内的带内波动是1dB。
纹波(Ripple)：指1dB或3dB带宽(截止频率)范围内，插损随频率在损耗均值曲线基础上波动的峰值。
延迟(Td)：指信号通过滤波器所需要的时间，数值上为传输相位函数对角频率的导数，即Td=df/dv。
带内相位线性度：该指标表征滤波器对通带内传输信号引入的相位失真大小。按线性相位响应函数设计的滤波器具有良好的相位线性度。
插入损耗(Insertion Loss)：由于滤波器的引入对电路中原有信号带来的衰耗，以中心或截止频率处损耗表征，如要求全带内插损需强调。
回波损耗(Return
Loss)：端口信号输入功率与反射功率之比的分贝(dB)数，也等于20Log10ρ，ρ为电压反射系数。输入功率被端口全部吸收时回波损耗为无穷大。
中心频率(Center
Frequency)：滤波器通带的频率f0，一般取f0=(f1+f2)/2，f1、f2为带通或带阻滤波器左、右相对下降1dB或3dB边频点。窄带滤波器常以插损最小点为中心频率计算通带带宽。
截止频率(Cutoff
Frequency)：指低通滤波器的通带右边频点及高通滤波器的通带左边频点。通常以1dB或3dB相对损耗点来标准定义。相对损耗的参考基准为：低通以DC处插损为基准，高通则以未出现寄生阻带的足够高通带频率处插损为基准。
带内驻波比(VSWR)：衡量滤波器通带内信号是否良好匹配传输的一项重要指标。理想匹配VSWR=1：1，失配时VSWR&gt;1。对于一个实际的滤波器而言，满足VSWR&lt;1.5：1的带宽一般小于BW3dB，其占BW3dB的比例与滤波器阶数和插损相关。
阻带抑制度：衡量滤波器选择性能好坏的重要指标。该指标越高说明对带外干扰信号抑制的越好。通常有两种提法：一种为要求对某一给定带外频率fs抑制多少dB，计算方法为fs处衰减量;另一种为提出表征滤波器幅频响应与理想矩形接近程度的指标——矩形系数(KxdB&gt;1)，KxdB=BWxdB/BW3dB，(X可为40dB、30dB、20dB等)。滤波器阶数越多矩形度越高——即K越接近理想值1，制作难度当然也就越大。
4.作用
(1)将有用的信号与噪声分离，提高信号的抗干扰性及信噪比;
(2)滤掉不感兴趣的频率成分，提高分析精度;
(3)从复杂频率成分中分离出单一的频率分量。
图5 滤波器外形
5.使用
为了提高电源的品质、电路的线性、减少各种杂波和非线性失真干扰和谐波干扰等均使用滤波器。对武器系统来讲，使用滤波器的场所有：
(1)除总配电系统和分配电系统上设置电源滤波器外，进入设备的电源均要安装滤波器，最好使用线至线滤波器，而不使用线至地滤波器。
(2)对脉冲干扰和瞬变干扰敏感的设备，使用隔离变压器供电时，应在负端加装滤波器。
(3)对含电爆装置的武器系统供电时，应加滤波器。必要时，电爆装置的引线也要加装滤波器。
(4)各分系统或设备之间的接口处，应有滤波器抑制干扰，确保兼容。
(5)设备和分系统的控制信号，其输入和输出端均应加滤波器或旁路电容器。
本文总结了滤波器的原理、滤波概念、参数、作用以及使用注意事项。滤波器种类繁多，各种滤波器具有不同的性能特点，因此在滤波器选择时，通常需要综合考虑客户的实际使用环境以及客户性能需求才能做出正确、有效、可靠的选择。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff71f524615da4e15f0a9e919ad77373/" rel="bookmark">
			死锁以及java模拟死锁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是死锁？ 死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。
产生原因 1. 竞争资源引起进程死锁 当系统中供多个进程共享的资源如打印机、公用队列的等，其数目不足以满足诸进程的需要时，会引起诸进程对资源的竞争而产生死锁。
2. 可剥夺资源和不可剥夺资源 系统中的资源可以分为两类，一类是可剥夺资源，是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺。例如，优先权高的进程可以剥夺优先权低的进程的处理机。又如，内存区可由存储器管理程序，把一个进程从一个存储区移到另一个存储区，此即剥夺了该进程原来占有的存储区，甚至可将一进程从内存调到外存上，可见，CPU和主存均属于可剥夺性资源。另一类资源是不可剥夺资源，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。
3.竞争不可剥夺资源 在系统中所配置的不可剥夺资源，由于它们的数量不能满足诸进程运行的需要，会使进程在运行过程中，因争夺这些资源而陷于僵局。
4.竞争临时资源 上面所说的打印机资源属于可顺序重复使用型资源，称为永久资源。还有一种所谓的临时资源，这是指由一个进程产生，被另一个进程使用，短时间后便无用的资源，故也称为消耗性资源，如硬件中断、信号、消息、缓冲区内的消息等，它也可能引起死锁。
死锁的四个必要条件 互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。环路等待条件：在发生死锁时，必然存在一个进程–资源的环形链。 预防死锁 理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和解除死锁。只要打破四个必要条件之一就能有效预防死锁的发生：
打破互斥条件：改造独占性资源为虚拟资源，大部分资源已无法改造。打破不可抢占条件：当一进程占有一独占性资源后又申请一独占性资源而无法满足，则退出原占有的资源。打破占有且申请条件：采用资源预先分配策略，即进程运行前申请全部资源，满足则运行，不然就等待，这样就不会占有且申请。打破循环等待条件：实现资源有序分配策略，对所有设备实现分类编号，所有进程只能采用按序号递增的形式申请资源。 避免死锁 1. 有序资源分配法
2. 银行家算法
检测死锁 首先为每个进程和每个资源指定一个唯一的号码；
然后建立资源分配表和进程等待表。
解除死锁 当发现有进程死锁后，便应立即把它从死锁状态中解脱出来，常采用的方法有：
剥夺资源：从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态；撤消进程：可以直接撤消死锁进程或撤消代价最小的进程，直至有足够的资源可用，死锁状态.消除为止；所谓代价是指优先级、运行代价、进程的重要性和价值等。 死锁检测 1、Jstack命令：jstack是java虚拟机自带的一种堆栈跟踪工具。
2、JConsole工具：Jconsole是JDK自带的监控工具，在JDK/bin目录下可以找到。
java代码模拟死锁 https://blog.csdn.net/gkmmg/article/details/79834006
参考博文：https://blog.csdn.net/hd12370/article/details/82814348
https://baike.baidu.com/item/%E6%AD%BB%E9%94%81/2196938?fr=aladdin#1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd45477b6a562bcaa4ca5725008bc1d0/" rel="bookmark">
			Golang 文件大小可视化ls工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 源码地址 点我
ls 文件大小可视化ls工具（适合初学者练手）
Usage git clone git@github.com:vua/ls.git cd ls go build ls.exe -h path Result 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a10c95c786b9c9df83558d903d99b09/" rel="bookmark">
			计算机网络拨号,个人拨号上网宽带连接设置图文方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多朋友买了电脑之后，不知道怎么上网，其实要实现上网需要满足3个条件。首先电脑必须安装有正确的网卡，并且驱动安装正常；另外还需要运营商的网线已正确接于电脑网卡接口中；最后最后还有猫(Modem)设备以及网络运行商提供给你的用于PPPOE拨号的帐号密码。以上基本条件具备了之后接下来就是简单的电脑网络宽带配置了，方法如下：
下面笔者以最基本的windows xp系统下为大家介绍个人拨号上网宽带设置方法，windows 7系统的设置方法与此类似，基本这个会了，windows 7系统也是一样的操作。
首先在我们桌面上找到“网上邻居”选种单击右键--选择“属性”如下图：
网上邻居 入口
在网上邻居上右键选择属性后，你应该看到一个打开的窗口并发现“本地连接”(如果未发现本地连接则代表电脑无网卡或网卡驱动程序没装好)，如下图所示：
网络连接窗口
由于我们是个人上网，所以必须创建一个新的连接，以便于我们拨号上网。如果是多人公用一根网线上网那么就需要路由器了，关于路由器多人上网设置，有兴趣的朋友可以参考：路由器设置图文教程 教你无线路由器怎么设置。这个我们介绍的是个人拨号上网，如上图指示所示例:我们点击“创建一个新的连接”之后的设置如下图演示：
进入创建一个新连接设置向导设置如下：
选择“连接到Internet”，然后点击“下一步”
选择“手动设置我的连接”，再点击“下一步”
选择“用要求用户名和密码的宽带连接来连接”，然后“下一步”
输入ISP名称，如输入你所用的宽带运营商的名字，或者随便填写
输入网络运营商提供给你的上网帐号、密码，并打上下面的勾，然后再点“下一步”。
在点击“完成”按纽之前，请选中“在我的桌面上添加一个到此连接的快捷方式”，这样你在桌面上可以看到一个刚才建立的连接
到这里拨号上网设置就基本结束了，返回到桌面我们可以看到刚才创建的一个宽带连接拨号快捷方式，下次开启电脑只需要点击该快捷方式输入上网账号与密码即可网上冲浪了，当然你也可以选择让系统记住上网账号密码，下次上网只需要连接即可，如下图：
宽带连接设置窗口
宽带连接设置的详细方法就为大家介绍到这里，这里主要涉及的是系统网络的配置与设置，完成以上步骤我们即可轻松实现网上冲浪了，如果您对以上个人拨号上网宽带设置有问题，可以到电脑百事社区的有问必答中提出，将得到第一时间回复！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/beae9617cbb331e0eb516045ba37242d/" rel="bookmark">
			定向士官计算机网络技术在部队干什么,定向培养士官是干什么的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定向培养士官，是指依托地方普通高等学校为部队定向培养技术复杂、培训周期较长的专业技术士官人才，毕业后补充到士官岗位服役。学制3年，毕业后取得大专学历。前2.5学年的全部课程由高校负责;后0.5学年为入伍实习期，由招收部队负责。
招收的定向培养士官毕业后，由所在部队按照权限下达士官任职命令，时间统一为毕业当年7月1日，其军衔等级和工资档次，比照同期入学从普通高等学校毕业生中直接招收士官确定。下达士官命令后执行现役士官的工资标准，享受现役士官相关待遇。批准服现役后首次授予军衔前，按义务兵新兵标准发放津贴。
定向培养士官待遇和福利都很不错，如果您有参军报国的想法，这是一个不错的选择!希望我的回答能够帮到你!
定向培养士官的报名及录取流程：
1、报名
考生须参加全国普通高校招生统一考试报名，填写相应高校“定向培养士官生”专业。
2、填报志愿
体检、政审、面试合格考生在高职(专科)阶段填报提前批次志愿。
3、体检和政审
考生所在地兵役机关组织体格检查和政治考核。省级招办部门、省级兵役机关将在官网提前公布参加体格检查和政治考核的考生名单。
4、面试
招收部队和高校于派员赴有招生任务的省(自治区、直辖市)，会同兵役机关对体检合格考生进行面试。
5、录取
我院从体格检查、政治考核和面试合格的报考考生中择优录取，发放录取通知书。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7f7bc6c5372a37b3ec2c620b8d12f2a/" rel="bookmark">
			Excel的各Sheet 转csv文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 import xlrd import pandas as pd import os def excel2csv(excel_file): # 打开excel文件 workbook=xlrd.open_workbook(excel_file) # 获取所有sheet名字 sheet_names=workbook.sheet_names() for worksheet_name in sheet_names: # 遍历每个sheet并用Pandas读取 data_xls=pd.read_excel(excel_file,worksheet_name,index_col=None) # 获取excel当前目录 dir_path=os.path.abspath(os.path.dirname(excel_file)) # 转换成csv并保存到excel所在目录下的csv文件夹中 csv_path=dir_path+'\\csv\\' if not os.path.exists(csv_path): os.mkdir(csv_path) data_xls.to_csv(worksheet_name+'.csv',index=None,encoding='utf-8') excel2csv(r'/Users/wang/Desktop/python/总表.xlsx') 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b0db06a254e202e22fa1deb2f48eadc/" rel="bookmark">
			UE4实时渲染需要注意的点——RTR（Real Time Rendering）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、性能与质量 这是一幅关于性能与质量的表达图示，
需要指出的是，只要有渲染，性能是必定会受影响的。
而好的渲染和糟糕的渲染之区别在于，取舍的平衡。
一般的TargetFramerate，假设为30FPS，在我们的渲染已经无限接近30FPS的情况时，我们应该在保持这个帧率的前提下，尽可能的将渲染质量提高；
或者换种说法，在我们追求高品质渲染的同时，将帧率维持在我们需要的目标帧率。
同时，如果渲染到一定阶段的时候，帧率确实已经达到目标帧率，如30FPS了，那么此时就没有必要花费精力在，把帧率提升到60FPS这样了，这样没有必要，不如花费精力在维持这个关系平衡点。
RTR是不可能完美的，要学会在实际渲染时，有所取舍，达到一个使Performance、Quality、Features三者达到平衡的点即可。（除非未来有强大的硬件支持，我觉得）
虽然称之为实时渲染，但并非所有内容都是及时渲染的，仍有许多内容会在预渲染阶段完成。所以实际上，很多功能的渲染采取的都是混合渲染。
当然这除了是为质量考虑，也是为了尽可能的高效。
另外，对资源和内容严格把控使用，也是为了高效。
2、硬件的协同 这是渲染时，硬件的协同图示，数据从硬盘，通过带宽读取到内存，由CPU或GPU与内存交换数据达到数据传输效果。
大家比较清楚的是CPU和GPU的计算与渲染功能不可或缺，实际上，渲染的高效性也特别依赖带宽，这也是我们常常忽略的一点。
有时CPU计算数据太多，我们可能会把计算放在GPU一部分，以平衡性能。由于多数情况下，GPU和CPU数据是需要同步的，所以这两者慢的那一个将成为另一个的拖油瓶，成为性能的制约因素。
3、实时渲染的两种方式 两种方式为Deferred延迟渲染和Forward前向渲染
Deferred延迟渲染特点：（UE4的默认渲染状态）
1.Shading happens in deferred passes
着色发生在延迟环节中（称之为延迟渲染的原因）
2.Works compositing based using the GBuffer
工作合成基于G缓存(GBuffer)，G缓存是一组图像，引擎不会把所有的图像渲染出来，而是将信息存储到G缓存中，并且将其中信息延迟到稍后渲染，例如着色和光照不会和几何体渲染同时完成，UE4会先渲染几何体，再延迟渲染光照，然后再与之前的几何体进行混合
3.Good at rendering dynamic lighting
善于动态照明渲染
4.Good at stable predictable high end performance
善于稳定可预测的高端性能
5.More flexible when it comes to disabling features,less flexible when it comes to surface attributes
在禁用特性时更灵活，在表面属性时则不那么灵活，
在涉及即时开启或关闭功能时更加灵活
6.No MSAA possible,relies on TAA
不能用多重采样抗锯齿（MSAA），完全依赖临时抗锯齿（TAA）
Forward前向渲染特点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b0db06a254e202e22fa1deb2f48eadc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a86ea49aa19e81df43928df366a87218/" rel="bookmark">
			如何关闭计算机远程桌面连接,怎么用命令行开启和关闭远程桌面？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		满意答案
小a乄酱
2016.03.20
采纳率：51% 等级：8
已帮助：1362人
以XP电脑为例。
1. 先在主机上用mstsc远程登入域控，再使用域控的“计算机管理”连接到那台xp远程主机tel02，确认“服务”项目中远程主机的Remote Registry、Telnet、Terminal Services服务都已经开启了。最后再利用命令行启用远程主机的远程桌面：
2. telnet到远程主机上:telnet tel02 输入username、password，稍等一会儿后，看到了命令行下的提示符： C:\ 说明已经成功登入tel02主机了。
3. 接着运行以下命令：
copy con term.bat
echo Windows Registry Editor Version 5.00&gt;3389.reg
echo [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server]&gt;&gt;3389.reg
echo "fDenyTSConnections"=dword:00000000&gt;&gt;3389.reg
echo [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\Wds\rdpwd\Tds\tcp]&gt;&gt;3389.reg
echo "PortNumber"=dword:00000d3d&gt;&gt;3389.reg
echo [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp]&gt;&gt;3389.reg
echo "PortNumber"=dword:00000d3d&gt;&gt;3389.reg
regedit /s 3389.reg
del 3389.reg
del term.bat
^Z
4. 跟着在C盘根目录下建立了一个名为term.bat的批处理文件。批处理内容是：先建立一个与开启远程桌面有关的注册表文件3389.reg，然后运行3389.reg，将3389.reg的文件内容导入系统注册表，最后是删除3389.reg以及term.bat自身。
5. 最后一步：运行term.bat。
注：用不着重启远程主机，在我的主机上运行mstsc连接tel02主机，毫无意外的出现了远程主机的登录界面。
00分享举报
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38eaa54dbec47742159b7de73c0bf344/" rel="bookmark">
			bat脚本语言记录：set 命令与变量使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		变量的使用格式
[设置变量]
格式：set 变量名=变量值
详细：被设定的变量以%变量名%引用
[引用变量]
格式: %变量名%
详细: 可以用echo %变量名%打印变量的只
[取消变量]
格式：set 变量名=
详细：取消后的变量若被引用%变量名%将为空
[展示变量]
格式：set 变量名
详细：展示以变量名开头的所有变量的值
[列出所有可用的变量]
格式：set
[计算器]
格式：set /a 表达式
示例：set /a 1+2*3
输出 7
预定义的变量
下面是些已经被底层定义好可以直接使用的变量：不会出现在 SET 显示的变量列表中
%CD% - 扩展到当前目录字符串。%DATE% - 用跟 DATE 命令同样的格式扩展到当前日期。%TIME% - 用跟 TIME 命令同样的格式扩展到当前时间。%RANDOM% - 扩展到 0 和 32767 之间的任意十进制数字。%ERRORLEVEL% - 扩展到当前 ERRORLEVEL 数值。%CMDEXTVERSION% - 扩展到当前命令处理器扩展名版本号。%CMDCMDLINE% - 扩展到调用命令处理器的原始命令行。%0 bat的完整路径名如"C:\Windows\system32\xxx.bat"%1 bat参数1 依次类推%2参数2…%path% - 当前的环境变量。以分号隔开的路径列表，路径可包含空格，可以以’'结尾, 可以以双引号包围之。 扩展变量
@ 与%i相关的变量（bat参数或者for循环的%i)
假设文件为C:\Documents and Settings\jinsun\桌面\ParseSinglePkgs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38eaa54dbec47742159b7de73c0bf344/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96381be4d23ee5901e15bbc665359bcf/" rel="bookmark">
			手写koa2源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.node创建http服务 ./create-node-server.js：
const http = require("http"); const server = http.createServer((req, res) =&gt; { res.end("hello node"); }); server.listen(3001, () =&gt; { console.log("server at 3001"); }); 二.使用koa2创建服务 ./index.js:
const Koa = require("koa"); const app = new Koa(); app.use(ctx =&gt; { ctx.body = { name: "Tony" }; }); app.listen(3000, () =&gt; { console.log("server at 3000"); }); 三.手写koa初始源码 const http = require("http"); class Koa { constructor() {} use(callback) { this.callback = callback; } listen(.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96381be4d23ee5901e15bbc665359bcf/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/198/">«</a>
	<span class="pagination__item pagination__item--current">199/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/200/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>