<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec2730e636bec83db71fa6146adfa953/" rel="bookmark">
			AI大模型参数介绍中的5B、7B是何意？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AIGC大模型参数的5B、7B是指模型中可训练参数的数量。这里的“B”表示10亿（Billion），即10^9。因此，5B表示50亿个可训练参数，7B表示70亿个可训练参数。这些参数是神经网络中的权重和偏置，它们在训练过程中通过反向传播算法进行更新，以使模型能够更好地拟合训练数据。
随着深度学习技术的发展，模型的规模越来越大，参数数量也越来越多。这是因为更大的模型具有更强的表达能力，可以捕捉到更复杂的特征和模式。然而，这也带来了一些问题，如计算资源需求增加、训练时间延长以及过拟合风险提高等。因此，研究人员需要在模型规模和性能之间找到一个平衡点。
为了解决这个问题，研究人员提出了许多技术，如模型压缩、知识蒸馏、迁移学习等。这些技术可以在保持模型性能的同时，降低模型的参数数量和计算复杂度。此外，还有一些硬件加速器，如图形处理器（GPU）和专用集成电路（ASIC），可以加速模型的训练和推理过程。
在实际应用中，选择合适的模型规模是非常重要的。如果模型太小，可能无法捕捉到数据中的关键特征，导致性能不佳。相反，如果模型太大，可能会导致过拟合问题，使得模型在未见过的数据上表现不佳。因此，研究人员需要根据具体的任务和数据集来选择合适的模型规模。
在选择模型规模时，可以考虑以下几个因素：
1. 数据集的大小：较大的数据集通常需要较大的模型来捕捉其中的特征。然而，过大的模型可能会导致过拟合问题。因此，需要根据数据集的大小来调整模型规模。
2. 任务的复杂性：不同的任务可能需要不同规模的模型。例如，图像分类任务通常需要较大的模型来捕捉图像中的复杂特征，而文本分类任务可能只需要较小的模型。
3. 计算资源：较大的模型需要更多的计算资源来进行训练和推理。因此，在有限的计算资源下，可能需要选择较小的模型规模。
4. 性能要求：根据任务的性能要求，可以选择适当规模的模型。例如，对于一些高精度的任务，可能需要选择较大的模型来提高性能。
【小熊AI网原创xiaoxiong360.com】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/304803bb2d49f36685d1a3bcb598e890/" rel="bookmark">
			这才是程序员未来的工作模式！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果工作也有“寒、暑”假；如果边工作还能边旅游；如果回乡工作还能拿到和一线城市差不多的高薪…
也许是经历的多了，越来越多的人渴望追求工作与生活的平衡，他们看透了996，也见多了办公区凌晨5点的太阳；
他们又何尝不想多一些时间去交友，去谈谈恋爱；去户外感受自然的"阳光”；他们看透了中年危机，运气好，趁着年轻疯狂“挣钱”；运气不好，在追求稳定还是成长的思维中反复纠结，充斥着整个职业生涯。
或许这就是这个时代的缩影，亦或是现在社会阶段的规则，而我们要做的就是打破规则，让工作可以更自由，生活可以更美好！
大家好！我们是猿派，一家以实现程序员“自由工作，美好生活”为愿景的公司！
在猿派平台上，你可以回乡全职远程办公，可以边旅游边接不同城市的驻场工作，也可以合规的接海外高薪项目，就算你对生活没有规划，也没有关系！
只要是在我们平台上工作的程序员，对于生活、对于玩，我们来安排！
我们会定期为大家组织技术沙龙、聊天交友趴、吐槽大会、户外运动等多种形式的社区活动。
也会积极帮大家争取一些旅游福利，满足大家任何时期的出行需求！充分保障大家在工作之余还能保持身心健康！
为什么选择猿派？
一、400+企业与猿派建立合作
目前我们已与400+企业建立合作，为程序员提供短期、长期、远程等多种方式的工作。
平台也会继续大力邀请更多企业入驻，为程序员提供更多的岗位机会，最终实现自由工作的美好蓝图！
二、现在我们还很小
小到产品还不是很成熟，或许有这样那样的问题，对此我们非常欢迎大家对我们提出宝贵的意见或建议。
三、当然我们也很大
大到承载了众多有种同样想法的程序员，对实现自由工作美好生活的向往！
我们的故事才刚刚开始，未完待续…
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ab45a913b21d8e8eaf6e2a8a275fd15/" rel="bookmark">
			在vue中实现在线代码编辑器之CodeMirror
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# 前言 由于项目需求，需要完成一个支持代码提示、代码校验、代码格式化的页面代码编辑器
1 技术选型 精力有限，只了解了几个主流的编辑器codemirror、ace、Monaco Editor、vue-web-terminal等等。本文只介绍codemirror的使用。
2 使用效果 先上效果图：
再看下有内容的效果：
虽然比较简单，但是最基本的缩进、高亮显示、缩放展开等基础功能还是有的。其实还包含了许多文件类型的语法校验。
后续使用中发现，给这个编辑器的内容赋值时，开头总是有个小红点。而经过反复检查传递的文件内容，并没有小红点，这个小红点也不会加在内容中传递出去，于是我发现codemirror的一些比较常用的配置项。
3 代码实现 先看实际我使用的配置项：
data() { return { value: '', /** @type {import('@types/codemirror/index').EditorConfiguration} */ codemirrorOptions: { // specialChars: '/[\u0000-\u0019\u00ad\u200b-\u200f\u2028\u2029\ufeff]/', //默认值 // specialCharPlaceholder: '', //默认值 // eslint-disable-next-line no-control-regex // specialChars: /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff\ufff9-\ufffc]/g, // specialCharPlaceholder: function (ch) { // let token = document.createElement("span"); // let content = "\u002e"; // token.className = "cm-invalidchar"; // if (typeof content == "string") { // token.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ab45a913b21d8e8eaf6e2a8a275fd15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/748469388456414c1cc1f5c518a523f2/" rel="bookmark">
			xcode15一直显示正在连接iOS17真机问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 更新xcode15之后，出现了各种报错问题，可谓是一路打怪啊，解决一个报错问题又来一个。没想到到了最后还能出现一个一直显示正在连接iOS17真机的问题
一直显示正在连接iOS17真机的问题 问题截图如下：
解决方法 1. 打开Devices and Simulators，查看，发现当前真机一直处于正在连接状态，并且默认的connect via network一直处于勾选状态，而且还不能去掉勾选 最终我发现我的网络开着VPN的，尝试关掉VPN后，发现最终解决了这个问题 2. 点击Show run destination选项，选择Always即可 3. 更新最新的iphone17 Simulator， 大概7.2GB。更新完就没这个问题了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a2c8d3db244eaa58024f280b396f457/" rel="bookmark">
			python基于flask写后端实操笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、基于flask写后端接口1.1、接口可以调用其他类成员示例1.2、接口的入参是多个的示例1.3、接口的入参是路径的示例1.4、接口的入参是数组的示例1.5、接口的入参是list的示例 二、调用类型GET、POST、DELETE之间的区别三、跨域设置四、接收数据的方式以及请求方式一：放文件路径上方式二：form data 五、如果后端返回的数据前端接收不到六、调用说明七、返回中文编码问题 一、基于flask写后端接口 1.1、接口可以调用其他类成员示例 from flask import Flask app = Flask(__name__) class Database: def __init__(self): self.data = [] def add_item(self, item): self.data.append(item) def get_items(self): return self.data db = Database() @app.route('/api/add_item/&lt;item&gt;', methods=['POST']) def add_item(item): db.add_item(item) return 'Item added successfully.' @app.route('/api/get_items', methods=['GET']) def get_items(): items = db.get_items() return ', '.join(items) if __name__ == '__main__': app.run(debug=True) 1.2、接口的入参是多个的示例 from flask import Flask app = Flask(__name__) @app.route('/api/user/&lt;username&gt;/profile/&lt;int:age&gt;', methods=['GET']) def get_user_profile(username, age): # 使用username和age进行相关操作 return 'Username: {}, Age: {}'.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a2c8d3db244eaa58024f280b396f457/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b006237fb9413d6bfa2c7e954d660f7/" rel="bookmark">
			Centos安装Sonatype Nexus Repository教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
0x00 Nexus简介
0x01 详细安装步骤
1.更新系统
2.安装 Java
3.解压 Nexus
4.移动目录
5.创建 Nexus 用户和组
6.修改 Nexus 目录权限
7.配置 Nexus 作为服务
8.启用 Nexus 服务
9.访问 Nexus
0x00 Nexus简介 Nexus 是一个开源的仓库管理器（repository manager），用于管理和分发软件组件、构建和部署制品。它是一个用于构建和管理软件开发生命周期的工具。
Nexus 提供了一个集中化的存储库，用于存储和管理开发团队使用的各种软件组件，如库文件、依赖项、插件、构建工具等。它允许开发人员通过 Maven、Gradle、NuGet、npm 等常用的构建工具来访问和下载这些组件。
主要功能和特点包括：仓库管理、依赖管理、安全和权限管理、构件部署、代理和缓存、插件和扩展。
0x01 详细安装步骤 本安装教程使用的资源版本如下：
OS：CentOS 7.6 64bit
JDK：jdk-8u251-linux-x64.rpm
Nexus：nexus-3.61.0-02-unix.tar.gz
JDK、Nexus可以在对应的官网下载，下面是对应的官网下载地址：
JDK可以在官网下载地址Java Downloads | Oracle
Nexus官网下载地址Download Nexus Repository OSS | Sonatype
1.更新系统 首先，使用 root 用户登录到你的 CentOS 7 服务器，并确保系统是最新的。运行以下命令更新系统：
yum update -y 可以根据自己的实际情况决定是否需要更新系统。
2.安装 Java Nexus 是基于 Java 的应用程序，所以你需要安装 Java 运行时环境（JRE）。运行以下命令安装 JDK：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b006237fb9413d6bfa2c7e954d660f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74c86c29c4d3ec3a82513f51f35b65e6/" rel="bookmark">
			Verilog功能模块——同步FIFO
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FIFO系列文章目录：
Verilog功能模块——异步FIFO-CSDN博客
Verilog功能模块——同步FIFO-CSDN博客
Verilog功能模块——读写位宽不同的异步FIFO-CSDN博客
Verilog功能模块——读写位宽不同的同步FIFO-CSDN博客
Verilog功能模块——标准FIFO转FWFT FIFO-CSDN博客
前言 同步FIFO实现起来是异步FIFO的简化版，所以，本博文不再介绍FIFO实现原理，感兴趣的同学可以去看我异步FIFO的文章，基本看懂了异步FIFO，同步FIFO自然就懂了。
二. 模块功能框图与信号说明 信号说明：
分类信号名称输入/输出说明参数DATA_WIDTH–数据位宽ADDR_WIDTH–地址位宽，FIFO深度=2**ADDR_WIDTHFWFT_EN–First word fall-through输出模式使能，高电平有效FIFO写端口dininputFIFO数据输入wr_eninputFIFO写使能fulloutputFIFO满信号almost_fulloutputFIFO快满信号，FIFO剩余容量&lt;=1时置高FIFO读端口doutoutputFIFO数据输出rd_eninputFIFO读使能emptyoutputFIFO空信号almost_emptyoutputFIFO快空信号，FIFO内数据量&lt;=1时置高时钟与复位clkinputFIFO读时钟rstinputFIFO读复位 注意：
信号的命名与Vivado中的FIFO IP核完全一致复位均为高电平复位，与Vivado中的FIFO IP核保持一致复位为异步复位FIFO深度通过ADDR_WIDTH来设置，所以FIFO的深度必然是2的指数，如2、4、8、16等 三. 部分代码展示 //++ 生成读写指针 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ reg [ADDR_WIDTH:0] rptr; always @(posedge clk or posedge rst) begin if (rst) rptr &lt;= 0; else if (rd_en &amp; ~empty) rptr &lt;= rptr + 1'b1; end reg [ADDR_WIDTH:0] wptr; always @(posedge clk or posedge rst) begin if (rst) wptr &lt;= 0; else if (wr_en &amp; ~full) wptr &lt;= wptr + 1'b1; end wire [ADDR_WIDTH-1:0] raddr = rptr[ADDR_WIDTH-1:0]; wire [ADDR_WIDTH-1:0] waddr = wptr[ADDR_WIDTH-1:0]; wire [ADDR_WIDTH:0] rptr_p1 = rptr + 1'b1; wire [ADDR_WIDTH:0] wptr_p1 = wptr + 1'b1; //-- 生成读写指针 ------------------------------------------------------------ //++ 生成empty与almost_empty信号 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ always @(*) begin if (rst) empty &lt;= 1'b1; else if (rptr == wptr) empty &lt;= 1'b1; else empty &lt;= 1'b0; end always @(*) begin if (rst) almost_empty &lt;= 1'b1; else if (rptr_p1 == wptr || empty) almost_empty &lt;= 1'b1; else almost_empty &lt;= 1'b0; end //-- 生成empty与almost_empty信号 ------------------------------------------------------------ //++ 生成full与almost_full信号 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ always @(*) begin if (rst) full &lt;= 1'b1; else if ((wptr[ADDR_WIDTH] !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74c86c29c4d3ec3a82513f51f35b65e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/989382499ec18445ea92ff2ba6262db2/" rel="bookmark">
			IT行业哪个方向比较好就业?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IT行业哪个方向比较好就业? 目前IT行业的发展速度非常的快，很多领域都已经开始和IT技术进行紧密的结合，这也带来了很多岗位的空缺。那么就一起来说说，IT行业里，哪些方向会更好就业。
方向一：IT技术发展背景及历程
IT技术的发展背景可以追溯到20世纪40年代末的第二次世界大战期间。当时，计算机技术的发展取得了重大突破，电子管和继电器被用于构建计算机系统，首次实现了电子计算机的运行。
随着时间的推移，计算机技术不断演进，从早期的大型机和迷你机发展到个人计算机。20世纪60年代和70年代，计算机领域出现了许多重要的技术突破，如集成电路的发明和微处理器的出现，使得计算机变得更小、更快、更便宜。
20世纪80年代和90年代，个人计算机的普及推动了IT技术的快速发展。图形用户界面（GUI）的出现使计算机更加易用，互联网的商业化应用也开始兴起。此外，移动通信技术的发展也为IT技术的普及和应用提供了支持。
进入21世纪，云计算、大数据、人工智能等新兴技术的兴起推动了IT技术的进一步发展。云计算使得计算资源可以通过网络进行共享和访问，大数据技术可以处理和分析庞大的数据集，人工智能技术可以模拟和实现人类智能的某些方面。
当前，IT技术的发展呈现出多样化和综合化的趋势。移动互联网、物联网、区块链、虚拟现实等新兴技术不断涌现，为各行各业带来了巨大的变革和机遇。同时，随着数字化转型的推进，IT技术在企业和社会中的应用也变得更加广泛和深入。
方向二：IT行业的就业方向有哪些？
IT行业的就业方向非常广泛，以下是一些常见的就业方向：
1. 软件开发：包括前端开发、后端开发、移动应用开发等。这是IT行业最常见的就业方向之一，需求量大。
2. 网络与系统管理：包括网络工程师、系统管理员、数据库管理员等。这些职位负责维护和管理网络和系统的正常运行。
3. 数据分析与人工智能：包括数据分析师、机器学习工程师、人工智能专家等。这些职位负责处理和分析大数据，并应用人工智能技术解决问题。
4. 信息安全与网络安全：包括信息安全工程师、网络安全专家等。这些职位负责保护信息系统和网络的安全，预防和应对安全威胁。
5. 项目管理与咨询：包括IT项目经理、IT咨询师等。这些职位负责规划、组织和管理IT项目，并提供专业咨询服务。
6. 用户体验与界面设计：包括用户体验设计师、界面设计师等。这些职位负责设计和优化软件和网站的用户体验和界面。
7. 云计算与大数据：包括云计算工程师、大数据工程师等。这些职位负责构建和管理云计算平台，处理和分析大规模数据。
8. 游戏开发与设计：包括游戏程序员、游戏设计师等。这些职位负责开发和设计电子游戏，包括游戏逻辑、图形效果等。
除了以上方向，还有许多其他的就业方向，如物联网、区块链、虚拟现实等新兴技术领域。根据个人的兴趣和专业背景，可以选择适合自己的就业方向。
方向三：分享在IT行业的就业经历
1. 学习和提升技能：IT行业变化快速，持续学习和提升技能非常重要。不断跟进最新的技术趋势，参加培训课程或获得相关认证，可以增加自己的竞争力。
2. 实践项目经验：在学习的同时，尽量参与实际项目或实习，积累项目经验。这可以展示您的实际能力和解决问题的能力，同时也有助于建立自己的专业网络。
3. 建立专业网络：加入相关的行业组织、参加行业活动、参与技术社区等，与同行交流和分享经验，扩大自己的人脉。这些人脉关系可能会为您提供就业机会或职业发展的建议。
4. 准备好简历和面试：撰写一份清晰、简洁、重点突出的简历，突出自己的技能和经验。在面试前，了解公司和职位要求，准备好回答常见的面试问题，并展示自己的优势和适应能力。
5. 持续发展个人品牌：在社交媒体和专业平台上展示自己的技能和成果，参与技术论坛和博客，发布有价值的内容，提升自己的个人品牌和影响力。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6eaf5ceab76499decf4b6420074c10b4/" rel="bookmark">
			linux下创建文件夹软链接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软链接：
软链接是Linux下常用的一种共享文件方式、目录的方式，这种方式类似于Windows下的快捷方式。一般一个文件或者目录在不同的路径都需要的时候，可以通过创建软链接的方式来共享，这样系统下面只有一份源文件、目录。另外，巧用软链接，可以大大增加应用程序的可移植性。
软链接创建与删除
软链接创建与删除比较简单，使用ln命令创建链接文件，格式如下：
ln -s [源文件或目录] [目标文件或目录] 示例：
建立一个指向/usr/local/www的软链接到/tmp下面：
$: ln -s /usr/local/www /tmp/www $: ls /tmp/www -l $: lrwxrwxrwx 1 fens fens 14 9月 12 08:56 www -&gt; /usr/local/www 删除软链接：
rm /tmp/www 注意：删除的时候，如果是目录，结尾时，不要加"/",不然会把指向的目录给删掉！
软链接使用技巧：
共享目录文件
一般做嵌入式Linux开发，linux的虚拟机都会安装好多平台的交叉编译器，这些编译器可能会用到一些库，库在使用的时候，需要将头文件放到编译器路径下面
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb7400581fb83bb41a7ebb488f741150/" rel="bookmark">
			Kafka-Java二：Spring配置kafka消息发送端的缓冲区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、涉及到的组件概念 1.1、缓冲区
1.2、本地线程
1.3.本地线程消息推送策略
二、各组件的解释参见代码注释 // 配置消息的缓冲区 /** 设置消息发送者端的缓冲区大小，如果设置了缓冲区，消息会先发送到缓冲区，可以提供发送性能 * 默认大小是32M */ props.put(ProducerConfig.BUFFER_MEMORY_CONFIG,33554432); // 配置消息的本地线程 /** 设置消息发送者端的本地线程拉取策略 * 本地线程会从缓冲区中拉取消息 * 设置批量拉取消息的大小,默认是16kb,即本地线程从缓冲区中batch满了16kb的消息后就会发送出去 **/ props.put(ProducerConfig.BATCH_SIZE_CONFIG,16384); // 设置本地线程中消息发送出去的时间 /** * 默认值是0,意思是在拉取到消息以后就立马发送出去 * 一般设置为10,表示不管本地线程有没有从缓冲区拉取够16kb的消息，在10ms后，都必须要拉取到的消息发送出去 */ props.put(ProducerConfig.LINGER_MS_CONFIG,10); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a86b1aedfdef5df6581e83223e54fb92/" rel="bookmark">
			SQL的IF使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
1、IF表达式
2、CASE WHEN表达式：
3、IFNULL表达式
MySQL的IF既可以作为表达式用，可在存储过程中作为流程控制语句使用。
1、IF表达式 IF(expr1,expr2,expr3)
expr1 是TRUE (expr1 &lt;&gt; 0 and expr1 &lt;&gt; NULL)，则 IF()的返回值为expr2; 否则返回值则为 expr3。
IF() 的返回值为数字值或字符串值，具体情况视其所在语境而定
SELECT IF(sex=1,"男","女") AS s FROM t_user; 2、CASE WHEN表达式： SELECT CASE sex WHEN 1 THEN '男' ELSE '女' END AS s FROM table_name WHERE sex != ''; 3、IFNULL表达式 IFNULL(expr1,expr2)
expr1 不为 NULL，则 IFNULL() 的返回值为 expr1; 否则其返回值为 expr2。IFNULL()的返回值是数字或是字符串，具体情况取决于其所使用的语境
SELECT IFNULL(2,0); -&gt; 2 SELECT IFNULL(NULL,1); -&gt; 1 SELECT IFNULL(1/0,'ok'); -&gt; 'ok' 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bad734c8647999331fea1de28db74310/" rel="bookmark">
			Windows上安装绿色版mysql-8.0.26
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以8.0.26为例
1.安装包下载 下载地址：https://dev.mysql.com/downloads/mysql/ 下载后文件如图所示：
解压压缩包，并修改文件夹名称为mysql：
2.创建配置文件 在E:\mysql（MySQL解压目录）文件夹下，创建my.ini文件，主体内容为：
my.ini
[client] port = 3306 default-character-set = utf8mb4 [mysql] default-character-set = utf8mb4 [mysqld] character-set-server = utf8mb4 port = 3306 basedir = E:\mysql datadir = E:\mysql\data lower_case_table_names = 1 default_authentication_plugin = mysql_native_password disable-log-bin default-storage-engine = InnoDB max_connections = 150 max_allowed_packet = 1024M innodb_log_file_size = 64M innodb_log_buffer_size = 1024M innodb_buffer_pool_size = 4096M transaction_isolation = READ-COMMITTED default-time-zone = '+8:00' tmp_table_size=512M max_allowed_packet=64M 3.初始化数据库 以管理员打开命令行
切换至mysql解压目录
执行初始化命令：.\mysqld.exe --initialize --console
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bad734c8647999331fea1de28db74310/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0752c2c39124295d14534fae2f7c77b5/" rel="bookmark">
			java遍历数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		public static void main(String[] args) {
//定义数组 int[] array={1,2,3,4,5,6,7,8,9};
for (int i = 0; i &lt; 9; i++) {
System.out.println(array[i]);
}
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9de52a494875177528acafa363c396bf/" rel="bookmark">
			linux网络测试命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一.route命令解释二.traceroute命令三.nslookup命令四.本地主机映射文件五.修改网络配置文件六.设置网络接口参数 一.route命令解释 Destination（目标）：这一列显示要路由的目标网络或主机的IP地址。它标识了数据包要发送到的目的地。Gateway（网关）：此列显示用于将数据包传输到目标网络或主机的下一跳路由器的IP地址。如果数据包的目标与本地网络相同，该列将显示本地网络的IP地址。Genmask（子网掩码）：这一列显示目标网络的子网掩码。子网掩码用于确定哪些位被视为网络位和主机位。Flags（标志）：此列显示与路由条目相关的标志。常见的标志包括 G（网关，表示目标是通过网关进行路由）、U（启用，表示路由是活动的）和H（主机，表示目标是单个主机）等。Metric（度量）：该列显示路由的度量值。度量用于确定数据包传输的优先级，较小的度量意味着更优先传递。Ref（引用）：此列显示对路由的引用计数。引用计数表示有多少个其他路由表条目引用了该路由。Use（使用）：这一列显示路由的使用计数。使用计数表示有多少个数据包已经使用了该路由。Iface（接口）：该列显示数据包将通过的网络接口，如eth0、wlan0等。
Destination Gateway Genmask Flags Metric Ref Use Iface
192.168.1.0 0.0.0.0 255.255.255.0 U 600 0 0 enp3s0
10.0.0.0 192.168.1.1 255.255.255.0 UG 0 0 0 enp3s0
在这个例子中，路由表包含两个条目。
第一个条目的目标是192.168.1.0，网关是0.0.0.0，子网掩码是255.255.255.0，标志为U（启用），度量为600。这意味着当要发送到192.168.1.0/24网络的数据包时，它将被直接发送到接口enp3s0，而不使用网关。
第二个条目的目标是10.0.0.0，网关是192.168.1.1，子网掩码是255.255.255.0，标志为UG（网关、启用），度量为0。这意味着当要发送到10.0.0.0/24网络的数据包时，它将首先发送到位于本地网络192.168.1.0/24上的网关192.168.1.1，由该网关进一步路由到目标网络。接口enp3s0将用于跟网关通信。 二.traceroute命令 测试从当前主机到目的主机之间经过的网络节点
traceroute 目标主机地址 traceroute命令可以用于测试从当前主机到目的主机之间经过了哪些网络结点，并显示各中间结点的连接状态(响应时间)。对于无法响应的结点，连接状态将显示为"*"。
三.nslookup命令 测试DNS域名解析
nslookup 目标主机地址 [DNS服务器地址] Server是指DNS服务器地址
Addres是指解析出的ip
域名解析配置文件查看与修改 resolv.conf
/etc/resolv.conf 文件中记录了本机默认使用的DNS服务器的地址信息，对该文件所做的修改将会立刻生效。
Linux系统中最多可以指定3个（第3个以后的将被忽略)不同的 DNS 服务器地址，优先使用第1个 DNS服务器。
resolv.conf 文件中的 “search localdomain” 行用来设置默认的搜索域(域名后缀)。例如，当访问主机“localhost”时,就相当于访问“localhost.localdomain”
四.本地主机映射文件 /etc/hosts文件
保存主机名与IP地址的映射记录
这里可以修改IP和对应的主机名或者域名，例如你想要访问
若在/etc/hosts 文件中添加“192.168.109.11 www.zhangbin.com”的映射记录，则当访问网站 www.zhangbin.com 时，将会直接向 IP 地址 192.168.109.11 www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9de52a494875177528acafa363c396bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e04ffb43394be966fbc9dcde95de1b71/" rel="bookmark">
			【JS学习笔记】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JS学习笔记 HTML和CSS相关知识点 什么是选择器？.xxx{} ,#xxx{} ,xxx{}, *xxx{},HTML中的&lt;body&gt;的JS会在页面加载时被执行&lt;head&gt;的JS会预先加载，但在被调用时才执行JS中如何获取html元素：document.querySelector('选择器')html 元素如何插入：containerMovements.insertAdjacentHTML('afterbegin',html) containerMovements.innerHTML JS小知识点 1. JS 的[ ] 引用表达式，比如
jonas[interest],interest = 'job'可以访问到Jonas对象的job属性
[ ]内还可以是各种加减乘除形式的表达式，比如['day-${2+4}'] : {open:0;close:24}
2. JS的this 表示指向当前对象，注意：在函数中的函数如果有this将会使得其指向undefined，解决方法为用bind()，或者箭头函数，因为箭头函数对象不会被获取到。this 的好处在于，对象被赋值到新变量时，不需要更改内部的名称，只要属性一致就可以复用this.year，进而使用method borrowing
3. the spread operator 和 the rest pattern是相反的 前者将一个变量(arr)形成多个新变量(3,4,5)const newArr = [1,2,...arr]; ，
后者将多个变量(2,3)形成一个新变量(number)const add = function(...number){console.log(number);} add(2,3); add(2,3,4)。
4. JS 的短路： 短路||：一真(且非0，非undefined，非空)则真；
短路&amp;&amp;：一假则假，非假则后；
短路??：一真(且非undefined，非空)则真。
运算符返回内容不返回内容&amp;&amp;第一个falsy value 或 last value??第一个非null valuenull，undefined 5. JS 的entries： menu.entries() 数组的一个方法，会列出多个数组，每个数组有两个元素，[0] 是位置，[1]是数组的元素。对象也有这个方法，只是第一个位置不是表示位置的0123，而是key。for(const [i,el] of menu.entries()) {console.log(${i+1}:${el})}
6. 函数的call(obj, arg)方法和bind(obj,arg)方法区别： 一个直接执行函数，一个返回一个函数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e04ffb43394be966fbc9dcde95de1b71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0593df7c1b7fa2ef791a600b16002dd4/" rel="bookmark">
			git pull Your configuration specifies to merge with the ref ‘refs/heads/xxxx‘ from the remote, but n
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		$ git pull Your configuration specifies to merge with the ref 'refs/heads/xxxx' from the remote, but no such ref was fetched. 1.问题原因分析2.问题解决 Your configuration specifies to merge with the ref ‘refs/heads/xxxx’ from the remote, but no such ref was fetched.) 1.问题原因分析 1.主要是因为网页上仓库fork别人的，更新了就没了分支，但是本地还有
2.需要切换到丢失的分支下，需要先解锁：
git branch --unset-upstream 3.然后在执行git pull会有提示:
There is no tracking information for the current branch. Please specify which branch you want to merge with. See git-pull(1) for details.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0593df7c1b7fa2ef791a600b16002dd4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d770de857d692dcf4f0caa657e45ab5d/" rel="bookmark">
			vue组件间通信之兄弟组件通信（$EventBus）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue组件间通信之兄弟组件通信（$EventBus） vue组件中的数据传递最最常见的就是父子组件之间的传递。父传子通过props向下传递数据给子组件；子传父通过$emit发送事件，并携带数据给父组件。而有时两个组件之间毫无关系，或者他们之间的结构复杂，如何传递数据呢？这时就要用到
vue 中的事件总线 EventBus的概念
EventBus的简介
EventBus又称事件总线，相当于一个全局的仓库，任何组件都可以去这个仓库里获取事件
EventBus的使用
初始化
要用EventBus，首先要在main.js中初始化一个EventBus，这里称它为全局事件总线。
Vue.prototype.$EventBus = new Vue();//全局注册一个事件总线 接收事件和发送事件
发送事件的语法：this. E v e n t B u s . EventBus. EventBus.emit(发送的事件名,传递的参数)
接收事件的语法：this. E v e n t B u s . EventBus. EventBus.on(监听的事件名, 回调函数)
见下方示例
ceshi.vue
&lt;template&gt; &lt;div&gt; &lt;PageA&gt;&lt;/PageA&gt; &lt;hr&gt; &lt;PageB&gt;&lt;/PageB&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import PageA from "../../components/ceshi/pageA.vue" import PageB from "../../components/ceshi/pageB.vue" export default{ components:{PageA,PageB}, data(){ return{ } } } &lt;/script&gt; &lt;style&gt; &lt;/style&gt; pageA.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d770de857d692dcf4f0caa657e45ab5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af41146b27a036d704afeab19f90cd60/" rel="bookmark">
			vue含附件的表单提交
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		此帖的主要目的是记录以下三点：
1、使用elementUI的上传附件。
2、vue使用FormData，向接口传送表单数据（含附件）。
3、接口从HttpServletRequest中获取请求数据，通过@RequestPart(“USER_PHOTO_”) MultipartFile USER_PHOTO_获取附件数据。
…1、使用elementUI的上传附件…
&lt;el-upload action="uploadAction" list-type="picture-card" :on-preview="handlePictureCardPreview" :on-remove="handleRemove" :limit="1" :show-file-list="true" name="img" ref="upload" :data="userForm" accept="image/png,image/gif,image/jpg,image/jpeg" :on-exceed="handleExceed" :auto-upload="false" :on-error="uploadError" :before-upload="handleBeforeUpload" :on-change="changeFile"&gt; &lt;i class="el-icon-plus"&gt;&lt;/i&gt; &lt;/el-upload&gt; //文件状态改变时的钩子，添加文件、上传成功和上传失败时都会被调用 onChange(file, fileList) { console.log(file.raw); console.log(this.$refs.userPhoto); this.userForm.imageUrl = URL.createObjectURL(file.raw); }, // 上传文件之前的钩子 handleBeforeUpload(file) { console.log('按钮', this.titleMap) if (!(file.type === 'image/png' || file.type === 'image/gif' || file.type === 'image/jpg' || file.type === 'image/jpeg')) { this.$notify.warning({ title: '警告', message: '请上传格式为image/png, image/gif, image/jpg, image/jpeg的图片' }) } let size = file.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af41146b27a036d704afeab19f90cd60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a48344601eafcfd96e28f8bfb23f5a1/" rel="bookmark">
			小知识(7) wangEditor富文本编辑器简单引入(vue3)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		wangEditor富文本编辑器 https://github.com/wangeditor-team/wangEditorhttps://www.wangeditor.com/ 一、安装 cnpm install @wangeditor/editor --save cnpm install @wangeditor/editor-for-vue@next --save 二、使用 BaseEditor.vue &lt;template&gt; &lt;div style="border: 1px solid #ccc"&gt; &lt;Toolbar style="border-bottom: 1px solid #ccc" :editor="editorRef" :default-config="toolbarConfig" :mode="mode" /&gt; &lt;Editor v-bind="$attrs" style="height: 500px; overflow-y: hidden" :default-config="editorConfig" :mode="mode" @onCreated="handleCreated" /&gt; &lt;/div&gt; &lt;/template&gt; &lt;script setup&gt; const { proxy } = getCurrentInstance(); import '@wangeditor/editor/dist/css/style.css'; // 引入 css import { onBeforeUnmount, ref, shallowRef, onMounted } from 'vue'; import { Editor, Toolbar } from '@wangeditor/editor-for-vue'; // 编辑器实例，必须用 shallowRef const editorRef = shallowRef(); let mode = ref('default'); // 'default' 或 'simple' onMounted(() =&gt; {}); const toolbarConfig = {}; const editorConfig = { placeholder: '请输入内容.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a48344601eafcfd96e28f8bfb23f5a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/795487ef16ebeef35641b04b6287030b/" rel="bookmark">
			【运筹优化】最短路算法之Dijkstra算法 &#43; Java代码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Dijkstra算法简介二、Dijkstra算法思想三、Dijkstra算法 Java代码四、测试 一、Dijkstra算法简介 迪杰斯特拉算法(Dijkstra)是由荷兰计算机科学家狄克斯特拉于1959年提出的，因此又叫狄克斯特拉算法。是从一个顶点到其余各顶点的最短路径算法，解决的是有权图中最短路径问题。迪杰斯特拉算法主要特点是从起始点开始，采用贪心算法的策略，每次遍历到始点距离最近且未访问过的顶点的邻接节点，直到扩展到终点为止。
二、Dijkstra算法思想 按路径长度递增次序产生算法：
把顶点集合V分成两组：
（1）S：已求出的顶点的集合（初始时只含有源点V0）
（2）V-S=T：尚未确定的顶点集合
将T中顶点按递增的次序加入到S中，保证：
（1）从源点V0到S中其他各顶点的长度都不大于从V0到T中任何顶点的最短路径长度
（2）每个顶点对应一个距离值
S中顶点：从V0到此顶点的长度
T中顶点：从V0到此顶点的只包括S中顶点作中间顶点的最短路径长度
依据：可以证明V0到T中顶点Vk的，或是从V0到Vk的直接路径的权值；或是从V0经S中顶点到Vk的路径权值之和 。
（反证法可证）
求最短路径步骤
算法步骤如下：
G={V,E}
初始时令 S={V0},T=V-S={其余顶点}，T中顶点对应的距离值
若存在，d(V0,Vi)为弧上的权值
若不存在，d(V0,Vi)为∞从T中选取一个与S中顶点有关联边且权值最小的顶点W，加入到S中对其余T中顶点的距离值进行修改：若加进W作中间顶点，从V0到Vi的距离值缩短，则修改此距离值
重复上述步骤2、3，直到S 中包含所有顶点，即W=Vi为止 三、Dijkstra算法 Java代码 @Data public class Dijkstra { // 距离矩阵 double[][] distance; // 起点 int start; // 终点 int end; /** * @param distance * @param start * @param end * @Description 构造函数 * @Author WSKH */ public Dijkstra(double[][] distance, int start, int end) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/795487ef16ebeef35641b04b6287030b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56ad9dc55743b1cd2d22ac68c684411b/" rel="bookmark">
			小知识(5) el-table行样式失效问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实现效果 子级呈现不同颜色去区分
二、最初代码 tips: 我这里使用的vue3 + elementplus
&lt;el-table :row-class-name="tableRowClassName" &gt; ... &lt;/el-table&gt; function tableRowClassName({ row, rowIndex }) { if (row.children.length === 0) { return 'success-row'; } return ''; } &lt;style lang="scss" scoped&gt; .el-table .success-row { --el-table-tr-bg-color: var(--el-color-success-light-9); } &lt;/style&gt; 三、解决 去掉style中的scoped即可，哈哈哈 ^_^ ^_^ ^_^
&lt;style lang="scss"&gt; .el-table .success-row { --el-table-tr-bg-color: var(--el-color-success-light-9); } &lt;/style&gt; 快去动动自己的小手手操作起来看看效果吧，冲冲冲！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f5d3c1cd1447dd45f4d00948ee21c0b/" rel="bookmark">
			关于StringJoiner的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于StringJoiner的使用 1 说明1 属性和构造方法2 普通方法 2 使用1 单个拼接场景2 遍历拼接场景 在项目中,经常有某些集合数据,需要添加逗号或其他符号,拼接成字符串展示,而普通的遍历后追加分隔符,需要单独处理最后一个元素,比较繁琐.Java8中,提供了一个工具类,即StringJoiner可以完美解决此类问题.
1 说明 StringJoiner类, 是Java8中,java.util包下的一个类.基于StringBuilder实现.主要用于对字符串通过分隔符进行拼接的场景.
1 属性和构造方法 public final class StringJoiner { // 拼接后字符串前缀 private final String prefix; // 拼接时字符串的分隔符 private final String delimiter; // 拼接后字符串后缀 private final String suffix; // 拼接后字符串的值 private StringBuilder value; // 当value为null时,返回的值 (默认是前缀+后缀) private String emptyValue; // 分隔符构造 public StringJoiner(CharSequence delimiter) { this(delimiter, "", ""); } // 前缀,分隔符,后缀构造 public StringJoiner(CharSequence delimiter, CharSequence prefix, CharSequence suffix) { Objects.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f5d3c1cd1447dd45f4d00948ee21c0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92d4dad0330d27c4b415b8bf6ee652c4/" rel="bookmark">
			卡尔曼R和Q的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Q 过程噪声协方差,Q增大，动态响应变快，收敛稳定性变坏
R 观测噪声协方差,R增大，动态响应变慢，收敛稳定性变好
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c538727b66a0ec32b907f432a5f70a20/" rel="bookmark">
			使用putText给图像写标签，但是发现标签后面有个问号，怎么办？cv::putText(img, data_classes[(int)res[j].class_id]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用putText给图像写标签，但是发现标签后面有个问号，怎么办？
这个是你的classt读取到的文本格式不对，可能是windows格式
建议新建一个txt，然后将分类的类别复制进去
或者另存一下txt，格式为选择linux格式
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/427e8e27c24b3a57dd179f2eb2fd81ae/" rel="bookmark">
			Node直接执行ts文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Node直接执行ts文件 1、常规流程 node 执行 【ts 文件】 流程： 1、编写ts代码 2、编译成js代码 [命令如 ：tsc xx.ts] 3、执行js代码 [node xx.js] 2、直接执行 想要直接执行 ts 文件，需要安装如下依赖工具。
执行如下命令：
# 安装在项目中 npm install @types/node --save-dev # 全局安装 npm install -g ts-node 直接运行ts的命令
ts-node xxx.ts 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78082e4d2e66e644907b8c22dc1b004d/" rel="bookmark">
			解决github ping不通的问题（1024程序员节快乐！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1024程序员节快乐！（随便粘贴一个文档，参加活动
解决github ping不通的问题 域名解析（域名-&gt;IP）：https://www.ipaddress.com/
Ubuntu平台 github经常ping不通或者访问缓慢，方法是更改hosts文件
#修改 /etc/hosts sudo vim /etc/hosts 在hosts里添加github的ip
140.82.114.4 www.github.com
199.232.5.194 github.global.ssl.fastly.net
54.231.114.219 github-cloud.s3.amazonaws.com
可以访问https://github.com.ipaddress.com/www.github.com 获取目前github.com实际ip
#更新一下hosts source /etc/hosts 这样github就ping的通啦！
Windows平台 修改：C:\Windows\System32\drivers\etc\hosts
同样加上一句：140.82.114.4 www.github.com
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/557fda8045a414dfecbc4c17fa6df375/" rel="bookmark">
			Mac安装多个版本Node.js
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mac安装多个版本Node.js
前言 开发旧项目时，使用低版本Node.js。开发新项目时，需使用高版本Node.js。
可使用n同时安装多个版本Node.js，并切换到指定版本Node.js。
操作
1 全局安装n
npm install -g n
2 使用国内淘宝镜像
默认使用国外镜像（nodejs.org/dist/），导致下载…
设置临时环境变量
export N_NODE_MIRROR=npm.taobao.org/mirrors/node
3 安装指定版本Node.js
加-E才能拿到临时环境变量
sudo -E n 16.16.0
4 查看已安装Node.js版本列表
n list
5 删除指定版本Node.js
n rm 16.15.0
6 切换Node.js版本
//打开已安装的Node.js列表，并使用上、下箭头切换版本，然后回车确认。
sudo n
7 查看切换后的Node.js版本
node -v
npm -v
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16639035f57b466357e4d77394545215/" rel="bookmark">
			Kafka磁盘写满日志清理操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近项目组的kafka集群，老是由于应用端写入kafka topic的消息太多，导致所在的broker节点占满，导致其他的组件接连宕机。
这里和应用端沟通可以删除1天之前的消息来清理磁盘，并且可以调整topic的消息存活时间。
一、调整Topic的消息存活时长删除消息 kafka-configs --zookeeper localhost:2181 --entity-type topics --entity-name topicName --alter --add-config retention.ms=86400000 如上调整topic的消息存活时长为为1天，当执行完之后执行查询topic详细信息，可以看到已经发生了修改，并且过一会过期的消息会被删除。
kafka-topics --bootstrap-server localhost:9092 --describe --topic topicName 二、不修改Topic消息存活时长删除消息 1.登录到相应的机器上。
2.找到写满的磁盘，删除掉不需要的业务数据。数据清理原则：
不可直接删除Kafka的数据目录，避免造成不必要的数据丢失。找到占用空间较多或者明确不需要的Topic，选择其中某些Partition，从最早的日志数据开始删除。删除segment及相应地index和timeindex文件。不要清理内置的Topic，例如__consumer_offsets和_schema等。 3.重启磁盘被写满的相应的Broker节点，使日志目录online。
参考：Kafka磁盘写满时如何运维操作_开源大数据平台E-MapReduce-阿里云帮助中心 (aliyun.com)
怎么删除kafka中的数据-火山引擎 (volcengine.com)
三、Kafka消息清理策略 在Kafka中，存在数据过期的机制，称为data expire。如何处理过期数据是根据指定的policy（策略）决定的，而处理过期数据的行为，即为log cleanup。
在Kafka中有以下几种处理过期数据的策略：
log.cleanup.policy=delete（Kafka中所有用户创建的topics，默认均为此策略） 根据数据已保存的时间，进行删除（默认为1周）根据log的max size，进行删除（默认为-1，也就是无限制） log.cleanup.policy=compact（topic __consumer_offsets 默认为此策略） 根据messages中的key，进行删除操作在active segment 被commit 后，会删除掉old duplicate keys无限制的时间与空间的日志保留 自动清理Kafka中的数据可以控制磁盘上数据的大小、删除不需要的数据，同时也减少了对Kafka集群的维护成本。
那Log cleanup 在什么时候发生呢？
首先值得注意的是：log cleanup 在partition segment 上发生更小/更多的segment，也就意味着log cleanup 发生的频率会上升Log cleanup 不应该频繁发生=&gt; 因为它会消耗CPU与内存资源Cleaner的检查会在每15秒进行一次，由log.cleaner.backoff.ms 控制 log.cleanup.policy=delete log.cleanup.policy=delete 的策略，根据数据保留的时间、以及log的max size，对数据进行cleanup。控制数据保留时间以及log max size的参数分别为：
log.retention.hours：指定数据保留的时常（默认为一周，168） 将参数调整到更高的值，也就意味着会占据更多的磁盘空间更小值意味着保存的数据量会更少（假如consumer 宕机超过一周，则数据便会再未处理前即丢失） log.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16639035f57b466357e4d77394545215/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38eaddf0d55d25f7319c39c42ba9c36c/" rel="bookmark">
			九联UNT413A-403A-411A-S905L3A-B芯片蓝牙语音免拆卡刷固件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 固件介绍：
1、带ROOT权限，适用于魔百盒unt413a晶晨S905L3A芯片。
2、调出原厂固件屏蔽的wifi，开放原厂固件屏蔽的市场安装和u盘安装apk；
3、无开机广告，无系统更新，不在被强制升级；修改dns，三网通用；
4、大量精简内置的没用的软件，运行速度提升30%以上，多出大量的存储空间；
5、内置当贝市场；去除应用安装限制，实现自由安装第三方软件！
6、支持开机自启动、开机密码锁、儿童应用锁、应用隐藏、开机自动进入HDMI等各种花式功能；
刷机教程：
1、准备一个干净无任何电脑操作系统启动功能的单一分区模式，FAT32个的32G大小以下的U盘，最好是8G的，2.0接口的；
2、将factory_update_param.aml、recovery.img、update.zip等三个文件，复制放入U盘里，插上机顶盒靠近网口的USB接口上；
3、用一个牙签或是镊子顶住复位键，通电开机7-8秒松开，即自动进入刷机模式下卡刷即可；
4、首页、菜单、设置键正常，首次刷机耐心等待3-5分钟，第一次开机会时间长点，耐心等待即可；
卡刷固件：
链接：https://pan.baidu.com/s/1romqWxk4doovQ-CW_RTDMw?pwd=1234 提取码：1234 线刷救砖固件：
链接：https://pan.baidu.com/s/1v5t4ee4ftaOhYDteWM4w_A?pwd=1234 提取码：1234 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e123294494914939c62015038e874597/" rel="bookmark">
			MySQL数据同步到达梦数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.服务器配置 达梦数据库的初始状态是不兼容其他任何数据库模式的，所以必须先设置系统的兼容性，从安装路径的tool文件夹中打开console工具（DM控制台工具），设置兼容MySQL。
2.创建用户（需要分配权限的操作，可忽略） 打开tool中的manager（DM管理工具），
创建的用户后，会生成与用户名相同的模式，系统权限中可以给此用户赋权（如果迁移数据到新建用户的模式中，给该用户赋相应的权限）
3.创建迁移工程 无需创建权限用户的话，可修改兼容性后直接跳到这一步
(1) 打开tool中的dts工具（DM数据迁移工具）
新建工程
（2）新建迁移
（3）选择MySQL ==&gt; DM
（4）填入MySQL和DM的数据库连接信息
（5）指定模式，或者勾选创建新的模式
（6）指定迁移的对象
（7）审阅迁移任务
可以选择是否生成日志，点击完成开始迁移
（8）完成迁移
（9）迁移完成，结果在manager查看（DM管理工具） 迁移出错原因：
权限问题：可以查看该用户是否有创建表的权限等。
表字段类型问题：
有可能MySQL中表的某个字段属性与达梦中无法转换兼容，修改字段类型（出现较少）。
有可能MySQL的字段太大，达梦的字段大小需要调整才能容纳。
有可能主键自动生成出现问题，可以先取消表的主键自增，迁移完再设置回来。
字段类型都可以在右键修改里设置
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ab072111c42e9ab668b8bfa9c645f08/" rel="bookmark">
			【Spring Cloud Alibaba】seata分布式事务官方入门案例导读2（实战版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 准备seata环境1.1. 生产环境启动seata1.2. 采用代码启动seata 2. 开始测试3. 附录3.1. 如果第一次配置seata压缩包3.2. 常见问题参考 本文是针对官方seata入门文章https://sca.aliyun.com/zh-cn/docs/2022.0.0.0/user-guide/seata/quick-start的 补充说明！补充说明！补充说明！如果读者在阅读官方入门文章有问题或困惑请参考本文。 seata分布式事务官方入门案例导读1（实战版）
seata分布式事务官方入门案例导读2（实战版）
1. 准备seata环境 1、启动mysql
docker start mysql_mall_learning 2、启动nacos
备注：如果没有设置db存储请自行设置db存储，下面是作者本地配置好的nacos持久化环境，所以直接启动了
/Users/apple/Documents/Work/InstallationSoftware/nacos/bin/startup.sh 3、启动seata
参考资料：https://sca.aliyun.com/zh-cn/docs/2022.0.0.0/user-guide/seata/quick-start
1.1. 生产环境启动seata 如果是第一次配置seata的压缩包，参考附录3.1
如果不是第一次配置，请直接启动
下面是作者本地配置好的seata持久化和把seata注册到nacos的环境，所以直接启动了
/Users/apple/Documents/Work/seata-1.7.1/bin/seata-server.sh -h 127.0.0.1 -p 8091 -m db 1.2. 采用代码启动seata 1、首先在nacos中创建nacos配置。
创建示例中 Nacos data-id: seata.properties , Group: SEATA_GROUP(seata 1.5.1 默认分组) ,导入 Nacos 配置 注意注意：一定要创建group为SEATA_GROUP，详细配置内容是连接中的内容
在 seata.properties 中增加示例中需要的如下事务群组配置。 service.vgroupMapping.order-service-tx-group=default service.vgroupMapping.account-service-tx-group=default service.vgroupMapping.business-service-tx-group=default service.vgroupMapping.storage-service-tx-group=default 把以上配置加载seata.properties的末尾
2、代码启动
回到代码spring-cloud-alibaba-example/spring-cloud-alibaba-examples/seata-example/seata-server，直接启动SeataServerApplication类，不出意外应该是没有报错的，作者亲试。
闲话：该模块其实啥都没有，只有一个SeataServerApplication类和一个application.yml配置文件，其实是使用了引入的seata-server.jar来启动的，且基于spring boot的配置文件覆盖规则，项目的application.yml覆盖了jar包中的application.yml。
2. 开始测试 在本示例中，我们模拟了一个用户购买货物的场景，StorageService 负责扣减库存数量，OrderService 负责保存订单，AccountService 负责扣减用户账户余额。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ab072111c42e9ab668b8bfa9c645f08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7438e917792501e001b3189761d06f17/" rel="bookmark">
			VINS-Mono&#43;Fusion源码解析系列（八）：IMU预积分的代码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. IMU预积分的代码部分 —— integration_base.h （1）预积分的构造函数
IntegrationBase(const Eigen::Vector3d &amp;_acc_0, // 初始加速度 const Eigen::Vector3d &amp;_gyr_0, // 初始角速度 const Eigen::Vector3d &amp;_linearized_ba, // 初始加速度零偏 const Eigen::Vector3d &amp;_linearized_bg) // 初始角速度零偏 // 列表初始化 使用括号{}内的输入参数给对应的成员变量赋初值 : acc_0{_acc_0}, gyr_0{_gyr_0}, linearized_acc{_acc_0}, linearized_gyr{_gyr_0}, linearized_ba{_linearized_ba}, linearized_bg{_linearized_bg}, // 初始时只有自身与自身才有联系，因此雅可比矩阵初始化为15*15的单位阵 jacobian{Eigen::Matrix&lt;double, 15, 15&gt;::Identity()}, // 初始时没有任何IMU数据，因此协方差矩阵为15*15的全零矩阵 covariance{Eigen::Matrix&lt;double, 15, 15&gt;::Zero()}, // 初始时的位移为0 sum_dt{0.0}, delta_p{Eigen::Vector3d::Zero()}, // 初始时的姿态为单位四元数 delta_q{Eigen::Quaterniond::Identity()}, // 初始时的速度为0 delta_v{Eigen::Vector3d::Zero()} { /* noise对应的是前面的噪声协方差矩阵V 由于噪声n是18*3的，而V = n*n^T，故V是(18*1)*(1*18) = 18*18 下面根据n = [n_{ak}, n_{wk}, n_{ak+1}, n_{wk+1}, n_{ba}, n_{bw}]给协方差矩阵noise(V)赋初值 参数ACC_N，GYR_N，ACC_W，GYR_W是通过在parameters.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7438e917792501e001b3189761d06f17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1b89b8abc2ce10ccc20eaabc4ca03b3/" rel="bookmark">
			Linux命令之网络命令ifconfig
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、ifconfig命令简介 ifconfig命令是Linux系统下的一个网络配置工具，用于查看和设置网络接口的配置信息。通过ifconfig命令，用户可以查看当前系统中所有网络接口的详细信息，如IP地址、子网掩码、广播地址等。同时，用户还可以使用ifconfig命令对网络接口进行配置，如启用或禁用网络接口、设置静态IP地址等。该命令与window环境下的ipconfig命令相似，容易出现混淆，当然这两个命令只能在各自的平台运行，输入验证下即可区分。
二、ifconfig命令使用示例 1、查看命令版本 通过下面命令可以看到ifconfig命令属于net-tools工具的子命令，如果linux环境提示不存在此命令，centos环境下我们可以使用yum install -y net-tools命令安装此命令集。
[root@s166 ~]# ifconfig --version
net-tools 2.10-alpha
2、获取命令帮助 通过–help参数获取命令帮助。我们可以看到该命令可以查看IP地址、状态信息；也可以配置IP地址、掩码等；还可以启用或者禁用网络接口。
3、查看所有网卡的状态信息 使用-a参数可以查看网卡的所有状态和配置信息。
4、查看指定网卡的状态信息 [root@s166 ~]# ifconfig eth0
eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500
inet 192.168.0.166 netmask 255.255.255.0 broadcast 192.168.0.255
inet6 fe80::242c:be63:5997:1371 prefixlen 64 scopeid 0x20
ether de:d5:84:b3:41:cb txqueuelen 1000 (Ethernet)
RX packets 24769 bytes 3211666 (3.0 MiB)
RX errors 0 dropped 0 overruns 0 frame 0
TX packets 1192 bytes 101143 (98.7 KiB)
TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1b89b8abc2ce10ccc20eaabc4ca03b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abc5f7becb2f4c3cd8df5813a30268b8/" rel="bookmark">
			Vue new Date()时区问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近想自己搞点东西，在夜里要输出时间时发现总是输出的昨天的时间，一查发现是New Date()使用的是UTC时间，跟北京时间有时差，所以可以采用如下方法：
const currentDate = new Date(); const formattedDate = `${currentDate.getFullYear()}-${String(currentDate.getMonth() + 1).padStart(2, '0')}-${String(currentDate.getDate()).padStart(2, '0')}`; console.log("date", formattedDate); 问题得到了解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9efd90f9ccce81e28fc99a4ab627c1d6/" rel="bookmark">
			【Spring Cloud Alibaba】seata分布式事务官方入门案例导读1（实战版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 业务介绍1.1. 用例1.2. 架构图1.3. 3个服务的代码及业务逻辑（略） 2. SEATA 的分布式交易解决方案3. 由Dubbo + SEATA提供支持的示例（实战）3.1. 步骤 1：建立数据库，如seata数据库3.2. 步骤 2：创建 UNDO_LOG 表3.3. 步骤 3：为示例业务创建表3.4. 步骤 4: 启动服务3.5. 步骤 5: 运行示例3.6. 测试3.6.1. 正常执行3.6.2. 模拟异常发生3.6.3. 原理简述 本文是介绍官方的seata入门案例，采用的是 微服务架构，参考地址：https://seata.io/zh-cn/docs/user/quickstart/。 代码详细地址：https://github.com/seata/seata-samples/tree/master/dubbo。
整个seata-samples代码库很大，本例只用到了dubbo子模块。
seata分布式事务官方入门案例导读1（实战版）
seata分布式事务官方入门案例导读2（实战版）
1. 业务介绍 1.1. 用例 本业务以购买商品的业务逻辑为例子。整个业务涉及到3个微服务一起提供服务：
仓储服务：对给定的商品扣除仓储数量。订单服务：根据采购需求创建订单。帐户服务：从用户帐户中扣除余额。 1.2. 架构图 1.3. 3个服务的代码及业务逻辑（略） 2. SEATA 的分布式交易解决方案 我们只需要使用一个 @GlobalTransactional 注解在业务方法上:
@GlobalTransactional public void purchase(String userId, String commodityCode, int orderCount) { ...... } 备注：
1、每个微服务都与seata服务连接起来（可以看每个服务的xxx-service.xml）。如dubbo-storage-service.xml文件。其他服务也一样
&lt;bean id="storageDataSourceProxy" class="io.seata.rm.datasource.DataSourceProxy"&gt; &lt;constructor-arg ref="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9efd90f9ccce81e28fc99a4ab627c1d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac8e433ae35e5eb015cc4bea6da27c83/" rel="bookmark">
			【中英字幕】Yarn报错: Extracting tar content of undefined failed, the file appears to be corrupt
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# Bug缘由 Bug birth crib
偶然兴起学学微前端的课程，建一个git repo然后 pnpx create-mf-app
I got pregnant in the head so I started learning micro frontend. I created a git repo then execute some funny code.
yarn是几万年前装的。
I installed yarn before my first yarn.
今不巧，当即给我尥蹶子报了个奇怪的错
Dang, yarn showed me how tough she can be today
yarn install v1.22.19 info No lockfile found. [1/4] Resolving packages... warning webpack-dev-server &gt; webpack-dev-middleware &gt; memfs@3.6.0: this will be v4 [2/4] Fetching packages.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac8e433ae35e5eb015cc4bea6da27c83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edde95224f12557d76bc9165b36dd3da/" rel="bookmark">
			JS-金山办公24届秋季校招-前端-滚雪球
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 已知山体上的雪球向下滚动时，雪球每向下滚动1的距离，体积会膨胀x倍。
例如，海拔高度为2的、初始大小为1雪球，当它滚到海拔高度为0的地面时，若x= 5其大小会变成1*5*5=25。
现在每个海拔为i的高度都生成了个大小为1的雪球。当它们全部滚动道地面时，请你求出所有雪球的大小总和。答案对取模。
输入描述： 在第一行中，给出山的高度T和雪球增加的程度，在第二行到 H + 1行表示在山上生成的雪球数量，其中第 i+1行的数字表示在高度为i处制成的雪球的数量
输出描述：输出从山上滚下的所有雪球个数总和。 输入：4 5 输出：**
1
3
2
4
代码（VSCode本地调试） const readline = require('readline'); const rl = readline.createInterface({ input: process.stdin, output: process.stdout }); let H, x; let snowballs = []; rl.on('line', (input) =&gt; { if (!H) { [H, x] = input.split(' ').map(Number); } else { snowballs.push(Number(input)); if (snowballs.length === H) { rl.close(); } } }); rl.on('close', () =&gt; { let totalSize = 0; let size = 1; for (let i = 0; i &lt; H; i++) { size = (size * x) % (1e9 + 7); totalSize = (totalSize + snowballs[i] * size) % (1e9 + 7); } console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edde95224f12557d76bc9165b36dd3da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73adb61c129be88ea5672d14efa248ff/" rel="bookmark">
			微信小程序：单行输入和多行输入组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信小程序提供了两种输入类型的输入框组件，分别是单行输入框 &lt;input&gt; 和多行输入框 &lt;textarea&gt;。
1. 单行输入组件（input）
单行输入框 &lt;input&gt; &lt;input&gt; 是一个用于收集用户输入的组件，主要用于收集单行文本输入。
input组件用于录入单行文本，尽管input的基本功能是文本录入，但该组件的属性还是比较多的，也比较复杂。
重要的属性有：
主要的监听事件有：
value：输入框的初始内容type：input 的类型，如 text, number, idcard, digit等password：是否是密码类型placeholder：输入框为空时占位符disabled：是否禁用maxlength：最大输入长度confirm-type：设置键盘右下角按钮的文字，如 send, search, next, go, done等confirm-hold：点击键盘右下角按钮时是否保持键盘不收起bindinput：当键盘输入时，触发 input 事件bindfocus：输入框聚焦时触发bindblur：输入框失去焦点时触发bindconfirm：点击完成时，键盘输入法收起的事件 如下为input组件的属性及其含义：
value：String类型，输入框的当前内容type：String类型，默认值是text。可指定的值：text, number, idcard, digitpassword：Boolean类型，默认值是false，是否以密码形式录入文本（所有的文本字符都显示为点）placeholder：String类型，输入框为空时显示的文本placeholder-style：String类型，指定 placeholder 的样式placeholder-class：String类型，指定 placeholder 的样式名称disabled：Boolean类型，默认值是false，表示是否禁用输入框maxlength：Number类型，默认值是140，表示文本最大输入长度，设置为 -1 的时候不限制最大长度auto-focus：Boolean类型，默认值是false，该属性为true，可以让当前输入框自动获得焦点，并且自动弹出软键盘。该属性只能在真机上测试，小程序开发工具目前没有软键盘。同一个wxml文件中，只能有一个输入框设置该属性为true，输入框还包括后面要介绍的textarea组件focus：Boolean类型，默认值是false，该属性可以让输入框获的焦点，目前开发工具暂不支持，只能在真机上测试bindinput：EventHandle类型 ，除了date/time类型外的输入框，当键盘输入时，触发input事件，event.detail = {value: value}，处理函数可以直接 return 一个字符串，将替换输入框的内容bindfocus ：EventHandle类型，输入框获得焦点时触发，event.detail = {value: value}bindblur：EventHandle类型，输入框失去焦点时触发，event.detail = {value: value} 注意：这些属性中，auto-focus和focus目前只能在真机上测试。
常用使用方法实例：
&lt;view style="margin:20px"&gt; &lt;input placeholder="请输入你的姓名" value="默认值" /&gt; &lt;input placeholder-style="color:green" placeholder="占位符字体是绿色的" auto-focus/&gt; &lt;input style="margin-top:25px" placeholder="这个只有在按钮点击的时候才聚焦" focus="{{focus}}" /&gt; &lt;button bindtap="bindButtonTap"&gt;使得输入框获取焦点（在真机上测试）&lt;/button&gt; &lt;input style="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73adb61c129be88ea5672d14efa248ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef0cd07e6730422281e25e73a5fa5892/" rel="bookmark">
			Redis未授权访问漏洞复现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis未授权访问漏洞复现 Redis 介绍：
Redis 是非关系型数据库系统，没有库表列的逻辑结构，仅仅以键值对的方式存储数据。
Redis 数据库经常用于Web 应用的缓存。
Redis 可以与文件系统进行交互。
Redis 监听TCP/6379。
漏洞复现： 启动漏洞环境：
sudo docker-compose up -d redis-cli -h 127.0.0.1 # redis数据库连接redis的客户端,127.0.0.1 表示连接本机 我们发现直接进来了，说明存在未授权访问漏洞。
info #查看服务器信息 redis 是以键值对的方式存储数据的：
set name GEHUi # name为键(key),GEHUI为值(value) get name #获取name的值 condig set dir /tmp/ #设定目录 config set dbfilename gehui.txt #设定数据库文件名为gehui.txt save #将数据库的内容存储在/tmp/gehui.txt中 sudo docker exec -it 780fea38003b /bin/bash #登录到redis容器中 在容器中查看有没有gehui.txt文件
我们查看到有gehui.txt文件，并且有我们写入的name和GEHUI，说明我们登录进redis数据库，能够读并且写文件，说明存在未授权访问漏洞。如果一个服务器开了redis数据库，那么就会造成数据库信息内容泄露（脱库）。
Redis 未授权访问
读取数据库内容读写系统文件执行系统命令数据泄露直接写WebShell
计划任务反弹Shell
SSH免密登录
…redis-rogue-getshell 克隆this script 脚本 到本地,下载时需要挂代理。
proxychains git clone https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef0cd07e6730422281e25e73a5fa5892/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16d020797f597d32ced13c50acfa9d5e/" rel="bookmark">
			APP个人隐私与漏洞检测系统：千里眼APPcheck
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. APP检测1.1. 系统APP漏洞引起的安全风险1.2. 系统名称1.3. 千里眼检测项目1.4. 千里眼支持系统1.5. 千里眼检测系统概述1.6. 千里眼检测系统架构图1.7. 千里眼检测系统检测引擎 2. 检测工具3. 检测过程4. 检测结果基本信息4.1. App基本信息 5. 漏洞检测结果6. 攻防团队介绍7. 攻防团队核心人员介绍 1. APP检测 1.1. 系统APP漏洞引起的安全风险 2023 年 6 月头号恶意软件：Qbot 成为 2023 年上半年最猖獗恶意软件-CSDN.NET
2023 年 7 月 ，全球领先的网络安全解决方案提供商 Check Point® 软件技术有限公司（纳斯达克股票代码：CHKP）发布了其 2023 年 6 月《全球威胁指数》报告。研究人员发现，木马 Qbot 是 2023 年上半年最猖獗的恶意软件，已有五个月位列榜首。与此同时，移动木马 SpinOk 在上个月被发现后首次登上了恶意软件排行榜首位。该勒索软件在文件共享软件 MOVEIt 暴出零日漏洞后登上新闻头条。
最初于 2008 年作为银行木马现身的 Qbot 经过了持续开发并添新功能，其目的在于窃取用户密码、电子邮件及信用卡信息。它通常通过垃圾邮件传播，并采用反 VM、反调试和反沙盒方法等各种技术来阻碍分析和规避检测。目前，其主要作用是充当其他恶意软件的加载程序，并驻留在目标机构内，作为勒索软件运营组织发起攻击的跳板。
与此同时，研究人员发现了一种传播甚广的移动恶意软件，其累计下载量现已达到 4.21 亿次。上月，木马化软件开发套件 (SDK) SpinOk 首次登上了移动恶意软件榜首。许多热门应用都使用该恶意软件进行营销，因此它已渗入许多热门应用和游戏中，其中一些应用和游戏可从 Google Play 商店下载。SpinOk 恶意软件能够从设备中窃取敏感信息并监控剪贴板活动，对用户隐私和安全构成了严重威胁，再次凸显采取主动措施保护个人数据和移动设备的必要性，并提醒我们软件供应链攻击的破坏性潜力不容小觑。
移动应用安全概况
移动应用安全问题成因
1.2. 系统名称 千里眼AppCheck
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16d020797f597d32ced13c50acfa9d5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7293fd64a6e1903cea2d8826789387d/" rel="bookmark">
			nodejs&#43;wasm&#43;rust debug及性能分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 背景v8引擎自带的profilelinux的perf采集wasm三方库性能分析编译debug版本wasmrust程序debug调试异常模型正常模型结论优化 参考
Node使用火焰图优化CPU爆涨 - 掘金
【Node.js丨主题周】理解perf 与火焰图-腾讯云开发者社区-腾讯云
Easy profiling for Node.js Applications | Node.js
Diagnostics - Flame Graphs | Node.js
perf性能分析工具使用分享
背景 一个node服务在处理模型的时候，发现超时了，并且超过了3分钟的上限触发了报警。行吧，一般来说十几秒足够处理了，初步定位是mikktspace-wasm库的性能问题。
wasm正逐渐走进我们的程序生活，不少计算库都在用高性能语言重写，并通过wasm作为第三方包提供能力。例如博主最近用到的渲染相关的计算包，基本都是用c++和rust实现的，然后web端直接调用wasm即可。
写这篇博客呢，是因为博主一开始只是定位到三方库有问题就暂停了，毕竟是做后端的，也是存在一定的认知障碍吧，对不熟的东西也存在敬畏之心。然而根因不找到实在是难受，一路debug和性能分析下来，回头看看也没那么难。希望以后遇到类似的问题也可以乘风破浪，一路追下去，技术都是相通的，不应该存在壁垒。
v8引擎自带的profile 1、运行程序并采集 node --prof index.js xxx v8会自动采集，并生成isolate-xxx文件 2、生成txt node --prof-process isolate-xxx &gt; processed.txt vim直接打开，就可以查看采集的结果。采集结果分析参考以上链接。 3、查看火焰图 npm install -g flamebearer node --prof-process --preprocess -j isolate-xxx | flamebearer 安装flamebearer，并执行上面的命令，会自动打开浏览器，查看生成的火焰图。 注意
运行node程序需要带两个参数：
–perf-basic-prof
通过--perf-basic-prof或 --perf-basic-prof-only-functions我们都可以启动支持 perf_events 的Node.js 应用程序。 --perf-basic-prof-only-functions产生较少的输出，因此它是开销最小的选项。 生成的文件在/tmp/perf-PID.map –interpreted-frames-native-stack
Node.js 8.x 及更高版本对 V8 引擎中的 JavaScript 编译管道进行了新的优化，这有时会导致 性能无法访问函数名称/引用。使用以上参数可以解决。 linux的perf采集 1、perf采集 perf record -F 99 -g -- node --perf-basic-prof-only-functions index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7293fd64a6e1903cea2d8826789387d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca5cffb4584e012e2eb25b8a9b434742/" rel="bookmark">
			学习笔记——在IDEA中如何上传git以及git分支的拉取和提交
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Gitee中创建仓库 1.点加号--&gt;新建仓库 2.输入仓库名称即可 3.创建完成 将地址复制，下面要用
IDEA使用Git 将项目上传到远程仓库 1.idea绑定git 2.创建本地库 VCS--&gt;Create Git Repository...--&gt;OK
此时项目文件名变红 ，说明Git已检测到项目，但没有进行追踪，
3.IDEA添加远程仓库 Git--&gt;Manage Remotes...
在弹出框中添加路径（即上面复制的地址）
4.将文件添加到暂存区 选中要添加到暂存区的项目，右键--&gt;Git--&gt;+Add
此时项目文件名变绿 ，说明文件已添加到暂存区
5.将缓存区的文件添加到本地库 选中要添加到暂存区的项目，右键--&gt;Git--&gt;Commit Directory...
5.1 提交到master分支 1.Group By --&gt;选择Directory
2.只勾选要上传的文件或项目（不包括.idea文件和target文件 切记！！！）
3.填写提交信息（必填）对提交内容的说明
4.点Commit and Push...
5.2 不用理会，继续点Commit Anyway and Push... 5.3 点Push，继续 建立git分支、拉取及提交合并 1.建立多个分支 点击分支--&gt;创建分支
输入分支名称，确认
此时创建的分支和master分支的内容一致，我们后续的操作可以在master分支以外的分支上操作
2.切换分支，进行工作 2.1 同步远程分支 2.2 切换远程分支 3. 将新完成的文件提交到本地库 具体步骤同上
提交到tom分支
4.刷新gitee 此时tom分支与 master相比，领先1个Commit
5.将tom分支的内容合并到master分支 5.1 点击Pull Requests --&gt;新建Pull Requests 5.2 创建Pull Requests 选择源分支和目标分支以及标题和说明
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca5cffb4584e012e2eb25b8a9b434742/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d898732719e7adceb490eb3a5fa47ce1/" rel="bookmark">
			OpenCV实现OCR（光学字符识别）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介： 随着计算机视觉技术的不断发展，OCR（光学字符识别）技术已经越来越成熟。OCR技术可以识别图像中的文本信息，并将其转换为可编辑的文本格式，为各种应用场景提供了便利。本文将介绍如何使用OpenCV库实现摄像头OCR。
步骤： 1.安装OpenCV库
首先，需要安装OpenCV库。可以通过pip命令在Python环境中安装OpenCV库。在命令行中输入以下命令即可安装：
pip install opencv-python
2.捕获摄像头数据
使用OpenCV库可以很方便地捕获摄像头的视频流。在Python中，可以使用以下代码来打开摄像头并读取视频流：
import cv2 cap = cv2.VideoCapture(0) # 使用默认摄像头 while True: ret, frame = cap.read() # 读取一帧图像 if not ret: break cv2.imshow('frame', frame) if cv2.waitKey(1) == ord('q'): # 按q键退出 break cap.release() cv2.destroyAllWindows() 3.图像预处理
在进行OCR之前，需要对图像进行预处理，以提高OCR的准确性。常见的预处理操作包括灰度化、二值化、降噪、膨胀/腐蚀等。以下是一个示例代码，展示如何进行灰度化和二值化操作：
gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) # 灰度化 _, binary = cv2.threshold(gray, 150, 255, cv2.THRESH_BINARY_INV) # 二值化 4.文本定位
在进行OCR之前，需要定位图像中的文本区域。可以使用OpenCV的一些算法来实现文本定位。例如，使用MSER算法可以检测图像中的文本区域。以下是一个示例代码，展示如何使用MSER算法定位文本：
import cv2 import pytesseract from PIL import Image # 设置Tesseract的路径 pytesseract.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d898732719e7adceb490eb3a5fa47ce1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bc6972c2985988c9956b44d845c784c/" rel="bookmark">
			【鸿蒙软件开发】文本输入（TextInput/TextArea）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、输入框1.1 创建输入框单行输入框多行输入框单行和多行输入框的区别 1.2 设置输入框的类型有哪些类型基本输入模式（默认类型）密码输入模式 1.3 自定义样式设置无输入时的提示文本设置输入框当前的文本内容。添加backgroundColor改变输入框的背景颜色。 二、添加事件二、场景示例总结 前言 TextInput、TextArea是输入框组件，通常用于响应用户的输入操作，比如评论区的输入、聊天框的输入、表格的输入等，也可以结合其它组件构建功能页面，例如登录注册页面。具体用法参考TextInput、TextArea。
一、输入框 1.1 创建输入框 TextInput为单行输入框、TextArea为多行输入框。通过以下接口来创建。
TextArea(value?:{placeholder?: ResourceStr, text?: ResourceStr, controller?: TextAreaController}) TextInput(value?:{placeholder?: ResourceStr, text?: ResourceStr, controller?: TextInputController}) 单行输入框 TextInput() 多行输入框 TextArea() 多行输入框文字超出一行时会自动折行。
TextArea({text:"我是TextArea我是TextArea我是TextArea我是TextArea"}).width(300) 使用text参数可以设置其自带的字
单行和多行输入框的区别 单行不可以回车换行，多行可以
1.2 设置输入框的类型 有哪些类型 TextInput有5种可选类型，分别为Normal基本输入模式、Password密码输入模式、Email邮箱地址输入模式、Number纯数字输入模式、PhoneNumber电话号码输入模式。通过type属性进行设置：
基本输入模式（默认类型） TextInput() .type(InputType.Normal) 密码输入模式 TextInput() .type(InputType.Password) 1.3 自定义样式 设置无输入时的提示文本 TextInput({placeholder:'我是提示文本'}) TextInput({placeholder:'我是提示文本'}) placeholder参数可以设置提示文本
设置输入框当前的文本内容。 TextInput({placeholder:'我是提示文本',text:'我是当前文本内容'}) 使用text参数可以设置当前文本内容
添加backgroundColor改变输入框的背景颜色。 TextInput({placeholder:'我是提示文本',text:'我是当前文本内容'}) .backgroundColor(Color.Pink) 更丰富的样式可以结合通用属性实现。
二、添加事件 文本框主要用于获取用户输入的信息，把信息处理成数据进行上传，绑定onChange事件可以获取输入框内改变的内容。用户也可以使用通用事件来进行相应的交互操作。
TextInput() .onChange((value: string) =&gt; { console.info(value); }) .onFocus(() =&gt; { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7bc6972c2985988c9956b44d845c784c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af3d74b6ae75a28b39fec1483d4c6fee/" rel="bookmark">
			BeanFactory和FactoryBean的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章总结的很好：Spring中BeanFactory与FactoryBean的区别
BeanFactory BeanFactory是一个接口，它是Spring中工厂的顶层规范，是SpringIoc容器的核心接口，它定义了getBean()、containsBean()等管理Bean的通用方法。Spring的容器都是它的具体实现如：
DefaultListableBeanFactoryXmlBeanFactoryApplicationContext FactoryBean FactoryBean表现的是一个工厂的职责。 即一个Bean A如果实现了FactoryBean接口，那么A就变成了一个工厂，根据A的名称获取到的实际上是工厂调用getObject()返回的对象，而不是A本身，如果要获取工厂A自身的实例，那么需要在名称前面加上’&amp;'符号。
getObject(‘name’)返回工厂中的实例
getObject(‘&amp;name’)返回工厂本身的实例
通常情况下，bean 无须自己实现工厂模式，Spring 容器担任了工厂的 角色；但少数情况下，容器中的 bean 本身就是工厂，作用是产生其他 bean 实例。由工厂 bean 产生的其他 bean 实例，不再由 Spring 容器产生，因此与普通 bean 的配置不同，不再需要提供 class 元素。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0104a8ad05a2b19215dcbd6d9ce962d4/" rel="bookmark">
			【git 学习】--- ubuntu18.04 搭建本地git服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Ubuntu18.04 上简单创建自己的git服务器~
环境配置 Ubuntu: 18.04 git服务器搭建步骤： ##1.安装git sudo apt-get install git ##2.添加用户 sudo adduser test_git //test_git -- git用户名 ##3. 在Git用户的home目录下创建文件夹，作为裸仓库 sudo mkdir /home/git/MyProject.git sudo git init --bare /home/git/MyProject.git ##4.git 服务器上修改权限， 一定要修改权限，否则容易报错 sudo chown -R test_git:test_git /home/git/ //在git 服务器上修改权限，test_git--git用户名 ##5.在本地新建文件夹，将代码放到文件夹中，并将代码推送到刚创建的Git服务器上 git remote add origin git@your_server:/home/git/MyProject.git git push -u origin master ## 6. 验证 git clone test_git@your_server:/home/git/Myproject.git 这样就可以实现代码共享与管理了~~~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d8e740dc88c5c6534fcc73129ca9df1/" rel="bookmark">
			Elasticsearch搜索与排序经验小记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近维护公司的APP搜索项目，在实际需求中，领导对搜索关心两方面，第一要搜出来，第二排序要符合人的搜索习惯，最近一段时间的搜索经验记录下来分享一下。
‘木瓜牛奶’ 是怎么搜出来的？ 先来说说Elasticsearch基本的搜索，一段文字在es中能被搜索出来，抛开复杂的原理，简单理解成一句话: 搜索词的分词结果正好匹配上了内容的分词结果，这段内容就被搜索出来了。
这句话有两个核心，一个是分词，一个是匹配。
分词 对于第一个核心“分词”来说，它有两个需要分词，一个是搜索词的分词，一个是文档内容的分词(跟倒排索引有关，后面解释)。 先从搜索词说起，对于一个搜索词来说，它会被分词，根据分词器的不同，会有不同的分词结果。比如 “木瓜牛奶”，如果用 standard 分词，对于中文就比较呆板，一个字一个字被分词成 [“木”,“瓜”,“牛”,“奶”] 四个词，而如果用 ik_max_word 分词器，会被分词成 [“木瓜”,“牛奶”]。
下面json就展示了对于搜索词可以指定分词器，当然，只有match这种需要分词的行为才能指定分词器，如果你用term这种精确查询，是不让你用analyzer属性的。
{ "query": { "bool": { "must": [ { "match": { "channelSkuName": { "query": "木瓜牛奶", "analyzer": "ik_max_word" } } } ] } } } 再看文档内容的分词，如果有一个商品名字段叫channelSkuName，值为 “好好吃的木瓜牛奶”，如果这个字段指定了ik_max_word 分词器，会被分词为[“好好”,“好吃”,“的”,“木瓜”,“牛奶”]。我们会发现，搜索词跟数据库内容被分词拆分之后，是有重合的内容的，[“木瓜”,“牛奶”] 是两个都具有的，这个是能被搜索出来的基础。
这个json截取了索引的mappering结构，展示了channelSkuName字段指定了"ik_max_word"分词器。然后下面还有fields字段，es是允许一个字段分别指定不同的字段类型和分词器的，只要搜索的时候对应好字段后缀就行了，比如"channelSkuName.standard"和"channelSkuName.pinyin"。
{ "channelSkuName":{ "analyzer":"ik_max_word", "type":"text", "fields":{ "standard":{ "analyzer":"standard", "type":"text" }, "pinyin":{ "analyzer":"pinyin", "type":"text" } } } } 匹配 说完分词，再说匹配，在 Elasticsearch 中，有几种不同的查询类型可用于搜索文本数据。以下是 matchPhrase、match 和 term 查询的区别。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d8e740dc88c5c6534fcc73129ca9df1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e9040b4342c85f5590c8bad166c1914/" rel="bookmark">
			导出下拉列表的两种小技巧【EasyPoi实战系列】- 第473篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		历史文章（文章累计460+）
《国内最全的Spring Boot系列之一》
《国内最全的Spring Boot系列之二》
《国内最全的Spring Boot系列之三》
《国内最全的Spring Boot系列之四》
《国内最全的Spring Boot系列之五》
《国内最全的Spring Boot系列之六》
用Midjourney画个美女，AI绘画也太强大了！！！ - 第8篇
【EasyPoi实战系列】Spring Boot使用EasyPoi实现多Sheet导出 - 第470篇
【EasyPoi实战系列】Spring Boot使用EasyPoi动态控制导出的列 - 第471篇100万数据导出，居然爆炸了OutOfMemoryError？【EasyPoi实战系列】- 第472篇
悟纤：师傅，在忙吗？
师傅：徒儿，何事？
悟纤：想请教师傅一个小小的问题。
师傅：那你这个小小的问题，5分钟可以搞定不？
悟纤：相信师傅的功力，要不了5分钟。
师傅：那你且说说看来着。
悟纤：就是我想在导出的单元格中，增加一个下拉的选项。
师傅：这个呀，使用了EasyPoi就特别简单，根本不是事，1分钟给你讲清楚。
悟纤：还的是师傅，那咱们马上开始吧~
导读
在实际的excel中，会有下拉的一个选项，供用户进行下拉修改下拉的选项。
对于这样的需求如何实现呢？
@Excel 加入 addressList 是否生成下拉的选项,默认false
目前下拉只支持replace和dict两个取值地方生成。
根据对应的值生成相应的下拉,xssf下拉rowMax = 100万,hssf下拉maxRow=65536,从数据第一行开始生成,使用方法也比较简单。
说明：本节的例子的导出实体类是基于前面的章节的实体类进行使用的，所以看的有点蒙圈的小伙伴可以查看前面的文章：
👇🏻👇🏻👇🏻EasyPoi实战系列：
01.《【EasyPoi实战系列】Spring Boot集成EasyPoi - 第467篇》
02.《【EasyPoi实战系列】Spring Boot使用EasyPoi的注解让表格更漂亮以及图片的导出 - 第468篇》
03.《【EasyPoi实战系列】Spring Boot使用EasyPoi实现一对多的导出 - 第469篇》
04.《【EasyPoi实战系列】Spring Boot使用EasyPoi实现多Sheet导出 - 第470篇》
05.《【EasyPoi实战系列】Spring Boot使用EasyPoi动态控制导出的列 - 第471篇》
06.《100万数据导出，居然爆炸了OutOfMemoryError？【EasyPoi实战系列】- 第472篇》
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e9040b4342c85f5590c8bad166c1914/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04de7554941cc26f8ef84667d35c7ff1/" rel="bookmark">
			ValueError: Only supported for TrueType fonts，生成词云图时字体报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 引言 之前一段时间做自然语言处理需要词云图，写完代码一直报这个错误，我确定代码没什么错误，可就是运行不起来。
之后在网上查找解决措施，主要就是让我再确定字体路径是否写错，或换种字体试试这两个办法，结果根本没用。
后来我突然想到我的wordcloud是直接用pip install wordcloud安装的，直接安装的最新版，可能就是因为最新版才报错的，所以我开始降本。
1.为了保险起见，直接下载whl文件安装 下载地址： https://www.lfd.uci.edu/~gohlke/pythonlibs/#wordcloud
下载好自己对应的python版本的whl文件之后,将whl文件移到python的安装目录下的D:\Python3.6.7\Scripts里面，以便后面安装。
2.卸载高版本wordcloud,安装对应版本的wordcloud.whl文件 前提你所用的python版本为默认版本,直接win+R调出命令提示符，输入cmd回车。
(1)先卸载高版本wordcloud库
运行命令：pip uninstall wordcloud
(2)安装wordcloud.whl文件
运行命令：pip install D:\Python3.6.7\Scripts\wordcloud-1.8.1-cp36-cp36m-win_amd64.whl
注意：红色字体是你们自己的python包的安装路径，蓝色字体是whl文件的全名，记得加上.whl后缀。
这样就安装成功了。
3.检验结果 运行成功！
4.代码示例 注意：读取文本中的文本路径是我自己的，要改成你自己的文本路径；字体路径是电脑自带的，如果不同，也可以根据自己的字体路径修改。
import jieba import wordcloud # 读取文本 with open("./data/iu.txt",encoding="utf-8") as f: s = f.read() ls = jieba.lcut(s) # 生成分词列表 text = ' '.join(ls) # 连接成字符串 wc = wordcloud.WordCloud(font_path='C:\Windows\Fonts\STZHONGS.TTF', width=1000, height=700, background_color='white', max_words=100) wc.generate(text) # 加载词云文本R wc.to_file("1.png") # 保存词云文件 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/529f973f7b7454591ffac82c6e8fd924/" rel="bookmark">
			C&#43;&#43; mutable、 final及noexcept 关键字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		见下面几篇文章
【C/C++ 关键字 函数说明符 】C++ final关键字(修饰成员函数无法被子类重写覆盖)-CSDN博客
【C/C++ 关键字 函数说明符 】C++ noexcept 关键字(指定某个函数不抛出异常)_泡沫o0的博客-CSDN博客 【C/C++ 关键字 存储类说明符】C/C++ 的mutable 关键字 忽略对该数据成员的常量性检查在const函数中修改变量值_泡沫o0的博客-CSDN博客
【C++ 关键字 override】C++ 重写关键字override(强制编译器检查该函数是否覆盖已存在的虚函数)_c++ override_泡沫o0的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b07bca9b606642d2182c62aac7e561af/" rel="bookmark">
			C&#43;&#43; 重写关键字override(强制编译器检查该函数是否覆盖已存在的虚函数)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		override关键字的作用：
从字面意思上，是覆盖的意思，实际上在C++中它是覆盖了一个方法并且对其重写，从而达到不同的作用.
如果派生类在虚函数声明时使用了override描述符，那么该函数必须重载其基类中的同名函数，否则代码将无法通过编译。
C++中的关键字override（重载）用于在派生类中声明一个函数与其基类中同名函数的关系。当派生类在虚函数声明时使用override描述符时，需要重载其基类中的同名函数，否则编译器将会提示错误。
这是因为在C++中，虚函数的定义与函数重载非常相似。虚函数定义的方式是使用关键字virtual在函数声明中进行声明，同时可以通过重载来指定函数的行为。如果派生类重载了基类中的同名函数，则该函数将成为派生类中的虚函数，可以通过调用基类中的函数来实现该函数的功能。如果派生类未重载基类中的同名函数，则该函数将被认为是虚函数，并且无法直接访问。这样就保证了代码的灵活性和可维护性，同时也提高了代码的可读性和可理解性。因此，在C++中，override关键字是非常重要的一个特性，对于实现灵活的类型重载和抽象函数的使用非常有帮助。
注意
在C++中，override关键字是可选的，用于显式地指示编译器一个成员函数（通常是虚函数）是重写了基类中的同名函数。如果你不使用override关键字，编译器仍然会执行重写行为，只要函数的签名与基类中的虚函数相匹配。
override的使用条件：
基类成员函数为虚函数（virtual）
派生类中重写该成员函数
函数签名必须完全匹配：派生类中的函数必须与基类中被重写的虚函数在函数签名上完全匹配，包括函数名、参数类型、常量性（const）和引用修饰符（&amp;或&amp;&amp;）。否则，编译器将不会认为这是一个重写，而是一个新的函数。
返回类型可以协变：在C++中，重写虚函数的返回类型可以是基类虚函数返回类型的子类。这被称为返回类型协变。例如，如果基类虚函数的返回类型是Base*或Base&amp;，那么派生类中重写的函数的返回类型可以是Derived*或Derived&amp;，其中Derived是Base的子类。
只能重写公有和保护的虚函数：你只能重写基类中的公有和保护的虚函数。私有虚函数不能在派生类中被重写，因为它们在派生类中不可见。
不能重写非虚函数：override关键字只能用于重写虚函数。如果你尝试使用override关键字重写一个非虚函数，编译器会报错。
不能改变虚函数的默认参数：虽然C++允许你在派生类中为重写的虚函数提供不同的默认参数，但这通常是一个坏主意，因为它可能会导致意外的行为。当你通过基类指针或引用调用虚函数时，将使用基类版本的默认参数，而不是派生类版本的默认参数。
使用override 关键字的好处：
程序员的意图更清晰：通过在派生类中使用override关键字，可以清楚地表明该函数是对基类中的虚函数的重写。这使得代码更易读，更易理解。
让编译器发现一些错误：如果你标记了一个函数为override，但它并没有真正重写任何基类中的函数，编译器会报错。这可以帮助你捕获一些可能的错误，例如函数签名的误差。
提高代码的维护性：如果基类的虚函数在未来发生改变（例如参数类型或数量的改变），但是派生类中的重写函数没有相应地改变，那么使用了override关键字的函数会在编译时报错，这样可以及时发现并修复问题。
提高代码的稳定性：使用override关键字可以确保当基类的虚函数接口改变时，所有的派生类都会得到更新，否则编译器会报错。这可以防止因接口改变而导致的运行时错误。
提高代码的可读性和可理解性：override关键字明确地表明了函数是重写了基类中的函数，这对于阅读和理解代码非常有帮助。
C++ override 关键字的来源：
C++的override关键字是在C++11标准中引入的。在C++11之前，C++并没有提供一种明确的方式来表明一个函数是重写了基类中的虚函数。这可能会导致一些错误，例如如果派生类中的函数签名与基类中的虚函数不完全匹配，那么这个函数可能不会被视为重写，而编译器也不会报错。
为了解决这个问题，C++11引入了override关键字。通过在派生类中使用override关键字，可以清楚地表明该函数是对基类中的虚函数的重写。如果这个函数并没有真正重写任何基类中的函数，编译器会报错。
这个特性使得C++的代码更加安全，更易于维护。它可以帮助程序员避免一些常见的错误，例如误打误写导致的函数签名不匹配，以及在基类中添加或修改虚函数时忘记更新派生类中的函数等。
使用示例
#include&lt;iostream&gt; using namespace std; class Base { public: // 虚函数 virtual void statmem() { cout &lt;&lt; "基类函数" &lt;&lt; endl; } }; class Derived :public Base { public: // override 重写 // final 不允许后续其它类覆盖 void statmem() override final { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b07bca9b606642d2182c62aac7e561af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3cceebce3e4ecc82f232622bec014c3/" rel="bookmark">
			java: 警告: 源发行版 8 需要目标发行版 1.8；(可我的项目是其他版本啊？)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的项目是1.7 可运行时却要求是1.8
情况1 提示需要1.8 而你刚好项目就是1.8 那么就是配置问题 这里就不描述怎么解决了 方案很多。
情况2 项目用的不是XX版本却提示需要XX版本 在你的Maven目录的conf文件夹下settings.xml中下面
不知道maven目录在哪从这里看
如果这里指定了jdk版本的话，那么所有项目将依据这个jdk版本进行编译，万一有些项目需要用到不同的jdk进行编译的话，就容易出问题。
找到截图中的 java版本 把profile标签内的全部注释掉就好了！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbe1df29a030f367549c9416822c0cec/" rel="bookmark">
			HTML读书笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTML的读书笔记
概述 Jack
2023.10.23
参考网站：
w3school 在线教程
HTML 头部 | 菜鸟教程
本教程已教你如何使用 HTML 创建站点。
HTML 是一种在 Web 上使用的通用标记语言（并不是类似Python一样的编程语言）。HTML 允许你格式化文本，添加图片，创建链接、输入表单、框架和表格等等，并可将之存为文本文件，浏览器即可读取和显示。
HTML 的关键是标签，其作用是指示将出现的内容。
&lt;!DOCTYPE&gt;声明有助于浏览器中正确显示网页。用于表明使用的HTML的版本，因为HTML1991年就诞生了，一直在不断地升级；
&lt;!DOCTYPE html&gt;
目前在大部分浏览器中，直接输出中文会出现中文乱码的情况，这时候我们就需要在头部将字符声明为 UTF-8 或 GBK。
&lt;meta charset="UTF-8"&gt;
HTML 编辑器推荐：VS Code：Visual Studio Code - Code Editing. Redefined
在线编辑器：HTML/CSS/JS 在线工具 | 菜鸟工具
可以将文档保存为test.html，放进D盘，然后把D:/test.html放进浏览器就可以显示出来HTML的效果。
VS code编译器：
Run and Debug
View &gt; Run (Ctrl+Shift+D)
浏览器的页面右击，点击查看网页源代码，显示出来的就是HTML标记内容；
注释： &lt;!-- 这是一个注释 --&gt;
基础 &lt;h1&gt;这是一个标题&lt;/h1&gt;
&lt;p&gt;这是一个段落。&lt;/p&gt;
&lt;a href="https://www.runoob.com"&gt;这是一个链接&lt;/a&gt;
&lt;img decoding="async" src="/images/logo.png" width="258" height="39" /&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbe1df29a030f367549c9416822c0cec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb60803dae16e74c926f270ffa1bf14b/" rel="bookmark">
			js算法-动态规划-小米2023秋招前端笔试真题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 到达终点的最大步数 给一个长度为n的数组nums，以及一个整数k，你的起点在下标0，终点在下标n-1，若i&lt;j且abs(num[i]-num[j])&lt;=k,则你可以从下标i跳到下标j。求到终点的最大步数，若无法到达终点，则返回-1.
输入：nums=[1,3,6,4,1] ，k=2 输出：3
输入：nums=[1,3,6,4,2] ，k=3 输出：5
代码 function getMaxSteps(nums,k){ let n=nums.length let dp=New Array(n).fill(-1) dp[0]=0 for (let i=1;i&lt;n;i++){ for(let j=i-1;j&gt;=0;j--){ if(Math.abs(nums[i]-nums[j]&lt;=k &amp;&amp; dp[j]!==-1)){ dp[i]=Math.max[dp[i],dp[j]+1] } } } return dp[n-1] } 解析 在这个题目中，动态规划的思想是通过构建一个一维数组 dp 来解决问题。该数组的长度与输入数组 nums 的长度相同，dp[i]的值表示数组中达到第 i 个元素的最大步数。
动态规划的核心思想是利用已经计算过的子问题的解来求解更大规模的问题。在这个题目中，我们可以利用已经计算过的子数组的最大步数来计算当前位置的最大步数。
具体实现如下：
首先，定义变量 n 并赋值为数组 nums 的长度。创建一个长度为 n 的数组 dp，并将所有元素初始化为 -1。dp 数组用于存储每个位置的最大步数。将 dp 数组的第一个元素 dp[0] 初始化为 0，表示以第一个元素结尾的子数组中，最大步数为 0。使用一个循环遍历数组 nums，从第二个元素开始（i=1）。对于每个位置 i，内部循环从 i-1 开始向前遍历，直到第一个元素（索引为 0）。在内部循环中，检查当前位置 i 与遍历位置 j 之间的差值是否不超过 k。如果满足上述条件，更新当前位置 i 的最大步数 dp[i]，取当前最大步数 dp[i] 和遍历位置 j 的最大步数 dp[j] 加 1 的较大值，即为到当前i位置的最大步数。最后，返回 dp 数组的最大值，即为整个数组中相邻元素之间的最大步数。 通过这种动态规划的思想，我们可以避免重复计算，并且利用已经计算过的子问题的解来求解更大规模的问题，从而得到相邻元素之间的最大步数。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee64491589e32d24335849367111e9a5/" rel="bookmark">
			基于 SSE 的前端日志展示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，SSE 的基本搭建 参考服务器往浏览器推消息（SSE）应用
2，核心代码 后台 @GetMapping(value = "/log",produces = MediaType.TEXT_EVENT_STREAM_VALUE) public SseEmitter streamLog() { SseEmitter emitter = new SseEmitter(); new Thread(() -&gt; { try { String message; Process process = Runtime.getRuntime().exec("tail -f /Users/waynezhao/Code/Myself/codeTest/log/codeTest.log"); BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream())); while ((message = reader.readLine()) != null){ emitter.send(SseEmitter.event().data(message+"&lt;br&gt;")); // 休眠1秒钟 Thread.sleep(1000); } } catch (Exception e) { emitter.completeWithError(e); } }).start(); return emitter; } 前端 &lt;div&gt; 服务器返回消息: &lt;div id="log-container" style="height: 650px; overflow-y: scroll; background: #333; color: #aaa; padding: 10px;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee64491589e32d24335849367111e9a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59c11b1d0e818e5201fe7a97af43b55b/" rel="bookmark">
			数据结构之二叉树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include "stdio.h" #include "stdlib.h" #include &lt;iostream&gt; #include &lt;stack&gt; #include &lt;queue&gt; using namespace std; #define elemtype char typedef struct binode{ elemtype data; struct binode *lchild,*rchild; bool tag=false; }binode,*bitree; class hikaka_tree{ public: void visit(bitree T); //打印当前结点 void bitree_createbycin(bitree *T); //输入数据创建二叉树 void bitree_createbystr(bitree *T,elemtype *&amp;str); //通过数组创建二叉树 void bitree_preorder_recursive(bitree T); //前序递归遍历 void bitree_inorder_recursive(bitree T); //中序递归遍历 void bitree_postorder_recursive(bitree T); //后序递归遍历 void bitree_preorder_non_recursive(bitree T); //前序非递归遍历 void bitree_inorder_non_recursive(bitree T); //中序非递归遍历 void bitree_postorder_non_recursive(bitree T); //后序非递归遍历 void bitree_levelorder(bitree T); //层次遍历 }; void hikaka_tree::visit(bitree T) { if(T!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59c11b1d0e818e5201fe7a97af43b55b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df41775b5064e318b9bdc45122c323e0/" rel="bookmark">
			死锁避免策略-银行家算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 目录
前言
一、数据结构
二、算法设计
1.流程图
2.C++实现
前言 银行家算法是由迪杰斯特拉提出在避免死锁的算法，该算法原为银行系统而设计，防止发放现金贷款时不能满足客户需要，在OS中可用于避免进程死锁。
一、数据结构 1.当前可利用资源向量 available
2.最大需求矩阵 max
3.已分配矩阵 allocation
4.剩余需求矩阵 need
5.进程发出的请求向量 request
注：
Need[i,j] = Max[i,j] - allocation[i, j]
二、算法设计 1.流程图 2.C++实现 //银行家算法 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; /* 当前可利用资源向量 available 最大需求矩阵 max 已分配矩阵 allocation 剩余需求矩阵 need 进程发出的请求向量 request */ void renewavailable(int *available,vector&lt;int&gt; allocation);//更新可利用资源量 bool safe(vector&lt;vector&lt;int&gt;&gt; &amp;max,vector&lt;vector&lt;int&gt;&gt; &amp;allocation,int *available,vector&lt;vector&lt;int&gt;&gt; &amp;need);//安全性算法 int banker_algorithm(vector&lt;vector&lt;int&gt;&gt; max,vector&lt;vector&lt;int&gt;&gt; &amp;allocation,int *available,int *request,int i);//银行家算法 void renewavailable(int *available,vector&lt;int&gt; allocation) { for(int i=0;i&lt;3;i++) { available[i]+=allocation[i]; } } bool safe(vector&lt;vector&lt;int&gt;&gt; &amp;max,vector&lt;vector&lt;int&gt;&gt; &amp;allocation,int *available,vector&lt;vector&lt;int&gt;&gt; &amp;need) { //设置进程访问标记为，false为未访问 bool tag[5]={false,false,false,false,false}; int count=5; while(count--) { for(int i=0;i&lt;need.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df41775b5064e318b9bdc45122c323e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39167b2e1403cc402b0ed36ea8c458cc/" rel="bookmark">
			无偏估计协方差和运行协方差
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运行协方差 (Running Covariance):
运行协方差是一种在实时数据流中估计协方差矩阵的方法。它允许在不断到达新数据点时持续更新协方差。下面是运行协方差的计算方法：
初始化协方差矩阵 (Cov) 和均值向量 (Mean)。
初始时，Cov 是一个零矩阵，Mean 是零向量。 当新数据点 (X) 到达时，使用以下公式更新协方差和均值：
更新均值 (Mean)：
Mean = (Mean * N + X) / (N + 1) 其中，N 是已经处理的数据点数量。
更新协方差 (Cov)：
Cov = (Cov * N + (X - Mean) * (X - Mean)^T) / (N + 1) 这里，^T 表示转置操作。
重复步骤 2，每次到达新数据点时都会更新均值和协方差。
无偏估计协方差 (Unbiased Sample Covariance):
无偏估计协方差是一种用于计算样本协方差矩阵的方法，以便获得无偏估计。它通常用于统计学和数据分析中，以估计总体协方差矩阵。下面是无偏估计协方差的计算方法：
初始化协方差矩阵 (Cov) 和均值向量 (Mean)。
初始时，Cov 是一个零矩阵，Mean 是零向量。 当新数据点 (X) 到达时，使用以下公式更新均值和协方差：
更新均值 (Mean) 同样使用以下公式：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39167b2e1403cc402b0ed36ea8c458cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/433a275d6e4d88b36f9907f9fdfef93b/" rel="bookmark">
			5G基带厂商
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 上海星思半导体
2.上海展锐
3.asr
4.huawei
5.mtk/gaotong
6.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d23d38ff3e9531d47310cb98b976711/" rel="bookmark">
			MQTT协议简介及其应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简介 MQTT（Message Queuing Telemetry Transport，消息队列遥测传输）是一种基于发布/订阅模式的“轻量级”通讯协议，该协议构建于TCP/IP协议上，由IBM在1999年开发。MQTT最大的优点在于，能够以极低的带宽，提供可靠的网络服务。其适合于物联网设备，不依赖于设备的操作系统或处理器能力。
二、使用场景 MQTT协议因其低带宽、低功耗和高可靠性的特点，被广泛应用于物联网领域。以下是一些常见的应用场景：
远程监控：通过MQTT协议，可以实时收集和发送设备的状态信息，如温度、湿度、压力等。
智能家居：MQTT协议可以用于控制家庭自动化系统的各种设备，如智能灯泡、智能插座、智能门锁等。
工业自动化：在工业4.0的背景下，MQTT协议可以用于连接各种工业设备，实现设备的远程监控和控制。
车联网：MQTT协议可以用于车辆的实时位置追踪、车辆状态监控等。
能源管理：MQTT协议可以用于电力、燃气等能源的实时监控和管理。
三、报文含义 MQTT协议的报文主要包括以下几个部分：
固定头：包含消息类型和DUP标志位，DUP标志位表示是否是重复的消息。
可变头：包含保留标志位、QoS级别和主题名。
消息体：根据不同的消息类型，消息体的内容也会有所不同。例如，对于PUBLISH类型的消息，消息体就是发布的消息内容；对于PUBACK类型的消息，消息体就是空的。
四、MQTT协议的工作方式 MQTT协议基于发布/订阅模式工作，客户端可以分为发布者（Publisher）和订阅者（Subscriber）。发布者负责发布消息，订阅者负责接收消息。当一个发布者发布一个消息时，所有订阅了该主题的订阅者都会收到这个消息。这种模式可以实现一对多的消息传递，非常适合于物联网的场景。
五、MQTT协议的优点 轻量级：MQTT协议是轻量级的协议，可以在低带宽、高延迟或不稳定的网络环境中运行。
简单易用：MQTT协议的报文结构简洁，易于理解和实现。
高效：MQTT协议使用了发布/订阅模式，可以实现一对多的消息传递，提高了消息传递的效率。
可靠：MQTT协议支持三种不同的服务质量（QoS）级别，可以根据应用的需求选择不同的服务质量级别。
六、总结 MQTT协议以其轻量级、简单易用、高效和可靠的优点，成为了物联网领域中广泛使用的通讯协议。随着物联网的发展，MQTT协议的应用将会更加广泛。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eddd6efa7d9975ec9a1661bded99d427/" rel="bookmark">
			软考初级程序员备考--第一章
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.1计算机系统的基本组成
1.1.1计算机硬件
1.1.2计算机软件
1.1.3计算机分类
1.2数据的表示以及运算
1.2.1数制与转换
1.2.1.1整数
1.2.1.2小数（不常考，随便看看就可以）
1.2.2运算
1.2.3机器数与码制
1.2.4定点数、浮点数、校验码
1.3计算机系统组成--硬件系统
1.3.1计算机组成
1.3.2计算机的存储单位和转换
1.3.3计算机的性能指标
1.3.4输入输出技术
1.1计算机系统的基本组成 其中cpu是我们计算机系统的核心，cpu又被称为中央处理单元。cpu和内存储器合称为主机。
1.1.1计算机硬件 运算器主要完成算数运算和逻辑运算，比如：加法减法循环等等。
控制器主要是从主存中取出命令进分析，控制各个部件完成指令。
内存储器容量小速度快，一般用来临时存放计算机运行时所需的程序、数据以及中间结果。
外存储器容量大速度慢，用于长期存储数据。
寄存器是cpu的记忆设备，用于临时存放指令、数据以及运算结果。与内存相比，寄存器速度快得多。
1.1.2计算机软件 计算机软件是指管理、运行、维护以及应用计算机所开发的程序和相关文档集合。
1.1.3计算机分类 （1）个人移动设备
（2）桌面计算机
（3）服务器：提供大规模和可靠文集及计算机服务。
（4）集群/仓库级计算机：将数万个服务器连接在一起形成的大规模集群。
（5）超级计算机：我国的超级计算机有银河、天河、曙光、神威四个系列。
（6）嵌入式计算机。专用领域，针对某一个特殊的需求设计的计算机。如洗衣机、数码产品等。
1.2数据的表示以及运算 1.2.1数制与转换 1.2.1.1整数 十进制（D）、二进制（B）、八进制（O）、十六进制（H）
要学会二进制转八进制和十六进制，要先学会二进制转十进制，这个高中初中都学过，就不废话了。直接进入正题：
十进制转二进制： 十进制转八进制：同上，除以2变成除以8
十进制转十六进制：同上。
十六进制转十进制：
八进制转十进制：同上
八进制转十六进制：都得先转化为十进制在转化为十六进制
十六进制转八进制：都得先转化为十进制在转换为八进制。这里不多演示。
1.2.1.2小数（不常考，随便看看就可以） 各个进制转化为十进制：
十进制转化为各个进制：
二进制转八进制、十六进制
1.2.2运算 二进制的加减法和十进制一样。（简单不需要看）
逻辑运算：与、或、异或
与：（全1为1）符号：∧
01000101 或：（全0为0）符号：∨
01001111 异或：（同0非1）符号：⊕
01001110 非：（直接取反）符号：¬或者在数字上方加一个“—”
例题：
1.2.3机器数与码制 计算机机器数都是采用二进制的计数方式，小数点隐含表示，不占位置。
无符号数：即小数点默认位于机器数最后为之后，计数纯整数。
有符号数：即机器数最高位表示正负，正0负1。
原码、反码、补码、移码：（带符号）（八位）
原码0100011111100011第一位表示符号，其余表示值反码0100011110011100正数的反码是其本身，负数的反码是除符号位外其余取反。补码0100011110011101正数的补码是其本身，负数的补码是反码+1。移码1100011101100011在补码的基础上，数值部分不变，符号位取反。 特例：（经常考哈，记住了）
1.对于0的补码，[+0]补=0000 0000,[-0]补=0000 0000。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eddd6efa7d9975ec9a1661bded99d427/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e781dc3dfcabcb6cf55afe27dfcd325/" rel="bookmark">
			Redis数据结构完全解析：底层实现细节揭秘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 🍊 简单字符串🎉 问题1：SDS结构体的三个属性分别表示什么意思？🎉 问题2：SDS字符串的内存分配方式是怎么样的？🎉 问题3：SDS字符串的拼接操作是怎么样的？🎉 问题4：什么场景下使用它？怎么优化它？ 🍊 链表🍊 跳跃表🍊 字典🍊 压缩列表🎉 压缩列表的结构🎉 压缩列表的节点📝 1. 字符串类型📝 2. 整数类型📝 3. 列表节点📝 4. 压缩表节点 🎉 压缩列表的优缺点🎉 压缩列表的应用 🍊 整数集合🎉 1. 内存占用🎉 2. 添加和删除操作🎉 3. 查询操作 📕我是廖志伟，一名Java开发工程师、Java领域优质创作者、CSDN博客专家、51CTO专家博主、阿里云专家博主、清华大学出版社签约作者、产品软文创造者、技术文章评审老师、问卷调查设计师、个人社区创始人、开源项目贡献者。🌎跑过十五公里、徒步爬过衡山、🔥有过三个月减肥20斤的经历、是个喜欢躺平的狠人。
📘拥有多年一线研发和团队管理经验，研究过主流框架的底层源码(Spring、SpringBoot、Spring MVC、SpringCould、Mybatis、Dubbo、Zookeeper)，消息中间件底层架构原理(RabbitMQ、RockerMQ、Kafka)、Redis缓存、MySQL关系型数据库、 ElasticSearch全文搜索、MongoDB非关系型数据库、Apache ShardingSphere分库分表读写分离、设计模式、领域驱动DDD、Kubernetes容器编排等。🎥有从0到1的高并发项目经验，利用弹性伸缩、负载均衡、报警任务、自启动脚本，最高压测过200台机器，有着丰富的项目调优经验。
📙经过多年在CSDN创作上千篇文章的经验积累，我已经拥有了不错的写作技巧。同时，我还与清华大学出版社签下了四本书籍的合约，并将陆续在明年出版。这些书籍包括了基础篇、进阶篇、架构篇的📌《Java项目实战—深入理解大型互联网企业通用技术》📌，以及📚《解密程序员的思维密码–沟通、演讲、思考的实践》📚。具体出版计划会根据实际情况进行调整，希望各位读者朋友能够多多支持！
希望各位读者大大多多支持用心写文章的博主，现在时代变了，信息爆炸，酒香也怕巷子深，博主真的需要大家的帮助才能在这片海洋中继续发光发热，所以，赶紧动动你的小手，点波关注❤️，点波赞👍，点波收藏⭐，甚至点波评论✍️，都是对博主最好的支持和鼓励！
💂 博客主页： 我是廖志伟👉开源项目：java_wxid🌥 哔哩哔哩：我是廖志伟🎏个人社区：幕后大佬🔖个人微信号： SeniorRD 💡在这个美好的时刻，本人不再啰嗦废话，现在毫不拖延地进入文章所要讨论的主题。接下来，我将为大家呈现正文内容。
🍊 简单字符串 SDS的优势主要在于解决了C语言处理字符串中的一些问题，例如长度和内存重新分配问题以及结尾标识问题。因为SDS有len属性和free属性记录字符串长度和剩余空间，所以可以避免C语言需要遍历来计算字符串长度的问题，也可以避免每次修改字符串都需要重新分配内存的问题，因为它可以通过检查len属性判断是否需要扩展内存，并且有free属性来记录剩余空间用于后续操作。而SDS以len作为结尾标识，避免了C语言中空字符串结尾标识可能中途截断字符串的问题。
举个例子，如果我们需要在字符串末尾添加一个字符，在C语言中需要重新分配内存并将原有数据复制到新的内存中，而对于SDS则只需要判断是否有足够的空闲空间，如果没有则扩展内存，并将新字符添加到字符串末尾即可，不需要重新分配内存和复制数据。
另外，SDS还提供了一些其他的优势，例如二进制安全（因为不是以空字符串结尾），支持O(1)复杂度的字符串长度计算和拼接操作等。
举个例子来说，假设我们有一个字符串“Hello World!”。如果使用char*来表示它，我们需要手动计算字符串长度，并为其准备缓冲区。这个过程很容易出错，而且无法动态地调整字符串大小。但是，如果我们使用SDS来存储这个字符串，我们只需要调用一个函数就可以获取字符串长度，而且在需要更改字符串大小时，SDS会自动地为其准备缓冲区，不需要我们手动操作。这样可以大大地减少程序员出错的可能性，同时也提高了代码的可维护性。
🎉 问题1：SDS结构体的三个属性分别表示什么意思？ SDS结构体的三个属性分别是len、free和buf[]。
len表示SDS字符串的长度，也就是实际存储的字符个数，不包含结尾的空字符。free表示SDS字符串的剩余空间，也就是还可以存储的字符个数，单位是字节。buf[]是实际存储SDS字符串的字符数组，它的长度是len+free。 举个例子，如果我们创建一个长度为5的SDS字符串“hello”，那么它的len为5，free则取决于SDS内存分配策略和实际使用情况，buf[]则是一个长度为10（5+5）的字符数组，其中前5个元素存储了字符串“hello”的内容，后面5个元素未使用。
🎉 问题2：SDS字符串的内存分配方式是怎么样的？ SDS字符串的内存分配方式主要有两种，一种是预分配内存，另一种是惰性扩展内存。
预分配内存是指在创建SDS字符串时为它分配足够的内存空间以存储预估的最大字符串长度。例如，我们可以为一个长度为15的字符串预分配20个字节的空间，这样在字符串长度增加时就可以直接修改buf[]中的内容，而不需要每次都重新分配内存。
惰性扩展内存是指在SDS字符串长度增加时，只分配刚好能够存储新字符的空间，而不是直接分配预估的最大字符串长度。例如，我们可以为一个长度为15的字符串惰性扩展5个字节的空间以存储一个新字符，这样可以节省内存空间的使用。
SDS字符串支持这两种内存分配方式的原因是因为它有free属性记录剩余空间，在进行字符串修改时可以通过检查free是否足够来决定是否需要分配更多的空间。如果free不足，则可以使用预分配的内存空间扩展SDS字符串，如果free足够，则可以使用惰性扩展内存的方式在buf[]中存储新字符。
🎉 问题3：SDS字符串的拼接操作是怎么样的？ SDS字符串的拼接操作是通过调用SDS库中提供的API函数来实现的，例如sdscat、sdscatprintf等函数。这些函数可以将一个SDS字符串和另一个SDS字符串、C字符串、整数等拼接在一起，并返回一个新的SDS字符串。
例如，我们可以使用sdscat函数将一个长度为5的SDS字符串“hello”和另一个长度为6的SDS字符串“world！”拼接在一起，得到一个长度为12的新SDS字符串“hello world！”。实现代码如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e781dc3dfcabcb6cf55afe27dfcd325/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8992a675e9257c8fb7576d4edab5e3ab/" rel="bookmark">
			【C&#43;&#43;】布隆过滤器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🚀write in front🚀
📜所属专栏： C++学习
🛰️博客主页：睿睿的博客主页
🛰️代码仓库：🎉VS2022_C语言仓库
🎡您的点赞、关注、收藏、评论，是对我最大的激励和支持！！！
关注我，关注我，关注我，你们将会看到更多的优质内容！！
文章目录 前言一.布隆过滤器的概念二.布隆过滤器的实现：注意： 三.布隆过滤器的误判四.布隆过滤器的优缺点：布隆过滤器优点布隆过滤器缺陷 五.哈希切割：题目1：题目2： 总结 前言 哈希还有一个重要的用途就是布隆过滤器。之前的位图只能对于整数进行判断是否存在，整形有一个固定的范围，但是对于字符串这些没有范围的数据怎么判断在不在呢？字符串在通过哈希函数转化成的数据对应的位置可能和其他字符串通过哈希函数转化的数据相同，这样就会造成误判。
所以我们可以让多个哈希函数对一个字符串转化成多个数据进行标记，这样误判就会少了不少。而这就是布隆过滤器的初形。
在大多数游戏里面，取名都不能取相同的名字。所以就要判断这个昵称是否存在，底层可以用哈希表，但是玩家的数量太多了，都是以亿这个量级来就算，那么采用哈希表就会造成大量的空间浪费；如果用位图，但位图一般只能用于处理整型数据。
那么我们就可以采用哈希表+位图，即布隆过滤器来完成检测这个昵称是否已经被注册。上面的字符串的举例就是布隆过滤器，在实际中判断名称是否重复都是用下面的方式：
一.布隆过滤器的概念 布隆过滤器是由布隆在1970年提出的 一种紧凑型的、比较巧妙的概率型数据结构，特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在”，它是用多个哈希函数，将一个数据映射到位图结构中。此种方式不仅可以提升查询效率，也可以节省大量的内存空间。
二.布隆过滤器的实现： 布隆过滤器的关键就是他使用了多个哈希函数（可以参考这篇文章：哈希函数)在这里挑选了三个误判率最低的哈希函数。
#include&lt;iostream&gt; #include&lt;bitset&gt; using namespace std; //这里采用仿函数的形式封装哈希函数 struct BKDRHash { size_t operator()(const string&amp; str) { size_t hash = 0; for (auto ch : str) { hash = hash * 131 + ch; } //cout &lt;&lt;"BKDRHash:" &lt;&lt; hash &lt;&lt; endl; return hash; } }; struct APHash { size_t operator()(const string&amp; str) { size_t hash = 0; for (size_t i = 0; i &lt; str.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8992a675e9257c8fb7576d4edab5e3ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7df190bbba4dbbab4ddcbab28973079/" rel="bookmark">
			2023网络安全工程师面试题汇总（附答案）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、面试开场白 一般首先是一段例行的开场自（说）我（学）介（逗）绍（唱），在这里我直接给你个万能公式：
1、在xx安全论坛投稿过xx篇文章，获得xx元稿费。
2、在xx众测,提交过xx漏洞，获得过xx元奖金。
3、有x年以上的Web/App漏洞挖掘、业务逻辑漏洞挖掘经验。
4、精通xx,xx,xx语言，能独立开发poc和exp。
5、获取xx张CNVD证书 和 xx CVE编号。
6、在xx安全会议上进行过xx演讲。
面试官要在这几分钟看看你的表达能力和随便翻翻你的简历，之后就会根据他们感兴趣的点开始面（盘）试（问）了，重点来了，经常被问到的有以下几点：
1、对安全行业的了解啊，之前有没有安全行业的实习或者工作经验啊；
2、毕设的方向啊，研究内容是不是有深度啊；
3、实习工作的内容啊，参与的实习项目，在项目中承担的工作及完成情况；
4、面试职位的优势啊，个人的优缺点啊；
当然上面这些都是很常规的，有些职位如渗透测试、漏洞挖掘、安全研究员之类的就会有各种意想不到的问题了……
如果问你离职原因：可以回答在公司个人发展受限，别整出“公司不被允许员工过年回家”的烂借口。
作为一个安全老司机，我曾经作为面试者被面试官折磨过，也作为面试官折磨过面试者，总结了以下几点经验供安全小白们参考：
1、简历切记不要贪全，页数不要太多，要结合面试职位突出重点；
2、了解专业技术问题，比如面试“WEB渗透测试”岗位，至少要掌握owasp top 10 的漏洞原理和测试方法吧；
3、代码作品可以附上github地址，有些技术类的面试官还真是回去看你的github，如果有像样儿的作品可以给自己加分不少；
4、提交过的漏洞编号，比如高大上的CVE啊、接地气的CNVD啊等等；
5、在互联网src提交过的经典漏洞和名次，用这个证明下实战经验还是不错的，至少比你说做过黑产要好。
二、高频面试题汇总 本套面试题，已整理成pdf文档，但内容还在持续更新中，因为无论如何都不可能覆盖所有的面试问题，更多的还是希望由点达面，查漏补缺，如果你感兴趣的话，可以点击链接【282G】网络安全&amp;黑客技术零基础到进阶全套学习大礼包（附面试题），免费分享！ 2.1、web部分： 1. sql注入部分
SQL注入原理SQL注入的种类？SQL注入的绕过有了解过吗？有绕过那些WAF？绕WAF的方法有哪些？介绍一下你的SQL注入流程SQL注入一开始用来判断数据库类型的语句是什么？讲一下sql写入webshell的条件，如果你在的目录没有执行权限怎么办讲讲sql注入的条件SQL注入里面有一个into outfile函数有什么作用？xp_cmdshell有了解过吗？能用来做什么你有了解过那些数据库的sql注入？简单说一下，你是怎么快速判断它属于那个数据库的呢？时间延时注入的原理？sleep()函数不能用你一般会怎么处理HTTP头注入了解过吗？注入点一般存在于那些地方SQL注入的防护方法有哪些呢？预编译的原理是什么呢？Orderby注入了解吗 2. xss部分
xss的原理是什么？xss的三种类别有什么不同xss存在于那些地方？仅仅是前端吗？xss用script就可以反射了吗？存储型和反射型有什么区别？本质上的区别反射性xss的前提是什么呢xss的防护方法有哪些呢？要是有了httponly是不是就不能xss绕过了呢？在已经有shell的情况下，如何使用xss实现对目标站的长久控制 3. ssrf部分
讲一下ssrf的利用以及ssrf的成因ssrf一般出现在哪里，你是如何判断这个点存在是ssrf漏洞的如何防御ssrf漏洞呢ssrf有哪些绕过方法 4. csrf部分
讲一下csrf原理csrf的防御方法有哪些？referer验证和token那个安全级别高呢？分别介绍一下两个 5. 文件上传
讲一下条件竞争的原理文件上传WAF怎么绕过文件上传常见绕过方法文件上传如何防护？白名单校验和黑名单校验二次渲染了解过吗？你是怎么确定加入shell的位置的 6. 文件包含
文件包含的函数有哪些？include和require的区别伪协议你了解哪些？伪协议的条件（需要开启那些配置) 7. XXE
xxe的原理xxe语句怎么去构建你是怎么判断存在xxe漏洞的xxe漏洞的危害有那些？你是怎么利用xxe漏洞的呀？怎么防御xxe漏洞 8. 命令执行
命令执行相关函数命令执行WAF绕过吗php.ini启用disable_functions，怎么绕过 9. 代码执行
代码执行相关函数 10. 业务逻辑漏洞
了解过那些逻辑漏洞支付的逻辑漏洞，你是怎么改价格的，讲三种方法？ 2.2、内网部分： 1. 提权
常用哪些方式提权？请讲一下udf提权linux的提权方法有哪些 2. 代理转发
代理转发常用的工具有哪些？ew的正向代理和反向代理讲一下讲一下ssh代理还有frp代理Neo-reGeorg代理是如何做的ew和neoreg的区别 3. 内网信息搜集
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7df190bbba4dbbab4ddcbab28973079/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b71bb7cdc8ec752368f7f55bb1dcc98c/" rel="bookmark">
			Python（黄金时代）—— 让文字来说话
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 在当前时代，文字与语音的转换已经成为一种必不可少的需求。无论是语音助手、语音聊天机器人还是有声书籍等等，文字到语音的转换技术正在发挥着重要的作用。而在Python编程语言中，pyttsx3库为我们提供了一个简便而强大的文字朗读解决方案。 什么是pyttsx3库？ pyttsx3是Python提供的一个文字转语音（Text to Speech）库。 它基于Microsoft的语音技术，并提供了简单而灵活的API，允许我们将文字转换成自然流畅的语音输出。 都有些什么功能？ 朗读单词或句子：利用pyttsx3库，我们可以轻松地让Python朗读出我们指定的单词或句子。 调整语速和音量：pyttsx3库允许我们根据需要调整朗读的语速和音量，提供更加个性化的语音输出。 改变语音的性别和语言：通过设置不同的语音引擎和语言参数，我们可以改变语音的性别和使用的语言，实现灵活多样的朗读效果。
代码操作 安装
pip install pyttsx3 简单示例
import pyttsx3 # 创建一个Engine对象 engine = pyttsx3.init() # 朗读一段文字 engine.say("你好,欢迎关注 程序猿知秋") # 等待朗读完成 engine.runAndWait() 运行上述代码，你将会听到一段朗读出来的文字！！！
其它功能 调整语速和音量
import pyttsx3 # 创建一个Engine对象 engine = pyttsx3.init() # 设置语速和音量 engine.setProperty('rate', 150) # 语速范围一般在50-300之间，默认为200 engine.setProperty('volume', 0.7) # 音量范围在0.0-1.0之间，默认为1.0 # 朗读一段文字 engine.say("你好,欢迎关注 程序猿知秋") # 等待朗读完成 engine.runAndWait() 注：设置语速和音量的代码 要放到 朗读文字设置之前 改变语音的性别和语言 import pyttsx3 # 创建一个Engine对象 engine = pyttsx3.init() # 获取所有可用的voices列表 voices = engine.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b71bb7cdc8ec752368f7f55bb1dcc98c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa4acd2a7553ccf7de7cf9c53756d5c9/" rel="bookmark">
			这是我见过对redis最直白的讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我是Redis 你好，我是Redis，一个叫Antirez的男人把我带到了这个世界上。
说起我的诞生，跟关系数据库MySQL还挺有渊源的。
在我还没来到这个世界上的时候，MySQL过的很辛苦，互联网发展的越来越快，它容纳的数据也越来越多，用户请求也随之暴涨，而每一个用户请求都变成了对它的一个又一个读写操作，MySQL是苦不堪言。尤其是到“双11”、“618“这种全民购物狂欢的日子，都是MySQL受苦受难的日子。
据后来MySQL告诉我说，其实有一大半的用户请求都是读操作，而且经常都是重复查询一个东西，浪费它很多时间去进行磁盘I/O。
后来有人就琢磨，是不是可以学学CPU，给数据库也加一个缓存呢？于是我就诞生了！
出生不久，我就和MySQL成为了好朋友，我们俩常常携手出现在后端服务器中。
应用程序们从MySQL查询到的数据，在我这里登记一下，后面再需要用到的时候，就先找我要，我这里没有再找MySQL要。
为了方便使用，我支持好几种数据结构的存储：
String
Hash
List
Set
SortedSet
Bitmap
······
因为我把登记的数据都记录在内存中，不用去执行慢如蜗牛的I/O操作，所以找我要比找MySQL要省去了不少的时间呢。
可别小瞧这简单的一个改变，我可为MySQL减轻了不小的负担！随着程序的运行，我缓存的数据越来越多，有相当部分时间我都给它挡住了用户请求，这一下它可乐得清闲自在了！
有了我的加入，网络服务的性能提升了不少，这都归功于我为数据库挨了不少枪子儿。
缓存过期 &amp;&amp; 缓存淘汰 不过很快我发现事情不妙了，我缓存的数据都是在内存中，可是就算是在服务器上，内存的空间资源还是很有限的，不能无节制的这么存下去，我得想个办法，不然吃枣药丸。
不久，我想到了一个办法：给缓存内容设置一个超时时间，具体设置多长交给应用程序们去设置，我要做的就是把过期了的内容从我里面删除掉，及时腾出空间就行了。
超时时间有了，我该在什么时候去干这个清理的活呢？
最简单的就是定期删除，我决定100ms就做一次，一秒钟就是10次！
我清理的时候也不能一口气把所有过期的都给删除掉，我这里面存了大量的数据，要全面扫一遍的话那不知道要花多久时间，会严重影响我接待新的客户请求的！
时间紧任务重，我只好随机选择一部分来清理，能缓解内存压力就行了。
就这样过了一段日子，我发现有些个键值运气比较好，每次都没有被我的随机算法选中，每次都能幸免于难，这可不行，这些长时间过期的数据一直霸占着不少的内存空间！气抖冷！
我眼里可揉不得沙子！于是在原来定期删除的基础上，又加了一招：
那些原来逃脱我随机选择算法的键值，一旦遇到查询请求，被我发现已经超期了，那我就绝不客气，立即删除。
这种方式因为是被动式触发的，不查询就不会发生，所以也叫惰性删除！
可是，还是有部分键值，既逃脱了我的随机选择算法，又一直没有被查询，导致它们一直逍遥法外！而于此同时，可以使用的内存空间却越来越少。
而且就算退一步讲，我能够把过期的数据都删除掉，那万一过期时间设置的很长，还没等到我去清理，内存就吃满了，一样要吃枣药丸，所以我还得想个办法。
我苦思良久，终于憋出了个大招：内存淘汰策略，这一次我要彻底解决问题！
我提供了8种策略供应用程序选择，用于我遇到内存不足时该如何决策：
noeviction：返回错误，不会删除任何键值
allkeys-lru：使用LRU算法删除最近最少使用的键值
volatile-lru：使用LRU算法从设置了过期时间的键集合中删除最近最少使用的键值
allkeys-random：从所有key随机删除
volatile-random：从设置了过期时间的键的集合中随机删除
volatile-ttl：从设置了过期时间的键中删除剩余时间最短的键
volatile-lfu：从配置了过期时间的键中删除使用频率最少的键
allkeys-lfu：从所有键中删除使用频率最少的键
有了上面几套组合拳，我再也不用担心过期数据多了把空间撑满的问题了~
缓存穿透 &amp;&amp; 布隆过滤器 我的日子过的还挺舒坦，不过MySQL大哥就没我这么舒坦了，有时候遇到些烦人的请求，查询的数据不存在，MySQL就要白忙活一场！不仅如此，因为不存在，我也没法缓存啊，导致同样的请求来了每次都要去让MySQL白忙活一场。我作为缓存的价值就没得到体现啦！这就是人们常说的缓存穿透。
这一来二去，MySQL大哥忍不住了：“唉，兄弟，能不能帮忙想个办法，把那些明知道不会有结果的查询请求给我挡一下”
这时我想到了我的另外一个好朋友：布隆过滤器
我这位朋友别的本事没有，就擅长从超大的数据集中快速告诉你查找的数据存不存在（悄悄告诉你，我的这位朋友有一点不靠谱，它告诉你存在的话不能全信，其实有可能是不存在的，不过它他要是告诉你不存在的话，那就一定不存在）。
如果你对我这位朋友感兴趣的话，可以看看这里《白话布隆过滤器BloomFilter》。
我把这位朋友介绍给了应用程序，不存在的数据就不必去叨扰MySQL了，轻松帮忙解决了缓存穿透的问题。
缓存击穿 &amp;&amp; 缓存雪崩 这之后过了一段时间太平日子，直到那一天···
有一次，MySQL那家伙正优哉游哉的摸鱼，突然一大堆请求给他怼了过去，给他打了一个措手不及。
一阵忙活之后，MySQL怒气冲冲的找到了我，“兄弟，咋回事啊，怎么一下子来的这么猛”
我查看了日志，赶紧解释到：“大哥，实在不好意思，刚刚有一个热点数据到了过期时间，被我删掉了，不巧的是随后就有对这个数据的大量查询请求来了，我这里已经删了，所以请求都发到你那里来了”
“你这干的叫啥事，下次注意点啊”，MySQL大哥一脸不高兴的离开了。
这一件小事我也没怎么放在心上，随后就抛之脑后了，却没曾想几天之后竟捅了更大的篓子。
那一天，又出现了大量的网络请求发到了MySQL那边，比上一次的规模大得多，MySQL大哥一会儿功夫就给干趴下了好几次！
等了好半天这一波流量才算过去，MySQL才缓过神来。
“老弟，这一次又是什么原因？”，MySQL大哥累的没了力气。
“这一次比上一次更不巧，这一次是一大批数据几乎同时过了有效期，然后又发生了很多对这些数据的请求，所以比起上一次这规模更大了”
MySQL大哥听了眉头一皱，“那你倒是想个办法啊，三天两头折磨我，这谁顶得住啊？”
“其实我也很无奈，这个时间也不是我设置的，要不我去找应用程序说说，让他把缓存过期时间设置的均匀一些？至少别让大量数据集体失效”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa4acd2a7553ccf7de7cf9c53756d5c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5840bd2c56c1b15f6fdbb9e7cb32139f/" rel="bookmark">
			首个多视角自动驾驶场景视频生成世界模型 | DrivingDiffusion: BEV数据和仿真新思路...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击下方卡片，关注“自动驾驶之心”公众号
ADAS巨卷干货，即可获取
&gt;&gt;自动驾驶之心【大模型】技术交流群
笔者的一些个人思考 在自动驾驶领域，随着BEV-based子任务/端到端方案的发展，高质量的多视图训练数据和相应的仿真场景构建愈发重要。针对当下任务的痛点，“高质量”可以解耦成三个方面：
不同维度上的长尾场景：如障碍物数据中近距离的车辆以及切车过程中精准的朝向角，以及车道线数据中不同曲率的弯道或较难采集的匝道/汇入/合流等场景。这些往往靠大量的数据采集和复杂的数据挖掘策略，成本高昂。
3D真值-图像的高度一致：当下的BEV数据获取往往受到传感器安装/标定，高精地图以及重建算法本身的误差影响。这导致了我们很难保证数据中的每一组【3D真值-图像-传感器参数】 的精确一致。
满足上述条件基础上的时序数据：连续帧的多视角图像和相应真值，这对于当前的感知/预测/决策/端到端等任务都是必不可少的。
而对仿真来说，可以直接通过布局进行满足上述条件的视频生成，无疑是最直接的multi-agent传感器输入的构造方式。而DrivingDiffusion则从一个新的角度解决了上述问题。
什么是DrivingDiffusion？ DrivingDiffusion是一个用于自动驾驶场景生成的扩散模型框架，实现了布局控制的多视角图像/视频生成并分别实现了SOTA。
DrivingDiffusion-Future作为自动驾驶世界模型有根据单帧图像预测未来场景视频并根据语言提示影响主车/他车运动规划的能力。
DrivingDiffusion生成效果是怎么样的？ 有需要的同学可以先看看项目主页：https://drivingdiffusion.github.io
（1）DrivingDiffusion 布局控制的多视角图像生成
图中展示了以布局投影作为输入的multi-view图像生成效果。
调整布局：精确控制生成结果
图中上半部分展示了生成结果的多样性以及下文中模块设计的重要性。下半部分展示了对正后方的车辆进行扰动的结果，包含移动，转向，碰撞甚至悬浮在空中的场景的生成效果。
布局控制的多视角视频生成
上：DrivingDiffusion在nuScenes数据上训练后的视频生成结果。下：DrivingDiffusion在大量私有真实数据上训练后的视频生成结果。
（2）DrivingDiffusion-Future 根据输入帧+文本描述生成后续帧
使用单帧图像作为输入，根据对主车/他车的文本描述构建后续帧驾驶场景。图中前三行和第四行分别展示了对主车和他车行为进行文本描述控制后的生成效果。（绿框为输入，蓝框为输出)
根据输入帧直接生成后续帧
无需其他控制，仅使用单帧图像作为输入，预测后续帧驾驶场景。（绿框为输入，蓝框为输出)
DrivingDiffusion是如何解决上述问题的？ DrivingDiffusion首先人为地构造场景中的所有3D真值（障碍物/道路结构），在将真值投影为Layout图像后，以此为模型输入得到多相机视角下的真实图像/视频。之所以没有直接使用3D真值（BEV视图或按照编码后的实例）作为模型输入，而是使用参数进行投影后输入，是为了消除系统性的3D-2D一致性误差。（在这样的一组数据中，3D真值和车辆参数都是人为地按照实际需求构造的，前者带来了随意构造罕见场景数据能力，后者消除了传统数据生产中几何一致性的误差。）
此时还剩下一个问题：生成的图像/视频质量能否满足使用需求？
提到构造场景，大家往往会想到使用仿真引擎，然而其生成的数据和真实数据存在着较大的domain gap。GAN-based 方法的生成结果往往和实际真实数据的分布存在一定bias。而Diffusion Models基于马尔可夫链通过学习噪声来生成数据的特性，其生成结果的保真度较高，更适合替代真实数据使用。
DrivingDiffusion依照人为构造的场景和车辆参数，直接生成时序multi-view视图，不仅可以作为下游自动驾驶任务的训练数据，还可以构建用于反馈自动驾驶算法的仿真系统。
这里的“人为构造的场景”仅包含障碍物和道路结构信息，但DrivingDiffusion的框架可以轻松引入标志牌，红绿灯，施工区域等layout信息甚至low-level的occupancy grid/depth map等控制模式。
DrivingDiffusion方法概述 生成多视角视频时，有几个难点：
相较常见的图像生成，多视角视频生成新增了视角和时序两个维度，如何设计一个可以进行长视频生成的框架？如何保持跨视角一致性和跨帧一致性?
从自动驾驶任务的角度，场景中的实例至关重要，如何保证生成实例的质量?
DrivingDiffusion主要设计了一个通用的训练框架，将stable-diffusion-v1-4模型作为图像的预训练模型，并使用3D伪卷积将原有图像输入膨胀，用于处理视角/时序新增的维度后输入3D-Unet，在得到了处理新增维度的扩散模型后，进行了交替迭代式的视频扩展，通过关键帧控制和微调的操作保障了短时序和长时序的整体一致性。此外，DrivingDiffusion提出了Consistency Module和Local Prompt，分别解决了跨视角/跨帧一致性和实例质量的问题。
DrivingDiffusion生成长视频流程 单帧多视角模型：生成multi-view关键帧，
以关键帧作为额外控制，多视角共享的单视角时序模型：并行对各个view进行时序扩展，
以生成结果为额外控制的单帧多视角模型：时序并行地微调后续帧，
确定新关键帧并通过滑动窗口延长视频。
跨视角模型和时序模型的训练框架 对于multi-view模型和时序模型来说，3D-Unet的扩展维度分别为视角和时间。二者都有相同的布局控制器。作者认为后续帧可以从multi-view关键帧获取场景中的信息，并隐式地学习不同目标的关联信息。二者分别使用了不同的一致性注意力模块和相同的Local Prompt模块。
布局编码：障碍物类别/实例信息和道路结构分割布局，分别以不同的固定编码值编码为RGB图像，经过encode后输出布局token。
关键帧控制：所有的时序扩展过程，都采用了某一关键帧的multi-view图像，这是基于在短时序内的后续帧可以从关键帧获取信息的假设。所有的微调过程都以关键帧和其生成的后续某帧的multi-view图像作为额外控制，输出优化该帧跨视角一致性后multi-view图像。
基于特定视角的光流先验：对于时序模型，训练时只进行某个视角下数据的采样。额外使用提前统计的该视角图像下每个像素位置的光流先验值，编码后作为相机ID token，进行类似扩散过程中的time embedding对hidden层的交互控制。
Consistency Module &amp; Local Prompt Consistency Module分为两部分：一致性注意力机制和一致性关联损失。
一致性注意力机制关注了相邻视角和时序相关帧的交互，具体来说对于跨帧一致性仅仅关注存在overlap的左右相邻视角的信息交互，对于时序模型，每一帧只关注关键帧以及前一帧。这避免了全局交互带来的巨大计算量。
一致性关联损失通过像素级关联并回归位姿来添加几何约束，其梯度由一个预先训练的位姿回归器提供。该回归器基于LoFTR添加位姿回归head，并在相应数据集的真实数据上使用位姿真值进行训练。对于多视角模型和时序模型该模块分别监督相机相对位姿和主车运动位姿。
Local Prompt和Global Prompt配合，复用了CLIP和stable-diffusion-v1-4的参数语义，对特定类别实例区域进行局部增强。如图所示，在图像token和全局的文字描述提示的交叉注意力机制基础上，作者对某类别进行local prompt设计并使用该类别mask区域的图像token对local prompt进行查询。该过程最大程度地利用了原模型参数中在open domain的文本引导图像生成的概念。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5840bd2c56c1b15f6fdbb9e7cb32139f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c00ba5767820fc7affc32b4afc09ccbf/" rel="bookmark">
			基于单片机智能停车系统的设计与实现(论文&#43;源码)_kaic
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于单机片智能停车系统
摘要： 随着私家车数量的迅速增加, 大中城市的停车问题越来越严重, 人们早已习惯了将问题交给手机来解决。因此, 迫切需要设计一个智能停车管理系统来支持移动终端, 使用户能够通过移动终端实现停车查询、预订和支付。与传统的停车管理系统相比, 智能停车管理系统具有诸多优势。传统停车管理系统的重点是如何控制每辆车的进出, 如何准确地对每辆车进行时间和充电, 但缺乏对用户人性化需求的考虑。为了弥补这些不足, 本文在对当前国内外停车管理和相关文献进行研究的基础上, 提出了一套智能停车管理系统的发展方案。该系统对进出的车牌进行识别, 并将车辆进出时间与车牌号捆绑在一起, 进行成本统计。在移动客户端上, 用户可以搜索其位置周围的停车场信息, 并进行选择和预订。停车引导功能也是系统人性化的一个重要体现。该系统不仅可以提高停车场的智能管理水平, 还能使车辆进入更加方便, 给车主带来良好的用户体验。本文首先介绍了停车管理系统的研究背景和意义, 阐述了与停车管理系统密切相关的视频识别和停车指导的技术原则。然后介绍了该系统的总体方案设计, 通过对停车管理要求的分析, 确定了停车管理系统的功能框架, 并设计了数据库。最后, 对系统的各个模块进行了详细的设计和实现。通过模板匹配和 BP 神经网络对车牌进行识别, 并采用 Dijkstra 算法为保留用户推荐停车位。该系统大大减少了人员对停车管理过程的干扰, 实现了停车场的自动化、智能化管理。
关键词：单机片；视频识别；智能停车管理系统
目 录
第一章 绪论
1.1 研究背景
1.1.1停车管理的主要问题
1.1.2停车管理智能化的需求
1.2 研究的意义
1.2.1理论意义
1.2.2 实践意义
1.3 国内外研究现状
1.3.1国内停车场管理现状
1.3.2国外停车场管理现状
1.4 研究内容
第二章 硬件分析选择
2.1 视频识别显示
2.1.1 视频识别的概念
2.1.2 视频识别系统的构成
2.2 车牌识别
2.2.1 车牌识别的分类
2.2.2 车牌识别技术在智能停车管理系统中的应用
2.3 停车诱导模块
2.3.1 停车场外的诱导
2.3.2 停车场内的诱导
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c00ba5767820fc7affc32b4afc09ccbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de1dc478b4f83f40603cdea362f5c891/" rel="bookmark">
			Mac配置java环境变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mac配置java环境变量 一、明确定义 JRE：（Java Runtime Environment），java运行环境。包括Java虚拟机(JVM Java Virtual Machine)和Java程序所需的核心类库等，如果想要运行一个开发好的Java程序，计算机中只需要安装JRE 即可。
JDK：（Java Development Kit Java）开发工具包。JDK是提供给Java开发人员使用的，其中包含了java的开发工具，也包括了JRE。所以安装了JDK，就不用在单独安装JRE了。
"/Library/Internet Plug-Ins/JavaAppletPlugin.plugin/Contents/Home/bin/java"这个是JRE的运行路径。
"/Library/Java/JavaVirtualMachines/jdk-21.jdk/Contents/Home"这个是JDK的运行路径。
我们要配置的java环境变量需要去java官网下载jdk的dmg文件，根据Mac的处理器不同选择适合处理器的jdk文件，我这里示范使用的是Intel芯片的处理器。
二、安装Jdk 双击下载好的jdk文件进行安装，安装过程中一直点击继续或下一步即可安装成功。
三、配置环境变量 首先找到jdk的安装路径，可以参考前面所说的jdk运行路径进行寻找。
也可以使用系统的资源库查找jdk路径，具体方法如下：
首先，找到访达图标，点开访达，点击前往菜单，选择前往文件夹。
然后，在对话框中输入/Library/Java/，按enter，即可进入资源库中的Java文件中，然后进入JavaVirtualMachines文件，进入后可以选择jdk的版本，选择好版本后依次进入Contents文件和Home文件，即可找到jdk的bin文件。
找到bin文件后在bin文件上右键，然后按住option可以看到拷贝变成了，将bin拷贝为路径名称，选择此选项即可将路径复制下来。
在正式配置之前可以先查看以下已有的环境变量，在终端中输入：
echo $PATH 命令行后的即是现在的环境变量，输入以下命令行：
vi .bash_profile 开始配置环境变量,输入该命令就会进入一个界面，然后敲一下键盘上的i键,只有敲了才能进入文本输入模式。
在文本输入模式输入下列代码
JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk-21.jdk/Contents/Home PATH=$JAVA_HOME/bin:$PATH //给环境变量赋值 export JAVA_HOME //导出使其生效 export PATH 注意上面JAVA_HOME的值一定要是你自己电脑上的jdk路径。和刚刚的/Library/Java/JavaVirtualMachines/jdk-21.jdk/Contents/Home/bin路径有差别的地方是JAVA_HOME后面的路径少了/bin。然后把/bin加在了PATH后面。
退出保存环境变量，先摁 ESC键 返回命名行模式。输入:wq 退出保存环境变量。
在终端输入下面命令行让环境变量生效：
source .bash_profile 再次使用echo $PATH命令查看环境变量是否添加完成，若我们的环境变量多出我们刚刚配置好的jdk路径，说明配置成功，但还没有结束。
四、必读 由于我们配置的环境变量是在bash_profile中，当终端重新开启新的窗口或重启终端后，配置的环境变量都不生效了，还需重新执行以下命令才会生效： source ~/.bash_profile 其原因是我们配置的环境变量是在bash中的，而终端默认使用的shell是zsh，所以解决办法是在.zshrc文件中添加 source ~/.bash_profile //此步类似于在使用zsh时的shell时提前执行这句命令，很像提前加载（仅个人理解） 要是不知道此时使用的shell是什么类型可以使用下列命令来查看： echo $SHELL 如图所示/bin/zsh就意味着此时使用的是zsh的shell。
首先进入主目录 cd ~ 然后显示隐藏文件，找到.zshrc文件夹 ls -a 编辑文件 sudo vim .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de1dc478b4f83f40603cdea362f5c891/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/963386b3bf676cfed195ef55fa0638c6/" rel="bookmark">
			golang 时间处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. golang时间time 1.1 time包处理时间 ，我们一般情况下需要的是 ：
a.格式化时间字符串 ： 2021-12-11 12:13:14 或 2021/12/11 12:13:14
b.时间戳：1689649862 秒
1.2 要明白的是 time是一个强大的时间对象，我们通过 时间字符串或时间戳转化为时间对象，然后通过时间对象去获取到我们需要的时间，比如 上一周 、上一个月、上一年、昨天、明天.....，最后将时间对象转换成我们需要的 时间字符串或时间戳
1.3 所以时间转换 时间对象计算 非常重要
2. 时间转换 2.1 注意：时间字符串转换需要模板 ："2006-01-02 15:04:05", 时间对象有时区，不同时区获取到的时间是不一样的
2.2 时间戳转时间对象
// 时间戳 转时间对象 timestamp := 1689690584 t := time.Unix(int64(timestamp), 0) fmt.Println(t) 2.3 时间格式字符串 转 时间对象
// 格式化时间字符串 转时间对象 timeStr := "2023-07-18 11:11:02" t, _ := time.ParseInLocation("2006-01-02 15:04:05", timeStr, time.Local) fmt.Println(t) 注意：时间字符串转时间对象，还有 time.Parse()这个函数，但是我们会发现转成的时间会相差8个小时，其原因就是时区不同。
2.4 时间对象转时间戳 和 时间格式字符串
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/963386b3bf676cfed195ef55fa0638c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/426db710a4742347f1d6a81dcfcb2852/" rel="bookmark">
			贝叶斯算法原理与代码实现（学习笔记）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、贝叶斯算法概述 贝叶斯算法（Bayesian algorithm）是一种基于贝叶斯定理的机器学习方法，用于估计模型参数和进行概率推断。它是一种统计推断的框架，旨在通过更新先验知识以反映观测数据来获得后验概率分布。
以下是贝叶斯算法的核心概念和数学表达：
贝叶斯定理（Bayes' Theorem）：
贝叶斯定理表示如何在观测到新数据时更新关于模型参数的信念。其数学表达如下：
其中，
是在给定数据 的情况下，参数 的后验概率。 是在参数 下观测到数据 的似然。 是参数 的先验概率。 是数据 的边际概率，通常作为归一化常数。 先验概率（Prior Probability）：
先验概率是在观测到数据之前对参数的概率分布的估计。它反映了我们的先验信念或领域知识。
似然函数（Likelihood）：
似然函数表示在给定模型参数 的情况下观测到数据的概率分布。通常用 表示。
后验概率（Posterior Probability）：
后验概率是在考虑观测数据后，参数的概率分布。它是通过应用贝叶斯定理计算得出的，通常用 表示。
边际概率（Marginal Probability）：
边际概率是观测数据的概率，通常用于将后验概率归一化，以获得有效的后验分布。
贝叶斯算法的工作流程如下：
定义模型：选择合适的概率分布来描述模型参数和观测数据之间的关系，通常使用参数化的概率模型。
设定先验概率：选择适当的先验分布，反映我们对模型参数的初始信念。
收集数据：获取观测数据集 。
计算后验概率：使用贝叶斯定理结合观测数据和先验概率来计算参数的后验概率分布：
进行推断：基于后验概率进行模型参数的估计、预测、分类等任务。
更新模型：随着新数据的积累，可以周期性地重复上述过程，不断更新后验概率和模型参数。
贝叶斯算法的优点包括对不确定性建模、能够自然地融入领域知识、适用于小样本数据等。但它也可能受限于计算复杂性，尤其在高维空间或大规模数据集上。因此，在实际应用中，需要谨慎选择模型和先验分布，并利用近似方法来解决计算上的挑战。
二、垃圾邮件过滤实例 1-邮件数据读取 import numpy as np # 导入NumPy库，用于数值计算 import re # 导入re库，用于正则表达式操作 import random # 导入random库，用于生成随机数 # 定义一个函数textParse，用于处理文本数据 def textParse(input_string): listofTokens = re.split(r'\W+', input_string) # 使用正则表达式切分输入的字符串 return [tok.lower() for tok in listofTokens if len(listofTokens) &gt; 2] # 返回切分后的单词列表，转换为小写并去除长度小于等于2的单词 # 定义一个函数spam，用于处理垃圾邮件数据 def spam(): doclist = [] # 创建一个空列表，用于存储文档数据 classlist = [] # 创建一个空列表，用于存储类别信息 for i in range(1, 26): # 循环处理1到25号文档 # 处理垃圾邮件文档 wordlist = textParse(open('email/spam/%d.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/426db710a4742347f1d6a81dcfcb2852/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a009e5819566ca089988734939d9b295/" rel="bookmark">
			开发一个ebpf程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步：使用 C 开发一个 eBPF 程序新建一个 hello.c 文件，并输入下面的内容：
//ebpf程序
int hello_world(void *ctx)
{
bpf_trace_printk("Hello, World!");
return 0;
}
第二步：使用 Python 和 BCC 库开发一个用户态程序
#!/usr/bin/env python3
# 1) import bcc library
from bcc import BPF
# 2) load BPF program
b = BPF(src_file="hello.c")
# 3) attach kprobe
b.attach_kprobe(event="do_sys_openat2", fn_name="hello_world")
# 4) read and print /sys/kernel/debug/tracing/trace_pipe
b.trace_print()
让我们来看看每一处的具体含义：第 1) 处导入了 BCC 库的 BPF 模块，以便接下来调用；
第 2) 处调用 BPF() 加载第一步开发的 BPF 源代码；
第 3) 处将 BPF 程序挂载到内核探针（简称 kprobe），其中 do_sys_openat2() 是系统调用 openat() 在内核中的实现；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a009e5819566ca089988734939d9b295/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/764930658e12a66d309c9849fc97e3c0/" rel="bookmark">
			php随机跳转到某一图片链接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 引言直接显示（不适用于主题）正确方式：跳转链接附录 引言 本文章首发于博主的个人网站
在WordPress的Sakurairo主题中，可以设置随机封面图片的api地址。
初始时就设定好了两个api链接，分别适配pc端和移动端的封面大小。
PC端（点击访问）移动端（点击访问） 每次在浏览器打开上面的链接，都会随机返回一张图片。不过，与之前 随机句子的直接返回显示方式不同，这个api是每次访问会自动调转到某一图片链接，即使不断刷新，显示的还是同一张图片。从地址栏可以发现访问的链接的地址已经从（xxx.php）变成了图片的链接地址（xxx.webp）。
示例：
直接显示（不适用于主题） 参考来源/转载自：CSDN 「海拥✘」
思路：
（1）准备图片放入文件夹中。（示例：网站/random/imagesapi/pcbg文件夹）
（2）同路径下新建index.php文件（示例：网站/random/imagesapi/index.php），,使得访问该路径时就能默认访问index.php。
（3）编写index.php，使其随机显示一张文件夹中的图片。
（4）上传以上文件到网站服务器，通过访问到路径即可。(示例：https://www.georgewahson.club/random/imagesapi/)
index.php代码解释：图片文件夹路径： $imageFolder = 'image/'; 获取图片文件列表： $imageFiles = scandir($imageFolder); 过滤掉".“和”.."目录： $imageFiles = array_diff($imageFiles, array('..', '.')); 随机选择一张图片： $randomImage = $imageFiles[array_rand($imageFiles)]; 图片显示： echo '&lt;img src="' . $imageFolder . $randomImage . '" alt="随机图片"&gt;'; 完整代码：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;随机调用图片&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;?php // 图片文件夹路径 $imageFolder = 'image/'; // 获取图片文件列表 $imageFiles = scandir($imageFolder); // 过滤掉"."和".."目录 $imageFiles = array_diff($imageFiles, array('.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/764930658e12a66d309c9849fc97e3c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55c4eec5d0abc01eaead4ccfb9b3be8b/" rel="bookmark">
			SpringBoot原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
SpringBoot是什么
SpringBoot的特点
SpringBoot的原理
使用SpringBoot的好处
SpringBoot启动执行流程
SpringBoot是什么 Spring Boot是一个用于简化和加速Java应用程序开发的开源框架。它基于Spring框架，并通过提供约定优于配置的方式来帮助开发者快速搭建独立运行的、生产级别的应用程序。
Spring Boot的设计目标是使得Java开发变得更加简单、快速和高效，同时降低了对于大量XML配置文件的依赖。它通过自动配置、内嵌式容器和快速启动等特性，减少了开发者的工作量，从而能够更专注于业务逻辑的实现。
SpringBoot的特点 简化配置：Spring Boot采用"约定优于配置"的原则，通过提供默认的配置和自动装配，显著减少了繁琐的配置工作。 内嵌式容器：Spring Boot内置了常见的Servlet容器（如Tomcat、Jetty、Undertow），可以将应用程序打包为可执行的JAR文件，无需外部容器的支持。 自动装配：Spring Boot根据应用程序的类路径和依赖关系，自动配置各种功能模块，例如数据库访问、消息队列、缓存等。开发者只需添加相应的依赖，即可轻松使用这些功能。 开发者友好：Spring Boot提供了一套开发者友好的工具和接口，例如开发热部署、自动重新启动、可视化配置等，极大地提升了开发效率和体验。 外部化配置：Spring Boot支持将配置信息从代码中抽离出来，可以使用属性文件、YAML文件、环境变量等方式进行配置，使得应用程序在不同环境下能够灵活适配。 健康监测：Spring Boot提供了健康检查的功能，通过HTTP端点或管理界面可以监测应用程序的运行状态，及时发现和解决问题。 生态系统：Spring Boot与Spring框架紧密集成，可以无缝使用Spring的各种扩展和插件，如Spring Data、Spring Security、Spring Cloud等，构建强大的企业级应用。 SpringBoot的原理 Spring Boot的原理可以总结为以下几个方面： 自动配置：Spring Boot通过使用条件化配置和自动装配机制，根据应用程序的类路径、依赖关系以及配置文件等信息，自动配置各种功能模块。它根据预定义的规则和条件，自动加载适合当前环境和需求的组件和配置。 约定优于配置：Spring Boot采用约定优于配置的原则，通过设定默认值和约定的命名规则，大部分情况下无需手动进行繁琐的配置工作。这使得开发者可以专注于业务逻辑的实现，而不需要过多关注框架和配置细节。 内嵌式容器：Spring Boot内置了常见的Servlet容器（如Tomcat、Jetty、Undertow），可以将应用程序打包为可执行的JAR文件，并在其中嵌入容器。这意味着开发者无需额外部署应用程序到外部容器，可以直接运行和管理应用程序。 外部化配置：Spring Boot支持将配置信息从代码中分离出来，可以使用属性文件、YAML文件、环境变量等方式进行配置。通过这种方式，开发者可以根据不同的环境要求轻松调整应用程序的行为，而无需重新编译和部署。 简化开发过程：Spring Boot提供了一系列开发者友好的工具和接口，例如自动重启、热部署、可视化配置等。这些工具能够极大地提升开发效率，使得开发者能够更专注于业务逻辑的实现。 总的来说，Spring Boot通过自动配置、约定优于配置、内嵌式容器和外部化配置等机制，简化了Java应用程序的开发过程。它减少了繁琐的配置工作，提供了便捷的开发和部署方式，使得开发者能够更快速、高效地构建独立运行的、可靠的应用程序。
使用SpringBoot的好处 简化的开发流程：Spring Boot提供了自动配置和约定优于配置的原则，大部分情况下无需手动进行繁琐的配置工作。这样可以减少开发人员的工作量，加快应用程序的开发速度。 快速搭建微服务架构：Spring Boot非常适合构建微服务架构。它提供了丰富的功能模块和插件，使得开发者可以方便地创建、部署和管理多个独立的微服务应用程序。 高度集成性：Spring Boot与Spring框架紧密集成，可以无缝使用Spring生态系统中的各种组件和工具。例如，可以轻松地集成Spring Data JPA、Spring Security、Spring Cloud等，以实现数据访问、安全认证和分布式系统等功能。 内嵌式容器：Spring Boot内置了常见的Servlet容器（如Tomcat、Jetty、Undertow），可以将应用程序打包为可执行的JAR文件，并在其中嵌入容器。这意味着开发者无需额外部署应用程序到外部容器，可以直接运行和管理应用程序。 外部化配置：Spring Boot支持将配置信息从代码中分离出来，可以使用属性文件、YAML文件、环境变量等方式进行配置。通过这种方式，开发者可以根据不同的环境要求轻松调整应用程序的行为，而无需重新编译和部署。 强大的开发者工具：Spring Boot提供了一系列开发者友好的工具和接口，例如自动重启、热部署、可视化配置等。这些工具能够极大地提升开发效率，使得开发者能够更专注于业务逻辑的实现。 SpringBoot启动执行流程 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdb8a2ffd0fc0c141ea54f1eeb70f4bd/" rel="bookmark">
			osWorkflow-1——osWorkflow官网例子部署启动简单使用（版本：OSWorkflow-2.8.0）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		osWorkflow-1——osWorkflow官网例子部署启动简单使用（版本：OSWorkflow-2.8.0） 1. 前言——准备工作1.1 下载相关资料1.2 安装翻译插件 2. 开始搞项目2.1 解压 .zip文件2.2 简单小测（war包放入tomcat）2.3 导入项目到 IDE、配置项目运行环境2.3.1 导入项目到Eclipse2.3.2 导入项目到idea 2.4 启动项目2.4.1 注意tomcat端口等2.4.2 启动项目 2.5 简单点点——页面2.5.1 create an account2.5.2 用户login（暂且不要用自己创建的用户登录！！！！）2.5.2.1 用自己创建的用户报错！！！2.5.2.2 加载用户并登录 2.5.3 New Workflow（新建工作流） 1. 前言——准备工作 1.1 下载相关资料 首先，这个官方已经不维护了，所以想在官方获取资料几乎不可能，那为啥还要花时间研究呢？为啥？问为啥的不会看到此篇文章，别问我为啥，存在即合理！虽然官网没资料，但是网上还是有很多可参考的资料的，需要做下面的准备工作，我的资料也是在csdn下载的，最终挑出2个参考价值大的分享一下： 下载参考手册，英文版的，但是参考价值大，下载地址如下：
国外OSWorkflow书籍,面向java开发者和架构师的好书!.
下载源码，关于源码我就下载了这一个，因为我觉得大同小异，没必要挑了，不行自己调试即可。
源码下载地址如下：
OSWorkflow-2.8.0.
使用这个是因为该朋友有文档，所以真实实践过，源码靠谱，文档参考地址：
OSWorkflow官方例子部署及运行详解.
两个文件（参考文档 + 源码包）我也放自己网盘了，需要的可去网盘直接下载： 链接：https://pan.baidu.com/s/1yYpa86tOR2jQf2vpwe08rw?pwd=bmzm 复制提取码：bmzm 1.2 安装翻译插件 因为上面的参考书是英文版的，如果英语不好的朋友可能需要翻译工具，但是直接翻译pdf的工具好用的不知道多不多，但是我这里有一个自我感觉很好，可以试试： 翻译效果如下（左边原文，右边翻译）：
关于翻译插件的安装与使用，请看下面的文章：
推荐几款实用的Google浏览器插件（各种翻译）——AI时代 实现 无障碍阅读各种英文网站. 2. 开始搞项目 2.1 解压 .zip文件 将下载的.zip文件直接解压：
2.2 简单小测（war包放入tomcat） 解压之后，里面有个war包文件，可以直接放到你tomcat下的webapp目录下，然后直接访问，如下：
然后启动你的tomcat服务，访问，如下：http://localhost:8080/osworkflow-2.8.0-example/ 手册介绍是可以登录的，但是我这里登录报错，这项目应该是上传源码的朋友在官方源码的基础上有做过改动，可能打包问题，也可能是别的问题，别费脑子猜来猜去了，直接自己动手吧，所以，学习的话，我门还得研究项目，起码先本地跑起来！
2.3 导入项目到 IDE、配置项目运行环境 2.3.1 导入项目到Eclipse 好久不用Eclipse了，实在是提不起用eclipse的兴趣，使用Eclipse的朋友，可以参考上传此源码包的朋友的文章，此处不多说：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fdb8a2ffd0fc0c141ea54f1eeb70f4bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e14e5992ee15317500253b92666bd100/" rel="bookmark">
			常见的锂电池的算法--基础概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常见的锂电池的算法–基础概念 1、锂电池的一些特性 (1)锂电池的各种静态和动态参数，都有个体差异，批次差异，型号差异。 (2)锂电池的剩余电量和电压有关。参考充放电曲线。 (3)锂电池的满电/空电状态对应的电量和电压参数，会随着充放电循环增多而老化衰减。 (4)锂电池的各种参数都随温度变化，一般额定参数是在某个特定温度下测量得到的。 (5)电池不同电压/剩余容量时的充放电电流极限值可能会不同，也可能老化，温度漂移。 2、常用SOX (1)SOC：State of Charge，剩余电量百分比，剩余电量/实际容量 (2)SOH：State of Health，电池健康度，电池使用一段时间后老化衰减度，实际容量/额定容量 (3)SOE：Stete of Energy，剩余能量，与续航里程相关，需考虑续航相关的额外因素 (4)SOP：State Of Power，锂电池的允许充放电电流值在不同SOC，不同温度下是不同的。(例如：电动车在刚充满电时和快没电量时，所表现的性能是不一样的) (5)DOD：Depth of discharge，放电深度，电池放电量与电池额定容量的百分比（例如：电池并不是完全放空电量，还是留有一定的电量保存在电池中） 3、总结说明 (1)SOX是从不同角度对锂电池特性的建模和参数表达 (2)物理上电池有个体差异，各种静态和动态参数在不同温度下也会变化甚至不成线性变化 (3)产品和项目中实现哪些SOX由产品和项目自身决定，没有统一标准 (4)SOX的实现可以有多种算法，可用1种或同时几种叠加使用以增强准确度 (5)SOX实现的关键点：算法选择、参数标定、验证试验体系和环境搭建 4、本课程中的实现 (1)本课程中只实现了SOC，未实现其余SOX，主要使用SOC计算剩余电量百分比 (2)本课程中SOC的实现采用了2种算法叠加：开路电压法、安时积分法 5、SOC代码解析 (1)电池状态的分析主要包括简单分析数据、实时校准容量、计算SOC值等主要部分。简单分析主要用于计算最大电压差、平均电压等简单参数；实时校准，主要是对采集的温度信息进行校准，SOC值计算主要包括开路电压法和安时积分法。
&gt; // 电池状态分析任务线程入口 static void BMS_AnalysisTaskEntry(void *paramter) { &gt; BMS_AnalysisCapAndSocInit(); while(1) {	&gt; BMS_AnalysisEasy();//简单分析，计算最大电压差、平均电压等简单参数 &gt; BMS_AnalysisCalCap();//实时校准容量涉及因素:温度 &gt; BMS_AnalysisSocCheck();//计算SOC值 &gt; rt_thread_mdelay(ANALYSISI_TASK_PERIOD); } } (2)简单分析,通过数据直接进行计算就能得到的
static void BMS_AnalysisEasy(void) { uint8_t index; // 最大电压差 BMS_AnalysisData.MaxVoltageDifference = BMS_MonitorData.CellData[BMS_GlobalParam.Cell_Real_Number - 1].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e14e5992ee15317500253b92666bd100/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18a81d72d2d070ca9390d37fe919f2d6/" rel="bookmark">
			计算机组成原理---第二章 习题详解版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(一）课内习题 1.
（二）课后练习 1.写出下列各整数的原码、反码和补码表示（用8位二进制表示）。其中MSB是最高位（符号位），LSB是最低位。 （1）-35 （2） -128 （3）-127 （4）-1
答：（1）-35 原： 1011 0101 反：1100 1010 补码：1100 1011
（2） -128 在八位二进制下，-128不能用原码或反码表示，反码只能表示0到127,-0到-127； 补码：1000 0000
（3）-127 原： 1111 1111 反：1000 0000 补码：1000 0001
（4）-1 原： 1000 0001 反：1111 1110 补码：1111 1111
2.设[X]补=a7.a6 a5··· a0 ,其中ai 取0或1, 若要X&gt;-0.5,求a0 a1 a2 ··· a7 的取值。 答：
若a7 =0,则X为正数,显然a0··· a6取任何值均可。
若a7 =1,则X为负数,[X]移=0. a6 a5 ··· a0 ∵ -0.5D = -0.100000B,则[-0.5D ]移=0.100000
∴ 若要X&gt;-0.5,即等价于[X]移&gt; [-0.5D ]移 即0. a6 a5··· a0&gt;0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18a81d72d2d070ca9390d37fe919f2d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9a1eee7f36b2ec78bb375c14a4ae815/" rel="bookmark">
			C语言scanf、占位符、printf重点介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		哈喽，各位宝汁们，今天我们重点来介绍一下C语言中的printf和scanf以及占位符的使用方法，让我们开启短暂的学习之旅吧！
一.printf：printf的作用是将参数文本输出到屏幕。
printf不会在行尾自动添加换行符，运行结束后，光标就会停在输出结束的地方，不会自动换行，为了让光标换到下一行，我们可以在输出文本的结尾添加一个换行符\n。
需要注意的是，printf是在标准的头文件stdio.h定义的，所以我们在使用这个函数之前，必须在源码文件头部引入这个头文件。
二.占位符：所谓“占位符”，就是指定的位置可以用其他的值来代入，printf（）可以在输出文本中指定占位符。
其中里面的%S为占位符，占位符的第一个字符统一为%，第二个字符表示占位符的类型，示例中%s表示的是字符串类型。
注：输出文本中可以使用多个占位符。 #include &lt;stdio.h&gt; int main() { printf("There are %d people in the %s",3,"park"); return 0; } 以下是常用的占位符举例和具体意义：
占位符的作用：（1）限定宽度；（2）总是显示正负号；（3）限定小数位数；（4）输出部分字符串
各个字符串的含义和作用：
1.%ms： 输出的字符串占m列，如果字符串长度本身大于m个则全部输出，如果小于m，则不足的用空格补齐，右对齐 。
2.%-ms：和%ms的作用一样，但是如果小于m个则需要右边用空格补齐，左对齐。
3.%m.ns： 输出占m列，但只取字符串中左端n个字符。这n个字符输出在m列的右侧，左补空格。
%-m.ns：其中m、n含义同上，n个字符输出在m列范围的左侧，右补空格。如果n&gt;m，则自动取n 值，即保证n个字符正常输出。
4.%f：例如:printf("%f", 12.5)输出“12.500000”浮点型数据（不包括双引号）。(%f小数点后默认保留 6位小数)
5.%mf：输出的数据占m列，如字符串本身长度大于m，则突破获m的限制,将浮点型对象全部输出，若串长小于m，则左补空格。可以理解为m前为正，则浮点型对象右对齐。
6.%-mf：如果浮点型对象长小于m，则在m列范围内，m前为负，浮点型对象左对齐，右补空格。
7.%m.nf：输出占m列，浮点型对象保留n个小数位。
8.%-m.nf：其中m、n含义同上，m为输出的宽度，n为保留的小数位数，若浮点型对象长小于m，则 在m列范围内，m前为负，浮点型对象左对齐，右补空格。
（1）.限定宽度：
#include &lt;stdio.h&gt; int main () { printf("%5d\n",123); return o; } //注意；此时输出的结果为 123 上面示例中，因为%5d表示这个占位符的宽度至少为5位，而此时的123只有三位，所以我们需要在左侧用两个空格来补齐，输出的值默认为右对齐，如果希望是 左对齐，则我们只需要改为%-5d。
（2）.总是显示正负号：
默认情况下，printf（）总是不对正数显示+号，只对负数显示-号。如果想让正数也显示出+号，则只需要在占位符%后加一个+号。 (3）.限定小数位数：
输出小数时，有时希望限定小数的位数。例如：希望小数点后面只希望保留两位，占位符可以写成%.2f。
这种写法可以和限定宽度结合起来使用。
注意：最小宽度和小数位数这两个限定值，都可以用*来代替，然后用printf来传参。 （4）.输出部分字符串：
%s占位符用来输出字符串，默认时全部输出，如果只是想要输出开头的部分，可以用%.[m]s指定输出的长度，其中[m]表示一个数字，表示所要输出的长度。
三.scanf介绍： 当我们有了变量的时候，我们需要给变量输入值就可以使用scanf函数，如果需要将变量的值输出在屏幕上的时候可以使用printf函数。而scanf函数用于读取用户的键盘输入，程序运行到这个语句时候，停下来，等待客户从键盘输入，用户输入数据，按下回车键后，scanf（）就会处理用户的输入，将其存入变量。它的原型定义在头文件stdio.h。
因为C语言的数据都是有类型的，scanf()必须知道用户输入的数据类型才能处理数据，它的其余参数就是存放用户输入的变量，格式字符串里面有多少个占位符，就有多少个变量。scanf（）的第一个参数%d，表示用户输入的应该是一个整数，%是占位符的标志，d表示整数，第二个参数&amp;i表示将用户从键盘输入的整数存入变量i。
注意：（1）.scanf_s函数是vs提供的函数，并非C语言提供的，其他编译可能不认识。
（2）如果想在vs上使用scanf函数，就在.c文件第一行加上3DEFINE_CRT_SECURE_NO_WARINGS1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9a1eee7f36b2ec78bb375c14a4ae815/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29b3ce5c6aa9dd7430fe9869c3bb82c8/" rel="bookmark">
			vue3跟vue2，v-if跟v-for同时使用区别，附源码文件位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue3跟vue2，v-if跟v-for同时使用区别 vue2 版本vue2.6.14 源码位置 vue\src\compiler\codegen\index.js vue3 版本vue3.3.4 源码位置 core\packages\compiler-core\src\compile.ts vue2 版本 v-if与v-for同时使用，v-for优先级最高。为什么？因为源码这么写。。
先遍历，在判断，有些不显示的节点遍历时不必要的，浪费性能。不建议同时使用。
vue2.6.14 源码位置 vue\src\compiler\codegen\index.js 在56行 genElement函数内
export function genElement (el: ASTElement, state: CodegenState): string { if (el.parent) { el.pre = el.pre || el.parent.pre } if (el.staticRoot &amp;&amp; !el.staticProcessed) { return genStatic(el, state) } else if (el.once &amp;&amp; !el.onceProcessed) { return genOnce(el, state) } else if (el.for &amp;&amp; !el.forProcessed) { return genFor(el, state) } else if (el.if &amp;&amp; !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29b3ce5c6aa9dd7430fe9869c3bb82c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/124cbd6138094b224ace35f2a7384487/" rel="bookmark">
			element-plus: 二次封装el-form方案？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网上看了几篇文章，都不是想要的答案。于是给下自己的实现思路，各位有好的建议也可以评论。
建议直接看源码： https://github.com/jyj1202/j-admin/blob/dev/src/views/j-form/components/JForm.vue
如果觉得有用，可以去github给我的项目点个star。
核心思路就是利用vue的动态组件渲染需要的组件，而不是v-if判断。这样大大简化了代码。
模板部分代码： &lt;el-form-item :label="col.label" :prop="col.prop" :rules="col.rules" &gt; &lt;slot :name="col.prop" v-bind="{col, size: getProp('size', col)}"&gt; &lt;component :is="getComponentType(col, getProp('type', col))" v-model="formData[col.prop]" v-bind="getComponentProps(col)" :key="col.prop" @change="handleFormItemValueChange" &gt; &lt;template v-if="!col.component &amp;&amp; getSlotComponent(getProp('type', col))"&gt; &lt;!-- 目前只有两种情况 1.有dicData的formItem 2.upload组件里的button --&gt; &lt;template v-if="col.dicData"&gt; &lt;component v-for="dicData in col.dicData" :key="dicData.value" :is="getSlotComponent(getProp('type', col))" v-bind="dicData" /&gt; &lt;/template&gt; &lt;el-button v-if="getSlotComponent(getProp('type', col))=='el-button'" type="primary" &gt;Click to upload &lt;/el-button&gt; &lt;/template&gt; &lt;/component&gt; &lt;/slot&gt; &lt;/el-form-item&gt; 需要注意的是，涉及到有插槽的组件，我目前的思路是： 1.条件判断，渲染对应的插槽内组件。
/** * @description 获取组件插槽内子组件 * @param type */ const getSlotComponent = (type: string): string|undefined =&gt; { /* 插槽子组件映射 */ const slotCompMap: Record&lt;string, string&gt; = { 'select': 'option', 'radio-group': 'radio', 'checkbox-group': 'checkbox', 'upload': 'button' } return `el-${slotCompMap[type]}` } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/124cbd6138094b224ace35f2a7384487/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44dee8ecbff432e886717c0370229284/" rel="bookmark">
			轻松上手：＜Android Studio笔记应用开发＞（二）大功告成！添加新笔记！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、引言二、第一步 - 数据库创建与管理1. 定义**4个**属性：表名、内容字段、主键字段、时间字段。2. 实现构造方法3. 执行 SQL 语句创建名为 "notes" 的数据库表格。4. 数据库升级5. `NoteDatabase`类的代码(注释详细)如下： 三、第二步 - CRUD操作1. 必要的属性2. 构造方法3. 数据库连接的打开和关闭4. 添加一条笔记记录5. 获取所有笔记记录6. `CRUD`类的代码(注释详细)如下： 四、第三步 - ListView五、第四步 - 主页(`MainActivity`)1. 属性2. `onCreate`方法3. 刷新笔记列表4. `MainActivity`的代码(注释详细)如下： 六、第五步 - 笔记列表(`EditActivity`)1. 新添两个属性：`content`和`time`2. 为意图添加额外数据3. 指定时间显示格式4. `EditActivity`的代码(注释详细)如下： 七、结果演示八、结语持续爆肝更新中...🫡🫡🫡求点赞👍求关注🤗求转发😍 一、引言 欢迎回到我们的Android笔记应用开发系列！
在日常生活中，我们常常需要记录重要的想法、任务或灵感。随着智能手机的普及，将这些笔记存储在便捷的应用程序中已经成为了一种习惯。
但是，你是否曾经想过如何创建自己的笔记应用，以更好地满足个人需求，或者简单地出于好奇？
在这个教程中，我们将在上一篇文章的基础上，继续带着你一步步创建一个功能强大的 Android 笔记应用。
无需担心，即使你是一个初学者，我们将以易懂的方式解释每个步骤，让你能够轻松掌握 Android 应用开发的精髓。
我们将从数据库的创建、CRUD操作的实现，一直到精心构建用户界面，最终让你轻松掌握如何添加新笔记的功能
无论你是初学者还是有经验的开发者，都将在这里找到有趣的灵感和宝贵的知识。
现在，让我们继续踏上这个令人兴奋的 Android 开发之旅吧！
二、第一步 - 数据库创建与管理 首先，让我们创建NoteDatabase类，这将帮助我们管理笔记数据。数据库操作中的核心就是这个类。它继承自SQLiteOpenHelper，用于创建和维护数据库。
在创建NoteDatabase类时，
1. 定义4个属性：表名、内容字段、主键字段、时间字段。 代码如下：
// 定义数据库表和字段的常量 public static final String TABLE_NAME = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44dee8ecbff432e886717c0370229284/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9d211e6d85a9c2e42e7534a565795ab/" rel="bookmark">
			vue3 使用 elementUi： ./lib/theme-chalk/index.css is not exported from package
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. 在 vue3 中使用 element-ui2. 如果启动报错：Module not found: Error: Package path ./lib/theme-chalk/index.css is not exported from package 1. 在 vue3 中使用 element-ui 在 vue3 中使用 element-ui，我们的流程一般是这样的：
安装Element-Plus
npm i element-plus -S main.js 中全局引入 element-plus
import { createApp } from 'vue' import ElementPlus from 'element-plus'; import 'element-plus/dist/index.css'; import App from './App.vue' createApp(App).use(ElementPlus).mount('#app') 在 HelloWorld.vue 中测试一下
&lt;template&gt; &lt;div class="hello"&gt; &lt;el-button type="primary"&gt;搜索&lt;/el-button&gt; &lt;/div&gt; &lt;/template&gt; npm run serve 跑一下服务
2. 如果启动报错：Module not found: Error: Package path .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9d211e6d85a9c2e42e7534a565795ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21f29a0ddc2b5d65f18b2820f06e7484/" rel="bookmark">
			【Linux 基础入门 &#43; Java项目部署】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Linux 基础入门1 Linux 简介1.1不同应用领域的主流操作系统1.2 Linux发展历史与 Linux系统版本 2 Linux 安装2.1 安装方式介绍2.2 安装Linux2.3 网卡设置2.4 安装SSH连接工具 Linux和Windows目录结构对比3 Linux 常用命令3.1 Linux命令初体验3.2 文件目录操作命令`ls``cd``cat``more``tail``mkdir``rmdir``rm` 3.3拷贝移动命令`cp``mv` 3.4打包压缩命令`tar` 3.5文本编辑命令`vi``vim` 3.6查找命令`find``grep` 3.7管理员与用户终端切换命令用户到管理员管理员到用户 4 Linux 软件安装4.1 软件安装方式4.2 安装jdk4.3 安装Tomcat4.4 安装MySQL4.5 安装Irzsz (用于文件上传与下载) Linux 防火墙 操作5 项目部署5.1 手工部署项目5.2 通过Shell脚本自动部署项目 Linux 基础入门 1 Linux 简介 1.1不同应用领域的主流操作系统 桌面操作系统 Windows（用户数量最多）Mac OS（操作体验好，办公人士首选）Linux（用户数量少） 服务器操作系统 UNIX（安全、稳定、付费）Linux（安全、稳定、免费、占有率高）Windows Server（付费、占有率低） 移动设备操作系统 Android（基于Linux、开源，主要用于智能手机、平板电脑和智能电视）iOS（苹果公司开发、不开源，用于苹果公司的产品，例如：iPhone、iPad） 嵌入式操作系统 Linux（机顶盒、路由器、交换机） 1.2 Linux发展历史与 Linux系统版本 时间：1991年
地点：芬兰赫尔辛基大学
人物：Linus Torvalds（21岁）
语言：C语言、汇编语言
logo：企鹅
特点：免费、开源、多用户、多任务
Linux系统分为内核版和发行版
内核版 由Linus Torvalds及其团队开发、维护免费、开源负责控制硬件 发行版 基于Linux内核版进行扩展由各个Linux厂商开发、维护有收费版本和免费版本 Linux系统发行版：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21f29a0ddc2b5d65f18b2820f06e7484/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acb7052a937ed464f60120b3ff66e832/" rel="bookmark">
			群晖Docker自建MS365-renew-x服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		适用范围：群晖等Nas自带的UI版Docker，其他版本的Docker设置方法自行搜索，有很多。
测试版本：DSM 7.2.1-69057 Update 1 本文以群晖新版的Container Manager（原Docker）创建，操作基本一样，就是创建镜像时候，需要右键点击运行。
镜像名称：hanhongyong/ms365-e5-renew-x
续订服务设置详情见Renew原作者SundayRX的文章：
【精选】E5 调用API续订服务：Microsoft 365 E5 Renew X_SundayRX的博客-CSDN博客
具体步骤：
1、File Station中新建文件夹Deploy及appdate。
2、在Docker（新版为Container Manager）的注册表中搜索：
ms365-e5-renew-x 双击镜像下载。
3、右击选择运行。
4、勾选“自动重新启动”，容器名称随意。点击下一步。
5、端口及挂载设置。
/app/Deploy
/app/appdate
挂载至第一步中新建的文件夹。
6、点击下一步后，启动容器。
IP:1066访问，默认密码“123456”。
启动容器后，若容器正常运行，但是无法访问，原因是没有自动生成Config.xml文件。
点击下载阿里云盘分享Config.xml文件，上传至Deploy文件夹。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58fb24e2941917b6a1d412d400ce041c/" rel="bookmark">
			3分钟详解阿里云VPN网关及使用场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是VPN网关？阿里云VPN网关有什么作用？使用VPN网关通过加密通道，可以将企业数据中心、办公网或终端与阿里云专有网络（VPC）安全可靠连接起来，阿里云百科来说下什么是VPN网关以及阿里云VPN网关的应用案例：
什么是VPN网关？ 阿里云VPN网关，即VPN Gateway，简称VPN。阿里云VPN网关是一款基于Internet，通过加密通道将企业数据中心、办公网或终端与专有网络（VPC）安全可靠连接起来的服务。支持IPsec VPN、SSL VPN及国密算法等能力，满足分支互联、移动办公等接入场景。
阿里云VPN网关 为了方便大家理解什么是阿里云VPN网关，举两个例子：
保险公司使用VPN网关案例：
某保险（上海）分公司作为第一批获得大陆经营保险业务许可的外资保险公司，有着遍布全球的分之机构。用户通过使用阿里云VPN网关产品，将分支机构通过加密隧道接入数据中心，快速搭建云上私网服务，为亚太业务提供安全可靠、简单易用的IPsec VPN互联网络。
物流企业使用VPN网关案例：
菜鸟网络作为物流行业的重要一员，业务遍及全球，随之而来的分支机构/物流中心也分布广泛。用户使用阿里云VPN网关产品，打造物流云平台，快速搭建云上私网服务，为集团提供安全可靠、高性价比、简单易用的IPsec VPN互联网络。
更多关于阿里云VPN网关详细说明及收费价格，请以阿里云官方页面为准。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f17f253b93485d3d2d48b8c4b19a5b28/" rel="bookmark">
			函数式编程：Rust中的闭包与迭代器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		闭包 Closure 闭包是一种匿名函数，它可以赋值给变量也可以作为参数传递给其它函数，不同于函数的是，它允许捕获调用者作用域中的值，例如：
fn main() { let x = 1; let sum = |y| x + y; assert_eq!(3, sum(2)); } 上面的代码展示了非常简单的闭包 sum，它拥有一个入参 y，同时捕获了作用域中的 x 的值，因此调用 sum(2) 意味着将 2（参数 y）跟 1（x）进行相加,最终返回它们的和：3。
可以看到 sum 非常符合闭包的定义：可以赋值给变量，允许捕获调用者作用域中的值。
Rust 闭包在形式上借鉴了 Smalltalk 和 Ruby 语言，与函数最大的不同就是它的参数是通过 |parm1| 的形式进行声明，如果是多个参数就 |param1, param2,...|， 下面给出闭包的形式定义：
|param1, param2,...| { 语句1; 语句2; 返回表达式 } 如果只有一个返回表达式的话，定义可以简化为：
|param1| 返回表达式 下面展示了同一个功能的函数和闭包实现形式：
fn add_one_v1 (x: u32) -&gt; u32 { x + 1 } let add_one_v2 = |x: u32| -&gt; u32 { x + 1 }; let add_one_v3 = |x| { x + 1 }; let add_one_v4 = |x| x + 1 ; 注意：闭包中最后一行表达式返回的值，就是闭包执行后的返回值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f17f253b93485d3d2d48b8c4b19a5b28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/771c730c9a9bb41eafc3ffefe0debcba/" rel="bookmark">
			【Spring Cloud】如何确定微服务项目的Spring Boot、Spring Cloud、Spring Cloud Alibaba的版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 版本选择2. 用脚手架快速生成微服务的pom.xml3. 创建一个父工程4. 代码地址 本文描述如何确定微服务项目的Spring Boot、Spring Cloud、Spring Cloud Alibaba的版本。 1. 版本选择 我们知道Spring Boot、Spring Cloud、Spring Cloud Alibaba的版本选择一致性非常重要。在选择Spring Boot和Spring Cloud版本时，需要考虑到两者之间的关系以及项目的具体需求。
首先，Spring Boot和Spring Cloud有密切的联系。Spring Boot是Spring Cloud的基础，版本选择应该先确定Spring Boot的版本，然后再选择与之兼容的Spring Cloud版本。
3者的版本选择可以参考：Spring Cloud Alibaba版本选择参考。简单起见也可以使用阿里巴巴提供的云原生应用脚手架
其他版本参考：https://sca.aliyun.com/zh-cn/docs/2022.0.0.0/overview/version-explain（先选择Spring Boot版本）
2. 用脚手架快速生成微服务的pom.xml 访问https://start.aliyun.com/
填写项目的基本信息
3、选择了3个组件，一个来自Spring Cloud，一个来自Spring Cloud Alibaba，所以会帮我们在pom.xml文件中引入2个框架的依赖。
可以选择下载代码或在线浏览代码。我这里把pom.xml文件的内容贴出来。 原始内容如下：
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.firefish&lt;/groupId&gt; &lt;artifactId&gt;firefish&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;name&gt;FireFish&lt;/name&gt; &lt;description&gt;火鱼微服务项目&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;spring-boot.version&gt;2.7.6&lt;/spring-boot.version&gt; &lt;spring-cloud-alibaba.version&gt;2021.0.5.0&lt;/spring-cloud-alibaba.version&gt; &lt;spring-cloud.version&gt;2021.0.5&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;modules&gt; &lt;module&gt;FireFish-start&lt;/module&gt; &lt;module&gt;FireFish-web&lt;/module&gt; &lt;module&gt;FireFish-service&lt;/module&gt; &lt;/modules&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/771c730c9a9bb41eafc3ffefe0debcba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de246cf01b5801df653f0d561dffbbd9/" rel="bookmark">
			【Spring Cloud】openfeign负载均衡方案(和lb发展历史)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 版本1：原始loadBalancerClient方案版本2：ribbon-loadbalancer方案版本3：openfeign方案（即**方案2+openfeign版本**） 本文描述了Spring Cloud微服务中，各个服务间调用的负载均衡方案的升级历史，目前市场通用的是openfeign方案。 版本1：原始loadBalancerClient方案 1、引入负载均衡组件
&lt;!-- 在消费者侧添加"负载均衡"组件 --&gt; &lt;!-- 组件的作用是注册了一个LoadBalancerClient类型的bean --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-loadbalancer&lt;/artifactId&gt; &lt;/dependency&gt; 2、使用负载均衡组件
@RestController public class NacosController{ @Autowired private LoadBalancerClient loadBalancerClient; @Autowired private RestTemplate restTemplate; @Value("${spring.application.name}") private String appName; @GetMapping("/echo/app-name") public String echoAppName(){ // &lt;1&gt; ServiceInstance serviceInstance = loadBalancerClient.choose("nacos-provider"); String path = String.format("http://%s:%s/echo/%s",serviceInstance.getHost(),serviceInstance.getPort(),appName); System.out.println("request path:" +path); // &lt;2&gt; return restTemplate.getForObject(path,String.class); } } 在代码&lt;1&gt;处，首先用复杂均衡组件提供的LoadBalancerClient选择出具体是哪一个微服务instance提供服务；然后在代码&lt;2&gt;处请求具体的instance获取结果。
注意：
1、此时的RestTemplate就是原始的RestTemplate，而没有加@LoadBalance注解，因为负载均衡功能已经由loadBalancerClient完成了。
@Bean public RestTemplate restTemplate(){ return new RestTemplate(); } 版本2：ribbon-loadbalancer方案 1、引入组件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de246cf01b5801df653f0d561dffbbd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7f9c79ccd55d1d9c113b47bfbfd90ac/" rel="bookmark">
			【初阶数据结构与算法】第十篇——八大排序算法（头脑风暴逻辑分析&#43;动图详解一看就会&#43;代码分析信手捏来）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🏆个人主页：企鹅不叫的博客
​ 🌈专栏
C语言初阶和进阶C项目Leetcode刷题初阶数据结构与算法C++初阶和进阶 ⭐️ 博主码云gitee链接：代码仓库地址
⚡若有帮助可以【关注+点赞+收藏】，大家一起进步！
💙系列文章💙 【初阶数据结构与算法】第一篇：算法中的时间复杂度和空间复杂度
【初阶数据结构与算法】第二篇：顺序表
【初阶数据结构与算法】第三篇：单链表
【初阶数据结构与算法】第四篇：链表面试题详解
【初阶数据结构与算法】第五篇：双链表
【初阶数据结构与算法】第六篇：栈和队列（各个功能实现+练习题包含多种方法）
【初阶数据结构与算法】第七篇：二叉树和堆的基本概念+以及堆的实现
【初阶数据结构与算法】第八篇——二叉树的顺序结构的应用（堆排序+TOPK问题）
【初阶数据结构与算法】第九篇——二叉树（链式结构实现+四种遍历方式+基本操作实现+基本练习详解）
文章目录 💙系列文章💙🌏一、排序介绍🍯1.排序概念🍯2.排序分类 🌏二.插入排序🍯1.直接插入排序🍍基本思想🍍实现过程🍍时间复杂度、空间复杂度、稳定性分析 🍯2.希尔排序🍍基本思想🍍实现过程🍍时间复杂度、空间复杂度、稳定性分析 🌏三.选择排序🍯1.直接选择排序🍍基本思想🍍实现过程🍍时间复杂度、空间复杂度、稳定性分析 🍯2.堆排序（[详细介绍点这里](https://blog.csdn.net/YQ20210216/article/details/123938785?spm=1001.2014.3001.5501)）🍍基本思想🍍实现过程🍍时间复杂度、空间复杂度、稳定性分析 🌏四.交换排序🍯1.冒泡排序🍍基本思想🍍实现过程🍍时间复杂度、空间复杂度、稳定性分析 🍯2.快速排序（递归版本）🍍hoare版本🔑基本思想🔑实现过程 🍍挖坑法🔑基本思想🔑实现过程 🍍前后指针法🔑基本思想🔑实现过程 🍍时间复杂度、空间复杂度、稳定性分析🍍优化快速排序🔑选出中间值优化🌰基本思想和代码实现 🔑小区间优化🌰基本思想和代码实现 🍯3.快速排序（非递归版本）🍍基本思想🍍实现过程 🌏五.归并排序🍯1.递归实现🍍相较于其他排序的优势🍍基本思想🍍实现过程🍍时间复杂度、空间复杂度、稳定性分析 🍯2.非递归实现🍍基本思想🍍实现过程 🌏六.计数排序（非比较排序）🍍基本思想🍍实现过程🍍时间复杂度、空间复杂度、稳定性分析 🌏七.八大排序比较🍯1.性能测试代码🍯2.排序空间复杂度、时间复杂度、稳定性 🌏总结 前言 🌏一、排序介绍 🍯1.排序概念 ⭐️ 排序：所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。
⭐️ 排序的稳定性:假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。
⭐️内部排序 ：数据元素全部放在内存中的排序。
⭐️外部排序：数据元素太多不能同时放在内存中，根据排序过程的要求不能在内外存之间移动数据的排序。
🍯2.排序分类 🌏二.插入排序 🍯1.直接插入排序 🍍基本思想 ⭐️现在有一个有序的区间，我们插入一个数据，保持它依旧有序
⭐️一般地，我们把第一个看作是有序的，所以我们可以从第二个数开始往前插入，使得前两个数是有序的，然后将第三个数插入直到最后一个数插入。
🍍实现过程 ⭐️单趟排序：首先选中end+1下标位置的数据存放到tmp中之后依次从end位置开始向前比较，直到end小于0，每个数进行比较，最后将tmp插入即可
⭐️整合： 总共有n个数，所以需要排序n-1次
void InsertSort(int* a, int n) { //有n个数据只用n-1趟排序 for (int i = 0; i &lt; n - 1; ++i) { //单趟排序 int end = i; //待插入的数据 int tmp = a[end + 1]; //依次往前移动 while (end &gt;= 0) { //依次比较 //降序只需要将下面改成 &lt; 即可 if (a[end] &gt; tmp) { a[end + 1] = a[end]; end--; } else { //当插入的数据是最小值的话，end移动到0位置处理完后，所有数据都往后移完了 //那下一次end为-1时，结束循环没有成功插入数据 //a[end + 1] = tmp; break; } a[end + 1] = tmp; } } } 🍍时间复杂度、空间复杂度、稳定性分析 ⭐️时间复杂度：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7f9c79ccd55d1d9c113b47bfbfd90ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb0d4a515d9e500b68c4ba2545be0202/" rel="bookmark">
			Python报错：PermissionError: [Errno 13] Permission denied解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Python报错：PermissionError: [Errno 13] Permission denied
翻译为：权限错误：[errno 13]权限被拒绝
错误产生的原因是文件无法打开，可能产生的原因是文件找不到，或者被占用，或者无权限访问，或者打开的不是文件，而是一个目录。
解决方案
公司电脑安装了联软防病毒勒索软件，退出即可。
常用解决方案
1.检查对应路径下的文件是否存在，且被占用。如果文件不存在，就找到对应文件即可；如果文件存在，被占用，将占用程序暂时关闭。2.修改cmd的权限，以管理员身份运行。3.检查是否是打开了文件夹。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a7b8cc89fdcaf3d35106178a839c6b3/" rel="bookmark">
			office宏的简单制作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文仅做参考，造成任何后果概不负责（本文适合渗透测试初学者）
环境： 1、两台可以ping通的虚拟机Linux-kali，Windows 2、提前配置好Windows的Java环境 （链接：jdk-11.0.17
提取码：6jfe --来自百度网盘超级会员V3的分享）
注：一定要关闭Windows防火墙 步骤： 一、下载cobalt strike汉化版 链接：cobalt strike
提取码：05rm --来自百度网盘超级会员V3的分享
下载完成后解压在自定义位置（这个位置必须记住）
二、将解压后的server文件夹拷贝到kali里，将client文件夹留在Windows中（安装VMware-tools的可以直接进行拖拽，未装的可以使用VMware共享文件夹） 三、打开kali终端并获取root权限，并将终端里的路径切换到server文件夹的路径（我本人是直接移动到kali桌面，所以比较方便找） ┌──(kali㉿kali)-[~] └─$ su 密码： ┌──(root㉿kali)-[/home/kali] └─# cd /home/kali/桌面/Server ┌──(root㉿kali)-[/home/kali/桌面/Server] └─# 四、启动cobalt strike的server服务端 ┌──(root㉿kali)-[/home/kali/桌面/Server] └─# ./teamserver 192.168.107.133 123456 #192.168.107.133为虚拟机kali的IP，不知道IP的可以输入“ifconfig”查询IP；123456为设置的密码 [*] Will use existing X509 certificate and keystore (for SSL) [*] Starting teamserver [*] Team Server Version: 4.8 (Pwn3rs) [*] Setting 'https.protocols' system property: SSLv3,SSLv2Hello,TLSv1,TLSv1.1,TLSv1.2,TLSv1.3 [*] Loading keystrokes. [*] Loaded 0 keystrokes. [*] Loading screenshots.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a7b8cc89fdcaf3d35106178a839c6b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfc3c0d1711e4bfa691edb7780e5c13f/" rel="bookmark">
			【Arduino TFT】基于 ESP32S3 S7789 240x240 TFT实现的SD2 天气时钟
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		忘记过去，超越自己
❤️ 博客主页 单片机菜鸟哥，一个野生非专业硬件IOT爱好者 ❤️❤️ 本篇创建记录 2023-10-21 ❤️❤️ 本篇更新记录 2023-10-21 ❤️🎉 欢迎关注 🔎点赞 👍收藏 ⭐️留言📝🙏 此博客均由博主单独编写，不存在任何商业团队运营，如发现错误，请留言轰炸哦！及时修正！感谢支持！🔥 Arduino ESP8266教程累计帮助过超过1W+同学入门学习硬件网络编程，入选过选修课程，刊登过无线电杂志 🔥零基础从入门到熟悉Arduino平台下开发ESP8266，同时会涉及网络编程知识。专栏文章累计超过60篇，分为基础篇、网络篇、应用篇、高级篇，涵盖ESP8266大部分开发技巧。 快速导航
单片机菜鸟的博客快速索引(快速找到你要的)
如果觉得有用，麻烦点赞收藏，您的支持是博主创作的动力。
文章目录 1. 前言2. 软件代码2.1 TFT屏幕的配置文件2.2 主工程代码2.3 tft显示代码2.4 睡眠模式2.5 获取天气信息 1. 前言 仿造网上开源的SD2 天气时钟，优化了部分代码， V1.0 最基本功能，支持夜间睡眠模式。后期会继续优化。
2. 软件代码 2.1 TFT屏幕的配置文件 // USER DEFINED SETTINGS // Set driver type, fonts to be loaded, pins used and SPI control method etc // // See the User_Setup_Select.h file if you wish to be able to define multiple // setups and then easily select which setup file is used by the compiler.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfc3c0d1711e4bfa691edb7780e5c13f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc650276d17388744d68b3cfd9db10bf/" rel="bookmark">
			Ros图像处理（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考自链接
3、在导入包时出现Illegal instruction (core dumped)该错误
解决方法：
运行前export OPENBLAS_CORETYPE=ARMV8 可加入到~/.bashrc中 4、在Jetson Nano上安装各种包
链接
1、cv_bridge和opencv版本不匹配报错的问题
File "/opt/ros/melodic/lib/python2.7/dist-packages/cv_bridge/core.py", line 91, in encoding_to_cvtype2 from cv_bridge.boost.cv_bridge_boost import getCvType ImportError: dynamic module does not define module export function (PyInit_cv_bridge_boost) 按照catkin_make的方式重新安装
sudo apt install python-catkin-tools python3-dev python3-catkin-pkg-modules python3-numpy python3-yaml ros-melodic-cv-bridge mkdir -p cv_bridge_ws/src &amp;&amp; cd cv_bridge_ws git clone https://github.com/ros-perception/vision_opencv.git src/vision_opencv apt-cache show ros-melodic-cv-bridge | grep Version cd src/vision_opencv/ git checkout 1.13.1 cd ../../ catkin_make -DPYTHON_EXECUTABLE=/usr/bin/python3 -DPYTHON_INCLUDE_DIR=/usr/include/python3.6m -DPYTHON_LIBRARY=/usr/lib/aarch64-linux-gnu/libpython3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc650276d17388744d68b3cfd9db10bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/effc3311927c937fa27b2afa0b251785/" rel="bookmark">
			unix本地套接字（Unix Domain Socket）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在​​Linux​​系统中，有很多进程间通信方式，套接字（Socket）就是其中的一种。但传统的套接字的用法都是基于TCP/IP协议栈的，需要指定IP地址。如果不同主机上的两个进程进行通信，当然这样做没什么问题。但是，如果只需要在一台机器上的两个不同进程间通信，还要用到IP地址就有点大材小用了。
其实很多人并不一定知道，对于套接字来说，还存在一种叫做Unix域套接字的类别，专门用来解决这个问题。其API的掉用方法基本上和普通TCP/IP的套接字一样，只是有些许差别。
因此，再正式介绍之前，先来复习一下套接字从创建，到传输数据，再到最后关闭的所有过程：
上边的图代表面向流的套接字，对于TCP/IP套接字来说，代表TCP协议；下边的图代表面向数据包的套接字，对于TCP/IP套接字来说，代表UDP协议。接下来，我们将特别针对普通TCP/IP套接字和Unix域套接字的不同，对这些API做一些解释。
1）socket()
最开始肯定还是要创建一个套接字：
int socket (int domain, int type, int protocol);
API定义是一样的，不过这里的第一个参数，也就是域一定要设置成AF_UNIX或AF_LOCAL，而不是普通TCP/IP套接字的AF_INET。第二个参数表示套接字的类型，分为流套接字（SOCK_STREAM）和数据包套接字（SOCK_DGRAM）。不同于普通的AF_INET的Socket，由于都是在本机通过内核通信，所以SOCK_STREAM和SOCK_DGRAM都是可靠的，不会丢包也不会出现发送包的次序和接收包的次序不一致的问题。它们的区别仅仅是，SOCK_STREAM无论发送多大的数据都不会被截断，而对于SOCK_DGRAM来说，如果发送的数据超过了一个报文的最大长度，则数据会被截断。而最后一个参数，表示协议，对于Unix域套接字来说，其一定是被设置成0。因此，一般通过下面的方式创建一个Unix域套接字：
int sockfd = socket(AF_UNIX, SOCK_STREAM, 0); // 流式Unix域套接字 int sockfd = socket(AF_UNIX,SOCK_DGRAM, 0); // 数据包式套接字
2）bind()，主要区别在这个函数里面
对于流式套接字的服务器端来说，在用socket()函数获得了新创建套接字的文件描述符之后，还要将其绑定到一个地址上去：
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
在Unix域套接字中，套接字的地址是以sockaddr_un结构体来表示的，其结构如下：
struct sockaddr_un { sa_family_t sun_family; char sun_path[108]; }
结构体中的第一个字段必须要设置成“AF_UNIX”。而第二个字段，表示的是一个路径名。因此，要将一个Unix域套接字绑定到一个本地地址上，需要创建并初始化一个sockaddr_un结构体，并将指向这个结构体的指针作为addr参数（需要类型转换）传入bind()函数，并将addrlen参数设置成这个结构体的实际大小。
这里还要特别提一下这个路径名，其实还要分为两种，一种是普通路径名，另一种是抽象路径名。
首先来说说普通路径名，这个很好理解，就是一个基本的​​linux​​文件路径，其必须要以NULL（'\0'）结尾。在绑定一个Unix域套接字时，会在文件系统中的相应位置上创建一个文件，且这个文件的类型被标记为“Socket”，因此这个文件无法用open()函数打开。当不再需要这个Unix域套接字时，可以使用remove()函数或者unlink()函数将这个对应的文件删除。如果在文件系统中，已经有了一个文件和指定的路径名相同，则绑定会失败（返回错误EADDRINUSE）。所以，一个套接字只能绑定到一个路径上，同样的，一个路径也只能被一个套接字绑定。
接下来看看什么叫抽象路径名，这其实是Linux特有的一个特性，它允许将一个Unix域套接字绑定到一个名字上，且不会在文件系统中创建这个名字的文件。如果要创建一个抽象名字空间的绑定，必须要将sun_path字段的第一个字节设置成NULL（'\0'），而且和普通的文件系统名字空间不同的是，系统会用sun_path除第一个字节之后余下的所有字节当做抽象名字。也就是说在解析抽象路径名时需要用到sun_path字段当中所有的字节，而不是像解析普通路径名一样，解析到第一个NULL就可以停止了。因为不会再在文件系统中创建文件了，所以对于抽象路径名来说，就不需要担心与文件系统中已存在的文件产生名字冲突的问题了，也不需要在使用完套接字之后删除附带产生的这个文件了，当套接字被关闭之后会自动删除这个抽象名。
最后再提一下权限的问题，因为要在文件系统中创建相应的文件，对于普通路径名来说，掉用bind()函数的进程必须要有路径名中目录部分的可写和可访问权限。还有，在默认情况下，在调用bind()函数时，会给所有者、组和其他用户赋予所有的权限（即777），如果想改变这个行为，可以在bind()之后再修改创建的文件的权限和属性。
3）listen()
对于流式套接字的服务器端来说，listen()函数在TCP/IP套接字和Unix域套接字中调用方式是一样的，没有区别：
int listen(int sockfd, int backlog);
4）accept()
对于流式套接字的服务器端来说，在调用bind()绑定完本地路径之后，还需要接收客户端的请求，这是通过调用accept()函数来实现的：
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/effc3311927c937fa27b2afa0b251785/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60a3eec230c12ef5c12d70a9cc35914c/" rel="bookmark">
			20T算力打造轻地图方案，这家智驾公司持续内卷
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者 | 张祥威
编辑 | 德新
行泊一体的话题热度不减。
近日，宏景智驾核心产品单SoC行泊一体解决方案已全场景跑通，可实现高速导航辅助驾驶。
在推进量产的同时，宏景智驾也在布局BEV感知、轻高精地图甚至去高精地图的智驾方案，同时也在打造4D BEV感知真值系统产品，赋能更多车企进行相关技术开发。
宏景智驾在HiEV进行了主题为《如何打造极致“品价比”的轻地图ADAS 产品》的线上分享，要点如下：
宏景智驾BEV去高精地图技术展示；宏景智驾轻地图ADAS产品，打造极致“品价比” ；宏景智驾 Hyper-GTMax如何附能车企高阶感知自研能力？ 以下为线上分享问答环节的内容整理。
一、将BEV轻地图能力降维到20T级算力芯片上 Q：当实时感知的结果跟本地的SD Pro Map（比标精地图精度更高）有差异的话，我们的逻辑策略是什么样的？
A：首先，宏景目前的开发重心还是高性价比的行泊一体产品。所以我们在高速上面采用的是SD地图，不是SD Pro的方案。在高速上SD地图就可以实现BEV+去地图的方案。因为我们在感知端的开发是不分高速和城市的。
在城市里面很多地方的拓扑是非常困难的，所以目前拓扑的模块还没有非常成熟之前，在这种比较复杂的路段，我们还是以图商提供的为准。
Q：目前我们对BEV的最低算力有评估吗？
A：我们目前可以把6V的BEV方案，在20TOPS+ 的芯片上实现目标检测和地图检测的能力。
Q：宏景的4D真值系统相当于是给车厂搭建了一套地图采集的设备么？
A：它其实不是地图采集。它更多的是，比如我们希望用一段多个图像的30秒数据，针对下游的任务，比如目标检测、局部地图的一些元素检测，包括一些Occupancy 的检测提供它的真值系统。
因为构建这些真值是非常麻烦的，很多时候车企想快速完成感知的0到1的能力的构建的时候，往往取决于它要怎么把这个数据构建出来。所以我们应客户需求做出了这套真值系统。
Q：宏景的方案跟其他家比，技术差异化主要在哪里？
A：第一，我们其实已经做了大量的基于HD Map的量产NOA（导航辅助驾驶）的落地。要去掉高精地图，首先要了解在量产NOA地图里的一些点，去地图的时候就更有信心，这个过程中的积累能更好地帮我们知道什么时候该如何解决某些问题。
第二，目前BEV轻地图的方案主要还是用在一些比较贵的车型上。我们希望能够把BEV轻地图的能力，通过技术降本的方式提供给车厂和消费者。这也是我们跟其它公司一个比较大的不同，我们能够把这种BEV轻地图的能力降维放到20TOPS+ 的芯片上，能实现差不多的功能，体验上也非常优秀。我们主打的是最高的“品价比”。
Q：要做到BEV轻地图的方案，算法上是如何考量的，是否要采用Transformer类型网络？
A：首先回到商业维度，我感觉城市NOA的落地，并不一定是大芯片+Transformer就一定能实现的，更多的是整个功能做出来是怎么样的？体验如何？价格如何？这是一个点。
第二，从技术维度上，因为整个BEV模型有很多个模组，包括比如2D转3D模块、时序、检测模块，在一些功能模块上面，我认为是不是 Transformer 都无所谓，只要能够完成这个功能就可以。无论是Transformer或者CNN（卷积神经网络）都可以。在检测上面使用Transformer的方式，其实能带来表征的一些优化。
从芯片的角度说，用这种支持Transformer的芯片，对于算法的选择上是有很多的帮助的。对我们来说做BEV地图的检测，如果只是用传统的CNN，想去地图是非常困难的，因为它有非常多厚重的后处理。
所以我们现在整个BEV在车端算法的核心，是在输出端能够直接输出点集加上局部的拓扑，这个输出的表征其实是非常重要的。这也是为什么我们在20TOPS＋ 的芯片上能够做出来跟Transformer效果差不多的线，它并不是通过大量的复杂的后处理来得到的，而是直接从模型里面出的。
Q：您认为BEV的难度以及壁垒在哪里？
A：我认为算法壁垒、数据壁垒，或者说BEV究竟能不能应用到一个非常好的产品上面，其实都有壁垒。
举个例子，从算法开发的角度来说，BEV其实也有一些不同的功能模块，比如BEV下的3D目标检测这个功能，从整个数据的构建到标注到最后的输出，这个难度会稍微小一点。但是BEV轻地图的这个功能，要完成非像素级别对应的数据的构建，其实要花的时间和整个数据构建的难度会更大。
第二，数据的壁垒肯定是最大的。拥有越来越多高质量的数据，BEV感知的性能就越好，迭代周期就越快。所以到BEV的阶段，需要有非常强的数据构建的能力，包括自动标注都是非常重要的。
第三，如何基于BEV打造一个好的产品也是一种壁垒。
二、要实现城市NOA，必须去高精地图 Q：现在大家可能会感受到，去地图后的成本并没有降太多，而且体验相比于传统高精地图的体验还会差一些，您怎么看这个问题？
A：我认为这个问题一方面取决于感知的成熟度，另一方面取决于体验能不能持续做得更好，还有一方面取决于客户的接受度。
宏景目前还是脚踏实地的希望先从高速做起，在高速上基于我们非常成熟的行泊一体的量产的系统，能把高精地图和高精定位模组去掉。
然后在感知开发端，其实不论城市和高速我们都会积累，所以我们也不会那么快一定要在城市里面完全不依赖高精地图。目前阶段我们的重心还是在高速上去完成具备性价比产品的打造。
从价格方面，我非常赞同“一个ADAS系统应该在车价的3% - 5% 的区间”这种说法，如果我们要让10万的车能满足这样的功能，那是不是要把整个系统成本压到这个区间，主机厂才愿意买单，才能有更多人愿意买单。这个时候我们一定是希望通过更好的技术降本去完成。
通过BEV轻地图的方式，在现在这种比较成熟的行泊一体的里面做到体验不降，甚至上了BEV之后体验还能更好，同时能降低成本，把这个能力给到更多的低价的车型，更多的消费者手里，这是我们的愿景。
Q：想问一下目前在跟主机厂交流的过程当中，主机厂的态度，是不是对去地图的诉求真的很强烈？还是主机厂的诉求只是降本？并不特别关心怎样通过技术去实现这个功能。
A：我觉得这个可以分成两个点。第一点，现在比较热的城市NOA的功能，它的去地图其实并不是一个降本的方案，因为高精地图在城市里面要保持这个东西非常困难，所以它更多是从技术角度的考虑，要实现城市NOA，必须具备去地图的能力。
现在，我们在高速NOA上去地图的能力，相对来说实现的方式会比城市稍微简单一点，它只要能够把各种匝道、各种困难的场景攻克了，能够达到这样的功能，其实从降本的层面，对于这个主机厂来说他们还是非常乐意见到这样的产品推出。只要能保证产品体验足够优秀，还比别人便宜，是非常有竞争力的。
还有一点，这种新系统里面它有一个核心点，就是它会把这个BEV的感知架构给拿出来，整个数据架构可以逐渐地从高速往城市这样去走，是一个体系化的升级和更新。
Q：相比传统技术，BEV技术下的标注有哪些新的规则和新的技术?
A：以BEV地图举例，规则层面肯定还是看算法下游的一些定义，包括后面需要的哪些功能来做BEV地图的一些标注，要识别哪一些元素，之间它需要有一个关联关系，这个关联关系是怎么样的？这是一个维度。
另外从技术的角度，它会比传统的更复杂一点。因为如果想在6V上面直接标BEV地图，基本上不太可能，所以必须要能够有场景重建能力的模块，在这个场景重建的基础上去做完标注，标完的数据还得跟图像级别的像素对应起来。这个地方对于整个系统的时间同步，传感器的标定，整个基础能力都是非常考验的，才能得到4D对应好的这种真值Clip 来做BEV训练，不然构建出来的数据对齐程度不高，这个BEV训练出来结果会有很大的问题。
Q：在拥堵场景下，BEV怎么做到实时建图，比如一个拓扑结构被周围车辆遮挡住了，怎么解决这个问题？
A：这是一个非常难的点，我觉得解决了这个问题之后，就能在高速上把BEV地图去掉了。现在我们的解决方案，首先整个BEV并不是单帧的，它是带时序的。因为整个地图元素是一个静态的信息，所以只要曾经看到过，就能记住。
BEV地图跟传统的所见即可得的这种车道线检测对比，它有一定的预测和推理能力。很多时候我数据标的时候真值为一个路口，或者一个匝道口，其实有时候像素里面没有看到，它其实就有局部的预测能力。这是一个点，在感知端需要更好地解决这个问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60a3eec230c12ef5c12d70a9cc35914c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46a345d586fc189e5fd58d9945a4dee1/" rel="bookmark">
			k8s ingress注解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Name
type
作用
nginx.ingress.kubernetes.io/app-root
string
定义应用根目录
nginx.ingress.kubernetes.io/affinity
cookie
开启会话的粘连
nginx.ingress.kubernetes.io/affinity-mode
"balanced" or "persistent"
nginx.ingress.kubernetes.io/affinity-canary-behavior
"sticky" or "legacy"
nginx.ingress.kubernetes.io/auth-realm
string
nginx.ingress.kubernetes.io/auth-secret
string
nginx.ingress.kubernetes.io/auth-secret-type
string
nginx.ingress.kubernetes.io/auth-type
basic or digest
nginx.ingress.kubernetes.io/auth-tls-secret
string
nginx.ingress.kubernetes.io/auth-tls-verify-depth
number
nginx.ingress.kubernetes.io/auth-tls-verify-client
string
nginx.ingress.kubernetes.io/auth-tls-error-page
string
nginx.ingress.kubernetes.io/auth-tls-pass-certificate-to-upstream
"true" or "false"
nginx.ingress.kubernetes.io/auth-tls-match-cn
string
nginx.ingress.kubernetes.io/auth-url
string
nginx.ingress.kubernetes.io/auth-cache-key
string
nginx.ingress.kubernetes.io/auth-cache-duration
string
nginx.ingress.kubernetes.io/auth-keepalive
number
nginx.ingress.kubernetes.io/auth-keepalive-requests
number
nginx.ingress.kubernetes.io/auth-keepalive-timeout
number
nginx.ingress.kubernetes.io/auth-proxy-set-headers
string
nginx.ingress.kubernetes.io/auth-snippet
string
nginx.ingress.kubernetes.io/enable-global-auth
"true" or "false"
nginx.ingress.kubernetes.io/backend-protocol
string
nginx.ingress.kubernetes.io/canary
"true" or "false"
nginx.ingress.kubernetes.io/canary-by-header
string
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46a345d586fc189e5fd58d9945a4dee1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9959629183a67fcb9f893ee5703cf673/" rel="bookmark">
			charles的基本介绍与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 Charles安装一、抓包1.http请求1）Charles设置2）手机设置3）抓包 2.https请求1）前提2）手机安装证书3）电脑安装证书4）Charles开启Enable SSL Proxying 二、重定向（Map）1.Map Remote2.Map Local 三、Mock数据1.断点（Breakpoints）2.文件映射（Map Local） 四、其他1.限速五、Q&amp;A Charles安装 下载链接：https://www.charlesproxy.com/download/
同时支持Windows和Mac平台
以下内容基于Charles V 3.11.5
Fiddler/charles
一、抓包 1.http请求 1）Charles设置 Help - Local IP Address，可以查看电脑IP：
查看IP其它方法：
Windows：
WIN+R，打开“cmd”
输入命令ipconfig
Mac：
系统偏好设置 -&gt; 网络
Proxy - Proxy Settings，查看代理端口，默认值8888，也可自行修改：
2）手机设置 iPhone：
点击红框位置打开代理设置页面，填写电脑端的IP和端口：
Android：
手机-设置-WiFi-已连接WiFi-详情-高级-代理-手动-主机名/端口
手机连上代理后，Charles将弹Access Control弹框，点击「allow」
误点了Deny？
Proxy - Access Control Setting，把手机的IP地址加上
3）抓包 选择一个请求
Overview：
请求的总体概况，包括请求URL/状态/请求方式/耗时/流量等信息，其中size是本次请求消耗的流量，具体到request和response的流量
Request：
点击「Form」，列出请求的所有参数
部分请求带了cookie，如打开团单详情页时请求的itemDetailNew接口
ctag埋点也在cookie中，即图中的bn_na_ctag字段，值经base64加密处理
Response：
以JSON或者JSON Text形式查看response
2.https请求 1）前提 Server端支持https请求
证书
证书是在Client和Server间建立SSL连接的基础
在Client和Server间加了代理后，要在 手机 - 代理工具、代理工具 - Server 间建立SSL连接，手机和电脑上都要安装证书
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9959629183a67fcb9f893ee5703cf673/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ea80f32d8751cf8b867b89d6b13ee7b/" rel="bookmark">
			C语言switch、while、for、do while干货~小白快看过来
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.switch介绍： 1.在C语言中，除了if语句可以实现分支选择结构外，switch也可以实现分支结构。switch语言是一种特殊形式的if……else结构，主要用于判断多个结果的情况。
2.switch的语言形式如下：
#include &lt;stdio.h&gt; int main() { switch (expression) case value1:statement case value2:statement default:statement return 0; } 根据表达式expression不同的值，执行相应的case分支，如果找不到对应的值，就执行default分支。
注：switch后面的expression必须是整形表达式，case后面的值，必须是整形常量表达式。字符也可以，因为字符是以ASCII值进行存储的，是整数类型。 一：if语句和switch语句的对比： 1.数据类型不同： 在if语句中数据类型可以是布尔类型、可以是大于0的整数判断为true，也可以是小于0的整数判断为false、可以是常量、枚举。
而在switch语句的括号中，数据类型必须是整型或者是字符类型。
2.语句结构不同： 在if语句中，常用到的是else、if……else，通常两种情况时，选用else，但如果有两种以上的多种情况，通常选用if……else语法结构。
在switch语句中，常用到的是case（它表示的是情况，与表达式中的值相匹配，他给的值一般是常量，不能是变量）、default（它表示case所有情况不符合）、break（表示中断结束的意思，跳出switch语句）。
3. 应用场景不同: if建议在判断区间或者范围的时候使用，switch建议在判断固定值的时候使用，但一般可以使用switch的场景都可以使用if，反之不一定成立。
4.返回途径不同： if是根据条件判断后再进行处理，通常条件表达式必须是一个返回布尔结果的表达式，条件返回值是true则继续进行下面的语句，如果条件返回值是false，则执行相对应的语句。
switch根据表达式的值来执行多个操作中的一个。
二.break、case、defalut介绍： 一.break具体使用： #include &lt;stdio.h&gt; int main() { int day =0; scanf("%d",&amp;day); switch(day) { case1: printf("星期一\n"); case2: printf("星期二\n"); case3: printf("星期三\n"); case4; printf("星期四\n"); default; printf("休息\n"); return 0; } 大家可以猜猜在这段代码中，如果不使用break运行的结果是什么？ 那么为什么输入3后输出的有四个结果？那是因为输入3后，找到对应的情况进去，然后一直从case3执行到default，中间没有被打断，所以当我们只想要一个输出结果时，可以使用break加在后面，使其只输出一个结果。 二.case具体使用： 上述代码中，我们需要注意的是case和后面的数字之间必须有空格，每一个case语句中的代码执行完成后，需要加上break才能跳出这个语句。，而且case后面只能使用常量表达式，case后面的值不能重复使用。
三.default具体使用： 在switch语句中，case句子和default句子没有顺序要求，只要我们写出的代码可以正常运行就行，不过我们一般都是把default放在句子后面处理的。
三.while介绍： 一.while基本知识： 1.C语言中提供了三种循环语句，分别是：while、for、do……while。while就是其中的一种.
2.while的语法形式如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ea80f32d8751cf8b867b89d6b13ee7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71c14ee65bc75918290364d625919ad4/" rel="bookmark">
			Spring Boot中@PathVariable、@RequestParam和@RequestBody的区别和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		title: springboot中@PathVariable、@RequestParam和@RequestBody的区别和使用
date: 2020-11-02
tags:
springspringbootspring注解注解@RequestParam注解@PathVariablerestful风格注解@RequestBody
categories:springspring注解注解@PathVariable、@RequestParam和@RequestBody的区别和使用 一、@PathVariable 1.1 restful风格 1.1.1 概念 一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。
1.1.2 特点 REST：即 Representational State Transfer。（资源）表现层状态转化。是目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用资源（Resources）：网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的存在。可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的 URI 。要获取这个资源，访问它的URI就可以，因此 URI 即为每一个资源的独一无二的识别符。表现层（Representation）：把资源具体呈现出来的形式，叫做它的表现层（Representation）。比如，文本可以用 txt 格式表现，也可以用 HTML 格式、XML 格式、JSON 格式表现，甚至可以采用二进制格式。状态转化（State Transfer）：每发出一个请求，就代表了客户端和服务器的一次交互过程。HTTP协议，是一个无状态协议，即所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生**“状态转化”**（State Transfer）。而这种转化是建立在表现层之上的，所以就是 “表现层状态转化”。具体说，就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源。 1.1.3 restful风格和传统操作方式的对比 功能传统方式restful风格查询http://127.0.0.1/item/selectUser?id=1GET http://127.0.0.1/item/selectUser/1新增http://127.0.0.1/item/addUserPOST http://127.0.0.1/item/addUser更新http://127.0.0.1/item/updateUserPUT http://127.0.0.1/item/updateUser删除http://127.0.0.1/item/deleteUser?id=1DELETE http://127.0.0.1/item/deleteUser/1 1.2 @PathVariable的介绍 @PathVariable 映射 URL 绑定的占位符
带占位符的 URL 是 Spring3.0 新增的功能，该功能在SpringMVC 向 REST 目标挺进发展过程中具有里程碑的意义通过 @PathVariable 可以将 URL 中占位符参数绑定到控制器（controller）处理方法的形参中：URL 中的 {xxx} 占位符可以通过@PathVariable(“xxx“) 绑定到操作方法的形参中。主要是根据请求方法进行类的区别 1.3 @PathVariable所具有的参数 String value：可指定占位符 { } 中的参数名，若只指定value这一个属性可省略属性名不写，若占位符中的参数名和处理方法中的参数名相同可省略此属性。String name：等价与value，和value无本质上的差异，两个属性指定其一即可。boolean required：是否必需，默认为 true，即 请求中必须包含该参数，如果没有包含，将会抛出异常（可选配置） 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71c14ee65bc75918290364d625919ad4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f8ff405cf068adad2a0531f4c7f6155/" rel="bookmark">
			施密特正交化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相信大家在平时的期末考试中一定少不了对某某向量组执行标准正交化类型的题目。今天我们从这个题目入手，说明这个如何执行施密特正交化，以及为什么要进行正交化。
一、例子 例子：设 a 1 = [ 1 2 − 1 ] a_1=\begin{bmatrix}1\\2\\-1\end{bmatrix} a1​= ​12−1​ ​， a 2 = [ − 1 3 1 ] a_2=\begin{bmatrix}-1\\3\\1\end{bmatrix} a2​= ​−131​ ​， a 3 = [ 4 − 1 0 ] a_3=\begin{bmatrix}4\\-1\\0\end{bmatrix} a3​= ​4−10​ ​ 使用施密特正交化将这组向量标准正交化。
答：标准正交向量组应该满足：
向量的长度为1；向量之间相互正交； 选定一个基准向量
A 1 = a 1 = [ 1 2 − 1 ] A_1=a_1=\begin{bmatrix}1\\2\\-1\end{bmatrix} A1​=a1​= ​12−1​ ​
对第二个向量分解为正交和与 A 1 A_1 A1​ 共线的两个向量，其中与 A 1 A_1 A1​ 共线的向量因为已经能够用 A 1 A_1 A1​ 进行表示，所以应该剔除只保留与 A 1 A_1 A1​ 正交的分量：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f8ff405cf068adad2a0531f4c7f6155/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/50/">«</a>
	<span class="pagination__item pagination__item--current">51/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/52/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>