<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c2d195e961b652749f031be4dcd5fc7/" rel="bookmark">
			windows10下 iperf3测试带宽
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		iperf3下载网址：iPerf - Download iPerf3 and original iPerf pre-compiled binaries
可以用来测试TCP以及UDP带宽质量　通俗来说是用来测试网速的
准备：两台设备
1.　根据自己的设备选择下载工具（两台都要有，这里我用的Windows10　64位台式机）
2.　打开下载好的压缩包
打开一个文件夹，讲压缩包解压到此处，并进入到文件夹目录下，在上方输入ｃｍｄ＋回车进入命令界面
3.　验证是否下载成功，在打开的窗口中输入“iperf3.exe -v”，会出现安装的版本，表示安装成功了
4.　开始测试
测试时，一台设备做服务端，一台设备做客户端
服务端输入“iperf3 -s”，出现server listening on 5201即说明服务端已运行
客户端输入：“iperf3.exe -c 服务器IP地址 -P 10“//表示客户端10路并行给服务器发送TCP包；
上图可知：带宽是15Gbps（这里不知道为什么下面测试的UDP会比这里TCP慢　按道理UDP不可能比TCP慢的5.）
客户端输入："iperf3.exe -u -c 服务器IP地址 -b 5g" //客户端给服务器发送udp数据包，最大带宽为5g
上图可知：带宽1.99 Gbps，延时0.003ｍｓ，丢包0％
5.　iperf3参数
共用参数：
-f [k|m|K|M] 分别表示以Kbits, Mbits, KBytes, MBytes显示报告，默认以Mbits为单位,eg:iperf -c 222.35.11.23 -f K -i sec 以秒为单位显示报告间隔，eg:iperf -c 222.35.11.23 -i 2 -l 缓冲区大小，默认是8KB,eg:iperf -c 222.35.11.23 -l 16 -m 显示tcp最大mtu值 -o 将报告和错误信息输出到文件eg:iperf -c 222.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c2d195e961b652749f031be4dcd5fc7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ace8d0b81fbf68faff31c3e803685c5/" rel="bookmark">
			echarts 中如何将 legend 设置成「直线」
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Thinking系列，旨在利用10分钟的时间传达一种可落地的编程思想。
echarts 中如何将 legend 设置成「直线」？
所有图例均为直线 可以通过 itemHeight 和 itemWidth 来统一控制
legend: { itemHeight: 2, itemWidth: 20, data: ['Expenses', 'Income'] } 部分是直线 需要通过icon+base64图片来实现
legend: { itemHeight: 20, itemWidth: 20, data: [{ name: 'Expenses', icon: 'rect' }, { name: 'Income', icon: 'image://data:image/gif;data:image/jpeg;base64,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' }] } 按照第一种方式生成直线类型，然后截图，通过在线工具转base64.
高版本 echarts 隐藏值
legend: { itemHeight: 20, itemWidth: 20, data: [{ name: 'Expenses', icon: 'rect' }, { name: 'Income', icon: 'line' }] } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05b4b46a905368abfe10b7dabeb7a984/" rel="bookmark">
			ubuntu20.04 nerf Instant-ngp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Instant-ngp linux
ubuntu 20.04
GPU RTX3050Ti
Instant-ngp官方文档地址
https://github.com/NVlabs/instant-ngp
参考链接
Instant-ngp linux部署及使用 - 简书
Ubuntu20.04复现instant-ngp，自建数据集，导出mesh_XINYU W的博客-CSDN博客
步骤
安装基本依赖
sudo apt-get install build-essential git python3-dev python3-pip libopenexr-dev libxi-dev \ libglfw3-dev libglew-dev libomp-dev libxinerama-dev libxcursor-dev 安装CUDA 官网给的是NVIDIA+CUDA，但我个人推荐现在自己电脑装对应的显卡驱动
首先进入
CUDA Toolkit - Free Tools and Training | NVIDIA Developer
download now
Linux
x86_64
ubuntu
20.04
runfile(local)
可以参考
Ubuntu 20.04安装CUDA 11.4, cuDNN 8.24 - 知乎
ubuntu将cuda卸载干净_ubuntu卸载cuda-CSDN博客
也可以参考下面
可以看到
wget https://developer.download.nvidia.com/compute/cuda/12.2.2/local_installers/cuda_12.2.2_535.104.05_linux.run sudo sh cuda_12.2.2_535.104.05_linux.run 这是可以看到535，那我们就在自己电脑的软件和更新里面选择（记得先sudo apt update,sudo apt upgrade）,选择NVIDIA driver metapackage 来自****535（专有）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05b4b46a905368abfe10b7dabeb7a984/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/065edeceed1e01439f2b9ccfa51cd404/" rel="bookmark">
			hantek 的hdp135v6s通信协议测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hantek 的hdp135v6s通信协议测试 型号为hdp135v6s，输出范围0-35V，最大分辨率10mV
官方给的头文件：
/** 初始化串口函数
*
* @param: UINT portNo 串口编号,默认值为1,即COM1,注意,尽量不要大于9
* @param: UINT baud 波特率,默认为9600
* @param: char parity 是否进行奇偶校验,'Y’表示需要奇偶校验,'N’表示不需要奇偶校验
* @param: UINT databits 数据位的个数,默认值为8个数据位
* @param: UINT stopsbits 停止位使用格式,默认值为1
* @param: DWORD dwCommEvents 默认为EV_RXCHAR,即只要收发任意一个字符,则产生一个事件
* @return: bool 初始化是否成功
* @note: 在使用其他本类提供的函数前,请先调用本函数进行串口的初始化
*　/n本函数提供了一些常用的串口参数设置,若需要自行设置详细的DCB参数,可使用重载函数
* /n本串口类析构时会自动关闭串口,无需额外执行关闭串口
* @see:
*/
bool InitPort(UINT portNo = 1, UINT baud = CBR_2400, char parity = ‘N’, UINT databits = 8, UINT stopsbits = 1, DWORD dwCommEvents = EV_RXCHAR);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/065edeceed1e01439f2b9ccfa51cd404/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f25319b8677f62a1fafb6792767c4f4f/" rel="bookmark">
			VMware如何彻底卸载删除干净详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 安装过VMware的小白，大概率会遇到 安装容易卸载难 的问题。而且卸载不干净会导致后续安装和使用出现各种bug，今天说说我如何彻底删除干净VMware。 一：卸载虚拟机内的系统 关机，右键，管理，删除。
二：卸载VMware虚拟机软件 一，在卸载VMware虚拟机之前，要先把与VMware相关的服务和进程终止。 1.同时按下键盘的 Win+R 键，打开运行框。输入命令 services.msc，再点击确定，进入服务页面。
（或者在windows中搜索【服务】设置，然后打开）
2.找到VMware，右键点击其中一个，在弹出的下拉列表中点击 停止 按钮，稍等片刻即可停止该服务。依次类推，逐个关掉所有VMware字样的服务。左上角变成 启动 代表已经停止服务了。（都要关闭哦）
3.在windows中使用【Crtl+Shift+Esc】打开任务管理器，并找到以VM打头命名的进程，然后右键结束这些进程任务；
(或者同时按下键盘的 Win+R 键，打开运行框，在里面输入 taskmgr，然后点击确定，打开任务管理器。)
二，开始卸载VMware虚拟机 1.打开【控制面板】，然后点击【卸载程序】；
(这里会有人发现自己程序里没有这个软件，没法卸载，这我的方法是安装完保留软件安装包，如何找到安装包，双击打开，下一步也可以到这个界面)
如何就接着下一步，完成删除。
三. 清理VMware虚拟机在注册表中的信息和遗留在电脑的文件 1. 在系统中搜索【注册表】，然后打开【注册表编辑器】 ；
（或者同时按下键盘的 Win+R 键，打开运行框，在里面输入 regedit，然后点击确定，打开注册表编辑器。）
2. 在【注册表编辑器】中找到【HKEY_CURRENT_USER】目录；
再依次打开【software】【VMware，Inc】，右击删除。
3.打开我的电脑，在C盘的Program Files(x86)文件下找到VMwar文件，然后删除；
至此，VMware虚拟机以彻底卸载完成。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/576ab89e6a522717709730ea574601f2/" rel="bookmark">
			docker部署 spring-boot 项目，验证码获取报错的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 在 docker 部署 spring-boot 项目后，启动项目时，验证码获取报错：
2020-10-21 16:13:03.603 ERROR 9 --- [ XNIO-1 task-2] c.e.c.s.handler.GlobalExceptionHandler : 全局异常信息 ex=null java.lang.NullPointerException: null at sun.awt.FontConfiguration.getVersion(FontConfiguration.java:1264) at sun.awt.FontConfiguration.readFontConfigFile(FontConfiguration.java:219) at sun.awt.FontConfiguration.init(FontConfiguration.java:107) at sun.awt.X11FontManager.createFontConfiguration(X11FontManager.java:774) at sun.font.SunFontManager$2.run(SunFontManager.java:431) at java.security.AccessController.doPrivileged(Native Method) at sun.font.SunFontManager.&lt;init&gt;(SunFontManager.java:376) at sun.awt.FcFontManager.&lt;init&gt;(FcFontManager.java:35) at sun.awt.X11FontManager.&lt;init&gt;(X11FontManager.java:57) at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62) at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) at java.lang.reflect.Constructor.newInstance(Constructor.java:423) at java.lang.Class.newInstance(Class.java:442) at sun.font.FontManagerFactory$1.run(FontManagerFactory.java:83) at java.security.AccessController.doPrivileged(Native Method) at sun.font.FontManagerFactory.getInstance(FontManagerFactory.java:74) at java.awt.Font.getFont2D(Font.java:491) at java.awt.Font.access$000(Font.java:224) at java.awt.Font$FontAccessImpl.getFont2D(Font.java:228) at sun.font.FontUtilities.getFont2D(FontUtilities.java:180) at sun.java2d.SunGraphics2D.checkFontInfo(SunGraphics2D.java:670) at sun.java2d.SunGraphics2D.getFontInfo(SunGraphics2D.java:831) at sun.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/576ab89e6a522717709730ea574601f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d023576ca988ea7a90359e1683a9a73/" rel="bookmark">
			【python】求多变量/样本（矩阵）之间的相关性系数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创作日志： Pearson或Spearson代表的是两个变量之间的相关性，因此一般输入是两个向量(vector)，那么当我们有多个变量时，怎样计算他们两两之间的相关性系数呢？得到的correlation matrix各元素代表的又是什么意思呢？
举例：
矩阵A有两个样本：a1 与 a2，矩阵B有两个样本：b1 与 b2
我们可以利用相关性系数计算函数直接得到 a1 与 b1 、 a2 与 b2 的相关性
import numpy as np # 创建两个示例矩阵 matrix1 = np.array([[1, 2, 3], [4, 5, 6]]) matrix2 = np.array([[9, 2, 7], [6, 5, 0]]) # 使用NumPy的corrcoef函数计算Pearson相关性系数 correlation_matrix = np.corrcoef(matrix1, matrix2) print(correlation_matrix) 打印结果： [[ 1. 1. -0.2773501 -0.93325653] [ 1. 1. -0.2773501 -0.93325653] [-0.2773501 -0.2773501 1. -0.0862796 ] [-0.93325653 -0.93325653 -0.0862796 1. ]] 结果是一个4x4的矩阵，因为matrix1有两个变量/样本，matrix2有两个变量/样本，共四个样本，每两个样本之间一一对应，包括自身与自身，就形成了4x4，下面是对应关系：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d023576ca988ea7a90359e1683a9a73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c6e6795c43cce276b7983eb11e7a026/" rel="bookmark">
			一文搞懂常见敏感信息泄露
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常见敏感信息泄露 1.备份文件泄露 1.1 备份文件 常见的文件泄露一般泄露的都是网站的备份文件，常见的备份的文件名通常为 wwwroot、www、子域名等，压缩包后缀通常为 zip、tar.gz 等
/a.zip /web.zip /web.rar /1.rar /bbs.rar /www.root.rar /123.rar /data.rar /bak.rar /oa.rar /admin.rar /www.rar /2014.rar /2015.rar /2016.rar /2014.zip /2015.zip /2016.zip /2017.zip /1.zip /1.gz /1.tar.gz /2.zip /2.rar /123.rar /123.zip /a.rar /a.zip /admin.rar /back.rar /backup.rar /bak.rar /bbs.rar /bbs.zip /beifen.rar /beifen.zip /beian.rar /data.rar /data.zip /db.rar /db.zip /flashfxp.rar /flashfxp.zip /fdsa.rar /ftp.rar /gg.rar /hdocs.rar /hdocs.zip /HYTop.mdb /root.rar /Release.rar /Release.zip /sql.rar /test.rar /template.rar /template.zip /upfile.rar /vip.rar /wangzhan.rar /wangzhan.zip /web.rar /web.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c6e6795c43cce276b7983eb11e7a026/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47835f621a0996c270241571bf0b5595/" rel="bookmark">
			WSL安装Ubuntu及配置Pytorch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：
https://www.bilibili.com/video/BV1Fx4y1j7yy/?spm_id_from=333.337.search-card.all.click
https://www.gongsunqi.xyz/posts/3c995b2a/#wsl%E5%AE%89%E8%A3%85anaconda%E5%B9%B6%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83
在深度学习中经常会用到linux环境，但是相对于windows，对于作者这样的小白，使用linux肯定不是首选，但是最近用到了某些包，只能在linux环境下使用，在安装双系统时，发现了WSL2，尝试了一下很好用，所以记录一下安装教程，如果不习惯于linux，可以尝试使用。
安装WSL及Ubuntu 网上教程在安装WSL时有很多命令，偶然从bilibili发现UP主使用Microsoft Store下载很好用，所以本文也采用这种方式，视频链接在顶部参考中已列出。目前最新的是WSL2，使用win11系统默认为此版本，如果是win10可能需要用其他方法安装WSL2。
1、启用windows某些功能 首先在windows下方搜索栏输入hyper
点击进入，并将框中三项打勾，点击确定，等待完成配置并重新启动电脑。
2、安装WSL和Ubuntu 打开微软商店搜索WSL和Ubuntu，点击安装
安装完成后，打开Ubuntu
配置Ubuntu用户信息：
然后等待一会，如下图所示即为配置成功
然后打开终端（Powershell）:
输入下方命令可以看到已安装版本：
wsl -l --all -v 3、迁移至其他盘 在默认情况下，WSL和Ubuntu会安装在C盘，这一小节是将C盘的这两部分转移至其他盘，如果不需要可以跳过此小节。
当我们输入wsl -l --all -v 命令，如果Ubuntu的STATE是Running，首先输入下面的命令，将其暂停：
wsl --shutdown 首先去要转移到的盘新建一个文件夹，如图所示，我要转移到F:\linux\Ubuntu位置
回到终端输入命令：
wsl --export Ubuntu-22.04(根据自己版本填写) 转移的位置+\名称.tar 如图所示即为导出成功：
接下来注销当前C盘的版本：
wsl --unregister 名称 注销成功后，重新导入WSL并安装在目标盘：
wsl --import 版本 导入位置 第一步tar包的位置 --version 2 可能不太好理解，此时我的命令是：
wsl --import Ubuntu-22.04 F:\linux\Ubuntu F:\linux\Ubuntu\Ubuntu-22.04.tar --version 2 效果如图：
导入成功，我们可以手动删除导入位置的tar包：
然后在终端输入WSL：
此时用户是root，不是我们自己创建的用户，我们可以设置默认用户
首先输入exit退回到终端，然后输入下面命令：
名称 config --default-user 用户 注意！这句命令的“名称”部分，输入前几个字母然后按Tab键自动补全！
可以看到，名称变了，因此需要自动补全，这样才不会出问题，设置好以后点击终端下拉图标选择进入Ubuntu
至此WSL和Ubuntu已经安装好了，接下来的章节是在WSL的Ubuntu配置Pytorch
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47835f621a0996c270241571bf0b5595/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/098191288dc68b591db6a9f0075b76b9/" rel="bookmark">
			【深度学习】绘制模型训练曲线（epoch-accuracy），寻找最佳epoch值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是epoch 在卷积神经网络（CNN）训练中，"epoch"（周期）是一个重要的概念，表示模型训练过程中数据集的完整遍历次数。通过多次"epoch"，模型逐渐适应训练数据，提高性能，并通过验证性能监测模型的泛化能力。在深度学习中，正确设置"epoch"的数量是一个重要的超参数，需要根据具体问题和数据集来调整。
Epoch设置过大：
过拟合风险：如果 epoch 设置过大，模型有可能过度拟合训练数据，即模型在训练数据上表现得非常好，但在新数据上表现较差。这是因为模型会记住噪声和细节，而不是学习通用规律。
浪费时间和计算资源：较大的 epoch 会占用更多的时间和计算资源，而结果可能不会有显著的提升。这对于大规模深度学习模型来说特别昂贵。
Epoch设置过小：
欠拟合风险：如果 epoch 设置得太小，模型可能无法捕获训练数据中的模式和特征，导致训练不足，模型性能较差。
性能下降：模型需要一定的训练时间才能逐渐学习数据的特征。如果 epoch 设置太小，模型可能没有足够的时间来收敛，导致性能下降。
二、绘制epoch-accuracy（准确性）与epoch-loss（损失值）曲线图，寻找最佳epoch 所用数据文件：点击下载
import torch from torch.utils.data import Dataset, DataLoader import numpy as np from PIL import Image from torchvision import transforms # 定义数据预处理的转换 data_transforms = { 'train': transforms.Compose([ transforms.Resize([256,256]), transforms.ToTensor() ]), 'valid': transforms.Compose([ transforms.Resize([256, 256]), transforms.ToTensor() ]), } # 定义自定义的数据集类 class food_dataset(Dataset): # food_dataset是自己创建的类名称，可以改为你需要的名称 def __init__(self, file_path, transform=None): # 类的初始化 self.file_path = file_path self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/098191288dc68b591db6a9f0075b76b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5857d4f5bf01eaa9c3b691dd4770484/" rel="bookmark">
			Linux安装yum
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		是不是安装yum找半天找不到详细的操作方法
一会让你装这个，一会让你装那个，一装发现还是需要yum来安装
有些还要你装python
今天就让你一步解决你的问题。
yum安装：
一、安装build-essential软件包
提供编译程序必须软件包的列表信息。build-essential包包含了开发很多必要的软件包，安装一个build-essential包，对应C/C++依赖的好多包都会被安装。
apt-cache depends build-essential
安装完成后，可以尝试安装yum
二、初步尝试安装yum
sudo apt-get install yum
可能会出现下面提示：
意思就是无法定位软件包，解决办法就是修改软件源镜像。方法如下：
解决问题：
cd /etc/apt/ #切换到apt目录下
sudo cp sources.list sources.list.old #把原来的sources.list文件备份一下
sudo vim sources.list #编辑sources.list
告知一下小白vim简单使用方法，知道的可以直接下一步：
vim进入后，按「i」进入编辑模式，按「Esc」推出编辑模式，按「:wq」保存推出。
打开编辑 sources.list 文件，在文件最后添加如下内容（可以一次性复制进去）：
deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse
然后更新一下软件源：
sudo apt-get update
更新完成以后，再次输入yum安装命令：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5857d4f5bf01eaa9c3b691dd4770484/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab8c669a1bd8f201f2d24657934ef58f/" rel="bookmark">
			使用el-upload上传文件时，对文件名进行校验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 概要使用before-upload钩子函数实现逻辑调用函数关联正则小结 概要 通常在日常项目开发过程中,会用到文件上传的功能，此时，会要求什么样的文件名可以上传什么样的不能上传，虽然说后端也可以做校验，如果在多文件上传的时候，会出现客户多次上传的文件因为一个文件名称的不规范导致所有的文件都无法上传，因此在上传的时候，需要对上传文件的文件名进行校验并提示。
例如：
使用before-upload钩子函数 注意：如果要使用upload钩子函数时，需要查看项目中有没要用到:auto-upload这个属性，如果有，此时使用before-upload是不会生效的，需要在on-change事件中看到上传的文件，建议在before-upload对文件进行校验。
实现逻辑 // 以下代码是上传文件前对文件名称的校验。 const beforeFileUpload = async (rawFile) =&gt; { const fileName = rawFile.name; const regex = /^\[(.+)\](.+)-(.+)\s+(.+)/; // 这里的正则可以根据自己项目中的对文件命名的规范来给 if(!regex.test(fileName)) { if(!errorMessageDiaplayed.value) { global.$message.error('错误提示') } return false	} return true } 调用函数关联正则 提示：这里是关键性代码的细节
const FileChange: UploadProps['onChange'] = async (uploadFile: any) =&gt; { errorMessageDisplayed.value = false; const isValidFile = await beforeFileUpload(uploadFile.raw) if(isValidFile) { fileList.value.push(uploadFile.raw) fileList.value = fileList.value &amp;&amp; fileList.value.map((item : any) =&gt; { if(item.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab8c669a1bd8f201f2d24657934ef58f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46f42e5d74d59634a61adff544f66559/" rel="bookmark">
			vue&#43;uniapp登录密码轻松展示隐藏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		登录页面：点击小眼睛图标隐藏和显示密码
直接上代码
view class="input-item flex align-center"&gt; &lt;u-input maxlength="20" :type="pwdFlag == true ? 'password' : 'text'" v-model="loginForm.password" placeholder="请输入密码" prefixIcon="lock-fill" prefixIconStyle="font-size: 22px;color: #999" style="border: none;"&gt; &lt;template slot="suffix"&gt; &lt;u-icon :name="pwdFlag == true ? 'eye-off' : 'eye-fill'" color="#999" size="28" @click="pwdFlag = !pwdFlag"&gt;&lt;/u-icon&gt; &lt;/template&gt; &lt;/u-input&gt; &lt;/view&gt; data() { return { pwdFlag: true, }; }, 注意修改u-input的样式时候：：v-deep .u-input修改
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0c8b4bf20d6cd8bfd4979358ee7c5a3/" rel="bookmark">
			【C&#43;&#43;11】final与override
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在了解C++11中的final/override之前，需要先了解一下C++中关于重载的概念。简单地说，一个类A中声明的虚函数fun在其派生类B中被再次定义，且B中的函数fun跟A中fun的原型一样（函数名、参数列表等一样），那么我们就称B重载了A的fun函数。对于任何B类型的变量，调用成员函数fun都是调用了B重载的版本。而如果同时有A的派生类C，却并没有重载A的fun函数，那么调用成员函数fun则会调用A中的版本。这在C++中构成多态。
其实上面这段话说的重载是通俗说法，上面所说的虚函数重载实际叫重写或覆盖，它们函数名、参数列表、返回值都相同。重载是在同一个作用域中的两个函数，它们函数名相同，参数列表不同，返回值可以相同可以不同。
假如类A和类B都是程序员1写的，类C由程序员2写。类B派生于类A，且基类B中有一个重写类A的fun函数，而程序员2并不知道，那么当他在写派生类C时也写了一个fun函数（派生类重写不用加virtual），那么继承于基类B的虚函数表（函数指针数组）就会修改关于fun函数的地址从原来B::fun变为C::fun，这就构成了重写。
程序员1想让后面所有的程序员都使用他写的类B中的fun函数，形成统一的标准（比如统一打印函数格式）不希望B的派生类的fun函数被重写。用一个生动的说法就是，到了类B这，fun函数说我累了不想再漂泊了，就到这吧。给fun函数后面加上final关键字，类C就不能重写或覆盖继承于类B的fun函数了。
所以final关键字的作用就是使派生类不可覆盖final修饰的的虚函数。当派生类对基类的加了final的虚函数进行了重载则会造成编译错误。从接口派生的角度而言，final可以在派生过程中任意的阻止一个接口的可重载性，这就给面向对象的程序员带来了更大的控制力。
基类虚函数加virtual关键字但是派生类函数重写时却并不用加vitual，这是编译器做的优化。但是这样却带来了一些阅读上的困难，如果继承结构较长，派生类的编写者会遇到信息分散、难以阅读的问题。在C++11中为了帮助程序员写继承结构复杂的类型，引入了虚函数描述符override，如果派生类在虚函数声明时使用了override描述符，那么该函数必须重写基类中的同名函数，否则代码无法通过编译。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f522980e8a2532cfc5bca36a17777525/" rel="bookmark">
			查看服务所在目录属于哪个文件系统，以及剩余磁盘空间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		命令: dh -lh 目录 如 dh -lh /home
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ee03ee994eb49fe13abf94c9be78efc/" rel="bookmark">
			如何用六步教会你使用python爬虫爬取数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 用python的爬虫爬取数据真的很简单，只要掌握这六步就好，也不复杂。以前还以为爬虫很难，结果一上手，从初学到把东西爬下来，一个小时都不到就解决了。
python爬出六部曲 第一步：安装requests库和BeautifulSoup库： 在程序中两个库的书写是这样的：
import` `requests``from` `bs4 ``import` `BeautifulSoup 由于我使用的是pycharm进行的python编程。所以我就讲讲在pycharm上安装这两个库的方法。在主页面文件选项下，找到设置。进一步找到项目解释器。之后在所选框中，点击软件包上的+号就可以进行查询插件安装了。有过编译器插件安装的hxd估计会比较好入手。具体情况就如下图所示。
第二步：获取爬虫所需的header和cookie： 我写了一个爬取微博热搜的爬虫程序，这里就直接以它为例吧。获取header和cookie是一个爬虫程序必须的，它直接决定了爬虫程序能不能准确的找到网页位置进行爬取。
首先进入微博热搜的页面，按下F12，就会出现网页的js语言设计部分。如下图所示。找到网页上的Network部分。然后按下ctrl+R刷新页面。如果，进行就有文件信息，就不用刷新了，当然刷新了也没啥问题。然后，我们浏览Name这部分，找到我们想要爬取的文件，鼠标右键，选择copy，复制下网页的URL。就如下图所示。
复制好URL后，我们就进入一个网页Convert curl commands to code。这个网页可以根据你复制的URL，自动生成header和cookie，如下图。生成的header和cookie，直接复制走就行，粘贴到程序中。
#爬虫头数据``cookies ``=` `{`` ``'SINAGLOBAL'``: ``'6797875236621.702.1603159218040'``,`` ``'SUB'``: ``'_2AkMXbqMSf8NxqwJRmfkTzmnhboh1ygvEieKhMlLJJRMxHRl-yT9jqmg8tRB6PO6N_Rc_2FhPeZF2iThYO9DfkLUGpv4V'``,`` ``'SUBP'``: ``'0033WrSXqPxfM72-Ws9jqgMF55529P9D9Wh-nU-QNDs1Fu27p6nmwwiJ'``,`` ``'_s_tentry'``: ``'www.baidu.com'``,`` ``'UOR'``: ``'www.hfut.edu.cn,widget.weibo.com,www.baidu.com'``,`` ``'Apache'``: ``'7782025452543.054.1635925669528'``,`` ``'ULV'``: ``'1635925669554:15:1:1:7782025452543.054.1635925669528:1627316870256'``,``}``headers ``=` `{`` ``'Connection'``: ``'keep-alive'``,`` ``'Cache-Control'``: ``'max-age=0'``,`` ``'Upgrade-Insecure-Requests'``: ``'1'``,`` ``'User-Agent'``: ``'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36 SLBrowser/7.0.0.6241 SLBChan/25'``,`` ``'Accept'``: ``'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9'``,`` ``'Sec-Fetch-Site'``: ``'cross-site'``,`` ``'Sec-Fetch-Mode'``: ``'navigate'``,`` ``'Sec-Fetch-User'``: ``'?1'``,`` ``'Sec-Fetch-Dest'``: ``'document'``,`` ``'Accept-Language'``: ``'zh-CN,zh;q=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ee03ee994eb49fe13abf94c9be78efc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e5faa93d9cd2c2313a760f5e86ab581/" rel="bookmark">
			Linux 防火墙firewall-cmd配置命令大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux 防火墙firewall-cmd配置命令大全 启动CentOS/RHEL 7后，防火墙规则设置由firewalld服务进程默认管理。
一个叫做firewall-cmd的命令行客户端支持和这个守护进程通信以永久修改防火墙规则。
查看状态
firewall-cmd --state 查看防火墙所有信息
firewall-cmd --list-all 查看已经开放的端口：
firewall-cmd --list-ports 如要查询是否开启80端口
firewall-cmd --query-port=80/tcp 永久打开一个新端口（如TCP/8080）
如果不使用“–permanent”标记，把么防火墙规则在重启后会失效
firewall-cmd --permanent --zone=public --add-port=8080/tcp 命令含义：
–zone #作用域 –add-port=8080/tcp #添加端口，格式为：端口/通讯协议 –permanent #永久生效，没有此参数重启后失效 开放多个端口
firewall-cmd --permanent --zone=public --add-port=80-90/tcp 移除一个端口
firewall-cmd --permanent --zone=public --remove-port=8080/tcp 重新加载防火墙
添加或删除开发端口必须重新加载才会生效
firewall-cmd --reload firewall的基本启动/停止/重启命令
systemctl stop firewalld #停止firewall systemctl start firewalld #启动firewall systemctl restart firewalld #重启firewall systemctl enable firewalld #开启firewall开机启动 systemctl disable firewalld #禁止firewall开机启动 查看本机已经启用的监听端口
netstat -ant #CentOS7以下使用 ss -ant	#7及以上使用ss 常用命令总结
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e5faa93d9cd2c2313a760f5e86ab581/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3e264be436a6a2c1cdb8a4a025ae367/" rel="bookmark">
			软件测试可以发现所有Bug吗，软件测评机构有哪些优势?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件产品的质量要想得到保障，软件测试这项工作必不可少，主要是在测试过程中提前发现问题，用来促进鉴定软件的正确性、完整性、安全性和质量的过程。那软件测试可以发现所有bug吗?
我们要明确的是，软件测试是一项非常重要的工作，但是并不能保证发现所有的Bug。软件是由人编写的，而人是会犯错误的，所以即使经过了严格的测试，仍然有可能发现不了一些潜在的问题。此外，软件测试是一个持续演进的过程，随着软件的不断迭代更新和用户的不断反馈，新的Bug可能会不断出现。
由于很多软件企业更注重产品开发，因此会将测试工作交给外包的软件测评机构进行，主要有以下优势：
1、拥有经验丰富的测试团队和完善的测试流程。
测试团队具备广泛的软件测试技能和行业知识，能够从多个角度对软件进行全面的测试。测试流程严谨而规范，从测试需求分析到测试用例设计、执行和Bug跟踪，每个环节都有明确的步骤和标准。
2、注重与客户的合作和沟通。与客户保持密切的联系，及时了解软件的需求和变更，以便在测试过程中能够重点关注相关功能和特性。通过与客户的合作，更好地理解软件的使用场景和用户需求，从而更加准确地进行测试和评估。
3、提供专业的测试报告和评估结果。在测试完成后，测试团队会对测试过程中发现的问题进行总结和整理，生成清晰、详细的测试报告。这些报告将包括Bug的类型、严重程度和解决建议，帮助客户全面了解软件质量和改进方向。
市面上的软件测评机构有许多，但合适且靠谱的需要慎重选择。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edfa10c51a478ffb5b627cd9f54399c0/" rel="bookmark">
			Air001外部中断/事件控制器功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Air001外部中断/事件控制器 ✨对于外部中断，一般单片机基本标配的硬件功能，使用方法也没有什么特别的地方，对于事件控制器，用于停机模式下唤醒单片机功能，但是使用起来很简单,只需配置其引脚模式即可。 🔖目前只看到该芯片的数据手册，没有看到参考手册，也没法具体了解其机制原理。🔰Stop mode(停机模式)：该模式下 SRAM 和寄存器的内容保持，HSI 和 HSE 关闭，VDD 域下大部分模块的时钟都被停掉。GPIO，COMP output，LPTIM 可以唤醒 stop 模式。
注： 在进入停机式时，IWDG和对应的时钟不会被停止。 📓外部中断/事件控制器(EXTI)数据手册描述语： 外部中断/事件控制器包含19个边沿检测器，用于产生中断/事件请求。每个中断线都可以独立地配置它的触发事件(上升沿或下降沿或双边沿)，并能够单独地被屏蔽；有一个挂起寄存器维持所有中断请求的状态。18个通用I/O口连接到16个外部中断线。 👉🏻外部中断注意事项 ⚡在外部中断触发后，需要在中断函数中，再次使能对应引脚的外部中断，否则无法响应第二次中断。这和STM32有所差异。 🌻配置外部中断 /** * @brief 配置EXTI * @param 无 * @retval 无 */ static void APP_ConfigureExti(void) { /* 配置引脚 */ GPIO_InitTypeDef GPIO_InitStruct; __HAL_RCC_GPIOA_CLK_ENABLE(); /* 使能GPIOA时钟 */ GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING; /* GPIO模式为下降沿中断 */ GPIO_InitStruct.Pull = GPIO_PULLUP; /* 上拉 */ GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH; /* 速度为高速 */ GPIO_InitStruct.Pin = GPIO_PIN_2;//中断引脚 HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct); /* 使能EXTI中断 */ HAL_NVIC_EnableIRQ(EXTI2_3_IRQn); /* 配置中断优先级 */ HAL_NVIC_SetPriority(EXTI2_3_IRQn, 0, 0); } /*EXTI中断函数*/ void EXTI2_3_IRQHandler(void) { /* LED翻转 */ HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_1); HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_2);//重新开启外部中断 //	printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edfa10c51a478ffb5b627cd9f54399c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46695583df6ee365c00af068ff18d153/" rel="bookmark">
			记录遇到的前端面试题，欢迎指正
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		css 1.隐藏元素的方式 转自将页面元素隐藏的10种方法 display:none
display属性用于设置页面元素的显示方式，能够控制元素的显示或者隐藏，当他的值被设置为none时，就会隐藏对应的元素，使其不可见。
这种方法是最常用的隐藏元素的方法，可以让元素在网页中完全消失，不会占据页面上的任何空间，用户无法看到或进行交互。
但是这样也会导致元素脱离文档流，可能会影响其他元素的布局。visibility:hidden
visibility舒缓型是专门用于控制元素的显示和隐藏，当它的值设置为hidden后，也会将元素隐藏。
但与display不同的地方在于，此时元素仍会占据页面上的空间，只是在视觉上不可见，显示为空区域（所占区域为元素的大小）。
这种方式也是无法进行元素的响应事件监听和交互状态，通常应用于需要隐藏但仍需要占据空间的元素，如占位符、提示信息等opacity:0
opacity属性用于控制元素的透明度，取值范围：0-1，0表示完全透明，1表示不透明
当我们讲元素的opacity属性设置为0时，该元素将会变为不可见状态，不过它仍会占据页面上的空间。
这种方式隐藏的元素，都是视觉上不可见，和visibility:hidden比较类似
但不同的地方在于：opacity：0 设置元素不可见以后，用户仍然能够与该元素进行交互，而visibility：hidden则不行position
position属性用于控制元素的定位方式，可以将元素在页面的不同位置进行定位，有多个取值，也是css中非常重要的属性，但我们这里只讨论如何隐藏元素。
当position取值相对定位或者绝对定位时，给定（left/top/right/bottom）四个方向上的任意一个较大的值（或负值），都能将元素设置到屏幕之外，达到不可见的状态。
在使用上，相对定位和绝对定位有一定的区别。
绝对定位的元素会脱离文档流，整个从视觉上小时，效果上与display:none相似。
而相对定位则只是将元素移出，在当前位置仍然会占据一定的空间，效果上与visibility:hidden较相似。
但使用的定位的方式使元素不可见，都无法再与元素进行交互操作。
在绝对定位时还可以通过z-index属性将元素的层级调低，让它被其他元素遮挡，达到一定的隐藏效果clip-path:circle(0%)
clip-path属性，允许用不同的剪切方式创建元素的可显示区域，区域内的内容可以展示，区域外的内容则隐藏。根据它的特点，如果将元素的所有内容都设置到显示区域外，则元素就自动隐藏了，达到不可见的状态，而要实现这点，只需要将剪切区域设置为0，有多个形状可以实现 .box { clip-path: circle(0%); clip-path: inset(50%); clip-path: polygon(0 0); } 这种方式隐藏的元素，虽然不可见，但仍然会占据自身大小的空间，效果上与 visibility:hidden 相似。并且也不能响应事件监听和各种交互状态。
filter:blur(500px)
filter 属性是CSS3开始提供的，用于对页面元素设置各种滤镜效果，有大概十多个各种不同的滤镜值可以设置，我们这里使用 blur 模糊效果来达到隐藏页面元素的效果。 只需要将 blur() 值设置为一个较大的值，元素将模糊到无法显示的地方，如值大于400：
.elem { filter: blur(500px); } 通过以上代码，就能将元素进行隐藏了，他的效果与使用 opacity: 0 一样，元素虽不可见，但仍占据空间，并且能够响应事件和交互状态。
注意：filter:opacity(0) 透明滤镜与 opacity: 0 也一样。
HTML Element 的 hidden 属性
通过设置页面元素(Element)的 hidden 属性，也能够将元素进行隐藏，它达到的效果与 display:none 几乎一样，元素脱离文档流、不可见，不占用空间，无法响应事件和用户交互等。 &lt;div hidden&gt;这个元素将被隐藏，不占用空间，无法交互。&lt;/div&gt; 以上方式，针对的页面元素，是不区分块状元素和行内元素，都能够达到隐藏效果，下面还有几种方式，可能针对特定的元素才起作用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46695583df6ee365c00af068ff18d153/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35bcdaf606a3a5f37251409622c07a6e/" rel="bookmark">
			前端实现单点登录（SSO）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单点登录是什么？你是怎么理解的？单点登录是如何实现的 普通登录 提到单点登录，首先可以想到传统登录，通过登录页面根据用户名查询用户信息，判断密码是否正确，正确则将用户信息写到session，访问的时候通过从session中获取用户信息，判断是否已登录，登录则允许访问。
普通登录的缺点 由于session不能共享，服务越来越多，并且还服务还搭建集群，导致每访问另外一个服务都需要重新登录。
单点登录
单点登录有个简称是sso，它是一个功能可以控制多个有联系的系统操作，简单地理解为通过单点登录可以让用户只需要登录一次软件或者系统，那么同系统下的平台都可以免去再次注册、验证、访问权限的麻烦程序，通俗易懂的理解为一次性登录也可以一次性下线。
前端需要知道的单点登录概述：
1、一个系统登录流程：用户进入系统——未登录——跳转登录界面——用户名和密码发送——服务器端验证后，设置一个cookie发送到浏览器，设置一个session存放在服务器——用户再次请求（带上cookie）——服务器验证cookie和session匹配后，就可以进行业务了。
2、多个系统登录：如果一个大公司有很多系统，a.seafile.com, b.seafile.com,c.seafile.com。这些系统都需要登录，如果用户在不同系统间登录需要多次输入密码，用户体验很不好。所以使用 SSO (single sign on) 单点登录实现。
3、相同域名，不同子域名下的单点登录：在浏览器端，根据同源策略，不同子域名的cookie不能共享。所以设置SSO的域名为根域名。SSO登录验证后，子域名可以访问根域名的 cookie，即可完成校验。在服务器端，可以设置多个子域名session共享（Spring-session）
4、不同域名下的单点登录：CAS流程：用户登录子系统时未登录，跳转到 SSO 登录界面，成功登录后，SSO 生成一个 ST （service ticket ）。用户登录不同的域名时，都会跳转到 SSO，然后 SSO 带着 ST 返回到不同的子域名，子域名中发出请求验证 ST 的正确性（防止篡改请求）。验证通过后即可完成不同的业务。
单点登录需求 在项目初期，公司中使用的系统很少，通常一个或者两个，每个系统都有自己的登录系统，用户用自己的账号登录，很方便。
但随着公司的不断发展，用到的系统随之增多，用户在操作不同的系统时，需要多次登录，而且每个系统的账号都不一样，这对于用户来说，是很不好的体验。于是，就想到是不是可以在一个系统登录，其他系统就不用登录了呢？这就是单点登录要解决的问题。
单点登录英文全称Single Sign On，简称就是SSO。它的解释是：在多个应用系统中，只需要登录一次，就可以访问其他相互信任的应用系统。
单点登录（Single Sign On），简称为 SSO，是比较流行的企业业务整合的解决方案之一。SSO的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。
如图所示，图中有4个系统，分别是Application1、Application2、Application3、和SSO。Application1、Application2、Application3没有登录模块，而SSO只有登录模块，没有其他的业务模块，当Application1、Application2、Application3需要登录时，将跳到SSO系统，SSO系统完成登录，其他的应用系统也就随之登录了。这完全符合我们对单点登录（SSO）的定义。
SSO 机制实现流程 用户首次访问时，需要在认证中心登录：
用户访问网站 a.com 下的 pageA 页面。
由于没有登录，则会重定向到认证中心，并带上回调地址 www.sso.com?return_uri=a.com/pageA，以便登录后…[1]
用户在认证中心输入账号密码，提交登录。
认证中心验证账号密码有效，然后重定向 a.com?ticket=123 带上授权码 ticket，并将认证中心 sso.com 的登录态写入 Cookie。
在 a.com 服务器中，拿着 ticket 向认证中心确认，授权码 ticket 真实有效。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35bcdaf606a3a5f37251409622c07a6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d0ec87eff0e75f18a183f71a46505c7/" rel="bookmark">
			Unity塔防游戏的制作与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、游戏场景的搭建
首先，我们需要创建一个新的Unity场景，并将场景设置为2D模式。然后，我们需要导入一些必要的素材，如地图、塔、怪物、子弹等。我们可以从Unity Asset Store中下载这些素材，或者自己制作。
对啦！这里有个游戏开发交流小组里面聚集了一帮热爱学习游戏的零基础小白，也有一些正在从事游戏开发的技术大佬，欢迎你来交流学习。 接下来，我们需要将地图和塔防元素放置在场景中。我们可以使用Unity的2D Tilemap工具来创建地图，并使用Unity的Sprite Renderer组件将塔和怪物放置在地图上。我们还需要为塔和怪物添加一些基本的属性，如生命值、攻击力等。
二、塔防游戏的逻辑实现
在游戏中，我们需要实现以下逻辑：
建造塔：当玩家点击地图上的空地时，会弹出一个塔的列表供玩家选择。玩家可以选择一种塔并将其放置在空地上。攻击怪物：当怪物进入塔的攻击范围内时，塔会对怪物进行攻击。当怪物的生命值降为0时，怪物会死亡并掉落金币。收集金币：当怪物死亡时，会掉落一定数量的金币。玩家可以通过收集这些金币来建造更多的塔。游戏结束：当怪物到达地图的另一端时，玩家失败。当玩家成功击败所有的怪物时，玩家胜利。 三、代码实现
下面是Unity塔防游戏的代码实现。这里只给出了主要的代码片段，完整的代码可以在GitHub上找到。
建造塔 当玩家点击地图上的空地时，会弹出一个塔的列表供玩家选择。玩家可以选择一种塔并将其放置在空地上。
一、游戏场景的搭建
二、塔防游戏的逻辑实现
在塔防游戏中，玩家需要建造塔来防御怪物的进攻。当玩家建造塔时，会消耗一定数量的金币。玩家可以通过杀死怪物来获得金币，从而建造更多的塔。
当怪物进入塔的攻击范围内时，塔会对怪物进行攻击。当怪物的生命值降为0时，怪物会死亡并掉落金币。玩家可以通过收集这些金币来建造更多的塔。
在游戏中，我们需要实现以下逻辑：
建造塔：当玩家点击地图上的空地时，会弹出一个塔的列表供玩家选择。玩家可以选择一种塔并将其放置在空地上。攻击怪物：当怪物进入塔的攻击范围内时，塔会对怪物进行攻击。当怪物的生命值降为0时，怪物会死亡并掉落金币。收集金币：当怪物死亡时，会掉落一定数量的金币。玩家可以通过收集这些金币来建造更多的塔。游戏结束：当怪物到达地图的另一端时，玩家失败。当玩家成功击败所有的怪物时，玩家胜利。 三、代码实现
下面是Unity塔防游戏的代码实现。这里只给出了主要的代码片段，完整的代码可以在GitHub上找到。
建造塔 当玩家点击地图上的空地时，会弹出一个塔的列表供玩家选择。玩家可以选择一种塔并将其放置在空地上。
public class TowerBuilder : MonoBehaviour { public GameObject[] towerPrefabs; public GameObject[] towerIcons; public int[] towerCosts; private GameObject currentIcon; private GameObject currentTower; private bool isBuilding = false; private int currentCost = 0; private void Start() { currentIcon = Instantiate(towerIcons[0], transform); currentIcon.SetActive(false); } private void Update() { if (isBuilding) { Vector3 mousePos = Camera.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d0ec87eff0e75f18a183f71a46505c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccfbeea1f372e37abf753780439d9e70/" rel="bookmark">
			SpringBoot集成腾讯云COS对象存储
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 腾讯云COS对象存储容量包是一种云存储服务，它可以帮助用户存储和管理海量数据。这种服务的主要作用是解决数据存储和管理方面的问题，使得用户可以更加方便地进行数据备份、共享和传输等操作。
一、准备资料 需要现在腾讯云中获取以下资料 密钥id密钥key所属区域存储桶名称COS存储文件夹（自己创建的，方便管理）访问地址 二、yml配置文件 # 腾讯云COS cos: # 密钥id secretId: ***** # 密钥key secretKey: ***** # 所属区域 bucket: ap-nanjing # 存储桶名称 bucketName: *-1320852402 # COS存储文件夹 folder: /自定义/ # 访问地址 webUrl: https://*.cos.ap-nanjing.myqcloud.com 三、创建实体映射 代码如下（示例）：
package com.ruoyi.common.config; import com.qcloud.cos.COSClient; import com.qcloud.cos.ClientConfig; import com.qcloud.cos.auth.BasicCOSCredentials; import com.qcloud.cos.auth.COSCredentials; import com.qcloud.cos.region.Region; import lombok.Data; import lombok.extern.slf4j.Slf4j; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.context.annotation.Bean; import org.springframework.stereotype.Component; @Component @Data @ConfigurationProperties(prefix = "cos") public class CosConfig { /** 项目名称 */ private String secretId; /** 版本 */ private String secretKey; /** 所属区域 */ private String bucket; /** 存储桶名称 */ private String bucketName; /** COS存储文件夹 */ private String folder; /** 访问路径 */ private String webUrl; } 三、上传工具类 代码如下（示例）：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccfbeea1f372e37abf753780439d9e70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58958cd4dbf17a5a1dc13c201e8141e7/" rel="bookmark">
			SVN文件的红、绿色图标消失
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述：文件夹SVN图标不显示，不知道仓库中的文件是否改动过，十分不方便。
环境：Windows 11
原本文件夹是显示有图标的(如下)，某一天突然没有了 。
试了网上的两种方法均失败：
方法一(失败)： 1、将SVN的Settings——Icon Overlays——Status cache——设置为Shell
2、Settings——Icon Overlays——Icon Set——设置为Win10，点击应用点确定。重新打开仓库的文件夹，还是无图标。
方法二(失败)： 1、快捷键Win + R，输入regedit找到：
\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\ShellIconOverlayIdentifiers
2、把Tortoise相关的几个都重命名，在前面加好几个空格(比排在他们前面的文件夹的空格多)，F5刷新，让它们排在ShellIconOverlayIdentifiers下最前面。这里原先最前面排的是OneDrive的好几个文件夹，重名名Tortoise相关的虽然排到他们前面了但还是不行，我把OneDrive相关的删除了也不行。
3、打开任务管理器，搜索资源管理器，右击重启。重新打开仓库的文件夹，还是无图标。
最后成功办法是： 直接卸载微软的OneDrive！！！然后重启Windows资源管理器。最后图标终于回来了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fa44901975b73a3ca90b54a8a541f14/" rel="bookmark">
			聊一聊 Spring 6 面向切面AOP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java全能学习+面试指南：https://javaxiaobear.cn
今天我们一起看看Spring AOP的相关操作！
1、场景模拟 搭建子模块：spring6-aop
1.1、声明接口 声明计算器接口Calculator，包含加减乘除的抽象方法
public interface Calculator { int add(int i, int j); int sub(int i, int j); int mul(int i, int j); int div(int i, int j); } 1.2、创建实现类 public class CalculatorImpl implements Calculator { @Override public int add(int i, int j) { int result = i + j; System.out.println("方法内部 result = " + result); return result; } @Override public int sub(int i, int j) { int result = i - j; System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9fa44901975b73a3ca90b54a8a541f14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f84010339c4e871b4bd74e3d1a4ba9cc/" rel="bookmark">
			记录：git切换分支丢失本地代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		情况：idea的ide，代码没有commit到本地的情况下，不小心切换分支，导致切换回来的时候写好的代码全部丢失。
双击shift搜索local history的方式找到了代码，回滚，但是发现仍然有一部分代码没有“找回来”。
后来发现右键点击工程，也会有一个local history，在这里面同样有代码的历史记录，通过在这里回滚，成功把所有的代码全部找回来了。
分析：我认为第一次双击shift找到的local history弹出来的是git的history，所以这里还是建立在git帮我们保存的代码记录
但是第二步的右击工程找到的local history是idea的额外的功能，相当于idea也在后台帮我们备份了《本地的》代码的历史记录。
idea这功能真是yyds，帮了我大忙
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64f55603abff2c86567d3b8df2a6165f/" rel="bookmark">
			运维大数据平台的建设与实践探索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着企业数字化转型的推进，运维管理面临着前所未有的挑战和机遇。为应对日益复杂且严峻的挑战，数字免疫系统和智能运维等概念应运而生。数字免疫系统和智能运维作为新兴技术，正引领着运维管理的新趋势。数字免疫系统和智能运维都借助大数据运维平台，实现数据驱动的运维策略，实时监控分析系统状态，自动识别异常行为、威胁和攻击，提供智能决策和预防性维护建议，实现自我保护和自我修复等，从根本上提高了系统安全性、稳定性和可用性。本文主要探讨运维大数据平台的建设和实践方法，旨在帮助组织构建数字免疫系统，实现智能化运维。
**数字免疫(Digital Immune System)：**未来充满了不确定性，但企业仍然需要明确的推进战略目标和举措。Gartner 在最新的重要战略技术趋势中提出了“数字免疫系统”(如图1所示)的概念。“数字免疫系统”的概念最早是在上世纪90年代的时候被提出，当时指的是一套完全自动化的防病毒解决方案。但是今天的“数字免疫系统”指的是一套用来构建稳定系统的软件设计、开发、运营和分析的一系列技术和实践。数字免疫系统保护应用程序和服务，使它们更具弹性和健壮性，以便从故障中能快速恢复，降低连续性风险。Gartner 预计，到 2025 年，投资构建数字免疫力的组织将通过减少 80% 的停机时间来提高客户满意度。
图1：数字免疫系统 **智能运维(AIOps)：**智能运维(如图2所示)是基于人工智能和大数据等高级分析技术，采用机器学习和数据科学来解决IT运维领域问题的应用，实现运维管理的自动化、智能化。智能运维通过对系统中产生的大量可观测性数据进行建模和分析，识别出系统中的问题点并进行响应，提高运维的效率和准确性，提高系统的稳定性和可靠性。
图2：智能运维 数字免疫系统与智能运维是寻求系统稳定性和故障恢复能力的两个关键要素，有着密切的关系(如图3所示)，共同致力于减缓故障、保障应用程序和服务的连续性，并确保遇到问题时实现快速恢复。二者的结合在构建和维护高效、稳定并具有自愈能力的系统方面发挥着重要作用。数字免疫系统作为智能运维的核心组件之一，有助于建立自动化、实时且富有反应力的运维策略。数字免疫系统强调的是软件设计的鲁棒性、弹性和恢复能力，而智能运维通过人工智能、大数据分析及场景感知等技术手段来提高整个 IT 系统的管理效率和运行水平。
图3：数字免疫和智能运维的关系 数字免疫系统和智能运维都依赖于运维大数据平台和数据分析，通过收集和分析大量运行数据，我们能更好地掌握系统状况，可以对潜在的安全威胁和运维问题做出快速、准确的预测和响应，并提炼出最佳实践，不断完善数字免疫系统和运维策略，提高系统稳定性和安全性。接下来，我们将深入分析各场景和运维数据平台之间的关系。
SRE
它的核心思路是通过引入软件工程的方法和思维模式，实现对系统运行过程的优化和预测故障。在运维大数据平台中，这意味着我们需要收集关键业务指标（如：延迟、错误率、吞吐量等）的数据，并通过分析这些数据，找出潜在风险和故障的根源。可以说，大数据分析能力是SRE实现运维自动化和高效解决问题的基础。
混沌工程
这是一种通过主动注入故障，模拟系统失效来提高系统抵抗力的实践。运维大数据平台可以实时监控模拟实验的结果，分析故障注入对系统性能的影响。通过这些数据，开发者和运维团队能更好地了解系统的弱点和容错能力，并提出相应的优化措施。
AI增强测试
利用人工智能技术对软件进行测试，从而提高测试覆盖率和准确性。运维大数据平台可以为AI测试提供海量的数据来源，以便AI能更好地理解系统行为和正常的性能水平，并从中发现潜在的风险。数据分析结果还可为AI训练模型提供指导，实现测试效果的持续优化。
可观测性
是理解系统内部状态和性能的关键因素。运维大数据平台通过汇总日志、指标、追踪等多种数据源，提供了一种全面的系统状态视角。这样，团队就能发现异常行为、确定故障原因，从而快速响应和解决问题。
自动修复
是指在检测到故障后，自动触发相应的修复措施。运维大数据平台可以实时监测系统状态，当检测到异常或故障时，自动触发相应的预案或修复策略。通过对大量数据进行历史分析，运维团队还能持续优化自动修复的策略，以降低系统故障对业务的影响。
应用程序供应链安全
关注整个软件开发、部署、运维过程中的安全性。运维大数据平台可以从多个维度（如：代码、环境、配置等）收集数据，实时监测潜在的安全风险。通过大数据分析，我们能够更及时、更准确地识别并修复潜在威胁，保证整个应用程序供应链的安全性。
智能运维
智能运维概念提出后，行业对运维内涵的理解也在发生变化，运维的边界由服务于IT拓展到服务于业务，运维的定位也由成本中心转向服务中心，智能运维演进的过程，更是IT运维向运营演进的过程。过去的运维是小数据，每一个运维模块都是一个数据孤岛，仅能满足传统运维的使用场景。而发展至今我们所关注的“新运维”，需要基于完整的大数据、AI算法来提供全栈式运维，面向泛运维甚至涵盖非运维的场景。
通过以上分析来看，不管是数字免疫场景还是智能运维场景都需要全面的可观测性数据，需要智能运维大数据平台来实现数据的拉通、整合和赋能，实现跨领域的协同，实现复杂系统中高效、稳定、安全运维。
智能运维大数据平台(如图4所示)是一个集数据收集、存储、处理、分析、可视化、数据服务和应用于一体的一站式平台，用于支持数据中心系统的可观测性、数字免疫和智能运维需求。运维大数据平台可以帮助企业有效地管理海量的运维数据，洞察系统运行状况，发现潜在问题，为运维团队提供有价值的洞察和建议。
图4：智能运维大数据平台 运维领域不缺乏数据，但普遍缺乏对如何提取数据、整合数据并以可操作的方式使用数据的理解。现代智能运维大数据平台需要一种全新的、囊括所有形式的数据架构，能解决运维数据多样性、分散性、规模和复杂性不断增加带来的一系列问题。Data Fabric和DataOps是数据管理和数据操作的两个关键概念。Data Fabric可以被描述为一个数据整合和管理平台，它可以帮助企业自动化管理和操作数据，结合了数据目录、数据治理、数据集成、数据管道和数据编排等关键的数据管理技术，进而形成高效可靠的数据资产化体系和数据服务化能力。而DataOps是一种数据操作方法论，其目标是能够让数据开发更敏捷、高效。
数据源层及采集技术 运维领域的数据源层包含了各种系统、网络、应用的监控数据以及日志数据，对不同层次的各种数据进行采集与分析可以为系统维护、故障排查、性能优化和运营管理等方面提供重要参考依据。数据源的可靠性和实时性对运维决策影响极大，因此需要充分考虑数据源的选择、采集方式、协议、标准等方面的因素，确保数据的准确性和及时性。数据采集技术有很多种，例如代理收集器、日志转发器、SDK等。代理收集器通常部署在需要收集数据的主机上。这些代理会定期收集指标数据并发送给数据存储。其中可观测性数据采集技术是问题的关键。可观测数据的三大分类包括日志（记录）、指标（度量）和跟踪（请求调用链）。
• 日志（Log）: 系统和应用运行产生的记录，包含事件、事务和出错信息。常用的日志收集工具有Logstash、Fluentd等。
• 指标（Metrics）: 衡量系统及其各组件的性能、容量、状态等关键性能指标。常用指标收集工具包括Prometheus、Zabbix等。
• 链路追踪（Tracing）: 跟踪请求在分布式系统中的调用情况，帮助诊断性能问题。典型的链路追踪工具如Skywalking、Jaeger等。
数据汇聚层及数据摄取技术 数据汇聚层指收集、预处理和存储来自不同数据源的数据，以便进一步处理和分析。主要通过以下几种数据摄取技术来实现：
**• 批量摄取（Batch Ingestion）😗*用于定时按批次导入数据，适用于数据量较大且不要求实时处理的场景。常用工具包括Apache Nifi、Sqoop等。
• 实时摄取（Streaming Ingestion）: 用于侦听不同数据源生成的事件，并立即进行处理，满足实时分析及快速反应业务需求。典型的实时摄取工具包括Kafka、Apache Flink等。
• 数据同步（Data Synchronization）: 实时或定时将源数据同步到目标数据系统。例如，使用Apache Kafka Connect实现数据同步。
数据摄取工具通过不同的连接器、过滤器等插件，可以转换、清洗、归一化和丰富数据，提高数据质量。
数据存储整合及萃取技术 在现代运维数据环境中，我们通常会遇到来自不同来源、结构化和非结构化，离线的和实时的大量数据。为了统一管理这些数据并从中获取有价值的信息，我们需要采用一种高效、灵活的数据存储和处理架构。数据湖、数据仓库和实时数仓是这一架构的关键组成部分，它们共同支撑着数据分级加工、存储、整合和数据萃取的需求。数据湖是一种庞大的数据存储系统，允许将原始数据以任意格式存储起来，是非结构化、半结构化和结构化数据的集合地。数据湖典型解决方案有Hadoop、Hudi等。相比之下，数据仓库则是一种高度结构化的数据存储方式，支持快速查询报表以及多维分析，如何进行数据存储和数据组织，其核心是标准规范的数据仓库和数据模型建设，也就是说数据仓库是实现数据资产化的呈现载体。引入OneData数据萃取技术，确保数据一致性和准确性：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64f55603abff2c86567d3b8df2a6165f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d13efd940d96494a326ecbb43c23691e/" rel="bookmark">
			零基础写作小白，如何用ChatGPT快速提高写作水平？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		零基础写作小白，如何用ChatGPT快速提高写作水平？ 一·AI在写作领域的应用及前景二·ChatGPT的出现及其优势三·突破写作困境四·书籍推荐五·书籍亮点六·核心内容七·内容简介八·作者简介九·购买链接十·参与方式十一·往期赠书回顾 一·AI在写作领域的应用及前景 AI在写作领域的应用及前景是一个备受关注的话题。随着人工智能技术的不断发展，越来越多的企业和个人开始意识到AI在写作领域的巨大潜力。目前，许多知名的在线内容创作平台已经开始利用AI技术来辅助用户进行文章撰写和编辑。这些平台通过分析用户的写作风格、语言习惯和关键词使用情况，为用户提供个性化的写作建议和修改意见。此外，AI还可以自动生成文章标题、摘要和开头段落，大大提高了写作的效率和质量。
📌随着深度学习和自然语言处理技术的不断进步，AI将在以下几个方面发挥更大的作用：
智能写作助手：未来的写作工具将更加智能化，能够根据用户的需求和场景提供更加精准的写作建议和帮助。例如，AI可以分析用户的写作目标、受众群体和传播渠道，为用户量身定制合适的内容策略。自动翻译与校对：AI可以实现多语言之间的自动翻译和校对，大大提高了跨语言沟通的效率。这对于国际交流、跨国合作和全球市场开拓具有重要意义。内容生成与优化：AI可以通过学习大量的文本数据，生成高质量的原创内容。同时，AI还可以对已有的内容进行优化和改写，提高其可读性和吸引力。情感分析与舆情监控：AI可以对网络上的情感倾向进行分析，帮助企业和个人更好地了解用户需求和市场动态。此外，AI还可以实时监控舆论舆情，为企业公关和危机应对提供有力支持。 AI在写作领域的应用和前景令人充满期待。随着技术的不断进步，我们有理由相信，未来的写作工具将更加智能、高效和人性化，为个人和企业带来更广阔的发展空间。
二·ChatGPT的出现及其优势 ChatGPT的出现不仅为人们提供了一种全新的交互方式，也为写作领域带来了许多新的可能性。ChatGPT具有强大的语义理解和生成能力，能够理解自然语言的上下文和含义，并生成流畅、准确的回答和对话。这使得ChatGPT在问答系统、智能客服、自动回复等方面具有广泛的应用前景。与传统的问答系统相比，ChatGPT能够更好地理解用户的问题，并提供更加准确和全面的答案。它通过深度学习算法的训练，可以对大量的文本数据进行分析和学习，从而提高对各种问题的回答准确率。此外，ChatGPT还能够根据用户的反馈和历史记录进行个性化的优化和改进，提供更加精准和个性化的服务。ChatGPT的出现为人们的交互方式带来了革命性的变革，同时也为写作领域带来了更多的可能性。 三·突破写作困境 📌在写作的旅程中，我们都可能遇到各种挑战和困境。我们来深入探讨一些常见的写作困境。许多初学者在开始写作时，常常会面临找不到合适的主题或者缺乏创意的困扰。
那么，这些困境的原因是什么呢？首要的原因是缺乏实践。任何技能的提升都需要大量的练习，写作也不例外。如果我们很少有机会去实际写作，那么我们的技能就无法得到提升。其次，对写作的误解也是一个重要因素。许多人认为写作是一种天赋，而忽视了它其实是一项可以通过学习和实践来提升的技能。我们可以运用AI技术来解决这些写作问题。AI技术可以帮助我们进行深度的数据分析和理解，从而提供更有价值的写作建议和指导。例如，AI可以通过分析大量的优秀文章，来帮助我们理解什么样的文章更能吸引读者的注意力，什么样的文章更能表达作者的独特观点。此外，AI还可以通过分析我们的写作习惯和风格，来提供个性化的修改和改进建议。虽然写作是一个充满挑战的过程，但是只要我们能够深入理解自己的问题，并有效地利用AI技术来帮助我们解决问题，我们就一定能够突破写作困境，实现从小白到大神的蜕变。 四·书籍推荐 📖📖书籍名称：《AI写作高手：从零开始用ChatGPT学会写作》
五·书籍亮点 看清AI写作逻辑，讲透AI写作之道掌握写作黑科技，用AI引爆你的创作天赋从0到1，教你巧用AI学会写作突破写作困境，完成从写作小白到写作大神的蜕变 六·核心内容 1.·覆盖常用写作场景·：写小说、写故事、写文案、写策划、写新媒体文章、写广告卖点……
2.提高写作效率：输入有效提问关键词，一键生成所需内容，稍加修改便成一篇完整文章，将写作效率成百倍提升。
3.扩大素材积累：作为天生的超大型素材库，只有你想不到的素材，没有AI无法提供的素材，极大充实素材库，让写作不再无内容可写。
4.快速进行文本精修：文稿写完只完成了第一步，修改校对仍是重中之重。AI自带语句精修功能，可对文稿的内容、结构、标点符号等进行全方位的修订，让稿件修改更轻松、更精细。
七·内容简介 📌本书从写作与ChatGPT的基础知识讲起，结合创作者的实际写作经历与写作教学经历，重点介了用ChatGPT写作的基础技巧、进阶写作的方法、不同文体的写作方法、写作变现的秘诀，让读者系统地理解写作技巧与变现思路。
📌本书包括如下内容：
用ChatGPT重建写作思维、快速摘定选题、快速写出标题、高效收集索材、生成文章结构、写出优质文章、进行日常写作训练，以及用ChatGPT提升写作变现能力。
本书适合零基础想学习写作、想利用ChatGPT提高写作能力的读者阅读。
八·作者简介 📝无戒：作家、编剧、无戒学堂创始人、已出版作品《零基础新媒体写作指南》《38℃爱情》《余温》《云端》《自由职业者生存手册》。《余温》签约国外版权，英文版出版德国，日本，美国，新加坡等十余国家。
📝杜培培：无戒学堂联合创始人、千万级私域操盘手、自由撰稿人，已出版作品《自由职业者生存手册》
📝俞庚言：前知名青春文学杂志资深编辑，《花火》《鹿小姐》《萱小说》等知名杂志签约作者，长篇小说签约曾潇湘、QQ阅读等网站，喜马拉雅签约作者，广播剧累计人气2000W+。
九·购买链接 🎁🎁当当网链接：http://product.dangdang.com/29626355.html
🎁🎁京东的链接：https://item.jd.com/13856373.html
十·参与方式 🎁🎁
抽奖方式：评论区随机抽取2位小伙伴免费送出！！
参与方式：关注博主、点赞、收藏、评论区评论“人生苦短，我爱Python！”
（切记要点赞+收藏，否则抽奖无效，每个人最多评论三次！）
活动截止时间：2023-10-14 20:00:00
十一·往期赠书回顾 【山河赠书第一期】:《Python从入门到精通（微课精编版》三本
【山河赠书第二期】:《零基础学会Python编程（ChatGPT版》一本
【山河赠书第三期】:《Python机器学习:基于PyTorch和Scikit-Learn 》四本
【山河送书第四期】:《Python之光：Python编程入门与实战》五本
【山河送书第五期】:《码上行动：利用Python与ChatGPT高效搞定Excel数据分析》三本
【山河送书第六期】:《码上行动:零基础学会Python编程( ChatGPT版)》两本
【山河送书第七期】:《强化学习：原理与Python实战》五本
【山河送书第八期】:《用ChatGPT轻松玩转机器学习与深度学习》两本
【山河送书第九期】:《分布式统一大数据虚拟文件系统》五本
【山河送书第十期】：《Python 自动化办公应用大全》两本
【山河送书第十一期】：《考研书籍》五本
【山河送书第十二期】：《巧用ChatGPT快速搞定数据分析》两本
【山河送书第十三期】：《3D科研绘图与学术图表绘制入门到精通》两本
【山河送书第十四期】：《从零开始学公文写作（精装版）》 两本
🎁🎁文章末尾扫码加入粉丝群，不定期发放粉丝福利，各种专业书籍免费赠送！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0e2b97538a7ab7370349a37613b4e3c/" rel="bookmark">
			使用HBUILDERX将VUE-CLI3文件打包成APP，以及解决打包后的APP出现白屏的问题（简单示例）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HBuilderX官网，先去官网下载需要的工具
一、前期的准备工作
1、到vue项目中把rooter的模式由“history”改为“hash”，否则在本地真机调试时会出现白屏
（原因：如果使用history模式上线，必须要服务端在服务器上有对应的模式才能使用history（看上面链接），如果服务器上没有配置，可以先使用默认的hash；）
vue-router对mode的说明：
mode
类型: string
默认值: "hash" (浏览器环境) | "abstract" (Node.js 环境)
可选值: "hash" | "history" | "abstract"
配置路由模式:
hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器。
history: 依赖 HTML5 History API 和服务器配置。
abstract: 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式。
2、更改 vue.config.js文件，不修改的话，同样会出现白屏
（原因：app打开需要在服务端，而不是本地打开file模式下。测试时需要将根路径，改为相对路径）
publicPath: process.env.NODE_ENV === 'production' ? './' : '/' （vuecli3.0支持的是publicPath而不是baseUrl）
3、执行npm run build，正在根目录下生成dist文件
二、需要在HBuilderX中做的操作
1、文件 ----&gt;新建 ----&gt;项目
2、出现如下弹框，选择如下
3、将dist中生成的一下文件替换到新建的H5App中
4、更改 manifest.json的配置文件，因为是demo练习，我这里只进行了两个配置，其它需要配置的根据自己的项目需求完成
"statusbar" : {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0e2b97538a7ab7370349a37613b4e3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a61b15108f435d0f73b89ad809c21b5/" rel="bookmark">
			yolov8模型训练结果分析以及如何评估yolov8模型训练的效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		训练结果目录 目标检测性能指标 检测精度检测速度Precision，Recall，F1 score前传耗时IoU（Intersection over Union）每秒帧数 FPS（Frames Per Sencond）P-R curve浮点运算量（FLOPS）AP、mAP 检测速度 前传耗时(ms)：从输入一张图像到输出最终结果所消耗的时间，包括前处理耗时(如图像归一化)、网络前传耗时、后处理耗时(如非极大值抑制)每秒帧数FPS (Frames Per Second)： 每秒钟能处理的图像数量浮点运算量(FLOPS)：处理一-张图像所需要的浮点运算数量,跟具体软硬件没有关系，可以公平地比较不同算法之间的检测速度 一、 confusion_matrix_normalized.png和confusion_matrix.png 混淆矩阵是对分类问题预测结果的总结。使用计数值汇总正确和不正确预测的数量，并按每个类进行细分，显示了分类模型进行预测时会对哪一部分产生混淆。通过这个矩阵可以方便地看出机器是否将两个不同的类混淆了，把一个类错认成了另一个。
混淆矩阵不仅可以让我们直观的了解分类模型所犯的错误，更重要的是可以了解哪些错误类型正在发生，正是这种对结果的分解克服了仅使用分类准确率带来的局限性（总体到细分）。
混淆矩阵 行是预测类别（y轴），列是真实类别（x轴）
混淆矩阵以矩阵形式将数据集中的记录按照真实的类别与分类模型预测的类别判断两个标准进行汇总。其中矩阵的行表示真实值，矩阵的列表示预测值。
TP（True Positive）: 将正类预测为正类数 即正确预测，真实为0，预测也为0FN （False Negative）：将正类预测为负类 即错误预测，真实为0，预测为1FP（False Positive）：将负类预测为正类数 即错误预测， 真实为1，预测为0TN （True Negative）：将负类预测为负类数，即正确预测，真实为1，预测也为1 精确率和召回率的计算方法 精确率Precision=TP / (TP+FP), 在预测是Positive所有结果中，预测正确的比重召回率recall=TP / (TP+FN), 在真实值为Positive的所有结果中，预测正确的比重 二、F1_curve.png F1曲线，被定义为查准率和召回率的调和平均数
一些多分类问题的竞赛，常常将F1-score作为最终测评的方法。它是精确率和召回率的调和平均数，最大为1，其中1是最好，0是最差。
一般来说，置信度阈值（该样本被判定为某一类的概率阈值）较低的时候，很多置信度低的样本被认为是真，召回率高，精确率低；置信度阈值较高的时候，置信度高的样本才能被认为是真，类别检测的越准确，即精准率较大（只有confidence很大，才被判断是某一类别），所以前后两头的F1分数比较少。
这是300epoch得到的F1_curve，说明在置信度为0.4-0.6区间内得到比较好的F1分数
三、args.yaml 训练时的超参数
四、P_curve.png（单一类准确率） 准确率precision和置信度confidence的关系图
即置信度阈值 - 准确率曲线图
当判定概率超过置信度阈值时，各个类别识别的准确率。当置信度越大时，类别检测越准确，但是这样就有可能漏掉一些判定概率较低的真实样本。
意思就是，当我设置置信度为某一数值的时候，各个类别识别的准确率。可以看到，当置信度越大的时候，类别检测的越准确。这也很好理解，只有confidence很大，才被判断是某一类别。但也很好想到，这样的话，会漏检一些置信度低的类别。
五、R_curve.png（单一类找回率） 召回率recall和置信度confidence之间的关系，recall（真实为positive的准确率），即正样本有多少被找出来了（召回了多少）。
即置信度阈值 - 召回率曲线图
当置信度越小的时候，类别检测的越全面（不容易被漏掉，但容易误判）。
六、PR_curve.png（精确率和召回率的关系图） PR曲线体现精确率和召回率的关系。mAP 是 Mean Average Precision 的缩写，即 均值平均精度。可以看到：精度越高，召回率越低。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a61b15108f435d0f73b89ad809c21b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/932b5e18958e0432523eaa071f5ef27a/" rel="bookmark">
			el-input输入框校验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		禁止输入空格 方式1： 使用trim修饰符，它是v-model的一种修饰符，可以过滤掉内容左右两边的的空格代码
&lt;el-input v-model.trim="data"&gt;&lt;/el-input&gt; 方式2： 正则
/*keyup.native是回车事件*/ &lt;el-input type="test" @keyup.native="getDataListS" v-model="userNameInput&gt;&lt;/el-input&gt; export default{ data(){ return{ userNameInput:'', } }, methods:{ getDataListS(){ /*这个正则表示的是输入框前后不得有空格*/ let re=/^(?!\s+).*(?&lt;!\s)$/; if(re.test(this.userNameInput)==true){ /*所需要写的事件*/ }else{ /*空格的时候的提示语*/ } } } } 方式3： el-from的表单验证
rules: { name: [ { required: true, message: '不能为空', trigger: 'blur'}, { pattern: /^(?!\s+).*(?&lt;!\s)$/, message: '首尾不能为空格', trigger: 'blur' } ] } 方法4： 输入框禁止输入特殊字符：
/** * 匹配特殊字符的正则 */ export const regexpSpecialStr = /[-~#（）|【-】· (){}+=*^&amp;%$@!.,，。&lt;&gt;;:：；‘’“”、'"?`\_\/\\]/g; const handleInputName = (val: string) =&gt; { formData.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/932b5e18958e0432523eaa071f5ef27a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15f2906e0b24703d5bd629f8e33fe604/" rel="bookmark">
			关闭进程windows
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解除占用端口的方法取决于操作系统和应用程序的情况。以下是一些常见的方法，您可以尝试它们来解除占用端口 12345：
1. **杀死占用端口的进程（Windows、Linux、macOS）：**
- 在 Windows 上，您可以使用命令行工具 `netstat` 和 `tasklist` 来查找占用端口的进程，并使用任务管理器或 `taskkill` 命令来终止进程。例如：
```shell
netstat -ano | findstr :12345
tasklist | findstr &lt;进程ID&gt;
taskkill /F /PID &lt;进程ID&gt;
```
- 在 Linux 和 macOS 上，您可以使用 `lsof` 命令来查找占用端口的进程，并使用 `kill` 命令来终止进程。例如：
```shell
sudo lsof -i :12345
sudo kill -9 &lt;进程ID&gt;
```
2. **等待一段时间：**
如果占用端口的进程是临时的，可能会在一段时间后自动释放该端口。您可以尝试等待一段时间，然后再次尝试绑定端口。
3. **更改应用程序使用的端口：**
如果您有权限更改应用程序使用的端口号，可以尝试将端口号更改为未被占用的端口，然后更新您的应用程序配置。
请注意，终止其他进程可能会影响这些进程的正常运行，因此在执行此操作之前，请确保了解您正在终止的进程以及其对系统的影响。如果可能的话，首选方法是更改您的应用程序配置以使用其他未被占用的端口。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92781605517b757fb46bd8cccd86dd86/" rel="bookmark">
			iOS 17 适配 Xcode 15 问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在适配 iOS 17 + xcode 15时遇到的问题，记录一下。
Could not build module ‘WebKit’
type argument 'nw_proxy_config_t' (aka 'struct nw_proxy_config *') is neither an Objective-C object nor a block type 解决方案：
编辑文件 /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS17.0.sdk/System/Library/Frameworks/WebKit.framework/Headers/WKWebsiteDataStore.h
将里面的 170000 修改成 180000。
因为该文件是锁定状态，直接修改不了，需拷贝出来修改完成之后，再去替换该文件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ceed9a8983fdb2818079fb6e22fdc4f/" rel="bookmark">
			python实现MACD指标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 MACD指标是交易者非常常用的技术指标，怎样在自已的系统工具中实现MACD指标是常见的开发需求，下面是我利用pandas的EWM方法分别实现DIF与DEA指标的计算，MACD=2*（DIF- DEA）。相关特性实现的MACD指数代码：
def read_macd(self, stock_dat): stock_dat['DIF'] = stock_dat['close'].ewm(span=12, adjust=False).mean() - stock_dat['close'].ewm(span=26, adjust=False).mean() stock_dat['DEA'] = stock_dat['DIF'].ewm(span=9, adjust=False).mean() stock_dat['MACD'] = 2 * (stock_dat['DIF'] - stock_dat['DEA']) return stock_dat 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93864b98a2d616e0d42ea7be819c4f6c/" rel="bookmark">
			VMware16.1.2安装及各版本密钥
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、VMware 16 虚拟机下载二、安装步骤三、VMware 各版本注册密钥1 、VMware 16密钥2 、VMware 14密钥3 、VMware 15密钥4 、VMware 17密钥 一、VMware 16 虚拟机下载 VMware 16 下载地址：
https://www.vmware.com/cn/products/workstation-pro/workstation-pro-evaluation.html
二、安装步骤 双击安装 进入 安装界面，点击下 一步 接受 许可协议，点击 下一步 设置 安装路径，点击 下一步
用户体验设置，取消勾选，然后点击 下一步
选择快捷方式，默认即可，然后点击 下一步
点击 安装
点击 完成
三、VMware 各版本注册密钥 1 、VMware 16密钥 ZF3RO-FHED2-M80TY-8QYGC-NPKYF
YF390-OHF8P-M81RQ-2DXQE-M2UT6
ZF71R-DMX85-08DQY-8YMNC-PPHV8
其他版本密钥：
2 、VMware 14密钥 CG54H-D8D0H-H8DHY-C6X7X-N2KG6
ZC3WK-AFXEK-488JP-A7MQX-XL8YF
AC5XK-0ZD4H-088HP-9NQZV-ZG2R4
ZC5XK-A6E0M-080XQ-04ZZG-YF08D
ZY5H0-D3Y8K-M89EZ-AYPEG-MYUA8
3 、VMware 15密钥 UY758-0RXEQ-M81WP-8ZM7Z-Y3HDA
VF750-4MX5Q-488DQ-9WZE9-ZY2D6
UU54R-FVD91-488PP-7NNGC-ZFAX6
YC74H-FGF92-081VZ-R5QNG-P6RY4
YC34H-6WWDK-085MQ-JYPNX-NZRA2
4 、VMware 17密钥 MC60H-DWHD5-H80U9-6V85M-8280D
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a47748cbb01da6a1df1452f077e4bcf5/" rel="bookmark">
			J1939协议的组成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通信数据格式
本协议总线通信速率为：250Kbps.本协议的物理链路层接口是CAN总线，消息格式遵循CAN2.0B规范，全部消息采用CAN扩展帧格式如下： 本协议的协议数据单元遵循J1939协议，PDU由七部分组成，分别是优先级，保留位，数据页，PDU 格式，特定PDU （可作为目标地址、组扩展或专用），源地址和数据域，如下： 定义：P是优先级，R是保留位，DP是数据页，PF是PDU格式，PS是特定PDU，SA是源地址
本协议规定：PF是协议消息命令码
协议当中有多字节表示的数据，约定低字节在前，高字节在后，特殊数据标红色。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ee4413e45beb6267996879d1223c4dc/" rel="bookmark">
			使用asp.net core web api创建web后台，并连接和使用Sql Server数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：因为要写一个安卓端app，实现从服务器中获取电影数据，所以需要搭建服务端代码，之前学过C#，所以想用C#实现服务器段代码用于测试，本文使用C#语言，使用asp.net core web api组件搭建服务器端，并访问sql server 数据库。
二、 创建ASP.NET Core Web API，选择C#语言。
如下图所示
后面一路默认配置即可，创建后会有个实例代码，个人感觉挺有意义，对于初次使用的人很有参考价值。因为程序中用到图片转base64格式字符串和使用sqlserver数据库，需要下载NuGet程序包，下载方法，解决方案--右键--“管理解决方案的NuGet程序包”，下载如下缺少的包，如下图：
2.安装Nuet程序包——项目——依赖项——管理NuGet程序包（版本等级尽量一样）
Microsoft.EntityFrameworkCore
Microsoft.EntityFrameworkCore.SqlServer （适用于EF Core SQL Server 提供程序）
Microsoft.EntityFrameworkCore.Tools（适用于 EF Core 的包管理器控制台工具）
Microsoft.EntityFrameworkCore.Design（适用于EF Core .NET Core CLI 工具 ）
system.Drawing.Common
Newtonsoft.Json
swashbuckle.AspNetCore
三、连接数据库，并返回查询结果
1、首先创建一个类，保存web端返回的数据，比如我创建一个电影类，客户端查询电影时，返回电影列表。
namespace MyWebServer.Model { // 电影列表使用 public class Film { public string? film_name { get; set; } public string? film_type { get; set; } public string? film_desc { get; set; } // base64格式的图片 public string?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ee4413e45beb6267996879d1223c4dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1aa06fad87de2f95ce81ea5aae11d950/" rel="bookmark">
			搜维尔科技：如何利用Varjo虚拟现实头显来改变建筑视觉化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虚拟现实/XR对建筑可视化的好处: 1.为客户和设计团队提供一次全面设计的生动体验
2.加快设计决策过程,节省成本,节省5%至50%的概念设计时间
3.减少对物理原型的需求、节约资源和减少浪费的能力
4.及早决策有助于避免在施工阶段发生不必要的变化,并节省时间、劳动力和材料
从地平线优势到开拓性技术： 柯恩·彼得森·福克斯是世界上最负盛名的建筑公司之一,以设计全球12座最高摩天大楼中的6座而闻名。他们在纽约、旧金山、伦敦、柏林、上海、香港、深圳、首尔和新加坡设有办事处,由700多名专业人员组成的团队,通常都在从事大规模和复杂的项目,这些项目在全球范围内带头进行设计创新。
为了 KFP ,推动大型、行业领先的项目,培养了不断创新和采用先进技术的文化。因此,自该技术早期以来,KFP在纽约和伦敦的团队一直站在探索各种虚拟现实解决方案的最前沿,以优化架构工作流。他们最初认为虚拟现实主要是一种空间分析工具,但随着技术的能力和视觉精确度的成熟,这种视角演变成更多的用例。
设计师和建筑师总是追求最高的分辨率,目的是尽可能精确地复制现实世界,以展示一个项目的最终结果。随着KFP团队深入研究采用浸入式技术,早期一代耳机的局限性变得越来越明显。
尤其是,老设备在交付KFP复杂项目所要求的高分辨率输出方面困难重重,当涉及到与公司首选软件工具的兼容性时,这些设备经常会出现问题。他们需要下一代的解决方案,它可以达到标准,并以不受损害的忠实度弥合理想与可视化之间的鸿沟。
设计和感知的新维度：
团队发现他们的对手是 瓦尔霍航空公司 ,瓦尔霍的最先进的虚拟现实耳机,由于其高分辨率的能力和比竞争对手优越的性能突出。借助瓦乔航空公司的高精度视觉保真度,KFP现在可以超越虚拟现实中仅仅的空间分析:他们可以仔细研究甚至是最好的细节,并且能够看到什么是真实世界的一对一代表。这种现实的水平有可能改变项目工作流和客户端交互。
"瓦尔霍耳机大大改变了设计师对虚拟现实能提供什么的看法,"他说。 安迪 赫里斯托福卢 ,是纽约区的应用研究计划创新经理。"我们一试它,就开始喜欢上它,因为它可以检查我们需要的所有耳机。"尽管3d架构的表现已经被使用了很多年,但传统上它们一直局限于监视器或屏幕的二维限制。基于VRS的可视化超越了这一限制,将用户直接放到建筑场景中,提供了真实的维度感,并减少了掌握复杂技术测量的需要。"与在屏幕或物理模型中观看相比,建筑师将自己迁移到虚拟建筑模型中并使自己沉浸其中的能力提供了一个独特的视角和更好的感觉反馈,"他解释说。 乔纳森 德雷弗斯, 伦敦Kpp的计算实践专家。"随着虚拟现实/XR技术变得越来越超现实,我相信业界将越来越多地将其与传统媒体一起使用。毕竟,当你能体验一个完全沉浸和互动的环境时,为什么要把自己限制在一个单一的形象上呢?"乔纳森德雷弗斯说。
更好的反馈和决策：
KFP的伦敦团队设立了一个专门的虚拟虚拟空间,供用户进行沉浸式的展示。该工作室配备了基站和设备,随时准备向客户展示高层次的可视化,并帮助他们在项目开始前亲身体验项目。这种设置为用户提供了空间理解,有助于决策和形成反馈,使他们的理解超越了传统的绘图或物理模型。
"尝试这种方法的客户通常会对体验表示满意。他们能够了解到一些细节,比如从地板到天花板的高度,以及通过窗户看到的景观,而这些可能在平面图或其他视觉中是没有注意到的。
通过沉浸式可视化,客户端可以测试设计迭代,选择最佳选项,并为设计团队节省5%到50%的概念时间。如果客户在回顾传统视觉后有些不确定性,将其纳入虚拟现实体验可以有效地消除他们的疑虑,加快决策过程。"在某些情况下,30分钟的虚拟虚拟会议可以节省数周的建模、起草和演示,并将其翻译成实质性的节省,"乔纳森德雷弗斯指出
无缝过渡到高级可视化： 对于kpp来说,采用瓦尔霍虚拟现实的主要好处之一是它与各种软件工具的兼容性,比如 双动 , 景观 , 不真实的引擎 , 无所不在 ,以及虚拟现实插件 阿尔基奥 和 展望.对于团队来说尤为突出的是瓦霍在更新和支持这些关键应用程序方面的积极方法。"从瓦尔霍团队,我们收到了关于即将到来的更新或任何我们遇到的东西的即时帮助。我们通常会在几分钟内收到回应,或者提供解决方案,或者提出解决方案。"这种水平的支持是我们希望与瓦霍保持一致的原因之一。我们不想转换到一个不同的耳机,它不支持我们使用的所有工具。"
… 新发布的支持 对于瓦尔霍的VR和XR设备的双动现在提供了一个宝贵的桥梁,在VR和行业的主要实时可视化工具之一之间。双动带来了许多强有力的功能,帮助描绘和叙述KFP的项目,其中许多是独家的平台。它还提供了一个高效率的门户,让项目使用不真实的引擎,使团队能够创造更高级的互动体验。
这种集成对KFP很有帮助,并简化了现有的工作流程:只要点击几下,设计师现在就可以通过激活双动,选择虚拟虚拟模型,并直接通过他们的瓦尔霍耳机沉浸在他们的3D模型中,从而为他们的建筑设计注入活力。
"对我们来说,关键是能够直接将瓦尔霍耳机插进双动作中,使其不受干扰。乔纳森德雷弗斯说:"事实上,我们可以简单地点击游戏,软件直接连接到耳机,这大大节省了时间。"
为专业人士重新定义虚拟现实云： 1.对设计迭代中央管理的额外控制
2.团队、同事和客户之间更容易分享设计
3.减少了对复杂3D模型可视化的本地硬件需求
是第一家尝试 现实云 ,瓦尔霍的云流服务,为沉浸式内容。使用VARJOO现实云,KFP的团队可以将虚拟现实/XR可视化功能上传到云中,让同事和客户可以浏览和流到虚拟现实耳机或其他设备的设计迭代,无论时间或地点。KFP的团队对瓦尔霍现实云印象深刻,认为它的流媒体质量和低延迟有可能与本地计算机匹敌。"现实云是我最喜欢的一个方面的瓦尔霍的提议。我发现这是一个令人难以置信的令人印象深刻的解决方案,几乎类似于虚拟现实的"圣杯",这一点到目前为止还没有实现。考虑到这种混合工作的转变,KFP的许多设计师通常都依赖笔记本电脑,对高性能计算机的访问也有限。瓦尔霍现实云能够弥补这一差距,消除了对先进硬件设置的需求,并为团队提供更大的版本控制,以管理最新设计迭代的共享。安迪?赫里斯托福卢解释说:"能够轻松地将大型场景上传到现实云,然后在不担心硬件管理的情况下跳进来,这就解决了团队的一个重大痛苦点。"
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50478bcb5a8db87fe6e80c10858db747/" rel="bookmark">
			python gui输入框内容获取,python规范化快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，本文将围绕python gui输入框内容获取展开说明，python规范化快捷键是一个很多人都想弄明白的事情，想搞清楚python gui界面设计需要先了解以下几个事情。
Python图形化界面设计 窗体控件布局 #coding:utf-8 from tkinter import * root= Tk() root.title('我的第一个Python窗体') root.geometry('240x240') # 这里的乘号不是 * ，而是小写英文字母 x root.mainloop() tkinter 常用控件 控件名称作用Button按钮单击触发事件Canvas画布绘制图形或绘制特殊控件Checkbutton复选框 多项选择Entry输入框接收单行文本输入Frame框架用于控件分组Label标签单行文本显示Lisbox列表框显示文本列表Menu菜单创建菜单命令Message消息多行文本标签，与Label 用法类似Radiobutton单选按钮从互斥的多个选项中做单项选择Scale滑块默认垂直方向，鼠标拖动改变数值形成可视化交互Scrollbar滑动条默认垂直方向，可鼠标拖动改变数值，可与 Text、Lisbox、Canvas等控件配合移动可视化空间Text文本框接收或输出显示多行文本Toplevel新建窗体容器在顶层创建新窗体 控件的共同属性 属性说明取值anchor文本起始位置CENTER(默认)，E,S,W,N,NE,SE,SW,NWbg背景色无bd加粗（默认 2 像素）无bitmap黑白二值图标网上查找cursor鼠标悬停光标网上查找font字体无fg前景色无height高（文本控件的单位为行，不是像素）无image显示图像无justify多行文本的对其方式CENTER(默认)，LEFT,RIGHT,TOP,BOTTOMpadx水平扩展像素无pady垂直扩展像素无relief3D浮雕样式FLAT,RAISED,SUNKEN,GROOVE,RIDGEstate控件实例状态是否可用NORMAL(默认)，DISABLEDwidth宽(文本控件的单位为行，不是像素)无 标签实例 #coding:utf-8 from tkinter import * root = Tk() root.title('Python窗体') lb = Label(root,text='我是第一个标签',\ bg='#d3fbfb',\ fg='red',\ font=('华文新魏',32),\ width=20,\ height=2,\ relief=SUNKEN) lb.pack() root.mainloop() 标签布局 控件的布局通常有pack()、grid() 和 place() 三种方法。
pack()方法:
是一种简单的布局方法，如果不加参数的默认方式，将按布局语句的先后，以最小占用空间的方式自上而下地排列控件实例，并且保持控件本身的最小尺寸Python解释器的安装步骤。
用pack() 方法不加参数排列标签。为看清楚各控件所占用的空间大小，文本用了不同长度的中英文，并设置relief=GROOVE的凹陷边缘属性。如下所示：
#coding:utf-8 from tkinter import * root = Tk() root.title('Python窗体') lbred = Label(root,text="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50478bcb5a8db87fe6e80c10858db747/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed134ab9b3cbc2561920b8ceced8e688/" rel="bookmark">
			InfluxDB在Windows和centos7的下载，安装，自启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 windows： 1.官网下载 官网下载地址，我一般都喜欢官网下载，包含windows，linux，macos，docker，K8s甚至树莓派系统等。
2.启动 进入到文件夹下，双击启动exe的话会一闪而过，它告诉你要cmd用命令行启动。所以cmd到当前目录下，输入命令：start influxd.exe
3.管理页面 http://localhost:8086
4.自启动 我个人比较喜欢用SrvanyUI软件管理自启动，无需安装。
选择自建服务，需要在influxdb.exe目录下写个bat脚本
:: 防止中文乱码 chcp 65001 :: 关闭回显 @echo off :: 进入当前目录 cd %~dp0 :: 运行后保持界面一直显示 cmd /k "start influxd.exe" :: 开启回显 @echo on 启动程序选择这个bat脚本,启动参数写上start，到这开机自启动就全部完成了。
centos7： 1.官网下载 地址，根据服务器架构下载rpm包
#1.上传到服务器，rpm安装 rpm -ivh influxdb2-2.7.1.x86_64.rpm #2.自启动，会在/lib/systemd/system路径下生成influxdb.service文件，输入 systemctl start influxdb.service命令启动服务 #3.打开端口，默认8086端口 firewall-cmd --zone=public --add-port=8086/tcp --permanent #刷新防火墙配置 firewall-cmd --reload #命令 systemctl stop influxdb.service #关闭 systemctl start influxdb.service #开启 systemctl status influxdb.service #查看状态 systemctl restart influxdb.service #重启 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df7c62a1038c78ce3641de86630d6db8/" rel="bookmark">
			麒麟系统查看系统版本命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 查看外核版本 cat /etc/.kyinfo cat /etc/lsb-release cat /etc/kylin-build cat /etc/kylin-release nkvers cat /etc/issue cat /proc/version cat /etc/os-release 查看内核版本 uname -a cat /etc/.productinfo 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da3fee8a574d80224d1a970d6979c69c/" rel="bookmark">
			计算机网络题库---选择题刷题训练（100多道精品）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一章 概述 1.下列四项内容中，不属于Internet（因特网）基本功能是___D_____。
A.电子邮件 B.文件传输 C.远程登录 D.实时监测控制
2.Internet是建立在____C_____协议集上的国际互联网络。
A.IPX B.NetBEUI C.TCP/IP D.AppleTalk
3.关于Internet，以下说法正确的是____D_____。
A.Internet属于美国 B.Internet属于联合国;
C.Internet属于国际红十字会 D.Internet不属于某个国家或组织
4.以下列举的关于Internet的各功能中，错误的是_____A____。
A.程序编码 B.信息查询 C.数据库检索 D.电子函件传送
5.和通信网络相比，计算机网络最本质的功能是____B_____。
A.数据通信 B.资源共享 C.提高计算机的可靠性和可用性 D.分布式处理
6.国际标准化组织ISO提出的不基于特定机型、操作系统或公司的网络体系结构OSI模型中，第二层和第四层分别为_____B____。
A.物理层和网络层 B.数据链路层和传输层；
C.网络层和表示层 D.会话层和应用层
7.在OSI参考模型中能实现路由选择及互连功能的层是_____C____。
A.传输层 B.应用层 C.网络层 D.物理层
8.下列说法中不对的是：____B_____。
A.可以同时双向传输信号的通信方式称为全双工通信方式；
B.在数字通信信道上，直接传送基带信号的方法称为频带传输； C.TCP/IP参考模型共分为四层，最底层为网络接口层，最高层是应用层；
D.类型不同的网络只要使用TCP/IP协议都可以互连成网。
9.在网络工程中通常用的线缆标准为_____B____。
A.568A B.568B C.586A D.586B
10.不属于计算机网络应用的是____B_____。
A.电子邮件的收发 B.用“写字板”写文章 C.用计算机传真软件远程收发传真 D.用浏览器浏览“上海热线”网站
第二章 物理层 11.在串行通信中采用位同步技术的目的是_________。
A.更快地发送数据 B.更快地接收数据
C.更可靠的传输数据 D.更有效地传输数据。
12.同步传输与异步传输相比_________。
A.同步传输更省线路
B.同步传输具有更高的数据传输速率
C.同步传输比异步传输的同步性能更好
D.以上三点都不对。
13.专线方式接入Internet时，可以按照实际通信量（即每月传送了多少字节数据）来计费，这是因为_________。
A.这种接入方式采用的是电路交换技术
B.这种接入方式采用的是报文交换技术
C.这种接入方式采用的是分组交换技术
D.这种接入方式采用的是同步传输技术
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da3fee8a574d80224d1a970d6979c69c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5614d2406f350e32e8acd81e1f58c64/" rel="bookmark">
			nlp-中字拼音（常用3726字）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		啊 ā
阿 ā
埃 āi
挨 āi
哎 āi
唉 āi
哀 āi
皑 ái
癌 ái
蔼 ǎi
矮 ǎi
艾 ài
碍 ài
爱 ài
隘 ài
鞍 ān
氨 ān
安 ān
俺 ǎn
按 àn
暗 àn
岸 àn
胺 àn
案 àn
肮 ānɡ
昂 ánɡ
盎 ànɡ
凹 āo
敖 áo
熬 áo
翱 áo
袄 ǎo
傲 ào
奥 ào
懊 ào
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5614d2406f350e32e8acd81e1f58c64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/497a125bdb2a4677d5487d5e8105d6b0/" rel="bookmark">
			elasticsearch 8.5.3问题记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一：解决 elasticsearch 高版本 warning: ignoring JAVA_HOME=C:\Program Files\Java\jdk-11； using bundled JDK if defined JAVA_HOME ( set JAVA_HOME=%JAVA_HOME%; ) 示例版本Elasticsearch 8.5.3 可以与 JDK 11 兼容，但不支持 JDK 17。确保选择与 Elasticsearch 版本兼容的 JDK 版本 二：重置用户名密码 elasticsearch-reset-password -u elastic 4xjAmb81FLGID*dG*4hX 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9eee54361cd4dc99c75bb734770929d/" rel="bookmark">
			nlp-中字拆字词典
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		丁 一 亅
丂 一 乙
七 一 乚 丿 乚
丄 丨 一
丅 一 丨
万 一 勹 一 刀
丈 一 乂
三 一 二 一 一 一
上 一 丨 一 丶 丨 一
下 一 卜 一 丨 丶
丌 一 丿 丨
不 一 丿 丨 丶
丐 下 勹 正 丿
丑 ㇆ 一 丨 一
丒 刃 一
且 月 一
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9eee54361cd4dc99c75bb734770929d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6345ab43d206dfb3c7c3374e85697886/" rel="bookmark">
			kettle数据同步
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kettle是一个强大的数据集成工具，可以用来实现各种数据同步的需求。以下是一些常见的Kettle数据同步的实现方法：
数据库之间的同步：使用Kettle中的数据库连接组件，可以连接多个不同的数据库，并通过数据抽取、转换和加载步骤实现数据同步。
文件之间的同步：Kettle可以读取和写入各种类型的文件，包括CSV、Excel、JSON和XML等格式。因此，可以通过读取源文件、转换数据格式，并将其写入目标文件来实现数据同步。
消息队列之间的同步：Kettle支持多种消息队列协议，如AMQP、Kafka和RabbitMQ等。使用这些协议，可以轻松地实现消息队列之间的数据同步。
云端数据之间的同步：Kettle可以连接各种主流的云数据库，如AWS、Google Cloud和Microsoft Azure等。使用这些组件，可以轻松地将数据在云端进行同步。
ERP系统之间的同步：Kettle可以与各种ERP系统进行集成，如SAP、Oracle EBS和Microsoft Dynamics等。通过连接这些系统，可以实现ERP数据之间的同步。
闲话休提，今天笔者来谈谈这个工具的利弊。笔者曾经做过一个项目，将一些数据从Oracle数据库中同步更新到PostgreSQL中，每天晚上凌晨1点开始同步，至凌晨5点前结束。但是这个项目的数据由于比较混乱，所以每一次都是需要全量更新，更新的数据量有3000万条左右。在最初的时候发现每一个星期总会出现1~2次更新失败。而一旦失败，就会在应用系统中体现出来，客户必然会联系笔者单位，附加一些语言伤害。
图1 kettle数据同步
图2 数据同步过程
笔者采用了2个批处理的命令分2个时段同步数据。从事后的log日志里面可以经常看到这样的 失败原因。
这个原因笔者分析，是因为同步的时间过长。在此期间，Oracle数据库中的数据又发生了变化，真的不好处理。后来，又通过增加线程，将串行改为并行的方式，时间上有所减少，但是依然会出现问题。后来，又尝试改为事务，同步时间更长了，而且更容易出错了。
截止目前数据同步还是没有办法通过此方法自动同步。当然主要原因笔者也进行了分析：
1.Oracle服务器数据限流导致速度慢。
2.kettle工具同步速度不快。
3.全量更新数据风险大，由于客户数据混乱不得已为之。
因此，笔者认为，在进行数据同步的时候，工具只是其中一方面，还需要考虑其他的环境问题。事实上，如果系统数据设计完善完全可以才用增量更新的方式，更安全保险进行数据同步，那样就不会发生上述问题。
笔者此文权当抛砖引玉，希望与其他开发者加强交流，互相学习进步。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e07149a99a262b483f1cfa40615a065/" rel="bookmark">
			Python123： 阶梯电价（C语言）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：为了提倡居民节约用电，某省电力公司执行“阶梯电价”，安装一户一表的居民用户电价分为两个“阶梯”：月用电量50千瓦时（含50千瓦时）以内的，电价为0.53元/千瓦时；超过50千瓦时的，超出部分的用电量，电价上调0.05元/千瓦时。请编写程序计算电费。
输入格式： 输入在一行中给出某用户的月用电量（单位：千瓦时），注意：用电量不一定是整数。
输出格式： 在一行中输出该用户应支付的电费（元），结果保留两位小数，格式如：“cost = 应付电费值”；若用电量小于0，则输出"Invalid Value!"。
输入样例1： 10 输出样例1： cost = 5.30 输入样例2： 100 输出样例2： cost = 55.50 代码1： #include &lt;stdio.h&gt; int main(void) { double x,cost; scanf("%lf",&amp;x); if (x&gt;50) { cost =(0.53+0.05)*(x-50)+0.53*50; printf("cost = %.2f",cost); } else if (x&gt;0) { cost = 0.53*x; printf("cost = %.2f",cost); } else { printf("Invalid Value!"); } return 0; } 代码2： #include &lt;stdio.h&gt; int main() { double a,cost; scanf("%lf",&amp;a); if(a&gt;=0) { if(a&gt;=0&amp;&amp;a&lt;=50) cost=a*0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e07149a99a262b483f1cfa40615a065/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/264bcd729ba7c336d6b534fec388625c/" rel="bookmark">
			Vue&#43;elementui表格中的数据是树形结构实现全选
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为树形结构的数据类型是嵌套的，elementui表格的全选没有办法实现选择子类
那么我们要通过循环遍历来让子类也选中
首先添加单选和全选事件，还有通过ref找到表格
&lt;el-table ref="refTable" v-loading="loading" :data="dataList" style="width: 100%" row-key="id" default-expand-all border :header-cell-style="{ height: '30px !important', fontSize: '14px' }" :tree-props="{ children: 'children', hasChildren: 'hasChildren' }" select-on-indeterminate :height="screenHeight" @select="rowSelect" @select-all="selectAll" &gt; data中定义一个储存选中数据的数组
// 多选数据暂存数组 multipleSelection: [] 事件
//树状表格全选 /*注意在获取初始数据时，所有节点（包括子节点）都增加一个isChecked 标志参数*/ rowSelect(selection, row) { if (row.children) { //只对有子节点的行响应 if (!row.isChecked) { //由行数据中的元素isChecked判断当前是否被选中 row.children.map(item =&gt; { //遍历所有子节点 this.$refs.refTable.toggleRowSelection(item, true); //切换该子节点选中状态 /* 方法名 说明 参数 用于多选表格，切换某一行的选中状态， row, selected toggleRowSelection 如果使用了第二个参数，则是设置这一行 选中与否（selected 为 true 则选中） */ item.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/264bcd729ba7c336d6b534fec388625c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c14d93b41d021ffd8ca12bebb417b819/" rel="bookmark">
			tomcat服务安装步骤以及详细配置教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		tomcat服务安装步骤以及详细配置教程 文章目录 tomcat服务安装步骤以及详细配置教程1.简介2.优缺点优点：缺点： 3.工作原理4.工作流程5.实战（tomcat项目部署）5.1.java环境安装5.2.拉取tomcat软件包5.3.解压部署5.4.启动tomcat服务5.5.访问tomcat的web页面5.6.尝试访问webapps目录中其他项目 总结： 1.简介 Tomcat是一个开源的Java Servlet容器，可以作为Java Web应用程序的运行环境。它是Apache软件基金会的一个重要项目，具有高性能、稳定可靠以及跨平台等特点。它实现了Java Servlet和JavaServer Pages（JSP）规范，并提供了一个运行环境，使得Java代码可以在Web服务器上执行。
tomcat就是传说中的中间件之一，tomcat本身是一个容器，专门用来运行java程序，java语言开发的网页.jsp就应该运行于tomcat中。而tomcat本身的运行也依赖于jdk环境。
2.优缺点 优点： 开源免费：Tomcat是一个开源项目，可以免费使用，这使得它成为了一个广受欢迎的Java Web应用服务器。跨平台：Tomcat可以在各种操作系统上运行，包括Windows、Linux、macOS等。轻量级：相比于其他一些Java应用服务器（如WebLogic、WebSphere等），Tomcat相对轻量级，资源占用较少，启动速度也相对较快。灵活性：Tomcat可以作为一个独立的Web服务器使用，也可以与其他Web服务器（如Apache）配合使用，形成一个强大的Web服务器架构。 缺点： 功能相对有限：相对于一些商业的Java应用服务器，Tomcat在一些高级特性和功能方面可能有所欠缺，比如分布式事务、集群等方面的支持。管理界面相对简陋：Tomcat的管理界面相对简单，对于一些高级的管理需求可能不够满足。 3.工作原理 omcat的工作原理基于Java Servlet和JavaServer Pages（JSP）规范，它充当了一个Java Web应用程序的运行环境和Web服务器。以下是Tomcat的工作原理的详细说明：
启动Tomcat：Tomcat作为一个独立的Java应用程序运行。通常，你会使用命令行或启动脚本来启动Tomcat。一旦Tomcat启动，它开始监听HTTP请求的到达。连接器（Connectors）：Tomcat通过连接器来监听HTTP请求。连接器是Tomcat的组件，负责处理网络连接和接收HTTP请求。常见的连接器包括HTTP连接器（用于处理HTTP请求）和AJP连接器（用于与其他Web服务器如Apache连接）。每个连接器通常监听一个特定的端口，比如HTTP连接器默认监听8080端口。容器（Containers）：Tomcat包含了两种主要的容器：引擎（Engine）和主机（Host）。引擎负责处理多个主机，每个主机代表一个独立的域名或虚拟主机。主机包含一个或多个上下文（Context），每个上下文对应一个Web应用程序。容器负责处理Servlet和JSP的生命周期管理、请求分发和响应收集。Servlet容器：当一个HTTP请求到达Tomcat后，Tomcat会根据请求的URL来确定将请求交给哪个Servlet进行处理。Servlet容器是Tomcat的一部分，它负责管理Servlet的生命周期，包括实例化、初始化、调用和销毁。Servlet容器还负责将请求传递给适当的Servlet，并将Servlet生成的响应返回给客户端。JSP引擎：Tomcat还包含了一个JSP引擎，用于处理JSP页面。当一个JSP页面被请求时，JSP引擎将JSP编译成Servlet，并交给Servlet容器来处理。生成的Servlet负责处理JSP页面的动态内容生成。部署描述符（Deployment Descriptors）：每个Web应用程序通常包括一个部署描述符（通常是一个web.xml文件），它包含了关于应用程序的配置信息，包括Servlet映射、过滤器配置、监听器配置等。Tomcat会读取这些描述符以了解如何处理请求。请求处理流程： Tomcat接收到HTTP请求后，连接器将请求传递给适当的主机和上下文。主机和上下文确定哪个Servlet应该处理请求，并将请求传递给Servlet容器。Servlet容器实例化和初始化Servlet，调用其service()方法来处理请求。Servlet生成响应并将其返回给Servlet容器。Servlet容器将响应返回给主机和连接器，最终发送给客户端。 关闭Tomcat：当不再需要Tomcat服务时，你可以通过命令行或脚本来关闭Tomcat。Tomcat会执行关闭过程，释放资源并停止监听HTTP请求。 总之，Tomcat的工作原理涉及连接器、容器、Servlet容器、JSP引擎以及部署描述符等多个组件，它们协同工作来处理HTTP请求，将请求传递给适当的Servlet或JSP，生成响应并将其返回给客户端。这个过程使得Tomcat成为一个强大的Java Web应用服务器，用于部署和运行Java Web应用程序。
4.工作流程 tomcat的工作原理基于Java Servlet和JSP规范。它充当一个Web服务器，接收HTTP请求并将其传递给合适的Servlet或JSP进行处理。以下是Tomcat的基本工作流程：
接收请求：Tomcat作为一个Web服务器监听指定的端口（默认为80或8080）。当一个HTTP请求到达时，Tomcat会接收并解析它。请求分发：根据URL和部署在Tomcat中的应用程序配置，Tomcat会决定将请求交给哪个Servlet或JSP进行处理。Servlet处理：如果请求是一个Servlet请求，Tomcat会将请求信息传递给相应的Servlet。Servlet会处理请求并生成响应，然后将其发送回Tomcat。JSP处理：如果请求是一个JSP请求，Tomcat会将JSP文件编译成一个Servlet，然后将请求信息传递给这个Servlet进行处理。Servlet再生成响应并将其返回给Tomcat。响应传递：Tomcat接收到Servlet或JSP生成的响应后，将其传递回客户端。 5.实战（tomcat项目部署） 服务器IP地址系统版本tomcat版本tomcat192.168.195.137centos 8apache-tomcat-9.0.80.tar.gz 首先关闭防火墙和selinux
[root@tomcat ~]# systemctl disable --now firewalld.service Removed /etc/systemd/system/multi-user.target.wants/firewalld.service. Removed /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service. [root@tomcat ~]# setenforce 0 [root@tomcat ~]# vim /etc/selinux/config [root@tomcat ~]# grep '^SELINUX=' /etc/selinux/config SELINUX=disabled 5.1.java环境安装 JDK（Java Development Kit）和JRE（Java Runtime Environment）是Java开发和运行环境的两个重要组成部分，它们之间有以下区别：
JDK：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c14d93b41d021ffd8ca12bebb417b819/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/491e2988c202f2a328c8320ac0ab841d/" rel="bookmark">
			K8S：配置资源管理 Secret和configMap
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一.Secret1.Secret概念2.Secret的类型①kubernetes.io/service-account-token②opaque③kubernetes.io/dockerconfigjson④kubernetes.io/tls 3.secret的三种参数①tls②docker-registry③generic 4.Pod 的3种方式来使用secret5.Secret创建及案例（1）创建Secret①用kubectl create secret命令创建Secret②内容用 base64 编码，创建Secret （2）使用Secret方式①将Secret 挂载到 Volume 中，以 Volume 的形式挂载到 Pod 的某个目录下②将 Secret 导出到环境变量中调用 二.ConfigMap1.ConfigMap概念2.ConfigMap功能及应用场景3.ConfigMap创建及案例（1）创建ConfigMap①使用目录创建②使用文件创建③使用字面值创建 （2）Pod 中使用 ConfigMap①使用 ConfigMap 来替代环境变量②用 ConfigMap 设置命令行参数③通过数据卷插件使用ConﬁgMap④ConﬁgMap 的热更新⑤ConfigMap 更新后滚动更新 Pod 总1.secret三种类型2.创建secret资源3.secret资源使用4.configMap cm 一.Secret 1.Secret概念 （1）Secret 是用来保存密码、token、密钥等敏感数据的 k8s 资源，这类数据虽然也可以存放在 Pod 或者镜像中，但是放在 secret 中是为了更方便的控制如何使用数据，并减少暴露的风险
（2）类似挂载的方式，使用的时候调用即可
2.Secret的类型 ①kubernetes.io/service-account-token 由Kubernetes自动创建，用来访问APIServer 的 Secret， Pod会默认使用这个 Secret 与 APIServer 通信，并且会自动挂载到 Pod 的 /run/secrets/kubernetes.io/serviceaccount 目录中
②opaque base64 编码格式的 Secret，用来存储用户自定义的密码、密钥等，默认的Secret 类型
③kubernetes.io/dockerconfigjson 用来存储私有 docker registry 的认证信息
④kubernetes.io/tls 用于为ssl通信模式存储证书和私钥文件，是命令式创建的类型标识符为tls
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/491e2988c202f2a328c8320ac0ab841d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e75c78d9a6c4c4667ffd1f80a1aefdf/" rel="bookmark">
			Qt编程-QTableView同时冻结行和列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Qt编程-QTableView同时冻结行和列。如题，先看效果是不是你需要的。网上找到的代码片段要么不全要么不是想要的。如果你只需要需要冻结行或冻结列，请看上篇博客 Qt编程-QTableView冻结行或冻结列或冻结局部单元格 ，代码更少一些。
同时冻结行列带表头：
同时冻结行列不带表头：
原理 冻结行或者冻结列原理: 使用3个tableview ，内容一样，最上层tableview显示交叉部分内容，中间层显示冻结的行tableview和冻结列tableview 把非冻结的内容隐藏掉，下层显示全部内容 下层tableview正常滑动就有冻结行或者列的效果了。
代码 代码改造来自 Qt自带例子 。可通过宏变量FREEZE_COL和FREEZE_ROW控制冻结行或冻结列，宏变量TABLE_HEAD控制表头显示。完整工程代码下载。
主要代码如下：
freezetablewidget.h
#ifndef FREEZETABLEWIDGET_H #define FREEZETABLEWIDGET_H #include &lt;QTableView&gt; //! [Widget definition] class FreezeTableWidget : public QTableView { Q_OBJECT public: FreezeTableWidget(QAbstractItemModel * model); ~FreezeTableWidget(); protected: void resizeEvent(QResizeEvent *event) override; QModelIndex moveCursor(CursorAction cursorAction, Qt::KeyboardModifiers modifiers) override; void scrollTo (const QModelIndex &amp; index, ScrollHint hint = EnsureVisible) override; private: QTableView *frozenCroTableView; //冻结行冻结列交叉部分的TableView QTableView *frozenColTableView; //冻结列的TableView QTableView *frozenRowTableView; //冻结行的TableView void initCroTable(); void initColTable(); void initRowTable(); void updateFrozenCroTableGeometry(); void updateFrozenColTableGeometry(); void updateFrozenRowTableGeometry(); private slots: void updateSectionWidth(int logicalIndex, int oldSize, int newSize); void updateSectionHeight(int logicalIndex, int oldSize, int newSize); private: //冻结的行列数 int m_iFreezeCols = 3; int m_iFreezeRows = 3; }; //!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e75c78d9a6c4c4667ffd1f80a1aefdf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7879eab326dbbd65fb5ee07f91e5254/" rel="bookmark">
			服务器与网站部署知识体系目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.网站部署必备知识与实践操作 服务器全套基础知识：包含基本概念，作用，服务器选择，服务器管理等域名相关基础知识普及域名备案流程（个人备案，腾讯云 / 阿里云）将网站域名访问从http升级到https（腾讯云/阿里云） 2.博客与知识库搭建 docsify快速部署搭建个人知识库（支持本地、服务器、虚拟机运行）halo搭建炫酷个人博客快速部署：docker+docker-compose+nginx 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adc0f8a19c3bc4af7d34a0eb7eae548d/" rel="bookmark">
			刚体惯性张量在不同坐标系下的转换方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用CAD模型进行动力学仿真的时候，需要将软件中计算得到的惯性张量转换到自己定义的连杆坐标系下，通常会涉及到共原点坐标系和平移坐标系的转换，下面给出两种情况下的matlab代码，以供参考。
1.共原点坐标系下的转换：
示例：两个共原点坐标系如下所示：
假设刚体在坐标系1中的惯性张量为I_1，坐标系1到坐标系2的旋转矩阵为R，那么通过如下代码可以计算刚体在坐标系2中的惯性张量。
R = [-1 0 0; 0 0 1; 0 1 0]; I2 = R*IVec2so3(I_1)*R'; %% 注意：函数的输入惯性张量元素是从Solidworks中提取得到的，所以在非对称惯性积上添加了负号 function I = IVec2so3(v) I = [ v(1) -v(2) -v(3); -v(2) v(4) -v(5); -v(3) -v(5) v(6);]; end 2.两个平移关系的坐标系下的转换：
假设在solidworks中测量得 刚体质量为m，在坐标系1中的惯性张量为I_1，刚体在坐标系1中的质心位置为[rx,ry,rz]，并且关于质心坐标系（与坐标系1对齐）的惯性张量为I_c。坐标系2相对于坐标系1的位置为[0,0,a]，那么通过如下代码可以计算刚体在坐标系2中的惯性张量。
% 主要公式为 Huygens-Steiner theorem % I1 = Ic + m(P'*P*I-P*P') % I1 = Ic + m*S(P)'*S(P) % S = [ 0 -x3 x2; % x3 0 -x1; % -x2 x1 0] % I2 = R*I1*R' % I1*R=I2 P_1 = [rx,ry,rz]'; % inertial tensor w.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/adc0f8a19c3bc4af7d34a0eb7eae548d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86d866676ed7f65cbf951b9fddf9431b/" rel="bookmark">
			佬们给孩子推荐一下深圳或者东莞那边的工作，背景211材料
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题解 | #顺时针旋转矩阵#
import java.util.*;public class Solution { /** * 代码中的类名、方法名、参数名已经指定，请勿修改，
tplink普联提前批座谈会9.5还没oc
如题，当时座谈会准时进的，没问问题，到现在还没接到电话，是挂了吗？有一起参加座谈会的大佬已经接到电话了吗
题解 | #公共子串计算#
// HJ75-3 公共子串计算.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。#include&lt;iostr
三环
从三环离职的友友，有什么出路啊，搞材料，感觉以后哪 也去不了了。但是也没有其他满意的offer，怕进去就跳不出来了 #三环求职进展汇总#
国庆也休完了，赶紧投个阿里秋招简历吧
阿里巴巴盒马，真诚求研发、数据、算法、产品等岗位人才，特别是客户端研发工程师，欢迎扫码投递～～可切换岗位自行选择 #秋招# #你的秋招进展怎么样了#
湖南德赛电池
湖南德赛电池避雷贴事情经过：23.9.18通知二面面试通过，后续是谈薪环节。之后分别在9.22、9.26询问，都是被通知后续会安排后续谈薪环节。10.9再问了一
有了解熊猫通信的前辈嘛
拿了南京熊猫通信的offer，只知道这公司是中电熊猫的子公司熊猫电子，的子公司，算个央企。给的待遇还不错。不含五险一金总包29W，主要双边12公积金之外还有18
#晒一晒我的offer(38210)##
#晒一晒我的offer##大厂offer#我觉得大厂offer也不是太难吧？不太理解有些同学觉得大厂offer难我自己就拿了好几个了，目前还在进行offer的横
农行软开和数据中心笔试选那个
家人们，如题
翱捷北京
有在翱捷北京工作的前辈嘛？modem部门。 听说北京一共就四五十个人，感觉规模太小而且公司平台一般。月薪20k在北京很难活，有前辈了解后面涨薪幅度大嘛？
杭州银行
初面1.lasso 岭回归 线性回归基本假设、区别、lasso解决什么问题，具体公式2.MySql查询优化3.反问
爱旭太阳能校招快速投递📮
【爱旭股份】2024届校园招聘首场空宣火爆来袭，1000+Offer“职”等你来~[握手]综合年薪（补贴另算）：本科13-21W/年；硕士15-27W/年；博士
爱旭太阳能校招快速投递📮
【爱旭股份】2024届校园招聘首场空宣火爆来袭，1000+Offer“职”等你来~[握手]综合年薪（补贴另算）：本科13-21W/年；硕士15-27W/年；博士
10.10日记
1.lc写题55跳跃游戏 复习最长回文子串最长公共子序列单词拆分最长递增子序列2.复习计网+redis+spring准备货拉拉和第四范式的面试北洋新生启航的获奖
法雷奥舒适驾驶辅助武汉技术中心
有人收到嵌入式软件的意向了吗？
数字马力面试
数字马力面试我选择了时间不合适怎么办#数字马力面试#
农行浙江省分金融科技笔试
三个编程题，难度感觉一般，但是做的不太好，暑假应该好好刷刷编程的唉都在刷SQL
字节真的海
字节还在海是吧智能创作8月初面到现在，以为国庆后是hr面，结果是4面。到底招不招人了还……
救命！我惹hr生气了，怎么办啊？因为我…
救命！我惹hr生气了，怎么办啊？因为我做了一件真的让她…………很失望的事情，行行好，来帮帮我吧因为我没有给她内推到人，呜呜呜，我将失去她了，救命！有人能帮帮我吗
阳光电源
有大佬知道二面是啥面吗，调整面试时间会被直接挂了吗 #阳光电源#
求问牛油，往年工行软开和省分的笔试是分开
求问牛油，往年工行软开和省分的笔试是分开还是一起的啊？
深信服群面 北京站
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86d866676ed7f65cbf951b9fddf9431b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb5291c38edd434ee5d54c8ae8cc2928/" rel="bookmark">
			利用 vlmcsd 搭建 KMS 服务器 激活
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用vlmcsd搭建KMS服务器
5个Windows10关闭自动更新的好方法！
Windows使用vlmcsd部署KMS激活服务器
​
使用 VBox 运行 vlmcsd 的步骤
资源：利用 vlmcsd 搭建 KMS 服务器，Oracle VM VirtualBox 版本
--------------------------------------------------------------
5个Windows10关闭自动更新的好方法！
https://baijiahao.baidu.com/s?id=1776341785811933929
==================================
​
​
利用vlmcsd搭建KMS服务器 https://cloud.tencent.com/developer/article/2232896
摘要：
Windows激活 slmgr.vbs -upk #卸载现有Key
# 或
slmgr /upk #卸载密钥
ver | find “10.0.”&gt;nul &amp;&amp; slmgr.vbs -ipk NPPR9-FWDCX-D2C8J-H872K-2YT43 #输入新Key (Win 10 Ent的GLVK)
# 或
slmgr /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX #安装（指定）密钥，红色部份替换为相对应的系统版本密钥（这里为Windows10专业版密钥）
slmgr.vbs -skms 34.219.129.62
# 或
slmgr /skms 103.47.83.106 #KMS服务器IP） ：设置kms服务器的地址或域名
slmgr.vbs -ato #激活完成。
# 或
slmgr /ato #执行激活
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb5291c38edd434ee5d54c8ae8cc2928/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e0294d3feda2cbae455143e300ca9ff/" rel="bookmark">
			echarts实现伪3D地图、省会坐标涟漪、自动轮播、数据联动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果图：
实现的效果：
伪3D效果地图省会坐标展示标点，并带有涟漪效果鼠标覆盖的区域，区域以及涟漪高亮地图上的所有区域按照时间间隔轮播点击、轮播时的区域，会带着所有其他表格的数据进行联动刷新，展示不同地区的统计数据 完整的JS代码：
let regions = []; let orgRegions = [];// 初始状态颜色 var selectedAreaName = "";// 当前被选中/轮播地市 var mapName = 'NX'; var geoJson = mapData; // 普通涟漪效果的标点 function convertNormalLianyiData(mapData) { var res = []; for (var i = 0; i &lt; mapData.features.length; i++) { var prop = mapData.features[i].properties; //var geoCoord = prop.center;// 标点位于地区省会 var geoCoord = prop.centroid;// 标点位于地区正中心 if (geoCoord &amp;&amp; prop.name != selectedAreaName) { res.push({ name: prop.name, // 横纵坐标后，拼接高度坐标，默认为10 value: geoCoord.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e0294d3feda2cbae455143e300ca9ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74ac2ea07499c775dad6454ca3bca1a6/" rel="bookmark">
			Foxmail 服务器的超大附件服务无效的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、背景
二、解决方案
一、背景 使用Foxmail上传发送附件时，如果附件超过50M大小，则会要求使用中转站。
使用中转站需要登录腾讯企业邮箱，普通用户邮箱无法使用，报错【服务器的超大附件服务无效】。
二、解决方案 1、找到Foxmail的安装目录，进入Global目录。
2、打开domain.ini，将账号和域名的值改为1。
3、重新启动Foxmail，发现设置腾讯普通邮箱成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5ff9f728cc33bb08f69990e3313254c/" rel="bookmark">
			OpenCV中initUndistortRectifyMap ()函数与十四讲中去畸变公式的区别探究
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.十四讲中的去畸变公式2. OpenCV中的去畸变公式3. 4个参数和8个参数之间的区别4.initUndistortRectifyMap()函数源码 最近在使用OpenCV对鱼眼相机图像去畸变时发现一个问题，基于针孔模型去畸变时所使用的参数和之前十四讲以及视觉SLAM中的畸变系数有一点不一样。 1.十四讲中的去畸变公式 首先是十四讲或者视觉SLAM中的方法，针孔模型的畸变系数为[k1, k2, p1, p2],使用以下去畸变公式计算：
2. OpenCV中的去畸变公式 在OpenCV中可以通过initUndistortRectifyMap()函数获得原始图像和矫正图像之间的映射表，然后remap()函数根据映射表对整个图像进行映射处理实现去畸变。
cv::fisheye::initUndistortRectifyMap(K, D, cv::Mat(), K, imageSize, CV_16SC2, map1, map2); cv::remap(raw_image, undistortImg, map1, map2, cv::INTER_LINEAR, cv::BORDER_CONSTANT); 具体实现可以见文章《对鱼眼相机图像进行去畸变处理》
initUndistortRectifyMap()函数的声明如下：
void cv::initUndistortRectifyMap	(	InputArray cameraMatrix, // 原相机内参矩阵 InputArray distCoeffs, // 原相机畸变参数 InputArray R, // 可选的修正变换矩阵 InputArray newCameraMatrix, // 新相机内参矩阵 Size size, // 去畸变后图像的尺寸 int m1type, // 第一个输出的映射(map1)的类型，CV_32FC1 or CV_16SC2 OutputArray map1, // 第一个输出映射 OutputArray map2 // 第二个输出映射 ) 有意思的是，这里的相机畸变参数是可选的，可以是4个参数k1, k2, p1, p2，可以是5个参数k1, k2, p1, p2, k3，也可以是8个参数k1, k2, p1, p2, k3, k4, k5, k6。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5ff9f728cc33bb08f69990e3313254c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b6dac89312fff56d28e8bc9fe851a66/" rel="bookmark">
			springboot &#43; shiro 配置 ehcache 缓存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景： shiro 是支持缓存功能的，它可以对用户的授权数据和认证数据进行缓存，使得用户不必每次认证或授权时都去查询数据库，今天讲下如何将 ehcache 缓存整合到 shiro 中，后续再讲下如何将 redis 整合到 shiro 中。
添加依赖： &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-ehcache&lt;/artifactId&gt; &lt;version&gt;1.6.0&lt;/version&gt; &lt;/dependency&gt; 配置ShiroConfig： 首先在 ShiroConfig 中添加 shiro 的缓存管理器 EhCacheManager ，并将缓存管理器添加到 SecurityManager 中，最后在 CustomRealm 中配置开启缓存，如下所示：
/** * shiro缓存管理器; * 需要添加到securityManager中 * @return */ @Bean public EhCacheManager ehCacheManager(){ EhCacheManager cacheManager = new EhCacheManager(); cacheManager.setCacheManagerConfigFile("classpath:ehcache-shiro.xml"); return cacheManager; } @Bean public SecurityManager securityManager() { DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); securityManager.setRealm(myShiroRealm()); // 将 CookieRememberMeManager 注入到 SecurityManager 中，否则不会生效 securityManager.setRememberMeManager(rememberMeManager()); // 将 sessionManager 注入到 SecurityManager 中，否则不会生效 securityManager.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b6dac89312fff56d28e8bc9fe851a66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ac978ddb6ccd769aabb9e845a0bf81a/" rel="bookmark">
			LONGLORA: EFFICIENT FINE-TUNING OF LONGCONTEXT LARGE LANGUAGE MODELS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文是LLM系列文章，针对《LONGLORA: EFFICIENT FINE-TUNING OF LONGCONTEXT LARGE LANGUAGE MODELS》的翻译。
Longlora:长上下文大型语言模型的高效微调 摘要1 引言2 相关工作3 LongLoRA4 实验5 结论 摘要 我们提出了LongLoRA，一种有效的微调方法，以有限的计算成本扩展预训练的大型语言模型(llm)的上下文大小。通常，训练具有长上下文大小的llm在计算上是昂贵的，需要大量的训练时间和GPU资源。例如，在上下文长度为8192的情况下进行训练，自注意力层的计算成本是在上下文长度为2048的情况下的16倍。本文从两个方面加快LLM的语境扩展。一方面，虽然在推理过程中需要密集的全局关注，但通过稀疏的局部关注可以有效地对模型进行微调。所提出的转移短注意力(S2 -Attn)有效地支持上下文扩展，从而节省大量计算，性能与使用普通注意力进行微调相似。特别的是，它可以在训练中仅用两行代码实现，而在推理中是可选的。另一方面，我们重新审视了上下文扩展的参数有效微调机制。值得注意的是，我们发现LoRA在可训练的嵌入和规范化的前提下可以很好地进行上下文扩展。LongLoRA在LLaMA2模型从7B/13B到70B的各种任务上证明了强有力的实证结果。LongLoRA在单个8× A100机器上采用LLaMA2 7B从4k上下文到100k，或LLaMA2 70B到32k。LongLoRA扩展了模型的上下文，同时保留了它们原来的架构，并且与大多数现有技术兼容，比如FlashAttention-2。此外，为了使LongLoRA实用，我们收集了一个数据集LongQA，用于监督微调。它包含超过3k长的上下文问答对。我们所有的代码、模型、数据集和演示都可以在github.com/dvlab-research/LongLoRA上获得。
1 引言 2 相关工作 3 LongLoRA 4 实验 5 结论 在这项工作中，我们提出了LongLoRA，可以有效地扩展llm的上下文长度，使其显着变大。与标准的完全微调相比，LongLoRA具有更少的GPU内存成本和训练时间，并且具有最小的精度折衷。在体系结构层面，我们建议在训练期间将短暂注意力转移到接近标准的自注意力模式。转移短暂注意力很容易实现，只需要两行代码。此外，通过转移短注意力训练的模型在推理过程中保留了原始的标准注意力结构，使大多数预先存在的基础设施和优化可重用。在训练层面，我们用可训练的归一化和嵌入弥合了LoRA和完全微调之间的差距。我们的方法可以在一台8× A100机器上将LLaMA2 7B模型扩展到100k上下文长度，将70B模型扩展到32k上下文长度。我们认为LongLoRA是一种通用的方法，可以兼容更多类型的llm和位置编码，我们计划在未来进行研究。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ba301ea3315b74629ece97ab5bb8bd3/" rel="bookmark">
			轻松上手：＜Android Studio笔记应用开发＞（二）笔记可显示Part2:定义笔记的数据结构类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 定义笔记的数据结构类型？先想明白下面这些问题！我如何回答前12个问题？为何定义数据结构类型？如何创建数据结构类型？属性的表示方式初始化属性保护属性更多操作 本文将如何定义笔记的数据结构类型？实现步骤第一步，新建java文件第二步，定义属性第三步，创造构造函数第四步，setter与getter方法第五步，更多操作 如果你对代码的实现有疑问，请继续阅读本文求点赞、收藏、评论和关注。更多内容，敬请期待，爆肝更新中.... 定义笔记的数据结构类型？先想明白下面这些问题！ 定义数据结构类型的目的是什么？它的意义何在？是否有其他替代方案？创建数据结构类型的步骤是什么？选择哪些属性来表示笔记？还有其他可能的属性吗？如何表示这些属性？内容通常是纯文本，但创建时间应使用何种数据类型？如何在创建数据结构类型的实例时初始化属性？是在构造方法中接受参数还是使用默认值？如何保护数据结构类型的属性，以确保只有授权的部分可以访问和修改？是否应该使用私有属性并提供公共的getter和setter方法？getter和setter方法是什么？是否有替代方案？除了基本属性之外，是否需要其他方法来执行与数据结构类型相关的操作？ 我如何回答前12个问题？ 为何定义数据结构类型？ 定义数据结构类型的目的是什么？
数据结构类型的创建旨在将相关属性和方法封装到一个独立的对象中，以提高代码的可读性和可维护性。 它的意义何在？
创建数据结构类型有助于清晰地定义数据对象的结构和行为，使应用可以轻松地处理数据的创建、修改、删除和显示。 是否有其他替代方案？
虽然可以使用原始数据结构（如ArrayList或HashMap）来管理数据，但这种做法通常会导致代码混乱，不易维护。因此，创建数据结构类型更符合面向对象编程原则。 如何创建数据结构类型？ 创建数据结构类型的步骤是什么？
创建数据结构类型需要在项目中编写一个Java类文件，其中包括属性和方法的定义。可使用Android Studio或其他Java开发工具来完成。 选择哪些属性来表示笔记？
基本属性通常包括内容、创建时间和标签。但根据应用需求，可以添加其他属性。 还有其他可能的属性吗？
其他可能的属性包括作者、修改时间、优先级、颜色等，具体取决于应用的需求。 属性的表示方式 如何表示这些属性？
内容可以表示为字符串，而创建时间可以用日期对象或时间戳表示，标签可以是字符串或枚举类型，具体取决于数据的性质。 内容通常是纯文本，但创建时间应使用何种数据类型？
通常情况下，创建时间应使用日期对象表示，以便于日期操作。这可以更容易地格式化日期和计算时间间隔。 初始化属性 如何在创建数据结构类型的实例时初始化属性？是在构造方法中接受参数还是使用默认值？ 属性的初始化可以通过构造方法接受参数或使用默认值进行。具体取决于应用需求，某些属性可能需要强制初始化，而其他属性可以使用默认值。 保护属性 如何保护数据结构类型的属性，以确保只有授权的部分可以访问和修改？是否应该使用私有属性并提供公共的getter和setter方法？
为了保护属性，通常将其声明为私有（private），并提供公共的getter和setter方法以控制属性的访问权限。这种封装机制提供了数据的封装性和安全性。 getter和setter方法是什么？是否有替代方案？
Getter方法用于获取属性的值，Setter方法用于设置属性的值，它们是标准的属性访问方式。虽然有替代方案，如直接访问属性，但使用getter和setter方法更好地封装和控制属性访问。 更多操作 除了基本属性之外，是否需要其他方法来执行与数据结构类型相关的操作？ 可根据需求在数据结构类型中定义其他方法，如格式化内容、计算字符数、生成摘要、检查数据是否包含特定关键词等。 本文将如何定义笔记的数据结构类型？ 新建Java文件并命名为NoteDataStructure仅包含三个属性：序号（id）、内容（content）、时间（time）使用setter和getter方法 实现步骤 第一步，新建java文件 打开Android Studio
java class
右键下图红色区域
鼠标左键点击下图红色区域
随便起个名字
这边起名为NoteDataStructure
建好了
第二步，定义属性 如前文所言，我这里定义3个属性：
private long id; private String content; private String time; 当然，你也可以自行定义更多属性
比如标签、颜色、优先级、位置、作者等
private String tag; private String color; private String priority; private String location; private String author; 以上只是举例，实际上用什么数据类型表示这些属性完全取决于你的应用需求和设计。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ba301ea3315b74629ece97ab5bb8bd3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6eeb2511e8a3820cfe368dad5c043f56/" rel="bookmark">
			Elasticsearch安装、使用，Springboot整合Elasticsearch详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Elasticsearch 是一个分布式、RESTful 风格的搜索和数据分析引擎，能够实现近乎实时的搜索。
Elasticsearch官网https://www.elastic.co/cn/
这篇文章主要简单介绍一下Elasticsearch，Elasticsearch的java API博主也在学习中，文章会持续更新~
目录
第一步：下载Elasticsearch
下载7.6.2版本
下载其他版本
第二步：安装Elasticsearch
第三步：安装kibana
第四步：Springboot整合Elasticsearch
1、创建springboot项目
2、在pom.xml中添加依赖
3、修改配置文件
4、创建数据库和es的实体类
5 、创建mapper接口及映射文件
6、创建Elasticsearch的查询接口
7、开启mapper包扫描
第五步：从mysql导入数据到es
第六步：学习DSL
1、无条件查询，默认返回10条数据
2、指定返回的数据条数
3、指定查询字段
4、分页查询
5、查询指定ID的数据
6、删除索引
7、条件查询
第七步：在java中使用Elasticsearch
1、通过ElasticsearchRepository
2、通过ElasticsearchRestTemplate
3、通过RestHighLevelClient
第一步：下载Elasticsearch 下载7.6.2版本 文章中使用的Elasticsearch版本是7.6.2，可以通过以下网盘链接下载，里面有7.6.2版本的ik分词器，链接永久有效。
elasticsearch7.6.2下载https://pan.baidu.com/s/1D_HS8w_WW3dfQllGzNGv8A?pwd=p3aa
下载完成后，把下面选中的Elasticsearch压缩文件解压到D盘
然后把ik分词器解压到Elasticsearch的plugins目录下，并把文件夹名称修改为ik。
下载其他版本 如需安装其他版本，可自行在官网下载。
1、访问官网，在首页点击页面上方的【文档】
2、点击All Elastic docs
3、点击选择other versions
4、在左侧版本列表选择对应的版本，点击对应链接，比如选择7.6.2版本
5、然后点击Installing the Elastic Stack
6、 在页面找到Elasticsearch，点击后面的install instructions（安装说明）
7、然后找到对应操作系统，比如windows，只需要点击Install Elasticsearch with .zip on Windows
8、在打开的页面向下滚动，找到Download and install the .zip package
9、点击后面的zip压缩文件链接开始下载https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.6.2-windows-x86_64.zip
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6eeb2511e8a3820cfe368dad5c043f56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7eda1ad1d8df9b4e8eb56d6af614daa/" rel="bookmark">
			某果的一个小参数分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分析链接:aHR0cHM6Ly9hcHBsZWlkLmFwcGxlLmNvbS9hY2NvdW50
分析目标：X-Apple-I-Fd-Client-Info
1.在浏览器搜索关键词，打下断点 我们再里面进行搜索，定位到这个位置，可以看到X-Apple-I-FD-Client-Info这个参数等于e，这个e等于ai.getBrowserData()这个函数，我们打下断点跟一下看看。下断点，刷新一下页面看看。
2.找到getBrowserData()函数 跟踪到这个函数，可以看到创建了一个input元素，设置了一下这个input元素的一些属性。调用了一些window.dcHelper.setData函数，传入Za函数。后面获取了一下刚刚创建的input的值。
然后继续跟。
大概代码放到这里。
window.dcHelper = new function() { this.setData = function(e) { var t; e: { if (null == (t = document.getElementById(e))) null != (n = document.getElementsByName(e)) &amp;&amp; 0 &lt; n.length &amp;&amp; (t = n[0]); if (null == t) for (var n = 0, r = document.forms.length; n &lt; r; n++) for (var a = 0, i = document.forms[n], o = i.elements.length; a &lt; o; a++) { var s = i[a]; if (s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7eda1ad1d8df9b4e8eb56d6af614daa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c675367ff6f37ad03e6095bfab0008ea/" rel="bookmark">
			Java-Stream的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java-Stream的使用 创建不可变集合 定义 定义：不可变集合即不可以被修改的集合。
不可变集合的应用场景：
如果某个数据不能被修改，把它防御性地拷贝到不可变集合中是个很好的实践。当集合对象被不可信的库调用时，不可变形式是安全的。 如上图电脑硬件信息一般都不可变，因此将其放在不可变的集合中。
简单理解：不想让别人修改集合中的内容。
创建不可变集合的书写格式 在List、Set、Map接口中，都存在静态的of方法，可以获取一个不可变的集合。jdk1.9以上才支持
方法名称说明static List of(E…elements)创建一个具有指定元素的List集合对象static Set of(E…elements)创建一个具有指定元素的Set集合对象static &lt;K , V&gt; Map&lt;K,V&gt; of(E…elements)创建一个具有指定元素的Map集合对象 注意：这个集合不能添加，不能删除，不能修改。
创建不可变的List集合 创建
public class ImmutableOfList { public static void main(String[] args) { /** * 创建不可变的List集合 * "李白","铠","兰陵王","小乔","大乔","孙策","周瑜","诸葛亮" */ //一旦创建完成，就不能修改 List&lt;String&gt; list = List.of("李白","铠","兰陵王","小乔","大乔","孙策","周瑜","诸葛亮"); for (String s : list) { System.out.print(s + " "); } } } 创建不可变集合后，往集合中添加、修改、删除数据则会报UnsupportedOperationException的错如下
import java.util.List; /** * @Author LiTeng * @Date 2023/10/9 10:57 * Version 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c675367ff6f37ad03e6095bfab0008ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ca9faa76e1f3c338bc5e7ae4e23b47f/" rel="bookmark">
			创建vue3项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要介绍在已经安装配置好nodejs的情况下，利用vuecli创建vue项目，步骤如下：
一、利用vuecli创建vue项目 1、全局安装脚手架vuecli3 （1）全局安装脚手架
（2） 检测vue版本
2、创建vue项目 以搭建一个项目名称为vue_blog_web为例：
如果项目名称在该目录下已经创建，则会出现以下选项：
其中overwrite是覆盖已存在的文件夹；merge是合并两个文件夹；cancel是取消操作。
点击确认后，进入以下界面：
（1）选择Manually select features
x
其中default是默认创建，manually select features是手动选择创建，即按需配置vue项目。
（2）选择项目特性（空格是选中，上下是选择）
其中：
Babel：是转码器，用于兼容低版本浏览器，建议选上。
TypeScript：是TS语法。
Progressive Web App (PWA) Support：渐进式web应用程序。（不知道能干嘛，求大佬解答）
Router：路由vue-router，建议选上。
Vuex：用于管理vuex状态，建议选上。
CSS Pre-processors：css预处理器，建议选上。
Linter / Formatter：格式校正，用于严格规范自身的代码格式，建议选上。
Unit Testing：单元测试。
E2E Testing：E2E测试。
（3）选择vue.js版本
（4）选择CSS预处理语言（此处我选择less）
（5）选择ESLint代码规范（此处我选择只进行报错提醒）
其中：
ESLint with error prevention only：只进行报错提醒。
ESLint + Airbnb config：不严谨模式。
ESLint + Standard config：正常模式。
ESLint + Prettier：严格模式
（6）选择何时进行代码检测（此处选择保存时检测）
第二个选项是修复提交时检测。
（7）选择 Babel、PostCSS、ESLint等配置文件的存放位置（此处选择单独保存在各自的配置文件中）
（8）配置完成后等待初始化。
二、vue create和vue init webpack的区别 1、vue create：是vue-cli3.x版本的初始方式，启动方式默认为npm run serve。其中模板是固定的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ca9faa76e1f3c338bc5e7ae4e23b47f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7017e1f579a6158cb701d62a0f025d31/" rel="bookmark">
			【C&#43;&#43;】面向对象编程（六）在派生类中定义一个虚函数、虚函数的静态解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在派生类中定义一个虚函数 定义派生类时： 将基类中的虚函数覆盖掉：派生类提供新定义，所声明的函数原型必须完全符合基类所声明的函数原型（包括：参数列表、返回类型、常量性）；原封不动继承基类中的虚函数；如果继承的是纯虚函数，则这个派生类也会被视为抽象类，无法为它定义任何对象。 在派生类中，如果其基类的同名成员函数已声明为虚函数，则派生类的同名成员函数声明和定义前不用加virtual，即为了覆盖基类的某个虚函数，而进行函数声明时，不一定得加上关键字virtual，编译器会自动根据两个同名函数的原型声明，决定某个函数是否会覆盖其基类中的同名函数。 class num_sequence{ public: virtual const char*what_am_i()const{return "num_sequence\n";} //... }; class Fibonacci : public num_sequence{ public: virtual const char* what_am_i(){return "Fibonacci\n";} //编译器报错：基类声明为const，派生类却是non-const //... }; 返回类型必须完全吻合“的一个例外——当基类的虚函数返回某个基类形式（通常是指针或者引用）时，派生类中的同名函数便可以返回该基类所派生出来的类型： class num_sequence{ public: //我们想让派生类的clone()函数可返回一个指针， //指向基类num_sequence的任何一个派生类 virtual num_sequence *clone() = 0; //... }; class Fibonacci : public num_seuqence{ public: //派生类同名函数不用加virtual Fibonacci *clone(){return new Fibonacci(*this);} //... }; 虚函数的静态解析 为了能够在“单一对象中展现多种类型”，多态需要一层间接性。在C++中，唯有用基类的指针和引用才能够支持面向对象编程概念
虚函数机制无用的两种情况：
基类的构造函数和析构函数里；使用的是基类的对象，而非基类对象的指针或引用。 所以，在基类的构造函数中，派生类的虚函数绝对不会被调用；基类的析构函数同理。
示例分析：
以下代码中，AudioBook是基类LibMat的派生类，print()在类继承体系中是个虚函数： void print(LibMat object, const LibMat *pointer, const LibMat &amp;reference) { //以下必定调用LibMat::print() object.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7017e1f579a6158cb701d62a0f025d31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5de3c54a1675e77d4741f6fff0c46725/" rel="bookmark">
			（三）Apache log4net™ 手册 -演示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0、引言 在开始本文之前，推荐您首先阅读 Apache log4net™ 手册中有关 介绍 与 配置 的相关内容。本文将通过实践分别为您演示如何使用 Visual Studio 2022 在 .NET Framework 项目和 .NET 项目下配置并使用 Log4Net。
1、为 .NET Framework 项目配置 Log4Net 1.1、先决条件 一个简单的 .NET Framework 项目（比如：控制台应用(.NET Framework)） 1.2、引用 Log4Net NuGet 包 在 1.1 小节中，笔者创建了一个新的 .NET Framework 控制台项目。解决方案名称为 “Log4NetDemo”, 项目名称为 “ConsoleApp4DotNetFramework”：
项目目标框架为 .NET Framework 4.8.1
前往 Visual Studio 菜单栏的【工具】-【NuGet 包管理器】-【管理解决方案的 NuGet 程序包】：
在打开的标签页中切换到【浏览】页面，搜索 “Log4Net” 并选中；在右方的配置页面勾选要安装的项目，点击【安装】按钮：
安装完成后，可以看到解决方案资源管理器内新增了一个 package.config 文件：
内容如下：
1.3、配置 Log4Net 完成 1.2 小节的内容后，在解决方案资源管理器内右击项目名称，点击【添加】-【新建项】。在打开的对话框中搜索找到“应用程序配置文件” C# 项，修改文件名为 log4net.config，点击【添加】：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5de3c54a1675e77d4741f6fff0c46725/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dcfb187ddebc4a4bc37817fae597c86/" rel="bookmark">
			flask python 设置定时任务 flask 周期性执行任务方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		flask 通常使用 flask_apscheduler 框架设计定时任务，flask_apscheduler 功能很全面，能按设定的时间规则执行任务，可以持久化到各类数据库（mysql，redis，mongodb），实现对定时任务增、删、改、查等操作。
安装 pip3 install flask_apscheduler 1、调用方法 方法一：使用 Config 类配置时间规则 from flask import Flask from flask_apscheduler import APScheduler class Config(object): # 列表类型，如有需要可以定义多个job JOBS = [ { 'id': 'job_1', # 一个标识 'func': '__main__:job1', # 指定运行的函数 'args': (1, 2), # 传入函数的参数 'trigger': 'interval', # 指定 定时任务的类型 'seconds': 5 # 运行的间隔时间 } ] SCHEDULER_API_ENABLED = True def job1(a, b): # 运行的定时任务的函数 print(str(a) + ' ' + str(b)) if __name__ == '__main__': app = Flask(__name__) # 实例化flask app.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4dcfb187ddebc4a4bc37817fae597c86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d084bb7b1ea7a55917a4c932dba9b0cb/" rel="bookmark">
			JAVA--一次性输入一行数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 使用循环逐个输入（类C） 首先需要创建一个用于输入的Scanner对象，然后使用循环来连续读取输入。当需要输入的数目未知或数目不确定时，这是一个常见的做法。
import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int[] numbers = new int[5]; // 假设要输入5个整数 for (int i = 0; i &lt; numbers.length; i++) { System.out.println("请输入第 " + (i + 1) + " 个整数："); numbers[i] = scanner.nextInt(); } // 现在，numbers数组包含了输入的整数 } } 将输入的整数作为字符串处理，然后通过切片和数据类型转换(类Python) import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d084bb7b1ea7a55917a4c932dba9b0cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9278019ac31f0a1b735e33c992235613/" rel="bookmark">
			MySQL 安装&#43;启动&#43;报错的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、安装准备
1.1 下载
1.2 版本说明
二、安装步骤
2.1 解压缩
2.2 配置环境变量
2.3 配置文件
2.4 安装
2.5 启动/停止服务
三、使用说明
3.1 用户名密码登录
3.1 设置用户名密码
四、卸载步骤
4.1 卸载服务
五、安装问题
六、启动问题
6.1 提示【服务无法启动】
6.1.1 问题描述
6.1.2 解决方案
一、安装准备 1.1 下载 1、MySQL官网地址MySQLhttps://www.mysql.com/
2、点击【DOWNLOAD】菜单。
往下翻，点击【MySQL Community (GPL) Downloads】连接。
选择【MySQL Community Server】选项，下载MySQL。
1.2 版本说明 本文档编写时，使用的是8.0.26-win64的解压缩版本。
二、安装步骤 2.1 解压缩 将压缩包解压缩到目标目录。
2.2 配置环境变量 1、【我的电脑/此电脑】右键，点击【属性】，选择【高级系统配置】
2、点击【环境变量】，在弹出框中，选择新建【系统变量】。
变量名建议为：MYSQL_HOME；变量值为MySQL的解压路径；
3、在【系统变量】中找到Path变量，并新增MYSQL的环境变量。
2.3 配置文件 将如下内容拷贝到名为my.ini的文件中，并将其放入到解压根目录中。
其中，较为重要的配置为：
# 设置mysql客户端连接服务端时默认使用的端口；
port=3306
# 设置mysql的安装目录；
basedir="D:\mysql\"
# 设置mysql数据库的数据的存放目录；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9278019ac31f0a1b735e33c992235613/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f9e5a21b9e7191328cbb850c731f0fa/" rel="bookmark">
			读书笔记--未来简史关键金句和阅读感悟
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		借着国庆假期，终于有时间研读了尤瓦尔.赫拉利的《未来简史》，作者的写作方式、文笔、观察视角都是我喜欢的类型，作者从古到今，谈到了上帝、神、宗教、科技、生物、智人到未来的超人智神（数据主义），让我们感受到一场人类如何从众多动物中脱颖而出，引领主导世界这么多年，同时借助生物科技和计算机技术的发展，展望世界未来发展，对于我们人类来说，作者在第三部分写的比较悲观，但这何尝不是一种历史发展的趋势呢，如果人类要从小小的地球走向太阳系、银河系，甚至宇宙，我倒是觉得这种预测也不失为一种未来发展的预测，特别是目前各行各业都在大力开展数字化转型和智能化建设，这种趋势是必然，甚至在某些局部场景环节，正如作者所说，数字化关联化之后，智能化的算法将比我们人类更精准更了解我们自身。
从古至今，人类面临的三大问题：饥荒、瘟疫和战争。人类区别于其他动物的区别之一就是经过一代代的进化，发明了各种工具、制度和社会系统，目前生物科技和信息技术给人类带来的强大新力量，使得人类将注意力和创造力放在如何健康、繁荣和谐。对于饥荒问题，目前真正造成的饥荒原因是政治或意识形态因素，基本不存在饥荒，而是存在饮食过量。对于瘟疫问题，自然形成的瘟疫，人类基本都有相应的预防或治疗措施，但由于意识形态的斗争，导致人为制造病毒传染病等等频繁发生，比如看不见的舰队引发的黑死病。对于战争问题，其实战争在逐渐消失，特别是全球经济从原来的物质经济变为知识经济，知识作为最重要的经济资源。这些问题的成功解决，就孕育了更大胆的目标和野心，在21世纪，人类未来的第一个议题，人类转向长生不老的目标；人类未来的第二个议题是找到幸福快乐的乐趣，生命的唯一目的就是快乐，人类如何将自己升级为神，有三条路径：生物工程、半机械工程和非有机生物工程；人类第三个议题是获得神性，及人类取得神一般的创造力和毁灭力。智人进化是一个渐进的历史过程，并在过程中持续与机器人和计算机融合，直到人类不再是人类。在这个进化过程中我们无法踩刹车，因为没人知道刹车在哪里，踩下刹车可能会让经济崩溃，无法预测人工智能的突破对纳米技术有什么影响。
研究历史并不能告诉我们应该如何选择，但至少能给我们提供更多的选项，研究历史不是为了预测未来，而是要摆脱过去，想象另一种命运。通过一段关于草坪的进化历史，讲述了草坪在人们心中代表了社会地位、经济实力（贵族）、政治权力象征、重大社交活动。
以下是本书三部分的内容摘编，本书主要分为三部分：智人征服世界、智人为世界赋予意义和智人失去控制权。
一、智人征服世界 开篇阐述了智人和其他动物的关系，以及人类这个物种的特殊性，讨论人类身为动物的过去，以及与其他动物的关系，这种关系很可能就是未来超人和人类的关系。科学将地球的历史分为不同的世，如更新世、上新世、中新世到人类世，智人逐渐改变了游戏规则，使得其他动物逐渐灭绝，特别是大型动物。农业革命让人类有了确保家畜生存繁衍能力，但忽视了其主观需求、感觉和情感，其实所有哺乳动物都有情感，情感是是所有动物生存和繁衍至为关键的生物算法，也就是说生物也是算法，算法是进行计算、解决问题、做出决定的一套有条理的步骤，算法是计算时采用的方法，算法也是一瞬间经历了袭来的种种感觉、情感和欲望。农业革命即是经济上的革命，也成了宗教上的革命，使得各种宗教强调人类与生态系统其他部分的密不可分，促成了神论宗教，崇拜神，后面的科技革命催生了人文主义革命，使得人取代神，崇拜人。
人类有哪些特质，一个问题是人类认为，智人是目前世界上最强大的物种，智人自己认为自己的伦理地位较为高尚，生命比猪、大象或狼更有价值。为什么说人类有灵魂，而其他动物没有呢？达尔文的进化论的基础是物竞天择、适者生存，进化论又无法解释人类有灵魂，灵魂是不可分割、永恒不变的，进化就是变化，部分有可能突变、但不可能永恒，进化无法产生永恒不变的实体，也就是说进化论无法解释人类有灵魂，而其他动物没有灵魂。另一个问题是意识问题，为什么股票交易所没有意识？心灵是脑中的主观体验的流动（如痛苦、快乐、愤怒和爱），主观体验有两个基本特征即感觉和欲望，意识是由大脑中的电化学反应产生的，这样的心理体验能完成某些重要的数据处理功能，但是，大脑如何通过这些电化学反应创造出主观体验的流动呢？这个问题至今未知，其实人类世认为计算机究竟有没有意识并不重要，重要的是人类会怎么想。汉斯（马）能够从人的肢体语言和面部表情看出答案，人类对动物强加了人性，反而低估了动物的认知能力，忽略了其他生物的独特能力，相比较其他动物，智力和制作工具是人类兴起的关键因素，其他因素就是基于我们想象秩序下，开展与陌生人的团结合作能力，提高了合作效率和更大的灵活性。人类认为现实又三种，即客观现实、主观现实和互为主体现实，主观现实取决于个人的信念和感受，互为主体的现实是依靠许多人类的沟通互动而存在，比如金钱本身并没有客观价值，不能吃不能穿，但大家都相信他的价值后，能够用来买吃喝用等等，这就是智人编织的互为主体的意义之网，其中的法律、约束力、实体和地点都存在于大家共同的想象中，研究发现动物只能想象世界上实际存在的东西，而人类可以想象虚幻的事物，人类具备丰富的想象力，能够创造出互为主体的实体，而人文科学强调的就是互为主体的实体，随着人类的各种虚幻想象转换为基因和电子代码，互为主体现实将逐步吞没客观现实，可以说，虚幻想象是未来世界上最强大的力量，从而为智人征服世界做好了储备。
二、智人为世界赋予意义 在智人征服世界之后，为了长久和合理性，智人在过去数千年间创造了怎么样的光怪陆离的世界，并为世界赋予意义，明确人类是所有意义和力量的来源。认为宇宙的中心是人类，并对社会、经济和政治产生影响，塑造我们的日常生活、艺术及深层次的欲望。人文主义将逐渐成为所有人最重要的宗教信仰。
智人除了熟悉客观现实和主观现实外，还能编织关于金钱、神、国家和公司的虚构故事，而且这种能力在进化过程中不断加强，同时苏美尔人还发明了文字和货币，让人突破了人类大脑的数据处理限制，比如法老、猫王品牌的创造，相当于一个故事、神话或品牌，同时，有了文字和货币之后，人类就可以催生出更强大的虚拟实体，人类能够以算法的方式组织整个社会，每个人相当于算法中的一个小步骤，最后形成整个算法，这正是官僚体系构建的本质。 结合宗教的发展，人类合作网络的力量就是依赖于真实与虚拟之间的微妙平衡，构建各类组织形成了虚构规则，能够将虚构的信仰建立在一个让人顺从的现实之上，虚构故事让人类更容易合作，评价合作网络的好坏，取决于什么标准和观点，历史绝不是单一的叙事，而是有着成千上万种不同的故事，我们选择一种叙事，就会导致其他叙事故事的失声，其实不管哪种虚构故事的构建延续，都是为人类服务的，在生物科技和计算机算法的协助下，这些宗教不但会控制我们的每时每刻，甚至塑造我们的身体、大脑和心灵，创造完整的虚拟世界。
虚构故事是人类社会的基础和支柱，如虚构国家、公司、货币、银行和神等，随着科学的发展，强化的神话，科学和宗教的差距更小，使得虚构和现实的界线模糊了，但宗教和灵性的差距变大了，宗教是对世界提出一套完整的描述，并提供一份定义清晰且载明各项预定目标的契约，宗教用于巩固世俗秩序，而灵性是一个旅程，是古代二元论宗教的遗产，相信一善一恶，是未来逃离世俗秩序，灵性一般以悲剧收场，灵性之旅就是推翻旧制度、建立新法则、制度和仪式，但人类是要合作的，不能只有问题，而是需要坚定的答案，灵性即使推翻了就社会，也需要合作形成新的社会新的宗教。人类的价值观隐藏着一个事实声明，即将痛苦最小化，快乐最大化。科学和宗教说白了是互相妥协，共存合作的，宗教最在乎秩序，创造和维持社会秩序，而科学最在乎力量，但总体来说，两者对真理的喜好远不及秩序和力量，现代历史就是科学和宗教达成协议的过程，现代社会相信人文主义教条，科学的用途是为了实现这些教条，而不是质疑这些教条。
人类从生下来那一刻起就签了契约，签约让人类同意放弃意义来换取力量，在现代社会之前，宇宙计划让人的生命有意义，但同时限制人的力量，传统观念将世界看出一块大小固定的饼，假设世界只有两种资源：原材料和能源，但其实世界上还有另一种资源，即知识，而且知识是不断增长、用的越多，反而拥有越多，原来大家认为各种宗教经典和古老传统已经提供了世界上所有的重要的知识，但科学发展最大的发现是让人类发现自己的无知，现代经济最大的敌人是生态崩溃，进而将导致经济崩溃、政治动荡即人类生活水平下降，甚至对人类文明造成威胁。其实导致这种情况的主要因素是人类想要更多，是人类的贪婪造成的。
人文主义革命让人类摆脱了人生无意义，存在无依据的困境，人文主义宗教崇拜人性，认为人类体验为宇宙赋予了意义，为无意义的世界创造意义，人文主义认为艺术创作和美学价值的唯一来源就是人的感受，人的感受是一切意义和权威的源头，现代人文主义教导大家要自己思考，重要的是你自己对这些事物的看法，相当于从上帝或神转移到了人类内心，也就是上帝已死。在中世纪，知识=经文*逻辑，科学革命时期，知识=实证数据 *数学，但无法处理价值和意义问题，需要回到中世纪的圣经中找答案，人文主义革命时期，知识=体验*敏感性，体验和敏感性形成一个互相加强的无限循环，没有必要的敏感性就无法体验到某些事物，没长期的体验就无法培养敏感性，体验是一种主观现象，包括知觉（热、愉悦、紧张）、情绪（爱、恐惧、愤怒）和想法；敏感性一是要注意到自己的知觉、情绪和想法，一是允许这些知觉情绪想法影响自己，人文主义认为生命是一种内在的渐进变化过程，靠着体验从无知走向启蒙，在生命的最广泛体验中，提炼出智慧，生命只有一座要征服的高峰，设法体验一切身为人的感觉。中国的哲学认为，世界由阴阳两种相对而又相依的力量维系，每股科学的阳都包含着一股人文主义的阴，阳给我们力量，阴提供了意义和伦理判断，总之，人文主义重点关注感受和体验。
随着人文主义的发展，又分裂成三大分支：正统派自由人文主义，社会人文主义和进化人文主义。
正统派自由人文主义认为每个人都像是一道不同的光线，通过不同角度照亮世界，不管在政治经济和艺术中，个人自由意志都比国家利益和宗教原则更为重要，认为个人选民能做出最好的选择，这种主义无法解决当所有的权威和意义都来自于个人体验，当发生冲突时怎么办？民主投票通常也只适用于有一群共同关系的人。
社会人文主义注重他人感受，注意自己的行动如何影响他人体验，认为政党能做出最好的选择，工会永远时对的，建立强有力的集体制度。
进化人文主义来源于达尔文的进化论，认为冲突是福不是祸，能促成自然选择，推动进步，认为战争是生命的学校，强调的是进化升级。
不管哪种人文主义，自由主义的核心思想仍然是个人自由、坚信选民最清楚，顾客永远是对的思想。
科技和宗教总是跳着一支优雅微妙的探戈，互相推动，互相依存，不能离得太远。马列主义作为社会人文主义之所以成功，主要是因为他们更努力地理解当代的科技经济现实，让整个国家能够监控和协调国内所有活动。
进入21世纪，特别是生物科技和计算机算法的力量，需要我们不断的做实验进行亲自实践，后续可能出现后人文主义，将人类的体验做出可设计的产品，那样的话，人类有可能就被替代了。
三、智人失去控制权 在智人统治了世界好多年后，随着生物科技和计算机技术的发展，该部分讲述了智人目前的困境和可能的未来，人类面临失去控制权，人文主义将崩盘，取而代之的是数据主义。
纵观历史，早已见证了许多宗教、帝国和文化的起起落落，这样的动荡不一定是坏事，这样想的话，人文主义的崩塌也是好事，人们之所以不愿意改变，是因为害怕未知，但历史唯一不变的事实就是一切都在改变。
人类有自由意志，但自由意志与当代科学是存在矛盾的，科学不仅破坏了自由主义对自由意志的信念，也破坏了对个人主义的信念，第一个实际威胁就是人类不再具备军事和经济上的用途。人类大脑分为左右脑，左脑在语言和逻辑推理时扮演重要角色，右脑在处理空间信息时有较大优势。
人体内至少有两个自我：体验自我和叙事自我，体验自我是我们每时每刻的意识，没有记忆能力，不会讲故事，叙事自我是在我们要唤起记忆，做重大决定时才启用的，类似于记者、诗人或政治人物，不会叙述所有细节，只会用事件的高潮和最后结果来编织故事，相当于峰值和终点的平均值，两者并非各自独立，而是紧密交织的，叙事自我宁可在未来继续痛苦，也不想承认过去的痛苦完全没有意义，自我也像国家、神和金钱一样，知识虚构故事，自由主义认为，我们不应该期待外界为我们提供现成的意义，应该用自己的自由意志创造意义，创造整个宇宙的意义。
自由主义推崇自由市场和民主选举，智能和意识脱钩，智能是必要的，但意识可有可无，回想起工业革命前后，马被汽车所代替，原因是汽车在社会系统的真正需要的那少数几个领域胜出了，就能替代马作为交通工具了，作为类比，人工智能（IBM的沃森）在某些领域可以取代医生了，因为他存放着所有已知疾病与药物信息，不仅熟知我的基因组，完整病史，而且知道我的兄弟姐妹、父母等的基因组和病史，而且也从来不感觉到累了、饿了或病了，可以随时为我诊断。未来人工智能只要在特定行业需要特定能力上超过人类，就能将人类挤出该就业市场。尤其目前拥有绝大多数地球的正是各种非人类的互为主体的实体，即国家和公司。因此，为了不被淘汰，人类需要一辈子不断学习，不断打造全新的自我。21世纪科技的发展，让外部算法有能力比我更了解自己，通过数据，认识自己，让人觉得自己是许多生化系统的集合，而不是不可分割的个体，例如安吉丽娜.朱莉在纽约时报发表的如何决定进行双乳乳腺切除术，这都是算法和统计数据库的功劳，并且朱莉本人接受算法建议。如果等到谷歌、facebook和其他算法成为无所不知的先知之后，很可能进一步进化为代理人，最后成为君主，再比如Waze、Cortana等等。
21世纪的新科技可能会彻底扭转人文主义革命，让人类交出权威，送到非人类算法手中，这是生物学家的责任，生命科学认为，生物就是各种算法，相当于拆除了有机和无机之间的那堵墙，将权威个人转移到计算机网络。这样可能导致不平等的再升级，自由主义面临三大实际威胁：1.人类将完全不具有价值；2.人类整体仍然有价值，但个人将不再具有权威，而是由外部算法来管理，算法对你的了解将超越你自己；3.有些人仍然不可或缺，算法系统也难以了解，而且形成了一个人数极少的特权精英阶层，由升级后的人类组成，相当于大多数人是低等阶级，受到计算机和新兴的超人类控制主导。这样就摧毁了自由主义意识形态的根基。20世纪的伟大成就是克服饥荒、瘟疫和战争，让所有人享有富足、健康与和平，21世纪的新议题将是获得永生、幸福快乐、化身为神，希望为人类服务。
这种新的科技宗教分为科技人文主义和数据主义。
科技人文主义希望让人类的心智升级，接触到目前未知的体验、未闻的意识形态，随着人类社会的发展，嗅觉、注意力和做梦能力都不如从前，科技人文主义最后可能反而让人类降级，让人类少了可能拖慢的系统、造成困扰的人类特质，人文主义认为，只有人的欲望才能使世界充满意义，两难抉择时人的意志是宇宙中最重要的东西，同时人类在开发能够控制、重新设计意志的科技，如果真能设计出控制意志的产品，科技人文主义将何去何从，只要我们相信人类的意志和经验是权威和意义的本源，就无法处理与科技的关系。
数据主义认为，宇宙是由数据流组成的，任何现象或实体的价值就在于对数据处理的贡献，达尔文的物种起源认为生物体就是生化算法，图灵机认为信息科学家可以写出越来越复杂的电子算法，数据主义将传统的学习金字塔彻底翻转（即数据--信息--知识--智慧），数据主义对人类知识和智能有所怀疑，信任大数据和计算机算法。数据主义的母学科是计算机科学和生物学，经济学家也越来越常用数据处理系统的概念来诠释经济，经济机制就是收集关于欲望与能力的数据，再转化为决策，比如资本主义和国家控制的共产主义就不是意识形态、伦理教条或政治制度上的竞争，而根本不同是不同数据处理系统间的竞争，资本主义采用分散式处理，共产主义采用集中式处理。政治科学家也逐渐把人类政治结构理解成数据处理系统，即民主与专制，即分散与集中式处理机制。
人类历史就是一个数据处理过程，如果将全人类看作单一的数据处理系统，每个个人都是里面的一个芯片，整个历史进程就通过4种方式来提高系统效率，即增加处理器数量（人数），增加处理器种类（运算和分析数据的方式不同，增加动力和创意）、增加处理器之间的连接（关联）、增加现有连接的流通自由度（自由流通），智人数据处理系统的构建分成四大阶段：1.认知革命，能够将大量智人连接为单一数据处理网络，分散到不同区域，感受不同气候，彼此失去联系，牺牲了连接，2.农业革命开始，大约5000年前，发明了文字和金钱，形成密集网络仍然分散为无数个小部落，3.开始于5000年前，发明了文字货币，结束于科学革命，人类摆脱了离心力，使得各个团体融合起来，形成城市和王国，4.始于1492年，信息在全球网络里越来越自由的流动，民主和自由市场胜出，改善了全球数据处理系统，这一系统的最终产出物就是效率更高的数据处理系统，即万物互联网，人类式创造万物互联的工具，而且这个系统比人类吸收更多的数据，处理信息算法的效率比人高（从生物科学的角度来说，人类情感和智力不过都是算法），数据主义也类似于其他宗教，有其诫命，其一是连接越来越多的媒介，产生和使用越来越多的信息，让数据流最大化，其二是将一切连接到系统，甚至异端也连入，数据主义认为信息自由是最高的善，一切的善来自于信息自由，数据主义相信数据流带来了新的发明和破坏，而且不在任何人的计划、控制或理解之中，没人真正理解全球经济如何运作，正如市场是资本主义那只无形的手一样，数据流也是。人类可以把自己的体验吟成诗，写成博客，再发表在网络上，丰富全球数据处理系统，可以说人类体验就是世界上最有效的数据处理算法或数据模式。
上帝是人类想象的产物，人类的想象力一样知识生化算法的产物，人文主义将以神为中心的世界观走向以人为中心，而21世纪，将以人为中心走向以数据为中心，几百万年以来，人的感觉就是全世界最好的算法，到了21世纪，我们正在开发更优秀的算法，能够充分利用前所未有的运算能力和庞大数据库，从聆听自己内心的声音转变为聆听算法的意见，数据主义认为人类大脑无法理解新的终极算法，数据流多会能够产生意识和主观体验还是个未知问题，数据主义对人类的威胁，正如人类对其他动物所造成的威胁，回首过去，人类也许会成为数据流里面的一片小小的涟漪。
其实我们无法真正预测未来，因为科技并不能带来确定的结果，人工智能和生物科技的兴起肯定会改变世界，但不代表只能是一种结局。过去阻挡思想言论的做法是阻挡信息流通，但在21世纪，反而是需要用不相关的信息淹没思想言论。未来需要我们继续关注以下三个方面的发展和三项关键问题。
1.科学正逐渐聚合于一个无所不包的教条，也就是认为所有生物都是算法，而生命则是进行数据处理
2.智能正与意识脱钩
3.无意识但具备高度智能的算法，可能很快就会比我们更了解我们自己。
三项关键问题
1.生物真的知识算法，而生命也真的只是数据处理吗
2.智能和意识，究竟哪一个才更有价值
3.等到无意识但具备高度智能的算法比我们更了解我们自己时，社会、政治和日常生活将会有什么变化。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3278e2d6644346c3aaed34c1b21d1a3/" rel="bookmark">
			TensorFlow2.0 学习笔记八 TensorFlowTTS环境配置准备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在之前的介绍中可以直接使用Docker的GPU版本来进行训练等操作，现在基于这里继续写一下如何准备TensorSpeech下的TensorFlowTTS
使用Docker用GPU的教程：
TensorFlow2.0 学习笔记四 利用Docker直接使用GPU版本_shaynerain的博客-CSDN博客
项目地址 GitHub - TensorSpeech/TensorFlowTTS: :stuck_out_tongue_closed_eyes: TensorFlowTTS: Real-Time State-of-the-art Speech Synthesis for Tensorflow 2 (supported including English, French, Korean, Chinese, German and Easy to adapt for other languages)
需要先说的是项目中推荐使用的GPU2.6版本，对于官网直接部署好的最新版的GPU版本，表示很不想使用旧版本，经过多次尝试，发现GPU2.6版本也非常难部署，现在进行各种尝试看组新版的如何正常部署。
部署 1 新建目录并且把这个目录挂载到容器中 操作可参考TensorFlow2.0 学习笔记七 Docker中设置直接挂载目录_shaynerain的博客-CSDN博客
在该目录中克隆代码
git clone https://github.com/TensorSpeech/TensorFlowTTS.git 2 修改代码中的setup.py文件 因为要使用最新版啊的tensorflow，所以把前面要求版本的给取消，这里展示做出修改的地方
requirements = { "install": [ "tensorflow&gt;=2.7.0", "tensorflow-addons&gt;=0.10.0", "setuptools&gt;=38.5.1", "huggingface_hub&gt;=0.0.8", "librosa&gt;=0.7.0", "soundfile&gt;=0.10.2", 3 设置pip镜像源，然后进行进入目录进行安装 这一步需要在容器中进行操作
pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple pip install . 4 开始运行他的Examples import numpy as np import soundfile as sf import yaml import tensorflow as tf from tensorflow_tts.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3278e2d6644346c3aaed34c1b21d1a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/526c91360e4689581a8d1fa74a76ec0a/" rel="bookmark">
			英码边缘计算盒子IVP03X——32T超强算力，搭载BM1684X算能TPU处理器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		产品8大优势：
高效节能：相较异构产品，IVP03X数据调配效率更高，资源利用率更高，平均功耗更低；升级换代：相较算能BM1684平台，IVP03X算力、编码，模型转换性能均翻倍提升，且不用改底板，仅需替换核心模组即可快速、低成本实现平台升级；全国产化：适配国产化麒麟系统； 散热性能：被动散热设计，0噪音，运行更稳定可靠；接口连接：采用凤凰端子接口，适配性更强；开发环境：相比同行提供的深度学习开发工具包更全面； 产品简介 IVP03X 是英码科技推出的超强运算性能、高度集成的智能工作站,内置强悍 TPU,INT8算力高达32TOPS，CPU 处理器为 8核 ARM Cotex-A53，主频高达2.3GHZ。IVP03X 提供完善的开发移植工具链，能快速完成算法移植和项目落地。IVP03X 智能工作站能在宽温环境内工作，可以灵活部署于各种 AI场景中，在智慧工厂、智慧工地、智慧城管、智慧油站等领域都有着广泛的应用。
产品特性 超强运算性能
算力高达32TOP@INT8，单芯片最高支持32路H.264&amp;H.265的实时解码能力。
方便易用的集成开发环境 1、适配Caffe/TensorFlow/MxNet/PyTorch/ONNX/Paddle 飞桨等主流深度学习框架,是行业内少数能同时兼容国内外深度学习框架的边缘计算设备之一。
2、支持Docker容器化部署，支持Python开发环境。
3、深度学习开发工具包，包括底层库 (FFmpeg、OpenCV等)、推理部署工具、等一系列软件工具，涵盖了神经网络推理阶段所需的模型优化、高效运行时支持等能力。
4、提供开源的pipeline开发工具案例，集成拉流、解码、推理分析、推流等全数据流程模块。
丰富外设接口资源 1、可扩展 4G/5G/WIFI 无线网络方式，为边缘化业务部署提供便利。
2、可扩展 mSATA SSD 固态硬盘，适应大量数据存储需求。
性能稳定可靠
1、低功耗设计，结合外壳被动散热。
2、支持-20C~60C宽温度工作环境。
产品重点规格参数 应用领域 关于英码科技 广州英码信息科技有限公司成立于2006年，是一家致力提供“云-边-端”协同的AIoT产品与细分场景解决方案的人工智能企业。
英码旗下的“深元”AI产品体系，打造了一个以高、中、低多层次算力硬件为基础，算法自训练和生态整合为驱动，AI赋能平台为支撑，工具链为辅助的全栈式AI应用服务模式，打通场景需求-算法-硬件集成-业务平台对接-项目交付的全链条，为客户提供算法、算力双重自定义的产品和服务，推动AI和边缘计算在细分场景的广泛应用。
英码的AIoT产品以及定制服务面向智慧城市、智慧交通、智慧金融、智慧校园、智慧应急、智慧园区等不同行业和细分场景，为客户提供全方位的软硬件支撑和产品自定义能力。
英码科技的以“感知万物，智算赋能”为核心理念，软硬结合全面赋能千行百业智能化转型，构建无所不及的智能世界。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a5f2f26f2cc2190a96a03eb5b51a50b/" rel="bookmark">
			C/C&#43;&#43;学习 -- RSA算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述
RSA算法是一种广泛应用于数据加密与解密的非对称加密算法。它由三位数学家（Rivest、Shamir和Adleman）在1977年提出，因此得名。RSA算法的核心原理是基于大素数的数学问题的难解性，利用两个密钥来完成加密和解密操作。
特点
RSA算法的特点如下：
非对称性：RSA算法使用一对公钥和私钥，其中公钥用于加密，私钥用于解密。这种非对称性使得通信双方可以安全地交换信息，而不需要共享密钥。
安全性：RSA的安全性基于大素数的难解性，即大整数分解问题。目前尚无有效的算法能够在合理的时间内分解大素数，因此RSA算法被认为是安全的。
适用性广泛：RSA算法广泛用于数字签名、数据加密、密钥交换等领域，被广泛应用于网络通信、电子商务等场景。
效率相对较低：由于涉及大数运算，RSA算法相对于对称加密算法而言，加解密速度较慢。因此，通常仅用于加密短文本或用于安全交换对称密钥。
原理
RSA算法的核心原理基于以下数学概念：
选择两个大素数：选择两个足够大的不同素数p和q。
计算n和Φ(n)：计算n = p * q 和Φ(n) = (p-1) * (q-1)。
选择公钥和私钥：选择一个公钥e，满足1 &lt; e &lt; Φ(n)，且e与Φ(n)互质。然后，计算私钥d，满足d * e ≡ 1 (mod Φ(n))。
加密：使用公钥(e, n)对明文进行加密，得到密文c = m^e (mod n)，其中m为明文。
解密：使用私钥(d, n)对密文进行解密，得到明文m = c^d (mod n)。
C语言实现RSA算法
以下是一个简单的C语言实现RSA算法的示例代码。请注意，这只是一个基本的示例，实际应用中需要考虑更多的安全性和性能优化。
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;math.h&gt; // 欧几里得算法求最大公约数 int gcd(int a, int b) { if (b == 0) return a; return gcd(b, a % b); } // 计算模反函数 int mod_inverse(int e, int phi) { int d; for (d = 2; d &lt; phi; d++) { if ((e * d) % phi == 1) { return d; } } return -1; // 如果找不到模反函数 } int main() { int p = 61; int q = 53; int n = p * q; int phi = (p - 1) * (q - 1); int e = 17; // 选择一个合适的公钥 int d = mod_inverse(e, phi); // 计算私钥 int plaintext = 42; int ciphertext = (int)pow(plaintext, e) % n; int decrypted_text = (int)pow(ciphertext, d) % n; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a5f2f26f2cc2190a96a03eb5b51a50b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd3998d07338466267a1b8b16c0b1607/" rel="bookmark">
			如何提高Google play马甲包上架、上包成功率？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何提高Google play马甲包上架、上包成功率？ 开发者账号关联的主要因素有哪些？如何降低关联风险？酷鸟云可以降低风险？原理是什么？
Googleplay近期遭遇频繁下架，不少开发者账号遭到Googleplay的封禁。不管是做了代码混淆或者其他方案的开发者账号近期依旧无差别下架。
在跟一些同行进行交流之后，汇总出了一些针对目前批量下架的高发问题，具体问题有以下几点；
1、代码混淆问题 具体高发于马甲包的代码没有混淆彻底，或者使用Java写的程序代码内容较为简单，谷歌识别比较容易。以上的问题需要从代码重新重构，建议使用c++来写代码，能最大程度减少代码层面被谷歌判定关联的问题。
2、IP相互关联问题 IP层面有许多复杂的问题，更高于应用包本身代码导致的问题，代码可以通过混淆或者其他的手段去规避，但是IP大多数来源于第三方，是否干净或者有没有超卖完全看第三方的良心程度，很多情况下IP厂商为了保证IP最大化的利用和利润率都会进行一定程度的超卖，并且由于IPv4本身的数量限制，导致很多地方使用的IP是高重复率的；
很多同行使用的vps远程或者是其他的方式很难去保证IP完全独立没有超卖，并且IP的广播信息是否和谷歌所属的IP库能否对应也无法确认，有的时候可能第三方的检测是对应国家，但是在谷歌的IP库中会判定成其他的国家导致开发者账号被封或者异常。
从一些交流中我们会发现很多的IP可能提供2个甚至是更多人去使用，在谷歌的数据库判定里面即使两个不同的包，但是使用了同样的IP也会进行关联和下架。
要解决这个问题，可以使用紫鸟旗下新出的酷鸟云来做一些规避，他们在IP层面会建立库去筛选拉黑，已经使用过的IP他们不会销售给用户。从IP层面去避免谷歌的关联风险，酷鸟云上线的IP都会进行一些初步筛选，确认归属地跟谷歌的IP库判断一致，更多IP相关的问题就不在这里展开，后续可以着重去说IP如何判定和筛选。
酷鸟云 - 出海企业专用云服务器(vps)​www.kuniaovps.com/?co-from=zhihu​编辑
酷鸟云 - 出海企业专用云服务器(vps)
3、账户资料问题 从大量的同行反馈来看，目前谷歌对于账户资料的判定是比较严格的，尤记得当初17-18年随便填写一些资料就可以注册开发者，到现在资料和手机号的严格审核，谷歌针对马甲这个行为也设立了很多的风控。
这一块本质上是仿真问题，对于平台来说每个阶段都有他们想要的用户群，处于初期发展阶段的时候由于他们对市场占有的需求，他们会放低门槛吸引开发者进入，到达一定阶段后就会设立各种门槛。
不过，其实重要的不是有什么很强的资源，主要在于你对平台和用户的理解，在平台眼里什么才是他们所认可的开发者，从资料、电话、IP的对应层面我们需要做更多深度的伪装，尽量做到几个环节都真实，尤其是在电话卡上需要着重进行处理，尽量使用国外运营商提供的真实sim卡的号段，目前国外的虚拟号段都比较容易进行判断，所以不太建议使用接码平台。
4、云测试平台问题 从开发者账号注册到上架后我们的包要拿去跑试运行，很多朋友在这个环节只是单纯的使用模拟器。从仿真的方面来说，这是给谷歌留下了一个秋后算账的把柄，目前市面的模拟器例如夜神之类的指纹环境都是基于中国来进行设置，一旦我们包体中的sdk检测到相关的环境就会导致异常，这个方面最好选择云手机进行包的运行测试。
市面上大多数的云手机无法提供代理功能，需要用户在里面自己装一些工具才能实现某些功能，本质上内置的app除了重启问题以外，也容易被谷歌检测到运行的后台信息，如果要做到毫无破绽建议使用一些可以前置设置代理功能的云手机。
5、开发者账户时长问题 近期的开发者账户问题主要高发于23年新注册的账号，好的情况下新号新包7天左右过了就没问题，坏的情况下直接当场去世没多久就挂掉，可以按照七天一个周期来看上包的情况，多做一些对照组测试，比如不同IP、电话、用户资料、信用卡进行不同的分组，达到最佳的测试效果。
总的来说因为中国开发者各种骚操作的问题，不仅仅是谷歌，其他的一些平台也加强了新号的风控，在注册开发者之前可以看看play商店兑换谷歌礼品卡是否能够通过风控，如果无法通过风控，建议继续养号不要随意进行开发者注册。
对于平台来说不论是c端的用户或者是开发者，本质上他的属性是重叠的，在平台的眼里用户也是潜在的开发者，如果在用户层面风控上已经出了一些问题，那么在b端的开发者的权限也会有相应的风控问题，并且平台的警戒程度也会上升。
以上的内容主要是针对一些思路上的分享，很多细节相关的问题相信大家都有自己的判断，笔者更多分享的是如何做好一个账号或者说是用户的仿真，或许有些操作在当下可能属于多余，但是谁也无法保证谷歌是否会进行秋后算账。
更多相关的内容可以持续关注后面的更新！
​ 关注
1.Google马甲封掉的大致原因 ①. 上过马甲包的同学都知道，Google审核马甲包特别的严格变态，一般来说，审核时间越久，越容易出问题，通常都是机器审核后有问题，会交给人工审核， 一般机器审核差不多两到三个工作日，如果，三到四个工作日没出结果，十有八九这个马甲是有问题的
②. 关联问题，最为严重的和值得思考的问题，咋也不知道Google的审核是怎么判断关联的，个人通过上架很多马甲包得出这几个途径，
1：class文件高度相似，2：res资源文件和xml布局文件 3：后台数据返回格式 4：Google账号及环境 5：马甲UI 6：电脑关联
其实仔细想一想，差不多这几大类。
2.Google解决封掉办法 ①：再此之前，可以了解下 Google混淆 这篇文章，提升马甲时间
②：想解决马甲被封，被关联，最重要的就是要新，最好不要和上一个马甲有任何关联，视作一个新包来看待
③：自己总结的几点经验：从项目来说
1.必须要创建新的项目，创建新的包名，
2.项目中所有的lib和module最好打乱，路径子目录最好每次都打乱，
3.所有的类名，路径，xml中的id必须更换名字，res图片让ui更换MD5，马甲ui首页最好每次都换种不同的风格
4.混淆可以用上面这个，部分java类可以转kotlin，kotlin可以转转java等，保证最大程度与旧包不一致
5.关联问题： 每次必须用新的Google账号，包括电脑，上一个马甲，必须换掉电脑，每个电脑只能上架一个马甲包，每个电脑，每个马甲包，必须都要有一个大陆外的手机卡，用来测试，或者上架时，当作vpn来打包使用，也就是一个马甲包一个大陆之外得IP
6.最好不要测试，先上架，审核通过后，再从GooglePlay中下载测试，
7.新马甲项目，必须要在新的电脑上，创建jks文件，不要再自己电脑上创建，创建jks文件的时候，可以连接新手机(大陆之外的手机卡)进行创建，包括生成sha1和256及散列密钥，这些都要保证在新的设备上获取
8.打包aab的时候，也必须链接新手机(大陆之外的手机卡)进行打包。有些同学说vpn不行吗，说实话，如果做过vpn的话，就知道，这个真不行，不信可以用vpn进行打包，
9.大致就是：每个马甲都要对应一套新设备如：大陆之外手机卡 新电脑 新项目 新账户，以免产生关联 代码 目录结构，能多改就多改！ui，能变就变！数据返回格式，能改就改(不用太大改动,就比如每个马甲包返回的时候，外层再套一层大的data)！
3.XmlClassGuard混淆任意类，上架GooglePlay的杀手锏利器 Google混淆 这个是大佬的最新的一篇混淆文章，可以用这个，节省时间
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd3998d07338466267a1b8b16c0b1607/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9136b262d5d6bb5128a4540eab7a57a0/" rel="bookmark">
			linux使用dd命令新建空字节指定大小文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先进入想要生成文件的目录
执行以下命令：
.....
dd if=/dev/zero of=file_name bs=1M count=100 ......
其中：
- if=/dev/zero 指定了输入文件为/dev/zero，该文件会不断输出空字节。
- of=file_name 指定了输出文件的名称，可以根据需要自定义。
- bs=1M 指定了块大小为1兆字节，可以根据需要修改。
- count=100 指定了复制的块数，这里设置为100，所以最终的文件大小为100兆字节（100M）。
执行完这个命令后，就会在当前目录下创建一个名为file_name的100M大小的空字节文件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b82e36b2715c542a05915ea9b3c75f8/" rel="bookmark">
			opencv图像处理学习（七十五）——glob遍历文件夹下的所有图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 用void glob(String pattern, std::vector&amp; result, bool recursive = false);
//当recursive为false时，仅仅遍历指定文件夹内符合模式的文件，当recursive为true时，会同时遍历指定文件夹的子文件夹
#include &lt;opencv2\opencv.hpp&gt; #include &lt;iostream&gt; using namespace std; using namespace cv; int main() { //要绝对路径 string path = "D:\\data\\*.bmp"; cout &lt;&lt; path &lt;&lt; endl; vector&lt;Mat&gt; images; // 必须cv的String vector&lt;String&gt; fn; glob(path, fn, false); size_t count = fn.size(); cout &lt;&lt; count &lt;&lt; endl; for (int i = 0; i &lt; count; i++) { images.push_back(imread(fn[i])); imshow("pic", images[i]); waitKey(10); } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de92fb65abbbe6b0371ce9dcb82b7455/" rel="bookmark">
			CDN 95带宽怎么计算，一篇文章看懂
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多CDN公司会选择 使用95带宽来计费
比如一个月一个月30天，五分钟取样为例：
一小时12个点 ，一天24小时就是288个点， 一个月30天就是8640个点。把这8640个点，按照从大到小排列，把前面的5%去掉，即流量最高的432个点去掉，第433个点就是这个月的95计费流量值。
一个月28、29、31天也是同样的道理计算。如果按照31天来算，那去掉最大的5%就是前面446.4个点，这里算446，所以排序后第447个点就是95带宽。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44874d83491c7198fb9a89bfee7707c3/" rel="bookmark">
			工作记录 -- el-table 取消鼠标悬浮时行高亮效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 工作记录 -- el-table 取消鼠标悬浮时行高亮效果 使用el-table组件时，会有默认事件 当鼠标悬停时会高亮当前行 改变鼠标悬浮时高亮的效果
.el-table tbody tr:hover&gt;td { background: greenyellow!important } 但如果设置了stripe属性，表格会呈斑马纹两种颜色交替，设置颜色这个方法就失效了，这时候就可以禁用事件：
.el-table tbody tr { pointer-events:none; } 用户使用鼠标单机行时，也会出现行颜色改变的情况，修改其单机的行颜色
.el-table__body tr.current-row&gt;td { background: #ffb707!important; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f950efccdbe3c944181a24f232017fea/" rel="bookmark">
			Element-Plus的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Element-Plus 【了解】常见UI组件库
【掌握】Element-Plus基本使用
【掌握】Element-Plus常见组件
【掌握】Element-Plus购物车
1.常见组件库 UI组件库需要基于JS框架来实现，也就是说我们现在学习的是Vue3，也需要选择适配的组件库，在Vue生态中，最为流行的PC端组件库要数饿了么团队开发的element系列，Vue2版本对应Element-Ui，Vue3版本对应Element-Plus，我们当前要学习的便是Element-Plus，只要掌握了一个组件库的使用，其他组件库的使用基本上大同小异，大家无需担心。常见的UI组件库介绍如下：
Element-UI出自饿了么前端团队，学习Vue必用的一款 UI 库，采用 Vue 2.0 作为基础框架实现的组件库，一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的组件库，提供了配套设计资源，帮助网站快速成型，Element Plus 支持 Vue3。主要用于PC端。
Vant一款有赞出品轻量、可靠的的移动UI组件库，目前支持 Vue2、Vue3、React、微信和支付宝小程序，官网的文档清晰易懂，如果你熟悉vue.js的组件化开发，上手非常容易。
Ant Design是一套企业级 UI 设计语言和 React 组件库，提供了一套非常完整的组件化设计规范与组件化编码规范，能大幅提高了部分产品的设计研发效率及质量，由阿里的专业团队负责维护。
Ant Design Mobile 可以视作AntD的移动端版本。
…
上面这4个UI组件库对应了两大主流JS框架(Vue React)的PC端和移动端，我们当前的课程重点学习Element-Plus。
2.Element-Plus快速入门 2.1 项目安装 通过命令将Element-Plus安装到项目中：
npm install element-plus --save
确认正确安装完毕：
2.2 全局引入 虽然已经安装了依赖，但是要在项目中使用还需要引入，组件库一般都提供了全局引入和按需引入2种方法，全局引入更加方便，一次引入后可以在项目的任何位置使用，但是全局引入会让项目的体积变大，对于性能而言不是那么友好。
/main.js import { createApp } from 'vue' import ElementPlus from 'element-plus' import 'element-plus/dist/index.css' //记得引入样式文件 import App from './App.vue' const app = createApp(App) app.use(ElementPlus) //通过use方法来注册插件 app.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f950efccdbe3c944181a24f232017fea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee434023cf89d7dfb21f63d64f0f9d74/" rel="bookmark">
			nginx
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nginx 配置详解 | 菜鸟教程
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3d43a4a1b4a92d6c445bbc027c96a84/" rel="bookmark">
			将本地代码提交到git新仓库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 建仓 首先需要新建一个仓库，注意一定要是空仓库，不要选任何初始化
在代码所在目录右击，进入Git Bash Here 初始化git仓库 git init 将文件添加进库 git add . 进行提交，-m 后面引号中的内容是本次提交内容，自行填写 git commit -m '初始化' 添加仓库 // 例：git remote add origin https://gitee.com/***/demo.git git remote add origin 仓库地址 推送代码至远程仓库 git push -u origin "master" 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68bd95e91657397982c76de86ad87440/" rel="bookmark">
			RK3568 SPI子系统–oled屏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		8. SPI子系统–oled屏实验 — [野火]嵌入式Linux驱动开发实战指南——基于LubanCat-RK系列板卡 文档
参见野火的资料。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0cf75234281264358b95110e47cc161/" rel="bookmark">
			关于很多人办理带宽上网忽视的光猫桥接与路由模式的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		刚接触到猫的人,可能很多人都不知道这两种有什么区别,以下是介绍这两种区别,不知道对大家有没有用.
ADSL宽带接入方式在使用的过程中常常会遇到ADSL“桥接模式”和“路由模式”问题的困扰。本文尝试就国内的ADSL接入的常见ADSL接入方式（模式）的作一个介绍，重点阐述ADSL ROUTER（ADSL路由器或称“带路由的ADSL MODEM”）的“桥接模式（RFC1483 Bridged）”和“路由模式（PPPoE）”的区别。
桥接模式与路由模式
早期国内的ADSL线路接入都是桥接方式，由ADSL MODEM和电脑配合，在电脑上分配固定IP地址，开机就能接入局端设备进入互联网。但是这样在用户不开机上网时，IP是不会被利用，会造成目前日益缺少的公网IP资源的浪费，因此出现了PPPoE拨号的ADSL接入。
PPPoE拨号可以使用户开机时拨号接入局端设备，由局端设备分配给一个动态公网IP，这样公网IP紧张的局面就得到了缓解。
目前国内的ADSL上网方式中，基本上是PPPoE拨号的方式。PPPoE拨号出现以后，ADSL的接入设备——ADSL MODEM（ADSL调制解调器）就有一个新的兄弟产品，叫做ADSL ROUTER（ADSL路由器）。这种设备具有ADSL MODEM的最基本的桥接功能，所以个别产品也叫ADSL BRIDGE/ROUTER（ADSL桥接路由器），俗称为“带路由的ADSL MODEM”。ADSL ROUTER 具有自带的PPPoE拨号软件，并能提供DHCP服务，RIP-1路由等功能，因此它被移植了少量的路由器的功能。但是，并不是说PPPoE拨号就没有桥接，常见的这类组网有如：ADSL MODEM + PPPoE拨号软件（如EnterNet 300）。有个别地方的电信营运商仍主推一般的ADSL MODEM，这样就没有路由功能，实际上就是不鼓励用户“一线多机”。但是，现在的ADSL接入设备生产商竞争实在激烈，所以ADSL MODEM已基本停产，而转生产ADSL ROUTER，这就是现在所称的大多数的ADSL MODEM都“带路由”的原因，也就是ADSL接入设备基本是ADSL ROUTER。
由于组网方案的不同，ADSL ROUTER就有了桥接模式和路由模式的工作模式。
若是有少量客户机的家庭用户或SOHO用户，就可以直接用PPPOE ROUTED——路由模式，由ADSL ROUTER来进行PPPoE拨号并进行路由。也可以用RFC 1483 BRIDGED，然后接入PC，在PC上运行PPPOE拨号软件进行拨号，或接入宽带路由器，由宽带路由器的内置PPPOE拨号工具进行拨号。
若是在多用户环境，客户机的数量较多时，如：网吧、企业、社区，往往是ADSL ROUTER 加宽带路由器的组网形式，这时多数会让ADSL ROUTER工作在桥接模式下，由宽带路由器来进行拨号功能，并承担路由的工作，这是因为ADSL ROUTER的路由能力较低，在处理大数量客户机的路由请求时会出现性能下降或产生死机故障。所以说，桥接模式和路由模式其实是针对于ADSL ROUTER来说的。
什么是桥接模式
ADSL ROUTER桥接模式有个正式专业的名称叫做RFC1483 桥接。RFC1483标准是为了实现在网络层上多协议数据包在ATM网络上封装传送而制定的，现已被广泛用于ATM技术中，成为在ATM网络上处理多协议数据包的封装标准。
RFC1483仿真了以太网的桥接功能，它在数据链路层上对网络层的数据包进行LLC/SNAP的封装。在ADSL Modem中完成对以太网帧的RFC1483 ATM封装后，通过用户端和局端网络的PVC永久虚电路完成数据包的透明传输。ADSL的RFC1483桥接接入方式是ADSL宽带接入的最基本形式，也成为其它接入方式的基础，一般的ADSL ROUTER出厂也默认在桥接方式下。 ADSL ROUTER出厂初始值为用于单台电脑的桥接器方式，也就是它的当前工作模式置于“BRIDGE ENABLE（桥接使能）”。在纯桥接模式下，ADSL ROUTER只是一个普通网桥，其功能较简单。通常需要一个代理服务器或网关设备将局域网中的通信汇聚起来再连接到外部网络上。需在代理服务器或网关设备上运行PPPoE拨号软件。桥接方式可以由局方分配固定IP，也可以配合配合拨号软件可设置为自动获取，或是分配固定IP需要在PC端设置。
什么是路由模式
ADSL ROUTER路由模式一般指的是ADSL ROUTER在“ROUTER ENABLE（路由使能）”的工作模式下，它具有PPPOE拨号、NAT、RIP-1等少量路由功能。
PPPoE全称是Point to Point Protocol over Ethernet（基于局域网的点对点通讯协议）。它基于两个广泛接受的标准即：局域网Ethernet和PPP点对点拨号协议。在ADSL ROUTER中采用RFC1483的桥接封装方式对终端发出的PPP包进行LLC/SNAP封装后，通过连结两端的PVC在ADSL Modem与网络侧的宽带接入服务器之间建立连接，实现PPP的动态接入。对于服务商来说不需要花费巨资来做大面积改造，设置IP地址绑定用户等来支持专线方式。这就使得PPPoE在宽带接入服务中比其他协议更具有优势。因此逐渐成为宽带上网的最佳选择。
在路由模式下，ADSL ROUTER是一个独立的准系统，它自己PPPOE拨号并做NAT，成为一**立的网关，不需要一台机器专门来开机并设置共享上网功能来为其他人做网关，或不需要宽带路由器来做网关，直接与局域网交换机连接就可以共享上网了。开启路由的好处：(1)不必专门使用一台电脑做服务器，任何一台电脑开机都可上网。(2)惟一的IP地址由ADSL ROUTER获得，外部发起的攻击全部作用于ADSL ROUTER上，可在一定程度上保护共享上网的电脑。
ADSL ROUTER路由模式启用路由模式，可以省却代理服务器和拨号软件或宽带路由器。但是，由于硬件条件的限制，ADSL路由能力只适用于仅有几台电脑的共享应用，如家庭、宿舍等超小型网络。而对于企业动辄几十台，甚至上百台的应用状况，ADSL路由就难以胜任了。在企业环境下，在ADSL运行在路由模式下，可能会出现一些问题，如：频繁出现ADSL 链路断开重连；ADSL 大猫死掉，须重启。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0cf75234281264358b95110e47cc161/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d31d4a8cd514e81c6d300bf0f5994093/" rel="bookmark">
			nginx转发服务，外部请求时返回404，403等问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录一下自己遇到的问题
1.检查页面显示404，找不到media、js、css文件。路径问题，找到本地存储这些文件的路径，在nginx配置文件中加入配置就行了。
注意：我的系统前端是streamlit实现的，这些文件在当前python环境的streamlit包中找到的。2.检查页面显示403，无权限访问
启动用户与Nginx工作用户不一致。
ps -aux | grep nginx查看nginx的master用户是root
去/etc/nginx路径下，查看nginx.cong文件中user是其他用户，不是root
把nginx.cong的user改为root：
sudo vi NLP.conf 向文件中写入配置、检查配置是否有效：使用指令 sudo nginx -t、重启Nginx：使用指令 sudo systemctl restart nginx
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07c054811ab2d62604ee2e0d71df386d/" rel="bookmark">
			Java基于SpringBoot的高校招生系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主介绍：✌程序员徐师兄、7年大厂程序员经历。全网粉丝30W+、csdn博客专家、掘金/华为云/阿里云/InfoQ等平台优质作者、专注于Java技术领域和毕业项目实战✌
文章目录 简介系统设计思路1 数据库设计2 系统整体设计 系统详细设计1系统功能模块2. 管理员功能模块3学生功能模块推荐阅读 简介 本次设计任务是要设计一个高校招生管理系统，通过这个系统能够满足管理员和学生的招生公告管理功能。系统的主要功能包括首页、个人中心、学生管理、专业信息管理、专业报名管理、录取通知管理、系统管理等功能。
管理员可以根据系统给定的账号进行登录，登录后可以进入招生管理系统，对招生管理系统所有模块进行管理。包括查看和修改自己的个人信息以及登录密码。
该系统为每一个用户都分配了一个用户账号，用户通过账号的登录可以在系统中查看招生公告信息及对个人信息进行修改等功能。
系统设计思路 1 数据库设计 信息管理系统的效率和实现的效果完全取决于数据库结构设计的好坏。为了保证数据的完整性，提高数据库存储的效率，那么统一合理地设计数据库结构是必要的。数据库设计一般包括如下几个步骤：
（1）根据用户需求，确定数据库信息进行保存
对用户的需求分析是数据库设计的第一阶段，用户的需求调研，熟悉学生运作流程，系统要求，这些都是以概念模型为基础的。
（2）设计数据的概念模型
概念模型与数据建模用户的观点一致，用于信息世界的建模工具。通过E-R图可以清楚地描述系统涉及到的实体之间的相互关系。
个人中心实体图如图
（3）数据库逻辑结构分析
数据库概念结构设计后，可以数据库概念转化实际的数据模型，这是一种数据库的逻辑结构，就是将概念结构与支持数据库管理系统的模型相符合。具体的表设计如下所示：
表 1：专业信息
字段名称类型长度字段说明主键默认值idbigint主键主键addtimetimestamp创建时间CURRENT_TIMESTAMPxuexiaomingchengvarchar200学校名称zhuanyemingchengvarchar200专业名称zhuanyeleibievarchar200专业类别tupianvarchar200图片zhaolurenshuvarchar200招录人数zhaoluyaoqiulongtext4294967295招录要求zhaoluzhuangtaivarchar200招录状态 表 2：专业报名
字段名称类型长度字段说明主键默认值idbigint主键主键addtimetimestamp创建时间CURRENT_TIMESTAMPxuexiaomingchengvarchar200学校名称zhuanyemingchengvarchar200专业名称baomingziliaovarchar200报名资料baomingshijiandatetime报名时间xuehaovarchar200学号xingmingvarchar200姓名shoujivarchar200手机sfshvarchar200是否审核否shhflongtext4294967295审核回复 表3：学生
字段名称类型长度字段说明主键默认值idbigint主键主键addtimetimestamp创建时间CURRENT_TIMESTAMPxuehaovarchar200学号mimavarchar200密码xingmingvarchar200姓名xingbievarchar200性别touxiangvarchar200头像shoujivarchar200手机 表4：用户表
字段名称类型长度字段说明主键默认值idbigint主键主键usernamevarchar100用户名passwordvarchar100密码rolevarchar100角色管理员addtimetimestamp新增时间CURRENT_TIMESTAMP 表5：token表
字段名称类型长度字段说明主键默认值idbigint主键主键useridbigint用户idusernamevarchar100用户名tablenamevarchar100表名rolevarchar100角色tokenvarchar200密码addtimetimestamp新增时间CURRENT_TIMESTAMPexpiratedtimetimestamp过期时间CURRENT_TIMESTAMP 表6：招生公告
字段名称类型长度字段说明主键默认值idbigint主键主键addtimetimestamp创建时间CURRENT_TIMESTAMPtitlevarchar200标题introductionlongtext4294967295简介picturevarchar200图片contentlongtext4294967295内容 表7：录取通知
字段名称类型长度字段说明主键默认值idbigint主键主键addtimetimestamp创建时间CURRENT_TIMESTAMPxuexiaomingchengvarchar200学校名称zhuanyemingchengvarchar200专业名称xuehaovarchar200学号xingmingvarchar200姓名shoujivarchar200手机tongzhishijiandatetime通知时间luqujieguovarchar200录取结果tongzhineironglongtext4294967295通知内容 表8：配置文件
字段名称类型长度字段说明主键默认值idbigint主键主键namevarchar100配置参数名称valuevarchar100配置参数值 2 系统整体设计 系统详细设计 源码咨询地址
1系统功能模块 招生管理系统，在系统首页可以查看首页、专业信息、招生公告、个人中心、后台管理等内容进行详细操作，如图所示。
学生注册，在学生注册页面通过填写学号、密码、确认密码、姓名、手机等内容进行注册等操作，如图所示。
专业信息，在专业信息页面可以查看学校名称、专业类别、招录人数、招录要求、招录状态等内容进行报名等操作，如图所示。
个人中心，在个人中心页面通过填写个人中心，学号、密码、 姓名、性别、图片、手机等内容进行更新信息等操作，如图所示。
2. 管理员功能模块 管理员登录，在系统首页通过填写用户名、密码选择角色进行操作，登录后就可以使用了，如图5-5所示。
管理员登录系统后，可以对首页、个人中心、学生管理、专业信息管理、专业报名管理、录取通知管理、系统管理等功能模块进行相应操作，如图5-6所示。
学生管理，在学生管理页面可以对索引、学号、姓名、性别、头像、手机等内容进行修改或删除等操作，如图5-7所示。
专业信息管理，在专业信息管理页面可以对索引、学校名称、专业名称、专业类别、图片、招录人数、招录状态等内容进行详情、修改或删除等操作，，如图5-8所示。
专业报名管理，在专业报名管理页面可以对索引、学校名称、专业名称、报名资料、报名时间、学号、姓名、手机、审核回复、审核状态、审核等内容进行详情、通知、修改或删除等操作，如图5-9所示。
录取通知管理，在录取通知管理页面可以对索引、学校名称、专业名称、学号、姓名、手机、通知时间、录取结果等内容进行详情、修改或删除等操作，如图5-10所示。
系统管理，在招生公告页面中可以对索引、标题、图片等内容进行详情、修改或删除等操作，也可以对轮播图管理进行相应的操作，如图5-11所示。
3学生功能模块 进入学生系统首页可以查看首页、个人中心、专业报名管理、录取通知管理等内容进行详细的操作，如图5-12所示。
专业报名管理，在专业报名管理页面可以对索引、学校名称、专业名称、报名资料、报名时间、学号、姓名、手机、审核回复、审核状态等内容进行详情或删除等操作，如图5-13所示。
录取通知管理，在录取通知管理页面可以对索引、学校名称、专业名称、学号、姓名、手机、通知时间、录取结果等内容进行详情等操作，如图5-14所示。
推荐阅读 小程序毕业设计精品项目
Java毕业设计精品项目
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a741387da7683042f41eee6865b6474/" rel="bookmark">
			java案例25：批量操作文件管理器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		思路： 编写文件管理器，实现文件的批量操作。 具体功能： 1.用户输入指令1，代表“指定关键字检索文件”， 此时需要用户输入检索的目录和关键字， 系统在用户指定的目录下检索出文件名中包含关键字的文件 并将其绝对路径展示出来 2.用户输入指令2，代表“指定后缀名检索文件”， 此时需要用户输入检索的目录和后缀名（多个后缀名用逗号分隔）， 系统在用户指定的目录下检索出指定后缀名的文件， 并将其绝对路径展示出来。 3.用户输入指令4，代表“删除文件/目录”， 此时需要用户输入需要删掉的文件目录， 程序执行后会将目录以及目录下的内容全部删除。 4.用户输入5，代表“退出”，即退出系统。 代码： 代码结构：
FileUtils类：
package base.base025; import java.io.File; import java.io.FilenameFilter; import java.util.ArrayList; public class FileUtils { public static ArrayList&lt;String&gt; listFiles(File file,String key){ //创建文件名称过滤器对象 FilenameFilter filter = new FilenameFilter() { @Override public boolean accept(File dir, String name) { //把dir和name封装成一个File对象 File currFile = new File(dir,name); //判断currFile是否是一个文件，并且文件的名称包含key if(currFile.isFile() &amp;&amp; name.contains(key)){ return true; } return false; } }; //获取满足条件的所有文件 //调用fileDir方法 ArrayList&lt;String&gt; arrayList = fileDir(file,filter); return arrayList; } //递归算法 public static ArrayList&lt;String&gt; fileDir(File dir,FilenameFilter filter){ //创建集合对象存储执行后的结果 ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;(); //获取file对象下面的所有文件以及文件夹对应的file数组，把文件名称过滤器传递过去 File[] lists = dir.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a741387da7683042f41eee6865b6474/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af23f5e7d6a8a9ea1d1342b6cdabb145/" rel="bookmark">
			java案例24：模拟百度翻译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		思路： 编写一个程序模拟百度翻译 用户输入英文之后，搜索程序中对应的中文， 如果搜索到1对应的中文，就输出搜索结果，反之给出提示 要求使用Map集合实现英文与中文的存储。 1.百度翻译主要用于翻译对应的意思，是一种一一映射关系，可以用Map集合来实现 定义Map集合，存储数据 2.用键盘录入获取要翻译的单词 3.定义一个方法，在该方法中实现对单词的查询操作，并根据不同的情况给出相关提示 4.调用查询方法，实现翻译。并将结果输出控制台 代码： package base.base024; /* 模拟百度翻译 编写一个程序模拟百度翻译 用户输入英文之后，搜索程序中对应的中文， 如果搜索到1对应的中文，就输出搜索结果，反之给出提示 要求使用Map集合实现英文与中文的存储。 1.百度翻译主要用于翻译对应的意思，是一种一一映射关系，可以用Map集合来实现 定义Map集合，存储数据 2.用键盘录入获取要翻译的单词 3.定义一个方法，在该方法中实现对单词的查询操作，并根据不同的情况给出相关提示 4.调用查询方法，实现翻译。并将结果输出控制台 */ import java.util.HashMap; import java.util.Scanner; public class Test24 { public static void main(String[] args) { HashMap&lt;String,String&gt; word = new HashMap&lt;String,String&gt;(); while(true){ word.put("apple","苹果"); word.put("banana","香蕉"); word.put("cat","小猫"); word.put("dog","小狗"); word.put("book","书"); word.put("tea","茶"); Scanner sc = new Scanner(System.in); System.out.println("请输入要查询的单词："); String name = sc.nextLine(); //判断输入的单词是否在map即合理作为键存储 if(word.containsKey(name)){ String value = word.get(name); System.out.println(name + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af23f5e7d6a8a9ea1d1342b6cdabb145/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36bb672a33dc6a199671215d1d9b0542/" rel="bookmark">
			java案例23：斗地主洗牌发牌
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		思路： 编写一个斗地主的洗牌发牌程序 要求按照斗地主的规则完成洗牌、发牌的过程 一副扑克牌共有54张牌，由花色和数字（字母J/Q/K/A）组成 花色有♠、♥、♦、♣四种，分别表示黑桃、红桃、方块、梅花，小王、大王 斗地主共有三位玩家参与， 首先将这54张牌顺序打乱， 每人一轮轮流摸牌， 剩余三张底牌 在控制台打印三位玩家的牌和三张底牌 代码： package base.base023; /* 斗地主洗牌发牌 编写一个斗地主的洗牌发牌程序 要求按照斗地主的规则完成洗牌、发牌的过程 一副扑克牌共有54张牌，由花色和数字（字母J/Q/K/A）组成 花色有♠、♥、♦、♣四种，分别表示黑桃、红桃、方块、梅花，小王、大王 斗地主共有三位玩家参与， 首先将这54张牌顺序打乱， 每人一轮轮流摸牌， 剩余三张底牌 在控制台打印三位玩家的牌和三张底牌 */ import java.util.ArrayList; import java.util.Collection; import java.util.Collections; import java.util.HashMap; public class Test23 { public static void main(String[] args) { //准备牌 HashMap&lt;Integer,String&gt; map = new HashMap&lt;&gt;();//键Integer用来保存牌号，String保存值 ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();//保存牌号 map.put(1,"大王"); map.put(2,"小王"); list.add(1); list.add(2); //花色和牌分别准备到一个数组里面 String[] numbers = {"2","A","K","Q","J","10","9","8","7","6","5","4","3"}; String[] colors = {"♠","♥","♣","♦"}; //循环遍历嵌套 int index = 3; for (String number : numbers) { for (String color : colors) { map.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36bb672a33dc6a199671215d1d9b0542/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40a40cab0c9f83f8e7e9e2a414f803a2/" rel="bookmark">
			java案例22：模拟用户注册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		思路： 与微信、淘宝类似， 都需要一个账户才可以登录，而账户需要注册才可以获取。 编写程序模拟用户注册。 用户输入用户名、 密码、确认密码、 生日（格式：yyyy-mm-dd）、 手机号（长度为11位）且仅支持13/15/17/19开头的手机号 邮箱（包含@符号） 判断信息正确后，验证用户是否重复 重复给出相应提示 如不重复则注册成功，将信息存入集合中 使用HashSet集合实现 代码： 代码结构：
User类：
package base.base022; import java.util.Date; import java.util.Objects; public class User { private String username; private String password; private Date birthday; private String tel; private String email; public User() { } public User(String username, String password, Date birthday, String tel, String email) { this.username = username; this.password = password; this.birthday = birthday; this.tel = tel; this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40a40cab0c9f83f8e7e9e2a414f803a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c5008889e5bf7511c90e4117a3a9705/" rel="bookmark">
			Qt Visual Studio 插件bug处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Only God knows how much time ive wasted on dealing it!!!
vs自动生成的cmakelists somehow在我的电脑上跑不成功, 无穷的debug之后发现, bug is:
你需要把vs自动生成的这段cmakelists ↓
target_link_libraries(QtLearning1 PUBLIC Qt::Core Qt::Gui Qt::Widgets ) 改为
target_link_libraries(QtLearning1 PUBLIC Qt5::Core Qt5::Gui Qt5::Widgets ) 或者 target_link_libraries(QtLearning1 PUBLIC Qt${QT_VERSION_MAJOR}::Core Qt${QT_VERSION_MAJOR}::Gui Qt${QT_VERSION_MAJOR}::Widgets ) 同时 为了解决windows平台下dll复制的问题,即:
需要在cmakelists最后添加这段话:
if (WIN32 AND NOT DEFINED CMAKE_TOOLCHAIN_FILE) set(DEBUG_SUFFIX) if (MSVC AND CMAKE_BUILD_TYPE MATCHES "Debug") set(DEBUG_SUFFIX "d") endif () set(QT_INSTALL_PATH "${CMAKE_PREFIX_PATH}") if (NOT EXISTS "${QT_INSTALL_PATH}/bin") set(QT_INSTALL_PATH "${QT_INSTALL_PATH}/..") if (NOT EXISTS "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c5008889e5bf7511c90e4117a3a9705/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdb5b9db60a39342e2d4607eb7cc9cb0/" rel="bookmark">
			ue5读取自定义文件夹中内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、复制文件夹到Content内
二、读取文件内容，直接使用相对路径就可以了/Content，Resource Bundle存储文件夹名的变量。Load Text为自定义的读取json文件的方法，我之前的文章讲了怎么操作。
ue5读取外部文件_艺菲的博客-CSDN博客
三、根据json文件的内容读取读取自定义文件夹中的图片
需要使用Get Project Content Directory获得文件绝对路径
四、打包exe时候，选择Additional Non-asset Directions to Package
打包时候遇到报错
System.ArgumentException: Path fragment ‘“Content/\351\237\263\351\242\221/Cheetah\302\240Mobile_Games_-_\…\265.uasset”’ contains invalid directory separators 在项目目录下执行git config --global core.quotepath false
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24b9a0b450288d0f50b69092e61ac2b0/" rel="bookmark">
			解决Outlook中的Funcaptcha新思路！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，今天我们将为您介绍一个令人兴奋的在线服务 EzCaptcha，这个网站可以帮助您更轻松地解决注册Outlook等网站时遇到的验证码问题。
FunCAPTCHA 简介 首先，让我们先来了解一下FunCAPTCHA。它是由谷歌开发的一种验证码技术，可能对很多人来说还很陌生。FunCAPTCHA的验证形式如下所示：
通常情况下，我们需要点击验证码上的小框，以触发验证过程。验证码经常以选择图像中的特定物体数量来进行验证。例如，您可能会看到如下的验证任务：
在这些验证任务中，您需要使用箭头点击图像，直到右侧的图像中的物体数量与左侧图像相匹配，然后再点击“提交”按钮。有时，您可能需要完成多次类似的验证任务，才能成功注册。
虽然看起来简单，但如果尝试使用API来绕过FunCAPTCHA，需要对FunCAPTCHA的内部机制有深入的理解，以及复杂的机器学习模型，才能稳定地绕过验证。
EzCaptcha的解决方案 现在，让我们向您介绍EzCaptcha，这是一个旨在帮助您轻松应对FunCAPTCHA和其他验证码的在线服务。EzCaptcha为您提供了一种简单而高效的方法，通过其API获取验证码的token，从而使您能够快速且大量地通过验证码验证。
EzCaptcha的使用步骤 首先，您需要在EzCaptcha网站上进行注册。请访问他们的官方网站：https://www.ez-captcha.com/#/home，并创建一个账户。在您注册后，您将获得一个ClientKey，这是您的账户密钥，务必妥善保存。
接下来，您可以查看EzCaptcha的官方文档：https://ezcaptcha.atlassian.net/wiki/spaces/IS/pages/425998/createTask。文档中详细介绍了如何使用EzCaptcha的API。
这里我们将需要传入这么几个参数：
type
websiteURL
websiteKey
以outlook为例子主要包括以下步骤：
首先根据以上ezcaptcha的使用文档，我们已经判断出outlook使用Funcaptcha的参数，这样我们就可以POST这样一个内容给服务器,post地址为https://api.ez-captcha.com/createTask
{
"clientKey": "r60f4b494631479a9486d67f84069f61234778",
"task": {
"websiteURL": "https://signup.live.com/signup2",
"websiteKey": "B7D8911C-5CC8-A9A3-35B0-554ACEE604DA",
"type": "FuncaptchaTaskProxyless"
}
}
然后服务器就会返回类似这样的相应：
{
"errorId": 0,
"taskId": "fd8a3af5-339b-47c7-aa10-9badf20cad7f"
}
下一步则是需要post一个获取结果的代码，地址为https://api.ez-captcha.com/getTaskResult：
{
"clientKey": "r60f4b494631479a9486d67f84069f61234778",
"taskId": "fd8a3af5-339b-47c7-aa10-9badf20cad7f"
}
然后我们就会得到一个返回的结果：
{
"errorId": 0,
"solution": {
"token": "646178c32b93d67c9.7168511505|r=eu-west-1|meta=7|meta_height=325|metabgclr=%23ffffff|metaiconclr=%23757575|mainbgclr=%23ffffff|maintxtclr=%231B1B1B|guitextcolor=%23747474|pk=B7D8911C-5CC8-A9A3-35B0-554ACEE604DA|at=40|ht=1|ag=101|cdn_url=https%3A%2F%2Fclient-api.arkoselabs.com%2Fcdn%2Ffc|lurl=https%3A%2F%2Faudio-eu-west-1.arkoselabs.com|surl=https%3A%2F%2Fclient-api.arkoselabs.com|smurl=https%3A%2F%2Fclient-api.arkoselabs.com%2Fcdn%2Ffc%2Fassets%2Fstyle-manager"
},
"status": "ready"
}
如此我们便得到了结果.
EzCaptcha的优势 EzCaptcha提供的验证码服务是付费的，但相对成本较低。每次验证码验证可能只需支付少量点数，成本非常实惠。此外，随着您在EzCaptcha上的使用频率增加，您将获得更多的奖励点数，甚至可以升级为VIP用户。此外，EzCaptcha还提供邀请奖励计划，让您更容易降低成本。
总结 EzCaptcha是一个非常有趣且实用的在线服务，可以帮助您轻松应对FunCAPTCHA等验证码，使您能够更快速地注册Outlook等网站。如果您经常需要处理验证码，EzCaptcha可能是您的最佳选择。不要错过这个令人兴奋的工具，立即访问他们的网站：https://www.ez-captcha.com。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8798a0490855bccc230697fad54c7769/" rel="bookmark">
			Mysql数据库分库分表问题&#43;引发问题&#43;中间件对比分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mysql数据库分库分表 一、背景-为什么要分表1. 读写的数据量限制：数据量太大2. 数据库连接数限制：并发访问多 二、分表方式2.1 垂直分表2.2 水平分表2.2.1 按关键字分表 2.2.2 按大小（范围）分表 2.2.3 按时间分表 三、分库分表引发的问题 四、分库分表中间件4.1 常见分表插件及其优缺点4.2 对比JDBC驱动和Proxy中间层两种方式 五、扩容问题5.1 路由规则5.2 双写过程 一、背景-为什么要分表 首先，要解决海量数据的问题，必须要用到分布式的存储集群。而绝大部分的电商大厂，它的在线交易这部分业务（比如订单、支付相关的系统）还是舍弃不了 MySQL，原因是只有 MySQL 这类关系型数据库才能提供金融级的事务保证。
但是单机的MySQL 数据库在很多场景下不是太适合存 TB 级别以上的数据，因此MySQL必须用上分片思想，这就是分库分表。
具体来说，MySQL什么时候需要分库分表？
1. 读写的数据量限制：数据量太大 数据量大会导致：
（1）装不下
（2）数据量大的话SQL语句执行很慢（简单一条count语句，在1000w数据量下，也需要运行几秒甚至超过十秒）——慢查询最终拖累整个系统；
2. 数据库连接数限制：并发访问多 数据库的连接是有限制的，不能无限制创建。
（ MySQL 中可以使用 max_connections 查看默认的最大连接数，当访问连接数过多时，就会导致连接失败）
以电商为例，假设存储没有进行分库，用户、商品、订单和交易，所有的业务请求都访问同一个数据库，产生的连接数是非常可观的，可能导致数据库无法支持业务请求。
使用数据库连接池可以优化连接数问题，但是更好的方式是通过分库等手段，避免数据库连接成为业务瓶颈。
二、分表方式 2.1 垂直分表 一张表按字段（列）分成多张表，改变表结构。
常见思路是将长度比较大（text等）、访问频率低的字段，移到扩展表；
将经常组合查询的列放在一张表中，充分发挥热点数据的操作效率。
2.2 水平分表 一张表按记录（行）分成多张表，分完后结构仍相同。
水平分表有不同的分库和分表规则，一般是通过业务主键，进行哈希取模操作。
感觉遇到过的一些按关键字、按大小、按时间分表其实都属于水平分表。
2.2.1 按关键字分表 这种方案适用于按关键字查询频繁的场景，关键字相同的数据，必须落在同张表，不然要是有列表分页查询，就会很烦。
不足之处在于，可能有比较多的大客户落在同一张表，分表数据不均匀。假设在我们的场景，支持代理机构注册一个用户id，多个学生可以使用同一个用户id参加考试，那么某个用户的数据量有可能非常大。
2.2.2 按大小（范围）分表 适用于数据和关键字无关的场景，如单纯的流水记录表，如果是和某个关键字扯上了关系，那么会导致跨表查询，比如查询某个用户的平均考试分数，就会比较麻烦，因为无法知道一个用户横跨了多少个子表。
本方案优点是大小均匀，性能可控。这里建议每个分表不超过500万行数据，这样对数据库造成的压力不会太大；缺点是有比较多的场景限制。
2.2.3 按时间分表 其优点在于思路简单，且很容易清理掉旧数据，整个表能自动变冷。缺点在于业务初期，对业务量的预估，会存在难度：可能一开始月表绰绰有余，后期随着业务量突飞猛进，一个月都有千万条甚至上亿条数据，此时又得进行拆分。另外，用该方案时一定要注意时间分割的节点，会不会造成有相关联的数据出现不一致。
三、分库分表引发的问题 问题问题描述解决办法事务一致性跨库、表的分布式事务问题比如数据库拆分后，订单和库存在两个库中，一个下单减库存的操作，就涉及跨库事务。可以使用分布式事务中间件，实现 TCC 等事务模型；也可以使用基于本地消息表的分布式事务实现。跨节点关联查询查询的数据存在于多表、多库之间，SQL无法正常执行（1）利用中间件Mycat（仅支持两表join）的catlet插件（Share Join）：解析SQL拆分成单表操作-路由到对应表-结果返回mycat汇总（2）抽象出全局表，全局表每个分片中都有一份，让全局表和其他表join（3）按ER父子关系分库，有父子关系的表就会在同一个节点，避免分库连表查询；（4）数据全量丢到ES来关联查询跨节点分页、排序函数跨节点多库查询时，limit 分页、order by 排序等问题，就变得比较复杂了。（1）可以使用插件MyCat，跨节点分布式分页/排序的思路：需要先在不同的节点中将数据进行排序并返回，然后将不同节点返回的结果集进行汇总和再次排序；（2）将数据全量放到ES中（原理是scroll游标）主键避重分布式id问题：由于表中数据同时保存在不同数据库中，主键值平时使用的自增长就不好使了uuid、雪花算法、数据库维护区间分配等 四、分库分表中间件 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8798a0490855bccc230697fad54c7769/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7488ca3f75ad3c82c8309ef2f7cf31bf/" rel="bookmark">
			软考程序员考试大纲（2023）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、考试说明1.考试目标2.考试要求3．考试科目设置 二、考试范围考试科目1：计算机与软件工程基本知识1．计算机科学基础2．计算机系统基础知识3．系统开发和运行知识4．网络与信息安全基础知识5．标准化与知识产权基础知识6．信息化基础知识7．计算机专业英语 考试科目2：程序设计1．算法设计与实现2．程序设计3．程序实现与测试4．程序设计语言 前言 之前给大家介绍了软考程序员是什么，如何报考及备考流程，现在我来带大家一起了解下软考程序员大纲！ 一、考试说明 1.考试目标 通过本考试的合格人员能根据软件开发项目管理和软件工程的要求按照程序设计规格说明书编制并高度程序，写出相应的程序文档，产生符合标准规范的、实现设计要求的、能正确可靠运行的程序。具有助理工程师（或技术员）的实际工作能力和业务水平。
2.考试要求 （1）掌握数制及其转换、数据的机内表示、算术和逻辑运算、应用数学的基础知识； （2）了解计算机的组成以及各主要部件性能指标； （3）掌握操作系统、程序设计语言的基础知识； （4）熟练掌握基本数据结构和常用算法； （5）熟练掌握Ｃ程序设计语言以及Ｃ++、Java中的一种程序设计语言； （6）熟悉数据库、网络和多媒体的基础知识； （7）了解软件工程的基础知识、软件过程基本知识、软件开发项目管理的常识； （8）了解常用信息技术标准、安全性以及有关法律、法规的基础知识； （9）了解信息化及计算机应用的基础知识； （10）正确阅读和理解计算机领域的简单英文资料。 3．考试科目设置 （1）计算机与软件工程基础知识，考试时间为150分钟，笔试，选择题； （2）程序设计，考试时间为150分钟，笔试，问答题。 二、考试范围 考试科目1：计算机与软件工程基本知识 1．计算机科学基础 1．1 数制及其转换
●	二进制、十进制和十六进制等常用数制及其相互转换 1．2 数据的表示
●	数的表示 ●	非数值数据的表示 1．3 算术运算和逻辑运算
●	计算机中二进制数的运算方法 ●	逻辑代数的基本运算 1．4 数学应用
●	常用数值计算（矩阵、近似求解、插值） ●	排列组合、应用统计 ●	编码基础 1．5 常用数据结构
●	数组 ●	线性表及链表 ●	队列、栈 ●	树 ●	图 1．6 常用算法
●	算法与数据结构的关系 ●	算法设计和算法描述 ●	常用的排序算法 ●	查找算法 ●	常用的数值计算方法 ●	字符串处理算法 ●	递归算法 ●	最小生成树、拓扑排序和单源点最短路径求解算法 2．计算机系统基础知识 2．1 硬件基础知识
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7488ca3f75ad3c82c8309ef2f7cf31bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b63d38a3895cacac2a76f9ad409b5945/" rel="bookmark">
			C/C&#43;&#43; 中的函数返回局部变量以及局部变量的地址？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C/C++中，函数内部的一切变量(函数内部局部变量，形参)都是在其被调用时才被分配内存单元。形参和函数内部的局部变量的生命期和作用域都是在函数内部(static变量的生命期除外)。子函数运行结束时，所有局部变量的内存单元会被系统释放。在C中，函数被调用时的传参方式有两种形式：传值和传址。
传址的好处：
(1) 能在函数内部通过实参地址间接地改变实参的值。
(2) 当所传实参内容比较庞大时，传址只是复制了整个实参的地址过去，指针依据同一个地址访问实参变量。而传值就会将实参内容整个拷贝过去，形参会跟实参占一样大的内存，栈空间是有限的。当然了，在弱小的程序中，传址的这个优点不会被体现出来。
在函数中，可以随意的返回一个局部变量。
但如果返回一个局部变量的地址（指针），编译器就会给出警告。因为函数只是把指针复制后返回了，但是指针指向的内容已经被释放，这样指针指向的内容就是不可预料的内容，程序就会出错。
准确的来说，函数不能返回指向栈内存的指针(返回指向堆内存的指针是可以的)。
返回局部变量 C++中，函数是可以返回局部变量的，原因：返回值是拷贝值，局部变量的作用域为函数内部，函数执行结束，栈上的局部变量会销毁，内存释放。
可返回的局部变量：
1、返回局部变量本身
#include &lt;iostream&gt; int display() { int num = 9; return num; } int main() { int p = display(); std::cout &lt;&lt; p &lt;&lt; std::endl; // 9 return 0; } display 函数返回一个 int 类型的局部变量 num，函数会把局部的num的值复制一份拷贝给主函数里面的 p 变量。这样是可以的，而且这种方式在程序里面还是经常用到的。
上面程序输出：9
返回局部变量地址 引用一位博主的分析：https://blog.csdn.net/qq_34801642/article/details/88411252
C/C++语言函数是不能返回局部变量地址（特指存放于栈区的局部变量地址），除非是局部静态变量地址，字符串常量地址、动态分配地址。其原因是一般局部变量的作用域只在函数内，其存储位置在栈区中，当程序调用完函数后，局部变量会随此函数一起被释放。其地址指向的内容不明（原先的数值可能不变，也可能改变）。而局部静态变量地址和字符串常量地址存放在数据区，动态分配地址存放在堆区，函数运行结束后只会释放栈区的内容，而不会改变数据区和堆区。
举例如下：
#include &lt;iostream&gt; int* display() { int num[3] = {8,6,5}; return num; } int main() { int* p = display(); for(int i = 0; i &lt; 3; i++) { std::cout &lt;&lt; *(p+i) &lt;&lt; std::endl; } return 0; } 这段代码存在一个问题，即在函数display()中返回了一个指向局部变量num的指针。这是不安全的操作，因为当函数display()结束时，局部变量num将被销毁，指向它的指针p将变成悬空指针，使用它可能导致未定义的行为。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b63d38a3895cacac2a76f9ad409b5945/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/327e47190e27cda64b15379661625d3e/" rel="bookmark">
			TensorFlow2.0 学习笔记七 Docker中设置直接挂载目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 在之前的文章中介绍过在Docker中安装SSH来同步代码，之前使用的是代码同步，同步来同步去总归比较麻烦，这里有新的方法可以使用，直接使用挂载目录功能，把电脑上的目录挂载到容器里面去，这样可以直接来修改代码，而不用担心同步问题
TensorFlow2.0 学习笔记五 在Docker容器里安装SSH，使用Pycharm远程调试代码-CSDN博客
实现 使用-v参数，前面是自己要挂在的目录，后面是要挂在的位置
docker run -p 997:22 -p 998:6006 -p 996:8888 -v D:\Work\FunProject\fun4\tensorflow-speech:/home/fun4/tensorflow-speech --name tensorflow-speech --pull missing tensorflow/tensorflow:latest-gpu-jupyter 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/307cdc7ba30305199a2d841f750c907b/" rel="bookmark">
			AF_UNIX和127.0.0.1(AF_INET)回环地址写数据速度对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在linux下，存在着这样的情况，本地的进程间通信，并且其中一个是服务端，另外的都是客户端。
服务端通过绑定端口，客户端往127.0.0.1的对应端口发送，即可办到，不过这样会浪费一个端口，同时也容易造成安全隐患。
今天发现linux服务端创建socket的时候，协议族用AF_UNIX即可，AF_LOCAL和AF_UNIX的值是一样的。
而AF_UNIX和127.0.0.1回环地址相比，具有哪些好处呢。本人读了下面博客：
Unix domain socket 简介
其中里面讲到UNIX domain socket 用于 IPC 更有效率：不需要经过网络协议栈，不需要打包拆包、计算校验和、维护序号和应答等。本人想当然认为AF_UNIX速度比127.0.0.1更快，为此鄙人进行了实验。
找一个比较大的文件，超过1G大小，然后
1。用AF_UNIX写客户端和服务端，由客户端读取文件，发送给AF_UNIX服务端，然后服务端写文件，看看用AF_UNIX传递一个文件需要多久。
2. 用127.0.0.1写客户端和服务端，由客户端读取文件，发送给127.0.0.1服务端，然后服务端写文件，看看用127.0.0.1传递一个文件需要多久。
废话不多说，直接上代码，先上AF_UNIX的：
AF_UNIX服务端(unixsocketserver.c)：
#include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;stddef.h&gt; #include &lt;sys/socket.h&gt; #include &lt;sys/un.h&gt; #include &lt;errno.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;ctype.h&gt; #define MAXLINE 80 char *socket_path = "/tmp/server.socket"; #define RECV_LEN 1000 int main(void) { fd_set readmask, exceptmask; struct timeval tv; int maxfd = FD_SETSIZE; int nready = 0; FILE *fp = fopen("/tmp/pull_desktop234_copy.flv", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/307cdc7ba30305199a2d841f750c907b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9f337b42cfbce0a5ec432212cfc73ca/" rel="bookmark">
			Arcgis小技巧【15】——字段计算器的简单用法和示例2.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前写过一篇【字段计算器的简单用法和示例】：
https://blog.csdn.net/xcc34452366/article/details/128776450
说了一些字段计算的使用方法，主要是针对python的用法。
不是很完整，这里再补充一些内容。
欢迎关注同名微信公众号，更多文章推送：
​
1、数字前填充0 一般用在编号中， 例如取【OBJECTID】的数字并在前面填充0至5位，注意计算的字段必须是字符串型。因为【OBJECTID】的值是数字，所以要加str()转成字符串：
str(!OBJECTID!).zfill(5) ​
2、小数点后保留固定位数，不足部分用0填充 正常情况下用round()函数可以保留固定位数，但是因为生成的是数值型，所以如果最后位是0会自动消掉。如果想要实现不足部分用0填充，则需要字段为字符串型，并如下计算：
format(!TBMJ!, '.5f') ​
3、文本居中，两端填充 再整点活，如果想在文本两端都进行填充。例如要在文本前后都填充【0】至文本长度为8：
!JQDLMC!.center(8,"0") 4、文本左右对齐，另一端填充 例如文本左对齐，右侧填充至8位：
!JQDLMC!.ljust(8,"%") 相反的话则是：
!JQDLMC!.rjust(8,"%") 5、获取特定字符在字符串的位置 例如获取字符串中【8】的位置，注意是从左开始获取第一个【8】的位置：
!BSM!.find("8") 如果是从右开始获取：
!BSM!.rfind("8") 6、获取多个数字型字段值中的最大值或最小值 取最大值：
max(!TBMJ!,!Shape_Area!) 取最小值：
min(!TBMJ!,!Shape_Area!) 7、获取随机数 例如要获取0至10之间的随机整数：
random.randrange(0,10) 在代码块中输入：
import random 8、赋空值 空值不是空格：
None 9、计算数字的百分比变化 例如计算图斑的面积变化，以百分比的方式表达：
PercentChange(!TBMJ!) 在代码块中输入：
lastValue = 0 def PercentChange(arg): newValue = arg global lastValue if lastValue: percentage = (float(newValue - lastValue) / lastValue) * 100 else: percentage = 0 lastValue = newValue return percentage 10、计算数字的累积值 例如逐个累积图斑的面积之和：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9f337b42cfbce0a5ec432212cfc73ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6da0816b5c9c064ebb81074fdcb7c3e1/" rel="bookmark">
			云计算安全和云原生安全的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		云计算安全(Cloud Computing Security)指的是在云环境中保护数据、应用程序和基础设施的安全性。它包括保护云服务提供商的基础设施和平台，以及云服务用户的数据和应用程序。
云原生安全(Cloud-Native Security)则是指在云原生环境中保护应用程序和服务的安全性。云原生是一种软件开发和部署的方法论，旨在充分利用云计算的优势，并实现高度可扩展和弹性的应用程序。云原生应用程序通常是以容器化的方式进行部署，并使用微服务架构。
云计算安全和云原生安全之间存在紧密联系。云原生环境的安全性是建立在云计算安全的基础上的。云计算安全提供了保护云基础设施和平台的措施，如访问控制、身份认证、数据加密等。而云原生安全则更加关注应用程序和服务的安全，包括容器安全、微服务安全、API安全等。
云计算安全和云原生安全的目标都是确保在云环境中的数据和应用程序的保密性、完整性和可用性。在实践中，需要综合考虑这两个安全领域的要求，采取合适的安全策略和措施，以确保整个云计算生态系统的安全。
为了实现云计算安全和云原生安全的目标，组织需要采取一系列综合的安全策略和措施。首先，云计算服务提供商需要建立严格的安全标准和流程，并确保其基础设施和平台符合相关法规和标准要求。他们需要实施访问控制、身份认证和数据加密等常见的安全措施，并定期进行安全审计和漏洞扫描，以发现和修复潜在的安全风险。
其次，对于云原生应用程序，需要采取容器安全和微服务安全等更加具有针对性的措施。这边建议可以联系安全狗在线商务咨询为您解决在云原生安全中会遇到的各类问题。
总之，云计算安全和云原生安全是相互联系的，组织需要综合考虑这两个领域的要求来确保整个云计算生态系统的安全。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/53/">«</a>
	<span class="pagination__item pagination__item--current">54/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/55/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>