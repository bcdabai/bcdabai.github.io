<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/478e91d9bc7a446c71fa26b8686f2bf0/" rel="bookmark">
			GBD调试器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 GDB的使用 先编译程序：gcc 源文件名 -o 可执行文件名 -g进入gdb调试环境：gdb 可执行文件运行文件：run/r（一次运行完），start（单步运行）单步运行：next/n单步运行（可以进入函数体内部）：step/s从函数体中跳出：finish查看代码：list/l，l 文件名：行号/函数名，l 行号/函数名继续向下查看内容：l （因为每次只显示10代码）设置断点：break/b 行号/函数名，b 文件名：行号/函数名设置条件断点：b 行号 if value == number删除断点：delete/d 断点编号获取断点编号：info/i b退出当前循环：u查看变量的值：p 变量名查看变量类型：ptype 变量名设置变量的值：set var 变量名 = 值追踪变量：display 变量取消追踪：undisplay 变量编号退出gdb：quit每次调试停在断点位置：continue/c GDB调试在进程中的使用 打开gdb时，默认调试父进程，或指定set follow-fork-mode parent，此命令在fork调用之前执行。调试子进程时：先start，再set follow-fork-mode child，然后用n继续调试，执行子进程时，父进程直接输出结果。跟踪指定的子进程：先在第n个子进程的入口处用带有if条件语句break语句打断点，然后set follow-fork-mode child 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11552c58af1ba7d31a4a0a9b67aac783/" rel="bookmark">
			原来手工测试小白也能分分钟学会的UI自动化测试（Python版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		手动测试做久了，总会想要尝试接触些新技术，UI自动化就是一个非常容易尝试的入门砖。
小白也能做，相信自己放手去试吧。
一、为什么需要做UI自动化 1.想一想，为什么需要做UI自动化
可以从解决问题的角度出发，想一下在工作中，哪些工作重复性非常高？
最最常见的重复性工作，那就是：功能回归测试啦。
现在市面上的大小公司都在推敏捷开发，几乎都是2周/3周发一次版本。
即2周/3周跑一次回归测试，而且Android和iOS都需要跑一次，即便分在个人头上的回归内容很少，其实也占据了大家大量时间。
当然，并不是说UI自动化只能在回归测试阶段发光发热，在测试的任何阶段都可以尝试跑UI测试脚本，可以根据公司需要调整运行阶段、运行次数，并且可以随时修正脚本内容。
2.做UI自动化可能需要克服的阻力
在一个技术氛围偏低的团队，如果想要尝试新技术，有可能会比较难以迈出第一步。
这时候你需要给出充足的理由，再开始跟领导沟通。
第一步，先做个demo，单纯的启动APP，跑通几个简单的主流场景。
第二步，整理一份简略版主流程测试点，作为后续使用UI自动化来实现的内容。
第三步，去找领导沟通吧
（1）有明确的启动实例，有明确待实现的主流程测试点，想清明确可以运行的测试阶段
（2）邀请组内同事一起加入，和团队伙伴们一起进步
（3）找迭代中闲暇的时间，梳理本期的新流程，并编写新脚本
相信有明确目标，有实例支撑，得到领导的支持应该不会太难。
二、UI自动化可以怎么做 1.常用工具
目前比较常用的有：Appium、Airtest、AppiumStudio
建议选择其中一个长期使用，推荐使用：Appium。
2.常用脚本语言
Python、Java均可，如果是零基础小白的话，Python上手可能会更快。
3.平台区分：iOS、Android
4.集成jenkins
如有稳定项目后，可以尝试集成到jenkins上，定期运行。
5.一个简单的UI自动化例子（iOS版本）
因为目前网上已有巨量的Android 自动化例子，这里给一份iOS 真机的示例。
运行iOS自动化，需要有一台mac，资金不充裕的话，建议入macmini。
（1） 启动APP
caps = {} caps["platformName"] = "iOS" caps["platformVersion"] = "13.1.3" caps["deviceName"] = "xiaobai" caps["xcodeOrgId"] = "xxx" # 需要跟开发同事要一份 caps["xcodeSigningId"] = "iPhone Developer" caps["automationName"] = "XCUITest" caps["startIWDP"] = "true" caps["udid"] = "auto" # 真机专用包，如/DerivedData下没有app，需要xcode上build一下 caps["app"] = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11552c58af1ba7d31a4a0a9b67aac783/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/371770cb902d8f065d0f5a546c570bd5/" rel="bookmark">
			在uni-app项目的pages下添加新的vue文件，生成的dist文件里，没有
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在pages下，添加了echarts/echarts.vue, 生成的dist里没有这个文件，是因为要在 pages.json里添加一下就好了：
{
"path": "pages/echarts/echarts",
"style": {
"navigationBarTitleText": "曲线图"
}
},
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0ea8b2f8508853af2dab81745475e77/" rel="bookmark">
			多益网络校招前端面经（2020.09.24）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多益网络校招前端面经（2020.09.24） 面试平台 QQ视频通话
时长 大约半小时
过程 自我介绍项目问题：项目中遇到的问题以及解决方式；在团队开发过程中个成员合作方式，遇到问题的解决方式css命名冲突http和httpshttps中密钥的具体协商过程及其使用方式get和post事件循环机制异步函数的输出顺序，为什么这个顺序（promise、setTimeout、promise与setTimeout嵌套）对vue了解吗react中组件间数据传递方式（父子间、兄弟间）对新知识的学习方式，如果以后有新的前端开发技术出来你怎么学习当前同事开发的代码出现bug由你解决，你怎么处理什么是xss、csrf，csrf的预防方式scrf的具体攻击方式react的优点diff算法element diff具体处理方式对996的看法 感受 感觉挺好，面试官问的问题会逐渐加深，也不会故意为难
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be17c98af375a174613087e3e713a07e/" rel="bookmark">
			UE4 局域网联机开发历程 - （三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UE4局域网打包后，在多台电脑上无法链接。两台电脑相互 ping IP 查看是否可以通信
（1）.不能通信，检查下路由设置或者打开手机热点进行测试。
（2）.可以正常通信，两台电脑就是无法联机，可以参考以下设置。
红：点击“网络和Internet设置”
红（更改适配器选项）：点击进入，禁用 VMnet
黄（共享选项）：检查专用，来宾或者共用和所有网络，启用网络发现，启用文件和 大打印机共享
补充 ：open ip 可以进入创建好的房间，那就要检查一下电脑网络的共享设置。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcfe4f46bf484a8d43d4ccc006d2ed5b/" rel="bookmark">
			To install it, you can run: npm install --save element-ui/lib/utils/date
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		npm run build 报错，提示 To install it, you can run: npm install --save element-ui/lib/utils/date
npm install element-ui -S
用以上命令，单独下载element-ui 就好了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2225b987030992d5bf23d9b458750bec/" rel="bookmark">
			UE4 局域网联机开发历程 - （二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UE4 局域网项目打包设置 1.在项目的配置文件 DefaultEngine.ini 添加
[OnlineSubsystem] DefaultPlatformService=Null （不一定是 MULL 也可能是 Steam 等） 2. 在 “项目名称 + .Build.cs”的文件下添加
PrivateDependencyModuleNames.Add("OnlineSubsystemNull");
打包后，两台电脑无法联机可以查看：UE4 局域网联机开发历程 - （三）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38e36c84fe2e220e4f8e880b49e83d99/" rel="bookmark">
			【概率与统计】---均方误差，方差，协方差，协方差矩阵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，均方误差 个人理解：平均的平方的误差值，即，误差的平方的期望值（误差就是每个估计值与真实值的差）；换句话说，也就是多个样本的时候，均方误差等于每个样本的误差平方再乘以该样本出现的概率的和。
二、方差 个人理解：误差的平方；方差是描述随机变量的离散程度，是变量离期望值的距离。
注意两者概念上稍有差别，当你的样本期望值就是真实值时，两者又完全相同。最小均方误差估计就是指估计参数时要使得估计出来的模型和真实值之间的误差平方期望值最小。
三、协方差 个人理解：协，协同的（两个变量）之间的误差
当，X与Y值相同时，其实就是方差； 若斜方差越大，两者的联系越大，若协方差越小，联系越小。
四、协方差矩阵 个人理解：矩阵的主对角线是方差，副对角线是协方差。若副对角线为0，就是协方差为0，为方差。
多元高斯分布：就是高斯分布的低维向高维的扩展，图像如下。
对应多元高斯分布的公式也请自行谷歌，以前高斯公式中的方差也变成了协方差，对应上面三张图的协方差矩阵分别如下：
注意协方差矩阵的主对角线就是方差，反对角线上的就是两个变量间的协方差。就上面的二元高斯分布而言，协方差越大，图像越扁，也就是说两个维度之间越有联系。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e470be70171e9170be8eb31ceba77080/" rel="bookmark">
			vue的加载顺序导致的：在export之外初始化window全局变量是undefined
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		question：最近写vue项目遇到一个问题，以下三个文件中，water.vue在export之外初始化window定义的全局变量，结果是undefined
//APP.vue &lt;template&gt; &lt;earth /&gt; &lt;water /&gt; &lt;/template&gt; //earth.vue &lt;template&gt;&lt;/template&gt; &lt;script&gt; export default{ name:'earth', mounted(){ window.earth = new Earth(); } } &lt;/script&gt; //water.vue var earth = window.earth; export default{ name:'water', methods:{ hello(){ console.log(earth); //打印结果是earth is undefined; } } } 后来才知道这个跟vue加载文件顺序有关：vue先加载export外的js代码，然后再加载export内的mounted。所以water.vue在export之外无法加载，earth.vue中mounted内部定义的全局变量。
index.html-&gt;APP.vue的export以外的js代码-&gt;main.js-&gt;APP.vue的export内代码-&gt;earth.vue的export外的js代码-&gt;water.vue的export外的js代码-&gt;meatrue.vue的export外的js代码-&gt;earth.vue的export内代码-&gt;water.vue的export内代码-&gt;meatrue.vue的export内代码
1，先加载全部组件export外的js代码，然后再加载全部组件export内的js代码；
2，export内的js代码先加载mounted函数
在app.vue中earth.vue组件是放在water.vue之前的，window.earth是在earth.vue的mounted内加载的，我在water.vue内的mounted内获取window.earth是成功的；假如我把earth.vue放在water.vue组件之后，理论上先加载water.vue的mounted再加载earth.vue的mounted，所以应该报错earth是undefined; 事实上确实报错了。但是water.vue的子组件却可以获取window.earth，说明以下两个问题：
1，vue是按照组件的摆放顺序加载的，同等级的组件，摆放越靠前越先加载；
2，父级组件总是先全部加载完毕，然后才轮到子组件加载
补充，以下是vue的启动流程，原文链接 VUE启动流程 1. package.json 在执行npm run dev的时候，会在当前目录中寻找 package.json 文件, 有点类似 Maven 的 pom.xml 文件，包含项目的名称版本、项目依赖等相关信息。
{　# 版本信息 "name": "kitty-ui", "version": "1.0.0", "description": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e470be70171e9170be8eb31ceba77080/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01cb892be5f89d156cbb98c1d83ca639/" rel="bookmark">
			MapGIS出现“存储服务错误，可能未启动”问题解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：
问题原因：
1 存储服务冲突。MapGIS k9和MapGIS 10的存储服务于冲突。
或者：
2 存储服务没有启动。
解决办法
1 卸载MapGIS相关的其他版本。
或者：
2 在服务管理启动启动MapGIS Datastore Server：
将红框中内容设为启用即可
参考：https://blog.csdn.net/wujianyouhun/article/details/44978735
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/425f57f69fc03ff3d39f1b944e162780/" rel="bookmark">
			Python有限差分法——向前差分，向后差分和中心差分的Python程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有限差分法
有限差分方法(FDM)是计算机数值模拟最早采用的方法，至今仍被广泛运用。
该方法将求解域划分为差分网格，用有限个网格节点代替连续的求解域。有限差分法以Taylor级数展开等方法，把控制方程中的导数用网格节点上的函数值的差商代替进行离散，从而建立以网格节点上的值为未知数的代数方程组。该方法是一种直接将微分问题变为代数问题的近似数值解法，数学概念直观，表达简单，是发展较早且比较成熟的数值方法。
分类
对于有限差分格式，从格式的精度来划分，有一阶格式、二阶格式和高阶格式。从差分的空间形式来考虑，可分为中心格式和逆风格式。考虑时间因子的影响，差分格式还可以分为显格式、隐格式、显隐交替格式等。目前常见的差分格式，主要是上述几种形式的组合，不同的组合构成不同的差分格式。差分方法主要适用于有结构网格，网格的步长一般根据实际情况和条件来决定。
构造差分的方法
构造差分的方法有多种形式，目前主要采用的是泰勒级数展开方法。其基本的差分表达式主要有三种形式：一阶向前差分、一阶向后差分、一阶中心差分和二阶中心差分等，其中前两种格式为一阶计算精度，后两种格式为二阶计算精度。通过对时间和空间这几种不同差分格式的组合，可以组合成不同的差分计算格式。
泰勒级数：
Python中调用sympy模块求解差分 from sympy import diff from sympy import symbols import sympy def func(t): return 2000 * sympy.log(14*10000/(14*10000-2100*t))-9.8*t #函数 t = symbols("t") print(func(16)) print(diff(func(t),t)) #对函数进行求导 print(diff(func(t),t).subs(t,16)) 运行上述程序结果：
392.073691403521 588000000000*(1 - 3*t/200)/(140000 - 2100*t)**2 - 9.8 29.6736842105263 【注意】：
函数的写法不能调用sympy以外的模块的函数
比如这样写就不对：
from sympy import diff from sympy import symbols import math def func(t): return 2000 * math.log(14*10000/(14*10000-2100*t))-9.8*t t = symbols("t") print(func(16)) print(diff(func(t),t)) print(diff(func(t),t).subs(t,16)) 结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/425f57f69fc03ff3d39f1b944e162780/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca19c2a60621f03266e0926d76e77a49/" rel="bookmark">
			Java StringBuffer  类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当对字符串进行修改的时候，需要使用 StringBuffer类
StringBuffer 方法 以下是 StringBuffer 类支持的主要方法：
序号方法描述1public StringBuffer append(String s)
将指定的字符串追加到此字符序列。2public StringBuffer reverse()
将此字符序列用其反转形式取代。3public delete(int start, int end)
移除此序列的子字符串中的字符。4public insert(int offset, int i)
将 int 参数的字符串表示形式插入此序列中。5replace(int start, int end, String str)
使用给定 String 中的字符替换此序列的子字符串中的字符。 下面的列表里的方法和 String 类的方法类似：
序号方法描述1int capacity()
返回当前容量。2char charAt(int index)
返回此序列中指定索引处的 char 值。3void ensureCapacity(int minimumCapacity)
确保容量至少等于指定的最小值。4void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)
将字符从此序列复制到目标字符数组 dst。5int indexOf(String str)
返回第一次出现的指定子字符串在该字符串中的索引。6int indexOf(String str, int fromIndex)
从指定的索引处开始，返回第一次出现的指定子字符串在该字符串中的索引。7int lastIndexOf(String str)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca19c2a60621f03266e0926d76e77a49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c1b031c02d702a478900ce84f952b0b/" rel="bookmark">
			通过webRTC&#43;websocket实现视频通话
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近空闲时间较多，于是写了一个个人博客，其中实现了实时通话，但是感觉功能比较无趣，前两天突发奇想，觉得如果可以视频通话就有意思了，于是从网上搜索了相关资料，发现webRTC可以实现该功能，但是网上关于webRTC的资料甚少，经过三天的研究，终于简单的实现了视频通话的功能，具体实现过程如下： 1.技术点： webRTC、websocket
2.实现思路： 两个浏览器打开同一页面，连接到同一个socket。
此时由一端点击建立连接，发起建立连接的一端就是offer(携带信号源信息)，发给另外一个端，另外一个端收到offer之后，发出响应answer(携带信号源信息)，offer端收到answer端信息进行存储；这样每个端都有了自己的信息和对方的信息，offer发出answer发出后设置了localDescription和remoteDescription后就会触发onicecandidate，如此一来，双方都有了对方的localDescription、remoteDescription和candidata；有了这三种数据之后，就可以触发Connection.onaddstream函数,然后通过theirVideo.srcObject = e.stream这个方法，把流写到video标签内，然后video标签里就会有对方的视频画面了。
注意：这样实现之后不能直接调用navigator.getUserMedia()函数，浏览器会默认getUserMedia为undifined，如果是互联网模式这里需要设置浏览(如果只是本地测试则不需要)（谷歌浏览器配置方法）；webrtc如只是p2p不需要特别服务器，自已开发信令服务就可以啦，当要安装turn server 国内常有打洞不成功需要转发。 下面是实现代码： 1.前端页面 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;webrtc&lt;/title&gt; &lt;style&gt; #yours{ width:300px; position:absolute; top:200px; left:100px; } #theirs{ width:300px; position:absolute; top:200px; left:400px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick="createOffer()"&gt;开始视频&lt;/button&gt; &lt;video id="yours" autoplay&gt;&lt;/video&gt; &lt;video id="theirs" autoplay&gt;&lt;/video&gt; &lt;/body&gt; &lt;script type="text/javascript" src="../blog/plugin/jquery/1.9.1/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="webtrc.js"&gt;&lt;/script&gt; &lt;script&gt; $(function () { f() }) &lt;/script&gt; &lt;/html&gt; 2.js、webRTC实现方法 var websocket; function randomNum(minNum,maxNum){ switch(arguments.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c1b031c02d702a478900ce84f952b0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7307900d953daf74c1bd4be006895f4/" rel="bookmark">
			生成验证码图片的第三方包——captcha
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、准备 1、在Django工程的apps中，新建子应用verifications ，里面新建包libs，存放生成图片验证码的扩展包captcha 2、安装Pillow的图片库 添加captcha完成后,如果直接使用会报错:
报错原因：captcha 框架, 需要依赖 Pillow 这个包
在虚拟环境–安装 Python 处理图片的库 Pillow：
pip install Pillow -i https://pypi.tuna.tsinghua.edu.cn/simple captcha 这个框架中有一个generate_captcha( ) 函数, 调用这个函数, 可以同时生成一个图片和对应内容的文字信息（验证码）：
使用示例： # text 文本验证码 # image 验证码图片二进制流 text, image = captcha.generate_captcha() print('验证码的内容是:', text) # 将验证码图片二进制流 存入图片 with open('demo.png', 'wb') as f: f.write(image) 3、图片验证码有时效性-选用redis数据库存储 在Django的配置文件中配置 Redis 的 2号库——存储图片验证码数据
# 验证码信息: 存到 2 号库 "verify_code": { "BACKEND": "django_redis.cache.RedisCache", "LOCATION": "redis://127.0.0.1:6379/2", "OPTIONS": { "CLIENT_CLASS": "django_redis.client.DefaultClient", } }, 二、接口实现 逻辑分析：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7307900d953daf74c1bd4be006895f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/565f896eb2e092bbbead5a5b5ffeb491/" rel="bookmark">
			nginx代理转发说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、nginx 默认转发header，个别字段除外 说明：
（1）proxy_hide_header
语法:proxy_hide_header field;默认值:—上下文:http, server, location nginx默认不会将“Date”、“Server”、“X-Pad”，和“X-Accel-...”响应头发送给客户端。proxy_hide_header指令则可以设置额外的响应头，这些响应头也不会发送给客户端。相反的，如果希望允许传递某些响应头给客户端，可以使用proxy_pass_header指令。
（2）proxy_pass_header（其功能与proxy_hide_header相反，会将原来不允许转发的改为允许转发）
语法:proxy_pass_header field;默认值:—上下文:http, server, location 允许传送被屏蔽的后端服务器响应头到客户端。
（3）proxy_set_header
语法:proxy_set_header field value;默认值: proxy_set_header Host $proxy_host; proxy_set_header Connection close; 上下文:http, server, location 允许重新定义或者添加发往后端服务器的请求头。value可以包含文本、变量或者它们的组合。 当且仅当当前配置级别中没有定义proxy_set_header指令时，会从上面的级别继承配置。 默认情况下，只有两个请求头会被重新定义：
proxy_set_header Host $proxy_host; proxy_set_header Connection close; 如果不想改变请求头“Host”的值，可以这样来设置：
proxy_set_header Host $http_host; 但是，如果客户端请求头中没有携带这个头部，那么传递到后端服务器的请求也不含这个头部。 这种情况下，更好的方式是使用$host变量——它的值在请求包含“Host”请求头时为“Host”字段的值，在请求未携带“Host”请求头时为虚拟主机的主域名：
proxy_set_header Host $host; 此外，服务器名可以和后端服务器的端口一起传送：
proxy_set_header Host $host:$proxy_port; 如果某个请求头的值为空，那么这个请求头将不会传送给后端服务器：
proxy_set_header Accept-Encoding ""; 2、nginx 默认转发body 说明：
proxy_pass_request_body（默认是打开的）
Syntax:proxy_pass_request_body on | off;Default: proxy_pass_request_body on; Context:http, server, location Indicates whether the original request body is passed to the proxied server.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/565f896eb2e092bbbead5a5b5ffeb491/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66d938c7f9569d98aa681a4246b5142e/" rel="bookmark">
			Prometheus Operator监控k8s集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前的文章中，使用传统方式安装了prometheus来监控node、mysql、redis等。这样配置非常麻烦，成本非常高。如果还要考虑Prometheus、AlertManager这些组件服务本身的高可用的话，成本就更高了。当然了，我们完全可以用自定义的方式来实现这些需求，我们也知道Prometheus在代码上就已经对Kubernetes有了原生的支持，可以通过服务发现的形式来自动监控集群，因此我们可以使用另外一种更加高级的方式来部署Prometheus：Operator框架。
一、什么是Operator Operator是由CoreOS公司开发的用来扩展Kubernetes API的特定应用程序控制器，用来创建、配置和管理复杂的有状态应用，例如数据库、缓存和监控系统。Operator基于kubernetes的资源和控制器概念上构建，但同时又包含了应用程序特定的领域知识。创建Operator的关键是CRD（自定义资源）的设计。
Operator是将运维人员对软件操作的只是给代码化，同时利用Kubernetes强大的抽象来管理大规模的软件应用。目前CoreOS官方提供了几种Operator的实现，其中就包括了Prometheus Operator，Operator的核心实现是基于Kubernetes的一下两个概念：
资源：对象的状态定义控制器：观测、分析和行动，以调节资源的分布 当前CoreOS提供了四种Operator：
etcd：创建etcd集群Rook：云原生环境下的文件、块、对象存储服务Prometheus：创建Prometheus监控实例Tectonic：部署Kubernetes集群 Prometheus作为一个核心的控制器，它会创建Prometheus、ServiceMonitor、AlertManager以及我们的prometheus-rule这四个资源对象，operator会一直监控并维持这四个资源对象的状态，其中创建Prometheus资源对象就是最为Prometheus Server进行监控，而ServiceMonitor就是我们用的exporter的各种抽象(exporter就是提供我们各种服务的metrics的工具)。Prometheus就是通过ServiceMonitor提供的metrics数据接口把我们数据pull过来的。现在我们监控prometheus不需要每个服务单独创建修改规则。通过直接管理Operator来进行集群的监控。这里还要说一下，一个ServiceMonitor可以通过我们的label标签去匹配集群内部的service，而我们的prometheus也可以通过label匹配多个ServiceMonitor。
其中Operator是核心部分，作为一个控制器而存在，Operator会其创建Prometheus、ServiceMonitor、AlertManager和PrometheusRule这4个CRD资源对象，然后一直监控并维持这4个CRD资源对象的状态。
Prometheus资源对象是作为Prometheus Service存在的ServiceMonitor资源对象是专门的提供metrics数据接口的exporter的抽象，Prometheus就是通过ServiceMonitor提供的metrics数据接口去pull数据的AlertManager资源对应alertmanager组件PrometheusRule资源对象是被Prometheus实例使用的告警规则文件 CRD简介 全称CustomResourceDefinition，在Kubernetes中一切都可视为资源，在Kubernetes1.7之后增加对CRD自定义资源二次开发能力扩展Kubernetes API，当我们创建一个新的CRD时，Kubernetes API服务将为你制定的每个版本创建一个新的RESTful资源路径，我们可以根据该API路径来创建一些我们自己定义的类型资源。CRD可以是命名空间，也可以是集群范围。由CRD的作用于scpoe字段中所制定的，与现有的内置对象一样，删除命名空间将删除该命名空间下的所有自定义对象。 简单来说CRD是对Kubernetes API的扩展，kubernetes中的每个资源都是一个API对象的集合，例如yaml文件中定义spec那样，都是对Kubernetes中资源对象的定义，所有的自定义资源可以跟Kubernetes中内建的资源一样使用kubectl。 这样，在集群中监控数据，就变成Kubernetes直接去监控资源对象，Service和ServiceMonitor都是Kubernetes的资源对象，一个ServiceMonitor可以通过labelSelector匹配一类Service，Prometheus也可以通过labelSelector匹配多个ServiceMonitor，并且Prometheus和AlertManager都是自动感知监控告警配置的变化，不需要人为进行reload操作。
二、安装Prometheus Operator Operator是原生支持Prometheus的，可以通过服务发现来监控集群，并且是通用安装。也就是operator提供的yaml文件，基本上在Prometheus是可以直接使用的，需要改动的地方比较少。
这里直接通过Prometheus-Operator的源码进行安装，当然也可以用Helm来进行一键安装。采用源码安装可以去了解更多的实现细节。
在安装之前，先把现在的环境说明一下
服务器IP系统主机名组件192.168.0.71CentOS7.6k8s-01Kubernetes 1.16.6,Docker 18.09.6,Etcd 3.3.20,Flanneld 0.11.0,kube-apiserver,kube-controller-manager,kube-scheduler,kubelet,kube-proxy,nginx-1.15.3192.168.0.72CentOS7.6k8s-02同上192.168.0.73CentOS7.6k8s-03同上192.168.0.74CentOS7.6nfs-server安装nfs服务用来持久化存储prometheus和grafana数据 如上表格，我已经用一键部署脚本部署好了k8s集群，并安装好了coredns插件和dashboard插件。
首先将Prometheus-Operator的源码克隆下来。这里有个坑要提前说一下：由于墙的原因，原本是要把Registry的地址换成微软中国的地址的，但是发现貌似从2020年4月份开始就用不了了，网上也是有很多的网友反映，暂时未能找到可以替代的镜像仓库地址。我这里已经把相关的镜像上传到了阿里云镜像仓库中。为了保证所需镜像的版本保持不变，我已经将https://github.com/coreos/kube-prometheus.git fork到了自己的github中，地址为https://github.com/wangchaoforever/kube-prometheus.git。
$ cd /opt/k8s/work $ git clone https://github.com/wangchaoforever/kube-prometheus.git ##注意：下面的镜像要在所有的k8s集群主机中都拉取和改tag # 拉取镜像 docker pull registry.cn-hangzhou.aliyuncs.com/wc181/alertmanager:v0.20.0 docker pull registry.cn-hangzhou.aliyuncs.com/wc181/grafana:6.6.0 docker pull registry.cn-hangzhou.aliyuncs.com/wc181/kube-state-metrics:v1.9.5 docker pull registry.cn-hangzhou.aliyuncs.com/wc181/kube-rbac-proxy:v0.4.1 docker pull registry.cn-hangzhou.aliyuncs.com/wc181/node-exporter:v0.18.1 docker pull registry.cn-hangzhou.aliyuncs.com/wc181/k8s-prometheus-adapter-amd64:v0.5.0 docker pull registry.cn-hangzhou.aliyuncs.com/wc181/prometheus:v2.15.2 docker pull registry.cn-hangzhou.aliyuncs.com/wc181/prometheus-operator:v0.38.1 docker pull registry.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66d938c7f9569d98aa681a4246b5142e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bee12fbe7a436df7439ce3609f1aec0/" rel="bookmark">
			mysql的alter语句中modify，rename，change详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接先抛出结论：
rename和change都是用于修改名称的
rename修改的是表名称，而change修改的是表中的字段名称。
文章最后还有一些骚操作，Just for fun。
modify用于修改表中字段的数据长度，数据类型以及字段的约束条件的。
首先最简单的是rename，用于修改表名，语法如下
alter table table_name rename [to] new table_name ; 这个语法没有什么可说的，to可要可不要，根据个人习惯，我一般是习惯性的加上to，就像使用别名时加上as一样。
然后就是change，用于修改字段名
alter table table_name change old_name new_name datatype...; --新字段需要完整定义 这里要注意的是你重新命名的新字段需要进行完整定义，并不是改字段名就可以。
最后就是modify，modify用于修改表中字段的数据长度，数据类型以及字段的约束条件的。
alter table table_name modify field datatype...; 这三者都同属于alter语句里面的内容，大概用法区别就是如此，语法也比较简单
接下来就是一些骚操作了
其实change也可以像modify一样修改表中字段的数据长度，数据类型以及字段的约束条件，只要你对字段进行完整的定义。
任意一表 有如下表结构，咱们就用change也来完成modify的工作，
我们执行如下语句，不进行改名的情况下（当然如果想，也可以改名），把原本varchar（10）类型，变为char(20)，把非空约束拿掉。
看看这个语句能不能执行的通
这样看来，如果有需求是需要修改字段名，同时修改数据长度，数据类型以及字段的约束条件，就可以用这样的方法
不过 总的来说 还是以文章开头的用法来使用，修改列名就用change，修改数据类型以及字段的约束条件还是用modify。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edef01ed7fddb444db63a5940f4860e1/" rel="bookmark">
			铁电存储器这样应对充电桩存储痛点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		中国今年提出了要求加快5G网络和数据中心等新型基础设施建设进度，在新型基础设施建设七个领域中，新能源充电桩在列。相比较加油站的充电桩能够承载更多的信息，除电流外还有信息流、资金流等等。作为车联网数据采集的主要端口，充电桩网络的大面积建成一定会成为未来社会交通系统的重要信息平台。
充电桩数据的记录和存储的非常重要的。充电桩是给新能源汽车提供电能的配套产品，充电桩在运作中需要处理大量的参数，通过系统监测数据和事件信息，实现设备集中远程监控，为设备故障诊断提供必要的数据支持，也为电站综合管理提供全面的统计数据和各类统计报表。为此所有数据必须进行统一的采集、查看和分析，并提供设备运行状态实时监测、危险警告与通知、数据查询分析、设备运行总额和管理等功能。
充电桩生产商需要挑选合适的存储芯片产品予以应对，其数据存储芯片的应用需求与智能表计非常相似。目前的铁电存储器在智能电表行业已经作为标准存储器被广泛采用，其具备的三个优势是许多同类型存储器芯片无法比拟的。FRAM存储器的三大优势分别是高速写入、耐久性以及低功耗。与EEPROM对比，FRAM存储器写入次数寿命高达10万亿次，而EEPROM芯片却仅有百万次(10^6)。富士通FRAM存储器写入数据可在150ns内完成，速度约为EEPROM存储器的3万倍。写入一个字节数据的功耗仅为150nJ，约为EEPROM的1/400，在电池供电应用中是具备有巨大的优势。
FRAM、EEPROM、FLASH主要参数对比
富士通FRAM能够进行高速写入且实现高速擦除。以保障数据安全为例，若遇到黑客违法盗取及分析充电桩的机密数据信息，将导致大范围的信息泄露。对此低功耗和高速的FRAM可以利用小型电池电源，瞬间消去重要数据，从而确保用户的信息安全。这时FRAM仅需0.1mA的工作电流，就能够在0.3ms的时间内擦除256bit的数据，相比EEPROM拥有显著的优势。
FRAM、EEPROM、FLASH工作电流与消去时间对比
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdd9b5a2b8e9692d2f8a1f3972be096c/" rel="bookmark">
			windows下sqlplus远程连接oracle
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 目标是在windows环境下安装sqlplus用来连接远程服务器上的oracle数据库，windows本地不需要安装oracle，只需要安装sqlplus组件即可；
为什么要使用sqlplus：因为navicat等通用工具不支持连接管理员用户，进行创建用户、授权等操作。
一、下载准备 首先确认服务器oracle版本，如果有navicat等远程工具连接普通用户可以执行select * from v$version;或者服务器本地登录查看。
根据查询到的版本到oracle官网下载对应版本的三个文件（比如我这里查询到的版本是12.2.0.1.0）：
instantclient-basic-windows.x64-12.2.0.1.0.zipinstantclient-sqlplus-windows.x64-12.2.0.1.0.zipinstantclient-sdk-windows.x64-12.2.0.1.0.zip 下载好后将三个文件解压合并到解压出来的同名文件夹中（三个解压出来的文件夹都形如instantclient_12_2\）
二、环境配置 假设解压文件放在C:\officesoft\oracle\sqlplus\下：
在右键计算机-&gt;高级-&gt;环境变量，
在系统变量中的Path变量后添加：
C:\officesoft\oracle\sqlplus\instantclient_12_2;
C:\officesoft\oracle\sqlplus\instantclient_12_2\sdk;
新增系统变量：
TNS_ADMIN，值为C:\officesoft\oracle\sqlplus\instantclient_12_2;
NLS_LANG，值为SIMPLIFIED CHINESE_CHINA.ZHS16GBK
三、远程连接 打开cmd窗口
sqlplus /nolog 进入SQL环境
conn username/password@ip:port/服务名 [as sysdba]
连接成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ddb58ddcd07c5c17236c90b7f0310fa/" rel="bookmark">
			Java学习之第一个代码与第一章练习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03033ecd40cc6f4b729bb51425609434/" rel="bookmark">
			2.前端框架—Vue的生命周期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Vue的生命周期☆1. Vue实例1.1 创建Vue实例1.2 模板或元素1.3 数据data1.4 方法methods 2. 生命周期钩子函数2.1 生命周期☆2.2 钩子函数☆2.3 this ☆ Vue的生命周期☆ 1. Vue实例 1.1 创建Vue实例 每个 Vue 应用都是通过用 Vue 函数创建一个新的 Vue 实例开始的：
var vue = new Vue({ // 选项 el:"#app" data:{ name:"mm" }, methods:{ } }) 1.2 模板或元素 每个Vue实例都需要关联一段Html模板，Vue会基于此模板进行视图渲染。我们可以通过el属性来指定。
&lt;!--例如一段html模板--&gt; &lt;div id="app"&gt; &lt;/div&gt; 然后创建Vue实例，关联这个div
var vm = new Vue({ el:"#app" }) 这样，Vue就可以基于id为app的div元素作为模板进行渲染了。在这个div范围以外的部分是无法使用vue特性的。
1.3 数据data 当Vue实例被创建时，它会尝试获取在data中定义的所有属性，用于视图的渲染，并且监视data中的属性变化，当data发生改变，所有相关的视图都将重新渲染，这就是“响应式“系统。
name的变化会影响到input的值input中输入的值，也会导致vm中的name发生改变 &lt;!--html--&gt; &lt;div id="app"&gt; &lt;input type="text" v-model="name"/&gt; &lt;/div&gt; //js var vue = new Vue({ el:"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03033ecd40cc6f4b729bb51425609434/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/850c279dfa631ce1af1a12d524adf787/" rel="bookmark">
			解决 websocket 无法注入bean （亲测正解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 初始化ApplicationContext时（在springboot启动类中）对该类的进行赋值
import org.springframework.context.ConfigurableApplicationContext; import org.springframework.boot.SpringApplication; public static void main(String[] args) { SpringApplication springApplication = new SpringApplication(Application.class); ConfigurableApplicationContext configurableApplicationContext = springApplication.run(args); //解决WebSocket不能注入的问题 WebSocketServer.setApplicationContext(configurableApplicationContext); } 在websocket类里加入： /** * 此处是解决无法注入的关键 */ private static ApplicationContext applicationContext; //举例 private StuService stuService; public static void setApplicationContext(ApplicationContext applicationContext) { MessageWebSocket.applicationContext = applicationContext; } // 具体根据自己需要注入的地方写一下方法 applicationContext.getBean(注入的类.class); //比如： applicationContext.getBean(StuService.class); 问题： websocket注入bean，通过直接在类里使用@Autowire和@Resource ，或者类上加@Component注解，ApplicationContext获取spring容器管理下的bean， 这些都属于spring管理的。 具体什么原因导致无法直接注入目前不明确。希望这些可以帮助到你们 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31ad67743889f5de0d7fcdacd7f62ff8/" rel="bookmark">
			早年黑网吧特供游戏《血战上海滩》如何在Win10运行?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		昨天发了一个读者讨论
image 有读者留言，国产游戏《血战上海滩》也是很好玩的射击游戏作品；
image-20201017211847416 《血战上海滩》运行在Win10的教程 由于《血战上海滩》年代久远，即使能找到安装包，也很难在Win10 运行了，但功夫不负有心人，我还是找到了《血战上海滩》在Win10完美运行的方法，并录了个小视频。
https://www.v2fy.com/p/2020-10-17-shanghai/
《血战上海滩》下载地址： 下载地址： https://zhaooolee.cowtransfer.com/s/29ec3c19c09644
自带修改器，祝你无伤通关! 如果你想轻松通关，可以使用我在安装包里附带的修改器，以管理员身份运行后，可以无限生命，无限弹药。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17c406861b8369499ef4eef37b618a7f/" rel="bookmark">
			Python努力学习笔记（第十二课）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python小白学习 Python学习第十二课简述说明1. 特殊⽅法2. 封装3. property装饰器看看这个的区别加了点东西的 Python学习第十二课 简述说明 因为课程已经学到后期了，相应的一些细则和例子会少一些，主要是一些关键性的概念之类的东西。
我理解的就是一些实际工作中会用到的一些规则、技巧之类的而且这这些东西都是有点类似于潜规则那种的大家都知道，就这么干（说实话不是这圈子的真不知道）
1. 特殊⽅法 1.在类中可以定义⼀些特殊⽅法也称为魔术⽅法2.特殊⽅法都是形如 xxx()这种形式3.特殊⽅法不需要我们调⽤，特殊⽅法会在特定时候⾃动调⽤ class Person: # 类属性 # name = '葫芦娃' def __init__(self): # 这个就是特殊方法 # 实例属性 print("hahah") def speak(self): print('大家好，我是%s' % self.name) if __name__ == '__main__': p1 = Person 看下图就会发现，我没有调用__init__()方法它就给出了结果，这就是魔术方法的特性特殊⽅法不需要我们调⽤，特殊⽅法会在特定时候⾃动调⽤
2. 封装 什么是封装：
这是百度词条给出的解释，我的理解就是举个例子：一个电子2级管，你拿到后根据他的说明，知道怎么用就好了，至于它内部有些什么东西，你不用管，也改变不了；放在编程中就是，我写了个方法给出了参数，和方法说明，你拿着用就好了，不能对我的方法轻易的进行更改。
出现封装的原因：我们需要⼀种⽅式来增强数据的安全性 属性不能随意修改属性不能改为任意的值 封装是⾯向对象的三⼤特性之⼀封装是指隐藏对象中⼀些不希望被外部所访问到的属性或⽅法我们也可以提供给⼀个getter()和setter()⽅法是外部可以访问到属性 getter() 获取对象中指定的属性setter() ⽤来设置对象指定的属性 使⽤封装，确实增加了类的定义的复杂程度，但是它也确保了数据 隐藏属性名，使调⽤者⽆法随意的修改对象中的属性增加了getter()和setter()⽅法，很好控制属性是否是只读的使⽤setter()设置属性，可以在做⼀个数据的验证使⽤getter()⽅法获取属性，使⽤setter()⽅法设置属性可以在读取属
性和修改属性的同时做⼀些其他的处理 下面这个是老师的程序例子，我偷懒了我承
class Dog: def __init__(self, name): self.hidden_name = name # getter查看属性 def get_name(self): # 只能查看，封装内部的东西，不能修改，有时候也会没有的 print('用户调用了此读取方法') return self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17c406861b8369499ef4eef37b618a7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca353512fa61ebbc102c98daec049fb6/" rel="bookmark">
			java8中CompletableFuture异步处理超时的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		stackoverflow上有一个讨论：Timeout with default value in Java 8 CompletableFuture
其中大家讨论了实现方案
其中的一个解决方案：
原文链接：Asynchronous Timeouts with CompletableFuture
如何实现Asynchronous timeouts
Java 8 的 CompletableFuture 并没有 timeout 机制，虽然可以在 get 的时候指定 timeout，但是我们知道get 是一个同步堵塞的操作。怎样让 timeout 也是异步的呢？
timeout异步就是说，如果forkjoin-pool中一个线程在规定时间内没有返回，那么就结束掉，而不是继续执行直到获取结果，比如main线程200ms内返回，但forkjoin-pool中某个执行线程执行400ms才返回，而其返回值根本没有被使用到
Java 8 内有内建的机制支持，一般的实现方案是启动一个 ScheduledThreadpoolExecutor 线程在 timeout 时间后直接调用 CompletableFuture.completeExceptionally(new TimeoutException())，然后用 acceptEither() 或者 applyToEither 看是先计算完成还是先超时：
public static &lt;T&gt; CompletableFuture&lt;T&gt; within(CompletableFuture&lt;T&gt; future, long timeout, TimeUnit unit) { final CompletableFuture&lt;T&gt; timeoutFuture = timeoutAfter(timeout, unit); // 哪个先完成 就apply哪一个结果 这是一个关键的API return future.applyToEither(timeoutFuture, Function.identity()); } 一个简单的 timeoutAfter 实现如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca353512fa61ebbc102c98daec049fb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a2cab68c47cecfaceadadc5a941d06b/" rel="bookmark">
			卿学姐的b站视频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		qscqesze
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d340aaaa18a8d50093670d58ba4eb7f6/" rel="bookmark">
			8 种常见SQL错误用法，看了都说好！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方 "程序员小乐"关注, 星标或置顶一起成长
后台回复“大礼包”有惊喜礼包！
关注订阅号「程序员小乐」，收看更多精彩内容 每日英文
Tough people aren't born that way, they become that way when no one's there to wipe their tears away. 人并非生来就坚强，没人替自己擦泪，就只能变得坚强。
每日掏心话
忍耐不是为了让你不去处理这件事情，而是为了避免在情绪失控的情况下，干出什么让自己丢脸的事情。以后你就会知道，生活中真的没有几件事情是值得我们搭上礼貌，教养，人品和格局的。
来自：db匠 | 责编：乐乐
链接：yq.aliyun.com/articles/72501
程序员小乐(ID:study_tech)第 1024 次推文
往日回顾：没有这 29 款插件的 Chrome 是没有灵魂的～
正文 1、LIMIT 语句
分页查询是最常用的场景之一，但也通常也是最容易出问题的地方。比如对于下面简单的语句，一般 DBA 想到的办法是在 type, name, create_time 字段上加组合索引。这样条件排序都能有效的利用到索引，性能迅速提升。
SELECT * FROM operation WHERE type = 'SQLStats' AND name = 'SlowLog' ORDER BY create_time LIMIT 1000, 10; 好吧，可能90%以上的 DBA 解决该问题就到此为止。但当 LIMIT 子句变成 “LIMIT 1000000,10” 时，程序员仍然会抱怨：我只取10条记录为什么还是慢？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d340aaaa18a8d50093670d58ba4eb7f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f146ba644459f4d5abcb3fadd48a6612/" rel="bookmark">
			JS内置对象及其用法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天去面试了一家小公司~面试题都比较基础，但是比较悲催的是本人日常不爱总结导致基础记得都很模糊，so结束的时候就为自己点了一首凉凉。所以决定还是日常总结一下，毕竟温故而知新，可以为师也吗！
首先JS对象分为3种：自定义、内置、浏览器。今天就总结一下JS内置对象以及一些用法。
一、Math对象:不是一个构造函数，不需要new，直接调用即可。
1.Math.max(x,y);返回x,y的最大值。注意：如果小括号种的值有非数值，则返回NaN，如果什么都没有返回-Infinity。
Math.max('aa',);-&gt; NAN Math.max(); -&gt;Infinity 2.Math.abs(x);返回x的绝对值
3.Math.ceil(x);对x进行向上取整
Math.ceil(2.5)-&gt;3 Math.ceil(-2,3)-&gt;-2 4.Math.floor(x);对x进行向下取整
Math.floor(2.1)-&gt;2 Math.floor(-1.7)-&gt;2 5.Math.round(x);把数四舍五入为最接近的数。其他数字都是四舍五入，但是.5特殊，是往大了取。
Math.round(1,5)-&gt;2 Math.round(-1.5)-&gt;-1 Math.round(-2.3)-&gt;-2 6.Math.random();返回介于【0，1]的之间的一个随机数。返回一个两数之间的随机数方法：
Math.floor(Math.random()*(max-min+1)+min);
7.Math.pow(x,y);返回x的y次幂
二、日期对象 Date();是一个构造函数，必须使用new对象来调用创建我们的日期对象，如果没有参数，则会返回当前系统的当前时间。
1.创建Date对象的语法：
var myDate=new Date();
2.myDate.getDate();返回一个月中的某一天(1~31)
3.myDate,getDay()返回一周中的某一天(0~6)周日返回0.
4.myDate,getMonth();返回月份(0~11)所以真实的月份应该是myDate.getMonth()+1
5.myDate.getFullYear();以四位数字返回当前日期的年份
下面写一个获取当前日期正确格式的写法。
虽然new Date()是返回当前系统的日期，但是出来的结果并非是常用的格式，如图：
正确获取当前格式写法：
6.myDate,getHours();返回小时
7.myDate.getMinuter();返回分
8.myDate.getSeconds();返回秒
当前日期时分秒正确格式的封装函数：
9.var date=+new Date(time);time可以是输入的一个时间，按照yyyy-MM-DD的格式输入，然后返回的是该time日期距离1970年1月1号过了多少毫秒，时间戳，可以用来做倒计时案例。
三、数组对象 Array
1.数组对象的创建方式有两种：
(1).利用数组字面量 var arr=[1,2,3];
(2).利用new Array ;
var arr=new Array();表示创建了一个空数组
var arr=new Array(2);//表示这个数组的长度为2，里面有2个空的数组元素
(3).var arr=new Array(2,3);等价于[2,3]
2.检测是否为数组方法
(1).instanceof
arr instanceof Array
(2).Array.isArray(arr);用来确定传入的参数是否是一个数组。
Array对象的一些方法
1.concat() 连接两个或更多的数组，并返回结果
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f146ba644459f4d5abcb3fadd48a6612/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af527a4cee873562970163b78275052a/" rel="bookmark">
			查看Tensorflow、CUDA及cuDNN版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看Tensorflow、CUDA及cuDNN版本 1. 查看Tensorflow版本 打开cmd,输入
python
import tensorflow as tf
tf.__version__
2. 查看windows的CUDA版本 法一：打开cmd,输入 nvcc --version
法二：按win+Q，输入控制面板，然后点击NVIDIA控制面板；
点击NVIDIA控制面板的帮助，点击左下角系统信息；
点击组件：这里就显示了你的CUDA的信息啦。
需注意：若控制面板显示版本与法一 nvcc --version不一致，则以法一版本为准。因为控制面板显示的版本应该是显卡支持的cuda最高版本。
3.查看windows的cuDNN版本 首先进入文件夹C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v10.1\include，找到名为cudnn.h的文件；
然后用记事本打开即可看到代码中的前部声明部分。
即：我的cuDNN版本号为7.5.0。
需注意：cuda11.0后新的cudnn版本在C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.0\include\cudnn_version.h 文件中定义版本号！而不是上述说的cudnn.h！
纪念一下第一次发博客，也想在之后的科研道路上把学到的、用到的知识多多总结，多多回顾。
可能有不全面的地方，也欢迎大家多提建议，多多讨论！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3b9c4c08cdcb00785de088361d3ae37/" rel="bookmark">
			基于Eviews的稳定性检验——以个股的β系数为例（含ADF检验步骤及结果分析）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于Eviews的稳定性检验——以个股的β系数为例（含ADF检验步骤及结果分析） 数据的获取将Excel数据导入到Eviews时间序列图单位根检验与ADF检验个股的β系数稳定性检验补充 总结 在资本资产定价模型（CAPM）中，β系数也称为贝塔系数（Beta coefficient），是一种风险指数，用来衡量个别股票或股票基金相对于整个股市的价格波动情况。如果β系数不具有稳定性，CAPM将不再适用，所以，检验β系数的稳定是很有必要的。
数据的获取 个股的β数据可从锐思数据库（RESSET）中获取，详情参见上一篇博客
基于SPSS的正态性检验方法汇总——以个股收益率为例（超详细）
注意风险因子β选择流通市值加权。
将Excel数据导入到Eviews 打开Eviews软件，选择Open a Foreign file (such as Excel)
如果打开报错，说明需要在Excel中进行设置。
Excel中选择文件—选项
选项中点击加载项，在管理处选择COM加载项并点击转到。
将可用加载项全部不勾选，然后点击确定并保存，即可成功导入到Eviews中。
一直点击下一步，嫌麻烦可以直接点完成。
询问处点Yes。
Eviews无法识别中文，所有中文处均用下划线代替。
时间序列图 双击第一个“____________…”，然后点View—Graph即可绘制数据的时间序列图。
选择图的类型。
即可得到β系数的时间序列图。
单位根检验与ADF检验 单位根检验是指检验序列中是否存在单位根，因为存在单位根就是非平稳时间序列了。单位根就是指单位根过程，可以证明，序列中存在单位根过程就不平稳，会使回归分析中存在伪回归。
DF检验与ADF检验均是基于单位根检验。Dickey-Fuller通过研究发现t统计量在原假设下已经不再服从t分布。为此,Mackinnon进行了大规模的模拟，给出了在单变量情况下不同回归模型以及不同样本数下t统计量在1%、5%和10%显著性水平下的临界值。这样，就可以根据需要，选择适当的显著性水平，通过t统计量来决定是否接受或拒绝原假设。这一检验被称为Dickey-Fuller检验（DF检验）。
上面描述的单位根检验只有当序列为AR（1）时才有效。如果序列存在高阶滞后相关，这就违背了扰动项是独立同分布的假设。在这种情况下，Dickey-Fuller提出了使用增厂的DF检验方法(Augmented Dickey-Fuller test )来检验含有高阶序列相关的序列的单位根。
个股的β系数稳定性检验 View—Unit Root Test…
Test type 选择 Augmented Dickey-Fuller
Test for unit root in 中 Level 表示原时间序列，1st difference表示一阶差分，2nd difference 表示二阶差分，只检验原序列的稳定性只选Level就可以。
Include in test equation 中Intercept 表示截距项，Trend and intercept 表示趋势项和截距项，None 表示两者均无，如果可以从时间序列图中很明显的看出是否有趋势项或截距项选择一个就可以，如果不能直接观察出来需要依次选三个然后进行比较。
右边的内容不需要改。
首先选择截距项，计算结果如下图所示。
先看圈1，ADF检验的 t-Statistic 大于下面1%、5%、10%level的任意一个 t-Statistic，说明只存在截距项时，不拒绝原假设，存在单位根，序列非平稳。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3b9c4c08cdcb00785de088361d3ae37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65566dfa01d5b3d112829b4422152fbd/" rel="bookmark">
			Titanic数据集百度云盘下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		百度云盘下载
链接：https://pan.baidu.com/s/1jF99BjxeRXxSUDhCcZ5RjQ
提取码：8gx6
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d4f12cc2b1f01f0b758008f81114988/" rel="bookmark">
			Git的使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先在github上注册一个账号:http://github.com
之后，点击右上角的加号，选中New repository
出现下面界面：
只需要输入仓库的名称就可以了
为了后期可以把我们创建的库推到远程库中，我们要：
把我们库的名称进行修改，改成"用户名.github.io"，如果不是这种格式，就不能把库推到远程库中。
之后，去http://msysgit.github.io/ 下载msysgit，下载的时候默认下一步就可以了，这里就不教了
下载安装之后，去桌面点击右键会发现，多了Git GUI Here和Git Bash Here
我们点开GIt Bash Here,打开命令窗口
我们可以通过cd 命令进行跳转盘符，我们去到E盘
如果不想用命令切换盘符，我也可以直接在E盘下，点击鼠标右键的Git Bash Here,直接进入
这上面一样，
这样我们就可以创建github仓库并把它克隆到本地
这样，就会在e盘下生成我们的库：
进入库后，我们可以看到一个.git文件夹，如果看不到，就把隐藏目录勾上，
之后，我们可以在我们克隆的库中创建index.html文件，
再在空白处，点击右键选择"Git Bash"，进入github命令，通过：
之后，通过：
git add index.html
git commit -m “yes”
进行注释，最后我们就可以把文件推送到服务器中了，
git push origin master
来到我们github网站,会发现多了index.html
之后我们在输入我们的网站就可以远程访问了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19f3f82102dfb87231491cec5db308e0/" rel="bookmark">
			查找数组最大值五种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		例如查询公司员工的最高薪资，以及班级的最高成绩又或者是面试中都会遇到查找最大值的问题，所以本文我们就来列举一下查询数组中最大值的 5 种方法。 1.for循环方式 for循环方式手动定义一个最大值，循环比较，如果数组的某一个元素比最大值还要大，就将这个数组元素作为最大值
比如说定义的最大值是0 现在开始循环 数组下标为0的第一个元素2 大于0 此时将2作为最大值，依次类推，循环结束，就查找到最大值
public static void main(String[] args) { int[] arr = {2, 8, 19, 3, 98, 12}; int max = findArrayMax_value(arr); System.out.println("最大值:" + max); } public static int findArrayMax_value(int[] arr) { //手动定义一个最大值 int max = 0; //循环遍历 for (int ele : arr) { //判断数组中每一个元素和最大值的关系 if (ele &gt; max){ //如果数组元素大 就赋值给max max = ele; } } =============== 一般使用增强for循环 ======================= for (int i = 0; i &lt; arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19f3f82102dfb87231491cec5db308e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4ce92046086c172e9224a62bda1537c/" rel="bookmark">
			Windows 10 VS 2013 Bundle fusion 代码运行笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在搞人体面部重建，本来打算通过一个正视图或者两个侧视图进行三维重建，实践中发现无论相机以哪个角度拍摄人脸，较少张的图像数据都不能包含所有部位的人脸数据。经过分析，想实现完整的人体面部重建，只能通过连续的图像序列实现人脸三维重建。经过网上检索bundle fusion在RGBD相机三维重建中，效果算是比较好的，所以下载下来运行下试试，由于使用的是国产的奥比中光的RGBD深度相机，所以这里先采用公开数据集进行实验。
安装的速度还是蛮快的，就是开始有点纠结要不要安装VS2013，想先看下算法效果就果断安装了。
操作系统：Windows 10 2004 update sep
CPU：i7-8750H
显卡：GTX1060 Max-Q
安装步骤如下
1.IDE visual studio 2013 update 5
地址:https://docs.microsoft.com/zh-cn/visualstudio/releasenotes/vs2013-update5-vs 2.CUDA 8.0 安装后命令行输入nvcc -V，验证安装是否成功。
安装的时候驱动可以使用最新的驱动，cuda安装8.0即可，如下图选择安装内容。
地址：https://developer.nvidia.com/cuda-80-ga2-download-archive 3.DirectX SDK
地址：http://download.microsoft.com/download/A/E/7/AE743F1F-632B-4809-87A9-AA1BB3458E31/DXSDK_Jun10.exe 4.下载代码，我把代码放到了D:\workspace\git_rep下面
#下载 BundleFusion git clone https://github.com/niessner/BundleFusion #下载mLib代码，如果失败手动下载并复制到对应目录，mLib地址：https://github.com/niessner/mLib git submodule update --init --recursive mLib external下载地址：
http://kaldir.vc.in.tum.de/mLib/mLibExternal.zip 或者https://www.dropbox.com/s/fve3uen5mzonidx/mLibExternal.zip?dl=0，解压后，放到 BundleFusioin 同级目录。
代码下载好后目录如下：
5.修改文件
（1）原来代码中设置的是使用cuda 7.0，这里安装的是cuda 8.0，所以要把设置改为8.0。
编辑BundleFusion/FriedLiver/FriedLiver.vcxproj，将所有的CUDA 7.0.props都变成CUDA 8.0.props即可，共两处，35行和375行。
（2）修改GlobalAppState.h为如下
然后用Release编译（debug会报dll缺失的错），编译成功。
如果想要用debug编译，需要将mLibExternal/libsWindows/dll64里的FreeImage.dll放入C:\Windows\System32和C:\Windows\SysWOW64即可。
将zParametersDefault.txt中的s_sensorIdx 设为8，使用离线模式。
下载数据集：http://graphics.stanford.edu/projects/bundlefusion/
将s_binaryDumpSensorFile = "../data/apt0.sens";设置为你自己的数据集路径。
回到程序里直接ctrl+f5运行即可，使用公开数据集测试完结，附一张结果图。
参考文献：
1.BundleFusion使用Intel RealSense D435i深度相机实现
2.win10+cuda8.0+vs2013+kinectv2+bundlefusion的安装配置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4ce92046086c172e9224a62bda1537c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2ca6abebf98964668a2c8be87c7e6df/" rel="bookmark">
			for循环中定义两个变量的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 for循环定义两个变量 转载▼ 分类： java
今天遇到一个很有意思的for循环，里面定义了两个变量，写法如下
for(int i=1,j=i+10;i&lt;5;i++,j=i*2){ System.out.println("i="+i+ "j="+j); } 打印结果如下： i=1 j=11 i=2 j=4 i=3 j=6 i=4 j=8 个人理解： 1、int i=1,j=i+10 定义变量初始值 i=1，j=11 2、i&lt;5 定义循环范围 3、i++,j=i*2 变量递增规则 这辈子坚持与不坚持都不可怕,怕的是独自走在坚持的道路上！！！
吃水不忘打水人,参考链接 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d624fdca3bfc73236dba9ddb1ab0b798/" rel="bookmark">
			Android Uri url file path区别/如何在SD卡上保存一张图片呢？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android URI&amp;&amp;URL的定义与使用
Android Url&amp;Uri详细解析
Android URI简介
Android中的Uri详解
在操作MediaStore的时候会用到Uri。
如何在SD卡上保存一张图片呢？
（1）之前的方式
我们都是在SD卡下面建一个目录比如/storage/emulated/0/shvdownload/video/tempVideo，然后把把需要保存的媒体资源（图片、视频）通过File 输出流的方式写入文件。然后就不管了，让系统触发扫描的时候，把这个媒体信息放到MediaStore中；或者通过触发MediaStore扫描，看参考文章。
从Android10开始，引入了分区存储，不让直接通过File的方式操作SD卡路径了。必须通过MediaStore，也就是说，让MediaStore给你指定存放位置，暴露抽象的Uri，让你用，真实路径隐藏。
（2）通过MediaStore的方式
MediaStore其实就是一个数据库，里面存的是媒体信息（名字、描述、路径等），访问MediaStore通过ContentResolver。MediaStore存的只是媒体信息，保存媒体本身到本地还是需要我们自己完成的，只不过MediaStore告诉了我们位置，而且有写入的方式。
public Uri createImageUri(Context context) { ContentValues values = new ContentValues(); // 需要指定文件信息时，非必须 values.put(MediaStore.Images.Media.DESCRIPTION, "This is an image"); values.put(MediaStore.Images.Media.DISPLAY_NAME, "Image.png"); values.put(MediaStore.Images.Media.MIME_TYPE, "image/png"); values.put(MediaStore.Images.Media.TITLE, "Image.png"); //values.put(MediaStore.Images.Media.RELATIVE_PATH, "Pictures/test"); return context.getContentResolver().insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, values); } 先在MediaStore的Images中创建一条表示图片的记录，返回表示这个图片的Uri。
我们连续调用两次，看看结果都是啥
public void showMediaInfo(Context context, Uri uri) { Cursor cursor= context.getContentResolver().query(uri, null, null, null, null); //System.out.println("lzy cursor.getCount() = " + cursor.getCount()); cursor.moveToFirst(); String path = cursor.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d624fdca3bfc73236dba9ddb1ab0b798/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4ff485b64c513584bc5868d1c54eb62/" rel="bookmark">
			Halcon中 reduce_domain算子和crop_domain算子的使用及配合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 reduce_domain算子 reduce_domain ( Image, Region : ImageReduced : : ) 其中，Image是输入的图像；Region是输入的区域；ImageReduced是输出的图像，是Image中Region的那部分图像。 通过reduce_domain确实能获得特定区域Region位置的图像，但是，reduce_domain是缩小一个图像的定义域，并不缩小图像的实际尺寸，即新图像ImageReduced尺寸大小并未发生变化。如果使用get_image_size来计算ImageReduced图像的尺寸，其尺寸和 原图Image一样。
并且，包括一系列的domain算子，比如change_domain，均不改变图像矩阵的大小。
2 crop_domain算子
crop_domain ( Image : ImagePart : : ) Image是输入的原始图像；ImagePart是输出的最小外界正矩形的图像，也就是说，如果一副大图上，就一块区域有值，其他区域均没有值。通过调用该函数，能够将有值的区域以最小外界正矩形的方式返回，而剪掉那些没有值的区域。 crop_domain能够对图像的尺寸进行剪裁。而且，其一系列的domain算子均能对图像尺寸进行剪裁。
3 配合使用的效果
reduce_domain ( Image, Region : ImageReduced : : ) crop_domain ( ImageReduced : ImagePart : : ) 一般来说，如果想要得到某个ROI区域的小图，且对小图的尺寸有要求时，需要特别注意，配合使用上述两个函数。比如说要调用傅立叶变换对小图进行分析。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48218477916602c5ca0cb93c948283a2/" rel="bookmark">
			蚂蚁金服网红技术团队分享，用 JavaScript 全栈打造商业级应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“云”端的语雀：用 JavaScript 全栈打造商业级应用
来源：https://my.oschina.net/yuque/blog/4293422
大家好，我是蚂蚁金服语雀产品技术负责人 不四（死马），想跟大家分享也许是西湖区最复杂的 Node.js 应用的相关实践。
写在前面 纸上得来终觉浅，绝知此事要躬行。
文章中所涉及的PPT 已经上传到：我的语雀专栏
https://www.yuque.com/seeconf/2020/slide
，欢迎下载，同时语雀也参与了Gitee 七周年纪念日，为大家提供了一份小小的福利，戳以下地址领取 3 个月的语雀 VIP 会员，
https://www.yuque.com/e/channel?channel=gitee
希望大家可以通过体验这个产品，了解我们的一些技术实现。
语雀是什么？ 语雀是一个专业的云端知识库，面向个人和团队，提供与众不同的知识管理，打造轻松流畅的工作协同，它提供各种格式的在线文档（富文本、表格、设计稿等）编辑能力，支持实时在线多人协同编辑，数据云端保存不丢失。而语雀与其他文档工具最大的不同是，它通过知识库来对文档进行组织，让知识创作者更好的管理知识。
语雀技术架构演进 原型阶段 语雀诞生于 2016 年，当时蚂蚁金融云需要一个工具来承载它的文档。当时负责的技术同学利用业余时间，开始搭建这个文档工具。项目的初期，没有任何人员和资源支持，同时也为了快速验证原型，技术选型上选择了最低成本的方案。
底层服务完全基于体验技术部内部提供的 BaaS 服务和容器托管平台：
Object 服务：一个类 MongoDB 的数据存储服务；
File 服务：阿里云 OSS 的基础上封装的一个文件存储服务；
DockerLab：一个容器托管平台；
这些服务和平台都是基于 Node.js 实现，专门给内部创新型应用使用，也正是由于有这些降低创新成本的内部服务，才给工程师们提供了更好的创新环境。
应用层服务端自然而然的选用了体验技术部开源的 Node.js Web 框架 Egg（蚂蚁内部的封装 Chair），通过一个单体 Web 应用实现服务端。应用层客户端也选用了 React 技术栈，结合内部的 antd，并采用 CodeMirror 实现了一个功能强大、体验优雅的 markdown 在线编辑器。
image.png 这时可以算作语雀的“原型阶段”，它仅仅是一个工程师的业余项目，采用内部专为创新应用提供的 BaaS 服务和一系列的开源技术解决方案，验证了在线文档工具这个产品原型。
PS：当时我还不在语雀团队，但是巧的是我却在给语雀提供 Object、File 等 BaaS 服务和 Egg.js Web 框架的支持。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48218477916602c5ca0cb93c948283a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69632287244038590efa0081e7d191e0/" rel="bookmark">
			Leetcode算法系列二（链表）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.8道经典链表常考题目 例1-a：反转链表
例1-b：反转链表2
例2：链表求交点
例3：链表求环
例4：链表划分
例5：复杂链表的复制
例6-a：2个排序链表归并
例6-b：K个排序链表归并
206.反转链表 反转一个单链表。
示例:
输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL
进阶:
你可以迭代或递归地反转链表。你能否用两种方法解决这道题？
public class Solution { public ListNode reverseList(ListNode head) { ListNode newHead=null; while(head!=null){ ListNode node=head.next; head.next=newHead; newHead=head; head=node; } return newHead; } } 92. 反转链表 II 反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。
说明:
1 ≤ m ≤ n ≤ 链表长度。
示例:
输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4
输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL
public class Solution { public ListNode reverseBetween(ListNode head, int m, int n) { ListNode dumy=new ListNode(-1); dumy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69632287244038590efa0081e7d191e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ca2af7399c945bd4bfaf0de4df0569d/" rel="bookmark">
			求职必备、面试刷题不二之选，此两份算法刷题宝典让你收集大厂offer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 这几年IT技术蓬勃发展，对技术人才的需求日益增长，程序员招聘市场也如火如荼。在有限的三五轮面试中，国外流行让面试者编程解决某些数据结构和算法的题目，通过观察面试者编码的熟练程度、思考的速度和深度来衡量面试者的能力和潜力。除字节跳动之外国内以百度、阿里、腾讯为首的互联网企业也都逐步开始采用算法面试来筛选人才。
如今想要收获大厂offer，在面试的前几轮，总是躲不开算法这座大山。
常听人说，算法很难。这话没错。算法本身是是一个艰深的方向。但是算法题却有据可循。通过有针对性的学习和练习，我们完全可以掌握解题的基本方法和技巧，见题拆题，扫清通往offer之路上的障碍。
第一份算法宝典 目录大纲
面试题略过............................................................................................
第一章、动态规划系列 动态规划之背包问题
最长公共子序列
第二章、数据结构系列 快速计算完全二叉树的节点
第三章、算法思维系列 FloodFill算法详解及应用
啥是FloodFill算法呢，最直接的一一个应用就是「 颜色填充」，就是Windows绘画本中那个小油漆桶的标志，可以把一块被圈起来的区域全部染色。
区间交集问题
第四章、高频面试系列 BFS算法秒杀各种益智游戏
滑动拼图游戏大家应该都玩过，下图是一个4x4的滑动拼图:
内容过多就不一一详写了，完整版在文末................................................
第二份算法宝典 目录大纲
Σ( ° △ °|||)︴ 内容极多，略过 ..........................................................................................
包含4个部分
第一部分(第1~2章)主要描述抽象数据类型，给出算法的基本概念和复杂度分析与评价方法，并讨论几乎每章都要用到的递归和回溯技术。第二部分(第3~9章)介绍基本数据结构，包括链表、栈、队列、树、优先队列、堆、并查集和图，对于每一种数据结构分别采用多个实例进行具体的演示。第三部分(第10~15章)介绍数据处理的技术，包括排序、查找、选择、符号表、散列和字符串算法。第四部分(第16~21章)重点介绍一些常用的算法设计技术及应用，包括贪婪算法、分治算法、动态规划算法、复杂度类型，并讨论对于面试和考试的一些有用话题。 第1章绪论
本章的目的是阐述算法分析的重要性、它们的表示法和关系，并尽可能求解多个问题。首先，让我们重点关注算法的基本要素、分析的重要性，然后再逐步讨论上述提及的其他主题。在完成本章的学习后，能够分析任意给定算法的复杂度(特别是递归函数)。
内容极多...............就不一一展现了
大O图示法
分治法主定理的相关问题
第2章递归和回溯
本章将探讨一个重要的内容“递归”。本书中几乎每章都要用到递归，同时还介绍一个与之相关的概念“回溯”。
递归与迭代
什么是回溯
第3章链表
链表是一种用于存储数据集合的数据结构。链表有以下属性:
相邻元素之间通过指针连接。最后一个元素的后继指针值为NULL.在程序执行过程中，链表的长度可以增加或缩小。链表的空 间能够按需分配(直到系统内存耗尽)。没有内存空间的浪费(但是链表中的指针需要一些额外的内存开销) 链表、数组和动态数组的比较
删除单向链表的最后一个结点
循环链表
松散链表
第4章栈
第5章队列
第6章树
第7章优先队列和堆
第8章并查集ADT
第9章图算法
栈的相关问题
队列抽象数据类型
二叉树
堆和二叉堆
路径压缩
最小生成树
第10章排序
第11章查找
第12章选择算法( 中位数)
第13章符号表
第14章散列
第15章字符串算法
排序的相关问题
选择算法的相关问题
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ca2af7399c945bd4bfaf0de4df0569d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7911077e12f787a920115af7d6470ac/" rel="bookmark">
			数据库之多表查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库之多表查询
要求：
1.创建student和score表
2.为student表和score表增加记录
3.查询student表的所有记录
4.查询student表的第2条到4条记录
5.从student表查询所有学生的学号（id）、姓名（name）和院系（department）的信息
6.从student表中查询计算机系和英语系的学生的信息
7.从student表中查询年龄18~22岁的学生信息
8.从student表中查询每个院系有多少人
9.从score表中查询每个科目的最高分
10.查询李四的考试科目（c_name）和考试成绩（grade）
11.用连接的方式查询所有学生的信息和考试信息
12.计算每个学生的总成绩
13.计算每个考试科目的平均成绩
14.查询计算机成绩低于95的学生信息
15.查询同时参加计算机和英语考试的学生的信息
16.将计算机考试成绩按从高到低进行排序
17.从student表和score表中查询出学生的学号，然后合并查询结果
18.查询姓张或者姓王的同学的姓名、院系和考试科目及成绩
19.查询都是湖南的学生的姓名、年龄、院系和考试科目及成绩
过程：
1.创建student和score表
2.为student表和score表增加记录
3.查询student表的所有记录
4.查询student表的第2条到4条记录
5.从student表查询所有学生的学号（id）、姓名（name）和院系（department）的信息
6.从student表中查询计算机系和英语系的学生的信息
7.从student表中查询年龄18~22岁的学生信息
8.从student表中查询每个院系有多少人
9.从score表中查询每个科目的最高分
10.查询李四的考试科目（c_name）和考试成绩（grade）
11.用连接的方式查询所有学生的信息和考试信息
12.计算每个学生的总成绩
13.计算每个考试科目的平均成绩
14.查询计算机成绩低于95的学生信息
15.查询同时参加计算机和英语考试的学生的信息
16.将计算机考试成绩按从高到低进行排序
17.从student表和score表中查询出学生的学号，然后合并查询结果
18.查询姓张或者姓王的同学的姓名、院系和考试科目及成绩
19.查询都是湖南的学生的姓名、年龄、院系和考试科目及成绩
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ddd6849daa9c8b14ae4c264f9f73a6e/" rel="bookmark">
			2020电赛E题--非线性失真器程序设计-02-使用STM32实现THD高精度测量采集（附整个工程gitee链接）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 从前我也是个白嫖怪，现在我想要当个被白嫖的人。如果有帮助，希望能留言个下次一定（老b站了hhhh）工程开源说明：分享在电赛期间的每个版本的程序，希望能对大家有帮助，本文档大致进行说明下代码的讲解，懒得下载的人可以通过文章中的代码自行调试。
gitee链接 不习惯github，还是换成国内的平台了。
快嫖我，快嫖我
代码功能描述 （备注：有些部分是直接把正点原子的例程的东西贴过来改写的，所以大家在正点的板子上可能更方便操作，我们使用的板子是自己做的板子，所以屏幕显示可能直接使用正点原子的板子无法正常显示，这个只需要在正点的LCD的例程下面进行修改即可，别的按键功能只需要自行修改管脚即可），波形的幅值大小是根据我们的模拟部分进行拟合的，所以显示的是放大器输出的大约的幅值大小。
使用网版FFT，定时器3采集版本 我们为了保证进行FFT之后的精准程度（分度值），在权衡下，选择了10240HZ为最后的采样频率，采样点数为1024，这样我们得到的频域的数据的分度值是10hz，所以也就能保证我们比较精准取到1k，2k，3k，4k，5k频率下的频域的幅值信息。
大致功能说明：
使用PA1进行ADC的采样。采样定时器3进行定时采集（控制采样时钟）。只进行一次采集测试，复位后进行下次采集。绘制频谱和波形图。 版本效果展示 使用FFT库函数，定时器输出PWM波进行采集版本 我们为了保证进行FFT之后的精准程度（分度值），在权衡下，选择了10240HZ为最后的采样频率，采样点数为1024，这样我们得到的频域的数据的分度值是10hz，所以也就能保证我们比较精准取到1k，2k，3k，4k，5k频率下的频域的幅值信息。
只进行讲解说明最终版本的功能：
使用PC1进行ADC的采样。（和上个版本略有不同）通过继电器切换控制不同失真状态可以全自动循环采集各种失真情况下的THD。全自动模式下，采集5次求均值进行保存显示可以实现单种状态循环测量可以通过按键切换不同的失真状态（控制继电器）可以显示频谱和波形数据 最终实现效果展示 这里是单独测试程序功能，没有接继电器，全自动模式测试显示的失真状态的汉字可能对不上，随机给了波进行测的，见谅。后面三种波形测试放到了单次循环的模式下。
测试三种1k的信号的理论值 正弦：1%以内方波：大约38.87%三角波：大约11.81% 测量1k方波 测试1k正弦波 测试1k三角波 定时器3采集版本代码： 这里的FFT算法同前文，不进行展示。由于c文件比较多，对没有参数声明，只是函数声明的h文件不再进行展示。lcd显示屏的代码不再展示，自行修改显示到自己的平台下。
main.c /* Includes ------------------------------------------------------------------*/ #include "usart.h" #include "fft.h" #include &lt;math.h&gt; #include "led.h" #include "delay.h" #include "key.h" #include "sys.h" #include "lcd.h" #include "usart.h"	#include "adc.h" #include "timer.h" #include &lt;stdio.h&gt; /* Private typedef -----------------------------------------------------------*/ /* Private define ------------------------------------------------------------*/ /* Private macro -------------------------------------------------------------*/ #define N 1024 //采样点数 #define Fs 10240 //采样频率 #define F 10 //分辨率 /* Private variables ---------------------------------------------------------*/ /* Private function prototypes -----------------------------------------------*/ /* Private functions ---------------------------------------------------------*/ extern float data[1024]; extern int end; /*屏幕设计频谱*/ int x11=20; int y11=120,y12=220; //竖 int x21=20,x22=280;//横 int y21=120; /*屏幕设计波形*/ int X1=20,X2=160; int Y1=1,Y2=101; int XX1=20,YY1=1; //FFT测试数据集 输入数组 complex FFT_256PointIn[N]; //FFT测试数据集 输出数组 float FFT_256PointOut[N/2]; float Mag[N/2]; u8 temp1[20]; //填入数组	测试	//void InitBufInArray() //{ // unsigned short i; // for(i=0; i&lt;N; i++) //	{ // FFT_256PointIn[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ddd6849daa9c8b14ae4c264f9f73a6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/160f5568c1678bf2a524b6a63b3d46bd/" rel="bookmark">
			Jenkins 	 Extended Choice Parameter插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运行jenkins的一个job, 我们经常需要动态地指定这个job中的一些参数, 以达到我们想跑的东西, 比如,我们iOS自动化的job, 想在一个iPhoneX模拟器上跑, 我们指定这个模拟器的udid, 一个月后我们换了iPhone11模拟器,这个时候如果在jenkins job之前采用的是动态传udid的方式, 这个时候我们改下udid这个参数的值就可以了. 不用去改我们的自动化脚本, 当然, 这里我只是举一个例子, 我感觉这个功能用处还是很大的, 甚至可以选择跑哪些自动化的cases.
首先jenkins自带这个功能, 基本的需求应该都可以满足:
使用方法如下:
大家可以看到这里已经提供了很多类型的参数, 用起来也方便.这里顺便提一句, 如果使用python写的自动化代码, 可以调system的env, 可以很方便地在代码中获取各个参数的值, 当然, 要在jenkins中执行这段python代码, 这不是难事, 用了jenkins,自动化代码就是通过jenkins来执行.
我有个需求,就是可以在众多的候选参数中, 我可以选择0到n个, jenkins自带的, 我想了下, 只能每个值我设置一个boolean类型的参数, 用到这个值我就把置为true, 参数名就是值本身, 但这样很不方便, 而且我还需要把所有的我设置的这些值遍历一遍, 看哪些用到了, 哪些没用到.
我上面其实是想选择执行哪些自动化cases, 有时自动化cases太多(其实不应该很多).
所以后来我在网上找到了一个jenkins插件:Extended Choice Parameter, 装上后, 这样可以达到我的需求:
最终效果:
但这里只能一直竖着排下去, 要是能横着排就好了, 要是哪位大佬能改进下, 最好了😁
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/857db73e66b238473411fadeca571521/" rel="bookmark">
			Python努力学习笔记（第十一课）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python小白学习 Python学习第十一课1. 迭代器实现语法 2. 面向对象3. 类4. 属性和方法5. self参数 Python学习第十一课 1. 迭代器 可迭代对象： 序列， 字典， 迭代器，生成器 iter迭代器： iter next 去一次就不能使用了会记住你上一次停留的位置 实现语法 list1 = [1, 2, 3, 4, 5] it = iter(list1) print(type(it)) 2. 面向对象 你在上海，老板让你去北京开会。
我出家门—上车—去车站—。。。。。。—到北京了—去开会我在北京开会 面向过程 面向过程指将我们的程序分解为一个一个步骤，通过对每个步骤的抽象来完成程序这种编写方式往往只适用于一个功能，如果要实现别的功能，往往复用性比较低这种编程方式符号人类的思维，编写起来比较容易
简单说就是把你要做的事按照步骤一步一步的用代码编写出来，就是面向过程（1） 面向对象 面向对象的编程语言，关注的是对象，而不注重过程，对于面向对象一切皆对象这种编码方式比较容易阅读，并且易于维护，容易复用。但是编写的过程中不太符合常规的思维，编写相对麻烦
这个的解释就不是太好说了，我的理解是这样的：网络游戏里的技能就是一个对象，比如冲锋技能，目的就是将人物快速从一个地方带到另一个地方，并且有明确的轨迹，（没轨迹的是瞬移🤣，我只是举例子，不要抬杠哈），游戏里无论谁获取到了冲锋技能，显示出来的效果都是这样的所以也可以说面向对象就是只看目的，只看结果，不看实现目的的过程（2） 3. 类 类的创建 class MyClass():pass大驼峰的命名规则 实例的创建
mc = MyClass()
mc就是实例 4. 属性和方法 属性：定义在类中的数据方法： 定义在类中的函数 方法中，必须传递一个参数 对于定义在类中的属性和方法，所有的实例对象都是可以调用的
可以参考下这个链接 https://blog.csdn.net/weixin_43871760/article/details/88092656
5. self参数 self参数
&lt;1&gt;. self参数如果要在方法中使用，必须携带self参数
&lt;2&gt;. self参数就是指的调用改方法的实例本身
这次的学习大多都是概念性的东西，老师讲的过程中也是穿插的一些实际的例子来说明的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d4ed8346c2d1e7671979cc9cab0a8d2/" rel="bookmark">
			【微信小程序】自己的小程序跳转到京东小程序商品详情页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、获取京东小程序APPID 二、获取小程序路径 1、随便进入一个小程序的开发后台 2、点击生成小程序码，然后输入小程序的appid选择小程序，点击下一步 3、然后点击获取更多页面路径，在弹出的输入框中输入你的微信号，点击开启。然后在你的微信中打开小程序 三、打开京东小程序商品详情 wx.navigateToMiniProgram({ appId: 'wx91d27dbf599dff74', path: '/pages/item/detail/detail?sku=100007810999', envVersion: 'release', success(res) { // 打开成功 console.log(res); } }) 注意：直接复制页面的连接是pages/item/detail/detail.html?__pid=Pxc96ewqwm5mb，是个临时的地址；另外一个办法：把页面分享给好友，打开再复制就是真正的地址了：pages/item/detail/detail.html?sku=100007810999&amp;【代码path中要把.html去掉】
wx.navigateToMiniProgram 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/213332241d4f0045ead012855346b01f/" rel="bookmark">
			StringBuilder/StringBuffer可变长原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 概述2. StringBuilder 的构造方法3. AbstractStringBuilder 构造方法4. 扩容机制5. 总结 1. 概述 StringBuffer 与 StringBuilder 都是可变字符序列（字符串）。不同的是 StringBuilder 非线程安全，StringBuffer 线程安全。查看源码可以发现，StringBuffer 除构造外的其他方法都直接或间接（重载）用 synchronized 修饰。这里主要讨论可变长，也就是扩容原理，以 StringBuilder 为例，StringBuffer 与之一致。 2. StringBuilder 的构造方法 // 类定义 public final class StringBuilder extends AbstractStringBuilder implements java.io.Serializable, CharSequence { // StringBuilder 的构造 public StringBuilder() { super(16); } public StringBuilder(int capacity) { super(capacity); } public StringBuilder(String str) { super(str.length() + 16); append(str); } public StringBuilder(CharSequence seq) { this(seq.length() + 16); append(seq); } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/213332241d4f0045ead012855346b01f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2ad5c95aafaccbe874d6a289ef6577f/" rel="bookmark">
			基于SPSS的正态性检验方法汇总——以个股收益率为例（超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于SPSS的正态性检验方法汇总——以个股收益率为例（超详细） 数据的获取将Excel文件导入到SPSS中正态性检验方法图示法直方图P-P图Q-Q图 计算法偏度和峰度Shapiro - Wilk检验和Kolmogorov - Smirnov检验 结论 网上的很多教程讲的比较概括，零基础的小白用起来可能比较困难，本文整理了较详细的使用方法，希望对大家有所帮助。
数据的获取 个股的收益率可从锐思数据库（RESSET）中获取，大多数高校的图书馆已购买。
从图书馆数据库中选择RESSET金融研究数据库。
选择日期和股票代码。
选择需要导出的数据。
然后就可以下载，类型是Excel文件。
将Excel文件导入到SPSS中 以22.0版本为例。
文件—打开—数据，即可选择刚刚从RESSET数据库下好的文件。
确定即可导入数据。
SPSS有两个窗口，一个是数据编辑器，一个是查看器。数据编辑器是原始数据，查看器可以获取数据的信息。
数据编辑器有两个视图，一个是数据视图，一个是变量视图。数据视图和Excel类似，变量视图是各个变量的类型。
数据视图
变量视图
查看器
正态性检验方法 图示法 直方图 直方图可以比较直观观察到数据的正态性，但是不够精确。
分析—描述统计—频率
选择日收益率，图标类型为直方图
查看器中即可获得直方图。
与SPSS生成的随机正态分布直方图对比。
P-P图 P-P图是根据变量的累积概率对应于所指定的理论分布累积概率绘制的散点图，用于直观地检测样本数据是否符合某一概率分布。如果被检验的数据符合所指定的分布，则代表样本数据的点应当基本在代表理论分布的对角线上。
分析—描述统计—P-P图
选择日收益率。
查看器中可获得日收益率的P-P图。
与随机正态分布的P-P图对比。
Q-Q图 Q-Q图的结果与P-P图非常相似，只是P-P图是用分布的累计比，而Q-Q图用的是分布的分位数来做检验。和P-P图一样，如果数据为正态分布，则在Q-Q正态分布图中，数据点应基本在图中对角线上。
分析—描述统计—Q-Q图
选择日收益率。
查看器中可获得日收益率的Q-Q图。
与随机正态分布的Q-Q图对比。
计算法 偏度和峰度 偏度（skewness），是统计数据分布偏斜方向和程度的度量，是统计数据分布非对称程度的数字特征。偏度(Skewness)亦称偏态、偏态系数。表征概率分布密度曲线相对于平均值不对称程度的特征数。直观看来就是密度函数曲线尾部的相对长度。
公式中，Sk——偏度；μ3——3阶中心矩；σ——标准差。
偏度大于零，等于零，小于零的情况。
峰度（peakedness;kurtosis）又称峰态系数。表征概率密度分布曲线在平均值处峰值高低的特征数。直观看来，峰度反映了峰部的尖度。样本的峰度是和正态分布相比较而言统计量，如果峰度大于3，峰的形状比较尖，比正态分布峰要陡峭。反之亦然。
不同峰度的对比图
在更通常的情况下，峰度被定义为四阶累积量除以二阶累积量的平方，它等于四阶中心矩除以概率分布方差的平方再减去3，这也被称为超值峰度（excess kurtosis）。“减3”是为了让正态分布的峰度为0。
公式中，γ2——超值峰度；μ4——4阶中心矩；σ——标准差。
分析—描述统计—描述
选择日收益率，并在选项中选择峰度和偏度。
日收益率的偏度为-3.142，峰度为92.058。
与随机正态分布对比，其偏度为0.013，峰度为-0.048。
Shapiro - Wilk检验和Kolmogorov - Smirnov检验 Shapiro—Wilk检验法是S.S.Shapiro与M.B.Wilk提出用顺序统计量W来检验分布的正态性,对研究的对象总体,先提出假设认为总体服从正态分布,再将样本量为n的样本按大小顺序排列编秩,然后由确定的显著性水平α,以及根据样本量为n时所对应的系数αi,根据特定公式计算出检验统计量W。最后查特定的正态性W检验临界值表,比较它们的大小,满足条件则接受假设,认为总体服从正态分布,否则拒绝假设,认为总体不服从正态分布。
Kolmogorov-Smirnov检验（K-S检验）基于累积分布函数，用以检验一个经验分布是否符合某种理论分布或比较两个经验分布是否有显著性差异。
若检验的显著性大于0.05，则说明有95%的把握说明该分布符合正态分布。通常，Kolmogorov-Smirnov检验适用于大样本（五千以上），Shapiro—Wilk检验适用于小样本。
分析—描述统计—探索
选择日收益率，并在绘图中选择带检验的正态图。
股票日收益率的Shapiro - Wilk和Kolmogorov - Smirnov的显著性均为零，不符合正态分布。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2ad5c95aafaccbe874d6a289ef6577f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/968a7ba3236eedd7eff1c5846ed7516e/" rel="bookmark">
			iptables和ipvs
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、service和iptables的关系 service 的代理是 kube-proxy
kube-proxy 运行在所有节点上，它监听 apiserver 中 service 和 endpoint 的变化情况，创建路由规则以提供服务 IP 和负载均衡功能。简单理解此进程是Service的透明代理兼负载均衡器，其核心功能是将到某个Service的访问请求转发到后端的多个Pod实例上，而kube-proxy底层又是通过iptables和ipvs实现的。
iptables原理 Kubernetes从1.2版本开始，将iptables作为kube-proxy的默认模式。iptables模式下的kube-proxy不再起到Proxy的作用，其核心功能：通过API Server的Watch接口实时跟踪Service与Endpoint的变更信息，并更新对应的iptables规则，Client的请求流量则通过iptables的NAT机制“直接路由”到目标Pod。
ipvs原理 IPVS在Kubernetes1.11中升级为GA稳定版。IPVS则专门用于高性能负载均衡，并使用更高效的数据结构(Hash表)，允许几乎无限的规模扩张，因此被kube-proxy采纳为最新模式。
在IPVS模式下，使用iptables的扩展ipset，而不是直接调用iptables来生成规则链。iptables规则链是一个线性的数据结构，ipset则引入了带索引的数据结构，因此当规则很多时，也可以很高效地查找和匹配。
可以将ipset简单理解为一个IP(段)的集合，这个集合的内容可以是IP地址、IP网段、端口等，iptables可以直接添加规则对这个“可变的集合”进行操作，这样做的好处在于可以大大减少iptables规则的数量，从而减少性能损耗。
kube-proxy ipvs和iptables的异同 iptables与IPVS都是基于Netfilter实现的，但因为定位不同，二者有着本质的差别：iptables是为防火墙而设计的；IPVS则专门用于高性能负载均衡，并使用更高效的数据结构(Hash表)，允许几乎无限的规模扩张。
与iptables相比，IPVS拥有以下明显优势：
为大型集群提供了更好的可扩展性和性能；
支持比iptables更复杂的复制均衡算法(最小负载、最少连接、加权等)；
支持服务器健康检查和连接重试等功能；
可以动态修改ipset的集合，即使iptables的规则正在使用这个集合。
二、k8s集群中分析service和kube-proxy 访问Service的请求，不论是Cluster IP+TargetPort的方式；还是用Node节点IP+NodePort的方式，都被Node节点的Iptables规则重定向到Kube-proxy监听Service服务代理端口。kube-proxy接收到Service的访问请求后，根据负载策略，转发到后端的Pod。
# kubectl logs kube-proxy-5clwf -n kube-system (查看某一个节点的kube-proxy日志)
W1014 13:25:02.120810 1 server_others.go:559] Unknown proxy mode "", assuming iptables proxy I1014 13:25:02.137813 1 node.go:136] Successfully retrieved node IP: 192.168.40.133 I1014 13:25:02.137952 1 server_others.go:186] Using iptables Proxier. I1014 13:25:02.138750 1 server.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/968a7ba3236eedd7eff1c5846ed7516e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a43eecd1810b22a610db28b122dbe489/" rel="bookmark">
			java Thread.yield()用法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		yield() yield
v.出产(作物);产生(收益、效益等);提供;屈服;让步;放弃;缴出
n.产量;产出;利润
Thread.yield()
让当前处于运行状态下的线程转入就绪状态；
运行状态下的线程 调用Thread.yield()进入就绪状态后，和其它就绪状态线程处于同一起跑线，也有可能被立即再次被调用；
yield()底层是native方法
public static native void yield(); 注意：yield()不是阻塞线程；
public class YiledTest implements Runnable { public static void main(String[] args) { MyThreadTest mt = new MyThreadTest(); new Thread(mt,"1").start(); new Thread(mt,"2").start(); new Thread(mt,"3").start(); } } class MyThreadTest implements Runnable { @Override public void run() { System.out.println(Thread.currentThread().getName()+"start ..."); Thread.yield(); System.out.println(Thread.currentThread().getName()+"over ..."); } } 输出
1 start ... 2 start ... 1 over ... 3 start .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a43eecd1810b22a610db28b122dbe489/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b436f3d07784cd34ff1a47af744873dc/" rel="bookmark">
			tp5.1apache伪静态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： 百度了好久,tp5.1伪静态实现不了,后面看了一天文章一下子就实现了
解决方案： 在.htacss中添加如下代码即可
&lt;IfModule mod_rewrite.c&gt; RewriteEngine on RewriteCond %{REQUEST_FILENAME} !-d RewriteCond %{REQUEST_FILENAME} !-f RewriteRule ^(.*)$ index.php [L,E=PATH_INFO:$1] &lt;/IfModule&gt; 还有nginx中的话要不那个路径放到tp5.1的public目录下,然后修改一下配置文件就好(百度一下)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cff9ff62cfa25592d8d189a76badea86/" rel="bookmark">
			限定通配符和非限定通配符_什么是通配符？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		限定通配符和非限定通配符
The wildcard character generally acts like an asterisk character. The wildcard is generally used in programming, scripting, IT in order to express special meanings for different cases. 通配符通常充当星号字符。 通配符通常用于编程，脚本编制和IT中，以表达不同情况的特殊含义。
通配符或通配符或通配符 (Wild Character or Wildcard Character or Wildcard) Well, the character is actually not important but the function is more important for the wildcard. So different sayings are not a problem and used for the Wild Character or Wildcard Character or Wildcard.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cff9ff62cfa25592d8d189a76badea86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8350f63abbc9753d7c2a7be57dc04f52/" rel="bookmark">
			Kubernetes --kubectl命令管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、kubectl --help帮助文档介绍二、完整项目周期实例 一、kubectl --help帮助文档介绍 [root@master01 dashboard]# kubectl --help Basic Commands (Beginner): create Create a resource from a file or from stdin.根据文件或者输入流创建资源 expose 使用 replication controller, service, deployment 或者 pod并暴露它作为一个新的 Kubernetes Service run 在集群中运行一个指定的镜像 set 为 objects 设置一个指定的特征 Basic Commands (Intermediate): explain 查看资源的文档 get 显示一个或更多 resources edit 在服务器上编辑一个资源 delete Delete resources by filenames, stdin, resources and names, or by resources and label selector Deploy Commands: rollout Manage the rollout of a resource；回滚，如果更新出问题了可以立马回滚 scale 为 Deployment, ReplicaSet, Replication Controller 或者 Job 设置一个新的副本数量； 弹性伸缩，特别是无状态的web服务 autoscale 自动调整一个 Deployment, ReplicaSet, 或者ReplicationController的副本数量；自动弹性伸缩 Cluster Management Commands: certificate 修改 certificate 资源.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8350f63abbc9753d7c2a7be57dc04f52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88b8d6605fd9411204088062fc1a3075/" rel="bookmark">
			c&#43;&#43;编译中出现‘vtable for ***未定义的引用解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、对‘vtable for Brass’未定义的引用
class Brass:public AcctABC { public: Brass(const std::string &amp; s="Nullbody",long an=-1, double bal=0.0):AcctABC(s,an,bal){} virtual void Withdraw(double amt); virtual void ViewAcct()const; virtual ~Brass(){} }; 出现错误/tmp/ccytx9fA.o：在函数‘Brass::Brass(std::string const&amp;, long, double)’中：
usebrass3.cpp:(.text._ZN5BrassC2ERKSsld[_ZN5BrassC5ERKSsld]+0x37)：对‘vtable for Brass’未定义的引用
collect2: error: ld returned 1 exit status
一般是以下的原因：
存在虚函数没有被实现！
父类的虚函数没有被实现！
关键字‘vtable for（虚函数）
解决办法查找相关虚函数时候已经写好功能函数（已经override）。
2、对vtable for ×××未定义的引用 ~其他分析~
class Socket { public: Socket(std::string addr, int port, std::string out_path); virtual ~Socket(); virtual int sendl(std::string content); virtual int recvl(); // 属性 protected: .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88b8d6605fd9411204088062fc1a3075/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5844416b927d59fbfeac48b956342232/" rel="bookmark">
			Python列表或元组的数字元素求和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 第6章-3 列表或元组的数字元素求和 (20分)
求列表中数字和,列表中嵌套层次不限2层
输入格式:
在一行中输入列表或元组
输出格式:
在一行中输出数字的和
输入样例:
在这里给出一组输入。例如：
[11,2,[3,7],(68,-1),“123”,9]
输出样例:
在这里给出相应的输出。例如：
99
x = eval(input()) def Sum(x): sums = 0 for ch in x: if isinstance(ch, int): sums += ch if isinstance(ch, list): sums += Sum(ch)#列表中嵌套层次不限2层,要用递归 if isinstance(ch, tuple): sums += Sum(ch)#列表中嵌套层次不限2层,要用递归 return sums ''' 列表或元组的数字元素求和,求列表中数字和,列表中嵌套层次不限2层 注意：1.列表中的字符串不用参与计算 2.列表中嵌套层次不限2层,要用递归 ''' print(Sum(x)) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55caeca492276e98f0b4ffc5bb9b43a4/" rel="bookmark">
			Vuex---数据持久化的多种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vuex无论你喜不喜欢或者想不想，但凡涉及到了Vue项目多数时候你都会需要。但万物都有弊端，页面刷新后状态，数据丢失一直很头大。
而这个问题我们也常常在面试中被问到，传统的解决方案是Vuex+sessionStorage等存储方案解决
好吧 不墨迹直接上封装好的干货，喜欢那个选那个。直接在Vuex中调用即可
var Storage = { // ==================sessionStorage设置缓存================ // 设置缓存 sessionSet: function (name, data, expires) { sessionStorage.removeItem(name) sessionStorage.setItem(name, JSON.stringify(data)) if (expires &amp;&amp; expires instanceof Date) { sessionStorage.removeItem(`${name}__expires`) sessionStorage.setItem(`${name}__expires`, new Date(expires).getTime()) } }, // 获取缓存 sessionGet: function (name) { if (sessionStorage.getItem(`${name}__expires`)) { const now = Date.now() const expires = sessionStorage.getItem(`${name}__expires`) if (now &gt;= expires) { sessionStorage.removeItem(name) sessionStorage.removeItem(`${name}__expires`) return undefined } else { return JSON.parse(sessionStorage.getItem(name)) } } else { return JSON.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55caeca492276e98f0b4ffc5bb9b43a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dc21a5466fffae82935925aaee08b6d/" rel="bookmark">
			实现了EMCCD和CMV4000摄像头的图像处理板卡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、基于zcu102采用的7eg的芯片设计了图像处理板卡原理图设计；
2、PCB板卡回来进行调试，完成PL和PS端的程序验证；
3、实现了完整的图像处理流程；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/438d19ac18cc954302ee2661dc5c119d/" rel="bookmark">
			NVDLA-Small在ZCU102上实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在王维大佬的博客指导下，以及他本人耐心的指点，终于把nvdla-small的运行在zcu102开发板上了。实现参考链接如下：https://vvviy.github.io/2018/09/12/nv_small-FPGA-Mapping-Workflow-I/
欢迎大家交流nvdla。qq:793625982
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47d87bd6d9a52cecd336d3c552a8f0d0/" rel="bookmark">
			使用Logstash-input-jdbc同步mysql中的数据到es中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备好es kibana logstash 保证同一版本并可以正常启动logstash 5.x.x版本以上可以直接使用logstash-input-jdbc插件, 不用安装ruby等环境同步方式可选全量或增量方式, 全量方式每次全部同步, 不太妥当, 我们选择使用增量方式, 增量方式第一次启动时也可以进行全部同步, 后面会说具体配置 Logstash目录结构如下所示, 我们创建一个文件夹mysql用来存放mysql同步所需要的配置等文件
logstash使用jdbc也需要引入jdbc的jar包, jar包下载地址
链接：https://pan.baidu.com/s/1qNkuH2T-Ba-bM1wTNvKydQ
提取码：8a4h
把jar包放入上面创建的mysql文件夹中
在mysql文件夹中创建mysql.conf文件, 这个文件就是logstash启动时运行的配置文件, 所有的参数信息需要放在这里面, 复制时把#后面的注释删除
input { jdbc { #数据库连接参数 jdbc_connection_string =&gt; "jdbc:mysql://127.0.0.1:3306/bd_mgmt" # mysql用户名 jdbc_user =&gt; "root" # mysql密码 jdbc_password =&gt; "root" # 刚才放入文件夹的jar包 jdbc_driver_library =&gt; "/opt/soft/logstash-7.9.1/mysql/mysql-connector-java-5.1.49.jar" # 驱动类名 jdbc_driver_class =&gt; "com.mysql.jdbc.Driver" # 开启分页 jdbc_paging_enabled =&gt; "true" # 最大页码 jdbc_page_size =&gt; "50000" # 用于同步的查询sql statement_filepath =&gt; "/opt/soft/logstash-7.9.1/mysql/bdmgmt_baseflight.sql" #如果要使用其它字段追踪，而不是用时间开启这个配置 use_column_value =&gt; true #设置要追踪的字段 tracking_column =&gt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47d87bd6d9a52cecd336d3c552a8f0d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d657c9136cb6babfb0217e872da08393/" rel="bookmark">
			jQuery 动态粒子效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset="utf-8"&gt;
&lt;style&gt;
html,body {
width: 100%;
height: 100%;
margin: 0;
padding: 0;
overflow: hidden;
}
.container{
width: 100％;
height: 100%;
margin: 0;
padding: 0;
background-color: #000000;
}
&lt;/style&gt;
&lt;script src="https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id="jsi-particle-container" class="container"&gt;&lt;/div&gt;
&lt;script&gt;
var RENDERER = {
PARTICLE_COUNT : 1000,
PARTICLE_RADIUS : 1,
MAX_ROTATION_ANGLE : Math.PI / 60,
TRANSLATION_COUNT : 500,
init : function(strategy){
this.setParameters(strategy);
this.createParticles();
this.setupFigure();
this.reconstructMethod();
this.bindEvent();
this.drawFigure();
},
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d657c9136cb6babfb0217e872da08393/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21bc37e63f0ceb3d5dab0c8212d2047b/" rel="bookmark">
			css,布局时父组件固定高度，子组件无法滑动问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		css,布局时父组件固定高度，，但子组件无法滑动，并且子组件变形缩放，在审查代码以后发现是其父组件的display赋予了 flex,因为其flex的特性，导致自子组件会适应父组件大小，导致变形缩放无法滑动的问题，将其删除即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7125920e740c70b0881642838f8de3c/" rel="bookmark">
			苹果iPhone手机提示iCloud储存空间将满，该如何清理？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ICloud储存空间满了，一般肯定的照片占的最多。这个无解，只能是把所有的照片导出来，放到电脑或者是云盘上。然后再删除iCloud储存空间即可
众所周知，iCloud免费储存空间只有5G，这是远远不够的，如果想要更大的储存空间，就只能是购买了。而相信很多人是不愿意购买这个储存空间的（比如我）。一般的习惯是直接关闭照片自动储存到icould，而其他的比如通讯录以及备忘录等都会打开。而这，其实对于5G的储存空间远远够了。而照片呢，我会专门放到网盘里（自己用的百度云盘），偶尔闲了，比如说是一个月，打开网盘后会自动上传。这样的话我们的照片就再也不会丢了。
而如果是一直用的是iPhone，且有打算一直把iPhone用下去。其实也可以充值一下。而很多的商务人士因为工作需要，经常要在手机里面存储一些必要的照片，而且需要随时调用的，那么建议直接充值。毕竟APPLE的产品共用一个iCloud，是可以在任何一个设备上直接打开相册去看的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63e1389d435a227b03534888ba3dba6f/" rel="bookmark">
			echarts缩放
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		echarts图表 加上dataZoom可实现缩放
dataZoom: [//加上dataZoom可实现缩放 { type: 'slider',//x轴 xAxisIndex: 0, }, { type: 'inside',//x轴 xAxisIndex: 0, zoomOnMouseWheel:'alt',//如何触发缩放。可选值为：true：表示不按任何功能键，鼠标滚轮能触发缩放。false：表示鼠标滚轮不能触发缩放。'shift'：表示按住 shift 和鼠标滚轮能触发缩放。'ctrl'：表示按住 ctrl 和鼠标滚轮能触发缩放。'alt'：表示按住 alt 和鼠标滚轮能触发缩放。 }, // { // type: 'slider',//y轴 // yAxisIndex: 0, // }, // { // type: 'inside',//y轴 // yAxisIndex: 0, // } ], 完整代码
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;echart&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 为 ECharts 准备一个具备大小（宽高）的 DOM --&gt; &lt;div id="main" style="width: 600px;height:400px;"&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; &lt;script src="https://cdn.bootcss.com/echarts/4.2.1-rc1/echarts.min.js"&gt;&lt;/script&gt; &lt;script&gt; // 基于准备好的dom，初始化echarts实例 var myChart = echarts.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63e1389d435a227b03534888ba3dba6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d16ce765cb473f575ed993bcc10dde54/" rel="bookmark">
			PL/SQL 导入SQL文件时报“Error reading file”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从另一台机器上导出了一个表的数据，有2万多条，导出的sql文件大小将近40M。之后使用PL/SQL的Command Window窗口执行sql文件，执行命令是：@ SQL文件全路径，提示错误：Error reading file不知道是不是因为文件太大导致的。
尝试另一种方法，用SqlPlus命令执行SQL文件。
这里不用cmd窗口执行sqlplus命令，而是使用PL/SQL工具里的Import Tables来实现sqlplus导入sql文件的功能
打开Import Tables，切换到SQL Inserts栏下，选择要导入的SQL文件，之后点击Import按钮就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52a81413c9462d2df04fe4251e861fc2/" rel="bookmark">
			沧小海的《xilinx的A7系列芯片资源学习笔记》之第一部分：I/O BANK(三)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
2.3 OSERDESE2与ISERDESE2
2.2.1 ISERDESE2
2.2.2 OSERDESE2
2.2.3 IO_FIFO
2.4 其他
2.3 OSERDESE2与ISERDESE2 如下图所示，每组引脚都有两个OSERDESE2和ISERDESE2。可以实现串行与并行之间的转换，每个SERDES都支持串行与8bit并行之间的转换。并可以通过Bitslip实现数据的重新对齐。
2.2.1 ISERDESE2 ISERDESE2主要是串行输入，可根据对ISERDESE2的模式配置，实现不同模式。如下图是ISERDESE2的例化，可以在vivado的原语里面搜索到该模块。
首先先看下参数的配置，具体解释如下表
第一部分：模块参数
参数部分的设置或是调用原语的设置或是使用相应IP核的配置。
1、DATA_RATE
是用于对串行数据采样时的采样模式设置，有SDR和DDR两种模式设置，SDR（single data rate）是单沿采样，DDR（double data rate）是双沿采样，该模块默认为DDR模式。
2、DATA_WIDTH
是设置串并转换的位宽，每一个“ISERDESE2”可以实现8bit位宽的输出，但通过不同的模式设置就有了多种位宽输出格式，具体如下表所示。其中“NETWORKING”类型的DDR模式可支持最大14bit位宽，这时就需要将两个“ISERDESE2”采用主从模式进行串联实现。具体方式会放在下文阐述。
3、DYN_CLKDIV_INV_EN和DYN_CLK_INV_EN
如下图所示，在“ISERDESE2”接口有“DYNCLKDIVSEL”和“DYNCLKSEL”两个信号分别控制“CLKDIV”和“CLK”是否进行取反操作。而“DYN_CLKDIV_INV_EN”和“DYN_CLK_INV_EN”就是“DYNCLKDIVSEL”和“DYNCLKSEL”这两个选择信号的的使能信号，只有在“DYN_CLKDIV_INV_EN”和“DYN_CLK_INV_EN”为“TURE”的情况下，才能进行选择，默认是“FALSE”。而这种操作只支持“MEMORY_QDR”和“MEMORY_DDR3”模式，一般用不到。
4、INTERFACE_TYPE
这是模式设置，“ISERDESE2”支持内存模式、网络模式以及过采样模式。内存模式即MEMORY模式、MEMORY_DDR3模式和MEMORY_QDR模式。例如我们用“mig_7series_0”核就是MEMORY_DDR3模式，另外还支持 OVERSAMPLE和 NETWORKING模式。NETWORKING模式就是实现串并转换，OVERSAMPLE是同频多相位采样模式，可实现与数据同频的时钟对数据采样。当然，这还需要其它逻辑的配合，这个在《xapp523》中有详细的介绍。
5、NUM_CE
它的值可以是1也可以是2，表示的是接口信号(CE1 and CE2)的使能个数。默认是2，具体CE1和CE2在接口信号相关部分阐述。
6、OFB_USED
这和“OLOGICE2/3”有关。
7、SERDES_MODE
主从模式设置，SERDES_MODE属性定义使用宽度扩展时ISERDESE2模块是主模块还是从模块，用于扩展连接，例如14bit位宽的使用。
8、INIT_Q1~Q4
设置第一个采样寄存器的初始值，在OVERSAMPLE模式时用于初始化采样值。
9、SRVAL_Q1~Q4
设置第二个采样寄存器复位后的值，默认即可。
10、IOBDELAY
D和DDLY引脚是ISERDESE2的专用输入。D输入是与IOB的直接连接。DDLY引脚是与IDELAYE2的直接连接。这使用户可以拥有已注册（Q1-Q8）或组合路径（O）输出的延迟或非延迟版本的输入。IOBDELAY属性确定应用于ISERDESE2的输入。表3-4显示了同时连接D和DDLY时IOBDELAY值的每种设置的结果。最后注释了依据当D和DDLY都接入ISERDESE2时的选择，那么是不是如果只接一个可以自动识别？
第二部分：接口信号
如下图所示，是ISERDESE2模块的接口信号，接下来就对此进行逐个分析。
1、Q1 – Q8
ISERDESE2模块转并后的输出端口，可实现最多8bit的输出，如果使用DDR模式，可扩展为两个ISERDESE2模块，实现10、14bit的输出。输出位宽是根据参数进行配置。
2、O
是D或者DDLY输入的直接输出
3、FTOUT1、SHIFTOUT2和SHIFTIN1、SHIFTIN2
是用于ISERDESE2模块的扩展功能的。
4、D
IOB的输入信号，当然也可以不是来自IOB
5、DDLY
也是串行输入信号，但是从IDELAYE2模块来的。
6、CLK
用于串行数据的时钟输入
7、CLKB
用于QDR模式的。咱们用不到，当使用MIG核时会用到。
8、CLKDIV
并行数据的输入时钟，例如8-1模式，SDR模式，并行时钟100MHz，串行时钟12.5Mhz。
9、CLKDIVP
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52a81413c9462d2df04fe4251e861fc2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e8d3faf621ae9ffb13d430be93f9ff9/" rel="bookmark">
			NXP ZigBee JN5169开发流程总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经过一个多月的摸索，现总结JN516x的开发流程如下：
安装IDE和SDK。源代码的编写：这里又包括图形界面的配置，和源文件中的纯代码的编写编译：可能要动手自己修改Makefile。烧写：又分为UART模式烧写和JTAG模式烧写。运行看功能，可能需要抓包。 接着简单展开描述一下：
安装IDE和SDK的资料网上有很多，我也是参考其他大佬的说明。
其他几步好像写的人很少，我就重点补充下后面几点。
编写代码涉及两块内容，NXP将很多底层的配置抽象成了图形界面，只要拖拖拽拽，在后面的编译中就会自动生成代码。比如新加一个task。还有一块内容是具体的源文件中手写代码，图形界面中添加task相当于只是一个声明，需要在源文件中自己手写代码来描述这个task具体执行的任务。
编译也有两种方式：第一种是直接使用IDE中按钮，第二种是通过命令行编译，需要进入MSYS Shell执行。
烧写的两种方式，一种是UART模式，只要进入UART烧写模式，串口线硬件也连接正确，就可以在PC上通过IDE烧写或者烧写工具烧写。这两种方式都有专门的guide可以参考，只是IDE是图形界面的，烧写工具是命令行的。
这里说一个遇到的大坑，用win10系统时，碰巧碰到一个u转串的小板，不能使用默认的100万波特率，死活烧不进去，折腾了一个小时，这时其实只要降低波特率就可以烧写成功了。
用JTAG烧写的话，需要注意烧入的镜像必须是hardware debug模式的镜像，并且需要用专用的jtag工具。
运行调试的话，可以直接看功能，也可以用jtag跟踪。
还有就可能需要抓包：抓包就需要硬件，nxp有usb dongle，需要烧入专门的sniffer bin，而且还需要运行特定的软件Ubiqua Protocol Analyzer
以上，就是最近一个多月的摸爬滚打，有错误或者纰漏之处欢迎留言指正，谢谢！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa069e55f2d5ccac100719b6ab72dcdc/" rel="bookmark">
			当前服务不加入到eureka注册中心
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		eureka.client.register-with-eureka: false
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fe70f44d49cf3ee6bc5b8c8c2ca464d/" rel="bookmark">
			雷达的主要技术参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.工作频率以及工作带宽 雷达的工作频率主要根据目标的特性、电波传播条件、天线尺寸、高频器件的性能、雷达的测量精确度和功能等要求来决定。工作带宽主要根据抗干扰的要求来决定。一般要求工作带宽为5%~10%，超带宽雷达为25%以上（相对发射波形的中心频率）
2.发射功率 发射功率的大小影响作用功率，功率大则作用距离远。发射功率分脉冲功率和平均功率。雷达在发射脉冲信号期间所输出的功率称为脉冲功率，平均功率是指一个周期内发射机输出功率的频率。发射机的输出功率直接影响雷达的威力和抗干扰能力。高频大功率的产生受到器件、电源容量和效率等因素的限制。一般远程警戒雷达的脉冲功率为几百千瓦至兆瓦量级，中、近火控雷达为几千瓦至几百千瓦量级。
3.调制波形、脉冲宽度和重复频率 早期雷达发射信号采用单一的脉冲波形幅度调制，现代雷达采用多种调制波形以供选择。
脉冲宽度指发射脉冲信号的持续时间，用τ表示。一般在0.05~20us，它不仅影响雷达的探测能力，还影响距离分辨率。早期雷达的脉冲宽度是不变的，现代雷达采用多种脉宽的信号以供选择。当采用脉冲压缩技术时，发射脉冲时宽可达数百微秒，相应地用脉冲压缩方式增大信号的带宽。
脉冲重复频率是指雷达每秒钟发射的射频脉冲的个数用Fr表示。脉冲重复频率的倒数称为脉冲重复周期，它等于相邻两个发射脉冲前沿的间隔时间，用Tr表示。雷达的脉冲重复频率一般在50~2000Hz(相应的Tr为20000—500us)。它们既决定了雷达单值测距范围，又影响不模糊测速区域大小。为了满足测距测速的性能的要求，现代雷达常采用多种重复频率或参差重复频率。
4.天线的波束形状、增益和扫描方式 天线波束形状一般用水平和垂直面内的波束宽度来表示(3dB表示)。
米波雷达的波束宽度在10度量级，而厘米波雷达的波束宽度在几度左右。常见的波束形状有扇形、针状和余割平方形。
天线的增益近似表示式为：
其中,A为天线的有效截面积。天线的增益越大，则雷达作用距离越远。
搜索个跟踪目标时，天线的主瓣在雷达的探测空域内以一定的规律运动，称为扫描。它可以分为机械扫描和点扫描两大类。
利用整个天线系统或者其某一部分的机械运动来实现波束扫描的称为机械性扫描。
电扫描时，天线反射体、馈源等不必做机械运动。
5.接收机的灵敏度 接收机的灵敏度是指雷达接收微弱信号的能力。它用接收机在噪声电平一定时所能感知的输入功率的大小来表示，通常规定在保证50%~90%发现概率条件下，接收机输入端回波信号的最小功率作为接收机的最小可检测信号Prmin。这个功率越小，接收机的灵敏度越高，雷达的作用距离就越远。
6.终端装置和雷达输出数据的形式 最常用的终端装置时候是显示器。根据雷达的任务和性质不同，所采用的显示器的形式也不同。
7.电源供应 功率大的雷达，电源供应是个重要问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/328c248186f5d5cf5cabb0744141c23e/" rel="bookmark">
			Laravel7.15.0学习中遇到的坑—框架目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 最近在学习 laravel 框架，学习的版本是 7.15.0 ，记录一下学习过程中遇到的问题和难点以及一些总结。
框架中的目录结构： ｜——　app 包含 Controller、Model、路由等在内的应用目录，大部分业务将在该目录下进行
｜　｜————　Console 命令行程序目录
｜　｜　｜——————　Commands 包含了用于命令行执行的类，可在该目录下自定义类
｜　｜　｜——————　Kernel.php 命令调用内核文件，包含 commands 变量(命令清单，自定义的命令需加入到这里)和 schedule 方法(用于任务调度，即定时任务)
｜　｜————　Events 事件目录
｜　｜————　Exceptions 包含了自定义错误和异常处理类
｜　｜————　Http HTTP 传输层相关的类目录
｜　｜　｜——————　Controllers 控制器目录
｜　｜　｜——————　Middleware 中间件目录
｜　｜　｜——————　Requests 请求类目录
｜　｜　｜——————　Kernel.php 包含 http 中间件和路由中间件的内核文件
｜　｜　｜——————　routes.php 强大的路由
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/328c248186f5d5cf5cabb0744141c23e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/430cd3fe2f1369e34eb0660e0b5e09ff/" rel="bookmark">
			一条坎坷的保研路：北理、天大、南开、厦大、川大、支保
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一条坎坷的保研路：北理，天大，南开，厦大，支保 写在前面的话我的曲折保研路 夏令营阶段厦门大学天津大学电子科技大学南京大学 预推免电子科技大学计算机学院软件学院 四川大学南开大学北京理工大学（最终去向） 选导师支教保研终章 写在前面的话 这是第一次写博客，我是个学艺不精的程序员，实在不会分享什么高深的算法或者代码，这篇博客是为了记录自己保研的过程，日后自己看起来是一段难得的回忆，对其他保研的学弟学妹们也能有点点帮助。
介绍一下我自己的基本情况：
西南某不知名985软件工程互联网安全专业，专业成绩排名15/127，综合排名20/127（综合排名加了竞赛得奖的加分）四级550+，六级475+，每年都会获得奖学金，还得过院演讲比赛的一等奖，党员，女生，参加过数模国赛和美赛没有获奖，曾经去新加坡国立大学交流过一个月，在绿盟实习过四个月，做过DCGAN、微信小程序等项目都不太拿得出手。
如上，可以看到我的硬性条件在严酷的保研竞争中实在是不太拿的出手，索性我并没有对自己有很高的期待，由此引出我想说的我认为最重要的一点：
为什么想要读研
2020年四月开始到现在十月份，我自己完完整整的走过保研这条路后我觉得最大的感悟就是：在进行推免学校申请之前，一定先要搞清楚自己为什么想要读研。
大部分人继续读研都是对自己的专业感兴趣想要继续深造，提升自己。
我的曲折保研路 对于我自己来说，其实我对软件专业没有很大的兴趣，对于读研的热情不高。从小到大我自己的学习还是很努力的，高考考进985已经花了我很大的精力，在大学拿到保研资格我也花了很大功夫，个中艰辛只有自己知道，今年我20岁了，我真的有点学不动了也不想再继续努力了。我和我父母对我以后的规划是当一名公务员或者去高校做辅导员或者老师，我不能接受华为阿里等大厂加班的节奏，虽然钱多，但是我父母和我都希望我能过的开心轻松一点，所以我读研的目标就只有一个——顺利拿到研究生文凭。不知道有没有学弟学妹们跟我一个想法，可能有人觉得我太颓废太懒了，每个人都有自己的活法，顺从自己的想法就好。
由于我是北方人，受够了南方的大蟑螂，所以研究生坚定的想回北方，投的学校也以京津冀为主。
搞明白自己的意图之后，申请学校就有自己的策略了，对我来说我走的像是一条很佛系又坎坷的保研之路。
为什么说佛系呢，因为我没有很努力的去刷题准备机试，我只复习了计网、操作系统、数据库这些基础课，因为想着最差也有本校研究生上。跟我不同读研想法的学弟学妹们千万别效仿我，刷题准备机试还是相当重要的。
为什么说坎坷呢，因为自己成绩在保研的边缘，其实有很长一段我都非常焦虑，一边申请学校一边焦虑学校申请到了保研名额拿不到怎么办，这种焦虑的情绪非常痛苦，有时候走着走着路都能哭出来，直到九月，我意识到我不能再这样下去了，要准备后路了，我为自己准备的后路是——考公。建议同在保研边缘的人一定要尽早准备后路或考研或出国等等，日夜不停的焦虑非常不可取（还有想劝一劝同样焦虑的学弟学妹们，就算保不上研也没什么大不了的，这世界总会有属于你的位置，难道还会连饭都吃不上？不读研也没什么大不了的。）九月中旬，学校给了保研排名，由于没有竞赛获奖加分我的排名降到了20，往年我们学校保研率只有13%太少了真的想哭，所以我基本保研无望，这时学校发了支教保研的通知，我才发现还有支教保研这种方式 ，我会在后面详细介绍。九月底，我们学院发布了保研名额，今年我们学院突然站起来了！！保研率达到了16.5%，我意料之外的拿到了保研资格，但是，九月中旬在我觉得自己铁定拿不到保研资格的时候，就回绝了我在夏令营阶段的所有offer以及在预推免阶段的所有面试资格，全心全意准备支教保研的东西。所以在九月底我拿到保研资格时面临的困境是：没有任何offer并且绝大部分学校预推免报名截止。真的是欲哭无泪，拿到保研资格比没拿到还难过。于是我只有安慰自己保本校也不错，至少老师们人都很好，环境也熟悉。在这时，国家给了通知今年推免系统延迟开放了，所以很多学校预推免又能报名了，真峰回路又转，我又报名了几所学校预推免，并最终在十一长假的最后一天拿到了想要的offer。
写了这么多碎碎念，下面终于是正题了，我会以夏令营和预推免为划分，记录各个学校保研面试的经过。
夏令营阶段 夏令营阶段是我认为最重要的保研申请的阶段，一般3月就陆续开展持续到七月，大部分夏令营三天左右，会有笔试面试等，今年的夏令营都是线上开展面试，所以我投了不少学校。即使是线下的夏令营大部分学校也会负担往返费用以及在夏令营期间的食宿等，参加夏令营实在是笔划算的买卖。夏令营属于各个高校的抢人阶段，对我们推免生来说，夏令营阶段拿到保底offer，就像打了一剂定心针，我们就有勇气在预推免或九推冲击更好的学校。
夏令营的信息一般会在各个学校学院的官网发布，要经常去浏览，也可以关注保研这个公众号：
公众号会汇总各个学校的夏令营和预推免信息，但是对于自己非常想去的学校还是要每天去看官网，以免错过。
有些高校会要求有老师的推荐信，一定要提前老师写好。成绩单、成绩排名证明、证件照、获奖证书等也都要准备好，接下来就可以报名自己想去的大学的夏令营了。
下面是我入营并参加面试的夏令营（有不少面试因为时间冲突放弃了）：
厦门大学 厦门大学信息学院软件工程系，今年入营了不到100人，最后优秀营员给了30个左右。没有机试，只有面试。面试先是有2分钟左右英文自我介绍，随后是在：《专业英语》、《计算机网络》、《数据库》、《IT 新技术》、《软件工程导论》、《操作系统》六门中选择四门，其中《专业英语》为必答。《专业英语》给了一段关于Python语言的文章，翻译中文。《计算机网络》考核的是交换机的作用，《操作系统》问的是死锁，其余的记不清了，问题都比较基础，复习过专业课都能答上来。最后是老师就你的项目经历等提问。
面试的老师们都很nice，一开始我还比较紧张，后来老师还主动跟我聊起我母校的原名啊之类的，让我放松了不少。厦门大学不愧是最美的大学，看宣传片真的美哭。
天津大学 入营的是智能与计算学部，填报时我选的是网络空间安全专业，这个专业只有学硕并且只给2、3个优营（填报时大意了）。天大同样没有机试，只有面试。面试首先是2分钟英文自我介绍，随后是自己准备PPT介绍自己主要做过的项目，最后老师会根据你的项目来提问。由于我报名的是网络安全，所以我主要介绍了自己做过的网安的项目，谁料老师们并不关心，而是揪着我工作量比较小的一个GAN的项目问个底朝天，难过，难过啊。
天大最后优营发了不少，将近100个？优营机会还是很大的，建议冲一冲。
电子科技大学 电子科技大学计算机学院入营了也是一百来个，但是，电科计院的夏令营就只是各个老师介绍一下自己的团队，没有任何考核，也不发优营！！完全就是一个了解老师的过程。但是这不是没有意义的，电科计算机还是非常强的，好的老师非常抢手，有的早早就招满了，所以看到喜欢的老师，赶紧联系，发邮件，打电话，加微信，让老师多了解你一点。在预推免阶段报名科大计算机是需要该院老师推荐信的，否则连报名的机会都没有。
南京大学 说起南大真是一把心酸泪，南大软件今年夏令营入营群里有800多人，听说有3000多报名的，筛了800人出来。南大有机试，还不简单，机试排名前面的才有机会进面试，由于南大和别的学校面试冲突了，且我对自己的机试水平很有自知之明，于是果断放弃。建议想去南大的推免生苦练机试，非常重要。
预推免 今年由于九推变十推，所以不少高校预推免在九月底才截至报名。在预推免阶段就要有选择性的填报大学了，如果夏令营阶段拿到了offer，那么预推免阶段大胆冲击更高层次的学校，这个阶段不要海投了，夏令营没有入营的高校也可以在预推免阶段再投一次。
预推免阶段更要非常注意各个大学的招生信息，务必每天看官网看公众号，否则好的大学很可能跟你擦肩而过。
下面是我参加面试的学校（同样由于时间冲突放弃了不少面试机会，比如华科，中科院）：
电子科技大学 计算机学院 前面提到过，电科计院报名是要该院老师推荐信的，夏令营阶段联系了导师的这会就有优势了。由于没有夏令营，所以预推免阶段竞争还是比较激烈的，大部分老师都已经被预定，所以务必务必务必提前联系老师，否则真的连面试资格都无啊！
计院是笔试加面试，笔试主要是C语言，手写代码，人肉debug，基本和学校的考试题难度相仿（我有整理之前几年笔试的题目，有需要的话可以联系我）笔试之后面试一般是根据你的简历提问，有英语提问等等。
软件学院 软院是在沙河校区，老校区环境不如新校区，但是实力也不差，建议计院和软院都要尝试一下。预推免阶段进面的大概有90人，面试有英语自我介绍和英语提问，专业课考察好像是计网，操作系统、数据库三门课随机抽问题，最后是老师的自由提问阶段。
近年电科大实力和名声都越来越棒，加上成都的地理位置，实在是非常好的选择。
四川大学 进面的是软件学院，和网络空间安全学院，川大的网安实力不差，但是时间冲突，我选择了面软件学院。面试先自我介绍，也没说要英文，于是我中文讲的，主要讲自己的项目经历，我问用不用PPT，老师们说不用，于是我有点慌乱的组织语言介绍了自己的几个项目。老师们问我的问题全是关于GAN项目的，这也是一种趋势，各个老师都对机器学习相关的东西越来越关心。整个面试持续时间8分钟左右，其实感觉有一点点的走流程，感觉这个并不能真的了解到我的水平，不过川大的地理位置和实力还是值得选择。
南开大学 由于时间问题，南开大学的夏令营我没有参加，但是又想要去南开，所以我给招生办打了电话，问有没有预推免，招生办告诉我可能没有预推免，但有些老师有自己招生名额，建议我去试一试。于是我认真整理了简历，投给了南开大学的一个老师，碰巧老师没招满，于是开始交流。先是跟老师打过几次电话交流，老师做网安的，实力非常强，可以说站在中国甚至是世界前列。我这个小菜鸡有一点点害怕，但是老师觉得我有礼貌，肯学习，还是觉得可以要我。后面参加了一场面试，主要是结合PPT介绍自己的做过的项目，老师再提问。总之，最后老师决定要我，要我寄送材料，并开始给我布置任务。但是就在这时，保研排名公布，我认为我保研无望，于是忍痛（其实也没太痛，因为这位老师太强，工作压力太大，其实不太适合我这种小混子）回绝了老师。
想要去南开同学也可以自己联系老师，有老师有自主招生名额，就算错过了夏令营也可以尝试。
北京理工大学（最终去向） 进面北理计算机学院，到10月6号才收到面试通知，8号就要面试，之前没想到能进面，毕竟北理太强了，让我这个小垃圾望而却步。知道进面很激动，但是什么也没准备，面试要求6-8分钟介绍自己基本信息、科研能力、研究生规划等等结合PPT，中间要有2分钟左右英文介绍，随后老师会提问你，会有英文问题。面试时我出了大糗事，讲到一半自己电脑没电了，突然就关机了，我只能赶紧请求下一个面试，这样其实非常不好，很容易影响老师们对你的印象。但是，后面我跟老师们道了歉，继续认真的介绍自己，我想着就算不行，我也要好好完成面试。介绍完自己，有位老师问了我实习做的事情，还有几个项目，问得不深，随后问了我英文问题，由于我很紧张说的话几乎不成句子。但是老师们没有嫌弃。面试完后老师主动加了我好友，说很喜欢我的性格，太开心了。晚上就接到电话，通知我选专业。大写的开心
选导师 推荐给学弟学妹们一个导师评价网站，部分高校的导师在网站上有评价，可以帮学弟学妹们避雷。导师推荐网
支教保研 我是在九月初跟辅导员交流的时候才知道还有这种保研方式，支教保研是去指定的贫困地区支教满一年后就可获得保研本校的资格，不是拥有保研资格的人才能报名，而是通过支教保研获得保研资格。很多同学对这个政策不了解或者是有误解。支教保研是党中央直接下发到部分大学的保研资格，与大学自身的保送资格没有关系。
对于在保研线外或者是保研边缘的同学来说，这是一条很好的保研渠道，报名支保的成绩要求一般是前50%，可以说是门槛比较低了，但是每个学校名额很少，像我们学校只有6个名额，所以竞争还是非常激烈的。
支教保研面试最看重的不再是你的科研能力了，而是你对支教事业的热情。如果你是党员、学生干部、成绩优异、口才好、有支教经历、有特长都会对面试很有帮助。更多的信息可以去翻看一下参加过支保的学长学姐们，由于我后期拿到了保研资格，考虑之后还是放弃了支保这条路。
还有一点，我想告诉想参加支保的学弟学妹们，不要为了拿到保研资格才选择支教保研，选择支保的原因应该也只能是想为贫困地区的孩子们带去希望，想用自己的力量为中国教育事业做贡献。
看到一个学姐写的这样一段话，分享给可能要去支教的学弟学妹们。“支教不是你人生舞台的配音演员，也不是旅游攻略下一个景点，更绝非施恩施惠，抱着分享而不是希望被别人敬佩的心态，去为孩子们提供力所能及的教育服务。其实我们在潜移默化不论时间长短的影响着孩子们的生活和学习、人生轨迹的影响又是一件严肃而认真的事情，这就需要我们更好的审视和完善自己。”
下面是一篇我认为写的非常好的给研支团的文章。给研究生支教团的11个忠告
终章 至此，我悬着的心终于放下来了，确定了自己要去北京理工大学了。于是回绝了所有之前拿的offer，也回绝了之后的所有面试。各位学弟学妹们也希望你们在拿到自己想要的offer之后，就尽早回绝之前拿到的offer，不要耽误别的学校的招生。
半年的保研之路算是告一段落了，保研之路充满艰辛，是能力战更是信息战，心理战。保研并不比考研轻松，想到自己大学三年一门课的成绩都不敢放松，兢兢业业的经营自己的均分和GPA，强迫自己参加不喜欢的比赛，凡此种种只为拿到保研资格。千辛万苦拿到推免资格仅仅是这场漫漫保研路的开始，甚至可以说是最简单的一步。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/430cd3fe2f1369e34eb0660e0b5e09ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1433f8440934cd9e2d774ad4d22f6eda/" rel="bookmark">
			Kubernetes --Dashboard网页界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于Kubernetes二进制部署（多节点）后部署网页界面
https://blog.csdn.net/chengu04/article/details/108904028
#在master01上操作
#创建dashborad工作目录
[root@localhost k8s]# mkdir dashboard #拷贝官方的文件
https://github.com/kubernetes/kubernetes/tree/master/cluster/addons/dashboard [root@master01 dashboard]# ls dashboard-configmap.yaml dashboard-rbac.yaml dashboard-service.yaml dashboard-controller.yaml dashboard-secret.yaml k8s-admin.yaml 默认的三个命名空间：
[root@master01 dashboard]# kubectl get ns NAME STATUS AGE default Active 9d kube-public Active 9d kube-system Active 9d #按以下次序以yaml文件进行创建
资源创建：create和apply
资源重新部署，更新：apply
[root@localhost dashboard]# kubectl create -f dashboard-rbac.yaml role.rbac.authorization.k8s.io/kubernetes-dashboard-minimal created rolebinding.rbac.authorization.k8s.io/kubernetes-dashboard-minimal created [root@localhost dashboard]# kubectl create -f dashboard-secret.yaml secret/kubernetes-dashboard-certs created secret/kubernetes-dashboard-key-holder created [root@localhost dashboard]# kubectl create -f dashboard-configmap.yaml configmap/kubernetes-dashboard-settings created [root@localhost dashboard]# kubectl create -f dashboard-controller.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1433f8440934cd9e2d774ad4d22f6eda/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e64fddc2ce91089d299771ebb180910/" rel="bookmark">
			vue的v-model原理简述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，v-model是什么 v-model就是vue的双向绑定的指令，能将页面上控件输入的值同步更新到相关绑定的data属性，也会在更新data绑定属性时候，更新页面上输入控件的值。
二，为什么使用v-model v-model作为双向绑定指令也是vue两大核心功能之一，使用非常方便，提高前端开发效率。在view层，model层相互需要数据交互，即可使用v-model。
三，v-model的原理简单描述 v-model主要提供了两个功能，view层输入值影响data的属性值，data属性值发生改变会更新view层的数值变化。以下以input控制绑定v-model举例说明。
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;p&gt;{{name}}&lt;/p&gt; &lt;input type="text" v-model="name" /&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 3.1 input 输入值后更新data 首先在页面初始化时候，vue的编译器会编译该html模板文件，将页面上的dom元素遍历生成一个虚拟的dom树。再递归遍历虚拟的dom的每一个节点。当匹配到其是一个元素而非纯文本，则继续遍历每一个属性。
如果遍历到v-model这个属性，则会为这个节点添加一个input事件，当监听从页面输入值的时候，来更新vue实例中的data想对应的属性值。
// 假如node是遍历到的input节点 node.addEventListener("input",function(e){ vm.name=e.target.value; }) 3.2data的属性赋值后更新input的值 同样初始化vue实例时候，会递归遍历data的每一个属性，并且通过defineProperty来监听每一个属性的get，set方法，从而一旦某个属性重新赋值，则能监听到变化来操作相应的页面控制。
Object.defineProperty(data,"name",{ get(){ return data["name"]; }, set(newVal){ let val=data["name"]; if (val===newVal){ return; } data["name"]=newVal; // 监听到了属性值的变化,假如node是其对应的input节点 node.value=newVal; } }) 四，总结 其核心就是，一方面modal层通过defineProperty来劫持每个属性，一旦监听到变化通过相关的页面元素更新。另一方面通过编译模板文件，为控件的v-model绑定input事件，从而页面输入能实时更新相关data属性值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2069751dae88741048160ce3776c27e/" rel="bookmark">
			MAXDOS网刻教程~~（虚拟机与物理机 / 两台或者多台电脑之间)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MAXDOS网刻教程~~（虚拟机与物理机 / 两台或者多台电脑之间） 查看主机IP与子网掩码MAXDOS网刻版配置新建方案配置网络配置 虚拟机与物理机两台电脑或者多台电脑之间 资源下载 MAXDOS 2.0网刻版 ：Http://pzz.cn/soft/7ngsrv.rar
Symantec ghost64.exe： https://xitonggho.cowtransfer.com/s/0f1f71cb687141
查看主机IP与子网掩码 在电脑网络适配器下，对当前所连接的网络（此处为 以太网）右键，选择状态—详细信息即可（主机ip为 172.17.236.135 子网掩码为255.255.255.0）：
MAXDOS网刻版配置 新建方案配置 双击MaxNGS.exe,输入方案名称–new，会话名称不用改，选择恢复镜像----PXE（网络启动），选择镜像文件（即所下载的.gho镜像）
下一步后，分区克隆，选择安装的分区位置，调整客户端参数，三种模式：
单点传送多点传输广播
另外，根据需求还有自动参数可供选择。
网络配置 （注意： 虚拟机网络模式选择 仅主机！！！）
启动网卡，选择主机IP那个数据（172.17.236.135），起始IP 设置在启动网卡之外（此处设置为 172.17.236.136），子网掩码即为主机的子网掩码（255.255.255.0），地址池根据需求设置，启动文件为PXELINUX.0 ,引导文件为 MAXDOS.IMG ,TFTP目录自动配置。（两个文件可新建txt文件后，对其重命名，一个为PXELINUX.0，另一个为MAXDOS.IMG）保存后即可。
MAXDOS服务端配置成功！
虚拟机与物理机 首先主机安装一系列软件，物理机安装MAXDOS网刻版与所需gho镜像，虚拟机安装Symantec ghost64.exe。如下：
首先在虚拟机里给系统分出一块硬盘，在此电脑右键—管理–存储设备：
分盘教程地址
分区完成后，打开ghost64.exe，选择GhostCast—Multioast。
输入服务端的会话名称（MAX），选择指定IP，输入ip（此ip必须在起始ip之外），点击ok结束。
选择安装的分区，硬盘位置（连接后该硬盘会被重置分区，导致不会正常使用，请提前备份数据）
连接成功后显示进度，服务端显示连接的客户ip，点击发送，客户机就开始恢复镜像。
两台电脑或者多台电脑之间 一台设置为 服务机，进行MAXDOS配置，建立可用方案，启动即可！
其他为客户机，客户机操作同虚拟机（连接后该硬盘会被重置分区，导致不会正常使用，但数据不会覆盖，建议提前备份数据）！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cd79e401ef9ef387ea628e2f3c06f7b/" rel="bookmark">
			数据可视化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、散点图二、散点图三、趋势分析四、相关性分析 一、散点图 代码如下（示例）：
#游戏数据可视化 # 绘制散点图 w &lt;- read.csv("可视化数据.csv", header = F, as.is=T) str(w) head(w) data.names &lt;- c("日期","活跃用户","新增用户","付费率", "付费用户","首次付费用户","ARPPU","ARPU") colnames(w) &lt;- data.names str(w) head(w) #单指标数据可视化 summary(w) w$new.date &lt;- paste(substr(w$日期,6,7),substr(w$日期,9,10),sep = "/") head(w) barplot(height = w$新增用户, names.arg = w$new.date) #还可以进行哪些单指标分析？通过分析单指标，得出相对应的结论。 二、散点图 #双指标数据可视化 plot(w$活跃用户~w$新增用户,col="violetred2",pch=16, main="活跃用户 vs 新增用户散点图") #添加线性拟合直线 abline(lm(w$活跃用户~w$新增用户),col="blue",lwd=2,lty=2) #还可以进行哪些双指标分析？通过分析双指标，得出相对应的结论。 #三指标数据可视化 plot(w$活跃用户~w$新增用户,col="violetred2",pch=16, cex=w$付费率, main="活跃用户 vs 新增用户气泡图") 三、趋势分析 #同比、环比 data &lt;- data.frame(pre=c(113,134,123,145,137,196,187), now=c(129,122,134,149,146,215,208)); ylim.max &lt;- 550 col = c("azure4","brown4") ##将主副标题放到barplot函数里，进行设置 ##font=3,表示字体为“斜体” ##cex=1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3cd79e401ef9ef387ea628e2f3c06f7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/319cae11f67676e5bec1f2cffad5e58e/" rel="bookmark">
			Login failed for user ‘sa‘  错误排查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用户查询页面执行查询sqlserver时某表报 Login failed for user 'sa'，这个错误有点莫名其妙，因为通过jdbc，配置的用户名根本不是sa，怎么会报此错误呢？仔细对比代码后没发现异常。后来怀疑是数据库设置有问题，通过一番操作后，还是报这个错。后来以不同账户在sql管理器来执行相同sql，都报相同的错误。基本上确实就是数据库连接或是查询的问题。
后来联系了DBA，排查发现因为查询了第三方数据库（用的视图），而第三方用的是sa账号，人家改密码了，我X。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb69a1a0de6fa5d0189076865502e18d/" rel="bookmark">
			【Java】P5461 赦免战俘——（OJ：洛谷）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目背景 借助反作弊系统，一些在月赛有抄袭作弊行为的选手被抓出来了！
题目描述 现有 2n×2n (n≤10) 名作弊者站成一个正方形方阵等候 kkksc03 的发落。kkksc03 决定赦免一些作弊者。他将正方形矩阵均分为 4 个更小的正方形矩阵，每个更小的矩阵的边长是原矩阵的一半。其中左上角那一个矩阵的所有作弊者都将得到赦免，剩下 3 个小矩阵中，每一个矩阵继续分为 4 个更小的矩阵，然后通过同样的方式赦免作弊者……直到矩阵无法再分下去为止。所有没有被赦免的作弊者都将被处以棕名处罚。
给出 n，请输出每名作弊者的命运，其中 0 代表被赦免，1 代表不被赦免。
输入格式 一个整数 n。
输出格式 2n×2n 的 01 矩阵，代表每个人是否被赦免。数字之间有一个空格。
输入输出样例 输入 #1复制
3
输出 #1复制
0 0 0 0 0 0 0 1
0 0 0 0 0 0 1 1
0 0 0 0 0 1 0 1
0 0 0 0 1 1 1 1
0 0 0 1 0 0 0 1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb69a1a0de6fa5d0189076865502e18d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dadf0c4040c56f03c429faa4a67e01f8/" rel="bookmark">
			OSI七层模型详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OSI 七层模型通过七个层次化的结构模型使不同的系统不同的网络之间实现可靠的通讯，因此其最主要的功能就是帮助不同类型的主机实现数据传输 。
完成中继功能的节点通常称为中继系统。在OSI七层模型中，处于不同层的中继系统具有不同的名称。 一个设备工作在哪一层，关键看它工作时利用哪一层的数据头部信息。网桥工作时，是以MAC头部来决定转发端口的，因此显然它是数据链路层的设备。
具体说:
物理层：网卡，网线，集线器，中继器，调制解调器
数据链路层：网桥，交换机
网络层：路由器
网关工作在第四层传输层及其以上
集线器是物理层设备,采用广播的形式来传输信息。
交换机就是用来进行报文交换的机器。多为链路层设备(二层交换机)，能够进行地址学习，采用存储转发的形式来交换报文.。
路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。选择通畅快捷的近路，能大大提高通信速度，减轻网络系统通信负荷，节约网络系统资源，提高网络系统畅通率。 交换机和路由器的区别
交换机拥有一条很高带宽的背部总线和内部交换矩阵。交换机的所有的端口都挂接在这条总线上，控制电路收到数据包以后，处理端口会查找内存中的地址对照表以确定目的MAC（网卡的硬件地址）的NIC（网卡）挂接在哪个端口上，通过内部交换矩阵迅速将数据包传送到目的端口，目的MAC若不存在则广播到所有的端口，接收端口回应后交换机会“学习”新的地址，并把它添加入内部MAC地址表中。 使用交换机也可以把网络“分段”，通过对照MAC地址表，交换机只允许必要的网络流量通过交换机。通过交换机的过滤和转发，可以有效的隔离广播风暴，减少误包和错包的出现，避免共享冲突。 交换机在同一时刻可进行多个端口对之间的数据传输。每一端口都可视为独立的网段，连接在其上的网络设备独自享有全部的带宽，无须同其他设备竞争使用。当节点A向节点D发送数据时，节点B可同时向节点C发送数据，而且这两个传输都享有网络的全部带宽，都有着自己的虚拟连接。假使这里使用的是10Mbps的以太网交换机，那么该交换机这时的总流通量就等于2×10Mbps＝20Mbps，而使用10Mbps的共享式HUB时，一个HUB的总流通量也不会超出10Mbps。 总之，交换机是一种基于MAC地址识别，能完成封装转发数据包功能的网络设备。交换机可以“学习”MAC地址，并把其存放在内部地址表中，通过在数据帧的始发者和目标接收者之间建立临时的交换路径，使数据帧直接由源地址到达目的地址。
从过滤网络流量的角度来看，路由器的作用与交换机和网桥非常相似。但是与工作在网络物理层，从物理上划分网段的交换机不同，路由器使用专门的软件协议从逻辑上对整个网络进行划分。例如，一台支持IP协议的路由器可以把网络划分成多个子网段，只有指向特殊IP地址的网络流量才可以通过路由器。对于每一个接收到的数据包，路由器都会重新计算其校验值，并写入新的物理地址。因此，使用路由器转发和过滤数据的速度往往要比只查看数据包物理地址的交换机慢。但是，对于那些结构复杂的网络，使用路由器可以提高网络的整体效率。路由器的另外一个明显优势就是可以自动过滤网络广播。
集线器与路由器在功能上有什么不同? 首先说HUB,也就是集线器。它的作用可以简单的理解为将一些机器连接起来组成一个局域网。而交换机（又名交换式集线器）作用与集线器大体相同。但是两者在性能上有区别：集线器采用的式共享带宽的工作方式，而交换机是独享带宽。这样在机器很多或数据量很大时，两者将会有比较明显的。而路由器与以上两者有明显区别，它的作用在于连接不同的网段并且找到网络中数据传输最合适的路径。路由器是产生于交换机之后，就像交换机产生于集线器之后，所以路由器与交换机也有一定联系，不是完全独立的两种设备。路由器主要克服了交换机不能路由转发数据包的不足。 总的来说，路由器与交换机的主要区别体现在以下几个方面： （1）工作层次不同 最初的的交换机是工作在数据链路层，而路由器一开始就设计工作在网络层。由于交换机工作在数据链路层，所以它的工作原理比较简单，而路由器工作在网络层，可以得到更多的协议信息，路由器可以做出更加智能的转发决策。 （2）数据转发所依据的对象不同 交换机是利用物理地址或者说MAC地址来确定转发数据的目的地址。而路由器则是利用IP地址来确定数据转发的地址。IP地址是在软件中实现的，描述的是设备所在的网络。MAC地址通常是硬件自带的，由网卡生产商来分配的，而且已经固化到了网卡中去，一般来说是不可更改的。而IP地址则通常由网络管理员或系统自动分配。 （3）传统的交换机只能分割冲突域，不能分割广播域；而路由器可以分割广播域 由交换机连接的网段仍属于同一个广播域，广播数据包会在交换机连接的所有网段上传播，在某些情况下会导致通信拥挤和安全漏洞。连接到路由器上的网段会被分配成不同的广播域，广播数据不会穿过路由器。虽然第三层以上交换机具有VLAN功能，也可以分割广播域，但是各子广播域之间是不能通信交流的，它们之间的交流仍然需要路由器。 （4）路由器提供了防火墙的服务 路由器仅仅转发特定地址的数据包，不传送不支持路由协议的数据包传送和未知目标网络数据包的传送，从而可以防止广播风暴。
物理层
在OSI参考模型中，物理层（Physical Layer）是参考模型的最低层，也是OSI模型的第一层。
物理层的主要功能是：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。
物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。
数据链路层
数据链路层（Data Link Layer）是OSI模型的第二层，负责建立和管理节点间的链路。该层的主要功能是：通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。
在计算机网络中由于各种干扰的存在，物理链路是不可靠的。因此，这一层的主要功能是在物理层提供的比特流的基础上，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路，即提供可靠的通过物理介质传输数据的方法。
该层通常又被分为介质访问控制（MAC）和逻辑链路控制（LLC）两个子层。
MAC子层的主要任务是解决共享型网络中多用户对信道竞争的问题，完成网络介质的访问控制；
LLC子层的主要任务是建立和维护网络连接，执行差错校验、流量控制和链路控制。
数据链路层的具体工作是接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层；并且，还负责处理接收端发回的确认帧的信息，以便提供可靠的数据传输。
网络层
网络层（Network Layer）是OSI模型的第三层，它是OSI参考模型中最复杂的一层，也是通信子网的最高一层。它在下两层的基础上向资源子网提供服务。其主要任务是：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。该层控制数据链路层与传输层之间的信息转发，建立、维持和终止网络的连接。具体地说，数据链路层的数据在这一层被转换为数据包，然后通过路径选择、分段组合、顺序、进/出路由等控制，将信息从一个网络设备传送到另一个网络设备。
一般地，数据链路层是解决同一网络内节点之间的通信，而网络层主要解决不同子网间的通信。例如在广域网之间通信时，必然会遇到路由（即两节点间可能有多条路径）选择问题。 在实现网络层功能时，需要解决的主要问题如下：
寻址：数据链路层中使用的物理地址（如MAC地址）仅解决网络内部的寻址问题。在不同子网之间通信时，为了识别和找到网络中的设备，每一子网中的设备都会被分配一个唯一的地址。由于各子网使用的物理技术可能不同，因此这个地址应当是逻辑地址（如IP地址）。
交换：规定不同的信息交换方式。常见的交换技术有：线路交换技术和存储转发技术，后者又包括报文交换技术和分组交换技术。
路由算法：当源节点和目的节点之间存在多条路径时，本层可以根据路由算法，通过网络为数据分组选择最佳路径，并将信息从最合适的路径由发送端传送到接收端。
连接服务：与数据链路层流量控制不同的是，前者控制的是网络相邻节点间的流量，后者控制的是从源节点到目的节点间的流量。其目的在于防止阻塞，并进行差错检测。
传输层
OSI下3层的主要任务是数据通信，上3层的任务是数据处理。而传输层（Transport Layer）是OSI模型的第4层。因此该层是通信子网和资源子网的接口和桥梁，起到承上启下的作用。
该层的主要任务是：向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。传输层的作用是向高层屏蔽下层数据通信的细节，即向用户透明地传送报文。该层常见的协议：TCP/IP中的TCP协议、Novell网络中的SPX协议和微软的NetBIOS/NetBEUI协议。
传输层提供会话层和网络层之间的传输服务，这种服务从会话层获得数据，并在必要时，对数据进行分割。然后，传输层将数据传递到网络层，并确保数据能正确无误地传送到网络层。因此，传输层负责提供两节点之间数据的可靠传送，当两节点的联系确定之后，传输层则负责监督工作。综上，传输层的主要功能如下：
传输连接管理：提供建立、维护和拆除传输连接的功能。传输层在网络层的基础上为高层提供“面向连接”和“面向无接连”的两种服务。
处理传输差错：提供可靠的“面向连接”和不太可靠的“面向无连接”的数据传输服务、差错控制和流量控制。在提供“面向连接”服务时，通过这一层传输的数据将由目标设备确认，如果在指定的时间内未收到确认信息，数据将被重发。
监控服务质量。
会话层
会话层（Session Layer）是OSI模型的第5层，是用户应用程序和网络之间的接口，主要任务是：向两个实体的表示层提供建立和使用连接的方法。将不同实体之间的表示层的连接称为会话。因此会话层的任务就是组织和协调两个会话进程之间的通信，并对数据交换进行管理。
用户可以按照半双工、单工和全双工的方式建立会话。当建立会话时，用户必须提供他们想要连接的远程地址。而这些地址与MAC（介质访问控制子层）地址或网络层的逻辑地址不同，它们是为用户专门设计的，更便于用户记忆。域名（DN）就是一种网络上使用的远程地址例如：www.3721.com就是一个域名。会话层的具体功能如下：
会话管理：允许用户在两个实体设备之间建立、维持和终止会话，并支持它们之间的数据交换。例如提供单方向会话或双向同时会话，并管理会话中的发送顺序，以及会话所占用时间的长短。
会话流量控制：提供会话流量控制和交叉会话功能。
寻址：使用远程地址建立会话连接。l
出错控制：从逻辑上讲会话层主要负责数据交换的建立、保持和终止，但实际的工作却是接收来自传输层的数据，并负责纠正错误。会话控制和远程过程调用均属于这一层的功能。但应注意，此层检查的错误不是通信介质的错误，而是磁盘空间、打印机缺纸等类型的高级错误。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dadf0c4040c56f03c429faa4a67e01f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f29bbf9531682a81c8a95ec12e967eef/" rel="bookmark">
			Java多线程-while死循环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		示例代码如下所示：
线程A执行methodA()，methodA()中有一个死循环
线程B执行methodB()，当线程A进入methodA()中的死循环的时候，我们希望知道线程B能不能执行完成。
import java.util.*; import java.util.concurrent.ThreadPoolExecutor; public class test { public static void main(String[] args) { Service service=new Service(); ThreadA threadA=new ThreadA(service); threadA.start(); ThreadB threadB=new ThreadB(service); threadB.start(); } } class Service{ Object object1=new Object(); public void methodA(){ synchronized (object1){ System.out.println("methodA begin"); boolean isContinueRun=true; while(isContinueRun){ } System.out.println("methodA end"); } } Object object2=new Object(); public void methodB(){ synchronized (object2){ System.out.println("methodB begin"); System.out.println("methodB end"); } } } class ThreadA extends Thread{ private Service service; public ThreadA(Service service){ super(); this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f29bbf9531682a81c8a95ec12e967eef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/971955ebaae9460c6f72bed12d93b827/" rel="bookmark">
			Golang时间格式化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Golang时间类型通过自带的 Format 方法进行格式化。
需要注意的是Go语言中格式化时间模板不是常见的Y-m-d H:M:S而是使用Go语言的诞生时间 2006-01-02 15:04:05 -0700 MST。
为了记忆方便，按照美式时间格式 月日时分秒年 外加时区 排列起来依次是 01/02 03:04:05PM ‘06 -0700，刚开始使用时需要注意。
实际项目中，Format 函数中可以自定义时间格式，也可以使用time包中的预定义格式：
const ( ANSIC = "Mon Jan _2 15:04:05 2006" UnixDate = "Mon Jan _2 15:04:05 MST 2006" RubyDate = "Mon Jan 02 15:04:05 -0700 2006" RFC822 = "02 Jan 06 15:04 MST" RFC822Z = "02 Jan 06 15:04 -0700" // RFC822 with numeric zone RFC850 = "Monday, 02-Jan-06 15:04:05 MST" RFC1123 = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/971955ebaae9460c6f72bed12d93b827/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1b0cc4575ca18732130b20cbde16e90/" rel="bookmark">
			idea antlr4 使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、安装ANTLR v4 grammar plugin插件
2、建立maven工程
3、新建CustomSql.g4文件
4、CustomSql.g4测试
5、编译CustomSql.g4，生成相关文件
6、代码测试
1、安装ANTLR v4 grammar plugin插件 2、建立maven工程 pom文件引入
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.antlr&lt;/groupId&gt; &lt;artifactId&gt;antlr4-runtime&lt;/artifactId&gt; &lt;version&gt;4.8-1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.antlr&lt;/groupId&gt; &lt;artifactId&gt;antlr4-maven-plugin&lt;/artifactId&gt; &lt;version&gt;4.8-1&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;antlr4&lt;/goal&gt; &lt;/goals&gt; &lt;phase&gt;none&lt;/phase&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;outputDirectory&gt;src/main/java&lt;/outputDirectory&gt; &lt;!--&lt;listener&gt;true&lt;/listener&gt;--&gt; &lt;visitor&gt;true&lt;/visitor&gt; &lt;!--&lt;treatWarningsAsErrors&gt;true&lt;/treatWarningsAsErrors&gt;--&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; 3、新建CustomSql.g4文件 内容如下（以下内容就是一个简单的测试demo，一个数组的语法）
grammar CustomSql; init : '{' value (',' value)* '}' ; value : init |INT ; INT : [0-9]+ ; WS : [\t\n\r]+ -&gt; skip ; 4、CustomSql.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1b0cc4575ca18732130b20cbde16e90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0359571e2be7e21106e52152477fda86/" rel="bookmark">
			Echarts 地图配置 拖动缩放/初始化缩放比例/不同地区显示不同颜色/地图和散点图结合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 特点基本使用百度地图API矢量地图 常用配置拖动缩放 roam名称显示初始化缩放比例设置地图中心点 常见效果显示某个区域不同地区显示不同颜色 地图和散点图结合 特点 主要可以帮助我们从宏观的角度快速看出不同地理位置上的数据差异。
基本使用 百度地图API 需要申请百度地图ak
矢量地图 资料
需要准备矢量地图数据
注册矢量地图数据 echarts.registerMap('map',data)
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="Echarts_kaifa.js"&gt;&lt;/script&gt; &lt;script src="jquery.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;h4&gt; 地图 &lt;/h4&gt; &lt;div id="map" style="width: 600px;height:400px;"&gt;&lt;/div&gt; &lt;/div&gt; &lt;hr&gt; &lt;script&gt; let myEchart = echarts.init(document.querySelector("#map")) let mapKey = 'fmap' $.get('json/map/china.json',ret=&gt;{ // 注册地图的JSON数据 echarts.registerMap(mapKey,ret) let option = { geo:{ type: 'map', map: mapKey } } myEchart.setOption(option) }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 常用配置 拖动缩放 roam geo:{ roam: true //拖动缩放 } 名称显示 geo:{ label:{show:true} } 初始化缩放比例 geo:{ zoom:2 //设置初始化缩放比例 } 设置地图中心点 geo:{ center:[87.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0359571e2be7e21106e52152477fda86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27418d34565dd305e19bdb7b78688d00/" rel="bookmark">
			MySQL登录报错ERROR 1045 (28000): Access denied for user ‘root‘@‘localhost‘ (using password: YES)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： Mysql8.0登录报错
原因分析： ERROR 1045 (28000): Access denied for user ‘root’@‘localhost’ (using password: YES)
MySQL8.0 不能通过直接修改 mysql.user 表来更改密码。
因为authentication_string字段下只能是MySQL加密后的43位字符串密码，其他的导致错误。错误不报出，但是无法再登录mysql，总是会提示无法认证。
可以用以下命令查看authentication_string字段下的密码是否是加密后的密码
// 使用mysql库 use mysql; // 查看用户的authentication_string字段下的密码是否加密 select user,authentication_string from user; 如果你的密码下面图片这种，可以试试能不能登录，我的mysql8.0是不能登录的
因此，正确更改密码的方式：先清空root密码，再改密码
解决方案： 按照以下步骤走
找出mysql的配置文件
find / -name my.cnf
编辑修改mysql配置文件
vi /etc/my.cnf
在配置文件里[mysqld]后添加以下两行代码(设置mysql无密码登录和添加加密方式）
skip-grant-tables
#下面的是添加加密方式
default-authentication-plugin=mysql_native_password
保存退出重启mysql
systemctl restart mysqld.service
登录mysql（无密码登录）
mysql -uroot -p
输入密码时直接回车进入，无需密码
进入mysql库
use mysql；
刷新权限
mysql&gt; flush privileges;
清空密码
mysql&gt; UPDATE user SET authentication_string="" WHERE user=“root”;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27418d34565dd305e19bdb7b78688d00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d462f025ba02ef15af5514049b5750c6/" rel="bookmark">
			ERROR 1396 (HY000): Operation ALTER USER failed for ‘root‘@‘%‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： MySQL8.0以上修改密码报错
问题描述： ERROR 1396 (HY000): Operation ALTER USER failed for 'root'@'%' 解决方案： 按照以下步骤执行： 进入mysql库
use mysql；
刷新权限
mysql&gt; flush privileges;
清空密码
mysql&gt; UPDATE user SET authentication_string="" WHERE user=“root”;
刷新权限
mysql&gt; flush privileges;
设置root的新的密码
mysql&gt;alter user’root’@’%’ IDENTIFIED BY 'test123 ';
刷新权限
mysql&gt; flush privileges;
退出mysql，清除my.cnf的skip-grant-tables后重启mysql
systemctl restart mysqld.service
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7c919dd3ad330d5837df8e507ebb68a/" rel="bookmark">
			最全153道Spring全家桶面试题，你都碰到过哪些？（含答案解析）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Spring 框架自诞生以来一直备受开发者青睐，有人亲切的称之为：Spring 全家桶。
毋庸置疑，Spring 早已成为 Java 后端开发的行业标准，无数的公司选择 Spring 作为基础的开发框架，大部分Java 后端程序员在日常工作中也会接触到 Spring。
很多研发人员把 Spring 看作心目中最好的 Java 项目，没有之一。
所以这是重点也是难点，工作中必须会，面试时肯定考。
Spring 面试题 1、不同版本的 Spring Framework 有哪些主要功能？
2、什么是 Spring Framework？
3、列举 Spring Framework 的优点。
4、Spring Framework 有哪些不同的功能？
5、Spring Framework 中有多少个模块，它们分别是什么？
6、什么是 Spring 配置文件？
7、Spring 应用程序有哪些不同组件？
8、使用 Spring 有哪些方式？
9、什么是 Spring IOC 容器？
10、什么是依赖注入？
11、可以通过多少种方式完成依赖注入？
12、区分构造函数注入和 setter 注入。
13、spring 中有多少种 IOC 容器？
14、区分 BeanFactory 和 ApplicationContext。
15、列举 IoC 的一些好处。
16、Spring IoC 的实现机制。
17、什么是 spring bean？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7c919dd3ad330d5837df8e507ebb68a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59d7085b71b86ae9d28dc66bdbb4b2a2/" rel="bookmark">
			自定义BroadcastReceiver 静态注册广播无法接收的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题原因： 从android 8.0（API26）开始，对清单文件AndroidManifest.xml中静态注册广播接收者作了限制（官方对耗电量的优化，避免APP滥用广播的一种处理方式）。
除了少部分的广播仍支持静态注册（如开机广播），其余的都会出现失效的情况。
//开机广播 &lt;receiver android:name=".RebootReceiver" android:enabled="true" android:exported="true"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.BOOT_COMPLETED" /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 解决方法： 采用动态注册（代码注册）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfa791ad6896c77d43ec86c2e8d0c3fe/" rel="bookmark">
			图像处理(三)-直方图均衡化、规格化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 直方图均衡化 上面是一些定义，看上去没有那么直观，下面来一个例子
直方图均衡化的步骤
1、计算Sk,公式在第一张图片
2、把计算的sk就近安排到8个灰度级中
3、重新命名sk，归并相同灰度级的象素数
r3和r4那一行都有6/7，都把他们归并到S3。656+329=985
像素的转换
根据上面图片 0-&gt;1 1-&gt;3 2-&gt;5 3-&gt;6 4-&gt;6 5-&gt;7 6-&gt;7 7-&gt;7 例子：f(1,1)=3 f(2,3)=3 f(1,0)=1 f(7,5)=5 根据上面的映射 f(1,1)=6 f(2,3)=6 f(1,0)=3 f(7,5)=7 直方图规格化 上面的灰度分布想变成
方法
|0.19-0|=0.19 |0.19-0|=0.19 |0.19-0.15|=0.14 |0.19-0.35|=0.16 |0.19-0.65|=0.46 |0.19-0.85|=0.66 |0.19-1.00|=0.81 0.14是最小的 所以0-&gt;3 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32b3d748e85e831b084daae677779d3e/" rel="bookmark">
			在Python中比较字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A string is a very useful and popular variable type used in the Python programming language. Sometimes we need to operate two or more strings and compare them. Comparing numbers is easy but the string is a bit different and harder. In this tutorial, we will look at different comparison operations on Python strings.
字符串是Python编程语言中非常有用且流行的变量类型。 有时我们需要操作两个或多个字符串并进行比较。 比较数字很容易，但是字符串有点不同并且更难。 在本教程中，我们将研究对Python字符串的不同比较操作。
查找更大的字符串 (Find Bigger String) Two numbers can be compared in order to find the bigger one but how can we find a bigger string.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32b3d748e85e831b084daae677779d3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b895749daf19f31e94654ae820486986/" rel="bookmark">
			Spring循环依赖报错Bean with name ‘**‘ has been injected into other beans [**] in its raw version as part
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		异常详情 Bean with name ‘commonService’ has been injected into other beans [] in its raw version as part of a circular reference, but has eventually been wrapped. This means that said other beans do not use the final version of the bean. This is often the result of over-eager type matching - consider using ‘getBeanNamesOfType’ with the ‘allowEagerInit’ flag turned off, for example.**
springboot循环依赖解决 1. 循环依赖是什么？
Bean A 依赖 B，Bean B 依赖 A这种情况下出现循环依赖。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b895749daf19f31e94654ae820486986/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfcdeb618a3cd1dd83543fe67192b5f5/" rel="bookmark">
			gitHub资源快速访问方法--jsDeliver
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 jsDelivr提供npm，GitHub，WordPress等项目的镜像。
https://cdn.jsdelivr.net/gh/ledtwo/simpleBlogs@master/img/earth_top_bg.jpeg
对于新手来说，可能翻译来自jsDelivr官方的使用方法感觉很复杂，其实可以简单一点告诉大家怎么用。
比如在我的网站主题中会用到这样的一个CSS文件：style.css
如果我使用本地文件，网站中载入的文件是：
https://mywebsite.com/wp-content/themes/mytheme/static/css/style.css 如果我把主题托管到github，那么在我的github中也会有这一个文件：
https://github.com/mygitname/mywebsite/tree/master/static/css/style.css 若我Releases一个版本0.0.1，那github中会有这样的文件：
https://github.com/mygitname/mywebsite/tree/0.0.1/static/css/style.css 如果我要使用jsDelivr托管此文件，那只需要将网站中载入的本地文件链接更换为jsDelivr CDN的链接，格式如下（gh代表github）：
https://cdn.jsdelivr.net/gh/mygitname/mywebsite@0.0.1/static/css/style.css 若要使用缩小版本功能，则将“.min”添加到任何JS / CSS文件中，jsdelivr将自动生成文件。
https://cdn.jsdelivr.net/gh/mygitname/mywebsite@0.0.1/static/css/style.min.css 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/056dec0843adec8308de5327ff67ae2a/" rel="bookmark">
			mysql高级篇-docker mysql主从
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql高级篇-docker mysql主从搭建
一、docker环境准备
1、VM安装centos-7 安装详情见https://blog.csdn.net/chaojiangroke/article/details/108660782
2、安装centos-7版docker 安装详细见https://blog.csdn.net/chaojiangroke/article/details/108666791
3、为mysql主从自定义网段 docker network create --subnet=172.18.0.0/16 net-mysql
二、mysql主从（一主一从）
1、下载redis镜像 docker pull mysql:version
2、查看镜像 docker images
3、创建mysql的映射目录 进入要创建映射目录的位置
cd /home/docker
创建主数据库的映射主目录
mkdir mysql-master
进入主数据库的映射主目录
cd mysql-master
创建主数据库的配置文件映射目录
mkdir conf
将准备好的配置文件mysql.cnf docker.cnf mysqldump.cnf拷贝到该目录下
文件保存在网盘
链接：https://pan.baidu.com/s/1g47PAUB-sSf09QkctyTY7w 提取码：aaaa 在docker.cnf目录下添加以下配置
## 设置server_id,注意要唯一
server-id=1
## 开启二进制日志功能，以备Slave作为其它Slave的Master时使用
log-bin=mysql-bin
进入要创建映射目录的位置
cd /home/docker
创建从数据库的映射主目录
mkdir mysql-slave
进入从数据库的映射主目录
cd mysql- slave
创建主数据库的配置文件映射目录
mkdir conf
将准备好的配置文件mysql.cnf docker.cnf mysqldump.cnf拷贝到该目录下
文件保存在网盘
链接：https://pan.baidu.com/s/1g47PAUB-sSf09QkctyTY7w 提取码：aaaa 在docker.cnf目录下添加以下配置
## 设置server_id,注意要唯一
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/056dec0843adec8308de5327ff67ae2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b766a5797f37bd9f5c73c227c7b42cc/" rel="bookmark">
			COIL 100数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Coil-100 Dataset 是由不同物体在 360° 旋转中不同角度成像组成的数据集，其含有 100 个物体（每个具有 72 个姿势）的 128 * 128 色彩图像，以及 49,152 个特征（红色，绿色和蓝色通道中 128 * 128 像素的值）。
大家可以到官网地址下载数据集，我自己也在百度网盘分享了一份。可关注本人公众号，回复“2020100902”获取下载链接。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8283d77df87096cf1c9ad444c36ff7f/" rel="bookmark">
			用python&#43;OpenCV去除图片水印
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python+OpenC不仅能用来为图片添加水印logo，还能用来去除图片的水印。从理论上来说，除非原图中水印所在区域为纯色或有规律的图案，否则无法真正去掉水印，因为加水印的过程是不可逆的，我们无法准确判断水印遮盖区域的像素点颜色，因此无法将图像完全恢复成之前的样子。通常的做法是识别出水印的轮廓，使用膨胀算法覆盖水印。
上篇文章我们介绍了python+OpenC为图片添加水印logo的方法（实现效果如上图），本文就来讨论如何去掉上图中的水印。我们首先要手动取得水印所在区域ROI（感兴趣区域），并为水印创建蒙层（mask），然后借助蒙层对图片进行修补以消除水印。
提取ROI：我们在画图中打开图片，放大之后将鼠标停留在图片中某一位置即可在左下角查看到具体的坐标。使用切片roi = img[918:999, 455,679]提取ROI，需要注意的是图片坐标与二维数组位置是相反的，图片坐标(x, y)中x表示像素点到图片左侧的距离，y表示像素点到图片顶部的距离，而二维数组位置(x, y)中x表示该像素点所在行数，y表示该像素点所在列数，两者虽然都是两个数字，但顺序正好相反。
为水印创建蒙层：通过对水印logo的观察可以发现，该水印由红蓝两种颜色构成，因此我们需要对两种颜色分别处理。为了精确处理蓝色，我们可以先将ROI的颜色格式由BGR转换为HS，然后调用inRange( )函数对ROI进行二值化处理，将蓝色区域变成白色，将其它区域变成黑色，这样就创建好了蓝色的蒙层（mask）。关于inRange函数和HS请读者自行百度，本文不做详细介绍。
图片修补：将水印区域放大之后发现在水印的边缘有很多锯齿噪点，这些噪点与水印的颜色相差较大，很影响去除水印的效果。为了消除这些边缘噪点需要调用dilate( )函数对水印蒙层进行膨胀操作，膨胀是数学形态学的基本操作之一，会使蒙层适当扩大“淹没”边缘可能存在的噪点；接下来就是利用膨胀后的蒙层对ROI进行修补，用到的函数是inPaint( )；最后一步把修补之后的水印区域回填到原图中，完整代码如下图：
因为原图中水印有两种颜色，我们需要先后对水印中的蓝色和红色部分进行处理。需要提醒的是：HS格式也是由三个数字表示，H的取值范围是0-180，S和的取值范围是0-255，不同颜色对应的HS的取值范围也是不同的，读者可以从网上。去除水印之后的图片如下所示：
不得不说这个水印消除的很完美，即使将上图放大还几倍也很难发现这是一张去除水印的图片。文中使用的图片素材和完整代码已上传至网盘，请移步我的同名微博获取下载链接。如果你对本文内容感兴趣请点个赞，我将持续更新精彩内容，请保持。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f44dbc6f0f47990b4da46d615ff422ac/" rel="bookmark">
			贪心算法以及简单示例Java实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		贪心算法 一、基本概念二、算法步骤三、贪心算法解决集合覆盖问题代码实现 一、基本概念 贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解。贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择。也就是说，不从整体最优上加以考虑，做出的只是在某种意义上的局部最优解。
二、算法步骤 贪心算法一般按照如下步骤进行：
建立数学模型来描述问题把待求解的问题分解位若干个子问题对每个子问题进行求解，得到局部最优解把子问题的局部最优解合并为原问题的一个解 简单来说，就是在进行每一步选择时，都基于当前步，选择最优的解。
这里我们以一个简单的集合覆盖问题为例：
假设现有如下几个广播台以及广播信号可以覆盖的地区，如何选择最少的广播，使广播信号可以覆盖所有地区。
由上题可以得知，现有{北京、上海、天津、广州、深圳、成都、杭州、大连}这几个地区需要覆盖，那么我们在进行选择时，就是每一次尽量覆盖足够多的未被覆盖的地区。
选择K1，那么此时还有{广州、深圳、成都、杭州、大连}未覆盖选择K2，那么此时还有{成都、杭州、大连}未覆盖选择K3，那么此时还有{大连}未覆盖现在K5，此时已经全部覆盖 三、贪心算法解决集合覆盖问题代码实现 /** * @author dankejun * @create 2020/9/1816:57 */ public class GreedyAlgorithm { public static void main(String[] args) { HashMap&lt;String, HashSet&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); HashSet&lt;String&gt; hashSet1 = new HashSet(); hashSet1.add("北京"); hashSet1.add("上海"); hashSet1.add("天津"); HashSet&lt;String&gt; hashSet2 = new HashSet(); hashSet2.add("广州"); hashSet2.add("北京"); hashSet2.add("深圳"); HashSet&lt;String&gt; hashSet3 = new HashSet(); hashSet3.add("成都"); hashSet3.add("上海"); hashSet3.add("杭州"); HashSet&lt;String&gt; hashSet4 = new HashSet(); hashSet4.add("上海"); hashSet4.add("天津"); HashSet&lt;String&gt; hashSet5 = new HashSet(); hashSet5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f44dbc6f0f47990b4da46d615ff422ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f9a27bc5eecdc0429c0dfed70d50cfb/" rel="bookmark">
			【jenkins基础】设置jenkins时区方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 打开jenkins图形界面，找到系统管理-&gt;脚本命令行 在脚本执行命令行中输入： System.setProperty('org.apache.commons.jelly.tags.fmt.timeZone', 'Asia/Shanghai') 在Linux系统下修改步骤如下： sudo vi /etc/default/jenkins
修改： JAVA_ARGS="-Dorg.apache.commons.jelly.tags.fmt.timeZone=Asia/Shanghai -Dfile.encoding=UTF-8 -Djava.awt.headless=true" # Allow graphs etc. to work even when an X server is present # 给java启动的进程指定参数org.apache.commons.jelly.tags.fmt.timeZone为你需要显示的时区，根据自需进行修改即可！ 修改完后执行：sudo service jenkins restart
成功展示系统当前时间，因我设置的上海地区 在构建触发器中设置 如果有不会使用定时构建任务的可以点击帮助，里面有具体信息可以参考
定时构建时间描述 在上述设置定时构建时，输入了一行命令H2/ * * * *来表示每隔 2 分钟构建一次，这是一种crontab的写法，具体描述分五个部分： 分钟 小时 日期 月份 星期几 * * * * * - - - - - | | | | | | | | | +----- 星期中星期几 (0 - 7) (星期天 为 0 或 7) | | | +---------- 月份 (1 - 12) | | +--------------- 一个月中的第几天 (1 - 31) | +-------------------- 小时 (0 - 23) +------------------------- 分钟 (0 - 59) 星号（*）：代表所有可能的值，例如 month 字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。 逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”。 中杠（-）：可以用整数之间的中杠表示一个整数范围，例如 “2-6” 表示 “2,3,4,5,6”。 正斜线（/）：可以用正斜线指定时间的间隔频率，例如 “0-23/2” 表示每两小时执行一次。同时正斜线可以和星号一起使用，例如 */10，如果用在 minute 字段，表示每十分钟执行一次。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bed21b90d45d7689fc49f04925ea8708/" rel="bookmark">
			解决 Github 无法登录的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、查询Github官网的IP地址
IP查询网站： https://www.ipaddress.com/
查询 github.com 查询 github.global.ssl.fastly.net 2、写入hosts文件
复制 C:\Windows\System32\drivers\etc 路径下的 hosts文件至桌面，并修改hosts文件，加入如下内容：
140.82.112.4 github.com 199.232.69.194 github.global.ssl.fastly.net	3、刷新DNS
打开cmd,输入如下指令
ipconfig /flushdns ipconfig /flushdns 4、重启浏览器即可访问
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c6606df918659c4aaf9815e86aa8ddb/" rel="bookmark">
			DC使用教程系列1-.synopsys.dc.setup的建立
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0、引言1、如何理解DC所做的工作2、 .synopsys.dc.setup的建立3、启动文件的知识讲解：4、启动DC吧5、再看看workshop吧6、图形界面来使用 0、引言 本博客是通过小破站，经典的DC视频教程，相信不少人应该看过，这里仅仅是针对个人菜鸡的水平，对其做的笔记。本人其实已经看过了5遍左右。刚开始时候，本人菜鸡，没听明白，随着工作的深入，逐渐才体会得到，如果加上了自己的理解，我感觉这样才算是真看懂了。如果我的博客仅仅是原话的抄录，我觉得毫无意义，所以我加上了自己的理解，希望读者能领会，指正。转载务必注明本人博客！
作者：ciscomonkey
1、如何理解DC所做的工作 DC的任务是综合，湾湾人称之为合成，综合的概念是通过RTL、单元库、约束，吐出netlist，由于每一个单元库都有各自的特性极限，如果你的约束不合理，如果你的代码不可综合，所以不是每一个RTL的想法都能够跑出netlist。
​基本的综合可以用一个等式来表达：synthesis = translation + logic optimization + gate mapping
如上图所示，db代表是给工具读的，而lib是给人读的，其中1p98v，代表1.98v，ff代表快速模型。
2、 .synopsys.dc.setup的建立 我们知道安装目录，用户目录，以及工程目录下都可以有这个文件，工程目录下面的优先级是最高的，也是我们经常拿来改动的。这个工程目录下面肯定是空的，需要我们自己手写，所以需要我们一次写好模板，以后拿来用即可。有5个文件夹，mapped是存放综合完成之后的netlist文件的目录，这些文件是经过综合库映射的。Unmaped是存放综合时没有经过工艺库映射所得到的文件目录。
Report是存放报告（比如时序报告、面积报告、DC启动报告等）的目录。Script是存放约束脚本的目录。Work就是启动DC的目录了，在这个目录里面，我们要进行创建.synopsys_dc.setup文件并且编写这个文件，将这个文件放置在work的目录下面。
参考博客如下：
https://www.cnblogs.com/iclearner/p/6621967.html
模板如下，我个人的模板如下所示：
echo "set your project work path" set SYN_ROOT_PATH /rhys_li/dc_training/my_dc_lab/lab1 echo "set your rtl document path" set RTL_PATH $SYN_ROOT_PATH/rtl echo "set your config document path" set CONFIG_PATH $SYN_ROOT_PATH/config echo "set your scripts document path" set SCRIPT_PATH $SYN_ROOT_PATH/scripts echo "set your unmapped document path" set UNMAPPED_PATH $SYN_ROOT_PATH/unmapped echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c6606df918659c4aaf9815e86aa8ddb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15f75dba08db6f49903fc9cb7a781dc1/" rel="bookmark">
			vue 项目使用iview如何做到table嵌套table
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1:首先看效果图
2.这里是使用的table表单组件，组件里面有一个 table-expand 属性需要使用，所以需要引入，我是只有一个组件需要这个属性，所以直接在组件中引入
3:在根据render函数的方式使用
父组件代码
&lt;template&gt; &lt;Table :columns="columns10" :data="data9"&gt; &lt;template slot="action" slot-scope="{ row }"&gt; &lt;Button size="small" type="text" @click="handDetails(row)" &gt; 详情&lt;/Button&gt; &lt;Button size="small" type="text" @click="ShowaddOrder()" &gt; 开单&lt;/Button&gt; &lt;!--&lt;Button--&gt; &lt;!--size="small"--&gt; &lt;!--type="text"--&gt; &lt;!--@click="editorModal('bj')"--&gt; &lt;!--&amp;gt;--&gt; &lt;!--编辑&lt;/Button&gt;--&gt; &lt;!-- &lt;Dropdown trigger="click" :transfer='transfer' style="margin-left: 10px"&gt; &lt;a href="javascript:void(0)"&gt; 更多 &lt;Icon type="ios-arrow-down"&gt;&lt;/Icon&gt; &lt;/a&gt; &lt;DropdownMenu slot="list"&gt; &lt;DropdownItem @click.native="Showdiscount(row)"&gt; 折让 &lt;/DropdownItem&gt; &lt;DropdownItem @click.native="handDetails('SH')"&gt; 经理审核 &lt;/DropdownItem&gt; &lt;DropdownItem @click.native="OutTicketMange()"&gt; 开票 &lt;/DropdownItem&gt; &lt;DropdownItem @click.native="OrderConfirm(row)"&gt; 开单确认 &lt;/DropdownItem&gt; &lt;DropdownItem @click.native="ChildModal(row)"&gt; 子订单列表 &lt;/DropdownItem&gt; &lt;/DropdownMenu&gt; &lt;/Dropdown&gt; --&gt; &lt;/template&gt; &lt;/Table&gt; &lt;/template&gt; js
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15f75dba08db6f49903fc9cb7a781dc1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96865f1bd420612e14cd5004bde55c55/" rel="bookmark">
			popen python_Python子进程和Popen（）及其示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		popen python
Python provides a lot of functionalities with different modules and libraries. When we need to open a new process inside a Python application we can use subprocess library and related functions.
Python提供了许多具有不同模块和库的功能。 当我们需要在Python应用程序中打开新进程时，可以使用subprocess进程库和相关函数。
导入子流程模块 (Import subprocess Module) In order to use related functions and libraries, we should import the subprocess library.
为了使用相关的功能和库，我们应该导入subprocess库。
import subprocess 使用call()函数启动子流程 (Start Sub-Process with call() Function) The simples use case to create a subprocess is using call() function.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96865f1bd420612e14cd5004bde55c55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c72a641a98d79fec2c87c970142d6e51/" rel="bookmark">
			FDTD_1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要彻底弄懂FDTD，首先就要从基本的麦克斯韦方程组出发，一步步推导至我们编程需要的公式。
典型的时域麦克斯韦方程组如下：
{ ∂ H z ∂ y − ∂ H y ∂ z = ϵ ∂ E x ∂ t + σ E x ∂ H x ∂ z − ∂ H z ∂ x = ϵ ∂ E y ∂ t + σ E y ∂ H y ∂ x − ∂ H x ∂ y = ϵ ∂ E z ∂ t + σ E z \begin{cases} \frac {\partial H_z}{\partial y}-\frac {\partial H_y}{\partial z}=\epsilon\frac {\partial E_x}{\partial t}+\sigma E_x\\[2ex] \frac {\partial H_x}{\partial z}-\frac {\partial H_z}{\partial x}=\epsilon\frac {\partial E_y}{\partial t}+\sigma E_y\\[2ex] \frac {\partial H_y}{\partial x}-\frac {\partial H_x}{\partial y}=\epsilon\frac {\partial E_z}{\partial t}+\sigma E_z \end{cases} ⎩⎪⎪⎪⎪⎨⎪⎪⎪⎪⎧​∂y∂Hz​​−∂z∂Hy​​=ϵ∂t∂Ex​​+σEx​∂z∂Hx​​−∂x∂Hz​​=ϵ∂t∂Ey​​+σEy​∂x∂Hy​​−∂y∂Hx​​=ϵ∂t∂Ez​​+σEz​​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c72a641a98d79fec2c87c970142d6e51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f33bcf1e62d69fdb472bb49b14b7186/" rel="bookmark">
			SpringBoot 之 Filter 解释和配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot 之 Filter 解释和配置 过滤器（Filter）：当你有一堆东西的时候，你只希望选择符合你要求的某一些东西。定义这些要求的工具，就是过滤器。
拦截器（Interceptor）：在一个流程正在进行的时候，你希望干预它的进展，甚至终止它进行，这是拦截器做的事情。
0. Filter工作原理 用户发送请求到服务器，会先到达过滤器过滤器会对请求进行一些处理比如过滤请求的参数、修改返回给客户端的 response 的内容、判断是否让用户访问该接口等等。用户请求响应完毕。进行一些自己想要的其他操作。 1. 编写Filter 实现 java.sevlet.Filter 接口，并实现其中的方法
如图所示
2. 配置Filter 配置Filter有两种方式
通过注解配置通过bean配置 2.1 通过注解配置 在自定义的Filter上边加上 @WebFilter注解和 @Component注解
在注解中写出要拦截的 url
2.2 通过bean配置 根据自己写的Filter配置一个 FilterRegistrationBean 注入到容器
3. 测试 编写一个Controller进行测试
测试结果如图：
4. 问题 4.1 如果有多个Filter对同一个方法生效怎么办? 答：bean配置并设置优先级
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27fe052b8e739c9ec49a8273c2fd9c99/" rel="bookmark">
			ubuntu下Vi编辑器方向键和退格键问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ubuntu下Vi编辑器方向键和退格键问题 刚刚新下载了ubuntu20.04的系统，感觉图形界面确实比centos7好用。但是又连续出现了很多问题（我太菜啦）。
问题描述 vi编辑器插入模式下，方向键分别对应ABCD以及退格键失效。以为是自己的问题qwq试了好几次，然后搜了一下是因为没有下载完整的vim包导致的。
解决方案 编辑/etc/vim下的vimrc.tiny文件
sudo vi /etc/vim/vimrc.tiny
将“set compatible改成 set nocompatible ，然后添加 set backspace=2即可解决
建议在命令模式下dd删除set compatible这一行，然后再粘贴（vi操作不熟悉的我qwq）
如图所示
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/230/">«</a>
	<span class="pagination__item pagination__item--current">231/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/232/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>