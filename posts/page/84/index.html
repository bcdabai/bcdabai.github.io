<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f7c34dfe798c3f8fcc0b61bd76d2833/" rel="bookmark">
			搭建stm32电机控制代码框架（五）——Stm32CubeMx配置PWM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		采样配置完成后，进行PWM的配置。PWM的生成依赖于STM32的TIM1定时器，其功能完备如下图所示，电机控制中主要应用其PWM生成功能。
我们当前阶段的目标是生成占空比为50%的三路PWM，其开关频率为10kHz。
那么开始CubeMx的配置，依据stm32f405数据手册中地址总线部分内容，TIM1是挂在ABP2时钟上的，那么先要配置ABP2的时钟。
时钟的配置如下图所示
此时ABP2的时钟频率为72MHz，要想获得10kHz的PWM，则定时器的周期值TPRD = 72M/2/10k = 3600，配置TIM1参数如下图所示，配置123通道均为PMW generation，然后时钟选择为内部时钟。分频系数设置为0，Counter period计数周期值设为3600。
这里需要明确一点就是Count Mode需要注意一下，三者的区别在于中断标志置位的条件不同，我们选择在递增等于比较值和下降等于比较值都触发中断。因此选择中心对齐模式3。
接下来设置死区时间，查询所用开关管的datashee，开关管上升时间+延迟+关断时间+延迟总时间为91ns，因此设置0.5us = 500ns时间作为死区时间完全足够。
由于此时的时钟频率为72M，因此0.5us对应的计数值约为36（36 = 0.5*1e-6*72*1e6）
最后设置PWM的模式，下图基本为默认设置，注意
然后生成代码即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cfc2877e47b1d26362dc5d3f2698002/" rel="bookmark">
			FPN(Feature Pyramid Networks) 特征金字塔模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文：Feature Pyramid Networks for Object Detection
论文链接：https://arxiv.org/abs/1612.03144
前言 目标的多尺度一直是目标检测算法极为棘手的问题。像Fast R-CNN，YOLO这些只是利用深层网络进行检测的算法，是很难把小目标物体检测好。因为小目标物体本身的像素就比较少，随着降采样的累积，它的特征更容易被丢失。为了解决多尺度检测的问题，传统的方法是使用图像金字塔进行数据扩充。虽然图像金字塔可以一定程度解决小尺度目标检测的问题，但是它最大的问题是带来计算量的极大的增加，而且还有很多冗余的计算。
我们这篇文章要介绍的特征金字塔网络（Feature Pyramid Network，FPN）[1]是一个在特征尺度的金字塔操作，它时通过将自顶向下和自底向上的特征图进行融合来实现特征金字塔操作的。FPN提供的是一个特征融合的机制，并没有引入太多的参数，实现了以增加极小计算代价的情况下提升对多尺度目标的检测能力。
1. 背景知识 在FPN之前，目标检测主要有4种不同的卷积结构类型，如下图所示。
(a)是早期的目标检测算法常用的图像金字塔，它通过将输入图像缩放到不同尺度的大小构成了图像金字塔。然后将这些不同尺度的特征输入到网络中（可以共享参数也可以独立参数），得到每个尺度的检测结果，然后通过NMS等后处理手段进行预测结果的处理。图像金字塔最大的问题是推理速度慢了几倍，一个是因为要推理的图像数多了几倍，另一个原因是要检测小目标势必要放大图像。
(b)是Fast R-CNN[3]，Faster R-CNN[4]，YOLO等算法的网络结构，它只使用卷积网络的最后一层作为输出层。这个结构最大的问题就是对小尺寸的目标检测效果非常不理想。因为小尺寸目标的特征会随着逐层的降采样快速损失，到最后一层已经有很少的特征支持小目标的精准检测了。
©是SSD[2]采用的结构，它首先提出了使用不同层的Feature Map进行检测的思想。但是SSD只是单纯的从每一层导出一个预测结果，它并没有进行层之间的特征复用。即没有给高层特征赋予浅层特征擅长检测小目标的能力，也没有给浅层的特征赋予高层捕捉到的语义信息，因此带来的小目标的检测效果的提升是非常有限的。
(d)特征融合在其它模型中也有过探索，例如医学分割算法中的U-Net，如图1.所示。U-Net的特点是只在模型的最后一层进行了预测，并没有使用多分辨率预测。
2. FPN的网络结构 FPN是一个结合了SSD的多分辨率尺度预测和U-Net的多分辨率特征融合的网络结构，如图2所示。FPN可以分成3部分：
图2左侧的自底向上的卷积；
图2右侧的自顶向下的上采样；
图2中间的横向的特征融合。
2.1 自底向上路径 自底向上即是卷积网络的前向过程，我们可以选择不同的骨干网络，例如ResNet-50或者ResNet-101。前向网络的返回值依次是C2，C3，C4，C5，是每次池化之后得到的Feature Map。在残差网络中，C2，C3，C4，C5经过的降采样次数分别是2，3，4，5即分别对应原图中的步长分别是4，8，16，32。这里之所以没有使用C1，是考虑到由于C1的尺寸过大，训练过程中会消耗很多的显存。
2.2 自顶向下路径和横向连接 通过自底向上路径，FPN得到了四组Feature Map。浅层的Feature Map，例如C2含有更多的底层信息（纹理，颜色等），而深层的Feature Map如C5含有更多的语义信息。为了将这四组倾向不同特征的Feature Map组合起来，FPN使用了自顶向下及横向连接的策略，最终得到P2，P3，P4，P5四个输出。
这里我们结合代码讲解FPN的特征融合过程，首先我们通过自底向上的路径得到C2，C3，C4，C5共4个输出。以ResNet-50为例，C5的尺寸是 [H/32, W/32, 512]，其中 512是通道数， 32是步长，H和W是图像的宽和高。在FPN中，我们要得到的P2，P3，P4，P5的通道数都是256。其中P5是由C5计算得到，P4是由P5和C4计算得到，以此类推。FPN的这种计算方式便是自顶向下的路径。
以P3为例，P3是由P4和C3共同得到，其中P4的通道数已经是
256了，但是它的大小只是P3的 1/2 ，因为我们使用上采样将它的尺寸增加到C3的大小，FPN中使用的上采样策略是最近邻居采样。继续，因为C3的通道数是128，而我们需要的P3的通道数是256，所以这里使用1*1卷积将C3的通道数扩充到256。最后P3是P4的上采样的Feature Map和C3的调整通道数的Feature Map的单位加。
最后，FPN 在 P2，P3，P4，P5 之后均接了一个 3*3 卷积操作，该卷积操作是为了减轻上采样的混叠效应（aliasing effect）。
# Top-down Layers P5 = KL.Conv2D(config.TOP_DOWN_PYRAMID_SIZE, (1, 1), name='fpn_c5p5')(C5) P4 = KL.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4cfc2877e47b1d26362dc5d3f2698002/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0beb6891c65c72c7120997e844ea40c9/" rel="bookmark">
			DR70xQ H桥驱动芯片使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、芯片介绍
2、引脚控制说明
2.1 模式控制
2.2 错误反馈
3、芯片控制
3.1 DR70x控制
3.2 DR703/DR704控制
4、实例代码
4.1 DR702
4.2 DR703/DR704
1、芯片介绍 DR70x H桥驱动芯片是一种高性能的电路芯片，主要用于直流电机控制。该芯片采用了先进的H桥驱动技术和电流反馈机制，能够快速、准确地控制电机的速度和方向，并具有高效、低噪音、低能耗等优点。 该芯片的主要特点如下：
1.大电流输出能力：DR70x H桥驱动芯片采用了大功率MOS场效应管，能够输出高达15A的电流，可满足大多数直流电机的驱动需求。
2.全局PWM控制：该芯片支持全局PWM控制，能够提供更加灵活的控制方式，有效减少了输出噪音。
3.双路电流反馈：DR70x H桥驱动芯片采用了双路电流反馈机制，可以准确地测量电机的电流，保证了电机的稳定性和可靠性。
4.多重保护机制：该芯片具备短路保护、过压保护、欠压保护和过流保护等多重保护机制，可有效保护芯片和电机的安全。
总的来说，DR70x H桥驱动芯片是一款性能优越、功能全面、可靠稳定的电路芯片，可以广泛应用于直流电机的控制，包括电动工具、电动车、机器人等领域。
2、引脚控制说明 2.1 模式控制 DR702为硬件配置接口，其所有功能可以通过硬件外围电阻电容元器件进行设定，DR702的控制简单并且占用MCU资源少。
DR703/DR704则含有SPI接口，用于MCU通讯，因此其可以灵活的进行功能配置并读取出所有状态寄存器信息。DR703的寄存器提供丰富的过压过流报警信息，方便系统获取电机工作的实时状态并实现更高的功能等级。相较于DR703Q，DR704Q进一步增加了过压保护功能、离线负载检测功能以及电流检测共模点可配等检测功能。
MODE引脚为控制模式引脚，具体控制信息下表所示：
2.2 故障反馈 DR70x
nFAULT PIN:该引脚应拉至5V或3.3V。当故障被检测时，改引脚为逻辑低
注：DR70x都有该引脚
DR703/DR704
通过读取地址为0X00的错误状态寄存器获取故障状态。
3、芯片控制 3.1 DR70x控制 DR70x控制模式都由MODE引脚来控制，工作状态都由nSLEEP引脚来控制，工作模式都由IN1、IN2脚来控制，两个引脚不同的电平可以控制芯片电流方向。
3.2 DR703/DR704控制 DR702其控制模式只由硬件来控制。
DR703/DR704相较于DR702多了SPI通信，可以由SPI来控制其一些工作模式和获取寄存器故障状态。其SPI工作模式配置如下：
SPI工作模式为MODE0
CPOL = 0，SCLK空闲状态为低电平
CPHA = 0，第一个边沿开始采集
MSB，最高有效位MSB
帧与帧之间，CS引脚至少要被拉高500ns
SPI帧内容
芯片输入帧内容
1位读写位（bit15） 0：
4位地址信息（bit14~bit11）
3位无关数据（bit10~bit8）
8位数据位（bit7~bit0）
芯片输出帧
8位无关数据（bit15~bit8）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0beb6891c65c72c7120997e844ea40c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e1c8a9365aa5c9de35da53a04ec2f64/" rel="bookmark">
			下载安装pytorch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载安装pytorch 在：
https://download.pytorch.org/whl/torch_stable.html
根据服务器CUDA的版本：
nvidia-smi 找到对应版本的pytorch：
下载之后，安装：
pip install cu113/torch-1.12.1%2Bcu113-cp38-cp38-linux_x86_64.whl 搞定！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d0a540b4f36bdadb5112352453595b9/" rel="bookmark">
			swift 存入plist缓存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用plist存入本地缓存 类要遵守协议NSCoding class MyClass: NSCoding { var name = "张三" var age = 8 } 获取路径 private func getFileURL() -&gt; URL? { guard let documentsDirectory = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first else { return nil } let fileURL = documentsDirectory.appendingPathComponent("MyTempData.plist") return fileURL } 存入数据方法 let array = [MyClass]() // ... 添加array元素 guard let fileURL = getFileURL() else { return } do { let archivedData = try NSKeyedArchiver.archivedData(withRootObject: array, requiringSecureCoding: false) try archivedData.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d0a540b4f36bdadb5112352453595b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2dc58122a86b77d0c931372c41b258b/" rel="bookmark">
			外部引脚中断
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FM33A048B的 7 组 GPIO A~G ）最多可以产生 24 个外部引脚中断。 7 组 GPIO 被分为 3 部分，分
别为 PA/PB 、 PC/PD/PG 和 PE/PF ，每部分分别可以选择 8 个引脚产生独立的外部中断，由 4 组控制
寄存器 EXTI_SELx(x=0~3) 进行配置，具体参见寄存器说明。其中 PA/PB 选出的 8bit 用于产生
EXTI0[7:0] PC/PD/P G 选出的 8bit 用于产生 EXTI1[7:0] PE/PF 选出的 8bit 用于产生 EXTI2[7:0]
最终汇总后接入 NVIC 中断输入。
使用引脚中断前必须将对应引脚的功能设为GPIO 输入。各路中断使能与 触发边沿选择功能 整合在
一起，可以选择上升沿、下降沿、双沿触发中断，或禁止中断触发。 下表为 GPIO 对应的中断编号，
其中 ( 表示支持引脚输入数字滤波。
应用指南
如需在Sleep/DeepSleep 模式下启动 EXTI 中断唤醒功能，推荐按照如下步骤进行操作
⚫ 关闭所有 EXTI 使能
⚫ 配置 SYSCLKSEL 寄存器（ 0x0x4000020C ）的 EXTICKSEL 位为 1 ，选择 LSCLK 进行 EXTI 采样
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2dc58122a86b77d0c931372c41b258b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49b879120259b4ca6c821feb3c1c4090/" rel="bookmark">
			c盘满了怎么清理垃圾而不误删？ 服务器c盘空间不足清理方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在使用服务器的时候基本不会在C盘安装软件，那么用久了发现C盘满了，提示空间不足？那么这是怎么回事，为什么空间会占用这么快呢？今天锦多多和大家分享下服务器c盘空间不足的清理方法。
一.磁盘清理
打开计算机，点击C盘，右键属性，可以看到有个“磁盘清理”
点击磁盘清理，可以使用“磁盘清理”来释放些临时和不需要文件。
二.整理桌面
桌面就是默认C盘存储位置，桌面文件太多也是会造成C盘空间不足的，把不需要的文件手动删除，删除后清空回收站，回收站不清理也是会占用C盘空间的。把重要的文件，能转移的转移到D盘或是其它磁盘
三.分文别类
对于长期使用电脑的朋友，建议可以保留一个习惯，根据程序、文件类型或是作用不同，来放到不同的盘符，程序不建议安装到C盘，工作有关、常用的可以放在D盘，休闲娱乐的可以放在E盘或是其它盘符，每个程序都单独建个文件夹，好分辨。当然，这个看个人的习惯，也可以根据自己的习惯来分门别类。
四.卸载不必要的软件
可以用软件管家卸载，也可以在控制面板-程序和功能中卸载，卸载一时兴起，长时间没用过的软件
五.清理QQ、微信不必要的文件 如果是你的QQ文件存储位置下载后没有改动过，可以在C:\Users\Administrator\Documents\Tencent Files 文档路径直接找到QQ的存储文件，能删除的文件夹有：Video、FileRecv（MobileFile这个文件不删，其他的没用的都可以删）、Image，删除后记得清空回收站
如果是你的微信文件存储位置下载后没有改动过，可以在
C:\Users\Administrator\Documents\WeChat Files
文档路径直接找到微信的存储文件，能删除的文件夹有：\FileStorage\Cache、FileStorage\File、FileStorage\Image、FileStorage\Video，删除后也是记得清空回收站
六.清理IIS日志文件（服务器）
打开文件夹C:\Windows\System32\LogFiles 可以看到日志有10多个G。（访问多的会更多）
同时也要检查：C:\inetpub\logs\LogFiles 这些日志文件夹。
这种系统日志文件，可以清理的就清理了，可以空出很多的空间
特别注意：删除之前要打开IIS，先把日志功能禁用
1）打开Internet信息服务（IIS）管理器——选择总网站——单击日志——选择禁用，就可以把日志文件删除了。
注意：如果IIS里有好几个网站，想单独删除某个网站的日志，在上面“选择总网站”的那一步点击左边的加号，里面就有服务器的所有网站，然后选择想禁用的子网站，再单击日志，选择禁用，就可以了。
七.清理不必要文件（服务器）
除了清理服务器IIS日志，还可以清理以下文件：
C:\WINDOWS\PCHealth\ERRORREP\QSIGNOFF\
C:\WINDOWS\PCHealth\ERRORREP\UserDumps\
C:\Windows\Temp
八.虚拟内存转移到其他硬盘（服务器）
服务器虚拟内存默认是在C盘的，将虚拟内存转移到其他盘，如D盘或是E盘，可以增加C盘的空间，虚拟内存设置方法点击这里查看
虚拟内存设置到其他盘服务器需要重启才能生效，服务器重启也可以关闭很多系统产生的缓存文件
删除不必要的文件对清理C盘作用不大，主要就是清理IIS系统日志和虚拟内存设置可以解决服务器c盘空间不足的问题
最后说一下，很多程序路径默认都是C盘，在安装的时候路径可以更换到D盘或是E盘，C盘很多都是系统文件，不好清理
除了以上方法，方便重启服务器的也可以重启下服务器，由于服务器一直开机状态，服务器会产生很多缓存文件，也会占用C盘的空间，导致C盘爆红的“假象”
关于清理C盘的方法今天就分享到这了，感谢您的阅读~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d98e5175956f948fc81e0e8410d53cf/" rel="bookmark">
			矿业，建筑业安全帽数据集15000张
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		XML数据集，已标注，50出
大块煤、锚杆、煤流数据集，未标注 30出
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6b99b0731ad179a763f2cd0c32595dd/" rel="bookmark">
			GitHub 登录不上解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、打开 http://ping.chinaz.com/github.com
2、输入 github.com 点击Ping检测
3、选择一个响应时间短的响应IP
4、修改配置 C:\Windows\System32\drivers\etc\hosts
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2974234b1e400a25d6490d96c5adfb2/" rel="bookmark">
			一场“chmod 777 -R /.*“的救赎
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		chmod -R 777 的3种补救办法
本来是要chmod 777 -R ./*，结果打成了chmod 777 /.*了，并快速按了回车，打印结果发现不对，快速ctrl+c中断，但还是晚了。
当时没发现哪里不对，按ctrl+alt+l 锁屏，吃完午饭回来，锁屏输入当前用户密码，提示密码错误进不了系统（密码是正确的），重启登录依然提示密码错误，一度以为有人给改了密码。
一、尝试单用户修改密码 （其实密码是对的，只要root能登陆，这步可跳过）
银河麒麟系统怎么进入root
找了好多帖子都是在grub中加入 init=/bin/bash，但重启黑屏没东西，直到看到上面链接的文章，高级选项按e加入init=bin/bash，重启有login提示符了。
用普通用户kylin登陆依然提示密码错误，试了下root用户，可以登陆。输入passwd kylin修改密码后，按F10重启还是不能登陆kylin用户。
一顿设置用root登陆界面
ctrl+alt+F1命令行登录界面 （不识别小键盘输入，用上面一排数字键）
ctrl+alt+F7图形登录界面
用root进入"ll /"查看权限，好多777呀，这才意识到是chmod 777 -R /.*问题。
然后各种试，其他机子getfacl -p -R / &gt; ./ggg，本机setfacl --restore=./ggg，没用依然不能登陆。
按chmod -R 777 / 之后 修复方法修改了/etc下的passwd、group、shadow、ssh权限，但没设开机启动脚本，重启还是不行。
二、修改/var/log/tallylog文件权限 Linux下服务器密码正确，登录的时候却提示密码错误
按照上面链接执行 pam_tally2 -u kylin，结果显示/var/log/tallylog文件权限有问题。
对照其他机子后，将权限由777改成600，重启，终于可以进入了！
三、修改一部分命令的suid权限 ping命令报错出现 “ping：icmp open soket：不允许的操作”
#which ping #ll /usr/bin/ping //显示777 #chmod u+s /usr/bin/ping //改成-rwsr-xr-x 对照别的机子发现还有：mount,unmount,su等要s权限。
Linux chmod命令
四、ctrl+alt+l主动锁屏后输入正确密码提示密码错误，只能切换用户登陆 Ubuntu密码正确但是停留在输入密码页面的问题
Ubuntu 锁定屏幕后即使输入正确密码也被提示密码错误导致无法解锁
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2974234b1e400a25d6490d96c5adfb2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df0a60fcdbb137c56baff51a81e6750a/" rel="bookmark">
			chrome的插件升级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有的时候插件的版本会影响项目的运行，会报一些错误的警告信息，因此，插件升级是很有必要的
一、 点击浏览器顶部分三个竖排的点，选中“设置”，点击“扩展程序”
二、选择其中的一个扩展程序，例如，选择印象笔记的扩展程序，点击“详情”
三、点击“更新”按钮，该扩展程序进行升级
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fec45d9a41068d895fc1ce0024baf53/" rel="bookmark">
			ROS踩坑记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ROS踩坑记录 问题：ubuntu 没有 /dev/ttyUSB0问题：运行 launch 文件或 ROS 节点时出现 exit code -9 错误提示问题：windows使用vscode远程连接（ssh）ubuntu时出现 “过程试图写入的管道不存在”或者出现“Bad owner or permissions on C:\\Users\\ASUS/.ssh/config”问题：AMCL 过程中出现 Request for map failed; trying again...问题：AMCL 过程中，在rviz里粒子分布（即那些红色箭头）没有显示问题：车身静止时，rviz中显示的机器人模型在几个定点位置上快速闪动，但odom坐标系一直不变问题：出现警告 MessageFilter问题：ubuntu 卡死 问题：ubuntu 没有 /dev/ttyUSB0 1、跟换数据线，有些数据线是仅充电的，没有数据传输功能
2、没有CH340或CP2102驱动。
CH340驱动下载：http://www.wch.cn/download/CH341SER_LINUX_ZIP.html
CP2102驱动下载：https://www.silabs.com/developers/usb-to-uart-bridge-vcp-drivers
问题：运行 launch 文件或 ROS 节点时出现 exit code -9 错误提示 exit code -9含义：
错误码为linux系统的错误码，并非ros系统的，-9含义为memory使用相关的错误。
使用 htop 命令检测运行 roslaunch 时的内容占用情况，监测内存状态，如果内存爆满，那就是内存不够而造成的
解决：可以扩大swap虚拟内存。参考教程：点这里。
问题：windows使用vscode远程连接（ssh）ubuntu时出现 “过程试图写入的管道不存在”或者出现“Bad owner or permissions on C:\Users\ASUS/.ssh/config” 解决：把C:\Users\ASUS\.ssh路径下的config文件删掉，然后在vscode重新ssh，这个时候会自动重新创建config文件。
如果还是不能ssh，或者弹出operation not permitted错误提示，就右键config文件-&gt;属性-&gt;安全，查看当前用户是否有权限，如下图：
如果没有，点击编辑-&gt;添加，把你的用户名称添加进去，然后确定，如下图：
添加完成后，把权限全部勾选：
然后确定就可以了。
问题：AMCL 过程中出现 Request for map failed; trying again… 这是因为AMCL需要订阅map话题，尽管你通过rostopic list看到map话题已经被发布，也会弹出这个错误。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fec45d9a41068d895fc1ce0024baf53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f331aae1025bd10931622fe2e71d0d9/" rel="bookmark">
			Windows平台下，YOLOX目标检测环境部署教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、克隆YOLOX源码 git clone https://github.com/Megvii-BaseDetection/YOLOX 可转到gitee仓库再克隆到本地
git clone https://gitee.com/monkeycc/YOLOX.git 2、安装requirements依赖文件 注释requirements.txt文件中的torch&gt;=1.7，使用#号注释
然后安装依赖库
pip install -U pip &amp;&amp; pip3 install -r requirements.txt 根据显卡型号和python版本，选择对应版本的cuda和cudnn
并通过whl文件手动安装GPU或CPU版本的pytorch
3、克隆cocotools仓库(coco数据集评估工具库) pip install cython pip install 'git+https://github.com/cocodataset/cocoapi.git#subdirectory=PythonAPI' 可将cocoapi仓库转到gitee，再运行上述命令
pip install 'git+https://gitee.com/lishan666/cocoapi.git#subdirectory==PythonAPI' 4、安装visual studio 2019 选择c++开发安装即可
5、进入YOLOX目录，安装库文件 cd YOLOX python setup.py develop 6、安装apex(混合精度加速训练库) git clone https://github.com/NVIDIA/apex cd apex python setup.py install 7、下载YOLOX权重文件 在YOLOX下创建weights文件夹，并下载权重文件放到YOLOX/weights
（1）yolox_nano下载链接：
https://github.com/Megvii-BaseDetection/YOLOX/releases/download/0.1.1rc0/yolox_nano.pth
（2）yolox_tiny下载链接：
https://github.com/Megvii-BaseDetection/YOLOX/releases/download/0.1.1rc0/yolox_tiny.pth
（3）yolox_s下载链接：
https://github.com/Megvii-BaseDetection/YOLOX/releases/download/0.1.1rc0/yolox_s.pth
（4）yolox_m下载链接：
https://github.com/Megvii-BaseDetection/YOLOX/releases/download/0.1.1rc0/yolox_m.pth
（5）yolox_l下载链接：
https://github.com/Megvii-BaseDetection/YOLOX/releases/download/0.1.1rc0/yolox_l.pth
（6）yolox_x下载链接：
https://github.com/Megvii-BaseDetection/YOLOX/releases/download/0.1.1rc0/yolox_x.pth
（7）yolox_darknet53下载链接：
https://github.com/Megvii-BaseDetection/YOLOX/releases/download/0.1.1rc0/yolox_darknet.pth
8、演示模型 使用官方coco数据类别测试yolox的默认权重网络
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f331aae1025bd10931622fe2e71d0d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f1dbc5ff5747b1aff6f87236ea0275b/" rel="bookmark">
			基于java web的课堂考勤系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.系统简要概述
2.系统设计
2.1功能设计
2.2用例设计 2.3数据库设计
2.4数据表设计
3.系统相关页面
3.1登陆页面
3.3教师发布考勤
3.4查看考勤信息
3.5 教师补打卡
3.6学生考勤打卡
4.部分代码
1.系统简要概述 此系统是基于B/S架构开发，利用j2ee技术，开发出来的一套web系统。主要用到的技术有servlet、javabean、jsp、echarts、jquery、ajax等。系统采用mvc模式实现内部逻辑和页面的分离。总体来看，工作量适当。
2.系统设计 2.1功能设计 2.2用例设计 系统总体用例图 2.3数据库设计 2.4数据表设计 user
classes
kaoqin
3.系统相关页面 3.1登陆页面 3.2管理员首页
3.3教师发布考勤 3.4查看考勤信息 3.5 教师补打卡 3.6学生考勤打卡 4.部分代码 adminservlet
package servlet; import java.io.IOException; import java.io.PrintWriter; import java.util.List; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession; import dao.ComBean; import dao.Constant; import dao.DBA; /** *@author:gz *@version：2023年4月13日上午10:29:47 *类说明 */ @WebServlet("/AdminServlet") public class AdminServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // TODO 自动生成的方法存根 String method=request.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f1dbc5ff5747b1aff6f87236ea0275b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8f8e8a1dd934d37b30b297e42709876/" rel="bookmark">
			华为防火墙实验基础篇-1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		拓扑图 实验需求 0）部署接口与安全区域
连接PC1，web-manager的接口位于trust区域Server1位于DMZ区域，连接AR1的接口部署为untrust区域防火墙所有地址为.12 1）防火墙远程登录
部署SSH登录，实现通过公网能够登录防火墙部署防火墙实现通过本机web方式登录防火墙 2)防火墙网络服务
配置FW-1作为DHCP服务器，对PC1分配地址其中PC1的MAC地址为AABB-CC00-0001，总是获取10.1.12.10/24，DNS为150.1.1.10配置FW-1作为PPPoE客户端，AR1作为PPPoE服务端 3）防火墙安全策略与ASPF
保障防火墙发起的任何连接都不受限调整安全策略实现除PC1以外，其他10.1.12.0/24网段内主机只能通过HTTP或FTP访问DMZ主机采用地址组与服务组的方式实现全局关闭ASPF，在特定区域激活ASPF 4）防火墙地址转换
FW-1添加NAT地址池（155.1.121.11-155.1.121.20）部署NAPT实现内网10.1.12.0/24能够访问互联网 部署NAT-Server实现，公网用户Client1访问DMZ的服务器的FTP与HTTP服务其中映射地址为155.1.121.10 对于内网主机能够通过155.1.121.10，访问DMZ服务器安全策略精确到端口级 5）防火墙本地portal认证
对于PC1访问公网不受限对于win主机访问互联网，需要通过本地Portal认证登录账户（USER/huawei@123） 配置 0）部署接口与安全区域 连接PC1，web-manager的接口位于trust区域Server1位于DMZ区域，连接AR1的接口部署为untrust区域防火墙所有地址为.12 FW的G1/0/0接口绑定dialer，目前无需配置地址
sysname FW1 # interface GigabitEthernet0/0/0 ip address 120.1.1.12 255.255.255.0 service-manage https permit service-manage ping permit # interface GigabitEthernet1/0/1 undo shutdown ip address 10.1.12.12 255.255.255.0 # interface GigabitEthernet1/0/2 undo shutdown ip address 10.0.0.12 255.255.255.0 # firewall zone trust set priority 85 add interface GigabitEthernet0/0/0 add interface GigabitEthernet1/0/1 # firewall zone dmz set priority 50 add interface GigabitEthernet1/0/2 # 1）防火墙远程登录 部署SSH登录，实现通过公网能够登录防火墙部署防火墙实现通过本机web方式登录防火墙 注意：防火墙默认加密安全级别高较高，需要调整为aes128_cbc，不然无法成功ssh
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8f8e8a1dd934d37b30b297e42709876/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49daf5dae19dbffa1b5524d950bbbf46/" rel="bookmark">
			验证URL是否存在cloudflare障碍？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着互联网的普及和发展，网站安全和性能变得越来越重要。Cloudflare是一家著名的网络安全和性能公司，为网站提供广泛的网络服务和解决方案，以保护网站免受恶意攻击，并提供快速的内容分发网络（CDN）服务。本文将探讨如何验证URL是否存在Cloudflare障碍。
首先，我们需要了解什么是Cloudflare障碍。当一个网站使用Cloudflare作为其网络服务提供商时，Cloudflare会拦截和过滤访问该网站的流量。这是通过Cloudflare全球网络中的多个数据中心来实现的。然而，有时由于各种原因，访问某个网站可能会遇到Cloudflare障碍，导致无法正常访问。
下面是一些验证URL是否存在Cloudflare障碍的方法：
1.使用ping命令：在命令提示符（Windows）或终端（Mac和Linux）中，输入ping命令后加上目标URL。如果ping命令能够成功返回目标URL的IP地址，那么该URL可能没有Cloudflare障碍。但需要注意的是，即使ping命令能够返回IP地址，仍有可能存在其他障碍，因此这种方法并不绝对可靠。
2.使用在线工具：有一些在线工具可用于验证URL是否存在Cloudflare障碍。例如，你可以使用”DownForEveryoneOrJustMe”来检查某个网站是否受到Cloudflare保护。只需输入目标URL，该工具将告诉你该网站是否离线或仅对你不可用。
3.使用浏览器开发者工具：现代浏览器的开发者工具提供了有用的功能来检查网络请求和响应。打开浏览器的开发者工具（通常按下F12键），切换到”Network”（网络）选项卡。然后刷新页面并查看请求列表。如果你在列表中看到一个包含”cf-ray”标头的请求，那么该URL很可能受到Cloudflare保护。
4.使用命令行工具：如果你更喜欢使用命令行工具，可以尝试使用curl命令来验证URL是否存在Cloudflare障碍。在命令行中输入以下命令：curl-I&lt;URL&gt;。如果响应头中包含”Server:cloudflare”，那么该URL很可能受到Cloudflare保护。
5.使用穿云API，您可以轻松地绕过Cloudflare的机器人验证，即使您需要发送10万个请求，也不必担心被识别为抓取者。
一个穿云API即可突破所有反Anti-bot机器人检查，轻松绕过Cloudflare验证、CAPTCHA验证，WAF，CC防护，并提供了HTTPAPI和Proxy，包括接口地址、请求参数、返回处理；以及设置Referer，浏览器UA和headless状态等各浏览器指纹设备特征。
需要注意的是，Cloudflare可能会根据其客户的配置和策略对不同的URL实施不同的保护措施。因此，在验证URL是否存在Cloudflare障碍时，我们需要考虑以下几个因素：
1.Cloudflare的配置：Cloudflare的客户可以根据其需求配置不同的安全和性能策略。这意味着某些URL可能受到Cloudflare保护，而另一些URL可能不受保护。因此，在验证URL是否存在Cloudflare障碍时，我们需要明确检查的是特定URL还是整个网站。
2.DNS解析：Cloudflare的服务通常与目标网站的域名系统（DNS）解析紧密相关。在验证URL时，我们需要确保DNS解析将流量正确地转发到Cloudflare网络，以使其能够提供保护。可以通过使用常见的DNS工具（如nslookup或dig）来检查URL的DNS记录是否指向Cloudflare的服务器。
3.反爬虫策略：为了保护网站免受恶意爬虫和机器人的攻击，可能会实施Cloudflare反爬虫策略。这些策略可能在访问URL时引入额外的验证措施，如人机验证（CAPTCHA）。如果在验证URL时遇到人机验证或其他类似的障碍，那么这可能是由Cloudflare引入的。
综上所述，验证URL是否存在Cloudflare障碍是一个复杂的过程，涉及多个因素。上述提到的方法和工具可以帮助你初步判断URL是否受到Cloudflare保护或存在障碍。然而，由于Cloudflare的灵活性和客户定制化的配置，没有一种方法是绝对准确的。如果你需要确切确定URL是否存在Cloudflare障碍，最好联系网站的管理员或所有者，以获取更详细的信息和支持。
本文来源于：验证URL是否存在cloudflare障碍？ – 穿云API帮助教程 (cloudbypass.com)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c2341c4b2e1b1e196f0e4c4a6012d2c/" rel="bookmark">
			Linux磁盘分区扩容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		磁盘分区主要包含MBR（Master Boot Record）和GPT（GUID Partition Table）两种不同方式：
MBR（主引导记录），驱动器上的一个特殊的启动扇区，最大支持2TB，最多支持4个主分区，如果想要更多分区，需要先创建扩展分区，然后在扩展分区中创建逻辑分区。
GPT（GUID分区表），驱动器上的每个分区都有一个全局唯一的标识符（globally unique identifier，GUID），它对磁盘大小几乎没有限制，同时还支持几乎无限个分区数量，具有更强的健壮性与更大的兼容性，并且逐步取代MBR分区方式。
fdisk工具最大支持2TB磁盘，如果磁盘超过2T，需要使用parted工具。fdisk -l 可以查看磁盘的分区情况(只针对MBR分区，GPT的分区无法查看)。
以下以CentOS7.9为例，记录新磁盘挂载、扩容磁盘挂载到新目录、扩容磁盘扩容到根分区目录、扩容数据盘到已有分区目录等4种情况。
一、新磁盘挂载
新增数据盘/dev/sdb，大小为30T，挂载到/data目录。
1、查看分区情况
#lsblk 2、创建分区
使用parted命令完成分区创建。
#parted /dev/sdb 2.1、分区转换
创建gpt分区（格式化），输入命令:
#mklabel gpt 如果磁盘容量小于2T，可以使用MBR分区，输入命令:
#mklabel msdos 2.2、创建分区
此处创建一个分区，输入命令：
mkpart primary 1 -1 其他输入方式如百分比、容量等：
输入:mkpart primary 0 50GiB
输入:mkpart primary 0% 100%
或者划分多个分区：
输入:mkpart primary 0% 20%
输入:mkpart logic 20% 100%
2.3、查看分区
输入:print
2.4、退出parted
输入:quit
具体过程如下所： 3、格式化磁盘
ext4类型磁盘格式化：
mkfs.ext4 /dev/sdb1 xfs类型磁盘格式化：
mkfs.xfs /dev/sdb1 4、挂载磁盘
4.1、临时挂载：
#mkdir /data #mount /dev/sdb1 /data 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c2341c4b2e1b1e196f0e4c4a6012d2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/128263910519346473ed942f90215dc7/" rel="bookmark">
			Java面试题：GC垃圾回收机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 什么是GC垃圾回收常见的垃圾回收算法1、标记-清除算法2、标记-复制算法3、标记-整理算法4、分代收集算法 如何判断一个对象是否可以回收Java对象的引用类型年轻代、老年代和永久代JVM中对象在堆中的生命周期 什么是GC垃圾回收 GC垃圾回收(Garbage Collection的简称)：当需要分配的内存空间不再使用的时候，JVM将调用垃圾回收机制来回收不再使用的内存空间。系统级线程跟踪存储空间的分配情况。并在JVM的空闲时，检查并释放那些可被释放的存储空间。
在程序运行中会不断地创建很多的对象，这些对象数据会占用系统内存，如果得不到有效的管理，内存的占用会越来越多，甚至会出现内存溢出的情况，所以需要对内存进行合理地释放，这个时候就要用到GC垃圾回收机制。
常见的垃圾回收算法 1、标记-清除算法 分为两个阶段：标记阶段和清除阶段
标记阶段：首先标记出所有需要回收的对象。
清除阶段：统一回收所有被标记的对象。
缺点：标记和清除过程效率都不高，会产生大量不连续的内存碎片，导致无法给大对象分配内存。
2、标记-复制算法 分为两个阶段：标记阶段和复制阶段
标记阶段：首先需要先标记出存活的对象。
复制阶段：把存活的对象都复制到一块新的空内存里去，最后将原来的内存空间清空。
复制算法是为了解决效率问题而出现的，将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。
缺点：内存缩小为了原来的一半，在对象存活率较高的场景下要进行大量的复制操作，效率很低。
3、标记-整理算法 分为三个阶段：标记阶段、整理阶段和清除阶段
标记阶段：首先需要先标记出存活的对象。
整理阶段：将所有的存活对象压缩到内存的一端。
清除阶段：把存活边界外的内存空间都清除一遍。
让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。
4、分代收集算法 存活率低：少量对象存活，适合标记-复制算法：在新生代中，每次GC时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成GC。
存活率高：大量对象存活，适合用标记-清理和标记-整理算法：在老年代中，因为对象存活率高、没有额外空间对他进行分配担保，就必须使用标记-清理/标记-整理算法进行GC。
现代商用虚拟机基本都采用分代收集算法来进行垃圾回收。这种算法只是将上面内容结合起来使用而已，根据对象的生命周期的不同将内存划分为几块，然后根据各块的特点采用最适当的收集算法。大批对象死去、少量对象存活的（新生代），使用复制算法，复制成本低；对象存活率高、没有额外空间进行分配担保的（老年代），采用标记-清理算法或者标记-整理算法。
如何判断一个对象是否可以回收 引用计数算法 给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。
两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。
正因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。
可达性分析算法 通过 GC Roots 作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收。
Java 虚拟机使用该算法来判断对象是否可被回收，在 Java 中 GC Roots 一般包含以下内容：
虚拟机栈中引用的对象本地方法栈中引用的对象方法区中的常量引用的对象方法区中类静态属性引用的对象 Java对象的引用类型 Java 具有强、软、弱、虚四种强度不同的引用类型。
强引用 被强引用关联的对象不会被回收。
使用 new 一个新对象的方式来创建强引用。
Object obj = new Object(); 软引用 被软引用关联的对象只有在内存不够的情况下才会被回收。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/128263910519346473ed942f90215dc7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/faf66cbc00281bd0f510b463775e3898/" rel="bookmark">
			Linux输入输出重定向
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Linux输入输出重定向
Linux中的默认设备
输入输出重定向定义
输入输出重定向操作符
实用形式
标准输入、标准输出、标准错误
输出重定向案例
案例1 --- 输出重定向（覆盖）
案例2 --- 输出重定向（追加）
案例3 --- 错误输出重定向
案例4 --- 正确和错误都输入到相同位置
案例5 --- 正确和错误都输入到相同位置
案例6 --- 重定向到空设备/dev/null
输入重定向案例
案例1
案例2
案例3
使用文件描述符重定向
重定向组合使用
特殊应用
Linux输入输出重定向 Linux中的默认设备 默认的输入设备（标准输入） --- 键盘
默认的输出设备（标准输出） --- 屏幕
输入输出重定向定义 利用重定向操作符可以重新定义命令涉及的默认的输入和输出设备对象,即重定向操作符可以将命令输入和输出数据流从默认设备重定向到其他位置
输入输出重定向操作符 “&gt;”、“&gt;&gt;”称为输出重定向操作符
“&lt;”、 “&lt;&lt;” 称为输入重定向操作符 注意：
重定向操作符本省不是一条命令，而是命令中附加的可改变命令的输入和输出对象的特殊符号
实用形式 使用形式 功能 命令 &gt; 文件或者：命令 1&gt; 文件 将命令执行后的输出信息不在默认的屏幕上显示 , 而是以覆盖的方式写入到指定文件中, 若指定的文件不存在 , 则自动创建该文件 命令 2&gt; 文件 将命令执行后所产生的错误信息不在默认的屏幕上显示 , 而是以覆盖的方式写入到指定文件中, 若指定的文件不存在 , 则自动创建该文件 命令 &amp;&gt; 文件 将命令执行后的输出信息和错误信息不在默认的屏幕上显示 , 而是以覆盖的方式写入到指定文件中, 若指定的文件不存在 , 则自动创建该文件 命令 2&gt;/dev/null 将命令执行后所产生的错误信息不在默认的屏幕上显示 , 而是写入到空设备文件中, 即将输出的错误信息丢弃掉 命令 &gt;&gt; 文件 将命令执行后的输出信息以追加的方式写入到指定的文件中 命令 &lt; 文件 使命令从指定的文件中读取输入数据 命令 &lt;&lt; 结束标识字符串 读取命令行输入 , 直到遇到输入行为指定的结束标识字符串 标准输入、标准输出、标准错误 输出重定向案例 案例1 --- 输出重定向（覆盖） [root@localhost test]# date 1&gt; date.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/faf66cbc00281bd0f510b463775e3898/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbcb246d99970fff6e239f6c3fc2db6e/" rel="bookmark">
			百度支付管理后台操作指引说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开通完支付账户后，在“小程序开发者平台 - 运营中心 - 支付管理”中，进行支付相关的业务操作。支付管理包含了支付设置、订单管理、财务管理。
支付管理权限说明 开通支付能力： 只有超级管理员才能开通支付能力。
支付管理（订单、财务管理）：超级管理员、管理员。
支付设置 支付设置中可查看该小程序已绑定支付服务的开发信息、支付服务提现信息、开发配置。
开发者信息 支付开通之后，平台分配的用于支付开发的核心参数：dealid、平台公钥、APP KEY、APP ID。
注意：区分于小程序开发者 ID 中的 App ID（智能小程序 ID）、App Key。
开发者须知：若开发者有更换支付服务、或新建支付服务的需求，可从此入口解绑支付服务，新增或者选择其他支付服务完成绑定。
支付服务信息 展示开发者在入驻时填写的银行卡和财务设置。审核通过后，开发者仅可修改服务名称、服务电话、打款预留（元）、每日退款上限（元）。
开发者须知：开发者仅可修改服务名称、服务电话、打款预留（元）、每日退款上限（元）。
开发者设置 支持开发者修改申请时填写的开发者公钥、支付 / 退款 / 退款审核回调地址。
开发者须知：修改后支付服务重新进入审核，审核通过后，支付服务才能正常使用。为避免影响支付功能正常，开发者谨慎修改。
注：开发者公钥是平台用于验签使用的公钥，需要开发者在开通支付账号时填写；平台公钥是开发者用于验签使用的公钥，在支付账号审核通过后分配，一经分配不会发生更改。
订单管理 为开发者提供该支付服务下产生的订单查询、订单退款等管理功能，开发者可通过该页面查询到该支付服务的交易流水。
点击“管理-功能管理-支付管理-订单管理“，进入如下页面：
选择筛选条件之后，点击“查询”可按条件查看对应的订单明细。
订单状态 待付款、已付款、已消费、退款中、已退款、退款失败、已取消。
订单明细解读 商品名称平台订单号第三方订单号订单创建时间订单最新状态支付金额（+元）已退款金额（-元）支付渠道开源联盟 APP开发者的商品名称百度收银台订单 ID开发者业务下的唯一订单号用户在收银台页面上发起支付的时间当前订单的最新状态，订单状态枚举值见上面订单的支付金额若该笔订单发起退款后，在此显示退款金额用户支付时选用的支付渠道，如：微信 / 支付宝 / 度小满 / 百度闪付等用户下单时的小程序宿主场景，分为百度 APP 和其他宿主，其他宿主汇总了非百度 APP 的所有其他场景 订单导出 点击订单管理 - 导出记录，所展示的列表中为平台每日为开发者所自动导出的对应支付服务的交易流水信息，开发者可通过点击下载查看当日交易明细，开发者也可以通过下载历史交易清单。
财务管理 为开发者提供实时对账，报表产出和查看流水和收款、付款记录等功能，供商户核对订单、退款、银行到账等情况。
注意：仅订单状态为已核销的订单方可被结算，开发者需通过正确处理支付回调修改订单状态；如订单无法进行重试核销，须提供订单号交给客服&amp;商务同学进行反馈。
应用场景 1、支持开发者实时查看收入流水
2、支持开发者下载对账报表
3、支持开发者查看付款记录
企业资产 当前商户支付账号余额，即待打款的资金。
手动提现 若当前小程序的支付服务选择手动提现时，在企业资产模块，展示手动结算入口，需手动进行账户资金的结算。若选择自动提现时，隐藏结算入口，指定账期内的资金由系统自动完成结算，无需开发者手动操作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbcb246d99970fff6e239f6c3fc2db6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/050c977b551b13d5c93489de298273a9/" rel="bookmark">
			linux入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 简介文件目录目录结构账号管理进程管理关机文件权限目录管理文件操作练习文件管理网络管理：磁盘管理下载软件 简介 文件目录 目录结构 Bin：全称binary，含义是二进制。该目录中存储的都是一些二进制文件，文件都是可以被运行的
Dev：该目录主要存放的是外接设备，例如：U盘、光盘。其中的外接设备不能直接使用，需要先挂载。
Etc：该目录放一些配置文件
Home：存放除了root以外的其他用户的家目录
Root：该目录是root用户的家目录
Sbin：全程super binary，该目录存储一些可执行的二进制文件，但是必须要有super权限的用户才能执行
Tmp：表示“临时”的，当系统运行时候产生的临时文件会在这个目录存着。
Usr：存放用户自己安装的软件。类似于windows下的program file
Var：存放的程序/系统的日志文件的目录
Mnt：当外接设备需要挂载的时候，就需要挂载到mnt目录下。
账号管理 基本操作：
useradd [选项] 用户名 //创建用户 passwd [选项] 用户名 //用户口令 usermod 选项 用户名 //修改用户 userdel [选项] 用户名 //删除用户 用户组：
groupadd [选项] 用户组名 groupmod [选项] 用户组名 groups 用户名 //查询用户所属用户组名 groupdel 用户组名 gpasswd [选项] 组名//用于将一个用户添加或者从组中删除 选项： -a：向组GROUP中添加用户USER -d：从组GROUP中添加或删除用户 -h：显示此帮助信息并推出 -Q：要chroot进的目录 -r：remove the GROUP's password -R：向其成员限制访问组GROUP -M：向其成员限制访问组GROUP -A：设置组的管理员列表 显示当前登录用户：
切换用户：
查看用户信息：
提高普通用户的操作权限：
进程管理 top //实时监控进程的信息 top -c //实时显示所有的进程信息（显示完整命令） top -p PID//实时显示指定进程的信息 ps //显示当前正在运行的进程信息 ps -A//显示系统中所有的进程信息 ps -ef//显示系统中所有的进程信息（完整信息） ps -u 用户名//显示指定用户的进程信息 kill [-s &lt;信息名或编号&gt;][程序] 中断执行中的程序 kill [-l &lt;信息编号&gt;] -l &lt;信息编号&gt;：若不加信息编号选项，则-l参数会列出全部的信息名称 直接加程序的PID或者PGID，也可以是工作编号 -u 用户名：杀死这个用户中所有进程 kill 进程PID //杀死指定进程 kill -9 进程PID //彻底杀死指定进程 kill -9 $(ps-ef|grep 用户名) //杀死指定用户的所有进程 killall -u 用户名 //杀死指定用户所有进程 关机 shutdown //不同的版本会有所差异 shutdown -h now //立马关机 shutdown +1 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/050c977b551b13d5c93489de298273a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec1504f05e39aa391eafa412b26cd674/" rel="bookmark">
			Linux CentOS 7 安装samba
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Samba简介
Samba是在Linux和UNIX系统上实现SMB协议的一个免费软件，由服务器及客户端程序构成。SMB（Server Messages Block，信息服务块）是一种在局域网上共享文件和打印机的一种通信协议，它为局域网内的不同计算机之间提供文件及打印机等资源的共享服务。SMB协议是客户机/服务器型协议，客户机通过该协议可以访问服务器上的共享文件系统、打印机及其他资源。通过设置“NetBIOS over TCP/IP”使得Samba不但能与局域网络主机分享资源，还能与全世界的电脑分享资源。
Samba安装与配置
安装samba
yum -y install samba samba-client 卸载samba软件包
yum remove samba 更新samba软件包
yum update samba 启动Samba应用
systemctl start smb nmb 查看Samba服务进程
[root@GateA home]# ps -ef | grep -E ‘smb|nmb’
root 80312 1 0 14:26 ? 00:00:00 /usr/sbin/smbd --foreground --no-process-group
root 80314 80312 0 14:26 ? 00:00:00 /usr/sbin/smbd --foreground --no-process-group
root 80315 80312 0 14:26 ? 00:00:00 /usr/sbin/smbd --foreground --no-process-group
root 80316 80312 0 14:26 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec1504f05e39aa391eafa412b26cd674/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81d0f7b8703e5c6b05dc2234043e7ba3/" rel="bookmark">
			记录一次vite代理不成功的奇葩问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 记录一次vite代理不成功的奇葩问题 vite代理配置如下：
server: { port: 8081, host: true, // open: true, proxy: { '/dev-api': { target: 'http://vue.xxx.com', changeOrigin: true, secure: false, rewrite: path =&gt; path.replace(/^\/dev-api/, "/prod-api") } } } 配置看起来好像没问题，正如你所想，确实没有问题
可不知怎么回事就是，代理配置没有任何问题，可是接口就是代理失败，研究了一下午各种搜索、各种测试，代理的监听器也加了，最后才发现了这个奇葩问题。
代理成功之前我浏览器访问地址是http://localhost:8081，咋一看也没有问题，可这个奇葩的问题就在这，通过localhost的方式访问就会一直代理不成功。当我使用http://127.0.0.1:8081/ IP地址访问时，代理起作用了。
搞了一下午原来是我的访问方式不对，太搞人了，做一个码农可真是永远都在填坑。印象中，之前用vue2+vue-cli似乎也出现过类似的问题，最后怎么解决的我也忘了。
vite用的是node-http-proxy，这个插件我不熟悉，可能是那个配置没配置好，花了一下午时间浪费在填这个坑上，也google了，似乎没发现类似问题，而且也没时间再去研究到底是啥问题了，工作进度得赶上才行啊。
最后，可有大神告知解答一下我的疑惑，究竟是我配置问题还是本来就有这个问题存在？ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea63de9c590fb5ff051982d928a95797/" rel="bookmark">
			用JAVA写的贪吃蛇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用JAVA写的贪吃蛇，Eclipse平台，2个类。内容入下：
class snake:
-----------------------
package tanchishe;
import java.awt.Color;
import java.awt.Graphics;
public class Snake {
private GamePanel panel = null;
int x = 0;
int y = 0;
public Snake(int x, int y, GamePanel panel) {
this.x = x;
this.y = y;
this.panel = panel;
}
// 画蛇身
void draw(Graphics g) {
g.setColor(new Color(255, 255, 255));
g.fillRect(x * 20, y * 20, 19, 19);
}
// 画食物
void drawfood(Graphics g) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea63de9c590fb5ff051982d928a95797/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/754a3636ebeff179c7bcad9a652561df/" rel="bookmark">
			System Java Compiler was not found in classpath
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		换过java jdk 版本之后，idea 运行发现这个问题，一开始认为是 没有设置 JAVA_HOME 后来设置注销重新打开 电脑也是没有用，
网上一片的说 改 Settings &gt; java compiler &gt; javac 改成 eclipse 要是这样有用的话，我就不写这篇博客了，我发想改 eclipsek可以用，但是好像只针对 java8 的 ，我这里还有一种选项可以供你们选择
另一种姿势：
step 1: 选好你要用的 jdk版本 files -- project structure 点击ok 就好了
原因： IDEA 会记住之前用的jdk 目录，当你使用的上一个版本的jdk 卸载删除之后，idea还是 有记录存在，会去找上个版本的javac 地址，这样就不好了呀，我们就不让他自己找，我指定你用啥，你就用啥，真 好，舒服了。。
over
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33ccc5fb5c6d10d968adae8c876cbc89/" rel="bookmark">
			@TableId(type = IdType.AUTO)不生效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、前期检查 注解√ @Data public class User { @TableId(type = IdType.AUTO) private Long id; //数据库设置的是BigInt private String name; private Integer age; private String email; private SexEnum sex; @TableLogic private int isDeleted; //逻辑删除 } 确保数据库设置了id自增 2、操作运行测试 @SpringBootTest public class MyBatisPlusEnumTest { @Autowired private UserMapper userMapper; @Test public void test(){ User user = new User(); user.setName("admin"); user.setAge(33); user.setSex(SexEnum.MALE); int result = userMapper.insert(user); System.out.println("result:"+result); } } 造成这个问题的原因可能是在我还没有设置@TableId注解之前运行的程序中插入过数据，由于程序默认的主键策略为ASSIGN_ID雪花算法，因此导致后面主键自增的值都在生成的该id的基础上进行自增+1。
补：type @Documented @Retention(RetentionPolicy.RUNTIME) @Target({ElementType.FIELD, ElementType.ANNOTATION_TYPE}) public @interface TableId { /** * 主键类型 * {@link IdType} */ IdType type() default IdType.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33ccc5fb5c6d10d968adae8c876cbc89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1af264661d71dbfccd9a24c01afd61e/" rel="bookmark">
			第五章 API 题库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、下列选项中，可以正确实现String初始化的是（） A、 String str = "abc";
B、 String str = ‘abc’;
C、 String str = abc;
D、 String str = 0;
答案： A
2、下面哪个方法可以实现获取字符在某个字符串中第一次出现的索引？（） A、 char charAt(int index)；
B、 int indexOf(int ch);
C、 int lastIndexOf(int ch);
D、 boolean endsWith(String suffix);
E、 ：B
F、 解析：A答案返回字符串中index位置上的字符
G、 案返回指定字符在此字符串中最后一次出现处的索引
答案： D
3、阅读下面的程序：
class StringDemo{
public static void main(String[] args){
String s1 = “a”;
String s2 = “b”;
show(s1,s2);
System.out.println(s1+s2);
}
public static void show(String s1,String s2){
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1af264661d71dbfccd9a24c01afd61e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/220cbfe9147ca04861e26f0eb9c4e1f1/" rel="bookmark">
			Linux命令之ifconfig
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.命令简介 用来查看、配置、启用或禁用网络接口的工具。可以用这个工具来临时性的配置网卡的IP地址、掩码、广播地址、网关等。
二.命令内容详解 第一行（显示网卡状态信息） eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 eth0网卡名称UP代表网卡开启状态BROADCAST代表主机支持广播RUNNING代表网卡设备已连接MULTICAST表示支持组播mtu 1500表示数据包最大传输单元 1500，单位是字节 第二行（显示网卡的网络信息） inet 10.10.100.220 netmask 255.255.255.0 broadcast 10.10.100.255 inet网卡的IP地址netmask子网掩码broadcast广播地址 第三行（ipv6地址） inet6 fe80::392a:fb67:ba9f:81be prefixlen 64 scopeid 0x20&lt;link&gt; 第四行 ether 00:50:56:af:7d:c3 txqueuelen 1000 (Ethernet) ether表示连接类型（以太网）00:50:56:af:7d:c3MAC地址txqueuelen 1000表示网卡传送队列长度 第五行 RX packets 383690 bytes 27273753 (26.0 MiB) RX packets接收到的总包数bytes接收到的总字节数 第六行 RX errors 0 dropped 0 overruns 0 frame 0 RX errors接收时，产生错误的数据包数dropped接收时，丢弃的数据包数overruns接收时，由于速度过快而丢失的数据包数frame接收时，发生frame（框架）错误而丢失的数据包数 第七行 TX packets 401383 bytes 5808218716 (5.4 GiB) TX packets发送的总包数bytes发送的总字节数 第八行 TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 TX errors发送时，产生错误的数据包数dropped发送时，丢失的数据包数overruns发送时，由于速度过快而丢失的数据包数collisions发送时，冲突信息包的数目 第二段 lo 是表示主机的回坏地址，IP地址固定为127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/220cbfe9147ca04861e26f0eb9c4e1f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98f91c610b4792732c23e36a3e27f2d7/" rel="bookmark">
			【Python基础知识】在VSCode中怎么配置Python开发环境？真的超简单！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：VS Code 里是不包括 Python 的，所以你首先得安装一个 Python。 1、终端运行 Python 安装完 python 之后，我们可以用任何一个文本编辑工具开始写 python 代码，然后在 cmd 中运行代码。 在 VS Code 中，在不安装任何插件的情况下，也可以运行 python 代码。 新建一个 test.py 文件，输入 print('Hello World!')。 点击 查看 -&gt; 终端（快捷键 Ctrl + `）打开终端，输入 python test.py 即可运行，跟在 cmd 中运行 python 代码是一样的。 2、安装 Python 插件 在不安装插件的情况下，点击 调试 -&gt; 启动调试（快捷键 F5）是没办法运行代码的。会让你选择环境，而你根本就没有环境可选。 在 VS Code 的应用商店（快捷键：Ctrl + Shift + X）里搜索 Python 插件，并安装。如下图： 按 Ctrl + Shift + P（或F1），在打开的输入框中输入 Python: Select Interpreter 搜索，选择 Python 解析器。 选择好解析器之后，我们就可以直接在 VS Code 里运行（快捷键 Ctrl + F5）或调试（快捷键 F5）Python 代码了。 3、查看、安装外部库 Python 最强大的就是外部库了，在 PyCharm 中，可以在 Settings 中查看、搜索、安装。那么在 VS Code 中如何安装呢？ 上文中提到，可以在终端直接运行 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98f91c610b4792732c23e36a3e27f2d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef312c5fc9c3caceea342c565f871253/" rel="bookmark">
			Flink on Yarn 任务迁移 on K8s
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		flink取消任务并保存savepoint flink cancel -s hdfs:///flink/flink-savepoints/20210326/11 【flink-job-id】 -yid 【application-id】 2.将sp下载到本地
3.上传sp到镜像中
4.flink任务命令行指定镜像中sp路径
-s = savepoint path
5.查看flinkUI是否从sp正常启动
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74c99a49f842e2b8cf5de09f2727cb44/" rel="bookmark">
			cascader 三级联动数据回显
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cascader 三级联动数据回显 el-cascader 级联选择器详解 在我们使用cascader 写三级联动的时候 往往会遇到需要回显 区域 这里我们以 element 示例
基本属性 v-model：绑定值
props：参数指定绑定数据的格式
clearable：清空选项
filterable：搜索功能
show-all-levels：示最后一级
checkStrictly：选中不是最后一级的节点
lazy： 动态下拉数据
以上是我们常用的几个属性想要了解更多可去官网
代码实现三级联动 以下我们简单的看三种场景的使用 1.使用props 指定绑定数据的格式
&lt;el-cascader v-model="value" :options="myOptions" :props="{label:'name',value:'id',children:'children' }"&gt;&lt;/el-cascader&gt; myOptions: [{ id: '1', name: '北京', children: [{ id: '2', name: '市辖区', }, { id: '3', name: '海淀区', }], }], 2.checkStrictly 开启后 我们想选中不是最后一级的节点 expandTrigger修改为hover
&lt;el-cascader v-model="value" :options="defaultOptions" :props="{ checkStrictly: 'true',expandTrigger: 'hover' }"&gt;&lt;/el-cascader&gt; 3.slot-scope=“{ data }” 自定义 渲染的内容和样式更改
自定义节点内容 &lt;el-cascader v-model="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74c99a49f842e2b8cf5de09f2727cb44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f79b2165fc580e8b4fd2a382429c25f6/" rel="bookmark">
			仿牛客网项目（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、社区首页1.1、功能分析1.2、功能实现1.3、功能测试 1、社区首页 1.1、功能分析 社区首页显示前10个帖子、支持内容分页、显示登录注册按钮。
1.2、功能实现 开发思路按照数据库-Dao-Service-Controller思路，首先新建数据库community，新建用户表user和帖子表discusspost；
前端页面展示采用thymeleaf模版引擎，实现将逻辑注入模板文件。具体sql文件和前端文件详见文章底部：源代码；
在community目录下创建entity包和dao包，entity包下编写User类和DiscussPost类，Page类用于控制页面分页显示。
@Data public class User { /**用户ID*/ private int id; /**用户名称*/ private String username; /**用户密码*/ private String password; /**密码加盐*/ private String salt; /**用户邮箱*/ private String email; /**用户类型*/ private int type; /**用户状态*/ private int status; /**激活码*/ private String activationCode; /**账号创建时间*/ private Date createTime; /**用户头像路径ß*/ private String headerUrl; @Override public String toString() { return "User{" + "id=" + id + ", username='" + username + '\'' + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f79b2165fc580e8b4fd2a382429c25f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1996546ffd95e20942cad82290951268/" rel="bookmark">
			C# .Net通过pythonnet调用python pyd文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发环境：windows， python310， dotnet 6.0
说明：python文件编译成pyd。
1.新建控制台应用程序
2.添加nuget包
3.C#调用代码
using Python.Runtime; Runtime.PythonDLL= @"D:\Programs\Python\Python310\python310.dll"; PythonEngine.Initialize(); using (Py.GIL()) { dynamic np = Py.Import("PythonTest"); var dd = np.cal("aa"); Console.ReadLine(); } 调试可以看到python脚本返回的代码。
注意：请将PythonDLL路径改为自己的python安装路径；PythonTest为编译好的pyd文件，请将该文件复制到控制台程序debug目录，或者复制到控制台程序里面，将其属性复制到输出目录改为始终复制。
4.附录python脚本
def cal(param): return f'this is from python program, and the parameter is {param}' ******************************************2022-10-13 更新*************************************************
对于简单的py文件上面的方法可以很容易执行，但是对于引用外部package，比如pandas, numpy等等，我们调用的时候会抛出异常 “未找到相应的模块”。仔细一想就会知道，我们只打包了单个py文件，它所依赖的package当然会找不到。下面就是来解决这个问题。
我所测试的环境python版本变成了python 3.8.10。
我们只需要将下面代码放在using(Py.GIL())之前就可以：
string pathToVirtualEnv = @"D:\Programs\Python\Python3.8.10"; Environment.SetEnvironmentVariable("PATH", pathToVirtualEnv, EnvironmentVariableTarget.Process); Environment.SetEnvironmentVariable("PYTHONHOME", pathToVirtualEnv, EnvironmentVariableTarget.Process); Environment.SetEnvironmentVariable("PYTHONPATH", $"{pathToVirtualEnv}\\Lib\\site-packages;{pathToVirtualEnv}\\Lib", EnvironmentVariableTarget.Process); Runtime.PythonDLL= @"D:\Programs\Python\Python3.8.10\python38.dll"; PythonEngine.PythonHome = pathToVirtualEnv; PythonEngine.PythonPath = PythonEngine.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1996546ffd95e20942cad82290951268/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5eee07cb48be49e3e71eea07e158b7b6/" rel="bookmark">
			I/O 端口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述
I/O 端口的主要功能特性：
⚫ GPIO 引脚最高耐5.5V 电压
⚫ GPIO 数字输入具有施密特特性
⚫ 部分GPIO 输入支持模拟滤波
⚫ 部分GPIO 输入支持数字滤波
⚫ GPIO 可配置为上拉、开漏输出
⚫ 低功耗模式下保持状态
PAD 结构
GPIO，输入输出使能，可控上拉电阻，可控开漏输出
FCR=00时
如果寄存器的 PUEN=0/1 ，则 PAD 上拉使能控制线为对应的 0/1;
如果寄存器 INEN=0/1 ，则 PAD 输入使能控制线为对应的 0/1
PAD 的输出使能控制线始终为 0
寄存器 DATA/ODEN 功能无关；
FCR=01时
如果寄存器 PUEN=0/1 ，则 PAD 上拉使能控制 线为对应的 0/1;
如果寄存器 ODEN=0 ，无论寄存器 DATA 是什么， PAD 输出使能控制线为 1
如果寄存器 ODEN=1 并且寄存器 DATA=0 ，则 PAD 输出使能控制线为 1
如果寄存器 ODEN=1 并且寄存器 DATA=1 ，则 PAD 输出使能控制线为 0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5eee07cb48be49e3e71eea07e158b7b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dd51b6d86b88a7570af8a6d431e59f7/" rel="bookmark">
			upper_bound和lower_bound
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		头文件:&lt;algorithm&gt;
功能:扩展版二分查找(upper_bound查找第一个大于给定数的元素地址，lower_bound查找第一个大于等于给定数的元素地址)
条件：数组必须有序
返回值：返回目标的地址，可以减去查找起始地址得到下标，查找失败返回查找范围长度，查找成功返回下标
基础使用
int nums[n]; //返回nums中第一个大于等于aim的元素地址，若不存在则返回nums[n+1]地址 第一个参数查找左边界地址(包括) 第二个参数查找右边界地址(不包括) 第三个参数aim查找元素 int *num = lower_bound(nums,nums+n,aim); //返回nums中第一个大于等于aim的元素下标 int pos = lower_bound(nums,nums+n,aim) - nums; upper_bound用法也是这样，只不过是返回大于aim的元素地址 int *num = upper_bound(nums,nums+n,aim); int pos = upper_bound(nums,nums+n,aim); vector容器也可以使用该方法 vector&lt;int&gt;nums; int pos = upper_bound(nums.begin(),nums.end(),aim) - nums.begin(); 注意点
1.使用lower_bound和upper_bound前必须保证数组有序，可以先使用sort排序。
2.在一般数组中(定义数组以及vector中)这两个函数的时间复杂度均为log(n)，但是在set等关联式容器中直接使用这两个函数的时间复杂度为O(n^2)，只有使用set等关联式容器中封装的upper_bound和lower_bound时间复杂度才可以达到O(log(n))。
set&lt;int&gt;s; s.lower_bound(3);//在集合s中查找第一个大于等于3的元素。注意 这里就不是元素地址了 进阶使用
1.查找第一个小于等于指定元素的元素下标
int nums[n]; //使用sort降序 sort(num,num+n,greater&lt;int&gt;()); //这里的greater&lt;int&gt;()含义指的是上一个元素比下一个元素大 //lower_bound 查找小于等于aim的元素下标 int pos = lower_bound(num,num+n,aim,greater&lt;int&gt;()) - num; 2.查找第一个小于指定元素的元素下标
int nums[n]; //使用sort降序 sort(num,num+n,greater&lt;int&gt;()); //这里的greater&lt;int&gt;()含义指的是上一个元素比下一个元素大 //upper_bound 查找小于等于aim的元素下标 int pos = upper_bound(num,num+n,aim,greater&lt;int&gt;()) - num; 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6dd51b6d86b88a7570af8a6d431e59f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2238dc8187ed388268d38b1fec65d7d3/" rel="bookmark">
			CSS动画库合集&#43;CSS动画效果演示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSS动画库合集+CSS动画效果演示 CSS3 可以创建动画，它可以取代许多网页动画图像、Flash 动画和 JavaScript 实现的效果。
要创建 CSS3 动画，你需要了解 @keyframes 规则。
@keyframes 规则是创建动画。
@keyframes 规则内指定一个 CSS 样式和动画将逐步从目前的样式更改为新的样式。
下面给大家介绍：常见CSS动画库合集+CSS动画效果演示：
一、animates.css
animate.css是来自dropbox的工程师Daniel Eden开发的一款CSS3的动画效果小类库。包含了60多款不同类型的CSS3动画，包括：晃动，闪动，各种淡出淡出效果，如果你想快速的整合各种CSS3动画特效的话，使用它即可方便的实现。
查看演示：
https://daneden.github.io/animate.css/
github地址：
https://github.com/daneden/animate.css
二、magic.css动画库
查看演示：
http://www.17sucai.com/pins/demoshow/10001
github地址：
https://github.com/miniMAC/magic
三、Effect.css
针对不同UI的CSS3动画和过渡效果集，包含了丰富的CSS3动画和过渡效果，包括：
Modal
overlay
button
list
listscroll
Caption
等等
查看演示：
http://www.gbtags.com/gb/linkviewer/3147.htm
https://www.kelianpay.com
https://www.pixivzhan.com
https://zhenlongtv.com
https://yuanshentv.com
四、hover.css
Hover.css是一套使用CSS3动画实现的Hover特效集锦，包含了：
2D变形
边框过渡效果
阴影过渡效果
页脚翻转效果
查看演示：
http://ianlunn.github.io/Hover/
github地址：
https://github.com/IanLunn/Hover
五、常用动画
/* animation */ .a-bounce,.a-flip,.a-flash,.a-shake,.a-swing,.a-wobble,.a-ring{-webkit-animation:1s ease;-moz-animation:1s ease;-ms-animation:1s ease;animation:1s ease;} .a-fadein,.a-fadeinT,.a-fadeinR,.a-fadeinB,.a-fadeinL,.a-bouncein,.a-bounceinT,.a-bounceinR,.a-bounceinB,.a-bounceinL,.a-rotatein,.a-rotateinLT,.a-rotateinLB,.a-rotateinRT,.a-rotateinRB,.a-flipin,.a-flipinX,.a-flipinY{-webkit-animation:1s ease-out backwards;-moz-animation:1s ease-out backwards;-ms-animation:1s ease-out backwards;animation:1s ease-out backwards;} .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2238dc8187ed388268d38b1fec65d7d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4223ff0c1c1c20a7d43a03a68b5d4f8/" rel="bookmark">
			室友打了一把王者，我就学会了Java创建线程的三种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java创建线程的三种方式 Java中创建线程的方式有以下三种：
继承Thread类实现run()方法实现Runable接口run()方法实现Callable接口call()方法 对于很多初学者来说，多线程的概念很抽象，不好理解，比如：
进程是操作系统分配资源的最小单位，一个进程可以包含多个线程。每个进程都有独立的代码和数据空间（程序上下文），并且通过进程间通信机制（IPC）进行通信。每个进程在内存中拥有独立的地址空间，一个进程崩溃或异常不会影响其他进程的正常运行。线程是一种轻量级的进程，也可称为执行路径。线程是进程内的一个实体，更确切的说，线程是CPU调度的最小单位。同一个进程内的多个线程共享代码和数据空间，每个线程还有自己的栈空间和寄存器上下文，并且可以通过共享内存或互斥量等方式与其他线程进行通信，因此线程之间的开销远低于进程。 很抽象，对不对？打个比喻，你在打一把王者：
进程可以比作是你开的这一把游戏
线程可以比作是你所选的英雄或者是游戏中的水晶野怪等之类的。
带着这个比喻来理解进程和线程的一些关系，一个进程可以有多个线程就叫多线程。是不是感觉非常好理解了？
❤1、线程在进程下进行
(单独的英雄角色、野怪、小兵肯定不能运行)
❤2、进程之间不会相互影响，主线程结束将会导致整个进程结束
(两把游戏之间不会有联系和影响。你的水晶被推掉，你这把游戏就结束了)
❤3、不同的进程数据很难共享
(两把游戏之间很难有联系，有联系的情况比如上把的敌人这把又匹配到了)
❤4、同进程下的不同线程之间数据很容易共享
(你开的那一把游戏，你可以看到每个玩家的状态——生死，也可以看到每个玩家的出装等等）
❤5、进程使用内存地址可以限定使用量
(开的房间模式，决定了你可以设置有多少人进，当房间满了后，其他人就进不去了，除非有人退出房间，其他人才能进)
具体实现 搞清楚上面这些概念之后，我们来看一下多线程创建的三种方式：
继承Thread类 public class MyThread extends Thread{ @Override public void run() { for (int i = 0; i &lt; 100; i++) { System.out.println(getName()+"补刀==》 "+ i); } } } 测试用例
public static void main(String[] args) { MyThread a = new MyThread(); MyThread b = new MyThread(); //给两个线程设置名字，调用的是父类Thread的方法 a.setName("张三"); b.setName("李四"); a.start(); b.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4223ff0c1c1c20a7d43a03a68b5d4f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45ad4be54bf9fc3a60d1af252d33ef8e/" rel="bookmark">
			基于 宝塔Linux &#43; vue3 &#43; pythonFlask &#43; mysql 完整项目方案运行总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一定要先用空白页面调试前后端接口环境！
一定要先用空白页面调试前后端接口环境！
一定要先用空白页面调试前后端接口环境！
重要的写在前面、因为我是在学习过程中徐徐渐进地部署的环境。本来是打算只vue的，结果想上传到云服务器让大家都看到，于是开始学搭建 阿里云 服务器；然后因为有点Linux的底子，就搭建的Linux的操作系统的环境；虽然是大多情况用的宝塔面板进行的项目上传，但是所有的Bug飘红，加起来也真够喝一壶了。
本文主要用来记录所有开发环境下的报错异常。供他人参考。具体的代码不做过多解释。
Vue 因为我一开始使用的是从 vite.config.js中配置路径，就像这样
server:{ proxy:{ "/regist":{ target:"http://127.0.0.1:5000/regist", changeOrigin:true, rewrite: (path) =&gt; path.replace(/^\/regist/, ''), }, "/checkLogin":{ target:"http://127.0.0.1:5000/checkLogin", changeOrigin:true, rewrite: (path) =&gt; path.replace(/^\/checkLogin/, ''), }, } }, 之后在前端页面这样调用：
const checkLogin = function () { let params = new URLSearchParams(); params.append("userName", userAccount); params.append("userPass", userPass); axios .post("/checkLogin", params, { headers: { "Content-Type": "application/x-www-form-urlencoded", }, }) .then((res) =&gt; { if (res.data.state == 0) { ElMessage({ message: res.data.message, type: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45ad4be54bf9fc3a60d1af252d33ef8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08771d9d64b70c98883ce1645efd2127/" rel="bookmark">
			Solved: STM32 core is locked up / STM32内核被锁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于STM32内核被锁的问题，网上普遍有两种方式解决。一是J-Link，另一种方式是ST-Link Utility。因为前人已经写的很详细了，故此选了两篇如下。（站在巨人的肩膀上）
Using J-Link / 使用J-Link ref: https://blog.csdn.net/qq_25186745/article/details/113697880
Using ST-Link Utility / 使用ST-Link Utility ref: https://blog.csdn.net/hxiaohai/article/details/78546431
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cb966166bf0634631bbb11b5a615b41/" rel="bookmark">
			linux网络配置命令(ifconfig)和网络任务管理命令(ip)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux网络配置命令(ifconfig) ifconfig 命令用来查看和配置网络设备。当网络环境发生改变时可通过此命令对网络进行相应的配置。 命令格式： ifconfig ［网络设备］ ［参数］ 命令选项： up : 启动指定网络设备/网卡 down : 关闭指定网络设备/网卡。该参数可以有效地阻止通过指定接口的 IP 信息流，如果想 永久地关闭一个接口，我们还需要从核心路由表中将该接口的路由信息全部删除。 arp : 设置指定网卡是否支持 ARP 协议。 -promisc : 设置是否支持网卡的 promiscuous 模式，如果选择此参数，网卡将接收网络中发给它所有的数据包 -a : 显示全部接口信息 -s : 显示摘要信息（类似于 netstat -i） add : 给指定网卡配置 IPv6 地址 del : 删除指定网卡的 IPv6 地址 tunel : 建立隧道 dstaddr : 设定一个远端地址，建立点对点通信 hw [网络类型] [硬件地址] ： 设置网络设备的类型和硬件地址 -broadcast [地址] : 为指定网卡设置广播协议 mtu [字节数] : 设置网卡的最大传输单元（bytes） netmask [子网掩码] : 设置网卡的子网掩码。掩码可以是有前缀 0x 的 32 位十六进制数，也可以是用点分开的 4 个十进制数。 -pointtopoint [地址] : 为网卡设置点对点通讯协议 multicast : 为网卡设置组播标志 address : 为网卡设置 IPv4 地址 txqueuelen [长度] : 为网卡设置传输列队的长度 实用示例 实例 1：显示网络设备信息（激活状态的） 命令：ifconfig 输出： 说明： ens33 网卡名字 mut 网卡的最大传输单元 inet 网卡的 ip 地址 netmmask 子网掩码 broadcast 广播地址 inet6 ipv6 的 ip 地址 ether 物理地址(MAC 地址) txqueuelen 传输缓区长度大小 RX 接收数据包的统计情况 TX 发送数据包的统计情况 lo 是表示主机的回环地址，这个一般是用来测试一个网络程序，但又不想让局域网或外网用 户能够查看，只能在此台主机上运行和查看所用的网络接口。比如把 HTTPD 服务器的指定到回 坏地址，在浏览器输入 127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1cb966166bf0634631bbb11b5a615b41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56ab19a0a32d1435e86306e5a17481c6/" rel="bookmark">
			React项目文件中-index.ts的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小白的疑问 如果项目中文件夹有index.ts, A.tsx,B.tsx,
A文件:export const TestA
A文件:export const TestB
那么index文件应该怎么写?
身为自学的小白,产生了疑问.
写法介绍 在这个场景下,index.tsx 文件应该作为 A.tsx 和 B.tsx 的入口文件,用于重新导出其导出的内容
例如,如果 A.tsx 中导出:
export const TestA = 'A'; B.tsx 中导出:
export const TestB = 'B'; 则 index.tsx 可以写成:
export { TestA } from './A'; export { TestB } from './B'; 这样就可以从 index.tsx 引入 TestA 和 TestB:
import { TestA, TestB } from './index'; 所以,index.tsx 的作用是方便用户更简洁地导入文件夹下的内容,而不需要直接导入每个文件。
类似的结构在 TypeScript、React 项目中很常见,例如:
- src/ - components/ - Button.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56ab19a0a32d1435e86306e5a17481c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/318b388ccca639264ea279e7a25e7e3b/" rel="bookmark">
			HTTPS加密流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		尹相辉 (yinxianghui66) - Gitee.com
文章目录 目录
文章目录
一、HTTPS
二、HTTPS加密过程
1.对称密钥
2.非对称密钥
3.中间人攻击
4.证书 一、HTTPS HTTPS可以理解为就是在HTTP上多加了一层加密层 在我们使用HTTP的时候往往都是明文传输 这就导致数据可能在传输过程中被篡改
HPPS就是为了保证数据传输的可靠性 在HTTP的基础上进行加密 进一步保证安全
二、HTTPS加密过程 1.对称密钥 对称密钥就是一个密钥key 可以对数据进行加密和解密 使用对称密钥对数据进行加密 传输给服务器 服务器再使用对称密钥解密拿到数据 这样可以一定程度上保证数据的安全 但是会有一些问题,我的服务器如何拿到这个密钥？ 还是需要网络传输 但是传输密钥也会被截获 所以就出现了非对称密钥来解决
2.非对称密钥 非对称密钥分为两个密钥 一个公钥（pub） 一个私钥（pri） 我们可以用任一方进行加密或者解密（但是一方加密时 只能用另一方解密） pub+ 明文-&gt;密文 pri+密文-&gt;明文 或者pri+明文 -&gt;密文 pub+密文-&gt;明文
这样我们就可以将私钥存储在服务器中 不进行网络传输（也就没有被篡改的风险） 客户端问服务器密钥是多少？ 服务器返回一个公钥 客户端拿到这个公钥 之后都按照这个公钥进行加密 传输加密的数据 服务器拿到加密数据就可以使用服务器的私钥进行解密 拿到数据 这样即使黑客截取到了加密的数据 因为没有这个公钥对应的私钥 就无法进行解密篡改数据
3.中间人攻击 但是非对称密钥也是有问题的 这么想 一开始是客户端问服务器公钥是多少？？ 此时黑客截取了这个消息 冒充服务器返回了一个黑客自己的公钥pub2 然后将原本的数据发给服务器 服务器返回服务器的公钥pub1（黑客截取下这个消息 不发送给客户端） 此时客户端收到的是黑客的pub2 他无法辨别对面是不是服务器 所以就只能使用pub2进行加密数据 发给服务器 此时黑客再次截取 此时的数据是pub2加密的 所以黑客可以使用pri2解析拿到数据 再伪装成客户端，使用pub1进行加密发给服务器 服务器收到了数据使用pri1正常进行解析 但是数据已经全部被黑客截取了。。。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/318b388ccca639264ea279e7a25e7e3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e4cd1f771a5f0eee8de04c6948ce4cd/" rel="bookmark">
			一个接口有多个实现类时，调用接口时，如何判定调用的哪个实现类？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在学习依赖注入的时候，碰到这个问题：当一个接口有多个实现类的时候，我们调用方法的时候，通常是调用接口，而不是直接调用实现类。这是因为接口用来定义申明，而实现类可以是多种变化的，所以通常我们在调用时写接口，而不是具体的实现类，可以降低代码的耦合性，提高重用度。
以下是遵循接口编程的一些好处：
1. 松耦合（Loose Coupling）：通过面向接口编程，调用方与实现方之间的依赖关系变得松散。调用方只需要知道接口的方法和约定，而不需要了解具体的实现细节。这样可以降低代码的耦合度，使系统更加灵活和可维护。
2. 可替换性（Replaceability）：使用接口编程可以实现组件的可替换性。如果一个接口有多个实现类，你可以在不修改调用方代码的情况下，轻松地切换不同的实现类。这种可替换性对于系统的扩展性和测试性都非常有价值。
3. 单一职责原则（Single Responsibility Principle）：接口可以将不同的功能和责任进行划分，每个实现类只需关注自己的具体实现。这样可以提高代码的可读性、可维护性和可测试性，使系统更加清晰和易于理解。
4. 接口抽象性（Interface Abstraction）：接口可以提供一种抽象层次，隐藏实现类的内部细节。这样可以将关注点集中在接口定义和使用上，而不需要关心具体的实现细节。这种抽象性有助于提高代码的可理解性和可复用性。
那么当一个接口有多个实现类时，我们怎么知道调用哪个实现类呢？以下是几种常见的示例，展示如何实现接口并调用具体的实现类： 1、显式实例化调用：直接通过接口类引用实现类的对象
interface MyInterface { void myMethod(); } class MyClass1 implements MyInterface { @Override public void myMethod() { System.out.println("MyClass1 implements MyInterface"); } } class MyClass2 implements MyInterface { @Override public void myMethod() { System.out.println("MyClass2 implements MyInterface"); } } public class Main { public static void main(String[] args) { MyInterface obj1 = new MyClass1(); obj1.myMethod(); // 输出："
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e4cd1f771a5f0eee8de04c6948ce4cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f846a0066d7f7017e6fd20936f55e90c/" rel="bookmark">
			axis = 0 &amp; axis = 1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于numpy二维数组[[1，2]，[3，4]]
np.sum([[0,1,2],[2,1,3]],axis=1)
0 1 2
2 1 3
结果就是：array（[3,6]）
对于二维数组axis=0是行，按axis=0求和就是保留行，列求和
axis=1是列，按axis=1求和是保留列，行求和
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5212c4b7a72b14304dcd01c987cbbfef/" rel="bookmark">
			Docker基本命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.启动类命令
2.镜像命令
3.commit命令
3.1镜像
3.2commit操作
4.容器数据卷
4.1读写规则
4.2继承
1.启动类命令 systemctl start dock 启动
systemctl stop dockerer 停止
systemctl restart docker 重启
systemctl status docker 查看状态
systemctl enable docker 开机启动
docker info 查看概要信息
docker --help 查看帮助文档
docker 具体命令 --help 具体指令
2.镜像命令 docker update --restart=always [容器id] 更新自动启动
docker update --restart=no [容器id] (默认退出不自动重启) docker images [选项] 列出本机所有镜像 选项 -a列出所有本地镜像（包含映像层）-q只显示镜像ID
docker search [OPTIONS] 镜像名字 网站 Docker Hub 选项--limit 只列出第几个镜像 ，默认25个
docker pull 镜像名字[:TAG] 默认最新版
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5212c4b7a72b14304dcd01c987cbbfef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b794c99b2ca8cedd09ab1680d6ea1255/" rel="bookmark">
			git修改历史提交(commit)信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、修改最近一次提交的commit信息 1.首先通过 git log 查看commit信息
2.使用指令：git commit --amend 进入命令模式（修改号commit信息保存后退出编辑模式）
3. git push --force 到远程仓库（注意：必须加上 --force 如果只使用 git push 会报错）
二、修改最近两个或者两次上的commit信息 1.首先通过 git log 查看commit信息
2.使用指令：git rebase -i HEAD~2（把对应的 pick 改成 e 或者 edit 后保存）
3.使用 git commit --amend 去修改具体的commit信息
4.用 git rebase --continue 完成
5.git push --force 到远程仓库（注意：必须加上 --force 如果只使用 git push 会报错）
6.去远程仓库查看提交记录
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e96ce462c365ba9b28f42902fba0729/" rel="bookmark">
			​​Linux开源存储漫谈（8）容器及容器存储
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		容器 2013年，dotCloud公司开源容器项目Docker，开启了容器时代。但早在2013年之前，容器相关技术就已然出现并趋于完善，GOOGLE公司的Process Container，后更名为cgroup，并于2007年加入Linux 2.6.24内核版本，2008年，出现第一个比较完善的容器技术，基于cgroup和Linux Namesapces实现的LXC。之后，陆续出现了一些容器的实现，如CoreOS的rkt，再如Redhat开源了更加安全的容器实现Podman，但时至今日，似乎docker仍然是容器的代名词
容器解决了什么问题
容器之前，应用程序的部署、运维管理总是基于进程的，直接面对宿主机的操作系统，程序的发布、部署、运维管理更是五花八门，如发布部署格式，包括rpm、deb、压缩包，还有像IIM（IBＭ Installation Manager）；运维管理采用supervisor、systemd服务、crontab等等，不一而足。标准化盛行的当代技术圈，必然会出现一种革命性的解决方案，一统发布、部署、运维管理的困境，docker和kubernetes便站在了浪潮之巅，docker解决了应用程序规范化发布、部署及沙盒的运行环境问题，kubernetes则解决分布式应用的容器集群编排及调度管理
容器技术框架
容器的技术框架如图：
应用层，指运行于容器的应用程序及辅助系统（监控、日志、安全等）；集群管理层，负责容器应用的调度、编排，如Google开源的容器集群管理系统Kubernetes，也是Google多年大规模容器管理技术 Borg的开源版本，主要功能包括，基于容器的应用部署调度、维护和滚动升级，负载均衡和服务发现、自动伸缩等；运行引擎层指常见的容器系统，包括docker、rkt、基于CRI-O的容器实现等等，负责启动、运行、管理容器实例；资源管理层的核心目标是对服务器操作系统的管理；服务器层就是物理机或虚拟机
2013年到现在的10年时间里，得益于容器技术的发展演进，以及CNCF推动下云原生技术生态的蓬勃发展，而Kubernetes更是一骑绝尘逐渐成为容器集群管理系统的事实标准，而围绕着容器和Kubernetes生态的发展起来的诸如容器网络、容器存储等技术相关创新层次不穷，相关技术规范也日臻完善，2017年12月，标准化容器接口规范（CSI）发布，CSI的主要目的是使存储提供商只需要编写一个插件，就能够适配大部分容器编排系统。
Kubernetes的存储插件是内置的，也就是说这些插件随Kubernetes核心部件一起发布。但是对于大多数插件开发者来说，跟随Kubernetes的发布流程是一件很痛苦的事情。Flex Volume Plugin通过向外部插件暴露基于exec的API的方式来解决存储插件同Kubernetes核心部件一起发布的问题，Flex Volume Plugin虽然避开了写入Kubernetes核心代码的风险，但是需要访问工作节点或Master节点的root文件系统。另外，Flex Volume Plugin也未能解决依赖问题，插件经常需要外部依赖，如mount或文件系统工具，而安装这些依赖需要root文件权限。另一个存储插件的开发方式是CSI，CSI允许插件完全独立于Kubernetes核心代码，只是规定了发布CSI插件的最低要求，用户使用标准的Kubernetes存储原语，包括物理卷、PVC、StorageClass，来进行容器化部署。
Docker
从2013年dotCloud开源Docker，到2019年Docker公司拆分，Docker和Docker公司的传奇故事如今已经称为过去，但是容器技术的发展和演变却从未停止，大多容器实现与Docker基于相同的技术原理（限于Linux OS）
Docker架构（摘自Docker官网）
1）Docker守护进程，docker daemon
docker daemon是docker常驻在后台的系统进程，负责监听来自docker client发送来的命令或API请求，当某个命令或API被调用时，这些调用或请求将会被封装成请求发送后台守护进程进行处理。后台守护进程管理各种Docker对象，包括镜像、容器、网络、卷等等
2）Docker客户端，docker client
Docker客户端，如docker命令，是docker用户与docker daemon进行交互的主要方式。当command窗口输入docker命令时，docker程序会将命令封装成消息发送给守护进程，守护进程根据消息的类型执行不同的操作 3）Docker仓库，docker registry
docker 仓库，存储docker镜像。docker客户端从docker仓库同步docker镜像同步到本地后备用
root@nvme:~# docker pull busybox Using default tag: latest latest: Pulling from library/busybox 325d69979d33: Pull complete Digest: sha256:560af6915bfc8d7630e50e212e08242d37b63bd5c1ccf9bd4acccf116e262d5b Status: Downloaded newer image for busybox:latest docker.io/library/busybox:latest root@nvme:~# docker images REPOSITORY TAG IMAGE ID CREATED SIZE busybox latest 8135583d97fe 4 days ago 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e96ce462c365ba9b28f42902fba0729/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ac1c407ac65e45a6679802bf5d74b9b/" rel="bookmark">
			关于人人swoole端口号问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.查看某个端口号
lsof -i:9501
杀死9501端口号的进程kill -9 PID
在终端连接某个端口
telnet 127.0.0.1 9501
或者 netcat 127.0.0.1 9501
查看端口状态 是否连接
netstat -an | grep 9505
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f3032abb279de74360cf6266a7e1549/" rel="bookmark">
			【Linux】find命令及相关用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 介绍示例1.（递归）查找当前目录下文件大小大于10M的文件？2.（递归）查找当前目录下一天内被修改过的文件？3.（递归）查找当前目录下文件大小大于10M的文件，并将其拷贝到当前target目录下?4.（递归）查找当前目录下文件名包含hello的文件？5.（递归）查找当前目录下所有.txt文件，并将结果输出到文件中? 介绍 Linux中的find命令用于在指定目录下查找文件或目录。它可以按照文件名、文件类型、文件大小、文件修改时间等条件进行匹配，并支持递归搜索。
find命令的基本语法如下：
find [搜索范围] [搜索条件] [操作] 搜索范围可以是当前目录（.）、某个目录（如/home/user/）或整个文件系统（如/）
搜索条件可以是文件名、文件类型、文件大小、文件修改时间等
操作则是对符合条件的文件进行的一些操作，如复制、移动、删除等。
下面是一些常用的find命令选项：
-name：按照文件名进行匹配。-type：按照文件类型进行匹配，如d表示目录，f表示普通文件等。-size：按照文件大小进行匹配，如+10M表示大于10M的文件，-10K表示小于等于10K的文件。-mtime：按照文件修改时间进行匹配，如-1表示修改时间在1天之内的文件，+1表示在一天之前被改过。-exec：对符合条件的文件执行指定操作，需要接操作命令参数。例如-exec mv {} /backup/ ;表示将符合条件的文件移动到/backup/目录下。 示例 1.（递归）查找当前目录下文件大小大于10M的文件？ find . -type f -size +10M 这将使用 find 命令在当前目录中查找所有文件，并输出文件名和文件大小。-type f 限制了查找的文件类型为普通文件，而 -size +10M 表示文件大小要大于 10MB。
2.（递归）查找当前目录下一天内被修改过的文件？ find . -type f -mtime -1 3.（递归）查找当前目录下文件大小大于10M的文件，并将其拷贝到当前target目录下? find . -type f -size +10M -exec cp {} ./target \ 解释：
find .：在当前目录及其子目录中查找文件。-type f：只匹配普通文件，不包括目录。-size +10M：匹配大小大于10M的文件。-exec cp {} ./target \;：对于每个匹配的文件，使用cp命令将其拷贝到当前目录下的target目录中。(-exec 选项用于执行指定的命令，{} 表示当前找到的文件名，\; 表示命令结束。) 4.（递归）查找当前目录下文件名包含hello的文件？ find . -name "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f3032abb279de74360cf6266a7e1549/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9c0581b5c1fecc6895091a9a66d9ebd/" rel="bookmark">
			Linux重启提示“A stop job is running for ...“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux系统重启提示 ：A stop job is running for Zabbix Server
解决办法 ： 1、删除所有.lck的文件 然后重启系统，就没有问题了。
扩展 2、CentOS系统（下面没有试过） 编辑:
/etc/systemd/system.conf
修改下面两个变量为：
DefaultTimeoutStartSec=10s
DefaultTimeoutStopSec=10s
执行：
systemctl daemon-reload
3、默认等待时间为90秒，修改：
/etc/systemd/system.conf
DefaultTimeoutStopSec
参考链接 ：
https://blog.51cto.com/13530586/2049767
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f13fdc68fae569ded503b5a68198ec34/" rel="bookmark">
			负反馈放大电路（附Multisim）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实验要求 1）实验前的准备工作；检查三极管、导线、电位器等；
2）调制+12V直流电压；
3）连接实验电路；
4）测量Q点，分别测量T1、T2各端点电压，完成表（静态工作点）； 5）在B端加入频率1kHz正弦波，调整幅值使A端电压Ui=1mV，测量Uo，完成表（电压放大倍数）；
6）将负反馈电路接入，再测量Uo，完成表（闭环电压放大倍数）； 二、仿真 Multisim电路（文末附下载链接）
三、 数据处理 1.电路为电压串联负反馈，Fuu=Re1/( Re1+Rf) =1/11。 根据实验测量数据，实操电路中的Auf与Fuu基本符合其理论关系。 3. Auf, Ro大幅度下降，Ri变大。引入负反馈后放大倍数，但却大大稳定了电路的放大倍数，而且在放大电路中，Ri越大，有利于信号输入，Ro越小，有利于增加带载能力，故有利于电路性能。
4.由于电路器件基本确定，其带宽增益积（P202）也随之确定近为一个常量，从仿真可以看出，负反馈电路引入之后，Au大大减小，故其带宽fBW会大大增大，通频带会相应增大，故引入该负反馈不仅稳定了电路，而且增大了电路的通频带，有利于需要宽频带放大电路的性能。
思考题 1. 负反馈优点：电路输出电压趋向于维持恒定,反馈网络对放大电路起自动调整作用，减小非线性失真，稳定其放大倍数。 缺点：大大降低了电路原有的放大倍数。
2. Re1是，Re2不是。 电路为电压串联负反馈，在交流通路中，Re2并没有负反馈给输入端。 Re1与输出端相连， 若Ui产生正微弱信号，U0也会产生正微弱信号后反馈到URe1，抬高了URe1的电位对URe1所在的回路中可写出电压减的等式 Multisim文件（仅供学习参考）
链接：https://pan.baidu.com/s/1KlLyAtwHDce5TRseXZmdIA?pwd=6666 提取码：6666
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ce2e062a18f05a83fa5b58087efc969/" rel="bookmark">
			【转】Qt4移植Qt5总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果想把Qt4.x上面开发的软件在Qt5上面正常运行，如果什么都不做的话估计会出现各做各样的错误，笔者也是经历过这种迷茫痛，后面才发现官方已有系统发文一一提及到诸多迁移会遇到的问题以及解决办法。附上官网地址，以供参考http://qt-project.org/wiki/Transition_from_Qt_4.x_to_Qt5
为了提高开发者的开发效率，我对这个文档大致做一个翻译，也算为大家提供中文版的解决方案吧，如有异议，请参考原文。
1. QtWidgets 是一个独立的模块
例如，编译出现如下错误
error: QMainWindow: No such file or directory
error: QToolButton: No such file or directory
error: QWidget: No such file or directory
解决方法：
在工程的 *.pro文件中添加下面内容：
QT += widgets
同时把头文件
#include &lt;QtGui&gt;
更改为
#include &lt;QtWidgets&gt;
这样代码就可以正常运行了，不过有时候需要添加更详细的头文件，例如
#include &lt;QtWidgets/QtoolButton&gt;
2.QtWebKitWidgets也是一个独立的模块
例如，编译的时候出现如下错误:
error: invalid use of incomplete type 'class QWebFrame'
error: forward declaration of 'class QWebFrame'
解决方法：
在工程的 *.pro 文件中添加：
QT += webkitwidgets
备注：当已经有QT += webkitwidgets ，就不需要添加 QT += widgets
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ce2e062a18f05a83fa5b58087efc969/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29355d646543b612bf807956e365cbf4/" rel="bookmark">
			现控报告-- 分析倒立摆系统稳定性、能控性及能观性分析，设计PID控制方案（附matlab）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
摘要
数学建模
1、 倒立摆系统简介 2、 直线倒立摆系统数学模型
系统传递函数模型 系统状态空间数学模型 系统分析
3、 直线一级倒立摆系统分析
（1）系统稳定性分析 （2）系统能控性和能观性分析
仿真
4、 直线倒立摆系统PID控制与仿真 （1）PID控制系统原理 （2）PID控制算法仿真
总结
参考文献
摘要 此次大作业主要通过建立直线一级倒立摆系统的动力学模型,推导该系统的运动方程,求出直线一级倒立摆系统传递函数模型及空间状态方程模型,并进一步对系统的稳定性、能控性及能观性进行分析,得出直线一级倒立摆系统是线性不稳定、完全能控、完全能观系统结论。利用PID控制器方法对系统进行双闭环Simulink仿真，得出常规双闭环PID控制方案和基于状态空间方程加PID控制方案均可以成功地控制直线一级倒立摆系统。
数学建模 1、 倒立摆系统简介 倒立摆是处于倒置不稳定状态、通过人为控制使其处于动态平衡的一种摆,是一个复杂的快速、非线性、多变量、强耦合、开环不稳定系统,是重心在上、支点在下控制问题的抽象[1]。倒立摆主要有两个方面的用途：
第一,作为一个非线性自然不稳定系统,倒立摆系统是进行控制理论教学及开展各种控制实验的理想实验平台。对倒立摆系统的研究能有效直观地反映控制中的许多典型问题如非线性问题、鲁棒性问题、镇定问题、随动问题以及跟踪问题等[6]。
第二,由于倒立摆系统具有高阶次、不稳定、多变量、非线性和强耦合等特性,其作为控制理论研究中的一个严格的控制对象,通过对倒立摆的控制,用来检验新的控制方法是否有较强的处理非线性和不稳定性问题的能力[2]。
对倒立摆的控制涉及到控制科学中处理非线性、高阶次、强耦合对象的关键技术,许多现代控制理论的研究人员一直将它视为研究对象，因而倒立摆被誉为“控制领域中的一颗明珠”。通过对倒立摆的研究不仅可以解决控制中的理论问题,还能将控制理论涉及的三个主要基础学科—力学、数学和电学进行有机的综合应用[3]。
2、 直线倒立摆系统数学模型 一级倒立摆小车系统如图1所示。系统由沿导轨运动的小车和通过转轴固定在小车上的摆杆组成。
1) 模型假设
a) 忽略空气阻力。
b) 将系统抽象成小车和匀质刚性杆组成的系统。
c) 忽略摆杆与支点之间等的各种次要摩擦阻力。
d) 皮带轮与传送带之间无滑动,传送带无伸长现象。
e) 摩擦力与相对速度角速度成正比。
2) 符号说明 3) 小车及摆杆的受力分析 其中，N--小车与摆杆相互作用力的水平方向的分量, P--小车与摆杆相互作用力的垂直方向的分量。 应用牛顿法建立直线一级倒立摆系统的动力学方程过程。根据小车水平方向所受的合力,可得如下方程
由方程组(9)知该系统是明显的非线性系统。为便于控制器的设计,需要将系统在工作点(𝜙=0)进行线性化处理。当摆杆与垂直向上方向之间的夹角𝜙 必与单位是弧度相比很小(即 𝜙≪1)时,则可以进行近似处理：𝑐𝑜𝑠𝜃=−1,𝑠𝑖𝑛𝜃=−𝜙,(𝑑𝜙/𝑑𝑡)^2=0。为了与控制理论的表达习惯相统一，用u表示被控对象的输入力F, 经线性化处理后系统的数学模型成为如下微分方程表达式：
系统传递函数模型 对方程组（10）进行拉普拉斯变换,得到如下方程组：
系统状态空间数学模型 由现代控制理论原理可知,控制系统的状态空间方程可写成如下形式：
式（13）中, u表示系统控制输入向量, x表示系统状态变量, y表示系统的输出向量, A表示系统的状态矩阵, B表示系统控制输入矩阵, C表示系统输出观测矩阵, D表示系统输入输出矩阵。 系统分析 3、 直线一级倒立摆系统分析 （1）系统稳定性分析 若系统由于受到扰动作用而偏离了原来的平衡状态,但扰动去除后,如果能恢复到原来的平衡状态,则称该系统是稳定的,否则该系统就是不稳定的。求解线性系统稳定性问题最简单的方法是求出该系统的所有极点,并观察是否含有实部大于零的极点（不稳定极点）。[4]如果有这样的极点,则系统是不稳定的,否则系统是稳定的。要得出传递函数描述的系统和状态方程描述的系统的所有极点,只需简单的调用函数MATLAB函数roots(den)或eig(A)即可,这样就可以由得出的极点位置直接判定系统的稳定性了[7]。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29355d646543b612bf807956e365cbf4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b410e3bfb379fa3eba1e506a0aed7a1/" rel="bookmark">
			Typora&#43;PicGo&#43;gitee实现markdown图床
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSDN上传图片（Typora+PicGo+gitee实现markdown图床） 因为csdn直接上传Typora的图片时，会出现外链图片转存失败，源站有放盗链机制，图片不会显示，至此为了解决这个问题我使用了typora+PicGo+gitee实现markdown编辑器的图床。具体步骤如下步骤所示：
1、安装node.js和配置typora node.js文件：https://nodejs.org/en/
typora文件：https://typoraio.cn/
验证node.js是否安装成功 2、安装[PicGo] 前提需安装Node
https://picgo.github.io/PicGo-Doc/zh/
3、gitee创建仓库 点击刚刚创建的仓库，点击”初始化readme文件“
之后即可在”管理“部分进行开源
生成仓库后，点击右上角的头像-&gt;设置-&gt;私人令牌-&gt;生成私人令牌-&gt;复制-&gt;确认
4、配置PicGo 安装gitee插件
repo：⽤户名/仓库名称 （这儿选择前面新建的仓库名就好）
brash：分⽀，这⾥写上mastertoken：填⼊码云的私⼈令牌path：路径，一般写这个img 标题 测试上传选择gitee 设置服务器 开启时间戳重命名 5、配置Typora 参考下图，注意：PicGo路径为安装路径 6、补充 之后你再基于Typora写markdown涉及到图片时，就会自动上传图片了。
当然，以前笔记中的图片也可以批量上传：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89dff7d44c837482202c9877df1f7a7e/" rel="bookmark">
			Redis的一些基本命令和使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis基本命令 一、连接Redis服务器二、操作数据基本操作高阶操作 三、统计key的 Redis是一个开源的内存数据结构存储系统，支持多种数据结构（如字符串、哈希、列表、集合、有序集合等），常用于缓存、消息队列、排行榜等场景。以下是Redis的基本命令和使用方法： 一、连接Redis服务器 可以使用redis-cli命令连接Redis服务器，如：
redis-cli -h host -p port -a password 其中，host为Redis服务器主机名或IP地址，port为Redis服务器端口号，password为Redis服务器密码（如果设置了的话）。
二、操作数据 基本操作 # 使用SET命令存储数据，如： SET key value # 其中，key为数据的键名，value为数据的值。 # 使用GET命令获取数据，如： GET key # 其中，key为数据的键名。 # 使用DEL命令删除数据，如： DEL key # 其中，key为数据的键名。包括以下后面的高阶命令，删除都是用这个 # 使用EXPIRE命令设置数据的过期时间，如： EXPIRE key seconds # 其中，key为数据的键名，seconds为数据的过期时间（单位为秒）。 # 使用EXISTS命令判断数据是否存在，如： EXISTS key # 其中，key为数据的键名。 示例：
127.0.0.1:6379&gt; set lzq lzqValue OK 127.0.0.1:6379&gt; get lzq "lzqValue" 127.0.0.1:6379&gt; get l (nil) 127.0.0.1:6379&gt; set x y OK 127.0.0.1:6379&gt; get x "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89dff7d44c837482202c9877df1f7a7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98cf1b42ebfd65fc6783d83c2592cff4/" rel="bookmark">
			Redis相关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Redis基本概念 一、Redis的持久化方式二、Redis的单机、主从、哨兵、集群Redis主从复制的原理 三、Redis分布式锁的实现四、缓存穿透 击穿 雪崩 一、Redis的持久化方式 1）RDB方式
2）AOF方式
二、Redis的单机、主从、哨兵、集群 单机的问题：只有一台Redis，Redis宕机的时候，服务就无法使用了(并且因为只有一台，吞吐量偏低，有效率问题；
主从的问题是：读写分离，减轻单台Redis的压力，但是当主Redis宕机的时候，需要手动选择同步Redis，也是不可用的；
哨兵的问题是：由哨兵监控主从Redis情况，主宕机，自动从从Redis选择一个做主，保证可用性，只有一台主用来写，如果并发写比较多的话，写的压力会很大，
集群模式：解决可用和吞吐量的问题，
Redis主从复制的原理 三、Redis分布式锁的实现 可不是用以下两个加锁的：
用的是set原子方法：
四、缓存穿透 击穿 雪崩 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87a8535ac8f45024de40a676d874daec/" rel="bookmark">
			基于STM32F103的HAL库手动配置FreeRTOS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 基于STM32F103的HAL库手动配置FreeRTOS 源码下载 FreeRTOS源码下载包括示例工程与内核工程。
示例工程：获取与开发环境相关的架构文件
内核工程：移植FreeRTOS的内核文件
示例工程Gitee地址
内核工程GirHub地址
STM32工程创建 使用STM32CubeMX创建新工程，注意基准时钟源使用除滴答时钟（SysTick）外的定时器担当。
原因：在FreeRTOS中滴答定时器被作为任务调度定时器。
FreeRTOS移植 1、源文件移植
将下载的内核工程目录下的所有C文件添加到工程中
2、头文件移植
将下载的内核工程目录中的include文件夹添加到工程中
3、环境文件移植
将下载的内核工程目录中的portable文件夹添加到工程中，其中保留Keil、MenMang、RVDS三个文件夹即可，Keil为使用的环境，MenMang为内存管理文件，RVDS为所使用的芯片架构
4、添加配置文件
在下载的示例工程中选择对应的芯片Demo，复制FreeRTOSConfig.h（配置头文件）到工程下
Keil工程配置 创建Groups并添加相应的资源文件
在FreeRTOSConfig.h文件中添加宏定义（用于顶替默认工程的相关中断），同时删除默认工程下的对应定义（stm32f1xx_it.c文件夹中）
编译后无报错无警告即可。
测试 测试示例：一个LED1S闪烁，另外一个0.5S闪烁
添加头文件：
#include "FreeRTOS.h" #include "task.h" 任务函数：
void VTask1(void *pvParameters) { while(1) { HAL_GPIO_TogglePin(LED1_GPIO_Port,LED1_Pin); HAL_Delay(1000); } } void VTask2(void *pvParameters) { while(1) { HAL_GPIO_TogglePin(LED2_GPIO_Port,LED2_Pin); HAL_Delay(500); } } 创建任务并执行：
xTaskCreate(VTask1,"LED1",128,NULL,1,NULL); xTaskCreate(VTask2,"LED2",128,NULL,1,NULL); vTaskStartScheduler(); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02f523681e77447b168128ab59da5292/" rel="bookmark">
			说说对k8s的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kubernetes（K8s）是一种开源的容器编排工具，它能够自动化应用的部署、伸缩和容错处理。Kubernetes还提供了一系列的基础设施组件，包括长期存储、网络和服务发现等功能，帮助用户快速地构建分布式应用服务。
Kubernetes的核心理念是以容器为中心，将应用打包成可移植的容器，并在集群上部署和管理它们。Kubernetes提供了一套完整的调度、管理和监控机制，使得开发者可以集中精力于应用开发，而不必担心底层基础设施的细节实现。
Kubernetes的优点包括：
可伸缩性：Kubernetes提供了灵活的水平自动伸缩机制，可以根据应用负载自动地增加或减少容器实例数量。
高可用性：Kubernetes通过自动重启容器、自动替换故障实例等机制，保证了应用的高可用性。
容错性：Kubernetes支持多副本部署模式，使得容器实例的故障不会影响应用的正常运行。
自动化管理：Kubernetes提供了一套完善的自动化管理机制，可以自动化地部署、扩容、升级、回滚等应用操作。
总之，Kubernetes是一种强大的容器编排工具，可以为用户提供高效、可靠、灵活、自动化的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23c9b872a2f1c723d92987af4c2d6129/" rel="bookmark">
			三秒教会你如何使用scrcpy手机无线投屏到电脑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 scrcpy 是一款免费开源的投屏软件，可以将安卓手机屏幕投放在 Windows、macOS、GNU/Linux 上，并可以直接使用鼠标在投屏窗口中进行交互和录制。此应用程序镜像通过 USB 或TCP/IP连接的 Android 设备（视频和音频），并允许使用计算机的键盘和鼠标控制设备。它不需要任何 根访问权限。它适用于Linux、Windows和macOS。
官方地址 https://github.com/Genymobile/scrcpy
USB投屏： 下载安装： https://github.com/Genymobile/scrcpy/releases/download/v2.0/scrcpy-win64-v2.0.zip 运行方式 置顶运行 scrcpy --always-on-top 多设备运行 scrcpy -s edcfa4 防止休眠运行 scrcpy -w 无线投屏： 将设备连接到与您的计算机相同的 Wi-Fi 获取您的设备 IP 地址（在设置 → 关于手机 → 状态中） adb shell ip route #查看ip 在您的设备上启用 adb over TCP/IP adb tcpip 5555 连接到您的设备：（假设你的ip是192.168.1.100） adb connect 192.168.1.100:5555 拔下您的设备 运行 scrcpy 切回ubs连接 adb usb ps:无线投屏性能相比USB略差，默认的 scrcpy 比特率为 8Mbps，这对于 Wi-Fi 连接来说可能太多了。可以指定比特率启动
-b：比特率
-m：窗口大小
scrcpy -b2M -m800 快捷方式 https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23c9b872a2f1c723d92987af4c2d6129/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1abaf18cbf055d93ff9bf19dae3b4d85/" rel="bookmark">
			【Java编程】面向对象程序设计--类与对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、如何定义类
二、成员变量与成员函数
2.1 函数是通过.运算符来调用某个对象的函数
2.2 在成员函数内部直接调用自己（this) 的成员变量和其他函数
2.3 对象初始化
三、对象交互
四、封装（访问属性）
五、包
六、类变量和类函数
6.1 类变量
6.2 类函数
一、如何定义类 与C语言明显的区别在于，Java类是“对客观世界的建模方法”。
一个类由两种东西组成：表示对象“有什么的成员变量“和表示对象“能做什么的成员函数“。
类定义了对象长什么样，对象则是按照类的定义所制造出来的实体，一个类可以创建很多对象，每个对象有自己的数据。
类的定义与实例化
对象变量是对象的管理者而非所有者，所以涉及到赋值、函数参数传递和比较都与普通变量有所不同。
二、成员变量与成员函数 在没有引入类之前，变量是跟着代码走的。代码写到哪儿，变量写在哪里，那么运行的时候变量就在那儿。
现在，写在类里的成员变量，只是一个声明，变量并不在那里，变量不在类里，变量在每一个对象里。
2.1 函数是通过.运算符来调用某个对象的函数 对象名称.方法() vm.insertMoney() 这次调用临时建立方法 insertMoney() 与 vm 之间的关系，让 insertMoney()方法内部的成员变量指的是 vm 的成员变量。
2.2 在成员函数内部直接调用自己（this) 的成员变量和其他函数 在函数中可以直接写成员变量的名字来访问成员变量，需要通过 this 来实现。如果调用其他函数不用加 this。 public class test { int price = 80; //price1 void setPrice(int price) { this.price = price; // 调用自己的成员变量 price，将传进去的100通过this.price赋给price1 System.out.println(price); } public static void main(String[] args) { test myTest001 = new test(); myTest001.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1abaf18cbf055d93ff9bf19dae3b4d85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbb4ecd581eb3908781f1ead951bc537/" rel="bookmark">
			betterScroll基本使用和封装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言
工具
一、betterScroll是什么？
二、使用步骤
1.引入库
2.功能实现
3.添加滚轮功能
三、回归业务
四、封装成组件
五、总结
前言 betterScroll的大多数使用在移动端浏览器上面，因为旧版移动端原生滑动过于生硬，而新版没有下拉缓冲，这样对于客户来说并不友好，而betterScroll不仅解决这些问题，还配套了不少插件使用。
工具 "@better-scroll/core": "^2.5.1", "@better-scroll/mouse-wheel": "^2.5.1", "@better-scroll/observe-dom": "^2.5.1", "vue": "^3.2.13", (个人觉得这个是非常重要的，因为我不知道你是什么时候阅读的这篇文章，技术有没有更新，因为版本不同，用法可能也不同了，我这篇文章也就不能帮助到你) 一、betterScroll是什么？ betterScroll，官网上是叫BetterScroll 2.0，我这里就不水字数了，官网链接呈上......
https://better-scroll.github.io/docs/zh-CN/guide/
（我是非常建议大家通过读官网文档进行学习的，第一次读可能不习惯，但慢慢来就好。当然，你都去读文档了还来我这里干啥？）
二、使用步骤 1.引入库 代码如下：（这个是npm的）
npm install @better-scroll/core --save 代码如下：(yarn下载，因为可能你网速很拉，就建议这个了...)
yarn add @better-scroll/core 2.功能实现 不急于立马封装，先试试能不能实现功能，再进行封装(代码还是得有颜色的才好看...)
这是最基本的用法，效果如下
从这里我们可以看到:
我们可以按住绿色部分上下拖动使用betterScroll内的代码中的BScroll构造函数需要传入wrapper元素对象整个结构分为两层，一个是content内容区，该区域是可以上下拖动的，另一个是wrapper，当然，wrapper可以加个overflow:hidden隐藏超出的绿色部分 目前只能拖动，不可以滚动(滚动需要下载额外插件，后文会说...) 效果如下:
慢慢接近预期效果了
那么问题来了，如果没有content这个元素，直接在wrapper内塞满多个div是不是也可以拖动呢?
代码如下所示:
&lt;template&gt; &lt;div class="wrapper"&gt; 我是wrapper &lt;div class="item"&gt; item &lt;/div&gt; &lt;div class="item"&gt; item &lt;/div&gt; &lt;div class="item"&gt; item &lt;/div&gt; &lt;div class="item"&gt; item &lt;/div&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbb4ecd581eb3908781f1ead951bc537/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6e5582bd378b051cf318a6a7244a513/" rel="bookmark">
			记一次 SpringBoot 中文乱码问题调查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现象 现象是请求中的中文保存到数据库后会乱码。乱码的字符并不是什么特殊字符。删除了乱码字符前面的字符后，乱码的地方会向后偏移。 调查过程 第一反应是数据库字段的字符集设置导致的，但修改成 utf8mb4 字符集后问题依旧。
通过本地调试发现，直接请求接口的字符串并没有乱码。
通过测试环境日志发现，Controller 接收到的参数中字符串已经乱码了。
测试环境和开发环境的区别是其请求是通过网关转发的。
调查网关后，发现其中有一个 Filter 曾对请求内容进行了转码处理。具体代码如下：
java复制代码import java.nio.charset.StandardCharsets; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty; import org.springframework.cloud.gateway.filter.GatewayFilterChain; import org.springframework.cloud.gateway.filter.GlobalFilter; import org.springframework.core.Ordered; import org.springframework.core.io.buffer.DataBuffer; import org.springframework.core.io.buffer.DataBufferUtils; import org.springframework.core.io.buffer.NettyDataBufferFactory; import org.springframework.http.HttpHeaders; import org.springframework.http.HttpMethod; import org.springframework.http.MediaType; import org.springframework.http.server.reactive.ServerHttpRequest; import org.springframework.http.server.reactive.ServerHttpRequestDecorator; import org.springframework.stereotype.Component; import org.springframework.web.server.ServerWebExchange; import io.netty.buffer.ByteBufAllocator; import reactor.core.publisher.Flux; import reactor.core.publisher.Mono; /** * 跨站脚本过滤器 */ @Component @ConditionalOnProperty(value = "security.xss.enabled", havingValue = "true") public class XssFilter implements GlobalFilter, Ordered { // 跨站脚本的 xss 配置，nacos自行添加 @Autowired private XssProperties xss; @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) { ServerHttpRequest request = exchange.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6e5582bd378b051cf318a6a7244a513/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44aab7464343864e288100139d5b4916/" rel="bookmark">
			Zabbix6.0 LTS CentOS7 LNMP离线编译安装脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Zabbix6.0 LTS 目前最新版Zabbix6.0.17离线包123盘下载在CentOS7 2009上测试通过省略设置清华软件源 及yum update -y 部分将package.tar.gz和本脚本放置在同一目录使用root用户运行本脚本离线编译安装脚本,数据库密码在脚本中定义修改 #!/bin/bash # 1. 在CentOS7 2009上测试通过 # 2. 省略设置清华软件源 及yum update -y 部分 # 3. 将package.tar.gz和本脚本放置在同一目录 # 4. 使用root用户运行本脚本, ############################ 定义变量 ############################ db_password=Your_Db_Password ############################ 定义变量 ############################ dir=$(pwd) echo 关闭selinux和firewalld防火墙 systemctl stop firewalld;systemctl disable firewalld;setenforce 0;sed -i '/^SELINUX=/cSELINUX=disabled' /etc/selinux/config echo 解压软件包... cd $dir tar zxvf package.tar.gz cd package/mysql echo 安装mysql... rpm -ivh mysql-community-* --force --nodeps mkdir -p /data/mysql chown mysql:mysql /data/mysql cat &gt; /etc/my.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44aab7464343864e288100139d5b4916/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eeeae4e5e01a7e8d66294920ef4aa28b/" rel="bookmark">
			Spring动态添加数据源（全自动）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、使用场景 1、现在网上所有写的动态数据源，都是假动态数据，都是预先知道要连接几个数据库，但这不满足具体真正需要动态添加连接数据库的需求；
2、在很多业务场景下，如项目默认连一个主数据库，服务启动后，因业务不停的变更，需要动态连接其它数据库处理数据，关键点是其它数据库，在服务启动前是不知道连接地址的，所以其它数据库的地址是无法预先配置在application.yml文件中
二、因项目需求，需要真正动态连接其它库处理数据 1、做之前，百度网上搜，都是假动态数据源，为实现上面的真正动态添加数据，也花了几天时间才集成起，废话不多说
三、准备工作 1、准备三个数据，db_main，db_add01，db_add02，其中db_main为项目起动，默认连的主数据库，为了下面测试方便，我在三个数据库中创建了不同的三张表sys_company、sys_role、sys_user，以表示查询的数据不同，数据来源于不同的数据库，截图如下
application.yml中配置主数据库接信息
server: port: 8085 spring: application: name: mydata datasource: username: root password: 123456 url: jdbc:mysql://192.168.137.202:3306/db_main?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=GMT%2B8 druid: initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 #配置监控属性： 在druid-starter的： com.alibaba.druid.spring.boot.autoconfigure.stat包下进行的逻辑配置 # WebStatFilter配置， stat-view-servlet: #配置DruidStatViewServlet的访问地址。后台监控页面的访问地址 url-pattern: /druid/* #禁用HTML页面上的“重置”功能，会把所有监控的数据全部清空，一般不使用 reset-enable: false #监控页面登录的用户名 login-username: admin #监控页面登录的密码 login-password: 123456 #白名单 allow: #黑名单 deny: 2、动态添加数据库核心代码
/** * 添加私有数据源 * @param dbName 数据库名 * @param url * @param username * @param password */ public void addDataSource(String dbName,String url,String username,String password){ if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eeeae4e5e01a7e8d66294920ef4aa28b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77fec07e08858c389076af3d531d5804/" rel="bookmark">
			torch.randn()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 torch.randn()中的四个数分别为：
size：输出张量的形状dtype：输出张量的数据类型device：输出张量所在的设备requires_grad：是否对输出张量进行求导 torch.rand():
torch.rand(*size,out=None)
随机生成一个形状为size的均匀分布Tensor
W=torch.normal(0,0.01,size=(num_inputs,num_outputs),requires_grad=True) b=torch.zeros(num_outputs,requires_grad=True) X=torch.tensor([[1.0,2.0,3.0],[4.0,5.0,6.0]]) print(X) tensor([[1., 2., 3.], [4., 5., 6.]]) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8de6aeb45f12457af88e260a0b13de5/" rel="bookmark">
			前端常用的富文本编辑组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Quill 官网所说：Quill是一个跨平台的功能强大的富文本编辑器。开发者可以通过简单的API来控制编辑器的内容；
个人使用后理解：配置复杂，使用灵活
使用参考
博客：vue二次封装quill富文本组件_quill-image-resize-module_木心操作的博客-CSDN博客
UEditor UEditor 是由百度「FEX前端研发团队」开发的所见即所得富文本web编辑器，具有轻量，可定制，注重用户体验等特点，开源基于MIT协议，允许自由使用和修改代码。
个人理解：功能亲民，历史悠久，ui界面有点传统
VUE封装版组件UEditor：vue-ueditor-wrap - Vue + UEditor + v-model双向绑定
使用参考
官方： UEditor Docs
mavon-editor mavon-editor 是一款基于 vue 的 markdown 编辑器，常用于发送公告、个人博客等等；
可以左边编辑，右边展示
使用参考
官方：mavonEditor|码文 在线markdown编辑器
博客1：【前端系列】- 富文本组件(mavon-editor)-阿里云开发者社区
博客2：mavon-editor的使用_阿乐今天敲代码没的博客-CSDN博客
tui-editor tui.editor 编辑器支持 markdown 与标准富文本内容的编辑器
使用参考：
官方：https://nhn.github.io/tui.editor/latest/tutorial-example01-editor-basic
博客：tui.editor | 后盾人
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35495d5ef27822aff0b5be2d0393c6b1/" rel="bookmark">
			IO进程笔记（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、IO知识
1.IO种类
2.系统调用
3.库函数
4.常见的标准IO和文件IO的函数接口
二、标准IO
1.FILE指针
2.man手册使用说明
3.fopen函数
4.fclose函数
5.内核中错误码的问题
5.2将错误码转换成错误信息的描述的函数
5.3 perror直接打印错误信息(重置错误码才可以用)
6.fgetc/fputc
7.fgets/fputs
8.标准IO的缓冲区
8.1 缓冲区的类型
8.2 缓冲区的大小
​编辑
8.3缓冲区刷新的时机
9.获取系统时间
获取实际时间
10.sprintf/snprintf
sprintf
snprintf
11.fread/fwrite
fread
fwrite
12.fseek/rewind/ftell
fseek
13.标准IO操作图片文件
三、文件IO
1.概念
2.文件操作
2.1open
2.2close
2.3read
2.4write
2.5lseek
2.目录操作
2.1stat
​编辑
2.2getpwuid和getgrgid
2.2opendir
2.3readdir
2.4closedir
四、库的制作
1.概念
2.静态库
2.1制作静态库
2.2静态库的使用
3.动态库
3.1制作动态库
3.2动态库的使用
一、IO知识 1.IO种类 标准IO：库函数
文件IO：系统调用
2.系统调用 概念：从用户空间到内核空间的过程(内核给用户留了接口，系统调用就是用户调用接口函数的过程，最后由内核把数据写到硬件中)
用户空间每个进程是独立的
内核空间每个进程是共享的(内核空间物理映射映射到同一块空间)
可移植性差，没缓冲区，效率低(由于没有缓冲区，写入一次数据就要进行一次系统调 用，频繁的系统调用是很浪费时间的)
因为每个系统都有自己的函数接口，函数接口不同，就会导致不同系统上的程序运行不了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35495d5ef27822aff0b5be2d0393c6b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50cc2f8e20fa6d57c722ba75869c2fb7/" rel="bookmark">
			c&#43;&#43; 错误集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Error error C2572:重定义默认参数E0167: 形参不兼容E0546 控制传输跳过的实例化c1128 节数超过对象文件格式限制：请使用/bigobj进行编译。LNK2005 已在.obj中定义静态成员变量 LNK2019 该符号被引用静态成员变量 无法打开.obj文件LNK1107: 文件无效或损坏：无法在0x2C8处读取LNK1104: 无法打开文件Qt windows.h 和 winsock2.h 重定义错误； vs解决方案 error C2572:重定义默认参数 此错误一般为：在函数声明和定义同时设置了默认值；
纠正：在定义时去掉默认值设置。
E0167: 形参不兼容 此错误一般为：在类内实现多线程，但线程函数未static定义；
纠正：static定义线程函数。
E0546 控制传输跳过的实例化 在case 后面接{}。
c1128 节数超过对象文件格式限制：请使用/bigobj进行编译。 属性-&gt;c/c+±&gt;命令行-&gt;其他选择-&gt;输入：/bigobj
LNK2005 已在.obj中定义 静态成员变量 原因：在.h文件中初始化了成员变量。
纠正：在.cpp中初始化成员变量。
LNK2019 该符号被引用 静态成员变量 原因：未初始化静态成员变量。
纠正：初始化静态成员变量。
无法打开.obj文件 链接库没输后缀.lib
LNK1107: 文件无效或损坏：无法在0x2C8处读取 附近依赖项把.lib写成了.dll。
LNK1104: 无法打开文件 文件被占用
Qt windows.h 和 winsock2.h 重定义错误； vs解决方案 c++ ---- 预处理器— WIN32_LEAN_AND_MEAN
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/354d9ab7afedc09eb2a5178fc343d122/" rel="bookmark">
			Webassembly embind C&#43;&#43;数据结构绑定
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.全局函数 #include &lt;emscripten/val.h&gt; #include &lt;emscripten/bind.h&gt; #include &lt;iostream&gt; void globalFunction(int i){ std::cout &lt;&lt; "global function call : " &lt;&lt; i &lt;&lt; std::endl; return; } EMSCRIPTEN_BINDINGS(Module){ emscripten::function("globalFunction",&amp;globalFunction); } 编译指令
emcc .\main.cpp --bind -s WASM=1 -s EXPORT_ES6 -o wasm.js 生成文件 wasm.js wasm.wasm
js调用方式
import WasmModule from "./wasm.js" WasmModule().then((Instance)=&gt;{ Instance.globalFunction(6); }) 输出结果：
global function call : 6 2.结构体 struct Point{ double x; double y; }; void globalFunction(const Point&amp; point){ std::cout &lt;&lt; "x : "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/354d9ab7afedc09eb2a5178fc343d122/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c327970faa6ea72b0e79d43f785cbba/" rel="bookmark">
			Python相关性分析代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进行相关性分析的代码主要涉及数据处理和统计分析。以下是使用 Python 进行相关性分析的一般步骤：
1.导入必要的库：
import pandas as pd import numpy as np import seaborn as sns import matplotlib.pyplot as plt 2.读取数据：将你的数据加载到 Pandas DataFrame 中。
data = pd.read_csv('your_data.csv') # 根据实际情况替换文件路径和名称 3.数据预处理：根据需要进行数据清洗和处理，例如处理缺失值或异常值。
data = data.dropna() # 删除包含缺失值的行 # 进行其他的数据清洗和预处理操作 4.计算相关性：使用 Pandas 的 corr() 函数计算相关性矩阵。
correlation_matrix = data.corr() 5.可视化相关性：使用 Seaborn 库的 heatmap() 函数可视化相关性矩阵。
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm') plt.show() 这将显示一个热力图，其中颜色的深浅表示相关性的强度，注释显示了相关系数的值。
此外，你还可以根据需要执行其他统计分析和可视化操作，例如使用 Matplotlib 绘制散点图或线性回归拟合线等。
请注意，以上代码仅为一般示例，并假设你已经具备了数据的前提知识和适当的数据集。你可能需要根据你的具体数据和分析目的进行适当的调整和定制。
当然，还有其他一些常见的相关性分析方法和技术，你可以根据你的需求选择适合的方法。以下是其中几个常用的方法：
1.计算相关系数：除了计算整个相关性矩阵，你还可以计算特定变量之间的相关系数，如 Pearson 相关系数、Spearman 相关系数和 Kendall 相关系数。
pearson_corr = data['column1'].corr(data['column2'], method='pearson') spearman_corr = data['column1'].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c327970faa6ea72b0e79d43f785cbba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19952c6d94a2587d0b01b56597b66163/" rel="bookmark">
			【ISO14229_UDS刷写】-3-$36诊断服务TransferData理论部分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总目录：（单击下方链接皆可跳转至专栏总目录）
《UDS/OBD诊断需求编辑工具》总目录https://blog.csdn.net/qfmzhu/article/details/123697014
目录
1 $0x36 TransferData诊断服务描述
2 0x36服务请求消息
2.1 0x36服务请求消息定义
2.2 0x36服务请求消息子功能参数$ Level（LEV_）定义
2.3 0x36服务请求消息数据参数定义
3 0x36服务肯定响应消息
3.1 0x36服务肯定响应消息定义
3.2 0x36服务肯定响应消息数据参数定义
4 0x36服务支持的否定响应代码（NRC_）
5 示例：0x36 TransferData服务消息流
结尾
优质博文推荐阅读（单击下方链接，即可跳转）：
点击返回「《Autosar从入门到精通-实战篇》总目录」
点击返回「《Autosar_BSW高阶配置》总目录」
点击返回《嵌入式硬件/软件开发刷写/烧录文件》专栏
TransferData（0x36） service传输数据服务
服务
SID
描述
TransferData
传输数据 0x36
client向server发送数据（download下载）或从server请求数据（upload上传）。
1 $0x36 TransferData诊断服务描述 TransferData服务被client用来从client向server（download下载）或从server向client（upload上传）传输数据。
数据传输方向由前面的RequestDownload或RequestUpload服务定义。如果client发起RequestDownload，要下载的数据将包括在TransferData请求消息的参数transferRequestParameter中。如果client发起了一个RequestUpload，要上传的数据就包括在TransferData响应消息中的参数transferResponseParameter中。
TransferData服务请求包括一个blockSequenceCounter，以便在多个TransferData请求序列中的TransferData服务失败时改进错误处理。当收到RequestDownload (0x34)或RequestUpload (0x35)请求消息时，server的blockSequenceCounter应被初始化为1。这意味着在RequestDownload (0x34)或RequestUpload (0x35)请求消息之后的第一个TransferData (0x36)请求消息以一个blockSequenceCounter为起点。
重要的是 - server和client应满足ISO 14229-1的7.5章节中规定的请求和响应信息行为。
2 0x36服务请求消息 2.1 0x36服务请求消息定义 表403 - 请求消息定义
A_Data byte
参数名称
Cvt
字节值
助记符
#1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19952c6d94a2587d0b01b56597b66163/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ae82eef2169638065eeb626eb32eb03/" rel="bookmark">
			BeyondCompare-4_对比文件_所有文件标红_实际内容无差异问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 实际问题 1：1、文件内容一致，标准模式，所有的文件都会标红，需要手动点击进去再退出，就会变黑显示有无差异。 实际问题 2：1、Beyond Compare能生成表格比较报告，有时候文件太多，一一记录效率太低，所以需要最好能生成表格报表之类。 实际问题 1： 1、文件内容一致，标准模式，所有的文件都会标红，需要手动点击进去再退出，就会变黑显示有无差异。 原因分析： 之所以标红显示是因为文件的时间戳不一样。Beyond Compare在启动的时候好像启用的是快速测试，默认的快速测试选项里只比较时间和大小之类的，并不是像想象中的进行的二进制比较。所以文件是不一样的。 解决办法： 步骤一 打开Beyond Compare，进入到文件夹比较会话界面，在“会话”菜单下选择“会话设置”，打开会话设置对话框，进入第二个“比较”选项卡。 步骤二 勾上“比较内容”-&gt;“二进制比较”，然后确认。 另外还有一定一定要注意!！！ 在窗口最下端有个下拉菜单，一定要选择“也更新会话默认值”，然后确认，这样的话下次启动会话再进行新的其他的比较，也能使用此次所用的比较选项了。就可以直接比较内容了。 如果不选择，等到下次比较文件，又得再重新点一遍。 实际问题 2： 1、Beyond Compare能生成表格比较报告，有时候文件太多，一一记录效率太低，所以需要最好能生成表格报表之类。 解决办法： 步骤一：打开Beyond Compare软件，选择表格比较会话，打开会话操作界面。单击“打开文件”按钮，选择需要比较的表格文件。 步骤二：单击表格比较菜单栏“会话”按钮，在展开的菜单中选择“表格比较报告”选项，打开表格比较报告窗口界面。 步骤三：您可以根据个人比较表格文件的需求，选择报告布局和报告选项的内容。在输出选项栏目中，您可以选择“打印机”选择，直接打印生成纸质表格比较报告。 步骤四：您可以单击界面右下角的“打印预览“按钮，查看比较报告的详细内容，也可以单击“页面设置”按钮，重新调整页面布局风格。 Beyond Compare表格比较报告允许您将比较信息保存供日后修改文件时参阅，无需重新运行软件即可查看报告，您可以选择连接打印机将比较报告打印出来，也可以保存为HTML或纯文本格式。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d286812859e2a8eb634f4f9ddb2dc957/" rel="bookmark">
			sqlite数据库通过网络通信的TCP框架进行交互的简单示例代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现的功能 创建一个名为"student.db"的数据库，通过网络通信的TCP框架，实现在客户端发出增(insert) 删(delete) 改(update) 查(query) 的请求，增删改查整个的操作是在服务器端实现的，在客户端发出增删改查的请求，在服务器端返回增删改查的结果给客户端，然后在客户端显示。
要求在以上网络编程，数据库的基础上加上并发的操作，完成单服务器对多个客户端的支持。
此代码只是在本地进行测试的代码，如有不同需求，更改所需的网络端口号和ip地址即可。
代码实现 服务端代码 server.c 为实现并发的操作，在服务端接收到客户端的连接请求后进行子进程的创建，创建子进程后在子进程中关闭监听套接字，只处理客户端的请求，父进程关闭客户端套接字，继续监听新的客户端连接请求。
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;sqlite3.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/socket.h&gt; #include &lt;netinet/in.h&gt; #include &lt;arpa/inet.h&gt; #define DATABASE "student.db" #define N 128 #define M 1024 #define PORT 8888 #define MAX_CLIENTS 10 //函数声明 int client_handle(int client_socket, sqlite3 *db); int do_insert(sqlite3 *db, char *request); int do_delete(sqlite3 *db, char *request); int do_update(sqlite3 *db, char *request); int do_query(sqlite3 *db, char *request, char *response_buffer); int callback(void *arg, int f_num, char **f_value, char **f_name); int do_query1(sqlite3 *db, char *request, char *response_buffer); int main(int argc, const char *argv[]) { int server_socket, client_socket; struct sockaddr_in server_address, client_address; socklen_t address_len = sizeof(client_address); sqlite3 *db; char *errmsg; //创建数据库连接 if (sqlite3_open(DATABASE, &amp;db) !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d286812859e2a8eb634f4f9ddb2dc957/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01411d64a287e8660e914ffb42810c59/" rel="bookmark">
			尝试用js和jQuery实现一个简单的商品购买系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、首先渲染出商品列表数据
通过拼接和循环就得到表格了
添加一点简单的css样式让表格看得过去
大概效果如图所示
这一步我们先获取当前点击的节点信息，然后通过js生成节点，再拼接到购物车表头下面
在做个判断，
先建立一个空数组，因为商品的编号是唯一的，所以点购买商品就判断一下数组里有没有商品的编号，有就value+1，否则就生成新的一行
通过some方法判断数组里的数有没有重复
加号和减号按钮绑定事件 因为是渲染生产的，所有我直接给按钮里绑定了
小计通过获取当前这一行的value和单价相乘，总价则获取所有的小计相加
通过数组做累加，每次改变都调用一次
这里通过正则和if判断一下就行，给输入框绑定事件
当然为了总价小计不出错报错时给value更改为1
删除按钮通过绑定事件来找到当前行在删除就行，再调用一下总价函数,还要记得清除数组里对应的数据
这样一个简单的商品购买系统就完成了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/488cd85febfda5c7cb6df6697981e103/" rel="bookmark">
			java基础之Json
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相互转换 字符串 ⇋ JSONObject // Json字符串 转 JSONObject String st = "{name:Tim,age:25,sex:male}"; JSONObject rowData = JSONObject.parseObject(st); // JSONObject 转 Json字符串 JSONObJect json = new JSONObJect(); String str = json.toString(); JSONObject ⇋ 实体类 //实体类 转 JSONObject JSONObject jsonObject = JSON.toJSON(xtDmbm); JSONObject jsonObject = JSONObject.parseObject(JSON.toJSONString(xtDmbm)); //JSONObject 转 实体类 XtDmbm xtDmbm = JSONObject.toJavaObject(jsonObject, XtDmbm.class); VehicleInfo vehicleInfo = JSON.toJavaObject(VehicleJSONObject, VehicleInfo.class); 实体类 ⇋ 字符串 // 实体类 转 json字符串 String jsonStr = JSON.toJSONString(person); // json字符串 转 实体类 // 方法1 Persion persion2 = JSON.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/488cd85febfda5c7cb6df6697981e103/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9943a32528fea8f808720e806ab261bd/" rel="bookmark">
			项目总结：YOLOv8 人体姿态估计 跌倒检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		细节贴：
YOLOv8 人体姿态估计 跌倒检测_爱钓鱼的歪猴的博客-CSDN博客
yolov8-pose的输出中有17个人体关键点
在胸膛处计算出一个中心点，腰部计算出一个中心点，连线，做一个直角三角形，求角的大小。
当角大于60度，或者胸膛中心点y坐标小于腰部中心点y坐标，或检测框宽高比大于5/3,则判定为跌倒
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/208dd9c5d82a7c88dece8eccbf4dcc50/" rel="bookmark">
			mysql&#43;MHA 主从复制 故障切换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL MHA
一、MHA概念 1、MHA 的组成
2、MHA 的特点
二、搭建MySQL+MHA 实验环境、安装包
1、所有服务器，关闭系统防火墙和安全机制
2、修改 master、Slave1、Slave2 节点的主机名
3、修改三台MySQL服务器的主配置文件/etc/my.cnf
4、配置MySQL一主两从
5、主从复制验证
6、安装 MHA 软件
7、在所有服务器上配置无密码认证
8、在 manager 节点上配置 MHA
9、故障模拟
10，故障修复
MySQL MHA 一、MHA概念 MHA（MasterHigh Availability）是一套优秀的MySQL高可用环境下故障切换和主从复制的软件。
MHA 的出现就是解决MySQL 单点的问题。
MySQL故障切换过程中，MHA能做到0-30秒内自动完成故障切换操作。
MHA能在故障切换的过程中最大程度上保证数据的一致性，以达到真正意义上的高可用。
1、MHA 的组成 ●MHA Node（数据节点） MHA Node 运行在每台 MySQL 服务器上。
●MHA Manager（管理节点） MHA Manager 可以单独部署在一台独立的机器上，管理多个 master-slave 集群；也可以部署在一台 slave 节点上。
MHA Manager 会定时探测集群中的 master 节点。当 master 出现故障时，它可以自动将最新数据的 slave 提升为新的 master， 然后将所有其他的 slave 重新指向新的 master。整个故障转移过程对应用程序完全透明。
2、MHA 的特点 ●自动故障切换过程中，MHA试图从宕机的主服务器上保存二进制日志，最大程度的保证数据不丢失
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/208dd9c5d82a7c88dece8eccbf4dcc50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac5c3b3f19bbc3069d2a5b2ec6f1cadb/" rel="bookmark">
			[RSA议题分析] eBPF Warfare - Detecting Kernel &amp; eBPF Rootkits with Tracee
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 简介议题分析基础知识用户空间与内核空间hookrootkit追踪技术 eBPF架构Tracee - 一个运行时安全检查工具 RootKit种类与各个阶段的攻防LD_PRELOAD RootKitKernel Module RooKitKernel RootKit HidingKernel RootKit Hooksyscall table hookingfile operations hooking Kernel RootKit CommunicationCommand ExecutioneBPF RootKiteBPF Programs LoadeBPF Probes PlacementHiding eBPF RootKiteBPF RootKit Communication Channel 总结 简介 eBPF在恶意活动检测方面仍是未知领域。随着威胁的不断出现，我们需要采取主动。参与者将了解到不同类型的rootkits，它们的攻击流程，它们的运作方式以及如何检测它们。最后，他们将学习如何使用Tracee，这是一个利用eBPF来检测这些威胁并在攻击者面前获得优势的开源工具。
本篇议题是由Aqua Security实验室的Asaf Eitani 和Idan Revivo两位研究员带来
议题分析 基础知识 讨论rootkit需要知道的基础知识
用户空间与内核空间 通过系统调用交互
hook 追踪rootkit可能用到的技术，不改变两段代码逻辑的前提下，在两段逻辑之间插入一段逻辑
rootkit追踪技术 选择追踪rootkit的手段之前，需要知道，他们需要具备如下特征
低开销，别影响性能隐蔽，不能被攻击者察觉难以逃避，攻击者无法反制我们完整的系统可见性，获取更多的信息以至于让我们确认现在安全安全，物理上的，别把系统搞崩 目前方法的优劣：
eBPF 架构 eBPF，全称为扩展伯克利包过滤器（Extended Berkeley Packet Filter），是一种在Linux内核中运行的轻量级虚拟机。eBPF的主要优点是它能够在不更改内核源代码或加载内核模块的情况下，动态地在内核中插入程序。这些程序可以用于收集性能数据、跟踪系统调用、监视网络流量等。eBPF程序通常使用C语言编写，然后通过LLVM编译器编译成BPF字节码，最后由内核的BPF虚拟机执行。
用户空间将eBPF字节码传入内核的verifier模块进行运行前检查，通过之后送到BPF沙箱中允许，这时可以使用内核提供的各个功能的探测器(hook的其他模块)来进行操作。结果会返回给用户空间。用户空间也可以通过maps和内核交互。
Tracee - 一个运行时安全检查工具 演讲者所在组织开发的开源工具，使用eBPF来完成堆操作系统中rootKit的追踪。各种好，拥有自己的规则引擎，可以自己编写规则动态检测，源码如下：
GitHub - aquasecurity/tracee: Linux Runtime Security and Forensics using eBPF
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac5c3b3f19bbc3069d2a5b2ec6f1cadb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85c565cfbc10fb1487c12d53a698064e/" rel="bookmark">
			jvm之JMX
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 本文来看先jmx相关内容。
1：jmx介绍 jvm在运行的过程中有很多的信息，比如堆内存，线程数，加载的类信息，CPU的使用量等，如果我们想要将这些信息暴漏让外界获取，该怎么做呢?此时就需要用到jmx技术了，jmx技术的全称时Java management extension，即，Java管理扩展。那么首先，Java作为面向对象的语言，自然要先将需要暴漏的信息以某种形式组织起来了，组织的形式也比较简单，就是定义bean，只不过因为其用于管理用途，所以叫做management bean，即MBean，看似神秘，其实比较纯粹，和普通的Java bean没有任何区别，也是封装了一组属性（如可能CPU使用率属性等）和操作（如可能执行gc的操作，以及自定义的其他方法等）。MBean不止一个，有很多很多，为了方便MBean的管理，Java定义MbeanServer来完成MBean的统一管理工作，但是此时还不能暴漏到外界，暴漏到外界还需要用到rmi连接器，之后诸如jconsole，jvisualvm等工具就可以通过rmi连接到jvm获取各种MBean，并从中读取信息来展示，供用户进行管理和查看工作了，架构图如下：
2：自定义MBean 想要自定义MBean，我们首先需要创建接口，接口名称要以MBean结尾，如下：
public interface UserMBean { String getName(); String getPassword(); String getPhone(); void say(); void changeUrl(String url); } 然后我们就可以定义一个实现类作为MBean，如下：
public class User implements UserMBean { private static String url = "https://zhuanlan.zhihu.com/p/166530442"; @Override public String getName() { return "风筝"; } @Override public String getPassword() { return "密码不可见"; } @Override public String getPhone() { return "18900000000"; } @Override public void say() { System.out.println("Hello JMX"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85c565cfbc10fb1487c12d53a698064e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd0d8d5be568849696dacabefaf3fe54/" rel="bookmark">
			SpringBoot核心配置全面总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Boot的核心配置文件用于配置Spring Boot程序，文件名字必须以application开始。这个既是底层源码的强制要求，也是SpringBoot的一种代码规约，有助于在开发层面利于代码规范管理。
说明：以下内容接着i前面的SpringBootCase项目就行演示。
1、application. properties核心文件 格式：以键值对的方式进行配置，key=value 示例：name=xintu 我们修改application.properties配置文件。比如修改默认tomcat端口号及项目上下文件根。
设置内嵌Tomcat端口号
server.port=8888
设置项目上下文根路径，这个在请求的时候需要用到
server.servlet.context-path=/springbootcase
配置完毕之后，启动测试。
浏览器输入地址：http://localhost:8888/springbootcase/hello?name=lw ， 页面验证结果如下。
2、 application.yml配置文件（推荐配置风格） yml 是一种 yaml 格式的配置文件，主要采用一定的空格、换行等格式排版进行配置。格式如下，
key: 空格+value, 表示一对键值对。
配置YNML时，需要注意以下4点：
1）以空格的缩进来控制层级关系。 2）只要是左对齐的一列数据，都是属于同一层级。 3）空格必须有。 4）属性和值对大小写敏感。
server: port: 8888 # 设置内嵌Tomcat端口号 servlet: context-path: /SpringBootCase # 设置项目上下文根路径，这个在请求访问的时候需要用到 复制代码 特点：与 application. properties 相比，yaml更能直观地被计算机识别，而且容易被人类阅读。 yaml 类似于 xml，但是语法比xml 简洁很多，值与前面的冒号配置项必须要有一个空格， yml 后缀也可以使用 yaml 后缀。当两种格式配置文件同时存在，使用的是 .properties 配置文件，为了演示yml，可以先将其改名，重新运行SpringbootApplication，查看启动的端口及上下文根。
我们在后面的学习过程中，均使用 .yml格式 。如果想改.properties形式也可以，按照自己喜欢的风格 或 团队约定即可。
3、SpringBoot多环境配置 在实际开发的过程中，我们的项目会经历很多的阶段，开发、测试、上线， 尤其时很大厂，在进行一些重要需求迭代时，还会包括预发、灰度等。每个阶段的配置会因应用所依赖的环境不同而不同，例如：数据库配置、缓存配置、依赖第三方配置等，那么这个时候为了方便配置在不同的环境之间切换，SpringBoot提供了多环境profile配置功能。
命名格式：application-环境标识.yml（或 .properties）。
下面我们为每个环境创建3个配置文件，分别命名为：application-dev.yml（开发环境）、application-dev.yml（测试环境）、application-dev.yml（生产环境）。
各配置文件内容如下，
application-dev.yml
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd0d8d5be568849696dacabefaf3fe54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b8665fffcf6eaca92af252f31628c66/" rel="bookmark">
			spring注册Servlet的方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于配置文件 首先是web.xml的方式，这种方式就是在xml中进行配置，不想多讲，感兴趣的可以找资料看下。
基于注解 对主类标记注解@ServletComponentScan("com.example.springsource.nonblocking")，然后在过滤器上使用@WebServlet(name = "ServerServlet", urlPatterns = {"/server"}, asyncSupported = true)，注意过滤器一定要实现servlet接口，下面看下这个的原理。
@ServletComponentScan会导入ServletComponentScanRegistrar组件，其实现了ImportBeanDefinitionRegistrar，registerBeanDefinitions()会被调用。这个方法就是确定Servlet的扫描路径，并且添加BeanFactory的后置处理器。
@Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) { Set&lt;String&gt; packagesToScan = getPackagesToScan(importingClassMetadata); if (registry.containsBeanDefinition(BEAN_NAME)) { updatePostProcessor(registry, packagesToScan); } else { addPostProcessor(registry, packagesToScan); } } 添加的后置处理器为ServletComponentRegisteringPostProcessor。
private void addPostProcessor(BeanDefinitionRegistry registry, Set&lt;String&gt; packagesToScan) { GenericBeanDefinition beanDefinition = new GenericBeanDefinition(); beanDefinition.setBeanClass(ServletComponentRegisteringPostProcessor.class); beanDefinition.getConstructorArgumentValues().addGenericArgumentValue(packagesToScan); beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE); registry.registerBeanDefinition(BEAN_NAME, beanDefinition); } 容器启动时会调用postProcessBeanFactory，对包路径进行扫描，然后使用ServletComponentHandler进行处理。
@Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException { if (isRunningInEmbeddedWebServer()) { ClassPathScanningCandidateComponentProvider componentProvider = createComponentProvider(); for (String packageToScan : this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b8665fffcf6eaca92af252f31628c66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d269818c778ce1420323e9875c1ff94a/" rel="bookmark">
			vue实现倒计时功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue实现倒计时功能
首先我们需要一个 Vue. js的函数，这个函数用于实现倒计时，这里我们采用 vue. js的 import来实现，这是 vue. js的一个特殊功能，将函数调用的参数以列表的形式加入到函数中，当在函数执行完后返回结果。接下来我们介绍一下这个功能： 1、首先我们定义一个“date”事件，来实现倒计时； 2、然后在“date”事件中添加一个“temp”方法来获取当前时间； 3、最后使用vue2. vuex来实现倒计时功能。
1、定义“date”事件
首先，我们定义一个 date事件，这是一个触发倒计时功能的事件，代码如下： 定义“date”事件，主要用到了 vue. js中的 onload （）方法，其中 onload （）方法会将当前的时间值传递给“date”事件。该方法中有两个参数，一个是时间值，另一个是一个“date”参数。 我们在 onload （）方法中调用了“date”函数，并将其添加到 vue. js的 import函数中。 另外我们也需要为倒计时事件添加一些其它的属性，比如在 vue. js中需要用到的一个属性： tempName，这个属性代表了倒计时的时间值，所以我们在“date”事件中也需要添加这个属性： 最后我们还需要将“tempName”这个属性设置为“0”，这样当用户点击按钮时就会直接跳转到倒计时的时间页面。 至此，我们完成了第一步定义“date”事件，接下来我们开始编写代码：
2、添加“temp”方法获取当前时间
我们首先需要获取当前的时间，我们可以使用“date”事件的` temp方法来获取当前时间。如图所示： 在 vue中我们可以使用“start”和“end”方法来获取时间，但是它们的格式并不是一样的， start和 end表示时间开始和结束， temp表示当前时间。 我们首先使用“date”事件的` start`方法来获取当前时间，然后在“date”事件中添加一个` temp`方法，将这个方法传入“temp”中，可以通过vue2. vuex来实现。 然后我们使用“temp”方法获取当前的时间，在这里我们可以使用` start`方法来获取当前的时间，但是如果用“date”事件去获取的话，会导致 vue. js存在一个问题：无法获取当前时间，我们可以使用“date”事件的`end_time`方法去获取当前的时间。
3、将倒计时功能用vue2. vuex实现
vue2. vuex是一个基于 Webpack的组件库，其内置了许多实用的组件，如： datetime （）：可以获取当前时间、日期、时间等信息； setTimeout （）：可以设置倒计时时间； getTime （）：可以设置倒计时的间隔时间，如果当前时间到了，就会一直重复计时； 除了上面这些常用功能外，还有一些其他的实用功能，比如： 显示倒计时 date； 设置 temp （）和 getTime （）的默认值； 如果你觉得vue2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d269818c778ce1420323e9875c1ff94a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/053876005641bdff0575eb0517ee7a44/" rel="bookmark">
			集简云助力企业实现账务管理数智化，招银云直联无代码对接企业自研系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		客户 · 介绍 成都环泰宏图科技公司是一家专注于新兴产业高端技术的研发、集成、推广、运维的高新技术企业。公司主要提供信息化、物联网、人工智能、智慧城市等高端技术领域的解决方案和服务，注重技术创新和技术应用，并且在电子政务、人工智能、物联网等领域取得了多项成果。
客户 · 遇到的问题 作为一家新型企业，随着产业整合和市场竞争的加剧，资金管理也变得尤为重要。为了保持竞争优势，加快财务数字化转型，公司内部自研了对账系统，用来配合财务网银系统的资金管理，以提高财务管理和企业效率。然而，在数字化转型的过程中，自研系统和网银系统之间的协同效果并不理想，系统之间无法互通，企业通过银行办理收付款、转账的业务越来越多，和银行流水对账后，还要将收款单一笔一笔在自研系统中进行录入，大量流水手动流转经常导致：
● 数据来源不统一
自研系统和网银系统之间无法直接连接，导致数据来源不统一，无法保证数据的真实性和准确性。
● 信息不及时
自研系统和网银系统之间的信息无法有效传递，导致信息不及时，加重了财务部门的压力。
● 财务工作重复
由于信息不畅通和数据来源不统一，效率低还容易出错，导致有些工作需要重复操作，占用了财务人员大量的时间。
当下，财务数字化成为必选题，对于财务管理的便捷性和时效性要求也越来越高。作为财资管理的底层技术支撑，银企直连成为越来越多数字化企业的新需求，但耗费了大量时间和成本研发的系统难以应对现有场景规则的变化，更无法满足新场景的对账需求，那么到底该如何高效、低成本的解决这个问题呢？
集简云 · 解决方案 集简云是一款超级软件连接器，通过集简云无需任何开发就可以将招银云直联对接到自研系统中，让系统之间的数据实现自动同步，我们只需要在集简云搭建一个数据流程即可让整个工作流程实现自动化运转，操作简单，成本低，而且无需代码开发。
因该公司使用的是自研系统，集简云协助用户将自研系统上架到集简云开放平台，根据公司需求，将应用设置为“内部应用”，仅限公司内部人员使用外，上架的自研系统目前已与集简云平台上的数百款应用软件打通，无需进行额外开发和维护。
“招商银行云直联无需API开发连接企业自有研发系统”自动化方案如下：
点击使用此模版
实现效果：通过此流程，可以实现当招银云直联账务变动时，财务人员无需额外登录网银系统，在自研系统中可以直接接收到账务通知，更加快速便捷地掌握账户资金动态。
另外通过集简云内置应用实现了企业的个性化需求，通过数据筛选指定户名或者指定标记的流水以及提取流水交易金额中的数字，将更精准的账务信息推送到自研系统中，满足了企业的不同的业务场景。
客户 · 反馈 “想和招银云直联连接门槛很高，接入的成本也不低，但没想到通过集简云简单的流程搭建就能实现网银系统和我们的自有系统互通。”该公司财务负责人称。引入这一系统后，财务的的管理工作更加高效便捷，大大减少了手动操作带来的出错率。与此同时，招银云直联也为与银行的交易流程提供了更加便利的途径，提升了资金运转效率。
其次，集简云帮助企业实现交易数据在系统间有效传递，助力企业实现数字化集中管理，为企业后续决策提供有效支持，让企业真真实实的感受到了"自动化"是企业数字化转型的增长引擎。
总之，招银云直联使财务管理实现了高效、顺畅的自动化，为企业带来了稳定、高效、便捷的财务管理体验！
Q
关于集简云
ABOUT JIJYUN
集简云：让连接更简单
集简云是一款超级软件连接器，无需开发，无需代码知识就可以轻松打通数百款软件之间的数据连接，构建自动化与智能化的业务流程。通过自动化业务流程，每月可节省您数百甚至数万小时的人工成本。
600+集成应用
集简云平台
，赞2
集简云介绍
集简云开放平台：让您的系统拥有与600+款软件连接的能力
集简云开放平台现开启“优质应用招募计划”，诚邀您参加！免费入驻集简云应用中心，让您的产品拥有与600+款软件连接的能力！
前100位入驻将获得专属技术支持，助您快速完成上架！
百万级市场曝光，帮您获取更多商机！
如您资源紧张无排期，也可将您的产品介绍、接口文档及测试账号发送至chengguo@email.jijyun.cn，评估后我们将按照排期顺序安排接入。如需了解更多，请扫码联系我们
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a53e70f18d1a5b5b56b808e7d9bfff8f/" rel="bookmark">
			（STM32基础）对射式红外传感器计次&amp;旋转编码器计次
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、对射式红外传感器计次 1）配置对射式红外传感器初始化函数 1、外部中断配置： 第一步：因为对射式红外传感器模块DO数据传感器模块会给引脚发送高低电平信号来触发中断计次，所以需要配置该引脚外部中断初始化。
第二步：按照图示初始化所涉及到的外设：
①先开启所涉及的外设RCC时钟 ②配置GPIO口为输入模式
③配置AFIO选择所需要用到的Pin口连接到EXTI
④配置EXTI选择边沿出发方式，以及触发响应方式
⑤配置NVIC，给中断选择合适的优先级
代码实现：
① RCC开启所需外设的时钟，在这里只需要开启GPIO、AFIO的外设时钟，EXIT和NVIC时钟是默认开启的，NVIC是内核外设不受RCC控制。
代码：
RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
② GPIO_Init 初始化配置
代码： GPIO_InitTypeDef GPIO_InitStructure;
GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
GPIO_InitStructure.GPIO_Pin = GPIO_Pin_14;
GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
③ 配置AFIO初始化，ST公司没有专门给AFIO封装专用函数库，在GPIO内附带配置了专用函数。
GPIO_PinLockConfig 参数指定某个引脚， 那这个引脚配置会被锁定，防止误更改。
GPIO_EventOutputConfig
GPIO_EventOutputCmd 这两个函数用来配置AFIO的事件输出功能的
GPIO_PinRemapConfig 用于引脚重映射，第一个参数选择重映射的方式，第二个参数是新的状态
GPIO_EXTILineConfig 调用这个函数配置AFIO数据选择器，选择先要的中断引脚，虽然开头是GPIO，但是实际操作的是AFIO寄存器。
GPIO_ETH_MediaInterfaceConfig 以太网有关函数
代码：
GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource14);
④ 配置EXTI初始化
EXTI_DeInit 清除EXTI的所有配置 恢复上电的初始状态
EXTI_Init 结构体初始化EXTI函数
EXTI_StructInit 调用这个函数可以把参数传递的结构体变量赋一个默认值
EXTI_GenerateSWInterrupt 软件触发外部中断 调用一次 触发一次 如果只需要外部引脚触发中断则不需要次函数
FlagStatus EXTI_GetFlagStatus 获取指定标志位是否被置一
EXTI_ClearFlag 对置一的标志位进行清除
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a53e70f18d1a5b5b56b808e7d9bfff8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5981e029690ed6b214516e0a9b2cf9f/" rel="bookmark">
			（STM32基础）STM32用keil5开发前准备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、软件&amp;驱动安装 1）Keil5安装MDK-ARM版本后，需要安装对应芯片器件库，否则新建工程无芯片可选项。
查看设备管理器 stlink 是否驱动正常，如果是感叹号则需要装驱动 2、插入STLINK后，在keil安装目录下找到安装驱动程序，安装STLINK驱动。
3、插入usb转串口模块后，安装驱动程序（资料文件夹内 工具软件内）。
二、新建STM32工程 1）开发方式有如下几种： 1、基于寄存器的方式（和51开发相似）：这是最底层最直接的方式，使用程序直接配置寄存器，达到所需功能，但STM32结构复杂，寄存器太多所以不建议用此种方式。
2、基于标准库（库函数）的方式：使用官方提供的封装函数，通过调用函数来间接配置寄存器，ST对寄存器封装较好，所以此方式是首选，利于提高开发效率。
3、基于HAL库的方式：用图形化界面快速配置STM32，适合快速上手STM32，此方式隐层底层逻辑，因为太过简单，学完不能深入了解，所以暂不推荐用此方式。
2）新建基于标准库的STM32开发工程 1、建立存放所有工程文件夹
2、打开keil5软件，点击project，new uvision project ，选择第一步新建的文件夹，在此文件夹内创建新文件夹用于存放此次工程文件，名字可以自定义任意，接下来给工程起名-（Project）后，点击保存。
3、选择器件型号，
然后叉掉弹出来的小助手
4、添加工程必要文件（启动文件、外设寄存器描述文件、内核寄存器描述文件）打开固件库文件夹。
这里面就是stm32的 “ 启动文件 ” ， 复制后创建Start文件夹，都放在Start文件夹中
转回到“stm32f10x”文件夹
stm32f10x.h是STM 32的外设寄存器描述文件（头文件）描述有哪些寄存器以及对应地址。
两个system文件用来配置时钟，STM32主频72MHZ就是此文件里面的函数配置的
这三个文件都复制粘贴到Start文件夹下
因为STM32是由内核和内核的外围设备组成，内核寄存器描述文件和外围设备寄存器描述文件不在一起，所以需要打开下面的文件夹，添加“内核寄存器描述文件”（复制粘贴到Start文件夹中）
5、转到Keil中，修改第一个组的名字为Start，然后邮件添加已存在文件，文件过滤器选择allfiles
“启动文件”添加md.s后缀的
然后添加剩余的五个 .c 和 .h 文件
这里面的文件都是STM32里面最基本的文件，不需要我们任何修改，添加进来即可；文件图标带小钥匙因为是“只读文件”。
5、添加Start文件夹的头文件路径，要不然编译软件是无法找到头文件
点击右边三个点，新建路径，添加Start的文件路径。
6、新建工程内文件User，存放主函数main
然后再Keil里面右键“target” 添加组
右键“User”添加新文件，选择C文件，名字自定义，然后选择存放路径User文件夹中
在main中最后一行必须是空行，要不然会编译出警告。
注意：最新版Keil默认是v6编译器，需要在option for target里面设置v5.06编译器
为了防止中文出现乱码，编码格式设置为UTF8
7、Keil中配置STLINK调试器，点击option for target，选择debug，选择stlink
再点击右边settings，勾选reset and run，每次调试程序编译完自动下载到板子中。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6c46b447000301ba32010fcf2f4a4bd/" rel="bookmark">
			（STM32基础）STM32入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、STM32简介： 1、ST公司基于 ARM Cortex-M内核 开发的 32位 微控制器（运算在内核中完成）
2、STM32常用于嵌入式领域（智能车、无人机、机器人等领域）
3、STM32是一款功能强大的嵌入式微控制器
目前主要有以下型号：
1）ARM简介： 1、ARM是一家半导体知识产权（IP）提供商，全球超过百分之九十五的手机电脑都是采用ARM架构。
2、ARM公司设计内核，半导体厂商完善内核周边电路，并生产芯片。
2）本次学习单片机参数 1、51单片机供电电压为5v，usb供电电压也为5v，所以不能直接给stm32供电，需要用专用电源模块。
3）STM32-F1片上资源/外设（并不是所有型号都拥有全部的外设） 1、深色为Cortex-M3内核的功能外设，其余均为内核外的功能外设。
2、大概功能介绍：
NVIC：内存中管理中断的设备（例如配置中断优先级）
SysTick：给操作系统提供定时服务，STM32是可以加入操作系统的，例如：FreeRTOS、UCOS等。如果使用此类操作系统需要Systick提供定时服务来进行任务切换功能。
RCC：时钟控制，配置系统时钟，使能其他模块时钟，上电时其他外设是没有时钟的，在stm32中外设不配置时钟不工作。
GPIO：通用IO口，点灯等操作。
AFIO：复用功能端口的重定义、中断端口定义。
TIM：STM32最常用 功能也最多的外设，定时器分三类：高级定时器、通用定时器、基本定时器。
DMA：可以帮助CPU完成搬运大量数据的繁杂任务。
UART：异步串口
USART：同步/异步两种模式都支持的串口，实际用异步串口多。
通信协议：I2C、SPI、CAN（常用于汽车领域）、USB
RTC：实时时钟，在STM32内部完成计时功能，可接外部备用电池，即使掉电也可以继续运行。
CRC：数据校验方式，判断数据正确性。
PWR：电源控制，可以让芯片进入睡眠模式等，达到省电目的。
BKP：系统掉电时，可以使用备用电池保持数据，根据需要，可以完成一些特殊功能。
IWDG、WWDG：当单片机因为电磁干扰死机，或者程序设计不合理陷入死循环时，及时复位芯片，保持系统稳定。
USB OTG：使用此功能可以使STM32作为主机去读取其他USB设备。
4)STM32单片机命名规则 二、系统结构 1）结构图 1、AHB（先进高性能总线）系统总线挂载大量其他外设例如：SDIO、RCC。APB*（先进外设总线）。
2、AHB和APB因为总线协议、速度、数据格式等差异，所以中间需要加两个桥架完成数据转换和缓存。AHB总体性能高于APB，APB2性能高于APB1。
3、APB2一般和AHB同频 72MHZ，APB1一般是36MHZ，所以APB2一般连接优先级需要较高的外设（GPIO等图示端口）
4、DMA相当于CPU的秘书，当有需要搬运数据等简单且需要重复的需求出现，DMA通过DMA总线连接到总线矩阵，拥有和CPU一样的总线控制权，用于访问外设。
5、当需要DMA搬运数据时，外设通过DMA请求线，发出请求，然后DMA获得总线控制权，完成数据搬运，整个过程不需要CPU参与。
2）引脚定义 1、红色是电源相关的引脚、蓝色是最小系统相关引脚、绿色是常用IO口、功能口引脚。
3）启动配置 4）最小系统板电路图 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6d2679a3e38c0287bfcb2443c369ec2/" rel="bookmark">
			学习TypeScript快速入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🍁 作者主页：💖仙女不下凡💖
🍁 前言介绍：以下👇 内容是根据“阿宝哥”的教材自学总结，定期更新欢迎持续关注！
🍁 学习前提：学习该文章之前需要有一定JS的基础，较为熟悉ES5及ES6的相关知识基础！
🍁 欢迎点赞 👍 收藏 ⭐留言 📝 如有错误敬请指正！
💚一、安装与运行 🔶1.1 安装 TypeScript官网地址：https://www.tslang.cn/play/index.html # 安装命令 $ npm install -g typescript # 按指定版本号进行安装 $ npm install -g typescript@3.6.4 # 安装完毕后，查看版本号 $ tsc -v 🔶1.2 起步 # 创建文件夹 $ mkdir TypeScript # 在TypeScript文件夹中创建demo.ts文件，其代码如下： console.log('Hello,world') 🔶1.3 编译 正常编译
# 编译命令 $ tsc demo.ts # 编译命令执行之后，生成demo.js文件 # 再执行，输出一下内容：Hello,world $ node demo.js 安装插件之后直接启动浏览器编译，不安装插件不能直接编译。
# 安装ts-node $ npm install ts-node -g # 编译并执行 $ ts-node demo.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6d2679a3e38c0287bfcb2443c369ec2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6d13fc9ff6e3201cbca75bc7f86fb63/" rel="bookmark">
			Mac 与 Windows 通过网线“直连”共享数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 问题提出2. 必要条件3. 参数设定3.1 网卡参数设定3.2 创建专用的共享用户3.3 配置用户权限3.4 共享参数配置 4. SMB 共享配置5. 效果测试参考文献 1. 问题提出 Mac生态中方便的“隔空投送”想必令许多人印象深刻，不过出于各种目的和使用场景的特殊要求，我们很难完全仅在Mac或Windows的单一场景下完成任务，如此Mac与Windows共享数据便在某种程度的刚需。
当然，有人会说有很多局域网内互传文件的软件，如LANDrop等，使得两个系统间互传文件的效率大大提高。不过，这种场景一方面传输的速度与稳定性存在不确定性，另一方面不一定存在这种局域网环境或者不一定安全。
查遍网络中的相关资料存在以下几个问题，一是介绍网线直连的相关文章主要集中在Windows环境下，二是部分文章只从目的出发配置过于简单粗暴导致在使用过程中可能存安全隐患，三是一部分文章设置过于注重网络安全致使配置过于繁琐。
因此本文基于现存的问题，聚焦于Mac与Windows间数据共享，对一些过去没有论述到的问题进行澄清并提供一种兼顾安全性与便利性的适用于实际环境的配置方案。
2. 必要条件 硬件要求
首先需要有两块物理网卡，Windows 设备一般都有两个网卡一个无线网卡一个有线网卡，Mac 一般都需要配 USB Hub 有相当部分的 USB Hub 会自带网卡参数要求
现在市面上的网卡普遍为千兆网卡，考虑到设备的USB接口标准的复杂性，千兆网卡实际上已经可以应对绝大多数应用场景。如果考虑到部分用户可能会传输视频素材或者希望有更加极致的使用体验可以考虑使用2.5G网卡。Mac 网卡参数
Windows 网卡参数
3. 参数设定 3.1 网卡参数设定 通过网线连接两台电脑是最原始的局域网组网方式，只是此时两台电脑并不能直接进行通讯；而两台电脑之间要能够通讯需要具备两个条件，一是两台电脑间需要建立物理连接，二是两台电脑间还需要建立逻辑连接。因为两台电脑间已经通过网线建立起直接连接，所以两台电脑间是直接通信，此时只需配置逻辑连接，即IP 地址和子网掩码，而不需要配网关和 DNS 。
部分网络文献因为是通过路由或在已搭建好的局域网内进行数据共享，所以电脑A不需要配置网关和DNS，电脑B则需将网关设置为电脑A的IP地址，而DNS则不必配置。
两台电脑间要建立逻辑连接只需要将两台电脑设置在同一网段，即IP地址前三位相同最后一位不相同。另外，需要注意的是本教程关注的焦点在于 Mac 与 Windows 间数据的共享并不涉及网络的共享，两台电脑与互联网间的连接由分别由另外的网卡专门负责，因此并不需要对路由表进行修改。在此处部分网络文献会强调网关的配置，这实际上并不准确，这是因为 Windwos 不允同时有两个网关存在。如果一定需要共享网络或是在局域网环境下使用，请考虑配使用 route 命令修改路由表信息，以配置双网卡。
Windows 网卡配置
Mac 网卡配置
网络连通性测试
两台电脑间如果能够 ping 通表示逻辑连接建立成功，如果不能 ping 通则表明逻辑连接并示建立，此时需要检查网卡配置是否正确或者修改防火墙配置。 ping 192.168.1.2 3.2 创建专用的共享用户 该部分配置主要有两目的，一是应对部分 Windwos 用户开启 Administrator 用户后共享失败的情况，二是出于网络安全的目的，当然本教程只是考虑了基础的安全配置。Windows 用户开启 Administrator 用户后在共享数据的过程中会要求输入密码，而实际上该账户并可能并不设置密码，导致数据共享失败；另外，在共享失败时，为达到共享的目的部分网络教程给出的解决方案是开启 SMB V1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6d13fc9ff6e3201cbca75bc7f86fb63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acb0ead2e8e421a98e4e424b35937a30/" rel="bookmark">
			＜ ElementUi组件库： el-progress 进度条Bug及样式调整 ＞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ElementUi组件库： el-progress 进度条Bug及样式调整 👉 前言👉 一、实现原理&gt; 修改 el-progress 进度条样式 及 渐变进度条样式 👉 二、案例代码（前言效果图案例）&gt; HTML代码&gt; CSS代码 👉 三、效果演示往期内容 💨 👉 前言 在 Vue + elementUi 开发中，在使用 Progress 进度条时，往往会因为需求原型太过花里胡哨而烦恼（原本的样式并不能满足需求）。
为什么呢？ 因为这个组件elementUi并没有提供过多的自定义属性及插槽，对的，插槽也没有，不能自定义进度条文本样式。即使在elementUi 的文档里面写了属性，但是实际使用并未生效（怀疑是bug）。
Tips: 基于 elementUi来说，好像elementUi - Plus升级了，修复了bug，也增加了对应的属性、开放了插槽！
所以，在这个时候，我们就需要用到样式覆盖来对 Progress 进度条 进行个性化样式设置了！ 首先，给小伙伴们看看，经过定义样式后，使用进度条实现的样式！
接下来，进入主题！
👉 一、实现原理 &gt; 修改 el-progress 进度条样式 及 渐变进度条样式 我们可以通过 /deep/、&gt;&gt;&gt;、v-deep 来对 elementUI 中给 el-progress 定义的原样式进行深度覆盖。
并且我们可以通过控制台看见，进度条是由svg标签渲染出来的，如果需要更改进度条样式，可以通过修改原先svg标签的渲染路径即可，若只需要单色，可以直接在elementUi提供的属性 或者 自行进行样式覆盖！
具体内容如下：
&gt; HTML
&lt;div class="progressName"&gt; &lt;el-progress :width="60" :hidden="60" type="circle" :percentage="50"&gt;&lt;/el-progress&gt; &lt;/div&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/acb0ead2e8e421a98e4e424b35937a30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d5cc5410674fff3b09239ad6b62ea9c/" rel="bookmark">
			【leetcode刷题】剑指offer基础版（完结）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		剑指 Offer 05. 替换空格 class Solution { public: string replaceSpace(string s) { int len = s.size(); string g; for(int i = 0; i &lt; len; i++) { if(s[i] == ' ') { g += "%20"; continue; } g += s[i]; } return g; } }; 剑指 Offer 58 - II. 左旋转字符串 class Solution { public: void Reverse(string &amp;a,int left,int right) { while(left &lt; right) { char temp = a[left]; a[left] = a[right]; a[right] = temp; left++; right--; } } string reverseLeftWords(string s, int n) { int len = s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d5cc5410674fff3b09239ad6b62ea9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/781fb93a239bb5efb23ae4967097bbb1/" rel="bookmark">
			(vue):src图片不显示解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(vue):src图片不显示解决办法 总结几个可以解决本地图片路径显示不出来的问题：
1.把图片放在src同级的static文件夹下。
2.把图片放在cdn上，把网络地址存在imgUrl里，然后直接去展示。
3.图片放在assets文件夹，然后在data里面require进图片
展示法三用法： //html写法： &lt;el-carousel-item v-for="(item,index) in houseObj.imgList" :key="index"&gt; &lt;img :src="require('../../assets/image/'+item)" alt="" :size="400"&gt; &lt;/el-carousel-item&gt; //data写法： &lt;img :src="url"/&gt; data() { return { url: require("../assets/images/zd_logo.png"), } } 解决参考：https://blog.csdn.net/SugarXiXixi/article/details/109735379
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5a2d637ed2663b3625b74893d372d20/" rel="bookmark">
			linux安装git
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 linux安装git 有两种方式： 1、直接yum安装： yum install git -y # 查看版本： git --version 推荐自定义安装，因为yum安装的Git版本比较老，并且配置文件不能指定位置。
2、自定义安装： 官网下载安装包：https://git-scm.com/download/linux 解压安装包: tar -zxvf git-2.39.0.tar.gz 安装编译环境： yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker 安装上面编译环境的时候，yum自动帮你安装了git，这时候你需要先卸载这个旧版的git。 yum remove git 编译安装:（这个时候一定要在git-2.39.0的文件夹下执行） make prefix=/opt/git all make prefix=/opt/git install 配置环境变量： vim /etc/profile export GIT_HOME=/opt/git export PATH=$GIT_HOME/bin:$PATH #刷新源 source /etc/profile #最后查看版本： git --version 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/118ef15a9940b611cb4bd7af6f591b36/" rel="bookmark">
			easypoi导出csv文件，wps打开正常，excel2016打开乱码解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 /** * csv 导出 */ public static&lt;T&gt; void exportCsvFile(HttpServletResponse response, List&lt;T&gt; list) throws Exception{ response.setHeader("content-Type", "text/csv"); response.setHeader("Content-Disposition", "attachment;filename=" + URLEncoder.encode("测试" + ".csv", "utf-8")); //导出csv乱码，设置 ServletOutputStream outputStream = response.getOutputStream(); outputStream.write(new byte[]{(byte)0xEF, (byte)0xBB, (byte)0xBF}); CsvExportParams csvExportParams = new CsvExportParams(); csvExportParams.setEncoding("utf-8"); outputStream.flush(); CsvExportUtil.exportCsv(csvExportParams, User.class,list, outputStream); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fe2558d4b35137f4e58d79b139a304a/" rel="bookmark">
			3步轻松获取Pandas DataFrame任意单元格值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Pandas处理DataFrame数据的过程中，我们时常需要获取某个具体的单元格值进行操作。那么如何高效而灵活地从Pandas DataFrame中提取任意一个单元格的值呢?
今天分享在Pandas DataFrame获取单元格值的3大方法:
第一步:.loc[]方法，传入行列标签
使用.loc[]方法，传入行列标签可以直接提取值:
df.loc['row2'， 'col3'] 例如:
col1 col2 col3 row1 1 4 7 row2 2 5 8 row3 3 6 9 获取row2行col3列的值:
df.loc['row2'， 'col3'] # 输出:8 第二步:.iloc[]方法，传入整数位置
使用.iloc[]方法，传入行列整数位置即可提取值:
df.iloc[1， 2] 例如:
col1 col2 col3 row1 1 4 7 row2 2 5 8 row3 3 6 9 获取第2行第3列的值:
df.iloc[1， 2] # 输出:8 第三步:使用`[]`直接访问列
可以直接访问列，传入行标签或行位置获取值:
df['col3']['row2'] # 传入行标签 df[2][1] # 传入行位置 例如:
df['col3']['row2'] # 输出:8 df[2][1] # 输出:8 这就是在Pandas DataFrame获取任意单元格值的3大方法:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fe2558d4b35137f4e58d79b139a304a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9925b655ed110dd167a46ed1b6a5f12a/" rel="bookmark">
			WinMerge比较时未显示出全部文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WinMerge比较时未显示出全部文件 1.解决方法 从安装开始都是比较正常，但是用着用着差异部分就只能显示有差异的部分，而不是显示出全部文件，这就比较头疼。 在此做个笔记，以防下次再入坑。 参考：https://blog.csdn.net/sxzlc/article/details/105881890 1.解决方法 视图–差异的上下文–显示所有行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75ebbdafa436bfd64de7662e8ca55e5f/" rel="bookmark">
			数据海洋中的明珠：云计算与大数据分析引领洞察未来！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		⭐ 云计算：连接世界、储存未来⭐ 大数据分析：洞察未来的智慧之光⭐ 云计算与大数据分析的协同引领未来 在当今数字化时代，云计算和大数据分析成为了企业和组织获取洞察力、优化决策以及创造价值的重要工具。云计算提供了强大的计算和存储资源，而大数据分析则为海量数据的处理和挖掘提供了解决方案。本文将探讨云计算与大数据分析如何共同驱动着信息时代的变革，并对未来的发展趋势进行展望。
⭐ 云计算：连接世界、储存未来 云计算是一种通过互联网提供计算服务的模式，它将庞大的计算资源集中于云端，为用户提供灵活、高效、可扩展的计算能力。云计算通过虚拟化技术实现资源的共享与调度，为用户节省了硬件投资和维护成本，提供了按需分配和弹性扩展的能力。
在大数据时代，云计算扮演着关键的角色。云平台的高度可扩展性和弹性使得大规模数据的存储和处理成为可能。企业和组织可以将海量的数据存储在云端，通过云计算的强大计算能力，高效地处理和分析这些数据，从中获得宝贵的洞察。
同时，云计算也促进了数据的共享与协作。不同机构和个人可以将数据存储在云上，通过云平台进行数据交换和合作，实现数据的共享与融合。这为跨领域的数据分析和协同创新提供了便利，加速了科学研究和商业发展的步伐。
⭐ 大数据分析：洞察未来的智慧之光 大数据分析是指通过对大规模、多样化、高维度数据进行挖掘和分析，提取有价值的信息和知识。在传统的数据分析方法已经无法胜任的情况下，大数据分析凭借其强大的计算能力和智能算法，揭示了数据背后的规律和趋势。
大数据分析在各个领域都具有重要意义。在商业领域，通过对大数据的深入分析，企业可以了解市场趋势、消费者行为、产品需求等信息，从而做出精准的决策和战略规划。在医疗领域，大数据分析可以帮助研究人员发现疾病的风险因素、预测病测结果，优化治疗方案，并提供个性化医疗服务。在城市规划领域，大数据分析可以帮助政府和城市管理者了解交通拥堵情况、人口分布、环境质量等重要信息，从而进行合理规划和资源配置。
随着人工智能和机器学习的发展，大数据分析变得更加智能和高效。通过机器学习算法和模型的训练，大数据分析可以自动发现数据中的模式、关联和异常，为决策提供更准确的支持。而人工智能的引入，使得大数据分析能够进行更加复杂和深入的推理和预测，为未来的发展提供洞察与指引。
⭐ 云计算与大数据分析的协同引领未来 云计算和大数据分析并不是孤立的存在，它们互相依存、相互促进，共同引领着未来的发展。云计算为大数据分析提供了强大的计算和存储能力，支持大规模数据的存储和处理；而大数据分析则为云计算提供了重要的应用场景和需求驱动。
通过云计算和大数据分析的协同作用，我们可以更好地利用数据这一宝贵资源，洞察未来的趋势和机会。企业可以通过云平台将海量的数据整合和分析，发现潜在的商业机会和客户需求，实现精准营销和个性化服务。政府可以通过大数据分析了解社会状况和民生需求，进行精细化的政策制定和城市规划。科学研究者可以通过大数据分析发现新的科学规律和创新思路，推动科学进步和技术创新。
在未来，随着技术的不断演进和应用的深入，云计算和大数据分析将继续发挥更大的作用。数据海洋中的明珠，即云计算和大数据分析，将引领我们洞察未来、迈向新的发展高地。让我们共同拥抱数据时代，发掘数据的无限潜力，创造出更美好的未来！
通过云计算和大数据分析，我们能够更好地利用数据资源，洞察未来的趋势和机会。云计算提供了高效的计算和存储能力，而大数据分析则揭示了数据背后的规律和趋势。它们的协同作用将推动各行各业的创新和发展。
在商业领域，云计算和大数据分析的结合为企业提供了更多商业洞察的机会。通过云计算平台的弹性和可扩展性，企业能够存储和处理大规模的数据，而大数据分析则能够深入挖掘这些数据，发现隐藏在其中的商业机会和趋势。企业可以通过分析消费者行为和市场趋势，优化产品设计、提升市场营销效果，甚至开拓新的业务领域。同时，云计算的灵活性也为企业提供了更便捷的方式来共享数据和合作，促进跨部门和跨组织之间的协同创新。
在医疗领域，云计算和大数据分析的应用正在革命性地改变疾病预防、诊断和治疗。通过整合和分析大规模的医疗数据，研究人员可以发现疾病的风险因素、制定个性化治疗方案，并预测病情发展趋势。云计算为医疗机构提供了强大的存储和计算能力，使得大数据分析在医疗决策中发挥着重要作用。例如，通过分析患者的基因组数据和临床记录，医生可以更准确地预测患者的疾病风险，制定个性化的预防措施和治疗方案，提高治疗效果和患者生活质量。
在城市规划和交通领域，云计算和大数据分析的应用有助于优化城市的交通流动和资源配置。通过收集和分析大规模的交通数据、人口数据和环境数据，城市管理者可以了解交通拥堵状况、人口分布和环境质量等信息。基于这些数据的分析，城市管理者可以制定更有效的交通规划、改善城市基础设施、提升交通运输效率，从而提升居民的出行体验和城市的可持续发展。
除了商业、医疗和城市规划领域，云计算和大数据分析还在科学研究、金融服务、能源管理、农业等多个领域发挥着重要作用。它们为我们提供了从数据中提取智慧的能力，为决策提供更准确、深入的支持。
然而，云计算和大数据分析在实践中也面临一些挑战和考验。首先是数据隐私和安全性的问题。随着数据的不断增长和共享，如何保护用户的隐私和数据的安全成为了一个重要的议题。云计算服务提供商需要加强数据保护和安全措施，确保用户的数据不被滥用或泄露。同时，合规性和法规方面的考虑也是云计算和大数据分析必须面对的挑战之一。
其次，技术人才的培养和应用也是云计算和大数据分析面临的问题。随着技术的不断发展和创新，对于掌握云计算和大数据分析技能的专业人才需求越来越高。培养和吸引具备相关技能的人才成为了一个紧迫的任务。同时，面对不断涌现的新技术和算法，专业人员需要不断学习和更新知识，保持与时俱进。
在未来，随着技术的进一步演进和应用场景的扩大，云计算和大数据分析将继续引领洞察未来的发展。随着物联网、边缘计算和人工智能等技术的融合，我们将迎来更广阔的数据海洋和更深入的洞察能力。通过云计算和大数据分析，我们能够更好地理解和应对社会、经济和科技的挑战，为未来的发展开辟新的道路。
在这个数据海洋中的明珠，云计算和大数据分析，正引领着我们洞察未来的趋势和机遇。让我们积极拥抱数据时代，充分利用云计算和大数据分析的力量，开创更加智慧、创新和可持续的未来！
云计算和大数据分析的融合为企业和组织带来了巨大的机遇和挑战。它们共同推动了信息时代的变革，为决策者提供了更深入的洞察力和更高效的决策支持。随着技术的不断进步和创新，云计算和大数据分析将继续发挥重要作用，并在各个行业和领域创造更多的价值。在迎接未来的挑战和机遇时，我们需要保持对新技术的持续关注和学习，灵活应用云计算和大数据分析的工具和方法，不断探索创新，引领信息时代的变革。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abb86fbd08178c91ef3f039aa02c4152/" rel="bookmark">
			python识别对象移动轨迹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装cv2
pycharm开发环境。无法单独安装cv2，直接安装opencv-python即可。
报错：
cv2.error: OpenCV(4.7.0) D:\a\opencv-python\opencv-python\opencv\modules\imgproc\src\shapedescr.cpp:315: error: (-215:Assertion failed) npoints &gt;= 0 &amp;&amp; (depth == CV_32F || depth == CV_32S) in function 'cv::contourArea'
方法一，识别两点的坐标
import numpy as np import cv2 as cv frameWidth = 640 frameHeight = 480 cap = cv.VideoCapture('.\VID20230519045724.mp4') size = (frameWidth, frameHeight) fgbg = cv.createBackgroundSubtractorMOG2() feature_params = dict(maxCorners=1,qualityLevel=.6,minDistance=25,blockSize=9) result = cv.VideoWriter('output.avi', cv.VideoWriter_fourcc(*'MJPG'), 10, size) while True: ret, oframe = cap.read() if oframe is None: break oframe = cv.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abb86fbd08178c91ef3f039aa02c4152/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fe04229101ec3990a03916e6d566ec8/" rel="bookmark">
			手把手教你如何使用CapSolver通过cloudflare turnstile验证码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Cloudflare Turnstile Cloudflare Turnstile是一种创新性的解决方案，旨在增强网络安全。作为一种复杂的CAPTCHA系统，Turnstile提供了独特的用户友好性和强大的保护功能，可以防止与垃圾邮件和网络威胁有关的自动网络流量。本文将手把手教你如何使用CapSolver通过cloudflare turnstile验证码。
Cloudflare Turnstile的优势 用户体验：与常规的CAPTCHA系统不同，后者往往会因难以辨认的文本或图像而令用户感到沮丧，而Turnstile则注重提供直观、用户友好的界面。
强大的安全性：Turnstile作为一道可靠的防线，可以有效防止不必要的垃圾邮件、机器人和其他形式的自动滥用，从而增强您网站的安全性。
无缝集成：作为Cloudflare服务套件的重要组成部分，Turnstile的实施对那些已经使用Cloudflare的用户来说是简单和高效的。
Turnstile与其他CAPTCHA的比较 以用户为中心的设计：传统的CAPTCHA系统往往将安全性优先考虑，而牺牲用户体验。然而，Turnstile在保持安全性的同时，也注重确保流畅的用户体验。
可靠的保护：虽然所有CAPTCHA系统的主要目的都是区分人类与机器人，但这些系统的效果可以有很大的差异。特别是Turnstile的效率取决于它的正确实施和所面临的威胁模型。
顺畅的集成：使用Turnstile可以比集成第三方CAPTCHA解决方案更加流畅，特别是对于已经使用Cloudflare的用户而言。
Capsolver支持的Turnstile类型 验证码是取代reCaptcha/hCaptcha的又一尝试。我们自动支持所有其子类型：
手动非交互式隐形 如何解决Cloudflare Turnstile 在开始解决Cloudflare之前，有一些要求和需要知道的点。
要求:
Capsolver密钥
代理服务器（推荐使用https://metaproxies.net/）
需要注意的点：
在返回getTaskResult方法的响应中以Token的形式返回解决的验证码。
必须使用与getTaskResult方法返回的相同的用户代理。
必须使用与解决挑战时使用的相同代理IP。
要解决cloudflare turnstile，请访问我们的链接。一些参数是必需的，一些是可选的。
在这个例子中，我们只使用必需的参数。cloudflare的任务类型有：
AntiCloudflareTask：此任务类型需要您自己的代理。 我们将使用AntiCloudflareTask，因为该网站使用Cloudflare Turnstile。如果任何参数丢失或未正确提交，则可能会遇到令人不满意的问题，如令牌未被网站接受。您可以在这张图片中找到所有参数：
第1步：提交信息到capsolver 使用createTask方法提交所需的信息：
POST https://api.capsolver.com/createTask { "clientKey": "Your_API_KEY", "task": { "type": "AntiCloudflareTask", "websiteURL": "https://peet.ws/turnstile-test/non-interactive.html", "websiteKey": "0x4AAAAAAABS7vwvV6VFfMcD", "metadata": { "type": "turnstile", "action": "login", //optional "cdata": "0000-1111-2222-3333-example-cdata" //optional }, "proxy": "Your_Proxy" } } 第2步：获取结果 为了验证结果，您需要连续地轮询getTaskResult API端点，直到验证码被解决。
以下是一个示例请求：
POST https://api.capsolver.com/getTaskResult Host: api.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fe04229101ec3990a03916e6d566ec8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0695e844616f9c509a69557021952b0e/" rel="bookmark">
			使用mklink突破百度网盘等软件的自动备份文件夹数量限制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		百度网盘、夸克等各种网盘都提供了自动备份文件夹的功能，但一般都有文件夹数量的限制，比如百度网盘就限制了最多只能同时备份5个文件夹，想整盘备份的话显然是不够的。当然，你可以把所有的文件夹都转移到一个母文件夹下，但这样明显不太方便，操作起来还涉及到已有路径的迁移问题。
这里介绍一下通过windows自带的mklink命令来突破文件夹上限，实现整盘备份。
注意mklink不支持在powershell中使用，只能用cmd。
什么是mklink mklink是Windows操作系统中的一个命令行工具，用于创建符号链接。符号链接目录是指向其他目录的指针，当在符号链接目录中查找文件时，实际上是在目标目录中进行查找。这可以使得在不复制或移动实际文件的情况下，将目录中的内容链接到另一个位置。
因为是从底层实现文件夹链接，所以这个链接是对应用程序透明的。比如我有一个目录"D:\link"，链接到了“D:\pictures"，那么如果我备份link目录，实际是在备份pictures目录。
使用mklink不会占用额外的空间，而且在资源管理器里删除链接也不会影响到源目录，十分实用。
使用mklink实现全盘备份 了解了mklink的原理后，很容易就可以想到，如果我们有一个目录百度网盘备份，目录下使用mklink将D盘下的所有文件或文件夹都链接过来，那么只要备份百度网盘备份这一个目录，我们就可以备份D盘的所有目录了。
手动链接会比较慢，这里提供一个bat脚本进行批量操作，这个脚本是将D盘下的除了百度网盘备份文件夹的所有文件和文件夹链接到百度网盘备份文件夹下。
@echo off set "sourceFolder=D:\" REM 源文件夹路径 set "backupFolder=D:\百度网盘备份" REM 备份目标文件夹路径 REM 遍历源文件夹下的所有子文件夹 for /d %%I in ("%sourceFolder%\*") do ( set "folderName=%%~nxI" REM 排除百度网盘备份目录 if /i not "%%~nxI"=="百度网盘备份" ( REM 创建符号链接 mklink /d "%backupFolder%\%%~nxI" "%%I" ) ) REM 遍历源文件夹下的根目录文件 for %%F in ("%sourceFolder%\*.*") do ( set "fileName=%%~nxF" REM 创建符号链接 mklink "%backupFolder%\%%~nxF" "%%F" ) echo 备份完成！ 运行完成后，在百度网盘或其他网盘的自动备份设置里，设置备份百度网盘备份这个文件夹就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8edfb7d56e217f6e546e2ac0073380ca/" rel="bookmark">
			table表格初始化自动滚动和鼠标移入滚动两种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一、初始化自动滚动 html部分 :data="tableData" ref="sdangerTable" “tableData”表格数组
&lt;el-table :data="tableData" ref="sdangerTable"&gt;&lt;/el-table&gt; js部分 挂载
mounted() { this.tablescroll(); }, //自动滚动及鼠标移入移出方法一致
//滚动方法 tablescroll() { clearInterval(this.interval); const table = this.$refs.sdangerTable; const divData = table.bodyWrapper; this.interval = setInterval(() =&gt; { divData.scrollTop += 1 if (divData.clientHeight + divData.scrollTop + 1 &gt; divData.scrollHeight) { if (table.tableData.length &gt; 6) { divData.scrollTop = 0; } } }, 100); const that = this; window.onresize = () =&gt; { return (() =&gt; { window.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8edfb7d56e217f6e546e2ac0073380ca/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/83/">«</a>
	<span class="pagination__item pagination__item--current">84/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/85/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>