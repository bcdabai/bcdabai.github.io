<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3256a7b733d8a1c970dedb44ca01ee97/" rel="bookmark">
			es-删除字段-实测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		es字段一旦创建是无法删除的，本案的方案是复制新老索引的方法
一、背景 现有索引 index1,待删除字段field1和extendMap.field2，es版本6.3.2
二、步骤 1、删除index1中的filed1和extendMap.field2两个字段的数据
POST index1/_update_by_query { "query":{ "bool":{ "must":[ { "exists":{ "field":"field1" } } ] } }, "script": "ctx._source.remove('field1')" } POST index1/_update_by_query { "query":{ "bool":{ "must":[ { "exists":{ "field":"extendMap.field2" } } ] } }, "script": "ctx._source.extendMap.remove('field2')" } 2、新建index2，map中不要有上述待删除字段
3、拷贝index1到index2
POST _reindex { "source": { "index": "index1" }, "dest": { "index": "index2" } } 4、删除index1
DELETE index1 5、新建index1，map中不要有上述待删除字段
6、拷贝index2到index1
POST _reindex { "source": { "index": "index2" }, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3256a7b733d8a1c970dedb44ca01ee97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c559cd5ec4dae1ea2447fc790b38e112/" rel="bookmark">
			Leetcode：128. 最长连续序列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		128. 最长连续序列
乍一看感觉很简单，一看要用O(n)???
因为我觉得题目很难而且题目看起来很简单，感觉以后会用到😆，做个记录
1.朴素做法 思路
答:任何一段连续的数都有一个左端点：比如（1，2，3，4）的左端点是1，且找到1之后，发现（1，2，3，4）为最长的连续区间，那么从2，3，4为左端点的区间都不需要继续尝试了，因为他们都比1为左端点的区间短。
那么我们只需要找所有的左端点，然后不停比较更新即可。 怎么找左端点？只要没有比它更小的数，那么就是左端点：比如[100,1,3,2,4],这个数组有两个左端点：100，1。用哈希表空间换时间，这样就不需要每次找到一个数，然后去for循环判断有没有比他小的数以及他后面接着几个连续的数 class Solution { public: int longestConsecutive(vector&lt;int&gt;&amp; nums) { int n=nums.size(); unordered_set&lt;int&gt;Hash; //set只有一个参数，然后去重，重复的键值不会被插入 for(int i=0;i&lt;n;i++) Hash.insert(nums[i]); int ans=0; for(int i=0;i&lt;n;i++) { if(Hash.find(nums[i]-1)!=Hash.end())//num[i]-1存在，nums[i]不是左端点 continue; else { int x=nums[i]+1; //nums[i]是左端点，从x开始尝试找 int len=1; while(Hash.find(x)!=Hash.end()) { x++; len++; } ans=max(ans,len); } } return ans; } }; 2.并查集 思路
将连接在一起的数放在一个集合，且这个集合的根节点是当前集合最大的数 这里也用到左端点的思路，而且优化了并查集，一步到位。 class Solution { public: unordered_map&lt;int,int&gt; a; int find(int x) //找到该元素集合的根节点+路径压缩 { if(a.count(x)) { a[x]=find(a[x]); return a[x]; } else return x; //return a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c559cd5ec4dae1ea2447fc790b38e112/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fac8c5126abc5eea456e5b2649e9ee82/" rel="bookmark">
			新闻每天都在更新，那网页上的新闻页面是怎么使用Dreamweaver制作的？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新闻每天都在更新，那网页上的新闻页面是怎么使用Dreamweaver制作的？
新闻有很多种，但大多数结构都差不多，我们就先做一个简单的新闻页面，如图1中画圈圈的新闻内容。
图1
案例实现 新闻页面一般由四个部分构成，分别为标题、发布日期、水平线和网页正文。其中标题使用&lt;h2&gt;标签定义，发布日期和网页正文用&lt;p&gt;标签定义，水平线用&lt;hr/&gt;标签定义。样式分析 （1）标题：因为图中标题是文字靠左，因此&lt;h2&gt;标签不需要添加align属性，因为不添加的话，默认文本是靠左的。但&lt;h2&gt;标签中要嵌套&lt;font&gt;标签，添加字体即face=”微软雅黑”,用于设置标题文本的特殊字体。
（2）发布日期：因为图中字体向左靠拢，因此也不需要添加align属性，只需要添加文本的字体，即face=”微软雅黑”。观察可以发现日期的颜色不一样，因此还需要在添加一个&lt;font&gt;标签来控制文本颜色。
（3）水平线：图中水平线比较浅，但还是有。我们可以使用&lt;hr/&gt;标签中的size、color属性来控制水平线的粗细和颜色。
（4）网页正文：图上并没有做过多的修饰，只是把文字叙述出来，因此我们只需要一个&lt;p&gt;标签就可以了。
3.开始搭建网页结构
我们已经分析了新闻页面的样式，但是需要注意一点，我们可以发现网页中文本之间会有距离，网页中表示空格的代码之一是&amp;nbsp;。因此我们只要在想要文本输入&amp;nbsp;，保存刷新就会出现空格了。现在我们开始写代码，写完代码后如图2.
图2
保存并浏览，如图3.
图3
二．以上就是网页上新闻页面用Dreamweaver制作的内容了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8358990a821ff568cfbed4ff2cb0589d/" rel="bookmark">
			HttpServletRequest getServerPort()、getLocalPort() 、getRemotePort() 区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		getRemotePort() 、getServerPort()、getLocalPort() request.getServerPort()、request.getLocalPort() 和 request.getRemotePort() 这三个方法都是获取与HTTP请求相关的端口信息的
客户端(如浏览器)通过某个随机分配的网络连接端口(7070)
向服务器发送HTTP请求( http://example.com:8080/app/somepage.jsp)连接到服务器端口(8080)。
反向代理或负载均衡场景下，请求可能从端口(8080)转发到另一个端口(9090)进行处理。
request.getRemotePort()： 发起请求的客户端所使用的端口号 7070
request.getServerPort()： 浏览器发送请求时连接到的服务器端口 8080
request.getLocalPort()： 当前处理请求的服务器上的本地端口 9090
request.getRemoteHost()、getServerName()、getLocalName()区别 request.getRemoteHost()： 返回客户端主机的名称，而不是直接的IP地址 实现机制通常是通过DNS反向查询 request.getRemoteAddr() 返回的IP地址以得到对应的主机名。如果反向解析失败、出于性能原因未进行反向解析、没有进行DNS查询的能力，可能会返回与 getRemoteAddr() 相同的IP地址，或者在某些情况下返回 null。
request.getServerName()： 客户端请求时所使用的服务器域名或IP地址 http://example.com:8080/app/somepage.jsp 访问时就是"example.com"
http://192.168.0.1:8080/app/somepage.jsp 访问时就是"192.168.0.1"
request.getLocalName()： 当前处理请求的服务器的本地主机名或IP地址，在多宿主环境、有反向代理、负载均衡器的情况下，这个值可能与客户端直接连接的主机名或IP不同。 假设服务器的本地主机名是 “local-server” 或者内部IP地址是 “10.0.0.5”，那么返回就是 “local-server” 或"10.0.0.5"
getRemoteAddr()、getLocalAddr()区别 request.getRemoteAddr()： 发起HTTP请求的客户端（例如浏览器）的IP地址 在实际应用中，如果存在反向代理、负载均衡器等网络组件时，可能需要通过特定的HTTP头（如 X-Real-IP 或 X-Forwarded-For）来获取真实的客户端IP地址，因为这些网络组件可能会修改原始请求的来源信息。
request.getLocalAddr()： 当前处理请求的服务器接口绑定的IP地址 在多网络接口、多宿主配置的服务器上，这个值会是接收并处理当前请求的那个网络接口的IP地址。
用户通过浏览器（设备IP地址是 103.56.78.90）访问部署在服务器上的Web应用（IP地址 192.168.1.10，监听端口 8080）
request.getRemoteAddr() ： “103.56.78.90”
request.getLocalAddr() ： “192.168.1.10”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f2a5dbff372ac12d706358f26c8a918/" rel="bookmark">
			Skywalking链路追踪
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、简介1.1、APM系统1.2、SkyWalking 简介 二、快速入门2.1、下载、启动2.2、界面认识 三、持久化存储四、告警通知五、自定义追踪-细粒度追踪service方法 一、简介 1.1、APM系统 APM（Application Performance Monitoring）系统是一种用于监控和管理应用程序性能的工具。它可以帮助开发人员和运维团队实时监控应用程序的性能指标、识别潜在的性能问题，并提供性能优化建议。
APM系统可以帮助用户及时发现和解决应用程序的性能问题，提升用户体验和系统稳定性。它可以应用于各种类型的应用程序，包括Web应用、移动应用、微服务架构等。
1.2、SkyWalking 简介 SkyWalking是一个开源的应用性能监控（APM）系统，用于监控和管理分布式系统的性能。它提供了实时的性能指标、事务追踪、服务依赖分析等功能，帮助开发人员和运维团队快速定位和解决性能问题。
SkyWalking的核心功能包括：
分布式追踪：SkyWalking可以追踪分布式系统中的请求流程，记录每个请求经过的服务和组件，以及请求在每个组件中的耗时情况。通过分析追踪数据，可以了解系统中各个组件之间的调用关系和性能瓶颈，帮助开发人员快速定位和解决问题。
实时监控：SkyWalking提供实时的性能监控指标，包括各个服务的请求量、响应时间、错误率等。通过监控数据，可以及时发现系统的性能问题，并进行调优和优化。
服务依赖分析：SkyWalking可以分析系统中各个服务之间的依赖关系，包括调用关系和数据流向。通过可视化的方式展示服务之间的依赖关系，可以帮助开发人员理解系统的架构和流程，从而更好地进行系统设计和优化。
告警和报警：SkyWalking可以设置各种告警规则，当系统出现异常或性能下降时，可以及时发送告警通知。这样可以帮助运维人员快速响应和解决问题，保证系统的稳定性和可靠性。
数据可视化：SkyWalking提供丰富的数据可视化功能，可以将监控数据以图表的形式展示，帮助用户更直观地了解系统的性能和运行情况。同时，还可以根据需求自定义仪表盘，将关键指标集中展示，方便用户监控和管理系统。
二、快速入门 2.1、下载、启动 前提：要有java环境
下载链接: https://skywalking.apache.org/downloads/
我这边使用9.3版本的apm项目
还要再下载 agent，skywalking apm是服务端，agent才是真正监控应用的探针。
这里是监控java服务，所以下载的是java agent，如果是前端可以下载 javaScript
还需要再下载elasticsearch，用于存储记录
下载链接: https://www.elastic.co/cn/downloads/elasticsearch
1、启动apm系统：
window直接进入apm项目里面bin目录下的startup.bat文件，linux 则执行 sh startup.sh
修改启动端口：进入webapp目录下，修改yml文件
启动后访问 http://localhost:8080
2、启动agent：
在我们自己的项目上，注意是我们自己开发的项目，不是skywalking的，在启动参数上加上配置：
指定到agent的jar包的位置
-javaagent:D:\code\tool\skywalking-agent\skywalking-agent.jar -Dskywalking.agent.service_name=skywalking-service -Dskywalking.collector.backend_service=127.0.0.1:11800 -javaagent：指定skywalking中的agent中的skywalking-agent.jar的路径
-Dskywalking.agent.service_name：指定在skywalking中的服务名称，一般是微服务的spring.application.name
-Dskywalking.collector.backend_service：指定oap服务绑定的地址，由于陈某这里是本地，并且oap服务默认的端口是11800，因此只需要配置为127.0.0.1:11800
如我在idea上添加VM options配置
项目启动完毕，再次刷新http://localhost:8080/，apm项目，就可以看到服务注册进来了
微服务启动就是，每个服务也都写上那个配置即可，需要更换名称。
如果报下面错误，则可以将classpath更换成JAR manifest
2.2、界面认识 点击服务名称，可进入更详细的监控界面
概览（Overview）：提供整体系统的概览信息，包括各个服务的调用量、成功率、延迟等指标的总览。
实例（Instance）：查询和监控系统中的实例，可以查看每个实例的性能指标、调用情况等信息。
端点（Endpoint）：查询和监控系统中的端点（API、方法等），可以查看每个端点的调用量、成功率、延迟等指标。
拓扑（Topology）：展示系统中各个服务之间的调用关系和依赖关系，可以帮助理解系统的架构和调用流程。
链路追踪（Trace）：查询和监控系统中的请求链路，可以查看每个请求的详细信息，包括调用链路、耗时、异常等。
链路追踪分析（Trace Profiling）：对链路追踪数据进行分析和优化，可以查看每个请求的性能瓶颈、调用路径等信息。
eBPF Profiling：使用eBPF技术对系统进行性能分析和优化，可以查看系统的运行状态、资源使用情况等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f2a5dbff372ac12d706358f26c8a918/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/714907ea878ac2fa8063af3e88917c4f/" rel="bookmark">
			微服务入门 | 项目分割 | 远程调度Feign | 用户中心erueka 和 nacos
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		认识微服务 微服务架构演变： 单体架构：所有功能集中在一个项目中开发，打成一个包部署
分布式架构：就是各功能模块的代码不在同一个项目中写了，到时候修改其中一个过能的代码，对另一个功能完全没有任何影响（如果在一个项目中，修改这个功能的代码，就得将所有功能代码给重新编译）
服务治理 问题：
服务拆分力度
服务集群地址如何维护
服务之间如何实现远程 调用
服务健康状态如何感知
微服务 良好架构设计的分布式架构方案，微服务架构特征：
单一职责：功能单一
面向服务：对外暴露接口（让其他服务调用）
自治：团队独立，技术独立，数据独立，部署独立
隔离降级：服务做好隔离，容器，降级，避免出现级联问题
维护服务节点信息 – 注册中心
微服务配置的修改 – 配置中心
用户访问的微服务 – 服务网关
微服务间调用报错 – 服务保护
微服务入门案例 服务拆分与远程调用 服务拆分 拆分原则 这里我总结了微服务拆分时的几个原则：
不同微服务，不要重复开发相同业务微服务数据独立，不要访问其它微服务的数据库微服务可以将自己的业务暴露为接口，供其它微服务调用
入门案例 创建父项目 导入依赖： &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.12.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.zjh&lt;/groupId&gt; &lt;artifactId&gt;cloud-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;cloud-demo&lt;/name&gt; &lt;description&gt;cloud-demo&lt;/description&gt; &lt;!--父工程--&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/714907ea878ac2fa8063af3e88917c4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d3169c15676f149d59e784328f7c3e1/" rel="bookmark">
			面试经典150题(88-89)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		leetcode 150道题 计划花两个月时候刷完，今天（第四十四天）完成了2道(88-89)150：
88.(22. 括号生成) 题目描述：
数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。 输入：n = 3 输出：["((()))","(()())","(())()","()(())","()()()"] 第一版（没通过，我想法是 （）的全排列然后找出来符合的并且去重。。超时了）
class Solution { List&lt;String&gt; res=new ArrayList(); Set&lt;String&gt; set=new HashSet(); public List&lt;String&gt; generateParenthesis(int n) { if(n&lt;1){ return res; } StringBuilder sb=new StringBuilder(); for(int i=0;i&lt;n;i++){ sb.append("()"); } boolean[] used=new boolean[n*2]; generateCore(sb.toString(),new StringBuilder(),used); return res; } public void generateCore(String str,StringBuilder sb,boolean[] used){ if(sb.length()==str.length()){ if(check(sb.toString())&amp;&amp;set.add(sb.toString())){ res.add(sb.toString()); } return ; } for(int i=0;i&lt;str.length();i++){ if(used[i]){ continue; } sb.append(str.charAt(i)); used[i]=true; generateCore(str,sb,used); used[i]=false; sb.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d3169c15676f149d59e784328f7c3e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d67b1eeb871b37da2b493590dc5ee039/" rel="bookmark">
			VLAN区域间路由详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LAN局域网
WAN 广域网
WLAN无线局域网
VLAN:虚拟局域网
交换机和路由器，协同工作后，将原来的一个广播域，切分为多个，节省硬件成本；
配置思路：
交换机上创建vlan交换机上的各个接口划分到对应的vlan中 Trunk（中继）干道 ---SW-SW SW-routervlan间的路由--路由器的子接口 、 多层交换机的SVI接口 配置命令：
交换机上创建vlan 编号0-4095 由12位二进制构成 默认存在vlan1，且默认交换机上所有接口处于vlan1；
[sw1]vlan 3 单个创建
[sw1-vlan3]q
[sw1]vlan batch 4 to 10 15 to 20 批量创建
[sw1]undo vlan batch 4 to 20 删除vlan
交换机上的接口划分到对应的vlan中 [sw1]interface Eth0/0/1
[sw1-Ethernet0/0/1]port link-type access 先将该接口修改为接入模式
[sw1-Ethernet0/0/1]port default vlan 2 再将该接口划分到对应的vlan中
[sw1]port-group group-member Ethernet 0/0/3 to Ethernet 0/0/4 Ethernet 0/0/7 to Ethernet 0/0/10
[sw1-port-group]port link-type access
[sw1-port-group]port default vlan 3 批量划分
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d67b1eeb871b37da2b493590dc5ee039/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5197a9f5faa5cab08a92931364d11ecf/" rel="bookmark">
			Linux学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux 本章目标 Linux简介
Linux 文件与目录管理操作
Linux 文件编辑
Linux 文件基本属性
压缩文件操作
下载安装软件
其它命令
安装jdk
安装Tomcat
本章内容 Centos7下载
VMware 安装 Centos7
一、Linux简介 Linux的前身是赫尔辛基大学（University of Helsinki）一位名叫Linus Torvald（林纳斯）的计算机科学系学生的个人项目，他把Linux建立在一个基于PC机上运行的、名为Minux的Unix基础之上。
作者阐述
Linux 是Unix克隆或Unix风格的操作系统，在原代码级上兼容绝大部分Unix标准，是一个支持多用户、多进程、多线程，功能强大而稳定的操作系统。
它可以运行在x86PC，Sun Sparc，Digital Alpha，PowerPC，MIPS等平台上，是目前运行硬件平台最多的操作系统。
它是GNU的一员，遵循公共版权许可证(GPL)，秉承“自由的思想，开放的源码”原则，众多电脑专家和爱好者通过互联网在不断地完善并维护它
1、UNIX与Linux的关系 UNIX是历史最悠久的通用操作系统。1969年，美国贝尔实验室的K.Thompson和 D.M.Ritchie在规模较小及较简单的分时操作系统 MULTICS的基础上开发出UNIX, 当时是在DEC的PDP—7小型计算机上实现的，1970年正式投入运行。
而Linux是一套免费使用和自由传播的类Unix操作系统，它主要用于基于Intel x86系列CPU的计算机上。这个系统是由全世界各地的成千上万的程序员设计和实现的。其目的是建立不受任何商品化软件的版权制约的、全世界都能自由使用的Unix兼容产品。
linux是借鉴 unix的优点或说是核心程序等开发的更贴近现在需要的操作系统。
unix 是针对服务器的，linux 除了针对服务器，也更侧重了大众使用的操作系统。
简单的说linux是unix升级版 就像微软的XP2和95
2、Linux的特点 完全免费。
高效、安全、稳定。
支持多种硬件平台、开放性。
多用户、多任务。
虚拟内存、X Window系统。
强大的网络功能。
动态链接共享库。
设备独立性、支持多种文件系统。
同IEEE POSIX.1标准兼容。
非专有资源代码。
费用低于大多数Unix系统，如果有耐心和时间，可以从Internet上把Linux下载下来。
GNU软件支持。
可靠的系统安全
3、Linux的结构 Linux一般有3个主要部分：内核（kernel）、命令解释层（SHELL或其它操作环境）、文件结构（file structure）。
（1）Linux内核 内核是系统的心脏，是运行程序和管理磁盘和打印机等硬件设备的核心程序。操作环境向用户提供一个操作界面，它从用户那里接受命令，并且把命令送给内核去执行。
（2）Linux SHELL SHELL是系统的用户界面，提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令，并且把它送入内核去执行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5197a9f5faa5cab08a92931364d11ecf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7685ac6eb5893f9d3e31ebaa7d7f6af6/" rel="bookmark">
			Python算法例36 丑数Ⅱ
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 问题描述 设计一个算法，找出只含素因子2、3、5的第n小的数，符合条件的数如：1、2、3、4、5、6、8、9、10、12…
2. 问题示例 如果n=9，返回10。
3. 代码实现 def find_nth_number(n): if n &lt;= 0: return None numbers = [1] idx2 = 0 # 索引指向最后一个乘以2的数 idx3 = 0 # 索引指向最后一个乘以3的数 idx5 = 0 # 索引指向最后一个乘以5的数 for _ in range(1, n): next_num = min(numbers[idx2] * 2, numbers[idx3] * 3, numbers[idx5] * 5) numbers.append(next_num) if next_num == numbers[idx2] * 2: idx2 += 1 if next_num == numbers[idx3] * 3: idx3 += 1 if next_num == numbers[idx5] * 5: idx5 += 1 return numbers[-1] print(find_nth_number(9)) # 输出：10 print(find_nth_number(15)) # 输出：24 上述代码使用“丑数”算法（Ugly Number Algorithm）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7685ac6eb5893f9d3e31ebaa7d7f6af6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a76dd7b3969c53f7ff9c7479ea0c68e/" rel="bookmark">
			翻译: Streamlit从入门到精通 高级用法缓存Cache和Session 五
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Streamlit从入门到精通 系列：
翻译: Streamlit从入门到精通 基础控件 一翻译: Streamlit从入门到精通 显示图表Graphs 地图Map 主题Themes 二翻译: Streamlit从入门到精通 构建一个机器学习应用程序 三翻译: Streamlit从入门到精通 部署一个机器学习应用程序 四
现在您已经了解了 Streamlit 应用程序如何运行和处理数据，让我们来谈谈效率。缓存允许您保存函数的输出，以便在重新运行时跳过它。会话状态允许您保存在重新运行之间保留的每个用户的信息。这不仅可以避免不必要的重新计算，还可以创建动态页面并处理渐进式流程。
1. Caching 缓存 Streamlit 缓存使您的应用程序即使在从 Web 加载数据、操作大型数据集或执行昂贵的计算时也能保持性能。
缓存背后的基本思想是存储成本高昂的函数调用的结果，并在再次出现相同的输入时返回缓存的结果，而不是在后续运行时调用函数。
要在 Streamlit 中缓存函数，您需要使用以下两个装饰器（st.cache_data 和 st.cache_resource）之一来装饰它：
@st.cache_data def long_running_function(param1, param2): return … 在此示例中，使用 @st.cache_data 装饰long_running_function告诉 Streamlit，每当调用该函数时，它都会检查两件事：
输入参数的值（在本例中为 param1 和 param2）。函数内部的代码。 如果这是 Streamlit 第一次看到这些参数值和函数代码，它会运行该函数并将返回值存储在缓存中。下次使用相同的参数和代码调用函数时（例如，当用户与应用程序交互时），Streamlit 将完全跳过执行该函数并返回缓存的值。在开发过程中，缓存会随着函数代码的变化而自动更新，从而确保最新的更改反映在缓存中。
如前所述，有两个缓存装饰器：
st.cache_data 是缓存返回数据的计算的推荐方法：从 CSV 加载 DataFrame、转换 NumPy 数组、查询 API 或任何其他返回可序列化数据对象的函数（str、int、float、DataFrame、array、list 等）。它会在每次函数调用时创建一个新的数据副本，使其免受突变和竞争条件的影响。st.cache_data的行为是您想要的——所以如果您不确定，请从st.cache_data开始，看看它是否有效！st.cache_resource 是缓存全局资源（如 ML 模型或数据库连接）的推荐方法，这些资源是您不想多次加载的不可序列化对象。使用它，您可以在应用程序的所有重新运行和会话之间共享这些资源，而无需复制或复制。请注意，对缓存返回值的任何突变都会直接改变缓存中的对象（更多详细信息见下文）。 有关 Streamlit 缓存装饰器、其配置参数及其限制的详细信息，请参阅缓存。
2. Session State 会话状态 会话状态提供了一个类似于字典的界面，您可以在其中保存在脚本重新运行之间保留的信息。使用带有键或属性表示法st.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a76dd7b3969c53f7ff9c7479ea0c68e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcb595a58e5709ae116c5967f8867a92/" rel="bookmark">
			Python安装超详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文将介绍以下几部分内容：
下载 python安装 python配置环境变量python 多版本共存配置python 编程工具推荐 一、下载 python 下载 python 点击这里 进入 python 下载页面
在下载页面可以看到很多不同版本的下载链接。其中，标记 x86 的为 32 位安装包，x86-64 为 64 位安装包。executable installer为完整的安装包，下载完即可安装；web-based installer 体积更小，但安装时仍需联网下载其他部分。一般网络不好时选择 executable installer，以保证安装过程不会中断。
python下载官网
操作系统的位数可通过以下操作确定：右击此电脑 -&gt; 点击属性 -&gt; 查看位数
查看操作系统位数（1）
查看操作系统位数（2）
因篇幅有限，仅展示部分资料，需要的同学用vx扫描上方二维码即可获取‘
python 版本简介 python 包括 python2、python3 两个大版本，其中 python3 改进了 python2 的一些不足，但由于以前很多应用是用 python2 开发的，维护这些应用还需用到 python2，故 python2 尚未被完全淘汰。
此外，版本也不是越高越好，因为有的模块（库）不支持太高版本的 python。
二、安装 python 1.打开安装包所在文件夹，双击开始安装。
安装步骤1
2.勾选 "Add Python to PATH" 复选框，点击 "Customize installaion"。
安装步骤2
3.保持默认设置，点击 "next"。
安装步骤3
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcb595a58e5709ae116c5967f8867a92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df518b73ce50549bb145e2a9ecdbe547/" rel="bookmark">
			HarmonyOS—声明式UI描述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ArkTS以声明方式组合和扩展组件来描述应用程序的UI，同时还提供了基本的属性、事件和子组件配置方法，帮助开发者实现应用交互逻辑。
创建组件 根据组件构造方法的不同，创建组件包含有参数和无参数两种方式。
说明
创建组件时不需要new运算符。
无参数 如果组件的接口定义没有包含必选构造参数，则组件后面的“()”不需要配置任何内容。例如，Divider组件不包含构造参数：
Column() { Text('item 1') Divider() Text('item 2') } 有参数 如果组件的接口定义包含构造参数，则在组件后面的“()”配置相应参数。
Image组件的必选参数src。 Image('https://xyz/test.jpg') Text组件的非必选参数content。
// string类型的参数 Text('test') // $r形式引入应用资源，可应用于多语言场景 Text($r('app.string.title_value')) // 无参数形式 Text() 变量或表达式也可以用于参数赋值，其中表达式返回的结果类型必须满足参数类型要求。
例如，设置变量或表达式来构造Image和Text组件的参数。
Image(this.imagePath) Image('https://' + this.imageUrl) Text(`count: ${this.count}`) 配置属性 属性方法以“.”链式调用的方式配置系统组件的样式和其他属性，建议每个属性方法单独写一行。
配置Text组件的字体大小。 Text('test') .fontSize(12) 配置组件的多个属性。
Image('test.jpg') .alt('error.jpg') .width(100) .height(100) 除了直接传递常量参数外，还可以传递变量或表达式。
Text('hello') .fontSize(this.size) Image('test.jpg') .width(this.count % 2 === 0 ? 100 : 200) .height(this.offset + 100) 对于系统组件，ArkUI还为其属性预定义了一些枚举类型供开发者调用，枚举类型可以作为参数传递，但必须满足参数类型要求。
例如，可以按以下方式配置Text组件的颜色和字体样式。
Text('hello') .fontSize(20) .fontColor(Color.Red) .fontWeight(FontWeight.Bold) 配置事件 事件方法以“.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df518b73ce50549bb145e2a9ecdbe547/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d170e0296b2900b14d1399a744d68907/" rel="bookmark">
			AI绘画认识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是AI绘画 AI绘画是指利用人工智能技术进行绘画创作的过程，它使用机器学习算法和深度神经网络等技术，通过对现有艺术品、图像等大量数据进行分析和学习，生成新的艺术品或图像。
AI绘画的应用场景非常广泛，包括数字艺术、游戏、电影等领域。其实现方式可以是基于规则的方法，也可以是基于神经网络的方法，其中基于神经网络的方法更加高效和精准。AI绘画的发展对于提高艺术创作的效率、扩展人类艺术表达的范围和方式具有重要意义。
当前主流的AI绘画应用有StableDiffusion、DALL·E和Midjourney。
AI绘画的应用领域 AI绘画具有广阔的应用前景和市场价值。以下是一些可能的应用领域：
艺术创作：AI绘画可以帮助艺术家扩展创作的可能性，提供新的创意和风格，促进艺术的创新和发展。
设计行业：AI绘画可以应用于室内设计、产品设计、平面设计等领域，通过生成和优化设计方案，提高设计效率和质量。
印刷包装设计：AI绘画可以辅助印刷包装设计，生成符合要求的图案和排版，提高生产效率。
电商拍摄与修图：AI绘画可用于自动化产品拍摄和修图，减少人工劳动和时间成本，提高产品展示效果。
商业设计：AI绘画能够满足中低端商业设计需求，为小型企业和个人提供定制化的设计服务。
教育绘画培训：AI绘画可以在教育领域应用，辅助学生学习绘画技巧和表达能力，提供个性化的指导和反馈。
虚拟数字创作：AI绘画可用于虚拟数字人物和虚拟空间的创作，增强虚拟世界的真实感和视觉效果。
元宇宙：AI绘画有望在元宇宙中发挥重要作用，为虚拟世界提供丰富多样的艺术和设计内容，创造沉浸式体验。
总体而言，AI绘画将改变传统艺术、设计和创作的方式，提升效率和创意，为各个行业带来更多机遇和发展空间。
AI绘画的现状与争议 AI绘画目前面临一些现状和争议，其中包括：
版权问题：由于AI绘画需要使用大量的数据进行训练，其中可能包含未经授权的图片。这引发了对于生成图像的版权归属问题，目前尚未有明确的法律规定和界定。因此，确立AI绘画作品的版权归属权是一个争议的焦点。
创意与人工智能的关系：一些艺术家和设计师对于AI绘画表示担忧，担心其会影响人类创意和独特性。他们认为，AI绘画虽然可以提供便利和效率，但缺乏真正的情感和灵感，无法替代人类的艺术创作过程。
社会接受度和认可：AI绘画作品在艺术界和大众中的认可度尚不明确。一些人可能对其持怀疑态度，认为AI绘画作品缺乏真实性和原创性。因此，推动社会对于AI绘画的接受度和认可度仍然是一个挑战。
法律和监管：AI绘画行业处于法律空白地带，传统法律无法完全适用。需要制定相关法律和监管措施，以保护创作者的权益，规范市场秩序。
解决这些现状和争议是AI绘画行业发展的关键。通过明确版权归属、加强创意与人工智能的结合、提升社会认可度，并建立相应的法律和监管框架，可以推动AI绘画行业朝着良性发展的方向前进。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08cc48fd76580fdd63ed344fe3b828f5/" rel="bookmark">
			Eclipse搭建python环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、下载eclipse eclipse官网下载参考链接
二、 下载PyDev ​PyDev
三、安装和配置pyDev 下载完PyDev，解压之后是下面两个文件夹，我下载的版本是PyDev 7.7 ,然后拷到eclipse对应的目录下就可以
四、然后新建一个python程序 1.新建一个项目 ​​​​
2.右击项目新建文件 3.写程序 ，运行 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63d1618776c7bda40e64929b31e610ba/" rel="bookmark">
			vue3 实现简单计数器示例——一个html文件展示vue3的效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目的：作为一个新手开发，我想使用 Vue 3 将代码封装在 HTML 文件中时，进行界面打开展示。
一、vue计数示例 学了一个简单计数器界面展示，代码如下：
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;div id="app"&gt; &lt;h1&gt;alllalalallalal 默认会被覆盖&lt;/h1&gt; &lt;/div&gt; &lt;template id="why"&gt; &lt;div&gt; &lt;h2&gt;{{message}}&lt;/h2&gt; &lt;h2&gt;{{counter}}&lt;/h2&gt; &lt;button @click="increment"&gt;+1&lt;/button&gt; &lt;button @click="decrement"&gt;-1&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;body&gt; &lt;!-- 以下是四种引入vue依赖库的方式 --&gt; &lt;!-- 引入 Vue 3 的 CDN 资源网络加载不了 加载慢--&gt; &lt;!-- &lt;script src="https://unpkg.com/vue@next"&gt;&lt;/script&gt; --&gt; &lt;!-- 引入 Vue 3 的 CDN 资源 公司网络加载不了 无用--&gt; &lt;!--&lt;script src="https://cdn.jsdelivr.net/npm/vue@3"&gt;&lt;/script&gt;--&gt; &lt;!-- 引入 Vue 3 的 CDN 资源 公司网络能加载 有用 --&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63d1618776c7bda40e64929b31e610ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7c640d9633c6db2e8c17c36572d3662/" rel="bookmark">
			算法 - 二叉树 / 图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 🍺 二叉树🍻 搜索树🥂 96. 不同的二叉搜索树 [搜索树] [种类] (递归) 🍻 栈🥂 94. 二叉树的中序遍历 [二叉树] [遍历] (栈) (迭代)🥂 144. 二叉树的前序遍历 [二叉树] [遍历] (栈) (迭代)🥂 145. 二叉树的后序遍历 [二叉树] [遍历] (栈) (迭代) 🍺 图🍻 并查集🥂 130. 被围绕的区域 [矩阵] [岛屿] (并查集)🥂 261. 以图判树 [图] [树] [环] (并查集)🥂 305. 岛屿数量Ⅱ [矩阵] [岛屿] (并查集) (从0增加count)🥂 323. 无向图中连通分量的数目 [图] [连通分量] (并查集)🥂 990. 等式方程的可满足性 [等式] (并查集)🥂 1135. 最低成本连通所有城市 [图] [权重和] (并查集) (贪心) 🍺 二叉树 🍻 搜索树 🥂 96.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7c640d9633c6db2e8c17c36572d3662/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/348ef7078bc2e780c907b35d8ab8dfff/" rel="bookmark">
			GStreamer基础介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GStreamer 是一个开源的多媒体框架，用于构建和处理各种多媒体应用。它提供了一组用于创建、配置和处理音频、视频、图像和其他多媒体数据流的库和工具。GStreamer 设计为灵活且可扩展的，使开发者可以构建各种多媒体应用，包括音频/视频播放器、流媒体服务器、音视频编辑器等。
GStreamer和ffmpeg一样，可以在多个操作系统上运行，包括 Linux、Windows、macOS 等。
GStreamer 使用插件体系结构，这就允许用户通过添加插件来扩展其功能。GStreamer 使用管道模型来组织和处理多媒体数据。典型的 GStreamer 管道包括源元素、过滤器元素和目标元素，通过连接这些元素来实现数据流。GStreamer 提供了丰富的解码器、编码器、滤镜、混音器等元素。
#include &lt;gst/gst.h&gt; int main(int argc, char *argv[]) { // 初始化 GStreamer gst_init(&amp;argc, &amp;argv); // 创建主循环上下文 GMainLoop *loop = g_main_loop_new(NULL, FALSE); // 创建一个新的管道 GstElement *pipeline = gst_pipeline_new("my-pipeline"); // 创建音频采集元素 GstElement *audioSrc = gst_element_factory_make("autoaudiosrc", "audio-source"); // 创建音频编码元素 GstElement *audioEncoder = gst_element_factory_make("lamemp3enc", "audio-encoder"); // 创建音频解码元素 GstElement *audioDecoder = gst_element_factory_make("mpg123audiodec", "audio-decoder"); // 创建音频播放元素 GstElement *audioSink = gst_element_factory_make("autoaudiosink", "audio-sink"); // 创建视频采集元素 GstElement *videoSrc = gst_element_factory_make("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/348ef7078bc2e780c907b35d8ab8dfff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3663a4f6ffced1776ebcad779ab467db/" rel="bookmark">
			复现PointNet（分割网络）：Windows &#43; PyTorch &#43; 部件分割 &#43; 代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、平台 Windows 10
GPU RTX 3090 + CUDA 11.1 + cudnn 8.9.6
Python 3.9
Torch 1.9.1+cu111
所用的原始代码：https://github.com/fxia22/pointnet.pytorch
二、数据 shapenetcore_partanno_segmentation_benchmark_v0
三、代码 分享给有需要的人，代码质量勿喷。
对源代码进行了简化和注释。
不搞原作者的可视化工具，分割结果保存成txt，或者利用 laspy 生成点云。
别问为啥在C盘，问就是2T的三星980Pro
3.1 文件组织结构 3.2 dataset.py 修改了部分txt文件的路径
from __future__ import print_function import os import os.path import numpy as np import sys from tqdm import tqdm import json from plyfile import PlyData, PlyElement import torch import torch.utils.data as data def get_segmentation_classes(root): catfile = os.path.join(root, 'synsetoffset2category.txt') cat = {} meta = {} with open(catfile, 'r') as f: for line in f: ls = line.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3663a4f6ffced1776ebcad779ab467db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b41d7d7f1eaba0f947b85abb89b99db9/" rel="bookmark">
			nodejs使用 Unix domain socket进行IPC通讯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unix domain socket 又叫 IPC(inter-process communication 进程间通信) socket，用于实现同一主机上的进程间通信。socket 原本是为网络通讯设计的，但后来在 socket 的框架上发展出一种 IPC 机制，就是 UNIX domain socket。虽然网络 socket 也可用于同一台主机的进程间通讯(通过 loopback 地址 127.0.0.1)，但是 UNIX domain socket 用于 IPC 更有效率：不需要经过网络协议栈，不需要打包拆包、计算校验和、维护序号和应答等，只是将应用层数据从一个进程拷贝到另一个进程。这是因为，IPC 机制本质上是可靠的通讯，而网络协议是为不可靠的通讯设计的。
UNIX domain socket 是全双工的，API 接口语义丰富，相比其它 IPC 机制有明显的优越性，目前已成为使用最广泛的 IPC 机制，比如 X Window 服务器和 GUI 程序之间就是通过 UNIX domain socket 通讯的。Unix domain socket 是 POSIX 标准中的一个组件，所以不要被名字迷惑，linux 系统也是支持它的。
了解Docker的同学应该知道Docker daemon监听一个docker.sock文件，这个docker.sock文件的默认路径是/var/run/docker.sock，这个Socket就是一个Unix domain socket。
node echo服务器server.js
const net = require('net'); const server = net.createServer((c) =&gt; { // 'connection' listener.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b41d7d7f1eaba0f947b85abb89b99db9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a90608e010c9d5399477a68c104ac614/" rel="bookmark">
			Linux常用命令大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.查看端口号占用 lsof -i:端口号 lsof -i:8060 sudo netstat -nlp | grep 8060 2.查看CPU、核数、磁盘信息 [hadoop@master1 ~]$ cat /etc/redhat-release CentOS Linux release 7.9.2009 (Core) [hadoop@master2 software]$ uname -a Linux master2 3.10.0-1160.76.1.el7.x86_64 #1 SMP Wed Aug 10 16:21:17 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux [hadoop@master2 software]$ arch x86_64 # 总核数 = 物理CPU个数 X 每颗物理CPU的核数 # 总逻辑CPU数 = 物理CPU个数 X 每颗物理CPU的核数 X 超线程数 # 查看物理CPU个数 cat /proc/cpuinfo| grep "physical id"| sort| uniq| wc -l # 查看每个物理CPU中core的个数(即核数) cat /proc/cpuinfo| grep "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a90608e010c9d5399477a68c104ac614/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1007d660bd70b5955b4c1a9d33b6c422/" rel="bookmark">
			使用easyexcel 导出多级表头demo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先看效果：
1、引入maven依赖
&lt;!--EasyExcel --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel&lt;/artifactId&gt; &lt;version&gt;3.2.1&lt;/version&gt; &lt;/dependency&gt; 2、实体类
package com.huawei.it.domain; import com.alibaba.excel.annotation.ExcelIgnore; import com.alibaba.excel.annotation.ExcelProperty; import com.alibaba.excel.annotation.write.style.ColumnWidth; /** * @description: 嫁功率考勤实体类 * @author: yeyong * @create: 2024-01-16 */ public class Jglkq{ @ExcelProperty({"考勤状态"}) private String kqzt; //考勤状态 @ExcelProperty({"日期"}) @ColumnWidth(20) private String rq; //日期 @ExcelProperty({"工号"}) private String gh; //工号 @ExcelProperty({"姓名"}) private String xm; //姓名 @ExcelProperty({"应出勤"}) private String ycq; //应出勤 @ExcelProperty({"实出勤"}) private String scq; //实出勤 @ExcelProperty({"班制名称"}) private String bzmc; //班制名称 @ExcelProperty({"班一","上"}) private String sw; //上 @ExcelProperty({"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1007d660bd70b5955b4c1a9d33b6c422/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/420d1f7fb1049473c04d8db6720022f1/" rel="bookmark">
			FFmpeg简单总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FFmpeg简介 FFmpeg（Fast Forward MPEG）是一个开源跨平台的音视频处理工具库和软件套件，它包括了一系列用于处理多媒体数据的程序和库。FFmpeg 提供了音视频编解码、封装、过滤、流媒体传输等功能，支持多种音频、视频和容器格式，包括但不限于 MP4、AVI、MKV、FLV、MP3、AAC、H.264、H.265 等。
官方文档：ffmpeg document
FFmpeg 可以在多个操作系统上运行，包括 Linux、Windows、macOS 等。
组成部分 libavcodec： 提供了音视频编解码器的库。libavformat： 处理多媒体容器格式的库，包括封装和解封装。libavutil： 包含一些公共的实用工具函数。libswscale： 提供图像缩放和颜色转换功能的库。libavfilter： 实现音视频过滤器的库，用于进行各种音视频处理操作。ffmpeg： 命令行工具，用于进行音视频处理和转码。ffprobe： 用于检测多媒体文件信息的命令行工具。ffplay： 简单的播放器，支持音视频播放。 常用例子 1.转码视频为其他格式：将输入视频文件 input.mp4 转码为 H.264 视频编码和 AAC 音频编码的输出文件 output.mp4。
ffmpeg -i input.mp4 -c:v libx264 -c:a aac output.mp4 2.提取视频中的音频：从输入视频文件 input.mp4 中提取音频并保存为 AAC 格式的文件 output_audio.aac。
ffmpeg -i input.mp4 -vn -c:a copy output_audio.aac 3.剪切视频：从输入视频文件 input.mp4 中剪切出从 1 分钟到 2 分钟 30 秒的部分，并保存为输出文件 output_cut.mp4。
ffmpeg -i input.mp4 -ss 00:01:00 -to 00:02:30 -c:v copy -c:a copy output_cut.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/420d1f7fb1049473c04d8db6720022f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c509f9587144ddfd64231109e51c6f47/" rel="bookmark">
			代码随想录训练营第三十期|第八天|字符串part01|344.反转字符串● 541. 反转字符串II● 卡码网：54.替换数字● 151.翻转字符串里的单词● 卡码网：55.右旋转字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		344. 反转字符串 - 力扣（LeetCode）
class Solution { public void reverseString(char[] s) { int left = 0; int right = s.length - 1; while (left &lt; right) { char tmp = s[left]; s[left] = s[right]; s[right] = tmp; left++; right--; } return; } } 541. 反转字符串 II - 力扣（LeetCode）
class Solution { public String reverseStr(String s, int k) { char[] arr = s.toCharArray(); for (int i = 0; i &lt; arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c509f9587144ddfd64231109e51c6f47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/764f911a1f3797631711614f6e0acd19/" rel="bookmark">
			音视频开发之V4L2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		V4L2（Video for Linux 2）是 Linux 内核中用于视频设备的子系统，提供了统一的接口，使用户空间程序能够与各种视频设备进行通信和控制。V4L2 主要用于处理视频输入设备（例如摄像头）和视频输出设备（例如显示屏等）。
V4L2 提供了一个统一的接口，允许用户空间程序与各种视频设备进行通信，而无需了解底层硬件的具体细节。这使得开发视频应用程序更加方便。 同时V4L2 支持各种不同类型的视频设备，包括摄像头、视频采集卡、Webcam 等。这些设备可以通过 V4L2 接口进行访问和控制。V4L2 支持多种视频和图像格式，包括 YUV 格式、RGB 格式等。V4L2 允许用户从视频设备中采集视频流，并提供了配置和控制相关参数的功能，除了采集视频流，V4L2 还支持将视频流输出到显示设备或其他目标等。
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;fcntl.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/ioctl.h&gt; #include &lt;sys/mman.h&gt; #include &lt;linux/videodev2.h&gt; #define VIDEO_DEVICE "/dev/video0" #define WIDTH 640 #define HEIGHT 480 #define NUM_BUFFERS 4 //打开摄像头设备 int fd = open(VIDEO_DEVICE, O_RDWR); if (fd == -1) { perror("Error opening device"); exit(EXIT_FAILURE); } //设置视频格式 struct v4l2_format fmt = {0}; fmt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/764f911a1f3797631711614f6e0acd19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51a53252428a5eafbec47f04705288b9/" rel="bookmark">
			mmdet代码复现：安装指定版本的mmcv和mmdet以及版本匹配问题。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决mmcv，mmdet环境安装过程中出现的问题。
前言: 如果是复现别人论文里的代码，那么要注意mmdet和mmcv版本匹配的问题。
从论文中把代码下载下来之后首先要看一下项目文件中的mmdet/init.py和mmdet/version.py这两个文件：
这里的__version__指定了项目中使用的mmdet版本，这里作者用mmdet是2.3.0版本。
这里的mmcv_*_version参数指明了所需要的mmcv版本，这里mmcv=1.0.5.
这里的mmcv和mmdet版本一定要对应好，不然会出一些问题。
下面是官方的版本匹配图：
安装指定版本的mmcv和mmdet 知道需要的版本之后开始正式安装过程。
下面简单演示一下安装：
mmcv-full=1.0.5
mmdet=2.3.0
步骤1：安装依赖项和设置环境 在开始配置之前，确保你的系统已经安装了Anaconda或Miniconda。
创建并激活虚拟环境：
conda create --name mmdetection python=3.8 -y conda activate mmdetection 将创建一个Python版本为3.8的虚拟环境，并自动安装所有默认依赖项.
步骤2：安装pytorch 先看一眼mmcv官网的安装要求：https://mmcv.readthedocs.io/zh_CN/latest/get_started/installation.html
看下面图片描述：
然后进入pytorch官网：https://pytorch.org/
找到需要的pytorch 1.6
复制命令到刚刚创建的虚拟环境中安装pytorch:
conda install pytorch==1.6.0 torchvision==0.7.0 cudatoolkit=10.2 -c pytorch 步骤3：安装mmcv-full 安装好pytorch了，进入mmcv官网刚刚打开的页面
可以看一下pytorch安装状态：
python -c 'import torch;print(torch.__version__);print(torch.version.cuda)' 开始安装mmcv 1.0.5：
pip install mmcv-full==1.0.5 -f https://download.openmmlab.com/mmcv/dist/cu102/torch1.6/index.html 正确执行完毕就可以了，一般不用验证。
步骤4：安装mmdet （复现别人的项目中的代码一半不需要这一步，看步骤5） 这里面找到需要的版本：
https://github.com/open-mmlab/mmdetection/tags
下载压缩包解压后，cd 进入mmdetection目录后直接执行：pip install -v -e .完成编译即可。
至此，完整安装了mmcv-full 1.0.5和mmdet 2.3.0。
步骤5：复现代码步骤（不需要单独下载mmdetection） 完成步骤1，2， 3之后，直接进入你所下载的项目目录中，因为框架已经包含了mmdet，，其中mmdet/version.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51a53252428a5eafbec47f04705288b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43c97ee467ada45d6b4e1d0722632389/" rel="bookmark">
			Go Build编译打包文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Go编译打包文件 1、简单打包 程序 main1.go：
package main import "fmt" func main() { fmt.Println("Hello World!") } 打包：
# 在linux服务上执行下面的3个命令 # linux平台,生成main1可执行程序 CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build main1.go # windows平台,生成main1.exe可执行程序 CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build main1.go # mac平台,生成main1可执行程序 CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build main1.go 执行：
$ ./main1 Hello World! 2、打包时为程序中的变量设置值 程序 main2.go ：
package main import "fmt" var ( VERSION string BUILD_TIME string GO_VERSION string ) func main() { fmt.Printf("%s\n%s\n%s\n", VERSION, BUILD_TIME, GO_VERSION) } 打包：打包方式和上面一样，这里只介绍linux下的打包。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43c97ee467ada45d6b4e1d0722632389/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1fde9948afc0ccbeae9ce47a7210668/" rel="bookmark">
			初识微服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、单体结构 VS 分布式结构
二、微服务简介 一、单体结构 VS 分布式结构 单体结构：将所有功能集中在一个项目开发，打包部署。
优点：架构简单，部署成本低；
缺点：耦合度较高。
分布式结构：根据业务功能的具体功能对系统进行拆分，每个业务模块作为独立的项目开发，称为一个服务。
优点：耦合度低，便于业务拓展。
缺点：架构复杂，运维、监控以及部署的难度大。
二、微服务简介 微服务是一种经过良好架构设计的分布式架构方案
微服务架构特征：
单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责，避免重复业务开发；面向服务：微服务对外暴露业务接口；自治：团队独立、技术独立、数据独立、部署独立；隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题。 微服务注意点：
微服务需要根据业务模块拆分，做到单一职责,不要重复开发相同业务微服务可以将业务暴露为接口，供其它微服务使用不同微服务都应该有自己独立的数据库 微服务调用方式:基于RestTemplate发起的http请求实现远程调用，http请求做远程调用是与语言无关的调用，只要知道对方的ip、端口、接口路径、请求参数即可。
服务调用关系：
服务提供者：暴露接口给其它微服务调用
服务消费者：调用其它微服务提供的接口
提供者与消费者角色其实是相对的,一个服务可以同时是服务提供者和服务消费者
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57cc5d01a181e9f8ebb21c8532bff642/" rel="bookmark">
			带头双向循环链表基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		带头双向循环链表基础 销毁 //销毁 void ListDestory(ListNode* phead); void ListDestory(ListNode* phead) { assert(phead); ListNode* cur = phead-&gt;next; while (cur != phead) { ListNode* next = cur-&gt;next; free(cur); cur = next; } free(phead); phead = NULL; } 尾插 //尾插 void ListPushBack(ListNode* phead, LTDataType x); //尾插 void ListPushBack(ListNode* phead, LTDataType x) { assert(phead); /*ListNode* tail = phead-&gt;prev; ListNode* newnode = BuyListNode(x); tail-&gt;next = newnode; newnode-&gt;prev = tail; newnode-&gt;next = phead; phead-&gt;prev = newnode;*/ ListInsert(phead, x); } 头插 //头插 void ListPushFront(ListNode* phead, LTDataType x); //头插 void ListPushFront(ListNode* phead, LTDataType x) { //ListNode* first = phead-&gt;next; //ListNode* newnode = BuyListNode(x); ///*phead-&gt;next = newnode; //newnode-&gt;prev = phead; //newnode-&gt;next = first; //first-&gt;prev = newnode;*/ //newnode-&gt;next = phead-&gt;next; //phead-&gt;next-&gt;prev = newnode; //phead-&gt;next = newnode; //newnode-&gt;prev = phead; ListInsert(phead-&gt;next,x); } 尾删 //尾删 void ListPopBack(ListNode* phead); //尾删 void ListPopBack(ListNode* phead) { /*assert(phead); assert(phead-&gt;next !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57cc5d01a181e9f8ebb21c8532bff642/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b16d82a02924ddab18fe1dc7e2dbd05f/" rel="bookmark">
			VS&#43;QT编译环境中字符乱码问题详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 字符乱码问题详解 1 编码字符集与字符编码方式2 字符乱码原因3 字符乱码解决方案 在解释字符乱码问题之前，我们需要先理清一些基本概念 1 编码字符集与字符编码方式 编码字符集
编码字符集是所有字符以及对应代码值的集合。编码字符集中的每个字符都对应一个唯一的代码值。常见的编码字符集：ASCII字符集、GBXXXX字符集、BIG5字符集、Unicode字符集等。
字符编码方式
编码字符集中只规定了字符的代码值并未规定具体如何存储，字符编码方式解决了字符在计算机中如何存储的问题，它是将编码字符集中的字符代码值转换为实际的存储字节序列的一种映射规则。常见字符编码方式：ASCII编码、GBXXXX编码、BIG5编码、UTF-8编码、UTF-16编码、UTF-32编码等。每种编码字符集至少对应一种字符编码方式，也可以对应多种编码方式。
什么是字符的编码与解码?
编码就是把⼀个字符编码成二进制码存起来的方式，而解码就是把这个二进制码按照原本编码的规则还原成原来的字符。
源字符集： 源文件字符集是指源文件保存时按源字符集编码方式编码后的字符集。VS2019源字符集编码格式默认是GBK格式，在利用VS编写代码时，源代码会自动编码为GBK字符集。
执行字符集： 程序运行时所使用的字符集，编译器会将源字符集先按照源字符集编码方式进行解码，再将解码后得到的字符按照执行字符集编码方式编码为执行字符集。执行字符集一般默认使用Windows系统本地字符编码，若是简体中文系统，则是GBK或GB2312字符集。
2 字符乱码原因 在编程中我们给某个函数输入中文字符串的时候，在运行的时候中文字符串往往就会变成乱码，这是因为编码方式与解码方式不一致造成的。
例：
VS+QT编译环境中，如果直接将中文字符串传给QT函数时，会出现乱码：
QString s("你好");//乱码 qDebug() &lt;&lt; "路漫漫其修远兮";//乱码 原因在于这些中文字符串被GBK编码为源字符集，编译器会先采用GBK将这被GBK编码的源字符集解码，再用GB2312编码为执行字符集，而Qt5内部采用Unicode字符集，UTF-16编码，QT中的函数会将执行字符集使用UTF-8解码，再使用UTF-16编码为unicode字符集，QString内部使用UTF-8对执行字符集进行解码的时候，与执行字符集编码格式不一致，肯定会出现乱码现象。
为什么英文字符就不会出现乱码现象呢？
英文字符通常都是ASCII字符编码，常见的字符编码都会以某种形式“兼容”ASCII编码，而我们接触比较多的UTF-8和GBK则是完全兼容ASCII，也就是ASCII编码的数据，在UTF-8、GBK中会是一样的数字形式（一个字节）。即
AB在ASCII编码中对应的是0x41和0x42，在GB2312和UTF-8中还是0x41和0x42，所以对于AB这两个字符用GB2312编码为0x41和0x42后，采用UTF-8再进行解码，得出来的仍然是AB，所以不会出现乱码。
3 字符乱码解决方案 （1）使用QStringLiteral宏
从“字符串常量”创建QString对象
qDebug() &lt;&lt; QStringLiteral("路漫漫其修远兮"); QStringLiteral宏它只能处理常量。
（2）使用fromLocal8Bit()函数
fromLocal8Bit是Qt 中QString 类的一个成员函数，用于将使用本地编码的字符串转换为 QString 对象的内部 Unicode编码。
qDebug() &lt;&lt; QString::fromLocal8Bit("路漫漫其修远兮"); 使用QStringLiteral宏和fromLocal8Bit()函数输出的字符串还带有双引号：
使用下面的这两个方法可以解决这种问题。
（3）使用#pragma execution_character_set(“utf-8”)
源程序中加上如下指令，将源文件的可执行字符集编码方式设置为utf-8
#pragma execution_character_set("utf-8") qDebug() &lt;&lt; "路漫漫其修远兮"; （4）使用u8关键字
C++17到来后出现了u8关键字，表示一个字符串的可执行字符集编码方式是UTF-8编码
qDebug() &lt;&lt; u8"路漫漫其修远兮" 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1c4da71c066671c4da3f8000bef335f/" rel="bookmark">
			Linux 常用的一些命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、常用文件管理命令二、tmux 和 vimtmuxvim 三、[Shell语法](https://blog.csdn.net/weixin_43288201/article/details/105643692)四、git五、sshReference 一、常用文件管理命令 (1) ctrl c: 取消命令，并且换行 (2) ctrl u: 清空本行命令 (3) tab键：可以补全命令和文件名，如果补全不了快速按两下tab键，可以显示备选选项 (4) ls: 列出当前目录下所有文件，蓝色的是文件夹，白色的是普通文件，绿色的是可执行文件 (5) pwd: 显示当前路径 (6) cd XXX: 进入XXX目录下, cd .. 返回上层目录 (7) cp XXX YYY: 将XXX文件复制成YYY，XXX和YYY可以是一个路径，比如../dir_c/a.txt，表示上层目录下的dir_c文件夹下的文件a.txt (8) mkdir XXX: 创建目录XXX (9) rm XXX: 删除普通文件; rm XXX -r: 删除文件夹 (10) mv XXX YYY: 将XXX文件移动到YYY，和cp命令一样，XXX和YYY可以是一个路径；重命名也是用这个命令 (11) touch XXX: 创建一个文件 (12) cat XXX: 展示文件XXX中的内容 (13) 复制文本 windows/Linux下：Ctrl + insert，Mac下：command + c (14) 粘贴文本 windows/Linux下：Shift + insert，Mac下：command + v 二、tmux 和 vim tmux 功能： (1) 分屏。 (2) 允许断开Terminal连接后，继续运行进程。 结构： 一个tmux可以包含多个session，一个session可以包含多个window，一个window可以包含多个pane。 实例： tmux: session 0: window 0: pane 0 pane 1 pane 2 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1c4da71c066671c4da3f8000bef335f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b31ee6aaad549efb5fd3616de6f6fd68/" rel="bookmark">
			VMware workstation安装debian-12.1.0虚拟机（最小化安装）并配置网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VMware workstation安装debian-12.1.0虚拟机（最小化安装）并配置网络 Debian 是一个完全自由的操作系统！Debian 有一个由普罗大众组成的社区！该文档适用于在VMware workstation平台安装最小化安装debian-12.1.0虚拟机。
1.安装准备 1.1安装平台 Windows 11 1.2软件信息 软件名称软件版本安装路径VMware-workstation 17 proVMware-workstation-full-17.5.0-22583795D:\softwaredebian-12.1.0debian-12.1.0E:\virtual 1.3软件下载 debian官网官网下载debian-12.1.0版本
2.VMware workstation搭建debian-12.1.0虚拟机 2.1新建虚拟机 2.2使用新建虚拟机向导，选择典型配置 2.3选择稍后安装操作系统 2.4选择客户机操作系统类型和版本 2.5设置虚拟机名称和安装位置 2.6设置虚拟机磁盘大小 2.7自定义虚拟硬件 2.8可设置内存、CPU等，并添加操作系统ISO镜像文件 关闭网络启动时连接。
2.9检查配置信息正确后，完成虚拟机创建 3.VMware workstation安装debian-12.1.0虚拟机 3.1打开虚拟机电源 3.2选择第1项，通用安装 3.3选择中文（简体） 3.4选择中国地区 3.5选择汉语键盘映射 3.6虚拟机设置中未联网，所以配置网络失败，暂时不配置完网络，后续手动配置网络 3.7设置主机名 3.8设置域名名 3.9设置root管理员用户密码 3.10新建普通用户，并设置密码 3.11自动配置时钟 3.12配置磁盘分区 3.13配置软件包管理器，不扫描额外的安装介质 3.13不参加软件包流行度调查 3.14不使用网络镜像站点 3.15安装标准系统工具 3.16安装GRUB启动引导器到主驱动器 3.17安装完成，重启系统 3.18按enter键重启 3.19重启后，输入用户名密码登录系统 4.VMware workstation配置debian-12.1.0虚拟机网络 4.1设置虚拟机启动时连接网络，重启虚拟机 4.2打开终端，查看虚拟机IP 5.测试debian-12.1.0虚拟机网络与SSH远程登录 5.1新建虚拟机 参考：敬请期待博主更新，点链接查看博主主页。 创作不易，转载请注明出处。点关注，不迷路，您的支持是我创作最大的动力！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad61d908da76908201293610c7b17b81/" rel="bookmark">
			统计学-R语言-5.3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 前言分位数统计量的标准误总结 前言 本篇文章即为概率与分布的最后一篇文章。
分位数 分位数函数是累积分布函数的反函数。
p-分位数是具有这样性质的一个值：小于或等于它的概率为p。
根据定义，中位数即50%分位数。
分位数通常用于置信区间的计算，以及与设计试验有关的势函数的计算。
下面给出一个置信区间计算的简单例子：如果𝜎= 12，测量了n=5个观测值，得到均值，通过相关的分位数得到𝜇的一个置信度为95%的置信区间：
xbar=83 sigma=12 n=5 sem=sigma/sqrt(n) #标准误 sem [1] 5.366563
xbar+sem*qnorm(0.025) [1] 72.48173
xbar+sem*qnorm(0.975) [1] 93.51827
qnorm():输入的是小于或等于这个分位数的概率为p，区间为0—1，输出的是z-score（分位数）
由于标准正态分布的对称性，
通常把置信度为95%的置的置信区间写成
统计量的标准误 统计量的抽样分布的标准差，简称标准误差
衡量统计量的离散程度
在参数估计与假设检验中，用于衡量样本统计量估计总体参数的精确程度
样本均值和样本比例的标准误分别为
当计算标准误时涉及的总体参数未知时，用样本统计量代替计算的标准误，称为估计的标准误(在统计软件中得到的都是估计标准误)
以样本均值为例：当总体标准差未知时，可用样本标准差s代替，则在重复抽样条件下，样本均值的估计标准误为
标准误与前面讲的标准差是两个不同的概念。标准差是根据原始观测值计算，反映一组原始数据的离散程度。而标准误是根据样本统计量计算的，反映统计量的离散程度的。
总结 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edf7dd0dd9dbc3b022a1ef1fdb134ea1/" rel="bookmark">
			Pytorch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、pytorch环境创建二、jupyter配置pytorch加载数据 三、实战1、Dataset代码实战2、Tensorboard的使用3、tensorboard4、图像变换，transform的使用5、常见的transforms6、torchvision中的数据集使用7、dataloader的使用 四、神经网络1、神经网络基本骨架--nn.Module的使用2、卷积操作3、卷积层的使用（Convolutional Layer）4、最大池化的使用（MaxPooling）5、非线性激活（Nonlinear activation）6、线性层（linear）7、序列化（Sequential）8、损失函数与反向传播（loss function）9、优化器（optimizer） 五、模型的使用1、现有模型的使用及更改2、网络模型的保存与加载3、完整的模型训练套路（以CIFAR10数据集）4、训练模型套路二5、GPU训练6、完整模型验证 一、pytorch环境创建 创建一个pytorch环境n后面环境名字，python环境版本
conda create -n pytorch python=3.11 激活环境
conda activate pytorch 查看工具包
pip list 安装pytorch，我天是真的慢
conda install pytorch torchvision torchaudio pytorch-cuda=11.8 -c pytorch -c nvidia 验证是否安装成功，是否可以使用gpu
(pytorch) E:\deep_learning&gt;python import torch torch.cuda.is_available() True 二、jupyter配置 安装jupyter
(pytorch) E:\deep_learning&gt;conda install nb_conda 换成了，可以了
conda install -n pytorch ipykernel jupyter notebook终于能运行pytorch环境了呜呜呜。。。
遇到了问题：
转载：23年最新版pycharm找不到conda可执行文件解决办法
终于成了，好难
dir():打开，看见 help():说明书 dir(toch) dir(torch.cuda) dir(torch.cuda.is_available()) help(torch.cuda.is_available) Help on function is_available in module torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edf7dd0dd9dbc3b022a1ef1fdb134ea1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48c14d225f90f2a9d88d272d91ca2d63/" rel="bookmark">
			C语言--带哨兵位的双向循环链表的创建及使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言--带哨兵位的双向循环链表的创建及使用详解 1. 双向循环链表定义1.1 定义1.2 优点：1.3 物理结构 2. 双向链表的创建2.1 文件创建2.2 节点创建 3. 链表操作3.1 初始化3.2 显示3.3 尾插3.4 头插3.5 尾删3.6 头删3.7 查找3.8 指定位置前插入3.9 指定位置删除3.10 链表销毁 4. 链表总内容4.1 List.c 文件4.2 List.h文件4.3 test.c文件 5. 总结 1. 双向循环链表定义 1.1 定义 带哨兵位的双向循环链表是一种数据结构，它由多个节点组成，每个节点包含一个数据元素和两个指针，分别指向前一个节点和后一个节点，这样可以实现双向遍历。而且由于是循环链表，所以最后一个节点的后继节点是第一个节点，第一个节点的前驱节点是最后一个节点。与普通的双向循环链表不同的是，带哨兵位的链表在链表头部有一个哨兵节点，它不存储任何数据，仅用于简化链表操作。定义如下：
typedef int LTDataType;//定义存放数据的类型，便于不同类型数据的修改 typedef struct ListNode//定义链表结构 { struct ListNode* next;//指向下一个节点的地址 struct ListNode* prev;//指向前一个数据的地址 LTDataType data;//存放的数据 }LN;//重新命名 1.2 优点： 简化边界情况处理：哨兵节点的存在简化了对链表为空或者只有一个节点的情况的处理，使得代码更加简洁和易于理解。方便实现循环遍历：由于是循环链表，可以方便地实现对链表的循环遍历，并且在实现迭代器等功能时也更加方便。提高代码的可读性和可维护性：哨兵节点的引入使得链表操作的边界情况处理更加统一，减少了代码中的特殊情况处理，提高了代码的可读性和可维护性。 1.3 物理结构 物理结构如下图：
该链表的第一个节点为哨兵位节点，不存放任何数据。phead 的next指向的节点才是第一个数据存放的位子。尾节点的next指向头节点地址，头节点的prev指向尾节点地址当链表仅剩下哨兵位时，perv 和 next 均指向自己，此时数据为空，链表中总会存在一个节点。在进行后面的操作的时候不需要判空，仅需要判别next 是否和prev 指向的位置相同 2. 双向链表的创建 2.1 文件创建 为方便代码管理，将文件内容分为三个文件来共同组成单链表，如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48c14d225f90f2a9d88d272d91ca2d63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc9a437fc3f0e3e80346d444b1fcdd65/" rel="bookmark">
			Linux shell编程学习笔记39：df命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0 前言1 df命令的功能、格式和选项说明 1.1 df命令的功能1.2 df命令的格式1.3 df命令选项说明 2 df命令使用实例 2.1 df：显示主要文件系统信息2.2 df -a：显示所有文件系统信息2.3 df -t[=]TYPE或--type[=]TYPE：显示TYPE指定类型的文件系统信息2.4 df --total：追加显示统计信息2.5 df -l 或 --local：只显示本地文件系统信息2.6 df -B[=]SIZE或--block-size[=]SIZE：按按 SIZE指定的单位来打印大小信息2.7 df -h或--human-readable：以人类可读格式打印尺寸2.8 df -i或--inodes： 列出索引节点而不是块使用情况信息2.9 df-T或--print-type：打印文件系统类型2.10 df -P或--portability：使用 POSIX 输出格式2.11 df -x=TYPE或--exclude-type=TYPE：显示非TYPE指定类型的文件系统信息 0 前言 说到DF，你最先想起的是啥呢？
我最选想来的是以前玩过的由 NovaLogic 开发和出版的一款第一人称射击游戏，名字是《Delta Force | 三角洲特种部队》，简写就是DF，启动游戏的文件是df.exe。
那么，在Linux中，df命令的功能是什么呢？
1 df命令的功能、格式和选项说明 我们可以使用 def --help命令查看 df命令的帮助信息。
purpleEndurer @ bash ~ $df --help
Usage: df [OPTION]... [FILE]...
Show information about the file system on which each FILE resides,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc9a437fc3f0e3e80346d444b1fcdd65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fed0232f7d42629e70806696ce35ae65/" rel="bookmark">
			Charles macOS Apple Silicon
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 安装 Charles 5 betas 安装证书 Install Charles Root Certificate 安装并信任证书
Recording Settings SSL Proxying Settings macOS 代理 iOS 代理 Install Charles Root Certificate on a Mobile Device or Remote Browser 设置 》通用 》关于本机 》证书信任设置 参考 download 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/808c14fd44bd9a3bac87c1fffa9f9138/" rel="bookmark">
			XXL-Job的搭建&amp;接入Springboot项目（详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、XXL-Job介绍 XXL-Job 是一款开源的分布式任务调度平台，由 Xuxueli（徐雪里）开发。它基于 Java 技术栈，提供了一套简单易用、高可靠性的任务调度解决方案。
XXL-Job 的主要作用是帮助开发者实现定时任务的调度和执行。它可以用于定时执行各种类型的任务，例如定时生成报表、定时发送邮件、定时清理数据等。通过 XXL-Job，开发者可以非常方便地管理和监控任务的执行情况，实现任务的自动化调度。
XXL-Job 提供了一个可视化的任务管理界面，可以进行任务的创建、编辑、删除和暂停等操作。同时，它还支持任务的分片并行执行，提高任务的处理效率。XXL-Job 还提供了丰富的任务调度配置选项，如定时触发、CRON 表达式、间隔触发等，满足不同任务调度需求。
除了任务调度功能，XXL-Job 还提供了任务日志记录和报警功能。它可以将任务的执行日志记录下来，方便排查问题和分析任务执行情况。同时，XXL-Job 还支持邮件、钉钉等方式的报警通知，及时告知任务执行异常或失败的情况。
总结来说，XXL-Job 是一款功能强大的分布式任务调度平台，可以帮助开发者实现定时任务的调度和执行。它提供了任务管理、任务调度配置、任务日志记录和报警等功能，方便开发者进行任务的管理和监控。
官网地址 分布式任务调度平台XXL-JOB
这个上面有关于xxl-job的详细介绍和各个功能说明。有需要的可自行去了解官方提供的文档。
系统架构图 调度中心作用：统一管理任务调度平台上调度任务，负责触发调度执行，并且提供任务管理平台。
执行器作用：负责接收“调度中心”的调度并执行。
二、下载xxl-job 1.环境准备 Maven3+Jdk1.8+Mysql5.7+ 2.源码仓库地址 githup:
https://github.com/xuxueli/xxl-job
Gitee：
xxl-job: 一个分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。现已开放源代码并接入多家公司线上产品线，开箱即用。
GitCode:
GitCode - 开发者的代码家园
3.中央仓库地址 目前最新的版本是2.4.1
&lt;!-- http://repo1.maven.org/maven2/com/xuxueli/xxl-job-core/ --&gt; &lt;dependency&gt; &lt;groupId&gt;com.xuxueli&lt;/groupId&gt; &lt;artifactId&gt;xxl-job-core&lt;/artifactId&gt; &lt;version&gt;${最新稳定版本}&lt;/version&gt; &lt;/dependency&gt; 三、快速入门 1.拉取代码 拉取下来的目录结构如下：
xxl-job-admin：调度中心
xxl-job-core：公共依赖
xxl-job-executor-samples：执行器Sample示例（选择合适的版本执行器，可直接使用，也可以参考其并将现有项目改造成执行器）
：xxl-job-executor-sample-springboot：Springboot版本，通过Springboot管理执行器，推荐这种方式；
：xxl-job-executor-sample-frameless：无框架版本；
2.初始化调度数据库 将tables_xxl_job.sql文件导入到我们数据库中，表结构如下：
3.配置部署调度中心 调度中心项目：xxl-job-admin
作用：统一管理任务调度平台上调度任务，负责触发调度执行，并且提供任务管理平台
调度中心配置文件地址：
/xxl-job/xxl-job-admin/src/main/resources/application.properties
调度中心配置内容说明：
### 调度中心JDBC链接：链接地址请保持和 2.1章节 所创建的调度数据库的地址一致 spring.datasource.url=jdbc:mysql://127.0.0.1:3306/xxl_job?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai spring.datasource.username=root spring.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/808c14fd44bd9a3bac87c1fffa9f9138/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a233320d7432683f4f6d09d8f970822/" rel="bookmark">
			一文了解GeoTrust SSL证书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在当今互联网的高度连接世界中，确保网站安全性至关重要。SSL证书是保护网站和用户数据的关键组成部分。GeoTrust证书在SSL证书市场上享有盛誉，被许多网站所有者和企业所信赖。JoySSL将深入探讨GeoTrust证书的特点，帮助大家了解该品牌并做出更好的选择。
GeoTrust是全球领先的数字证书颁发机构，为网站提供多种类型的SSL证书。下面是GeoTrust证书的主要特点：
GeoTrust证书被几乎所有主要浏览器和操作系统广泛支持，确保网站可以在各种设备和平台上顺利运行。　GeoTrust证书提供强大的256位加密，确保通过网站传输的数据被安全地加密和保护，防止恶意攻击和数据泄露。GeoTrust对申请证书的网站进行域名验证，确保证书仅颁发给与域名相匹配的合法网站。对于企业和组织，GeoTrust提供了组织验证（OV）和增强验证（EV）证书选项，以验证网站背后的实体身份和合法性，增加用户信任。　GeoTrust证书可以在短时间内完成验证和颁发，使您的网站能够迅速启用SSL保护。　作为一家备受信任的证书颁发机构，GeoTrust证书享有良好的声誉和高度的可信度，可以增强用户对您网站的信任感。
GeoTrust_GeoTrust SSL证书_GeoTrust https证书-JoySSLGeotrust是全球最可信的安全品牌之一，专注于企业级 SSL证书解决方案。Geotrust为各种规模的企业提供高性价比的数字证书，包括EV，OV，DV，通配符型证书等。Geotrust是Digicert旗下的中端证书品牌，RapidSSL和QuickSSL是Geotrust旗下低端证书品牌。https://www.joyssl.com/brands/GeoTrust.html?nid=7 GeoTrust证书提供了可靠的安全性保护，确保网站和用户数据的机密性和完整性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b71266929d9c1d8e0ee07f1464756a63/" rel="bookmark">
			vue3&#43;ts&#43;vite&#43;elementPlus后台管理系统学习总结01
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue3+ts+vite+elementPlus后台管理系统学习总结01 一：运行源代码一：按照博客一步步操作1.ts中引入path模块出错：Cannot find module 'path' or its corresponding type declarations.2.安装最新版本的pnpm:3.配置自动导入时，遇到.eslintrc.cjs文件不存在，安装并配置4.生产和开发模式，包放在哪里？5.文档中自动导入模块，types和typings写的混乱，应统一为typings,另外不用新建typings文件夹，设置后运行 npm run dev后自动生成。6.安装pinia时报错7. 博客没有提到的文件，直接复制源代码的8.nprogress安装后，引用时仍有报错提示 一：运行源代码 由Vue3 + Vite + TypeScript + Element-Plus：从零到一构建企业级后台管理系统（前后端开源）这篇博客总结。
用的部分技术栈版本如下：
node.js : 20.10.0 (稳定版)
//vite : 5.1.0 （最新版）
vite: 5.0.10
PS F:\pms\pms-front\vue3-element-admin&gt; npm run dev
vue3-element-admin@2.8.0 dev
vite serve --mode development
启动的源代码
“vue”: “^3.3.13”,
“vue-i18n”: “9.2.2”,
“vue-router”: “^4.2.5”,
“vite”: “^5.0.10”,
启动后，会遇到一个报错：
这个跟package.json中的设置有关：
这是为了防止多人团队中，每个人使用习惯不同【npm,cnpm,pnpm】，导致代码混乱而作的统一处理。
所以你可以根据自己的习惯或者团队要求使用。这里我用pnpm
安装pnpm,并且pnpm install后报错
经查可能是pnpm版本过高的原因，于是降低版本试试。
之前的版本
PS F:\xxx\pms-front\vue3-element-admin&gt; npm -v 10.2.3 PS F:\xxx\pms-front\vue3-element-admin&gt; pnpm -v 8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b71266929d9c1d8e0ee07f1464756a63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fafa8b94eb8337beefd2a5ed94865a8f/" rel="bookmark">
			自动驾驶预测-决策-规划-控制学习（5）：图像分割与语义分割入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 论文题目：Evolution of Image Segmentation using Deep Convolutional Neural Network: A Survey前言：图像分割与语义分割一、图像分割是什么？1.语义分割只区分像素类别，而不区分类别中的具体单位2.实例分割更进一步，把像素区域中每一个个体也能区别出来 二、语义分割模型演变过程1.FCN 基于全卷积网络2.DeepLab3.基于自上而下/自下而上方法①Deconvnet②U-Net 4.基于全局上下文①ParseNet②GCN 5.Based on receptive field enlargement and multi-scale contextincorporation 基于感受野扩大和多尺度上下文合并①PSPNet②Gated-SCNN 三、总结讨论1.研究内容：对基于CNN的不同语义分割模型进行调查。描述了不同的最新语义分割模型的架构细节2.论文的工作3.概括性的神经网络模型分类4.不同模型的性能对比 论文题目：Evolution of Image Segmentation using Deep Convolutional Neural Network: A Survey 前言：图像分割与语义分割 对于图像的分析，传统的检测任务，比如这幅图的人，用标注框来表示。
而图像分割，则是针对每一个像素都可以被认定为不同的语义信息，比如这里红色区域的像素点属于人，蓝色属于天空，浅绿色属于草地，深绿色属于树木。
一、图像分割是什么？ 图像分割于把图像分成若干个特定的、具有独特性质的区域并提取出感兴趣的目标。
如上图所示分割可以分为三类
1） 语义分割：像素级分类，将图像分割成具有语义信息的区域，为每个像素分配一个语义标签。
2）实例分割：检测每个object instance，实例分割不仅关注像素级别的语义信息，还区分不同物体实例之间的边界。
3）全景分割：上面二者的结合。既需要分割出全部像素，同类像素不同物体间不能有重合。图片内的每个像素都必须分配 semantic label 和 instance id. 如 Figure 1d. 相同 label 和相同 id 的像素属于相同 object。
1.语义分割只区分像素类别，而不区分类别中的具体单位 他分割出来属于人的一大块像素区域，但是无法具体把每个人都抠出来。
2.实例分割更进一步，把像素区域中每一个个体也能区别出来 二、语义分割模型演变过程 图像语义分割的发展主要经历了三个时期．
传统方法时期: 采用阈值法、边缘检测法、区域法等对图像进行分割，这些方法只能利用图片中边缘、颜色、纹理等低级特征，分割结果并不精确．传统分割方法和 CNN 相结合的时期: 先利用传统算法处理图像，再利用 CNN 模型训练分类器，虽然带来了分割精度的提升，但依旧受到传统方法的限制．基于 CNN 时期: 全卷积神经网络( FCN) 的出现开启了图像语义分割领域的新篇章．FCN 将 CNN 中的全连接层转换为卷积层，首次实现了端到端的、像素级的分类．FCN的提出为研究人员提供了全新的研究思路，在 CNN 和 FCN的基础上，U-Net、SegNet、DeconvNet、ＲefineNet、EncNet等模型相继出现，为语义分割领域的发展做出了杰出贡献。 论文主要从第三个时期的一些网络来讲述的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fafa8b94eb8337beefd2a5ed94865a8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92470fdb3f1fbbea16ff1e850314cfdb/" rel="bookmark">
			JS数组已经有42个方法了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 数组在js中作为一个非常重要的类型之一，在我们对数据处理，存储数据，条件渲染的时候经常会用到，所以随着ES的不断更新，数组的方法也是越来越多，也让我们使用数组对数据操作的时候，越来越简单，但是不经意间，数组的方法已经有42个之多，接下来让我们看看有哪些数组方法从出来就你还没用过的吧！
数组方法 数组方法之多，大致可以分为以改变数组本身的，不改变数组本身的（返回一个新的数组），还有就是其他对数组本身功能性作用的方法
改变数组本身 （9个） pop和push尾部删除添加 这两个方法用于数组结尾的删除和添加
const arr = [ 1, 2, 3, 4, 5 ] //添加到数组的尾端 arr.push(6) //[1,2,3,4,5,6] //再次调用pop方法就删除了最后一位 arr.pop()//[1,2,3,4,5] unshift和shift头部删除添加 用于在数组的首位进行删除和添加
const arr = [ 1, 2, 3, 4, 5 ] //添加到数组的前端 arr.unshift(6) //[6,1,2,3,4,5] //再次调用shift方法就删除了第一位 arr.shift()//[1,2,3,4,5] sort 排序 进行对数组就地排序，不会复制或返回一个新数组，接收可选参数，一个回调函数，有a,b两个参数，当返回a&lt;b时返回-1从小到大排序，当返回a&gt;b时返回1从大到小排序，a==b时返回0，保持原来的排序（默认排序是将元素转换为字符串，然后按照它们的 UTF-16 码元值升序排序。）
const arr = ["March", "Jan", "Feb", "Dec", 6, 2, "A", "a"]; arr.sort(function (a, b) { if (a &lt; b) { return -1; } else if (a &gt; b) { return 1; } else { return 0; } }); console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92470fdb3f1fbbea16ff1e850314cfdb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22ddbf2e3dfc0f0e1b54ccdc3a28e26c/" rel="bookmark">
			❤ vue的实际使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ❤ vue的实际使用 vue项目中video标签的动态路径使用方法及里面的坑 需求： 在详情展示的时候播放.mp4文件,然后动态改变这个视频的路径无法生效
原因： 使用video标签的时候,会在里面嵌套一个source标签
&lt;video controls="controls" width="960px" autoplay="autoplay"&gt; &lt;source :src="url+videoUrl " type="video/.mp4" /&gt; &lt;/video&gt; ① 解决方法 url是固定的路径,videoUrl是动态的路径,这就导致我在切换数据详情页的时候,不会跟着详情的路径进行改变,分析是这个标签使用的问题
&lt;video :src=" url + videoUrl " controls="controls" width="960px" autoplay="autoplay"&gt; &lt;/video&gt; 把里面的source标签去掉 里面的路径写在video上面,这样就可以动态改变video了
（未生效）
return { url: require("../assets/promotionalVideo.mp4") }; 更改地址： this.$refs.video.src = ('你的视频地址') 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89174976a1e3103e87630f560497e286/" rel="bookmark">
			软件验收测试之正式验收测试和非正式验收测试有什么区别和联系?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、软件正式验收测试是什么?
正式验收测试是指按照既定的流程和标准执行的软件验收过程，具有一定的正式性和规范性。在正式验收测试中，根据软件的需求规格说明书进行测试，通过对软件功能、性能、安全性等方面的检查，评估软件是否符合用户的需求和质量标准。正式验收测试通常由独立的测试团队或第三方机构进行，以确保测试结果的客观性和可信度。
二、软件非正式验收测试是什么?
非正式验收测试是指在正式测试之前进行的功能验证或预验收过程，主要是为了提前发现软件中的问题和风险，并在早期阶段进行修复。非正式验收测试通常由软件开发团队或内部测试团队进行，其目的是发现和解决一些基本的问题，例如软件的完整性、稳定性和易用性等。
三、正式验收测试与非正式验收测试之间存在的区别和联系
1、区别：
a.正式验收测试是在软件开发完成后进行的最终测试，而非正式验收测试则是在软件开发过程中的某个阶段进行的早期测试。
b.正式验收测试具有较高的正式性和规范性，而非正式验收测试相对来说较为灵活。
c.正式验收测试由独立的测试团队或第三方机构进行，而非正式验收测试通常由软件开发团队或内部测试团队进行。
2、联系：两者都是为了保证软件质量，提升用户满意度，都需要对软件进行功能验证和问题修复。正式验收测试的结果可以为非正式验收测试提供参考，帮助测试人员更好地定位问题和改进测试方法。
四、专业第三方软件验收测试机构推荐
卓码软件测评，具备CMA、CNAS双重认证资质的第三方软件测试机构，各类测试类型全国范围内皆可服务，价格优惠，服务周到，出具的第三方软件测试报告公正权威具备法律效力。
文章来源：软件验收测试之正式验收测试和非正式验收测试有什么区别和联系?—卓码软件测评
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/537532adcf520f7fb9eb993aa072d8ab/" rel="bookmark">
			Apache JMeter 3.1压力测试监控服务器数据(cpu、内存、磁盘io等)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Apache JMeter 3.1压力测试 Apache JMeter 3.1压力测试监控cpu、内存情况1.下载Apache JMeter 3.11.1 添加线程组1.2 添加http请求1.3 增加http请求头设置1.4 添加csv配置1.5 添加测试结果监控配置 2. 监控插件下载3. 服务端插件下载并启动3.1 下载3.2 解压并启动3.3 增加服务器配置监控 4. 查看执行结果5. 非GUI模式测试 Apache JMeter 3.1压力测试监控cpu、内存情况 监控服务器CPU、内存、磁盘、网络等相关资源需要使用3.1版本并使用以下插件
客户端：JMeterPlugins-Standard和JMeterPlugins-Extras
服务端：ServerAgent
1.下载Apache JMeter 3.1 官网链接：https://archive.apache.org/dist/jmeter/binaries/apache-jmeter-3.1.zip
解压安装包，进入 bin 目录，点击 jmeter.bat 启动 Jmeter
1.1 添加线程组 线程数：虚拟用户数。一个虚拟用户占用一个进程或线程。设置多少虚拟用户数在这里也就是设置多少个线程数。Ramp-up就是每个线程的执行时间间隔，0表示并发循环次数：每个线程发送请求的次数。如果线程数为 10，循环次数为 100，那么每个线程发送 100 次请求。总请求数为 10*100=1000 。如果勾选了“永远”，那么所有线程会一直发送请求，一到选择停止运行脚本。Delay Thread creation until needed：直到需要时延迟线程的创建。调度器配置：设置线程组启动的开始时间和结束时间（配置调度器时，需要勾选循环次数为永远）
调度器配置参数：持续时间（秒）：测试持续时间，会覆盖结束时间启动延迟（秒）：测试延迟启动时间，会覆盖启动时间 1.2 添加http请求 1.3 增加http请求头设置 1.4 添加csv配置 csv文件内容如下：
1.5 添加测试结果监控配置 2. 监控插件下载 客户端下载地址：Download :: JMeter-Plugins.org
下载完成后解压客户端的两个文件，进入路径JMeterPlugins-Extras\lib\ext，JMeterPlugins-Standard\lib\ext，复制JmeterPlugins-Extras.jar，JmeterPlugins-Standard.jar两个文件，放到JMeter客户端的${jmeter-home}\lib\ext下面
3. 服务端插件下载并启动 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/537532adcf520f7fb9eb993aa072d8ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d709f17041bb1f3c1d04cf1181b4e339/" rel="bookmark">
			低代码与智能化办公：解锁工作效率的新纪元
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着科技的不断进步，低代码与智能化办公成为推动企业数字化转型的重要工具。本文将介绍低代码开发平台和智能化办公工具的特点和优势，并探讨其如何协同发展，加速生产力的提升并推动创新。
随着技术的不断进步，企业在数字化转型的道路上迎来了一次革命性的变革，即低代码与智能化办公的兴起。低代码开发平台的出现，让企业能够以更快的速度和更少的编码工作完成应用程序的开发，提供了插上翅膀的机会。同时，智能化办公技术的蓬勃发展，使得员工在各个层面的工作中能够借助人工智能和机器学习等技术，提高工作效率，实现更智能化的办公。
在数字化时代，企业积极寻求提高生产力、降低成本的方法。低代码开发平台和智能化办公工具的出现，给企业带来了前所未有的机会，使得企业能够更快地开发应用程序、自动化工作流程，并从大数据中获取洞见，从而推动业务创新和效率提升。
低代码开发与快速应用开发 传统的应用程序开发需要大量的编码工作，耗费时间和人力资源。而低代码开发平台则将开发过程简化到最低限度，通过可视化的界面和拖拽式的操作，企业可以在几个小时内快速构建复杂的应用程序。这种快速应用开发的方式不仅提高了开发效率，还减少了开发过程中的错误和Bug的风险。企业智能化办公体验实操引迈 - JNPF快速开发平台_低代码开发平台_零代码开发平台_流程设计器_表单引擎_工作流引擎_软件架构
低代码开发平台的特点和优势 低代码开发平台是一种以图形化界面和少量编码为基础的软件开发工具。它消除了传统软件开发中复杂的编码过程，使非专业开发人员也能快速构建应用程序。低代码平台的特点包括：
-可视化建模 通过拖拽式界面，非技术人员可以轻松创建应用程序的用户界面和逻辑流程。
-快速迭代 低代码平台提供了快速开发和迭代的能力，大大缩短了开发周期和交付时间。
-增强的可伸缩性 低代码平台通常基于云环境，能够根据需求自动扩展和适应变化。
智能化办公的崛起 智能化办公技术无疑是企业数字化转型的重要驱动力之一。通过结合人工智能、机器学习和自然语言处理等技术，智能化办公可以实现例如智能语音助手、自动化流程管理、智能文档处理等功能，极大地提高了员工的工作效率和工作质量。例如，智能语音助手可以帮助员工进行日程安排、任务提醒、会议记录等，极大地减轻了工作压力，并增强了工作的准确性。
智能化办公工具的特点和优势 智能化办公工具利用人工智能和自动化技术，提供了一系列的功能来增强办公效率和智能化决策。智能化办公工具的特点包括：
-自动化流程 自动化工作流程和任务分配，减少了人工操作和错误，提高了工作效率。
-智能认知 借助自然语言处理和机器学习技术，智能化办公工具能够理解和分析大量的文本、图像和数据，提供智能化的建议和洞见。
-数据驱动的决策 通过收集和分析大数据，智能化办公工具能够帮助企业进行数据驱动的决策，提高决策的准确性和效率。
低代码与智能化办公的协同发展 低代码开发平台和智能化办公工具在提高生产力和推动创新方面具有协同作用。通过结合使用两者，企业可以快速构建自定义的应用程序并自动化工作流程，从而实现高效的办公环境。例如，使用低代码平台开发的应用程序可以与智能办公工具集成，实现自动化数据输入、智能分析和自动决策。
低代码与智能化办公的协同应用 低代码开发和智能化办公两者之间并不是相互独立的，而是可以相互协同应用。通过低代码开发平台，可以快速构建智能化办公应用，例如快速开发一个智能合同管理系统，帮助企业自动化管理合同流程，节省时间和人力资源。
成功案例与未来展望 低代码与智能化办公已经在许多公司中取得了显著的成功。许多企业通过低代码平台快速构建了内部应用和客户端应用，大大提升了生产力和服务质量。同时，智能化办公工具的广泛应用也带来了高度自动化和智能化的工作环境。未来，随着技术的不断发展，低代码与智能化办公将进一步融合，为企业提供更强大的工具和平台，助力创新和业务发展。
结论 低代码与智能化办公作为推动企业数字化转型及提升生产力的关键工具，凭借其独特优势，使企业能够更高效地开发应用程序、自动化工作流程，并从数据中挖掘智能洞察。通过协同发展，低代码与智能化办公将为企业带来更多机遇与可能，激发未来商业创新与发展。
低代码与智能化办公的融合为企业带来了重大机遇与挑战。借助低代码开发平台，企业能更敏捷、高效地开发应用程序，实现工作流程的智能化。智能化办公技术的发展则进一步提升员工工作效率和质量。展望未来，随着技术的不断进步，低代码与智能化办公将继续发挥重要作用，推动企业数字化转型进程。企业应积极跟进技术发展，适应变革，以保持竞争力并成为行业翘楚。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59accc6d081f6da8df81bce0d513a71b/" rel="bookmark">
			FFmpeg之PostProc
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、概述二、宏定义三、类型定义四、重要函数4.1、postproc_version4.2、postproc_configuration4.3、postproc_license4.4、pp_postprocess4.5、pp_get_mode_by_name_and_quality 团队博客: 汽车电子社区
一、概述 FFmpeg中的postproc库是一个视频后处理库，用于应用各种图像处理滤镜和算法来改善和优化视频质量。
postproc库提供了一些常见的视频后处理滤镜，例如去隔行滤波、去噪滤波、锐化滤波等，可以用于增强视频的清晰度、减少噪点和伪影等。
在早期版本的 FFmpeg 中，postproc 库是默认启用的，可以通过命令行选项 -postproc 来应用后处理滤镜。但是自FFmpeg 3.2版本开始，postproc 库被标记为过时（deprecated），不再是默认启用的，而且在最新的 FFmpeg 版本中已经被移除。
现在，建议使用更现代和更强大的滤镜系统，如 libavfilter，来实现视频的后处理和滤波操作。libavfilter 提供了广泛的滤镜和处理器，可以进行更复杂和高级的视频处理。
所以，如果你使用最新版本的 FFmpeg，推荐使用 libavfilter 来进行视频后处理。
二、宏定义 #define PP_CPU_CAPS_MMX 0x80000000 #define PP_CPU_CAPS_MMX2 0x20000000 #define PP_CPU_CAPS_3DNOW 0x40000000 #define PP_CPU_CAPS_ALTIVEC 0x10000000 #define PP_CPU_CAPS_AUTO 0x00080000 #define PP_FORMAT 0x00000008 #define PP_FORMAT_420 (0x00000011|PP_FORMAT) #define PP_FORMAT_422 (0x00000001|PP_FORMAT) #define PP_FORMAT_411 (0x00000002|PP_FORMAT) #define PP_FORMAT_444 (0x00000000|PP_FORMAT) #define PP_FORMAT_440 (0x00000010|PP_FORMAT) #define PP_PICT_TYPE_QP2 0x00000010 ///&lt; MPEG2 style QScale #define LIBPOSTPROC_VERSION_MINOR 4 #define LIBPOSTPROC_VERSION_MICRO 100 #define LIBPOSTPROC_VERSION_INT AV_VERSION_INT(LIBPOSTPROC_VERSION_MAJOR, \ LIBPOSTPROC_VERSION_MINOR, \ LIBPOSTPROC_VERSION_MICRO) #define LIBPOSTPROC_VERSION AV_VERSION(LIBPOSTPROC_VERSION_MAJOR, \ LIBPOSTPROC_VERSION_MINOR, \ LIBPOSTPROC_VERSION_MICRO) #define LIBPOSTPROC_BUILD LIBPOSTPROC_VERSION_INT #define LIBPOSTPROC_IDENT "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59accc6d081f6da8df81bce0d513a71b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eebc407e1ce7c68357870c98373a2326/" rel="bookmark">
			Chrome 浏览器插件 cookies API 解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Chrome.cookie 前端开发肯定少不了和 cookie 打交道，此文较详细的介绍下 chrome.cookie 的 API 以及在 popup、service worker、content 中如何获取的
一、权限（Permissions） 如果需使用 Cookie API，需要在 manifest.json 文件中添加权限（Permissions）和主机权限（host_permissions）字段
"permissions": [ "cookies" ], "host_permissions": [ "https://*.lkcoffee.com/*" ] 比如，我需要获取 domain 为 .lkcoffee.com 的 cookie，就需要在 host_permissions 中进行 host 的配置
二、类型（Types） 1. Cookie 表示关于 HTTP Cookie 的信息。
属性 domain: string cookie 的 domain expirationDate: number 可选 Cookie 的有效期 hostOnly: boolean host-only 时为 true httpOnly: boolean httpOnly 时为 true name: string 名称 partitionKey: CookiePartitionKey 可选 用于通过分区属性读取或修改 Cookie 的分区键。 path: string 路径 sameSite: SameSiteStatus 同网站状态。 secure: boolean Secure 值 session: booean 是否是会话 storeId: string 包含此 Cookie 的 Cookie 存储区的 ID，如 getAllCookieStores() 中所提供。 value: string cookie 值 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eebc407e1ce7c68357870c98373a2326/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe931f82060ef2a883f4fca24a3bbd69/" rel="bookmark">
			#Android Studio使用01#
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#Android Studio ANDROID_SDK_HOME# Android_sdk_home在Windows系统中的作用：
创建本地的模拟器的时候，会指定到android_sdk_home所在的目录
创建.android文件。不在是系统默认的c盘下的用户目录
1:新建放置虚拟机文件夹,如图
2:配置环境变量ANDROID_SDK_HOME
3：重启AndroidStudio 查看创建的文件内是否生成.android 文件
如果没有重启电脑 成功
其他：
如果AVD模拟器启动不了，需要设置ANDROID_SDK_HOME环境变量 。原因，当安装SDK的时候没有使用默认的安装路径，安装到其他地方，这个时候，如果创建模拟器，出现启动失败的情况，需要设置一下ANDROID_SDK_HOME 重新指定一个安装路径，不用使用默认的安装路径
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7293b1f4cd34645c2e29d2676997194/" rel="bookmark">
			数组类 189 Rotate Array详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 189 Rotate Array问题描述算法分析与实现解法一：暴力解法方法二：使用额外的Array方法三：使用反转 189 Rotate Array 问题描述 Given an array, rotate the array to the right by k steps, where k is non-negative.
Follow up:
Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.Could you do it in-place with O(1) extra space? Example 1:
Input: nums = [1,2,3,4,5,6,7], k = 3
Output: [5,6,7,1,2,3,4]
Explanation:
rotate 1 steps to the right: [7,1,2,3,4,5,6]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7293b1f4cd34645c2e29d2676997194/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/038e3af2d80107e281a6ffed0c4d2455/" rel="bookmark">
			GoZero微服务微服务个人探究之路（五）部署微服务到k8s的一种最佳实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需做工作 在每个微服务下面新建一个Dockerfile文件根据Dockerfile文件使用docker build指令，打包为具体的镜像（根据自己需求选择）将docker镜像上传到私人docker仓库或者是公共仓库，如果没有上传，则自动保存在本地编写用于部署k8s的yaml文件--服务service，节点--pod根据yaml文件，使用kubectl apply部署k8s 需要注意的点 多机k8s集群，必须将docker镜像上传至仓库，保存至单机本地无法保证大家都访问到这个镜像
单机k8s集群则无需注意，可以直接使用本地docker仓库来保存镜像
效率提升方式 编写makefile文件来简化人工命令操作
额外的 打包为docker镜像的过程通常很慢，
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b8b06b94567a2992c33e9180862e4bc/" rel="bookmark">
			软件设计原则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件设计原则 1小时系列 （C++版）-CSDN博客
设计模式——六大设计原则_接口设计6大原则-CSDN博客
摘抄：
公共接口下，添加不同的实现。
橙色为接口，将繁杂的接口拆成多个接口
未完待续......
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d20daa67dbfc4252a556951a8194ec4c/" rel="bookmark">
			详解SpringCloud微服务技术栈：Gateway网关（断言、过滤器、跨域问题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		👨‍🎓作者简介：一位大四、研0学生，正在努力准备大四暑假的实习
🌌上期文章：详解SpringCloud微服务技术栈：Feign远程调用、最佳实践、错误排查
📚订阅专栏：微服务技术全家桶
希望文章对你们有所帮助
现在集群中会有很多的微服务，且都对应自己的一个数据库，同时每个微服务还需要在Nacos中做注册和配置管理，当微服务之间有相互调用的时候，直接通过Feign来做远程调用，而当外部要访问的时候，直接发请求就可以了。
但，外部可以随意访问微服务，并不是很安全，有些东西只有相应的专业人员才能访问，而网关就是负责解决这类问题的，一切请求都要先通过了网关才能去访问微服务。
Gateway网关（断言、过滤器、跨域问题） 网关的作用介绍网关快速入门路由断言工厂路由的过滤器配置全局过滤器GlobalFilter过滤器链执行顺序网关的cors跨域配置 网关的作用介绍 身份认证和权限校验：通过才能去访问微服务
服务路由：当通过网关后，还需要根据请求的类型，将请求转发到对应的微服务中
负载均衡：确定了转发的微服务之后，微服务中的多个实例之间还应该做负载均衡
请求限流：限制访问的请求量
在SpringCloud中网关的实现包括2种：
gateway
zuul
zuul是基于Servlet的实现，属于阻塞式编程。而SpringCloudGateway则是基于Spring5中提供的webFlux，属于响应式编程的实现，具备更好的性能。
因此，我们会使用SpringCloudGateway。
网关快速入门 需要先搭建一下网关，步骤：
1、创新新的module，引入SpringCloudGateway的依赖和Nacos的服务注册发现依赖：
&lt;!--Nacos服务发现依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--网关gateway依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt; &lt;/dependency&gt; 2、搭建一下启动类，位置cn.itcast.gateway.GatewayApplication：
@SpringBootApplication public class GatewayApplication { public static void main(String[] args) { SpringApplication.run(GatewayApplication.class, args); } } 2、编写网关的路由配置及Nacos地址：
server: port: 10010 spring: application: name: gateway cloud: nacos: server-addr: localhost:8848 # Nacos地址 gateway: routes: - id: user-service # 路由的标识，必须唯一 # uri: http://localhost:8081 # 固定的路由目标地址 uri: lb://userservice # lb表示负载均衡，后面跟上服务的名称 predicates: # 路由的断言，也就是判断请求能不能符合路由规则的条件 - Path=/user/** # 路径满足/user/开头的就符合要求，托管给userservice服务 - id: order-service uri: lb://orderservice predicates: - Path=/order/** 访问：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d20daa67dbfc4252a556951a8194ec4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdb1fe009ffea798eaed42db181aba29/" rel="bookmark">
			对话智谱AI CEO 张鹏：让追赶OpenAI成为可能？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文来自公众号：硅星人
1月16日，智谱AI发布新一代基座大模型GLM-4。
GLM-4在基础能力上实现大幅升级，支持最高 128K 长文本，原生支持自动联网、图片生成、数据分析等复杂任务，并在多模态能力上有了长足进步。据智谱AI透露，在内部测评中，GLM-4在性能上逼近了GPT-4。GLM模型智能体和智能体中心也在GLM-4发布当天同步上线。
此前，去年6月ChatGLM-2发布，去年10月ChatGLM-3发布，而去年3月GLM-4已经完成第一个版本。CEO 张鹏认为三到四个月完成一次基础模型迭代是正常的研发速度。
去年年初，这家中国最重要的基础模型公司定下了朝GPT-4追赶的目标，之后一年基础模型继续快速发展，Meta把持着开源生态，领头羊OpenAI拿出了GPT-4，谷歌带着Gemini姗姗来迟。基础模型的竞争者逐渐收敛到少数几家，而观察中国公司在其中的位置时，目前中国唯一估值超过百亿人民币的智谱AI或许是那个锚。
在GLM-4发布之际，我们与智谱AI CEO 张鹏进行了一次独家对话。
以下为对话实录：
对话人 | 骆轶航、朱正
什么最重要？模型，模型，还是模型
硅星人：我们先聊聊GLM-4本身。智谱AI对标GPT-4去做自己的升级和演进，这个整体思路是怎么样的，如何让追上GPT-4这件事看起来可行，并且可能还会有一些超预期的东西？
张鹏：首先肯定是模型能力方面差距的追赶，比如多模态能力，GPT-4在3月份发布的时候其实已经带来多模态能力了。我们判断对于AGI来说，多模态这件事情可能是必须要去解决的，所以这个能力你必须有。包括模型本身能力提升所带来的像CoT这样的高阶能力，它其实根植于你底层的基础模型的能力。
第二件事是，有了大脑，需要眼睛和耳朵，手和脚——需要要把这些基础模型的能力辐射出去，跟外界系统产生更密切的交互，而不是简单的做文本和图像的输入输出。这个事情就偏向应用了。
硅星人：基础模型能力的辐射，这是关于Agent（智能体）的想法了。现在人们谈起Agent，正在陷入一个概念的陷阱里，智谱AI对于Agent的有什么自己的理解？
张鹏：Agent在人工智能或者说计算机科学史上是个“老概念”，有一套相对完整的解释体系。大模型下Agent找到了一个新的视角。但Agent的本源仍然是大模型的基础能力，大脑的智力水平足够高，才能去谈理解、推理、以及规划和执行这些事。
智谱AI还是从技术角度的的定义和演进来理解Agent的。然后从大模型角度来看，Agent应该怎么去演化，怎么去提供这个能力。以及它跟需求语言之间应该如何相互翻译，找到通路去对应上。
硅星人：Agent和所谓的AI原生应用（AI Native App），这两者之间是什么关系？
张鹏：首先AI Native这个范畴还是太大，我们更愿意叫做大模型的原生应用。
首先说大模型原生应用，它实际上是指的我们希望说从大模型的原生能力出发，去设计和开发的应用，我们期待它是一种新的东西，而不是说把原来的应用拿来做一个升级。
这个是有的，比如ChatGPT，这个产品在工程化层面其实很简单，核心就是一个模型。而对于Agent，我们的理解始终是它是模型某种能力的外化，你可以把这种能力做成某种大模型原生应用。
但Agent本身也会给应用的开发过程带来一些变化。当Agent能力被用在开发阶段，它又变成一个赋能原生应用开发的过程，Agent和大模型原生应用之间的逻辑应该是这样。
硅星人：就是可能大模型原生能力本身体现了Agent的能力，Agent某种程度上也在帮助大模型原生能力开发的自动化，这样一种关系。
张鹏：对。
做垂直领域最终是为了以后不做
硅星人：智谱AI在垂直领域的商业化很早，给外界的感觉一直是比较 to B，GLM模型智能体会是一个跟GPTs很像的东西吗，还是不一样？
张鹏：商业化落地这件事还是围绕着我们模型价值本身。我们早期的模型能力不太够，那可能就需要去为了填补模型本身的能力和最终业务需求之间的gap，而去垂直领域多做一点事情。
你不去做，你不知道客户在想什么，也就不知道你的技术最终帮助客户提升的用户价值到底有多少。
这实际上是我们去寻找Best Practice（最佳实践）的一个过程。我们希望把这个路径蹚通，回过头来把这些东西沉淀下来之后赋能给生态。
硅星人：比如说RAG（Retrieval Augmented Generation，检索增强生成），智谱AI应该是国内最早把RAG用到垂直领域了的一个。
张鹏：算是比较早，因为LangChain整个开源项目里头就有我们。RAG是很典型的一个例子，就是从垂直领域沉淀出通用型的需求，以及一套方法。这套方法可以成为一种标准化的解决路径和产品。
硅星人：所以可以这么理解，我们做很多垂直领域的事，其实是为了反哺通用模型的基础能力提升。做的目的是为了以后不做。
张鹏：对。GLM模型智能体就是在探索一种更通用的路径。
传统互联网爆款产品经理不理解最新的AI技术
硅星人：智谱AI一直以技术能力见长，你怎么看现在智谱AI的产品能力，比方说我们能够支持多少个开发者在上面，怎么提供好的工具，甚至让开发者能得到更多曝光？
张鹏：如果我们现在真的进入到了大模型的应用半场的话，产品能力是大家都很关注的一件事。
智谱AI之前也有自己的一些产品化的东西，其实用户量都还不错，我觉得产品能力应该来说还不算差，当然我们会持续的在这方面去加强。
但是反过头来讲，你看ChatGPT，作为一个产品本身没有什么特别复杂的东西。所以——我个人感觉，因为我不是做产品出身——所谓产品力这个东西，在这个时代它变成了一种对需求的敏锐感知能力和对于新技术的领悟能力的兼顾，在这个基础上，考验的是如何揉合这两种能力，去产生一种新的产品表达形态的这样一种复合的能力。
硅星人：这跟移动互联网时期的小步快跑、快速迭代和敏捷开发这些东西可能是不一样了。
张鹏：这一套沉淀下来的产品开发逻辑还在，尤其是ToC。但为什么现在大家说要找一款所谓的Killer App这么难，好像所有的产品经理都没有头绪。
我个人觉得其实矛盾在于，原来传统的互联网爆款的产品经理，他对于现在最新的技术没办法理解。真正懂技术的这些人，对于所谓的用户需求和产品需求又没法理解。
硅星人：那当一个基础模型开始面对开发者了，也就存在一个模型的技术和产品适配问题（technology product fit）。你们要如何跟开发者去讲，你能够做什么不能做什么？
张鹏：好像现在只能开发者自己去尝试，但在这之外，其实有一些本质的东西做产品的人可以在间隙思考一下。
回到第一性原理，大模型本质上解决了什么样的问题，找到这个点，然后你把你所有需求写出来，然后你去找到这两者间的连线。
比如我反问你，Chatgpt解决的是什么问题？你第一天用上，它就直接告诉你这是个不一样的东西，从来没有人想过这个问题——虽然他帮你解决了很多问题。
硅星人：所以ChatGPT解决了什么问题？
张鹏：我个人认为它最本质上解决的还是人机交互的问题。机器终于有一天能够比较像样的能听懂人说什么，然后说出来的话也让人能听懂。这个是个本质的问题，它弥合了人和机器之间的距离，这是他第一性要解决的问题。
顺着这个思路，哪些场景可以被这件事情解决掉，很容易判断出自动客服这类的需求。
这是大模型解决的第一件事。第二是大模型在经过大量语料数据训练之后，具备超越一般人积累的知识和数据量，能很好的去解答人们日常生活当中的问题。这件事本质上解决的是我们人类社会当中人与人之间的信息和知识传递的成本和范围问题。
硅星人：那些让人被迫为了一份工作要学习一堆无用知识的问题，或者说是知识的快速消化的处理的问题，现在都可以处理了。
张鹏：对，我有更低的成本，更大的范围去获取知识了。所以这个事情又可以cover掉教育、员工内部培训这些事情。所以如果按这种逻辑分析方式的话，其实还是能找出来一些大模型应用产品具体的方向的。
硅星人：那这样其实对做产品的人的要求是非常高的。过去互联网时期中国的产品经理群体里，设计师出身的人很多，做交互做UI的人很多。那时候美国的产品经理，一看全是MBA背景。那时我们会嘲笑这帮人做MBA的怎么做好产品，现在你发现还真得靠MBA去做产品经理。
张鹏：对，我特别赞同你这么说。这背后其实是大家在对于“一个产品需要满足什么需求”这件事的着眼点不一样。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdb1fe009ffea798eaed42db181aba29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7705d48ec315af31040d2dc0fd805775/" rel="bookmark">
			寒假已开启，你的毕业论文写到哪了？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先来看1分钟的视频，对于要写论文的你来说，绝对有所值！
还在为写论文焦虑？免费AI写作大师来帮你三步搞定
体验免费智元兔AI写作：智元兔AI 第一步：输入关键信息 第二步：生成大纲 稍等片刻后，专业大纲生成（由于举例，只选了3000字，大纲会相应短些）：
可以在生成的大纲上进行插入、修改和删除。
如果不满意，可以点击“上一步”重新再生成。采用GPT 4.0生成的大纲，绝对会有让你满意的。
第三步：生成论文或文章 生成的文档，可直接编辑：AI续写、扩写、润色、降重。
哪里需要修改，优化哪里！简不简单？
最后可一键下载为word！
体验免费智元兔AI写作：智元兔AI
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4da5b4be7cd9385bd2cfe25f67e29266/" rel="bookmark">
			2023年网络安全十大发展趋势_
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近日，中国计算机学会（CCF）计算机安全专委会中来自国家网络安全主管部门、高校、科研院所、大型央企、民营企业的委员投票评选出2023年网络安全十大发展趋势。
趋势一
数据安全治理成为数字经济的基石
我国《数据安全法》提出“建立健全数据安全治理体系”，各地区各部门均在探索和建立数据分类分级、重要数据识别与重点保护制度。2022年12月，《中共中央 国务院关于构建数据基础制度更好发挥数据要素作用的意见》提出建立数据产权结构性分置制度，这将保障数据生产、流通、使用过程中各参与方享有的合法权利，进一步激发数据要素发挥价值。这些制度建立和实施的前提是数据安全治理有效实施。数据安全治理不仅是一系列技术应用或产品，更是包括组织构建、规范制定、技术支撑等要素共同完成数据安全建设的方法论。数据、模型算法、算力是数字经济发展的三大核心要素，其中数据是原材料。因此，发展数字经济、加快培育发展数据要素市场，必须把保障数据安全放在突出位置，着力解决数据安全领域的突出问题，有效提升数据安全治理能力。在建立安全可控、弹性包容的数据要素治理制度后，需有效推动数据开发利用与数据安全的一体两翼平衡发展。鉴于此，夯实数据安全治理是促进以数据为关键要素的数字经济健康快速发展的基石。
趋势二
智能网联汽车安全成为产业重点
近年来，我国高度重视智能网联汽车发展。2022年，我国新能源汽车产销分别达到705.8万辆和688.7万辆，同比增长96.9%和93.4%，市场占有率达到25.6%。我国正在不断释放智能网联汽车的鼓励性政策，加紧制定智能网联汽车产业发展战略规划。汽车智能化和网联化是一把双刃剑，一方面增强了便捷性，提高了用户体验感；另一方面，联网后的车辆有可能被黑客入侵和劫持，从而带来网络安全威胁。因此，智能联网汽车安全是企业的生命线。2022年，我国以新能源汽车为抓手，汽车产业在国内外发展势头强劲。在国家利好政策和市场需求的双重驱动下，2023年智能网络汽车将进一步快速发展，作为生命线的网络安全也将成为行业发展重点。
趋势三
关键信息基础设施保护领域成为行业增长点
关键信息基础设施一旦遭到破坏、丧失功能或者数据泄露，可能危害国家安全、国计民生和公共利益。当前，关键信息基础设施认定和保护越来越成为各方的关注焦点和研究重点。《关键信息基础设施安全保护条例》于2021年9月正式施行，对关键信息基础设施安全防护提出专门要求。《信息安全技术关键信息基础设施安全保护要求》国家标准将于2023年5月实施，为各行业各领域关键信息基础设施的识别认定、安全防护能力建设、检测评估、监测预警、主动防御、事件处置体系建设等工作提供有效技术遵循，为保障关键信息基础设施全生命周期安全提供标准化支撑，预计带来的安全投入规模将达到百亿级。《关键信息基础设施安全保护条例》及相关国家标准的贯彻施行将带动重要行业和重要领域网络安全建设投入快速增长，关基市场将成为下一个网络安全行业的增长点。
趋势四
隐私计算技术得到产学研界共同关注
随着数据安全保护相关法律法规标准与数据要素流通政策密集出台，数据安全保护与数据共享流通之间的矛盾日益突出。作为平衡数据流通与安全的重要工具，隐私计算成为数字经济的底层基础设施，为各行各业搭建坚实的数据应用基础。近日，工信部等16部门共同发布的《关于促进数据安全产业发展的指导意见》提出，加强隐私计算关键技术攻关和产品研发。联邦学习、多方安全计算、安全求交、匿踪查询、差分隐私、同态加密等实现技术已经逐渐从学术界走向商业化应用，互联网、金融、政务、医疗、运营商等行业的应用继续加速，产学研各界也在合力探索技术应用的合规路径。尽管隐私计算有强劲的市场需求，但目前异构系统无法互联互通、产品性能效率低、产品适配性不强等突出问题仍制约着隐私计算技术更大规模的商业化应用。近年来，隐私计算产业快速增长，预计2025年国内市场规模将达百亿元，在巨大市场预期下，产学研界将更加关注隐私计算技术的新发展和产品应用的新场景。
2023
趋势五
数据安全产业迎来高速增长
近年来，我国数字经济规模持续扩大，数据安全越发受到重视，数据安全产业增速明显，同比增长速度达30%，2022年更是达到40%。随着我国数字化转型步伐加速，数据规模持续扩大，金融、医疗、交通等重要市场以及智能汽车、智能家居等新兴领域数据安全投入持续增加，稳定增长的市场需求将吸引越来越多的传统安全企业以及新兴安全企业推出数据安全相关产品和服务。2023年，《网络数据安全管理条例》有望正式出台。在政策法规和可操作性标准持续优化完善的背景下，在数据合规与企业数据保护的双重驱动下，数据安全产品和服务市场需求更加凸显，以数据为中心的安全投资将获得增长，数据安全产业的增速有望进一步加大。在下游需求及国家政策推动下，各行业对数据安全的投入占比将持续增长，尤其是政务数据管理和央企、国企在相关领域的投入增速将明显加大，有望带动网络安全市场在2023年实现一定程度的复苏。
趋势六
国产密码技术将得到更加广泛地应用
密码是保障个人隐私和数据安全的核心技术，国产密码在各层次的充分融合应用成为基础软硬件安全体系化的核心支撑。在国家密码发展基金等国家级科技项目的引导和支持下，我国在密码算法设计与分析基础理论研究方面取得了一系列的创新科研成果，自主设计的系列密码算法已经成为国际标准、国家标准或密码行业标准，我国商用密码算法体系基本形成，能满足非对称加密算法、摘要算法和对称加密算法的需要。随着我国《密码法》的贯彻实施以及国家对国产化的支持，采用国产密码支撑底层芯片、卡、装置的条件日趋成熟，预计随着国产芯片性能提升和生态成熟，密码行业有望迎来全新国产化发展机遇。国产密码应用将在基础信息网络、涉及国计民生和基础信息资源的重要信息系统、重要工业控制系统、面向社会服务的政务信息系统中得到更加广泛的应用。
趋势七
供应链安全风险管理成为重要挑战
供应链风险管理一直是网络安全建设过程中的薄弱环节，尤其是采购的软件中多使用开源软件和源代码，为黑客通过供应链中供应商的薄弱安全链接访问企业数据提供可乘之机。随着经济全球化和信息技术的快速发展，网络产品和服务供应链已发展为遍布全球的复杂系统，任一产品组件、任一供应链环节出现问题，都可能影响网络产品和服务的安全。供应链攻击（尤其是勒索软件）将持续成为影响组织网络安全的重要因素，在目前远程办公逐渐常态化、规模化的环境下，组织内来源于全球供应链的设备、系统、服务、数据都存在供应链安全风险。2023年，供应链网络安全风险将作为一项社会技术挑战加以解决。保障供应链安全急需数据保护措施和身份验证技术的支持，对供应链实时数据可见性、流转节点安全检测和异常事件应急响应的需求将急剧增加。
趋势八
信创需求将全面爆发
基础软硬件是科技产业的支柱，信息技术创新直接关系国家安全，对信创产业的重视程度将上升到新高度。从近几年信创产业发展来看，通过应用牵引与产业培育，国产软硬件产品综合能力不断提升，操作系统、数据库等基础软件在部分应用场景中实现“可用”，正在向“好用”迈进。2022年，我国发布《“十四五”推进国家政务信息化规划》，提出要实现全流程安全可靠的发展目标。未来五年，从党政信创到行业信创，从金融和运营商到教育和医疗，信创需求将全面爆发，国产软硬件渗透率将快速提升。2020-2022年是党政信创需求爆发的三年，2023-2027年行业信创将接力党政信创，从金融行业、运营商行业逐渐向教育、医疗等行业扩散。
趋势九
网络安全云化服务被用户广泛接纳
云计算与云应用已经成为IT基础设施，如何在公有云、私有云、混合云、边缘云以及云地混合环境中保障安全已成为未来组织发展的“刚需”。厂商需要积极应对软件化趋势，提升其产品的虚拟化、云化、SaaS化能力，从而抓住网络安全市场的下一个五年发展机遇。
云化趋势为网络安全产品服务提供更有利的运营模式。“网络安全即服务”（CSaaS）将继续成为许多公司的最佳解决方案之一，以允许所使用的服务随时间变化并定期调整，确保满足客户的业务需求。在网络安全人才短缺、安全态势瞬息万变、安全防护云化的今天，用户愿意为硬件出高价而不愿意在软件甚至服务上投入的情况将得到改善，在数据安全政策法规和网络安全保险服务的共同支撑下，中小企业采购云化的网络安全服务意愿将增强，政务网络安全托管服务为广大政务用户提供了一种更经济、更便捷、更有效的选择。
趋势十
人工智能网络攻防呈现对抗发展演化
人工智能可以通过发现和检测网络攻击的安全威胁来提升自身网络安全保护水平，但人工智能也可能被恶意用于创建更加复杂的攻击，增加网络攻击监测发现的难度。网络安全从人人对抗、人机对抗逐渐向基于人工智能的攻防对抗发展演化。随着新一代人工智能技术的提出与发展，攻击方将利用人工智能更快、更准地发现漏洞，产生更难以检测识别的恶意代码，发起更隐秘的攻击，防守方则需要利用人工智能提升检测、防御及自动化响应能力。基于人工智能的自动化渗透测试、漏洞自动挖掘技术等将为这一问题的解决提供新的可能。
在国家大力推进数字化转型、激发数据要素价值的大背景下，我国网络与数据安全政策法规、技术标准不断完善，促进数据要素价值发挥和数据安全产业的规划不断出台，科技自强自立和扩大内循环在全国上下形成共识，自主可信可控成为不可逆转的趋势。2023年，网络安全行业将更加注重核心关键技术攻关，以重点产业带动网络新兴产业发展，促进网络安全自主技术的广泛应用，网络安全产业蓬勃发展的势头将继续保持。
如果你对网络安全入门感兴趣，那么你需要的话可以点击这里👉网络安全重磅福利：入门&amp;进阶全套282G学习资源包免费分享！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/225cbbac5436a0e64a2d12a2cfd71bcd/" rel="bookmark">
			综述：自动驾驶中的 4D 毫米波雷达
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文链接：《4D Millimeter-Wave Radar in Autonomous Driving: A Survey》
摘要 4D 毫米波 (mmWave) 雷达能够测量目标的距离、方位角、仰角和速度，引起了自动驾驶领域的极大兴趣。这归因于其在极端环境下的稳健性以及出色的速度和高度测量能力。
然而，尽管与其传感理论和应用相关的研究迅速发展，但对 4D 毫米波雷达主题的调查却明显缺乏。为了弥补这一差距并促进该领域的未来研究，论文对 4D 毫米波雷达在自动驾驶中的使用进行了全面调查。
首先回顾了4D毫米波雷达的理论背景和进展，包括信号处理流程、分辨率提高方法、外参标定过程和点云生成方法。然后介绍了自动驾驶感知、定位和建图任务中的相关数据集和应用算法。最后，论文对4D毫米波雷达领域的未来趋势进行了预测。
引言 自动驾驶技术正在快速发展，旨在提供安全、便捷、舒适的交通体验。要实现高水平自动驾驶，环境感知、定位、建图能力至关重要。因此，自动驾驶汽车上的传感器（例如摄像头、激光雷达和雷达）及其算法正引起越来越多的研究兴趣。
在各种传感器中，毫米波雷达凭借其体积小、成本低、全天候工作、测速能力和距离分辨率高等公认的优势，一直被广泛应用于自动驾驶领域。然而，传统毫米波雷达（也称为3D毫米波雷达）在测量目标仰角方面表现较差，其数据通常仅包括距离、方位角和速度信息。此外，3D 毫米波雷达还存在杂波、噪声和低分辨率的问题，特别是在角度维度上，这进一步限制了它们在复杂感知任务中的适用性。
MIMO 天线技术的最新进展提高了仰角分辨率，从而导致了 4D 毫米波雷达的出现。顾名思义，4D毫米波雷达可以测量四种类型的目标信息：距离、方位角、仰角和速度。
4D毫米波雷达不仅是毫米波雷达的改进版本，还引入了许多重要的研究课题。 4D毫米波雷达的原始数据量比传统雷达大得多，这给信号处理和数据生成带来了挑战，更不用说杂波和噪声了。现有信号处理流程中生成的4D毫米波雷达点云的稀疏性和噪声比LiDAR点云更严重，需要仔细设计考虑4D毫米波雷达固有特性的感知、定位和建图算法。
论文对自动驾驶中的 4D 毫米波雷达进行了全面回顾。主要贡献可概括如下：
1，首次针对自动驾驶中的 4D 毫米波雷达进行的调查；
2，鉴于4D毫米波雷达的独特性，专门介绍了其理论背景和信号处理流程；
3，对自动驾驶中的 4D 毫米波雷达应用算法进行了详尽的调查，涵盖感知、定位和建图方面的研究。
4D 毫米波雷达的背景 信号处理流程 在步骤 1 中，从发射 (TX) 天线发射毫米波。到达周围目标后，电波被反射到接收 (RX) 天线。大多数现有 4D 毫米波雷达的波形是调频连续波 (FMCW)，与其他波形相比，它具有卓越的分辨率。在 FMCW 雷达发射天线的每个工作周期（即啁啾）中，信号的频率随着起始频率 f c fc fc、带宽 B B B、频率斜率 S S S 和持续时间 T c T_c Tc​ 线性增加。通过测量接收信号的频率，可以计算出目标的距离 r r r，如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/225cbbac5436a0e64a2d12a2cfd71bcd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08d818dc374016933ae342159c20d532/" rel="bookmark">
			使用opencv把视频转换为灰色并且逐帧率转换为图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		功能介绍 使用opencv库把视频转换为灰色，并且逐帧率保存为图片到本地
启动结果
整体代码 import cv2 import os vc = cv2.VideoCapture('test.mp4') if vc.isOpened(): open, frame = vc.read() else: open = False os.makedirs("grayAll", exist_ok=True) i = 0 while open: ret, frame = vc.read() if frame is None: break if ret == True: i += 1 gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) cv2.imwrite("grayAll/ps" + str(i) + ".png",gray) # 释放硬件资源 vc.release() cv2.destroyAllWindows() 代码解释 这是一个控制文件的库十分的好用
import os os.makedirs("grayAll", exist_ok=True) exist_ok=True 如果有这个文件夹则不创建，没有才创建 "grayAll"要创建的文件夹名字
vc = cv2.VideoCapture('test.mp4') 读入视频文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08d818dc374016933ae342159c20d532/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7ea634aa62be389c90548dca5a531f9/" rel="bookmark">
			Jetpack Compose 快速上手
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Composable 注解与 Preview package com.tiger.compose0117 import android.os.Bundle import androidx.activity.ComponentActivity import androidx.activity.compose.setContent import androidx.compose.foundation.Image import androidx.compose.foundation.layout.Column import androidx.compose.foundation.layout.Row import androidx.compose.foundation.layout.fillMaxSize import androidx.compose.foundation.layout.height import androidx.compose.foundation.layout.padding import androidx.compose.foundation.layout.width import androidx.compose.foundation.shape.CircleShape import androidx.compose.foundation.shape.RoundedCornerShape import androidx.compose.material3.MaterialTheme import androidx.compose.material3.Surface import androidx.compose.material3.Text import androidx.compose.runtime.Composable import androidx.compose.ui.Modifier import androidx.compose.ui.draw.clip import androidx.compose.ui.graphics.ImageBitmap import androidx.compose.ui.res.imageResource import androidx.compose.ui.tooling.preview.Preview import androidx.compose.ui.unit.dp import com.tiger.compose0117.ui.theme.Compose0117Theme class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { MessageCard(name = "My Android") } } @Composable fun MessageCard(name: String) { Text(text = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7ea634aa62be389c90548dca5a531f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7db1bdca1eb51dfe5e26e227a0c2820/" rel="bookmark">
			四、基础篇 vue条件渲染
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		v-if v-if 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 truthy 值的时候被渲染。
&lt;template&gt; &lt;div class="content"&gt; &lt;div v-if="show"&gt;show渲染了&lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { show: true } }, } &lt;/script&gt; &lt;style scoped&gt; &lt;/style&gt; 也可以使用v-else ，添加else块：
&lt;div v-if="show"&gt;show渲染了&lt;/div&gt; &lt;div v-else&gt;show不渲染了&lt;/div&gt; 在 &lt;template&gt; 元素上使用 v-if 条件渲染分组 因为 v-if 是一个指令，所以必须将它添加到一个元素上。但是如果想切换多个元素呢？此时可以把一个 &lt;template&gt; 元素当做不可见的包裹元素，并在上面使用 v-if。最终的渲染结果将不包含 &lt;template&gt; 元素。
&lt;template v-if="ok"&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;p&gt;Paragraph 1&lt;/p&gt; &lt;p&gt;Paragraph 2&lt;/p&gt; &lt;/template&gt; v-else 你可以使用 v-else 指令来表示 v-if 的“else 块”：
&lt;div v-if="Math.random() &gt; 0.5"&gt; Now you see me &lt;/div&gt; &lt;div v-else&gt; Now you don't &lt;/div&gt; v-else 元素必须紧跟在带 v-if 或者 v-else-if 的元素的后面，否则它将不会被识别。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7db1bdca1eb51dfe5e26e227a0c2820/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9452550cb5a0a0448a0e1aa78605ab89/" rel="bookmark">
			python爬虫---网页爬虫，图片爬虫，文章爬虫，Python爬虫爬取新闻网站新闻！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		零基础入门Python，做网站文章的爬虫小项目，因为实战是学代码的最快方式。 爬虫目标 1，学习Python爬虫2，爬取新闻网站新闻列表3，爬取图片4，把爬取到的数据存在本地文件夹或者数据库5，学会用pycharm的pip安装Python需要用到的扩展包 一，首先看看Python是如何简单的爬取网页的 1，准备工作 项目用的BeautifulSoup4和chardet模块属于三方扩展包，如果没有请自行pip安装，我是用pycharm来做的安装，下面简单讲下用pycharm安装chardet和BeautifulSoup4
在pycharm的设置里按照下图的步骤操作
如下图搜索你要的扩展类库，如我们这里需要安装chardet直接搜索就行，然后点击install package, BeautifulSoup4做一样的操作就行
安装成功后就会出现在在安装列表中，到此就说明我们安装网络爬虫扩展库成功 二，由浅入深，我们先抓取网页 我们这里以抓取简书首页为例：www.jianshu.com/
# 简单的网络爬虫 from urllib import request import chardet response = request.urlopen("http://www.jianshu.com/") html = response.read() charset = chardet.detect(html)# {'language': '', 'encoding': 'utf-8', 'confidence': 0.99} html = html.decode(str(charset["encoding"])) # 解码 print(html) 由于抓取的html文档比较长，这里简单贴出来一部分给大家看下
&lt;!DOCTYPE html&gt; &lt;!--[if IE 6]&gt;&lt;html class="ie lt-ie8"&gt;&lt;![endif]--&gt; &lt;!--[if IE 7]&gt;&lt;html class="ie lt-ie8"&gt;&lt;![endif]--&gt; &lt;!--[if IE 8]&gt;&lt;html class="ie ie8"&gt;&lt;![endif]--&gt; &lt;!--[if IE 9]&gt;&lt;html class="ie ie9"&gt;&lt;![endif]--&gt; &lt;!--[if !IE]&gt;&lt;!--&gt; &lt;html&gt; &lt;!--&lt;![endif]--&gt; &lt;head&gt; &lt;meta charset="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9452550cb5a0a0448a0e1aa78605ab89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fee86e216e76bac8a90a8517d2aa2112/" rel="bookmark">
			【问题&#43;解决】axios/vue/element/echarts引入报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 缘由 笔者在html页面引用vue来快速实现页面；&lt;head&gt;&lt;/head&gt;中通过&lt;script&gt;src=""&gt;&lt;/script&gt;方法引入，开始引入，应用都是正常，后来用了也没问题；奇怪的是，前几天发现html页面无法出现效果图
更新线上项目发现，html页面加载慢；接口请求超时；页面样式也出现了问题；
当时的引入unpkg &lt;link rel="stylesheet" href="https://unpkg.com/element-ui/lib/theme-chalk/index.css"&gt;
&lt;script src="https://unpkg.com/vue@2/dist/vue.js"&gt;&lt;/script&gt;
&lt;script src="https://unpkg.com/element-ui/lib/index.js"&gt;&lt;/script&gt;
&lt;script src="https://unpkg.com/axios/dist/axios.min.js"&gt;&lt;/script&gt;
&lt;script src="https://cdn.bootcss.com/echarts/4.2.1-rc1/echarts.min.js"&gt;&lt;/script&gt;
排查 经过排查就是这种的引入方式失效了，引入当时也是根据官方文档引入的，纳闷了，之前还好好的，怎么突然出问题了；
排查发现这种的引入不是正确的，记得之前引入，是cdn，排查发下，它的引入方式是unpgk，进而导致的
正确的引入cdn 替换内容
&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/element-ui/lib/theme-chalk/index.css"&gt;
&lt;script src="https://cdn.jsdelivr.net/npm/vue@2.6.14"&gt;&lt;/script&gt;
&lt;script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"&gt;&lt;/script&gt;
&lt;script src="https://cdn.jsdelivr.net/npm/element-ui/lib/index.js"&gt;&lt;/script&gt;
&lt;script src="http://cdn.jsdelivr.net/npm/axios@0.19.0/dist/axios.min.js"&gt;&lt;/script&gt;
&lt;script src="https://cdn.bootcss.com/echarts/4.2.1-rc1/echarts.min.js"&gt;&lt;/script&gt;
大家想用直接复制就行。
&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/element-ui/lib/theme-chalk/index.css"&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.6.14"&gt;&lt;/script&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.jsdelivr.net/npm/element-ui/lib/index.js"&gt;&lt;/script&gt; &lt;script src="http://cdn.jsdelivr.net/npm/axios@0.19.0/dist/axios.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/echarts/4.2.1-rc1/echarts.min.js"&gt;&lt;/script&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa5f357c55e15bea2b3481701321a942/" rel="bookmark">
			【音视频】基于webrtc协议浏览器播放rtsp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 现阶段直播越来越流行，直播技术发展也越来越快。Webrtc和rtsp是比较火热的技术，而且应用也比较广泛。本文通过实践来展开介绍关于rtsp、webrtc的使用过程。
正文 本文是基于ffmpeg技术将mp4转换为rtsp视频流，并且将流推送到流媒体服务器（EasyDarwin）上，而后采用了webrtc-streamer对rtsp进行了播放。我相信会更好的别的使用方式，本文采取这种方式只是经过了一次实践做了一次记录，同时也分享给大家。
1、安装流媒体服务器 安装EasyDarwin-windows-8.1.0
2、启动流媒体服务器 启动命令：
EasyDarwin.exe 3、流媒体服务器运行 浏览器中输入http://localhost:10008/#/
4、Ffmpeg将mp4转换为rtsp 启动命令：
ffmpeg -re -i 2.mp4 -rtsp_transport tcp -vcodec libx264 -acodec aac -f rtsp rtsp://localhost/test 启动效果：
5、Ffmpeg推流之后的效果： 6、启动webrtc-streamer 7、查看webrtc的播放 通过浏览器查看webrtc的播放效果：
http://localhost:8000/webrtcstreamer.html?video=rtsp://localhost/test&amp;options=rtptransport=tcp&amp;timeout=60&amp;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/748978e5e7f8f59a7db7d7fa6b9bc2e3/" rel="bookmark">
			selenium-java中切换iframe
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、当iframe中有固定的name或者id时可以通过name和id进行切换,代码如下
driver.switchTo().frame("name"); 2、当iframe中没有固定的name或者id时可以通过iframe角标进行切换，在浏览器通过ctrl+f快捷键，搜索标签框输入//iframe;来查看当前iframe是第几个来定位，代码如下
注意：通过下标来定位时需要是同级别的，如果是需要定位到iframe中子级iframe时则需要先通过下标定位到父级再从0开始通过下标来定位子级，iframe中如果有嵌套则需要层层递进不可直接定i位到最里面的一级。
driver.switchTo().frame(0); 3、如果需要回到元素frame中则代码如下：
driver.switchTo().defaultContent(); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a638695d48cd320eb1141adba8e1ecc6/" rel="bookmark">
			spring框架解析(全)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		spring概述
spring容器启动
springIoc控制反转
spring依赖注入
spring事务
spring事件监听
springaop面向切面编程
–AOP用例搭建
–注解配置 Spring AOP详解
–@Transactional注解
spring工具类大全
spring注解大全
spring概述
spring是一个轻量级的容器,用于管理业务相关对象的。其两大内核：Ioc(控制反转)、aop(面向切面编程)。容器功能包括依赖注入(Dependency，简称DI)和依赖查找(Dependency Lookup)。
耦合与解耦
耦合是程序间的依赖关系包括：类间的依赖、方法间的依赖
解耦是降低程序间的依赖关系,实际开发中应该做到，编译器不依赖，运行时才依赖。
解耦的思路有两种：
1.使用反射来创建对象，而避免使用new关键字
2.通过读取配置文件来获取要创建的对象全限定类名
spring容器启动
在web项目中，启动spring容器的方式有三种,ContextLoaderListener、ContextLoadServlet、ContextLoaderPlugin
监听方式(web.xml)
&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/classes/applicationContext-*.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt; &lt;/listener&gt;	[注]还可以通过&lt;import resource="classpath:/spring/spring-xxx.xml"/&gt;的方式把其他的配置引进来
servlet方式(web.xml)
&lt;servlet&gt; &lt;servlet-name&gt;context&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.context.ContextLoaderServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; [注]这种方式在spring3.0以后不再支持,建议使用监听方式
通过plugin配置方式(web.xml)
&lt;plug-in className="org.springframework.web.struts.ContextLoaderPlugIn"&gt; &lt;set-property property="contextConfigLocation" value="/WEB-INF/applicationContext.xml,/WEB-INF/action-servlet.xml" /&gt; &lt;/plug-in&gt; [注]该方式适用于spring与strust等整合，在struts-config.xml里面配置一个ContextLoaderPlugIn，用于spring的初始化工作
springIoc控制反转
Ioc(控制反转)将对象的创建过程交给容器,让容器管理对象的生命周期,如创建,初始化,销毁等。目的是削减计算机程序的耦合(接触我们代码中的依赖关系)。
SpringIoc核心容器接口：ApplicationContext
常用实现类
a.ClassPathXmlApplicationContext 它可以加载类路径下的配置文件
b.FileSystemXmlApplicationContext 它可以加载磁盘任意路径下的配置文件(必须有访问权限)
c.AnnotationConfigApplicationContext 它是用于读取注解创建容器的
使用Ioc只需要实现即可：
ApplicationContext ac = new ClassPathXmlApplicationContext("Spring/bean.xml"); 现在把对象的创建交给Spring来管理就要知道Spring对bean的管理细节（创建bean的方式、bean的作用域）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a638695d48cd320eb1141adba8e1ecc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f87daf08ad3b588a820a0b325c28f89/" rel="bookmark">
			python list.sort方法和内置函数sorted
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		list.sort 方法会就地排序列表，也就是说不会把原列表复制一份。这也是这个方法的返回值是 None 的原因，提醒你本方法不会新建一个列表。在这种情况下返回 None 其实是Python 的一个惯例：如果一个函数或者方法对对象进行的是就地改动，那它就应该返回None，好让调用者知道传入的参数发生了变动，而且并未产生新的对象。例如，random.shuffle 函数也遵守了这个惯例。
用返回 None 来表示就地改动这个惯例有个弊端，那就是调用者无法将其串联起来。而返回一个新对象的方法（比如说 str 里的所有方法）则正好相反，它们可以串联起来调用，从而形成连贯接口（fluent interface）。详情参见维基百科中有关连贯接口的讨论（https://en.wikipedia.org/wiki/Fluent_interface）。
与 list.sort 相反的是内置函数 sorted，它会新建一个列表作为返回值。这个方法可以接受任何形式的可迭代对象作为参数，甚至包括不可变序列或生成器（见第 14 章）。而不管sorted 接受的是怎样的参数，它最后都会返回一个列表。不管是 list.sort 方法还是 sorted 函数，都有两个可选的关键字参数。
reverse
如果被设定为 True，被排序的序列里的元素会以降序输出（也就是说把最大值当作最小值来排序）。这个参数的默认值是 False。
key
一个只有一个参数的函数，这个函数会被用在序列里的每一个元素上，所产生的结果将是排序算法依赖的对比关键字。比如说，在对一些字符串排序时，可以用 key=str.lower 来实现忽略大小写的排序，或者是用 key=len 进行基于字符串长度的排序。这个参数的默认值是恒等函数（identity function），也就是默认用元素自己的值来排序。
可选参数 key 还可以在内置函数 min() 和 max() 中起作用。另外，还有些标准库里的函数也接受这个参数，像 itertools.groupby() 和 heapq.nlargest() 等。
下面通过几个小例子来看看这两个函数和它们的关键字参数:
&gt;&gt;&gt; fruits = ['grape', 'raspberry', 'apple', 'banana'] &gt;&gt;&gt; sorted(fruits) ['apple', 'banana', 'grape', 'raspberry'] &gt;&gt;&gt; fruits ['grape', 'raspberry', 'apple', 'banana'] &gt;&gt;&gt; sorted(fruits, reverse=True) ['raspberry', 'grape', 'banana', 'apple'] &gt;&gt;&gt; sorted(fruits, key=len) ['grape', 'apple', 'banana', 'raspberry'] &gt;&gt;&gt; sorted(fruits, key=len, reverse=True) ['raspberry', 'banana', 'grape', 'apple'] &gt;&gt;&gt; fruits ['grape', 'raspberry', 'apple', 'banana'] &gt;&gt;&gt; fruits.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f87daf08ad3b588a820a0b325c28f89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8db7fb54f09a6e178b402522afc7483/" rel="bookmark">
			啥是CTF？新手如何入门CTF？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CTF是啥 CTF 是 Capture The Flag 的简称，中文咱们叫夺旗赛，其本意是西方的一种传统运动。在比赛上两军会互相争夺旗帜，当有一方的旗帜已被敌军夺取，就代表了那一方的战败。在信息安全领域的 CTF 是说，通过各种攻击手法，获取服务器后寻找指定的字段，或者文件中某一个固定格式的字段，这个字段叫做 flag，其形式一般为 flag{xxxxxxxx}，提交到裁判机就可以得分。
信息安全的 CTF 的历史可以说很长了，最早起源于 96 年的 DEFCON 全球黑客大会
为啥要参加CTF 入门渗透，那肯定得各种练手对不对？但因为由于 「网络安全法」的颁布，随意扫描他人网站，或非授权渗透测试都有一定的风险。最近也有个新闻：
说实话，这小伙只是在扫描，攻击都被防火墙拦下了，啥都没弄到，结果还是一样被判刑，可谓是偷鸡不成蚀把米了……
所以记住千万不要乱扫国内的网站，尤其是教育、政府类网站。但初入门的同学学习渗透测试没有一个对应的环境也是不行的，而常见的靶机对于小白来说太过复杂，很容易不知如何下手。
这个时候 CTF 就非常适合了，CTF 一般是一个题目有一个或几个知识点相互糅合，相对来说目标性比较强。如果想要体会到安全的成就感和趣味性，促进自己边练边学，CTF 就是一个很好的选择。
CTF 的类型 CTF 题目类型一般分为 Web 渗透、RE 逆向、Misc 杂项、PWN 二进制漏洞利用、Crypto 密码破译，有志于渗透测试的同学一开始建议从 Web 渗透的题目开始，辅以 Misc 杂项和 Crypto 密码学。
CTF 主要分为两种模式，一是解题模式。对于 Web 安全来说，会要求你入侵网站或者靶机，攻击成功后系统会显示flag或者在某个目录 文件 数据库寻找 Flag，提交到答题系统得分。逆向工程题目一般形式是破解注册机、动态调试、dump 内存等等。这些题目可以百度或谷歌别人的解题报告（ 关键字：CTF writeup）来认识一下。
这种模式的缺点是类似于“应试教育”，当前的趋势是注重出题难、出题偏，没有考虑实际，就跟奥数似的。而且这种模式只有攻击，却没有防守，而在企业中工作更多的还是考虑如何防护的问题，这个时候 AWD 攻防赛模式就应运而生了。
二是攻防赛，也叫 AWD(Attack With Defense，攻防兼备)模式。你需要在一场比赛里要扮演攻击方和防守方，攻者得分，失守者会被扣分。也就是说，攻击别人的靶机可以获取 Flag 分数时，别人会被扣分，同时你也要保护自己的主机不被别人得分，以防扣分。
这种模式非常激烈，准备要非常充分，手上要有充足的防守方案和 EXP 攻击脚本。我第一次参加这种比赛的时候就被人打惨了QWQ，不过后面参赛越多，积累的经验就会越多。所以说，这种比赛不用慌，多打多学多积累就好了。
CTF 里面也有一血之说，谁第一个交 Flag 能获得分数加成，所以说手快也很重要。不过一般来说是没有别的大佬手快的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8db7fb54f09a6e178b402522afc7483/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4c8fc80cae4372213f383397995aaf3/" rel="bookmark">
			Gitea Webhook报错 webhook.ALLOWED_HOST_LIST setting
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Gitea Webhook报错 webhook.ALLOWED_HOST_LIST setting 登录到Gitea中，编辑app.ini
vi /data/gitea/conf/app.ini
[webhook] ALLOWED_HOST_LIST = 你的IP地址 示例
[webhook] ALLOWED_HOST_LIST = 192.168.3.98 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef9321f468553b8298f558022e9f0922/" rel="bookmark">
			学习JavaEE的日子 day13补 深入类加载机制及底层
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深入类加载机制 初识类加载过程 使用某个类时，如果该类的class文件没有加载到内存时，则系统会通过以下三个步骤来对该类进行初始化
1.类的加载（Load） → 2.类的连接（Link） → 3.类的初始化（Initialize）
类的加载（Load）：将类的class文件读入内存，并为之创建一个java.lang.Class的对象，此过程由类加载器（ClassLoader ）完成类的连接（Link）：将类中的数据加载到各个内存区域中类的初始化（Initialize）：JVM负责对类进行初始化 深入类加载过程 类的完整生命周期 ：加载、连接（验证、准备、解析）、初始化、使用、卸载
加载
通过一个类的全限定名来获取其定义的二进制字节流
将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构
在堆中生成一个代表这个类的Class对象，作为方法区中这些数据的访问入口
注意： 相对于类加载过程的其他阶段而言，加载阶段是可控性最强的阶段，因为程序员可以使用系统的类加载器加载，还可以使用自己的类加载器加载，在这里我们只需要知道类加载器的作用就是上面虚拟机需要完成的三件事
连接
验证
文件格式的验证：验证.class文件字节流是否符合class文件的格式的规范，并且能够被当前版本的虚拟机处理
元数据验证：主要是对字节码描述的信息进行语义分析，以保证其描述的信息符合java语言规范的要求，比如说验证这个类是不是有父类，类中的字段方法是不是和父类冲突等等。
字节码验证：这是整个验证过程最复杂的阶段，主要是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。在元数据验证阶段对数据类型做出验证后，这个阶段主要对类的方法做出分析，保证类的方法在运行时不会做出威胁虚拟机安全的事。
符号引用验证：它是验证的最后一个阶段，发生在虚拟机将符号引用转化为直接引用的时候。主要是对类自身以外 （常量池中的各种符号引用） 的信息进行校验。目的是确保解析动作能够完成。
注意： 对整个类加载机制而言，验证阶段是一个很重要但是非必需的阶段，如果我们的代码能够确保没有问题，那么我们就没有必要去验证，毕竟验证需要花费一定的的时间。当然我们可以使用
-Xverfty:none来关闭大部分的验证。
准备 - 重要
准备阶段主要为类变量（static）分配内存并设置初始值。这些内存都在方法区分配。在这个阶段我们只需要注意两点就好了，类变量和初始值两个关键词：
类变量（static）：会分配内存，但不会对应的分配值，其次实例变量不会分配空间，因为实例变量主要随着对象的实例化一块分配到java堆内存中
初始值：这里的初始值指的是数据类型默认值，而不是代码中被显示赋予的值
比如1：public static int value = 1;
在这里准备阶段过后的value值为0，而不是1赋值为1的动作在初始化阶段
比如2：public static final int value = 1;
同时被final和static修饰准备阶段之后就是1了，因为static final在编译器就将结果放入调用它的类的常量池中
解析
解析阶段主要是虚拟机将常量池中的符号引用转化为直接引用的过程
符号引用：以一组符号来描述所引用的目标，可以是任何形式的字面量，只要是能无歧义的定位到目标就好，就好比在班级中，老师可以用张三来代表你，也可以用你的学号来代表你，但无论任何方式这些都只是一个代号（符号），这个代号指向你（符号引用）直接引用：直接引用是可以指向目标的指针、相对偏移量或者是一个能直接或间接定位到目标的句柄。和虚拟机实现的内存有关，不同的虚拟机直接引用一般不同补充： 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行 初始化
这是类加载机制的最后一步，在这个阶段，java程序代码才开始真正执行。在准备阶段已经为类变量赋过一次值。在初始化阶端，程序员可以根据自己的需求来赋值了。一句话描述这个阶段就是执行类构造器clinit()方法的过程。
在初始化阶段，主要为类的静态（stitic）变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量（stitic）进行初始化。在Java中对类变量进行初始值设定有两种方式：
声明类变量是指定初始值使用静态代码块为类变量指定初始值 补充：clinit() 方法具有以下特点：
由编译器自动收集类中所有类变量（static）的赋值动作和静态语句块（static{} 块）中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码 class Test { static { i = 0; // 给变量赋值可以正常编译通过 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef9321f468553b8298f558022e9f0922/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff19ef1379c2ffe5405888ae10d72e15/" rel="bookmark">
			Python进阶知识：整理3 -＞ 设计模式（单例模式、工厂模式）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 单例模式 # 单例模式：确保一个类只有一个实例，并提供一个全局访问点。 class Singleton: pass st = Singleton() """ 在其它文件中import, 使用上述类时，无论实例化多少对象，得到对象id都是一样的，相当于实例化一个对象 ---&gt; 节省内存；节省创建对象的开销 """ 2 工厂模式 # -- coding: utf-8 -- """ 当需要大量创建一个类的实例的时候，可以使用工厂模式： 即从原生的使用类的构造去创建对象的形式，迁移到基于工厂提供的方法去创建对象的形式 """ """ 优点: 1.大批量创建对象的时候有统一的入口，易于代码的维护 2.当发生修改，仅需要修改工厂类的创建方法即可 3.符合现实世界的模式，即有工厂来制作产品（对象） """ class Person: pass class Worker(Person): pass class Student(Person): pass class Teacher(Person): pass class PersonFactory: def get_person(self, p_type): if p_type == 'worker': return Worker() elif p_type == 'student': return Student() elif p_type == 'teacher': return Teacher() else: return None pf = PersonFactory() worker = pf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff19ef1379c2ffe5405888ae10d72e15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8455b98d77b210119ce0498555516d16/" rel="bookmark">
			Java的学习简化要点，带你快速过一遍java（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习要求 1.学会idea的基础操作，建立项目，moudle，package，class类
2.学会创建数组，能够编写几个基础的排序算法。
3.学会创建方法，调用方法，了解什么是方法的重载
4.学会面向对象编程，能够debug调试代码，了解对象的内存存储方式
5.学会关键字static的用法，学会关于static方法的调用，掌握可变参数使用方法
6.了解面向对象的三大特征封装，继承，多态
多态 1.知道多态的前提
2.知道怎么用多态的方式new对象
3.知道多态的前提下，成员变量的访问特点
4.知道多态的好处
5.知道如何向下转型（将父类类型转成子类类型-&gt;强转）
前提 a.必须有父类继承关系或者接口实现关系
b.必须有方法的重写，没有方法的重写，多态没有意义（多态专门玩的就是重写方法）
c.父类引用执行子类对象
父类类型 对象名 = new 子类对象（）
d.弊端不能直接调用子类特有功能
使用方法 1.定义一个父类
2.定义一个子类继承父类，重写父类方法
3.new 对象的时候：父类引用指向子类对象
4.重写调用方法
多态的好处 1.不仅仅是体现在new对象上，而是体现在方法参数传递上
原始方法：
好处：既能调用自己特有的，还能调用重写的，还能调用父类的
坏处：扩展性差
多态方式：
好处：扩展性强
弊端：不能直接调用子类特有功能
多态中的转型 向上转型： 多态默认的，父类引用指向子类对象。 父类类型 对象名 = new 子类对象()
向下转型
子类类型 对象名 = （子类类型）对象名
转型的时候注意：ClassCastException -&gt; 类型转换异常 -&gt; 等号左右两边类型不一致
判断类型 instanceof
a 使用
对象名 instanceof 类型
b 含义
判断对象是否属于关键字后面的类型
c 结果 boolen类型
fianl关键字 用法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8455b98d77b210119ce0498555516d16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/492270c8597b2844666140c1256b2575/" rel="bookmark">
			redis总结--常见问题与解决办法，推荐等级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为csdn只支持这种文档形式：不支持思维导图：
更好友好的阅读：可以看我的飞书--------思维导图（这样食用更加）：
缓存穿透 问题原因 每次从缓存中都查不到数据，而需要查询数据库，同时数据库中也没有查到该数据，也没法放入缓存 如何解决 布隆过滤器 原理：布隆过滤器可以用于检索一个元素是否在一个集合中。 结构：概率型数据结构 使用 方式一：通过自己写算法实现布隆过滤器 方式二：使用网上存在的开源包 推荐指数：⭐⭐⭐(这个技术有些过时了，但是可以用) 优点：算法简单，可以自己配置 缺点： 存在一定的误判率 不支持删除操作 查找性能比布谷鸟底 空间利用率低 布谷鸟过滤器 要求条件：适用于对误判率要求较高的场景。 如网络路由、存储系统等 原理： 最简单的布谷鸟哈希结构是一维数组结构，会有两个 hash 算法将新来的元素映射到数组的两个位置。如果两个位置中有一个位置为空，那么就可以将元素直接放进去。但是如果这两个位置都满了，它就不得不「鸠占鹊巢」，随机踢走一个，然后自己霸占了这个位置。 近似集合数据结构 如何使用 方式一：自己写一个算法（我试过，比较复杂） 方式二：调用别人写的库 情况 优点： 相较于布隆过滤器具有更低的误判率 支持删除操作 查找性能高 空间利用率高 缺点： 删除不完美，存在误删的概率。 删除的时候只是删除了一份指纹副本，并不能确定此指纹副本是要删除的key的指纹。同时这个问题也导致了假阳性的情况。 插入复杂度比较高 随着插入元素的增多，复杂度会越来越高，因为存在桶满，踢出的操作，所以需要重新计算，但综合来讲复杂度还是常数级别。 存储空间的大小必须为2的指数 让空间效率打了折扣 同一个元素最多插入kb次（k指哈希函数的个数，b指的桶中能装指纹的个数） 如果布谷鸟过滤器支持删除，则必须存储同一项的多个副本。 插入同一项kb+1次将导致插入失败。 这类似于计数布隆过滤器，其中重复插入会导致计数器溢出。 推荐指数：⭐⭐⭐⭐⭐（绝对好用） 缓存空对象 方案一 要求条件：适中 推荐指数：⭐⭐⭐⭐（很常见的方式） 设置缓存的时候，同时设置一个过期时间，这样过期之后，就会重新去数据库查询最新的数据并缓存起来 方案二 要求条件：实时性要求非常高 推荐指数：⭐⭐⭐（要结合实际情况，考虑双写一致性的问题） 如果对的话，那就写数据库的时候，同时写缓存。这样可以保障实时性 方案三 要求条件：实时性要求不是那么高 推荐指数：⭐⭐⭐⭐（非常实用的方式） 那就写数据库的时候给消息队列发一条数据，让消息队列再通知处理缓存的逻辑去数据库取出最新的数据 校验参数 原理： 我们可以对用户id做检验。（请求合法性校验） 比如权限管理 推荐指数：⭐⭐⭐⭐⭐（这个必须做） 缓存击穿 问题原因 缓存击穿问题是由于key过期了导致的 如何解决 加锁 原理：在缓存失效的瞬间，通过加锁机制来保证只有一个请求能够访问数据库，其他请求等待获取缓存数据。 使用： 同一时刻只有一个请求才能访问某个信息 并且另一个线程将数据库中查询到的结果，又重新放入缓存中 推荐指数：⭐⭐⭐（非必要不加锁） 自动续期 原理：在key快要过期之前，就自动给它续期 推荐指数：⭐⭐⭐（本来要过期，但是续期的指令如何识别） 缓存不失效 原理：对于很多热门key，其实是可以不用设置过期时间，让其永久有效的。 推荐指数：⭐⭐⭐⭐（正对某些业务可以设置） 缓存雪崩 原因：有多个热门key同时失效（非常严重）：归根结底都是有大量的请求，透过缓存，而直接访问数据库了 有大量的热门缓存，同时失效。会导致大量的请求，访问数据库。而数据库很有可能因为扛不住压力，而直接挂掉。 缓存服务器宕机了，可能是机器硬件问题，或者机房网络问题。总之，造成了整个缓存的不可用。 解决办法 过期时间加随机数 推荐指数：⭐⭐⭐⭐（较为安全） 要求不要设置相同的过期时间 即使在高并发的情况下，多个请求同时设置过期时间，由于有随机数的存在，也不会出现太多相同的过期key 高可用（分布式部署） 推荐指数：⭐⭐⭐⭐（能在源头处理最好） 深层原因：针对缓存服务器宕机的情况， 原理：通过多个节点来分担缓存的压力，提高系统的容灾性 解决办法： 在前期做系统设计时，可以做一些高可用架构 redis可以使用哨兵模式，或者集群模式，避免出现单节点故障导致整个redis服务不可用的情况 服务降级（备份机制） 推荐指数：⭐⭐⭐⭐（做一个数据兜底） 更深的原因：做了高可用架构，redis服务还是挂了，该怎么办呢？ 解决办法：配置一些默认的兜底数据。 程序中有个全局开关，比如有10个请求在最近一分钟内，从redis中获取数据失败，则全局开关打开。就直接从配置中心中获取默认的数据。 还需要有个线程，每隔一定时间去从redis中获取数据 数据预热 原理：数据预热就是系统上线后，将相关的缓存数据直接加载到缓存系统，这样就可以避免在用户请求的时候先查询数据库 方式：在系统低峰期，提前对热点数据进行加载和缓存，避免大量数据同时失效 推荐指数：⭐⭐⭐⭐（不要等高峰了做预案） 双层缓存策略 C1为原始缓存，C2为拷贝缓存，C1失效时可以访问C2，C1缓存失效时间设置为短期，C2缓存失效时间设置为长期 推荐指数：⭐⭐⭐（万一都宕机就完蛋了） 定时更新缓存策略 原理：失效性要求不高的缓存，容器启动初始化加载，采用定时任务更新或移除缓存 使用：另起一个线程，去做任务处理 推荐指数：⭐⭐⭐⭐⭐（前期预防永远比后期解决来的好） 双写一致性（redis与mysql） 原因：分布式常见问题 数据库和缓存双写，就必然会存在不一致的问题 最终一致性： 要保证数据库与缓存可以先后一致 强一致性： 有强一致性要求的数据，不能放缓存 解决方法： 更新缓存 先写缓存，写数据库 问题程度：上上（很严重） 问题原因：刚写完缓存，突然网络出现了异常，导致写数据库失败了 推荐指数：⭐⭐（用的不多） 造成影响：容易诞生假数据 先写数据库，在写缓存 问题情况：写缓存失败了 问题程度：上 （严重） 问题原因：写数据库和写缓存，都属于远程操作。（通常建议写数据库和写缓存不要放在同一个事务中） 写数据库成功了，但写缓存失败了，数据库中已写入的数据不会回滚 推荐指数：⭐⭐ ⭐（接口性能要求不太高的系统） 造成影响：数据库是新数据，而缓存是旧数据，两边数据不一致的情况 问题情况：高并发先写数据库，在写缓存 问题程度：上上 （很严重） 问题原因：请求b在缓存中的新数据，被请求a的旧数据覆盖了。（请求互相覆盖） 推荐指数：⭐⭐（高并发场景，不适合） 造成影响：可能会出现数据库是新值，而缓存中是旧值，两边数据不一致的情况 问题情况：浪费系统资源 问题程度：上（严重） 问题原因：每写一次缓存，都需要经过一次非常复杂的计算 推荐指数：⭐⭐（计算要求低的情况） 造成影响：浪费cpu和内存资源 删除缓存 先删缓存，在写数据库 高并发下，单删 问题程度：中上（适度） 问题原因：请求A删除完缓存数据Data后，网络卡顿，写入数据库操作暂停。请求B读数据Data，缓存中没有，去数据库读，读的是旧数据。请求A网络好了，写入新数据到数据库 推荐指数：⭐⭐⭐（低并发下） 造成影响：请求A的新值并没有被请求B写入缓存，同样会导致缓存和数据库的数据不一致的情况 高并发下，缓存双删 问题程度：中下 （良好） 问题原因：写数据库之前删除缓存一次，写完数据库后，再删除缓存一次 推荐指数：⭐⭐⭐⭐（看情况推荐使用） 使用要点：第二次删除缓存，并非立马就删，而是要在一定的时间间隔之后。 原因：在另一个请求未生效前，删除这就没有意义了 造成影响：第二次删除可能失败 解决办法：重试机制 原理：更新了数据库成功了，但更新缓存失败了，可以立刻重试N次。如果其中有任何一次成功，则直接返回成功。如果N次都失败了，则写入数据库，准备后续再处理。 同步重试 推荐指数：⭐⭐⭐（） 原因：接口并发量比较高的时候，可能有点影响接口性能 异步重试 推荐指数：⭐⭐⭐⭐⭐ 方式一：每次都单独起一个线程，该线程专门做重试的工作 推荐指数：⭐⭐⭐ 原因：在高并发的场景下，可能会创建太多的线程，导致系统OOM问题 方式二：将重试的任务交给线程池处理 推荐指数：⭐⭐⭐⭐ 原因：如果服务器重启，部分数据可能会丢失 方式三：将重试数据写表存入数据库（定时任务） 推荐指数：⭐⭐⭐⭐（不适合实时性要求特别高的业务场景） 使用：定时任务进行重试 重试表（至少得有一下字段）： 重试次数字段 是否成功的状态字段 原理：设置初始值，每次删除重试次数字段加1，只要任意有一次成功就返回成功，同时修改状态，等待后续进一步处理 缺点：实时性没那么高 优点：数据是落库的，不会丢数据 方式四：将重试的请求写入mq等消息中间件 推荐指数：⭐⭐⭐⭐⭐（实时性还是比较高的） 使用：mq的consumer中处理 原理： 操作写完数据库，但删除缓存失败了，产生一条mq消息，发送给mq服务器 mq消费者读取mq消息，如果其中有任意一次成功了，则返回成功。重试N此后还是失败，写入死信队列中，后续需要人工处理 优点：mq的实时性还是比较高的 优化：删除缓存可以完全走异步。即用户的写操作，在写完数据库之后，不用立刻删除一次缓存。而直接发送mq消息，到mq服务器，然后有mq消费者全权负责删除缓存的任务。 方式五：订阅mysql的binlog 推荐指数：⭐⭐⭐⭐⭐（强烈推荐） 原理：订阅者中，如果发现了更新数据请求，则删除相应的缓存（监听binlog） 使用：canal等中间件，实现 原理：业务接口中写数据库之后，就不管了，直接返回成功，mysql服务器会自动把变更的数据写入binlog中，binlog订阅者获取变更的数据，然后删除缓存 问题：也会删除失败 解决办法：重试机制 推荐使用方式三和方式四（当推荐方式四） 先写数据库，再删缓存 问题程度：下上 （优秀） 问题原因：缓存过期失效，请求A查询数据发现缓存没有，去数据库查询，但是网络原因，没有及时更新缓存。请求B先写数据库，然后删除缓存。请求A恢复，更新缓存。 诞生条件（同时满足概率小） 缓存刚好自动失效 请求A查询数据库旧值以及更新缓存数据的时间，比请求B写入数据库以及删除缓存数据的时间长 一般数据库查询比数据库写入时间短（那种复合，聚合查询就不好说了） 推荐指数：⭐⭐⭐⭐⭐ (推荐使用) 使用指南：请求查询不要太过复杂 造成影响：最差的情况就是读取到旧数据（问题不算太大，刷新一下，重新请求，数据就对了），删除可能失效 解决办法：重试机制 原理：更新了数据库成功了，但更新缓存失败了，可以立刻重试N次。如果其中有任何一次成功，则直接返回成功。如果N次都失败了，则写入数据库，准备后续再处理。 同步重试 推荐指数：⭐⭐⭐（适合低并发） 原因：接口并发量比较高的时候，可能有点影响接口性能 异步重试 推荐指数：⭐⭐⭐⭐⭐（常见操作） 方式一：每次都单独起一个线程，该线程专门做重试的工作 推荐指数：⭐⭐⭐ 原因：在高并发的场景下，可能会创建太多的线程，导致系统OOM问题 方式二：将重试的任务交给线程池处理 推荐指数：⭐⭐⭐⭐ 原因：如果服务器重启，部分数据可能会丢失 方式三：将重试数据写表存入数据库（定时任务） 推荐指数：⭐⭐⭐⭐（不适合实时性要求特别高的业务场景） 使用：定时任务进行重试 重试表（至少得有一下字段）： 重试次数字段 是否成功的状态字段 原理：设置初始值，每次删除重试次数字段加1，只要任意有一次成功就返回成功，同时修改状态，等待后续进一步处理 缺点：实时性没那么高 优点：数据是落库的，不会丢数据 方式四：将重试的请求写入mq等消息中间件 推荐指数：⭐⭐⭐⭐⭐（实时性还是比较高的） 使用：mq的consumer中处理 原理： 操作写完数据库，但删除缓存失败了，产生一条mq消息，发送给mq服务器 mq消费者读取mq消息，如果其中有任意一次成功了，则返回成功。重试N此后还是失败，写入死信队列中，后续需要人工处理 优点：mq的实时性还是比较高的 优化：删除缓存可以完全走异步。即用户的写操作，在写完数据库之后，不用立刻删除一次缓存。而直接发送mq消息，到mq服务器，然后有mq消费者全权负责删除缓存的任务。 方式五：订阅mysql的binlog 推荐指数：⭐⭐⭐⭐⭐（强烈推荐） 原理：订阅者中，如果发现了更新数据请求，则删除相应的缓存（监听binlog） 使用：canal等中间件，实现 原理：业务接口中写数据库之后，就不管了，直接返回成功，mysql服务器会自动把变更的数据写入binlog中，binlog订阅者获取变更的数据，然后删除缓存 问题：也会删除失败 解决办法：重试机制 推荐使用方式三和方式四（当推荐方式四） 缓存的并发竞争 原因：多个redis的client同时set key引起的并发问题 多客户端同时并发写一个key，一个key的值是1，本来按顺序修改为2,3,4，最后是4，但是顺序变成了4,3,2，最后变成了2。 解决方案： 乐观锁 推荐指数：⭐⭐⭐（乐观锁适用于大家一起抢着改同一个key） 使用：watch 命令可以方便的实现乐观锁 缺点：如果 redis 使用了数据分片的方式，那么这个方法就不适用了 什么是数据分片？ 原理：Redis的分片机制允许数据拆分存放在不同的Redis实例上，每个Redis实例只包含所有键的子集 优点：可以减轻单台Redis的压力，提升Redis扩展能力和计算能力 分布式锁+时间戳 原理：加锁的目的实际上就是把并行读写改成串行读写的方式，从而来避免资源竞争 用一个状态值表示锁，对锁的占用和释放通过状态值来标识 加锁使用方法： 使用：使用redis中setnx()函数 返回1，则客户端获得锁，把锁的键值设置为时间值，表示该键已经被锁定，可以通过DEL lock.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/492270c8597b2844666140c1256b2575/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa4b6eaa4101518e1e9472fcb7b8c32e/" rel="bookmark">
			Python程序员常用的IDE和其它开发工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 “工欲善其事，必先利其器”，如果说编程是程序员的手艺，那么IDE就是程序员的吃饭家伙了。
IDE的全称是Integration Development Environment（集成开发环境），一般以代码编辑器为核心，包括一系列周边组件和附属功能。一个优秀的IDE，最重要的就是在普通文本编辑之外，提供针对特定语言的各种快捷编辑功能，让程序员尽可能快捷、舒适、清晰的浏览、输入、修改代码。对于一个现代的IDE来说，语法着色、错误提示、代码折叠、代码完成、代码块定位、重构，与调试器、版本控制系统(VCS)的集成等等都是重要的功能。以插件、扩展系统为代表的可定制框架，是现代IDE的另一个流行趋势。
IDE并非功能越多越好，因为更多的功能往往意味着更大的复杂度，这不但会分散程序员本来的精力，而且还可能带来更多的错误。只要基本功能满足需要，符合自己使用习惯的IDE才是最好的IDE。程序员的逻辑永远是：用最合适的工具做最合适的事情。
正因为此，比起大而全的IDE，以单纯的文本编辑器结合独立的调试器、交互式命令行等外部小工具也是另一种开发方式。由于python本身的简洁，因此在写小的代码片段以及通过示例代码学习时这种方式尤其适合。
常用IDE简介 这里简单介绍Python程序员中最流行的若干IDE。
内置IDE Python的各个常见发行版都有内置的IDE，虽然它们的功能一般不够强大完整，但简便易得就是最大的优势。 对于初学者来说，它们也是上手的最好选择，可以让你更专注于语言本身而不会被繁复的IDE分散精力。
IDLE IDLE是Python标准发行版内置的一个简单小巧的IDE，包括了交互式命令行、编辑器、调试器等基本组件，足以应付大多数简单应用。 IDLE是用纯Python基于Tkinter编写的的，最初的作者正是Python之父Guido van Rossum本人。
One Day of IDLE Toying -- 《One Day of IDLE Toying》，图文并茂的入门文章
One Day of IDLE Toying -- 《One Day of IDLE Toying》中文版
PythonWin PythonWin是Python Win32 Extensions(半官方性质的python for win32增强包)的一部分，也包含在ActivePython的windows发行版中。如其名字所言，只针对win32平台。
总体来说，PythonWin是一个增强版的IDLE，尤其是易用性方面(就像windows本身的风格一样)。除了易用性和稳定性之外，(简单的)代码完成和更强的调试器都是相对于IDLE的明显优势。
Python Win32 Extensions的下载页：Python for Windows Extensions download | SourceForge.net
ActivePython的主页：Download &amp; Install Python - ActiveState
MacPython IDE MacPythonIDE是Python的Mac OS发行版内置的IDE，可以看作是PythonWin的Mac对应版本，由Guido的哥哥Just van Rossum编写。
Emacs和Vim Emacs和Vim号称是这个星球上最强大(以及第二强大)的文本编辑器，对于许多程序员来说是万能IDE的不二(三?)选择。 比起同类的通用文本编辑器如UltraEdit，Emacs和Vim由于扩展功能的强大，可以针对性地搭建出更为完整便利的IDE。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa4b6eaa4101518e1e9472fcb7b8c32e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf6429d686277cdfc585f8e568ff373f/" rel="bookmark">
			Unity进行Oculus quest 2 VR开发的测试与打包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内容结构
软硬件准备
Unity项目创建
点击运行按钮进行项目调试
针对quest串流PC运行打包exe文件
针对quest独立运行打包apk文件
我使用的是quest2，unity的版本是2020.3.4
1 软硬件准备
1）oculus手机应用下载
使用手册上面提供了软件的下载方式
但是Google Play并不提供国内的软件下载
软件下载好之后，注册并登录账号。
配对quest2 → 点击已配对的quest2→ 更多设置 → 启用开发者模式
（不启用开发者模式就不能向quest安装自己开发的应用）
2）oculus电脑应用下载
下载地址：https://www.oculus.com/setup/
登录账号
设置 → 通用 → 开启允许未知来源
设置 → 公测版 → 开启公测渠道
3）Unity下载
下载地址：https://unity.cn/releases
我使用的是2020.3.4
请从官网下载 unity hub，再从 Hub 去下载Unity，否则后面无法像oculus开发者手册中介绍的那样从Hub下载Android SDK NDK JDK
GIF
4）下载Oculus ADB Drivers
下载地址：https://developer.oculus.com/downloads/package/oculus-adb-drivers
安装好之后，快捷键WIN+R，输入cmd，调出命令窗口
输入adb help回车，adb安装好显示的界面是这样的
用USB连接PC和quest2头显，在头显中允许usb进行调试和数据访问
在命令窗口中键入adb devices回车，能看到你的设备被检测到
2 Unity项目创建
创建一个新的3D项目，导入Oculus integration资源包。
Oculus Integration资源包在Unity asset中下载。
导入之后会提示你进行升级并重启。
在Project窗口中打开oculus → SampleFramwork → Usage → HandsInteractionTrainScene 作为打包示例场景。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf6429d686277cdfc585f8e568ff373f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36b18f16237f9d90100146a2c34ec857/" rel="bookmark">
			2024年华数杯国际赛B题数据集分享 光伏数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了帮助大家更好的的比赛，本次将仿照美赛助攻的方式，为大家提供今年华数杯国际赛B题的解题数据，解题数据对于美赛、华数杯国际赛这种英文数学建模竞赛也是一场常见的难点。本文将简述本次竞赛收集到的数据集，稍后也会发布视频说明这些数据是如何找到的。
数据库以及B题资料分享链接：https://pan.baidu.com/s/1DQEOPAt-gTS3NwEk99_9Iw
提取码：sxjm
对于问题一、中国的电力供应与许多因素相互作用。请研究它们之间的关系，并预测中国从2024年到2060年电力供应的发展趋势。
我们为大家收集到了中国电力的相关数据，如下表所示。对于其他因素，为了方便大家选择，我们在世界银行、国家统计局等收集了近1500个其他中国的指标，希望能够对大家求解问题一有所帮助。
指标
2021年
电力可供量(亿千瓦小时)
85200.1
电力生产量(亿千瓦小时)
85342.5
水电生产电力量(亿千瓦小时)
13390
火电生产电力量(亿千瓦小时)
58058.7
核电生产电力量(亿千瓦小时)
4075.2
风电生产电力量(亿千瓦小时)
6561
电力进口量(亿千瓦小时)
59.4
电力出口量(亿千瓦小时)
201.8
问题二、在建设光伏电站时需要考虑许多因素。这需要考虑成本和收益，以及地理和照明条件。请选择一个区域，讨论在那里建设光伏电站的可行性。
对于问题二，根据之前给大家分析的思路，我们在一些网站收集到了部分数据集，如下所示
问题三、如果您想在中国建设多个光伏电站，请结合中国的地理资源和投资能力、成本和收入因素，中国光伏发电的最大潜力是什么？换句话说，中国的最大光伏发电量是多少？
问题四、为了实现中国政府到2060年实现碳达峰和碳中和的战略目标，用清洁能源替代燃煤发电是一个绝妙的想法。这个想法能实现吗？请研究中国光伏发电可持续发展的战略规划，并回答这个备受期待的问题。
对于问题四，由于涉及到碳排放相关指标，因此，我们收集到了2023年研赛D题的数据集，
下面是收集数据的部分网站
中国国家能源局2012年以后的数据
2021 electricity &amp; other energy statistics (preliminary) | China Energy Portal | 中国能源门户
维基百科 中国的太阳能发电
https://en.wikipedia.org/wiki/Solar_power_in_China
户用光伏累计装机超百GW 助力乡村振兴与能源转型
户用光伏累计装机超百GW 助力乡村振兴与能源转型_电力网
根据国家能源局发布的数据，2023年前三季度，全国可再生能源新增装机1.72亿千瓦，同比增长93%，占前三季度新增装机的76%。值得关注的是，截至2023年9月底，全国可再生能源装机约13.84亿千瓦，约占我国总装机的49.6%，已超过火电装机，堪称是重要的行业里程碑。
光伏发电方面，2023年前三季度，光伏新增装机12894万千瓦(128.94GW)，同比增长145%，其中集中式光伏6180万千瓦(61.8GW)，分布式光伏6714万千瓦(67.14GW)，分布式光伏占比超过52%。分地区看，河南、山东、江苏、湖北等11个省(自治区)，前三季度光伏发电新增装机超过5GW，其中7省的分布式光伏占比都超过一半。最高的河南省，分布式光伏占比超过98.6%，成为名副其实的“分布式光伏发展热土”。
可下载全国各地数据集，需要花钱 2000-2023年 一个地点 费用为573元
羲和能源气象大数据平台 - 首页
哈尔滨工业大学（深圳）D栋楼顶，113.9745°E 22.5945°N。该地2020.09.08-2021.03.05相关数据
链接：https://pan.baidu.com/s/1X5PFX5ezuFOlGQRUxrHxBg
提取码：sxjm
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e52f3c13640eb43233a38f094a67058/" rel="bookmark">
			Oculus quest2 开发（一）环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、参考文档
https://developer.oculus.com/documentation/unreal/unreal-engine/
二、相关软件下载
Unreal Engine 4.27.1
Android Studio 4.2.2
Oculus Develper Hub
三、环境配置
1. Oculus Develper Hub
安装 Oculus ADB Drivers，用于识别 Oculus quest2 设备
2. Android Studio 4.2.2
用于管理 Java SDK、SDK Tools、build-tools。
下载 Android 10.0 SDK，21.1.6352462 版本的 NDK
3. Unreal Engine
用于 VR 游戏开发，按文档操作即可。
注意 平台/Android SDK 下配置各目录。
SDK：C:/Users/[username]/AppData/Local/Android/Sdk
NDK：C:/Users/[username]/AppData/Local/Android/Sdk/ndk/21.1.6352462
JAVA：/[path to android studio]/Android Studio/jre
四、可能遇到的问题
1. 启动时 build 失败。build fail with an exception
将 \Android\Sdk\build-tools\31.0.0 和 \Android\Sdk\build-tools\31.0.0\lib 下的 d8 改成 dx 作者：是前端呀 https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e52f3c13640eb43233a38f094a67058/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44a280fc385876a876644a2b3b822ee6/" rel="bookmark">
			RubyMine for Mac/win：提升Ruby和Rails开发的强大IDE
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着Ruby和Rails在Web开发领域的广泛应用，一款高效的开发工具对于提高生产力至关重要。JetBrains RubyMine正是这样一款值得信赖的集成开发环境（IDE）。作为Mac和Windows平台上的强大工具，RubyMine为开发者提供了卓越的代码编辑、实时分析和调试功能。
RubyMine的智能代码编辑器可提供丰富的代码提示和自动完成功能，帮助您更快地编写代码。无论是自动导入模块、代码片段还是重构工具，RubyMine都能为您节省大量时间。此外，通过实时分析和代码检查，RubyMine可以检测代码中的潜在错误，确保您的应用程序运行流畅。
对于团队协作，RubyMine集成了Git等版本控制系统，使代码审查和团队协作变得简单高效。您可以在IDE中直接查看代码差异、提交更改并管理分支，从而简化整个开发流程。
总之，如果您是一位Ruby和Rails开发者，那么RubyMine将是您提高生产力的必备工具。无论是初学者还是经验丰富的开发者，RubyMine都能为您带来卓越的开发体验。立即下载RubyMine，开始您的Ruby和Rails开发之旅吧！
Mac安装：JetBrains RubyMinev2023.2.5中文激活版
Win安装：JetBrains RubyMine v2023.2.5 激活版
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b14b30ea16639d548c0409893e1bec07/" rel="bookmark">
			谷歌和微软的ASR的差异和特点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为满足海外客户的业务需求，目前天天讯通的AI机器人系统正在对接谷歌和微软的ASR，目前微软的开发进入尾声了。
这两家是国际上知名的ASR厂商了，当然还有亚马逊、IBM等，之所以选择这两家来对接测试，主要也是海外的客户给我们提供的建议，毕竟这个客户以前就是在海外从事思科、Avaya的技术大牛。
那今天跟大家说说谷歌和微软的ASR各自有什么不同和他们的特点。
一、对接过程的不同：
1. API风格：
Google Cloud使用REST和gRPC两种API风格，开发者可以根据需求选择相应的接入方式。
Microsoft Azure提供了一系列的SDKs，可用于多种编程语言和平台，带来了可能性的灵活性，以及对不同客户端应用程序的原生支持。
2.认证方式：
Google Cloud通常使用OAuth 2.0协议进行身份验证和授权。
Microsoft Azure使用Azure Active Directory进行身份验证，并且提供了一系列的安全性和认证选项。
3.文档和支持：
Google和Microsoft都提供了详细的文档和开发者指南，但他们的社区支持、教程和案例研究就会有所不同。
二、特点以及优劣：
1.语种支持：
Google Cloud Speech-to-Text支持120多种语言和方言，适合需要支持多种语言的全球化应用。
Microsoft Azure Speech也支持多种语言，但可能在某些语种或方言上不如Google全面。
2. 实时识别能力：
Google支持实时语音识别，其流式传输功能可以即时转写长时间的语音。
Microsoft Azure同样支持实时转写，并提供了对实时、互动式会话场景的优化。
3. 准确性和识别性能：
准确性方面，两者都基于先进的深度学习模型，但在不同的用例和数据集上的表现可能会有所不同。
客户需要自行测试以确定哪个服务更适合特定的应用和语言。
4.价格：
Google和Microsoft的定价模型可能存在差异，例如按请求次数或音频长度计费，这可能会影响到成本考虑。
还需要考虑免费层额度和价格随使用量增加的折扣。
5. 自定义模型：
Google允许开发者通过上传特定领域的文本数据来训练自定义模型。
Microsoft也提供了类似的Custom Speech服务，允许开发者优化识别准确性，特别是针对特定词汇和噪音环境。
6. 集成和生态系统：
集成到现有的Google Cloud或Microsoft Azure的服务和工具可能更加方便些，因为这两家公司都提供了比较完善的云服务生态系统。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed5c66cb865022cb689ef98221356973/" rel="bookmark">
			【Java】HttpServlet类简单方法和请求显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、HttpServlet类简介🍀 Servlet类中常见的三个类有：☑️HttpServlet类，☑️HttpServletRequest类，☑️HttpResponse类
🐬其中，HttpServlet首先必须读取Http请求的内容。Servlet容器负责创建HttpServlet对象，并把Http请求直接封装到HttpServlet对象中，大大简化了HttpServlet解析请求数据的工作量💪
🐬使用HttpServlet类时，需要继承这个类、重写里面的方法并把重写的代码插入到Tomcat的既定流程当中
创建HttpServlet的步骤——“四部曲”
1）扩展HttpServlet抽象类； 2）覆盖HttpServlet的部分方法，如覆盖doGet()或doPost()方法； 3）获取HTTP请求信息。通过HttpServletRequest对象来检索HTML表单所提交的数据或URL上的查询字符串； 4）生成HTTP响应结果。通过HttpServletResponse对象生成响应结果，它有一个getWriter()方法，该方法返回一个PrintWriter对象。
2、HttpServlet类中的方法 （1）常见方法 HttpServlet类中常见的方法如下🌟
方法方法作用说明initservlet 被实例化之后,自动执行的方法.用来进行初始化工作这三个方法都不需要手动调用。Tomcat会在合适的时机，自动调用这三个方法destoryServlet 被销毁之前,自动执行的方法.用来进行释放资源的操作service每次收到 http 请求,就会自动执行的方法.处理请求, 计算响应(服务器的主逻辑)doGet用于获取服务器信息，并将其做为响应返回给客户端根据请求的方法，被service调用doPost用于客户端把数据传送到服务器端，Post适合发送大量的数据。doDelete/doPut/doOptions用来处理一个HTTP DELETE操作，这个操作允许客户端请求从服务器上删除URL/这个操作自动地决定支持哪一种HTTP方法/操作包含请求体的数据，Servlet应该按照他行事 （2）验证doGet、doPost、doDelete ·postman 什么是postman？
在开发APP接口的过程中，一般接口写完之后，后端开发都会模拟调用一下请求。在用Postman之前，对于一般的get请求基本都会用浏览器来简单模拟。
Postman是一款支持http协议的接口调试与测试工具，具有功能强大、使用简单且易用性好的特点🚀
postman下载地址
import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet("/method") public class MethodServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println("doGet-sys"); resp.getWriter().write("doGet"); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed5c66cb865022cb689ef98221356973/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d90b93099655631e01b4d6c9453657c8/" rel="bookmark">
			2024最新整理Python入门教程(超详细)，从零基础入门到精通，看完这一篇就够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
本文罗列了Python零基础入门到精通的详细教程，内容均以知识目录的形式展开。
01.python由来与发展介绍
02.项目开发流程
【文末有惊喜福利🎁】
第一章 markdown编辑器
01.markdown基本语法
02.Typora简介与安装
03.Windows上gitee+Typora设置图床
04.macOS上gitee+Typora设置图床
第二章 计算机核心基础
01.计算机组成原理
第三章 编程语言
01.编程语言介绍
02.python是解释型的强类型动态语言
第四章 Python解释器和集成环境
01.python的两层意思
02.Windows安装Python解释器
03.linux安装Python解释器
04.pip软件包管理工具介绍及基本使用
05.IDE集成开发环境介绍
06.IDE工具安装
07.IDE集成开发环境的基本使用
第五章 python入门
01.python语法之变量、常量
02.python语法之注释
03.python垃圾回收机制GC
04.Python语法入门之基本数据类型
05.用户交互与格式化输出
06.python入门之基本运算符
07.Python语法入门之流程控制if判断
08.python流程控制之while循环
09.python流程控制之for循环
10.python之数据类型之可变与不可变类型
11.python之深浅copy
12.python小数据池,代码块的深入剖析
13.拓展：Python格式化字符串的4种方式
第六章 数据类型的内置方法
01.python之数字类型内置方法
02.python之字符串类型内置方法
03.python之列表类型内置方法
04.python之元组类型内置方法
05.python之字典类型内置方法
06.python之集合类型内置方法
第七章 文件处理与字符编码
01.python之文件处理编码字符
02.python文件处理
03.python文件操作之修改
第八章 函数
01.python之函数的基本使用
02.python之函数Type-hinting
03.python之函数的参数
04.python之函数对象+函数嵌套
05.python之名称空间与作用域
06.python之闭包函数
07.python之装饰器
08.python之迭代器
09.python之生成器
10.python之三元表达式、生成式、生成器表达式
11.python之面向过程编程思想与匿名函数及其应用
12.python之内置函数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d90b93099655631e01b4d6c9453657c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9df9ccf8bcb06e700e4a35a050c0bdd9/" rel="bookmark">
			软考系分之计算机网络IP地址的表示(IPv4及IPv6)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、概要2、IPv4地址点分十进制和分类表示2.1 IPv4分类表示2.2 IPv4不分类表示2.3 IPv4特殊IP和子网划分 3、IPv6地址4、总结 1、概要 本篇介绍计算机网络中的IP地址，在网络工程师的考试中，IP地址是必考内容，但是在系统分析师的考察中，IP地址的考查重点，应该就是IPv4和IPv6的相关概念和IPv4中简单的子网划分计算了。
2、IPv4地址点分十进制和分类表示 2.1 IPv4分类表示 IP地址中，机器存放IPv4是32位二进制代码，每隔8位插一个空格，提高可读性，我们常见的IP地址，如192.168.1.1，是采用了点分十进制方法表示的。IPv4分为5类：A、B、C、D、E，具体范围参见如下图。
2.2 IPv4不分类表示 IPv4不分类表示，我们也经常见到，如128.1.1.1/20，它不按照A、B、C等分类规则表示，编址采用 IP地址/网格号的方式表示。
2.3 IPv4特殊IP和子网划分 IPv4地址数量有限，为了更好的使用IPv4，划分了一些私有地址，它不会注册到公网，每家企业、家庭等局域网都可以用；子网划分也是一样，为了避免资源浪费，根据主机个数划分最合适的网络分配方案。
3、IPv6地址 IPv6地址在系分考试中，不怎么常见，但依旧要了解其相关知识点。IPv6总共128位，相关特性包括：报文头更灵活、支持更多协议、需要身份认证、具有隐私权等。IPv4到IPv6过渡期间，采用的技术包括：双协议栈、隧道技术、翻译技术。
4、总结 I机器存放IPv4是32位二进制代码，每隔8位插一个空格，我们常见的IP地址，是采用了点分十进制方法表示的，IPv4分为5类，也可以用IP地址+网格号简单表示；A类私有地址10网段，B类私有地址172.16~172.31网段，C类私有地址192.168网段。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87ef6fc1d6acfb6472ff8a6775d2e1ec/" rel="bookmark">
			react15与react16的本质区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		React 15 和 React 16 在架构和一些核心特性上存在本质性的区别。
1.Reconciliation（协调）算法： React 15: React 15 使用了递归的协调算法，即采用深度优先遍历整个组件树来协调更新。这种方式在处理大型组件树或深度嵌套组件时可能导致性能问题。React 16: React 16 引入了 Fiber 架构，使用了一种更灵活的协调算法。Fiber 架构的核心思想是将协调过程拆分成可中断的小任务单元，允许在渲染过程中中断和恢复，以更好地响应用户输入，提高性能。 React Fiber 架构： React Fiber 架构是 React 16 引入的一种新的协调引擎，它重新设计了 React 的核心算法，提供了更灵活的调度和渲染机制。Fiber 架构的目标是改善 React 在大型应用中的性能，同时提供更好的用户体验和交互响应性。以下是 React Fiber 架构的一些关键特性和概念：1. Fiber 节点：在 Fiber 架构中，每个 React 元素都对应一个 Fiber 节点。Fiber 节点是一个轻量的 JavaScript 对象，用于描述 React 元素的信息，例如元素的类型、属性、子元素等。2. 协调：Fiber 架构引入了新的协调机制，通过协调器（Reconciler）来处理元素的更新和渲染。协调器使用一种深度优先遍历的算法来协调和调度 Fiber 节点，使得 React 能够更加灵活地处理更新和渲染的优先级。3. Fiber 树：Fiber 架构中的元素被组织成一个 Fiber 树。与传统的递归调度不同，Fiber 树的节点可以在不同时间点暂停、中断和恢复。这使得 React 能够在渲染时对任务进行切片，提高对用户输入的响应速度。4. 时间片（Time Slicing）：Fiber 架构引入了时间片的概念，将任务切分成小的时间片单元。这使得浏览器能够在每个时间片之间进行中断，执行其他任务，提高页面的交互响应性。5. 异步渲染： Fiber 架构支持异步渲染，可以将渲染工作分散到多个帧中，避免一次性渲染大量元素导致的卡顿。异步渲染使得 React 能够更好地适应复杂的应用场景，提高了整体的性能。6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87ef6fc1d6acfb6472ff8a6775d2e1ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1c8b0b9c9ec1a23b07d255aaac0bd19/" rel="bookmark">
			Kafka-消费者-KafkaConsumer分析-ConsumerNetworkClient
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前面介绍过NetworkClient的实现，它依赖于KSelector、InFlightRequests、Metadata等组件，负责管理客户端与Kafka集群中各个Node节点之间的连接，通过KSelector法实现了发送请求的功能，并通过一系列handle*方法处理请求响应、超时请求以及断线重连。
ConsumerNetworkClient在NetworkClient之上进行了封装，提供了更高级的功能和更易用的API。
在图中展示了ConsumerNetworkClient的核心字段以及其依赖的组件。
client:NetworkClient对象。delayedTasks:定时任务队列，DelayedTaskQueue是Kafka提供的定时任务队列的实现，其底层是使用JDK提供的PriorityQueue实现。
简单介绍一下PriorityQueue,这是一个非线程安全的、无界的、优先级队列，实现原理是小顶堆，底层是基于数组实现的，其对应的线程安全实现是PriorityBlockingQueue，这个定时任务队列中是心跳任务。metadata:用于管理Kafka集群元数据。unsent:缓冲队列，Map&lt;Node,List类型，key是Node节点，value是发往此Node的ClientRequest集合。unsentExpiryMs:ClientRequest在unsent中缓存的超时时长。wakeup:由调用KafkaConsumer对象的消费者线程之外的其他线程设置，表示要中断KafkaConsumer线程。wakeupDisabledCount:KafkaConsumer是否正在执行不可中断的方法。每进入一个不可中断的方法时，则增加一，退出不可中断方法时，则减少一。
wakeupDisabledCount只会被KafkaConsumer线程修改，其他线程不能修改。 ConsumerNetworkClient.poll()方法是ConsumerNetworkClient中最核心的方法，poll方法有多个重载，最终会调用poll(long timeout,long now,boolean executeDelayedTasks)重载，这三个参数的含义分别是：
timeout表示执行poll方法的最长阻塞时间(单位是ms),如果为0,则表示不阻塞；now表示当前时间戳；executeDelayedTasks表示是否执行delayedTasks队列中的定时任务。 下面介绍其流程，其中简单回顾一下NetworkClient的功能：
调用ConsumerNetworkClient.trySend方法循环处理unsent中缓存的请求。
具体逻辑是：对每个Node节点，循环遍历其对应的ClientRequest列表，每次循环都调用NetworkClient.ready方法检测消费者与此节点之间的连接，以及发送请求的条件。
若符合发送条件，则调用NetworkClient.send()方法将请求放入InFlightRequests队中等待响应，也放入KafkaChannel的send字段中等待发送，并将此消息从列表中删除。实现代码如下：
计算超时时间，此超时时间由timeout与delayedTasks队列中最近要执行的定时任务的时间共同决定。在下面的NetworkClient.poll()方法中，会使用此超时时间作为最长阻塞时长，避免影响定时任务的执行。
调用NetworkClient.poll方法，将KafkaChannel.send字段指定的消息发送出去。除此之外，NetworkClient.poll()方法可能会更新Metadata使用一系列handle*方法处理请求响应、连接断开、超时等情况，并调用每个请求的回调函数。
调用ConsumerNetworkClient.maybeTriggerWakeup方法，检测wakeup和wakeupDisabledCount,查看是否有其他线程中断。如果有中断请求，则抛出WakeupException异常，中断当前ConsumerNetworkClient.poll方法。
调用checkDisconnects方法检测连接状态。检测消费者与每个Node之间的连接状态，当检测到连接断开的Node时，会将其在unsent集合中对应的全部ClientRequest对象清除掉，之后调用这些ClientRequest的回调函数。 根据executeDelayedTasks参数决定是否处理delayedTasks队列中超时的定时任务，如果需要执行delayedTasks队列中的定时任务，则调用delayedTasks.poll()方法。
再次调用trySend方法。在步骤3中调用了NetworkClient.poll方法，在其中可能已经将KafkaChannel.send字段上的请求发送出去了，也可能已经新建了与某些Node的网络连接，所以这里再次尝试调用trySend方法。
调用ConsumerNetworkClient.failExpiredRequests()处理unsent中超时请求。它会循环遍历整个unsent集合，检测每个ClientRequest是否超时，调用超时ClientRequest的回调函数，并将其从unsent集合中删除。
分析完poll方法的详细步骤之后，我们下面来看其实现代码：
pollNoWakeup方法是poll方法的变体，表示执行不可被中断的poll方法。
具体逻辑是：在执行poll方法之前，会调用disableWakeups方法将wakeupDisabledCount加一，然后调用poll方法。这样，即使其他线程请求中断，也不会被响应。
poll(future)是poll方法的另一个实现阻塞发送请求的功能，代码如下所示。
在ConsumerNetworkClient.send方法中，会将待发送的请求封装成ClientRequest,然后保存到unsent集合中等待发送，具体代码如下。
在这里需要重点关注的是KafkaConsumer中使用的回调对象—RequestFutureCompletionHandler,其继承关系如图所示。
从RequestFutureCompletionHandler的继承关系上我们可以知道，它不仅实现了RequestCompletionHandler,它还继承了RequestFuture类。RequestFuture是一个泛型类，其核心字段如下所示。
isDone:表示当前请求是否已经完成，不管正常完成还是出现异常，此字段都会被设置为true。exception:记录导致请求异常完成的异常类，与value字段互斥。此字段非空则表示出现异常，反之则表示正常完成。value:记录请求正常完成时收到的响应，与exception字段互斥。此字段非空表示正常完成，反之表示出现异常。listeners:RequestFutureListener集合， 用来监听请求完成的情况。RequestFutureListener接口有onSuccess()和onFailure()两个方法，对应于请求正常完成和出现异常两种情况。 在RequestFuture中有两处典型设计模式的使用：一处是compose方法，使用了适配器模式；另一处是chain方法，使用了责任链模式。下面是compose方法的相关代码：
图展示了使用compose()方法进行适配后，回调时的调用过程，也可以认为是请求完成的事件传播流程。
当调用RequestFuture对象的complete()或raise()方法时，会调用RequestFutureListener的onSuccess()或onFailure()方法，然后调用RequestFutureAdapter&lt;T,S&gt;的对应方法，最终调用RequestFuture对象的对应方法。
RequestFuture.chain()方法的实现与compose()类似，也是通过RequestFutureListener在多个RequestFuture之间传递事件。下面是其具体代码：
RequestFuture提供了一系列检查请求完成情况的方法，以及管理listeners的方法，代码比较简单，不再赘述了。
介绍完RequestFutureCompleteHandler之后，回到ConsumerNetworkClient的分析上来。下面简单介绍ConsumerNetworkClient中几个常用的功能，代码比较简单，就不贴出来了：
awaitMetadataUpdate()方法：循环调用poll方法，直到Metadata版本号增加，实现阻塞等待Metadata更新完成。awaitPendingRequests()方法：等待unsent和InFightRequests中的请求全部完成(正常收到响应或出现异常)。put()方法：向unsent中添加请求。schedule()方法：向delayedTasks队列中添加定时任务。leastLoadedNode()方法：查找Kafka集群中负载最低的Node。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a5748355cb71dabd14b94d1a1834f9f/" rel="bookmark">
			PMP培训机构哪家好？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据一项调查显示，近80%的组织鼓励他们的项目经理获得PMP认证，并且有50%的组织要求项目经理必须具备PMP认证。目前市场上有许多机构提供PMP认证的培训项目，这就给人们选择合适机构的问题带来了困扰。因此，在考虑是否要获得PMP认证时，个人应首先核查自身是否符合报考条件。
先和大家说一下选择机构需要看哪些内容，在给大家举例一些机构的具体情况是怎样的。
【本文小目录】：
选择PMP机构看什么？
各大PMP机构对比情况。
一.选择PMP培训机构的考虑因素是什么？ 在选择PMP培训机构时，有几个重要因素需要考虑。首先，确保该机构具备获得"PMI"或"中国国际基金会人才交流中心"授权的资格。这是考证的必要条件之一，因此考生在选择机构时务必要关注此点。只需满足其中一个授权即可。知道如何查看机构是否满足授权要求吗？你可以直接在官方网站上进行搜索。如PMI官方网站可以提供相关信息。
此外，PMP考试的报考条件之一是必须具备35小时以上的项目管理学习或相关培训经历。因此，在选择机构时，要确保其提供的学习证明是由PMI官方授权的机构提供的，才能被视为有效凭证。
另外选择机构还需要查看这个机构的这些方面：服务、价格、师资、PDU、课程保障、资料等等。
01 课程与保障
从我身边的朋友那里了解到，不同机构的课程保障有所不同。有些机构提供的课程只能在考试期间观看，考完之后就无法再学习了。而有些机构则允许学习者永久学习，直到通过考试为止。尽管如此，部分机构可能会设置一年的学习期限，但相对来说还是比较人性化的。另外，关于刷题，也要了解是否有智能题库、章节闯关、错题巩固等功能，这样就不用担心没有题目可做。不过一般来说，机构都会提供自己的题库。
02 师资选择
选择培训机构时，老师的水平也是一个关键因素。有时候，即使机构声誉很好，服务很周到，但老师的教学方式不符合自己的喜好或者没有足够的教学收获，那就相当于白白支付了培训费，没有什么实质性的收益。我曾听过很多机构的课程，在网上搜索去听过，最终选择课程还是要根据自己喜好和适应情况来决定。毕竟学习是自己的事情，即使机构再好，如果自己无法倾听和接受，也不会有太大的效果。
03 教学服务/其他服务
报考PMP考试是所有考试中最繁琐的一个证书考试，需要中英文进行报名，而英文报名则是全英文操作。最好能找到一家能够代办报名的机构。另外，学习资料和教材的完整性也很重要，包括纸质刷题资料和重要知识点等等。其次，要了解是否提供续证60PDU的服务（每三年需要续证一次）。我了解到许多机构并不提供续证PDU的赠送，学员需要自己积攒。当然，如果有机构能提供终身免费积攒PDU的服务，那就更加方便了。此外，还要考虑教师和助教的督导服务以及考前模拟等是否到位。
二. 各大PMP机构对比情况 个人整理了一些PMP机构的详细基本情况，大家做一个参考，根据上方所提到的一些内容去做选择，当然可以根据自己在意的点去做选择也完全OK。
01 光环PMP培训
光环是一家在PMP培训行业中有着卓越实力的机构。他们提供线上和线下两种培训方式，其中线下课程只在北上广深等城市设立，其他地区仅提供线上远程录播+少量直播的方式授课。虽然价格相对较高，但光环的实力毋庸置疑。据我了解，光环目前正在转型远程培训。以下是他们的课程方案：
面授班：原价4480元，拼团价3680元；
线上录播+直播：原价3500元，拼团价2780元。
课程内容包括直播课和录播课，有效期为2年。视频课程共有31个小时，分为200个节次，还有20个小时的串讲视频课程，共38个节次。光环的师资力量由资深项目经理人组成的教资团队，学习资料包括纸质版官方教材、3套纸质版模拟题、纸质版知识集锦和纸质版5A备考宝典。服务方面，他们提供35学时证明、中英文代报名、考后PDU积累活动等。需要注意的是，直播课程次数较少，录播课程无法下载。周末和节假日不提供答疑服务。
02 现代卓越PMP培训
现代卓越提供的PMP培训价格相对较低，2880元起，课程有效期为两年。培训采用录播方式进行，共有112节课时和2次模考解析（总计230分钟）。学习资料包括一本《PMBOK指南》。他们提供组建PMP学习班级及小组群的服务，通过微信群，助教老师解答疑问。另外，学员可以终身免费积攒60PDU，并享受证书续证换审服务。值得注意的是，录播课程是提前录制好的，无法实时更新考点。这意味着机构可以节省成本，所以培训费用相对便宜。
03 中创教育PMP培训
中创教育的PMP培训价格原价3280元，底价2580元，课程有效期为一年。他们提供线上直播和录播的上课方式，每周会有2至3节课程。师资力量包括全职和兼职老师，其中兼职老师是名师级别。学习资料包括最新版PMBOK官方教材、考试培训讲义、重点知识点集锦和模拟题库。服务方面，中创教育提供群服务，助教和老师会解答疑问，并提供电话答疑服务。他们还提供PDU包括6年的服务，后期需要购买或参加线上活动来获取，比较麻烦。中创教育提供代报名服务，并赠送多个视频课程和纸质资料。
04 华夏智诚PMP培训
华夏智诚的PMP培训价格为2200元。培训方式为直播+录播，课程内容包括10节重点串讲和18节高清录播。学习资料包括5本书籍。服务方面，华夏智诚提供班级群答疑，考试不过可以免费重读一年。他们有多位老师，不过有些老师并未取得相关证书。
05 慧翔天地PMP培训
慧翔天地提供全程案例教学，面授学员还附赠网课。他们的培训价格为直播课程2680元（双十一特价为2580元），线下面授课程4380元（最低价3180元），有效期是2年，不过可以免费学。培训方式包括面授和直播。面授班的上课时间为平时班晚上8点至10点，周末班全天9点至下午5点（包括休息和午休，总计7小时）。学习资料包括5本纸质教材、辅导讲义+模拟题和3次模拟考试。他们提供组建PMP学习班级及小组群的服务，在群内授课老师亲自解答疑问。慧翔天地一周上一次课，互动较少，学生需要自主学习。授课老师的水平单一，有部分课程由非主讲老师授课。
以上这些内容你最好都了解清楚
备考资料分享如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cdbee401fe2546f576ac9af1562023d/" rel="bookmark">
			ArcGIS初始化软件界面Normal.mxt
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ArcGIS有时候永久了，或者呢突然不自觉软件界面乱了，或者一些窗口打开却找不到！
这时候可以去删除arcgis的界面配置文件，Normal.mxt
删除后再打开软件，软件界面就会回到初始化设置了！
文件所在的路径：
C:\Users\用户名\AppData\Roaming\ESRI\Desktop10.7\ArcMap\Templates 推荐学习： ArcGIS10.X入门实战视频教程（GIS思维） ArcGIS之模型构建器（ModelBuilder）视频教程 ArcGIS之遥感影像分类及成果应用视频课程 ArcPy结合数据驱动模块的批量制图 ArcGIS之Data Reviewer空间数据质量检查 GIS思维GIS系列技术课程 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd67b2ee1c2a5cf31578aa2e071bd978/" rel="bookmark">
			ERPNext vscode Debug
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		{
// Use IntelliSense to learn about possible attributes.
// Hover to view descriptions of existing attributes.
// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
"version": "0.2.0",
"configurations": [
{
"name": "Bench Runner",
"type": "python",
"request": "launch",
"python": "${workspaceFolder}/env/bin/python",
"program": "${workspaceFolder}/apps/frappe/frappe/utils/bench_helper.py",
"args": [
"frappe", "serve", "--port", "8000",
"--noreload", "--noreload", "--nothreading"
],
"cwd": "${workspaceFolder}/sites",
"env": {
"DEV_SERVER": "1"
}
}
]
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ba95d4be243e09eb4e18425f6172a08/" rel="bookmark">
			服务器VPS是什么意思?一文了解其含义与重要性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在今天的数字时代，服务器扮演着至关重要的角色，它们是网站、应用程序和在线业务的基石。但是，你是否听说过VPS?本文将深入探讨什么是服务器VPS，以及为什么它在今天的互联网世界中如此重要。
什么是服务器VPS?
服务器的基本概念
在我们深入探讨VPS之前，让我们首先了解一下服务器的基本概念。服务器是一种特殊的计算机，它们设计用于存储、处理和传输数据。这些数据可以是网站的页面、应用程序的代码，甚至是电子邮件和多媒体文件。
VPS的定义
VPS代表虚拟专用服务器。它是一种虚拟化技术，允许在单台物理服务器上运行多个虚拟服务器。每个VPS都像一个独立的服务器一样运行，具有自己的操作系统和资源。这使得多个用户可以共享一台物理服务器，而不会互相干扰。
为什么VPS如此重要?
成本效益
VPS相对于传统的独立服务器来说更加经济实惠。对于小型企业和个人网站所有者来说，它提供了一个实惠的托管解决方案。你可以根据自己的需求选择不同的VPS计划，从而控制成本。
灵活性和可扩展性
VPS提供了更大的灵活性和可扩展性。你可以根据需要轻松地增加或减少资源，而无需购买新的物理服务器。这使得它成为了适应不断变化的业务需求的理想选择。Hostease VPS拥有高性能的硬件和卓越的性能，确保您的网站或应用程序始终以最佳状态运行。无论您是运行小型博客还是大型电子商务网站，我们的VPS都能满足您的需求。
安全性
由于每个VPS都是独立的，它们之间是隔离的。这意味着如果一个VPS遇到安全问题，不会影响其他VPS。这提供了更高的安全性，使得你的数据和应用程序更加安全。
如何选择适合你的VPS?
资源需求
首先，你需要考虑你的资源需求。这包括处理器、内存、存储和带宽等方面。根据你的网站或应用程序的性质和预期的流量，选择合适的资源配置。
操作系统选择
你还需要选择适合你的操作系统。常见的选择包括Linux和Windows。你的应用程序和技术栈可能会影响你的操作系统选择。
可用性和支持
确保选择的VPS提供商提供良好的可用性和客户支持。这将确保在遇到问题时有人可以协助解决。
结论
服务器VPS是现代互联网世界的关键组成部分，它们提供了成本效益、灵活性和安全性。选择适合你需求的VPS是确保你的在线业务顺利运行的关键。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26e862a813dec3087089f0ebf500a610/" rel="bookmark">
			Docker consul、容器服务更新与发现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 实验前准备Consul部署建立consul服务器设置代理查看集群信息 Registrator服务器安装Gliderlabs/Registrator测试服务发现功能 部署consul-template准备template nginx模板文件编译安装nginx配置nginx配置并启动template访问template-nginx增加nginx容器节点 实验前准备 Consul服务器：192.168.188.17，consul服务，nginx服务，consul-template守护进程
Registrator服务器：192.168.188.11，registrator容器，nginx容器
Consul部署 建立consul服务器 mkdir /opt/consul
cp consul_0.9.2_linux_amd64.zip /opt/consul
cd /opt/consul
unzip consul_0.9.2_linux_amd64.zip
mv consul /usr/local/bin/
设置代理 在后台启动consul服务端
consul agent \ -server \ -bootstrap \ -ui \ -data-dir=/var/lib/consul-data \ -bind=192.168.10.23 \ -client=0.0.0.0 \ -node=consul-server01 &amp;&gt; /var/log/consul.log &amp; 参数解释
-server：以server身份启动。默认是client。
-bootstrap:用来控制一个server是否在bootstrap模式，在一个数据中心中只能有一个server处于bootstrap模式，当一个server处于 bootstrap模式时，可以自己选举为 server-leader。
-bootstrap-expect=2：集群要求的最少server数量，当低于这个数量，集群即失效。
-ui：指定开启 UI 界面，这样可以通过 http://localhost:8500/ui 这样的地址访问 consul 自带的 web UI 界面。
-data-dir ：指定数据存储目录。
-bind：指定用来在集群内部的通讯地址，集群内的所有节点到此地址都必须是可达的，默认是0.0.0.0。
-client：指定 consul 绑定在哪个 client 地址上，这个地址提供 HTTP、DNS、RPC 等服务，默认是 127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26e862a813dec3087089f0ebf500a610/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43a00e0bc80bf0ff37fde5180ae88369/" rel="bookmark">
			Spring 中 HttpServletRequest 作为成员变量是安全的吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用spring框架开发的时候，经常会在controller类中看到 HttpServletRequest 对象参数，一般我们都是直接使用，但是它是何时、怎么注入到 spring 容器的呢 ？另外以成员变量注入的 request 是线程安全的吗 ?
@Controller public class SomeController { @Resource private HttpServletRequest request1; @RequestMapping("/test") public String test2(HttpServletRequest request2) { System.out.println(request1.getQueryString()); System.out.println(request2.getQueryString()); return ""; } } 1、request 成员变量是否线程安全 ？ 先说结论：注入request这个成员变量是线程安全的，来看下 spring 是如何做到的，先 debug 看下两种做法真实注入类的区别
可以看出成员变量注入的是代理对象AutowireUtils.ObjectFactoryDelegatingInvocationHandler ，而作为方法参数注入的就是我们一般使用的Request对象，先看下 AutowireUtils 的内部类ObjectFactoryDelegatingInvocationHandler
/** * Reflective InvocationHandler for lazy access to the current target object. */ @SuppressWarnings("serial") private static class ObjectFactoryDelegatingInvocationHandler implements InvocationHandler, Serializable { private final ObjectFactory&lt;?&gt; objectFactory; public ObjectFactoryDelegatingInvocationHandler(ObjectFactory&lt;?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43a00e0bc80bf0ff37fde5180ae88369/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81e5f2deecd548b0668802d2de3a4dad/" rel="bookmark">
			水质净化厂物联网远程监控系统解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		水质净化厂物联网远程监控系统解决方案
随着科技的不断发展，物联网技术逐渐走进我们的生活。在水质净化厂中，物联网技术可以应用于远程监控系统，实现对水质净化过程的实时监测和数据分析，从而提高净化效率和管理水平。
一、需求分析
水质净化厂的远程监控系统需要具备以下功能：
1. 实时监测水质指标：包括水温、pH值、浊度、色度、电导率、总磷、总氮等。
2. 远程传输数据：蓝蜂物联网网关连接现场PLC、触摸屏等控制设备，通过无线网络将监测到的数据传输到EMCP物联网云平台，以便实时监测和数据分析。
3. 自动报警：当监测到水质异常时，平台自动报警，第一时间通过多种方式电话语音、短信、网页语音、通知相关人员进行处理。
4. 数据分析：通过对监测到的数据进行分析，提供实时的水质监测报告和趋势分析。
二、技术选型
为了实现上述需求，我们需要选择合适的物联网技术和硬件设备。
1. 物联网技术：选择具有低功耗、长待机时间、稳定性好的物联网技术，如蓝蜂物联网EG20，低功耗网关EG10-LP。
2. 传感器：选择具有高灵敏度、低功耗、长待机时间的传感器，如压力传感器、温度传感器、水位传感器等。
3. 云平台：选择具有高性能、稳定性好、安全性高的云平台，如EMCP物联网云平台。
三、方案设计
基于上述需求和技术选型，我们可以设计如下方案：
1. 系统架构
该方案采用分层架构，包括传感器层、控制器层、通信层和云平台层。其中，传感器层和控制器层通过无线网络连接到通信层，通信层将数据传输到云平台层。云平台层对数据进行分析和处理，并向用户提供数据服务。
2. 传感器层
传感器层包括水温传感器、pH值传感器、浊度传感器、色度传感器、电导率传感器、总磷传感器和总氮传感器。这些传感器通过低功耗无线网络连接到控制器层，控制器层对传感器数据进行处理和采集。
3. 控制器层
控制器层采用蓝蜂物联网网关，对传感器采集到的数据进行处理和计算。远程监控现场设备，远程控制设备启停通过无线网络连接到EMCP物联网云平台，实现对数据的实时传输。
4. 云平台层
云平台层采EMCP物联网云平台，实现对数据的分析和处理。云平台层对传输过来的数据进行处理和分析，并生成实时的水质监测报告和趋势分析。同时，云平台层也支持数据存储和查询、云组态远程监控、大屏展示数据中心、运维工单等功能。
四、总结
通过上述方案设计，我们可以实现对水质净化厂的实时监测和数据分析，提高净化效率和管理水平。同时，该方案还具有低功耗、长待机时间、稳定性好等优点，适用于各种环境和场景。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c0fd297bb60c079e4cf875076d25a09/" rel="bookmark">
			鸿蒙开发笔记(十):Stage模型开发中的UIAbility使用(类Activity)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		应用模型是HarmonyOS为开发者提供的应用程序所需能力的抽象提炼，它提供了应用程序必备的组件和运行机制。有了应用模型，开发者可以基于一套统一的模型进行应用开发，使应用开发更简单、高效。
1. 概述 HarmonyOS应用模型的构成要素包括：
应用组件
应用组件是应用的基本组成单位，是应用的运行入口。用户启动、使用和退出应用过程中，应用组件会在不同的状态间切换，这些状态称为应用组件的生命周期。应用组件提供生命周期的回调函数，开发者通过应用组件的生命周期回调感知应用的状态变化。应用开发者在编写应用时，首先需要编写的就是应用组件，同时还需编写应用组件的生命周期回调函数，并在应用配置文件中配置相关信息。这样，操作系统在运行期间通过配置文件创建应用组件的实例，并调度它的生命周期回调函数，从而执行开发者的代码。
应用进程模型
应用进程模型定义应用进程的创建和销毁方式，以及进程间的通信方式。
应用线程模型
应用线程模型定义应用进程内线程的创建和销毁方式、主线程和UI线程的创建方式、线程间的通信方式。
应用任务管理模型
应用任务管理模型定义任务（Mission）的创建和销毁方式，以及任务与组件间的关系。HarmonyOS应用任务管理由系统应用负责，三方应用无需关注，下文不做具体介绍。
应用配置文件
应用配置文件中包含应用配置信息、应用组件信息、权限信息、开发者自定义信息等，这些信息在编译构建、分发和运行阶段分别提供给编译工具、应用市场和操作系统使用。
随着系统的演进发展，HarmonyOS先后提供了两种应用模型：
FA（Feature Ability）模型：HarmonyOS早期版本开始支持的模型，已经不再主推。
Stage模型：HarmonyOS 3.1 Developer Preview版本开始新增的模型，是目前主推且会长期演进的模型。在该模型中，由于提供了AbilityStage、WindowStage等类作为应用组件和Window窗口的“舞台”，因此称这种应用模型为Stage模型。
Stage模型之所以成为主推模型，源于其设计思想。Stage模型的设计基于如下出发点。
为复杂应用而设计
多个应用组件共享同一个ArkTS引擎（运行ArkTS语言的虚拟机）实例，应用组件之间可以方便的共享对象和状态，同时减少复杂应用运行对内存的占用。采用面向对象的开发方式，使得复杂应用代码可读性高、易维护性好、可扩展性强。 支持多设备和多窗口形态
应用组件管理和窗口管理在架构层面解耦：
便于系统对应用组件进行裁剪（无屏设备可裁剪窗口）。
便于系统扩展窗口形态。
在多设备（如桌面设备和移动设备）上，应用组件可使用同一套生命周期。
平衡应用能力和系统管控成本
Stage模型重新定义应用能力的边界，平衡应用能力和系统管控成本。
提供特定场景（如卡片、输入法）的应用组件，以便满足更多的使用场景。规范化后台进程管理：为保障用户体验，Stage模型对后台应用进程进行了有序治理，应用程序不能随意驻留在后台，同时应用后台行为受到严格管理，防止恶意应用行为。 Stage模型与FA模型最大的区别在于：Stage模型中，多个应用组件共享同一个ArkTS引擎实例；而FA模型中，每个应用组件独享一个ArkTS引擎实例。因此在Stage模型中，应用组件之间可以方便的共享对象和状态，同时减少复杂应用运行对内存的占用。Stage模型作为主推的应用模型，开发者通过它能够更加便利地开发出分布式场景下的复杂应用。
2. Stage模型开发概述 Stage模型概念图
UIAbility组件和ExtensionAbility组件
Stage模型提供UIAbility和ExtensionAbility两种类型的组件，这两种组件都有具体的类承载，支持面向对象的开发方式。
UIAbility组件是一种包含UI界面的应用组件，主要用于和用户交互。例如，图库类应用可以在UIAbility组件中展示图片瀑布流，在用户选择某个图片后，在新的页面中展示图片的详细内容。同时用户可以通过返回键返回到瀑布流页面。UIAbility的生命周期只包含创建/销毁/前台/后台等状态，与显示相关的状态通过WindowStage的事件暴露给开发者。
ExtensionAbility组件是一种面向特定场景的应用组件。
WindowStage
每个UIAbility类实例都会与一个WindowStage类实例绑定，该类提供了应用进程内窗口管理器的作用。它包含一个主窗口。也就是说UIAbility通过WindowStage持有了一个窗口，该窗口为ArkUI提供了绘制区域。
Context
在Stage模型上，Context及其派生类向开发者提供在运行期可以调用的各种能力。UIAbility组件和各种ExtensionAbility派生类都有各自不同的Context类，他们都继承自基类Context，但是各自又根据所属组件，提供不同的能力。
AbilityStage
每个Entry类型或者Feature类型的HAP在运行期都有一个AbilityStage类实例，当HAP中的代码首次被加载到进程中的时候，系统会先创建AbilityStage实例。每个在该HAP中定义的UIAbility类，在实例化后都会与该实例产生关联。开发者可以使用AbilityStage获取该HAP中UIAbility实例的运行时信息。
基于Stage模型开发应用时，在应用模型部分，涉及如下开发过程。
3. 应用/组件级配置 在开发应用时，需要配置应用的一些标签，例如应用的包名、图标等标识特征的属性。图标和标签通常一起配置，可以分为应用图标、应用标签和入口图标、入口标签，分别对应app.json5配置文件和module.json5配置文件文件中的icon和label标签。应用图标和标签是在设置应用中使用，例如设置应用中的应用列表。入口图标是应用安装完成后在设备桌面上显示出来的，入口图标是以UIAbility为粒度，支持同一个应用存在多个入口图标和标签，点击后进入对应的UIAbility界面。
AppScope目录下的app.json5配置文件
应用包名配置
应用需要在工程的AppScope目录下的app.json5配置文件中配置bundleName标签，该标签用于标识应用的唯一性。推荐采用反域名形式命名（如com.example.demo，建议第一级为域名后缀com，第二级为厂商/个人名，第三级为应用名，也可以多级）。
应用图标和标签配置
应用图标需要在工程的AppScope目录下的app.json5配置文件中配置icon标签。应用图标需配置为图片的资源索引，配置完成后，该图片即为应用的图标。
应用标签需要在工程的AppScope模块下的app.json5配置文件中配置label标签。标识应用对用户显示的名称，需要配置为字符串资源的索引。
入口图标和标签配置
入口图标需要在module.json5配置文件中配置，在abilities标签下面有icon标签。例如希望在桌面上显示该UIAbility的图标，则需要在skills标签下面的entities中添加"entity.system.home"、actions中添加"action.system.home"。同一个应用有多个UIAbility配置上述字段时，桌面上会显示出多个图标，分别对应各自的UIAbility。
应用版本声明配置
应用版本声明需要在工程的AppScope目录下的app.json5配置文件中配置versionCode标签和versionName标签。versionCode用于标识应用的版本号，该标签值为32位非负整数。此数字仅用于确定某个版本是否比另一个版本更新，数值越大表示版本越高。versionName标签标识版本号的文字描述。
Module支持的设备类型配置
Module支持的设备类型需要在module.json5配置文件中配置deviceTypes标签，如果deviceTypes标签中添加了某种设备，则表明当前的Module支持在该设备上运行。
Module权限配置
Module访问系统或其他应用受保护部分所需的权限信息需要在module.json5配置文件中配置requestPermission标签。该标签用于声明需要申请权限的名称、申请权限的原因以及权限使用的场景。
4. UIAbility组件 – Activity 4.1 概述 UIAbility组件是一种包含UI界面的应用组件，主要用于和用户交互。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c0fd297bb60c079e4cf875076d25a09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aaa5118e81ff1cfea68f3cf0acbd3a06/" rel="bookmark">
			AI绘画软件Fooocus介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你是否想过用AI来创作你的画作？你是否厌倦了传统的绘画工具和方法？你是否想要尝试一种全新的、智能的、有趣的绘画方式？如果你的答案是肯定的，那么你一定要了解一下AI绘画软件Fooocus。
Fooocus是一款基于深度学习的绘画软件，它可以根据你的输入和偏好，自动生成高质量的画作。你可以选择不同的风格、主题、颜色和细节，让Fooocus为你创造出独一无二的艺术品。你也可以随时修改和调整Fooocus生成的画作，让它更符合你的想法和审美。
Fooocus不仅适合专业的艺术家和设计师，也适合任何对绘画感兴趣的人。无论你是初学者还是高手，Fooocus都可以帮助你提升你的绘画技巧和创造力。Fooocus还可以让你与其他用户分享和交流你的作品，让你获得更多的灵感和反馈。
Fooocus是一款免费的软件，你可以在官网上下载和安装。Fooocus支持Windows、Mac和Linux系统，也支持平板电脑和触摸屏设备。Fooocus只需要很少的系统资源，运行速度非常快。
如果你想要体验一下AI绘画的魅力，那就赶快下载Fooocus吧！Fooocus将会给你带来无限的惊喜和乐趣！
项目地址：https://github.com/lllyasviel/Fooocus
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74d33040fcdecdf0dea8b0073fe08d9b/" rel="bookmark">
			无界面自动化测试（IDEA&#43;Java&#43;Selenium&#43;testng）(PhantomJS)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自动化测试（IDEA+Java+Selenium+testng）(PhantomJS)_phantomjs怎么写js脚本idea-CSDN博客
上述连接是参考：现在如果按照如上链接进行操作大概率会失败，下面会针对如上链接的部分步骤做出修改
1、在pom.xml文件中需要使用低版本selenium-java依赖包，目前我使用的是4.13.0版本的所以在运行时铁定失败，目前除了降低selenium-java依赖包版本没有找到其它版本解决；可以使用2.53.1版本的依赖包；
2、上述连接是说在maven仓库中下载相关依赖，按照该步骤我这边无法成功下载依赖包，我这边是将依赖的下载源改为阿里云的（具体步骤可以百度或者看我之前博客），然后在pom.xml文件中配置如下代码下载依赖：
&lt;dependency&gt; &lt;groupId&gt;com.codeborne&lt;/groupId&gt; &lt;artifactId&gt;phantomjsdriver&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; 3、经过这两处修改即可完成web无界面运行自动化脚本了。不知道是否有大神知道高版本selenium-java无界面运行自动化脚本的办法，如果有的话还望赐教。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11362b376804c8868cc73d5b34faeb3e/" rel="bookmark">
			使用freessl为网站获取https证书及配置详细步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、进入freessl网站二、修改域名解析记录三、创建证书四、配置证书五、服务启动 一、进入freessl网站 首先进入freessl网站，需要注册一个账号
freessl网站
进入网站后填写自己的域名
接下来要求进行DCV配置
二、修改域名解析记录 到域名管理处编辑域名解析，我用的是阿里云，这里进入阿里云域名管理中添加解析设置。这里填写的值就是刚才freessl给的。
操作成功后：
三、创建证书 回到freessl网站，点击刚才的立即检测按钮，成功通过：
这里我用的是acme.sh，复制这一串代码，到服务器终端里运行，运行结果如下：
四、配置证书 进入nginx配置文件，配置443端口
证书地址在刚才的运行结果当中可以看到
五、服务启动 重启nginx，即可完成配置
sudo systemctl restart nginx 现在即可访问https://www.你的域名 了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4172d134eb5d725eed328a609583864/" rel="bookmark">
			软考系分之计算机网络通信方向、同步和交换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、概述2、通信方向和同步3、交换方式4、总结 1、概述 本篇依旧是一图概括主要考察的知识点，包括通信方向（单工、半双工、全双工），同步方式和数据交换等。
2、通信方向和同步 通信方向（单工、半双工、全双工）相对简单，常在选择题中出现，了解其概念。同步方式包括了异步、同步、并行和串行，了解概念即可。
3、交换方式 计算机网络通信中，交换方式有三种：电路交换、分组交换和报文交换。电路交换常用语语音和视频的传输；报文交换是存储转发的模式；分组交换也是存储转发，但数据分组后比报文更小，细分为三种交换方式（数据报、虚电路和信元交换）。
数据报，在分组信息中会携带地址信息，通过路由进行交换；信元交换，信元是固定了长度的分组信息，通过异步传输（ATM）进行交换；虚电路，分组信息通过虚拟通信线路进行传输。
4、总结 以上，一图汇总和概括了关于计算机网络的单工、双工、半双工、同步和交换等，可能会考试的知识点，需要了解和记忆。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07afbe03625ac5b7e64dd8daf75e8629/" rel="bookmark">
			第十一周：机器学习周报
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
摘要
Abstract
What is GNN？
Why need GNN？
Spatial-based GNN
模型一：NN4G（Neural Network for Graph）
模型二：DCNN（Diffusion-Convolution Neural Network）
模型三：DGC（Diffusion Graph Convolution）
模型四：MoNET（Mixture Model Networks）
模型五：GAT（Graph Attention Networks）
Spectral-based GNN
图信号的傅里叶变换
GNN模型例子分析
摘要 GNN可以将graph的结构和图中每个节点和边的特征转化为一般的神经网络的输入，而GNN中的卷积有两种方法，一种是Spatial-based（基于空间的），另一种是Spectral-based（基于谱域的）Spatial-based GNN方法采用类似CNN的卷积得到每个隐藏层的值，再将所有层的值集合成为整个graph的输出，Spectral-based GNN方法借助了信号与系统中的傅里叶变换，定义了一套Spectral Graph Theory，使用特征值等价频率，再构造傅里叶变换与逆傅里叶变换得到图神经网络的卷积输出。
Abstract What is GNN？ 简单来说GNN就是Graph + Nerual Networks，而这里的Graph的粗略定义就是有节点有边的图形，并不是图片而是数据结构中的图，而是一种结构化的数据。关键问题就是将graph的结构和图中每个节点和边的特征转化为一般的神经网络的输入（张量）。
GNN考虑所有的特征并将其转化为神经网络可以输入的向量，就需要用到类似于CNN的Convolution（卷积），而GNN中的卷积有两种方法，一种是Spatial-based（基于空间的），另一种是Spectral-based（基于谱域的）。
Why need GNN？ 当我们在做classfication的时候数据以图的形式出现，而这张图非常大，拥有很多的节点，并且节点之间互相影响，那数据集就会非常大，我们需要考虑节点之间的各种联系，因此需要用到GNN。
例如在一个故事中存在很多个角色，每个角色都有对应的特征，例如姓名职业等，要从这些角色中找到一个杀人凶手，寻找的这个过程可以看成是一个classfication的问题，训练一个分类器，将一个角色（即该角色的各个特征）放入训练出来的classifier，判断该角色是否是杀人凶手。
但是问题是角色之间存在一张庞大的关系网，两两角色之间都存在一定的关系，而这些关系在做classfication的时候可以得到额外的信息，帮助我们做更好的model。因此需要考虑全部的关系，这就必须要用到graph neural network。
Spatial-based GNN Spatial-based GNN需要做空间域的卷积，也就是在空间上的卷积，需要做两步，第一步是aggregate，aggregate类似于CNN中的convolution也就是卷积，CNN 中的卷积核在计算某一个像素点的 feature 的时候，可以看成把这个像素点周围的像素点的特征按照一定的权重加权求和，Spatial-GNN 想要把这种卷积操作直接推广到 Graph 上，即用邻节点的特征更新下一隐藏层的状态，第二步是readout，把所有节点的特征集合起来代表整个graph。
GNN的卷积和readout有很多种方法
模型一：NN4G（Neural Network for Graph） NN4G是在上一层的数据基础上更新下一层隐藏层的特征，我们可以认为它的计算方法 COMBINE 的就是上层自己的特征经过一个线性变换。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07afbe03625ac5b7e64dd8daf75e8629/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd4b4db9630fe7b4b7d77575e4dc099c/" rel="bookmark">
			C语言经典练习3——[NOIP2008]ISBN号码与圣诞树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在学习C语言的过程中刷题是很重要的，俗话说眼看千遍不如手动一遍因为在真正动手去刷题的时候会暴露出更多你没有意识到的问题接下来我就为各位奉上两道我认为比较有代表性的题 1. [NOIP2008]ISBN号码 1.1 题目描述 每一本正式出版的图书都有一个ISBN号码与之对应，ISBN码包括9位数字、1位识别码和3位分隔符，其规定格式如“x-xxx-xxxxx-x”，其中符号“-”是分隔符（键盘上的减号），最后一位是识别码，例如0-670-82162-4就是一个标准的ISBN码。ISBN码的首位数字表示书籍的出版语言，例如0代表英语；第一个分隔符“-”之后的三位数字代表出版社，例如670代表维京出版社；第二个分隔之后的五位数字代表该书在出版社的编号；最后一位为识别码。识别码的计算方法如下：
首位数字乘以1加上次位数字乘以2……以此类推，用所得的结果mod 11，所得的余数即为识别码，如果余数为10，则识别码为大写字母X。例如ISBN号码0-670-82162-4中的识别码4是这样得到的：对067082162这9个数字，从左至右，分别乘以1，2，…，9，再求和，即0×1+6×2+……+2×9=158，然后取158 mod 11的结果4作为识别码。你的任务是编写程序判断输入的ISBN号码中识别码是否正确，如果正确，则仅输出“Right”；如果错误，则输出你认为是正确的ISBN号码。 1.2 输入描述 只有一行，是一个字符序列，表示一本书的ISBN号码（保证输入符合ISBN号码的格式要求）。 1.3 输出描述 共一行，假如输入的ISBN号码的识别码正确，那么输出“Right”，否则，按照规定的格式，输出正确的ISBN号码（包括分隔符“-”）。 1.4 示例 1.5 分析 这里我们可以定义一个数组来存储输入的号码，并且可以在这个过程中先计算出和，然后再利用分支结构分别判断 mod 为 11 和不是 11 的情况 1.6 完整代码 #include &lt;stdio.h&gt; int main() { char arr1[15] = { 0 }; int sum = 0; int k = 1;//每一位对应的权值 scanf("%s", arr1); for (int i=0; i&lt;11; i++) { if(arr1[i] != '-') { sum += (arr1[i]-'0') * k; k++; } }//初始化数组并求和 if (sum % 11 &lt; 10) { if (sum % 11 == (arr1[12]-'0')) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd4b4db9630fe7b4b7d77575e4dc099c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef7c0e82fb79aa9b5a83015c363b8331/" rel="bookmark">
			大语言模型系列-word2vec
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、word2vec的网络结构和流程1.Skip-Gram模型2.CBOW模型 二、word2vec的训练机制1. Hierarchical softmax2. Negative Sampling 总结 前言 在前文大语言模型系列-总述已经提到传统NLP的一般流程：
创建语料库 =&gt; 数据预处理 =&gt; 分词向量化 =&gt; 特征选择 =&gt; 建模（RNN、LSTM等） 传统的分词向量化的手段是进行简单编码（如one-hot），存在如下缺点：
如果词库过大， one-hot编码生成的向量会造成维度灾难one-hot编码生成的向量是稀疏的，它们之间的距离相等，无法捕捉单词之间的语义关系。one-hot编码是固定的，无法在训练过程中进行调整。 因此，出现了词嵌入（word embedding）的概念，通过word embedding模型生成的向量是密集的，具有相似含义的单词在向量空间中距离较近，可以捕捉单词之间的语义关系。并且Word Embedding模型的权重可以在训练过程中进行调整，以便更好地捕捉词汇之间的语义关系。
word2vec就是一种经典的词嵌入（word embedding）模型，由Tomas Mikolov等人在2013年提出，它通过学习将单词映射到连续向量空间中的表示，以捕捉单词之间的语义关系。
提示：以下是本篇文章正文内容，下面内容可供参考
一、word2vec的网络结构和流程 Word2Vec是轻量级的神经网络，其模型仅仅包括输入层、隐藏层和输出层，根据学习思路的不同，分为两种训练方式：Skip-Gram和CBOW（Continuous Bag of Words）。其中，Skip-gram是已知当前词的情况下预测上下文的表示，CBOW则是在已知上下文的情况下预测当前词的表示。通过这种表示学习，学得映射矩阵，将原始离散数据空间映射到新的连续向量空间（实际上起到了降维的作用）。
将单词使用one-hot编码输入网络进行训练，获得参数矩阵 W V × N W_{V×N} WV×N​输入层的每个单词one-hot编码x（V-dim）与矩阵W相乘，即 x ⋅ W V × N x \cdot W_{V×N} x⋅WV×N​，得到其word embedding（N-dim） 1.Skip-Gram模型 2.CBOW模型 二、word2vec的训练机制 假设语料库中有V个不同的单词，hidden layer取128，则word2vec两个权值矩阵维度都是[V,128]，我们使用的语料库往往十分庞大，这也会导致权值矩阵的庞大，即神经网络的参数规模的庞大，在使用SGD对庞大的神经网络进行学习时，将是十分缓慢的。
word2vec提出两种加快训练速度的方式，一种是Hierarchical softmax，另一种是Negative Sampling。
1. Hierarchical softmax 和传统的神经网络输出不同的是，word2vec的hierarchical softmax结构是把输出层改成了一颗哈夫曼树，其中图中白色的叶子节点表示词汇表中所有的V个词，黑色节点表示非叶子节点，每一个叶子节点也就是每一个单词,都对应唯一的一条从root节点出发的路径。我们的目的是使的 w = w 0 w=w_0 w=w0​这条路径的概率最大，即: P ( w = w 0 ∣ w I ) P(w=w_0|w_I) P(w=w0​∣wI​)最大，假设最后输出的条件概率是 P ( w = w 0 ∣ w 2 ) P(w=w_0|w_2) P(w=w0​∣w2​)最大，那么只需要去更新从根结点到 w 2 w_2 w2​这一个叶子结点的路径上面节点的向量即可，而不需要更新所有的词的出现概率，这样大大的缩小了模型训练更新的时间。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef7c0e82fb79aa9b5a83015c363b8331/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a04442755d1b87a021f5ee75aa9d037/" rel="bookmark">
			一篇综述洞悉医学大型语言模型的原理，应用和挑战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在过去的一年中，随着 GPT-4、LLaMA、Mistral，PaLM 等先进技术的突飞猛进，大型语言模型（Large Language Models）已经引领全球人工智能进入了一个全新的基础模型时代，这一时代不仅开启了技术创新的新篇章，也彻底重塑了各行各业的运作模式。特别是在医疗领域，这些变革显得尤为突出。医疗领域不仅是全球各国竞相投资的重点研究领域，而且与一个国家的医疗水平和综合国力密切相关。在这样的背景下，大型语言模型在医疗领域究竟能带来怎样的变革和影响？
近日，牛津大学的David A. Clifton，罗切斯特大学的罗杰波（Jiebo Luo）和亚马逊的Zheng Li领导的一个联合团队发布了一篇综述报告，介绍了医学大型语言模型在原理、应用和面临的挑战方面的最新进展（截止至2024年），通过深入探讨相关技术发展，提供宝贵的见解，为构建更加实用和高效的医学大型模型奠定坚实的基础。
论文题目： A Survey of Large Language Models in Medicine: Principles, Applications, and Challenges 论文地址： https://arxiv.org/abs/2311.05112 项目地址： https://github.com/AI-in-Health/MedLLMsPracticalGuide 近期，通用大型语言模型（LLMs）如PaLM、LLaMA、GPT系列和ChatGLM在多种自然语言处理（NLP）任务中展现出前所未有的进展。这些任务包括文本生成、文本摘要和问题回答等。受到这些模型在自然语言处理领域的成功启发，研究者们开始尝试将通用LLM调整应用于医学领域，从而催生了一系列医学专用的大型模型。例如，基于PaLM开发的MedPaLM和MedPaLM-2在美国医学许可考试（USMLE）上的表现，几乎与人类专家（87.0）持平，达到了86.5的竞争性准确率。此外，基于公开可用的LLM (例如LLaMA）衍生出的几个医学LLM包括ChatDoctor、MedAlpaca、PMC LLaMA、BenTsao和Clinical Camel等，正引发越来越多的关注，它们在协助医疗专业人员改善患者护理方面展现出巨大潜力。
尽管这些医学LLMs取得了令人鼓舞的成果，但在其开发和应用过程中，仍面临一些挑战。首先，许多模型主要关注生物医学NLP任务，如对话和问题回答，但其在临床实践中的实际应用价值往往被忽视。近期的研究开始探讨医学LLM在不同临床场景中的应用潜力，例如，电子健康记录（EHRs）的出院结论生成、健康教育和护理计划等。然而，这些研究多为案例研究，并依赖于临床医生对少量样本的人工评估，因此缺乏全面的评估数据集来衡量模型在实际临床场景中的表现。其次，大多数现有医学LLM的研究主要聚焦于医学问题回答的生物医学NLP性能，而忽略了文本摘要、关系提取、信息检索和文本生成等其他生物医学任务。这些研究空白激发了我们进行这项调查，旨在全面回顾LLM的发展及其在医学领域的应用，并探讨面临的挑战和机遇。
如图1所示，本综述旨在回答以下问题：
LLMs是什么？如何有效地构建医学LLMs？（第一章节）当前医学LLM的评估方式是什么？它们相较于传统模型有何独特之处？（第二章节）医学LLMs在临床环境中应如何应用？（第三章节）在临床实践中实施医学LLMs时, 需要解决哪些挑战？（第四章节）如何优化医学LLMs的构建，以增强其在临床环境中的适用性，最终为医学界带来积极的社会影响？（第五章节） 对于第一个问题，我们总结了现有医学LLMs的关键原则，详细介绍了它们的基本结构、参数数量以及用于模型开发的数据集。此外，我们还提供了这些模型构建过程中的关键见解，这对于希望根据特定需求（如计算限制、私有数据和本地知识库）定制医学LLM的研究人员和医疗从业者极具价值。
对于第二个问题，我们通过广泛的调查，对现有医学LLMs在十种生物医学NLP任务（包括判别和生成）上的性能进行了评估。这种全面的分析帮助我们理解医学LLMs在多个方面是如何超越传统医学人工智能模型的。通过展示它们的能力，我们旨在阐明医学LLMs在临床环境中部署时所带来的优势。
第三个问题着重于医学LLMs在临床环境中的实际应用。我们为七个临床应用场景提供了指南，详细说明了医学LLM的具体实施方式，并强调了在每个场景中能够发挥的能力。
第四个问题强调了在临床实践中部署医学LLM时必须克服的挑战。这些挑战包括生成幻觉（即产生连贯但事实不正确的输出）、模型的可解释性问题、伦理考量，以及医学LLM的法律和安全问题。我们还提倡对医学LLM进行更广泛的评估，比如信任度，以确保其在临床环境中的负责任和有效使用。
最后一个问题，我们展望了医学LLM的未来发展方向，并为那些希望推动该领域发展、最大化医学LLMs潜力的研究人员和从业者提供了指导。
通过回答这些问题并提供对医学LLM的全面视角，我们希望能促进对医学人工智能领域的更深入理解，更广泛的合作以及更快的进展。总结而言，本综述做出了以下贡献：
我们对医学领域中的大型语言模型进行了全面回顾，并总结了它们在十个生物医学下游任务中的表现。我们强调了医学LLMs的临床应用，并为其在各种临床环境中的部署提供了实用指南。我们识别并讨论了在临床实践中应用医学LLM时面临的挑战，旨在激励该领域的进一步研究和发展。 图 1: 医学大语言模型综述的整体结构 一、医学大型语言模型的原理 为了清晰起见，本节重点总结医学大语言模型的原理。现有的医学LLM主要是包括三种类型（1）从头开始进行预训练，（2）从现有的通用LLM中进行微调，或者（3）通过提示将普通LLM与医学领域对齐直接获得。因此，我们从预训练、微调和提示三种方法介绍了医学LLM的原理。
预训练 预训练是医学大型语言模型开发中的一个关键过程，它涉及在庞大的医学文本库上训练模型，以吸收和学习丰富的医学知识。这些文本通常包括结构化和非结构化的数据，如电子健康记录（EHR）、临床笔记、DNA序列和医学文献等。特别值得一提的是，PubMed、MIMIC-III临床笔记和PubMed Central（PMC）文献是医学LLM预训练中常用的三个主要医学语料库。模型可以选择在单一语料库或多个语料库的组合上进行预训练。例如，PubMedBERT和ClinicalBERT分别在PubMed和MIMIC-III上进行预训练。而BlueBERT结合了这两个语料库，BioBERT则同时在PubMed和PMC上进行预训练。此外，佛罗里达大学健康EHR也被用于GatorTron和GatorTronPT的预训练中。而MEDITRON则是在临床实践指南（CPG）上接受预培训，CPG主要用于指导医疗从业者和患者进行循证决策。
在预训练医学LLM时，通常会对通用LLM中常用的训练目标进行细化，包括掩蔽语言建模、下一句预测和下一个标记预测。例如，BERT系列模型如BioBERT、PubMedBERT、ClinicalBERT和GatorTron，主要采用掩蔽语言建模和下一句预测进行预训练。而GPT系列模型，如BioGPT和GatorTronGPT，则主要采用下一个令牌预测进行预训练。
预训练完成后，医学LLM通常会进行微调，然后在不同的生物医学人工智能任务中进行评估，以检验其理解和生成相关文本的能力。一旦经过预训练，LLM将掌握丰富的通用语言表示，这些表示可用于各种下游任务。为了在这些任务上获得强大的性能，LLM可以在一个小型、特定于任务的数据集上进行微调，即进一步训练。这使得模型能够使其通用语言表示适应目标任务的特定要求。大规模预训练与微调结合，已被证明能有效实现最先进的性能。
微调 从头开始训练医学LLMs是高成本和耗时的，因为它需要大量（例如几天甚至几周）的计算能力和体力。一种解决方案是用医学数据对通用语言大模型进行微调，研究人员提出了不同的微调方法，用于学习特定领域的医学知识并获得医学LLM。当前的微调方法包括监督微调（SFT）、指令微调（IFT）和参数有效调整。
监督微调（SFT）： 旨在利用高质量的医学语料库，可以是医患对话、医学问答和知识图谱。所构建的SFT数据用作预训练数据的延续，以进一步预训练具有相同训练目标的一般LLM，例如下一个令牌预测。SFT提供了一个额外的预培训阶段，使普通LLM能够学习丰富的医学知识并与医学领域保持一致，从而将其转变为专业的医学LLM。指令微调（IFT）： 首先构建基于指令的训练数据集，这些数据集通常由指令输入输出三元组组成，例如指令问答。IFT的主要目标是增强模型遵循各种人工/任务指令的能力，使其输出与医学领域保持一致，从而生成专门的医学LLM。参数高效调整： 旨在大幅降低微调通用LLM的计算和内存需求。主要思想是通过仅微调这些LLM中的最小参数子集（或附加参数），保持预训练LLM中大多数参数不变。常用的参数有效微调技术包括低秩自适应（LoRA）、前缀微调和适配器微调。 提示工程 与预训练相比，微调大大降低了计算成本，但它需要进一步的模型训练和高质量数据集的收集来进行微调，因此仍需要消耗一些计算资源和人工。相反，“提示”方法有效地将一般LLM（如PaLM）与医学领域（如MedPaLM）对齐，而无需训练任何模型参数。流行的提示方法包括零/少样本提示、思想链提示、自一致性提示和提示调整。
零/少样本提示旨在直接给出指令，提示LLM按照给定指令有效执行任务。零样本提示没有提供示例。在要求LLM执行任务之前，很少有样本提示会向LLM提供少量示例或任务演示。思想链提示进一步提高了模型输出的准确性和逻辑性。具体来说，通过提示词，思维链提示旨在提示模型在处理下游（复杂）问题时生成推理的中间步骤或路径。自一致性提示建立在思维链提示之上，以进一步增强回复的稳健性。它鼓励模型多次尝试生成同一问题的多个答案，然后在不同的尝试中选择最一致的答案，从而提高模型性。提示调整旨在通过采用提示和微调技术来提高下游模型的性能。提示调整方法引入了可学习的提示，即。可训练的连续向量，可以在微调过程中进行优化或调整，以更好地适应不同的下游场景和任务。 图 2: 医学大语言模型的进化树 为了进一步展现医学大型语言模型的发展现状，我们制作了医学大模型在不同分支上的进化树（图 2）。此外，我们还尝试通过MedQA (USMLE-style) 数据集性能图（图 3）洞察医学大语言模型的能力发展，来分析现有的医学LLMs是否已经超过人类专家判断水平。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a04442755d1b87a021f5ee75aa9d037/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6fde8e61fe09b6fd35da69a102ce139/" rel="bookmark">
			创意无限！亲测可用的免费Photoshop素材网站大揭秘！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		高质量的PS材料可以保证设计师设计作品的质量，但很多人不知道在哪里找到一些免费的材料，尤其是对初学者来说。那么，有没有质量好、免费的PS材料网站呢？别担心，现在就告诉你。
即时设计 被很多人视为免费的PS素材网站——即时设计提供了「资源广场」版块，方便用户查找材料。对于提供的PS材料，即时设计也做了详细的分类工作，用户可以根据不同的使用标签快速找到相应的PS材料。
进入资源广场，在搜索框中输入要查找的材料标签，然后点击「搜索」你可以完成搜索工作。关于平面设计，资源广场提供图标材料、插图材料等。关于海报制作，资源广场不仅提供了丰富的海报设计材料，还提供了可以一键使用的设计模板。PS材料的使用也很简单。由于即时设计是支持在线设计的设计工具，因此在使用设计材料时不提供下载操作，点击「使用」按钮可以直接设计在画布上。
即时设计 - 可实时协作的专业 UI 设计工具即时设计是一款支持在线协作的专业级 UI 设计工具，支持 Sketch、Figma、XD 格式导入，海量优质设计资源即拿即用。支持创建交互原型、获取设计标注，为产设研团队提供一站式协同办公体验。https://ad.js.design/special/ui/?source=csdn&amp;plan=bttcsdn01172
Fribbble Fribbble是一个免费高速下载dribblerPSD资源的网站，看起来和Dribble很像。该网站收集了来自Dribble的免费资料，并提供给设计师下载使用，包括网站适用图、建立登录页面的PSD档、各种视觉稿等资源。设计师可以通过RSS在网站上订阅更新内容，方便随时下载最新资源。
花瓣网 花瓣网，经常找材料的小伙伴一定很熟悉这个网站。这是一个很多设计师都在使用的材料网站。这里的材料分类非常丰富。具体材料分类包括插画/漫画、婚礼、女装/搭配、工业设计等；除了材料，它还有一个非常实用的收集工具
stickpng Stickpng，这是一个提供PNG透明背景图资源的免费网站。这个网站上的PNG背景图已经去除了背景，不需要重新挖掘背景，下载后可以直接使用，非常方便。它的图片分类非常丰富，包括食物、家具、音乐明星、厨房用具、假期、游戏、动物、漫画人物、机器人等。
pixelsquid Pixelsquid，这是一个可以免费下载3D材料地图的网站。在这个网站上，你可以下载非常逼真和三维的3D材料。你可以从360度的全视角浏览。很酷。这个网站上的材料很有趣。感兴趣的朋友不妨看看~
colorhub colorhub也是一个免费的高清无版权图片库。目前已收录高清无版权图片110208张，每天不断更新。站内所有图片均无版权，可放心使用。
网站的使用非常方便，我们可以直接输入中文关键词进行搜索，也可以根据颜色进行搜索，使用起来特别方便。
iconmonstr iconmonstr是一个免费的图标材料库，主要是简单的线条和黑白。目前已包含4512多个图标。站内所有图标均可免费下载，无版权，可用于个人和商业用途，无版权风险。
下载网站图标素材时，将提供SVG等图标素材、EPS、PSD、可以下载PNG等四种文件类型，使用起来非常方便。
Brusheezy Brushezy是一个免费分享PS笔刷材料的网站。站内收录了2000多种优秀的PS笔刷材料，全部可免费下载。
我们可以根据自己的PS版本来筛选刷子，也可以根据流行程度、评分和发布日期来筛选站内刷子材料，使用起来非常方便。
即时设计 - 可实时协作的专业 UI 设计工具即时设计是一款支持在线协作的专业级 UI 设计工具，支持 Sketch、Figma、XD 格式导入，海量优质设计资源即拿即用。支持创建交互原型、获取设计标注，为产设研团队提供一站式协同办公体验。https://ad.js.design/special/ui/?source=csdn&amp;plan=bttcsdn01172
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/16/">«</a>
	<span class="pagination__item pagination__item--current">17/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/18/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>