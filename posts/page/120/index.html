<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c01b07f009147d421b5803125331f1d/" rel="bookmark">
			Qgis加载arcgis的gdb格式数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方式1：文件浏览器打开可直接看到图层，拖到可视区域即可。
方式2：gdb文件夹拖到可视区域即可。
方式3：图层-矢量-目录
该gdb可能没有坐标信息，需要跟甲方询问或者自己尝试
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cf84f6e7266154622508808ef2765f6/" rel="bookmark">
			Flutter-权限管理 permission_handler
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		权限管理
dependencies: permission_handler: # 权限管理 ///调用原生的收车检测和交车检测功能 addUsedCarOrder(int index) async { ///Android 需要额外判断权限 if (Platform.isAndroid) { if (await _requestPermission()) { GlobalConfig.getInstance().addUsedCarOrder(index); } } else if (Platform.isIOS) { GlobalConfig.getInstance().addUsedCarOrder(index); } } ///请求权限 Future&lt;bool&gt; _requestPermission() async { var status = await Permission.camera.status; var status1 = await Permission.storage.status; if (status1 != PermissionStatus.granted || status != PermissionStatus.granted) { var future = await [Permission.camera, Permission.storage].request(); for (final item in future.entries) { ///拒绝并不再询问 if (item.value.isPermanentlyDenied) { ///BrnToast.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cf84f6e7266154622508808ef2765f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63085f5a282250ba5443ffac271dd84f/" rel="bookmark">
			【k8s】配置文件上传命名空间不存在
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在执行命令 kubectl apply -f .XXX.yaml时出现错误情况
错误信息：（这就是说明命名空间未找到）
Error from server (NotFound): error when creating ".\\XXX-prod.yaml": namespaces "XXX-prod" not found
执行命令查看命名空间：
kubectl get namespaces 果然不存在prod命名空间，但是出现一个新的问题，那就是我之前用的时simpord命名空间，这里也没有显示，可是我一直在使用，这是什么情况？
后来想起来，用的阿里云的kube配置文件在D盘的kube文件夹下，而这里的kubectl命令还是找的C:\Users\Administrator\.kube配置文件
于是设置使用配置文件参数
kubectl get namespaces --kubeconfig D:\kube\config
查看发现正常存在了，于是使用：
kubectl apply --kubeconfig D:\kube\config -f .XXX.yaml
执行成功。
查看k8s发现k8s拉取镜像出现问题
这个是因为docker镜像是私有存储，我们在使用时需要登录才能拉取和提交，所以k8s需要配置权限，如下图：
点击添加配置即可正常拉取
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9af6b13cbd68a2bcb683643ab6bdef6e/" rel="bookmark">
			vue2&#43;element UI，根据组织选择人员弹窗的封装！（组织为树结构）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		弹窗截图 弹窗功能代码： &lt;template&gt; &lt;el-dialog :title="title" :visible.sync="dialogCopyVisible" :before-close="handelcloseDialog" :close-on-click-modal="false" width="60%" :modal-append-to-body="false" top="60px" append-to-body &gt; &lt;div class="fx-dialog" :close-on-click-modal="false"&gt; &lt;div class="flex-item"&gt; &lt;div class="box-left column"&gt; &lt;span&gt;&lt;i class="one" /&gt;组织架构&lt;/span&gt; &lt;el-scrollbar wrap-class="tree-wrapper-scroller orgTree1"&gt; &lt;el-tree ref="orgTree" :data="treeData" default-expand-all node-key="id" highlight-current @node-click="handleNodeClick" &gt; &lt;span slot-scope="{ data }" class="custom-tree-node"&gt; &lt;span&gt; &lt;i v-if="data.id == '0'" class="treeIcon1 treeIcon_father2" /&gt; &lt;i v-else class="treeIcon1 treeIcon_children2" /&gt; {{ data.name }} &lt;/span&gt; &lt;/span&gt; &lt;/el-tree&gt; &lt;/el-scrollbar&gt; &lt;/div&gt; &lt;span v-if="params.isMultiple !== undefined" class="link el-icon-arrow-right" /&gt; &lt;!-- 多选 --&gt; &lt;div v-if="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9af6b13cbd68a2bcb683643ab6bdef6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e00c58fcbb0dfcbc190e41e82bcd51e/" rel="bookmark">
			Python下载及安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步下载Python：
官网下载地址：https://www.python.org/downloads/
百度网盘：https://pan.baidu.com/s/15ACm8KmJExfUZT8qHrLDSw 提取码：9csk
网盘里的python为3.9.5版本，64位对应的安装包，如需下载最新版本，可以去python的官网下载需要的python版本。
第二步安装python：
python安装包下载完成后，双击执行下载的exe程序，进入安装界面。安装界面可以选择默认安装和自定义安装
选择安装方式时可以将”Add Python 3.6 toPATH”勾选上，可以直接默认将用户变量添加上，后续就不需要手动添加
接下来就可以一直点击next，全部选择默认即可，在该界面时可以选择python安装的目录，然后点击Install
安装完成后界面如下图
安装成功后Pyhton文件目录结构如下图
检查Python是否安装成功，查看安装的python版本，可以使用win+r，运行cmd，在cmd窗口执行python -V
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1b33d7b6aa13166d1d297a33ecb7532/" rel="bookmark">
			有关偏序的概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		偏序 偏序：定义在一个集合S上的关系R，满足自反、反对称、传递，R就是偏序。
偏序集：集合S和S上的关系R一起成为偏序集，记作（S，R）
比如整数集合上的≥关系、正整数集合Z+上的整除关系…见离散数学及其应用P543≼表示任意一个偏序集中的序关系（抽象意义上的“小于等于”）。使用这个符号是因为“≤”关系是一种典型的偏序。a≺b表示a≼b但a≠b 全序集/线序集：（S，≼）满足偏序集；S上的每对元素都是可比的。S称为全序集或线序集，≼成为全序或线序。一个全序集也成为链
可比：如果偏序集中两个元素a和b有a≼b或b≼a，则a和b是可比的。否则a和b是不可比的
良序：对于（S，≼），≼是全序；且S的每一个非空子集都有一个最小元素
根据偏序集构造哈塞图步骤：
移除表示自反关系的环移走表示传递性的边排列每条边，使得起点在终点的下方移除有向边上的所有箭头 覆盖：（S，≼）是一个偏序集。x≺y且不存在z∈S使得x≺z≺y，则称元素y∈S覆盖元素x∈S
覆盖关系：y覆盖x的有序对（x，y）的集合
极大元：不存在b∈S使得a≺b，a就是偏序集（S，≼）中的极大元
极小元：不存在b∈S使得b≺a，a就是偏序集（S，≼）中的极小元
极大元、极小元分别对应哈塞图的“顶”元素、“底”元素
最大元：偏序集（S，≼），对于所有的b∈S都有b≼a，a是最大元
最小元：偏序集（S，≼），对于所有的b∈S都有a≼b，a是最小元
根据定义可知，最大元、最小元是唯一的
上界：偏序集（S，≼），u∈S，A是偏序集的子集。对于所有的a∈A，都有a≼u，称u是A的一个上界
下界：同理，对于l∈S，对于所有的a∈A，l≼a，称l是A的一个下界
最小上界：任意a∈A有a≼x，并且对于A的任意上界z有x≼z，x就是A的最小上界
元素a是子集A的最小上界，如果a是A的上界，且a小于其他上界。
最大下界：任意a∈A有y≼a，并且对于A的任意下界z有z≼y，y就是A的最小上界
元素a是子集A的最小上界，如果a是A的上界，且a小于其他上界。
关于最小上界x、最大下界y是否属于子集A：不一定。但是x、y一定要属于S
最小上界、最大下界也是唯一的
A的最小上界least upper bound：简记为lub(A)；最大下界greatest lower bound：glb(A)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdb0a2d86a3933c3abe6546004a9291d/" rel="bookmark">
			activiti6获取历史节点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		废话不多说 上代码
controller
@RequestMapping(“/getRunNodes”)
@ApiOperation(value = “获取历史执行节点”, httpMethod = “GET”, notes = “获取历史执行节点”)
@ResponseBody
public ResponseVo&lt;Map&lt;String, String&gt;&gt; getRunNodes(String procInstId) {
Map&lt;String, String&gt; runNodes = jbpmProcessinstanceService.getRunNodes(procInstId);
return new ResponseVo&lt;&gt;(runNodes);
}
service
public Map&lt;String,String&gt; getRunNodes(String procInstId) {
//procInstId 流程实例id
//查询流程运行到哪个节点了
Execution execution = runtimeService.createExecutionQuery()
.processInstanceId(procInstId)
.orderByProcessInstanceId()
.desc()
.list().get(0);
String activityId = execution.getActivityId();
Map&lt;String,String&gt; map= new LinkedHashMap&lt;&gt;();
// 获取流程历史中已执行节点，并按照节点在流程中执行先后顺序排序
List historicActivityInstanceList = ProcessEngines.getDefaultProcessEngine().getHistoryService().createHistoricActivityInstanceQuery()
.processInstanceId(procInstId)
//用户任务
.activityType(“userTask”)
//已经执行的任务节点
.finished()
.orderByHistoricActivityInstanceEndTime()
.asc()
.list();
// 已执行的节点ID集合
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdb0a2d86a3933c3abe6546004a9291d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8f56ff4d9ea388e5e51a297bbabc721/" rel="bookmark">
			免费生成Nginx的Https使用的SSL证书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、打开Free SSL Certificates Provider and ACME Tools 需要先注册
2、选择通配符证书，可以是二级或则三级通配符
例如：*.yourdomain.com 或则*.yourdomain.com.cn
3、打开生成页面，一直下一步，会生成一个_xxxx.yourdomain.com.key的文件
4、安装工具，安装后需要重新进入linux才能使用
可以参考：ACME v2证书自动化快速入门
curl https://get.acme.sh | sh -s email=yourEmail [root@localhost ~]# curl https://get.acme.sh | sh -s email=lenkty@live.cn % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 1032 0 1032 0 0 498 0 --:--:-- 0:00:02 --:--:-- 499 % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 214k 100 214k 0 0 23645 0 0:00:09 0:00:09 --:--:-- 21315 [Tue Dec 6 14:34:58 CST 2022] Installing from online archive.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8f56ff4d9ea388e5e51a297bbabc721/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70b1a7e259ed6e4d27167ad93df44b51/" rel="bookmark">
			YOLOv5 模型结构及代码详细讲解（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		王旭*，沈啸彬 *, 张钊*
(淮北师范大学计算机科学与技术学院，淮北师范大学经济与管理学院，安徽 淮北)
*These authors contributed to the work equllly and should be regarded as co-first authors.
🌞欢迎来到深度学习的世界 🌈博客主页：卿云阁
💌欢迎关注🎉点赞👍收藏⭐️留言📝
🌟本文由卿云阁原创！
🌠本阶段属于练气阶段，希望各位仙友顺利完成突破
📆首发时间：🌹2022年12月6日🌹
✉️希望可以和大家一起完成进阶之路！
🙏作者水平很有限，如果发现错误，请留言轰炸哦！万分感谢！
目录
🍈 配置文件
backbone配置文件
​编辑
🍊构成的元素
Conv ---CBA(convolution, batch normalization, activation)
关于SiLU--sigmoid linear unit
SPP(Spatial Pyramid Pooling)/SPPF(Spatial Pyramid Pooling Fast)结构
C3 -- cross stage partial network with 3 convolutions
🍋项目结构
🍈 配置文件 在yolov5中有好几种得配置文件，这几种配置文件只有下面的两个参数不同，其它部分都相同这两个参数是为了控制模型大小的。下面以yolov5l.yaml为例
depth_multiple: 1.0 # model depth multiple width_multiple: 1.0 # layer channel multiple 第一部分：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70b1a7e259ed6e4d27167ad93df44b51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d1402f5801c97005050ba4a60d593c6/" rel="bookmark">
			MAC 通过IDEA启动tomcat，显示80端口被占用解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mac系统下使用IntelliJ IDEA中的Tomcat报错问题：Address localhost:80 is already in use 一、状况描述 本人在跑一个tomcat的项目时，由于项目限制了用域名访问，为了方便本地开发调试，需在tomcat在IDEA中将端口设置为80，当一切准备工作弄好时，高高兴兴地启动项目，一看控制台，结果，啪，弹出"Address localhost:80 is already in use."的错误，很快啊。是我大意了，没有“闪”。
二、原由探究 经过查询各种资料得出结论：
1、Mac禁止了普通用户访问1024以下的端口，包括80端口。 2、通过IDEA启动SpringBoot项目80端口能正常使用，但是通过IDEA启动tomcat，会显示80端口被占用。 三、解决方法 在查询资料的过程中，查询各种解决方案，尝试一两种后，发现然并卵。于是我用自己的思路重新解决。
接下来聊聊聊我的思路吧：
1、我个人认为MacOS系统其实是跟Linux系统差不多类似的。
2、安装Nginx用80端口代理至本tomcat的端口(80端口除外啊，上面有讲)地址。
nginx 安装教程：https://blog.csdn.net/qq_43762932/article/details/126341858 nginx配置图片：
tomcat端口设置图片：
3、温馨提示：这一点用不到这个需求的可以不采纳：
修改host文件将 127.0.0.1 指向所需要的域名。
经过上述步骤后，然后在浏览器就可以用域名访问你本地跑的项目啦 。
四、本文最后 看完此篇文章就会有人纳闷了，为什么有的人发的解决方案那么简短(看起来很简单)，因为本人在采纳其中的一个，然而并没效果，于是采取了自己的思路解决，利用Nginx来做代理。
如果不Nginx不太熟悉的童鞋，顺便此篇帖子可以让你趁机了解一下Nginx。伟大的程序员行动吧！！！拒绝躺平！！！不然耗子尾汁！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39d99cf369ca16bcb8ef05cd815ae086/" rel="bookmark">
			MyBatis批量插入的五种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：预备工作 1：pom依赖： &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!--Mybatis依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--Mybatis-Plus依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 2：配置yml文件 server: port: 8080 spring: datasource: username: mysql用户名 password: mysql密码 url: jdbc:mysql://localhost:3306/数据库名字?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=UTC driver-class-name: com.mysql.cj.jdbc.Driver mybatis: mapper-locations: classpath:mapping/*.xml 3：公用的User类： @Data public class User { private int id; private String username; private String password; } 二、不同的实现方法 1：MyBatis利用For循环批量插入 （1）、编写UserService服务类，测试一万条数据耗时情况 @Service public class UserService { @Resource private UserMapper userMapper; public void InsertUsers(){ long start = System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39d99cf369ca16bcb8ef05cd815ae086/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e4a586291fbb0747acc7d1f6816fdca/" rel="bookmark">
			Redis 性能问题&amp;优化方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis性能问题&amp;优化方案 前言Redis真的变慢了吗？使用复杂度过高的命令操作bigkey集中过期实例内存达到上限fork耗时严重开启内存大页开启AOF绑定CPU使用Swap碎片整理网络带宽过载其他原因频繁短连接运维监控其它程序争抢资源 总结 前言 Redis 作为优秀的内存数据库，拥有非常高的性能，单个实例的 OPS 能够达到 10W 左右，也正因此如此，当我们在使用 Redis 时，如果发现操作延迟变大的情况，就会与预期不符。
或多或少地，你也遇到过以下这些场景：
在 Redis 上执行同样的命令，为什么有时响应很快，有时却很慢？为什么 Redis 执行 SET、DEL 命令耗时也很久？为什么我的 Redis 突然慢了一波，之后又恢复正常了？为什么我的 Redis 稳定运行了很久，突然从某个时间点开始变慢了？… 如果你并不清楚 Redis 内部的实现原理，那么在排查这种延迟问题时就会一头雾水。
如果你也遇到了以上情况，那么这篇文章将会给你一个「全面」的问题排查思路，并且针对这些导致变慢的场景，我还会给你一个高效的解决方案。
在正文开始之前，需要提醒你的是，这篇文章很长，涵盖的 Redis
知识点也非常广，全篇文章比较长，如果此时你的阅读环境不适合专注阅读，建议你先收藏此文章，然后在合适的时间专注阅读这篇文章。
如果你能耐心且认真地读完这篇文章，相信你对 Redis 的性能调优将会有非常大的收获。
Redis真的变慢了吗？ 首先，在开始之前，你需要弄清楚 Redis 是否真的变慢了？
如果你发现你的业务服务 API 响应延迟变长，首先你需要先排查服务内部，究竟是哪个环节拖慢了整个服务。
比较高效的做法是，在服务内部集成 链路追踪，也就是在服务访问外部依赖的出入口，记录下每次请求外部依赖的响应延时。
如果你发现确实是操作 Redis 的这条链路耗时变长了，那么此刻你需要把焦点关注在业务服务到 Redis 这条链路上。
从你的业务服务到 Redis 这条链路变慢的原因可能也有 2 个：
业务服务器到 Redis 服务器之间的网络存在问题，例如网络线路质量不佳，网络数据包在传输时存在延迟、丢包等情况Redis 本身存在问题，需要进一步排查是什么原因导致 Redis 变慢 通常来说，第一种情况发生的概率比较小，如果是服务器之间网络存在问题，那部署在这台业务服务器上的所有服务都会发生网络延迟的情况，此时你需要联系网络运维同事，让其协助解决网络问题。
这里重点关注的是第二种情况。
也就是从 Redis 角度来排查，是否存在导致变慢的场景，以及都有哪些因素会导致 Redis 的延迟增加，然后针对性地进行优化。
排除网络原因，如何确认你的 Redis 是否真的变慢了？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e4a586291fbb0747acc7d1f6816fdca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf614d00a20cf40ceaf30b85c22ed7fa/" rel="bookmark">
			ubuntu&#43;Docker双容器docker-compose部署Django&#43;Vue项目(2-Django)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 部署Django后端接口下载Python环境及一些尝试pip包管理运行项目容器报错1(查询容器IP解决)报错2(pvsite_uwsgi.ini文件配置socket还是http)报错3(用http先)用python manage.py runserver运行项目先报错4(下载cryptography库) 回到用uwsgi+django运行成功先在uwsgi+django中加入nginx配置 最终使用docker-compose双容器配置项目目录树docker-compose.yml配置最终Django文件配置requirements.txt文件配置pvsite_uwsgi.ini文件配置Django下的Dockerfile文件配置 最终Vue文件配置Vue下的Dockerfile文件配置Vue下的nginx.conf文件配置 其他笔记写在最后 部署Django后端接口 下载Python环境及一些尝试 由于项目用到是3.8.8版本，避免之后出现问题。就不下最新的了
docker pull python:3.8.8 以python镜像启动一个容器，参数以命令模式进入该容器：
docker run -it python /bin/bash /bin/bash进入容器中的命令行，暂时我理解为进入之后用法和ubuntu中的终端一样。(毕竟一个容器相当于一个虚拟机[滑稽])
但是上面的命令的命令会默认运行最新的python版本，本地的旧版本都不行
运行指定版本镜像
docker run -it python:3.8.8 /bin/bash 后台运行
在大部分的场景下，我们希望 docker 的服务是在后台运行的，我们可以过 -d 指定容器的运行模式，--name给容器起名
docker run -itd --name pythonTest python:3.8.8 /bin/bash 进入容器
exec 命令适用于进入后台运行的容器
docker exec -it 容器ID /bin/bash 可以直接进入容器中下载Django，执行如下命令，第一次不行，第二次就好了
pip install django pip包管理 在本地下载pip管理工具(可以下载其他工具试试,这里用pipreqs)
pip install pipreqs 下载完执行命令
pipreqs --encoding=utf8 ./ 导出文件到当前路径，后续可继续添加所需要的库
运行项目容器 先跑出项目容器
docker run -it -d --name Djangotest -p 9001:9001 -v /home/andy/Web/Django:/home/andy/Web/Django python:3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf614d00a20cf40ceaf30b85c22ed7fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/384c81401e765be11d69b10241fdcbeb/" rel="bookmark">
			拯救强迫症：Win11去除桌面快捷方式小箭头
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 不知道大家是不是强迫症患者，看着win11桌面上的快捷方式的小箭头心里想刀扎似的，就是看着碍眼，今天我教大家一招去除小箭头的方法。
首先 大家打开注册表，快捷键win + r 调出运行，输入regedit，然后回车，进入电脑的注册表界面。
第二步 在注册表里面依次打开HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Icons
注意，部分电脑没有Shell Icons这一项，没有不要紧，我们在上一项也就是Explorer里面右击新建项，取名为Shell Icons即可。
第三步 在Shell Icons里面我们右击选择新建 --&gt; 字符串值(S)，名称为29，可以双击，可以右击选择修改，数值数据设为C:\WINDOWS\system32\imageres.dll,197，为了防止有的同学把系统按在了D盘E盘，这里我们可以直接把数值数据设为%systemroot%\system32\imageres.dll,197
保存后，重启电脑，桌面上快捷方式的小箭头就没有了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f2aa11e2c84b8cc8e6e7089aef08d48/" rel="bookmark">
			VSCODE linux 解决头文件未找到问题、g&#43;&#43;的常用编译参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、linux 版本解决头文件未找到问题
错误信息：[{
“resource”: “/home/ubuntu/erchashu/BTCreate.cpp”,
“message”: “检测到 #include 错误。请更新 includePath。已为此翻译单元(/home/ubuntu/erchashu/BTCreate.cpp)禁用波形曲线。”,
}]
解决方案：
首先打开一个文件夹，ctrl+shift+p 打开搜索，搜索
执行 g++ -v -E -x c++ - 搜索所有生成路径
将此路径添加到"includePath": 下。
{ "configurations": [ { "name": "Linux", "includePath": [ "${workspaceFolder}/**", "/usr/include/c++/9", "/usr/include/x86_64-linux-gnu/c++/9", "/usr/include/c++/9/backward", "/usr/lib/gcc/x86_64-linux-gnu/9/include", "/usr/local/include", "/usr/include/x86_64-linux-gnu", "/usr/include" ], "defines": [], "compilerPath": "/usr/bin/gcc", "cStandard": "gnu17", "cppStandard": "gnu++14", "intelliSenseMode": "linux-gcc-x64" } ], "version": 4 } 然后就可以正常搜索到.h文件了
二、g++常用编译参数
预编译 编译 汇编 链接
g++ 附加调试信息
3.优化源代码 （一般用-o2）
4.指定库文件
连接静态库生产可执行文件例子：
工程由当前文件夹下的BTCreate.cpp ，src文件夹下的Fun.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f2aa11e2c84b8cc8e6e7089aef08d48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84e762eb80c4c8b040f19a9d258141c1/" rel="bookmark">
			linux中sed和find,find 和sed基础用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、查找/etc目录下大于1M且类型为普通文件的所有文件 用法： find 搜索的目录或文件 查找的选项 -size 大小 +1M 大于1M -type 类型 f普通文件 d目录 [root@God5 ~]# find /etc/ -size +1M -type f /etc/selinux/targeted/contexts/files/file_contexts.bin /etc/selinux/targeted/policy/policy.31 /etc/selinux/targeted/active/policy.kern /etc/selinux/targeted/active/policy.linked /etc/udev/hwdb.bin 2、打包/etc/目录下面所有conf结尾的文件，压缩包名称为当天的时间，并拷贝到/usr/local/src目录备份 先找到/etc//目录下面所有conf结尾的文件 [root@God5 ~]# find /etc/ -type f -name "*.conf"|xargs tar -zcvf /usr/local/src/`date +%F`.tar.gz [root@God5 ~]# ls 2020-03-21.tar.gz [root@God5 ~]# cd /usr/local/src/ [root@God5 src]# ls 2020-03-21.tar.gz 3、利用sed 取出ifconfig命令中本机的IPv4地址 [root@God5 ~]# ifconfig ens33 | sed -n '2p' |sed -nr 's@^[^0-9]+([0-9.]+).*$@\1@p' 192.168.132.131 4、删除/etc/fstab文件中所有以#开头，后面至少跟一个空白字符的行的行首的#和空白字符 [root@God5 ~]# sed -r 's@^#[[:space:]]+@@' /etc/fstab # /etc/fstab Created by anaconda on Thu Nov 21 09:50:40 2019 # Accessible filesystems, by reference, are maintained under '/dev/disk' See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info # /dev/mapper/centos-root / xfs defaults 0 0 UUID=a3eb68a6-836d-481c-83ae-cc540635d1e9 /boot xfs defaults 0 0 /dev/mapper/centos-swap swap swap defaults 0 0 5、处理/etc/fstab路径,使用sed命令取出其目录名和基名 [root@God5 ~]# echo /etc/fstab | sed -nr 's@^(.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84e762eb80c4c8b040f19a9d258141c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9daf3925c3a5bc8c878c1895c8c84fb/" rel="bookmark">
			Vite 3.2.5配置代理proxy,打印代理转发的日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求背景 使用vite代理模式后，想看看vite是否传递参数，故而需要打印出代理的转发日志。
使用方法 启动的时候，带上–debug参数即可。如下所示
npx vite --debug 另一种是借用 proxy 配置中的 rewrite 函数手动打印，例如 console.log()。自行尝试即可
样例 https://gitee.com/matevip/artemis
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e110b217d51615796a20141ea0848da/" rel="bookmark">
			Android开发之弹出popwindow
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求: 在Android点击设置按钮，弹出popwindow，设置一个IP全局使用，退出重新打开APP，能保留上次传入的IP。
技术： popWindow
sharedPreference
代码实现： UI层 popwindow弹框内容，比较简单 一个编辑框 一个保存按钮
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent" android:background="#ffffff"&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="60dp" android:layout_margin="10dp" android:gravity="center_vertical"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="服务器IP：" android:textSize="20dp"/&gt; &lt;EditText android:id="@+id/pop_ip_edt" android:layout_width="match_parent" android:layout_height="wrap_content"/&gt; &lt;/LinearLayout&gt; &lt;Button android:id="@+id/pop_save_ip_btn" android:layout_width="80dp" android:layout_height="40dp" android:layout_gravity="center" android:text="保存"/&gt; &lt;/LinearLayout&gt; 代码层：
public class MainActivity extends Activity { private static final String TAG = "MainActivity11"; SharedPreferences sharedPreferences; PopupWindow popupWindow; //popWindow中的属性 Button saveBtn; EditText ipEdt; String popIpStr; ImageView setImg;//设置按钮 @Override protected void onCreate(Bundle savedInstanceState) { super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e110b217d51615796a20141ea0848da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72336bc4b947e2e247054de0f05be7dd/" rel="bookmark">
			UserWarning: Glyph 20809 (\N{CJK UNIFIED IDEOGRAPH-5149}) missing from current font解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如果只需要改图例的话，在plt前设置显示中文字体即可
font1 = {'family' : 'Times New Roman', 'weight' : 'normal', 'size' : 16, } from pylab import mpl # 设置中文显示字体 mpl.rcParams["font.sans-serif"] = ["SimHei"] plt.figure(figsize=(5,5)) plt.xlabel('lambda/nm',font1) plt.plot(WL,LED0,'-*',color='red',label='灯1') plt.plot(WL,LED,'-.',color='blue',label='灯2') plt.legend() plt.show() 如果需要图名也是中文的话，改成'family' : 'Microsoft YaHei'。
font1 = {'family' : 'Microsoft YaHei', 'weight' : 'normal', 'size' : 16, } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d17c14f52623708263aa4a42c2d26b39/" rel="bookmark">
			磁盘挂载失败:mount: wrong fs type, bad option, bad superblock on /dev/vdb1 故障排除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 故障现象 mount: wrong fs type, bad option, bad superblock on /dev/vdb1, missing codepage or helper program, or other error In some cases useful info is found in syslog - try dmesg | tail or so. 2. 故障排除 造成这个故障是因为原来内网的服务器上阿里云.在内网时是用的vg,用SMC上云之后VG就不再支持,默认被转成了vdb1,格式还是xfs
使用命令查看详细报错
dmesg | tail 获取到以下报错
[ 2084.391811] XFS (vdb1): Mounting V5 Filesystem [ 2084.404936] XFS (vdb1): Corruption warning: Metadata has LSN (2077:25717) ahead of current LSN (1:2). Please unmount and run xfs_repair (&gt;= v4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d17c14f52623708263aa4a42c2d26b39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26a48a3650b21c8f4d6ed8ba4a4caa13/" rel="bookmark">
			gitee/github上传远程仓库错误usage: git remote add [＜options＞] ＜name＞ ＜url＞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		gitee/github上传远程仓库错误 gitee/github上传远程仓库错误错误截图版本错误出现时间错误检查及解决1.网址中含有空格2.关闭翻译软件3.git bash自身问题 gitee/github上传远程仓库错误 不知道大家最近有没有碰到这个错误usage: git remote add [&lt;options&gt;] &lt;name&gt; &lt;url&gt;，我最近就碰到了，在上传到gitee的时候出现的，当我用git remote add的时候就报了这个错误，我原以为是创建仓库的问题就仓库删了从弄，结果不行，我还尝试传到GitHub上结果也不行依然是这个错误
错误截图 版本 软件/硬件版本git2.33.1windows10 错误出现时间 2022-12-06
错误检查及解决 1.网址中含有空格 查看你的网址中官方是否有空格，这可能是原因之一
2.关闭翻译软件 如果你的浏览器有翻译软件的话试试关掉再复制试试
3.git bash自身问题 我的就是git bash的自身问题，具体为什么我也不清楚
但是我只要用自己的终端直接设置地址就不会有这个错误，不用git bash
我最后又去尝试了创建其他仓库结果发现也是这个问题，希望大家看到之后集思广益，一起研究一下到底哪里出问题了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a67dc901b68fc35041ff98f2b3bfa51/" rel="bookmark">
			C语言 数组中查找其中的最大值，最小值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个数组输入10个数字（可以自定义），查找出其中的最大值，最小值，然后输出最大值、最小值
1.直接比较找出最大值，最小值 先设立max、min初始化为a[0](第一个数字)，然后依次比较 ，如果小的话那么min赋值为a[i]，如果大的话就max赋值为a[i]。
#include&lt;stdio.h&gt; int main() { int a[10]; for (int i = 0; i &lt; 10; i++)//输入10个数字 scanf("%d", &amp;a[i]); int max = a[0];//最大值初始化为a[0] for (int i = 1; i &lt; 10; i++) { if (max &lt; a[i]) max = a[i]; } int min = a[0]; for (int i = 1; i &lt; 10; i++) { if (min &gt; a[i]) max = a[i]; } printf("%d %d", max,min); } 结果如下： 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a67dc901b68fc35041ff98f2b3bfa51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c77e78e57d91388fbbba76dba81cade1/" rel="bookmark">
			FPGA入门教程之Quartus软件新建工程步骤（超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步：在随意一个路径下（必须是英文路径）新建文件夹（本文文件夹为test）
第二步：在test文件夹下新建prj文件夹（工程文件）、src文件夹（放置代码程序）、tb文件夹（放置仿真文件）、doc文件夹（放置本工程说明）；doc文件夹可以不用加入
第三步：在src文件夹下新建test.v文件，在tb文件夹下新建test_tb.v文件
第四步：打开Quartus软件
第五步：新建工程
（2）点击New Project Wizard进入下一步操作，或者点击File→New Project Wizard
（2）点击New Project Wizard弹出对话框，点击next
（3）之后会出现图一界面，然后如下图找到自己新建的prj工程文件夹位置并选择它
（4）输入工程名，点击next
（5）点击next
（6）进入如下界面后，选择之前新建的src文件夹中的test.v文件和在tb文件夹下的test_tb.v文件，并将它们打开
（7）点击next
（8）一下选项都要进行选择，2和3选择之后会出来设备名称，选第一个就OK了，点击next
（9）选择仿真工具，点击next（本人用的是ModelSim-Altera，有可能其他人的可能会不支持，所以要选择ModelSim→这个设置在系统环境变量里，有需要的可以添加系统环境变量）
（10）点击finish工程就建好了
第六步：添加仿真文件，点击setting进入之后，执行后面的繁琐操作
然后点击ok→ok→apply→ok，仿真文件就添加进去了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b89f26e586a372b25508def15c18e188/" rel="bookmark">
			复杂度——时间复杂度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、算法的复杂度
二、时间复杂度
三、时间复杂度习题
例1、2、3、4：普通循环的时间复杂度
例5：二分查找法的时间复杂度
例6：冒泡排序的时间复杂度
例7：普通递归的时间复杂度
例8：求斐波那契数的时间复杂度
附加题：逆置数组
前言 C程序在实现某种特定的功能的时候，会有多种代码去实现，为了提高程序的效率，需要考虑代码执行的时间和代码存储需要的空间。而在当今存储设备的进步，人们不是很在意存储代码所花空间的大小，会更在意代码运行的时间。
算法的复杂度 我们熟知的斐波那契数列，用递归的方式去实现的时候，代码十分简洁，但是这简洁的代码能说明它的效率高吗？
long long Fib(int N) { if(N &lt; 3) return 1; return Fib(N-1) + Fib(N-2); } 算法在编写成可执行程序后，运行时需要耗费时间资源和空间(内存)资源 。因此衡量一个算法的好坏，一般 是从时间和空间两个维度来衡量的，即时间复杂度和空间复杂度。时间复杂度主要衡量一个算法的运行快慢，而空间复杂度主要衡量一个算法运行所需要的额外空间。在计算 机发展的早期，计算机的存储容量很小。所以对空间复杂度很是在乎。但是经过计算机行业的迅速发展，计 算机的存储容量已经达到了很高的程度。所以我们如今已经不需要再特别关注一个算法的空间复杂度。
时间复杂度 定义：在计算机科学中，算法的时间复杂度是一个函数 ，它定量描述了该算法的运行时间。一个算法执行所耗费的时间，从理论上说，是不能算出来的，只有当程序执行起来，从它的执行快慢的情况下主观的判断。如果我们将每个代码都上机测试，那样将会很麻烦，所以才有了时间复杂度这个分析方式。一个算法所花费的时间与其中语句的执行次数成正比例，算法中的基本操作的执行次数，为算法 的时间复杂度。 即：找到某条基本语句与问题规模N之间的数学表达式，就是算出了该算法的时间复杂度。
大 O 的渐进表示法 1.若运行次数为常数，无论大小，时间复杂度均记为O（1） 2.若计算的运行次数为N的表达式，则只保留最高阶项，并将系数视为1 上述方法可以去掉对结果影响不大的项，简单明了的表示出了执行次数，在某些情况下算法的时间复杂度存在最好、平均、最坏三种。 最坏情况 任意输入规模的最大运行次数 ( 上界 ) 平均情况 任意输入规模的期望运行次数 最好情况 任意输入规模的最小运行次数 ( 下界 ) 时间复杂度习题 例1 // 请计算一下Func1中++count语句总共执行了多少次？ void Func1(int N) { int count = 0; for (int i = 0; i &lt; N; ++i) //N { for (int j = 0; j &lt; N; ++j) //N { ++count; } } //共N*N次 for (int k = 0; k &lt; 2 * N; ++k) //2*N { ++count; } int M = 10; while (M--) //10 { ++count; } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b89f26e586a372b25508def15c18e188/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00c86178d54398c880f7ce75f07e85b4/" rel="bookmark">
			gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu交叉编译Arm Linux环境下的身份证读卡器so库操作步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、配置环境变量
①将gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu.tar解压至/home/eastcoms/
sudo或者root运行命令 ：sudo tar -xvf gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu.tar -C /home/eastcoms
.tar用 -xvf
.gz用 -zxvf
.bz2用 -jxvf
.xz用 -Jxvf
②修改环境变量 命令：sudo gedit /etc/profile
在最后面加上：
export PATH=$PATH:"/home/eastcoms/gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu/bin"
或者：
export PATH="/home/eastcoms/gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu/bin:$PATH"
③使环境变量生效（相当于重启）命令：source /etc/profile
查看编译器是否存在，以及版本是否和交叉编译链7.5.0一致
命令：aarch64-linux-gnu-gcc -v 或者 aarch64-linux-gnu-g++ -v
如果一致，则表示配置成功，可以用交叉编译工具进行编译文件了
2、交叉编译libusb
①下载libusb 然后解压 链接：https://libusb.info/ downloads-&gt;latest soruce
②配置交叉编译环境和输出目录：
首先进入libusb文件夹打开终端：
sudo ./configure --host=aarch64-linux --prefix=/home/eastcoms/libusb --disable-udev CC=/home/eastcoms/gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-gcc CXX=/home/eastcoms/gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-g++
其中：
--host=aarch64-linux表示该软件编译完成后在aarch64-linux平台上运行，其他的还有arm-linux、x86_64-linux等
--prefix后面为libusb库安装目录/home/eastcoms/libusb
--disable表示禁用功能
CC表示指定gcc交叉编译器
CXX表示指定g++交叉编译器
③编译、安装libusb
命令：make
命令：make install
进入/home/eastcoms/libusb查看是否生成include和lib文件夹，进入lib文件夹查看文件 file libusb-1.0.so.0.3.0，可以看到是ARM aarch64的即表示编译成功。
3、编译读卡代码
aarch64-linux-gnu-gcc donsee.c dllMain.c utf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00c86178d54398c880f7ce75f07e85b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f95717761a1e5251aecaa1309c343b5/" rel="bookmark">
			Node.js学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		// 这是路由模块 // 1. 导入 express const express = require('express') // 2. 创建路由对象 const router = express.Router() // 3. 挂载具体的路由 router.get('/user/list', (req, res) =&gt; { res.send('Get user list.') }) router.post('/user/add', (req, res) =&gt; { res.send('Add new user.') }) // 4. 向外导出路由对象 module.exports = router 介绍： 此文章为黑马程序员视频参考笔记
仅供回顾内容参考
目录
介绍： 一、初识Node.js
1.1Node.js是什么，它是用来做什么的？
1.2node.js能干什么？
1.3前端用nodejs能做什么
1.4nodejs可以用来做什么
1.5nodejs 具体是做什么用的
1.6 node能做什么?
1.7node.js中的JavaScript运行环境 1.8node.js的学习路径 二、fs文件系统模块
2.1 读取指定文件中的内容
2.2 写入指定文件内容
2.3 成绩管理练习
2.4 fs模块-路径动态拼接问题
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f95717761a1e5251aecaa1309c343b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69d9ad165695ccfde95434e31d7a312d/" rel="bookmark">
			第二十五章《图书管理系统》第1节：图书管理系统简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图书管理系统具有图书信息管理、读者信息管理和借阅信息管理三大功能模块，本小节将从软件功能、数据库系统设计和项目结构几个方面介绍该软件系统的设计方案。
25.1.1系统功能简介 图书管理系统第一大功能模块是图书信息管理，这个模块的软件界面如图25-1所示。
图25-1图书信息管理界面
从图25-1可以看出：图书信息管理模块能够完成图书的新增、修改、删除、借阅登记等常规的信息管理工作，并且还能以多种方式对图书进行检索。
新增图书信息对话框如图25-2所示。
图25-2新增图书信息对话框
在这个对话框中，用户正确填写关于图书的各项信息，之后单击“确定”按钮就可以完成新增图书的操作。从图25-2可以看出：图书类型和出版社这两项信息并不是由用户手动填写的，而是从下拉框中选择的。这两个下拉框中的选项也是可以编辑和维护的，在图25-1所示的界面中单击“图书类型设置”和“出版社管理”按钮即可打开维护这两个下拉框选项的对话框，图书类型设置对话框如图25-3所示。
图25-3图书类型设置对话框
在这个对话框中可以对图书类型进行新增、修改、删除的操作。用户所设置的图书类型都会出现在图24-2所示窗体的图书类型下拉框中。同样，用户所设置的出版社信息，这些出版社信息也都会出现在图24-2所示窗体的出版社下拉框中。
当用户在图书列表中选中一条图书信息后单击“借阅”按钮，即可打开借阅登记对话框，这个对话框如图24-4所示。
图24-4借阅登记对话框
在图24-4所示的借阅登记对话框中会自动显示出读者所选定图书的编号和书名，并且还会显示出借书日期和最晚归还日期。借书日期就是当前日期，而最晚归还日期是当前日期后的第60天。操作人员只需要在这个对话框中填写读者编号，并单击“确定”按钮即可完成图书借阅操作。当完成图书借阅操作后，在借阅信息管理界面中就会出现一条借阅信息。
图书管理系统的第二个模块是读者信息管理，该模块的界面如图24-5所示。
图25-5读者信息管理界面
在读者信息管理界面中显示了读者的各项信息，其中读者编号与他的图书证编号是一致的，因此每条读者信息与其图书证上的信息也是一致的。在这个界面中可以完成读者信息的查询、新增、修改等操作，此外，如果有读者出现多次逾期未还图书、丢失图书等情况，还可以对其进行停用操作，只需要在列表中选中一个读者，然后单击“停用”按钮即可，处于停用状态的读者不能再次借阅本系统中的图书，但可以进行归还图书的操作。被停用的读者还可以被恢复正常状态，只需要从列表中选定被停用的读者后单击“恢复”按钮即可。读者信息不能被删除，这是为了在系统中保留所有注册过的读者信息。
图书管理系统的第三个模块是借阅信息管理，这个模块的界面如图25-6所示。
图25-6借阅信息管理界面
在借阅信息管理模块中显示出了图书的借阅信息，这些信息的最后一列显示出了图书的归还状态，每条借阅信息根据图书是否归还以及是否超过归还日期分为未还、逾期未还、按时归还和逾期归还4种状态。每次打开该模块时，系统都会自动更新状态，并且界面左下角还设置了“刷新”按钮用来手动更新状态，例如登录图书管理系统时是2022年10月5日，但一直到10月6日还没有退出系统，在这种情况下可能某些图书在10月5日还属于“未还”状态，但到了10月6日就变成了“逾期未还”状态，而单击“刷新”按钮就能够即时更新状态。
当操作人员选定一条借阅信息并单击“还书”按钮后，能够完成还书操作，但在真正还书之前系统会弹出确认对话框让操作人员确认图书信息和读者信息以避免出现操作错误的情况，还书确认对话框如图25-7所示。
图25-7还书确认对话框
25.1.2数据库表设计 图书管理系统包含多种信息，它们分别是：图书类型、出版社、图书、读者、借阅记录，因此本系统总共有5张数据表，它们分别是：
book_type：存储图书类型信息。publisher：存储出版社信息。book：存储图书信息。reader：存储读者信息。record：存储借阅信息。 在以上5张表中，book_type表和publisher表的结构完全相同，它们如表25-1所示。
表25-1 book_type表和publisher表结构
字段
类型
长度
意义
id
varchar
20
编号
name
varchar
20
名称
book表的结构如表25-2所示。
表25-2 book表结构
字段
类型
长度
意义
id
varchar
20
图书编号
book_type_id
varchar
20
图书类型编号
name
varchar
60
书名
author
varchar
20
作者
price
varchar
20
价格
publisher_id
varchar
20
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69d9ad165695ccfde95434e31d7a312d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca957b8fe6adf2a0cf2c7fc1ef9cca52/" rel="bookmark">
			华为HCIA考试（个人笔记）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		填空题：
Yarn做资源调度时，maptask和reduce Task是运行在Container中。
Flume在传输数据过程中，可以对数据进行简单过滤，主要通过设置Interceptor在Soure和Channel之间对不关心的数据进行过滤。
HBase会周期性的把MemStore的数据刷写在磁盘StoreFile文件中
Redis主要消耗内存物理资源
下面那些场景不是Flink组件擅长的：迭代计算、数据存储
如果需要由数据生产者决定数据发送给目标Bolt的某一个确定的Task，应选择直接分组消息发布策略
ElasticSearch采用倒排索引方式索引数据
如果想把Key中存储的数字值加1，该使用incr命令
TARN中队列的默认资源调度器是容量调度器
创建Loader作业中，可以在转换步骤中设置过滤器类型
以下优先级不属于创建Loader作业时必选项
商业模式发现无法通过大数据技术实现
传统数据处理的数据规模的单位是MB
创建Loader作业时，可以在输出设置步骤设置Map数
Fusininsight HD系统审计日志不可以记录查询历史监控操作
在YARN的任务调度流程中，下列申请和领取资源是ApplicationMaster负责的任务
HDFS的副本放置策略中，同一机架不同的服务器之间的距离是2
RegionServer故障时，HMaster由对已故障的RegionServer上的Region进行迁移
HBase通过BloomFiter快速判断用户数据不存在
用于记录Kafka中消息读取位置的是Offset
24315
Spark架构中Spark Core是核心模块
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3f50234911fdfd6abcd1dba3d487195/" rel="bookmark">
			解决启动postgresql问题var/run/postgresql/.s.PGSQL.5432
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		psql遇到麻烦
问题描述 我之前把postgresql的data_directory 换了地方，导致我打开psql会有如下错误：
Is the server running locally and accepting connections on Unix domain socket “/var/run/postgresql/.s.PGSQL.5432
解决方法 找到postgresql所在的文件夹
whereis postgresql
llxy@llxy-GS65-Stealth-9SD:/var/lib$ whereis postgresql postgresql: /usr/lib/postgresql /etc/postgresql /usr/share/postgresql 进到 /usr/lib/postgresql/12/bin 查到 pg_ctl 存放在这里，ok记住这个路径（path1 ）
llxy@llxy-GS65-Stealth-9SD:~$ cd /usr/lib/postgresql 12 llxy@llxy-GS65-Stealth-9SD:/usr/lib/postgresql$ cd 12 llxy@llxy-GS65-Stealth-9SD:/usr/lib/postgresql/12$ ls bin lib llxy@llxy-GS65-Stealth-9SD:/usr/lib/postgresql/12$ ls bin clusterdb initdb pg_checksums pg_dumpall pg_restore pg_upgrade reindexdb createdb oid2name pg_config pg_isready pg_rewind pg_waldump vacuumdb createuser pg_archivecleanup pg_controldata pg_receivewal pg_standby postgres vacuumlo dropdb pg_basebackup pg_ctl pg_recvlogical pg_test_fsync postmaster dropuser pgbench pg_dump pg_resetwal pg_test_timing psql 再找到更改后的 data_directory做存的文件夹，我存放在/bigdisk/pgdata，同样记住这个路径（path2）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3f50234911fdfd6abcd1dba3d487195/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c641903e2c8b53e4f85d1a0e52bbede4/" rel="bookmark">
			647. 回文子串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		动态规划 确定dp数组下标及含义： dp[i][j] s[i] 到s[j]是否为回文。是回文 dp[i][j]即为true 确定递推公式 首先保证j大于等于i。当i和j相等。例：a。 必为回文 dp[i][j]=truei和j相差为1 s[i]=s[j]时 例：aa 也为回文 dp[i][j]=truei和j相差大于1时， 例： abcba。 计算dp[i+1][j-1] if (s[i] == s[j]) { if (j - i &lt;= 1) { // 情况一 和 情况二 result++; dp[i][j] = true; } else if (dp[i + 1][j - 1]) { // 情况三 result++; dp[i][j] = true; } } 3.初始化dp数组 将dp数组初始化为false，遇到符合回文字符串的位置设置为true，就可以避免重复筛选
4.确定dp数组遍历顺序 从下到上，从左到右。因为要用到dp[i + 1][j - 1]就必须先计算
for(let i=s.length-1;i&gt;=0;i--){ //从下到上 for(let j=i;j&lt;s.lenth;j++){//从左至右 if (s[i] == s[j]) { if (j - i &lt;= 1) { // 情况一 和 情况二 result++; dp[i][j] = true; } else if (dp[i + 1][j - 1]) { // 情况三 result++; dp[i][j] = true; } } } } 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c641903e2c8b53e4f85d1a0e52bbede4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2aa893930d6a8b3c21f2d4257b803ba5/" rel="bookmark">
			域名查ip方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多人都知道每一个网站都会对应一个ip，那么你知道怎么样通过域名查ip吗，下面是通过域名查ip的方法介绍。
1、命令提示符查看：
采用ping命令，在运行里输入cmd(或使用功能键+R)，在命令提示符管理器里，输入：ping:juming.com即可查看到详细IP，这里将juming.com替换成你想要查询的域名即可。
2、通过站长工具查询域名对应ip地址
可以用chinaz、爱站等第三方站长工具，在其域名IP查询页面，输入域名，可以查到对应的ip地址。
3、另外，如果知道要查找相应域名的IP地址，可以在命令提示下输入nslookup IP地址：
start;run(table key+r)enter cmd;nslookup x.x(IP address);可以查看相应的域名。
但是，如果一个IP是许多域名主机的独立IP，则可以直接找到它;如果它是共享IP，则不希望通过IP找到域名。
注意：在使用虚拟主机过程中，建议不要直接使用IP地址。一般的虚拟主机都是共享IP，多个虚拟主机使用一个共享IP。一些平台会给每个虚拟主机提供一个独立的上传地址、解析别名：*****.1234.com，来代替IP使用。平常上传文件，管理文件，都可以使用这个地址。通过ping这个上传地址，得到的IP地址，与实际使用域名IP是一致的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea6b8278c6bc3f47b318230e4bf4ead6/" rel="bookmark">
			Android 闪图三种实现方式 动态闪
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		闪图作用不用说了：广告啊 公司标识之类的 1、静态图片放大动画 1）在activity中先插入动画效果方法
//放大图片 public void animateImage() { //设置缩放动画 ObjectAnimator animatorX = ObjectAnimator.ofFloat(splash, "scaleX", 1f, 1.5f); ObjectAnimator animatorY = ObjectAnimator.ofFloat(splash, "scaleY", 1f, 1.5f); AnimatorSet animatorSet = new AnimatorSet(); animatorSet.setDuration(2000).play(animatorX).with(animatorY); animatorSet.start(); //动画完成监听 animatorSet.addListener(new AnimatorListenerAdapter() { @Override public void onAnimationEnd(Animator animation) { //动画完成后跳转首页 startActivity(new Intent(FlashActivity.this,MainActivity.class)); finish(); overridePendingTransition(android.R.anim.fade_in, android.R.anim.fade_out); } }); } 2）在activity中开启子线程，延迟调用
2、Glide加载动态GIF图片 1）先在build.gradle添加依赖
implementation 'com.github.bumptech.glide:glide:3.7.0' 2）在activity中调用Glide方法加载，再延迟跳转
Glide.with(this).load(R.drawable.flash_gif).into(splash); 效果图：
3、VideoView加载asserts视频资源 1)先插入视频播放代码。
有小伙伴可能有疑惑，VideoView不是有进度条吗，只需要设置
mediaController.setVisibility(View.INVISIBLE);//隐藏播放进度条 //视频播放 private void playVideo(){ mVideoView = (VideoView)this.findViewById(R.id.vid_splash); //获得下载目录，不推荐使用，api29已弃用，返回的是公共下载目录，需要声明存储权限 //File directory_doc = Environment.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea6b8278c6bc3f47b318230e4bf4ead6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42cae71f68d84c03161419fb3b268f53/" rel="bookmark">
			【C语言】求素数的三种方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示： /* 该文章仅限学习和分享，若有不足之处，还请私信于我进行改善 */
文章目录 素数的定义求100-200之间的素数 素数的定义 1、素数又叫质数。素数，指的是“大于1的整数中，只能被1和这个数本身整除的数”。
2、素数也可以被等价表述成：“在正整数范围内，大于1并且只有1和自身两个约数的数”
求100-200之间的素数 提示：以下是本篇文章正文内容，下面案例可供参考
这里给出一个题目，以该题为例：
求100-200之间的素数，并算出该范围内有多少个素数？
第一种方案
# include &lt;stdio.h&gt; int main() { int i; //先求出100-200之间的所有的数 //这里给出一个for循环 int count = 0; for(i = 100; i &lt; 200; i++) { int j; //定义一个变量j用来表示因子 for( j = 2; j &lt; i ;j++) //用 2 到 i-1 之间的因子去试除i { if(i % j ==0) { break; //若能整除，则说明一定不是素数，跳出循环 } } //当上一个for循环任意一个数i都不能被j(2到i-1)整除，也即j==i时，跳出for循环 if (j == i) //此时因子i等于一个数本身，则说明是素数 { count++; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42cae71f68d84c03161419fb3b268f53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57e25977e2530002ddb7f5836ff84676/" rel="bookmark">
			Linux内核开发——编译Ubuntu 20.04内核代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 完整编译 1.1. 查看内核版本 可以使用下列
uname -r
5.13.0
1.2. 下载内核代码 可以直接下载一个比当前内核版本新的代码，也可以去https://mirrors.edge.kernel.org/pub/linux/kernel下载自己内核使用的版本。此文下载的是更新的版本 5.17.15，去官网https://www.kernel.org/，下载linux-5.17.12.tar.xz。
1.3. 解压 tar -xavf linux-5.17.12.tar.xz
1.4. 配置环境 1.4.1. 更换源 不同版本的Ubuntu，需要对应不同版本的源。可以通过。https://mirror.tuna.tsinghua.edu.cn/help/ubuntu/上可以选择不同版本的Ubuntu对应的源。
# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse deb https://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57e25977e2530002ddb7f5836ff84676/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cc91b2e98d0be902a00968348e81945/" rel="bookmark">
			Xilinx AXI-GPIO用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		xilinx axi-gpio是用来将AXI接口转化为gpio接口，其中gpio可以设置为3个状态，in、out、inout三个状态；gpio的位宽最大支持到32bit，例程中设置为1bit，仅仅作为ouptut、使能了两路gpio的输出，配置如下：
注意哈： 此处本来认为AXI地址和数据都是32bit，但是实测过程中我使能两路agio管脚，第二路地址跳变是按8跳的，比如说我第一路设置的axi地址为0，则要想配置第二路gpio使能，则需要向地址8中写1第二路gpio才能拉高。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/077611ce183863a1552d70cb3aae515d/" rel="bookmark">
			【笔记】小米电视屏蔽广告好评，亲测方法及相关设备参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 微信关注公众号 “DLGG创客DIY”
设为“星标”，重磅干货，第一时间送达。
这个小米电视，买了有几年了，型号我记得是4（找不到购买记录了）。给父母用，所以联网次数也不多，不过每次联网之后增加的广告和因广告导致的开机速度变慢，还是非常印象深刻的。
最近搞了AIO，希望能让孩子在奶奶家也能看到nas里的动画片，即实现远程访问nas的功能。那就肯定是要联网的，所以想把小米电视的广告处理一下。
屏蔽广告的方法是参考网上的在路由器中设置hosts的方法，如下图所示，想需要屏蔽的域名填如，就能很轻松的实现广告屏蔽。
如上图所示，是京东云的二代路由器，在“高级功能”里找到自定义Hosts的功能，填如对应要屏蔽的域名。这个应该是路由器的基本功能，大部分路由器都应该有这个功能。
实测不光是开机广告，视频前的广告也可以屏蔽。
下边记录一下相关参数给大家参考：
电视型号：L55M5-AB
电视系统版本：1.3.125
注意事项：
建议关闭更新，省的回头官方把这“方法”修复了，就没法屏蔽了
转了吗赞了吗在看吗 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc16406845d243a19edfe796e8e3fd0a/" rel="bookmark">
			解决 413 Request Entity Too Large（请求实体太大问题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 上传文件出现问题 413 Request Entity Too Large，如下图所示
我们可以看到请求的body的大小，在Content-Length后显示，Nginx默认的request body为1M，小于我们上传的大小
解决方案 找到自己主机的nginx.conf配置文件，打开 在http{}中加入 client_max_body_size 10m; 然后重启nginx service nginx restart Nginx 出现504 Gateway Time-out的解决方法:
http://t.zoukankan.com/linjiqin-p-11858127.html 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fc19cf871778ba7472884864db9620b/" rel="bookmark">
			python读取xlsx转csv文件出错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为python读取xlsx文件的时间较长，然后想通过转csv的方式来缩短时间，陆续出现了很多玄学问题。
直接改后缀，出现以下问题：
ParserError: Error tokenizing data. C error: Expected 1 fields in line 11, saw 4 按照网上的解决方法，加上：
header=None,sep = None
又出现下列问题：
'utf-8' codec can't decode byte 0x87 in position 10: invalid start byte 以及warning
ParserWarning: Falling back to the 'python' engine because the 'c' engine does not support sep=None with delim_whitespace=False; you can avoid this warning by specifying engine='python'. 这里，加上engine='python'，waring就会消失，将encoding = 'utf-8'改成gbk也好还是什么，都会报错。
UnicodeDecodeError: 'gbk' codec can't decode byte 0xf9 in position 56: illegal multibyte sequence 中途试过打开xlsx文件，在wps里选择另存为.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fc19cf871778ba7472884864db9620b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a4377a1d8ef1625d95d77152b8a9d13/" rel="bookmark">
			老司机发车了，CountDownLatch：等与不等都在你
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		哈喽大家好，我是阿Q。
前几天我们把 ReentrantLock的原理 进行了详细的讲解，不熟悉的同学可以翻看前文，今天我们介绍另一种基于 AQS 的同步工具——CountDownLatch。
CountDownLatch 被称为倒计时器，也叫闭锁，是 juc 包下的工具类，同时也是共享锁的一种实现。它的作用是可以让一个或多个线程等待，直到所有线程的任务都执行完之后再继续往下执行。
举个简单的例子：阿Q高中时期都是乘坐大巴往返于县城与农村，那时的司机为了利益的最大化，会在汽车满员的情况下才会发车。
如果我们把乘客去车站乘车比作一个一个的线程，那 CountDownLatch 做的事就是等大家到齐之前的等待工作。
我们从源码的角度来分析下它的工作原理
①谁来决定公交车上的座位数？
公交车上的座位数是由汽车制造商决定的，在 CountDownLatch 中也会存在这样一个值 count，用来表示需要等待的线程个数。
count 值是在 CountDownLatch 的构造函数中进行初始化的
public CountDownLatch(int count) { if (count &lt; 0) throw new IllegalArgumentException("count &lt; 0"); this.sync = new Sync(count); } Sync(int count) { //设置 AQS 中的 state 为 count 值 setState(count); } 复制代码 计数值 count 是一次性的，当它的值减为0后就不会再变化了，这也是其存在的不足之处。
②谁来确定乘客全部到齐？
在汽车发车前检票员会对车上的乘客数量进行清点，如果满员了就会通知司机开车。
当然也可以采用这种方法：在得知车座位数的前提下，每上来一位乘客，座位数进行减一操作。CountDownLatch 就是采用的上述方法，它的 countDown() 方法会对 state 的值执行减1操作。
让我们从源码的角度来认识一下该方法。
public void countDown() { //释放共享锁 sync.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a4377a1d8ef1625d95d77152b8a9d13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b68d2596264f77ef23b3569bbdd02001/" rel="bookmark">
			yolov5推理出大的错误框--一种简单粗暴但局限的规避方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一。概述
二。问题描述
三。验证
四。一种简单粗暴但局限的规避方法
一。概述 yolov5在匹配格子、anchor与物体标签的时候，有可能把同一个格子同一个anchor匹配给不同的物体，甚至是尺度相差的比较大的物体，此时就有可能导致在推理的时候推理出一些置信度偏低、尺度比真实物体大很多的物体框。本文采用了一种简单粗暴并且有局限性的办法来规避，但是在一定的限度内确实蛮有效的~~
二。问题描述 在yolov5源码解析(10)--损失计算与anchor_扫地僧1234的博客-CSDN博客
的末尾抛出了一个问题，具体可以去看一下那一期的内容（强烈建议去看一下!），简单的说，就是标注的物体a、b有重叠，在训练的时候有可能同一个格子即负责预测物体a，也负责预测物体b。你可能会说这不是很正常吗。
但是如果物体a、b的尺度相差比较大，比如物体a大，物体b小，而物体a、b的中心点比较接近，此时也会发生这种情况，比如下图：
耳塞基本在平板的中间，这样它们的中心点就能归到同一个格子上，那么这个格子就有可能会既负责预测平板，也负责预测耳塞。
注意：
(1)这里说的是有可能，因为除了中心点与格子的关系之外，物体的宽高与anchor的宽高比例不能超过4（超参anchor_t）
(2)也不一定中心点非得落在这个格子， 比如中心点落在格子c里，位置偏左上，那么格子c的左侧格子，上侧格子都会负责预测该物体。
如下图，详见yolov5源码解析(10)--损失计算与anchor_扫地僧1234的博客-CSDN博客
那么如果一个格子既要预测平板，又要预测耳塞会有什么问题呢：
(1)显然在非多标签分类的情况下，这个格子不管是预测平板还是预测耳塞的分类得分都会被抑制，所以两个得分都会比较低，sigmoid之后会接近0.5。这好像问题不是太大，0.5咱就不要它呗，咱要得分高的。
(2)这个格子还得预测物体的宽高啊，平板和耳塞的尺寸差距比较大，一会儿用平板的宽高真值给他计算损失，一会儿用耳塞的宽高直值给他计算损失，那最终得出的宽高可能不靠谱。
(3)问题(1)里面说0.5的就不要，但是如果我们训练出来的东西里面，有些东西的效果不太好，置信度比较低，跟0.5很接近，而我们又想要预测出这些东西，那置信度就有点难设了。
三。验证 光说无用，我们先验证一下到底会不会有上面说的问题，拍了一批图片，一共50张，拍的时候没用耳塞，拿着耳机了（不要在意这些细节。。），训练集45张图，测试集5张图
另外为了省时间，拍的图有点少。有兴趣的同学也可以多拿些图验证验证，其实我是工作中验证的东西遇到了这个问题，当时用了几百张图，有300多张的，也有900多张的，都有这个问题。所以这个可能跟图多图少关系不是太大。
标注的分类就是平板和耳塞（耳机。。）
接下来开始训练：
python train.py --data earplug_data/dataset.yaml --cfg models/yolov5s.yaml --weights weights/yolov5s.pt --batch-size 8 --epochs 200 --cache --name exp_earplug 看上面的数据可能不能直接反映出我们的问题，直接再推理一遍验证集：
python detect.py --weights D:\workPython\yolov5-6.2\runs\train\exp_earplug\weights\best.pt --source D:\dataset\earplug_data\images\val --name exp_earplug 第一张图就出问题了，推理出了一个置信度0.55，类型为耳塞的物体，但是尺寸明显比耳塞大，可能位于耳塞与平板之间的尺寸。
其它4张图没什么问题
现在的问题很明显，就是在推理的时候，如果耳塞与平板的中心点接近，就有可能有问题，跟上面说的情况一致。
四。一种简单粗暴但局限的规避方法 怎么解决这个问题呢，其实yolov5的作者可能知道这个问题，但是这个问题可能暂时并没有很好的解决方案，或者说这个问题本身就是在一些特殊的场景下才会有的，比如你有1万张图，但只有10张才会有这种问题（即问题场景只有千分之1），这种情况下训练出来的模型还有没有这个问题我就没验证过了。
但是同一个框，同时预测两种尺度相差比较大的物体，明显是不太合理的。
先回顾一下，yolov5一共有3层输出，分别是80x80，40x40，20x20，浅层的用来预测小物体，中层的预测中物体，深层的预测大物体。每一层都有3个anchor分别对应不同尺度的宽高。如果能设计一种规则，让不同层的anchor把要预测的物体分摊一下，不要出现这种同一个格子的同一个anchor同时预测两个不同的东西的情况，那就没这个问题了。但问题就是，这个规则很难设计，如果必须保证一个格子一个anchor只预测一个物体，而不预测其它物体，那就有可能导致有些物体没人负责预测了，它们就丢了！
所以这里先提出一种简单粗暴的方法，比如本文中的实例，这个平板很大，直接让20x20这一层的最大的anchor来预测它就行了啊。即373,326这个anchor。剩下的8个anchor负责预测耳塞（不管能不能匹配上，分正我们把它们分开了！）
怎么实现呢，修改utils/loss.py的build_targets函数（注，这里用的是yolov5-6.2的代码，先跟前面的源码解析系列保持一致，但我看了一下yolov5-7.0的代码，这一块应该没怎么变）
直接上完整代码。
def build_targets(self, p, targets): # Build targets for compute_loss(), input targets(image,class,x,y,w,h) na, nt = self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b68d2596264f77ef23b3569bbdd02001/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f55e6e8bc1adce7b7586735fc73e508a/" rel="bookmark">
			《MySQL实战45讲》——学习笔记18 “索引失效、函数/隐式转换“【建议收藏】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍几种MYSQL中索引失效的典型SQL用法，包括对索引字段使用函数、索引字段隐式类型转换（如字符串转数值类型，实质上也是使用CAST函数）、索引字段隐式字符编码转换（如utf8mb4字符集与utf8字符集的等值判断，实质上也是使用CONVERT函数）；
并且，有的时候你可能发现explain执行计划中使用了索引，但是SQL的性能依然很慢，这时就要观察下rows判断是否走了全表扫描；并不是说查询走了索引就一定快；
案例一：查询条件中对索引字段显示的使用函数 假设有一个交易系统，其中交易记录表tradelog包含交易流水号（tradeid）、交易员id（operator）、交易时间（t_modified）等字段，其中交易时间和流水号字段都加了索引；这个表的建表语句如下：
mysql&gt; CREATE TABLE `tradelog` ( `id` int(11) NOT NULL, `tradeid` varchar(32) DEFAULT NULL, `operator` int(11) DEFAULT NULL, `t_modified` datetime DEFAULT NULL, PRIMARY KEY (`id`), KEY `tradeid` (`tradeid`), KEY `t_modified` (`t_modified`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; 假设，现在已经记录了从2016年初到2018年底的所有数据，运营部门有一个需求是：要统计发生在所有年份中7月份的交易记录总数；这个逻辑看上去并不复杂，你的SQL语句可能会这么写：
mysql&gt; select count(*) from tradelog where month(t_modified)=7; 由于t_modified字段上有索引，于是你就很放心地在生产库中执行了这条语句，但却发现执行了特别久，才返回了结果；DBA同事的解释可能是：如果对字段做了函数计算，就用不上索引了，这是MySQL的规定；
现在分析下原因，下面是这个t_modified索引的示意图，方框上面的数字就是month()函数对应的值；
如果你的SQL语句条件用的是where t_modified='2018-7-1’的话，引擎就会按照上面绿色箭头的路线，快速定位到t_modified='2018-7-1’需要的结果；实际上，B+树提供的这个快速定位能力，来源于同一层兄弟节点的有序性；
但是，如果计算month()函数的话，你会发现这颗B+树的"有序性"被破坏了；例如当传入month(t_modified)=7的时候，在树的第一层就不知道该怎么办了——他不知道接下来往哪个方向找；也就是说，对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能，转而走全索引扫描（遍历整个索引树）；
需要注意的是，"放弃走树搜索功能"并不意味着优化器放弃使用这个索引；
在这个例子里，尽管优化器放弃了树搜索功能，但它遍历索引树获取t_modified字段，既可以选择遍历主键id索引，也可以选择遍历索引t_modified；优化器对比索引大小后发现，索引t_modified更小（覆盖索引），遍历这个索引比遍历主键索引来得更快；因此最终还是会选择索引t_modified；
使用explain命令查看一下这条SQL语句的执行结果：
key="t_modified"表示的是，使用了t_modified这个索引；因为测试表数据中插入了10万行数据，这里统计rows=100335，说明这条语句扫描了整个索引的所有值；Extra字段的Using index，表示的是使用了覆盖索引，因为仅需要全表扫描t_modified字段；
结论就是——由于在t_modified这个索引字段加了month()函数操作，导致了全索引扫描；
根据上述结论，可以在语句中不对索引字段做函数运算，而是使用范围查询，如下；
mysql&gt; select count(*) from tradelog where -&gt; (t_modified &gt;= '2016-7-1' and t_modified&lt;'2016-8-1') or -&gt; (t_modified &gt;= '2017-7-1' and t_modified&lt;'2017-8-1') or -&gt; (t_modified &gt;= '2018-7-1' and t_modified&lt;'2018-8-1'); 不过优化器在个问题上确实有“偷懒”行为——即使是对于不改变有序性的函数，也不会考虑使用索引；比如，对于 select * from tradelog where id+1=10000 这个SQL语句，这个加1操作并不会改变有序性，但是MySQL优化器还是不能用id索引快速定位到9999这一行；所以，需要你在写SQL语句的时候，手动改写成 where id=10000-1 才可以；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f55e6e8bc1adce7b7586735fc73e508a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33105b120e3541b66f74d953a312e88d/" rel="bookmark">
			【泛函分析】压缩映射定理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定义 设 X X X 为距离空间， T : X → X T: X \rightarrow X T:X→X 是一映射，若存在 0 ≤ λ &lt; 1 0\leq \lambda&lt;1 0≤λ&lt;1，使得
d ( T x , T y ) ≤ λ d ( x , y ) , ∀ x , y ∈ X d(Tx,Ty)\leq \lambda d(x,y), \quad \forall x,y\in X d(Tx,Ty)≤λd(x,y),∀x,y∈X
则称 T T T 是压缩的
引理 压缩映射是连续的
若 x n → x x_{n} \rightarrow x xn​→x，则： T x n → T x Tx_{n}\rightarrow Tx Txn​→Tx
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33105b120e3541b66f74d953a312e88d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37908a43ec109f3087ea128290a52e38/" rel="bookmark">
			tidb集群介绍和物理部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TiDB是NewSQL数据库的技术探路者和引领者，本文简要介绍了TiDB的组件TiDB Server、PD调度和TiKV，并使用TiUP搭建了三节点的TiDB集群环境，部署简单便捷。
TiDB介绍 TiDB是PingCAP公司自主设计、研发的开源分布式关系型数据库，是一款同时支持OLTP和OLAP业务的融合型分布式数据库产品，具备水平扩容或者缩容、金融级高可用、实时HTAP、云原生的分布式数据库、同时兼容MySQL 5.7协议和MySQL生态等重要特性。
如图是TiDB整体架构图，可以看到TiDB核心功能组件包括：
计算层TiDB Server，负责与客户端通信，执行SQL解析和优化存储层TiKV和TiFlash，支持key-value键值对存储和列式存储调度层PDCluster，整个集群的大脑，负责分发调度指令给TiKV分析计算模块TiSPARK，与Spark集群进行联动云原生架构，基于K8S实现容器云平台的自动化部署和运维通过TiDB Binlog实现MySQL数据库的实时同步 TiDB执行流程如图所示：
用户的SQL请求会直接或者通过 Load Balancer发送到TiDB ServerTiDB Server会解析MySQL Protocol Packet，获取请求内容，对SQL进行语法解析和语义分析，制定和优化查询计划，执行查询计划并获取和处理数据PD server根据TiKV节点实时上报的数据分布状态，下发数据调度命令给具体的TiKV节点数据全部存储在TiKV集群中， TiKV根据SQL请求返回数据到TiDB Server最后TiDB Server需要将查询结果返回给用户。 TiDB Server TiDB Server是SQL层，对外暴露MySQL协议的连接endpoint，负责接受客户端的连接，执行 SQL 解析和优化，最终生成分布式执行计划。TiDB层本身是无状态的，TiDB Server本身并不存储数据，只是解析 SQL，将实际的数据读取请求翻译成key-value操作转发给底层的存储节点 TiKV（或 TiFlash），最终查询结果返回给客户端。
SQL层架构如下所示：
用户的SQL请求会直接或者通过 Load Balancer发送到TiDB Server，TiDB Server会解析MySQL Protocol Packet，获取请求内容，对SQL进行语法解析和语义分析，制定和优化查询计划，执行查询计划并获取和处理数据。数据全部存储在TiKV集群中，所以在这个过程中TiDB Server需要和TiKV交互，获取数据。最后 TiDB Server需要将查询结果返回给用户。
PD Server PD server是整个TiDB集群的元信息管理模块，负责存储每个TiKV节点实时的数据分布情况和集群的整体拓扑结构，提供TiDB Dashboard管控界面，并为分布式事务分配事务 ID。PD不仅存储元信息，同时还会根据TiKV节点实时上报的数据分布状态，下发数据调度命令给具体的TiKV节点，可以说是整个集群的“大脑”。
调度信息的收集
调度依赖于整个集群信息的收集，简单来说，调度需要知道每个TiKV节点的状态以及每个 Region的状态。TiKV集群会以心跳包的形式定期向PD汇报两类消息，TiKV节点信息和Region信息：
每个TiKV节点会定期向PD汇报节点的状态信息，包括磁盘容量、承载的Region数量、数据写入/读取速度、发送/接收的Snapshot数量、是否过载等每个Raft group leader会定期向PD汇报Region状态信息，包括Leader的位置、Followers的位置、掉线Replica的数量、数据写入/读取速度等 调度的策略
PD在收集到信息后，会根据一些调度策略来制定具体的调度计划：
Region中副本的数量，当发现副本数量不满足Raft算法要求时，需要通过ADD或Remove副本来调整副本数量Raft Group中多个副本不在同一个位置，一般情况下PD只会保证多个副本不会落在同一个节点上，以避免单个副本失效导致多个副本丢失副本在存储之间均匀分配，使得各节点之间承载的数据更均衡Leader数量在存储之间均匀分配，Raft协议要求读写都是在leader上完成，因此PD会尽量保证leader在节点之间分散开访问热点数据在存储间均匀分配，PD会检测出访问热点，并将其在节点之间分散开各个存储的空间使用大致相等，PD在调度时候会考虑节点的存储空间剩余量控制调度速度，避免影响在线服务，调度操作需要耗费CPU、内存、磁盘IO以及网络带宽，PD会对当前正在进行的操作数量进行控制 TiKV存储 TiKV负责存储数据，从外部看TiKV是一个分布式的提供事务的Key-Value存储引擎。存储数据的基本单位是Region，每个Region负责存储一个Key Range（从 StartKey 到 EndKey 的左闭右开区间）的数据，每个TiKV节点会负责多个Region。TiKV的API在KV键值对层面提供对分布式事务的原生支持，默认提供了SI (Snapshot Isolation)的隔离级别，这也是TiDB在SQL层面支持分布式事务的核心。TiDB的SQL层做完SQL解析后，会将SQL的执行计划转换为对TiKV API的实际调用。
Key-value键值对
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37908a43ec109f3087ea128290a52e38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/603de343328389f4e4f54f59aa25834e/" rel="bookmark">
			【编译原理】6—语法制导翻译Syntax-Directed Translation（SDD、SDT详细介绍）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		6 语法制导翻译Syntax-Directed Translation ⭐⭐⭐⭐⭐⭐
Github主页👉https://github.com/A-BigTree
项目链接👉https://github.com/A-BigTree/college_assignment
⭐⭐⭐⭐⭐⭐
文章目录 6 语法制导翻译Syntax-Directed Translation6.1 语法制导定义SDD6.1.1 属性分类6.1.2 在语法分析树的结点上对SSD求值⭐ 6.2 SDD的求值顺序6.2.1 依赖图6.2.2 属性求值的顺序6.2.3 S属性的定义⭐6.2.4 L属性的定义⭐6.2.5 具有受控副作用的语义规则 6.3 语法制导的应用6.3.1 抽象语法树的构造6.3.2 类型结构 6.4 语法制导的翻译方案6.4.1 后缀翻译方案6.4.2 产生式内部带有语义动作的SDT6.4.3 从SDT中消除左递归6.4.4 L属性定义的SDT 6.1 语法制导定义SDD 语法制导定义（Syntax-Directed Definition，SDD）是一个上文文无关文法和 属性及规则 的结合。
属性和文法符号相关联，而规则和产生式相关联。如果X是一个符号而a是X的一个属性，那么我们用X.a来表示a在某个标号为X的分析树结点上的值。属性可以有很多种类型，比如数字、类型、表格引用或串。
6.1.1 属性分类 综合属性（synthesized attribute）：自下而上传递信息。在分析树节点N上的非终结符号A的综合属性是由N上的产生式所关联的语义规则来定义。 继承属性（inherited attribute）：自上而下传递消息。在分析树节点N上的非终结符号B的继承属性是由N的父节点上的产生式所关联的语义规则来定义。 终结符只有综合属性，它由语法分析器提供。非终结符既可以有综合属性也可以有继承属性，但文法开始符号的继承属性作为属性计算前的初始值。
一个只 包含综合属性 的SDD称为S属性(S-attribute)的SDD；一个S属性的SDD可以和一个LR语法分析器一起自然地实现；一个没有副作用的SDD有时也称为属性文法（attribute grammar）；一个属性文法的规则仅仅通过其他属性值和常量值来定义一个属性值； 6.1.2 在语法分析树的结点上对SSD求值⭐ 一个显示了它的各个属性的值的语法分析树称为 注释语法分析树（annotated parse tree）。
我们对一棵语法分析树的某个结点的一个属性进行求值之前，必须首先求出这个属性值依赖的所有属性值。
对于综合属性，我们可以按照任何自底向上的顺序计算它们的值，比如对语法分析树进行后序遍历的顺序；对于同时具有继承属性和综合属性的SSD，不能保证有一个顺序来对各节点上的属性进行求值；从计算角度看，给定一个SDD，很难确定是否存在某棵语法分析树使得SDD属性值之间具有依赖关系。幸运的是，存在一个SDD的有用子类，它们能够保证对每棵语法分析树都存在一个求值顺序，后面将进一步讨论； 示例1：
对于如下文法：
写出 3 ∗ 5 + 4 n 3*5+4n 3∗5+4n的注释语法分析树。
自下而上
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/603de343328389f4e4f54f59aa25834e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be662e563b652fb4a472738c523fc818/" rel="bookmark">
			Kafka服务端参数配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 $KAFKA_HOME/config/server.properties文件中的配置
1、zookeeper.connect 该参数用于配置Kafka要连接的Zookeeper/集群的地址。它的值是一个字符串，使用逗号分隔Zookeeper的多个地址。Zookeeper的单个地址是host:port形式的，可以在最后添加Kafka在Zookeeper中的根节点路径。 如：
zookeeper.connect=192.168.0.101:2181,192.168.0.102:2181,192.168.0.103:2181/myKafka
2、listeners 用于指定当前Broker向外发布服务的地址和端口。（kafka内部通信）与advertised.listeners 配合，用于做内外网隔离。 3、内外网隔离配置： listener.security.protocol.map
监听器名称和安全协议的映射配置。比如，可以将内外网隔离，即使它们都使用SSL。 listener.security.protocol.map=INTERNAL:SSL,EXTERNAL:SSL
每个监听器的名称只能在map中出现一次。 inter.broker.listener.name
用于配置broker之间通信使用的监听器名称，该名称必须在advertised.listeners列表中。 inter.broker.listener.name=EXTERNAL
listeners
用于配置broker监听的URI以及监听器名称列表，使用逗号隔开多个URI及监听器名称。如果监听器名称代表的不是安全协议，必须配置listener.security.protocol.map。每个监听器必须使用不同的网络端口。 advertised.listeners
需要将该地址发布到zookeeper供客户端使用，如果客户端使用的地址与listeners配置不同。可以在zookeeper的get /myKafka/brokers/ids/&lt;broker.id&gt; 中找到。在IaaS环境，该条目的网络接口得与broker绑定的网络接口不同。如果不设置此条目，就使用listeners的配置。跟listeners不同，该条目不能使用0.0.0.0网络端口。advertised.listeners的地址必须是listeners中配置的或配置的一部分。 4、broker.id 该属性用于唯一标记一个Kafka的Broker，它的值是一个任意integer值。当Kafka以分布式集群运行的时候，尤为重要。最好该值跟该Broker所在的物理主机有关的，如主机名为host1.lagou.com ，则broker.id=1 ，如果主机名为192.168.100.101 ，则broker.id=101 等等。 5、log.dir 通过该属性的值，指定Kafka在磁盘上保存消息的日志片段的目录。它是一组用逗号分隔的本地文件系统路径。如果指定了多个路径，那么broker 会根据“最少使用”原则，把同一个分区的日志片段保存到同一个路径下。broker 会往拥有最少数目分区的路径新增分区，而不是往拥有最小磁盘空间的路径新增分区。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f03432121393487d1d84727a3a1498a/" rel="bookmark">
			【python蓝桥杯】等腰三角形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		核心思路：
1.将所有数以字符串保存在列表
2.将各个数拆成单个字符
3.一行一行填充（其中尾行单独填充）
4.列表再转化为字符串，统一输出格式
详细思路在代码注释：
#等腰三角形 n = int(input()) #n = 10 #end为观察得知，n与三角形个数的关系 end = (n-2)*2+n*2 #保存需要的字符，将每个数字当成字符串判断 m = [] #将每个数字加入列表，如['9','10','11'] for i in range(1,end): m.append(str(i)) #判断是否大于等于所需要的个数， if len(''.join(m)) &gt;= end: break #将每个数字拆分，如['9','10','11']拆成['9','1','0','1','1'] m = list(''.join(m))[:end] #print(m) #观察得知，其'.'与行数的关系，即有n行，每行有n+i个值（包括数字,先默认为'.'） ans = [] for i in range(n): ans.append(list('.'*(n+i))) #print(ans[0]) #开始同时填充等腰的两条边 #主要观察 k = 0 for i in range(len(ans)): #第一行规律与其它行不同，只用填充一个值 if i == 0: #观察发现填充的位置，如n=10,ans[0][9] = m[0],符合 ans[i][n-1-i] = m[k] else: #其它行数，可以同时由两边往中间填，其观察得到规律如下 ans[i][n-1-i] = m[k] ans[i][n-1+i] = m[len(m)-k] k += 1 #print(ans) #最后填充底边 for i in range(1,2*n-1): ans[-1][i] = m[k] k += 1 #整理格式，将列表变为字符串，输出 for x in ans: print(''.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f03432121393487d1d84727a3a1498a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8cb334486df1d89d4c130b4f66263b4/" rel="bookmark">
			Kubernetes 的 NameSpace 无法删除应该怎么办？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 有时候我们操作不规范，或者删除的先后顺序有问题，或者某项关键服务没有启动，导致 Kubernetes 经常会出现无法删除 NameSpace 的情况。这种情况下我们应该怎么办？
规范删除流程 其实，很多时候出现这种情况，主要是因为我们的删除操作不规范，典型的有下面几种情况：
删除的先后顺序有问题，如： 先删除了 Traefik 的关键组件，再尝试删除包含 Traefik Ingress 或 EdgeIngress 的 CRD 某项关键服务没有启动，如： 对于安装了 Prometheus Operator + custom adapter 的 Kubernetes 集群，在 Prometheus 的一些关键组件 scale down 的情况下，删除包含这些监控 CRD 或 HPA custom metric 的 NameSpace ...
综上，根源上，大部分情况下 NameSpace 无法删除，都是我们操作有错在先。
为了避免此类错误再犯，推荐搭建删除按照如下流程：
保证所有基础服务组件都是正常运行的状态（如前面提到的，ingress 组件，监控组件，servicemesh 组件。..)检查要删除的 NameSpace 下的所有资源，特别是 CRD, 这里推荐使用 Krew - Kubernetes 的 CLI 插件管理器 安装 get-all 来真正地获取该 NameSpace 下的所有资源，如后面的代码块所示：针对其中的一些 CRD 或特殊资源，最好先明确指定删除并确保可以成功删除掉最后，再删除该 NameSpace 第 2 步的代码块：（有如此多的 CRD)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8cb334486df1d89d4c130b4f66263b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bb16224cfc33897d1beb9c07d831d2c/" rel="bookmark">
			commons-math3-3.6.1-org.apache.commons.math3.analysis.integration.gauss-包下的类-中英对照文档及源码赏析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		commons-math3-3.6.1-org.apache.commons.math3.analysis.integration.gauss-包下的类-中英对照文档及源码赏析 摘要：中英对照文档、源码赏析、org.apache.commons.math3.analysis.integration.gauss、BaseRuleFactory&lt;T extends Number&gt;、GaussIntegrator、GaussIntegratorFactory、HermiteRuleFactory、LegendreHighPrecisionRuleFactory、LegendreRuleFactory、SymmetricGaussIntegrator
完整中文文档、中英对照文档下载请移步：commons-math3-中文文档、中英对照文档-CSDN下载 1. 开源组件说明 jar包名称：commons-math3-3.6.1.jar
Maven 依赖：
&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-math3&lt;/artifactId&gt; &lt;version&gt;3.6.1&lt;/version&gt; &lt;/dependency&gt; 完整中文文档、中英对照文档下载请移步：commons-math3-中文文档、中英对照文档-CSDN下载 程序包 org.apache.commons.math3.analysis.integration.gauss Gauss family of quadrature schemes. 高斯系列正交计划。
See: 说明
类 Summary 类说明BaseRuleFactory&lt;T extends Number&gt; Base class for rules that determines the integration nodes and their weights. 用于确定集成节点及其权重的规则的基类。
GaussIntegrator Class that implements the Gaussian rule for integrating a weighted function. 实现用于集成加权函数的高斯规则的类。
GaussIntegratorFactory Class that provides different ways to compute the nodes and weights to be used by the Gaussian integration rule.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8bb16224cfc33897d1beb9c07d831d2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d553f735751327cf6680e10605b2263c/" rel="bookmark">
			android studio内容提供者（查看短信的猫）点击查看短信，闪退，无法显示短信内容。（附程序源代码，以及解决办法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错的问题： Permission Denial: readingcom.android.providers.telephony.SmsProvider uri content://sms/ 找到问题： 老师最近讲到内容提供者，让我们做个案例，查看短信的猫，但我写完代码，在android studio里编辑了短信，而且检查代码没有问题，但出现程序闪退，我在Logcat发现上述程序错误。我在网上搜索得出是权限问题，是sdk23对应用程序权限做出了改动。
解决方法： 那个博主提供了两种结局方法：
1.使用sdk22开发，并且运行此程序的android虚拟机或者是手机系统6.0以下。（我不建议采用）
2.进行权限校验，在MainActivity里添加代码如下图：
final private int REQUEST_CODE_ASK_PERMISSIONS = 123; if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.M) { int hasReadSmsPermission = checkSelfPermission(Manifest.permission.READ_SMS); if (hasReadSmsPermission != PackageManager.PERMISSION_GRANTED) { requestPermissions(new String[]{Manifest.permission.READ_SMS}, REQUEST_CODE_ASK_PERMISSIONS); return; } } 用上面方法，我用的android studio自带的模拟器运行后，点击查看短信就可以查看我发出的短信了。
附上参考网址：http://t.csdn.cn/SC3kH
以下是程序源代码： 1.创建一个layout.XML.file 页面我采用RelativeLayout界面，名称为duanxin.xml &lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;ImageView android:layout_width="match_parent" android:layout_height="match_parent" android:src="@drawable/bg9"/&gt; &lt;TextView android:id="@+id/tv_des" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_marginTop="16dp" android:paddingLeft="20dp" android:text="读取到的系统短信如下:" android:textSize="30sp" android:visibility="invisible" /&gt; &lt;TextView android:id="@+id/tv_sms" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_below="@+id/tv_des" android:lines="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d553f735751327cf6680e10605b2263c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7eb69203bda38b9d6557d1e5560032fa/" rel="bookmark">
			Android Studio 虚拟机安装搜狗输入法（实现输入中文）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.下载安装包 我这里为大家准备一个，链接：https://pan.baidu.com/s/1kGkmPP5m3atWnyiGvdreuA 提取码：qwer 上面就是我在搜狗官方网站上新下载的，大家也可以去官网自行下载： 搜狗输入法手机版 (sogou.com)
2.安装 其实安装很简单（Android Studio不需要连接网络，安装包也不需要解压），你下载了之后，打开文件所在位置 然后我们再打开， Android Studio，之后运行模拟器，把他直接拖拽到模拟器里面就行了 之后 这样我们的Android Studio就可以输入中文了！ 江湖路远，让我们顶峰相见！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a6481c7f93c86712a926f65803a6373/" rel="bookmark">
			【工业】工业无线组网场景下的典型拓扑及设备解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工业以太网简介
工业以太网是指在工业环境的自动化控制及过程控制中应用以太网的相关组件及技术。工业以太网会采用TCP/IP协议，和IEEE 802.3标准兼容，但在应用层会加入各自特有的协议。常见工业协议简介：
lProfinet：西门子公司和PROFIBUS用户协会开发的实时通信协议，通信报文为二层和三层报文，延时要求高，常见于西门子设备上使用；
lModbus TCP：施耐德公司推出嵌入TCP帧的工业协议，通信报文为三层报文（IP层），工业设备之间通过彼此IP建立连接交互通信；
lEthernet/IP：面向自动化应用的工业应用层协议，通信报文为三层报文（IP层），是面向对象的协议，以TCP或UDP形式封装成报文在工业设备之间交互通信。
典型无线组网方案
典型的自动化车间、工厂、仓库等工业场景下无线组网拓扑存在要素：上位机（Server）/工业终端、交换机、无线接入点（AP）、无线客户端（Client），典型组网拓扑如下：
如何保证上位机与工业终端（AGV小车、机器人、PDA等）的正常通信，对于无线接入点（AP）和无线客户端（Client）的选择至关重要！！！干货来了！！
1、自带无线网卡接入无线的工业终端，只需要对AP进行选型即可：
2、没有无线网卡的工业终端，需要搭配无线客户端（Client）接入无线网络使用，需要对AP和Client进行选型：
看到这里就有小伙伴问了：这个无线通信格式三地址、四地址是个什么东西？Profinet通信为啥自带网卡接入的终端只要AP支持三地址就行，而搭配Client接入无线却需要AP和Client都必须支持四地址？而且Profinet必须要求5G吗？
在这里，小云君的答复是：
1、关于无线地址格式三地址/四地址技术我就不在本文扩展了，有兴趣的小伙伴可以找找相关资料自行查阅，后续我会在技术类的文档中给大家分享；
2、AP/Client的选择取决于通信协议，前面说过Profinet是二层报文，并不是上位机能ping通工业终端就可以了，还必须保证上位机Server能通过ARP正确的学习到工业终端的MAC才能建立PN连接并实现I/O通信。基于以下拓扑分析说明：
自带无线网卡的工业终端接入，上位机侧ARP表学到的是工业终端的真实MAC+IP，PN二层/三层报文交互均能正常；
而搭配Client接入无线的工业终端，假设AP和Client之间跑三地址，在上位机侧ARP表学习到的只有Client自身MAC，该MAC会对应多个IP（Client自身IP、以及下挂LAN侧所有工业终端的IP），此时上位机封装二层PN报文的dst mac就是Client MAC发出去，最终无线客户端收到该二层报文后因为dst mac是自己就不会向LAN侧转发，工业终端因此收不到上位机过来的报文导致通信失败：
所以当AP与Client采用四地址格式通信，上位机才能正确识别到工业终端的真实MAC+IP，从而实现PN协议的正常通信：
产品选型推荐
总结：针对Profinet通信需要买支持四地址格式和5G的无线设备，modbus TCP和Ethernet/IP支持三地址即可。
市面上所有厂商的AP或client基本都支持三地址，所以在这里我向大家推荐几款支持四地址的无线设备（更多机型请详细咨询各大设备厂商）：
（作者声明：最终产品解释权归各个厂家所有，在此仅作为已查到产品功能的支持情况给大家分享）
更多组网方案可关注微信公众号：网络工程师解决方案与技术
作者：小云君
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbd6f397892a3242da1b5547a712df55/" rel="bookmark">
			头歌：数据预处理之数据清洗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本关任务：完成泰坦尼克号遇难数据的清洗。
案例背景
泰坦尼克号遭遇的灾难震惊世界，如何避免灾难甚至预测灾难呢？ 要实现首先要做好泰坦尼克号的损失数据统计，才能为数据分析打下基础。
编程要求 根据提示，你需要完成：
缺失值填充离群点检测 import numpy as np import pandas as pd #读取数据 df=pd.read_csv('/data/workspace/myshixun/step1/train.csv') ##### begin ##### #查看列中是否存在空值 temp=df.isnull().any() print(temp) #使用SimpleImputer取出缺失值所在列的数值，sklearn当中特征矩阵必须是二维才能传入 使用reshape(-1,1)升维 age=df['Age'].values.reshape(-1,1) #导入模块 from sklearn.impute import SimpleImputer #实例化，均值填充,可改变strategy参数，实现其他填充方式 imp_mean=SimpleImputer(missing_values=np.nan,strategy='mean') #fit_transform一步完成调取结果 imp_mean=imp_mean.fit_transform(age) #填充好的数据传回到 data['Age']列 df_fillna=df df_fillna['Age']=imp_mean #检验是否还有空值，为0即说明空值均已被填充 print(df_fillna['Age'].isnull().sum()) ##### end ##### imp_mean=SimpleImputer(missing_values=np.nan,strategy='mean') imp_mean=imp_mean.fit_transform(age) df_fillna=df df_fillna['Age']=imp_mean #正太分布离群点检测 ##### begin ##### #计算均值 u=df['Age'].mean() #计算标准差 std=df['Age'].std() #识别异常值 error = df[np.abs(df['Age'] - u) &gt; 3 * std ] ##### end ##### print(error) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7deb9d37b15ffe5c616c7825fd1687f2/" rel="bookmark">
			Java输入一元二次方程的三个系数求一元二次方程的根
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 求一元二次方程的根。输入一元二次方程的三个系数，数与数之间用空格分隔。输出结果。
代码实现 import java.util.Scanner; public class Equation { static double a; static double b; static double c; static double num; //根据公式b^2-4ac判断根的数量 static double getRootNum() { num=(b*b)-(4*a*c); if(num&gt;0) { //大于0时，有两个不相等的根 System.out.println("此函数的解为:"); System.out.println("x1="+getRoot1());//调用函数求解 System.out.println("x2="+getRoot2()); } else { if(num==0) { //等于0时，有且只有一个根 System.out.println("此函数有且只有一个解:"); System.out.println("x="+getRoot1()); } else { //小于0时无解 System.out.println("此函数无解"); } } return 0; } //计算函数的根 static double getRoot1() { Double x; x=((0-b)+Math.sqrt(num))/(2*a); return x;//返回double值 } static double getRoot2() { Double x; x=((0-b)-Math.sqrt(num))/(2*a); return x; } public static void main(String[] args) { // TODO 自动生成的方法存根 Scanner sc=new Scanner(System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7deb9d37b15ffe5c616c7825fd1687f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/baf3387fd80ffaed1a924a725eacbca2/" rel="bookmark">
			E3--FPGA实现LVDS收发实例和原理2022-12-03
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是LVDS 一个新东西来的时候，人们总是希望能够宏观的定性的认识它。一个问题是，手机上用的“软件”该如何定义呢？来自百度百科的定义是，软件是指一系列按照特定顺序组织的计算机数据和指令的集合，如果你是非专业人员，第一次听说“软件”并听到这样的定义应该不会有好的感知。另外一种回答是，类似手机里“微信”的就是一个软件，虽然仍然不知道软件如何标准定义，但这个回答显然能让更容易的感知“软件”这个名词。生活中往往需要从另外一个事物A认识事物B，这个A可能和B存在某种关系，由于A很简单从而对B有了宏观的感知。生活如此，学习一个新的技术也是如此，或者说，学技术如此，生活也是如此。那该如何宏观感知LVDS呢？
LVDS的标准定义是Low-Voltage Diffferential Signaling低电压差分信号，为了克服以TTL电平方式传输宽带高码率数据时功耗大，电磁干扰大等缺点出现了LVDS技术，它具有低功耗、低误码率、低串扰和低辐射等特点。LVDS接口使用1.2V 偏置电压作为基准（共模直流电压），其正负端的摆幅大约为350mV，即所谓的差模电压。在网络上检索LVDS会出现各种说法，LVDS接口、LVDS电平、LVDS协议、LVDS技术，到底该如何理解呢？从电气标准的角度，LVDS是一种电平标准，其他常见的电平标准还有TTL、LVTTL、SSTL、LVCMOS、RS232、RS485等，不同电平标准有不同的场景应用。在Xilinx的FPGA中，支持这个电平标准，并且有LVDS_25\LVDS\LVDS33等，后续会介绍xilinx LVDS使用注意事项。从接口的角度看，LVDS可以称作接口，侠义的接口例如USB接口，千兆网口，麦克接口都是指某个物理硬件，可以连接起来。而广义的接口包括API、Sockets、弱函数、虚函数等软件上的接口，二者有一个共同的特点就是要在接口两端实现信息的传递，从这个意义上讲，LVDS是一个侠义的硬件接口。关于LVDS技术，这个说法主要是指LVDS接收器和收发器的硬件上的组成部分，大多数低速数字逻辑电平（如TTL、CMOS）是以电压对参考地的幅值来判断是高电平还是低电平， LVDS却完全不一样，它是通过数据接收器同相端与反相端的电压相对大小判断高低电平的，而不是通过同相端或反相端对公共地（GND）。通过恒流源和全桥开关电路不同晶体管的通断形成电压摆幅。关于LVDS协议，这种说法应该是不对的，通常协议是指规定两个或多个通信实体之间进行交换的报文格式和次序，LVDS并没有做这些规定。因此当设备与控制芯片（如FPGA）通过LVDS接口相连时，如何正确传输数据，这是控制芯片去适配设备接口属性的，这也是本篇要解决的问题，即实现FPGA上的LVDS与外部设备通信，实例中用到的外部设备也是FPGA。同样这也是LVDS的本质意义，即如何通过硬件电路LVDS接口实现通信。文末附本例源码。
2.LVDS传输模型 如上图所示，LVDS是典型的源同步传输模型，除此以外还有即将被淘汰的系统同步模型和现在应用广泛的自同步模型。源同步模型由数据线和时钟线组成，LVDS传输支持速率一般在155Mbps（大约为77MHZ）以上，推荐最大速率为655Mbps，理论极限速率为1.923Gbps。这里的时钟通常称之为随路时钟，并没有规定这个随路时钟的时钟频率是多少，但通常是并行时钟或者串行时钟（SDR）或串行时钟除以2（DDR模式）。它存在的意义便是帮助接收端恢复数据。恢复的过程是同步于随路时钟，发送一个双方约定好的Pattern，当接收端恢复出pattern时，认为通道可以传输有效数据。当通信速率较小的源同步模型，例如cypressUSB3.0方案中，可以通过将随路时钟相移的方法满足cypress芯片的时序参数要求。但LVDS的线速度是比较高的，需要通过逻辑代码中微调来找到数据采样的中心点。
关于LVDS接口通信的其他概念结合上图阐释，截图出自xapp585-lvds-source-synch-serdes-clock-multiplication.pdf，可以看到随路时钟采用的是并行时钟，一共有五个LVDS传输线同步于此时钟，此外还有通道的概念，通常是一个通道有一个单独的随路时钟，通道内有几个LVDS传输线。图中随路时钟的占空比并不均匀，在一个传输线高电平期间传输3bit，在低电平期间传输4bit，一个并行时钟周期单个传输线上传输的bit个数称为串化因子，图中串化因子是7。SDR模式和DDR模式是相对于串行时钟说的，DDR就是在串行时钟的上升沿和下降沿都发出数据。因此，一个并行周期将传输 7bit*5lines=35bit数据。上述提及的各个LVDS通信中的概念应该是通信双方已知的，就像串口传输通信双方应该协调好波特率等参数。
LVDS传输模型常用于液晶屏的信号接收端口，ADC转接芯片的数据输出端口，CMOS图像数据输出接口等场景。
3.LVDS硬件设计注意事项 1.不同型号的FPGA对于LVDS的速度支持是不同的，选型时需要注意。以下截图出自xilinx A7 datasheet。
2.应该确认Bank类型，HR bank只有在供电电压是2.5V的时候才可以使用内部电阻，当bank电压为其他值时，此时只能作为输入管脚且不能使用内部电阻。对于HP bank标准电压是1.8v，当bank电压是1.8v时可以使用内部电阻，当bank电压为其他值时，此时只能作为输入管脚且不能使用内部电阻。可在UG475中查看当前Bank是HR还是HP。
3.LVDS_25和LVDS（指1.8V）是可以互相通信的，这是因为他俩的直流特性是一样的。即设备之间通信也是，LVDS与LVDS_25可以相互通信，但要确保Vdiff和Vcm是兼容的。以下截图来自于xilinx官方回复，HR bank使用内部的终端电阻的时候，必须配置为LVDS_25,即bank电压为2.5v；当作为输入管脚，且不使用内部电阻，可以配置成其他电压；LVDS与LVDS_25可以相互通信，但要确保Vdiff和Vcm是兼容的（可在Datasheet中查看该属性）。第二张图是为了更好的说明了LVDS使用的问题。
4.最后是7系列不在支持LVDS_33，原因如图所示。 4.发送端LVDS程序设计 根据前三节的描述，搭建LVDS发送端程序首先要明确以下三个事项，①明确属性，包括通道个数，LVDS传输线个数，串化因子的大小，训练数据pattern值，以及SDR或DDR模式，随路时钟的大小；②明确当前硬件环境，随路时钟应该接MRCC或者SRCC管脚，否则vivado编译会不通过；差分数据管脚应该连接在FPGA上的PN差分对，并要确认好管脚所在bank的供电电压；还应该查看FPGA芯片数据手册判断是否支持需求的传输速率。③根据应用场景，例如LVDS发送端发送数据到LVDS液晶显示屏，则要遵守液晶显示屏时序的相关要求。在上述事项明确的前提下，LVDS发送端要解决的问题便是，将来自其他模块的应用数据按照既定的传输模型并转串后，接入到FPGA内部的LVDS发送器完成数据的发送。为此，xilinx 7系列提供了OBUFDS原语实现单端信号转LVDS差分信号的转换（可理解为该原语指向FPGA内部的LVDS发送器），提供了OSERDES2原语实现逻辑中应用并行数据的串行化处理。
本次实例拟8位传化因子，1个通道，2个LVDS，DDR模式，随路时钟为200MHz，并行时钟为50MHz,pattern值为0xe9，LVDS相关引脚连接某A7芯片Bank16，bank电压为2.5V。所发送的应用数据为测试数据为1-255自增，发送端逻辑框图如下
5.接收端LVDS程序设计 5.1接收端概述 接收端的传输模型各个属性应该与LVDS发送端各属性一致，例如，如果用于接收CMOS图像传感器的图像数据，则接收端程序的串化因子、通道个数等将要与设备一致。在硬件设计上，LVDS时钟线和LVDS数据线应该等长设计，但由于布线制板工艺的影响，难免数据线和时钟线无法同时到达接收端，在传输速度快时，微乎其微的偏差都可能让数据出错，这就是LVDS接收端要解决的问题，即在数据稳定窗口的中心采样，保持数据的稳定，这个动作称之为位对齐。此外，当在数据线上重复发送ABCDEFGH（假设一个字母代表一个bit），有可能接收到的是BCDEFGHA产生字偏移，通过ISERDES2的bitslip可以完成数据的平移，这个动作称之为“字对齐”。接收端通过IBUFDS进行差分转单端信号便于逻辑处理，将lvds传输线上的串行数据经过IDELAY2进行位对齐操作，随后利用ISERDES2将该串行数据并行化即字对齐操作，将发送端的数据恢复。其难点就在于如何实现字对齐和位对齐操作。Xilinx提供了多个例程适用于不同系列的FPGA，如xapp860和xapp855适于V5，xapp585适用于7系列，还有适用于ultrascale的例程。本例程基于xapp855修改使之适配7系列并满足既定传输模型属性要求。
5.2逻辑框图 以下框图截取自xapp855，与示例程序并不一致。数据差分信号经IBUFDS转化为单端信号，进入IDELAY2（由于xapp855适用于V5，而当前程序适用于7系列，因此原语的名称有所不同）将数据位对齐后进入ISEDERS2转换成并行数据；时钟差分信号经过IBUFDS转化成单端信号，进入IDELAY2（此处为0，以时钟到达为基准）由BUFR倍频出并行时钟，经BUFIO产生串行时钟。此外，使用IDELAY必须要使用IDELAYCTRL，输入200MHz作为参考时钟。还有两个逻辑模块一个是Bit Align Machine实现位对齐字对齐，产生ISERDES2和IDELAY2所需的信号，完成当前LVDS传输线的对齐操作。Resource sharing control实现通道切换，和训练完成的指示。
5.3xapp855训练代码解读 通道选择模块较为简单，主要介绍Bit Align Machine模块是如何完成单通道的数据训练操作。将ISERDES2模块传入的并行数据A打一拍得到B，当A不等于B的时候，认为此时遇到了亚稳态，即建立时间或者保持时间不满足要求的情况。当连续几个周期B等于pattern数据时，认为此时的采样点可用，字对齐也完成。完成数据训练的主要思路是，先使用IDEALY延迟直到找见一个亚稳态的点，未找见就延迟加1，然后继续增加延迟并加入字节对齐的判断直到找到Pattern数据，认为此时找到了数据窗口的左值，继续增加延时值，直到找见下一个亚稳态的采样点。从第一个pattern数据出现，增加延时值到下一个亚稳态的出现之间就是数据有效窗口，然后通过减去延迟值找到采样中心点，此后再次判断字对齐的情况，当字对齐结束后认为此LVDS传输线数据训练完成。由Resource sharing control控制开始训练下一个LVDS传输线。 以上截图出自xapp855的解释说明，步骤①即是假定数据和时钟到达时二者的相对位置关系。步骤②是经过延时找到了第一个亚稳态窗口（Transition），图中斜线部分代表此时数据采样不稳定。步骤③是通过延时和bitslip寻找到数据有效窗口的左值（Eye）。步骤④是通过延时找到下一个亚稳态窗口，由此在③和④之间便是数据有效的窗口。步骤⑤是将采样点控制到数据有效窗口的中心位置。需要注意，IDELAY2总共只有32个阶，当参考时钟是200MHz时，每一阶延时78ps，即总共可延时32*78=2496ps=2.5ns。因此数据传输的线速率不能太低，线速率太低时需要采用别的方法或者调整该状态机，否则会错误的找到最佳采样点，出现不稳定的情况，因此使用该程序，其线数据传输速率建议大于400Mbps。
下面对该模块中状态机简单分析便于理解。 00000不动（指各计数模块，idelay、bitslip均不做操作，后同），保证不与通道切换指令冲突。00001不动 比较前一个后一个，不相等认为找见第一个亚稳态窗口。01000 SAMPLE（指代码中信号含SAMPLE的128bit计数器，后同）计数器加1，连续抓15次判断是否为亚稳态窗口。01011 IDELAY延时加1，两个计数器清0。00100 SAMPLE控制7个周期后判断是否亚稳态，如此循环直到找到亚稳态窗口，即进入01111状态。（上述五个步骤必定能找见亚稳态窗口）01111 SAMPLE清0 IDEALAY加1 准备寻找pattern。01101 SAMPLE加1 JC添加8周期等待 找等于check pattern 找见就准备记录 重复上述步骤，直到找见稳态check pattern即渡过第一个窗口 bitslip=1。01100 SAMPLE清0 （进入IDLE状态）。10000 第二个idle 不动作。00010再次确认是否退出了窗口 如果没有退出，重复上述步骤直到退出。01110 确认跳出第一个亚稳态窗口，该状态CNT开始计数，找左值。01001 idelay值加1 CNT开始计数(记录的是数据有效窗口的大小，CNT指代码中不含SAMPLE的128计数器) 找下一个亚稳态区域。00011 SAMPLE计数控制8周期后比较数据，复制当前的CNT中的计数值，找见第二个就退出，找不见就重复上面步骤。10010 计数器全部清0 无动作跳转。01010 idelay减一减到有效采样的中间处即可，清0CNT。思考，假如taps的值不够用怎么办（即前文提到线数据速率不能太慢，否则会出现这种情况）。00101 CNT控制延时，再次确认是否word对齐，默认当前已经到了采样中心点 word对齐则进入成功完成数据训练状态，word没有对齐就再次进入word对齐状态00110 bitslip一次00111 指示当前通道训练完成，准备切换到下一个通道，重复上述步骤进行训练 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/baf3387fd80ffaed1a924a725eacbca2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d92480dc99e56b58fc06d5e7c8f7797/" rel="bookmark">
			【SQL教程｜01】SQL简介——什么是SQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 什么是SQL SQL是一门语言 SQL是Structured Query Language的简写，中文译为“结构化查询语言”；SQL是一种用来查询和处理关系性数据库的语言，使用SQL我们可以： 增（INSERT）：可以向数据库中插入记录；删（DELETE）：可以删除数据可中的记录；改（UPDATE）：可以更新数据库中的记录；查（SELECT）：可以查询数据库中的数据； 对于数据分析从业者来说，SQL的使用场景主要是查询，各位在学习SQL的过程中也可以优先去学习查询（select）的语法。 SQL是一种标准 SQL是一门用来操作数据库系统的语言，但我们熟知的数据库其实很多种，比如常见的Mysql，Oracle，SQLServer，近几年比较火热的clickhouse，doris DB等等。
不同的数据库系统可以应用不同的使用场景，但这样也就造成了，虽然都是SQL语言，但也会存在很多不同的版本。
但好在现有SQL都会去遵循ANSI 89的标准（ANSI， 美国国家标准化组织），能够保证基本命令（select，from，where，delete，update等等）的用法都是一致的，这也保证了我们数据从业人员在不同数据库系统之间迁移的学习成本不会太高。
当然除了SQL的标准之外，大部分的SQL数据库都会有一些自己的私有函数，比如我们想取数据表中的前5条记录，在不同的数据库中写法是不一样的：
SQLServer中使用TOP SELECT TOP 5 * FROM Persons Mysql在通过LIMIT SELECT * FROM Persons LIMIT 5 Oracle中通过ROWNUM进行过滤 SELECT * FROM Persons WHERE ROWNUM &lt;= 5 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e23e2afc9c38df4c3708b9d014721adb/" rel="bookmark">
			golang中日期操作之日期格式化及日期转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		golang中并没有像java一样提供类似yyyy-MM-dd HH:mm:ss格式的操作，而是将其定义为golang的诞生时间：
2006-01-02 15:04:05 -0700 MST 注意这在golang的日期格式化里不是一个具体日期，而是格式,这样如果我们需要格式化日期，可以如下操作 timeNow := time.Now() fmt.Println("yyyy-MM-dd HH:mm:ss" ,timeNow.Format("2006-01-02 15:04:05")) // 打印： yyyy-MM-dd HH:mm:ss: 2022-05-11 14:24:19 接下来说下Time中的几个方法： Time.Unix() 获取时间秒数，返回的是unix时间秒 fmt.Println("from 1970-01-01 to now seconds: ",int32(time.Now().Unix())) Time.Date() 返回年月日： year,month,day := timeNow.Date() fmt.Println(year,month,day) // 注意打印的是： 2022 May 11 Time.AddDate 时间增减： timeLast := timeNow.AddDate(0,0,-1) fmt.Println(timeLast.Format("2006-01-02 15:04:05")) Time.Add 增加指定的时间，可以精确到纳秒 time2 := timeNow.Add(time.Duration(2000*time.Millisecond)) fmt.Println(time2.Format("2006-01-02 15:04:05")) Time.After 是否在指定时间之后，如果是返回true Time.Before 是否在指定时间之前，如果是返回true time.Parse 按照指定格式将字符串转换为日期： time2,err := time.Parse("2006-01-02 15:04:05","2022-05-11 15:04:05") if err != nil { fmt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e23e2afc9c38df4c3708b9d014721adb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99e605c84c2164afc8f2ebc5ad18b0bb/" rel="bookmark">
			数据库的基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、常用数据类型和约束 1. 数据类型 整数：int，有符号范围（-2147483648 ~ 2147483647），无符号（unsigned）范围（0 ~ 4294967295）
小数：decimal，decimal(5,2)表示5位数，小数占2位，整数占3位
字符串：varchar，范围（0~65533），varchar(3)表示最多存3个字符，一个中文或字母都占一个字符
日期时间：datetime，如 ‘2022-11-24 16:56’
2. 约束 主键（Primay Key）： 唯一性，非空性，能唯一标识表中的每一条记录唯一（unique）：唯一性，可以空，不可以重复非空（not null）：不可以为空默认约束（default）：不填写此值时使用默认值外键约束（foreign key）：一个表中的一个字段引用另一个表的主键 二、数据库的操作 开始使用mysql：mysql -u 用户名 -p
1. 创建 语法格式：
creat database 数据库名 charset=[字符编码] collate=[校验规则];
mysql&gt; create database test_database charset=utf8 collate=utf8_general_ci;
查看创建结果: show create database 数据库名;
2. 使用 语法格式：
打开数据库
use 数据库名;
查看当前使用的数据库
mysql&gt; select database();
3. 修改 语法格式：
alter database [数据库名] default character set 字符集名 default collate 校对规则名
创建testpython数据库，并修改该数据库的字符集和校验规则
mysql&gt; create database testpython charset=gb2312;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99e605c84c2164afc8f2ebc5ad18b0bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8def3b51c716c924e9c345d71141fab2/" rel="bookmark">
			codeblocks 变成这样了怎么恢复成原本的样子。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不知道按错什么了，成这个样子了，有人能帮帮我，真的非常感谢。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8247c669fe7688c47299077e55a58d0b/" rel="bookmark">
			python学生成绩管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python学生成绩管理系统 描述程序源代码 描述 学生成绩管理系统可以实现学生基本信息的管理：主要实现以下功能：
1.输入并存储 信息到文件（包含学生的学号、姓名和分数）；
2.输出学生信息并显示在屏幕上；
3.具有查询功能 判断该学生是否存在，若存在，能实现对该学生的信息进行修改及删除等功能；
4.实现按 学生成绩高低的排序功能；
5.实现查找学生信息功能。
程序源代码 #import pickle import os stulist=[]#新建学生列表存储学生对象 class stu: def __init__(self): self.name="" self.id="" self.score1=0 #语文 self.score2=0 #数学 self.score3=0 #英语 self.sum=0 #总分 def sumscore(self): self.sum=self.score1+self.score2+self.score3 return self.sum def output(self,file_object): file_object.write(self.name) file_object.write(" ") file_object.write(self.id) file_object.write(" ") file_object.write(str(self.score1)) file_object.write(" ") file_object.write(str(self.score2)) file_object.write(" ") file_object.write(str(self.score3)) file_object.write(" ") file_object.write(str(self.sum)) file_object.write("\n") #添加学生信息 def addstu(): student=stu() student.name=input("请输入学生姓名：") student.id=input("请输入学生id：") if(cfindstu(student.id)!=-1): print("该学生已存在，添加失败") return False student.score1=int(input("请输入学生语文成绩：")) student.score2=int(input("请输入学生数学成绩：")) student.score3=int(input("请输入学生英语成绩：")) stulist.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8247c669fe7688c47299077e55a58d0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/954fcb9ce00f9047be20378a87570f0f/" rel="bookmark">
			Kibana配置ES集群（版本号8.3.3）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、解压授权 tar -xzvf kibana-8.3.3-linux-x86_64.tar.gz chown -R elasticsearch101 kibana-8.3.3　二、修改配置文件 cd kibana-8.3.3/config vim kibana.yml # For more configuration options see the configuration guide for Kibana in # https://www.elastic.co/guide/index.html # =================== System: Kibana Server =================== # Kibana is served by a back end server. This setting specifies the port to use. #server.port: 5601 # Specifies the address to which the Kibana server will bind. IP addresses and host names are both valid values.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/954fcb9ce00f9047be20378a87570f0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1b6b8c2626d44dad26c736102da0006/" rel="bookmark">
			【网络教程】Iptables官方教程-学习笔记6-IPTABLES TARGETS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、IPTABLES TAGRETS 本章节介绍Iptables 的目标和跳转(targets and jumps)，目标和跳转负责告诉规则如何处理与规则匹配部分完全匹配的包。“ACCEPT”和“DROP”是一对基础目标，他们是首先处理的。在学习目标是如何完成之前，我们先看下跳转是如何完成的。
跳转跟目标类似，但是跳转是在同一个表的链之间进行跳转。要跳转到一个特定的链，前提是该链已存在。通过“-N”命令创建一个用户定义的链，如下所示：
iptables -N tcp_packets 设置一个跳转目标如下所示：
iptables -A INPUT -p tcp -j tcp_packets 表示我们将从INPUT链跳转到tcp_packets链，并开始遍历tcp_packets链。当我们到达该tcp_packets链的末端，我们就会回到INPUT链，数据包开始从它跳转到另一个链(tcp_packets),按接下来的规则进行遍历。如果一个数据包在一个子链中被接受，它将在超集链中也被接受，并且它将不再遍历任何超集链。但是，请注意，包将以正常方式遍历其他表中的所有其他链。更多信息参考： Traversing of tables and chains【网络教程】IPtables官方教程–学习笔记3 目标(targets)是指要对有问题的包采取的操作。例如，基于我们的需求，我们可以接受或丢弃数据包。跳转到目标的操作可能会导致不同的结果，某些目标可以将导致包停止遍历上面所述的特定链和上级链，比如DROP和ACCEPT。被停止的规则将不会在链中或更高级的链中通过接下来的任一规则。其他目标可能对数据包采取行动，之后数据包将继续通过其余的规则。一个很好的例子是LOG、ULOG和TOS目标。这些目标可以记录数据包，破坏它们，然后将它们传递给同一组链中的其他规则。例如，我们可能希望这样做，以便我们还可以同时破坏特定包/流的TTL和TOS值。一些目标将接受额外的选项(使用什么TOS值等)，而其他目标不一定需要任何选项——但如果我们愿意，我们可以包括它们(日志前缀，伪装到端口等)。
下面就让我们来看看有IPTABLES有哪些目标。
1.1 ACCEPT target 这个目标不需要更多的选项。一旦完全满足数据包的匹配规范，并且指定ACCEPT为目标，则接受该规则，并且不再继续遍历当前链或同一表中的任何其他链。但是请注意，在一个链中接受的数据包仍然可能通过其他表中的链传输，并且仍然可能被丢弃。ACCEPT目标没有任何特别之处，它不需要也不可能向目标添加选项。要使用这个目标，只需指定-j ACCEPT。
注意：适配于Linux 内核2.3, 2.4, 2.5, 2.6
1.2 CLASSIFY target 分类目标可以被用于分类包的方式，可以被一对不同的qdisc(queue disciplines)使用。例如，atm、cbq、dsmark、pfifo_fast、htb和prio qdisc。更多请参考： Linux Advanced Routing and Traffic Control HOW-TO
分类目标仅在mangle表的POSTROUTING 链中有效
Option–set-classExampleiptables -t mangle -A POSTROUTING -p tcp --dport 80 -j CLASSIFY --set-class 20:10ExplanationThe CLASSIFY target only takes one argument, the --set-class.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1b6b8c2626d44dad26c736102da0006/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d26ce7c206b950646101baa27aaf355d/" rel="bookmark">
			Linux环境MySQL数据库主从复制保姆级教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、环境准备1.1、安装MySQL1.2、设置root登录密码 2、主库配置2.1、修改my.cnf2.2、重启数据库2.3、检验设置是否成功2.4、建立主从复制的账号 3、从库配置3.1、配置my.cnf3.2、配置复制参数3.3、查看从库状态 4、测试5、注意事项5.1、接口放行5.2、防火墙关闭5.3、Slave_IO_Running: No 6、总结 1、环境准备 本文主要是针对MySQL数据库做个主从复制测试，环境是Linux（在阿里云领取的免费服务器，可以试用一个月），MySQL数据库的版本我这里是5.7.40
主库IP：120.26.60.94
从库IP：120.27.241.69
1.1、安装MySQL 我这里安装的版本是5.7.40
首先进入opt目录，执行下面命令进行下载：
wget https://dev.mysql.com/get/mysql57-community-release-el7-9.noarch.rpm 然后执行下面命令进行安装：
rpm -ivh mysql57-community-release-el7-9.noarch.rpm 执行完成后会在/etc/yum.repos.d/目录下生成两个repo文件mysql-community.repo mysql-community-source.repo
必须进入到 /etc/yum.repos.d/目录后再执行安装
cd /etc/yum.repos.d/ yum install mysql-server --nogpgcheck //nogpgcheck表示不校验key 下面就表示安装成功了
运行下面命令进行启动：
systemctl start mysqld 设置开机自动启动：
systemctl enable mysqld 其他命令：
# 关闭开机启动 systemctl stop mysqld # 关闭MySQL systemctl stop mysqld # 重启MySQL systemctl restart mysqld 运行下面命令查看MySQL运行状态：
systemctl status mysqld 如下：
1.2、设置root登录密码 那么如何设置root账户的登录密码呢？可按照下面步骤修改root账户密码：
1、进入MySQL数据配置文件进行修改
vi /etc/my.cnf 再按字母【i】进入编辑模式，然后将下面这一行拷贝进去，放到最后一行，含义是免密码登录
skip-grant-tables 然后按【Esc】后再输入【:wq】，表示保存并退出
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d26ce7c206b950646101baa27aaf355d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6860684b16cfa048cd716a6daafce800/" rel="bookmark">
			GIS工具maptalks开发手册(五)02-用JSON载入地图——json格式绘制多个面之全量工具版，包括-shape绘制、disable关闭、clear清空和图层之添加、移除、显示、隐藏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GIS工具maptalks开发手册(五)02-用JSON载入地图——json格式绘制多个面之全量工具版，包括-shape绘制、disable关闭、clear清空和图层之添加、移除、显示、隐藏 效果-json渲染图层-全量工具 代码 页面文件 index.html
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;title&gt;JSON序列化 - 用JSON载入地图&lt;/title&gt; &lt;style type="text/css"&gt; html, body { margin: 0px; height: 100%; width: 100%; } .container { width: 1400px; height: 500px; margin: 50px; } #json { position: fixed; background-color: rgba(13, 13, 13, 0.5); padding: 10px 10px 10px 10px; font: 13px bold sans-serif; color: #fff; left: 0px; top: 0px; width: 100%; height: 85px; overflow: hidden } &lt;/style&gt; &lt;link rel="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6860684b16cfa048cd716a6daafce800/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52ce481fbf1c5f5bb47790ac73d38b1a/" rel="bookmark">
			使用Flink的各种技术实现WordCount逻辑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Flink的各种技术实现WordCount逻辑 在大数据程序中，WordCount程序实现了统计词频的作用，这个WordCount程序也往往在大数据分析处理中一直占着非常重要的地位。统计一天内某网站的访问次数，需要对网站排序后求其词频，统计一段时间内某个用户的登陆次数，也是对网站用户分组后的词频计算.....等等，很多的大数据应用示例都是在WordCount的基础之上进行改良发展，最终实现大数据分析的关键逻辑。
对于wordcount程序来说，基本思想在于输入文件中有每行的英文单词组成的句子，通过行处理的思想，将每个句子的英文单词分割出来，以（单词，1）这种key-value的形式来计数，再通过分组排序，将相同的单词放在一组，最后对每组的单词进行汇总统计。其思想流程图如下图所示。
对于wordcount程序的处理框架，Flink提供了不同级别的编程抽象，通过调用抽象的数据集调用算子构建DataFlow就可以实现对分布式的数据进行流式计算和离线计算，DataSet是批处理的抽象数据集，DataStream是流式计算的抽象数据集，他们的方法都分别为Source、Transformation、Sink
Source主要负责数据的读取 Transformation主要负责对数据的转换操作 Sink负责最终计算好的结果数据输出。 Source读取词频文件的数据，通过Transformation的转换操作将文件中的英文句子切分单词，并分组统计，最终可以Sink到控制台中输出结果。flink的思想结构如下图。
根据这种思想结构，结合不同的Transformation转换函数，常用算子如：
map算子对一个DataStream中的每个元素使用用户自定义的map函数进行处理，每个输入元素对应一个输出元素，最终整个数据流被转换成一个新的DataStream。输入每一个句子，就可以通过map后的函数split空格，然后返回形如(单词,1)的新数据流DataStream。
FlatMap只要处理处理一个输入元素，通过后面的函数可以实现输出一个或者多个输出元素的时候，尤其表现在输出一个元素，如wordcount中输出形如(单词,1)的这种元组类型的元素。就可以用到flatMap()。
reduce方法可以对分组后的元素进行统计处理。
当然， wordcount 也可以结合到不同的情况中。如滑动窗口内的wordcount，就需要结合SlidingWindow。
下面就结合不同情况下使用Flink实现wordCount的词频计算。
一、第一种情况：读取words.txt文件通过flink进行流式分析。 这里需要用到DataStream的Source源DataStreamSource.步骤如下。
1、打开Intellij IDEA，然后点击FIle--&gt;New--&gt;project。
2、打开Project对话框后，左边点击maven，右边不需要点击，只要确认jdk的版本，然后Next进入下一步。
3、在弹出的对话框中，输入groupId和artifactId，然后继续点击Next进入下一步。
4、最后Finish结束配置。
5、在pom.xml中设置dependency的依赖包。
6、建立flink的streaming流式wordcount程序。
注意在敲程序时，设定lambda表达式，方式如下
File -----&gt; Project Structure...
在弹出的对话框中，左边选择Modules，右边选择Lambda表达式8，如下图所示。
最终代码如下。
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment; import org.apache.flink.streaming.api.datastream.DataStreamSource; import org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator; import org.apache.flink.streaming.api.datastream.KeyedStream; import org.apache.flink.api.java.tuple.Tuple2; import org.apache.flink.util.Collector; import org.apache.flink.api.common.typeinfo.Types; public class MyWordCount { public static void main(String[] args) throws Exception { StreamExecutionEnvironment env=StreamExecutionEnvironment.getExecutionEnvironment(); DataStreamSource&lt;String&gt; lineds=env.readTextFile("f://data//words.txt"); SingleOutputStreamOperator&lt;Tuple2&lt;String,Long&gt;&gt; wordstream=lineds.flatMap ((String line, Collector&lt;Tuple2&lt;String,Long&gt;&gt; out)-&gt;{ String[] words=line.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52ce481fbf1c5f5bb47790ac73d38b1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31d6bada41b069f1a3140bf8e246b535/" rel="bookmark">
			MongoDB：update批量更新多条数据multi
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 更新语法
db.collection.update( &lt;query&gt;, &lt;update&gt;, { upsert: &lt;boolean&gt;, multi: &lt;boolean&gt;, writeConcern: &lt;document&gt; } ) 代码示例
// 更新一条数据 &gt;db.col.update({'title':'MongoDB 教程'},{$set:{'title':'MongoDB'}}) // 更新多条数据 &gt;db.col.update({'title':'MongoDB 教程'},{$set:{'title':'MongoDB'}},{multi:true}) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0635145d0e8d58ea83a9d0bd6ce761f5/" rel="bookmark">
			Docker常用命令以及常用服务的安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一. 什么是Docker?二. Docker安装三. Docker常用命令四. Docker常用服务1. mysql服务2. redis服务3. nginx服务 五. Dockerfile使用 一. 什么是Docker? Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows操作系统的机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。
二. Docker安装 下面是一个通用的docker安装命令, 使用aliyun镜像下载
$ curl -fsSL get.docker.com -o get-docker.sh $ sudo sh get-docker.sh --mirror Aliyun 三. Docker常用命令 (1) 配置阿里云加速–拉取镜像时用国内的更快
$ sudo mkdir -p /etc/docker $ sudo tee /etc/docker/daemon.json &lt;&lt;-'EOF' { "registry-mirrors": ["https://lz2nib3q.mirror.aliyuncs.com"] // 自己的镜像加速链接 } EOF $ sudo systemctl daemon-reload $ sudo systemctl restart docker (2) 启动docker
$ sudo systemctl enable docker $ sudo systemctl start docker (3) 镜像相关命令
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0635145d0e8d58ea83a9d0bd6ce761f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51b8fa96eb19edf9fb7715ea3e155dae/" rel="bookmark">
			HClA初步认识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HCIA,HCIP,HCLE分别对应华为认证体系下的工程师等级。
我们学习软件代码，首先要理解什么是计算机网络，而计算机网络指的是数据组成数据包，在各个网络结点中不断传递，最终报道目标的包交换通信方式，然后运用计算机为载体，进行信息收集，发布，存储，处理和应用，最终运用通信技术和计算机技术来实现资源的共享，让更多的人可以获得信息，软件，硬件的资源。
云存储，云计算分别运用在百度网盘和分布式计算当中，他们都是属于云技术。
文字，图片都是属于抽象的语言，他们都是通过电信信号来进行传播，电信号则是通过CPU进行处理，抽象语言通过编码在应用层中体现，编码通过二进制中的0和1在表示层体现，二进制通过传输电信号在介质访问控制层中发生，最后处理信号到达物理。
通信技术的发展最早可以追溯到1946年2月14日的第一台电子计算机的出现。1876年——贝尔发明电话专利——公共交换电话网——电路交换——1880年。而现在的互联网是通过以前的阿帕网发展而来的。最早期的计算机网络是通过对等网，然后再进行扩大，最后扩大到互联网的规模。
我们想要扩大物联网的规模，可以从增加节点数和延长传输距离下手。从理论上来说，增加传输距离更加容易。
延长传输距离就需要更多的网线，成本更高。双绞线分为屏蔽和非屏蔽。网线分为RJ-45双绞线和超五类双绞线。RJ-45双绞线是有八根铜丝构成，超五类双绞线在100m左右，信号开始衰弱。
光纤---光信号---光导纤维
电--光---发光二极管，注入式激光二极管
光--电---光电二极管
单模--注入式激光二极管---信号畸变小
多模--发光二极管
增加节点数，首先要了解网络拓扑的结构，网络拓扑的结构分为直线型拓扑，环形拓扑，星型拓扑，网状拓扑，混合型多环形拓扑，其中网状拓扑结构复杂，维护成本高，但是某一点出错对其影响不大。星型拓扑是性价比最高的拓扑结构。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fc7d1cce909417abcbfc832768ce3dd/" rel="bookmark">
			【Linux安全管理】iptables配置与iptables基本用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、服务的启动与关闭命令
二、iptables介绍
1、防火墙分类
2、iptables的启动
① 在开机时禁用firewalld服务：
②安装iptables-services
③将它设置为开机自启
3、iptables 四表五链详解
链
表
表和链的关系​编辑
不是所有的表都附着在同一条链上​编辑
4、iptables基本用法
匹配条件 处理动作
iptables常用的选项​编辑
iptables常用规则匹配​编辑
iptables配置
基本匹配条件总结
扩展匹配条件总结
(补充)selinux
1、工作模式
2、如何禁用
一、服务的启动与关闭命令 启动服务：systemctl start service关闭服务：systemctl stop service重启服务：systemctl restart service显示服务的状态：systemctl status service在开机时启用服务：systemctl enable service在开机时禁用服务：systemctl disable service查看服务是否开机启动：systemctl is-enabled service查看已启动的服务列表：systemctl list-unit-files|grep enabled查看启动失败的服务列表：systemctl --failed 二、iptables介绍 1、防火墙分类 ①从逻辑上
②从物理上
iptables 并不是真正意义上的防火墙，我们可以理解为一个客户端工具，用户通过 ipatbles 这个客户端，将用户的安全设定执行到对应的"安全框架”中，这个"安全框架"才是真正的防火墙，这个框架的名字叫 netfilter .iptables 是一个命令行工具，位于用户空间，通过这个命令行工具来操作 netfilter 。
netfilter 才是防火墙真正的安全框架， netfilter 位于内核空间。
netfilter / iptables （简称为 iptables ）组成 Linux 平台下的包过滤防火墙，与大多数的 Linux 软件一样，这个包过滤防火墙是免费的，它可以代替昂贵的商业防火墙解决方案，完成封包过滤、封包重定向和网络地址转换（ NAT )等功能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fc7d1cce909417abcbfc832768ce3dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84ecc92a237b9a90ed56c548b88a7bb3/" rel="bookmark">
			vue使用video.js实现播放m3u8格式的视频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装video.js npm install video.js 我使用的video.js版本如下：
"video.js": "^7.20.3" 二、VideoPlayer组件 在components下新建一个VideoPlayer文件夹
index如下：
&lt;template&gt; &lt;div ref="videoDiv"&gt;&lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: "VideoPlayer", data() { return { player: null, }; }, props: { sourceUrl: { type: String, default: "", }, }, mounted() { this.initVideo(); }, watch: { sourceUrl: { handler(val) { this.initVideo(); }, }, }, methods: { initVideo() { // video标签无法动态加载src，所以在vue中如果是动态写入视频地址，js加载在HTML渲染之后，会导致video在取src时无法解析。 // 所以需要用js在获取到src值之后生成HTML元素 this.$refs.videoDiv.innerHTML = '&lt;video class="video-js vjs-default-skin vjs-big-play-centered"&gt;' + "&lt;/video&gt;"; this.player = this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84ecc92a237b9a90ed56c548b88a7bb3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24bee6444dc3f0cbae0060f3ebb8ceea/" rel="bookmark">
			vue3使用Vite打包报Rollup failed to resolve import “xxx/node_modules/ant-design-vue/xxxx
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用vue3 + vite + ant design vue 的时候，引入一些antd的一些组件的时候，通常运行是没有错的，但是打包会报错，例如：
Rollup failed to resolve import "D:/xxxxx/node_modules/ant-design-vue/es/form-item-rest/style/index" from "src/views/xxx/xxx.vue". 15:01:51 This is most likely unintended because it can break your application at runtime. If you do want to externalize this module explicitly add it to build.rollupOptions.external 报关于 ant design vue的一些组件错误，
解决：
&lt;template&gt; &lt;FormItemRest&gt; &lt;a-input v-moal:value='val' /&gt; &lt;/FormItemRest&gt; &lt;/template&gt; &lt;script lang='ts' setup&gt; import { ref } from 'vue'; import { Form } from 'ant-design-vue'; const FormItemRest = Form.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24bee6444dc3f0cbae0060f3ebb8ceea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3053a6c7dcb0b5ac3e538d354d95362/" rel="bookmark">
			【VUE2】VUE2基础知识和原理--超详细--超简介--零基础（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue基础知识和原理 1 初识Vue 想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象demo容器里的代码依然符合html规范，只不过混入了一些特殊的Vue语法demo容器里的代码被称为【Vue模板】Vue实例和容器是一一对应的真实开发中只有一个Vue实例，并且会配合着组件一起使用{{xxx}}是Vue的语法：插值表达式，{{xxx}}可以读取到data中的所有属性一旦data中的数据发生改变，那么页面中用到该数据的地方也会自动更新(Vue实现的响应式) &lt;!-- 准备好一个容器 --&gt; &lt;div id="demo"&gt; &lt;h1&gt;Hello，{{name.toUpperCase()}}，{{address}}&lt;/h1&gt; &lt;/div&gt; &lt;script type="text/javascript" &gt; Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。 //创建Vue实例 new Vue({ el:'#demo', //el用于指定当前Vue实例为哪个容器服务，值通常为css选择器字符串。 data:{ //data中用于存储数据，数据供el所指定的容器去使用，值我们暂时先写成一个对象。 name:'hello,world', address:'北京' } }); &lt;/script&gt; 2 模板语法 Vue模板语法有2大类:
插值语法：
功能：用于解析标签体内容
写法：{{xxx}}，xxx是js表达式，且可以直接读取到data中的所有属性
指令语法:
功能：用于解析标签（包括：标签属性、标签体内容、绑定事件…）
举例：v-bind:href=“xxx” 或 简写为 :href=“xxx”，xxx同样要写js表达式，且可以直接读取到data中的所有属性
&lt;div id="root"&gt; &lt;h1&gt;插值语法&lt;/h1&gt; &lt;h3&gt;你好，{{name}}&lt;/h3&gt; &lt;hr/&gt; &lt;h1&gt;指令语法&lt;/h1&gt; &lt;!-- 这里是展示被Vue指令绑定的属性，引号内写的是js表达式 --&gt; &lt;a :href="school.url.toUpperCase()" x="hello"&gt;点我去{{school.name}}学习1&lt;/a&gt; &lt;a :href="school.url" x="hello"&gt;点我去{{school.name}}学习2&lt;/a&gt; &lt;/div&gt; &lt;script&gt; new Vue({ el:'#root', data:{ name:'jack', school:{ name:'百度', url:'http://www.baidu.com', } } }) &lt;/script&gt; 3 数据绑定 Vue中有2种数据绑定的方式：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3053a6c7dcb0b5ac3e538d354d95362/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58819f4fc14bc751ddac618f231bfd70/" rel="bookmark">
			[PTA]删除字符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		void delchar( char *str, char c ){
char *a=str;
for(;*str;str++)if(*str!=c)*a++=*str;
*a=0;
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cf366e3140a262b8d4441005c24e1be/" rel="bookmark">
			关于我对线程安全问题中死锁的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.什么是死锁2.三个典型情况3.可重入与不可重入4.死锁的四个必要条件5.如何破除死锁 1.什么是死锁 比如张三谈了一个女朋友，张三就对这个女朋友加锁了。
此时李四也看上了这个女生，但是他只能等待张三分手（解锁）后，才能和这个女生谈恋爱。
李四为了等待这个女生，错过了好多喜欢他的人，这里就相当于线程无法执行的后续工作，
此时就相当于是死锁了。
一旦程序出现死锁，就会导致线程无法执行后序工作了，此时程序必然会有严重的 bug 。
发生死锁的概率又是随机的，因此死锁是非常隐蔽，不容易被发现的。
2.三个典型情况 情况1：
一个线程如果有一把锁，连续加锁两次。如果这个锁是不可重入锁，就会死锁。
java 中的 synchronized 和 ReentrantLock 都是可重入锁，
因此这一种情况演示不了。
情况2：
两个线程两把锁，t1 和 t2 各自先针对 锁1 和 锁2 加锁，之后再尝试获取对方的锁。
比如说，张三的车钥匙锁在屋里了，而屋子的钥匙锁在车了。
这个时候屋子和车都进不去了，就会产生问题。
下面来举例说明。
package thread; public class ThreadDemo16 { public static void main(String[] args) { Object locker1 = new Object(); Object locker2 = new Object(); Thread t1 = new Thread(() -&gt; { synchronized (locker1) { try { Thread.sleep(500); } catch (InterruptedException e) { e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8cf366e3140a262b8d4441005c24e1be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ac2ce5456550ac950243f5d895849e5/" rel="bookmark">
			洛谷P5705 题解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 洛谷P5705 题解 传送门
题意 反转输入的数
分析 这题使用STL库中的string会简单得多
本题只用到一个函数：length()
用于获取字符串长度
代码 #include &lt;iostream&gt; #include &lt;string&gt; //string的头文件 using namespace std; //标准命名空间 int main() //进入主函数 { string a; //定义变量 cin &gt;&gt; a; //使用cin进行输入 for(int i=a.length()-1;i&gt;=0;i--) { cout &lt;&lt; a[i]; //倒序输出 } return 0; } 注意事项 length()别漏写括号string类型的字符串是从下标0开始的，需注意 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9d810a45e2f042b3bb20b3665afce40/" rel="bookmark">
			嵌入式Linux 调试常用工具与知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常用工具 Linux端查看.a/.so库文件信息，包含架构等等 readelf -h XXX.a 2. 静态库(.a) 与 动态库(.so) 的详解
3. 交叉编译指定安装路径，设置交叉编译器
4. 编译动态库与静态库
5. Linux列出当前路径下指定后缀的文件
#result为重定向输出 find ${PWD} -name '*.c' &gt; result 引用静态库时说找不到库中的函数，但用nm能看到那个函数？ 考虑是不是C++和C混合使用了如果使用了cmake，依赖顺序很重要，被依赖的要放在右边 参考：linux下程序链接多个静态库，提示找不到函数链接的问题。
7. cmake /start.S:86：对‘main’未定义的引用
考虑依赖顺序的问题，把控制台的日志再往前翻一翻，看哪里出错了
C文件 CMakeList.txt编译器配置错误的问题 error:invalid conversion from ‘int’ to ‘LAYER_TYPE’ [-fpermissive]…海思自己重新实现了securec，所以在hilinux系统中可以使用snprintf_s，memcpy_s这些，但是要特别注意cmake链接的时候要把被依赖的放在最右边。cmake target_link_libraries 链接库顺序linux – 管道符“|”创建软连接Linux chmod命令 Linux C atoi与sprintf可以反着用，sprintf为格式化输入到指定char数组，snprintf可以防患于未然（给定空间）fseek和ftell结合可以计算文件长度rewind等价于： (void)fseek(stream,0L,SEEK_SET) 用fseek产生文件空洞，可用于占用磁盘fflush缓冲区 缓冲区的作用：大多数情况下是好事，可用来合并系统调用。
分为
行缓冲：换行时候刷，满了的时候刷，强制刷新（标准输出是这样）
全缓冲：满了的时候刷，只要不是终端设备（标准输出为终端设备）
无缓冲：stderr，需要立即输出的内容
fseeko
可移植性不好
没有单位的数值没有意义。如果想要长整型，记得在数字后加L，然后再参与运算。文件类型：dcb-lsp
考虑用int接收charumask
Linux中目录的粘贴位（t位） ——《Unix环境高级编程》
如果对一个目录设置了粘着位，只有对该目录具有写权限的用户并且满足下列条件之一，才能删除或重命名该目录下的文件：
•拥有此文件；
•拥有此目录；
•是超级用户。
目录/tmp 和/var/tmp 是设置粘着位的典型候选者—任何用户都可在这两个目录中创建文件。任一用户（用户、组和其他）对这两个目录的权限通常都是读、写和执行。但是用户不应能删除或重命名属于其他人的文件，为此在这两个目录的文件模式中都设置了粘着位。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f50186adb8ddb3b9890546d4975d53f/" rel="bookmark">
			kafka 日志清除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		日志删除 Kafka 日志管理器中会有一个专门的日志删除任务来周期性检测和删除不符合保留条件的日志分段文件，这个周期可以通过 broker 端参数log.retention.check.interval.ms 来配置，默认值为 300,000，即5分钟。当前日志分段的保留策略有3种：基于时间的保留策略、基于日志大小的保留策略以及基于日志起始偏移量的保留策略。
基于时间 kafka segment
查找过期的日志分段文件，并不是简单地根据日志分段的最近修改时间lastModifiedTime 来计算，而是根据日志分段中最大的时间戳largestTimeStamp 来计算。因为日志分段的 lastModifiedTime 可以被有意或者无意的修改，比如执行了 touch 操作，或者分区副本进行了重新分配，lastModifiedTime 并不能真实地反映出日志分段在磁盘的保留时间。要获取日志分段中的最大时间戳 largestTimeStamp 的值，首先要查询该日志分段所对应的时间戳索引文件，查找时间戳索引文件中最后一条索引项，若最后一条索引项的时间戳字段值大于0，则取其值，否则才设置为最近修改时间 lastModifiedTime。
root@kafka-1:/opt/kafka/data/logs/v2xRTData-0# kafka-dump-log --files /opt/kafka/data/logs/v2xRTData-0/00000000000005357795.timeindex ... timestamp: 1669782936152 offset: 5366863 timestamp: 1669782937050 offset: 5366872 timestamp: 1669782937954 offset: 5366881 timestamp: 1669782938850 offset: 5366890 timestamp: 1669782939752 offset: 5366899 timestamp: 1669782940648 offset: 5366908 若待删除的日志分段（阴影部分）的总数等于该日志文件中所有的日志分段的数量，那么说明所有的日志分段都已过期，但是该日志文件中还要有一个日志分段来用于接收消息的写入，即必须要保证有一个活跃的日志分段 activeSegment，在此种情况下，会先切分出一个新的日志分段作为 activeSegment，然后再执行删除操作。
删除日志分段时，首先会从日志文件对象中所维护日志分段的跳跃表中移除待删除的日志分段，以保证没有线程对这些日志分段进行读取操作。然后将日志分段文件添加上 .deleted 的后缀，当然也包括日志分段对应的索引文件。最后交由一个以 delete-file 命名的延迟任务来删除这些 .deleted 为后缀的文件，这个任务的延迟执行时间可以通过 file.delete.delay.ms参数来设置，默认值为 60000，即1分钟。
基于日志大小 日志删除任务会检查当前日志的大小是否超过设定的阈值 retentionSize 来寻找可删除的日志分段的文件集合 deletableSegments，参考下图所示。retentionSize 可以通过 broker 端参数 log.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f50186adb8ddb3b9890546d4975d53f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d7427f08deae6174c7eb413dc210688/" rel="bookmark">
			【JUC】循环屏障CyclicBarrier详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 jdk中提供了许多的并发工具类，大家可能比较熟悉的有CountDownLatch，主要用来阻塞一个线程运行，直到其他线程运行完毕。而jdk还有一个功能类似并发工具类CyclicBarrier，你知道它的作用吗？和CountDownLatch有什么区别呢？
对于CountDownLatch不了解的可以参考# CountDownLatch源码硬核解析
介绍和使用 CyclicBarrier，循环屏障，用来进行线程协作，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，会触发自己运行，运行完后，屏障又会开门，所有被屏障拦截的线程又可以继续运行。所以CyclicBarrier 是可以重用的。
为了更好的理解，我们举个例子，如下图所示：
我们将屏障想成栅栏，5个线程想成5头猪。5头猪开始往前跑，直到都跑到栅栏前，栅栏开始做个自己的任务，比如看看猪多重。然后打开栅栏，猪又会继续跑，跑到下一个栅栏，就这样循环....
API介绍 构造方法
public CyclicBarrier(int parties): 创建parties个线程任务的循环CyclicBarrierpublic CyclicBarrier(int parties, Runnable barrierAction)： 当parties个线程到到屏障出，自己执行任务barrierAction 常用API
int await()：线程调用 await 方法通知 CyclicBarrier 本线程已经到达屏障 基本使用 我们将上面猪猪的例子通过CyclicBarrier简单做一个实现。
@Slf4j(topic = "c.CyclicBarrierPig") public class CyclicBarrierPig { public static void main(String[] args) { ExecutorService service = Executors.newFixedThreadPool(5); CyclicBarrier barrier = new CyclicBarrier(5, () -&gt; { System.out.println("主人看看哪个猪跑最快，最肥..."); }); // 循环跑3次 for (int i = 0; i &lt; 3; i++) { // 5条猪开始跑 for(int j = 0; j&lt;5; j++) { int finalJ = j; service.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d7427f08deae6174c7eb413dc210688/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0daf0425bbbf19b5b8c2b55074954c75/" rel="bookmark">
			vmware如何设置中文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://jingyan.baidu.com/article/b907e627cd7dcf07e6891c18.html
在电脑桌面上，用鼠标右键点击vmware的快捷图标。
在右键菜单中，点击“属性”。
在属性窗口里，点击“快捷方式”选项卡。
“快捷方式”选项卡下，在“目标”右边的输入框中的字符后面添加： --locale zh_CN，“--”前面有空格。
点击“确定”按钮。
设置完成后，双击快捷图标打开vmware软件，即可看到软件界面已更换为中文界面。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15183063ca990469e2643345f813c277/" rel="bookmark">
			计算机通信与网络（原书第7版）自顶向下答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		链接如下：
答案（全）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a70bde27cdd7462ee69c9c6d96542420/" rel="bookmark">
			64个热门图像分类数据集免费、高速资源分享，涵盖通用视觉、食物、艺术、医疗等多种场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小伙伴们期待已久的数据集资源盘点系列又来啦~
本期将分享64个图像分类任务相关的热门公开数据集资源，粗略分了10类：
● 通用视觉类；● 手写体&amp;单通道类；● 细粒度图像识别类；● 自然界图像和场景类；● 遥感类；● 医疗健康类；● 科学教育类；● 艺术类；● 食物类；● 生活场景类。
快来看看有没有你想要的吧。
如果觉得不错的话，记得收藏。更多资源，欢迎访问OpenDataLab官网：https://opendatalab.org.cn/
目录
一、通用视觉类
No.1 CIFAR-10
No.2 CIFAR-100
No.3 STL-10
No.4 PASCAL VOC2007
No.5 PASCAL VOC2012
No.6 ImageNet-P
No.7 ImageNet-Sketch
No.8 ObjectNet
No.9 Open Images V4
No.10 ImageNet-21k
No.11 ImageNet-O
No.12 DEIC Benchmark (Data-Efficient Image Classification Benchmark)
No.13 OmniBenchmark
No.14 Caltech-256
No.15 CIFAR-10N (Real-World Human Annotations)
No.16 CIFAR-100N (Real-World Human Annotations)
二、手写体&amp;单通道类
No.17 MNIST
No.18 Fashion-MNIST
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a70bde27cdd7462ee69c9c6d96542420/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccc15f3fe8f8c7345abf257ff3e2752e/" rel="bookmark">
			银河麒麟高级服务器操作系统V10 SP2安装tomcat 8.5.31
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		银河麒麟高级服务器操作系统V10 SP2安装tomcat 8.5.31
在/soft/目录下载 apache-tomcat-8.5.31.tar.gz安装包
[root@KylinV10001 soft]# wget http://192.168.10.101/soft/apache-tomcat-8.5.31.tar.gz [root@KylinV10001 soft]# tar -zxvf apache-tomcat-8.5.31.tar.gz 将软件包移动到 /usr/local/softwork/并改名为tomcat8.5.31
[root@KylinV10001 soft]# mv apache-tomcat-8.5.31/ /usr/local/softwork/tomcat8.5.31 为Tomcat8.5.31下脚本文件添加执行权限
[root@KylinV10001 softwork]# chmod +x tomcat8.5.31/bin/*.sh 修改Tomcat默认端口号为80。 Tomcat默认端口号为8080。
[root@KylinV10001 conf]# sed -i 's/Connector port="8080"/Connector port="80"/' /usr/local/softwork/tomcat8.5.31/conf/server.xml 或者用vim编辑server.xml中修改端口。
防火墙设置放行80端口
[root@KylinV10001 conf]# firewall-cmd --zone=public --add-port=80/tcp --permanent 更新防火墙规则
[root@KylinV10001 conf]# firewall-cmd --reload 查看下public区域下所有已打开的端口
[root@KylinV10001 conf]# firewall-cmd --zone=public --list-ports 至此，配置已经结束。下面开始启动tomcat
[root@KylinV10001 conf]#cd /usr/local/tomcat8.5.31/bin [root@KylinV10001 bin]#./startup.sh 至此，tomcat搭建、启动完成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ab21b6458fabc053f41f9a8de7c3e15/" rel="bookmark">
			趁热打铁，再构建百万节点关系中药方剂知识图谱
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		趁热打铁，再构建百万节点关系中药方剂知识图谱 前文自顶向下构建中药知识图谱初探中，已经介绍了知识图谱和中药知识图谱构建的相关基础概念，本文将研究中药方剂数据，趁热打铁，再构建百万节点关系中药方剂知识图谱。该图谱能够让中医药知识图谱更加完善与全面。详细内容请看全文。
本文目录 趁热打铁，再构建百万节点关系中药方剂知识图谱1、中药方剂2、构建中药方剂知识图谱2.1 中药方剂实体与关系定义2.2 方剂数据获取与分析2.3 构建中药方剂知识图谱 3、中药方剂知识图谱数据展示4、问题发现4.1 节点关系定义问题4.2 知识融合问题 5、总结 1、中药方剂 每味中药都有自己的功效特色，古人很早就使用单味药物治疗疾病，但是在漫长的实践过程中发现合理应用中药配伍，能够起到事半功倍的良好效果。方剂学是研究中医方剂组成、变化和临床运用规律的一门学科，是中医学的主要基础学科之一，方剂学的内容包括方剂的组成原则、药物的配伍规律、方剂的组成变化、剂型及方剂的用法等。
本文将基于收集的方剂数据，利用自然语言处理技术构建中药方剂知识图谱，并分析中药处方中的一些数据规律。
2、构建中药方剂知识图谱 2.1 中药方剂实体与关系定义 本文主要从中药方剂处方组成和功能主治的角度抽取相关信息，构建知识图谱。具体实体和关系描述如下：
实体定义：方剂（root节点）、方名、来源、别名、处方、中药名、剂量、功能主治。
关系定义：&lt;方剂, include, 方名&gt;、&lt;方名， from, 来源&gt;、&lt;方名， another name, 别名&gt;、&lt;方名, prescription type, 处方_id&gt;、&lt;处方_id, composition, 中药名&gt;、&lt;中药名, dose, 剂量&gt;和&lt;处方_id, functions, 功能主治&gt;。
prescription type关系说明：由于历代诸多医家的研究与发展，方剂存在同名的情况，因此prescription type关系的尾节点利用“处方_id”标识同名的多个处方。如：“当归散”有207个处方，“白术散”有170个处方，“羚羊角散”有169个处方。
说明：该实体和关系的定义旨在学习知识图谱在中医药数据中的应用与处理，仅限自己初步研究，具体应用需根据实际情况调整。
另外，组成方剂的药物可按其在方剂中所起的作用分为君、臣、佐、使；组方存在十八反和十九畏关系；中药有四气五味性状等。因此，后续可在已有方剂知识图谱基础上，继续对方剂数据进行融合处理，构建完善最终的中药方剂知识图谱
2.2 方剂数据获取与分析 本文将基于收集的2.5w组共计5.2w个中药处方数据，主要利用规则和词典抽取2.1节中描述的实体关系三元组，构建中药方剂知识图谱。
方剂与处方个数简单分析结果：
（1）单个处方的方剂共计19023组，占比76.1%；含有2个或3个处方的方剂共计3896组，占比15.6；含有4-10个处方的方剂共计1355组，占比5.4%；含有11-30个处方的方剂共计446个，占比1.8%。
（2）含有处方个数最多的10个方剂名分别是：当归散、白术散、羚羊角散、槟榔散、黄耆散、黄耆汤、黄连散、柴胡散、茯苓汤和当归汤。
（3）含有“当归散”的方名有21组，具体图谱如图1所示。
图1 含有“当归散”的方名图谱 处方与用药数量简单分析结果：
（1）5.2万个处方中10味以内的处方有40596个，占比78.1%，含有11-15味中药的处方共计8217个，占比15.8%。可见，有人说中药处方用药超过10味大多是胡扯的论断也有一定道理，哈哈哈。不过需要说明的是中药处方与病情发展和医生经验密切相关，不可呆板照搬经典，一尘不变的开方治病。
（2）用药数量最多的方剂是“金仙膏”，一个处方有109味中药，另一个处方有108味中药。两个“金仙膏”的处方图谱如图2所示。
图2 两个“金仙膏”的处方图谱 两个“金仙膏”的功能主治图谱如图3所示。
图3 两个“金仙膏”的功能主治图谱 感兴趣的可以分析对比这两个处方。
2.3 构建中药方剂知识图谱 本文通过py2neo将数据存入neo4j数据库，并进行可视化展示。
demo如下：
import json from py2neo import Graph, Node, Relationship def generateGraph_Node(graph, label, name): "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ab21b6458fabc053f41f9a8de7c3e15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a1b7b8561460d25e3e553df8521aa55/" rel="bookmark">
			C&#43;&#43;中istream_iterator和ostream_iterator的源码分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 概述istream_iterator源码分析使用方法 ostream_iterator源码使用方法 疑问为什么重载后置++会有一个int型参数为何前置++效率要比后置++效率要高返回类型不同形参不同代码实现不同 概述 在一篇博客当中无意间发现了istream_iterator和iostream_iterator的使用，感觉用法很神奇，就专门去研究了一下，觉得还挺有意思的，所以就专门写了一篇博客来聊聊这两个迭代器的实现,一下为gnu2.9版本的源码。
istream_iterator源码 template &lt;class T, class Distance = ptrdiff_t&gt; class istream_iterator { friend bool operator== __STL_NULL_TMPL_ARGS (const istream_iterator&lt;T, Distance&gt;&amp; x, const istream_iterator&lt;T, Distance&gt;&amp; y); protected: istream* stream; T value; bool end_marker; //判断是否读入结束符，比如C语言中的EOF等等 void read() { //其中调用的读取函数 end_marker = (*stream) ? true : false; if (end_marker) *stream &gt;&gt; value; //读入value，若读入信息与类型不符，会将value置为0 end_marker = (*stream) ? true : false; //判断上一步&gt;&gt;读取是否成功 } public: typedef input_iterator_tag iterator_category; typedef T value_type; typedef Distance difference_type; typedef const T* pointer; typedef const T&amp; reference; istream_iterator() : stream(&amp;cin), end_marker(false) {} //默认构造函数，不会触发输入操作 istream_iterator(istream&amp; s) : stream(&amp;s) { read(); } //这种构造函数，后面就紧跟着读取一个数据 reference operator*() const { return value; } //返回value的引用 #ifndef __SGI_STL_NO_ARROW_OPERATOR pointer operator-&gt;() const { return &amp;(operator*()); } //返回value的地址,前置++ #endif /* __SGI_STL_NO_ARROW_OPERATOR */ istream_iterator&lt;T, Distance&gt;&amp; operator++() { //重点重载operator++ read(); //不会创建新类 return *this; } istream_iterator&lt;T, Distance&gt; operator++(int) { //将operator++重载为输入操作，后置++ istream_iterator&lt;T, Distance&gt; tmp = *this; //会创建一个的istream_iterator来保存读入前的iterator read(); //从流读入后，返回存有读入前数据的istream_iterator return tmp; } }; 分析 std::istream_iterator是单程输入迭代器T，通过调用适当的operator&gt;&gt;.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a1b7b8561460d25e3e553df8521aa55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5c996e58d6f34e8043af6a82c5d3183/" rel="bookmark">
			★深度优先搜索&#43;解空间树&#43;递归，三合一详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么这三个内容要放在一起讲？
如果单独分开讲那么 递归 和 深度优先搜索 这两个内容就会变得及其抽象，不适合新手入门
首先明确这三个内容的定义，由于深搜和递归过于抽象先说解空间树。
一、什么是解空间树？
解空间树是用树的结构来表达一个问题的解空间。（解空间就是这个问题的所有解。无论对错，包含所有情况）
以背包问题举例
你眼前有1，2，3三个物品，每个物品最多装 1 次，问你背包的不同情况有哪些。
随便想想的话，可以把1放进去，这是一种情况，1和2放进去，这又是一种情况，这样很容易考虑不全。
那么我们尝试以树的结构来描述出这个问题的所有解。
每个物品都只有 取 或者 不取 两种情况，所以易得下图
那么从根节点随便取一条路径开始走到底，就会成为这个解空间树的一个可能解，如果这个解是正确的，那么就是最优解。 再换一个问题
你眼前现在有一个方格纸，里面有很多个小方格，每个方格可以涂 红 黄 蓝 三种颜色，涂满这个方格纸，有多少种不同的方案。
画出解空间树，假设一共有n个方格，由每个格子有三种情况得出下图
太多了就不画完了，当1号格子涂蓝，2号可以是任意一个；当1号格子涂黄，2号可以是任意一个，从根节点走到底的任意一条路径，那么就是一个解。 基本上就是这么个意思，用树来表达出解空间就可以。
二、什么是深度优先搜索（Deep-First-Search）？
取英文开头缩写即，DFS或者dfs，被众多神犇们戏称为大法师（dfs）或者 暴力算法
深度优先搜索是由两块部分组成的，即 深度优先 - 搜索。
深度优先就是以深度为优先。搜索就是在所给的数据中，搜索出解。
体现在解空间树中就是，每一步都要往下走一层，深度优先√
搜索就是走到底，找出一个解√
显而易见，深度优先不能100%保证能找出最优解，很可能会找出一大堆错的之后才找到对的那个，路径这么多那是必然的。
三、什么是递归?
递归就是调用自己。
这样是调用别的函数，如果变成下面这样，调用自己就称为递归
明确了三个部分的定义之后就可以开始研究高深莫测的内容了
一、高深莫测的递归
这个分段函数的意思就是，x=1的时候，f(1)=1，x&gt;1的时候，f(x)=f(x-1).....多嘴了
把这个函数写成代码就是
int f(int x){ if(x==1)return 1; else return f(x-1); } 这就是递归喽。
因为有电脑，所以我们并不需要一步一步去算f(x)=f(x-1)=f(x-2).......=f(1)=1，虽然显而易见答案都是1，如果你能确保你的函数每一个都能推出正确解，那么电脑就会帮你自动算出来。
引用wiki的一句话：明白一个函数的作用并相信它能完成这个任务，千万不要跳进这个函数里面企图探究更多细节， 否则就会陷入无穷的细节无法自拔，人脑能压几个栈啊。递归 &amp; 分治 - OI Wiki
这句话并不抽象（如果用解空间树的话），比如上面那个方格涂色，你知道每个方格都能涂三种颜色，那就开始思考！第一个涂红的时候 第二个涂红 黄 蓝，第一个涂黄的时候，第二个涂红 黄 蓝 @&amp;*@#&amp;*，你记得住吗？反正我记不住
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5c996e58d6f34e8043af6a82c5d3183/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac9ffc8e239eb070484e08d80d9f57d3/" rel="bookmark">
			word编号技巧：如何将手动编号批量转为自动编号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​我们在制作Word文档的时候，总有需要编号的内容，但是，许多同学常会使用手动编号。不仅费劲，而且容易出错。一旦需要删除或者添加内容，就等于所有编号需要重新更改一遍，那酸爽，我相信经历过的人都懂。
案例一
如果文档中的编号内容不多，且是连续的，我们可以先把鼠标光标放到第 2 个段落的结尾处，按 Enter 键，新起的一个段落。此时，如果文档中没有产生编号，说明我们现在的编号是手动编号，那么我们需要将其转化成自动编号。
操作方法：单击【开始】-【段落】-【编号】按钮右侧的下拉按钮，在弹出的下拉列表中选择需要的编号样式即可。这样以后再使用编号就不用再手动输入了，按下 Enter 键就能自动编号了。
案例二
在实际应用过程中，我们经常会碰到一些不连续的编号问题，如下图所示。
每题及各个编号之间被A、B、C的答案分割了。这种情况下，如果直接选中文本，单击【开始】-【段落】-【编号】按钮，应用编号样式，那么，格式会出错，如下图所示。
所以，我们不能直接应用编号样式。需要通过“查找和替换”功能来实现手动编号转为自动编号，下面请看具体操作方法：
（1）按Ctrl+A键选中所有文本，首先清除格式，点击【开始】-【字体】组中的“清除所有格式”按钮。
（2）按Ctrl+H键打开“查找和替换”对话框，在“查找内容”中输入【&lt;[0123456789]@】，勾选【通配符】，并点击“在以下项查找”，选择【主文档】，此时，可看到文档中所有手动录入的数字编号已被选中。
（3）单击【开始】-【段落】-【编号】按钮，应用自动编号即可，效果如下图所示。
代码解析：“&lt;”表示单词开头；“[0123456789]”表示在此范围内查找；“@”表示重复前一个或者多个，这样就能满足找到所有开头为数字的编号了。
就这么简单，文档中所有的手动编号全部替换成自动编号啦！以后，若要调整编号，编号将会自动更新，不再一一手动更改了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5eac5fda7d2381472dad29fa66e8df8/" rel="bookmark">
			Centos Stream 8虚拟机搭建单节点OpenStack
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Centos Stream 8虚拟机搭建单节点OpenStack 注意 1、在实际搭建过程中，一定要注意自己的文件路径！ 2、centos stream 8虚拟机为最小化安装，该系统似乎没有自带的python，这与centos7相比，省去很多麻烦。 3、官方文档是建立一个python虚拟环境，在虚拟环境中部署OpenStack。但是尝试多次，在web验证阶段，始终失败，不知道是网络设置的原因，还是中间部署过程出现错误的原因，始终失败，因此选择不创建python虚拟环境的情况下进行部署。 4、本次安装的是OpenStack yoga版本。 参考文献 325.【openstack】kolla 搭建 openstack 单机版云环境
kolla-ansible虚拟机单节点部署OpenStack
Quick Start
一、Centos Stream 8虚拟机安装必要的工具软件 1、修改主机名 [root@localhost ~]# hostnamectl set-hostname controller 2、安装网络工具 [root@controller ~]# yum install -y net-tools 3、修改ens160网络配置 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-nABXLvEi-1669918781213)(E:\虚拟化技术\素材\ifconfig_1.png)]
（1）修改ens160网络配置文件 [root@controller ~]# vi /etc/sysconfig/network-scripts/ifcfg-ens160 （2）重启网络服务 [root@controller ~]# nmcli c reload [root@controller ~]# nmcli c up ens160 [root@controller ~]# nmcli networking off [root@controller ~]# nmcli networking on [root@controller ~]# ping www.baidu.com PING www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5eac5fda7d2381472dad29fa66e8df8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fb9e95b0cfe58466dd7bee1326ffc98/" rel="bookmark">
			解开Kafka神秘的面纱(三)：kafka单机部署和集群部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、前言二、kafka单机安装2.1 下载压缩包2.2 zookeeper安装2.3 kafka安装 三、kafka集群安装3.1 zookeeper安装3.2 kafka的安装3.3 两种Topic 四、尾声 一、前言 本文主要介绍kafka的单机和集群模式部署。
二、kafka单机安装 2.1 下载压缩包 需要先到官网下载zookeeper和kafka压缩包，先下载zookeeper，如下
然后进入kafka官网下载，如下图：
下载到本地
2.2 zookeeper安装 第一步：使用FileZilla或者xftp可以通过ftp将zookeeper压缩包上传到 192.168.100.120 机器，解压，进入到 conf 目录，看到 zoo_sample.cfg 文件，cp 复制生成 zoo.cfg 文件，如下：
第二步，启动并查看状态
启动zookeeper ./bin/zkServer.sh start 查看zookeeper状态 ./bin/zkServer.sh status standalone代表单机启动，后面讲解集群启动
2.3 kafka安装 第一步：使用FileZilla或者xftp可以通过ftp将kafka压缩包上传到 192.168.100.120 机器，解压，进入到 conf 目录，看到config/server.properties 文件，并做如下修改
第二步：启动kafka
./bin/kafka-server-start.sh config/server.properties &amp; 第三步：新建topic并查看状态
./bin/kafka-topics.sh --create --topic test2 --bootstrap-server 192.168.100.120:9092 --partitions 1 --replication-factor 1 ./bin/kafka-topics.sh --describe --topic test2 --bootstrap-server 192.168.100.120:9092 然后zoo.cfg指定的目录就有了topic了
第五步：生产消息和消费消息
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fb9e95b0cfe58466dd7bee1326ffc98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/242401003e18f49f5027034f10746966/" rel="bookmark">
			EGE基础：图像操作篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EGE专栏：EGE专栏
目录 一、EGE的图像功能二、图片读取绘制简单演示1. 找一张保存在电脑上的图片2. 查看图片的路径(File path)3. 读取图像文件并绘制到窗口上4. 查看运行结果 三、文件路径1. 文件扩展名显示设置2. 绝对路径和相对路径 四、EGE 中的图像1. 计算机如何表示图像2. EGE中的图像3. 如何定义全局图像 五、EGE图像的使用流程六、图像的创建和销毁1. 创建图像 newimage()2. 图像的销毁 delimage() 七、获取图像1. 获取图像的四种方式1.1 从图形窗口获取图像（截屏）1.2 从图像文件中获取1.3 从另一个 PIMAGE 中获取1.4 从资源文件获取 2. 如何检测是否成功读取到图像2.1 利用getimage返回值判断2.2 利用getwidth, getheight判断 3. 图像数组，加载多张图像4. 图像缩放4.1 图片缩放的考虑4.2 使用EGE接口改变图像大小4.3 从文件中加载图像并缩放至指定大小4.4 缩放原图像 5. 内存泄漏 八、 图像绘制1. 图像普通绘制1.1 putimage()1.1.1 全图绘制1.1.2 部分绘制1.1.3 部分缩放绘制1.2 putimage_withalpha() 支持带透明度图像 2. 图像透明绘制2.1 putimage_alphablend() 图像半透明混合2.3 putimage_transparent() 指定图像透明像素2.4 putimage_alphatransparent() 3. 旋转绘图3.1 putimage_rotate()3.2 putimage_rotatezoom() 4. 模糊滤镜 六、图像其它操作1. 图像属性1.1 重设图像尺寸1.2 获取图像宽度和高度 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/242401003e18f49f5027034f10746966/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4141fb799683827c7772bf1a97d85f7/" rel="bookmark">
			关于Event Loop事件循环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Event Loop概念： Event Loop即事件循环，是指浏览器或Node的一种解决javaScript单线程运行时不会阻塞的一种机制，也就是我们经常使用异步的原理。
二、Event Loop： 同步任务和异步任务
为了防止某个耗时任务导致程序假死的问题,javaScript把待执行的任务分为了两类：
​ 1.同步任务（syncchronous）
又叫非耗时任务,指的是主线程上排队执行的那些任务
只有前一个任务执行完毕,才能执行后一个任务
2.异步任务（asyncchronous）
​ 又叫做耗时任务,异步任务由javaScript委托给宿主环境进行执行
​ 当异步任务执行完成后,会通知javaScript主线程执行异步任务的回调函数
三、同步任务与异步任务的执行过程： 1.同步任务由JavaScript 主线程次序执行 2.异步任务委托给宿主环境执行 3.已完成的异步任务对应的回调函数，会被 加入到任务队列中等待执行 4.avaScript 主线程的执行栈被清空后，会 读取任务队列中的回调函数，次序执行 5.JavaScript 主线程不断重复上面的第 4 步 宏任务和微任务： 宏任务和微任务的根本区别： 1.常见的宏任务有：setTimeout setInterval ajax DOM事件
2.常见的微任务有：promise async/await
3.微任务的执行时间早于宏任务
4.微任务是由es6语法规定的，宏任务是浏览器规定的
宏任务与微任务的执行顺序： 每一个宏任务执行完毕后,都会检查是否还存爱待执行的微任务,如果有,则执行完所有的微任务之后,再继续执行下一个宏任务 经典案例： console.log('start'); setTimeout(() =&gt; { console.log(1); }); Promise.resolve('x').then(() =&gt; { console.log(2); }).then(() =&gt; { console.log(3); }).then(() =&gt; { console.log(4); }) console.log('end'); 输入结果：start–&gt;end–&gt;2—&gt;3–&gt;4–&gt;1
分析： 1.start和end属于同步代码优先执行
2.promise里的代码也属于同步代码，但.then里的代码属于异步代码中的微任务，稍后执行
3.setTimeout属于异步代码中的宏任务，最后执行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75002ff4456eb718ba3c9a0d65353a93/" rel="bookmark">
			Microsoft visual c&#43;&#43;组件库报错快速解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：装软件的时候偶尔会遇到报错，提示Microsoft Visual C++ 201X Additional Runtime有问题。其实一般是软件要求装的C++组件库版本与你电脑中存在的版本不符，通过移除电脑上的旧版本即可解决问题。
注意：在移除旧版本后，大部分软件会自动安装上符合的组件库，如果没有自动安装，可自行去微软搜索对应的组件库进行安装。
这次是在装Vmware的时候提示，Microsoft Visual C++运行库有问题，根据Browse提示的路径去找发现没有对应文件，而点击“OK”选项后只会跳出下面一段警告。
下载 Windows Installer Clean Up 网上资源很多，随便挑一个下载就行，贴一个我之前用的
https://download.csdn.net/download/qq_42808479/12477715
下载完成后，直接安装。
打开Windows Installer Clean Up，依据刚才安装软件报错的提示（这里是要点击"OK”后提示的库名2017 x86 Additional Runtime，不是标题写着的2019 x86 Additional Runtime），找对应的库名，选中，点击Remove。
一般不止一个库出错，Remove后再次打开软件安装包会发现提示另一个库有问题，重复上述操作即可。大概在清理两三个库之后，安装包就可以正常打开啦！
如果是组件库2017、组件库2019的各类报错，推荐更完美的解决方案：
https://blog.csdn.net/qq_42808479/article/details/114300378
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c88f5344e258f841e6c917ea2b717ff8/" rel="bookmark">
			嵌入式闲置作品、产品设计，模电，数电设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 简介 长期做嵌入式软件、硬件相关产品设计和项目。
主要内容 嵌入式闲置作品接产品设计模电，数电设计bi ye 设计ke设51,stm32等任何单片机定制设计 服务 手把手教学包教包会详情可私聊 详情如下图所示 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6eca48ee4786cd7f8a0b0c4b310128b8/" rel="bookmark">
			Spring Cloud Gateway 网关组件及搭建实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Cloud Gateway 是 Spring Cloud 团队基于 Spring 5.0、Spring Boot 2.0 和 Project Reactor 等技术开发的高性能 API 网关组件。Spring Cloud Gateway 旨在提供一种简单而有效的途径来发送 API，并为它们提供横切关注点，例如：安全性，监控/指标和弹性。
Spring Cloud Gateway 是基于 WebFlux 框架实现的，而 WebFlux 框架底层则使用了高性能的 Reactor 模式通信框架 Netty。它最主要的功能就是路由转发，在定义转发规则时主要涉及以下三个核心概念：
Route（路由）—— 网关最基本的模块。它由一个 ID、一个目标 URI、一组断言（Predicate）和一组过滤器（Filter）组成。Predicate（断言）—— 路由转发的判断条件，可以通过 Predicate 对 HTTP 请求进行匹配，例如请求方式、请求路径、请求头、参数等，如果请求与断言匹配成功，则将请求转发到相应的服务。Filter（过滤器）—— 过滤器，可以使用它对请求进行拦截和修改，还可以使用它对上文的响应进行再处理。 工作流程 客户端将请求发送到 Spring Cloud Gateway 上。Spring Cloud Gateway 通过 Gateway Handler Mapping 找到与请求相匹配的路由，将其发送给 Gateway Web Handler。Gateway Web Handler 通过指定的过滤器链（Filter Chain），将请求转发到实际的服务节点中，执行业务逻辑返回响应结果。过滤器之间用虚线分开是因为过滤器可能会在转发请求之前（pre）或之后（post）执行业务逻辑。过滤器（Filter）可以在请求被转发到服务端前，对请求进行拦截和修改，例如参数校验、权限校验、流量监控、日志输出以及协议转换等。过滤器可以在响应返回客户端之前，对响应进行拦截和再处理，例如修改响应内容或响应头、日志输出、流量监控等。响应原路返回给客户端。
动态路由 默认情况下，Spring Cloud Gateway 会根据服务注册中心（例如 Eureka Server）中维护的服务列表，以服务名（spring.application.name）作为路径创建动态路由进行转发，从而实现动态路由功能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6eca48ee4786cd7f8a0b0c4b310128b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4a29865a72eb964289d83d748032dab/" rel="bookmark">
			网站变灰白css
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 直接在html或者body增加样式 filter: progid:DXImageTransform.Microsoft.BasicImage(grayscale=1); -webkit-filter: grayscale(100%); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/169744c5158549fb3a3c61b032308e64/" rel="bookmark">
			Element组件$Notification 通知使用指北
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 效果图
先在element js里按需引入 import {Notification,} from 'element-ui'
别直接Vue.use(Notification)
挂载到原型上 Vue.prototype.$notify = Notification 这个$notify就是咱们起的名字 叫abc都行 建议不动
然后在需要使用的地方设置就行了 如：
created() { this.$notify({ title: "成功", message: "获取左侧菜单列表成功",//这儿也可以用比如res.data.meta.msg的办法 type: "success", }); }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a11978d5952161fdf2b5fb0a8b6c48c/" rel="bookmark">
			【实用插件】Vue图片浏览组件v-viewer，支持旋转、缩放、翻转等操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		适用场景
适用于管理平台预览图片的场景支持功能
支持放大缩小旋转，方向键切换图片效果如下：
用法说明
将该插件按文档说明引入项目后，只需要在容器标签上面增加v-viewer属性，就可对该元素下所有后代元素中的图片增加如上图的预览功能，具体引入方式请参考官方文档。
文档地址：
中文文档： 中文文档
仓库地址： 插件git仓库示例代码 &lt;div class="flex" v-viewer&gt; &lt;a-card style="width: 240px; margin-top: 20px; margin-left: 20px"&gt; &lt;img slot="cover" alt="example" src="" /&gt; &lt;/a-card&gt; &lt;a-card style="width: 240px; margin-top: 20px; margin-left: 20px"&gt; &lt;img slot="cover" alt="example" src="" /&gt; &lt;/a-card&gt; &lt;a-card style="width: 240px; margin-top: 20px; margin-left: 20px"&gt; &lt;img slot="cover" alt="example" src="" /&gt; &lt;/a-card&gt; &lt;/div&gt; 另
在我逛该插件作者的仓库时，发现这位大佬还有另一个点赞更多的项目，抱着学习的心态点进了项目示例 简要概括的话是一个线上裁剪图片的项目，用户上传图片之后可以进行裁剪等操作，最后得到操作后的图片。
项目演示网站
演示网站
git仓库网站预览
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55f48d516b9e43e83d355aab57e7f347/" rel="bookmark">
			严重: Failed to initialize end point associated with ProtocolHandler [“http-bio-8080“]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.端口号被占用，之前的tomcat未正常关闭，cmd执行
1.查看指定端口的占用情况 netstat -aon|findstr "8080"
2.查看PID对应的进程 tasklist|findstr "PID"
3.结束该进程 taskkill /f /t /im java.exe(程序名称+exe)
二：如果mybatis数据库连接失败，查看账号和密码是否正确或者数据库名称正确否
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9591086b927057d59d1c5217067bacd6/" rel="bookmark">
			在服务器跑vue不能访问？是你的host设置问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看了csdn的一堆文章
大都是部署的
也就是 经过了 npm run build 之后，打包好的压缩工程部署
比如：
https://blog.csdn.net/weixin_43690623/article/details/122718677
我想知道的，是，如何 npm run dev 就能访问，
答案是：在config/index.js 进行 host 的 0.0.0.0 设定
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8776e9d12618fb0813ab6793bf05c8b/" rel="bookmark">
			el-tree 实现全部展开或折叠
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		el-tree 实现全部展开或折叠 先上图，node-key 属性是必不可少的。
关键点是通过 el-tree 的引用获取到所有节点，然后赋值每个节点的 expanded 属性即可控制整体的展开或合并。
下面是 this.$refs.tree.store 的打印结果，nodesMap 中包含了所有层级节点。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0d48047faafe26c38e51b0446cf3c0b/" rel="bookmark">
			Python仓库管理系统源代码，库存管理系统源码，基于flask，内含数据库文件，已实现出入库、库存预警，库存搜索等功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python仓库管理系统源代码，库存管理系统源码，基于flask，内含数据库文件，已实现出入库、库存预警，库存搜索等功能
已实现三大功能：库存管理（出库、入库、低库存预警、物品搜索），预算统计，出入库记录导出。
完整代码下载地址：Python仓库管理系统源代码，库存管理系统源码
app.py
from flask import Flask, render_template, request, jsonify import webbrowser import sqldb app = Flask(__name__) #进入首页 @app.route('/') # def hei(): # return render_template('test.html') # #进入'index'页面 @app.route('/index/') #进入后自动运行下面函数 def index(): return render_template('goods.html') @app.route('/other/') def other(): return render_template('records.html') @app.route('/count/') def count(): return render_template('count.html') @app.route('/data/goods/') def getgoods(): #data数据要以这种方式命名是为了LAYUI的数据要求 data = {"code": 0, "msg": ""} name = request.args.get('search_name') or '' model = request.args.get('search_model') or '' process = request.args.get('search_process') or '' lst = sqldb.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0d48047faafe26c38e51b0446cf3c0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef6ea29e15ae64dda451479e23818d81/" rel="bookmark">
			mybatisplus如何处理Mysql的Json字段
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 最近业务上遇到需要处理mysql中的Json字段的情况，在此做下记录。
MySql中的Json字段 MySQL里的json分为json array和json object。
$表示整个json对象，在索引数据时用下标（对于json array，从0开始）或键值（对于json object，含有特殊字符的key要用"括起来，比如$.“my name”）。
根据json字段的内容检索查询数据
使用 字段-&gt;'$.json属性'进行查询条件使用json_extract函数查询，json_extract(字段,"$.json属性")根据json数组查询，用JSON_CONTAINS(字段,JSON_OBJECT('json属性', "内容")) 例如：
SELECT * FROM `msg_content` t where t.extend_data -&gt;'$.lastName' like '%a%' 注意：
在field中使用，-&gt;在field中使用的时候结果带引号，-&gt;&gt;的结果不带引号；
在where条件中使用，-&gt;当做where查询是要注意类型的，-&gt;&gt;是不用注意类型的。
Mybatis Plus处理Mysql中的Json字段 1.实体类中有属性是其他对象，或者是List；在数据库中存储时使用的是mysql的json格式，此时可以用mybatis plus的一个注解@TableField(typeHandler = JacksonTypeHandler.class)，这样在存入是就可以把对象自动转换为json格式
@TableField(typeHandler = JacksonTypeHandler.class) 2.那么取出时怎么进行映射呢，有分为两种情况：
a:当没有使用到xml时：
@Data @TableName(value = "person",autoResultMap = true) b:当使用了xml文件时：
&lt;result property="advance" column="advance" typeHandler="com.baomidou.mybatisplus.extension.handlers.JacksonTypeHandler"/&gt; 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/119/">«</a>
	<span class="pagination__item pagination__item--current">120/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/121/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>