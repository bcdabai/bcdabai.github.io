<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4359c1bdccc2da7ceb863777976ea13a/" rel="bookmark">
			js中的跨域问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ajax中的跨域问题 跨域问题 跨域问题，指从一个域名的网页去请求另一个域名的资源。它是由浏览器的同源策略造成的，是浏览器对JavaScript施加的安全限制。
何为跨域访问 解决跨域问题常用的方法 1. 跨域资源共享（CORS） CORS（Cross-Origin Resource Sharing）跨域资源共享，定义了必须在访问跨域资源时，浏览器与服务器应该如何沟通。CORS背后的基本思想就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。
服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。
只需要在后台中加上响应头来允许域请求！在被请求的Response header中加入以下设置，就可以实现跨域访问了！
//指定允许其他域名访问 'Access-Control-Allow-Origin:*'//或指定域 //响应类型 'Access-Control-Allow-Methods:GET,POST' //响应头设置 'Access-Control-Allow-Headers:x-requested-with,content-type' 2. 服务器代理 例如需要调用www.baidu.com中的资源，可以写一php接口，由这个接口从后端去调用www.baidu.com中的资源并拿到返回值，然后再返回给前端，这就是一个代理的模式。因为它是通过后端进行调用的，没有经过浏览器，自然就不存在跨域问题。
3. document.domain+iframe的设置 对于主域相同而子域不同的例子，可以通过设置document.domain的办法来解决。具体的做法是可以在http://www.a.com/a.html和http://script.a.com/b.html两个文件中分别加上document.domain =‘a.com’；然后通过a.html文件中创建一个iframe，去控制iframe的contentDocument，这样两个js文件之间就可以“交互”了。当然这种办法只能解决主域相同而二级域名不同的情况，代码如下
www.a.com中的a.html
document.domain = 'a.com'; var ifr = document.createElement('iframe'); ifr.src = 'http://script.a.com/b.html'; ifr.style.display = 'none'; document.body.appendChild(ifr); ifr.onload = function(){ var doc = ifr.contentDocument || ifr.contentWindow.document; // 在这里操纵b.html alert(doc.getElementsByTagName("h1")[0].childNodes[0].nodeValue); }; script.a.com上的b.html
document.domain = 'a.com'; 缺点 1、安全性，当一个站点（b.a.com）被攻击后，另一个站点（c.a.com）会引起安全漏洞。
2、如果一个页面中引入多个iframe，要想能够操作所有iframe，必须都得设置相同domain。
4. 使用HTML5的window.postMessage方法跨域 window.postMessage(message,targetOrigin) 方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源，目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。
调用postMessage方法的window对象是只要接收消息的那一个window对象，该方法的第一个参数message为要发送的消息，类型只能为字符串；第二个参数targetOrigin用来限定接收消息的那个window对象所在的域，如果不想限定域，可以使用通配符 * 。
需要接收消息的window对象，可以通过监听自身的message事件来获取传过来的消息，消息内容储存在该事件对象的data属性中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4359c1bdccc2da7ceb863777976ea13a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/098006223c284e93f02c3d9049e3726c/" rel="bookmark">
			如何在cisco官网上下载Cisco packet tracer模拟器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个是“思科网络技术学院”提供的一个软件，需要注册成为学员以后才能用，注册名字可以更改。 进入网站后，上面七个选项，cisco Networking Academy、课程（下边第七个选项“Packet Tracer”）、职业生涯、关于我们（右边）放大镜、语言选择（English,可以选简体中文）、登录； 进入以后，页面的中间有两个课程，都是“在线自定进度学习”，一个电脑端，一个是手机端，选左边的“了解详情”，然后进入注册界面，课程是十个小时，点“请立即注册”按钮里的一个"ENGLISH"选项，然后填写就行了，填好注册，然后上边选项多了一个“资源选项，点击即可找到下载项。 转载于:https://www.cnblogs.com/hackerZT-7/p/10562651.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/194247d47bb1c402ae2dddebebb89dd2/" rel="bookmark">
			是哪一瞬间让后端们决定入职的？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		奇略科技 一家神奇又随意的公司，想用心打造一个教育平台，给所有孩子一个轻松又好玩的教育平台。需要强有力又有趣的你们加入。
岗位名称：后端 岗位职责： 负责项目服务器端的功能实现
岗位要求： 5年以上服务器开发经验；
熟练使用Java或者C#，有Vertx，Akka，Orleans等框架的使用经验（附线上项目链接）；
熟悉直播和视频相关技术；
熟悉云服务；
熟悉Docker，K8S相关技术；
有团队精神；
对新技术持有不断学习的兴趣和动力；
熟悉前端开发者优先；
会下围棋者优先。
薪资待遇： 包您满意，来了不肯走。
工作环境： 绝对没得说，轻松幽默各种逗，零食吃个够。
联系方式： xiaye@qilue.com
反正就那么回事儿，具体怎么回事儿，来了就知道。 发简历给我吧～～～ 有的事不能在这说，来了再说。 转载于:https://juejin.im/post/5c91e90ae51d4577de68e2f3
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e73ea00310b4f0d2b0b842de6ef1f99/" rel="bookmark">
			微擎中事务处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 做过小程序开发的可能都知道微擎吧
提到微擎二次开发那是一个酸爽啊，废话多说，微擎的文档微擎官方文档比较有限，没说怎么用事务处理，这里我只好用原生的了，首先了解一下mysql原生事务处理
在默认的情况下，MySQL从自动提交（autocommit）模式运行，这种模式会在每条语句执行完毕后把它作出的修改立刻提交给数据库并使之永久化。事实上，这相当于把每一条语句都隐含地当做一个事务来执行。如果你想明确地执行事务，需要禁用自动提交模式并告诉MySQL你想让它在何时提交或回滚有关的修改。
执行事务的常用办法是发出一条START TRANSACTION（或BEGIN）语句挂起自动提交模式，然后执行构成本次事务的各条语句，最后用一条 COMMIT语句结束事务并把它们作出的修改永久性地记入数据库。万一在事务过程中发生错误，用一条ROLLBACK语句撤销事务并把数据库恢复到事务开 始之前的状态。
START TRANSACTION语句"挂起"自动提交模式的含义是：在事务被提交或回滚之后，该模式将恢复到开始本次事务的 START TRANSACTION语句被执行之前的状态。（如果自动提交模式原来是激活的，结束事务将让你回到自动提交模式；如果它原来是禁用的，结束 当前事务将开始下一个事务。） 如果是autocommit模式 ，autocommit的值应该为 1 ，不autocommit 的值是 0 ；请在试验前 确定autocommit 的模式是否开启
结合微擎的方法，代码如下：
pdo_fetchall('set AUTOCOMMIT=0');//关闭自动提交，自此句执行以后，每个SQL语句或者语句块所在的事务都需要显示"commit"才能提交事务 pdo_fetchall('START TRANSACTION');//启动一个新事务 pdo_fetchall('ROLLBACK');//事务回滚 pdo_fetchall('COMMIT');//事务提交 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a75771ae7fce7f58a2784f9b4abd060/" rel="bookmark">
			iOS 唤起各种App的方法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		暴力打开某个App , 如果可以打开 +(BOOL)isOpenApp:(NSString*)appIdentifierName { Class LSApplicationWorkspace_class = objc_getClass("LSApplicationWorkspace"); NSObject* workspace = [LSApplicationWorkspace_class performSelector:NSSelectorFromString(@"defaultWorkspace")]; BOOL isOpenApp = [workspace performSelector:NSSelectorFromString(@"openApplicationWithBundleID:") withObject:appIdentifierName]; return isOpenApp; } 以下为App版 url schemes： launch center pro支持的参数主要有两个，[prompt]文本输入框和[clipboard]剪贴板 淘宝宝贝搜索 taobao://http://s.taobao.com/?q=[prompt] 淘宝店铺搜索taobao://http://shopsearch.taobao.com/browse/shop_search.htm?q=[prompt] omnifocus:///add?name=[prompt]&amp;note=[clipboard] mdict://[prompt] QQ的url是 mqq:// 微信是weixin:// 淘宝taobao:// 点评dianping:// dianping://search 微博 sinaweibo:// 名片全能王camcard:// weico微博weico:// 支付宝alipay:// 豆瓣fm：doubanradio:// 微盘 sinavdisk:// 网易公开课ntesopen:// 美团 imeituan:// 京冬openapp.jdmoble:// 人人renren:// 我查查 wcc:// 1号店wccbyihaodian:// 有道词典yddictproapp:// 知乎zhihu:// 优酷 youku:// 以下为ipad版url schemes： ZAKER ：【zakeripad://】 mdict：【mdict://】 京东hd：【openApp.jdiPad://】 易迅：【wx6964eb0b10aa369b://】；【icson://】；【wap2app://】；【com51buyiPad://】；【sinaweibosso.2217266362://】；【yixunipad://】； wunderlist：【fb208559595824260://】；【wunderlist://】； 1password：【db-0bcm217bz8olcxj://】； 支付宝：【alipay://】； 亚马逊：【fb115829135094686://】； 查找朋友：【grenada://】；【findmyfriends://】；【fmf1://】； 查找iphone：【fmip1://】； homestyler：【fb110202249127916://】； 百度旅游hd：【sinaweibosso.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a75771ae7fce7f58a2784f9b4abd060/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6cc05c39ad8a0feb399e765ae9ab86f/" rel="bookmark">
			微信小程序-锚点定位&#43;内容滑动控制导航选中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前两篇文章分别介绍了锚点定位和滑动内容影响导航选中，这里我们就结合起来，实现这两个功能！
思路不再多说，直接上干货！
WXML &lt;view class="navigateBox"&gt; &lt;view class="title"&gt; &lt;image wx:if="{{actionView=='productBox'}}" src="../images/position.png"/&gt; &lt;view class="title {{actionView=='productBox' ? 'checked':''}}" bindtap="toViewClick" data-hash="productBox"&gt;商品&lt;/view&gt; &lt;/view&gt; &lt;view class="title"&gt; &lt;image wx:if="{{actionView=='commentBox'}}" src="../images/position.png"/&gt; &lt;view class="title {{actionView=='commentBox' ? 'checked':''}}" bindtap="toViewClick" data-hash="commentBox"&gt;评价&lt;/view&gt; &lt;/view&gt; &lt;view class="title"&gt; &lt;image wx:if="{{actionView=='infoBox'}}" src="../images/position.png"/&gt; &lt;view class="title {{actionView=='infoBox' ? 'checked':''}}" bindtap="toViewClick" data-hash="infoBox"&gt;详情&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;scroll-view style="height:{{winHeight}}" scroll-into-view="{{toView}}" scroll-y="true" bindscroll="scrollTo"&gt; &lt;view id="productBox" class="content"&gt;商品信息...&lt;/view&gt; &lt;view id="commentBox" class="content"&gt;评价内容...&lt;/view&gt; &lt;view id="infoBox" class="content"&gt;商品详情...&lt;/view&gt; &lt;/scroll-view&gt; 复制代码 WXS data: { winHeight: '100%', toView: 'productBox',//锚点跳转的ID actionView: 'productBox',//控制导航显示 productBoxTop: 0,//商品模块距离顶部的距离 commentBoxTop: 0,//评价模块距离顶部的距离 infoBoxTop: 0,//详情模块距离顶部的距离 }; onLoad() { let that = this; wx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6cc05c39ad8a0feb399e765ae9ab86f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf7407c1b620f32ffe47c5a5351fc96e/" rel="bookmark">
			ZZULIOJ 1175: 矩阵转置（指针专题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述
给定一个m行n列的二维矩阵，输出其转置矩阵。1&lt;=m、n&lt;=100000，可能是1行100000列，也可能是10000行50列。你可能不能预定义数组的大小了，你要学会使用动态内存分配哦。
输入
输入第一行是m和n，然后是一个m行n列的矩阵。
输出
输出转置后的矩阵
样例输入 Copy
3 4
1 2 3 4
5 6 7 8
9 5 4 6
样例输出 Copy
1 5 9
2 6 5
3 7 4
4 8 6
#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; int main() { int m,n; scanf("%d%d",&amp;m,&amp;n); int *p; p=(int *)malloc(sizeof(int)*(n*m)); int i,j,k; for( i=0;i&lt;m;i++) for( j=0;j&lt;n;j++) scanf("%d",&amp;p[i*n+j]); int a[m][n]; for( i=0;i&lt;m;i++) for( j=0;j&lt;n;j++) { a[i][j]=p[i*n+j]; } for( j=0;j&lt;n;j++) { for( i=0;i&lt;m-1;i++) printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf7407c1b620f32ffe47c5a5351fc96e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b979c2e0956065840214b552afb5625/" rel="bookmark">
			java hashmap里明明有一个key却得不到它的value
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hashmap里明明有一个key却得不到它的value，get这个key取出来null，原因是接口调试或者测试的时候可能key多加了一个空格号！！！！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d1ce69c98876bfe995e7c767541836b/" rel="bookmark">
			flink随手笔记之Slot分配与共享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明：本文为《Flink大数据项目实战》学习笔记，想通过视频系统学习Flink这个最火爆的大数据计算框架的同学，推荐学习CSDN官网课程：
Flink大数据项目实战：http://t.cn/ExrHPl9
共享Slot 默认情况下，Flink 允许subtasks共享slot，条件是它们都来自同一个Job的不同task的subtask。结果可能一个slot持有该job的整个pipeline。
允许slot共享有以下两点好处：
1.Flink集群需要的任务槽与作业中使用的最高并行度正好相同(前提，保持默认SlotSharingGroup)。也就是说我们不需要再去计算一个程序总共会起多少个task了。
2.更容易获得更充分的资源利用。如果没有slot共享，那么非密集型操作source/flatmap就会占用同密集型操作 keyAggregation/sink 一样多的资源。如果有slot共享，将task的2个并行度增加到6个，能充分利用slot资源，同时保证每个TaskManager能平均分配到重的subtasks。
2.2共享Slot实例
将 WordCount 的并行度从之前的2个增加到6个（Source并行度仍为1），并开启slot共享（所有operator都在default共享组），将得到如上图所示的slot分布图。
首先，我们不用去计算这个job会其多少个task，总之该任务最终会占用6个slots（最高并行度为6）。其次，我们可以看到密集型操作 keyAggregation/sink 被平均地分配到各个 TaskManager。
2.3 SlotSharingGroup(soft)
SlotSharingGroup是Flink中用来实现slot共享的类，它尽可能地让subtasks共享一个slot。
保证同一个group的并行度相同的sub-tasks 共享同一个slots。算子的默认group为default(即默认一个job下的subtask都可以共享一个slot)
为了防止不合理的共享，用户也能通过API来强制指定operator的共享组，比如：someStream.filter(...).slotSharingGroup("group1");就强制指定了filter的slot共享组为group1。怎么确定一个未做SlotSharingGroup设置算子的SlotSharingGroup什么呢(根据上游算子的group 和自身是否设置group共同确定)。适当设置可以减少每个slot运行的线程数，从而整体上减少机器的负载。
2.4 CoLocationGroup(强制)
CoLocationGroup可以保证所有的并行度相同的sub-tasks运行在同一个slot，主要用于迭代流(训练机器学习模型)。
3. Slot &amp; parallelism的关系 3.1 Slots &amp;&amp; parallelism
如上图所示，有两个TaskManager，每个TaskManager有3个槽位。假设source操作并行度为3，map操作的并行度为4，sink的并行度为4，所需的task slots数与job中task的最高并行度一致，最高并行度为4，那么使用的Slot也为4。
3.2如何计算Slot
如何计算一个应用需要多少slot？
如果不设置SlotSharingGroup，那么需要的Slot数为应用的最大并行度数。如果设置了SlotSharingGroup，那么需要的Slot数为所有SlotSharingGroup中的最大并行度之和。比如已经强制指定了map的slot共享组为test，那么map和map下游的组为test，map的上游source的组为默认的default，此时default组中最大并行度为10，test组中最大并行度为20，那么需要的Slot=10+20=30。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b5cce01fe3d0d549cd2424c94442684/" rel="bookmark">
			移动硬盘打不开，换一台电脑就又可以打开了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一、重新插拔更换usb接口。
打开控制面板（小图标查看）—设备管理器，在磁盘驱动器列表中找到你的设备，右击卸载。
拔下USB数据线，并重新连接，此时驱动程序会自动加载，一般可恢复正常。
方法二：重新安装USB控制器。
打开控制面板（小图标查看）—设备管理器，展开通用串行总线控制器，右键单击设备选择“卸载”，每个设备重复以上操作。完成后，重新启动计算机，系统会自动安装USB控制器。
方法三：禁用USB选择性暂停设置。
1、控制面板——电源选项，单击当前所选的电源计划旁边的更改计划设置。
2、单击更改高级电源设置。
3、展开USB设置—USB选择性暂停设置，将其设置为“已禁用”，确定。
重新安装USB控制器比较有用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d64d2027ede5c97d34823644b10f0cf0/" rel="bookmark">
			【理论课之配饰设计】色彩与视觉的原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		色彩与视觉的原理(1)
1.光与色 光色并存，有光才有色。色彩感觉离不开光。 （1）光与可见光谱。光在物理学上是一种电磁波。从0.39微米到0.77微米波长之间的电磁波，才能引起人们的色彩视觉感觉受。此范围称为可见光谱 。波长大于0.77微米称红外线，波长小于0.39称紫外线。 （2）光的传播。光是以波动的形式进行直线传播的，具有波长和振幅两个因素。不同的波长长短产生色相差别。不同的振幅强弱大小产生同一色相的明暗差别。光在传播时有直射、反射、透射、漫射、折射等多种形式。光直射时直接传入人眼，视觉感受到的是光源色。当光源照射物体时，光从物体表面反射出来，人眼感受到的是物体表面色彩。当光照射时，如遇玻璃之类的透明物体，人眼看到是透过物体的穿透色。光在传播过程中，受到物体的干涉时，则产生漫射，对物体的表面色有一定影响。如通过不同物体时产生方向变化，称为折射，反映至人眼的色光与物体色相同。 2.物体色 自然界的物体五花八门、变化万千，它们本身虽然大都不会发光，但都具有选择性地吸收、反射、透射色光的特 性。当然，任何物体对色光不可能全部吸收或反射，因此，实际上不存在绝对的黑色或白色。 常见的黑、白、灰物体色中，白色的反射率是64％-92.3％；灰色的反射率是10％-64％；黑色的吸收率是90％以上。 物体对色光的吸收、反射或透射能力，很受物体表面肌理状态的影响，表面光滑、平整、细腻的物体，对色光的反射较强，如镜子、磨光石面、丝绸织物等。表面粗糙、凹凸、疏松的物体，易使光线产生漫射现象，故对色光的反射较弱，如毛玻璃、呢绒、海绵等。 但是，物体对色光的吸收与反射能力虽是固定不变的，而物体的表面色却会随着光源色的不同而改变，有时甚至失去其原有的色相感觉。所谓的物体“固有色”，实际上不过是常光下人们对此的习惯而已。如在闪烁、强烈的各色霓虹灯光下，所有建筑及人物的服色几乎都失去了原有本色而显得奇异莫测。 另外，光照的强度及角度对物体色也有影响。 二、 色立体及表色系 1.色立体 色立体是依据色彩的色相、明度、纯度变化关系，借助三维空间，用旋围直角坐标的方法，组成一个类似 球体的立体模型。它的结构经了比地球仪的形状，北极为白色，南极为黑色，连接南北两极贯穿中心的轴为明度标轴，北半球是明色系，南北半球是深色系。色相环的位置则赤道线上，球面一点到中心轴的重直线，表示纯度系列标准，越近中心，纯度越低，球中心为正灰。 色立体有多种，主要有美国蒙赛尔色立体、德国奥斯特瓦尔德色立体、日本色研色立体等。 2.蒙赛尔表色系 三、色彩三要素及色彩对比 &lt;一&gt;.色相对比的基本类型 两种以上色彩组合后，由于色相差别而形成的色彩对比效果称为色相对比。它是色彩对比的一个根本方面，其对比强弱程度取决于色相之间在色相环上的距离（角度），距离（角度）越小对比越强，反之则对比越强。 1.零度对比 （1）无彩色对比 无彩色对比虽然无色相，但它们的组合在实用方同很有价值。如黑与白 、黑与灰、中灰与浅灰，或黑与白与灰、黑与深灰与浅灰等。对比效果感觉大方、庄重、高雅而富有现代感，但也易产生过于素净的单调感。 （2）无彩色与有彩色对比 如黑与红、灰与紫，或黑与白与黄、白与灰与蓝等。对比效果感觉既大方 又活泼，无彩色面积大时，偏于高雅、庄重，有彩色面积大时活泼感加强。 （3）同种色相对比 一种色相的不同明度或不同纯度变化的对比，俗称姐妹色组合。如蓝与浅蓝（蓝+白）色对比，橙与咖啡（橙+灰）或绿与粉绿（绿+白）与墨绿（绿+黑）色等对比。对比效果感觉统一、文静、雅致、含蓄、稳重，但也易产生单调、呆板的弊病。 （4）无彩色与同种色相比 如白与深蓝与浅蓝、黑与桔与咖啡色等对比，其效果综合了（2）和（3）类型的优点。感觉既有一定层次，又显大方、活泼、稳定。 2.调和对比 （1）邻接色相对比 色相环上相邻的二至三色对比，色相距离大约30度左右，为弱对比类型。如红橙与橙与黄橙色对比等。效果感觉柔和、和谐、雅致、文静，但也感觉单调、模糊、乏味、无力，必须调节明度差来加强效果。 （2）类似色相对比 色相对比距离约60度左右，为较弱对比类型，如红与黄橙色对比等。效果较丰富、活泼，但又不失统一、雅致、和谐的感觉。 （3）中差色相对比 色相对比距离约90度左右，为中对比类型，如黄与绿色对比等，效果明快、活泼、饱满、使人兴奋，感觉有兴趣，对比既有相当力度，但又不失调和之感。 3.强烈对比 （1）对比色相对比 色相对比距离约120度左右，为强对比类型，如黄绿与红紫色对比等。效果强烈、醒目、有力、活泼、丰富，但也不易统一而感杂乱、刺激、造成视觉疲劳。一般需要采用多种调和手段来改善对比效果。 （2）补色对比 色相对比距离180度，为极端对比类型，如红与蓝绿、黄与蓝紫色对比等。效果强烈、眩目、响亮、极有力，但若处理不当，易产生幼稚 、原始、粗俗、不安定、不协调等不良感觉。 &lt;二&gt;明度对比的基本类型 两种以上色相组合后，由于明度不同而形成的色彩对比效果称为明度 对比。它是色彩对比的一个重要方面，是决定色彩方案感觉明快、清晰、沉闷、柔和、强烈、朦胧与否的关键。 其对比强决于色彩在明度等差色级数，通常把1——3划为低明度区，8——10划为高明度区，4——7划为中明度区。（图）在选择色彩进行组合时，当基调色与对比色间隔距离在5级以上时，称为长（强）对比，3——5级时称为中对比，1——2级时称为短（弱）对比。据此可划分为九种明度对比基本类型。（图） （1）高长调 如10：8：1等，其中10为浅基调色，面积应大，8为浅配合色，面积也较大，1 为深对比色，面积应小。该调明暗反差大，感觉刺激、明快、积极、活泼、强烈。 （2）高中调 如10：8：5等，该调明暗反差适中，感觉明亮、愉快、清晰、鲜明、安定。 （3）高短调 如10：8：7等，该调明暗反差微弱，形象不分辩，感觉优雅、少淡、柔和、高贵、软弱、朦胧、女性化。 （4）中长调 如4：6：10或7：6：1等，该调以中明度色作基调、配合色，用浅色或深色进行对比，感觉强 硬 、稳重中显生动、男性化。 （5）中中调 如4：6：8或7：6：3等，该调为中对比，感觉较丰富。 （6）中短调 如4：5：6等，该调为中明度弱对比，感觉含蓄、平板、模糊。 （7）低长调 如1：3：10等，该调深暗而对比强烈，感觉雄伟、深沉、警惕、有爆发力。 （8）低中调 如1：3：6等，该调深暗而对比适中，感觉保守、厚重、朴实、男性化。 （9）低短调 如1：3：4等，该调深暗而对比微弱，感觉沉闷、忧郁、神秘、孤寂、恐怖。 另外，还有一种最强对比的1：10最长调，感觉强烈、单纯、生硬、锐利、眩目等。 &lt;三&gt;纯度对比的基本类型 两种以上色彩组合后，由于纯度不同而形成的色彩对比效果称为纯度对比。它是色彩对比的另一个重要方面，但因其较为隐蔽、内在，故易被。在色彩设计中，纯度对比是决定色调感觉华丽、高雅、古朴、粗俗、含蓄与否的关键。 其对比强弱程度取决于色彩在纯度等差色标上的距离，距离越长对比越强，反之则对比越弱。 如将灰色至纯鲜色分成10个等差级数，通常把1——3划为低纯度区，8——10划为高纯度区，4——7划为中纯度区（图）。在选择色彩组合时，当基调色与对比色间隔距离在5级以上时，称为强对比；3——5级时称为中对比；1——2级时称为弱对比。据此可划分出九种纯度对比基本类型。（图） （1）鲜强调 如10：8：1等，感觉鲜艳、生动、活泼、华丽、强烈。 （2）鲜中调 如10：8：5等，感觉较刺激，较生动。 （3）鲜弱调 如10：8：7等，由于色彩纯度都高，组合对比后互相起着抵制、碰撞的作用，故感觉刺目、俗气、幼稚、原始、火爆。如果彼此相距离离大，这种效果将更为明显、强烈。 （4）中强调 如4：6：10或7：5：1等，感觉适当、大众化。 （5）中中调 如4：6：8或7：6：3等，感觉温和、静态、舒适。 （6）中弱调 如4：5：6等，感觉平板、含混、单调。 （7）灰强调 如1：3：10等，感觉大方、高雅而又活泼。 （8）灰中调 如1：3：6等，感觉相互、沉静、较大方。 （9）灰弱调 如1：3：4等，感觉雅致、细腻、耐看、含蓄、朦胧、较弱。 另外，还有一种最弱的无彩色对比，如白：黑、深灰：浅灰等，由于对比各色纯度均为零 ，故感觉非常大方，庄重，高雅，朴素。 &lt;四&gt;色彩的面积与位置对比 形态作为视觉色彩的载体，总有其一定的面积，因此，从这个意义上说，面积也是色彩不可缺少的特 性。艺术设计实践中经常会出现虽然色彩选择比较适合，但由于面积、位置控制不当而导致失误的情况 。 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d64d2027ede5c97d34823644b10f0cf0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0b502111728d050dbae6e830641f2f6/" rel="bookmark">
			全排列优化问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天看到一个比较有意思的解法来接全排列问题，能够将代码优化的比较多。
问题描述是这样的：
对于长度为 5 位的一个 01 串，每一位都可能是 0 或 1，一共有 32 种可能
。它们的前几个是：
00000 00001 00010 00011 00100
请按从小到大的顺序输出这 32 种 01 串。
输入格式本试题没有输入。
输出格式
输出 32 行，按从小到大的顺序每行一个长度为 5 的 01 串
看到题的时候首先想到是用深搜的办法来写。 时间复杂度为O（n^5)
代码我就不放了，直接放出比较简单的解法。
#include&lt;stdio.h&gt; int main() { for(int i=0;i&lt;32;i++) printf("%d%d%d%d%d\n",i/16%2,i/8%2,i/4%2,i/2%2,i%2); return 0; } 一共五行代码，时间复杂度为O(n) 转载于:https://www.cnblogs.com/cong12586/p/10548625.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e9f1275508438e550486f47631e5ad8/" rel="bookmark">
			k8s ingress 理解及配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ingress: 入口，负责统一管理外部对k8s cluster中service的请求。通过定义Ingress Resoucre（Ingress，Ingress Controller，Ingress Service）等实现。
internet | [ Ingress ] --|-----|-- [ Services ] 使用Ingress的好处：
1. 端口管理。减少不必要端口暴露，便于管理。
所有的请求，通过Ingress对应的IP：PORT进入，过滤/转发/负载均衡到相应的service/pod。
k8s现在提供三种暴露服务的方式：LoadBlancer、NodePort 、Ingress。
NodePort会在每个node上暴露对应的port，不便管理。
2. 动态配置服务
以Ingress Nignx为例，实现原理如下。
Ingress Contronler 通过与 Kubernetes API 交互，能够动态的获取cluster中Ingress rules的变化，生成一段 Nginx 配置，再写到 Nginx-ingress-control的 Pod 里，reload pod 使规则生效。从而实现注册的service及其对应域名/IP/Port的动态添加和解析。
Demo：
1. 配置ingress
apiVersion: extensions/v1beta1 kind: Ingress metadata: name: ingress-nginx annotations: nginx.ingress.kubernetes.io/rewrite-target: / spec: rules: - host: java-application.local http: paths: - path: /spring-boot-demo backend: serviceName: spring-boot-demo servicePort: 8080 （注：java-application.local是配置的指向k8s所在IP的域名，eg: minikube环境下，指向minikube ip, 访问 java-application.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e9f1275508438e550486f47631e5ad8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4079ede30f72bdd807794c57e0bb6444/" rel="bookmark">
			用 python 实现一个简单的神经网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用 python 实现一个简单的神经网络 1. 前言 让我们先看一个经典的双层神经网络模型，想必大家都很熟悉了。
在这个模型中，有一个输入层、一个输出层和一个隐藏层。但是单纯根据这个模型来看图说话，实现一个神经网络，还是比较困难的。
2. 另一种表示 现在看看这个双层神经网络的另外一种表示方法：
同前面的图相比，有几点区别：
除了输入（x）、输出（y_pred）和隐藏层（h 和 h_relu）这几个表征层之外，另外还有两个网络层 w1 和 w2。可以将 w1 看做输入表示到隐藏表示之间的映射，将 w2 看做隐藏表示到输出表示之间的映射。输入向量的维度为 D_in, 输出向量维度为 D_out，隐藏层向量维度为 H。可以批量执行，每批样本量为 N。在隐藏层内部，使用了 relu 激活函数 3. 反向传播 反向传播中，最重要的是求梯度。在矩阵乘这种场景下如何求梯度呢？
如
h_relu * w2 = y_pred
那么，有了 y_pred 的梯度（grad_y_pred），如何求 h_relu 和 w2 的梯度呢？
很简单：
grad_h_relu = grad_y_pred * w2.T
grad_w2 = h_relu.T * grad_y_pred
等式左边变量的梯度，依赖于等式右边变量的梯度和左边其他变量的现值。具体如何乘，是否需要做转置，可根据矩阵的维度确定。
除了矩阵乘法梯度计算之外，其他梯度计算根据相应情况确定。
4. 实现 有了上面的表示，我们用 numpy 手动实现一个神经网络就比较简单了
# -*- coding: utf-8 -*- import numpy as np N, D_in, H, D_out = 64, 1000, 100, 10 x = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4079ede30f72bdd807794c57e0bb6444/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/925b27fa7d2780f9e36c2965a5ae95e1/" rel="bookmark">
			Altium Designer导出STEP文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Tips：由于我使用的是13版本，没有高版本具有的STEP导出功能，故采用以下方式导出PCB，此种方式对元器件模型支持较差，对模型要求较高的同学，建议还是升级DXP版本
首先在PCB文件中，点击 工具——》遗留工具——》3D显示
在弹出的PCB3D页面中，点击 工具——》导出
这样就得到一个STEP文件了，再打开solidworks，弹出的要求选择空模板选项卡中，全部选择否
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12e45a73d7c8147f3d50d17f064dec44/" rel="bookmark">
			数据结构：哈希表函数构造和冲突解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		哈希表 哈希函数：记录的存储位置和它的关键字之间建立一个确定的对应关系。
冲突：对不同的关键字可能得到同一哈希地址，这种现象称为冲突。
哈希函数构造方法 1.直接定址法 取关键字或关键字的某个线性函数值为哈希地址，即：
或
2.数字分析法 3.平方取中法 取关键字平方后的中间几位为哈希地址。这是一种较常用的构造哈希函数的方法。一个数平方后的中间几位数和数的每一位都相关。
4.折叠法 5.除留余数法 取关键字被某个不大于哈希表表长m的数p除后所得余数为哈希地址，即
这是最简单也是最常用的构造哈希函数的方法。不仅可以对关键字直接取模，也可以在折叠，平方取中等运算之后取模。
6.随机数法 冲突处理方法 1.开放定址法 为哈希函数；为增量序列，可有下列三种取法：
，称为线性探测再散列；，称为二次探测再散列；为伪随机数列，称为伪随机探测再散列。 2.再哈希法 均是不同的哈希函数，即在同义词产生地址冲突时计算另一个哈希函数地址，直到冲突不再发生，但是增加了计算时间。
3.链地址法 将所有关键字为同义词的记录存储在同一线性链表中。
平均查找长度以牛客网中的一个题目举例：
设散列表的长度为10，散列函数H(n)=n mod 7，初始关键字序列为 (33，24，8，17，21，10)，用链地址法作为解决冲突的方法，平均查找长度是（）：
33/7=5, 查找33需要1次；
24/7=3,查找24需要1次；
8/7=1,查找8需要1次；
17/7=3,查找17需要2次；
21/7=0,查找21需要1次；
10/7=3,查找10需要3次；
ASL=每个关键字查找的次数之和/关键字的个数=（1+1+1+2+3+1）/6=1.5
4.建立一个公共溢出区 哈希表的查找及分析 哈希表的装填因子定义为
，
为表中填入的记录数，为哈希表的长度。标志着哈希表的装满程度。
线性探测再散列的哈希表查找成功时的平均查找长度
，
随机探测再散列，二次探测再散列查找成功时平均查找长度
，
链地址法处理冲突的哈希表查找成功时的平均查找长度为
。
参考：
数据结构（c语言版），严蔚敏
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9db76e93de7a8a2236d980b160101cef/" rel="bookmark">
			算法训练 2的次幂表示（ C语言版   分治&#43;递归 ）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 任何一个正整数都可以用2进制表示，例如：137的2进制表示为10001001。
将这种2进制表示写成2的次幂的和的形式，令次幂高的排在前面，可得到如下表达式：137=2^7+2^3+2^0
现在约定幂次用括号来表示，即a^b表示为a（b）
此时，137可表示为：2（7）+2（3）+2（0）
进一步：7=2^2+2+2^0 （2^1用2表示）
3=2+2^0
所以最后137可表示为：2（2（2）+2+2（0））+2（2+2（0））+2（0）
又如：1315=2^10+2^8+2^5+2+1
所以1315最后可表示为：
2（2（2+2（0））+2）+2（2（2+2（0）））+2（2（2）+2（0））+2+2（0）
输入格式 正整数（1&lt;=n&lt;=20000）
输出格式 符合约定的n的0，2表示（在表示中不能有空格）
样例输入 137
样例输出 2(2(2)+2+2(0))+2(2+2(0))+2(0)
样例输入 1315
样例输出 2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)
解题思路 这道题就是一种分治的思想，把问题的规模不断缩小，就是先把一个数分为划分为他的二进制表示形式，然后只允许二进制的十进制必须小于8，不断进行递归把数变小，然后就按他给的规则输出，但是我的+位置有点问题，最后通过暴力的方法来纠正（此处的判断条件我很久没想出来，只能暴力解决这个问题）。 #include &lt;stdio.h&gt; #include &lt;string.h&gt; char mystr[2000]; //应为我最后要强制改格式 所以用字符数组来存 int m; int min=0; int findT(int n){ int i=0,j,k,sum=0; char a[100000]; k=n; if(n==2||n==1|| n==0) return ; while(n){ // 二进制表示形式 if(n%2==0) a[i]='0'; else a[i]='1'; n/=2; i++; } if(k!=m) strcat(mystr,"2("); for(j=i-1;j&gt;=0;j--) {	if(a[j]=='1') {	if(j==2) strcat(mystr,"2(2)"); if(j==2&amp;&amp;(a[1]=='1'||a[0]=='1')) strcat(mystr,"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9db76e93de7a8a2236d980b160101cef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dd7239c5ee1f8aabaa69241ceed81a5/" rel="bookmark">
			Dart学习（17）：静态static
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		静态变量 static定义 声明
class People { static String name = 'abcd'; } 调用
静态变量可以通过外部直接访问,不需要将类实例化
print(People.name); 函数内部访问 实例化后的类也可以访问该静态变量
声明
class People { static String name = 'abc'; void show() { print(name); } } 调用
var p = new People(); p.show(); 不能用 this 因为静态变量实际上存在于类中,而不是实例本身
class People { static String name = 'abc'; void show() { print(this.name);//错误 } } 静态方法 静态方法可以通过外部直接访问
声明
class People { static String name = 'abc'; static void printName() { print(name); } } 调用
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0dd7239c5ee1f8aabaa69241ceed81a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a1f59bbe87e6fe657908c7ecd0298e1/" rel="bookmark">
			浅谈C语言主函数参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言主函数参数 C语言的主函数，恐怕稍微学过点C语言的人都知道是主函数是什么，从我们第一天开始学C语言的时候就知道不管写什么程序，总之先写这一段就对了。
#include&lt;stdio.h&gt; int main() { return 0; } 虽然有些地方在教的时候是void main()或者直接main()如此然后直接写后面的，但是在这里我不建议这么写，首先他是不标准的，其次在少数的开发环境中写成void main()是会报错的（我曾经就遇到过这样的坑，具体是哪个开发环境忘记了）！切忌！切忌！切忌！
我们在写C代码的时候都是习惯性的新建空项目然后自己添加.cpp文件，但是可能有部分人习惯直接新建控制台程序，然后可能就会看到这么一段代码
#include&lt;stdio.h&gt; int main(int argc,char *argv[])	//char *argv[]有时也可能是char **argv { return 0; } 那肯定就会有人问mian函数里的两个参数是什么，有什么用，怎么用。那两个参数是负责接收指令行参数的，很多在linux gcc或者g++下编译过c程序的人都知道他的指令格式是：
gcc 源文件名 -o 生成文件名 没错这里的”源文件名“、“-o”、“生成文件名”都是指令行参数。口说无凭，直接上代码：
#include&lt;stdio.h&gt; int main(int argc,char*argv[]) { printf("%d\n",argc); for(int i=0;i&lt;argc;i++) printf("%s\n",argv[i]); return 0; } 在这里先简单写一个小代码，相信能看到这里的，基本上也都能看得懂这段代码
然后让我们在控制台下执行这个生成的程序并附上参数
（说明：这里的c 就是我编译生成的程序，因为我的系统环境是kali linux所以与windows略有不同，但是程序执行效果是相同的）运行结果如下（a.c是我的源程序名）：
从上图的执行结果可以得到一个结论，main函数的第一个参数是指令行参数的个数（因为包括输入的文件名，所以这里是4），而第二个参数就是你要传给程序的参数字符串了。
根据上面的执行结果还可以判断出，它会将空格作为参数之间的分割符不管你之间隔几个空格，只要有空格他就视为一个参数结束，例如执行我这里生成的程序：
./c aa bb cc 与
./c aa bb cc 是完全一样的结果
除此之外，还要提到一点，它会将\符号视为完全不存在例如在执行程序时输入：
./c aa\bb cc 最后执行效果是
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45975d437c369d2724fe74b05fc2e0a2/" rel="bookmark">
			CentOS7 安装mysql 8（离线）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、下载rpm安装包
地址 https://dev.mysql.com/downloads/mysql/
二、卸载自带mariaDB
使用命令：yum remove mysql-libs yum
remove mysql-libs
三、安装rpm包
[jk@bogon mysql]$ sudo rpm -ivh mysql-community-libs-8.0.15-1.el7.x86_64.rpm
警告：mysql-community-libs-8.0.15-1.el7.x86_64.rpm: 头V3 DSA/SHA1 Signature, 密钥 ID 5072e1f5: NOKEY
准备中... ################################# [100%]
正在升级/安装...
1:mysql-community-libs-8.0.15-1.el7################################# [100%]
[jk@bogon mysql]$ sudo rpm -ivh mysql-community-libs-compat-8.0.15-1.el7.x86_64.rpm
警告：mysql-community-libs-compat-8.0.15-1.el7.x86_64.rpm: 头V3 DSA/SHA1 Signature, 密钥 ID 5072e1f5: NOKEY
准备中... ################################# [100%]
正在升级/安装...
1:mysql-community-libs-compat-8.0.1################################# [100%]
警告：mysql-community-devel-8.0.15-1.el7.x86_64.rpm: 头V3 DSA/SHA1 Signature, 密钥 ID 5072e1f5: NOKEY
准备中... ################################# [100%]
正在升级/安装...
1:mysql-community-devel-8.0.15-1.el################################# [100%]
[jk@bogon mysql]$ sudo rpm -ivh mysql-community-embedded-compat-8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45975d437c369d2724fe74b05fc2e0a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b81dd4d64bb40ac5b60e9b36aba4344/" rel="bookmark">
			桑基图（Echarts）——自定义风格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		桑基图绘制——使用Echarts 桑基图（Sankey diagram），即桑基能量分流图，也叫桑基能量平衡图。它是一种特定类型的流程图，图中延伸的分支的宽度对应数据流量的大小，通常应用于能源、材料成分、金融等数据的可视化分析。
数据要求： 桑基图理论上只支持有向无环图（DAG, Directed Acyclic Graph），所以要确保可视化数据中的边是无环的。
本篇以北京、上海的移民统计为例，参照Echarts官方提供的示例代码，介绍如何定制自己风格的桑基图。
一、节点和边设置统一风格 第一种样式主要是统一对节点和边进行了风格设置，城市节点统一为深蓝色#1b6199，边为一个渐变效果，效果如下图：
1、数据格式 数据包括城市节点和两城市间的移民统计：
var citylist = [ {name: '北京'}, {name: '上海'}, {name: '广州'}, {name: '深圳'}, {name: '香港'} ]; var population=[ {source: "广州", target: "北京", value: 4567}, {source: "广州", target: "上海", value: 2060}, {source: "深圳", target: "北京", value: 1234}, {source: "深圳", target: "上海", value: 124}, {source: "香港", target: "北京", value: 3714}, {source: "香港", target: "上海", value: 3234} ]; 2、样式配置 系列列表series中itemStyle用来设置节点的样式，lineStyle用来设置边的样式。注意：在series中设置的样式应用于所有数据的渲染。具体代码如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b81dd4d64bb40ac5b60e9b36aba4344/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16f5cc1ccfe0f85e20cd2e6428b268fc/" rel="bookmark">
			Linux终端编译并执行Java文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、先创建java项目目录，名称MyTest。
mkdir MyTest 2、在项目中创建src和bin目录，src下用于存放 “.java” 文件，bin下存放 “ .class ” 文件。
cd MyTest mkdir src bin 3、在src下创建包com.stu。
mkdir -p src/com/stu 4、在包中编写java文件，文件名为Hello.java。
vi src/com/stu/Hello.java package com.stu; // 包名 public class Hello{ public static void main(String[] args){ System.out.println("Hello world"); } } // vim中编写，完成后保存退出。 5、在bin目录下创建用于存放MyTest项目中生成的class文件的目录。
mkdir bin/MyTest 6、编译java文件，将生成的编译文件存放在bin/MyTest下，其中的com/stu目录会自动创建，因为“package com.stu;”语句。“-d”表示指定生成class文件的位置。
javac ./src/com/stu/Hello.java -d ./bin/MyTest/ 7、执行java文件。“-cp”表示classpath，后跟路径，创建的是什么就指定哪里，否则会报错。之后再指定包名.类名即可运行。
java -cp ./bin/MyTest/ com.stu.Hello 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c066d99e81e1561b03d3ca38c6bbd5f/" rel="bookmark">
			java生成唯一订单号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/** * 生成唯一订单号 * 规则：四位随机数+"M"+格式化到秒的时间+"R"+六位随机数 */ public static String getBillCode() { Random rd = new Random(); // 创建随机对象 String n = ""; //保存随机数 int rdGet; // 取得随机数 do { if (rd.nextInt() % 2 == 1) { rdGet = Math.abs(rd.nextInt()) % 10 + 48; // 产生48到57的随机数(0-9的键位值) }else{ rdGet = Math.abs(rd.nextInt()) % 26 + 97; // 产生97到122的随机数(a-z的键位值) } char num1 = (char) rdGet; //int转换char String dd = Character.toString(num1); n += dd; } while (n.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c066d99e81e1561b03d3ca38c6bbd5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25adf11e087a29549daf5ed6b71d35e7/" rel="bookmark">
			restful风格的API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		restful风格的API 要说RESTful首先来说说REST – REpresentational State Transfer （表述性状态传递）
REST – REpresentational State Transfe 表述性状态转移是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是RESTful。需要注意的是，REST是设计风格而不是标准。
表属性状态转移 表属性状态转移，简单来说就是资源在网络中以某种表现形式进行状态转移。
用一句话来说就是：
使用URL定位资源，用HTTP动词（GET,POST,DELETE,PUT等）描述操作。
既然是用HTTP动词进行操作。那么需要了解这里列出的4.5个非常重要的HTTP动作，这里的0.5个是指PATCH，因为它在功能上与PUT非常类似，剩下4个通常被API开发人员两两结合使用
GET（SELECT）：从服务器获取一个指定资源或一个资源集合；
POST（CREATE）：在服务器上创建一个资源；
PUT（UPDATE）：更新服务器上的一个资源，需要提供整个资源；
PATCH（UPDATE）：更新服务器上的一个资源，只提供资源中改变的那部分属性；
DELETE（DELETE）：移除服务器上的一个资源；
还有两个不常见的HTTP动作：
HEAD – 获取一个资源的元数据，例如一组hash数据或者资源的最近一次更新时间；
OPTIONS – 获取当前用户（Consumer）对资源的访问权限；
restful风格的API api API是服务提供方和使用方之间的契约，打破该契约将会给服务端开发人员招来非常大的麻烦，这些麻烦来自于使用API的开发人员，因为对API的改动会导致他们的移动app无法工作。一个好的文档对于解决这些事情能起到事半功倍的作用，但是绝对多数程序员都不喜欢写文档。如果想让服务端的价值更好的体现出来，就要好好设计API。通过这些API，你的服务/核心程序将有可能成为其他项目所依赖的平台；你提供的API越易用，就会有越多人愿意使用它。规划API的展示形式可能比你想象的要简单，首先要确定你的数据是如何设计以及核心程序是如何工作的。
也就是说Server提供的RESTful API中，URL中只使用名词来指定资源，原则上不使用动词。“资源”是REST架构或者说整个网络处理的核心。
URL命名 Server提供的RESTful API中，URL中只使用名词来指定资源，原则上不使用动词。“资源”是REST架构或者说整个网络处理的核心。比如：
http://api.qc.com/v1/profile: 获取某人的详细信息; URL是对资源描述的抽象，资源的描述一定是名词，如果引入了动词，那这个URL就表示了一个动作，而非一个资源，这样就偏离了REST的设计思想
版本化api 在 RESTful API 中，API 接口应该尽量兼容之前的版本。但是，在实际业务开发场景中，可能随着业务需求的不断迭代，现有的 API 接口无法支持旧版本的适配，此时如果强制升级服务端的 API 接口将导致客户端旧有功能出现故障。实际上，Web 端是部署在服务器，因此它可以很容易为了适配服务端的新的 API 接口进行版本升级，然而像 Android 端、IOS 端、PC 端等其他客户端是运行在用户的机器上，因此当前产品很难做到适配新的服务端的 API 接口，从而出现功能故障，这种情况下，用户必须升级产品到最新的版本才能正常使用。
为了解决这个版本不兼容问题，在设计 RESTful API 的一种实用的做法是使用版本号。一般情况下，我们会在 url 中保留版本号，并同时兼容多个版本。
Get方法和查询参数不应该涉及状态改变 使用PUT, POST 和DELETE 方法 而不是 GET 方法来改变状态，不要使用GET 进行状态改变:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25adf11e087a29549daf5ed6b71d35e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8959748091b7c988511987c3e7877ed3/" rel="bookmark">
			java中char对应的ASCII码的转化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 java中char对应的ASCII码的转化
java中，char类型变量可以强制转化为int类型变量，int类型变量也可以强制转化成char类型的变量： char c='a'; int i=98; System.out.println((int)c); System.out.println((char)i); 对于数组类型，其下标为int类型，所以可以直接使用char类型变量，默认强制转换： int[] array=new int[100]; for(int i=0;i&lt;array.length;i++){ array[i]=i; } char c='a'; System.out.println(array[c]); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/000fc0d08de8d3b258242eb7fe1b4f75/" rel="bookmark">
			【巨人的肩膀上制造世界】——1——Unity3D实用插件之地形插件Gaia，高质高效搭建你的地形，全中文教程！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unity3D快速搭建你的高质量地形，最好用的Unity3D地形制作插件Gaia，全中文教程 目录 1、博文介绍
2、Gaia3分钟制作地形效果展示
3、Gaia导入
4、Gaia编辑栏中文详解
（1）Gaia编辑栏
（2）全中文译解
5、利用Gaia快速的制作地形
6、自定义地形贴图，植物素材
7、自定义预设物
8、自定义滤镜
9、自定义天空盒和灯光和环境音等
9、自定义水效果
10、推送
11、结语
1、博文介绍 博主准备新开一个系列专门来介绍Unity内各类超级实用和好用的插件，这个系列就叫做【巨人的肩膀上制造世界】，做这个系列的目的呢就是希望能够充分利用前辈们的车轮子，让开发变得更简单更开心，因为多数插件为外国人制作，所以这一系列博文将对插件进行非常详细的中文介绍，此为该系列第一篇博文，有兴趣的同学可以关注博主，留意后续的文章，本篇文章将介绍一款Unity制作地形的插件——Gaia，该插件将极大的提高制作地形的效率和效果。
2、Gaia3分钟制作地形效果展示 3、Gaia导入 从商店直接导入或者直接运行插件包，这里需要注意到是导入Unity后需要继续加载一个依赖包，位置是在Gaia-Dependencies-Gaia Dependencies，直接双击导入即可。
4、Gaia编辑栏中文详解 （1）Gaia编辑栏 Windows-Procedural Words-Gaia-Show Gaia Manager,或者直接Ctrl + G快捷键。
（2）全中文译解 1、Controller创建玩家的模式，可以选择第一人称，第三人称或者飞行模式2、Environment选择不同环境的模式，对应环境对应的默认资源不同3、Renderer选择渲染的模式4、Terrain Size 选择生成地形的尺寸
5、Terrain Defaults设置地形的默认参数，可以在资源内调整地形的各种参数6、Terrain Resources设置地形的默认资源，可以在设置呢调整默认资源，植物贴图等7、GameObject Resources设置地形的默认资源，可以在设置呢调整默认资源，建筑物岩石等8、Set Linear Deferred改变渲染模式，伽马或者线性9、Create Terrain &amp; Show Stamper创建地形和对应的地形模具10、 Enhance Terrain
地形细节编辑工具11、Create Spawners创建卵，这个卵的含义是指初始的资源，作为被复制的模板12、Create Player，Post FX，Screenshotter,skies,Water&amp;Wind创建玩家，风，水效果，滤镜13、Bake Lighting烘焙灯光 14、Show Session Manager 15、Create Terrain创建地形16、Show Stamper 17-25、创建地形模具穿件各种植物模型的卵 26、Add Character添加玩家控制27、Add Wind Zone添加风28、Add Water添加水效果29、Add Screen Shotter添加屏幕拍摄 30、Show Scanner创建一个扫描仪可以通过拖拽图片快速的生成一个地形的印章31、Show Visualiser可视化的查看地形上是否适合生成物体32-37、 各个资源的纹理导出器 38、About环境设置介绍39、Get full Version环境例子版本40、Morning天气设置为早晨41、Day 天气设置为白天42、Evening 天气设置为晚上43、Night天气设置为深夜44、Default Procedural默认设置45、Add Global Reflection Probe添加灯光探针46、Remove Global Reflection Probe移除灯光探针47、Bake Lighting烘焙光照48、Default Morning滤镜早晨49、Default Day滤镜白天50、Default Evening 滤镜夜晚51、Default Night滤镜深夜52、Remove Post Processing移除滤镜 53、Add Water添加水效果54、Deep Blue Style水面效果改为深蓝55、Clear Blue Style 水面效果清除深蓝56、Toxic Green Style 水面效果改为深绿57、Cyan Style水面效果改为青色58、Remove Water移除水效果59、Remove Underwater Fx移除水下滤镜 60、Gaia的一些文档视频资料和支持信息 5、利用Gaia快速的制作地形 点击GaiaManager的Creat Terrain &amp; Show Stamper生成地形和印章，找寻一个高度贴图，拖拽到Hierarchy面板上刚生成的Stamper的Stamp Preview，再点击下方的Stamp，地形就会根据高度贴图生成。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/000fc0d08de8d3b258242eb7fe1b4f75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a34493421b00ef82306ec1a37b51a5ba/" rel="bookmark">
			【Vue】判断设备是移动端还是pc端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经常在项目中会有支持 pc 与手机端需求。并且pc与手机端是两个不一样的页面。这时就要求判断设置，根据不同的设置跳转不同的路由。
直接上代码
//在 router/index.js 中有两个页面。 export default new Router({ mode: 'history', routes: [ { path: '', redirect: '/pc_index' }, { path: "/pc_index", // pc端首页 name: PcIndex, component: PcIndex }, { path: '/m_index', // 手机端首页 name: MIndex, component: MIndex } ] }); 在 App.vue 的 mounted 方法中对设置进行判断，如下:
//App.vue mounted() { if (this._isMobile()) { alert("手机端"); this.$router.replace('/m_index'); } else { alert("pc端"); this.$router.replace('/pc_index'); } } 其中 _isMobile() 方法如下:
//App.vue _isMobile() { let flag = navigator.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a34493421b00ef82306ec1a37b51a5ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/212d83fb267459b54060c426c0f02d51/" rel="bookmark">
			ios 代码支持cocoapod spec写法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pod::Spec.new do |s|
s.name = "QTcocoapodsTest" # 项目名称
s.version = "0.0.1" # 版本号 与 你仓库的 标签号 对应
s.license = "MIT" # 开源证书
s.summary = "私人pod代码" # 项目简介
s.homepage = "https://github.com/HelloBie/cocoapods" # 仓库的主页
s.source = { :git =&gt; "https://github.com/HelloBie/cocoapods.git", :tag =&gt; "#{s.version}" }#你的仓库地址，不能用SSH地址
s.source_files = "QTCore/*.{h,m}" # 你代码的位置， BYPhoneNumTF/*.{h,m} 表示 BYPhoneNumTF 文件夹下所有的.h和.m文件
s.requires_arc = true # 是否启用ARC
s.platform = :ios, "7.0" #平台及支持的最低版本
s.frameworks = "UIKit", "Foundation" #支持的框架
# s.dependency = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/212d83fb267459b54060c426c0f02d51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5396653ff634ec291d622efd59d94c5/" rel="bookmark">
			均值之差的置信区间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们想检验一种低脂节食能否帮助人们减肥。100个随机抽取的人采用低脂节食，另100个随机抽取的肥胖者作为对照，对照组少吃几乎等量的食物。这样，第二组就是普通节食的对照组，第一组是低脂节食实验组。4个月后，第一组的体重减轻均值是9.31磅，标准差是4.67磅。对照组体重减轻均值是7.40磅，标准差是4.04磅。
第一组：均值=9.31，标准差=4.67
第二组：均值=7.40，标准差=4.04
均值之差 = 9.31-7.40=1.91
我们要在1.91周围找到95%的置信区间。
随机抽样均值之差分布 近似服从正态分布，该分布均值为： 1.91，标准差为：根号下（4.674.67/100+4.044.04/100）=0.617
该分布的95%置信区间的Z值为 1.96，也就是均值左右1.96个标准差距离的面积为95%，1.96*0.617=1.21
95%置信区间下： 1.91-1.21 &lt; 抽样均值差 &lt; 1.91+1.21 即：0.7 &lt;抽样均值差&lt;3.12
也就是样本均值之差1.91 有 95%的几率落在 随机抽样分布（均值之差分布）的均值的左右1.96个标准差距离内。 也可以理解为
分布的均值(随机抽样的均值差的分布)有95%的概率落在 样本均值差1.91左右1.96个标准差范围内。
零假设：低脂节食对减肥无效（相对于普通节食）
备择假设：低脂节食对减肥有效（相对于普通节食）
零假设下：低脂组的总体均值 - 对照组的总体均值 = 0 即低脂组的抽样均值 - 对照组的抽样均值 = 0
也就是说总体均值差=0 即： 随机抽样均值差=0
备择假设下：低脂组的总体均值 - 对照组的总体均值 &gt; 0 即低脂组的抽样均值 - 对照组的抽样均值 &gt; 0
也就是说总体均值差&gt;0 即： 随机抽样均值差&gt;0
假设检验的显著性水平5%
零假设下：抽样均值差1.91达到（均值差为0）的95%范围内，择我们拒绝零假设，选择备择假设。
均值差分布近似服从正太分布，大样本下，查Z分布表可得：单侧95%的Z值为1.65
标准差为：0.617 则1.65*0.617 = 1.02
所以如果假设低脂节食对减肥无效，随机抽样的均值差只有5%的概率大于1.02.
1.91 &gt; 1.02,概率只有5%，所以拒绝零假设，选择备择假设。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d579cfcc6b7442005a08e1e79189e00d/" rel="bookmark">
			RN Exception: Warning: Functions are not valid as a React child. This may happen if you return a ...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		异常 ReactNativeJS: Warning: Functions are not valid as a React child. This may happen if you return a Component instead of &lt;Component /&gt; from render. Or maybe you meant to call this function rather than return it. in RCTView (at View.js:60) in View (at createAnimatedComponent.js:154) in AnimatedComponent (at Header.js:443) in RCTView (at View.js:60) in View (at Header.js:488) in RCTView (at View.js:60) in View (at Header.js:624) in RCTView (at View.js:60) in View (at createAnimatedComponent.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d579cfcc6b7442005a08e1e79189e00d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35a074ef754009810c44f22293310c53/" rel="bookmark">
			【已解决】阿里云配置安全组后，仍无法访问端口问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章首发于如下链接：http://80sdianying.xyz/?id=8
最近在搭python的falsk服务器，遇到一个问题，在服务器运行python程序后，外网无法访问到该程序，程序中已经设置host为0.0.0.0，而且也配置了阿里云的安全组，Ping服务器的IP地址能Ping通。
耗费了很长时间查找方法，终于找到了解决办法。
（在此感谢该博主，附上原文链接https://blog.csdn.net/YanlongFight/article/details/79252227）
造成该问题的原因是服务器防火墙的问题，阿里云服务器在访问端口时，除了要配置安全组，有时候还要配置一下防火墙，配置方法为：
一，使用命令 vim /etc/sysconfig/iptables，如果没有该文件则创建；
二，使用命令 -A INPUT -m state –state NEW -m tcp -p tcp –dport 5000 -j ACCEPT 来配置防火墙，允许5000端口通过防火墙；
三，使用命令 service iptables restart使其重启生效；
之后就搞定了，不过令我奇怪的是昨天的时候没进行配置，也是可以访问的，但是今天什么也没改动，就不能访问了，配置之后才能访问，这个问题还有待考究。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0df718be815505abf3794eb18f230c3c/" rel="bookmark">
			CentOS包安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看已安装包信息 经常要看看安装了某个包没有：
rpm -qa | grep 包名关键字
这样可以查到具体的包名，然后
rpm -ql 确切的包名
就是显示出这个包安装的所有问题的位置，比如bin doc config等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a2281dd165efb0d676164aeb886257e/" rel="bookmark">
			机器视觉中非常好的github仓库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 # AwesomeComputerVision **Multi-Object-Tracking-Paper-List** https://github.com/SpyderXu/multi-object-tracking-paper-list **awesome-object-detection** https://github.com/hoya012/deep_learning_object_detection **awesome-image-classification** https://github.com/weiaicunzai/awesome-image-classification **Visual-Tracking-Paper-List** https://github.com/foolwood/benchmark_results **awesome-semantic-segmentation** https://github.com/mrgloom/awesome-semantic-segmentation **awesome-human-pose-estimation** https://github.com/cbsudux/awesome-human-pose-estimation **awesome-Face-Recognition** https://github.com/ChanChiChoi/awesome-Face_Recognition 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af253b4433335f38f2e9cb6b091a25b4/" rel="bookmark">
			Python 知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python 知识点 1.对不定长参数的理解？ 不定长参数有两种：*args和**kwargs；
*args：是不定长参数，用来将参数打包成tuple给函数体调用；
**kwargs:是关键字参数，打包关键字参数成dict给函数体调用在定义函数的时候不确定要传入的参数个数会有多少个的时候就可以使用不定长参数作为形参。
2.对缺省参数的理解？ 缺省参数指在调用函数的时候没有传入参数的情况下,调用默认的参数,在调用函数的同时赋值时,所传入的参数会替代默认参数。
3.什么是lambda函数？它有什么好处？写一个匿名函数求两个数的和。 lambda函数是匿名函数；使用lambda函数能创建小型匿名函数。这种函数得名于省略了用def声明函数的标准步骤；
f = lambda x,y:x+y print(f(2017,2018)) 4.深拷贝和浅拷贝的区别？ （1）python中的拷贝分为浅拷贝和深拷贝，若不特殊说明拷贝一般是浅拷贝
（2）浅拷贝是将对象顶层拷贝，拷贝了引用，并没有拷贝内容，原对象改变新对象也跟着改变
（3）深拷贝是对一个对象的所有层次的拷贝（递归），但是修改原来的值，新对象不受影响
（4）浅拷贝对于可变类型和不可变类型是不同的，对于可变类型只拷贝顶层，不可变类型依然是原来的对象
5.什么是可变、不可变？元组里添加字典，会改变id吗？ （1）可变不可变指的是内存中的值是否可以被改变，不可变类型指的是对象所在内存块里面的值不可以改变，有数值、字符串、元组；可变类型则是可以改变，主要有列表、字典
（2）元组的顶层元素中包含可变类型，在可变类型中修改或添加字典id不会改变
6.生成器、迭代器的区别？ （1）在Python中，一边循环一边计算的机制，称为生成器：generator，生成器是可以迭代对象，但是生成器可以通过send传值返回到前面；
（2）迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。
迭代器是一个可以记住遍历的位置的对象。 7.range（）和xrange（）函数的用法？ （1）range(start,stop,step)函数按照从start到stop每个step生成一个数值，生成的是列表对象，一次性将所有数据都返回；
（2）xrange(start,stop,step)函数按照从start到stop每个step生成一个数值，返回的是可迭代对象，每次调用返回其中的一个值
8.对装饰器的理解，写出一个装饰器用来打印函数的执行时间。
装饰器本质上是一个Python函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象
import time def timeit(func): def wrapper(): start = time.clock() func() end =time.clock() result = end - start print（end） return wrapper @timeit def foo(): Print(‘函数执行时间’) foo() 什么单例模式，其应用场景都有哪些？ class Single(object): def __new__(cls, *args, **kwargs): if not hasattr(cls, '_instance'):（hasattr判断里面有没有某个属性或者方法） cls._instance = super(DanLi, cls).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af253b4433335f38f2e9cb6b091a25b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eaea9c0031fd403741296a24ac824240/" rel="bookmark">
			flutter 依赖库版本不一致问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近正好遇见版本库依赖的问题：我是直接调整项目版本，找合适的固定依赖库版本
一早看见郭神发的文章记录一下：
flutter的版本管理
在我们的开发过程中遇到了一个问题，就是各个开发者使用的flutter sdk版本不一致，导致一些库无法运行，在网上也遇到有相同问题的人，提出了模仿gradle wrapper来做一个flutter_wrapper的思路。于是我根据自己的需要写了一个flutter_wrapper的小工具。它的主要作用是统一开发人员的本地flutter环境。
使用说明
在你的项目根目录中执行命令下载脚本
curl -O https://raw.githubusercontent.com/zakiso/flutterw/master/flutterw &amp;&amp; chmod 755 flutterw
下载好脚本后在根目录中使用
./flutterw init
该命令会收集你当前系统中的flutter版本，并将相关信息写入flutter_wrapper.properties文件中，团队中所有成员都会以该版本号做为该项目的标准版本
将flutterw文件和flutter_wrapper.properties文件添加到git中提交到仓库里
其他成员拉取代码后在项目中使用flutter命令的地方使用./flutterw代替，如果使用ide请选择home目录下对应版本的sdk包
flutterw做了什么？
使用flutterw的时候会获取当前目录下的flutter_wrapper.properties文件中的版本号
去用户的${HOME}/flutter_wrapper/{版本号}/ 目录下查找是否有该版本sdk
如果没有该版本sdk会下载下来，然后使用该目录下的sdk执行命令
注意事项
如果flutter版本是preview的版本是直接使用master的最新代码来管理的。大家可以查看源码很简单，根据自己的需要定制。
项目demo我已经传到github中：有遇到问题的可以参考项目源码
https://github.com/zakiso
原文链接：
https://mp.weixin.qq.com/s/QoevlX6pUecbX56nCDEgCA 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49b7b1e83df42cb6327ad6cde7e3cf66/" rel="bookmark">
			tf.Variable用法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://tensorflow.google.cn/api_docs/python/tf/Variable
通过创建Variable类的实例向graph中添加变量。
Variable()需要初始值，一旦初始值确定，那么该变量的类型和形状都确定了。
更改值通过assign方法。
想要改变形状，需要使用assign+validate_shape=False。
想要运行graph，必须先显式初始化变量。
初始化变量3种方法：
①运行它的initializerop，
②从save file中恢复变量
③运行 assign操作，把初值赋给变量。
# Launch the graph in a session. with tf.Session() as sess: # Run the variable initializer. sess.run(w.initializer) # ...you now can run ops that use the value of 'w'... 但是最常用的初始化方式，是global_variables_initializer()，它可以添加一个op到graph里，这个op可以初始化所有变量。在launch图后，运行这个op。
# Add an Op to initialize global variables. init_op = tf.global_variables_initializer() # Launch the graph in a session. with tf.Session() as sess: # Run the Op that initializes global variables.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49b7b1e83df42cb6327ad6cde7e3cf66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/100bddbc73b5b3523c7c6eda818292c0/" rel="bookmark">
			sublime3  工具中，编译java 并输出到该控制台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.在jdk安装目录的bin 目录下，新建一个runJava.bat文件，是bat！！！并且字符集必须是：ANSI （在文本编辑器下另存为可以选择），然后复制下面代码
@echo off
cd %~dp1
echo Compiling %~nx1......
if exist %~n1.class (
del %~n1.class
)
javac -encoding UTF-8 %~nx1
if exist %~n1.class (
echo ------Output------
java %~n1
)
2.在sublime 的安装目录下（安装目录），找到Packages 文件夹下，找到Java.sublime-package 文件，用压缩工具打开
修改JavaC.sublime-build文件，把内容换成：
{
"cmd": "runJava.bat \"$file\"",
"file_regex": "^(...*?):([0-9]*):?([0-9]*)",
"selector": "source.java",
"encoding": "UTF-8"
}
然后重启sublime ,完美运行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3cd47c5120f6c7d194e99051a5b6f55/" rel="bookmark">
			python-pygame之旋转图像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用pygame.transform.ratate(Surface, angle)
angle为正，逆时针旋转；为负，顺时针旋转
方法一:
(用库函数写一个自定义函数)
The below example is a bit redundant (and forgets that pygame.transform.rotate returns the rotated surface, it doesn't transform in place) You can simply write it thusly: def __init__(self, image, startangle): ... self.original = image self.rotate(startangle) def rotate(self, angle): self.image = pygame.transform.rotate(self.original, angle) 方法二：
（直接用，但是需要赋值更新）
A good idea in rotating in small angles is to restore the image or sprite to its original picture for example: def __init__(self) .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3cd47c5120f6c7d194e99051a5b6f55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20f6aaf60666436797ee2892c1f713a2/" rel="bookmark">
			【原生JS】写滚动指定位置展示动画
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用原生js做滚动到指定位置展示动画，动画效果用Animate.css 直接上代码
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;滚动可见位置动画&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="http://www.jq22.com/jquery/animate-3.1.0.min.css"&gt; &lt;style&gt; body { overflow-x: hidden; } div { width: 100px; height: 100px; margin: 100px auto 0; background: red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="dream" data-animate="bounceInUp,1s,linear"&gt;&lt;/div&gt; &lt;div class="dream" data-animate="flash,2s,linear"&gt;&lt;/div&gt; &lt;div class="dream" data-animate="pulse,1s,linear"&gt;&lt;/div&gt; &lt;div class="dream" data-animate="rubberBand,1s,linear"&gt;&lt;/div&gt; &lt;div class="dream" data-animate="shake,1s,linear"&gt;&lt;/div&gt; &lt;div class="dream" data-animate="swing,1s,linear"&gt;&lt;/div&gt; &lt;div class="dream" data-animate="tade,1s,linear"&gt;&lt;/div&gt; &lt;div class="dream" data-animate="wobble,1s,linear"&gt;&lt;/div&gt; &lt;div class="dream" data-animate="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20f6aaf60666436797ee2892c1f713a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e03b85e3aa638cf2bbeef5f1247046ac/" rel="bookmark">
			python使用UDP协议进行远程桌面共享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前在写远程桌面共享的时候一直没有思路，直到搜到了这篇文章：
（具体实现原理过程请看原文）
python实现基于UDP的视频直播程序
对我启发很大，但还有两个问题：
1.画质太低，导致连桌面上的文字都难辨认
2.存在色变，画面崩坏
解决办法 import threading import time import numpy import cv2 as cv from PIL import ImageGrab from PIL import Image from io import BytesIO #因为开发需要，我将接收端的IP与端口写进配置文件 ip_inifile=open("ip.ini","r") ipasport=ip_inifile.read() ipAndport=ipasport.split(":")#拆分字符串 ip=ipAndport[0]	#接收端IP port=ipAndport[1]	#接收端端口 def jiep_send(): while True: ip_adder=(ip,int(port)) #截取桌面 img=ImageGrab.grab() #传输使用UDP协议，将图片分辨率变小方便传输，将ANTIALIAS作为第二个参数即可一定程度上提高画质 out=img.resize((650,400),Image.ANTIALIAS) #申请一块内存块 stram_0=BytesIO() #将图片以JPEG格式图片的方式保存至内存块 out.save(stram_0,format='JPEG') #将内存块当作图片文件打开，并转为数组 jp_array=numpy.array(Image.open(stram_0)) stram_0.close() #再申请一个内存块 stram_1=BytesIO() pic=Image.fromarray(jp_array) #将图片保存至新申请的内存块，以JPEG图片格式 pic.save(stram_1,format='JPEG') #提取内存块中的值 jpeg=stram_1.getvalue() stram_1.close() #设置UDP链接 socket_0=socket.socket(socket.AF_INET,socket.SOCK_DGRAM) #是否正常发送 try: socket_0.sendto(jpeg,ip_adder) #断线重连机制，每三秒重拨一次 except Exception as e: while True: try: socket_0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e03b85e3aa638cf2bbeef5f1247046ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d08e9bc513ba9550e8a102eeae9523a7/" rel="bookmark">
			2019年3月份
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3月12日
JDK包含了JRE。如果要运行JAVA程序，需要JRE，如果要编写JAVA程序，需要JDK。
==与equals的区别。对于基本数据类型来说，不能使用equals方法。==方法比较的是它们的值是否相等。对于引用数据类型来说，==比较的是内存地址是否相同。而equals比较的就是两个对象是否相等。如果没有重写hashcode与equals方法，那么会使用父类Object类的equals方法，比较的仍然是内存地址。如果重写了equals方法，那么比较的方法就按照重写后的equals方法。
hashcode相同。equals相同么？不对。比如在JDK1.7版本的HashMap。HashMap底层使用的是“数组+链表”的数据结构。使用链地址法解决哈希冲突。链地址法的表现就在于相同的hash值的键值对组成一个链表，每一个键值对都有它后一个键值对的引用。这样一个一个挂上去，形成一个链表。
基本数据类型：byte short char int float double boolean long
String str=new String("i")创建了几个对象。先在方法区中的常量池创建了一个"i"字符串，然后再在堆内存中创建一个字符串对象。
new StringBuilder("abcdefgh").reverse().toString()；
说出String类型的常用方法。 subString，toUpperCase，toLowerCase，length()，jon()，indexOf
抽象类与接口的区别。一个类只能继承一个抽象类，但是可以实现多个接口。接口中的所有方法与变量都是public类型的，而抽象类不是。然后再扯一波多态，最后说一说一个方法上的参数是抽象类与接口的好处。体现了多态的扩展性与灵活性。
Collection是集合框架顶层容器，而Collections是集合框架的工具类。
Collections.emptyList()；（返回不可变的）。
Collections.sort()；根据自然排序规则排序
任何集合框架的描述，都离不开口诀："序重步"。
3月13日
HashMap 和 Hashtable 有什么区别？
HashMap线程不安全。Hashtable线程安全。
HashMap允许key和value为null，而Hashtable不允许。
一般情况在多线程情况下，不使用Hashtable，取而代之的是ConcurrentHashMap。
说一下 HashMap 的实现原理
HashMap是Map接口的实现。通过put方法存放键值对。使用get方法获取键值对。
在put方法的源码中，首先计算出key的hash值。再通过相关的hash算法算出它在内部数组中的索引。然后查看这个索引上有没有其它值。如果有其它元素的话，说明这发生了hash冲突。在JDK1.7版本里面的处理办法是使用链地址法解决hash冲突。
首先把这组键值对封装成一个节点。节点对象维护了前一个节点的引用与后一个节点的引用。我们会把当前的这组键值对的内存地址告诉前一个节点。这样会在内存中形成一组相同hash值的链表。哈希表中的每个位置永远只保存一个最新加进来的键值对，其他键值对是一个挂一个，这样挂上去的。
影响HashMap的两个参数是“初始容量”和“加载因子"。加载因子是是哈希表在扩容之前可以达到多满的一种尺度。如果加载因子设置过大，那么hash冲突的机会变大，每个链表的长度很长。内存利用率变大，但是长链表导致查询时间变长。加载因子过小，链表长度会变小，查询时间变少，但是内存的空间利用率会变小。
说一下 HashSet的实现原理
HashSet内部其实就是一个HashMap。如果说HashMap的元素是一组键值对，那么HashSet的元素就是键值对的键。 ArrayList 和 LinkedList 的区别是什么？ 一般我比较集合我会从集合是否有序，元素是否可以重复，是不是同步的集合。
ArrayList和LinkedList都是List接口的实现，都是有序的，可以重复的，不同步的。
主要区别在于内部的实现。ArrayList的内部使用的是数组的实现方式。而LinkedList使用的是链表的实现方式。
ArrayList是数组实现，所以查询速度很快，增删慢。
LinkedList是链表实现，查询慢，增删快。
因为他们都是java.util包下的，所以都是不同步的集合，具有快速失败的特性。
快速失败是指，在遍历集合的时候，修改集合将会导致异常的发生。
数组与集合切换
Arrays.asList(...T);
Collection.toArray(T[ ] array);
HashMap与TreeMap的区别
HashMap与TreeMap都是Map接口的实现，存放的是键值对。
HashMap使用的是hash表结构，所以无序。TreeMap使用的是二叉树结构，所以有序。
HashMap与TreeMap中元素都不能重复。
HashMap与TreeMap都是线程不安全的。他们在Java.util包下，所以具有快速失败的特性。
快速失败是指，在遍历集合的时候，修改集合将会导致异常的发生。
ArrayList与Vector的区别
都是有序的，可以重复的。ArrayList不同步，而Vector是同步的。
扩容方面：AraryList每次扩容50%，而Vector扩容一倍。
性能方面：ArrayList的性能由于Vector。
ArrayList与数组的区别
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d08e9bc513ba9550e8a102eeae9523a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c23378b43f0148f3c62a23e6ce9daaf/" rel="bookmark">
			JavaScript中Number的数值范围以及判断
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在日常开发中，我们可能会忽略掉Number类型的取值范围，因为它的取值范围足够大，也足够小（怎么感觉怪怪的），但是当我们的开发涉及到特别大的数值计算时，难免出现超出范围的问题，尽管可能性很小，但是为了严谨，我们也不得不避免这个问题。
那么我们先来说说Number的取值范围。
Number.MIN_VALUE：最小值，值为5e-324
Number.MAX_VALUE：最大值，值为1.7976931348623157e+308
当超出最大值的范围，就会转换为Infinity，即正无穷大，如果这个值是负值，就会转换为-Infinity，即负无穷大
当超出最小值的范围，就会转换为0
所以Number的取值范围在JavaScript中为 [ 5e-324 , 1.7976931348623157e+308 ]
以上都是科学计数法的写法，即aeb = a × 10^b（a和b都可为负数）
所以在执行极小或极大的计算时，监测监控时，判断值是否在取值范围内是必要的。
那么我们来看看判断方法。
isFinite()
// 两个最大值相加，必然会超出取值范围 var result = Number.MAX_VALUE + Number.MAX_VALUE; // 打印结果为：Infinity，即正无穷大 console.log(isFinite(result)); 以上就是js中number类型的数值范围以及判断是否在范围内的方法，希望对大家有帮助。
如有问题，请指出，接受批评。
个人微信公众号：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95a48e0a1b5d0971b5ceb0fcbfdf0f49/" rel="bookmark">
			安全多方计算新突破！阿里首次实现“公开可验证” 的安全方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阿里妹导读：近日，阿里安全双子座实验室与马里兰大学等高校合作的论文《Covert Security with Public Verifiability: Faster, Leaner, and Simpler 》【1】被欧洲密码年会(Eurocrypt)2019接收。这是国内公司在安全多方计算领域的第一篇顶会论文（Eurocrypt2018只有3篇大陆作者论文，难度可见一斑）。
今天，我们邀请阿里高级安全专家鸿程，深入解读业界首个“公开可验证(PVC)” 的安全两方计算方案。
安全多方计算介绍
安全多方计算（ Secure Multi-Party Computation，MPC）于1986 年由姚期智院士提出【2】。安全多方计算协议允许多个数据所有者在互不信任的情况下进行协同计算，输出计算结果，并保证任何一方均无法得到除应得的计算结果之外的其他任何信息。换句话说，MPC技术可以获取数据使用价值，却不泄露原始数据内容。
互联网已经完成了从IT时代向DT时代的转变，数据已经成为DT时代企业的核心竞争力。数据作为一种新能源，只有流动起来才能产生价值。不过，大多数企业考虑到数据安全和个人隐私等问题，对数据共享都非常谨慎。而MPC对打破数据孤岛，实现数据的可控共享，具有重要的理论和现实意义。
MPC方案主要可分为基于混淆电路(Garbled Circuit，GC)和基于秘密共享两种。本文主要关注GC类方案。
不经意传输(Oblivious Transfer)
我们首先介绍一种基础的安全多方计算协议：不经意传输(Oblivious Transfer, OT)。 来看一个例子：假设某旅行社拥有N个景点的旅游资料，小淘想去其中的A景点游玩，希望向旅行社购买相关资料做好出游功课。但是小淘非常在意自己的隐私，不希望向旅行社泄露自己的目的地是哪里。因此双方希望这笔交易能够满足以下隐私条件：
1. 小淘不希望向旅行社泄露“我准备去A景点”这一信息；
2. 旅行社只希望出售小淘出钱购买的那份资料，而不泄露小淘未购买的N-1份资料；
粗看起来这种隐私条件似乎是无法满足的：旅行社只要把景点A的资料给到小淘，就必然了解了“小淘正在关注A景点”这一信息；除非旅行社把所有N份资料都给出，但是这又违背了旅行社的利益；
但是神奇的OT可以让交易在这种“不可能的条件”下达成。简而言之，在OT协议中，旅行社把他拥有的N份资料使用某种双方协商同意的加密算法和参数进行加密，然后发送给小淘；小淘可以从密文中解密出A的资料，而无法解密出其他N-1份资料。
以下以N=2为例，基于Diffie-Hellman密钥交换协议，给出一种1 of 2 OT实现方法的非正式描述；其中S（Sender）=旅行社，R（Receiver）=小淘，S拥有两份资料，R希望取得其中的；
1. S秘密生成随机数a; R秘密生成随机数b；
2. S将发送给R; R将发送给S；
3. S计算；
4. S以为密钥加密, 以k1为密钥加密,将和发送给R；
5. 由于, 因此R可以计算出，并解密出，但R无法计算，因此无法解密出。
如果R希望取得，只需把第2步中的改为即可。
OT除了可以直接用于构造MPC方案之外，也是GC等许多MPC方案的基石。
混淆电路
我们知道，任意函数最后在计算机语言内部都是由加法器、乘法器、移位器、选择器等电路表示，而这些电路最后都可以仅由AND和XOR两种逻辑门组成。一个门电路其实就是一个真值表，例如AND门的真值表就是：
例如其中右下格表示两根输入线(wire)都取1时，输出wire=1：即 1 AND 1 = 1。
假设我们把每个wire都使用不同的密钥加密，把真值表变成这样：
例如其中右下格表示如果门的输入是b和d，那么输出加密的f(密钥是b和d)。这个门从控制流的角度来看还是一样的，只不过输入和输出被加密了，且输出必须使用对应的输入才能解密，解密出的f又可以作为后续门的输入。这种加密方式就称为“混淆电路(Garbled Circuit，GC)”。
将电路中所有的门都按顺序进行这样的加密，我们就得到了一个GC表示的函数。这个函数接收加密的输入，输出加密的结果。
假设有两个参与方A和B各自提供数据a、b，希望安全的计算约定的函数F(a,b)，那么一种基于GC的安全两方计算协议过程可以非正式的描述如下：
1. A把F进行加密，得到GC表示的函数; （注意这里A是电路的生成者，所以他了解每根wire的密钥）；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95a48e0a1b5d0971b5ceb0fcbfdf0f49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bf3399dc3beeffe48880ad9b12ddade/" rel="bookmark">
			日常服务器巡检时，free -m命令的说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		日常服务器巡检中，我们通常会进行服务器的硬件健康状态，比如对服务器的硬盘、CPU和内存等状态进行查询。现在这里我们进行的是对常用的查看内存使用情况的free -m 命令进行讲解： 一、巡检第一台服务器： #free -m
total used free shared buffers cached
Mem: 16031 744 15287 0 182 213
-/+ buffers/cache: 348 15683
Swap: 8015 0 8015
以上是对某台服务器进行内存的使用情况进行检查，好多新手统计当前内存的使用率=user/total=744 / 16031 * 100%=5%，感觉没毛病，加上用top命令查看cpu使用率时，发现使用率为0.3%
二、接着往下看第二台服务器的硬件设备使用率情况： 先查看第二台服务器CPU使用情况
（类似上面的第一台服务器，cpu使用率不高，那么就查看它（第二台）的内存使用率了）
#free -m
total used free shared buffers cached
Mem: 16031 15861 170 0 287 15079
-/+ buffers/cache: 494 15537
Swap: 8015 0 8015
在第二台服务器，你会发现没有什么程序在运行，但是使用top或free命令看到可用内存free项会很少，那么这是什么情况呢？
其实一开始，算内存的使用率=user/total=744 / 16031 * 100%=5%用这公式是错误的了，这是Linux新手，容易犯的错误！
那好，现在开始进行对free -m命令进行讲解： （以上例子进行讲解）
#free -m
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bf3399dc3beeffe48880ad9b12ddade/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/759dde8d3008579ebc7744f409dbe0fd/" rel="bookmark">
			使用python创建数组的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍两种在python里创建数组的方法。第一种是通过字典直接创建，第二种是通过转换列表得到数组。
方法1.字典创建
（1）导入功能
（2）创立字典
（3）将字典带上索引转换为数组
代码示例如下：
import numpy as np
import pandas as pd
data={“name”:[‘xiaozhang’,‘xiaoli’,‘lily’,‘tony’],
“sex”:[‘boy’,‘girl’,‘girl’,‘boy’],
“age”:[12,11,10,11],
“number”:np.random.randn(4),
“class”:np.linspace(1,4,4)}
data1=pd.DataFrame(data,index=[1,2,3,4])
运行结果如下：
扩展：
np.random.rand(4,2) 随机生成四行两列的随机数。
np.linspace(1,4,4) 在规定的时间内，返回固定间隔的数据。他将返回“num-4”（第三为num）个等间距的样本，在区间[start-1, stop-4]中
方法2：列表转换成数组
（1）导入功能，创建各个列表并加入元素
（2）将列表转换为数组
（3）把各个数组合并
（4）可视需要转置数组
代码示例如下：
import pandas as pd
import numpy as np
list1=[‘name’,‘sex’,‘school’,‘Chinese’,‘Math’,‘English’]
list2=[‘zhangsan’,‘boy’,‘A’,85,94,62]
list3=[‘wangwu’,‘boy’,‘B’,85,80,88]
list4=[‘wangwu’,‘boy’,‘B’,85,80,88]
df1=pd.DataFrame(list1)
df2=pd.DataFrame(list2)
df3=pd.DataFrame(list3)
df4=pd.DataFrame(list4)
data=pd.concat([df1,df2,df3,df4],axis=1)
data.columns=[1,2,3,4]
data=data.T
运行结果如下：
扩展：
data.T 可转置数组
data.columns=[‘A’,‘B’,‘C’,‘D’] 直接暴力改列名
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a84b5449efb55cdbcba0fe846d54f8c9/" rel="bookmark">
			机器学习思考题目——10神经网络基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文直译自《hands on ML》课后题。（有改动的以【】表示）
1.用原始人工神经元（为组件）画出一个ANN的示意图，来实现操作 A ⊕ B ：⊕表示异或操作XOR。提示：A ⊕ B = (A∧ ¬ B) ∨ (¬ A ∧ B). 下图是用原始人工神经元为基础的神经网络，实现异或操作，基于公式A ⊕ B = (A ∧ ¬ B)
∨ (¬ A ∧ B)。图形还有其他若干解法，例如基于公式 A ⊕ B =(A ∨ B) ∧ ¬(A ∧ B)或者 A ⊕ B = (A ∨ B) ∧ (¬ A ∨ ∧ B)等等。
【补充——画图方法——不同情况示意图】
2.一般而言，为什么Logistics Regression分类器比经典感知机（i.e.，classical Perceptron，a single layer of linear threshold units trained using the Perceptron training algorithm）更好？怎样调整（tweak）感知机，使其等价于Logistics Regression分类器？ （1）经典感知机只有在数据集线性可分的情况下才收敛，而且它不能估计类的概率。数据集线性不可分的时候，LR分类器也可以收敛到一个好的解，同时LR会输出类的概率。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a84b5449efb55cdbcba0fe846d54f8c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bdf3c7a35ac1a801747993d4a8096b1/" rel="bookmark">
			thymeleaf模板对没有结束符的HTML5标签解析出错的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 默认配置下，thymeleaf对.html的内容要求很严格，比如&lt;meta charset="UTF-8" /&gt;，如果少最后的标签封闭符号/，就会报错而转到错误页。也比如你在使用Vue.js这样的库，然后有&lt;div v-cloak&gt;&lt;/div&gt;这样的html代码，也会被thymeleaf认为不符合要求而抛出错误。
通过设置thymeleaf模板可以解决这个问题，下面是具体的配置:
spring.thymeleaf.content-type=text/html
spring.thymeleaf.cache=false
spring.thymeleaf.mode =LEGACYHTML5
LEGACYHTML5需要搭配一个额外的库NekoHTML才可用
项目中使用的构建工具是Maven添加如下的依赖即可完成:
&lt;dependency&gt; &lt;groupId&gt;net.sourceforge.nekohtml&lt;/groupId&gt; &lt;artifactId&gt;nekohtml&lt;/artifactId&gt; &lt;version&gt;1.9.22&lt;/version&gt; &lt;/dependency&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85c7247fb465bfd9747ee97e0019350a/" rel="bookmark">
			微信小程序源码丢失了如何找回微信小程序源码？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		此教程若过时，请看下其他大神评论，以便获取最新方法；若大神有其他更好的方法请在下面评论！！ 今天电脑出问题，以前写的微信小程序源代码丢失了，悲剧啊！！ 然后就找各种办法数据恢复，但是种种原因恢复不过来了。。。。。。。凉凉。。。。。。
继续想解决办法，结果呢想到了反编译，对，就这样反编译！
先看下最终结果吧
找了下大神写的反编译工具，先给地址：wxappUnpacker点击就可以去下载工具；
记得要安装最新版本的node.js哦
使用模拟器或者越狱的苹果手机，获得root权限的安卓手机来抓取wxapkg包
我的是使用苹果手机来抓取包的，需要越狱。这里就不多说了，直接放图：
使用反编译脚本解包 wxapkg
● 到这里你应该已经将反编译脚本从github下载 或者 clone 到本地某个目录● 打开nodejs命令窗口，按住shift+右击● cd 到你clone或者下载好的反编译脚本目录下● 在node命令窗口中依次安装如下依赖（当然，你也可以选择-g全局安装）： 1、npm install esprima
2、npm install css-tree
3、npm install cssbeautify
4、npm install vm2
5、npm install uglify-es
6、npm install js-beautify
● 安装好依赖之后，就是最后一步了，反编译 .wxapkg 文件在当前目录下输入 node wuWxapkg.js [-d] //files 就是你想要反编译的文件名 例如：我有一个需要反编译的文件 1.wxapkg 已经解压到了C盘根目录下,那么就输出命令 node wuWxapkg.js C:\1.wxapkg 按照描述进行了反编译，奇迹发生了，果然反编译成功了，但是一跑起来就出问题了，wxcc文件成了.html文件，
而且发现反编译的时候报错了；错误图：
不知道咋弄，继续网上搜解决办法，结果没找到。最后想放弃去某宝花钱。去问了一个店铺，我把我遇到的问题给店主描述了下，说要花80元给我搞定。花钱是值得的，但是呢我还是不服气，既然编译了，那得自己尝试么，对吧，然后我问店主，我出现的问题在哪里，店主说github上的有问题，最新的没更新，我这里有新的，300元我给你，我去，你这个也太坑了吧，300元把人家工具给我。我就直接不理他了。
休息下。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。
然后我把ReferenceError: $gwx is not defined问题谷歌上一搜出来了解决办法，有的到一半就要钱，有的还不全，咋办呢，继续搜，最后在知乎上找到一个wuWxx.js需要修改的代码，提地址：https://zhuanlan.zhihu.com/p/56056561，没删之前赶紧去看看。果然把这个js修改，成功编译到以前的代码，虽然有些变动，但是大部分都正常。
修改部分代码：
需要源码或者需要编译指导可以联系我！！第一次写博客，望大家多多支持，谢谢！
心得就是：动手尝试---------------------------
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/879e8ad109dfd9075cc4b1917e4d6936/" rel="bookmark">
			作业--数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package sz;
public class sz1 {
public static void main(String[] args) {
int[] a= {-1,-2,-4,-8,-4,-7,-1,-5};
System.out.println(max(a));
}
public static int max(int[] array) {
int n=array.length;
int max=0;
int maxsum=array[0];
for(int i = 0;i &lt; n;i++)
{
if (max &lt;= 0) {
max = array[i];
}else {
max += array[i];
}
if (maxsum &lt; max) {
maxsum = max;
}
}
return maxsum;
}
}
转载于:https://www.cnblogs.com/zhang188660586/p/10506552.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86134a4cb5ae2a5f3b46419f4fcc43f2/" rel="bookmark">
			kafka介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		kafka是一款开源的、轻量级的、分布式消息系统。它基于zookeeper协调管理，还具有可分区和具有复制备份（replicated）特性。
kafka的设计初衷是，kafka能够成为统一实时处理，大数据的平台。据kafka官方网站介绍，kafka定位就是一个分布式流处理平台。
作为一个流式处理平台，必须具有以下三个关键特性：
能够允许发布和订阅流数据；存储流数据时，提供相应的容错机制；当流数据到达时能够被及时处理。 下面的概念可能有点绕，不过学习新技术不就是学习这些新名词吗？
kafka将一组消息抽象归纳为一个主题topic。
消息是kafka通信的基本单位，每一条消息称为message，在由Java重新实现的客户端中，每一条消息称为record。
kafka每个topic，又被分成一个或多个分区，每个分区在物理上对应一个文件夹。每个分区又有一或多个副本replica。
每个副本在逻辑上抽象为一个日志对象。也就是说，分区的副本和日志对象是一一对应的。每个主题，对应的分区数可以在kafka启动时所加载的配置文件中配置。
由于kafka副本的存在，就需要保证一个分区的多个副本之间数据的一致性。kafka会选择该分区的一个副本作为leader副本，而该分区的其他副本是follower副本。这样数据一致性及顺序性就有了保证。
一个日志又被划分为多个日志段，日志段是kafka日志对象分片的最小单位。一个日志段对应磁盘上一个具体的日志文件和两个索引文件。
kafka集群，就是由一个或多个kafka实例构成，每一个kafka实例称为代理（broker），通常也称代理为kafka服务器。
下载安装kafka 1、下载安装 kafka官网 http://kafka.apache.org/downloads，安装包没有区分linux和windows，都是叫kafka_2.11-2.1.1.tgz
下载尽量选择国内镜像
https://mirrors.tuna.tsinghua.edu.cn/apache/kafka/2.5.0/kafka_2.12-2.5.0.tgz 2、配置环境变量 KAFKA_HOME=/usr/local/applications/backup/kafka_2.12-2.5.0 PATH=PATH=$PATH:$KAFKA_HOME/bin 3、使之生效 source /ect/profile 启动验证 kafka需要先启动zookeeper，如果zk不是本地服务，应修改/config/server.properties文件zookeeper.connect配置项 # 避免在zookeeper根节点生成大量目录，指定kafka的根目录 zookeeper.connect=192.168.26.99:2181/myKafka log.dirs=/home/data/logs/kafka-logs 后台启动 ./kafka-server-start.sh -daemon ../config/server.properties 执行jps查看java进程 25521 Jps 25484 Kafka 以上修改/server.properties配置项是基于单机，可以不用改broker.id，如果是集群环境，最好和zookeeper改为一致
4、日志查看 $KAFKA/logs/server.log文件可以看到启动日志，启动日志中会记录启动时加载的配置信息。
5、通过zookeeper的客户端登录zookeeper查看目录结构，也可以在dubbo-monitor上看 zkCli.sh -server server-1:2181 kafka服务器配置 1、zookeeper集群配置
zookeeper.connect=node2:2181,node3:2181,node4:2181/myKafka 2、listener
listener.security.protocol.map=INTERNAL:PLAINTEXT,EXTERNAL:PLAINTEXT listener=INTERNAL:192.168.27.5:9000,EXTERNAL:192.168.27.5:9001 advertised.listeners=EXTERNAL:192.168.27.5:9001 inter.broker.listener.name=EXTERNAL 3、log.dir
log.dir=/home/logs/kafka_logs 4、broker.id
用于标记唯一的broker
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd49af8e7e6c5e8077422aa1dfa89051/" rel="bookmark">
			C#中的协变和逆变
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C#从2.0开始推出了泛型，极大的简化了相同算法对应不同数据类型的工作。在此基础上，C#4.0更进一步推出了泛型中的协变和逆变，有不少人对这个概念感觉比较模糊，今天就让我们来简单的捋一捋。
最常见的情况 考虑下面代码
object[] objs = new string[]{}; List&lt;object&gt; objList = new List&lt;string&gt;(); 这段代码中，第一句没问题，虽然被Jon Skeet认为是性能低下并且需要避免使用的，但是好歹是合法的语法。第二句编译器会报错，会说无法隐式转换List&lt;string&gt;到List&lt;object&gt;。按照相同的思路，下面这段代码似乎也应该报错。
IEumerable&lt;object&gt; strs = new List&lt;string&gt;(); 但实际情况是，这是一段合法的代码。
嗯。。是不是感觉有点头晕，其实在背后，是协变和逆变在起作用。
协变 协变英文名为Covariance，在泛型方法的原型里面以out表示，有out关键字修饰的参数可以在声明需要父类参数的泛型的地方使用需要子类参数的泛型实例，比如我们刚刚看到的IEnumerable&lt;T&gt;。
public interface IEnumerable&lt;out T&gt; : IEnumerable 所以在我们声明需要一个使用父类参数的IEnumerable的地方，我们可以提供一个使用子类参数的IEnumerable。
class Person{} class Manager : Person{} IEnumerable&lt;Person&gt; persons = new List&lt;Manager&gt;(); foreach(var person in persons){} 这段代码是完全合法的，我们在需要IEnumerable&lt;Person&gt;的地方提供了一个IEnumerable&lt;Manager&gt;。但是为什么这样是合法的呢，因为我们的IEnumerable主要作用是负责提供Person（只读），在这里是通过遍历的方式提供Person实例。Manager作为Person的子类，把它当做Person提供给外部是完全没有问题的。反过来，IEnumerable接口不允许通过本接口添加数据，这也是协变可以实现的一个前提。试想，如果IEnumberable&lt;Person&gt;允许通过接口添加数据到集合，但是本身其实例又是一个List&lt;Manager&gt;，那么会出现把Person添加到Manager里面的非法情况。
逆变 逆变英文名叫Contravariance，在泛型的方法签名中以in表示。和协变相反，逆变是指可以使用基于父类参数的泛型实例在要求子类参数的泛型的场合，我们还是来看个例子。
class ComparePerson : IComparer&lt;Person&gt; { public int Compare(Person x, Person y) { throw new NotImplementedException(); } } IComparer&lt;Manager&gt; comp = new ComparePerson(); List&lt;Manager&gt; managers = new List&lt;Manager&gt;(); managers.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd49af8e7e6c5e8077422aa1dfa89051/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/591e40db05c3605839959aead4fd509d/" rel="bookmark">
			信息学奥赛一本通C&#43;&#43;语言——1004：字符三角形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【题目描述】
给定一个字符，用它构造一个底边长5个字符，高3个字符的等腰字符三角形。
【输入】
输入只有一行，包含一个字符。
【输出】
该字符构成的等腰三角形，底边长5个字符，高3个字符。
【输入样例】
*
【输出样例】
代码
#include &lt;iostream&gt; using namespace std; int main () { char a; cin&gt;&gt;a; cout&lt;&lt;" "&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;" "&lt;&lt;a&lt;&lt;a&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;a&lt;&lt;a&lt;&lt;a&lt;&lt;a&lt;&lt;a&lt;&lt;endl; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3899d946e6f959c13ad7df18a4c351b4/" rel="bookmark">
			秒懂设计模式之桥接模式（Bridge Pattern）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		版权申明】非商业目的可自由转载
博文地址：https://blog.csdn.net/ShuSheng0007/article/details/88370067
出自：shusheng007
设计模式系列文章：
秒懂Java代理与动态代理模式
秒懂设计模式之建造者模式（Builder Pattern）
秒懂设计模式之工厂方法模式（Factory Method Pattern）
秒懂设计模式之抽象工厂模式（Abstract Factory Pattern）
秒懂设计模式之策略模式（Strategy Pattern）
文章目录 前言定义使用场景如何实现业务场景使用桥接模式 优缺点总结 前言 人在IT江湖飘，不懂设计模式咋装X？
桥接模式在日常开发中不是特别常用，主要是因为上手难度较大，但是对于理解面向对象设计有非常大的帮助。
定义 桥接模式是将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interfce)模式。
使用场景 桥我们大家都熟悉，顾名思义就是用来将河的两岸联系起来的。而此处的桥是用来将两个独立的结构联系起来，而这两个被联系起来的结构可以独立的变化，所有其他的理解只要建立在这个层面上就会比较容易。
下面是一些官方的说明，比较晦涩，必须等你有一定的经验后才能理解：
如果一个系统需要在抽象化和具体化之间增加更多的灵活性，避免在两个层次之间建立静态的继承关系，通过桥接模式可以使它们在抽象层建立一个关联关系。
“抽象部分”和“实现部分”可以以继承的方式独立扩展而互不影响，在程序运行时可以动态将一个抽象化子类的对象和一个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合。
一个类存在两个（或多个）独立变化的维度，且这两个（或多个）维度都需要独立进行扩展。
对于那些不希望使用继承或因为多层继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。
如何实现 业务场景 在讲策略模式的时候，王二狗和牛翠花不是要到天津之眼去约炮，不，约会嘛，两人到那后先去星巴克喝咖啡了，星巴克提供了多种选择，从容量上说有大杯，中杯，小杯，从口味上说有原味，加糖。这可难为了有选择恐惧症的牛翠花，半天点不出来，后面的人都开始骂娘了，王二狗也只能陪着笑脸道歉。
其实被难为的除了牛翠花，还有给星巴克做订单系统的外包公司的程序员林蛋大。星巴克一开始提需求的时候只有正常杯（中杯），原味和加糖这几种选择，人家林蛋大也是有两年工作经验的码农，这需求不在话下，蛋大还想到了要面对抽象编程。
首先定义一个点咖啡接口，里面有一个下单方法，至于点哪种口味的咖啡，就由其子类去决定，完美，蛋大好牛逼啊！
public interface ICoffee { void orderCoffee(int count); } 原味咖啡类
public class CoffeeOriginal implements ICoffee { @Override public void orderCoffee(int count) { System.out.println(String.format("原味咖啡%d杯",count)); } } 加糖咖啡类
public class CoffeeWithSugar implements ICoffee { @Override public void orderCoffee(int count) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3899d946e6f959c13ad7df18a4c351b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcea206dc163c0913384ff80d0c88e2c/" rel="bookmark">
			5. 卡特兰数（Catalan）公式、证明、代码、典例.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 定义 卡特兰数（卡塔兰数），英文名Catalan number，是组合数学中一个常出现在各种计数问题中出现的数列。
其前几项为（从第零项开始） :
C0 = 1, C1 = 1, C2 = 2, C3 = 5, C4 = 14, C5 = 42, C6 = 132, C7 = 429, C8 = 1430, C9 = 4862, C10 = 16796, C11 = 58786, C12 = 208012, C13 = 742900, C14 = 2674440, C15 = 9694845, C16 = 35357670, C17 = 129644790, C18 = 477638700, C19 = 1767263190, C20 = 6564120420, .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dcea206dc163c0913384ff80d0c88e2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca9836c0ff0262b2d3f7bc0bd9d09355/" rel="bookmark">
			P1605 迷宫( C语言版  DFS&#43;回溯 )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目背景 迷宫 【问题描述】
给定一个N*M方格的迷宫，迷宫里有T处障碍，障碍处不可通过。给定起点坐标和
终点坐标，问: 每个方格最多经过1次，有多少种从起点坐标到终点坐标的方案。在迷宫
中移动有上下左右四种方式，每次只能移动一个方格。数据保证起点上没有障碍。
输入样例 输出样例
【数据规模】
1≤N,M≤5
题目描述 输入输出格式 输入格式：
【输入】
第一行N、M和T，N为行，M为列，T为障碍总数。第二行起点坐标SX,SY，终点
坐标FX,FY。接下来T行，每行为障碍点的坐标。
输出格式：
【输出】
给定起点坐标和终点坐标，问每个方格最多经过1次，从起点坐标到终点坐标的方
案总数。
样例输入 2 2 1
1 1 2 2
1 2 样例输出 1 解题思路 这个题也是迷宫问题的一个变形，因为数据规模比较小，所以DFS搜索也能解决问题，这个也是DFS入门的比较经典的题型，这个题也可以用BFS做，如果有时间就写一个。就是从起点开始，下一个位置不断不断的尝试，直到找到，如果这个路走不通，就返回到上一步换个方向找，这就是回溯，大概思路就是这样，如果有不懂的欢迎留言，我随时回答你。 #include &lt;stdio.h&gt; int a[6][6]; // 记录障碍 int b[6][6]; //标记数组 记录自己走过的格子 防止重复走 int c[4][2]={{0,-1},{-1,0},{0,1},{1,0}};//方向数组 int n,m,t; int sx,sy,fx,fy; int sum; void DFS(int x ,int y){ int i,mx,my; if(x==fx&amp;&amp; y==fy) ++sum; //满足条 for(i=0;i&lt;4;i++){ mx=x+c[i][0]; my=y+c[i][1]; if(mx&lt;1||mx&gt;n ||my&lt;1||my&gt;m || a[mx][my]==-1 || b[mx][my]) continue;//判断下一个点十分满足条件 b[mx][my]=1; //标记改点 DFS(mx,my);//找下一个满足条件的点 b[mx][my]=0;//回溯到上一个点的位置进行寻找 } } int main(){ int i,jx,jy; sum=0; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca9836c0ff0262b2d3f7bc0bd9d09355/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab7b012e5a4b7d2857ea9c9df21b96fb/" rel="bookmark">
			opkg update失败问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		执行opkg update提示找不文件。
root@EC2022v:~/clienttest# opkg update Downloading http://downloads.openwrt.org/barrier_breaker/14.07/at91/generic/packages/base/Packages.gz. wget: server returned error: HTTP/1.0 404 Not Found Downloading http://downloads.openwrt.org/barrier_breaker/14.07/at91/generic/packages/luci/Packages.gz. wget: server returned error: HTTP/1.0 404 Not Found Downloading http://downloads.openwrt.org/barrier_breaker/14.07/at91/generic/packages/management/Packages.gz. wget: server returned error: HTTP/1.0 404 Not Found Downloading http://downloads.openwrt.org/barrier_breaker/14.07/at91/generic/packages/oldpackages/Packages.gz. wget: server returned error: HTTP/1.0 404 Not Found Downloading http://downloads.openwrt.org/barrier_breaker/14.07/at91/generic/packages/packages/Packages.gz. wget: server returned error: HTTP/1.0 404 Not Found Downloading http://downloads.openwrt.org/barrier_breaker/14.07/at91/generic/packages/routing/Packages.gz. wget: server returned error: HTTP/1.0 404 Not Found Downloading http://downloads.openwrt.org/barrier_breaker/14.07/at91/generic/packages/telephony/Packages.gz. wget: server returned error: HTTP/1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab7b012e5a4b7d2857ea9c9df21b96fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35a4f4a6717c5b2c3c930313c7f64221/" rel="bookmark">
			Vue中使用EventBus进行组件通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue中的eventBus类似与js原生的事件，即CustomEvent事件，该事件主要是用于dom之间的互相通信，而eventBus则不同，eventBus主要用于组件之间的通信，该方法应用于兄弟组件之间通信偏多，但是，该方法也可以应用于父子之间的相互通信。
这里我以脚手架3.0为样例进行讲解接下来要使用的方法。
建立EventBus可以通过以下两种方法:
1) 在main.js中直接创建以下语句
window.EventBus=new Vue(); window即全局，声明之后，就可以在任何一个组件进行使用
2）创建bug.js文件，在里面填入以下内容
import Vue from 'vue' const EventBus=new Vue(); export default EventBus; 这种方法的好处是哪里需要用EventBus在哪里引用就行
在子-&gt;父通信的时候，我们用到了$emit，在使用EventBus的时候，也需要用到它，如
EventBus.$emit('on-add',{ number:1 }) 在这里EventBus触发了on-add的事件，并传了一个number的参数，接下来，在需要的地方用Event.$on去监听该事件，然后进行相应的处理
EventBus.$on('on-add',event=&gt;this.number++) 该语句就是在兄弟1组件中触发on-add事件后，在兄弟2组件中监听到on-add事件触发了，然后将number进行相加，这就是EventBus的使用。
个人感觉:虽说EventBus在组件之间用起来非常简单方便，但是，如果在组件多了之后，用了大量的EventBus之后，并不是那么的容易维护。还有一点，就是事件很难快速跟踪，在组件中放置了大量的emit和on的触发器和监听器可能会造成一定的后果，所以在进行兄弟组件之间共享数据的时候，可以考虑使用Vuex来进行状态管理。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a410058d3cc5186b41640acc621215b/" rel="bookmark">
			ResultSet.next() 速度慢 怎么办
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果 java中执行ResultSet.next() 非常慢。
首先可以肯定的是ResultSet.next() 效率低下是错觉，真正效率低下的是写出SQL的执行速度，同样ResultSet只是代表着结果集，而不表示它就是整个结果集的数据
当出现奇怪的问题的时候，不要这么做：
大量重复测试怀疑框架，怀疑Java，怀疑人生 言归正传，首先看一下sql
select * from ( select * from ( a union all b ) order by xxx ) where rownum &lt; 100 查找原因
把a部分拿出来检索，结果有十多条，速度很快。 把b部分拿出来检索，上百万件结果。
问题原因：SQL写的不好。 union all的子句的数据量非常大，union之后再进行排序取数据，速度慢。在union子句内部进行排序，刚好排序字段在索引字段上，能够利用索引，自然速度非常快。
注：
1.如果是大量数据情况，可考虑采用分页形式进行查询，这样可以避免内存溢出
2.200万条记录，遍历数据需要30s左右，并行加载，并行之后遍历数据需要25s，基本上没有并行效果
解决方案：
多CPU主机的话，并行机制要能提升效率，主要偏重于CPU密集型操作；
也就是说你的SQL中需要大量的运算，这种情况下可以较好发挥多CPU的优势。
否则服务器磁盘就那么一块，就是个顺序读取文件，跟执行copy没啥本质区别，即便有100个CPU，效果差不多就那样。瓶颈基本就在 网络IO 或 磁盘IO 。
可以把程序直接放在数据库服务器上执行，如果速度大大提升，说明之前瓶颈主要是网络IO；如果速度依然没有提升，说明瓶颈主要是磁盘IO。
如果是单机普通硬盘的话，这速度真的挺快了，要是要提速，弄成分布式数据库集群，换成SSD，java方面的话估计没什么提升的，纯jdbc了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0aa411bc121627dc03a70a1455dd4b15/" rel="bookmark">
			Spring Boot之使用thymeleaf和jpa增删改查简单实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章介绍如何使用jpa和thymeleaf做一个增删改查的示例。
配置文件 pom包配置 pom包里面添加jpa和thymeleaf的相关包引用
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; 在application.properties中添加配置 spring.datasource.url = jdbc:mysql://localhost:3309/springboot?useSSL\=false&amp;characterEncoding\=UTF-8&amp;autoReconnect\=true spring.datasource.username=root spring.datasource.password=123456 spring.datasource.driver-class-name=com.mysql.jdbc.Driver #启动时会根据实体类生成数据表，或者更新表结构，不清空数据，开发阶段使用；validate：表结构稳定后使用，可用于正式环境； spring.jpa.properties.hibernate.hbm2ddl.auto=update spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialect # 控制台打印sql spring.jpa.show-sql= true spring.thymeleaf.cache=false 其中propertiesspring.thymeleaf.cache=false是关闭thymeleaf的缓存，不然在开发过程中修改页面不会立刻生效需要重启，生产可配置为true。
在项目resources目录下会有两个文件夹：static目录用于放置网站的静态内容如css、js、图片；templates目录用于放置项目使用的页面模板。
启动类 启动类需要添加Servlet的支持
import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.boot.builder.SpringApplicationBuilder; import org.springframework.boot.context.web.SpringBootServletInitializer; @SpringBootApplication //若打包成war包,则需要继承SpringBootServletInitializer类,覆盖其configure(SpringApplicationBuilder)方法 public class JpaThymeleafApplication extends SpringBootServletInitializer { //添加servlet依赖 @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application){ return application.sources(JpaThymeleafApplication.class); } public static void main(String[] args) { SpringApplication.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0aa411bc121627dc03a70a1455dd4b15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9aa7d26e7a20ee708948b95bfd12448/" rel="bookmark">
			springboot部署web容器SpringBootServletInitializer用途
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.jar包中的打包方式根据自己的需要进行修改
2.若打包成war包,则需要继承 org.springframework.boot.context.web.SpringBootServletInitializer类,覆盖其config(SpringApplicationBuilder)方法
3.打包成war的话,如果打包之后的文件中没有web.xml文件的话自己可以加进去一个最简单的web.xml(只有根节点的定义,而没有子元素)，防止因缺乏web.xml文件而部署失败
例子：
import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.boot.builder.SpringApplicationBuilder; import org.springframework.boot.context.web.SpringBootServletInitializer; @SpringBootApplication //若打包成war包,则需要继承SpringBootServletInitializer类,覆盖其configure(SpringApplicationBuilder)方法 public class JpaThymeleafApplication extends SpringBootServletInitializer { //添加servlet依赖 @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application){ return application.sources(JpaThymeleafApplication.class); } public static void main(String[] args) { SpringApplication.run(JpaThymeleafApplication.class, args); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ad8094a1d157996a335eae4c9e8df3f/" rel="bookmark">
			No EntityManager with actual transaction available for current thread
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		具体异常信息：
org.springframework.dao.InvalidDataAccessApiUsageException:
No EntityManager with actual transactionavailable for current thread - cannot reliably process 'persist' call;
nested exception isjavax.persistence.TransactionRequiredException: No EntityManager with actualtransaction available for current thread - cannot reliably process 'persist'call
以上这个异常可能是由于在需要事务的方法上，没有开启事务，结果就操作需要事务的方法比如保存，修改数据库数据方法。
修复方式也特别简单，在需要事务的方法上加入加上注解：@Transactional即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/557cfddd44f8bebf388bcd95a71a583e/" rel="bookmark">
			shell pwd 和 dirname 讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		例如：DIR="$( cd "$(dirname "$0")" ; pwd -P )"
解析：
$0 类似于python中的sys.argv[0]等。 $0指的是Shell本身的文件名。类似的有如果运行脚本的时候带参数，那么$1 就是第一个参数，依此类推。 dirname 用于取指定路径所在的目录 ，如 dirname /home/ikidou 结果为 /home。 $ 返回该命令的结果 pwd -P 如果目录是链接时，格式：pwd -P 显示出实际路径，而非使用连接（link）路径
一、pwd和dirname
1、pwd返回的是当前目录，“print name of current/working directory”，但并不一定是脚本存放的目录，如下所示，当在~/c-example路径下执行
pwd得到结果并不是脚本所在的路径
2、dirname $0在命令行状态下返回" . "，而在脚本中返回的是脚本所在的路径，且是脚本所在路径相对于命令执行时的路径
是test.sh相对于命令执行时的相对路径
3、二者的区别可由如上示例看到：pwd会随着cd等指令而变化，但最开始由dirname $0得到的相对路径是一个固定参数。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29ca734231b500284c3761172791bf15/" rel="bookmark">
			LaTex 论文排版(2): 插入公式 (从MathType公式编辑器导入到LaTex中)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 行内公式
2 行间公式
3 公式用MathType导入到LaTex中
总结
本文介绍在期刊的LaTex模板的基础上，如何用MathType公式编辑器导入到LaTex中，这样插入公式是非常快捷。期刊的LaTex模板字体，字号设置好了，一般只需按照模板的格式就可以了。
下面以IEEE Transactions 的模板为例：
论文中 公式分为行内公式和行间公式，如下图所示：
1 行内公式 对于行内公式，其格式为：$公式$
例如：
$E=mc^2$ 表示 2 行间公式 对于行间公式，其格式为：
\begin{equation} %公式 \end{equation} 例如：
\begin{equation} E=mc^2. \end{equation} 行内公式和行间公式的例子，如下图所示：
对于 较为简单的公式，可以在LaTex上直接写，那么论文中，比较长的公式，如下面的公式，该如何写呢？我自己用LaTex直接写这个公式，用了十几分钟。一把幸酸一把泪，后来查阅资料才知道，公式编辑器MathType可以导出对应的LaTex。下面将详细介绍。
3 公式用MathType导入到LaTex中 (1) 打开公式编辑器，选择：Preferences—&gt;Cut and Copy Preferences
(2) 接着，选择 MathML or TeX—&gt; LaTeX 2.09 and later —&gt; OK 即可
(3) 然后，直接按 ” Ctrl + C ” 复制公式,如下图所示：
(4) 然后新建一个文本文件，粘贴进去，然后将最前面的 \[ 和最后面的 \] 删除，如下图所示：
(5) 删除之后，重新复制文本文件LaTex公式，粘贴到LaTex论文中，运行，结果如下图所示，公示字体和大小都是期刊模板已经设置好的。注: 当熟悉后，可以直接粘贴到LaTex，然后删除最前面的 \[ 和最后面的 \] 就可以了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29ca734231b500284c3761172791bf15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3170cf8a31d983cb035bba556058441f/" rel="bookmark">
			使用 TypeScript &#43; React &#43; Redux 进行项目开发（入门篇，附源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文详细介绍了如何使用 Create-React-App 编写 TypeScript + React 项目
前言 对于 TypeScript + React 开发，MicroSoft 编写了一个 TypeScript-React-Starter 的例子，Github 地址。有需要的朋友可以去看一下。
我自己也看了一下，文档说明讲解的很好，但是 Demo 拉下来却无法正常运行，一直报错。所以我自己使用 TypeScript + React + Redux 写了 Demo，作为范例来用一下。
本文 Demo 地址 本文 Counter Demo 是一个简易的例子，可以用来作为入门参考，Counter Demo
另外还写了一个 TodoList 的例子，稍微更有难度一些，代码量和组件更多更详细。有需要的朋友也可以参考一下。TodoList Demo
建议 可以先下载 Counter Demo 后，运行项目，查看运行效果，然后对照本文进行阅读，效果更佳！
使用 TypeScript 编写 React 需要注意的规范 必须遵守的要求：
所有用到 jsx 语法的文件都需要以 tsx 后缀命名使用组件声明时的 Component&lt;P, S&gt; 泛型参数声明，来代替 PropTypes进行类型校验 额外的代码规范：
全局变量或者自定义的 window 对象属性，统一在项目根下的 global.d.ts 中进行声明定义对于项目中常用到的接口数据对象，最好在 types/ 目录下定义好其结构化类型声明 安装 Create-React-App $ npm install create-react-app -g 复制代码 创建项目 先创建一个新的项目，这里我们命名为 typescript-react-app $ create-react-app typescript-react-app --scripts-version=react-scripts-ts 复制代码 react-scripts-ts是一系列适配器，它利用标准的create-react-app工程管道并把TypeScript混入进来。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3170cf8a31d983cb035bba556058441f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e958d34ccf1027dafdfccf0dcf12b6bc/" rel="bookmark">
			java学习笔记40：String类、StringBuild和Stringbuffer、不可变和可变字符序列使用的陷阱
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、String类 String类对象代表不可变的Unicode字符序列，因此我们可以将String对象称为“不可变对象”。
那什么叫做“不可变对象”呢?指的是对象内部的成员变量的值无法再改变。
打开String类的源码，如下图所示：
我们发现字符串内容全部存储到value[]数组中，而变量value是final类型的，也就是常量(即只能被赋值一次)。 这就是“不可变对象”的典型定义方式。（原因）
我们发现在前面学习String的某些方法，比如：substring()是对字符串的截取操作，但本质是读取原字符串内容生成了新的字符串。测试代码如下：
示例：String类测试代码
public class Test { public static void main(String[] args) { String s1 = new String("abcdef"); String s2 = s1.substring(2, 4); // 打印：ab199863 System.out.println(Integer.toHexString(s1.hashCode())); // 打印：c61, 显然s1和s2不是同一个对象 System.out.println(Integer.toHexString(s2.hashCode())); } } 运行结果：
二、String类 字符串常量拼接、优化以及比较（不可变字符序列） 在遇到字符串常量之间的拼接时，编译器会做出优化，即在编译期间就会完成字符串的拼接。
使用==进行String对象之间的比较，使用equals进行内容的比较。
示例：字符串常量拼接时的优化
public class Test { public static void main(String[] args) { //编译器做了优化,直接在编译的时候将字符串进行拼接 String str1 = "Hello" + " World"; //相当于str1 = "Hello World"; String str2 = "Hello World"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e958d34ccf1027dafdfccf0dcf12b6bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/488ac6e926bb2b009ed0f635db22ec1a/" rel="bookmark">
			[linux] lsyncd 文件增量同步利器 用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[linux] lsyncd 文件增量同步利器 用法 简介 自从有一次不小心把home目录删没了，还有一次调整分区大小不小心把home给格没了，我就长心眼了。一定要数据备份。
然后统计了一下，我的个龟龟，30w个文件我拿命备份啊，文件倒是不到（迁移了一部分在移动硬盘里），但是qq聊天记录那些乱七八糟的表情包啊小图片啊，光这一部分就有8w个文件，淦。自然就想到了增量备份。
我比较懒就不发引用了，增量同步大致就有点像git仓库，原理上是会根据文件差异来传输文件，而不是一股脑把所有文件都拷过去（当然它肯定没法像git一样回溯）
安装、配置与使用 原理 其实lsyncd[3]它使用的工具是rsync+inotify。rsync是linux自带的，几乎所有发行版应该都有这个工具，你们也可以尝试一下，直接rsync -av /home/core /tmp/xxx就好了。第一次拷因为很大所以慢，但是在做出一些修改之后，第二次使用同样的命令就非常快了，只会拷贝修改的文件，具体其它骚操作可以看这里Linux文件同步工具-rsync[2]或者直接man一下手册。
关于lsync的原理下面直接引用大佬的发言[1]，本文主要参考的就是这篇了
Lysncd 实际上是lua语言封装了 inotify 和 rsync 工具，采用了 Linux 内核（2.6.13 及以后）里的 inotify 触发机制，然后通过rsync去差异同步，达到实时的效果。我认为它最令人称道的特性是，完美解决了 inotify + rsync海量文件同步带来的文件频繁发送文件列表的问题 —— 通过时间延迟或累计触发事件次数实现。另外，它的配置方式很简单，lua本身就是一种配置语言，可读性非常强。lsyncd也有多种工作模式可以选择，本地目录cp，本地目录rsync，远程目录rsyncssh。
安装 作为arch系，aur里怎么可能没有包，一顿yay -Sy lsyncd搞定。（yaourt已经过时啦赶紧yay用起来）
配置 这个包最骚的是它丫竟然没有给默认配置，我：？？？
还好文档还是有的，感谢大佬[1]做了大部分翻译工作，欢迎直接参考，这边只说几个大佬网站上没讲的部分。
安好了之后并没有任何指导，但你知道它是个daemon，所以问题不大，vim /usr/lib/systemd/system/lsyncd.service，就能看到它的daemon的配置文件
（这里面注释的是我自己写后来删掉了，其余的应该和刚装好没什么区别。）
红线备注出来的部分便是配置文件了，当然你打开这个目录的时候会发现它并没有目录，也没有给默认配置，这就需要配置文件了，具体的规则在大佬的博客[1]里写得很清楚了，他是把原本的官方文档[4]翻译了一波。
这里我对着我自己的配置简单说一下要注意的地方
settings { nodaemon=false, maxProcesses=4 } sync { default.rsync, source="/home/core", target="/run/media/core/Home-Bak/core", delay=4000, delete="startup", excludeFrom="/home/core/.config/lsyncd.exclude", rsync={ binary="/usr/bin/rsync", archive=true, compress=false, verbose=false } } sync { default.rsync, source="/run/media/core/Data-2.5", target="/run/media/core/Data-3.5/Data-2.5", delay=7000, delete="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/488ac6e926bb2b009ed0f635db22ec1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dcfd915cdbadb27011dab464c3acbf9/" rel="bookmark">
			Latex 修改英文显示 Chaper 格式为自定义中文章节格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Latex 撰写中文书籍 book 时，默认各个章节会显示英文格式的 Chaper 1、Chaper 2 等，此时需要将 Chaper 转换显示为“第几章”格式：
\documentclass{book} \usepackage[utf8]{inputenc} \usepackage{CTEX} \begin{document} \tableofcontents \chapter{本书第一章} \section{章节} 这是一个 section 部分内容 \subsection{子章节} 这是一个 subsection 部分内容 \subsubsection{子子章节} 这是一个 subsubsection 部分内容 \paragraph{段落} 这是一个 paragraph 部分内容 \paragraph{子段落} 这是一个 paragraph 部分内容 \end{document} 在 \begin{document} 前前添加自定义的章节中文格式即可：
\usepackage[center]{titlesec}%chapter1修改为第1章 \titleformat{\chapter}{\raggedright\Huge\bfseries}{第\,\thechapter\,章}{1em}{} \titleformat{\section}{\raggedright\Large\bfseries}{\,\thesection\,}{1em}{} \titleformat{\subsection}{\raggedright\large\bfseries}{\,\thesubsection\,}{1em}{} \documentclass{book} \usepackage[utf8]{inputenc} \usepackage{CTEX} \usepackage[center]{titlesec}%chapter1修改为第1章 \titleformat{\chapter}{\raggedright\Huge\bfseries}{第\,\thechapter\,章}{1em}{} \titleformat{\section}{\raggedright\Large\bfseries}{\,\thesection\,}{1em}{} \titleformat{\subsection}{\raggedright\large\bfseries}{\,\thesubsection\,}{1em}{} \begin{document} \tableofcontents \chapter{本书第一章} \section{章节} 这是一个 section 部分内容 \subsection{子章节} 这是一个 subsection 部分内容 \subsubsection{子子章节} 这是一个 subsubsection 部分内容 \paragraph{段落} 这是一个 paragraph 部分内容 \paragraph{子段落} 这是一个 paragraph 部分内容 \end{document} 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5aeeedd497f838406480e652d6096405/" rel="bookmark">
			Android Studio调试之使用USB连接手机调试(详细版)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境准备 JDKAndroid SDKAndroid Studio 3.x(我的是3.2，3.0以前的版本可能有些区别)手机一部，可以开启USB调试即可，不用ROOT 手机端 手机上要先开启“开发者模式”（一般是在“关于手机”中点击5次系统版本号），然后打开USB调试，如果是小米手机，还要在开发者模式中关闭“启用MIUI优化”，不然后面调试时会出错。
连接手机 手机用USB连上电脑，连上后会自己安装驱动。
如果手机上出现这个画面，请勾选“一律允许使用这台计算机进行调试”，然后确定。
驱动安装成功后，打开设备管理器，会在便携设备中看到我们的手机。
配置ADB 因为我们通过USB调试应用时，是借助ADB向手机中导入APK的，所以，如果ADB中能看到我们的手机时，那么手机已经成功建立连接了。
1、先找到Android SDK的目录，我的是在C:\Users\Administrator\AppData\Local\Android\Sdk\platform-tools
这是默认的SDK目录，WIN10系统貌似把Administration替换成当前用户名就是SDK的目录了。
2、打开环境变量配置，编辑系统变量中的Path，WIN10系统直接增加一项C:\Users\Administrator\AppData\Local\Android\Sdk\platform-tools
WIN7系统要注意每个路径间有个分号。
3、打开命令行输入adb devices，可以看下设备列表中是否有我们的手机。我这里可以看到是有一个的，就是这部手机了。
Android Studio中的配置 1、安装谷歌USB驱动
右上角工具栏点击SDK Manager，打开SDK管理器，然后按照下图步骤依次单击SDK tools——Google USB Driver——OK。
等待它下载安装完成后，我们点击finish。
2、设置调试方式为USB
点击菜单RUN——Edit Configuration，把目标改为USB device。
开始调试 点击工具栏上的绿色三角按钮，运行。
然后可能会弹出这个提示框，意思大概是要我安装Android 6.0所需的运行环境，因为我的小米4手机系统版本是Android 6.0的，这里我们直接点击安装。
等待它下载安装完成，点击finish。
连接手机后应该在logcat中能看到我们的设备型号的，如图：
然后在Profiler中应该也能看到了。
也许这个窗口不会自动给你显示出来，但没关系，快速按两下SHIFT键，搜索Profiler，双击它就出来了。
如果你在Profiler中看不到你的设备名称，别着急，先打开命令行输入adb devices看看是否连接成功了，连接成功了还是没有的话，就把开发者选项关闭再打开，再打开USB调试，应该就能在Profiler中看到你的手机设备了。
这时我们再单击右上角工具栏上的运行，如果还不行，或者是提示：Error running ‘app’: No target device found
你就点击右上角工具栏上的sync刷新一下吧，我是这样解决了。
然后我们再点击运行，这下应该没问题了，然后下面依次提示什么构建中、、、导入apk中、、、等一下就好了，然后没提示了，打开手机看一下，运行成功了
这个哈喽喔的有点大，恩，没错，我改了字体大小
加上这一行就好了，再运行一下就跟我一样了，第一次写博客，可能有很多不足之处，有问题可以在下面提问，有错误也可以在下面指出，谢谢。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb8b8105a60651e634718cad5a30181b/" rel="bookmark">
			web项目HTML页面不能滚动的问题及解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天在改web项目时发现页面垂直滚动条消失了，整个页面只能显示上半部分。导致数据显示不全。
查阅资料，发现https://blog.csdn.net/zhouyingge1104/article/details/81706961该篇博客情况我的类似，就按照其方法尝试了一下，果然好了，特此记录一下，以免下次再犯。
并没有做过相关方面设置的话，应该就是第三方css文件导致的，可以尝试逐个注释起来尝试。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55747993462eb96530090971ac7314d2/" rel="bookmark">
			c&#43;&#43; socket 多路复用IO之select
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.select()
select函数用于在非阻塞中，当一个套接字或一组套接字有信号时通知你，系统提供select函数来实现多路复用输入/输出模型
#include &lt;sys/time.h&gt; #include &lt;unistd.h&gt; // 所在的头文件 int select(int maxfd,fd_set *rdset,fd_set *wrset,fd_set *exset,struct timeval *timeout); 1、maxfd：是需要监视的最大的文件描述符值+1
2、rdset：需要检测的可读文件描述符的集合
3、wrset：需要检测的可写文件描述符的集合
4、exset：需要检测的异常文件描述符的集合
5、timeout：指向timeval结构体的指针，通过传入的这个timeout参数来决定select()函数的三种执行方式
1.传入的timeout为NULL，则表示将select()函数置为阻塞状态，直到我们所监视的文件描述符集合中某个文件描述符发生变化是，才会返回结果。
2.传入的timeout为0秒0毫秒，则表示将select()函数置为非阻塞状态，不管文件描述符是否发生变化均立刻返回继续执行。
3.传入的timeout为一个大于0的值，则表示这个值为select()函数的超时时间，在timeout时间内一直阻塞，超过时间即返回结果 。
2.fd_set类型四个宏操作：
1、FD_ZERO(fd_set *fdset) 将指定的文件描述符集清空，在对文件描述符集合进行设置前，必须对其进行初始化，如果不清空，由于在系统分配内存空间后，通常并不作清空处理，所以结果是不可知的。
2、FD_SET(fd_set *fdset) 用于在文件描述符集合中增加一个新的文件描述符。
3、FD_CLR(fd_set *fdset) 用于在文件描述符集合中删除一个文件描述符。
4、FD_ISSET(int fd,fd_set *fdset) 用于测试指定的文件描述符是否在该集合中
3.服务端
流程：
1、创建套接字，即调用socket(),根据需要选择参数类型
2、根据地址和端口号，绑定服务端，即调用bind()
3、将套接字设为监听套接字，并设置监听数，即调用listen()
4、开始检测监听套接字与客户端套接字信号，即调用select()
4、阻塞等待等待客户端连接请求，即调用accept()
5、接受发送消息，即调用recv(),send()函数
6、关闭套接字，即调用close()
#include &lt;stdio.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; #include &lt;unistd.h&gt; #include &lt;netinet/in.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;sys/time.h&gt; #include &lt;iostream&gt; using namespace std; class Server { private: int port;	// 设置端口号 int serverfd;	// 定义服务端套接字（这个最后作为了监听套接字） int clientfd;	// 定义客户端套接字 int backlog;	// 设置最大客户端连接数，监听数 struct sockaddr_in serveraddr;	// 定义服务端套接字地址结构体 struct sockaddr_in clientaddr;	// 定义客户端套接字地址结构体 struct timeval tv;	// 定义时间结构体 socklen_t clientlen;	// 定义客户端套接字长度 public: Server(int port = 10000):port(port),serverfd(-1),clientfd(-1),backlog(10) // 初始化相关参数 { serverfd = socket(AF_INET, SOCK_STREAM, 0);	// 初始化服务端套接字对象 //cout &lt;&lt; serverfd &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55747993462eb96530090971ac7314d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/858b3361387442b2c9eaba48c1fc45c5/" rel="bookmark">
			请用sorted()对列表分别排序：
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		假设我们用一组tuple表示学生名字和成绩：
L = [(‘Bob’, 75), (‘Adam’, 92), (‘Bart’, 66), (‘Lisa’, 88)]
请用sorted()对上述列表分别按名字排序：
# -*- coding: utf-8 -*- L = [('Bob', 75), ('Adam', 92), ('Bart', 66), ('Lisa', 88)] def by_name(t): print(t) return t L2 = sorted(L, key=by_name) print(L2) run:
(‘Bob’, 75)
(‘Adam’, 92)
(‘Bart’, 66)
(‘Lisa’, 88)
[(‘Adam’, 92), (‘Bart’, 66), (‘Bob’, 75), (‘Lisa’, 88)]
再按成绩从高到低排序：
# -*- coding: utf-8 -*- L = [('Bob', 75), ('Adam', 92), ('Bart', 66), ('Lisa', 88)] def by_score(t): print(-t[1]) return -t[1] L2 = sorted(L, key=by_score) print(L2) Run:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/858b3361387442b2c9eaba48c1fc45c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2c3f8d99a38751bfd5152a861fe9bb1/" rel="bookmark">
			Tensorflow 报错illegal instruction (core dumped) 解决版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多童鞋安装tensorflow 1.5以上版本后，在导入tensorflow的时候报如下错：
&gt;&gt;&gt; import tensorflow as tf Illegal instruction (core dumped) 网上找了大多数解决办法都是将版本回退到1.5，但不可能一直用旧版本，这个问题也解决了很久。解释的原因也很多，当然主要原因的电脑配置环境，比如没有SSE4.1,SSE4.2,AVX,AVX2 等等。当然据说源码编译也是可以解决的，但太麻烦。其实解决上述问题很简单。
用conda 创建一个新的环境，再用conda install命令安装即可，多个人亲测有效，这里是安装的cpu版本。确保已安装Anaconda。
conda create -n tensorflow python=3.6 source activate tensorflow conda install tensorflow-mkl 再导入应该不会报错了，记得创建一个新的环境测试。若遇到问题可随时问！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/617ddc2635fa4a369a626bb52c96d376/" rel="bookmark">
			Easyui datagrid 获取所有行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 var rows = $("#datagridID").datagrid("getRows"); 这段代码是获取当前页的所有行。 for(var i=0;i&lt;rows.length;i++) { //获取每一行的数据 alert(rows[i].id);//假设有id这个字段 } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74cd1f6b28da1f8c4c17401dabd15e2e/" rel="bookmark">
			QT——3.4关闭事件：练习QCloseEvent类的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、在头文件中包含 #include&lt;QCloseEvent&gt; //当程序需要关闭的时候所处理的内容，所有的事件都是受保护的成员变量
2、添加事件
protected: void closeEvent(QCloseEvent *event); 3、实现事件
要想关闭时，弹出对话框，提示是否保存、忽略、取消操作，可以使用QMessageBox，打开帮助，查看里面的例子，我们在判断语句中添加自己的程序
4、 效果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a96526b9acf40e0ea6921d1a20d4ec1/" rel="bookmark">
			Mac安装软件提示 已损坏【已解决】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mac安装软件时提示已损坏的解决方法 从网上下载的SecureCRT、Principle等设计软件，以及输入法等常用软件，安装时可能会提示“已损坏，移至废纸篓”这类信息，根本无法打开。如下图：
这不是文件的问题，是系统限制的原因。
原因 新系统（macOS Sierra 10.12.X以上）加强了安全机制
默认不允许用户自行下载安装应用程序，只能从Mac App Store里安装应用。
解决方法 ▌步骤一：打开终端 ▌步骤二：输入代码sudo spctl --master-disable 在终端输入以下代码（可复制粘贴）
sudo spctl --master-disable 然后回车，输入自己电脑密码
输完回车即可（密码不会显示出来，如果密码不对会有提示，没有提示就是输入正确了）
▌步骤三：打开系统偏好设置 &gt; 安全性与隐私，若显示任何来源，说明离成功不远了 回到桌面双击安装文件，应该是可以安装了
如果还是无法打开，继续往下看 ▌步骤四：（移除这个应用的安全隔离属性） xattr -r -d com.apple.quarantine path（path换成软件安装路径，一般在/Application下）
现在再回去安装软件，成功！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32316b280a11a2d05bae0c549e112949/" rel="bookmark">
			echarts两条或两条以上x轴不同的线合并x轴但保持数据连续
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：这两组数据我想在一个图表上显示出来，他们的x轴都是时间点，但是时间点的数据是不统一的，请问echart能否实现固定一个x轴，数据自动对应到相应的时间轴上的点
解决方法：
整理数据 把时间x轴合并
x轴: ['1:00', '1:05', '1:10', ...]
data有两种方式： 1 . 空数据用null或者直接空表示
series: [{ data: [25, null, 15, ...], //or: [25, , 15, ...] connectNulls:true },{ data: [null, 25, 15, ...], //or: [, 25, 15, ...] connectNulls:true }] 2 . 直接把你的数组放到data上
series: [{ data: [ // xAxis data [ 1:00, 25 ], [ 1:10, 15 ], ... ], connectNulls:true },{ data: [ // xAxis data [ 1:05, 25 ], [ 1:10, 15 ], .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32316b280a11a2d05bae0c549e112949/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/301d7668c1142e479e7def733b6f7a97/" rel="bookmark">
			Ubuntu下解决apt update时签名无效问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu 18.04在执行apt-get update时出现一下报错：
W: GPG 错误：http://repo.mysql.com/apt/ubuntu bionic InRelease: 下列签名无效： EXPKEYSIG 8C718D3B5072E1F5 MySQL Release Engineering &lt;mysql-build@oss.oracle.com&gt; E: 仓库 “http://repo.mysql.com/apt/ubuntu bionic InRelease” 没有数字签名。 N: 无法安全地用该源进行更新，所以默认禁用该源。 N: 参见 apt-secure(8) 手册以了解仓库创建和用户配置方面的细节。 W: GPG 错误：http://repo.mongodb.org/apt/ubuntu xenial/mongodb-org/3.6 Release: 下列签名无效： EXPKEYSIG 58712A2291FA4AD5 MongoDB 3.6 Release Signing Key &lt;packaging@mongodb.com&gt; E: 仓库 “http://repo.mongodb.org/apt/ubuntu xenial/mongodb-org/3.6 Release” 没有数字签名。 N: 无法安全地用该源进行更新，所以默认禁用该源。 N: 参见 apt-secure(8) 手册以了解仓库创建和用户配置方面的细节。 解决办法：
sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 8C718D3B5072E1F5 sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 58712A2291FA4AD5 转载于:https://www.cnblogs.com/lishanlei/p/10707819.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afe0762e11e09dac682818b219338ddc/" rel="bookmark">
			AP与mAP的详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AP和mAP是图像分类任务中的评价方法。
mAP的计算方法：
1、首先使用训练好的模型获得所有测试样本的confideutnce score，每个类别（如person、car等）都会获得一组confidence score，假设现在共有20个测试样本，如下给出这20个样本的id、confidence score、真实标签ground truth label。
2、按照上图中的score值从大到小对所有样本进行排序，排序后结果如下图所示：
3、计算precision和recall值
在计算之前首先举个例子通俗地解释一下什么是precision和recall。
precision（精确率）：你预测出的结果有多少是正确的。
recall（召回率）：正确的结果有多少被你给出来了。
假设一个不透明的盒子里有8个红球和3个蓝球，现在让你取出了所有红球，你取出来了5个球，但里面有3个红球，2个蓝球。
precision=3/5 指你取出来的5个球里面只有3个是正确的。
recall=3/8 指8个红球只有3个被你取出来了。
用（True Positive+False Positive）来表示分类任务中我们取出来的结果，如在测试集上取出Top-5的结果为
其中id为4和2的样本图片为True Positive，id为13、19、6的样本为False Positive。剩余排在Top-5之外的元素时我们没有取出来的。如下：
这个例子中precision=2/5，recall=2/6。
实际的任务中通常不会满足只用Top-5来衡量模型的好坏。
4、计算AP
设总数为N的样本中总共有M个正样本，则从Top-1至Top-N可以有M个recall值，分别为（1/M,2/M,...,M/M），对于每个recall值r，可以从对应的（r'&gt;=r）中计算出一个最大的precision，对这M个precision求平均得到AP，如下图所示：
在上图所示中，共有6个正例，因此共有6个recall值，分别为1/6、2/6、3/6、4/6、5/6、6/6，
当recall=1/6时，r'为1/6、2/6、3/6、4/6、5/6、6/6，最大的precision=1；
当recall=2/6时，r'为2/6、3/6、4/6、5/6、6/6，最大的precision=2/2=1；
当recall=3/6时，r'为3/6、4/6、5/6、6/6，最大的precision=4/7；
当recall=4/6时，r'为4/6、5/6、6/6，最大的precision=4/7；
当recall=5/6时，r'为5/6、6/6，最大的precision=5/11；
当recall=6/6时，r'为6/6，最大的precision=6/16。
。
此时AP表示训练出来的模型在当前类别上的好坏。
5、计算mAP
按照第4步的方法对每个类别都计算出AP，求均值得到mAP。
参考文献：
https://blog.csdn.net/zdh2010xyz/article/details/54293298
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a86cf1569a4569d9a9f625a6087c0bae/" rel="bookmark">
			Spring Boot之使用指定的JDK版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 只需要在pom.xml中进行配置
&lt;!-- JDK版本 --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.7&lt;/source&gt; &lt;target&gt;1.7&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bcd1f3a7ce2e5090fbc8582e1762ade/" rel="bookmark">
			Mybatis如何在xml文件使用get方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Mybatis如何在xml文件使用get方法 使用Mybatis层层调用的时候，如果参数过多，调用所带的参数也会非常多。然后在mapper.xml文件就会出现下面这种情况：
void addClient(@Param("name") String name, @Param("type_one")String type_one, @Param("type_two")String type_two, @Param("level")String level, @Param("province")String province, @Param("city")String city, @Param("district")String district, @Param("location")String location, @Param("url")String url, @Param("phone")String phone, @Param("slogan")String slogan, @Param("student_count")String student_count, @Param("course")String course) ; 其实在Controller通过set方法装进实体，然后再mapper.xml文件中在get就可以，传参只需要带上实体就行。
需要注意的地方 1.实体传递到了mapper层，依旧传实体，不用写@Param（“XXX”）
int updateClient(ClientInfo clientInfo); 2.mapper.xml需要指明参数类型为实体
&lt;update id="updateClient" parameterType="com.domain.ClientInfo"&gt; ... &lt;/update&gt; 3.直接使用#{变量名}获取实体内变量，但是一定要注意：变量名一定是跟实体类所定义的名称相同。有的generator生成的domain，字段名中有带下划线的，会将下划线去掉，下划线后的第一个字母大写。
&lt;if test="studentCount!=null"&gt; --if中的名称也应该跟实体类中定义的相同 student_count = #{studentCount}, &lt;/if&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b15db87f0e819d078946b4c6e5a1d4cb/" rel="bookmark">
			音频输出设备是如何决定的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 既然是分析音频输出设备，我们首先需要知道当前手机支持的音频输出设备有哪些
adb shell dumpsys media.audio_policy &gt; /home/jon/audio_policy.txt
我们关注如下字段：
- Available output devices: Device 1: - id: 1 - tag name: Earpiece - type: AUDIO_DEVICE_OUT_EARPIECE - Profiles: Profile 0: - format: AUDIO_FORMAT_PCM_16_BIT - sampling rates:48000 - channel masks:0x0010 Device 2: - id: 2 - tag name: Speaker - type: AUDIO_DEVICE_OUT_SPEAKER - Profiles: Profile 0: - format: AUDIO_FORMAT_PCM_16_BIT - sampling rates:48000 - channel masks:0x0003 Device 3: - id: 6 - tag name: Telephony Tx - type: AUDIO_DEVICE_OUT_TELEPHONY_TX - Profiles: Profile 0: - format: AUDIO_FORMAT_PCM_16_BIT - sampling rates:8000, 16000 - channel masks:0x0001, 0x0003 从中我们得到当前终端支持的音频输出方式有：Earpiece(听筒)，Speaker(外放)，Telephony Tx(用于传输路由到手机无线装置的音频)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b15db87f0e819d078946b4c6e5a1d4cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/286faea0b4e3a91d8371c2cd1b84800a/" rel="bookmark">
			H.264的profile与level概念解释。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、有三种主要的profile。
baseline profile，
main profile，
high profile
profile指的是图像的压缩率，关系是baseline &lt; main &lt; high。high拥有最高的压缩率。baseline只有I帧与P帧，main和high有I,P,B三种帧。
二、level指的是解码性能。
分辨率，帧率，码率越高，level则越高。
这里顺便科普下，对于MPEG-2来说，level的分类是low level（LL），main level（ML），high 1440 level（H14L），high level（HL）这四种。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99ed9b9d668d2cc99c14d28895274056/" rel="bookmark">
			logback 日志脱敏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在研究如何使用logback实现日志脱敏的工作，网上各种查，各种找，终于找到了解决的办法。其实原理知道，就是想找一个最简便的方法而已。那今天咱们就来聊聊如何用Logback创建自定义格式转换符来实现日志脱敏**
脱敏类文件
配置文件
脱敏类文件
数据脱敏是指对某些敏感信息通过脱敏规则进行数据的变形，实现敏感隐私数据的可靠保护。 —— [ 百度百科 ]
本文使用最简单的脱敏方式进行数据脱敏打印，规则如下：
| 参数 | 脱敏前 | 脱敏后 |
| ——– | ——– | ——– |
| 姓名 | 李丽丽 | 李** |
| 手机号 | 13898701234 | 138****1234 |
| 身份证号 | 111111111111115762 | **************5762 |
| 银行卡号 | 6222600890987671234 | 6222600********1234 |
具体代码
首先定义类：SensitiveDataConverter 继承父类：MessageConverter
import ch.qos.logback.classic.pattern.MessageConverter;
import ch.qos.logback.classic.spi.ILoggingEvent;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
/**
* 敏感信息脱敏处理
* @author AAA
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99ed9b9d668d2cc99c14d28895274056/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64ea7412c674078049943ec84dfefc88/" rel="bookmark">
			vue 路由跳转，导致页面样式错乱，刷新又好了的情况
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在项目开始的时候，把所有的代码都码好。在页面跳转的时候总有几个页面，在跳到该页面时样式全错位了，但是刷新一下就又好。而且我在每个组件页面里面写的公共样式css，都删除掉scoped,这种情况下，跳转后页面的样式会沿用了前一个页面的样式，导致页面错乱。
解决办法: 在跳转前和跳转后页面的style上加上scoped，把公共样式写到分别写到子组件就OK了
&lt;style scoped&gt; @import "../../assets/public.css"; header{ position: fixed; top: 0; left: 0; width: 100%; } &lt;/style&gt; scoped属性（可选属性）：会自动添加一个唯一的属性 (比如 data-v-21e5b78) 为组件内 CSS 指定作用域，即css样式只在当前页面加载
如果引入了外部框架，很可能用了全局css，可能会影响你的部分样式，通过审查元素去定位问题就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbc3b8449fa6e9f9148797f1c783c93d/" rel="bookmark">
			vue 根据选择的图片绘制canvas图片及编辑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工具： cropperjs+vue+canvas
methods: { // 画图片方法 drawImage(src) { this.$nextTick(function() { let img = new Image(); // console.log("this.img is ",this.img); // 设置跨域必须放到img.src前面 img.setAttribute('crossOrigin', 'anonymous'); console.log("当前的图片的路径是：",this.imglist[this.index].path); img.src = src; const that = this; new Promise(function(resolve,reject) { img.onload = function() { console.log("in onload img is ",img.width,img.height); let whRatio = img.width / img.height; if((img.width / img.height) &lt; (1006 / 674)) { // 适配高度 img.height = 674; img.width = whRatio * img.height; } else { // 适配宽度 img.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbc3b8449fa6e9f9148797f1c783c93d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59e217656fced41f836898118693abb7/" rel="bookmark">
			批处理(bat)脚本语言---SET命令和变量使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		变量的使用格式
[设置变量]
格式：set 变量名=变量值
详细：被设定的变量以%变量名%引用
[引用变量]
格式: %变量名%
详细: 可以用echo %变量名%打印变量的只
[取消变量]
格式：set 变量名=
详细：取消后的变量若被引用%变量名%将为空
[展示变量]
格式：set 变量名
详细：展示以变量名开头的所有变量的值
[列出所有可用的变量]
格式：set
[计算器]
格式：set /a 表达式
示例：set /a 1+2*3
输出 7
预定义的变量
下面是些已经被底层定义好可以直接使用的变量：不会出现在 SET 显示的变量列表中
%CD% - 扩展到当前目录字符串。%DATE% - 用跟 DATE 命令同样的格式扩展到当前日期。%TIME% - 用跟 TIME 命令同样的格式扩展到当前时间。%RANDOM% - 扩展到 0 和 32767 之间的任意十进制数字。%ERRORLEVEL% - 扩展到当前 ERRORLEVEL 数值。%CMDEXTVERSION% - 扩展到当前命令处理器扩展名版本号。%CMDCMDLINE% - 扩展到调用命令处理器的原始命令行。%0 bat的完整路径名如"C:\Windows\system32\xxx.bat"%1 bat参数1 依次类推%2参数2…%path% - 当前的环境变量。以分号隔开的路径列表，路径可包含空格，可以以’'结尾, 可以以双引号包围之。 扩展变量
@ 与%i相关的变量（bat参数或者for循环的%i)
假设文件为C:\Documents and Settings\jinsun\桌面\ParseSinglePkgs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59e217656fced41f836898118693abb7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3407bd600e396fc7a9ffd6218871b61/" rel="bookmark">
			Flask-SQLAlchemy 中多表链接查询（不使用外键）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQLAlchemy 是一个功能强大的 ORM 。 Flask-SQLAlchemy 是一个 Flask 插件，它让我们在 Flask 框架中使用 SQLAlchemy 变得更容易。
本篇介绍我在使用 Flask-SQLAlchemy 2.1 时进行联表查询的一些经验。
表定义 这里有两个表，account 表保存帐号 ID 和昵称，bind 表保存 account 之间的绑定关系。
1
2
3
4
5
6
7
8
9
10
11
12
# 省略了外键定义，请自行脑补
create table account
(
gameuid int auto_increment primary key,
nickname varchar(34) not null
);
create table bind
(
bindid int auto_increment primary key,
fromid int not null,
toid int not null
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3407bd600e396fc7a9ffd6218871b61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/858c87105848ca5591bd9043b26a06d5/" rel="bookmark">
			Arima相关概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.cnblogs.com/bradleon/p/6832867.html
https://www.cnblogs.com/bradleon/p/6827109.html
平稳性：就是要求经由样本时间序列所得到的拟合曲线在未来的一段期间内仍能顺着现有的形态“惯性”地延续下去。平稳性要求序列的均值和方差不发生明显变化
严平稳：严平稳表示的分布不随时间的改变而改变。如：白噪声（正态），无论怎么取，都是期望为0，方差为1
弱平稳：期望与相关系数（依赖性）不变，未来某时刻的t的值Xt就要依赖于它的过去信息，所以需要依赖性
差分法：时间序列在t与t-1时刻的差值
差分（d）：现在数列=现时刻数值-前一时刻数值
也就是本时刻与前一时刻的差值作为新的数列，可以让数列 更加平稳，
数据.diff(1)：1代表与前一时刻的差值，2代表与倒数第二个数的差值。
做一次.diff(1)，就是一阶差分，再在一阶差分上做一次.diff(1)，就是二阶差分。
1 自回归模型（AR） 描述当前值与历史值之间的关系，用变量自身的历史时间数据对自身进行预测，自回归模型必须满足平稳性的。
自回归（AR），就是指当前值只与历史值有关
p阶自回归，指当前值与前p个值有关
求常数u与自回归系数ri
自回归模型的限制
（1）自回归模型是用自身的数据来进行预测
必须具有平稳性
（2）必须具有自相关性，如果自相关系数(φi)小于0.5，则不宜采用
（3）自回归只适用于预测与自身前期相关的现象
2移动平均模型（MA） 移动平均模型关注的是自回归模型中的误差项的累加，移动平均法能有效地消除预测中的随机波动。
移动平均（MA），自回归中几个误差项累加
q为移动平均项数
q阶：与前q个误差有关
3自回归移动平均模型（ARMA) 自回归与移动平均的结合
p,q指定，求解r,thta
4差分自回归移动平均模型 ARIMA(p，d，q) AR是自回归， p为自回归项；
MA为移动平均，q为移动平均项数，
d为时间序列成为平稳时所做的差分次数
原理：将非平稳时间序列，转化为，平稳时间序列；然后将因变量仅对它的滞后值以及随机误差项的现值和滞后值进行回归所建立的模型
5自相关函数ACF 有序的随机变量序列与其自身相比较
自相关函数反映了同一序列在不同时序的取值之间的相关性
Pk的取值范围为[-1,1]
（1）在不同滞后阶数的相关性（一阶：Yt与Yt-1）,滞后多少点
（2）虚线：置信区间 95%（100个点95个符合逻辑）
（3）横轴：p,0-20阶，滞后多少，也就是与前几个的关系
（4）阴影表示95%置信区间，点表示阶数
statsmodels 统计学习库
6 偏自相关函数(PACF) 对于一个平稳AR(p模型，求出滞后k自相关系数p(k)时，实际上得到并不是x(t)与x(t-k)之间单纯的相关关系。
x(t)同时还会受到中间k-1个随机变量x(t-1)、x(t-2)、……、x(t-k+1)的影响，而这k-1个随机变量又都和x(t-k)具有相关关系。
所以，自相关系数p(k)里实际掺杂了其他变量对x(t)与x(t-k)的影响。
偏自相关函数，剔除了中间k-1个随机变量x(t-1)、x(t-2)、……、x(t-k+1)的干扰之后，x(t-k)对x(t)影响的相关程度。
ACF还包含了其他变量的影响。
PACF是严格这两个变量之间的相关性。
ACF包含了其他阶的影响
PCAF只包含这两阶的影响，更绝一些，把中间阶都剔除了
7 ARIMA(p，d，q)阶数确定： 截尾：落在置信区间内（95%的点都符合该规则）
AR(p看PACF
MA(q) 看ACF
ACF中第几个点落到阴影面积中，就为第几阶p
PACF中第几个点落到阴影面积中，就为第几阶q
ARIMA建模流程
（1）将序列平稳化（差分法确定d）
（2）p和q阶数确定（ACF,PACF）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/858c87105848ca5591bd9043b26a06d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8679a936370629dd4978ae142cfdbb3f/" rel="bookmark">
			hql 判断是否为空
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		select * from table1 where id is NULL;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e1142f23bd2d1e7731ab175f0da9fb4/" rel="bookmark">
			jQuery简单的注册表单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注册表单的实现思想及步骤 明确自己需要收集的注册信息并在Html上写出表单的布局在js上进行数据接收和验证，向服务器发起注册请求，处理请求返回的数据。 代码实现 html代码 &lt;form&gt; &lt;div&gt;&lt;span&gt;用户名：&lt;/span&gt;&lt;input type="text" id="username"/&gt;&lt;span class="tishi"&gt;长度为4~20个字符，支持汉字，字母，数字及"-","_"组合&lt;/span&gt;&lt;/div&gt; &lt;div&gt;&lt;span&gt;设置密码：&lt;/span&gt;&lt;input type="password" id="password" /&gt;&lt;span class="tishi"&gt;6~20个字符，建议由字母，数字构成的组合&lt;/span&gt;&lt;/div&gt; &lt;div&gt;&lt;span&gt;确认密码：&lt;/span&gt;&lt;input type="password" id="passwords"/&gt;&lt;span class="tishi"&gt;请再次输入密码&lt;/span&gt;&lt;/div&gt; &lt;div&gt;&lt;span&gt;性别：&lt;/span&gt;&lt;input type="radio" name="sex" value="男"/&gt;&lt;strong&gt;男&lt;/strong&gt;&lt;input type="radio" name="sex" value="女" /&gt;&lt;strong&gt;女&lt;/strong&gt;&lt;/div&gt; &lt;div&gt;&lt;span&gt;邮箱：&lt;/span&gt;&lt;input type="text" id="email" &gt;&lt;span class="tishi"&gt;&lt;/span&gt;&lt;/div&gt; &lt;input type="button" value="立即注册" id="submit"/&gt; &lt;/form&gt; css代码 input{ margin: 0; padding: 0; display: block; border: none; } form{ width: 515px; height: 580px; float: left; font-size: 16px; color: #cecece; line-height: 40px; } form input{ width: 300px; height: 40px; border: 1px solid #cecece; float: left; } form span{ display: block; height: 40px; float: left; } form div{ height: 40px; width: 900px; float: left; margin: 13px 0; padding-left: 50px; } form div:nth-of-type(1){ padding-left: 115px; } form div:nth-of-type(2){ padding-left: 100px; } form div:nth-of-type(3){ padding-left: 100px; } form div:nth-of-type(4){ padding-left: 131px; } form div:nth-of-type(4) input{ width:15px; height: 15px; line-height: 40px; margin-top: 14px; margin-right: 5px; } strong{ display: block; height: 40px; width:20px; font-size: 16px; float: left; line-height: 40px; } form div:nth-of-type(5){ padding-left: 131px; } form #submit{ background: #ff5757; color: #fff; margin-left: 180px; margin-top: 20px; } form .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e1142f23bd2d1e7731ab175f0da9fb4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f005a1fe2f4f4f32253de9959c4d727b/" rel="bookmark">
			vue 自定义指令及利用跨域图片进行canvas绘制的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1：vue自定义指令 有时候需要自定义指令时候就需要用到Vue.directive,但是要注意的是该语句必须放到创建vue实例的前面：
Vue.directive("drag",{ inserted:(el: any, binding: any)=&gt;{ console.log("el is ",el); el.onmousedown = function(e) { let disX = e.pageX - el.offsetLeft; let disY = e.pageY - el.offsetTop; document.onmousemove = function(e) { el.style.left = e.pageX - disX + 'px'; el.style.top = e.pageY - disY + 'px'; } document.onmouseup = function() { document.onmousemove = document.onmouseup = null; } } } }); new Vue({ router, store, created() { if(window['isWin32']){ const settingStr = localStorage.getItem('setting'); if (settingStr) { window['ipcRenderer'].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f005a1fe2f4f4f32253de9959c4d727b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eef9922ebfa71d0711ee7bcaeaaa5d08/" rel="bookmark">
			IntelliJ IDEA 下的svn配置及使用的非常详细的图文总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：李学凯 来源：CSDN 原文：https://blog.csdn.net/qq_27093465/article/details/74898489 版权声明：本文为博主原创文章，转载请附上博文链接！ 首先，使用的时候，自己得先在电脑上安装个小乌龟。也就是svn啦。 第一步安装小乌龟。
如下：
具体安装好像没什么具体要求，一路next，就好。
如上图箭头所示，在安装 TortoiseSVN 的时候，默认 command line client tools，是不安装的，这里建议勾选上。
这个我不确定我当时选没选，不过呢，你给安装上，也是没问题的。
把上面的勾选取消了，就可以应对下面的这个错误。看图。
安装OK之后，确保你这个编辑器也已经激活成功，那么下一步开始
第二步，导出。
从svn上check out 项目我这以maven项目为例。
第一步，就是从svn上check out，当然也可以从github上check out，当然，前提是你已经配置了github和git。这就不赘述啦。
这个就是输入svn仓库的地址，然后继续ing。
选择导出的目的地，一般就是新建个文件夹用来存放所有的工作相关的项目。我这是测试，就随意点啦。
(我这地方取名字叫testCheckOut，一般你们本地可能新建个文件夹用来存放各个项目，就比如叫workspace吧，那么这个文件夹下面，就会存放项目1，项目2，，，很多个，那么下面这个图就应该选第二个，然后，导出来的效果就是在workspace下面会有n个项目目录，各自是各自，互不干扰。)
这地方应该看情况，导出的时候，最好导出到对应的项目文件夹下。第一个选项是直接到我的那个测试目录下，这个就不是太好。或者干脆就是不行的，不推荐这么干。
下面会示范，两者的差别的。
这个版本究竟是啥意思，我暂时没有深究过，不过一般都选默认的吧。
理论上导出操作完之后，会自动打开刚刚导出的项目，然后再下一步操作，但是有时候，也会出现上面这个图，估计是自动创建失败，这个时候，就的手动操作一下，他的意思就是，从一个已经存在的项目也就是你刚刚check out的项目，创建一个intelliJ idea项目。这个也是可以继续操作的。你点yes，然后继续选maven，选pom选啥的
正确的，也就是上面你选择导出到对应项目名称的文件夹下的话，就会出现下图。
哦，这个是导出的时候，他在一个个文件的往外check ，这是个过程图。
你要是导出OK，也就是说你导出项目到对应的项目名称下的话，他就会提示说，你已经导出个项目了，你需要打开吗。
当然打开啦，点yes，打开。继续ing。
这个就是打开之后的，截的全图的效果。具体注释我都写在截图上了。
因为这个mavne项目，导出之后，编辑器会自动判断一下，他要是发现pom.xml文件的话，他就会这么提示你，按我图上的操作就OK啦。
继续吧，图上写的应该比较详细啦。
这个就是刚刚导出项目之后，这个版本控制的初始情况。虽然我后面也会说，你可以依我图操作一下，看着干净舒心。
要是下面有重复讲解的地方，还请见谅啊。
经过这么操作，这就干净啦。继续看图ing。
这个就是所有提交记录的列表的地方。
刷新出来的效果。
下面奉上这个分支合并的链接，有心情的可以点点看看。
IntelliJ IDEA 详细图解 svn merge 分支合并主干，主干合并分支，都是merge一个套路
第三步，具体使用详情。
上面的都是安装过程可能会遇到的问题，下面看具体经常使用的地方。
这个工具栏，可能你刚使用这个编辑器的时候，是没有的，可以参考下面链接，把这个工具栏给显示出来。
IntelliJ IDEA中如何显示和关闭----工具栏，目录栏，
下面对这五个按钮的简单介绍。
第一个按钮：Update Project 更新项目。
第二个按钮：Commit changes 提交项目上所有变化文件。点击这个按钮不会立马提交所有文件，而是先弹出一个被修改文件的一个汇总框，具体操作下面会有图片进行专门介绍。
第三个按钮：Compare with the Same Repository Version 当前文件与服务器上该文件通版本的内容进行比较。如果当前编辑的文件没有修改，则是灰色不可点击。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eef9922ebfa71d0711ee7bcaeaaa5d08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37f6a4c6f9070bada2a24b447ea9da75/" rel="bookmark">
			使用git命令 提交多个项目到同一个仓库中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以common-code文件夹为例，有三个maven项目
右键选择Git Bash here
输入git init命令初始化仓库，项目出现绿色打钩图标，并且生成.git文件夹
然后把仓库关联到远程地址
再分别把三个项目上传本地仓库 变成红色感叹号图标
提交
git push origin master 把代码推送到远程仓库，发现报错，原因是远程仓库中存在部分文件是我们本地仓库不存在的 ，需要先pull下来
git pull --rebase origin master 运行把原先仓库中的两个文件pull下来后 然后再提交就可以了
git push -u origin master
此时远程仓库中就出现了三个项目
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81be2c87ad65cf5f6c3c906a8ef2cc91/" rel="bookmark">
			使用 TensorFlow Serving 和 Docker 快速部署机器学习服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从实验到生产，简单快速部署机器学习模型一直是一个挑战。这个过程要做的就是将训练好的模型对外提供预测服务。在生产中，这个过程需要可重现，隔离和安全。这里，我们使用基于Docker的TensorFlow Serving来简单地完成这个过程。TensorFlow 从1.8版本开始支持Docker部署，包括CPU和GPU，非常方便。
获得训练好的模型 获取模型的第一步当然是训练一个模型，但是这不是本篇的重点，所以我们使用一个已经训练好的模型，比如ResNet。TensorFlow Serving 使用SavedModel这种格式来保存其模型，SavedModel是一种独立于语言的，可恢复，密集的序列化格式，支持使用更高级别的系统和工具来生成，使用和转换TensorFlow模型。这里我们直接下载一个预训练好的模型：
$ mkdir /tmp/resnet $ curl -s https://storage.googleapis.com/download.tensorflow.org/models/official/20181001_resnet/savedmodels/resnet_v2_fp32_savedmodel_NHWC_jpg.tar.gz | tar --strip-components=2 -C /tmp/resnet -xvz 复制代码 如果是使用其他框架比如Keras生成的模型，则需要将模型转换为SavedModel格式，比如：
from keras.models import Sequential from keras import backend as K import tensorflow as tf model = Sequential() # 中间省略模型构建 # 模型转换为SavedModel signature = tf.saved_model.signature_def_utils.predict_signature_def( inputs={'input_param': model.input}, outputs={'type': model.output}) builder = tf.saved_model.builder.SavedModelBuilder('/tmp/output_model_path/1/') builder.add_meta_graph_and_variables( sess=K.get_session(), tags=[tf.saved_model.tag_constants.SERVING], signature_def_map={ tf.saved_model.signature_constants.DEFAULT_SERVING_SIGNATURE_DEF_KEY: signature }) builder.save() 复制代码 下载完成后，文件目录树为：
$ tree /tmp/resnet /tmp/resnet └── 1538687457 ├── saved_model.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81be2c87ad65cf5f6c3c906a8ef2cc91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb6339ce99707ac2d290eb30d33c525a/" rel="bookmark">
			Docker常用命令（四）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		29.容器之间的连接：
docker 默认是所有容器之间是互联的
Docker 守护进程的启动选项。—icc=true
停止一个容器重启之后IP会动态变化的，他是一个不可靠的连接，随着容器的启动会动态变化这样是不太好的，所以docker 提供了一个类似别名的东西 ，让我们拿这个别名去访问这个新启动的容器
docker run —link =[CONTAINER_NAME]:[ALIAS][IMAFE][COMMOND]
eg:docker run --name cct3 --link=cct1:webtest -it -d cct
拒绝容器间的访问： Docker 守护进程的启动选项。—icc=false 允许特定容器间的访问 —icc=false —iptables=true —link 30.Docker 容器与外部网络的连接 ip_forward=true linux 系统中的变量。他的值决定了是否转发流量 查看数据转发是否开启 sudo sysctl net.ipv4.conf.all.forwarding iptables : iptables是与Linux内核集成额度包过滤防火墙系统，几乎所有的Linux发行版本都会包含iptables的功能： 允许端口映射访问 Sudo iptables -L -n
-L 表示这个操作是现实
Iptables 中的连有3个。filter （input forward output）
使用iptables 限制访问：
sudo iptables -I DOCKER -s 10.211.55.3 -d 172.17.0.7 -p TCP —dport 80 -j DROP
参数解释：
-I：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb6339ce99707ac2d290eb30d33c525a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2b19c283b6160f4414ef8cf6bdfd1ae/" rel="bookmark">
			QT APP 打包发布流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QT APP 打包发布流程 今天说说QT Qt Widgets Application 可执行程序发布方式，就是我们创建的 Qt Widgets Application 项目，开发完成后如何发布软件，下面来看看软件发布步骤:
1、以 Release 方式编译生成 exe 程序,也就是调试运行的方式选择Release
2、运行成功后，会在源码项目文件夹的 release文件夹下生成 exe文件
3、将 project.exe 可执行文件复制到 别的文件夹下，这里我复制到 D:\工程测试\ 下
在开始菜单Qt5.5.0下找到Qt5.5 for Desktop cmd运行文件，打开运行
4、cmd进入 D:\工程测试\ , 执行命令windeployqt project3.exe
5、然后在 D:\工程测试\ 中 就可以看到发布的文件了，连依赖关系都解决了，直接可以运行
（部分转载）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3e2664d060b5940d798f7bcea9f6ff6/" rel="bookmark">
			关于Neo4j和Cypher批量更新和批量插入优化的5个建议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当通过程序向图形化数据库中写入大量数据的时候，你会希望它能够高效的处理。
低效的方式 下面这些方式不是十分有效： - 将值直接写入到语句中，而不是通过参数的方式 - 每一个更新都通过一个Transaction发送一个请求 - 通过一个Transaction发送大量的单个请求 - 生成一个巨大复杂的语句（几百行），然后通过一个Transaction进行提交 - 在一个Transaction中，发送一个巨大的请求，会导致OOM错误
正确的方式 你需要构造尽可能小的请求，并且语句格式固定（这样可以利用缓存），然后通过参数方式进行使用。
每一个请求可以只修改一个属性，或者修改整个子图（上百个节点），但是它的语句结构必须是一致的，否则就不能使用缓存。
UNWIND – 救星 为了实现这个目标，你只需要在你单次请求的前面加上一个UNWIND语句。UNWIND会将大量的数据（高达10k或者50k条）分散成一行一行的，每一行都会包含每一次更新所需要的全部信息。
你添加一个{batch}参数，并且将它的值设置成一个Map列表，其中可以包含你的数据（10k或者50k条）。这些数据会被打包成一个完整的请求，并且符合语法结构，还用上了缓存（因为其结构一致）。
语法结构 输入：
{batch: [{row1},{row2},{row3},...10k]} 语句：
UNWIND {batch} as row // 基于每一行的Map数据，编写更新语句 示例 下面是一些示例
创建节点并写入属性 数据：
{batch: [{name:"Alice",age:32},{name:"Bob",age:42}]} 语句:
UNWIND {batch} as row CREATE (n:Label) SET n.name = row.name, n.age = row.age Merge节点并写入属性 数据：
{batch: [{id:"alice@example.com",properties:{name:"Alice",age:32}},{id:"bob@example.com",properties:{name:"Bob",age:42}}]} 语句:
UNWIND {batch} as row MERGE (n:Label {id:row.id}) (ON CREATE) SET n.name = row.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3e2664d060b5940d798f7bcea9f6ff6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2199532a605264a35d94dbf1bd1c5c56/" rel="bookmark">
			restful api 规范那些事
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 公司的项目是采用微服务架构来构建的，提供的服务接口都是restful风格。之前也学习过restful的相关概念和知识。但是之前公司的项目一直没有涉及到restful，所以对于restful的理解也就停留在概念上。对于restful风格的实际操作还是有些地方需要注意下的。restful api接口设计的规范性还是很有必要去学习下的。
何为restful风格 REST这个词全称是Representational State Transfer，翻译成中文大意为表现层状态传输。当一个软件架构符合REST原则，我们称之为restful架构。说了这么多，我们为什么要使用restful架构？使用restful架构有什么好处？因为按照restful架构可以充分的利用HTTP协议带给我们的各种功能，算是对HTTP协议使用的最佳实践，还有一点就是可以使软件架构设计更加清晰，可维护性更好。
restful api规范 URL 规范 1. 动词 + 宾语 restful的核心思想就是，客户端发出的数据操作指令都是"动词 + 宾语"的结构。比如，GET /articles这个命令，GET是动词，/articles是宾语。动词通常就是五种 HTTP 方法，对应 CRUD 操作。
GET：读取（Read）POST：新建（Create）PUT：更新（Update）PATCH：更新（Update），通常是部分更新DELETE：删除（Delete） 2. 宾语必须是名词 宾语就是 API 的 URL，是 HTTP 动词作用的对象。它应该是名词，不能是动词。比如，/articles这个 URL 就是正确的，而下面的 URL 不是名词，所以都是错误的。
/getAllCars/createNewCar/deleteAllRedCars 3. 复数 URL 既然 URL 是名词，那么应该使用复数，还是单数？这没有统一的规定，但是常见的操作是读取一个集合，比如GET /articles（读取所有文章），这里明显应该是复数。为了统一起见，建议都使用复数 URL，比如GET /articles/2要好于GET /article/2。
4. 避免多级 URL 常见的情况是，资源需要多级分类，因此很容易写出多级的 URL，比如获取某个作者的某一类文章。
GET /authors/12/categories/2 这种 URL 不利于扩展，语义也不明确，往往要想一会，才能明白含义。更好的做法是，除了第一级，其他级别都用查询字符串表达。
GET /authors/12?categories=2 下面是另一个例子，查询已发布的文章。你可能会设计成下面的 URL。
GET /articles/published 查询字符串的写法明显更好。
GET /articles?published=true 5. 动词的覆盖 有些客户端只能使用GET和POST这两种方法。服务器必须接受POST模拟其他三个方法（PUT、PATCH、DELETE）。这时，客户端发出的 HTTP 请求，要加上X-HTTP-Method-Override属性，告诉服务器应该使用哪一个动词，覆盖POST方法。下面代码中，X-HTTP-Method-Override指定本次请求的方法是PUT，而不是POST。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2199532a605264a35d94dbf1bd1c5c56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fe7af0e908273b38944d8ef77c10c12/" rel="bookmark">
			基于STM32从零写操作系统系列---将printf指向串口输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如有不详细的描述、错误或疑问，欢迎留言！！！ 基于STM32从零写操作系统系列---前言与目录 这里有很多关于ARM的文档：http://infocenter.arm.com/help/index.jsp 为什么需要printf？ 首先，这个printf不是标准C中的printf，这个printf是自己参考标准库实现的。只是简单地完成了打印输出int，long long int， unsigned int， unsigned long long int， float， double和十六进制数等功能。主要用于在以后的学习中，输出变量、寄存器等的数据，便于调试程序。
1.函数调用中的参数传递 根据《Procedure Call Standard for the ARM ® Architecture》（文章结尾有下载分享）这个文档可知，标准规定在寄存器（r0-r3）和堆栈中传递参数。对于采用少量参数的子程序，仅使用寄存器，大大减少了调用的开销。还有就是，char，short，int这些类型的数据入栈时，会占用4字节的空间；long long int，double等的8字节数据入栈时，只会放置到8字节对齐的地址上。下面通过反汇编查看参数传递的过程：
C语言调用过程:
反汇编：
先了解test_func1函数的参数（long long int a1, ...）中的“...”省略号，它表示这是一个可变参数列表。用于表示将来调用该函数时，可能会传递除参数a1以外的一个、两个或多个的参数给test_func1函数。那么如何获取可变参数列表中的参数呢？经过上面的标准文档说明和反汇编代码的分析，然后参照网上的一些分享，用以下的方法获取可变参数列表：
自定义va_list类型，typedef char *va_list。其实就是一个指向char类型的指针，void类型的指针void *应该更合理（没试过）。va_list指针用于指向可变参数列表中的不同类型的参数。定义宏va_start(ap,v),ap就是va_list类型的变量，v就是靠近可变参数列表左边的第一个参数（这里是a1参数）；这个宏的目的就是用a1变量在栈中的地址初始化va_list类型的ap指针，让它指向可变参数列表中的第一个参数（这里是a2）。定义宏va_arg(ap,t),ap就是va_list类型的变量，已通过va_start（ap，v）初始化；t就是要获取的参数的类型，如在这里要获取a2参数，就是va_arg(ap，int)；这个宏的作用是首先用sizeof（t）判断要获取的参数的类型t的大小，如果是小于等于4字节，就按4字节大小在栈中取值，如果大于4字节（在这里就默认为8字节），就需要判断ap指针是否在8字节对齐的地址上，如果是就直接在当前位置取8字节数据，ap=ap+8指向下一个数据，如果不是，ap就需要ap=ap+4加4到达8字节对齐的地址上取8字节数据，ap=ap+8再加8指向下一个数据。定义宏va_end（ap），ap就是va_list类型的变量，这个宏用于销毁ap指针，就是出于安全让指针指向0地址处（相当于NULL指针）。定义宏_INTSIZEOF(n)，n是数据类型，源于计算4字节对齐。 通过定义了上面的宏，我们就可以在test_func1函数中使用这些宏去获取可变参数列表中的参数了。用法如下：
2.printf实现 printf的实现就是需要用到可变参数列表，定义好上面的宏后，就需要开始写如何格式化输出信息了。所谓的格式化，可以简单理解为在一串字符串中使用占位符表示将要输出的数据，如“a = %d\r\n”,%d就相当于占位符，表示这个位置将用一个十进制有符号整型数据（int）来代替。
怎么实现呢？其实就是通过读取格式化字符串中的每个字符，当读取到%百分号时，再读取%百分号的下一个字符，判断是什么字符，如‘d’这个字符表示将数据转换为十进制后输出。本次实验的printf只实现了一下几种格式输出：
1.十进制整型输出（包括d,u,ld,lu）
首先就是就是计算这个十进制数有几位，如123，很明显有3位，代码实现如下：
“/”斜杠表示求除法中的商，如123除以10的商为12，余数为3
例如，s32_tmp = 123；第一次计算，123除以10的商为12，即s32_tmp = 12,count = 1;第二次计算，12除以10的商为1，即s32_tmp = 1,count = 2;第三次计算，1除以10的商为0，即s32_tmp = 0,count = 3。此时s32_tmp=0，退出while循环。求得count=3，即表示123这个数有3位。
然后，从高位到低位输出十进制数，代码如下：
“%”百分号表示除法中求余数，如123除以10的商为12，余数为3
pow_10()这个函数用于求10的n次方，如pow_10(2)返回10的2次方100的值。这里需要注意pow_10()的返回值定义为long long int类型，否则在格式化长整型（ld,lu）时会出错。
myputc(),用于串口输出一个字符。
例如，s32_tmp = 123；输出第一个字符，123除以10的2次方，商为1，余数23，即c = 1,s32_tmp = 23,c + ‘0’表示1加0的ascii码0x30，就是1的ascii码0x31，然后串口输出0x31,这会在串口调试助手中显示字符1。以后的输出也是相似的，直到count为0，退出while循环。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9fe7af0e908273b38944d8ef77c10c12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc0ff6ed86071e4c4ae493b216ed1dfb/" rel="bookmark">
			搭配linux&#43;Anaconda&#43;TensorFlow&#43;Keras&#43;GPU环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		搭配linux+Anaconda+TensorFlow+Keras+GPU环境
1． 安装anaconda
注意：linux 系统不同，命令可能略有差异，如口令前sudo。以下都是如此。
将安装包copy到Server（服务器一般都是linux系统）的根目录下，
bash Anaconda3-5.2.0-Linux-x86_64.sh
或者，
wget https://repo.anaconda.com/archive/Anaconda3-5.2.0-Linux-x86_64.sh
bash Anaconda3-5.2.0-Linux-x86_64.sh
一路大胆的yes下去。
配置jupyter
python
from notebook.auth import passwd
passwd() #输入自己的密码，首次登录时会用到。命令结束时会产生一个sha:=的口令，接下来有用
jupyter notebook --generate-config
找到.jupyter文件夹下的jupyter_notebook_config.py文档，在文件末尾添加如下内容 ：
c.NotebookApp.ip=’*’
c.NotebookApp.password = ’ ‘sha1:c58e4bad8a9a:c13d1dd9fd2632e4921a87830de7710d5f942ebd’’ #为上面生成的口令
c.NotebookApp.open_browser = False
c.NotebookApp.port = 8888
此时jupyter配置结束，在浏览器中输入http://server的IP地址:8888/tree，输入自己的密码即可访问。本地的话ip地址为localhost。
安装Keras
强烈建议新建一个环境,如abc。
conda create -n abc anaconda python=3.5(强烈建议Python3.5版本，目前Keras等一些框架都支持)
source activate abc （关闭环境source deactivate）
pip install tensorflow
git clone https://github.com/fchollet/keras
4.安装TensorFlow-gpu
conda install -c anaconda tensorflow-gpu（版本为1.12）
（有很好的例子参考）
cd keras
python setup.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc0ff6ed86071e4c4ae493b216ed1dfb/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/272/">«</a>
	<span class="pagination__item pagination__item--current">273/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/274/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>