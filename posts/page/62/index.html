<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b4c8aad928f65a07a5f7e026cd67c9b/" rel="bookmark">
			如何构建自己的技术博客
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文相关知识点：
markdownVuepress/vitepressGitHub pages 托管服务 为什么建议搭建个人博客网站 拥有自己的技术博客，不仅可以提升自己的技术能力，还可以提升自己的影响力，未来也可能带来一些“睡后”收益。
对于我们职场新人来说，拥有自己的技术博客一方面可以总结沉淀自己所学内容，同时也是一个不错的加分项 – 助你获得更多的面试机会。
国内目前的一些技术博客网站：CSDN、博客园、掘金、51CTO、腾讯云等等
使用这些第三方的网站是不错的选择，但长期下来，对于个人名牌建立有很大的限制。（挂广告、私域扩展）
阮一峰的个人博客：http://www.ruanyifeng.com/blog/张鑫旭的个人博客：http://www.zhangxinxu.com/wordpress/廖雪峰的个人博客：https://www.liaoxuefeng.com/ 选型 Vuepress（vue2.0）/ Vitepres（vue3.0）+ GitHub pages
Vuepress：vue 驱动的静态网站生成器 优势：以 Markdown 为中心的项目结构，可以专注于写作；加载速度、SEO也比较友好（博客网站SEO无疑是非常重要的）；支持md中写vue组件。 Github pages：Github 提供的用于搭建个人网站的静态站点托管服务。 优势：无需购买服务器（或云服务），省去了一定费用以及服务配置等；劣势：响应速度无法跟自由服务器相比，同时搜索引擎收录不友好 markdown 目前市面上主流的文字编辑型软件，大概率都已经支持了 markdown 输入。（印象笔记、notion、语雀等等）
重视输入效率、易读性，而不是追求复杂美观的排版。
markdown 是美国科技博主 John Gruber 于 2004 年推出，是一种纯文本格式的轻量级标记语言。
*Italic*	**Bold**	# Heading 1	## Heading 2	[Link](http://a.com)	![Image](http://url/a.png)	&gt; Blockquote	* List * List * List 1. One 2. Two 3. Three `Inline code` with backticks	markdown教程：https://commonmark.org/help/
vuepress vuepress 站点本质是一个由 vue 和 vue router 驱动的单页应用。路由会根据你的 markdown 文件的相对目录来自动生成。每个 markdown 文件都通过 markdown-it 编译为 html，然后将其作为 vue 组件的模板。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b4c8aad928f65a07a5f7e026cd67c9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e75ac30f7f27055dead0d84e10c13bd0/" rel="bookmark">
			WPF文本框限制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、引言
二、文本框输入限制
1. 常见的文本框输入限制
2. 使用正则表达式进行输入验证
3. 使用InputMask控件
4. 使用Preview事件进行输入过滤
4.1、只能输入数字
4.2、只能输入英文字母和数字 4.3、只能输入中文汉字
一、引言 WPF文本框是用户输入数据的重要工具，但有时候我们需要确保用户输入的数据满足特定的格式或约束条件。这就是为什么限制文本框的输入变得如此重要。
二、文本框输入限制 1. 常见的文本框输入限制 常见的输入限制包括：
限制输入为数字。限制输入的最大长度。限制输入为特定的格式，如日期、电话号码等。 2. 使用正则表达式进行输入验证 在WPF中，我们可以使用正则表达式（Regex）来验证输入。以下是一个简单的示例，说明如何验证一个输入字段是否符合特定的正则表达式。
首先，我们创建一个名为 RegexValidator 的自定义验证器类，该类实现了 IValidator 接口：
public class NegativeNumberInputMask : InputMask { public NegativeNumberInputMask() { AcceptingCharacterEventArgs allowedCharactersEventArgs = new AcceptingCharacterEventArgs(Keys.Back, string.Empty); this.SpecialKeyPressed += InputMask_SpecialKeyPressed; } private void InputMask_SpecialKeyPressed(object sender, SpecialKeyPressedEventArgs e) { switch (e.Key) { case Keys.Back: this.RemoveChar(); break; case Keys.Enter: this.RemoveChar(); break; default: if (e.KeyChar &lt; '0' || e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e75ac30f7f27055dead0d84e10c13bd0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6420e39b4d158d572bc901212c13f01/" rel="bookmark">
			基于Python的Selenium详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、PyCharm安装配置Selenium 本文使用环境：windows11、Python 3.10.5、PyCharm 2022.1.3、Selenium 4.3.0
需要你懂的技术：Python、HTML、CSS、JavaScript
1.Seleium安装： 在PyCharm终端或window命令窗口输入以下命令
#查看已安装的Python包(可跳过) pip list #安装selenium 4.3.0 pip install selenium==4.3.0 注意：在window命令窗口安装时，首先要确保Python环境变量配置正确
##卸载Selenium命令 pip uninstall selenium 2.配置浏览器驱动 下载浏览器驱动
这里给出各浏览器（Chrome、Firefox、Edge等）的驱动下载地址，自行下载所需浏览器驱动。将下载好的浏览器驱动放置在Python安装目录下（即Python环境变量配置目录） 3. 验证 在PyCharm中新建一个Python文件，自行命名，输入以下代码：
import time # 导入selenium包 from selenium import webdriver # 打开Firefox浏览器 browser = webdriver.Firefox() # 停留三秒 time.sleep(3) # 关闭浏览器 browser.quit() 执行后，Firefox浏览器将被打开，证明Selenium安装配置完成
启动Chrome浏览器 # 打开Chome浏览器 browser = webdriver.Chrome() # 关闭浏览器 browser.quit() 启动Edge浏览器 # 打开Edge浏览器 browser = webdriver.Edge() # 关闭浏览器 browser.quit() 二、Selenium使用 2.1、加载指定页面并关闭 import time # 导入selenium包 from selenium import webdriver # 打开指定（Firefox）浏览器 browser = webdriver.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6420e39b4d158d572bc901212c13f01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab13fa0429f2be7e858809c0169fdfbf/" rel="bookmark">
			【Web UI自动化测试】Web UI自动化测试之框架篇（全网最全）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文大纲截图：
UnitTest框架：
PyTest框架：
框架： 框架英文单词 framework，为解决一类事情的功能的集合。需要按照框架的规定（套路）去书写代码。
一、UnitTest框架介绍【文末分享自动化测试学习资源】 1、什么是UnitTest框架？ 概念：UnitTest是python自带的一个单元测试框架，用它来做单元测试
自带的框架：不需要单独按照，只要安装了 python就可以用
第三方框架：想要使用 需要先安装后使用（如：pytest）
单元测试框架：主要用来做单元测试，一般单元测试是开发做的。对于测试来说，UnitTest 框架的作用是自动化脚本（用例代码）执行框架（使用UnitTest框架来管理 运行多个测试用例的）
2、为什么使用UnitTest框架？ 1）能够组织多个用例去执行
2）提供丰富的断言方法（让程序代码代替人工自动的判断预期结果和实际结果是否相符）
3）能够生成测试报告
4）UnitTest框架对于测试来说的作用是：自动化脚本执行框架（使用 UnitTest框架来管理运行多个测试用例的脚本）
3、UnitTest框架核心组成要素 1）TestCase【最核心的模块】
TestCase（测试用例），这个测试用例是UnitTest框架的组成部分，不是手工和自动化中所说的用例（Test Case）
主要作用：每个TestCase（测试用例）都是一个代码文件，在这个代码文件中 来书写 真正的用例代码
2）TestSuite
TestSuite（测试套件），用来 管理、组装（打包）多个 TestCase（测试用例）的
3）TestRunner
TestRunner（测试执行，测试运行），用来 执行 TestSuite（测试套件）的
4）TestLoader
TestLoader（测试加载），功能是对 TestSuite（测试套件）功能的补充，管理、组装（打包）多个 TestCase（测试用例）的
5）Fixture
Fixture（测试夹具），书写在TestCase（测试用例）代码中，是一个代码结构，可以在每个方法执行前后都会执行的内容
每个用例中重复的代码就可以写在 Fixture 代码结构中，只写一遍，但每次用例方法的执行，都会执行Fixture中的代码
举例：登录的测试用例
1、打开浏览器
2、输入网址
4、UnitTest框架实践 4.1 TestCase（测试用例） 介绍：
1）每个 TestCase（测试用例）都是一个代码文件，在这个代码文件中 来书写真正的用例代码
2）代码文件的名称必须按照标识符的规则来书写（可以将代码的作用在文件的开头又多行注释说明）
注意：
1）代码文件的命名规范
1&gt;代码文件名字不能以数字开头
2&gt;代码文件名字中不能有空格
3&gt;代码文件名字不能有中文
4&gt;代码文件名字由字母、数字、下划线组成，且不能以数字开头
2）代码运行没结果
原因：右键运行没有 unittest for xxx 的提示 而出现的问题
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab13fa0429f2be7e858809c0169fdfbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6e568e9f0ccb27b4543cf1a4b8eaaa0/" rel="bookmark">
			Pgsql报错: invalid input syntax for integer:‘ ‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		业务sql偶尔会报错,意思是给integer了空字符串
invalid input syntax for integer:' ' 起初我以为是alarm.status in () 这里传参问题,
因为我试了几次 把1换成2就不会报出这个错误,但看了很久也没发现1为什么会被认为是空字符
后来才发现,是因为类型强转的问题,应该是status为1时,camera.device_id为空了,导致强转为integer失败,因此报错;
修改前:
select alarm.*,camera.status as camera_status, region.name from ai.alarm_log alarm left join ai.camera on alarm.camera_id = camera.id left join vcenter.device d on d.id = camera.device_id::INTEGER left join ai.region on region.id = d.org_id::BIGINT WHERE alarm.start_time BETWEEN to_timestamp(1692806400) AND to_timestamp(1693497599) AND alarm.status in (0,1) 所以我对强转的字段加了空值转换,就不会再出现这个问题了
修改后:
select alarm.*, camera.status as camera_status, region.name from ai.alarm_log alarm left join ai.camera on alarm.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6e568e9f0ccb27b4543cf1a4b8eaaa0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42baf5d18e6b7a1c631329ece5f63208/" rel="bookmark">
			【环境与工具】IDE配置——IDEA配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文参考尚硅谷IDEA，所涉及图片大部分为笔记中内容
学习视频：尚硅谷IDEA教程(idea经典之作，idea安装，idea使用)_哔哩哔哩_bilibili
安装 更新这篇文章时，我是用的是IDEA 03.2。
IDEA安装链接
IDEA目录结构 C:\Users\用户名\AppData\Roaming\JetBrains\IntelliJIdea2021.3
-Xms128m， 16 G 内存的机器可尝试设置为 -Xms512m (设置初始的内存数，增加该值可以提高 Java 程序的启动速度。 ) -Xmx750m， 16 G 内存的机器可尝试设置为 -Xmx1500m (设置最大内存数，提高该值，可以减少内存 Garage 收集的频率，提高程序性能) -XX:ReservedCodeCacheSize=240m， 16G 内存的机器可尝试设置为 -XX:ReservedCodeCacheSize=500m (保留代码占用的内存容量) 设置的目录结构 IDEA工程 设置视图 工程界面 src：存放源码.idea 和 [项目名].iml：IDEA工程特有 模块 IDEA中创建Module 删除Module 将Module与Project解除关联
删除Module
查看项目配置 编辑器配置 设置界面
Editor——General 设置自动导包功能 设置鼠标滚轮修改字体大小 显示行号和方法间的分割线 忽略大小写提示 stringBuffer &amp; StringBuffer 设置单行显示tabs Editor——Color Scheme 修改代码中注释的字体颜色 Doc Comment-Text：文档注释Block Comment：多行注释Line Comment：单行注释 Editor——Code Style 设置超过指定 import 个数，改为* Editor——File and Code Templates 新建文档的头部注释信息 Editor——File Encodings 设置项目文件编码 Transparent native-to-ascii conversion 主要用于转换 ascii，一般都要勾选，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42baf5d18e6b7a1c631329ece5f63208/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f963d59dc5ea5b1c3ba9c185550d6b1/" rel="bookmark">
			什么时候用增量式PID，什么时候用位置式PID
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PID控制器原理：
增量式PID：
位置式PID：
什么时候用位置式PID，什么时候用增量式PID：
在设计PID控制器时，应该考虑下什么时候用增量式，什么时候用位置式。需要看控制器输出u与控制目标之间的关系。举个例子：
通过带有调节阀的管路向水箱注水，控制输出u为阀门开度，如果控制目标是注水速度（流量），则采用增量控制，达到目标流量后阀门会保持；如果控制目标是水位，则采用位置式，达到目标水位后阀门会基本处于零位，积分作用下会保持一定开度。
可以看出，当控制输出u，和控制目标是一一对应关系（一定阀门开度对应一定流量）时，采用增量式；当控制输出u,影响的是控制目标的速度（水位变化的速度，即流量）时，采用位置控制。
又比如，通过油门控制车速，也是增量控制，根据期望速度加减油门，速度到了保持住。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a99369409ce66b09ccac333ae70516ba/" rel="bookmark">
			VPN网关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阿里云VPN网关(VPN Gateway，简称VPN)是一款基于Internet，通过加密通道将企业数据中心、办公网或终端与专有网络(VPC) 安全可靠连接起来的服务。
VPN网关提供IPsec-VPN和SSL-VPN两种。
网络连接方式应用场景IPsec-VPN支持在企业本地数据中心、企业办公网络与VPC之间建立网络连接。支持在不同的VPC之间建立网络连接。SSL-VPN支持在互联网客户端与VPC之间建立网络连接。 ■同地域内需要先创建VPC
■IPsec-VPN功能默认开启
■SSL-VPN功能默认关闭
■IPsec连接是VPN网关实例和本地数据中心网关设备建立连接后的加密通信通道。
■如果IPsec连接需要绑定转发路由器实例，请选择云企业网或者不绑定。
■IPsec连接的网络类型：
公网（默认值）：表示IPsec连接通过公网建立加密通信通道。
私网：表示IPsec连接通过私网建立加密通信通道。
■IPsec连接的路由模式：
目的路由模式（默认值）：基于目的IP地址路由和转发流量。
感兴趣流模式：基于源IP地址和目的IP地址精确的路由和转发流量。
VPN网关应用 1.建立VPC与本地数据中心之间的连接。
2.实现物理专线私网流量加密通信。
3.建立VPC与客户端之间的连接。
4.建立客户端和站点之间的连接
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da971cc92159fd02c0cfcaa255f027b9/" rel="bookmark">
			13.108.Spark 优化、Spark优化与hive的区别、SparkSQL启动参数调优、四川任务优化实践：执行效率提升50%以上
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		13.108.Spark 优化
1.1.25.Spark优化与hive的区别
1.1.26.SparkSQL启动参数调优
1.1.27.四川任务优化实践：执行效率提升50%以上
13.108.Spark 优化： 1.1.25.Spark优化与hive的区别 先理解spark与mapreduce的本质区别，算子之间（map和reduce之间多了依赖关系判断，即宽依赖和窄依赖。）
优化的思路和hive基本一致，比较大的区别就是mapreduce算子之间都需要落磁盘，而spark只有宽依赖才需要落磁盘，窄依赖不落磁盘。
1.1.26.SparkSQL启动参数调优 1)先对比结果：executors优化
Hive执行了30分钟（1800秒）的sql，没有优化过的SparkSQL执行需要，
最少化的Executor执行需要640秒（提高了Executor的并行度，牺牲了HDFS的吞吐量：5个core最合适），
最大化的Executor 281.634秒（最大限度的利用HDFS的吞吐量，牺牲Executor的并行度），
优化取中间值，253.189秒。
方案1：最少化 Fat executors
---------------------------------	Fat executors	-------------------------------------------------------------------------------- ./spark-sql --master yarn \	# Fat executors (每个节点一个Executor)【优势：最佳吞吐量】 --num-executors 3 \	# 集群中的节点的数目 = 3 --executor-memory 30G \	# 每个节点的内存/每个节点的executor数目 = 30GB/1 = 30GB --executor-cores 16 \	# 每个executor独占节点中所有的cores = 节点中的core的数目 = 16 --driver-memory 1G	# AM大约需要1024MB的内存和一个Executor 耗时：Time taken: 640 seconds 方案2：最大化Tiny executors
---------------------------------	Tiny executors	-------------------------------------------------------------------------------- .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da971cc92159fd02c0cfcaa255f027b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff745f2d4a0a3088540c546a4acb2965/" rel="bookmark">
			ZYNQ CAN总线之CAN ID过滤器分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ZYNQ CAN 总线学习总结
参考链接：
https://www.uisrc.com/portal.php?mod=view&amp;aid=73
CAN基础知识总结 帧的种类 通信是通过以下 5 种类型的帧进行的。
• 数据帧
• 遥控帧
• 错误帧
• 过载帧
• 帧间隔
另外，数据帧和遥控帧有标准格式和扩展格式两种格式。标准格式有 11 个位的标识符（Identifier: 以下称 ID），扩展格式有 29 个位的 ID。
各种帧的用途如表 7 所示，各种帧的构成如图 11～图 15 所示
波特率 根据CAN规范，位时间被分成4个时间段：同步段（Sync_Seg）、传播时间段（Prop_Seg）、相位缓冲段1（Phase_Seg1）和相位缓冲段2（Phase_Seg2）
每个段由具体、可编程数量的时间份额（time quanta）组成，时间份额是位时间的基本时间单元，它的长度（tq）由CAN控制器的系统时钟（fcan）和波特率预分频器BRP定义：tq=BRP/fcan
CAN模块的系统时钟fcan是其CAN模块时钟（CAN_CLK）输入的频率。
其中位同步时间占用1个Tscl；时间段2占用(Tseg1+1)个Tscl；时间段2占用(Tseg2+1)个Tscl,所以CAN控制器的位时间(TBit)就是：TBit=Tseg1+Tseg2+Tsync=(TSEG1+TSEG2+3）*Tscl，那么CAN的波特率 (CANbps)就是1/TBit。
但是这样计算出的值是一个理论值。在实际的网络通信中由于存在传输的延时、不同节点的晶体的误差等因素，使得网络CAN的波特率的计算变得复杂起来。CAN在技术上便引入了重同步的概念，以更好的解决这些问题。这样重同步带来的结果就是要么时间段1(Tseg1)增加TSJW（同步跳转宽度SJW+1），要么时间段减少TSJW
CAN有波特率的值四以下几个元素决定：
A． 最小时间段Tscl；
B． 时间段1 TSEG1；
C． 时间段2 TSEG2；
D． 同步跳转宽度 SJW
那么Tscl又是怎么计算的呢？这是总总线时序寄存器中的预分频寄存器BRP派上了用场，Tscl＝（BRP+1）/FVBP。FVBP为微处理器的外设时钟。
而TSEG1与TSEG2又是怎么划分的呢？TSEG1与TSEG2的长度决定了CAN数据的采样点，这种方式允许宽范围的数据传输延迟和晶体的误差。其中TSEG1用来调整数据传输延迟时间造成的误差，而TSEG2则用来调整不同点节点晶体频率的误差。但是他们由于过于灵活，而使初次接触CAN的人有点无所适从。TSEG1与TSEG2的是分大体遵循以下规则： Tseg2≥Tscl2，Tseg2≥2TSJW，Tseg1≥Tseg2
总的来说，对于CAN的波特率计算问题，把握一个大的方向就行了，其计算公式可了规结为： BitRate = Fpclk/( (BRP+1) * ((Tseg1+1)+(Tseg2+1)+1)
采样时间 除了波特率之外，CAN接口还有1个重要的参数就是单bit数据的采样时间。采样时间通常用采样点时间位于整个bit时间内的百分比来表示。
(Sync_Seg+ Prog_Seg+ Phase_Seg1)/( Sync_Seg+ Prog_Seg+ Phase_Seg1+ Phase_Seg2) 如下图所示，采样点位置为(1+1+4)/(1+1+4+2)=75%。 与采样时间相关的有如下几个重要参数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff745f2d4a0a3088540c546a4acb2965/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9490b6b120625998eabb7a705da5f6c2/" rel="bookmark">
			Elasticsearch 7.6 - API高阶操作篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ES 7.6 - API高阶操作篇 分片和副本索引别名添加别名查询所有别名删除别名使用别名代替索引操作代替插入代替查询 场景实操 滚动索引索引模板创建索引模板查看模板删除模板 场景实操一把索引的生命周期数据迁移APIGEO(地理)API索引准备矩形查询圆形查询多边形查询 自定义分词器总结 分片和副本 只会CURD的boy可能对es的分片和副本概念都很模糊，更别提要怎么对一个索引设置一个合适的分片和副本大小了
分片：你可以认为是一个存储数据库，有几个分片就有几个库，本质上是将数据分片存储，达到更好的性能和容灾效果
副本：你可以认为是分片的从库，用来同步主分片的数据，平时不接受写的请求，但可以接受读的请求
怎么设置这两者的数量呢？假设ES集群有三个节点，那么分片数设置为3，副本设置为2
为什么这么设置？
首先ES是一个内存怪兽，性能全靠内存，一个分片的数据能全放内存里面这是性能最高的，所以一个节点最好只放一个分片，为什么要副本分片，因为节点有可能宕机，如果没有副本一旦宕机就失去了该主分片的数据读写能力了，有了副本，主分片挂了，副本还能升级为主，对外提供服务，像下面这个图一样，无论哪个节点宕机都不会造成太大的影响，至于数据丢失等问题不在本文讨论范围内
如下图所示：
怎么设置呢？在创建索引的时候就可以设置了
PUT http://{{es_ip}}:{{es_port}}/xxxx(索引名称) { "settings":{ "index": { "number_of_shards": "1", // 主分片数 "number_of_replicas": "1" // 每个分片的副本数 } } } 索引别名 别名是干嘛的？顾名思义就是可以替代索引的名称做一些操作，举个例子：
索引的设置和mapping一旦创建好后，是不能被修改的，但是后期扩容、字段类型变更怎么办？只能重新创建一个索引然后把旧的索引数据迁移过来吧，这要是停机迁移，那用户不得裂开？
这时候别名的好处就体现出来了，别名就等于是索引的一层代理，像上面那个场景我只需要改一下别名的指向就搞定了，多说无用，直接实操
注意：一个索引可以用多个别名，一个别名也可以赋给多个索引
添加别名 三个添加方式，唯一需要注意的就是is_write_index，这是干嘛的？
想想别名可以同时赋予多个索引，条件查询的时候好说，但插入的时候呢？我要是用别名用来插入，我咋知道要写入哪个索引呢？这个用处就是这个标识写入哪个，要是别名下只有一个索引的话，则不需要指定，默认写入，就好比一个没有负载均衡的代理
# 创建索引时直接添加别名 如下：我为alias_test2 添加了一个alias_test别名 PUT http://{{es_ip}}:{{es_port}}/alias_test2(索引名称) "aliases": { "alias_test": {} } # 创建索引后，为索引添加别名 // 1. 先创建索引 PUT http://{{es_ip}}:{{es_port}}/alias_test1 // 先创建索引 // 2.后为这个索引添加一个别名 PUT http://{{es_ip}}:{{es_port}}/alias_test1(索引名称)/_alias(别名命令)/alias_test(别名名称) # 使用别名命令 批量添加 POST http://{{es_ip}}:{{es_port}}/_aliases(别名命令) { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9490b6b120625998eabb7a705da5f6c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19cfb885dce0997953f22acb76865368/" rel="bookmark">
			Elasticsearch 7.6 - Springboot应用基础操作篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ES 7.6 - JAVA应用基础操作篇 环境准备依赖配置 实体类准备使用说明索引/映射操作创建索引和映射索引和映射相关查询删除索引 文档操作插入数据更新数据删除数据批量操作 文档查询根据ID查询根据字段精准查询根据字段分词查询控制返回字段范围查询组合查询排序+分页高亮搜索聚合查询 场景查询实操查询2023年中男、女的数量并找出对应的最大/最小年龄查询在地址中包含 "深圳" 或者 备注中包含 "积极" 的 男性青年(18-30岁)要求根据关键字找出匹配项目标，高亮实时预览分别找出男、女性别中年龄最小的三个人(TOP N)查询tag中带有某些标签的或者出身地在某某地的人，按照年龄降序，并且分页 总结 上文已经教了大家最基本的操作了，那我们在java代码里面要如何实现呢？本文的目的就是教大家在springboot框架下实现上文的API操作，也就是CURD！ 环境准备 首先我们要知道ES的API都是HTTP请求！！！！，所以什么语言都可以操作，就是发送请求和处理返回而已嘛，只是说现在这种封装不需要我们做，有人做好了，这种叫做ES的客户端！
依赖配置 我们直接采用Spring-data-es的依赖，先看一下版本依赖说明：
这里建议客户端版本和你自身搭建的es版本保持一致（es不同版本间api差异很大，如果不想出现莫名其妙的错的最好一致），所以这里我们选择springboot 2.3版本，这里给出spring-data-es的官方文档
# springboot版本 &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.2.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; # spring-elasticsearch依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-elasticsearch&lt;/artifactId&gt; &lt;version&gt;4.0.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; 因为我这ES是7.6的，所以选择使用HighLevelRestClient客户端，虽然这个已经在高版本过时了(8.x)，但是在7.x版本里面官方建议使用这个
项目引入依赖后，使用非常简单，文件中配置一下ES地址，就可以愉快的访问啦：
# yml配置文件 spring: elasticsearch: rest: uris: ip:port username: password: 实体类准备 @Data @Document(indexName = "es_apply_test") public class EsTest { @Id private Long id; @Field(type = FieldType.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19cfb885dce0997953f22acb76865368/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/412323ffa5162a31f019f1521e61e658/" rel="bookmark">
			学习Spring框架过程遇到并解决的报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
问题1：无法解析 org.springframework:spring-context:pom:5.2.10 failed to transfer 问题2：SpringBoot启动时报错：​java.nio.charset.MalformedInputException: Input length=2​
问题1：无法解析 org.springframework:spring-context:pom:5.2.10 failed to transfer 问题解决：在网上搜索了很多的资料，大家都提到了设置中关于maven文件的配置，这让我一下子想起来了，我在不同的项目下新建了一个，应该需要配置maven的"用户设置文件"
上面页面中的用户设置文件需要重写，这里的重写路径就是自己安装maven包到自己电脑上的路径
这里回顾总结一下学习的maven配置的相关知识点：
具体的maven相关知识也可查阅网站：maven官方网站
1.配置文件
maven的配置文件主要有 settings.xml 和pom.xml 两个文件。在maven安装目录，如apache-maven-3.8.1\conf目录下的settings.xml 是全局配置文件用户目录(C盘中)的.m2子目录下面的settings.xml的配置只是针对当前用户的配置项目根路径下的pom.xml主要是对当前项目的配置。局部配置优先于全局配置。 配置优先级从高到低：pom.xml&gt; user settings &gt; global settings 2.settings.xml元素详解
settings.xml中的配置我只是相应简单的了解一下，如果遇到了具体的配置，再去具体了解。
&lt;settings xmlns="http://maven.apache.org/SETTINGS/1.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0 https://maven.apache.org/xsd/settings-1.0.0.xsd"&gt; &lt;localRepository/&gt; &lt;interactiveMode/&gt; &lt;usePluginRegistry/&gt; &lt;offline/&gt; &lt;pluginGroups/&gt; &lt;servers/&gt; &lt;mirrors/&gt; &lt;proxies/&gt; &lt;profiles/&gt; &lt;activeProfiles/&gt; &lt;/settings&gt; 3.pom.xml元素详解 1. &lt;project&gt;：定义了整个 Maven 项目的配置信息。包含以下子元素：
&lt;modelVersion&gt;：指定 Maven POM 模型的版本。 &lt;groupId&gt;：定义项目的组织或团队的唯一标识符。 &lt;artifactId&gt;：定义项目的唯一标识符，通常是项目的名称。 &lt;version&gt;：定义项目的版本号。 &lt;modules&gt;：指定项目包含的模块（子项目）列表。 &lt;name&gt;：定义项目的名称。 &lt;packaging&gt;：定义项目的打包类型， &lt;properties&gt;：定义项目的属性，可以在其他地方引用。 2. &lt;dependencyManagement&gt;：用于管理项目的依赖版本号。包含以下子元素：
&lt;dependencies&gt;：定义项目的依赖项列表。 3. &lt;dependencies&gt;：定义项目的依赖项列表，包含在项目构建中使用的外部库和框架。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/412323ffa5162a31f019f1521e61e658/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6170c8df5ce97f2c42c8bcd271e70cf3/" rel="bookmark">
			ORACLE报错ORA-12514 TNS:listener does not currently know of service requested in conn
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#不知道大家是个什么情况 我的是一下情况 以下提供参考 一、首先我查看了很多很多关于这个错的资料 什么listener.org文件和tnsnames.org文件配置 我的都对 重新配置监听 就差卸载 重新装了
还好 我发现了 他报这个问题了
1.服务器重启后，数据库监听服务正常。但是数据库登陆提示，“已连接到空闲例程”。
2.已连接到空闲例程”表示数据库实例没有启动
依次输入
1. sqlplus /nolog 2. conn /as sysdba 3. startup mount 4. conn /as sysdba 3.连上数据库后，可使用select * from v$log 查看日志
4.恢复数据库然后重启。
1. recover database until time '2023-08-29' 2. alter database open resetlogs 3. shutdown 4. startup 5.连接数据后，查看sql是否正常即可。
最终我的PLSQL也能登录上去了 提供参考
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29be0935e533e28c50f50b5856de686f/" rel="bookmark">
			el-tree实现一键全选、反选功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇文章将详细讲解 vue3+Element Plus 项目中如何实现el-tree组件的一键全选反选功能：点击一键全选时，将选中所有的节点，当节点未被全部选中时 ，全选框为半选状态。（最后有增加vue2+element ui 实现代码）
vue3+Element Plus具体实现： 模板部分： 1，在合适位置（如el-tree同级）新增一个复选框组件 el-checkbox &lt;el-checkbox size="mini" :indeterminate="isIndeterminate" v-model="checkAll" @change="handleCheckAllChange" style="padding:0px;margin-right:5px;"&gt; 全选&lt;/el-checkbox&gt; 步骤详解：
（1） indeterminate 属性用以表示 checkbox 的不确定状态，一般用于实现全选的效果；
（2）v-model 绑定的值控制全选框是否为选中状态；
（3）@change是状态改变时触发的事件。
2，给el-tree组件绑定ref属性，node-key属性，以及 @check-change事件 &lt;el-tree ref="testingTree" :data="testingData" :props="testingProps" show-checkbox @check-change="testCheckChange" node-key="path" /&gt; 步骤详解：
（1） 在vue3中同样是以ref属性来获取元素；
（2）check-change 事件当复选框被点击的时候触发；
（3）node-key 节点标识 通常用id，实际开发根据后端数据来确定就好。 JS逻辑部分 3，实现全选及反选逻辑（代码有点长，我会逐句讲解） //一键全选 let checkAll = ref(false) //全选按钮的绑定值 let isIndeterminate = ref(false) //全选按钮的全选，半选样式 const testingTree = ref(null) //在vue3中使用ref获取元素需要在setup中进行声明一个同名变量 //1.1获取当前选中的节点 function testCheckChange() { // 获取Tree组件的实例，使用ref声明的变量在逻辑代码中使 用时需加 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29be0935e533e28c50f50b5856de686f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f28cb3dbe777b19d9cdb5addc6dcb11/" rel="bookmark">
			MybatisPlus-Generator
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、前言二、MybatisPlus代码生成器1、引入依赖2、编写生成代码3、配置说明3.1、全局配置(GlobalConfig)3.2、包配置(PackageConfig)3.3、模板配置(TemplateConfig)3.4、策略配置(StrategyConfig)3.4.1、Entity 策略配置3.4.2、Controller 策略配置3.4.3、Service 策略配置 4、示例演示4.1、进行代码生成：4.2、生成结果 三、总结 一、前言 本文将详细介绍mybatisplus-generator的相关使用，mybatisplus-generator是 MyBatis Plus 框架中的一个代码生成工具，它能够自动生成与数据库表对应的 Java 实体类、Mapper 接口以及 XML 配置文件。它的出现极大地提高了开发效率，让开发者能够将更多的精力集中在业务逻辑上，而不是繁琐的 CRUD 操作上。
二、MybatisPlus代码生成器 使用mybatisplus-generator可以快速生成 Entity、Mapper、Mapper XML、Service、Controller 等各个模块的代码，极大的提升了开发效率。
1、引入依赖 博客这里使用的是.vm模板引擎，所以需要手动引入velocity的依赖；
&lt;!-- velocity --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt; &lt;/dependency&gt; 2、编写生成代码 以下是mybatisplus官方提供的可交互是的代码生成的例子：
public class MyBatisPlusGenerator { // 处理 all 情况 protected static List&lt;String&gt; getTables(String tables) { return "all".equals(tables) ? Collections.emptyList() : Arrays.asList(tables.split(",")); } public static void main(String[] args) { FastAutoGenerator.create("jdbc:mysql://localhost:3306/mengjie", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f28cb3dbe777b19d9cdb5addc6dcb11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff54e0c3b3c29c0377e96b198fd041f7/" rel="bookmark">
			内存卡选购指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、存储卡的种类 1、TF卡：TF卡也叫Micro SD卡。也就是小型SD卡。SD卡的三围大概是24mm3*2mm*2.1mm.而TF卡体积缩小到15mm*11mm*1mm.这里华为还推出了更小体积的NM存储卡，比TF卡更小。可以直接放在SIM卡里使用。但价格比较高。
2、SD卡：最常用的存储卡设备。体积小，被广泛地于使用便携式装置上，例例如数码相机、平板电脑和多媒体播放器MP3,MP4,行车记录仪等。
3、CF卡：主要用于相机等拍摄设备。体积比SD卡大，但安全性和稳定性传输速度上更高。当然价格也更高。
按目前常用设备基本都是TF卡了，网上买的话有的商家会送SD卡转换器（就是大卡套小卡）
二、存储卡速度等级划分 主要有三种等级标准（Class等级标准、UHS 等级标准、VSC等级标准），每种等级又有不同的速率划分。
1、Class等级标准：早期存储卡速度等级使用Class等级来标识。主要有C10、C6、C4、C2四种标识。C2最低写入速度为2MB/秒；C4最低写入速度为4MB/秒；C6最低写入速度为6MB/秒；C10最低写入速度为10MB/秒。 2、UHS 等级标准：UHS（Ultra High Speed）超高速等级为全新的总线模式。目前有UHS-I、UHS-II、UHS-III三种版本。实现UHS标准传输速度需要设备支持，高版本向下兼容低版本，不支持该标准可以兼容降速为普通存储卡使用。日常使用U1（最低写入速度10M/S）和U3（最低写入速度30M/S）的等级标识最低写入速度。UHS-I卡的最大读取速度为104M/S，而UHS-II卡的最大读取速度为312M/S。UHS-III卡的最大读取达到了624M/S。 3、VSC等级标准：VSC（Video Speed Class）视频速度等级。4K视频的拍摄需求增大后，SD协会针对视频拍摄应用制定的视频速度等级，以识别字母V加上最低写入速度值的数字构成标识。即：V10最低写入速度10M/S；V30最低写入速度30M/S。 三、存儲卡应用性能划分（A1、A2） A2&gt;A1应用性能等级可以提升设备应用程序(APP)的启动运行和任务处理的效能。
1、适不适合放应用主要看有没有A1、A2标识，不过一般内存卡都不放应用，因为4K读写速度太慢。
2、随机读写速度往往与4K读写性能息息相关，但并不等同于，因为随机存储的单位是IOPS（Input/Output Operations Per Second），即每秒进行读写（I/O）操作的次数。
四、存储卡大小选择 1、以64G为例，1080P画质1分钟大约118M,约8.4小时
2、以64G为例，2k画质1分钟大约140M,约7.08小时
3、以64G为例，4K画质1分钟大约200M,约4.96小时
以上数据会根据画面内容丰富程度有所出入，其他大小以此类推。
个人建议直接买256G,不同大小写入速度也会有所不一致，且这个大小可以持续录一天半左右。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9837089537629fc6ec4abeb6a0ada341/" rel="bookmark">
			Linux常用命令（不定期更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录一下自己工作中常用的linux命令
查询类 top 实时查看进程
free -h 查看内存
df -h 查看已挂在的存储
fdisk -l 查看所有存储，包含未挂载
编辑类 passwd 修改密码，要进入到系统
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f40719b91b314ea43d7ff4c7f3cc1661/" rel="bookmark">
			MySQL基础入门教程（非常详细）从零基础入门到精通，看完这一篇就够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		推荐查看
数据库相关概念 MySQL百度百科 MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一 注意：MySQL究其本质就是一个管理系统，管理关系型数据库的应用软件
Windows下安装MySQL
MySQL数据类型 数值类型
字符串类型
日期类型
SQL 全称 Structured Query Language，结构化查询语言。操作关系型数据库的编程语言，定义了 一套操作关系型数据库统一标准
SQL通用语法 在学习具体的SQL语句之前，先来了解一下SQL语言的同于语法。
1). SQL语句可以单行或多行书写，以分号结尾。
2). SQL语句可以使用空格/缩进来增强语句的可读性。
3). MySQL数据库的SQL语句不区分大小写，关键字建议使用大写
4). 注释：单行注释：-- 注释内容 或 # 注释内容 多行注释：/* 注 释内容 */
SQL分类 DDL # 查询所有数据库 SHOW DATABASES; # 查看当前数据库 SELECT DATABASE(); # 创建数据库 方括号内是可选参数 # 标准语法 create database [ if not exists ] 数据库名 [ default charset 字符集 ] [ collate 排序规则 ] ; create database itcast; # 删除数据库 drop database [ if exists ] 数据库名 ; if exists 代表数据库存在在删除 DROP DATABASE IF EXISTS teste; # 切换数据库 use 数据库名 use test 对表定义操作 # 查询当前数据库所有表 show tables; # 查询表结构 desc 表名 desc test; # 查看创建表语句 SHOW CREATE TABLE 表名 SHOW CREATE TABLE tb_blog; # 创建表 /* CREATE TABLE 表名( 字段1 字段1类型 [ COMMENT 字段1注释 ], 字段2 字段2类型 [COMMENT 字段2注释 ], 字段3 字段3类型 [COMMENT 字段3注释 ], .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f40719b91b314ea43d7ff4c7f3cc1661/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20574c3fa0253e7f81b299ff891b3e7d/" rel="bookmark">
			C&#43;&#43; 构造函数、析构函数调用虚函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++虚函数是通过虚表实现的，虚函数的地址记录在虚表中，只对象完成构造完成后，虚函数的地址才最终确定。
构造函数中调用虚函数 基类先于派生类构造，所以构造时没法调用到派生类的虚函数，也就是说只能调用到自己这一层，也就是虚函数失去多态功能。
析构函数调用虚函数 派生类先于基类析构，所以析构时基类没法调用到派生类的虚函数，同样只能调用到自己这一层，虚函数也失去多态功能。
代码 #include &lt;iostream&gt; class Base { public: Base() { std::cout &lt;&lt; "Base Construct. "; this-&gt;fun2("Base::Base"); } virtual ~Base() { std::cout &lt;&lt; "Base Destruct. "; this-&gt;fun2("Base::~Base"); } virtual void fun() { std::cout &lt;&lt; "Base::fun" &lt;&lt; std::endl; } virtual void fun2(const char* caller) { std::cout &lt;&lt; "Base::fun2, caller: " &lt;&lt; caller &lt;&lt; std::endl; } }; class Derive : public Base { public: Derive() { std::cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20574c3fa0253e7f81b299ff891b3e7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df54340f528091ad3b2b9739f8c57052/" rel="bookmark">
			将python代码打包成可执行文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 打包工具使用pyinstaller安装pyinstaller库打包 Python是一种高级编程语言，它具有易学易用、跨平台等优点，因此在开发中得到了广泛的应用。
然而，Python代码需要在Python解释器中运行，这对于一些用户来说可能不太方便，因为并不是所有用户都安装python环境。
因此，将Python代码打包成可执行文件（exe）是一种很好的解决方案。
打包工具 下面几种工具，可以将Python代码打包成独立的可执行文件：
编号工具可执行文件，运行环境命令1pyinstallerWindows、Linux和MacOS上运行pyinstaller your_script.py2cx_FreezeWindows、Linux和MacOS上运行cxfreeze your_script.py --target-dir dist3py2exeWindows上运行python setup.py py2exe4py2appMacOS上运行python setup.py py2app5NuitkaWindows、Linux和MacOS上运行nuitka your_script.py6Nuitka+pyinstallerWindows、Linux和MacOS上运行nuitka --standalone your_script.py pyinstaller your_script.spec 使用 pyinstaller 安装pyinstaller库 pip install pyinstaller 打包 pyinstaller提供两种打包方式：
方式一： 在终端进入要打包的Python文件所在目录，使用pyinstaller xxx.py命令打包代码。
方式二： 在终端进入要打包的Python文件所在目录，使用pyi-makespec xxx.py命令生成spec文件，然后对spec需要修改的区域做修改，再使用pyinstaller xxx.spec命令打包代码。
使用pyinstaller打包成功之后，产生两个文件夹:
build文件夹：这是打包过程中临时文件的存放位置。这些文件包括 Python 源代码、打包脚本和其他一些中间文件。在成功打包应用程序后，该目录可以被安全地删除。dist文件夹：这是最终生成的可执行文件及其依赖项的存放位置。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fc6299537572ae43b35702ce08468f8/" rel="bookmark">
			华为放大招，国产就是强
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		昨天出现一个大消息：在完全毫无征兆的情况下，华为Mate60 Pro 直接就在自己官网上开售了。
华为这次发布的Mate60 Pro虽然没有公布任何参数，但已经有网友拿到了真机，并且确定了两个重要信息：
一是芯片是麒麟9000S，不是高通芯片；
二是手机上不显示5G信号，应该是系统专门对此进行了屏蔽，但通过网速测试软件测试，根据下载速度判断是5G手机。
更多请访问：华为放大招，希望大家能支持国产！-3YL的博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e014836169573ebe3a4eb299622d0b33/" rel="bookmark">
			（C语言）单链表基本操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编写程序实现单链表插入、删除结点等基本算法。
给定一个单链表和一系列插入、删除结点的操作序列，输出实施上述操作后的链表。
单链表数据域值为整数。
输入：输入第1行为1个正整数n，表示当前单链表长度；第2行为n个空格间隔的整数，为该链表n个元素的数据域值。第3行为1个正整数m，表示对该链表施加的操作数量；接下来m行，每行表示一个操作，为2个或3个整数，格式为0 k d或1 k。0 k d表示在链表第k个结点后插入一个数据域值为d的结点，若k=0则表示表头插入。1 k表示删除链表中第k个结点，此时k不能为0。注：操作序列中若含有不合法的操作（如在长度为5的链表中删除第8个结点、删除第0个结点等），则忽略该操作。n和m不超过100000。
输出：输出为一行整数，表示实施上述m个操作后的链表，每个整数后一个空格。输入数据保证结果链表不空。
例：
输入：
5
1 2 3 4 5
5
0 2 8
0 9 6
0 0 7
1 0 1 6
输出：
7 1 2 8 3 5 解决代码如下：
#define _CRT_SECURE_NO_WARNINGS 1 #include&lt;stdio.h&gt; #include&lt;math.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; #include&lt;malloc.h&gt; typedef struct sn { int data; struct sn* next; }SN; int main() { int n, m, l, a, b, c, i = 0; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e014836169573ebe3a4eb299622d0b33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d971b5ab74b3d41f3e2c26d82ded7e13/" rel="bookmark">
			Compose - 布局组合项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		组合函数不指定布局默认是Box堆叠。一些概念参考View版的ContraintLayout。
一、纵向 Colum inline fun Column(
modifier = Modifier,
verticalArrangement = Arrangement.Top, //子元素纵向排列规则
horizontalAlignment = Alignment.Start, //子元素横向排列规则
content: @Composable ColumnScope.() -&gt; Unit
)
1.1 使Column具备滑动能力 val scrollState = rememberScrollState() Column(Modifier.verticalScroll(scrollState)) { repeat(20) { Text(text = "aaaaaaa") } } 二、横向 Row inline fun Row(
modifier: Modifier = Modifier,
horizontalArrangement: Arrangement.Horizontal = Arrangement.Start,
verticalAlignment: Alignment.Vertical = Alignment.Top,
content: @Composable RowScope.() -&gt; Unit
)
三、堆叠 Box inline fun Box(
modifier: Modifier = Modifier,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d971b5ab74b3d41f3e2c26d82ded7e13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/261bedfa883baf5f66d9257fcb08b128/" rel="bookmark">
			3_嵌入式Linux学习_入门_vim编辑器_三种模式及其常用命令&#43;配置文件.vimrc设置常用便捷功能（永久显示行数、快捷代码模板、设置缩进等）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Linux系统中vi编辑器和vim编辑器的区别 1.1、异同点简介： vi和vim都是Linux中的编辑器，不同的是vim比较高级，功能更全更好用，可以视为vi的升级版本。vi使用于文本编辑，但是vim更适用于coding。它们都是多模式编辑器，vim 是vi的升级版本，它不仅兼容vi的所有指令，而且还有一些新的特性在里面。某些情况下，你可以把vim当成vi来使用。
1.2、vim的优势： 1、多级撤销
我们知道在vi里，按 u只能撤消上次命令，而在vim里可以无限制的撤消。
2、易用性
vi只能运行于linux中，而vim不仅可以运行于linux、windows 、mac等多操作平台。
3、语法加亮
vim可以用不同的颜色来加亮你的代码。
4、可视化操作
就是说vim不仅可以在终端运行，也可以运行于windows等。
5、对vi编辑器的完全兼容
参考博客：https://www.rstk.cn/news/743008.html?action=onClick
二、vim编辑器的安装 1、打开终端
2、输入命令：
sudo apt-get update sudo apt-get install vim 3、输入用户密码（输入时不显示）
4、等待安装即可
三、vim编辑器的三种模式 3.1、命令行模式 （command mode/一般模式） 任何时候，不管用户处于何种模式，只要按一下【ESC】键，即可进入命令行模式。且一般情况下，进入编辑器时，便是处于命令行模式下。在该模式下，用户可以输入各种合法的vim命令，用于管理自己的文档。此时从键盘上输入的任何字符都被当做编辑命令来解释，若输入的字符是合法的vim命令，则vim在接受用户命令之后完成相应的动作。但需注意的是，所输入的命令并不在屏幕上显示出来。若输入的字符不是vim的合法命令，vim会响铃报警。
3.2、文本输入模式 （input mode/编辑模式） 编辑模式可以对内容进行编辑，按下i, I, o, O, a, A, r, R等任何一个指令之后即可进入编辑模式。如果要复制、粘贴、退出、保存等系列操作时，需要回到命令行模式，则必须要按下【ESC】这个按键即可退出编辑模式。
3.3、末行模式 （last line mode/指令列命令模式） 末行模式也称转义模式。一般是用来保存退出等操作。在命令模式下，用户按“:”【冒号】键即可进入末行模式下，此时vi会在显示窗口的最后一行（通常也是屏幕的最后一行）显示一个“:”【冒号】作为末行模式的提示符，等待用户输入命令。
四、需熟悉的常用命令 4.1、命令行模式下的常用命令 4.1.1切换至编辑模式的命令 i：在当前光标所在字符的前面，转为输入模式； a：在当前光标所在字符的后面，转为输入模式； o：在当前光标所在行的下方，新建一行，并转为输入模式； I：在当前光标所在行的行首，转为输入模式； A：在当前光标所在行的行尾，转为输入模式； O：在当前光标所在行的上方，新建一行，并转为输入模式； 4.1.2光标控制 h	光标左移一个字符 j	光标下移一个字符 k	光标上移一个字符 l	光标右移一个字符 w	移至下一个单词的词首 e	跳至当前或下一个单词的词尾 b	跳至当前或前一个单词的词首 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/261bedfa883baf5f66d9257fcb08b128/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5baf61f3252745fa2dfa5ed3cbaa052/" rel="bookmark">
			如何在本地浏览器远程访问服务器jupyter
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.在服务器运行jupyter notebook
jupyter notebook --no-browser --port=8888 --ip=0.0.0.0
2.设置本地和服务器端口映射
ssh ubuntu@10.16.108.133 -L127.0.0.1:8000:127.0.0.1:8888 -p 5122
3.在本地浏览器打开服务器上的Jupyter Notebook
在本地浏览器上输入http://127.0.0.1:8000，即第2步中映射的本地端口号
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df5fc8e78095b619854c4e74489f2188/" rel="bookmark">
			一直傻傻分不清 count(*) count(id) count(1) 这次终于整明白了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		`COUNT(*)`、`COUNT(id)` 和 `COUNT(1)` 是用于计算行数的 SQL 聚合函数，它们在某些方面有一些区别。
- `COUNT(*)`：`COUNT(*)` 是一种特殊的语法，它返回结果集中的行数，不考虑任何列的值。它会将表中的每一行都计数，包括含有NULL值的行。因此，即使列中包含NULL值，它也会将其计入计数。使用 `COUNT(*)` 时 会扫描整个表，这可能导致性能下降。例如：
```sql
SELECT COUNT(*) FROM table_name;
```
- `COUNT(column)`：`COUNT(column)` 指定了要计数的具体列，它仅计算指定列中的非空值的行数。这意味着只有当该列不为NULL时，才会对它进行计数。使用 `COUNT(column)` 会忽略该列中的NULL值，因此在有NULL值的列上使用这个函数可以更准确地计算行数。例如：
```sql
SELECT COUNT(column) FROM table_name;
```
- `COUNT(1)`：`COUNT(1)` 是一种常用的优化写法。它计算的是任意列上的非空行数，因为在这种情况下，计算的列没关系。这意味着它会忽略所有列中的NULL值，只计算非空行的数目。使用 `COUNT(1)` 时会比使用 `COUNT(*)` 效率更高，因为它不需要扫描整个表的所有列。例如：
```sql
SELECT COUNT(1) FROM table_name;
```
上述提到的三种写法在一般情况下都可以达到相同的结果，只是在对待NULL值和对性能的考虑上略有不同。你可以根据具体场景和需求选择使用哪种写法。
`COUNT(*)`、`COUNT(id)` 和 `COUNT(1)` 的原理：
- `COUNT(*)`：`COUNT(*)` 是一种特殊的语法，它会扫描整个表的所有行，不考虑任何列的值。由于它不需要对具体的列进行计算，因此在执行时可以更快地得到结果。它会计算结果集中的行数，包括含有NULL值的行。
- `COUNT(column)`：`COUNT(column)` 是对指定的列进行计数。它只计算指定列中非空值的行数，也就是说该列不为NULL的行才会被计数。在执行时，它会遍历该列的每一行，检查是否为NULL，然后累计计数。
- `COUNT(1)`：`COUNT(1)` 是一种常用的优化写法，它不考虑任何具体的列，只关注行的存在与否。由于在执行时并不需要读取具体的列值，所以使用 `COUNT(1)` 可以更快地得到结果。它会忽略所有列中的NULL值，只计算非空行的数目。
这些函数的目标都是计算行数，只是在对待NULL值和对性能的考虑上有所不同。`COUNT(*)` 不管是不是 NULL 都计入，而 `COUNT(column)` 和 `COUNT(1)` 均只计入非 NULL 行。
领域驱动设计入门指南
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df5fc8e78095b619854c4e74489f2188/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b3728556db05531de9a0884c442b04c/" rel="bookmark">
			springboot docker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Spring Boot中使用Docker可以帮助你将应用程序与其依赖的容器化，并简化部署和管理过程。
当你在Spring Boot中使用Docker时，你的代码不需要特殊的更改。你可以按照通常的方式编写Spring Boot应用程序。
java示例代码，展示了如何编写一个基本的Spring Boot应用程序：
```java
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
@SpringBootApplication
public class MyAppApplication {
public static void main(String[] args) {
SpringApplication.run(MyAppApplication.class, args);
}
}
@RestController
class HelloController {
@GetMapping("/")
public String hello() {
return "Hello, Docker!";
}
}
```
在上述示例代码中，`MyAppApplication`是Spring Boot应用程序的入口点，使用`@SpringBootApplication`注解标记。`HelloController` 是一个简单的REST控制器，处理根路径上的GET请求并返回 "Hello, Docker!"。
可以根据你的需求编写其他的Spring Boot代码，例如定义数据库模型、创建服务层等等。
当你使用Docker构建和运行Spring Boot应用程序时，只需在Dockerfile中定义容器的构建规则，并在Docker中运行构建好的应用程序镜像。你的Spring Boot代码不需要进行特殊修改。
希望这个示例对你有帮助，如果还有其他问题，请随时提问。
1. 编写Dockerfile：在项目的根目录下创建一个名为`Dockerfile`的文件，并在该文件中定义Docker镜像的构建规则。
```dockerfile
# 使用基础的Java镜像
FROM openjdk:11-jdk-slim
# 设置工作目录
WORKDIR /app
# 复制应用程序JAR文件到工作目录
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b3728556db05531de9a0884c442b04c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19755da04c2ca16c162f042480b503b2/" rel="bookmark">
			【记录】Truenas scale｜NFSv4数据集的子目录或文件的ACL完全访问权限继承老是继承不了怎么回事
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我遇到了数据集下新建文件夹或文件，新建的文件夹或文件没有和数据集的ACL设置相符合的情况。其根本原因是NFSv4的完全访问权限要想继承的话，它的访问设置权限要设置“用户”和“组”的，就是，一定要选择中文的那个设置。纯@owner和@group继承会失败。
以下是我的需求和设置成功后的配置。
我需要的是让数据集以及其中的所有内容都可以被组里的所有成员访问，新建的内容也要能够成功被访问，我成功的设置如下：
之前没添加这两项的时候，新建的文件总是只能继承到创建者的权限。
至于查看权限的方法我建议最好采用命令行直接ls -al查看，比如这样：
别在windows上连上smb用是否能够点进文件夹来测试权限，因为要切换用户才能测组内的权限的情况，实在太麻烦了。
具体原因我也实在不清楚，因为不这样设置时，读取权限也能被正常继承，只有完全访问权限会出bug。
在此只是做一个分享和记录。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e668fc30e9785c8fa95c0881c743e2e9/" rel="bookmark">
			微信小程序怎么直播？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们目前使用的小程序都是支持直播功能的，小程序直播功能是通过小程序直播组件实现的，这是微信为商家提供的实时视频直播工具，可以帮助商家快速通过小程序向用户提供优质的直播内容。同时，借助小程序丰富的营销功能，使得用户可以在小程序内轻松流畅完成购买交易闭环，有效提升转化率。而关于微信小程序怎么直播？
一、开通条件
​符合以下条件的商家，可申请开通小程序直播功能。共有6个条件，其中条件1、2、3必须同时满足，条件4、5、6满足其一即可。
条件1：满足开放的服务类目要求（任选其一）：电商平台、商家自营-百货、初级食用农产品、食品、酒/盐、图书报刊/音像/影视/游戏/动漫、汽车/其他交通工具的配件、服装/鞋/箱包、玩具/母婴用品、家电/数码/手机、美妆/洗护、珠宝/饰品/眼镜/钟表、运动/户外/乐器、办公/文具、鲜花/园艺/工艺品、汽车内搭/外饰、家居/家饰/家纺、机械/电子器件、在线视频课程、直播、视频。
条件2：主体下小程序近半年没有严重违规
条件3：小程序近90天内存在支付行为
条件4：主体下公众号累计粉丝大于100
条件5：主体下小程序连续7日活跃用户数大于100
条件6：主体在微信生态内近1年广告投放实际消耗金额大于10000元
注：申请由微信官方进行处理，审核通过后即可使用小程序直播功能。
二、开通入口
登录微信小程序后台，进入【功能-直播】中点击“开通”按钮，然后阅读并勾选同意服务条款，即可开通小程序直播功能。
三、如何使用小程序直播功能
在微信小程序后台创建直播间。开通功能后，在【微信小程序后台-功能-直播-直播间】中，点击“创建直播间”。
按要求填写直播间资料，包括：直播标题、开播时间、主播昵称、主播微信账号、是否允许评论、分享卡片封面、直播间封面等。
成功创建直播间后，可以进行分享直播间、添加运营资源、查看推流小程序码操作。
四、搭建直播小程序
最后一步就是搭建我们的直播小程序，可以采用小程序制作工具【45。fkw。com】搭建，支持自定义模块样式，轻松打造丰富展示效果。
想做直播的商家不妨可以通过小程序进行直播哦，希望以上内容对大家有帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7b42a5c6a2392f4767edf33edd56fdd/" rel="bookmark">
			训练集、验证集、测试集比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 训练集验证集测试集功能用来训练机器学习模型的数据集用来调整机器学习模型的超参数（如学习率、正则化参数等）的数据集在训练和验证后用于评估模型性能的数据集规模通常是数据集的大部分，可以包含成千上万的样本验证集通常是从训练集中划分出来的，通常包含数百到数千个样本测试集通常是从数据集中划分出来的，通常包含数百到数千个样本来源划分通过留出法、交叉验证法、自助法等方法来将数据集划分为训练集和验证集可以是原始数据集中划分出来的；可以是外部真实数据集 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfed94c5985ffc311c2a594b3c224e25/" rel="bookmark">
			Ubuntu20.04下ROS2-foxy版本与PX4开发环境配置教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我自己当时配得要吐了。。。
本教程参考了Ubuntu20.04下PX4 + ROS2环境配置踩坑记录 - 知乎 （我是跟着这个大佬配置的，但是我们两个的ros版本不一样，所以在此作一些修改，我也是个小白，只是按部就班地配置，然后踩坑。。。）你要是按照我的方法来配置出现了一些奇奇怪怪的问题我也解决不了。
注意！！！ 本教程不为你解决网络问题，github上clone不下来的项目自己想办法找镜像（清华源）或者配置代理。
目录
注意！！！
1.安装ROS2-foxy版本
2.安装JAVA的jdk
3.安装交叉编译器arm-none-eabi-gcc 和 arm-none-eabi-g++ 4.安装Asio（一个跨平台的C++库，FastDDS的依赖库之一）
5.安装PX4 v1.13.1
6.安装Fast DDS &amp; Fast-RTPS-Gen
7.安装px4_ros_com &amp; px4_msgs
8.安装QGroundcontrol
1.安装ROS2-foxy版本 鱼香ROS提供了一键安装脚本，很牛逼！
小鱼的一键安装系列 | 鱼香ROS
我把命令直接写在这里吧：
wget http://fishros.com/install -O fishros &amp;&amp; . fishros 运行之后很简单易懂了。
用这个指令安装好ROS2的foxy版本，桌面版
还是用这个指令安装好VScode，然后在VScode里面装好对应的拓展
全部装好之后验证一下ros能不能正常运行：（打开2个终端，分别运行下面的命令，有输出就是装好了）
ros2 run demo_nodes_cpp talker ros2 run demo_nodes_py listener 2.安装JAVA的jdk 我装的是jdk-11.0.10_linux-x64_bin.deb的。（这个包自己去官网下载然后安装）
sudo dpkg -i jdk-11.0.10_linux-x64_bin.deb 配置home目录下的.bashrc文件（没有的话右上角三道杠显示隐藏文件）
打开.bashrc之后在末尾加上
export JAVA_HOME=/usr/lib/jvm/jdk-11.0.10 export JRE_HOME=${JAVA_HOME} export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib export PATH=${JAVA_HOME}/bin:$PATH 根据自己的具体目录和版本来配置（应该看得懂吧）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfed94c5985ffc311c2a594b3c224e25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b7d34651fc9547425184778feb65ab4/" rel="bookmark">
			Linux-MySQL主从复制详解和配置--一主一从
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是主从复制 主从复制是用来建立一个和主数据库完全一致的数据库环境，称为从数据库；主数据库一般是准实时的业务数据库。
1.主从复制的作用 1.做数据的热备，作为后备数据库，主数据库服务器故障之后，可以切换到从数据库继续工作，避免数据丢失。
2.架构的扩展，业务量越来越大，I/O访问量过高，单机无法满足，此时做多库存储，减低磁盘I/O访问的频率，提高单个机器的I/O性能。
3.读写分离，使数据库能支撑更大的并发：
--在从服务器可以执行查询操作（读）,降低主服务器的压力（主库执行写操作，从库执行读操作，从而降低压力）。
--在从服务器进行备份，避免备份期间影响主服务器服务，确保数据安全。
2.主从复制的原理 实现整个主从复制，需要由slave服务器上的I/O线程和省去了线程共同完成。
要实现主从复制，首先必须打开master端的binlog 功能
主从复制过程实际上就是slave从master端获取相应的二进制日志（binlog），然后再在自己的slave端完全按照顺序执行日志中的时间，将其执行到自己的数据库中。
---------------------------------------------------------------------------------------------
1.在主库上把数据记录到binlog日志中，
2.从库I/O线程将主库上的日志复制到自己的中继日志中。
3.从库sql线程读取中继日志中的事件，将其执行到从数据库之上
----------------------------------------------------------------------------------------------
master 负责写 A
slave relay-log B
I/O 负责通信读取binlog日志
sql 负责写数据
步骤一：主库db的更新事件(update、insert、delete)被写到binlog
步骤二：从库发起连接，连接到主库
步骤三：此时主库创建一个binlog dump thread线程，把binlog的内容发送到从库
步骤四：从库启动之后，创建一个I/O线程，读取主库传过来的binlog内容并写入到relay log.
步骤五：从库还会创建一个SQL线程，从relay log里面读取内容，将更新内容写入到slave的db.
面试题：
1.主从复制延迟比较大的原因：
主服务器配置高，从服务器配置低
并发量大导致主服务器读得慢，从服务器写得慢
网络延迟较高
从服务器的读写速度慢
从节点过多
2.从数据库的读的延迟问题了解吗？如何解决
半同步复制---解决数据丢失的问题
并行复制---解决从库复制延迟的问题
3.主从复制 一，binlog日志 首先两台机器都关闭防火墙和selinux 两台机器环境必须一致，时间也一致 # systemctl stop firewalld # setenforce 0 可以先进行域名解析 /etc/hosts 不解析也可以 后面配置的时候就要写ip # vim /etc/hosts 192.168.126.141 mysql-master 192.168.126.139 mysql-slave 添加两台机器的ip 即可 后面可以自定义 每台机器都要配置 如果有mysql 需要保证两台机器数据一致 所有这里进行了删除库内容删除日志等 省略了。。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b7d34651fc9547425184778feb65ab4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df655e082930cf4f79ec77456dfeb1d8/" rel="bookmark">
			新手利用hexo在Gitee搭建第一个博客网站（2023巨细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Gitee搭建个人博客网站之前我们需要做一些准备：注册好Gitee,安装visual studio code（功能齐全，实用)，安装node.js。
这些我都会一 一介绍。
一、Gitee注册 1、Gitee介绍 Gitee是开源中国（OSChina）推出的基于Git的一款开源的源代码管理和协作平台，类似于GitHub和GitLab。Gitee提供了Git仓库托管、代码托管、代码审查、代码协作、代码打包、部署、社交化编程、CI/CD行业领先的自动化构建、issue、Wiki等开发服务，同时，Gitee集成了很多国内外流行的代码扫描、编译、测试、部署等开发工具，公有仓库免费不限使用私有仓库托管价格低，服务稳定，反应快速。Gitee致力于为开发者提供更好的代码协作环境和更优质的服务，为开源做贡献，支持开源、关注开发者、服务创新。
Gitee目前已经成为国内最大的代码托管平台，致力于为国内开发者提供优质稳定的托管服务。
2、Gitee网站的应用 Gitee网址：https://gitee.com
在进入Gitee网页后只需要跟着它的提示步骤注册就可以使用了，Gitee界面介绍。
在这里我们可以看到各种各样的项目和工具，我们只需要找到自己需要的即可。
在搭建个人博客网站时，我们需要构建自己的仓库，仓库的搭建步骤：在右上角找到+号,第二步:鼠标右键点击新建一个仓库，取好仓库名称，它会自己给我们标好路径，输入仓库介绍，点击私有，创建就完成了一个属于我们的仓库。
新建仓库界面：
这里 建议把仓库改为 开源仓库，因为Gitee Pages 不支持私有仓库服务，但是设置为私有仓库后期也很好设置为开源仓库，仅仅需要一个步骤即可。
二、visual studio code安装 1、visual studio code介绍 Visual Studio Code是一款免费、开源、跨平台的代码编辑器，由微软公司开发，支持多种编程语言，例如：JavaScript、TypeScript、CSS、HTML等。它支持智能代码补全、语法高亮、调试、Git版本控制等功能，同时还提供了许多扩展插件，用户可以自由安装和使用。Visual Studio Code号称是轻量级的IDE，但其功能却十分强大，受到了广泛的使用和好评。
2、安装visual studio code 下载地址：VS Code的官网： https://code.visualstudio.com/下载慢，我们可以用镜像网站下载：https://vscode.cdn.azure.cn/stable/dfd34e8260c270da74b5c2d86d61aee4b6d56977/VSCodeUserSetup-x64-1.66.2.exe
运行下载安装就可以了。visual studio code界面，很适合初学者。
下载几个插件：
如果你只是搭建一个属于自己的个人博客网站，那安装到这里就可以了。如果你还想继续使用visual studio code来做一些C++实验什么的，可以看以下步骤来安装MinGW。
安装完扩展Code Runner，还需点击左边工具栏的设置图标-&gt;设置，搜索Run In Terminal并勾选Run In Terminal设置。
3、下载MinGW（搭建个人博客网站不需要安装MinGW,此处是为想实现C++的朋友做的一个补充，搭建个人博客网站跳过安装MinGW） 官方下载网站：MinGW-w64 - for 32 and 64 bit Windows download | SourceForge.net
查看你的Jdk版本是32还是64位，选择下载。cmd输入：java -version,可以看出我的64位。
x86_64是指64位的操作系统，i686是指32位的操作系统， seh是新的，支持64位系统，sjlj 是稳定的，支持64位和32位。
下载速度会有点慢。
在D盘新建文件夹：D:\MinGW-w64。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df655e082930cf4f79ec77456dfeb1d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9a837684900ec8327a93c0aadad3f29/" rel="bookmark">
			Linux安装MySQL8.0 (超完整图文详细教程)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux安装MySQL8.0 (超完整图文详细教程) 前言：本机环境win11系统、MySQL版本8.0
下载MySQL 网站进入mysql官网 ，https://dev.mysql.com/， 进入后滑动到最下面在DOWNLOADS栏中 选择MySQL Community Server（mysql社区版）
大家一定要选择安装centos7镜像对应的
安装MySQL 解压下载完的MySQL压缩包，完事之后选择以下rpm包，上传选中的文件
上传完成后（如果在上传失败，可以查看下linux权限问题，没有权限可以切换到root用户，su root），按照以下顺序解压rpm包 rpm -ivh mysql-community-common...rpm rpm -ivh mysql-community-client-plugins...rpm rpm -ivh mysql-community-libs...rpm rpm -ivh mysql-community-client...rpm rpm -ivh mysql-community-server...rpm 省略号对应大家不同的版本号。
在安装mysql-community-libs 报错
error: Failed dependencies:
mariadb-libs is obsoleted by mysql-community-libs
解决办法：卸载之前的mysql-libs
- yum remove -y mysql-libs ##再次安装 - rpm -ivh mysql-community-libs.. 在安装mysql-community-server 报错
解决的方法：在rpm 语句后面加上
安装时忽略依赖关系 rpm -ivh mysql-community-libs.. --nodeps --force 安装完成可以检查自己的MySQL版本（mysql --version） 配置MySQL 执行命令初始化（root用户，普通用户没有权限）： mysqld --initialize --user=mysql 执行完成后会在该文件中生成mysql的临时密码： cat /var/log/mysqld.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9a837684900ec8327a93c0aadad3f29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c0be9bcd712a4ab3786783202762ded/" rel="bookmark">
			Quartus FPGA工程创建流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、FPGA工程文件夹创建二、Quartus开发工程创建三、逻辑功能开发四、Modelsim仿真五、程序烧录与下载 前言 Quartus是一种由英特尔（Intel）公司开发的FPGA设计软件，旨在为数字电路设计师提供一个高效、便捷的开发环境。它可以帮助用户完成数字逻辑电路的设计、仿真、综合和布局，以及与外围设备进行通信和控制。Quartus支持多种编程语言，包括VHDL、Verilog等，并具有丰富的功能和工具库，可满足不同级别、不同规模的数字电路设计需求。
Quartus作为一种专业的FPGA设计软件，具有以下主要功能：
1. 数字电路设计 Quartus支持多种编程语言，如VHDL、Verilog等，可以用于数字逻辑电路的设计、仿真和优化。用户可以使用标准的图形界面或者代码编辑器来进行设计，同时还可使用Quartus内置的综合器和仿真器进行验证。
2. 综合和布局 Quartus能够将设计的逻辑电路综合为具体的FPGA器件，包括了自动化地寻找延时最小的逻辑网络和时序约束等功能。同时，它还支持设计布局的优化和手动调整，以提高电路的性能和可靠性。
3. 器件编程和调试 Quartus支持多种芯片编程方式，如JTAG、USB等，可以直接进入到目标芯片中进行调试和测试。此外，它还提供了丰富的调试工具和分析报告，以便用户对设计过程进行全面的监控和评估。
一、FPGA工程文件夹创建 1. 在任意一个路径下（必须是英文路径）新建文件夹（本文文件夹为AD9226）。
2. 在AD9226文件夹下新建prj文件夹（放置工程文件）、src文件夹（放置代码程序）、tb文件夹（放置仿真文件）。
3. 在src文件夹下新建test.v文件，在tb文件夹下新建test_tb.v文件。
至此，第一步结束。 二、Quartus开发工程创建 1. 打开Quartus软件
2. 新建工程
3. 进入如下界面后，选择之前新建的src文件夹中的AD9226.v文件和在tb文件夹下的AD9226_tb.v文件，并将它们打开。
然后，进入下一界面，选择FPGA芯片型号，仿真模式及开发语言。
最终界面如下，点击Finish完成工程创建。 三、逻辑功能开发 1. 在src文件夹的AD9226.v文件中完成代码编写。示例如下：
2. 在tb文件夹的AD9226_tb.v文件中完成仿真激励代码编写。示例如下： 3. 编译
四、Modelsim仿真 五 、程序烧录与下载 1. 使用quartus烧录文件
JTAG programming（烧录sof文件）:这种编程方法以将bit stream直接下载到Cyclone FPGA。只要有电源,FPGA将保持这种配置;当电源关闭时，信息将丢失。（再次启动则会读取原来在FLASH中的程序）
主动串行编程（烧录jic文件）：配置bit stream下载到FLASH。它能将数据存储在开发板中，当开发板的电源打开时，数据自动加载到 FPGA中。
2. 烧录sof
创建project文件
在这个界面选择你所用的型号。
3. 打开Tools Programmer，在add file中添加生成的sof文件，并连接好usb线。
最后点start即可。
4. 烧录jic文件
（1）点击File,然后点击Convert Programming Files
（2）将Programming file type选择成JTAD Indirect Configuration File(.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c0be9bcd712a4ab3786783202762ded/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c95375bf9ef2db7ba2af949a9be0372/" rel="bookmark">
			detr训练代码解析，训练自己的数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原始代码：21个小时/epoch
前置resieze（最大边长1333）：17个小时/epoch
数据前处理:
train：
1.随机水平翻转
def __call__(self, img, target): if random.random() &lt; self.p: return hflip(img, target) return img, target 2.随机进行两种方式的处理
def __init__(self, transforms1, transforms2, p=0.5): self.transforms1 = transforms1 self.transforms2 = transforms2 self.p = p def __call__(self, img, target): if random.random() &lt; self.p: return self.transforms1(img, target) return self.transforms2(img, target) self.transforms1(img, target) :运行 5-6，直接resize和归一化。先根据最小边长进行resize，如果最大边长小于1333，进行下一步。否则按最大边长进行resize。最小边长为[480, 512, 544, 576, 608, 640, 672, 704, 736, 768, 800]，最大边长为1333。
self.transforms2(img, target) :运行 3-6，进行resize、crop、resize、归一化
3.resize
def __init__(self, sizes, max_size=None): assert isinstance(sizes, (list, tuple)) self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c95375bf9ef2db7ba2af949a9be0372/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/041094f3247d34a63f219049c5fc1df2/" rel="bookmark">
			常见nginx管理及配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 常用命令查看nginx帮助命令查看nginx版本信息查看nginx的进程验证nginx配置文件是否正确重启nginx服务停止nginx服务 nginx配置文件常用配置http 全局块server 块rewrite 地址重定向 常见问题failed (13: Permission denied)查看nginx是否配置 ssl 模块 常用命令 查看nginx帮助命令 nginx -h ## ------------------------- 例如，输出： nginx version: nginx/1.25.1 Usage: nginx [-?hvVtTq] [-s signal] [-p prefix] [-e filename] [-c filename] [-g directives] Options: -?,-h : this help -v : show version and exit -V : show version and configure options then exit -t : test configuration and exit -T : test configuration, dump it and exit -q : suppress non-error messages during configuration testing -s signal : send signal to a master process: stop, quit, reopen, reload -p prefix : set prefix path (default: /usr/local/Cellar/nginx/1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/041094f3247d34a63f219049c5fc1df2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0c5c90aeab89cba7e4050434defb66f/" rel="bookmark">
			DNS 协议都没听过？你配做开发？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是DNS协议？ DNS协议是一种用于将域名转换为IP地址的分布式命名系统。它通过将用户提供的域名映射到相应的IP地址，实现了互联网上资源的定位和访问。DNS协议采用了层次化的域名结构，使得域名之间可以建立逻辑上的关联。
二、DNS解析过程 在理解DNS协议的工作原理之前，我们需要了解DNS解析过程。DNS解析是将用户提供的域名转换为IP地址的过程。它涉及到多个步骤，包括查询类型、递归查询和迭代查询以及DNS缓存等。
2.1. 查询类型 在DNS解析过程中，存在不同的查询类型，用于获取特定类型的DNS记录。以下是一些常见的查询类型：
A记录查询：用于将域名解析为IPv4地址。AAAA记录查询：用于将域名解析为IPv6地址。CNAME记录查询：用于获取指向另一个域名的别名记录。MX记录查询：用于获取处理域名相关电子邮件流量的邮件交换服务器记录。NS记录查询：用于获取管理特定域名区域的域名服务器记录。SOA记录查询：用于获取指定域名区域的授权域名服务器的起始权威记录。PTR记录查询：用于将IP地址解析为域名。 2.2. 递归查询和迭代查询 在DNS解析过程中，存在两种常见的查询方式：递归查询和迭代查询。
递归查询：在递归查询中，客户端向本地DNS服务器发送一个查询请求，本地DNS服务器将负责继续向其他DNS服务器发送查询，直到找到所需的DNS记录，并将结果返回给客户端。递归查询的特点是本地DNS服务器承担了查询的全部责任，直到返回结果给客户端。
迭代查询：在迭代查询中，客户端向本地DNS服务器发送一个查询请求，本地DNS服务器将返回一个指向其他DNS服务器的迭代查询响应，客户端需要继续向其他DNS服务器发送查询请求，直到找到所需的DNS记录。迭代查询的特点是客户端需要主动进行多次查询，并负责整个查询过程。
2.3. DNS缓存 DNS缓存是一种机制，用于在本地DNS服务器或客户端上存储最近查询的DNS记录。当进行DNS解析时，如果查询的域名在缓存中存在，则可以直接从缓存中获取相应的IP地址，而无需向其他DNS服务器发起请求。这可以提高解析速度和减轻DNS服务器的负载。
DNS缓存可以存在于多个层次，包括本地操作系统的缓存、本地DNS服务器的缓存以及客户端应用程序的缓存。缓存的DNS记录具有一定的生存时间（TTL），在TTL过期之前，可以重复使用缓存的记录。
通过使用DNS缓存，可以减少对DNS服务器的查询请求，提高整体的解析效率和网络性能。然而，缓存的DNS记录也可能导致一些问题，例如当域名的IP地址发生更改时，缓存的记录可能会过期，需要及时更新以避免访问问题。
这些是DNS协议中查询类型、递归查询和迭代查询以及DNS缓存的基本概念和功能。理解这些内容将有助于更好地理解DNS协议的工作原理和应用。
三、DNS记录类型 3.1. A记录 A记录（Address Record）是DNS中最常见的记录类型之一，它将域名映射到IPv4地址。当浏览器或其他应用程序需要将域名转换为IP地址时，会向DNS服务器发送A记录查询请求。
A记录示例：
example.com. IN A 192.168.0.1 上述示例中，"example.com"是域名，"192.168.0.1"是与之对应的IPv4地址。当进行域名解析时，DNS服务器会返回该A记录，使得应用程序能够将域名映射到相应的IP地址。
3.2. CNAME记录 CNAME记录（Canonical Name Record）用于为一个域名创建别名，将一个域名映射到另一个域名。CNAME记录常用于实现域名的重定向或将一个域名指向另一个域名的解决方案。
CNAME记录示例：
www.example.com. IN CNAME example.com. 3.3. MX记录 MX记录（Mail Exchanger Record）用于指定处理特定域名邮件流量的邮件交换服务器。当向特定域名发送电子邮件时，邮件服务器使用MX记录来确定邮件的传递路径。
MX记录示例：
example.com. IN MX 10 mail.example.com. 上述示例中，"example.com"是域名，"mail.example.com"是处理该域名邮件流量的邮件交换服务器。MX记录中的数字（此处为10）表示邮件传递的优先级，较小的数字具有更高的优先级。
3.4. NS记录 NS记录（Name Server Record）用于指定管理特定域名区域的域名服务器。它将域名与负责管理该域名的域名服务器进行关联。
NS记录示例：
example.com. IN NS ns1.example.com. example.com. IN NS ns2.example.com. 上述示例中，"example.com"是域名，"ns1.example.com"和"ns2.example.com"是管理该域名区域的域名服务器。应用程序在进行域名解析时，将向这些域名服务器发送查询请求。
这些是常见的DNS记录类型：A记录、CNAME记录、MX记录和NS记录。它们在DNS协议中承载着不同的功能和用途，为域名解析和网络服务提供了灵活性和可扩展性。
四、DNS在应用程序开发中的应用 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0c5c90aeab89cba7e4050434defb66f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/445ee3de806e2d5e71be99bf61f8eda2/" rel="bookmark">
			用Java实现Huffman编码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、实现思路二、准备Huffman结点三、主要实现 前言 在使用http1.1协议传输数据的时候，会有一些固定的字段，比如cookie、编码方式、接收的数据类型，另外会有一些大量重复的字段造成请求报文过于冗长，为了解决这个问题，在http2.0的时候，采用了二进制对请求报文进行编码，同时客户端和服务端维护一张静态表和静态表，对我们的请求报文进行二进制编码，同时采用Huffman编码进行压缩。
Huffman编码是一种编码方式，对出现频次更高的字段采取更短的编码，Huffman编码要求每个字符的编码不能是其他字符编码的前缀，这篇文章就是准备记录一下用Java实现Huffman编码。
一、实现思路 将出现的字符和字符出现的频次一一映射，将所有字符放进优先队列，优先队列的堆顶存放的是频次最小的字符，弹出频次最小的的两个字符，申请一个新的根节点，新的根节点左子结点是最小频次的字符，右子结点是第二小频次的字符，频次为左子节点和右子结点频次的和，将新结点加入优先队列重复上述过程
二、准备Huffman结点 public class Node { //编码字符 private char data; //频次 private int freq; //左子节点 private Node left; //右子节点 private Node right; } 三、主要实现 public static void main(String[] args) { char[] charArray = { 'a', 'b', 'c', 'd', 'e', 'f' }; int[] charFreq = { 45, 13, 12, 16, 9, 5 }; PriorityQueue&lt;Node&gt; priorityQueue = new PriorityQueue&lt;&gt;(6, new Comparator&lt;Node&gt;() { @Override public int compare(Node o1, Node o2) { return o1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/445ee3de806e2d5e71be99bf61f8eda2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5268d91d3b988caa198f74586f896807/" rel="bookmark">
			4x2矩阵按键的短按和长按
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		4x2矩阵按键的短按和长按 前言一、识别矩阵按键的具体按键二、识别具体按键的短按和长按总结 前言 最近在项目中遇到一个4x2矩阵按键的问题，各种百度了好久，都是在说4x4的矩阵按键（当然，通过4x4来推4x2的矩阵按键也没毛病），但是我现在的需求是识别出具体某个按键被按下后，是短按还是长按。
于是，我又找了好久，终于在阿B上找到了能满足我的需求的视频，按照上面所讲的结合我自己写的矩阵按键，终于实现了这个功能，在这里做个笔记。下面这个是阿B上的视频标题，通过搜索这个就能找到。
一、识别矩阵按键的具体按键 这里我用的是行列扫描法，由于我的6个IO口不是同一P引脚，所以我这里写了一个函数，方便对IO口赋值和对按键状态编码。
1、首先初始化6个IO引脚的工作模式为准双向模式
下面依次这样接了KEY_SET和BT_KEY]
void Key_Init(void) { /*********************** | * 说明 * | 0,0准双向口 | 0,1推挽输出 | 1,0高阻输入 | 1,1开漏 ************************/ P6M1&amp;=~(1&lt;&lt;0);P6M0&amp;=~(1&lt;&lt;0);	/* KEY_SET P00*/ P6M1&amp;=~(1&lt;&lt;1);P6M0&amp;=~(1&lt;&lt;1);	/* BT_KEY P02*/ P6M1&amp;=~(1&lt;&lt;2);P6M0&amp;=~(1&lt;&lt;2);	/* KEY0or1 P24*/ P6M1&amp;=~(1&lt;&lt;3);P6M0&amp;=~(1&lt;&lt;3);	/* KEY_MOD P27*/ P6M1&amp;=~(1&lt;&lt;4);P6M0|=1&lt;&lt;4;	/* NetInto1 P37*/ P6M1&amp;=~(1&lt;&lt;5);P6M0|=1&lt;&lt;5;	/* NetInto2 P36*/	} 2、写一个方便给6个IO口引脚赋值的函数
/************************************************************************* * 函 数 名: Key_Pin * 函数功能: 给按键引脚赋值0 or 1 * 输 入: p1-p4为高四位赋值，n2,n1为低四位的3,4为赋值 * 返 回 值: Key_Value的高四位为行按键的引脚值，低四位中的3,4位为列按键的引脚值 *************************************************************************/ uchar Key_Pin(uchar p1,uchar p2,uchar p3,uchar p4,uchar n1,uchar n2) { uchar Key_Value=0x00,Key_PinValue[8]={0x00}; KEY0or1=p1; KEY_MOD=p2; KEY_SET=p3; BT_KEY=p4; NetInto1=n1; NetInto2=n2; Key_PinValue[7]=KEY0or1; Key_PinValue[6]=KEY_MOD; Key_PinValue[5]=KEY_SET; Key_PinValue[4]=BT_KEY; Key_PinValue[3]=NetInto1; Key_PinValue[2]=NetInto2; Key_Value |= Key_PinValue[7]&lt;&lt;7; Key_Value |= Key_PinValue[6]&lt;&lt;6; Key_Value |= Key_PinValue[5]&lt;&lt;5; Key_Value |= Key_PinValue[4]&lt;&lt;4; Key_Value |= Key_PinValue[3]&lt;&lt;3; Key_Value |= Key_PinValue[2]&lt;&lt;2; Key_Value |= Key_PinValue[1]&lt;&lt;1; Key_Value |= Key_PinValue[0]&lt;&lt;0; return Key_Value; } 3、按键扫描函数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5268d91d3b988caa198f74586f896807/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34c445f14c6c3270625769223ed267ac/" rel="bookmark">
			Docker 容器的DNS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.简介 DNS服务是域名系统的缩写， 英文全称：Domain Name System，将域名和IP地址相互映射。在容器环境中，DNS至关重要，
Docker link
Docker link是一个遗留的特性，在新版本的Docker中，一般不推荐使用。简单来说Docker link就是把两个容器连接起来，容器可以使用容器名进行通信，而不需要依赖ip地址（其实就是在容器的/etc/hosts文件添加了host记录，原本容器之间的IP就是通的，只是我们增加了host记录，可以不用IP去访问）
创建容器centos-1： [root@host1 ~]# docker run -itd --name centos-1 registry.cn-shanghai.aliyuncs.com/public-namespace/cr7-centos7-tool:v2 创建容器centos-2，使用--link name:alias，name就是要访问的目标机器，alias就是自定义的别名。
[root@host1 ~]# docker run -itd --name centos-2 --link centos-1:centos-1-alias registry.cn-shanghai.aliyuncs.com/public-namespace/cr7-centos7-tool:v2 查看容器centos-2的/etc/hosts文件：
[root@host1 ~]# docker exec centos-2 cat /etc/hosts 127.0.0.1 localhost ::1 localhost ip6-localhost ip6-loopback fe00::0 ip6-localnet ff00::0 ip6-mcastprefix ff02::1 ip6-allnodes ff02::2 ip6-allrouters 172.18.0.2 centos-1-alias 9dde6339057a centos-1 #容器centos-1的host记录 172.18.0.3 f1a7e5fa3d96 #容器centos-2自身的host记录 意味着centos-2可以用centos-1-alias，9dde6339057a，centos-1来访问原先创建的容器。centos-1是不可以通过hostname访问centos-2的。
[root@host1 ~]# docker exec centos-2 ping centos-1-alias PING centos-1-alias (172.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34c445f14c6c3270625769223ed267ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14da4d62ea2467bc734e03eafc86be05/" rel="bookmark">
			（python）百分制成绩转换五分制(循环)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 编写一个成绩转换程序，用户输入百分制的成绩，成绩大于或等于90且小于或等于100的输出为“A”，成绩大于或等于80且小于90的输出为“B”，成绩大于或等于70且小于80的输出为“C”，成绩大于或等于60且小于70的输出为“D”，成绩小于60的输出为“E”。输入数据不合法时输出“不合法”。用户可反复输入成绩进行转换，输入负数时输出“end”并结束程序。
输入：每次输入一个浮点数，代表百分制成绩；反复输入，输入负数结束程序
输出：根据每一次的输入值分别输出A、B、C、D、E中的一个字母或"不合法"或"end"。输出end时程序结束。
循环解法：
while True: score = eval(input()) if score &lt; 0: print('end') break elif score &gt; 100: print('data error!') elif score &gt;= 90: print('A') elif score &gt;= 80: print('B') elif score &gt;= 70: print('C') elif score &gt;= 60: print('D') else: print('E') 索引解法：
degree = 'EEEEEEDCBAA' while True: score = float(input()) if score &lt; 0: print('end') break else: print('data error!') if (score &gt; 100 or score &lt; 0) else print(degree[int(score //10)]) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5be6fb4df8dbaae4363fc06d52ab4e38/" rel="bookmark">
			学习：游戏AI探索之旅
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		王亮：游戏AI探索之旅——从alphago到moba游戏
分为四部分： 第一部分，什么是游戏AI，游戏AI为什么对现在的游戏非常重要
业界和工业界对于做游戏AI主要的方法，以及现在业界一些主流的游戏上的进展结合MOBA游戏，讨论一些探索研究及现在的进展会简单介绍一下基于深度学习方法来做游戏AI，对于游戏开发者来说需要提供哪些环境便于AI的开发 什么是游戏Al：
对于游戏开发者而言是增进用户体验，提示游戏玩家的活跃度，方法主要是基于一些人工规则的方式。
几乎所有的游戏都有自己的游戏Al，例如：棋牌类的Alphago，Moba游戏会的小兵，防御塔等，其实越复杂的游戏对Al的依赖程度越高。Al在游戏中常用的方式：
人机对战：Al为游戏提供一种玩法，玩家可以选择与游戏Al对战熟悉游戏；
平衡性测试：辅助游戏设计开发，如：游戏数值改变，Al可以用于验证数值变化带来的影响。
对于射击类游戏，Al可以用于探索地图等。
通用的游戏AI的设计,包含三部分: 感知系统、决策系统、导航系统；游戏AI的决策操作基于一定的时间粒度进行循环工作。
常用的游戏AI方案，游戏AI常用方法分为三类：
工业界常用的行为树、有限状态机及势力图：优点：实现逻辑清晰，不足：固定逻辑执行，容易被玩家识破，复杂逻辑难实现； search方法，常用的方法：遗传算法、蒙特卡洛搜索树方法等；基于learning的方法： 监督学习算法、强化学习算法； 监督学习算法：基于训练数据，难点是抽象状态环境以及执行操作Action，通常Action的定义直接影响模型的上限；对于复杂游戏来讲，对于状态s很难定义最优的Action操作。
强化学习回避SL中如何确定“正确”A的问题，转而定义reward（例如赢一场比赛reward=10，击杀对方英雄reward=1, 自身死亡reward=-5）；
强化学习通常用于序列操作决策问题，对于强化学习来说，特别是复杂游戏，遇到的挑战：
Exploration(探索：能够帮助智能体通过不断试验获得反馈）和exploitation（利用：是指利用已有的反馈信息选择最好的动作）的问题。 对于游戏玩法时间较长，如何解决reward delay（延迟满足）问题。 在MOBA游戏上的AI研究与探索。王者荣耀是一款即时战略游戏，与Dota，LoL是同类型游戏。MOBA游戏特点：注重英雄的操作，英雄设计较为复杂。介绍AI技术方案之前，首先我们来看下做MOBA类游戏难点在哪：
强化学习在围棋上成功的应用，为什么Moba类游戏AI还没有战胜人类的职业选手？以王者荣耀这款游戏来分析，从状态训练空间来看，王者的操作基本是在102000，围棋只有10170。操作序列空间也存在巨大差别，导致计算会非常非常大。
王者荣耀跟围棋存在什么样的差异：从AI的个数上来说，围棋只有一个AI，只需关注黑白子。对于王者来而言却是有多种对战情况的，5V5，3V3，是多个AI的操作。其次就是确定性的问题，下围棋落子即定，不存在下完还可能下不成功的问题。而对于战略性游戏却是非确定的操作，即使发出了技能也有可能被人打断，所以是非确定性的操作。对于状态可观测性，围棋可以看到整体的情况，而王者地图对于玩家而言是部分可见，只能看到友方的视野，这样就会涉及到博弈问题：如何去预测敌方的位置。
目标学习问题：目标学习是非常重要的，首先需要解决每个英雄要去哪里的问题，对每个英雄或者对每类英雄要去的位置和出场是不一样的。其次就是选目标的问题：游戏中有七十多个英雄，每一局英雄可能不一致，如何解决英雄不一致的问题？因为AI学的是用户的操作，每个英雄技能设计不一样，有的是方向型的技能，有的是指向型技能，有的是位置型技能。
第三个难点是知识表达的问题。如果对于一个复杂英雄如：露娜，李白，玩家没有熟悉一百场练习很难熟练操作这复杂英雄。露娜无限连怎么打，关羽的无限推，李白四字真言，诸葛亮大招躲避。另外每个英雄有一些技能状态变化的设计，例如说花木兰，它的技能会随着三技能的变更，前两个技能效果也会变。这些如何表示？对于人来说是游戏常识，难点在于对于AI如何进行表达。
对于遇到的主要问题我们的解决方案：第一是引入框架进行分层，任务分层场景切分。对于知识表达，引入了多模态的特征表达方式：卷积特征+向量特征+时序特征；模型采用多深度学习模型结合。
王者AI的主要技术解决方案。框架设计主要包含两大组成部分：游戏分析和策略模块。游戏分析模块主要包含：英雄搭配问题，装备策略的分析等。策略执行模块用以解决：接下来去做什么，到达对应地点后如何进行对战的问题。
大局观设计，大局观是解决下一时刻位置问题。具体来说对于英雄它下一次的热点在哪里？下一次的战斗位置在哪儿？或者它下一次蹲草丛在哪个位置。微操的设计，微操解决的是场景发生战斗的问题。我们特征采用多模态方式组织：位置相关信息通过imagelike特征组织，属性信息通过向量特征表征，采用深度学习的Multi-task模型。
整体来说随着强化学习，深度学习方向进展，以前主要是基于规则，现在主要是基于学习方式来研究AI。如果采取基于学习的方式研究AI对于开发者而言需要提供相关的环境便于开发者进行迭代调试。总而言之，MOBA类游戏AI研发遇到很多困难与挑战，但也充满了机会。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b24131f3838fd2e531c7d02b68d8c2e/" rel="bookmark">
			【C/C&#43;&#43;】课程设计：通讯录管理系统源码，C语言链表实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好呀，亲爱的小伙伴们！你们今天有在编写代码吗？
如果有熟悉的小伙伴看到我，就会知道又到了学习源码项目的好时机了！没错，今天要分享的同样是一个经典的管理系统项目：通信录管理系统！我们一起来探索一下吧！
涉及知识领域：C语言，链表数据结构
开发所需工具：Visual Studio 2022/2019（如果没有安装这款软件，也可以点击获取哦）
完成一个通讯录管理系统，具体要求如下：
1. 建立通讯录信息，信息至少包含编号、姓名、年龄、电话、通讯地址、电子邮箱等
2. 能够提供添加、删除和修改通讯录信息的功能
3. 能够提供安不同方式查询的功能；如按姓名或年龄、电话等查询
4. 将通讯录保存在文件中
5. 能够按表格方式输出通讯录信息
6. 退出程序
也不说太多多余的话了，先看一下效果图：
为了照顾那些想要快速完成项目设计的同学，咱们就不进行源码的解析了，直接上全部源码吧！
源码分享： #include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
typedef struct
{
char num[6]; // 将编号数组大小修改为6，以容纳字符串结尾的'\0'
char name[10]; // 将姓名数组大小修改为10，以容纳字符串结尾的'\0'
char sex[4]; // 将性别数组大小修改为4，以容纳字符串结尾的'\0'
char phone[14]; // 将电话数组大小修改为14，以容纳字符串结尾的'\0'
char addr[32]; // 将地址数组大小修改为32，以容纳字符串结尾的'\0'
} DataType;
typedef struct node
{
DataType data;
struct node* next;
} ListNode;
typedef ListNode* LinkList;
void CreateList(LinkList* L, int m)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b24131f3838fd2e531c7d02b68d8c2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bab3594a3b8b1104964eb2b123eabf4d/" rel="bookmark">
			多串口高速率数据收发（dma&#43;空闲中断&#43;fifo）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于在项目使用多串口与不同模块通信的情况，实时数据有收有发，没有良好的接受机制与任务调度机制容易丢数据。
方法一
正常配置stm32cubemx，开启dma（开启循环模式）、TIM与相应中断
将缓存区取得适当大一点，充分利用缓存区空间可以提高效率
usart.h
#include "stdio.h" #include "string.h" #include "stdio.h" #define BUFFER_SIZE 1024 extern volatile uint8_t usart1_rx_len ; //接收一帧数据的长度 extern volatile uint8_t usart2_rx_len ; //接收一帧数据的长度 extern uint8_t usart1_rx_buffer[BUFFER_SIZE]; //接收数据缓存数组 extern uint8_t usart2_rx_buffer[BUFFER_SIZE]; //接收数据缓存数组 extern volatile uint8_t numdata ; //接收缓存区位置标记 extern volatile uint8_t numdata1 ; //接收缓存区位置标记 usart.c
volatile uint8_t usart1_rx_len = 0; //接收一帧数据的长度 volatile uint8_t usart2_rx_len = 0; //接收一帧数据的长度 uint8_t usart1_rx_buffer[BUFFER_SIZE]={0}; //接收数据缓存数组 uint8_t usart2_rx_buffer[BUFFER_SIZE]={0}; //接收数据缓存数组 volatile uint8_t numdata=0 ; volatile uint8_t numdata1=0 ; stm32f1xx_it.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bab3594a3b8b1104964eb2b123eabf4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b2676c65e956d0a121ecd55d96ec95e/" rel="bookmark">
			和辉光电工业工程师岗周末加班按两倍工资计算，节假日按三倍工资
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记一次难得的面试经历
现在改简历还来得及，简历筛选助你一臂之力
offer求比较
网易游戏原画师面经
网易雷火游戏原画师三轮面试
高薪硬科技企业介绍系列1-博世
我也不想打工啊，可是这是快手诶！
24届秋招汇总
库洛美术岗一面
联影医疗前景很好，但不推荐来
巨人网络游戏美术设计二面
腾讯 游戏2D美术设计 面经分享
中兴综合面+联影医疗二面
产运实习面试官跟我说简历折损…
第一次面试给了美团
海信 信动力 芯片数字后端面经
联影医疗mark
百度-C++一面
得物数分面试场景题
海信信动力 软硬件开发岗完整面经
24届秋招汇总
24届秋招汇总
盘点一波可以投的公司
华为看重学历还是方向？
码一些重庆的公司
机器学习面经-LR
材料女硕士秋招的心路历程
Java 垃圾回收机制
毕业两年回看自己的offer选择，我现在后悔了吗？
华为24届校招机考题库
JVM GC 垃圾收集简介
淘天约面啦~！！
在经历人生第一场笔试前的焦虑失眠之后，成功渡劫。在想补觉没补成的下午，接到了淘天的电话约面试时间。呜呜呜太激动了，即将迎来人生第一面值得我单独为它发篇帖子！！！
【2024届 华为云校招】华为云校招启动
网申：1、登陆https://career.huawei.com/ 选择校园招聘-应届生/留学生2、职能选“研发”，职位搜索关键字“测试工程师”或者“软件开
题解 | #求int型正整数在内存中存储时1的个数#
n=int(input())b=bin(n)print(b.count("1"))
题解 | #牛牛的新数组求和#
#include &lt;stdio.h&gt;int cal(int * array,int n){ int s=0,sum=0; whi
今年都是海面吗
说实在的，我已经有点糊涂，面的四家公司都进二面，今年二面也变成海面了吗，应该不至于吧ರ_ರ 心塞
京东2024届秋招笔试真题
T1 讨厌鬼的数组构造给定一个长度为 n 的序列啊， 请你构造一个序列b, 序列b满足以下条件：序列b的长度为n；对于任意 i ∈ [1, n], 满足 (
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b2676c65e956d0a121ecd55d96ec95e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e63b355a04624a5280af4095da07778c/" rel="bookmark">
			Linux系统下vim常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基础命令：
v:可视模式 i:插入模式 esc:命令模式下 :q ：退出 :wq ：保存并退出 ZZ：保存并退出 :q! ：不保存并强制退出 二、在Esc下：
dd : 删除当前行 yy:复制当前行 p:复制已粘贴的文本 u:撤销上一步 U:撤销对整行的操作 r:替换光标所在文本 R:替换并可以追加文本 三、查找命令
/text :查找text关键字，按enter后，按n找下一个，N找前一个 ?text:反向查找text，按enter后，按N找下一个，n找前一个 :set number: 显示行号 :set ignorecase:忽略大小写 :set noignorecase:不忽略大小写 :set hlsearch:高亮查找 四、shell脚本
五、注释命令
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbddef072dbad418b4cb14681280e573/" rel="bookmark">
			Java：类和对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、类的描述 //类名用大驼峰 class Person{ //属性 字段 成员变量 //定义在类当中，方法外部 //普通成员变量 public String name; //静态成员变量 public static int age = 10; //普通成员方法 public void sleep(); //静态成员方法 public static void staticMethod(){ } } Java中每个类都会产生一个字节码文件
2、类的实例化 Person p1 = new person(); 访问成员变量
p1.name = "张三"; p1.sleep(); 3、this引用 注意：
1、this只能在成员方法中用
2、静态变量不属于this（静态变量不属于实例化对象，而this本质上是实例化对象）
this的三种应用
（1）访问成员变量
（2）访问成员方法
public class Date{ public int year; public int month; public int day; //形参隐藏了一个date this public void setDate(int year,int month,int day){ this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbddef072dbad418b4cb14681280e573/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49250b26ca8798762ad813a5c379ba0a/" rel="bookmark">
			NetCore下WebApi的后台服务BackgroundService
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言：最近发现个好东西就是BackgroundService，以前一直没注意到。个人理解它就是在你的后台开了一个子线程运行你的其他业务逻辑。
先上代码：
public class ValueHisWorker : BackgroundService { public override async Task StartAsync(CancellationToken cancellationToken) { await base.StartAsync(cancellationToken); } public override Task StopAsync(CancellationToken cancellationToken) { return base.StopAsync(cancellationToken); } protected override async Task ExecuteAsync(CancellationToken stoppingToken) { while (!stoppingToken.IsCancellationRequested) { try { //业务逻辑 await Task.Delay(10000, stoppingToken); } catch (TaskCanceledException) { } } } } 还需要在startup里面注册一下：
public IServiceProvider ConfigureServices(IServiceCollection services) { services.AddHostedService&lt;ValueHisWorker&gt;(); } 应用场景：定时提醒。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8372398047e6c4100480a6b7f71389da/" rel="bookmark">
			DeepLabV3&#43;模型训练全过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、DeepLabV3+介绍 Deeplabv3+模型是由谷歌在2021年提出来的一个用于语义分割的模型，它可以进行多分类语义分割也可以进行实例分割，在公共数据集PASCAL VOC 2012和Cityscapes上达到了89.0%及82.1%的精度，同时也是一个较为轻便的模型，因此Deeplabv3+是一个兼具了速度和精度的模型。此次，我选用了resnet101为主干模型的DeeplapV3+。
二、数据集制作： 1）首先把图片和json文件分开，自己编写代码。
# coding:utf-8 import os import random import argparse import shutil ''' 把一个文件夹中的图片和json文件按照比例分为训练集和测试集 ''' def split1(path,trainPath,testPath): trainval_percent = 1.0 train_percent = 0.8 total_path = os.listdir(path) num = len(total_path) list_index = range(num) tv = int(num * trainval_percent) tr = int(tv * train_percent) trainval = random.sample(list_index, tv) train = random.sample(trainval, tr) print("训练集数量：",len(train)) print("测试集数量：",len(total_path)- len(train)) for i in list_index: old_jpg_path = path + total_path[i] name = total_path[i].split(".")[0] old_json_path = path + name + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8372398047e6c4100480a6b7f71389da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efeac9dbf2f7833c732ef56388ddb402/" rel="bookmark">
			windows系统下载配置mysql免安装版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、下载二、配置（一）服务配置（二）创建库及信息 前言 最近由于工作需要，需要在自己电脑上安装下mysql，以此记录下，以免后面忘记。
以下是以mysql免安装版（windows）为例，记录下安装和配置的过程及所遇到的问题。
一、下载 1.mysql官网地址：https://www.mysql.com/
2.选择下载，进入下载页面。
3.下滑至下载页面最下方，点击以下按钮，选择社区服务，之后就可以选择相应的mysql版本；
二、配置 （一）服务配置 1.解压，以管理员的身份（这块未做过多研究，是否真的需要管理员身份运行）打开命令提示框，进入mysql的bin目录下面；
2.mysql服务安装，这块遇到了一个小问题，就是写命令的时候多写了一个空格，导致预想的效果没有出现，不过最终改过来了。命令：mysqld --install
3.mysql初始化，生成的随机密码需要记录下，命令：mysqld --initialize --console
4.开启mysql服务，后续可在任务管理器里面将启动方式调为手动，需要用时再进行开启，命令：net start mysql ， 与之相反的命令是：net stop mysql （关闭服务）
5.验证mysql服务，登录mysql，密码为之前生成的随机密码，命令：mysql -u root -p
6.修改登录密码，命令：alter user ‘root’@‘localhost’ identified by ‘root’;（;很重要）
（二）创建库及信息 可参考以下文章
mysql创建数据库命令（windos系统）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbf65e6738bac21612709d22cc604116/" rel="bookmark">
			SOLO实例分割模型训练过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、SOLO介绍
SOLO（Segmenting Objects by Locations）是阿莱德大学和字节跳动联合研究的，算法的核心思想是将分割问题转化为位置分类问题，从而做到不需要 anchor（锚框）及 bounding box，而是根据实例的位置和大小，对每个实例的像素点赋予一个类别从而达到对实例对象进行分割的效果。
代码地址：GitHub - WXinlong/SOLO: SOLO and SOLOv2 for instance segmentation, ECCV 2020 &amp; NeurIPS 2020.
参考博客：
SOLO实战——用自己的数据集训练实例分割模型_from .cocodataset import cocodataset_CV-deeplearning的博客-CSDN博客
win10上用实例分割网络SOLO训练自己的数据集（mmdetection版本）_solo实力分割自己的数据集_不打代码也没有头发的博客-CSDN博客
SOLO分割模型环境搭建踩坑记录（ubuntu18.04）_solo模型_丹啊丹的博客-CSDN博客
二、数据集制作
1）运行labelme2coco.py文件，将所有的json文件读取到instances_train2014.json中。测试集同理。
2）数据集格式如下：annotations中是训练集和测试集的json文件，train2014中是jpg图片和json文件。
三、环境配置
部分包的版本：
torch 1.10.0+cu113 torchaudio 0.10.0+cu113 torchvision 0.11.1+cu113 mmcv 0.2.16 mmdet 1.0.0+unknown /root/anaconda3/envs/torch1.10/lib/python3.8/site-packages/mmdet-1.0.0+unknown-py3.8-linux-x86_64.egg model-index 0.1.11 networkx 3.1 numpy 1.23.0 步骤如下：
​ conda create -n solo python=3.7 -y conda activate solo conda install -c pytorch pytorch torchvision -y conda install cython -y git clone GitHub - WXinlong/SOLO: SOLO and SOLOv2 for instance segmentation, ECCV 2020 &amp; NeurIPS 2020.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbf65e6738bac21612709d22cc604116/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c6844e5e8dc15fd8a92190a60d9a7bb/" rel="bookmark">
			最好的ADB教程，从下载安装到使用【win&#43; linux】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Best Adb Tutorials 由于在工作中常用到的adb命令，在此总结，基本是很全乎了，以供后续查阅，欢迎补充！
一、什么是adb adb的全称为Android Debug Bridge,安卓调试桥。
是安卓设备和电脑之间的中间件,是官方提供的用于操作安卓设备的工具。 二、adb用来干什么? adb的使用场景不仅仅局限于安卓手机,安卓平板、部分游戏手柄、安卓vr等安卓设备均可使用。
在PC终端进入安卓设备shell,通过命令行操作安卓设备; pc和安卓安卓设备之间传输文件; 打开、关闭安卓设备或其应用; 模拟点击、输入、滑动等操作; 输出设备信息、性能指标信息 三、adb工作原理: adb采用客户端-服务器模式(C/S模式),分为: PC: 客户端:client 服务器:server MACHINE:(安卓设备) 守护进程:daemon 流程:服务器监听5037端口,接受客户端发来的指令发送给移动设备端adbd。
常用端口：5555端口和移动端建立连接,5554则是和控制台建连接。
四、ADB下载安装: 最新版本的ADB下载(包含多系统版本) ：入口 linux 下载 在线安装: sudo apt-get install android-tools-adb 离线安装：参考资料 windows配置ADB环境: 打开控制面板 &gt;系统和安全&gt;系统&gt;高级系统设置 在系统变量中新建ANDROID_HOME变量，赋值路径(platform-tools的上一级目录例如：C:\Users\SweetOrange\AppData\Local\Android\Sdk) 在系统变量path中添加%ANDROID_HOME%\platform-tools cmd进入终端 安装配置部分可以参考这篇博客：入口 五、连接移动设备以及查看设备连接状态 本文以安卓手机真机为例说明，下同。 adb真机调试使用前提: 真机插入USB数据线打开调试模式,PC端安装手机驱动,弹出是否允许调试点击是
adb调试手机需要打开手机开发者模式、USB调试 弹出的USB配置窗口建议选择文件传输 特殊命令还需要打开其他开关,例如无线调试的时候需要提前打开无线调试开关 检查 adb 是否安装成功: 执行 adb shell 是否进入安卓设备shell 正常情况下可以进入到安卓设备的内环境使用命令行进行操作 执行 adb --version 是否有adb 版本显示 以上有一个成功就说明安装成功 获取设备序列号：
adb shell getprop ro.serialno adb get-serialno adb devices 获取更加详细的设备信息,含序列号、型号等：adb devices -l 获取型号： adb -d shell getprop ro.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c6844e5e8dc15fd8a92190a60d9a7bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d3e40c50914e6c069cfa8fef402869d/" rel="bookmark">
			vue3中keep-alive的使用及结合transition使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正确用法 在组件中使用（这里结合了 transition 内置动画组件 ） &lt;template&gt; &lt;div class="layout clearfix"&gt; &lt;router-view v-slot="{ Component, route }"&gt; &lt;transition name="fade-transform" mode="out-in" v-if="!route.meta.keepAlive"&gt; &lt;component :is="Component" :key="route.name" /&gt; &lt;/transition&gt; &lt;transition name="fade-transform" mode="out-in" v-if="route.meta.keepAlive"&gt; &lt;keep-alive&gt; &lt;component :is="Component" :key="route.name"/&gt; &lt;/keep-alive&gt; &lt;/transition&gt; &lt;/router-view&gt; &lt;/div&gt; &lt;/template&gt; &lt;script setup&gt; import { onActivated, onDeactivated } from 'vue' // 在 keep-alive 组件激活时调用 onActivated(() =&gt; { console.log('onActivated') }) // 在 keep-alive 组件停用时调用 onDeactivated(() =&gt; { console.log('onDeactivated') }) &lt;/script&gt; 在router.js中配置 keepAlive 自定义属性 import { createRouter, createWebHistory } from 'vue-router' const routes = [ { path: '/', name: 'layout', component: () =&gt; import('.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d3e40c50914e6c069cfa8fef402869d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11784f79b9ef5ec613b895304708c12c/" rel="bookmark">
			HbuilderX报错提示：pages.json tabBar[‘list‘][1][‘pagePath‘] “pages/sort/sort“ 需在 pages 数组中的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 pages.json正确配置页面示例
"pages": [ //pages数组中第一项表示应用启动页 { "path": "pages/home/home", "style": { "navigationBarTitleText": "首页" } }, {//！！错误原因1：每新增一个.vue页面都要加这么一套 "path": "pages/sort/sort", "style": { "navigationBarTitleText": "分类" } } ], "tabBar": {//底部导航 "selectedColor": "#50b686", "list": [ { "pagePath": "pages/home/home", //！！错误原因2：路径最前面不用加/ "text": "首页", "iconPath": "static/tab_icons/main.png", "selectedIconPath": "static/tab_icons/main1.png" }, { "pagePath": "pages/sort/sort", "text": "分类", "iconPath": "static/tab_icons/sort.png", "selectedIconPath": "static/tab_icons/sort1.png" } ] }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bd1802c0b15ca1aac0cb27efd3638b5/" rel="bookmark">
			如何查看自己的公网ip
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 windos查看公网ip地址
1.直接访问：百度
2.就是win+r输入cmd然后输入:tracert www.baidu.com
3.其他查询地址：https://ip.cn/ 、https://ip138.com/ 、https://ifconfig.me/
linux查看自己的公网ip地址
命令行输入：
curl ifconfig.io curl ifconfig.me curl ipinfo.io/ip/ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2dd2024819bcc2d88b19b6a9c7b9d48/" rel="bookmark">
			gitignore文件使用方法（gitignore教程）（git status --ignored）（git check-ignore -v ＜file＞）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Gitignore文件使用描述Gitignore基本语法1. 基本语法★★★★★2. 配置方法 匹配示例示例1示例2示例3 其他命令`git status --ignored`（用于显示被Git忽略的文件和文件夹的状态）`git check-ignore -v &lt;file&gt;`（用于检查指定文件是否被Git忽略，并显示忽略规则的详细信息） 答疑关于“否定模式`!`中，被先前模式排除的任何匹配文件将重新包含。如果排除了文件的父目录，则无法重新包含该文件”如何取消已跟踪的文件？示例 在gitignore中增加忽略的项目后，如何删除云上仓库中相应的项目 参考文章 Gitignore文件 Gitignore是一个用于指定Git版本控制系统忽略特定文件或目录的规则文件。它的发展可以追溯到早期的版本控制系统，如CVS和SVN，这些系统使用类似的机制来忽略特定文件。
在Git中，Gitignore文件的原理是通过定义一系列规则来告诉Git哪些文件应该被忽略。这些规则可以是简单的通配符模式，也可以是正则表达式。当Git执行某个操作时，如添加文件到版本控制或提交更改，它会检查Gitignore文件中的规则，并根据规则来决定是否忽略某个文件。
Gitignore文件的作用是帮助开发者过滤掉不需要被版本控制的文件，以减少仓库的体积和提高操作效率。它可以用于忽略一些临时文件、编译生成的文件、日志文件、配置文件等。通过忽略这些文件，可以使版本控制系统更加干净和专注于源代码的管理。
使用描述 一个.gitignore文件指定了Git应该忽略的意图上未跟踪的文件。已经被Git跟踪的文件不受影响；有关详细信息，请参阅下面的注释。
gitignore文件中的每一行都指定了一个模式。在决定是否忽略一个路径时，Git通常会从多个来源检查gitignore模式，按照以下优先顺序（在一个优先级级别内，最后匹配的模式决定结果）：
对于支持它们的命令，从命令行读取的模式。
从与路径相同目录中的.gitignore文件，或者从任何父目录（直到工作树的顶级）中读取的模式，其中较高级别文件中的模式会被较低级别文件中的模式覆盖，直到包含该文件的目录。这些模式相对于.gitignore文件的位置进行匹配。一个项目通常会在其存储库中包含这样的.gitignore文件，其中包含作为项目构建的一部分生成的文件的模式。
从$GIT_DIR/info/exclude中读取的模式。
从由配置变量core.excludesFile指定的文件中读取的模式。
将模式放在哪个文件中取决于模式的使用方式。
应该进行版本控制并通过克隆分发到其他存储库（即，所有开发人员都希望忽略的文件）的模式应该放在.gitignore文件中。
特定于特定存储库但不需要与其他相关存储库共享的模式（例如，存储库内部但特定于一个用户工作流程的辅助文件）应该放在$GIT_DIR/info/exclude文件中。
用户希望Git在所有情况下都忽略的模式（例如，用户选择的编辑器生成的备份或临时文件）通常放在由core.excludesFile在用户的~/.gitconfig中指定的文件中。它的默认值是$XDG_CONFIG_HOME/git/ignore。如果$XDG_CONFIG_HOME未设置或为空，则使用$HOME/.config/git/ignore。
底层的Git工具，如git ls-files和git read-tree，从命令行选项指定的gitignore模式或从命令行选项指定的文件中读取。更高级别的Git工具，如git status和git add，使用上述来源中的模式。
Gitignore基本语法 Gitignore文件的基本使用方法是通过定义规则来告诉Git哪些文件应该被忽略。下面是Gitignore文件的基本语法和配置方法：
1. 基本语法★★★★★ 空行不匹配任何文件，因此可以用作可读性的分隔符。以“#”开头的行作为注释。对于以“#”开头的模式，可以在第一个“#”前面加上反斜杠（“\”）。尾随空格会被忽略，除非用反斜杠（“\”）引用。可选的前缀“!”可以否定模式；被先前模式排除的任何匹配文件将重新包含。如果排除了文件的父目录，则无法重新包含该文件。出于性能原因，Git不会列出被排除的目录，因此对包含的文件的任何模式都没有影响，无论它们在何处定义。对于以字面“!”开头的模式，例如“\!important!.txt”，可以在第一个“!”前面加上反斜杠（“\”）。斜杠“/”用作目录分隔符。分隔符可以出现在.gitignore搜索模式的开头、中间或结尾。
如果模式的开头或中间（或两者都有）有分隔符/，则该模式相对于特定.gitignore文件所在的目录级别。否则，该模式也可以在.gitignore级别以下的任何级别匹配。（比如a/b中间有斜杠，需要a与.gitignore同级才会被匹配，c/a/b不会匹配；/a同样）
如果模式的结尾有分隔符/，则该模式只匹配目录，否则该模式可以匹配文件和目录。
例如，模式doc/frotz/匹配doc/frotz目录，但不匹配a/doc/frotz目录；但是frotz/匹配frotz和a/frotz这两个目录（所有路径都是相对于.gitignore文件的）。星号“*”匹配除斜杠以外的任何字符（可匹配多个字符组成的字符串，但字符串中不能包含斜杠/）。问号“?”匹配除斜杠以外的任何一个字符（只能匹配一个字符）。范围表示法，例如[a-zA-Z]，可用于匹配范围内的一个字符。有关更详细的说明，请参阅fnmatch(3)和FNM_PATHNAME标志。在与完整路径名匹配的模式中，两个连续的星号（“**”）可能具有特殊含义： 以“**”开头的斜杠表示在所有目录中匹配。例如，“**/foo”匹配任何位置的文件或目录“foo”，与模式“foo”相同。“**/foo/bar”匹配直接位于目录“foo”下的文件或目录“bar”。以“/**”结尾的斜杠表示匹配其中的所有内容。例如，“abc/**”匹配相对于.gitignore文件位置的目录“abc”中的所有文件，具有无限深度。斜杠后面跟着两个连续的星号然后是斜杠，表示匹配零个或多个目录。例如，“a/**/b”匹配“a/b”、“a/x/b”、“a/x/y/b”等。 其他连续的星号被视为普通的星号，并根据前面的规则进行匹配。 2. 配置方法 在项目根目录下创建一个名为.gitignore的文件。在.gitignore文件中添加需要忽略的文件或目录的规则。每行一个规则，可以使用上述基本语法来定义规则。保存.gitignore文件。 对于有多个目录的情况，想要忽略某种类型文件的目录和不想忽略的目录，可以在.gitignore文件中分别定义规则。例如，假设有两个目录dir1和dir2，想要忽略dir1目录下的.txt文件，但不想忽略dir2目录下的.txt文件，可以按照以下步骤进行配置：
在.gitignore文件中添加以下规则：
# 忽略dir1目录下的.txt文件 /dir1/*.txt 在dir2目录下创建一个名为.gitignore的文件。
在dir2/.gitignore文件中添加以下规则：
# 不忽略dir2目录下的.txt文件 !*.txt 这样配置后，Git会忽略dir1目录下的.txt文件，但不会忽略dir2目录下的.txt文件。注意，.gitignore文件的规则是逐级生效的，所以在dir2/.gitignore文件中使用!*.txt来取反，表示不忽略dir2目录下的.txt文件。
匹配示例 示例1 模式 hello.* 匹配以 hello. 开头的任何文件或目录。如果只想限制在目录中而不包括其子目录，可以在模式前加上斜杠，即 /hello.*；现在模式匹配 hello.txt、hello.c，但不匹配 a/hello.java。
模式 foo/ 匹配目录 foo 及其下面的路径，但不匹配普通文件或符号链接 foo（这与 Git 中 pathspec 的工作方式一致）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2dd2024819bcc2d88b19b6a9c7b9d48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c39e714304e630df5c952ae0acb85dc/" rel="bookmark">
			Ubuntu系统基本操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章中所需要的文件可以在这里下载
链接：https://pan.baidu.com/s/1NYXxHD0jebngmCTEwgjGbQ 提取码：2jyo
目录
1.安装谷歌浏览器
2.修改开机启动项
3. 快捷键查找与设置
4. Ubuntu换源
5. 环境变量
5.1 添加
5.2 查询
6.查看so文件
7.将应用固定到左侧快捷栏
8.Ubuntu挂载机械硬盘
9.自定义命令
1.安装谷歌浏览器 首先要下载好谷歌浏览器deb的包 进入包目录后，输入命令sudo dpkg –i google-chrmoe-stable_current_amd64.deb
若出现dpkg: error: dpkg status database is locked by another process
输入
（1）sudo rm /var/lib/dpkg/lock
（2）sudo dpkg --configure -a
安装其他deb包也可以用同样的方法，也可以不用命令进行安装，直接双击deb包，然后点击install就可以进行安装
2.修改开机启动项 当我们在一个机器中安装多个系统后，开机后会弹出多个系统供我们选择，我们可以对这些系统的名称进行修改
进入第一个系统后依次输入三个命令
sudo add-apt-repository ppa:danielrichter2007/grub-customizer
这个命令最后要显示OK
sudo apt-get update
sudo apt-get install grub-customizer
之后在系统中搜索grub，点击那个图像化的软件，在里面修改即可
3. 快捷键查找与设置 进入System Settings
点击Keyboard 点击Shortcuts，可以在其中查看与设置快捷键
其中Screenshots就是截图的快捷键 4. Ubuntu换源 换源之前可以先做一个备份文件，输入 sudo cp/etc/apt/sources.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c39e714304e630df5c952ae0acb85dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/970c3820f5e3ab427d59460029ad5ebb/" rel="bookmark">
			elasticsearch批量删除(查询删除)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注:delete by query只适用于低于elasticsearch2.0的版本(不包含2.0)。有两种形式:
1.无请求体
curl -XDELETE 'localhost:9200/twitter/tweet/_query?q=user:kimchy'
2.有请求体
使用请求体的时候，请求体中只能使用query查询，不能使用filter
curl -XDELETE 'localhost:9200/twitter/tweet/_query' -d '{
"query":{
"term":{"user":"kimchy"}
}
}'
删除全部:
"query":{
"match_all":{}
}
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec2ac4904834c6f64ca0e3d6eb25b32b/" rel="bookmark">
			anaconda navigator一直卡在adding featured channels界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		anaconda navigator一直卡在adding featured channels界面，试了无数个方法，网上各种方法都没法解决，比如断网挂梯子之类的。
问题细节：
在Anaconda Prompt输入调试代码：
anaconda-navigator --debug 发现报错出现在
anaconda_api.py”, line 298, in _load_repo_data
packages, applications = output
TypeError: ‘NoneType’ object is not iterable
解决方法：
删除C:\Users\你的用户名\.condarc文件重新启动，问题解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1ed8aaee0f9c66893bfdd86eb596a9b/" rel="bookmark">
			三维地图 Cesium &#43; vue api记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 通过经纬度获取高程
let posArr = [{ lon:'', lat:'' } ] let lonlat = [] posArr.forEach(item =&gt; { lonlat.push(new Cesium.Cartographic(Cesium.Math.toRadians(item.lon), Cesium.Math.toRadians(item.lat))) }) let finalArr = [] //模型上取点 const promise = viewer.scene.sampleHeightMostDetailed(lonlat); promise.then((data) =&gt; { //data里是相关坐标信息,如：{lon:'',lat:'',height:''} } 2、地图点击事件
mounted(){ //注册点击事件 this.handlePinClick() } beforeDestroy(){ // 去除鼠标点击监听事件 this.handleClick3D &amp;&amp; this.handleClick3D.destroy(); this.handleClick3D = null; } // 地图点击事件 handlePinClick() { this.handleClick3D = new Cesium.ScreenSpaceEventHandler(this.Global.viewer.scene.canvas); this.handleClick3D.setInputAction((movement) =&gt; { //pick 为添加到地图中的图标(entities)对象 const pick = this.Global.viewer.scene.pick(movement.position); if (!pick) { return; } // 打开弹窗 this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1ed8aaee0f9c66893bfdd86eb596a9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/add275cbff66784b3c8ea0284a96e77f/" rel="bookmark">
			Angular 使用Angular CLI搭建项目并提交项目代码至远程仓库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、学前必备知识点
1.TypeScript
2.Angular
3.Angular CLI
二、必备软件
1.Node
三、镜像源
1.临时切换使用
2.持久使用（推荐）
3.验证是否配置成功
四、Angular相关开发环境 1.全局安装Angular CLI脚手架工具
2.Angular项目创建
3.本地运行项目
五、创建并提交到远程仓库
总结
前言 最近在学习搭建Angular项目，在这里记录搭建项目的过程以及一些相关操作。
参考文章：Angular入门，开发环境搭建，使用Angular CLI创建你的第一个Angular项目
一、学前必备知识点 1.TypeScript TypeScript学习文档 TypeScript中文网-TypeScript--JavaScript的超集
2.Angular Angular学习文档 Angular文档简介
3.Angular CLI Angular CLI命令参考手册 Angular CLI概览与命令参考手册
二、必备软件 1.Node Node.js(携带NPM包管理工具)，在构建Angular项目之前，需先安装Node.js
下载安装包地址：https://nodejs.org/en
安装及环境配置教程：nodejs安装及环境配置
安装完成后查看node版本
node --version node -v 获取到版本号即代表安装成功
安装成功后需要配置环境变量，根据上面的链接教程配置环境变量
如果本地有多个项目，并且每个项目的node版本都不一致，可以使用nvm来管理node版本。
windows版本下载及安装教程：nvm-windows下载与安装_小 源的博客-CSDN博客
三、镜像源 Node.js安装好之后，NPM就可以使用了（NPM是随同NodeJS一起安装的包管理工具）。NPM的默认安装源在国外，一般会比较慢或因为网络原因安装失败，因此需要把NPM的安装源设置到国内镜像源，可以使用淘宝镜像（npm.taobao.org/）。
1.临时切换使用 npm --registry https://registry.npm.taobao.org install express 2.持久使用（推荐） npm config set registry https://registry.npm.taobao.org # 恢复到默认状态 npm config delete registry 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/add275cbff66784b3c8ea0284a96e77f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b64ca7341d8295046d2d2e56364f1b1/" rel="bookmark">
			Python（Web时代）—— Django数据库整合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 ORM框架介绍 ORM（Object Relation Mapping）框架，可以帮助我们把类和数据表进行一个映射，让我们可以通过类和类对象来直接操作数据库中的数据。
优势：根据对接的数据库引擎翻译成对应的sql语句，所以我们不用关注使用的是MySQL还是Oracle等，我们只需要修改数据库配置即可
django中内嵌了ORM框架，不需要直接面向数据库编程，而是定义模型类，通过模型类和对象完成数据表的增删改查操作。
模型 Django 中模型是真实数据的描述，它包含了储存的数据所必要的字段和行为，在创建模型前需要先配置好数据库。每一个模型类即对应一个数据表
数据库配置 Python 内置 SQLite，如果使用SQLite则无需安装额外东西。 以下以TestDjango项目为例 ，我们使用 mysql 数据库 一、数据库连接配置 在 TestDjango 项目目录下，打开 TestDjango/settings.py 配置文件，修改DATABASES 中的数据库信息（默认是sqlite）
# TestDjango/settings.py DATABASES = { 'default': { # 指定当前使用的数据库引擎 # django.db.backends.mysql、oracle、sqlite3 'ENGINE': 'django.db.backends.mysql', 'NAME': 'test', # 数据库 'USER': 'root', # 用户名 'PASSWORD': '123456', # 密码 'PORT': 3306, # 数据库的端口号 'HOST': 'localhost' # 主机ip } } 然后在settings.py所在目录下的__init__py文件中设置Django默认连接MySQL的方式
# TestDjango/__init__py import pymysql pymysql.install_as_MySQLdb() 二、创建模型 为了避免不同数据库sql不一样的情况，django统一采用 模型类，模型类 定义在 应用的models.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b64ca7341d8295046d2d2e56364f1b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/048ba86f40e9af51080555c68003a100/" rel="bookmark">
			【Python学习-基础篇】【时间操作】获取并输出当前日期时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 获取并输出当前日期时间
在Python 中，可以使用 datetime 模块来处理日期和时间。
datetime 模块非常好用，提供了很多日期格式、时间格式处理、转换的对象和方法。
使用时，首先要导入 datetime 库，代码如下:
使用 today 和now 获得当前日期和时间，时间精确到毫秒级，代码如下:
import datetime print(datetime.datetime.today()) # 2023-08-29 10:55:24.833695 print(datetime.datetime.now()) # 2023-08-29 10:55:24.833694 # 使用format0函数格式化时间，“%Y-%m-%d” 年的格式，“%H:%M:%S,时间格式 print(format(datetime.datetime.now(), "%Y-%m-%d %H:%M:%S")) # 2023-08-29 10:56:26 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e616422b390959f7502c23d0f6724aeb/" rel="bookmark">
			如何设置让软件开机自启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 电脑重置，一些软件能正常使用，但是系统开机自启动选项中并没有它，这就很郁闷
有些极简软件没有直接设置开机自启，需要手动设置，所以我们就需要手动去设置一下它。
1、如果你在任务管理器里能找到它，也可以设置 先到任务管理器看下，点击启动项
把你需要开机启动的程序选中点击启动，把不需要的程序选中，点击禁用，这样开机它就不会启动运行了
2、如果在这里没找到要开机运行的程序，我们就需要去设置一下 按win+r 打开运行框，输入 shell:startup 回车，
调出启动文件，把你在桌面上要开机运行的程序的快捷方式复制到启动文件里就可以了。
搞定
标题如何启动 Windows 11任务管理器 搜索任务管理打开地址栏右键选择任务管理器同时按住 Ctrl、Alt 和 Delete 键同时按住 Ctrl、Shift 和 Esc 键按win+x键 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b753ae7e503af5f04c09e4f26a1a6a4/" rel="bookmark">
			2.GaussDB分布式数据库部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装包准备
Kylin-Server-10-SP2-x86-Release-Build09-20210524.iso 操作系统采用麒麟V10 GaussDBInstaller_1.0.5.6_20230630015648.tar.gz 数据库安装工具包。
GaussDB_X86_Kylinv10_Distributed_2.23.01.230_20230705094619.tar.gz 基于麒麟V10的分布式数据库安装包。
需要注意:华为GaussDB的安装包，不支个人下载，只有购买服务或者作为合作方才可以下载使用。集中式部署有集中式部署的包，分布式有分布式部署的包。这里我们使用分布式。
2.创建数据库管理用户
useradd omm passwd omm groupadd dbgrp echo Gauss_2xx|passwd omm --stdin 3.检查磁盘容量
[root@gaussdb01 GaussDB]# df -h
文件系统 容量 已用 可用 已用% 挂载点
devtmpfs 7.2G 0 7.2G 0% /dev
tmpfs 7.2G 12K 7.2G 1% /dev/shm
tmpfs 7.2G 9.6M 7.2G 1% /run
tmpfs 7.2G 0 7.2G 0% /sys/fs/cgroup
/dev/mapper/klas-root 52G 11G 42G 21% /
tmpfs 7.2G 4.0K 7.2G 1% /tmp
/dev/sda1 1014M 214M 801M 22% /boot
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b753ae7e503af5f04c09e4f26a1a6a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f9e8f5fd1c488dbae2e51b5dd585781/" rel="bookmark">
			ENSP常用命令_HCIA/HCIP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ENSP常用命令_HCIA/HCIP 基本操作命令进入系统视图模式&lt;&gt;system-view(sys)退出当前模式quit（qu）设备名称更改sysname x查看当前正在执行的所有配置display current-configuration(cu)查看接口ip地址display ip int brief查看接口的简要信息display interface brief( int b)查看MAC表display mac-address查看路由表display ip routing-table查看ospf邻居关系display ospf peer查看链路聚合状态display int Eth-Trunk进入回环接口int loopback1（loo1）查看当前模式下的配置display this查看ospf邻居表display ospf peer brief保存&lt;&gt;save查看硬盘&lt;&gt;dir查看系统和内存以及硬盘dis version查看内存dis memory-usage查看CPUdisplay cpu-usage回退用户模式ctrl+z日志提示语言为中文language-mode chinese回车符&lt; CR&gt;TAB键支持补全显示当前条件下配置dis this查看邻居表dis ospf peer brief重置ospf 进程&lt; &gt;reset ospf process以1.1.1.1 为源地址ping 2.2.2.2ping -a 1.1.1.1 2.2.2.2追踪tracert -a 1.1.1.1 2.2.2.2指定次数，源地址，目标地址ping -c 1000 -a 1.1.1.1 2.2.2.2 ping查看静态相同目的不通路径优先级dis ip routing-table protocol static查看bfd简易内容dis bfd session all查看bfd全部内容dis bfd session all verbose undo命令恢复缺省状态undo sysname禁用某个功能undo ftp server删除某项设置undo ip address关闭系统提示undo info-center enable (un in en) 配置系统下次启动文件命令保存x文件save x下次启动x文件startup saved-configuration x 添加路由条目命令静态ip route-static 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f9e8f5fd1c488dbae2e51b5dd585781/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88f38664335f035b61ca345a94a64514/" rel="bookmark">
			双指针（详细解释）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是双指针算法？
严格的来说，双指针只能说是是算法中的一种技巧。
双指针指的是在遍历对象的过程中，不是普通的使用单个指针进行访问，而是使用两个相同方向（快慢指针）或者相反方向（对撞指针）的指针进行扫描，从而达到相应的目的。
二、双指针算法的适用范围
常用在数组遍历中，我们使用两个指针进行操作，遍历完整个数组来实现我们的目的。一般能用双指针算法解决的问题，都可以用暴力解法解决，常用于单调场景。所以双指针问题基本有以下几个细节：
1、注意双指针的初始位置。
2、注意双指针的移动方法。
3、注意遍历的结束条件。
双指针题型大致分为以下几种：
快慢指针对撞指针两数组指针滑动窗口 一般双指针类型的题目主要存在于数组，字符串，链表居多。接下来我将每种类型分别进行归纳总结并拿出相关例题进行分析，但不可能每种类型记住了模板就一定会做了，因此我个人还是建议记住做题解法顺序。具体题目具体分析比较好。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1900b5bf732271a715b87b93a76dfb9b/" rel="bookmark">
			solidworks设计软件2020-2023简体中文官版软件三维设计软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 软件简介： SolidWorks是一款功能强大的三维计算机辅助设计(CAD)软件，被广泛应用于机械工程、制造和设计领域。该软件提供了许多独特的功能，使得设计师能够更快速、高效地创建和修改各种复杂的产品。
首先，SolidWorks具有智能造型功能，它通过智能引导工具和自动特征识别等功能，使得模型的创建过程更加快捷和直观。此外，该软件还提供了灵活的组件建模工具，使得设计师可以按照产品的组装方式进行快速设计和评估。
另外，SolidWorks还具备全局和局部的性能分析功能。通过该软件，设计师可以模拟和分析产品的材料、强度、热传导等性能特征，从而在产品设计的早期阶段就能够发现和解决潜在的问题。
此外，SolidWorks还支持多种导入和导出文件格式，以便于与其他CAD和CAE软件进行兼容和交互。例如，设计师可以方便地导入其他软件创建的模型，并在SolidWorks中进行进一步编辑和修改。
最后，SolidWorks还提供了一套全面的绘图和渲染工具，可以帮助设计师创建精美的二维和三维制图，以便于产品展示和沟通。设计师可以通过该软件生成高质量的渲染图像，使得设计的呈现更加生动和真实。
总而言之，SolidWorks具有多种强大的功能，能够满足设计师在产品开发过程中的各种需求，提高工作效率并实现更高水平的设计创新。SolidWorks是一款广泛应用于机械设计领域的三维建模软件。它以其强大的功能和易于使用的界面而闻名，为工程师们提供了优秀的设计工具。在实际的工程设计过程中，我们可以运用SolidWorks的多种特色功能和技巧，以提高工作效率和设计质量。本文将通过几个实际案例，用举例讲解的方式来介绍SolidWorks的特色功能使用技巧。
一、零件设计中的局部切除
在进行零件设计时，有时我们需要在一个较大的零件中切除一个局部区域，例如加工或装配的需要。在SolidWorks中，我们可以使用“切除”命令来实现这一功能。
以设计一个带有凹槽的轴为例，我们可以首先绘制整个轴的轮廓，然后使用“切除”命令选择凹槽的轮廓来进行切除操作。通过调整切削的深度和方向，我们可以灵活地控制凹槽的形状和大小。这样，我们就可以在设计过程中方便地添加和调整各种复杂的凹槽形状，提高了设计的灵活性和效率。
二、装配设计中的零部件定位
在进行装配设计时，零部件的准确定位是非常重要的。SolidWorks提供了多种功能和技巧来实现零部件的准确定位，例如使用子装配和约束等。
以设计一个简单的门锁为例，我们可以先设计门锁的主体零件，然后将门把手、插销等零部件组装到主体上。在进行装配时，我们可以使用“子装配”命令将门把手和插销这些相关的零部件组合成一个子装配体，然后将子装配体与主体进行整体装配。在装配过程中，我们可以使用约束功能来确保各个零部件的位置和运动的正确性，例如使用垂直约束来使门把手和插销与主体相对垂直。通过合理使用这些功能和技巧，我们可以提高装配的准确性和效率。
三、绘图中的注释和标注
在进行工程设计时，绘图是不可或缺的一项工作。在SolidWorks中，我们可以使用注释和标注功能来准确地表达设计意图和传递信息。
以设计一个机械零件图为例，我们可以使用注释功能在图纸中添加文字说明和图形标识。例如，我们可以使用文本工具在图纸上添加尺寸标注、文字说明等。此外，SolidWorks还提供了丰富的标注工具，如直径标注、角度标注等，以满足不同设计需求。通过合理地使用注释和标注功能，我们可以清晰地表达设计意图，使得图纸更加易读和易理解。
综上所述，SolidWorks作为一款功能强大且易于使用的三维建模软件，为工程设计师们带来了许多便利和高效的功能和技巧。在实际的工程设计过程中，我们可以灵活运用SolidWorks的特色功能和技巧来提高工作效率和设计质量。通过上述几个实际案例，我们不仅了解了SolidWorks的特色功能的使用方法，还深入体会到了这些功能在实际设计中的应用价值。相信在今后的工程设计过程中，我们将能更好地利用SolidWorks的特色功能和技巧，提高工作效率和设计质量，为工程行业的发展贡献力量。
运行截图： 下载地址 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b44ae4146b5d37ba99a4bca23de7500/" rel="bookmark">
			微信小程序 通过setData 给两个变量设置同一个数组时，为什么修改一个变量，另一个会也被修改？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在微信小程序中，使用 setData 方法更新数据时，如果给两个变量设置同一个数组，修改其中一个变量的值会导致另一个变量也被修改的原因是，数组是引用类型的数据，在内存中的存储方式是按引用地址存储。
当你将一个数组赋值给两个变量时，实际上两个变量共享同一块内存空间，即它们引用相同的地址。因此，无论你修改其中一个变量的值，另一个变量也会受到影响。
示例如下：
// 在 Page 实例的 data 中定义两个变量 data: { array1: [1, 2, 3], array2: [] }, // 将 array1 赋值给 array2 onLoad: function() { this.setData({ array2: this.data.array1 }); }, // 修改 array1 的值 modifyArray: function() { this.data.array1.push(4); this.setData({ array1: this.data.array1 }); console.log(this.data.array2); // 输出 [1, 2, 3, 4]，array2 也被修改了 } 通过以上示例，当我们调用 modifyArray 函数更新 array1 变量的值时，array2 的值也会受到影响，因为它们引用同一块内存地址上的数组。
如果想要避免这种情况，可以使用 array.slice() 方法复制一份原数组并赋给另一个变量，这样就不会导致修改一个变量时影响到其他变量的问题。
// 使用 array.slice() 方法复制数组 onLoad: function() { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b44ae4146b5d37ba99a4bca23de7500/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfd711a60be8a4c5c6d0bdd7965948eb/" rel="bookmark">
			题解 | #识别有效的IP地址和掩码并进行分类统计#
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔试题-2023-瑞芯微-数字IC设计【附答案及解析】
数字IC/模拟IC如何快速入门？（干货建议收藏）
小米-前端工程师-面试-凉经
小米南京前端一面凉经
秋招记录
小米前端实习一面(凉经)base北京
得物Java一面
小米前端实习一面
得物goLong一面（离大谱）
小米 前端开发一面 2023.7.24
mentor说我把公司当免费自习室
B站还没笔就未通过了？
【网易】2022版最强面经汇总！
第四范式算法
大佬们，帮忙看看简历
24届学生速投！外企秋招来袭~弹性上下班，超长带薪年假！
快手C++凉面
秋招记录：大疆一面 8.28
实习荔枝，再见了快手，再见了北京
OPPO查看进度情况-最新
双非本第一个offer终于来了呜呜呜
计算机视觉算法实习生面经
C++ const关键字（详解）
应届生入职百度 3 个月被裁
字节跳动后端开发工程师-Data提前批一二面
uu我22号测评一点信都没有
新思科技面试经验
是我幼稚了
快手直播 JAVA 一、二面
京东二面
美团hr面后挂
傻B 美团
国企篇小谈
华为OD是什么？华为OD值得去吗？
秋招总结 | 互联网=&gt;外企=&gt;各种国企全掺和选手
前端八股看哪些资料好一点？
地平线二面 应用软件工程师
美团一面
美团已挂
秋招怎么变成夏招了？？
字节凉经
腾讯wxg后台开发二面
腾讯光子后台开发一面
2022秋招美团面经
秋招投递记录
必背八股文-C/C++(1)
百度产品经理实习导师很nice，团队氛围好
在百度产品经理实习两个多月了，下面分享一下这段时间的体验。上班时间：工作时间早10:30至晚上8:00，时间比较自由。工作内容：我的工作内容是负责产品的功能迭代
23届毕业已交社保有哪些可以投的公司
四川人广飘23届信息安全双非硕目前做等保测评工作干了两个月感觉自己一点也不喜欢这个工作，但是感觉没有退路，已经交了社保，没了应届生身份。想回四川考公或者换个单位
腾讯运营开发一面凉经
鹅鹅鹅鹅鹅鹅爹，没有你我怎么活啊[牛泪][牛泪][牛泪][牛泪]。我真是太菜了，被鹅吊打五十多分钟[牛泪][牛泪][牛泪][牛泪]。前景提要莫名其妙被中台部门软
美团笔试
开水团，软开到店，9本华五硕，笔试100+100+100+95+20，流程结束。
题解 | #识别有效的IP地址和掩码并进行分类统计#
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfd711a60be8a4c5c6d0bdd7965948eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/984d5653bb05b473b3bf0538bf27b77a/" rel="bookmark">
			VScode的动态窗口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VScode的动态窗口（一个窗口切换不同文件） 在vscode中打开文件默认是打开一个静态的窗口。
那么什么时候会打开动态窗口呢？
观察下图，demo.txt是我们直接通过vscode打开的，而demo1.txt则是在vscode中打开的
demo.txt就是静态的（字体为正常字体），而demo1.txt则是动态窗口（斜体）。
区别是什么呢？
我们这时候在vscode左侧的目录中单击（双击默认打开静态窗口）一个新的文件，我们看一下效果：
可以看见，demo1.txt的窗口直接被替换掉了。这就是VScode 的动态窗口。
你说，这也妹啥用啊。
nonono~当我们只是想查看一下文件的内容而不需要长时间停留在这些文件上的时候，比如查看配置文件等，这就不需要我们重复的关闭窗口了，生产效率（大概）大大提升。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1d89313dbf08e6193887b08c2618891/" rel="bookmark">
			创业笔记16
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从来没有对抗压力的方法，对抗压力就要去定位问题，解决问题。
任何用 游戏 娱乐 倾诉来缓解压力，实际也是在逃避问题。
王圣豪
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8125234cee9a67b1ca67d19188240551/" rel="bookmark">
			Linux 下使用 linuxdeployqt 打包QT程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux 下使用 linuxdeployqt 打包QT程序 一. 安装 linuxdeployqt二. 打包成 .AppImage 应用程序 当别人需要使用我们的 Qt 程序时，我们可以用打包工具将程序打包发给他，这样就不用发送整个 Qt 工程。由于Qt 跨平台的特性，可以用不同的工具打包它。本篇文章是在 Linux 下使用 linuxdeployqt 将 Qt 程序打包成 .AppImage 应用程序。
环境介绍：
Ubuntu 16.04QT 5.12.12linuxdeployqt（built on 2023-04-23） 注： 当我们把打包好的应用程序发给别人使用，可能会遇到 GLIBC库 版本过高的错误，也有很多办法，不过个人觉得使用低版本的 Linux 系统作为编译机这个方法简单点，而且兼容性好一点，所以我才使用 Ubuntu 16.04 这个版本作为编译机。
一. 安装 linuxdeployqt 直接从 Releases · probonopd/linuxdeployqt (github.com) 中下载编译好的 linuxdeployqt-continuous-x86_64.AppImage 应用程序文件。（从最新的版本开始下载，如果用不了可以降版本）
下载好之后，执行下面命令（这里默认 Ubuntu 上已经配置了 Qt 环境）
chmod +x linuxdeployqt-continuous-x86_64.AppImage # 赋予可执行权限 mv linuxdeployqt-continuous-x86_64.AppImage linuxdeployqt # 改名以便后面操作 ./linuxdelpoyqt -version # 查看是否安装成功，若输出版本信息表示安装成功。 （参数说明 机翻） Usage: linuxdeployqt &lt;app-binary|desktop file&gt; [options] Options: -always-overwrite ：即使目标文件存在，也复制文件。 -appimage ：创建 AppImage （意味着 -bundle-non-qt-libs）。 -bundle-non-qt-libs ：还捆绑非核心、非 Qt 库。 -exclude-libs=&lt;list&gt; ：应排除的库列表，用逗号分隔。 -ignore-glob=&lt;glob&gt; ：相对于 appdir 的 Glob 模式在何时忽略寻找库。 -executable=&lt;path&gt; ：让给定的可执行文件使用已部署的库也 -extra-plugins=&lt;list&gt; ：应该部署的额外插件列表，用逗号分隔。 -no-copy-copyright-files ：跳过版权文件的部署。 -no-plugins ：跳过插件部署。 -no-strip ：不要在二进制文件上运行“strip”。 -no-translations ：跳过翻译部署。 -qmake=&lt;path&gt; ：要使用的 qmake 可执行文件。 -qmldir=&lt;path&gt; ：扫描给定路径中的 QML 导入。 -qmlimport=&lt;path&gt; ：将给定路径添加到 QML 模块搜索位置。 -show-exclude-libs ：打印排除库列表。 -verbose=&lt;0-3&gt; ：0 = 无输出，1 = 错误/警告（默认），2 = 正常，3 = 调试。 -updateinformation=&lt;更新字符串&gt;：嵌入更新信息STRING； 如果安装了zsyncmake，则生成zsync文件 -qtlibinfix=&lt;infix&gt; ：如果您的 Qt 发行版有中缀，请调整 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8125234cee9a67b1ca67d19188240551/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eec32bf97843d5b561279861d5945660/" rel="bookmark">
			FPGA图像算法.任意比缩放
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天狼哥又来更新了，上段时间写了一篇文章介绍缩放的原理《FPGA图像处理算法—基于双线性插值的图像缩放原理》，今天介绍下基于这个原理实现的无极缩放。
无极缩放是个很有意思也很有用的一个功能，在pc上实现缩放效率比较低，基于FPGA的缩放可以实时实现视频的缩放，本篇主要介绍程序的实现，对原理不做讲解，对原理不熟悉的可以看上次的原理讲解。
整个缩放的实现架构如下，主要分成两个模块，一个负责数据的读写控制，一个负责双线性插值，由于双线性插值需要两行数据才能进行差值，所以数据控制模块需要有bram缓存数据，再一个就是插值需要四个数据，所以需要四个bram来存储数据，这样才能在一个时钟周期读取四个数据，然后在有两行数据后启动插值，使用插值模块计算出来的反映射地址来控制数据读取地址，将读取出来的数据给后面的插值模块使用，所有的模块使用纯流水的模式进行，数据流进去数据流出来。
整个实现的参数设置和占用的资源如下所示，输入分辨率支持到1080p(修改参数可以支持到更高分辨率)，数据位宽8bit，小数位12位，整数位8位，其他参数位宽为16bit，消耗的资源还不错。
最后放一些不同尺寸的缩放效果图：
图一最左边为原图尺寸276*276，放大到554*554，中间是FPGA放大的图，最右边是matlab出来的图。
图二左边为原图尺寸276*276，放大到1080p
图三左边为原图尺寸276*276，缩小到128*128
图四左边为原图尺寸276*276，缩小到64*64
图五左边为原图尺寸1024*1024，放大到1080p
************往期精彩文章列表************
基于Zynq的图像处理入门课程
FPGA图像算法.导向滤波
点击上面链接查看详情
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9db43e231781407fe026ccc30c1ad8c2/" rel="bookmark">
			如何实现C&#43;&#43;动态调用动态链接库（DLL或SO）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++动态调用动态链接库（DLL或SO）主要步骤： 动态库调用流程大致可以描述为：0.创建动态库 -&gt; 1.加载动态库 -&gt; 2.定义函数类型 -&gt; 3.获取函数地址 -&gt; 4.调用函数 -&gt; 5.卸载动态库。
这个流程和逻辑可以在不同的操作系统和编译器下略有差异，因此需要根据特定的平台和工具链做适当的调整。
0.创建动态库： 创建一个接口，并生成可供其他程序使用的DLL和SO（动态链接库）,步骤如下：
要创建一个接口，并生成可供其他程序使用的DLL和SO（动态链接库），可以按照以下步骤进行：
创建接口头文件（例如 helloFunc.h）：在头文件中定义接口的函数和数据结构。将接口的所有公共部分放在这个头文件中，并确保使用适当的导出声明。 // helloFunc.h #ifdef _MSC_VER // Windows环境下的导出声明 #ifdef helloFunc_EXPORTS #define HELLOFUNC_API __declspec(dllexport) #else #define HELLOFUNC_API __declspec(dllimport) #endif #else // Linux/Unix下的导出声明 #ifdef HELLOFUNC_EXPORTS #define HELLOFUNC_API __attribute__((visibility("default"))) #else #define HELLOFUNC_API #endif #endif // 接口函数 #ifdef __cplusplus extern "C" { #endif HELLOFUNC_API void hello(); #ifdef __cplusplus } #endif 实现接口函数的源文件（例如 helloFunc.cpp）：在源文件中实现接口函数。确保使用正确的导出声明，并根据需要处理接口的具体逻辑。 // helloFunc.cpp #include "helloFunc.h" void hello() { // 实现函数逻辑 // .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9db43e231781407fe026ccc30c1ad8c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0ae990f966f0ba1ec88930b388042b3/" rel="bookmark">
			RT-2(robotics-transformer2)论文翻译——2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明： ChatGPT等基于Transformer的大语言模型(LLM)的成功带给了人们巨大的震撼，其表现的few-shot甚至zero-shot能力仿佛让人们看到了通用人工智能(AGI)的曙光。而CLIP等跨模态模型打通了NLP和CV的界限，这些VLM模型将AGI发展继续向前推进。
AGI在机器人领域同样有很大的提升空间。试想如果机器人拥有了LLM般的思考能力，那世界将变得多么智能！届时的机器人不是只能机械执行预先设定好的程序，而是能够真的读懂人类，和人类自然交互。
RT2是谷歌deepmind团队今年7月底结合VLM和机器人控制技术研发的横跨语言-视觉-动作三模态的大模型。真正赋予了机器人的泛化能力！
——————————————————————————————————————————
本文包括论文的实验、不足、结论及附录的节选翻译；论文其他部分翻译和解读见本专栏其他文章。翻译仅供参考。
论文地址：arxiv.org/pdf/2307.15818.pdf 翻译：ChatGPT Experiments 我们的实验重点关注RT-2的现实世界泛化和新兴能力，并旨在回答以下问题：
RT-2在已知任务上的表现如何，更重要的是，它如何在新对象、背景和环境上进行泛化？我们能否观察和衡量RT-2的任何新兴能力？泛化效果如何随参数数量和其他设计决策而变化？RT-2是否能像视觉-语言模型一样展现出链式思维推理的迹象？ 通过实验和定量评估，我们可以回答这些问题，深入了解RT-2的性能、能力和泛化特点。这些问题的回答将有助于我们对于将大规模视觉-语言模型与机器人控制相结合的方法和效果有更全面的理解。
我们在各种条件下对我们的方法和几种基线模型进行了约6,000个评估轨迹的评估，这些条件将在以下各节中进行描述。除非另有说明，我们使用一个7自由度的移动操纵器，其动作空间在第3.2节中有所描述。我们还在项目网站上展示了RT-2在实际执行中的示例：robotics-transformer2.github.io。我们训练了两种特定的RT-2实例，它们利用了预训练的VLMs：（1）RT-2-PaLI-X是由5B和55B的PaLI-X（Chen等，2023a）构建的，（2）RT-2-PaLM-E是由12B的PaLM-E（Driess等，2023）构建的。
在训练过程中，我们利用了Chen等人（2023a）和Driess等人（2023）的原始网络规模数据，其中包括视觉问答、图像描述以及非结构化的交织图像和文本示例。我们将这些数据与Brohan等人（2022）的机器人演示数据相结合，该数据在办公室厨房环境中通过13个机器人在17个月内收集而来。每个机器人演示轨迹都用自然语言指令进行了注释，该指令描述了所执行的任务，包括描述技能的动词（例如，“pick”、“open”、“place into”）以及描述操作的一个或多个名词（例如，“7up can”、“drawer”、“napkin”）（有关所使用数据集的更多详细信息，请参见附录B）。对于所有RT-2的训练过程，我们采用了原始的PaLI-X（Chen等，2023a）和PaLM-E（Driess等，2023）论文中的超参数，包括学习率调度和正则化。更多的训练细节可以在附录E中找到。
基线。我们将我们的方法与多个挑战我们方法不同方面的最新基线进行比较。所有的基线都使用完全相同的机器人数据。为了与最先进的策略进行比较，我们使用了RT-1（Brohan等，2022），这是一个拥有35M参数的基于Transformer的模型。为了与最先进的预训练表示进行比较，我们使用了VC-1（Majumdar等，2023a）和R3M（Nair等，2022b），通过训练RT-1骨干以将它们的表示作为输入来实现策略。为了与其他使用VLM的架构进行比较，我们使用了MOO（Stone等，2023），它使用VLM创建了一个额外的图像通道用于语义地图，然后将其馈送到RT-1骨干中。更多信息请参见附录C。
RT-2在已知任务上的表现如何，及它如何在新对象、背景和环境上进行泛化？ 为了评估内分布的性能以及泛化能力，我们将RT-2-PaLI-X和RT-2-PaLM-E模型与前文提到的四个基线进行比较。对于“已知任务”类别，我们使用了与RT-1（Brohan等，2022）中相同的一组已知指令，其中包括超过200个任务：36个用于拾取物体，35个用于撞击物体，35个用于将物体放置直立，48个用于移动物体，18个用于打开和关闭各种抽屉，以及36个用于从抽屉中取出和放置物体。然而，需要注意的是，即使在这些“内分布”评估中，物体的放置以及诸如一天中的时间和机器人位置等因素仍然会变化，这要求模型具有在环境中的实际变化中进行泛化的能力。
我们将泛化评估分为三种未知类别（物体、背景和环境），并进一步分为简单和困难情况。对于未知物体，困难情况包括更难抓取和更独特的物体（例如玩具）。对于未知背景，困难情况包括更多变化的背景和新颖的物体。最后，对于未知环境，困难情况对应于一个更具视觉特色的带有监视器和配件的办公桌环境，而较简单的环境是一个厨房水槽。这些评估涵盖了超过280个任务，主要关注在许多不同情境下的拾取和放置技能。未知类别的指令列表在附录F.2中有详细说明。
评估结果显示在图4和附录表4中。在已知任务上，RT-2模型和RT-1的性能相似，而其他基线的成功率较低。在各种泛化实验中，RT-2模型与基线之间的差异最为显著，这表明视觉-语言-动作模型的优势在于从其互联网规模的预训练数据中转移更具有泛化性的视觉和语义概念。在这里，平均而言，RT-2的两种实例表现相似，相对于RT-1和MOO，它们的改进约为2倍，而相对于其他基线，改进约为6倍。RT-2的PaLM-E版本在更困难的泛化场景中表现似乎优于RT-2-PaLI-X，但在较简单的场景中表现不佳，导致了类似的平均表现。
开源Language-Table基准测试。为了提供使用开源基线和环境的额外比较，我们利用了Lynch等人（2022）的开源语言表格模拟环境。我们在Language-Table数据集上对一个较小的PaLI 3B模型进行了联合微调，包括在领域VQA任务中进行了预测，然后在模拟环境中评估了生成的策略。对于动作预测任务，我们将动作离散化并编码为格式为“X Y”的文本，其中X和Y在{-10，-9，...，+9，+10}之间变化，表示末端执行器的2D笛卡尔设置点的增量。由于其尺寸较小，生成的模型可以以类似的速率（5 Hz）运行推断，就像其他基线一样。这个实验的结果在表1中呈现。我们观察到使用我们的模型与基线相比，在不同的机器人模拟环境中，可以获得显著的性能提升，这表明基于VLM的预训练结合大型PaLI模型的表达能力在其他场景中也可能是有益的，例如这种情况下的模拟。我们还在图5中展示了实际的现实世界外分布行为，展示了新的推动任务以及以前在该环境中未见过的目标。关于语言表格实验的更多细节可以在附录B和D中找到。
我们能否观察和测量RT-2的任何新兴能力呢？ 除了评估视觉语言动作模型的泛化能力之外，我们还旨在评估这些模型在多大程度上能够通过从网络传递知识来实现超出机器人数据中所示能力的新功能。我们将这种能力称为新兴能力，因为它们通过从互联网规模的预训练中获得而出现。我们并不指望这种传递能够实现新的机器人动作，但我们确实期望语义和视觉概念，包括关系和名词，在传统机器人数据中没有看到的情况下，能够有效地传递。
定性评估：首先，我们使用RT-2-PaLI-X模型进行实验，以确定从视觉语言概念中传递过来的各种新兴能力。我们在图2中展示了一些这样的互动示例。通过我们的探索，我们发现RT-2在语义理解和基本推理方面继承了新的能力，这些能力是在场景上下文中得以实现的。例如，完成“将草莓放入正确的碗中”的任务需要对草莓和碗的理解，以及在场景上下文中进行推理，以了解草莓应该与相似的水果一起放置。对于任务“拿起即将从桌子上掉下来的包”，RT-2展示出了物理理解，以消除两个包之间的歧义，并识别出摆放不稳定的物体。在这些情景中测试的所有互动行为在机器人数据中从未见过，这指向了从视觉语言数据中传递的语义知识。
定量评估：为了量化这些新兴能力，我们选择前面评估中的前两个基线，即RT-1和VC-1，并将它们与我们的两个模型进行比较：RT-2-PaLI-X和RT-2-PaLM-E。为了减少这些实验的方差，我们使用A/B测试框架（Fisher, 1936）对所有方法进行评估，其中四个模型都在完全相同的条件下一个接一个地进行评估。
我们将RT-2的新兴能力分为三个类别，涵盖了推理和语义理解的不同方面（每个类别的示例在附录图8中显示）。第一个类别我们称之为符号理解，明确测试RT-2策略是否能够传递从视觉语言预训练中获得的语义知识，而这些知识在任何机器人数据中都不存在。该类别中的示例指令包括“将苹果移动到3”或“将可乐罐推到心脏上方”。第二个类别我们称之为推理，这展示了将底层VLM的各种推理能力应用于控制任务的能力。这些任务需要视觉推理（“将苹果移动到颜色相同的杯子上”）、数学推理（“将X移动到两加一的和附近”）以及多语言理解（“mueve la manzana al vaso verde”）。我们将最后一个类别称为人类识别任务，包括“将可乐罐移动到佩戴眼镜的人身边”等任务，以展示对人类的理解和识别。用于此评估的完整指令列表在附录F.2中详细说明。
我们在图6a中呈现了此实验的结果，所有数值结果都在附录H.2中。我们观察到，我们的VLA模型在所有类别上都显著优于基线，我们最好的RT-2-PaLI-X模型在平均成功率上超过了次佳的基线（RT-1）3倍以上。我们还注意到，虽然基于较大的PaLI-X的模型在符号理解、推理和人物识别性能上平均表现更好，但基于较小的PaLM-E的模型在涉及数学推理的任务上具有优势。我们将这一有趣的结果归因于PaLM-E中使用的不同预训练混合，这导致该模型在数学计算方面比主要依赖视觉预训练的PaLI-X更具能力。
模型表现如何随参数规模和设计细节变化？ 在这个比较中，我们选择使用RT-2-PaLI-X模型，因为它在模型大小方面具有灵活性（由于PaLM-E的性质，RT-2-PaLM-E仅限于特定大小的PaLM和ViT模型）。具体来说，我们比较了两种不同的模型大小，即5B和55B，以及三种不同的训练方式：从头开始训练模型，不使用任何VLM预训练的权重；仅使用机器人动作数据对预训练模型进行微调；以及本研究中主要使用的联合微调（co-fine-tuning），其中我们同时使用原始的VLM训练数据和机器人数据来进行VLM微调。由于我们主要关注这些模型的泛化方面，因此我们从这组实验中排除了已见任务的评估。
实验的结果在图6b和附录表6中呈现。首先，我们观察到从头开始训练一个非常大的模型会导致性能非常差，即使对于5B模型也是如此。鉴于这个结果，我们决定跳过对从头开始训练更大的55B PaLI-X模型的评估。其次，我们注意到，联合微调模型（无论其大小如何）的泛化性能要优于仅使用机器人数据进行微调。我们将这归因于保留在微调部分训练中的原始数据，使得模型不会忘记在VLM训练期间学到的先前概念。最后，不太出人意料的是，我们注意到模型的增加大小会导致更好的泛化性能。
RT2是否展现了类似其他视觉-语言模型的思维链能力？ 受到LLM（语言模型）中链式思维提示方法的启发（Wei等人，2022），我们微调了一种RT-2的变体，使用PaLM-E进行了几百个梯度步骤的微调，以增加其同时利用语言和动作的能力，希望能引发更复杂的推理行为。我们扩充了数据，包括一个额外的“计划”步骤，该步骤首先用自然语言描述机器人即将采取的动作的目的，然后跟随实际的动作标记，例如“指令：我饿了。计划：挑选rxbar巧克力。动作：1 128 124 136 121 158 111 255。”这种数据增强方案在VQA数据集（视觉推理）和操作数据集（生成动作）之间起到了桥梁的作用。
我们在定性上观察到，具有链式思维推理的RT-2能够更好地执行更复杂的命令，因为它首先可以使用自然语言计划其动作。这是一个有希望的方向，为我们提供了一些初步的证据，表明将LLM或VLM用作规划器（Ahn等人，2022; Driess等人，2023）可以与单个VLA模型中的低级策略相结合。RT-2链式思维推理的模拟结果在图7中展示，附录I中也有更多相关内容。
Limitations 尽管RT-2展现出有希望的泛化特性，但这种方法还存在多个限制。首先，尽管我们展示了通过VLM的Web规模预训练可以提升对语义和视觉概念的泛化能力，但机器人并没有因为包含了这种额外的经验而获得执行新动作的能力。该模型的物理技能仍然受限于机器人数据中所见的技能分布（请参见附录G），但它学会了以新的方式应用这些技能。我们认为这是由于数据集在技能轴上的变化不足造成的。未来研究的一个令人兴奋的方向是研究如何通过新的数据收集范式（例如人类视频）获得新的技能。
其次，虽然我们展示了可以实时运行大型VLA模型，但这些模型的计算成本很高，而且在需要高频控制的情况下，实时推断可能成为一个主要瓶颈。未来研究的一个激动人心的方向是探索量化和蒸馏技术，可能使这些模型能够以更高的速率运行或在更低成本的硬件上运行。这也与另一个当前的限制有关，即只有少数几个通常可用的VLM模型可以用来创建RT-2。我们希望会有更多的开源模型可用。
Conclusions 在本文中，我们描述了如何通过将视觉语言模型（VLM）的预训练与机器人数据相结合来训练视觉-语言-动作（VLA）模型。然后，我们介绍了基于PaLM-E和PaLI-X的两种VLA实例，分别称为RT-2-PaLM-E和RT-2-PaLI-X。这些模型通过机器人轨迹数据进行协同微调，以输出机器人动作，这些动作以文本令牌的形式表示。我们展示了我们的方法导致了非常出色的机器人策略，并且更重要的是，它在泛化性能和从Web规模视觉语言预训练中继承的新能力方面表现出显著优势。我们相信，这种简单而通用的方法展示了机器人学习可以直接从更好的视觉语言模型中受益，从而使机器人学习领域在其他领域的进步中处于战略地位，进一步得到改进。
Appendix 数据集 本工作中使用的视觉-语言数据集基于Chen等人（2023b）和Driess等人（2023）的数据集混合物。这些数据集组合了各种来源，包括WebLI数据集，其中包含大约10亿对跨109种语言的图像-文本对。WebLI数据集经过筛选，包括排名前10%的跨模态相似性示例，从而获得约10亿个训练示例。此外，还包括其他字幕和视觉问答数据集。关于数据集混合物的更详细信息可以在Chen等人（2023b）的RT-2-PaLI-X部分和Driess等人（2023）的RT-2-PaLM-E部分找到。值得注意的是，在对RT-2-PaLI-X进行协同微调时，不使用Chen等人（2023a）中描述的Episodic WebLI数据集。
本工作中使用的机器人数据集基于Brohan等人（2022）的数据集。该数据集包括使用移动操纵机器人收集的演示情节。每个演示都与自然语言指令相关联，对应于七种技能之一，如“Pick Object”、“Move Object Near Object”、“Place Object Upright”、“Knock Object Over”、“Open Drawer”、“Close Drawer”、“Place Object into Receptacle”和“Pick Object from Receptacle and place on the counter”。有关机器人数据集的更详细信息，可以参考Brohan等人（2022）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0ae990f966f0ba1ec88930b388042b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1526b6155cb0f219bf394d72c58a8ff6/" rel="bookmark">
			VSCode中修改HTML代码无法实时刷新到浏览器页面的问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		天行健，君子以自强不息；地势坤，君子以厚德载物。
每个人都有惰性，但不断学习是好好生活的根本，共勉！
文章均为学习整理笔记，分享记录为主，如有错误请指正，共同学习进步。
实时刷新代码到浏览器页面 一、问题重现1. VSCode中编写HTML代码2. Live Server插件3. 修改代码 二、问题分析1. Live Server2. 重启VSCode3. Live Server Preview4. 自动保存 三、问题解决1. 打开自动保存代码设置2. 浏览器查看页面3. 再次修改代码内容4. 再到浏览器页面查页面内容 一、问题重现 1. VSCode中编写HTML代码 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 这是一个测试界面，验证是否实时刷新到浏览器页面 &lt;/body&gt; &lt;/html&gt; 2. Live Server插件 首先下载Live Sever 插件
参考：https://blog.csdn.net/mo_sss/article/details/132321681
下载后重启VSCode，代码界面右键Open with Live Server 可将代码打开到浏览器中查看
如图所示：
3. 修改代码 修改代码，在文本后添加以下内容
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 这是一个测试界面，验证是否实时刷新到浏览器页面 &lt;br&gt;20230822 &lt;/body&gt; &lt;/html&gt; 查看浏览器页面
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1526b6155cb0f219bf394d72c58a8ff6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5649b8cb14686cc4df4ec37b4ca24730/" rel="bookmark">
			半导体制造常用软件工具总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 半导体制造常用软件工具总结 CIM：Computer Integrated Manufacturing 设备自动化，总称MES：Manufacturing Execution System 制造执行系统EAP：Equipment Automation Programming 设备自动化，是MES与设备的桥梁APC：AdvancedProcessControl 先进过程控制技术FDC：Fault detect control 故障检测控制RMS：Recipe Management System 配方管理系统SPC：Statistical Process Control 质量管理与控制，利用统计方法进行控制YMS：Yield Management System 良率管理系统AMHS：Automatic Material Handling System搭配RTD和MCS使用以实现高程度的自动化RTD：Real-time Dispatch 实时派工系统MCS：Material Control System 物料控制系统，控制天车APS：Advanced Planning and Scheduling，高级计划与排程PMS：Preventive Maintenance System 预防保养系统 其他参考 半导体制造领域的先进过程控制技术APC
最早了解APC的参考，这是广义上的APC，里面包含了一些不属于狭义APC的范畴工业软件——先进过程控制系统APC
这里设计到PID和MPC芯片制作工序 &amp; 半导体常见自动化软件模块梳理半导体FAB厂岗位介绍 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40a120f7ec2fb464bb66248720bd481d/" rel="bookmark">
			springboot actuator配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		### #1、Endpoints是Spring Boot Actuator提供的一组用于监控和管理应用程序的RESTful接口 #2、Endpoint是Endpoints的具体实现类 #3、Endpoints与Endpoint，有一个禁用，则结果是禁用 ### management: health: db: enabled: true #配置health端点中，是否检测、展示db存活 endpoints: #是否暴露endpoint,相当于总开关，默认为true enabled-by-default: true web: #默认访问路径 base-path: /myActuator #暴露哪些web endpoint，默认为health、info exposure: include: '*' #配置暴露所有端点 #include: 'health,info,env' #配置暴露health,info,env这3个端点 #exclude: "beans,heapdump,shutdown" #配置不暴露beans,heapdump,shutdown这3个端点 #关闭所有端点之后，可以指定暴露某个端点 #endpoints配置暴露所有端点后，endpoint再配置，结果是打开 endpoint: info: enabled: true heapdump: enabled: true #Endpoints与Endpoint，有一个禁用，则结果是禁用 health: show-details: never #配置是否展示health详细信息 参考：应用监控之 SpringBoot Actuator 使用及配置 - 简书
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f00f29e66a1d22d492535eab3e754dd9/" rel="bookmark">
			Pycocotools 报错 No module named pycocotools.coco 以 numpy.ndarray size changed, may indicate binary
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、numpy.ndarray size changed, may indicate binary incompatibility. Expected 88 from C header, got 80 from PyObject pycocotools和numpy版本不兼容导致
pip install --upgrade numpy 或
pip install --upgrade numpy==1.20.2
pip install --upgrade pycocotools==2.0.2
或
pip install --upgrade --force-reinstall pycocotools
pip install --upgrade --force-reinstall numpy
2、No module named 'pycocotools' 参考链接 https://betterdatascience.com/modulenotfounderror-no-module-named-pycocotools/
除了直接pip或者conda安装之外的解决办法是本地直接从git源链接安装到本地：
Solution 3 - Use Pycocotools source code
Installing Pycocotools from the source implies you have Cython and C compiler already configured. If that’s the case, proceed by cloning the COCO API GitHub repository, and navigating to the correct directory for Python API:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f00f29e66a1d22d492535eab3e754dd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8171a9727bee01ff6c23114de706cf7f/" rel="bookmark">
			（C语言）歌手得分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有n个评委为参赛的歌手打分，分数为0~100分。歌手最后得分为去掉m个最高分和m个最低分后，剩余的n−2m个分数的平均值。
输入数据的第一行为一个正整数T，表示测试数据的组数，然后是T组测试数据。对于每组测试数据，第一行输入两个整数n,m(3&lt;n&lt;100,m&lt;n/2)，含义如上；第二行输入n个整数。
对于每组测试数据，输出一行，包含一个实数，表示歌手的最后得分。结果保留两位小数。
输入样例：
2
10 1
20 20 80 80 10 10 10 40 40 60
10 2
20 20 80 80 10 10 10 40 40 60
输出样例：
35.00
31.67
解决代码如下：
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(){ int n,m,t,i,j,p,q; double averge,sum=0; scanf("%d",&amp;t); for(q=0;q&lt;t;q++){ scanf("%d %d",&amp;n,&amp;m); int score[n]; for(i=0;i&lt;n;i++) scanf("%d",&amp;score[i]); for(i=0;i&lt;n-1;i++){ for(j=0;j&lt;n-1-i;j++){ if(score[j]&gt;score[j+1]){ p=score[j];score[j]=score[j+1];score[j+1]=p; } } } sum=0; for(i=0;i&lt;n-2*m;i++){ sum=sum+score[m+i];} averge=sum/(n-2*m); printf("%.2lf",averge); printf("\n"); } return 0; } 此代码主要是用来练习数组和循环，这个题目当中，理解哪个循环套在哪个循环里面是最重要的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e17911f87377b4c0d5c53e41dfe37f1/" rel="bookmark">
			leetcode 第360场周赛
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总结 好久没参加leetcode周赛了，比赛时间都从两小时变成了一个半小时。这次周赛由两道签到题和两道中等难度题组成，严格来说最后一道的难度也可以视为hard，但是只要想到正确的思路，编码还是比较容易的。
比赛链接:leetcode 第 360 场周赛
题目列表 1.距离原点最远的点 题目描述 给你一个长度为 n 的字符串 moves ，该字符串仅由字符 'L'、'R' 和 '_' 组成。字符串表示你在一条原点为 0 的数轴上的若干次移动。
你的初始位置就在原点（0），第 i 次移动过程中，你可以根据对应字符选择移动方向：
如果 moves[i] = 'L' 或 moves[i] = '_' ，可以选择向左移动一个单位距离如果 moves[i] = 'R' 或 moves[i] = '_' ，可以选择向右移动一个单位距离 移动 n 次之后，请你找出可以到达的距离原点 最远 的点，并返回 从原点到这一点的距离 。
示例 1：
输入：moves = "L_RL__R" 输出：3 解释：可以到达的距离原点 0 最远的点是 -3 ，移动的序列为 "LLRLLLR" 。 示例 2：
输入：moves = "_R__LL_" 输出：5 解释：可以到达的距离原点 0 最远的点是 -5 ，移动的序列为 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e17911f87377b4c0d5c53e41dfe37f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a63501709ee9d25385e923a0eb05d307/" rel="bookmark">
			python使用openpyxl模块操作Excel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python使用openpyxl模块操作Excel 1.openpyxl概述1.1 openpyxl的官网：1.2 openpyxl的API文档：1.3 openpyxl的主要class和各个对象间的加载与访问class访问和加载方式 2.workbook对象的主要属性和方法Class openpyxl.workbook.workbook.Workbook主要属性：主要方法：操作workbook对象的方法：保存、关闭获取worksheet对象的方法：索引、名称操作worksheet对象的方法：创建、删除、移动、复制 3.worksheet对象的主要属性和方法Class openpyxl.worksheet.worksheet.Worksheet主要属性主要方法： 4.Cell对象的主要属性和方法5.Font对象的主要属性Class openpyxl.style.font.Fontsname = "微软雅黑" #字体型号size = 20 #字体大小color = Blue #字体颜色bold = True # 加粗italic = True # 倾斜underline = 'single' #单个下划线strikestrough = True #删除线 5.工程实例5.1 创建workbook新建sheet写入数据并保存5.2 读取workbook并修改5.3 对Excel中数据的格式进行修改 1.openpyxl概述 1.1 openpyxl的官网： https://openpyxl.readthedocs.io/en/stable/index.html
1.2 openpyxl的API文档： https://openpyxl-chinese-docs.readthedocs.io/zh_CN/latest/api/openpyxl.html
1.3 openpyxl的主要class和各个对象间的加载与访问 class openpyxl.workbook.workbook.Workbook
opnepyxl.worksheet.worksheet.Worksheet
openpyxl.cell.cell.Cell
访问和加载方式 #加载workbook对象
wb=openpyxl.load_Workbook(Filename)
#创建workbook对象
wb=openpyxl.Workbook()
#根据sheetname加载worksheet对象
sh=workbook[sheetname]
#创建worksheet对象
sh=workbook.creat_sheet(sheetname)
#根据Cell的坐标加载某个单元格
cell=worksheet[cellcoordinate]
#根据列号获取某一列的单元格
cellrange=worksheet[‘A’]
#根据列号获取某几列的单元格
cellrange=worksheet[‘A：C’]
#根据行号获取某一行的单元格
cellrange=worksheet[3]
#根据列号获取某几列的单元格
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a63501709ee9d25385e923a0eb05d307/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d4918bbb119928dc8a8206e8f008613/" rel="bookmark">
			(C语言)鸡兔同笼求解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 鸡兔同笼，共有98个头，386只脚，请用穷举法编程计算鸡、兔各有多少。
#include&lt;stdio.h&gt; int main() { int t,j; for (j=1;j&lt;=98;j++) { t=98-j; if(j*2+t*4==386){ break; } } printf("chicken:%d\nrabbit:%d\n",j,t); } 此程序不需要进行输入操作，进行输入操作可以对此程序进行进一步拓展，利用穷举法解出所有解，拓展如下：
#include&lt;stdio.h&gt; int main() { int t,j,a,b; int x=0; scanf("%d%d",&amp;a,&amp;b); for (j=1;j&lt;=a;j++) { t=a-j; if(j*2+t*4==b){ x=x+1; break; } } if(x!=0){ printf("chicken:%d\nrabbit:%d\n",j,t); } if(x==0){ printf("无解"); } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4614705cb21fdf6c5f0b410d2ccca9ff/" rel="bookmark">
			【Python】requests实现cookie 登陆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Python 系列 文章目录 Python 系列前言一、requests是什么？二、使用步骤1.引入库 总结 前言 session 登录获取接口数据的，操作不需要header 等数据，print(my_session.headers)，如果有需要可以自己重新去设置，包括cookie的内容等
一、requests是什么？ 可以实现get post 等网络请求，cookie ，可以作为登录的凭证，可以简单的理解为在登录之后，每次的操作都能获取是登录状态的一个标识,
二、使用步骤 1.引入库 代码如下（示例）：
import requests //创建一个session my_session = requests.session() my_session.post('loginurl', params={ "username": "jack", "password": "mimamima", }) print(my_session.cookies)# 这边可以查看正常登录之后的cookie 的信息数据 # 在登录完成之后session 会自动存储cookie，现在只需要使用my_session ，就会是在一个登录的状态去获取其他接口的数据信息 res = my_session.post('get something url', params={ "name": "jack ma", }) json1 = res.json() print(json1) 总结 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc662a0e794aff042b9ea3c13552439e/" rel="bookmark">
			package.json 详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 package.json1. name2. version3. description4. homepage5. bugs6. license7. author, contributors8. funding9. files10. main11. module12. browser13. bin14. man15. directories15.1 directories.bin15.2 directories.man 16. repository17. scripts18. config19. dependencies19.1 URLs as Dependencies19.2 Git URLs as Dependencies19.3 GitHub URLs19.4 Local Paths 20. devDependencies21. peerDependencies22. peerDependenciesMeta23. bundleDependencies24. optionalDependencies25. overrides26. engines27. os28. cpu29. private30. publishConfig31. workspaces32. DEFAULT VALUES33. 更多 package.json npm package.json 文件的详细说明。
Version:9.8.1
本文档包含了关于 package.json 文件中所需内容的所有信息。它必须是有效的 JSON 格式，而不仅仅是 JavaScript 对象字面量。
1. name 如果您计划发布您的包，那么 package.json 文件中最重要的字段是 name 和 version，它们是必需的。name 和 version 共同形成一个被认为是完全唯一的标识符。对包的更改应该伴随着版本的更改。如果您不打算发布您的包，name 和 version 字段是可选的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc662a0e794aff042b9ea3c13552439e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62f27c4cf398a90bd0984b82ef16682b/" rel="bookmark">
			四维图新 minemap实现地图漫游效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原理就是不断改变地图中心点，改变相机角度方向，明白这一点，其他地图引擎譬如cesium都可效仿，本人就是通过cesium的漫游实现四维图新的漫游，唯一不足的是转弯的时候不能丝滑转向，尝试过应该是四维图新引擎的问题 /* * @Description: * @Author: 大帅逼 * @Date: 2023-08-17 17:52:09 * @LastEditTime: 2023-08-21 15:39:15 * @LastEditors: Do not edit * @Reference: */ export default function flyView (map, roadLine,nextIndex){ let index = 1; let ding; let currentCenter; if(nextIndex){ index = nextIndex; } const flyTime = 12000; //一段路程的飞行时间 /** * 设置时间差 * @returns 开始时间 结束时间 */ function setExtentTime(time) { const startTime = new Date().getTime(); const stopTime = startTime + time; return { stopTime, startTime }; } /** * 相机转向角 * @param {number} angle 角度 * @returns {number} 弧度*/ function bearings(startLat, startLng, destLat, destLng) { const y = Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62f27c4cf398a90bd0984b82ef16682b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d198bc49de8ba26ed60c8b91be6246ba/" rel="bookmark">
			企业注册小程序流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、准备资料： 1、未被微信公众平台注册，未被微信开放平台注册，未被个人微信号绑定的邮箱
2、企业名称（与企业注册证上的一致）
3、营业执照注册号（15位）（或18位统一社会信用代码）
4、公司对公帐户打款验证（注册过程中使用公司对公帐户给腾讯小额打款验证）
5、管理员信息：姓名、身份证号、手机号、身份验证（手机号短信验证及微信扫码验证）
二、进入网址，点击右上角“立即注册”按钮 微信公众平台网址：https://mp.weixin.qq.com/
三、选择注册类型-小程序 四、填写账号信息-&gt;邮箱激活 五、信息登记及打款 选择主体类型为企业
六、填写主体信息及选择注册方式： 企业类型帐号可选择两种主体验证方式。
方式一：向腾讯公司小额打款认证（只需几毛）
需要用公司的对公账户向腾讯公司打款来验证主体身份。打款信息在提交主体信息后可以查看到。
方式二：微信认证（无需企业对公账户打款）
通过微信认证验证主体身份,需支付300元认证费。认证通过前,小程序部分功能暂无法使用。
七、填写管理员信息（后期可变更） （八、注册完成，完善信息） 用刚注册的账号登录微信公众平台，完善小程序信息
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/590895582df2a4c4403eba0a1ef55b38/" rel="bookmark">
			都28了，半路转行学编程还来得及吗?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多新来的粉丝，经常会问到：“我现在xx岁了，学编程晚吗?"，“程序员是不是吃青春饭啊，我都没有青春了，还能找到工作吗？”…
其实这类的问题，东东以前都已经整理过文章，说过很多次了，但今天还是想系统的给大家打个鸡血。
多年前就有人说，计算机专业已经不吃香了，毕业出来时找不到工作，但是看看现在，互联网人才缺口依然很大！！
别人在一个行业成功了，大家就会说这个行业都这么多人成功了，肯定已经不缺人了，你就不去争取！
对那些问“现在学编程，晚了么？”的小伙伴，其实：学编程，任何时候都不晚！
分析行业
最近几年大家都感受到互联网给我们生活带来的变化，移动支付、共享单车、外卖等等等，完全改变了我们的生活方式。其他行业也逐渐离不开互联网，互联网俨然已经成了基础设施。
何为基础设施？意味着你生活的方方面面，都越来越离不开它，互联网的前景可想而知。
还有说互联网发展至今，是否后续已经没有发展了，快停滞不前了？
互联网发展至今还不到百年，在中国发展起来也只是近几十年。同时互联网经历过PC时代以及移动时代，已经趋向成熟、稳定！
未来，互联网会渗透每个行业，进入每个城市，担心现在是互联网的尾声，完全是短见，未来，人工智能、物联网、智能家居、无人驾驶等等，都将是改变人类的大时代，互联网必将继续改变人们的生活方式。
看看前景
分析了所处的大行业之后，再来为大家分析一下编程自身的前景！
先说工资，找一份工作，工资肯定是每个人都在意的方面。
2020年平均工资出炉：IT业年平均工资超17万元，连续5年雄踞第一。
其实如果你关注每年的薪资排行榜：我们看下信息技术服务业每年优越的增长速度，再横向对比下其他行业，发现IT业真香！
而比较有意思的是，哪怕薪资排行第二的金融行业，也离不开互联网，而 IT是互联网最中坚、最核心的行业，而编程又是IT领域最核心的岗位，所以，说到薪资，编程是有足够的吸引力让你学习的！
另外，编程语言有很多种，但是编程是通的，当你掌握了一门语言，再学习其他的语言要容易的多。并且据调查，如果你会两种以上编程语言，企业开出的薪资也将高一些。
例如，如果你是学习Web前端JavaScript的，但是你还同时了解后端Java语言，会一些编程，如果顺带还会Python、C、C++那么相信企业会非常喜欢你！
年龄呢…
在程序员这一行，有一部分人会告诉你，IT是吃青春饭的，如果大学没学了，出来工作就不要瞎折腾了，太晚了。
大学毕业的年龄，大约是在23左右~那这个年龄学编程，就是老龄化了？
事实肯定不是这样的，不然那么多27、8岁才毕业的研究生怎么办！但为什么大家都喜欢讲工作跟年龄挂钩？这就涉及心理暗示问题了…
心态会影响一个人的行为。当有人告诉你，23岁学编程太迟了，哪怕你不信邪，信心和毅力都会受到影响，特别是当你遇到困难的时候。
当自己觉得学编程太晚时，就很可能因为“觉得晚”，而编程学得烂……所以，当有人告诉你：做某件事太晚了，都这把年纪了，别瞎折腾时，请给他一个大嘴巴，请他闭嘴。
大部分问这个问题的人，应该说是迫于生活，迫于压力，急需转行，但又苦于年龄问题，不知道现在转行，是否太迟，年龄集中在23-35岁之间，可谓“这把年纪了。”
公司不招大龄程序员？
身体、家庭拖累，跟不上节奏？
年纪大了，思维跟不上？
与年轻人比，没有任何优势？
…
种种都成了学编程、学习太迟的借口，总以为别人“学得太早”，这是不对的，大家都只比较了起点，而没人比较线段。
他们编程能力高超，技法娴熟，并不是因为“他们开始得太早”，而是他们“学得已经够久了。”所以，以自己的起点，比对手的线段，并不公平，这时开始的你，应该和起点时的他们比，你是否超越了他们？
这位老奶奶，可谓是活到老学到老的案例了，虽然他不是为了工作，也不能说是热爱编程，但是这种不服输，利用空余时间学习的精神是非常让人佩服的。
始终一句话：“种一棵树最好的时间是十年前，其次是现在。”
什么样的人适合学IT? 中学毕业想进入高薪行业 职/高中生刚毕业，大多数都很迷茫，他们不仅不知道自己想干什么、能干什么，甚至不知道自己不想干什么。这样的你，不如趁青春正好，来学习IT技术，在互联网+的大环境下，用自己的努力实现高薪梦。
不安现状，想转行者 如果你不喜欢自己目前的工作，行业前景不可观，那么，你可以考虑重新学习一门IT技术，掌握赚钱的本领，跨行学习，也能有一番作为。
学历低想改变命运的人 一些人因为各种原因，不得不中途放弃学业外出打工，但是学历不高的人，薪资也普遍不高，工作环境自然也不会太好。因此，想重新开始学习，提升学历，这时候选择热门的IT技术，让你有一个很好的起点，并且能够接触一些先进的知识，开拓眼界，毕业后高薪就业，何乐而不为?
退伍军人 如果你在IT行业，实操能力和执行力是企业最看重的能力之一。这也是为什么东科教育一直践行理论+实践相结合的授课模式的原因。而军人在部队所培养和锻炼出来的较强的动手能力和执行力用在IT技术的学习上，一定会比别的学员学的更快、更好。转业并不等于失业，退伍并不等于落伍，抓住机会，选择正确的成材之路，人生将是一个新的开始！
即将或已经毕业计算机专业学生 除了初高中生，现在很多大学毕业生毕业求职时空有一纸文凭，在技能和经验上和企业的需求有很大差距，尤其是像计算机专业这样的工科类专业，很难找到一份满意对口的工作。在大学，计算机专业往往采取传统教育方式，以老师说学生听为主，这样的方式很难保证学生对知识的吸收，加上传统应试教育中几乎为零的实际动手操作训练，出现毕业生零基础状况也不足为奇。这也导致：人才与岗位的匹配度矛盾在近年来越来越明显！所以对于想要从事计算机相关专业的学生，参加IT培训，可以在最短的时间内掌握技术、积累项目经验，在大学所学理论知识的基础上实力进阶，无疑是比较好的选择。
关于Python学习指南 学好 Python 不论是就业还是做副业赚钱都不错，但要学会 Python 还是要有一个学习规划。最后给大家分享一份全套的 Python 学习资料，给那些想学习 Python 的小伙伴们一点帮助！
包括：Python激活码+安装包、Python web开发，Python爬虫，Python数据分析，人工智能、自动化办公等学习教程。带你从零基础系统性的学好Python！
👉Python所有方向的学习路线👈 Python所有方向路线就是把Python常用的技术点做整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。（全套教程文末领取）
👉Python学习视频600合集👈 观看零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
温馨提示：篇幅有限，已打包文件夹，获取方式在：文末 👉Python70个实战练手案例&amp;源码👈 光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
👉Python大厂面试资料👈 我们学习Python必然是为了找到高薪的工作，下面这些面试题是来自阿里、腾讯、字节等一线互联网大厂最新的面试资料，并且有阿里大佬给出了权威的解答，刷完这一套面试资料相信大家都能找到满意的工作。
👉Python副业兼职路线&amp;方法👈 学好 Python 不论是就业还是做副业赚钱都不错，但要学会兼职接单还是要有一个学习规划。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/590895582df2a4c4403eba0a1ef55b38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17fc8cc9721386486548bae105b71820/" rel="bookmark">
			自编码器：数据降维和特征提取的新方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 自编码器的原理编码过程解码过程 自编码器的应用数据降维特征提取 拓展应用总结 🎉欢迎来到AIGC人工智能专栏~自编码器：数据降维和特征提取的新方法
☆* o(≧▽≦)o *☆嗨~我是IT·陈寒🍹✨博客主页：IT·陈寒的博客🎈该系列文章专栏：AIGC人工智能📜其他专栏：Java学习路线 Java面试技巧 Java实战项目 AIGC人工智能 数据结构学习🍹文章作者技术和水平有限，如果文中出现错误，希望大家能指正🙏📜 欢迎大家关注！ ❤️ 在机器学习领域中，自编码器（Autoencoder）是一种强大的神经网络架构，用于数据降维和特征提取。自编码器通过训练过程将输入数据映射到低维编码空间，然后再将其重构为原始数据。本文将深入探讨自编码器的原理、应用以及代码示例，帮助读者理解其在数据处理中的重要性。
自编码器的原理 自编码器的基本思想是尝试将输入数据通过编码器（Encoder）映射到一个低维的隐藏表示，然后再通过解码器（Decoder）将隐藏表示重构为原始数据。这个过程可以理解为一个数据的压缩和解压缩过程，其中隐藏表示被认为是数据的有价值特征。
编码过程 编码器部分的目标是将输入数据压缩为一个较小的隐藏表示。常见的编码器结构是多层神经网络，其中逐渐减少神经元的数量，使得网络逐渐捕捉到数据的主要特征。
import tensorflow as tf from tensorflow.keras.layers import Input, Dense def build_encoder(input_shape, encoding_dim): inputs = Input(shape=input_shape) encoded = Dense(128, activation='relu')(inputs) encoded = Dense(encoding_dim, activation='relu')(encoded) return tf.keras.Model(inputs, encoded) 解码过程 解码器部分的目标是将隐藏表示解码为原始数据。解码器的结构与编码器相似，但神经元数量逐渐增加，最终生成与输入数据相匹配的输出。
def build_decoder(encoding_dim, input_shape): inputs = Input(shape=(encoding_dim,)) decoded = Dense(128, activation='relu')(inputs) decoded = Dense(input_shape, activation='sigmoid')(decoded) return tf.keras.Model(inputs, decoded) 自编码器的应用 数据降维 自编码器的一个重要应用是数据降维。通过将高维数据映射到低维表示，自编码器可以去除冗余信息，提取数据的主要特征。这对于处理大量数据和减少计算成本非常有用。
# 使用自编码器进行数据降维 encoding_dim = 32 encoder = build_encoder(input_shape, encoding_dim) decoder = build_decoder(encoding_dim, input_shape) autoencoder = tf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17fc8cc9721386486548bae105b71820/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a752edfff232d0e2faab8b8f661c895d/" rel="bookmark">
			在win11上建立Python环境（特详细，初学者可了解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、下载安装程序
1、官网安装地址：Download Python | Python.org
打开上面网址，会进入如下页面，该网页会检测你的系统平台，给出最新版本的下载提示。
2、国内下载地址：
国外官网下载速度实在有些慢，推荐到国内华为云上的Python各平台各版本的下载镜像源下载，地址是：Index of python-localhttps://mirrors.huaweicloud.com/python/
上面这个网址下载Python速度非常快，打开后显示如下的页面，进入你需要的版本，然后选择需要的平台上的不同类型的文件即可。
我的电脑是Win11，选择下载的安装文件是Python3的最后一个版本，目前最新的是3.12版本
python-3.11.5-arm64.exe 二、安装Python
双击下载到电脑中的python-3.11.5.amd64.exe文件，如下如下的安装画面：
注意：把最下方的Add python.exe to PATH这个选项一定要勾选上。
默认如上选项即可，点击"NEXT"按钮。
建议不要勾选最上面的一个选项“Install Python3.11 for all users"，和我一样的初学者安装到默认的文件夹即可，因为后面要安装一些外部的库，会默认安装到这里，如果把python安装到其它文件夹，有可能无法正常运行。 可以测试一下，打卡终端，输入python然后回车，出现如下的画面，就说明Python已经正常运行，可以使用了。
在上图的三个三角符后输入print("Hello world .")后回车，会显示出来"Hello world ."，如下图 祝贺，已经使用Python编写并运行了第一个程序。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e1cb062c8e69ba34883a8b009ed1d94/" rel="bookmark">
			城市安全风险监测预警平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在城市化进程不断加速的今天，城市已然成为一个复杂的社会机体和巨大的运行系统，而城市安全新兴风险、传统产业风险、区域风险等积聚滋生、易发多发，也暴露出我国部分城市安全风险底数不清、安全风险辨识水平不高、安全管理手段落后、风险化解能力有限等突出问题。
城市安全风险监测预警平台是集传感器、监测设备、数据采集分析系统于一体的综合性平台。它以物联网、大数据、人工智能等技术为基础，实现对城市基础设施、环境、交通、公共安全等各个领域的全面感知和实时监控，为城市管理者提供精确、高效的数据支持，从而推动城市管理水平的不断提升。
城市安全综合风险一张图 推动城市运行管理“一网统管”
汇聚融合城市安全运行相关各类数据，以“一张图”形式呈现城市整体运行和风险态势，形成全方位、多层级、立体化的城市风险监测预警平台以及多主体、大联动应急管理协同处置机制，提升城市安全综合风险管控能力。
实时感知监测对象安全运行状态 风险监测分析预警
实时感知监测对象的位置、设备编号、设备状态及监测量等信息，基于地图可视化展示不同区域监测设备覆盖数量和点位分布，通过对城市运行监测数据和报警数据，进行事故预测、风险研判、耦合分析、风险预警等。
多类型分级预警 实现报警信息与警情处置及时联动
当监测数据异常时，可根据不同的报预警分级规则，自动确定预警类型/级别，并匹配相应的应急预案，通过监管平台或手机APP派单给相应责任人，确保报警信息与警情处置及时联动，执行落地。
总之，城市安全风险监测预警平台作为智慧城市的重要组成部分，正在引领城市管理进入一个全新的时代。通过对数据的全面感知和深度分析，能够有效提升城市管理效率，为人类创造更加美好的城市生活。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba60e1f7f2e4dbe5283f707a821fa0b4/" rel="bookmark">
			气瓶充装追溯管理平台-液化石油气配送信息系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		液化石油气瓶作为城市能源的重要载体，对于社会经济的发展有着重要意义，但燃气安全形势严峻、安全事故频繁发等痛点依然存在，由于气瓶数量多、使用分散、流动性大等特点，给液化气瓶的安全监管也带来了诸多难题。
气瓶充装追溯管理系统通过对气瓶添加电子标签、二维码等身份标识，再运用识读设备将气瓶存储、运输、配送流程及终端用户使用情况等信息，上传到气瓶充装追溯管理平台，实现气瓶登记注册数字化管理。
监管部门可通过该平台，按区域查看燃气企业、燃气用户、站点、气瓶以及配送人员的分布和基本信息，方便监管人员快速掌握辖区内气瓶注册、使用、流转、检验及报废等情况。
城市液化气瓶“一张图”，显示用户气瓶的分布位置、燃气泄露报警以及配送车辆当前所在位置的GIS地图信息，可对数据进行分析研判，统计企业安全评级、安检率、预警率、整改率等指标。
可在经营企业重点区域进行视频监控，将各燃气经营企业重点区域，按标准安装摄像头，并远程调用摄像头信息，实现远程视频监控的目的。
该系统通过加装瓶装液化气报警器，还可实时监测用户瓶装液化气泄露浓度，当浓度超标时，瓶装液化气报警切断装置立即发出声光报警，自动关闭切断阀，并将报警信息通过智能语音电话、小程序等方式推送给监管部门及用户，实现报警信息与警情处置及时联动，从而有效降低事故风险。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/400833be3501b1627d2c47a254f987d3/" rel="bookmark">
			拦截器拦截swagger2的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 通过断点的方式获取到访问swagger时的路径是 /v2/*
在拦截器中设置放行的样式
protected void addInterceptors(InterceptorRegistry registry) { log.info("开始注册自定义拦截器..."); String[] swaggerExcludes=new String[]{"/v2/**","/swagger-resources/**"}; registry.addInterceptor(jwtTokenInterceptor) .addPathPatterns("/**") //添加拦截路径 .excludePathPatterns("/user/login") //放行登录方法 .excludePathPatterns(swaggerExcludes); //放行swagger路径 } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14d6f4642aad864fc6178b2eca43bccc/" rel="bookmark">
			如何在树莓派4上安装和设置OpenCV
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
概述
要求
在 Raspberry Pi 上安装和设置 OpenCV
步骤1：安装依赖项
步骤2：安装pip（包管理工具）
步骤3：安装 Numpy 库
步骤4：访问 Raspbian 存储库上的 OpenCV
步骤5：安装OpenCV
步骤6：验证 OpenCV 安装
结论
概述 在本指南中，我们将学习如何在Raspberry Pi 4计算机上安装和设置 OpenCV。
OpenCV（开源计算机视觉库）是一个开源计算机视觉和机器学习软件库。它包含超过 2500 种优化算法，涵盖视觉领域的各个领域，包括但不限于：
图像和视频捕捉
预处理（过滤、灰度化、阈值化等）
人脸和眼睛检测
物体检测
边缘检测和运动感应
图像分割
机器学习
相机校准
3D重建
运动分析和对象跟踪
增强现实
OpenCV和Raspberry Pi共同为各种计算机视觉项目提供了强大的平台。无论您是要构建具有人脸识别功能的智能门铃、可以导航周围环境的机器人，还是只是学习计算机视觉的基础知识，这个组合都是经济实惠且用途广泛的。
要求 对于硬件部件，我们需要以下组件：
您可以使用HDMI 监视器或VNC 查看器进行设置部分。
在 Raspberry Pi 上安装和设置 OpenCV 在学习如何在 Raspberry Pi 计算机上安装和设置 OpenCV 之前，您需要先设置 Raspberry Pi。要首先了解如何设置 Raspberry Pi，请参阅本文。
在本指南中，我们使用了带有最新 Raspbian Buster 的 Raspberry Pi 4。OpenCV的安装过程分为多个步骤如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14d6f4642aad864fc6178b2eca43bccc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/241bc9a4fab475063578ee84857ce351/" rel="bookmark">
			树莓派项目：在树莓派上使用 OpenCV 进行边缘检测和运动传感
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
概述：
所需组件
树莓派相机连接
什么是均方误差 (MSE) 和 Canny 边缘检测方法？
均方误差 (MSE)
Canny边缘检测方法
Raspberry Pi 设置、库和依赖项安装
使用 OpenCV 进行边缘检测和运动传感的 Raspberry Pi Python 代码
Python代码
代码说明
边缘检测和运动传感的测试和结果
结论
概述：
该项目是关于在Raspberry Pi 4上使用 OpenCV 进行边缘检测和运动传感。
在OpenCV中，边缘检测和运动传感是图像处理和计算机视觉的支柱。通过图像处理，边缘检测等技术可以细化视觉数据，突出显示特征以改进图像输出。相比之下，计算机视觉中的运动传感是关于解释的；它通过分析图像序列来辨别和理解运动，从而更深入地了解视觉数据。
在这个项目中，我们将在Raspberry Pi 4上使用OpenCV来处理视频帧。对于边缘检测，我们将在帧的灰度版本上使用Canny 边缘检测方法。为了识别运动，我们将计算连续灰度帧之间的均方误差（MSE）；MSE的显着变化表明运动。此设置提供了视频源中边缘和潜在运动的实时视觉表示。
所需组件：
树莓派相机连接 Raspberry Pi 相机是由 Raspberry Pi 基金会开发的外围设备，可与其系列 Raspberry Pi 单板计算机一起使用。相机模块提供了一种向 Raspberry Pi 项目添加视频/照片功能的方法。
对于这个项目，我们可以使用5 兆像素的Raspberry Pi 相机。
只需使用相机连接器将相机模块连接到 Raspberry Pi 4 板即可。
要使用相机，您需要先启用相机模块。sudo raspi-config通过在终端中键入内容来打开 Raspberry Pi 配置工具。导航至Interfacing Options&gt;Camera并启用它。
什么是均方误差 (MSE) 和 Canny 边缘检测方法？ 该项目使用Canny 边缘检测方法进行边缘检测，并使用均方误差 (MSE) 算法进行运动检测。这些步骤共同使 Canny 算法能够稳健地检测图像中的边缘。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/241bc9a4fab475063578ee84857ce351/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc4f427da2fbd515b64d13347b5dd7ed/" rel="bookmark">
			类图到底该如何画
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、前言
二、内容
2.1、什么是类图？
2.2、类图的组成：
2.3、类之间的关系：
2.4、绘制类图的格式：
2.5、至于为什么有了接口还要增加一层抽象类？
2.6、接口与类的设计原则
接口：接口隔离原则
类：单一职责原则
三、总结
一、前言 本文将详细介绍类图应该如何画，如何画好一张类图。
二、内容 2.1、什么是类图？ 要学习如何画类图的话那么我们首先要明确一下什么是类图？
顾名思义，类图是显示了模型的静态结构，特别是模型中存在的类、类的内部结构以及它们与其他类的关系等。类图不显示暂时性的信息。类图是面向对象建模的主要组成部分。它既用于应用程序的系统分类的一般概念建模，也用于详细建模，将模型转换成编程代码。
2.2、类图的组成： 类名、属性、方法
2.3、类之间的关系： 继承、实现、依赖、关联、组合、聚合
2.4、绘制类图的格式： 类：
接口： 抽象类： 需要注意的地方：
接口一定有 &lt;&lt;interface&gt;&gt; 的标识，接口中的方法必须斜体（默认都是抽象方法）抽象类名和抽象方法必须斜体，非抽象方法不斜体 注意访问控制符、返回值、参数等格式的正确性类中属性、方法要描述全面 类中使用注解或者new的方式声明的其他类的成员变量也是该类的属性： 原因一：对此类本身而言，此类的类内结构包括属性（成员变量）和方法（成员方法）原因二：对类间关系而言，虽然这个类与其他类（这个类声明其他类对象）之间有关联（或其他关系），但是这个关系是体现在类间的。 为使程序灵活、可扩展、可复用的角度出发，将程序service层架构设为3层，接口 -&gt; 抽象类 -&gt; 实现类。
2.5、至于为什么有了接口还要增加一层抽象类？ 观点1：抽象类是接口与实现类之间的桥梁。
让抽象类去实现接口，而不是每个实现类去实现接口，实现类一致的行为（或者说大部分一致的行为）在抽象类中进行实现，而不一致的行为（或者一小部分不一致的行为），在抽象类中写成抽象方法，让子类去重写，减少子类重写接口所有方法的负担。
2.6、接口与类的设计原则 接口：接口隔离原则 接口应该尽量细化，一个接口对应一个功能模块。使接口轻便灵活，而不是臃肿不堪。要求“尽量使用多个专门的接口”，专门的接口是指提供给每个模块的都应该是单一接口（即每个模块对应一个接口），而不是建立一个庞大臃肿的接口来容纳所有客户端访问。
类：单一职责原则 代码中的具体体现，一个类中只能有一个 public 方法，而其他 private 方法都是为这一个 public 方法服务。也就是，对于外界来说，只能有一个方法仅供外界访问。
三、总结 接口和抽象类的区别？这个问题，相信大家从语法角度都能说上来1、2、3，我们学习一个技术不能只光会用就完了，要从思想上去总结统一：接口是自上向下的，因为它不用去管谁要去实现的，它是一种规范，是一种约束，但凡实现了该接口的类，从方法定义上去进行约束，而抽象类是自下向上的，抽象抽象，就是在几个不同的东西中找出相同的东西来，比如：狗、猫、老鼠等，这些都是动物，它们都有皮肤颜色这个属性，这些东西是有了狗、有了猫、有了老鼠之后抽象出来动物这么一个东西，是先有下层后有的上层，所以说抽象类是自下向上的；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5df03fdbab57a57de478b72978a72cc7/" rel="bookmark">
			vxe-table 鼠标滑动选择多行,鼠标区域选中批量操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该功能存在bug哦，移步我的新博客:vxe-table 鼠标滑动选择多行,鼠标区域选中批量操作[2]_wanghanlu_的博客-CSDN博客
在看vxe-table 文档时,发现一个功能,鼠标区域选中,觉得这个功能很好。
但是仔细发现,这个功能不是免费的。我就想想,为啥不能自己实现呢。
下面给你看看我的最终效果： 可复制、粘贴、数值自增。
实现步骤 &lt;template&gt; //其他相关配置省略 这里的ref名称需要注意 &lt;vxe-grid ref='xGrid' v-bind="gridOptions" @cell-click="tableCellClick"&gt; &lt;/vxe-grid&gt; &lt;/template&gt; &lt;style scoped&gt; .vxe-grid{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none} .td-mouse-active{background-color:rgb(155,204,255) !important} &lt;/style&gt; JS:
&lt;script&gt; export default { data() { return { gridOptions: { size: "small", border: "full", //斑马纹 stripe: true, }, //鼠标区域选中 selectedCells: [], // 选中的单元格数组 isSelecting: false, // 是否正在进行选择操作 selectionStart: { rowIndex: -1, cellIndex: -1 }, // 选择操作起始单元格位置 selectionEnd: { rowIndex: -1, cellIndex: -1 }, // 选择操作结束单元格位置 } }, mounted() { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5df03fdbab57a57de478b72978a72cc7/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/61/">«</a>
	<span class="pagination__item pagination__item--current">62/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/63/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>