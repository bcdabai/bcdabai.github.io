<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7844ad9b4e5cc220b0181b3e13b1977b/" rel="bookmark">
			【nRF24L01 与 Arduino 连接实现无线通信】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nRF24L01 与 Arduino 连接实现无线通信 前言nRF24L01 模块示例 1 - nRF24L01 Arduino 接口示例 2 - nRF24L01 Arduino 接口源代码和库文件 前言 在本教程中，您将借助两个示例了解 nRF24L01 Arduino 接口。在第一个示例中，我们将发送“Hello world”和一个命令来闪烁连接到另一个 Arduino 的 LED。在第二个示例中，我们将进行双向控制，并从第一个 Arduino 发送命令以在第二个 Arduino 上闪烁 LED，然后我们将从第二个 Arduino 发送命令以在第一个 Arduino 上闪烁 LED。
nRF24L01 模块 nFR24L01 是一个收发器模块，这意味着它可以发送和接收数据。这些模块非常便宜，体积更小，规格也很多。这些模块的一些规格如下：
传输过程中的功耗在12mA左右，比LED还要小。
它可以以 250Kbps 到 2 Mbps 的波特率运行。
如果在开放空间使用并带有天线，其范围可达 100 米。
它可以同时发送和接收数据。
每个模块最多可与 6 个其他模块通信。
它使用 2.4 GHz 频段。
它可以以 1 MB 的传输速率发送 1 到 25 字节的原始数据。
它有 125 个不同的频道。
nRF24L01 模块通过 SPI 通信与 Arduino 协同工作。模块的管脚如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7844ad9b4e5cc220b0181b3e13b1977b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26ee002b91cd5f1aaf6f5e75554123c5/" rel="bookmark">
			MLPClassifier的参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 MLPClassifier是一个多层感知机分类器。它的参数有：
hidden_layer_sizes：一个整数或者整数元组，表示隐藏层的数量和每层的神经元数量。默认值是(100,)。activation：激活函数的类型。可以是“identity”、“logistic”、“tanh”或者“relu”。默认值是“relu”。solver：优化算法的类型。可以是“lbfgs”、“sgd”或者“adam”。默认值是“adam”。alpha：L2正则化系数。默认值是0.0001。batch_size：在SGD算法中，每个批次中包含的样本数量。默认值是“auto”，表示自动根 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7bc35a9c76a647cc8bc214944ba8096/" rel="bookmark">
			更多丰富内容，请转移至博主的个人博客——SeaDream乄造梦
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2022年12月20号，本人创建了自己的个人博客https://yahuihui.cn
以后相关技术文章和生活文章就在我的个人博客中来更新，个人博客地址
SeaDream乄造梦
欢迎大家和我交换友链，顺手的话对my地址进行点赞收藏呦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2d8902d8fa09435da2f3fdece2c14aa/" rel="bookmark">
			【SAP Abap】SAP Eclipse ADT开发环境配置与应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SAP Eclipse ADT开发环境配置与应用 1、确定Eclipse版本2、下载Eclipse3、Eclipse 安装组件4、连接SAP服务器5、ABAP开发6、CDS开发 1、确定Eclipse版本 下载前，首选参考SAP开发工具页面，根据自己的开发需求，选择合适的Eclipse版本
这里我主要做SAP ABAP、BW以及HANA数据库开发，因此选定Eclipse 2022-03版本。
2、下载Eclipse 去Eclipse官网下载，首页如下，目前最新版本为 Eclipse 2022-06，我们点击“Download Packages”，前往下载历史版本 Eclipse 2022-03
选择windows版本下载，下载后安装（安装过程省略）。
3、Eclipse 安装组件 （1）Eclipse添加软件源
（2）下载所需的组件
4、连接SAP服务器 （1）切换ABAP开发视图
（2）连接SAP服务器
参考SAP GUI设置进行填写
连接成功，本地开发对象位于Local Objects包中，其他开发包位于System Library目录中。
5、ABAP开发 展开相应的包，查看 Programs 下面的程序，通过双击即可打开代码编辑页面。
6、CDS开发 展开相应的包，查看 Core Data Services 下面的程序，通过双击即可打开代码编辑页面。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/415115ab2a330e7141c26b6cb680843d/" rel="bookmark">
			Linux之间ssh密钥登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux之间ssh密钥登录 由于工作需要：服务器A免密登录服务器B
那么就需要再A上生成私钥与公钥，再将A的公钥加入到B的授权列表就可以实现A免密登录B
进入密钥文件夹 cd ~/.ssh 生成密钥 ssh-keygen -t rsa //三次回车 [root@localhost .ssh]# ssh-keygen -t rsa Generating public/private rsa key pair. Enter file in which to save the key (/root/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /root/.ssh/id_rsa. Your public key has been saved in /root/.ssh/id_rsa.pub. The key fingerprint is: SHA256:kglPELNYVTyqMGu1ROSqXbsZ1pqzU root@localhost.localdomain The key's randomart image is: +---[RSA 2048]----+ | *+oo+.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/415115ab2a330e7141c26b6cb680843d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d95f549e4d8a7c740da0811460d1a81b/" rel="bookmark">
			【Java案例】小明可以买什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		案例介绍：
编写一个智能购物计算小程序，在一家商店有书本、铅笔、橡皮、可乐、零食五种商品，商品价格如下表所示。
假如小明带了20元，且必须购买一本书，剩余的钱还可以购买哪种商品？可以购买几件？购买完后又能剩余多少钱？
运行结果：
完整代码：
import java.util.Scanner; public class shopping { public static void main(String[] args){ int money = 20; int book = 12;//书本 int pencil = 1;//铅笔 int rubber = 2;//橡皮 int cola = 3;//可乐 int snacks = 5;//零食 System.out.println("书本的价格为"+book+"元，您总共有"+money+"元"); System.out.println("1.铅笔的价格为："+pencil+"元"); System.out.println("2.橡皮的价格为："+rubber+"元"); System.out.println("3.可乐的价格为："+cola+"元"); System.out.println("4.零食的价格为："+snacks+"元"); System.out.print("请输入其他需要购买商品的序列号："); int surplus = money-book;//购买一本书后，小明剩余的钱 Scanner scanner = new Scanner(System.in); int id = scanner.nextInt(); switch (id) { case 1: System.out.println("购买完书本后还可以购买铅笔"+surplus/pencil+"支，还剩"+surplus%pencil+"元"); break; case 2: System.out.println("购买完书本后还可以购买橡皮"+surplus/rubber+"块，还剩"+surplus%rubber+"元"); break; case 3: System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d95f549e4d8a7c740da0811460d1a81b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12ea64a9cb003937b7471b8a191d4118/" rel="bookmark">
			el-input输入校验不能为空格，不能输入全部为空的内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		应用场景： 输入框的校验太常见了，基本上常见的为：不能为空，不能输入空格，和不能输入全部为空的内容。这里对这个进行记录。
详细开发： 针对三种情况进行分别展示：
rules: { ResearchNO: [ { required: true, message: '请输入项目代码', trigger: 'blur' }, { required: true, transform: (value) =&gt; value &amp;&amp; value.trim(), message: '项目代码不能全部为空', trigger: 'blur' } ], Name: [ //输入为空 { required: true, message: '请输入项目名称', trigger: 'blur' }, { min: 1, max: 50, message: '长度在 1 到 50 个字符', trigger: 'blur' }, //不能全部输入空格 { required: true, transform: (value) =&gt; value &amp;&amp; value.trim(), message: '项目名称不能全部为空', trigger: 'blur' } ] }, 不能输入全部空格，主要是这里起作用：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12ea64a9cb003937b7471b8a191d4118/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/714535645b75a962245a1bbb00f28375/" rel="bookmark">
			【C&#43;&#43;高阶数据结构】B树、B&#43;树、B*树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🏆个人主页：企鹅不叫的博客
​ 🌈专栏
C语言初阶和进阶C项目Leetcode刷题初阶数据结构与算法C++初阶和进阶《深入理解计算机操作系统》《高质量C/C++编程》Linux ⭐️ 博主码云gitee链接：代码仓库地址
⚡若有帮助可以【关注+点赞+收藏】，大家一起进步！
💙系列文章💙 【C++高阶数据结构】并查集
【C++高阶数据结构】图
【C++高阶数据结构】LRU
文章目录 💙系列文章💙💎一、概念🏆1.优点🏆2.B树规则 💎二、B树插入🏆1.插入过程🏆2.代码实现 💎三、B+树🏆1.概念🏆2.分裂过程 💎四、B*树🏆1.概念 💎五、B树系类应用🏆1.MyISAM🏆2.InnoDB 💎一、概念 🏆1.优点 B树适合外查找，当数据量很大，无法一次全部都放进内存的话，那就只能存在磁盘上，B树本质是一个多叉搜索树。
从树的根开始读取的话，我们需要读取树的高度次磁盘IO，多次进行磁盘读取，就会非常缓慢。每次要读取新的数据，要去定位这个过程是非常缓慢。
在平衡搜索树的基础上寻找优化方法
1.压缩高度，二叉变多插
2.一个结点里面存多行的值，也就是一个结点里面有多个关键字以及映射的值
🏆2.B树规则 一棵m阶(m&gt;2)的B树，是一棵平衡的M路平衡搜索树，可以是空树或者满足一下性质：
根节点至少有两个孩子每个分支节点都包含k-1个关键字和k个孩子，其中ceil(m/2) ≤ k ≤ m ceil是向上取整函数每个叶子节点都包含k-1个关键字，其中 ceil(m/2) ≤ k ≤ m所有的叶子节点都在同一层每个节点中的关键字从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域划分每个结点的结构为：（n，A0，K1，A1，K2，A2，… ，Kn，An）其中，Ki(1≤i≤n)为关键字，且Ki&lt;Ki+1(1≤i≤n-1)。Ai(0≤i≤n)为指向子树根结点的指针。且Ai所指子树所有结点中的关键字均小于Ki+1。n为结点中关键字的个数，满足ceil(m/2)-1≤n≤m-1。 假设现在我们的m是10
按照上面的规则，也就是说我们
最少需要4个关键字和5个孩子
最多需要9个关键字和10个孩子
这个节点中的关键字按照从小到大的顺序进行排列
（n，A0，K1，A1，K2，A2，… ，Kn，An）
K1&lt;K2&lt;K3&lt;…&lt;Kn
A0节点中的值&lt;K1&lt;A1节点中的值&lt;K2&lt;……也就是说，如果比K1小，我们就在A0节点中继续寻找，如果比K2小比K1大，我们就在A1节点中进行查找。
B树本质是一个多叉搜索树。
💎二、B树插入 🏆1.插入过程 假设M=3。
也就是最少存1个关键字，最多两个关键字，最少2个孩子，最多3个孩子
这里是我们的数据：{53, 139, 75, 49, 145, 36, 101}
首先我们将53，139和75插入
（我们这里多开一个空间，便于我们的插入。否则我们的第m个元素插入的时候，也就是我们刚刚好越界的时候，我们就不知道插入在哪里，我们可能还要分情况进行讨论，这样就非常麻烦。多开辟一个空间的话，我们就可以先将这第M个元素先插进去，然后再进行分裂操作，就省去了分类讨论）
关键字的数量等于M，那就是满了，满了就分裂，分裂出一个兄弟（兄弟里面最初始没有值），然后分一半的值给兄弟
插入49，145
再插入36的时候，我们左边的结点1就满了，我们又需要进行分裂
49是我们的中位数。
所以我们将49放入我们的父节点中
（我们的关键字要比我们孩子的数量少一个。现在我们有三个孩子和两个关键字）
最右边的子树满了，进行持续分裂
B树天然平衡
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/714535645b75a962245a1bbb00f28375/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad4fbee9722ffd1e2d33cf3de4ac17e2/" rel="bookmark">
			社区发现系列02-算法介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hello, 大家好，欢迎来到阿君聊风控，我是阿君（一名有7年互金和电商风控经验的算法工程师）。 在上篇文章https://blog.csdn.net/u010569893/article/details/128565829?spm=1001.2014.3001.5502 中我们了解到可以用社区发现技术来对图进行划分，进而挖掘到作弊团伙。那么常用的社区发现算法有哪些呢？今天我们就来聊一聊常用的社区发现算法和原理，以及通过实验来来对比不同社区发现算法划分的效果 一、社区发现算法 网络图内部连接比较紧密的节点子集合对应的子图叫做社区（community），各社区节点集合彼此没有交集的称为非重叠型（disjoint）社区，有交集的称为重叠型（overlapping）社区。对给定的网络图寻找其社区结构的过程称为“社区发现”。大体上看，社区发现的过程就是一种聚类的过程。 1.1 LPA标签传播算法 1、基本思想：
标签传播算法是不重叠社区发现的经典算法，其基本思想是：将一个节点的邻居节点的标签中数量最多的标签作为该节点自身的标签。给每个节点添加标签（label）以代表它所属的社区，并通过标签的“传播”形成同一标签的“社区”结构。
给每个节点添加标签（label）以代表它所属的社区，并通过标签的“传播”形成同一标签的“社区”结构。一个节点的标签取决于它邻居节点的标签：假设节点z的邻居节点有z1至zk，那么哪个社区包含z的邻居节点最多z就属于那个社区（或者说z的邻居中包含哪个社区的标签最多，z就属于哪个社区）。优点是收敛周期短，无需任何先验参数(不需事先指定社区个数和大小)，算法执行过程中不需要计算任何社区指标。
时间复杂度接近线性：对顶点分配标签的复杂度为O(n)，每次迭代时间为O( m)，找出所有社区的复杂度为O (n +m)，但迭代次数难以估计
2、传播过程： 1)初始时，给每个节点一个唯一的标签； 2)每个节点使用其邻居节点的标签中最多的标签来更新自身的标签。 3)反复执行步骤2)，直到每个节点的标签都不再发生变化为止。 一次迭代过程中一个节点标签的更新可以分为同步和异步两种。所谓同步更新，即节点z在第t次迭代的label依据于它的邻居节点在第t-1次迭代时所得的label；异步更新，即节点z在第t次迭代的label依据于第t次迭代已经更新过label的节点和第t次迭代未更新过label的节点在第t-1次迭代时的label。
注： 1、迭代次数设定一个阈值，可以防止过度运算； 2、对于二分图等网络结构，同步更新会引起震荡； //3、类似（“强”社区&gt;）定义的结构（该社区&gt;=）； 4、每个顶点在初始的时候赋予唯一的标签，即“重要性”相同，而迭代过程又采用随机序列，会导致同一初始状态不同结果甚至巨型社区的出现； 5、如果能预测“社区中心”点，能有效提高社区发现的准确度，大幅提高效率； 6、同一节点的邻居节点的标签可能存在多种社区最大数目相同的情况，取“随机”一个作为其标签
3、算法改进思路：初始化或传播改进 1)给节点或边添加权重（势函数、模块密度优化、LeaderRank值、局部拓扑信息的相似度、标签从属系数等），信息熵等描述节点的传播优先度，进而初步确定社区中心点以提高社区划分的精度； 2）标签初始化改进，如提取一些较为紧密的子结构来作为标签传播的初始标签（非重叠最小极大团提取算法 orz。。。）或通过初始社区划分算法先确定社区的雏形再进行传播。 3）标签随机选择改进，将1）中的权值和节点邻接点的度数等作为参考因素，对标签更新过程进行修正。
1)在社区中寻找不重叠三角形作为起始簇的雏形，以提高算法结果的稳定性和运行效率； 2)添加标签熵属性，在迭代过程中不采用随机序列，而是根据每个节点的标签熵来排序序列； 3)在2）的基础上，为了不完全消除标签传播算法的随机性，将排序好的队列平均分成三个部分，在每个部分内，节点进行随机排列。 4)对于同一节点的邻居节点的标签可能存在多种社区最大数目相同的情况，不使用随机方法，而是分析该节点的邻节点的邻节点集标签分布情况来决定该节点的标签
5)在社区中寻找以度最大的若干节点为中心的“雪花型”结构作为起始簇的雏形 1.2 Louvain算法（基于模块度的层次型社区发现算法） 1、 算法的思想： 1）初始时，将图中的每个节点看作是一个独立的社区，社区的数量跟节点的数量相同 2）对每个节点i， 分别尝试将该节点划分到其邻居节点所在的社区，根据下面的公式（3）计算划分前和划分后模块度的变化delta(Q) ，也就是模块度增益, 并记录模块度增益最大的那个邻居节点，如果最大模块度增益&gt;0, 则将即节点i分配到那个邻居节点中，否则保持不变 3）重复2），直到所有节点的所属社区不再变化 4）对图进行压缩，将所有的子图压缩成一个超节点，社区内节点之间的边的权重转化为超节点的权重，社区间边的权重转化为超节点的权重 5）重复1）直到整个图的模块度不再发生变化 从流程看，该算法可以产生层次性的社区结构，这样分层的结构是每个网络的自然属性，使研究员得意深入了解某个社区的内部结构和形成机制。 其中计算最耗时的是最底层的社区划分，节点按社区压缩后，将大大缩减节点和边的数量，并且计算节点i的分配只跟节点i的邻居节点有关，因此计算很快，是一种高效的层次社区发现算法，是一种迭代的2层社区发现算法 该算法目前被认为是快速、准确，被认为是效果和性能最优的社区发现算法之一；该算法对图的大小几乎没有上限要求，并且能够在迭代几轮后快速收敛，这为处理拥有百万节点以上的大型社交网络的社区发现提供了可能 2、 模块度和模块度的增益 参考：http://www.yalewoo.com/modularity_community_detection.html 1）模块度的定义： 可以理解为：社区内部变得权重减去所有与社区节点相连边的权重和的平方，对无向图更好理解，即社区内部边的度数减去社区内节点的总度数。 2）模块度的增益 模块度增益 上式可以理解为： 括号内第一项ki,in表示实际节点i（或社区A）与要移入社区B之间的连接边的权重之和, tot ki/m 则为随机情况下节点i（或社区A）在总的加权度为 tot ki的情况下与当前graph上任意 的节点或社区连接的边的权重的期望. 第一项若比第二项大则说明节点i（或社区A）与该社 区B的连接程度是具有显著的意义的, 那么便加入到该社区, 反之则不加入。 模块度是评估一个社区网络划分好坏的度量方法，可以看出，它是一种相对性的指标。 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad4fbee9722ffd1e2d33cf3de4ac17e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0665ca5c79f956172ff2832066a978f3/" rel="bookmark">
			c&#43;&#43; std::funciona代替函数指针——结合std::bind
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、介绍std::function std::function是函数模板类（是一个类）。包含在#include &lt;functional&gt; 中。以前没有这个类的时候，我们在想定义一个回调函数指针，非常的麻烦。我们通常这样的定义：
typedef void（*ptr）（int，int）// 这里的ptr就是一个函数指针 而使用了std::function这个类的时候，我们可以这样使用，来替换函数指针。例如
std::function&lt;void(int ,int)&gt; func; std::function 是一种通用、多态的函数封装。它的实例能存储、复制及调用任何可调用 (Callable) 目标——函数、 lambda 表达式、 bind 表达式或其他函数对象，还有指向成员函数指针和指向数据成员指针。
它也是对 C++ 中现有的可调用实体的一种类型安全的包裹（相对来说，函数指针的调用不是类型安全的）
二、与std::bind结合 可以将std::bind函数看作一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。
std::bind将可调用对象与其参数一起进行绑定，绑定后的结果可以使用std::function保存。std::bind主要有以下两个作用：
将可调用对象和其参数绑定成一个仿函数；只绑定部分参数，减少可调用对象传入的参数。 1、std::bind绑定普通函数
double my_divide(double x, double y) { return x / y; }; int main(int argc, char* argv[]) { auto fn_half = std::bind(my_divide, std::placeholders::_1, 2); std::cout &lt;&lt; fn_half(10) &lt;&lt; '\n'; // 输出为5 return 0; } 2、std::bind绑定一个成员函数
struct Foo { void print_sum(int n1, int n2) { std::cout &lt;&lt; n1+n2 &lt;&lt; '\n'; } int data = 10; }; int main() { Foo foo; auto f = std::bind(&amp;Foo::print_sum, &amp;foo, 95, std::placeholders::_1); f(5); // 100 } 三、实例 #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;list&gt; #include &lt;map&gt; #include &lt;set&gt; #include &lt;string&gt; #include &lt;algorithm&gt; #include &lt;functional&gt; #include &lt;memory&gt; using namespace std; //声明一个模板 typedef std::function&lt;int(int)&gt; Functional; //normal function int TestFunc(int a) { return a; } //lambda expression auto lambda = [](int a)-&gt;int{return a;}; //functor仿函数 class Functor { public: int operator() (int a) { return a; } }; //类的成员函数和类的静态成员函数 class CTest { public: int Func(int a) { return a; } static int SFunc(int a) { return a; } }; int main(int argc, char* argv[]) { //封装普通函数 Functional obj = TestFunc; int res = obj(0); cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0665ca5c79f956172ff2832066a978f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d7ab2d3fc69ee7463643d4f3b2b9461/" rel="bookmark">
			filter、interceptor、controllerAdvice、aspect执行顺序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、filter、interceptor、controllerAdevice、aspect
1、filter，这是java的过滤器，和框架无关的，是所有过滤组件中最外层的，从粒度来说是最大的。
配置方式，有直接实现Filter+@component，@Bean+@configuration（第三方的filter）
2、interceptor，spring框架的拦截器
配置方式，@configuration+继承WebMvcConfigurerAdapter或WebMvcConfigurationSupport类添加过滤器。
继承WebMvcConfigurationSupport不需要声明@EnableWebMvc注解，继承WebMvcConfigurerAdapter需要 @see org.springframework.web.servlet.config.annotation.EnableWebMvc
@RestController的类和带@ResponseBody的方法在被调用后response会直接写入输出流，在postHandle和afterCompletion这两个方法执行之前就已经把数据返回，导致这两个方法里面的response根本获取不到响应数据
拦截器可以分为两种类型：
一是WebMVC：负责拦截请求，类似于过滤器，对用户的请求在Controller接收前进行处理，在Controller处理完成后加工结果等。使用时需实现HandlerInterceptor接口。
二是AOP：拦截指定类型的方法，通过动态代理模式实现，可以在方法的调用前和调用后添加功能处理。使用时需要实现MethodInterceptor接口。
实现MethodInterceptor拦截器大致也分为两种：
一种是实现MethodInterceptor接口
另一种利用Aspect的注解或配置。
3、aspect，可以自定义要切入的类甚至再细的方法，粒度最小。加个注解用效果更佳。
4、controllerAdvice，是controller的增强，和ExceptionHandler一起用来做全局异常。也可以配合ResponseBodyAdvice接口来对@ResponseBody的返回数据进行加工再返回(同理还有RequestBodyAdvice-&gt; @RequestBody等)
上图给出了filter、interceptor、controllerAdvice、aspect、controller执行顺序，即请求接入的时候，请求会先到达filter -&gt; interceptor -&gt; controllerAdvice -&gt; aspect -&gt; controller
二、每一类有多个时的执行顺序
多个filter内部如何控制执行顺序呢
使用或者Order接口
1.web.xml配置： 谁定义在上边，谁先执行
2.Order注解配置：Order(1)、Order(2) ，值小的先执行
3.Ordered接口
多个interceptor内部如何控制执行顺序呢
1.每个Interceptor 的调用会依据它的声明顺序依次执行
如以下例子：
@Configuration public class WebAppConfig extends WebMvcConfigurerAdapter { @Override public void addInterceptors(InterceptorRegistry registry) { super.addInterceptors(registry); //请求拦截 registry.addInterceptor(new MyInterceptor2()).addPathPatterns("/**").excludePathPatterns("/loginfrom","/login"); registry.addInterceptor(new MyInterceptor()).addPathPatterns("/**").excludePathPatterns("/loginfrom","/login"); } } 2.使用InterceptorRegistrationd的Order方法，值小的先执行
@Configuration public class WebAppConfig extends WebMvcConfigurerAdapter { @Override public void addInterceptors(InterceptorRegistry registry) { super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d7ab2d3fc69ee7463643d4f3b2b9461/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bfad570daf416b21a30d795dea7ca7f/" rel="bookmark">
			QTextDocument
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、描述 此类用来储存结构化的富文本文档。
二、类型成员 1、enum QTextDocument::FindFlag：此枚举描述查找函数可用的选项。这些选项可以用“|”组合：
FindBackward：向后搜索。FindCaseSensitive：不区分大小写。FindWholeWords：查找仅匹配完整的单词。 2、enum QTextDocument::MetaInformation：此枚举描述了可以添加到文档中的不同类型的元信息。
DocumentTitle：文档的标题。DocumentUrl：文档的url。loadResource() 函数在加载相关资源时使用此url作为基础。CssMedia：此值用于在调用 setHtml() 时从指定的CSS样式表中选择相应的“@media”规则。 3、enum QTextDocument::ResourceType：此枚举描述可由 loadResource() 函数或QTextBrowser::setSource() 加载的资源类型。
UnknownResource：未加载资源，或资源类型未知。HtmlResource：资源包含HTML。ImageResource：资源包含图像数据。StyleSheetResource：资源包含CSS。MarkdownResource：资源包含Markdown。UserResource：用户定义的资源类型的第一个可用值。 三、属性成员 1、baseUrl : QUrl
用于解析文档中相对资源URL的基URL。
资源URL被解析为与基URL的目标位于同一目录中，即着路径中最后一个“/”之后的任何部分都将被忽略。
2、blockCount : const int
文档中文本块的数量。
此属性的值在具有表格（QTextTable）或框架（QTextFrame）的文档中未定义。
默认情况下，如果已定义，则值为1。
3、defaultFont : QFont
用于显示文档文本的默认字体。
4、defaultStyleSheet : QString
默认样式表，应用于插入到文档中的所有新HTML格式文本（使用 setHtml() 或 QTextCursor:：insertHtml() 插入）。
更改默认样式表不会对文档的现有内容产生任何影响。
5、defaultTextOption : QTextOption
文档中所有 QTextLayout 的默认文本选项。
创建 QTextBlocks 时，将在其 QTextLayout 上设置 defaultTextOption。
这可用来设置文档的全局属性，例如默认换行模式。
6、documentMargin : qreal
文档周围的边距。默认值为4。
7、indentWidth : qreal
文本列表（QTextList）和文本块（QTextBlock）缩进的宽度。默认为40。
8、layoutEnabled : bool
每次更改后 QTextDocument 是否应重新计算布局。默认为 true。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bfad570daf416b21a30d795dea7ca7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d996a2fbd1f359cf89d0f0a8e1e3fac/" rel="bookmark">
			Python写猜数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		猜数字游戏 Python 猜数字和猜词小游戏
from random import randint # 导入可以随机生成数的库 def guess_number(start = 1 , end = 10 , times = 3): # 定义函数，def是关键字，guess_number是函数名称 # start，end，times是带默认值的形参，若调用函数时没有传递实参，就用默认值 number = randint(start , end) # 生成指定范围的随机数，也就是要猜的数 # 用for循环控制最大猜测次数，如果次数用完仍未猜对就结束循环 for i in range(times): # 关键字else的用法1：value1 if condition else value2，condition值为真取value1，否则取value2 prompt = '开始猜吧，' if i==0 else '再猜一次' # f-字符串，把大括号内的表达式替换为对应的计算结果 prompt = f'剩余{times - i}次，{prompt}[{start},{end}]范围的数是什么：' # 接收用户输入，返回字符串 value = input(prompt) try: # 异常处理结构，把可能会出错的代码放在try块中 # 尝试把字符串转换为整数 value = int(value) except: print('必须输入整数。',end = '') else: if value == number: print('恭喜，猜对了。') return True elif value &gt; number: print('猜大了。') else: print('猜小了。') else: print('次数用完，没有猜对。') return False total , win , times = 0 , 0 , 3 while True: # 玩游戏的次数 total = total + 1 start = randint(1 , 100) end = randint(start , start + 30) if guess_number(start , end , times = times): win = win + 1 times = times + 1 else: times = times - 1 if times &lt;= 0: print('最大猜测次数已经变成0了，不允许再玩了。') break # 必须输入Y或者N while True: flag = input('还想再来一局吗？(Y/N)：').
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d996a2fbd1f359cf89d0f0a8e1e3fac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efca11a5aa24b3f66e8b1eb61ac46727/" rel="bookmark">
			CNN 一般训练跟测试集的比例是 多少
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般来说，CNN 在训练和测试时会将数据分为训练集和测试集两部分。具体来说，通常将数据分为 80% 的训练集和 20% 的测试集。但这并不是绝对的，可能会有一些变化，也可能会根据具体情况进行调整。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e7cdf2f220039b0c8ad1b73c198e8b7/" rel="bookmark">
			MyBatis 万字长文：从入门到动态SQL超详细
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 前言2. 创建项目3. 添加框架支持4. 建库5. 配置数据库连接信息和 XML 文件路径5.1 创建 Java 类5.2 Java 接口5.3 XML 文件 6. 查询6.1 不带参数的查询6.2 单元测试6.3 带参数的查询 7. 修改8. 增加8.1 将对象插入表中8.2 获取自增主键 9. 删除10. 数据库字段和类属性名字不一致的情况10.1 查询10.2 resultMap 11. 排序查询11.1 #{} 和 ${} 的区别 12. 模糊匹配13. 联合查询14. 动态 SQL14.1 if 标签14.2 trim 标签14.3 where 标签14.4 set 标签14.5 foreach 标签 15. 全代码 1. 前言 MyBatis是一个基于JDBC的半 ORM 持久化框架, 能通过 注解 或者 XML(主流方式) 和 映射原生类型, 接口和 java 的POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e7cdf2f220039b0c8ad1b73c198e8b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/597d98cbf18c25935cea63084d5cb64b/" rel="bookmark">
			基于java的简单学生宿舍管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本程序是简单的JDBC加上一些java中JFrame的框图（布局真的丑），原谅我JFrame学的不好，布局实在弄不来，大家撮合着看吧！
我使用的是
MySQL来实现的。工具使用（navicat for MySql）数据库中包含有七张表，分别是：user(用户管理表)、dorm(宿舍基本信息表)、student(学生信息表)、repair(房屋报修信息表)、register(外来人员登记表)、charge(水电费管理表)、checkinfo(卫生检查表)
登陆界面：
注册界面
用户界面-增加宿舍
此功能模块主要是对宿舍检查信息的添加和查询。
用户界面-查询宿舍
其他部分的图片我就不一一展示了！ 代码部分实在太多（部分有些累赘，封装性不是很好！）这里我就说一下我的整体思路吧！
整个流程图就是这样子;
这个系统大家只要能够连接到自己的数据库，平且会一些java中数据库的知识和一些JFrame就可以很快做出来！
整体上是不难的！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/256f10c8af84384686d1e54f571bb6c6/" rel="bookmark">
			ubuntu22.04安装libudev-dev
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ubuntu22.04安装libudev-dev
sudo apt-get install -y libudev-dev 若出现如下问题：
正在读取软件包列表... 完成 正在分析软件包的依赖关系树... 完成 正在读取状态信息... 完成 有一些软件包无法被安装。如果您用的是 unstable 发行版，这也许是 因为系统无法达到您要求的状态造成的。该版本中可能会有一些您需要的软件 包尚未被创建或是它们已被从新到(Incoming)目录移出。 下列信息可能会对解决问题有所帮助： 下列软件包有未满足的依赖关系： udev : 破坏: systemd (&lt; 249.11-0ubuntu3.6) 破坏: systemd:i386 (&lt; 249.11-0ubuntu3.6) 推荐: systemd-hwe-hwdb 但是它将不会被安装 E: 错误，pkgProblemResolver::Resolve 发生故障，这可能是有软件包被要求保持现状的缘故。 可用码源安装：
参考ubuntu20.04源码编译安装libudev：
1.源码下载
libudev源码：https://download.csdn.net/download/weixin_42736510/86438113
2.源码编译
./autogen.sh ./configure CFLAGS='-g -O1' --prefix=/usr --sysconfdir=/etc --libdir=/usr/lib --with-selinux --enable-gtk-doc --libexecdir=/usr/lib --with-systemdsystemunitdir=/usr/lib/systemd/system 若提示
./autogen.sh: autoreconf: not found
执行
sudo apt-get install -y autoconf automake libtool
当configure 配置出现如下问题：
1- No package 'libkmod' found 2- No package 'blkid' found 3- No package 'gobject-2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/256f10c8af84384686d1e54f571bb6c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/020955908af285be7d871599797060fd/" rel="bookmark">
			Qt无边框窗口拖动算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用Qt做桌面软件时，各个系统的窗口标题不统一，也不好看，所以就隐藏了自己写标题栏，但是隐藏系统标题栏后，就不能再拖动窗口了，所以得自己写：
// 重写这几个函数 void mousePressEvent(QMouseEvent* event); void mouseMoveEvent(QMouseEvent* event); void mouseReleaseEvent(QMouseEvent* event); 然后需要一个判断鼠标是否按住的变量，一个变量保存鼠标按下时的鼠标坐标减去窗口坐标差值
bool m_mousMove; QPoint m_Difference; 然后写点代码
void DialogObj::mousePressEvent(QMouseEvent* event) { if (event-&gt;button() == Qt::LeftButton) { DEBUG() &lt;&lt; "this-&gt;m_mousMove = true;"; this-&gt;m_mousMove = true; // 按下时保存差值 this-&gt;m_Difference = event-&gt;globalPos() - this-&gt;pos(); } } // 移动鼠标时随时改变窗口坐标 void DialogObj::mouseMoveEvent(QMouseEvent* event) { if (this-&gt;m_mousMove) { this-&gt;move(event-&gt;globalPos() - this-&gt;m_Difference); } } // 松开鼠标时重置标记，清空差值 void DialogObj::mouseReleaseEvent(QMouseEvent* event) { this-&gt;m_mousMove = false; } 原理：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/020955908af285be7d871599797060fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12b2d6c0d69eb0bf480021971053cb99/" rel="bookmark">
			python wheel文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		wheel介绍
.whl文件(WHL file)也称为轮子(wheel)，这是用于python分发(distribution)的标准内置包格式(standard built-package format)。它包含安装所需的所有文件和元数据(metadata)。.whl文件使用zip进行压缩。.whl文件还包含有关此wheel文件支持的Python版本和平台的信息。.whl文件格式是一种即装即用格式(ready-to-install format)，允许在不构建源代码分发(without building the source distribution)的情况下运行安装包。
.whl文件本质上是zip文件，这些.whl文件可以使用解压缩选项(unzip option)或标准解压缩软件应用程序(如WinZIP和WinRAR)解压缩。
.whl文件按照以下约定命名：
{dist}-{version}(-{build})?-{python.version}-{abi}-{platform}.whl 如果我们之前使用pip安装过Python包，那么我们的系统上很可能已经有轮子(wheel)被安装过。pip是安装wheel的包管理器。
我们可以通过pip安装已下载的.whl文件：pip install &lt;filename&gt;.whl ，安装包后，我们可以执行Python shell并尝试导入包：import whl_dist_name
wheel的直接好处是我们与其他人共享我们的包，他们不必担心构建它。他们只需pip install后即可使用该软件包。它也是一个更小的共享文件(与所有源代码相比)，安装速度更快，因为它不需要运行安装脚本。
摘自https://www.jb51.net/article/263488.htm
浏览https://blog.csdn.net/weixin_39525097/article/details/111453515
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4724a0feddda36807f12504290e76d92/" rel="bookmark">
			Excel 快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给表格添加所有边框（All boarders）：Alt + H + B + A 筛选Filter：Ctrl+Shift+L
复制上一个单元格: Ctrl + D
从上一个单元格复制值: Ctrl +Shift + "（双引号）
从上一个单元格复制公式: Ctrl + '（单引号）
复制左侧的一个单元格：Ctrl + R
复制单元格的值：Ctrl+V -&gt; Ctrl-&gt; V
SUM: Alt + =
输入当前日期: Ctrl + ;（分号）
输入当前时间: Ctrl +Shift + :
拆分字符串的自动填充：Ctrl + E
应用通用格式 ：Ctrl + Shift + ~
货币格式 ：Ctrl + Shift + $
百分比格式 ：Ctrl + Shift + %
科学记数格式 ：Ctrl + shift + ^
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4724a0feddda36807f12504290e76d92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69760a27d2a3957e3ad74612c0b583de/" rel="bookmark">
			C# （江湖小新）- 连接Mysql数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		依赖插件 MySql.Data安装 使用之前需要先在 vs中安装MySql.Data 插件，本文采用 Nuget 方式安装 ，步骤如下：
选中项目右键——》管理Nuget程序包 输入 MySql.Data ，搜索安装即可
连接数据库的基本对象介绍 MySqlConnection： 数据库连接对象MySqlCommand： sql语句执行对象MySqlDataReader：包含sql语句执⾏的结果，并提供⼀个⽅法从结果中阅读⼀⾏MySqlTransaction： sql事务管理对象MySqlException： 报错时返回的Exception。MySqlCommandBuilder：自动生成命令，该命令用于MySQL数据库协调对数据集所做的更改MySqlDataAdapter： 表示一组数据命令和数据库连接，用于填充数据集和更新MySQL数据库MySqlHelper：提供帮助的工具类 sql执行方法 ExcuteNonQuery：执行【insert（增）】、【updata（改）】、【delete（删）】语句ExcuteReader：执行多行查询，返回DataReader对象ExcuteScalar：执行单行查询，返回查询结果的首行数据 DataTable和DataSet 容器 可以把DataTable和DataSet看做是数据容器，比如你查询数据库后得到一些结果，可以放到这种容器里DataSet 可以比作一个内存中的数据库DataTable 是一个内存中的数据表DataSet 里可以存储多个DataTable数据结果 直接放到 dataTable中 DataTable dt = new DataTable(); MySqlDataAdapter DataAdapter = new MySqlDataAdapter(sql, conn); // 将数据填充到dataTable中 DataAdapter.Fill(dt); 数据结果 直接放到 dateSet 中 DataSet ds = new DataSet(); MySqlDataAdapter DataAdapter = new MySqlDataAdapter(sql, conn); // 将数据填充到dataSet中 DataAdapter.Fill(ds); 数据结果放到dataset中，若要用那个datatable,可以这样：dataset[0] DataSet ds = new DataSet(); MySqlDataAdapter DataAdapter = new MySqlDataAdapter(sql, conn); // 将数据填充到dataSet中 DataAdapter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69760a27d2a3957e3ad74612c0b583de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9aac3b5c04ca1c133177233b503c1517/" rel="bookmark">
			[JavaMailSender that could not be found] 之终极坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近有一个JIRA是需要enhance之前的batch模块(使用的spring-batch)，和我之前的schedule的microservice结合，每天定时发送邮件给配置的Maintainer来回报当天的batch状况。mail的api被封装到了一个公司的包里，所以就直接依赖了这个包，但是却莫名奇妙的报错javaMailsender could not be found。
在这里插入图片描述
很奇怪，按理说既然是封装好的包不应该存在缺失依赖的问题，确认了下，包是在的。然后再想是不是没有扫描到，又去检查了扫描配置，发现还是没问题。又怀疑是不是注入方式又问题，因为封装的时候使用的是构造器去注入的，我本地使用的是autowire注入，怕两种注入方式不能混用，后来证明都不是 。直到看到了这个。 Autowire JavaMailSender with spring-boot-starter-mail not working? 在spring-boot的main里面加入了- -debug参数，最终发现是yml配置出了问题(spring.mail)
public static void main(String[] args) { SpringApplication.run(Application.class, "--debug"); } 加上之后完美解决。
spring: mail: host: localhost port: 25 username:xxxx password:xxxxx 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd7de66ad61b9096c7068cd9f7ecd557/" rel="bookmark">
			JWT讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，JWT原理和构成 1. 含义 ​ Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519).该
token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提
供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务
逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。
2. 基于token的认证和传统的session认证的区别 3. JWT的构成 ​ 第一部分我们称它为头部（header),第二部分我们称其为载荷（payload, 类似于飞机上承载的物品)，第三部分是签证（signature).
jwt的头部承载两部分信息： 声明类型，这里是jwt声明加密的算法 通常直接使用 HMAC SHA256 完整的头部就像下面这样的JSON：
{ 'typ': 'JWT', 'alg': 'HS256' } 然后将头部进行base64加密（该加密是可以对称解密的),构成了第一部分.
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9 payload 载荷就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分
标准中注册的声明公共的声明私有的声明 标准中注册的声明 (建议但不强制使用) ：
iss: jwt签发者sub: jwt所面向的用户aud: 接收jwt的一方exp: jwt的过期时间，这个过期时间必须要大于签发时间nbf: 定义在什么时间之前，该jwt都是不可用的.iat: jwt的签发时间jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。 公共的声明 ： 公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添
加敏感信息，因为该部分在客户端可解密。
私有的声明 ： 私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密
的，意味着该部分信息可以归类为明文信息。
定义一个payload:
{ "sub": "1234567890", "name": "John Doe", "admin": true } 然后将其进行base64加密，得到JWT的第二部分。
eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9 signature JWT的第三部分是一个签证信息，这个签证信息由三部分组成：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd7de66ad61b9096c7068cd9f7ecd557/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8a9c0129350359dc59874f8f1dfcccc/" rel="bookmark">
			解决SVN左下角图标不显示（图文详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SVN中文件左下角图标消失的解决步骤 首先解释以下为什么会发生这样的现象：
因为WindowsExporerShell所支持的Overlay Icon最多十五个，当前面十五个被其他软件或者windows系统自身占用，svn就被顶掉从而无法使用，结果就是图标消失。
解决方法就是将注册表中svn图标重命名，使其在前十五个中。下面是详细步骤。
01打开注册表 按住Win+R键，输入regedit进入注册表编辑器，按路径打开: 计算机-&gt;HKEY_LOCAL_MACHINE-&gt;SOFTWARE-&gt;Microsoft-&gt;Windows-&gt;CurrentVersion-&gt;Explorer-&gt;ShellIconOverlayIdentifiers，会看到如下注册信息：
以Tortoise开头的都是svn图标的注册信息，只需要右键，重命名这些名称，在名称前加一个 0 就可以，名称前的空格数要与其他软件的空格数相同或者更多，这样才能保证svn图标的注册信息在最前面（重命名完后可以退出注册表重新进入检查，如果svn注册信息在最前面就可以了 如上图即可）
02svn相关设置 然后就是SVN相关设置：
右键svn库，TortoiseSVN-&gt;设置，然后对图标集和覆盖程序进行如下设置：
可以保持如上相同，图标集也可以选择自己喜欢的
03重启生效 可以在任务管理器关闭explorer.exe任务后重运行该任务
嫌麻烦直接重启电脑即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6799fec42a2c09013f73ff0256e0712b/" rel="bookmark">
			gitlab&#43;jenkins&#43;docker持续集成环境搭建实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 什么是持续集成？ 持续集成（CI）是在源代码变更后自动检测、拉取、构建和（在大多数情况下）进行单元测试的过程。持续集成是启动管道的环节（尽管某些预验证 —— 通常称为 上线前检查(pre-flight checks) —— 有时会被归在持续集成之前）。
本篇简明扼要，直击痛点，可以让急需构建CI/DI环境而无从下手的小伙伴。
步骤 准备服务器 4台centos7虚拟机：
192.168.182.131 gitlab服务器
192.168.182.132 jenkins服务器
192.168.182.133 java应用发布服务器
192.168.182.134 docker发布服务器
可以先搭建1台基础的包含docker和jdk环境的虚拟机。其余的3台采用克隆方式创建。
准备1个springboot项目 主要用于演示代码提交和自动化构建，代码很简单：
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.4.5&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;groupId&gt;com.test.java&lt;/groupId&gt; &lt;artifactId&gt;helloci&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;!-- 跳过测试 --&gt; &lt;skipTests&gt;true&lt;/skipTests&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--打包--&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; @RestController public class HelloController { @GetMapping public String hello(){ return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6799fec42a2c09013f73ff0256e0712b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b017ba07b4561a9d1fed691ad8bca81/" rel="bookmark">
			Linux 内核观测技术 eBPF 中文入门指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公众号关注 「奇妙的 Linux 世界」
设为「星标」，每天带你玩转 Linux ！
很早前就想写一篇关于 eBPF 的文章，但是迟迟没有动手，这两天有点时间，所以就来写一篇。这文章主要还是简单的介绍 eBPF 是用来干什么的，并通过几个示例来介绍是怎么玩的。这个技术非常非常之强，Linux 操作系统的观测性实在是太强大了，并在 BCC 加持下变得一览无余。这个技术不是一般的运维人员或是系统管理员可以驾驭的，这个还是要有底层系统知识并有一定开发能力的技术人员才能驾驭的了的。我在这篇文章的最后给了个彩蛋。
— 1 —
介绍
eBPF（extened Berkeley Packet Filter）是一种内核技术，它允许开发人员在不修改内核代码的情况下运行特定的功能。eBPF 的概念源自于 Berkeley Packet Filter（BPF），后者是由贝尔实验室开发的一种网络过滤器，可以捕获和过滤网络数据包。
出于对更好的 Linux 跟踪工具的需求，eBPF 从 dtrace中汲取灵感，dtrace 是一种主要用于 Solaris 和 BSD 操作系统的动态跟踪工具。与 dtrace 不同，Linux 无法全面了解正在运行的系统，因为它仅限于系统调用、库调用和函数的特定框架。
在 Berkeley Packet Filter（BPF）（一种使用内核 VM 编写打包过滤代码的工具）的基础上，一小群工程师开始扩展 BPF 后端以提供与 dtrace 类似的功能集。eBPF 诞生了。2014 年随 Linux 3.18 首次限量发布，充分利用 eBPF 至少需要 Linux 4.4 以上版本。
eBPF 比起传统的 BPF 来说，传统的 BPF 只能用于网络过滤，而 eBPF 则可以用于更多的应用场景，包括网络监控、安全过滤和性能分析等。另外，eBPF 允许常规用户空间应用程序将要在 Linux 内核中执行的逻辑打包为字节码，当某些事件（称为挂钩）发生时，内核会调用 eBPF 程序。此类挂钩的示例包括系统调用、网络事件等。用于编写和调试 eBPF 程序的最流行的工具链称为 BPF 编译器集合（BCC），它基于 LLVM 和 CLang。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b017ba07b4561a9d1fed691ad8bca81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32a7f2111bbf15777198f13675240032/" rel="bookmark">
			python中字典取值的两种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 方法一：dic.get('key', 默认值) dic1 = {'1':'node1','2':'node2'} print(dic1.get('1')) # node1 print(dic1.get('3', 'no such key')) # no such key 若字典中没有该键，则返回默认值 若字典中没有该键，则返回默认值。
方法二：使用方括号[] dic1 = {'1':'node1','2':'node2'} print(dic1['1']) # node1 print(dic1['3']) # KeyError: '3' 使用方括号[]，dic['key']时要求key必须在dic中存在，否则报错。
建议使用方法一：dic.get('key', 默认值) 来获取字典中的键值对。因为当键不存在时不会报错，会用默认值填充。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8b59b82ab2ab9d09a78391f8d2e3d02/" rel="bookmark">
			Vue通信、传值的多种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、通过路由带参数进行传值 1、两个组件 A和B,A组件通过query把orderId传递给B组件（触发事件可以是点击事件、钩子函数等）
this.$router.push({ path: '/conponentsB', query: { orderId: 123 } }) // 跳转到B 2、在B组件中获取A组件传递过来的参数
this.$route.query.orderId 二、通过设置 Session Storage缓存的形式进行传递 1、两个组件A和B，在A组件中设置缓存orderData
const orderData = { 'orderId': 123, 'price': 88 } sessionStorage.setItem('缓存名称', JSON.stringify(orderData)) 2、B组件就可以获取在A中设置的缓存了
const dataB = JSON.parse(sessionStorage.getItem('缓存名称')) 此时 dataB 就是数据 orderData
三、父子组件之间的传值 （一）父组件往子组件传值props 1、定义父组件，父组件传递 number这个数值给子组件，如果传递的参数很多，推荐使用json数组{}的形式。
2、定义子组件，子组件通过 props方法获取父组件传递过来的值。props中可以定义能接收的数据类型，如果不符合会报错。
3、假如接收的参数 是动态的，比如 input输入的内容 v-model的形式。
4、父子组件传值，数据是异步请求，有可能数据渲染时报错
（二）子组件往父组件传值，通过emit事件 四、不同组件之间传值，通过eventBus 小项目少页面用eventBus，大项目多页面使用 vuex
1、定义一个新的vue实例专门用于传递数据，并导出
2、定义传递的方法名和传输内容，点击事件或钩子函数触发eventBus.emit事件
3、接收传递过来的数据
五、vuex进行传值 1、 vuex主要是是做数据交互，父子组件传值可以很容易办到，但是兄弟组件间传值（兄弟组件下又有父子组件），或者大型spa单页面框架项目，页面多并且一层嵌套一层的传值，异常麻烦，用vuex来维护共有的状态或数据会显得得心应手
src新建一个vuex文件夹
vuex文件夹里新建一个store.js
安装vuex cnpm install vuex --save
在刚才创建的store.js 中引入vue、vuex 引入vue
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8b59b82ab2ab9d09a78391f8d2e3d02/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95fe9acc45a852df12cfd9bc7c95a46a/" rel="bookmark">
			IDEA中Ignored pom 问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题产生环境：maven 父子工程项目，创建子模块时产生。
问题描述：子模块名字创建错误，删除子模块重新创建子模块时，若名字相同，则会出现pom文件被IDEA 忽略的情况
问题原因：由于相同名称module 在之前被创建国，因此IDEA中留有痕迹。重新创建会让IDE误认为是之前被删除掉的module，所以忽略了本pom.xml。
解决方法：
1. File -&gt; Setting 2.找到 Ignored Files （maven下的），把右边已选中的选项取消勾选，然后保存。
3. 刷新Maven 或 文件目录，pom.xml 文件恢复如初。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6eea0b83a6f0d87b21a328bdbf8ed73a/" rel="bookmark">
			C&#43;&#43;11计时器:chrono库介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++11计时器:chrono库介绍 C++11有了chrono库，可以在不同系统中很容易的实现定时功能。
要使用chrono库，需要#include，其所有实现均在std::chrono namespace下。注意标准库里面的每个命名空间代表了一个独立的概念。
chrono是一个模版库，使用简单，功能强大，只需要理解三个概念：duration、time_point、clock
一 、时钟-CLOCK chrono库定义了三种不同的时钟:
std::chrono::system_clock: 依据系统的当前时间 (不稳定) std::chrono::steady_clock: 以统一的速率运行(不能被调整) std::chrono::high_resolution_clock: 提供最高精度的计时周期(可能是steady_clock或者system_clock的typedef) 二、这三个时钟有什么区别呢？ system_clock就类似Windows系统右下角那个时钟，是系统时间。明显那个时钟是可以乱设置的。明明是早上10点，却可以设置成下午3点。
steady_clock则针对system_clock可以随意设置这个缺陷而提出来的，他表示时钟是不能设置的。
high_resolution_clock则是一个高分辨率时钟。
这三个时钟类都提供了一个静态成员函数now()用于获取当前时间，该函数的返回值是一个time_point类型，
system_clock除了now()函数外，还提供了to_time_t()静态成员函数。用于将系统时间转换成熟悉的std::time_t类型，得到了time_t类型的值，在使用ctime()函数将时间转换成字符串格式，就可以很方便地打印当前时间了。
#include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;string&gt; #include&lt;ctime&gt;//将时间格式的数据转换成字符串 #include&lt;chrono&gt; using namespace std::chrono; using namespace std; int main() { //获取系统的当前时间 auto t = system_clock::now(); //将获取的时间转换成time_t类型 auto tNow = system_clock::to_time_t(t); //ctime()函数将time_t类型的时间转化成字符串格式,这个字符串自带换行符 string str_time = std::ctime(&amp;tNow); cout&lt;&lt;str_time; return 0; } 三、持续的时间 - duration td::chrono::duration&lt;int,ratio&lt;60,1&gt;&gt; ,表示持续的一段时间,这段时间的单位是由ratio&lt;60,1&gt;决定的,int表示这段时间的值的类型,函数返回的类型还是一个时间段duration
std::chrono::duration&lt;double,ratio&lt;60,1&gt;&gt;
由于各种时间段(duration)表示不同，chrono库提供了duration_cast类型转换函数。
duration_cast用于将duration进行转换成另一个类型的duration。
duration还有一个成员函数count(),用来表示这一段时间的长度
#include&lt;iostream&gt; #include&lt;string.h&gt; #include&lt;chrono&gt; using namespace std::chrono; using namespace std; int main() { auto start = std::chrono::steady_clock::now(); for(int i=0;i&lt;100;i++) cout&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6eea0b83a6f0d87b21a328bdbf8ed73a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/996201645ebde5de43dbd1cf5620e9f6/" rel="bookmark">
			Failed to execute goal on project xxx-service: Could not resolve dependencies for project
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Failed to execute goal on project xxx-service: Could not resolve dependencies for project com.xxx:xxx-service:jar:1.0.0: Failed to collect dependencies at com.yyy:yyy-facade:jar:1.0.0: Failed to read artifact descriptor for com.yyy:yyy-facade:jar:1.0.0: Failure to find com.yyy:yyy:pom:1.0.0
in http://host:ip/nexus/public/ was cached in the local repository,resolution will not be reattempted until the update interval oftest-mirrorId has elapsed or updates are forced -&gt; [Help 1]
原因：
子项目引用了父项目的POM，但没有在父项目POM目录下执行安装操作(父目录下执行mvn install)，这个问题就会出现。当一个子模块可能会依赖一个兄弟子模块而且去读取兄弟子模块的pom时，除非在父项目POM目录下至少执行一次安装，否则就会读取失败，即出现上述错误。
原文:https://www.jianshu.com/p/60b2719b5e3a
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad8b3f128bc2aad92164bf1757e9760d/" rel="bookmark">
			js调用其他js文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 要在 JavaScript 中调用其他 JavaScript 文件，你可以使用 HTML &lt;script&gt; 标签来引入其他 JavaScript 文件。例如，假设你有一个名为 "main.js" 的 JavaScript 文件，要在 HTML 文件中调用它，你可以这样写：
&lt;script src="main.js"&gt;&lt;/script&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc7ff2b02975825705948758f46c318d/" rel="bookmark">
			组件的生命周期、vue2中使用axios、插槽
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、组件的生命周期
1、什么是组件的生命周期
2、生命周期函数
3、生命周期的阶段划分
4、钩子函数
5、keep-alive组件
6、生命周期函数：
二、vue2中使用axios
1、axios：是一个基于Promise的网络请求库。既可以在node.js（服务器端）使用，也可以在浏览器端使用
2、vue中的使用方法
3、axios中不同请求方式向服务器提交数据的格式
三、插槽
1、组件的三大核心：属性（data、props）、事件、插槽
2、插槽（slot）:将子组件和父组件进行组合，可以弥补视图的不足。使组件具有更好的扩展性
3、插槽的使用方式
一、组件的生命周期 1、什么是组件的生命周期 ​ 指一个组件从 创建 —-&gt; 运行 ——&gt; 销毁的过程，强调的是一个时间段
2、生命周期函数 由Vue提供的内置函数，伴随组件的生命周期按次序自动运行 —— 钩子函数
3、生命周期的阶段划分 （1）创建阶段：beforeCreate、created、beforeMount、mounted
​（2）运行阶段：beforeUpdate、update
​（3）销毁阶段：beforeDestroy、destroyed
4、钩子函数 vue的内置函数，当Vue组件运行到某个阶段时这些函数会自动运行，不需要用户显式的调用
5、keep-alive组件 vue的内置组件，用来保持vue组件运行的某种状态，避免被重新渲染
​ 第一步：创建组件（定义组件），组件文件的扩展名(后缀)可以是.vue，也可以是.js
​ 第二步：在使用组件的位置导入，注册组件
​ 第三步：使用组件：像html标签一样使用
6、生命周期函数： ​ （1）beforeCreate：在组件创建之前运行，此时Vue实例的el、data、data中的变量均为undefined
​ （2）created：表示组件已经创建完成，data、props已经初始化了，el还是undefined（组件还没有挂载到DOM上）
​ （3）beforeMount：el被绑定（和DOM绑定），但未挂载
​ （4）mounted：组件挂载之后，el绑定、组件挂载
​ （5）beforeUpdate：当组件的内容被改变、隐藏的组件被显示、显示的组件被隐藏等触发
​ （6）beforeDestroy：在组件销毁之前。组件还是正常使用
​ （7）destroyed：组件销毁之后
二、vue2中使用axios 1、axios：是一个基于Promise的网络请求库。既可以在node.js（服务器端）使用，也可以在浏览器端使用 ​ （1）在node.js中使用的原生的http模块
​ （2）在浏览器中使用的XMLHttpRequest
2、vue中的使用方法 ​ （1）安装：npm install axios
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc7ff2b02975825705948758f46c318d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef0d7f4622d1d98177e103b0813303bf/" rel="bookmark">
			通过CMA、CNAS双认证的第三方软件测试机构安利
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、什么是CMA认证?
CMA是中国计量认证的简称，由省级以上人民政府计量行政部门对检测机构的检测能力及可靠性进行的一种全面的认证及评价，认证对象是所有对社会出具公正数据的产品质量监督检验机构及其它各类实验室，是需要强制性认证的资质。取得该资质认证的，可以的检验报告上使用CMA标记。
2、什么是CNAS认可?
CNAS是中国合格评定国家认可委员会的英文缩写，由国家认证认可监督管理委员会批准设立并授权的国家认可机构，统一负责对认证机构、实验室和检验机构等相关机构的认可工作。是由实验室自愿进行的认可资质，检测报告上可加盖CNAS章。
3、检测机构拥有CMA和CNAS双重认证有什么好处?
软件测试报告上有CMA和CNAS标记的检验检测报告更加的可靠，获得国家和行业内的认可，具备法律效益。可以有助于软件企业提高市场竞争力，为软件产品质量提供有效保障，降低企业成本。
4、通过CMA、CNAS双认证的第三方软件测试机构安利
卓码软件测评，获得了CMA认证和CNAS认可权威资质。公司拥有专业的软件测试团队、科学管理机制和严格的保密制度，可根据客户不同需求进行各类软件测试服务，服务范围覆盖全国各地，专业出具权威软件测试报告。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/199a3ede6a7468775e69d238878f036e/" rel="bookmark">
			R语言绘制柱状图(bar plot)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		柱状图是在数据可视化过程中最为常见的图片形式之一，本文将借助R语言中的ggplot2这个包绘制常用的柱状图。在ggplot2包中主要是使用geom_bar()这个函数来绘制柱状图。该函数主要包括以下5个参数，我们可以通过输入?geom_bar命令来查看帮助文档。
stat：有identity、count和bin这三个参数。其中identity比较常用，表示直接引用数据集中的变量的值（默认为count）。
position：我的理解为调整柱状图的形式，有identity、fill、dodge这三种形式，下面将通过案例1对此进行详细讲解。
width：调整柱子的宽度。
color：调整柱子边框的颜色。
fill：调整柱子的填充颜色。
案例一：在这里插入代码片
使用ggplot2包里的“diamonds”数据集。diamonds数据集包含大约 54 000 颗钻石的信息，每颗钻石具有 price、carat、color、clarity 和 cut 变量。案例一将使用cut（切割质量）和clarity （钻石的纯净度）这两个变量。
1、调整参数position=“identity”，color = “white”
library(tidyverse) # 载入数据集和绘图包 ggplot(data = diamonds) + geom_bar(aes(x = cut, fill = clarity), color = "white", position = "identity") 可以观察到当position=“identity”该图的形式为高度表示绝对数量的堆积柱状图，当color = “white”时边框变成了白色，当我们想改变柱子的填充颜色时，可以使用fill这个函数。
同时，我们也可以通过coord_flip()函数把柱子变成横向的。
coord_flip() 如果我们想通过clarify的不同把该图分为不同小块，可以通过facet_grid()函数来实现。
ggplot(data = diamonds) + geom_bar(aes(x = cut, fill = clarity), color = "white", position = "identity")+ facet_grid(.~clarity) ggplot(data = diamonds) + geom_bar(aes(x = cut, fill = clarity), color = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/199a3ede6a7468775e69d238878f036e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8028887e9e7dd9eca4fa3b2c3d3049d/" rel="bookmark">
			高德地图的js api 覆盖物的颜色怎么渐变
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		高德地图的 JavaScript API 支持设置覆盖物的渐变颜色。首先，你需要使用 AMap.Polygon 类创建一个多边形覆盖物，然后使用 setOptions 方法设置其 fillColor 属性。fillColor 属性接受一个数组，其中包含多个颜色值，表示从开始颜色渐变到结束颜色。例如：
var polygon = new AMap.Polygon({ path: path, // path 是一个包含多个经纬度坐标的数组 fillColor: ['#FF0000', '#00FF00'] // 从红色渐变到绿色 }); polygon.setMap(map); // map 是一个 AMap.Map 对象 注意，你可以使用任意数量的颜色值来实现复杂的渐变效果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85bf3250e6dc0af1630e3790a1b1d40f/" rel="bookmark">
			WPF快速入门2——WPF布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WPF布局 WPF中常用的布局有一下几种：
Grid 网格 主要应用场合：
UI布局大框架涉及大量元素需成行或成列对齐UI整体尺寸改变时，元素需要保持固有宽高比例UI后期有较大变更或扩展 示例
&lt;Window x:Class="WpfApplication2.MainWindow" xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:d="http://schemas.microsoft.com/expression/blend/2008" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" xmlns:local="clr-namespace:WpfApplication2" mc:Ignorable="d" Title="数据发送" Height="222.408" Width="299.08"&gt; &lt;Grid&gt; &lt;TextBlock Text="选择端口:" Margin="10,10,0,0" Height="20" Width="60" VerticalAlignment="Top" HorizontalAlignment="Left"/&gt; &lt;ComboBox Height="25" Width="210" VerticalAlignment="Top" Margin="0,10,10,0" HorizontalAlignment="Right"/&gt; &lt;TextBox BorderBrush="Black" Margin="10,50,10,50"/&gt; &lt;Button Content="发 送" Height="30" Width="80" VerticalAlignment="Bottom" HorizontalAlignment="Right" Margin="0,0,10,10"/&gt; &lt;Button Content="清 除" Height="30" Width="80" VerticalAlignment="Bottom" HorizontalAlignment="Right" Margin="0,0,100,10"/&gt; &lt;/Grid&gt; &lt;/Window&gt; 效果：
StackPanel 栈式面板 StackPanel可以把内部元素横/纵向紧凑排列、行程栈式布局。
应用场合一般是：
同类元素需要紧凑排列（菜单或列表等）移除其中的元素后能自动补缺 示例：
&lt;Window x:Class="WpfApplication2.MainWindow" xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:d="http://schemas.microsoft.com/expression/blend/2008" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" xmlns:local="clr-namespace:WpfApplication2" mc:Ignorable="d" Title="选择语言" Height="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85bf3250e6dc0af1630e3790a1b1d40f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42371211f545338bb2e55733e8e348d2/" rel="bookmark">
			【C&#43;&#43;高阶数据结构】LRU
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​ 🏆个人主页：企鹅不叫的博客
​ 🌈专栏
C语言初阶和进阶C项目Leetcode刷题初阶数据结构与算法C++初阶和进阶《深入理解计算机操作系统》《高质量C/C++编程》Linux ⭐️ 博主码云gitee链接：代码仓库地址
⚡若有帮助可以【关注+点赞+收藏】，大家一起进步！
💙系列文章💙 【C++高阶数据结构】并查集
【C++高阶数据结构】图
文章目录 💙系列文章💙💎一、概念💎二、OJ 💎一、概念 缓存空间满了之后，更新数据，我要进入，谁出去呢？
LRU是Least Recently Used的缩写，意思是最近最少使用，它是一种Cache替换算法。，将最近最少被使用的算法替换出去。（包括读和写）
💎二、OJ LRU缓存
思路：
要调整_LRUList中key的位置到头部，更新顺序
但是我们不知道数据在哪里，只能遍历查找，这个就变成了O(N)
我们找到了数据，我们还需要知道在链表中的位置
所以我们下面用了unorder_map&lt;int,iterator&gt;作为映射，记录当前的key在我们链表中对应的位置
然后用一个list&lt;int,int&gt;来记录我们题目要求的&lt;key,value&gt;
class LRUCache { public: LRUCache(int capacity) :_capacity(capacity){ } int get(int key) { //返回_hashmap中存key的迭代器 auto ret=_hashMap.find(key); //如果存在 if(ret !=_hashMap.end()) { //更新key对应的值的位置 //ret的second是对应的值在链表里面的迭代器的位置 LtIter it=ret-&gt;second; //splice 转移节点 _LRUList.splice(_LRUList.begin(),_LRUList,it); //ret-&gt;second找到的是在链表中的迭代器的位置再-&gt;second就是找到第二个元素也就是存的具体的数据 return ret-&gt;second-&gt;second; } else { return -1; } } void put(int key, int value) { //1、新增 //2、更新 auto ret=_hashMap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42371211f545338bb2e55733e8e348d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ee01a1f9159a462ada90018518a5194/" rel="bookmark">
			Keycloak Oauth2.0流程 --- Angular前端 &#43; Django后端 &#43; Keycloak 实现SSO功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言：
前端Angular集成Keycloak：
1.使用github开源的的库 keycloak-angular：
安装Keycloak Angular和keycloak客户端keycloak-js库：
Angular中设置Keycloak：
Keycloak登录：
2.自己实现集成Keycloak功能 -- 实现Oauth2.0流程 ：
(1).实现Keycloak登录：
(2).登录成功，获取Keycloak相关信息：
3.关于Nginx配置：
后端Django集成Keycloak:
1.实现中间件：
2.实现Keycloak的API工具类：
代码地址：
前言： 一个企业往往拥有多个应用系统，如果每个应用都有独立的用户认证和授权管理功能，这不仅需要运维人员维护多套用户管理系统，用户使用每个系统时都要登录一次，非常不方便。如果能够将所有应用系统的用户集中管理，用户只登录一次，就可以无需再次登录而访问所有系统，这将会大大改善用户体验。本文前端Angular, 后端Django，基于Keycloak搭建单点登录系统。所以代码均经过验证，直接从工程代码中拷贝。
前端代码部署到nginx, 前后端代码分开部署
前端Angular集成Keycloak： 本文使用前端登录，而不是后端登录的方式。后端只负责检测前端发送的请求携带的access token是否可以访问Keycloak，以及访问Keycloak server的几个API。
前端要怎样集成Keycloak呢？ 本文提供两种方式
1.使用github开源的的库 keycloak-angular： 原始的keycloak js adapter：前端集成Keycloak，根据官方文档，keycloak提供了一个JavaScript adapter，详情请参考：https://www.keycloak.org/docs/latest/securing_apps/index.html#_javascript_adapter
这个keycloak-angular库对keycloak提供的这个JavaScript adapter进行了包装，可以帮助用户在Angular应用中更方便的使用, 请参考github：GitHub - mauriciovigolo/keycloak-angular: Easy Keycloak setup for Angular applications. 它提供了以下特性：
提供了一个keycloak服务，它包装了要在Angular中使用的keycloak-js函数，为原始函数（keycloak-js文件中提供的函数）提供了额外的功能，并且还添加了新的函数，使其更容易被Angular应用程序使用通用的AuthGuard实现，用户可以通过继承其认证逻辑和角色加载，自定义所需要的AuthGuard逻辑。提供了一个HttpClient拦截器，登录成功之后，每个http请求都会在header中增加认证信息(其实就是登录成功之后的keycloak access token)，用户可以禁用这个拦截器，也可以设置排除某个url的http请求。下面是拦截器源码中，给http请求的header中增加access token的代码： /** * Adds the token of the current user to the Authorization header * * @param req * @param next */ private handleRequestWithTokenHeader( req: HttpRequest&lt;any&gt;, next: HttpHandler ): Observable&lt;any&gt; { return this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ee01a1f9159a462ada90018518a5194/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d349608ae0d4a796ee66085d8f8ba6ce/" rel="bookmark">
			Typora插图免费上传云端教程（太香了）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、前言 我们平时在使用Typora时，文档中的图片一般是保存在本地，很方便，但是有些场景也有问题，比如我全部拷贝到有道云笔记中或者全部拷贝到CSDN中去发布时，你会发现，所有图片都无法预览了，此时只能一张一张的选择上传了，非常大麻烦（我就遇到了这样的问题）
我就开始想，有没有什么办法，图片直接上传到云上了，图片到地址都是云地址，这样我拷贝到人和地方，图片都是可以正常显示的
功夫不负苦心人，我终于找到了一种办法实现我的这个需求（不知道你们需不需要，反正我是需要的，哈哈）
下面我们就来配置一下，步骤如下：
gitee新建仓库，用来存放Typora文档中的图片下载安装PicGo图片上传工具，用来上传图片到giteeTypora设置测试 2、gitee新建仓库 2.1、创建仓库 我们先在码云官网（https://gitee.com）上注册一个账号，然后登录成功后，创建一个仓库：
创建成功后就是这样的：
注意：仓库一定要设置成公开的，否则拷贝到博客中可能就无法显示
2.2、生成私人令牌 然后
然后输入账号密码：
就会生成私人令牌了，如下：
注意：记得保存好这个令牌，弹框关闭后，这个令牌就再也找不到了哦
有了这个私人令牌之后，待会要用到的，继续下面的操作
3、下载安装PicGo 3.1、PicGo介绍 首先我们必须先了解图床工具的概念，所谓图床工具，就是自动把本地图片转换成链接的一款工具网络上有很多图床工具，就目前使用种类而言，PicGo 算得上一款比较优秀的图床工具它是一款用 Electron-vue 开发的软件，可以支持微博，七牛云，腾讯云COS，又拍云，GitHub，阿里云OSS，SM.MS，imgur 等8种常用图床，功能强大，简单易用官网地址：https://picgo.github.io/PicGo-Doc/zh 3.2、下载安装 下载地址：https://github.com/Molunerfinn/PicGo/releases，如下：
页面滑到下面点击下载即可，我这里使用的版本是：2.3.1，然后安装即可
也可以从我的网盘中下载PicGo，地址：
链接：https://pan.baidu.com/s/1z7D3AgaQabepAsEduXKZIw
提取码：6666
3.3、PicGo设置 运行PicGo，点击插件设置，搜索【github】，点击安装即可
防止上传文件多了重名，所以用时间戳作为文件名
然后点击【图床设置】 - 【gitee】，然后填写相关参数即可
repo：复制仓库地址：https://gitee.com/xxxxxxxx/TyporaImages，然后取https://gitee.com/后面的值填进去就可以了
token：填写我们上面生成的私人令牌
如下：
然后点击【确定】即可
当然，这里你也可以选择其他的平台，比如：阿里云、七牛云什么的，都可以
然后选择【上传区】菜单，上传一个文件试试，看能否上传到我们的gitee仓库中：
将文件拖拽到上面虚线框中即可完成上传，然后电脑右下角就会弹出提示，如下：
上传成功了，看下gitee仓库中：
果然上传成功了
到这里我们PicGo就成功设置完毕了
4、Typora设置 打开typora的偏好设置路径，选择刚刚安装PicGo的路径，如下设置：
然后每次我们在粘贴图片到Typora中后，右键选择【上传图片】就可以将图片上传到gitee仓库中了
5、小结 如果你直接按照上面方式设置到话，那每次你的图片就会直接上传到gitee的仓库中了，本地就没有图片了，如果需要本地也有一份图片到话，可以怎么做呢？
非常简单，直接将gitee上的仓库拉到本地即可
自从这样设置后，每次本地写完文章后，想分享到CSDN等网络平台上时，那叫一个丝滑啊，再也不用一张图片一张图片的选择拷贝进去了，节约了很多时间，大家赶紧用起来吧
如果本文对你有帮助的话，记得点个赞哦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dc1891ba4733af908a732abd532cb53/" rel="bookmark">
			（PTA）顺序练习编程题答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		7-5 然后是几点 分数 15
全屏浏览题目
切换布局
作者 翁恺单位 浙江大学
有时候人们用四位数字表示一个时间，比如 1106 表示 11 点零 6 分。现在，你的程序要根据起始时间和流逝的时间计算出终止时间。
读入两个数字，第一个数字以这样的四位数字表示当前时间，第二个数字表示分钟数，计算当前时间经过那么多分钟后是几点，结果也表示为四位数字。当小时为个位数时，没有前导的零，例如 5 点 30 分表示为 530；0 点 30 分表示为 030。注意，第二个数字表示的分钟数可能超过 60，也可能是负数。
输入格式： 输入在一行中给出 2 个整数，分别是四位数字表示的起始时间、以及流逝的分钟数，其间以空格分隔。注意：在起始时间中，当小时为个位数时，没有前导的零，即 5 点 30 分表示为 530；0 点 30 分表示为 030。流逝的分钟数可能超过 60，也可能是负数。
输出格式： 输出不多于四位数字表示的终止时间，当小时为个位数时，没有前导的零。题目保证起始时间和终止时间在同一天内。
输入样例： 1120 110 输出样例： 1310 答案： #include&lt;stdio.h&gt; int main(void) { int time,min,h,m,sum,a,b; scanf("%d %d",&amp;time,&amp;min); h=time/100;//算出小时数 m=min+time-h*100;//算出从当前时间的分钟数加上经过时间的分钟数的总分钟数 sum=h*60+m;//算出总的分钟数 a=sum/60;//显示小时 b=sum%60;//显示分钟 printf("%d%.2d",a,b); return 0; } 7-10 计算两点之间的距离 分数 10
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0dc1891ba4733af908a732abd532cb53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/242075464504c3371ebafc1b73bacf89/" rel="bookmark">
			https安全传输揭秘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTTPS是什么 我们知道HTTP是明文传输的，恶意的中间人和窃听者通过截取用户发送的网络数据包可以拿到用户的敏感信息。尤其是涉及网上交易，银行转账等操作更是危害极大。
HTTPS的核心是SSL/TLS安全协议层，该层位于应用层和传输层之间，TLS对应用层数据加密后再向下交给传输层，以解决HTTP安全传输的问题。
下面我们就一起来梳理一下TLS在背后做了哪些事情，为我们的互联网行业保驾护航。
身份验证 发送方与接收方在决定数据传输之前，第一步要做的必然是互相确认对方的身份。TLS使用数字证书帮助确认证书持有者的身份。
证书 证书是一数字形式的身份证明，通常由CA进行颁发。证书中包含了证书持有者的信息，有效期，公钥，序列号，以及证书颁发者的数字签名。
CA CA（Certificate Authority），数字证书认证机构是负责发放和管理数字证书的权威机构，并作为电子商务交易中受信任的第三方，承担公钥体系中公钥的合法性检验的责任。
CA的作用可以用公安局来做个类比，负责给公民颁发居民身份证，身份证上的信息都是公安局签字确认过的，具有权威性。
数字签名 数字签名是非对称加密技术的另一项应用。它的原理非常简单：公私钥是成对使用的，使用私钥加密的密文，只能使用公钥来解密。因为私钥只有特定服务器才知道，所以如果公钥可以解密用私钥加密的密文，必然证明是该服务器发送的。私钥用来数字签名，表明报文是特定服务器发送的；公钥用来验证数字签名。
数字签名是使用私钥加密的校验和。将数字签名附加到报文上，一并发给接收方。
数字签名的作用：
证明是作者编写了这条报文；可以防止报文被篡改。 描述一下整个身份验证的过程：
1.客户端向服务器发起请求
2.服务器将CA发给自己的证书发送给客户端
3.客户端在本机查找该CA是否在本机的CA列表中
4.如果存在，客户端使用该CA的公钥对该证书上的CA数字签名进行验证
5.如果验证通过，说明该证书确实是CA颁发的。
6.客户端查看证书是否在有效期，证书上的信息是否与当前访问的域名一致。
7.如果确认一致，则证明该证书属于该服务器所有。
加密 TLS需要解决的问题是安全地交换对称密钥，使用对称密钥进行数据的加解密。
加密有两种主要的技术：对称密钥加密和公开密钥加密。 这两种加密技术，TLS都在使用。
对称密钥 在对称密钥加密中，密钥既用于加密也用于解密。消息交换的双方需要同时知道该密钥。对称密钥加密常用于大数据量的加解密，相比非对称密钥加密，它的加密速度要快得多。常见的对称密钥加密算法有DES，3-DES，RC2，RC4，和AES。
公开密钥加密 公开密钥加密是一组密钥对，由复杂的数学运算得出。其中一个密钥对外公开称之为公钥，通常密钥持有者让CA把自己的公钥写到证书中对外发布。另一把密钥由持有者秘密保存。两把密钥一起协作，一把用来加密，另一把用来解密：如果公钥用来加密，那么只有对应的私钥能解密；如果私钥用来加密，同样只有对应的公钥才能解密。这种特殊的关系使得公开密钥加密有两种重要的应用。首先，任何一个取得了服务器公钥的人，都可以用该公钥加密数据，同时只有该服务器私钥的拥有者才可以进行解密。其次，如果服务器使用私钥加密数据，那么任何取得该服务器公钥的人都可以对服务器发送的数据进行解密。这也是数字签名的实现基础。最常见的算法是RSA。
加密技术优点缺点对称密钥加解密速度快，性能好密钥交换有泄露风险公开密钥不存在密钥交换窃取的风险；可以用作签名验证身份计算复杂，性能差 TLS使用公钥加密对服务器进行身份验证后，在客户端和服务器之间商定对称密钥。随后使用商定的对称密钥加密会话过程中的大量数据。这种方案既利用公钥加密解决了身份验证和密钥交换的问题，又结合了对称密钥加密大量数据速度快的优点。
安全会话建立的完整过程 以上我们已经对TLS的功能和实现方式有了一个初步的了解。接下来，我们将对安全会话建立的细节做一个详细的介绍。
整个安全会话的建立，TLS是以握手的过程来协商的，具体过程下图所示：
可以看到握手协议通过一系列的有序的消息协商数据会话所需的安全参数。
客户端先发送消息启动握手 Client Hello 客户端向服务器发送Client Hello以发起会话，Client Hello包含以下信息：
版本号。客户端可以支持的最高版本的协议。随机数。长度为32字节的随机数。由4字节的客户端时间加28字节的随机数组成。sessionID。sessionID用来恢复之前的会话。恢复之前的会话很有必要，因为创建新的安全会话，需处理器进行密集的计算得到会话密钥。通过sessionID恢复已有的会话可以避免此问题。加密套装。客户端可以支持的加密套装列表。例如TLS_RSA_WITH_DES_CBC_SHA，TLS是协议的版本，RSA是密钥交换的非对称加密算法，DES_CBC是对称加密算法，SHA是散列方法。压缩算法。客户端支持的压缩算法。 如下是一个 Client Hello消息的示例：
ClientVersion 3,1 ClientRandom[32] SessionID: None (new session) Suggested Cipher Suites: TLS_RSA_WITH_3DES_EDE_CBC_SHA TLS_RSA_WITH_DES_CBC_SHA Suggested Compression Algorithm: NONE 服务器响应 服务器收到客户端的hello消息后，同样以hello消息应答：
Server Hello 服务器向客户端发送Server Hello，该消息包括以下内容：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/242075464504c3371ebafc1b73bacf89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/292debec00cfa34f9da5d623a9e73208/" rel="bookmark">
			解决uniapp  textarea标签快速输入时光标抖动或闪现的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题长这样
问题代码长这样
&lt;textarea placeholder="请输入组织介绍" class="info-cell-text" maxlength="600" v-model="form.orgIntroduce"&gt;&lt;/textarea&gt; 解决代码长这样
&lt;textarea placeholder="请输入组织介绍" class="info-cell-text" maxlength="600" :value="form.orgIntroduce"&gt;&lt;/textarea&gt; 解决效果长这样
究其原因是因为 v-model 好像有点不友好 换个写法即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0aad04b9b623b16a8e11a60337ff0a4d/" rel="bookmark">
			类的五种方法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 Python中类的实例方法、类方法、自由方法、静态方法、保留方法进行简要总结。
一、实例方法 实例对象的方法，由各实例对象独享。
注意：实例方法采用&lt;对象名&gt;.&lt;方法名&gt;（）形式使用，其等价于&lt;类名&gt;.&lt;方法名&gt;（对象名）。
二、类方法 类方法：类对象的方法，由所有实例对象共享。
注意：类方法只能操作类属性和其他类方法，不能操作实例属性和实例方法。采用&lt;类名&gt;.&lt;方法名&gt;（）或者&lt;对象名&gt;.&lt;方法名&gt;（）形式使用。
三、自由方法 自由方法：定义在类命名空间中的一个普通函数，由类所在命名空间管理，类对象独享。
注意：不需要cls或者self这样的参数，可以无参。只能操作类属性和类方法，不能操作实例属性和实例方法。采用&lt;类名&gt;.&lt;自由方法名&gt;（）的形式使用。
四、静态方法 静态方法：定义在类中的普通函数，能够被类对象和实例对象所共享。
注意：可以无参。只能操作类属性和其他类方法，不能操作实例属性和实例方法。采用&lt;类名&gt;.&lt;静态方法名&gt;（）或者&lt;对象名&gt;.&lt;静态方法名&gt;（）形式使用。
五、保留方法 保留方法：由双下划线开始和结束，保留使用，如__name__()。
class Democlass: def __init__(self,name): self.name = name def getName1(self): #实例方法 return "类的实例方法" @classmethod #类方法装饰器 def getName2(cls): return "类的类方法" def getName3(): return "类的自由方法" @staticmethod #静态方法装饰器 def getName4(): return "类的静态方法" def __name__(self): return "类的保留方法" dc1 = Democlass("老王") print("类的实例方法：",dc1.getName1(),Democlass.getName1(dc1)) print("类的类方法：",dc1.getName2(),Democlass.getName4()) print("自由方法：",Democlass.getName3()) print("类的静态方法：",dc1.getName4(),Democlass.getName4()) print("类的保留方法：",dc1.__name__()) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a4abc5f15fd21d02e3e3fe9f01d9036/" rel="bookmark">
			为什么top -Hp pid 查询的running数是0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这可能是因为你使用的是"top"命令的一个选项，它会统计进程中每个线程的CPU使用情况。如果你使用了"-H"选项，那么"top"命令会显示每个线程的CPU使用情况，而不是每个进程的CPU使用情况。因此，"running"数字可能会变成0，因为它只会显示每个线程的CPU使用情况，而不是整个进程的CPU使用情况。
如果你想查看进程的CPU使用情况，可以使用"top"命令的"-p"选项，并且不要使用"-H"选项。例如，你可以运行"top -p pid"来查看指定进程的CPU使用情况。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36cdb728dcf796fd397b028b475fdfa6/" rel="bookmark">
			【购物车项目】代码&#43;页面&#43;连接数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主界面 个人中心界面 ， 数据库表设计 就不多说，直接上代码 他们的顺序是register.jsp→login.jsp→index.jsp→dogwc.jsp→index.jsp register.jsp和doregister.jsp &lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;用户注册&lt;/title&gt; &lt;style&gt; #a { width:50%; height:200px; border: 1px dashed ; background-color:lightyellow; text-align:center; } body{ background-color:lightblue; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="doregister.jsp" method="post" align="center"&gt; 用户名:&lt;input type="text" name="uname"&gt;&lt;br&gt; 密码:&lt;input type="password" name="upwd"&gt;&lt;br&gt; 备注:&lt;textarea rows="" cols="" name="uinfo"&gt; &lt;/textarea&gt;&lt;br&gt; &lt;input type="submit" value="注册"&gt; &lt;input type="reset" value="重置"&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; &lt;%@page import="com.zking.biz.imp.Imp_UserBiz"%&gt; &lt;%@page import="com.zking.biz.IUserBiz"%&gt; &lt;%@page import="com.zking.entity.User"%&gt; &lt;%@page import="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36cdb728dcf796fd397b028b475fdfa6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d63b7785030a860f4cc0e3800787063/" rel="bookmark">
			jsp登录注册代码（增删改查&#43;网页&#43;数据库）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一·登录注册代码以及效果
doregister.jsp:注册信息弹框
login.jsp:登录
dologin.jsp：与数据库相连、存放登陆的用户
index.jsp:主界面
update.jsp:修改
doup.jsp:修改页面（帮助）
info.jsp：详情
dodel.jsp:删除界面
二·页面跳转的方式以及他们的区别
1、跳转路径并传递数据
2、页面跳转的两种方式和区别
三·其他
1、jdbc连接Oracle
2、乱码
3、添加数据时，获取最新编号
以上就是今天的分享，谢谢大家的观赏！！
一·登录注册代码以及效果 register.jsp:注册
&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;注册&lt;/title&gt; &lt;style&gt; #a { width:50%; height:200px; border: 1px dashed ; background-color:lightyellow; text-align:center; } body{ background-color:lightblue; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="doregister.jsp" method="post"&gt; 用户名:&lt;input type="text" name="uname"&gt;&lt;br&gt; 密码:&lt;input type="password" name="upwd"&gt;&lt;br&gt; 备注:&lt;textarea rows="" cols="" name="uinfo"&gt; &lt;/textarea&gt;&lt;br&gt; &lt;input type="submit" value="注册"&gt; &lt;input type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d63b7785030a860f4cc0e3800787063/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42c27b68d4a48768afc3e7e27ea623a8/" rel="bookmark">
			cartographer建图配置，使用自己2d数据，正常tf显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装cartographer 安装链接
一、播放bag需要加 --clock rosbag play --clock XXX.bag 二、配置launch文件 2.1、官方demo_backpack_2d.launch文件 &lt;launch&gt; &lt;param name="/use_sim_time" value="true" /&gt; &lt;!-- 运行播放bag包 变量为true --&gt; &lt;!-- 运行数据是实时传感器发布的， 变量为false --&gt; &lt;include file="$(find cartographer_ros)/launch/backpack_2d.launch" /&gt; &lt;node name="rviz" pkg="rviz" type="rviz" required="true" args="-d $(find cartographer_ros)/configuration_files/demo_2d.rviz" /&gt; &lt;!-- &lt;node name="playbag" pkg="rosbag" type="play" args="clock $(arg bag_filename)" /&gt; --&gt;&lt;!-- 我运行其它终端来播放数据 --&gt; &lt;/launch&gt; 2.2、修改backpack_2d.launch &lt;launch&gt; &lt;param name="robot_description" textfile="$(find cartographer_ros)/urdf/backpack_2d.urdf" /&gt; &lt;!-- 下面这句不能删除 --&gt; &lt;node name="robot_state_publisher" pkg="robot_state_publisher" type="robot_state_publisher" /&gt; &lt;node name="cartographer_node" pkg="cartographer_ros" type="cartographer_node" args=" -configuration_directory $(find cartographer_ros)/configuration_files -configuration_basename backpack_2d.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42c27b68d4a48768afc3e7e27ea623a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bec0c37ff70efc082568e7faa327c7cb/" rel="bookmark">
			PIL，cv2读取类型及转换，以及PIL，numpy，tensor格式以及cuda，cpu的格式转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PIL，cv2读取类型，以及PIL，numpy，tensor格式以及cuda，cpu的格式转换 一、PIL，cv2读取数据图片以及之间的转换二、PIL，数组类型以及tensor类型的转换1、PIL转换为tensor类型（包含CPU和GPU）2、数组转换为tensor类型（包含CPU和GPU）3、tensor类型转换为数组类型4、tensor、数组类型转换为PIL类型 三、CPU tensor类型与GPU tensor类型的转换四、对二和三进行一个总结 一、PIL，cv2读取数据图片以及之间的转换 这里先列个表格方便理解清楚：
cv2PIL读取a=cv2.imread()a=Image.open()读取类型数组类型PIL类型读取颜色通道BGRRGB（这里需要注意的是当图像格式为RGBA时，PIL读取的是RGBA）读取尺寸排列（H,W,C）（W,H,C）显示图片cv2.imshow(“a”, a)
cv2.waitKey (0)
a.show()相互之间转换显示Image.fromarray(cv2.cvtColor(img,
cv2.COLOR_BGR2RGB))a=numpy.array(a)#先转换为数组
a=cv2.cvtColor(a,cv2.COLOR_RGB2BGR)
#转变颜色通道转换为数组类型cv2读取的就是数组类型a = numpy.array(a) 直接来看代码：
#cv2显示图像 img_path="E:\expression_recognition\\1.jpg" img_cv2 = cv2.imread(img_path) # cv2读取的是数组类型 BGR H W C cv2.imshow("img_cv2", img_cv2) cv2.waitKey (0) #PIL显示图像 img_path="E:\expression_recognition\\1.jpg" img_PIL = Image.open(img_path) # PIL读取的是PIL类型 RGB W H C img_PIL.show() #cv2转变为PIL进行图像显示 img_path="E:\expression_recognition\\1.jpg" img_cv2 = cv2.imread(img_path) # cv2读取的是数组类型 BGR H W C img_cv2_PIL = Image.fromarray(cv2.cvtColor(img_cv2,cv2.COLOR_BGR2RGB)) img_cv2_PIL.show() #PIL转变为cv2进行图像展示 img_path="E:\expression_recognition\\1.jpg" img_PIL = Image.open(img_path) # PIL读取的是PIL类型 RGB W H C img_PIL = numpy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bec0c37ff70efc082568e7faa327c7cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db934c26eac402a6ff9c89e7680f23d2/" rel="bookmark">
			flutter&#43;dart配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		dart搭建 1、下载dart的sdk windows（推荐）：
http://www.gekorm.com/dart-windows/ mac：
安装brew工具 http://brew.sh/brew tap dart-lang/dartbrew install dart 2、dart开发工具 IDEA、Webstorm、Atom、Vscode等
3、Vscode配置 下载 Dart 扩展下载 Code Runner 扩展（用于dart项目运行） dart语法及使用 Dart命名规范
1、变量名称必须由数字、字母、下划线和美元符($)组成。
2、注意：标识符开头不能是数字
3、标识符不能是保留字和关键字。
4、变量的名字是区分大小写的如: age和Age是不同的变量。在实际的运用中,也建议,不要用一个单词大小写区分两个变量。
5、标识符(变量名称)一定要见名思意 ：变量名称建议用名词，方法名称建议用动词
1、dart的数据类型 数组.where(判断条件)：返回所有符合条件的值
数组.any(判断条件)：若有任意一个符合条件的值则返回true，反之返回false
数组.every(判断条件)：所有值均符合条件返回true，反之返回false
Numbers(数值)
（1）int--------------整数
（2）double--------双精度数（表示64位(双精度)浮点数）String(字符串)
''' '''可定义多行变量Boolean(布尔)List(数组)
数组.add(数据)：添加数据
数组.reversed.toList()：数组倒序
数组.addAll(数组)：拼接数组
数组.remove(数据)：删除数据
数组.removeAt(数据索引)：删除数组中该索引的数据
数组.fillRange(开始索引, 结束索引, 新值)：将开始索引与结束索引之间的数据替换为新值
数组.insert(索引, 新值)：在索引处插入新值
数组.insertAll(索引, 新数组)：在索引处拼接新数组
4.1. 定义 指定类型 的数组：
List strList = &lt;String&gt;['哈哈', '哈哈哈', '哈哈哈哈']; print(strList); // 输出: [哈哈, 哈哈哈, 哈哈哈哈]
4.2. 定义 固定长度 的数组：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db934c26eac402a6ff9c89e7680f23d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c98a22f65e214e35685a0765e01d709/" rel="bookmark">
			基于TCP/UDP协议的聊天室
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本项目采用C/S架构模型，主要运用的技术如下，采用sqlite3数据库来存储信息，TCP协议传输数据，通过多线程方式的处理客户端的需求，调用系统提供的各种函数接口来实现的。
优化的地方：频繁的创建和销毁线程比较浪费资源，可以利用线程池来解决。利用IO的多路复用和reactor模型来提高。
注意：在Linux下运行需要加库文件和数据库。
创建文件，client.h,client.c;server.h,server.c
编译：gcc client.c -pthread -lsqlite3
gcc server.c -pthread -lsqlite3
运行：./a.out
需要修改的地方，一个是client.c,server.h
基于TCP/UDP协议的聊天室 客户端客户端头文件代码如下：客户端实现代码如下： 服务器端服务器端头文件代码如下：服务器端实现代码如下： 登录界面如下：
主要功能如下：
功能我就不一一展示了，这个我测试过了，没问题的。想测试的自己去测试下就知道了。
客户端 客户端头文件代码如下： #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;time.h&gt; #include &lt;stdlib.h&gt; #include &lt;sqlite3.h&gt; #include &lt;pthread.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; #include &lt;signal.h&gt; #define PORT 9999 #define SIZE 20 struct Usr { char name[SIZE]; //用户名 int socket; int flag;//用来判断该用户是否被禁言，没有被禁设为0，被禁设为1 }; struct Msg { struct Usr usr[SIZE]; //用户数 char msg[1024]; //记录消息 char buf[1024]; // char name[SIZE]; //帐号 char fromname[SIZE];//发送者 char toname[SIZE]; //接受者 char password[SIZE];//密码 int cmd; //权限的标志位 int filesize; //文件大小 int flag; //用来判断用户权限 0代表普通用户，1代表超级用户 }; //动态显示进度条 int show_login(); //动态显示进度条 int show_connect(); //信号注册函数 void sigfun(int signo); //显示空行 void display_line(); //显示主界面 void maininterface(); //显示普通用户界面 void cominterface(struct Msg *msg); //显示超级用户界面 void supinterface(struct Msg *msg); //查看在线用户 void see_online(int socketfd, struct Msg *msg); //保存一条聊天记录 void insert_mysql(struct Msg *msg); //群聊 void chat_group(int socketfd, struct Msg *msg); //发送悄悄话 void chat_private(int socketfd, struct Msg *msg); //删除聊天记录 void del_personsql(); //查看聊天记录 void see_record(); //获取文件大小 int file_size(char* filename) ; //上传文件 void send_file(int socketfd, struct Msg *msg); //注销当前用户 void logout(int socketfd, struct Msg *msg); //设置禁言 void forbid_speak(int socketfd, struct Msg *msg); //解除禁言 void relieve_speak(int socketfd, struct Msg *msg); //踢出聊天室 void kickout_room(int socketfd, struct Msg *msg); //下线 void off_line(int socketfd, struct Msg *msg); //超级用户 void superusr(int socketfd, struct Msg *msg); //下载文件 void download_file(int socketfd, struct Msg *msg); void fun(int socketfd, struct Msg *msg); //普通用户 void commonusr(int socketfd, struct Msg *msg); //创建聊天记录数据库 void set_mysql(); //注册函数 void reg(int socketfd); //专门用来读取服务器 void * readMsg(void *v); //登陆函数 void login(int socketfd); // 客户端向服务器发送数据 void ask_server(int socketfd); 客户端实现代码如下： #include "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c98a22f65e214e35685a0765e01d709/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fcc381c45bfe8a60a6f99fa6277ef5c/" rel="bookmark">
			模型预测控制（MPC）算法原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		模型预测算法是在欧美等国家兴起的应用于工业领域的一种优化控制算法。目前经过多年的发展，在工业领域、智能控制领域等都有应用。随着算法的理论的完善，其已经成为工业领域内经常使用的一种经典算法。虽然在各个领域算法的应用存在差异。
但他们都遵循预测模型、滚动优化、和反馈校正的基本原理。并且，近年来在汽车工业尤其是在车辆智驾驶技术上，模型预测算法的应用越来越受欢迎。很多科研机构利用了模型预测的原理进行了智能车辆的轨迹跟踪控制研究，下面将详细阐述模型预测算法的原理。
（1）预测模型 预测模型是模型预测控制的基础，它能够通过控制系统中被控平台提供的当前系统状态信息，再加上未来的控制输入变量，预测到未来的被控平台的状态。
预测模型的形式没有确定的形式要求，可以是状态空间方程、传递函数也可以是阶跃响应模型、脉冲响应模型模糊模型等。根据被控对象和需要预测的状态选择合适的预测模型。
对于车辆方向而言，模型预测控制选择状态空间模型比较合适。
（2）滚动优化 预测控制中的优化与通常的离散最优控制算法不同，不是采用一个不变的全局最优目标，而是采用滚动式的有限时域优化策略。
在每一采样时刻，根据该时刻的优化性能指标，求解该时刻起有限时段的最优控制率。计算得到的控制作用序列也只有当前值是实际执行的，在下一个采样时刻又重新求取最优控制率。
也就是说，优化过程不是一次离线完成的，而是反复在线进行（即在每一采样时刻，优化性能指标只涉及从该时刻起到未来有限的时间，而到下一个采样时刻，这一优化时段会同时向前推移）。
通过滚动优化策略，始终在实际的基础上建立新的优化目标，兼顾了对未来有限时域内的理想优化和实际不确定性的影响。这要比建立在理想条件下的传统最优控制更加实际和有效。
（3） 反馈校正 预测控制求解的是一个开环优化问题。在预测控制中，采用预测模型进行过程输出值的预估只是一种理想的方式，对于实际过程，由于存在非线性、时变、模型失配和干扰等不确定因素，使基于模型的预测不可能准确地与实际相符。
因此，在预测控制中，通过输出的测量值与模型的预估值进行比较，得出模型的预测误差，再利用模型预测误差来校正模型的预测值，从而得到更为准确的将来输出的预测值。正是这种由模型加反馈校正的过程，使预测控制具有很强的抗干扰和克服系统不确定的能力。不断根据系统的实际输出对预测输出做出修正，使滚动优化不但基于模型，而且利用反馈信息，构闭环优化控制。
跟据上面所提三要素（预测模型、滚动优化、反馈矫正/误差补偿），模型预测算法的控制原理如上图 所示。
控制过程中，存在一条期望的参考轨迹。在整个控制时域中，令 k 时刻为当前时刻。控制器结合当前系统的测量值和预测模型，预测未来一段时域内 [K,K+p]（也被称为预测时域）系统的输出。
通过求解满足目标函数以及各种约束的优化问题，得到 [K,K+M]（这段时间为控制时域，控制时域的时间段要比预测时域时间段要短）时域内的一系列控制变量序列。并将该时控制系列中的第一个元素作为被控对象的实际控制量，当来到下一时刻 k +1时重复上述过程。如此滚动的完成一个个带约束的优化问题。以此实现对被控对象的持续控制。
模型预测控制原理框架
模型预测控制器原理框图如上图所示，包含了 MPC 控制器、被控车辆、状态估计三个基本模块。
1.MPC控制器结合预测模型、目标函数和约束条件进行最优化求解。得到当前时刻的最优控制序列；
2.将控制序列的第一个元素作为控制变量输入到被控平台中，被控平台执行接受到的控制指令，然后将当前时刻的状态量观测值输入给状态估计器；
3.状态估计器将会对于那些没有办法直接观测的状态量进行估计，如地面附着系数。将状态量输入到 MPC 控制器，再次进行最优化求解，得到下一时刻被控平台所需的控制变量。
如此循环，构成了完整的模型预测控制过程。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e55ecf645b3ecf5419c4b3d78c09c26f/" rel="bookmark">
			Java集合如何遍历删除指定元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、删除List
2、删除Set
3、删除Map
注意事项：
1、删除List public class ListDemo { public static void main(String[] args) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add("张三"); list.add("李四"); list.add("王五"); list.add("赵六"); list.forEach(System.out::println); for(String str : list) { if ("李四".equals(str)) { list.remove(str); } } list.forEach(s -&gt; { System.out.println("第1次删除后：" + list); }); } } 以上代码运行会发生并发修改异常ConcurrentModificationException，正确的方式是：
public class ListExample { public static void main(String[] args) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add("张三"); list.add("李四"); list.add("王五"); list.add("赵六"); System.out.println(list); // 方法1：迭代器遍历 Iterator&lt;String&gt; iterator = list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e55ecf645b3ecf5419c4b3d78c09c26f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fa7faba1c2521fd6f50bc659025e09a/" rel="bookmark">
			IDEA 版本更新为2020.1双击打不开的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打开我的电脑C盘
分别删除里面idea 下对应的版本就可以了
如果就可以了
如果有问题可以留言
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa5453efe7eed81998e05fd000c791ed/" rel="bookmark">
			单元测试Mock的时候出现org.mockito.exceptions.misusing.NotAMockException
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 @InjectMocks XXXX xxxx; Mockito.doNothing().when(xxxx).init(); org.mockito.exceptions.misusing.NotAMockException: Argument passed to when() is not a mock!
Example of correct stubbing:
doThrow(new RuntimeException()).when(mock).someMethod();
这是因为我们在验证某些结果的时候，我们的对象使用被@InjectMocks注解了，此时并不是真实的Mock，此时我们可以在@InjectMocks上面加上一个@Spy注解就可以了，此时它就是一个真实的mock了
@InjectMocks @Spy XXXX xxxx; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc4fdcec9921917351b1591fb2a5ac09/" rel="bookmark">
			【解决git报错 10054】OpenSSL SSL_read: Connection was reset, errno 10054
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用git获取github上代码时报错：OpenSSL SSL_read: Connection was reset, errno 10054
(此时又必须开着vpn才能访问到github)
参考网上的回答，成功解决问题：
修改设置，解除ssl验证git config --global http.sslVerify "false" 此时，再执行git操作即可。
注：设置后关闭当前git窗口，重新打开再执行git操作
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd2bfcfa0d6486830cb475b965a479e2/" rel="bookmark">
			智能合约Smart Contract技术详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 合约编写基本介绍构造方法ipfsmint提现白名单合约前端 部署验证合约代码前端和合约交互准备工作获取已经mint了的数量mint 合约编写 建议读者先了解下solidity，这里推荐CryptoZombies，还是比较详细的。
ok当你大概知道自己在做什么之后，我们就可以开始编写智能合约了，首先我们需要一个编译器，我是用的web ide remix，当然他也有桌面版，使用起来都是一样的，web版本的话记得做备份，如果仅靠浏览器缓存来做备份的话，很容易吃亏找不到代码了等会。
基本介绍 先看几个关键常量
uint public constant MAX_TOKENS = 2000; uint private constant TOKENS_RESERVED = 4; //normal whitelist price uint public white_price = 0.008 ether; //normal price uint public price = 0.015 ether; uint256 public constant MAX_MINT_PER_TX = 4; bool public isSaleActive = false; uint256 public totalSupply; mapping(address =&gt; uint256) private mintedPerWallet; string public baseUri; string public baseExtension = ".json"; MAX_TOKENS指的是该合约最大能mint的数量
white_price指的是白名单价格（如果你的合约有白名单的话），注意这里价格会带上ether关键字后缀，表示每一个nft的单价
price指的是普通价格
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd2bfcfa0d6486830cb475b965a479e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4db164deb0c3172388edfe2fdf914e4d/" rel="bookmark">
			Linux找不到yum命令，没有已启用的仓库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用场景：Linux软件安装 我们都知道Linux操作系统中的安装包格式为.rpm文件，但是在终端中直接安装可能会导致各种问题。所以为了方便，我们使用yum命令进行安装，因为yum命令用于自动化安装配置Linux软件，并可以自动解决依赖问题。
此命令需要root权限和互联网，加-y是为了无需手动确认安装或卸载过程
其格式为：yum -y [install/remove/search] 软件名
问题1描述 使用yum命令安装wget的时候提示找不到yum命令
原因分析：
1.没有安装yum
2.可能连build-essential程序包也没有
解决方案： 1.安装build-essential程序包，输入以下两行代码
sudo -s
apt-get install build-essential
2.安装yum
apt-get install yum
问题2描述 安装完成yum，再次尝试安装wget，提示没有启用的仓库。根据提示查询已经拥有的仓库以后，显示仓库为0
原因分析： 使用yum的这种安装方式在centos中才可以，由于我使用的是Ubuntu，其默认软件包管理器不是yum，安装软件需要使用apt-get，所以会遇到问题
解决方案： 使用apt-get语句进行安装即可 sudo apt-get install wget
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56e31dfef13f07f2c6f0e4945b7ed08c/" rel="bookmark">
			Excel函数公式大全—MATCH函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EXCEL系列文章目录 Excel系列文章是本人亲身经历职场之后萌发的想法，为什么Excel覆盖如此之广，几乎每个公司、学校、家庭都在使用，但是它深藏的宝藏功能却很少被人使用，PQ、BI这些功能同样适用于数据分析；并且在一些需要简单及时的数据分析项目前，Excel是完胜python、R、SPSS这些科学专业的软件的。因此决心开启Excel篇章。
数据分析为什么要学Excel
Excel图表美化—表格美化
Excel函数公式大全—IF函数
Excel函数公式大全—IF家族函数
Excel函数公式大全—VLOOKUP函数
Excel函数公式大全—MATCH函数
Excel函数公式大全—INDEX函数
Excel函数公式大全—HLOOKUP函数
Excel函数公式大全—LOOKUP函数
Excel函数公式大全—MATCH函数 EXCEL系列文章目录前言一、MATCH函数语法二、图解算法三、实用案例1、新建数据2、案例展示横向查找：竖向查找： 总结 前言 match()一个excel函数中高手级别的存在，基本不会自己露面，却在绝大多数的组合函数中看到它的存在，应为得它帮助，使得很多原本平平无奇的小函数一跃翻身；可匹级于那些高级函数。今天将带大家走近match()，介绍其的基本内核；基础功练好了，何愁大功不成。也希望大家将想学习了解的函数留言 ，在后面的文章里我们一起学习分享 ！
一、MATCH函数语法 MATCH(lookup_value, lookup_array, [match_type])
提示: MATCH函数是查找条件在查找区域里的什么位置！！！当您需要项目在区域中的位置而非项目本身时，使用 MATCH 而不是 LOOKUP 函数之一。 例如，您可以使用 MATCH 函数提供 INDEX 函数的 row_num 参数值。 参数名称说明lookup_value （必填）查找条件。为需要在数据表中查找的数值。可以为数值(数字、文本或逻辑值)或对数字、文本或逻辑值的单元格引用。lookup_array （必填）查找区域。可能包含所要查找的数值的连续单元格区域。Lookup_array应为数组或数组引用。match_type （选填）查找方式。为数字-1、0或1。match-type指明MicrosoftExcel如何在lookup_array中查找lookup_value。 1、如果match_type为1,函数MATCH查找小于或等于lookup_value的最大数值。lookup_array必须按升序排列：…、-2、-1、0、1、2、…、A-Z、FALSE、TRUE。
2、如果match_type为0,函数MATCH查找等于lookup_value的第一个数值。lookup_array可以按任何顺序排列。
3、如果match_type为-1,函数MATCH查找大于或等于lookup_value的最小数值。Lookup_array必须按降序排列：TRUE、FALSE、Z-A、…、2、1、0、-1、-2、…,等等。
4、如果省略match_type,则假设为1。
5、查找文本值时,函数MATCH不区分大小写字母。
6、如果函数MATCH查找不成功,则返回错误值#N/A。
7、如果match_type为0且lookup_value为文本,lookup_value可以包含通配符、星号(*)和问号(?)。星号可以匹配任何字符序列；问号可以匹配单个字符。
二、图解算法 公式解释：在 B3 到 B13 中精准查找 H9 第一次出现的位置。
三、实用案例 1、新建数据 为展示函数效果；数据均为Excel函数生成：
2、案例展示 横向查找： =MATCH([@学科],表3[#标题],0)
横向匹配无非便是选着的查询区域是横向的。经常与vlookup结合，自动查找列数。 竖向查找： =MATCH([@姓名],表3[姓名],0)
横向匹配无非便是选着的查询区域是横向的。经常与index结合，从而能与vlookup平起平坐。
总结 match（）作为一个万能的存在，但多数都是使用上面的两个功能，理解起来也并不难。希望大家能多练习练习，后续的文章也还会推出一些组合使用的案例。
也希望大家将想学习了解的函数留言 ，在后面的文章里我们一起学习分享 ！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec09bae8c1b826558b4ff1333bea4a3c/" rel="bookmark">
			Excel函数公式大全—IF家族函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EXCEL系列文章目录 Excel系列文章是本人亲身经历职场之后萌发的想法，为什么Excel覆盖如此之广，几乎每个公司、学校、家庭都在使用，但是它深藏的宝藏功能却很少被人使用，PQ、BI这些功能同样适用于数据分析；并且在一些需要简单及时的数据分析项目前，Excel是完胜python、R、SPSS这些科学专业的软件的。因此决心开启Excel篇章。
数据分析为什么要学Excel
Excel图表美化—表格美化
Excel函数公式大全—IF函数
Excel函数公式大全—IF家族函数
Excel函数公式大全—VLOOKUP函数
Excel函数公式大全—MATCH函数
Excel函数公式大全—INDEX函数
Excel函数公式大全—HLOOKUP函数
Excel函数公式大全—LOOKUP函数
Excel函数公式大全—IF家族函数 EXCEL系列文章目录前言一、IFS()函数函数语法实战案例 二、IFNA()函数函数语法实战案例 三、IFERROR()函数函数语法实战案例 总结 前言 if函数是最基本，也算是最常用的函数之一；同样作为if家族的还有（ifs、ifna、iferror）三个if 家族函数，由于一些函数存在兼容信问题，所以使用的是office2019版本进行演示；如果运行不出来先看看自己的版本。 如需要2019版本三联私聊，亲手奉上
一、IFS()函数 用于多条件判断函数；但个人对此函数不是很推荐，因为需要按正确的顺序输入多个条件，这样一来，构建、测试和更新会变得十分困难；也不是很方便阅读。
函数语法 IFS(logical_test1, value_if_true1, [logical_test2, value_if_true2], [logical_test3, value_if_true3],…)
IFS 函数检查是否满足一个或多个条件，且返回符合第一个 TRUE 条件的值。 IFS 可以取代多个嵌套 IF 语句，并且有多个条件时更方便阅读。 参数名称说明logical_test1 （必填）计算结果为 TRUE 或 FALSE 的条件value_if_true1 （必填）当 logical_test1 的计算结果为 TRUE 时要返回结果。可以为空logical_test2 （选填）计算结果为 TRUE 或 FALSE 的条件value_if_true2 （选填）当 logical_test1 的计算结果为 TRUE 时要返回结果。可以为空 =IFS(A2&gt;89,“A”,A2&gt;79,“B”,A2&gt;69,“C”,A2&gt;59,“D”,TRUE,“F”)
也即如果（A2 大于 89，则返回“A”，如果 A2 大于 79，则返回“B”并以此类推，对于所有小于 59 的值，返回“F”）。
实战案例 还是一样的人 😐 不一样的数，如何给他们划分等级呢？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec09bae8c1b826558b4ff1333bea4a3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd67e4ca9d0c27675d43a54d49b2a7ef/" rel="bookmark">
			Python基础知识——Pandas数据分析篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pandas数据结构 Pandas有3种数据结构：系列（Series）、数据帧（DataFrame）和面板（Panel），这些数据结构可以构建在NumPy数组之上
1、Series(系列)——具有均匀数据的一维数组结构 pandas.Series(data, index, dtype, copy)
2、DataFrame(数据帧)——具有异构数据的二维数组 pandas.DataFrame(data, index, coloumns, dtype, copy)
3、Panel(面板)——具有异构数据的三维数据结构 pandas.Panel(data, items, major_axis, minor_axis, dtype, copy)
Series
# Series import pandas as pd import numpy as np data = np.array(['a', 'b', 'c', 'd', 'e']) s1 = pd.Series(data) print('默认索引：') print(s1) print('#####################') s2 = pd.Series(data, index=[100, 101, 102, 103, 200]) # 指定索引 print('指定索引：') print(s2) print('#####################') print('索引s1[0:2]=') # 左闭右开 print(s1[0:2]) print('#####################') print('索引s2[[100, 102]]=') print(s2[[100, 102]]) # 进行选择 print('#####################') print('索引s2[100]=', s2[100]) print('#####################') print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd67e4ca9d0c27675d43a54d49b2a7ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/616c0ed25cb6cb13b1ce416adf37a6e4/" rel="bookmark">
			设计模式--04--结构型--04--外观模式及与代理的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景一：我饿了，去饭店点菜， 我不需要关心菜是怎么做出来的， 只要最后能吃到就好（外观模式）
场景二：我是个外地人， 连饭店都不知道在哪，于是找了个当地的代理，叫他帮我去点菜，我无需关心代理是怎么找到饭店，以及怎么点菜的，我只要结果（代理模式）
综上， 代理模式相当于更包装化的外观模式， 代理可以调用外观。
转载自：深入浅出，对于代理模式的理解（代理模式与外观模式的区别）_来老铁干了这碗代码的博客-CSDN博客_代理模式和外观模式区别
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c0cf2a1faf4e6080185f8177065c37a/" rel="bookmark">
			SSH远程连接报错:Permission denied, please try again.的解决办法【备忘】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 当使用 SSH 登录Linux 服务器时，如果是 root 用户，即便正确输入密码，也会出现如下错误信息“Permission denied, please try again.”
但非root用户可以正常登录。
问题原因 服务端SSH 服务配置了禁止root用户登录策略。
处理办法 要解决此问题，请进行如下配置检查和修改：
1、进入系统。
2、通过 cat /etc/ssh/sshd_config 查看是否包含类似如下配置：
PermitRootLogin no
若是no，需要修改成yes
PermitRootLogin yes
3、修改后重启 SSH 服务： service sshd restart
4、尝试再次使用 root 用户登录服务器，登录成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df63a28abeb30827fa9af8ef13fa8d14/" rel="bookmark">
			mysql知识点总结（网安必备）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
数据库介绍
数据库基本概念
数据库类型
MySql数据库管理系统
SQL语言
概述
常见操作
表的完整性约束
非外键约束
外键约束
单表查询
函数
多表查询
事务
事务隔离级别
视图
数据库介绍 数据库基本概念 数据：所谓数据（Data）是指对客观事物进行描述并可以鉴别的符号，这些符号是可识别的、抽象的。它不仅仅指狭义上的数字，而是有多种表现形式：字母、文字、文本、图形、音频、视频等。现在计算机存储和处理的数据范围十分广泛，而描述这些数据的符号也变得越来越复杂了。
数据库：数据库（Database，DB）指的是以一定格式存放、能够实现多个用户共享、与应用程序彼此独立的数据集合。
数据库管理系统：数据库管理系统（Database Management System，DBMS）是用来定义和管理数据的软件。如何科学的组织和存储数据，如何高效的获取和维护数据，如何保证数据的安全性和完整性，这些都需要靠数据库管理系统完成。目前，比较流行的数据库管理系统有：Oracle、MySQL、SQL Server、DB2等。
数据库应用程序：数据库应用程序（Database Application System，DBAS）是在数据库管理系统基础上，使用数据库管理系统的语法，开发的直接面对最终用户的应用程序，如学生管理系统、人事管理系统、图书管理系统等。
数据库系统：数据库系统（Database System，DBS）一般是由数据库、数据库管理系统、数据库应用程序、数据库管理员和最终用户构成。其中DBMS是数据库系统的基础和核心。
数据库类型 关系型数据库 ：将复杂的数据结构用较为简单的二元关系（二维表）来表示。在该类型数据库中，对数据的操作基本上都建立在一个或多个表格上，我们可以采用结构化查询语言（SQL）对数据库进行操作。关系型数据库是目前主流的数据库技术，其中具有代表性的数据库管理系统有：Oracle、DB2、SQL Server、MySQL等。非关系型数据库（NOSQL）：NOSQL（Not Only SQL）泛指非关系型数据库。关系型数据库在超大规模和高并发的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题。NOSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。常见的非关系型数据库管理系统有Memcached、MongoDB，redis，HBase等。 关系型数据库是存储在硬盘上，而非关系型数据库是存储在硬盘，访问速度更快。
MySql数据库管理系统 理ilnaug概述：MySQL是一种开放源代码的轻量级关系型数据库，MySQL数据库使用最常用的结构化查询语言（SQL）对数据库进行管理；MySQL数据库体积小、速度快、成本低、开放源码等优点。
安装好数据库后可以在对应bin目录下cmd登陆mysql。
或者配置环境变量后，直接在cmd登陆。
登陆所用参数：
-h：host主机名。后面跟要访问的数据库服务器的地址；如果是登录本机，可以省略 -u：user 用户名。后面跟登录数据的用户名，第一次安装后以root用户来登录，是MySQL的管理员用户 -p: password 密码。一般不直接输入，而是回车后以保密方式输入。
MySQL 层次：不同项目对应不同的数据库组成 - 每个数据库中有很多表 - 每个表中有很多数据 退出数据库：可以使用quit或者exit命令完成，也可以用\q; 完成退出操作 。
数据库的卸载：在服务中停止mysql服务，然后再控制面板中卸载mysql软件。删除所有的mysql文件夹。（C:\Program Files\MySQL；C:\ProgramData\MySQL。）；把环境变量删除。
SQL语言 概述 数据库管理人员（DBA）通过数据库管理系统（DBMS）可以对数据库（DB）中的数据进行操作，操作用到的就是sq语言。
SQL（Structured Query Language）是结构化查询语言的简称，它是一种数据库查询和程序设计语言，同时也是目前使用最广泛的关系型数据库操作语言。在数据库管理系统中，使用SQL语言来实现数据的存取、查询、更新等功能。
SQL语言可以分为五个部分： 数据查询语言（Data Query Language，DQL）：DQL主要用于数据的查询，其基本结构是使用SELECT子句，FROM子句和WHERE子句的组合来查询一条或多条数据。数据操作语言（Data Manipulation Language，DML）：DML主要用于对数据库中的数据进行增加、修改和删除的操作，其主要包括：INSERT：增加数据、 UPDATE：修改数据、DELETE：删除数据数据定义语言（Data Definition Language，DDL）：DDL主要用针对是数据库对象（数据库、表、索引、视图、触发器、存储过程、函数）进行创建、修改和删除操作。其主要包括：CREATE：创建数据库对象、ALTER：修改数据库对象、DROP：删除数据库对象数据控制语言（Data Control Language，DCL）：DCL用来授予或回收访问 数据库的权限，其主要包括： GRANT：授予用户某种权限、REVOKE：回收授予的某种权限事务控制语言（Transaction Control Language，TCL）：TCL用于数据库的事务管理。其主要包括：START TRANSACTION：开启事务、COMMIT：提交事务、ROLLBACK：回滚事务、SET TRANSACTION：设置事务的属性 。 常见操作 创建数据库表:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df63a28abeb30827fa9af8ef13fa8d14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0546be0f36c163476cd9d457378c85c6/" rel="bookmark">
			【JWT在线解密为什么不用提供密钥也可以】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无密钥解码token令牌的header和payload 这为什么JWT解释上代码本次使用的token代码复现尾解析报错是为啥token的安全保证（如何验证） 这为什么 不知道大家在接触JWT的token后有没有想过为什么我用了各种加密方式加密后的token在不告诉在线解密工具密钥的时候他就能解密出来我token里面的信息。而且大多数解密工具在解密时也不需要我们提供密钥。
JWT解释 百度一下你就知道 JWT 时JSON WEB TOKEN ，也就是说是一个json令牌
JWT（JSON Web Token）是一种用于双方之间传递安全信息的简洁的、URL安全的表述性声明规范。它由三个部分组成：头部，载荷和签名。
头： 头部包含了令牌的类型和加密算法的信息。体： 载荷是存放有效信息的地方。它可以包含用户的相关信息，例如用户的ID、用户名等。尾: 签名是用来验证令牌的完整性的。它是头部和载荷的结合，通过指定的秘钥进行加密生成的。 上代码 本次使用的token eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyTmFtZSI6ImFkbWluIiwidWlkIjoiMmIyMmJjNjUtZGU5YS00ZGRlLWJjZDctNjMyNWQ0NWViNWQxIiwibG9naW5UaW1lIjoxNjcyNzM5NDk4MjEyLCJleHBpcmVUaW1lIjoxNjcyNzM5Nzk4MjEyfQ.8wrNGKSCrdUg_sz8JyVgsxpHigFJ9pk_gs4rwc5T5v4 在线解析后的结果是
代码复现 从上面图中的代码可以看出，我在不借助密钥的情况下，仅使用base64就已经获得的头和体 这里基本上可以猜测出在线解析JWT的大致逻辑了，但为什么在解析尾的时候报错了。
尾解析报错是为啥 明明三段的编码都是base64，但前两段成功了，最后一段报错。
这是因为在JWT的生成时的规则不是三段都是一样的base64。
JWT在生成token的时候是会先将头和体进行普通的base64然后再用这两个已经编码过的字符串去生成签名。但签名后 (第三段不是token整体) 的字符串也是经过编码的。
至于不一样的base64编码其实是添加了一层url编码
可以冲sign的代码中看出
通过代码截图可以看出，默认传的tue导致是用的encodeUrlSafe，而不是encode所以导致我们解码时部分字符解不出来导致的。
所以当解码签名时应该使用下面代码
public static void main(String[] args) { String token ="eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyTmFtZSI6ImFkbWluIiwidWlkIjoiMmIyMmJjNjUtZGU5YS00ZGRlLWJjZDctNjMyNWQ0NWViNWQxIiwibG9naW5UaW1lIjoxNjcyNzM5NDk4MjEyLCJleHBpcmVUaW1lIjoxNjcyNzM5Nzk4MjEyfQ.8wrNGKSCrdUg_sz8JyVgsxpHigFJ9pk_gs4rwc5T5v4"; String[] split = token.split("\\."); System.out.println("头："+ split[0]); System.out.println("体："+ split[1]); System.out.println("尾："+ split[2]); System.out.println("解密 base64"); Decoder decoder = Base64.getDecoder(); System.out.println("头："+ new String(decoder.decode(split[0]))); System.out.println("体："+ new String(decoder.decode(split[1]))); System.out.println("尾："+ new String(Base64.getUrlDecoder().decode(split[2]))); } 但结果是这样的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0546be0f36c163476cd9d457378c85c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2625efa7e357d713ca41e4c0d3b9d662/" rel="bookmark">
			mysqldump 导出乱码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原备份命令：
mysqldump --default-character-set=utf8mb4 -h127.0.0.1 -P3306 -uroot -p123456 -c --add-drop-table dbname &gt; D:\MySqlBackup\20230104.sql 原备份命令导出后中文乱码
在原命令中添加 --hex-blob
mysqldump --default-character-set=utf8mb4 -h127.0.0.1 -P3306 -uroot -p123456 -c --add-drop-table dbname --hex-blob &gt; D:\MySqlBackup\20230104.sql 新命令导出文件正常
注：设置字符集后的导出文件可以用Notepad++等工具打开设置字符集，这样也不会乱码，以防万一最好还是加上--hex-blob
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91e46b7bde0c35d283fb73d7ba752e34/" rel="bookmark">
			上采样-反置卷积&amp;线性插值&amp;反池化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上采样 常用的一些上采样的方法：
近邻插值、单线性插值、双线性插值、反卷积、反池化。
最近邻插值：直接取最近坐标的像素映射到输出图像上。 102030152535202530 10203030152535352025303020253030 单线性插值： 已知P1和P2坐标，坐标分别为(X1,Y1),(X2,Y2),要计算在【X1,X2】区间内的某一位置x在直线上的y值。
然后化简后 ​​​​​​​ ​​​​​​​​​​​​​​​​​​​​​
Y1 和Y2分别代表图像中的像素值，公式可改写为
双线性插值： 双线性插值已知四个变量，Q11、Q12、Q22、Q21 分别利用线性插值的方法 计算R1、R2、再利用线性插值的方法计算P。
反卷积 反卷积又称为转置卷积（Transposed Convolution）
首先我们看一下正向卷积的操作。
卷积将4x4的矩阵进行变化得到2X2的矩阵。
现在反卷积即将此操作进行反转，将2X2的矩阵转换为4X4的矩阵。
即将3x3的卷积核进行反转 将卷积核重新排列， 1 4 1 -0- 1 4 3 -0- 3 3 1 -0- 0 0 0 -0-
最后将这个4x16的卷积核进行转置，同时也将2X2的输出矩阵进行拉平。
不同的卷积参数对应的反卷积操作也不尽相同。
反池化 池化分为max pooling和mean pooling mean pooling
max pooling
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4f45ff881adcd19b2788c2ae8804168/" rel="bookmark">
			统一网关Gateway
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网关功能： 身份验证、权限校验服务路由、负载均衡请求限流 网关实现技术： gatewayzuul Zuul是基于Servlet的实现，属于阻塞式编程。而SpringCloudGateway则是基于Spring5中提供的WebFlux，属于响应式编程的实现，具备更好的性能。
搭建网关服务 创建新module，引入Spring Cloud Gateway的依赖和nacos的服务发现依赖
&lt;!--网关依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--nacos服务发现依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; 编写路由配置及nacos地址
server: port: 10010 # 网关端口 spring: application: name: gateway # 服务名称 cloud: nacos: server-addr: localhost:8848 # nacos地址 gateway: routes: # 网关路由配置 - id: user-service # 路由id，自定义，只要唯一即可 # uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址 uri: lb://userservice # 路由的目标地址 lb就是负载均衡，后面跟服务名称 predicates: # 路由断言，也就是判断请求是否符合路由规则的条件 - Path=/user/** # 这个是按照路径匹配，只要以/user/开头就符合要求 路由配置：
路由id：路由的唯一标示
路由目标（uri）：路由的目标地址，http代表固定地址，lb代表根据服务名负载均衡
路由断言（predicates）：判断路由的规则，
路由过滤器（filters）：对请求或响应做处理
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4f45ff881adcd19b2788c2ae8804168/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9b8cc5e803c97bfe161365c420e3ccb/" rel="bookmark">
			Feign配置日志、Feign性能优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 自定义Feign的配置 Feign运行自定义配置来覆盖默认配置，可以修改的配置如下：
类型作用说明feign.Logger.Level修改日志级别包含四种不同的级别：none、basic、headers、fullfeign.codec.Decoder响应结果的解析器http远程调用的结果做解析，例如解析JSON字符串为Java对象feign.codec.Encoder请求参数编码将请求参数编码，便于通过http发送请求feign.Contract支持的注解格式默认是SpringMVC的注解feign.Retryer失败重试机制请求失败的重试机制，默认是没有的，不过会使用Ribbon的重试 一般只需配置日志级别即可。
配置Feign日志有两种方式：
方式一：配置文件方式
全局生效
feign: client: config: default: #default表示全局配置，如果写服务器名，则就是针对某个微服务的配置 logger-level: full #默认为none，还可选择basic、headers、full 局部生效
feign: client: config: userservice: #针对userservice微服务的配置 logger-level: full #默认为none，还可选择basic、headers、full 方式二：Java代码方式
声明一个Bean
public class FeignClientConfiguration { @Bean public Logger.Level feignLogLevel(){ return Logger.Level.BASIC; } } 如果为全局配置，把上面的FeignClientConfiguration类放到@EnableFeignClients的注解中：
@EnableFeignClients(defaultConfiguration = {DefaultFeignConfiguration.class}) 如果为局部配置，则把上面的FeignClientConfiguration类放到@FeignClient的注解中：
@FeignClient(value = "userservice", configuration = FeignClientConfiguration.class) Feign性能优化 feign底层的客户端实现：
URLConnection：默认实现，不支持连接池Apache HttpClient：支持连接池OKHttp：支持连接池 因此优化Feign的性能主要包括：
使用连接池代替默认的URLConnection ​ Feign添加HttpClient的支持：
&lt;!--httpClient的依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt; &lt;artifactId&gt;feign-httpclient&lt;/artifactId&gt; &lt;/dependency&gt; ​ 配置连接池：
feign: client: config: default: # default全局的配置 loggerLevel: BASIC # 日志级别，BASIC就是基本的请求和响应信息 httpclient: enabled: true # 开启feign对HttpClient的支持 max-connections: 200 # 最大的连接数 max-connections-per-route: 50 # 每个路径的最大连接数 日志级别最好使用none或basic 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49524688434643e978337c9a8560bacd/" rel="bookmark">
			OSI参考模型与TCP/IP模型比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TCP/IP模型 — TCP/IP协议簇
TCP/IP分为两种体系结构，一种是分为四层网络接口层、网络层、传输层和应用层；另外一种是分为五层物理层、数据链路层、网络层、传输层和应用层。这两种体系结构都对。
TCP/IP四层模型 — TCP/IP标准模型
TCP/IP五层模型 — TCP/IP对等模型
现在一般在应用中与OSI参考模型相比，使用TCP/IP模型的比较多，因为OSI参考模型①分的太细②分配不均衡
OSI参考模型与TCP/IP模型两者的联系：
相同点： ①两者都是模型化层次化 ②下层对上层提供服务支持 ③每层协议彼此相互独立
不同点：①OSI先有模型才有协议 TCP/IP先有协议才有模型②TCP/IP协议栈只适用于TCP/IP网络③层数量不同
区别：TCP/IP模型支持跨层封装 ，OSI不支持跨层封装。TCP/IP的跨层封装一般应用在直连设备之间的近距离通讯。
PDU — 协议数据单元
在OSI中：
L1PDU （数据在物理层）
L2PDU （数据在数据链路层）
L3PDU
L4PDU
L5PDU
L6PDU
L7PDU
在五层TCP/IP模型中：
应用层 — 数据报文 （在应用层数据叫数据报文）
传输层 — 数据段 （加入源端口号、目标端口号）
网络层 — 数据包 （加入SIP、DIP）
数据链路层 — 数据帧 （加入SMAC、DMAC）
物理层 — 比特流（电流）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a3538110598eb4d05ae81a28e973439/" rel="bookmark">
			Python基础知识——Numpy数值计算篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NumPy提供了一个名为ndarray的多维数组对象，该数组元素具有固定大小。即NumPy数组元素是同质的，只能存放同一种数据类型的对象。能够运用向量化运算来处理整个数组，具有较高的运算效率。
数组创建 通过array()函数创建ndarray数组 array()函数可以将Python的列表、元组、数组或其他序列类型作为参数创建ndarray数组。
import numpy as np a1 = np.array([1, 2, 3, 4, 5, 6]) #一维列表 print("a1=",a1) a2 = np.array([[1, 2, 3], [4, 5, 6]]) #二维列表 print("a2=",a2) a3 = np.array('abcdf') #字符串 print("a3=",a3) a4 = np.array((1, 2, 3)) #元组 print("a4=",a4) a5 = np.array({'zhang':12, 'dd':45}) #字典 print("a5=",a5) ## 输出 ## a1= [1 2 3 4 5 6] a2= [[1 2 3] [4 5 6]] a3= abcdf a4= [1 2 3] a5= {'zhang': 12, 'dd': 45} 创建特殊数组 NumPy提供了创建特殊数组的函数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a3538110598eb4d05ae81a28e973439/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2c6864024e5f25fd58bf51aa524aedd/" rel="bookmark">
			【Word】MathType 运行时错误‘53’：文件未找到：MathPage.WLL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 1. 环境： MathType7.4Microsoft Office 365Windows 11 2. 问题 情景1. Microsoft Word 启动时显示 Please reload Word to load MathType addin properly
情景2. 安装MathType后在 Microsoft Word 中使用复制粘贴时报错 运行时错误‘53’
情景3. 在 Microsoft Word 中使用 MathType 选项卡时，无法打开并报错 运行时错误‘53’
重新加载后，MathType 大部分功能不可用，状态为灰色不可点击
解决方法 1. 系统环境 首先需要确认一下计算机系统是32位的还是64位的。
可以通过控制面板，或者运行 dxdiag进行查看，控制台 systeminfo 等等方法查看
2. 复制文件 找到 MathType 安装目录，默认的安装目录为 C:\Program Files (x86)\MathType，如果你修改了安装目录请自行定位。在安装目录下能够找到 MathPage 文件夹。
进入 MathPage 目录，根据操作系统位数选择 32 位或 64 位，进入对应目录，找到 MathPage.wll 文件。并复制到 C:\Program Files\Microsoft Office\root\Office16 目录下。
甚至都不需要重新启动Word，这个问题就被轻松秒杀了。其实避免这个问题也挺简单的，运行 MathType 安装程序的时候选择管理员身份启动即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb7826317b565497714ed953c4f272b2/" rel="bookmark">
			linux gdb使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		gdb 是由 GNU 软件系统社区提供的调试器。可以监控程序执行的每一个细节，包括变量的值、函数的调用过程、内存中数据、线程的调度等，从而发现隐藏的错误或者低效的代码作用
// q.cpp #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #define NUM 10 // argc, argv 是命令行参数 // 启动应用程序的时候 int main(int argc, char* argv[]) { printf("参数个数: %d\n", argc); for(int i=0; i&lt;argc; ++i) { printf("%d\n", NUM); printf("参数 %d: %s\n", i, argv[i]); } return 0; } 调试准备 如果是为了进行调试而编译时， 必须要打开调试选项 (-g)。即
g++ -g q.cpp -o q.exe 程序分为debug版本和release版本。只要debug版本才能进行调试。在Linux中，用gcc/g++生成的软件程序是release版本！（这里顺便复习一下：gcc默认：动态链接、默认release）所以，我们需要将其变成debug。我们在编译软件的时候，加上-g。
启动 gdb gdb 可执行程序的名字
gdb q.exe 一定要注意 gdb进程启动之后, 需要的被调试的应用程序是没有执行的.
命令行传参 有些程序在启动的时候需要传递命令行参数，如果要调试这类程序，这些命令行参数必须要在应用程序启动之前通过调试程序的 gdb 进程传递进去.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb7826317b565497714ed953c4f272b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eddb538389d119484a24cbffec994873/" rel="bookmark">
			ubuntu gnome桌面农历日历显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ubuntu gnome桌面农历日历显示 需要安装这个扩展
前提是先安装gir1.2-lunar-date-2.0
https://pkgs.org/download/gir1.2-lunar-date-2.0
去此网站下载deb
并且需要些requires也要先ta安装
然后去安装这个扩展https://extensions.gnome.org/extension/675/lunar-calendar/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f919b93a4f9c839b8a6aad7d003ee0c/" rel="bookmark">
			Ubuntu服务器上安装ifort
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu服务器上安装ifort 安装ifort之前需要有gcc、g++等，网上可以找到
主要是用到了两个链接，第一个用了下面这位大佬的文章，完成了ifort下载和安装
https://blog.csdn.net/qq_43070386/article/details/83214690
第二个是下面这位大佬的文章，安装完成后完成了环境配置
https://www.cnblogs.com/Seashore/p/6428823.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b61f58c0d53709374fb6d9bd1362e5b/" rel="bookmark">
			RTL9010 RTCT功能配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RTCT即线缆诊断，在车载以太网使用上是一个必备的功能 一 手册解读 解释如下
涉及的相关寄存器
二 相关代码 s8 RTL9010AA_VA_CableFaultLocationAndDiagnosis(u16* cable_length){ u32 mdio_data = 0; u16 cable_st; mdio_write(31, 0x0A42); //PAGSR:change page to 0xA42 mdio_write(17, 0x0001); //RTCTCR: bit0 = 1,rtct_en, enable RTCT and start to test while (mdio_data != 0x8000){ //RTCTCR: bit15 = 1, check RTCT is finished mdio_data = mdio_read(17); mdio_data = mdio_data &amp; 0x8000; } //read channel status and cable length mdio_write(31, 0x0A43); //write reg31,page select register mdio_write(27, 0x8022); //PHYSRAD mdio_data = mdio_read(28); //PHYSRD: this value means cable status cable_st = mdio_data &amp; 0xFF00; //normal mode if (cable_st == 0x6000) { *cable_length = 0xFFFF; // Cable is normal.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b61f58c0d53709374fb6d9bd1362e5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ac28edca839bf97d7e30d2f4e8e4c13/" rel="bookmark">
			C语言PTA题目：7-4 2024 日期更正器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 输入格式:
输出格式:
输入样例:
输出样例:
解题步骤：
解题代码:
小强在统计一个小区里居民的出生年月，但是发现大家填写的生日格式不统一，例如有的人写 199808，有的人只写 9808。有强迫症的小强请你写个程序，把所有人的出生年月都整理成 年年年年-月月 格式。对于那些只写了年份后两位的信息，我们默认小于 22 都是 20 开头的，其他都是 19 开头的。
输入格式: 有多行数据，每行一个出生年月，为一个 6 位或者 4 位数，题目保证是 1000 年 1 月到 2021 年 12 月之间的合法年月。
输出格式: 在一行中按标准格式“年年年年-月月” 将输入的信息整理输出。
输入样例: 9808
0510
196711
输出样例: 1998-08
2005-10
1967-11
解题步骤： 1.判断输入日期是4位数格式还是6位数格式
2.判断输入年份是20xx年还是19xx年
if(((a[0]-48)*10+a[1]-48)&lt;22) printf("20%c%c-%c%c\n",a[0],a[1],a[2],a[3]); else printf("19%c%c-%c%c\n",a[0],a[1],a[2],a[3]); 注意：由于这里存储输入数据的时候使用的是字符，但是进行判断的时候使用的是数字形式，记得将字符-48转换成其对应的数字形式
解题代码: #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() { char a[10]={}; while(~scanf("%s",a)) { if(strlen(a)==4) { if(((a[0]-48)*10+a[1]-48)&lt;22) printf("20%c%c-%c%c\n",a[0],a[1],a[2],a[3]); else printf("19%c%c-%c%c\n",a[0],a[1],a[2],a[3]); } if(strlen(a)==6) printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ac28edca839bf97d7e30d2f4e8e4c13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e68af5344c2fdf65cffff17e06ac06f/" rel="bookmark">
			第二章：Swagger2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
背景介绍
什么是Swagger2
常用注解
SpringBoot整合Swagger2
生产环境下屏蔽Swagger2
修改Swagger2配置类
修改application.yml
使用maven package打包测试
运行测试
背景介绍 在团队开发中，一个好的 API 文档不但可以减少大量的沟通成本，还可以帮助一位新人快速上手业务。传统的做法是由开发人员创建一份 RESTful API 文档来记录所有的接口细节，并在程序员之间代代相传。这种做法存在以下几个问题：
1）API 接口众多，细节复杂，需要考虑不同的HTTP请求类型、HTTP头部信息、HTTP请求内容等，想要高质量的完成这份文档需要耗费大量的精力；
2）难以维护。随着需求的变更和项目的优化、推进，接口的细节在不断地演变，接口描述文档也需要同步修订，可是文档和代码处于两个不同的媒介，除非有严格的管理机制，否则很容易出现文档、接口不一致的情况；
Swagger2 的出现就是为了从根本上解决上述问题。它作为一个规范和完整的框架，可以用于生成、描述、调用和可视化 RESTful 风格的 Web 服务：
接口文档在线自动生成，文档随接口变动实时更新，节省维护成本；
支持在线接口测试，不依赖第三方工具；
什么是Swagger2 Swagger2 是一个规范和完整的框架，用于生成、描述、调用和可视化Restful风格的web服务，现在我们使用spring boot 整合它。作用：
接口的文档在线自动生成；
功能测试；
常用注解 注解描述@Api将类标记为 Swagger 资源。@ApiImplicitParam表示 API 操作中的单个参数。@ApiImplicitParams允许多个 ApiImplicitParam 对象列表的包装器。@ApiModel提供有关 Swagger 模型的其他信息。@ApiModelProperty添加和操作模型属性的数据。@ApiOperation描述针对特定路径的操作或通常是 HTTP 方法。@ApiParam为操作参数添加额外的元数据。@ApiResponse描述操作的可能响应。@ApiResponses允许多个 ApiResponse 对象列表的包装器。@Authorization声明要在资源或操作上使用的授权方案。@AuthorizationScope描述 OAuth2 授权范围。 SpringBoot整合Swagger2 导入依赖 &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;swagger-models&lt;/artifactId&gt; &lt;groupId&gt;io.swagger&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; ​ &lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;swagger-bootstrap-ui&lt;/artifactId&gt; &lt;version&gt;1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e68af5344c2fdf65cffff17e06ac06f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd706e4ab5b626efab23436404c34ad0/" rel="bookmark">
			利用Python去除图片水印，太神奇了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近写文章遇到图片有水印，如何去除水印呢？
网上找了各种办法，也跑到小红书、抖音等平台找有没有不收费就去水印的网站，但是基本上都是需要VIP会员才可以。
话又说回来这种事情怎么能难倒一个程序员呢？Python的库有这么多肯定有一款适合我吧？
于是找来了OpenCV。
OpenCV介绍 文档链接：https://docs.opencv.org/3.0-beta/doc/py_tutorials/py_tutorials.html
Opencv（Open Source Computer Vision Library）是一个基于开源发行的跨平台计算机视觉库，它实现了图像处理和计算机视觉方面的很多通用算法，已成为计算机视觉领域最有力的研究工具。
在这里我们要区分两个概念：
图像处理和计算机视觉的区别：图像处理侧重于“处理”图像–如增强，还原，去噪，分割等等；
而计算机视觉重点在于使用计算机来模拟人的视觉，因此模拟才是计算机视觉领域的最终目标。
OpenCV用C++语言编写，它具有C ++，Python，Java和MATLAB接口，并支持Windows，Linux，Android和Mac OS， 如今也提供对于C#、Ch、Ruby，GO的支持
OpenCV应用领域有：人机互动、物体识别、 图像分割、人脸识别、动作识别、运动跟踪、机器人、运动分析、机器视觉、结构分析、汽车安全驾驶等。
安装：
安装numpy：pip install numpy
安装opencv-python：pip install opencv-python
安装opencv-contrib-python**：pip install opencv-contrib-python
如果安装过程中有误，可以去下载安装whl：http://www.lfd.uci.edu/~gohlke/pythonlibs/，找到对应的版本下载。
在命令行安装成功后，进入开发环境导入cv2，如果未报错，就证明opencv安装成功。
去水印 图片展示
记得学过PS中有蒙版，可以使用蒙版遮罩完成。
代码：
python # 方式一 import cv2 # 黑底白字 src = cv2.imread("images/a1.png") # 默认的彩色图(IMREAD_COLOR)方式读入原始图像 # black.jpg mask = cv2.imread('images/a2.png', cv2.IMREAD_GRAYSCALE) # 灰度图(IMREAD_GRAYSCALE)方式读入水印蒙版图像 # 参数：目标修复图像; 蒙版图（定位修复区域）; 选取邻域半径; 修复算法(包括INPAINT_TELEA/INPAINT_NS， 前者算法效果较好) dst = cv2.inpaint(src, mask, 3, cv2.INPAINT_NS) cv2.imwrite('result.jpg', dst) 但是这种方法使用的时候要求两张图片的大小必须是一样的，否则会一直报错
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd706e4ab5b626efab23436404c34ad0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61bfcb3b3ab77cd7efdefadac3aa609a/" rel="bookmark">
			python读取CSV写入redshift数据库，数据含有单引号和双引号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Python来读取CSV并将其写入Redshift数据库时，如果CSV数据中含有单引号和双引号，则可以使用以下方法来处理它们：
在读取CSV时使用带有 escapechar 参数的 csv.reader() 函数，并指定一个转义字符。在这种情况下，在单引号或双引号前添加转义字符即可。
在读取CSV时使用带有 quotechar 参数的 csv.reader() 函数，并指定一个引号字符。在这种情况下，如果单元格中的文本以指定的引号字符开头和结尾，则 csv.reader() 会自动将其视为引用字符串，并将其中的单引号和双引号转义。
示例代码如下：
import csv # 使用转义字符 '\' 读取 CSV with open('data.csv', 'r') as f: reader = csv.reader(f, escapechar='\\') for row in reader: print(row) # 使用引号字符 '"' 读取 CSV with open('data.csv', 'r') as f: reader = csv.reader(f, quotechar='"') for row in reader: print(row) 然后，您可以使用 Python 的 psycopg2 模块将数据写入 Redshift 数据库。
示例代码如下：
``` import psycopg2
连接 Redshift 数据库 conn = psycopg2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61bfcb3b3ab77cd7efdefadac3aa609a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/158115066d4b684e30c0d2f088a32740/" rel="bookmark">
			Unity中为InputField添加点击事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、描述
Turn a simple label into a interactable input field.
将简单的标签转换为可交互的输入字段。
2、支持的监听事件
InputField提供的监听只有OnValueChanged和OnEndEdit两种。
（1）OnValueChanged主要用来监听输入的字符数量变化，并返回一个当前的string；
inputField.onValueChanged.AddListener((param)=&gt; { OnInputFieldChange(param); });
（2）OnEndEdit会返回一个结束的事件，并返回输入完毕的string。
inputField.onEndEdit.AddListener(delegate { InputEnd(m_inputSearch); });
3、为InputField添加点击事件
private void AddInputNameClickEvent() //可以在Awake中调用
{
var eventTrigger = _inputField.gameObject.GetOrAddComponent&lt;EventTrigger&gt;();
UnityAction&lt;BaseEventData&gt; selectEvent = OnInputFieldClicked;
EventTrigger.Entry onClick = new EventTrigger.Entry()
{
eventID = EventTriggerType.PointerClick
};
onClick.callback.AddListener(selectEvent);
eventTrigger.triggers.Add(onClick);
}
private void OnInputFieldClicked(BaseEventData data)
{
//TODO: 点击事件
}
————————————————
版权声明：本文为CSDN博主「q123_xi」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/q123_xi/article/details/124801973
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6b728cf84afa5d08b52ee4014f75f1c/" rel="bookmark">
			基础（一）C&#43;&#43;语言 第二章 顺序结构程序设计 第三节 标准数据类型 1021：打印字符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【题目描述】 输入一个整数，即字符的ASCII码，保证存在对应的可见字符。输出相对应的字符。
【输入】 一个整数，即字符的ASCII码，保证存在对应的可见字符。
【输出】 一行，包含相应的字符。
【输入样例】 65 【输出样例】 A #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; int main() { int a; scanf("%d",&amp;a); printf("%c",a); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5de38ff57d22b265fcdee56e203deb53/" rel="bookmark">
			vuecli 外部字体引入火狐浏览器兼容问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 由于各个浏览器对字体文件的兼容不一样，所以需要把字体文件转换各种格式然后引入。 1. 先需要把你的字体文件格式转换成 eot,otf,svg,ttf,woff 等格式，格式转换网站: CloudConvert
2. 在assets下面新建fonts文件夹，fonts里面引入各种字体文件，然后新建fonts.css文件 3. fonts.css文件内容： @font-face { font-family: 'HYL2MJN2'; src: url('./HYL2MJN2.eot'); src: url('./HYL2MJN2.eot?#iefix') format('embedded-opentype'), url('./HYL2MJN2.woff') format('woff'), url('./HYL2MJN2.ttf') format('truetype'), url('./HYL2MJN2.svg#webfont34M5alKg') format('svg'); } 代码中 HYL2MJN2 是文件名
4. main.js 里面引入css文件 import './assets/fonts/fonts.css' 5. 现在可以在templet里面直接使用了 html部分：
&lt;h1&gt;'f%j3'K'i&lt;/h1&gt; css部分：
h1 { font-family: "HYL2MJN2"; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/451083d3b1e705cab3e09d94039ed448/" rel="bookmark">
			02 Hadoop概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Hadoop概述 1、Hadoop是什么2、Hadoop版本3、HDFS、YARN、MapReduce（1） HDFS（2）YARN（3）MapReduce（3）Hadoop模块之间的关系 1、Hadoop是什么 是一个由Apache基金会开发的分布式系统基础架构。解决海量数据的存储以及分析计算。广义的Hadoop是一个更广泛的概念——Hadoop生态圈。
重点框架：Kafka、Spark、Flink、Hive、Hbase、Zookeeper、Yarn、MapReduce、HDFS 生态体系：
1）Sqoop：Sqoop是一款开源的工具，主要用于在Hadoop、Hive与传统的数据库（MySql）间进行 数据的传递 ，可以将一个关系型数据库（例如 ：MySQL，Oracle 等）中的数据导进到Hadoop的HDFS中，也可以将HDFS的数据导进到关系型数据库中。
2）Flume：Flume是一个高可用的，高可靠的，分布式的海量 日志采集 、聚合和传输的系统，Flume支持在日志系统中定制各类数据发送方，用于收集数据；
3）Kafka：Kafka是一种高吞吐量的分布式发布 订阅消息系统；
4）Spark：Spark是当前最流行的开源大数据 内存计算框架 。可以基于Hadoop上存储的大数据进行计算。
5）Flink：Flink是当前最流行的开源大数据内存计算框架。用于实时计算的场景较多。
6）Oozie：Oozie是一个管理Hdoop作业（job）的工作流程调度管理系统。
7）Hbase：HBase是一个分布式的、面向列的开源数据库。HBase不同于一般的关系数据库，它是一个适合于非结构化数据存储的数据库。
8）Hive：Hive是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，并提供简单的SQL查询功能，可以将SQL语句转换为MapReduce任务进行运行。 其优点是学习成本低，可以通过类SQL语句快速实现简单的MapReduce统计，不必开发专门的MapReduce应用，十分适合数据仓库的统计分析。
9）ZooKeeper：它是一个针对大型分布式系统的可靠协调系统，提供的功能包括：配置维护、名字服务、分布式同步、组服务等。
2、Hadoop版本 1.x版本系列：hadoop的第二代开源版本，该版本基本已被淘汰2.x版本系列：架构产生重大变化，引入了Yarn平台等许多新特性,是现在使用的主流版本。3.x版本系列:该版本是最新版本，但是还不太稳定。 Hadoop发行版本分为开源社区版和商业版：
开源社区版:指由Apache软件基金会维护的版本，是官方维护的版本体系,版本丰富，兼容性稍差，对于入门学习最好。商业版:指由第三方商业公司在社区版Hadoop基础上进行了一些修改、整合以及各个服务组件兼容性测试而发行的版本，比较著名的有cloudera的CDH、TDH等 Hadoop1.x和2.x的区别:
在1.x时代，MapReduce同时处理业务逻辑运算以及资源的调度，耦合性较大；在2.x时，Yarn负责资源的调度，MapReduce只负责运算。
3、HDFS、YARN、MapReduce （1） HDFS 单机容量往往无法存储大量数据，大数据需要跨机器存储。统一管理分布在集群上的文件系统称为分布式文件系统 。HDFS（Hadoop Distributed File System）就是一种Hadoop分布式文件系统，具备高度容错特性，支持高吞吐量数据访问，可以在处理海量数据（TB或PB级别以上）的同时最大可能的降低成本。HDFS适用于大规模数据的分布式读写，特别是读多写少的场景。
架构概述：
HDFS采用Master/Slave架构，一个HDFS集群有两个重要的角色，分别是Namenode和Datanode。
HDFS的四个基本组件:HDFS Client、NameNode、DataNode和Secondary NameNode。
NameNode：集群当中的主节点，主要用于管理集群当中的各种数据。存储文件的元数据（文件名、文件目录结构、文件属性），以及每个文件的块列表和块所在的DataNode等。
DataNode： 集群当中的从节点，主要用于存储集群中的各种数据（在本地文件系统存储文件块数据以及块数据的校验和）。
SecondaryNameNode：主要用于hadoop中元数据信息的辅助管理（每隔一段时间对NameNode元数据备份）。
HDFS的副本机制
HDFS能够在一个大集群中跨机器地存储超大文件。它将每个文件存储成一系列的数据块——block，除了最后一个block，所有的数据块都是同样大小的128M。为了容错，所有的block都会有副本，每个文件的数据块大小和副本系数都是可配置的。
特点：
HDFS文件系统可存储超大文件，时效性稍差。
HDFS具有硬件故障检测和自动快速恢复功能。
HDFS为数据存储提供很强的扩展能力。
HDFS存储一般为一次写入，多次读取，只支持追加写入，不支持随机修改。
HDFS可在普通廉价的机器上运行。
（2）YARN 数据计算核心模块——Yarn
ResourceManager：接收用户的计算请求任务，并负责集群的资源分配。NodeManager： 负责执行主节点分配的任务。
Container是YARN中的资源抽象，它封装了某个节点上多维度资源，如内存、CPU、磁盘、网络等。 （3）MapReduce MapReduce将计算过程分为两个阶段：Map和Reduce
Map阶段并行处理输入数据Reduce阶段对Map结果进行汇总
（3）Hadoop模块之间的关系 MapReduce计算需要的数据和产生的结果需要HDFS来进行存储MapReduce的运行需要由Yarn集群来提供资源调度。（MapReduce只是一段代码，需要Yarn提供资源进行调度） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bec4823554e03871102ccd2adce3fd22/" rel="bookmark">
			【python报错】ImportError: DLL load failed while importing QtCore: 找不到指定的程序。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本人用Pyqt6编写了一个小软件，发给朋友使用时运行报错。
报错 研究发现出现这个问题的根本原因在于：操作系统不匹配，用高版本python发布的程序，无法在win7上运行，在win10上可以正常运行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11bfb691e26191b1fbbbeb829f0c2a2e/" rel="bookmark">
			JavaScript 数组-概念，创建数组，遍历数组，新增元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JavaScript 数组-概念，创建数组，遍历数组，新增元素 目录 JavaScript 数组-概念，创建数组，遍历数组，新增元素 1. 数组的概念2. 创建数组 2.1 数组的创建方式2.2 利用 new 创建数组2.3 利用数组字面量创建数组2.4 数组元素的类型3. 获取数组元素 3.1 数组的索引4. 遍历数组5. 数组中新增元素 5.1 通过修改 length 长度新增数组元素5.2 通过修改数组索引新增数组元素 1. 数组的概念 问：之前学习的数据类型，只能存储一个值。如果我们想存储班级中所有学生的姓名，那么该如何存储呢？答：可以使用数组(Array)。数组可以把一组相关的数据一起存放，并提供方便的访问(获取)方式。问：什么是数组呢？答：数组是指一组数据的集合，其中的每个数据被称作元素，在数组中可以存放任意类型的元素。数组是一种将一组数据存储在单个变量名下的优雅方式。
2. 创建数组 2.1 数组的创建方式 JS 中创建数组有两种方式：
利用 new 创建数组
利用数组字面量创建数组
2.2 利用 new 创建数组 2.3 利用数组字面量创建数组 2.4 数组元素的类型 3. 获取数组元素 3.1 数组的索引 4. 遍历数组 测试：
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; // 遍历数组：就是把数组的元素从头到尾访问一次 var arr = ['red', 'green', 'blue']; for (var i = 0; i &lt; 3; i++) { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11bfb691e26191b1fbbbeb829f0c2a2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49e84696f1d49e6ccbcd0085bab8d623/" rel="bookmark">
			CentOS 7忘记密码怎么办？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 步骤：
完整命令行： 步骤： 首先进入虚拟机，在出现第一个图形界面后就按e，进入：
找到ro，改为rw init=/sysroot/bin/sh
按下 ctrl+x ，使用单用户模式启动
1、访问系统：
chroot /sysroot 2、重置密码
passwd root 3、更新系统信息
touch /.autorelabel 4、 退出单用户模式
esec /sbin/init 5、重启系统
reboot 完整命令行： 最后退出，重启即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b35baf9adabbd14664d587d44cd04422/" rel="bookmark">
			C&#43;&#43;：将输出结果写入文件、从文件中读取数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		应用背景 很多时候我们会使用语句：
cout &lt;&lt; ... &lt;&lt; endl ;
来进行将某个变量的值展示在屏幕上，但如果我们希望将这个结果写入文件中
该怎样操作呢？
下面展示了如何将输出结果写入txt文件之中 #include &lt;iostream&gt; using namespace std ; int main() { int x, y ; cin &gt;&gt; x &gt;&gt; y ; freopen("test.txt","w",stdout) ; // 将标准输出重定向到text.txt文件 if (y == 0) cerr &lt;&lt; "error." &lt;&lt; endl ; // 除数为0则输出错误信息 else cout &lt;&lt; x / y ; // 否则将结果写入test.txt return 0 ; } 相似的，如果我们希望从文件中读取数据用于 cin &gt;&gt; 输入 可以参考下面例子 #include &lt;iostream&gt; using namespace std ; int main() { int n ; freopen("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b35baf9adabbd14664d587d44cd04422/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a30cd67db68b3169f2d9cee37b4bc30/" rel="bookmark">
			SMOTE算法代码是什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SMOTE算法(Synthetic Minority Over-sampling Technique)是一种用于解决数据集不平衡问题的算法。它主要是通过生成新的数据点来增加少数类的样本数量，以提高分类器的效果。
下面是一个使用 Python 实现 SMOTE 算法的示例代码：
from imblearn.over_sampling import SMOTE # 建立SMOTE模型 smote = SMOTE(random_state=42) # 将训练集进行SMOTE处理 X_train_resampled, y_train_resampled = smote.fit_resample(X_train, y_train) 在这个代码中，X_train 和 y_train 分别表示训练集的特征和标签。通过调用 SMOTE 类的 fit_resample 方法，可以对训练集进行SMOTE处理，生成新的训练集 X_train_resampled 和 y_train_resampled。
需要注意的是，这个代码中使用了 imbalanced-learn 库中的 SMOTE 类来实现 SMOTE 算法。如果您的环境中没有安装这个库，可以使用 pip install imbalanced-learn 命令进行安装。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/893c9c2dbb8398913e2e85d23c05d0cf/" rel="bookmark">
			Mysql两表 join 查询方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、SQL基本语法格式 SELECT DISTINCT &lt; select_list &gt; FROM &lt; left_table &gt; &lt; join_type &gt; JOIN &lt; right_table &gt; ON &lt;join_condition&gt; WHERE &lt; where_condition &gt; GROUP BY &lt; group_by_list &gt; HAVING &lt; having_condition &gt; ORDER BY &lt; order_by_condition &gt; LIMIT &lt; limit_number &gt; 二、3种join方式 1. left join（左连接） A left join B 得到A表的所有字段，如果没有匹配到连接条件则用null填充
select A.*,B.* from A left join B on A.id = B.id; 2. right join（右连接） A right join B 得到B表所有的字段
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/893c9c2dbb8398913e2e85d23c05d0cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c88825f4e536d74ef4563dd42e755a6/" rel="bookmark">
			MPLS LDP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 目录
一、topo结构
二、配置topo
第一步：配置IP地址和isis协议使全网互通
第二步、测试网络联通性 第三步、配置MPLS LDP多协议标签转发 第四步、抓包分析MPLS LDP 总结
新的一年开始了，在这里先祝大家兔年快乐，哈哈哈哈 前言 MPLS是一种根根据标签报文中携带的短而定长的标签来转发数据的技术MPLS的一个基本概念就是两台LSR必须对在它们之间转发的数据的标签使用上“达成共识”。
LSR之间可以运行标签分发协议( Label Distribution Protocol，LDP)来告知其他LSR本设备上的标签绑定信息，从而实现标签报文的正确转发。
LDP是MPLS的一种控制协议，相当于传统网络中的信令协议，负责FEC的分类、标签的分配以及LSP的建立和维护等操作。LDP规定了标签分发过程中的各种消息以及相关处理过程
LDP的工作过程主要分为两部分
1.LSR之间建立LDP会话
2.LSR之间基于LDP会话动态交换标签与FEC的映射信息，并根据标签信息建立LSP
LDP的会话建立是可靠传输，类似于TCP的三次握手。
发现阶段
设备通过周期性地发送LDP链路Hello报文 (LDPLink Hello)，实现LDP基本发现机制。LDP链路Hello报文使用UDP报文，目的地址是组播地址224.0.0.2。如果LSR在特定接口接收到LDP链路Hello报文，表明该接口存在LDP邻接体
TCP建立阶段
Hello报文中携带传输地址，双方后续将使用传输地址建立LDP会话
传输地址较大的一方作为主动方，主动发起建立TCP连接
经过TCP三次握手之后，两者建立起TCP连接。
TCP连接建立成功后，主动方R2(传输地址大的一方)发送LDP初始化报文，协商建立LDP会话的相关参数。
LDP会话的相关参数包括LDP协议版本、标签分发方式、KeepAlive保持定时器的值、最大PDU长度和标签空间等。
被动方R1收到初始化报文后，若接受R2的相关参数则回应KeepAlive报文作为确认，为了提高发送效率同时发送自己的初始化报文。
R2收到R1的初始化报文后，若接受相关参数，则回复KeepAlive报文给R1。
双方都收到对端的KeepAlive报文后，会话建立成功后续通过周期性发送的KeepAlive报文
下面来看实验吧
一、topo结构 二、配置topo 第一步：配置IP地址和isis协议使全网互通 第二步、测试网络联通性 第三步、配置MPLS LDP多协议标签转发 接口要开启mpls ldp协议 第四步、抓包分析MPLS LDP 可以看到传输地址为1.1.1.1 用来做后续的ldp建立 配置好AR2的MPLS LDP 来查看端口建立
抓包分析MPLS LDP 这里我们可以看到TCP 的三次握手，也就是说明会话建立完成了
可以看到会话接收端是2.2.2.2 保证建立成功
同理配置完AR3 AR4
用ping命令抓包查看MPLS LDP 标签 查看标签分析MPLS ldp
dis mpls lsp 查看标签分配
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c88825f4e536d74ef4563dd42e755a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11d325dfec27255495965265a805a2a2/" rel="bookmark">
			洛谷P5706 题解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 洛谷P5706 题解 传送门
题意 输入一个浮点数和一个整数
输出浮点数除以整数的商和整数乘二
分析 这里要用到一个新的变量——double
用于存储浮点数
题目还要求输出后三位小数
我们可以用printf进行输出
之后会在代码中讲到
代码 #include &lt;bits/stdc++.h&gt; //万能头文件 using namespace std; //标准命名空间 int main() { double a; //定义浮点型变量 int b; cin &gt;&gt; a &gt;&gt; b; double c=a/b; //计算得数 printf("%.3lf",c); //本来是 printf("%lf",c) 表示输出c变量 //加上 .3 表示输出后三位小数 cout &lt;&lt; endl &lt;&lt; b*2; return 0; } 注意事项 注意使用double类型变量输出时加上.3 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b51009e8f6c6ae594d9e0bbcddda909/" rel="bookmark">
			VMware虚拟机快照——虚拟机状态恢复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Q1：为什么要拍虚拟机快照？ 我们在使用虚拟机时，经常一不小心“玩儿坏”虚拟机，但是每次都重装一遍太过麻烦，所以我们通过给虚拟机拍摄“快照”的方式，快速将其状态恢复到从前的某一状态，以继续正常使用
Q2：如何拍摄快照？ 打开VMware虚拟机 ---&gt; 调试好要拍照的虚拟机状态 ---&gt; 关机
关机的原因是在关机状态下拍摄快照速度比较快，不关机也行
点击“虚拟机” ---&gt; 点击“快照” ---&gt; 点击“快照管理器” ---&gt; 点击“拍摄快照”
输入快照的名称和描述 ---&gt; 点击“拍摄快照” ---&gt; 出现建立好的快照状态
Q3:状态恢复 某次使用时把虚拟机“玩儿坏”了，需要恢复到“测试快照”状态
选中想要恢复到的快照 ---&gt; 点击“转到”
点击“是”
恢复完成啦~ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fbb25b69826b54208fb9865e6e675dd/" rel="bookmark">
			Vue3纯前端实现Vue路由权限的方法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址：Vue3纯前端实现Vue路由权限的方法详解_vue.js_脚本之家
前言 在开发管理后台时，都会存在多个角色登录，登录成功后，不同的角色会展示不同的菜单路由。这就是我们通常所说的动态路由权限，实现路由权限的方案有多种，比较常用的是由前端使用addRoutes（V3版本改成了addRoute）动态挂载路由和服务端返回可访问的路由菜单这两种。今天主要是从前端角度，实现路由权限的功能。
RBAC模型 前端实现路由权限主要是基于RBAC模型。
RBAC（Role-Based Access Control）即：基于角色的权限控制。通过角色关联用户，角色关联权限的方式间接赋予用户权限。
代码实现 登录 首先是登录，登录成功后，服务端会返回用户登录的角色、token以及用户信息等。用户角色如：role: ['admin']。我们一般会将这些信息保存到Vuex里。
1
2
3
4
5
6
7
8
9
const login = () =&gt; {
ruleFormRef.value?.validate((valid: boolean) =&gt; {
if (valid) {
store.dispatch('userModule/login', { ...accountForm })
} else {
console.log('error submit!')
}
})
}
信息存储在Vuex：
1
2
3
4
5
6
7
8
9
10
11
async login({ commit }, payload: IRequest) {
// 登录获取token
const { data } = await accountLogin(payload)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fbb25b69826b54208fb9865e6e675dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5c71078c964ca5352eabbaabb119b2a/" rel="bookmark">
			C语言仿天天酷跑小游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：全文代码是模仿程序员rock开发的游戏代码思路，如果大家想根据视频一步步进行制作可以直接去b站进行搜索。全文代码主要分为两个部分，一个是完整版的开发代码（博主根据视频进行一步一步制作而成，素材也均来自于程序员rock）；另一个是博主考虑到自身水平的原因，在源码的基础上进行弱化修改，并且博主会在后文提到可以修改的地方，并且其中的素材是由博主ps手动扣出来的，会在后面的文章中详细说到。
目录
完整版
一.库与宏编译以及一些变量的设置
二.init()函数作为游戏初始化
三.creatobstacle()函数创建障碍物
四.checkhit()函数检测玩家碰撞
五. fly()函数实现图片的数据更新
六.updata()函数渲染游戏背景
七.updataren()函数进行人物图像渲染
八.人物跳跃开关
九.人物下蹲开关
十. anjian()函数处理用户按键读入
十一.updateEnemy()函数处理小怪渲染
十二. updatablood()函数进行血条渲染
十三.updatascore()函数处理分数渲染
十四.checkover()函数进行结束判定 十五.checkscore()函数进行分数更新
十六.checkwin()函数检测胜利
十七.drawblood()函数用来画血条
十八.main()主程序
完整程序
效果展示：
弱化版
详细讲解
接下来进入正文
完整版 一.库与宏编译以及一些变量的设置 #include&lt;stdio.h&gt; #include&lt;graphics.h&gt; #include&lt;conio.h&gt; #include"tools.h" #include&lt;vector&gt; using namespace std; #define WHIDE 1012 #define HEIGHT 396 #define OBSTACLE_COUNT 10 #define win 20 //胜利分数 //三重循环 IMAGE imgbgs[3]; int bgx[3];//背景图片的x坐标 int bgspeed[3] = { 1,2,4 }; IMAGE imgbgsren[12]; int renx;//人物横坐标 int reny;//人物纵坐标 int renindex;//玩家奔跑的图片帧 int jumpmax;//人物跳跃最大高度 bool renjump;//判断人物有没有跳 int rendownspeed;//下降 bool updata;//图片刷新开关 int blood;//人物血量 int score;//分数 //IMAGE imgTortoise;//小怪1 //int torToiseX;//小怪1的x坐标 //int torToiseY; //bool torToiseXExist;//当前窗口是否有小怪1 typedef enum { //枚举类型 guai1, guai2, zhu1, zhu2, zhu3, zhu4, //怪1为0，怪2为1 sum //sum来表示一共有多少种怪 }obstacle_type; vector&lt;vector&lt;IMAGE&gt;&gt;obstacleimgs;//定义可变二维数组，行表示哪一种障碍物，列表示障碍物图片 typedef struct obstacle {//障碍物封装 obstacle_type type;//障碍物类型 int imgindex;//当前图片序号 int x, y; //障碍物的x，y坐标 int speed;//速度 int power;//障碍物杀伤力（俗称扣多少血） bool exist;//判断障碍物是否存在 bool hit;//判断是否碰撞 bool passed;//表示是否通过 }obstacle_t; obstacle_t obstacles[OBSTACLE_COUNT];//直接建一个池子，看有多少障碍物 int lastobindex; //上一个障碍物的序号 //人物下蹲素材 IMAGE imgrendown[2]; bool rendown;//人物下蹲判定 //数字素材 IMAGE imgsz[10]; 二.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5c71078c964ca5352eabbaabb119b2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b4dff261dbfc7d72f9f771beb7e4caf/" rel="bookmark">
			年度总结-2022年
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 2022年，这一年，是我步入社会最痛苦的一年，也是成长最快的一年。
看尽人世间善恶丑陋嘴脸，多少的人情冷暖。
如人饮水，冷暖自知。
职场感悟 同事就是同事。不要和同事说心里话，包括吐槽领导，吐露自己的计划。可能在同事眼里，你只是个小丑，你的事情，只是别人的饭后谈资。对于不爽的同事，能不打交道就不打交道。不要做软柿子，如果都是同级，该回应的就回应！被甩锅的时候，必须把证据亮出来，别默不吭声！即使自己是要走人，也不能惯着某些人！绝对不能和上级发生直接冲突，如果特别不爽上级，能走就走，三字诀：忍狠滚！不是自己的事情，少多管闲事！不要和不在同一次元的人争论！ FB项目组总结 一提到此项目组，只能说管理混乱，团队氛围极差！要文档没文档，问业务的时候态度语气极差！
项目组成员评价 zhoujn：女，od出身的hw员工，一提到这个，就想爆粗口：jianhuo！脾气火爆，说话带着刺儿，很有个性，没脑子，给的需求，说得不明不白，态度语气极差，需求不明白的时候问她第二次好像是欠了她几个亿似的。什么都只知道用嘴，估计是因为习惯晚上用嘴了！脑子里面完全没有管理意识！
raow：是上面那女的亲信。总结起来，跟那女的加起来两个真是天造地设的一对狗男女奇葩搭档！业务不懂，请教的时候，都是态度语气极差，全程就会用嘴！
zhaism：一个前端菜鸟，两面三刀，左右逢源。我很厌恶测试来找开发澄清业务，毕竟从来没见过需要开发给测试澄清业务的团队，但是，此人就当着我的面骂测试，接着转头又跟测试说说笑笑，装得一副好人模样；曾经我请假了，让他跟上面那女的说一下，结果，他答应了，可就是不说。想想，曾经，我一个后端，指导他写前端，结果，后面被他甩锅过来，我居然也默不吭声！去TMD的！
nihn：人心隔肚皮，曾经我有问题就去问他，他有问题也来问我。但是，没想到的是，领导在他面前说我思维很跳跃，工作还需要改进的时候，他居然没有对我透露一点。直到我已经确定离开fb了，他才透露了一点！这么会玩？是不是有人害怕自己团队的同事改进了缺点，然后自己的绩效就低了？所以就这样玩？该说小人还是说啥？
其他人：打交道不多。
纪要 一月 那女的要写一个接口，我说直接用现成的接口，前端处理一下就行了，结果那女的直接说：我就是要这样。好吧，那就写新的接口吧，全程，那前端就是沉默看戏。有个权限失效的问题，我已经解决了。可是那女的就没放在心上，第一次review代码要求整改和第二次review代码要求整改的意见居然是不同，而且，还跟我说用OjectUtil.nonNull()，实际又不能这么用，哎。合入代码的时候，要先合入test分支，然后重新合入dev分支，结果，两个分支都有冲突，我不是在处理冲突就是在处理冲突的路上！ 二月 小周末的时候，前端有个bug，我好心提醒前端让他过来改。没想到前端后面四月份的时候直接甩锅给我，所以这次是极度后悔！ 三月 跟那女的发生了意见不合。我是不是脑子进水了，居然敢当面和领导发生冲突。结果，后面就果然被穿小鞋了。fb要和sca融合，那女的直接分配了一个controller接口给我，及其简单的一个查询接口，写完就算是参与了sca融合。fb即使有需求，也不给我核心相关的需求任务了。我出去面试了一家公司，结果被虐了。 四月 极度恶心的一个月来了。
4月12日早会，那女的在会上直接使用颇具讽刺的称呼喊我，结果让会上其他人都大笑。这件事情我一直记在心头。4月20日之前，那女的给了个需求让我搞，结果转手又给了新人，还给了新人开单子，但是，给我的时候却没有给我开单子。我准备了2天，刚有眉目了就这么玩，OK！4月20日，我写下了这样一段话：没权没势，只会被让欺辱，当你的亲人受辱的时候，你只能眼睁睁地看着却无能为力。因为4.12的场景已经刻在了我的心头！这天，那女的给我打电话，想给我安排任务，我选择不接，拒接。4月21日，我找PM，想换个项目组，结果，PM对我进行了一顿CPU，就是不给换项目组。好吧，临近下班的时候，我选择了请假，去面试。4月22日，我请假面试去了，结果，又被虐了。4月23日-月底的某一天，那女的给我打电话，说，你不要只做开发，不然我要你做啥！哦，我当时想说，你以为我想跟你混啊，你知道你多让人讨厌不！4月26-28日，这几天的事情是我遇到过最奇葩的事情。
7.1 测试找我澄清需求，我说了是这样的，结果测试有问题，让我去找那女的澄清。我qtm的，你觉得有问题，就应该你去找啊，为什么要我去找？
7.2 测试的发了一堆bug到群里，有些bug是前端的，结果，我居然默不吭声，当时就应该说，业务是这样那样的，还有的bug，你是基于哪点业务！
7.3 26还是27号晚上，测试和前端都在，我下班了，结果，测试把环境的问题甩锅到我身上，前端把本来是json格式的参数，结果最后传了一个表格过来给后端，最后又甩锅给我，让那女的打电话给我，说我的代码有问题，害得我整晚都睡不好。结果，第二天一看，就是前端的问题。qtmd，测试和前端都在，居然还要后端来定位！可是，自己当时是不是脑子进水了，别人都踩到脸上了，自己居然还没任何表示，默不吭声，没跟那女的说清楚，即使自己打算走了，也不应该这么默不吭声，便宜别人啊！ 五月 五月份，穿好小鞋了，已经没什么需求了。但是，还是被那女的扣上了一口锅：某个需求漏改了。然后实际需求没有涉及到！
六月 继续穿小鞋。6.3号左右，那女的给了一个表格，大概有200个IP，然后让我手动一个一个复制去网页查找IP对于的主机信息，我当时直接沉默了几秒，qnm的，侮辱我智商。6.7号左右。那女的给了一个需求，做什么配置流水线的，我居然接了。现在想起来真是后悔啊，当时就应该说，这个我不会，你让其他人来做。6.15号左右，测试投诉我，说我不好沟通，没给他们澄清需求。我当时居然又默不吭声，那时候就应该说，给需求的人怎么给我说，我就怎么给你们说。6.20号，那女的要checklist文档，我说没有，结果那女的好像因为晚上没得到满足，直接对我发脾气，说我的接口文档就是checklist文档。但是，我和其他的开发和测试人员，都认为接口文档和checklist文档是不同的。6.29日，我已经收到了offer，确定能走了。这天，那女的有问题拉我会议，还用一副高高在上的语气，极度讽刺的话语跟我说话，我直接毛了，杠回去，然后自己下会，退出所有群。 七月 这个月我在PM的劝说下，还是继续待着fb项目组，其实就不应该继续管fb项目组的事情了！结果搞出了一些让自己很尴尬的事情，比如让fb的主管延期账号，问其中一个od是不是要做某个需求！真是让人啼笑皆非！在另外要给深圳群里面，聊了很多事情，但是，这些最后估计变成了别人的饭后谈资罢了。7.15日，game over！解放了，我换项目组了！ 总结 在fb项目组，就一句话：胆小怕事，逆来顺受！
所以，社会对你毒打，你就要学会教训！
新项目组tatai 新项目组整体而已，氛围比fb要好点。需求管理以及待人方面，都不错，只是项目代码管理有待提高，还有个别人喜欢藏着掖着，不是很喜欢分享。
在新的项目组里面，一改之前默不吭声，逆来顺受的性子，是自己的问题就是自己的问题，如果是别人甩锅过来的，就拿出证据，不要走软柿子！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bf88241868054abba1fcd150d54ffcc/" rel="bookmark">
			【R语言】正则表达式 从字符串中提取数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 R语言 正则表达式 从字符串中提取数字
pattern &lt;- "(?&lt;ID&gt;[0-9]+)" result &lt;- regexpr(pattern= pattern, text = lj$line, perl=TRUE) start &lt;- attr(result,"capture.start") length &lt;- attr(result,"capture.length") name &lt;- attr(result,"capture.name") geneID &lt;- ifelse(start &gt; 0, substr(lj$line, start[,name],start[,name] + length[,name]-1),NA) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/199fca1fa9a1cf02b2f814a032b079ec/" rel="bookmark">
			Linux-软链接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软链接常用，硬链接知道概念即可。
ln -s target source
ln -s：表示创建一个软连接；
target：表示目标文件（文件夹），即源文件。
source：表示当前目录的软连接名，即被创建出来的软连接名称以及放置在何处。
我的测试:
-&gt; 后面的是真正路径
软链接:
软链接修改link,真正的文件也会修改。软链接类似于快捷方式。
硬链接
硬链接指经过索引节点来进行链接。
在Linux的文件系统中，保存在磁盘分区中的文件无论是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。
在Linux中，多个文件名指向同一索引节点是存在的。通常这种链接就是硬链接。
硬链接的做用是容许一个文件拥有多个有效路径名，这样用户就能够创建硬链接到重要文件，以防止“误删”的功能。
其缘由如上所述，由于对应该目录的索引节点有一个以上的链接。只删除一个链接并不影响索引节点自己和其它的链接，只有当最后一个链接被删除后，文件的数据块及目录的链接才会被释放。也就是说，文件真正删除的条件是与之相关的全部硬链接文件均被删除。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87f206d1953685b9da939144292d039b/" rel="bookmark">
			论文中 c.f. i.e. s.t. e.g. w.r.t. et al. etc英文缩写是什么意思
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自：(45条消息) 论文中出现的 cf. i.e. s.t. e.g. w.r.t. et al. etc等英文缩写是什么意思_H速写不读书H的博客-CSDN博客
论文阅读中经常遇到的一些缩写，具体含义如下：
c.f. 参考
例句：The prefix B denotes that the corresponding quantity is expressed in the frame B (cf., Fig. 2)
i.e. 即
例句：Inherently, the vision-only problem has six DoFs that are unobservable and need to be held fixed during optimization, i.e. the absolute pose.
s.t. 服从，满足 ，受约束于
subject to的缩写，通常出现在数学方程式和数学公式中，比如：
参数x满足约束g(x)=0的所有值中，使得f(x)的值最大。
e.g. 例如
源自拉丁文exempli gratia
例句：This is in contrast to, e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87f206d1953685b9da939144292d039b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d680efd4404096c795bd4e102a34d48/" rel="bookmark">
			OpenCV下载与环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载 官网：Releases - OpenCV
下载最新版release
安装 运行刚刚下载的安装程序，点击Extract进行安装
配置环境 右键点击此电脑，点击属性，点击高级系统设置会弹出名为系统属性的窗口
点击环境变量，选择系统变量中的Path,点击编辑
点击新建，再点击浏览
找到刚刚安装的opencv文件夹，选择build-&gt;x64-&gt;vc16-&gt;bin（其中vc16可能由于版本差异而有不同），点击确定
可以看到opencv已经被添加到环境变量中
打开刚刚的路径，将其中的所有后缀为.dll的动态链接库复制到C:\Windows\System32 配置Visual Studio 打开visual Studio，在搜索栏输入属性管理器
右键Debug|64，选择添加新项目属性表
命名为opencv，点击添加
右键刚刚建立的opencv，点击属性
选择VC++目录，并准备添加包含目录
选择opencv安装文件夹下的build-&gt;include点击确定，同理将build-&gt;include-&gt;opencv2也加入包含目录
用同样的方法，添加库目录
将安装目录下opencv\build\x64\vc16\lib下的内容添加到库目录
添加依赖项
打开安装目录，看到build-&gt;x64-&gt;vc16-&gt;lib下有一个名为opencv_world470d.lib的库文件
在依赖项中直接添加
点击确定后一定要点击应用
至此，配置完成
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/114/">«</a>
	<span class="pagination__item pagination__item--current">115/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/116/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>