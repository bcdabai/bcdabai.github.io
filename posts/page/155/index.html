<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a4c1c016be92d39e7366a3ad02d2da5/" rel="bookmark">
			WIN10安装配置JDK10的图文方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JDK是 Java 语言的软件开发工具包，主要用于移动设备、嵌入式设备上的java应用程序。JDK是整个java开发的核心，它包含了JAVA的运行环境，JAVA工具和JAVA基础的类库。没有JDK的话，无法编译Java程序，如果想只运行Java程序，要确保已安装相应的JRE。相信还有很多小伙伴对于WIN10安装配置JDK10的简单操作还不是很了解，有需要的朋友就跟我一起来学习一下吧。
首先，下载安装JDK10
双击.exe安装包，进行下一步
可按需点击【更改】设置路径，然后进行下一步
开始安装更新组件
JDK安装完成，会弹出jre的安装，我建议与JDK在同一个目录
如图配置环境，右击【此电脑】，选择【属性】
点击左侧的【高级系统设置】
打开系统属性界面，点击【环境变量】按钮
进入界面，在【系统变量】中点击【新建】，弹出对话框，变量名为【JAVA_HOME】，变量值是指JDK软件的安装路径，输入【D:\ProgramFiles\Java\jdk-10.0.2】，点击确定
找到【Path】，如没有就新建，输入【%JAVA_HOME%bin】，点击确定
JAVA_HOME、Path设置完成，点击确定，退出
测试JDK是否配置成功，按【Win+R】快捷键，打开运行窗口，输入cmd，点击确定
打开DOS命令提示符界面，输入【java-version】进行测试，结果如图，配置成功
*回复公众号“JDK”获取JDK 10下载链接
ps：微信搜一搜【争知拙见】，获取更多干货！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7143df963e5ac679be92b0e2cc22172c/" rel="bookmark">
			解决IDEA编译乱码�����方案合集（内附JDK下载链接）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IDEA编译的时候乱码，Build Output提示信息乱码�����。
解决方案一：
首先是编辑器的乱码，这个很好解决，file→settings→appearance里面设置成支持中文的字体(这个很重要)
解决方案二：
将Help→EditCusuom VM Options...中添加-Dfile.encoding=UTF-8
解决方案三：
防止方案二未生效，可用方案三：在IDEA的安装目录下找到idea.exe.vmoptions和idea64.exe.vmoptions文件
将 -Dfile.encoding=UTF-8 粘贴进去
我的电脑中的文件夹所在位置是：
D:\JetBrains\IDEA\bin
解决方案四：
Settings→Editor→FileEncodings 全部改为UTF-8
解决方案五：
选择适合本工程的JDK版本
解决方案六： 找到Maven的配置取消委托给Maven的build/run的权利
解决方案七：
发现这里设置没问题，编码格式都一样，上网继续找办法，找到一个在这个文件打开后的右下角可以改变脚本文件的编码格式的方法，选择对应编码后，点Convert
解决方案八：
如果还不行，试下FILE→setting，然后在下图目录位置中加入-encoding utf-8
最后告诉大家如何重启IDEA，对，就是点这里：
上面解决方案有很多，总有一个适合你的。如果所有办法都行不通，那很大可能就是你用了JDK最新的版本，存在兼容问题，这里可以回复公众号“JDK”下载JDK 10这样相对稳定的版本进行搭建Java开发环境。
ps：微信搜一搜【争知拙见】，获取更多干货！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fae524af9854d7929b818eb4a664f82a/" rel="bookmark">
			Oracle的三种高可用集群方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		快速浏览了一下Oracle官方的网页以及非官方的材料，简单了解了Oracle提供的高可用方案。
主要有三种：
1. RAC
RAC, Real Application Clusters
多个Oracle服务器组成一个共享的Cache，而这些Oracle服务器共享一个基于网络的存储。这个系统可以容忍单机或是多机失败。
不过系统内部的多个节点需要高速网络互连，基本上也就是要全部东西放在在一个机房内，或者说一个数据中心内。如果机房出故障，比如网络不通，那就坏了。所以仅仅用RAC还是满足不了一般互联网公司的重要业务的需要，重要业务需要多机房来容忍单个机房的事故。
2. Data Guard
Data Guard这个方案就适合多机房的。某机房一个production的数据库，另外其他机房部署standby的数据库。Standby数据库分物理的和逻辑的，物理的standby数据库主要用于production失败后做切换，而逻辑的standby数据库则在平时可以分担production数据库的读负载。
3. MAA
MAA(Maximum Availability Architecture)其实不是独立的第三种，而是前面两种的结合，来提供最高的可用性。
每个机房内部署RAC集群，多个机房间用Data Guard同步。
图片来源于：
http://www.stanford.edu/dept/itss/docs/oracle/10g/server.101/b10726.pdf
ps：微信搜一搜【争知拙见】，获取更多干货！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb6ea0eab726761a8ba2188366257acb/" rel="bookmark">
			Android实现购物车App(ListView和GridView的使用)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.ListView的使用 运行效果
点击商品跳转到商品详细信息
在Layout布局文件下创建item.xml文件,这里的item.xml文件就是上图中每一个item
创建item.xml
item.xml布局文件代码
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="150dp"&gt; &lt;ImageView android:id="@+id/item_displayimage" android:layout_width="100dip" android:layout_height="150dip" android:layout_centerVertical="true" android:layout_marginEnd="10dp" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintEnd_toStartOf="@+id/item_title" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toTopOf="parent" app:srcCompat="@drawable/iphone8" /&gt; &lt;TextView android:id="@+id/item_title" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginStart="10dp" android:layout_marginTop="20dp" android:text="Apple iPhone 8" android:textColor="#000000" android:textSize="20sp" app:layout_constraintStart_toEndOf="@+id/item_displayimage" app:layout_constraintTop_toTopOf="parent" /&gt; &lt;TextView android:id="@+id/item_size" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginStart="10dp" android:layout_marginTop="10dp" android:text="4.7英寸" android:textColor="#000000" android:textSize="15sp" app:layout_constraintStart_toEndOf="@+id/item_displayimage" app:layout_constraintTop_toBottomOf="@+id/item_title" /&gt; &lt;TextView android:id="@+id/item_money" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginStart="10dp" android:layout_marginTop="10dp" android:text="@string/money" android:textColor="#F44336" android:textSize="25sp" android:textStyle="bold" app:layout_constraintStart_toEndOf="@+id/item_displayimage" app:layout_constraintTop_toBottomOf="@+id/item_size" /&gt; &lt;TextView android:id="@+id/item_info" android:layout_width="wrap_content" android:layout_height="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb6ea0eab726761a8ba2188366257acb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f78b3b46246640c2441cb2e3dbec1e02/" rel="bookmark">
			安全认证框架Shiro之认证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 集成Spring1.1. 工作流程1.2. 权限URL配置细节1.2.1. 部分细节1.2.2. shiro中默认的过滤器1.2.3. url匹配模式 2. 认证2.1. 认证实现流程2.2. 认证方法中的实现步骤2.3. 认证方法代码2.4. 密码的对比2.5. 密码的MD5加密2.6. 密码的MD5盐值加密2.7. 多 Realm 验证2.8. 认证策略2.9. 把 realms 配置给 SecurityManager 3. 上一篇：[安全认证框架之Shiro详解](http://t.csdn.cn/JmL6h) 1. 集成Spring 导入Spring依赖包：spring-webmvc
在web.xml中配置监听、前端控制器
配置applicationContext.xml
注解驱动
扫描包
视图转换器配前后缀
静态资源访问
测试
导入shiro包
在web环境下配置shiro
在web.xml中配置shiroFilter
在applicationContext.xml配置shiro的核心组件：
DefaultWebSecurityManager
sessionMode可删掉。
这里需要加入EHcache的jar包及配置文件。
创建realm类，实现Realm接口，配置realm
anon表示可以被匿名访问，实际上是一个过滤芯器
authc必须认证（即登录）后才可能访问的页面
一般只配Login页和/**
1.1. 工作流程 shiro提供与web集成的支持，其通过一个ShiroFilter入口来拦截需要安全控制的URL，然后进行相应的控制。
ShiroFilter类似于如struts2/springmvc这种web框架的前端控制器，是安全控制的入口点，其负责读取配置（如ini配置文件），然后判断URL是否需要登录/权限等工作。
ShiroFilter的工作原理：
1.2. 权限URL配置细节 1.2.1. 部分细节 [urls]部分的配置，其格式是：“url=拦截器[参数], 拦截器[参数]”;
如果当前请求的url匹配[urls]部分的某个url模式，将会执行其配置的拦截器。
anon（anonymous）拦截器表示匿名访问（即不需要登录即可访问）。
authc（authentication）拦截器表示需要身份认证通过后才能访问。
1.2.2. shiro中默认的过滤器 过滤器名称： Anon
过滤器类： org.apache.shiro.web.filter.authc.AnnonymousFilter
概述： 没有参数，表示可以匿名使用
例子：/admins/**=anon
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f78b3b46246640c2441cb2e3dbec1e02/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f244df8b5933adbd71013f9bae72a73/" rel="bookmark">
			Ubuntu UFW 防火墙配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu 附带的 UFW（Uncomplicated Firewall）防火墙配置工具，用于管理 iptables 防火墙规则，用于监视和过滤传入和传出网络流量的工具，通过定义一组安全规则来确定是允许还是阻止特定流量。本文基于 Ubuntu 20.04 上配置和管理UFW。
文章目录 1.安装UFW2.检查UFW状态3.UFW默认策略4.应用配置文件5.启用 UFW6.打开 UFW端口7.拒绝连接8.删除UFW规则9.UFW操作10.IP伪装和转发 1.安装UFW Ubuntu 20.04默认安装有UFW，如果不存在，请执行
sudo apt update sudo apt install ufw 2.检查UFW状态 默认情况下禁用 UFW，使用以下命令检查 UFW 服务的状态：
sudo ufw status verbose 3.UFW默认策略 UFW 防火墙的默认行为是阻止所有传入和转发流量并允许所有出站流量。默认策略在 /etc/default/ufw 文件中定义，可以通过手动修改文件或使用以下命令来更改。
sudo ufw default &lt;policy&gt; &lt;chain&gt; 4.应用配置文件 应用程序配置文件是 INI 格式的文本文件，用于描述服务并包含服务的防火墙规则。应用程序配置文件是在 /etc/ufw/applications.d 安装包期间在目录中创建的。列出服务器上可用的所有应用程序配置文件：
sudo ufw app list 根据系统上安装的软件包，输出将类似于以下内容：
Available applications: Nginx Full Nginx HTTP Nginx HTTPS OpenSSH 要查找有关特定配置文件和包含的规则的更多信息，请使用以下命令：
sudo ufw app info 'Nginx Full' 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f244df8b5933adbd71013f9bae72a73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7d4012fa8a53afde2d65c6d57918f0b/" rel="bookmark">
			谈谈「数据仓库构建与分层」
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 先导知识之【数据库与ER建模】 1.1 数据库（DataBase） 数据库是按照数据结构来组织、存储和管理数据的仓库，是一个长期存储在计算机内的、有组织的、可共享的、统一管理的大量数据的集合。
数据库是以一定方式储存在一起、能与多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据集合，可视为电子化的文件柜，存储电子文件的处所，用户可以对文件中的数据进行新增、查询、更新、删除等操作，数据组织主要是面向事务处理任务。
1.2 数据库三范式 关系型数据库设计时，遵照一定的规范要求，目的在于降低数据的冗余性和保证数据的一致性，这些规范就可以称为范式NF(Normal Form)，大多数情况下，关系型数据库的设计符合三范式即可。
第一范式(1NF)：原子性，字段不可分
即表的列具有原子性，不可再分解，即列的信息，不能分解。数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等非原子数据项。如果实体中的某个属性有多个值时，必须拆分为不同的属性 。通俗理解即一个字段只存储一项信息。
举例如下，有如下订单表，购买商品一列，可以拆分为商品和数量两列。
第二范式(2NF)：唯一性，一个表只能说明一个事物，有主键，非主键字段依赖主键
第二范式是在第一范式的基础上建立起来的，第二范式（2NF）要求数据库表中的每个实例或行必须可以被唯一地区分，为实现区分通常需要我们设计一个主键来实现。当存在多个主键的时候，不能存在只依赖于其中一个主键的属性，否则就不符合第二范式。通俗理解是任意一个字段都只依赖表中的同一个字段。举例如下：
学生信息表中的成绩依赖于学号和课程两个主键，但是课程学分只是依赖课程的。可以拆分成右侧的两张表。
第三范式(3NF)：非主键字段不能相互依赖，不存在传递依赖
满足第三范式必须先满足第二范式,第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主键字段（某张表的某字段信息，如果能够被推导出来，就不应该单独的设计一个字段来存放）。
如果某一属性依赖于其他非主键属性，而其他非主键属性又依赖于主键，那么这个属性就是间接依赖于主键，这被称作传递依赖于主属性。第三范式中要求任何非主属性不依赖于其它非主属性，即不存在传递依赖。很多时候，我们为了满足第三范式往往会把一张表分成多张表。
举例如下：
第一张表中“院校地址”是依赖于“院校”的，“院校”依赖于主键“学号”，存在传递依赖，不符合第三范式，那么需要拆解成对应的学生表和院校表两张表。
注意： 三大范式只是一般设计数据库的基本理念，没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，提高读性能，就必须降低范式标准，降低范式就是增加字段，减少了查询时的关联，提高查询效率，适当保留冗余数据。这就是反范式，反范式化一定要适度，并且在原本已满足三范式的基础上再做调整的。
1.3 ER实体关系模型 ER实体关系模型（Entity-Relationship）是数据库设计的理论基础，当前几乎所有的OLTP系统设计都采用ER模型建模的方式，这种建模方式基于三范式。在信息系统中，将事物抽象为“实体”、“属性”、“关系”来表示数据关联和事物描述。
实体（Entity）：实体是一个数据对象，指应用中可以区别的客观存在的事物。例如：商品、用户、学生、课程等。它具有自己的属性，一类有意义的实体构成实体集。在ER实体关系模型中实体使用方框表示。
属性：对实体的描述、修饰就是属性，即：实体的某一特性称为属性。例如：商品的重量、颜色、尺寸。用户的性别、身高、爱好等。在ER实体关系模型中属性使用椭圆来表示。
关系（Relationship）：表示一个或多个实体之间的关联关系。实体不是孤立的，实体之间是有联系的，这就是关系。例如：用户是实体，商品是实体，用户选购商品这个过程就会产生“选购商品数量”，“金额”这些属性，这就是关系。再如：学生是实体，课程是实体，学生选择课程这个过程就产生了“课程数量”、“分数”这些属性，这就是关系。在ER实体关系模型中关系使用菱形框表示，并用线段将其与相关的实体链接起来。
ER实体关系模型又叫E-R关系图，实体与实体之间的关系存在一对一的关系、一对多的关系、多对多的关系。
一对一关系：例如：“学生”是实体，“身份证”是实体，一个学生只能有一个身份证，一个身份证也只能对应一个学生。
一对多关系：一对多关系反过来也就成了多对一的关系。例如：“学生”是实体，“账号”是实体，一个学生有多个账号，反过来就是多个账号对应一个学生。
多对多关系：例如：“学生”是实体，“课程”是实体，一个学生可以学习多个课程，一个课程可以被多个学生学习，整体来看，学生学习课程就成了多对多的关系。
1.4 ER实体关系模型案例 假设在电商购物系统中，对商品、用户设计ER实体关系模型图来表示商品信息、用户购买商品之间的业务联系，完成数据库逻辑模型设计。
设计ER实体关系模型图，步骤如下：
抽象出实体
找出实体之间的关系
找出实体的属性
画出E-R关系图
以上是ER实体关系图，为了方便，我们一般可以将ER实体关系图转换成如下数据库表格式，IDEF1X格式：
2. 数据仓库构建与分层 2.1 为什么构建数据仓库 在日益激烈的商业竞争中，企业迫切需要更加准确的战略决策信息。在以往的关系型数据库系统中，企业拥有海量的数据，这些数据对于企业的运作是非常有用的，但是对于商业战略决策和目标制定的作用甚微，不是战略决策要使用的信息。
关系型数据库很难将这些数据转换成企业真正需要的决策信息，原因如下：
一个企业中可能有很多管理系统平台，企业数据分散在多种互不兼容的系统中。例如：一个银行中的系统分为：核心系统，信贷系统，企业贷款系统，客户关系系统，助学贷款系统，理财系统、反洗钱系统等，这些系统数据有可能存储在不同类型的关系型数据库中。
关系型数据库中存储的数据一般是最基本的、日常事务处理的、面向业务操作的数据，数据一般可以更新状态，删除数据条目等。不能直接反映趋势的变化。例如：用户登录网站购买商品，在关系型数据库中最终存储的数据是某个用户下了一个订单，订单状态为付款待发货。一般用户在网站浏览了什么商品，搜索了什么样的关键字，这些数据不会存储在关系型数据库中，往往这些数据更具价值。
对于战略决策来说，决策者必须从不同的商业角度观察数据，比如说产品、地区、客户群等不同方面观察数据，关系型数据库中数据不适合从不同的角度进行分析，只是面向基本的业务操作。
所以我们需要对企业中各类数据进行汇集，清洗，管理，找出战略决策信息，这就需要建立数据仓库。
2.2 什么是数据仓库 数据仓库，Data Warehouse，可简写为DW或DWH。数据仓库是面向主题的、集成的（非简单的数据堆积）、相对稳定的、反映历史变化的数据集合，数仓中的数据是有组织有结构的存储数据集合，用于对管理决策过程的支持。
面向主题 ：主题是指使用数据仓库进行决策时所关心的重点方面，每个主题都对应一个相应的分析领域，一个主题通常与多个信息系统相关。
例如：在银行数据中心平台中，用户可以定义为一个主题，用户相关的数据可以来自信贷系统、银行资金业务系统、风险评估系统等，以用户为主题就是将以上各个系统的数据通过用户切入点，将各种信息关联起来。如下图所示：
数据集成 ：数据仓库中的数据是在对原有分散的数据库数据抽取、清理的基础上经过系统加工、汇总和整理得到的，必须消除源数据中的不一致性，以保证数据仓库内的信息是关于整个企业的一致的全局信息，这个过程中会有ETL操作，以保证数据的一致性、完整性、有效性、精确性。
例如某公司中有人力资源系统、生产系统、财务系统、仓储系统等，现需要将各个系统的数据统一采集到数据仓库中进行分析。在人力系统中，张三的性别为“男”，可能在财务系统中张三的性别为“M”，在人力资源系统中张三的职称为“生产部员工”，在生产系统中张三的职称为“技术经理”，那么当我们将数据抽取到数据仓库中时，需要经过数据清洗将数据进行统一、精确、一致性存储。
相对稳定： 数据仓库的数据主要供企业决策分析之用，所涉及的数据操作主要是数据查询，一旦某个数据进入数据仓库以后，一般情况下将被长期保留，也就是数据仓库中一般有大量的查询操作，基本没有修改和删除操作，通常只需要定期的加载、刷新。
例如：某用户在一天中多次登录某系统，关系型数据库中只是记录当前用户最终在系统上的状态是“在线”还是“离线”，只需要记录一条数据进行状态更新即可。但是在数据仓库中，当用户多次登录系统时，会产生多条记录，不会存在更新状态操作，每次用户登录系统和下线系统都会在数据仓库中记录一条信息，这样方便后期分析用户行为。
反映历史变化： 数据仓库中的数据通常包含历史信息，系统地记录企业从过去某一时点（如开始应用数据仓库的时点）到当前的各个阶段的信息，通过这些信息，可以对企业的发展历程和未来趋势做出定量分析和预测。
例如：电商网站中，用户从浏览各个商品，到将商品加入购物车，直到付款完成，最终的结果在关系型数据库中只需要记录用户的订单信息。往往用户在网站中的浏览商品的信息行为更具有价值，数据仓库中就可以全程记录某个用户登录系统之后浏览商品的浏览行为，加入购物车的行为，及付款行为。以上这些数据都会被记录在数据仓库中，这样就为企业分析用户行为数据提供了数据基础。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7d4012fa8a53afde2d65c6d57918f0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72fd64d5f6874f130472a1acd3a5625a/" rel="bookmark">
			SpringBoot，EasyExcel导入xlsx文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实体类
/** * 前端Excel导入数据库对应实体 * @author * @date 2022-03-10 */ @Data @TableName("") //一定要实现序列化，防止内存溢出 public class EquipmentExcel implements Serializable { /** * 设备编码 */ @ExcelProperty(value = {"所属部门"}) @TableField("dept_guid") private String deptGuid; } 控制层
@ControllerEndpoint(operation = "上传设备数据", exceptionMessage = "导入Excel失败") /*consumes： 指定处理请求的提交内容类型（Content-Type）， 例如: application/xml application/json application/x-www-form-urlencoded multipart/form-data application/octet-stream text/plain text/xml text/html*/ @PostMapping(value = "/uploadExcel", consumes = "multipart/*", headers = "content-type=multipart/form-data") @ResponseBody public List&lt;String&gt; uploadEquipmentInfo(MultipartFile file) throws IOException { return equipmentService.uploadEquipmentInfo(file,deviceCategory,deviceType,status,user); } 业务层
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72fd64d5f6874f130472a1acd3a5625a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a22970a44c28364b5f676885d580525c/" rel="bookmark">
			蒙特卡洛算法（Monte Carlo algorithm）求圆周率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		蒙特卡洛算法是统计模拟算法的一种，蒙特卡洛算法的数学理论基础是大数定理，在事件发生次数多的情况下，利用事件发生的频率作为时间发生概率的近似值
统计问题可直接求解，对于连续问题可不用离散化
与穷举法相对比而言，属于随机搜索，而穷举法属于给定特定规则的搜索
下面给出一个实例，来让蒙特卡洛算法求出圆周率
在一个2*2的矩形内，随机生成点，求在圆中相对矩形的数量比例，从而推出圆周率
推导过程：
矩形面积：圆的面积 = 所有点的数量：落在圆中点的数量
=&gt; 4r*r ：Pi*r*r = 所有点的数量：落在圆中点的数量
=&gt; Pi = 4*落在圆中点的数量/所有点的数量
#include &lt;iostream&gt; #include &lt;cstdlib&gt; #include &lt;ctime&gt; using namespace std; #define Step 100000000 //模拟实验的次数 int main() { srand((unsigned)time(NULL)); int inside = 0; for(int i = 0; i &lt; Step; ++i) { double x = static_cast&lt;double&gt;(rand()) / RAND_MAX; double y = static_cast&lt;double&gt;(rand()) / RAND_MAX; if(x * x + y * y &lt;= 1.0) { ++inside; //如果点在圆内则，让inside记录下来 } }	double pi = 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a22970a44c28364b5f676885d580525c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77c21b57b6aa30e4360496934d363048/" rel="bookmark">
			LinuxCentOS7关于PV neme券显示[unknown]问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LinuxCentOS7关于PV name券显示[unknown]问题 今天遇见了一个问题，就是本人想要扩展linux的分区容量时，创建的pv卷显示名称为[unknown]？？？？ 如下： [root@bogon ~]# pvs WARNING: Device for PV NJQyPM-K2N8-vk2O-04IG-GmS8-IGxZ-FJt1rj not found or rejected by a filter. PV VG Fmt Attr PSize PFree /dev/sda2 centos lvm2 a-- &lt;19.00g 0 [unknown] centos lvm2 a-m &lt;10.00g &lt;10.00g 这个问题是啥东西啊？我也没有瞎胡创建还是怎么着啊，就是不能正常使用了。
使用pvremove告知如下：
[root@bogon ~]# pvremove [unknown] WARNING: Device for PV NJQyPM-K2N8-vk2O-04IG-GmS8-IGxZ-FJt1rj not found or rejected by a filter. Device [unknown] not found (or ignored by filtering). ？？？？这下我就迷糊了，还不能删除。。。
告诉我什么找不到的意思，可是我查询明明是有的。
我又看了眼 发现vg name名称相同，会不会是重名导致的？？于是我又vgrename ：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77c21b57b6aa30e4360496934d363048/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6344c9f0de693d49d71cdbc083089e5c/" rel="bookmark">
			runner.logger.info(‘loss become infinite or NaN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用mmdetection训练的时候出现了如下错误：
2022-05-07 21:35:13,488 - mmdet - INFO - Epoch [1][50/5111] lr: 1.978e-04, eta: 18:35:19, time: 0.546, data_time: 0.217, memory: 1781, loss_cls: 17.7358, loss_bbox: 4.1217, loss: 21.8 575 2022-05-07 21:35:24,322 - mmdet - INFO - Epoch [1][100/5111] lr: 3.976e-04, eta: 12:58:42, time: 0.217, data_time: 0.003, memory: 1781, loss_cls: 13.2629, loss_bbox: 4.4149, loss: 17.6 778 2022-05-07 21:35:35,155 - mmdet - INFO - Epoch [1][150/5111] lr: 5.974e-04, eta: 11:06:25, time: 0.217, data_time: 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6344c9f0de693d49d71cdbc083089e5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bc057c173ed8925fe5b4de787c2d73a/" rel="bookmark">
			Linux之bash介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Shell的介绍 shell是一个程序，可以称之为壳程序，用于用户与操作系统进行交互。用来区别与核，相当于是一个命令解析器，Shell有很多中，这里列出其中几种
Bourne SHell(sh)Bourne Again SHell(bash)C SHell(csh)KornSHell(ksh)zsh 各个shell的功能都差不太多，在某些语法的下达下面有些区别，Linux预设就是bash。这里主要介绍bash
bash bash命令是sh命令的超集，大多数sh脚本都可以在bash下运行，bash主要有如下这些功能
bash功能 记录历史命令:bash可以记录曾经的命令，保持在~/.bash_history文件中，只保存上次注销登录之后的命令tab键自动补全:使用tab见可以自动不全命令或者目录ialias命令别名:可以使用alias ll='ls -al'来设置命令的别名工作控制:可以将某些任务放在后台去运行，这里不多种介绍程序脚本:可以执行shell脚本文件通配符:在查找相关文件或者执行相关命令时，可以使用通配符*内建命令type:可以使用type 命令来查看某个命令是否为内建在bash当中的命令「 bash变量 bash中变量有两种，分别是环境变量和自定义变量，可以理解为全局变量和局部变量，在理解他们的区别前，需要知道父程序和子程序，举个例子，当前的bash我们称之为父程序，而在这个bash下执行的任何程序，都称之为子程序。那全局变量和局部变量的区别就是，全局变量在子程序中仍然有效，局部变量只在当前程序中生效。（注意，一旦退出父程序这个bash的话，无论是全局变量还是局部变量都失效了，再次打开bash时，该变量是不存在的）
变量范围
变量的设定 变量的设定有几个规则，这里列举如下:
设定变量通过=来链接，例如name=sujinzhou,两边不能有空格，如果有空格的话，需要用引号变量名只能是英文名和数字，只能是英文开头如果变量内容被引号扩起来的话，双引号和单引号是有区别的双引号里面的特殊字符，会保持原有的特性。单引号里面的特殊字符，只会是字符使用\将特殊字符转换为一般字符使用``这个符号扩起来的命令会先计算这个命令里面的内容，这个指令等价于$()给原有的变量添加值时，使用 变 量 , " {变量}," 变量,"变量"再加具体的内容 变量类型
bash中变量类型有两种，一种是普通的字符串，一种是整数;设置变量的类型使用的是declare命令，delcare的命令格式如下
declare -[axir] variable 参数的意思:
-a:将variable定义为数组-i:将后面的变量设置为整数类型-x:与export一样，将后面的变量设置为环境变量-r:将后面的变量设置为只读变量
如果declare命令没有接任何变量的话，则表示显示所哟的 定义数组
var[index]=content 变量的删除 删除变量使用如下命令
unset 变量名 变量的查看 查看单个命令的内容，可以使用echo命令，使用echo $变量名就可以查看变量内容，另外如果要查看所有变量有3个命令，分别是如下几个命令，每个命令又有区别。
echo $变量名:用于显示制定变量env:用来查询环境变量，set:显示shell变量，包括私有变量与用户变量，不同的shell有不同的私有变量，在shell中设置变量之后，可以通过set查到export:显示当前导出成用户变量的shell变量，也是用来查询环境变量的，shell的私有变量不会出现 Bash shell的操作环境 在shell中设置的变量，无论是环境变量还是自定义变量，在bash中注销登录之后，就失效了。下次登录时，是没有这些变量的，如果想要这些变量永久生效，是需要下如配置文件的，bash在启动时，会读取这个配置文件，来设置当前shell的各种变量。shell分为两种，分别是login shell和nonlogin shell，这里先说login shell；login shell是需要输入用户名和密码的，一般情况下，login shell在登录之后，会去读取两个文件，来设置当前shell的环境变量，分别是
/etc/profile:这个配置文件是默认配置文件，是系统整体的设置~/.bash_profile或者~/.bash_login或者~/.profile：这个是用户的自定义设置文件 shell在读取/etc/profile中的文件之后，会去读取用户自定义的设置文件，按照顺序读取上文中所说的自定义设置文件，只要找到其中任何一个，就不再继续。在用户自定义的配置文件中，都会调用~/.bashrc这个文件，来配置当前的这个shell
/etc/profile或者~/.bash_profile都是在登录的时候才去读取，如果将自己的一些设置到这些文件之后，一般都需要重新登录一次shell才会生效，也可以使用source这个命令，来读取配置文件的内容到当前的这个shell
数据流重导向 数据重导向，表示将数据从一个地方导向到另外一个地方，在linux的bash中，有两种输出，分别是
标准输出:输出在屏幕当中的正常的提示信息，或者正常的返回值错误输出:命令执行出错时，显示在屏幕当中的出错信息 有时候，我们需要将标准输出或者错误输出保留到某个文件中，方便以后你查询，这种情况下，就需要数据流重导向，也就是将输出到屏幕的信息导向到一个文件中。而导向又分为标准输出导向和错误输出导向
标准输出重导向:代码为1,使用&gt;或者&gt;&gt;错误输出重导向:代码为2,使用2&gt;或者2&gt;&gt; 在linux中一个特殊的装置，是/dev/null，所有将导向到这个装置的数据都会被丢弃，相当与删除数据。
有时候，我们需要将标准输出和错误输出导出到文件中，则可以使用符号 2&gt;&amp;1，这个符号是连在一起的，表示将错误和标准输出一起输出。
除了输出之外，还有输入，
标准输入重导向:代码为0,使用&lt;
某些由键盘输入的数据，可以使用标准输入重导向，从文件中输入数据。 管线命令 常用的关系命令有如下几个，具体的用法可以查询man文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bc057c173ed8925fe5b4de787c2d73a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e75567e0abbcdaeb49ec2e3d15ebd1e/" rel="bookmark">
			结构体数组：有5个同学的信息（包括：学号，名字，成绩），要求按照成绩从大到小的顺序输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include&lt;stdio.h&gt; int main() { struct student{ int no; char name[20]; int cj; }a[5]={{01,"zhao",78},{02,"hu",76},{03,"wang",98},{04,"li",34},{05,"ma",44}}; int i,j; struct student t; for(i=0;i&lt;5;i++) { j=0; for(j=0;j&lt;4;j++) { if(a[j].cj&lt;a[j+1].cj) {t=a[j];a[j]=a[j+1];a[j+1]=t; } } } for(i=0;i&lt;5;i++) { printf("%d %s %d\n",a[i].no,a[i].name,a[i].cj); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/378e9a026ef9f06b85293fe384deb558/" rel="bookmark">
			转录组-差异基因热图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 top_de_exp&lt;-dplyr::slice(de_result2,1:20)%&gt;%#挑取差异最大的 select(-c(2:8))%&gt;%#去掉2-8列 column_to_rownames(var="id")#列变行 de_result2为上一篇转录组-火山图得到的数据！
#第一种做图方式
library(pheatmap) pheatmap(log10(top_de_exp+1), #cluster_rows = F,#顺序按照导入表一致且左侧不聚类,一般不用 #cluster_cols = F,#上面不聚类,一般不用 show_colnames = F)#去掉行名 #第二种做图方式:标准化之后
pheatmap(top_de_exp, scale = "row", show_rownames = F)#不显示基因名字/列名 #第三种做图方式
#cols&lt;-list( #group=c(C="#4DBBD5FF",P="#00FFFF",HP="#EE82EE",HC="#FFA07A"))#不运行 pheatmap(top_de_exp, scale = "row", color = colorRampPalette(c("green","white","red"))(200),#绿-红：200个颜色 annotation_col = sample_info[c("group")],#sample_info表格第一列必须是分组情况，不能为“1/2/3..”，否则group无颜色 annotation_colors=list( #annotation_colors=cols# group=c(C="#4DBBD5FF", P="#00FFFF", HP="#EE82EE", HC="#FFA07A")), cutree_rows = 2) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be83179bc0353e0cb4ed934459b73202/" rel="bookmark">
			scrapy框架实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		👨‍💻更多精彩尽在博主首页：i新木优子👀
🎉欢迎关注🔍点赞👍收藏⭐留言📝
🧚‍♂️寄语:当你将信心放在自己身上时，你将永远充满力量👣
✨有任何疑问欢迎评论探讨
什么是全站数据crawling呢，顾名思义就是将一个网站的全部数据都crawling下来，这里我采用scrapy框架，这里我提供了很多方式，可以挑选自己喜欢的玩一玩
接下来有请我们的幸运儿：不能说的网站名，我怕不过审🚗
0️⃣1️⃣创建scrapy项目
scrapy startproject 文件名 cd 文件名 scrapy genspider 名称 要crawling网站的域名 0️⃣2️⃣更改settings配置文件
USER_AGENT ----------&gt;设置UA ROBOTSTXT_OBEY ----------&gt;君子协议（我们爬虫当然不会遵守啦😎） LOG_LEVEL ----------&gt;日志等级（建议设置为WARNING） ❗❗❗一定要记得设置·DOWNLOAD_DELAY·限制访问频率
因为scrapy的底层是协程，速度非常快，如果不设置可能用不了几分钟就会弹出安全验证无法抓取网页。有些网站如果不设置，抓取的数据量够多几分钟就会把网站跑die了,毕竟我们是善良的spider，不要破坏网站哦😄
首先，我们进入网页按键盘上的F12进入开发者模式，在Elements中做参考，Elements可以做参考不能作为依据，因为Elements是经过css和js渲染之后形成的，作为依据的只能是页面源代码（Sources）。可以观察到每一个li标签就是一条数据（这里我们先不考虑分页，先抓取一页的数据，一页搞定了分页就很简单了）
我们要是只抓取首页上的数据就很没意思，更多的是想点击进入详情页,抓取详情页中的数据，详情页的数据才更全面
0️⃣3️⃣解析首页数据拿到详情页的url
li_list = resp.xpath("//ul[@class='viewlist_ul']/li") # 拿到每一个li for li in li_list: href = li.xpath("./a/@href").extract_first() print(href) 0️⃣4️⃣拿到的url如上图，发现这并不是我们想要的url它不完整，所以我们要将href进行拼接，得到真正的url
href = resp.urljoin(href) 0️⃣5️⃣这样我们就拿到了真正的url，仔细观察发现最后一条数据并不是我们想要的（最后一条url是广告），加一个if判断就可以个将没用的url去除
if "topicm" in href: continue 0️⃣6️⃣到此为止，我们拿到了每一条详情页的url，只需再一次发送请求进入详情页，解析详情页拿到我们要的数据即可
⚠⚠⚠我们的目的是为了实现全站数据crawling,数据量是非常大的，所以我们要提前预估风险，就像上图中的数据可能某一条或某几条会缺失，这就涉及到缺省值的处理
0️⃣7️⃣💎缺省值的处理：
方式一：
可以用if条件判断，通过判断小标题拿对应的内容（这种比较麻烦，数据越多难度越大）方式二（推荐）：
自己定义一种数据结构作为映射（简便且数据规整） 代码和运行图片如下：
car_tag = { "表显里程": "mileage", "上牌时间": "time", "挡位/排量": "displace", "车辆所在地": "location", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be83179bc0353e0cb4ed934459b73202/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/638619bec63428b0bb2f5766ee004490/" rel="bookmark">
			linux下安装yum步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装yum前下介绍以下知识。 1、yum介绍 Yum（全称为 Yellow dog Updater, Modified）是一个在Fedora和RedHat以及CentOS中的Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。
2、Fedora介绍 Fedora Linux（第七版以前为Fedora Core）是由Fedora项目社区开发、红帽公司赞助，目标是创建一套新颖、多功能并且自由（开放源代码）的操作系统。Fedora是商业化的Red Hat Enterprise Linux发行版的上游源码。
3、build-essential软件包
提供编译程序必须软件包的列表信息。build-essential包包含了开发很多必要的软件包，安装一个build-essential包，对应C/C++依赖的好多包都会被安装。 可以查看build-essential的依赖关系，输入命令：apt-cache depends build-essential
从上面可以看出，安装build-essential之后，对于上面的依赖都会被安装。
本文使用的linux系统是ubuntu系统。
二、安装yum 1、首先安装build-essential包， 命令：apt-get install build-essential
安装完成之后，出现如下提示：
上述安装过程后，有可能会报错，按照提示输入命令后，继续输入上面的命令就可安装成功。
2、安装yum 步骤：
sudo apt-get install yum 我已安装，再次输入表示已安装，如下
安装过程中，如果出现错误：apt-get install E: 无法定位软件包问题请下面看问题解决步骤，若正常，请略过下面步骤。
///apt-get install E: 无法定位软件包 问题解决start
分析：出现无法定位问题，是因为找不到源镜像导致的，只需要将/etc/apt/路径下的source.list文件内容改成对应的源镜像就像。
步骤如下：
cd /etc/apt/ // 切换到/etc/apt/ 目录下 sudo cp sources.list sources.list.old // 先把源文件复制到sources.list.old，备份 sudo vim sources.list //编辑文件 本文修改的sources.list文件内容如下：
deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb http://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/638619bec63428b0bb2f5766ee004490/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e49c4d2b2e932aa8377301792b74cd05/" rel="bookmark">
			redis学习笔记（十一）AKF、CAP理论
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、AKF原则1.redis单节点有什么问题？(1) 单点故障(2) 容量有限(3) 压力大 2.什么是AKF原则？ 二、CAP理论1.什么是CAP2.主从和主备的区别：3.主备模型怎么自动的故障转移？ 一、AKF原则 1.redis单节点有什么问题？ (1) 单点故障 (2) 容量有限 (3) 压力大 2.什么是AKF原则？ AKF网上查不到是什么的缩写。。
说穿了，就是从3个维度解决单以上3个问题（不止redis，所有分布式系统都遵循）。
x轴：全量，镜像
一般用主从、主备来解决。
主备解决单点故障问题，读写分离解决读压力问题
y轴：业务，功能
多个不同实例解决
如redis实例1储存用户相关的数据
redis实例2储存订单相关的数据
解决容量有限和压力大的问题
z轴：再拆分，可用优先级或逻辑拆分
如redis实例2存订单数据，但订单数据太多一个redis实例也存不下了咋办？那就进一步拆分，用多个redis储存订单数据。然后用某种算法(如一致性hash算法)访问多个redis。
进一步解决容量有限和压力大的问题。
AKF原则图解：
二、CAP理论 1.什么是CAP C:Consistency 一致性
A:Availability 可用性
P:Partition Tolerance 分区容错性(最难理解)
CAP理论指的是同一个分布式系统中，3条性质最多只能满足2条
为什么只能满足2条？
答：如主从模型中，主被set k1 1，从机立刻get k1是否立刻能获取k1的值？
此时就要分情况
1.如果主set k1后立刻对所有备机加锁，等备机写入k1后才释放锁，那么从库就能获取k1。这种就是CP模型（一致性优先，但加锁期间会导致系统不可用），这种一致性又称为强一致性
2.如果主set k1不加锁，而是异步的向从库set k1，那么从库就有可能获取不到k1(可能还被同步过去)，异步期间系统依然可用。这种就是AP模型（可用性优先），这种一致性又称为弱一致性。
那CA模型又是啥？
这种一般不讨论。因为CA模型就是单实例系统（非分布式）。P是分区容错性，意思就是分布式允不允许出错的意思（如网络故障）。
2.主从和主备的区别： 主备：只能访问主，备是用来接替主的
主从：都可以访问，但更偏向主（更偏向这个方案）
redis 2种都可以
3.主备模型怎么自动的故障转移？ 意思就是主挂了，备机怎么自动的接替主机。很简单，用另一个程序监控主机，一监控到挂了就执行脚本，执行设置从机为主机之类的相关操作。那问题又来了，监控程序自己也是一个单点，所以监控程序也需要做高可用。
如果有写错的地方，欢迎大家指正，感谢！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20c8b567c9fc0f06322cb47c1d989221/" rel="bookmark">
			MassEntity中SimpleMovement的使用方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MassEntity中的SimpleMovementTrait的主要作用就是演示用。
所以如果你希望能够快速的使用到这个框架，那么你就可以使用到这样的MassEntityConfig。
在MassEntityConfig中添加DebugVisualizationTrait，用于快速的给予Agent显示。
添加SimpleMovementTrait，根据Agent的VelocityFragment，来进行移动。
添加VelocityRandomizerTrait，随机化Agent的VelocityFragment。
至于其它的操作，要是不了解的话，可以转到我的博客，【UE5 Mass AI 基础教程一】代理生成
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/810447a95fd35c6746c415cf8a093687/" rel="bookmark">
			如何把网址配置为http和https可以同时访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.打开iis7 ,找到具体站点
2.点击站点后右侧有个绑定按钮
3.点击绑定，增加https,设置端口，ssl选择 iis证书
4.找到ssl设置，要求证书不勾选，客户证书，忽略
5.如果右侧不显示浏览站点https,点击站点高级设置-已启用协议，把http改为https保存，刷新。然后在改为http
亲测有用。
更多信息请查看 个人博客 或者关注公众号：Z技术
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f245d41875cc9e4e0002b3476b73a8a/" rel="bookmark">
			加域或win预览计划空白无法加入win11预览体验计划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先下载win11升级检测工具，检测通过才能升级，这是基础
1，修改注册表。管理员命令启动powershell
输入：
$path = "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\DataCollection" # Telemetry level: 1 - basic, 3 - full $value = "3" New-ItemProperty -Path $path -Name AllowTelemetry -Value $value -Type Dword -Force New-ItemProperty -Path $path -Name MaxTelemetryAllowed -Value $value -Type Dword -Force 结果
2，win键+i 进入更新和安全
点击：windows预览体验计划，选择dev通道，输入windows账号验证
3，打开window更新，获取更新
系统会自动推送win11更新，全部安装就行
更多信息请查看 个人博客 或者关注公众号：Z技术
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0ad8fccafbf72a4424b1abc7c6ea830/" rel="bookmark">
			云平台本地系统挂虚机载镜像qcow2操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在一些使用场景中，直接把虚机镜像文件挂接在本地系统中，也是一个简便的办法。例如。
# guestmount -a ax73c.qcow2 -m /devmapper/vgsz00-lv_root --rw /mnt
如果事先不知道虚机内部分区的路径信息，则可以使用参数-i来让guestmount自己决定使用哪一个挂接点：
# guestmount -a ax73c.qcow2 -i --rw /mnt
接着使用# rpm -qa --dbpath /mnt/var/lib/rpm 查看该虚机安装了哪些rpm包
操作完成后，使用# umount /mnt退出。
mkdir -p /mnt_tmp
guestmount -a ax73c.qcow2 -i --rw /mnt_tmp
[root@test ~]# guestmount -a ax73c.qcow2 -i --rw /mnt_tmp
libguestfs: error: could not create appliance through libvirt.
[root@test ~]# guestmount -a ax73c.qcow2 -i --rw /mnt_tmp
libguestfs: error: could not create appliance through libvirt.
Try running qemu directly without libvirt using this environment variable:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0ad8fccafbf72a4424b1abc7c6ea830/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12b4fc8ad6691a4bd2487b75ec2120a1/" rel="bookmark">
			Java基础：Date类的练习题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目： 请使用日期时间相关的API，计算出一个人已经出生了多少年，再转换为多少天（一年365天）。
分析: 1.使用Scanner类中的方法next,获取出生日期
2.使用DateFormat类中的方法parse,把字符串的出生日期,解析为Date格式的出生日期
3.把Date格式的出生日期转换为毫秒值
4.获取当前的日期,转换为毫秒值
5.使用当前日期的毫秒值-出生日期的毫秒值
6.把毫秒差值转换为天(s/1000/60/60/24)
实现： public class demo02Test { public static void main(String[] args) throws ParseException { //1.使用Scanner类中的方法next,获取出生日期 Scanner sc = new Scanner(System.in); System.out.println("请输入您的出生日期,格式:yyyy-MM-dd"); String birthdayDateString = sc.next(); //2.使用DateFormat类中的方法parse,把字符串的出生日期,解析为Date格式的出生日期 SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd"); Date birthdayDate = sdf.parse(birthdayDateString); //3.把Date格式的出生日期转换为毫秒值 long birthdayDateTime = birthdayDate.getTime(); //4.获取当前的日期,转换为毫秒值 long todayTime = new Date().getTime(); //5.使用当前日期的毫秒值-出生日期的毫秒值 long time = todayTime - birthdayDateTime; //6.把毫秒差值转换为天(s/1000/60/60/24) long day = time/1000/60/60/24; long year = day/365; System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12b4fc8ad6691a4bd2487b75ec2120a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f07dcfea893c9a6a363f67a222072ea/" rel="bookmark">
			Redis - Redisson lock和tryLock原理解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redisson 分布式锁原理
1. 工具类 package com.meta.mall.common.utils; import lombok.extern.slf4j.Slf4j; import org.redisson.api.RLock; import org.redisson.api.RedissonClient; import org.springframework.stereotype.Component; import javax.annotation.Resource; import java.util.concurrent.TimeUnit; /** * redisson 分布式工具类 * * @author gaoyang * @date 2022-05-14 08:58 */ @Slf4j @Component public class RedissonUtils { @Resource private RedissonClient redissonClient; /** * 加锁 * * @param lockKey */ public void lock(String lockKey) { RLock lock = redissonClient.getLock(lockKey); lock.lock(); } /** * 带过期时间的锁 * * @param lockKey key * @param leaseTime 上锁后自动释放锁时间 */ public void lock(String lockKey, long leaseTime) { RLock lock = redissonClient.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f07dcfea893c9a6a363f67a222072ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1295559ea41de052599020059b7d536/" rel="bookmark">
			hadoop集群 Web 页面在linux中可以访问到，但是在本地访问不了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【注】1、当我们成功启动集群之后，发现在Linux中可以打开Web页面，而在本地却打不开。这是因为你没有关闭防火墙。
问题描述
解决方案
1、查看防火墙状态：systemctl status firewalld.service
2、关闭防火墙 systemctl stop firewalld.service
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9fbc0dddc5907156355fa8060dcd96f/" rel="bookmark">
			hadoop3.0 启动后输入 jps没有进程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【注】1、启动集群之后，输入jps,发现没有任何返回。原因就是你的JDK版本不对。其次
hadoop集群格式化完成后,启动集群成功,jps没有进程
原因:
java的进程好没有没记录到tmp文件夹下.
问题 解决 1、重新更换一个JDK版本即可，不过这里 source /etc/profile 好像没用，建议重启。
2、按下面链接中的方案操作，亲测有效
解决方案
楼主找了好久，才找到的解决方案，特来分享给大家，希望对大家有帮助
接下来有
衍生问题：jps只显示一个jps进程 问题描述
[lxm@hadoop102 hadoop-3.1.3]$ jps 10254 jps 解决方案
1、删除集群中hadoop所有的data和logs文件夹，然后 hdfs namenode -format 格式化
2、最后在重启 sbin/start-dfs.sh
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d580c8f8f86a51bc5ff49ca386063700/" rel="bookmark">
			搭建hadoop 集群，出现 Permission denied (publickey,gssapi-keyex,gssapi-with-mic,password).
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【注】1、出现这个原因在于在我们生成 ssh 免密登录的时候。没有把is_rsa.pub(公钥)追加到 authorized_keys文件后面。
2、理论上，设置成功的话 输入 ssh hadoop103 是不需要输入密码的
问题描述 解决方案 把is_rsa.pub(公钥)追加到 authorized_keys文件后面，然后在分发一下ssh-copy-id 主机名
[lxm@hadoop102 .ssh]$ cat is_rsa.pub &gt;&gt; authorized_keys [lxm@hadoop102 .ssh]$ reboot [lxm@hadoop102 .ssh]$ ssh-copy-id hadoop103 楼主亲测有效！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0738887e6eb12bf329d5dc08fb2fff94/" rel="bookmark">
			Hive安装详细步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hive安装详细步骤 基础环境准备 Hive安装前，首先以安装完成Hadoop，且本文中使用MySQL作为Hive的元数据存储库，MySQL数据库也要提前准备好，关于Hadoop和MySQL的安装可参考另外两篇文章：
完全分布式Hadoop集群搭建
CentOS离线安装MySQL
Hive安装包下载 直接从官网下载需要的版本即可：Hive官网
本文中安装的版本为：apache-hive-2.3.9
上传并解压安装包 本示例中Hive安装在/app目录下，解压后重命名为hive
cd /app tar -zxvf apache-hive-2.3.9-bin.tar.gz mv apache-hive-2.3.9-bin hive 配置环境变量 vim ~/.bashrc # 添加以下内容 export HIVE_HOME=/app/hive export PATH=$PATH:$HIVE_HOME/bin export HADOOP_HOME=/app/hadoop-2.10.1 # 生效环境变量 source ~/.bashrc 查看Hive版本，正常输出无问题即可，如下：
# 查看Hive版本命令 hive --version # 输出信息如下 Hive 2.3.9 Git git://chaos-mbp.lan/Users/chao/git/hive -r 92dd0159f440ca7863be3232f3a683a510a62b9d Compiled by chao on Tue Jun 1 14:02:14 PDT 2021 From source with checksum 6715a3ba850b746eefbb0ec20d5a0187 修改Hive配置 &lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt; &lt;?xml-stylesheet type="text/xsl" href="configuration.xsl"?&gt; &lt;configuration&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0738887e6eb12bf329d5dc08fb2fff94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b525b8f37f542e5396eb33a2cf134ed2/" rel="bookmark">
			Spring笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Spring 1.1 简介 Spring : 春天 —&gt;给软件行业带来了春天
2002年，Rod Jahnson首次推出了Spring框架雏形interface21框架。
2004年3月24日，Spring框架以interface21框架为基础，经过重新设计，发布了1.0正式版。
很难想象Rod Johnson的学历 , 他是悉尼大学的博士，然而他的专业不是计算机，而是音乐学。
Spring理念 : 使现有技术更加实用 . 本身就是一个大杂烩 , 整合现有的框架技术
官网 : http://spring.io/
官方下载地址 : https://repo.spring.io/libs-release-local/org/springframework/spring/
GitHub : https://github.com/spring-projects
&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; 1.2 优点 1、Spring是一个开源免费的框架 , 容器 .
2、Spring是一个轻量级的框架 , 非侵入式的 .
3、控制反转 IoC , 面向切面 Aop
4、对事物的支持 , 对框架的支持
…
一句话概括：
Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器（框架）。
1.3 组成 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-DwEnnU9d-1652450458742)(img/image-20220503170707826.png)]
Spring 框架是一个分层架构，由 7 个定义良好的模块组成。Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b525b8f37f542e5396eb33a2cf134ed2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/084cee4d2a193e9cf8226f58f8ce94dd/" rel="bookmark">
			java读取共享文件夹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、JCIFS介绍 JCIFS是使用纯Java开发的一个开源框架，通过smb协议访问远程文件夹。该框架同时支持Windows共享文件夹和Linux共享文件夹，不过，Linux共享文件夹需要安装Samba服务软件(官网：http://www.samba.org/)。
2、SMB协议 SMB协议(Server Messages Block，信息服务块)是一种在局域网上共享文件和打印机的一种通信协议，它为局域网内的不同计算机之间提供文件及打印机等资源的共享服务。
SMB协议是客户机/服务器型协议，客户机通过该协议可以访问服务器上的共享文件系统、打印机及其他资源。
3、设置共享文件夹 创建一个文件夹文件夹右键属性点击共享选中的 “everyone” 选项，点击添加；设置级别权限，最后点击最下方的共享文件夹右键属性，选择高级共享，点击权限，设置权限为完全控制，然后确定打开网络和共享中心，点击更改高级共享设置，开启“启用文件和打印机共享”和“关闭密码保护共享”，点击“保持修改”在另一台电脑输入共享文件夹电脑的ip地址。如：\192.168.1.6
4、java读取共享文件夹中的文件 4.1、添加smb协议依赖 &lt;!--smb协议获取共享文件夹内容--&gt; &lt;dependency&gt; &lt;groupId&gt;jcifs&lt;/groupId&gt; &lt;artifactId&gt;jcifs&lt;/artifactId&gt; &lt;version&gt;1.3.17&lt;/version&gt; &lt;/dependency&gt; 4.2、创建连接，并将文件复制到本地桌面中的file文件夹 public void getRemoteFile(){ InputStream in = null; try { // 创建远程文件对象 // smb://用户名:密码/共享的路径/... // smb://ip地址/共享的路径/... String remoteUrl = "smb://192.168.xx.xx/file/"; SmbFile remoteFile = new SmbFile(remoteUrl); remoteFile.connect();//尝试连接 if(remoteFile.exists()){ // 获取共享文件夹中文件列表 SmbFile[] smbFiles = remoteFile.listFiles(); for (SmbFile smbFile : smbFiles) { createFile(smbFile); } }else { log.error("文件不存在！"); } }catch (Exception e) { log.error("访问远程文件夹出错：" + e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/084cee4d2a193e9cf8226f58f8ce94dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0626f0638ba00f860a84e16b6c8c7dd8/" rel="bookmark">
			数据库安全性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、数据库安全性：保护数据以防不合法的使用所造成的数据泄露、更改或破坏。
重要性：
特点：数据共享数据共享带来安全性的问题数据共享不能无条件共享 数据库不安全因素：
1、非授权用户身份对数据库的恶意存取和破坏----------安全措施：用户身份鉴别、存取控制、视图
2、数据库中重要或敏感数据被泄露-----------安全措施：审计、日志、入侵检测、数据加密
3.安全环境脆弱性，包括：硬盘、OS、网络..---------可信计算机标准
数据库安全技术：
1.用户身份鉴别
系统最外层安全保护措施系统提供一定的方式让用户表示自己的名字和身份系统进行核实，通过鉴定后才提供资统使用权 口令：静态（易被窃取），动态（一次一密）
生物特征识别:指纹，声音，照片
2.存取控制
对于有上机权的用户还要根据系统预先定义好的外模式（视图）或用户权限进行存取控制，保证用户只能存取有权存取的数据。
方法：定义用户权限，合法权限检查
常用存取控制方法：
自主存取控制（DAC），C2级，灵活
强制存取控制（MAC），B1级，严格
3.视图机制
视图能够把要保密的数据对无权存取数据的用户隐藏起来，因此对数据提供一定程度的安全保护
间接实现了支持存取谓词的用户权限定义
4.审计
系统自动建立审计日志，将用户对数据库的所有操作记录在上面
DBA利用审计日志找出非法存取数据的人，时间，内容
C2以上安全级别的DBMS必须具有审计功能
审计分类：
用户级审计：针对自己创建的数据库表或视图进行审计（记录所有用户一切成功或不成功的访问要求以及各类型的SQL操作）系统及审计：由DBA设置，检测成功或失败的登录要求，监测GRANT和REVOKE操作以及其他数据库权限下的操作 审计AUDIT语句：
AUDIT：设计审计功能NOAUDIT：取消审计功能 对修改SC表结构或修改SC表数据的操作进行审计
audit alter，update
on SC；
取消对SC表的一切审计
noaudit alter，update
on SC； 5.数据加密
数据库中的数据以密码形式存放，使用时由用户设计的解码程序将其转化成用户可读的数据。这样数据即使被窃取，也只是一些无法辨认的代码。
分类：存储加密、传输加密
数据库加密实现层次：
·OS层 ：文件级加密，加解密力度粗糙
·DBMS内核层：视图+触发器+扩展索引+外部调用来数据加密，加重数据库内核负担
·DBMS外层：做数据加密系统，可扩充性强，功能查询效率限制
二、自主存取控制方法DAC
用户对不同数据库对象有不同存取权限，不同用户对同一对象有不同权限，用户可将其权限转授其他用户。
组成要素：数据对象、操作类型
授权：用户可以在哪些数据库对象上进行哪些类型的操作。
对象类型对象操作类型数据库模式模式create schema基本表create table，alter table视图create view索引create index数据基本表和视图select，insect，update，delete，references，all privileges属性列select，insert，update，references,all privileges SQL中grant和revoke语句实现自主存取控制:
grant/revoke授权 1.grant语句：授权（不能循环授权）
grant &lt;权限&gt; [，&lt;权限&gt;]...
[on &lt;对象类型&gt; &lt;对象名&gt;]
to &lt;用户&gt; [，&lt;用户&gt;].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0626f0638ba00f860a84e16b6c8c7dd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0fab838a9a40d60fb07b8eaab08e925/" rel="bookmark">
			Wget下载慢，CentOs换成阿里源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先确定安装有wget
切入CentOS-Base.repo所在目录 cd /etc/yum.repos.d 将CentOS-Base.repo改名成CentOS-Base.repo.bak mv CentOS-Base.repo CentOS-Base.repo.bak 下载阿里源文件 wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/Centos-7.repo 4. 清除缓存
yum clean all 5. 重新生成缓存
yum makecache 切换源前后速度对比
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2baffcfe82ab1d23c005920e6bb9e665/" rel="bookmark">
			java的char 转byte
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java中的char类型即可以存储英文字母也可以存储汉字，汉字在java中使用Unicode编码占两个字节。char转byte数组的方法如下：
public static byte[] charToByte(char c) { byte[] b = new byte[2]; b[0] = (byte) ((c &amp; 0xFF00) &gt;&gt; 8); b[1] = (byte) (c &amp; 0xFF); return b; } 另外附上其它几种数字类型和byte类型之间互相转换方法
public static byte[] float2byte(float f) { // 把float转换为byte[] int fbit = Float.floatToIntBits(f); byte[] b = new byte[4]; for (int i = 0; i &lt; 4; i++) { b[i] = (byte) (fbit &gt;&gt; (24 - i * 8)); } // 翻转数组 int len = b.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2baffcfe82ab1d23c005920e6bb9e665/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b1f36e827fc18bb5b9dbcfba8de277a/" rel="bookmark">
			markdown常用数学符号小结⌈ ⌉⌊ ⌋
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 上下标:运算符：向量：微积分：求和求极限：括号：省略号：转义字符： 数学符号集合运算符：对数符号：箭头符号：三角运算符：希腊字母：更多矩阵 markdown 数学公式符号大全
史上最全Markdown公式、符号总结
$$ \begin{gathered} \operatorname{arg\,max}_a f(a) = \operatorname*{arg\,max}_b f(b) \\ \operatorname{arg\,min}_c f(c) = \operatorname*{arg\,min}_d f(d) \end{gathered} $$ $$ \underset{&lt;constraints&gt;}{\operatorname{&lt;argmax\;or\;argmin&gt;}} $$ $\underset {c \in C} {\operatorname {argmax}}$ arg max ⁡ a f ( a ) = * ⁡ a r g m a x b f ( b ) arg min ⁡ c f ( c ) = * ⁡ a r g m i n d f ( d ) \begin{gathered} \operatorname{arg\,max}_a f(a) = \operatorname*{arg\,max}_b f(b) \\ \operatorname{arg\,min}_c f(c) = \operatorname*{arg\,min}_d f(d) \end{gathered} argmaxa​f(a)=*argmaxb​f(b)argminc​f(c)=*argmind​f(d)​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b1f36e827fc18bb5b9dbcfba8de277a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e785cbe4338c9ac621c6ea767a6713e/" rel="bookmark">
			Pytorch(GPU)配环境原理：cuda&#43;cudnn&#43;pytorch配环境的每一步到底干了些什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：18届cyl 时间：2022.5.11 参考文章：https://blog.csdn.net/qq_42406643/article/details/109545766 最近帮舍友配pytorch、cuda、cudnn环境的时候，回想起来自己两年以前也只会按照教程安装，例如像个白痴一样搜索cuda xx.x+cudnn x.x+pytorch1.x.0安装教程，顺着步骤来，中间错一步或者一步不一样，简直十万个草泥马路过。一直是出现什么错误就搜教程，按照教程试奇奇怪怪的命令，运气好的话突然就成功了，但始终不知道自己干了些啥？
到现在配环境两个小时够够的（除非原环境是个屎）
温馨提示： 1、本篇文章需要读者有一定的基础（至少能分清anaconda与python,conda与pip，环境变量是什么意思的程度） 2、读本篇文章的时候多点耐心，本文倾向于给出在逻辑上先干什么再干什么最终达成目的，帮助读者去理解如何配pytorch 3、读懂本篇文章后足以全方位了解pytorch+cuda+cudnn到底怎么配。以后在安装过程中出现问题也可以自行快速解决 4、建议先迅速通读全文，对整体有个印象，然后再细细尝试每一个知识点 4、若是想要直接得到一套可行的命令行组合，请移步其他博客。 5、小白一点基础也没有没关系！读一遍不理解也记不住也没关系！建议收藏，多读几遍-其义自见。 一、配pytorch环境之前首先得知道cuda、cudnn、pytorch、torchvision、nvidia、nvidia图形加速驱动程序（nvidis 驱动程序）是啥？ pytorch有cpu版本的也有gpu版本的，cpu版本的通过conda或者pip安装就可以用。
炼丹玩家可以通过执行conda list查看自己安装的python库.第一步是能看懂pytorch的版本描述。
例如我安装的这个是 适合在python3.6、cuda10.0、cudnn7.5.1环境下运行的1.1.0版本。带着cuda说明的一定是GPU版本，因为cpu运行不需要cuda.玩家可以对应着自己的版本描述理解一下。
其次玩家也需要理解：版本并不是一一对应关系而是多对多关系，比如cuda10.0可以与几种不同的cudnn兼容、cudnn8.0也可以与几种不同的cuda兼容。CUDA和CUDA Driver显卡驱动不是一一对应的，比如同一台电脑上可同时安装CUDA 9.0、CUDA 9.2、CUDA 10.0等版本。在不同版本间切换我常常使用更改环境变量的方式。（有人可能喜欢创建动态链接的方式）这里看不懂没关系，继续往下读。
读到这里有玩家可能会问cuda、cudnn、NVIDIA。
的关系是啥？
nvidia是英伟达公司，我们用的GPU通常是他家生产的，主要产品有GTX系列。有了显卡（GPU别名）还得需要驱动程序，英文名交NVIDIA Accelerated Graphics Driver，在安装某些东西的时候会出现这个单词，建议记住。那电脑上是否有驱动程序呢？打开cmd-&gt;执行nvidia-smi (无空格)如果有反应则代表有GPU并且安装了驱动程序。
CUDA是显卡厂商NVIDIA推出的运算平台。CUDA是一种由NVIDIA推出的通用并行计算架构，是一种并行计算平台和编程模型，但我们通常说的安装CUDAx.x则是指CUDA Toolkit即cuda工具包。
关于CUDA Toolkit （cuda工具包）就有的注意了：上面说了在cuda官网上下载的runfile是cudatoolkit下载起来蛮麻烦，那我从conda上直接执行conda install cudatoolkit也能下载下来一个东西是不是也行？答案是不行：anaconda是python版本管理工具也可以说是包管理工具那么他下载的只是一个名字叫做cudatoolkit的第三方库，这个可以理解为从官网下载的子集。但是从NVIDIA CUDA官网上下载的CUDA Toolkit则是还包括cuda编译器（nvcc）等等组件,如果没这些，也是无法运用cuda加速的。
cuDNN是NVIDIA专门针对深度神经网络中的基础操作而设计基于GPU的加速库。cuDNN为深度神经网络中的标准流程提供了高度优化的实现方式，例如convolution、pooling、normalization以及activation layers的前向以及后向过程。CUDA这个平台一开始并没有安装cuDNN库，当开发者们需要用到深度学习GPU加速时才安装cuDNN库，工作速度相较CPU快很多。所以还得想要在深度学习模型训练上加速还得下载cudnn。
至于pytorch、torch、torchvision、torchaudio这四个名词的意思，可以简单理解下载pytorch的时候其实是下载三个python第三方库一个叫torch（官网下载链接名称）、一个叫torchvision、一个叫torchaudio。不过如果执行conda list查看下载的第三方库就可以发现库的真实名字叫pytorch与torchvision和torchaudio。看名字也知道torchvision主要处理图片，torchaudio是音频。（用什么下什么）
看到这里没理解没关系，可以接着往下读。
其实我们需要的其实就是一个pytorch GPU版本的python第三方库，但是这个第三方库依赖有点多。看着刚刚的图也应该知道，应该从下往上安装，先查看硬件、驱动再下载cuda、cudnn最后下载torch、torchvision。当然也有自己的硬件只支持一部分版本的cuda，cuda版本又限制了cudnn、torch、torchvision版本的原因。当然既然是python第三方库肯定与python的版本有对应关系。
#在安装环境之前，我的建议是先查看一下目前自己的环境 #打开cmd或者linux终端 nvcc -V #查看之前是否装过cuda 之前装过也不用卸载，因为不同版本之间可以通过修改环境变量更换。 python &gt;&gt;&gt; import torch &gt;&gt;&gt; torch.__version__ #查看目前安装的pytorch版本 &gt;&gt;&gt; torch.cuda.is_available() #查看是否可以使用cuda加速，只有有cuda且与pytorch兼容的情况才是True # 如果返回True说明兼容 二、cuda 安装步骤释疑 第一步：玩家的笔记本需要有 NVIDIA英伟达的GPU芯片：右击“此电脑（或：我的电脑）”--&gt;属性--&gt;设备管理器--&gt;显示适配器，会有显示如下代表我的显卡是GTX 1050 （显卡就是GPU）,用服务器的朋友可以直接看第二步（应该都有）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e785cbe4338c9ac621c6ea767a6713e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/141a0913a1bd13c55f33468dd79528e3/" rel="bookmark">
			vue2之浅谈template
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue2之浅谈template 什么是template以定义组件的两种方法之一的*定义根组件*为例我们先看没有template的情况接下来我们引入template，看看有template的情况 什么是template template的作用是渲染组件的内容，在vue中渲染组件的内容有两种方式，这是其一，另外一种是通过render函数的方式。另外一种我们之后讲。
先来看看官方文档的定义：
组件的模板结构(HTML)，模板内容会被vue进行渲染，生成最终的HTML内容，并替换占位(挂载)元素。
上案例:
以定义组件的两种方法之一的定义根组件为例 我们先看没有template的情况 &lt;div id="v-model-basic" class="demo"&gt; &lt;p&gt;Message is: {{ message }}&lt;/p&gt; &lt;/div&gt; var app =new Vue({ el:'#v-model-basic', data:{ message:"" } }) 先浅浅解读一下这个新建的vue实例对象内有两个很重要的参数：分别是el和data。el参数功能是将实例中的内容挂载到指定的el中，在这里指向id为v-model-basic的语句块；data参数内注册变量并保存变量数据，在这里初始化值为空的字符串
结果如上
接下来我们引入template，看看有template的情况 &lt;div id="v-model-basic" class="demo"&gt; &lt;p&gt;Message is: {{ message }}&lt;/p&gt; &lt;/div&gt; var app =new Vue({ el:'#v-model-basic', data:{ message:"" }, template:'&lt;p&gt; my-root Message is: {{ message }}&lt;/p&gt;' }) 我们在原有的代码的基础上，在创建根组件代码块内，添加template参数
结果如上,原来(挂载)元素上有原始的模板结构(HTML) 和 模板内容，但是在添加template参数之后，template参数内的模板结构(HTML) 和 模板内容被vue渲染后生成最终的HTML内容，将之替换
ps：由于template选项为string类型，使用的时候，一定不要漏‘’；此外，防止报错最好将其写在一行之内
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/613767109e8cb4189d7d1e3227981216/" rel="bookmark">
			Elasticsearch 入门到精通-IP 数据类型及其搜索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用 Elasticsearch 搜索 IP 地址时，我们可以把数据类型定义为 IP 数据类型。这样我们可以针对 IP 地址进行搜索。这种 IP 地址可以是 IPv4 或者是 IPv6 的形式。
现在假设我们导入一个如下的数据到 Elasticsearch 中：
PUT my-index/_doc/1 { "ip_addr": "192.168.1.1" } 在没有定义数据类型的情况下， Elasticsearch 会把上面的字段 ip_add 映射到一个 text 及 keyword 的类型的数据上：
GET my-index/_mapping 上面命令显示的结果为：
{ "my-index" : { "mappings" : { "properties" : { "ip_addr" : { "type" : "text", "fields" : { "keyword" : { "type" : "keyword", "ignore_above" : 256 } } } } } } } 假如我们想对上面的数据进行如下的搜索：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/613767109e8cb4189d7d1e3227981216/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d85e69f73747c9b61cf67033be3763df/" rel="bookmark">
			Android项目编译异常之AAPT: error
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题描述 新建个项目报了个错误：C:\Users\LingFeng.gradle\caches\transforms-2\files-2.1\51e7578a0d149e0aa4fac11646699afa\core-1.7.0\res\values\values.xml:105:5-114:25: AAPT: error: resource android:attr/lStar not found.
解决方案 把androidx的依赖注掉就好了
dependencies { implementation fileTree(dir: 'libs', include: ['*.jar']) implementation(name:'Alipay_IoTSDK', ext:'aar') implementation 'com.android.support:appcompat-v7:28.0.0' implementation 'com.android.support.constraint:constraint-layout:1.1.3' //implementation 'androidx.appcompat:appcompat:1.4.1' //implementation 'androidx.constraintlayout:constraintlayout:2.1.3' testImplementation 'junit:junit:4.12' //androidTestImplementation 'androidx.test.ext:junit:1.1.3' //androidTestImplementation 'androidx.test.espresso:espresso-core:3.4.0' implementation 'com.google.protobuf:protobuf-java:3.5.1' } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0264a042db5353c9d63ca3a859af649d/" rel="bookmark">
			MYSQL foreach使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.批量查询 select id from a where 1=1 and( &lt;foreach collection="list" item="cus" separator="or"&gt; name = #{cus} &lt;/foreach&gt; ) 2.批量新增 INSERT INTO a(id, name,remark) VALUES &lt;foreach collection="List" item="item" index="index" separator=","&gt; ( #{item.id,jdbcType=VARCHAR}, #{item.name,jdbcType=VARCHAR}, #{item.remark,jdbcType=VARCHAR} ) &lt;/foreach&gt; 3.批量修改 update a set id = '' where 1=1 and id in ( &lt;foreach collection="List" item="id" separator="or"&gt; #{id} &lt;/foreach&gt; ) 4.批量删除 delete a set id = '' where 1=1 and id in ( &lt;foreach collection="List" item="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0264a042db5353c9d63ca3a859af649d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d4f3f3a7bc1d31f79b48fe1d1b16e6a/" rel="bookmark">
			构造方法及其重载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.构造方法 类中有一种特殊的成员方法，其方法名与类名相同，称为构造方法。
通过构造方法可以完成对象的创建，以及实例变量的初始化。
下面是一个构造方法示例：
public class Puppy{
public Puppy( ) { }
public Puppy(String name) {
//这个构造器仅有一个name
}
} 每个类都有一个隐藏的无参构造函数。
public class Dog{ /** * 带参构造函数 * @param name * @param age */ public Dog(String name,int age){ this.age = age; this.name = name; } /** * 无惨构造函数 */ public Dog(){} String name; int age; public void ptint(){ System.out.println("name = "+this.name+";age = "+age); } public static void main(String[] args) { new Dog().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d4f3f3a7bc1d31f79b48fe1d1b16e6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f22548a4235e718330c95f2767235bf/" rel="bookmark">
			Java基础八股文（背诵版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java基础八股文（背诵版） Java 语言具有哪些特点？ Java 为纯面向对象的语言。它能够直接反应现实生活中的对象。具有平台无关性。Java 利用 Java 虚拟机运行字节码，无论是在 Windows、Linux 还是 MacOS 等其它平台对 Java 程序进行编译，编译后的程序可在其它平台运行。Java 为解释型语言，编译器把 Java 代码编译成平台无关的中间代码，然后在 JVM 上解释运行，具有很好的可移植性。Java 提供了很多内置类库。如对多线程支持，对网络通信支持，最重要的一点是提供了垃圾回收器。Java 具有较好的安全性和健壮性。Java 提供了异常处理和垃圾回收机制，去除了 C++中难以理解的指针特性。 JDK 与 JRE 有什么区别？ JDK：Java 开发工具包（Java Development Kit），提供了 Java 的开发环境和运行环境。JRE：Java 运行环境(Java Runtime Environment)，提供了 Java 运行所需的环境。JDK 包含了 JRE。如果只运行 Java 程序，安装 JRE 即可。要编写 Java 程序需安装 JDK. 简述 Java 基本数据类型 byte: 占用 1 个字节，取值范围-128 ~ 127short: 占用 2 个字节，取值范围-215 ~ 215-1int：占用 4 个字节，取值范围-231 ~ 231-1long：占用 8 个字节float：占用 4 个字节double：占用 8 个字节char: 占用 2 个字节boolean：占用大小根据实现虚拟机不同有所差异 简述自动装箱拆箱 对于 Java 基本数据类型，均对应一个包装类。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f22548a4235e718330c95f2767235bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08a30075872eda76af48ccb96d5b55a8/" rel="bookmark">
			Git学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Git rm -rf / 切勿在Linux中尝试！删除电脑中全部文件 Git 配置
查看配置 git config -l
Pandas@user MINGW64 /d/Course/01Git/gitcode $ git config -l diff.astextplain.textconv=astextplain filter.lfs.clean=git-lfs clean -- %f filter.lfs.smudge=git-lfs smudge -- %f filter.lfs.process=git-lfs filter-process filter.lfs.required=true http.sslbackend=openssl http.sslcainfo=D:/Software/Git/mingw64/ssl/certs/ca-bundle.crt core.autocrlf=true core.fscache=true core.symlinks=false core.usebuiltinfsmonitor=true pull.rebase=false credential.helper=manager-core credential.https://dev.azure.com.usehttppath=true init.defaultbranch=master user.name=Charles user.email=2427592909@qq.com credential.https://gitee.com.provider=generic 查看本地配置 git config --system --list
本地配置文件地址
D:\Software\Git\etc\gitconfig
Pandas@user MINGW64 /d/Course/01Git/gitcode $ git config --system --list diff.astextplain.textconv=astextplain filter.lfs.clean=git-lfs clean -- %f filter.lfs.smudge=git-lfs smudge -- %f filter.lfs.process=git-lfs filter-process filter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08a30075872eda76af48ccb96d5b55a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3a251a1de5c6b7345ba004fe8f6bf54/" rel="bookmark">
			VScode 在集群上远程开发环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VS code 下载 https://visual-studio-code.en.softonic.com/download
VS code 安装 安装后配置 点击扩展（如下图） 搜索 Remote Development 安装 Remote Development 安装成功后会出现这个
本地连接集群配置 点击上图红框中的图标，会出现如下界面
点图中 + 号，会出现如下输入ssh连接命令接口
按照如上格式输入所在集群的 账号@IP地址 -p 端口号
例如 ssh hhh@100.100.100.1 -p 1362
这里端口号 ssh默认的是22 但是有的集群上已经修改过了 大家根据实际情况选择输入
输入完成后回车出现如下界面
这里选择刚刚输入用户账号端口保存的位置，一般选择第一个，确认后就会出现保存的主机
点击
开始连接集群，会出现如下界面，要求输入密码，首次连接可能会出现让选择ssh连接集群的系统类型，一般选择Linux。
密码输入完成后等待连接成功。
左下角出现上图则表示连接成功。
打开用户目录，愉快的远程交互开发 点击 文件 打开文件夹
上图界面即为集群上用户对应的文件夹，点击确定，再次输入密码即可将文件目录导入到VC code，可以同步编辑，进行交互开发。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d390e0ee7e6bebc633f65d58915b1209/" rel="bookmark">
			Tensor 和 NumPy 相互转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Tensor 和 NumPy 相互转换 我们很容易用numpy()和from_numpy()将Tensor和NumPy中的数组相互转换。但是需要注意的一点是： 这两个函数所产生的Tensor和NumPy中的数组共享相同的内存（所以他们之间的转换很快），改变其中一个时另一个也会改变！
文章目录 Tensor 和 NumPy 相互转换1. Tensor 转 NumPy2. NumPy 数组转 Tensor3. torch.tensor() 将 NumPy 数组转换成 Tensor 1. Tensor 转 NumPy a = torch.ones(6) b = a.numpy() print(a, b) a += 1 print(a, b) b += 1 print(a, b) tensor([1., 1., 1., 1., 1., 1.]) [1. 1. 1. 1. 1. 1.] tensor([2., 2., 2., 2., 2., 2.]) [2. 2. 2. 2. 2. 2.] tensor([3., 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d390e0ee7e6bebc633f65d58915b1209/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/977d3e1e6fd79d31af1ce3fcf8b16884/" rel="bookmark">
			Python 深拷贝和浅拷贝详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、Python 深拷贝和浅拷贝概念理解2、浅拷贝2.1 使用数据类型本身的构造器2.2 对于列表2.3 使用 copy.copy() 函数2.4 对于元组2.5 关于切片操作符 ':'2.6 和赋值的区别2.7 浅拷贝需注意的问题 2、深拷贝 1、Python 深拷贝和浅拷贝概念理解 浅拷贝，指的是重新分配一块内存，创建一个新的对象，但里面的元素是原对象中各个子对象的引用。
深拷贝，是指重新分配一块内存，创建一个新的对象，并且将原对象中的元素，以递归的方式，通过创建新的子对象拷贝到新对象中。因此，新对象和原对象没有任何关联。
2、浅拷贝 使用数据类型本身的构造器对于可变的序列，还可以通过切片操作符 : 来完成浅拷贝Python 还提供了对应的函数 copy.copy() 函数，适用于任何数据类型 2.1 使用数据类型本身的构造器 list1 = [1, 2, 3] list2 = list(list1) print(list2) print("list1==list2 ?",list1==list2) print("list1 is list2 ?",list1 is list2) set1= set([1, 2, 3]) set2 = set(set1) print(set2) print("set1==set2 ?",set1==set2) print("set1 is set2 ?",set1 is set2) dict1 = {1:[1,'w'], 2:0, 3:98} dict2 = dict(dict1) print(dict2) print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/977d3e1e6fd79d31af1ce3fcf8b16884/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a57b6921d25245182004a215691c44b7/" rel="bookmark">
			导出手机缓存的B站视频或者在PC电脑端下载B站视频到本地
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、问题介绍2、将手机中缓存的 B 站视频导入电脑或者其他地方3、在 B 站官网下载喜欢的视频到PC电脑端本地 1、问题介绍 一般，我们是直接在手机 B 站在线看视频，或者缓存在手机中看，或者在网页看 B 站视频，但是有时候需要将手机缓存的 B 站视频导入电脑或者导出去其它地方，这个时候就需要通过办法实现。
2、将手机中缓存的 B 站视频导入电脑或者其他地方 其实就是要找到视频在手机的存储位置，根据位置的存储路径用数据线导入电脑就行。
这里可以自己设置 B 站缓存视频的存储位置，
一般，默认存储在手机的 “手机内存\Android\data\tv.danmaku.bili\download ” 。
参考 https://zhidao.baidu.com/question/936949985008648372.html?qbl=relate_question_6&amp;word=%CA%D6%BB%FA%CF%C2%D4%D8%B5%C4B%D5%BE%CA%D3%C6%B5%D4%F5%C3%B4%B4%AB%B5%BD%B5%E7%C4%D4%C9%CF 。
如果发现，默认存储在手机的是 audio.m4s 音频文件和 video.m4s 视频文件，则需要将两个合并。
把 B 站手机 APP 缓存的 m4s 文件转换成mp4格式，https://www.bilibili.com/read/cv14802750/ ，这是转换指南。
先在 http://www.121down.com/soft/softview-103719.html#downaddress 下载 ffmpeg ，再解压下载文件后，将 audio.m4s 音频文件和 video.m4s 视频文件放入 ./bin 文件夹下，打开 powershell ，输入关键指令：
.\ffmpeg.exe -i video.m4s -i audio.m4s -codec copy Output.mp4 3、在 B 站官网下载喜欢的视频到PC电脑端本地 （1） https://www.yinxiang.com/everhub/note/3c658854-a5bd-4554-b254-8ac5368d64f3
（2）https://jingyan.baidu.com/article/ab0b56309b48be805afa7dfb.html
（3）下载唧唧Down ，https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a57b6921d25245182004a215691c44b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/718b59cd1db19ee1eb8c1282f9802433/" rel="bookmark">
			自动提取当前文件夹中所有文件名或包含指定字符串的文件名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 自动提取当前文件夹中所有文件名或包含指定字符串的文件名。
解决方法 step1：显示当前文件夹中所有文件的扩展名，该步骤也可省略；
step2：在当前文件夹下建立一个.txt的文本文档，文件名称随意，如extract.txt；
step3：在extract.txt文档中输入dir *.*/b&gt;file.txt并保存；
注意：dir和*之间要有空格，file.txt名称随意；
step4：修改extract.txt文件扩展名，改成extract.bat；
step5：双击运行extract.bat文件，当前文件夹下将自动生成file.txt文件，里面是当前文件夹中所有文件的文件名，包括新建的extract.bat文件、自动生成的file.txt文件、以及子文件夹名。
通过以上步骤就能实现当前文件夹中所有文件名的自动提取；
若想提取当前文件夹下包含指定字符串的文件名，只需要把*.*中的.替换成指定的字符串即可，如dir *.lib*/b&gt;file.txt，不区分大小写。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12ce49bd652aaa5b1254f4236b0d4f99/" rel="bookmark">
			git pull 报错Your configuration specifies to merge with the XXX from the remote, but no such ref was..
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		翻译过来的大致意思是：
你的配置指定与ref 'XXX’合并 从远程，但没有这样的引用。
打开.git文件夹
打开config文件
[branch "master"] remote = origin merge = refs/heads/XXX 上诉XXX应该和 branch后面的分支名称保持一致。如果不一致就会报错，更改之后，git pull就成功了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3abea8241a9a80bd537cb75c16f00ed9/" rel="bookmark">
			SpringBoot 集成 websocket
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、环境二、代码方式一1、目录结构2、WebSocketConfiguration 配置3、DefaultHandler 消息处理类4、DefaultInterceptor 拦截器 方式二1、目录结构2、WebSocketConfiguration 配置3、TestWebSocket 消息处理类 结果 前言 SpringBoot 集成 websocket的两种方式，手把手教你写后端Websocket接口
一、环境 &lt;!-- websocket --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;/dependency&gt; 二、代码 方式一 1、目录结构 DefaultHandler 类似与Controller 用于定义IPA内的消息处理
DefaultInterceptor 拦截器用于对请求和响应做拦截，若无需求可以没有
WebSocketConfiguration 配置类
2、WebSocketConfiguration 配置 import org.springframework.context.annotation.Configuration; import org.springframework.web.socket.WebSocketHandler; import org.springframework.web.socket.config.annotation.EnableWebSocket; import org.springframework.web.socket.config.annotation.WebSocketConfigurer; import org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry; import org.springframework.web.socket.server.HandshakeInterceptor; import javax.annotation.Resource; /** * Date: 2022-04-28 星期四 * Time: 14:37 * Author: Dily_Su * Remark: */ @Configuration @EnableWebSocket public class WebSocketConfiguration implements WebSocketConfigurer { @Override public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) { registry.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3abea8241a9a80bd537cb75c16f00ed9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/593096aa5b1e131989295bac0a511fef/" rel="bookmark">
			【异常处理】Word2016 出现“此功能看似已中断 并需要修复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		刚刚安装并激活了office2016，
每次打开Word文档都会提示
“很抱歉，此功能看似已中断，并需要修复，请使用Windows 控制面板中的“程序和功能”选项修复Microsoft Office”。
亲测使用控制面板的办法无效，下面是网络上查到的解决办法
解决方法：
1. 按Windows 键+R键，输入“regedit”打开注册表。
2.找到以下键值：HKEY_CURRENT_USER\SOFTWARE\Microsoft\Office\16.0\Word\Options
在右侧新建DWORD值，取名为NoReReg，并输入数值为1 并确认，关闭注册表编辑器，重新打开Word 即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22d69315d177422ebb701c3427796d09/" rel="bookmark">
			MAPREDUCE详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. MAPREDUCE原理篇（1） Mapreduce是一个分布式运算程序的编程框架，是用户开发“基于hadoop的数据分析应用”的核心框架；
Mapreduce核心功能是将用户编写的业务逻辑代码和自带默认组件整合成一个完整的分布式运算程序，并发运行在一个hadoop集群上；
1.1 为什么要MAPREDUCE （1）海量数据在单机上处理因为硬件资源限制，无法胜任
（2）而一旦将单机版程序扩展到集群来分布式运行，将极大增加程序的复杂度和开发难度
（3）引入mapreduce框架后，开发人员可以将绝大部分工作集中在业务逻辑的开发上，而将分布式计算中的复杂性交由框架来处理
设想一个海量数据场景下的wordcount需求：
单机版：内存受限，磁盘受限，运算能力受限
分布式：
文件分布式存储（HDFS）运算逻辑需要至少分成2个阶段（一个阶段独立并发，一个阶段汇聚）运算程序如何分发程序如何分配运算任务（切片）两阶段的程序如何启动？如何协调？整个程序运行过程中的监控？容错？重试？ 可见在程序由单机版扩成分布式时，会引入大量的复杂工作。为了提高开发效率，可以将分布式程序中的公共功能封装成框架，让开发人员可以将精力集中于业务逻辑。
而mapreduce就是这样一个分布式程序的通用框架，其应对以上问题的整体结构如下：
MRAppMaster(mapreduce application master)MapTaskReduceTask 1.2 MAPREDUCE框架结构及核心运行机制 1.2.1 结构 一个完整的mapreduce程序在分布式运行时有三类实例进程：
1、MRAppMaster：负责整个程序的过程调度及状态协调
2、mapTask：负责map阶段的整个数据处理流程
3、ReduceTask：负责reduce阶段的整个数据处理流程
1.2.2 MR程序运行流程 1.2.2.1 流程示意图
1.2.2.2 流程解析
一个mr程序启动的时候，最先启动的是MRAppMaster，MRAppMaster启动后根据本次job的描述信息，计算出需要的maptask实例数量，然后向集群申请机器启动相应数量的maptask进程 maptask进程启动之后，根据给定的数据切片范围进行数据处理，主体流程为： 利用客户指定的inputformat来获取RecordReader读取数据，形成输入KV对将输入KV对传递给客户定义的map()方法，做逻辑运算，并将map()方法输出的KV对收集到缓存将缓存中的KV对按照K分区排序后不断溢写到磁盘文件 MRAppMaster监控到所有maptask进程任务完成之后，会根据客户指定的参数启动相应数量的reducetask进程，并告知reducetask进程要处理的数据范围（数据分区） Reducetask进程启动之后，根据MRAppMaster告知的待处理数据所在位置，从若干台maptask运行所在机器上获取到若干个maptask输出结果文件，并在本地进行重新归并排序，然后按照相同key的KV为一个组，调用客户定义的reduce()方法进行逻辑运算，并收集运算输出的结果KV，然后调用客户指定的outputformat将结果数据输出到外部存储 1.3 MapTask并行度决定机制 maptask的并行度决定map阶段的任务处理并发度，进而影响到整个job的处理速度
那么，mapTask并行实例是否越多越好呢？其并行度又是如何决定呢？
1.3.1 mapTask并行度的决定机制 一个job的map阶段并行度由客户端在提交job时决定
而客户端对map阶段并行度的规划的基本逻辑为：
将待处理数据执行逻辑切片（即按照一个特定切片大小，将待处理数据划分成逻辑上的多个split），然后每一个split分配一个mapTask并行实例处理
这段逻辑及形成的切片规划描述文件，由FileInputFormat实现类的getSplits()方法完成，其过程如下图：
1.3.2 FileInputFormat切片机制 1、切片定义在InputFormat类中的getSplit()方法
2、FileInputFormat中默认的切片机制：
简单地按照文件的内容长度进行切片切片大小，默认等于block大小切片时不考虑数据集整体，而是逐个针对每一个文件单独切片 比如待处理数据有两个文件：
file1.txt 320M
file2.txt 10M
经过FileInputFormat的切片机制运算后，形成的切片信息如下： file1.txt.split1-- 0~128
file1.txt.split2-- 128~256
file1.txt.split3-- 256~320
file2.txt.split1-- 0~10M
3、FileInputFormat中切片的大小的参数配置
通过分析源码，在FileInputFormat中，计算切片大小的逻辑：Math.max(minSize, Math.min(maxSize, blockSize)); 切片主要由这几个值来运算决定
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22d69315d177422ebb701c3427796d09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a3a97f7edcdf76b85411738c7cf320c/" rel="bookmark">
			数据仓库介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据仓库简介 什么是数据仓库 数据仓库，英文名称为Data Warehouse，可简写为DW或DWH。数据仓库，是为企业所有级别的决策制定过程，提供所有类型数据支持的战略集合。它出于分析性报告和决策支持目的而创建。 为需要业务智能的企业，提供指导业务流程改进、监视时间、成本、质量以及控制。
数据仓库的特点 1．数据仓库的数据是面向主题的
与传统数据库面向应用进行数据组织的特点相对应，数据仓库中的数据是面向主题进行组织的。什么是主题呢？首先，主题是一个抽象的概念，是较高层次上企业信息系统中的数据综合、归类并进行分析利用的抽象。在逻辑意义上，它是对应企业中某一宏观分析领域所涉及的分析对象。面向主题的数据组织方式，就是在较高层次上对分析对象的数据的一个完整、一致的描述，能完整、统一地刻划各个分析对象所涉及的企业的各项数据，以及数据之间的联系。所谓较高层次是相对面向应用的数据组织方式而言的，是指按照主题进行数据组织的方式具有更高的数据抽象级别。
2. 数据仓库的数据是集成的
数据仓库的数据是从原有的分散的数据库数据抽取来的。操作型数据与DSS分析型数据之间差别甚大。第一，数据仓库的每一个主题所对应的源数据在原有的各分散数据库中有许多重复和不一致的地方，且来源于不同的联机系统的数据都和不同的应用逻辑捆绑在一起；第二，数据仓库中的综合数据不能从原有的数据库系统直接得到。因此在数据进入数据仓库之前，必然要经过统一与综合，这一步是数据仓库建设中最关键、最复杂的一步，所要完成的工作有：
（1）要统一源数据中所有矛盾之处，如字段的同名异义、异名同义、单位不统一、字长不一致，等等。
（2）进行数据综合和计算。数据仓库中的数据综合工作可以在从原有数据库抽取 数据时生成，但许多是在数据仓库内部生成的，即进入数据仓库以后进行综合生成的。
3. 数据仓库的数据是不可更新的
数据仓库的数据主要供企业决策分析之用，所涉及的数据操作主要是数据查询，一般情况下并不进行修改操作。数据仓库的数据反映的是一段相当长的时间内历史数据的内容，是不同时点的数据库快照的集合，以及基于这些快照进行统计、综合和重组的导出数据，而不是联机处理的数据。数据库中进行联机处理的数据经过集成输入到数据仓库中，一旦数据仓库存放的数据已经超过数据仓库的数据存储期限，这些数据将从当前的数据仓库中删去。因为数据仓库只进行数据查询操作，所以数据仓库管理系统相比数据库管理系统而言要简单得多。数据库管理系统中许多技术难点，如完整性保护、并发控制等等，在数据仓库的管理中几乎可以省去。但是由于数据仓库的查询数据量往往很大，所以就对数据查询提出了更高的要求，它要求采用各种复杂的索引技术；同时由于数据仓库面向的是商业企业的高层管理者，他们会对数据查询的界面友好性和数据表示提出更高的要求。
4. 数据仓库的数据是随时间不断变化的
数据仓库中的数据不可更新是针对应用来说的，也就是说，数据仓库的用户进行分析处理时是不进行数据更新操作的。但并不是说，在从数据集成输入数据仓库开始到最终被删除的整个数据生存周期中，所有的数据仓库数据都是永远不变的。
数据仓库的数据是随时间的变化而不断变化的，这是数据仓库数据的第四个特征。这一特征表现在以下3方面：
（1）数据仓库随时间变化不断增加新的数据内容。数据仓库系统必须不断捕捉OLTP数据库中变化的数据，追加到数据仓库中去，也就是要不断地生成OLTP数据库的快照，经统一集成后增加到数据仓库中去；但对于确实不再变化的数据库快照，如果捕捉到新的变化数据，则只生成一个新的数据库快照增加进去，而不会对原有的数据库快照进行修改。
（2）数据仓库随时间变化不断删去旧的数据内容。数据仓库的数据也有存储期限，一旦超过了这一期限，过期数据就要被删除。只是数据仓库内的数据时限要远远长于操作型环境中的数据时限。在操作型环境中一般只保存有60~90天的数据，而在数据仓库中则需要保存较长时限的数据（如5~10年），以适应DSS进行趋势分析的要求。
（3）数据仓库中包含有大量的综合数据，这些综合数据中很多跟时间有关，如数据经常按照时间段进行综合，或隔一定的时间片进行抽样等等。这些数据要随着时间的变化不断地进行重新综合。因此，数据仓库的数据特征都包含时间项，以标明数据的历史时期。
数据仓库发展历程 数据仓库的发展大致经历了这样的三个过程：
简单报表阶段：这个阶段，系统的主要目标是解决一些日常的工作中业务人员需要的报表，以及生成一些简单的能够帮助领导进行决策所需要的汇总数据。这个阶段的大部分表现形式为数据库和前端报表工具。数据集市阶段：这个阶段，主要是根据某个业务部门的需要，进行一定的数据的采集，整理，按照业务人员的需要，进行多维报表的展现，能够提供对特定业务指导的数据，并且能够提供特定的领导决策数据。数据仓库阶段：这个阶段，主要是按照一定的数据模型，对整个企业的数据进行采集，整理，并且能够按照各个业务部门的需要，提供跨部门的，完全一致的业务报表数据，能够通过数据仓库生成对对业务具有指导性的数据，同时，为领导决策提供全面的数据支持。 通过数据仓库建设的发展阶段，我们能够看出，数据仓库的建设和数据集市的建设的重要区别就在于数据模型的支持。因此，数据模型的建设，对于我们数据仓库的建设，有着决定性的意义。
数据库与数据仓库的区别 了解数据库与数据仓库的区别之前，首先掌握三个概念。数据库软件、数据库、数据仓库。
数据库软件：是一种软件，可以看得见，可以操作。用来实现数据库逻辑功能。属于物理层。
数据库：是一种逻辑概念，用来存放数据的仓库。通过数据库软件来实现。数据库由很多表组成，表是二维的，一张表里可以有很多字段。字段一字排开，对应的数据就一行一行写入表中。数据库的表，在于能够用二维表现多维关系。目前市面上流行的数据库都是二维数据库。如：Oracle、DB2、MySQL、Sybase、MS SQL Server等。
数据仓库：是数据库概念的升级。从逻辑上理解，数据库和数据仓库没有区别，都是通过数据库软件实现的存放数据的地方，只不过从数据量来说，数据仓库要比数据库更庞大得多。数据仓库主要用于数据挖掘和数据分析，辅助领导做决策。
在IT的架构体系中，数据库是必须存在的。必须要有地方存放数据。比如现在的网购，淘宝，京东等等。物品的存货数量，货品的价格，用户的账户余额之类的。这些数据都是存放在后台数据库中。或者最简单理解，我们现在微博，QQ等账户的用户名和密码。在后台数据库必然有一张user表，字段起码有两个，即用户名和密码，然后我们的数据就一行一行的存在表上面。当我们登录的时候，我们填写了用户名和密码，这些数据就会被传回到后台去，去跟表上面的数据匹配，匹配成功了，你就能登录了。匹配不成功就会报错说密码错误或者没有此用户名等。这个就是数据库，数据库在生产环境就是用来干活的。凡是跟业务应用挂钩的，我们都使用数据库。
数据仓库则是BI下的其中一种技术。由于数据库是跟业务应用挂钩的，所以一个数据库不可能装下一家公司的所有数据。数据库的表设计往往是针对某一个应用进行设计的。比如刚才那个登录的功能，这张user表上就只有这两个字段，没有别的字段了。但是这张表符合应用，没有问题。但是这张表不符合分析。比如我想知道在哪个时间段，用户登录的量最多？哪个用户一年购物最多？诸如此类的指标。那就要重新设计数据库的表结构了。对于数据分析和数据挖掘，我们引入数据仓库概念。数据仓库的表结构是依照分析需求，分析维度，分析指标进行设计的。
数据库与数据仓库的区别实际讲的是OLTP与OLAP的区别。
操作型处理，叫联机事务处理OLTP（On-Line Transaction Processing，），也可以称面向交易的处理系统，它是针对具体业务在数据库联机的日常操作，通常对少数记录进行查询、修改。用户较为关心操作的响应时间、数据的安全性、完整性和并发支持的用户数等问题。传统的数据库系统作为数据管理的主要手段，主要用于操作型处理。
分析型处理，叫联机分析处理OLAP（On-Line Analytical Processing）一般针对某些主题的历史数据进行分析，支持管理决策。
数据仓库架构分层 数据仓库标准上可以分为四层：ODS（临时存储层）、PDW（数据仓库层）、DM（数据集市层）、APP（应用层）。
ODS层：
为临时存储层，是接口数据的临时存储区域，为后一步的数据处理做准备。一般来说ODS层的数据和源系统的数据是同构的，主要目的是简化后续数据加工处理的工作。从数据粒度上来说ODS层的数据粒度是最细的。ODS层的表通常包括两类，一个用于存储当前需要加载的数据，一个用于存储处理完后的历史数据。历史数据一般保存3-6个月后需要清除，以节省空间。但不同的项目要区别对待，如果源系统的数据量不大，可以保留更长的时间，甚至全量保存；
PDW层：
为数据仓库层，PDW层的数据应该是一致的、准确的、干净的数据，即对源系统数据进行了清洗（去除了杂质）后的数据。这一层的数据一般是遵循数据库第三范式的，其数据粒度通常和ODS的粒度相同。在PDW层会保存BI系统中所有的历史数据，例如保存10年的数据。
DM层：
为数据集市层，这层数据是面向主题来组织数据的，通常是星形或雪花结构的数据。从数据粒度来说，这层的数据是轻度汇总级的数据，已经不存在明细数据了。从数据的时间跨度来说，通常是PDW层的一部分，主要的目的是为了满足用户分析的需求，而从分析的角度来说，用户通常只需要分析近几年（如近三年的数据）的即可。从数据的广度来说，仍然覆盖了所有业务数据。
APP层：
为应用层，这层数据是完全为了满足具体的分析需求而构建的数据，也是星形或雪花结构的数据。从数据粒度来说是高度汇总的数据。从数据的广度来说，则并不一定会覆盖所有业务数据，而是DM层数据的一个真子集，从某种意义上来说是DM层数据的一个重复。从极端情况来说，可以为每一张报表在APP层构建一个模型来支持，达到以空间换时间的目的数据仓库的标准分层只是一个建议性质的标准，实际实施时需要根据实际情况确定数据仓库的分层，不同类型的数据也可能采取不同的分层方法。
为什么要对数据仓库分层：
1用空间换时间，通过大量的预处理来提升应用系统的用户体验（效率），因此数据仓库会存在大量冗余的数据；
2如果不分层的话，如果源业务系统的业务规则发生变化将会影响整个数据清洗过程，工作量巨大
3通过数据分层管理可以简化数据清洗的过程，因为把原来一步的工作分到了多个步骤去完成，相当于把一个复杂的工作拆成了多个简单的工作，把一个大的黑盒变成了一个白盒，每一层的处理逻辑都相对简单和容易理解，这样我们比较容易保证每一个步骤的正确性，当数据发生错误的时候，往往我们只需要局部调整某个步骤即可。
元数据介绍 当需要了解某地企业及其提供的服务时，电话黄页的重要性就体现出来了。元数据（Metadata）类似于这样的电话黄页。
1．元数据的定义
数据仓库的元数据是关于数据仓库中数据的数据。它的作用类似于数据库管理系统的数据字典，保存了逻辑数据结构、文件、地址和索引等信息。广义上讲，在数据仓库中，元数据描述了数据仓库内数据的结构和建立方法的数据。
元数据是数据仓库管理系统的重要组成部分，元数据管理器是企业级数据仓库中的关键组件，贯穿数据仓库构建的整个过程，直接影响着数据仓库的构建、使用和维护。
（1）构建数据仓库的主要步骤之一是ETL。这时元数据将发挥重要的作用，它定义了源数据系统到数据仓库的映射、数据转换的规则、数据仓库的逻辑结构、数据更新的规则、数据导入历史记录以及装载周期等相关内容。数据抽取和转换的专家以及数据仓库管理员正是通过元数据高效地构建数据仓库。
（2）用户在使用数据仓库时，通过元数据访问数据，明确数据项的含义以及定制报表。
（3）数据仓库的规模及其复杂性离不开正确的元数据管理，包括增加或移除外部数据源，改变数据清洗方法，控制出错的查询以及安排备份等。
元数据可分为技术元数据和业务元数据。技术元数据为开发和管理数据仓库的IT 人员使用，它描述了与数据仓库开发、管理和维护相关的数据，包括数据源信息、数据转换描述、数据仓库模型、数据清洗与更新规则、数据映射和访问权限等。而业务元数据为管理层和业务分析人员服务，从业务角度描述数据，包括商务术语、数据仓库中有什么数据、数据的位置和数据的可用性等，帮助业务人员更好地理解数据仓库中哪些数据是可用的以及如何使用。
由上可见，元数据不仅定义了数据仓库中数据的模式、来源、抽取和转换规则等，而且是整个数据仓库系统运行的基础，元数据把数据仓库系统中各个松散的组件联系起来，组成了一个有机的整体，如图3.5 所示
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a3a97f7edcdf76b85411738c7cf320c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9449a6010b5e59efecf37f3401e20404/" rel="bookmark">
			存储过程解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用存储过程来解决涨工资 涨工资，总裁涨1000，经理涨800，其他人涨400。 伪代码：
ResultSet rs = “select empno,job from emp”;
While(rs.next()){
Int eno = rs.getInt(“empno”);
String job = rs.getString(“job”);
If(“PRESIDENT”.equals(job))
{
update emp set sal = sal+1000;
}else if(“Manager”.equals(job))
{
update emp set sal = sal+800;
}else
{
update emp set sal = sal+400;
}
}
分析：那么上面这样的一个过程，使用存储过程(PL/SQL)就可以轻松解决。可以写很少的java代码。
①.查询emp表：7839的姓名和薪水并打印.
declare
pename emp.ename%type;
psal emp.sal%type;
begin
--得到7839的姓名和薪水
select ename,sal into pename,psal from emp where empno = 7839;
dbms_output.put_line(pename||'的薪水是'||psal);
end;
运行结果：KING的薪水是5000
②.使用记录型变量
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9449a6010b5e59efecf37f3401e20404/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7529da3c84f156ce81a5f9847d496869/" rel="bookmark">
			vue--vue&#43;ElementUI实现动态树&#43;数据表格&#43;分页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前提在上一篇博客之后，继续来写
实现动态树 数据表结构： 实现无限极分类 父类的pid是子类的id
后端代码： /** * 根据父类id查询子类pid的数据（递归） * @param pid * @param mod */ public void queryModuleByPid(Integer pid,Module mod){ String sql="select id,pid,text,icon,url,sort from t_module_vue where" + " pid="+pid; List&lt;Module&gt; lst=super.executeQuery(sql, null, new CallBack&lt;Module&gt;() { @Override public List&lt;Module&gt; forEach(ResultSet rs) throws SQLException { List&lt;Module&gt; lst=new ArrayList&lt;Module&gt;(); Module node=null; while(rs.next()) { node=new Module(); int id=rs.getInt("id"); node.setId(id); node.setPid(rs.getInt("pid")); node.setText(rs.getString("text")); node.setIcon(rs.getString("icon")); node.setUrl(rs.getString("url")); lst.add(node); //此注释代表实现无限极分类,在此只实现了两级 //queryModuleByPid(id, root); } return lst; } }); mod.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7529da3c84f156ce81a5f9847d496869/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/295a0cf466e38c21ff98ffd992282466/" rel="bookmark">
			weblogic反序列化之T3协议(CVE-2015-4582)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于T3协议的weblogic反序列化漏洞 之前说过在weblogic里面其实反序列化漏洞利用中大致分为两种，一个是基于T3协议的反序列化漏洞，一个是基于XML的反序列化漏洞，这篇来分析一下基于T3协议的weblogic，列出几个基于T3协议具有代表性的CVE： CVE-2015-4582、CVE-2016-0638、CVE-2016-3510、CVE-2018-2628、CVE-2020-2555、CVE-2020-2883，每个cve的思路大致都是基于上几个漏洞的补丁进行的一个绕过，本来想逐个分析，这里先跳过吧。
T3协议 简介 RMI通信时会将数据进行序列化后进行传输，同样的接收数据后反序列化进行接收，正常RMI通信使用的是JRMP协议，而在Weblogic的RMI通信中使用的是T3协议。T3协议是Weblogic独有的一个协议，相比于JRMP协议多了如下的一些特性
服务端可以持续追踪监控客户端是否存活（心跳机制），通常心跳的间隔为60秒，服务端在超过240秒未收到心跳即判定与客户端的连接丢失。 通过建立一次连接可以将全部数据包传输完成，优化了数据包大小和网络消耗。 结构 主要包含请求包头和请求主体这两部分内容，总共分为七个部分，第一部分是协议头，也就是请求包头，后面2-7都是请求主体，贴一张充满故事的结构图
请求包头 T3 协议在传输请求体之前都会先发送一个请求包到目标服务器，这个数据包的内容固定为
t3 12.2.1 AS:255 HL:19 MS:10000000 PU:t3://us-l-breens:7001 我们使用python手动发包
import socket def T3Test(ip,port): sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sock.connect((ip, port)) handshake = "t3 12.2.3\nAS:255\nHL:19\nMS:10000000\n\n" #请求包的头 sock.sendall(handshake.encode()) while True: data = sock.recv(1024) print(data.decode()) if __name__ == "__main__": ip = "192.168.__.__" port = 7001 T3Test(ip,port) 查看它的返回信息，包含了一些版本信息
使用Wireshark对它进行抓包，weblogic我是搭建在服务器上，所以ip就不露了，设置好过滤器后run上面的代码发包，在wireshark数据处右键 - 追踪流 - tcp流
同样在HELO后面会返回一个版本号，这就是发这个请求包头的作用
请求主体 上面说过了，请求主体就是2-7的部分，这里我们可以发现都是ac ed 00 05开头，说明该串内容是序列化的数据。而如果需要去构造payload的话，需要在后面序列化的内容中，进行一个替换。将原本存在的序列化内容替换成我们payload的序列化内容，在传输完成后，进行反序列化达成攻击的目的，这里还借用师傅的图
这里两种攻击思路
第一种生成方式为，将weblogic发送的JAVA序列化数据的第二到七部分的JAVA序列化数据的任意一个替换为恶意的序列化数据。 第二种生成方式为，将weblogic发送的JAVA序列化数据的第一部分与恶意的序列化数据进行拼接。 环境搭建 这里就不多说了，上次搭建专门写了weblogic反序列化介绍及环境搭建，放两个工具
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/295a0cf466e38c21ff98ffd992282466/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc9c8212b6aa76ad6a1d83533fee0aab/" rel="bookmark">
			Vue知识点：==与===的异同点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		==与===的区别 =====相同点两者均是用于比较判断相等情况，返回boolean值不同点用于比较或判断两者是否相等，比较时可以自动转换数据类型用于较为严格的比较，除判断数据是否相等外，还会判断两者的数据类型是否相同，且不会进行自动类型转换 &lt;template&gt; &lt;div&gt; 1==='1' {{1==='1'}} &lt;br/&gt; 1=='1' {{1=='1'}} &lt;/div&gt; &lt;/template&gt; 代码输出结果为：
!=与!==的区别 !=!==相同点与==、===相对的是!=、!==，两者也是用于比较判断，比较不相等的情况，返回boolean值不同点用于比较或判断两者是否不相等，比较时可以自动转换数据类型用于较为严格的比较，除判断数据是否不相等外，还会判断两者的数据类型是否相同，且不会进行自动类型转换 if(!value) 当value 值为undefined、null、0、""、false时，转换成boolean，其值为false
! 取反运算符
value为false，!value为true；value为true，!value为false。
代码示例：
&lt;script&gt; export default { name: "index", data() { return{ testVal:null } }, created(){ this.test() }, methods: { test(){ if(!this.testVal){ console.log('this.testVal='+this.testVal,'!this.testVal='+!this.testVal) } } } } &lt;/script&gt; 日志结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5ec08f87c39a30a435272a870ebfb74/" rel="bookmark">
			Chrome &amp; Firefox 浏览器在 Windows 10 浏览页面时经常崩溃的 Bug？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Chrome &amp; Firefox 浏览器在 Windows 10 21H2 LTSC 19044.1682 浏览页面时经常崩溃的 Bug？
解决方法：添加 --no-sandbox，能略微缓解一点，但无法从根本上解决其崩溃的严重 BUG。据说可能与Windows10最新预览版中改进其内存管理机制有关，也可能与其强行绑定的杀软有关... 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78bdde7e7dd90cd90cdb602f36b7dba1/" rel="bookmark">
			[数据分析]-音频分析-BirdCLE-1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		wechat号：浩波的笔记
数据背景 作为“世界灭绝之都”，夏威夷已经失去了68%的鸟类物种，其后果可能会损害整个食物链。研究人员利用种群监测来了解本地鸟类对环境变化和保护措施的反应。但岛上的许多鸟类都被隔离在难以接近的高海拔栖息地。由于身体监测困难，科学家们转向了声音记录。这种被称为生物声学监测的方法可以为研究濒危鸟类种群提供一种被动的、低成本的、经济的策略。
目前处理大型生物声学数据集的方法涉及对每个记录的手工注释。这需要专门的训练和大量的时间。因此使用机器学习技能，通过声音来识别鸟类的种类，可以节约大量成本。具体来说，开发一个模型，可以处理连续的音频数据，然后从声音上识别物种。最好的条目将能够用有限的训练数据训练可靠的分类器。
数据介绍 数据集来源：https://www.kaggle.com/competitions/birdclef-2022/data
下载方式：https://github.com/Kaggle/kaggle-api
kaggle competitions download -c birdclef-2022
train_metadata.csv:为训练数据提供了广泛的元数据
primary_label -鸟类的编码。可以通过将代码附加到https://ebird.org/species/来查看有关鸟类代码的详细信息，例如美国乌鸦的代码添加到https://ebird.org/species/amecrosecondary_labels: 记录员标注的背景物种，空列表并不意味着没有背景鸟的声音。author - 提供录音的eBird用户Filename:关联音频文件。rating: 浮动值在0.0到5.0之间，作为Xeno-canto的质量等级和背景物种数量的指标，其中5.0是最高的，1.0是最低的。0.0表示此记录还没有用户评级。 train_audio:大量的训练数据由xenocanto.org的用户慷慨上传的单个鸟类叫声的短录音组成。这些文件已被下采样到32khz，适用于匹配测试集的音频，并转换为ogg格式。
test_soundscapes:当您提交一个笔记本时，test_soundscapes目录将填充大约5500段录音，用于评分。每一个都是1分钟几毫秒的ogg音频格式，并只有一个音景可供下载。
test.csv：测试数据
row_id：行的唯一标识符。file_id：音频文件的唯一标识符。bird ：一行的ebird代码。每个音频文件每5秒窗口有一排为每个得分物种。end_time：5秒时间窗口(5、10、15等)的最后一秒。 数据分析 #相关库安装 import pkg_resources def placeholder(x): raise pkg_resources.DistributionNotFound pkg_resources.get_distribution = placeholder !pip uninstall fastai fastcore torchaudio -y #!pip install torch==1.8.1 torchaudio==0.8.1 fastcore==1.3.20 !pip install torch==1.9.0 torchaudio==0.9.0 !pip install fastaudio try: import pycaret except: !pip install pycaret-nightly 文章从以下几个方面展开
了解每个数据集，使用简单模型检查哪些特征是重要特征。了解音频数据转换音频数据并设计数据加载器来处理它们设计一个模型并通过引入各种方法来训练它以提高性能 import os import librosa from tqdm import tqdm import pandas as pd from fastaudio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78bdde7e7dd90cd90cdb602f36b7dba1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4b7e826bfe437ab64ec78bda93eddd5/" rel="bookmark">
			IPv6 SLAAC原理详解及配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天给大家介绍一下IPv6的一大特性——SLAAC。本文从SLAAC的原理出发，详细介绍了SLAAC的原理及RS和RA包的内容，最后通过简单的实验进行了SLAAC的配置。
阅读本文，您需要对IPv6相关基础知识有一定了解，如果对此还需要学习，欢迎关注我的博客，在我之前的文章里有关于IPv6的详细介绍。相关链接如下：IPv6报文格式讲解及其科学性探究、IPv6地址简介、IPv6各地址计算方式汇总、IPv6地址解析详解、IPv6邻居状态与邻居检测机制。
一、SLAAC简介
所谓LSAAC，即Stateless Address Autoconfiguration，无状态地址自动配置。SLAAC技术是自动获取IP地址的技术，在IPv6中，除了配置使用HDCP外，还支持使用SLAAC技术获取IPv6地址，以达到设备即插即用的效果。
SLAAC的实现依托于NDP协议中的RS报文和RA报文。在IPv6的NDP协议中，共有五种报文，而RS报文，即Router Solicitation，路由器请求报文，RA报文，即Router Advertisement，路由器公告报文。
IPv6可以设置一个网络设备上线后，先发送RS报文，在其上层路由器上可以配置定时发送RA报文。在一个网络设备收到RA报文后，就可以得到该链路上的IPv6地址前缀，之后，该网络设备就会根据IPv6地址范围和EUI64规则计算出一个IPv6地址给自己使用。因此，利用RS和RA报文，一个IPv6的网络设备就可以实现无状态IP地址配置了。
二、RA和RS报文详解
（一）RS报文
RS报文主要用来请求链路上相连的路由器发送RA报文。对于RS的发送方而言，此时必须先要有一个链路本地地址，RS报文的源IP地址就是该链路上的LLA地址，而目的地址是一个组播地址：ff02::1。由于所有的IPv6路由器都会监听这个组播地址，因此收到RA报文的路由器会向其通告RA报文。
Wireshark抓取RS报文如下：
（二）RA报文
对路由器而言，RA报文的源IP地址也是自己的本地链路地址，而目的地址也是ff02::1。
Wireshark抓取RA报文如下：
RA报文除了携带本地网段信息外，还将携带两个重要的参数，就是在上图中标红的参数。路由器可以设置自己的接口IP地址作为其他网络设备的网关。Router LifeTime参数就是将自己作为网关的生存时间，而Flags就是将自己作为网关的优先级。通过合适的修改这两个参数，可以实现类似于IPv6 VRRP的功能。
下面，我将通过一个实验，介绍一下IPv6 SLAAC的配置
三、SLAAC实验拓扑
实验拓扑如下所示：
现在要求在R1、R2和R3之间运行SLAAC，当R1上线后，R2和R3向R1发定期通告RA报文，使得R1能够自动获取IPv6地址。并且设置类似VRRP的功能，将R3作为R1的主网关，当R3宕机后，自动将网关切换到R2。
四、SLAAC配置命令
（一）IPv6配置相关命令
要使得路由器开启IPv6，则必须首先在全局模式开启IPv6，然后再接口模式下使能IPv6。命令如下：
ipv6
interface GigabitEthernet0/0/0
ipv6 enable
1
2
3
（二）R3上RA相关配置
interface GigabitEthernet0/0/0
ipv6 enable ipv6 address 3000::FFFF/64 ipv6 nd ra Max-interval 4 ipv6 nd ra router-lifetime 10 ipv6 nd ra preference high undo ipv6 nd ra halt
1
2
3
4
5
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4b7e826bfe437ab64ec78bda93eddd5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbfa4f9a02ab3a269fe5cc319e3fac25/" rel="bookmark">
			缓存使用的几种方式以及优缺点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址 mp.weixin.qq.com
本文翻译自英文，原文标题是 Cacheing Strategies and How to Choose the Right One，同事推荐看的，觉得总结的不错，鉴于很多同学都懒得看英文的，所以皮皮就用蹩脚的水平试着翻译一波，如何觉得还凑合，记得点个 “在看”，-。
缓存是提高系统性能的最简单方法之一。相对而言，数据库（or NoSQL 数据库）的速度比较慢，而速度却往往又是制胜的关键。
如果使用得当，缓存可以减少相应时间、减少数据库负载以及节省成本。本文罗列了几种缓存策略，选择正确的一种会有很大的不同。缓存策略取决于数据和数据访问模式。换句话说，数据是如何写和读的。例如:
系统是写多读少的吗？(例如基于时间的日志)
数据是否是只写入一次并被读取多次?(例如用户配置文件)
返回的数据总是惟一的吗?(例如搜索查询)
选择正确的缓存策略是提高性能的关键。让我们快速了解一下各种缓存策略。
第一种：Cache-Aside 这可能是最常用的缓存方法。缓存位于一边，应用程序直接与缓存和数据库对话。
简要解释一下:
应用程序首先检查缓存。
如果在缓存中找到，表示已经命中缓存。数据被读取并返回给应用程序。
如果在缓存中没有找到，则未命中缓存。应用程序必须做一些额外的工作，它需要查询数据库来读取数据，将数据返回给客户端，然后还要将数据存储在缓存中，这样对相同数据的后续读取可以命中缓存。
Cache-aside 策略特别适合读多的应用场景。使用 Cache-aside 的系统对缓存失效具有一定的弹性。如果缓存集群宕机，系统仍然可以通过直接访问数据库进行操作。(不过，如果缓存在峰值负载期间下降，这也没有多大帮助。响应时间可能会变得很糟糕，最糟糕的情况是，数据库可能会停止工作。)
另一个优点在于缓存中的数据模型可以与数据库中的数据模型不同。例如，多个查询产生的响应可以存储在某个请求 id 上。
当使用 cache-aside 时，最常见的写策略是直接将数据写到数据库中。当这种情况发生时，缓存可能与数据库不一致。为了解决这个问题，开发人员通常会引入 TTL，并继续提供陈旧的数据，直到 TTL 过期。如果必须保证数据的新鲜度，开发人员要么使缓存条目无效，要么使用适当的写策略，我们将在后面讨论。
第二种：Read-Though Cache Read-though 策略下的缓存与数据库保持一致。当缓存丢失时，它从数据库加载相应的数据，填充缓存并将其返回给应用程序（参考下图）。
cache-aside 和 read-through 策略都是延迟加载数据的，也就是说，只在第一次读取数据时才加载数据。
虽然 read-through 和 cache-aside 非常相似，但至少有两个关键区别:
在 cache-aside 中，应用程序负责从数据库中获取数据并填充缓存。在 read-through 中，此逻辑通常由库或独立缓存提供程序支持。
与 cache-aside 不同，read-through cache 中的数据模型不能与数据库中的数据模型不同。
当多次请求相同的数据时，read-through 缓存最适合于读量较大的工作负载。例如，一个新闻故事。缺点是，当第一次请求数据时，它总是导致缓存丢失，并导致额外的数据加载到缓存的代价。开发人员通过手动发出查询来 “预热” 或“预热”缓存来处理这个问题。就像 cache-aside 一样，数据也可能在缓存和数据库之间变得不一致，而解决方案就在写策略中，我们将在接下来看到这一点。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbfa4f9a02ab3a269fe5cc319e3fac25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f65ca782cbe5258156d89a26c44b7c9/" rel="bookmark">
			高性能 Go 语言发行版优化与落地实践 （Go 内存管理及优化、编译器优化）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文是记录2022年5月字节跳动青训营的课程笔记！！！ 本文内容：
优化：
内存管理优化
编译器优化
背景：
自动内存管理和Go内存管理机制
编译器优化的基本问题和思路
实践：
字节跳动遇到的性能问题和优化方案
性能优化： 性能优化是什么：
提升软件能力，减少不必要的消耗，充分发掘计算机的能力
为什么要做性能优化：
用户体验：带来用户体验的提升
资源高效利用：降低成本、提高效率
1.自动内存管理 1.1背景及概念 动态内存：
程序在运行时根据需求动态分配的内存
自动内存管理：
由程序语言的运行时系统管理动态内存
优点：
避免手动内存管理，专注于实现业务逻辑
保证内存使用的正确性和安全性
三个任务：
为新对象分配空间
找到存活对象
回收死亡对象的内存空间
Mutator：业务线程，分配新对象，修改对象的指向关系
Collector：GC线程，找到存活对象，回收死亡对象的内存空间
Serial GC:只有一个GC
ParallelGC：支持多个collectors同时回收GC的算法
Concurrent GC：mutator和collector可以同时执行 注：Collectors必须感知对象指向关系的改变
评价GC算法：
安全性：不能回收存活对象 基本要求
吞吐率：1-GC时间/程序运行总时间 花在GC上的时间
暂停时间：STW 业务是否感知
内存开销：GC元数据开销
1.2追踪垃圾回收 对象被回收的条件：指针指向关系不可达的对象
标记根对象（静态变量、全局变量、常量、线程栈等）
标记：可达对象
求指针指向关系的传递闭包：从根对象出发，找到所有可达对象
清理：所有不可达对象
将存活对象复制到另外的内存空间（Copying GC）
将死亡对象的内存标记为“可分配”（Mark-sweep GC）
移动并整理存活对象（Mark-compact GC）
根据对象的生命周期，使用不同的标记和清理策略
分代GC 跟Java JVM 类似
Java 虚拟机（JVM）学习笔记_芙蓉铁蛋的博客-CSDN博客
对年轻和老年代的对象，制定不同的GC策略，降低整体内存管理开销
不同年龄的对象处于heap的不同区域
年轻代：常规的对象分配，由于存活对象很少可以采用copying collection GC吞吐率高
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f65ca782cbe5258156d89a26c44b7c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8bee8f7bb04e3ad9cec34b40a196bee/" rel="bookmark">
			（三）k8s资源清单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、k8s中的资源 K8s中所有的内容都抽象为资源,资源实例化之后,叫做对象,那么这些资源不能在同一空间下重名
名称空间级别（namespace）
工作负载型资源( workload):Pod、 ReplicaSet、 Deployment、 StatefulSet、 DaemonSet、Job、CronJob( ReplicationController在v1.11版本被废弃)服务发现及负载均衡型资源( ServiceDiscovery LoadBalance): Service、 Ingress配置与存储型资源: Volume(存储卷)、CSI(容器存储接口,可以扩展各种各样的第三方存储卷)特殊类型的存储卷: ConfigMap(当配置中心来使用的资源类型)、 Secret(保存敏感数据) DownwardAPI(把外部环境中的信息输出给容器) 集群级资源:
Namespace、node、 Role ClusterRole、 RoleBinding、 ClusterRoleBinding元数据型资源: HPA、 PodTemplate、 LimitRange 二、资源清单 在k8s中，一般使用yam格式的文件来创建符合我们预期期望的pod，这样的yaml文件我们一般
称为资源清单。
2.1、资源清单yaml 语法 三、字段解释 3.1、必须存在的属性 参数名字段说明类型versionString这里是指的是K8SAPl的版本,目前基本上是v1,可以用 kubectl api versions命令查询kindString这里指的是yam文件定义的资源类型和角色,比如:odmetadataObject元数据对象,下面是它的属性metadata. nameString元数据对象的名字,这里由我们编写,比如命名pod的名字metadata. namespaceString元数据对象的命名空间,由我们自身定义SpecObject详细定义对象,下面是它的属性spec.containers[]list这里是Spec对象的容器列表定义,是个列表spec. containers.nameString这里定义容器的名字spec.containers.imageString这里定义要用到的镜像名称 3.2、主要属性 参数名字段说明类型spec. containers.nameString这里定义容器的名字spec.containers.imageString这里定义要用到的镜像名称spec.containers[]. imagePullPolicyString定义镜像拉取策略,有 Always、 Never 、IfNotPresent三个值可选(1) Always:意思是每次都尝试重新拉取镜像；(2) Never:表示仅使用本地镜像 ；(3)、IfNotPresent:如果本地有镜像就使用本地镜像,没有就拉取在线镜像。上面三个值都没设置的话,默认是 Alwaysspec.containers[].command[]List指定容器启动命令,因为是数组可以指定多个,不指定则使用镜像打包时使用的启动命spec.containers[].args[]List指定容器启动命令参数,因为是数组可以指定多个。spec.containers[].workingDirString指容器的工作目录spec.containers[]. volumeMounts[]List指定容器内部的存储卷配置spec.containers[].volumeMounts[].nameString指定可以被容器挂载的存储卷的名称spec.containers[].volumeMounts[].mountPathString指可以被容器挂载的存储卷的路径spec.containers[].volumeMounts[]. readOnlyString设置存储卷路径的读写模式,ture或者 false,spec.containers[].ports[]List指定容器需要用到的端口列表spec.containers[].ports[].nameString指定端口名称spec.containers[].ports[].containerPortString指定容器需要监听的端口号spec. containers[.ports[].hostPortString指定容器所在主机需要监听的端口号,默认跟上面 icontainerPort相同,注意设置了 hostPort，同一台主机无法启动该容器的相同副本(因为主机的端口号不能相同,这样会冲突)spec. containers[]-ports[.protocolString指定端口协议,支持TCP和UDP,默认值为 TCPspec. containers[]. env[]List指定容器运行前需设置的环境变量列表spec. containers[].env[].nameString指环境变量名称spec.containers[].env].valueString指定环境变量值spec.containers[].resourcesObject指定资源限制和资源请求的值(这里开始就是设置容器的资源上限)spec.containers[].resources.limitsObject指设置容器运行时资源的运行上限spec.containers[].resources.limits.cpuString指定CPU的限制,单位为core数,将用于docker run-cpu-shares参数(这里前面文章 Pod资源限制有讲过 HAP 那个啥的，哈哈 主要我也忘记具体名字了)spec.containers[].resources. limits.memoryString指定MEM内存的限制,单位为MB、GiB spec.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8bee8f7bb04e3ad9cec34b40a196bee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c31687dcebe3ef1bdf1cc590ccbbe7e8/" rel="bookmark">
			win10无法登陆到你的账户解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进入win10系统登录的时候很多用户遇到了win10无法登陆到你的账户情况，这种问题都会需要来进行重新设置，来看看怎么解决这个无法登录问题吧。
更多重装系统教程尽在小白系统重装官网
1、首先我们需要进入win10系统安全模式。【安全模式进入方法】
2、然后按下快捷键“win+x”点击“powershell”，
然后输入：net localgroup administrators 用户名 /add 注意留空。
3、然后按下快捷键“win+i”依次点击“账户—其他人员”在右侧点击创建用户名。
4、然后点击“更改账户类型”。
5、然后在“账户管理”下拉中选择“管理员”点击确定重启电脑即可。
进入win10系统登录的时候很多用户遇到了win10无法登陆到你的账户情况，这种问题都会需要来进行重新设置，来看看怎么解决这个无法登录问题吧。
1、首先我们需要进入win10系统安全模式。【安全模式进入方法】
2、然后按下快捷键“win+x”点击“powershell”，
然后输入：net localgroup administrators 用户名 /add 注意留空。
3、然后按下快捷键“win+i”依次点击“账户—其他人员”在右侧点击创建用户名。
4、然后点击“更改账户类型”。
5、然后在“账户管理”下拉中选择“管理员”点击确定重启电脑即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b7b1ea679d6785492214af4dc8a16f7/" rel="bookmark">
			编译系统入门篇-Android10.0编译系统（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要：本节主要来进行Android10.0 编译系统入门讲解
1 概述 在 Android 7.0 之前，Android 编译系统使用 GNU Make 描述和shell来构建编译规则，模块定义都使用Android.mk进行定义，Android.mk的本质就是Makefile，但是随着Android的工程越来越大，模块越来越多，Makefile组织的项目编译时间越来越长。这样下去Google工程师觉得不行，得要优化。
因此，在Android7.0开始，Google采用ninja来代取代之前使用的make，由于之前的Android.mk数据实在巨大，因此Google加入了一个kati工具，用于将Android.mk转换成ninja的构建规则文件buildxxx.ninja,再使用ninja来进行构建工作。
ninja的网址：https://ninja-build.org
编译速度快了一些，但是既然要干， 那就干个大的，最终目标要把make都取代，于是从Android8.0开始，Google为了进一步淘汰Makefile，因此引入了Android.bp文件来替换之前的Android.mk。
Android.bp只是一个纯粹的配置文件，不包括分支、循环语句等控制流程，本质上就是一个json配置文件。Android.bp 通过Blueprint+soong转换成ninja的构建规则文件build.ninja，再使用ninja来进行构建工作。
Android10.0上，mk和bp编译的列表可以从 \out\.module_paths中的Android.bp.list、Android.mk.list中看到，Android10.0还有400多个mk文件没有被替换完，Google任重道远。
Android编译演进过程：
Android7.0之前 使用GNU Make
Android7.0 引入ninja、kati、Android.bp和soong构建系统
Android8.0 默认打开Android.bp
Android9.0 强制使用Android.bp
Google在 Android 7.0之后，引入了Soong构建系统，旨在取代make，它利用 Kati GNU Make 克隆工具和 Ninja 构建系统组件来加速 Android 的构建。
Make 构建系统得到了广泛的支持和使用，但在 Android 层面变得缓慢、容易出错、无法扩展且难以测试。Soong 构建系统正好提供了 Android build 所需的灵活性。
Android系统的编译历程：
2 编译流程 2.1 编译构成 Android的编译目录在/build 中，看一下Android 10源码中的build目录，现在是这个样子：
这个目录中可以看到core文件夹被link到了make/core，envsetup.sh被link到make/envsetup.sh，这主要是为了对使用者屏蔽切换编译系统的差异。
这里重点看四个文件夹：blueprint、kati、make、soong
blueprint：用于处理Android.bp，编译生成*.ninja文件，用于做ninja的处理
kati：用于处理Android.mk，编译生成*.ninja文件，用于做ninja的处理
make：文件夹还是原始的make那一套流程，比如envsetup.sh
soong：构建系统，核心编译为soong_ui.bash
Soong编译系统家族成员及各自关系如下图所示：
在编译过程中，Android.bp会被收集到out/soong/build.ninja.d,blueprint以此为基础，生成out/soong/build.ninja
Android.mk会由kati/ckati生成为out/build-aosp_arm.ninja
两个ninja文件会被整合进入out/combined-aosp_arm.ninja
out/combined-aosp_arm.ninja内容如下所示： builddir = out pool local_pool depth = 42 build _kati_always_build_: phony subninja out/build-aosp_arm.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b7b1ea679d6785492214af4dc8a16f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc1c5077fc09c828a03c4a1fb4269c81/" rel="bookmark">
			java8实现数组转字符串（以特定字符拼接）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java8实现数组转字符串（以特定字符拼接）的方法 实现代码 list.stream().collect(Collectors.joining(",")); 实例 List list = new ArrayList(); list.add("a"); list.add("b"); list.add("c"); String str = (String) list.stream().collect(Collectors.joining(",")); System.out.println(str); //如果是整形 list.stream().map(String::valueOf).collect(Collectors.joining(",")); 输出 a,b,c 是不是很简单呢
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c958ae232b53bbb694b6ade2de8cba99/" rel="bookmark">
			python编码问题的一点笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python编码： 中文乱码问题：
如果开头不声明保存编码的格式是什么，那么它会默认使用 ASCII 码保存文件。这时如果你的代码中有中文就会出错了，即使你的中文是包含在注释里面的。声明中文编码格式的方法是在文件开头加上如下代码。 #coding=utf-8或#coding=gbk
设置Python中的编码：
# code: 编码格式
(美观写法：#-*- coding: UTF-8 -*-)
编码类型：
GB2312编码：适用于汉字处理、汉字通信等系统之间的信息交换。
GBK编码： 是汉字编码标准之一，是在 GB2312—80 标准基础上的内码扩展规范，使用了双字节编码。
ASCII编码： 是对英语字符和二进制之间的关系做的统一规定。
Unicode编码（内存中）：这是一种世界上所有字符的编码，当然，它没有规定的存储方式。(固定的最少 2 个字节。)
UTF-8编码： 是 Unicode Transformation Format-8 bit 的缩写，4UTF-8 是 Unicode 的一种实现方式。它是可变长的编码方式，可以使用 1～4个 字节表示一个字符，可以根据不同的符号而变化字节长度。(表示英文时可节省空间)
扩展：
在计算机内存中，统一使用 Unicode 编码，当需要保存到硬盘或者需要传输的时候，就转换为 UTF-8 编码。
举个例子：
当用记事本程序编辑的时候，从文件读取的 UTF-8 字符被转换为内存中的 Unicode 字符进行读取修改，编辑完成后，当保存的时候再把 Unicode 转换为 UTF-8 写入保存到 04 文件中，具体过程如图 2-4 所示。
所以在默认情况下，Python 源码文件以 UTF-8 格式进行编码，所有字符串都是 Unicode 字符串。
浏览网页时：
服务器会把动态生成的 Unicode 内容转换为 UTF-8 再传输到浏览器，具体过程如图 2-5 所示。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c958ae232b53bbb694b6ade2de8cba99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f8b7a6ef8583a965bc35264d625eef2/" rel="bookmark">
			KEPServerEX U-CON驱动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		梅特勒-托利多（METTLER TOLEDO）是一家历史悠久的精密仪器及衡器制造商与服务提供商，其地磅系统与重载秤适用于包括食品、化工、制药、制造、交通运输和物流等各种行业内的应用。
KEPServerEX以其特有的U-CON（User-Configurable）驱动，为没有现成驱动的串行和以太网设备创建设备驱动（包括条形码扫描枪、称重设备、各种传感器和 RTU）。它的直观界面专为非编程者设计，用户仅需具备基本的协议知识、协议手册和设备即可开始使用，从而为上层OPC客户端或者云端应用提供更快捷的访问接口。
方案简介
客户需要将每次称重数据主动发送给OPC上位机，现场电子秤带有RS485接口并且有明确的通讯协议，我们推荐客户选择使用KEPServerEX中U-CON驱动来采集数据，再以OPC协议上传给OPC客户端。
下面开始小伙伴们记笔记了，让我们通过实例看下如何配置KEPServerEX中U-CON驱动
设备型号：梅特勒-托利多T800，通过RS-485串口通讯
1.新建通道，在通道选项中选择“U-CON（user-configurable）”驱动，单击下一步
注意：如果在下拉选项中没有找到想要的驱动，可能安装的时候没有完全安装，此时需要对KEPSeverEX V6进行修改安装，在安装时安装所需要的驱动。
自定义通道名，如下修改为“METTLER”，单击下一步:
3.根据实际的设备的连接参数，波特率、数据位、停止位、奇偶检验，以及设备连接到服务器的COM口，，完成后点击“下一步”:
由于设备设置的是连续输出格式，因此不需要我们发送请求命令，只需要被动接受设备数据即可，这里将通道设置为非主动问答式: 5.单击软件界面中的“Click to add a device”或者工具栏上的“New Device”,进行设备设置。完成后点击“下一步”按照默认参数直到设备创建完成：
6.对设备中的“U-CON Device Profile”进行“Transaction Editor”，进入设置界面：
7.在这个界面进行如下标记建立，然后对称重系统发过来的数据帧如下进行规则设置：
8.设置完成后点击“Updateserver”：
9.以上完成后返回主界面就可以在设备下方自动出现标记，到此设置完成：
如果您有一些自定义协议设备想要通讯，欢迎与我们联系咨询，后续我们也会分享更多的案例。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ee318f1d9dc0229e5315b1726c6fbea/" rel="bookmark">
			Hadoop集群基础操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hadoop集群基础操作 Hadoop集群基本信息查看 集群存储信息查看 登录HDFS监控web查看运行情况及相关存储信息，默认端口为50070，具体以hdfs-site.xml文件中配置为准
&lt;!-- 定义namenode界面的访问地址 --&gt; &lt;property&gt; &lt;name&gt;dfs.http.address&lt;/name&gt; &lt;value&gt;node1:50070&lt;/value&gt; &lt;/property&gt; 当然也可以在后台服务器通过命令的方式进行查看：
Usage: hdfs dfsadmin Note: Administrative commands can only be run as the HDFS superuser. [-report [-live] [-dead] [-decommissioning] [-enteringmaintenance] [-inmaintenance]] 集群计算资源查看 登录8088端口（默认）查看集群的计算资源信息，具体地址以yarn-site.xml文件中配置为准：
&lt;!-- 指定YARN的ResourceManager的地址 --&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt; &lt;value&gt;node1&lt;/value&gt; &lt;/property&gt; &lt;!-- yarn的web访问地址 --&gt; &lt;property&gt; &lt;description&gt; The http address of the RM web application. If only a host is provided as the value, the webapp will be served on a random port.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ee318f1d9dc0229e5315b1726c6fbea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ec8ea09ac17f8cc34db12e6436c7031/" rel="bookmark">
			RStudio 下载R包的几种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 使用RStudio自带的安装方法，右侧找到Packages，点击Install，然后输入package_name即可
2.使用CRAN，repos后面的镜像地址可以更改，一般使用的是这个清华的镜像。
#一般使用第一行命令进行安装，如果不成功可以参考第二行命令对镜像进行设置 install.packages("package_name") install.packages("package_name",repos="http://mirrors.tuna.tsinghua.edu.cn/CRAN/") 3.使用BiocManager包
install.packages("BiocManager") #如果已经下载了BiocManager包，跳过此行 BiocManager::install("package_name") 4.使用GitHub中的devtools包
install.package("devtools") #如果已经下载了devtools包，跳过此行 library(devtools) install_github("Package_name") 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ea86c184d8dc909bcfd36893d11ebf5/" rel="bookmark">
			Java实现顺序表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、顺序表的简单理解
1、为什么我们要以数组为基础来构建顺序表呢？
2、顺序表都具有哪些功能
二、顺序表的代码实现
1、构建并且初始化顺序表
2、在顺序表中添加元素
1、判断需要添加元素的下标是否在顺序表的范围内
2、如果添加元素下标合法，进行添加元素操作。
3、判断顺序表是否满了满了的话我们需要进行扩容
4、实现代码如下：
3、打印顺序表中的元素
4、判断顺序表中是否含有某个元素
5、查找顺序表中元素的下标
6、更新顺序表对应下标的元素值
7、查找顺序表对应下标的元素值
8、删除顺序表中的元素
9、获取顺序表的长度
10、清空顺序表
三、顺序表的缺点和优点总结 1、顺序表的优点
2、顺序表的缺点
一、顺序表的简单理解 顺序表示用一段物理地址连续的存储单元依次存储数据元素的线性结构，一般以数组为基础进行存储。
1、为什么我们要以数组为基础来构建顺序表呢？ 首先，我们的数组是在内存中的顺序存储，因此他就可以更好的在逻辑上实现顺序表。
并且，数组里面存储的元素就像一个队伍一样，每个人都是紧密连接，既不能打乱队伍顺序，也不能跳过一个空位，去排下一个位置，并且每个人都有自己对应的编码，也就是他们的下标。
这就是一个数组，因此由于有以上的优势，他完全可以胜任顺序表的地基。
2、顺序表都具有哪些功能 首先顺序表会有增，删，查，找这四个功能，接下来我们将会用java代码的形式来对这些功能的实现并且构建一个顺序表。
二、顺序表的代码实现 1、构建并且初始化顺序表 首先我们需要构建一个顺序表，前文指出顺序表的地基为数组，因此我们需要一个数组，但是仅仅有一个数组是不够的，因为我们只知道数组的长度，并不知道其实数组里面存储了多少的元素，所以我们还需要一个东西来记录我们顺序表存储了多少的元素个数。
public class myArraysList { public int[]arrary; public int usedSize ; // 获取顺序表的有效数据长度 public myArraysList(){ this.arrary = new int[10];//初始化数组 } } 这里我定义了一个构造方法，目的是用来在方法内部定义数组大小，开辟空间。
2、在顺序表中添加元素 在添加元素时，我们需要考虑两点问题
1、判断需要添加元素的下标是否在顺序表的范围内 判断添加元素下标是否大于零，并且是否在顺序表存储元素数量范围内
2、如果添加元素下标合法，进行添加元素操作。 关于这一条我们会有两种情况
1、尾部插入
这种插入最为简单，直接插入到顺序表最后面就可以
2、中间插入
这个就稍微有点复杂了，首先我们得吧数组插入元素的位置空出来，因此我们需要把插入位置元素的位置以及后面元素统一向后移动一位，这样就腾出位置，然后插入元素
3、判断顺序表是否满了满了的话我们需要进行扩容 对于判断顺序表是否满了，我构建了一个布尔类型的返回方法，因此可以更好的在判断语句中利用它。对于扩容我们可以利用copyOf这个方法来实现对数组的扩容
4、实现代码如下： public boolean isFull() { return this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ea86c184d8dc909bcfd36893d11ebf5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61134fae6a6f44e8da1bb569b5a6eade/" rel="bookmark">
			一文了解Flutter的GetX框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Get 关于GetGetX的计数器示例Get三大功能状态管理响应式状态管理器声明一个响应式变量数据变化监听 简单状态管理器用法无需StatefulWidgets其他使用方法唯一标识 依赖管理controller生命周期实例方法Get.put()Get.lazyPutGet.putAsync使用实例化方法/类区别 BindingsBindings类BindingsBuilder FlutterBinding智能管理如何改变SmartManagement.fullSmartManagement.onlyBuildersSmartManagement.keepFactory Bindings的工作原理 路由配置路由路由跳转路由传参数路由获取参数SnackBarsDialogsBottomSheets嵌套导航兼容使用 实用工具国际化翻译使用翻译 语言改变语言系统语言 改变主题GetConnect默认配置自定义配置 GetPage 中间件优先级RedirectonPageCalledOnBindingsStartOnPageBuildStartOnPageBuiltOnPageDispose 其他高级APIValueBuilderGetViewGetxServiceGetUtils 关于Get GetX 是 Flutter 上的一个轻量且强大的解决方案：高性能的状态管理、智能的依赖注入和便捷的路由管理。GetX 有3个基本原则： 性能： GetX 专注于性能和最小资源消耗。GetX 打包后的apk占用大小和运行时的内存占用与其他状态管理插件不相上下。效率： GetX 的语法非常简捷，并保持了极高的性能，能极大缩短开发时长。结构： GetX 可以将界面、逻辑、依赖和路由完全解耦，逻辑更清晰，代码更容易维护。 GetX 并不臃肿，却很轻量。如果你只使用状态管理，只有状态管理模块会被编译，其他没用到的东西都不会被编译到你的代码中。它拥有众多的功能，但这些功能都在独立的容器中，只有在使用后才会启动。Getx有一个庞大的生态系统，能够在Android、iOS、Web、Mac、Linux、Windows和你的服务器上用同样的代码运行。 在Flutter三方库中，也是likes最高的
GetX的计数器示例 Flutter默认创建的 "计数器 "项目有100多行（含注释），这里使用 GetX 重写一个计数器 。
而完成这一切只需 26 行代码（含注释）
步骤1. 在你的MaterialApp前添加 “Get”，将其变成GetMaterialApp。 void main() =&gt; runApp(GetMaterialApp(home: Home())); GetMaterialApp只是对MaterialApp封装了一层，它的子组件是默认的MaterialApp。
如果你只用Get来进行状态管理或依赖管理，就没有必要使用GetMaterialApp。GetMaterialApp对于路由、snackbar、国际化、bottomSheet、对话框以及与路由相关的高级apis和没有上下文（context）的情况下是必要的。
第二步： 创建你的业务逻辑类，并将所有的变量，方法和控制器放在里面。 你可以使用一个简单的".obs "使任何变量成为可观察的。 class Controller extends GetxController{ var count = 0.obs; increment() =&gt; count++; } 第三步: 创建你的界面，使用StatelessWidget节省一些内存，使用Get你可能不再需要使用StatefulWidget。 class Home extends StatelessWidget { @override Widget build(context) { // 使用Get.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61134fae6a6f44e8da1bb569b5a6eade/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eab371164f4b7b4b519deb43a5ac2eba/" rel="bookmark">
			SVN图标丢失解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.回到系统桌面，点击“TortoiseSVN”，进入设置“Setting”选项
2.点击“图标覆盖”选项卡，再点击“覆盖程序”选项卡，点击按钮“启动注册表管理器”
3.进入注册表编辑器中，然后进入“HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\ShellIconOverlayIdentifiers”
4.将其中9项与SVN相关的图标进行“重命名”，加入3~8个空格“ ”，然后刷新“F5”显示列表，使其排列在最前面，如下:
然后以下要让SVN图标显示出来有两种方法：
（A）重启电脑
直接重启电脑，重启之后就可以看到对应的图标显示正常
（B）重启桌面
（1）关闭注册表编辑器，按“Ctrl + Alt + Delete”启动任务管理器，进入“进程”选项卡，找到“explorer.exe”
（2）右键，点击“结束进程”，确认结束进程
（3）然后在这个任务管理器中，点击上面的菜单栏“文件”，点击“新建”任务，输入“explorer.exe”,重启桌面，然后进入相应的SVN文件夹，就可以看到图标已经正常显示
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/460d95e997ff4028590799636ae530a4/" rel="bookmark">
			python根据视频帧按秒从视频中提取图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看到有按照帧提取视频中的图片的例子，但是个人只需用到每秒的图片。
以下是用到的代码：
import os import cv2 def save_img2(): # 提取视频中图片 按照每秒提取 间隔是视频帧率 video_path = r'C:/Users/Louise喵/Desktop/video1/' # 视频所在的路径 f_save_path = 'D:/image/' # 保存图片的上级目录 videos = os.listdir(video_path) # 返回指定路径下的文件和文件夹列表。 for video_name in videos: # 依次读取视频文件 file_name = video_name.split('.')[0] # 拆分视频文件名称 ，剔除后缀 folder_name = f_save_path + file_name # 保存图片的上级目录+对应每条视频名称 构成新的目录存放每个视频的 os.makedirs(folder_name, exist_ok=True) # 创建存放视频的对应目录 vc = cv2.VideoCapture(video_path + video_name) # 读入视频文件 fps = vc.get(cv2.CAP_PROP_FPS) # 获取帧率 print(fps) # 帧率可能不是整数 需要取整 rval = vc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/460d95e997ff4028590799636ae530a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab231c020889856149d15e7b235900e5/" rel="bookmark">
			python中join的使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 join的使用语法和定义实例 join的使用 语法和定义 str.join(iterable) iterable:所有值必须是字符串的任何可迭代对象 join方法获取可迭代对象中的所有项目，并将他们连接成字符串
实例 #1 &gt;&gt;&gt; list =[1,2,3] #定义有个可迭代对象 &gt;&gt;&gt; "|".join(list) #使用字符串|进行连接生成新的字符 TypeError: sequence item 0: expected str instance, int found #报错期望连接字符，但是发现的是int #2 &gt;&gt;&gt; list =["1","2","3"]#可迭代对象均为字符串 &gt;&gt;&gt; "|".join(list) '1|2|3' #3 &gt;&gt;&gt; Dict = {"name":"python","version":3.7} &gt;&gt;&gt; "|".join(Dict) name|version #使用字典作为可迭代对象返回的是key而不是value 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4023e117c07ebef9c399516d388457ba/" rel="bookmark">
			2022 IDEA （学生邮箱认证）安装使用教程以及基础配置教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2022 IDEA （学生邮箱认证）安装使用教程以及基础配置教程 1. IDEA 下载安装a. IDEA 下载b. 安装 IDEAc. 打开软件 2. 利用教育邮箱进行学生认证a. 进行学生认证b. 认证完成登录软件 3. 学生认证常见问题4. 使用 IDEA 创建项目a. 新建一个 Maven 项目b. 添加 tomcat 模板 5. 简单配置自己的 IDEA 风格a. 主题颜色b.字体大小c. 设置快捷键 6. 安装常见的 IDEA 插件a. 打开插件商店b. 下载自己喜欢的插件c. 部分插件安装后需要重启 7. 常用的 IDEA 插件 1. IDEA 下载安装 a. IDEA 下载 IDEA 官网下载地址
左侧是专业版，右侧是社区版
如果你有学生邮箱账号的话，推荐下载专业版，因为社区版的部分功能不能使用
选择适合自己的版本下载就可以了
b. 安装 IDEA 点击 NEXT 下一步
选择自己的安装路径
配置一下自己的选择
选择初始的就可以了
等待安装完成即可
完成后会重启一下电脑，然后就安装完成了
重启后，再次打开软件，然后选择接受就好了
这里最好选择不发送，不然会经常给你发邮件…有点烦…
c. 打开软件 没有账号的话，要先进行注册，或者选择试用（好像只有30天的试用期）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4023e117c07ebef9c399516d388457ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/171252e766efd99f2d5e8efff362e6e3/" rel="bookmark">
			机器学习-贝叶斯分类算法与应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 朴素贝叶斯分类算法原理 1.1 概述 贝叶斯分类算法是一大类分类算法的总称
贝叶斯分类算法以样本可能属于某类的概率来作为分类依据
朴素贝叶斯分类算法是贝叶斯分类算法中最简单的一种
注：朴素的意思是条件概率独立性[dht1] 此处要想真正理解，需要有概率论的基础知识
P(A|x1x2x3x4)=p(A|x1)*p(A|x2)p(A|x3)p(A|x4)则为条件概率独立
P(xy|z)=p(xyz)/p(z)=p(xz)/p(z)*p(yz)/p(z)
1.2 算法思想 朴素贝叶斯的思想是这样的：
如果一个事物在一些属性条件发生的情况下，事物属于A的概率&gt;属于B的概率，则判定事物属于A
通俗来说比如，你在街上看到一个黑人，我让你猜这哥们哪里来的，你十有八九猜非洲。为什么呢？
在你的脑海中，有这么一个判断流程：
这个人的肤色是黑色 &lt;特征&gt;黑色人种是非洲人的概率最高 &lt;条件概率：黑色条件下是非洲人的概率&gt;没有其他辅助信息的情况下，最好的判断就是非洲人 这就是朴素贝叶斯的思想基础。
再扩展一下，假如在街上看到一个黑人讲英语，那我们是怎么去判断他来自于哪里？
提取特征：
肤色： 黑
语言： 英语
黑色人种来自非洲的概率： 80%
黑色人种来自于美国的概率：20%
讲英语的人来自于非洲的概率：10%
讲英语的人来自于美国的概率：90%
在我们的自然思维方式中，就会这样判断：
这个人来自非洲的概率：80% * 10% = 0.08
这个人来自美国的概率：20% * 90% =0.18
我们的判断结果就是：此人来自美国！
其蕴含的数学原理如下：
p(A|xy)=p(Axy)/p(xy)=p(Axy)/p(x)p(y)=p(A)/p(x)*p(A)/p(y)* p(xy)/p(xy)=p(A|x)p(A|y)
朴素贝叶斯分类器
朴素贝叶斯分类器的表示形式：
当特征为为x时，计算所有类别的条件概率，选取条件概率最大的类别作为待分类的类别。由于上公式的分母对每个类别都是一样的，因此计算时可以不考虑分母，即
朴素贝叶斯的朴素体现在其对各个条件的独立性假设上，加上独立假设后，大大减少了参数假设空间。　1.3 算法要点 1.3.1 算法步骤 分解各类先验样本数据中的特征计算各类数据中，各特征的条件概率 （比如：特征1出现的情况下，属于A类的概率p(A|特征1)，属于B类的概率p(B|特征1)，属于C类的概率p(C|特征1)......）
分解待分类数据中的特征（特征1、特征2、特征3、特征4......）计算各特征的各条件概率的乘积，如下所示： 判断为A类的概率：p(A|特征1)*p(A|特征2)*p(A|特征3)*p(A|特征4).....
判断为B类的概率：p(B|特征1)*p(B|特征2)*p(B|特征3)*p(B|特征4).....
判断为C类的概率：p(C|特征1)*p(C|特征2)*p(C|特征3)*p(C|特征4).....
......
结果中的最大值就是该样本所属的类别 1.3.2 算法应用举例 大众点评、淘宝等电商上都会有大量的用户评论，比如：
1、衣服质量太差了！！！！颜色根本不纯！！！
2、我有一有种上当受骗的感觉！！！！
3、质量太差，衣服拿到手感觉像旧货！！！
4、上身漂亮，合身，很帅，给卖家点赞
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/171252e766efd99f2d5e8efff362e6e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29e068ba1ece1382c9da6200aaa9f4af/" rel="bookmark">
			Gitea：从SVN迁移到Git
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
环境信息
迁移步骤
SVN和Git都是优秀的版本管理工具。不幸的是，对于从SVN迁移到Git的过程、命令和说明，网上不少文章存在误导性。因此本文以Gitea为例，演示从SVN迁移到Git的详细过程。
本文前提条件：
已经完成Gitea安装（含Git软件安装）在Gitea中，已完成了初始配置并正常运行在Gitea中，根据需要配置Organization、Teams、User Accounts等组织协作信息（可选）在Gitea中，已经创建Repository（这里名字为：gsyspm，无需对该Repository初始化） 环境信息 在以上git Repository创建完成且未被初始化的情况下，需要从原SVN仓库迁移导入至Git，包括在SVN的提交Commit 和作者log日志。需要导出的SVN信息：
SVN仓根URL：http://20.1.1.11:7001/usvn/svn/sys_pmSVN仓中trunk相对于根的路径：pmis/01develop/02code/trunkSVN仓中branches相对于根的路径：pmis/01develop/02code/branchesSVN仓中没有Tags信息需要迁移的SVN版本号范围：从1至HEAD 迁移步骤 以下步骤通过git svn命令完成从SVN至Git的迁移：
1、在任意PC电脑上（能够访问SVN和Gitea）创建迁移临时用目录：migrate_svn_to_git/
2、进入该目录。创建文本authors_map.txt，存放SVN作者至Git作者映射信息文件，格式形式如下：
loginname=JoeUser&lt;user@example.com&gt;
或者可通过以下方式自动生成该作者映射文件。
进入本地既有的SVN目录（该目录已经完成从SVN checkout至最新）通过以下命令生成（在Bash中执行）authors_map.txt文件，然后将生成得到的该txt文件拷贝至 migrate_svn_to_git/ 目录下：
svn log -r 1:HEAD --xml | grep "&lt;author" | sort -u | awk -F '&lt;author&gt;' '{print $2}' | awk -F '&lt;/author&gt;' '{print $1"="$1"&lt;"$1"@yykj.com&gt;" }' &gt; authors_map.txt 3、通过以下两条git svn命令从SVN仓导出至本地（在Bash中执行）：
#以SVN仓根URL对当前本地目录进行git初始化 git svn init http://20.1.1.11:7001/usvn/svn/sys_pm --prefix fromsvn/ --no-metadata --username=LOGIN_SVNUSER --trunk=pmis/01develop/02code/trunk --branches=pmis/01develop/02code/branches #从SVN仓导出到本地git仓中（耗时可能很长甚至几天几夜） git svn fetch -r 1:HEAD --authors-file=authors_map.txt 选项说明：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29e068ba1ece1382c9da6200aaa9f4af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adff600fab5323a40d4a02b8356a8aa1/" rel="bookmark">
			Linux系统级程序设计-3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 wait函数
#include &lt;sys/wait.h&gt; pid_t wait(int *status); 功能：挂起进程，进程进入阻塞状态，直到子进程变为僵尸态，如果捕获到子进程的退出信息就会转为运行态，然后回收子进程资源并返回；若没有变为僵尸态的子进程，wait函数就会让进程一直阻塞。若当前进程有多个子进程，只要捕获到一个变为僵尸态的子进程，wait函数就会恢复执行态。
参数说明：参数status是一个int *类型的指针，用来保存子进程退出时的状态信息。通常情况下该参数设为NULL，表示不关心进程时如何终止的。
返回值说明：
成功：返回子进程的进程id；
失败：返回-1，errno被设置为ECHILD。
【案例 1】若子进程p 1 p_1p是其父进程p pp的先决进程，基于wait函数使得进程同步。
test_wait.c #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/wait.h&gt; int main(){ pid_t tempPid, tempW; tempPid = fork(); if(tempPid == -1){ perror("fork error"); exit(1); }else if(tempPid == 0){//child sleep(3); printf("Child process, pid = %d, ppid = %d\n", getpid(), getppid()); }else{//parent tempW = wait(NULL); printf("Catched a child process, pid = %d, ppid = %d\n", tempW, getppid()); }//of if printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/adff600fab5323a40d4a02b8356a8aa1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e673cce84971e66bf043686b63048ae/" rel="bookmark">
			m3u8加密文件原理及下载脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、加密ts文件解密 #EXTM3U #EXT-X-VERSION:3 #EXT-X-MEDIA-SEQUENCE:0 #EXT-X-ALLOW-CACHE:YES #EXT-X-TARGETDURATION:13 #EXT-X-KEY:METHOD=AES-128,URI="https://j-island.net/movie/hls_key/s/857401e309d8a032c3bb18f4b09b8db2/?f=jj_20190401_hihijets_004",IV=0xaa3dcf6a7acb92ff4fb08d9b3b3d6f51 #EXTINF:12.078733, https://j-island.stream2.johnnys-net.jp/j-island/jj_20190401_hihijets_004/jj_20190401_hihijets_00400000.ts #EXTINF:9.009000, https://j-island.stream2.johnnys-net.jp/j-island/jj_20190401_hihijets_004/jj_20190401_hihijets_00400001.ts #EXTINF:9.009000, https://j-island.stream2.johnnys-net.jp/j-island/jj_20190401_hihijets_004/jj_20190401_hihijets_00400002.ts #EXTINF:12.012000, https://j-island.stream2.johnnys-net.jp/j-island/jj_20190401_hihijets_004/jj_20190401_hihijets_00400003.ts #EXTINF:9.009000, https://j-island.stream2.johnnys-net.jp/j-island/jj_20190401_hihijets_004/jj_20190401_hihijets_00400004.ts #EXTINF:2.002000, https://j-island.stream2.johnnys-net.jp/j-island/jj_20190401_hihijets_004/jj_20190401_hihijets_00400005.ts #EXT-X-ENDLIST m3u8视频另一种下载方式 如上图中用ts链接直接下载下来的ts视频文件是加密的（为什么要下加密的？虽然加密但是下载速度快啊）。
#EXT-X-KEY 字段已经写明了加密方式是AES-128，key通过URI获取，IV也有。
#EXT-X-KEY: METHOD=AES-128, URI="https://j-island.net/movie/hls_key/s/857401e309d8a032c3bb18f4b09b8db2/?f=jj_20190401_hihijets_004", IV=0xaa3dcf6a7acb92ff4fb08d9b3b3d6f51 那怎么解密呢？
1.复制URI地址到网页，你将秒速自动下载得到一个16字节文件 2.打开终端，打开该文件查看16进制：
打开二进制key
vi -b /路径/key文件 输入“ :%!xxd”再把二进制文件切换到16进制
00000000: 283d cc2d 3747 e965 0a81 ead3 1e04 fa8a (=.-7G.e........ 获取到key就是 283dcc2d3747e9650a81ead31e04fa8a 3.打开终端，转化
openssl aes-128-cbc -d -in /路径/media_0.ts -out /路径/media_decryptd_0.ts -nosalt -iv $iv -K $strkey *media_0.ts* : 加密ts文件（无法播放） *media_decryptd_0.ts* : 解密后ts文件（可以直接播放） *$iv* : aa3dcf6a7acb92ff4fb08d9b3b3d6f51（#EXT-X-KEY字段中获取，注意去掉0x） *$strkey* : 283dcc2d3747e9650a81ead31e04fa8a（上一步获得）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e673cce84971e66bf043686b63048ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/080c54176bc2c297bfede72a30e65275/" rel="bookmark">
			（ICCV-2021）通过有效的全局-局部特征表示和局部时间聚合进行步态识别（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		4. Experiments 4.1. Datasets \quad \quad 在两个常用数据集上评估了所提出方法的性能，即CASIA-B和 OUMVLP数据集。
\quad \quad CASIA-B. CASIA-B数据集是最大的跨视角步态数据库。它包括124个受试者，每个受试者有10组视频。10组视频中，6组是正常行走（NM），2组是背着包行走（BG），2组是穿着外套行走（CL）。每组包含11个不同角度的步态序列（0°-180°，采样间隔为18°）。因此，CASIA-B 中有 124 (subject) × 10 (groups) × 11 (view angle) = 13 , 640 124\text{(subject)}\times10\text{(groups)}\times11\text{(view angle)} = 13,640 124(subject)×10(groups)×11(view angle)=13,640个步态序列。每个受试者的步态序列分为训练集和测试集。在训练阶段，根据不同的训练规模配置三种训练设置：小规模训练（ST）、中规模训练（MT）和大规模训练（LT）。对于这三种设置，分别选择 24、62 和 74 名受试者作为训练集，其余 100、62 和 50 名受试者分别用于测试。来自训练集的所有步态数据用于在训练阶段训练所提出的模型。在测试阶段，将序列NM#01-NM#04作为注册集，而考虑序列NM#05-NM#06、BG#01-BG#02和CL#01-CL#02作为验证集来评估性能。
\quad \quad OU-MVLP. OUMVLP 数据集是规模最大的步态识别数据库之一，共包含 10,307 个受试者。每个受试者包含两组视频，Seq#00 和 Seq#01。每组视频从 14 个角度捕获：0°-90° 和 180°-270°，采样间隔为 15°。采用的协议为：5,153名受试者作为训练数据，5,154名受试者作为测试数据来评估所提出方法的性能。在测试阶段，Seq#01中的序列作为注册集，Seq#00中的序列作为验证集进行评估。
4.2. Implementation Details \quad \quad 采用与GaitSet相同的预处理方法来获得 CASIA-B 和 OUMVLP 数据集的步态轮廓。每帧的图像都归一化为 64 × 44 64\times44 64×44 的大小。网络参数如表1所示。三元组损失公式中的 m m m设置为 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/080c54176bc2c297bfede72a30e65275/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfb9ea17789c357df98eac14346e7474/" rel="bookmark">
			航空公司客户价值分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的这个项目放在百度网盘了，你可以提取。数据表都有。
链接：https://pan.baidu.com/s/1il9Uzs7xlcEkssIzeiZpfA 提取码：ys9e
一、对于数据的抽取
#1、数据抽取 import pandas as pd datafile = './air_data.csv' # 航空原始数据路径 data = pd.read_csv(datafile, encoding = 'utf-8') #读取原始数据，指定UTF-8编码 二、数据探索分析
#2、数据探索分析 import pandas as pd datafile= './air_data.csv' #航空原始数据,第一行为属性标签 resultfile = './explore.xls' #数据探索结果表 data = pd.read_csv(datafile, encoding = 'utf-8') #读取原始数据，指定UTF-8编码 explore = data.describe(percentiles = [], include = 'all').T #包括对数据的基本描述，percentiles参数是指定计算多少的分位数表（如1/4分位数、中位数等）；T是转置，转置后更方便查阅 explore['null'] = len(data)-explore['count'] #describe()函数自动计算非空值数，需要手动计算空值数 explore = explore[['null', 'max', 'min']] explore.columns = [u'空值数', u'最大值', u'最小值'] #表头重命名 explore.to_excel(resultfile) #导出结果 三、对于数据的清洗
import pandas as pd datafile = '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfb9ea17789c357df98eac14346e7474/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d896ea70c2ed767b0b7c80326da9129/" rel="bookmark">
			使用Servlet和Filter打印所有请求和响应日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在之前请求日志和响应日志一般都是自定义注解 + Spring 的AOP实现, 但是这样有的时候新写的接口会忘记加日志注解了 后来使用Filter 来进行请求日志的打印 响应日志 使用Spring的 @ControllerAdvice 注解 实现, 但是领导说了 为了使日志功能更加简单使用的技术因越少越好, 后来研究了一下先使用使用Servlet和Filter打印所有请求和响应日志. 使用JDK自带的SPI 来实现自定义的日志输出.
GitHub地址
主要代码:
package com.qz1997.qzlog.filter; import cn.hutool.core.collection.CollUtil; import cn.hutool.core.util.StrUtil; import com.google.common.collect.Lists; import com.qz1997.qzlog.constant.CommonConstant; import com.qz1997.qzlog.service.PrintLogServer; import com.qz1997.qzlog.utils.SpiGetImplementUtil; import com.qz1997.qzlog.wrapper.LogWrapServletResponseWrapper; import com.qz1997.qzlog.wrapper.ParameterRequestWrapper; import com.qz1997.qzlog.wrapper.ServletOutputStreamWrapper; import lombok.NoArgsConstructor; import javax.servlet.Filter; import javax.servlet.FilterChain; import javax.servlet.FilterConfig; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.http.HttpServletRequest; import java.io.IOException; import java.io.PrintWriter; import java.util.List; /** * Http请求响应日志过滤器 * * @author zhangqi * @date 2022/5/01 15:26 */ @NoArgsConstructor @SuppressWarnings("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d896ea70c2ed767b0b7c80326da9129/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2805d2860a16a4b4c15d1e14f439fcb7/" rel="bookmark">
			python人机大战小游戏代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import random def computer(user_score,comp_score,n): #user_score接受玩家得分，comp_score接受电脑得分，n接受回合数 print(f'*********** 回合【{n}】：电脑攻击 ***********') comp = random.randint(1,3) #电脑随机取值 print(f'---------作弊{comp}') user = int(input('玩家请输入：')) if user == comp: user_score += 1 print(f'电脑使用 【 {comp} 】 攻击，玩家使用 【 {user} 】 防守；玩家获胜！') print('----------------------------------------------') print(f' -------- 电脑 {comp_score} VS {user_score} 玩家 --------') print() else: comp_score += 1 print(f'电脑使用 【 {comp} 】 攻击，玩家使用 【 {user} 】 防守；电脑获胜！') print('----------------------------------------------') print(f' -------- 电脑 {comp_score} VS {user_score} 玩家 --------') print() return user_score, comp_score #返回玩家得分、电脑得分 def user(user_score,comp_score,n): print(f'*********** 回合【{n}】：玩家攻击 ***********') comp = random.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2805d2860a16a4b4c15d1e14f439fcb7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/002e5995352ff893fa4b8986af31cf25/" rel="bookmark">
			5-2 找两个数中最大者
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本题要求对两个整数a和b，输出其中较大的数。
函数接口定义： int max( int a, int b );
其中a和b是用户传入的参数，函数返回的是两者中较大的数。
裁判测试程序样例： #include &lt;stdio.h&gt; int max( int a, int b ); int main() { int a, b; scanf("%d %d", &amp;a, &amp;b); printf("max = %d\n", max(a, b)); return 0; } /* 你的代码将被嵌在这里 */ 输入样例： -5 8 输出样例： max = 8 这道题的计算方式，首先我们定义一个max数，然后再比较a与b的大小，谁大谁就是max，最后在返回值max就可以啦，函数题每一次都要返回值，这样主体才能接受得到
int max( int a, int b ){ int max; if(a&gt;b) max=a; else max=b; return max; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1564cf3af53244b72c9b22718c76e1a3/" rel="bookmark">
			c# twincat 读取基础数据类型数组或结构体数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基础数据类型数组 class Program { public static TcAdsClient client; static void Main(string[] args) { // Create the ADS Client using (client = new TcAdsClient()) { // Establish Connection client.Connect(new AmsAddress("10.1.2.95.1.1", 851)); int handle = client.CreateVariableHandle("PRG_AIS.stAds"); AdsClass ads = (AdsClass)client.ReadAny(handle, typeof(AdsClass)); ads.boolArr[0] = 1; client.WriteAny(handle, ads); Console.ReadLine(); } } } [StructLayout(LayoutKind.Sequential, Pack = 1)] class AdsClass { [MarshalAs(UnmanagedType.ByValArray, SizeConst = 10)] public byte[] boolArr = new byte[10]; } 结构体数组 [StructLayout(LayoutKind.Sequential, Pack = 1)] class AdsClass { [MarshalAs(UnmanagedType.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1564cf3af53244b72c9b22718c76e1a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d587613944b49cd6fa70e961ed692de0/" rel="bookmark">
			windows10通过端口查找对应进程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、输入命令：netstat -ano，列出所有端口的情况。 二、在列表中我们观察被占用的端口，比如是49157，首先找到它。 三、查看被占用端口对应的PID， 输入命令：netstat -aon|findstr "1900"， 回车，记下最后一位数字，即PID,这里是4992。
四、继续输入：tasklist|findstr "4992"， 回车，查看是哪个进程或者程序占用了1900端口，结果是：svchost.exe
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5687284ba12c4384a28858fc611441b3/" rel="bookmark">
			CUDNN_STATUS_NOT_INITIALIZED解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在某平台跑代码，最开始尝试去训练，发现训练成功后久终止，修改部分参数后再次运行发现这个错误”CUDNN_STATUS_NOT_INITIALIZED“
解决方法：就是python进程其实还在继续，查找进程号
ps -ef |grep python 杀掉进程
kill -9 进程id 再次运行成功！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22b03f23c39ba291d3230b08680f686d/" rel="bookmark">
			iperf3使用方法(Windows与MacOS,iOS)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Windows下载:​​​​​
https://iperf.fr/iperf-download.php#windows MacOS下载:
brew install iperf3 iOS App Store搜索:iperf
=====
在软路由上打开终端,执行启动服务端:
iperf3 -s 客户端命令解释
单线程上传测速:iperf3 -c 192.168.5.1 单线程下载测速:iperf3 -c 192.168.5.1 -R 多线程上传测速:iperf3 -c 192.168.5.1 -P 10 多线程下载测速:iperf3 -c 192.168.5.1 -P 10 -R 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31c53b32e4061a65ea0362cecb50a73e/" rel="bookmark">
			【4-3】多彩的声音
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设计和实现一-个Soundable发声接口，该接口具有发声功能，同时还能调节声音大小。Soundable接口的这些功能将由有3种声音设备来实现，他们分别是收音机Radio、随身听Walkman、手机MobilePhone.最后还需设计--个应用程序类来使用这些实现Soundable接口的声音设备。程序运行时，先询问用户想哪个设备，用户选择设备后，程序按照该设备的工作方式打印发出的发音。
此案例分为五个类 Phone Radio Usersound WalkMan Test 一个接口Soundable
Soundable接口 public interface Soundable { public abstract void playSound(); public abstract void lower(); public abstract void stop(); } Phone 类 public class Phone implements Soundable { @Override public void playSound() { System.out.println("手机发出来电铃声：叮当 叮当"); } @Override public void lower() { System.out.println("以降低手机音量"); } @Override public void stop() { System.out.println("已关闭手机"); } } Radio 类 public class Radio implements Soundable { @Override public void playSound() { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31c53b32e4061a65ea0362cecb50a73e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/558779b264e6e47a60055723cd152df1/" rel="bookmark">
			【老生谈算法】基于matlab的运动目标识别与跟踪系统设计与算法原理及程序源码——目标识别算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于matlab的运动目标识别与跟踪系统设计与算法原理 大家好，今天给大家介绍基于matlab的运动目标的监测与跟踪系统设计与原理。
视频图像分析主要是对运动图像序列进行分析处理，它通常涉及到运动检测、目标分类、目标跟踪及行为理解与描述几个过程。其中，运动目标检测与跟踪处于整个视觉监视系统的最底层，是视频图像分析中最基本的方法，是各种后续高级处理如目标分类、行为理解等的基础。
文章目录：
基于matlab的运动目标识别与跟踪系统设计与算法原理1、项目简介2、难度指数3、运行环境：4、项目详解：5、源码下载： 1、项目简介 对所要求的场景提出了一种检测运动物体,跟踪运动物体的方法。用背景差分得到运动人体的区域, 通过卡尔曼滤波对人体进行跟踪，并给出实例
目前，对运动物体的检测和运动参数测量的研究方法主要有人工神经网络方法和图像处理方法。本文研究运用图像处理的方法进行运动物体的检测。该方法大体上可以分为四类:基于帧间差分的方法、基于背景差分的方法、基于特征的方法和基于光流场的方法。
一个运动物体跟踪系统的基本过程如下：
1.在图像序列中检测出运动物体及运动区域
2.对检测到的运动物体提取特征建立目标匹配模板
3.计算目标的形心
4.预测目标在下一时刻可能运动到的位置，确定目标在下一时刻的搜索范围
5.在预测的搜索范围内，用前一时刻的模板进行匹配搜索，寻找最佳匹配位置，当在预测范围内未找到目标时需进行例外处理。
2、难度指数 本项目难度：中等难度
适用场景：相关题目的毕业设计及相关领域的应用研究
3、运行环境： 环境配置：
本项目所使用的MATLAB版本为MATLAB 7.8.0（R2016a）
注：可适配绝大部分matlab版本
项目技术：
轮廓提取算法+ 图像分割算法 +背景差分算法+图像预处理+卡尔曼滤波算法+运动跟踪+物体检测识别等等
4、项目详解： 提示：以下为项目的详细介绍，项目源码及项目设计文档下载地址见文末。
4.1运动物体的检测方法
运动目标的检测是一个重要、困难的研究课题，它除了能将运动分量和背景分量分割开，还能用检测出的运动块为以后的识别、分类以及行为分析提供感兴趣的区域。从分割的角度来看，运动物体检测被认为是视频对象的空间域分割。具体说来是指把序列图像中独立运动的区域逐帧检测分割出来。换言之，所谓运动物体检测，就是当场景中有新物体进入或者场景中有物体移动时，通过检测算法得知有物体出现，而分割则是把进入场景的物体从背景图像中分割出来。
4.1.1运动物体的常用检测方法
运动物体检测通常采用差分图像的方法。
差分图像一般有两种情况:
1.当前图像与固定背景图像之间的差分，通常称为背景差分;
2.当前连续两幅图像之间的差分，通常称为帧间差分。
本项目采用背景差分的方法以获取运动物体。过程如下：
基于背景差分的方法是目前运动分割中最常用的一种方法，它是利用当前图像与背景图像的差分来检测运动区域的一种技术。该方法一般能够提供完全的特征数据，但对于动态场景的变化，如光照和外来无关事件的干扰等特别敏感。
4.1.2灰度图像的背景提取
运动目标检测和跟踪可以不直接使用原始彩色图像序列，而使用灰度图像序列，即将彩色视频图像序列转换成灰度图像序列，然后在灰度图像序列上提取背景。
彩色图像转换成灰度图像：
彩色图像每个像素点在RGB空间中是一个三维矢量，每个分量分别代表红、绿、蓝三种颜色的灰度。最简单的将彩色图像转换成灰度图像的方法是将这三个分量取平均值。但是这种方法和人眼视觉感知不符。人眼感知红、绿、蓝三种颜色的权重是不一样的。JPEG图像压缩格式采用的是YUV空间，YUV空间是RGB空间的线性变换。转换公式是：
R、G、B分别表示红、绿、蓝三种颜色分量的灰度值。Y分量表示图像的亮度，这是符合人眼对颜色感知的。我们就以Y分量作为图像像素的灰度。将彩色像素转换为灰度像素的公式为
GRAY=0.299R+0.587G+0.114B
将彩色图像转换为灰度图像的算法如下:
遍历彩色图像的每一个像素矢量，设矢量的红、绿、蓝三色分量值为R、G、B，则
输出的灰度图像的对应像素的值为0.299R+0.587G十0.114B
运动检测的目的是在图像序列中将前景运动区域从背景图像中提取出来。运动检测是运动物体分类、跟踪和行为理解的基础，该阶段处理结果的质量直接影响到以后处理的效果，所以运动检测在人体运动分析中的作用非常重要。然而，由于背景图像的动态变化，如天气、光照、影子及混乱干扰等的影响，使得运动检测成为一项相当困难的工作。
本项目中进行对象检测所使用的是背景相减(baekgroundsubtraetion)的方法，是目前运动分割中最常用的一种方法，它是利用当前图像与背景图像的差分来检测运动区域的一种技术，其主要工作过程如图所示:首先利用公式计算背景图像与当前图像的差，然后对差分图像进行二值化，并对二值化后的图像进行连通性分析，当某一连通区域的面积(像素数)大于一定的阈值，则认为检测到目标出现，并且认为这个连通的区域就为提取出的目标图像。
基于背景相减的运动检测算法流程图：
该方法一般能够提供最完全的特征数据，但对于动态场景的变化，如光照和外来无关事件的干扰等特别敏感。最简单的背景模型是时间平均图像，大部分研究人员目前都致力于开发不同的背景模型，以期减少动态场景变化对于动态分割的影响。
例如：Haritaoglu等利用最小、最大强度值和最大时间差分值为场景中每个像素进行统计建模，并且进行周期性的背景更新;
McKenna等利用像素色彩和梯度信息相结合的自适应背景模型来解决影子和不可靠色彩线索对于分割的影响;
Karmann与Brandt、Kilger采用基于卡尔曼滤波(Kalmanfiltering)的自适应背景模型以适应天气和光照的时间变化;
Stauffer与Grimson利用自适应的混合高斯背景模型(即对每个像素利用混合高斯分布建模)，并且利用在线估计来更新模型，从而可靠地处理了光照变化、背景混乱运动的干扰等的影响。
此外还有以下其他方法：
时间差分方法(temporal difference)。时间差分是在连续的图像序列中两个或三个相邻帧之间采用基于像素的时间差分并且阈值化来提取图像中的运动区域，其基本过程如图所示。首先，利用公式计算第k帧图像与第k一1帧图像之间的差别，得到差分后的图像，然后对差分后的图像进行二值化，当差分图像中某一像素值大于某一给定的阈值时，则认为该像素为前景像素，反之则认为是背景像素。在对差分图像二值化后得到，最后对进行连通性分析，当某一连通的区域的面积大于某一给定的阈值，则检测到目标，并认为该区域就为目标所占的区域。
基于时间差分的检测算法流程图：
光流法(optiealflow)：基于光流方法的运动检测采用了运动目标随时间变化的光流特性。如Meyer等通过计算位移向量光流场来初始化基于轮廓的跟踪算法，从而有效地提取和跟踪运动目标，该方法的优点是在摄像机运动存在的前提下也能检测出独立的运动目标。然而，大多数的光流计算方法相当复杂，且抗噪性能差，如果没有特别的硬件装置则不能被应用于全帧视频流的实时处理。
由于时间差分在运动实体内部容易产生空洞现象，并且很难精确地得到运动物体的轮廓信息;而光流方法时间开销比较大，且抗噪性能较差，在复杂背景下也不适用;背景相减是利用当前图像与背景图像的差分来检测速度快，并能够提供最完整的运动区域信息，缺点是对背景中的干扰比较敏感。
4.1.3目标形心坐标的计算
背景差分后图像已获得了运动目标的分割图，并将此图像进行了二值化处理，令目标区域像素灰度值为255，其它区域为0。要想获得运动物体的运动轨迹，或要预测运动物体在下一帧图像中的位置，必须计算出运动物体的形心坐标。
4.2运动物体跟踪
4.2.1跟踪简介
序列图像中进行目标跟踪是计算机视觉、图像处理和模式识别领域里非常活跃的课题。所谓运动目标跟踪，就是在一段序列图像中的每幅图像中找到感兴趣的运动目标所处的位置。简单来说就是在下一帧图像中找到运动物体的确切位置。因为周围的环境是动态的，某一时刻所拍摄的图像和另一时刻的图像是不同的，因而视觉系统的一个初步任务在于将图像特征从一幅图像到另一幅图像匹配起来。这个过程就称为图像特征的跟踪（token tracking）。
在视频监视中运动目标跟踪的作用非常重要，因为它不但可以提供被监视目标的运动轨迹，也为进行场景中运动目标的运动分析和场景分析提供了可靠的数据来源，同时运动目标的跟踪信息也反过来为运动目标的正确检测以及运动目标的识别提供了帮助。
如果将所有图像重叠起来（即在图像坐标系下考虑问题），我们可以将第一幅图像的每个特征和后继图像中匹配的特征连接起来，这样对每个图像特征就得到一条轨迹（trajectory）。因此，我们也可将“跟踪”重新定义为图像特征轨迹的估计。根据这个定义，特征跟踪可以认为是参数估计的一个特例。我们将会看到，参数估计理论确实构成了特征跟踪的基础。但是，特征跟踪所涉及的范围要比参数估计宽的多，例如统计决策理论（statistic decision theory）在特征跟踪中也起着很重要的作用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/558779b264e6e47a60055723cd152df1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/094d36db421eb53449380c4865ff82ec/" rel="bookmark">
			CDH6.3.1 集群离线部署（若泽大数据）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[ 若泽大数据 ] CDH6.3.1 企业集群离线部署
一、准备工作 离线部署主要分为三块： MySQL离线部署CM离线部署Parcel⽂件离线源部署 支持的版本：Cloudera Enterprise 6 要求和支持的版本|6.x |Cloudera Documentation
CDH 部署时，系统默认自带的 Python 不要更改，若需要其他版本，进行 Python 多版本控制，Centos 7.x — Python2.7，Centos 6.x — Python 2.6。
不使用官方默认的 postgresql，建议使用 MySQL 5.7。
MySQL 离线部署：
mysql-5.7.11-linux-glibc2.5-x86_64.tar.gz
CM：
cm6.3.1-redhat7.tar.gz
Parcel：
CDH-6.3.1-1.cdh6.3.1.p0.1470567-el7.parcel
CDH-6.3.1-1.cdh6.3.1.p0.1470567-el7.parcel.sha1
manifest.json
环境准备：
jdk-8u45-linux-x64.gz
mysql-connector-java-5.1.47.jar
二、集群节点初始化 1、服务器 1 台，虚拟机 2 台 CentOS 7.9 操作系统，虚拟机 4 核 20 G（内存尽量 &gt; 8 G）
# 查看 IP 地址 [root@node04 ~]# ip addr # 查看网关 [root@node04 ~]# route -n Kernel IP routing table Destination Gateway Genmask Flags Metric Ref Use Iface 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/094d36db421eb53449380c4865ff82ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccbb3ea8ab6749616b39767e9cb36de5/" rel="bookmark">
			win10关闭防火墙脚本.bat
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@echo off
%1 mshta vbscript:CreateObject("Shell.Application").ShellExecute("cmd.exe","/c %~s0 ::","","runas",1)(window.close)&amp;&amp;exit
cd /d "%~dp0"
echo 关闭防火墙
NetSh Advfirewall set allprofiles state off echo 防火墙状态
Netsh Advfirewall show allprofiles pause
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d996ea19f66babe72141f55f83a57d5/" rel="bookmark">
			Spark概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spark概述
1.1. 什么是Spark（官网：http://spark.apache.org）
Spark是一种快速、通用、可扩展的大数据分析引擎，2009年诞生于加州大学伯克利分校AMPLab，2010年开源，2013年6月成为Apache孵化项目，2014年2月成为Apache顶级项目。目前，Spark生态系统已经发展成为一个包含多个子项目的集合，其中包含SparkSQL、Spark Streaming、GraphX、MLlib等子项目，Spark是基于内存计算的大数据并行计算框架。Spark基于内存计算，提高了在大数据环境下数据处理的实时性，同时保证了高容错性和高可伸缩性，允许用户将Spark部署在大量廉价硬件之上，形成集群。Spark得到了众多大数据公司的支持，这些公司包括Hortonworks、IBM、Intel、Cloudera、MapR、Pivotal、百度、阿里、腾讯、京东、携程、优酷土豆。当前百度的Spark已应用于凤巢、大搜索、直达号、百度大数据等业务；阿里利用GraphX构建了大规模的图计算和图挖掘系统，实现了很多生产系统的推荐算法；腾讯Spark集群达到8000台的规模，是当前已知的世界上最大的Spark集群。
1.2. 为什么要学Spark
中间结果输出：基于MapReduce的计算引擎通常会将中间结果输出到磁盘上，进行存储和容错。出于任务管道承接的，考虑，当一些查询翻译到MapReduce任务时，往往会产生多个Stage，而这些串联的Stage又依赖于底层文件系统（如HDFS）来存储每一个Stage的输出结果
Hadoop Spark
Spark是MapReduce的替代方案，而且兼容HDFS、Hive，可融入Hadoop的生态系统，以弥补MapReduce的不足。
1.3. Spark特点
1.3.1. 快
与Hadoop的MapReduce相比，Spark基于内存的运算要快100倍以上，基于硬盘的运算也要快10倍以上。Spark实现了高效的DAG执行引擎，可以通过基于内存来高效处理数据流。
1.3.2. 易用
Spark支持Java、Python和Scala的API，还支持超过80种高级算法，使用户可以快速构建不同的应用。而且Spark支持交互式的Python和Scala的shell，可以非常方便地在这些shell中使用Spark集群来验证解决问题的方法。
1.3.3. 通用
Spark提供了统一的解决方案。Spark可以用于批处理、交互式查询（Spark SQL）、实时流处理（Spark Streaming）、机器学习（Spark MLlib）和图计算（GraphX）。这些不同类型的处理都可以在同一个应用中无缝使用。Spark统一的解决方案非常具有吸引力，毕竟任何公司都想用统一的平台去处理遇到的问题，减少开发和维护的人力成本和部署平台的物力成本。
1.3.4. 兼容性
Spark可以非常方便地与其他的开源产品进行融合。比如，Spark可以使用Hadoop的YARN和Apache Mesos作为它的资源管理和调度器，器，并且可以处理所有Hadoop支持的数据，包括HDFS、HBase和Cassandra等。这对于已经部署Hadoop集群的用户特别重要，因为不需要做任何数据迁移就可以使用Spark的强大处理能力。Spark也可以不依赖于第三方的资源管理和调度器，它实现了Standalone作为其内置的资源管理和调度框架，这样进一步降低了Spark的使用门槛，使得所有人都可以非常容易地部署和使用Spark。此外，Spark还提供了在EC2上部署Standalone的Spark集群的工具。
2. Spark集群安装
2.1. 安装
2.1.1. 机器部署
准备两台以上Linux服务器，安装好JDK1.7
2.1.2. 下载Spark安装包
http://www.apache.org/dyn/closer.lua/spark/spark-1.5.2/spark-1.5.2-bin-hadoop2.6.tgz
上传解压安装包
上传spark-1.5.2-bin-hadoop2.6.tgz安装包到Linux上
解压安装包到指定位置
tar -zxvf spark-1.5.2-bin-hadoop2.6.tgz -C /usr/local
2.1.3. 配置Spark
进入到Spark安装目录
cd /usr/local/spark-1.5.2-bin-hadoop2.6
进入conf目录并重命名并修改spark-env.sh.template文件
cd conf/
mv spark-env.sh.template spark-env.sh
vi spark-env.sh
在该配置文件中添加如下配置
export JAVA_HOME=/usr/java/jdk1.7.0_45
export SPARK_MASTER_IP=node1.itcast.cn
export SPARK_MASTER_PORT=7077
保存退出
重命名并修改slaves.template文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d996ea19f66babe72141f55f83a57d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1d1ab2ddad0b31ef5e405d5f449492a/" rel="bookmark">
			Spark计算模型-RDD
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是RDD RDD（Resilient Distributed Dataset）叫做分布式数据集，是Spark中最基本的数据抽象，它代表一个不可变、可分区、里面的元素可并行计算的集合。RDD具有数据流模型的特点：自动容错、位置感知性调度和可伸缩性。RDD允许用户在执行多个查询时显式地将工作集缓存在内存中，后续的查询能够重用工作集，这极大地提升了查询速度。
RDD的属性 一组分片（Partition），即数据集的基本组成单位。对于RDD来说，每个分片都会被一个计算任务处理，并决定并行计算的粒度。用户可以在创建RDD时指定RDD的分片个数，如果没有指定，那么就会采用默认值。默认值就是程序所分配到的CPU Core的数目。 一个计算每个分区的函数。Spark中RDD的计算是以分片为单位的，每个RDD都会实现compute函数以达到这个目的。compute函数会对迭代器进行复合，不需要保存每次计算的结果。 RDD之间的依赖关系。RDD的每次转换都会生成一个新的RDD，所以RDD之间就会形成类似于流水线一样的前后依赖关系。在部分分区数据丢失时，Spark可以通过这个依赖关系重新计算丢失的分区数据，而不是对RDD的所有分区进行重新计算。 一个Partitioner，即RDD的分片函数。当前Spark中实现了两种类型的分片函数，一个是基于哈希的HashPartitioner，另外一个是基于范围的RangePartitioner。只有对于于key-value的RDD，才会有Partitioner，非key-value的RDD的Parititioner的值是None。Partitioner函数不但决定了RDD本身的分片数量，也决定了parent RDD Shuffle输出时的分片数量。 一个列表，存储存取每个Partition的优先位置（preferred location）。对于一个HDFS文件来说，这个列表保存的就是每个Partition所在的块的位置。按照“移动数据不如移动计算”的理念，Spark在进行任务调度的时候，会尽可能地将计算任务分配到其所要处理数据块的存储位置。 创建RDD 由一个已经存在的Scala集合创建。 val rdd1 = sc.parallelize(Array(1,2,3,4,5,6,7,8))
由外部存储系统的数据集创建，包括本地的文件系统，还有所有Hadoop支持的数据集，比如HDFS、Cassandra、HBase等 val rdd2 = sc.textFile("hdfs://node1.itcast.cn:9000/words.txt")
RDD编程API Transformation RDD中的所有转换都是延迟加载的，也就是说，它们并不会直接计算结果。相反的，它们只是记住这些应用到基础数据集（例如一个文件）上的转换动作。只有当发生一个要求返回结果给Driver的动作时，这些转换才会真正运行。这种设计让Spark更加有效率地运行。
常用的Transformation：
转换
含义
map(func)
返回一个新的RDD，该RDD由每一个输入元素经过func函数转换后组成
filter(func)
返回一个新的RDD，该RDD由经过func函数计算后返回值为true的输入元素组成
flatMap(func)
类似于map，但是每一个输入元素可以被映射为0或多个输出元素（所以func应该返回一个序列，而不是单一元素）
mapPartitions(func)
类似于map，但独立地在RDD的每一个分片上运行，因此在类型为T的RDD上运行时，func的函数类型必须是Iterator[T] =&gt; Iterator[U]
mapPartitionsWithIndex(func)
类似于mapPartitions，但func带有一个整数参数表示分片的索引值，因此在类型为T的RDD上运行时，func的函数类型必须是
(Int, Interator[T]) =&gt; Iterator[U]
sample(withReplacement, fraction, seed)
根据fraction指定的比例对数据进行采样，可以选择是否使用随机数进行替换，seed用于指定随机数生成器种子
union(otherDataset)
对源RDD和参数RDD求并集后返回一个新的RDD
intersection(otherDataset)
对源RDD和参数RDD求交集后返回一个新的RDD
distinct([numTasks]))
对源RDD进行去重后返回一个新的RDD
groupByKey([numTasks]) 在一个(K,V)的RDD上调用，返回一个(K, Iterator[V])的RDD
reduceByKey(func, [numTasks])
在一个(K,V)的RDD上调用，返回一个(K,V)的RDD，使用指定的reduce函数，将相同key的值聚合到一起，与groupByKey类似，reduce任务的个数可以通过第二个可选的参数来设置
aggregateByKey(zeroValue)(seqOp, combOp, [numTasks])
sortByKey([ascending], [numTasks])
在一个(K,V)的RDD上调用，K必须实现Ordered接口，返回一个按照key进行排序的(K,V)的RDD
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1d1ab2ddad0b31ef5e405d5f449492a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/378fd464f7e573a4d1e0d6abe3fde9a2/" rel="bookmark">
			堆与栈的内存开辟、高地址与低地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机内存分了代码段（.text段）、初始化的数据段（.data段）、未初始化的数据段（.bss段）、堆空间（heap）、栈空间（stack）和命令行参数和环境变量区域。
程序计数器(Program Counter，简称PC)的缺省指向0地址，计算机开机后从程序计数器指向的地址开始执行程序，每执行完一条指令后， 程序计数器自动加1。
因此很自然的，代码段从低地址区间开始加载，向高地址区间扩展；
heap从低地址向高地址扩展，做内存管理相对要简单些，为了避免栈空间和代码段冲突，最大利用地址空间，很自然的**，我们会选择把栈底设置在高地址区间，然后让栈向下增长。**
把栈作为单独参照物来看如下图：
1.此时是栈区开辟空间示意图，注意现在是栈的单独示意图，所以最底是高地址，最上是低地址。x86采取小端存储模式，IP指针存放a的地址,00高位存放在高地址0X00AFFBB7上.
2.为什么一个存储单元存放了两个十六进制位？
之所以ip指针00AFFBB4地址存放的是两个十六进制位，是因为，在32位计算机系统中，一个指针占4字节，也就是32个二进制位，四个二进制位存放一个十六进制来计算，一共能存放8个十六进制数，也就说**，一个存储单元存放两个十六进制位。**可以用程序来理解是否如此：
int main() { short big = 0xff00; char litter = big; if (litter == 0xff) { cout &lt;&lt; "大端" &lt;&lt; endl; } else { cout &lt;&lt; "小端" &lt;&lt; endl; } return 0; } ———————————————— &gt;短整型转char 型丢失一字节，最后结果要不是0xff就是0x00,这个程序也验证是大端还是小端 C程序原文链接：https://blog.csdn.net/weixin_43886592/article/details/106336154 我们再用一个程序验证栈的开辟与高低地址之间的关系和冗余空间：
第一个地址和第二个地址相差为： a变量两侧其中一侧的冗余量（4字节）+c两侧其中一侧的冗余量（4字节）+变量a本身所占大小8字节=16字节。
第二、三地址之间相差为： 3776+自身的34+两侧冗余42=20；
栈作为单独参照的简图（属于逻辑图，下面的C程序内存分布图示物理表示图）：
这是来自apue里一张经典的ｃ程序内存分布图，着重看一下heap和stack的内存分布。
stack从高地址向低地址扩展，这样栈空间的起始位置就能确定下来。动态的调整栈空间大小也不需要移动栈内的数据，如果是从低地址到高地址的扩展，结尾的地址是固定的，如果要扩大或缩小，则需要移动整个栈的数据。
并且**这样设计可以使得堆和栈能够充分利用空闲的地址空间。**如果栈向上涨的话，我们就必须得指定栈和堆的一个严格分界线，但这个分界线怎么确定呢？平均分？但是有的程序使用的堆空间比较多，而有的程序使用的栈空间比较多。
所以就可能出现这种情况：一个程序因为栈溢出而崩溃的时候，其实它还有大量闲置的堆空间呢，但是我们却无法使用这些闲置的堆空间。所以呢，最好的办法就是让堆和栈一个向上涨，一个向下涨，这样它们就可以最大程度地共用这块剩余的地址空间，达到利用率的最大化。
————————————————
参考原文链接：https://blog.csdn.net/Albert52856/article/details/119836153
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47fde7d619d7c1c4de141baf45d30361/" rel="bookmark">
			JavaScript递归详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是递归？ 一个方法或函数内部调用了自己，这就叫递归。如下。
&lt;script&gt; function fn(n){ if(n == 0) return fn(n - 1); } fn(3); &lt;/script&gt; 递归设计（递归三要素） 1.找重复（子问题）
-找到更小规模的子问题
-如上代码，（n-1）是原问题的重复（规模更小）—— 子问题
2.找重复中的变化量➡参数
-变化的量应该作为参数
-如上代码，变化的量为n
3.找参数变化趋势➡设计出口
-找到递归的边界（出口）
-如上代码，n越来越小，当n等于0时，结束递归
递归三要素缺一不可，不然就会导致栈溢出
栈溢出：
1.没有使问题规模更小
function fn(n){ if(n == 0) return fn(n); } fn(3) 2.没有用变化的量作为参数
function fn(n){ if(n == 0) return fn(2); } fn(3) 3.递归没有边界
function fn(n){ fn(n-1); } fn(3) 切蛋糕思维 1.求n的阶乘
/* 1.找重复：n * (n - 1)的阶乘，求(n - 1)的阶乘就是原问题的重复——子问题 2.找变化：n 3.找边界：出口，n = 1 */ function fn(n){ if(n == 1) return 1 return n * fn(n - 1); } console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47fde7d619d7c1c4de141baf45d30361/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/243078a2773bdbdd63346baf4bd2163a/" rel="bookmark">
			华清远见嵌入式学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C高级笔记 符号含义 1、hqyj@ubuntu:~$
hqyj：用户名@：分隔ubuntu：主机名‘：’：分隔~：文件路径---&gt; ~：家目录 /：根目录$:分隔 2、文件类型及标识符
d：目录文件c：字符设备b：块设备block-：普通文件p：管道文件s：套接字文件l：链接文件 3、权限及标识符
r：读权限
w：写
x：可执行
-：无该权限
4、根目录下的目录文件说明：
bin：二进制文件目录mnt：挂载文件目录root：超级用户文件目录usr：用户文件目录etc：配置文件目录dev：设备文件目录boot：启动文件目录proc：进程文件目录 5、常用指令
ls：列出指定路径下的文件
-l：列出文件的详细信息
-a：列出所有文件包含隐藏文件
cd：路径跳转 绝对路径：从根目录出发的路径 相对路径：从当前路径出发的路径
mkdir：创建目录文件
6、vi编辑器：
命令行模式
dd：剪切光标所在行
n+dd：剪切光标后n行
p：粘贴 yy：复制光标所在行
n+yy：复制n行
u：撤销
ZZ：保存并退出 v---&gt;进入可视模式
gg=G：全文自动缩进
插入模式
i：光标前开始插入
a：光标后开始插入
o：光标下一行开始插入
底行模式
w：保存
q：退出
wq：保存并退出
x：保存并退出
set nu：设置行号
set mouse=a：使能鼠标
vsp + 文件名：横向展开另一个文件
sp + 文件名：纵向展开
7、文件操作
mv：移动文件到指定目录，或者重命名
ls：列出文件信息
cp：复制文件
mkdir：创建目录文件
touch：创建文件，修改文件的时间戳
cat：在终端显示文件内容，查看文件
head：默认查看文件的前十行
head -num filename：查看文件开头num行
tail：默认查看文件后十行
rm：删除文件，删除目录文件需要添加-r选项
rmdir：删除空目录文件
wc：统计字符数
-c ：字节数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/243078a2773bdbdd63346baf4bd2163a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89d45658e8b0b12aea4f2214234ed5d3/" rel="bookmark">
			数据压缩实验四--DPCM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据压缩实验四--DPCM 实验原理DPCM编解码原理PSNR计算压缩质量 实验代码DPCM.cppmain.cppDPCM.h 实验步骤实验图片的准备命令参数图像质量比较8比特量化4比特，2比特，1比特量化 Huffman熵编码比较编码效率原始图像与预测误差概率分布 实验原理 DPCM编解码原理 DPCM为差分预测编码。在DPCM系统中，预测器的输入是已经解码以后的样本。在解码端无法得到原始样本，只能得到存在误差的样本，因此不用原始样本来做预测。在DPCM编码器中实际内嵌了一个解码器，如编码器中虚线框中所示。
在一个DPCM系统中，有两个因素需要设计：预测器和量化器。理想情况下，预测器和量化器应进行联合优化。实际中，采用一种次优的设计方法：分别进行线性预测器和量化器的优化设计。
在本次实验中，我们采用固定预测器和均匀量化器。预测器采用左侧预测。量化器采用8比特均匀量化，以及4比特，2比特，1比特均匀量化。对原始图像和预测误差分别进行熵编码，验证DPCM编码的编码效率。
PSNR计算压缩质量 psnr是“Peak Signal to Noise Ratio”的缩写，即峰值信噪比，是一种评价图像的客观标准。它是原图像与被处理图像之间的均方误差相对于(2n-1)2的对数值(信号最大值的平方，n是每个采样值的比特数)，它的单位是dB。PSNR值越大，就代表失真越少。
其中，MSE是原图像（语音）与处理图像（语音）之间均方误差。
实验代码 DPCM.cpp #include&lt;stdlib.h&gt; #include&lt;stdio.h&gt; #include&lt;math.h&gt; void DPCM(unsigned char* y_buffer, unsigned char* differ_buffer, unsigned char* rebuild_buffer,int width, int height,int bitnum) { for (int i = 0; i &lt; height; i++) { for (int j = 0; j &lt; width; j++) { if (j == 0) { differ_buffer[i * width] = ((y_buffer[i * width] - 128)+255)/pow(2,(double)(9-bitnum)); rebuild_buffer[i * width] = differ_buffer[i * width] * pow(2, (double)(9 - bitnum)) - 255 + 128; } else { differ_buffer[i * width+j] = ((y_buffer[i * width+j] - rebuild_buffer[i * width+j-1]) + 255) / pow(2, (double)(9 - bitnum)); rebuild_buffer[i * width + j] = differ_buffer[i * width+j] * pow(2, (double)(9 - bitnum)) - 255 + rebuild_buffer[i * width + j-1]; } if (differ_buffer[i * width + j] &gt; 255) differ_buffer[i * width + j] = 255; if(differ_buffer[i * width + j] &lt;0) differ_buffer[i * width + j] = 0; if (rebuild_buffer[i * width + j] &gt; 255) rebuild_buffer[i * width + j] = 255; if (rebuild_buffer[i * width + j] &lt; 0) rebuild_buffer[i * width + j] = 0; } } } main.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89d45658e8b0b12aea4f2214234ed5d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1f30cc5e6b4ed6355258718c8be0d5b/" rel="bookmark">
			vue启动报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue启动报错npm ERR! Found: vue@2.6.10 解决方案：降低npm版本
npm install -g npm @ version
npm ERR! code ERESOLVE
npm ERR! ERESOLVE unable to resolve dependency tree
npm ERR!
npm ERR! While resolving: rzhy@3.0.0
npm ERR! Found: vue@2.6.10
npm ERR! node_modules/vue
npm ERR! vue@“2.6.10” from the root project
npm ERR!
npm ERR! Could not resolve dependency:
npm ERR! peer vue@“^3.0.0” from @tinymce/tinymce-vue@4.0.7
npm ERR! node_modules/@tinymce/tinymce-vue
npm ERR! @tinymce/tinymce-vue@“^4.0.5” from the root project
npm ERR!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1f30cc5e6b4ed6355258718c8be0d5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94c518848ba00de867a474d316107a72/" rel="bookmark">
			SpringBoot视图技术4：使用Thymeleaf完成数据的页面展示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Thymeleaf完成数据的页面展示 概括一、步骤截图1. 创建SpringBoot项目，引入Thymeleaf依赖2. 配置Thymeleaf模板的参数3. Controller层(Web控制层)4. 创建模板页面并引入静态资源文件4.1 使用BootStrap中提供的组件进行开发4.1.1 引入CSS和JS到项目中4.1.2 使用组件库中提供的html进行开发 二、测试结果三、整体代码目录结构1. 配置Thymeleaf模板的参数2. Html文件3. Controller层：请求处理类 概括 Thymeleaf是一种用于Web和独立环境的现代服务器端的Java模板引擎。
本文主要介绍：如何使用Thymeleaf在html页面上显示动态数据，也介绍了如何使用BootStrap文档中现成的HTML、CSS、JS进行前端开发
一、步骤截图 1. 创建SpringBoot项目，引入Thymeleaf依赖 Web场景依赖和Thymeleaf场景依赖
//thymeleaf场景依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; 2. 配置Thymeleaf模板的参数 # THYMELEAF (ThymeleafAutoConfiguration) # 开启模板缓存（默认值： true ）=&gt; 修改：开发中关闭模板页面缓存 spring.thymeleaf.cache=false # 模板编码 spring.thymeleaf.encoding=UTF-8 # 要运⽤于模板之上的模板模式。另⻅ StandardTemplate-ModeHandlers( 默认值： HTML5) spring.thymeleaf.mode=HTML5 # 在构建 URL 时添加到视图名称前的前缀（默认值： classpath:/templates/ ） spring.thymeleaf.prefix=classpath:/templates/ # 在构建 URL 时添加到视图名称后的后缀（默认值： .html ） spring.thymeleaf.suffix=.html 3. Controller层(Web控制层) Controller层请求处理类：接收请求，跳转页面
突然想到访问的顺序
浏览器 Controller层 Service层 DAO层 实体类数据库 4. 创建模板页面并引入静态资源文件 写完配置文件，先写静态html文件(html+css+js)，然后写Controller类(访问路径，携带参数，跳转页面)，然后再在html中加入动态数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94c518848ba00de867a474d316107a72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81fbbc89bc16f28d5014f6522cb0fee2/" rel="bookmark">
			中国大学MOOC 程序设计入门——C语言 翁凯 编程测试题汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第1周编程练习： 输出“Hello World”（5分）
题目内容：
请输出一行，内容为
Hello World
请注意大小写。
由于这一周只是简单地介绍了C程序的基本框架，还不能做很多事情，甚至还不能做数据的输入，所以这一周的题目也非常简单。
第二周会仔细介绍如何在中M和拼题A做题，如果你一时无法搞定如何提交这周的作业，没关系，可以先在在线编程环境或IDE中做好程序，下周学过之后再来提交作业。我们所有的作业的截止时间都是到2018年12月31号晚上。所以，你可以慢慢来，一点点能跟上来就可以了。
输入格式:无输入
输出格式:一行文字
输入样例：无
输出样例：Hello World
解答：
#include &lt;stdio.h&gt; int main() { printf("Hello World\n"); return 0; } 第2周编程练习： 1.逆序的三位数（5分）
题目内容：
逆序的三位数：
程序每次读入一个正三位数，然后输出逆序的数字。注意，当输入的数字含有结尾的0时，输出不应带有前导的0。比如输入700，输出应该是7。提示：用%10可以得到个位数，用/100可以得到百位数...。将这样得到的三个数字合起来：百位*100+十位*10+个位，就得到了结果。注意：除了题目要求的输出，不能输出任何其他内容，比如输入时的提示，输出时的说明等等都不能。这道题目要求输出逆序的数字，程序就只能输出这个数字，除此之外任何内容都不能输出。
输入格式:每个测试是一个3位的正整数。
输出格式：输出逆序的数。
输入样例：123
输出样例：321
#include&lt;stdio.h&gt; int main(int argc,const char*argv[]) { int a,b1,b2,b3; scanf("%d",&amp;a); b1=a%10*100; b2=a/10%10*10; b3=a/100; printf("%d\n",b1+b2+b3); return 0; } 第3周编程练习 1.时间换算（5分）
题目内容：UTC是世界协调时，BJT是北京时间，UTC时间相当于BJT减去8。现在，你的程序要读入一个整数，表示BJT的时和分。整数的个位和十位表示分，百位和千位表示小时。如果小时小于10，则没有千位部分；如果小时是0，则没有百位部分；如果小时不是0而分小于10分，需要保留十位上的0；如果小时是0而分小于10分的，则不需要保留十位上的0。如1124表示11点24分，而905表示9点5分，36表示0点36分，7表示0点7分。
有效的输入范围是0到2359，即你的程序不可能从测试服务器读到0到2359以外的输入数据。
你的程序要输出这个时间对应的UTC时间，输出的格式和输入的相同，即输出一个整数，表示UTC的时和分。整数的个位和十位表示分，百位和千位表示小时。如果小时小于10，则没有千位部分；如果小时是0，则没有百位部分；如果小时不是0而分小于10分，需要保留十位上的0；如果小时是0而分小于10分的，则不需要保留十位上的0。
提醒：要小心跨日的换算。
输入格式:一个整数，表示BJT的时和分。整数的个位和十位表示分，百位和千位表示小时。如果小时小于10，则没有千位部分；如果小时是0，则没有百位部分；如果小时不是0而分小于10分，需要保留十位上的0；如果小时是0而分小于10分的，则不需要保留十位上的0。
输出格式：一个整数，表示UTC的时和分。整数的个位和十位表示分，百位和千位表示小时。如果小时小于10，则没有千位部分；如果小时是0，则没有百位部分；如果小时不是0而分小于10分，需要保留十位上的0；如果小时是0而分小于10分的，则不需要保留十位上的0。
输入样例：803
输出样例：3
#include&lt;stdio.h&gt; int main() { int bjt,utc; int h,m; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81fbbc89bc16f28d5014f6522cb0fee2/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/154/">«</a>
	<span class="pagination__item pagination__item--current">155/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/156/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>