<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b1317c13b9049e895db41c5f2ed3b79/" rel="bookmark">
			R语言|数据结构(四) 数据框 ———R语言入门到入土系列(五)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		R语言数据结构——数据框 数据框的创建data.frame()函数创建由矩阵转数据框 数据框增加添加新的一列添加新的一行 数据框的删除行的删除列的删除 数据框的查找指定行的查找指定列的查找which()函数的使用 数据框的修改总结 数据框作为数据分析中常用的数据结构，其优势在于他可以存储多种数据形式，并不会局限于单独某一种数据形式。对应的处理方法也就对应的多一些，本文将从数据框的增删查改四个方面去简述数据框的处理。 数据框的创建 data.frame()函数创建 data.frame()是数据框在R语言里的标识方式，也是用于创建数据框的常用形式。
data.frame(…, row.names = NULL, check.rows = FALSE,
check.names = TRUE, fix.empty.names = TRUE,
stringsAsFactors = default.stringsAsFactors())
参数解释：
参数解释…需要创建的数据row.names数据框的行名，通常为一个向量check.rows检查row.names的长度与数据框的行数是否相同stringAsFactors对字符串的处理，TRUE时，将字符串改为因子类型， FALSE时，不改变字符串的类型 ID &lt;- c(101,102,103,104,105,106) name &lt;- c('Tom','Bob','Tim','王二','张三','李四') math_score &lt;- c(88,70,65,77,64,80) data_1 &lt;- data.frame(ID,name,score,stringsAsFactors = F) ##查看数据形式 sapply(data_1, class) # "numeric" "character" "numeric" 由矩阵转数据框 首先得有矩阵，然后利用as.data.frame()函数将矩阵转化为数据框。
x_1 &lt;- seq(1:12) x_2 &lt;- matrix(x_1,nrow = 3,ncol = 4,byrow = T) data_1 &lt;- as.data.frame(x_2) 数据框增加 添加新的一列 新添加一个列名，然后赋值语句添加一个向量即可。或者可以列的角标进行添加赋值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b1317c13b9049e895db41c5f2ed3b79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09783854f5627acb560c8de922c10423/" rel="bookmark">
			Android串口使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、环境介绍
二、设备介绍
二、方法一:
1.引入库 2.编写代码
三、方法二:
1.引入库 2.编写代码
四、完整代码:
五、源码:
前言 串口是一种用于android对硬件设备通信的一种协议，可以发送某种指令控制硬件设备,也可以接受传感器发送过来的数据，比如IC/ID卡，雷达，传感器等。下面介绍串口在android开发中的2使用方式
一、环境介绍 Android 系统版本:Android 7.1 Android 12 Android Studio Electric Eel | 2022.1.1
jdk-18.0.2
PC Windows11 串口调试工具sscom(或者其他串口调试工具也可以)
二、设备介绍 二、方法一: 使用ARMT自带的串口api SerialPort.java
1.引入库 在build.gradle 的dependencies中添加jar包
//ARMT SDK
implementation files('libs/armtsdkapi.jar')
2.编写代码 2.1初始化串口 initSerialPort("/dev/ttyS4"); /** * 初始化串口 * * @param path 串口路径 */ private void initSerialPort(String path) { try { uart3 = new SerialPort(path, 9600, 8, "n", 1); } catch (IOException e) { e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09783854f5627acb560c8de922c10423/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29ed53c1538a38c2d002d09750e89774/" rel="bookmark">
			vscode pont 模板使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装 安装插件 vscode
创建项目
PS E:\Code\Vues&gt; mkdir apricot-pont 1、创建目录
全局安装pont-engine
$ npm i -g pont-engine 1、安装 pont-engine
二、使用 配置模板
$ pont start 1、配置模板
安装依赖
$ npm i -D pont-engine 1、安装依赖
文件生成
$ pont check 1、生成文件
目录结构
三、自定义模板 参数地址/api/apricot/{id}
import { Interface, BaseClass, Property, CodeGenerator, Surrounding } from 'pont-engine'; export default class MyGenerator extends CodeGenerator { getInterfaceContentInDeclaration(inter: Interface) { const requestParams = inter.getRequestParams(); const paramsCode = inter.getParamsCode('Params'); //自定义参数 let params = `params:${JSON.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29ed53c1538a38c2d002d09750e89774/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1ec51cb7982a6711d66dbfc2200273c/" rel="bookmark">
			怎么在线调整图片像素和大小？一分钟学会图片尺寸修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在从社交媒体到网站设计，再到印刷品等多种用途，有时候您可能进行图片尺寸修改（https://www.yasuotu.com/size）以适应特定的需求，本文将介绍怎么在线调整图片大小，帮助您轻松地修改图片大小尺寸。
浏览器搜索“压缩图”，进入压缩图网站后工具栏中选择【图片改大小】功能。
点击选择图片，在左侧工具栏中输入我们想要的图片宽、高(输入其中任意数值，系统自动修改图片尺寸)，最后保存图片即可。
效果图展示：
以上就是关于怎么在线调整图片像素和大小的全部内容了，除了图片改大小之外，我们还可以图片压缩来缩小图片kb，都可以在压缩图网站中操作完成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d01dc3b18a1f698c83cc782dc84b92c8/" rel="bookmark">
			Linux 下判断一个字符串ip是否合法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、inet_pton函数简介二、使用例子三、其他例子3.1 python3.2 c++11 前言 要判断一个IP地址是否合法，可以使用C语言标准库中的inet_pton()函数。
inet_pton() 函数是一个标准的C库函数，用于将一个IPv4或IPv6地址的字符串表示转换为网络字节序的二进制值。
inet_pton()函数可以根据传入的地址族（Address Family）参数，将一个字符串表示的IP地址转换为相应的二进制形式。如果转换成功，函数返回1，则表示该字符串ip地址合法。
一、inet_pton函数简介 NAME inet_pton - convert IPv4 and IPv6 addresses from text to binary form SYNOPSIS #include &lt;arpa/inet.h&gt; int inet_pton(int af, const char *src, void *dst); 此函数将字符串src转换为af地址族中的网络地址结构，然后将网络地址结构复制到dst。af参数必须是AF_INET（IPv4）或AF_INET6（IPv6）。
当前支持以下地址族：
（1）AF_INET
src指向一个字符串，该字符串包含十进制点格式的IPv4网络地址“ddd.ddd.ddd.ddd”，其中ddd是0到255范围内最多三位的十进制数。地址被转换为 struct in_addr 并复制到dst，dst的大小必须为（struct in_addr）（4）字节（32位）长。
/* Internet address. */ typedef uint32_t in_addr_t; struct in_addr { in_addr_t s_addr; }; （2）AF_INET6
src指向一个包含IPv6网络地址的字符串。地址被转换为 struct in6_addr 并复制到dst，dst的大小必须为（struct in6_addr）（16）字节（128位）长。
/* IPv6 address */ struct in6_addr { union { uint8_t	__u6_addr8[16]; uint16_t __u6_addr16[8]; uint32_t __u6_addr32[4]; } __in6_u; #define s6_addr	__in6_u.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d01dc3b18a1f698c83cc782dc84b92c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b62e1068d67bedbd042d98328f546d4/" rel="bookmark">
			【centos】【Redis】【systemd】Redis进程守护
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Centos7中将redis服务写入systemctl
CentOS 7.x开始,CentOS开始使用systemd服务来代替daemon,比起原来的service和config两套命令，systemd整合了service和config的功能。Systemctl是一个systemd工具，主要负责控制systemd系统和服务管理器。先安装一下redis，我这里是redis-6.2.3版本，不多说命令如下：
下载安装redis. $ cd /usr/local/redis
$ wget https://download.redis.io/releases/redis-6.2.3.tar.gz
$ tar xzf redis-6.2.3.tar.gz
$ cd redis-6.2.3
$ make
安装完成之后添加快捷方式进/usr/bin中以方便后期使用redis-cli。 $ cd /usr/local/redis
$ mkdir etc
$ cp redis-6.2.3/redis.conf etc/
$ ln -s /usr/local/redis/redis-6.2.3/src/redis-server /usr/bin/redis-server
$ ln -s /usr/local/redis/redis-6.2.3/src/redis-cli /usr/bin/redis-cli
这时redis就可以通过 redis-server /usr/local/redis/etc/redis.conf启动了。然后我们开始将其写入systemd中。进入/usr/lib/systemd/system/目录中，创建redis.service文件，.service文件定义一个服务，分为[Unit]，[Service]，[Install]三个部分，需要更改的就基本只有ExecStart这一行，即是你本机的redis启动命令。另外PIDFile保持和redis配置文件中一样。
$ cd /usr/lib/systemd/system/
$ vim redis.service
[Unit] Description=Redis #描述内容 #在哪些服务启动之后启动 After=syslog.target network.target remote-fs.target nss-lookup.target [Service] Type=forking #PIDFile和redis.conf配置中一致 PIDFile=/var/run/redis_6379.pid ExecStart=/usr/local/redis/redis-6.2.3/src/redis-server /usr/local/redis/etc/redis.conf #重新加载和停止服务的命令 ExecReload=/bin/kill -s HUP $MAINPID ExecStop=/bin/kill -s QUIT $MAINPID PrivateTmp=true #系统以默认多用户方式启动时，此服务自动运行。 [Install] #Alias:服务别名 WantedBy=multi-user.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b62e1068d67bedbd042d98328f546d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/668a81b8a02af1d0f1f93c190eb40fb6/" rel="bookmark">
			mixly温度传感器、声音光线传感器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
温度传感器
温度到达一定度数报警
声音、光线传感器
智能楼道灯 温度传感器
用来获取实际温度值（℃）
温度到达一定度数报警 当仓库的温度到达一定度数时，就亮红灯并发出警报。
声音、光线传感器 智能楼道灯 功能 1.判断光线和声音； 2.在光线较暗且有声音，灯自动亮起。
步骤
从“串口”目录下拖出“打印（自动换行）”模块，并复制一次，再从“板载传感”目录下分别拖出“获取光线传感器的值”和获取“声音传感器的值”两个模块，与串口打印相连接，这样我们上传之后就能在串口监视器中看到传感器的值，并依据这些值来编写下面的程序。
判断周围光线程度和声音大小。从“逻辑”模块分类中拖出“…=…”模块并调整为“…&lt;…”；左边添加“获取光线传感器的值”；右边从“数学”模块分类中拖出“0”模块，调整为“xxx”；同样步骤设置声音判断条件。
控制两个条件同时满足。从“逻辑”模块分类中拖出“…且…”模块，将光线和声音控制条件放在左右两侧。
点亮RGB灯。拖出“RGB灯”模块，将数值调整为某个值，利用“延时”模块让RGB灯亮5秒，随后调整RGB灯的数值为“0,0,0”，让灯熄灭。（不要忘记设置RGB灯模式） 将判断条件和点亮RGB灯部分代码，与“如果…执行…”模块拼接在一起。
最后在程序的最下方加上短暂的延时，在最外侧添加“当满足条件真…重复执行…”模块，让程序循环执行。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84c4446cd41d2991a4ac30d539518965/" rel="bookmark">
			mixly红外传感器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 入室警报器 我们可以利用红外接近传感器来检测是否有物体靠近，再设置一个报警的声音，进而就可以实现入室报警器的功能 。
测试传感器。从“板载传感”模块分类中拖出“获取红外接近传感器数值”模块，并依次连接串口打印模块（“串口”模块分类中拖出“打印自动换行”模块）。这样我们上传之后就能在串口监视器中看到传感器的值，并依据这些值来编写下面的程序。
通过计数 通过左右两个红外线收集数据，来计算从板子左侧移到右侧物体的个数，并实时在显示屏上显示出来。
测左侧快速移到右侧的时间 试试测一下你的手指从板子左侧快速移到右侧的时间，并在屏幕上展示出来 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b163975e30421e9b865201eb1fde3365/" rel="bookmark">
			通过vscode开发调试ApolloAuto---来自chatgpt回复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要在 VS Code 中开发和调试 Apollo Auto 代码，您需要执行以下步骤：
安装 VS Code 首先，您需要安装 Visual Studio Code。您可以从官方网站 https://code.visualstudio.com/ 下载安装程序并安装它。
安装 C++ 扩展 在 VS Code 中打开扩展选项卡，搜索 C++ 扩展并安装它。这将为您提供编写 C++ 代码所需的工具和语言支持。
安装 Apollo Auto 您需要安装 Apollo Auto 以便在本地计算机上编写和调试 Apollo Auto 代码。请遵循官方文档 https://github.com/ApolloAuto/apollo/blob/master/docs/quickstart/apollo_software_installation_guide.md 中的指南。
在 VS Code 中打开项目 使用 VS Code 打开 Apollo Auto 项目目录，例如：
cd /path/to/apollo code . 这将在 VS Code 中打开 Apollo Auto 项目目录。
配置编译和调试器 在 VS Code 中，按 F1 键打开命令面板，然后搜索和选择“C++：编辑配置”命令。这将在 .vscode 目录中创建一个 launch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b163975e30421e9b865201eb1fde3365/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85b25a16b3a336eadea65f695b5ab7f1/" rel="bookmark">
			flutter版本升级时遇到的问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		flutter多版本切换 注：无需修改环境变量，也不用重启AndroidStudio
mac具体flutter版本切换操作步骤： 1、项目clean然后切换自己需要的分支
2、删除文件夹flutter目录文件（这里的flutter是原来的符号连接）
3、ln -s flutter3.7.7 flutter （在指定目录下执行该命令会生成新的符号连接）
4、flutter doctor -v （看看版本是否对应）
5、pub get 然后运行项目即可
使用符号连接进行切换，配置符号连接参考：如何在Mac上创建和使用符号链接（也称为符号链接）
参考链接：https://blog.csdn.net/qq_33220645/article/details/127012269
注：旧项目谨慎删除pubspec-lock文件 Flutter项目升级flutter 一个项目代码全部是用flutter写的，在升级flutter之前，项目时可以正常运行的，升级以后惨了，跑不起来了了。解决方案如下：
1. 删除项目中.idea文件夹
2. 删除项目中的build文件夹
3. 删除项目中的pubspec-lock文件
4. 执行命令flutter clean
5. 执行命令flutter pub get
原生项目集成flutter插件升级flutter 原生项目集成flutter这个解决起来要更麻烦些， 大体思路分成两步
第一步：让flutter插件所在的runner.workspace先成功运行，第二步：原生项目所在的workspace能够执行。
第一步需要进行的操作：
1，删除项目中.idea文件夹
2，删除项目中的build文件夹
3，删除项目中的pubspec-lock文件
4，flutter clean 执行下
5，flutter pub upgrade 执行下
6，检查podfile中，以及project中最低版本号是否是大于等于11.0
7，执行pod deintegrate
8，执行 pod install
9，运行一下runner.workspace如果能够成功运行则第一步已经成功了
第二步：
1，删除pods文件件
2，删除pod.lock文件
3，检查podfile中，以及project中最低版本号是否是大于等于11.0
4，执行pod deintegrate
5，执行 pod install
6，运行原生项目对应的workspace，如果可运行成功，flutter升级的问题就完美解决了。
Flutter工程代码管理 pubspec.yaml、.pubcache 与 pubspec.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85b25a16b3a336eadea65f695b5ab7f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66538808687769a028e316bd8ddcb7fb/" rel="bookmark">
			QT 网络编程之主机信息查询（QHostInfo 和 QNetworkInterface类）简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qt 网络模块提供了用于编写 TCP/IP 客户端和服务器端程序的各种类，如用于 TCP 通信的QTcpSocket 和 QTcpServer，用于 UDP 通信的 QUdpSocket，还有用于实现 HTTP、FTP 等普通网络协议的高级类如 QNetworkRequest，QNetworkReply 和QNetworkAccessManager。Qt 网络模块还提供用于网络代理、网络承载管理的类，提供基于安全套接字层(Secure Sockets Layer，SSL)协议的安全网络通信的类。
要在程序中使用 Qt 网络模块，需要在项目配置文件中增加一条配置语句:
Qt += network
1、QHostInfo 和 QNetworkInterface 类
查询一个主机的MAC地址或IP 地址是网络应用程序中经常用到的功能,Qt提供了QHostInfo和QNetworkInterface 类可以用于此类信息的查询。
QHostInfo 的静态函数 localHostName()可获取本机的主机名，静态函数 fromName()可以通过主机名获取IP 地址，静态函数 lookupHost()可以通过一个主机名，以异步方式查找这个主机的IP地址。下表是QHostInfo 类主要的功能函数(省略了函数中的const 关键字)。
类别
函数原型
作用
公共函数
QList&lt;QHostAddress&gt; addresses()
HostInfoError error()
QString errorString()
QString hostName()
int lookupld()
返回与 hostname()主机关联的IP 地址列表
如果主机查找失败，返回失败类型
如果主机查找失败，返回错误描述字符串
返回通过 IP查找的主机的名称
返回本次查找的ID
静态函数
void abortHostLookup(int id)
QHostInfo fromName(QString &amp;name)
QString localDomainName()
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66538808687769a028e316bd8ddcb7fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d84365256503e53338833cd81654a8cc/" rel="bookmark">
			TCP协议详解 (史上最全)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载：(116条消息) TCP协议详解 (史上最全)_40岁资深老架构师尼恩的博客-CSDN博客
TCP/IP协议包含了一系列的协议，也叫TCP/IP协议族（TCP/IP Protocol Suite，或TCP/IP
Protocols），简称TCP/IP。TCP/IP协议族提供了点对点的连结机制，并且将传输数据帧的封装、寻址、传输、路由以及接收方式，都予以标准化
TCP/IP协议的分层模型 在展开介绍TCP/IP协议之前，首先介绍一下七层ISO模型。国际标准化组织ISO为了使网络应用更为普及，推出了OSI参考模型，即开放式系统互联（Open
System Interconnect）模型，
一般都叫OSI参考模型。OSI参考模型是ISO组织在1985年发布的网络互连模型，其含义就是为所有公司使用一个统一的规范来控制网络，这样所有公司遵循相同的通信规范，网络就能互联互通了。
OSI模型的七层框架 OSI模型定义了网络互连的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层、应用层），每一层实现各自的功能和协议，并完成与相邻层的接口通信。OSI模型各层的通信协议，大致举例如下表所示：
表：OSI模型各层的通信协议举例
TCP/IP协议是Internet互联网最基本的协议，其在一定程度上参考了七层ISO模型。OSI模型共有七层，从下到上分别是物理层、数据链路层、网络层、运输层、会话层、表示层和应用层。但是这显然是有些复杂的，所以在TCP/IP协议中，七层被简化为了四个层次。TCP/IP模型中的各种协议，依其功能不同，被分别归属到这四层之中，常被视为是简化过后的七层OSI模型。
TCP/IP协议与七层ISO模型的对应关系 TCP/IP协议与七层ISO模型的对应关系，大致如下图所示：
图：TCP/IP协议与七层ISO模型的对应关系
TCP/IP协议的应用层的主要协议有HTTP、Telnet、FTP、SMTP等，是用来读取来自传输层的数据或者将数据传输写入传输层；传输层的主要协议有UDP、TCP，实现端对端的数据传输；网络层的主要协议有ICMP、IP、IGMP，主要负责网络中数据包的传送等；链路层有时也称作数据链路层或网络接口层，主要协议有ARP、RARP，
通常包括操作系统中的设备驱动程序和计算机中对应的网络接口卡，它们一起处理与传输媒介（如电缆或其他物理设备）的物理接口细节。
（一）TCP/IP协议的应用层
应用层包括所有和应用程序协同工作，并利用基础网络交换应用程序的业务数据的协议。一些特定的程序被认为运行在这个层上，该层协议所提供的服务能直接支持用户应用。应用层协议包括HTTP（万维网服务）、FTP（文件传输）、SMTP（电子邮件）、SSH（安全远程登陆）、DNS（域名解析）以及许多其他协议。
（二）TCP/IP协议的传输层
传输层的协议，解决了诸如端到端可靠性问题，能确保数据可靠的到达目的地，甚至能保证数据按照正确的顺序到达目的地。传输层的主要功能大致如下：
（1）为端到端连接提供传输服务；
（2）这种传输服务分为可靠和不可靠的，其中TCP是典型的可靠传输，而UDP则是不可靠传输；
（3）为端到端连接提供流量控制、差错控制、QoS(Quality of
Service)服务质量等管理服务。
传输层主要有两个性质不同的协议：TCP传输控制协议和UDP用户数据报协议。
TCP协议是一个面向连接的、可靠的传输协议，它提供一种可靠的字节流，能保证数据完整、无损并且按顺序到达。TCP尽量连续不断地测试网络的负载并且控制发送数据的速度以避免网络过载。另外，TCP试图将数据按照规定的顺序发送。
UDP协议是一个无连接的数据报协议，是一个“尽力传递”和“不可靠”协议，不会对数据包是否已经到达目的地进行检查，并且不保证数据包按顺序到达。
总体来说，TCP协议传输效率低，但可靠性强；UDP协议传输效率高，但可靠性略低，适用于传输可靠性要求不高、体量小的数据（比如QQ聊天数据）。
三）TCP/IP协议的网络层
TCP/IP协议网络层的作用是在复杂的网络环境中为要发送的数据报找到一个合适的路径进行传输。简单来说，网络层负责将数据传输到目标地址，目标地址可以是多个网络通过路由器连接而成的某一个地址。另外，网络层负责寻找合适的路径到达对方计算机，并把数据帧传送给对方，网络层还可以实现拥塞控制、网际互连等功能。网络层协议的代表包括：ICMP、IP、IGMP等。
（四）TCP/IP协议的链路层
链路层有时也称作数据链路层或网络接口层，用来处理连接网络的硬件部分。该层既包括操作系统硬件的设备驱动、NIC（网卡）、光纤等物理可见部分，还包括连接器等一切传输媒介。在这一层，数据的传输单位为比特。其主要协议有ARP、RARP等。
图解 物理层：使用MAC解决设备的身份证问题 通信的原始时代 很久很久之前，你不与任何其他电脑相连接，孤苦伶仃。
直到有一天，你希望与另一台电脑 B 建立通信，于是你们各开了一个网口，用一根网线连接了起来。
用一根网线连接起来怎么就能"通信"了呢？我可以给你讲 IO、讲中断、讲缓冲区，但这不是研究网络时该关心的问题。
如果你纠结，要么去研究一下操作系统是如何处理网络 IO 的，要么去研究一下包是如何被网卡转换成电信号发送出去的，要么就仅仅把它当做电脑里有个小人在开枪吧~
反正，你们就是连起来了，并且可以通信。
有一天，一个新伙伴 C 加入了，但聪明的你们很快发现，可以每个人开两个网口，用一共三根网线，彼此相连。
随着越来越多的人加入，你发现身上开的网口实在太多了，而且网线密密麻麻，混乱不堪。（而实际上一台电脑根本开不了这么多网口，所以这种连线只在理论上可行，所以连不上的我就用红色虚线表示了，就是这么严谨哈哈~）
集线器的诞生
于是你们发明了一个中间设备，你们将网线都插到这个设备上，由这个设备做转发，就可以彼此之间通信了，本质上和原来一样，只不过网口的数量和网线的数量减少了，不再那么混乱。
你给它取名叫集线器，它仅仅是无脑将电信号转发到所有出口（广播），不做任何处理，你觉得它是没有智商的，因此把人家定性在了物理层。
由于转发到了所有出口，那 BCDE 四台机器怎么知道数据包是不是发给自己的呢？
首先，你要给所有的连接到交换机的设备，都起个名字。原来你们叫 ABCD，但现在需要一个更专业的，全局唯一的名字作为标识，你把这个更高端的名字称为 MAC 地址。
你的 MAC 地址是 aa-aa-aa-aa-aa-aa，你的伙伴 b 的 MAC 地址是 bb-bb-bb-bb-bb-bb，以此类推，不重复就好。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d84365256503e53338833cd81654a8cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa40a558a37a0ee95b2b4c1784b34ca3/" rel="bookmark">
			将列表拼接到server对象的表格中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 将列表拼接到server对象的表格中。列表不能直接拼接到server表格中，可以先转换为一个表格，然后拼接两个表格。
过程 准备数组：a=[1,2,3]
将列表转换为server表格
a=pandas.DataFrame(a,columns=[‘a’])将转换出来的表格拼接到目标表格中
test_y=pandas.concat([test_y,y_pre],axis=1)
注意：在拼接的时候两个表格索引最好是一样的，不然拼接出来就只有索引相同的行 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be75fed57c8167dc91113d0bd6a6aa7e/" rel="bookmark">
			STM32：GPIO配置和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、GPIO简介
1.1 GPIO的输入输出模式
1.1.1 输入模式
1.1.2 输出模式
二、GPIO的使用
2.1 引脚初始化
2.2 引脚使用
注：型号：STM32F407ZET6
一、GPIO简介 GPIO：通用输入输出接口
STM32上有A~H共8组，其中A~G7组每组有0~15号共16个引脚，H组有两个引脚。
1.1 GPIO的输入输出模式 1.1.1 输入模式 1. 上拉输入
上拉电阻：信号线通过电阻连接高电平，信号的初始值是高电平。
2. 下拉输入
下拉电阻：信号线通过电阻连接低电平，信号的初始值为低电平。
3. 浮空输入
浮空：信号线不连接高低电平，信号电压不确定。
5. 模拟输入
1.1.2 输出模式 1. 开漏输出（上拉或下拉）
2. 复用开漏输出（上拉或下拉）
3. 推挽输出（上拉或下拉）
4. 复用推挽输出（上拉或下拉）
二、GPIO的使用 2.1 引脚初始化 初始化步骤：
1. 初始化一个GPIO配置结构体
头文件（定义位置）：#include "stm32f4xx_gpio.h"
2. 使能时钟总线
头文件：#include "stm32f4xx_rcc.h"
原型：void RCC_AHB1PeriphClockCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState);
参数：
- RCC_AHB1Periph 外围设备，可选项在定义的注释中 - NewState 时钟新状态，ENABLE、DISABLE
3. 配置这个GPIO配置结构体
- GPIO_Pin 初始化的引脚号 可选项：GPIO_Pin_0~GPIO_Pin_15，GPIO_Pin_All
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be75fed57c8167dc91113d0bd6a6aa7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75a9edafba188a65d9d09879b66cc8cf/" rel="bookmark">
			python PyQt5的安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 简介 PyQt5 是 Digia的一套 Qt5 应用框架与 python 的结合，同时支持 python2.x和 python3.x。
这里使用的是Python 3.x。Qt库由 Riverbank Computing开发，是最强大的GUI库之一 。
PyQt5 是由一系列 Python 模块组成。超过 620 个类，6000 函数和方法。能在诸如 Unix、Windows 和Mac OS 等主流操作系统上运行。PyQt5 有两种证书，GPL和 商业证书。
PyQt5 的官网链接如下：
http://www.riverbankcomputing.co.uk/news。 当然也可以在 Python 这里查看教程。
https://pythonspot.com/pyqt5/ 2. window 平台安装 2.1 安装 PyQt5 PyQt5 有两种安装方式，一种是从官网下载源码安装，另外一种是使用 pip 安装。
这里我推荐大家使用pip 安装。因为它会自动根据你的Python 版本来选择合适的 PyQt5 版本，如果是手动下载源码安装，难免会选择出错。建议使用比较稳妥的安装方式。
pip3 install PyQt5 另外，如果你的网络访问外网不是很好的话建议使用豆瓣的镜像下载，不然会很很慢或者直接安装失败。
pip install PyQt5 -i https://pypi.douban.com/simple 2.2 安装 PyQt5-tools PyQt5 不再提供常用Qt工具，比如图形界面开发工具Qt Designer、国际化翻译工具Liguist 如果开发中使用到这些，必须自行安装Qt工具。
这里我们还是采用脚本安装的方式。
pip install PyQt5-tools 或者使用镜像下载：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75a9edafba188a65d9d09879b66cc8cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94a1b462a02335a62cbfee4714bf5a72/" rel="bookmark">
			激光SLAM学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习第一步： 先看完了 《视觉SLAM14讲》的内容，安装Ubuntu系统，学习Linux语法。按照14讲 的内容安装库，学习知识点，运行代码。(研一上学期寒假前结束的，研一上学期课程较多，看的慢一些)
一、Ubuntu系统安装： 1. 安装虚拟机 可以看古月居安装虚拟机的过程。
镜像下载地址：https://ubuntu.com/download/desktop
打开地址进入Ubuntu下载的界面，下载的是Ubuntu 18.04版本，LTS表示是一个长期支持版，一般是5年的时间。点击“Download” 按钮进行下载，下载 .iso 文件
2. 安装 Ubuntu系统 网上找操作教程
二、Ubuntu软件下载： (1) 打开Ubuntu软件(图标带有一个A字母)，类似于手机里面的软件商店。
(2) 点击左上角 “ Ubuntu 软件 ” ，来进行 配置系统的软件源，点击 "软件和更新 "
从右边的窗口 配置 软件源，从什么地方下载，自动选择下载的服务器(选择aliyun，，或者 .edu后缀的源)，，下载源的选择会影响后面下载文件的速度，比如ROS安装
选定软件源之后，点击关闭，会出现下面的界面：
之后点击 ---&gt;重新载入 , 连接设置的 aliyun 服务器
加载成功之后点击关闭 退出即可。 三、Ubuntu 的一些操作 打开终端界面：Ctrl + Alt + T
命令行：
(1) 查看当前打开文件的路径：pwd
(2) 切换路径： cd (文件名) 进入下一级文件
cd .. 进入上一级文件目录
cd 回到主目录
(3) 当前路径下创建新的文件夹： mkdir 文件夹名字 例如： mkdir build
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94a1b462a02335a62cbfee4714bf5a72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b216aae2110dc92de7017aff9525c39d/" rel="bookmark">
			跟ChatGPT聊聊Scratch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Scratch适合多大的孩子学习? 学习scratch有什么用? scratch是最好的少儿编程软件吗? scratch学起来会不会很难? scratch只能用来开发小游戏吗? scratch能帮助孩子考学吗? scratch对生活和工作有帮助吗? scratch与python或java 是一个层次的东西吗? scratch能赚钱吗? scratch3.17.1 和 scratch3.29.1 版本之间的差别大吗? 学习scratch的建议 先学习基础：首先要学习Scratch的基础概念和编程知识，包括角色、舞台、事件、运动、控制、感知、音频、绘画等。可以通过官方文档、教程、视频等方式学习。
练习实践：在学习基础知识的同时，建议尝试自己动手制作一些简单的项目，例如动画、游戏、故事等，这样可以更好地巩固所学知识。
学习其他作品：可以学习其他人的Scratch作品，了解他们的思路和方法，从中学习和借鉴，进一步提高自己的技能。
使用Scratch教学资源：Scratch提供了丰富的教学资源，包括教程、课程、教材、指南等，可以利用这些资源提高自己的技能和教学水平。
尝试其他编程语言：当熟练掌握了Scratch之后，可以尝试学习其他编程语言，例如Python、Java、c#等，这些编程语言具有更广泛的应用和更强大的功能。
程序猿与投资生活实录已改名为 程序猿知秋，WX 公众号同款，欢迎关注！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f5d435b7473e8ce14d8b8bda826530b/" rel="bookmark">
			ppt必备的10个宝藏网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		做ppt必备的10个宝藏网站：
1.ppt超级市场
http://ppt.sotary.com
2.优品ppt
http://www.ypppt.com
3.阿里巴巴矢量图标库
https://www.iconfont.cn
4.colorhunt
https://colorhunt.co
5.officeconverter 格式转换
https://cn.office-converter.com
6.pexels免费图片下载
https://www.pexels.com
7.求字体
https://www.qiuziti.co
8.echarts 图表丰富
echarts.apache.org
9.高德开放平台 适合商业分析类，可数据化模板
https://lbs.amap.com
10.islide （插件）许多ppt辅助工具，模板，配色方案
https://www.islide.cc
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cc8264ea113bd0fd024f883cc5e4ad3/" rel="bookmark">
			(linux卸载nvidia驱动)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.先查看驱动以及版本安装情况，命令如下：
ls /usr/src | grep nvidia 2.进入安装目录
cd /usr/bin ls nvidia-* 3.卸载命令卸载
sudo apt-get remove --purge nvidia-* 4.然后用上面的查看命令查看是否卸载干净，完成卸载
ls /usr/src | grep nvidia
没有东西出现即卸载成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47103db579ba33ae364beb599f6be4e0/" rel="bookmark">
			caught (in promise) TypeError: Cannot read properties of undefined (reading ‘init‘)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错caught (in promise) TypeError: Cannot read properties of undefined (reading ‘init’) 解决方案：init报错
查看package.json文件中echarts版本，如果是5.0以上的版本请卸载安装指定版本4.2.1，然后就不会报错了
转自：https://blog.csdn.net/qq_45223074/article/details/112860423
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/765f8d2dfdd72a31f1db251ec88e39e1/" rel="bookmark">
			Javascript 同步/异步编程知识点整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.何为同步/异步编程?
程序是一条条有序的语句集，如果运行时，按照语句的顺序，一条一条依次执行，上一条语句执行完毕，才能执行下一条语句，那么就是同步编程。异步编程则是，可能出现上一条语句没执行完毕，下一条语句可以开设执行。
同步可以理解为程序语句的顺序和执行顺序是一致的，异步则可能出现语句的顺序与执行的完成顺序不一致（语句开始执行的时间顺序和程序语句顺序还是一致的）。
2、异步的目的是？
异步可以提高执行效率。如果程序中的某一条语句需要等待网络请求的数据，那么等该条语句执行完毕，再执行下一条语句，会降低程序的执行效率（大量时间在等待）。
3.JavaScript Promise的理解
Js 提供了 Promise对象来简化异步编程。假如某个程序，有一条语句需要访问远程服务器的数据，如果同步编程方式，需要等远程数据返回，才能执行下一条语句。
用Promise对象来访问远程服务器，实现异步操作。同步编程时，访问远程服务器的语句将阻塞，一直等到数据返回。异步编程时，将需要等待的语句放到一个函数中，并以该函数作为参数，创建一个承若对象（Promise），该对象访问服务器，在服务器成功返回数据或失败时，会调用回调函数来分别处理。因此创建Promise时，要传入两个回调函数作为参数。 prm= new Promise(function（resolve,reject）{ if(...){ resolve("success");//成功,调用回调函数resolve }else{ reject("failure");//失败，调用回调函数reject } }); prm.then(success).catch(reject) //success,reject分别为成功和失败时的处理函数（实参） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3e131864a4f6939bf8b51a0ffb14cfe/" rel="bookmark">
			Qt - 从零到壹的 打地鼠 游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		❤️‍🔥欢迎收看西北风的blog，好男人就是我，我就是西北风。✨
Gitee 地址 W_A_Mole · NTC_jason/cc语言 - 码云 - 开源中国 (gitee.com)
目录
🟥一：创建一个主窗体
🟣二.：添加主窗口背景图片以及相关部件 🔸2.1 添加资源文件
2.1.1 添加资源文件
2.1.2 在项目中添加资源文件
🔸 2.2 为 窗口 添加背景图
2.2.1打开 mainwindow.ui
🔸 2.3 为窗口添加开始按钮
🔵三:增加游戏界面
🔹3.1 新建窗口 更名为game
🔹3.2将主窗口与game窗口联动。
🔹3.3添加背景图片
🔹3.4 添加 地鼠 按钮。
🔹3.5为 地鼠 添加 定时器
🔹3.6 改变鼠标样式，增加简单锤子。
🔴四：完善，增加,退出游戏,简易分数,简易难度 🔺4.1 退出游戏按钮
🔺4.2分数
🔺4.3简易难度
​🔺4.4 鼠标在普通按钮上变回普通样式
🟥一：创建一个主窗体 下一步即可。名字自选
🟣二.：添加主窗口背景图片以及相关部件 🔸2.1 添加资源文件 2.1.1 添加资源文件 在项目文件夹下新建文件夹，用于存放资源文件
在资源文件npg内，添加图片。图源网络，可自行更改。
2.1.2 在项目中添加资源文件 新建一个Qt 下的资源文件
下一步，名称自选。下一步添加到之前创建的项目下。
完成会出现右图资源文件 对qrc文件 右键 找到 open in editor
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3e131864a4f6939bf8b51a0ffb14cfe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c98dfc1700f6debe7e181170245972ef/" rel="bookmark">
			B-SOiD visualisation interface with full error reporting
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		B-SOiD V2.0 web browser first running step
Error：IndexError: list index out of range
IndexError: list index out of range Traceback: File "/home/user/anaconda3/envs/bsoid_v2/lib/python3.8/site-packages/streamlit/script_runner.py", line 332, in _run_script exec(code, module.__dict__) File "/home/user/B-SOID/bsoid_app.py", line 42, in &lt;module&gt; processor.compile_data() File "/home/user/B-SOID/bsoid_app/data_preprocess.py", line 88, in compile_data file0_df = pd.read_csv(data_files[0], low_memory=False) Problem Analysis:
At first I found the answer in the community: (taken from the community answer)
"This is a bug/misfeature that we worked on correcting in later versions of Streamlit since it was confusing to people.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c98dfc1700f6debe7e181170245972ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8066ff2f0e27b101c541af097774ed5/" rel="bookmark">
			输出倒金字塔
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天遇见一个很有趣的题：
这里我们遵循化繁为简，先死后活的思路
先做正三角
int main() { //空格 //i表示层数 int n = 3; /*int n = 0; scanf_s("%d", &amp;n);*/ for (int i = 0; i &lt;n; i++) { for (int j= 0; j &lt; n-i-1; j++) { printf(" "); } for (int k = 0; k &lt;= i; k++) { printf("* "); } //打印完一层*就换行 printf("\n"); } } 然后我们用scanf将它复杂化
int main() { //空格 //i表示层数 //int n = 3; int n; scanf_s("%d", &amp;n); for (int i = 0; i &lt;n; i++) { for (int j= 0; j &lt; n-i-1; j++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8066ff2f0e27b101c541af097774ed5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef189ac4989fbc0c46e4b289c6cf0b10/" rel="bookmark">
			【Linux中文设置】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Linux中文设置 查看当前语言安装语言包 查看当前语言 使用 locale 命令查看当前系统语言,LANG为当前系统语言，我这里已经改过所以已经是zh_CN.UTF-8
linux@ubuntu:~$ locale; 安装语言包 1.下载语言包
linux@ubuntu:~$ sudo locale-gen; 2.配置
linux@ubuntu:~$ sudo dpkg-reconfigure locales; 进入配置界面，找到en_US.UTF-8,空格取消选中，找到zh_CN.UTF-8,空格选中，选中后会显示[ * ]，回车确定
光标选中zh_CN.UTF-8,回车确定
系统重启
linux@ubuntu:~$ reboot; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36280f48025ead1ac01ab4f3b84ef98d/" rel="bookmark">
			百度搜索视频标题的进阶指南说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家都知道，视频标题是吸引用户前来观看的关键。上节课带大家学习了视频标题的基础要求，接下来带大家一起来学习优质视频标题的进阶指南吧！
视频的标题在满足规则的基础上可以从以下3个方面对标题进行优化：趣味性、引导性、时效性。
一标题的趣味性
为标题增加一定的趣味性，可以让你的视频内容在众多视频内容中，更加吸引用户的关注。
我们可以在标题内容上增加一些形容词或语气词作为标题的一个润色，来达到具有一定趣味性的效果。
正面案例：一些具象的形容词加持，会让你标题看起来新颖生动且有趣，会很大程度上提升用户想要点击的兴趣
负面案例：虽然标题也精准表达了视频内容，但是仅简单的表达陈述，整体吸引力较低
二适量的引导性
在标题中增加一些适当的引导词，会引起用户的好奇心。
一般来说可以通过改变句式来达成引导性的目的。比如：将简单的陈述句改为疑问句或感叹句的形式，可以很大程度上带有一些引导性。
注意在做适量引导的过程也需要保证对视频内容的高度总结和精准产出，标题纯引导但对内容没有表述会适得其反，且这类引导不可过于直观、夸张的展现，否则会极大降低用户的观看体验。
正面案例：善用疑问句式，在精准表达自己的视频内容后，来问你觉得什么更好用？稍加的引导会极大程度增加用户好奇心
负面案例：简单的陈述句式，虽然能感知有一定的引导性，但对于内容没有精准表达很大程度上用户是无法感知的内容，适得其反
网站SEO
三符合热点的时效性
近期的网络热点、热梗、热词一直以来都是用户关注度极高的内容，此类标题会很容易吸引用户的关注。
当创作者产出的视频内容具有一定的时效性或与相关热点具有联系性，我们可以在标题上适当融入一些时效性的热词、热梗或热点，这样会很大程度上刺激到用户的兴趣点，从而吸引用户点击视频内容进行观看。
正面案例：是近日热点，标题的时效性和直观感对内容的直观表达，让此条内容一经发布快速进入热榜
反面案例：此条内容虽也为近日热点，但在标题上没有注明他是谁，整体热度没有进入热榜
总的来说，一个好的视频标题生产首先要保证对视频内容的高度精准概括，保持标题与视频内容的一致性，文字表达正确，字数适中且表述真实，传递正向价值。
其次在满足上述基础后可以适当增加标题的趣味性、引导性、时效性，这样的标题就是非常优质的标题啦~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ccf6a1566667463b59b9cdc7207644b/" rel="bookmark">
			百度事实视频封面基础设计要点说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		封面是最直观能让用户感知视频内容好坏的方式，那一个好的封面设计应该具备哪些条件呢？接下来带大家了解一下好的封面所应该具备的基础设计要点。
一封面的清晰度
1►
画面高清
封面切记不可模糊，无法辨别人物或仅能辨别大致主体的封面都是不合规的，我们需要保证整体的画面非常清晰，能清楚地看到画面主体。
低质示例：封面模糊，看不清主体
正面示例：非常的清晰的看到画面主体
2►
不可拉伸截断导致主体变形
封面主体、内容必须是正常比例，严禁出现严重明显拉伸，感知到比例不对称现象，若画面需要放大或缩小，必须进行等比操作。
在封面制作过程中必须保证画面主体的完整性，不可出现对人物脸进行截断展示等情况，此类问题会非常影响用户的观感体验。
低质反面示例：截图导致人脸无法完全展示
低质反面示例：严重拉伸导致封面比例不对称
正面示例：等比例放大视频人物主体，不会造成人物的变形或失真
3►
尽量避免出现封面黑边情况
SEO网站
所有的封面若存在黑边，不可占比过大，不得超过画面整体的三分之一，且不得出现不对称黑边。如正常电影或MV等内容，黑边仅可上下存在，不可左右存在。
低质反面示例：黑边占比大，影响观感
正面示例：视频画面上下存在合理范围内不影响画面观感的黑边
二封面主体内容
1►
封面主体要与视频主体内容一致
一般来说，创作者会将截取视频内容最高光时刻来作为我们的封面制作，不仅可以让用户很快地捕捉我们想要表达的内容，而且高光的内容会很大程度上吸引用户。
对此需注意封面不可存在无封面、纯色黑/白/灰类型封面、仅简单几个字无法感知视频内容的内容封面，这一类封面信息量极低，用户无法从封面获取有效内容信息，会极大降低用户的观看体验。
低质示例：封面上是无意义的几个字，并不知道封面想表达什么意思
正面示例：此封面就是截取视频内容的，做到与实际内容一致，且有非常高的信息量，即使不看标题也能清晰感知的视频内容
2►
封面内容需传递正向价值
所有的封面内容必须符合社会核心价值观，坚决杜绝违背社会公序良俗的敏感信息。比如：色情、低俗、暴力、血腥、重口味、恶意虚假广告营销等相关内容，此类封面严令禁止。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c005b4ece8c3f409234ace52b8b4df88/" rel="bookmark">
			基于SpringBoot的线上日志阅读器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件特点 部署后能通过浏览器查看线上日志。支持Linux、Windows服务器。采用随机读取的方式，支持大文件的读取。支持实时打印新增的日志（类终端）。支持日志搜索。 使用手册 基本页面 配置路径 配置日志所在的目录，配置后按回车键生效，下拉框选择日志名称。
选择日志后点击生效，即可加载日志。
windows路径
E:\java\project\log-view\logslinux路径
/usr/local/XX 历史模式 历史模式下，不会读取新增的日志。针对历史文件可以分页读取，配置分页大小、跳转。
历史模式下，支持根据关键词搜索。目前搜索引擎使用的是jdk自带类库，搜索速度相对较低，优点是比较简单。2G日志全文搜索大概需要5秒左右。
建议大日志文件缩小搜索范围。
匹配结果后，左侧会展示那些数据页包含该关键词，点击后可以跳转到指定页
点击右侧上一页、下一页按钮，可以在关键词之间跳转，便于定位。
实时模式 开启实时模式后，会实时日志文件新增内容
实现思路 技术栈
后台：springboot
前端：jquery+bootstrap5主要思路
一般编辑器或者日志查看器，都需要将所有内容读到内存里。这种方式比较耗费内存，且无法打开比较大的日志。
大文件日志一般的处理方案是做日志拆分，比如100M一个文件。但如果出现问题，就需要一个文件一个文件找，不是很方便。
用ELK这种偏重的解决方案也不现实，公司提供不了相应的环境。
Java内置的类RandomAccessFile支持文件的随机读取，正好提供了另一种比较轻量的解决方案，就是将大日志分页读取。 package com.dayrain.log.core; import lombok.extern.slf4j.Slf4j; import java.io.FileNotFoundException; import java.io.IOException; import java.io.RandomAccessFile; @Slf4j public class FileRandomAccessReader { private RandomAccessFile randomAccessFile; public FileRandomAccessReader(String path) throws FileNotFoundException { randomAccessFile = new RandomAccessFile(path, "r"); } public long getFileSize(){ try { return randomAccessFile.length(); } catch (IOException e) { log.error(String.valueOf(e)); } return -1; } public byte[] readBytes(long fs, long fe) { int len = (int) (fe - fs); byte[]bytes = new byte[len]; try { randomAccessFile.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c005b4ece8c3f409234ace52b8b4df88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3c78b7d1f3f3bc39312b22251ad2ebf/" rel="bookmark">
			流程图拖拽视觉编程-流程编辑器2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、简介
二、自定义图元
2.1图元设计
2.2 端口QNEPort
2.3节点块QNEBlock
一、简介 前期文章：
流程图拖拽视觉编程--概述_Jason~shen的博客-CSDN博客
流程图拖拽视觉编程-流程编辑器_Jason~shen的博客-CSDN博客
本期内容：
本期将继续介绍流程编辑器模块的实现方法，前面介绍了视图的实现，现在介绍自定义图元的实现，即流程图中每个节点块、端口和连接线。
二、自定义图元 该部分基于QGraphicsItem 图元类实现，该类提供了一些基本的图形元件，可在此基础上自定义图元。
2.1图元设计 开始：圆角矩形 + 1个输出端口
结束：圆角矩形 + 1个输入端口
程序块：矩形 + 1个输入端口 + 1个输出端口
条件：菱形 + 1个输入端口 + 1个为真端口 + 1个为假端口
循环：菱形 + 1个输入端口 + 2个循环体端口 （左+下）+ 1个退出循环端口（右）
流程线：带箭头的直线或者折线
2.2 端口QNEPort 继承QGraphicsPathItem，设置为圆形
QPainterPath p; p.addEllipse(-radius_, -radius_, 2 * radius_, 2 * radius_); setPath(p); #ifndef QNEPORT_H #define QNEPORT_H #include &lt;QGraphicsPathItem&gt; #include "floweditor_global.h" class QNEBlock; class QNEConnection; /* 端口 */ class FLOWEDITORSHARED_EXPORT QNEPort : public QGraphicsPathItem { public: enum { Type = QGraphicsItem::UserType + 1 }; enum E_Direction {TOP = 0, BOTTOM = 1, LEFT = 2, RIGHT = 3}; QNEPort(QGraphicsItem *parent = 0); ~QNEPort(); void setDirection(const E_Direction &amp;dir); E_Direction direction(); void setOutput(bool b); bool isOutput() const; void setNEBlock(QNEBlock *); QNEBlock *block() const; int radius(); QVector&lt;QNEConnection *&gt; &amp;connections(); bool isConnected(QNEPort *); int type() const { return Type; } protected: QVariant itemChange(GraphicsItemChange change, const QVariant &amp;value); private: QNEBlock *m_block; int radius_; bool m_isOutput; E_Direction m_directtion; QVector&lt;QNEConnection *&gt; m_connections; }; #endif // QNEPORT_H #include "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3c78b7d1f3f3bc39312b22251ad2ebf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d33131be3c786832c925a64017ff6652/" rel="bookmark">
			魔兽世界服务端用户注册以及网页的搭建教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		魔兽世界服务端用户注册以及网页的搭建教程 大家好我是艾西，上一章我们讲解了怎么编译一个魔兽的服务端以及安装最后进到我们自己的游戏。那么在平时娱乐的同时肯定是需要和朋友们一起玩游戏才会更有意思，那么今天艾西教大家怎么搭建用户注册页面以及网站
搭建网站我们需要用到phpstudy： 先打开这个软件点击启动Nginx然后点击网站选项
在文件夹里找到phpstudy_pro &gt;www 目录下的index.html文件直接删掉，这个文件是我们在启动nginx程序时自动生成的文件不是我们想要的
下载一个azerothcore/wowSimpleRegistration.zip 文件包，将这个文件包解压到php文件目录的www文件夹内（以下就是wowSimpleRegistration文件夹的内容）
然后打开www目录下的application&gt;config&gt;找到config.php.sample文件将后缀.sample删除后用记事本的方式打开 （按图中红色字体标记提示改）
Template name, You can change it to:
light
advance
icecrown
kaelthas
Battleforazeroth
$config['template']= ; （选择模板的意思）
$config['db_auth_host’] 是数据库信息的意思
$config['realmlists] = array 是服务器数据库的意思
"db_name' =&gt; "acore_ characters" // Characters database name 角色配置列表的意思
角色配置列表配置好后我们打开Navicat Acore_auth 认证数据库
acore_characters角色数据库
到这里我们需要确认下一 php数据库能访问到acore数据库，我们运行win+r 输入cmd
输入mysql -uroot -p回车 输入密码进入数据库 输入use mysql回车输入changed 回车输入select user,plugin form user 回车 : 回车
我们可以看到root是mysql_native的认证方式，acore是sha2的认证方式，而php是不支持sha2的加密方式，所以我们得改一下acore的加密方式
use mysql;
ALTER USER 'root @'ocalhost lDENTIFED WiTH mysql native password BY xxxx”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d33131be3c786832c925a64017ff6652/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d52cdff8719a0d6414988b746a513b63/" rel="bookmark">
			skynet学习笔记 源码之skynet_timer定时器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定时器简介 skynet.timeout(ti,func)
skynet定时器非常的轻量级，仅仅提供注册函数，并且还不能传参。
定时器的实现仅仅用了300行代码。
定时器注册回调流程 通过调用capi把定时任务加入，最终以消息的方式传回本actor，用worker线程处理消息，执行注册函数。
function skynet.timeout(ti, func) local session = c.intcommand("TIMEOUT",ti) .... end static int lintcommand(lua_State *L) { result = skynet_command(context, cmd, parm); ... } cmd_timeout(struct skynet_context * context, const char * param) { ... skynet_timeout(context-&gt;handle, ti, session); ... } int skynet_timeout(uint32_t handle, int time, int session) { if (time &lt;= 0) { struct skynet_message message; message.source = 0; message.session = session; message.data = NULL; message.sz = (size_t)PTYPE_RESPONSE &lt;&lt; MESSAGE_TYPE_SHIFT; if (skynet_context_push(handle, &amp;message)) { return -1; } } else { struct timer_event event; event.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d52cdff8719a0d6414988b746a513b63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa9e5fc2f74cf48f8b1024881b81586d/" rel="bookmark">
			利用python爬虫爬取旅游网信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、准备需要的库 import requests from lxml import html from openpyxl import Workbook 二、爬取的网站 url = 'https://place.qyer.com/china/citylist-0-0-1/' 三、对网站进行抓包分析 四、源码 # -- coding: utf-8 -- import requests from lxml import html from openpyxl import Workbook # 创建Excel wb = Workbook() ws = wb.active # 获取数据 url = 'https://place.qyer.com/china/citylist-0-0-1/' def getpage(url): # 请求头，模拟浏览器登录 headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Safari/537.36'} # 访问链接，获取HTML r = requests.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa9e5fc2f74cf48f8b1024881b81586d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6eb4cc9b1f3e762e75c9f0738095447a/" rel="bookmark">
			流程图拖拽视觉编程-流程编辑器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、简介
二、流程编辑器-视图实现
三、参考资料
一、简介 前期文章：
流程图拖拽视觉编程--概述_Jason~shen的博客-CSDN博客
本期内容：
本期将介绍流程编辑器模块的实现方法，效果图如下所示。该模块基于QT Graphics/View实现，由视图、自定义图元、图元管理器组成。
二、流程编辑器-视图实现 视图的功能是提供一个节点显示窗口，支持缩放、平移和网格线背景。
该部分继承QGraphicsView实现，定义接口如下：
class GRAPHICSLIBSHARED_EXPORT BaseGraphicsView: public QGraphicsView { Q_OBJECT public: explicit BaseGraphicsView(QWidget *parent = nullptr); ~BaseGraphicsView(); void setFactorMax(double val); //最大缩放因子 void setFactorMin(double val); //最小缩放因子 void setShowGrid(bool b); //是否显示网格线 void setMoveSceneEnabled(bool b); //是否平移使能 public slots: void zoomIn(); void zoomOut(); protected: void wheelEvent(QWheelEvent *event) Q_DECL_OVERRIDE; void drawBackground(QPainter *painter, const QRectF &amp;rect) Q_DECL_OVERRIDE; void mousePressEvent(QMouseEvent *event) Q_DECL_OVERRIDE; void mouseMoveEvent(QMouseEvent *event) Q_DECL_OVERRIDE; void mouseReleaseEvent(QMouseEvent *event) Q_DECL_OVERRIDE; private: void drawGrid(QPainter *painter, double gridStep); private: double m_factorMax; double m_factorMin; QPointF m_scenePos; QPointF m_pressPos; bool m_moveScene; bool m_showGrid; bool m_moveSceneEnabled; }; 缩放的实现：核心函数scale(), 配合鼠标事件操作，重写鼠标滚动事件函数wheelEvent，限制视图过大或者过小。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6eb4cc9b1f3e762e75c9f0738095447a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4029f744110bc5647afbe32a9e3f9a0d/" rel="bookmark">
			【你好！我是MOSS】从0开始搭建本地MOSS智能机器人
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前提条件：需要单张A100或A800显卡，或两张3090显卡，或者以上规模。
以下正文：远程到GPU服务器，本地使用的是Centos 7.5系统环境。然后查看显卡信息
查看显卡显存等其他信息，一共8张GTX3080TI显卡，96G显存，应该是够用了。
下载moss项目到本地
git clone https://github.com/OpenLMLab/MOSS.git 本文原文，出自我个人的公众号【Dotnet Dancer】，地址：
【你好！我是MOSS】从0开始搭建本地MOSS智能机器人
git clone报错，可能是第一次使用，git 版本有问题，先卸载
yum remove git 安装git 依赖包们
yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel asciidoc -y yum install gcc perl-ExtUtils-MakeMaker -y 查看git版本列表
https://mirrors.edge.kernel.org/pub/software/scm/git
下载指定的版本，例如最新版 git-2.39.2.tar.gz
wget https://mirrors.edge.kernel.org/pub/software/scm/git/git-2.39.2.tar.gz 报错了，根据提示进行改造一下，为了以防万一，git版本下载低一点的，例如2.28.0
解压和创建git安装文件夹
tar -zxf git-2.28.0.tar.gz mkdir -p ~/local/git cd git-2.28.0/ ./configure --prefix=$HOME/local/git 编译与安装git
make &amp;&amp; make install 设置环境变量和查看当前版本
export PATH=$HOME/local/git/bin:$PATH git version 重新拉取代码
可能是网络原因，或者其他某些原因，一直无法拉取成功
只能使用工具传上去，例如 winSCP。先把moss库git clone到本地，然后通过工具传输到远程服务器上。
MOSS项目现在在服务器上了
把默认的torch版本改为1.13.1版本或者其他高版本也行【备注：现在最新的代码库，已经修复了低版本问题，该步骤可以省略】
进行安装moss依赖
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4029f744110bc5647afbe32a9e3f9a0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3eb26287f30d36d95ddbc2e1a143eb63/" rel="bookmark">
			vue2-django 实现登录注册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前端vue：
后端django处理请求
前端vue： cd到目标文件夹，输入：vue init webpack 文件名
前四个一路回车，后几个选no
接着cd到建好的文件夹，执行npm install ，然后就可以npm run dev 查看初始页面了
接下来我们通过vue组件来搭建一个前端页面
首先把默认样式清除，删除helloword.vue后将app.vue清除成如下内容。
然后在components文件夹中新建vue文件，写入我们需要的内容
我构建了三个文件，分别用来登录、注册、登录成功后显示
我们要做的是注册与登录功能，那么我们需要账号与密码
我们先做注册功能，也就是进入signup.vue中
因此我们在data里构建一个对象loginForm存储输入的账号与密码
data(){ return{ loginForm:{ username:'', password:'' } } }, data写在&lt;script&gt;中，如
而后构建一个form表单，输入框绑定username与password
&lt;template&gt; &lt;div id="sign"&gt; &lt;div style="text-align: center; font-family: 华文琥珀; font-size: larger;"&gt; &lt;div&gt;欢迎注册&lt;/div&gt; &lt;div&gt;请输入您的信息&lt;/div&gt; &lt;/div&gt; &lt;div style="height: 50px;"&gt;&lt;/div&gt; &lt;div&gt; &lt;form v-bind:model="loginForm"&gt; &lt;input v-model="loginForm.username" type="text" placeholder="请输入用户名"/&gt; &lt;input v-model="loginForm.password" type="password" placeholder="请输入密码"/&gt; &lt;/form&gt; &lt;button v-on:click="summiti()"&gt;注册&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; 写好之后，我们要怎么查看写出来的页面是什么样子呢？
这需要用到vue-router
在项目的根目录的终端执行npm install --legacy-peer-deps vue-router@3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3eb26287f30d36d95ddbc2e1a143eb63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d428002aaafeafe81fad4bbf94b3232c/" rel="bookmark">
			golang：时间转换总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在编程中，我们经常会遭遇八小时时间差问题。这是由时区差异引起的，为了能更好地解决它们，我们需要理解几个时间定义标准。
GMT（Greenwich Mean Time），格林威治平时。GMT 根据地球的自转和公转来计算时间，它规定太阳每天经过位于英国伦敦郊区的皇家格林威治天文台的时间为中午12点。GMT 是前世界标准时。
UTC（Coordinated Universal Time），协调世界时。UTC 比 GMT 更精准，它根据原子钟来计算时间。在不需要精确到秒的情况下，可以认为 UTC=GMT。UTC 是现世界标准时。
从格林威治本初子午线起，往东为正，往西为负，全球共划分为 24 个标准时区，相邻时区相差一个小时。
package main import ( "fmt" "time" ) func main() { fmt.Println(time.Now()) } 中国大陆使用的是东八时区的标准时，即北京时间 CST，China Standard Time。
$ go run main.go 2022-07-17 16:37:31.186043 +0800 CST m=+0.000066647 这是默认时区下的结果，time.Now()的打印中会标注+0800 CST。
假设我们是在美国洛杉矶时区下，那得到的结果是什么呢？
$ TZ="America/Los_Angeles" go run main.go 2022-07-17 01:39:12.391505 -0700 PDT m=+0.000069514 可以看到，此时的结果是-0700 PDT 时间，即 PDT（Pacific Daylight Time）太平洋夏季时间。由于时区差异，两次执行的时间结果相差了 15 小时。
注意，在使用 Docker 容器时，系统默认的时区就是 UTC 时间（0 时区），和我们实际需要的北京时间相差八个小时，这是导致八小时时间差问题的经典场景。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d428002aaafeafe81fad4bbf94b3232c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b4bbc0940c4c89976ee75847f500a6b/" rel="bookmark">
			golang 实现：给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		示例 1:
输入: s = “abcabcbb”
输出: 3
解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。
示例 2:
输入: s = “bbbbb”
输出: 1
解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。
示例 3:
输入: s = “pwwkew”
输出: 3
解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。
请注意，你的答案必须是 子串 的长度，“pwke” 是一个子序列，不是子串。
提示：
0 &lt;= s.length &lt;= 5 * 104
s 由英文字母、数字、符号和空格组成
这道题可以使用滑动窗口来解决。具体思路如下： 定义一个空的窗口，用两个指针 left 和 right 表示窗口的左右边界，初始化为 0。
用一个哈希表记录窗口中每个字符出现的次数，键为字符，值为该字符在窗口中出现的次数。
当 right 指针小于字符串的长度时，执行以下步骤：
a. 如果当前字符在哈希表中已经存在，说明窗口中出现了重复字符，需要将左边界右移，并且更新哈希表中的值，直到窗口中不再存在重复字符为止。
b. 如果当前字符在哈希表中不存在，说明可以将该字符加入窗口，将 right 指针右移，并且更新哈希表中的值。
c. 在每次更新完哈希表后，记录下当前窗口的大小，取其中的最大值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b4bbc0940c4c89976ee75847f500a6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06800379a28d69139d1e64fd62c5564e/" rel="bookmark">
			golang 两数之和,给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
你可以按任意顺序返回答案。
示例 1：
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
示例 2：
输入：nums = [3,2,4], target = 6
输出：[1,2]
示例 3：
输入：nums = [3,3], target = 6
输出：[0,1]
提示：
2 &lt;= nums.length &lt;= 104
-109 &lt;= nums[i] &lt;= 109
-109 &lt;= target &lt;= 109
只会存在一个有效答案
package main import "fmt" func main() { n := []int{1, 2, 3, 4, 5} fmt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06800379a28d69139d1e64fd62c5564e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a65559babd55dee38570ef70c39a4900/" rel="bookmark">
			如何打开jupyter /.ipynb文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打开anaconda Prompt（anaconda ）输入
jupyter lab 即可打开网址
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b511308301f1c2a07b6eb644f401ca71/" rel="bookmark">
			golang 日期函数，常用用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时间是计量时间的标准，常用于记录、比较和计算时间间隔。以下是时间的各种用法：
1. 表示时间的类型 在 Go 语言中，时间使用 time.Time 类型表示，它包含了日期和时间信息。例如，可以使用 time.Now() 获取当前时间：
now := time.Now() // 获取当前时间
时间的格式化
可以使用 time.Format() 函数将时间格式化为字符串，例如：
now := time.Now() fmt.Println(now.Format("2006-01-02 15:04:05")) // 输出：2023-04-27 14:30:00 其中，“2006-01-02 15:04:05” 是一个固定的格式化字符串，表示年月日时分秒。
2.时间的解析 可以使用 time.Parse() 函数将字符串解析为时间，例如：
dateStr := "2023-04-27 14:30:00" date, err := time.Parse("2006-01-02 15:04:05", dateStr) if err != nil { // 解析错误 } 其中，“2006-01-02 15:04:05” 是一个固定的解析字符串，表示年月日时分秒。
3.时间的比较 可以使用 time.Before()、time.After()、time.Equal() 等函数比较两个时间的大小关系，例如：
now := time.Now() tomorrow := now.AddDate(0, 0, 1) if tomorrow.After(now) { fmt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b511308301f1c2a07b6eb644f401ca71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/697cb4277f921a6f68776baa6c3e3628/" rel="bookmark">
			ROS学习8：ROS机器人平台设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Autolabor初级教程】ROS机器人入门
1. 电机与电机驱动板 1.1 直流减速电机 电机主体通过输入轴与减速箱相连接，通过减速箱的减速效果，最终外端的输出轴会按照比例 (取决于减速箱减速比) 降低电机输入轴的转速，当然速度降低之后，将提升电机的力矩
尾部是 AB 两相霍尔编码器，通过 AB 编码器输出的波形图，可以判断电机的转向以及计算电机转速
电机主要参数 额定扭矩：额定扭矩和机器人质量以及有效负荷相关，二者正比例相关，额定扭矩越大，可支持的机器人质量以及有效负荷越高；
减速比：电机输入轴与输出轴的减速比例，比如: 减速比为90，意味着电机主体旋转90圈，输出轴旋转1圈。
减速后转速：与减速比相关，是电机减速箱输出轴的转速，单位是 rpm(转/分)，减速后转速与减速前转速存在转换关系: 减速后转速 = 减速前转速 / 减速比。另外，可以根据官方给定的额定功率下的减速后转速结合车轮参数来确定小车最大速度。
编码器精度：是指编码器旋转一圈单相 (当前编码器有 AB 两相) 输出的脉冲数
注意：电机输入轴旋转一圈的同时，编码器旋转一圈，如果输出轴旋转一圈，那么编码器的旋转圈数和减速比一致(比如减速比是90，那么输出轴旋转一圈，编码器旋转90圈)编码器输出的脉冲数计算公式：输出轴旋转一圈产生的脉冲数 = 减速比 * 编码器旋转一圈发送的脉冲数(比如：减速比为90，编码器旋转一圈输出 11 个脉冲，那么输出轴旋转一圈总共产生 11 * 90 也即 990 个脉冲) 1.2 电机驱动板 为什么需要选配合适的电机驱动板？ 因为 Arduino 的输出电流不足以直接驱动电机，需要通过电机驱动板放大电机控制信号 2. 电机测速理论 2.1 编码器 编码器（encoder）是将信号（如比特流）或数据进行编制、转换为可用以通讯、传输和存储的信号形式的设备 编码器把角位移或直线位移转换成电信号，前者称为码盘，后者称为码尺按照读出方式编码器可以分为接触式和非接触式两种按照工作原理编码器可分为增量式和绝对式两类 增量式编码器是将位移转换成周期性的电信号，再把这个电信号转变成计数脉冲，用脉冲的个数表示位移的大小绝对式编码器的每一个位置对应一个确定的数字码，因此它的示值只与测量的起始和终止位置有关，而与测量的中间过程无关 2.2 测速原理 AB 相增量式编码器测速原理 AB 相编码器主要构成为 A 相与 B 相，每一相每转过单位的角度就发出一个脉冲信号(一圈可以发出 N 个脉冲信号)，A 相、B 相为相互延迟 1/4 周期的脉冲输出，根据延迟关系可以区别正反转，而且通过取 A 相、B 相的上升和下降沿可以进行单频或 2 倍频或 4 倍频测速
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/697cb4277f921a6f68776baa6c3e3628/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ff67c854aaabcc5bf9c20e8e0b2ab2f/" rel="bookmark">
			关于textarea在uniapp、微信小程序下，ios手机有上内边距问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：https://developers.weixin.qq.com/community/develop/doc/00082669f70908eea2a7c9cfe5b400
emmmm，这个问题有些年头了，但是，并没有解决。
最近项目也用到了textarea，安卓机、模拟器完全ojbk，但是一到ios那，就出问题了（ps：我就不喜欢ios机，所以我不知道这个bug，企图萌（猛）混过关）
在贴个老哥的分析：https://blog.csdn.net/weixin_33699914/article/details/88731379
后来查找了许多资料，找到一些解决的办法。（链接忘了…）
就写下其中一种比较简单的方法。
思路：既然textarea设置padding:0;不行，那么就让textarea往上移动(margin-top:-20rpx)。首先要判断该手机是ios还是android。至于为什么是-20rpx，这个就根据实际效果了，查找的时候，有的是-10rpx，有的是-12rpx；
uniapp获取设备信息（platform字段）：https://uniapp.dcloud.io/api/system/info?id=getsysteminfosync
uniapp插件uView（os方法）：https://uviewui.com/js/fastUse.html#os
微信小程序获取设备信息：https://developers.weixin.qq.com/miniprogram/dev/api/base/system/system-info/wx.getSystemInfo.html
拿到设备的平台名称，那就简单了，直接判断然后改变class
&lt;textarea value="" v-model="value" placeholder="选填，请输入您申请退款的说明" :class="os=='ios' ? 'textareaIos' : '' " /&gt; &lt;script&gt; export default{ data(){ return{ os:this.$u.os(),//我用的是uView，别问，问就是简单方便懒 } } } &lt;/script&gt; &lt;style&gt; .textareaIos{ margin-top: -20rpx; } &lt;/style&gt; 补充：uview2.0有属性可以解决这个问题了，如下图
最后，如果我的笔记对您有帮助，请给我一个赞~ 谢谢！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d19b071456c0d7109466ba769a94b6bf/" rel="bookmark">
			Linux 系统安装 Oracle 11g 数据库详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、登录root用户，在root用户下执行以下步骤
（1）输入命令：vi /etc/security/limits.conf，按i键进入编辑模式，添加下边的内容。
oracle soft nproc 204
oracle hard nproc 16384
oracle soft nofile 1024
oracle hard nofile 65536
编辑完成后按Esc键，输入“:wq”存盘退出。
（2）再次输入命令：vi /etc/pam.d/login，按i键进入编辑模式，添加下边的内容。
session required /lib/security/pam_limits.so
session required pam_limits.so
编辑完成后按Esc键，输入“:wq”存盘退出
（3）再次输入命令: vi /etc/sysctl.conf ，按i键进入编辑模式，添加下边的内容
fs.file-max = 6815744
fs.aio-max-nr = 1048576
kernel.shmall = 2097152
kernel.shmmax = 2147483648
kernel.shmmni = 4096
kernel.sem = 250 32000 100 128
net.ipv4.ip_local_port_range = 9000 65500
net.core.rmem_default = 4194304
net.core.rmem_max = 4194304
net.core.wmem_default = 262144
net.core.wmem_max = 1048576
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d19b071456c0d7109466ba769a94b6bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b0a5f03f4408b4a4e602a3b87514952/" rel="bookmark">
			ArcGIS Pro拓扑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		地理数据库拓扑帮助确保数据完整性。拓扑的使用提供了一种对数据执行完整性检查的机制，帮助地理数据库中验证和保持更好的要素表示。
拓扑是点、线和多边形要素共享几何的方式的排列布置。拓扑的用途包括以下几个方面：
（1）限制要素共享几何的方式。例如，相邻多边形（如宗地）具有共享边、街道中心线和人口普查区块共享几何以及相邻的土壤多边形共享边。
（2）定义并强制实施数据完整性规则：两个面之间不应存在间隙，不应存在重叠的要素等等。
（3）支持拓扑关系查询和导航，如确定要素邻接性和连通性。
（4）支持可强制执行数据模型拓扑约束的编辑工具。
（5）根据非结构化的几何构造要素，如根据线创建多边形。
拓扑一直是 GIS 在数据管理和完整性方面的关键要求。 通常拓扑数据模型通过将空间对象（点、线和面要素）表示为拓扑原始数据（节点、面和边）的基础图表来管理空间关系。 这些原始数据（连同它们彼此之间及其所表示的要素边界之间的关系）通过在拓扑元素的平面图表中表示要素几何进行定义。
1 ArcGIS地理数据库中的拓扑规则 1.1 点规则 点规则
1.2 线规则 线规则
线规则
1.3 面规则 面规则
2 ArcGIS Pro Data Reviewer中的规则 2.1 属性校验 2.
属性校验
2.2 要素完整性校检 2.3
要素完整性校检
2.3 事件校检 事件校检
2.4 地理数据库校检 地理数据库校检
2.5 面校验 面校检
2.6 折线校验 折线校检
2.7 空间关系校检 空间关系校检
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4302b42575cc07acaba6650dae8f27a/" rel="bookmark">
			MySQL 安全及防止 SQL 注入攻击
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果通过网页获取用户输入的数据并将其插入 MySQL 数据库，那么就有可能发生 SQL注入攻击的安全问题
作为研发，有一条铁律需要记住，那就是
永远不要相信用户的数据，哪怕他一再承诺是安全的
SQL 注入式攻击 SQL 注入，就是通过把 SQL 命令插入到 Web 表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的 SQL 命令
比如有一个表单，用户可以输入 name
&lt;?php $name = $_GET['name']; $dbh-&gt;query("SELECT * FROM users WHERE name='{$name}'"); 那么当用户输入的 name 为 Python'; DELETE FROM user;' 时会变成什么？
SELECT * FROM users WHERE name='Python'; DELETE FROM user;''; 这条语句运行一下，会发现什么？ 我们的 user 表被清空啦，很可怕，对不对
所以我们需要对用户的输入进行过滤处理
例如下面的 PHP 语句，要求用户输入的名称 name 必须是字母、数字及下划线的组合，且用户名长度为 8 到 20 个字符之间
&lt;?php if (preg_match("/^\w{8,20}$/", $_GET['name'], $matches)) $dbh-&gt;query("SELECT * FROM tbl_language WHERE name=$matches[0]"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4302b42575cc07acaba6650dae8f27a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5ba7313c10f04e5c5654c4b36d2310c/" rel="bookmark">
			ERROR: Could not build wheels for pymssql, which is required to install pyproject.toml-based project
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：m2在终端下想要访问SQLserver数据库，就需要在Python中安装pymssql的模块，我用的是pip命令安装的，命令pip install ,具体报错信息如下； pip install pymssql  ✔ took 7s base Py at 11:38:10 Collecting pymssql Downloading pymssql-2.2.7.tar.gz (170 kB) ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 171.0/171.0 kB 330.8 kB/s eta 0:00:00 Installing build dependencies ... done Getting requirements to build wheel ... done Preparing metadata (pyproject.toml) ... done Building wheels for collected packages: pymssql Building wheel for pymssql (pyproject.toml) ... error error: subprocess-exited-with-error × Building wheel for pymssql (pyproject.toml) did not run successfully. │ exit code: 1 ╰─&gt; [25 lines of output] setup.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5ba7313c10f04e5c5654c4b36d2310c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1371c57b72f7bbe086435cec23180acb/" rel="bookmark">
			JS调用方法时报undefined排查思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JS调用方法时报undefined排查思路 1、看该方法是否存在
2、看参数是否存在，看调用时传的实参数有没有值，
3、函数调用没有返回值或者return后没有数据，接收函数返回的变量是undefined
方法时报 is not a function 排查思路 1，看是否是个方法，或者方法名是否写错
2，调用方法的对象格式是否正确
比如： data.map() 方法，data必须是数组，如果data不是数组，就会报错 data.map is not a function
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/145fe2398f7fab2eae92467ff23b5847/" rel="bookmark">
			快速调试PID参数的3种方法。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在学习 PID 算法的参数整定的时候，每一个系统的 PID系数是不通用的，在不同的系统中运用同样的 PID 系数，其最终所体现的效果可能是相差可能甚远的，所以我们需要根据实际的系统进行 PID 的参数整定（调参）。
01
采样周期选择
采样周期指的是 PID 控制中实际值的采样时间间隔，其越短，效果越趋于连续，但对硬件资源的占用也越高。在实际的应用中，我们可以使用理论或者经验方法来确定采样周期：
① 理论方法：香农采样定理。
这个定理可以用来确定采样周期可选择的最大值，当采样周期超出了这个最大的允许范围，我们所得到的信号就会失真，也就无法较好地还原信号了。
香农采样定理的具体原理我们不展开介绍，感兴趣的朋友可以去查找相关的资料，我们这里重点关注经验方法。
② 经验方法：根据控制对象突变能力选择。
假设电机当前转速为 20RPM，我们需要提高它的转速到 30RPM，此电机的转速在 1s 之内最大可以突变 10RPM，如果我们每 1ms 采集一次电机转速，那么每一次采集到的速度变化量最大为 10RPM / 1000 =0.01RPM。
很明显，此时最大的变化量远远小于当前的速度，对我们的 PID 控制效果并没有明显的提升，但是却占用了很多的硬件资源，因此，我们需要根据控制对象的突变能力来选择采样周期。
02
PID参数整定方法
理论计算整定法：依据系统的数学模型，经过理论计算确定 PID 参数。
这种方法是建立在理想化条件下的，其得到的参数不一定能够直接使用，还需要结合经验以及实际的系统进行调整。
工程整定法：依靠工程经验，直接在控制系统的试验中进行整定，此方法易于掌握，在实际调参中被广泛采用。工程整定法包括：试凑法、临界比例法和一般调节法。
注意：无论采用哪一种方法所得到的 PID 参数，都需要在实际运行中进行最后调整与完善，因此，在 PID 参数整定中，最重要的就是经验的积累。**
① 比例系数：调节作用快，系统一出现偏差，调节器立即将偏差放大输出
② 积分系数：积分系数的调节会改变输入偏差对于系统输出的影响程度。积分系数越大，消除静差的时间越短，但是过大的积分系数则会导致系统出现超调现象，这在具有惯性的系统中尤为明显。
③ 微分系数：微分系数的调节是偏差变化量对于系统输出的影响程度。微分系数越大，系统对于偏差量的变化越敏感，越能提前响应，进而抑制超调，但是过大的微分系数则会让整个系统出现振荡。
03
试凑法
3.1 内容
结合系统的具体情况以及经验，先试凑几组合理的 PID 系数，同时需要观察系统的曲线变化，确定每一个系数对于整个系统曲线的大致影响，然后再根据具体的曲线进行调整。
3.2 调节思路
① 先是比例（P），再积分（I），最后是微分（D）
② 按纯比例系统整定比例系数，使其得到比较理想的调节过程曲线，然后再把比例系数缩小 1.2 倍左右，将积分系数从小到大改变，使其得到较好的调节过程曲线
③ 在这个积分系数下重新改变比例系数，再看调节过程曲线有无改善
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/145fe2398f7fab2eae92467ff23b5847/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83979b9d615adb51bd3d543a674e0790/" rel="bookmark">
			The differences between World Wide Web and the Internet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 WWW consists of content organized as web pages. The Web pages are available across the Internet from web servers; HTTP/HTTPS protocol is use to transfer the web pages from server to client;The Internet is a connected network, a global communication infrastructure. It links computers and networks together. The Internet uses TCP/IP suite to provide various services, including the web service, email service, file transfer service and many others. 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa3900579bdb0d8ff069e70053074b80/" rel="bookmark">
			银河麒麟专用机服务器和终端软件下载仓库源地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		服务器源地址rpm
http://update.cs2c.com.cn:8080/NS/V10/V10SP1/os/adv/lic/base/aarch64/Packages/
终端源地址deb
V10SP1源仓库http://archive2.kylinos.cn/deb/kylin/production/KY-V10-SP1-arm64/custom/kylin-desktop/V10-SP1-arm64/pool/main/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04fb28ddb30235e149f181bd2e0333c9/" rel="bookmark">
			归并排序-Pyhton
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🚀归并排序（Merge Sort）是一种分治算法，它将一个大的序列拆分成较小的子序列，然后对每个子序列进行排序，最后将排序好的子序列合并成一个已排序的序列。归并排序的主要操作是归并。
🚀归并排序的主要步骤如下：
1. 分解：将原始序列划分为只有一个元素的子序列。
2. 递归地排序子序列：对每个子序列进行排序。
3. 合并：将排序好的子序列合并成最终的已排序序列。
🚀Python的归并排序示例：
def merge_sort(arr): if len(arr) &lt;= 1: return arr mid = len(arr) // 2 left = arr[:mid] right = arr[mid:] left = merge_sort(left) right = merge_sort(right) return merge(left, right) def merge(left, right): result = [] i, j = 0, 0 while i &lt; len(left) and j &lt; len(right): if left[i] &lt;= right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result += left[i:] result += right[j:] return result arr = [3, 6, 8, 10, 1, 2, 1] print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04fb28ddb30235e149f181bd2e0333c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eebb84780dfb228928f9767ec40e7374/" rel="bookmark">
			mysq5.7 yum方式安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境 centos7.6 当工作需要部署mysql时，通过手动上传安装包以及依赖包的方式安装mysql会比较麻烦，可以添加官方yum源，来实现自动安装依赖，方便快捷，这里已mysql5.7为例，其他版本差不多。
查看当前yum仓库是否包含mysql-server相关包，
[root@k8smaster ~]# yum whatprovides mysql-server 下载 mysql的yum仓库文件包
wget http://repo.mysql.com/yum/mysql-5.7-community/el/7/x86_64/mysql57-community-release-el7-10.noarch.rpm rpm -ivh mysql57-community-release-el7-10.noarch.rpm 再次查看仓库是否有mysql相关安装包，已存在
[root@jenkins ~]# yum whatprovides mysql-server 开始使用yum安装mysql
[root@jenkins ~]# yum -y install mysql-server 设置开机启动并启动mysql
[root@jenkins ~]# systemctl enable mysqld [root@jenkins ~]# systemctl start mysqld [root@jenkins ~]# systemctl status mysqld 首次安装后，可以通过mysql日志查询默认密码，登录后修改密码即可。
[root@jenkins ~]# cat /var/log/mysqld.log |grep password 2022-01-02T06:48:58.316678Z 1 [Note] A temporary password is generated for root@localhost: e:xa#2U2k+As e:xa#2U2k+As 就是初始密码
初始密码登录后必须先执行修改密码才能进行其他操作
[root@jenkins ~]# mysql -u root -p Enter password: Welcome to the MySQL monitor.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eebb84780dfb228928f9767ec40e7374/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d48bc2fc8d44436b983cfcb89549c2c/" rel="bookmark">
			.ipynb直接转成.py
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.打开含有.ipynb的文件夹，在目录上点击，输入cmd
2.输入
jupyter nbconvert --to script *.ipynb 不用修改直接回车
3.当前目录下多了一个.py文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/162feb116ee7a55ffc90c100e520c3ca/" rel="bookmark">
			UE Async Load Asset通过资源路径加载Content下资源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、右键资源复制资源路径
2、粘贴资源路径到蓝图中
拖出路径转Asset节点
拆分该节点为字符串
粘贴资源路径到该节点中
其中Texture2D’/Game/test.test’为固定格式
3、将转换成功后的object再转换成所需的资源类型
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/416e27b8edbda6fa6360d59879b0ef0d/" rel="bookmark">
			樊昌信 通信原理第七版 第八章思考题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、何谓MSK？其中文全称是什么？MSK信号对每个码元持续时间TB内包含的载波周期数有何约束？ 答：MSK全称最小频移键控，是对2FSK的改进。TB必须是载波周期四分之一的整数倍。
2、试述MSK信号的6个特点？ 答：
信号包络恒定；相位连续；严格正交；占用带宽最小；具有最小调制指数 h = 1/2；一个码元内包含 1/4 个载波周期整数倍；一个码元期间内附加相位线性变化 ± π/2；两种码元包含的正弦波周期相差1/2周期。 3、何谓GMSK？其中文全称是什么？GMSK信号有何优缺点？ 答：GMSK中文全称高斯最小频移键控，优点是可以进一步集中信号功率谱密度，减小对邻道的干扰，缺点是有码间串扰。
4、何谓OFDM？其中文全称是什么？主要优点？ 答：正交频分复用。
优点：
传输码元持续时间增长，提高了信号抗多径传输能力；各路已调信号严格正交，接收端能完全分离各路信号；各路子载波已调信号频谱有部分重叠，最小子载波间隔为 1/TB（子载波正交条件），充分利用频带；每路子载波的调制是多进制调制；每路子载波的调制可以根据所处信道的优势采用不同的方式。 5、在OFDM信号中，对各路子载频的间隔有何要求？ 答：为使各路子载波相互正交，要求各路子载波间隔大于或等于1/TB，TB是码元周期。
6、OFDM体制和串行单载波体制相比，其频带利用率可以提高多少？ 答：由P245公式可得可大约提高2倍。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f94bdf10818e7d475169b6134f7efe5b/" rel="bookmark">
			Git Stash 命令详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
背景
用途
常见方法
举例说明
背景 使用git协同开发工具的同学应该都知道，在开发过程中我们需要经常切换分支，例如正在某一个分支下做需求时候，在该需求还未完成时就需要在另外一个分支下进行问题的修改，如果直接git checkout 切换分支会有冲突，会导致切换不成功，但是又不想将当前的做的修改复原，于是想到将当前的改动暂时保存下来，然后切换到另外一个分支去修改问题，当问题修改完成了之后将分支切换回来，然后再将之前保存的改动释放即可继续对需求进行开发了。
用途 git stash这个命令可以将当前的工作状态保存到git栈，在需要的时候再恢复。
常见方法 1、git stash
保存当前的工作区与暂存区的状态，把当前的修改的保存到git 栈，等以后需要的时候再恢复，git stash 这个命令可以多次使用，每次使用都会新加一个stash@{num}，num是编号
注意:
新增的文件，直接执行stash是不会被存储的。【换句话说：没有在git 版本控制中的文件，是不能被git stash 存起来的】
那要怎么办呢，新增的文件我也想存起来，很明显，先执行下git add 加到git版本控制中，然后再git stash就可以了
2、git stash save '注释'
作⽤等同于git stash，区别是可以加⼀些注释， 执⾏存储时，添加注释，⽅便查找
git stash save 'test comment some key words' 3、git stash pop
默认恢复git栈中最新的一个stash@{num}，建议在git栈中只有一条的时候使用，以免混乱。
释放最近一次保存的内容，并且将该次保存的内容出栈（即将栈顶出栈，释放最近一次保存的内容后将该次保存内容删除）（git stash pop）
注意：该命令将堆栈中最新保存的内容删除
4、git stash list
查看当前stash的所有内容列表
如上图所示，stash@{0}和stash@{1}分别是两次保存的修改，stash@{0}是最新的一次提交暂存信息。
5、git stash apply
将堆栈中的内容恢复到当前分支下。这个命令不同于 git stash pop。该命令不会将内容从对堆栈中删除，也就是该命令能够将堆栈的内容多次运用到工作目录，适合用与多个分支的场景。
应用某一次的存储内容，但不删除改内容（即该存储的内容还是存储在栈内 git apply）
使用方法：git stash apply stash@{$num}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f94bdf10818e7d475169b6134f7efe5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2409542516d36a3c9d443f28b0435eb/" rel="bookmark">
			2023年团体程序设计天梯赛（含部分题解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
个人总结
L1-1 最好的文档（模拟）
AC代码：
L1-2 什么是机器学习（模拟）
AC代码：
L1-3 程序员买包子（模拟）
AC代码：
L1-4 进化论（模拟）
AC代码：
L1-5 猜帽子游戏（模拟）
AC代码：
L1-6 剪切粘贴（模拟）
AC代码：
L1-7 分寝室（模拟）
AC代码：
L1-8 谁管谁叫爹（模拟）
AC代码：
L2-1 堆宝塔（栈）
AC代码：
L2-2 天梯赛的赛场安排（堆）
AC代码：
L2-3 锦标赛
（代码待补充）
L2-4 寻宝图（BFS）
AC代码：
L3-1 超能力者大赛
（代码待补充）
L3-2 完美树
（代码待补充）
L3-3 血染钟楼
（代码待补充）
个人总结 今年的天梯赛相比于去年确实是简单了，但依旧未能保住175的国三个奖（弱校勿喷），最终因为L2-2题干意思看的过于粗略导致代码敲完后发现不太对劲从而浪费了不少时间，最终还是没能A掉L2-2以150+结束今年的天梯赛，发现天梯赛的题好像就是有点在玩文字游戏，光读题就耗费了不少时间，不同于其他平台的OJ，也有可能是我个人对题意的理解有偏差吧，总之感觉天梯赛的题目就是又臭又长还难理解，明年应该还会参加天梯赛，希望那时候能拿个个人国奖
L1-1 最好的文档（模拟） 有一位软件工程师说过一句很有道理的话：“Good code is its own best documentation.”（好代码本身就是最好的文档）。本题就请你直接在屏幕上输出这句话。
输入格式：
本题没有输入。
输出格式：
在一行中输出 Good code is its own best documentation.。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2409542516d36a3c9d443f28b0435eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94990adf983343fd5dad008df1ff707b/" rel="bookmark">
			CentOS7.9镜像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		centos7.9下载
Index of /centos/7.9.2009/isos/x86_64/
官网下载链接：CentOS Mirrors List
阿里云站点：centos-7-isos-x86_64安装包下载_开源镜像站-阿里云
各个版本的ISO镜像文件说明：
CentOS-7-x86_64-DVD-2009.iso 标准安装版（推荐）
CentOS-7-x86_64-Everything-2009.iso 完整版，集成所有软件（以用来补充系统的软件或者填充本地镜像）
CentOS-7-x86_64-LiveGNOME-2009.iso GNOME桌面版
CentOS-7-x86_64-LiveKDE-2009.iso KDE桌面版
CentOS-7-x86_64-Minimal-2009.iso 精简版，自带的软件最少
CentOS-7-x86_64-NetInstall-2009.iso 网络安装版（从网络安装或者救援系统）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0f0a654a77c4965840b054c0af78e17/" rel="bookmark">
			算法——分布式——一致性哈希、一致性hash图解动画
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分布式算法——一致性哈希、一致性Hash 概述传统Hash算法算法步骤生成Hash环定位服务器定位数据和映射服务器 服务器变更Hash环倾斜虚拟节点总结 概述 一致性哈希算法在1997年由麻省理工学院提出，是一种特殊的哈希算法，目的是解决分布式缓存的问题。在移除或者添加一个服务器时，能够尽可能小地改变已存在的服务请求与处理请求服务器之间的映射关系。一致性哈希解决了简单哈希算法在分布式哈希表( Distributed Hash Table，DHT) 中存在的动态伸缩等问题。
整体流程大致分为三步。
一：生成Hash环：首先，对存储节点的哈希值进行计算，其将存储空间抽象为一个环，将存储节点配置到环上。环上所有的节点都有一个值。
二：对各个服务器使用Hash函数进行哈希计算，具体可以选择服务器的IP或主机名作为关键字进行哈希，从而确定每台机器在哈希环上的位置。
二：对各个服务器使用Hash函数进行哈希计算，具体可以选择服务器的IP或主机名作为关键字进行哈希，从而确定每台机器在哈希环上的位置。
三:对数据进行哈希计算，按顺时针方向将其映射到离其最近的节点上去。当有节点出现故障离线时，按照算法的映射方法，受影响的仅仅为环上故障节点开始逆时针方向至下一个节点之间区间的数据对象，而这些对象本身就是映射到故障节点之上的。
动画算法总体概览图: 动画算法总体概览图
文章中使用的动画网站地址，限 pc: 一致性哈希 算法动画
http://www.donghuasuanfa.com/platform/portal?pc=consistent-hashing
传统Hash算法 假设现在一共有3个服务器和n个数据，需要将数据存储到服务器上。那么传统的做法是将数据进行Hash算法，然后与3取模。取模结果为数据映射服务器的结果。
数据计算和定位服务器过程如下图1-1所示
图1-1 映射计算结果如下图1-2所示
图1-2 如果新增加一个服务器，因为服务器数量变更。则需要对n个数据重新进行映射。重新计算的过程耗时耗力。
为了解决上述问题，则发明出一致性hash算法。
算法步骤 生成Hash环 一：首先将232的节点生成一个虚拟圆环，称为Hash 环。Hash环的节点为0、1、2…232-1 。
类似钟表，钟表是12个小时节点组成的圆环。而 Hash 环是是由 232幂组成的圆环。详情如图2-1所示
图2-1 定位服务器 服务器需要加入到集群中。则需要定位服务的节点位置，定位过程为通过服务器ip计算Hash结果。然后结果与232取模。结果肯定为0~232-1中的某一个数字。取模结果对应的环中的位置就是服务器的所在位置。
详情如图2-2所示
图2-2 定位数据和映射服务器 现在有数据需要定位到服务器，传统的方式可以为与服务器个数进行取模预算，取模结果为映射到的服务器。例如共有3个服务器。数据与3进行取模，结果为0。则数据定位到第一个服务器。
一致性hash处理数据的步骤如下：
一：将数据进行Hash计算。计算结果与232次幂取模，取模结果定位到Hash环上。
二：通过数据所在位置，沿顺时针寻找最近的服务器，然后数据定位到对应的服务器。
详情如图2-3所示
图2-3 服务器变更 现集群中有3个服务器和4个数据。其中张三、李四、王五定位的服务器为第一台红色服务器，赵六定位的服务器为第二台绿色服务器。
假设第二个服务器宕机了，则逆时针寻找宕机的服务器与存活服务器时间的数据。图中需要处理的数据为赵六数据节点。重新定位的逻辑依旧为顺时针定位寻找存活的服务器。图中赵六重新定位的结果为第3个蓝色服务器。
新增服务器时同理，只需要重新计算新服务器和新服务器逆时针顺序的第一个服务器的中间数据即可。不用全量重新计算所有数据。
详情如图3-1所示
图3-1 Hash环倾斜 当环上服务器较少时，容易造成数据与服务器分布均匀。如图4-1所示。张三、李四、王五三个数据都映射到了红色服务器，但是其他服务器所对应的数据较少。这种分布不均匀的情况称为Hash环倾斜。
图4-1 虚拟节点 为了解决Hash环倾斜的问题，一致性hash算法增加了虚拟节点解决问题。即对服务器节点计算多个Hash值，然后将多个Hash结果定位到Hash环上。环上的服务器节点越多，则数据映射服务器越均匀。详情如图5-1所示。
图5-1 总结 算法解决的问题:解决集群中数据映射定位服务器，当集群中增加或减少服务器数量时，需要重新对所有数据进行计算的问题。
算法过程:
2.1 首先将232的节点生成一个虚拟圆环，称为Hash 环。
2.2 对服务器进行hash计算并与232进行取模计算，取模结果为hash环所在位置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0f0a654a77c4965840b054c0af78e17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90a3361f8dd26e3ae5fd4df7c91ad2a2/" rel="bookmark">
			Postgres使用CDC监控数据变化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、wal_level设置为logical
修改postgresql.conf文件，将其中的wal_level值修改为logical，重启服务，验证show wal_level的值应该为logical。
2、创建插槽
SELECT* FROM pg_create_logical_replication_slot('slot_test', 'test_decoding');
以后数据的变化都可以从该插槽中读取
-- pg新建用户 CREATE USER ODPS_ETL WITH PASSWORD 'odpsETL@2021'; -- 给用户复制流权限 ALTER ROLE ODPS_ETL replication; -- 给用户数据库权限 grant CONNECT ON DATABASE test to ODPS_ETL; -- 设置发布开关 update pg_publication set puballtables=true where pubname is not null; -- 把所有表进行发布 CREATE PUBLICATION dbz_publication FOR ALL TABLES; -- 查询哪些表已经发布 select * from pg_publication_tables; -- 给表查询权限 grant select on TABLE aa to ODPS_ETL; -- 给用户读写权限 grant select,insert,update,delete ON ALL TABLES IN SCHEMA public to bd_test; -- 把当前库所有表查询权限赋给用户 GRANT SELECT ON ALL TABLES IN SCHEMA public TO ODPS_ETL; -- 把当前库以后新建的表查询权限赋给用户 alter default privileges in schema public grant select on tables to ODPS_ETL; -- 更改复制标识包含更新和删除之前值 ALTER TABLE test0425 REPLICA IDENTITY FULL; -- 查看复制标识 select relreplident from pg_class where relname='test0425'; -- 查看solt使用情况 SELECT * FROM pg_replication_slots; -- 删除solt SELECT pg_drop_replication_slot('zd_org_goods_solt'); -- 查询用户当前连接数 select usename, count(*) from pg_stat_activity group by usename order by count(*) desc; -- 设置用户最大连接数 alter role odps_etl connection limit 200; 3、读取变化
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90a3361f8dd26e3ae5fd4df7c91ad2a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cc68286e9eee9475b6cddfe2135e888/" rel="bookmark">
			PDManer 入门教程：超强代码生成工具！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是树哥！
对于使用 Spring 全家桶作为开发的小伙伴来说，MyBatis 基本上是最佳的选择。当我们开发一个新的项目的时候，我们都会用 MyBatis Generator 去生成代码，并且还会生成对应的 Controller 层、Service 层、Dao 层代码。有一说一，这种方式确实非常方便，极大节约了广大工程师的开发时间。
但是像 MyBatis Generator 这样的工具也有这样的问题：命令行界面操作非常笨拙不友好、换个新的电脑又得重新弄一遍，真是非常麻烦！于是我在想：是否有一个图形化界面可以来操作生成代码，还能把之前的设置导出成文件，下次新的电脑直接恢复设置就可以了？
我们能想到的，已经有很多人想到，又做到了！PDManer 就是这样一款软件，它以图形化界面的形式帮助我们管理数据库模型，生成 Java 代码 等等，兼职就是开发同学的最佳伴侣啊！
今天就让我带着大家介绍下这款软件，并且送给大家一套我使用了很久的代码生成模板，让大家开发效率再次起飞！
软件安装 PDManer 可在起官网下载，下载地址为：http://www.pdmaner.com/download/v4.1.5。官网提供了多种下载方式，建议可用付费 1 元的方式高速下载，即节省了时间又支持了开源工具，一举两得。
下载完成之后是正常的安装流程，这里不再赘述。
创建项目 下载安装完成后打开软件，点击左侧新建按钮，新建一个新的项目，如下图所示。
创建完成之后，我们可以看到如下图所示的界面，里面列出了数据库表、数据字典等信息。
我们可以直接在这里面建表，后续也可以直接导出这里面的建表语句。这里我是通过数据库导入已建好的表，因此我选择右上角的数据库按钮。
填写好对应的数据库连接信息，随后点击导入按钮，选择从数据库导入。
随后选择具体的数据库，接着选择要导入的表格，点击确定之后就开始导入了。导入完成后，导入的表会在数据表处显示。
随后我们随意选择其中某张表格，可以看到对应的数据表信息、索引信息、数据库代码、程序代码。
其中程序代码标签，就是生成 Java 代码的地方。软件提供了多种语言，以及多种方式的代码生成，例如 Java 语言就提供了 Java Bean、MyBatisPlus 等三种。其中 MyBatisPlus 还提供了 Controller 层、Service 层、Mapper 层等文件代码的生成功能，如下图所示。
## 配置代码生成器
为了能更方便地使用生成的代码，所以我们需要对生成的代码进行配置。我们可以根据我们的项目规范，将对应层的代码生成到不同的目录下。我们点击路径及变量按钮，弹出对应的配置窗口，如下图所示。
我们需要修改的就是上图红框中的位置，主要来说有四大类，分别是：
保存位置：一般填项目所在目录。例如我的项目名为 shopping-mall，那么我就填上这个项目所在磁盘的位置即可，例如：D:\code\shopping-mall。
nameSpace：保存项目包名前缀。例如我项目某个 Controller 路径为：tech.shuyi.controller.ShopController，那么项目包名就是 tech.shuyi。
codeRoot：默认是表名，这里可以不需要修改。
生成文件映射：修改生成文件的映射位置。文件的保存位置为：保存位置属性 + 映射值，跟上面写的 nameSpace 没关系。
由于上面保存位置我写的是项目的根目录，那么模板这里就从项目根目录写起，一直到具体的包的位置，随后用 {{=it.codeRoot}} 来表示动态类名。下面是我常用的文件映射配置，大家可以根据自己的情况自己参考下。
src/main/java/tech/shuyi/controller/{{=it.codeRoot}}Controller.java src/main/java/tech/shuyi/service/{{=it.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cc68286e9eee9475b6cddfe2135e888/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99ae0357c137c2c952c6821317baa430/" rel="bookmark">
			用这些 JavaScript 试题来提高你的编程技能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、解释 Promise 的概念和用法。二、解释节流（throttle）和防抖（debounce）在 JavaScript 中的应用场景。三、请列举 JavaScript 中的原始数据类型。四、请解释JavaScript中的作用域。五、写一个名为 multiply 的函数，接受两个参数 a 和 b ，返回它们的乘积。六、写一个函数 reverseString ，接受一个字符串参数，并返回反转后的字符串。七、给定一个数组，编写一个函数 findMax ，找出数组中的最大值并返回。八、创建一个构造函数 Car，包含属性 brand（品牌）、model（型号）和 year（生产年份）以及一个方法 getInfo ，该方法返回车辆的品牌、型号和生产年份的字符串表示。九、解释箭头函数的特点和用法。十、解释JavaScript中的原型链。十一、解释JavaScript中的闭包，并提供一个简单示例。十二、如何使用JavaScript选取DOM元素？十三、编写一个函数addClass，接受一个DOM元素和一个类名作为参数，将类名添加到元素的classList属性中十四、解释JavaScript中的try-catch语句 一、解释 Promise 的概念和用法。 在 JavaScript 中，Promise 是一种处理异步操作的方式。Promise 对象表示一个尚未完成，但将来会完成的操作，以及该操作的结果。Promise 是一种解决回调地狱（Callback Hell）的方式，可以使异步代码更加清晰和易于理解。
Promise 的基本概念是，一个 Promise 对象代表着一个异步操作，该异步操作可能处于以下三种状态之一：
等待状态（Pending）：异步操作尚未完成，Promise 处于等待状态。完成状态（Fulfilled）：异步操作已经成功完成，Promise 处于完成状态，可以获取到操作的结果。拒绝状态（Rejected）：异步操作失败，Promise 处于拒绝状态，可以获取到错误信息。 Promise 对象有一个 then() 方法，该方法接收两个回调函数作为参数，一个用于处理操作成功的情况，一个用于处理操作失败的情况。当 Promise 对象处于完成状态时，执行成功的回调函数；当 Promise 对象处于拒绝状态时，执行失败的回调函数。
例如，以下是一个使用 Promise 的例子，读取一个文件的内容：
const fs = require('fs'); function readFile(path) { return new Promise(function(resolve, reject) { fs.readFile(path, 'utf8', function(err, data) { if (err) { reject(err); } else { resolve(data); } }); }); } readFile('example.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99ae0357c137c2c952c6821317baa430/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a560c7d3f9b8065b57f17b75e5fd0d3/" rel="bookmark">
			python 画图时各种颜色代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		颜色搭配 点击配色：https://culrs.com/#/red
颜色协调的原则是避免颜色选择过度，能够表达清晰明了的设计主题。以下是一些通用的基本颜色搭配方案，其中每种方案都包括9种颜色： 红色、黄色、浅绿色、鲑鱼色、紫罗兰色、淡蓝色、白色、浅灰色和黑色；橙色、浅黄色、青色、棕色、粉色、浅绿色、紫色、银灰色和蓝色；黄色、绿色、红色、白色、黑色、灰色、蓝色、天蓝色和深蓝色；灰色、浅灰色、黄色、紫色、绿色、白色、黑色、天蓝色和深蓝色；蓝色、紫色、深绿色、金黄色、黄色、橙色、红色、玫瑰色和棕色；深绿色、宝蓝色、橙色、蓝绿色、白色、红色、黄色、深棕色和灰色；奶油色、宝蓝色、深蓝色、黄色、白色、深灰色、棕色、天蓝色和红色；灰色、米色、橙色、棕色、青色、绿色、紫色、金黄色和深蓝色；北极蓝、钴蓝、岩黄色、赭色、石墨灰、浅桔色、蕃茄红、艳红色、银灰色。 #FF0000（红色）、#FFFF00（黄色）、#90EE90（浅绿色）、#FF8C69（鲑鱼色）、#8B00FF（紫罗兰色）、#87CEFA（淡蓝色）、#FFFFFF（白色）、#D3D3D3（浅灰色）和 #000000（黑色）
#FFA500（橙色）、#FFFFE0（浅黄色）、#00CED1（青色）、#A52A2A（棕色）、#FFC0CB（粉色）、#90EE90（浅绿色）、#800080（紫色）、#C0C0C0（银灰色）和 #0000FF（蓝色）
#FFFF00（黄色）、#008000（绿色）、#FF0000（红色）、#FFFFFF（白色）、#000000（黑色）、#808080（灰色）、#0000FF（蓝色）、#87CEEB（天蓝色）和 #00008B（深蓝色）
灰色、浅灰色、黄色、紫色、绿色、白色、黑色、天蓝色和深蓝色：
灰色：#808080浅灰色：#D3D3D3黄色：#FFFF00紫色：#800080绿色：#008000白色：#FFFFFF黑色：#000000天蓝色：#87CEEB深蓝色：#00008B 蓝色、紫色、深绿色、金黄色、黄色、橙色、红色、玫瑰色和棕色： 蓝色：#0000FF紫色：#800080深绿色：#006400金黄色：#FFD700黄色：#FFFF00橙色：#FFA500红色：#FF0000玫瑰色：#FFC0CB棕色：#A52A2A 深绿色、宝蓝色、橙色、蓝绿色、白色、红色、黄色、深棕色和灰色： 深绿色：#006400宝蓝色：#1E90FF橙色：#FFA500蓝绿色：#00FFFF白色：#FFFFFF红色：#FF0000黄色：#FFFF00深棕色：#654321灰色：#808080 奶油色、宝蓝色、深蓝色、黄色、白色、深灰色、棕色、天蓝色和红色： 奶油色：#FFFDD0宝蓝色：#1E90FF深蓝色：#00008B黄色：#FFFF00白色：#FFFFFF深灰色：#A9A9A9棕色：#A52A2A天蓝色：#87CEEB红色：#FF0000 灰色、米色、橙色、棕色、青色、绿色、紫色、金黄色和深蓝色： 灰色：#808080米色：#F5DEB3橙色：#FFA500棕色：#A52A2A青色：#00CED1绿色：#008000紫色：#800080金黄色：#FFD700深蓝色：#000080 北极蓝、钴蓝、岩黄色、赭色、石墨灰、浅桔色、蕃茄红、艳红色、银灰色： 北极蓝：#00BFFF钴蓝：#4682B4岩黄色：#FFB451赭色：#A0522D石墨灰：#43464B浅桔色：#FFE4B5蕃茄红：#FF6347艳红色：#FF69B4银灰色：#C0C0C0 在代码中的使用 import numpy as np import matplotlib.pyplot as plt x = ['Rank-1', 'mAP'] IFGSM = [4.04,3.36] MI = [1.60,1.37] VMI = [1.57,1.42] SI = [3.86,3.35] IG =[1.87,1.75] SMI = [1.66,1.39] IG_MI =[1.78,1.68] GSMI =[1.37,1.24] EGSMI = [1.28,1.20] # 创建柱状图 fig = plt.figure(figsize=(12, 8)) #fig, ax = plt.subplots(12,8) x_pos = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a560c7d3f9b8065b57f17b75e5fd0d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3180ed3c12eeef7f0441d5c34988ec53/" rel="bookmark">
			SpringBoot配置消息转换器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录
一、何为消息转换器
二、默认的消息转换器
三、SpringBoot配置自定义消息转换器
1. 注册fastjson消息转换器
2. 将消息转换器配置到集合中
四、注意事项
五、总结
一、何为消息转换器 要想理解消息转换器，首先得知道消息是什么，在使用SpringMVC框架时，由前端发请求给后端，请求体中的内容就被称为消息，另外反过来，由后端发给前端的响应数据也是消息，那消息转换器又是来干嘛的呢？其实就是实现消息与Java对象的相互转换，将请求体中的消息转为Java对象，反过来将Java对象转为响应体中的消息，所以其实SpringMVC中的@RequestBody和@ResponseBody注解就是干的这个事。
二、默认的消息转换器 在SpringBoot项目中由于导入了web-start依赖，在org.springframework.web.servlet.config.annotation包下面的WebMvcConfigurationSupport类，在这个下面有个addDefaultHttpMessageConverters方法就是设置默认的消息转换器集合。下面是源码：
protected final void addDefaultHttpMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters) { messageConverters.add(new ByteArrayHttpMessageConverter()); messageConverters.add(new StringHttpMessageConverter()); messageConverters.add(new ResourceHttpMessageConverter()); messageConverters.add(new ResourceRegionHttpMessageConverter()); if (!shouldIgnoreXml) { try { messageConverters.add(new SourceHttpMessageConverter()); } catch (Throwable var3) { } } messageConverters.add(new AllEncompassingFormHttpMessageConverter()); if (romePresent) { messageConverters.add(new AtomFeedHttpMessageConverter()); messageConverters.add(new RssChannelHttpMessageConverter()); } Jackson2ObjectMapperBuilder builder; if (!shouldIgnoreXml) { if (jackson2XmlPresent) { builder = Jackson2ObjectMapperBuilder.xml(); if (this.applicationContext != null) { builder.applicationContext(this.applicationContext); } messageConverters.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3180ed3c12eeef7f0441d5c34988ec53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3be2fc03e9d0645537c0fed7bcbb1d9/" rel="bookmark">
			APR欺骗的防御措施
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 不要把网络安全信任关系，单纯地建立在IP基础上或MAC基础上，理想的关系应该建立在“IP + MAC”基础上。
2.设置添加静态的“ARP映射表”，不要让主机刷新设定好的“ARP映射表”。
3. 除非很有必要，否则停止使用ARP（地址解析协议），将ARP（地址解析协议）作为永久条目保存在“ARP映射表”中。
4.使用ARP服务器，通过该服务器查找自己的“ARP映射表”，以此来响应其他机器的ARP请求广播，并确保这台ARP服务器不被黑。
5.IP的传输，使用“proxy”代理。
6. 使用硬件屏蔽主机，设置好路由，确保IP地址能到达合法的路径（静态配置路由ARP条目）。
7. 使用防火墙连续监控网络。注意有使用SNMP（简单网络管理协议）的情况下，ARP欺骗有可能导致陷阱包丢失。
8.若感染ARP病毒，可以通过“清空ARP缓存、指定ARP对应关系、添加路由信息、使用防病毒软件”等方式解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb215671174d96136e0857d872014a7a/" rel="bookmark">
			python基础-文件操作（打开、读取、写入等）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、文件的基本操作 文件打开的格式： file = open（文件路径，读写模式） 文件路径：可以写相对路径，也可以写绝对路径读写模式：r（读取） w（写入） a（追加） 文件打开后，必须关闭，否则持续消耗服务器性能。 # 文件读写,在使用的时候和我们正常使用文件一样 # 1.打开文件 # 2.操作文件 # 3.关闭文件 # 打开文件使用open函数即可 # 格式: open(file_name(文件路径), mode(读写模式)) 使用该函数会返回一个文件对象 # 文件路径:可以写相对路径, 也可以写绝对路径,路径需要以字符串形式传入 # 读写模式: r(只读) w(写入) a()追加 file = open('python.txt', 'r') print(file) # &lt;_io.TextIOWrapper name='python.txt' mode='r' encoding='UTF-8'&gt; 在windows中默认读写格式是gbk print(type(file)) # &lt;class '_io.TextIOWrapper'&gt; # 将读取出来的内容进行打印 print(file.read()) # 关闭文件 file.close() # 为什么要关闭文件? # 在文件打开状态是会保持连接,这种状态下会持续消耗内存,不利于服务器性能优化(内存泄漏) # 关闭文件后,文件对象有没有被释放? # 没有释放 print(file) # &lt;_io.TextIOWrapper name='python.txt' mode='r' encoding='UTF-8'&gt; # 文件关闭后,相当于与文件的连接状态消失了,但是文件对象没有发生变化 # 在文件关闭后,file对象不能进行任何读写操作,因为已经无法连接文件 # ValueError: I/O operation on closed file.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb215671174d96136e0857d872014a7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f87c7cf8f916b3158a7f72a5be7af36/" rel="bookmark">
			快速排序-Python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🚀快速排序（Quick Sort）是一种高效的排序算法，其基本思想是通过一趟排序将待排序记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，然后再按此方法对这两部分记录继续进行排序，以达到整个序列有序的目的。快速排序是一种分治策略的实现。
🏃‍快速排序的基本步骤如下： 选择一个基准元素（pivot）：从待排序序列中选择一个元素作为基准元素。分割（partitioning）：将待排序序列中的所有比基准元素小的元素放到基准元素的左边，所有比基准元素大的元素放到基准元素的右边。此时，基准元素在序列的中间位置。递归地对左边和右边的子序列进行快速排序。 🌤Python的实现可以参考以下代码示例：
def quick_sort(arr): if len(arr) &lt;= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x &lt; pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x &gt; pivot] return quick_sort(left) + middle + quick_sort(right) def main(): arr = [3, 6, 8, 10, 1, 2, 1] print("原始数组：", arr) sorted_arr = quick_sort(arr) print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f87c7cf8f916b3158a7f72a5be7af36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ee5bbd6280b1afa7c64dada42b9fcb7/" rel="bookmark">
			mybatisplus主键字段id每次保存，id都很大，并不是从序列开始自增的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 数据库 postgresql
mybatisPlus框架
一个注意点
主键字段id一定要加入这个注解，不然新增的id很大很大！！！十位数左右那么大！
@TableId(value = "id", type = IdType.AUTO) private Long id; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59a22c6d5e0edc5b9aaf77d5bebbd1aa/" rel="bookmark">
			vue2下npm安装国际化i18n包报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如题 我项目是vue2，在terminal控制台输入以下指令安装时报错：
npm install vue-i18n --save
原因 在vue2环境下，默认安装 npm install vue-i18n 的版本是 vue-i18n@9.2.2，
报错信息里写了，人家这个版本要求是vue3，所以我们需要安装适合vue2版本的vue-i18n 依赖包。
tips：适合vue2的版本很多，除了9以外貌似都可以
解决 运行指令查看所有版本：
npm view vue-i18n versions --json
[ '0.0.0', '0.1.0', '0.1.1', '0.1.2', '0.2.0', '0.11.0', '1.0.0', '1.1.0', '1.1.1', '2.0.0', '2.1.0', '2.2.0', '2.3.0', '2.3.1', '2.3.2', '2.3.3', '2.4.0', '2.4.1', '3.0.0', '3.1.0', '3.1.1', '4.0.0', '4.0.1', '4.1.0', '4.2.0', '4.2.1', '4.2.2', '4.2.3', '4.3.0', '4.3.1', '4.4.0', '4.4.1', '4.5.0', '4.6.0', '4.7.0', '4.7.1', '4.7.2', '4.7.3', '4.7.4', '4.8.0', '4.9.0', '4.10.0', '5.0.0', '5.0.1', '5.0.2', '5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59a22c6d5e0edc5b9aaf77d5bebbd1aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea97d92d52fc2cc04f8eb1c8ca2f2052/" rel="bookmark">
			什么是GPIO？(详细介绍)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以STM32F4系列的单片机做例子
一.引入 单片机最小系统的组成： 芯片 + 供电电路 + 复位电路 + 时钟（晶振）电路
一个完成的系统的组成 最小系统 + 项目所需要的其他硬件（外设）
芯片： 整个系统的核心 相当于人类的大脑 会提供引脚与外部电路相连接 引脚（俗称 官方称呼“GPIO”）
二. GPIO GPIO是什么？ General Purpose Input Output 通用功能输出输出 GPIO就是从芯片内部引出来一根功能复用的口线（电线）
功能复用是指：GPIO的引脚可以由CPU配置成不同的功能 比如：输入功能 输出功能 模拟功能 复用功能等等
分析GPIO内部结构图如picture/STM32F4XX_GPIO内部结构.PNG 通过图我们可以得知 每个GPIO可以独立地被配置成不同的功能。 GPIO配置功能如下： (1)输入功能 CPU可以通过该GPIO的来获取外部电路输入的一个电平状态 输入功能又可以分为几种模式： a.带上拉的输入（input pull-up）
默认接一个上拉电阻 此时就算IO引脚没有外部输入信号时 CPU也能读到一个高电平 只有在外部电路输入低电平的时候 CPU读取到的才是低电平
b.带下拉的输入 默认接一个下拉电阻 此时就算IO引脚没有外部输入信号时 CPU也能读到一个低电平
只有在外部电路输入高电平的时候 CPU读取到的才是高电平 c.输入悬空
既不接上拉电阻 也不接下拉电阻 这种情况下 IO引脚的电平状态完全由外部输入所绝对 此时CPU可以通过读取数据的
操作来获取外部电路的工作状态
d.模拟输入
该引脚被设置为模拟输入的时候 能够获取到模拟信号 通过ADC转换为数字量
(2)输出功能 CPU可以通过该GPIO口往外部输出一个电平状态（相当于可以控制外部电路工作）
输出功能也可以分为以下两种模式 a.输出推挽 （PP: push-pull）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea97d92d52fc2cc04f8eb1c8ca2f2052/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8df457acd1757daf5f5e4fce3722dd8c/" rel="bookmark">
			Java常见的100道面试题（内附答案及代码示例）持续更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是Java程序？
Java程序是一组可执行的代码，由Java编译器编译生成，可以在Java虚拟机（JVM）上运行。 public class HelloWorld { public static void main(String[] args) { System.out.println("Hello, World!"); } } Java中的变量有哪些类型？
Java中的变量有八种基本类型：byte、short、int、long、float、double、char和boolean。 int age = 25; String name = "John Doe"; double salary = 5000.50; boolean isEmployed = true; 什么是Java包？
Java包是一种用于组织类和接口的机制。它可以将相关的类和接口组合在一起，以便更好地管理和维护代码。 package com.example.mypackage; public class MyClass { // class implementation } Java中的继承是什么？
继承是Java中的一种机制，它允许一个类（称为子类）继承另一个类（称为父类）的属性和方法。 public class Animal { String name; int age; public void eat() { System.out.println("Animal is eating"); } } public class Dog extends Animal { String breed; public void bark() { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8df457acd1757daf5f5e4fce3722dd8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/debd12a752ef7f49748ac2fea843da59/" rel="bookmark">
			如何成为企业急需的技术人才：掌握这些技能，提升你的实力和竞争力
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在当前竞争激烈的互联网环境中，作为程序员等技术岗，必须不断的学习，才能不断提升自身实力，锻炼自身技能。想要成为一名企业急需的技术人才，需要学习哪些技能呢？
一、IT技术发展背景及历程 IT技术是当今社会中最为热门和发展迅速的领域之一，涉及到计算机、互联网、移动设备、软件开发和信息安全等多个方面。IT技术的发展历程可以追溯到二十世纪的计算机产业的兴起，下面是IT技术发展的背景和历程：
一、计算机产业的兴起
计算机产业的兴起可以追溯到20世纪40年代，第二次世界大战期间，美国政府为了解决军事计算问题，开始大量投资研发计算机。到了50年代，计算机逐渐商业化，IBM、UNIVAC等公司开始生产商用计算机。60年代，计算机开始进入企业和政府机构，完成大量数据处理工作。二、互联网的出现
互联网作为IT技术中的重要组成部分，最初是由美国国防部的研究项目ARPANET发展而来。1983年，ARPANET正式切换到TCP/IP协议，成为现代互联网的雏形。随着互联网的普及，互联网技术快速发展，出现了万维网、搜索引擎、电子商务等各种新型应用。三、移动设备的普及
移动设备的普及可以追溯到20世纪90年代，当时手机开始普及，移动通信开始逐渐发展。2007年，苹果公司推出了第一款iPhone，从此智能手机进入了一个全新的时代。智能手机的兴起，推动了移动互联网的发展，移动应用、移动支付等各种新型应用层出不穷。四、软件开发的变革
软件开发在IT技术中占据着非常重要的地位。随着互联网和移动设备的普及，软件开发开始发生变革。传统的软件开发模式逐渐被敏捷开发、DevOps等新型开发模式所取代。同时，云计算、人工智能、区块链等新兴技术的发展，也为软件开发带来了更多的可能性。五、信息安全的挑战
随着互联网和移动设备的快速发展，信息安全问题也逐渐成为了IT技术发展中的重要问题。黑客攻击、数据泄露、网络病毒等安全问题层出不穷，对企业和个人的安全造成了威胁。因此，信息安全技术也逐渐成为了IT技术中的重要组成部分。 IT技术的发展历程可以追溯到计算机产业的兴起，经历了互联网的出现、移动设备的普及、软件开发的变革和信息安全的挑战等多个阶段。IT技术的发展给我们带来了巨大的变革和机遇，未来IT技术的发展也将继续引领着社会的进步和发展。
二、IT行业吃香技能TOP榜探讨 IT行业是当今社会中最为热门和发展迅速的领域之一，涉及到计算机、互联网、移动设备、软件开发和信息安全等多个方面。随着科技的不断发展，IT行业中的技能也在不断更新和升级。下面我们来探讨一下IT行业吃香技能TOP榜，看看哪些技能最为热门和受欢迎。
一、人工智能
人工智能是IT行业中最热门的技能之一。随着大数据和云计算的发展，人工智能技术也得到了快速发展。人工智能技术已经被应用于各个领域，如自然语言处理、机器学习、计算机视觉等。具备人工智能技能的IT人才在市场上非常抢手。二、云计算
云计算是IT行业中另一个非常热门的技能。随着企业对IT资源的需求不断增长，云计算技术被广泛应用于数据存储、应用开发、网络管理等方面。具备云计算技能的IT人才在企业中非常受欢迎。三、大数据
大数据技术是IT行业中另一个非常热门和吃香的技能。随着数据量不断增长，企业需要大数据技术来处理和分析这些数据。具备大数据技能的IT人才在企业中非常抢手，市场需求量也非常大。四、网络安全
随着企业信息化程度的不断提升，网络安全问题也越来越受到重视。具备网络安全技能的IT人才在企业中非常紧缺。网络安全技能包括渗透测试、防火墙配置、安全漏洞修复等方面。五、移动应用开发
随着移动设备的普及，移动应用开发也成为了IT行业中的热门技能之一。移动应用开发技能包括iOS和Android平台的开发、移动应用界面设计等方面。具备移动应用开发技能的IT人才非常受欢迎。 IT行业中的技能不断更新和升级，不同的技能在不同的时间段和市场环境下都有其独特的优势和吃香程度。通过掌握这些热门技能，IT人才可以提升自身实力和竞争力，更好地适应市场需求和发展趋势。
拿我现在正在做的开发岗位来说吧，不断学习是必须的。只有不断学习新技能，才能适应新的技术环境和市场需求，才能不断提升自身实力和竞争力。那么，作为一名企业急需的技术人才，哪些技能是必不可少的呢？
一、编程语言
编程语言是程序员最重要的工具之一。不同的编程语言适用于不同的应用场景。因此，作为一名企业急需的技术人才，需要掌握至少一种主流的编程语言。例如，Java、Python、PHP、C++、C#等语言，都是市场需求较高的编程语言。此外，随着大数据和人工智能的兴起，掌握一些应用于这些领域的编程语言，如R语言、Scala等也可以有很好的前景。二、前端技术
前端技术是指网页开发中用于处理网页展示和交互的技术。前端技术的发展也很快，因此作为一名企业急需的技术人才，需要掌握一些主流的前端技术。例如，HTML、CSS、JavaScript、jQuery、Vue.js等。这些技术可以帮助你开发出更美观、更实用的网页，提升用户体验。三、后端技术
后端技术是指网站服务器端的技术。作为一名企业急需的技术人才，需要掌握一些主流的后端技术。例如，Java Servlet、JSP、PHP、ASP.NET等。此外，随着云计算的兴起，云计算技术也成为了后端技术的重要组成部分。因此，掌握云计算技术，如AWS、Azure等也是非常有前途的。四、数据库
数据库是企业中非常重要的数据存储和管理工具。因此，作为一名企业急需的技术人才，需要掌握一些主流的数据库技术。例如，MySQL、Oracle、SQL Server等。此外，NoSQL数据库也是近年来发展迅速的数据库技术，掌握一些NoSQL数据库技术也非常有必要。五、安全技术
随着互联网应用的普及，网络安全问题越来越受到重视。因此，作为一名企业急需的技术人才，需要掌握一些主流的安全技术。例如，网络攻防、数据加密、安全漏洞修复等。此外，了解一些常用的安全工具，如Wireshark、Nmap等也是非常有必要的。六、团队协作
作为一名企业急需的技术人才，团队协作也是非常重要的。因此，需要掌握一些团队协作工具，如Git、SVN等版本控制工具，JIRA、Trello等项目管理工具，Slack、QQ群等即时通讯工具。这些工具可以帮助你更好地与团队协作，提高开发效率。 作为一名企业急需的技术人才，需要不断学习新技能，适应新的技术环境和市场需求。掌握上述技能可以让你更好地适应市场需求，提高自身实力和竞争力，成为一名更加优秀的技术人才。
三、如何学习这些TOP技能 自学：可以通过网络上的各种教程、博客、视频等资源自学相关技能。例如，可以通过在网上查找相关的学习资料或者参加在线课程学习。参加培训和课程：可以参加线下或线上的培训和课程，学习相关技能。例如，可以通过参加大学或者公开课程、IT培训机构的课程等途径学习相关技能。参加实践项目：可以通过参加实践项目锻炼自己的技能，提高自己的实战能力。例如，可以参加开源项目、参与社区贡献等途径。参加社区和论坛：可以通过参加相关技术社区和论坛，与其他技术爱好者交流，学习相关技能。例如，可以参加知名的技术社区如Github、Stack Overflow等。找到行业专家进行指导：可以通过找到具有相关技能和经验的行业专家进行指导和学习。例如，可以通过参加行业会议、参加技术讲座等途径，与行业专家进行交流和学习。 学习这些TOP技能需要持续不断地学习和实践，通过多种途径获取知识和技能，并不断提升自己的能力。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd48ea8c038a3d93aee9140ca3139209/" rel="bookmark">
			数仓建设规划核心问题！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小A进入一家网约车出现服务公司，负责公司数仓建设，试用期主要一项 OKR是制定数据仓库建设规划；因此小 A 本着从问题出发为原点，先对公司数仓现状进行一轮深入了解，理清存在问题，然后在以不忘初心原则提出解决问题方案。相信很多数据建设者在公司发展某个阶段时都会遇到类似小 A 公司问题，也在思考或已经在执行落地解决这些问题方案，希望通过小 A 案例可以给大家一些启发。下面先看看小 A 公司数仓现状与问题
01 数据仓库现状 小 A 公司创建时间比较短，才刚过完两周岁生日没多久；业务增长速度快，数据迅速增加，同时取数需求激增与数据应用场景对数据质量、响应速度、数据时效性与稳定要求越来越高；但技术能力滞后业务增长，如实时数仓技术能力、高可用稳定保障能力、流程规范缺少等，这些能力严重滞后业务发展，甚至有些还是停留在公司创建初期 case by case 阶段。小 A 根据数据在数仓流向（以下图），从上游的业务系统测到数仓内部最后到下游数据应用梳理数据仓库建设存在问题。
业务系统侧【上游】 数据仓库首先需要对业务系统结构化业务数据、日志数据与埋点数据进行归集；数仓与上游业务系统对接主要存在以下问题:
缺失业务系统数据模型清单与变更同步：没有对已归集到数仓业务系统数据模型记录，业务系统数据模型发送变更也没有对数仓知会，更多是出现问题后或者是数据使用者事后告知数仓。
缺少统一枚举值编码与变更同步：业务系统没有统一枚举值编码，如订单状态有：下单、接单、成单，没有统一对这些枚举值进行管理；如果后面对订单状态再增加一个：取消单状态，这种变更也没有对数仓进行知会。
业务部门搭建各自小数仓：有些部门绕过数仓直接接入上游数据源，搭建各自的小数仓，从而导致数据孤岛、重复计算、口径不一致。
存在业务盲区：有些业务需要专业知识背景如：财务；有些业务规则保密级别高，无法对非业务相关员公开业务逻辑，如风控；因此无法系统梳理这些业务实体与实体之间关系，提炼指标，共享数据。
数仓内部 公司创建初期，数据量比较小、数据需求也不多、数据应用场景也比较单一更多是为了满足一下简单报表，因此数仓主要是以接单方式驱动工作，来一个需求做一个，case by case，主要是为了快速响应需求。但随着业务迅速增加，数据量暴涨，数据应用场景多样化，慢慢暴露出以下问题：
流程规范缺少：没有流程与规范指引数据开发者根据流程对数据进行规范化建设，导致数据分层分类不清晰，数据混乱；命名不规范，同义不同名，同名不同义；数据重复建设，冗余数据多。
没有体系化技术设计：无论是离线或实时数据采集、处理与分发都缺少体系化设计与搭建，更多是在前期 case by case 上面修修补补；例如在离线与实时对同一数据源进行采集；无差别对所有数据源每次全量抽取与 DWD 到 DWS 层无差别全量计算；T+1 与每小时批处理烟囱开发，同一宽表离线与实时烟囱开发、重复计算与存储；对不同应用场景无差别使用相同存储与计算等等；
影响无互相隔离：数仓数据存储与计算，没有与数据应用服务存储与技术隔离，存在互相之间资源抢占与问题被放大情况；同时也存在数仓底层模型设计很难兼容数据应用层模型设计需求
数据应用测【下游】 数仓需要为不同数据应用场景（风控、C 端、业务运营等）提供数据，不同数据应用需求是不一致的，存在很多差异；同时数据在不同应用场景价值也是不一样的。因此需要清楚了解下游数据应用场景与存在问题才可以更好服务数据应用方，下游主要存在以下问题：
对数据应用场景不了解：对下游数据需求应用场景不了解或者没有深入了解，没有针对不同场景评估技术选型，简单粗暴使用一招打天下，对不同场景使用一套计算与存储。
不知道数据被哪些应用访问：没有对下游应用对数据使用监控与记录，无法对数据使用情况与价值进行量化
没有量化数据需求优先级：对下游数据需求没有优先级评估机制，没有量化数据需求优先级
没有自助取数工具：下游没有取数能力，导致大部分的取数工作还是依赖数据开发来完成。数据开发大部分的时间都被临时取数的需求占据，根本无法专注在数仓模型的构建和集市层数据的建设，最终形成了一个恶性循环，一方面是数据不完善，另一方面是数据开发忙于各种临时取数需求。
数据接入方式多样，接入效率低：每个数据应用都要根据不同的中间存储，开发对应的代码，如果涉及多个中间存储，还需要开发多套代码，数据接入效率很低。
数据质量问题：数据经常因为 BUG 导致计算结果错误，最终导致错误的商业决策。
02 如何解决问题 业务系统侧【上游】 与业务系统侧协同需要跨部门沟通与合作，因此需要沟通流程与标准，让双方聚焦在公共目标；同时也要维护好你好我好的共存关系。主要是针对事前、事中、事后提出解决方案。
事前：与上游建立知会机制与协同流程，及时同步业务与模型变更；接管 ODS 层，控制源头，ODS 是业务数据进入数仓的第一站，是所有数据加工的源头，控制住源头，才能从根本上防止一个重复的数据体系的出现。
事中：通过技术手段捕捉上游元数据与字典值变更，从而方便以后问题追踪与影响分析
事后：通过事后复盘优化流程与迭代技术
数仓内部 数仓内部主要是要从技术体系、流程规范与数据架构等几个维度去解决这些问题。
制定流程与规范
数据开发流程：
数据开发规范：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd48ea8c038a3d93aee9140ca3139209/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ab835b4d251c5f484a65da164ae7c26/" rel="bookmark">
			数学建模之模拟退火法（SA）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		算法介绍 模拟退火算法（SA）是一种模拟物理退火过程而设计的优化算法。
它的基本思想最早在1953年就被Metropolis提出，但直到1983年，Kirkpatrick等人才设计出真正意义上的模拟退火算法并进行应用。
模拟退火算法采用类似于物理退火的过程。先在一个高温状态下，然后逐渐退火，在每个温度下慢慢冷却，最终达到物理基态（相当于算法找到最优解）。
算法应用 求解TSP问题、求最值、全局优化、生产调度、控制工程、机器学习、信号处理等问题。
算法特性 模拟退火算法源于对固体退火过程的模拟，采用Metropolis准则，并用一组称为冷却进度表的参数控制算法的进程，使得算法在多项式时间里可以给出一个近似最优解。
模拟退火算法在某一初温下，伴随温数的不断下降，结合概率突跳特性在解空间中随机寻找目标函数的全局最优解。即在局部最优解的空间内能概率性地跳出并最终趋于全局最优。（不在局限于局部最优）
算法名词解释 退火：将固体加热到足够高的温度，使分子呈随机排列状态，保持足够的时间，然后以适宜的速度逐步降温。使之冷却，最后分子以低能状态排列，固体达到内能最小的稳定状态。（加温—等温—冷却）
退火过程： 1、在初始状态，固体内部的粒子存在非均匀状态。
2、加热到一定温度，增强其粒子的热运动，使粒子偏离其平衡位置，消除原来的非均匀状态。
3、让温度慢慢降低，达到热平衡状态，粒子逐渐均匀有序，最终达到内能最小的状态。
算法步骤 1.设定当前解（即为当前的最优解）：令T= ，即开始退火的初始温度，随机生成一个初始解 ，并计算相应的目标函数值E( )。
2.产生新解与当前解差值：根据当前解进行扰动，产生一个新解 ,计算相应的目标函数值E( ),得到𝜟𝑬=𝑬( )−𝑬( )。
3.判断新解是否被接受：若𝜟𝑬&lt;𝟎，则新解 被接受；若𝜟𝑬&gt;𝟎，则新解 按概率接受， 为当前温度。
4.当新解被确定接受时：新解 被作为当前解。
5.循环以上四个步骤：在温度 下，重复k次的扰动和接受过程，接着执行下一步骤。
6.最后找到全局最优解：判断T是否已经达到终止温度 ，是，则终止算法；否，则转到循环步骤继续执行。
冷却进度表 退火过程由一组初始参数，即冷却进度表控制。它的目的是尽量使系统达到平衡，以使算法在有限的时间内逼近最优解。
冷却进度表包括：
1.控制温度参数的初值T0
2.控制温度T的衰减函数(温度的更新)
3.马尔科夫链的的长度Lk（迭代次数）
4.控制参数T的终值(停止准则)
组合优化问题
金属物体
解
粒子状态
最优解
能量最低的状态
设定初温
熔解过程
Metropolis接受过程
等温过程
控制参数的下降
冷却
目标函数
能量
模拟退火算法的优缺点 优点：
高效地求解NP完全问题（如TSP问题，0-1背包问题等）。
相较于其他非线性与优化算法，模拟退火算法编程工作量小且易于实现。
缺点：
使用不当，可能会陷入局部最优
参数难以控制，所得结果可能为接近最优解但并非最优解。
案例1：求解TSP问题 问题描述：现有34个城市，已知其坐标；从其中某一城市作为起点出发，途径其他的所有城市，然后回到起点，要求走过的距离最短。
结果如下所示：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f921bd480342e0dfc9b7dadc0f956619/" rel="bookmark">
			优秀开源音乐项目---落雪音乐软件（免费听歌下载歌曲）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在学习Electron的时候在github上看到了一个开源的项目（是一个音乐分享软件）。（重点是大家要经常逛github，上边有很多很好的开源项目，gitee也是类似）下载下来后使用了效果很好，希望给大家分享下。Electron可以简单地理解为web应用打包工具，就是可以将你写好的web项目打包成一个app。想学习的戳这里！！！
很多软件都是使用的Electron打包的！ 使用界面特别简洁明了（界面为vue2.0和JavaScript搭建的） 这个软件是在github上开源的，我们可以轻松获取到源代码并下载到本地使用（windows和mac都可以下载使用该应用） 而且这个application还做了喜好推荐，很多的歌曲都可以找得到！
同时还有很方便的工具列表 还可以设置自己心仪的壁纸，壁纸设计的也是很用心
怎么样，是不是很心动啊，安装方式也是极其简单的。按照github上的安装提示即可成功！
同时需要注意的是，这个项目是开源的，mac用户和windows用户都可以下载使用。我们在使用这个软件的时候要注意不要关闭资源，就是结束进程，把它放在底部状态栏就可以了，切记不要关闭资源。 如果仅仅听歌的话，可以下载新版的app，但是新版的落雪无法下载歌曲，所以只能听歌如果还是想下载歌曲，最好是使用老版本的落雪，可以下载歌曲，然后导入到本地音乐或者使用阿里云网盘导入到手机上，我用的是0.17.0
最后来一点我自己的建议： mac用户可以下载好自己心仪的音乐，并导入mac自带的音乐软件中（最好设置好一个听歌列表）。windows用户可以导入其他的音乐软件中，比如网易云等等。
最后就是附上开源地址！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b66e1ce92666f15060b5d7c32db6579/" rel="bookmark">
			阿里云免费SSL申请及Nginx配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阿里云免费SSL证书创建地址 阿里云免费的证书为digicert的RSA证书，有效期为一年，到期后可重新申请，每年有20个可以申请
如图可以看到创建证书的按钮即可创建属于自己的SSL RSA证书
接下来如图配置提交审核即可
提交审核后，即可在分页栏看到你自己创建的那一项，审核需要点时间，但不用太久就能收到短信的通知
当证书的状态变为已签发的时候，即可下载使用
点击操作栏的下载可以看到
这里我们选择 Nginx 的进行下载
下载后能看到这样的一个zip压缩包
将其上传至你的 nginx 服务器
上传有很多工具，大伙也可以直接sftp 的 put 命令进行上传
上传后，我将该压缩包放在了 /etc/nginx/ssl 中，ssl 这个文件夹是我自己创建的，另外例如我的这个证书的域名是link.ahogek.com，我就会再建一个名为link的文件夹专门放这个压缩包解压出来的一个pem文件和一个key文件。解压可以使用unzip也可以使用unar 的命令
然后就可以开始配置nginx了，我一般在conf.d目录下新建配置文件。例如 /etc/nginx/conf.d/link.conf
server { listen 80; server_name link.ahogek.com; return 301 https://$host$request_uri; } server { listen 443 ssl; server_name link.ahogek.com; ssl_certificate ssl/link/link.ahogek.com.pem; ssl_certificate_key ssl/link/link.ahogek.com.key; ssl_protocols TLSv1.2 TLSv1.3; ssl_ciphers 'TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384'; location / { proxy_pass http://127.0.0.1:8000; } } 在配置文件中，第一个 server 配置用于当用户使用 http 进行访问的时候自动跳转至 https
关于$host $request_uri 相当于请求的host与uri 更多详细可以查看官方文档:http://nginx.org/en/docs/http/ngx_http_core_module.html#variables
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b66e1ce92666f15060b5d7c32db6579/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be9c26dd0f579202c4ac8ae1bac22304/" rel="bookmark">
			Qt连接MySQL数据库最详细的教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 1.直接通过MySQL的驱动加载数据库1）所需代码2）解决QMYSQL driver not loaded 2.通过ODBC连接MySQL数据库１）官方解释2)下载ODBC3)连接MySQL数据库4)qt通过ODBC连接MySQL 3.qt通过ODBC操作数据库1)查询数据2)插入数据3)更新数据 Win10安装MySQL出现错误2503 2502 的解决办法QT使用ODBC连接MySQL 原文链接：https://blog.csdn.net/joey_ro/article/details/105411135
被Qt连接数据库折磨了三天之后终于连接成功了，记录一下希望对看到的人有所帮助。
1.直接通过MySQL的驱动加载数据库 1）所需代码 QSqlDatabase db = QSqlDatabase::addDatabase("QMYSQL"); db.setHostName("127.0.0.1"); db.setPort(3306); db.setDatabaseName("数据库名"); db.setUserName("用户名"); db.setPassword("密码"); bool ok = db.open(); if (ok){ QMessageBox::information(this, "infor", "success"); } else { QMessageBox::information(this, "infor", "open failed"); qDebug()&lt;&lt;"error open database because"&lt;&lt;db.lastError().text(); } 当然要在.pro文件中添加一行引入
QT += sql 如果显示：
那么恭喜你太幸运了，你已经成功连接MySQL数据库了，快去使用吧。
如果显示：
也不要灰心接着往下看我的电脑就一直显示失败
没有QMYSQL的驱动，这是怎么回事呢？
2）解决QMYSQL driver not loaded Qt连接到mysql的过程：app-&gt;Qt的数据库插件-&gt;mysql动态库-&gt;mysql服务。
Qt的数据库插件位于“C:\Qt(安装路径)(Qt版本)\版本号(库)\mingw49_32(编译器)\plugins(插件)\sqldrivers(数据库插件)” 下的qsqlmysqld.dll(debug版本用) qsqlmysql.dll(release版本用).
mysql动态库位于“C:\Qt\MySQLServer5.5(mysql安装路径)\lib”下的“libmysql.dll“
i:将mysql下的ilbmysql.lib和libmysql.dll复制到Qt的bin目录下
ii：查看自己的qt中有没有qsqlmysqld.dll(debug版本用) qsqlmysql.dll(release版本用)
如果都有：
运行一下代码：
//输出可用数据库 qDebug()&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be9c26dd0f579202c4ac8ae1bac22304/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ff80386aa1643923d8f7aa37a409b35/" rel="bookmark">
			Linux环境下后台启动jar包以及停止服务以及每天生成日志文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录： 1、Linux环境下后台启动jar包2、Linux环境下后台停止jar包3、每天生成日志文件命令 1、Linux环境下后台启动jar包 //后台启动且将日志输出到log.out文件中 nohup java -jar XXX.jar &gt;log.out &amp; //用 nohub 命令启动 jar 包，是在后台不挂断运行，关闭终端窗口或者 CTRL + C 命令也不会终止程序。 //当用 nohub命令启动 jar 包的时候，如果不指定日志输出文件，则所有的输出都会被重定向到 nohub.out 的文件中。 nohup java -jar XXX.jar &amp; 2、Linux环境下后台停止jar包 //获取进程方法一 ps aux | grep java //获取进程方法二 jps -l 然后直接kill -9 214170,其实后台启动后出现得数字就是进程pid，不用查，可以直接杀死进程，停止服务。
3、每天生成日志文件命令 nohup java -jar zlfy-server-1.0.0.jar &gt;&gt; /iflytek/server/zouyangTest/logs/nohup-$(date +%Y-%m-%d).log 2&gt;&amp;1 &amp; 如果没有生成每天的日志文件，那需要在linux系统里面添加定时器，每天执行这个命令生成新的日志文件。
编辑定时器 crontab -e 输入如下内容（每天23:59执行一下脚本，内容自己实现（略），大楷意思就是查找进程杀死进程，然后执行每日生成日志的命令） 59 23 * * * 59 23 * * * sh /usr/local/nginx/logs/cutlog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ff80386aa1643923d8f7aa37a409b35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdd9c80f812470601aec37bc2fdd675d/" rel="bookmark">
			比较ClickHouse三种表字段默认值表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ClickHouse表字段支持三种默认值表达式的定义方法，分别是DEFAULT、MATERIALIZED和ALIAS。Default其他RDBMS也支持，比较常用，本文注意介绍后两者表达式的差异，并通过示例分别进行介绍。
数据类型 无论使用哪种形式，表字段一旦被定义了默认值，它便不再强制要求定义数据类型，因为ClickHouse会根据默认值进行类型推断。如果同时对表字段定义了数据类型和默认值表达式，则以明确定义的数据类型为主，例如下面的例子：
CREATE TABLE dfv_v1 ( id String, c1 DEFAULT 1000, c2 String DEFAULT c1 ) ENGINE = TinyLog c1字段没有定义数据类型，默认值为整型1000；c2字段定义了数据类型和默认值，且默认值等于c1。根据默认值的优先级顺序，其中c1字段根据默认值被推断为UInt16；而c2字段由于同时定义了数据类型和默认值，所以它最终的数据类型来自明确定义的String。
alias表达式 alias列没有序列化，是在查询时才计算。因此不适合复杂计算，示例如下：
CREATE TABLE test_new_col ( `_csv` String, `csv_as_array` Array(String) ALIAS splitByChar(';',_csv), `csv_col1` String DEFAULT csv_as_array[1], `csv_col2` String DEFAULT csv_as_array[2] ) ENGINE = MergeTree ORDER BY tuple(); INSERT INTO test_new_col (_csv) values ('a1;b1;c1;d1'), ('a2;b2;c2;d2'), ('a3;b3;c3;d3'); SELECT csv_col1, csv_col2 FROM test_new_col; 查询结果：
Query id: 45e5ded7-3b93-4bc0-b825-47c4310d21cf ┌─csv_col1─┬─csv_col2─┐ │ a1 │ b1 │ │ a2 │ b2 │ │ a3 │ b3 │ └──────────┴──────────┘ 我们再增加一列：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bdd9c80f812470601aec37bc2fdd675d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdc4598288f77690939766b1dc166094/" rel="bookmark">
			全网最全Linux学习路线！十一张原创思维导图涵盖日常全部命令（干货）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		测试、后端、开发、大数据分析&amp;挖掘、AI算法、产品都能无压力掌握的linux重点知识归纳，图形化系统展现要点，你值得拥有！
无论是测试、后端、开发的同学，还是数据分析、挖掘、算法的大佬，甚至是产品人，都值得学习linux，其中对于工作的重要性不言而喻，因为不掌握甚至都无法工作！可以说安卓系统、常见的各类服务器底层包括最近以ChatGPT为代表的生成式对话系统部署都离不开linux的身影。
但是具体怎么学，通常缺乏一篇较为成体系的简明思维导图，导致不知从何学起，或者学到一半就丢失方向，无法系统掌握linux知识，从而在解决实际问题时经常浪费大量时间，例如不明白环境变量的含义，不懂得负载均衡，以及LD_LIBRARY_PATH到底是干嘛的？
学完本文后会让你对linux有一个基础并且全面的认识，能够完全满足日常工作当中所需要的全部命令，此外也会为接下来的深入学习打下坚实基础，少走弯路，接下来就逐一介绍这十一张思维导图的具体内容。（文本有PDF高清资源可供下载）
No.1
linux学习路线
第一张是linux学习路线，包含了基础概念及具体的学习思路，同时也介绍了一些参考书籍及在线教程。
No.2
linux安装与登录
第二张思维导图展现了常见linux图形化界面，可以自选食用（不要贪杯），此外也介绍了系统安装与常用的登陆命令，双系统安装参考这篇妈妈再也不用担心双系统安装了！（最详细！附镜像资源+分区详解+实测教程）。
No.3
linux常用命令
第三张思维导图的内容十分广泛，并且干货满满，系统整理了包含文件命令、远程管理、搜索、压缩、系统信息、SSH、快捷键、文件权限、安装等全部常用命令，非常方便检索。
No.4
linux文件目录操作
第4张思维导图则在前三张思维导图基础上进一步介绍Linux系统目录的配置情况，以及引入非常关键的用户与用户组概念和文件权限操作（防止误删和删库跑路利器）。
No.5
Vi/Vim专项命令
第5张思维导图花一整张图介绍了Vi/Vim一个工具的使用，这将是在linux上进行代码编写与运行最高频使用的工具，涵盖了全系的方法与指令使用，同时也可以作为工具集进行检索。
No.6
linux文本处理
第6张思维导图主要介绍了sed、grep、awk三种文本/字符串处理的利器，各有所长，本质对于文本处理都有高效处理的作用，可以说只要这三个命令用得好，数据预处理可以直接替代python并且运行速度吊打python。
No.7
Shell变量&amp;参数
第7张思维导图则进入到了Shell的学习，Shell编程是linux学习的核心，基本等同于完整的编程语言，先学习变量概念及常用变量类型使用，此外还涵盖了全部的参数传递方式供查阅。
No.8
Shell运算符&amp;测试
第8张思维导图介绍了Shell的全部运算符包括逻辑运算符、关系运算符、字符串运算符、布尔运算符和逻辑运算符等等，以及在数据处理流的高频场景下常用的文件测试运算符。
No.9
Shell IO&amp;重定向
第9张思维导图展现了Shell命令中输入输出相关命令，以及重定向概念，此外还有echo、printf等输出命令的系统说明。
No.10
Shell函数&amp;流程控制
第10张介绍了Shell函数和流程控制，搭配示例使用更容易理解。
No.11
linux网络服务命令
第11张也是最后一张全面引入了网络服务相关命令，包括路由、远程传输等等超实用命令，能够很好地帮助工程师完成日常工作！
总的来说，linux学习入门十分简单，一天基本能过完全部命令，但是学完可能不久之后就会忘，需要反复结合实践进行学习，最好是搭配项目在项目中学习，这样既能完成工作也能使得linux发挥真正的作用，还能积累实际经验促进专业技能提升。
原创不易，关注在看都是莫大的分享动力！有任何问题公众号直接留言～
公众号内直接回复【linux思维导图】即可获取高清PDF下载链接
历史推荐
妈妈再也不用担心双系统安装了！（最详细！附镜像资源+分区详解+实测教程）
保姆级教程教你快速搭建属于自己的AI绘画系统！（收藏）
原创最全数据分析师学习路线+思维导图！文末附PDF下载
GPT-4火爆出圈，GPT-5或年底发布？这儿有一份原创最全NLP学习路线请查收！
Selenium爬取京东商品
数据分析与挖掘
数据结构与算法
深度学习与大数据框架
欢迎关注，感谢“在看”，随缘稀罕~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcfacfa376f045176018a82c271e1917/" rel="bookmark">
			Glang测试算法运行时间、内存占用，解决运行时间为零
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算运行时间传统写法
计算时间太短，运行时间为零，显然不符合要求
可以看到让函数停一秒后能显示加上睡眠时间的运行时间
原因是%d以十进制输出,%v以默认格式输出，运行时间太短丢弃了一部分
解决方法：在包内新建测试文件main_test.go
定义测试函数
func TestAddTwoNumbers(t *testing.T) { // defer是逆序执行，在前面的后执行，先显示时间再显示内存占用 defer memoryUsage(t) defer timeCost(time.Now(), t) // 构造测试数据 l1 := intToListNode(342) l2 := intToListNode(465) expected := intToListNode(807) // 执行函数 result := addTwoNumbers(l1, l2) // 检查结果是否符合预期 if listNodeToInt(result) != listNodeToInt(expected) { t.Errorf("AddTwoNumbers(%v, %v) = %v; want %v", l1, l2, result, expected) } } // 耗时统计函数 func timeCost(start time.Time, t *testing.T) { tc := time.Since(start) t.Logf("time cost:%s\n", tc) } // 统计内存占用 func memoryUsage(t *testing.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dcfacfa376f045176018a82c271e1917/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4a4a492eb217d0e5c34eb11fe2e8a4e/" rel="bookmark">
			多线程之线程安全问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 线程安全
1.1线程安全问题产生的原因
1.1.1 抢占式执行
1.1.2 多个线程同时修改一个变量
1.1.3 修改操作不是原子性
1.1.4 内存可见性问题
1.1.5 指令重排序
1.2 加锁
1.2.1 synchronized 的使用方式
1.2.2 synchronized 的特性
1.2.3 死锁
1.2.3.1 死锁的三种情况:
1.2.3.2 死锁形成的四个必要条件:
1.3 Java 标准库中的线程安全类
1.4 volatile 关键字
1.4.1 volatile 特性
1.4.2 内存可见性
1.4.2.1 从汇编的角度来看内存可见性问题
1.4.2.2 从 JMM 的角度来看内存可见性问题 1.4.3 synchronized 和volatile 的区别
观前提示:本篇博客演示使用的 IDEA 版本为2021.3.3版本,使用的是Java8(又名jdk1.8)
1. 线程安全 在上一篇博客(多线程之多线程的的三种状态)中,我们在使用 wait 方法的时候,提到了线程安全问题,要解决线程安全问题需要使用 synchronized 方法,简单讲解了一下为什么会有线程安全,这篇博客将详细介绍线程安全问题
一个多线程程序实际的执行顺序有多种变数,在所有的变数下,安全运行,这就是线程安全
1.1线程安全问题产生的原因 可能威胁到线程安全的原因有很多,常见的有以下几种
1.抢占式执行,随机调度
2.多个线程同时修改一个变量
3.修改操作不是原子性
4.内存可见性问题
5.指令重排序
1.1.1 抢占式执行 抢占式执行是指操作系统通过对进程或线程进行优先级调度，并在高优先级进程或线程运行的时候强制暂时停止低优先级进程或线程，从而实现资源的高效利用和任务的快速响应。这种调度方式被广泛应用于多任务操作系统、实时系统或需要快速响应的计算机系统中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4a4a492eb217d0e5c34eb11fe2e8a4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef0d2078b64a2d73b369aafac7597cba/" rel="bookmark">
			DPDK和RDMA的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络的发展好像在各方面都是滞后于计算和存储，时延方面也不例外，网络传输时延高，逐渐成为了数据中心高性能的瓶颈。因为传统两个节点间传输数据的网络路径上有大量的内存拷贝，导致网络传输效率低下，网络数据包的收发处理路径如下图所示：
普通物理机上收发包 虚拟机环境上收发包(从host物理机到虚拟机)
为了解决此问题，有2种方案：RDMA和DPDK
一：RDMA RDMA（ Remote Direct Memory Access，远程直接地址访问技术 ）是一种新的内存访问技术，RDMA将服务器应用数据直接由内存传输到智能网卡（固化RDMA协议），由智能网卡硬件完成RDMA传输报文封装，这样就可以让服务器直接高速读写其他服务器的内存数据，而不需要经过操作系统/CPU耗时的处理。具体看如下：
RDMA的内核旁路机制允许应用与网卡之间的直接数据读写，规避了TCP/IP的限制，将协议栈时延降低到接近1us。RDMA的内存零拷贝机制，无需在应用程序内存和操作系统中的数据缓冲区之间复制数据。这样的传输不需要CPU、缓存或上下文切换器完成任何工作，大幅度降低了消息传输中的处理延迟，同时传输与其他系统操作并行进行，提高了网络传输的性能。
传统模式和RDMA模式的对比
通过对比传统模式和RDMA模式对发送和接收数据的处理过程，RDMA技术最大的突破在于给数据中心通信架构带来了低时延、超低的CPU和内存资源占用率等特性。
低时延主要体现在RDMA的零拷贝网络和内核旁路机制。零拷贝网络网卡可以直接与应用内存相互传输数据，消除了在应用内存与内核内存之间的数据复制操作，使传输延迟显著降低。内核内存旁路机制使应用程序无需执行内核内存调用就可向网卡发送命令。在不需要任何内核内存参与的条件下，RDMA请求从用户空间发送到本地网卡，再通过网络发送给远程网卡，这就减少了在处理网络传输流时内核内存空间与用户空间之间环境切换的次数，降低了网络时延。
超低CPU和内存资源占用率主要体现在应用程序可以直接访问远程内存，而不占用远程服务器中的任何CPU资源，远程CPU中的缓存资源也不会被访问的内容填满，服务器可以将几乎100%的CPU资源和内存资源提供给计算或其他的服务，节省了服务器资源占用的同时，提高了服务器数据处理带宽。
二：DPDK DPDK是Data Plane Development Kit的缩写。简单说，DPDK应用程序运行在操作系统的User Space，利用自身提供的数据面库进行收发包处理，绕过了Linux内核态协议栈，以提升报文处理效率。
DPDK是一组lib库和工具包的集合。最简单的架构描述如下图所示：
上图蓝色部分是DPDK的主要组件（更全面更权威的DPDK架构可以参考Intel官网），简单解释一下：
PMD：Pool Mode Driver，轮询模式驱动，通过非中断，以及数据帧进出应用缓冲区内存的零拷贝机制，提高发送/接受数据帧的效率
流分类：Flow Classification，为N元组匹配和LPM（最长前缀匹配）提供优化的查找算法
环队列：Ring Queue，针对单个或多个数据包生产者、单个数据包消费者的出入队列提供无锁机制，有效减少系统开销
MBUF缓冲区管理：分配内存创建缓冲区，并通过建立MBUF对象，封装实际数据帧，供应用程序使用
EAL：Environment Abstract Layer，环境抽象（适配）层，PMD初始化、CPU内核和DPDK线程配置/绑定、设置HugePage大页内存等系统初始化
这么说可能还有一点点抽象，再总结一下DPDK的核心思想：
用户态模式的PMD驱动，去除中断，避免内核态和用户态内存拷贝，减少系统开销，从而提升I/O吞吐能力
用户态有一个好处，一旦程序崩溃，不至于导致内核完蛋，带来更高的健壮性
HugePage，通过更大的内存页（如1G内存页），减少TLB（Translation Lookaside Buffer，即快表） Miss，Miss对报文转发性能影响很大
多核设备上创建多线程，每个线程绑定到独立的物理核，减少线程调度的开销。同时每个线程对应着独立免锁队列，同样为了降低系统开销
向量指令集，提升CPU流水线效率，降低内存等待开销
下图简单描述了DPDK的多队列和多线程机制：
DPDK将网卡接收队列分配给某个CPU核，该队列收到的报文都交给该核上的DPDK线程处理。存在两种方式将数据包发送到接收队列之上：
RSS（Receive Side Scaling，接收方扩展）机制：根据关键字，比如根据UDP的四元组&lt;srcIP&gt;&lt;dstIP&gt;&lt;srcPort&gt;&lt;dstPort&gt;进行哈希
Flow Director机制：可设定根据数据包某些信息进行精确匹配，分配到指定的队列与CPU核
当网络数据包（帧）被网卡接收后，DPDK网卡驱动将其存储在一个高效缓冲区中，并在MBUF缓存中创建MBUF对象与实际网络包相连，对网络包的分析和处理都会基于该MBUF，必要的时候才会访问缓冲区中的实际网络包
对比： DPDKRDMA网络层 硬件中断-&gt;放弃中断流程；
用户层通过设备映射取包-&gt;进入用户层协议栈-&gt;逻辑层-&gt;业务层；
核心技术 1）将协议栈上移到用户态，利用UIO技术直接将设备数据映射拷贝到用户态
2）利用大页技术，降低TLB cache miss，提高TLB访问命中率
3）通过CPU亲和性，绑定网卡和线程到固定的core，减少cpu任务切换
4）通过无锁队列，减少资源的竞争
协议栈硬件offload优势 1）减少中断次数；
2）减少内存拷贝次数
3）绕过linux的协议栈，用户获得协议栈的控制权，能够定制化协议栈以降低复杂度；
1）协议栈offload，解放cpu
2）减少了中断和内存拷贝，降低时延
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef0d2078b64a2d73b369aafac7597cba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdb8b91e4c2a9c101c3d1fc8c2a757f2/" rel="bookmark">
			SpringSecurity OAuth2实现单点登录,微信扫码登录,Redis缓存验证码---入门到实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 认证授权 1.1 什么是认证授权 ​ 例如课程发布后用户通过在线学习页面点播视频进行学习。如何去记录学生的学习过程呢？要想掌握学生的学习情况就需要知道用户的身份信息，记录哪个用户在什么时间学习什么课程，如果用户要购买课程也需要知道用户的身份信息。所以，去管理学生的学习过程最基本的要实现用户的身份认证。
​ 认证授权模块实现平台所有用户的身份认证与用户授权功能。
​ 用户身份认证即用户去访问系统资源时系统要求验证用户的身份信息，身份合法方可继续访问。常见的用户身份认证的表现形式有：用户名密码登录，微信扫码等方式。
​ 本案例基于黑马程序员2023版的学成在线-Plus中的第五章认证授权v3.1。
1.1.1 什么是用户认证 项目包括学生、学习机构的老师、平台运营人员三类用户，不管哪一类用户在访问项目受保护资源时都需要进行身份认证。比如：发布课程操作，需要学习机构的老师首先登录系统成功，然后再执行发布课程操作。创建订单，需要学生用户首先登录系统，才可以创建订单。如下图：
1.1.2 什么是用户授权 ​ 用户认证通过后去访问系统的资源，系统会判断用户是否拥有访问资源的权限，只允许访问有权限的系统资源，没有权限的资源将无法访问，这个过程叫用户授权。比如：用户去发布课程，系统首先进行用户身份认证，认证通过后继续判断用户是否有发布课程的权限，如果没有权限则拒绝继续访问系统，如果有权限则继续发布课程。如下图：
1.2 单点登录 ​ 用户只需要认证一次便可以在多个拥有访问权限的系统中访问，这个功能叫做单点登录。
​ 引用百度百科：单点登录（Single Sign On），简称为 SSO，是目前比较流行的企业业务整合的解决方案之一。SSO的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。
​ 如下图，用户只需要认证一次，便可以在多个拥有访问权限的系统中访问。
1.3 第三方认证 ​ 为了提高用户体验，很多网站有扫码登录的功能，如：微信扫码登录、QQ扫码登录等。扫码登录的好处是用户不用输入账号和密码，操作简便，另外一个好处就是有利于用户信息的共享，互联网的优势就是资源共享，用户也是一种资源，对于一个新网站如果让用户去注册是很困难的，如果提供了微信扫码登录将省去用户注册的成本，是一种非常有效的推广手段。
​ 微信扫码登录其中的原理正是使用了第三方认证，如下图：
2. Spring Security 认证研究 2.1 Spring Security 介绍 ​ 认证功能几乎是每个项目都要具备的功能，并且它与业务无关，市面上有很多认证框架，如：Apache Shiro、CAS、Spring Security等。由于本项目基于Spring Cloud技术构建，Spring Security是spring家族的一份子且和Spring Cloud集成的很好，所以本项目选用Spring Security作为认证服务的技术框架。
​ Spring Security 是一个功能强大且高度可定制的身份验证和访问控制框架，它是一个专注于为 Java 应用程序提供身份验证和授权的框架。
​ 项目主页：https://spring.io/projects/spring-security
​ Spring cloud Security： https://spring.io/projects/spring-cloud-security
2.2 认证授权入门 2.2.1 认证测试工程 ​ 下边我们使用Spring Security框架快速构建认证授权功能体系。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bdb8b91e4c2a9c101c3d1fc8c2a757f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e7ee28cd393a546527bc5f6a8a64aed/" rel="bookmark">
			华为ensp基础命令的学习（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		eNSP(Enterprise Network Simulation Platform)是一款由华为提供的、可扩展的、图形化操作的网络仿真工具平台，主要对企业网络路由器、交换机进行软件仿真，完美呈现真实设备实景，支持大型网络模拟，让广大用户有机会在没有真实设备的情况下能够模拟演练，学习网络技术。
本部分为ensp基础知识命令+相关实验，自己总结的相关知识点，仅供参考！！
一、先介绍一下华为eNSP命令基础 &lt;Huawei&gt; #用户试图 [Huawei] #系统视图 &lt;Huawei&gt;system-view #进入系统视图 Enter system view, return user view with Ctrl+Z. [Huawei]interface GigabitEthernet 0/0/1 #进入端口视图 [Huawei-GigabitEthernet0/0/1]quit #退出视图 [Huawei] 两种退出视图： 1. [Huawei]return #直接退到用户视图下面 &lt;Huawei&gt; 2.ctrl +z =return 二、命令行功能 命令行功能ctrl+C #停止当前命令的运行ctrl+z#回到用户试图，同等returnctrl+] #停止当前的连接或切换连接 Tab键#命令补全？ #查找命令相关内容 三、命令等级 用户等级命令等级名称00访问10 and 1监控20,1,and 2配置3-150,1,2,and3管理 四、命令行功能 display version #查看路由器VRP基本信息 display interface GigabitEthernet 0/0/0 #查看端口信息 display ip interface brief #查看全部接口的IP信息，含IP地址 display ip routing-table #查看路由表 （比较重要） display current-configuration #查看当前配置信息 save #退出保存，否则会丢失配置 dir flash: #最终保存文件在flash里 reboot #重启设备 display this #查看当前端口下的配置 五、关于telnet（远程连接）和console的交换配置 拓扑图如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e7ee28cd393a546527bc5f6a8a64aed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41f140247a2fea2c40cbd8b2011cf7c5/" rel="bookmark">
			【Python】京东抢购脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 问题背景2 设计思路3 具体实现3.1 账号登录获取登录二维码获取Ticket验证 Ticket 3.2 库存监听获取商品详情信息查询库存 3.3 购物车操作取消所有选中商品加入购入车修改购物车商品数量 3.4 订单操作获取结算单提交订单 3.5 其他模块3.5.1 微信通知3.5.2 日志模块3.5.3 打包成APP模块3.5.4 参数模块 4 参考文献 1 问题背景 编写脚本监听商品库存，一旦查询到货源便开始尝试自动下单。
2 设计思路 京东对于商品的抢购主要分为两种：
预约抢购：到点开放购买，和普通商品下单流程一致；秒杀商品：单独的抢购接口和下单流程。 当然本次针对的预约抢购类或无货订购类，即整体下单流程和购买普通商品时一样：
登录账号 → 进入购物车 → 选择抢购商品 → 点击去结算 → 点击提交订单 → 选择付款方式并付款。
3 具体实现 采用京东 WEB 端接口实现我们的脚本程序。
于是经过对京东网页下单流程的分析，将我们的脚本程序分为四个模块：
账号登录模块库存监听模块购物车管理模块订单管理模块 3.1 账号登录 由于使用账号密码时有验证码限制，此处采用扫码登录方式绕过。
本次主要针对京东登录页进行抓包分析，找到几个有用接口.
获取登录二维码 def getQRcode(self): url = 'https://qr.m.jd.com/show' payload = { 'appid': 133, 'size': 147, 't': str(int(time.time() * 1000)), } headers = { 'User-Agent': self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41f140247a2fea2c40cbd8b2011cf7c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19767853087d46217e0fa3a412272da2/" rel="bookmark">
			BatchNormalization和LayerNormalization的理解、适用范围、PyTorch代码示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 为什么要NormalizationBatchNormLayerNormtorch代码示例 学习神经网络归一化时，文章形形色色，但没找到适合小白通俗易懂且全面的。学习过后，特此记录。 为什么要Normalization 当输入数据量级极大或极小时，为保证输出数据有效，参数必需被训练到一个极小或极大的区间，而这对初始化来说非常困难，且多层网络链式法则求导会导致梯度消失或爆炸的问题。
Reference：神经网络为什么要归一化
归一化的具体计算过程：CSDN博客
BatchNorm BN适用于大多数Dataframe样式的常规数据。
BN对每个特征进行归一化，如下图，分别计算身高归一化后的数据、体重归一化后的数据、年龄归一化后的数据。好理解。
LayerNorm 对于NLP数据，不适用于BN。
BN的逻辑是每个变量来自于某一特定分布，虽然每次只计算一个batch内的数据，但第一个batch（如前64名同学）的身高和第二个batch（后64名同学）的身高，大概率来自同样的分布。
而对文本数据来说，所有句子的第一个词不一定来自同一分布，第二个词也是。每个句子的长度也不同，对句子末尾几个词作BN就相当于对最长句子的最后一个词和一堆padding值作BN，没有意义。
这里就要用到LN，即对每条样本作归一化，即“横着”归一化。
torch代码示例 BatchNorm: 参考pytorch BatchNorm参数详解，计算过程
# BatchNorm import torch.nn as nn Class Net: def __ init__(): self.bn = nn.BatchNorm1d(20,affine=True) pass def forward(x): # x:(N,L)，对L个变量分别进行normalization out = self.ln(x) # out: (N,L) LayerNorm: 参考pytorch 层标准化 LayerNorm 的用法
# LayerNorm import torch.nn as nn Class Net: def __ init__(): self.ln = nn.LayerNorm(W,elementwise_affine=True)	# 只对最后一个维度 self.ln = nn.LayerNorm([H,W],elementwise_affine = True)	# 对最后两个维度，即均值、方差一起求，拉伸成一个维度 pass def forward(x): # x: (N, H ,W)，对最后几个维度进行normalization out = self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19767853087d46217e0fa3a412272da2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb102feeacefbc9ed7a09d70315ab774/" rel="bookmark">
			移除元素【数组】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		⭐前言⭐ ※※※大家好！我是同学〖森〗，一名计算机爱好者，今天让我们进入练习模式。若有错误，请多多指教。更多有趣的代码请移步Gitee
👍 点赞 ⭐ 收藏 📝留言 都是我创作的最大的动力！
题目 27. 移除元素
题目：
给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。
不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。
元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
示例1
输入：nums = [3,2,2,3], val = 3 输出：2, nums = [2,2] 解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。 示例2
输入：nums = [0,1,2,2,3,0,4,2], val = 2 输出：5, nums = [0,1,4,0,3] 解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。 提示
0 &lt;= nums.length &lt;= 1000 &lt;= nums[i] &lt;= 500 &lt;= val &lt;= 100 思路 题目分析:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb102feeacefbc9ed7a09d70315ab774/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2652be08d1dcc731afd9c550ba1200b0/" rel="bookmark">
			Android双屏异显
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、环境介绍
二、设备介绍 ​编辑 使用场景
三、编写代码
1.添加权限
2.创建副屏DisplayPresentation类
3.创建PresentationActivity启动类
4.主屏操控副屏
5.完整代码链接:
前言 双屏异显可以用在各种窗口服务系统,信息发布系统,如收银机,广告机等。记录一下使用方法~
一、环境介绍 Android 系统版本:Android 7.1 Android 12 Android Studio Electric Eel | 2022.1.1
jdk-18.0.2
二、设备介绍 使用场景 安卓平板接一个HDMI显示器,显示器为副屏~
三、编写代码 首先创建一个android程序, 创建过程就不多讲了~
1.添加权限 AndroidManifest中增加权限,代码如下:
&lt;!-- 申请悬浮权限 --&gt; &lt;uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW"/&gt; &lt;uses-permission android:name="android.permission.SYSTEM_OVERLAY_WINDOW" /&gt; 动态申请权限:
if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.M) { //启动Activity让用户授权 if (!Settings.canDrawOverlays(this)) { Intent intent = new Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION, Uri.parse("package:" + getPackageName())); startActivityForResult(intent, 1000); return; } } 2.创建副屏DisplayPresentation类 继承Presentation, Presentation其实就是一个Dialog DisplayPresentation简单实现了一个全屏的webview,用来加载网页~
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2652be08d1dcc731afd9c550ba1200b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6af9ee9bc2bebd7f0e2a889db1a6498/" rel="bookmark">
			ImportError: cannot import name ‘Celery‘ from ‘celery‘ (/root/.virtualenvs/venv/lib/python3.7/site-p
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 django导入celery报错 在安装python虚拟环境后celery不能正常导入使用了
python ----- 3.7.7
celery ------ 4.4.7
ImportError: cannot import name 'Celery' from 'celery' (/root/.virtualenvs/venv/lib/python3.7/site-packages/cel ery/__init__.py) 解决办法： 重新安装 importlib-metadata，且 版本必须小于5
pip3 uninstall importlib-metadata pip3 install importlib-metadata==4.13.0 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f9eeccc9fc9e8cff549fd07ec65cd2e/" rel="bookmark">
			模拟退火
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.起源 模拟退火（Simulated Annealing，SA）是一种启发式算法，用于在大规模搜索空间中寻找最优解或接近最优解的解。其灵感来自于固体物理学中的固体退火过程，即将材料加热到足够高的温度并逐渐冷却，从而使其原子或分子的排列达到最稳定的状态。
2.原理 模拟退火算法是一种用于求解大规模组合优化问题的随机搜索算法，利用问题的求解过程与熔化物体退火道过程的相似性,采用随机模拟物体退火过程来完成问题的求解，t也就是在控制参数(温度)的作用下对参数的值进行调整，直到所选取的参数值最终使能量函数达到全局极小值。
3.步骤 1.初始化： 针对问题选择合适的目标函数f作为能量函数E；
确定起始温度、终止温度、冷却率、单一迭代次数；
2.设定起始迭代次数t=0,产生初始状态X0，计算能量E0;
3.以目前解为中心由状态产生函数产生新的邻近解X1，计算能量E1；
4.采用Metropolis接受法则比较两状态的能量，判决是否接受X1，若接受，则令当前状态为X1,若不接受，仍为X0；
Metropolis接受法则：以概率接受新状态，若Ej&lt;Ei，则接受j为当前状态；
否则，若概率p=exp[-(Ej-Ei)/KT]大于[0,1)区间的随机数，则仍接受状态j为当前状态；
若不成立，则保留状态i为当前状态。
5.更新迭代次数，判断是否达到设定的阈值k，若是则进行降温；
6.判断温度是否达到终止温度，若是则顺序执行step7,若否则转到step3；
7.当前解作为最优解输出。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50dddb49fddffd744912c06d32e3867b/" rel="bookmark">
			IDEA中切换分支同步代码的方法---Git篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在日常开发中，我们经常需要在生产（正式）分支和开发（测试）分支来回切换，或者将开发分支的代码同步到生产分支中去，接下来小编将给出两种超方便的方法
方法一：智能优选（Cherry-Pick），该方法适用于合并代码的时间间隔短且只有一次提交的情况下 第一步切换分支，已经将内容提交至开发分支中去，此时我们需要切换到开发分支上 第二步进行优选，切换完成之后找到我们需要合并的代码，我们按图中提示进行优选（Cherry-Pick）就完成了 方法二：从两个分支不同的内容中进行优选
第一步还是和方法一的第一步操作相同，先切换分支，此处就不再过多解释了第二步如图中操作 第三步按照自己的需求进行合并：当我们按照第二步进行操作后会发现多出如下图所示的内容，其中绿色的为当前分支不存在的文件，蓝色为有差异的文件 若为绿色（不存在的文件）且是需要合并的文件，则可以直接右键拉代码
若为蓝色（有差异的文件）则可以选择查看不同进行选择性合并
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f52bb2e93be654b287275751ff41cd30/" rel="bookmark">
			洛谷入门题·Python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🚀B2003 输出第二个整数 题目描述 输入三个整数，整数之间由一个空格分隔。把第二个输入的整数输出。
输入格式 只有一行，共三个整数，整数之间由一个空格分隔。
输出格式 只有一行，一个整数，即输入的第二个整数。
a=input().split(" ") print(a[1]) 🚀B2036 输出绝对值 题目描述 输入一个浮点数 n，输出这个浮点数的绝对值。
输入格式 输入一个浮点数 n，其绝对值不超过 10000。
输出格式 输出 n 的绝对值，保留到小数点后两位。
a=float(input()) def abs(a):1 if a&gt;0: return a else: return -a print('%.2f'%abs(a)) 🚀B2051 点和正方形的关系 题目描述 展开有一个正方形，四个角的坐标(,y)分别是(1,-1)、(1,1)、(-1,-1)、(-1,1)， 是横轴，y是纵轴。
写一个程序，判断一个给定的点是否在这个正方形内 (包括正方形边界)。 输入格式 输入一行，包括两个整数a,y，以一个空格分开，表示坐标 (a,y). 输出格式 输出一行，如果点在正方形内，则输出 yes ，否则输出 no。
x,y = map(int,input().split()) if -1&lt;=x&lt;=1 and -1&lt;=y&lt;=1: print("yes") else: print("no") 🚀🚀进阶版 import sys def is_point_inside_square(point, square): x, y = point w, h = square return abs(x - w // 2) &lt;= h and abs(y - h // 2) &lt;= w def main(): point_x, point_y = map(float, input().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f52bb2e93be654b287275751ff41cd30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f73c9f8cb6d366e3efa5a869b116672/" rel="bookmark">
			如何在电脑里装虚拟机里装esxi8.0里装Windows
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，打开vm软件，创建新的虚拟机，记得把创建的虚拟机里的cpu虚拟化给打开，不然安装不了esxi,导入esxi软件，随后开启虚拟机，然后等待加载完毕。
正在安装esxi中，等待下方进度条加载满、
按下F11同意，按照他的提示往下走
安装完毕到达此界面，选择第三个选项，打开如图所示的小颜色框，给其配置好IP地址，在本操作系统上按下win+r输入CMD,回车，在命令行里输入ipconfig /all就可查看本操作系统的IP相关信息，在此处填的ｉｐ地址要与你的操作系统在同一网段，才行，配置好，最后将其保存好。
打开浏览器，输入exsi8.0的IP地址，随后进入用户登录界面，输入账号密码，登入
添加存储，并填好名称，点击下一页
输入好名称，选择好相关的操作系统
然后上载操作系统，等待完成
上载完成后点击选择，最后完成
然后进入新安装的系统，运行即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5829bf6c5f9ec551210bfd2ee1f7801/" rel="bookmark">
			Vue3 &#43; Element-UI 搭建一个后台管理系统框架模板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 本文将介绍如何基于Vue3和element-ui搭建一个后台管理系统框架模板。我们将详细讲解代码流程，并提供详细的说明。
技术栈 Vue3Element-uiAxios 前置知识 本文假设读者已经熟悉Vue3和Element-ui的基本使用方法，并且对Axios有一定的了解。
步骤 步骤1：创建Vue3项目 我们可以使用Vue CLI来创建一个Vue3项目，具体步骤如下：
打开命令行工具，在任意目录下输入以下命令：
vue create {项目名称} 选择“Manually select features”选项（手动选择特性），按回车键进入下一步。
按下空格键选择以下特性：
Choose Vue version（选择Vue版本）：选择“3.x”。Babel（使用Babel编译器）：选中。Router（使用Vue Router进行路由管理）：选中。Vuex（使用Vuex进行状态管理）：选中。CSS Pre-processors（使用CSS预处理器）：选中。Linter / Formatter（使用ESLint进行代码检查和格式化）：选中。 确认选择，按回车键进入下一步。
选择CSS预处理器，我们可以使用Sass或Less，这里以Sass为例，按下空格键选中“Sass/SCSS (with dart-sass)”选项，按回车键确认选择。
确认是否使用history模式进行路由管理，这里我们选择“n”（不使用），按回车键进入下一步。
确认是否安装依赖，我们选择“npm”或“yarn”，按回车键确认选择。
等待依赖安装完成，项目创建成功。
步骤2：安装Element-ui 我们可以使用npm或yarn来安装Element-ui，具体步骤如下：
打开命令行工具，在项目根目录下输入以下命令：
npm install element-plus --save 或 yarn add element-plus 等待依赖安装完成，Element-ui安装成功。
步骤3：配置Element-ui 我们需要在main.js中引入Element-ui并按需引入组件，具体步骤如下：
在main.js中引入Element-ui：
import { createApp } from 'vue' import App from './App.vue' import ElementPlus from 'element-plus' import 'element-plus/lib/theme-chalk/index.css' createApp(App).use(ElementPlus).mount('#app') 在需要使用的组件中按需引入：
import { ElButton, ElInput } from 'element-plus' export default { components: { ElButton, ElInput } } 步骤4：封装Axios 我们可以在项目中封装Axios，方便进行网络请求，具体步骤如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5829bf6c5f9ec551210bfd2ee1f7801/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de1c50aed32a1994694a7be8824d17bf/" rel="bookmark">
			Linux内核编程小妙招
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		延时处理 #include &lt;linux/device.h&gt; #include &lt;linux/input.h&gt; #include &lt;linux/jiffies.h&gt; #include &lt;linux/mutex.h&gt; #include &lt;linux/slab.h&gt; #include &lt;linux/types.h&gt; #include &lt;linux/workqueue.h&gt; struct work_poller { void (*poll)(void *dev); unsigned int poll_interval; void *private; struct delayed_work work; }; void poller_queue_work(struct work_poller *poller) { unsigned long delay; delay = msecs_to_jiffies(poller-&gt;poll_interval); if (delay &gt;= HZ) delay = round_jiffies_relative(delay); queue_delayed_work(system_freezable_wq, &amp;poller-&gt;work, delay); } void poller_work(struct work_struct *work) { struct work_poller *poller = container_of(work, struct work_poller, work.work); poller-&gt;poll(poller-&gt;private); poller_queue_work(poller); } int init_polling(struct work_poller *polling, void (*poll_fn)(void *dev)) { polling = kzalloc(sizeof(struct work_poller), GFP_KERNEL); if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de1c50aed32a1994694a7be8824d17bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9997d33f6deaa8f61108d70e030b0e7/" rel="bookmark">
			WSL2 对外暴露端口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考文档
一口气搞定 WSL2 的网络问题从局域网 (LAN) 访问 WSL 2 发行版通过本地网络连接到 WSL2 服务器 按照下面的操作步骤进行操作。
1. powershell 支持 sudo https://github.com/gerardog/gsudo
可以直接下载msi安装：https://github.com/gerardog/gsudo/releases
2. powershell 支持执行脚本 官方文档： PowerShell 执行策略
执行下面的命令：
Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser 3. 编写便捷脚本 在 powershell 中执行 code $profile 使用 vscode 打开配置文件，输入下面的脚本：
function setWslNetsh { param ( $Port ) sudo netsh interface portproxy add v4tov4 listenport=$Port connectaddress=localhost connectport=$Port listenaddress=192.168.1.100 protocol=tcp Write-Output "[OK] Port($Port) now is out!" } function unsetWslNetsh { param ( $Port ) sudo netsh interface portproxy delete v4tov4 listenport=$Port listenaddress=192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9997d33f6deaa8f61108d70e030b0e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54167cbc7e7886fc7745b096bb196052/" rel="bookmark">
			vue3权限的设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue 3 中可以使用 Vue Router 和 Vuex 来实现权限控制。
首先，对于路由的权限控制，我们可以在路由定义时，设置 meta 属性，用于存储该路由的权限信息。例如，我们可以在 router.js 中定义一个路由数组：
import { createRouter, createWebHistory } from 'vue-router' import Home from './views/Home.vue' import Login from './views/Login.vue' import Dashboard from './views/Dashboard.vue' const routes = [ { path: '/', name: 'Home', component: Home, meta: { requiresAuth: false } }, { path: '/login', name: 'Login', component: Login, meta: { requiresAuth: false } }, { path: '/dashboard', name: 'Dashboard', component: Dashboard, meta: { requiresAuth: true } } ] const router = createRouter({ history: createWebHistory(), routes }) export default router 在 meta 中我们可以设置 requiresAuth 属性，用于标识该路由是否需要登录权限，如果需要登录权限则设置为 true，否则设置为 false。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54167cbc7e7886fc7745b096bb196052/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72c6259d37343b5df2b3295432e153af/" rel="bookmark">
			互联网大厂面试最常见的1109 道java 面试题（附答案分享）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 作为一个 Java 程序员，你平时总是陷在业务开发里，每天噼里啪啦忙敲着代码，上到系统开发，下到 Bug 修改，你感觉自己无所不能。然而偶尔的一次聚会，你听说和自己一起出道的同学早已经年薪 50 万，而自己却囊中羞涩。于是你也想看看新机会，找个新平台，好好发展。
但是面试的时候，当那个笑眯眯的面试官问出那些你再熟悉不过的 Java 问题时，你只是感觉似曾相识，却怎么也回答不到点上。比如 HashMap 的工作原理，再或者 volatile 的使用场景。
这个时候，你可能会怀疑自己的能力，也痛恨为什么当初自己没有好好复习。
该新版文档非常全面，包涵 Java 基础、Java 集合、JavaWeb、Java 异常、OOP、IO 与 NIO、反射、注解、多线程、JVM、MySQL、MongoDB、Spring 全家桶、计算机网络、分布式架构、Redis、Linux、git、前端、算法与数据结构、MyBatis、RocketMQ、Netty、Dubbo、Zookeeper、分布式缓存、数据结构等等 1109 道面试题，内容非常丰富，已经帮很多人拿下互联网一线公司的 offer。下面我来跟大家一起分享一下。 JavaOO 什么是 B/S 架构？什么是 C/S 架构Java 都有哪些开发平台？什么是 JDK？什么是 JRE?Java 语言有哪些特点面向对象和面向过程的区别什么是数据结构？Java 的数据结构有哪些？什么是 OOP?类与对象的关系?Java 中有几种数据类型 Java 集合/泛型 ArrayList 和 linkedList 的区别HashMap 和 HashTable 的区别Collection 包结构，与 Collections 的区别泛型常用特点 （待补充）说说 List,Set,Map 三者的区别Array 与 ArrayList 有什么不一样？Map 有什么特点集合内存放于 Java.util 包中， 主要有几 种接口什么是 list 接口说说 ArrayList（数组） Java 异常 Java 中异常分为哪两种？异常的处理机制有几种？如何自定义一个异常try catch fifinally，try 里有 return，finally 还执行么？Excption 与 Error 包结构Thow 与 thorws 区别Error 与 Exception 区别？error 和 exception 有什么区别 Java 中的 IO 与 NIO Java 中 IO 流？Java IO 与 NIO 的区别常用 io 类有哪些字节流与字符流的区别阻塞 IO 模型非阻塞 IO 模型多路复用 IO 模型信号驱动 IO 模型异步 IO 模型JAVA NIO Java 反射 除了使用 new 创建对象之外，还可以用什么方法创建对象？Java 反射创建对象效率高还是通过 new 创建对象的效率高？java 反射的作用哪里会用到反射机制？反射的实现方式：实现 Java 反射的类：反射机制的优缺点：Java 反射 API反射使用步骤（获取 Class 对象、调用对象方法）获取 Class 对象有几种方法利用反射动态创建对象实例 Java 序列化 什么是 java 序列化，如何实现 java 序列化？保存(持久化)对象及其状态到内存或者磁盘序列化对象以字节数组保持-静态成员不保存序列化用户远程对象传输Serializable 实现序列化writeObject 和 readObject 自定义序列化策略序列化 ID序列化并不保存静态变量Transient 关键字阻止该变量被序列化到文件中序列化（深 clone 一中实现） 多线程 &amp;并发 JAVA 并发知识库
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72c6259d37343b5df2b3295432e153af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99f08bf15318f931574fb1fd213db009/" rel="bookmark">
			短视频平台-小说推文（番茄小说）推广任务详情
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 字节旗下平台:番茄小说 今日头条，抖音故事，抖音漫画官方每周只出一次数据!!!!!
预计每周二出上周四之前的数据，有时官方回传数据较晚，会延迟到周三出!
请达人知悉!
注意: 再次强调!番茄拉新规则!
是以设备第一次下载番茄小说后搜的第一个别名为一个有效拉新!!!
不是【第一次下载】番茄的【新设备】不算!
如果用户买的二手机，别人下载过番茄，被刷机，下载也不算!
《番茄每周爆款书单》 https://bytedance.feishu.cn/sheets/shtcn6RaM3VXHz6 kVVgOedOjCOe
点击复制到浏览器打开t
别名审核比较严格，大家申请别名前先查看别名过审攻略:
《别名申请攻略-番茄小说&amp;今日头条》
1.1 关键词 番茄关键词审核时间
周一~周五(周末可提词，结果周二出)
每天上午10:00前提交，第二天18:00点前可查:
(周一~周四 每天10点前 申请关键词 出结果相对较快)注意:
1.关键词字数:3-8个字
2.关键词不可涉黄、涉政，不可蹭已有流量词、符号。字母，空格，标点等不合规行为
3.一个关键词仅能对应一个内容链接:一个内容链接可以对应多个关键词:
4.关键词审核通过，且自己搜索后内容对应才可以作品发布;
5.关键词具有唯一性，多人不能重复使用:
6.有效期6个月;
1.2 回填 同一个关键词选择本周播放量较高的1~3条视频回填即可;
每周四晚上21:00点之前，回填好上周五~本周四的所有数据;
如果某词从最后一次回填到现在已经经历4个周五(即回填有效期28天)，如突然火起来或仍有流量，该关键词须任意【新发一个】作品回填:
1.3 订单 每周二(22:00点之前)更新【截止上周四之前】订单数据;
1.4 结算 单价8元，周结(每周末开始打款，预计2-3天内到
账);
想做副业的立即做任务吧！ 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/90/">«</a>
	<span class="pagination__item pagination__item--current">91/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/92/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>