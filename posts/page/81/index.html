<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d122b8aae43444f17fc8d98d9801635/" rel="bookmark">
			使用Java的反射和字节码操作实现动态代码生成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Java的反射和字节码操作可以实现动态代码生成。下面是一些步骤和示例代码：
1. 获取类对象：使用`Class.forName()`方法或直接使用类名获取类对象。
```java
Class&lt;?&gt; clazz = Class.forName("com.example.MyClass");
```
2. 创建实例：使用`newInstance()`方法创建类的实例。
```java
Object obj = clazz.newInstance();
```
3. 获取方法：使用`getMethod()`或`getDeclaredMethod()`方法获取类的方法。
```java
Method method = clazz.getMethod("myMethod", String.class);
```
4. 调用方法：使用`invoke()`方法调用方法。
```java
method.invoke(obj, "Hello");
```
5. 动态生成类：使用字节码操作库（如ASM、Byte Buddy、CGLIB）来生成类的字节码，并加载生成的类。
下面是一个使用ASM库生成类的示例：
```java
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;
public class DynamicCodeGenerationExample {
public static void main(String[] args) throws Exception {
// 创建ClassWriter对象
ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);
// 定义类的基本信息
cw.visit(Opcodes.V11, Opcodes.ACC_PUBLIC, "com/example/MyClass", null, "java/lang/Object", null);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d122b8aae43444f17fc8d98d9801635/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c65de2d294f402001c92937be2f6270b/" rel="bookmark">
			使用Java的JMX管理和监控应用程序：远程管理和自定义MBean
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java Management Extensions (JMX) 是一种用于管理和监控 Java 应用程序的标准 API。它提供了一套工具和机制，可以远程监控和管理应用程序的各个方面，包括性能监控、配置管理、故障诊断等。
以下是使用Java的JMX进行应用程序管理和监控的一般步骤：
1. 创建管理接口（MBean）：定义应用程序的管理接口，该接口暴露了应用程序的属性、操作和通知等信息。可以使用标准的`javax.management.MXBean`接口或自定义接口实现。
```java
public interface MyAppMBean {
String getAppName();
void setAppName(String name);
int getActiveUsers();
void shutdown();
}
```
2. 实现管理接口：创建一个实现管理接口的类，该类提供了实际的属性和操作实现。
```java
public class MyApp implements MyAppMBean {
private String appName;
private int activeUsers;
public String getAppName() {
return appName;
}
public void setAppName(String name) {
this.appName = name;
}
public int getActiveUsers() {
return activeUsers;
}
public void shutdown() {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c65de2d294f402001c92937be2f6270b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/215d179df02bd6f67dadd43980a36793/" rel="bookmark">
			利用Java的XML和JSON处理库进行数据解析和生成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Java中，有多种库可以用于XML和JSON的数据解析和生成。以下是一些常用的库和示例代码：
1. XML处理库：
- DOM解析：使用Java内置的`javax.xml.parsers.DocumentBuilder`和`org.w3c.dom`包进行DOM解析。
```java
// DOM解析示例
DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
DocumentBuilder builder = factory.newDocumentBuilder();
Document document = builder.parse(new File("data.xml"));
// 处理XML文档
```
- SAX解析：使用Java内置的`javax.xml.parsers.SAXParser`和`org.xml.sax`包进行SAX解析。
```java
// SAX解析示例
SAXParserFactory factory = SAXParserFactory.newInstance();
SAXParser saxParser = factory.newSAXParser();
saxParser.parse(new File("data.xml"), new MyHandler());
// 自定义SAX解析处理器实现org.xml.sax.helpers.DefaultHandler
```
- JAXB解析：使用Java内置的JAXB库进行XML绑定解析。
```java
// JAXB解析示例
JAXBContext context = JAXBContext.newInstance(MyClass.class);
Unmarshaller unmarshaller = context.createUnmarshaller();
MyClass obj = (MyClass) unmarshaller.unmarshal(new File("data.xml"));
```
2. JSON处理库：
- Jackson库：使用Jackson库进行JSON解析和生成。
```java
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/215d179df02bd6f67dadd43980a36793/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ba721880ebf72a5f5b95f6addca7fb1/" rel="bookmark">
			关于float精度缺失和String new对象不对等的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在学习过程中碰到的问题，顺便分享给各位朋友们。
问题一：
public class Demo2 { public static void main(String[] args) { ​ float a=123456789F; float b=a+1; ​ System.out.println(a==b);//ture } } ​ 用bigdecimal数学类处理 ​ 到结果为true，这意味着两个值相等
可我们发现b的值加1应该是123456790
原因：因为float类型的有效位数是8位，double类型的有效位数是16位，结果也就是根据有效位来判断的
这里引发一个问题：我们知道了两个类型的有效位数后，那么我们对两个数据进行运算的结果超出了他们的有效位。结果不是我们想要该怎么办
这个时候我们通常使用大数据类BigDecimal来处理精度失真问题
double a=2.3; double b=1.1; ​ double c=a+b; System.out.println(c);//这个结果出现精度new_c ​ // 使用大数据类BigDecimal 把两个可能会出现两个浮点型精度失真问题的变量，转换成BigDecimal类型 BigDecimal new_a = BigDecimal.valueOf(a); BigDecimal new_b = BigDecimal.valueOf(b); // 使用subtract进行减运算 BigDecimal bd_c=new_a.add(new_b); // 下面把两个值转换回来进行加减乘除就不会出现精度失真 double new_c=bd_c.doubleValue(); System.out.println(new_c); BigDecimal 类中有加减乘除方法：
public BigDecimal add(BigDecimal value) 加法
public BigDecimal subtract(BigDecimal value) 减法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ba721880ebf72a5f5b95f6addca7fb1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd7836173b660a5a712b46218aa91de4/" rel="bookmark">
			Java反序列化漏洞分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java反序列化漏洞（Java Deserialization Vulnerabilities）是一种常见的安全漏洞，其攻击方式是利用Java中的序列化和反序列化机制，通过在序列化数据中插入恶意代码，导致反序列化过程中执行恶意代码。本文将介绍Java反序列化漏洞的原理、攻击方式和防范措施。
一、Java序列化和反序列化机制
Java中的序列化和反序列化机制用于将Java对象转换为字节流，以便于在网络传输或数据存储中使用。Java提供了一个Serializable接口，将实现该接口的Java对象序列化为字节流，并可以通过反序列化将其还原为Java对象。
序列化示例代码：
public class User implements Serializable { private static final long serialVersionUID = 1L; private String username; private String password; public User(String username, String password) { this.username = username; this.password = password; } //getter and setter } //序列化对象 User user = new User("admin", "123456"); ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(user); oos.close(); byte[] bytes = baos.toByteArray(); //bytes即为序列化后的字节数组 反序列化示例代码： //反序列化对象 ByteArrayInputStream bais = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bais); User user = (User) ois.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd7836173b660a5a712b46218aa91de4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90d6290daada425956cef1176c5fc88a/" rel="bookmark">
			【图像去噪】基于图像加噪去噪算法合集附matlab代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✅作者简介：热爱科研的Matlab仿真开发者，修心和技术同步精进，matlab项目合作可私信。
🍎个人主页：Matlab科研工作室
🍊个人信条：格物致知。
更多Matlab仿真内容点击👇
智能优化算法 神经网络预测 雷达通信 无线传感器 电力系统
信号处理 图像处理 路径规划 元胞自动机 无人机 ⛄ 内容介绍 Matlab GUI集成了图像加噪、去噪和压缩三种功能，并附相关源码及操作说明。图像加噪包含高斯、泊松、椒盐、斑点噪声；图像去噪包含中值滤波、维纳滤波、小波滤波、理想低通滤波和高斯低通滤波；图像压缩包含PCA、DCT（离散余弦变换）、FFT（快速傅里叶变换）、位平面行程编码和JPEG。
⛄ 部分代码 function x = jpegdecode(y)
%jpegdecode函数，jpegencode的解码程序
error(nargchk(1, 1, nargin)); %检查输入参数
m = [16 11 10 16 24 40 51 61 %JPEG量化步长矩阵
12 12 14 19 26 58 60 55
14 13 16 24 40 57 69 56
14 17 22 29 51 87 80 62
18 22 37 56 68 109 103 77
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90d6290daada425956cef1176c5fc88a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73bf32dc95a892384e3371a20366641d/" rel="bookmark">
			编写GUI Swing窗口实现爬取酷我音乐MP3格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 代码简单易懂，全文注释，另外代码中包含了一点点的GUI窗口编写代码，如有不懂欢迎提问，同时也欢迎各位大佬多多指教，感谢阅读！
1.引入库 代码如下（示例）：
from tkinter import * from tkinter import messagebox from PIL import Image,ImageTk import requests import json 2.代码主体 代码如下（示例）：
def download(): def main(): # 歌手名称 geshou = str(entry1.get()) # 获取下载歌曲的名称 gequ = str(entry2.get()) for i in range(1, 6): # https://www.kuwo.cn geshou,i url = "http://www.kuwo.cn/api/www/search/searchMusicBykeyWord?key={}&amp;pn={}&amp;rn=30&amp;httpsStatus=1&amp;reqId=2bf0b8c0-5f0a-11eb-8fd0-030dff96f987".format( geshou, i) headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36(KHTML, like Gecko)Chrome/79.0.3945.88 Safari/537.36', 'Referer': 'http://www.kuwo.cn/search/list?key=%E5%91%A8%E6%9D%B0%E4%BC%A6', 'csrf': 'GW5N3I6JE9Q', 'Cookie': '_ga=GA1.2.1345614870.1610439929; Hm_lvt_cdb524f42f0ce19b169a8071123a4797=1610439929,1610687692; _gid=GA1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73bf32dc95a892384e3371a20366641d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d429e4ffe4baf5048acc2a3a3c1c754/" rel="bookmark">
			JFormDesigner 7.0.3 最新版压缩包（IDEA版本）下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近开始学习Java相关的swing，因为想实现可视化开发窗口程序，所以找到了JFormDesigner这个插件，我是使用2020年版的IDEA开发程序的且JDK也也是最新的，所以在这个论坛上看了很多篇帖子想安装这个最新版的插件，但是无奈在这个论坛上最新版的压缩包要积分，所以想在这里把最新版的JFormDesigner（IDEA版本）分享给大家。
JFormDesigner 7.0.3插件（IDEA版本）：
链接：https://pan.baidu.com/s/12kCw7xAw_YYiV3zkMEsL5w
提取码：for5
JFormDesigner_Keygen破解工具的网址：
链接：https://pan.baidu.com/s/1OV6G43jnB9Nw7-zHMICVJA
提取码：qm0h
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc85a8ed6c70f31f7177de1d6dce5834/" rel="bookmark">
			JavaScript 静态方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JavaScript 中的静态方法是指附加到类本身而不是类的实例的方法。它们可以通过类名称直接调用，而不需要创建类的实例。静态方法通常用于执行与类相关的实用函数或操作。
在 JavaScript 中，可以使用 `static` 关键字来定义静态方法。下面是一个示例：
```javascript
class MyClass {
static myStaticMethod() {
console.log('This is a static method.');
}
static anotherStaticMethod() {
console.log('This is another static method.');
}
}
// 调用静态方法
MyClass.myStaticMethod(); // 输出: This is a static method.
MyClass.anotherStaticMethod(); // 输出: This is another static method.
```
在上面的示例中，`myStaticMethod()` 和 `anotherStaticMethod()` 都是 `MyClass` 类的静态方法。通过使用类名称，我们可以直接调用这些方法。
需要注意的是，静态方法不能访问类的实例属性或方法，因为它们与类的实例无关。它们只能访问其他静态成员（如静态属性或其他静态方法）。
此外，静态方法也无法被继承。如果你从一个包含静态方法的类派生出子类，子类将继承父类的实例方法和属性，但不会继承父类的静态方法。
```javascript
class MySubClass extends MyClass {
// 这里定义的是子类的实例方法
myMethod() {
console.log('This is an instance method.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc85a8ed6c70f31f7177de1d6dce5834/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fef794da5b339c273f7ee04285ba05e/" rel="bookmark">
			Android广播发送流程(广播3)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android广播发送流程 1. 广播发送流程2. 广播发送3. 系统处理广播发送3.1 AMS接收广播的请求3.2 修改增加默认flag解析可选广播参数BroadcastOptions3.4 保护广播isProtectedBroadcast、特定action的处理3.5 发送粘性广播的处理3.6 筛选出静态广播接受者3.7 筛选出动态广播接受者3.8 非oder的平行广播的入队与分发3.8 order广播接收者的过滤 4. 广播队列的处理4.1 新建广播队列4.2 广播接收者入队列4.3 广播队列的分发4.4 处理分发下一个广播4.4.1 mParallelBroadcasts平行广播的分发4.4.2 mPendingBroadcast挂起广播的处理4.4.3 取出下一个有序队列中的广播4.4.4 处理下一个接收者nextReceiver4.4.5 发送给动态注册的order注册者4.4.6 静态注册者跳过的逻辑4.4.7 发送给已经启动了的静态注册者4.4.8 启动静态注册接收者的进程 4.5 广播接收者处理完成4.5.1 广播完成，开始下一个广播的调度4.5.2 广播完成finishReceiverLocked 5. 广播的拓展使用 1. 广播发送流程 这次我们讲一下广播发送的流程，老规矩先上大概的流程图
2. 广播发送 常见的通过ContextImpl.java发送广播的方法有下面几种
=&gt; sendBroadcast/sendBroadcastAsUser ：普通的广播发送，默认是当前userId，带有“AsUser”的是发送给特定的user
=&gt; sendBroadcastMultiplePermissions/sendBroadcastAsUserMultiplePermissions ：带有多个权限的广播发送
=&gt; sendOrderedBroadcast/sendOrderedBroadcastAsUser ：发送order有序的广播(order广播是一个接收完成下一个才能接收，接收者一个个按顺序接收)
=&gt; sendStickyBroadcast/sendStickyBroadcastAsUser ：发送粘性广播，粘性广播的意思是注册者注册了就马上能收到该类型(之前已经发送的粘性广播)的广播，
接收者的注册不需要在发送者的前面
=&gt; sendStickyOrderedBroadcast/sendStickyOrderedBroadcastAsUser ：发送粘性而且是顺序order的广播 它们都是调用AMS的broadcastIntentWithFeature来发送广播
如下面是最简单的只有一个Intent的广播发送
//ContextImpl.java @Override public void sendBroadcast(Intent intent) { warnIfCallingFromSystemProcess(); String resolvedType = intent.resolveTypeIfNeeded(getContentResolver()); try { intent.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fef794da5b339c273f7ee04285ba05e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5004009e04f624707cf9b4d6b42e87bc/" rel="bookmark">
			Android进程的adj值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android进程的adj值 1. Android进程的adj值 1. Android进程的adj值 //在未调整adj之前（没有进行初始化过），adj的值是INVALID_ADJ，这个值非常小，也就是优先级很大
static final int INVALID_ADJ = -10000;
//这个是未知的adj，一般cachedAdj的初始值，在cached进程进行重新调整(assignCachedAdjIfNecessary)之前会是这个值
static final int UNKNOWN_ADJ = 1001;
// 从900-999是cached缓存进程adj调整的时候可能存在的值，adj(进程优先级的值)大于等于900代表缓存进程
static final int CACHED_APP_MAX_ADJ = 999;
static final int CACHED_APP_MIN_ADJ = 900;
// 这个是传入lmkd中首先被允许杀死的adj，相当于lmkd里面最大的水位线的adj，
//低于改值将开始杀进程，存放在lmkd.c的lowmem_adj[MAX_TARGETS-1]里面
//不过由于lmkd策略经过很多次更新换代，还有平台商，手机厂家的魔改
//这个值的水位线不一定有在lmkd实际使用
static final int CACHED_APP_LMK_FIRST_ADJ = 950;
// 1. 每个cached进程组之间的adj值的最低间隔
// 2. 同uid或者有服务连接的，而且需要在mLruProcesses是连续紧挨着的，会属于一个组，同组调整是adj最新是+1的差距
// 3. 注意这里只是单次assignCachedAdjIfNecessary的规则(进入时如何还是UNKNOWN_ADJ的才会进行调整)
static final int CACHED_APP_IMPORTANCE_LEVELS = 5;
// B service的优先级，也是服务(SERVICE_ADJ)，只是排在mLruProcesses后面的服务，相对优先级低一点的服务
static final int SERVICE_B_ADJ = 800;
//1. 如果是上一个进程，而且拥有缓存的activity，adj类型是"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5004009e04f624707cf9b4d6b42e87bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be8d7550dda127e1eb3a8bac44d1b826/" rel="bookmark">
			Android 静态广播注册流程(广播2)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android 静态广播注册流程 1. 静态广播注册的流程2. 在AndroidManifest静态注册广播3. AndroidManifest静态注册接受者的安装过程4. 总结 1. 静态广播注册的流程 上一篇文章讲了动态广播的注册(系统存储在mReceiverResolver中)，
这篇文章主要讲解静态广播的注册流程
=&gt; 解析包中的receiver
=&gt; 将receiver相关信息添加到mComponentResolver中
2. 在AndroidManifest静态注册广播 还是以亮屏SCREEN_ON和开机BOOT_COMPLETED静态广播为例子 //在AndroidManifest.xml中定义如下 &lt;receiver android:name=".MyReceiver"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.SCREEN_ON" /&gt; &lt;action android:name="android.intent.action.BOOT_COMPLETED" /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; //MyReceiver.java public class MyReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { Log.e("yunhen", "MyReceiver static intent = " + intent.getAction()); } } 测试发现这个不管是亮屏SCREEN_ON还是开机BOOT_COMPLETED的广播都收不到，
BOOT_COMPLETED没有收到的日志如下(大概意思是少了一个RECEIVE_BOOT_COMPLETED权限定义)： 04-26 09:00:26.506 1337 1549 W BroadcastQueue: Permission Denial: receiving Intent { act=android.intent.action.BOOT_COMPLETED flg=0x89000010 (has extras) } to co
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be8d7550dda127e1eb3a8bac44d1b826/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1747632d332c4674d514d189660d1537/" rel="bookmark">
			Android 动态广播注册流程(广播1)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android 动态广播注册流程 1. 动态广播注册的流程2. 新建一个动态广播接收者3. App部分的registerReceiver4. system_server侧的广播注册5. 总结一下 1. 动态广播注册的流程 先看一下大致文件和流程如下（activity中动态注册广播）：
2. 新建一个动态广播接收者 广播好久之前就准备写了，最近有时间就先把广播这部分写完
这篇文章就先将动态广播注册的流程
先看一下，在一个activity中注册一个亮屏的动态广播
//新建一个BroadcastReceiver，用于接收广播 public BroadcastReceiver mDynamicReceiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { //onReceive是广播处理的时候的接收方法 Log.e("yunhen", "MyReceiver dynamic intent = " + intent.getAction()); } }; //在需要注册广播的时候调用，写下类似下面的代码 //新建一个IntentFilter，意图过滤器 IntentFilter filter = new IntentFilter(); //增加亮屏的行为action filter.addAction(Intent.ACTION_SCREEN_ON); //注册广播，广播接受者是mDynamicReceiver，意图过滤器是filter mContext.registerReceiver(mDynamicReceiver, filter); 3. App部分的registerReceiver activity中的registerReceiver，其调用的是ContextWrapper的registerReceiver //ContextWrapper.java public Intent registerReceiver(@Nullable BroadcastReceiver receiver, IntentFilter filter) { return mBase.registerReceiver(receiver, filter); } 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1747632d332c4674d514d189660d1537/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0256aed055dcd59dac9dc96dda48e07/" rel="bookmark">
			Lua的闭包详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 当一个函数内嵌套另一个函数的时候，内部的函数可以访问外部函数的局部变量，这种特征叫做词法定界。
lua当中函数是一个值，他可以存在变量中，可以作为其他函数的参数，可以作为返回值
function test() local i=0 return function() i++ ... end end //这里的函数作为返回值,这里的i也叫外部局部变量，lua中称为upvalue //这里的内部函数可以访问外部函数test的函数局部变量i 闭包：如果一个函数内部含义一个函数的定义，被包含的函数称为内部函数，包含的函数称为外部函数，这个内部函数能够访问外部函数里面定义的变量，这个变量称为外部局部变量。如果函数作为返回值，则这整个部分被称为闭包。
闭包组成：外部函数+外部函数创建的upvalue+被返回的内部函数（闭包函数）
function test() local i=0 return function()//定义一个函数并返回，这个函数当前没有被调用 i+=1 return i end end c1=test() c2=test()//c1,c2是两个不同的闭包 //闭包中的upvalue各自独立互不影响，调用一次test()就会产生一个新的闭包 print(c1()) --&gt;1 print(c1()) --&gt;2//重复调用时每一个调用都会记住上一次调用后的值，就是说i=1了已经 print(c2()) --&gt;1//闭包不同所以upvalue不同 print(c2()) --&gt;2 闭包在迭代器中的运用:迭代器需要保留上一次调用的状态，刚好可以使用闭包的机制来实现，返回闭包的函数在这时称为迭代器
创建迭代器：
function list_iter(t) local i=0 local n=table.getn(t) return function() i=i+1 if i&lt;=n then return t[i] end end end //这里的list_iter是一个工厂，每次调用都会产生一个新的闭包该闭包内部包括了t,i,n这些 upvalue //返回的闭包每调用依次那么该闭包就会根据记录上一次的状态，返回list的下一个 使用迭代器：
while中使用： t={10,20,90} iter=list_iter(t)//调用迭代器产生一个闭包 while true do local element=iter() if element==nil then break end print(element) end end 泛型for使用： t={10,0,29} for element in list_iter(t) do //这里的list_iter()工厂函数只会被调用一次产生一个闭包函数，后面的每一次迭代都是用该闭包函数，而不是工厂函数 print(element) end 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e19fadce70b2c35da83bdc5e6864940/" rel="bookmark">
			Java调用Pytorch实现以图搜图（附源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java调用Pytorch实现以图搜图 设计技术栈：
1、ElasticSearch环境；
2、Python运行环境（如果事先没有pytorch模型时，可以用python脚本创建模型）；
1、运行效果 2、创建模型（有则可以跳过） vi script.py
import torch import torch.nn as nn import torchvision.models as models class ImageFeatureExtractor(nn.Module): def __init__(self): super(ImageFeatureExtractor, self).__init__() self.resnet = models.resnet50(pretrained=True) #最终输出维度1024的向量，下文elastic search要设置dims为1024 self.resnet.fc = nn.Linear(2048, 1024) def forward(self, x): x = self.resnet(x) return x if __name__ == '__main__': model = ImageFeatureExtractor() model.eval() #根据模型随便创建一个输入 input = torch.rand([1, 3, 224, 224]) output = model(input) #以这种方式保存 script = torch.jit.trace(model, input) script.save("model.pt") 2、java项目pom.xml
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e19fadce70b2c35da83bdc5e6864940/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd0857e5422d7f683b818331e04727e0/" rel="bookmark">
			通俗易懂讲JVM分代回收机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
分代收集算法
工作机制
MinorGC，MixedGC，FullGC
分代回收算法 在Java8中，对被分为了两份：新生代和老年代（1:2的比例）、
如下图
对于新生代，内部又被分为三个区域
1.伊甸区Eden，新生的对象都分配在这里
2.幸存者区servivor（from和to）
3.Eden区，from区，to区（8:1:1）
工作机制 如下图
1.新创建的对象，都会先分配到Eden区
2.当Eden区内存不足，标记Eden与from（现在阶段是没有的）的存活对象
3.将存活对象采用元复制算法复制到to中，复制完毕后，Eden和from内存都得到释放
如下图
假如Eden区分配内存又出现不足
这时会标记出Eden区的存活对象，存活对象和to区的存活对象一起复制到from区，然后释放，如下图
如果from中的A对象一直存活，超过了15次的垃圾回送都没有被释放掉的话，那么A对象会被复制到Old区
MinorGC，MixedGC，FullGC MinorGC（youngGC）发生在新生代的垃圾回收，暂停时间短（STW）
MixedGC新生代和老年代步分区域的垃圾回收，G1收集器持有
FullGC：新生代和老年代完整垃圾回收，内存严重不足时，暂停时间长（STW）应尽力避免
STW：暂停所有应用程序线程，等待垃圾回收完成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e2b978ea46a557d8f4d5e51c600a07d/" rel="bookmark">
			ubuntu依赖库安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pcl安装 安装pcl所需依赖 sudo apt-get update sudo apt-get install git build-essential linux-libc-dev sudo apt-get install cmake cmake-gui sudo apt-get install libusb-1.0-0-dev libusb-dev libudev-dev sudo apt-get install mpi-default-dev openmpi-bin openmpi-common sudo apt-get install libflann1.9 libflann-dev sudo apt-get install libeigen3-dev sudo apt-get install libboost-all-dev sudo apt-get install libvtk7.1-qt sudo apt-get install libvtk7.1 sudo apt-get install libvtk7-qt-dev sudo apt-get install libqhull* libgtest-dev sudo apt-get install freeglut3-dev pkg-config sudo apt-get install libxmu-dev libxi-dev sudo apt-get install mono-complete sudo apt-get install openjdk-8-jdk openjdk-8-jre 执行sudo apt-get install libvtk7-qt-dev时报错，可不用理会继续往下执行
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e2b978ea46a557d8f4d5e51c600a07d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3b0b8b596211681a1e4c49a31d322b8/" rel="bookmark">
			Ubunut22.04使用国内清华源在线安装zabbix6.0.18LTS 基于MySQL和NGINX
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		脚本#!/bin/bash # 1. 在Ubuntu22.04上测试通过 # 2. 使用root用户运行本脚本 # 3. zabbix为6.0.18 LTS版 ############################ 定义变量 ############################ db_password=China123 package_zabbix_url=https://mirrors.tuna.tsinghua.edu.cn/zabbix/zabbix/6.0/ubuntu/pool/main/z/zabbix-release/zabbix-release_6.0-4%2Bubuntu22.04_all.deb ############################ 定义变量 ############################ dir=$(pwd) echo "############################ 安装zabbix仓库... ############################" wget $package_zabbix_url dpkg -i zabbix-release_6.0-4+ubuntu22.04_all.deb echo "############################ 修改zabbix仓库为清华软件源... ############################" cat &gt; /etc/apt/sources.list.d/zabbix.list &lt;&lt;-EOF # Zabbix main repository deb https://mirrors.tuna.tsinghua.edu.cn/zabbix/zabbix/6.0/ubuntu jammy main deb-src https://mirrors.tuna.tsinghua.edu.cn/zabbix/zabbix/6.0/ubuntu jammy main EOF cat &gt; /etc/apt/sources.list.d/zabbix-agent2-plugins.list &lt;&lt;-EOF # Zabbix main repository deb [arch=amd64] https://mirrors.tuna.tsinghua.edu.cn/zabbix/zabbix-agent2-plugins/1/ubuntu jammy main deb-src [arch=amd64] https://mirrors.tuna.tsinghua.edu.cn/zabbix/zabbix-agent2-plugins/1/ubuntu jammy main EOF echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3b0b8b596211681a1e4c49a31d322b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e974e9d52dc47a8cd1aad1b6273d3660/" rel="bookmark">
			核心业务上云难题II
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		B卷
一、计算题
有三个系统，oa系统、运维系统、ERP系统，分别收集信息，计算公有云规划配置。
Oa是6台RH2288，运维是2台泰山，ERP 2台E9000（6个刀片），oa要求是华为系的系统，运维要求国产化架构，CentOS，ERP要求高性能裸金属，Ubuntu。
（1）收集表里，是写单台规格，不是写单台实际使用率，不需乘以使用率
（2）CPU核数：Vcpu =1：1
（3）6个刀片，注意乘以6。上云以后台数也乘以6.
（4）其中一个系统是按需计费
1信息收集表
系统
设备品牌
单台规格
台数
Oa
6
运维
2
ERP
2
2公有云上云服务
服务
架构
上云规格
台数
镜像
Oa
ECS
X86
6
Euler
运维
鲲鹏
ARM
2
CentOS
ERP
BMS
X86
12
ubuntu
3.如果客户有高性能场景，如何推荐客户上云。（同上）
二、网络双平面
和老师上课讲过的题目一样，给了每个系统业务平面和管理平面的IP地址。（同上）
运维无业务平面
各业务平面入规则都连公司内网，出规则都放通
运维的管理平面，开放远程桌面接口，开放某个运维ip。其他管理平面入方向规则都连管理内网，出方向规则全方通。
用到的网络服务
安全组和ACL规则
Oa
ELB、VPN、ACL、VPC
业务入：连内网
业务出：全放通
管理入：连运维内
网
管理出：全放通
运维
ELB、VPN、ACL、VPC
管理入：放通 3389 端口；放通ip XXX
管理出：全放通
ERP
ELB、VPN、ACL、VPC
业务入：连内网
业务出：全放通
管理入：连运维内网
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e974e9d52dc47a8cd1aad1b6273d3660/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea93eec43398d5aad5a67d2017440a52/" rel="bookmark">
			STM32F4_LCD显示图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本程序基于正点的STM32F4系列；
LCD 显示数字和字符的原理都是将数字和字符转换成点阵，通过函数扫描点阵进而在LCD上显示，LCD显示图片的原理也是如此，将图片转换成若干点阵，进而通过函数进行扫描，正点官方提供了图片转换成点阵的工具 Image2LCD v2.9；
具体步骤：
1. 首先打开原子哥的 LCD 例程，在 LCD.c 文件下添加 LCD_ShowPicture 函数，在 LCD 上显示图片；
//参数 //x y 起点坐标 //像素 60*180 //pic 源数组 //注：参数column和row需要根据工具Image2LCD进行设置，否则LCD上无法显示正确的图片 void LCD_ShowPicture(u16 x,u16 y,u16 column,u16 row,unsigned short *pic) { u16 m,h; u16 *data=(u16*)pic; for(h=0+y;h&lt;row+y;h++) //60 { for(m=0+x;m&lt;column+x;m++) //180 { LCD_Fast_DrawPoint(m,h,*data++); } } } 2. 网上随便找 1~2 张图片；
3. 使用正点提供的 Image2LCD 软件取模变成数组；
4. 将数组复制到 main.c 中；
5. 编写主函数调用 LCD_ShowPicture 即可；
int main(void) { u8 lcd_id[12];	//存放LCD ID字符串 NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);//设置系统中断优先级分组2 delay_init(168); //初始化延时函数 uart_init(115200);	//初始化串口波特率为115200 LED_Init(); LCD_Init(); //初始化LCD FSMC接口 POINT_COLOR=RED; //画笔颜色：红色 sprintf((char*)lcd_id,"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea93eec43398d5aad5a67d2017440a52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02f0cd45ba58e8a0d8a9bae4cbfbe465/" rel="bookmark">
			Hive初始化元数据报错：com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException : Unknown database ‘hive‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 在hive初始化元数据时初始化失败，报错如下图：
解决方案： 在mysql中创建一个用于保存hive元数据的数据库hive
然后，再进行初始化，命令如下：即可初始化成功
bin/schematool -dbType mysql -initSchema
如下图所示，初始化成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64b587d302409c67516aff51062177b4/" rel="bookmark">
			【Android】使用AnimationDrawable实现闪烁红光动画效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现闪烁红光效果可以使用Android中的Animation和Drawable资源。具体步骤如下：
创建一个Drawable资源文件，例如red_light.xml，用于定义红光的形状和颜色。示例代码如下： &lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="oval"&gt; &lt;solid android:color="#FF0000" /&gt; &lt;size android:width="20dp" android:height="20dp" /&gt; &lt;/shape&gt; 这个资源文件定义了一个圆形形状，并设置了红色的填充色和大小。
创建一个Animation资源文件，例如red_light_anim.xml，用于定义红光闪烁的动画效果。示例代码如下： &lt;animation-list xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:duration="500" android:drawable="@drawable/red_light" /&gt; &lt;item android:duration="500" android:drawable="@android:color/transparent" /&gt; &lt;/animation-list&gt; 这个资源文件定义了一个动画列表，包含两个item。每个item指定了一个Drawable资源文件，并设置了动画持续时间。第一个item使用了red_light.xml资源文件，表示红光亮起；第二个item使用了Android系统自带的透明颜色，表示红光熄灭。这样，就实现了红光闪烁的效果。
在代码中使用AnimationDrawable类来加载动画资源，并将其设置为一个View的背景。示例代码如下： ImageView redLight = findViewById(R.id.red_light); AnimationDrawable anim = (AnimationDrawable) getResources().getDrawable(R.drawable.red_light_anim); redLight.setBackground(anim); anim.start(); 这个示例中，我们使用findViewById()方法获取了一个ImageView控件，然后使用getResources().getDrawable()方法加载了red_light_anim.xml资源文件，并将其转换为一个AnimationDrawable对象。最后，将AnimationDrawable对象设置为ImageView的背景，并调用start()方法开始动画。
这样，当界面中的ImageView控件显示时，就会闪烁红光，实现数字报警效果。
使用BigDecimal判断是否达到报警值 使用BigDecimal判断温湿度是否达到报警上下限值的步骤如下：
创建BigDecimal对象来表示温湿度的值，例如： BigDecimal temperature = new BigDecimal("26.5"); BigDecimal humidity = new BigDecimal("70.5"); 创建BigDecimal对象来表示报警上下限值，例如： BigDecimal minTemperature = new BigDecimal("20.0"); BigDecimal maxTemperature = new BigDecimal("30.0"); BigDecimal minHumidity = new BigDecimal("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64b587d302409c67516aff51062177b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c502b6d3d6629cd97b078c830992242/" rel="bookmark">
			git submodule 使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 submoude 介绍 （1）项目很大参与开发人员多的时候，需要将各个模块文件进行抽离单独管理。
（2）使用git submodule来对项目文件做成模块抽离，抽离出来的文件可单独成为一个git仓库。整个主项目对抽离出来的子项目（子模块）有依赖关系，却又并不关心子项目（子模块）的内部开发流程细节；
（3）代码如果全员可见，可以做成分支进行管理；如果代码不可见，可以创建为子仓库（独立一个git 仓库）；子仓库管理模块代码，主仓库定时更新
（4）简单理解：项目工程为一个仓库；模块为一个仓库；主仓库操作git module命令来使用这个模块子仓库；主项目，子模块可由不同的开发人员维护。
2 带Submodule 模块的主项目仓库环境搭建 （1）克隆一个主项目仓库git_test
命令：git clone git@gitee.com:monkeyqiyu/git_test.git
（2）添加模块子仓库的路径到主项目中
执行添加子仓库的命令:
git submodule add git@gitee.com:monkeyqiyu/git_submodule.git //其中模块即子仓库的路径为：git@gitee.com:monkeyqiyu/git_submodule.git
子模块仓库：
注：git submodule 还支持嵌套开发
（3）提交代码到远程仓库
git add .
git commit - m “添加子仓库到主仓库” git push origin master
3 带Submodule 模块的主项目开发操作流程 3.1主仓库开发人员A克隆代码进行开发
（1）克隆主仓库代码，子仓库代码为空
git clone git@gitee.com:monkeyqiyu/git_test.git （2）执行以下命令，获取子仓库代码：
git submodule init //初始化子仓库
git submodule update //获取子仓库最新代码
或者直接执行：git submodule update --init --recursive
3.2子仓库和主仓库修改后操作
（1） 非子仓库代码修改跟普通git操作一样提交代码
（2）主仓库由开发人员A开发，子仓库由开发人员B进行开发:
【1】发人员B开发完后提交代码到远程仓库;
【2】开发人员A要对submodule 模块进行更新
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c502b6d3d6629cd97b078c830992242/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b6d6c71df0a5e689532e30bef1feed7/" rel="bookmark">
			CSS中的Flex布局常用的属性介绍和使用说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		justify-content：定义 Flex 项目在水平方向上的对齐方式 justify-content: flex-start;	//起始端对齐 justify-content: flex-end;	//末尾段对齐 justify-content: center;	//居中对齐 justify-content: space-around;	//均匀分布 justify-content: space-between;	//两端对齐，中间均匀分布 align-items：定义 Flex 项目在垂直方向上的对齐方式 align-items:flex-start;	//起始端对齐 align-items:flex-end;	//末尾端对齐 align-items:center;	//居中对齐 align-items:baseline;	//基线对齐，这里的baseline默认是指首行文字 align-items:stretch;	//子容器沿交叉轴方向的尺寸拉伸至与父容器一致。 align-content：定义多行 Flex 项目在垂直方向上的对齐方式 align-content: stretch;	//默认值，多行项目被拉伸以填满容器的垂直方向。 align-content: flex-start;	//多行项目在垂直方向起始位置对齐。 align-content: flex-end;	//多行项目在垂直方向末尾位置对齐。 align-content: center;	//多行项目在垂直方向中间位置对齐。 align-content: space-between;	//多行项目在垂直方向上均匀分布，首尾行贴紧容器边界。 align-content: space-around;	//多行项目在垂直方向上均匀分布，行之间有相等的间隔。 align-content: space-evenly;	//多行项目在垂直方向上均匀分布，行之间和首尾与容器边界之间的间隔均相等。 flex-direction：设置 Flex 容器中 Flex 项目的主轴方向 flex-direction: row;	//默认值，主轴为水平方向，项目从左到右排列。 flex-direction: row-reverse;	//主轴为水平方向，项目从右到左排列。 flex-direction: column;	//主轴为垂直方向，项目从上到下排列。 flex-direction: column-reverse;	//主轴为垂直方向，项目从下到上排列。 flex-wrap：设置 Flex 容器中的项目是否换行 flex-wrap: nowrap;	//默认值，项目不换行，尽可能在一行内显示。 flex-wrap: wrap;	//项目在需要时换行，多余的项目将移动到下一行。 flex-wrap: wrap-reverse;	//项目在需要时换行，多余的项目将移动到上一行。 justify-items 属性用于设置 Flex 容器中单个 Flex 项目在主轴上的对齐方式 具体来说，justify-items 适用于设置单个 Flex 项目在主轴方向上的对齐，而不是多个项目之间的对齐。如果你希望设置整个 Flex 容器内所有项目的对齐方式，应该使用 justify-content 属性
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b6d6c71df0a5e689532e30bef1feed7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54bd90cef000e2a087289423a1f28621/" rel="bookmark">
			记在墨者学院业务逻辑漏洞靶场实战感受
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、身份认证失效
二、登陆密码重置
三、逻辑漏洞-0元买东西
四、热点评论刷分
一、身份认证失效
漏洞分析
1.什么是身份认证？ 验证用户或者客户端身份的过程，其实就是证明你是你自己
2.身份认证漏洞原理？
1）、身份验证机制无法充分防御暴力攻击。
2）、逻辑缺陷或较差的编码使攻击者可以完全绕过身份验证机制。
3.预防措施
1）、严格的逻辑验证。防止在登录页面，注册页面，密码修改页面等出现逻辑错误
2）、防止暴力破解。登录请求在达到特定限制后进行登录验证
3）、防止用户凭据泄露。账户明文传输可能会导致用户名和密码泄露
靶场实战
靶场环境：身份认证失效漏洞实战_身份认证和会话管理_在线靶场_墨者学院_专注于网络安全人才培养
目标要求：通过代理网站获取目标用户手机号码等信息
思路：打开网站后看见登录框和下面一排用户头像和信息，目标是获取马春生的个人信息，目前只知道测试账户test/test，首先查看该网页源代码寻找信息
可以发现钻石代理为马春生，同时获取到马春生的图片id为20128880316，打开bp，登录test/test账户进行抓包看数据
通过抓到的数据包可以看到test账户的图片ID，然后进行改包，将card_id改成马春生的图片id，重放，发送获取数据
可以在右侧获取到账户和密码，不过密码是加密的，浏览器搜在线解密就可以，然后通过获取到账户密码可以登录到马春生账户，查看个人信息。
二、登陆密码重置（逻辑漏洞）
1）、验证码绕过原理：主要是因为验证码的校验机制是在客户端本地的，也就是可以在本地的源码中可以看到的
2）、预防：1设置多重验证，2进行逻辑清晰组件建设，3验证码只能有一次，用完立即过期
思路：观察第一个页面需要重置171手机号密码，第二个页面中有四个输入表单，未知的是验证码，所以从验证码下手，在一个看说明，即188手机号已经注册，也就是188可以收到验证码，那么可不可以直接用188手机号获取到验证码，然后用来给171重置密码呢？
1.输入188手机号来获取验证码
2.然后将手机号改为171的
3.成功，这里也可以用bp进行抓包 然后将数据包中的181手机号改成171的，同样可以完成操作
三、逻辑漏洞-0元买东西
靶场：PHP逻辑漏洞利用实战(第1题)_安全意识_在线靶场_墨者学院_专注于网络安全人才培养
逻辑漏洞原理：开发者在设计时考虑不周，造成不安全设计，缺乏或无效的控制设计（owasp top10中的不安全设计）
预防措施：1.实施访问控制 2.建立安全的策略 3.加强用户认证 4.使用安全组件
首先登录靶场user：xiaoming | password：123456，登录成功页面如下：
思路：可以观察余额为1，书的价格超出预算，可以拿bp抓包，然后修改书的价格，达成0元购买，观察bi11和bi22参数分别为10 20 ，对应书的价格，将其改为0，然后放行数据包 即可找到key
四、热点评论刷分
靶场地址：热点评论刷分漏洞分析溯源_网络安全_在线靶场_墨者学院_专注于网络安全人才培养
思路：抓取点赞包，放到爆破模块中，在http头中增加一个X-Forwarded-for用于修改IP地址
，IP设置变量，使其IP不断变化爆破，IP一边变化一边发包，达到多次点赞的目的
这里多了个知识点X-Forwarded-for的理解：是一个 HTTP 扩展头部，主要是为了让 Web 服务器获取访问用户的真实 IP 地址。那么，我在对IP地址最后进行改包更改，就可以实现不同ip点击此点赞包的效果，达到增加点赞数量的效果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/034eecf867d627c347dfc5af025b7b66/" rel="bookmark">
			JavaScript 类继承
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在JavaScript中，类继承是一种机制，允许你创建一个新的类，并继承来自一个或多个父类的属性和方法。这使得你可以构建更复杂的对象层次结构，并共享通用的行为和特性。
下面是几种常见的类继承方式：
1. **单继承（Single Inheritance）**：一个子类只能继承自一个父类。
```javascript
class ChildClass extends ParentClass {
// 子类的定义
}
```
2. **多继承（Multiple Inheritance）**：一个子类可以继承自多个父类。
在JavaScript中，原生不支持多继承，但可以通过混入（mixin）模式来模拟多继承的效果。
```javascript
class ChildClass extends Mixin(ParentClass1, ParentClass2) {
// 子类的定义
}
```
3. **多层继承（Multilevel Inheritance）**：一个子类可以继承自另一个子类，形成继承的层次结构。
```javascript
class ChildClass extends ParentClass {
// 子类的定义
}
class GrandchildClass extends ChildClass {
// 孙子类的定义
}
```
在继承中，子类通过使用`extends`关键字来指定它所要继承的父类。子类可以访问父类的属性和方法，并可以添加自己的属性和方法。
当子类定义了与父类同名的方法时，子类的方法将覆盖（override）父类的方法，从而改变其行为。子类可以使用`super`关键字来调用父类的构造函数、方法和访问父类的属性。
下面是一个简单的示例，展示了如何使用继承来创建一个图形对象层次结构：
```javascript
class Shape {
constructor(color) {
this.color = color;
}
getColor() {
return this.color;
}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/034eecf867d627c347dfc5af025b7b66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ee49251944802db9ed2dbc05888fea2/" rel="bookmark">
			2.1 搭建第一个区块链网络流程说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导语： 区块链技术正在迅速发展，成为创新和改变的关键驱动力。在此，我将向您介绍如何在Ubuntu操作系统下搭建您的第一个区块链网络。无论您是初学者还是有一定经验的开发者，通过本指南，您将了解搭建区块链网络的基本步骤和必要工具。
1. 硬件和操作系统准备： 首先，确保您的计算机具备足够的硬件资源，如磁盘空间、内存和处理能力。然后，选择您喜欢的操作系统，FISCO BCOS支持多个操作系统，包括Linux、Windows和MacOS。博主这里选择基于Linux的Ubuntu操作系统。
2. 安装必要软件 2.1： 打开终端，并执行以下命令以更新系统软件包：
sudo apt update 2.2： 安装必要的软件和工具：
sudo apt install -y build-essential libssl-dev git cmake libcurl4-gnutls-dev libsqlite3-dev libboost-all-dev libncurses5-dev 1. build-essential：包含了构建软件所需的基本工具，包括编译器、链接器和构建工具等。
2. libssl-dev：用于支持安全套接层（SSL）和传输层安全（TLS）协议的开发库，用于加密通信和安全连接。
3. git：版本控制工具，用于从GitHub仓库中克隆FISCO BCOS的源代码。
4. cmake：跨平台的构建工具，用于管理和生成编译配置。
5. libcurl4-gnutls-dev：用于支持网络传输和通信的开发库，提供了HTTP、HTTPS和FTP等协议的客户端功能。
6. libsqlite3-dev：用于支持SQLite数据库的开发库，FISCO BCOS使用SQLite作为默认的区块链数据存储。
7. libboost-all-dev：包含了Boost C++库的全部组件和开发文件，Boost库提供了许多常用的C++功能和工具。
8. libncurses5-dev：用于支持文本界面的开发库，提供了在终端中进行交互和显示的功能。
3. 下载FISCO BCOS： 前往FISCO BCOS的官方网站或GitHub仓库，下载最新版本的FISCO BCOS。您可以选择下载预编译的二进制文件或者从源代码编译。
3.1： 在终端中执行以下命令，克隆FISCO BCOS的GitHub仓库：
git clone https://github.com/FISCO-BCOS/FISCO-BCOS.git 3.2： 进入下载的源代码目录：
cd FISCO-BCOS 3.3： 切换到最新稳定版本的分支：
git checkout master 3.4： 在终端中执行以下命令以编译FISCO BCOS：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ee49251944802db9ed2dbc05888fea2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/306b2a481753c6db6fafee64d00192c8/" rel="bookmark">
			java毕业设计——基于jsp&#43;JDBC&#43;mysql的试题生成与考试系统设计与实现（毕业论文&#43;程序源码）——试题生成与考试系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于jsp+JDBC+mysql的试题生成与考试系统设计与实现（毕业论文+程序源码） 大家好，今天给大家介绍基于jsp+JDBC+mysql的试题生成与考试系统设计与实现，文章末尾附有本毕业设计的论文和源码下载地址哦。需要下载开题报告PPT模板及论文答辩PPT模板等的小伙伴，可以进入我的博客主页查看左侧最下面栏目中的自助下载方法哦
文章目录：
基于jsp+JDBC+mysql的试题生成与考试系统设计与实现（毕业论文+程序源码）1、项目简介2、资源详情3、关键词4、毕设简介5、资源下载6、更多JAVA毕业设计项目 1、项目简介 当前，网络教学方兴未艾。网上考试已在其中扮演了重要的角色，传统试卷考试方式有待提高。网络教学已从其规范性、科学性及考试工作组织、管理的统一性，影响到教学质量的好坏。基于此，本系统开发实现了基于B/S模式的c试题生成与考试系统，其中数据库采用MYSQL，开发平台是jsp，开发工具是eclipse+myeclipse，服务器采用tomcat。本系统实现了三个功能模块即试题管理模块、在线考试模块、自动评分模块。试题管理模块包括上传试题、试题管理、试卷的自动生成。在线考试模块包括学生登录、考试鉴权、考试时间控制和一些简单的考试意外的避免。自动评分模块包括制定评分规则自动评分和答案的返回。 用户机则不需要安装任何应用程序直接通过浏览器就可以访问。本系统的实现有利于提高网络教学的质量同时大大拓展了考试的灵活性，阅卷效率，以及保证了考试的公平性、答案的安全性。 2、资源详情 项目难度：中等难度
适用场景：相关题目的毕业设计
配套论文字数：11046个字30页
包含内容：全套源码+配整论文
开题报告、论文答辩、课题报告等ppt模板推荐下载方式：
3、关键词 网络考试系统；Web；B/S模式 4、毕设简介 提示：以下为毕业论文的简略介绍，项目完整源码及完整毕业论文下载地址见文末。
1 引言
1.1 课题背景
使用网络考试系统可以使考试在本地进行，也可以在异地进行，打破了以往把考生聚集在一起参加考试的局面，大大拓展了考试的灵活性。试卷根据题库中的内容即时生成，可避免考试前的压题。使用计算机判卷，大大提高阅卷效率；还可以直接把成绩送到数据库中，进行统计、排序等操作。试题内容放在服务器上，考生通过姓名、准考证号码和口令进行登录，考试答案也存放在服务器中，这样考试的公平性、答案的安全性可以得到有效的保证。而且使用试题自动生成系统把从固定在单一试卷中的试题发展到了可以自由组合的题库,再到现在的多媒体试题库.随着题库的建立,组卷变得方便了,测试的形式也发生着变化,由所有学生同考一张试卷的大规模的集体测试发展到了同一场考试使用等同考查效力的不同试卷。这样更能适应我们的现代化教育，使我们的教学质量得到极大的提高。极大的节省了人力和物力，提高了效率。
通过以上分析，得出结论；在科技化飞速发展的今天，我们只有充分利用身边的资源使用科学的考试方式，才能使教育跟上时代的步伐。也只有这样才能使我们的教育水平更上一层楼。
1.2 试题自动生成系统开发的目的和意义
目前国内许多学校在考试方式上还是保留了原有的老师统一出题，学生集中在同一个地方用笔作答的考试方式，这样的考试方式存在着学多弊端。例如：老师出题花费大量时间，印刷试卷花费时间和钱财，造成大量纸张的浪费。人工判题速度慢而且还容易出错，使得考一次试需要花费大量人力和物力。这些弊端的存在使得传统考试越来越不适应现代教学的需要。因此，如何使考试过程变得方便、高效、快捷、公正，是现代教育的一个重要课题。使用试题自动生成系统就能避免这些弊端，通过随机抽取不同的试题，保证了一人一卷从而极大的降低了作弊的几率。而且也避免了印刷试卷浪费的人力物力。
本C语言试题自动生成系统借鉴了许多优秀的先进的网络考试系统的思想，再结合自己所学的知识，开发出来的一套简单的考试系统，主要是目的是检查自己综合运用自己所学知识的能力。本系统完全可以满足一些小型考试的需要，并通过对各种客观题考试情况的长期研究，以灵活、通用为主要设计思想，开发适合于各种客观试题测验的系统。本系统将会提高许多学校对学生考试的效率，极大程度上减轻了老师的工作量，同时加强了对学生所学知识的检测。提高了教学质量。该系统也还可以用于其它部门的考试。例如一些驾校，单位的考试。
考试是网络教学的重要部分，日渐普及的网络教学呼唤着功能强大的网络考试系统的出现。网络考试系统方便了传统考试中的各个环节。提高了试题管理的自动化、标准化、便捷化，也提高了试题的安全性和保密性。试题的自动生成，使每个考生都有一套不同的试题，把固定在单一试卷中的试题发展到了可以自由组合的题库,随着题库的建立,组卷变得方便了,测试的形式也发生着变化,由所有学生同考一张试卷的大规模的集体测试发展到了同一场考试使用等同考查效力的不同试卷，而且可以跨地域的进行同一考试，除了在本地也可以在异地进行，打破了以前考试的局限性。在成绩统计方面，可以方便快捷地实现成绩统计，如各种均值，方差，分布等的计算，同时还可以方便地评判考试的信度和效度。通过使用试题自动生成系统完全摆脱了纸和笔，考生使用计算机答卷，然后通过网络提交试卷，系统自动阅卷。基于计算机网络的考试需要专门的较高水平的技术支持，网络考试已经发展成为一种产业。
发展网络教学有着非常深远的意义，网络教学在全世界范围内得到了迅速的发展。在国外，美国每年大约有近1700万人通过网络接受教育和培训;欧洲网络教育规模也很大，巨大的需求推动了网上教育业的快速发展。目前，在国际市场上比较著名的网上教育软件产品有：Lotus公司LearningSpace，英属哥伦比亚大学计算机科学系开发的WebCT,WBT System公司的TopClass和加拿大Simon Fraser大学开发的Virtual-U等。美国的NTU,英国的Open College都是十分典型的网络教育示例。
目前国内许多学校的教育水平都不是很高，不能满足教育部在“面向21世纪教育振兴行动计划”中的决定。在未来的几年，中央政府将集中投入相当数量的资金，并广泛吸取地方、企业、个人的资金和力量共同完成现代远程教育框架的构建。网络考试在现代化教育中是越来越重要，而在考试过程中，试题的自动生成相当重要，它的正常运行保证了后面考试的质量。所以研究试题的自动生成是相当重要的环节。整体来说 ，国外的网上考试系统有一定的优势，但在一定范围内的考试采用的技术还停留在局部范围内基于Client-Serve:结构的应用程序，真正应用性很好的考试管理工具也还没有出现.所以我们有研究考试系统的必要。现在，科学技术的飞速发展把人类社会推向了一个崭新的时代——网络时代，世界经济发展已进入一个激烈竞争的年代，谁拥有好的教育水平，谁就会创造出更好的知识财富，从而对经济的发展起到巨大的推动作用。新一代远程教学系统的网络传输结构将会具有很强的可扩展性和不同系统间的互操作性。教育信息内容从简单的文件系统组织向教育信息资源库建设发展，从以前的以课程教学内容逐步向以学科体系为出发点构建教学内容过渡。好的考试系统将能很好的检测学习者学习的积极性、主动性。能有效的及时的弥补学习者在学习过程中所存在的知识缺陷。
纵观国内外网络考试系统，它们大多采用SQL SERVER,ACCESS和MySQL作为为后台数据库，在结构上采取B/S, C/S两层开发模式，在评分系统中主要支持客观题的自动评分，没有对主观题的自动评分进行研究和开发，从而对系统的功能和实用性带来了一定制约。本系统也是对客观题的做出自动评分，试题的自动生成也只局限于选择、判断和填空。
1.3 开发环境
1.3.1硬件配置及外设设备与配置
硬件环境：硬件平台是指开发与运行所需要的硬件环境，主要包括计算机机型及一些硬件配置。由于本c语言试题自动生成系统是一个基于web架构小型的MIS系统，因此对服务器端有一定的配置要求，客户端只需要安装IE浏览器就可以了，对计算机硬件的要求都不高，比较经济，只须配备如下即可：
本系统服务器端的运行环境规定：
处理器型号：Intel P4 2.8G；
内存容量：512 M；
外存容量：80G；
网络环境：联网状态或企业内部网中；
1.3.2软件平台及语言
软件平台是指系统开发与运行的软件环境。本系统在开发时选用了兼容性比较好的Windows XP（SP2）版和JSP作为主要的开发技术，由于JSP可以不加修改地在大多数的Web Server上运行，符合“Write once, run anywhere”(“一次编写，多平台运行”)的Java原则，实现了程序与服务器平台的独立性，使得基于JSP技术的应用程序更易于维护和管理。所采用的开发软件主要有eclipse+myeclipse 、Dreamweaver 2004等，数据库方面考虑到与Windows XP兼容性以及所开发的系统的一些信息的数量，所以选择MySQL。服务器采用tomcat ，Web服务器和数据库连接技术采用JDBC。
2 项目总览
2.1 总体设计
项目总体设计框架图如图2-1：
图2－1 项目总体设计框架
2.2 模块划分及各模块的基本功能
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/306b2a481753c6db6fafee64d00192c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/755df7f50c05e314129360ef0f4a372d/" rel="bookmark">
			java毕业设计——基于JSP&#43;J2EE&#43;sqlserver的超市综合信息管理系统设计与实现（毕业论文&#43;程序源码）——超市综合信息管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于JSP+J2EE+sqlserver的超市综合信息管理系统设计与实现（毕业论文+程序源码） 大家好，今天给大家介绍基于JSP+J2EE+sqlserver的超市综合信息管理系统设计与实现，文章末尾附有本毕业设计的论文和源码下载地址哦。需要下载开题报告PPT模板及论文答辩PPT模板等的小伙伴，可以进入我的博客主页查看左侧最下面栏目中的自助下载方法哦
文章目录：
基于JSP+J2EE+sqlserver的超市综合信息管理系统设计与实现（毕业论文+程序源码）1、项目简介2、资源详情3、关键词4、毕设简介5、资源下载6、更多JAVA毕业设计项目 1、项目简介 本网络超市综合管理信息系统的整体开发中尝试了当前最新的思路和技术。系统框架设计采用了MVC模式思想，代码实现使用了JSP+Java Bean的网络编程技术，后台数据库是用SQL Server 对数据库进行管理。系统有完善的信息管理功能，为商家建立一套科学管理流程。本系统界面友好简洁，使用人员可以很快掌握，为系统管理人员带来的方便快捷。 2、资源详情 项目难度：中等难度
适用场景：相关题目的毕业设计
配套论文字数：23460个字58页
包含内容：全套源码+配整论文
开题报告、论文答辩、课题报告等ppt模板推荐下载方式：
3、关键词 管理信息系统; MVC模式; JSP; SQL Server 数据库管理系统; J2EE 4、毕设简介 提示：以下为毕业论文的简略介绍，项目完整源码及完整毕业论文下载地址见文末。
第1章 绪论
往来管理子系统与其他子系统间实现数据兼容和信息共享。商业超市管理信息系统中，其他各子系统的业务运作进展情况基本上以单据提交到往来管理子系统，由往来管理子系统对这些数据信息进行处理。一方面向企业内各部门提供其业务过程及相关活动的往来信息，协助这些部门进行更好地管理；另一方面向管理者提供有用的决策信息。往来管理子系统好比整个商业超市的“中枢神经”系统，不断从外界接受新信息进行处理，再输出各类相关的信息，反映企业的经营状况。
第2章 超市综合信息管理系统概述
2.1 超市综合信息管理系统简介
2.1.1 什么是信息管理系统
(1)管理信息系统概述 管理信息系统是计算机应用在管理领域的一门实用技术。它综合运用了管理科学、数学和计算机应用的原理和方法，在符合软件工程规范的原则下，形成了自身完整的理论和方法学体系。
计算机管理信息系统的总体需求及管理目标：以商品进、销、存的信息管理为基础，以财务核算为中心，采用先进的计算机网络设备，对商场进行全面、细致、规范的管理，实时反映商场的经营情况，为商场管理者、决策者提供科学、准确、规范的数据。该系统由数据采集、数据传输、数据处理、数据存储和辅助决策组成一个多功能可扩展的计算机管理信息系统。将进销存系统与财务电算化、办公自动化系统、人事管理系统互相衔接，为商场提供一个强有力的管理工具。
(2)信息系统的历史
图2-1 C/S结构图
管理信息系统通常可以采用客户机/服务器（C/S）和浏览器/服务器（C/S）两种结构开发。C/S结构在20世纪80，90年代被广泛采用，它可以使用Visual Basic，Visual C++，Delphi和PowerBuilder等众多功能强大的开发工具开发客户端应用程序，服务器上使用后台数据库保存用户数据，基本结构如图2-1所示。
C/S结构的管理信息系统在技术上已经相当成熟，为广大程序开发人员接受。
随着Internet的推广和普及，开发B/S结构的管理信息系统叶在很多领域得到了应用。它的主要优势在于用户无需安装客户端软件，只要使用Internet Explore浏览器就可以使用管理信息系统。当然，B/S结构管理信息系统的主要操作都在服务器上完成，对服务器的要求比较高，它的结构如图2-2所示
图2-2 B/S结构图
而且在开发工具方面也像C/S结构的开发工具那样拥有强大的功能。
2.1.2 信息管理系统的特点
从前面对信息管理系统所作的定义可以看出基于B/S的信息管理系统有一下几个重要特征：
(1)可靠性 保证系统具有充分的容错能力和多级备份，提供有效的系统结构，防止故障发生，一旦发生能自动恢复。
(2)可扩展性 系统扩充和适应能力强，在硬件不变的情况下，通过软件系统重新设置运行参数来调整系统的功能和结构。易于二次开发，若硬件配置升级、网络站点扩充，系统功能应能随之相应增加。
(3)安全性 系统具有多层次的安全和保密机制，权限明确，智能提示，具有很强的安全性、保密性和较长的生命周期，有效防止非法访问。具有上机日志。
(4)易用性 在后台管理系统中的汉字只输入一次，无须记忆各种代码。全中文界面，采用仿真表格与单据，操作直观自然，统一编码，消除重复劳动。
2.1.3 管理信息系统的分类
管理信息系统可以有很多的分类标准。例如，可以将信息管理系统分成独立系统和综合管理信息系统两种情形。独立的系统是为了满足某个特定的应用领域（例如，人力资源管理）而设定的。独立的系统有它自己的文件和数据库系统。综合的系统是由多个独立系统组成。这些独立系统通过它们使用的数据被综合在一起，系统利用一个资源共享的数据库来达到综合的目的。例如，工资管理系统需要人力资源管理系统中提取部门和员工数据，采购管理，销售管理需要从客户资源管理系统中提取客户信息。本系统正是采用综合管理信息系统，来实现超市信息的综合管理。
2.2 管理信息系统的开发过程
管理信息系统的开发过程可以分为以下5个阶段来描述：[11]
第一阶段 系统开始和可行性研究；
第二阶段 系统分析和设计；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/755df7f50c05e314129360ef0f4a372d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47edf643580913b8d6d8ed1482197d57/" rel="bookmark">
			如何在 Ubuntu 22.04 服务器上安装和配置 KVM？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【摘要】 KVM（Kernel-based Virtual Machine）是一种基于内核的虚拟化技术，它允许你在 Linux 操作系统上创建和管理虚拟机。在 Ubuntu 22.04 服务器上安装 KVM 可以提供强大的虚拟化能力，使你能够轻松运行多个独立的虚拟机。本文将详细介绍如何在 Ubuntu 22.04 服务器上安装和配置 KVM。 检查硬件支持在安装 KVM 之前，首先要确保你的服务器支持...
KVM（Kernel-based Virtual Machine）是一种基于内核的虚拟化技术，它允许你在 Linux 操作系统上创建和管理虚拟机。在 Ubuntu 22.04 服务器上安装 KVM 可以提供强大的虚拟化能力，使你能够轻松运行多个独立的虚拟机。本文将详细介绍如何在 Ubuntu 22.04 服务器上安装和配置 KVM。
检查硬件支持 在安装 KVM 之前，首先要确保你的服务器支持硬件虚拟化。使用以下命令可以检查 CPU 是否支持虚拟化扩展：
egrep -c '(vmx|svm)' /proc/cpuinfo 如果输出结果大于等于1，表示你的 CPU 支持虚拟化。否则，你需要使用支持虚拟化的 CPU 或者在 BIOS 中启用虚拟化选项。
安装 KVM 软件包 更新软件包列表： sudo apt update 安装 KVM 软件包和相关工具： sudo apt install qemu-kvm libvirt-daemon-system libvirt-clients bridge-utils virtinst virt-manager 这些软件包将提供 KVM 虚拟化的核心组件和管理工具。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47edf643580913b8d6d8ed1482197d57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eea87705247135e989787e3b040d1d49/" rel="bookmark">
			String类型与Long类型互转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		String转Long的两种方法 1、Long.valueOf("String")返回Long包装类型
2、Long.parseLong("String")返回long基本数据类型
String类型时间转Long类型时间戳
String time = ""; Long timestamp = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").parse(time).getTime(); Long转String的三种方法 1、末尾直接加空串
long a = 123; String s = a + ""; 2、 String.valueof()
long a = 123;
String s =String.valueof(a) ; 3、 Long.toString()
long a = 123; String s = Long.toString(a) ; 示例 下面的例子展示了 java.lang.Long.parseLong() 方法的使用。
package com.tutorialspoint; import java.lang.*; public class LongDemo { public static void main(String[] args) { // parses the string argument long a = Long.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eea87705247135e989787e3b040d1d49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d23ccbeac554f32118c79c173d0894f/" rel="bookmark">
			java毕业设计——基于JSP&#43;J2EE&#43;sqlserver的B2C电子商务系统设计与实现（毕业论文&#43;程序源码）——电子商务系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于JSP+J2EE+sqlserver的B2C电子商务系统设计与实现（毕业论文+程序源码） 大家好，今天给大家介绍基于JSP+J2EE+sqlserver的B2C电子商务系统设计与实现，文章末尾附有本毕业设计的论文和源码下载地址哦。需要下载开题报告PPT模板及论文答辩PPT模板等的小伙伴，可以进入我的博客主页查看左侧最下面栏目中的自助下载方法哦
文章目录：
基于JSP+J2EE+sqlserver的B2C电子商务系统设计与实现（毕业论文+程序源码）1、项目简介2、资源详情3、关键词4、毕设简介5、资源下载6、更多JAVA毕业设计项目 1、项目简介 当今社会,科学技术突飞猛进,知识经济初见端倪。电子商务作为一种新型的贸易方式,极大地促进了全球经济贸易的发展,同时也正在改变人们的生活方式和思想观念。电子商务是指整个贸易活动实现电子化,交易各方以电子交易方式而进行的商业交易。世界贸易组织电子商务专题报告定义:电子商务是通过电子信息网络进行的生产、营销、销售和流通等活动。全球电子商务涉及世界各国,也为我国企业带来了新的发展机遇。所以本次毕业设计的选题就是一个电子商务系统的开发。我们的系统主要应该实现的功能有用户的注册、登陆、密码找回、修改密码、浏览商品、购买商品以及系统的添加商品、商品展示、新闻发布等功能。系统设计中主要采用的技术为：JSP、Servlet、J2EE、B/S。我主要负责的是新闻发布和系统管理子系统。 2、资源详情 项目难度：中等难度
适用场景：相关题目的毕业设计
配套论文字数：16978个字39页
包含内容：全套源码+配整论文
开题报告、论文答辩、课题报告等ppt模板推荐下载方式：
3、关键词 JSP B2C Servlet J2EE B/S 4、毕设简介 提示：以下为毕业论文的简略介绍，项目完整源码及完整毕业论文下载地址见文末。
1．系统概述
1.1选题来源及意义
省略
1.2 技术背景
本次我们的B2C电子商务系统设计过程中主要用到的技术为分别为JSP、Servlet、J2EE、B/S模式，以下为各技术的简要介绍：
1.2.1 JSP
Java Server Pages (JSP) 是由Sun Microsystems 公司倡导、许多公司参与一起建立的一种动态网页技术标准。它为创建动态Web应用提供了一个简捷而快速的方法。JSP 技术使得构造基于Web的应用程序更加容易和快捷,而这些应用程序能够与各种Web服务器,应用服务器,浏览器和开发工具共同工作。IBM WebSphere Application Server 标准版为电子商务应用的Web 事务处理和交互提供了健全的开发环境,它提供可移植的、基于Java 的Web 应用程序开发平台, 支持JavaServer Page、Java Servlet 等技术[2]。
WebSphere Application Server 提供了JSP 引擎和标记支持。JSP 组合了服务器端脚本和标记,同时允许将显示逻辑(如HTML) 与业务逻辑区分开来。在每一个JSP 文件中,可以包括JSP 语法、HTML 标记、Servlet 标记、NCSA 标记及处理用户请求的内联Java 代码、访问可重用业务逻辑组件,如所需的小服务程序和基于Java 的Web 应用程序。
省略
1.2.2 SERVLET
Servlet是使用Java Servlet应用程序设计接口及相关类和方法的Java程序。它在Web服务器上或应用服务器上运行并扩展了该服务器的能力。Java Servlet对于Web服务器就好像Java Applet对于Web浏览器。Applet装入Web浏览器并在Web浏览器内执行，而Servlet则是装入Web服务器并在Web服务器内执行。Java Servlet API 定义了Servlet和服务器间的一个标准接口，这使Servlet具有跨服务器平台的特性[9]。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d23ccbeac554f32118c79c173d0894f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e0ac54135898d7e589eca8d99b8a926/" rel="bookmark">
			微信支付官方SDK PHP版本接入记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 下载证书 下载商家支付证书
这里忽略步骤.
下载的证书我们放在E:/wwwroot/certs/wx/目录下,一共有4个文件:apiclient_cert.p12, apiclient_cert.pem, apiclient_key.pem, 证书使用说明.txt
我们需要从apiclient_cert.pem文件中提取序列号, 可以在 https://myssl.com/cert_decode.html 这里上传文件,然后点击"证书查看"找到序列号
下载微信支付平台证书
文档在我们clone的git目录的bin文件夹下面.
我们先把CertificateDownloader.php拷贝到网站目录的 vendor/下面, 然后启动命令行.
命令行格式如下:
php CertificateDownloader.php -k ${apiV3key} -m ${mchId} -f ${mchPrivateKeyFilePath} -s ${mchSerialNo} -o ${outputFilePath} 注意路径的书写格式, 前面一定要加file://, 保存到相同的目录下,下面是示例:
php CertificateDownloader.php -k YourApiV3Key -m 1433431234 -f file://E:/wwwroot/certs/wx/apiclient_key.pem -s 序列号 -o file://E:/wwwroot/certs/wx/ 下载下来的证书名称类似wechatpay_xxxxxxxxxxxx.pem
未完待续…
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f148f73c81d249909524eff08c0371d/" rel="bookmark">
			Echarts颜色设置，好看的小清新配色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		只需要在option中加入color属性：
color: ['#75bedc', '#ef6567', '#91cd77', '#f9c956', '#5470c6'], 对于饼图配置完整代码：
option = { title: { text: 'Referer of a Website', subtext: 'Fake Data', left: 'center' }, //这里配置颜色 color: ['#75bedc', '#ef6567', '#91cd77', '#f9c956', '#5470c6'], tooltip: { trigger: 'item' }, legend: { orient: 'vertical', left: 'left' }, series: [ { name: 'Access From', type: 'pie', radius: '50%', data: [ { value: 1048, name: 'Search Engine' }, { value: 735, name: 'Direct' }, { value: 580, name: 'Email' }, { value: 484, name: 'Union Ads' }, { value: 300, name: 'Video Ads' } ], emphasis: { itemStyle: { shadowBlur: 10, shadowOffsetX: 0, shadowColor: 'rgba(0, 0, 0, 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f148f73c81d249909524eff08c0371d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/657e998e5b1801a4f3f85f24923b214e/" rel="bookmark">
			Linux gdb调试正在运行中的程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 获取所要调试程序的进程号
2.gdb 调试正在运行的程序，命令如下：
gdb attach 100717
3.查看当前正在运行的线程，命令如下：
info threads
可以看到，当前有20个线程正在运行
4、查看每个线程的基本信息，这样我才知道，我的读目录是运行在哪个线程里面，命令如下：
thread apply all bt
能清晰的知道，Thread 4是我想调试的线程
5.进入调试的线程并查看运行的情况，命令如下：
t 4
是切换到4号线程
bt
是查看当前线程的堆栈情况
可以看到线程是停留在了msisdn.c:920，这里有一个while循环，所以接下来设置断点，让程序重新跑起来。
这里的重点是命令 c,就是让程序继续跑起来，因为当你gdb之后，程序是已经停下来了的，接下来就可以用 单步啊、next啊，来查看你的内存变量了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/372d219dde003e9a4af4939747c7b7fc/" rel="bookmark">
			遗传算法（Genetic Algorithm, GA）学习，基于MATLAB和Sheffield工具箱
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文内容主要参考《MATLAB智能算法30个案例分析（第2版）》
遗传算法的原理：
遗传算法是从一组随机产生的初始解（种群）开始的，这个种群由经过基因编码的一定数量的个体组成，每个个体实际上是染色体带有特征的实体。染色体作为遗传物质的主要载体，其内部表现（基因型）是某种基因的组合，它决定了个体的外部表现。因此，从一开始就需要实现从表现型到基因型的映射，即编码工作。初始种群产生后，按照优胜劣汰的原理，逐代演化产生出越来越好的近似解。在每一代，根据问题域中个体的适应度大小选择个体，并借助于自然遗传学的遗传算子进行组合交叉和变异，产生出代表新的解集的种群。这个过程将导致种群像自然进化一样，后代种群比前代种群更加适应环境，末代种群中的最优个体经过解码，可以作为问题近似最优解。（主观解释：遗传算法是一种模拟自然界生物进化的算法，通过选择、交叉和变异等操作，逐步演化数据以获得近似最优解的算法）
遗传算法的基本步骤：
开始 S1.初始化，输入原始参数及给定参数 S2.数据编码，产生初始种群 S3.适应度评估 while S4.终止条件的判断 S5.选择 S6.交叉 S7.变异 S8.新种群 S9.代计数器增加 end S10.输出结果 结束 名词解读：
编码：GA在进行搜索之前先将解空间的解数据表示成遗传空间的基因型串结构数据,这些串结构数据的不同组合便构成了不同的点。（主观解释：将十进制数据转化为二进制数据）
初始群体：随机产生N个初始串结构数据,每个串结构数据称为一个个体,N个个体构成了一个群体。GA以这N个串结构数据作为初始点开始进化。（主观解释：随机生成N个可能数据）
适应度评估：适应度表明个体或解的优劣性。不同的问题,适应性函数的定义方式也不同。（主观解释：求最小值的问题中，值越小适应度评估数据就越大）
选择：选择的目的是为了从当前群体中选出优良的个体,使它们有机会作为父代为下一代繁殖子孙。遗传算法通过选择过程体现这一思想,进行选择的原则是适应性强的个体为下一代贡献一个或多个后代的概率大。选择体现了达尔文的适者生存原则。（主观解释：适应度越强被选择的概率越大）
交叉：交叉操作是遗传算法中最主要的遗传操作。通过交叉操作可以得到新一代个体﹐新个体组合了其父辈个体的特性。交叉体现了信息交换的思想。（主观解释：现有两个字节分别为：11110000、00001111设交叉点在第五位交叉操作后的两个数据为：11111111、00000000）
变异：变异首先在群体中随机选择一个个体,对于选中的个体以一定的概率随机地改变串结构数据中某个串的值。同生物界一样,GA中变异发生的概率很低,通常取值很小。（主观解释：00000000使其中一位变异后为00010000）
Sheffield遗传算法工具箱中常用函数：
（通过学习这个工具箱中的函数，你可以更好地理解遗传算法的原理和应用。这个工具箱的函数源代码是开放的，你可以随时查看和修改。这样，你就可以把学习的重点放在算法的原理和效果上，而不是代码的编写和调试上。工具箱安装方法）
1.创建种群函数——crtbp
功能：创建任意离散随机种群。
调用格式：
[Chrom,lind,BaseV] = crtbp(Nind,Lind)
[Chrom,lind,BaseV] = crtbp(Nind,Base)
[Chrom,lind,BaseV] = crtbp(Nind,Lind,Base)
本文仅使用：[Chrom,lind,BaseV] = crtbp(Nind,Lind)（若要了解其他调用格式，参考工具箱安装文件中的gatbxa2.pdf）。此格式为Nind×Lind的随机二进制矩阵,其中,Nind 为种群个体数，Lind为个体长度。返回种群编码Chrom和染色体基因位的基本字符向量 BaseV。（主观解释：生成Nind×Lind的随机二进制矩阵）
举例：
&gt;&gt; [Chrom,lind,BaseV] = crtbp(4,5) Chrom = 1 1 1 0 1 0 1 0 0 0 1 1 1 0 1 1 0 0 1 0 lind = 5 BaseV = 2 2 2 2 2 &gt;&gt; NIND = 4;PRECI = 5; &gt;&gt; Chrom = crtbp(NIND,PRECI); &gt;&gt; Chrom Chrom = 1 0 0 0 0 0 0 1 1 1 0 1 1 0 1 1 1 0 0 0 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/372d219dde003e9a4af4939747c7b7fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38e1122ef5df5d61b46f2b9ddab2db0b/" rel="bookmark">
			安装.net3.5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因工作需要，要求安装.net3.5，然后我就开始了走上.net3.5的安装之路。安装这个最大的坑就是不同大版本的net3.5不能混装，要跟你系统的版本相对应！
经过上网查找以后，我查到的安装.net3.5的方法有以下3种:
1. 通过dotnetfx35.exe这个安装包安装。
你去网上找到的这个.exe安装包，都不知道对应哪个Windows版本，通过运行这个.exe能安装成功的，除了命好的，其他基本全都安装失败！基本不用去尝试这种安装方法，还没见过谁通过这个安装方法去安装成功的
2.通过windows镜像安装
通过重新装系统的这个过程，会顺带安装上.net3.5。但是这个镜像文件过大，且安装起来很麻烦。由于是通过安装系统来附带安装.nrt3.5，所以不用考虑版本的问题。
3.通过对应的原版镜像文件安装（知乎上抄来的，原文https://zhuanlan.zhihu.com/p/443245703）
(1).查看系统版本的详细信息
通过cmd输入winver查看window版本版本信息，查看电脑版本下载对应的.net3.5版本才能安装成功
(2).几个对应版本的.net3.5映像文件
windows版本号：1809 https://wws.lanzoui.com/i0zFtqaieoh%20%E5%AF%86%E7%A0%81:3quo 密码:3quo
windows版本号：1903,1909 https://wws.lanzoui.com/igOZ5qaifmb 密码:1ax1
windows版本号：2004,20h2,21h1，22h2 https://wws.lanzoui.com/idDI6qaigsd 密码:9wr3
(3).进行安装
把提取的SXS放在C盘根目录，在管理员模式下powershell或者cmd复制下面脚本直接刷就行了。(建议复制下面这个命令，因为有的地方有空格，你敲不对！)
dism.exe /online /enable-feature /featurename:netfx3 /Source:C:\适用的版本号文件夹名\sxs
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cb636c17baf6615cb01117ea231a650/" rel="bookmark">
			信息管理毕业设计选题推荐100例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0 前言1 java web 管理系统 毕设选题2 java web 平台/业务系统 毕设选题3 游戏设计、动画设计类 毕设选题 (适合数媒的同学)4 算法开发5 数据挖掘 毕设选题6 大数据处理、云计算、区块链 毕设选题7 网络安全 毕设选题8 通信类/网络工程 毕设选题9 嵌入式 毕设选题10 开题指导 0 前言 Hi，大家好，大四的同学马上要开始毕业设计啦，大家做好准备了没！
学长给大家详细整理了计算机信息管理毕设最新选题，对选题有任何疑问，都可以问学长哦~
选题分享，技术解答
https://gitee.com/yaa-dc/warehouse-1/blob/master/python/README.md
1 java web 管理系统 毕设选题 java web 系统往年很常见，不太推荐纯管理系统作为毕设了。
学籍管理系统设计与实现
教务管理系统设计与实现
网上考试系统设计与实现
在线考试系统设计与实现
题库（及试卷）管理系统设计与实现
网络远程作业处理系统设计与实现
毕业论文管理系统的设计与实现
毕业设计管理系统设计与实现
毕业生学历证明系统设计与实现
基于jsp的毕业生派遣管理系统设计与实现
XX学院信息化办公平台-公文、组织机构管理系统的设计与实现
XX学院师资培养管理系统设计与实现
基于web的师资管理系统设计与实现
高校评教教师工作量管理系统设计与实现
教师信息管理系统设计与实现
教师档案管理系统设计与实现
教学进度管理系统设计与实现
网络教学平台-教师子系统设计与实现
学生日常行为评分管理系统设计与实现
学生成绩学分制管理系统设计与实现
学生社团管理系统设计与实现
可视化学生宿舍管理系统设计与实现
班级管理系统设计与实现（或者是班级网站）
高校实验室教学管理系统的设计与实现
校园新闻管理系统设计与实现
基于SSM的学科竞赛管理系统
办公管理系统设计与实现
库存管理系统设计与实现
物资管理系统设计与实现
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2cb636c17baf6615cb01117ea231a650/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/296f640aa916b0034ed9a787cf601c36/" rel="bookmark">
			22级 Java练习题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1．下面哪种类型的文件可以在Java虚拟机中运行（ ）。
A．.java
B．.class
C．.exe
D．.jre
2．下列关于变量作用域的说法中，正确的是（ ）。
A．在main()方法中任何位置定义的变量，其作用域为整个main()方法
B．代码块中定义的变量，在代码块外也是可以使用的
C．变量的作用域为：从定义处开始，到变量所在代码块结束的位置
D．变量的作用域不受代码块的限制
3．请阅读下面的程序：
public class Test {
public static void main(String[] args) {
for(int x =0;x&lt;5;x++)
{
if(x%2==0)
break;
System.out.print(x+” “);
}
}
}
下列选项中，哪一个是程序的运行结果（ ）。
A．12345
B．024
C．13
D．不输出任何内容
4．下列关于数组最值的描述中，错误的是（ ）。
A．要想求数组的最值必须先定义一个数组
B．在求数组最值时，初始时一定要将数组中的第一个元素的值赋给变量
C．求数组最值过程中，一定要对数组进行遍历
D．在求数组最大值时，使用变量记住每次比较后较大的那个值
5．Java中，如果类C是类B的子类，类B是类A的子类，那么下面描述正确的是（ ）。
A．C可以继承B中的公有成员，同样也可以继承A中的公有成员
B．C只继承了B中的成员
C．C只继承了A中的成员
D．C不能继承A或B中的成员
6．请阅读下面的程序：
class Parent {
Parent() {
System.out.println("parent");
}
}
public class Child extends Parent {
Child(String s) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/296f640aa916b0034ed9a787cf601c36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa3541978f5c54923bea2f8541293268/" rel="bookmark">
			【IOS开发】SwiftUI中IOS设备切换成dark模式后字体看不见的解决方案，根据手机背景色模式修改字体颜色！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 SwiftUI 中，当设备切换为 Dark模式时，文字的颜色可能与背景颜色相似，导致文字无法看清。为了解决这个问题，你可以在视图中设置适应 Dark 模式的文字颜色。
1.文字的颜色调整 以下是一种常见的方法，可以尝试在 SwiftUI 视图中使用 colorScheme 环境变量和 foregroundColor 修饰符来调整文字的颜色：
struct ContentView: View { @Environment(\.colorScheme) var colorScheme var body: some View { Text("Hello, World!") .foregroundColor(colorScheme == .dark ? .white : .black) } } 在上面的示例中，我们通过使用 @Environment(.colorScheme) 来获取当前的颜色方案，然后根据 colorScheme 的值设置文字的前景色。如果当前颜色方案为 .dark（即 Dark 模式），我们将文字颜色设置为白色，否则设置为黑色。
通过这种方式，当设备切换为 Dark 模式时，文字颜色将自动调整为适应该模式，以确保可读性。
注意，根据你的具体布局和设计需求，你可能需要在其他视图或组件中进行类似的调整。确保在适当的位置设置文字的前景色，以便在 Dark 模式下保持良好的可读性。
2.@Environment是干嘛的？ @Environment 是 SwiftUI 中的一个属性包装器（property
wrapper），用于访问环境变量的值。环境变量是一种在 SwiftUI
视图层次结构中传递和共享数据的方式，可以提供应用程序的全局状态、配置信息和其他上下文相关的值。 @Environment
属性包装器允许你声明一个属性，该属性从环境中获取对应的值。通过这种方式，你可以在视图中轻松地访问环境变量，而不必手动传递它们。 在 SwiftUI 中，有一些内置的环境变量可以通过 @Environment 来访问，例如：
.colorScheme: 当前的颜色方案（.light 或 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa3541978f5c54923bea2f8541293268/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7fbb4b6e65857eb95b91d96a633a64b/" rel="bookmark">
			Kibana配置删除过期数据（Index Lifecycle Policies）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		添加生命周期策略 在 Hot phase 阶段打开 Advance Setting , 使用自定义设置 点击 垃圾桶 图标，开启 删除阶段
开启后，在最下方会多出一个 Delete phase 阶段；
在 Move data into phase when 中输入你要多久后删除；
最后填上 策略名称 点击 保存策略 ；
添加 Index Template 索引模板 点击 Create template 创建一个索引模板
填写 Name 和 Index pattern 后不断下一步即可；
将 Index Template 添加到 策略 选着刚才创建的 Index template 名称；
这样就完成了日志删除配置
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82c840924820a48857f7bed5507cc522/" rel="bookmark">
			Linux下 安装Docker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用官方安装脚本自动安装 安装命令如下：
curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun 也可以使用国内 daocloud 一键安装命令：
curl -sSL https://get.daocloud.io/docker | sh Docker离线安装 一、Docker安装 1. 安装包官方地址：https://download.docker.com/linux/static/stable/x86_64/ 可以先下载到本地，然后通过ftp工具上传到服务器上，或者在服务器上使用命令下载
wget https://download.docker.com/linux/static/stable/x86_64/docker-18.06.3-ce.tgz 2. 解压 tar -zxvf docker-18.06.3-ce.tgz 3. 将解压出来的docker文件复制到 /usr/bin/ 目录下 cp docker/* /usr/bin/ 4. 创建docker.service文件 进入 /etc/systemd/system/ 目录,并创建 docker.service 文件，内容如下，这样可以将docker注册为service服务
[Unit] Description=Docker Application Container Engine Documentation=https://docs.docker.com After=network-online.target firewalld.service Wants=network-online.target [Service] Type=notify # the default is not to use systemd for cgroups because the delegate issues still # exists and systemd currently does not support the cgroup feature set required # for containers run by docker ExecStart=/usr/bin/dockerd --selinux-enabled=false --insecure-registry=127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82c840924820a48857f7bed5507cc522/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e50e2aec52869d0e17ab0bcae23268d6/" rel="bookmark">
			python modbus RTU
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Modbus RTU 是一种基于串口通讯的 Modbus 协议，它适用于需要长距离和高速传输的场合。
Python 中也支持使用 PyModbus 库来实现 Modbus RTU 通讯。以下是一个简单的示例：
from pymodbus.client.sync import ModbusSerialClient # 连接 Modbus RTU 设备 client = ModbusSerialClient(method='rtu', port='/dev/ttyUSB0', baudrate=9600) client.connect() # 读取一个保持寄存器 result = client.read_holding_registers(address=0, count=1, unit=1) # 处理读取结果 if result.isError(): print(f"Modbus error: {result}`) else: value = result.registers[0] print(f"Register value: {value}") # 关闭 Modbus 连接 client.close() 在这个示例中，我们使用 ModbusSerialClient 类创建了一个 Modbus RTU 客户端对象，并指定了串口的设备文件名（/dev/ttyUSB0）和波特率（9600）。然后，通过 read_holding_registers() 方法读取了一个保持寄存器的值。
在使用 PyModbus 库时，需要根据设备类型（TCP 还是 RTU）来指定不同的 ModbusTcpClient 或 ModbusSerialClient 对象来创建客户端连接。在连接时，需要指定一些连接参数，例如设备的地址、端口、波特率等。然后，通过调用读、写等方法来与 Modbus 设备进行通信。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e50e2aec52869d0e17ab0bcae23268d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4b619b0ec5438b842e44734e5ac2885/" rel="bookmark">
			【C语言】算法学习·Dijkstra算法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Dijkstra算法设计
Dijkstra算法简介
Dijkstra算法的基本思想
Dijkstra贪心策略
完美图解
伪代码详解
完整代码
算法解析及优化拓展
​使用优先队列的完整代码
Dijkstra算法设计 Dijkstra算法简介 Dijkstra算法是解决**单源最短路径**问题的**贪心算法**
它先求出长度最短的一条路径，再参照该最短路径求出长度次短的一条路径直到求出从源点到其他各个顶点的最短路径。
Dijkstra算法的基本思想 首先假定源点为u，顶点集合V被划分为两部分：集合 S 和 V-S。 初始时S中仅含有源点u，其中S中的顶点到源点的最短路径已经确定。
集合S 和V-S中所包含的顶点到源点的最短路径的长度待定，称从源点出发只经过S中的点到达V-S中的点的路径为特殊路径，并用dist[]记录当前每个顶点对应的最短特殊路径长度。
Dijkstra贪心策略 选择特殊路径长度最短的路径，将其连接的V-S中的顶点加入到集合S中，同时更新数组dist[]。一旦S包含了所有顶点，dist[]就是从源到所有其他顶点的最短路径长度。
（1）数据结构。 设置地图的带权邻接矩阵为map[][]，即如果从源点u到顶点i有边，就令map[u][i]=&lt;u,i&gt;的权值，否则map[u][i]=∞；采用一维数组dist[i]来记录从源点到i顶点的最短路径长度：采用一维数组p[i]来记录最短路径上i顶点的前驱。（2）初始化。令集合S={u}，对于集合V-S中的所有顶点x，初始化dist[i]=map[u][i],如果源点u到顶点i有边相连，初始化p[i]=u(i的前驱是u),否则p[i]=-1（3）找最小。在集合V-S中依照贪心策略来寻找使得dist[j]具有最小值的顶点t,即dist[t]=min，则顶点t就是集合V-S中距离源点u最近的顶点。（4）加入S战队。将顶点t加入集合S，同时更新V-S（5）判结束。如果集合V-S为空，算法结束，否则转6（6）借东风。在（3）中已近找到了源点到t的最短路径，那么对集合V-S中所有与顶点t相邻的顶点j，都可以借助t走捷径。如果dist[j]&gt;dist[t]+map[t][j],则dist[j]=dist[t]+map[t][j]，记录顶点j的前驱为t，p[j]=t，转（3）。 我自己在这里理解就是，从u找到与它最近的点t，在从t找到与它最近的点j，在....按照这样持续下去，直到最后一个点 这里我再通俗的解释下这个借东风的意思。源点为1，如果我们找到了距离源点最近的点2，且点2与3,4相连。这样，我们如果要倒3,4有两种方法：
1-&gt;2-&gt;3(4) 1-&gt;3(4) 这里我们就要判断是从1直接到3(4)快，还是经过2后快。假设&lt;1,2&gt;=2 / &lt;2,3&gt;=3 / &lt;1,3&gt;=4，根据上面的数据，我们第一次找最小找到的是2结点，如果我们直接把2替换掉1当做源点继续找下一个最近的点，这种方法是错的。
因为可以看出1-&gt;3只用4，而过2的话要用5。
完美图解 这里我就直接放图片了，书里的图不好画。但主要的是自己按照其流程过一遍，在草稿纸上自己画一遍。
伪代码详解 跟着图解大致了解了一遍接下来就要上代码了，放心，代码不是一个完整的几十行的代码，全部按步骤划分好了的，这里方便大家粘贴。
/* (1)数据结构 n:城市顶点个数. m:城市间路线的条数. map[][]:地图对应的带权邻接矩阵. dist[]:记录源点u到某顶点的最短路径长度。 p[]:记录源点到某顶点的最短路径上的该顶点的前一个顶点(前驱).flag[]：flag[i]=true说明顶点i已加入到集合S，否则该顶点属于集合V-S */ const int N=100;//初始化城市个数，可修改 const int INF=1e7;	//无穷大 int map[N][N],dist[N],p[N],n,m; bool flag[N]; //(2)初始化源点u到其他各个顶点的最短路径长度，初始化源点u出边邻接点的前驱为u bool flag[n];//如果flag[i]=true,说明该顶点i已经加入到集合S；否则i属于集合V-S for(int i=1;i&lt;=n;i++){ dist[i]=map[u][i];	//初始化源点u到其他各个顶点的最短路径长度 flag[i]=false; if(dist[i]==INF) p[i]=-1;	//说明源点u到顶点i无边相连，设置p[i]=-1 else p[i]=u;	//说明源点u到顶点i有边相连，设置p[i]=u } //(3)初始化集合S，令集合S={u},从源点u的最短路径为0 flag[u]=true;//初始化集合S中，只有一个元素：源点u dist[u]=0;	//初始化源点u的最短路径为0，自己到自己的最短路径 //(4)找最小.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4b619b0ec5438b842e44734e5ac2885/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57c2287fa0b2e7ae4e1a169f6092926e/" rel="bookmark">
			Postgre内建触发器函数suppress_redundant_updates_trigger
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、探究 suppress_redundant_updates_trigger 是否真的起作用了，有insert_time，update_time的情况下。
2、探究 suppress_redundant_updates_trigger 触发器对数据插入和更新速度的影响。
suppress_redundant_updates_trigger是在PostgreSQL 9.5版本中引入的内置函数，而我本地的PostgreSQL 版本是9.4，暂时无法完成测试：
select version(); -- 9.4.24 https://www.runoob.com/manual/PostgreSQL/functions-trigger.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b852878badd12a2390fb1be0c3191bd3/" rel="bookmark">
			英伟达官方源Jetson Xavier NX安装Ubuntu20.04，配置CUDA，cuDNN，Pytorch等环境教程（基于NVIDIA官方教程，理论适用其它Jetson设备）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、准备工作 硬件：Jetson Xavier NX开发板（笔者购入为带128g内存条的EMMC版）、跳线帽（杜邦线）、microUSB转USB数据线、电源线
软件：Ubuntu host主机（可运行Ubuntu的虚拟机/双系统）、NVIDIA SDK MANAGER（下载地址：NVIDIA SDK Manager | NVIDIA Developer）。
在Ubuntu主机里安装sdkmanager，命令如下，版本不同则tab补齐安装。
sudo apt install ./sdkmanager_1.6.0-8170_amd64.deb 硬件准备 用杜邦线或者跳线帽将Xavier NX第三个引脚FC_REC与第二/四引脚GND短接（上电后会进入recovery模式），并插上电源给板子供电。然后通过NX的microusb接口连接host主机的USB接口（没有的可以通过扩展坞转接），主机识别到串口后连接到虚拟机内（若是双系统无需此步骤），不要勾选记住此选择，以防之后无法连接到主机。
软件准备 TIPS:在进行安装下载前建议换国内源（常用的比如阿里，清华，中科大源）以加快jetpack及CUDA组件下载速度
打开一个终端，输入sdkmanager，启动sdkmanager（或直接点击sdkmanager图标启动）
sdkmanager 登录 NVIDIA 账号（没有的话自己申请一个），选择登录方式为Developer账户（跳转到NVIDIA网页登录确认，stay logged in之后不需要再登录）。如果sdkmanager提示更新点击yes更新即可，对于如下系统不符合要求的警告不需要管yes继续即可。
二、开始刷机 STEP 01 弹窗选择板子的型号：Jetson Xavier NX（如果没有弹出就是usb没插好，使用lsusb命令查看是否有名称带nvidia的设备），也可以在下图中Target Hardware里刷新后自动读取。
安装时注意选择JetPack5.0.2版本（对应安装ubuntu20.04版本）其他的JetPack版本和ubuntu，CUDA，cudda的对应关系可在英伟达官网查看https://developer.nvidia.com/embedded/jetpack-archive，如多数教程选择的Ubuntu18.04就对应jetpack4.5.1版本。
安装成功后通过以下命令查看本机jetpack版本ubuntu版本则可通过设置-详细信息查看。
sudo apt-cache show nvidia-jetpack 取消勾选第四行里的DeepStream（用于构建智能视频分析（IVA）管道的加速人工智能框架，笔者用不到所以不装）、取消勾选Host Machine（这个是为主机下载安装文件的，若是想在主机上安装 nivida 软件，勾选这个，实际上不必），而后点击 continue，进入下一步。
STEP 02 注意！这里我们先只安装Jetpack系统，等将系统迁移到SSD上面后，再进行其他SDK组件的安装（jetson Xavier NX系统自带内存16g不足以安装其他SDK组件）
勾选左下角接收协议后才能点击continue进入下一步下载安装!系统剩余空间如果大于17GB即可继续下载安装jepack系统。如果提醒disk内存不够或还需要xxMB，无需担心（文件下载到主机的路径无需更改，为保证后续组件安装，建议在开始使用SDKmanager前，主机留足40G以上的内存）
键入HOST主机的ubuntu系统密码后点击ok即可下载
STEP03 下载过程中如果出现检测网络，apt仓库未成功的问题无需担心，skip通过即可(通常是网络问题，只要保证download下载的进度条在前进就说明下得动，下的速度快慢就是另一回事了)整个下载过程视网络状况而定，而烧录系统过程则需要30-60分钟。点击DETAILS旁边的TERMINAL即可查看NX内具体安装命令和报错提示。
当下载完成要刷新目标设备时，SDK Manager 会打开一个对话框。提示会提供有关设备以使其准备就绪以进行闪烁的说明：其中，将启动方式更改为手动，输入并创建 Jetson 的用户名和密码。（后续安装SDK组件过程中选择自动）
点击箭头展开可以看到安装的软件包细节，当出现OS image ready时可以拔掉跳线帽，但电脑与NX连接的USB不要拔！(整个烧录过程必须保证电脑与NX保持连接以防烧录失败)
等待系统烧写完成，时间稍久，Jetson NX会重启，如果接上显示屏就会看到ubuntu登录界面，无外接显示屏看进度条和听风扇转速就知道了。（此过程中可能会提醒烧写超时无需紧张继续即可，如果报错可以关掉SDKmanager重新烧录，一般电脑和NX的USB连线全程保持不断开就没问题）开机后连上键鼠，启动ubuntu系统后连接wifi、添加中文输入法、设置快捷键等基本操作。
三、插入内存条并设置SSD为首启动方式（扩容） 1、格式化SSD： 由于官方自带内存仅为16G，厂家一般提供SSD内存条用以扩容。插上内存条SSD后，在NX启动的Ubuntu系统中，打开disks软件，点击右上角菜单，将固态硬盘格式化。无需更改选项，直接格式化。然后点击左下角+号继续分区。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b852878badd12a2390fb1be0c3191bd3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c9e137aed4dcac914df1895bee9c98f/" rel="bookmark">
			银河麒麟系统中离线安装jdk和tomcat
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，提前下载好安装包同步到服务器中，使用tar -zxvf 命令解压 安装包名字
2，解压完成后打开profile文件 vim /etc/profile，修改profile文件
在文件最后添加export JAVA_HOME=/home/install/jdk8/jdk1.8.0_181
export PATH=$JAVA_HOME/bin:$PATH 然后:wq保存文件。
3，source /etc/profile 刷新profile配置文件
4，测试是否成功，查看 java -version 版本
5， 下载安装包apache-tomcat-8.5.89
6，创建安装路径:
进入安装路径：[root@localhost ~]# cd /opt
创建目录：[root@localhost opt]# mkdir tomcat
把安装包apache-tomcat-8.5.89.tar.gz移动到tomcat文件夹下
7， 解压安装包：[root@localhost tomcat]# tar -zxvf apache-tomcat-8.5.89.gz
8，进入apache-tomcat-8.5.89文件夹下的bin文件夹：[root@localhost tomcat]# cd apache-tomcat-8.5.89/bin
9,输入命令启动：[root@localhost bin]# cd /opt/tomcat/apache-tomcat-9.0.33/bin ./startup.sh
10.启动成功后不要关闭终端，打开浏览器，在网址栏输入 localhost:8080 即可看到tomcat界面
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50f12a98cbef846fcb1684b3fa3200dd/" rel="bookmark">
			深度学习1：环境安装（windows系统&#43;本机显卡）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提要 目录即步骤！安装的是 torch 2.0 （小节4.3.1），听说它有加速效果，但是对于windows，torch. compile (model) 这个语句会报错，我网上搜索的原因是 没有适配 windows。 目录 提要1.显卡信息查看1.1 在电脑上直接查看1.2 在 cmd 中查看 2.anaconda 安装3. cuda &amp; cudnn 安装3.1 CUDA 安装3.2 cudnn 安装3.3 安装错版本如何卸载 4. python 安装4.1 conda 创建新python环境4.2 更多 conda 命令4.3 拓展阅读4.3.1 python 各版本差异 5.python 库安装5.1查看已安装的库5.2下载库5.3 常用的库5.3.1 torch （注意 torch &amp; cuda 版本）5.3.2 tensorflow 6. 编译器安装6.1 vscode （推荐）6.1.1 app下载6.1.2 扩展工具下载6.1.3 运行环境 &amp; 调试环境 5.2 spyder (初学者可用) 7. 安装结果测试7.1 环境查看7.2 vscode 简单调试 1.显卡信息查看 1.1 在电脑上直接查看 （1） 方法1: 设备管理器 -&gt; 显示器适配器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50f12a98cbef846fcb1684b3fa3200dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/924d331b55b043e7159ad13c8c682e9d/" rel="bookmark">
			QT——QSS技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.基本介绍 Html中样式表被叫做Css,Qt当中称为Qss,其中的SS是style sheet（样式表),用于设置程序UI界面中控件的背景图片、大小、字体颜色、字体类型、按钮状态变化等属性，美化UI界面，实现界面和程序的分离，可以快速切换皮肤。用于设置程序UI界面中控件的背景图片、大小、字体颜色、字体类型、按钮状态变化等属性，美化UI界面，实现界面和程序的分离，可以快速切换皮肤。
2.基本语法:选择器{声明} 选择器:通常情况下为控件类名(如:QPushButton)btn-&gt;setStyleSheet( QPushButton color:red}");可以对多个选择器使用同一语句，使用逗号隔开,如this-&gt;setStyleSheet(“QPushButton,QLineEdit{color:blue}”);选择器后可以::跟上子控件，比如spinbox中的上下选择按钮就是子控件,可使用!反转状态,如,ui-&gt;spinBox-&gt;setStyleSheet(“QSpinBox::up-arrowfimage:url(/image/7.ico))”);选择器子控件和选择器后也可以跟上:添加伪状态，比如鼠标悬停在按钮上就是一种:如：btn-&gt;setStyleSheet(“QPushButton:hover color:green:background-color:green;}”);选择器子控件和选择器后也可以跟上:添加伪状态，比如鼠标悬停在按钮上就是一种
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/006ff6a30a1f6ca93811857ab86606d8/" rel="bookmark">
			【openframework】实时路径规划（RTRRTstar算法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		程序框架
视频演示
实时RRT-star算法介绍
实时RRT-star算法是一种基于采样的运动规划算法，它可以在有限的时间内找到一条渐进最优的路径。实时RRT-star算法是在RRT-star算法的基础上进行了改进，主要有两个方面：
- 实时更新起始点。实时RRT-star算法不是从固定的起始点开始搜索，而是每次迭代都将当前的位置作为起始点，这样可以适应动态的环境和目标。
- 实时调整采样区域。实时RRT-star算法不是在整个搜索空间中随机采样，而是根据当前的路径长度和目标位置，计算一个椭圆形的采样区域，只在该区域内进行采样，这样可以提高采样的效率和质量。
实时RRT-star算法的流程如下：
1. 初始化：将当前位置作为起始点，将目标位置作为终点，将起始点加入搜索树中，设置最大迭代次数和时间限制。
2. 迭代：重复以下步骤，直到达到最大迭代次数或时间限制。
- 采样：根据当前的路径长度和目标位置，计算一个椭圆形的采样区域，从该区域内随机选择一个点作为采样点。
- 扩展：在搜索树中找到离采样点最近的节点作为基准节点，从基准节点出发以一定步长朝着采样点进行延伸，延伸线的终点所在的位置被当做有效节点加入搜索树中。
- 重布线：在搜索树中找到有效节点附近的一定范围内的所有节点，对每个节点检查是否可以通过有效节点改善其路径长度，如果可以，则将有效节点作为其父节点，并更新其路径长度。
- 检查：检查是否存在从起始点到终点的可行路径，如果存在，则更新当前的路径长度和采样区域。
3. 输出：输出当前找到的最优路径或者提示无法找到可行路径。
实时RRT-star算法的优点是：
- 可以在有限的时间内找到一条渐进最优的路径，适用于时间敏感的任务。
- 可以实时更新起始点和采样区域，适应动态的环境和目标。
- 可以利用先验知识指导采样过程，提高采样的效率和质量。
实时RRT-star算法的缺点是：
- 需要计算椭圆形的采样区域，增加了计算量和复杂度。
- 需要存储搜索树中的所有节点和路径长度，增加了空间开销。
- 不能保证找到全局最优的路径，只能保证渐进最优。
实时RRT-star算法是一种有前途的运动规划算法，它结合了RRT-star算法和informed RRT-star算法的优点，同时进行了一些创新性的改进。实时RRT-star算法在多种场景下都有很好的表现，例如无人驾驶、机器人导航、游戏角色控制等。实时RRT-star算法还有很多可以改进和扩展的地方，例如采样区域的形状、采样点的分布、重布线的策略等，值得进一步的研究和探索。
ofApp主程序：
#include "ofApp.h" //-------------------------------------------------------------- void ofApp::setup() { #ifdef randomSeed ofSeedRandom(randomSeed);//如果定义了 randomSeed，则使用它来设置随机数种子，以便在每次运行时获得可重复的随机结果。 #endif // randomSeed #ifdef CLK auto start = std::chrono::steady_clock::now(); #endif // DEBUG ofSetVerticalSync(true);//启用垂直同步，以匹配显示器的刷新率。 ofSetFrameRate(30);//设置帧率为30帧/秒。 ofSetWindowTitle("Dynamic-obstacles");//设置窗口标题为 "Dynamic-obstacles"。 ofBackground(200,200,200,200);//设置窗口背景颜色为浅灰色。 myfont.loadFont("Roboto-Regular.ttf", 10);//加载字体文件 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/006ff6a30a1f6ca93811857ab86606d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/379894447d8bbfd35990f1f748c6066a/" rel="bookmark">
			超详细IDEA创建Maven项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Maven概述二、创建Maven项目三、Maven项目简单介绍3.1 标准化的项目结构3.2 标准化的构建流程3.3 方便的依赖管理 一、Maven概述 Maven是一个专门用于管理和构建Java项目的工具。我们之所以要使用Maven，是因为Maven可以为我们提供一套标准化的项目结构、一套标准化的构建流程和一套方便的依赖管理机制，这些功能可以使得我们的项目结构更加清晰，导入jar包的方式更加方便和标准，进而使得我们的开发更加的便捷高效。
接下来，我们就来一起学习一下如何使用IDEA来创建一个Maven项目。
二、创建Maven项目 使用IDEA创建Maven项目，首先需要配置好Maven，具体教程为：Window10 配置Maven详细教程
在打开的项目中，点击File----&gt;点击Project Structure…
选中Modules----&gt;点击+号----&gt;点击New Module
选中Maven----&gt;选择好自己配置的JDK版本----&gt;点击Next
为自己的Maven项目起一个响亮的名字----&gt;②框处需要点击Artifact Coordinates展开----&gt;点击Finish
GroupId：组id（组名）
ArtifactId：项目名
Version不用改
点击OK
等待加载完成后，一个Maven项目就算是创建完成啦！！！
三、Maven项目简单介绍 3.1 标准化的项目结构 3.2 标准化的构建流程 3.3 方便的依赖管理 以往我们要添加一个jar包，需要首先下载好jar包，之后将jar包加入到项目中去，看似不复杂，但是随着版本的不断迭代和更新，jar包版本也要随之变更，这时我们就需要再次重复上述的步骤：首先下载好jar包，之后再将jar包加入至项目中（这样看起来是不是也不是很复杂呢？但是你要知道一个项目可不止一个jar包呀，往往是好多好多个jar包，这时这样的操作就是极其复杂了！！！）
而Maven的出现就解决了这样的问题，因为Maven使用标准的坐标配置来管理各种依赖，我们只需要简单的配置就可以完成依赖管理。
接下来我们来举一个简单的例子（仅为举例子），即可证明Maven的便捷性：例如我们当前项目使用的是MySQL5.1.32版本的，那么我们需要使用数据库连接jar包对应的版本也是5.1.32版本的，如下图所示（没错，jar包也不需要我们去下载，Maven会自动下载，详见windows10 配置Maven一文第五部分）
假如随着项目的更新迭代，我们使用的MySQL版本要更新至8.0.22，那么对应Maven该怎么做呢，很简单，只需要将版本号改为8.0.22即可，如下图所示
OK！！！结束！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35746318ac3b12d41218ea0c73ccd804/" rel="bookmark">
			ClickHouse安装（保姆级教学）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、前期环境准备 1.1 建议关闭防火墙，安装会更省心。（我们公司是不允许关闭防火墙的，所以我这边是全程防火墙，大家各取所需）
1.2 检查当前CPU是否支持SSE 4.2
grep -q sse4_2 /proc/cpuinfo &amp;&amp; echo "SSE 4.2 supported" || echo "SSE 4.2 not supported" 如果输出下图所示，表示支持
1.3 调整CentOS系统对打开文件数的限制，在/etc/security/limits.conf和/etc/security/limits.d/20-nproc.conf文件的末尾加上
* soft nofile 65536 * hard nofile 65536 * soft nproc 131072 * hard nproc 131072 1.4 安装相关的依赖（大部分系统自带），执行一下代码
sudo yum install -y libtool sudo yum install -y *unixODBC*	1.5 在安装 ClickHouse 过程中，官方推荐将 SELinux 设置为 Permissive 模式而不是禁用 SELinux。Permissive 模式下，SELinux 会记录违规操作但不会拒绝访问，这样可以让管理员更好地了解 ClickHouse 对 SELinux 的依赖和影响。 但是我们这边为了安装更顺利采用disabled
sudo vim /etc/selinux/config #修改 SELINUX=disabled 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35746318ac3b12d41218ea0c73ccd804/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e348feafed4bed3fe44cec159b9eede/" rel="bookmark">
			【C&#43;&#43;】deque的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、容器适配器二、deque的介绍三、deque的使用及缺陷1、deque的构造函数2、deque的元素访问接口3、deque的 iterator的使用4、deque的增删查改4、deque的缺陷5、为什么选择deque作为stack和queue的底层默认容器 一、容器适配器 在了解deque前，我们先讲一讲什么是适配器。
适配器是一种设计模式(设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结)，该种模式是将一个类的接口转换成客户希望的另外一个接口。 就像我们生活中常见的充电器一样。
在STL中，虽然stack、queue和priority_dueue中也可以存放元素，但是并没有将其划分在容器的行列中去，而是将其称为容器适配器，这就是因为stack、queue和priority_dueue中只是对其他容器的接口进行了包装。并且，在STL中stack和queue默认使用的是deque，priority_dueue默认使用的是vector。
二、deque的介绍 deque：即双端队列，是一种双开口的连续空间的数据结构。可以在头尾两端进行插入和删除操作。并且，时间复杂度为O(1)，与vector比较，头插效率高，不需要移动元素；与list比较，空间利用率比较高。
但是，deque并不是真正连续的空间，而是由一段段连续的小空间拼接而成的，实际deque类似于一个动态的二维数组，其底层结构如下：
双端队列底层是一段假象的连续空间，实际是分段连续的，为了维护其“整体连续”以及随机访问的假象，落在了deque的迭代器身上，因此deque的迭代器设计就比较复杂，如下图所示：
那deque又是如何借助其迭代器维护其假想连续的结构呢？
三、deque的使用及缺陷 1、deque的构造函数 函数名称功能说明deque()无参构造deque（size_type n, const value_type&amp; val = value_type()）构造并初始化n个valdeque (InputIterator first, InputIterator last)使用迭代器进行初始化构造deque (const deque&amp; x)拷贝构造 代码演示：
#include &lt;iostream&gt; #include &lt;deque&gt; using namespace std; int main() { int i; deque&lt;int&gt; d1; deque&lt;int&gt; d2(4, 50); deque&lt;int&gt; d3(d2.begin(), d2.end()); deque&lt;int&gt; d4(d3); for (auto e : d4) { cout &lt;&lt; e &lt;&lt; " ";//结果：50 50 50 50 } cout &lt;&lt; endl; int arr[] = { 16,2,77,29 }; deque&lt;int&gt; d5(arr, arr + sizeof(arr) / sizeof(int)); deque&lt;int&gt;::iterator it = d5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e348feafed4bed3fe44cec159b9eede/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f55f45704d8f644baabbaaa2b79aa1c9/" rel="bookmark">
			【ArcGIS Pro二次开发】(36)：度分秒转十进制度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经纬度坐标的表达方式比较常用的一般有2种，【度分秒和十进制度】。
在成果展示中，以【度分秒】居多，但如果要将坐标导入ArcGIS中，则一般需要用到【十进制度】，这个转换可以在Excel中进行，也可以在ArcGIS中的字段计算里计算，但都有点小麻烦。
为了更方便的转换，就做了这个小工具。
一、要实现的功能 如上图所示，点击【度分秒转十进制度】按钮，选择要素图层或独立表，再选择度分秒（文本型）和十进制度（浮点型）的字段。
最后选择转换模式，包括【度分秒转十进制度】和【十进制度转度分秒】2种，要注意的是，模式改变时，不需要改变上面2个字段的位置。
生成结果如上图右边的表格。其中有2点需要注意，一是如果输入是空值，则输出也是空值，二是【度、分、秒】这个3个关键字兼容了中文、中文输入法下的符号和英文输入法下的符号，避免输入不规范造成的错误。
二、实现流程 1、度分秒转十进制度 主要流程就是对输入的字符串进行处理，提取出度、分、秒的值，再经过数学计算，得到十进制度的值。
为了兼容多种关键字符，设置字符列表：
List&lt;string&gt; list_degree = new List&lt;string&gt;() { "度", "°" }; List&lt;string&gt; list_minutes = new List&lt;string&gt;() { "分", "′", "'" }; List&lt;string&gt; list_seconds = new List&lt;string&gt;() { "秒", "″", "\"" }; 分别找到关键字符的位置：
foreach (var item in list_degree) { if (value_text.ToString().IndexOf(item) != -1) { index1= value_text.ToString().IndexOf(item); } } foreach (var item in list_minutes) { if (value_text.ToString().IndexOf(item) != -1) { index2 = value_text.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f55f45704d8f644baabbaaa2b79aa1c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b703b870196e6228e8f6408f11dc72b8/" rel="bookmark">
			Docker篇-生成MYSQL和REDIS容器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、下载MYSQL和REDIS镜像 没有下载docker的同学可以去看这篇文章，这篇文章主要讲的用docker-compose来启动容器，今天要讲的是用命令行单独启动容器（这篇文章结尾有docker常见命令，可参考用于该篇文章）https://blog.csdn.net/Peaceuai/article/details/124875101?spm=1001.2014.3001.5502
（1）拉取镜像
# 拉取5.7版本的mysql镜像 docker pull mysql:5.7 # 拉取6.0.0.版本的redis镜像 docker pull redis:6 二、通过镜像生成容器 （1）生成MYSQL容器
# -p中 ：前为主机端口号，后为容器端口号 -v中 ：前为主机文件夹，后为容器文件夹 docker run -p 3315:3306 --name mysql5.7 -e MYSQL_ROOT_PASSWORD=root --privileged=true -v /mount/mysql/data:/var/lib/mysql -v /mount/mysql/log:/var/log/mysql -v /mount/mysql/conf:/etc/mysql/conf.d -d mysql:5.7 生成之后通过挂载文件夹新建一个配置文件，操作如下：（主要是防止中文字符乱码问题）
# 进入挂载配置文件夹 cd /mount/mysql/conf # 新建文件 vim my.cnf # 将下面内容复制进文件中 [client] default_character_set=utf8 [mysqld] collation_server = utf8_general_ci character_set_server = utf8 # 重启容器 docker restart mysql5.7 （2）生成REDIS容器
先新建REDIS的配置文件，之后可通过挂载进容器中
# 进入挂载文件夹 cd /mount # 新建redis的挂载文件夹 mkdir redis # 进入redis的挂载文件夹 cd redis # 新建一个配置文件 vim redis.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b703b870196e6228e8f6408f11dc72b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4d7914668de783a1a7f69cf82cd288d/" rel="bookmark">
			【剑指offer专项突破版】数组篇——“C“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一 . 排序数组中两个数字的和题目分析思路分析法①代码——双指针法②代码——二分查找 二. 数组中和为 0 的三个数题目分析问题转换代码 三. 和大于等于 target 的最短子数组题目分析思路分析代码 四. 乘积小于 K 的子数组题目分析思路分析代码 五. 和为 k 的子数组题目分析思路分析代码 六. 0 和 1 个数相同的子数组题目分析思路分析代码 七. 左右两边子数组的和相等题目分析思路分析代码 八. 二维子矩阵的和题目分析思路分析代码 总结 前言 剑指offer专项突破版（力扣官网）——&gt; 点击进入
本文所属专栏——&gt;点击进入
一 . 排序数组中两个数字的和 题目分析 思路分析 关键：利用好升序数组的特性
思路1：可以利用双指针，一个左下边标，一个右下标，这样比目标数大，就让右下标右移，调小。比目标数小，就让左下标左移，调大。
思路2：固定一个值（可以从左边也可以从右边），那么要找的数就是目标值-这个固定的值，这个固定的值就可以利用二分法进行查找。
法①代码——双指针 int* twoSum(int* numbers, int numbersSize, int target, int* returnSize) { //开辟空间并初始化数组 int *arr = (int*)malloc(sizeof(int)*2); *returnSize = 2; memset(arr,0,sizeof(int)*2); //双指针查找思路 int left = 0; int right = numbersSize - 1; while(left &lt; right) { int sum = numbers[left]+numbers[right]; if(sum &gt; target) { right--; } else if(sum &lt; target) { left++; } else { arr[0] = left; arr[1] = right; break; } } return arr; } 法②代码——二分查找 int* twoSum(int* numbers, int numbersSize, int target, int* returnSize) { //开辟空间并初始化数组 int *arr = (int*)malloc(sizeof(int)*2); *returnSize = 2; memset(arr,0,sizeof(int)*2); //二分查找思路 for(int i = 0; i &lt; numbersSize; i++) { //从左边开始 int left = i+1; int right = numbersSize - 1; int mid = (left+right)/2; int Target = target - numbers[i]; int flag = 0; while(left&lt;=right)//这里是可以相等的，因为我要找的是一个数 { if(numbers[mid]&gt;Target) { right = mid - 1; } else if(numbers[mid]&lt;Target) { left = mid + 1; } else { flag = 1; break; } //更新mid mid = (left+right)/2; } if(flag) { arr[0] = i; arr[1] = mid; break; } } return arr; } 二.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4d7914668de783a1a7f69cf82cd288d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06ee7f3afde66542aebce087254e7545/" rel="bookmark">
			POSTGRESQL远程连接报错： FATAL: no pg_hba.conf entry for host
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PostgreSQL新建用户，连接提示
FATAL: no pg_hba.conf entry for host “10.79.XX.XX”, user “XX”,
database “XX”, no encryption ……
PostgreSQL数据库为了安全，它不会监听除本地以外的所有连接请求，当用户通过JDBC访问是，会报一些如下的异常：
org.postgresql.util.PSQLException: FATAL: no pg_hba.conf entry for host
要解决这个问题，只需要在PostgreSQL数据库的安装目录下找到/data/pg_hba.conf,
cd /var/lib/pgsql/14/data/pg_hba.conf
找到“# IPv4 local connections:”
在其下加上请求连接的机器IP
host all all 127.0.0.1/32 md5
32是子网掩码的网段；md5是密码验证方法，可以改为trust
之后使用postgres用户在安装目录/usr/pgsql-14/bin下执行 ./pg_ctl restart -D /var/lib/pgsql/14/data 重启数据库
依次执行以下命令
cd /var/lib/pgsql/14/data
vim pg_hba.conf
添加上IP
su postgres
cd /usr/pgsql-14/bin
sh ./pg_ctl restart -D /var/lib/pgsql/14/data
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6021083d6ca880285161f8d5ab6d3462/" rel="bookmark">
			midjourney怎么付费？现在还有免费的么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于midjourney，相信你的第一印象是最强大的ai绘画工具，好吧，今天我们就来详细的聊一聊midjourney这款ai绘画工具，给大家讲解一下midjourney付费等情况。
目录
一.Midjourney的介绍
二.Midjourney收费问题
三.Midjourney的使用问题
一.Midjourney的介绍 Midjourney是一款AI制图工具，利用先进的AI算法，只需输入关键字即可在不到一分钟内生成相应的图片。此外，Midjourney还提供多种画家的艺术风格可供选择，如安迪·沃霍尔、达芬奇、达利和毕加索等，并且还能识别特定的镜头或摄影术语。Midjourney与谷歌的Imagen和OpenAI的DALL-E不同，是第一个快速生成AI制图并向公众开放申请使用的平台。虽然Midjourney生成的作品会带有电脑生成的痕迹，但它们往往不会被误认为是假新闻素材。然而，对于色情、血腥、暴力等创作题材的审核还需要更加精准。
二.Midjourney收费问题 Midjourney提供两种会员选择，第一种是每月10美元的会员，可以生成200张图片，适合轻度使用者；第二种是每月30美元的会员，可以无限制生成图片，同时还享受每月15小时的fast使用时长，适合需要经常使用Midjourney并需要生成大量图表的用户。除了生成图片外，这两种会员还可以享受其他服务功能，比如上传和保存数据，编辑已生成的图表等等。无论你是需要偶尔使用Midjourney，还是需要高效完成工作并展示数据，都可以根据自己的需求选择最合适的会员。对了，目前Midjourney已经不免费了，之前还能免费生成25张图，现在已经木有了。
三.Midjourney的使用问题 Midjourney的使用，首先你需要会魔法，这是最基本的门槛，然后你就需要花钱，因为目前没有免费的了，你需要付费10美金，这个付款的问题也会比较麻烦，需要找办法付款，然后还有就是因为是用英文来描述的，你需要懂一点英文，如果不懂的话，需要使用翻译，当然基于翻译的质量，你的描述词可能会有出入，导致出来的成品可能不太好。有人会问，既然那么麻烦，那么我们国内有什么中文版的Midjourney么？其实这方面还真有，国内目前有很多接入各种ai绘画软件的api,所以在国内不需要魔法也是可以使用的。如你可以在任意的浏览器上车俞入 人工智能绘画.site 然后按确认，直接进入就可以了。
相对来说用中文来描述，来进行ai绘画会相对好一点，起码你懂得怎么去描述。
好了，以上就是关于 midjourney怎么付费的一些相关分享，希望本文能帮助到大家，如果想了解更多，欢迎继续关注小编哦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5496862ce33b1516ec8798ec0bf1715c/" rel="bookmark">
			实用脚本一：python将文件夹中的视频文件按帧分割为图像并命名保存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import cv2 import os def save_img(): video_path = ''\\文件夹路径 videos = os.listdir(video_path) cut_video = [] for video_name in videos: if video_name.endswith(".mp4"):\\选择视频后缀名一般是mp4、avi cut_video.append(video_name) count = 1 for video in cut_video: file_name = video.split('.')[0] folder_name = video_path + file_name cutvideo_name = video_path + video os.makedirs(folder_name, exist_ok=True)\\建立保存的文件夹 vc = cv2.VideoCapture(cutvideo_name) c = 0 rval = vc.isOpened() while rval: rval, frame = vc.read() pic_path = folder_name + '/' if rval: %%if c%15==0:\\取帧的间隔 save_path = pic_path + ''+ str(count) + str(c).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5496862ce33b1516ec8798ec0bf1715c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3b1f9633a6be78087db8307614268ae/" rel="bookmark">
			【超详细】Pytest全栈自动化测试指南-夹具入门，让你快速提高测试效率！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二、夹具 2.1 什么是fixtures 在测试中，fixture为测试 提供了一个定义好的、可靠的和一致的上下文。这可能包括环境（例如配置有已知参数的数据库）或内容（例如数据集）。
2.2 使用上的理解 它是一个高级装饰器，通过被@Fixture标记的的函数，都叫做夹具.把使用@Fixture标记的函数名称，传到任意用例的参数列表里面，即可使用在不修改用例函数内部代码的前提下，扩展其功能，可以给用例提供数据，增强功能， 和测试前，测试后环境的初始化和清理工作。 2.3 初始化和清理 fixture 函数会在测试函数之前运行如fixtrue 函数包含yield,那么代码会在yield 处停止，转而运行测试函数，等测试函数执行完毕后，在回到fixtrue，继续执行yield 后面的代码。可以将yield 前、当做setup，yield后，当做teardown无论测试过程中发生了什么，yield后面的代码都会被执行。它的作用视为代码清理功能。类似UnitTest 里面的setup 和teardwn 2.4 共享夹具 conftest.py: 跨多个文件共享夹具该文件用作为整个目录提供共享Fixtrue 的一种方式，可以跨多个文件共享夹具，并且在用例模块中无需导入它们，pytest 会自动会发现conftest.py 中的夹具。您可以拥有多个包含测试的嵌套目录/包，并且每个目录都可以拥有conftest.py. 如果夹具出现重名，子级会覆盖父级中的夹具conftest.py ,只针对当前目录和子级目录有效，对它当前的父级目录，不起作用。 2.5 代码案例 2.5.1 fixtrue夹具入门案例 # ---------------------------------conftest.py------------------------------------ import pytest @pytest.fixture def some_data(): return 66 @pytest.fixture def student_score(): return {'小明': 99, '小红': 100} @pytest.fixture def student_name(): return ['小明', '小红'] # ---------------------------------test_01_fixtures.py---------------------------- from pytest_assume.plugin import assume def test_some(some_data): assert some_data == 66 def test_student(student_score, student_name): with assume: # 实际的数据长度是否跟预期长度相同 assert len(student_score) == 2, \ f"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3b1f9633a6be78087db8307614268ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b551cfeb81575df99407f78ca9fa9763/" rel="bookmark">
			python import 详解 全局变量 作用域
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、名词 模块:
模块通常是个文件，可以作为module的文件类型有".py"、“.pyo”、“.pyc”、“.pyd”、“.so”、“.dll”。
包:
包通常是个文件夹，python中约定文件夹中有__init__.py的默认为包，如果包的子目录中也有__init__.py则认为是子包。
Python import 的搜索路径
在当前目录下搜索该模块
在环境变量 PYTHONPATH 中指定的路径列表中依次搜索
# 加入上级路径到PYTHONPATH export PYTHONPATH=../:$PYTHONPATH 在 Python 安装路径的 lib 库中搜索
Python import 的步骤
python 所有加载的模块信息都存放在 sys.modules 结构中，当 import 一个模块时，会按如下步骤来进行
如果是 import A，检查 sys.modules 中是否已经有 A，如果有则不加载，如果没有则为 A 创建 module 对象，并加载 A
如果是 from A import B，先为 A 创建 module 对象，再解析A，从中寻找B并填充到 A 的 dict 中
相对导入与绝对导入
绝对导入的格式为 import A.B 或 from A import B，相对导入格式为 from . import B 或 from …A import B，.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b551cfeb81575df99407f78ca9fa9763/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8517d286772a5a7538a2a82801a6127f/" rel="bookmark">
			WEB网络渗透的基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络渗透 1.什么是网络渗透 网络渗透是攻击者常用的一种攻击手段，也是一种综合的高级攻击技术，同时网络渗透也是安全工作者所研究的一个课题，在他们口中通常被称为”渗透测试（Penetration Test）”。
网络渗透的目的 无论是网络渗透（Network Penetration）还是渗透测试（Penetration Test），其实际上所指的都是同一内容，也就是研究如何一步步攻击入侵某个大型网络主机服务器群组。只不过从实施的角度上看，前者是攻击者的恶意行为，而后者则是安全工作者模拟入侵攻击测试，进而寻找最佳安全防护方案的正当手段。
随着网络技术的发展，在政府、电力、金融、教育、能源、通信、制造等行业的企业网络应用日趋普遍，规模也日渐扩大。在各个公司企业网络中，网络结构越来越复杂，各种网络维护工作也极为重要，一旦网络出现问题，将会影响公司或企业的正常运作，并给公司或企业带来极大的损失。
在各种网络维护工作中，网络安全维护更是重中之重。各种网络安全事件频频发生，不时见诸于报纸头条和网络新闻，大型企业公司的网络也逃不过被攻击的命运。网络安全工作保障着网络的正常运行，避免因攻击者入侵带来的可怕损失。
为了保障网络的安全，网络管理员往往严格地规划网络的结构，区分内部与外部网络进行网络隔离，设置网络防火墙，安装杀毒软件，并做好各种安全保护措施。然而绝对的安全是不存在的，潜在的危险和漏洞总是相对存在的。
网络渗透攻击 面对越来越多的网络攻击事件，网络管理员们采取了积极主动的应对措施，大大提高了网络的安全性。恶意的入侵者想要直接攻击一个安全防御到位的网络，看起来似乎是很困难的事情。于是，网络渗透攻击出现了。
对于大型的网络主机服务器群组，攻击者往往不会采取直接的攻击手段，而是采用一些迂回渐进式的攻击方法，长期而有计划地逐步渗透攻击进入网络，并完全控制整个网络，这就是”网络渗透攻击”。
蚁穴 攻击者要直接通过设置森严的网络关卡进入网络是不可能的，然而无论怎么样设置网络，总会有一些或大或小的安全缺陷或漏洞。而攻击者所做的，就是在一个看似安全的网络上，找到一个小缺口，然后一步一步地将这些缺口扩大，扩大，再扩大，最终导致整个网络安全防线的失守，掌控整个网络的权限。
对网络管理员来说，网络上的某个小小的安全缺陷，就好似一个微不足道的”蚁穴”，然而忽略了对它的重视，最终的结果将十分可怕，它将会引发整个网络安全防御堤坝的全面崩塌。因此，作为网络管理员，完全有必要了解甚至掌握网络渗透入侵的技术，这样才能有针对性地进行防御，真正保障网络的安全。
普通攻击与渗透攻击 网络渗透攻击与普通攻击的不同
网络渗透攻击与普通网络攻击的不同在于，普通的网络攻击只是单一类型的攻击。
例如，在普通的网络攻击事件中，攻击者可能仅仅是利用目标网络的Web服务器漏洞，入侵网站更改网页，或者在网页上挂马。也就是说，这种攻击是随机的，而其目的也是单一而简单的。
网络渗透攻击则与此不同，它是一种系统渐进型的综合攻击方式，其攻击目标是明确的，攻击目的往往不那么单一，危害性也非常严重。
例如，攻击者会有针对性地对某个目标网络进行攻击，以获取其内部的商业资料，进行网络破坏等。因此，攻击者实施攻击的步骤是非常系统的，假设其获取了目标网络中网站服务器的权限，则不会仅满足于控制此台服务器，而是会利用此台服务器，继续入侵目标网络，获取整个网络中所有主机的权限。
为了实现渗透攻击，攻击者采用的攻击方式绝不仅此于一种简单的Web脚本漏洞攻击。攻击者会综合运用远程溢出、木马攻击、密码破解、嗅探、ARP欺骗等多种攻击方式，逐步控制网络。
总体来说，与普通网络攻击相比，网络渗透攻击具有几个特性：攻击目的的明确性，攻击步骤的逐步与渐进性，攻击手段的多样性和综合性。
1.如何进行渗透？ 一、信息收集
1，获取域名的whois信息,获取注册者邮箱姓名电话等。
2，查询服务器旁站以及子域名站点，因为主站一般比较难，所以先看看旁站有没有通用性的cms或者其他漏洞。
3，查看服务器操作系统版本，web中间件，看看是否存在已知的漏洞，比如IIS，APACHE,NGINX的解析漏洞
4，查看IP，进行IP地址端口扫描，对响应的端口进行漏洞探测，比如 rsync,心脏出血，mysql,ftp,ssh弱口令等。
5，扫描网站目录结构，看看是否可以遍历目录，或者敏感文件泄漏，比如php探针
6，cookie hack google hack cookies edit 进一步探测网站的信息，后台，敏感文件
备注：根据悬镜安全团队多年的渗透测试实战经验得出：安全团队再进行渗透测试的时候，收集完相关的信息后，通过自动化的漏扫工具，进行进一步的问题发掘，然后通过扫描出来的漏洞以及自身的实战项目经验再进行深层次的漏洞挖掘，这也是为什么渗透测试比漏扫工具发现问题的深度和攻击面会更广。
二、漏洞扫描
开始检测漏洞，如XSS,XSRF,sql注入，代码执行，命令执行，越权访问，目录读取，任意文件读取，下载，文件包含， 远程命令执行，弱口令，上传，编辑器漏洞，暴力破解等
三、漏洞利用
利用以上的方式拿到webshell，或者其他权限
四、权限提升
提权服务器，比如windows下mysql的udf提权，serv-u提权，windows低版本的漏洞，如iis6,pr,巴西烤肉， linux藏牛漏洞，linux内核版本漏洞提权，linux下的mysql system提权以及oracle低权限提权
五、 日志清理
日志清理是必要的工作
六、总结报告及修复方案
报告是安全漏洞结果展现形式之一，也是目前安全业内最认可的和常见的。每家安全团队在写渗透测试报告的都不一样，但大体展现的内容是一样的。那报告上都会有哪些内容呢？小编就拿悬镜安全团队做渗透测试的经验以及实际交付给客户的报告来分享下。
有的团队，特别是专业的安全渗透测试团队，报告首先有渗透测试人员产出，出来后由专业的文档品控人员对文档的质量再进行进一步的检查，这个过程不仅可以看出技术的专业度来，也可以看出团队文档的品质感。
那报告上都包括哪些内容？
首先是对本次网站渗透测试的一个总概括，发现几个漏洞，有几个是高危的漏洞，几个中危漏洞，几个低危漏洞。
然后对漏洞进行详细的讲解，比如是什么类型的漏洞，漏洞名称，漏洞危害，漏洞具体展现方式，修复漏洞的方法。
01.sqlmap，怎么对一个注入点注入？ 1.如果是get型号，直接，sqlmap -u “诸如点网址”.
2. 如果是post型诸如点，可以sqlmap -u “注入点网址” – data=”post的参数”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8517d286772a5a7538a2a82801a6127f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e97a08cc10d84c49c75b7851a2f4d7e9/" rel="bookmark">
			mycat分库分表中间件介绍，有案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 MyCat分库分表概述水平拆分和垂直拆分安装JDK安装MyCat安装 MyCat案例1、创建数据库2、分片配置（schema.xml）3、分片配置（server.xml）4、启动服务5、查看日志，看是否启动成功6、登录MyCat7、查看数据库和表8、创建表结构并且插入数据9、查看数据分布 MyCat配置schema.xmlschema标签table标签dataNode标签dataHost标签 rule.xmlserver.xmlsystem标签user标签 MyCat原理MyCat管理 MyCat分库分表 概述 Mycat是一个开源的分布式数据库中间件，它可以将多个MySQL服务器组合成一个逻辑数据库集群，提供高可用、高并发、分片等功能。Mycat在MySQL协议层上实现了Sharding和读写分离等功能，可以将数据水平拆分到多个MySQL服务器上，从而提高数据库的性能和可用性，结构图如下。
水平拆分和垂直拆分 垂直拆分是指将一个大的数据库按照业务功能进行拆分，将不同的表放在不同的数据库中，从而实现数据库的分离。垂直拆分可以提高数据库的可维护性和可扩展性，但是需要重新设计数据库结构，增加了开发和维护的难度。
水平拆分是指将一个大的数据库按照数据行进行拆分，将不同的数据行存储在不同的数据库中，从而实现数据库的分布式存储和访问。水平拆分可以提高数据库的并发能力和可扩展性，但是需要考虑数据一致性和分片规则等问题。
安装 下载
http://www.mycat.org.cn/mycat1.html MyCat采用java语言开发的开源的数据库中间件，支持windows和linux运行环境，因此安装需要的软件有MySQL、JDK、MyCat。
规划如下
服务器安装软件说明192.168.40.137JDK、MyCat、MySQLMyCat中间服务器192.168.40.138MySQL分片服务器192.168.40.150MySQL分片服务器 JDK安装 JDK具体安装步骤如下：
上传安装包 [root@mysql-master ~]# ls anaconda-ks.cfg Mycat-server-1.6.7.3-release-20210913163959-linux.tar.gz mysql jdk-8u171-linux-x64.tar.gz onekey-install-nginx.sh 解压安装包 执行如下指令，将上传上来的压缩包进行解压，并通过-C参数指定解压文件存放目录为 /usr/local。
[root@mysql-master ~]# tar -zxvf jdk-8u171-linux-x64.tar.gz -C /usr/local 配置环境变量 使用vim命令修改/etc/profile文件，在文件末尾加入如下配置
JAVA_HOME=/usr/local/jdk1.8.0_171 PATH=$JAVA_HOME/bin:$PATH 具体操作指令如下:
1). 编辑/etc/profile文件，进入命令模式 vim /etc/profile 2). 在命令模式中，输入指令 G ， 切换到文件最后 G 3). 在命令模式中输入 i/a/o 进入插入模式，然后切换到文件最后一行 i 4). 将上述的配置拷贝到文件中 export JAVA_HOME=/usr/local/jdk1.8.0_171 export PATH=$JAVA_HOME/bin:$PATH 5). 从插入模式，切换到指令模式 ESC 6). 按:进入底行模式，然后输入wq，回车保存 :wq 重新加载profile文件 为了使更改的配置立即生效，需要重新加载profile文件，执行命令:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e97a08cc10d84c49c75b7851a2f4d7e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73204909acab39f894dea28782ad11f6/" rel="bookmark">
			Vue中v-model的原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、v-model原理 1.原理： v-model本质上是一个语法糖。例如应用在输入框上，就是value属性 和 input事件 的合写
&lt;template&gt; &lt;div id="app" &gt; &lt;input v-model="msg" type="text"&gt; &lt;input :value="msg" @input="msg = $event.target.value" type="text"&gt; &lt;/div&gt; &lt;/template&gt; 2.作用： 提供数据的双向绑定
数据变，视图跟着变 :value
视图变，数据跟着变 @input
3.注意 $event 用于在模板中，获取事件的形参
4.代码示例 &lt;template&gt; &lt;div class="app"&gt; &lt;input type="text" /&gt; &lt;br /&gt; &lt;input type="text" /&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { msg1: '', msg2: '', } }, } &lt;/script&gt; &lt;style&gt; &lt;/style&gt; 5.v-model使用在其他表单元素上的原理 不同的表单元素， v-model在底层的处理机制是不一样的。比如给checkbox使用v-model
底层处理的是 checked属性和change事件。
不过咱们只需要掌握应用在文本框上的原理即可
二、v-model简化代码 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73204909acab39f894dea28782ad11f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c7b06f0b5f378dbf13eb0d7d29de203/" rel="bookmark">
			【编程语言 · C语言 · while语句】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​while 语句 循环
在前面我们了解到, 程序在运行时可以通过判断, 检验条件作出选择。此处，程序还必须能够重复， 也就是反复执行一段指令， 直到满足某个条件为止。
while 语句 while语句可以执行循环结构。
语法：
while(表达式) 语句 其一般形式如下：
while 语句首先检验一个条件，也就是括号中的表达式。当条件为真时，就执行紧跟其后的语句或者语句块。
每执行一遍循环，程序都将回到 while 语句处， 重新检验条件是否满足。如果一开始就不满足， 则不执行循环体内的代码。
while循环必须有条件为假的操作，否则程序无法终止。
例如：
#include &lt;stdio.h&gt; int main() { int count = 1; while (count &lt; 8) { printf("Count = %d\n", count); count++; } return 0; } 尝试一下
上面的代码将输出count变量7次。
注意：无法终止的循环常被称为死循环或者无限循环。
【选词填空】打印“ hello” 5次：
int n = 0;
（n &lt;5）{
printf（“ hello \ n”）;
++;
}
switch
while
n
if
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c7b06f0b5f378dbf13eb0d7d29de203/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ecb94ebd4314e06a7fd655f34886bf4/" rel="bookmark">
			富文本插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		wangeditor
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/928b4aa37830c5cd02f3fe2f1fd00f7d/" rel="bookmark">
			我是如何自学Python的，全网最全Python攻略，看完这一篇就够了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新手小白学Python在还没有人带的情况下很容易半途而废，首先给大家总结一下我这两年Python的学习、开发经验遇到一些问题，大家首先得正视这些问题，因为超90%的人在初学Python时都会也遇到。
①：自学网上资料多，但质量参差不齐；
②： 资料杂乱又不成体系，而且缺乏企业级项目实战；
③：应用方向太多了，没有全面的学习路径不知道怎么选择；
④：遇到问题没人带，只能自己苦苦摸索，最后把自己逼到放弃；
而这些问题，绝不是个例，相信很多人都曾遇到过，甚至觉得自己不学这个
在学习Python的过程中，首先就得想明白3个问题，我会就这三个问题给大家具体分析高效解决的方式
1、学习python，要解决什么问题?
2、学完Python你想做什么？如何规划自己的学习路径
3、要学哪些东西?
python只是一门编程语言，要清楚如何利用这门语言解决问题，Python实际应用实在太广了。在python基础知识学完之后，必须要了解自己想要应用方向，应该方向不同学习的路径也会有变化。
你想做web开发，但学完python基础知识，跑去学numpy，pandas等知识，也不能说我要用python做数据分析，学完python基础知识，又去学django，flask框架。
这个道理，就跟我们想要去泰国旅行，肯定不会买去日本的机票一样，很简单，但是我们不得不承认，还是会有人犯迷糊，上来就开干，这个坑能不踩就不踩。
学习方向真的很重要！
1、网站后端程序员：使用它单间网站，后台服务比较容易维护。如：Gmail、Youtube、知乎、豆瓣
2、自动化运维：自动化处理大量的运维任务
3、数据分析师：快速开发快速验证，分析数据得到结果
4、游戏开发者：一般是作为游戏脚本内嵌在游戏中
5、自动化测试：编写为简单的实现脚本，运用在Selenium/lr中，实现自动化。
6、网站开发：借助django,flask框架自己搭建网站。
7、爬虫获取或处理大量信息：批量下载美剧、运行投资策略、爬合适房源、系统管理员的脚本任务等。
8、人工智能：Python由于简便、库多、可读性强、可植入等优点，被作为人工智能的主要开发语言，所以学Python是进入人工智能行业的不二利器。
这个路径是我们系统学习的逻辑主线，我会根据主线来决定下一个完成的的目标是什么，需要学习哪些知识点哪些，避开暂时不需要学习的知识点。然后每学习一个部分，我就能够有一些实际的成果输出，利用成果产出来形成正向刺激，激励后续的学习。
我们在后续的学习过程中，掌握好基础知识，其次再就是运用，在 “ 运用中深入理解，在深入理解中优化应用 ” 。相互印证理解，才一种自然而然的深入学习过程。另外就是大家自行学习很容易遇到编程报错怎么办？该怎么解决？
第一步 遇到很多初学者，环境不会安装，导包错误，直接卡到了第一步，结果因为一个很简单的问题，也浪费了自己的很多时间，其实里面大神简单指导一下就能茅塞顿开，加了学习群的萌新大家一定要多问多沟通。
第二步 实在不好意思问的再就自己百度，查阅相关文章，一般你遇到的问题，90%以上已经有人遇到过了，百度一下，看看人家最后的一些解决办法，多尝试，一定要有意识的培养自己解决问题的能力，这点我觉得是做开发的一项基本素养。
说到下意识的培养自己的编程思维，我这里举个简单的例子，一个列表，[1,3,5,7,9],我想随机抽取3个元素，有没有最简单的方法？当时遇到这个的时候，我自己有意识的想去搜下python中有没有那种一行代码就能搞定这件事的方法，结果确实搜到了sample方法，就用这一行代码搞定了
除此之外，不仅仅在列表中有随机抽样的sample方法，我在工作中还遇到数据分析pandas DataFrame随机抽样的需求，同样，我仍然下意识的去搜有没有那种类似random.sample的方法进行随机抽样，确实不出所料，也搜到了一个sample方法，并成功抽样
第三步 百度不到的话，如果是一些编程方法函数之类的，去查阅相关文档，看有没有类似的方法，比如上面的数据分析库pandas随机抽样sample的用法，可以直接去查阅官方文档，看看最规范的用法是什么，比如，箭头所指的，提供了个数和比例两种抽取方式，这样学习才会进步。
读者福利 小编是一名Python开发工程师，自己整理了一套最新的Python系统学习教程，包括从基础的python脚本到web开发、爬虫、数据分析、数据可视化、机器学习等。如果你也喜欢编程，想通过学习Python转行、做副业或者提升工作效率，这份【最新全套Python学习资料】 一定对你有用！
对于0基础小白入门：
如果你是零基础小白，想快速入门Python是可以考虑的！
1、学习时间相对较短，学习内容更全面更集中
2、可以找到适合自己的学习方案
我已经上传至CSDN官方，如果需要可以扫描下方二维码都可以免费获取【保证100%免费】
1、Python所有方向的学习路线 Python所有方向路线就是把Python常用的技术点做整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。
2、Python课程视频 我们在看视频学习的时候，不能光动眼动脑不动手，比较科学的学习方法是在理解之后运用它们，这时候练手项目就很适合了。
3、精品书籍 书籍的好处就在于权威和体系健全，刚开始学习的时候你可以只看视频或者听某个人讲课，但等你学完之后，你觉得你掌握了，这时候建议还是得去看一下书籍，看权威技术书籍也是每个程序员必经之路。
4、清华编程大佬出品《漫画看学Python》 用通俗易懂的漫画，来教你学习Python，让你更容易记住，并且不会枯燥乏味。
5、Python实战案例 光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
6、互联网企业面试真题 我们学习Python必然是为了找到高薪的工作，下面这些面试题是来自阿里、腾讯、字节等一线互联网大厂最新的面试资料，并且有阿里大佬给出了权威的解答，刷完这一套面试资料相信大家都能找到满意的工作。
这份完整版的Python全套学习资料已经上传至CSDN官方，朋友们如果需要可以点击下方链接或扫描下方二v码都可以免费获取【保证100%免费】
最新全套【Python入门到进阶资料 &amp; 实战源码 &amp;安装工具】
以上全套资料已经为大家打包准备好了，希望对正在学习Python的你有所帮助！
如果你觉得这篇文章有帮助，可以点个赞呀~
我会坚持每天更新Python相关干货，分享自己的学习经验帮助想学习Python的朋友们少走弯路！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eeb18c607872ea48b6669e76110603b8/" rel="bookmark">
			python中 requests库的安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python爬虫中经常需要用到requests库，今天我们开始教学reques库的安装。
01
我们打开“cmd"进行安装
输入win+r 输入cmd
02 先检测pip是否安装（cmd可以直接检测）
如图安装成功
03 检测requests库是否安装完成，打开python运行：status_code
返回值是200表示返回正常。
希望这篇文章给大家能够带来帮助！
作者：茶不予
欢迎大家点赞与关注!
如有错误，请多多指正！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3689c0fc3dbb70c984d52eb94ce165c/" rel="bookmark">
			linux-docker备份数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用计划任务和批处理从docker容器中备份数据库文件到宿主机指定目录
如何创建定时任务 创建计划任务（定时任务）：
crontab -e 打开后是VI编辑器，将自己计划任务的内容写到里边然后wq（保存并退出）就行了
查看计划任务：
crontab -l 查看以及存在的计划任务
可能遇到的问题 bash: crontab: command not found
这个问题主要是因为 crond 服务没有启动
启动crond服务	service crond start 启动crond提示没有找到服务
安装 crond服务即可	yum -y install crontabs 安装成功
数据库备份脚本 容器内操作 ： 备份文件路径：/home/database_bak/
计划任务内容(每天晚上10点执行)：
容器内也可不用加定时任务，直接从宿主机调用容器内的脚本
0 10 * * * /home/database_bak/bak_database.sh 脚本bak_database.sh内容:
# 备份数据库文件 mysqldump -u*** -p*** boo_db -t &gt; /home/database_bak/$(date +%Y%m%d)_boo_db.sql # 清理5天前的备份文件，防止过度占用内存 rm -rf /home/database_bak/$(date -d "5 day ago" +%Y%m%d)_boo_db.sql 宿主机操作： 备份文件路径：/thinker/storage/data_base_bak计划任务(每天晚上11点执行)：0 11 * * * /thinker/storage/data_base_bak/bak_database.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3689c0fc3dbb70c984d52eb94ce165c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67fcd227e50400fc6cdd31a549b92793/" rel="bookmark">
			vite&#43;Vue3 createWebHistory 路由前缀配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue 作为前端最火的前端框架之一，大家在使用的过程中必不可少需要使用router(路由)。
路由有hash 和 history 两种，本期主要针对history模式下 路由前缀 使用和配置，进行简单介绍。
env变量 在根目录下，创建开发、测试、灰度、生产等 env文件
// .env.dev VITE_APP_ENV = 'development' VITE_APP_ROUTER = '/xxx-demo/' //.env.prod VITE_APP_ENV = 'prod' VITE_APP_ROUTER = '/xxx-demo/' package.json // 使用 env 文件
{ "name": "xxx-demo", "version": "1.0.0", "license": "MIT", "scripts": { "dev": "vite --mode dev --open", "build": "vite build --mode test", "prod": "vite build --mode prod" }, "dependencies": { ... } } router路由文件 import { createRouter, createWebHistory } from 'vue-router' /** * 去中心化管理路由 */ const files = import.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67fcd227e50400fc6cdd31a549b92793/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6834e0ad9545b6cde420ab5f2567bad/" rel="bookmark">
			基础渗透测试实验—永恒之蓝漏洞复现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 概述一、 漏洞简述二、组件概述三、漏洞影响四、漏洞复现4.1环境搭建4.2复现过程：1. 查看上线主机2. 使用Metasploit（MSF）工具3. 选择一个编码技术， 用来绕过杀毒软件的查杀4.远程控制目标机 缓解措施 概述 永恒之蓝是指2017年4月14日晚，黑客团体Shadow Brokers（影子经纪人）公布一大批网络攻击工具，其中包含“永恒之蓝”工具，“永恒之蓝”利用Windows系统的SMB漏洞可以获取系统最高权限。
一、 漏洞简述 漏洞名称：“永恒之蓝”漏洞
漏洞编号：MS17-010，CVE-2017-0143/0144/0145/0146/0147/0148
漏洞类型：缓冲区溢出漏洞
漏洞影响：信息泄露
CVSS评分：9.3（High）
利用难度：Medium
基础权限：不需要
二、组件概述 SMB(Server Message Block)是一个协议名，它能被用于Web连接和客户端与服务器之间的信息沟通。其目的是将DOS操作系统中的本地文件接口“中断13”改造为网络文件系统。
SMB1.0协议由于在文件共享传输过程中存在的传输效率低以及传输空间小等缺陷被人们所摒弃。为了更好的实现网络中文件的共享过程，在SMB1.0的基础上开发了新的网络文件传输协议，并将其命名为SMB2.0。
该协议在实现了文件共享传输的基本功能的基础上对文件传输的效率、文件缓存的空间以及文件并发传输等问题进行改进，使得在局域网或更高配置的网络环境下，文件传输过程的速度和效率等得到了很大的提升。
三、漏洞影响 Windows Vista SP2; Windows Server 2008 SP2 and R2 SP1; Windows 7SP1;
Windows 8.1; Windows Server 2012 Gold and R2; Windows RT8.1; and
Windows 10 Gold, 1511, and 1607; and Windows Server 2016
以上系统打开445号端口都容易受到影响。
四、漏洞复现 4.1环境搭建 实验中需要用到俩个机器，分别是，靶机（关闭防火墙），攻击机。
靶机环境：windows_7x64
配置：192.168.231.130
攻击机环境：kali-linux-2023.1
攻击机配置：192.168.231.132
注意：靶机和攻击机能互相ping同
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6834e0ad9545b6cde420ab5f2567bad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dea892c61c334b0db873352f9dc4a35f/" rel="bookmark">
			Java 面试题大全（整理版）1000&#43; 面试题附答案详解最全面看完稳了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进大厂是大部分程序员的梦想，而进大厂的门槛也是比较高的，所以这里整理了一份阿里、美团、滴滴、头条等大厂面试大全，其中概括的知识点有：Java、MyBatis、ZooKeeper、Dubbo、Elasticsearch、Memcached、Redis、MySQL、Spring、Spring Boot、Spring Cloud、RabbitMQ、Kafka、Linux 等技术栈共有 1000+道面试题。
对于 Java 后端的朋友来说应该是最全面最完整的面试备战仓库，为了更好地整理每个模块，我也参考了很多网上的优质博文和项目，力求不漏掉每一个知识点，很多朋友靠着这些内容进行复习，拿到了 BATJ 等大厂的 offer， 也已经帮助了很多的 Java 学习者，希望也能帮助到你。
面试题整理十分全面，文末还有答案解析！（文章比较长，耐心看完，让你面试提升一大截！）
MyBatis 面试题 1、什么是 Mybatis？
2、Mybaits 的优点：
3、MyBatis 框架的缺点：
4、MyBatis 框架适用场合：
5、MyBatis 与 Hibernate 有哪些不同？
6、#{}和 ${}的区别是什么？
7、当实体类中的属性名和表中的字段名不一样 ，怎么办 ？
8、 模糊查询 like 语句该怎么写?
9、通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，请问，
这个 Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，
方法能重载吗？
10、...
ZooKeeper 面试题 1. ZooKeeper 面试题？
2. ZooKeeper 提供了什么？
3. Zookeeper 文件系统
4. ZAB 协议？
5. 四种类型的数据节点 Znode
6. Zookeeper Watcher 机制 -- 数据变更通知
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dea892c61c334b0db873352f9dc4a35f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76fdf8b4e56c48ca4186bc356c024bbd/" rel="bookmark">
			systemctl配置redis服务的2种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、使用fork方式，后台进程：
redis配置文件要改成daemonize yes
bind 127.0.0.1 10.21.108.175 protected-mode no port 6381 tcp-backlog 10240 timeout 0 tcp-keepalive 300 daemonize yes supervised no pidfile "/var/run/redis_6381.pid" loglevel notice logfile "/data/redis_6381/log/redis_6381.log" databases 16 save 900 1 save 300 10 save 60 10000 maxmemory 100000 stop-writes-on-bgsave-error yes rdbcompression yes rdbchecksum yes dbfilename "dump_6381.rdb" dir "/data/redis_6381" slave-serve-stale-data yes slave-read-only yes repl-diskless-sync no repl-diskless-sync-delay 5 repl-disable-tcp-nodelay no slave-priority 100 maxmemory-policy volatile-lru appendonly no appendfilename "appendonly.aof" appendfsync everysec no-appendfsync-on-rewrite no auto-aof-rewrite-percentage 100 auto-aof-rewrite-min-size 64mb aof-load-truncated yes lua-time-limit 5000 slowlog-log-slower-than 10000 slowlog-max-len 128 latency-monitor-threshold 0 notify-keyspace-events "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76fdf8b4e56c48ca4186bc356c024bbd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/effc65f26b043c4fd80566e91ca7a721/" rel="bookmark">
			Vim的入门使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先来了解一下vim编辑器的两种操作模式：
普通模式 刚打开vim就是普通模式。
普通模式下除了可以用方向键移动光标外，还可以：
h：左移一个字符
j：下移一行
k：上移一行
l ：右移一个字符
ctrl+f：下翻一屏
ctrl+b：上翻一屏
G：移动到缓冲区的最后一行
num G：移动到缓冲区的第num行
gg：移到缓冲区的第一行
x：删除当前光标处字符
dd：删除当前行
dw：删除当前光标所在位置的单词
d$：删除当前位置至行尾的内容
J：删除行尾换行符（拼接行）
u：撤销
a：转插入模式（在当前光标后追加数据）
A：转插入模式（在当前光标行尾追加）
r char：用char替换光标处字符
R text：用text覆盖光标处字符，esc退出
剪切和粘贴：剪切同删除，粘贴p
复制：y（第二个字符同d）
复制（可视模式）：移动到开始复制的位置按v，移动光标后y键复制，p键粘贴
查找和替换
查找：/+内容，回车。从当前光标往后找，会回到开头。/+enter下一个（或者n，N上一个）。
普通模式下有个特别的功能叫命令行模式：提供了一个交互式命令行，可以输入额外的命令来控制vim的行为。
普通模式下按冒号键（:）进入，常用命令如下：
q：无修改退出 q!：退出不保存 w filename：另存 wq：保存退出 替换：
:s/old/new/ #替换一次 :s/old/new/g #替换行内 :n,ms/old/new/g #替换n-m行之间 :%s/old/new/g #替换全文 :%s/old/new/gc #替换全文，带提醒 插入模式 普通模式下按下i键进入插入模式。插入模式下按ESC键返回普通模式。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6667761381ab68775d93a41b3bf5fcdf/" rel="bookmark">
			如何自由的看英文期刊，学习英语 Bypass Paywalls
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何自由的看英文期刊，学习英语 Bypass Paywalls Bypass Paywalls 使用上述插件，就可以免费获取期刊内容，来学习英文了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29f3c2c0dc53793eee0a77326936d447/" rel="bookmark">
			上海AI实验室与商汤科技等发布“书生·浦语”大语言模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着AI大语言模型越来越多地表现出接近人类的智能，面向人类设计的高难度、综合性考试被越来越多地引入对语言模型的智能水平进行评测。OpenAI在其关于GPT-4的技术报告中就主要通过各领域的考试对模型能力进行检验。2023年高考开考，中文大语言模型是否能够在高考中赶超ChatGPT呢？
6月7日，上海人工智能实验室（上海AI实验室）、商汤科技联合香港中文大学、复旦大学及上海交通大学发布千亿级参数大语言模型“书生·浦语”（InternLM）。“书生·浦语”具有1040亿参数，是在包含1.6万亿token的多语种高质量数据集上训练而成。全面评测结果显示，“书生·浦语”不仅在知识掌握、阅读理解、数学推理、多语翻译等多个测试任务上表现优秀，而且具备很强的综合能力，因而在综合性考试中表现突出，在多项中文考试中取得超越ChatGPT的成绩，其中就包括中国高考各科目的数据集（GaoKao）。
“书生·浦语”相关技术报告已在网上公开：https://github.com/InternLM/InternLM-techreport，报告对模型的技术特点以及测试结果进行了详细阐述。
综合“大考”：“书生·浦语”多项成绩领先于ChatGPT “书生·浦语”联合团队选取了20余项评测对其进行检验，其中包含全球最具影响力的四个综合性考试评测集：由伯克利加州大学等高校构建的多任务考试评测集MMLU；由微软研究院推出的学科考试评测集AGIEval（含中国高考、司法考试及美国SAT、LSAT、GRE和GMAT等）；由上海交通大学、清华大学和爱丁堡大学合作构建的面向中文语言模型的综合性考试评测集C-Eval；由复旦大学研究团队构建的高考题目评测集Gaokao。
实验室联合团队对“书生·浦语”、GLM-130B、LLaMA-65B、ChatGPT和GPT-4进行了全面测试，针对上述四个评测集的成绩对比如下（满分100分）。
可以看到，“书生·浦语”不仅显著超越了GLM-130B 和 LLaMA-65B等学术开源模型，还在AGIEval、C-Eval以及Gaokao等多个综合性考试中领先于ChatGPT；在以美国考试为主的MMLU上实现和ChatGPT持平。这些综合性考试的成绩反映出“书生·浦语”扎实的知识掌握程度和优秀的综合能力。
虽然 “书生·浦语”在考试评测上取得优秀成绩，但在测评中也可以看到，大语言模型仍然存在不少能力局限性。“书生·浦语” 受限于2K的语境窗口长度（GPT-4的语境窗口长度为32K），在长文理解、复杂推理、撰写代码以及数理逻辑演绎等方面还存在明显局限。另外，在实际对话中，大语言模型还普遍存在幻觉、概念混淆等问题；这些局限使得大语言模型在开放场景中的使用还有很长的路要走。
四个综合性考试评测数据集结果 MMLU是由伯克利加州大学（UC Berkeley）联合哥伦比亚大学、芝加哥大学和UIUC公共构建的多任务考试评测集，涵盖了初等数学、物理、化学、计算机科学、美国历史、法律、经济、外交等多个学科。细分科目结果如下表所示。
（粗体表示最佳结果，下划线表示第二）
AGIEval是由微软研究院在今年新提出的学科考试评测集，主要目标是通过面向的考试来评估语言模型的能力，从而实现模型智能和人类智能的对比。这个评测集基于中国和美国各类考试构建了19个评测大项，包括了中国各科高考、司法考试以及美国的SAT、LSAT、GRE和GMAT等重要考试。值得一提的是，在这19个大项有9个大项是中国高考，通常也列为一个重要的评测子集 AGIEval（GK）。下列表格中，带GK的是中国高考科目。
（粗体表示最佳结果，下划线表示第二）
C-Eval是由上海交通大学、清华大学和爱丁堡大学合作构建的面向中文语言模型的综合性考试评测集。它包含了52个科目的近14000道考题，涵盖数学、物理、化学、生物、历史、政治、计算机等学科考试，以及面向公务员、注册会计师、律师、医生的职业考试。测试结果可以通过leaderboard获得。
（https://cevalbenchmark.com/static/leaderboard.html）
Gaokao是由复旦大学研究团队构建的基于中国高考题目的综合性考试评测集，包含了中国高考的各个科目，以及选择、填空、问答等多种题型。在GaoKao测评中，“书生·浦语”在超过75%的项目中均领先ChatGPT。
分项评测：阅读理解、推理能力表现出色 为了避免“偏科”，研究人员还通过多个学术评测集，对“书生·浦语”等语言模型的分项能力进行了评测对比。结果显示，“书生·浦语”不仅在中英文的阅读理解方面表现突出，并且在数学推理、编程能力等评测中也取得了较好的成绩。
在知识问答方面，“书生·浦语”在TriviaQA和NaturalQuestions两项评测上得分为69.8和27.6，均超越LLaMA-65B（得分为68.2和23.8）。
在阅读理解（英语）方面，“书生·浦语”明显领先于LLaMA-65B和ChatGPT。浦语在初中和高中英语阅读理解中得分为92.7和88.9，⽽ChatGPT得分为85.6和81.2，LLaMA-65B则更低。
在中文理解方面，“书生·浦语”的成绩全面超越主要的两个中文语言模型ERNIE-260B和GLM-130B。
在多语翻译方面，“书生·浦语”在多语种互译中的平均得分为33.9，显著超越LLaMA（平均得分15.1）。
在数学推理方面，“书生·浦语”在GSM8K和MATH这两项被广泛用于评测的数学考试中，分别取得62.9和14.9的得分，明显领先于Google的PaLM-540B（得分为56.5和8.8）与LLaMA-65B（得分为50.9和10.9）。
在编程能力方面，“书生·浦语”在HumanEval和MBPP这两项最具代表性的考评中，分别取得28.1和41.4的得分（其中经过在代码领域的微调后，在HumanEval上的得分可以提升至45.7），明显领先于PaLM-540B（得分为 26.2和36.8）与LLaMA-65B（得分为23.7和37.7）。
此外，研究人员还对“书生·浦语”的安全性进行评测，在TruthfulQA（主要评价回答的事实准确性）以及CrowS-Pairs（主要评价回答是否含有偏见）上，“书生·浦语”均达到领先水平。
欢迎对大模型感兴趣的同学加入 OpenMMLab 团队，详情请戳：
OpenMMLab：OpenMMLab 浦视团队 | 2023 全球招聘
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fc9a74a7b07ce11e27efa027c86e8ef/" rel="bookmark">
			LIO-SAM代码逐行解读（4）- IMU预积分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		imuPreintegration.cpp 1.main() int main(int argc, char **argv) { ros::init(argc, argv, "roboat_loam"); IMUPreintegration ImuP; TransformFusion TF; ROS_INFO("\033[1;32m----&gt; IMU Preintegration Started.\033[0m"); ros::MultiThreadedSpinner spinner(4); spinner.spin(); return 0; } 2.IMUPreintegration类 2.1 成员变量 class IMUPreintegration : public ParamServer { public: std::mutex mtx; ros::Subscriber subImu; // imu信息订阅器 ros::Subscriber subOdometry; // 最终优化后的里程计增量信息(用来矫正imu的偏置) ros::Publisher pubImuOdometry; // 估计的imu里程计信息发布器(其实是通过imu估计的雷达里程计信息) bool systemInitialized = false; gtsam::noiseModel::Diagonal::shared_ptr priorPoseNoise; // 先验位置噪声 gtsam::noiseModel::Diagonal::shared_ptr priorVelNoise; // 先验速度噪声 gtsam::noiseModel::Diagonal::shared_ptr priorBiasNoise; // 先验偏置噪声 gtsam::noiseModel::Diagonal::shared_ptr correctionNoise; gtsam::noiseModel::Diagonal::shared_ptr correctionNoise2; gtsam::Vector noiseModelBetweenBias; gtsam::PreintegratedImuMeasurements *imuIntegratorOpt_; gtsam::PreintegratedImuMeasurements *imuIntegratorImu_; std::deque&lt;sensor_msgs::Imu&gt; imuQueOpt; std::deque&lt;sensor_msgs::Imu&gt; imuQueImu; gtsam::Pose3 prevPose_; // 上一时刻估计imu的位姿信息 gtsam::Vector3 prevVel_; // 上一时刻估计imu的速度信息 gtsam::NavState prevState_; gtsam::imuBias::ConstantBias prevBias_; gtsam::NavState prevStateOdom; gtsam::imuBias::ConstantBias prevBiasOdom; bool doneFirstOpt = false; double lastImuT_imu = -1; double lastImuT_opt = -1; gtsam::ISAM2 optimizer; gtsam::NonlinearFactorGraph graphFactors; gtsam::Values graphValues; const double delta_t = 0; int key = 1; gtsam::Pose3 imu2Lidar = gtsam::Pose3(gtsam::Rot3(1, 0, 0, 0), gtsam::Point3(-extTrans.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fc9a74a7b07ce11e27efa027c86e8ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b98d5279161fbd48f5c663b26c1b98e0/" rel="bookmark">
			Linux关于iptables防火墙的配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		iptables防火墙 netfilter/iptables：工作在主机或网络的边缘，对于进出本主机或网络的报文根据事先定义好的检查规则作匹配检测，对于能够被规则所匹配到的报文做出相应的处理 iptables框架 iptables的4表
filter：数据过滤表 包含三个链：INPUT，UOTPUT，FORWARD nat：地址转换表，不能过滤数据包，仅仅修改数据包中的IP和端口 包含三个链：PREROUTING，POSTROUTING，OUTPUT raw：状态跟踪表，决定是否跟踪数据包 包含两个链：OUTPUT，PREROUTING mangle：包标记表，不能过滤也不能修改数据包 包含五个链：PREROUTING，FORWARD，POSTROUTING，INPUT，OUTPUT iptables的5链
PREROUTING链：路由前规则，防火墙在刚刚接收到数据包，对数据包进行路径选择之前所需要的链FORWARD链：转发规则，将数据包从一个网络转发到另外一个网络所需要的链POSTROUTING链：路由后规则，对数据包进行路径选择后，并在防火墙即将把数据包转发出去之前，所要需要的链INPUT链：入站规则，限制客户端数据包目地地址是防火墙主机的上层应用所需要的链OUTPUT链：出站规则，限制防火墙主机上层应用产生的数据包是否可以出站需要的链 目标操作
ACCEPT：允许通过/放行DROP：直接丢弃，不给出任何回应REJECT：拒绝通过，有明确回应LOG：记录日志，然后传给下一条规则 iptables命令格式 命令格式：Iptables [-t 表名] 选项 [链名] [条件] [-j 目标操作]
添加规则：
-A #追加一条防火墙规则至链的末尾-I #插入一条防火墙规则至链的开头 查看规则：
-L #查看iptables所有规则，与-n连用-n #以数字形式显示地址、端口等信息，与-L连用–line-numbers #查看规则时，显示规则的行号 删除规则：
-D #删除链内指定的序号（或内容）的一条规则-F #清空所有规则 默认规则：
-P #为指定的链设置默认规则 iptables防火墙规则的条件 通用匹配：
协议匹配：-p #协议名称
地址匹配：-s 源地址、-d 目标地址
接口匹配：-i 接受数据的网卡、-o 发送数据的网卡
端口匹配：–sport 源端口号、–dport 目标端口号
ICMP类别匹配：–icmp-type ICMP 类型
创建规则注意事项
可以不指定表，默认为filter表如果没有找到匹配条件，执行防火墙默认规则 主机型防火墙规则配置 #安装iptables服务 [root@master ~]# yum -y install iptables-services [root@master ~]# systemctl start iptables #拒绝icmp访问 [root@master ~]# iptables -t filter -I INPUT -p icmp -j REJECT #查看规则 [root@master ~]# iptables -L -n --line-numbers #测试icmp访问 [root@slave ~]# ping 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b98d5279161fbd48f5c663b26c1b98e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eaab28a46207e31b73c1c4c5ca9cfe4c/" rel="bookmark">
			login(登录).jsp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;%@ page language="java" contentType="text/html; charset=UTF-8"
pageEncoding="UTF-8"%&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"&gt;
&lt;title&gt;Insert title here&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form action="${pageContext.request.contextPath}/login" οnsubmit="return check()"&gt;
&lt;table border="1px"&gt;
&lt;tr&gt;
&lt;td&gt;用户名:&lt;/td&gt;
&lt;td&gt;&lt;input type="text" name="uname" id="uname"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;密码:&lt;/td&gt;
&lt;td&gt;&lt;input type="password" name="pwd" id="pwd"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td colspan="2"&gt;&lt;input type="submit" value="登录"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;script&gt;
function check()
{
var uname = document.getElementById("uname").value;
var pwd = document.getElementById("pwd").value;
if(uname==null || uname =='')
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eaab28a46207e31b73c1c4c5ca9cfe4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6d12ee4a0fe92e9fe8c086c952d2bf8/" rel="bookmark">
			java springboot 项目关于org.apache.shiro.authz.UnauthorizedException: Subject does not have permission
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： 提示：这里简述项目相关背景：
例如：项目场景：springboot 项目 后台 出现以下相关错误：
org.apache.shiro.authz.UnauthorizedException: Subject does not have permission Caused by: org.apache.shiro.authz.AuthorizationException: Not authorized to invoke method:
问题描述 提示：这里描述项目中遇到的问题：
相关截图如下图所示：
详细 控制台日志代码如下所示：
org.apache.shiro.authz.UnauthorizedException: Subject does not have permission [devops:repair:list] at org.apache.shiro.authz.ModularRealmAuthorizer.checkPermission(ModularRealmAuthorizer.java:323) at org.apache.shiro.mgt.AuthorizingSecurityManager.checkPermission(AuthorizingSecurityManager.java:137) at org.apache.shiro.subject.support.DelegatingSubject.checkPermission(DelegatingSubject.java:209) at org.apache.shiro.authz.aop.PermissionAnnotationHandler.assertAuthorized(PermissionAnnotationHandler.java:74) at org.apache.shiro.authz.aop.AuthorizingAnnotationMethodInterceptor.assertAuthorized(AuthorizingAnnotationMethodInterceptor.java:84) at org.apache.shiro.authz.aop.AnnotationsAuthorizingMethodInterceptor.assertAuthorized(AnnotationsAuthorizingMethodInterceptor.java:100) at org.apache.shiro.authz.aop.AuthorizingMethodInterceptor.invoke(AuthorizingMethodInterceptor.java:38) at org.apache.shiro.spring.security.interceptor.AopAllianceAnnotationsAuthorizingMethodInterceptor.invoke(AopAllianceAnnotationsAuthorizingMethodInterceptor.java:115) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) at org.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor.invoke(MethodBeforeAdviceInterceptor.java:56) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) at org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint.proceed(MethodInvocationProceedingJoinPoint.java:88) at com.yywl.common.aspect.ControllerAspect.around(ControllerAspect.java:132) at sun.reflect.GeneratedMethodAccessor488.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethodWithGivenArgs(AbstractAspectJAdvice.java:644) at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethod(AbstractAspectJAdvice.java:633) at org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6d12ee4a0fe92e9fe8c086c952d2bf8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b10c2a4eb6dcde2f8438447f631e47d7/" rel="bookmark">
			【JDBC：连接MySQL数据库】出现SQL注入的解决办法、什么时候需要使用SQL注入、事务的使用、悲观锁乐观锁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JDBC JDBC是什么？
Java Database Connectivity（java语言连接数据库）
java.sql.*;（这个包下有很多接口）
JDBC的本质是什么？
JDBC的本质是SUN公司制定的一套接口（interface）
接口都有调用者和实现者。面向接口调用、面向接口写实现类，这都属于面向接口编程。
为什么要面向接口编程？
解耦合：降低程序的耦合度，提高程序的扩展力。 多态机制就是非常典型的：面向抽象编程（不要面向具体编程） 建议： Animal a = new Cat(); Animal b = new Dog(); //喂养的方法 public void feed(Animal a){//面向父类型编程 } 不建议： Dog d = new Dog(); Cat c = new Cat(); //喂养方法 public void feed(Dog d){}//只能喂狗 public void feed(Cat c){}//只能喂猫 思考：为什么SUN制定一套JDBC接口呢？
因为每一个数据库的底层实现原理都不一样。
Oracle数据库有自己的原理、MySQL数据库也有自己的原理、MS SqlServer数据库也有自己的原理
…每一个数据库都有自己的实现原理。
JDBC开发前的准备工作，先从官网下载对应的驱动jar包，然后将其配置到环境变量classpass中
classpath=.;C:\Users\qishi\Desktop\typora markdown学习\JDBC\MySql Connector Java 5.1.23\mysql-connector-java-5.1.23-bin.jar 以上的配置是针对文本编辑器的方式开发，使用IDEA工具的时候，不需要配置以上的环境变量。IDEA有自己的配置方式
JDBC编程六步（需要记住）
第一步：注册驱动（作用：告诉java程序，即将要连接的是哪个品牌的数据库）第二步：获取连接（表示JVM的进程和数据库进程之间的通道打开了，属于进程之间的通信，重量级的，使用完毕之后一定要关闭通道。）第三步：获取数据库操作对象（专门执行sql语句的对象）第四步：执行SQL语句（DQL、DML…）第五步：处理查询结果集（只有当第四步执行的是select语句的时候，才执行处理查询结果）第六步：释放资源（使用完资源之后一定要关闭资源。java和数据库属于进程间的通信，开启之后一定要关闭） JDBC完成数据的插入
import java.sql.Driver; import java.sql.DriverManager; import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b10c2a4eb6dcde2f8438447f631e47d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/647a321330fb5ce36cf555c199e51ff5/" rel="bookmark">
			项目管理软件大对比：2023年15款最佳项目管理工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简单的项目只需要一个电子表格清单可能就管理好了，而复杂的项目则需要适当的规划、任务分配、设定截止日期，以确保每个人都遵守它们、大家进行紧密的协作，并追踪所花费的时间。
让项目量化、可视化，资源合理分配、更容易的协作和追踪等，这是现代工具的带来的价值。当下有非常多的项目管理软件，如果你是项目管理的新手，你可能很难确定哪个是符合需求，什么功能是有益的，什么是浪费你的时间的。下面我们将为你提供一些参考。
一、2023年15个最佳的项目管理工具 如果你在寻找项目管理软件，以下是你应该考虑的最佳项目管理软件工具。该清单中的软件包括免费和付费版本，以及每个计划中你可以得到的功能。
1.PingCode 这是一款国产化的产品研发项目管理工具，2021年被36氪评为：国内研发项目管理榜单TOP1。知名客户包括小红书、中国联通、北京银行、西安交大等。
PingCode 能够满足研发项目中一站式的管理需求，比如需求收集、需求管理、需求优先级、产品路线图、项目管理（敏捷/kanban/瀑布）、测试管理、缺陷追踪、项目文档管理、效能度量等，都能在PingCode一个工具上进行管理和协作。并且集成了github、gitlab、jinkens、企微、飞书等主流工具。
定价：为25人以下团队提供了免费版本。付费版本299/人/年起【版本价格及功能介绍】
部署方案：支持SaaS、私有部署、买断等方式，且支持信创、麒麟等国产化诉求。
优缺点：1.产品开箱即用，简单易上手，不需要像Jira 那样经过好几月的培训，以及专门的系统管理专家配置系统才可使用；但暂未提供多语言版本；也无法满足销售等业务团队的项目管理需求。
【官方地址：https://sc.pingcode.com/wic37】
2.Worktile 国内市场占有率最高的项目管理软件之一，中小团队项目管理工具最佳选择。被广泛用于电商、市场活动、律所项目、生产制造、行政、财务、设计、工程、教育、科研等几乎包含所有类型的项目。
在功能上Worktile 是一个工具集合，它具备OKR目标管理、项目管理、项目集管理、项目计划、项目风险、项目成本管理、企业网盘、审批、简报等能力。并且具备强大的自定义能力，能够配置出符合各种项目团队的流程、表单、字段、数据报表，以及具备丰富的模板市场。
定价：为10人以下团队提供免费版本。付费版本499/人/年起。【版本价格及功能介绍】
部署方案：与PingCode一样支持SaaS、私有部署、买断等方式，且支持信创、麒麟等国产化诉求。
优缺点：1.强大的自定义能力配置出符合各种项目团队的流程、表单、字段、数据报表，以及具备丰富的模板市场。2.但在一些垂直领域的项目管理深度低于垂直领域产品，比如在软件研发项目领域PingCode可能更加适合，在CRM项目上，Worktile可能能满足中小企业的管理需求，但在大型客户上纷享销客可能会更加合适。
【官方地址：https://sc.pingcode.com/m2k4l】
3.Trello Trello是一款适用于小团队和个人的在线项目管理软件。可让您的团队管理任何类型的项目、工作流或任务跟踪。它轻便、简单、直接易用。
定价：基本计划是免费使用的。然而，付费计划增加自动化，集成，优先支持等等。
购买方案：国内可能不支持本地版。
优缺点：1.简单易用，能够满足大部分的简单任务管理诉求。2.但报告功能和项目跟踪功能相对缺乏，所以它非常适合管理少量项目的个人或小团队。3.国内访问需要工具，否则访问速度会很慢。
【官方地址：https://trello.com/】
4.Asana Asana是一款灵活的saas项目管理工具，侧重于协作。有自动化的工作流程来自动化重复的任务。它直观，支持不同的任务显示方式和支持自定义字段和表单。你甚至可以邀请无限数量的访客用户。还有建立自定义规则和审批工作流程的选项。
Asana提供了很多关于效率和协作的优点，但大部分的核心项目管理功能则通过集成插件来补充，这可能并不适合所有用户。它适合所有规模的企业，但不适合自由职业者。一些用户感觉Asana的界面过于简单，系统过于僵硬，但不可否认它有强大的任务管理和协作特性。
定价：有一个最多15个用户的免费计划。他们的高级计划每月每用户10.99美元，支持时间线，报告，自定义字段，自动化规则等等。
优缺点：1.一些用户感觉Asana的界面过于简单，系统过于僵硬。2.国内访问同样存在问题。3.但是它支持了多国语言，且功能成熟。
【官方地址：https://asana.com/】
5.Zoho Projects Zoho Projects是Zoho的一款热门产品，它的核心功能包括：项目计划、协调团队、管理工程进度与流程等。Zoho Projects 能让您随时掌握自己的关键任务及其相依性，并立即显示规划进度和实际进度之间的任何偏差。Zoho Projects也拥有非常令人印象深刻的通信工具套件，包括实时聊天和论坛页面。
定价：Zoho提供了几种订阅计划的选择：
永久免费版本，具有基本功能和限制的用户标准计划费用为3美元，具有自定义状态和问题跟踪功能。支持多达10个用户。快速计划价格为4美元，支持多达50个用户。你会得到重复任务，甘特图，和时间表审批等功能。高级计划从5美元开始，支持多达100个用户。包括任务自动化，业务规则，资源利用和预算编制等功能。企业计划价格为6美元，没有用户数量上限。可用的功能包括自定义角色，全局甘特图，项目间依赖性等。
所有计划都是每用户每月。 优缺点：1.Zoho Projects 是一款以易于使用、实施和配置而著称的工具。它是定制化能力，使我能够在办公室内外管理和协调我们所有的项目。多亏了这个工具，我可以创建自定义字段、布局、状态和工作流，我可以轻松地创建任务并委派团队成员来执行它。2.许多用户说甘特图很难使用，大型团队的报告细分可能不够。3.国外用户评价它不支持任何标准项目管理流程（PMI、PRINCE2 等）。
【官方地址：https://www.zoho.com/projects】
6.Wrike Wrike是一款基于云的项目管理工具，其核心功能包括：任务管理、时间表（甘特图）、实时提醒、文档协作、任务讨论、任务优先级别、自定义报告、工作量管理、时间追踪等等。它还有很多集成选项，使其成为一个强大的项目管理套件。
它非常适合组织内的不同团队，如市场营销，软件开发和专业服务。
定价：有一个功能有限的免费版本，最多支持五个用户。付费计划从每用户每月9.80美元开始。还有一个商业计划，价格为每用户每月24.80美元。
优缺点：1.Wrike 允许我们创建由不同工作流程和流程组成的项目；2.同时应用于多种类型的项目团队；3.但有非常大的学习成本，用户界面较丑，大多数用户不喜欢它。4.且国内无法购买私有版本。
【官方地址：https://www.wrike.com/vx/】
7.Monday.com monday.com 是国外的一个效率工具，它可以给自由职业者来管理项目，也可以对需要多人团队协同的项目进行管理。它可以让中小型企业在无代码的环境中构建自定义工作流应用程序以运行项目，流程和日常工作。
定价：Monday.com并没有提供免费版本。但有30天的免费试用期。定价计划根据用户数量和需要的功能而变化，价格从每月8美元开始。
优缺点：1.它易于学习，易于理解；2.集成中心支持与Slack，Dropbox，Teams，Outlook和许多其他应用程序轻松集成；3.该平台可以定制以满足每个用户的个人需求，并提供模板和选项来创建定制的工作流程。4.不在大陆提供服务，所以更适合海外或者是跨国团队使用。
【官方地址：https://monday.com/project-management】
8.ProofHub ProofHub强调简洁，因此集成的工具非常少，任务管理也相当有限。无论对于自由职业者还是各种规模的企业，ProofHub都是一个不错的选择。
ProofHub提供了一个集中的工作空间，用于任务列表、工作流、甘特图、讨论、日历和文档。它帮助你规划、组织并跟踪团队的任务。它还使得团队内部以及与外部客户的协作变得简单。有很多报告，如工作负载和资源报告。
定价：ProofHub对用户数量没有上限，并提供了无论用户数量多少都一样的固定费用。有两个计划：Essential计划的价格是每月50美元，而Ultimate Control计划的费用是每月99美元。
优缺点：具备强大的规划和监控管理功能，但缺少一些能力，比如从其他工具迁移数据、以及笔记等能力。
【官方地址：https://www.proofhub.com/】
9.Clarizen（改名Planview） Clarizen是一款评价非常高的在线项目管理软件，适用于中型到大型企业。但它只支持基于网络的项目管理，所以对于一些团队来说，缺少本地部署等特点可能会限制其实用性。Clarizen最适合需要强大、灵活和直观的基于网络的项目管理软件的企业级项目经理、IT组织和专业服务团队。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/647a321330fb5ce36cf555c199e51ff5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/935ae055692fb14ebae57614a8f87e7d/" rel="bookmark">
			如何零基础入门编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		每个人都应该学习计算机编程，因为它教会你如何思考。
——史蒂夫 • 乔布斯
随着技术的进步，我们的日常生活和社会环境都变得越来越方便和丰富，智能手机和互联网已经成了我们生活中不可或缺的一部分。
据说十年、二十年后，我们将迎来一个计算机（人工智能）和机器人取代人类从事各种工作的时代。现在的孩子长大后走入社会时，信息技术的重要性将比现在大得多！
现在已经有许多国家将计算机编程列入了中小学教育必修课程，下面分享一个零基础入门编程的书单，希望对你有帮助。
编程是一项充满乐趣的挑战，想要上手其实挺容易！
在实践中入门 01 编程语言：Python
Python是一种计算机程序设计语言，越来越多被用于独立的、大型项目的开发。
《父与子的编程之旅：与小卡特一起学Python》
上到88，下到8岁，都可以读这本书！
只要懂得计算机的基本操作，如启动程序、保存文件，任何人都可以跟着本书学会编写程序，甚至制作游戏。
内容介绍：
这本书以一对父子的角度，全面地介绍了计算机编程世界。书中内容以简单易学的Python语言为例，通过可爱的漫画、有趣的例子，生动地介绍了变量、循环、输入和输出、数据结构以及图形用户界面等编程的基本概念。本书内容经过教育专家的评审，经过孩子的亲身检验，并得到了家长的认可。
《Python编程：从入门到实践》
编程语言分类里销量和口碑最好的一本书！
它旨在让你尽快学会Python，以便能够编写能正确运行的程序——游戏、数据可视化和Web应用程序，同时掌握让你终身受益的基本编程知识。
适合任何年龄的读者阅读，它不要求你有任何Python编程经验，甚至不要求你有编程经验。
内容介绍：
全书分两部分：第一部分介绍用Python编程所必须了解的基本概念，包括 matplotlib、NumPy和Pygal等强大的Python库和工具介绍，以及列表、字典、if语句、类、文件与异常、代码测试等内容；第二部分将理论付诸实践，讲解如何开发三个项目，包括简单的Python 2D游戏开发，如何利用数据生成交互式的信息图，以及创建和定制简单的Web应用，并帮读者解决常见编程问题和困惑。
02 手机编程软件：App Inventor
App Inventor是无需编程的可视化App开发工具，它让人人都会开发应用变为现实。
《写给大家看的安卓应用开发书》
参与App Inventor开发的世界一流教师和软件工程师联合著作！
对App开发感兴趣但没有编程背景的人以及有一定经验的开发者都可阅读。
内容介绍：
本书由浅入深地介绍了强大的可视化编程工具App Inventor 2，任何人都可以用它来开发自己的应用。作者汇集了13个有趣的例子，读者可以跟随书中的讲解，亲手创建这些应用，从实践中学会开发安卓应用的基本知识与技术。另外，作者还从计算机科学及工程技术的角度出发，给出了详尽的开发指南，力图让读者对创建应用获得更本质的理解。
《App Inventor开发训练营》
国内App Inventor推广先驱、“老巫婆”金从军新作！
学习编程只需具备两个条件：会使用“如果……则……否则……”造句；会运用四则运算解简单的应用题。也就是说，小学高年级学生就可以开始学习编程了。
内容介绍：
本书带领读者通过动手实践数个编程实例来了解程序开发的逻辑。书中内容共分为21章，包含15个完整的应用，覆盖了游戏、教学、工具、信息管理以及网络应用等。本书不仅详细介绍了应用开发的步骤和要点，还针对每种应用的特征给出了进一步优化的建议，忠实还原了应用开发过程中遇到的问题和解决方法，是一本不可多得的编程技术与理念并重的实践指南。
03 编程工具：Sunaba
用来编写程序的语言：Sunaba，名字的实际意思就是沙地，在沙地上摔倒不会受伤，可以尽情发挥想象力。
《我的第一本编程书》
这本编程入门书目的在于教会读者编程的基本思路和方法。
这本书面向的是完全没有接触过编程的读者。作者将门槛设置得非常低，读者不需要懂得变量、函数这些名词（这些名词在书中也不会出现），不需要会英语，完全不需要查阅其他书籍，只需要小学算术水平即可。这本书给初学者非常平缓的学习曲线，有利于为之后的进阶学习打下坚实的基础。
内容介绍：
书中使用专门的工具Sunaba，向读者展示如何从零开始一步步做出一个完整的程序。本书讲解详细、连贯，并采用了大量能与现实生活相结合的例子。特别是在对编程思路的介绍上，作者不惜笔墨，进行了详细的说明。
奠定计算机理论基础 01 日系图解三件套
日系入门书以通俗易懂闻名，图解趣味版计算机基础知识。
《计算机是怎样跑起来的》
“计算机科学概论”图解趣味版，蹲马桶就能看懂的硬件&amp;软件基础知识！
在纸上体验微型计算机的制作过程，消除对硬件的恐惧；完成一次手工汇编，加深对计算机的理解；理解程序的流程、面向对象的编程、数据库以及XML；抓住7个要点，与算法和数据结构成为好朋友；通过7个实验，理解TCP/IP网络协议；原来，计算机并不难！
内容介绍：
本书以图配文，以计算机的三大原则为开端、相继介绍了计算机的结构、手工汇编、程序流程、算法、数据结构、面向对象编程、数据库、TCP/IP 网络、数据加密、XML、计算机系统开发以及SE 的相关知识。
《网络是怎样连接的》
“计算机网络概论”图解趣味版，蹲马桶就能看懂的网络基础知识！
如果你好奇从在浏览器中输入网址到显示出网页内容，网络中到底发生了什么？如果你想知道网络设备和软件在网络内部是如何工作的？ 如果你已经掌握了一些零散的网络知识，但是想要形成完整的知识脉络？如果你想在工作和生活中更好地应用网络？那么就该读一读这本书，全面系统地掌握网络基础知识！
内容介绍：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/935ae055692fb14ebae57614a8f87e7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3b3c1561afc3e956bce3fe57fc08e90/" rel="bookmark">
			【严重】vm2 ＜3.9.18 沙箱逃逸漏洞（存在POC）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		漏洞描述 vm2 是一个基于 Node.js 的沙箱环境，可以使用列入白名单的 Node 内置模块运行不受信任的代码，代理对象用于拦截并重定义宿主对象的各种操作。
vm2 3.9.18之前版本中，由于 prepareStackTrace 函数直接由 V8 引擎调用，其中的 error 参数没有经过 vm2 库定义的处理程序代理，导致沙箱的保护机制失效。攻击者可通过构造错误对象和代理对象，进而访问主机上下文中的 Function 构造函数执行任意系统命令。
漏洞名称vm2 ❤️.9.18 沙箱逃逸漏洞漏洞类型注入发现时间2023/5/16漏洞影响广度广MPS编号MPS-h8kx-5m1pCVE编号CVE-2023-32314CNVD编号- 影响范围 vm2@[0.1.0, 3.9.18)
修复方案 将组件 vm2 升级至 3.9.18 及以上版本
参考链接 https://www.oscs1024.com/hd/MPS-h8kx-5m1p
https://nvd.nist.gov/vuln/detail/CVE-2023-32314
https://github.com/patriksimek/vm2/security/advisories/GHSA-whpj-8f3w-67p5
https://gist.github.com/arkark/e9f5cf5782dec8321095be3e52acf5ac
https://github.com/patriksimek/vm2/commit/d88105f99752305c5b8a77b63ddee3ec86912daf
关于墨菲安全 墨菲安全是一家为您提供专业的软件供应链安全管理的科技公司，核心团队来自百度、华为、乌云等企业，公司为客户提供完整的软件供应链安全管理平台，围绕SBOM提供软件全生命周期的安全管理，平台能力包括软件成分分析、源安全管理、容器镜像检测、漏洞情报预警及商业软件供应链准入评估等多个产品。为客户提供从供应链资产识别管理、风险检测、安全控制、一键修复的完整控制能力。
开源项目：https://github.com/murphysecurity/murphysec/?sf=qbyj
产品可以极低成本的和现有开发流程中的各种工具一键打通，包括 IDE、Gitlab、Bitbucket、Jenkins、Harbor、Nexus 等数十种工具无缝集成。
免费代码安全检测工具： https://www.murphysec.com/?sf=qbyj
免费情报订阅： https://www.oscs1024.com/cm/?sf=qbyj
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d66013a550f1b20f61838a739018f826/" rel="bookmark">
			Termius 最好用的SSH 连接工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Termius 最好用的SSH 连接工具 一、环境准备二、配置2.1 terminus 安装2.2 删除自动更新2.3 修改用户信息 三、使用四、页面展示 该工具 mac os 可直接使用
本文只展示 windows 使用步骤，本教程使用的 termius 版本为 7.59.6
一、环境准备 termius 下载
官网下载地址
文件编译器
建议使用 vscode
本机环境
需要安装 node.js，会用到其中的 npm 包管理工具 ，yarn 也可
npm install -g asar yarn add -g asar 二、配置 2.1 terminus 安装 双击 terminus 安装包，直接安装。默认安装在 C 盘，不可修改安装目录。
默认根目录：C:\Users\XXX\AppData\Local\Programs\Termius
# 在 termius 根目录/resources下， 打开控制台执行 asar e app.asar app 2.2 删除自动更新 删除根目录下 resources 文件夹下 文件
根目录/resources/app-update.yml
2.3 修改用户信息 打开 resources\app\js 下的 ui-process.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d66013a550f1b20f61838a739018f826/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a540bc707386dad8a9deeb1f7a2c56a3/" rel="bookmark">
			公共表表达式CTE递归查询学习篇1：WITH RECURSIVE关键字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注：本文使用的是最新版的PgSQL(2023.06.07)
问题背景：在公司内的B2B电商系统中，下游交易环节，需要用户选择地址，而我采用了 省、市、区、街道 四级地址结构，例如：广东省→广州市→海珠区→江海街道。这是一条完整的地址层级关系。此时引入了Github中比较新(2023年6月4日更新)的地址关系csv。为了减少前端调用接口的次数，我选择在选择 xx市 之后使用递归查询将街道信息一并查出给前端。
地址表和转换SQL教程GitHub链接如下： GitHub - xiangyuecn/AreaCity-JsSpider-StatsGov: 省市区县乡镇三级或四级城市数据，带拼音标注、坐标、行政区域边界范围；2023年06月04日最新采集，提供csv格式文件，支持在线转成多级联动js代码、通用json格式，提供软件转成shp、geojson、sql、导入数据库；带浏览器里面运行的js采集源码，综合了中华人民共和国民政部、国家统计局、高德地图、腾讯地图行政区划数据https://github.com/xiangyuecn/AreaCity-JsSpider-StatsGov
Step1：了解表结构 直接上表结构：
表采用了四级地址结构：省、市、区(县)、街道。
Step2：了解需求：根据父级id递归查询所有子级目录。 熟悉表结构后，我们就可以开始递归查询实践了。
首先我们以广州市为例：id=4401。 需求：已知广州市主键id，我们要查出所有和广州市有关的子级数据。
那么，按照我们最简单、最常规的方法，就是通过parent_id去匹配后面两个子级的数据：
#查出三级(区)地址 SELECT * FROM b2b_area WHERE parent_id = 4401; #查出四级(街道)地址，其中l2.id是三级地址的id SELECT * FROM b2b_area WHERE parent_id = l3.id; 这里，我们使用了两个查询来完成广州市的子级地址查询。
1.问：但是，这不是也可以通过子查询的方法来完成吗？
1.答：是的，但这仅限于你在知道表中数据的层次情况下，才能通过子查询的方式完成，万一表的层次结构有10级怎么办？那就得写10个子查询。如果我压根不知道他到底有几层结构呢？很显然，用 子查询的方法 对于 多层级结构的数据 和 未知层级结构的数据表 来说，并不通用。
2.问：那对于这两种数据，该怎么解决？
2.答：用我们今天的主角 《CTE公共表拓展：递归表达式》。
Step3：使用CTE递归查出所有子级数据。 直接上代码：
WITH RECURSIVE addr_hierarchy(id, name, parent_id, level) AS ( -- 基本情况（市级地址） SELECT id, name, parent_id, area_level FROM b2b_area WHERE parent_id = 4401 UNION ALL -- 递归情况 SELECT ch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a540bc707386dad8a9deeb1f7a2c56a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43523d58851afee10aabd8e7e043a970/" rel="bookmark">
			自定义组件中，使用onLoad,onShow生命周期失效问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		的解决方法 自定义组件中，使用onLoad,onShow生命周期失效问题 自定义组件中，使用onLoad,onShow生命周期失效问题 官方文档可查阅到：
页面生命周期仅在page中的vue页面有效，而单独封装的组件中【页面周期无效】，但是Vue的生命周期依然有效 【Vue的生命周期在任何地方都是有效的】，
组件页面只能使用vue生命周期函数。
解决方案：
1.用vue生命周期函数created（），mounted（）替换，如果页面想要实时更新页面的效果不建议使用。（mounted函数存在延迟，即当前组件加载后，如果想要实时更新页面效果，还需要切换其他组件，再切换回来才能实现页面效果）
2.子组件上添加ref，父组件通过ref在页面相对应的生命周期函数中调用子组件的方法（如刷新列表数据）
子组件在methods中定义一个盛放onload和onshow中代码的函数（函数名：onLoadMethod）。在父组件显示该组件时通过ref调用子组件onLoadMethod方法。
补充知识：
uniapp中有应用生命周期、页面生命周期、组件生命周期（同vue标准组件的生命周期相同）
uni-app支持的应用生命周期：
注意：应用生命周期仅可在App.vue中监听，在其它页面监听无效。
uni-app支持的页面生命周期函数：
注意：页面生命周期仅在page页面有效，而单独封装的组件中【页面周期无效】，但是Vue
的生命周期依然有效 【Vue的生命周期在任何地方都是有效的】
uni-app组件生命周期函数（同vue）
vue生命周期函数（vue3 选项式api）：
参考：https://blog.csdn.net/qq_51250105/article/details/130065729?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-130065729-blog-129879407.235%5Ev38%5Epc_relevant_anti_t3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-130065729-blog-129879407.235%5Ev38%5Epc_relevant_anti_t3&amp;utm_relevant_index=2
https://blog.csdn.net/m0_58889179/article/details/129879407?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-129879407-blog-105355651.235%5Ev38%5Epc_relevant_anti_t3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-129879407-blog-105355651.235%5Ev38%5Epc_relevant_anti_t3&amp;utm_relevant_index=2
https://blog.csdn.net/zlsjune123/article/details/105355651?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-105355651-blog-129879407.235%5Ev38%5Epc_relevant_anti_t3&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-105355651-blog-129879407.235%5Ev38%5Epc_relevant_anti_t3&amp;utm_relevant_index=1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e59fe0bb6302d57d37f1c74667cdcb36/" rel="bookmark">
			【RocketMQ】sendDefaultImpl call timeout发送超时
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误异常：Caused by: org.apache.rocketmq.remoting.exception.RemotingTooMuchRequestException: sendDefaultImpl call timeout
原因：控制台集群地址是服务器内网的地址，必须改为外网的地址
查看服务器防火墙是否关闭 查看防火墙状态 systemctl status firewalld
关闭防火墙 systemctl stop firewalld
修改配置文件
我们需要修改rocketmq的安装目录下的conf/broker.conf文件,在文件后追加如下内容 brokerIP1=服务器ip地址
nameSrvAddr=服务器IP地址:端口号
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a857556e8bef58745c3c2bb367d29a61/" rel="bookmark">
			hexview 命令行操作使用说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hexview 命令行操作使用说明 命令行操作基础格式 hexview.exe infile [option] -o outfile 提取部分内容 hexview.exe app.hex /AR:0X200000-0X303404 /s /XI -o app1.hex /AR：指定提取的范围。（也可以使用/CR，它可以指定多个范围，/CR:range1[:range2]）。range格式可以是起始地址和结束地址：addr1-addr2，也可以是起始地址加长度：addr1,length。
/s：后台运行。不启动GUI界面，可以加/eerrorlog.txt，输出错误日志。
/XI：指定导出格式为Intel Hex格式。
-o：输出文件名称。
提取并转化格式 hexview.exe app.hex /AR:0X200000-0X303404 /s /XN /eerror.log -o app1.hex 作用：提取app.hex固件中的0x200000-0x203404，并转换为.bin格式文件。
/XN：指定导出格式为data binary格式。
注意：虽然上述操作能提取成功，但是会将hex中的所有block无缝合并到一起，block之间的空白部分内容会被剔除。因此，为了将HEX格式固件转化为BIN格式固件时，需要先填充空白内容，再输出。
hexview.exe app.hex /AR:0x200000-0x303404 /s /elog.txt /FR:0x200000-0x303404 /FP:FF /XN -o app.bin /FR：指定需要填充的范围。多个范围可以用/FR:range1:range2等分隔。填充时，范围内，只会填充空白部分，非空白部分，不会进行覆盖填充。
/FP：指定/FR范围内需要填充部分的填充内容的模式串，为16进制数，/FPAABBCCDD。
使用此操作将HEX转化为BIN时，可以避免空白部分被删除，解决前述问题。
转化固件为C语言数组 hexview.exe .\StartupBuild.hex /AR:0XFE002888-0XFE002B01 /s /FP:FF /XC -o flashdriver.c /XC : 指定输出文件格式为C语言文件。
删除固件中的某段内容 hexview.exe .\StartupBuild.hex /CR:0XFE002B00-0XFE002D7D /s /XI -o StartupBuild.hex /CR: 裁减掉范围的内容。通过 : 连接多个地址范围。@TOC
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97e36553bdff2008ad50fb384a52bfb8/" rel="bookmark">
			kali网络配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.配置临时IP 建议：此处丌要设置，而直接进行永久配置 IP
┌──(root💀piloteer-101)-[~]
└─# ifconfig eth0 192.168.1.111/24 #配置临时 IP 地址。
┌──(root💀piloteer-101)-[~]
└─# route add default gw 192.168.1.1 #配置默认路由。
┌──(root💀piloteer-101)-[~]
└─# echo nameserver 8.8.8.8 &gt; /etc/resolv.conf #配置 DNS 服务器。
注意：在刚安装完操作系统时，而直接配置临时 IP 地址，可能会报错
报错过程：
可以正常配置临时 IP 地址，但是在配置网关时则提示“SIOCADDRT: 网络丌可达”
原因：
是因为网卡配置文件中缺少了 auto eth0 和 iface eth0 inet dhcp 这两项。
觋决方法：
┌──(root💀piloteer-101)-[~]
└─# vim /etc/network/interfaces #修改网卡配置文件，在末行中添加如下两项：
auto eth0
iface eth0 inet dhcp
┌──(root💀piloteer-101)-[~]
└─# /etc/init.d/networking restart #重启网络服务。
重新配置：
┌──(root💀piloteer-101)-[~]
└─# ifconfig eth0 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97e36553bdff2008ad50fb384a52bfb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/584434d0877a5098598a909c7e2c8a76/" rel="bookmark">
			EMQX 安装使用和部分坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0、前言 1、强烈建议查看官方文档，说的是真的不错，浅显易懂：EMQ 提供了通俗易懂的技术文章，帮助开发者快速了解 MQTT 协议及其相关特性
2、在我使用到现在，对比了很多MQTT broker，EMQX 几乎是完美的，只有一点限制，那就是开源版本不支持消息持久化
3、当然直接使用官方编译好的方式，启动也是不错的，很简单，也是很推荐的，官方文档的安装步骤一栏就有，记得选好版本欧
官方安装文档地址
点击上面箭头的链接，就会跳转了
一、安装 1、这里安装使用docker安装，版本为4.4.9，目前为止版本已经到5.x，但是本着先不用最新版本的原则，就先使用4.x版本
官网文档：4.4版本中文官方文档，左下角有切换版本和语言的按钮，选择对应的版本就好
2、从 dockerHub中找到对应的镜像版本 emqx/emqx
3、我就使用4.4.9版本的镜像就🆗。
4、建立对应的数据挂载目录，至于为什么挂载这些目录，是因为这些目录比较重要，可以看官方的目录解释
mkdir -p /data/docker/emqx/{etc,lib,data,log} 5、先运行一个demo 的emqx，就是没有挂载的镜像版本，为了将对应的目录文件copy出来，因为等下如果挂载，会读取挂载目录的数据，所以我们又不知道要那些数据，所以先跑一个demo，把对应文件数据copy出来，后面用来挂载即可
对应端口说明，如下图，其中挂载一个时间是因为，我发现这个镜像的时区不对，比我们少8个小时，所以挂载下时区，就可以保证和系统是一致的了
docker run -d --name emqx -v /etc/localtime:/etc/localtime -p 1883:1883 -p 8081:8081 -p 8083:8083 -p 8084:8084 -p 8883:8883 -p 18083:18083 emqx/emqx:4.4.9 6、将对应的问价copy到我们前面建立的目录中,copy完成之后，就会发现我们的目录有数据了，这都是默认的基础配置，后面就可以用它们来挂载
docker cp emqx:/opt/emqx/etc /data/docker/emqx docker cp emqx:/opt/emqx/lib /data/docker/emqx docker cp emqx:/opt/emqx/data /data/docker/emqx docker cp emqx:/opt/emqx/log /data/docker/emqx 7、修改目录权限
chown -R 1000:1000 /data/docker/emqx/ chmod -R 755 /data/docker/emqx/ 8、删除不用的，建立完整的镜像
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/584434d0877a5098598a909c7e2c8a76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb72ff0c554dfa56902af6820138741a/" rel="bookmark">
			python毕业设计如何选题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、python 毕设 选题推荐二、选题注意事项2.1 难度怎么把控？2.2 题目名称怎么取？ 三、开题指导3.1 起因3.2 如何避坑(重中之重)3.3 为什么这么说呢？ 四、最后 一、python 毕设 选题推荐 以下为学长手动整理python 毕业设计 项目，完全可以作为当前较新的毕业设计题目选择方向，给各位同学参考
1 基于MapReduce的气候数据的分析
2 基于关键词的文本知识的挖掘系统的设计与实现
3 基于概率图模型的蛋白质功能预测
4 基于第三方库的人脸识别系统的设计与实现
5 基于hbase搜索引擎的设计与实现
6 基于Spark-Streaming的黑名单实时过滤系统的设计与实现
7 客户潜在价值评估系统的设计与实现
8 基于神经网络的文本分类的设计与实现
9 基于Apriori的商品关联关系分析与挖掘
10 基于词频统计的中文分词系统的设计与实现
11 K-means算法在微博数据挖掘中的应用
12 图像对象检测分析系统的研究和应用
13 基于Apriori关联规则的电子商务潜在客户的数据挖掘
14 基于Spark的电商用户行为分析系统的设计与实现
15 音乐推荐系统的研究与应用
16 基于大数据的高校网络舆情监控引导系统的研究与应用
17 基于医疗大数据的肿瘤疾病模式分析与研究
18 基于支持向量机的空间数据挖掘及其在旅游地理经济中的应用
19 基于深度残差网络的糖尿病视网膜病变分类检测研究
20 基于大数据分析的门户信息推荐系统
21 Web数据挖掘及其在电子商务中的研究与应用
22 面向电信CRM的数据挖掘研究与应用
23 基于物联网的小麦生长环境数据采集与数据挖掘技术研究与应用
24 基于k-means算法在微博数据挖掘中的应用
25 Apriori关联规则算法的数据挖掘技术挖掘电子商务潜在客户的应用
26 基于大数据的个性化学习环境构建的研究与应用
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb72ff0c554dfa56902af6820138741a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/515365be6662624ac3e3a2a568f0de2d/" rel="bookmark">
			filezilla 搭建ftp服务器，配合花生壳进行外网访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、下载filezilla，安装教程网上很多 fillazilla server端官网下载：https://www.filezilla.cn/download/server
百度网盘下载：https://pan.baidu.com/s/1owsBlYqQHuS54t-RYvZkcw?pwd=wc8z
此版本为：FileZilla Server 0.9.60.2 中文安装版
2、安装花生壳，免费版两个映射就可以了，网上有教程 3、打开filezilla，界面如下 4、创建用户和密码 5、添加共享文件夹 6、设置参数 7、打开花生壳，设置映射 8、重新回到filezilla 9、文件资源管理器进行访问 10、然后就显示出你共享文件夹重的内容 11、并且，在filezilla客户端上，也是可以连接ftp的 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a1b654dd631e1449afe5df204b7ea67/" rel="bookmark">
			人工智能基础数据服务行业相关政策汇总（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人工智能产业的快速增长带动了AI基础数据服务市场的蓬勃发展。以自动驾驶场景为代表的AI算法模型训练与升级迭代进一步催生了规模庞大的数据服务需求。
根据德勤相关统计数据显示，未来几年，人工智能基础数据服务市场将保持高速增长，相关市场规模有望达到130-160 亿元。
本文将继续总结归纳近年来国家以及地方政府出台的关于人工智能基础数据服务行业的重要相关政策。
上一篇详见：《人工智能基础数据服务行业相关政策汇总》。
一、北京市政府办公厅发布《北京市促进通用人工智能创新发展的若干措施》
加快建设数据基础制度先行先试示范区，探索打造数据训练基地，推动数据要素高水平开放，提升本市人工智能数据标注库规模和质量。鼓励开展内容信息服务的互联网平台提供高质量语料数据，供创新主体申请使用。探索基于数据贡献、模型应用的商业化场景合作。
以众包服务方式，建设数据集精细化标注平台，开发智能云服务系统，集成相关工具应用。鼓励并组织来自不同学科的专业人员参与标注多模态训练数据及指令数据，提高数据集质量。研究平台激励机制，推动平台持续良性发展。
围绕训练数据“采、存、管、研、用”等环节，研究互联网数据全量实时更新技术、多源异构数据整合与分类方法，构建数据管理平台相关系统，研发数据清洗、标注、分类、注释及内容审查等算法及工具。
二、中共中央 国务院印发《数字中国建设整体布局规划》
构建国家数据管理体制机制，健全各级数据统筹管理机构。推动公共数据汇聚利用，建设公共卫生、科技、教育等重要领域国家数据资源库。释放商业数据价值潜能，加快建立数据产权制度，开展数据资产计价研究，建立数据要素按价值贡献参与分配机制。
三、国务院关于印发“十四五”数字经济发展规划的通知
数据要素市场体系初步建立。数据资源体系基本建成，利用数据资源推动研发、生产、流通、服务、消费全价值链协同。数据要素市场化建设成效显现，数据确权、定价、交易有序开展，探索建立与数据要素价值和贡献相适应的收入分配机制，激发市场主体创新活力。
强化高质量数据要素供给。支持市场主体依法合规开展数据采集，聚焦数据的标注、清洗、脱敏、脱密、聚合、分析等环节，提升数据资源处理能力，培育壮大数据服务产业。推动数据资源标准体系建设，提升数据管理水平和数据质量，探索面向业务应用的共享、交换、协作和开放。加快推动各领域通信协议兼容统一，打破技术和协议壁垒，努力实现互通互操作，形成完整贯通的数据链。推动数据分类分级管理，强化数据安全风险评估、监测预警和应急处置。深化政务数据跨层级、跨地域、跨部门有序共享。建立健全国家公共数据资源体系，统筹公共数据资源开发利用，推动基础公共数据安全有序开放，构建统一的国家公共数据开放平台和开发利用端口，提升公共数据开放水平，释放数据红利。
加快数据要素市场化流通。加快构建数据要素市场规则，培育市场主体、完善治理体系，促进数据要素市场流通。鼓励市场主体探索数据资产定价机制，推动形成数据资产目录，逐步完善数据定价体系。规范数据交易管理，培育规范的数据交易平台和市场主体，建立健全数据资产评估、登记结算、交易撮合、争议仲裁等市场运营体系，提升数据交易效率。严厉打击数据黑市交易，营造安全有序的市场环境。
四、组建国家数据局
十四届全国人大一次会议举行第二次全会，会议中根据国务院关于提请审议国务院机构改革方案的议案组建国家数据局。国家数据局由国家发展和改革委员会管理，负责协调推进数据基础制度建设，统筹数据资源整合共享和开发利用，统筹推进数字中国、数字经济、数字社会规划和建设。
五、关于印发黑龙江省“十四五”数字经济发展规划的通知
夯实大数据产业发展基础，完善基础设施，强化自主基础软硬件的底层支撑能力，推动自主开源框架、组件和工具的研发。大力发展数据服务产业，鼓励企业开展数据清洗、脱敏、建模、分析挖掘、应用服务等大数据分析和技术服务，发展数据标注和数据分析企业，拓展采集、交易等专业化数据服务新业态。
六、关于印发江苏省“十四五”数字经济发展规划的通知
探索数据要素流通交易。推动省内企业、高校、科研院所开展数据确权、数据质量评估、数据资产定价等数据价值化研究，建立健全数据流通、交易标准规范。推进数据安全管控技术、数据产业链模式等创新研究，提升数据衍生服务水平。探索公共数据授权许可和运营机制，以公共数据授权开放、定向开放或者政企数据互换（融合）等方式，创新数据资源共享方式和运营模式。创新数据服务模式，强化数据清洗、数据标注、数据加工等数据服务供给，鼓励发展数据银行、数据信托、数据中介等新兴服务业态，因地制宜建设以数据资产登记、数据交易流通为主要业务的数据交易机构。鼓励有条件的地区开展数据交易试点，积极参与国家数据要素市场化配置改革试点示范。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab50caa2b260c708cda7e2d253f77cb9/" rel="bookmark">
			mybatis-plus 使用更复杂的模糊查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4919eb51b5ad9e361a407ba2a5ec7fe9/" rel="bookmark">
			Java stream多字段分组（groupingBy）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近期的项目里，遇到一个需求：对于含有多个元素的List&lt;Person&gt;，按照其中的某几个属性进行分组，比如Persion::getAge、Persion::getType、Persion::getGender等字段。下面就让我们讨论一下如何比较优雅的按多字段进行分组groupingBy。
利用Stream进行分组 Stream是Java8的一个新特性，主要用户集合数据的处理，如排序、过滤、去重等等功能，这里我们不展开讲解。本文主要讲解的是利用Stream.collect()来对List进行分组。
Person类Person.java：
public class Person { /** * id */ private Integer id; /** * 年龄 */ private Integer age; /** * 类型 */ private String type; /** * 姓名 */ private String name; /** * 性别 */ private String gender; public Integer getId() { return id; } public Person setId(Integer id) { this.id = id; return this; } public Integer getAge() { return age; } public Person setAge(Integer age) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4919eb51b5ad9e361a407ba2a5ec7fe9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f510ba955c6bd66c4df772cc0190d6eb/" rel="bookmark">
			超详细280页Docker实战文档！开放下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ChatGPT狂飙160天，世界已经不是之前的样子。
新建了人工智能中文站https://ai.weoknow.com
每天给大家更新可用的国内可用chatGPT资源
Docker如日中天，这不是单纯的炒概念，Docker确确实实解决了开发与运维的痛点，因此在企业开发中得到了非常广泛的使用。
Docker是一个开放源代码软件项目，让应用程序部署在软件容器下的工作可以自动化进行，借此在Linux操作系统上，提供一-个额外的软件抽象层，以及操作系统层虚拟化的自动管理机制。
今天分享的这份资料，280页的Docker实战手册，相信这套资料看完后会让你对Docker有更深入的了解。而且这份实战手册真的很火，开放两天超3W人下载！！
下面给大家重点说下这份280页的实战手册，由于文档实战内容过多，在此只以截图展示部分内容，详细完整版下载方式见文末。
第一章：欢迎来到Docker 世界： 1.什么是Docker
2. Docker 解决了什么问题
3. 为什么Docker 如此重要
4. 何时何处使用Docker
5.案例："Hello World"
第二章：在容器中运行软件： 1.从Docker 命令行工具获得帮助
2.控制容器：建立一个网站的监控器
3. 已解决的问题和PID 命名空间
4. 消除元数据冲突：构建一个网站农场
5. 构建与环境无关的系统
6. 建立持久化的容器
7.清理
第三章：软件安装的简化： 1. 选择所需的软件
2. 什么是仓库
3. 查找和安装软件
4. 命令行使用Docker Hub
5.通过网站访问Docker Hub
6.使用替代注册服务器
7.镜像文件
8. 从Dockerfile 安装
9.安装文件和隔离
第四章：持久化存储和卷间状态共享： 1. 存储卷的简介
2. 存储卷的类型
3.共享存储卷
4.管理卷的生命周期
5. 存储卷的高级容器模式
第五章：网络访问： 1. 网络相关的背景知识
2. Docker 的网络
3.Closed 容器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f510ba955c6bd66c4df772cc0190d6eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f8fd7f160457b3f0a31206159a9c3bd/" rel="bookmark">
			Jenkins获取gitlab代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.gitlab上设置个人访问令牌 登录gitlab--选择项目进入--User Settings--Access Tokens
2.Jenkins，安装gitlab插件 系统管理--插件管理--搜索GitLab Plugin插件安装（在available plugins里搜索安装，我是已经安装过了所以在installed plugins中）
3.Jenkins，配置gitlab链接 Jenkins--系统管理--系统配置--Gitlab编辑
填写连接名称、gitlab地址、gitlab凭证
gitlab凭证添加：
类型选择：Gitlab API token
API token：填写第一步中gitlab中生成的个人令牌字符串
id、描述：填写第一步gitlab填写的token name即可
配置完凭证后，点击test connection测试直到success为止
4.jenkins,配置对应工程中的git信息 5.Jenkins构建 开始测试构建，构建成功，表示配置成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77c244cd7f9e0bef222dec927dc3d521/" rel="bookmark">
			数据库的增删改查(二)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、数据库约束 关系型数据库的一个重要功能
主要作用是保证数据的完整性，也就是数据的正确性（数据本身是正确的，关联关系也是正确的）
人工检查数据的完整性的工作量非常的大，在数据表定义一些约束，那数据库在写入数据时，帮我们完成这个工作
1.1、约束类型 *NOT NULL -指示某列不能存储NULL值
*UNIQUE -保证某列的每行必须由唯一的值
*DEFAULT -规定没有给列赋值时的默认值
*PRIMARY KEY - NOT NULL和UNIQUE的结合。确保某列(或两个列多个列的结合)唯一的标识，有助于更容易更快速的找到表中的一个特定的记录
*FOREING KEY - 保证一个表中的数据匹配到另一个表中的值的参照完整性
*CHECK - 保证每列的值都符合指定的条件。对于MySQL数据库，对CHECK子句进行分析，但是忽略CHECK子句
1.2、NULL 约束 *创建表时可以指定某列不能为空
-- 重新设置学生表结构
DROP TABLE IF EXISTS student;
CREATE TABLE student (
id INT NOT NULL,
sn INT,
name VARCHAR(20),
qq_mail VARCHAR(20)
);
1.3、UNIQUE:唯一约束 保证某列的每一行必须有唯一的值(某一列的值不能重复)
-- 重新设置表结构
DROP TABLE IF EXISTS student;
create table student(
id int NOT NULL,
sn int UNIQUE,
name VARCHAR(20),
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77c244cd7f9e0bef222dec927dc3d521/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdfbf19e992db8bd9f0a89325b56bf3f/" rel="bookmark">
			vue项目netWork地址无法访问问题解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.配置vue.config.js
devServer: { host: "0.0.0.0", public: "172.201.10.26:1888", // 此处是自己电脑IP地址！ port: 1888, https: false, disableHostCheck: true, open: false, // 配置自动启动浏览器 } 2.修改host为“0.0.0.0”，public：改为本机ip地址
（1）本机ip查询方法 win+R 后输入cmd弹出命令行
（2）命令行中输入ipconfig后回车，找到IPv4，复制地址 3.重新运行vue项目，如果出现网络无法访问状态，请确认配置端口号是否相同
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/80/">«</a>
	<span class="pagination__item pagination__item--current">81/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/82/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>