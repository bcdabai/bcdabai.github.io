<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82a61fbf98dbdd5acc73182785c46d5f/" rel="bookmark">
			微信小程序的配置(项目开发配置、小程序收录配置、全局配置、页面配置)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小程序中常用的配置(项目开发配置、小程序收录配置、全局配置、页面配置) 前言:小程序的很多开发需求被规定在了配置文件中。
为什么这样做?
这样做可以更有利于我们的开发效率；并且可以保证开发出来的小程序的某些风格是比较一致的；比如导航栏 – 顶部TabBar，以及页面路由等等。 1. 项目开发配置（对应的文件-&gt;project.config.json） 先附上微信官方给的文档微信小程序项目配置文件文档下面是对应的文件
这个项目配置文件里面的配置项一般不用手敲，它有可视化操作界面,在微信开发者工具中右上角详细中,下面图示：
在可视化中每更改一项在project.config.json中都会有相应的改变 2. 小程序收录配置(对应的文件-&gt;sitemap.json) 传送门：小程序搜索相关的—微信小程序提供的sitemap.json配置文档小程序根目录下的 sitemap.json 文件用于配置小程序及其页面是否允许被微信索引，文件内容为一个 JSON 对象，如果没有 sitemap.json ，则默认为所有页面都允许被索引；sitemap.json 2.1 希望被收录 使用场景:官网、商城、工具等一些面向大众的，希望更多人使用的小程序
配置项 属性类型必填描述rulesObject[]是索引规则列表 rules rules 配置项指定了索引规则，每项规则为一个JSON对象，属性如下所示：
属性类型必填默认值取值取值说明actionstring否“allow”“allow”、“disallow”命中该规则的页面是否能被索引pagestring是“*”、页面的路径* 表示所有页面，不能作为通配符使用paramsstring[]否[ ]当 page 字段指定的页面在被本规则匹配时可能使用的页面参数名称的列表（不含参数值）matchingstring否“inclusive”参考 matching 取值说明当 page 字段指定的页面在被本规则匹配时，此参数说明 params 匹配方式priorityNumber否优先级，值越大则规则越早被匹配，否则默认从上到下匹配 matching 取值说明 值说明exact当小程序页面的参数列表等于 params 时，规则命中inclusive当小程序页面的参数列表包含 params 时，规则命中exclusive当小程序页面的参数列表与 params 交集为空时，规则命中partial当小程序页面的参数列表与 params 交集不为空时，规则命中 下面是配置示例 示例1 { "rules":[{ "action": "allow", "page": "path/to/page", "params": ["a", "b"], "matching": "exact" }, { "action": "disallow", "page": "path/to/page" }] } path/to/page?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82a61fbf98dbdd5acc73182785c46d5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2569eb81931f15117d7024552c8402de/" rel="bookmark">
			封装localStorage，支持切换存储引擎 sessionStorage，支持vue hook方式调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		封装storage存储class // MyStorage.ts export enum StorageType { session = 'session', local = 'local' } export class MyStorage { /** 存储key值前缀 */ private prefix: string /** 单例的实例 */ private static _instance: Map&lt;string, MyStorage&gt; private storage: Storage private engine = { [StorageType.session]: sessionStorage, [StorageType.local]: localStorage } // 单例模式 constructor(prefix = '', type: StorageType = StorageType.local) { this.prefix = prefix this.storage = this.engine[type] if (!this.storage) { throw new Error("engine type error. it must be 'session','local'"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2569eb81931f15117d7024552c8402de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c79b38871bf0580a5f50942f894ad994/" rel="bookmark">
			JWT授权为啥要在 Authorization标头里加个Bearer 呢
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是因为 W3C 的 HTTP 1.0 规范，Authorization 的格式是：
Authorization: &lt;type&gt; &lt;authorization-parameters&gt; w3c规定，请求头Authorization用于验证用户身份。这就是告诉我们，token应该写在请求头Authorization中
type是指认证的方式
所以 Bearer 是授权的类型，常见的授权类型还有：
Basic 用于 http-basic 认证；
Bearer 常见于 OAuth 和 JWT 授权；
Digest MD5 哈希的 http-basic 认证 (已弃用)
AWS4-HMAC-SHA256 AWS 授权
JWT官方推荐格式：JWT官网 https://jwt.io/introduction/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17ac7c4aa82957698f5905640993f775/" rel="bookmark">
			Reids集群设计思路&#43;Reids Cluster&#43;最佳实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		reids集群方案设计思路 + 最佳实践 1.问题背景 2.从redis cluster看redis集群技术 3.Redis Cluster的局限 4.Redis超大规模集群最佳实践 5.小结 6.参考 1.问题背景 当业务场景存在高并发访问、海量数据、高可用性等业务需求时，单机redis已经不满足要求。
在网上一搜，你会看到琳琅满目的解决方案，有开源且成熟的redis cluster，也有大企业自研的redis集群方案，其中涉及的技术点，如主从复制、故障转移、分片算法更是让人眼花缭乱。当你想要开始针对你的业务场景设计redis缓存方案时，难免布置从何下手。
只有合适的方案才是最好的，本文旨在梳理这些技术和方案之间的选用思路，让你在面对不同的业务问题时，能自如地把握redis集群方案，按需选择！
2.从redis cluster看redis集群技术 技术的选型应该是发现某个问题，再寻求相应对策。而Redis Cluster是官方推荐的比较成熟的集群方案，其中集成了分片、主从复制、Sentinel哨兵等技术。
技术解决的问题RedisCluster实现方式分片数据量大，并发访问量大通过哈希槽算法，将redis单节点分片成多节点，可以通过水平扩容来增加集群的存储容量；主从复制节点的可用性将原来分片了的各节点作为主节点，给每个主节点配置多个从节点，保证主节点的可用性Sentinel哨兵基于主从复制，当主节点挂掉后，需要手动切换主从节点额外设置一个哨兵，用于实现主从自动切换，从从节点中选举产生新的主节点（Redis-Sentinel是官方推荐的高可用（HA）解决方案，是独立运行程序，自身也可以集群） 值得注意的是高可用问题，你可能会觉得分片之后，当一个服务挂了可以快速的切换到另外一个服务，就也自动保证了高可用。
但其实Redis Cluster里保证高可用的是主从结构，如果某一master节点宕机，且他无slave的话，为了保障集群的完整性，保证所有的哈希槽都指派给了可用的master，整个集群将不可用。
当然，在这种情况下如果你还是想让集群保持可用的话，可以将 cluster-require-full-coverage 这个参数设置成no，cluster-require-full-coverage表示需要16384个slot都正常被分配的时候Redis Cluster才可以对外提供服务。
3.Redis Cluster的局限 Redis Cluster 的优点是易于使用。分片、主从复制、弹性扩容这些功能都可以做到自动化，通过简单的部署就可以获得一个大容量、高可靠、高可用的 Redis 集群。
所以，Redis Cluster 非常适合构建中小规模 Redis 集群（几个到几十个节点这样规模）。但是 Redis Cluster 不太适合构建超大规模集群，主要原因是，它采用了去中心化的设计。
Redis Cluster的去中心化是指，虽然每个节点只存储全量数据中的一部分，但其每个节点上都保存了所有槽和节点的映射关系表，客户端可以访问任意一个节点，再通过重定向命令，找到数据所在的那个节点。
但当集群增加节点、或者某个主节点宕机、新的主节点被选举出来时，都需要更新集群每一个节点上的映射关系表。
这时候就需要考虑节点之间的通讯成本了，Redis Cluster 采用了一种去中心化的 流言 (Gossip) 协议 来传播集群配置的变化。大概原理就好像一段八卦在一群吃瓜群众中传播，他是自发的无序的，一段时间后群众中的每一个人都知道这个八卦了。对比起中心节点的方案，这样部署和维护都更简单，也能避免中心节点的单点故障。但Gossip协议的缺点就是传播速度慢。并且是集群规模越大，传播得越慢，连带着数据不同步的问题会被明显放大，还有一定的不确定性，如果出现问题很难排查。
4.Redis超大规模集群最佳实践 Redis Cluster 不太适合用于大规模集群，所以很多大厂，都选择自己去搭建 Redis 集群。
集群架构原理案例优缺点基于代理在客户端和 Redis 节点之间增加一层代理服务，作用有（1）在客户端和 Redis 节点之间转发请求和响应（2）监控集群中所有 Redis 节点状态（3）维护集群的主从信息、槽和节点的映射关系等元数据twemproxy 、Codis（1）性能损失：增加了一层代理转发，数据访问的链路更长（2）代理服务的单点故障问题定制客户端把代理服务的寻址功能前移到客户端中去，客户端在发起请求之前，先去查询元数据，就可以知道要访问的是哪个分片和哪个节点，然后直连对应的 Redis 节点访问数据jedis（1）架构比较复杂，客户端不能通用，需要开发定制化的 Redis 客户端；（2）元数据服务仍然是一个单点，但它的数据量和访问量不大，相对较容易实现 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17ac7c4aa82957698f5905640993f775/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71ddba0e8896831a09f68bfd1da173bf/" rel="bookmark">
			01 STM32CubeMX 配置输出PWM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PWM 简介 脉冲宽度调制（PWM，PulseWidthModulation）是利用微处理器的数字输出来对模拟电路进行控制的一种非常有效的技术。广泛应用在从测量、通信到功率控制与变换的许多领域中。
PWM 配置 下面以STM32F103C8T6为例，说明采用STM32CubeMX配置输出PWM的过程。
时钟树配置 选择外部时钟源
倍频至最高的频率
配置PWM输出通道 选择内部时钟，输出PWM到通道1
设置分频系数 &amp; 占空比
频率=定时器时钟/（Prescaler预分频+1）/（CounterPeriod计数值+1）Hz
占空比=Pulse(对比值)/（CounterPeriod计数值）%
生成工程文件
相关函数介绍 /* PWM 使能函数 */ /* 使能timx的通道y */ HAL_TIM_PWM_Start(&amp;htimx,TIM_CHANNEL_y); /* 改变占空比函数 */ /* 修改timx通道y的占空比为z */ __HAL_TIM_SET_COMPARE(&amp;htimx, TIM_CHANNEL_y, z); MDK文件 开启PWM输出通道
修改占空比
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/332300c34b8b1f5be859ba2ec87823f1/" rel="bookmark">
			svn 更新提示Node remains in conflict
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个时候不管svn更新多少次，都无法更新到最新的内容 在该目录下执行：
svn revert --depth=infinity *
其中*是你冲突的目录或文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31c978d2cf0858a2bf75c163cb8ef3cd/" rel="bookmark">
			Segment Anything模型结构解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 论文地址
代码下载
官网
关于Segment Anything的理解 1.人工标注过程 使用公开数据集训练，并且让人工标注团队进行标注预测的mask，该过程总共进行6次，并产生430万个mask
2.半自动标注过程 模型产生的置信度相对较高的mask，不需要人工标注，而置信度相对不高的mask，由人工完成标注。举个例子，模型分割一张图片，总共产生了10个mask，其中有5个分割得很好，这部分就作为自动标注的mask，另外5个效果不好，就进行人工标注。该过程总共进行5次，产生590万个mask
3.全自动过程 让模型完成全自动的标注。通过IoU过滤置信度不高的mask，并且进行去重操作，产生11亿的mask
关于数据集SA-1B 数据集相当大，尝试下载一个tar，大概10个G，压缩包总共可能有10T
SA-1B数据下载
关于网络模型 网络总共有三个部分：image_encoder、prompt_encoder和mask_decoder。个人感觉网络模型还是很大的，下面是细化的网络模型也是代码结构
image_encoder部分： prompt_encoder部分： mask_decoder部分： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2e3771ed52d68dcc1d0a289c13c534c/" rel="bookmark">
			【办公-excel】两个时间相减 （二） - 带毫秒的时间进行相减操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、使用内部函数 1.1 效果展示 =TEXT(((RIGHT(TEXT(B2,"yyyy-mm-dd hh:mm:ss.000"),LEN(TEXT(B2,"yyyy-mm-dd hh:mm:ss.000"))-FIND(".",TEXT(B2,"yyyy-mm-dd hh:mm:ss.000")))-RIGHT(TEXT(A2,"yyyy-mm-dd hh:mm:ss.000"),LEN(TEXT(A2,"yyyy-mm-dd hh:mm:ss.000"))-FIND(".",TEXT(A2,"yyyy-mm-dd hh:mm:ss.000"))))+(LEFT(TEXT(B2,"yyyy-mm-dd hh:mm:ss.000"),FIND(".",TEXT(B2,"yyyy-mm-dd hh:mm:ss.000"))-1)-LEFT(TEXT(A2,"yyyy-mm-dd hh:mm:ss.000"),FIND(".",TEXT(A2,"yyyy-mm-dd hh:mm:ss.000"))-1))*86400000)/86400000,"[h]:m:S.000")
其中：
B2 结束时间 A2 开始时间 单元格式：yyyy-mm-dd hh:mm:ss.000
1.2 步骤分解 步骤开始时间结束时间[B2]2023-09-10 10:22:24.333[C2]2023-09-11 10:22:23.2221.将时间转为字符串[B3]2023-09-10 10:22:24.333[C3]2023-09-11 10:22:23.2222.获取字符串长度[B4]23[C4]233.获取毫秒中·位置序号[B5]20[C5]204.截取日期+时间[B6]2023-09-10 10:22:24[C6]2023-09-11 10:22:235.截取毫秒[B7]333[C7]2226.获取日期时间差(天)[B8]0.9999884267.获取毫秒差[B9]-1118.日期时间差(天)转为日期时间差(毫秒)[B10]863990009.合并日期时间差(毫秒)与毫秒差[B11]8639888910.日期时间差(毫秒)转为日期时间差(天)[B12]0.99998714111.日期时间差(天)格式化[B13]23:59:58.889 1.将时间格式转为字符串 —— =TEXT(B2,"yyyy-mm-dd hh:mm:ss.000")|=TEXT(C2,"yyyy-mm-dd hh:mm:ss.000") 2.获取字符串长度 —— =LEN(B3)|=LEN(C3) 3.获取毫秒分隔符(·)位置序号 —— =FIND(".",B3)|=FIND(".",C3) 4.截取日期时间 —— =LEFT(B3,B5-1)|=LEFT(C3,C5-1) 5.截取毫秒 —— =RIGHT(B3,B4-B5)|=RIGHT(C3,C4-C5) 6.计算日期时间差(天) —— =C6-B6 7.计算毫秒差 —— =C7-B7 8.日期时间差(天)转为日期时间差(毫秒) —— =B8*86400000 9.累计日期时间差(毫秒)与毫秒差 —— =B10+B9 10.日期时间差(毫秒)转为日期时间差(天) —— =B11/86400000 11.日期时间差(天)格式化 —— =TEXT(B12,"[h]:m:S.000") 二、使用自定义函数 2.1 WPS使用js进行函数编程 2.1.1 将文件另存为 启用宏的工作簿(*.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2e3771ed52d68dcc1d0a289c13c534c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14f4352c3282c2a1428f502a7dbaf4b8/" rel="bookmark">
			Vue 项目中如何进行用户登录状态判断？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		登录的状态我们需要分为3中情况（具体如下）
1.是否已经登录
2.登录是否已经过期
3.如何让已登录并未过期的用户获得对应的权限
(1)是否已经登录
1.用户登录成功后，后端返回token,前端则将token保存在本地存储当中
2.设置全局前置守卫beforeEach，判断用户访问的页面是否是需要登录才能访问的页面
3.如果用户访问的页面不需要登录，则直接next()通过(如登录、注册页面)
4.如果用户访问的页面需要进行登录，则判断本地存储当中是否有对应的token存在
5.如果本地存储当中没有对应的token存在的话，则说明用户并没有登录，则直接next('/login)，跳转到登录页面当中去
6.如果本地存储中有对应的token存在，则说明已登录
(2)登录是否过期
判断用户登录是否过期的主要流程为:
1.在axios请求拦截器中，给所有请求的请求头中统一添加token
2.在所有页面的位置发送的任意一个请求，后端都要对token进行判断
3.如果没有过期则正常处理，如果后端判断为过期后则返回401，在axios响应拦截器中，前端接收到返回的状态码为401后，则需要做出相应的处理(跳转登录界面或者是其他操作)
(3)为已登录的用户获得相应的权限
如果用户登录了并且token也没有过期的话，那么我们则会给他分配对应的权限
1.在全局前置守卫beforeEach中，调用后端提供的接口，获取当前用户能够访问的菜单和路由数据，保存在状态机中
2.继续在全局前置守卫beforEach中，通过router.addRoute方法动态生成路由配置
3.同时在菜单组件中，动态渲染该用户（角色）的权限菜单
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b04fb6123de310cb1f806b4064b33cdb/" rel="bookmark">
			shell定时清理日志文件、及crontab说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		服务器日志文件一般是每天一个或多个文件，如果日志文件不清理，时间久了就会将磁盘空间占满，从而影响系统的正常运行。
1、分析磁盘空间占用情况 1.1、df 命令 df 命令以磁盘分区为单位查看文件系统中磁盘空间的使用情况。
语法：df [选项] [文件|目录]
选项：
-h 或 --human-readable ：将信息以人类可读的形式打印。-i 或 --inode ：查看分区inode使用情况。 示例：
1.2、du命令 查看指定目录的磁盘空间使用情况。
du 命令会递归地计算指定目录下所有文件和子目录的磁盘使用量，并将结果显示出来。
语法：du [选项] [文件|目录]
选项：
-a或--all : 列出所有的文件和目录容量大小而不仅仅列出目录容量大小。-s或--summarize : 仅显示总计，只列出最后加总的值。-h或--human-readable : 以K，M，G为单位，提高信息的可读性。-c或--total : 除了列出文件和目录的容量大小外，最后在列出总容量。--max-depth=N : 递归显示(仅仅是显示)时的递归深度小于等于N。--max-depth=0相当于-s参数。-d 数字 ：递归深度设置，效果与--max-depth=N相同。 示例：显示指定目录下每个子目录的磁盘使用量，以人类可读的格式呈现。
2、shell脚本文件 vim clearlog.sh 添加脚本文件
方式一：保留当天删除的日志文件记录
#!/bin/bash # 日志文件目录 log_dir="/logs" # 日志文件保留天数 max_days=7 # 查找所有超过期限的日志文件列表，并保存到clear_log_file.txt find "${log_dir}" -name "*.log" -type f -mtime +"${max_days}" &gt; ${log_dir}/clear_log_file.txt # 遍历需要清除的日志文件列表 cat ${log_dir}/clear_log_file.txt|while read fileName do # 删除日志文件 rm -f $fileName echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b04fb6123de310cb1f806b4064b33cdb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e74796f62a29eb8aee91df841370607/" rel="bookmark">
			C&#43;&#43;sort函数用法笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 函数回调
sort(strs.begin(), strs.end(), [](string&amp; x, string&amp; y){ return x + y &lt; y + x; }); 数组从小到大排序：
sort(nums.begin(),nums.end()); 数组从大到小排序：
sort(nums.begin(),nums.end(),greater&lt;int&gt;()); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d849c2a6ad77ba2461f652e4c7af72f2/" rel="bookmark">
			es6 数据类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​
es6 数据类型 map 数据类型 ===&gt;Map 对象保存键值对。 用途 ：
Object的key无法支持该数据时需要了解对象大小时 map 数据类型任何值(对象或者原始值) 都可以作为一个键。 Object 的键只能是字符串 let myMap = new Map(); let myMap1 = new Map(); var keyString = 'a string'; var keyObj = { a: 1 }; myMap.set(keyString, "和键'a string'关联的值"); myMap1.set(keyObj, '和键 keyObj 关联的值'); console.log(myMap1.get(keyObj)); //和键 keyObj 关联的值 console.log(myMap); //Map {'a string' =&gt; "和键'a string'关联的值"} console.log(myMap1); //Map {'a string' =&gt; "和键'a string'关联的值"} console.log(myMap1.size); //1 键值对个数可以从 size 属性获取， Object 的键值对个数只能手动计算。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d849c2a6ad77ba2461f652e4c7af72f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ad8a3ac514f76f905c4ef0b7beca5b0/" rel="bookmark">
			基于FPGA的I2C读写EEPROM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、I2C协议1.1 I2C协议简介1.2 物理层1.3 协议层 二、EEPROM2.1 型号及硬件规格2.2 各种读写时序 三、状态机设计四、项目源码：五、实现效果参考资料 前言 本次项目所用开发板FPGA芯片型号为：EP4CE6F17C8 EEPROM芯片型号为：24LC04B UART串口设置为：波特率115200
无校验位
本次项目仅实现了EEPROM的单字节读写。若要实现连续读写可以在下文的EEPROM控制模块设置计数器控制读写字数。
一、I2C协议 1.1 I2C协议简介 I2C总线是Philips公司在八十年代初推出的一种同步、串行、半双工 的总线，主要用于近距离、低速的芯片之间的通信；I2C总线有两根双向的信号线，一根数据线SDA用于收发数据，一根时钟线SCL用于通信双方时钟的同步；I2C总线硬件结构简单，简化了PCB布线，降低了系统成本，提高了系统可靠性，因此在各个领域得到了广泛应用。
I2C是一种多主机多从机总线，通过呼叫应答的方式实现主机与从机间的通信。每一个I2C设备都有一个唯一的7位地址，也就是说同一根线上最多挂载127个I2C从机设备（主机自己占一个地址）。主机有权发起和结束一次通信，从机只能被动呼叫；当总线上有多个主机同时启用总线时，I2C也具备冲突检测和仲裁的功能来防止错误产生。
1.2 物理层 I2C支持多主机多从机
I2C有两条线，一条SCL串行时钟线，用于数据收发同步；一条SDA串行数据线，用来表示数据
每个连接到IIC总线的设备都有一个唯一的地址（ID），主机可以通过地址与不同的从机建立连接
I2C 总线通过上拉电阻接到电源。当 IIC 设备空闲时，设备会输出高阻态，当所有设备都空闲，都输出高阻态时，由上拉电阻把 IIC总线拉成高电平。
I2C总线有仲裁机制：当多个主机同时发起传输时，触发仲裁机制，最终只给一个主机授权。
具有三种传输模式，每种传输模式对应的传输速率不同，具体速率如下：
有些I2C变种还包含了快速+（1Mbit/s）和超高速（5Mbit/s 单向传输）模式。
1.3 协议层 空闲状态：I2C协议规定，在空闲状态下SDA数据线和SCL时钟线均处于高电平。开始位：当SCL处于高电平时，SDA数据线被拉低，则认为检测到起始位，一次数据传输开始。数据传输：同时，协议规定在SCL高电平时期SDA数据线必须保持稳定，在SCL低电平时，SDA才允许发生改变。主机进行数据读写时，I2C协议规定，数据传输时先发送寻址字节，即7位从机地址+0/1。其中0表示主机写，1表示主机读。寻址字节发送完成后才是数据字节应答位：I2C协议规定，主机每次向从机传输1字节数据后，需要接收一次从机的应答信号。0为接收成功；1为接受失败，没有响应。停止位：当SCL为高电平时，数据线SDA拉高，则认为检测到停止位，一次数据传输结束。
二、EEPROM 2.1 型号及硬件规格 EEPROM的全称是“电可擦除可编程只读存储器”，即Electrically Erasable Programmable Read-Only Memory。本次项目中使用的EEPROM型号为24LC04B。
由手册可以看出，24LC04B支持的最大时钟频率为400KHz。
由手册得出该型号EEPROM共有两个Block 每个Block的存储容量为256×8bit。
由手册得出，设备地址为1010xxB0共七位（xx为dont care B0为块选择），1为读操作，0为写操作。
2.2 各种读写时序 单字节写
先写开始位然后写控制字节，从机接收到发应答信号然后写数据地址，从机接收到发应答信号，如果数据地址是2位的话，就继续写数据地址，从机接收到发应答信号然后写数据，从机接收到发应答信号最后写结束位 页写
页节写先开始位然后写控制字节，从机接收到应答信号然后写数据地址，从机接收到应答信号，如果数据地址是2位的话，就继续写数据地址，从机接收到应答信号然后写数据，从机接收到应答信号然后继续写数据，直到写完全部的数据最后是结束位 当前地址读
当前地址读先开始位然后写控制字节，从机接收到应答信号，然后读数据，无应答信号最后结束位 随机地址读和顺序读
随机读先写开始位然后写控制字节，从机接收到应答信号然后dummuy write 虚写，写数据地址，从机接收到应答信号然后开始位然后读控制字节，从机接收到应答信号然后读数据最后结束位 三、状态机设计 I2C接口模块：
EEPROM控制模块：
四、项目源码： EEPROM驱动模块：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ad8a3ac514f76f905c4ef0b7beca5b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdd4de3e717f88d431f19e804c535ee3/" rel="bookmark">
			井盖异动传感器-城市窨井盖监测设备-旭华智能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在传统的城市管理中，井盖的监控一直是一个难题，而井盖异动传感器的出现为这一问题提供了有效的解决方案。它具有体积小、重量轻、安装方便等特点，可以灵活地应用于各种类型的井盖，实现对城市基础设施的全方位监控。
旭华智能井盖异动传感器采用IP68防护，防潮防水防腐蚀防撞击；数据传输采用NB-IoT网络通讯，穿透力较好，传输距离长； 并且配有唯一的身份标识，把井盖整个生命周期的事务统一归档、统一管理 。
井盖异动传感器的报警系统具有及时、高效的特点。一旦井盖发生移动，报警系统会立即发出警报，提醒相关人员进行处理，从而将安全隐患扼杀在萌芽状态。此外，井盖异动传感器还可以与其他安防系统进行联动，如视频监控系统、智能巡检系统等，实现全方位的治安防控。
相较于其他同类产品，井盖异动传感器具有灵敏度高、稳定性好、使用寿命长等优势。它可以适应各种恶劣环境，长期稳定运行，减少了维护和更换的次数，降低了运维成本。此外，井盖异动传感器的操作简单易行，可以轻松上手，为使用单位节省了大量人力和物力资源。
未来，随着技术的不断进步和应用场景的不断扩展，井盖异动传感器将会在城市建设中发挥更加重要的作用，为构建更美好的城市生活保驾护航。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c88fd93db9a980c9311d6733d86ce2f/" rel="bookmark">
			无需升级内核解决Y9000p等新机型安装Ubuntu18.04无WiFi问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 其实安装Ubuntu20.04就可以解决WiFi问题，但是无奈Ubuntu18.04有很多学习资料。
本人Win11+Ubuntu18.04双系统，安装完后无WiFi、无声音（声音伪输出）、无法调节屏幕亮度、触摸板失灵，多方搜寻发现是内核版本太低导致的，但是升级内核太麻烦，据说会有很多新问题出现，本人比较懒，就不想多折腾了。于是打算逐个解决，先来针对WiFi问题。
在疯狂谷歌之后，发现有人通过安装无线网卡驱动解决了问题，但大多数是安装Intel Wi-Fi 6 AX210无线网卡驱动，本机网卡型号是Intel Wi-Fi 6 AX211，去官网一查：Linux* Support for Intel® Wireless Adapters 最新驱动才到AX210，硬着头皮按照步骤下载下来重启之后居然成功了，出现了WiFi图标，可喜可贺。遂记录下来以备不时之需。
二、快速解决 参考askUbuntu上的一个问题解决方案，链接：Running Intel Wi-Fi 6 AX210 adapter under Ubuntu 18.04
1.安装一些必要的包（虽然不知道是做什么用的）
sudo apt install flex bison 2.克隆向后移植intel驱动库
git clone https://github.com/intel/backport-iwlwifi.git 克隆的速度让人绝望，即使我开了代理速度也才20Kb/s，于是果断去github上直接下载源码。链接如下：backport-iwlwifi 下载之后解压到/home/username下（username就是你的用户名），解压到指定目录命令如下：
cd /home/username/Downloads sudo unzip backport-iwlwifi-master.zip -d /home/username/ 如果你是git clone，不需要执行上面两行命令。
3.编译安装
cd backport-iwlwifi #如果是github直接下载的，看准文件名，改为backport-iwlwifi-master cd iwlwifi-stack-dev sudo make defconfig-iwlwifi-public sudo make sudo make install 4.下载网卡驱动
git clone git://git.kernel.org/pub/scm/linux/kernel/git/firmware/linux-firmware.git 老样子，克隆速度还是慢的不行，于是github一下：linux-firmware
如果选择github下载，下载后直接解压到当前文件夹就好，然后再将所有的 iwlwifi-开头的文件移动到 /lib/firmware,指令如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c88fd93db9a980c9311d6733d86ce2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75cbdbb755d8a72622034926673d8bcd/" rel="bookmark">
			Idea通过 Alibaba Cloud Tookit 自动部署到云服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我们进行服务器部署调试时，每次都需要上传，停止再启动，操作繁琐。
其实我们可以在idea中就进行快速部署，启动项目。
安装插件
在idea软件商店中搜索 Alibaba Cloud Tookit 插件，并进行安装。
在项目中进行配置
找到 Edit Configurations 打开
选择 + ，选择 Deploy to Host
添加后，可以看到以下界面
首先我们给配置起一个名字
配置服务器ip,点击 + ， 选择 Add Host 。
配置ssh端口号，选择验证方式 支持密码模式和私钥模式
配置好后，可进行测试连接，成功连接， 点击添加就可以了。
然后选择 Upload File, 选择target 下面的jar包 配置好ip后，配置上传服务器路径， 我的在/opt/sphere下， 如图
我们新建一段shell脚本，如下所示，放在上传目录中 文件名 restart.sh
ps：chmod命令更改文件权限
#!/bin/bash # 停止正在运行的jar包 需改动 pkill -f [你的jar包名称].jar # 等待一段时间以确保进程完全停止（根据需要调整等待时间） sleep 5 # 启动JAR包 需改动 nohup java -jar [你的jar包名称].jar &amp; echo "应用已重新启动" 将文件新建到上传目录中
然后填写上传后执行命令，选择 Select Command ，选择 Add Command
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75cbdbb755d8a72622034926673d8bcd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22182084886ee9bb45863de3adb61831/" rel="bookmark">
			2023CCF中国开源大会丨开源供应链安全技术分论坛
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2023 CCF 中国开源大会即将于10月21日-22日于湖南长沙举行，将举办近20场领域平行分论坛。由王千祥作为主席的开源供应链安全技术分论坛邀请您共同分享经验和见解，共同探索开源领域的无限未来！
开源供应链安全技术分论坛
一、分论坛简介
开源漏洞给企业甚至国家的安全都带来了严峻的挑战。研究表明：应用软件 80-90% 的代码来自开源组件，平均每个应用使用的开源软件数量达 100多个，平均每个软件应用存在 50多个开源软件漏洞。开源供应链安全的保障近年来受到了业界的广泛关注。本论坛邀请了来自高校、企业、研究所的多位资深专家针对开源供应链安全技术相关的问题、挑战及未来方向等内容开展深入讨论，希望给听众带来一些新的思路。
二、分论坛主席
王千祥
华为云智能化软件研发首席专家，PaaS技术创新LAB主任，华为可信领域科学家，中国计算机学会软件工程专委副主任，主导华为公司的智能化软件研发，结合AI技术与软件分析技术，赋能公司的系列软件研发工具。
三、分论坛演讲
软件供应链安全评估实践及行业标准框架
程华
军事科学院战略评估中心国防科技安全评估团队负责人、
研究员
一、嘉宾介绍
程华，军事科学院战略评估中心国防科技安全评估团队负责人，研究员，博士生导师，中国计算机学会理事，CCF开源技术委员会常务委员，信创联盟“产业成熟度工作组”组长。长期从事国产计算机系统一线研制和评测，研究成果转化为自主可控度评估、国产操作系统、服务器、桌面计算机、云计算评测等11项国军标/国标，主持研制“重睛鸟”代码溯源和安全审查平台，获党政军广泛应用。获省部级科技进步一等奖1项（3）、二等奖3项（1，1，1），“国家标准创新贡献奖”一等奖1项（1），获卓青基金资助。
二、演讲内容
本报告主要分为三部分：（1）介绍国产软件的开源依赖现状、挑战和全球主要国家的法律和技术对策；（2）结合工作实践，介绍CCF GitLink和“重睛鸟”在开源治理方面的探索和实践；（3）介绍软件演进过程量化分析方法，总结开源软件发展规律，为当前我国发展开源软件提供参考；（4）介绍正在制定的软件供应链安全评估分级标准框架。
AI开源联合体的思考与实践
彭鑫
复旦大学计算机科学技术学院副院长、软件学院副院长、教授、博士生导师
一、嘉宾介绍
彭鑫，复旦大学计算机科学技术学院副院长、软件学院副院长、教授、博士生导师。中国计算机学会（CCF）杰出会员、软件工程专委会副主任、开源发展委员会常务委员，上海市计算机学会青工委主任，《Journal of Software: Evolution and Process》联合主编（Co-Editor），《ACM Transactions on Software Engineering and Methodology》、《Empirical Software Engineering》、《Automated Software Engineering》、《软件学报》等期刊编委。2016年获得NASAC青年软件创新奖。主要研究方向包括软件智能化开发、云原生与智能化运维、泛在计算软件系统、智能网联汽车等。研究工作获得IEEE Transactions on Software Engineering年度最佳论文奖（2018）、ICSM 2011最佳论文奖、ACM SIGSOFT杰出论文奖（ASE 2018/2021及ICPC 2022）、IEEE TCSE杰出论文奖（ICSME 2018/2019/2020、SANER 2023）。担任ICGSE 2014及ICSME 2017组委会主席，Internetware 2017及ICSR 2019程序委员会主席，2022年与2023年CCF中国软件大会（ChinaSoft 2022）组织委员会主席与程序委员会共同主席，以及ICSE、FSE、ASE、ISSTA、ICSME、SANER等会议程序委员会委员。带领复旦大学CodeWisdom研究团队开展软件智能化开发与运维以及软件供应链治理平台的研究，研究成果在多家大型企业进行了实践应用。
二、演讲内容
开源软件已经上升为国家级战略，对于信创和软件产业、国民经济、国防与国家安全等发挥着重要的支撑作用。然而，由于开源软件生态以及开源软件供应链日益复杂，开源软件也给软件产品带来了严峻的安全、法律和维护风险。为此，复旦大学CodeWisdom团队研制并发布了开源软件供应链风险分析与治理平台“伏羲”。“伏羲”在高质量开源软件供应链知识（包括漏洞知识、许可证知识等）汇聚的基础上，利用一系列高精度程序分析技术（包括代码差异分析、调用图分析等）实现多种开源软件供应链风险（安全风险、法律风险等）的分析与治理服务。本次报告将在介绍“伏羲”平台相关分析技术的基础上，对未来的发展趋势进行展望。
CCF精准开源漏洞库COSV服务建设进展与规划
梁广泰
华为云软件分析Lab负责人
软件分析领域技术专家
一、嘉宾介绍
梁广泰，14年初获得北京大学计算系博士学位，之后入职IBM中国研究院担任研究员职位。16年5月加入华为工作至今，带领团队先后围绕代码缺陷检测与修复、开源成分分析与治理、代码智能同步/重构/移植等方向成功孵化多项智能化开发服务并规模化落地。至今已发表技术专利50+及学术论文30+（含ICSE/FSE/ASE/OOPSLA等），曾获FSE最佳论文奖，先后担任一系列软工Top国际会议PC Member/Chair等角色（含ICSE/OOPSLA/ISSRE等）。
二、演讲内容
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22182084886ee9bb45863de3adb61831/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b824b5c5b8dc981ed30d69876ec9c3dd/" rel="bookmark">
			ARCGIS PRO SDK VB2022 创建环面要素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Private Async Sub Button_Click_3(sender As Object, e As Windows.RoutedEventArgs)
Dim ttp As Integer
MapView = MapView.Active
'获取地图视图的关联地图
Map = MapView.Map
ttp = 0
'获取的图层
For it = 0 To Map.Layers.Count - 1
If Map.Layers(it).Name = "土地性质图斑" Then
Layer = CType(Map.Layers(it), FeatureLayer)
ttp = 1
End If
Next
If ttp = 0 Then
MsgBox("土地性质图斑。")
Exit Sub
End If
Await QueuedTask.Run(Sub()
pfeatureClass = Layer.GetFeatureClass
Dim FeatureClassDefinition As FeatureClassDefinition = pfeatureClass.GetDefinition()
Dim rowBuffer As RowBuffer = pfeatureClass.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b824b5c5b8dc981ed30d69876ec9c3dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65185543951910248226f00892bc7c6a/" rel="bookmark">
			华为JAVA校招面试问题收集整理（含研发&#43;OD）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录 八股算法题 八股 接口和抽象类的区别；TCP\UDP区别；查询语句，where和having有什么不同连表查询时“where”+“=”与“join”的区别ssl过程；三次握手四次挥手；多进程与多线程；xss攻击如何防止；SQL注入；CSRF：跨站请求伪造Linux查看端口命令 查看所有正在使用中的端口： netstat -anp查看某个特定端口是否被占用： netstat -anp | grep :端口号查看某个特定端口的占用情况： lsof -i :端口号 Linux如何查看当前目录最后修改的文件
——find命令，比如单位mmin（分钟），+号表示多少分钟前，-号表示多少分钟内，如：
find /home/ -type f -mmin -1 一分钟内
find /home/ -type f -mmin +1 一分钟前值传递会不会改变原来的变量（深、浅、引用拷贝）；socket的具体步骤；说一下MVCC说一下AQS，有哪些类JVM：类加载机制、双亲委派、栈溢出异常和OOM产生的情况；对GPT模型有没有了解；锁的原理springboot自动装配过程 算法题 算法基础：常见的排序算法、bfs、dfs遍历；算法题-并查集； 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a109080aa2f0b1cf837bd29641b983e/" rel="bookmark">
			SpringCloud技术体系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 Springboot和springcloud的关系 架构演变简述微服务架构简介 SpringCloud技术体系 引用 Springboot和springcloud的关系 微服务是一种架构的理念，提出了微服务的设计原则，从理论为具体的技术落地提供了指导思想。Spring Boot是一套快速配置脚手架，可以基于Spring Boot快速开发单个微服务；
Spring Cloud是一个基于Spring Boot实现的服务治理工具包；
Spring Boot专注于快速、方便集成的单个微服务个体，Spring Cloud关注全局的服务治理框架。
架构演变简述 单体架构：未做任何拆分的Java Web程序分布式架构:按照业务垂直划分，每个业务都是单体架构，通过API互相调用。SOA架构：SOA是一种面向服务的架构。其应用程序的不同组件通过网络上的通信协议向其它组件提供服务或消费服务，所以也是分布式架构的一种。微服务架构在某种程度上是SOA架构的进一步的发展。 微服务架构简介 通常而言，微服务架构是一种架构模式或者说是一种架构风格，它提倡将单一应用程序划分成一组小的服务，每个服务运行独立的自己的进程中，服务之间互相协调、互相配合，为用户提供最终价值。
服务之间采用轻量级的通信机制互相沟通（通常是基于 HTTP 的 RESTful API ) 。每个服务都围绕着具体业务进行构建，并且能够被独立地部署到生产环境、类生产环境等。
另外，应尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建，可以有一个非常轻量级的集中式管理来协调这些服务。可以使用不同的语言来编写服务，也可以使用不同的数据存储。
SpringCloud技术体系 Eureka注册中心；Ribbon负载均衡；Hystrix：Hystix是Netflix开源的一个延迟和容错库，用线程隔离、服务降级方法解决雪崩问题。Circuit Breaker服务熔断：服务调用方 可以自己进行判断哪些服务反应慢或存在大量超时，可以针对这些服务进行主动熔断，防止整个系统被拖垮。Feign：Feign提供了HTTP请求的模板，通过编写简单的接口和插入注解，就可以定义好HTTP请求的参数、格式、地址等信息。而Feign则会完全代理HTTP请求，我们只需要像调用方法一样调用它就可以完成服务请求及相关处理。SpringCloud对Feign进行了封装，使其支持SpringMVC标准注解和HttpMessageConverters。Feign可以与Eureka和Ribbon组合使用以支持负载均衡。Spring Cloud Gateway组件：核心是一系列的过滤器，通过这些过滤器可以将客户端发送的请求转发（路由）到对应的微服务；Spring Cloud Bus服务总线：实现配置的自动更新（基于RabbitMQ实现的）。 引用 部分内容引用自公众号JAVA知音
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf41b182c42f5a46e8e0bb0276eb1954/" rel="bookmark">
			CefSharp入门-winform
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说CefSharp应该先说一下cef，官方是这样说的：
Chromium Embedded Framework (CEF)是个基于Google Chromium项目的开源Web browser控件，支持Windows, Linux, Mac平台。除了提供C/C++接口外，也有其他语言的移植版。因为基于Chromium，所以CEF支持Webkit &amp; Chrome中实现的HTML5的特性，并且在性能上面，也比较接近Chrome。CEF还提供的如下特性：自定义插件、自定义协议、自定义JavaScript对象和扩展；可控制的resource loading, navigation, context menus等等。
简言之，Cef支持HTML，CSS，JavaScript，可以在CS中像web网站那样操作。与winform中自带的webBrowser一样，只是CefSharp是独立的，基于Chrome浏览器，而webBrowser基于IE浏览器。
而CefSharp后面的sharp就是c#语言的简称，应用于c#语言框架中使用的cef，所以还有适用于Java的，go的，Python的cef版本。
现在简单的体验一下c#中的cef，即CefSharp效果。
1.首先建立一个winform程序
项目选择.NET Framework4.8框架
在nuget中，下载cefsharp，选择版本是83.4.20。这里使用高版本的话，会出现黑屏的问题。只有此版本目前不会，而且小于此版本的也不会出现黑屏（经过大量的测试而知）
2.然后运行的话会报错，增加以下几个地方
在项目文件中增加如下代码
&lt;CefSharpAnyCpuSupport&gt;true&lt;/CefSharpAnyCpuSupport&gt; 在配置文件中增加 &lt;runtime&gt; &lt;assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1"&gt; &lt;probing privatePath="x86"/&gt; &lt;/assemblyBinding&gt; &lt;/runtime&gt; 然后重新启动即可。
3. 主界面中，增加以下代码
using CefSharp; using CefSharp.WinForms; using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Windows.Forms; namespace cef1 { public partial class Form1 : Form { public ChromiumWebBrowser chromeBrowser; public Form1() { InitializeComponent(); } private void Form1_Load(object sender, EventArgs e) { InitializeChromium();//初始化 } public void InitializeChromium() { CefSettings settings = new CefSettings(); settings.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf41b182c42f5a46e8e0bb0276eb1954/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb532cc14f5fbd62feb4865c0f5fc7c6/" rel="bookmark">
			VUE3中，使用.env.development和.env.production
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在实际项目开发过程中，可能开发环境和生产（测试）环境不一样，经常需要修改配置常量，才能满足对应的环境，才能使软件运行起来。在vue3中可以使用2个文件进行区分。
.env.development：开发环境
.env.production：生产（测试）环境
1.首先使用HBuilder X建立一个VUE3项目，并且能跑起来
2.分别建立2个文件，必须以VITE_开头，否则无法识别，如图所示
3.然后在使用的地方加上如下命令
import.meta.env.VITE_TEST 4.重新启动服务器，一定要重新启动服务器，否则无效
打开浏览器，我们可以看到输出了开发环境。
5.选择build，生成生产模式，程序就在dist中
6.此时，我这里使用nginx进行发布，当然你也可以使用别的发布网址，比如IIS等等。
nginx的配置，之前文档已经介绍了，这里不再说明。
Windows中使用nginx部署网站_故里2130的博客-CSDN博客_nginx部署网站
部署完成后，直接打开，我这里是808端口。
打开浏览器，我们可以看到输出了生产环境。
拓展：
打包后，自定义IP地址。
1.打包前，在项目的根目录中，创建config.js
const CONF={ baseUrl1:'http://127.0.0.1:8888' } 2.在index.html中调用
3. 然后在axios中调用
4.打包后，之前的config.js就没有了，复制所有的打包文件。
5.创建config.js，把之前写的再写一次
6.把index.html中的路径修改一下
来源：VUE3中，使用.env.development和.env.production-CSDN博客 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9468e1794837370dde0528fb206b505c/" rel="bookmark">
			.net6Api后台&#43;VUE3前端实现上传和下载文件全过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先本文参考的是，感谢博主：
net6WebApi上传下载文件_cduoa的博客-CSDN博客_webapi下载文件
在博主的基础上，增加了新的功能，代码中有注明，并且使用VUE3前端实现。
后端部分：
1.首先建立IFileService文件
namespace net6ApiUploadAndDownload { public interface IFileService { void UploadFile(List&lt;IFormFile&gt; files, string subDirectory); (string fileType, byte[] archiveData, string archiveName) DownloadFiles(string subDirectory); //返回3个值 string SizeConverter(long bytes); } } 2.建立FileService文件
using System.IO.Compression; namespace net6ApiUploadAndDownload; public class FileService : IFileService { #region Property private readonly IWebHostEnvironment webHostEnvironment; #endregion #region Constructor public FileService(IWebHostEnvironment webHostEnvironment) { this.webHostEnvironment = webHostEnvironment; } #endregion #region Upload File public void UploadFile(List&lt;IFormFile&gt; files, string subDirectory) { subDirectory = subDirectory ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9468e1794837370dde0528fb206b505c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21ba6fb247ee6a768b61c7e5284471d9/" rel="bookmark">
			Linux部署zerotier局域网工具,并搭建moon；客户端配置moon
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在线安装zerotier curl -s https://install.zerotier.com | sudo bash
查看安装zerotier版本 sudo zerotier-cli status
加入一个netWork sudo zerotier-cli join ################（networkid）
查看加入的网络的信息，比如network sudo zerotier-cli listnetworks
退出加入的network网段 sudo zerotier-cli leave ################（networkid）
启动、停止服务(mac下，linux尝试发现没有launchctl command) #Stop and start the service with launchctl
停止
sudo launchctl unload /Library/LaunchDaemons/com.zerotier.one.plist 启动
sudo launchctl load /Library/LaunchDaemons/com.zerotier.one.plist 卸载服务（未尝试） #Cleanly uninstall ZeroTier One, preserving only your secret identity
sudo "/Library/Application Support/ZeroTier/One/uninstall.sh" 搭建moon 问题是ZeroTier One本身的服务器都在国外访问速度很慢。可以通过搭建国内Moon服务加速解决连接慢的问题。
在自己的云服务器上搭建moon，我的云服务器是ubuntu系统
zerotier官方提供了比较方便的安装方式安装 moon
curl -s https://install.zerotier.com/ | sudo bash 生成moon配置文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21ba6fb247ee6a768b61c7e5284471d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eabc97c9ab3a044f905fd480d246ac68/" rel="bookmark">
			一种基于QT应用程序封装JsonRpc2.0协议请求对象的便捷方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方“嵌入式应用研究院”，选择“置顶/星标公众号”
干货福利，第一时间送达！
来源 | 嵌入式应用研究院
整理&amp;排版 | 嵌入式应用研究院
之前一直用的是cJSON库来封装和解析，写久了感觉实在太丑，又难维护，于是还是研究下QT原生的QJson是否有更优雅的方法来封装一些Json对象，果不其然，通过阅读QT开发文档发现，QT封装的Json非常强大，其中Json对象可以有很多种形式，我们看到qjsonobject.h中：
template &lt;class Key, class T&gt; class QMap; typedef QMap&lt;QString, QVariant&gt; QVariantMap; template &lt;class Key, class T&gt; class QHash; typedef QHash&lt;QString, QVariant&gt; QVariantHash; 基于模板创建了QMap和QHash两种容器类型，我们先来介绍QMap和QVariantMap的应用，在介绍QVariantMap的应用之前，先来了解QMap以及QVariant。
1、QMap QMap是Qt库中的一个关联容器，它存储键值对，其中每个键都是唯一的。这使得你可以通过键值来快速查找或访问存储在QMap中的值。
以下是一些QMap的基本操作：
插入：使用insert()函数将一个键值对插入到QMap中。
获取值：使用value()函数通过键来获取值。
查找：使用find()函数查找具有给定键的键值对。
删除：使用remove()函数删除具有给定键的键值对。
遍历：使用iterator（如QMapIterator或constIterator）遍历QMap中的所有键值对。
下面是一个简单的QMap使用例子：
#include &lt;QCoreApplication&gt; #include &lt;QDebug&gt; #include &lt;QMap&gt; int main(int argc, char *argv[]) { QMap&lt;QString, int&gt; map; map.insert("One", 1); map.insert("Two", 2); map.insert("Three", 3); // 使用value()函数获取值 int one = map.value("One"); qDebug() &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eabc97c9ab3a044f905fd480d246ac68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b121d84d3f1047ecccac448051c6433/" rel="bookmark">
			搜维尔科技：提高生产力的最佳方法是通过scalefit 的独立算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		医保的年度健康报告表明，由于体力劳动而引起的肌肉骨骼疾病是导致缺工的主要原因。严重负担，较重的复发率，或较硬的行为，将导致长期病痛，不可修复磨损。其结果是业绩减退，违约日，疾病和人才流失，那些由英国人和民怨所引发的民怨影响。
运用生物力学使身体健康
我们支持公司和研究机构分析工作岗位从而实现安全健康减轻负担我们的biomechanischesMesssystem工业运动员-在市场上的xsens -基本运动捕捉相关企业也做出相关的合理安排:
1.快速准确危险程度评估
2.合理的工作安排和产品
3.恢复运营和疾病成本 4.通过具有竞争力的员工
对于其他研究机构，贝卡的研究者以及顾问来说，我们的科学方法就为探索内容和经济带来了新的可能性:
1.做简易评估和自动报告
2.来自高效率和创新的测量系统的竞争优势
3.服务范围扩大
我们的方法方法方法可以作为一个劳动保护和贝卡的综合方法。为学校和研究所量身定做的！
工业运动员:“生理和工程学”
斯卡拉菲的科学家们通过提高生产力的移动生产力实验室——来提高生产力的2020年生产力奖得主——研发出了劳动科学的一种最具创新性的方法。生物机械测量系统能直接在工作现场测量身体承受的压力，并实时测量其对肌肉疾病的影响。一个回收箱会在事件发生前简要说明犯人的真实情况，在长期工作期间将会通过按按钮提出一个有效力的效力评估。斑点图、外形骨骼和计算机模型的整合和自动数据出口等实际功能起到了测量系统的用户效益。
因此，工业竞技提供了适用劳动力的最佳支持职业安全与健康与健康措施:
1. 肌肉骨骼
2.相关工作和产品安排
3.提高人们对工作和休闲健康行为的认识
在脆弱程度评估、行为和适度预防、培训、卫生问题或预防方案中使用易于使用的测量系统。
多样的应用产品提供客户服务
生产力分析和咨询，包括行动发展，嵌入了实时分析和自动新闻报告，用于本摩卡系统的软件包包括培训和支持。
今天正在为员工的健康投资的公司明天将会从吸引力的增加、性能的提高和可持续的竞争力中获益。让他见识一下我们使用的最先进的科技和科学专长！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08da8229cd8394e974cae7e6f1c1f458/" rel="bookmark">
			MySql学习笔记：MySql性能优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本文是自己的学习笔记，主要参考以下资料
- 大话设计模式，程杰著，清华大学出版社出版
- 马士兵教育
1、MySql调优金字塔2、MySql调优2.1、查询性能2.1.1、慢查询2.1.1.1、总结 1、MySql调优金字塔 Mysql 调优时设计三个层面，分别是架构调优，MySql调优，硬件和OS调优。这三者的成本和效果如上所示，越在底层的越是优先考虑。
架构调优是指系统设计时需要考虑业务的实际情况，比如数据库是否承担了不属于他的工作，能否将这些工作移到数据仓库或者缓存中去；并发量是否够大，要不要读写分离；金融类的应用还要考虑数据安全性问题，是否要增加新的设计保证数据不会丢失等等。架构设计得不合适，那么在其他方面调优达到的效果也是有限。
MySql调优是指，业务表设计是否合理，索引设计是否合理等技术上的考量。
硬件和OS调优则是查看硬件和OS了，需要对这些有深刻的认识。单单磁盘来说，就需要考虑使用什么样的磁盘阵列（RAID）级别、是否可以分散磁盘IO等。
这篇文章主要讲解如何MySql调优。
2、MySql调优 2.1、查询性能 想要优化，首先考虑的是对哪些东西调优，如何查询性能。
2.1.1、慢查询 所谓的慢查询是指在默认的情况下，MySql将哪些相应时间超过10s的查询称为慢查询。当然我们可以自己更改时间。
慢查询默认关闭，可以通过下面语句开启和查看。
-- 1开启，0关闭 set GLOBAL slow_query_log=1; show VARIABLES like '%slow_query_log%'; 关于慢查询的时间界限，默认10秒。
show VARIABLES like '%long_query_time%'; 指定慢查询日志的文件地址
show VARIABLES like '%slow_query_log_file%' 2.1.1.1、总结 set GLOBAL slow_query_log=1; show VARIABLES like '%slow_query_log%'; show VARIABLES like '%long_query_time%'; show VARIABLES like '%slow_query_log_file%' 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7931e3c02b8acbd45586e0b630224e7/" rel="bookmark">
			无人机自主飞行航迹规划问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要
本文分别研究了基于二维平面和三维空间的最优航迹规划问题。
对于第一问，我们在忽略地形和无人机操作性能等因素影响的基础上，将影响无人机飞行的“敌方雷达威胁”和“飞行燃油代价”两个因素进行了量化处理，建立了雷达威胁模型和燃油代价模型，并在这两个模型的基础上建立了基于二维平面的最优航迹规划模型。在求解该模型时，我们依据图论中的相关理论，将二维平面划分成了若干网格，然后使用Dijkstra算法来求最优航迹。
对于第二问，我们在第一问的模型的基础上，同时考虑了地形因素和无人机的操作性能（主要是拐弯），增加了“无人机飞行高度代价”和“无人机操作性能”两个指标，并对其进行了量化处理。同时，我们对雷达威胁模型进行了适当的简化，建立了一个较复杂的、基于三维空间的最优航迹规划模型。在求解该模型时，我们将三维空间划分为若干个小方块，在“无人机操作性能”作为补充约束条件的基础上，采用蚁群算法，得到了最优航迹。
在建立以上两个模型的基础上，我们对每个模型的可行性分别进行了分析。由于规划的约束条件众多而且模糊性大、研究的各因素之间的相互联系及不同种类无人机的控制方式和任务情况各异，因而模型存在着一定的缺陷。我们用MATLAB对建立的两个模型进行了仿真，分别得到了基于二维平面的最优航迹和基于三维空间最优航迹。此外，我们分析了所建模型的优缺点，并对模型的完善进行了进一步的探索。
关键词：最优航迹 Dijkstra算法 蚁群算法 MATLAB仿真
目 录
1. 问题的重述------------------------------------------------------------------------------------2
2. 问题的分析------------------------------------------------------------------------------------2
3. 模型假设----------------------------------------------------------------------------------------3
4. 符号说明----------------------------------------------------------------------------------------3
5. 模型的建立-------------------------------------------------------------------------------------3
5.1问题一模型的分析、建立与求解-----------------------------------------------------3
5.2问题二模型的分析、建立与求解-----------------------------------------------------6
6. 模型的可行性分析与仿真-------------------------------------------------------------------9
6.1模型的可行性分析-----------------------------------------------------------------------9
6.2模型的仿真-------------------------------------------------------------------------------10
7. 模型的评价、改进及推广-------------------------------------------------------------------12
8. 参考文献----------------------------------------------------------------------------------------14
9. 附录----------------------------------------------------------------------------------------------15
一、问题的重述
无人机的发展至今已有70多年的历史，其军事应用主要是执行各种侦察任务。随着无人机平台技术和机载遥感技术的不断发展，它的军事应用范围已经得到大大的扩展，并且这种扩展还将持续下去，如通信中继、军事测绘、电子对抗、信息攻击等。特别是精确制导武器技术的发展，又使它成为搭载这种武器的理想平台。
众所周知，“自主飞行”的能力是无人驾驶飞机所必须具有的。如果要实现无人驾驶飞机的自主飞行,那么就要求无人驾驶飞机具有相当程度的飞行航迹规划能力。无人机的航迹规划是指其为了圆满完成任务而作的计划。它往往指单机在初始位置、终止位置和一些目标任务结点确定之后的航迹规划问题,其基本功能是根据无人机的性能和飞经的地理环境、威胁环境等因素,对已知的目标规划提出满足要求的航迹,以便在实际飞行时可以根据需要进行实时的局部修改。
现在要讨论如下的情况：
假定无人机的活动范围为20km×20km的区域，无人机起点的平面坐标为[1,2](单位：km), 攻击目标的平面坐标为[19,18](单位：km)，同时不考虑无人机起飞和降落时的限制。数字地图和敌方威胁情况(主要考虑雷达威胁)可以从附件中查得。数字地图可以做适当的简化，比如可以把地形近似分为三种：高地，低地以及过渡地带。
具体问题如下：
问题1：忽略地形和无人机操作性能等因素的影响，综合考虑敌方威胁情况、无人机航程等因素，基于二维平面建立单机单目标的航迹规划模型。
问题2：把模型扩展到三维空间，并同时考虑无人机的操作性能（主要考虑拐弯）和地形因素。
问题3：试讨论和分析上述模型的可行性，并做仿真分析。
二、问题的分析
对于问题一，经过分析后我们认为平面是一个连续的集合，为了便于研究，我们将无人机能够活动的平面划分成有限个正方形的网格，这样就可以把无限的、连续的研究对象转化为有限的、离散的，便于计算和研究。另外，这样划分也可以保证计算结果的精度。
另外，要考虑敌方的威胁（这里主要指雷达威胁），那么就要将雷达的“威胁程度”进行量化。在进行了量化之后，就可以考虑构建威胁模型。在上述准备工作完成之后，就要根据量化的数据进行最优航迹的求解。因为我们在本问中所建立的模型求解的是最优航迹，所以可以使用Dijkstra算法进行求解。
问题二要求把模型扩展到三维空间，并同时考虑无人机的操作性能（主要考虑拐弯）和地形因素。经过分析我们认为，问题二是在问题一的基础上,把问题拓展到三维空间里,综合考虑雷达威胁因素、地形因素和飞机本身的因素,建立一个可以确定飞机最优航迹的综合模型。因此，无人机的航迹规划问题可转化为一个带约束的优化问题。如果对规划空间进行三维网格划分，可得到若干节点,从而构成一个网格图，则优化问题的搜索空间就转化为一个离散的空间节点集,而问题的求解也可简单归结为一个求解网络图最短路径的组合优化问题,使得无人机在沿着这些节点所形成的路径上飞行时具有最小代价。对此我们采用一种基于改进蚁群算法的无人机三维航迹规划方法, 将最短路径的信息反馈到系统中作为搜索的指导信号,并改进节点选择方法,以提高应用蚁群算法搜索无人机三维航路的效率，以保证在敌方防御区域内以最小的被发现概率以及可接受的航程到达目标。
对于第三问，我们可以在对相关参数进行适当赋值后，在MATLAB中进行仿真模拟。
三、模型假设
（1）假设附件中所提供雷达威胁的坐标方位表和数字地图真实有效，并在短期内不会改变。
（2）假设无人机的活动范围为题目中所述的20km×20km的区域。
（3）假设所有雷达全天24小时都开机。
（4）假设每个雷达的作用方式完全一致，且无人机具有相同的雷达反射截面。
（5）假设每个雷达之间不存在信息交流，即当一个雷达发现目标时，不会通知其他雷达。
（6）假设无人机在执行任务的过程中不会出现故障。
（7）不考虑地形的变化对气流造成的影响。
四、符号说明
：雷达对无人机的杀伤概率
：突防高度下绝对杀伤区半径
:突防高度下非绝对杀伤区半径
：雷达对无人机的威胁代价
：无人机飞行时的的燃油代价
：无人机飞行时的的高度代价
文中出现的其它符号在用到时另行说明。
五、模型的建立
5.1问题一模型的分析、建立与求解
5.1.1问题一模型的分析
首先，针对本问中的模型，我们做出如下假设：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7931e3c02b8acbd45586e0b630224e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1326cf8900d9ba0086a84863057e9cc/" rel="bookmark">
			【SWAT水文模型】SWATCUP率定参数实例-以某具体流域为例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SWATCUP率定参数实例 1 径流率定选取参数1.1 径流 Runoff1.2 蒸发 Evaporation1.3 基流 Base flow1.4 主河道 Main1.5 土壤 Soil 2 径流率定过程3 设置上中下游分开率定参考 流域如下所示：
模拟参数设置如下：（设置500代每次进行调试）
13 : Number of Parameters 1000 : number of simulations r__CN2.mgt	-0.2 0.2 v__SURLAG.bsn	0.05 24 v__OV_N.hru	0.01 30 v__ESCO.hru	0.1 1.0 v__GW_REVAP.gw 0.02 0.02 v__ALPHA_BF.gw 0.0 1.0 v__GW_DELAY.gw	30.0 450.0 v__CH_N2.rte -0.01 0.3 v__CH_K2.rte -0.01 500 v__ALPHA_BNK.rte 0.0 1.0 r__SOL_K().sol -0.2 0.2 r__SOL_AWC().sol -0.2 0.2 r__SOL_BD().sol -0.2 0.2 相应SWATCUP界面显示如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1326cf8900d9ba0086a84863057e9cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09b5363a44c76b7af1c1671cacf65d2c/" rel="bookmark">
			数组之滑动窗口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		所谓滑动窗口，就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果。
在暴力解法中，是一个for循环滑动窗口的起始位置，一个for循环为滑动窗口的终止位置，用两个for循环 完成了一个不断搜索区间的过程。
那么滑动窗口如何用一个for循环来完成这个操作呢。
首先要思考 如果用一个for循环，那么应该表示 滑动窗口的起始位置，还是终止位置。
如果只用一个for循环来表示 滑动窗口的起始位置，那么如何遍历剩下的终止位置？
此时难免再次陷入 暴力解法的怪圈。
所以 只用一个for循环，那么这个循环的索引，一定是表示 滑动窗口的终止位置。
最小滑窗模板 给定数组 nums，定义滑窗的左右边界 i, j，求满足某个条件的滑窗的最小长度。
while j &lt; len(nums): 判断[i, j]是否满足条件 while 满足条件： 不断更新结果(注意在while内更新！) i += 1 （最大程度的压缩i，使得滑窗尽可能的小） j += 1 最大滑窗模板 给定数组 nums，定义滑窗的左右边界 i, j，求满足某个条件的滑窗的最大长度。
while j &lt; len(nums): 判断[i, j]是否满足条件 while 不满足条件： i += 1 （最保守的压缩i，一旦满足条件了就退出压缩i的过程，使得滑窗尽可能的大） 不断更新结果（注意在while外更新！） j += 1 关键的区别在于，最大滑窗是在迭代右移右边界的过程中更新结果，而最小滑窗是在迭代右移左边界的过程中更新结果。因此虽然都是滑窗，但是两者的模板和对应的贪心思路并不一样，而真正理解后就可以在lc.76，lc.904，lc.3, lc.1004写出非常无脑的代码。
时间复杂度为：O(N), 空间复杂度为：O(N).
其实双指针和滑动窗口是有些许区别的。滑动窗口一句话就是右指针先出发，左指针视情况追赶右指针。可类比男生暗恋女生，两人都在往前走，但男生总是默默跟着女生走但又不敢超过她。因此，右指针最多遍历一遍数组，左指针也最多遍历一次数组，时间复杂度不超过O(2N)。接下来，如何判断滑动窗口内是否满足题设条件，有两种选择：(1) 要么你遍历这个滑窗，通过遍历来断滑窗是否满足需要O(N), 那么总的时间就退化为O(N^2), (2) 要么你选择字典，用空间换时间，那么判断划窗是否满足条件则需要 O(1)，总时间为O(N).
lc904 水果成篮（最大滑窗） 白话题意：求满足某个条件（数组值最多就两类的连续数组，例如[1,2,2,1,2]）的最长数组长度
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09b5363a44c76b7af1c1671cacf65d2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/147eddb955bf93ce4071e219f996097e/" rel="bookmark">
			Docker部署RocketMQ5.x (单机部署&#43;配置参数详解&#43;不使用docker-compose直接部署)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker部署RocketMQ5.x 单机部署+配置参数详解+不使用docker-compose直接部署 镜像拉取（使用apache/rocketmq镜像包含NameServer+Broker+Proxy...）部署NameServer创建挂载文件夹创建挂载文件启动NameServer 部署Broker创建需要映射的文件夹和文件创建的挂载文件夹创建broker.conf文件拷贝容器内Broker启动脚本到宿主机（如果不需要自定义堆内存可以跳过） 启动Broker 部署Proxy部署RocketMQ控制台（rocketmq-dashboard）镜像拉取启动RocketMQ控制台（rocketmq-dashboard） Broker配置详解 官网地址：https://rocketmq.apache.org/ 镜像拉取（使用apache/rocketmq镜像包含NameServer+Broker+Proxy…） 镜像地址： https://hub.docker.com/r/apache/rocketmq/tags
我在部署的时候最新发行版是5.1.0可以根据需求自行选择一个5.x的版本，部署流程不会有太大改变。
docker pull apache/rocketmq:5.1.0 部署NameServer NameServer是一个简单的 Topic 路由注册中心，支持 Topic、Broker 的动态注册与发现，几乎无状态节点，因此可集群部署，节点之间无任何信息同步，所谓的集群部署和单机部署其实是一样的，需要多个NameServer保持高可用只需独立部署即可。
创建挂载文件夹 # 日志目录 mkdir /usr/local/rocketmq/nameserver/logs -p # 脚本目录 mkdir /usr/local/rocketmq/nameserver/bin -p 设置权限：如果不设置会导致NameServer容器内部无法写日志文件
# 777 文件所属者、文件所属组和其他人有读取 &amp; 写入 &amp; 执行全部权限。rwxrwxrwx chmod 777 -R /usr/local/rocketmq/nameserver/* 创建挂载文件 NameServer启动脚本中有一个自动计算最大堆内存和新生代内存的函数会导致在不同硬件环境下设置最大堆内存和新生代内存环境变量不被应用，，这里先提前copy一份容器内部启动脚本做挂载，如果想自定义内存可以自己调整。
1、启动容器
docker run -d \ --privileged=true \ --name rmqnamesrv \ apache/rocketmq:5.1.0 sh mqnamesrv 2、复制容器内启动脚本到挂载目录/usr/local/rocketmq/nameserver/bin
docker cp rmqnamesrv:/home/rocketmq/rocketmq-5.1.0/bin/runserver.sh /usr/local/rocketmq/nameserver/bin/runserver.sh 3、修改runserver.sh
# 打开脚本文件 vi /usr/local/rocketmq/nameserver/bin/runserver.sh 找到调用calculate_heap_sizes函数的位置注释掉保存即可，拉到脚本最底部就能找到
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/147eddb955bf93ce4071e219f996097e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd9e074be43c792d4ff1b7e2a6fc0c26/" rel="bookmark">
			Java中23种经典设计模式详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.1.1 工厂方法 *义一个用于创建对象的接口，让子类决定实例化哪一个类。FactoryMethod使一个类的实例*延迟到其子类。
适用性
1.当一个类不知道它所必须创建的对象的类的时候。
2.当一个类希望由它的子类来指定它所创建的对象的时候。
3.当*将创建对象的职责委托给多个帮助*类中的某一个，并且*希望将哪一个帮助子类是代理者这一信息局部化的时候。
参与者
1.Product
定义工厂方法所创建的对象的接口。
2.ConcreteProduct
实现Product接口。
3.Creator
声明工厂方法，该方法返回一个Product类型的对象*
Creator也可以定义一个工厂方法的缺省实现，它返回一个缺省的ConcreteProduct对象。
可以调用工厂方法以创建一个Product对象。
4.ConcreteCreator
重定义工厂方法以返回一个ConcreteProduct实例。
*roduct public interface Work { void doWork(); } ConcreteProduct public class StudentWork implements Work { public void doWork() { System.out.println("学生*作业!"); } } public class TeacherWork implements Work { public void doWork() { System.out.println("老师审批作业!"); } } Creator public interface IWorkFactory { Work get*ork(); } Concre*eCreator pu*lic class StudentWorkFactory implements IWorkFactory { public Work getWork() { *eturn new StudentWork(); } } public class TeacherWorkFactory implements IWorkFactory { public Work getWork() { return new TeacherWork(); } } Test public class Test { public static void m*in(Strin*[] args) { IWorkFactory studentWorkFactory = new StudentWorkFactory(); studentWorkFactory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd9e074be43c792d4ff1b7e2a6fc0c26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3159ed72643b234cb3d411cabe99af45/" rel="bookmark">
			Android SurfaceFlinger导读（10）理解DisplayDevice
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该系列文章总纲链接：Android GUI系统之SurfaceFlinger 系列文章目录
本章关键点总结 &amp; 说明： 本章节思维导图如上。主要讲述了DisplayDevice的概念，这里 主要DisplayDevice的创建流程和 两个关键方法makeCurrent 和swapBuffer。
在之前的分析中，我们知道 每个应用端对应一个SurfaceControl，每个SurfaceControl都对应多个Surface，即 应用端使用Surface来管理Buffer。实际上在SurfaceFlinger中 DisplayDevice也是通过Surface来管理Buffer。这里简单说明下两者的异同：
应用端的Buffer是向Ashmem申请的；DisplayDevice端的Buffer是向FrameBuffer申请的应用端的Buffer是用来填充的；DisplayDevice端的Buffer是用来推给Framebuffer 渲染的 了解了这些后，我们开始从DisplayDevice创建流程开始分析。
1 DisplayDevice创建流程开始分析
DisplayDevice是在SurfaceFlinger的init中创建的，代码实现如下：
void SurfaceFlinger::init() { //... // initialize our non-virtual displays for (size_t i=0 ; i&lt;DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES ; i++) { DisplayDevice::DisplayType type((DisplayDevice::DisplayType)i); // set-up the displays that are already connected if (mHwc-&gt;isConnected(i) || type==DisplayDevice::DISPLAY_PRIMARY) { // All non-virtual displays are currently considered secure. bool isSecure = true; createBuiltinDisplayLocked(type); wp&lt;IBinder&gt; token = mBuiltinDisplays[i]; //BufferQueue相关 sp&lt;IGraphicBufferProducer&gt; producer; sp&lt;IGraphicBufferConsumer&gt; consumer; BufferQueue::createBufferQueue(&amp;producer, &amp;consumer, new GraphicBufferAlloc()); //关键点1：FramebufferSurface创建，定位为 消费者身份 sp&lt;FramebufferSurface&gt; fbs = new FramebufferSurface(*mHwc, i, consumer); int32_t hwcId = allocateHwcDisplayId(type); //关键点2：DisplayDevice创建，定位为 生产者身份 sp&lt;DisplayDevice&gt; hw = new DisplayDevice(this, type, hwcId, mHwc-&gt;getFormat(hwcId), isSecure, token, fbs, producer, mRenderEngine-&gt;getEGLConfig()); if (i &gt; DisplayDevice::DISPLAY_PRIMARY) { hw-&gt;setPowerMode(HWC_POWER_MODE_NORMAL); } mDisplays.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3159ed72643b234cb3d411cabe99af45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5e384c24a7a07aeec5ea6e33d6b9e48/" rel="bookmark">
			工具使用【PDManer】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		综述
该开源产品有新建、导入导出模型、导出word、生成java相关类等功能，类似与powerdesigner，没有直接更改数据库的操作。
下载地址 http://www.pdmaner.com/download/v4.6.2
使用手册地址 https://www.yuque.com/pdmaner/docs/pdmaner-manual#WUstl
根据已有数据库导入模型 全量与增量同步，应该是被删除了 初始化基线后，改了一个字段名只同步到现在的模型中，没有同步到数据库上。
生成java代码导出 生成关系图 新建一个关系页，然后将表拖入其中
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/186ca6ad039f50e05f55bb5ee717f81c/" rel="bookmark">
			LLMops：大模型时代的运维与部署之道
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着人工智能技术的快速发展，大模型时代已经来临。大模型具备更强的泛化能力和更高的性能，为各个行业提供了更广阔的应用空间。然而，随着模型规模的增大，模型运维和部署的难度也日益凸显。LLMops（Large Language Model Operations and Maintenance Patterns）作为大模型时代的模型运维与部署方法，为大模型的落地应用提供了重要的技术支持。
一、大模型时代的挑战
大模型由于其巨大的参数量和复杂的结构，给模型的运维和部署带来了诸多挑战。首先，大模型的计算和存储需求巨大，对算力和存储资源提出了更高的要求。其次，大模型的训练和推理时间较长，需要高效的训练和推理框架来缩短周期。此外，大模型的应用场景多样化，要求模型具备更高的可扩展性和灵活性。
二、LLMops的重要性和特点
针对大模型时代的挑战，LLMops应运而生。LLMops是大模型运维和部署的方法论，旨在为大模型的落地应用提供一套完整的解决方案。LLMops具有以下特点：
高效的训练和推理框架：LLMops采用分布式训练和并行推理框架，充分利用计算和存储资源，提高大模型的训练和推理效率。
可扩展性和灵活性：LLMops支持多种硬件平台和训练框架，具备强大的可扩展性。同时，LLMops提供灵活的模型部署方式，满足不同场景的应用需求。
模型优化和压缩：LLMops通过对大模型进行优化和压缩，降低模型的复杂度和计算量，提高模型的实时性和性能。
模型版本管理和回滚：LLMops建立完善的模型版本管理体系，支持模型回滚和升级，保证大模型的安全稳定运行。
数据安全和隐私保护：LLMops注重数据安全和隐私保护，采取一系列安全措施，确保数据的安全性和机密性。
三、LLMops的应用场景
LLMops在大模型时代的模型运维和部署中具有广泛的应用场景，下面举几个例子：
自然语言处理（NLP）：NLP领域的任务通常需要处理大量的文本数据，并使用复杂的大模型进行特征提取和语义理解。LLMops可以提供高效的训练和推理框架，缩短模型的训练和推理时间。
语音识别和生成：语音识别和生成领域的大模型需要处理音频数据，并使用复杂的深度学习模型进行特征提取和生成。LLMops可以提供可扩展性和灵活性，适应不同场景下的语音处理需求。
图像处理：图像处理领域的大模型通常需要处理大量的图像数据，并使用深度学习技术进行特征提取、分类、分割等任务。LLMops可以提供高效的训练和推理框架，提高图像处理的效果和性能。
自动驾驶：自动驾驶领域的大模型需要处理多种传感器数据，并使用复杂的深度学习模型进行感知、决策和控制。LLMops可以提供高效的训练和推理框架，提高自动驾驶的安全性和性能。
四、总结
大模型时代的模型运维与部署面临着诸多挑战，而LLMops为大模型的落地应用提供了重要的技术支持。LLMops具备高效的训练和推理框架、可扩展性和灵活性、模型优化和压缩、模型版本管理和回滚以及数据安全和隐私保护等特点，适用于自然语言处理、语音识别和生成、图像处理、自动驾驶等应用场景。未来，随着大模型技术的不断发展，LLMops有望为大模型的广泛应用做出更大的贡献。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55345844776b634678e009069ca1a50c/" rel="bookmark">
			【UE4 C&#43;&#43;】根据指定路径生成静态网格体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在上一篇博客中（【UE C++】蓝图调用C++函数），我们用C++创建了一个蓝图函数库，本篇文章在这个蓝图函数库基础上增加一个方法，该方法只需输入一个文件目录路径，就可在场景中生成该目录下得所有静态网格体。（如果不想写C++的话，可以用这篇文章的方法：UE4 | BP | 使用蓝图获取Uasset资源_ue4 蓝图加载uasset资产）
在.cpp文件中增加如下代码：
TArray&lt;UObject*&gt; UMyBlueprintFunctionLibrary::FindOrLoadAssetsByPath(const FString&amp; FilePath) { TArray&lt;UObject*&gt; LoadedObjects; EngineUtils::FindOrLoadAssetsByPath(FilePath, LoadedObjects, EngineUtils::ATL_Regular); return LoadedObjects; } 在.h文件中添加如下代码：
UFUNCTION(BlueprintCallable, Category="LibraryFunction") static TArray&lt;UObject*&gt; FindOrLoadAssetsByPath(const FString&amp; FilePath); 编译后，打开虚幻编辑器，新建一个父类为Actor的蓝图类，这里命名为“BP_CreateStaticMesh”
打开“BP_CreateStaticMesh”，添加一个静态网格体组件
添加一个变量，这里命名为“Mesh”
“Mesh”变量的变量类型是静态网格体的对象引用。勾选可编辑实例、生成时公开
在构造函数中添加如下节点，这样在“BP_CreateStaticMesh”生成时，就能根据传入给Mesh的模型来生成静态网格体
再新建一个Actor蓝图，这里命名为“BP_CreateStaticMeshByPath”
打开“BP_CreateStaticMeshByPath”，在事件图表中添加如下节点
如下是我静态网格体的存放路径
将“BP_CreateStaticMeshByPath”拖入视口
运行游戏可以看到生成了静态网格体
有时候用户想自己改变这个静态网格体，该如何做？我目前进展是：
首先打包设置中，取消勾选“使用Pak文件”，这样打包后Content文件夹中就不再仅是一个.pak文件，而是和打包前工程目录中的Content文件夹一样。
打包后，比如我删除了“Key”这个文件夹，场景中确实不会出现对应的静态网格体，还原后也还是能生成之前的静态网格体。
但是让人头大的是打包后的模型不再是FBX或是obj之类的模型，而是变成了.uasset格式文件，这样用户就不能直接向文件夹中导入一个3D模型让引擎调用。
我特地搜了一下如何将FBX转.uasset格式文件，例如：[UE4 convert .fbx to .uasset commandlet] - #7 by nyudeb - Pipeline &amp; Plugins - Epic Developer Community Forums
，但是即使生成了.uasset文件还是不行，我将.uexp文件删除后，打包后的exe就无法运行并且弹出报错的窗口。
如果路过的大佬有什么见解，还希望在评论区指点一下，谢谢~
相关文章 【UE】在游戏运行时，通过选择uasset来生成静态网格体-CSDN博客
参考文章 1. UE4 根据文件夹路径生成文件夹下的所有静态网格体(蓝图)_ue4将静态网格体转换成蓝图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55345844776b634678e009069ca1a50c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12f9224241e0191441300ea6f93682e8/" rel="bookmark">
			基于全新电脑环境安装pytorch的GPU版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 距离第一次安装深度学习的GPU环境已经过去了4年多（当时TensorFlow特别麻烦），现在发现安装pytorch的GPU版本还是很简单方便的，流程记录如下。
安装步骤： 步骤一：官网下载Anaconda Free Download | Anaconda
直接下载最新版本到电脑里，并安装。
步骤二：查询电脑的CUDA Version win+R 然后输入cmd调出命令窗，输入 nvidia-smi
步骤三：确定电脑GPU的NVDIA型号。 通过搜索找到”设备管理器”，再找到其中的“显示适配器”。
步骤四：更新NVIDIA驱动程序 NVIDIA官网：https://www.nvidia.cn/
选择对应的硬件环境
搜索到合适的驱动后，下载并安装（可以用C盘的默认位置）。
安装完毕后，重启电脑。
步骤五：再次查询CUDA Version win+R 然后输入cmd调出命令窗，输入 nvidia-smi
可以看到，CUDA Version的版本已经从11.7变成了12.2。
步骤六：通过官网下载pytorch 官网地址：https://pytorch.org/
注意：CUDA Version要选择比电脑低的情况，我这里选择了默认推荐版本。
在Anaconda的prompt中输入官网指令。
pip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu117
在安装过程中，遇到的选择，全部选择y。
其中，由于没有借助镜像源（增加出问题的概率），安装过程较慢（大概花了30分钟）。
步骤七：在anaconda的prompt环境测试安装结果 显示True，安装成功。
步骤八：打开anaconda自带的spyder编辑器进行测试 步骤九：跑一个MNIST数据集分类样例代码测试 nvidia-smi -l 1实时观察GPU的占用率
补充说明 （1）windows系统需要增加Anaconda的环境变量。 （2）matplotlib通常需要重新安装对应版本，很容易版本不匹配。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b11549edf38e94459d8cfcf180fc457/" rel="bookmark">
			详解IDEA git 版本回滚
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者简介
目录
1.git分区
2.未commit，进行回滚
3.commit未push，进行回滚
3.1.undo commit
3.2.reset
4.已commit&amp;push，进行回滚
1.git分区 git的版本回滚其实就是回滚不同的分区，所以在聊git回滚之前我们有必要简单了解一下git的分区。git在本地有三大分区：工作区、暂存区、版本库。
工作区：正在编写，还未add的部分，红色。
暂存区：add后的代码，绿色。
版本库：commit后的代码，灰色。
在IDEA中，在loacl changes中可以看到在工作区中和暂存区中的内容：
版本库中的内容可以从log中看出来，log中可以看到commit test这条提交的分支是本地的main分支，如果是已经同步到远端的提交分支会显示为origin/main：
2.未commit，进行回滚 已经add到暂存区，但是未commit到本地版本库的改动有两种：
新增的文件
修改的文件
新增的文件直接删除即可，如果是修改的文件，使用roll back来回滚。在local change里面，选择想要rollback的文件即可：
也可以直接右击要rollback的文件然后rollback也行。
3.commit未push，进行回滚 3.1.undo commit commit到本地版本库并且还未push的代码，可以在log里右击单次提交进行undo commit：
需要注意的是undo commit只能从最后一次commit开始回滚，undo commit后会要求选择一个变更列表来存放回滚后的内容，可以自己新建一个，比如此处的commit test，也可以在下拉框里选择一个已经存在的，如果是自己新建的变更列表，勾选了set active选项，后续的变动也会存放到该变更列表中：
可以看到多了一个变更列表：
变更列表有什么用喃？其实变更列表可以把它视为一个命名空间，就是用来做资源隔离的，在进行commit的时候需要下拉选择不同的变更列表来进行提交：
3.2.reset 有时候我们需要直接将本地的代码回滚到版本库的某一个版本，这时候可以使用reset来进行回滚。reset有几种模式：
soft，将版本回滚，工作区不动，暂存区=原来的+回滚后和回滚前的版本差异。
mixed，将版本回滚，回滚到了所有 git add 和 git commit 的命令执行之前。暂存区变为空，变更全部到了工作区。
hard，将版本回滚，将所有工作区和暂存区的文件修改全部清空，是真正的覆盖，不能找回了。
keep，将版本回滚，将所有commit的内容丢弃掉，未commit的内容保留。
在log上选择要回滚到的具体版本：
reset时会要求选择回滚的模式：
4.已commit&amp;push，进行回滚 对commit&amp;push的内容进行回滚其实就是对远端仓库的代码版本进行回滚，在实际开发中偶尔会将内容误推送到了远端仓库上去。比如commit的message写错了，查看log的时候才发现，比如不小心将本地还没有开发完成的代码推送到远端仓库了，由或者合并冲突或者分支的时候合并错了......等等这些情况都要我们对远端仓库的代码进行回滚。
回滚的方式其实很简单，就是将本地的代码版本回滚到指定版本（至于是用revert还是reset，看自己），然后将本地的版本用git push -f强推到远端。
在IDEA中可以在terminal中执行指令：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ca3a646a550e085e5216ae6da118bf5/" rel="bookmark">
			微信小程序 -- 页面间通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 今天我们来说下微信小程序的页面间通信：
通过url传参实现页面间单向通信通过getCurrentPages()页面栈实现页面间单向通信通过EventChannel实现页面间双向通信 1、url传参 我们知道页面之间的跳转可以通过路由组件来实现，其中组件的属性url就是要跳转到页面的路径。
我们可以通过在路径中添加需要传递的数据来实现页面间数据通信
//数据传递 wx.navigateTo({ url: '../../followUp/index?aa=1256&amp;bb=jkkk' }) //数据接收 onLoad: function (options) { const {info} = options; }, 2、getCurrentPages() 获取当前页面栈。数组中第一个元素为首页，最后一个元素为当前页面。
通过获取到相应的页面栈对象，然后根据业务需求，执行具体操作。
//数据传递 let curPages = getCurrentPages();//获取当前页面栈列表 var prevPage = curPages[curPages.length - 2];//上一页面栈对象 prevPage.setData({ aa:'111111', bb:'2222222', }); prevPage.updateInfo(); 2、EventChannel 如果一个页面(B)由另一个页面(A)通过 wx.navigateTo 打开，这两个页面间将建立一条数据通道：
被打开的页面可以通过 this.getOpenerEventChannel() 方法来获得一个 EventChannel 对象；
wx.navigateTo 的 success 回调中也包含一个 EventChannel 对象。
这两个 EventChannel 对象间可以使用 emit 和 on 方法相互发送、监听事件。
//--------------------------页面A-------------------------- wx.navigateTo({ url: '../../followUp/index', events: { //接收页面B传递的数据 two: function (data) { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ca3a646a550e085e5216ae6da118bf5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76b1fe2844e699ba9f135f9953254c00/" rel="bookmark">
			BUUCTF NewStarCTF 2023 WEB题WP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.泄露的秘密 直接在URL处访问www.zip文件
将下载下来的www.zip文件解压即可得到flag
常见的文件泄露一般泄露的都是网站的备份文件，常见的备份的文件名通常为 wwwroot、www、子域名等，压缩包后缀通常为 zip、tar.gz 等
其他的也有配置文件的泄露。建议自己收集一个敏感文件的字典
二.Begin of Upload 很简单的文件上传
查看网页源码可以发现限制上传的js代码，是最没用的前端过滤
这里只需要F12，再F1，选择禁用js代码即可
接下来构造一个一句话木马
&lt;?php @eval($_POST['a']); ?&gt; 这里写用GET方式的马应该也可以，我没有试，感觉用webshell管理工具找flag更快
直接上传即可
打开自己的webshell管理工具，这里我用的蚁剑
URL地址是 IP/upload/demo.php
连接密码就是POST中的参数
点击测试连接，出现连接成功就代表成功了
选择保存，右键刚刚添加的数据
flag藏在根目录下
三.Begin of HTTP 提示我们使用GET方式传参
http://ip/?ctf=1
又让用POST传参
先找一下secret的值
查看源代码，再代码中藏着secret的值
再进行base64解码
n3wst4rCTF2023g00000d
接着我们使用burp抓包
将抓到的包改为POST请求方式
这里要注意第一小关get请求的参数也要带着
接下来把cookie的power值改为ctfer即可
吧UA头改为NewStarCTF2023即可，注意不用带着浏览器三个字
这里需要添加一个Referer头，填入对应网址即可
本地用户这里我卡了很久，最后是用的X-Real-IP这个头，确实没想到
四.ErrorFlask 一看到Flask我就想到了之前做过的一个模板注入题和debug调试漏洞
来到题目，让我们穿一个number1和number2.那我们先传一个number1看看会咋样
很熟悉的报错界面，看到这里我当时基本确定了是需要计算pin，通过python的shell交互找flag，顺着这个思路让我吃了大亏啊
先来揭秘flag在哪，万万没想到啊，flag就在这个报错界面啊
展开 File "/app/app.py", line 11, in hello 即可看到flag
说到这里了，我简单介绍一下flask debug漏洞
在这个报错界面，我们把鼠标随便放到一行上，可以看的这个小黑框
点一下就提示我们输入pin
pin码的计算通常需要五个部分
首先是app的绝对路径，在报错界面即可找到
然后是uuidnode 通常在如下路径下
/sys/class/net/eth0/address
然后需要拿到ID 通常在如下这两个里面
/proc/sys/kernel/random/boot_id file
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76b1fe2844e699ba9f135f9953254c00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ad5b3eb5e684afb0ce422753f4e4f5b/" rel="bookmark">
			JavaScript 中testContent的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 JavaScript 中，textContent 是一个常见的属性，用于获取或设置一个 HTML 元素及其子元素的文本内容。
要获取元素的文本内容，可以使用以下语法：
var element = document.getElementById("example"); // 获取元素 var text = element.textContent; // 获取元素的文本内容 console.log(text); // 输出文本内容 要设置元素的文本内容，可以使用以下语法：
var element = document.getElementById("example"); // 获取元素 element.textContent = "New Text"; // 设置新的文本内容 请注意，textContent 返回的是纯文本内容，不包含 HTML 标签，而且会保留换行符和空格。如果你希望获取包含 HTML 标签的内容，可以使用 innerHTML 属性。另外， textContent 是只读属性，你只能通过赋值来修改元素的文本内容。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9a7ac426509a79926b38d6cbf4639d7/" rel="bookmark">
			新型双功能整合剂，NOTA-奥曲肽，NOTA-octreotide，具有广泛应用前景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关键词：NOTA-octreotide，NOTA-奥曲肽
【名称】
中文名：NOTA-奥曲肽
英文名：NOTA-octreotide
CAS：N/A
结构式：
【处置与储存】
外观：固体/粉末
规格种类：1g，5g，10g
纯度：95%，详情可在线咨询
发货：每日订单截止时间为16点整，特殊情况可来电咨询，确保在承诺的时间内提供理想的产品。
保存建议： 需要存储在-20°C，避光，避湿，避免反复冻融。从冰箱取出产品后,置于室温回温至少30min-1h，再开盖，以避免受潮。
注意事项：在有粉尘生成的地方，提供合适的排风设备，不要让产物进入下水道。本品仅供科研用途，不作为药物、家庭备用药或其它用途。
【产品介绍】
大环化合物NOTA-octreotide，NOTA及其衍生物具有良好的配位和整合能力，是应用为广泛的新型双功能整合剂之一。针对奥曲肽类探针的标记，用于检测的正电子核素主要有68Ga、18F、64Cu和89Zr，其中，常用的是68Ga离子，因其成本低廉、合成简单、放化收率高颇受青睐。它的结构与天然生长激素类似，因此能够与受体结合并产生生物效应。此外，NOTA-octreotide还具有较长的半衰期和较低的毒副作用。
对于NOTA-octreotide这种新型的肿瘤靶向治疗药物，其作用机制主要是利用NOTA（氮氧乙酰基）与生长抑素类似物的结合，以增加其在肿瘤组织中的聚集和滞留，从而实现对肿瘤的精准靶向治疗。该药物在一定时间内可以在肿瘤组织中形成高浓度的生长抑素类似物，有效抑制肿瘤细胞的增殖和扩散，并刺激免疫细胞对肿瘤细胞的杀伤作用。同时，由于其具有较好的组织穿透能力，能够透过肿瘤组织，进入血液循环系统，从而实现对肿瘤的全身治疗。
【同类型相关产品】
Cinnamycin-PEG3-NOTA
Azido-TAT
Cyclo(Leu-Ser)
Cyclo(Leu-Thr)
Cyclo(Leu-Tyr)
NOTA-3P-TATE-RGD
cyclo(Ala-Gly)
Cyclo(-Leu-Leu)
Cyclo(Leu-Ser)
Alfatide II
Cyclo(D-Leu-D-Pro)
cyclo(Leu-Phe)
cyclo(Gly-Leu)
Cyclo(-Leu-Pro)
Azido-ApoPep-1
Cyclo(Leu-Thr)
Pentynoic cyclic RGDyK
CTTHWGFTLC, CYCLIC
cyclo(Ala-Glu)
cyclo(Ala-Gln)
Cyclo(Ile-Leu)
Cyclo(-Arg-Gly-Asp-D-Phe-Lys)
4-Aminobutyl-DOTA-tris (t-butyl ester)，CAS：1402393-59-2
DOTA-NHS-ester，CAS：1823122-52-6
4-Aminobutyl-DOTA，CAS：753421-63-5
DOTA-tris (t-Bu ester)，CAS：137076-54-1
2-Aminoethyl-mono-amide-DOTA-tris(t-Bu ester)，CAS：173308-19-5
Azido-mono-amide-DOTA，CAS：1227407-76-2
本篇图文信息均由陕西新研博美生物科技有限公司小编木木提供，如需了解详细烦请联系！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62cb768dacee3fae922741583289c68f/" rel="bookmark">
			2023前端最全Vscode插件合集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 本人情况：接触 Vscode 两年多，前端实习近一年左右
插件包含：主题美化、自动补全、头部注释等
插件说明：本文推荐插件排名不分先后，均为自用插件。使用 Vscode 这两年中用过形形色色的各种插件，最后留下的就只剩这些，若你还有其他好用插件，欢迎评论区讨论。
二、挨个详解 1、汉化Vscode，必备插件之一 2、One Dark Pro，经典主题 3、Fiedl Lights Theme，我独爱的一款主题，非常耐看 3、IntelliCode：图标插件，效果如下图 4、background-cover：自定义背景 5、koroFileHeader：安装配置好后，自动生成头文件注释 6、Tabnine AI：强大的代码提示工具，可以根据你的代码习惯，快速生成你可能想要的代码 7、Path Intellisense： 路径自动补全工具 8、Path Autocomplete： 同位路径提示差价，不多赘述 9、Prettier - Code formatter：格式化代码工具，帮你一键调整代码格式 10、Eslint：统一代码风格用，配合 Prettier 使用有良好的体验。但是新手不建议装！！！ 11、filesize：安装后可在右下角显示当前问价的大小 12、CSS Peek：帮你快速查看 Css样式的位置 13、Beautify css/sass/scss/less：Css代码格式化 14、Auto Close Tag：HTML标签自动补全 15、Auto Rename Tag：辅助修改标签名 16、Code Spell Checker：帮你检查代码中的单词拼写错误 17、Git Graph：帮助你快速查看 Git 提交日志 18、Image preview：引入图片后，可以预览图片 19、npm Intellisense：从node_modules中引入依赖时 自动补全 20、Turbo Console Log：便捷的 console.log工具，我也还在摸索，不太适应 三、结语 后续我有其他好的插件，也会继续更新在此文章上，点赞收藏不迷路，希望你也能高效舒适的完成你的前端开发！！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bf8b68de86fa3b47963bc36c8a35b44/" rel="bookmark">
			SpringBoot&#43;Vue校园管理系统(源码&#43;论文&#43;答辩PPT)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 采用技术： 后端：Java+SpringBoot
前端：Vue
数据库：MySQL
开发软件：Eclipse、MyEclipse、IDEA都可以运行
系统功能： 1、关于校园管理系统的基本要求
（1）功能要求：可以管理首页、个人中心、院校管理、用户管理、单位类别管理、院校管理员管理、单位管理、通知推送管理、投票信息管理、通知回复管理等功能模块。
（2）性能：在不同操作系统上均能无差错实现在不同类型的用户登入相应界面后能不出差错、方便地进行预期操作。
（3）安全与保密要求：用户都必须通过身份验证才能进入系统，并且用户的权限也需要根据用户的类型进行限定。
（4）环境要求：支持多种平台，可在Windows系列、Vista系统等多种操作系统下使用。
2、开发目标
校园管理系统的主要开发目标如下：
（1）实现管理系统信息关系的系统化、规范化和自动化；
（2）减少维护人员的工作量以及实现用户对信息的控制和管理。
（3）方便查询信息及管理信息等；
（4）通过网络操作，改善处理问题的效率，提高操作人员利用率；
（5）考虑到用户多样性特点，要求界面简单，操作简便。
3、设计原则
本校园管理系统采用Java技术，MySQL数据库开发，充分保证了系统稳定性、完整性。
校园管理系统的设计与实现的设计思想如下：
1.操作简单方便、系统界面安全良好、简单明了的页面布局、方便查询相关信息。
2、即时可见：对校园管理系统信息的处理将立马在对应地点可以查询到，从而实现"即时发布、即时见效"的系统功能。
3、功能的完善性：可以管理管理员：首页、个人中心、院校管理、用户管理、单位类别管理、院校管理员管理、单位管理、通知推送管理、投票信息管理、通知回复管理。
用户；首页、个人中心、单位管理、通知推送管理、投票信息管理、通知回复管理。
院校管理员；首页、个人中心、用户管理、单位类别管理、单位管理、通知推送管理、投票信息管理、通知回复管理模块的修改维护操作。
运行截图： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2dfb9bf6b875954784b2ebbb38ea00c/" rel="bookmark">
			Selenium基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在学习爬虫的有关知识，发现一个很有意思的工具Selenium，所以打算花点时间看Selenium提供的手册来学习，为了防止以后忘记和方便复习，打算记录一下我的学习过程，我使用的Selenium版本是4.8.2。
目录
Selenium概述
网页操作
创建驱动会话
导航网页和关闭网页
刷新网页
退回上一页
前进下一页
查询与定位元素
获取元素信息
Actions接口交互
键盘操作
键盘按下和释放
键盘输入
键盘输入清除
键盘复制粘贴
鼠标操作
鼠标悬停
鼠标双击
单击并且长按住
单击并且瞬间释放
右键单击
长按拖动并释放
窗口操作
获取/设置窗口大小
获取/调整窗口位置
窗口大小格式设置
屏幕截图
关闭当前页面
获取窗口句柄
窗口 / 标签切换
Selenium概述 首先我们需要知道Selenium的功能和存在的价值：Selenium是一个自动化的测试工具，它用于帮助我们实现跨浏览器的自动化测试Web应用。我将理解为是通过提供一些工具帮助我们用编程语言自动化模仿浏览器的相关行为动作，其中我们常使用的API和协议是WebDriver。它定义了一个可以满足很多语言的接口，帮助我们实现浏览器应用程序的自动化测试，Selenium使用手册中对它的描述还提到：
WebDriver 不要求使用应用程序代码编译其 API, 因此它本质上不具有侵入性. 因此, 您测试的应用程序与实时推送的应用程序相同
在如何具体使用WebDriver之前手册还为我们提供了一些相关术语的介绍，这里我打算列一部分出来：
1、API：API是应用程序的编程接口，我们可以通过所提供的API来实现对WebDriver的控制和操作。
2、驱动程序（代理）：这个很重要（相当于驱动遥控车的遥控器），我们使用WebDriver控制浏览器之前，我们首先要确保浏览器是可以和我们进行对话，也就是需要使用一套程序来作为中介连接浏览器和我们的控制代码，这套程序就是驱动程序。
网页操作 创建驱动会话 一个最简单的打开网页操作共分为三部：
获取驱动对话导航到对应网页关闭对话 首先我们从selenium模块里面导入webdriver。调用webdriver里面的Edge方法创建Edge浏览器的驱动对象（如果是Firefox则调用Firefox的方法、是谷歌则调用Chrome方法...）
from selenium import webdriver
driver = webdriver.Chrome()
# driver = webdriver.Edge()
# driver = webdriver.Firefox()
导航网页和关闭网页 然后我们像requests模块一样调用get方法来导航到网页：
driver.get("https://baike.baidu.com/item/百度百科")
最后打开网页后记得将我们的驱动对话给关闭：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2dfb9bf6b875954784b2ebbb38ea00c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22428395e0ef03ce79c28508a77ee7d4/" rel="bookmark">
			Ubuntu、stm32下的C程序中堆、栈、全局、局部等变量的分配地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、变量介绍 1、全局常量：在程序中定义的全局范围内不可改变的常量，它们的值在整个程序执行过程中都保持不变。
2、全局变量：在程序中定义的全局范围内可改变的变量，它们可以在程序的任何位置被访问和修改。
3、局部变量：在函数或代码块中定义的变量，它们的作用域仅限于函数或代码块内部，在外部无法访问。
4、静态变量：在函数内或代码块内用 static 关键字修饰的变量，它们的生存期会延长到整个程序的执行过程中，但作用域仍然限于所在的函数或代码块内部。
5、堆：动态分配内存的一种方式，通过调用 malloc 或 new 等函数在运行时分配的内存空间。它的生命周期由程序员手动管理，需要显式释放。
6、栈：存储函数调用和局部变量的一块内存空间，它的管理由编译器自动完成，具有先进后出的特点。
二、变量的内存分配 栈区（stack）：指那些由编译器在需要的时候分配，不需要时自动清除的变量所在的储存区，如函数执行时，函数的形参以及函数内的局部变量分配在栈区，函数运行结束后，形参和局部变量去栈（自动释放）。栈内存分配运算内置与处理器的指令集中，效率高但是分配的内存空间有限。
堆区（heap）：指哪些由程序员手动分配释放的储存区，如果程序员不释放这块内存，内存将一直被占用，直到程序运行结束由系统自动收回，c语言中使用malloc，free申请和释放空间。
静态储存区（static）：全局变量和静态变量的储存是放在一块的，其中初始化的全局变量和静态变量在一个区域，这块空间当程序运行结束后由系统释放。
常量储存区（const）：常量字符串就是储存在这里的，如“ABC”字符串就储存在常量区，储存在常量区的只读不可写。const修饰的全局变量也储存在常量区，const修饰的局部变量依然在栈上。
程序代码区：存放函数体的二进制代码。
例子程序
//main.cpp int a = 0; //全局初始化区 int a = 0; //全局初始化区 char *p1; //全局未初始化区 main() { int b; //栈 char s[] = "abc"; //栈 char *p2; //栈 char *p3 = "123456"; //123456\0在常量区，p3在栈上。 static int c = 0; //全局（静态）初始化区 p1 = (char *)malloc(10); p2 = (char *)malloc(20); //分配得来得10和20字节的区域就在堆区。 strcpy(p1, "123456"); //123456\0放在常量区，编译器可能会将它与p3所指向的"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22428395e0ef03ce79c28508a77ee7d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/269c2ae59a1cd8776b9f9c151956596c/" rel="bookmark">
			组播路由协议——PIM基本概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
PIM基本概念
组播路由协议的作用
PIM与之前组播路由协议的区别
组播分发树
RFC机制
PIM两种工作模式
PIM的上游接口与下游接口
上游接口
下游接口
PIM邻居发现
Hello报文作用
DR的作用
PIMv2的其它类型报文
PIM基本概念 组播路由协议的作用 和单播路由协议类似，组播路由协议用于建立、维护组播路由，为组播网络生成一颗无环的组播分发树（组播流量在网络中的传输路径）进行组播数据转发。
PIM与之前组播路由协议的区别 PIM协议之前，使用的组播路由协议是DVMRP（距离矢量组播路由协议），MOSPF（组播OSPF协议）等，它们的特点都是需要依赖单播路由协议来进行工作，维护大量的拓扑数据库。
PIM称为协议无关组播路由协议（与单播协议无关的组播路由协议），不维护组播拓扑数据库，不能够自己直接画出组播拓扑。因此PIM通过利用单播路由表的路由信息进行组播报文RPF检查，创建组播路由表项，转发组播报文。目前流行PIMv2
组播分发树 组播分发树由组播路由协议生成，是组播流量在网络中的传输路径，主要分为两种类型
SPT 最短路径树，也成为源树
是以组播源为树根的组播分发树，组播组成员可以看为枝叶
源到组播成员的最短路径树
使用（S，G）表示，S代表组播源，G代表组播组地址。
每一个（S，G）表项都在网络中都对应了一颗独立的SPT
RPT 共享树
是以RP为树根的组播分发树，组播组成员可以看为枝叶，多个组播组可以共用一个RP
组播流量先从源发往RP，再从RP发往成员（此路径不一定是最优的）
主要使用（*，G）表示，也会使用到（S，G）表项。*代表的是任意组播源
注意：
一个（*，G）表项可以维护一个组播组（多个组播源）
一个（S，G）表项可以维护一个组播源
RFC机制 反向路径转发检测 是PIM协议中用于组播转发防环的核心手段
检测过程
路由器收到组播报文后，检查组播报文的源地址，然后在单播路由表中寻找此源地址的路由如果单播路由表中此源地址路由的出接口就是接收组播报文的那个入接口，则RPF检查成功否则RPF检查失败，报文被丢弃 PIM两种工作模式 PIM DM 密集模式
多应用于组播组成员相对较多、分布相对密集的局域网络环境中
PIM SM 稀疏模式
多应用在接收者分布较为分散、地域较大的环境
PIM的上游接口与下游接口 其中（S，G）、（*，G）表项是由上游接口和下游接口组成的（以下为S，G表项举例）
上游接口 也就是RPF接口，负责接收（S，G）组播流量的接口（完成了RPF检测）
对于每一个（S，G）表项来说，RPF接口有且只有一个去往组播源负载分担（单播路由表去往组播源的路由有多条），则选择下一跳地址大的接口为RPF接口RPF接口上的PIM邻居称为RPF邻居。如果RPF接口上存在多个PIM邻居，则邻居地址大的为RPF邻居 上游接口状态——根据上游接口的操作行为，会有不同的状态
Nolnfo（NI） 没有接口状态
Pruned（P） 已经向上游发送Prune报文
Forwarding（F） (S，G)下游接口非空时，组播报文从上有接口收到
AckPending（AP）已经发送Graft报文，等待GraftAck报文
下游接口 将组播流量发送出去的接口
即存在直连组成员的接口（有IGMP协议维护）以及存在PIM邻居的接口组播流量会通过下游接口进行扩撒 下游接口状态
Nolnfo（NI） 接口为正常接口，会一直转发组播数据（初始状态）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/269c2ae59a1cd8776b9f9c151956596c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30e729625ccc07a7775c18361d4c2c4a/" rel="bookmark">
			Android Studio 引入 aar 后 import 所需类时找不到
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		implementation 'io.github.sinaweibosdk:core:13.6.1@aar' 然后
import com.sina.weibo.sdk.openapi.IWBAPI; 发现前面都有，IWBAPI不可见。
aar改名为zip，把里边的 classes.jar解压出来，然后
jar jt classes.jar 可以看到：
com/sina/weibo/sdk/openapi/IWBAPI.class
说明有这个类。
方法1：此时点击Android Studio的“大象”按钮，即 Sync Project with Gradle Files，快捷键 Ctrl + Shift + O即可。
方法2：将aar复制到某个文件夹下，然后
implementation fileTree(dir: 'C:\\yourdir', include: ['*.aar', '*.jar'], exclude: []) 然后点同步按钮
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f21802f765fd447c6ea69e99565c002/" rel="bookmark">
			[年中总结]真正的精彩都在海里
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时间过得可真的是快啊,一眨眼就是六月底了
这半年的经历也是挺多彩
二月底的时候,跟老大提出了离职申请,经过 老大/hr/部门 leader 的谈话之后,依然决定离职
四月底拿到离职证明之后,就出去玩了一圈,六月份刚回来,哈哈哈哈
我不知道有没有人和我一样,非常在意能不能在一份工作中,获得成就感,获得个人成长
如果当前做的事情,因为各种原因拿不到结果,我会非常难受,睡觉都睡不好的那种;如果当前做的事情,只是重复以前的,对我个人能力没有提升,我也会非常难受
我讲不出来那种感受,但就是整个人都不开心
我的盖洛普报告也显示我有这样的倾向:
成就第三,非常在意一件事情能不能拿到成果,特别有达成欲
学习第四,非常在意能不能学到东西
我还记得刚加入公司的时候,因为对我来说是个新的领域,每天去上班路上都是开心的,计划今天要把 xx 搞定;那个问题好像 yy 遇到过,等去了公司要向他请教请教
为了能够尽快上手公司工作,那段时间几乎是部门里面到的最早的,走的最晚的,自己还乐此不疲,每天都是新知识,每天开心到爆炸,一度被同事吐槽太卷了
但是离职前的那一段时间,很难受
项目上没有很难的需求给到我让我去开发;每天大部分的时间,不是在给客户答疑,就是在和别的部门的人打交道,让别的部门的人帮忙搞一些东西
我非常想要拿结果,但因为很多事情不是我们部门自己就可以搞定的,所以就算很想拿,依旧拿不到
我非常想通过项目,通过解决问题,来提升个人能力,来让自己获得成长,但我当时所处的环境,没有那么多项目给我
那段时间每天上班前,都需要好几个闹钟才能把自己叫醒
我知道我在这家公司呆的没有那么开心了
思考再三之后,还是向公司提出了离职申请
担心肯定是担心过的,在裁员这个大环境下,主动提出离职申请,或许多多少少是有些离经叛道
但人总得逼一下自己,强制让自己脱离一下舒适区
离职的时候,部门 leader 和我谈话,他说我这个人还是挺靠谱的
得到部门 leader 这个评价,还是蛮开心的,哈哈哈哈
离职之后,就出去玩了一趟
去了 深圳/珠海/澳门/佛山/大理
一边玩,一边看书,一边思考
也体验到了以前不曾有过的体验
比如啊,这次旅行知道了关系建立靠前的人,真的是很看重关系
去找醒教练时,她问我,我介不介意去找她玩,她还工作,我说不介意,后来聊起这件事,我才知道,如果我说介意的话,那她就不会接咨询了,这个钱就算不赚也会在乎我的感受;
我记得有天晚上她做完咨询,从屋里跑出来,那个时候我和阿槿看完电影打算睡觉了,看她跑出来,很平淡的跟她说:做完咨询了?我都打算睡觉了,后来才知道她那天是打算陪我出去溜达的,但因为我想睡觉了,就算了,如果她不讲的话,我现在都不知道
有一种,原来有个人关心你,为你做了蛮多事情的,还没让你知道,没有负担
真不愧是关系建立靠前的人啊
我就不一样了,我如果为对方做了一些事情的话,就我这个嘴,叭叭的恨不得身边的人都知道,哈哈哈哈
比如啊,这次旅行知道了交往靠前的人,宠起人来真的不像话
四月份去找小师姐的时候,想着住她那里可能不方便,就自己在外面订了酒店,结果让我退了不说,还管接管送,明明自己工作挺忙的,还抽时间陪我出去逛
旅行过程中,因为醒教练认识了皮皮,跟她认识还没一个月,就开始送礼物给我;知道我喜欢天空,看到好看的,去露营的时候,都会想着给我拍照
新玲每天都提醒我:别睡了啊,好不容易出去一趟,出去玩啊
小姐姐买房之后,第一反应就是:回头装修完了,邀请你来跟我一起住啊
哈哈哈哈,被交往靠前的人放在心上,感觉不要太棒~
比如啊,这次旅行知道了影响力靠前的人,真的和我蛮不一样的
旅行过程中,认识了一位朋友,影响力靠前,一起吃饭的时候:璐璐,来尝尝这个;我:这个比较凉,不尝了;他:来嘛,来尝一尝嘛,就一口
醒教练跟我说,她有位影响力靠前的朋友有次跟她聊天:我这么喜欢你,我都不知道你喜不喜欢我;哈哈哈哈,当时听到真的觉得好好笑
影响力靠前的人,这么可爱~
在人群中,能觉察自己与他人的不同之处
而远离人群之后,更能看清自己
看清楚想要的是什么,愿意为此付出什么
我在旅行过程中,确定了对当下的我来说,最重要的两件事: 体验 &amp; 陪伴
确定之后,就没有那么担心,没有那么焦虑了
当下所经历的一切,何尝不是独一无二的体验呢
六月份回来之后,开启了吃了睡,睡了吃的模式,哈哈哈哈,我也不知道为什么,就是这么爱睡觉
最近的状态是,玩也玩够了,睡也睡够了,接下来就是一心一意准备找工作的事情了
最后用一句最近喜欢的鸡汤来结尾吧: 真正的精彩都在海里,而且岸上未必安全
以上
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a9cbff93dc959b2e3a74021e1d74fbb/" rel="bookmark">
			Google 新手机发布会：Android 14，「买手机，送 AI」
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者 | 芯芯
编辑 | 靖宇
美国当地时间 10 月 4 日上午 10 点，Google 在纽约举行「Made by Google」活动，Pixel 8、Pixel 8Pro、Pixel Watch 2、Pixel Buds 等硬件，以及最新的 Android 14 系统逐一曝光。
除了 Pixel 8 哑光磨砂后背和防爆盾造型的 5000 万像素摄像头，当天发布会最大的亮点，你能猜到的，就是 AI——Google 如何在旗舰手机上集成它的各种 AI 理念和功能，更让人好奇。
从超级无痕修图、画质修正再到 AI 生成壁纸，AI 渗透进了 Google 新手机和新系统中，每一个用户最熟悉和感知最强的功能之中。
699 美元的 Pixel 8 和 999 美元的 Pixel 8 Pro，仍然比苹果和华为最新的旗舰机要便宜不少，但是，Google Pixel 是真正的「买手机，送 AI」。
01
AI 功能入侵手机
新的 Pixel 8 系列手机，继承了 Pixel 系列一贯的设计风格，在外形上改动并不大。最大的改动一个是屏幕从上一代的曲面屏，变成了非曲面屏幕，同时背壳从玻璃变成了哑光磨砂材质，握持感更强。
同时，Google 升级了 Pixel 8 系列手机的屏幕，1-120Hz LTPO 刷新率让手机在玩游戏和浏览网页时画面更流畅，也更省电一些。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a9cbff93dc959b2e3a74021e1d74fbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52bfd8e3b000a603d9221afaaf32779b/" rel="bookmark">
			ImportError: C extension: No module named ‘pandas._libs.tslibs.conversion‘ not built.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我之前遇到如本文标题所示的PyCharm运行时报错，经网上查找，发现部分网友反馈Python安装的版本从32bit变成64bit时会遇到这个问题。而我确实是从Python 3.6 (32-bit)升级为Python 3.10 (64-bit)。
备注：Python v3.10.6 64bit无法安装在Win7或更早以前的Windows版本上。用官方的原话说就是：Note that Python 3.10.6 cannot be used on Windows 7 or earlier.
既然事已至此，遇到“ImportError: C extension: No module named ‘pandas._libs.tslibs.conversion‘ not built.”就想着找方法解决。我遇到的报错Log具体为：ImportError: C extension: No module named ‘pandas._libs.tslibs.conversion‘ not built. If you want to import pandas from the source directory, you may need to run 'python setup.py build_ext --inplace --force' to build the C extensions first.
python setup.py build_ext --inplace --force 如下图所示，报错：python: can't open file 'C:\\Windows\\system32\\setup.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52bfd8e3b000a603d9221afaaf32779b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe03e495e259788bdb3197e4f2fab173/" rel="bookmark">
			k8s-kubernetes--etcd的备份和恢复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.etcd介绍2.重新搭建集群环境3.etcd的备份4.etcd数据的恢复 1.etcd介绍 官方网址：https://etcd.io/docs/v3.6/op-guide/recovery/
k8s相关网址：https://v1-25.docs.kubernetes.io/zh-cn/docs/tasks/administer-cluster/configure-upgrade-etcd/#restoring-an-etcd-cluster
etcd拉起过程：
kubelet自动扫描/etc/kubernetes/manifests目录（如下图），如果发现.yaml文件自动拉起来
Etcd被形容为Kubernetes集群的大脑，是 Kubernetes的关键组件，因为它存储了集群的全部状态：其配置，规格以及运行中的工作负载的状态。
在Kubernetes世界中，etcd用作服务发现的后端，并存储集群的状态及其配置。
Etcd被部署为一个集群，几个节点的通信由Raft算法处理。在生产环境中，集群包含奇数个节点，并且至少需要三个。
以下来自Heptio博客的序列图显示了在简单的Pod创建过程中涉及的组件。它很好地说明了API服务器和etcd的交互作用。
2.重新搭建集群环境 由于在k8s高可用集群实验后做该实验，我们需要重新初始化集群环境
[root@k8s2 ~]# kubeadm reset
[root@k8s2 ~]# vim kubeadm-init.yaml ##去掉高可用实验时加入的负载均衡地址（25行左右）
[root@k8s3 ~]# kubeadm reset
[root@k8s4 ~]# kubeadm reset
k8s2作为control-plane执行初始化（如下图），然后在k8s3和k8s4节点执行生成的token使这两个节点加入集群即可
[root@k8s2 ~]# kubectl get node ##
NAME STATUS ROLES AGE VERSION
k8s2 Ready control-plane 90m v1.25.0
k8s3 Ready 89m v1.25.0
k8s4 Ready 89m v1.25.0
3.etcd的备份 所有 Kubernetes 对象都存储在 etcd 上。 定期备份 etcd 集群数据对于在灾难场景（例如丢失所有控制平面节点）下恢复 Kubernetes 集群非常重要。 快照文件包含所有 Kubernetes 状态和关键信息。为了保证敏感的 Kubernetes 数据的安全，可以对快照文件进行加密。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe03e495e259788bdb3197e4f2fab173/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34670a2a27b88294458ae57ce85286ef/" rel="bookmark">
			10.4：输入两个正整数m和n，求其最大公约数和最小公倍数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include &lt;head.h&gt; #include &lt;stdio.h&gt; int gcd(int m, int n) { if (n == 0) { return m; } return gcd(n, m % n); } int lcm(int m, int n) { return m * n / gcd(m, n); } int main(int argc, const char *argv[]) { int m, n; printf("Enter two positive integers: "); scanf("%d %d", &amp;m, &amp;n); printf("GCD: %d\n", gcd(m, n)); printf("LCM: %d\n", lcm(m, n)); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97fdab36eaa4087f2b9c6be3069e0cf6/" rel="bookmark">
			【大数据】Hive函数&#43;分区表和分桶表＋文件格式和压缩
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、函数1. 炸裂函数1.1 常用的UDTF1.2 Lateral View 2. 窗口函数（开窗函数）2.1 概述和语法2.2 常用窗口函数 3. 自定义函数4. 自定义UDF函数 二、分区表和分桶表1. 分区表1.1 分区表基本语法1.2 二级分区表 2. 分桶表2.1 分桶表基本语法2.2 分桶排序表 三、文件格式和压缩1. Hadoop压缩概述2. Hive文件格式2.1 Text File2.2 ORC2.3 Parquet 3. 压缩3.1 Hive表数据进行压缩3.2 计算过程中使用压缩 一、函数 1. 炸裂函数 UDTF（Table-Generating Functions），接收一行数据，输出一行或多行数据。
1.1 常用的UDTF explode(ARRAY&lt;T&gt; a) select explode(array(“a”,”b”,”c”)) as item; explode(MAP&lt;K,V&gt; m) select explode(map(“a”,1,”b”,2,”c”,3)) as (key,value); posexplode(ARRAY&lt;T&gt; a) select posexplode(array(“a”,”b”,”c”)) as (pos,item); inline(ARRAY&lt;STRUCT&lt;f1:T1,…,fn:Tn&gt;&gt; a) select inline(array&lt;named_struct(“id”,1,”name”,”zs”), named_struct(“id”,2,”name”,”ls”), named_struct(“id”,3,”name”,”ww”)) as (id,name); 1.2 Lateral View Lateral View通常与UDTF配合使用。Lateral View可以将UDTF应用到源表的每行数据，将每行数据转换伟一行或多行，并将源表钟每行的输出结果与该行连接起来，形成一个虚拟表。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97fdab36eaa4087f2b9c6be3069e0cf6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c456f12524f1f4189e625bf20b0d038/" rel="bookmark">
			简单两步实现离线部署ChatGPT，ChatGPT平替版，无需GPU离线搭建ChatGPT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文末附主程序安装包和大模型参数文件~
演示效果如下图所示：
一、使用方法 软件主要分为两个部分：GPT4ALL软件主体（主程序）+模型参数（离线模型），如果使用API Key的话则不需要下载模型参数。
可以从官网下载主程序安装包或者直接使用小编准备好安装包进行主程序安装（软件官网也在最后的链接中）。
1、主程序安装 以Windows为例，双击安装程序正常执行主程序安装即可，大概需要200MB左右的磁盘空间。
安装完成后，第一次进入主程序界面会出现两个隐私选项，为了保证个人隐私的安全，建议都选择【No】。
2、模型下载 选择完隐私选项后，大概率会自动弹出一个窗口，让我们选择一个模型进行下载，其中有红色字体的的模型表示不推荐下载，大概率是因为内存不满足模型运行的最低要求。这里最小的模型为GPT4ALL Falcon，该模型包含70亿参数，只需要8GB的可支配运行内存即可。
【注】：可支配内存为8G往往需要电脑的实际内存大于8G，总内存为8G的电脑可支配内存通常不足8G（维持操作系统运行要用掉一部分）。
别着急点击下载，据小编测试，使用国内网络大概率不能下载成功，并且直接在软件内部下载会有极大可能下载几MB后卡住不动，所以小编推荐在官网下载模型参数（官网地址见链接中文本文件），然后手动导入（GPT4ALL Falcon模型小编已经下载好放在最后的链接里了，大家下载后直接导入即可）。
官网下载模型方法：在官网下拉找到【Model Explorer】，从下拉框找到需要下载的模型然后点击右下角的下载按钮即可下载，推荐使用迅雷等下载软件下载，否则很可能下载到一半因链接中断需要重新下载。
模型文件的后缀名为【.bin】，将模型文件下载下来后，我们在主程序中点击【设置】按钮。
进入设置界面后，点击【Application】，在【Download path】按钮旁边有一个【Browse】按钮，用于选择模型默认下载路径，点击该按钮，然后选择模型文件所在的路径作为默认下载路径。
一般来说经过上述设置，主程序就可以自动识别模型，需要注意的是，尽量不要在模型存放路径中出现中文，否则很可能会在加载模型时出现类似下面这样的错误提示。
建议直接在D盘根目录创建一个名为【Model】的文件夹作为模型默认下载路径，然后直接将模型文件放在这个文件夹即可。
如此一来，就可以使用这款本地GPT为你完成一些简单的工作啦，经过小编测试，该离线版GPT响应速度还可以（和CPU性能有关，设置中可以调整线程数，线程数越多，使用的CPU资源越多，模型响应速度越快），并且具备编写代码的功能，可惜仅支持英文沟通，当你用中文描述问题时，模型会表示无法理解你的问题。
二、下载链接 见评论区
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90b401186843387db59ef142e8ff85d6/" rel="bookmark">
			时间序列 自回归差分移动平均模型 ARIMA
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、ARIMA是什么？
二、ARIMA的优点和缺点
三、ARIMA的应用场景
四、构建ARIMA模型的注意事项
五、ARIMA模型的实现类库
六、ARIMA模型的评价指标
七、类库statsmodels实现ARIMA的例子
八、ARIMA的模型参数
总结
前言 时间序列是在时间点上形成的数值序列，时间序列预测是通过观察历史数据预测未来的值。代表性的算法模型是ARIMA。
一、ARIMA是什么？ 自回归差分移动平均模型，又称ARIMA（Autoregressive Integrated Moving Average Model）模型，由AR、I、MA3部分构成。
AR：自回归，当前时间点上的数据被前K个时间点上的数据进行线性关系的解释。
I：差分，为了确保时间序列的数据是平稳的（建模需要），用当前时间点的数据减去K个时间点前的数据，实现差分转化，获得平稳的时间序列数据。
MA：移动平均。
ARIMA(p, d, q)：是对数据进行d阶差分，转化数据为平稳时间序列之后，结合AR(p)和MA(q)的时间序列模型。AR(p)是P项自回归，MA(q)是q项的移动回归。此外，ARMA(p, q)是自回归AR(p)和移动平均MA(q)的组合模型。
二、ARIMA的优点和缺点 1. 优点： 模型简单，容易实现；只需要内生变量，需要借助其他变量能够对线性和非线性趋势进行建模能够对季节性进行建模能够对残差进行建模，从而检查是否存在自相关性 2. 缺点： 对于非线性趋势或非常复杂的时间序列，ARIMA模型可能无法很好地拟合数据ARIMA模型需要大量的数据才能有效地进行建模和预测ARIMA模型中需要手动选择参数，这可能需要一定的专业知识和经验 三、ARIMA的应用场景 ARIMA（自回归综合移动平均模型）是一种常见的时间序列分析模型，其应用场景包括但不限于以下几个方面：
经济预测：ARIMA可以用于经济预测中，如股票价格预测、通货膨胀率预测等。销售预测：ARIMA可以用于销售预测中，如商品销售量预测、市场需求预测等。交通流量预测：ARIMA可以用于交通流量预测中，如道路拥堵预测、公交车运营时间预测等。气象预测：ARIMA可以用于气象预测中，如气温预测、降雨量预测等。能源需求预测：ARIMA可以用于能源需求预测中，如电力需求预测、石油需求预测等。信号处理：ARIMA可以用于信号处理中，如语音信号处理、音频信号处理等。负载预测：ARIMA可以用于负载预测中，如服务器负载预测、网络流量预测等。人口统计学：ARIMA可以用于人口统计学中，如人口增长预测、人口迁移预测等。环境监测：ARIMA可以用于环境监测中，如空气质量预测、水质预测等。 总之，ARIMA是一种非常常用的时间序列分析模型，可应用于多种领域，特别是需要进行时间序列数据分析和预测的场景下。
四、构建ARIMA模型的注意事项 时间序列建模需要数据具有平稳性，即均值函数是常数且协方差函数仅与时间差相关。可以通过ACF、PACF、ADF(单位根检验)进行验证。 在对ARIMA进行定阶（p，q）时，可以确认自相关系数ACF和偏自相关系数PACF的拖尾和截尾情况，p依据的是PACF的截尾阶数，q则依据的是ACF的截尾阶数，如果ACF和PACF均为拖尾，则可以通过AIC和BIC进行定阶。对于模型拟合的结果，可以通过确认残差分布是否是白噪声序列来验证模型的参数是否得当。（白躁声：是由一组均值为0，方差不变，相互独立的元素构成，各元素之间没有相关性。建模的时间序列数据要求是非白噪声序列。） 另外，时间序列除了ARIMA的回归模型外，还有时间序列的分解算法，比如：prophet模型 一个时间序列通常由长期趋势(T:Trend)、季节变动(S:Season)、循环波动(C:Cyclical)和不规则波动(I:Irregular)叠加或耦合。 T：较长时期内持续性发展变化的一种趋向或状态。S：由于季节的变化引起的发展水平的规则变动。C：以若干年为期限，不具有严格规则的周期性连续变动。I：由于众多偶然因素对时间序列造成的影响。 五、ARIMA模型的实现类库 Python中有多个库可以实现ARIMA，以下是其中比较常用的几个库：
statsmodels：statsmodels是Python中的统计分析库，其中包含了ARIMA模型。Keras：Keras是一个高级神经网络API，可以在多个深度学习框架上运行，其中也包含了ARIMA。 以上这些库都提供了丰富的接口和功能，可以满足不同场景下的需求。需要注意的是，在使用这些库时，需要根据具体情况选择合适的模型、参数和评估指标，以获得更好的预测效果。
六、ARIMA模型的评价指标 赤池信息量（AIC）：衡量统计模型拟合优良性的一种标准，基于信息熵，对自变量个数施加惩罚，AIC越小，模型越好。贝叶斯信息量（BIC）：衡量模型拟合优良性的一种标准，基于贝叶斯概率函数，对自变量个数施加惩罚，BIC越小，模型越好。均方根误差（RMSE）：衡量模型预测值与实际值之间的平均差异，RMSE越小，表示模型预测效果越好。平均绝对误差（MAE）：衡量模型预测值与实际值之间的平均差异，MAE越小，表示模型预测效果越好。平均绝对百分比误差（MAPE）：衡量模型预测值与实际值之间的平均百分比误差，MAPE越小，表示模型预测效果越好。对称平均绝对百分比误差（SMAPE）：衡量模型预测值与实际值之间的对称平均百分比误差，SMAPE越小，表示模型预测效果越好。 七、类库statsmodels实现ARIMA的例子 import pandas as pd import numpy as np import matplotlib.pyplot as plt from statsmodels.tsa.arima.model import ARIMA # 加载数据 df = pd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90b401186843387db59ef142e8ff85d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/652337835d8a3499f89c69cb8ef4303a/" rel="bookmark">
			上传、下载huggingface仓库文件（模型、数据等）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载 例如，想要从huggingface hub下载llama-13b模型文件到本地：
可以用如下命令，local_dir就是你想要下载到的本地文件夹：
from huggingface_hub import snapshot_download snapshot_download(repo_id="decapoda-research/llama-13b-hf",cache_dir="./cache", local_dir="./model_weights/llama-13b-hf") 上述命令等价于git clone，更多参数, 例如过滤、指定文件，建立符号链接等，详见官网教程:
Download files from the Hub 上传 想要上传文件，例如模型权重的话，首先得找到自己huggingface hub的access code：
然后将自己的access code设置到自己的机器上：
pip install huggingface_hub ## 如果没有安装huggingface_hub库 python -c "from huggingface_hub.hf_api import HfFolder; HfFolder.save_token('MY_HUGGINGFACE_TOKEN_HERE')" 最后用如下命令，把相关文件（模型、tokenizer）上传就行（等价于git push）。
pt_model.push_to_hub("my-awesome-model") # 这里的my-awesome-model就是你仓库的名字（用户名+仓库名），例如“Reza8848/MUFFIN-T5-3B” tokenizer.push_to_hub("my-awesome-model") 注意，如果遇到类似于TypeError: create_repo() got an unexpected keyword argument 'organization'的报错，需要把huggingface hub的版本更新：
pip install transformers==4.24.0 pip install --upgrade huggingface_hub # 确保更新huggingface hub到最新版本 python -c "from huggingface_hub.hf_api import HfFolder; HfFolder.save_token('MY_HUGGINGFACE_TOKEN_HERE')" # 记得重新再设置一次access token 之后再上传模型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/652337835d8a3499f89c69cb8ef4303a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35fb556db255d4075b1151823024a1e3/" rel="bookmark">
			第二届全国高校计算机技能竞赛——C&#43;&#43;赛道 题解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Powered by:NEFU AB-IN
Link
文章目录 第二届全国高校计算机技能竞赛——C++赛道A 互不侵犯题意思路代码 B 奖学金题意思路代码 C 领导者题意思路代码 D 空调题意思路代码 E 字符操作变换题意思路代码 第二届全国高校计算机技能竞赛——C++赛道 A 互不侵犯 题意 在象棋中，车可以攻击和他同一行同一列的棋子。
现在有一个放置了若干个车的 n × n n\times n n×n的棋盘，请问这个棋盘中车此时能相互攻击吗？能输出"YES"，不能输出"NO"。
棋盘中只有车，有车的位置用 1 1 1表示，没有车用 0 0 0表示。
思路 模拟，一开始理解错题意了，其实是能挨着就行
代码 /* * @Author: NEFU AB-IN * @Date: 2023-09-28 19:01:05 * @FilePath: \Contest\a\a.cpp * @LastEditTime: 2023-10-05 18:14:53 */ #include &lt;bits/stdc++.h&gt; using namespace std; #define int long long #undef int #define SZ(X) ((int)(X).size()) #define ALL(X) (X).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35fb556db255d4075b1151823024a1e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6500646233ef16f4d0ea5f92622438fc/" rel="bookmark">
			Linux系统编程系列之线程的信号处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux系统编程系列（16篇管饱，吃货都投降了！） 1、Linux系统编程系列之进程基础
2、Linux系统编程系列之进程间通信(IPC)-信号
3、Linux系统编程系列之进程间通信(IPC)-管道
4、Linux系统编程系列之进程间通信-IPC对象
5、Linux系统编程系列之进程间通信-消息队列
6、Linux系统编程系列之进程间通信-共享内存
7、Linux系统编程系列之进程间通信-信号量组
8、Linux系统编程系列之守护进程
9、Linux系统编程系列之线程
10、Linux系统编程系列之线程属性 11、Linux系统编程系列之互斥锁和读写锁
12、Linux系统编程系列之线程的信号处理
13、Linux系统编程系列之POSIX信号量
14、Linux系统编程系列之条件变量
15、Linux系统编程系列之死锁
16、 Linux系统编程系列之线程池
一、为什么要有线程的信号处理 由于多线程程序中线程的执行状态是并发的，因此当一个进程收到一个信号时，那么究竟由进程中的哪条线程响应这个信号就是不确定的，只能取决于哪条线程刚好在信号达到的瞬间被调度，这种不确定性在程序逻辑中一般是不能接受的。
二、解决办法 1、在多线程进程中选定某条线程去响应信号
2、其余线程对该信号进行屏蔽
三、相关函数API接口 1、发送信号给指定线程 // 在进程内部，只允许在线程之间进行发送 int pthread_kill(pthread_t thread, int sig); // 接口说明 返回值：成功返回0，失败返回错误码 参数thread：接收信号的线程号 参数sig：待发送的信号 // 在进程之间进行的信号发送 int kill(pid_t pid, int sig); // 接口说明 返回值：成功返回0，失败返回-1 参数pid：接受信号的进程号 参数sig：待发送的信号 2、发送带参数的信号给指定线程 // 发送带参数的信号给指定线程 // 线程间 int pthread_sigqueue(pthread_t thread, int sig, const union sigval value); // 接口说明 返回值：成功返回0，失败返回-1 参数thread：待接收信号的线程号 参数sig：待发送的信号 参数value：额外携带的参数 // 进程间 int sigqueue(pid_t pid, int sig, const union sigval value); // 接口说明 返回值：成功返回0，失败返回-1 参数pid：待接收信号的进程号 参数sig：待发送的信号 参数value：额外携带的参数 3、屏蔽指定信号 // 屏蔽指定信号 int sigprocmask(int how, const sigset_t *set, sigset_t *oldset); // 接口说明 返回值：成功返回0，失败返回-1 // 参数解析： 1、how：操作命令字，比如阻塞、解除阻塞等 SIG_BLOCK：阻塞set中的信号（原有正在阻塞的信号保持阻塞） SIG_SETMASK：阻塞set中的信号（原有正在阻塞的信号自动解除） SIG_UNBLOCK：解除set中的信号 2、set：当前要操作的信号集 3、oldset：若为非空，则将原有阻塞信号集保留到该oldset中 注意：该函数的操作参数不是单个信号，而是信号集。 // 信号集操作函数组 int sigemptypset(sigset_t *set); // 清空信号集set int sigfillset(sigset_t *set); // 将所有信号加入信号集set中 int sigaddset(sigset_t *set, int signum); // 将信号signum添加到信号集set中 int sigdelset(sigset_t *set, int signum); // 将信号signum从信号集set中剔除 int sigsimember(const sigset_t *set, int signum); // 测试信号signum是否在信号集set中 四、案例 1、使用线程结合信号的方式完成数据的接收和发送，要求一条线程发送数据同时发送信号指定某条线程接收数据，另外有多余线程做伪任务。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6500646233ef16f4d0ea5f92622438fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73bdcb286342d1ff00053b911e675824/" rel="bookmark">
			Vue中如何进行代码编辑器与实时预览
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当在Vue项目中需要实现代码编辑器与实时预览功能时，通常会使用一些前端库来简化这个任务。本文将介绍如何在Vue中使用CodeMirror和Vue.js来实现代码编辑器与实时预览功能。我们将首先介绍CodeMirror和Vue.js的基本概念，然后演示如何将它们结合起来创建一个实用的代码编辑器和实时预览功能。
1. 什么是CodeMirror？ CodeMirror是一个流行的开源JavaScript代码编辑器库，它提供了丰富的编辑器功能，如语法高亮、代码折叠、智能缩进等。CodeMirror易于集成到Vue项目中，并且可以用来创建代码编辑器组件，让用户能够轻松地编辑代码。
要在Vue项目中使用CodeMirror，首先需要安装它。在项目目录中运行以下命令：
npm install codemirror 然后，可以在Vue组件中引入CodeMirror并使用它来创建代码编辑器。
2. 创建CodeMirror代码编辑器组件 首先，让我们创建一个名为CodeEditor.vue的Vue组件，用于包装CodeMirror代码编辑器。
&lt;template&gt; &lt;div&gt; &lt;textarea ref="editor"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import 'codemirror/lib/codemirror.css'; import 'codemirror/theme/material.css'; import 'codemirror/mode/javascript/javascript.js'; import CodeMirror from 'codemirror'; export default { props: { value: String, }, mounted() { const editor = CodeMirror(this.$refs.editor, { mode: 'javascript', theme: 'material', lineNumbers: true, }); editor.setValue(this.value); editor.on('change', () =&gt; { this.$emit('input', editor.getValue()); }); }, }; &lt;/script&gt; 上面的代码创建了一个包含CodeMirror编辑器的Vue组件，它接受一个名为value的prop，用于传递初始代码。组件在mounted钩子中初始化CodeMirror编辑器，并通过v-model绑定实时更新的代码。
3. 创建实时预览组件 现在，我们将创建另一个Vue组件，用于显示实时预览。让我们创建一个名为Preview.vue的组件：
&lt;template&gt; &lt;div&gt; &lt;iframe ref="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73bdcb286342d1ff00053b911e675824/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79506af1a30180cb7fbf312fdb060924/" rel="bookmark">
			IDEA 将一个普通Java工程转化为maven工程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打开IntelliJ IDEA并打开Java工程。
在项目窗口中，右键单击项目名称，选择“Add Framework Support”。
在弹出的窗口中，选择“Maven”。
在“Maven Information”窗口中，填写Group Id、Artifact Id和Version等基本信息。
点击“Finish”按钮，IntelliJ IDEA会自动创建一个pom.xml文件并将Java工程转化为Maven工程。
注意：在转化过程中，如果遇到版本冲突等问题，需要手动修改pom.xml文件，以确保项目能够正常构建和运行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52940a5c7ab9b6a27223b3a9578c298b/" rel="bookmark">
			CubeIDE使用国产版ST-Link/V2升级固件失败（已解决）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文末有总结。
网上买了一个新的ST-Link，想用来下载/调试程序，但是CubeIDE说我的ST-Link的固件版本太老，要强制升级，不升级不让用。但是呢，每次升级固件都失败。出现了以下的情况，让我很恼火。
在CubeIDE里点击Help -&gt; ST-Link Upgrade，出现下面的画面。正常来说按照顺序依次点击下面的标号就可以更新了。
注意看，我现在的版本时V2J37S7，需要更新到的版本是V2J42S7。
但是出现了状况
它的提示是这样的：先说更新失败，请再次尝试。然后说更新成功。
版本那里，也变成了V2J42S7。
但是这时去启动下载/调试，还是说ST-Link的固件版本太低。
回来一看，版本仍然是V2J32S7。
就是说，虽然它最后提示更新成功了，但是实际上是更新失败的。
重复多次，结果都是一样。
我向其他人借了一个ST-Link，使用同样的方法来进行操作，发现可以更新。基本上可以确定，问题出在ST-Link上面。
所以我将两个ST-Link都拆开了。（两个ST-Link都是盗版的）
把后面的标签撕掉，把两颗螺丝拆掉，就可以顺利拆开了。
最后发现，不能更新固件的ST-Link的芯片是CKSF103C8T6，
可以更新固件的ST-Link的芯片是STM32F103C8T6
猜测是前两年ST的芯片价格大涨，所以那时候生产的国产ST-Link就使用了价格较为便宜的国产芯片替代，在刚刚推出的时候是可以使用的（否则也不会上市），但是随着ST-Link的固件升级，国产芯片的ST-Link就更新不了固件了。
查了一些资料，CKSF103C8T6是【无锡中科芯】的产品。正常来说CKSF103C8T6是可以兼容STM32F103C8T6的。但是现在确实是出现了问题。
两款产品的Flash容量都是64KB，有可能是ST-Link最新的固件包大小在64KB附近，而CKSF103C8T6的实际有效Flash容量小于64KB，导致无法升级固件。
另外说一句，使用CKSF103C8T6芯片的ST-Link可以给板子供电。而使用STM32F103C8T6芯片的ST-Link不可以给板子供电。
而正版的ST-Link，是不能给板子供电的。
刚好手上也有一个JLINK V9，干脆一起拆了，看一下里面的芯片是什么。
图片上看不清（吐槽一下苹果手机，拍照的对焦能力是真的弱，相册系统是真的难用）。
芯片是STM32F205RCT6。性能是高于STM32F103C8T6的。
总结：不能升级固件的ST-Link的芯片是CKSF103C8T6，而芯片是STM32F103C8T6的ST-Link可以正常升级固件。
换一个芯片是STM32F103C8T6的ST-Link即可。
或者将原来的ST-Link的芯片升级一下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/380027a6f718717628679b7b16204967/" rel="bookmark">
			关于升级到win11触摸板只有点击功能这件事
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 觉得win11有触摸板手势功能太牛了，有一种想升级的念头（搞半天现在才知win10貌似也可以。。。）。结果当然就升级成win11了，但发现有一堆问题，例如：输入法字体太小......
然后想尝尝win11触摸板手势的味道，结果划了半天，无效。。。才有了这篇文章。
解决 由于发现只有点击功能，于是就百度，于是乎，找到了以下文章。
解决 win11 笔记本触摸板失灵/仅能点击，不能双指手势滑动/非联想驱动_MaverickJohnny的博客-CSDN博客
HID与IO接口驱动可以到各自电脑官网下，以下是我电脑官网驱动。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96dd368de70d39006dbe371ce8d3ac07/" rel="bookmark">
			HAL库自学笔记（一）——点亮LED
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、STM32CubeMX配置 STM32CubeMX配置如下：
（一）芯片选型及调试模式 本次实验设备选用野火开发板指南者，芯片型号STM32F103VET6。
Debug选用serial wire
（二） 时钟配置 使用高速时钟， Crystal/Ceramic Resonator（石英/陶瓷谐振器）
将系统时钟配置为72Mhz
（三）gpio配置 打开原理图，可知PB5，PB0，PB1分别对应红绿蓝灯，且低电平亮，高电平灭。
分别配置gpio，下面仅给出PB5配置，PB0，PB1同理。
此处配置输出模式，GPIO_Output。
GPIO Output level：默认电平，因为开发板低电平点亮，默认配置为高电平
GPIO mode：输出模式，有推挽输出和开漏输出两周，这里随意，用推挽输出。
GPIO Pull-up/Pull-down：上拉或下拉，推挽输出没有上下拉，这里配置 no pull-up and no pull-down。
Maximum output speed：最大输出速度，这里是高低电平切换速度，配置为High。
User Label：用户标签，就是重命名，给一个用户想要的名字，这里给LED_R表示该gpio控制红灯。
（四）生成代码 给此项目命名，选择合适的IDE
我习惯生成所有库的内容以适应以后的扩充，生成的文件有独立的.c和.h后期更好修改，如下：
最后点击generate code即可，生成代码如下：
二、点亮LED （一）调试设置 刚配置完的代码还不能直接使用，需要修改编译器的一些设置，首先在Debug里面修改烧录器选项
当SW Device有一个小标记出现时，说明连接上了单片机。
此时可以编译了，点击F7或者向下箭头，0 error 0 warning
（二）宏定义 可以在gpio.h中定义一些对LED的操作，如亮灭，翻转等
（三）主函数调用 此时，简易流水灯已经做好
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/160222350edcf8029e254d79c5394b72/" rel="bookmark">
			MyBatisPlus（九）模糊查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明 模糊查询，对应SQL语句中的 like 语句，模糊匹配“要查询的内容”。
like /** * 查询用户列表， 查询条件：姓名包含 "J" */ @Test void like() { String name = "J"; LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;(); wrapper.like(StringUtils.hasText(name), User::getName, name); List&lt;User&gt; users = mapper.selectList(wrapper); log.info(users.toString()); } notLike /** * 查询用户列表， 查询条件：姓名不包含 "J" */ @Test void notLike() { String name = "J"; LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;(); wrapper.notLike(StringUtils.hasText(name), User::getName, name); List&lt;User&gt; users = mapper.selectList(wrapper); log.info(users.toString()); } likeLeft /** * 查询用户列表， 查询条件：左模糊查询，姓名以 "e" 结尾 */ @Test void likeLeft() { String name = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/160222350edcf8029e254d79c5394b72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ca75e6a58f8fd5dddb7c1750eaf148d/" rel="bookmark">
			VS2019的各种使用问题及解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.scanf报错的问题2.运行窗口一闪而过的问题3.调试时提示缺少urctbased.dll文件而无法打开运行窗口的问题4.vs编译器如何显示行号的问题5.使用vs编译器如何自定义命令栏6.自定义vs2019命令时如何添加分割线分隔线7.使用vs2019如何在不给源代码的情况下，使用其中的内容（静态库）8.修改命令选项快捷键9.vs启动程序后，控制台黑框卡住不动10.vs修改文件编码格式 该篇是我总结我使用vs2019遇到的问题和一些小操作的博客。闲话少说，下面进入正题。
1.scanf报错的问题 这里只提供一种一劳永逸的方法。
首先找到vs的安装路径，一般情况下是：
C:\ProgramFiles(x86)\MicrosoftVisualStudio\2019\Community\Common7\IDE\VC\VCProjectItems
找到文件newc++file.cpp，由于修改所在文件夹的内容需要管理员权限，更方便的一种办法是，将该文件拖到桌面上，再进行修改，然后再拖回文件夹即可。
修改时，将该语句#define_CRT_SECURE_NO_WARNINGS 1（可在错误列表窗口中复制）添加在文件内。
2.运行窗口一闪而过的问题 可以选择执行不调试按钮
右击解决方案名称，点击最后的属性
然后依次点击左侧链接器，系统，右侧子系统中选择控制台。
该问题在最新版vs2019已修复，默认为控制台选项。
3.调试时提示缺少urctbased.dll文件而无法打开运行窗口的问题 首先请看自己的两个路径（现在大多都是64位电脑），
C:\Windows\sysytems32C:\Windows\SysWOW64 两个文件夹内都应有各自的ucrtbased.dll文件，如果有缺少可以到下方下载（注意不要混淆），据说是因为卸载软件时会导致这个问题，不过不要怕很简单的。认识我的可以单独联系我私发，小比特也行。
如果两个都有的话，还是不行请看下列方法。
那么我们依然还是老方法，右击项目名称，选择最下方的属性，然后找到C/C++，选择代码生成，到右侧点击运行库。
看看你是多线程调试DLL(/MDd)还是多线程调试DLL(/MD)，然后分别选择相应的多线程调试(/MTd)或者多线程(/MT)。
然后就可以啦。
4.vs编译器如何显示行号的问题 在最上方的菜单栏，找到偏后面的“工具”一项，然后在点下面的“选项”。
在选项内容下，依次点击下列红框标记的内容就行。
值得一提的是，如果在c/c++文件内就选择C/C++。
5.使用vs编译器如何自定义命令栏 我们都知道要调试，看内存，监视的时候，还要去到最上方的命令栏去找，太麻烦。不然就是记住快捷键。现在我们可以把这些按钮都集中到工具栏里，例如
方法就是，在工具栏右键点击最下方自定义，然后选择右方的新建，
点击新建后会让你输入工具栏名称，注意这里只有一次机会，以后没有重命名的选项，所以如果有需要的话可以想想。
新建成功后会在上方出现一个空白的小块如左边用于拖动该工具块，右边的点击后可以进行添加，然后会跳转到该页面
随即到了添加命令的页面，类别可以参考编译器最上方命令栏的归类。这样就很方便啦
6.自定义vs2019命令时如何添加分割线分隔线 就是像如下图这样，软件自带的每组“按钮”的分割线。笔者之前也找了好久都没找到。
自定义命令的界面如下图，怎么添加这么一行的分割线呢？
本来是没有分割线的，我们先选中一个想在其之前添加分割线的命令“按钮”，点击右侧的修改所选内容，勾选如下图的“开始一组”，就在其之前出现了一条分割线。
7.使用vs2019如何在不给源代码的情况下，使用其中的内容（静态库） 首先当我们写好.c和.h文件时。
单击项目属性，在配置属性这里的常规中，右侧找到配置类型，选择静态库，点击确定后。
注意系统的选择，调试Debug那里也必须更改成相应的平台，不无法生成文件夹！
我们再去运行一下，当然肯定时运行不了的，因为我们没有主程序。这里他会提示一个窗口，
我们在代码存储路径里，第一级Debug里找到函数.lib文件，将其连同函数.h，文件一同发给购买者。（头文件不带也行）
.lib文件打开是这个样子的，看不出源代码的。
ok，现在切换到使用者模式，我们把对方给我们的.lib和.h文件都放到我们主程序test.c所在的文件夹里，这样我们再在test.c文件里加一句，
//导入静态库 #pragmacomment(lib,”Add.lib”) 加上这条导入静态库的语句就可以啦。
8.修改命令选项快捷键 点击工具，然后是选项，
选择左侧环境中的键盘，在右侧显示命令包含中输入要修改的命令，
在下方选择框中一个一个选择，直到找到具有快捷键功能的那个（一般想要修改的就是那个），可以移除也可以不移除。
下方新快捷键处输入想要的快捷键，并在下方查看是否已经被使用，点击分配即可。
9.vs启动程序后，控制台黑框卡住不动 有时运行vs的控制台应用程序，控制台上什么都没有，卡住阻塞住。
此时鼠标右键单击控制台窗口。
控制台的暂停与运行分别由鼠标左键和右键控制。你可能不小心点击鼠标左键；或者你之前点击了鼠标左键，其windows缓冲区还保存着鼠标左键点击的消息，下次运行就会被读取；又或者是vs 未完成加载数据，此时你已经按下了运行。
10.vs修改文件编码格式 修改文件编码的功能被vs默认隐藏起来了，需要先打开。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c2d0fb33340433df7179a0206cf3d46/" rel="bookmark">
			神码ai伪原创【php源码】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 大家好，本文将围绕python绘制烟花特定爆炸效果展开说明，python炫酷烟花表白源代码是一个很多人都想弄明白的事情，想搞清楚html代码烟花特效python需要先了解以下几个事情。
火车头采集ai伪原创插件截图：
以下是一个绘制烟花效果的 Python 代码示例，使用了 Pygame 库来实现图形界面和动画效果：
import pygame import random # 初始化 Pygame pygame.init() # 设置窗口大小 size = (700, 500) screen = pygame.display.set_mode(size) # 设置窗口标题 pygame.display.set_caption("烟花效果") # 设置颜色 white = (255, 255, 255) # 用于存储烟花粒子的列表 particles = [] # 定义粒子类 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7844583d5d40ce89632407e1441bb412/" rel="bookmark">
			2023蓝桥杯C&amp;C&#43;&#43;大学A组试题A幸运数暴力解法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; int count=0; int main() { for(int i=1;i&lt;100000000;i++) { int x=0,y=0; vector&lt;int&gt;a; int num=i; while(num&gt;0) { a.push_back(num%10); num=num/10; } if(a.size()%2==0) {	for(int i=0;i&lt;(int)a.size()/2;i++) { x=x+a[i]; y=y+a[i+a.size()/2]; } if(x==y) { count++; } } } cout&lt;&lt;count;//4430091 return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/176635c6238c875e6cc02d5c9ef0e35a/" rel="bookmark">
			输入两个正整数m和n，求其最大公约数和最小公倍数 2023.10.4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include&lt;stdio.h&gt; #include&lt;string.h&gt; int main(int argc, const char *argv[]) { int n,m,temp; printf("请输入n"); scanf("%d",&amp;n); printf("请输入m"); scanf("%d",&amp;m); int sum=n*m; while(m*n!=0) { temp=m%n; m=n; n=temp; } printf("最大公因数为%d\n",m); printf("最小公倍数为%d\n",(sum/m)); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06f63228fc74da2c6486628646013060/" rel="bookmark">
			IDEA快速插入当前日期时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有时候我们想要快速使用当前日期时间字符串，但自己太麻烦了，可以利用idea的模板功能实现：
选择 Edit variables 配置变量的表达式：
选择idea提供的函数，系统中获取日期（年月日） date() 和时间（时分秒） time()的表达式，括号里起始没显示默认格式，默认格式是 date("yyyy/MM/dd") 和 time("hh:mm") ，可以自定义日期和时间格式如 date("yyyy-MM-dd") 和 time("HH:mm:ss")。
测试效果
有时候我们想要快速使用当前日期时间字符串，但自己太麻烦了，可以利用idea的模板功能实现：
选择 Edit variables 配置变量的表达式：
选择idea提供的函数，系统中获取日期（年月日） date() 和时间（时分秒） time()的表达式，括号里起始没显示默认格式，默认格式是 date("yyyy/MM/dd") 和 time("hh:mm") ，可以自定义日期和时间格式如 date("yyyy-MM-dd") 和 time("HH:mm:ss")。
测试效果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f41493ec5f015c3d3e86e38efc1e4c22/" rel="bookmark">
			输入一个日期，包括年、月和日，计算该日期是这一年的第几天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：输入一个日期，包括年、月和日，计算该日期是这一年的第几天。
思路：输入年月日之后，这是这一年中的第几天 = 之前月数的总天数+当月的日子
先想一下如果是手动算的话需要怎么算？
通常的年份的2月份都是28天，如果是闰年，闰年的2月份是29天。
比如输入一个2022-10-13
计算应该是：1（31）+2（28或者29天）+3（31）+4（30）+5（31）+6（30）+7（31）+8（31）+9（30）+13
比如输入一个2022-07-13
计算应该是：1（31）+2（28或者29天）+3（31）+4（30）+5（31）+6（30）+13
比如输入一个2022-03-13
计算应该是：1（31）+2（28或者29天）+13
可以看到这个是一个月份的累加，中间没有间断，如果要计算10月的就要从1月加到9月。
这个适合python中的 range()函数，然后里面是一个循环的累加
方法1：
# date=input("请输入年月日(格式举例:2000-01-05):") year=int(date[:4]) month=int(date[5:7]) day=int(date[8:10]) f_run=[31,28,31,30,31,30,31,31,30,31,30,31] #通常的年的每个月的天数 tall_day=0 #判断年是否闰年？ if (year%4==0 and year%100!=0 or year%400==0) and month&gt;2: for i in range(month-1): tall_day+=f_run[i] tall_day+=1 #如果是闰年并且是3月份以后，需要增加1天 else: for i in range(month-1): tall_day+=f_run[i] tall_day+=day print(date+"是当年的第"+str(tall_day)+"天") 例子：输入：2020-04-19，输出：110天
输入：2022-02-03，输出：34天
输入：2022-03-15，输出：74天
输入：2000-03-01，输出：61天
方法2： 通过datetime库函数实现
import datetime date=input("请输入年月日(格式举例:2000-01-05):") year=int(date[:4]) month=int(date[5:7]) day=int(date[8:10]) date1 = datetime.date(year=int(year), month=int(month), day=int(day)) date2 = datetime.date(year=int(year), month=1, day=1) tall_day = (date1 - date2).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f41493ec5f015c3d3e86e38efc1e4c22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b60e18bf44db15a2ecf21daf6f8c855/" rel="bookmark">
			实现模拟浏览器环境操作_jsdom的安装和解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 环境安装: 1.nodejs开发环境(自行安装node) 去官网:(最好下载最新版)
检查: cmd--&gt;node -v 出现版本号就是安装好了! 2.安装npm 检查: cmd--&gt;npm -v 出现版本号就是安装好了! 3.安装jsdom (nodejs中的一个模块,用nodejs实现的用于测试虚拟浏览器) 步骤: 1.用管理员方式进入cmd npm install node-gyp@latest 解析: 具体来说： npm install 是告诉 npm 去安装一个包。 node-gyp 是你想要安装的包名。node-gyp 是一个跨平台命令行工具，用于在 Node.js 环境中编译原生插件模块。 @latest 是一个标签，表示你希望下载该包的最新版本。 安装成功如图: 2. 全局安装jsdom npm install jsdom -g 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d16bb68f9e78ffcf5a544a1d1d5bbfc/" rel="bookmark">
			在排序数组中查找元素的第一个和最后一个位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。
如果数组中不存在目标值 target，返回 [-1, -1]。
你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。
示例 1：
输入：nums = [5,7,7,8,8,10], target = 8 输出：[3,4] 示例 2：
输入：nums = [5,7,7,8,8,10], target = 6 输出：[-1,-1] 示例 3：
输入：nums = [], target = 0 输出：[-1,-1] 思路 寻找target在数组里的左右边界，有如下三种情况：
情况一：target 在数组范围的右边或者左边，例如数组{3, 4, 5}，target为2或者数组{3, 4, 5},target为6，此时应该返回{-1, -1}情况二：target 在数组范围中，且数组中不存在target，例如数组{3,6,7},target为5，此时应该返回{-1, -1}情况三：target 在数组范围中，且数组中存在target，例如数组{3,6,7},target为6，此时应该返回{1, 1} 错误解法 按照我自己的思路用传统二分不知道为什么超时，有知道的大佬可以指点一下我的错误代码
public int[] searchRange(int[] nums, int target) { int arr[]={-1,-1}; if (target&lt;nums[0]||target&gt;nums[nums.length-1])return arr; int l=0,r=nums.length-1; while (l&lt;=r){ int mid=l+((r-l)&gt;&gt;1); if (nums[mid]==target){ if (arr[0]==-1){ arr[0]=mid; arr[1]=mid; }else { arr[1]=mid; } }else if(nums[mid]&lt;target)l=mid+1; else if (nums[mid]&gt;target)r=mid-1; } return arr; } 正确代码 下面换了个思路就AK了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d16bb68f9e78ffcf5a544a1d1d5bbfc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e496e079369dbf067e69082d81ab5200/" rel="bookmark">
			电脑提示需要安装.Net Framework 3.5怎么解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		日常生活中使用windows系统的时候我们可能都会遇到电脑中的一些功能无法正常使用，比如经常有用户会看到系统会提示“需要安装.Net Framework 3.5”，那么很多人在安装的时候都无法成功安装，这个问题要怎么解决呢，下面我们就一起来看下详细教程，让你快速就能学会。
提示：解决win10安装net fram ework 3.5失败（错误代码 0x800F0950）
一：出现问题：报错代码
二：解决步骤
1、通过命令提示符明确自己系统版本，使用快捷键windows+X键打开命令提示符（管理员A）；
2、然后在命令提示符面板中我们就可以知晓自己电脑安装的系统版本是多少，前面10代表windows10系统，18362就是当前系统的版本；
3、然后根据系统下载对应版本的iso，提取sxs文件夹，下载好iso文件之后右键--打开方式--WinRAR压缩文件管理器--打开；
5、找到子目录中的sources里面的sxs文件夹，拷贝到电脑的D盘中，也可以放在C盘当中；
6、接着使用cmd命令行中执行命令dism.exe /online /enable-feature /featurename:NetFX3/Source:D:sxs，如果是放在C的话就需要将最后的Source:D改成Source:C，接着在面板中看到进度条显示100％就基本上完成了；
7、最后打开控制面板选择“程序”进入到程序面板中；
8、在程序和功能当中选择“启用或关闭Windows功能”；
9、最后将 net framework 3.5功能开启即可完成。
总结：其中最麻烦的可能就是要找到你这台电脑对应版本的iso文件，然后从中解压出需要的sxs文件夹即可。
这个解决方法可以保证一次性完美解决问题，不知道屏幕前的你是否已经学会了呢，更多详细教程大家可以持续关注。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e372f317669b6f1fa3939219cdc1167b/" rel="bookmark">
			基于C# Winform的二维码（QR Code）生成程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二维码简介 二维码即2-Dimensional Bar Code，二维条码的种类很多，常见的二维码格式有：PDF417码、QR码、汉信码、颜色条码、quick mark code、data matrix。与传统的条形码相比，可以存储更多的信息，二维码本质上是个密码算法，本文描述的是最常见的QR码（QR Code）的生成方式，QR码的结构如下图所示。
目标 开发一个C# Winform应用程序：
1）可以在界面中输入任意文本内容，点击生成按钮可以将文本内容转换为二维码展示在用户界面中；
2）点击保存按钮可以将二维码以图片的形式保存在指定的路径下。
基于 C# Winform 的 QR 码生成程序 创建Winform .net framework项目，通过Nuget包管理器安装QRCoder库，如下图所示。
搭建 Winform 用户界面，如下图所示，其中一个richText文本框用于输入文本信息，该文本信息用于生成二维码，一个picturebox控件用于展示生成的二维码，两个Button控件用于触发二维码的生成和保存。
编写程序代码，代码源码如下： using QRCoder; using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.IO; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Windows.Forms; namespace QRCode_Winform { public partial class Form1 : Form { public Form1() { InitializeComponent(); // 设置picQRCode对象图片自适应 picQRCode.BackgroundImageLayout = ImageLayout.Stretch; picQRCode.SizeMode=PictureBoxSizeMode.StretchImage; } private void btnCreate_Click(object sender, EventArgs e) { // 创建QRCodeGenerator对象 QRCodeGenerator qrGenerator = new QRCodeGenerator(); // 创建QCodeRData对象 QRCodeData qrData = qrGenerator.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e372f317669b6f1fa3939219cdc1167b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e48c39a4bf5d79c2b691523e9aa33e61/" rel="bookmark">
			pycharm配置python3.8版本专门用于undecteded_chromedriver测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pycharm配置python3.8版本专门用于undecteded_chromedriver测试 作者：虚坏叔叔
博客：https://pay.xuhss.com
早餐店不会开到晚上，想吃的人早就来了！😄
一、Pycharm及python环境的配置 1.安装python-3.8.7rc1-amd64.exe 2.pycharm添加python解释器 3.配置脚本启动 创建一个脚本MakeBaiDuShuRuKuang.py
# -*- coding: utf-8 -*- import undetected_chromedriver as uc ''' ''' class JobTask(): def __init__(self): self.source = "BaiduShuRuKuang" self.deep = 1 #定义递归的深度 控制相关性 self.url = { "num" : 1, } ''' ''' def run(self,params): act = params['act'] driver = uc.Chrome(headless=True,use_subprocess=False) driver.get('https://nowsecure.nl') driver.save_screenshot('nowsecure.png') # 当程序直接运行时，执行main函数 if __name__ == "__main__": # 创建 JobTask 类的实例 job_task = JobTask() # 定义包含 'act' 键的参数字典 params = {'act': 'your_action_here'} # 调用 run 函数并传递参数 job_task.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e48c39a4bf5d79c2b691523e9aa33e61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f81227a1556fb37294f145b82da84a64/" rel="bookmark">
			#洛谷题解：P5703（数组）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、题目链接：【深基5.例10】显示屏 - 洛谷 学习要点：
1、数字的变量类型选择：如果是在0～9之间的数字，根据题目要求是开int 还是开char，并且后续要记住是int还是char的数字，不能只记得是个数字, 即搞清变量类型
2、数组：1⃣️、如果读入需要保存，就开数组，不需要保存就开一个变量，实时处理即可
2⃣️、数组长度为n，存储从0～(n-1)
3⃣️、对多维数组的处理
3、scanf: 如果用scanf读入非空白字符，一律写成scanf(" %c", &amp;*), 避免空白字符读入
4、在现实中需要竖着写的，在程序中考虑用二重循环处理
5、弄清楚各个变量之间的关系，写在纸上
二、题目： 1. 题目描述： 液晶屏上，每个阿拉伯数字都是可以显示成 3×5的点阵的（其中 X 表示亮点，. 表示暗点）。现在给出数字位数（不超过 100100）和一串数字，要求输出这些数字在显示屏上的效果。数字的显示方式如同样例输出，注意每个数字之间都有一列间隔。
2. 输入格式： 第一行输入一个正整数 n，表示数字的位数。
第二行输入一个长度为 n 的自然数。
3. 输出格式： 输出五行，表示显示屏上的数字。
4.输出样例： 输入：
10 0123456789 输出：
XXX...X.XXX.XXX.X.X.XXX.XXX.XXX.XXX.XXX X.X...X...X...X.X.X.X...X.....X.X.X.X.X X.X...X.XXX.XXX.XXX.XXX.XXX...X.XXX.XXX X.X...X.X.....X...X...X.X.X...X.X.X...X XXX...X.XXX.XXX...X.XXX.XXX...X.XXX.XXX 5.说明/提示： 数据保证：1 &lt;= n &lt;= 100
三、题目分析 首先，题目中n&lt;=100, 所以开int类型即可
然后由样例可知从0～9依次对应一个图案，再加上输出是先输出一行再输出下一行，所以要二重循环（因为没办法完整打出一个图案再从第一行开始打第二个图案，这和九九乘法表是一样的），因此决定暴力打表
其次，从样例中分析出0～9的图案表示：
{//0 "XXX", "X.X", "X.X", "X.X", "XXX" }, {//1 "..X", "..X", "..X", "..X", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f81227a1556fb37294f145b82da84a64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0082f611e6e5a3c37deec765e8a2d505/" rel="bookmark">
			WebSocket实战之六心跳重连机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 WebSocket应用部署到生产环境，我们除了会碰到因为经过代理服务器无法连接的问题（注：该问题可以通过搭建WSS来解决，具体配置请看 WebSocket实战之四WSS配置 ），另外一个问题就是外网环境不稳定经常会断开或者服务器重启或者网络中间服务器当发现一个长连接长时间没有传输数据会断开，今天我们来了解一下基于WebSocket如何做心跳重连。
二、PingPong 关于心跳包的格式，WebSocket协议RFC6455中有定义控制帧的格式.
Ping帧包含一个操作码 0x9，Pong帧包含一个操作码 0xA。
客户端发送Ping帧，服务端收到Ping帧后回一个响应Pong帧。
但是JavaScript 并没有API支持Ping、Pong帧，而后端JavaEE是有PingPong的支持，这是很奇怪的事情，那我们就通过自定义消息来定义心跳包。
三、一个包含心跳包服务端推送较完整的例子 1、SpringBoot端代码 对 WebSocket实战之五JSR356 这篇文章WebSocketServer类进行修改，配置一个定时器，每隔10秒定时发送当前时间，并且在onMessage事件中加上接收心跳包以及发送心跳包的代码，服务端对心跳处理相对简单。
注：需要使用一个容器将请求的Session保存起来并且使用static，否则在发送信息时拿不到原来的那个session对象。
2、前端JavaScript代码 说明：
1、所有异常都加上重连代码，包含创建WebSocket连接、onClose事件、onError事件。
2、在onOpen和onMessage启动心跳包发送。
3、心跳包发送方法设置两个延迟器一个用于发送心跳包，另外一个用于当服务端超时（如果服务端未超时会发送响应心跳包然后重新调用heartCheck将两个延迟器清空）关闭WebSocket连接。
4、重连代码时序：当服务端Down掉或网络断开超过一定时间serverTimeoutObj这个延迟器会执行，然后调用ws.close()关闭连接并且触发onClose事件，在onClose事件中会调用reconnect方法，而reconnect又会调用createWebSocket方法，createWebSocket去创建WebSocket连接，当创建异常时又会再调用reconnect，一直到能连接得上。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7845664c7b53852622e5a107a3563ddb/" rel="bookmark">
			签名算法SHA256withRSA，RSA数字证书公钥私钥生成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		"SHA256withRSA" 是一种签名算法，结合了 SHA-256 哈希算法和 RSA 加密算法。 RSA数字证书公钥密钥生成： 在Linux系统下运行以下命令生成：
如果提示输出密码，可以为空，直接回车
生成的公钥rsa_public_key.pem和密钥rsa_private_key.pem文件在当前目录下
# openssl # genrsa -out rsa_private_key.pem 2048 Generating RSA private key, 2048 bit long modulus # pkcs8 -topk8 -inform PEM -in rsa_private_key.pem -outform PEM -nocrypt # rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem 签名算法sha256withrsa： $string：需要加密的字符串 $binary_signature：加密后保存到该变量中 $this-&gt;privateKey：RSA的私钥。(使用file_get_contents()读取私钥文件获取）; openssl_sign($string, $binary_signature, $this-&gt;privateKey, OPENSSL_ALGO_SHA256); 实例： 签名算法使用sha256withrsa算法，我方和渠道伙伴需交换RSA数字证书公钥用于验证签名，签名时，使用RSA数字证书私钥对签名参数串进行签名，RSA密用2048位及以上的，将签名值使用BASE64转码后填充到报文的数字签名域(Signature)。验证签名时，使用对方颁发的RSA数字证书公钥进行验签
/** * 签名 + post请求 * @param array $param 请求参数 * @param string $method 第三方方法名 * @param string $api_method 接口名 * @param string $is_big 通道别名 * @param int $phone 手机号码 * @return mixed */ public function sign_post($param, $method, $api_method, $is_big, $phone) { $param['reqTime'] = date('YmdHis'); $param['partnerId'] = $this-&gt;partnerId; $this-&gt;log($param, $api_method, $is_big, '签名前数据：', $phone); $signature = $this-&gt;makeSign($param); $this-&gt;log($signature, $api_method, $is_big, '签名值：'); $param['signature'] = $signature; $types = explode('_',$api_method); if($types[0] == 'sk'){ $requestUrl = $this-&gt;edUrl .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7845664c7b53852622e5a107a3563ddb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/915ad2127447fb5abea425ec16cf42b7/" rel="bookmark">
			C语言画爱心
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先,你要了解画爱心的循环代码:
for (y = 1.5f; y &gt; -1; y -= 0.1f) { for (x = -1.5f; x &lt; 1.5f; x += .05f) { a = x * x + y * y - 1; putchar(a * a * a - x * x * y * y * y &lt; 0.0f ? 'x' : ' '); } putchar('\n'); //换行 } 其次,如果要更换颜色,就要用到设计程序颜色(system("color **"))。
0~9为背景颜色设置，A~F为字体颜色设置。
例如：system（“color 0C”）就是黑色背景，淡红色字体
system(" color 0C");//设计程序颜色 切记：使用color函数是要包含头文件(Windows.h)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/915ad2127447fb5abea425ec16cf42b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8157835ed7eda11b0fd378433a361d65/" rel="bookmark">
			MQTT 服务器搭建（基于mosquitto）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、前言 MQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议），是一种基于发布/订阅（publish/subscribe）模式的"轻量级"通讯协议，该协议构建于TCP/IP协议上，由IBM在1999年发布。MQTT最大优点在于，可以以极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务。
Mosquitto是用C语言实现MQTT协议的Broker。是一款实现了消息推送协议 MQTT v3.1 的开源消息代理软件，提供轻量级的，支持可发布/可订阅的的消息推送模式，使设备对设备之间的短消息通信变得简单，比如现在应用广泛的低功耗传感器，手机、嵌入式计算机、微型控制器等移动设备。
2、mosquitto 2.1 安装 mosquitto下载地址：Download | Eclipse Mosquitto
下载相应的版本，我的系统是windows 64 的
选择安装路径，例如我的是：D:\Program Files\mosquitto
2.2 mosquitto文件说明 1）mosquitto：代理器主程序
2）mosquitto.conf：配置文件
3）mosquitto_passwd：用户密码管理工具
4）mosquitto_pub：用于发布消息的命令行客户端
5）mosquitto_sub：用于订阅消息的命令行客户端
6）mqtt：MQTT的后台进程
7）libmosquitto：客户端编译的库文件
2.3 修改配置文件 配置文件在D:\Program Files\mosquitto目录下，找到mosquitto.conf文件打开
2.2.1. 配置端口，搜索listener：改为 listener 1883
2.2.2.允许匿名登录：allow_anonymous false改为allow_anonymous true
2.2.3. 设置账号密码，搜索password_file：改为 password_file pwfile.example
设置账号密码，保存于pwfile.example文件内（不允许匿名登录才有效）
至此，mqtt broker环境安装与配置完毕！
2.4 启动mosquitto 打开D:\Program Files\mosquitto目录
按住Shift键，在空白处右击，打开命令行窗口
输入 .\mosquitto -c .\mosquitto.conf -v 然后下面的消息表示mosquitto 2.0.18版本运行起来了。
3、mqtt测试 打开mqtt客户端
因为我开始设置的用户名跟密码是user与password，所以这里需要填上
mosquitto_sub 订阅消息
mosquitto_sub -h localhost -t "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8157835ed7eda11b0fd378433a361d65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5298cfe9778431ddbbc4e3222ac7acb0/" rel="bookmark">
			数字时代古文的传承———云南文化瑰宝“爨文化“(我为家乡发声)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言⭐ "爨"意味着什么，究竟何为"爨文化"？⭐ 爨文化鲜明的特点1.经济生活2.政治生活3.文化艺术 ⭐ 数字时代古文的传承与传播1.藏品数字化2.建立数据库3.传播大众化 前言 爨文化是继古滇文化之后崛起于珠江正源南盘江流域的历史文化，其中心区域在今曲靖及昆明、玉溪、楚雄、红河等地，范围包括当时的建宁、兴古、朱提、云南、牂柯、越巂、永昌七郡在内的整个南中地区，时间大致为蜀汉建兴三年（225年）至唐天宝七载（748年）。爨文化孕育成长的南盘江流域曾是古人类生活的地方。盘江流域的远古人类在滇东高原创造了光辉灿烂的古代文明，这一区域文化的中心为今曲靖、陆良两大坝区。其中，曲靖自古为“入滇门户”，素有“全滇锁钥”之称。特定的地理位置，使其较早地接受巴蜀、夜郎和中原文化的影响。
⭐ “爨"意味着什么，究竟何为"爨文化”？ 爨，最初是中国古代氏族部落之称。云南，是人类的故乡之一。在滇中、滇东、滇南、滇西都发现了大量旧石器、新石器时代的文化遗址，其中尤以元谋人的发现最为突出。到了文明时代，云南的历史发展较之中原为缓。不过，在这块神奇土地上，先民们后来的发展进程在时间上虽属滞后，但在文化内涵上却形成了独特风格，在中国灿烂的文化史上散发出了夺目的光彩。
由于复杂的地理环境和众多的文化源流，自古以来，云南形成了多区域、多文化、多中心的发展格局：以滇池区域为中心的古滇文化，是云南青铜文明高度发达的集中体现；稍后崛起于盘江流域的爨文化，则是云南中古时期文明的代表；继之而起在洱海区域形成并得到高度发展的南诏、大理文化，具有鲜明的地方民族特色；元、明以后，汉族大量涌入云南，汉文化在交通沿线和相对发达的坝区逐渐取代当地文化而成为主导文化，这才使云南的本土文化与中原文化趋近归流而处于后进发展的时代。
至于爨之为姓，已经是很古老的事了，而使作为姓氏的爨得到发扬光大的则是南中头号大姓爨氏，后来一直是南中地区的实际统治者，曾称霸南中四百余年。最早见于史籍的爨姓之人为《战国策·魏策》里的爨襄，这表明至迟在战国时期爨姓已出现。爨氏之姓究竟因何而来，源自何方？据始建于南朝刘宋时期（公元458年）的《爨龙颜碑》记载：“采邑于爨，因氏族焉”，是说爨氏因封地而得姓。以采邑为姓即以封地之名为姓氏，在古代极为普遍，不过爨氏是否形成过一个民族，是个值得进一步深入研究的问题。
⭐ 爨文化鲜明的特点 1.经济生活 滇东高原既有盘江便利的水利，又有乌蒙丰盛的牧草，这就使得其在文明发展史上，形成了独特的农畜并存的文化特征，也就是爨文化基本的经济特征。以农为主，畜牧为辅，且农牧之间并无严格界限，根据历史记载，在爨文化时期，就已开始推行水田种植，种植麻、豆、黍、稷等农作物，同时养殖牛等常见牲畜。
正是因为从爨文化时期丰富的农作物的种植技术经验积累，才有了后来包括油菜种植在内的多种农作物的种植和培育。
2.政治生活 诸葛亮南征，封南中四郡为七郡，这一设置并未完全按照地域来分，而是在庲降都督节制下，根据西南夷原有的民族结构来划分的。
在爨氏统治期间，既任命王朝官吏，又封土酋为长，这种政治制度上的“双轨制”对爨文化形成以后爨区的政治结构产生了巨大的影响。但爨氏十数代中，从未出现过割据称王或改元称号的现象。这样，就在中原纷乱的情况下和长达400余年的时期内，始终维护了国家的统一和多民族的团结。所以，始终维护国家统一和民族团结，也是爨文化其一。
3.文化艺术 ①文字文化：
爨氏重视文化。爨宝子、爨龙颜均在20余岁举秀才，并以文人仕，凭学识和文治武功登上政治舞台。以国家重点文物保护单位“爨宝子碑”和“爨龙颜碑”(俗称“两爨碑”)为代表的爨文化，也成为研究魏晋南北朝时期云南独特文化现象的重要内容。
两爨碑中，其碑刻集中地体现出东晋、南北朝时期汉字从隶向楷过渡的特点，有个书体就叫做爨体。“爨体字”其书体风格用笔方峻，起收果断，似昆刀切玉，笔力雄强，结体茂密，继承汉碑法度，有隶书遗意，爨体字也被称为书体中的国宝。
比如“昆明火车站”地铁站站名，电影《我和我的祖国》海报字体，还有招商银行标志的字体，都采用了“爨体”，可见“爨体字”应用之广。
②礼乐文化：
爨古乐内容丰富，具有鲜明的民族特色。融合宗教音乐、宫廷音乐和民间音乐，兼收并蓄，旋律雍容、典雅、庄严，古色古香，还融合了洞经音乐、本县打鼓村的吹吹腔、舞族民歌等地方音乐，增强了爨乡古乐的表现力。
乐器的使用更具有个性色彩，如《舞龙颜将军出征》曲以大鼓、小鼓、堂鼓等打击乐为主，生动形象地反映出昔日舞龙颜将军出征时那种威武、雄壮的场面。
没有改姓的爨氏族人，如今主要分布在云南省曲靖市麒麟区，陕西省华阴市孟源镇沟李村爨家自然村，河北省廊坊市等地，但仍然保留爨人的音乐习俗文化，会定期举行爨乡文化节、爨族火把节等活动。
爨文化之中的音乐文化别具宝光异彩，悠扬博厚。很容易将人带入到历史的洪流之中，感知历史的磅礴与厚重，声声撞击着灵魂！
③饮食文化：
爨乡古酒中的“阳春老窖”、“老窖子”、“八鲜醇”、“冷酒”、“松子酒”等，闻名遐迩。唐开元年间，爨归王曾有“杯酒斗米”之称誉。
在古时候云南地区，食物的主要来源为采集和狩猎，云南优质的气候条件，使得其植被种类多样，可供食用的植物也很多，直至今日，云南等地还有许多独有的菜肴。
喜食“饭团”，外出狩猎或劳作可随时取出烘烤食用，后来陆良出现的久负盛名的“陆良小粑粑”，推测也应该是由爨人留下的饮食习俗慢慢演变而成。
当然，平定南中的诸葛亮对云南饮食文化也有助推，他是馒头（即包子）的发明者，对云南饮食乃至中国饮食文化都有很大的影响。
④服饰文化：
爨氏在控制云南四百多年的历史中逐渐形成了“东爨乌蛮”和“西爨白蛮”两大部族。南召灭爨以后，西爨白蛮被强行迁徙至永昌(保山)地区，他们和洱海地区的其他部族一起，逐步形成了今天的白族等少数民族。留在当地山区的东爨乌蛮则保有了自己的部落组织，在南宋时期成立了以“东爨乌蛮”为主体的“自杞国”政权。
自杞国人个子高，眼窝深，脸黑齿白。喜欢赤脚、戴笠、披毡子。腰间系着用芦苇织成的带子，手臂上戴着金银打造的圆环佩饰，身上随时挎着长刀、弩弓、箭矢。乌蛮男子喜欢把头发扎起来，上面佩戴一些兽骨、飞禽的羽毛(像印第安人)。身上穿着用兽毛、猪鬃、头发混合碾压揉成的毡子。骑的马没有马鞍，只有用木头剜成鱼口状仅能容下脚趾的马镫。妇女则耳朵上戴着大耳环，剪着齐眉刘海，穿着露出膝盖的布裙(这与东乌蛮的后裔彝族的服饰相类似)。
⑤医药文化：
云南省是中医药和民族医药大省，中草药资源丰富，素来有“植物王国”“百药之乡”的美誉，在云南医药的不断发展之中，形成了以傣、彝、藏族医药为主，苗族、白族、纳西族等民族医药多元并存的独特的云南民族医药体系，为各个民族人民健康和繁衍昌盛做出了重要贡献。
在爨氏统治时期，医药也是在不断的发展且流传至今。被誉为“滇东明珠”的爨文化中心陆良，中药资源极其丰富，“药食同源”的中药材俯首皆是，在云南医药文化中是重要的一环。
⑥工艺：
《山海经》山经记载：共工与颛顼争为天子不胜，怒而触不周之山，使天柱折，地维绝。捅破天了，大地万物无法生长，给人类带来灾难，女娲为救天下苍生，练七彩泥补天，掉下一块落在云南陆良，形成彩色沙林，成为今天爨陶原矿。
爨氏迁徙曲靖陆良把这制陶工艺带入当地，传授当地百姓技艺发展陶业，带动当地经济发展，爨陶精选云南高原七彩稀有黏土和陆良彩色沙林七彩沙；含有锶、硒等多种人体所需矿物质。爨陶体如铁、色如铜、亮如镜、声如磬，润如语，造型古拙，形神奇逸，用爨陶壶泡茶能保持水的甘甜、茶的香韵，蒸煮米饭香软可口，花瓶插花经久不凋谢，爨陶餐具存肴不馊。
爨文化是爨陶的灵魂，爨文化有了爨陶作为有效传播载体，得到了更快更广泛的传播，爨陶有了爨文化的植入，提高了爨陶文化艺术价值、收藏价值和品牌价值，提高了知名度和市场竞争力，从而彰显出爨陶的独特魅力。
⑦建筑：
爨氏统治南中四百多年，历经西晋、东晋、南北朝、隋朝、唐初五个朝代，受中原文化影响最为深刻，其建筑风格还是秉承了以中原木构架为基础的四合院的汉唐风建筑风格。这种木构体系、院落式组合的建筑是陆良乃至中国古民居建筑最根本、最突出的表现形式。秦汉时期这种建筑形式的雏形就由中原移民带入陆良。根据陆良现存古城遗址挖掘探明，爨氏时期的大姓都采用了这样的建筑形式，只是地上房屋结构多有区别。
⭐ 数字时代古文的传承与传播 古文字与出土文献作为人类古典文明阶段留存下来的珍贵遗产，是今人认识和探索人类文明历史进程所凭借的最为重要的基本材料。世界上现存于世的古文字中，只有中国古文字资料最为丰富和系统，而且也唯有中国的这一古典文字系统当今依然在传承使用。中国文字与古代文献是传承和传播中华古典文明的重要载体，也是中国古代历史文化的信息资源库。
1.藏品数字化 依托数字化技术可改变古文字资料的储藏方式，为古文字的传承和传播开辟便捷通道。
中国古文字资料的载体主要是甲骨、金石和简帛等。这些历史文物及其文字资料都是收藏单位的珍稀瑰宝。古文字资料的文物属性，使得其保护和利用成为长期以来困扰收藏单位和古文字研究者的一大问题。除了极少数在博物馆展示的材料外，一般的研究者根本无法接触到古文字实物。数字化技术可使这些古文字文物以多维方式呈现出来，通过网络系统和其他电子媒介将深藏于博物馆的珍贵文字文物资料与研究者和公众分享，为古文字研究、传承和传播提供极为便利的条件，同时也能妥善解决文字文物保护和利用的矛盾。
目前，国际上一些著名的收藏单位已开始尝试将所收藏的古文字文物数字化，并通过信息门户网站部分向社会公布。如果各收藏单位能够有计划地将全部收藏的古文字文物资料数字化并公之于众，必将极大地推进古文字的传承和传播。这是古文字适应数字文明时代新需求的一项令人期待的宏大工程。
2.建立数据库 古文字的数字化可促进各类古文字资源数据库的建立，为古文字研究获取资料提供极大便利。
古文字资料印刷品价格昂贵、不便流通，使得专业研究者和一般读者获得古文字资料极为困难，阻碍了古文字的研究、传承和传播。古文字学成为名副其实的“冷门绝学”。古文字数字化为建立各类古文字数据库奠定了基础，通过数据库可以从根本上突破长期以来制约古文字学发展的资料瓶颈。古文字资料获取的便捷，必将极大地提高古文字研究和学习的效率。
近年来，一些研究单位分别开发甲骨文、青铜器铭文和简帛文献数据库，有些已经开始面向专业学者提供服务。如清华大学出土文献研究与保护中心与出版单位合作，将《清华大学藏战国竹简》整理研究报告数字化，建立了《清华大学藏战国竹简》电子书网站。读者通过网站可方便地使用清华简研究成果。同时，中心还开发建立了“楚文字综合整理工作平台”，启动了以清华简为代表的楚文字数据库研制。
3.传播大众化 数字时代提供的各类传播路径和平台，可为古文字传承和传播开辟极为广阔的前景。
传统的传播方式和路径，使古文字知识的传承和传播受到极大局限。对社会大众而言，古文字是那么深不可测，令人望而生畏。数字时代，网络、新媒体和各类传播平台可以生动形象地传播古文字知识产品，让古文字走进社会、走进大众。人们可在喜闻乐见的轻松氛围中获得古文字知识。通过培育古文字传承和传播的深厚群众基础，尤其是有针对性地加强以青少年为主要对象的古文字数字化传播，对弘扬传承中华优秀传统文化以及古文字学学科的长远发展都有深远意义。
数字时代为古文字的传承和传播带来巨大的历史机遇。古文字学学者要善于把握机遇，努力拓宽视野，主动更新观念，开拓新思路，探索新路径，充分发挥信息技术对古文字与出土文献传承和传播的积极影响。由中宣部、教育部、国家语委等八部门组织实施的“古文字与中华文明传承发展工程”，将数字化作为工程建设的重要内容，统筹安排了多个古文字与出土文献数字化项目。随着工程建设的推进，各建设单位将会结合自身实际，努力探索古文字融入数字化时代的方法和路径，推出古文字数字化研究新成果，积极推动古文字学学科的交叉发展，使古文字在数字文明时代焕发出新的生机。
祝各位国庆快乐！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b46f18a5b6ffdcc4ced2f04f78eaf25/" rel="bookmark">
			Prometheus&#43;Grafana监控K8S集群(基于K8S环境部署)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、环境信息二、部署前准备工作三、部署Prometheus监控系统四、部署Node_exporter组件五、部署Kube_state_metrics组件六、部署Grafana可视化平台七、Grafana接入Prometheus数据八、Grafana添加监控模板九、拓展 一、环境信息 1、服务器及K8S版本信息：
IP地址主机名称角色K8S版本16.32.15.200master-1Master节点v1.23.016.32.15.201node-1Node节点v1.23.016.32.15.202node-2Node节点v1.23.0 2、部署组件版本：
序号名称版本作用1Prometheusv2.33.5收集、存储和处理指标数据2Node_exporterv0.16.0采集服务器指标，如CPU、内存、磁盘、网络等3Kube-state-metricsv1.9.0采集K8S资源指标，如Pod、Node、Deployment、Service等4Grafanav8.4.5可视化展示Prometheus收集数据 3、离线包下载：
包括本实验的离线镜像包、导入Grafana所需的模板文件。
点击下载：
二、部署前准备工作 1、创建名称空间，下面所有资源都放到这里
kubectl create ns prometheus 2、创建ServiceAccount账号，并绑定cluster-admin集群角色(Prometheus中需要指定)
kubectl create serviceaccount prometheus -n prometheus kubectl create clusterrolebinding prometheus-clusterrolebinding -n prometheus --clusterrole=cluster-admin --serviceaccount=prometheus:prometheus kubectl create clusterrolebinding prometheus-clusterrolebinding-1 -n prometheus --clusterrole=cluster-admin --user=system:serviceaccount:prometheus:prometheus 3、创建Prometheus存放数据目录
注意：我准备将Prometheus服务部署在Node-1节点，所以此步骤在Node-1节点执行
mkdir /data chmod -R 777 /data 4、创建Grafana存放数据目录
我准备将Grafana服务部署在Node-1节点，所以此步骤也在Node-1节点执行
mkdir /var/lib/grafana/ -p chmod 777 /var/lib/grafana/ 5、时间同步 &amp;&amp; 时区同步
# 时间同步 yum -y install ntpdate /usr/sbin/ntpdate -u ntp1.aliyun.com # 时区同步 timedatectl set-timezone Asia/Shanghai 定时同步：每天凌晨5点进行时间同步
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b46f18a5b6ffdcc4ced2f04f78eaf25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efec787e47233de5bf49555443b6f9cb/" rel="bookmark">
			Vue中的数据筛选与搜索功能实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue中的数据筛选与搜索功能实现 在许多Web应用程序中，数据筛选和搜索是关键的用户体验功能。Vue.js作为一种流行的前端框架，提供了许多工具和技术，使开发者能够轻松地实现这些功能。本文将深入探讨在Vue中如何进行数据筛选与搜索的实现，以及提供示例代码来帮助您入门。
在这里插入图片描述
数据筛选与搜索的基本概念 数据筛选和搜索功能的核心目标是从一组数据中过滤出满足特定条件的项。这些条件可以基于用户输入、选择的过滤器或其他参数来确定。以下是一些常见的用例：
基于文本的搜索：根据用户输入的关键字搜索数据集中的项目。
基于条件的筛选：根据用户选择的条件（例如日期范围、价格范围等）筛选数据。
多个筛选条件的组合：允许用户同时应用多个筛选条件。
在Vue中，您可以使用计算属性和方法来实现这些功能，以及利用Vue的响应式数据绑定来自动更新界面。
示例：基于文本的搜索 让我们从一个简单的基于文本的搜索功能开始。我们将创建一个包含一组电影数据的Vue应用程序，并允许用户搜索这些电影。
创建Vue应用程序 首先，创建一个Vue应用程序。您可以使用Vue CLI来快速设置一个新的Vue项目：
vue create movie-app 准备电影数据 在Vue应用程序中，您需要一个包含电影数据的数组。您可以将数据硬编码到Vue组件中，或者从API或外部数据源获取数据。以下是一个示例电影数据数组：
const movies = [ { title: 'Movie 1', year: 2020 }, { title: 'Movie 2', year: 2019 }, { title: 'Movie 3', year: 2021 }, // ... 更多电影数据 ]; 创建Vue组件 创建一个Vue组件来显示电影数据和搜索框。在src/components/MovieList.vue中，添加以下代码：
&lt;template&gt; &lt;div&gt; &lt;input type="text" v-model="searchTerm" placeholder="Search movies..." /&gt; &lt;ul&gt; &lt;li v-for="movie in filteredMovies" :key="movie.title"&gt; {{ movie.title }} ({{ movie.year }}) &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { movies: [.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/efec787e47233de5bf49555443b6f9cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5aa22c2eb118b1b08f90c724a21ce35c/" rel="bookmark">
			常用的分布式ID解决方案原理解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一：分布式ID的使用场景
二：分布式ID设计的技术指标
三：常见的分布式ID生成策略
3.1 UUID
3.2 数据库生成
3.3 数据库的多主模式
3.4 号段模式
3.5 雪花算法
前言 分布式ID的生成是分布式系统中非常核心的基础性模块，其常用于在分布式环境下作为数据或消息的唯一性的标识。
在互联网发展早期，由于用户量较少,业务需求也比较简单。对于软件应用，我们只需要一台高配置的服务器，把业务所有模块全单机部署，这样的软件架构模式称为单体架构模式。
在这种架构模式下，为了为数据生成唯一性的标识ID，一般有以下两种方案
1) 在服务器层面，主动的填充好ID，再将数据记录保存数据库。
2) 强依赖于数据库表的自增ID，服务器生成的数据记录不需要先填充ID，交由数据库来自动填充自增ID。
随着用户量的增加，客户端请求的并发量越来越大，在这个过程中单体架构因为其单机硬件资源的瓶颈造成以下问题
1）随着并发量的逐渐增大，客户端的请求RT时间越来越大，请求超时失败概率越来越大。
2）单机架构会存在单点故障问题。
为了解决上述的问题，在并发量较高的场景中我们会进行分库分表，将数据库进行集群化部署。
在复杂的分布式系统中，我们需要对大量的数据和消息进行唯一性标识，在数据库进行分库分表后，数据库表的自增ID显然不满足需求。此时急需一个分布式ID的生成方案。
一：分布式ID的使用场景 分布式ID的使用前提就是在复杂的分布式系统中，我们需要对大量的数据和消息进行唯一性标识。
1）用户，会员等成员身份的唯一标识。
2）订单，支付，金融等业务场景。
3) 优惠卷的兑换码
4) 加密文件的密码
总之，需要在复杂分布式系统中，需要对大量数据和消息进行唯一性标识，那么就应当使用分布式ID。
二：分布式ID设计的技术指标 首先，实现分布式全局唯一ID的解决方案有很多，比如说Mysql的主键维护表，数据库的号段模式，Zookeeper的有序节点，MongoDB的ObjectID，Redis的自增ID，UUID，雪花算法........
以上方案自然满足了在分布式环境下生成ID的唯一性的标准，但是在实际生产环境中，考虑一个分布式ID解决方案是否达标，还应该考虑其它的技术指标。
分布式ID设计的技术指标可以用来评估一个分布式ID解决方案是否满足实际的生产环境，也可以用来评估分布式ID解决方案的优劣。
1）全局唯一性：分布式ID的全局唯一性是最基础的指标，是分布式ID解决方案必须保证的指标。
2）有序性：分布式ID常用来作为数据库的主键存在，例如Mysql数据库，有序的ID能够显著提升B+树的维护效率，避免因为ID的无序性导致数据新增时造成频繁的页分裂，避免大量数据迁移造成的大量磁盘随机IO的代价。
3）安全性: 分布式ID不一定是无规则，杂乱无章的，通常还会代表一些实际的意义。(比如 生成当前分布式ID的时间 ，用于标识当前机器的唯一标识 等)。正因为有了这些实际的意义，可以方便于进行统计，数据分析等工作。但分布式ID不因该携带敏感信息，否则可能被恶意爬取数据造成数据泄露风险。
4）可用性:分布式ID是分布式系统中非常核心的基础模块，众多业务都依赖于分布式ID，来对大量数据和消息进行唯一性标识。因此实际生产环境对ID生成系统的可用性要求极高，一旦ID生成系统出现不可用，可能会导致整个业务系统瘫痪。
5）高性能：分布式唯一ID生成系统需要满足整个公司业务的需求，可能涉及亿级别的调用，对性能要求较高。
三：常见的分布式ID生成策略 3.1 UUID UUID(Universally Unique Identifier)，通用唯一识别码。UUID到目前为止总共迭代了五个版本，每个版本生成UUID的算法都不一样，适用于不同的场景。
UUID 是由一组32位数的16进制数字所构成，以连字号分隔的五组来显示，形式为 8-4-4-4-12，总共有 36个字符（即三十二个英数字母和四个连字号)，占36个字节的存储空间。例如：
aefbbd3a-9cc5-4655-8363-a2a43e6e6c80
xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx
UUID是基于当前时间、计数器（counter）和硬件标识（通常为无线网卡的MAC地址）等数据计算生成的。
此版本的UUID由以下几个部分组成：
1）当前日期和时间，可以保证在不同日期和时间生成的ID一定不同。
2）自增的计数器，可以保证在并发环境下的性能，相同时间内并发生成的多个UUID的计数器是自增的。
3） 当前机器的唯一标识码，全局唯一的IEEE机器识别号，如果有网卡，从网卡MAC地址获得，没有网卡以其他方式获得。可以保证不同机器生成的UUID一定不同。
当然UUID也有根据 随机数，基于名字空间/名字的散列值 (MD5/SHA1) 生成等生成的版本。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5aa22c2eb118b1b08f90c724a21ce35c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42123938b7f5d81806295245e1b2c8aa/" rel="bookmark">
			Java之动态规划的背包问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
动态规划问题
一:01背包问题
1.问题描述
2.分析问题
3.代码实现(二维数组)
4.滚动数组实现(一维数组)
二:完全背包问题
1.题目描述
2.问题分析
3.代码实现
动态规划问题 动态规划(Dynamic Programming)算法的核心思想是:将大问题划分为小问题,进行解决，从而一步步获取最优解的处理算法
动态规划对于解决最优子结构啊和重叠子问题等问题时候,有着很好的应用
对于动态规划问题,大致可以分为以下几步:
确定dp数组（dp table）以及下标的含义确定递推公式dp数组如何初始化确定遍历顺序举例推导dp数组 一:01背包问题 1.问题描述 有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。
例如以下问题:
有一个背包,它的容量为4磅,现有以下物体
物品重量价格物品011500物品143000物品232000 1)要求达到的目标为装入的背包的总价值最大，并且重量不超出 2)要求装入的物品不能重复
2.分析问题 对于解决这样的动态规划的背包问题,还是采用通用的五个步骤
1.确定dp数组（dp table）以及下标的含义
对于01背包问题,可以采用二维数组或者一维数组,这里为了便于理解,先采用一维数组
定义一个二维数组dp[i][j],这里dp数组的含义为:将物品(0到i)放入到背包容量为j的背包里面,价值总和最大为dp[i][j]
2.确定递推公式
对于放入物品i,有两种状态:将物品i放入到背包中,不将物品i放入到背包中
不放物品i:不放物品i,相当于将物品0到i-1放入到背包容量为j的背包中,这个时候递推公式dp[i][j]就可以等于dp[i-1][j]
放物品i:当放入物品i的时候,此时首先需要判断的是否物品i可以放入到背包容量为j的背包中,要是使背包可以放入物品i,则背包的容量至少剩余weight[i],即放入物品0到i-1的时候,背包剩余的容量至少为j-weight[i],因此放入0到i-1物品的最大价值为dp[i-1][j-weight[i]],放入物品i时候的最大价值就为dp[i-1][j-weight[i]]+value[i]
此时dp[i][j]=max(dp[i-1][j],dp[i-1][j-weight[i]]+value[i])
3.dp数组如何初始化
由递推公式dp[i][j]=max(dp[i-1][j],dp[i-1][j-weight[i]]+value[i])可以看出,第i行需要由上一行推算出,所以第i=0行的数据一定要进行初始化,具体如下
for (int i = weight[0]; i &lt;= bagSize; ++i) { dp[0][i] = value[0]; } 4.确定遍历顺序
实现先遍历背包还是先遍历物品,其实都可以,但是先遍历物品更好理解
确定递推的方向:
dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); 递归公式中可以看出dp[i][j]是靠dp[i-1][j]和dp[i - 1][j - weight[i]]推导出来的,dp[i][j]是由其左上角的元素推出来的,因此需要自上到下,自左到右的遍历顺序
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42123938b7f5d81806295245e1b2c8aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7570024de0b1078ad8d4ad78e31c7488/" rel="bookmark">
			查看Python安装路径几种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看Python安装路径方法
在使用python的时候，有时候会需要找到python包的安装位置，怎么办？
对于Windows平台，打开cmd
使用命令py -0p 【其中0是零】
显示已安装的 python 版本且带路径的列表，参见下图：
其中带星号*的为默认版本。
其它还有
一、对于Windows平台，打开cmd
输入命令where Python，回车（即按下Enter键）可输出Python的安装路径。参见下图：
【提示：若安装了python虚拟环境virtualenv，其路径也将显示。】
【如何清除命令行窗口(cmd)内容
输入 cls 回车】
二、在IDLE（Python自带的简洁的集成开发环境）中
先输入import sys回车
再输入sys.path 回车
其中红线标识的就是路径，将其中的\\替换为\ 即可。但这种方式只能看到当前运行的Python的安装路径。
三、以操作系统是Windows10计算机为例，右键 此电脑，属性 -&gt; 高级系统设置 -&gt; 环境变量，在“用户变量”（对当前用户起作用）或“系统变量”（对此计算机上所有的用户起作用）找到path行点击选中，点击“编辑”找到带“Python”的部分就是。
附录、Python第三方模块(库、包)安装、卸载与查看及常见问题解决 https://blog.csdn.net/cnds123/article/details/104393385
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eda8d30e65741ae86898ef549744d184/" rel="bookmark">
			【WIN32 API】函数后缀中的 A 和 W 区别及应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Win32 API 中，函数名后的 “A” 和 “W” 后缀代表了该函数的 ANSI 和 Unicode 版本。在早期的 Windows 系统中，ANSI 版本是使用单字节字符集（主要是 ASCII），而 Unicode 版本支持更广泛的双字节字符集，包括多种语言字符。
“A” 后缀：代表 ANSI 版本。这个版本的函数使用单字节字符集，主要是 ASCII。例如，WNDCLASSA 是一个处理 ANSI 窗口类的结构。
“W” 后缀：代表 Unicode 版本。这个版本的函数使用双字节字符集，支持多种语言字符。例如，WNDCLASSW 是一个处理 Unicode 窗口类的结构。
当使用没有后缀的版本的函数时，如 WNDCLASS，这取决于你编译代码时定义的预处理器宏 _UNICODE 和 UNICODE。如果定义了这些宏，那么没有后缀的函数将默认为 Unicode 版本（即，等同于带有 “W” 后缀的函数）。如果没有定义这些宏，那么没有后缀的函数将默认为 ANSI 版本（即，等同于带有 “A” 后缀的函数）。
定义_UNICODE和UNICODE这两个宏是为了告诉编译器，你的代码将使用Unicode版本的Win32 API函数，而不是ANSI版本。
理论上，只需要定义其中一个宏就可以了，因为另一个宏通常会被第一个宏自动定义。然而，为了清晰明了地表明你的代码是使用Unicode，建议同时定义这两个宏。这样可以避免可能的混淆和错误。
请注意，_UNICODE和UNICODE的定义方式有两种：
在源代码文件中使用#define预处理器指令定义。在编译选项中指定。例如，在Visual C++中，可以在项目设置中的“C/C++”选项卡下的“预处理器”中定义这两个宏。 在现代的 Windows 系统中，推荐总是使用 Unicode 版本，因为它支持更广泛的字符集，并且在很多情况下，使用 Unicode 版本的函数不需要额外的工作。然而，如果你在处理的都是 ASCII 字符，并且出于某种原因需要节省内存或处理速度，那么可以使用 ANSI 版本。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93a53e3255810cfba4f364d2621aab5a/" rel="bookmark">
			selenium元素定位失效的解决措施
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前期语法：from selenium import webdriver driver.find_element_by_id('//*[@id="kw"]').send_keys('python') driver.find_element_by_css_SELECTOR('#kw').send_keys('python') driver.find_element_by_name('wd').send_keys('python') driver.find_element_by_class('s_ipt').send_keys('python') time.sleep(3) driver.find_element_by_id('su').click() time.sleep(2) driver.find_element_by_link_text(新闻').click() 最新语法： from selenium import webdriver from selenium.webdriver.common.by import By url = 'http://www.baidu.com' import time driver = webdriver.Chrome() driver.get(url) driver.find_element(By.XPATH,'//*[@id="kw"]').send_keys('python') driver.find_element(By.CSS_SELECTOR,'#kw').send_keys('python') driver.find_element(By.NAME,'wd').send_keys('python') driver.find_element(By.CLASS_NAME,'s_ipt').send_keys('python') time.sleep(3) driver.find_element(By.ID,'su').click() time.sleep(2) driver.find_element(By.LINK_TEXT,'新闻').click() river.find_element(By.PARTIAL_LINK_TEXT,'hao').click() time.sleep(3) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e24c02b1d777dab8031d6c8c8c48489/" rel="bookmark">
			Where和having的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.省流概括2.查询优先级3.举例： 1.省流概括 where过滤行，having过滤分组having是在分组后对数据进行过滤where是在分组前对数据进行过滤having后面可以使用聚合函数where后面不可以使用聚合 2.查询优先级 在查询过程中执行优先级顺序：
from（联表）&gt; where &gt; group by（分组聚合）&gt; having &gt; order by
聚合语句指(sum,min,max,avg,count)
3.举例： 3.1 where子句：
select sum(num) as rmb from order where id&gt;10
//只有先查询出id大于10的记录才能进行聚合语句
3.2 having子句:
select reports, count() from employees group by reports having count() &gt; 4
//上例having条件表达示为聚合语句，having子句查询过程执行优先级低于聚合语句。
having就是来弥补where在分组数据判断时的不足。注意把上面的having换成where则会出错，因为统计分组数据时用到聚合语句，而where执行优先级别要高于聚合语句。
记住对分组数据再次判断时要用having。
3.3 Where、having同时出现在一个语句中时的相互影响案例：
摘自《Mysql必知必会》
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6945da1a1a729044e27cb0dd82e0981/" rel="bookmark">
			管理经济学基本概念(一): 成本、效益、盈亏等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、边际成本和边际效益 边际成本：一般用MC来表示
就是因多销售一单位产品而发生的增量成本。
边际收益：一般用MR来表示
就是由多销售已单位产品而得到的增量收益。
如果MC &gt; MR，减少销量
如果MC &lt; MR，增加销量
如果MC = MR，销量适当(获得最大利润)
能够增加边际收益或减少边际成本的激励薪酬计划将提供员工的工作努力程度。固定费用对于工作努力没有影响。
一个良好的激励薪酬计划把报酬与反映工作努力的绩效指标联系起来。
边际利润：就是多销售一单位的产品得到的增量利润。
边际利润 = MR - MC
2、平均成本 平均成本：AC
就是总成本(固定成本和变动成本)除以生产总量。
3、复利和贴现 3.1、贴现 贴现就是帮助我们对当前牺牲和未来获益之间的权衡而进行计算的一种工具。即能在投资前就知道未来的获益是否大于当前的牺牲。
现值 = (未来值，未来的k期) / (1+r) ^ k，其中r是收益率。
3.2、复利 复利是贴现的对立面，一般的计算公式如下：
(未来值，未来的k期) = (现值) * (1 + r) ^ k
其中r是收益率，如果我们按收益率r来投资，用72除以r就得到把你的钱翻一番所需要的年数。
4、NPV规则(确定投资能否赢利) 对一项投资的未来效益进行贴现，并与此项投资的成本相比较，如果差额为正即是净现值，即投资所得大于资本的成本。但是不是所有的公司都会用。
5、盈亏平衡分析 要计算盈亏平衡数量，必须区分边际成本(MC)和固定成本(F)，前者随销量的变化而变化，后者则不变。
Q = F / (P - MC) 固定成本 / 贡献毛利
F是年度固定成本，P是价格，MC是边际成本，Q是盈亏平衡数量。
盈亏平衡数量就是导致利润等于零的产销量。
销售的每一单位产品都会赚取贡献毛利(P-MC)，如此命名是因为这是销售一个单位的产品所赚取的数量。
产销量必须至少达到盈亏平衡数量才能使所得足以收回固定成本。
6、定价 总需求或市场需求就是一组消费者在某一给定价格上将要购买的商品总量。
MR &gt; MC：降低价格(增加销量) ，即通过降低价格来增加销量
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6945da1a1a729044e27cb0dd82e0981/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bd61db070e03ae79e18005973bca656/" rel="bookmark">
			fastJson配置的(FastJsonConfiguration)的作用 null装换成““ 或者是不返回null值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种解决办法 实际开发过程中，当我们返回json数据时,如果数据为空,那么默认返回null（因为ResponseBody这个注解底层就是使用的jackson）。毕竟程序员不喜欢null这个字眼。
那么我们如何不让他返回null呢？我们可以使用fastJson解决。fastJson是阿里巴巴的开源库，被誉为史上最快的Json解析库 首先请看查询结果
因为数据库中enName的值为空,所以查询出的结果就表示为Null。
那么我们如何不返回null，而返回一个" "空的字符串呢？其实很
简单，只需要增加fastjson配置替换默认的jackson配置即可。 下面贴出代码。
/** * @Description FastJson配置类 */ @Configuration public class FastJsonConfiguration implements WebMvcConfigurer { @Override public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) { /* 31 先把JackSon的消息转换器删除. 32 备注: (1)源码分析可知，返回json的过程为: 33 Controller调用结束后返回一个数据对象，for循环遍历conventers，找到支持application/json的HttpMessageConverter，然后将返回的数据序列化成json。 34 具体参考org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodProcessor的writeWithMessageConverters方法 35 (2)由于是list结构，我们添加的fastjson在最后。因此必须要将jackson的转换器删除，不然会先匹配上jackson，导致没使用fastjson 36 */ for (int i = converters.size() - 1; i &gt;= 0; i--) { if (converters.get(i) instanceof MappingJackson2HttpMessageConverter) { converters.remove(i); } } FastJsonHttpMessageConverter fastJsonHttpMessageConverter = new FastJsonHttpMessageConverter(); FastJsonConfig fastJsonConfig = new FastJsonConfig(); fastJsonConfig.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1bd61db070e03ae79e18005973bca656/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6499cc2e7cb3daaf2861d054ecf54b87/" rel="bookmark">
			最小生成树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Prim算法
算法思路：
1.对于所有的点，可以看作两个集合A和B，A中的点都是在最小生成树中的点，B是未加入最小生成树中的点。初始时随机选择一个点加入到A中，更新集合A到其他点的距离。
PS：集合A到其他点的距离比较抽象，这里举一个例子。点b是集合B中的一个点，现在更新集合A到b的点的距离，这个距离就是b与集合A中离他最近的那个点的距离。
2.每次选出一个离集合A最近的点，加入到集合A中，加上权值，然后更新集合A到其他点的距离。
3.更新n-1次就可以找到一个最小生成树了。
时间复杂度为：O(N^2)
空间复杂度为: O(N^2)
题目链接：【模板】最小生成树 - 洛谷
#include&lt;bits/stdc++.h&gt; #define inf 0x3f3f3f3f using namespace std; const int maxn = 5e3+10; int dis[maxn]; int mp[maxn][maxn]; int vis[maxn]; int n,m; void prim() { long long sum = 0; memset(dis,inf,sizeof(dis)); dis[1]=0; for(int i = 1;i&lt;=n;i++) { int id = -1,minn = inf; for(int j = 1;j&lt;=n;j++) { if(dis[j]&lt;minn&amp;&amp;!vis[j]) { minn=dis[j]; id=j; } } if(minn==inf) { cout&lt;&lt;"orz"&lt;&lt;endl; return ; } vis[id]=1; sum+=minn; for(int j = 1;j&lt;=n;j++) { if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6499cc2e7cb3daaf2861d054ecf54b87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff4782c6ff8c126aff7b334f8a53c2c3/" rel="bookmark">
			【2023NewStar】#Week1 Web和Crypto 全题解！涉及知识扩展~
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 2023NewStarCTFWeb泄露的秘密Begin of UploadErrorFlaskBegin of HTTP考点：对请求头的考察 Begin of PHPR!C!ELogin Cryptobabyrsa：考点：多素数rsa Vigeneresmall_d考点：低解密指数攻击 Baby_xor考点：异或 Affine考点：仿射密码 BabyEncodingbabyaes考点：异或 aes中cbc模式 2023NewStarCTF Web 泄露的秘密 www.zip Begin of Upload 打开源码 找到限制是在前端
我们抓包 上传正常后缀的文件 比如jpg结尾
但是这样传上去服务器是无法解析的
所以我们进行抓包 然后在bp中修改后缀名
将我们上传的后缀jpg在请求包中改为php 服务器就可以解析我们的语句了
一句话木马:&lt;?php eval($_POST['a']);?&gt;
然后进入到我们上传的这个文件中就可以rce啦
http://13878733-90ba-4e0c-9a0a-4ce861aaa1bf.node4.buuoj.cn:81/upload/aaa_b.php?b=system(%27cat%20/fllll4g%27);
ErrorFlask python中flask启的框架
输入非法字符，报错
在报错中找到源代码
Begin of HTTP 考点：对请求头的考察 POST /?ctf=ctfer HTTP/1.1 Host: node4.buuoj.cn:27705 //设置发起请求的浏览器 User-Agent: NewStarCTF2023 //设置只有本地用户才能访问 知识扩展 这些都可以用 Forwarded-For:127.0.0.1 Forwarded:127.0.0.1 X-Forwarded-Host:127.0.0.1 X-remote-IP:127.0.0.1 X-remote-addr:127.0.0.1 True-Client-IP:127.0.0.1 X-Client-IP:127.0.0.1 Client-IP:127.0.0.1 X-Real-IP:127.0.0.1 Ali-CDN-Real-IP:127.0.0.1 Cdn-Src-Ip:127.0.0.1 Cdn-Real-Ip:127.0.0.1 CF-Connecting-IP:127.0.0.1 X-Cluster-Client-IP:127.0.0.1 WL-Proxy-Client-IP:127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff4782c6ff8c126aff7b334f8a53c2c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bb3067a2e52d25939b5c5cebc25acfb/" rel="bookmark">
			恐怖，ChatGPT 王炸级更新，到底有多厉害
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们都知道哈，前几天 ChatGPT 进行了王炸级别的更新，也就是多模态功能。
简单来说，除了文本交互之外，ChatGPT 现在可以理解语音和图像了。
语音这个还好，不算什么，毕竟本质上还是 TTS 的技术，让文本和语音之间互相转化就行了，这应该不算难事。
但读取图像这个能力就有点逆天了，它不是那种以图搜图的传统模式，而是用 OCR 技术去真的识别用户发过去的图片，哪怕这个图片是用户现拍的、没有在网上出现过，ChatGPT 也能做出理解并调用大模型进行回应。
先让大家看个恐怖如斯的视频：
拍了自行车的照片问ChatGPT怎么调整座椅高度，你们可以感受一下什么叫恐怖如斯。
对了，根据 OpenAI 的说法，这个多模态版本在10个月前就训练好了，之前一直藏着。
今天一大早，我还看到一个有意思的内容，是 ChatGPT 对图片的识别，不仅仅只是识别，还能 ChatGPT 还能根据用户的提示和提问进行图片的编辑操作。
请看图片：
是不是被 ChatGPT 的图片处理能力惊到了！！！！！
点击下方公众号卡片，关注我
在公众号对话框，回复关键字 “1024”
免费领取副业赚钱实操教程
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a04bf6ae00b01c07648f99255ee6dea2/" rel="bookmark">
			sci投稿流程（从投稿到录用全流程解析）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文投稿流程 1.初稿:准备好论文，给编辑的信(cover letter） 2.返修: 一.会返回两个东西:
1）编辑的决定 (小修minior review，大修major review，拒稿reject等等)。只要不是审稿人质疑创新性问题和数据造假问题，一般编辑不会拒稿。
2）两位或更多审稿人的审稿意见 包括两部分:
第一部分是审稿人选择的选项，在创新性，语言，应用前景等方面，进行打分，或者选等级。大概有五到十项。等级有top5%，top30%等选项。这一部分至少要拿到top30%。这一部分，编辑给作者的信中，作者可以看见。在投稿系统中看不到。
第二部分是审稿人写给作者/编辑的信。也包括两部分
1是审稿人对于论文的整体评价，在信的第一段，有建议发表，建议修改后发表，不建议发表等等。只要不是创新性不够，或者审稿人质疑数据造假，一般不会拒稿。
2.是审稿人提出的修改意见，会分条，一般四五条。
先看整体意见，偏正面还是负面，再看分条意见好不好修改，需要补做什么实验?
原则:
1.针对性回答，不要说没用的无关的
2.能有数据的就用数据说话。实测实拍数据图片最好，仿真数据次之，无数据纯解释更次之。(能有视频更好了，nature子刊都有视频)
3.注意详略，哪些可以详细，哪些可以简略?可以参考nature子刊，有的peer review也会展现，可以参考他们怎么回复审稿人的。
有些与论文主题相关性不是很强，但是审稿人提出需要补充的，可以加到supportting information里。例如，对于衍射神经网络的超表面的单元结构及单元性能，单元斜入射性能，单元功耗等等。这种指标性很强的内容可以在supportting information里以列表展现（注意还是尽量有实测实拍至少是仿真数据）。展现方式类似于55所单片部和功率部的产品数据手册
另外，看一下类似论文的常用指标是什么，比如斜入射，功耗等等
这种常见指标，在投稿的时候就加上
二.我们返修的时候需要准备：
1.给编辑申请延期的信（extend deadline） 一般这个在投稿系统里有链接可以申请
如果给的返修时间太短，可以在系统里申请延期，一般编辑会同意的。注意，要在deadline之前申请，不能超过deadline再申请
话术：为了完成审稿人的修改意见，我们需要补做实验。因此，我们申请将deadline延迟x周/月，到xx年x月x号。
2.返修信（response letter） 返修信模板见附件
1）首先是对编辑说一段：Dear Editor,巴拉巴拉 感谢能有修改的机会，我们已经按照要求进行了修改，修改再manuscript中已经标红，等等等等。这一部分直接套用模板即可
2）然后对审稿人进行逐条回复 每条意见的回复要包括两部分
对审稿人的回复，Our Response:
和在原文中修改的地方，The modified sentence:
在原文中修改的地方很重要。编辑可能看不懂审稿意见和你回复审稿人了什么东西。他只会看你有没有根据审稿人的意见在原文中修改。
3）给编辑的cover letter 同上。
三.系统上提交返修的时候需要提交以下材料：
1.response letter（返修信，给编辑和审稿人的）
2.revised manuscript （修改标红）
3.cover letter to editor（给编辑的信）
4.support information（不适合在正文中展现的细节，加到补充材料里）
5.publication data
这是个啥东西？
是个压缩包
包括：
1.manuscript（修改后的，不标红）
2.supporting information
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a04bf6ae00b01c07648f99255ee6dea2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8cb280e1ae8c51959bd074ffb59d77b/" rel="bookmark">
			力扣第150题 逆波兰表达式求值 stack c&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 150. 逆波兰表达式求值
中等
给你一个字符串数组 tokens ，表示一个根据 逆波兰表示法 表示的算术表达式。
请你计算该表达式。返回一个表示表达式值的整数。
注意：
有效的算符为 '+'、'-'、'*' 和 '/' 。每个操作数（运算对象）都可以是一个整数或者另一个表达式。两个整数之间的除法总是 向零截断 。表达式中不含除零运算。输入是一个根据逆波兰表示法表示的算术表达式。答案及所有中间计算结果可以用 32 位 整数表示。 示例 1：
输入：tokens = ["2","1","+","3","*"] 输出：9 解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9 示例 2：
输入：tokens = ["4","13","5","/","+"] 输出：6 解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6 示例 3：
输入：tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"] 输出：22 解释：该算式转化为常见的中缀算术表达式为： ((10 * (6 / ((9 + 3) * -11))) + 17) + 5 = ((10 * (6 / (12 * -11))) + 17) + 5 = ((10 * (6 / -132)) + 17) + 5 = ((10 * 0) + 17) + 5 = (0 + 17) + 5 = 17 + 5 = 22 提示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8cb280e1ae8c51959bd074ffb59d77b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d262327f9655a55f18cc54d360224e4/" rel="bookmark">
			[官方培训]24-UE非线性动画制作流程 Epic 戴浩军 笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UE非线性动画制作流程 1.UE非线性动画制作流程的概念和价值 我们以《堡垒之夜》预告片白皮书中的核心观点为纲，回顾UE动画非线性流程的主要概念。
首先是明确流程目标，在开始设计制作流程之前，先明确以下目标。
明确的目标是流程设计的基础。
其次是设计工作流程，基于目标团队列出了以下制作任务。
实时流程和线性流程的差异
线性流程实时流程渲染方式离线线性渲染实时渲染主要制作工具各种DCC工具Unreal Engine工作流部门很少平行工作更多平行工作数据组织管理分散中心化开发模式拉版本按需获取及推送命名规则严格的比较自由版本资源控制手动自动管理更新迭代输出形式分层直接输出最终画面资源要求可以非常高精度需要优化 表格中有几项比较有代表性的差异值得稍作展开介绍，比如预渲染线性流程和次世代实时渲染非线性流程的渲染时机差异。
工作流的并行程度差异
项目开发和管理模式的差异
分层输出方面的差异
《堡垒之夜》的流程
第一单位可视化预览阶段
可以理解为角色动画实施3D分镜。
首先根据剧情通过临时占位资产搭建大致的场景布局。
然后请动作捕捉演员根据粗略场景进行首次动作表演，演员可以根据剧本进行多次演出，并通过Sequencer的take，也就是镜头试拍功能进行组织。导演可以随时决定并切换使用哪个take，并在未来以此为基础进行评审，重新动捕或截取动作。
这个阶段表现出了这个项目在动画制作方面的显著特点，就是相对于传统线性动画流程更倾向于将场景制作，3D镜头调整和角色动画分为明确的三个阶段。
实时流程更倾向于在同一个场地，同一个时间，根据最终效果实时调整场景，角色或镜头之间的关联。这跟拍摄真人电影的逻辑很相似。不同在于实时流程不仅可以灵活调度角色镜头，甚至场景也可以瞬间切换。
白皮书在这里也提到了Sequencer的具体组织形式，就是有一个完整的Level Sequencer动画序列。
为了方便管理和协作项目将所有关卡通过UE子关卡工具分为下列关卡：
其中分别包含各自的专用对象，然后一起包含在一个母关卡中。母关卡对应的是影视拍摄中的幕。通常可以是一个空关卡，然后根据需要添加相关的子关卡。这样可以更好的并行工作。
Sequence的具体组织结构
上图中的Sequence指的都是关卡序列资产，轨迹值得是序列中的的轨道，文件夹指的是Sequence工具中用来管理轨道的文件夹。引擎本身并不提供所谓序列结构的范本，完全靠开发者更具项目需要进行灵活组织。在团队间约定使用规则，并通过版本控制软件等工具确保多岗位并行协作。
此外白皮书中提到，在本项目中序列的划分遵循顶层主序列，幕序列和镜头序列。其中幕序列代表发生在同一时刻，同一场景会有相关性的场景中的多个镜头。而镜头序列则包含了当前镜头中出现的各类镜头动画轨道，角色动画轨道，特效动画轨道等。其中幕和镜头的概念和真实电影拍摄很相似，而场的概念则通过关卡来呈现。并在幕的序列中通过关卡可见性轨道来控制关卡的显示和隐藏。
在本项目中团队选择了只在顶级和幕级别的序列中添加关卡可见性，这也是和电影拍摄中根据幕来切换场的概念相吻合。如果在一个镜头中，某些场景元素需要被显示或隐藏，则更适合通过在镜头序列中对物体本身的可见性属性制作动画切换来实现。
和代表幕的序列需要合理拆分组织一样，代表场的关卡同样需要合理的组织。在本项目中前期阶段就会根据整个动画对场的定义进行相关关卡的创建和拆分。然后通过子关卡编辑器添加到主关卡中，这样才能够很灵活地通过主序列和幕序列中的关卡可见性轨道，根据当前的幕进行切换。此外在UE编辑器的世界大纲列表中可以选择关卡分类标签来显示当前场景中物体所在的关卡。方便我们随时观察随着关卡的显示隐藏哪些物体会一起切换。
接下来到了中期制作阶段，这个阶段的工作重心是在前期搭建的框架内制作并导入合适的美术资产。主要包括场景模型，角色模型，角色动画等主要使用两种格式的数据来导入DCC资产，分别为FBX和Alembic。可以感受到虽然实时流程为了提升流程效率缩减中间格式带来的成本，但基于当时的工具和技术条件，场景模型等美术资产依然需要依赖美术资产中间格式。一旦需求发生变化就必须回到DCC进行修改。
而在UE5中由于引用了建模模式。面对场景模型的小范围修改，还可以直接在UE编辑器中完成。跳过了DCC导出中间格式，再导入UE的过程。
灯光方面
UE5中有Lumen。
第三个阶段是特效和后期。
2.UE非线性动画制作流程典型案例分析 《动画实践指南》展开说明。
3.搭建UE非线性动画制作流程的一些建议 实时流程革新非常具有挑战，需要整个团队齐心协力团队本身就需要持续学习成长，实时动画流程提供了一个性价比很高并且有趣的目标基于作品学习技术，面向主创改进流程拥抱行业融合，发掘实时技术的综合价值共建虚幻社区，加强双向沟通 相关链接 《动画实践指南》白皮书《堡垒之夜预告片》白皮书虚幻引擎开发者社区 学习地址 地址
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e79d67400a98a95fe55cd3ad5e0d107d/" rel="bookmark">
			数学建模Matlab之优化类方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文还是来源于http://t.csdnimg.cn/P5zOD，但肯定不可能只有这些内容，否则那位作者应该会打我……，在这里，只是讲解优化类问题比较常用的方法，以TSP问题为例，适合入门。
模拟退火 模拟退火是一种概率算法，它从某个解出发，随机产生下一个解，并根据一定的准则来接受或拒绝新解，同时随着迭代的进行逐渐降低“温度”。
基础示例 %% 模拟退火 clc,clear % 模拟退火(求最小)。模拟退火是一种概率算法，它从某个解出发，随机产生下一个解 % 并根据一定的准则来接受或拒绝新解，同时随着迭代的进行逐渐降低“温度”。 temperature = 100; % 初始温度，开始时较高以接受更多的解。 final_temperature = 1; % 算法停止的最低温度。 time_temperature = 1; % 用来计算当前温度下已经迭代了多少步，作用类似于计数器。 time_tuihuo = 10; % 退火步长，是每个温度下的迭代步数。 cooling_rate = 0.95; % 是每次降温的比率。 % 初始化随机数生成器，以使结果具备可重复性 % rng(0,'twister'); % 生成范围a-b的随机数 a = -10; b = 10; % rang_math = (b-a).*rand(1000,1) + a;是初始解。 rang_math = (b-a).*rand + a; % 定义函数，求最小值 f = @(x)(x.^4 + 4.*x.^3 - x.^2); current_old = f(rang_math); while final_temperature &lt; temperature rang_math = (b-a).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e79d67400a98a95fe55cd3ad5e0d107d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4a1df428122b74031ebfc2418a9d5ac/" rel="bookmark">
			基于51单片机的超声波红外检测停车场管理车位系统proteus仿真程序设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		硬件设计 （末尾附文件）
仿真图1
基于超声波的车位检测系统 三个超声波检测三个车位，LCD显示剩余的车位，具有LED指示；：
仿真图2：
基于红外对管的车位检测系统，两个按键模拟红外对管，LCD显示剩余的车位，具有LED指示，车辆超出后蜂鸣器报警提示；
程序设计 软件设计是设计中很重要的部分。它关系到一个系统能否实现其预定的要求。
主程序设计
主程序是软件设计的总体框架，因此主程序的流程图的设计决定了程序编写的好坏，该主程序的功能是扫描键盘，作出逻辑判断，控制各种中断，数据送入显示模块。其流程图如图所示。
在判断车辆是否进出中：本系统使用了两个传感器，一个用来检测出去的车，一个检测进来的车。当两个传感器同时检测到车的时候，说明进出的是车辆。当一个传感器检测到车辆时，开门。当两个传感器都检测到时，通过逻辑判断，剩余车位数进行加减。
增加键
在此程序中，剩余车位不超过最大车位数.流程图如图所示：
主程序 #include &lt;reg52.h&gt;	//调用单片机头文件 #define uchar unsigned char //无符号字符型 宏定义	变量范围0~255 #define uint unsigned int	//无符号整型 宏定义	变量范围0~65535 #include &lt;intrins.h&gt; #include "lcd1602.h" sbit K1=P1^0; sbit K2=P1^1; sbit K3=P1^2; sbit K4=P1^3; sbit beep = P1^7; //蜂鸣器IO口定义 sbit SH = P3^5; sbit ST = P3^6; sbit DS = P3^7; uchar num_jin; uchar num_chu; uchar num_car; //1ms延时函数 void delay_1ms(uint q) { uint i,j; for(i=0;i&lt;q;i++) for(j=0;j&lt;120;j++); } //74HC595函数 void write_74hc595(unsigned int num) { int i;	ST = 0; for(i=0; i&lt;16; i++) { SH = 0; if (num &amp; 0x0001) {DS = 1;} Else {DS = 0;} SH = 1; num &gt;&gt;= 1; } ST = 1; } unsigned int num_2_led(unsigned int num) { int i; unsigned int ret=0; if (num &gt; 16) return 0xFFFF; for(i=0;i&lt;num;i++) { ret |= 1&lt;&lt;i; } return ret; } //独立按键程序 void key()	{ if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4a1df428122b74031ebfc2418a9d5ac/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/54/">«</a>
	<span class="pagination__item pagination__item--current">55/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/56/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>