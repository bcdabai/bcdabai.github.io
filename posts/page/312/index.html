<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/647b3fe8f4fe4888f945be84ed386053/" rel="bookmark">
			openwrt下wifi设置详细过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.缺省情况下，openwrt中的无线是关闭的，系统起来后，ifconfig和ifconfig -a, iwconfig均看不到wlan0接口
原始的wireless配置文件如下：
root@OpenWrt:/# cat /etc/config/wireless config wifi-device radio0
option type mac80211
option channel 11
option macaddr 00:90:4b:24:ff:2a
option hwmode 11ng
option htmode HT20
list ht_capab SHORT-GI-40
list ht_capab DSSS_CCK-40
# REMOVE THIS LINE TO ENABLE WIFI:
option disabled 1
config wifi-iface
option device radio0
option network lan
option mode ap
option ssid OpenWrt
option encryption none
root@OpenWrt:/# root@OpenWrt:/# cat /etc/config/network config 'interface' 'loopback'
option 'ifname' 'lo'
option 'proto' 'static'
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/647b3fe8f4fe4888f945be84ed386053/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33d83da469d9e1054b8c0df4dc9bf5e4/" rel="bookmark">
			Ember学习（2）：Ember的命名约定
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		英文原址：http://emberjs.com/guides/concepts/naming-conventions/
Ember.js使用命名约定来连接你的各种对象，从而避免使用过多的引用。你需要对你的route，controller和template使用这些约定。通常你可以推测哪些名字，但是这个指导集中地给出了一个大纲，包含了所有的命名约定。在下面的列子中，“App”是我们选定的命名空间，或者说它代表了你创建的Ember应用，但是你也可以为你的应用选择任何其他的名字。我们后面将会向你展示如何创建一个Ember应用，现在让我们先专心学习这些命名约定。
The Application（应用） 当你的应用启动时，Ember会寻找下面这些对象： App.ApplicationRouteApp.ApplicationController"application" template Ember.js会将“application” template当做主模板来显示。如果定义了App.ApplicationController，Ember会创建一个App.ApplicationController的实例，并将设定为application template的controller。这意味着，application模板可以从这个controller中获取数据。 如果你的应用定义了App.ApplicationRoute，Ember在显示application template之前会先调用router的钩子函数。Hooks（钩子函数）被实现成方法，给你提供了一个Ember对象生命周期的扩展接口，来插入你自己的代码以改变Ember默认的行为以满足你的需要。Ember提供许多的Hook来支持你各种不同的目的（比如model和setupcontroller hook）。在下面的例子中，App.ApplicationRoute，它是一个Ember.Route对象，实现了setupController钩子函数。 下面是一个简单的例子关于如何使用route，controller和template： App.ApplicationRoute = Ember.Route.extend({ setupController: function(controller) { // `controller` is the instance of ApplicationController controller.set('title', "Hello world!"); } }); App.ApplicationController = Ember.Controller.extend({ appName: 'My First Example' }); &lt;!-- application template --&gt; &lt;h1&gt;{{appName}}&lt;/h1&gt; &lt;h2&gt;{{title}}&lt;/h2&gt;在Ember应用中，你必须总是将你的controller指定成类，框架负责初始化它们，并且提供给你的模板。这使得测试你的controll变得非常简单，并且保证你的整个应用对于每种controller只共享一个对应controller的实例。 Simple Route（简单路由） 你的每个route都会有一个controller，还会有一个和route同名的template。让我们从一个简单的route开始： App.Router.map(function() { this.route('favorites'); });如果你的用户导航到“/favorites”，Ember会查找下面的对象： App.FavoritesRouteApp.FavoritesControllerthe favorites template Ember会将favorites模板显示在application模板的{{outlet}}中，还会为这个模板设置一个App.FavoritesController的实例。如果你的应用定义了App.FavoritesRoute，框架会在显示模板前调用它。你猜对了，这个过程会重复的递归下去。对于一个像App.FavoritesRoute这样的route，你可能会实现一个model钩子函数，来指定你的controller使用什么model供你的模板显示。下面是一个例子： App.FavoritesRoute = Ember.Route.extend({ model: function() { // the model is an Array of all of the posts return this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33d83da469d9e1054b8c0df4dc9bf5e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b440356ce2aa9664abe5e0c19c38f08/" rel="bookmark">
			Ember学习（1）：Ember核心概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近项目需要用来Ember，又要开始新的学习了，由于网上资料比较少，可以找到的基本都是英文，因此，这里对Ember官方网站的Guide进行边看边翻译，以方便自己深化理解。
英文原址：http://emberjs.com/guides/concepts/core-concepts/
开始学习Ember，你必须了解下面列举的一些核心概念。
Ember.js的设计目的是帮助开发者创建任意规模的Web应用，并使它的性能可以和本地App相媲美。为了这个目标，我们需要新的工具和新的概念。我们花了很多时间研究一些本地App框架（比如Cocoa和Smalltalk），从它们那里借用一些想法。
不过，重要的是我们必须记住是什么使Web如此的特殊。许多人认为某个东西被称为Web应用是因为它使用了HTML，CSS和Javascript。事实上，这些只是实现细节。相反，Web的力量来自它可以通过URL来标记和分享。URL是Web应用能够分享和合作的关键。现在，大多数的Javascript框架都把URL当做后来出现的东西来对待，而不是Web成功的主要原因。
Ember.js和它们不一样，它结合了工具还有本地GUI框架的概念，并且对让Web如此强大的URL提供良好的支持。
概念 Template（模板） template是用Handlebars模板语言编写的，用来描述你的应用的User Interface。每一个template背后都对应到一个model（模型），并且当model改变时template会自动更新自己。除了简单的HTML，template还可以包含： Expressions（表达式），像{{firstName}},它会从template的model那里获取信息并将它插入到HTML中。Outlets（占位符），它是其他template的占位符。当用户浏览你的应用，router（路由器）会将不同的template插入到outlet中。你可以使用{{outlet}} helper（帮助符）将outlet插入到你的template中。Components（组件），它是自定义的HTML元素，你可以使用它来清理重复的模板或者创建可复用的控件。
Router（路由器） Router负责将URL翻译成一系列嵌套的template，每个一个template都对应一个model。当显示给用户的template或者model发生改变，Ember会自动的更新浏览器地址栏中的URL。这意味着，在任一时刻，用户都可以分享使用URL来分享你的应用。当某人点击了这个链接，他们肯定可以看到和原用户一模一样的内容。 Components(组件) component是自定义的HTML元素，它的行为使用Javascript来实现，它的外观使用Handlebars模板来描述。有了component，你就可以创建可复用的控件，并简化你的应用的模板。 Models（模型） model是一个存储持久状态的对象。Template负责将model的数据转化为HTML以显示给用户。在许多应用中，model是通过HTTP JSON API来加载的，尽管如此，Ember对你选择使用那种方式来获取model是一无所知的。 Route（路由） route是一种可以告诉template它应该使用哪个model的对象。 Controllers（控制器） controller是存储应用状态数据的对象，template除了对应到一个model之外，还可以可选的对应到一个controller，并且可以从model和controller获取信息。 以上这些就是开发Ember.js应用所需要理解的核心概念，它们被设计成随着复杂度的提升可以方便向上扩展，因此新的功能被添加进来时，不会迫使你回去对你的应用做大的修改。现在你理解了这些对象的作用，你已经准备好了深入学习Ember.js，了解这些对象是如何在一起工作的。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f988fa6ec1cfaaaa63f61cf7168ccd0/" rel="bookmark">
			WPF(6)----窗口大小固定设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 WPF下如果希望界面大小固定不变时，设置很简单：
只需要将窗口中的Width/MaxWidth/MinWidth ， Height/MaxHeight/MinHeight 设置成两组一样的值，同时将 ResizeMode设 为 NoResize即可。
例子代码如下所示：
&lt;Window xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:s="clr-namespace:System;assembly=mscorlib" Title="MainWindow" Height="560" MaxHeight="560" MinHeight="560" Width="800" MaxWidth="800" MinWidth="800" ResizeMode="NoResize" WindowStyle="None" AllowsTransparency="True" Background="#00FFFFFF" &gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a507b44459b9513b7d9ae9b3e576420e/" rel="bookmark">
			开启RCP平台中osgi的console，用于查个插件状态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用eclipse插件开发RCP产品时，导出的RCP产品在运行时有可能出现插件引用失败情况，此时可在控制台开启osgi查看插件状态，并进行调试 开启RCP平台中osgi的console，用于查个插件状态： 1、在启动参数中增加 -console，使用脚本启动的在脚本中添加，使用exe启动的在rcp.ini文件中。添加若脚本中存在“&amp;”（linux下后台运行命令），则删除“&amp;”后再添加 2、确定plugins文件夹下存在下列插件，若不存在，则从对应版本eclipse中获取 org.apache.felix.gogo.command org.apache.felix.gogo.runtime org.apache.felix.gogo.shell org.eclipse.equinox.console 启动后在控制台输入回车，会出现OSGI&gt; 此时按下ss会显示当前插件列表 osgi&gt; ss "Framework is launched." id State Bundle 0 ACTIVE org.eclipse.osgi_3.9.0.v20130529-1710 1 ACTIVE org.eclipse.equinox.common_3.6.200.v20130402-1505 osgi&gt; 观察插件状态其中installed为已经安装但没有使用（无效状态），如果发现有installed状态的插件，手动启动start + 插件编号（id列），根据提示报出的错误情况，去排除错误，如start 1
插件的几种状态： 1)INSTALLED：安装完成，本地资源成功加载 2）RESOLVED：依赖关系满足，这个状态意味着这个Bundle要么已经准备好运行，要么是被 停止了。 3）STARTING：Bundle正在被启动，BundleActivator的start()方法已经被调用但是还没有 返回。 4）STOPPING：Bundle正在被停止，BundleActivator的stop()方法已经被调用但是还没有 返回。 5）ACTIVE：Bundle被成功启动并且在运行。 6）UNINSTALLED：bundle被卸载并且无法进入其他状态。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fb92c3b8b083018d1565b23bf7ee913/" rel="bookmark">
			Windows 8 和 OpenWRT 下查看 WiFi 属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从 Win7 到 Win8，部分 WiFi 属性被隐藏掉了，在图形界面上看不到……只好用命令行了：
netsh wlan show networks mode=bssid OpenWRT 上是：
iw dev wlan0 scan 转载于:https://my.oschina.net/umu618/blog/264935
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c12fe471bd012f9349a4fe7d870f6ee5/" rel="bookmark">
			遵照std::allocator实现自定制的内存分配器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面是标准库STL中allocator的实现
template&lt;class _Ty&gt;
class allocator
: public _Allocator_base&lt;_Ty&gt;
{ // generic allocator for objects of class _Ty
public:
typedef allocator&lt;_Ty&gt; other;
typedef _Allocator_base&lt;_Ty&gt; _Mybase;
typedef typename _Mybase::value_type value_type;
typedef value_type *pointer;
typedef const value_type *const_pointer;
typedef void *void_pointer;
typedef const void *const_void_pointer;
typedef value_type&amp; reference;
typedef const value_type&amp; const_reference;
typedef size_t size_type;
typedef ptrdiff_t difference_type;
#if _HAS_CPP0X
typedef false_type propagate_on_container_copy_assignment;
typedef false_type propagate_on_container_move_assignment;
typedef false_type propagate_on_container_swap;
allocator&lt;_Ty&gt; select_on_container_copy_construction() const
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c12fe471bd012f9349a4fe7d870f6ee5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f7f78eb3769c78c063fc2a6ac9cc6a0/" rel="bookmark">
			create temp table as from occur ora-600 处理一例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用户某个ETL 数据库在处理一个临时表时候出现建表失败并遭遇 ORA-00600 报错，具体信息如下：
Oracle Database 11.2.0.4.0 on suse linux 11 sp3
create table tmp_5302_ins_prf_agtlevel_3b as
select distinct a.company_cd, a.agent_level, a.INSURED_RNG_TYPE, b.INSURED_RNG_SUB_TYPE, b.INSURED_RNG_VALUE, a.minus_NOI
from (select company_cd, agent_level, INSURED_RNG_TYPE, NULL INSURED_RNG_SUB_TYPE, sum(case when INSURED_RNG_VALUE&lt;&gt;'z) Total' then INSURED_RNG_AVG_NOI end)-max(case when INSURED_RNG_VALUE&lt;&gt;'z) Total' then INSURED_RNG_AVG_NOI end) minus_NOI
from qs.tmp_5302_ins_prf_agtlevel_2 a where INSURED_RNG_TYPE='TENURE_RNG' group by company_cd, agent_level, INSURED_RNG_TYPE, NULL ) a, (select company_cd, agent_level, INSURED_RNG_TYPE, INSURED_RNG_SUB_TYPE, INSURED_RNG_VALUE
from --??RNG????????INSURED_RNG_VALUE (select company_cd, agent_level, INSURED_RNG_TYPE, INSURED_RNG_SUB_TYPE, INSURED_RNG_VALUE, row_number() over(partition by company_cd, agent_level, INSURED_RNG_TYPE order by INSURED_RNG_AVG_NOI desc) get_ind
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f7f78eb3769c78c063fc2a6ac9cc6a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e26acf1516ad92564089506b3b04449/" rel="bookmark">
			2G-3G-4G网络结构演进过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无线接入网：负责接收用户终端的无线信号，由此接入到通信网络；
核心网：对用户数据的管理及具体业务处理，并作为承载网络提供到外部网络的接口。
一、GSM网络结构（2G）
通常，我们所说的2G网络指的就是基于GSM的网络，它的结构主要由四部分构成：
移动台MS（Mobile Station），它的功能是负责无线信号的收发及处理；
基站子系统BSS（Base Station Subsystem），它属于接入网部分，由基站收发信台BTS（Base Transceiver Station）和基站控制器BSC（Base Station Controller）两部分构成。BTS通过Um空中接口收到MS发送的无线信号，然后将其传送给BSC，在BSC负责无线资源的管理及配置（诸如功率控制，信道分配等），然后通过A接口传送至核心网部分；
网络子系统NSS（Network and Switching Subsystem），它是核心网的核心部分，主要由MSC、VLR、HLR、AUC、EIR等功能实体组成。其中，移动业务交换中心MSC（Mobile service Switching Center）是NSS核心，负责处理用户具体业务；访问位置寄存器VLR（Visit Location Register）和归属位置寄存器HLR（Home Location Register）主要负责移动性管理及用户数据库管理的功能；鉴权中心AUC（Authentication Center）和设备识别寄存器EIR（Equipment Identity Register）主要负责安全性方面的功能；网关型GMSC负责提供接入外部网络接口；
操作管理系统OMS（Operations Management System），它主要负责网络的监视，状态报告及故障诊断等，在此不作具体介绍。
GSM网络结构图如下：
GSM数据业务：http://www.tlsun.com.cn/tc/index_menu2.asp?menu_serial=17&amp;menu_id=68
二、GPRS叠加网络结构（2.5G）
从GSM网络（2G）演进到GPRS网络（2.5G），最主要的变化是引入了分组交换业务。原有的GSM网络是基于电路交换技术，不具备支持分组交换业务的功能。因此，为了支持分组业务，在原有GSM网络结构上增加了几个功能实体，相当与在原有网络基础上叠加了一小型网络，共同构成GPRS网络。
接入网方面，在BSC上增加了分组控制单元PCU（Packet Control Unit），用以提供分组交换通道；
核心网方面，增加了服务型GPRS支持节点SGSN（Service GPRS Supported Node）和网关型GPRS支持节点GGSN（Gateway GPRS Supported Node），功能方面与MSC和GMSC一致，只不过处理的是分组业务，外部网络接入IP网；
从GPRS叠加网络结构开始，引入了两个概念。一个是电路交换域，一个是分组交换域，也就是我们常说的Cs域与Ps域。
GPRS叠加网络结构图如下：
三、UMTS网络结构（3G）
通信技术发展到3G，在速率发面有了质的提高，而网络结构上，同样发生巨大变化。
首先，伴随技术的发展，空中接口也随之改变。之前网络结构中的Um空中接口换成了Uu接口，而接入网与核心网接口也换成了Iu口；然后，在接入网方面，不再包含BTS和BSC，取而代之的是基站NodeB与无线网络控制器RNC（Radio Network Controller），功能方面与之前保持一致，在核心网方面基本与原有网络共用，无太大区别。
NodeB的功能：主要完成射频处理和基带处理两大类工作。射频处理：主要完成发送或接收高频无线信号，以及高频无线信号和基带信号的相互转换功能；基带处理：主要完成信道编/译码、复用/解复用、扩频调制及解扩/解调功能。
RNC的功能：主要负责控制和协调基站间配合工作，主要完成系统接入控制、承载控制、移动性管理、宏分集合并、无线资源管理等控制功能。
CS域：电路交换，主要包括一些语音业务，也包括电路型数据业务，最常见的是传真业务；
PS域：分组交换，主要是常见的数据业务，也包括流媒体业务、VOIP（voice over IP）等等。
UMTS网络结构图如下：
四、LTE网络结构（4G）
很多人说所谓的4G，即LTE技术不是一种演进，而是一场变革。其实，我们不需要太多的了解技术细节，但从网络结构方面，我们就能看出一二。
整个LTE网络从接入网和核心网方面分为E-UTRAN和EPC。首先，接入网方面，它不再包含两种功能实体，整个网络只有一种基站eNodeB，它包含了整个NodeB和部分RNC的功能，演进过程可以概括为：“少一层，多一口，胖基站”；其次，EPC（Evolved Packet Core）方面，它对之前的网络结构能够保持前向兼容，而自身结构方面，也不再有之前各种实体部分，取而代之的主要就换成了移动管理实体MME（Mobile Management Entity）与服务网关S-GW，分组数据网关，外部网络只接入IP网。
1.无线接入网：
少一层：四层组网架构变为三层，去掉了RNC(软切换功能也不复存在)，减少了基站和核心网之间信息交互的多节点开销，用户平面时延大大降低，系统复杂性降低；
多一口：以往无线制式基站之间是没有连接的，而eNodeB直接通过X2接口有线连接，可以以光纤为载体，实现无线侧IP化传输，使得基站网元之间可以协调工作。当eNodeB互连后，形成类似于“mesh”的网络，避免某个基站成为孤点，增强了网络的健壮性；
胖基站：eNodeB的功能由3G阶段的NodeB,RNC,SGSN,GGSN的部分功能演化而来，新加了系统接入控制、承载控制、移动性管理、无线资源管理、路由选择等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e26acf1516ad92564089506b3b04449/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c08efa24260342189c071a45097607b2/" rel="bookmark">
			myeclipse优化过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		优化方案主要有这么几个方面：去除无需加载的模块、取消冗余的配置、去除不必要的检查、关闭更新和设置内存等。
一、 去除不需要加载的模块
通过Windows - Preferences打开配置窗口，依次选择左侧的General --&gt; Startup and Shutdown，
这个时候在右侧就显示出了myEclipse启动时加载的模块，可以根据自己的实际情况去除一些模块。
建议关掉的启动项有：1）JSF/ICEfaces(看个人的需要)；2）大多数应用服务器(应用服务器只选需要的)；
3）Derby；4）两个自动更新Automatic Update；5）m2e Marketplace。
二、取消MyEclipse的拼写检查
拼写检查时，有时MyEclipse会提示单词拼写有错，给我开发带来麻烦，所以最好去掉。
windows --&gt; perferences --&gt; general --&gt; editors --&gt; Text Editors --&gt; spelling
取消Enable spell checking。
三、取消MyEclipse启动时的自动验证项目配置文件
一般来说，我们只需验证XML和JSF文件，其它的验证基本用不上。
取消方法：windows --&gt; perferences --&gt; MyEclipse --&gt; Validation
除XML和JSF外，其它的都可以不选。
点击Apply按钮，会弹出Validation Settings Changed提示。可以把所有Build部分的钩取消掉。
需要时可手动验证,方法：
在要验证的文件上，单击鼠标右键--&gt; MyEclipse --&gt; run validation；一样可以达到效果。
四、关闭Maven自动下载
windows --&gt; Perferences --&gt; MyEclipse --&gt; Maven4MyEclipse
关闭所有Download和Update开始的选项。
五、更改JSP默认打开的方式
安装MyEclipse后，打开JSP的编辑页面，有预览页面，速度很慢,可换掉编辑方式
windows --&gt; Perferences --&gt; General --&gt; Editors --&gt; File Associations
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c08efa24260342189c071a45097607b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8cc2babbfc79b309c0706d287157d9c/" rel="bookmark">
			boost的posix_time用法详解01
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		// boost_time.cpp : 定义控制台应用程序的入口点。 //made by davidsu33 //2014-5-11 //the usage of posix_time #include "stdafx.h" #include &lt;boost/date_time/posix_time/posix_time.hpp&gt; #include &lt;iostream&gt; #include &lt;cassert&gt; using namespace std; #define SHOW_VARIABLE(x)\ {\ cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;\ } void show_tm(std::tm &amp; atm) { cout&lt;&lt;"year="&lt;&lt;atm.tm_year&lt;&lt;" month="&lt;&lt;atm.tm_mon&lt;&lt;" day="&lt;&lt;atm.tm_mday&lt;&lt;endl; cout&lt;&lt;"hour="&lt;&lt;atm.tm_hour&lt;&lt;" minute="&lt;&lt;atm.tm_min&lt;&lt;" sec="&lt;&lt;atm.tm_sec&lt;&lt;endl; } //时间区间 void use_time_duration() { //mili-sec 毫秒 //mico-sec 微妙 //nano-sec 纳秒 //1hour 20minutes 30seconds 1000mico-seconds boost::posix_time::time_duration td(1, 20, 30, 1000); //cout&lt;&lt;"td="&lt;&lt;td&lt;&lt;endl; SHOW_VARIABLE(td); //根据所给的数值自动的进制 boost::posix_time::time_duration td2(1, 60, 60, 1000*1000*6); SHOW_VARIABLE(td2); boost::posix_time::time_duration td3(2, 1, 6); assert(td3 == td2); SHOW_VARIABLE(td3); //hours minutes seconds 分别从time_duration派生 boost::posix_time::hours h(2); boost::posix_time::minutes m(1); boost::posix_time::seconds s(6); boost::posix_time::time_duration td4 = h + m + s; assert(td4 == td3); SHOW_VARIABLE(td4); //duration_from_string std::string str = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8cc2babbfc79b309c0706d287157d9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac95f98141e3eacf7d5ceb9c29584a0a/" rel="bookmark">
			分享一个不错的题目“典型的最小生成树的应用”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Watering Hole My Tags (Edit) Source : USACO 2008 Open Time limit : 1 sec Memory limit : 64 M Submitted : 71, Accepted : 48
Farmer John has decided to bring water to his N (1 &lt;= N &lt;= 300) pastures which are conveniently numbered 1..N. He may bring water to a pasture either by building a well in that pasture or connecting the pasture via a pipe to another pasture which already has water.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac95f98141e3eacf7d5ceb9c29584a0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04157a9afae230c2b84c3857b19897f9/" rel="bookmark">
			vs使用(引用)第三方库的四种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在程序开发过程中，经常会引用第三方已经开发好的库(*.h,*.dll,*.lib),在visual studio中引用第三方动态库的四种方法：
1.直接将头文件和lib加入到项目工程中，如下图：
2.在项目工程文件中利用#pragma comment引用：
3.项目属性页--&gt;连接器--&gt;常规/输入
4.利用项目依赖性，具体步骤：项目属性页--&gt;通用属性--&gt;框架和引用
在下图中工程mod_crypto_swxa要引用mod_pkicore中的一些api
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65b198708562e564b0db2febcc7e5430/" rel="bookmark">
			QT积累
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用户对应用程序经常有这样的要求：要求它能记住它的settings，比如窗口大小，位置，一些别的设置，还有一个经常用的，就是recent files，等等这些都可以通过Qsettings来实现。
我们知道，这些settings一般都是存在系统里的，比如windows一般都写在系统注册表或者写INI文件，mac系统一般都在XML文件里，那么按照一般的标准来说，许多应用程序是用INI文件来实现的。而Qsettings就是提供了一种方便的方法来存储和恢复应用程序的settings。
QSettings的API是基于Qvariant，Qvariant是一种数据类型的集合，它包含了大部分通常的Qt数据类型，比如QString，QRec，QImage，等等。
当我们创建一个Qsettings的对象时，我们需要传递给它两个参数，第一个是你公司或者组织的名称，第二个事你的应用程序的名称。比如：
Settings = Qsettings(“MySoft”,”QtPad”)
公司名称：MySoft，程序名称：QtPad
假如我们在应用程序中多次要用到Qsettings，为了简单其间，我们可以在主程序中先如下声明。
QtCore.QCoreApplication.setOrganizationName("MySoft")
QtCore.QCoreApplication.setOrganizationDomain("mysoft.com")
QtCore.QCoreApplication.setApplicationName("QtPad")
当然前提是已经from PyQt4 import QtCore
然后在应用程序的任何地方想要声明一个Qsettings类型的变量，便不需要书写两个参数了，直接用settings = Qsettings即可。
那么如何用它来保持应用程序的settings信息呢？我们以字典数据类型与之类比，它也有key，以及对应的value。比如下面例子：
settings = Qsettings(“MySoft”,”QtPad”)
Mainwindow = QmainWindow()
settings.setValue(“pos”,QVariant(Mainwindow.pos())
settings.setValue(“size”,QVariant(Mainwindow.size())
上面两句就是把当前窗口的位置，和大小两个信息记录到了settings中，其中的key就是”pos”和”size”两个Qstring类型，而它所对应的值就是QVariant类型的。当然如果我们要写的key已在settings中存在的话，则会覆盖原来的值，写入新值。
如何读取Qsettings里的内容呢？如下：
Pos = settngs.value(“pos”).toPoint()
Size = settings.value(“size”).toSize()
当然如果key所对应的value是int型的，也可toInt(),如果没有我们要找的key，则会返回一个null QVariant如果用toInt的话会得到0。
那么实际应用中我们一般会如下：
pos= settings.value("pos", QVariant(QPoint(200, 200))).toPoint()
size= settings.value("size", QVariant(QSize(400, 400))).toSize()
self.resize(size)
self.move(pos)
意思是，如果settings里有以前存下的(用setValue设置的)pos和size的值，则读取，如果没有，不会返回null，而会使用我们给它的起始值——default value——即应用程序第一次运行时的情况。
注意：因为QVariant是不会提供所有数据类型的转化的，比如有toInt(),toPoint(),toSize(),但是却没有对Qcolor，Qimage和Qpixmap等数据类型的转化，此时我们可以用QVariant.value（），具体参看QVariant模块说明。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e0671b297672da3462b8f943356910a/" rel="bookmark">
			Mariadb源码编译过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从微博上看到有人提及Mariadb，搜索了一下，找到地址https://mariadb.org/，这是mysql的一个分支，由原作者维护，意在与oracle分庭抗礼，避免oracle将来毕源。
目前版本Mariadb 10.0.10，我下载了一个，准备编译一个64位版本，下载地址：
https://downloads.mariadb.org/mariadb/10.0.10/
下载后用cmake编译一下试试，进入cmake图形界面，编译器选择vs12.0 win64
Warning: Bison executable not found in PATH
这是警告未安装Bison，这个软件是unix下的，windows下可以不安装，不理了。
在cmake中generate，生成相关的文件。输出选择了build目录：
mariadb\mariadb-10.0.10\BUILD 目录下一堆的东西
选all build这个cmake生成的文件试试。
编译错误。。。sql_local.cc编译错误，太常见了，与前期编译mysql官方版本一样。处理方式早已驾轻就熟：
1）用word打开sql_local.cc,直接保存即可,此时文件头部,被添加了不可见字符,标示utf8编码文件；
2）修改mysql.cc文件,找到test_lc_time_sz()函数，注释掉语句 DBUG_ASSERT(0);
这两个修改完成后，编译成功。
编译后可以输出到install目录，直接执行install失败，需要一些技巧处理install
打开install工程，里面其实是一个命令行脚本，直接copy出来做完doinstall.bat
setlocal
"C:\Program Files (x86)\CMake 2.8\bin\cmake.exe" -DBUILD_TYPE=$(Configuration) -P cmake_install.cmake
if %errorlevel% neq 0 goto :cmEnd
:cmEnd
endlocal &amp; call :cmErrorLevel %errorlevel% &amp; goto :cmDone
:cmErrorLevel
exit /b %1
:cmDone
if %errorlevel% neq 0 goto :VCEnd
原来是执行cmake_install.cmake
修改里面的输出目录为：F:\Program Files\MySQL（确实是C:\Program Files\MySQL，在C盘不太好）
直接命令行执行，发现有个宏没有定义，增加：
增加了一行：
SET(CMAKE_INSTALL_CONFIG_NAME "Debug")
还有若干pdb需要手工copy，然后就install成功了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e0671b297672da3462b8f943356910a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e395fcef208e8f8d8ab50050f2c4187/" rel="bookmark">
			Android WebView开发中无法调音量的问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在开发浏览器的过程中，发现打开视频的时候，无法调音量，最后发现是keyCode == KeyEvent.KEYCODE_BACK里面的问题。
如果return true，那么就结束了事件，相当于屏蔽了音量键。但是不return true，就要加以判断是否是多次按下。总之还不如从简考虑：
public void onBackPressed() {if (mWebView.canGoBack() &amp;&amp; goBackflag) {Print.PrintSys("goback-----" + mWebView.canGoBack());mWebView.goBack();} elsethis.finish();} 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ec7288a2ef95e5ada8844fd42f5e4c0/" rel="bookmark">
			udp协议和tcp协议的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 面向连接的TCP“面向连接”就是在正式通信前必须要与对方建立起连接。比如你给别人打电话，必须等线路接通了、对方拿起话筒才能相互通话。TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来，其中的过程非常复杂，我们这里只做简单、形象的介绍，你只要做到能够理解这个过程即可。我们来看看这三次对话的简单过程：主机A向主机B发出连接请求数据包：“我想给你发数据，可以吗？”，这是第一次对话；主机B向主机A发送同意连接和要求同步（同步就是两台主机一个在发送，一个在接收，协调工作）的数据包：“可以，你什么时候发？”，这是第二次对话；主机A再发出一个数据包确认主机B的要求同步：“我现在就发，你接着吧！”，这是第三次对话。三次“对话”的目的是使数据包的发送和接收同步，经过三次“对话”之后，主机A才向主机B正式发送数据。TCP协议能为应用程序提供可靠的通信连接，使一台计算机发出的字节流无差错地发往网络上的其他计算机，对可靠性要求高的数据通信系统往往使用TCP协议传输数据。面向非连接的UDP协议“面向非连接”就是在正式通信前不必与对方先建立连接，不管对方状态就直接发送。这与现在风行的手机短信非常相似：你在发短信的时候，只需要输入对方手机号就OK了。UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。比如，我们经常使用“ping”命令来测试两台主机之间TCP/IP通信是否正常，其实“ping”命令的原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包，如果数据包是否到达的消息及时反馈回来，那么网络就是通的。例如，在默认状态下，一次“ping”操作发送4个数据包（如图2所示）。大家可以看到，发送的数据包数量是4包，收到的也是4包（因为对方主机收到后会发回一个确认收到的数据包）。这充分说明了UDP协议是面向非连接的协议，没有建立连接的过程。正因为UDP协议没有连接的过程，所以它的通信效果高；但也正因为如此，它的可靠性不如TCP协议高。QQ就使用UDP发消息，因此有时会出现收不到消息的情况。TCP协议和UDP协议各有所长、各有所短，适用于不同要求的通信环境。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e80e922d27ccf974b008038aa853ede/" rel="bookmark">
			由于目标机器积极拒绝，无法连接(一种变态问题)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于目标机器积极拒绝，无法连接（解决方法）
一、系统环境
操作系统： Win7 X64
SVN服务端：VisualSVN
SVN客户端：TortoiseSVN
具体安装步骤及配置网上又很多，在这里就不赘述了，这里有两篇文章写得很详细
1.http://blog.csdn.net/guowenyan001/article/details/9815249
2.http://www.cnblogs.com/xiaobaihome/archive/2012/03/20/2407610.html
我把我的笔记本既当服务器又当客户端，咦？我怎么会有这么变态的想法，反正想起来就试一试呗，要不然以后又得感叹时间都去哪了？
二、出现问题（如下图）
是不是很想砸电脑，配置了半天到这居然不好使了，你积极拒绝个毛线啊！我被这个问题困扰了一宿，现在已经凌晨1点04分了，终于解决了了，当我知道了答案，我把电脑粉碎的心都有了
三、解决方案
1.错误的输入
2.正确的输入
发现亮点了没有，有没有砸电脑的冲动！（都是s惹的祸）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52c3efde9dedbde0c6ef42b74f063b49/" rel="bookmark">
			capture 16.3精简版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 http://www.amobbs.com/thread-5537116-1-1.html 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74542fb26834008bbbb24c8564f0a97e/" rel="bookmark">
			整数反转的递归算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目：把整数反转，结果保存到一个整数数组，如：
输入：12345
输出：[5,4,3,2,1]
#include "stdafx.h" #include &lt;iostream&gt; using namespace std; #define INT_LENGTH 20 ///反转整数 ///n 输入的待反转的整数 ///result 保存结果的数组指针 ///int 型的返回值 表示递归的深度，也就是整数的位数 int ReverseInteger(int n,int * result) { *result++=n%10; if(n/10==0) { return 1; } else { return 1+ReverseInteger(n/10,result); } } //打印结果 void PrintResult(int * result,int len){ for(int i=0;i&lt;len;i++) cout&lt;&lt;result[i]&lt;&lt;" "; } int _tmain(int argc, _TCHAR* argv[]) { int n=123405; //初始化 int *result = new int[INT_LENGTH]; for(int i=0;i&lt;INT_LENGTH;i++) result[i]=0; int len = ReverseInteger(n,result); PrintResult(result,len); delete []result; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd2cdeaa5476de19178fe26396f7acc5/" rel="bookmark">
			卡巴斯基实验室发布其最新虚拟化安全解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		卡巴斯基实验室即将于近日发布其最新虚拟化安全解决方案。大连航远科技发展有限公司也在第一时间得知了这个信息。该方案旨在为vmware、citrix和microsoft虚拟平台提供领先保护，适用于vmware esxi 5.1和5.5 虚拟化平台，microsoft hyper-v server 2008 r2 / 2012虚拟化平台以及citrix xenserver 6.0.2 / 6.1 虚拟化平台。据悉，这项全新的轻代理技术是卡巴斯基实验室专为microsoft hyper-v 和citrix xenserver用户打造的首款优化安全解决方案。此次推出的新产品与卡巴斯基实验室另一款业内领先产品——针对vmware vsphere用户的无代理虚拟安全解决方案互为补充，满足不同用户的需求。大连航远科技发展有限公司非常认可这种解决方案。
与现有的无代理和基于代理的虚拟安全模式相比，这款新品所具有的四大突出优势能够为用户提供最佳的虚拟安全解决方案。
优势一：出众的性能
“基于代理”的安全方案不仅会导致计算机资源被无端占用，降低虚拟机的固结比，更减少了企业对虚拟化项目的总体投资回报率。此外，由于“防护间隙”的存在，“基于代理”的方案很容易使虚拟机受到攻击。与之形成鲜明对比的是卡巴斯基实验室这项全新的轻代理技术。在轻代理模式下，几乎所有的资源密集型安全进程都是由专门的虚拟设备在虚拟化平台层面执行。这种即时的应用可以疏导虚拟网络流量与文件。因此，虚拟机在创建之时就能够得到最新更新的安全保护，并且无需将多余的反恶意软件数据库备份推送给每台虚拟机。卡巴斯基实验室的智能扫描技术还能避免重复扫描同一文件，以释放更多系统资源。
优势二：极强的安全防御功能
卡巴斯基网络安全解决方案——虚拟化安全|轻代理模式之所以被称为“轻代理”，是因为它会在每台虚拟机上安装一个小型的软件代理。这样一来，轻量的代理就可以实现大量的安全功能，从而保障虚拟网络的安全。它不仅包含应用控制、设备控制、网页使用策略、基于主机的入侵防御系统和防火墙等先进的保护技术，还融合了卡巴斯基实验室无代理安全方案中的所有安全防护功能，如启发式的文件分析功能，以及通过卡巴斯基安全网络得到有关新型威胁和恶意应用的云情报。
正是这些全面的安全防护功能弥补了无代理的安全方案在安全方面存在的不足，让轻代理成功实现性能与安全防护之间的理想平衡。
优势三：轻松管理
卡巴斯基实验室的虚拟化安全产品融合了安全技术、便捷管理和平台兼容三大特点，能够带给客户无可比拟的使用体验。大连航远科技发展有限公司希望在未来的发展中能通过这种产品为客户提供安全高效的解决方案。通过卡巴斯基网络安全中心的管理平台，只需在同一页面就能管理卡巴斯基网络安全解决方案——虚拟化安全以及卡巴斯基实验室针对物理机的其他解决方案。它将物理和虚拟网络状态完整呈现于it管理员眼前，便于其抵御安全威胁，完成日常管理任务，更无需在不同页面间来回切换。大连航远科技发展有限公司又得知无论是使用卡巴斯基实验室虚拟化安全的无代理模式或轻代理模式，亦或二者兼用，it管理员都可以通过一个统一管理平台控制整个卡巴斯基实验室的安全解决方案，并且还可以轻松管理物理与虚拟平台之间或者两个虚拟平台之间的任何迁移。
优势四：灵活的许可方式
卡巴斯基实验室为其虚拟化安全产品提供统一的许可。企业用户只需购买一个卡巴斯基网络安全解决方案——虚拟化安全的许可，就可以同时享受到双重安全方案——无代理模式和轻代理模式。大连航远科技发展有限公司非常欣赏这种灵活的许可方式。这种灵活多样的许可模式让企业用户可以根据“每台虚拟机”（已知虚拟服务器和桌面所需许可的准确数量）或“每个内核”（已知客户虚拟硬件中cpu数量）来购买许可。这为企业用户提供了灵活的空间，从而能够按需拓展企业网络。 来自 “ ITPUB博客 ” ，链接：http://blog.itpub.net/29622450/viewspace-1151042/，如需转载，请注明出处，否则将追究法律责任。 转载于:http://blog.itpub.net/29622450/viewspace-1151042/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c07f5b733038667b27adc4b97d89bd5b/" rel="bookmark">
			boost的scope_exit的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		boost的scope_exit中1.4.9的版本和1.5.5的版本差异很大，以前boost1.4.9的scope_exit不支持this_指针，而且1.4.9版本对scope_exit的参数都是通过()隔开，例如
boost 1.4.9版本的scope_exit的写法，变量必须使用()
BOOST_SCOPE_EXIT((&amp;commit))
{
}BOOST_SCOPE_EXIT_END
而且1.4.9不支持this指针，所以我设计了一个宏来解决该问题
#define CREATE_THIS(class) \
class* this_ = const_cast&lt;class*&gt;(this);
通过这个来解决没有this提供的问题
然而boost1.5.5的版本做了很大的改进，更符合函数调用方式，提供了多参数的参数输入，并且提供了this_来访问成员属性和成员方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/162fd7fcec1b35d3ae2ad55247efe479/" rel="bookmark">
			oracle中 unino，union all,minus,intersect的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.准备测试数据 准备测试表：test_minus_tbl create table test_minus_tbl( id varchar2(20), name varchar2(50), age int ); alter table test_minus_tbl add constraint pk_minus_tbl primary key(id); create sequence seq_test_minus_tbl increment by 1 start with 1 maxvalue 99999999 minvalue 1 nocycle nocache;准备测试数据 insert into test_minus_tbl(id, name, age)values(seq_test_minus_tbl.nextval, 'lxl', 26); insert into test_minus_tbl(id, name, age)values(seq_test_minus_tbl.nextval, 'lxl', 26); insert into test_minus_tbl(id, name, age)values(seq_test_minus_tbl.nextval, 'lxl_01', 26); insert into test_minus_tbl(id, name, age)values(seq_test_minus_tbl.nextval, 'lxl_02', 26); insert into test_minus_tbl(id, name, age)values(seq_test_minus_tbl.nextval, 'lxl_01', 26); insert into test_minus_tbl(id, name, age)values(seq_test_minus_tbl.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/162fd7fcec1b35d3ae2ad55247efe479/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8859c060e277a5cfb65195677814f78f/" rel="bookmark">
			链接器link.exe 编译器cl.exe 资源编译器rc.exe
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		更多精彩图形学视频教程，请访问 http://www.oxox.work/
1.cl.exe文件是Visual C\C++的编译器，它将程序源代码文件编译为obj文件。
2.rc.exe文件是资源编译器。工程项目中的．rc文件中包含了对程序中所使用资源（菜单、图标等）的描述。rc.exe将．rc格式的文件编译为.res文件，供链接器链接到可执行文件中。
3.link.exe是Windows平台的链接器，它将cl.exe编译生成的obj文件，资源编译器生成的.res文件，以及lib目录下的lib文件等链接成可执行的exe文件、dll文件等。
在程序编译完成后，生成的文件是以obj为扩展名的对象文件，link.exe是将对象文件和库链接起来以创建可执行程序文件或动态链接库文件的工具。
link.exe的输入文件包括obj文件、lib文件、exp文件、def文件、res文件、txt文件、ilk文件。输出文件是exe文件、dll文件、sys文件等可执行程序文件。
其他工具
1．BSCMAKE．EXE
生成一个信息文件(．bsc)，用于浏览程序中的符号（类、函数、数据、宏和类型）信息。可以在集成开发环境的浏览窗口中查看这些信息（.bsc文件也可以在IDE中生成）。
2． LIB．EXE
用于生成COFF格式的lib库文件，可用于创建导出文件和引用导出定义的导入库，在为其他开发人员提供开发接口时非常有用。
3． EDITBIN.EXE
可用于编辑COFF格式的二进制文件。
4．DUMPBIN.EXE
可显示COFF二进制文件的有关信息，比如符号表等。
比如，使用dumpbin.exe分析第1章的start.exe。选择“工具”→“Visual Studio命令提示”切换到start.exe所在的目录，运行：
在bin_info.txt中包含了可执行文件中非常丰富的信息，包括文件头信息、节信息等。
5． NMAKE.EXE
程序维护实用工具，读取和执行生成文件。将在3.3节中详细
介绍nmake的使用。
6． ERRLOOK．EXE
错误查找工具，与GetLastError API函数配合使用，在程序调试时起到了很多的作用，用于分析Windows API的调用错误。如图3-1所示，在Visual Studio IDE中，可以通过菜单“工具”→“错误查找”来使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ec1e3b03f627f91a8e6dfefec5681bc/" rel="bookmark">
			True or False? and WHY??? Java HashSet Contains
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import java.util.HashSet; public class MyClass { public String s; public MyClass(String s) { this.s = s; } public int hashCode() { return s.hashCode(); } public boolean equals(Object obj) { if(obj == null) return false; if(!(obj instanceof MyClass)) return false; MyClass other = (MyClass)obj; if(s == null) { return false; } return(s.equals(other.s)); } public static void main(String[] args) { HashSet&lt;MyClass&gt; set = new HashSet&lt;MyClass&gt;(); MyClass mc1 = new MyClass("a"); set.add(mc1); mc1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ec1e3b03f627f91a8e6dfefec5681bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2632023db601bdc0afd4d2a2d19213e3/" rel="bookmark">
			繞過linux Driver Vermagic檢查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在開發kernel driver時，總是會遇到討人厭的vermagic檢查，只要目前在run的kernel版本跟driver編譯時用的kernel版本不一致，就沒辦法insmod。
bash-3.2# insmod sdio.ko sdio: version magic '2.6.28-271-gec75a15 preempt mod_unload modversions ARMv7 ' should be '2.6.28 preempt mod_unload ARMv7 ' insmod: init_module 'sdio.ko' failed (Exec format error) 這大大降低了開發速度，尤其是當你拿不到客戶在用的kernel時，又要開發driver給他用，真的是很麻煩……
那麼要怎麼利用噁心的方式繞過去呢???
一、先把 Moudle version 檢查關掉。 user@host # ARCH=arm make menuconfig --- Enable loadable module support │ │ │ │ [ ] Forced module loading │ │ │ │ [*] Module unloading │ │ │ │ [*] Forced module unloading │ │ │ │ [ ] Module versioning support │ │ │ │ [ ] Source checksum for all modules 二、 使用modinfo時，可以看到目前這driver的vermagic filename: external_drivers/omap3530/Linux/sdio/sdio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2632023db601bdc0afd4d2a2d19213e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfdc9460d333c0b4cdf79670a1ebe66e/" rel="bookmark">
			C#中keybd_event 用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows提供了一个模拟键盘API函数Keybd_event（），该函数能触发一个按键事件，也就是说会产生一个WM_KEYDOWN或WM_KEYUP消息。 [DllImport("user32.dll", EntryPoint = "keybd_event")]
public static extern void keybd_event(
byte bVk, //虚拟键值
byte bScan,// 一般为0
int dwFlags, //这里是整数类型 0 为按下，2为释放
int dwExtraInfo //这里是整数类型 一般情况下设成为 0
); 使用方法：
keybd_event((byte)Keys.LWin, 0, 0, 0); //按下LWIN
keybd_event((byte)Keys.D, 0, 0, 0); //按下D
keybd_event((byte)Keys.LWin, 0, 2, 0); //释放LWIN
keybd_event((byte)Keys.D, 0, 2, 0); //释放D
补充：
1.调用API函数记得引用：using System.Runtime.InteropServices;
2.常用模拟键的键值对照表。
键盘键与虚拟键码对照表
字母和数字键　数字小键盘的键　功能键 其它键 键　键码　键　键码　键　键码 键　键码 A　65　0 96 F1 112 Backspace 8 B　66　1　97 F2 113　Tab 9 C　67 2 98 F3 114　Clear 12 D　68　3　99 F4 115　Enter 13 E　69 4 100　F5 116　Shift　16 F　70 5 101　F6 117　Control 17 G　71 6　102　F7 118 Alt 18 H　72 7 103　F8 119　Caps Lock 20 I　73 8 104　F9 120　Esc 27 J　74 9　105　F10　121　Spacebar　32 K　75 * 106　F11　122　Page Up　33 L　76 + 107　F12　123　Page Down 34 M　77 Enter 108　-- --　End 35 N　78 -　109　-- -- Home　36 O　79 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfdc9460d333c0b4cdf79670a1ebe66e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb5a948fd6d6584a62502dead445455e/" rel="bookmark">
			LVM/RAID
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LVM Logical Volume Manager 逻辑卷管理
屏蔽了底层磁盘布局，便于调整磁盘容量
相对传统分区方式的优点
1.空间利用率高
2. 可以在线扩张容量
3. 数据备份方便
4. 可随意定义逻辑卷卷标
缺点：一个磁盘坏了，整个逻辑卷全部崩溃
注：/boot分区用于存放引导文件，不能应用LVM机制
对比
传统分区：磁盘——&gt;建立分区——&gt;格式化分区（建立文件系统）
LVM：磁盘——&gt;(分区）——&gt;PV——&gt;VG——&gt;LV——格式化
基本概念
PV （physical volume ，物理卷）
整个磁盘，或普通分区
包括许多默认4MB大小的PE (physical extents ，基本单元）
VG (Volume Group , 卷组）：一个或多个物理卷组合而成的整体
LV （Logical volume , 逻辑卷）：从卷组中分割出的一块空间，用于建立文件系统
LE（logical extents) 与PE大小相同并一一对应
管理命令
pvmove
#pvmove [物理卷] 移动物理卷组进行数据迁移
#pvcreate [设备]/[分区] #vgcreate [卷组] [物理卷1] [物理卷2]
#vgextend [卷组] [物理卷1] [物理卷2]
#vgreduce [卷组] [物理卷1] [物理卷2]
#lvcreate -L 大小 -n 逻辑卷名 卷组名
:#pvceate/dev/sd{b,c,d}1 = #pvceate /dev/sdb1 /dev/sdc1 /dev/sdd1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb5a948fd6d6584a62502dead445455e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a28f39daf05949fa1b73c1b3395b5dc3/" rel="bookmark">
			VS MONO Android开发控件悬浮显示提醒 自定义背景颜色、字体、数字颜色、摆放位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		axml
&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"android:layout_width="match_parent"android:layout_height="match_parent"android:orientation="vertical"&gt;&lt;Buttonandroid:layout_width="fill_parent"android:layout_height="wrap_content"android:id="@+id/button1"android:text="button1" /&gt;&lt;/LinearLayout&gt; Activity1.cs
using System;using Android.App;using Android.Content;using Android.Runtime;using Android.Views;using Android.Widget;using Android.OS;using Android.Graphics;using Android.Util;namespace myBadge{[Activity(Label = "myBadge", MainLauncher = true, Icon = "@drawable/icon")]public class Activity1 : Activity{View target;BadgeView badge;protected override void OnCreate(Bundle bundle){base.OnCreate(bundle); SetContentView(Resource.Layout.Main);target = FindViewById&lt;View&gt;(Resource.Id.button1);Button btn = FindViewById&lt;Button&gt;(Resource.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a28f39daf05949fa1b73c1b3395b5dc3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a78c1bc745ef59bb897da5c9b343cf81/" rel="bookmark">
			C#——详析GetHashCode方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GetHashCode函数一般是在操作HashTable或者Dictionary之类的数据集的时候被调用，目的是产生一个Key，为了方便在 HashTable或者 Dictionary中的检索。 每个类型，不管是值类型还是引用类型，都提供这个基本函数，同样也可以像重写ToString或者Equals函数一样去重写它。但是不建议重写此函数，而且在使用这个函数也需要加倍小心。
对于GetHashCode来说，要满足如下三点，这也是判断一个GetHashCode函数是否有效的标准。
第一，两个相等的对象，通过GetHashCode函数产生的结果要相 等，此外两个不相等的对象，通过GetHashCode函数的返回值要不相等；否则，通过其产生HashCode而存入HashTable中的数据就无法 取出来了。
第二，对于一个类型的对象来说，其GetHashCode函数的返 回值要自始至终要保持一致。否则，和第一点一样。
第三，在 GetHashCode函数中需要提供一个比较好的哈希函数，也就是在最小的范围内来实现数据分散，换句话说它的离散度决定HashTable存取效率。
对于引用类型自带的GetHashCode函数来说，基本上是正确的，但是效率不高；而对于值类型自带的GetHashCode函数而言，基本上是不正确的，即使正确也是效率不高。
首先说说引用类型自带的GetHashCode函数实现。一个.Net程序在运行的时候会对引用类型的对象进行标记，大致操作类似如下：标记起始为0，当创建一个引用类型对象的时候，标记会自动加一，对象释放后标记并不做减一操作，这有点儿像数据库中的自增字段。
这也就是为什么说引用类型的GetHashCode函数基本是正确的原因。对于第一条来说，如果类型没有重载Equals或者Operator==函数的话，类型自带的Equals函数只是在对象引用层进行验证，也就是说，一个对象等于另外一个对象就说明这个对象要么是另外一个对象的引用，要么另外一个对象是这个对象的引用。这说明没有新的引用对象产生，那么当引用标记也不会发生变化，所以对于第一条来说满足（如果要是重载了Equals或者Operator==函数的话，那么相应要提供此版本的GetHashCode函数，这一点在后面进行叙说）。至于第二条来说，由于对象数据成员发生改变不会影响到引用标记的改变，所以对于第二条来说也是满足的。对于第三点来说，由于引用标记是相对于整个程序而言的，并不是类型所特有的，那么它的效率不高是不言而喻的。
那么对于值类型自带的GetHashCode函数呢，就更有趣了，为了更形象地说明它的有趣，请先参看如下的代码，猜猜Debug的输出是什么。
C#代码 public struct ErrorMessage { private string strMsg; private int nErrorCode; private DateTime dtInvoked; public bool TestHashCode() { return this.GetHashCode() == strMsg.GetHashCode(); } } // Test "GetHashCode" function in value type ErrorMessage err = new ErrorMessage( "Test", 0 ); if( err.TestHashCode() ) Debug.WriteLine( "Both hash code equal!" ); else Debug.WriteLine( "Not equal!" ); 可能谁都没有想到，Debug中的输出是“Both hash code equal!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a78c1bc745ef59bb897da5c9b343cf81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fbc9ef8194b0d6feb1b3b2681c7c815/" rel="bookmark">
			H3C交换机典型（ACL）访问控制列表配置实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、组网需求： 1．通过配置基本访问控制列表，实现在每天8:00～18:00时间段内对源IP为10.1.1.2主机发出报文的过滤； www.jb51.net 2．要求配置高级访问控制列表，禁止研发部门与技术支援部门之间互访，并限制研发部门在上班时间8:00至18:00访问工资查询服务器； 3．通过二层访问控制列表，实现在每天8:00～18:00时间段内对源MAC为00e0-fc01-0101的报文进行过滤。 二、组网图： 三、配置步骤： H3C 3600 5600 5100系列交换机典型访问控制列表配置 共用配置 1．根据组网图，创建四个vlan，对应加入各个端口 &lt;H3C&gt;system-view [H3C]vlan 10 [H3C-vlan10]port GigabitEthernet 1/0/1 [H3C-vlan10]vlan 20 [H3C-vlan20]port GigabitEthernet 1/0/2 [H3C-vlan20]vlan 30 [H3C-vlan30]port GigabitEthernet 1/0/3 [H3C-vlan30]vlan 40 [H3C-vlan40]port GigabitEthernet 1/0/4 [H3C-vlan40]quit 2．配置各VLAN虚接口地址 [H3C]interface vlan 10 [H3C-Vlan-interface10]ip address 10.1.1.1 24 [H3C-Vlan-interface10]quit [H3C]interface vlan 20 [H3C-Vlan-interface20]ip address 10.1.2.1 24 [H3C-Vlan-interface20]quit [H3C]interface vlan 30 [H3C-Vlan-interface30]ip address 10.1.3.1 24 [H3C-Vlan-interface30]quit [H3C]interface vlan 40 [H3C-Vlan-interface40]ip address 10.1.4.1 24 [H3C-Vlan-interface40]quit 3．定义时间段 [H3C] time-range huawei 8:00 to 18:00 working-day 需求1配置（基本ACL配置） 1．进入2000号的基本访问控制列表视图 [H3C-GigabitEthernet1/0/1] acl number 2000 2．定义访问规则过滤10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fbc9ef8194b0d6feb1b3b2681c7c815/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68fe40ed5e576c47a8246b57bd781b0d/" rel="bookmark">
			接口中的方法不能声明为static
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、如果可以定义抽象静态方法static，设 static abstract method(); 是抽象类A的方法 那么因为是静态方法那可以用A.method(); 而这个方法又是抽象的没有方法体，掉用了怎么执行呢？ 2、静态方法是不能被子类重写的. 接口中是不能有被实现的方法的，否则它就不是接口而是抽象类 一个类要实现接口中的方法，其实就是对接口方法的重写。而要实现静态方法，就必须重写接口中的静态方法，这和第一点产生冲突。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97e5dcce533b39db33d72cd14571d9e3/" rel="bookmark">
			Interpolator
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AccelerateDecelerateInterpolator 先加速再减速AccelerateInterpolator 加速AnticipateInterpolator 先回退一小步，然后再迅速前进AnticipateOvershootInterpolator 先回退一小步，然后再迅速前进，在超过右边界一小步BounceInterpolator 实现弹球效果CycleInterpolator 周期运动DecelerateInterpolator 减速LinearInterpolator 匀速OvershootInterpolator 快速前进到右边界上，再往外突出一小步 转载于:https://www.cnblogs.com/bingoogol/p/Interpolator.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/038245fc5ee1e16e19d60fff98aa38d9/" rel="bookmark">
			builder设计模式的使用以及优缺点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		嗯，大家是否在开发过程中，经常遇到一个类拥有许多的属性呢。为了使这个类的使用便捷，我们通常情况下会给这个类多个构造器以及一个默认的无参数构造器。
但是当参数的个数达到四个或者更多的时候，你是否会经常忘记这几个参数之间的次序了呢。下面给出一个列子：
class A{
private String a;
private String b; private String c;
private String d;
private String e; private String f;
public A(){}
public A(String a){
// initialization in here
}
public A(String a, String b){}
public A(String a, String b, String c){}
public A(String a, String b, String c, String d){} public A(String a, String b, String c, String d){}
public A(String a, String b, String c, String d, String e){}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/038245fc5ee1e16e19d60fff98aa38d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/542f5c721904514d190d69a8742de5ea/" rel="bookmark">
			【QT】4 - 初试Qt Style Sheets 之美化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于某些原因，本人对于UI美化十分热衷，平生最大的想法就是做一个“让我的小伙伴们都惊呆了”的UI程序，跟随工作转辗折腾，始终不遂愿，后来接触了HtmLayout和Sciter疯狂了好几周，翻译N多文章，最终因为文档的原因不得不放弃了。哎呀，跑题了......
以上都不是重点，重点是今天要解决的Qt样式表美化程序的问题，当让，如今的Qt已经步入5.2的牛叉版本，跨平台并且支持Qml界面，支持所有的手机应用开发，简直是开发神器！是优点又是缺点，它才出生就这么强大，肯定免不了这样那样的问题，相比较已经更新维护了10多年的V4.xx版本，4版本才是真正应该好好学会的核心内容。so,......
不要理会上面的内容，都是瞎诌的。下面来讲如何定制一个可修改的程序样式表文件，即通过文件加载Qt Style sheets内容。
-----------------------------------
在这之前，让我们先梳理一下思路：
1、Qt Style sheets是一些90%等价于CSS的文本内容。
2、Qt不提供直接加载样式文件的办法，但是对所有的Qwidget提供了setStyleSheet()函数。
3、Qt的样式表相对关系完全和CSS类似，可以在Dialog中设置自身所有子控件甚至其他Dialog中的类型Style。
鉴于以上原因，我们可以直接写一个CSS文件，在程序启动时，主动读取，并且加载到主窗口中，然后Qt引擎会自动解析和绘制User Custom Style。
------------------------------------
下面，开始正式的处理：
准备工作：
1、新建一个Qt项目，简单起见，基于QDialog。然后再上放一些常用的控件，以便于测试和观察。
2、书写一个加载CSS文件并且设置样式的函数，以便于测试，以后每次都可以不用重新编译。（当然，Qt支持直接书写style到xx.ui文件，需要重新编译）
原始界面：
加载函数：（默认加载exe所在目录default.css文件）
void MainDlg::InitUI() { // 给ComBox添加一些测试文本 QString strContent; for(int i=0;i&lt;10;i++) { strContent.sprintf("Text%.2d",i); ui-&gt;comboBox-&gt;addItem(strContent); } emit ui-&gt;comboBox-&gt;setCurrentIndex(0); // 加载CSS文件 QString strPath = QCoreApplication::applicationDirPath(); qDebug()&lt;&lt;strPath; QString strCssFile = strPath + "/default.css"; QFile fCss(strCssFile); if( !fCss.open(QFile::ReadOnly)) { qDebug("css File %s load false",strCssFile); return; } QString strCssContent(fCss.readAll()); setStyleSheet(strCssContent); fCss.close(); } 在exe所在目录，新建一个default.css文本文件。
编译，运行，没有错误后就可以进行下一步了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/542f5c721904514d190d69a8742de5ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/517442670a7abc74efca13183e0743b1/" rel="bookmark">
			NSPort
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NSPort是一个描述通信通道的抽象类。通信发生在两个NSPort对象之中，这两个NSPort对象通常属于不同的进程或任务。分发对象系统使用NSPort对象来返回或发送NSProtMessage对象。你应该尽可能使用分发对象来完成应用间通信，必要时才使用NSPort对象。
要接收发来的消息，NSPort对象必须作为输入源被添加到NSRunLoop对象中。NSConnection对象在初始化时自动添加它们的接收端口。
当一个NSPort对象接收到一个端口消息，便把这条消息在handleMachMessage:或者handlePortMessge:消息中传送给它的代理。这个代理应该至少实现其中一个方法来处理要接收的消息，不管你想要实现什么功能。handleMachMessage:提供了一个早期的Mach内核消息，它以msg_header_t结构体为起始。handlePortMessage:提供了一个作为NSPortMessage对象的消息，这个对象是Mach消息面向对象的替代品。如果没有设置代理，这个NSPort对象会自己处理这条消息。
当你使用NSPort对象完成消息处理，你必须首先使这个端口对象失效，然后再发送release消息。类似的处理还有，如果你的应用使用了垃圾回收，你必须先使端口失效，然后移除它的一些强引用。如果你没有是端口失效，就可能引起内存泄漏。要使端口失效，请调用invalidate方法。
基础框架定义了三个具体的NSPort子类。NSMachPort和NSMessagePort只允许本地（在一样的机器上）通信。NSSocketPort允许本地和远程两种通讯，但是对于本地通信，NSSocketPort会更加耗费资源。创建NSPort对象，可以使用allocWithZone:或port，NSMachPort对象创建例外。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dbcb47592c0cb6807898ba5cc964195/" rel="bookmark">
			CComVariant类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CComVariant类封装了VARIANT类型，主要的操作方法有：
HRESULT Attach(VARIANT *pSrc); //清除当前对象的VARAINT成员变量，然后将pSrc赋值到该对象的VARIANT成员变量，设置变量的类型为VT_EMPTY
HRESULT ChangeType(VARTYPE vtNew,const VARIANT* pSrc = NULL); //vtNew就是CComVariant对象的新类型，pSrc就要要被转换的VARIANT变量，如果该参数为NULL,则表示默认为该对象。
HRESULT Clear(); //清除CComVariant对象
HRESULT Copy(const VARIANT* pSrc); //先释放CComVariant对象，然后将pSrc拷贝到VARIANT成员变量
HRESULT CopyTo(BSTR *pstrDest); //将CComVariant对象拷贝给pstrDest
HRESULT Detach(VARIANT* pDest); //将CComVariant对象拷贝给pDest,然后释放该对象，并将该对象类型设置为VT_EMPTY
ULONG GetSize()const; //返回该CComVariant对象大小，如果是BSTR则返回其长度，否则就是sizeof(VARTYPE)
HRESULT ReadFromStream(IStream* pStream);
HRESULT WriteToStream(IStream* pStream);
template&lt;typename T&gt;
void SetByRef(T* pT); //初始化CComVariant对象，设置vt成员为VT_BYREF
eg. CComVariant var;
int nData = 10;
var.SetByRef(&amp;nData);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5298faff3216c8ca0f258b97b982b73f/" rel="bookmark">
			AIX红皮书摘选---LVM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原文： https://www.ibm.com/developerworks/cn/aix/redbooks/test191-4-1/ 转载： http://blog.csdn.net/mybluetiankong/article/details/9270065 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/120c090a4647afe79f66ac4945389579/" rel="bookmark">
			Delphi-UpperCase 函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数名称 UpperCase
所在单元 System.SysUtils
函数原型 function UpperCase(const S: string): string;
函数功能 将字符串中所有的小写字母转换为大写字母.
举例如下 var s: string; begin s := 'www.hhit.edu.cn'; s := UpperCase(s); // s = 'WWW.HHIT.EDU.CN' end; 函数备注 UpperCase 已被弃用。 建议使用 AnsiUpperCase函数，功能和使用方法与 UpperCase类似。
转载于:https://www.cnblogs.com/chinacodegear/p/3622962.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fa552c7bc6c2128906b473b9050f737/" rel="bookmark">
			程序员编程艺术 pdf下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://pan.baidu.com/s/1jGFSuiy
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9d8c588756aa87ae126fbb58ef1740e/" rel="bookmark">
			iOS开发-点击屏幕，键盘消失的极佳方法。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般点击屏幕消失键盘常用三种方法：
①、xib中将背景设为UIControl，再添加点击事件。
②、键盘出现时，添加一个空白按钮，添加点击事件。
③、给背景添加个点击手势，添加触发事件。
具体代码推荐博客：http://blog.csdn.net/ugg/article/details/7246164
以上方法都有其片面和不方便之处。xib不一定常用，添加手势和增加按钮显得繁琐，代码又分散，极不容易管理。
偶然在CocoaChina看到一个非常好的做法，推荐给大家：
#pragma mark - 点击背景键盘消失 - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event { [self.view endEditing:YES]; } 两行代码搞定事情，何乐而不为呢？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b682eda4b2a58d7c3649eabacd07ed1/" rel="bookmark">
			AIX6.1安装SSH
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://blog.csdn.net/Hank_dai/article/details/8952417
AIX系统安装是没有ssh协议的
所以Xmanager，putty等工具是无法联入，平添许多不便
现在我们fix它！
步骤如下：
一、官方网站下载： openssl IBM官方网站下载：https://www14.software.ibm.com/webapp/iwm/web/reg/download.do?source=aixbp&amp;S_PKG=openssl&amp;lang=en_US# openssh下载：http://sourceforge.net/projects/openssh-aix 也可以通过我的新浪微盘来下载 openssh：http://vdisk.weibo.com/s/CfcJp openssl：http://vdisk.weibo.com/s/CfeJK 顺便也关注下我的微博，哈哈，求粉啊~~ http://weibo.com/u/1939547104 二、软件安装 1、上传文件 将openssh_5.2p1_aix61.tar.Z用ftp传到/tmp/openssh目录下 将openssl.0.9.8.1103.tar.Z用ftp传到/tmp/openssl目录下 2、解压文件 Shell# cd /tmp/openssh/ Shell# uncompress openssh_5.2p1_aix61.tar.Z Shell# tar -xvf openssh_5.2p1_aix61.tar Shell# cd /tmp/openssl/ Shell# uncompress openssl.0.9.8.1103.tar.Z Shell# tar -xvf openssl.0.9.8.1103.tar 3、安装文件 注：必须先安装openssl，然后再安装openssh。 1)、openssl安装： 进入openssl目录 Shell# cd /tmp/openssh Shell# smitty install_latest 要先安装license，然后再安装别的 ACCEPT new license agreements 安装时都要选yes，按F4更换 2)、openssh安装 openssh的安装与openssl的安装过程一样。 进入到ssh的目录 Shell# cd /tmp/openssh Shell# smitty install_latest 安装过的文件集可以通过如下命令查看。 Shell# lslpp -l | grep ssh 安装顺序同SSL 三、运行ssh服务 默认安装好后系统自动启用ssh服务： 以下命令查看ssh服务 Shell# #lssrc -a | grep ssh sshd ssh 979088 active 如果是inactive，可通过以下命令启动ssh服务： Shell# startsrc -s sshd 停止ssh服务： Shell# stopsrc -s sshd 可参考http://wenku.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b682eda4b2a58d7c3649eabacd07ed1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/510d866e423b144358aa47ff83f44866/" rel="bookmark">
			ORACLE登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sqlplus 中用户名密码分别是创建数据库时自己设置的，主机名是sid
oracle directory manager 的服务器名应该是主机字符串，端口号是登录网上管理的那个地址里面主机字符串后面跟得那个数字。我的是http://XZ-20131019YFCP:1158/em
端口号就是1158.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39fb13393cca0675acd4feda08890365/" rel="bookmark">
			oracle修改“NLS_NCHAR_CHARACTERSET”字符集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://blog.csdn.net/apple_7898/article/details/7618371
oracle
测试数据库的NLS_NCHAR_CHARACTERSET和正式环境不一致，需要由UTF8修改为AL16UTF16。
1、停数据库
SQL&gt; alter system checkpoint;
System altered.
SQL&gt; alter system switch logfile;
System altered.
SQL&gt; shutdown immediate;
Database closed.
Database dismounted.
ORACLE instance shut down.
2、启动数据库
SQL&gt; STARTUP MOUNT EXCLUSIVE;
ORACLE instance started.
Total System Global Area 838860800 bytes
Fixed Size 2024536 bytes
Variable Size 192940968 bytes
Database Buffers 637534208 bytes
Redo Buffers 6361088 bytes
Database mounted.
SQL&gt; alter system enable restricted session;
System altered.
SQL&gt; alter system set job_queue_processes=0;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39fb13393cca0675acd4feda08890365/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac960f3d8bf2db84038d436ef707a998/" rel="bookmark">
			借用认证了的微信订阅号或者服务号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5718a8b68eb2a742296ddeec5f7ea22e/" rel="bookmark">
			easyUI combobox 置灰
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		$('#Id号').combobox('enable'); //可用 $('#Id号').combobox('disable'); //不可用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5eb8e6008eb62576e6aae6f7933fb72b/" rel="bookmark">
			操作系统与CPU的指令集的关系是怎样的？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 正好在做相关的项目，就把 知道的说说，程序猿的一大特点就是说话不利索，将就着看。 CPU指令集 取决于 CPU的 体系架构，目前主流的就是两类 ，ARM 和 X86 ，其他的也有，当然非主流。 指令集上有啥不一样呢，小例子，ARM 体系的寄存器叫做 R1，R2，R3。。。 X86 体系的寄存器叫做EAX， EBX，ECX。。。 好了，再扯到操作系统上，程序猿心中的圣杯---LINUX，很大的一个优势就是在各种CPU体系架构行都能跑。装个ubuntu/red hat 到我们X86 电脑上（就是你在电脑城配的那台）能跑，装个Android到我们ARM 架构手机上也是能跑。不像某家W，不开源还只能跑在 X86上面，形成了日薄西山的WINTEL联盟。不过最近推出的WINDOWS RT 也是第一次试水ARM 架构上的WINDOWS。 说了这么多，离你 的问题还是很远，简单说吧，一个应用程序 编译成 ARM版本 那就可以在 ARM 指令集上运行，编译成X86版本就可以在X86指令集上运行。但是一般场景是这样： 应用程序 ---》 操作系统 ---》CPU指令执行，编译成ARM版本的应用程序（此时二进制文件是ARM指令集实现）不可能在WINDOWS XP系统上运行， 因为如上面说，WINDOWS XP只是支持X86 指令集。 哎，程序猿还是说话不利索，反正就是LINUX操作系统可支持多种指令集，在具体的设备上（因为此时CPU体系架构就确定）只支持一种，这时候LINUX需要做一些适配工作才能实现。WINDOWS 目前只支持X86指令集，WINDOWS RT 目前只支持ARM指令集。 类比一下，一部手机在英国市场，必须配英文使用说明书，而在中国市场，就必须配中文说明书。如果厂家在出厂时候都给配上，就可以在各国售卖。这手机就代表那操作系统，市场就是具体的CPU体系架构。好不贴切，就这么地吧！程序猿的表达能力始终是硬伤，我去疗伤！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cba0834788addd16b005ee6bc73f91b/" rel="bookmark">
			Android蓝牙连接蓝牙音箱和耳机的 A2dp与Headset Profile
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		蓝牙搜索与SPP协议的连接网上例程很多，就不详细介绍了，官方例程BluetoothChat是很好的例子。不过并不是所有的蓝牙设备都支持SPP协议，连接A2dp和Headset协议能找到的例程不多，本文介绍的方法特别适合于蓝牙音箱和蓝牙耳机的连接。原理主要是利用反射原理得到系统api进行连接，先从配对取消配对框弹出说起：
/** * 配对设备 */ private void doPair(){ mBluetoothAdapter.cancelDiscovery(); if (D) Log.d(TAG, "开始配对"); //配对 if(mDevice.getBondState()!= BluetoothDevice.BOND_BONDED){ try { if (D) Log.d(TAG, "setPin 2 ..."); BluetoothMethod.setPin(mDevice.getClass(), mDevice,"0000"); if (D) Log.d(TAG, "createBond 2 ..."); BluetoothMethod.createBond(mDevice.getClass(), mDevice); } catch (Exception e) { connectfailed(); e.printStackTrace(); } }else{ setState(STATE_CONNECTING); } } setPin()和createBond()在android系统源码/frameworks/base/core/java/android/bluetooth/BluetoothDevice.java
中能找到。利用反射调用的方法能把这方法得到，
/** * 与设备配对 参考源码：platform/packages/apps/Settings.git * /Settings/src/com/android/settings/bluetooth/CachedBluetoothDevice.java */ static public boolean createBond(Class btClass,BluetoothDevice btDevice) throws Exception { Method createBondMethod = btClass.getMethod("createBond"); Boolean returnValue = (Boolean) createBondMethod.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cba0834788addd16b005ee6bc73f91b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16d59fd98a2cafbc104bc69aa821fdd7/" rel="bookmark">
			最简单的找质因子的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 诺。。。直接小代码一贴。。
int main() { int n; while(cin&gt;&gt;n) { for(int d=2;d*d&lt;=n;d++) { while(n%d==0) { cout&lt;&lt;d&lt;&lt;" "; n/=d; } } if(n!=1) cout&lt;&lt;n; cout&lt;&lt;endl; } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52a6cadc989cda8067684834be178649/" rel="bookmark">
			asterisk非常卡   接听客户来电后听到系统播放的背景音乐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		偶尔发现安装一台asterisk后 在asterisk cli下面执行一次reload后如果接着执行一次reload就会提示The previous reload command didn't finish yet。并且内部分机互打都反应非常慢，后来经过排查发现是因为一个sip对接造成的，这个sip对接时使用的不是默认的5060端口注册不上。在删除这个sip注册对接后系统就正常了。 一个客户反应说在坐席和客户接通电话后还能听见队列的等待音乐，经过排查发现是因为网关O口线路的568B线序错了，导致每次呼入时就会产生两个呼入，一个接通后另外一个在队列中等待。
转载于:https://blog.51cto.com/tlchwy/1376318
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87cd1b9079171dcbd289e84a48b69be1/" rel="bookmark">
			[C#] Byte[]、Image、Bitmap 之间的相互转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/// &lt;summary&gt; /// 将图片Image转换成Byte[] /// &lt;/summary&gt; /// &lt;param name="Image"&gt;image对象&lt;/param&gt; /// &lt;param name="imageFormat"&gt;后缀名&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static byte[] ImageToBytes(Image Image, System.Drawing.Imaging.ImageFormat imageFormat) { if (Image == null) { return null; } byte[] data = http://www.cnblogs.com/peasana/archive/2012/02/13/null; using (MemoryStream ms= new MemoryStream()) { using (Bitmap Bitmap = new Bitmap(Image)) { Bitmap.Save(ms, imageFormat); ms.Position = 0; data = http://www.cnblogs.com/peasana/archive/2012/02/13/new byte[ms.Length]; ms.Read(data, 0, Convert.ToInt32(ms.Length)); ms.Flush(); } } return data; } /// &lt;summary&gt; /// byte[]转换成Image /// &lt;/summary&gt; /// &lt;param name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87cd1b9079171dcbd289e84a48b69be1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da3bc26f8f139c815550a8eb2642732c/" rel="bookmark">
			asp.net  Socket 实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		public class Socketclient{TextBox txt;TextBox send_txt;public Socketclient(TextBox txt, TextBox send_txt){this.txt = txt;this.send_txt = send_txt;}public void StartClient(){// Data buffer for incoming data.byte[] bytes = new byte[1024];// Connect to a remote device.try{// Establish the remote endpoint for the socket.// This example uses port 11000 on the local computer.IPHostEntry ipHostInfo = Dns.Resolve(Dns.GetHostName());IPAddress ipAddress = ipHostInfo.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da3bc26f8f139c815550a8eb2642732c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b5fcedf517e4dc42d65481794c4d56d/" rel="bookmark">
			UIView,UIButton,UIImageView等设置圆角，设置阴影，设置边框的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在iOS开发中，任何可见视图都是继承于UIView的。 继承体系中，大部分UIView的属性适用于其任何子类。
而UIView的layer属性可以绘制UIView的各种效果。其实我们看到的View的动画实际上也是layer在绘制。
1、绘制圆角 cornerView.layer.cornerRadius = 20; cornerView.layer.masksToBounds = YES; masksToBounds防止子元素溢出父视图。
如果一个正方形要设置成圆形，代码为:
cornerView.layer.cornerRadius = cornerView.frame.size.height/2; cornerView.layer.masksToBounds = YES; 2、绘制边框 borderView.layer.borderWidth = 1.0; borderView.layer.borderColor = [UIColor blackColor].CGColor; 注意此处使用的是CGColor而不是UIColor. 3、绘制阴影 shadowView.layer.shadowColor = [UIColor redColor].CGColor; shadowView.layer.shadowOffset = CGSizeMake(5.0, 5.0); shadowView.layer.shadowOpacity = YES; offset为偏移量，为正表示向frame x，y坐标增加的方向偏移。 opacity为透明度，默认为0，即表示透明的。所以我们要把opacity设置成1或者YES，表示不透明，也可以设置成0.5或者类似的值呈现半透明。
效果如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3efcd968f79ea5a4b8cfdb6f1b5c7291/" rel="bookmark">
			VS2012发布网站详细步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、打开你的VS2012网站项目，右键点击项目》菜单中 重新生成一下网站项目；再次点击右键》发布：
2、弹出网站发布设置面板，点击&lt;新建..&gt;,创建新的发布配置文件：
输入你自己定义的配置文件名：
3、点击下一步：在发布方法中选“文件系统”，这样我们可以发布到自己指定的本机文件上。
选择自己指定的文件夹：通过点击下图中右上角红色箭头处创建新的文件夹，自定义命名（我的就写WebSite）。点击打开，进入下一步
4、 在配置中，要选择“Release”——发布模式（Release 称为发布版本，它往往是进行了各种优化，使得程序在代码大小和运行速度上都是最优的，以便用户很好地使用。Debug 通常称为调试版本，它包含调试信息，并且不作任何优化，便于程序员调试程序）
5、点击下一步：进入发布前的预览界面
点击发布即可以发布你指定的文件夹中，这里，我发布的是C盘下的WebSite文件夹中。
发布成功后，点开文件夹，所有页面的.cs文件都消失了， 都去哪里了呢？是bin文件夹里面吗？大家猜一猜。
发布好的截图：
6、通过》控制面板》管理工具》启动 ‘Internet信息服务(IIS)管理器’ 进入IIS界面。
右键单击网站》添加网站
7、下面图中，左边红色方框内输入自定义的网站名称（请尽量用英文，这里我就写MyPhotoSite），右边红色箭头处需要点击 ‘选择(E)…’ 进行更改。
大家可以点开下拉列表框根据自己的网站版本进行选择（一般请选择 不带有Classic的）。这里我选择的是选择DefaultAppPool，
8、选择 “已发布网站文件夹” 的物理路径。
9、点击下拉列表选择 “自己当前的IP地址”
点击确定：这时我们的网站就还差一步就发布好了，点击网站MyPhotosSite，再点击下图红色箭头处 切换到 “内容视图”。
10、 最后一步：注册IIS服务器。命令：aspnet_regiis -i（请复制），先在程序菜单》VS2012里面》Visual Studio Tools》VS2012开发人员命令提示。右键单击 “VS2012开发人员命令提示”。以管理员身份运行。（如果不是以管理员身份运行，将会提示“权限不足”错误）
运行后，右键粘贴 aspnet_regiis -i 按回车。等待运行大概 1分钟左右提示安装完毕（我的机子慢所以提供1分钟供大家参考，大家不要着急慢慢等待安装完成即可）。
最后，找到自己的网站首页，右键浏览。IE有时会不响应（地址栏出现空白），要多次浏览才会成功。展示一下我们的成果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4af767f6acb57dfc87561828da1aed84/" rel="bookmark">
			【IOS】IOS上实现的自定义仪表盘(可以用在流量监控之类的应用上)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原创作品， 欢迎转载，转载请在明显处注明！ 谢谢。
原文地址：http://blog.csdn.net/toss156/article/details/7407770】
今天给大家带来一个自定义的仪表盘，效果图如下。
Demo中用到了 QuartzCore类 首先继承一个UIView。
[cpp] view plain copy &lt;span style="font-size:10px;"&gt;// // Gauge.h // GaugeDemo // // Created by 海锋 周 on 12-3-27. // Copyright (c) 2012年 CJLU rights reserved. // #import &lt;UIKit/UIKit.h&gt; #import &lt;QuartzCore/QuartzCore.h&gt; @interface Gauge : UIView { UIImage *gaugeView; UIImageView *pointer; CGFloat maxNum; CGFloat minNum; CGFloat maxAngle; CGFloat minAngle; CGFloat gaugeValue; CGFloat gaugeAngle; CGFloat angleperValue; CGFloat scoleNum; NSMutableArray *labelArray; CGContextRef context; } @property (nonatomic,retain) UIImage *gaugeView; @property (nonatomic,retain) UIImageView *pointer; @property (nonatomic,retain) NSMutableArray *labelArray; @property (nonatomic) CGContextRef context; -(void)setGaugeValue:(CGFloat)value animation:(BOOL)isAnim; @end&lt;/span&gt;&lt;span style="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4af767f6acb57dfc87561828da1aed84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc671e4f839566aa641f205054c09879/" rel="bookmark">
			使用RAR解压Jar文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		产品的安装程序有点问题，需要自己解压Jar文件进行产品安装。
看了一下WinRAR的帮助文档，
使用下面的方式能够实现Jar文件的解压到制定目录
1 CMD输入命令 [WinRAR安装路径]|WinRAR.exe X -ibck -O+ jar文件目录\*.jar jar解压后目录\
1.1WinRAR.exe 是要执行的命令，因为jar文件压缩格式是zip的，所以
不能使用rar命令解压，WinRAR.exe是支持zip格式的。
1.2 X 意思是解压,保持完整路径[rar帮助]
1.3 -ibck 后台静默模式[rar帮助]
1.4 -O+ [rar帮助] 覆盖已经存在的
1.5 jar文件目录\*.jar 是jar文件
1.6 jar解压后目录\ 加压到文件 后面一定有有个\
1.7 也可以使用jar 命令，但是这个命令似乎不能指定解压到哪个路径下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6de9a151bab5b9ee1723830a28b9f39b/" rel="bookmark">
			void指针的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		指针有两个属性:指向变量/对象的地址和长度 但是指针只存储地址,长度则取决于指针的类型 编译器根据指针的类型从指针指向的地址向后寻址 指针类型不同则寻址范围也不同,比如: int*从指定地址向后寻找4字节作为变量的存储单元 double*从指定地址向后寻找8字节作为变量的存储单元 1.void指针是一种特别的指针 void *vp //说它特别是因为它没有类型 //或者说这个类型不能判断出指向对象的长度 2.任何指针都可以赋值给void指针 type *p; vp=p; //不需转换 //只获得变量/对象地址而不获得大小 3.void指针赋值给其他类型的指针时都要进行转换 type *p=(type*)vp; //转换类型也就是获得指向变量/对象大小 转:http://icoding.spaces.live.com/blog/cns!209684E38D520BA6!130.entry 4.void指针不能复引用 *vp//错误 因为void指针只知道,指向变量/对象的起始地址 而不知道指向变量/对象的大小(占几个字节)所以无法正确引用 5.void指针不能参与指针运算,除非进行转换 (type*)vp++; //vp==vp+sizeof(type)
#include&lt;iostream&gt;
#include&lt;stdlib.h&gt;
#include&lt;string&gt;
using namespace std;
typedef struct tag_st { char id[10];
float fa[2];
}ST; //我在程序里面这样使用的 int main()
{
ST * P=(ST *)malloc(sizeof(ST));
strcpy(P-&gt;id,"hello!");
P-&gt;fa[0]=1.1;
P-&gt;fa[1]=2.1;
ST * Q=(ST *)malloc(sizeof(ST));
strcpy(Q-&gt;id,"world!");
Q-&gt;fa[0]=3.1;
Q-&gt;fa[1]=4.1;
void ** plink=(void **)P;
*((ST *)(plink)) = * Q; //plink要先强制转换一下,目的是为了让它先知道要覆盖的大小.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6de9a151bab5b9ee1723830a28b9f39b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7d41d66cd709eeac104d4f0c942f2a4/" rel="bookmark">
			c语言运算符优先级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		优先级
运算符
名称或含义
使用形式
结合方向
说明
1
[]
数组下标
数组名[常量表达式]
左到右
()
圆括号
（表达式）/函数名(形参表)
.
成员选择（对象）
对象.成员名
-&gt;
成员选择（指针）
对象指针-&gt;成员名
2
-
负号运算符
-表达式
右到左
单目运算符
(类型)
强制类型转换
(数据类型)表达式
++
自增运算符
++变量名/变量名++
单目运算符
--
自减运算符
--变量名/变量名--
单目运算符
*
取值运算符
*指针变量
单目运算符
&amp;
取地址运算符
&amp;变量名
单目运算符
!
逻辑非运算符
!表达式
单目运算符
~
按位取反运算符
~表达式
单目运算符
sizeof
长度运算符
sizeof(表达式)
3
/
除
表达式/表达式
左到右
双目运算符
*
乘
表达式*表达式
双目运算符
%
余数（取模）
整型表达式/整型表达式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7d41d66cd709eeac104d4f0c942f2a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72d0cab612da647efa4bfe8a2f9b0a47/" rel="bookmark">
			mysqldump 导出数据文件,是乱码,何解?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysqldump 导出一个 SQL 文件,用vim 打开中文显示是乱码,导出的时候设置的字符集是 utf8 ,数据库的默认字符集也是utf8,终端操作同样是utf8的,用file 工具显示也是UTF8的文本文件,可用vim 打开就显示中文乱码.在打开的文件当中 set fileencoding 查看编码,居然是 latin1 编码的 用head,more,cat等文本查看工具,都正常显示中文无乱码. 思思不得其解. 后来偶尔看到网上文章说也许是编辑器本身的问题,于是搜索了一把.
原来是跟 vim 的设置有关. 请看下面一段话.
vim编码方面的基础知识：
1，存在3个变量：
encoding—-该选项使用于缓冲的文本(你正在编辑的文件)，寄存器，Vim 脚本文件等等。你可以把 ‘encoding’ 选项当作是对 Vim 内部运行机制的设定。
fileencoding—-该选项是vim写入文件时采用的编码类型。
termencoding—-该选项代表输出到客户终端（Term）采用的编码类型。
2，此3个变量的默认值：
encoding—-与系统当前locale相同，所以编辑文件的时候要考虑当前locale，否则要设置的东西就比较多了。
fileencoding—-vim打开文件时自动辨认其编码，fileencoding就为辨认的值。为空则保存文件时采用encoding的编码，如果没有修改encoding，那值就是系统当前locale了。
termencoding—-默认空值，也就是输出到终端不进行编码转换。
由此可见，编辑不同编码文件需要注意的地方不仅仅是这3个变量，还有系统当前locale和、文件本身编码以及自动编码识别、客户运行vim的终端所使用的编码类型3个关键点，这3个关键点影响着3个变量的设定。
如果有人问：为什么我用vim打开中文文档的时候出现乱码？
答案是不确定的，原因上面已经讲了，不搞清楚这3个关键点和这3个变量的设定值，出现乱码是正常的，倒是不出现乱码那反倒是凑巧的。
看到这个,应该是 自动编码识别错误了!! 所以,可以在vim的配置文件中进行修改. vim /etc/vimrc 中第一行会设置编码.
if v:lang =~ "utf8$" || v:lang =~ "UTF-8$"
set fileencodings=ucs-bom,utf-8,latin1
endif
但是在文件编码识别成了 latin1 ,改为
if v:lang =~ "utf8$" || v:lang =~ "UTF-8$"
set fileencodings=utf-8
endif
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72d0cab612da647efa4bfe8a2f9b0a47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3846685fd6c02862844adf147c8ca061/" rel="bookmark">
			Python——字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基本字符串操作
所有标准的序列操作（索引、分片、乘法、判断成员资格、求长度、取最小值和最大值）对字符串同样适用。但是，请记住字符串都是不可变的。
二、字符串格式化：精简版
字符串格式化使用字符串格式化操作符即百分号%来实现。在%的左侧放置一个字符串（格式化字符串），而右侧则放置希望格式化的值。可以使用一个值，如一个字符串或者数字，也可以使用多个值的元组或者字典。
&gt;&gt;&gt; format = "Hello. %s. %s enough for ya?" &gt;&gt;&gt; values = ('world', 'Hot') &gt;&gt;&gt; print(format % values) Hello. world. Hot enough for ya? 注意：如果使用类表或者其他序列代替元组，那么序列就会被解释为一个值。只有元组和字典可以格式化一个以上的值。 格式化字符串的 %s 部分称为转换说明符(conversion specifier)，它们标记了需要插入转换值的位置。
三、字符串格式化：完整版
1. 如果右操作数是元组的话，则其中的每一个元素都会被单独格式化，每个值都需要一个对应的转换说明符。
2. 基本的转换说明符包括以下部分。
(1)%字符：标记转换说明符的开始。
(2)转换标志（可选）：- 表示左对齐；+ 表示在转换值之前要加上正负号；“ ”（空白字符）表示正数之前保留空格；0表示转换值若位数不够则用 0 填充。
(3)最小字段宽度（可选）：转换后的字符串至少应该具有该值指定的宽度。如果是 *，则宽度会从值元组中读出。
(4)点(.)后跟精度值（可选）：如果转换的是实数，精度值表示出现在小数点后的位数。如果转换的是字符串，那么该数字就表示最大字段宽度。如果是*，那么精度就会从元组中读出。
(5)转换类型
3.1 简单转换
简单的转换只需要写出转换类型。
&gt;&gt;&gt; print(format % values) Hello. world. Hot enough for ya? &gt;&gt;&gt; 'Price of eggs: $%d' % 42 'Price of eggs: $42' &gt;&gt;&gt; 'Hexadecimal price of eggs: %x' % 42 'Hexadecimal price of eggs: 2a' 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3846685fd6c02862844adf147c8ca061/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45ef362c0bb1546fb4a6fad24e613962/" rel="bookmark">
			c&#43;&#43; 基本操作 知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看了一遍书，还是理解的不够。那就从历年的考题中，来学习吧，挖掘他的考点，挖掘我们课本上当时不理解的知识点。题不再多，而在于精，自然有必要好好研究研究。一下是结合真题参考答案和自己的理解。也依靠博客，和广大的要考C++的同学们一起交流，多多指点。
关键词： 构造函数 成员函数及其调用
首先来看一道基本操作真题。
题目： 改错。输出结果为：The value is 10
// proj1.cpp #include &lt;iostream&gt; using namespace std; class MyClass { int value; public: // ERROR ********found******** void MyClass(int val) : value(val) {} int GetValue() const { return value; } void SetValue(int val); }; // ERROR ********found******** inline void SetValue(int val) { value = val; } int main() { MyClass obj(0); obj.SetValue(10); // ERROR ********found******** 下列语句功能是输出obj的成员value的值 cout &lt;&lt; "The value is "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45ef362c0bb1546fb4a6fad24e613962/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8e862b10303b8f98021feb2ecdfd952/" rel="bookmark">
			Altium Designer 10画PCB图，怎样增大走线和覆铜之间的距离？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如下图，在Altium Designer 10中画PCB图，放置了一个“多边形平面”的覆铜，我想知道，怎样增大走线和覆铜之间的空隙?
你这样操作下吧。设置下“rules“里的“clearence”就可以了。 ”design“--“rules“--”electrical“--“clearence”，右键“clearence”，”new rules“，并修改为”polygon“，将”minimum clearence“修改为30mil(这个就是铜皮和走线的间距)。在”where the first object matches“中选择”advanced(Query)“，在”full query“中输入”InPolygon“。 点击”properties“按钮，进入后，将”polygon“的优先级调高于”all“的优先级。 OK即可完成设置，这样你敷铜时则遵循”polygon“规则。布线的时候遵循“all”规则。 有人说下面的方案也行 铺铜间距设置应该和99一样，不在铺铜选项中，而是在布线规则中的导体间距设置吧。也就是说铺铜和其他布线一样，遵守同样的间距规则，当然，可以铺完铜后再改回来。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4169699897b08cf81677245e8b86e9b/" rel="bookmark">
			java.lang.IllegalStateException异常产生的原因及解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： 错误类型大致为以下几种：
java.lang.IllegalStateException：Cannot forward a response that is already committed IllegalStateException：response already commited IllegalStateException：getOutputStream() has already been called for this request …………
错误原因：
该异常表示，当前对客户端的响应已经结束，不能在响应已经结束（或说消亡）后再向
客户端（实际上是缓冲区）输出任何内容。
具体分析：
首先解释下flush()，我们知道在使用读写流的时候数据先被读入内存这个缓冲区中，
然后再写入文件，但是当数据读完时不代表数据已经写入文件完毕，因为可能还有
一部分仍未写入文件而留在内存中，这时调用flush()方法就会把缓冲区的数据强行
清空输出，因此flush()的作用就是保证缓存清空输出。
response是服务端对客户端请求的一个响应，其中封装了响应头、状态码、内容等，
服务端在把response提交到客户端之前，会向缓冲区内写入响应头和状态码，然后
将所有内容flush。这就标志着该次响应已经committed(提交)。对于当前页面中
已经committed(提交)的response，就不能再使用这个response向缓冲区写任何东西
（注：同一个页面中的response.XXX()是同一个response的不同方法，只要其中一个
已经导致了committed，那么其它类似方式的调用都会导致 IllegalStateException异常）。
【注意】能够导致响应已经committed的操作包括：forward, redirect, flushBuffer。
JDK API：
①
flushBuffer
public void flushBuffer()throws IOException Forces any content in the buffer to be written to the client. A call to this method automatically commits the response, meaning the status code and headers will be written.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4169699897b08cf81677245e8b86e9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ef1f17fe7120f4c7e50977eef553475/" rel="bookmark">
			iframe子页面js调用父页面js函数/父页面调用Iframe子页面中js方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、iframe页面里的js调用父级页面js函数
1、假设当前页面为a.html, iframe的src页面为b.html,其代码如下：
&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;iframe页面里的js调用父级页面js函数的demo&lt;/p&gt; &lt;iframeframeborder="0"width="0"height="0" name="test" src="b.html"&gt; &lt;/iframe&gt; &lt;p id="p_nr"&gt;&lt;/p&gt; &lt;/body&gt; &lt;scripttype="text/javascript"&gt; function testParent(){ alert('Parent'); } &lt;/script&gt; &lt;/html&gt; 2、b.html里的页面元素为：
&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type='text/javascript'&gt; window.parent.document.getElementById('p_nr').innerHTML ='内容';//控制父级页面的元素 window.parent.testParent();//调用父级页面的Js函数 &lt;/script&gt; &lt;/body&gt;
&lt;/html&gt;
二、父页面调用Iframe页面中js方法
1、test.js内容
function testJs()
{
alert('JS');
}
2、Children.html内容
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;&lt;/title&gt;
&lt;script type="text/javascript" src="test.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;/body&gt;
&lt;/html&gt;
3、parent.html内容
&lt;head&gt;
&lt;title&gt;&lt;/title&gt;
&lt;script type="text/javascript" &gt;
var obj=self.frames[0];
obj.testJs();
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;/body&gt;
&lt;/html&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ef1f17fe7120f4c7e50977eef553475/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bd14c5a3292f5e4053912397f784cd1/" rel="bookmark">
			VMware读取U盘USB设备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击 虚拟机 右下角的USB设备，点连接（断开本机）。如果不行，则点，虚拟机-》设置-》删除USB，再点添加-》USB
本机USB拨出，再插上，再点右下角USB设备。
右击-》我的电脑-》管理-》服务。vm usb 重新启动，或改为自动 。
虚拟机的状态栏中没有USB设备的图标，
且已确定USB虚拟设备已经添加，并开启自动连通，
虚拟机USB设备的服务也已经开启，
甚至包括因为怀疑电压过低，无法识别的USB的问题也想到了，接通了电源。
结果：
均无效。
后来想起来最近安装过VMware vSphere Client，是不是两者有冲突。果然，安装VMware vSphere Client时，也会创建一个VMware USB Arbitration Service服务，这个服务会把VMware Workstation8的VMware USB Arbitration Service修改掉。
当我打开VMware USB Arbitration Service服务查看详细信息时发现 “可执行文件的路径” 为无效路径，让人纳闷的是，既然无效为何还可启动，至今不解。
后来我卸载重启后从新安装了一下VMware Workstation8，因为使用的是绿色安装所以很快
安装玩后我再查看VMware USB Arbitration Service服务详细信息，“可执行文件的路径” 已经为一个有效路径，
其中D:\WMware为VMware的安装根目录。
至此，虚拟机USB设备正常。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d9fd850a1431640c4fc34f9655981c1/" rel="bookmark">
			no matching function for call to &#39;sort(...),
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初leetcode的two sum 题中排序坑死, 枉费好长时间
no matching function for call to 'sort(std::vector&lt;Solution::Node&gt;::iterator
sort(,,.,,., cmp);
当时确信代码正确, 类型更是比对好久, 总是提示这个错误.
后来才发现, cmp函数要定义在类的外面, 具体:
cmp()
{...}
class Solution
{
...
sort(...);
}
原因:
cmp是定义在一个类中的成员函数。开始的时候老是报错：no matching function for call to 'sort(...), &lt;unresolved overloaded function type&gt;'。后来我把该成员定义成静态函数，问题解决。原因可能和类成员函数的函数原型有关。所有成员函数都有一个隐含的指针参数，即this。这就和sort需要的comp函数原型不一致了，所以就报错了。而static函数就没有这个隐含参数了
如果类中有个cmp函数,调用时,类型就多了个this指针, 当然类型不对
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64ce83fd70c395a92ce5cb08c6f5a1fb/" rel="bookmark">
			Perl哈希数组入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Perl的数据结构中最有趣的一个特性是哈希(hash)，它使得在数据片段之间建立键—值(key-value)关联成为可能。虽然这些哈希要远远比普通系统中以数字索引的数组用途更广，但是往往也会使初学者不知所措。这就是要写本篇文章的原因所在--它将告诉你如何创建Perl的哈希，如何插入、删除要素，以及如何创建嵌套哈希和利用循环来处理哈希。 哈希是一种数据结构，和数组类似，可以将值存放到其中，或者从中取回值。但和数组不同的是，其索引不是数字，而是名字。也就是说，索引(这里，我们将它叫key)不是数字而是任意的唯一的字符串。 key可以是任意的字符串，你可以使用任何的字符串作为key，但它们是唯一的。 另一种理解hash 的方法是，把它看作一堆数据(a barrel of data)，每一个数据都有一个相应的标签。可以通过标签访问此标签对应的元素。但其中是没有“第一个”元素的概念的。在数组中，数组元素从0,1,2 开始编号。但在hash中，没有确定的顺序，因此也没有第一个元素。只是一些key/value 对的集合。 keys和values均为任意的标量，但keys通常转换为字符串。由于Perl的“没有不必要的限制”的设计哲学：hash可以是任意大小，从空hash(没有key/value对)，到任何你内存允许的大小。 keys是唯一的，但values可以重复。hash的value可以是数字，字符串，undef，或者它们的混合，但key是唯一的。 哈希相关函数及用法 1.keys和values函数 keys函数会返回此hash的所有keys，values函数将返回所有的values。如果hash中没有元素，则此函数将返回空列表。 my %hash = ("a"=&gt;1, "b"=&gt;2, "c"=&gt;3); print my @k = keys %hash; print my @v = values %hash; 2.each函数 如果想迭代hash的每一个元素，一种通常的方法是使用each函数，它将返回key/value对应的2个元素列表。 当对同一个hash 函数进行一次迭代时，将返回下一个key/value对，直到所有的元素均被访问。如果没有更多的key/value对，则each函数将返回空表。 my %hash = ("a"=&gt;1, "b"=&gt;2, "c"=&gt;3); while(($key, $value) = each %hash){ print "$key =&gt; $value\n"; } 当然，each返回的key/vlaue对，顺序是混乱的(它其顺序和keys和values函数返回的顺序相同)。如果想将其按序排放，可以对它们排序（使用sort）。 my %hash = ("a"=&gt;1, "b"=&gt;2, "c"=&gt;3, "d"=&gt;4); foreach $key (sort keys %hash){ $value =$hash{$key}; print "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64ce83fd70c395a92ce5cb08c6f5a1fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9d606a2ba5a9856304f60d8e61d3dff/" rel="bookmark">
			使用Jrtplib编译的arm程序和pc无法通信的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://blog.chinaunix.net/uid-24456535-id-2606931.html
最近本人在作关于RTP的项目，要求在arm和pc间用RTP协议传输数据。
1. 下载jrtplib-3.7.1和jthread-1.2.1。
2. pc上编译很简单，windows下编译过程如下：
首先编译jthread库。然后解压缩jrtplib，打开jrtplib.dsw工程，注意工程的include路径设置，要包含jrtplib和 jthread的头文件，然后编译。将编译生成的jrtplib.lib和jthread.lib拷贝到Microsoft Visual Studio的VC98\Lib目录下。在编译jrtplib.lib和jthread.lib的时候，在project——settings—— C/C++——Code generation:use run-time library中，对于debug，选择:Debug Multithreaded DLL，对于release，则选择:Multithreaded DLL。 ??那些example的编译，需要在cpp文件开头加上： ??#pragma comment(lib, "jrtplib.lib") ??#pragma comment(lib, "jthread.lib") ??#pragma comment(lib, "WS2_32.lib")//pragma的作用自己上网查吧 ??编译的时候，同样选择编译选项：Debug Multithreaded DLL（对于debug）；Multithreaded DLL（对于release）。 ??然后在windows上测试example1,这是一个往指定IP的端口上发包的程序，同样也可以收包，测试通过。
3.jrtplib库的移植，主要参考了这篇文章http://blog.csdn.net/neohuo/archive/2006/03/08/618684.aspx
编译器我用的arm-linux-gcc3.4.1，2.95.3也用过，不过需要修改一下rtperror里面的代码。可能还有些问题没提到，自己注意 一下吧。
4.移植成功后，我遇到了第一个棘手的问题，提示can't retrieve login name,建立不了rtpsession。
后来发现是RTPSession::CreateCNAME这个函数搞得鬼
这个函数会从系统调用里获取loginname，但是一般的板子由于内核和文件系统的原因都没有loginname，所以
if (!gotlogin) { char *logname = getenv("LOGNAME"); if (logname == 0) return ERR_RTP_SESSION_CANTGETLOGINNAME;//这里return了一个error strncpy((char *)buffer,logname,*bufferlength); }
所以我强制将logname的值设为root，就ok了。
5.有些人会遇到arm和pc无法互相接受数据包的问题，但是pc和pc，arm和arm就可以收到。我用sniffer抓了一下包发现确实是有数据包 的，所以应该不是程序的问题。这个问题上网查了一下，也没人说的明白，只有一个高人点了一下，可能是字节序和位域的问题。自己又研究了一下，也是一知半 解。
一般x86的pc机是用小端字节序(little endian),而嵌入式平台一般是大端字节序(big endian),可能是由于字节序的不同，导致了明明存在数据包，却认不出来的问题。其实，JRTPLIB的开发者可能已经考虑到了这个问题（真牛），在 rtpstructs.h中，有这样的代码定义：
struct RTPHeader { #ifdef RTP_BIG_ENDIAN uint8_t version:2; uint8_t padding:1; uint8_t extension:1; uint8_t csrccount:4; uint8_t marker:1; uint8_t payloadtype:7; #else // little endian uint8_t csrccount:4; uint8_t extension:1; uint8_t padding:1; uint8_t version:2; uint8_t payloadtype:7; uint8_t marker:1; #endif // RTP_BIG_ENDIAN uint16_t sequencenumber; uint32_t timestamp; uint32_t ssrc; }; 这是一个位域结构体，明眼人一下子就看出来了，jrtplib库使用哪种字节序完全取决于RTP_BIG_ENDIAN的定义，这样问题就简单化了。当然，也可以在pc的安装时选择将pc端安装为大端模式，只要两端的一致就可以了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9d606a2ba5a9856304f60d8e61d3dff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cda2e0b6050f53a73ada83363d58e2a3/" rel="bookmark">
			Doxygen使用教程（个人总结）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介Doxygen
一．什么是Doxygen? Doxygen 是一个程序的文件产生工具，可将程序中的特定批注转换成为说明文件。通常我们在写程序时，或多或少都会写上批注，但是对于其它人而言，要直接探索程序里的批注，与打捞铁达尼号同样的辛苦。大部分有用的批注都是属于针对函式，类别等等的说明。所以，如果能依据程序本身的结构，将批注经过处理重新整理成为一个纯粹的参考手册，对于后面利用您的程序代码的人而言将会减少许多的负担。不过，反过来说，整理文件的工作对于您来说，就是沉重的负担。
Doxygen 就是在您写批注时，稍微按照一些它所制订的规则。接着，他就可以帮您产生出漂亮的文档了。
因此，Doxygen 的使用可分为两大部分。首先是特定格式的批注撰写，第二便是利用Doxygen的工具来产生文档。
目前Doxygen可处理的程序语言包含：
· C/C++
· Java
· IDL (Corba, Microsoft及KDE-DCOP类型) 而可产生出来的文档格式有：
· HTML
· XML
· LaTeX
· RTF
· Unix Man Page
而其中还可衍生出不少其它格式。HTML可以打包成CHM格式，而LaTeX可以透过一些工具产生出PS或是PDF文档。
二．安装Doxygen · 1.1 安装 Doxygen 1.7.4(Windows) · 1.2 安装 graphviz 2.28.0(Windows)
graphviz 是一个由AT&amp;T实验室启动的开源工具包，用于绘制DOT语言脚本描述的图形。Doxygen 使用 graphviz 自动生成类之间和文件之间的调用关系图，如不需要此功能可不安装该工具包。
· 1.3 安装 Windows Help Workshop 1.32
Doxygen 使用这个工具可以生成 CHM 格式的文档。
三．Doxygen的配置 Doxygen 产生文档可以分为三个步骤。一是在程序代码中加上符合Doxygen所定义批注格式。二是使用Doxywizard进行配置。三是使用Doxygen来产生批注文档。
Doxygen 1.7.4 主界面如下图 1 所示。
说明：1，Doxygen 工作目录，就是用来存放配置文件的目录。
2，递归搜索源文件目录需要选上。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cda2e0b6050f53a73ada83363d58e2a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6b79e167f086c0e818530a2f0c5d0ba/" rel="bookmark">
			glBlendFunc()--混合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenGL 会把源颜色和目标颜色各自取出，并乘以一个系数（源颜色乘以的系数称为“源因子”，目标颜色乘以的系数称为“目标因子”），然后相加，这样就得到了新的颜 色。（也可以不是相加，新版本的OpenGL可以设置运算方式，包括加、减、取两者中较大的、取两者中较小的、逻辑运算等，但我们这里为了简单起见，不讨 论这个了） 下面用数学公式来表达一下这个运算方式。假设源颜色的四个分量（指红色，绿色，蓝色，alpha值）是(Rs, Gs, Bs, As)，目标颜色的四个分量是(Rd, Gd, Bd, Ad)，又设源因子为(Sr, Sg, Sb, Sa)，目标因子为(Dr, Dg, Db, Da)。则混合产生的新颜色可以表示为： (Rs*Sr+Rd*Dr, Gs*Sg+Gd*Dg, Bs*Sb+Bd*Db, As*Sa+Ad*Da) 当然了，如果颜色的某一分量超过了1.0，则它会被自动截取为1.0，不需要考虑越界的问题。
源因子和目标因子是可以通过glBlendFunc函数来进行设置的。glBlendFunc有两个参数，前者表示源因子，后者表示目标因子。这两个参数可以是多种值，下面介绍比较常用的几种。
GL_ZERO： 表示使用0.0作为因子，实际上相当于不使用这种颜色参与混合运算。
GL_ONE： 表示使用1.0作为因子，实际上相当于完全的使用了这种颜色参与混合运算。
GL_SRC_ALPHA：表示使用源颜色的alpha值来作为因子。
GL_DST_ALPHA：表示使用目标颜色的alpha值来作为因子。
GL_ONE_MINUS_SRC_ALPHA：表示用1.0减去源颜色的alpha值来作为因子。
GL_ONE_MINUS_DST_ALPHA：表示用1.0减去目标颜色的alpha值来作为因子。 除此以外，还有GL_SRC_COLOR（把源颜色的四个分量分别作为因子的四个分量）、GL_ONE_MINUS_SRC_COLOR、 GL_DST_COLOR、GL_ONE_MINUS_DST_COLOR等，前两个在OpenGL旧版本中只能用于设置目标因子，后两个在OpenGL 旧版本中只能用于设置源因子。新版本的OpenGL则没有这个限制，并且支持新的GL_CONST_COLOR（设定一种常数颜色，将其四个分量分别作为 因子的四个分量）、GL_ONE_MINUS_CONST_COLOR、GL_CONST_ALPHA、 GL_ONE_MINUS_CONST_ALPHA。另外还有GL_SRC_ALPHA_SATURATE。新版本的OpenGL还允许颜色的alpha 值和RGB值采用不同的混合因子。
举例来说： 如果设置了glBlendFunc(GL_ONE, GL_ZERO);，则表示完全使用源颜色，完全不使用目标颜色，因此画面效果和不使用混合的时候一致（当然效率可能会低一点点）。如果没有设置源因子和目标因子，则默认情况就是这样的设置。 如果设置了glBlendFunc(GL_ZERO, GL_ONE);，则表示完全不使用源颜色，因此无论你想画什么，最后都不会被画上去了。（但这并不是说这样设置就没有用，有些时候可能有特殊用途） 如 果设置了glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);，则表示源颜色乘以自身的alpha 值，目标颜色乘以1.0减去源颜色的alpha值，这样一来，源颜色的alpha值越大，则产生的新颜色中源颜色所占比例就越大，而目标颜色所占比例则减 小。这种情况下，我们可以简单的将源颜色的alpha值理解为“不透明度”。这也是混合时最常用的方式。 如果设置了glBlendFunc(GL_ONE, GL_ONE);，则表示完全使用源颜色和目标颜色，最终的颜色实际上就是两种颜色的简单相加。例如红色(1, 0, 0)和绿色(0, 1, 0)相加得到(1, 1, 0)，结果为黄色。
注意： 所 谓源颜色和目标颜色，是跟绘制的顺序有关的。假如先绘制了一个红色的物体，再在其上绘制绿色的物体。则绿色是源颜色，红色是目标颜色。如果顺序反过来，则 红色就是源颜色，绿色才是目标颜色。在绘制时，应该注意顺序，使得绘制的源颜色与设置的源因子对应，目标颜色与设置的目标因子对应。不要被混乱的顺序搞晕 。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7664adb437219de644662e6654635864/" rel="bookmark">
			PHP  http(file_get_content) GET与POST请求方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.GET方式请求
[php] view plain copy &lt;?php $data = array('sParam1'=&gt;'test1','sParam2'=&gt;101,'isAuto'=&gt;1); //定义参数 $data = @http_build_query($data); //把参数转换成URL数据 $aContext = array('http' =&gt; array('method' =&gt; 'GET', 'header' =&gt; 'Content-type: application/x-www-form-urlencoded', 'content' =&gt; $data )); $cxContext = stream_context_create($aContext); $sUrl = 'http://www.mytest.com/test.php'; //此处必须为完整路径 $d = @file_get_contents($sUrl,false,$cxContext); print_r($d); ?&gt; 2.POST方式请求
[python] view plain copy &lt;?php $data = array('sParam1'=&gt;'test1','sParam2'=&gt;101,'isAuto'=&gt;1); //定义参数 $data = @http_build_query($data); //把参数转换成URL数据 $aContext = array('http' =&gt; array('method' =&gt; 'POST', 'header' =&gt; 'Content-type: application/x-www-form-urlencoded', 'content' =&gt; $data )); $cxContext = stream_context_create($aContext); $sUrl = 'http://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7664adb437219de644662e6654635864/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/535fe3c9726e3dceae98b1849c8b1e01/" rel="bookmark">
			Windows 7 英文版操作系统中文软件乱码解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自：http://jingyan.baidu.com/article/e9fb46e1ca8c3c7521f766e0.html
Start --&gt; Control Panel --&gt; Clock, Language and Region--&gt; Change display language --&gt; Administration --&gt; Change system locale --&gt; Current system locale 选择 Chineses(Simplified, PRC) --&gt; 重启计算机
转载自：http://jingyan.baidu.com/article/a948d651b142a10a2dcd2e1a.html
Step 1
第一步打开控制面板，选择Clock，Language，and Region（时钟、语言和区域），第二步选择Region and Language，在新弹出的窗口中，Formats标签中，选择Chinese（Simplified，PRC）。在Location标签卡中，Current Location下拉框中选择China。在最后一个Administrative，最下面的选项里选择Chinese（Simplified，PRC），这样我们的设置就结束了。
Step 2
一般来说，这样设置之后，基本上所有程序都会正常了，如果你发现还有一些不能正常显示的，比如迅雷、光影魔术手等等，这时候你可以选择安装最新版的程序。
Step 3
最后如果做了上面的所有操作，您的系统中仍然有软件会有乱码问题，那还有一招杀手锏，修改注册表中的一个键值，实际上这个键值是用来定义安装的区域位置的，根据对比发现，我们无法通过控制面板进行修改它，所以只能用注册表的方式来解决。打开注册表Start输入regedit，进入到如下目录[HKEY_CURRENT_USER --&gt; Control Panel --&gt; International]，将其中的“Locale”键值修改成“00000804”，保存然后关闭注册表。这样我们就基本能解决乱码问题了。
英文版win7记事本中文乱码
转载自：http://blog.sina.com.cn/s/blog_6ab264c60100zkfm.html
打开记事本Notepad, Format --&gt; Font --&gt; 选择中文字体或其他Chinese GB2312字体，例如 Fixedsys --&gt; 搞定
Notepad++中文乱码解决方案
转载自：http://blog.sina.com.cn/s/blog_4b0ea3990100zp75.html
中文：
菜单-》设置-》语言格式设置-》字体格式-》字体名称：Microsoft YaHei
-》使用全局字体 English:
Menue-&gt;Settings-&gt;Style Configurator-&gt;Font Style-&gt;Font name: Microsoft YaHei
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/535fe3c9726e3dceae98b1849c8b1e01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0cf5cc66eff653cfb9ee213193b026e/" rel="bookmark">
			清除UIWebView的背景色的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题时间：2014.1.5 下午1：10
问题描述:UIWebView始终有白底
解决方案：设置背景色为clearColor，并且将opaque= no;
引用资料：http://code4app.com/ios/%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%98%BE%E7%A4%BAGIF%E5%9B%BE%E7%89%87/505c04ce6803fa622d000000
代码片段：
webView.backgroudColor = [UIColor clearColor]; webView.opaque = NO; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8389ac7e01181ac49ef9b4c296e1673/" rel="bookmark">
			MVC4相关Razor语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		﻿﻿ 默认建的工程都自带的了一个_ViewStart.cshtml文件，文件里面的代码如下：
[csharp] view plain copy print ? @{ Layout = "~/Views/Shared/_Layout.cshtml";} @{ Layout = "~/Views/Shared/_Layout.cshtml";} 这里的 @{Layout="文件路径";} 代码块指定了整个项目默认所使用的布局文件（如图：）
左边蓝色部分显示了MVC4提供的默认的布局文件，我们看看_Layout.cshtml里面的内容： 不难看出，_Layout.cshtml里面就是html静态页面。对于里面的一些语法做简单的说明：
@RenderBody()对于所有的页面默认的情况下都会使用这个布局(WebForm的模板) @RenderBody()相当于一个占位符其他页面的所有内容都会被引擎渲染在这个地方。
@RenderSecion()这个占位符表示：在这里会渲染页面里面的一个节（可以是html代码也可以是c#代码和Html的结合体）。
Note:假如你不想使用默认的布局，或者是你的web应用有多个页面布局文件怎么办呢？
其实很简单，例如：你新建了一个view页面UserInfo.cshtml，你可以在UserInfo.cshtml文件里面写上
@{Layout = null;}
就可以了，这个时候就不会应用布局文件了，假如你想定义一个新的布局(依照惯例优先的原则)，我们在Views/Shared下面创建一个自己的布局_MyLayout.cshtml文件，然后我们给我们创建的新页面指定如下的布局就行了：
@{ Layout = "~/Views/Shared/_MyLayout.cshtml";} 对于上面的
@RenderSection("scripts", required: false)做一个补充说明，第一个参数指明：在子页面被渲染的节的名称，第二个参数：指定子页面这个节是否是必需的，如果指定了required:true;但是在子页面没有给这个名称的节的话，编译是通不过的。 如果我们想在母版页使用默认的节可以做如下的判断：
[csharp] view plain copy print ? @if(IsSectionDefined("sectionName")) { @RenderSection("sectionName") } else { &lt;span&gt;默认节&lt;/span&gt; } @if(IsSectionDefined("sectionName")) { @RenderSection("sectionName") } else { &lt;span&gt;默认节&lt;/span&gt; } 假如子页面有这个节我们就渲染子页面的，没有的话就显示我们默认的Html块(例如：网站的头部，底部，侧边栏等等)。
Razor语法的分类 基本语法
[csharp] view plain copy print ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8389ac7e01181ac49ef9b4c296e1673/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df0438ebe6b684d3c8e2755146ced426/" rel="bookmark">
			安卓入门：动态输入日期与时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天对DatePicker和TimePicker进行了学习，并且参照了教程自己打了一遍。 DatePicker 与TimePicker 应用 ① 新建工程 ② 修改main.xml 布局，添加一个DatePicker、一个TimePicker、一个TextView &lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;AbsoluteLayout android:id="@+id/widget0" android:layout_width="fill_parent" android:layout_height="fill_parent" xmlns:android="http://schemas.android.com/apk/res/android" &gt; &lt;DatePicker android:id="@+id/my_DatePicker" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_x="10px" android:layout_y="10px"&gt; &lt;/DatePicker&gt;&lt;!-- 日期设置器--&gt; &lt;TimePicker android:id="@+id/my_TimePicker" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_x="10px" android:layout_y="150px"&gt; &lt;/TimePicker&gt;&lt;!-- 事件设置器--&gt; &lt;TextView android:id="@+id/my_TextView" android:layout_width="228px" android:layout_height="29px" android:text="TextView" android:layout_x="10px" android:layout_y="300px"&gt; &lt;/TextView&gt; &lt;/AbsoluteLayout&gt; ③ DatePicker 的初始化与日期改变事件的处理 /* 定义程序用到的UI元素对象:日历设置器*/ DatePicker my_datePicker; /* findViewById()从XML中获取UI元素对象*/ my_datePicker = (DatePicker) findViewById(R.id.my_DatePicker); -----------------------------------Android 编程基础 41 ④ TimePicker 的初始化与时间改变事件的处理 ⑤ 修改mainActivity.java，添加动态修改时间并显示效果 /*为日历设置器添加点击事件监听器，处理设置日期事件*/ my_datePicker.init(my_Year, my_Month, my_Day, new DatePicker.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df0438ebe6b684d3c8e2755146ced426/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a3af9fd318bd3cf346510d0d38b5e10/" rel="bookmark">
			详解Java中的clone方法 -- 原型模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java中对象的创建 clone顾名思义就是复制， 在Java语言中， clone方法被对象调用，所以会复制对象。所谓的复制对象，首先要分配一个和源对象同样大小的空间，在这个空间中创建一个新的对象。那么在java语言中，有几种方式可以创建对象呢？ 1 使用new操作符创建一个对象 2 使用clone方法复制一个对象 那么这两种方式有什么相同和不同呢？ new操作符的本意是分配内存。程序执行到new操作符时， 首先去看new操作符后面的类型，因为知道了类型，才能知道要分配多大的内存空间。分配完内存之后，再调用构造函数，填充对象的各个域，这一步叫做对象的初始化，构造方法返回后，一个对象创建完毕，可以把他的引用（地址）发布到外部，在外部就可以使用这个引用操纵这个对象。而clone在第一步是和new相似的， 都是分配内存，调用clone方法时，分配的内存和源对象（即调用clone方法的对象）相同，然后再使用原对象中对应的各个域，填充新对象的域， 填充完成之后，clone方法返回，一个新的相同的对象被创建，同样可以把这个新对象的引用发布到外部。 复制对象 or 复制引用 在Java中，以下类似的代码非常常见： Person p = new Person(23, "zhang"); Person p1 = p; System.out.println(p); System.out.println(p1); 当Person p1 = p;执行之后， 是创建了一个新的对象吗？ 首先看打印结果： com.pansoft.zhangjg.testclone.Person@2f9ee1ac
com.pansoft.zhangjg.testclone.Person@2f9ee1ac
可已看出，打印的地址值是相同的，既然地址都是相同的，那么肯定是同一个对象。p和p1只是引用而已，他们都指向了一个相同的对象Person(23, "zhang") 。 可以把这种现象叫做引用的复制。 （关于引用和对象的区分，可以参考我之前的文章Java中的String为什么是不可变的？ -- String源码分析 ， 其中有一节讲到了引用和对象的区分）。上面代码执行完成之后， 内存中的情景如下图所示： 而下面的代码是真真正正的克隆了一个对象。 Person p = new Person(23, "zhang"); Person p1 = (Person) p.clone(); System.out.println(p); System.out.println(p1); 从打印结果可以看出，两个对象的地址是不同的，也就是说创建了新的对象， 而不是把原对象的地址赋给了一个新的引用变量： com.pansoft.zhangjg.testclone.Person@2f9ee1ac
com.pansoft.zhangjg.testclone.Person@67f1fba0
以上代码执行完成后， 内存中的情景如下图所示： 深拷贝 or 浅拷贝 上面的示例代码中，Person中有两个成员变量，分别是name和age， name是String类型， age是int类型。代码非常简单，如下所示： public class Person implements Cloneable{ private int age ; private String name; public Person(int age, String name) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a3af9fd318bd3cf346510d0d38b5e10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/812a4325adb467a9b479149e22c8fc64/" rel="bookmark">
			在MTK6572当中如何增加一个新按键，而且此按键值在虚拟按键当中可以使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在物理按键当中如果你要增加一个新按键： [Description] How to add a new key on android ICS/ICS2 [Solution] 1.在DCT tool keypad list 文件增加新按键的选项 alps\mediatek\source\dct\Keypad_YuSu.cmp中添加新键，如SMS快捷键 KEY_SYM KEY_SMS KEY_0 2.打开DCT tool 在keypad矩阵中在相应定义的按键位中添加新按键，如SMS，然后Save 3.修改linux 键盘码文件input.h 由于preloader\uboot\kernel\factory 等情况分开使用，相应的文件路径下的input.h都应该修改为新按键增加键码值 kernel\include\linux\input.h bionic\libc\kernel\common\linux\input.h external\kernel-headers\original\linux\input.h external\qemu\linux_keycodes.h mediatek\plaform\mt6575\preloader\src\drivers\inc\linux\input.h Mediatek\plaform\mt6575\uboot\inc\linux\input.h 如KEY_SMS #define KEY_SMS 252 4.增加keypad layout文件键盘映射，linux和android key映射 mediatek\config\&lt;project name&gt;\mtk-tpd.kl 如： key 252 SMS 其中252 是linux键码，SMS是android识别key值 如果是需要唤醒系统，还需要增加WAKE 如果新按键是全键盘的一些生僻字符，修改： mediatek\config\&lt;project name&gt;\mt6575-kpd.kcm 5.修改Java识别keycode mt6515 framework/base/include/ui/KeyCodelabels.h mt6572平台如下路径 framework/base/include/androidfw/KeyCodelabels.h KEYCODES数据结构后面增加 {"SMS",220} mt6515 framework/base/native/include/android/KeyCodes.h mt6572 framework/native/include/android/KeyCodes.h 在按键定义项增加AKEYCODE_SMS = 220; 6.修改Java 键盘事件 framework/base/core/java/android/view/keyevent.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/812a4325adb467a9b479149e22c8fc64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3d2599cc8ebfcd6319e6be4c36f34f6/" rel="bookmark">
			android ListView上拉加载更多 下拉刷新功能实现（采用pull-to-refresh）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android实现上拉加载更多功能以及下拉刷新功能，
采用了目前比较火的PullToRefresh，他是目前实现比较好的下拉刷新的类库。
目前他支持的控件有：ListView， ExpandableListView，GridView，WebView等。
下载地址：https://github.com/chrisbanes/Android-PullToRefresh
首先第一步当然是导入libriay到咱们的项目了，具体导入方式，这里不再赘述。
下面是个例子采用的是ListView，当然其余的和这个类似
1、布局文件activity_main.xml
01 &lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" 02 xmlns:tools="http://schemas.android.com/tools" 03 android:layout_width="match_parent" 04 android:layout_height="match_parent" 05 tools:context=".MainActivity" &gt; 06 07 &lt;com.handmark.pulltorefresh.library.PullToRefreshListView 08 android:id="@+id/pull_refresh_list" 09 android:layout_width="fill_parent" 10 android:layout_height="fill_parent" /&gt; 11 &lt;/RelativeLayout&gt; 2、要实现下拉刷新的功能很简单，只需要实现OnRefreshListener的OnRefresh方法即可。这里说一下如何实现上拉和下拉分别执行不同的操作。 这里参考了http://blog.csdn.net/ueryueryuery/article/details/17440465
原理是：根据下拉和上拉显示的布局的可见状态类区分上拉还是下拉，然后执行相应操作。
在PullToRefresh的类库的com.handmark.pulltorefresh.library包下，打开PullToRefreshBase.java，在这个类的最后面添加如下代码：
1 public boolean isHeaderShown() { 2 return getHeaderLayout().isShown(); 3 } 4 5 public boolean isFooterShown() { 6 return getFooterLayout().isShown(); 7 } 3、在Activity的代码如下： 01 public class MainActivity extends ListActivity { 02 03 private PullToRefreshListView mPullToRefreshListView; 04 05 private LinkedList&lt;String&gt; mItemList; 06 private ArrayAdapter&lt;String&gt; adapter; 07 08 private Context context; 09 @Override 10 protected void onCreate(Bundle savedInstanceState) { 11 super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3d2599cc8ebfcd6319e6be4c36f34f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8797acd1ec4b9e8007f858cdf38d9e7f/" rel="bookmark">
			Git 教程 - Git 基本用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Git 教程 - Git 基本用法
您的评价:
收藏该经验
Git 是当前最流行的版本控制程序之一，文本包含了 Git 的一些基本用法 创建 git 仓库 初始化 git 仓库 mkdir project # 创建项目目录 cd project # 进入到项目目录 git init # 初始化 git 仓库。此命令会在当前目录新建一个 .git 目录，用于存储 git 仓库的相关信息 初始化提交 touch README git add . # 将当前目录添加到 git 仓库中， 使用 git add -A 则是添加所有改动的文档 git commit -m "Initial commit" git remote add origin git @github.com:lugir /repo.git # 设置仓库 修补提交（修补最近一次的提交而不创建新的提交） git commit --amend -m "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8797acd1ec4b9e8007f858cdf38d9e7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/faaba6f97fb271f438c24f0bcdbb45b5/" rel="bookmark">
			好压打开压缩包文件名乱码问题一步教你解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：
用好压打开同事给发的压缩包后，打开查看和解压的文件夹里面文件名都是乱码。截图如下：
原因：
1.编码方式不一样。像linux下文件名是用UTF-8编码，win32下文件名是用GBK编码。
2.使用不同压缩软件压缩的，比如你打开的这个压缩包是winrar压缩的，用好压打开就会文件名乱码
解决：
用好压软件打开压缩包，在“选项——Language——设置代码页——更多代码页与设置”选择UTF-8，在后面两个复选框上打勾；这时有时可能在压缩包内查看文件名仍然是乱码，但是解压后文件名已正常了。操作图解：
结果：
版权所有：yangkai
转载请指明：http://blog.csdn.net/tianyazaiheruan
转载于:https://www.cnblogs.com/yangkai-cn/p/4017213.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccecab9e9177f595cf0580ecb017e4aa/" rel="bookmark">
			解析JSON问题（一）包含特殊字符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用JSON从后台向前台传输数据的时候，当数据本身含有一些特殊字符，会导致JSON数据的解析出错。 使用下面的方法对即将向前台输出的json字符串进行处理，可以解决键盘上能输入的所有特殊字符问题。
//当文本中含有如下特殊字符时，此方法可以成功处理，让其在前台被正确解析，注意：此法不能处理单引号
publicstatic String stringToJson(String s){ StringBuffersb = new StringBuffer(); for(int i=0; i&lt;s.length(); i++){ charc =s.charAt(i); switch(c){ case'\"': sb.append("\\\""); break; // case'\\': //如果不处理单引号，可以释放此段代码，若结合下面的方法处理单引号就必须注释掉该段代码 // sb.append("\\\\"); // break; case'/': sb.append("\\/"); break; case'\b': //退格 sb.append("\\b"); break; case'\f': //走纸换页 sb.append("\\f"); break; case'\n': sb.append("\\n");//换行 break; case'\r': //回车 sb.append("\\r"); break; case'\t': //横向跳格 sb.append("\\t"); break; default: sb.append(c); }} returnsb.toString(); } //注意，下面的方法是在把你的数据文本接入json数据字符串之前使用，预先对文本做处理后在接入JSON字符串 //处理文本中的单引号 和 斜杠
publicstatic String StringDanYinToJSON(String ors) { ors= ors == null ? "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccecab9e9177f595cf0580ecb017e4aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/554b427d34d9c82d723f12e805de3735/" rel="bookmark">
			JAVA中的反射机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		反射，当时经常听他们说，自己也看过一些资料，也可能在设计模式中使用过，但是感觉对它没有一个较深入的了解，这次重新学习了一下，感觉还行吧！
一，先看一下反射的概念：
主要是指程序可以访问，检测和修改它本身状态或行为的一种能力，并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义。
反射是java中一种强大的工具，能够使我们很方便的创建灵活的代码，这些代码可以再运行时装配，无需在组件之间进行源代码链接。但是反射使用不当会成本很高！
看概念很晕的，继续往下看。
二，反射机制的作用：
1，反编译：.class--&gt;.java
2,通过反射机制访问java对象的属性，方法，构造方法等；
这样好像更容易理解一些，下边我们具体看怎么实现这些功能。
三，在这里先看一下sun为我们提供了那些反射机制中的类：
java.lang.Class; java.lang.reflect.Constructor; java.lang.reflect.Field; java.lang.reflect.Method;
java.lang.reflect.Modifier;
很多反射中的方法，属性等操作我们可以从这四个类中查询。还是哪句话要学着不断的查询API，那才是我们最好的老师。
四，具体功能实现：
1，反射机制获取类有三种方法，我们来获取Employee类型
//第一种方式： Classc1 = Class.forName("Employee"); //第二种方式： //java中每个类型都有class 属性. Classc2 = Employee.class; //第三种方式： //java语言中任何一个java对象都有getClass 方法 Employeee = new Employee(); Classc3 = e.getClass(); //c3是运行时类 (e的运行时类是Employee) 2，创建对象：获取类以后我们来创建它的对象，利用newInstance：
Class c =Class.forName("Employee"); //创建此Class 对象所表示的类的一个新实例 Objecto = c.newInstance(); //调用了Employee的无参数构造方法. 3,获取属性：分为所有的属性和指定的属性：
a，先看获取所有的属性的写法：
//获取整个类 Class c = Class.forName("java.lang.Integer"); //获取所有的属性? Field[] fs = c.getDeclaredFields(); //定义可变长的字符串，用来存储属性 StringBuffer sb = new StringBuffer(); //通过追加的方法，将每个属性拼接到此字符串中 //最外边的public定义 sb.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/554b427d34d9c82d723f12e805de3735/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58c0984e713b0ebcba679a829512c693/" rel="bookmark">
			公司服务器部署规划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目需求
1.产品宣传
通过网络宣传自己产品，必然不能被忽视、网络宣传、论坛交流、网站广告、网上订单等 都必需通过WEB站点网站来实现。搭建Web网站是每个公司都需要做的事情。
2. 信息共享
搭建web站点、文件服务器来实现 公司内部信息资料共享，发布公司各种通知、任务计划等。
3. 信息交流
和其它公司进行交流、
4.远程访问
员工出差或对远的 部门 、分公司需要和总公司保持信息交流采用××× 远程连接公司。
5.计算机维护
糸统更新服务器、DHCP服务器、病毒服务器及windows部署服务器等 ,能够使公司安全、稳定地运行
二：项目分析
网络搭建需要根据 公司现在的场地、人员、设备等情况，然后 分析网络建设所需要的内容，做出一份网络分析报告
1. Active Dircetory 域服务和DNS服务
域服务是用来用户访问各种服务的身份验证、部署用户策略
DNS服务是网站域名和用户访问internet中的网站 需要域名解析。
2.DHCP服务
用户计算机分配IP地址，不必手动配置，减少配置错误和网络故障
3.文件服务
在局域网中，公司文件信息进行共享，重要的资料数据保存在文件服务器则文件服务器需要配置大容量的硬盘并配置高速网络连接。由于文件服务器负载较大，需要和其他服务器一起配置成集群，减轻负担。
4.电子证书服务
资料数据在网络传输可以进行加密 防止被人截获。
5.打印服务A
使用打印服务，可以对网络中的打印机进行管理，及时调整打印任务,加快打印时间。
6.web站点和FTP站点
搭建网站必备功能，FTP服务可以更新网站，也可以通过interent来上传或下载文件。
7.邮件服务
公司的员工和员工之前，本公司和其他公司之间交流需要利用邮件服务器来实现。exchangeserver 搭建邮件服务器的首选，同时还具有信息共享功能
8.Windows 部署服务和系统更新服务
Windows 部署服务 可以让用户重新安装一个全新的操作系统，不必进行各种设置系统更新服务则可以保证用户的计算机及安装各种更新，不会因系统漏洞而出现各种故障。
9.Windows sharepointserver 可以提高公司内部人员之间的交流，时用户及时了解公司领导所发布的通知、任务、并使职工之间能够共享信息。
10.虚拟机服务
充分发挥网络设备功能，一台服务器当作几台服务器来用
11.终端服务
可以将一套软件发布到网络中，使所有用户都可以使用。
12.×××服务：员工出差可以访问公司内部网络，需要配置一台×××服务器
三：项目规划
1.域名和结构规划
为了便于对用户进行身份验证 需要采用域结构。 需要安装一台域控制器和辅助域控制器，并为网络中的用户创建一个用户帐号。
网络中所有服务器都加入域，可以进行统一管理。没加入域的计算机，只有用户在访问某台服务器或者访问某个网络中的服务时，需要域用户账户进行验证。使用域和DNS服务，必须设置一个DNS域名。用于web站点、邮件服务器发布到网络中。则DNS域名需要向域名注册机构注册。
2.管理权限规划
根据每个用户的工作不同、要对所负责的工作赋予相应权限，而用户未涉及的工作，则一律设置为只读或者拒接权限。
四：IP地址规划
私网IP地址分为A B C 类
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58c0984e713b0ebcba679a829512c693/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b3b81c1d67250f9dfd2cea7a275d006/" rel="bookmark">
			Linux网络配置 -- 各种配置文件及其作用篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. Linux平台下各种网络相关配置文件(RedHat Linux为例) -----------------------------------------------------------------------------------------------------------------------------------
1. 文件/etc/hosts
(1) 文件格式
以#开头的是注释
每行包括：第一部份：网络IP地址；第二部份：主机名或域名；第三部份：主机名别名；
注意：这里稍微解释一下主机名(hostname)和域名(Domain）的区别：主机名通常在局域网内使用，通过hosts文件，主机名就被解析到对应ip；域名通常在internet上使用，但如果本机不想使用internet上的域名解析，这时就可以更改hosts文件，加入自己的域名解析。
例如一个/etc/hosts文件的可能实例为如下所示:
#This is the comment part of /etc/hosts file
127.0.0.1 localhost.localdomain localhost
192.168.0.1 otherhost.domain otherhost
(2) 文件作用
Linux 的/etc/hosts是配置IP地址和其对应主机名的文件，这里可以记录本机的或其他主机的IP及其对应主机名。
(3)管理该文件相关的Linux命令
与此相关的Linux命令有：hostname
hostname -a 命令显示该主机的别名，这就是文件/etc/hosts第三列以后的部分
hostname -d命令显示主机所在的域名，这就是文件/etc/hosts第二列的内容
hostname -i 命令显示主机的IP地址，这就是文件/etc/hosts第一列的内容
-----------------------------------------------------------------------------------------------------------------------------------
2. 文件/etc/nsswitch.conf
(1) 文件格式
文件/etc/nsswitch.conf中每一行的格式如下：
INFO: METHOD[[ACTION]] [METHOD [[ACTION]] ...]
(1.1) INFO --&gt; 指定该行所描述的信息的类型
nsswitch.conf文件通常控制着用户，口令，主机IP和组信息的搜索。下面列举了具体的INFO类型及其含义
automount --&gt; 自动挂载
bootparams --&gt; 无盘引导选项和其他引导选项
ethers --&gt; MAC地址
group --&gt; 用户所在组(/etc/group)
hosts --&gt; 系统信息(/etc/hosts)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b3b81c1d67250f9dfd2cea7a275d006/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7426bbbd69763f2976b9c2e22dd3b975/" rel="bookmark">
			Hello Netgen
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hello Netgen eryar@163.com
摘要Abstract：本文主要介绍如何对下载的Netgen源码进行编译生成Netgen程序和程序开发所需要的库nglib。
关键字Key Words：Netgen, nglib, Mesh Generator, OpenCascade, Triangulation
一、引言 Introduction NETGEN是一个二维/三维自动网格剖分工具，并且遵循LGPL开源协议。即可以作为一个带有用户界面的单独程序使用，也可以作为C++的库文件被其它程序链接。Netgen可以跨平台，支持Unix/Linux和Windows。
Netgen最早为奥地利科学家Joachim Schoberl编写的网格剖分程序，是网格划分技术中极为先进与完善的，在3D网格划分领域更是具有极大的优势。可以从sourceforge上获取最新版本的Netgen5.1，网址是：http://sourceforge.net/projects/netgen-mesher/，如下图所示：
Figure 1.1 Netgen Mesh Generator on SourceForge.net
本文主要介绍如何对下载的Netgen源码进行编译生成Netgen程序和程序开发所需要的库nglib。
二、Netgen的安装 Installing Netgen 根据机器的配置选择32位或64位的安装程序，和普通软件的安装一样，下一步直到完成，安装好之后就可以使用了。
Figure 2.1 Netgen 5.1
安装完成后，在程序的开始菜单中会生成链接，如下图所示：
Figure 2.2 Netgen in Start menu
选择Netgen 5.1即可启动程序，测试一下效果，如下图所示：
Figure 2.3 Mesh generated by Netgen
三、Netgen的编译 Compiling Netgen 如果需要在程序中使用Netgen，就需要编译Netgen来生成程序开发使用Netgen的库nglib。编译Netgen需要第三方库的支持，必须的第三方库有：
l pthread-w32
l TclTkTixTogl
l zlib
其中pthread-w32和TclTkTixTogl的库都可以从Netgen的SourceForge上的AdditionalFiles中下载得到。若需要对IGES或STEP文件的读写，还需要安装OpenCascade。
Figure 3.1 3rdparty library for Netgen
原来没发现Netgen在这里把这些第三方库都提供了，尝试自己编译Tcl、Tk和Togl，前两个已经编译成功了，编译到Togl时也没找到什么资料，就放弃了，浪费了时间。直接根据需要下载Visual Studio对应的第三方库文件，再下载好zlib，很快就可以编译成功了。最好按如下方式来组织这些第三方库：
Figure 3.2 Default location of 3rdparty library for Netgen
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7426bbbd69763f2976b9c2e22dd3b975/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f84d631ab64a8f2b156afa3e79209081/" rel="bookmark">
			vs遇到异常，这可能是由某个拓展引起的的其他原因及解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		﻿﻿ 2014的第一件事
上个星期实训时，新建一个MFC的解决方案，当点头文件的时候总是会弹出一个对话框说：遇到异常，这可能是由某个扩展所致。如下图所示
对于这个问题，我被困扰了好几天，这几天来可谓寝食难安。直到今天半夜三点半终于解决了。顿时困意全无，写下此篇，为各位使用VS开发工具遇到这样的问题而无法解决的朋友一点参考；同时也为我刚过去的诸事不顺的2013道个别，希望我的2014有一点转机。
当发现这个问题的时候还不以为意，觉得应该不用太费心就解决了，后来百度了发现有不少网友也遇到这样的问题。他们给出的答案是：修改相应的注册表即可
1、在运行中输入命令：regedit，打开注册表编辑器
2、32位系统查找注册表的项： [HKEY_CLASSES_ROOT\CLSID\{73B7DC00-F498-4ABD-AB79-D07AFD52F395}\InProcServer32]，
把它的默认值修改为：
C:\ProgramFiles\Common Files\Microsoft Shared\MSEnv\TextMgrP.dll
而对于64位的系统，查找项：
[HKEY_CLASSES_ROOT\Wow6432Node\CLSID\{73B7DC00-F498-4ABD-AB79-D07AFD52F395}\InProcServer32]
把它的默认值修改为：
C:\Program Files (x86)\CommonFiles\Microsoft Shared\MSEnv\TextMgrP.dll
我按照上面的做了之后，为了安全起见还重启了一遍电脑，满怀希望的打开工程，结果问题依旧。无奈只好继续百度，有人说在vs2010的时候遇到过这样的问题，是由于装了08的msdm引起的，因此我决定把帮助文档卸载了，但是还是不能解决。后来想想，既然是扩展引起的，我干脆把拓展的插件都卸载了
包括vs助手和vs的主题，但是还是没解决啊这时我又觉得是其他位置注册表被改了，所以决定用原版的镜像文件修复一下，经过大概半个小时的修复，以为这样应该总的了吧，打开工程，结果那个对话框又再次亮瞎双眼。既然无法修复那就 痛下决心重装系统吧，你不是注册表 被改了么？我重装还不行吗？于是重装了系统，再重新装了vs2012,装好vs助手和按照自己的习惯设置好相关设置，好，新建MFC工程，在头文件和.cpp之间来回切换看有没有问题，结果还是很不争气的出问题了，这到底是怎么回事呢，都重装了都不能解决，难道是vs助手是破解版的问题？再次重装系统和vs，这次不装破解版的，只可惜最后问题依旧。难道又是vs版本的问题？感觉不可能啊，之前用着好好的，不过我还是决定花3g校园网流量下载了vs2012的高级版和专业版，装上去，还是每解决啊，难道会是系统问题？于是把系统从8.1企业版换成专业版，再换成8.0的专业版，并且是装完系统和驱动马上装vs,都是开始可以用以下，后面就出问题了。这都没办法解决，真的要崩溃了。想想这2013就没有一件事是顺利的，在这一年的最后几天了还不让我舒舒坦坦的过。
下面是发现问题和暂时解决的办法：在无数次失败时候正打算试试会服vs的所有默认设置，结果居然问题解决了，这时装上vs助手并且破解，没问题，再装上主题，也没问题，最后按照自己习惯设置vs，结果问题出来了，这时貌似发现问题所在了，就是自己对vs的配置问题，看看自己的设置，我无非是设置了下面几个地方
所以最后一个一个地测试，发现只要我把c/c++的自动换行去掉就解决问题了，对于为什么是这样，由于自己才疏学浅，不知道原因。总之这个问题总算解决了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28cb7e8c029deb3f7597f7a2d2fbc2a6/" rel="bookmark">
			Delphi XE4中Or, In, CharInSet,哪个更快？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Delphi XE4中测试用Or,In,CharInSet三种方式，实现判断一个字符是否在一个字符数组中。 作者提供了代码： procedure TForm7.FormCreate(Sender: TObject); const Max = 200000000; var S : AnsiString; PBuffer : PByte; Count : Integer; I : Integer; pf : int64; st : int64; et : int64; begin WinApi.Windows.QueryPerformanceFrequency( pf );//获得机器内部定时器的时钟频率 SetLength( S, Max ); for I := 1 to Max do S[i] := AnsiChar( random(128-32) 31 ); WinApi.Windows.QueryPerformanceCounter( st );//取得开始值 Count := 0; PBuffer := @S[1]; while PAnsiChar(PBuffer)^&lt;&gt;#0 do begin if (PAnsiChar(PBuffer)^='M') or (PAnsiChar(PBuffer)^='Z') or (PAnsiChar(PBuffer)^='x') or (PAnsiChar(PBuffer)^='y') or (PAnsiChar(PBuffer)^='*') then Inc(Count); Inc( PBuffer ); end; WinApi.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28cb7e8c029deb3f7597f7a2d2fbc2a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86aca316d0fe505a6e9a630462603e1f/" rel="bookmark">
			delphi中in的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题: 在Delphi中，如何将集合数据类型中的某元素取出来？如set1:=[1,2,3,4,5,6]中的第三项3取出放入一变量中。 Delphi的集合不同于数组或者List或者VB的Collection，它的元素是没有顺序，所以不存在某个集合中的第3项的说法。
你只能用in判断某个元素是否在Delphi的集合中。
如 if 3 in set1 then ... else ... 例如 防止输入非整数字符 procedure TForm1.Edit2KeyPress(Sender: TObject; var Key: Char); begin if not (key in [’0’..’9’, #8]) then //防止输入非整数字符 key := #0; end; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f829a391bc171e0de0e9bd8183e4f90e/" rel="bookmark">
			C#中字符数组，字节数组和string之间的转化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：http://hi.baidu.com/endyli/item/7bf074945de35e1f934f41fe
来源：
NDC（NetworkDiskClient）的界面和后台程序之间用Socket通信，发送命令。
环境：界面：C# winform
后台：Ｖｃ＋＋，消息通知
网络通信，Ｃ＃是通过网络字节流进行传输的，传输内容是有报文头的Ｐｒｏｔｏｂｕｆ。Ｎｅｔ消息。报文头是struct结构体，先转化成byte[],protobuf消息就先转换为内存流，再stream.ToArray[]转化为字节数组，就可以由Socket传输。
字符串string和内存流MemoryStream及比特数组byte[]互转比较
定义string变量为str,内存流变量为ms,比特数组为bt
1.字符串转比特数组
(1)byte[] bt=System.Text.Encoding.Default.GetBytes("字符串");
(2)byte[] bt=Convert.FromBase64String("字符串");
2.字符串转流
(1)MemoryStream ms=new MemoryStream(System.Text.Encoding.Default.GetBytes("字符串"));
(2)MemoryStream ms=new MemoryStream(Convert.FromBase64String("字符串"));
3.流转比特数组
(1)byte[] bt=ms.ToArray();
(2)MemoryStream ms=new MemoryStream();ms.Write(bt,0,ms.Length);
4.流转字符串
(1)string str=Convert.ToBase64String(ms.ToArray());
(2)string str=System.Text.Encoding.Default.GetString(ms.ToArray());
5.比特数组转字符串
(1)string str=System.Text.Encoding.Default.GetString(bt);
(2)string str=Convert.ToBase64String(bt);
6.比特数组转流
(1)MemoryStream ms=new MemoryStream(bt);
(2)MemoryStream ms=new MemoryStream();ms.Read(bt,0,bt.Lenght);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64c47c266e0610f845f6024f2c035c3d/" rel="bookmark">
			java php 时间戳区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 总结一下java 时间戳和PHP时间戳 的转换问题： 由于精度不同，导致长度不一致，直接转换错误。 JAVA时间戳长度是13位，如：1294890876859 PHP时间戳长度是10位， 如：1294890859 主要最后三位的不同，JAVA时间戳在PHP中使用，去掉后三位，如：1294890876859-&gt; 1294890876 结果:2011-01-13 11:54:36 echo date('Y-m-d H:i:s','1294890876'); 复制代码 PHP时间戳在JAVA中使用，最后加三位，用000补充,如：1294890859-&gt;1294890859000 结果:2011-01-13 11:54:19 SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String dateTime = df.format(1294890859000L); System.out.println(df); 复制代码 总结一下java时间戳和PHP时间戳 的转换问题： 由于精度不同，导致长度不一致，直接转换错误。 JAVA时间戳长度是13位，如：1294890876859 PHP时间戳长度是10位， 如：1294890859 主要最后三位的不同，JAVA时间戳在PHP中使用，去掉后三位，如：1294890876859-&gt; 1294890876 结果:2011-01-13 11:54:36 echo date('Y-m-d H:i:s','1294890876'); PHP时间戳在JAVA中使用，最后加三位，用000补充,如：1294890859-&gt;1294890859000 结果:2011-01-13 11:54:19 SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String dateTime = df.format(1294890859000L); System.out.println(df); 更多 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/868a220b5a76a229a1d23d8b5bfc970c/" rel="bookmark">
			计算2的100次方模5的结果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接求肯定挺痛苦的，利用一个求模的简单性质然后结合递归可以很快算出。
A*B mod 5 = ( (A mod 5) * (B mod 5) ) mod 5
这个性质可以简单证明如下:
假设A mod 5 = K1, B mod 5 = K2. 那么设 A = 5a+K1, B = 5b + K2。那么A*B = (5a+K1)*（5b+K2）= 25ab + 5a*K2 + 5b*K1 + K1*K2,右边表达式的前面三项模5等于0，所以上面性质得证。
那么我们可以利用递归的方法来将2的100次方拆成2的50次方乘以2的50次方，然后2的50次方又可以递归的继续拆，直到2的0次方或者1次方，程序如下:
using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace ConsoleApplication2 { class Program { static void Main(string[] args) { for (int i = 0; i &lt; 101; ++i) { Console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/868a220b5a76a229a1d23d8b5bfc970c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efb5e27101ad69da420abe570c050542/" rel="bookmark">
			递归方法计算数N的二进制表示中1的个数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 利用一个现成的结论：如果N是奇数，那么它等于N/2的二进制表示中的1的个数加1.
剩下的问题就是解决当N是偶数时，如何往基本情况递归了，简单分析一下任何一个偶数的二进制表示的最低位绝对等于0,，那么我们可以推导出一个简单结论：当N是偶数的时候，它二进制包含1的个数应该等于N+1包含的1的个数和减1。因为，N为偶数时，最低位是0，那么N+1的二进制的前面和N的二进制一模一样，只是最低位是1。
所以简单的程序如下：
using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace ConsoleApplication1 { class Program { static void Main(string[] args) { UInt32 value = 0; for (int i = 0; i &lt; 20; ++i) { Console.WriteLine("{0}={1}", value, CalculateOneCountInBinaryFormat(value)); ++value; } } static int CalculateOneCountInBinaryFormat(UInt32 value) { if (value == 0) { return 0; } else if (value == 1) { return 1; } else if (value % 2 == 0) { return CalculateOneCountInBinaryFormat(value + 1) - 1; } else { return CalculateOneCountInBinaryFormat(value / 2) + 1; } } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37274c5541a57eda31314b49febb61c6/" rel="bookmark">
			Physics Engine Box2D(CrossBridge(FlasCC) Version) Demo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 修改命令行：
FLASCC:=/cygdrive/C/Crossbridge_1.0.1/sdk FLEX:=/cygdrive/C/Program Files (x86)/Adobe/Adobe Flash Builder 4.6/sdks/4.6.0 2 MakeFile得到Box2D.swc库文件：
$?EXTRACFLAGS= $?OPT_CFLAGS=-O4 $?MXMLC_DEBUG=false T12: check @echo "------- Example: Box2D --------" mkdir -p build cd build &amp;&amp; PATH="$(call unixpath,$(FLASCC)/usr/bin):$(PATH)" CC=gcc CXX=g++ CFLAGS="$(OPT_CFLAGS) $(BASE_CFLAGS) $(EXTRACFLAGS)" CXXFLAGS="$(OPT_CFLAGS) $(BASE_CFLAGS) $(EXTRACFLAGS)" cmake ../Box2D_v2.2.1/ make recompile recompile: cd build &amp;&amp; PATH="$(call unixpath,$(FLASCC)/usr/bin):$(PATH)" make -j8 cp -f as3api.h build/ cd build &amp;&amp; "$(FLASCC)/usr/bin/swig" -as3 -c++ -I../Box2D_v2.2.1/ -DSWIGPP -module Box2D -outdir . -includeall -ignoremissing as3api.h cd build &amp;&amp; java -jar $(call nativepath,$(FLASCC)/usr/lib/$(AS3COMPILER)) -import $(call nativepath,$(FLASCC)/usr/lib/builtin.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37274c5541a57eda31314b49febb61c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bdc85f2017c8edb418b8c137415e117/" rel="bookmark">
			学习mvvm的好帖子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 http://www.cnblogs.com/xiaobaihome/archive/2011/11/28/2266536.html 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35a87928fb2f25afdd9982c50bbaa016/" rel="bookmark">
			mvvm light入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WPF / MVVM快速入门教程 假设你有C＃的一个体面的理解，在WPF中起步并不太难。我开始看WPF前一阵子，并没有找到很多有用的MVVM教程。希望这篇文章解决了。
如同学习任何新的技术，你得到事后的好处。从我的角度来看，在WPF中几乎每一个教程中，我已经遇到不足以几个原因：
· 这个例子是所有在XAML。
· 这个例子掩盖了，将真正使您的生活更轻松的关键事实。
· 该示例尝试炫耀的WPF/ XAML的功能有很多毫无意义的效果，不帮助你。
· 该示例使用有出现过于相似，框架的关键字和类别，并因此难以确定在（XAML）代码作为用户定义（该属性的类ListBox中的GroupStyle的名称属性是一个完整的头疼的新手）。
因此，要解决这个问题，我写此基础上我本来希望找到的＃1命中谷歌上键入“WPF教程”之后。本文可能不是100％正确的，甚至做的事情“唯一正确的方法”，但它会说明，我想我已经找到一个地方3个月前的要点。
我会很快推出一些主题，然后表明，解释或说明每个点的例子。因此，我还没有真正试图使图形用户界面漂亮，这不是本文的点（见上面的要点）。
由于本教程是相当长的，我已经省略为简便起见，相当多的代码，所以请下载附件中的压缩文件，并查看示例（。NET4.0/VS2010）。每个例子的基础上的前一个。
基础知识 1. 在有关WPF最重要的是数据绑定。总之，你有一些数据，通常以某种形式的集合，并且要显示给用户。你可以'绑定'你的XAML来的数据。
2. WPF中有两个部分，其中描述你的GUI布局和效果的XAML和代码隐藏一个被捆绑到XAML。
3. 最巧妙的也可能是最可重用的方式来组织你的代码是使用'MVVM图案：模型，视图，视图模型。这可确保您的浏览包含极少（或根本没有）代码的目的，而应该是XAML的唯一。
该关键点，你需要知道 1. 你应该使用来保存你的数据的收集是的ObservableCollection &lt;&gt; 。不是一个列表，而不是一个字典，而是一个的ObservableCollection。这个词' 可察觉 '是线索在这里：WPF窗口需要能够“看到”您的数据收集。此集合类实现WPF使用某些接口。
2. 每个WPF控件（包括“窗口的）有一个' 的DataContext '和收集控件有一个' 的ItemsSource “属性绑定到。
3. “该接口INotifyPropertyChanged的 '将被广泛用于通信的图形用户界面和代码之间的数据进行任何修改。
例1：按自己（主要是）错误的 以最好的方式开始就是一个例子。我们将开始与宋级，而不是通常的人物类。我们可以安排成歌曲专辑，或者一个大的集合，或者艺术家。一个简单的松类将如下所示：
收起| 复制代码
public class Song { #region Members string _artistName; string _songTitle; #endregion #region Properties /// The artist name. public string ArtistName { get { return _artistName; } set { _artistName = value; } } /// The song title.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35a87928fb2f25afdd9982c50bbaa016/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea36aa4864cae574f41214b0a5eb6208/" rel="bookmark">
			Java Thread.yield详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
前几天复习了一下多线程，发现有许多网上讲的都很抽象，所以，自己把网上的一些案例总结了一下！
一. Thread.yield( )方法：
使当前线程从执行状态（运行状态）变为可执行态（就绪状态）。cpu会从众多的可执行态里选择，也就是说，当前也就是刚刚的那个线程还是有可能会被再次执行到的，并不是说一定会执行其他线程而该线程在下一次中不会执行到了。
Java线程中有一个Thread.yield( )方法，很多人翻译成线程让步。顾名思义，就是说当一个线程使用了这个方法之后，它就会把自己CPU执行的时间让掉，让自己或者其它的线程运行。
打个比方：现在有很多人在排队上厕所，好不容易轮到这个人上厕所了，突然这个人说：“我要和大家来个竞赛，看谁先抢到厕所！”，然后所有的人在同一起跑线冲向厕所，有可能是别人抢到了，也有可能他自己有抢到了。我们还知道线程有个优先级的问题，那么手里有优先权的这些人就一定能抢到厕所的位置吗? 不一定的，他们只是概率上大些，也有可能没特权的抢到了。
例子：
package com.yield; public class YieldTest extends Thread { public YieldTest(String name) { super(name); } @Override public void run() { for (int i = 1; i &lt;= 50; i++) { System.out.println("" + this.getName() + "-----" + i); // 当i为30时，该线程就会把CPU时间让掉，让其他或者自己的线程执行（也就是谁先抢到谁执行） if (i == 30) { this.yield(); } } } public static void main(String[] args) { YieldTest yt1 = new YieldTest("张三"); YieldTest yt2 = new YieldTest("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea36aa4864cae574f41214b0a5eb6208/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38a6aecb793dfba78f58e7e28074211d/" rel="bookmark">
			利用C#访问注册表获取软件的安装路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		绝大多数软件，基本上都会在注册表中记录自己的名字和安装路径信息。
在注册表中记录这些信息的位置是：
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths
因此，我们只要能访问到注册表的这个位置，就可以获取到某些软件的名称和安装路径信息。
本博文使用C#访问注册表获取软件的安装路径并进行显示。
1 示例程序主画面说明
示例程序主画面如下图所示。
在画面中的文本框中输入可执行程序的名称，点击“获取路径”按钮，便会在画面中的下一行（“获取路径”按钮所在行的下一行）显示出该程序完整的安装路径信息。这里输入的可执行文件名称必须是程序在注册表中的名称，如Adobe Reader在注册表中的名称为“AcroRd32.exe”。
2 示例程序完整代码
using System; using System.Windows.Forms; using Microsoft.Win32; namespace GetSoftWarePathExp { public partial class Form1 : Form { public Form1() { InitializeComponent(); } private void button1_Click(object sender, EventArgs e) { try { string softName = textBox1.Text.ToString(); string strKeyName = string.Empty; string softPath = @"SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\"; RegistryKey regKey = Registry.LocalMachine; RegistryKey regSubKey = regKey.OpenSubKey(softPath + softName + ".exe", false); object objResult = regSubKey.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38a6aecb793dfba78f58e7e28074211d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12b8da37ae515be0480bbc76b3c0c336/" rel="bookmark">
			【python】 关于去掉转义字符\,输出中文字符(decode(&#34;string_escape&#34;))
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 假如有一个GBK的字符aa='\\xC1\\xBD',要输出中文，那么就要利用decode("string_escape")命令，去掉转义字符\,例如下面的代码： #coding=gbk import re aa='\\xC1\\xBD' bb=aa.decode("string_escape") print bb 输出： 两 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cb382ce07b71c8fb8861c573e407ec3/" rel="bookmark">
			wpf button 之win8风格按钮
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网上下来来的代码片段，win 8风格按钮模板
&lt;ControlTemplate TargetType="Button" x:Key="win8" &gt; &lt;!--背景色--&gt; &lt;Border x:Name="back" Opacity="0.8" CornerRadius="3"&gt; &lt;Border.BitmapEffect&gt; &lt;OuterGlowBitmapEffect Opacity="0.7" GlowSize="0" GlowColor="{Binding RelativeSource={RelativeSource TemplatedParent}, Path=(Button.Background).(SolidColorBrush.Color)}" /&gt; &lt;/Border.BitmapEffect&gt; &lt;Border.Background&gt; &lt;LinearGradientBrush StartPoint="0,0" EndPoint="0,1.5"&gt; &lt;GradientBrush.GradientStops&gt; &lt;GradientStopCollection&gt; &lt;GradientStop Color="{Binding RelativeSource={RelativeSource TemplatedParent}, Path=(Button.Background).(SolidColorBrush.Color)}" Offset="0" /&gt; &lt;GradientStop Color="{Binding RelativeSource={RelativeSource TemplatedParent}, Path=(Button.Background).(SolidColorBrush.Color)}" Offset="0.4" /&gt; &lt;GradientStop Color="#FFF" Offset="1" /&gt; &lt;/GradientStopCollection&gt; &lt;/GradientBrush.GradientStops&gt; &lt;/LinearGradientBrush&gt; &lt;/Border.Background&gt; &lt;!--前景色及边框--&gt; &lt;Border x:Name="fore" BorderThickness="1" CornerRadius="3" BorderBrush="#5555"&gt; &lt;Border.Background&gt; &lt;LinearGradientBrush StartPoint="0,0" EndPoint="0,1"&gt; &lt;GradientBrush.GradientStops&gt; &lt;GradientStopCollection&gt; &lt;GradientStop Color="#6FFF" Offset="0.5" /&gt; &lt;GradientStop Color="#1111" Offset="0.51" /&gt; &lt;/GradientStopCollection&gt; &lt;/GradientBrush.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cb382ce07b71c8fb8861c573e407ec3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c333c1be33f700d74639cf4612098103/" rel="bookmark">
			海量高并发处理网站的负载均衡如何设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【IT168 应用】随着线上业务的发展，网站面临高并发访问和海量数据流的情况屡见不鲜，系统中的各个核心设备所负担的处理能力和计算强度也会相应增大，使得单一设备根本无法承担。如果淘汰现有设备去做硬件升级，将造成资源的浪费，而且如果以后面临业务量的激增，又不得不再次投入高额的硬件升级成本，甚至性能再卓越的设备也不能满足将来业务量的需求。
在此种情况下，单纯的网络架构就显得捉襟见肘了，而负载均衡机制则应运而生。服务器负载均衡(Server Load Balancing)，其原理是将工作任务相对均衡地分摊到多个节点(服务器集群)上执行，从而提升整个业务系统的性能。诸如LVS、HA Proxy等开源软件，可以在现有的网络基础架构之上建立负载均衡机制，以满足业务增长的需要，对于网站的来说不啻为一种廉价且有效的扩展性选择。
此外，针对互联网上有可能影响数据传输的各种环节，CDN(Content Delivery Network)内容交付网络的应对方案也适时出现。CDN对网站内容的处理，主要在于利用缓存技术将静态内容快速分发至边缘节点，通过让用户就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度，同时也减轻了网站自身系统的性能压力。
现在看来，貌似我们已经解决了网站发布所面临的所有瓶颈了，但是实际上问题远没有那么简单。一方面，对于数据交互比较频繁的动态内容而言，CDN只能在其中心节点与源数据节点(网站自身系统)之间做有限的传输优化，加速效果远不如静态内容做缓存分发那般明显。
另一方面，随着线上业务、电子商务等领域的Web内容呈现日渐丰富，涌现出了愈发复杂的业务交付需求，这对网站的发布方而言也意味着将面临更多的挑战。因此，当我们抛开网络的传输质量、带宽拥塞程度等外界因素来看的话，又不得不正视一个问题--影响网站访问效果的最大瓶颈还是在于源数据节点自身的处理性能。
以电子商务网站这种典型的大型高并发访问量的线上业务为例，其性能瓶颈最容易出现在联机事务处理(OLTP)的环节，例如访问用户进行条目查阅、订单确认等场景。产生这种情况的原因在于，网站的运营方出于数据安全等因素的考虑，是不可能将后台数据库等资源完全向CDN服务商开放的。由此造成，所有涉及到此类动态资源的访问就会频繁地经由CDN网络的边缘节点上溯到源数据节点(即网站自身系统)来请求实时地响应处理。在保障数据安全性的前提下，要解决网站的性能瓶颈问题，必须提高源数据节点的业务处理效率，因此我们还得从网络架构的设计着手。
前文提到过，单台服务器的处理能力有限，当突发访问量骤然增加的时候，其性能就会成为整个系统的瓶颈，导致用户访问的响应缓慢甚至网站服务器瘫痪。为了满足高并发量访问的需求，可以通过软件手段实现服务器集群的多机负载均衡效果。然而，这种软件式的负载均衡有一个不可避免的缺点，那便是系统的稳定性和性能方面受限于软件所安装运行的服务器，一旦访问量过大时，该台服务器就恰恰成了整个系统的瓶颈所在。
就一个发布线上业务的网站系统而言，前台的Web服务器由于有外部的CDN服务作为静态内容的分流渠道，尚不至于产生明显的系统瓶颈，而后台处理动态内容的核心业务系统就难免会感到压力巨大了。具体分析的话，当前的业务系统多采用客户端--中间件--数据库的三层结构设计，通常多是利用WebLogic中间件软件自带的服务器集群功能来满足高性能需求，其中一台WebLogic Server作为管理服务器负责任务调度，实现负载均衡效果。但是，当访问用户到达一定数目的时候，由于该服务器自身的硬件性能瓶颈，会造成整个系统的联机事务处理效率低下;而且由于WebLogic自身设计的原因，当任务量达到一定阀值的时候，即便是升级服务器硬件性能也无法提升其进行负载均衡调度的能力。
针对上述情况，最好的办法莫过于采用硬件负载均衡设备，以解决数据流量过大、任务负荷过重所产生的系统瓶颈问题。在这一方面，业内知名的硬件厂商有F5、深信服等等。值得一提的是，深信服的应用交付产品除具有传统负载均衡功能外，其独有的单边加速技术，能够在跨运营商网络环境中，通过广域网传输文件及应用的访问时间减少30%以上，极大提高了用户体验。
虽然部署硬件设备意味着一笔额外的开支，但是它给网站的整体业务系统所带来的性能提升，却是传统的软件方案所望其项背的。除此之外，专业的硬件设备所能提供的负载调度算法和健康检查机制也更加丰富、全面，有助于进一步提升关键业务发布的稳定性和持久性，这对于高并发量的大型网站而言是极具价值的。
当然，对于不同规模、不同业务的网站而言，没有一概而论的设计标准，文中提到的技术手段都有着相应的适用场景，这就需要网站的架构师们做具体的规划了。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/311/">«</a>
	<span class="pagination__item pagination__item--current">312/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/313/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>