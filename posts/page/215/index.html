<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3270abd493e8a62d493d2ae32a1c111/" rel="bookmark">
			IDEA修改背景颜色大全（护眼绿等）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.IDEA默认有3种背景颜色 路径为File-&gt;settings-&gt;Editor-&gt;Color Scheme可以设置软件默认颜色，旁边的小齿轮添加颜色名字
二.IDEA扩展颜色（护眼绿） 第一种方法： IDEA设置一张背景图片,路径：File-&gt;Settings-&gt;Appearance&amp;Behavior-&gt;Appearance
第二种方法： 手动设置护眼绿的RGB颜色
路径：File-&gt;Settings-&gt;Editor-&gt;Color Scheme-&gt;General
到这里代码编辑界面设置成了护眼绿色，但是你会发现，项目界面和调试界面并没有更改成功。
如果你比较懒得话，可以按照第一个方法设置一个背景图片就可以变色。
在这里说下另一个方法：
File -&gt;Settings -&gt; Appearance &amp; Behavior -&gt; File Colors ，选择+号 选择Project file
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d6e79225f046bef72f0c54b9431892b/" rel="bookmark">
			【SpringSecurity】使用注解方式实现匿名访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringSecurity实现匿名访问的方式如下，
/** * spring security配置 * {@link EnableGlobalMethodSecurity } 如果想要启用spring方法级安全时，使用这个注解 * * @author ruoyi */ @EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true) public class SecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity httpSecurity) throws Exception { httpSecurity .authorizeRequests() // 对于登录login 验证码captchaImage 允许匿名访问 .antMatchers("/login", "/captchaImage").anonymous(); } } 如果有很多个路径都需要匿名访问，那岂不是要在 antMatchers 加很多路径？这样太繁琐
使用注解方式实现匿名访问，步骤如下
先定义一个注解 /** * Security允许匿名访问 */ @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface AnonymousAccess { } 修改 security 配置类 /** * spring security配置 * {@link EnableGlobalMethodSecurity } 如果想要启用spring方法级安全时，使用这个注解 * * @author ruoyi */ @EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true) public class SecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity httpSecurity) throws Exception { httpSecurity .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d6e79225f046bef72f0c54b9431892b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df16e734af905d1e86550b21b2315f3c/" rel="bookmark">
			我的世界只支持java8_我的世界minecraft 1.8以上版本forge安装支持哪一种java？7还是8？...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		好的LZ，解答如下：(1)从1.7.10版本开始，包括1.8版本和之后的版本，目前暂时只支持jav...
解答如下：(1)从minecraft 1.7.10版本开始包括后面的版本，minecraft对配...
你好！根据你的情况，我们推断是使用了旋律启动器，你可以安装完forge后安装其他的启动器，例如Eas...
解答如下：(1)第一个可能性，您安装的java不是对应版本的java7，从1.7.X版本开始，m...
LZ，解答如下：1)旋律启动器无法生成正版文件，所以和forge安装无缘；2)forge的安装...
1、进入forge官方网站，这里附上链接http://files.minecraftforge.ne...
先彻底卸载java，再把那个forge的安装噐删了，下载java7,java8无法兼容minecra...
你好，打开forge【首先保证你的java版本为7】，然后点击【...】这个按钮，选取你的Minec...
解答如下：(1)您安装forge的时候，因为某种原因导致forge安装不全，比如常见的网络不顺畅导...
目前用编辑forge的Java版本是7。所以你需要下载Java7。这是网站：http://www...
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d480b52aa8797a08905bd18002b01f9/" rel="bookmark">
			java流意外结束_java – 异常：ZLIB输入流意外结束
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GZIPInputStream或GZIPOutputStream有问题.请阅读以下代码(或运行它,看看会发生什么)：
def main(a: Array[String]) {
val name = "test.dat"
new GZIPOutputStream(new FileOutputStream(name)).write(10)
println(new GZIPInputStream(new FileInputStream(name)).read())
}
它创建一个文件test.dat,由GZIP写入一个单字节10格式,并以相同的格式读取同一个文件中的字节.
这就是我运行它：
Exception in thread "main" java.io.EOFException: Unexpected end of ZLIB input stream
at java.util.zip.InflaterInputStream.fill(Unknown Source)
at java.util.zip.InflaterInputStream.read(Unknown Source)
at java.util.zip.GZIPInputStream.read(Unknown Source)
at java.util.zip.InflaterInputStream.read(Unknown Source)
at nbt.Test$.main(Test.scala:13)
at nbt.Test.main(Test.scala)
由于某种原因,阅读线似乎错了.
我google错误的ZLIB输入流的意外结束,并发现了一些关于2007年至2010年发布的Oracle的错误报告.所以我猜这个错误仍然在某种程度上,但是我不知道我的代码是否正确,所以让我在这里发贴,听你的意见.谢谢！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa2f67e0b9b1f576d6190d8f57d14743/" rel="bookmark">
			如何在Android Studio中，将一个工程复制，另存一个新工程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为一个小白，在我做好我的一个APP以后，我想把这个APP升级一下，加一些功能模块之类的，但是我又想保留一份原来的工程，因为害怕改残了，保存一下原始版本比较好，然后把原始项目另存为一个新项目，在新项目上就可以放心修改了。但是，Android Studio貌似并没有提供这样一个直接另存为一个新项目的功能，所以我网上看了一些大神的指点，学到了一个简单快捷的方法，如下：
第一步，复制工程并另存，将工程文件夹的名字修改一下，如下图。原始项目的文件夹名为"Rocket"，复制该文件夹并保存，将文件名改为"Rocket_sec"。
第二步，导入copy的工程。
第三步，修改包名。
第四步，Application ID。
修改Application ID，并点击ok。
第五步，等待完成，完成以后可能还是安装不成功，直接clean项目，再次安装即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad60521a197a8afb18ef30e469dc2abb/" rel="bookmark">
			微信小程序页面点击滚动到指定位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 tabFn(e) { var query = wx.createSelectorQuery() //创建节点查询器 query.selectViewport().scrollOffset(); //节点的竖直滚动位置 query.select(`#${e.currentTarget.dataset.appoint}`).boundingClientRect() //动态获取id query.exec(function (res) { //执行请求 wx.pageScrollTo({ scrollTop: res[0].scrollTop + res[1].top, //滚动到页面节点的上边界坐标 duration: 300 // 滚动动画的时长 }); }) } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb34424bbbbd8e00088765fb7b88752c/" rel="bookmark">
			java删除sftp文件夹_java实现sftp服务器文件上传、下载、删除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先是一个SftpClientUtil 类，封装了对sftp服务器文件上传、下载、删除的方法
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Properties;
import java.util.Vector;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import com.jcraft.jsch.Channel;
import com.jcraft.jsch.ChannelSftp;
import com.jcraft.jsch.ChannelSftp.LsEntry;
import com.jcraft.jsch.JSch;
import com.jcraft.jsch.Session;
public class SftpClientUtil {
/**
* 初始化日志引擎
*/
private final Logger logger = LoggerFactory.getLogger(SftpClientUtil.class);
/** Sftp */
ChannelSftp sftp = null;
/** 主机 */
private String host = "";
/** 端口 */
private int port = 0;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb34424bbbbd8e00088765fb7b88752c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a91296946cfb0913a9ef87606015ce4/" rel="bookmark">
			jdbcdaosupport.java_基于springframework的JdbcDaoSupport、JdbcTemplate实现JDBC数据库连接并实现常见增删改查的重写AbstractJdbc...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言
基于org.springframework.jdbc.core.support.JdbcDaoSupport(spring-jdbc-xx.jar),定义AbstractJdbcDao子类通过org.springframework.jdbc.core.JdbcTemplate的实现数据库jdbc获取连接，从而可以直接指向数据库sql语句来实现依赖sql功能的业务逻辑。
二、代码
1.AbstractJdbcDao类import java.sql.Array;@b@import java.sql.PreparedStatement;@b@import java.sql.SQLException;@b@import java.util.List;@b@import java.util.Map;@b@@b@import org.springframework.dao.DataAccessException;@b@import org.springframework.jdbc.core.BatchPreparedStatementSetter;@b@import org.springframework.jdbc.core.JdbcTemplate;@b@import org.springframework.jdbc.core.PreparedStatementCallback;@b@import org.springframework.jdbc.core.support.JdbcDaoSupport;@b@@b@import com.woopa.common.util.ClassUtils;@b@@b@/**@b@ * @Date 2011-2-10 下午01:57:09@b@ * @version 1.0@b@ */@b@@SuppressWarnings({"unchecked", "rawtypes"})@b@public abstract class AbstractJdbcDao extends JdbcDaoSupport {@b@@b@JdbcTemplate template;@b@@b@protected void initDao(){@b@template = super.getJdbcTemplate();@b@}@b@@b@public T getUnique(Class type, String sql, Object[] values) {@b@if(! ClassUtils.isMappingType(type)){@b@return super.getJdbcTemplate().queryForObject(sql, values, type);@b@}@b@return super.getJdbcTemplate().queryForObject(sql, values, RowMapperFactory.getRowMapper(type));@b@}@b@@b@public T get(Class type, String sql, Object[] values) {@b@return super.getJdbcTemplate().queryForObject(sql, values, RowMapperFactory.getRowMapper(type));@b@}@b@@b@public List list(Class entityClass, String sql, Object... values){@b@return super.getJdbcTemplate().query(sql, values, RowMapperFactory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a91296946cfb0913a9ef87606015ce4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35e19620d19285e01766dbcf06528ac7/" rel="bookmark">
			java中跳转页面的两种方法_页面跳转的几种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		页面跳转的几种方式：
--------------(网络收藏)
http头实现页面跳转：
out.println("");
content是指跳转的时间间隔，单位为秒
----------------------------------------------
forward方法实现跳转：
String url = "index.jsp";
%&gt;
-------------------------------------------------
response跳转：
response.sendRedirect(url);
或
response.encodeRedirectURL(response.encodeRedirectURL(url));
对要用的URL编码，如果cookie打开的话，sessionid通过cookie传递，这个方法原样返回；如果cookie没打开的话，这个方法会在你的url后面加上sessionid的参数，保证你的session传递。
---------------------------------------------------
区别：
forward执行后，地址栏链接不变
sendRedirect()执行后，地址栏链接会更换
由此可知forward的执行是在服务器完成的，重定向到其他文件取出内容输出到页面，并且可以附加参数传递
而sendRedirect，可以认为是客户端完成，相当于客户端又重新发了一个get请求，要服务器传输另一个文件过来。
能够向目标文件传送参数和值。如果使用了标签的话
，目标文件必须是一个动态的文件，能够处理参数。如果使用了非缓冲输出，那么使用
时就要小心；如果使用之前，JSP文件已经有了数据，那么
文件运行将会出错。标签从一个JSP文件向另一个文件传递一个包含用户
请求的request对象，标签以下的代码将不能运行。
posted on 2007-11-04 11:50 Bill111 阅读(853) 评论(0) 编辑 收藏
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff1d1e2098f12ad82420d755495259f1/" rel="bookmark">
			java多线程adb安装apk卡死_多线程方式安装apk
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# -*- coding:utf-8 -*-
# 1.获取连接设备的机器ip
# 2.获取需要安装的apk
# 3.对每一台机器安装apk
# 4.检查apk安装是否成功
# 5.安装完成
import os,subprocess
import _thread
#获取设备ip地址，并连接
result=0
def connectDevice(dress):
'''检查设别是否连接成功，如果成功返回True，否则返回False'''
ip_dress=deviceName(dress)
for ipdressline in ip_dress:
cmd="adb connect"+" "+str(ipdressline)
print(cmd)
device_con=subprocess.getoutput(cmd)
print(device_con)
Devicecmd='adb devices'
device_str=subprocess.getoutput(Devicecmd)
device_list=[]
m=(device_str.strip('\n').strip(' ')).split('\n')
for line in m:
if 'List' not in line:
device_list.append(line.split('\t')[0])
print(device_list)
else:
print("无设备连接")
return device_list
#读取apk
def readapk(apk_path):
apkpackage=os.listdir(apk_path)
apk_list=[]
for list in apkpackage:
if '.apk' in list:
apk_list.append(list)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff1d1e2098f12ad82420d755495259f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f08eff97cdc3a52eab521b1721b1ca3d/" rel="bookmark">
			学单片机怎么入门？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时间很快，不知不觉从事单片机开发近10年了，对于单片机怎么学这个话题，感慨万千。
单片机在外行人看来门槛很高，既要懂硬件，又要会编程，大多数人还没开始已经吓尿了！
其实，单片机并大家没想的这么难，关键就是方向正确+努力。
下面来讲讲我的自学经历。
曾经我和大多数即将步入社会的学生一样，不知道自己以后该做什么，对未来充满无助和迷茫。
更糟的是，我文凭也不高，连本科都不是，但是抱怨没有用，第一步首先要解决就业的问题。
我的性格是比较内向的那种，所以我选择了编程，最重要的还是那工资看着真香。
但是编程分为很多种，C、C++、java、PHP等等等，选择太多让我无从下手。
一次机缘巧合的机会，让我了解到了单片机，这玩意有意思，因为能通过写程序去控制硬件去完成一些有趣的操作，比如说最经典的点灯，智障小车等等。
或许我是比较喜欢这种”即时反馈”，可以一边学一边做出好玩的东西出来。
然后我就一头扎进学习单片机的道路，越研究发现越艰难，什么电子元器件、数字电路、模拟电路、数学、英语、单片机、C语言、Protel99、原理图一堆东西要学。
现在想想，如果当初我能看到这样一篇指引方向的文章，那该有多么幸运。
Ok，干货正式开始，我将通过以下3点来讲述单片机要怎么学，才不会从入门到放弃。
1.单片机要学什么？
2.入门最佳学习路线
一、单片机要学什么？ 我们不管学什么，最重要的目的都是奔着赚钱的，这点应该没人反驳吧？
对于单片机来说，前期变现唯一的方式就是去找工作。
有这个思维以后，接下来就好办了，我们直接看企业需求。
我们直接打开招聘平台，然后搜”单片机工程师”、或者”嵌入式工程师”职位。
多看几个职位你就会发现大家的要求都是大同小异，我们只要抓住这些职位的共同要求，这个要求通常就是这个职位的刚需，而这些就是我们要学的。
什么？你还是总结不出来？
没关系，我早想到了！继续往下看！
二、入门最佳学习路线 入门学习路线大纲：电子元器件-电路基础-C语言-单片机-AD软件使用
1.电子元器件
单片机主要是用来控制硬件的，所以基本的电路必须要懂，而电路是由各种电子元器件组成的。
元器件成千上万种，没必要全部学，前期只需要学会电阻、电容、继电器、LED灯、二极管、三极管、MOS管、电感、按键、晶振这些元器件的作用就可以了。
2.电路基础
关于电路的知识就多了，电路还分模拟电路和数字电路，我入门的时候在这里踩了一个大坑(死磕了一段时间模拟电路)，导致我一度想放弃单片机。
其实完全没必要单独去学模拟电路和数字电路，对于单片机开发来说模拟电路用的还是比较少的，即便有也有专门硬件工程师帮你设计成能直接接单片机的信号了。
电路基础只要掌握欧姆定律、三极管开关原理、二极管导通原理、按键检测原理、蜂鸣器驱动、单片机的外围电路就可以了，简单来说学到能看的懂51单片机开发板的电路图就行了。
3.C语言
我在入门的时候C语言和单片机是同步学的，否则单纯去学枯燥无味的代码兴趣很容易被磨灭，学技术最大的动力就是兴趣。
C语言学完结构体和指针那章就可以了，如果指针实在学不懂那也没关系，先了解，当你有一定代码量的沉淀后，再回过头去看就很容易搞懂了。
3.单片机
目前市面上主流的单片机就是51和STM32，所以这两个单片机是必学的，先学51后学STM32。
51的话全部外设都要学完，而STM32因为比较复杂一点，所以只需要学习常用的外设(GPIO、Timer、中断、USART、IIC、SPI、PWM、DMA、ADC)就可以了，其他像什么CAN、USB的一律不管，工作需要用到的时候再去学。
4.AD软件使用
AD是一个画原理图和PCB的软件，作为单片机软件开发来说只需要会看或者画原理图即可。
以上学习路线所有资料在网上都能搜集到，我这边也整理了一份，要的可以直接找我拿。
三、总结 正确的方向比盲目地努力重要，特别是学技术这种无底洞。
最后聊下很多小伙伴最近问我的一个问题，他说他没有学历，英语数学也不好，专业也不对口能不能学得会单片机和编程，学出来会有人要吗。
其实完全没必要有这个顾虑，记得在17年的时候在公司里带了一个之前在工厂做电路板维修的学徒，他也才初中毕业，后面跟他聊的来，就带着他学了半年多，后面他跳槽到一家公司做研发，拿13K一个月，原来做维修才6K多。
所以，学历和数学、英语最多是决定了你的天花板，而不是限制你进入这个行业的门槛。
玩到后期，想通过这个行业赚到大钱，拼的绝对不是技术，而是你的思维认知，你的人脉，你的资源。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3b18cda138111530a684de11dc08877/" rel="bookmark">
			undefined reference to `ceres::Problem::Problem()‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正常安装ceres之后，如下报错，搞了几天，心累，还以为是gcc/g++版本问题还是少安了什么依赖项，最后发现是链接库写错了
不是CERES_LIBS ，而是CERES_LIBRARIES。
CMakeFiles/cerescurvefitting.dir/ceresCurveFitting.cpp.o: In function `std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;* google::MakeCheckOpString&lt;int, int&gt;(int const&amp;, int const&amp;, char const*)': ceresCurveFitting.cpp:(.text._ZN6google17MakeCheckOpStringIiiEEPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKT_RKT0_PKc[_ZN6google17MakeCheckOpStringIiiEEPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKT_RKT0_PKc]+0x28): undefined reference to `google::base::CheckOpMessageBuilder::CheckOpMessageBuilder(char const*)' ceresCurveFitting.cpp:(.text._ZN6google17MakeCheckOpStringIiiEEPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKT_RKT0_PKc[_ZN6google17MakeCheckOpStringIiiEEPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKT_RKT0_PKc]+0x3d): undefined reference to `google::base::CheckOpMessageBuilder::ForVar2()' ceresCurveFitting.cpp:(.text._ZN6google17MakeCheckOpStringIiiEEPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKT_RKT0_PKc[_ZN6google17MakeCheckOpStringIiiEEPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKT_RKT0_PKc]+0x50): undefined reference to `google::base::CheckOpMessageBuilder::NewString[abi:cxx11]()' ceresCurveFitting.cpp:(.text._ZN6google17MakeCheckOpStringIiiEEPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKT_RKT0_PKc[_ZN6google17MakeCheckOpStringIiiEEPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKT_RKT0_PKc]+0x5b): undefined reference to `google::base::CheckOpMessageBuilder::~CheckOpMessageBuilder()' ceresCurveFitting.cpp:(.text._ZN6google17MakeCheckOpStringIiiEEPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKT_RKT0_PKc[_ZN6google17MakeCheckOpStringIiiEEPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKT_RKT0_PKc]+0x87): undefined reference to `google::base::CheckOpMessageBuilder::~CheckOpMessageBuilder()' CMakeFiles/cerescurvefitting.dir/ceresCurveFitting.cpp.o: In function `main': ceresCurveFitting.cpp:(.text.startup+0x247): undefined reference to `ceres::Problem::Problem()' ceresCurveFitting.cpp:(.text.startup+0x32d): undefined reference to `ceres::Problem::AddResidualBlock(ceres::CostFunction*, ceres::LossFunction*, double* const*, int)' ceresCurveFitting.cpp:(.text.startup+0x915): undefined reference to `ceres::Solve(ceres::Solver::Options const&amp;, ceres::Problem*, ceres::Solver::Summary*)' ceresCurveFitting.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3b18cda138111530a684de11dc08877/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6892558d7e286353c22247104ab8aa9/" rel="bookmark">
			Hystrix熔断器使用时的三个参数介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hystrix熔断器使用时的三个参数介绍 circuitBreaker.sleepWindowInMilliseconds
断路器的快照时间窗，也叫做窗口期。可以理解为一个触发断路器的周期时间值，默认为5秒（5000）。
这个参数大家应该不陌生，但是网上对他的解释有两种，一种是说在这个时间内如果发生断路的请求数超过了设置数则会熔断；另一种是说如果发生了熔断，那么在这个时间后会成为半开状态
其实以上两种都对，因为这两个时间都是一个窗口期
circuitBreaker.requestVolumeThreshold
断路器的窗口期内触发断路的请求阈值，默认为20。
当一个窗口期超过了20之后，则去看下面那个参数能够容忍的百分比阈值是否超过，若超过则熔断。假如某个窗口期内的请求总数都不到该配置值，那么断路器连发生的资格都没有。断路器在该窗口期内将不会被打开。
circuitBreaker.errorThresholdPercentage
断路器的窗口期内能够容忍的错误百分比阈值，默认为50（也就是说默认容忍50%的错误率）。
假如一个窗口期内，发生了100次服务请求，其中50次出现了错误。在这样的情况下，断路器将会被打开。在下个窗口期结束之前，即使是之前可以正确访问得，也将被执行fallback逻辑。
最后他的默认设置的意思是： 在一个窗口期内（关闭状态），若请求数超过20，并且错误的数量超过50%，那么就会触发熔断。在接下来的一个窗口期内任何请求都会降级（开启状态），直到下一个请求过去进入半开状态，进入半开状态后继续从新判定。
更多参数配置请见: https://github.com/Netflix/Hystrix/wiki/Configuration
本文章如有写的不好的地方，请联系修改
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64206a5af127b3f1bf30a6f23a22f41e/" rel="bookmark">
			spss不存在java虚拟机_SPSS22显示“Could not create the Java virtual machine.”的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		展开全部
应该是没有安装java运行环境，(Java Development Kit) 简称JDK，可以上网32313133353236313431303231363533e78988e69d8331333365643662查找最新版本，下载安装即可。
-vmargs是表示下面是设置JVM(java虚拟机)的参数，也就是说下面都是java虚拟机的参数，对于JVM来说，内存分为堆内存和非堆内存，注意这里的堆不是c/c++里面的堆的概念，因为jvm自己管理内存，所谓堆上的内存就是jvm可以分配给java应用程序使用的内存。
由-Xms和-Xmx这两个参数限定，而非堆内存则是JVM自己使用的，由-XX:PermSize和-XX:MaxPermSize这两个参数来限定。对于堆内存来讲，JVM根据剩余的堆内存的多少调整整个堆内存的大小，调整范围就是-Xms(最小)和-Xmx(最大)指定的范围，-XX:PermSize和-XX:MaxPermSize也是同样的道理，如果你不想JVM来动态调整的话，可以把最大和最小值设置相等，默认最小值是物理内存的1/64，最大值是物理内存的1/4，所以这个最大值就受到物理内存的限制(当然还会收到操作系统的限制)。
经过实验发现，如果-Xms的值比-Xmx设置的大则启动会失败；而如果-Xmx和-XX:MaxPermSize设置的值的和比可用的物理内存还大，启动也会失败，我的第一个设置，两者的和超过了1G，而当时可用内存才700M，所以启动会失败，JVM在启动时会检测参数和实际可用内存。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08ca0856559d4c06dec7ac62819400b3/" rel="bookmark">
			java 动态计算_Java动态执行计算表达式利器 -- ScriptEngine
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在通过配置文件对系统进行参数配置时，有时需要更好的理解参数值的具体意义，往往采用计算表达式的方式设置，例如1天换成秒数为86400，如果写成24 * 60 * 60就很清晰的表达是一天的秒数。但是这个表达式通过properties的方式获取为字符串，这里就需要动态计算这个表达式。
ScriptEngine这个对象专门用来处理动态执行表达式，主要调用其eval方法动态执行(类似于javascript中的eval方法)，其返回结果为object对象；针对计算表达式的返回结果是double类型，所以这里先将object转换为double，然后根据实际需要进行强制转换。
配置文件如下：
#标准缓存时长(单位：秒)
#默认为1天(24 * 60 * 60)，也可以为86400
std_cache_time_out=24 * 60 * 60
其用法如下：
ScriptEngineManager _mgr = new ScriptEngineManager();
//这里只调用javascript执行器，可以执行javascript脚本，除此之外还可以调用其他类型的脚本
ScriptEngine _enginer = _mgr.getEngineByName("javascript");
try{
String expression = properties.getProperty("std_cache_time_out");
Object result = _enginer.eval(expression);
_MAX_CACHE_TIME_OUT = (long)Double.parseDouble(result.toString());
}
}catch(ScriptException e){
e.printStackTrace();
}
以ScriptEngine这个接口提供的方法请参阅ScriptEngine使用API
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6360f76b25f42d2a3b4c277772e7c4f8/" rel="bookmark">
			普罗米修斯(Prometheus)与SNMP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近又在研究普罗米修斯，一种开源的监控系统。打算与SNMP结合使用
关于普罗米修斯的介绍，网上有很多
https://www.cnblogs.com/cuiyubo/p/10981840.html
由于操作系统本身并不直接支持Prometheus，同时用户也无法通过直接从操作系统层面上提供对Prometheus的支持。因此，用户只能通过独立运行一个程序的方式，通过操作系统提供的相关接口，将系统的运行状态数据转换为可供Prometheus读取的监控数据。 除了Node Exporter以外，比如MySQL Exporter、Redis Exporter等都是通过这种方式实现的。 这些Exporter程序扮演了一个中间代理人的角色。
SNMP与普罗米修斯 两者之间的通信格式和协议都不相同，故不能直接通信，但是我们可以使用snmp_exporter。
snmp-exporter是prometheus官方开源的一款网络设备监控工具，从SNMP收集的信息，供Prometheus监控系统使用。它有两个部分。一个执行实际抓取的snmp-exporter和一个generator（它依赖于NetSNMP）创建供导出器使用的配置。
相关信息
1.prometheus： 监控系统，负责指标的收取和一些告警规则的定义
2.snmp-exporter: 用于通过snmp协议暴露交换机的相关指标
3.SNMP Exporter Config Generator： 此配置生成器使用NetSNMP解析MIB，并使用它们为snmp_exporter生成配置–帮助生成snmp的配置文件
4.MIB和OID： MIB是管理信息库的缩写，它是用于管理通信网络中的实体的数据库。数据库是分层的（树形结构），并且每个条目都通过对象标识符（OID）进行寻址
5.snmp协议： SNMP 是专门设计用于在 IP 网络管理网络节点（服务器、工作站、路由器、交换机及HUBS等）的一种标准协议
普罗米修斯安装步骤
安装包下载
1.安装包github下载
https://prometheus.io/download/
2 安装
1.部署到/usr/local/目录 tar -zxvf prometheus-2.23.0.linux-amd64.tar.gz -C /usr/local/
2.修改文件夹名称 mv prometheus-2.23.0.linux-amd64 prometheus
3.验证，查看版本号 cd prometheus/ ./prometheus --version 3 启动
使用Prometheus默认配置启动
/usr/local/prometheus/prometheus --config.file=/usr/local/prometheus/prometheus.yml &amp;
验证，打开浏览器访问9090端口
http://10.10.10.101:9090
关闭防火墙
/sbin/iptables -P INPUT ACCEPT
然后执行
/sbin/iptables -F
如果网页上提示
Warning: Error fetching server time: Detected 28799.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6360f76b25f42d2a3b4c277772e7c4f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0eb36b2b2a9abc3891815326f633cfa/" rel="bookmark">
			Idea 设置类、方法注释模板(解决params和return显示问题)---不来虚的 实测有效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、使用场景
2、操作步骤
2.1、新建类模板注释添加
2.2、给类的方法生成方法注释
3、成果展现
4、参考文章
1、使用场景 我们在开发项目的时候需要知道类的创建者，什么时间创建，这个类是什么主要作用等描述信息；以及创建方法的时候能够支持自定义的模板(方法的描述信息、创建方法的开发人员、创建日期和时间、参数名称、返回类型等)
2、操作步骤 2.1、新建类模板注释添加 操作菜单顺序：File--&gt;Settings--&gt;Editor--&gt;File and Code Templates--&gt;Includes 修改File Header里面的模板内容如下模板代码：
/** * @Description TODO * @Classname ${NAME} * @Date ${DATE} ${TIME} * @Created by ${USER} */ 在完成上面操作后如下图所示：
2.2、给类的方法生成方法注释 网络上关于给类方法生成注释一大堆文章；但是90%的文章都是copy的没有实操。估计很多人都遇见过params和return参数无法返回，或者返回效果不佳的情况。
操作步骤：File--&gt;Settings--&gt;Editor--&gt; Live Templates
新建自己的分组和自己的模板，这都不说了，界面如图
其中第1步选择创建自定义组，第2步选择创建模板
点击右边的”+“号,选择Template Group
第2步创建Live template
内容源码及说明：
Abbreviation那里不要用 / 开头的！！！ 模板中开头不要 / ，从* 号开始 模板如下：
** * description: * @since: 1.0.0 * @author: 作者拼音或者英文名称 * @date: $date$ $time$ $params$ $returns$ */ 其中第一行必须为**(两个星号) 其中参数 $params$ $returns$ 前面无需@符号
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0eb36b2b2a9abc3891815326f633cfa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/554dce7df0c7cf5609e2f0ea3b690ec8/" rel="bookmark">
			数据结构——分块扩展\莫队算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分块扩展\莫队算法 普通莫队分析P2709 小B的询问传送门题目分析Code 251. 小Z的袜子传送门题目分析Code 莫队算法（mo’s algorithm）一般分为两类，一是莫队维护区间答案，二是维护区间内的数据结构。当然也有树上莫队，带修改莫队、二维莫队等等。 可参考：莫队算法初探：https://www.luogu.com.cn/blog/codesonic/Mosalgorithm
普通莫队 分析 相信大家已经学过了分块这一数据结构（没学过），其中251.小Z的袜子一题会使用分块算法的一种重要形式——对“询问”进行分块。这是一种用于处理一类不带修改的区间查询问题的离线做法，又被称为“莫队算法”，其核心在于利用曼哈顿距离最小生成树算法对区间处理顺序进行处理。
如果可以通过区间 [ l , r ] [l,r] [l,r]快速转移到 [ l − 1 , r ] [ l + 1 , r ] [ l , r − 1 ] [ l , r + 1 ] [l-1,r][l+1,r][l,r-1][l,r+1] [l−1,r][l+1,r][l,r−1][l,r+1]，那么可以用 O ( x × ∣ l 1 − l 2 ∣ + ∣ r 1 − r 2 ∣ ) O(x\times |l1-l2|+|r1-r2|) O(x×∣l1−l2∣+∣r1−r2∣)的时间完成转移， [ l 2 , r 2 ] [l2,r2] [l2,r2]是 [ l 1 , r 1 ] [l1,r1] [l1,r1]的后一次询问， x x x是 [ l , r ] [l,r] [l,r]转到相邻区间的复杂度
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/554dce7df0c7cf5609e2f0ea3b690ec8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc222bd214a966e0a73caf1743c35c7f/" rel="bookmark">
			STM32G0系列的启动配置与程序下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 目的启动配置程序下载通过程序修改 nBOOT_SEL总结 目的 STM32G是意法半导体这两年新推出的系列芯片，相比原先的F系列的芯片有很多提升点，将来必将取代F系列芯片的地位。对于新芯片的应用来说能够正确下载与运行程序是比较重要的一点，这篇文章将对 STM32G0 系列芯片的启动配置与程序下载做个简单的说明。
启动配置 STM32G0系列芯片的启动配置相关内容在官方文档《AN5096：Getting started with STM32G0 Series hardware development》第三章中有详细的描述：
启动配置相关内容其实是不多的，下面将对这部分内容做个简单的说明。
STM32系列芯片程序启动方式分为下面三种：
Main Flash memory 从主闪存启动，想要运行我们自己的程序就要选择这种方式；System memory 从系统存储区启动，想要通过串口下载程序就要选择这种方式；Embbeded SRAM 从内存启动； STM32G0系列芯片通过选项字节（option byte）中的 BOOT_LOCK、nBOOT1、nBOOT_SEL、nBOOT0这几位加上外部的 BOOT0 管脚的电平来确定启动方式。当 nBOOT_SEL 为 0 时， BOOT0 的值来源于外部的 BOOT0 管脚的电平，低电平为 0 ，高电平为 1 ；当 nBOOT_SEL 为 1 时， BOOT0 的值来源于 nBOOT0 的值。
芯片启动时会检查闪存地址0x080000000（即用户程序起始地址）处的数据，如果该数据为0xFFFFFFFF则表示用户程序为空，此时不管上面的那些设置程序会从 System memory 启动。
芯片在出厂后只要没有经过程序下载等操作启动时总是会从 System memory 启动。
程序下载 STM32系列系统程序下载通常通过串口进行，而使用串口下载程序重要的是要让芯片从 System memory 启动。
从上一章节内容可以知道芯片在初次烧写时就是从 System memory 启动的，你可以正常使用串口进行连接烧写，不需要关心外部 BOOT0 管脚的电平，如果连接不上就拉低下芯片 NRST 引脚复位下芯片试试。（如果还是连接不上就检查下芯片供电、线路连接、串口模块、串口驱动等试试。）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc222bd214a966e0a73caf1743c35c7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8423cbcb405abe0c7b8bcf90a3b97db7/" rel="bookmark">
			VS编译OpenCV3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
流程
源码
环境
编译完成库
流程文档转载（防丢）
1.下载Cmake
2.下载OpenCV源码
3.编译OpenCV
4.最后一步-VS编译openCV
4.1编译Debug版的openCV
4.2编译Release版的openCV
4.3生成结果
5.牛刀小试
流程 Windows下 Cmake + VS 编译 OpenCV (+ opencv_contribute)源码
源码 版本：3.4.13
链接：https://sourceforge.net/projects/opencvlibrary/files/3.4.13/opencv-3.4.13-vc14_vc15.exe/download
环境 Visual Studio 2017，CMake 3.19
编译完成库 链接：https://pan.baidu.com/s/1ETvzYVtv0zGMEH7I7NXXNA 提取码：4m3k 流程文档转载（防丢） windows下Cmake+VS编译OpenCV源码
这里我使用的是VS2015 update3，默认大家电脑里都有VS了。
1.下载Cmake 点击Cmake官网的下载界面，点击下载对应版本的Cmake就可以了。
下载完压缩包直接解压，无需安装。
点击开文件夹可以看见：
最后一步就是把Cmake路径下的bin文件夹路径加入到电脑的环境变量。
2.下载OpenCV源码 OpenCV在图像领域所占的地位就不用多提了，很强的工具，不过涉及到配置的问题，对于初学者来说还是会有一些问题的。
首先进入OpenCV的官网的下载界面，这里主要以OpenCV3的3.1版本为例，其他的版本一样的操作流程。
正常Windows下直接下载Win pack，下载exe文件，然后直接双击解压就可以了。
不过有些时候我们在用C++调用OpenCV时会碰到某些库文件没有的情况，所以一般还是自己下载源码，根据自己的需求生成依赖库会好一些。这里我们就选择 Sources 选项，下载就行了。
解压到相应路径后，可以看见下面的文件内容：
3.编译OpenCV 上面第一步将Cmake的bin文件夹加入到环境变量生效以后，直接在cmd里面输入cmake-gui然后回车就可以直接打开cmake了。（这里我使用的是Cmder，界面会比windows自带的cmd界面友好一些，而且可以加入右键菜单直接打开，类似于Ubuntu的Terminal,很方便，推荐大家使用，具体安装方法参见我的另一篇博客-Cmder 加入右键菜单）：
如上图步骤：
1）首先选择source code的路径,就是上面的opencv-3.1.0/opencv-3.1.0
2）手动在opencv-3.1.0里面建一个名字为 build 的文件夹，把 build 文件夹的路径加到这步
3）点击 Configue
4）就会弹出一个选择编译器的界面，选择自己对应的VS版本就行了。
5）点击Finish
文件就开始编译了，第一次编译的话会下载一些依赖的东西，所以需要多等一会。会有如下生成：
Selecting Windows SDK version to target Windows 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8423cbcb405abe0c7b8bcf90a3b97db7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db07367661ddce5e8182010823007738/" rel="bookmark">
			节后三思，产品经理有没有未来？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		产品经理的未来在哪？肯定不是开滴滴。
产品经理的未来要看互联网的未来。2001到2010年的互联网是PC纪元，2011到2020年的互联网是移动纪元，那2021到2030年呢？
一路发展走来，产品经理的话题从圆桌到破圈，产品经理的群体从稀缺到壮大，产品经理的工作从改变世界到AB test，那下一步呢？
我们不知不觉又走到了纪元的节点，在新的纪元里我们产品经理会经历怎样的故事？这未书写的故事，就是未来。
所以，除了开滴滴，产品经理的未来在哪？或者说，产品经理拥有怎样的未来？在节后开工利是的时间点，我想了想这个问题。
01
产品经理有没有未来？
知乎说，先看是不是再问为什么。
我从四个方面看了看，产品经理必须拥有未来。
1 从产品经理的职责看未来
职责是立身之本，我们先看产品经理的职责。
产品经理的定义是什么？解决问题的人。解决用户问题的人，解决业务问题的人，解决商业问题的人。有问题，就需要有人解决问题。
这样的人，在皇宫里叫丞相，在王府里叫管家，在PC纪元叫项目经理，在移动纪元叫产品经理。头衔可能变化，但解决问题的人恒定存在。
产品经理恰恰是这样一群人：定位关键问题、输出解决方案、跟进落地并反馈结果。他们串联公司的各个部门，活跃在公司的一线。
社会需要产品经理。微信是产品，一个咖啡杯也是产品，都在解决用户问题。需求是问题的表述，产品是需求的具象。
产品经理带来美好的设计。可以说，产品经理让世界更美好。美好的另一面，就是产品经理的未来。
2 从产品经理职责的变化看未来
第二看，我们站在变化的角度看未来。
产品经理解决问题的职责不变，但产品工作需要的技能点在变化。在职责不变的大背景下，技能点至少发生了四个变化。
一是功能型产品经理到优化型产品经理的转变。从做功能堆上线到针对功能的精细化。之前的我们关注功能是否上线，现在的我们知道上线仅仅是个开始，紧跟着就是数据、策略的优化。
二是体验型产品经理到业务型产品经理的转变。从关注按钮放左边还是右边，到配合业务、甚至改造业务的深入一线。用户体验很重要，但业绩目标更重要，产品经理无法取悦所有人，那就针对部分人。
三是工具型产品经理到商业化产品经理的转变。工具时代一去不复返，互联网的基建已经完成，很少有新的产品问世。产品经理的职责重点变为针对存量的商业转化，提升用户的LTV，妙笔生花。
四是面向存量型产品经理到面向增长型产品经理的转变。这个变化最猛烈和急迫，现在市面上最缺的产品经理必有增长产品经理。在哪里找到便宜的流量来新增用户呢？这个问题可能只有下一任产品经理在面试的时候知道。
从这四个变化来看，前者没有没来，后面拥有现在。囿于原地的产品经理没有未来，不断进化的产品经理拥有未来。
换句话说，部分产品经理拥有未来。
3 站在现在看未来
第三看，是站在现在看远方的未来。
我们能看的是发展趋势，趋势代表着未来。所以，这个趋势是什么？
是5G吗？是AI吗？是AR/VR吗？不是。技术本身不代表未来，技术的应用才是未来。但应用场景大家都在苦苦寻找。
是增长、是策略、是B端吗？不是。这是职责现状，现状不代表着未来。但大家也不要怕，因为没有现状肯定没有未来。
关键的不是大家怎么看，而是产品经理自己怎么看。如果自身的职业发展也是产品的话，那么基于自身的个性化发展才是未来。
个性化包含了产品经理自身对未来的判断，然后结合自身的现状、兴趣、特长而定制的专属路径。这是能掌控和达到的未来，达到才等于拥有。
所以，那部分看见自己未来的产品经理，拥有着未来。
4 站在未来看现在
最后，我们得站在未来看现在。
终局思维，目标导向。我们现在做的一切事，都服务于最终目标。未来必须影响现在，现在的做法是为了达到未来。不能随波逐流，任其发展。
10年后的产品经理由5年后的产品经理发展而来，5年后的产品经理由3年后的产品经理发展而来，3年后的产品经理由现在的产品经理发展而来。
站在未来的角度看现在，未来确定，产品经理现在的前进方向也必须确定。没有未来，就没有现在。
现在的茫然，对应的就是茫茫然的未来。现在的明确，对应的就是拥有的未来。这不是祖父悖论，这是因果报应。
结论就是，明确当下的产品经理，拥有着未来。
02
产品经理如何把握未来？
怎么才能成为那部分拥有未来的产品经理呢？
抛开学习成长、反思总结的老生常谈，还有三个深坑陷阱需要我们注意。
1 不要做螺丝钉，反脆弱
产品的成长过程肯定要经历这样的阶段，从入门到熟悉，从力不从心到得心应手，从疲于应付到游刃有余。
如果我们一直待在得心应手的能力范围和游刃有余工作环境，那么就会成为一个螺丝钉。做的好是一个兢兢业业的螺丝钉，做的不好就是职场老油条。
这两点都不符合产品经理的自身发展。自身发展当是能力的不断进阶，是一个又一个阶段的跨越。
囿于现状的产品经理无法应对职场和环境的变化。现在有用的技能，未来未必可行。我们需要不断提升自己的反脆弱能力。
一专多长，警惕黑天鹅，产品经理才能在变化中把握主动，才不会有35岁困境。这才叫游刃有余。
2 不要被光迷惑，再出发
产品成长的路上充满奖励，就像超级马里奥一样吃着蘑菇不断长大。
但当被喧嚣和热闹包围的时候，产品经理反而应该更加清醒。我们总得敏锐的预感到狂欢背后的危机。
绝望之谷到开悟之坡的过程，不应该为片刻的奖励而暂停，反而应该在拿到奖励之后再次出发。
要能认识到自己的不足，认识到现在的开悟之坡其实就是下一个阶段的绝望之谷。藏起现有的奖杯和荣誉，出发一程又一程。
产品本身也是一个不设限的过程。一个关卡的通过，就要走向下一个边界。玩拓展边界的无线游戏，其乐无穷。
第二点与第一点的区别是，第一点是说不要平庸，第二点是要意识到优秀本身也是平庸。
3 不要顺其自然，有执念
所以，产品经理要在职场的道路上不断打怪升级吗？对，也不对。
产品肯定要不断的打怪升级，来获得第一点的提升和第二点的荣誉。但重要的仍是第三点，我们对自身发展规划的路径。
战略错了，战术再好也是错。这一点在产品经理的职业生涯中至关重要。不能顺其自然，要有版本规划。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db07367661ddce5e8182010823007738/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/088918fe641cb5d570611bc3722bd2c4/" rel="bookmark">
			网络教育的课后作业期末考核,原来可以这么做!
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学历提升#现在工作中,一个人的学历资产对他影响越来越大,例如在公司有职位晋升的机会,会有严格的学历要求,职称评级也大多数对学历有着硬性的要求,尤其是在大型,有规模的正规公司中,学历的作用更为凸显.
由于上班族学习空间时间有限,很多人选择了网络教育,实现学历提升,在网络教育平台上学习的课后会有很多种类型的作业,如在线作业,离线作业,期末考核等等,这些都需要学习者花费不少的时间,这样就会特别繁忙,家里的事在多一些,那就是焦头烂额,烦躁不安,影响家庭生活的和谐.
既然是网络教育,那学习必然要多借助于互联网,在互联网上搜索到了网络教育作业辅导,期末考核辅导的服务,通过实际沟通,确实可以为#网络教育作业#和期末考核带来很大的助力,既可以学习,完成作业任务,又可以节省宝贵的业余时间,来陪伴家人,真可谓是一举两得.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b28e455225d36ae520ac699412bac018/" rel="bookmark">
			黑马java 57期_黑马JavaEE 57期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		资源内容：
黑马JavaEE 57期|____27 软件测试 |____软件测试相搭配的测试工具.rar |____软件测试教程讲义.rar |____9.QC管理学习(类禅道)学习.rar |____8.性能测试LoadRunner.rar |____7.接口视频Jmeter.rar |____6.移动端项目测试视频appium.rar |____5.web自动化测试视频selenium.rar |____4.编程数据结构python6学习教程.rar |____3.深入了解软件测试基础视频.rar |____2.Linux和数据库SQL.rar |____1.软件测试前置基础知识.rar|____26 互联网全终端项目-好客租房项目 |____资料.rar |____4-4 服务的具体实现以及MybatisPlus入门.rar |____4-3 项目介绍以及开发后台系统.rar |____4-2 Ant Design以及Ant Design Pro入门.rar |____4-1 ES6新特性以及ReactJS入门.rar|____25 传统行业解决方案SaaS-IHrm项目 |____视频.rar |____3-9 图片上传及Jasper.rar |____3-8 员工管理及POI.rar |____3-7 Shiro高级 及SaaS-HRM的认证授权.rar |____3-6 JWT的权限控制与Shiro入门.rar |____3-5 权限分配与jwt概述.rar |____3-4 SaaS-HRM系统用户权限设计概述.rar |____3-3 SAAS-HRM数据库设计与前端框架.rar |____3-2 SAAS-HRM系统概述与搭建环境.rar |____3-1 Activiti7工作流引擎.rar|____24 项目框架架构与优化 |____06-NIO与Netty编程.rar |____05-Netty网络编程.rar |____04-ORM思想及相关框架实现原理.rar |____03-MVC.rar |____02-数据库优化.rar |____01-JVM优化.rar|____23 微服务社交平台【十次方】 |____17 项目完结.rar |____16 dockfile.rar |____15 SpringCloud之一统天下.rar |____14 SpringCloud之初入江湖.rar |____13 密码加密与微服务鉴权JWT.rar |____12 rabbitmq架构.rar |____11 消息中间件RabbitMQ与搜索微 服务.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b28e455225d36ae520ac699412bac018/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d4339c997be4deccac7f74b1d037dad/" rel="bookmark">
			java&#43;1.6.0下载_JDK1.6.0下载安装与环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习Java开发的第一步是构建开发环境，以JDK6.0为例讲述。
第一步：从sun网站下载JDK1.6.0-17。
第二步：安装JDK。将其安装到D:\Programe Files\Java文件夹下即可。
第三步：配置环境变量。
(1)右键我的电脑——属性——高级——环境变量。
(2)为了指定命令搜索路径，在用户变量的path变量(只需在其最前面)添加下述路径即可D:\Program Files\Java\jdk1.6.0_17\bin;。注意末尾用分号隔开。
(3)为了指定类搜索路径，在用户变量中新建JAVA_HOME变量，变量名JAVA_HOME，变量值为D:\Program Files\Java\jdk1.6.0_17。
(4)为了指向JDK的安装目录，在用户变量中新建classpath变量，变量名为classpath，变量值为.;%JAVA_HOME%lib\tools.jar;%JAVA_HOME%lib\dt.jar;，注意最前面的.不可以省略。
第四步：测试JDK是否配置成功。
单击开始菜单——运行——输入cmd——确定，输入java -version(java和-之间有一个空格)显示出版本的信息，则证明配置成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef761841187510822e4d35b82d6193a0/" rel="bookmark">
			Java jdbctemplate赋值_给dao层注入jdbcTemplate时的一个强行bug(jdbcDaoSupport不要随便用!用了要记得!)...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录Dao层一个鱼唇至极的错误
这一天我在使用Spring的进行注解配置项目时,
我的Idea给我抛了一个如下的错误:
Exception in thread "main" org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'accountDaoImpl' defined in file [D:ideaworksday53_spring4demo03targetclassescomjxkdaoimplAccountDaoImpl.class]: Invocation of init method failed;
nested exception is java.lang.IllegalArgumentException:
'dataSource' or 'jdbcTemplate' is required
一开始看到这个错误,我赶紧又看了一下我的配置文件:
xmlns:aop="http://www.springframework.org/schema/aop"
xmlns:tx="http://www.springframework.org/schema/tx"
xmlns:context="http://www.springframework.org/schema/context"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
http://www.springframework.org/schema/aop
http://www.springframework.org/schema/aop/spring-aop.xsd
http://www.springframework.org/schema/tx
http://www.springframework.org/schema/tx/spring-tx.xsd
http://www.springframework.org/schema/context
http://www.springframework.org/schema/context/spring-context.xsd"&gt;
感觉没啥毛病啊,难道是spring提供的内置数据源有问题?
于是我就把上边的数据源替换成c3p0的…...
一运行––-—--
'dataSource' or 'jdbcTemplate' is required
难道是注解有干扰?于是在@Autowired下边添加了一个@Qualifier
@Repository
public class AccountDaoImpl extends JdbcDaoSupport implements AccountDao {
@Autowired
@Qualifier(value = "jdbcTemplate")
private JdbcTemplate jdbcTemplate;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef761841187510822e4d35b82d6193a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48f05eea4971e1941710d0a85a4ffdad/" rel="bookmark">
			TVM学习（三）编译流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VM主要的编译过程如下图：
Import：将tensorflow，onnx，pytorch等构建的深度学习模型导入，转化成TVM的中间层表示IR。
Lower：将高层IR表示转化成低阶TIR表示。
Codegen：内存分配和硬件可执行程序生成。
图导入
通过一个tensorflow的reception网络来熟悉编译过程，其它深度学习框架也具有类似过程。从TVM官网可以下载tensorflow的编译程序
https://tvm.apache.org/docs/tutorials/frontend/from_tensorflow.html#sphx-glr-tutorials-frontend-from-tensorflow-py。
主要代码如下：
模型的输入是一个后缀为pb的文件，它是神经网络模型图的protobuf格式存储文件。Pb是二进制形式，pbtxt是文本形式。Import_graph_def函数是导入pb，graph是tensorflow的图结构。
From_tensorflow是将tensorflow的图结构转化成TVM的IR。这个函数在文件relay/frontend/tensorflow.py中。函数的调用关系为：
From_tensorflow -&gt; GraphProto.from_tensorflow -&gt; self._get_relay_func。
在get_relay_func中会遍历每个tensorflow的节点，转换成tvm的IR表示。重点关注_backtrack_construct函数。
继续深入和算子转化有关的函数调用为：_convert_operator -&gt; convert_map。Convert_map中对应了可支持tensorflow算子到tvm算子的转换关系。
完成了tensorflow到TVM算子转化后，我们就得到了一个IRModule。我们可以利用tvm的可视化来打印出转化后的图：
Main是主函数入口，在TVM中以函数形式反应了tensorflow的图结构。函数的调用关系反应了图的依赖关系。
编译
Python中主要代码位于relay/build_module.py文件中，调用关系为build -&gt; BuildModule -&gt; build。在build中通过字典获得了C++中的相应函数。
这里不明白如何通过self.mod[“build”]得到C++中函数的。_BuildModule()是C++中注册到环境中的一个函数。在src/relay/backend/http://build_module.cc中，
TVM_REGISTER_GLOBAL是将C++函数注册到一个全局map中。当python加载编译好的动态库时，会自动查询map中静态注册的函数，并添加到python模块当中。
真正build操作位于RelayBuildModule类中，在其中有一个GetFunction函数，会通过名字查询要使用的函数，打包成PackedFunc返回，这个函数可能和self.mod[“build”]有关。PackedFunc是TVM中提供的python的一个接口，任何函数都可以封装成PackedFunc，并给python调用。更详细介绍可看：https://hjchen2.github.io/2020/01/10/TVMPackedFunc%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/
继续深入代码，Build -&gt; BuildRelay。这是编译的主要代码。其过程包括optimize，codgen。
Optimize就是执行一些优化passes，这些passes包括常数折叠，算符融合等。之后会调用graph_codegen-&gt;Codegen。Codegen中实现了内存分配和硬件代码生成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b29c499a2dc3d0808af7df89dc99c723/" rel="bookmark">
			Ubuntu打开ssh，可以远程登陆自己的电脑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SSH分客户端openssh-client和openssh-server
默认情况下已经安装了客户端openssh-client
若希望其他可以远程登陆，要打开openssh-server
查看安装情况
dpkg -l | grep ssh sudo apt-get install openssh-server 查看已安装的软件
dpkg -l 查找某个名字为zero，| grep 是管道
dpkg -l | grep zero 查看进程命令
ps -e 查看某个进程
ps -e | grep zero 启动ssh
sudo /etc/init.d/ssh start sudo service ssh start ssh-server配置文件 /etc/ssh/sshd_config，在这里可以定义SSH的服务端口，默认端口是22，你可以自己定义成其他端口号，如222。（或把配置文件中的”PermitRootLogin without-password”加一个”#”号,把它注释掉，再增加一句”PermitRootLogin yes”）
https://blog.csdn.net/jackghq/article/details/54974141
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5bf610c286f3952b36a091582b03957/" rel="bookmark">
			mybatis-plus 通过QueryWrapper进行多条件查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标题mybatis-plus QueryWrapper pojo： @Data @EqualsAndHashCode(callSuper = false) @Accessors(chain = true) @TableName("m_goods") @ApiModel(value="Goods对象", description="") public class Goods implements Serializable { private static final long serialVersionUID = 1L; @ApiModelProperty(value = "序号主键") @TableId(value = "id", type = IdType.AUTO) private Integer id; @ApiModelProperty(value = "货物名称") private String goodsname; @ApiModelProperty(value = "货物价格") private Integer goodsprice; @ApiModelProperty(value = "货物数量") private Integer goodsnum; } Controller： @ApiOperation(value = "根据条件查询商品") @PostMapping("/selectGoodsByCondition/{currentPage}/{pageSize}") public RespBean selectGoodsByCondition(@RequestBody Goods goods, @PathVariable("currentPage") Integer currentPage, @PathVariable("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5bf610c286f3952b36a091582b03957/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d84a66f2019be0ea5c1169903f3745b/" rel="bookmark">
			vue element 实现树形菜单栏n层级分类,NavMenu menu
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：项目有个需求，要实现多层文件夹的下拉。
思路：数据结构为数组多层级嵌套模式，需要利用递归渲染菜单栏数据实现菜单多层级分类。
什么是递归？ 定义：就是函数自己调用自己本身，或者在自己函数调用的下级函数中调用自己。
递归函数的使用要注意函数终止条件避免死循环；
递归的步骤 假设递归函数已经写好
寻找递推关系
将递推关系的结构转换为递归体
将临界条件加入到递归体中
了解什么是递归后开始着手敲代码；
1.首先 模拟菜单数据，引入封装组件，index.vue
&lt;template&gt; &lt;div class="container"&gt; &lt;el-row class="main-part"&gt; &lt;el-col :span="5" class="title-col"&gt; &lt;!-- 实现菜单多级分类 --&gt; &lt;el-menu @open="handleOpen" @close="handleClose" default-active="1-1-1-1" background-color="#fff" text-color="#000" active-text-color="#000" &gt; &lt;!-- 引入组件 --&gt; &lt;menu-tree :menuData="menuList"&gt;&lt;/menu-tree&gt; &lt;/el-menu&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import MenuTree from '../../components/MentTree' export default { components: { MenuTree }, data () { return { menuList: [ { "id": "1363387207968104450", "name": "第一层", "suffix": null, "fileId": null, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d84a66f2019be0ea5c1169903f3745b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/956b503945f34e59921a35858c1594ac/" rel="bookmark">
			vue3.0&#43;vite 使用 postcss-pxtorem 实现移动自适应（px转rem）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载 postcss-pxtorem npm i postcss-pxtorem -D
与package.json同级目录创建postcss.config.js文件 module.exports = { plugins: { autoprefixer: { overrideBrowserslist: [ "Android 4.1", "iOS 7.1", "Chrome &gt; 31", "ff &gt; 31", "ie &gt;= 8", "last 10 versions", // 所有主流浏览器最近10版本用 ], grid: true, }, 'postcss-pxtorem': { rootValue: 37.5, propList: ['*'], unitPrecision: 5 } } } 这里只实现了 px转rem，还要安装 amfe-flexible
npm i amfe-flexible -D
在main.ts文件中 import 一下就好可以了
import ‘amfe-flexible/index.js’
：可能会出现下面情况
[vite] Internal server error: Loading PostCSS Plugin failed: Cannot find module 'autoprefixer'
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/956b503945f34e59921a35858c1594ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35d2b109c34769b4f2fa017527c23307/" rel="bookmark">
			Kafka 如何给集群配置SSL认证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 上一篇【Kafka 如何给集群配置Scram账户认证】我们说了如何给连接Kafka的客户端设置账户名和密码，但是对于一个企业使用的安全验证显然还是不够的，因此本篇就接着上篇继续，在使用SASL的方式下再加一个SSL的连接认证方式，做一个双保险。更多内容请点击【Apache Kafka API AdminClient 目录】。
Kafka-SSL官方支持 Kafka如何进行SSL认证的官方参考见链接【security_ssl】，包括如何配置，如何申请CA Key，如何对证书签名等等都有详细的介绍，这里就不多说了，有兴趣的可以自己研究，这里我们直说怎么用。因此我们已经有了一对CA认证签名做好的.jks文件service.keystore.jks和client.truststore.jks以及它们的密码abcdefg。
Zookeeper 配置 由于这篇博客算是接着上一篇来的，因此我们就直接使用上一篇的Zookeeper配置，最终会搭建一个既有SASL认证，也有SSL认证的Kafka集群。当然SSL和SASL两种安全机制是独立的，单独使用SASL或者SSL都是可以的。
tickTime=2000 initLimit=10 syncLimit=5 dataDir=/home/data/zookeeper_data dataLogDir=/home/data/zookeeper_log #这里可以不配置 clientPort=2181 # 下面两行仅仅是SASL支持，不需要可以删了 authProvider.1=org.apache.zookeeper.server.auth.SASLAuthenticationProvider requireClientAuthScheme=sasl server.1=192.168.33.101:2887:3887 server.2=192.168.33.102:2887:3887 server.3=192.168.33.103:2887:3887 server.4=192.168.33.104:2887:3887 server.5=192.168.33.105:2887:3887 Kafka配置 在正常启动Zookeeper以后，我们在上一篇Kafka的service.properties文件中添加新的SSL认证参数。此步骤的前提同样也是建立在上篇SASL认证基础上的，如果不需要，可以把这部分删除。
############################ 基础配置如下 ############################## broker.id=1 #默认监控端口，设置9092使用SASL_SSL协议，设置9093使用SASL_PLAINTEXT协议，此时使用9092端口就需要jks+SASL认证才能够连接了 #如果只要SSL认证，则配置“listeners=SSL://192.168.33.101:9092” listeners=SASL_SSL://192.168.33.101:9092,SASL_PLAINTEXT://192.168.33.101:9093 #advertised.listeners控制生产者与消费者接入的端口，如果不设置默认都用listeners，设置9092使用SASL_SSL协议，设置9093使用SASL_PLAINTEXT协议 #如果只要SSL认证，则配置“advertised.listeners=SSL://192.168.33.101:9092” advertised.listeners=SASL_SSL://192.168.33.101:9092,SASL_PLAINTEXT://192.168.33.101:9093 log.dirs=/home/data/kafka-logs zookeeper.connect=192.168.33.101:2181,192.168.33.102:2181,192.168.33.103:2181,192.168.33.104:2181,192.168.33.105:2181/kafka ############################ SSL相关配置如下 ############################## #设置客户端的SSL认证文件，需要提前将client.truststore.jks文件提前Copy到该目录 ssl.truststore.location=/usr/local/client.truststore.jks #配置客户端truststore认证密码 ssl.truststore.password=abcdefg #设置服务器的SSL认证文件，需要提前将service.keystore.jks文件提前Copy到该目录 ssl.keystore.location=/usr/local/service.keystore.jks #配置服务端KeyStore认证密码 ssl.keystore.password=abcdefg #配置key认证密码 ssl.key.password=abcdefg #配置启动的权限，这里把所有的认证协议都加上了 ssl.enabled.protocols=TLSv1.2,TLSv1.1,TLSv1 #强制连接需要 ssl.client.auth=required #配置文件认证类型 ssl.keystore.type=JKS ssl.truststore.type=JKS ############################ SASL/SCRAM相关配置如下，不需要可以删除 ############################## #Broker内部联络使用的security协议 #security.inter.broker.protocol=SSL 只用SSL认证这样配置 security.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35d2b109c34769b4f2fa017527c23307/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f652303a5950359376bbcc7c5679d73/" rel="bookmark">
			数据结构之树（4）——红黑树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 红黑树
概念
调整
变色
左旋和右旋
插入
插入情况分析
插入平衡总结
插入实例
删除
概述
删除情况分析
删除平衡总结
删除实例
参考链接
红黑树 概念 红黑树同样是解决二叉排序树不平衡的问题的，例如下面这种失衡的二叉树。
所以红黑树首先是一棵二叉排序树，然后是二叉平衡树的特殊形式。
​
红黑树(Red Black Tree)是一种自平衡的二叉查找树。红黑树有如下特性：
结点是红色或者黑色的。根结点是黑色的。每个叶子结点都是黑色的空结点（NIL结点）。每个红色结点的两个子结点都是黑色的（从每个叶子到根的所有路径上不能有两个连续的红色结点）。从任一结点到其每个叶子的所有路径都包含相同数组的黑色结点。 ​
调整 新插入的结点颜色一定要先设置为红色，下面向红黑树种插入一个值为14的结点。
​
符合红黑树的规则，不需要调整平衡。
再插入一个21结点，如下图：
​
违反了上面的“每个红色结点的两个子结点都是黑色的”，所以必须进行调整，让这棵树重新符合红黑树的定义。
叶子(NIL)节点就是一个空节点，表示节点在此位置上没有元素了。在实际的算法实现中NIL不需要考虑，填上NIL节点只是为了判断到此路径终点的NIL节点上，经过多少黑节点。
调整红黑树有两种方法：变色和旋转（左旋转和右旋转）
变色：将红色结点变为黑色，或者将黑色结点变为红色。左旋转：逆时针旋转红黑树的两个节点，使得父节点被自己的右孩子取代，而自己成为自己的左孩子。右旋转：顺时针旋转红黑树的两个节点，使得父节点被自己的左孩子取代，而自己成为自己的右孩子。 变色 下面说下变色：
结点21和结点22都是红色，需要进行调整
​
将结点22变成黑色
​
但又不符合“从任一结点到其每个叶子的所有路径都包含相同数组的黑色结点”规则，从根结点13到结点21下的NIL结点，共有4个黑色结点，其他路径有3个黑色结点。
所以将结点25变成红色结点，如下：
​
此时发现结点25和结点27都是红色结点，所以将结点27变为黑色结点。
​
总之，变色就是改变结点的颜色，要么是红色，要么是黑色，然后调整成符合红黑树的规则。
左旋和右旋 关于左旋和右旋可以查看AVL树中的旋转：数据结构之树（3）——二叉平衡树（AVL）
左旋转，在上面已经说了
​
右旋转，上面也讲了的
​
但什么时候用变色，什么时候又用旋转呢，这很复杂，红黑树的插入和删除都需要判断调整是否符合红黑树的规则，然后调整。
下面通过其他参考资料来试图说明下红黑树插入和删除的各种情况：
插入 插入情况分析 红黑树的插入同二叉排序树的插入过程相似，但红黑树插入新结点后，需要判断红黑树是否符合定义要求，如果不符合，租需要进行调整，以满足红黑树的性质。
认识下结点的标记
第一种情况：如果插入的结点是根结点，那么该结点颜色调整为黑色
​
但发现不满足“根结点是黑色的”，所以需要调整，将根结点调整为黑色。
​
这时发现红黑树的所有要求被满足。
第二种情况：待插入结点的父结点是黑色，不需要调整
​
第三种情况：待插入结点的父结点是红色，同时叔叔结点也是红色，需要调整 ​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f652303a5950359376bbcc7c5679d73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39d8912da995375fb2fb57a36df41774/" rel="bookmark">
			PyQt5开发环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PyQt5开发环境搭建 一，什么是PyQt5?
PyQt是一个创建python GUI应用程序的工具包，是C++的Qt和python结合的一个产物，PyQt5是一个基于Qt5的python语言的实现，是由一组python模块构成的。PyQt5从结构上可以看成是三大部分组成，一是Qt Designer，中文称为Qt设计师，这是一个图形界面开发工具，二是将图形界面相关资源转换成python语言的工具，包括PyUIC和PyRcc，三是PyQt类库。
二，PyQt5三大组成系统
PyQt5安装时，需要三个安装包，分别是PyQt5-sip，PyQt5，PyQt5-tools，也就是说PyQt5整体由这三大部分组成
三，开发环境安装步骤（必须遵循安装顺序，否则会出错）
1.安装PyQt5-sip（可以与C和C++交互），命令如下:
pip install –user sip -i https://pypi.douban.com/simple
2.安装PyQt5（Qt各个类的python模块），命令如下：
pip install PyQt5 -i https://pypi.douban.com/simple
3.安装PyQt5-tools（主要包括Qt Designer，PyUIC，PyRcc），命令如下：
pip install PyQt5-tools -i https://pypi.douban.com/simple
4.查看是否安装成功
执行pip list，显示如下及说明安装成功
四，在pycharm中集成PyQt5开发环境
1.打开pycharm，通过菜单路径：File——settings进入设置界面，在设置界面选择菜单路径：tools——external tools进入外部工具配置界面
2.Qt Designer配置信息
搜索自己PC的designer.exe路径
3.PyUIC配置信息
arguments:-m PyQt5.uic.pyuic F i l e N a m e FileName FileName -o F i l e N a m e W i t h o u t E x t e n s i o n FileNameWithoutExtension FileNameWithoutExtension.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39d8912da995375fb2fb57a36df41774/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c239406b2e51a934edc0844eb9b171e2/" rel="bookmark">
			运算符辨别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 运算符的类型 类型： 算数运算符： +，-，*，/，%，++，--赋值运算符：=扩展赋值运算符：+=，-=，*=，/=关系运算符： &gt;，&lt;，&gt;=，&lt;=，==，!=，instanceof逻辑运算符：位运算符： 7. 条件运算符：？：
8. 字符串连接符：+
重点需要辨别的包括： 1. 算数运算符中的“/”和“%” “/”其实是除法取整运算
“%”其实是取余运算，如果遇到负数的计算问题，详情见下图
2. 关系运算符- instanceof 关键字用法 instanceof 是 Java 的一个二元操作符，类似于 ==，&gt;，&lt; 等操作符。
instanceof 是 Java 的保留关键字。它的作用是测试它左边的对象是否是它右边的类的实例，返回 boolean 的数据类型。
图片来源链接： https://www.runoob.com/java/method-instanceof.html 3. 位运算符中和逻辑运算符相同部分区分 首先表格对比二者之含义差别 逻辑运算符 位运算符 其次对于逻辑运算符中的短路深度理解 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a793960eb76c0615f14ca66eda9d9e52/" rel="bookmark">
			getheaderfields java_java  –  HttpsURLConnection getHeaderFields没有返回set-cookie
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我正在向一个HTTPS URL发送一个get请求,不知怎的,我正在为“Set-Cookie”获取空值.迭代时我可以看到header-key有“set-cookie”但header-value为null.
这是我的代码：
URL obj = new URL(url);
HttpsURLConnection conn = (HttpsURLConnection) obj.openConnection();
HttpsURLConnection.setFollowRedirects(false);
conn.setRequestProperty("User-Agent", USER_AGENT);
conn.setRequestProperty("Accept",
"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8");
conn.setRequestProperty("Accept-Language", "en-US,en;q=0.5");
conn.setRequestProperty("Connection", "keep-alive");
conn.setRequestProperty("Accept-Encoding", "gzip, deflate");
conn.connect();
Map em = conn.getHeaderFields();
System.out.println("header Values......" + em.toString());
String headerName = null;
for (int i = 1; (headerName = conn.getHeaderFieldKey(i)) != null; i++)
{
System.out.println("Header Nme : " + headerName);
System.out.println(conn.getHeaderField(i));
}
输出：
header Values......{null=[HTTP/1.1 200 OK], x-wily-info=[Clear guid=0BE0EC9D0A7E67816C471FA946FD2EBB], Date=[Sat, 29 Mar 2014 03:27:41 GMT], Content-Length=[8106], x-wily-servlet=[*******************], X-FRAME-OPTIONS=[SAMEORIGIN], Connection=[close], Content-Type=[text/html;charset=UTF-8]}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a793960eb76c0615f14ca66eda9d9e52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/681f12f4bb9a2da8680d5f1448a35ff0/" rel="bookmark">
			getheaderfields java_Java 发起 http 请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、GET与POST
GET和POST是HTTP的两个常用方法。
GET指从指定的服务器中获取数据
POST指提交数据给指定的服务器处理
1.GET方法
使用GET方法，需要传递的参数被附加在URL地址后面一起发送到服务器。
例如：http://192.168.0.19/submit?name=zxy&amp;age=21
特点：
GET请求能够被缓存
GET请求会保存在浏览器的浏览记录中
以GET请求的URL能够保存为浏览器书签
GET请求有长度限制
GET请求主要用以获取数据
2.POST方法
使用POST方法，需要传递的参数在POST信息中单独存在，和HTTP请求一起发送到服务器。
例如：
POST /submit HTTP/1.1
Host 121.41.111.95
name=zxy&amp;age=21
特点：
POST请求不能被缓存下来
POST请求不会保存在浏览器浏览记录中
以POST请求的URL无法保存为浏览器书签
POST请求没有长度限制
实现代码
下面将Java发送GET/POST请求封装成HttpRequest类，可以直接使用。HttpRequest类代码如下：
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.URL;
import java.net.URLConnection;
import java.util.List;
import java.util.Map;
//java项目www.fhadmin.org
public class HttpRequest {
/**
* 向指定URL发送GET方法的请求
*
* @param url
* 发送请求的URL
* @param param
* 请求参数，请求参数应该是 name1=value1&amp;name2=value2 的形式。
* @return URL 所代表远程资源的响应结果
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/681f12f4bb9a2da8680d5f1448a35ff0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aff270a751ded6f6ea803178c46866a2/" rel="bookmark">
			Selecting Windows SDK version
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不知道这句话是哪个脚本输出的 ：Selecting Windows SDK version现在也没找到。发现cmake 改不了 CMAKE_VS_WINDOWS_TARGET_PLATFORM_VERSION will contain the chosen Windows 10 SDK version.
可能是被我？ 在哪里写死了。。。 这位大神的笔记 Selecting Windows SDK version 10.0.18362.0 to target Windows 10.0.17763: 说明 SDK 版本和windows 版本不匹配, 需要重新下载对应版本的 SDK: https://developer.microsoft.com/zh-cn/windows/downloads/sdk-archive.
SDK版本对应 https://github.com/bjkwon/auxlab/blob/63c9d69bc8223d69f12ca9d5a24deab5353202d1/weird_VS_stuff_Windows_SDK_version.txt In VS2017, Windows SDK Version needs to be specifically defined, such as &lt;WindowsTargetPlatformVersion&gt;10.0.16299.0&lt;/WindowsTargetPlatformVersion&gt; in either *.vcxproj file or *.props globally. In my PC (running VS2017), Windows SDK version shows 4 choices: 10.0.16299.0 10.0.15063.0 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aff270a751ded6f6ea803178c46866a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad5dd5f7b83642b4ef25c6cb21f67132/" rel="bookmark">
			初识webpack之loader的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是loader？
前面有讲到，webpack是一个模块打包工具，它可以打包任何以模块方式引入的文件，而webpack实际上默认情况下它还是只能识别js文件，而要打包其它类型的文件，此时就需要我们在webpack.config.js配置文件中对需要打包的文件进行配置。只有配置之后，当我们的webpack在打包非js文件时，它才会去看配置文件中是怎么配置的，然后按照我们的配置进行打包，而配置打包规则时就需要用到我们的loader。配置非js打包规则如下：
从图中我们可以看到，在这个配置文件中，我们不止配置了webpack打包的入口和出口文件，还配置了module，而module中的rules就是配置的各种打包文件的打包方案。而要使用loader方案来打包文件，我们在打包之前就需要下安装我们需要用到的loader。
总结：loader实际上就是针对不同类型的打包文件提供的打包方案。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1777b34ee0188619d94be821b8d98cf6/" rel="bookmark">
			IDEA中pom文件变成了橘黄色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IDEA中pom文件变成了橘黄色 有的时候项目中的pom.xml文件会变成橘黄色，原因是这个文件不是maven项目，右键点击pom.xml，点击add as maven project，将项目添加为Maven项目就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/169e45bcc4f0d461714e215959c8d20b/" rel="bookmark">
			C语言用结构体构造动态链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		非常实际的一个问题，我们需要通过构造动态链表来输入一组学生的成绩信息，代码及注释如下：
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; //调用malloc函数需要stdlib库 #define LEN sizeof(struct student) //可以简单的理解为将程序中所有的"LEN"替换为"sizeof(struct student)" struct student { long num; float score; struct student *next; //定义一个student类型的结构体指针，用于链表的链接 }; /*********************************************************************************************************************************/ int n;	//n是一个全局变量，用于记录有多少个学生信息在这个链表中 struct student *creat(void)	//链表创建函数 { struct student *head; struct student *p1,*p2; n=0;	p1=p2=(struct student*)malloc(LEN);	//在标准库中malloc函数给到的是一个void类型的空间，需要用强制转换符来获得合适类型的空间 scanf("%ld,%f",&amp;p1-&gt;num,&amp;p1-&gt;score);//录入第一个学生信息 head=NULL;	//在不确定信息是否有效时，动态链表应该为空，也即头指针指向为空 while(p1-&gt;num!=0)	//这里假定学生学号不为零，若输入零代表这个动态链表结束链接 { n=n+1;	//每录入一个学生信息，n就加一 //当录入第一个学生信息之后，这个学生信息的地址就作为链表的头指针，让head指向p1（此时p1、p2都指向第一个学生信息） if(n==1)head=p1; //如果录入的学生信息不是第一个，那么（由后面的操作）p1此时指向的是这个学生信息的地址，而p2指向的是上一个学生信息地址 //此时需要让p2-&gt;next指向p1，也即让上一个链表成员与新的成员链接起来 else p2-&gt;next=p1;	p2=p1;	//再让p2向前指一位，以便于下次操作，此时p1、p2都指向最新加入链表的成员	p1=(struct student*)malloc(LEN);//让p1开辟新的studdent类型的空间，输入下一个链表成员信息。可以理解为while循环中的x++ scanf("%ld,%f",&amp;p1-&gt;num,&amp;p1-&gt;score); } p2-&gt;next=NULL;	//最后一位链表成员不再链接其他东西，这里的指向NULL相当于表尾 return (head); //向主函数返回构造好的动态链表d的第一个结点的地址 } /*********************************************************************************************************************************/ /*********************************************************************************************************************************/ void print(struct student *head)	//构造结构体输出函数 { struct student *p; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/169e45bcc4f0d461714e215959c8d20b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a77e416b2e993dc96fe09e6c7d7fa187/" rel="bookmark">
			annotation java log_java自定义注解，以编写spring日志打印注解@ApiLog为例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java自定义注解，以编写spring日志打印注解@ApiLog为例
1.声明一个注解
基本元素
描述
修饰符
访问修饰符必须为public,不写默认为pubic
关键字
关键字为@interface
注解名称
注解名称为自定义注解的名称，使用时还会用到
注解类型元素
注解类型元素是注解中内容，可以理解成自定义接口的实现部分
例：
public @interface ApiLog {
}
2.@Target修饰注解
@Target用以表明该注解可以应用的java元素类型
类型
描述
ElementType.TYPE
应用于类、接口(包括注解类型)、枚举
ElementType.FIELD
应用于属性(包括枚举中的常量)
ElementType.METHOD
应用于方法
ElementType.PARAMETER
应用于方法的形参
ElementType.CONSTRUCTOR
应用于构造函数
ElementType.LOCAL_VARIABLE
应用于局部变量
ElementType.ANNOTATION_TYPE
应用于注解类型
ElementType.PACKAGE
应用于包
ElementType.TYPE_PARAMETER
1.8版本新增，应用于类型变量
ElementType.TYPE_USE
1.8版本新增，应用于任何使用类型的语句中(例如声明语句、泛型和强制转换语句中的类型)
例：
@Target({ElementType.TYPE, ElementType.METHOD})
public @interface ApiLog {
}
3.@Retention修饰注解
类型
描述
RetentionPolicy.SOURCE
编译时被丢弃，不包含在类文件中
RetentionPolicy.CLASS
JVM加载时被丢弃，包含在类文件中，默认值
RetentionPolicy.RUNTIME
由JVM 加载，包含在类文件中，在运行时可以被获取到
例：
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface ApiLog {
}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a77e416b2e993dc96fe09e6c7d7fa187/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c53cf709b44095d52aaa3fd3150d7547/" rel="bookmark">
			7段均衡器最佳参数_汽车音响7段均衡器设置，七段均衡器常用调校图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		几乎所有车载音响都会有音效设置，其中均衡器是调整声音的主要设置之一，今天我们以最常见的7段均衡器来说一说如何设置达到最佳效果。
不同车型的7段均衡器具体频段可能不一样，不过大致上的调节基本相同，首先来看看每一个频段都分管音乐哪些内容。以60Hz、150Hz、400Hz、1kHz、3kHz、7kHz、15k Hz为例：
60Hz 重低音，主要表现声音的空间感；
150Hz低音，主要表现声音的力度，尤其是男音；
400Hz人声，主要表现声音的喉音；
1kHz器材，主要表现音乐器材的穿透力；
3kHz主要表现声音的明亮度和清晰度；
7kHz主要表现声音的明亮度和清晰度；
15kHz高音，主要表现声音的攻击性。
以下分享几种七段均衡参数设置(从左至右开始)：
1、偏低音
第一频段：+4；第二频段：+2；第三频段：0；第四频段：+1；第五频段：+2；
第六频段：+1；第七频段：+1。
2、高低音强，偏摇滚
第一频段：+4；第二频段：+2；第三频段：0；第四频段：+1；第五频段：0；
第六频段：+1；第七频段：+3。
3、层次分明，偏人声
第一频段：0；第二频段：+1；第三频段：+3；第四频段：+1；第五频段：+1；
第六频段：0；第七频段：+1。
值得一提的是，均衡器设置并非必要，它只是一个音色的润滑工具，而不是修理工具。并且均衡器没有所谓的最佳设置，只有符合自己的感受才是最舒服的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/988c1ec60a147d8fd38aad68f237def8/" rel="bookmark">
			bootstrap使用-基础样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 标题 标题提供了h1-h6和.h1-.h6 2种方式。
small ：副标题
&lt;h1&gt;标题一 &lt;small&gt;小标题&lt;/small&gt;&lt;/h1&gt; &lt;h2&gt;标题二&lt;/h2&gt; &lt;h3&gt;标题三&lt;/h3&gt; &lt;h4&gt;标题四&lt;/h4&gt; &lt;h5&gt;标题五&lt;/h5&gt; &lt;h6&gt;标题六&lt;/h6&gt; &lt;div&gt; &lt;span class="h1"&gt;标题一&lt;small&gt;小标题&lt;/small&gt;&lt;/span&gt; &lt;span class="h2"&gt;标题一&lt;/span&gt; &lt;span class="h3"&gt;标题一&lt;/span&gt; &lt;span class="h4"&gt;标题一&lt;/span&gt; &lt;span class="h5"&gt;标题一&lt;/span&gt; &lt;span class="h6"&gt;标题一&lt;/span&gt; &lt;/div&gt; 2. 段落与文本 网页标记
&lt;mark&gt;响应式图像&lt;/mark&gt; //突出显示文本 &lt;del&gt;的解决方案&lt;/del&gt; //删除线 //提示：&lt;del&gt; 和 &lt;ins&gt; 一起使用，描述文档中的更新和修正。浏览器通常会在已删除文本上添加一条删除线，在新插入文本下添加一条下划线。在HTML文档中每个 &lt;ins&gt; 标签都能创建 ins 对象 &lt;ins&gt;有很多&lt;/ins&gt; //定义已经被插入文档中的文本。 &lt;u&gt;JavaScript 和&lt;/u&gt; //为文本添加下划线 &lt;small&gt; &lt;/small&gt; //把字符串显示为小号字 &lt;strong&gt; &lt;/strong&gt; //定义重要的文本 bootstrap 中文本的处理
text-left，文本左对齐 text-center，文本居中对齐 text-right，文本右对齐 text-lowercase 英文字母小写 text-uppercase 英文字母大写 text-capitalize 英文字母首字母大写 3. 表格 table 表格
table-striped 斑马线
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/988c1ec60a147d8fd38aad68f237def8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/286487a2dba1871f39bd6e2bd60c013c/" rel="bookmark">
			登录Swagger2界面却进入了Please sign in界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 启动Swagger-ui，却进入了Please sign in 在搭建开发环境时，配置好了swagger2，在访问swagger2接口界面时并没有进入swagger-ui界面，而是进入了一个登录界面，这个界面并不是我写的。后来查询资料发现，这个界面是SpringSecurity对swagger2访问进行拦截。
解决方法：
如果不使用SpringSecurity，可以将pom.xml文件中的SpringSecurity依赖删除。如果希望继续使用SpringSecurity，则在配置类中进行如下配置。 @Override protected void configure(HttpSecurity http) throws Exception { http.formLogin() // 自定义自己编写的登录页面 .loginPage("/login.html") // 登录页面设置 .loginProcessingUrl("/user/login") // 登录访问路径 .defaultSuccessUrl("/test/index").permitAll() // 登录成功后的跳转路径 .and().authorizeRequests() .antMatchers("/","/test/hello","/login.html").permitAll() // 设置哪些路径可以直接访问，不需要认证 .anyRequest().authenticated() .and().csrf().disable(); // 关闭csrf防护 } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cf912101100fd17f171f4713efd909b/" rel="bookmark">
			Ubuntu更新之后无法搜索到WIFI了怎么办？RealTek 8822CE网卡Linux驱动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原因：
内核版本变了
cd /lib/modules 可以看到有2个版本，那个小的就是更新之前的
5.3.0-28-generic 5.4.0-58-generic 新的里面没有网卡驱动
首先确定自己的网卡型号
方法1，如果是双系统则进入windows的设备管理器查看
第二，在Ubunut中确定这个设备是可以看到的
list pci上的设备
lspci 01:00.0 Network controller: Realtek Semiconductor Co., Ltd. Device c822 证明这个设备是被Ubunut看到的
第三，RealTek的Linux驱动都是源码，需要自己编译
在bing搜索中输入
8822CE github 这样就可以找到源码
下载
git clone https://github.com/rtlwifi-linux/rtk_wifi_driver_rtl8822ce 第四，解压
输入下面命令
make make install 第五，注册（应该是这个意思）
安装命令sudo modprobe -a 8821ce 只要不提示错误就表示成功
sudo modprobe -a 8822ce 第六，重启
reboot 也就是5.4.0-48-generic
看这个文件夹下的kernel/drivers/net/wireless/realtek下有没有rtw88这个文件夹
如果有，删除rtw88文件夹（删之前cp备份一下哈，以免删完没用原来的也没了）
sudo rm -rf rtw88 再用下面命令行更新
update-initramfs -u 然后重启电脑 wifi就好使啦！！！！！！！
经过几次反复装驱动才发现，我的wifi和英伟达驱动突然消失的情况是系统自动检测更新，然后给我更新了，每次更新完这两个驱动都不好使。
打开软件与更新，选择更新，把自动检测更新那个设置成了从不，希望以后不要再出现这个问题了。每次都要浪费我半小时。气。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2d4f2ceb5e2265e08ec694173e19b28/" rel="bookmark">
			unity的UGUI笔记（二）--Text
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于text text是UI中显示文字的组件，中文模式下很多都可以轻松理解其中的含义
以下是比较重要的东西：
1.几何对齐：以文本框为参考对齐，使用后更好的对齐贴合文本框，就像把word的 边框去掉直接对齐一样（个人理解）
2.富文本：使用后可以支持字体调节，颜色，大小，粗细
3.水平/垂直溢出：使用overflow，超出文本框的文字，可以正常显示出来，反之，则会不显示，除非你扩大文本框
4.最佳适应：开启后，你在文本框中输入的东西会自动调节字体大小，防止其无法显示
5.光线投射目标：unity默认勾选项目，npc互动时会应用，接近ncp，以玩家为原点，发射射线，如果成功，则触发文字
关于脚本中修改text的方法（简单向）：
private Text text;//记得写上using UnityEngine.UI void Start() { text = transform.GetComponent&lt;Text&gt;(); //获取组件 text.text = "this is rime\nthis is not rime";//内容设置 text.fontSize = 20; //大小设置 text.color = Color.red; //颜色设置 text.fontStyle = FontStyle.Bold; //字体设置 } Bold 粗体
BoldAndItalic 粗体加斜体
Italic 斜体
Normal 标准
备注：因为不会修改代码片的基本颜色，查看时为了方便可以用鼠标选中文本，这样能更清晰一些。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2daf295973368c2cd0533028f2ec2431/" rel="bookmark">
			Warning: The core is locked up的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		rt thread studio V2.0版本编译器
使用正点原子的DAP无线调试器进入调试模式后，再用J link下载程序就提示Warning: The core is locked up
从菜单 SEGGER-&gt;J-Link STM32 Unlock ，运行一下就行了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49ba10db11d16f3ae99568745baea979/" rel="bookmark">
			java环境教程_java环境配置的详细教程（图文）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇文章给大家带来的内容是关于java环境配置的详细教程(图文)，有一定的参考价值，有需要的朋友可以参考一下，希望对你有所帮助。
JAVA环境变量的配置：Path,JAVA_HOME,CLASSPATH
一、右键我的电脑，属性，高级系统设置，点击环境变量
二、然后就会弹出环境变量这个窗口，在系统变量编辑JAVA_HOME,如果没有就新建一个，把jkd的路径添加进去，如图
三、配置CASSPATH，如果没有就新建一个，把jdk的lib里面的tool.jar和dt.jar添加进去，注意在前面加一个“.”，如图
四、配置Path，依次将jdk里的bin、jdk里jre的bin、jdk里的lib和lib里的tool.jar添加进去
五、查看是否配置成功，在命令行写上java，javac和java - version测试，效果如下
六、既然测试没毛病，那我们写一段代码看看能不能打印出来
先在记事本写一段hello would的代码,文件名和类名必须一致，把后缀改为.java，注意，这里为了方便我把hello.java写在了当前的文件夹
“javac hello.java”会在当前文件夹里找这个.java文件，所以编译前我们先进入需要编译的.java文件存放的目录，javac后会生成一个.class文件,然后我们就可以使用“java hello”的方式打印出hello would了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/552f447afa929c7acf754efe2d70c53d/" rel="bookmark">
			resnet152训练_ResNet改进版来了！可训练网络超过3000层！相同深度精度更高
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习了~
来自阿联酋起源人工智能研究院(IIAI)的研究人员公布了一篇论文Improved Residual Networks for Image and Video Recognition，深入研究了残差网络不能更深的原因，提出了改进版的残差网络(Improved Residual Networks，iResNet)，使得训练超深网络时更容易收敛，在多个计算机视觉任务(图像分类，COCO目标检测，视频动作识别)中精度也更高。
作者成功在ImageNet数据集上训练了404层网络的模型，在CIFAR-10和CIFAR-100数据集上训练了3002层网络的模型，而原始的残差网络在达到上述层数的时候已经无法收敛。
该文作者信息：
因残差网络几乎已经成为所有深度卷积网络的标配，“涨点又不涨计算量”的iResNet的出现，或可影响深远。
算法思想
作者主要从三个方向来思考残差网络的改进：
1)促进信息在网络中的流动(Improved flow of information)
2)减少信息损失(Improved projection shortcut)
3)不增加计算量前提下增强残差模块的学习能力(Grouped building block)
1. Improved information flow through the network
作者认为原始的ResNet网络模块中的ReLU在将负信号置0时影响了信息的传播，这种情形在刚开始训练时尤其严重，提出了一种分网络阶段(stage)的三种不同残差构建模块。
以50层的残差网络为例，作者按照网络中特征的空间分辨率大小划分四个阶段(stage)，相同分辨率的残差模块被分为同一个stage，
每个stage都包含有下图中start ResBlock、Middle ResBlock、End ResBlock三种残差模块，每个stage有一个start ResBlock 、一个End ResBlock 和数个Middle ResBlock。
减少整体上ReLU对信息流通的影响。
2. Improved projection shortcut
projection shortcut 被用于残差网络特征维度改变的时候，用于将不同特征维度的特征相加之前的处理。原始的残差网络使用stride为2的1x1卷积进行通道的改变。如下图中的(a)。
作者认为1x1卷积丢弃了大量信息，提出先使用3x3 max Pooling再使用1x1卷积的方案，即实现了保留重要信息的降维。
3. Grouped building block
作者认为原始的残差网络中瓶颈模块(bottleneck block)不够好，这种上下粗中间细的结构中，前面的1x1卷积是为了降通道数进而减少计算量，后面的1x1卷积是为了特征对齐，3x3卷积部分被限制了，只有它在“认真的”学习特征模式，将其通道数减少虽然提高了计算速度，却降低了网络表达能力。(算是一种不得已而为之的设计吧)
而新的组卷积(Group conv)技术方案恰好可以解决这个问题。所以作者提出使用组卷积构建模块替换瓶颈模块。
如下图：
ResGroup在不增加计算量的前提下可更好的让3x3卷积发挥作用。
实验结果
使用上述改进方案，可以训练更深层的网络模型，而且相对原始方案，在相同深度时，iResNet的精度也更高。
下图为在ImageNet上训练50、101、152、200层网络时的结果比较：
可见原始残差网络在超过152层时精度开始下降，iResNet精度一直在上升，且比其他方案的精度更好。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/552f447afa929c7acf754efe2d70c53d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25470ac9a3836b8a9070668e232150c1/" rel="bookmark">
			qpython 教程_极简Qlearning教程（附Python源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		极简Qlearning入门教程
在当前的机器学习中，主流方向为有监督学习、无监督学习以及强化学习，今天我想介绍的就是强化学习的一个小入门Qleaning算法。
回想我们小时候在妈妈的教育下进行学习，首先我们是什么都不会，但是在父母的教育下，慢慢地开始学习起来，比如看见猫，第一次见到不知道这是什么物种，于是妈妈告诉你这是猫，下次见到就知道了，这就是监督学习，当我们做出一个动作，立即得到反馈，而强化学习则不然，当我们做出动作的时候，却不会有立即的反馈，只能到结束才能知道效果，因此本人在学习的过程中，将网上的资料收集了一下，发现这篇文章是特别棒的http://mnemstudio.org/path-finding-q-learning-tutorial.htm
假设有这样的房间
这样看，我们可以将其进行建模：
这就是房间对应的图。我们首先将agent(机器人)处于任何一个位置，让他自己走动，直到走到5房间，表示成功。为了能够走出去，我们将每个节点之间设置一定的权重，能够直接到达5的边设置为100，其他不能的设置为0，这样网络的图为：
Qlearning中，最重要的就是“状态”和“动作”，状态表示处于图中的哪个节点，比如2节点，3节点等等，而动作则表示从一个节点到另一个节点的操作。
首先我们生成一个奖赏矩阵：
-1表示不可以通过
0表示可以通过
100表示直接到达终点
总结就是：R矩阵中非负的表示节点之间是可以相通的。
同时，我们创建一个Q表，表示学习到的经验，与R表同阶，初始化为0矩阵。
根据Q-learning转移方程：
S表示当前的状态
a表示当前的动作
s~表示下一个状态
a~表示下一个动作
λ为贪婪因子，0
下面就是Qlearning的学习步骤：
当Q表学习完以后，就可以根据Q表来选择路径。
看一个实际的例子
首先设定λ=0.8，R：
Q：
随机选择一个状态，比如1，查看状态1所对应的R表，也就是1可以到达3或5，随机地，我们选择5，根据转移方程：
于是，Q表为：
这样，到达目标，一次尝试结束。
接下来再选择一个随机状态，比如3，3对应的下一个状态有(1，2，4都是状态3对应的非负状态)，随机地，我们选择1，这样根据算法更新：
这样，Q表为
到达1状态以后，可以直接到达5，这样一次训练也完成了。
这样，我们将上面的解答转换为代码，采用Python编写。
import numpy as np
import random
# 建立 Q 表
q = np.zeros((6, 6))
q = np.matrix(q)
# 建立 R 表
r = np.array([[-1, -1, -1, -1, 0, -1], [-1, -1, -1, 0, -1, 100], [-1, -1, -1, 0, -1, -1], [-1, 0, 0, -1, 0, -1],
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25470ac9a3836b8a9070668e232150c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef4dc623fcae77cfa9f94049cce801c9/" rel="bookmark">
			C语言扩展python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录结构
├── setup.py ├── source │ └── mymodel.c mymodel.c
#define PY_SSIZE_T_CLEAN #include &lt;Python.h&gt; /** * reverse * 实际执行函数 * * @param str * @param size */ void reverse(char *str, int size) { for (int i = 0, j = size-1; i &lt; j ; ++i, --j) { char tmp = str[i]; str[i] = str[j]; str[j] = tmp; } } int add(int a,int b){ return a*b; } /** * 对函数进行封装 * * @param self * @param args * @return */ PyObject * strings_reverse(PyObject *self, PyObject *args) { char *str; // 参数解析 if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef4dc623fcae77cfa9f94049cce801c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8cc9b18e8143fd401a3bdfde9dca381/" rel="bookmark">
			java人民币金额大写_Java人民币金额数字转换成大写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java人民币金额数字转换成大写
import java.text.NumberFormat;
import java.util.HashMap;
public class SimpleMoneyFormat {
public static final String EMPTY = "";
public static final String ZERO = "零";
public static final String ONE = "壹";
public static final String TWO = "贰";
public static final String THREE = "叁";
public static final String FOUR = "肆";
public static final String FIVE = "伍";
public static final String SIX = "陆";
public static final String SEVEN = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8cc9b18e8143fd401a3bdfde9dca381/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80add24a3b30233d30a36efcf9d6f21e/" rel="bookmark">
			scriptengine java_Java用ScriptEngine解析脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实习第一期的任务基本做完，从python和django的世界又回到了Java，当初来刚来百度的时候怎么也没想到居然还会用上Java。新的任务也很简单，不过正好学习了Java一个新的script包，可以用来解析脚本语法。
javax.script，始于JDK1.6，不过现在只有sun实现的javascript的解析器，难道是因为主要用来解析js语法所以归类到JEE的范畴？不过基本足够了，一般的用途主要是能解析通用的表达式就好，比如X &gt;= 1(X作为参数传入)这样的表达式，也能利用js的函数语法，创造一个就像java的函数一样存在于内存中随时可以被调用的函数，更可以将js中的对象直接转换成java对象。
script包下最主要的是ScriptEngineManager、ScriptEngine、CompiledScript和Bindings 4个类或接口。
ScriptEngineManager是一个工厂的集合，可以通过name或tag的方式获取某个脚本的工厂并生成一个此脚本的ScriptEngine，目前只有javascript的工厂。通过工厂函数得到了ScriptEngine之后，就可以用这个对象来解析脚本字符串了，直接调用Object obj = ScriptEngine.eval(String script)即可，返回的obj为表达式的值，比如true、false或int值。
CompiledScript可以将ScriptEngine解析一段脚本的结果存起来，方便多次调用。只要将ScriptEngine用Compilable接口强制转换后，调用compile(String script)就返回了一个CompiledScript对象，要用的时候每次调用一下CompiledScript.eval()即可，一般适合用于js函数的使用。
Bindings的概念算稍微复杂点，我的理解Bindings是用来存放数据的容器。它有3个层级，为Global级、Engine级和Local级，前2者通过ScriptEngine.getBindings()获得，是唯一的对象，而Local Binding由ScriptEngine.createBindings()获得，很好理解，每次都产生一个新的。Global对应到工厂，Engine对应到ScriptEngine，向这2者里面加入任何数据或者编译后的脚本执行对象，在每一份新生成的Local Binding里面都会存在。
给个代码的例子，其中的functionScript可以从标准输入stdin或者配置文件等地方获得，这样就可以动态的控制Java代码的运行结果
try {
ScriptEngine engine = new ScriptEngineManager().getEngineByName("javascript");
Compilable compilable = (Compilable) engine;
Bindings bindings = engine.createBindings(); //Local级别的Binding
String script = "function add(op1,op2){return op1+op2} add(a, b)"; //定义函数并调用
CompiledScript JSFunction = compilable.compile(script); //解析编译脚本函数
bindings.put("a", 1);bindings.put("b", 2); //通过Bindings加入参数
Object result = JSFunction.eval(bindings);
System.out.println(result); //调用缓存着的脚本函数对象，Bindings作为参数容器传入
}
catch (ScriptException e) {}
另外还有一个ScriptContext的概念，这个可能很少用到吧，它是用来连接ScriptEngine和Bindings的工具。按照JDK的解释：该接口的实现类被用来连接ScriptEngine和宿主应用程序中的对象(如有范围的Bindings)。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25b26fdfd8014884e0d253ac5eb93519/" rel="bookmark">
			UGUI笔记（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		两种特殊模式：在Inspector的菜单中存在的两种模式：
Normal：显示资源或组件的自定义编辑器。
Debug：显示组件属性详细参数，不显示自定义编辑器，显示私有变量只是不能像公共变量一样更改。
（lock小锁图标可以实现两种以上组件属性的显示）
Canvas：画布，摆放所有UI元素的区域，在创建控件时会自动添加（所有的UI必须放在Canvas下才能正常显示）。
RectTransform:
Panel：面板，可以控制UI元素大小，移动UI。
Pivot：轴心点，利用轴心点方便针对于某一具体位置对齐。
Anchor：锚点，物体针对于父物体的对齐方式，对应点距离不变。
蓝图模式和原始编辑模式
蓝图模式：第一个虚线按钮，启用时无论怎么调节我们的Rotation和Scale，蓝色点内区域不会改变。
**原始编辑模式：**第二个R按钮，启用时改变锚点或者轴心点会导致控件内image缩放自动适配。
3 种渲染模式（ Render Mode）：Screen Space-Overlay、Screen Space-Camera 和 World Space。
Screen Space-Overlay模式：此模式下所有UI会自动显示在最上层。
Screen Space-Camera 模式：需要具体的相机与Canvas连接，画布被放在该摄像机指定位置前。Plane Distance用来调节。
World SpaceUI此时相当于一个3D对象。
画布缩放器 (Canvas Scaler)：
UI Scale Mode：
Constant Pixel Size：
可在屏幕上按照像素指定 UI 元素的位置和大小
Reference Pixels Per Unit：和图片属性中Pixels Per Unit相作用，影响像素。（做适配）
Scale With Screen Size：
匹配模式1、Match Width or Height
根据屏幕进行适配， Screen Match Mode可以控制当宽高比不适应设置好的分辨率时以宽和高的参考权重（ Match，通常设置为0.5）。
2、Expand和 Shrink
不会小于（大于）宽高比的参数。
Constant Physical Size：
根据物理单位控制UI的位置和大小。DPI :每英寸点数。
Block Raycasts：组件是否作为射线投射的碰撞体。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25b26fdfd8014884e0d253ac5eb93519/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65682c508d97676e8b9016b307ef6c46/" rel="bookmark">
			python类定义学生_B035 修改学生类型结构体 ★
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		所属年份：2011.3
程序通过定义学生结构体变量，存储学生的学号、姓名和3门课的成绩。函数fun的功能是：将形参a中的数据进行修改，把修改后的数据作为函数值返回主函数进行输出。
例如，若传给形参a的数据中学号、姓名和三门课的成绩依次是：10001、”ZhangSan”、95、80、88，修改后的数据应为：10002、”LiSi”、96、81、89。
请在下画线处填入正确的内容并将下画线删除，使程序得出正确的结果。
#include #include struct student {
long sno;
char name[10];
float score[3];
};
/**********found**********/
__1__ fun(struct student a)
{ int i;
a.sno = 10002;
/**********found**********/
strcpy(__2__, "LiSi");
/**********found**********/
for (i=0; i&lt;3; i++) __3__+= 1;
return a;
}
main()
{ struct student s={10001,"ZhangSan", 95, 80, 88}, t;
int i;
printf("\n\nThe original data :\n");
printf("\nNo: %ld Name: %s\nScores: ",s.sno, s.name);
for (i=0; i&lt;3; i++) printf("%6.2f ", s.score[i]);
printf("\n");
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65682c508d97676e8b9016b307ef6c46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25015ce65f27a601ee69cdfe444493ae/" rel="bookmark">
			java countdownlatch_并发工具类（一）等待多线程完成的CountDownLatch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介
CountDownLatch 允许一个或多个线程等待其他线程完成操作。
应用场景
假如有这样一个需求，当我们需要解析一个Excel里多个sheet的数据时，可以考虑使用多线程，每个线程解析一个sheet里的数据，等到所有的sheet都解析完之后，程序需要提示解析完成。在这个需求中，要实现主线程等待所有线程完成sheet的解析操作，最简单的做法是使用join。代码如下：
public class JoinCountDownLatchTest {
public static void main(String[] args) throws InterruptedException {
Thread parser1 = new Thread(new Runnable() {
@Override
public void run() {
}
});
Thread parser2 = new Thread(new Runnable() {
@Override
public void run() {
System.out.println("parser2 finish");
}
});
parser1.start();
parser2.start();
parser1.join();
parser2.join();
System.out.println("all parser finish");
}
}
join用于让当前执行线程等待join线程执行结束。其实现原理是不停检查join线程是否存活，如果join线程存活则让当前线程永远wait，代码片段如下，wait(0)表示永远等待下去。
while (isAlive()) {
wait(0);
}
直到join线程中止后，线程的this.notifyAll会被调用，调用notifyAll是在JVM里实现的，所以JDK里看不到，有兴趣的同学可以看看JVM源码。JDK不推荐在线程实例上使用wait，notify和notifyAll方法。
而在JDK1.5之后的并发包中提供的CountDownLatch也可以实现join的这个功能，并且比join的功能更多。
public class CountDownLatchTest { static CountDownLatch c = new CountDownLatch(2);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25015ce65f27a601ee69cdfe444493ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc4520e4c2d999b68313f9a491c52041/" rel="bookmark">
			zerotier设置教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，打开Zerotier，然后输入ID
二，到Zerotier网站，启用这个
三，Openwrt 新建网络接口，名称zerotier，协议为静态地址，以太网适配器“zt××××”（可不用）
四，分配防火墙区域为lan（可不用）
五，更改防火墙规则
iptables -I FORWARD -i zt3jnyhgxl -j ACCEPT
iptables -I FORWARD -o zt3jnyhgxl -j ACCEPT
iptables -t nat -I POSTROUTING -o zt3jnyhgxl -j MASQUERADE
六，网络接口设置：IP4地址填入，子网掩码255.255.255.0
七，重启防火墙
八，回到zerotier网站，填入自己的ip：192.168.1.4/24，分配的Ip：192.168.196.*
九，到https://install.zerotier.com下载文件，改名“zerotier”, chmod 775 zerotier, ./zerotier,
十，Sudo zerotier-cli join 自己的ID
zerotier通过moon中转设置方法 https://www.youtube.com/watch?v=OzKBXBwBrUQ&amp;t=218s
1、
curl -s https://install.zerotier.com/ | sudo bash
2、
zerotier-cli join 网络ID
3、
cd /var/lib/zerotier-one
sudo zerotier-idtool initmoon identity.public &gt; moon.json
4、修改配置文件moon.json
“stableEndpoints”: [ “自己的公网IP/9993” ]
5、
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc4520e4c2d999b68313f9a491c52041/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a826d24809ea20ec9643632fc3f950d9/" rel="bookmark">
			Ubuntu20.04 关于搜狗输入法无法安装的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.介绍一下情况 本人小白，刚开始折腾Linux没几天，下载的Ubuntu20.04版本。 一直看网上的教程来的，先谢谢各位巨人。
记录一下重点，方便以后使用。
2.先官网下载搜狗输入法.deb安装包 [官网下载Linux版本](https://pinyin.sogou.com/linux/?r=pinyin) 3.软件安装[.deb]文件： cd 进入安装包所在目录 ` sudo dpkg -i 安装包.deb ` 安装失败。提示缺少相关依赖。
4.输入以下命令查询核对系统依赖关系完整性 sudo apt-get check 5.会提示缺少哪些依赖，并且有提示输入哪些代码进行安装 按装成后就可以使用搜狗输入法了。（当时没有截图，没记住代码，惭愧）
PS：以上操作纯属误打误撞。
——————第一次发博，写的不好见谅
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78c3e7ad6e663f20e8cadb09e2ba06a6/" rel="bookmark">
			TVM代码学习 -- 代码生成流程（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要介绍TVM针对不同后端部署平台生成运行代码的流程，TVM可以通过两种方式生成代码：tvm.build 和 relay.build。两种方式流程略有不同，tvm.build 主要针对单一算子进行编译优化，relay.build 是针对整个网络计算图进行编译优化。先介绍relay.build，示例代码如下所示。
relay.build
onnx_model = onnx.load('model/mobilenetv2.onnx') mod,params = relay.frontend.from_onnx(onnx_model,shape_dict) dtype = 'float32' with relay.build_config(opt_level=0): graph, lib, params = relay.build_module.build(mod, target, params=params) 对relay.build进行代码跟踪，首先进入tvm/python/tvm/relay/build_module.py（这里是因为在relay/init.py中将build函数直接import到relay的命名空间，因此跳过了build_module这一层），其中的build函数是build_module内的全局函数)。
def build(mod, target=None, target_host=None, params=None, mod_name='default'): // ignore some code..... # If current dispatch context is fallback context (the default root context), # then load pre-tuned parameters from TopHub if isinstance(autotvm.DispatchContext.current, autotvm.FallbackContext): tophub_context = autotvm.tophub.context(list(target.values())) else: tophub_context = autotvm.util.EmptyContext() with tophub_context: bld_mod = BuildModule() graph_json, mod, params = bld_mod.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78c3e7ad6e663f20e8cadb09e2ba06a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6eb69a2df660b96e808c700c292587f2/" rel="bookmark">
			Ubuntu:使用cd命令后直接自动ls
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 修改～/.bashrc
vim ~/.bashrc 然后在里面加入下面的代码
cdls() { cd "${1}"; ls; } alias cd='cdls' 保存退出后
source ~/.bashrc 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c1fc75282eb3a9df99f6a9c0e7b9377/" rel="bookmark">
			颠倒二进制位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、需求 颠倒给定的 32 位无符号整数的二进制位。 示例 1：
输入: 00000010100101000001111010011100
输出: 00111001011110000010100101000000
解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
示例 2：
输入：11111111111111111111111111111101
输出：10111111111111111111111111111111
解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。
二、位运算 2.1 思路分析
输入 n 是无符号整数的二进制形式，那么可以通过 n &amp; 1运算从低位到高位获取每一位；定义变量从低位到高位保存每一位，这样便实现了逆序； 2.2 代码实现
public class Solution { // you need treat n as an unsigned value public int reverseBits(int n) { int res = 0; for(int i = 0; i &lt; 32; i++) { res = res &lt;&lt; 1; res = res | n &amp; 1; n = n &gt;&gt; 1; } return res; } } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c1fc75282eb3a9df99f6a9c0e7b9377/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1778056975c171dcf600e04d8503ddd1/" rel="bookmark">
			php java 结合_php能结合java开发吗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		php能结合java开发吗
发布时间：2020-07-03 11:56:28
来源：亿速云
阅读：71
作者：Leah
php能结合java开发吗？针对这个问题，这篇文章详细介绍了相对应的分析和解答，希望可以帮助更多想解决这个问题的小伙伴找到更简单易行的方法。
php可以和java一起开发。比如可以做成服务，通过RPC调用，PHP做网关，JAVA做服务。
PHP可以与任何其它语言一起开发。
php简介：
PHP即“超文本预处理器”，是一种通用开源脚本语言。PHP是在服务器端执行的脚本语言，与C语言类似，是常用的网站编程语言。PHP独特的语法混合了C、Java、Perl以及 PHP 自创的语法。利于学习，使用广泛，主要适用于Web开发领域。
java简介：
Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程 。
关于php能结合java开发吗问题的解答就分享到这里了，希望以上内容可以对大家有一定的帮助，如果你还有很多疑惑没有解开，可以关注亿速云行业资讯频道了解更多相关知识。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91bc9a54b92ae65c3a88eb94ff645b7d/" rel="bookmark">
			C&#43;&#43; vector与set互转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 vector转set可以实现去重；set转vector可以方便自己实现排序（对于set貌似自己写的cmp不能用？不清楚 太菜了）
vector&lt;int&gt; v; v = {1,2,2,3,3,4};//建立vector set&lt;int&gt; st(v.begin(), v.end());//在构造函数中可以直接实现vector转set v.assign(st.begin(), st.end());//用assign实现set转vector 短小精悍 嘿嘿 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc5b887c91fe56358b904e71ddde702b/" rel="bookmark">
			java ftp命令_Java实现FTP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意：
Access restriction: The type FtpClient is not accessible due to restriction on required library F:\Program Files\Java\jre6\lib\rt.jar
sun.net包里的内容，在eclipse/myeclipse里默认是不让用的。解决办法是自定义access rules
工程上右键-&gt;工程属性-&gt;java builder path-&gt;Libraries标签，点击JRE System Library里面的Access rules，add sun/** 为accessible，如果该项存在，就edit。然后选择workspace default jre(jdk1.6.0_18)package com.suma.exchange.ftp;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import sun.net.TelnetInputStream;
import sun.net.TelnetOutputStream;
import sun.net.ftp.FtpClient;
/**
* ftp上传，下载
* @author why 2009-07-30
*
*/
public class FtpUtil {
private String ip = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc5b887c91fe56358b904e71ddde702b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06da50c8ca33492ab2b148ef78bdc822/" rel="bookmark">
			3D成像汇总（原理解析）--- 双目视觉、激光三角、结构光、ToF、光场、全息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文转载，方便查阅。原文链接：https://blog.csdn.net/tyfwin/article/details/89110067
目录
简介
1、双目立体视觉法：
2、激光三角法
3、结构光3D成像法
4、飞行时间法ToF
5、光场成像法（Light field of imaging）
6、全息投影技术
7、补充：戳穿假全息
参考资料：
简介 3D成像方法汇总介绍：
这里要介绍的是真正的3D成像，得到物体三维的图形，是立体的图像。
而不是利用人眼视觉差异的特点，错误感知到的假三维信息。
原理上分类：主要常用有：
1、双目立体视觉法(Stereo Vision)
2、激光三角法(Laser triangulation)
3、结构光3D成像(Structured light 3D imaging)
4、飞行时间法ToF（Time of flight）
5、光场成像法（Light field of imaging）
6、全息投影技术(Front-projected holographic display)
上面原理之间可能会有交叉。
而激光雷达不是3D成像原理上的一个分类，而是一种具体方法。
激光雷达的3D成像原理有：三角测距法、飞行时间ToF法等。
激光雷达按照实现方式分类有：机械式、混合固态、基于光学相控阵固态 、基于MEMS式混合固态、基于FLASH式固态等。
1、双目立体视觉法： 就和人的两个眼睛一样，各种两个摄像头的手机大都会用这种方法来获得深度信息，从而得到三维图像。但深度受到两个摄像头之间距离的限制。
视差图：双目立体视觉融合两只眼睛获得的图像并观察它们之间的差别，使我们可以获得明显的深度感，建立特征间的对应关系，将同一空间物理点在不同图像中的映像点对应起来，这个差别，我们称作视差(Disparity)图像。对于视差的理解可以自己体验一下：将手指头放在离眼睛不同距离的位置，并轮换睁、闭左右眼，可以发现手指在不同距离的位置，视觉差也不同，且距离越近，视差越大。
提到视差图，就有深度图，深度图像也叫距离影像，是指将从图像采集器到场景中各点的距离（深度）值作为像素值的图像。
深度图与点云的区别，点云：当一束激光照射到物体表面时，所反射的激光会携带方位、距离等信息。若将激光束按照某种轨迹进行扫描，便会边扫描边记录到反射的激光点信息，由于扫描极为精细，则能够得到大量的激光点，因而就可形成激光点云。深度图像经过坐标转换可以计算为点云数据；有规则及必要信息的点云数据可以反算为深度图像。 两者在一定条件下是可以相互转化的。
双目立体视觉由三角法原理进行三维信息的获取，即由两个摄像机的图像平面和被测物体之间构成一个三角形。已知两个摄像机之间的位置关系和物体在左右图像中的坐标，便可以获得两摄像机公共视场内物体的三维尺寸及空间物体特征点的三维坐标。所以，双目视觉系统一般由两个摄像机构成。
深度和视差成反比。
2、激光三角法 单点激光测距原理：（同属于下面结构光原理）
单点激光测距原理图如下图。
激光头Laser与摄像头在同一水平线（称为基准线）上，其距离为s，摄像头焦距为f，激光头与基准线的夹角为β。激光头Laser与摄像头在同一水平线（称为基准线）上，其距离为s，摄像头焦距为f，激光头与基准线的夹角为β。假设目标物体Object在点状激光器的照射下，反射回摄像头成像平面的位置为点P。假设目标物体Object在点状激光器的照射下，反射回摄像头成像平面的位置为点P。 由几何知识可作相似三角形，激光头、摄像头与目标物体组成的三角形，相似于摄像头、成像点P与辅助点P′。P与辅助点P′。 设 PP′=x，q、d如图所示，则由相似三角形可得：PP′=x，q、d如图所示，则 由相似三角形可得：f/x=q/s ==&gt; q=fs/x X可分为两部分计算：X=x1+x2= f/tanβ + pixelSize* position
其中pixelSize是像素单位大小， position是成像的像素坐标相对于成像中心的位置。
最后，可求得距离d: d=q/sinβ
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06da50c8ca33492ab2b148ef78bdc822/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae19f041f2ffc40f25c56784b8023e52/" rel="bookmark">
			车载双目ADAS（五）：双目视觉技术的原理、组成、应用与挑战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 双目视觉的原理
采用一对相机代替双眼。通过左右图像获取各像素点的视差，然后基于三角测量原理重构三维信息，从而识别障碍物体。与单目视觉相比，双目视觉不依赖庞大的训练集，测距精度较高。
（引自：中科慧眼官网）
注：视差（disparity）是指同一物体在左右图中的横坐标之差。
深度距离和视差成反比，物体距离双目相机越远，视差越小，离相机越近，视差越大。 2.双目视觉系统的组成
图像采集：要求相机绝对的同步，图像画质清晰，高对比度。
双目标定：以标定板为参照系，求得相机的内参（图像中心和畸变系数）和外参数（RT矩阵）。
图像校正：依据相机内外参数对畸变图像进行平行等位校正，获得无畸变且平行等位的左右图像。
双目匹配：对校正后的图像进行匹配，获得视差图像，供后续算法使用。
ADAS功能：根据视差图进行障碍物检测预警和车道线检测。
3.双目视觉技术的应用
3.1航空航天、无人机
华盛顿大学与微软公司合作为火星卫星“探测者”号研制了宽基线立体视觉系统，使“探测者”号能够在火星上对地形进行精确的定位和导航；嫦娥二号搭载的玉兔号也配备双目立体相机，进行避障。
大疆精灵无人机，辅助无人机更快更好地识别周围场景，便于它的飞行与避障，现在配备2对以上的双目相机。主要的原因可能是双目的优势：体积小，功耗小。
3.2工业非接触式检测
高温环境下大型铸件在热处理过程中（上千度）尺寸的测量，对中型或大型尺寸的物体尤其有用。固定工位装配零件的检测，场景简单。（参见大恒公司的部分产品）
3.3手机拍照、三维重建
手机拍照：获得物体的距离信息，虚化背景，可以更好的景深效果。以及一些VR产品都会用到双目视觉技术。
双目立体视觉技术特别适用于3D重构，即确定某任意物体的3D形状。可以用来实现3D物体质量检测，也可用来确定3D物体的位置。（TOF技术，结构光技术更准确）
3.4高级辅助驾驶（ADAS）
说到双目视觉，不得不提斯巴鲁—零式战斗机厂商，其他牛逼企业：日立、富士重工、理光、博世、大陆等。这家日本汽车厂商1989年开始对立体摄像头（即双目摄像头）技术进行研究，并于1999年把该技术应用到量产车的ADA系统之上。2008年5月，搭载第一代EyeSight系统的力狮正式上市。目前，该系统的装车量已经超过了100万辆。2017年3月，欧洲安全评鉴协会发布了新一系列包扩奥迪、丰田、路虎等在内的车型的碰撞测试结果，其中路虎的发现车型获得了五星。获得五星的路虎车型，搭载的主动安全系统中，前向采用了双目摄像头的方案，而这个方案也成为了它能脱颖而出的关键。
4.车载双目ADAS的挑战
挑战很多，各个环节环环相扣，呈现在图像上总表现为场景点在左右图像中并非总是一致的。图像是唯一数据来源，准确率∝光线强弱。
实时性：算法复杂度、存储空间的需求 。
成本： 硬件逻辑资源的消耗 。
结构：高精度装配工艺，环境温度等外力影响下，左右镜头位置不能发生较大相对位移。
算法：遮挡、弱纹理和重复纹理区域、深度不连续区域难以获取高精度和高鲁棒的视差信息，自动标定算法不成熟。
相机画质： 相机的噪声，增益，不同对比度等 。
环境光线： 左右镜头的光照不同，环境光照过强过弱，不均匀等。
（来自mobileye 产品说明书）
以上内容如有错误或者偏差，请您直接指出，我会立即纠正。（掐腰大笑）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9667730074a3f9b439f07ea3bebf803f/" rel="bookmark">
			JQuery将字符串转为json对象的四种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JQuery将字符串转为json对象的四种方法：
第一种：用jquery里自带的$.parseJSON函数：
&lt;script language="javascript"&gt; var jsonstr1="{\"id\":\"1\",\"name\":\"John\"}"; var obj=$.parseJSON(jsonstr1); alter(obj.id); &lt;/script&gt; ***用$.parseJSON来把字符串转换为json对象，对字符串要求极高，字符串里的属性全部用双引号来包裹，并且不能用单引号。
第二种：js里的方法，用eval把字符串转换为json：
&lt;script language="javascript"&gt; //这三种写法都可以用eval来转换 var jsonstr1="{\"id\":\"1\",\"name\":\"John\"}"; var jsonstr1={'id':'1','name':'John'}; var jsonstr1={id:1,name:'John'}; var obj=eval('('+jsonstr1+')'); alert(obj.id); &lt;/script&gt; ***在用eval把字符串转为json时，需要在字符串外包裹一对小括号；
第三种：使用浏览器自带的JSON.parse：
&lt;script language="javascript"&gt; var jsonstr1="{\"id\":\"1\",\"name\":\"John\"}"; var obj=JSON.parse(jsonstr1) alert(obj.id); &lt;/script&gt; ***Firefox，chrome，opera等浏览器都支持JSON.parse，但IE6、IE7不支持，并且对要转换的字符串要求也比较高。
第四种：JSON官方提供的方法：
www.json.org 提供了一个json.js，可以用parse()方法来把字符串转换为json，用stringify()来把json转换为字符串；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ed7277b61401249a54548d738376091/" rel="bookmark">
			python下雪的实例_javascript实现下雪效果【实例代码】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原理 :
1、js动态创建DIV,指定CLASS类设置不同的背景图样式显示不同的雪花效果。
2、js获取创建的DIV并改变其top属性值，当下落的高度大于屏幕高后删除该移动div
3、好像不够完善勿喷
HTML代码：
雪花飞舞 CSS代码
*{
margin:0;
padding:0;
list-style: none;
border: none;
}
body{
width: 100%;
height:600px;
background:#000;
}
.snow_parent{
position: relative;
width: 100%;
height:100%;
overflow: hidden;
margin: 0 auto;
}
.snow_parent div.parent{
background-image: url(../img/snow.png);
float: left;
-webkit-transform: scale(.1);
-moz-transform: scale(.1);
-o-transform: scale(.1);
-ms-transform: scale(.1);
transform: scale(.1);
position: absolute;
}
.snow_one{
width: 180px;
height: 180px;
background-position:0 0;
background-repeat: no-repeat;
left:-70px;
top: -95px;
}
.snow_two{
width: 140px;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ed7277b61401249a54548d738376091/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ae82e29b7a83594012ae708d684a9d2/" rel="bookmark">
			MCDF实验——Lab5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Lab5主要完成如何定义覆盖率，如何从验证计划到测试用例的实现，最后再到覆盖率的量化。验证量化分为代码覆盖率和功能覆盖率。
一、编译 在编译过程中，需要对于设计相关的文件设置额外的覆盖率编译选项。
只选中与设计相关的文件点击右键，选择compile-&gt;compile properties，在弹出设置栏的coverage一栏中，如图选择以下选项，然后点击OK。
完成所有文件的编译“Compile All”。这一步将在编译DUT文件时生成代码覆盖率的模型。 二、仿真 在仿真窗口(transcript)中，执行仿真命令
vsim -i -classdebug -solvefaildebug -coverage -coverstore D:/questasim64_10.6c/Project/lab5/lab5 -testname mcdf_full_random_test -sv_seed random +TESTNAME=mcdf_full_random_test -l mcdf_full_random_test.log work.tb -coverage：会在仿真时产生代码覆盖率数据，功能覆盖率数据则默认会生成，与此选项无关。-coverstore COVERAGE_STORAGE_PATH：这个命令是用来在仿真在最后结束时，生成覆盖率数据并且存储到COVERAGE_STORAGE_PATH。-testname TESTNAME：这个选项是你需要添加本次仿真的test名称，可以使用同+TESTNAME选项一样的test名称。这样在仿真结束后，将在COVERAGE_STORAGE_PATH下产生一个覆盖率数据文件“{TESTNAME}_{SV_SEED}.data”。由于仿真时传入的种子是随机值，因此每次提交测试，在测试结束后都将产生一个独一无二的覆盖率数据。 执行run -all，等待跑完仿真
执行quit -sim命令之后，可以发现文件下中多了一个data文件
仿真结束以后，可以查看代码覆盖率
还可以查看本次仿真所收集到的功能覆盖率
三、合并覆盖率 运行不同的仿真，或者运行同一个test，都会生成独一无二的数据库，可以将生成的.data覆盖率数据文件做合并。
执行如下命令
vcover merge -out merged_coverage.ucdb D:/questasim64_10.6c/Project/lab5/lab5 可以打开合并后的UCDB覆盖率数据库，打开这个数据库之后，会发现合并后的数据库要比之前单独提交的任何一次测试在仿真结束时的该次覆盖率都要高。
四、分析覆盖率 可以选择Tools-&gt;Coverage Report-&gt;HTML生成报告
通过分析覆盖率，需要修改约束或者创建新的测试最终来达到验证完备性的要求。
五、覆盖率代码分析 相比于Lab4，Lab5在mcdf_pkg.sv新添加了一个组件mcdf_coverage
class mcdf_coverage; local virtual chnl_intf chnl_vifs[3]; local virtual arb_intf arb_vif; local virtual mcdf_intf mcdf_vif; local virtual reg_intf reg_vif; local virtual fmt_intf fmt_vif; local string name; local int delay_req_to_grant; covergroup cg_mcdf_reg_write_read; addr: coverpoint reg_vif.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ae82e29b7a83594012ae708d684a9d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0c78227c4ced7851a4d63917221a86e/" rel="bookmark">
			早高峰共享单车潮汐点的群智优化Baseline
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考自：coogle数据科学 https://coggle.club/learn/dcic2021/
一、赛题说明 2021数字中国创新大赛大数据赛道-城市管理大数据专题
二、数据读取与理解 共享单车轨迹数据 共享单车轨迹数据为共享单车在使用时候产生的位置定位数据，具体包含单车在不同时间段（默认是15秒记录一次）下的经纬度信息。
读取数据：读取单车轨迹数据： import os, codecs import pandas as pd import numpy as np PATH = '../dataset/' # 共享单车轨迹数据 bike_track = pd.concat([ pd.read_csv(PATH + 'gxdc_gj20201221.csv'), pd.read_csv(PATH + 'gxdc_gj20201222.csv'), pd.read_csv(PATH + 'gxdc_gj20201223.csv'), pd.read_csv(PATH + 'gxdc_gj20201224.csv'), pd.read_csv(PATH + 'gxdc_gj20201225.csv') ]) # 按照单车ID和时间进行排序 bike_track = bike_track.sort_values(['BICYCLE_ID', 'LOCATING_TIME']) 路线可视化 import folium m = folium.Map(location=[24.482426, 118.157606], zoom_start=12) my_PolyLine=folium.PolyLine(locations=bike_track[bike_track['BICYCLE_ID'] == '000152773681a23a7f2d9af8e8902703'][['LATITUDE', 'LONGITUDE']].values,weight=5) m.add_children(my_PolyLine) 共享单车停车点位（电子围栏）数据 共享单车停车点位（电子围栏）数据为规范共享单车停车秩序，统一划定的共享单车停放区域。
读取数据 def bike_fence_format(s): s = s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0c78227c4ced7851a4d63917221a86e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b89cb63c385d7b75e8911a167fb0628f/" rel="bookmark">
			找不到java虚拟机_找不到Java虚拟机(JVM)库，要更正此问题，请先检查java运行时环境是否已正确安装。...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，检查你是否有安装与当前NX版本匹配的JAVA版本，如果没有请安装。可以在控制面板程序里查看，如果有更新版或者更旧版，可以先卸载再安装。注意JAVA有32位和64位之分，安装的时候，不要修改其路径，直接默认安装就好了。
其次，这个问题可以确认是JAVA没有与NX软件正常匹配的原因，大部分电脑，一般只要安装匹配的JAVA版本就可以了，但是有少部分版本需要额外添加环境变量。
第一种方法：
环境变量一般有两个，你可以一个一个添加测试是否有效。
变量名：
UGII_JAVA_HOME
变量值：
你的当前JAVA程序所在路径，比如我的：
C:\Program Files\Java\jre1.8.0_172
另外一个环境：
变量名：
UGII_JVM_LIBRARY_DIR
变量值，和上面的一样。
这样添加好以后，再进行重新打开NX软件测试，如果还是不行，请按以下方法。
第二种方法：
看警告图片提示上的修改ugii_env文件来测试，修改这个文件其实和添加环境变量一个意思。不同的NX版本可能修改文件存在差异，一般都是UGII目录下的ugii_env.dat或者ugii_env_ug.dat文件。
这个文件的路径在(这是我的路径)：
C:\Program Files\Siemens\NX 12.0\UGII\ugii_env.dat
或者：
C:\Program Files\Siemens\NX 12.0\UGII\ugii_env_ug.dat
在最后一行，加上你的环境变量以及变量值，例如：
UGII_JAVA_HOME=C:\Program Files\Java\jre1.8.0_172
一般建议直接添加系统环境变量，省得修改文件弄糊涂了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e586830eb2ad2659d77477db6db98887/" rel="bookmark">
			java 迭代器_Java中 ( Iterator ) 迭代器 详解 ( JDK8源码 )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java集合框架的集合类，我们有时候称之为容器。容器的种类有很多种，比如ArrayList、LinkedList、HashSet...，每种容器都有自己的特点，ArrayList底层维护的是一个数组；LinkedList是链表结构的；HashSet依赖的是哈希表，每种容器都有自己特有的数据结构。
因为容器的内部结构不同，很多时候可能不知道该怎样去遍历一个容器中的元素。所以为了使对容器内元素的操作更为简单，Java引入了迭代器模式！
那什么是迭代器呢？
迭代器(Iterator)是一个对象，它的工作就是遍历并选择序列中的对象，它提供了一种访问容器(container)对象中的各个元素，而又不必暴露该对象内部细节的方法。
迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构 ( 迭代器把访问逻辑从不同类型的集合类中抽取出来，从而避免向外部暴露集合的内部结构)。
迭代器通常被称为“轻量级”对象，因为创建它的代价小。
Java中的Iterator功能比较简单，并且只能单向移动：
(1) 使用方法iterator()要求容器返回一个Iterator。第一次调用Iterator的next()方法时，它返回序列的第一个元素。注意：iterator()方法是java.lang.Iterable接口,被Collection继承。
(2) 使用next()获得序列中的下一个元素。
(3) 使用hasNext()检查序列中是否还有元素。
(4) 使用remove()将迭代器新返回的元素删除。
只要看看下面这个例子就一清二楚了：
import java.util.*;
public class Muster {
public static void main(String[] args) {
ArrayList list = new ArrayList();
list.add("a");
list.add("b");
list.add("c");
Iterator it = list.iterator();
while(it.hasNext()){
String str = (String) it.next();
System.out.println(str);
}
}
}
结果
a
b
c
可以看到，Iterator可以不用管底层数据具体是怎样存储的，都能够通过next()遍历整个List。
为啥要用Iterator?
若不使用迭代器, 访问代码和集合本身是紧密耦合的，因此无法将访问逻辑从集合类和客户端代码中分离出来。而由于不同的集合会对应不同的遍历方法，所以客户端代码无法复用。在实际应用中如何将上面两个集合整合是相当麻烦的。
而对于Iterator来说，它总是用同一种逻辑来遍历集合，使得客户端自身不需要维护集合的内部结构，所有的内部状态都由Iterator来维护。也就是说，客户端不用直接和集合进行打交道，而是控制Iterator向它发送向前向后的指令，就可以遍历集合。
实现原理
但是，具体是怎么实现的呢？背后机制究竟如何呢？
所有Iterator都最终实现接口Iterator，Iterator接口中包含三个基本方法，next(), hasNext(), remove()，其中对于List的遍历删除只能用Iterator的remove方法；
JDK1.8中java.util.Iterator接口的源码如下：
public interface Iterator {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e586830eb2ad2659d77477db6db98887/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c051a01abb6de67d54165a71c3ff601f/" rel="bookmark">
			K8s 滚动更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Deployment特性
事件和状态查看保存更新版本记录，支持回滚到指定版本可以实现多种自动更新方案暂停和启动，支持每次升级必要的暂停，以便是否继续以下的更新 说白就是基于Pod的滚动更新高级支持，特性都是针对更新而言
Deployment更新
更新的是Pod模板下的内容，比如镜像文件，标签、存储等等，而怎么更新就由Deployment控制器完成
更新策略：滚动更新和重新创建更新和回滚方式：yaml文件和命令行暂停更新方案：符合现实使用的更新方案 更新策略
滚动更新（默认）：新旧版本交替更新，好处就是可以实现理论上的无中断更新重新创建：旧版本全部删除，根据模板重新创建Pod，坏处是业务会出现中断 Deployment更新操作还是要基于replicaset控制器，但是更新过程是要基于2个控制器进行替换，旧版本减少，新版本就增加
滚动更新的2个字段说明
需要确保可用Pod数，以保证客户端能正常请求服务，而这个范围数由2个字段控制 maxSurge：更新中最高可以超出的副本总数(包含新旧副本)，可以以数值或者百分比，假如定义的是3副本，maxSurge=1,3+1=4maxUnavailable：更新中可用的副本数(包含新旧副本)，可以以数值或者百分比，假如定义的是3副本，maxUnavailable=1,3-1=2 maxSurge和maxUnavailable默认为25%
maxSurge和maxUnavailbale可以为0，但是不能同时为0
查看depolyment默认的更新信息
隐含的意思其实就是每次以四分之一进行更新交替新旧版本，这个最小化的实现平滑过度更新
更新方式
命令行更新Pod模本信息
kubectl set ：可以直接写成赋值的方式替换内容，常见的有image，只支持部分内容 kubectl set image deployment/nginx nginx=nginx:1.19.7 最后nginx=nginx:1.19.7，代表的是镜像名=替换的镜像 kubectl patch ：以json格式替换内容 kubectl patch deployment nginx --patch={“spec”: {“template”: {“spec”: {“containers”: [{“name”: “nginx”,“image”: “nginx:1.19.6”}]}}}} yaml格式转成json格式：点击访问
yaml文件更新
kubectl apply -f nginx-deploymnet.yaml --record record是可以记录历史版本的执行命令
查看历史版本，首次为版本1， CHANGE-CAUSE就是加上record结果，方便查看更新的信息
kubectl rollout history deployment nginx spec.revisionHistoryLimit：历史版本记录，默认记录5个历史记录，多的会被覆盖
kubectl rollout status deployment/nginx --revision=2 #查看更新状态 回滚方式
kubectl rollout undo deployment nginx --to-revision=2 REVISION发生了改变，原本的2回滚后变成4，累计追加修订版本号
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c051a01abb6de67d54165a71c3ff601f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0425ed3640bff2442d1031516abe2852/" rel="bookmark">
			解决‘parent.relativePath‘ of POM xxx points at instead of please verify your project structure
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在如下位置加入&lt;relativePath/&gt; relativePath:
1)指定查找该父项目pom.xml的(相对)路径。默认顺序：relativePath &gt; 本地仓库 &gt; 远程仓库
2)没有relativePath标签等同…/pom.xml, 即默认从当前pom文件的上一级目录找
3)表示不从relativePath找, 直接从本地仓库找,找不到再从远程仓库找
关于2）经过测试，似乎 没有relativePath标签时，它没有从当前pom文件的上一级目录找，子模块继承不到父模块中dependencyManagement中包的version信息。
因此，强烈推荐，子模块配置relativePath元素，指定 …/pom.xml。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c804c353cd88f4a72adc2be084e58674/" rel="bookmark">
			keil 5字体设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、编译器字体设置 二、关键字颜色设置 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77953ef39db60a4f2b0f6ce3ae6e3ca6/" rel="bookmark">
			java内存分为几个部分_jvm的内存结构主要包含哪几个部分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jvm的内存结构主要包含哪几个部分
发布时间：2020-06-04 14:24:33
来源：亿速云
阅读：196
作者：Leah
jvm的内存结构主要包含哪几个部分？针对这个问题，今天小编总结这篇有关内存结构的文章，希望能帮助更多想解决这个问题的朋友找到更加简单易行的办法。
jvm内存分为五大块：
标灰的是线程公有的内存区域，没有标灰的是线程私有
一：程序计数器：程序计数器是用来指示当前线程要执行哪条指令，并且在执行完该条指令后让程序计数器指向下一条指令，直到将程序执行完毕。指令需要靠cpu来执行，在多线程中，多个线程是通过轮流切换分配cpu的时间片而执行的，在切换时需要记录当前执行到了哪条指令以便将来继续执行，每一个线程都需要有自己的程序计数器，所以程序计数器是线程私有的内存。
二：虚拟机栈：通常我们把jvm的内存粗略的分为堆和栈，其中的栈指的就是虚拟机栈,虚拟机栈也是线程私有的。
虚拟机栈对应的是方法的内存区域，每个方法执行时都会创建一个栈帧，用来存储该方法的局部变量表，操作数栈，动态链接，方法返回地址：
1.局部变量表：局部变量表中存储的是方法的参数和方法中定义的局部变量，在编译期间就为局部变量表分配好了内存空间。局部变量表中存储三种类型的数据：
(1) 基本数据类型
(2) 引用类型：指向一个对象在内存中的地址
(3) returnAddress类型：指向指令的地址(已经很少见了，指向异常处理的指令，现在已经由异常表代替)
2.操作数栈：当虚拟机执行一些指令的时候会对操作数栈进行入栈或出栈的操作，比如iadd指令将两个数相加，会先将操作数栈中的两个数弹出来(出栈)，相加后再压入栈(入栈)中。
3.动态链接：在运行时常量池中存储了诸如类名，方法名，我们要找到目标类，执行相应的方法就需要用到动态链接，栈帧中有一个指向运行时常量池的引用，通过这个引用可以找到相应的类名和方法名，但是光知道名称是没法执行方法的，需要通过名称找到相应的类和方法在内存中的地址，这个过程就是动态链接。
4.方法返回地址：当方法执行完以后如果有返回值，就会把这个返回值返回给该方法的调用者，方法的返回就是我们java中用到的return命令。方法返回之后调用者需要继续往下执行就需要知道要执行的地址，该地址就是方法返回地址，它被记录在了栈帧中，当然在发生异常的情况下不会有返回值，要继续执行的地址可以通过异常处理器表来确定。
虚拟机栈可能出现两种类型的异常：
1.线程请求的栈深度大于虚拟机允许的栈深度会抛出StackOverflowError,(虚拟机栈空间不能动态扩展的情况下)
2.如果虚拟机栈空间可以动态扩展(目前多数的虚拟机都可以)，当动态扩展无法申请到足够的空间时会抛出OutOfMemory异常。
三：本地方法栈：本地方法栈与虚拟机栈的作用是一样的，区别在于虚拟机栈为虚拟机执行java方法服务，而本地方法栈为虚拟机执行native方法服务，native方法为本地方法，不是用java语言写的有可能是c或者c++写的，在jdk中就有很多c的代码，就是提供给本地方法来调用的。
四:堆：通常我们把jvm的内存粗略的分为堆和栈，其中的堆就是指它，它是虚拟机中占用内存最大的一块，是被所有线程共享的一块区域，它是用来存放对象实例的。是垃圾收集器管理的主要区域。
五：方法区：方法区也是被所有线程共享的一块区域，它存储的是类信息，常量，静态变量，编译后的字节码等信息。方法区中还有一块区域“运行时常量池“：运行时常量池中存储的是编译期生成的各种字面量和符号引用。字面量相当于Java里常量的概念，比如字符串，声明为final的常量值等，符号引用包括了：类和接口名，字段名，方法名。
看完上述内容，你们对jvm的内存结构有进一步的了解吗？如果还想学到更多技能或想了解更多相关内容，欢迎关注亿速云行业资讯频道，感谢各位的阅读。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c13593b1819c44f4ef30f67959733a2/" rel="bookmark">
			pve远程连接 spcie_pve实现云桌面的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建虚拟机
虚拟机编号从100开始，可以规划为编号、ip、端口一致
使用客户端连接spice
关闭虚拟机
在web界面中把虚拟机的“硬件”-“显示”设置回原来的“默认”。
编辑虚拟机的配置文件
nano /etc/pve/qemu-server/XXX.conf
加入
args: -device AC97,addr=0x18 -spice ‘port=6101,disable-ticketing,seamless-migration=on’
其中，-device选项是配置声卡，来自官方wiki。-spice选项是配置SPICE，这里绑定地址默认是0.0.0.0，所以不用设置。而port选项是设置SPICE的监听端口，这个端口应该是6000以上，5000都不行，后面在client中填写端口跟这里一致即可。disable-ticketing是关闭认证，这样子就可以不输入账号密码直接连上。seamless-migration这个选项不知道干什么用的。
可以直接这样写：
echo “args: -spice ‘port=6101,disable-ticketing,seamless-migration=on’
” &gt;&gt; /etc/pve/qemu-server/***.conf
virtviewer中输入
spice://172.21.105.108:6101
或终端输入:
remote-viewer -f spice://86.200.1.3:6102
要想开机直接连上云桌面，可以在/home/.profile中加入：
remote-viewer -f spice://86.200.1.3:6102
我在用lubuntu时，这样加云桌面会启动的太早，比窗口管理器还早，导致有问题。可以建一个脚本文件boot.sh，写入：
sleep 5
remote-viewer-fspice://86.200.1.3:6102
然后在/home/.profile中加入：boot.sh &amp;
windows下网页打开控制台，输密码时总提示大写锁定，密码错误，linux下正常。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ca002f6d3201115e0ca90579dc6dbc1/" rel="bookmark">
			java多重注解_Java 8新特性探究（五）重复注解（repeating annotations）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		知识回顾
前面介绍了：
lambda表达式和默认方法 (JEP 126)
批量数据操作(JEP 107)
类型注解(JEP 104)
注：JEP=JDK Enhancement-Proposal (JDK 增强建议 )，每个JEP即一个新特性。
在java 8里面，注解一共有2个改进，一个是类型注解，在上篇已经介绍了，本篇将介绍另外一个注解的改进：重复注解(JEP 120)。
什么是重复注解
允许在同一申明类型(类，属性，或方法)的多次使用同一个注解
一个简单的例子
java 8之前也有重复使用注解的解决方案，但可读性不是很好，比如下面的代码：
public @interface Authority {
String role();
}
public @interface Authorities {
Authority[] value();
}
public class RepeatAnnotationUseOldVersion {
@Authorities({@Authority(role="Admin"),@Authority(role="Manager")})
public void doSomeThing(){
}
}
由另一个注解来存储重复注解，在使用时候，用存储注解Authorities来扩展重复注解，我们再来看看java 8里面的做法：
@Repeatable(Authorities.class)
public @interface Authority {
String role();
}
public @interface Authorities {
Authority[] value();
}
public class RepeatAnnotationUseNewVersion {
@Authority(role="Admin")
@Authority(role="Manager")
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ca002f6d3201115e0ca90579dc6dbc1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c0621726abb50d13eb09a48c75222d6/" rel="bookmark">
			java获取classloader_Java Class getClassLoader()用法及代码示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java.lang.Class类的getClassLoader()方法用于获取此实体的classLoader。该实体可以是类，数组，接口等。该方法返回此实体的classLoader。
用法:
public ClassLoader getClassLoader()
参数：此方法不接受任何参数。
返回值：此方法返回实体的ClassLoader。
下面的程序演示了getClassLoader()方法。
示例1:
// Java program to demonstrate getClassLoader() method
public class Test {
public static void main(String[] args)
throws ClassNotFoundException
{
// returns the Class object for this class
Class myClass = Class.forName("Test");
System.out.println("Class represented by myClass: "
+ myClass.toString());
// Get the classLoader of myClass
// using getClassLoader() method
System.out.println("ClassLoader of myClass: "
+ myClass.getClassLoader());
}
}
输出：
Class represented by myClass: class Test
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c0621726abb50d13eb09a48c75222d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a886cc64394ea0b7e882e21ca25af81/" rel="bookmark">
			安装java1.6_JAVA1.6怎么安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		展开全部
一、JDK1.6的下载
二、JDK1.6的安装
安装JDK很简单e69da5e887aa62616964757a686964616f31333337613231，只需要按照安装向导一步一步进行即可。在此就不再截图了。因为重点放在后面的JDK的环境变量的设置。
三、JDK1.6安装图解之设置环境变量
安装Java JDK1.6最重要的也是最容易出错的是设置环境变量。一共需要设置3个环境变量：Path，Classpath和Java_Home(大小写无所谓)。
Windows系统中设置环境变量如下图：
右击“我的电脑”，选择“属性”。
点击“高级”选项卡，选择“环境变量”。
在“系统环境变量”中设置上面提到的3个环境变量，如果变量已经存在就选择“编辑”，否则选“新建”。
JAVA_HOME指明JDK安装路径，就是刚才安装时所选择的路径(假设安装在D:\jdk1.4)，此路径下包括lib，bin，jre等文件夹(此变量最好设置，因为以后运行tomcat，Eclipse等都需要依靠此变量)。
Path使得系统可以在任何路径下识别java命令，设为：%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin
CLASSPATH为java加载类(class or lib)路径，只有类在classpath中，java命令才能识别，设为：.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar (要加.表示当前路径)
特别注意：
◆环境变量值的结尾没有任何符号，不同值之间用；隔开(unix中用:)。
◆CLASSPATH变量值中的.表示当前目录。
四、JDK1.6安装的最后检验
基本上就大功告成了，如果不放心，可以检验下。在命令行窗口下，键入java -version命令可以查看到安装的JDK版本信息；键入java命令，可以看到此命令的帮助信息；键入javac命令可以看到此命令的帮助信息。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82126bdee6a5dd42c0678c30a63fe58c/" rel="bookmark">
			java英文面试题_一套英文的Java面试题笔试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2014-07-15 06:30:01
阅读( 108 )
一、 选择题：
1. Which declarations of identifiers are legal?
A.$persons
B.TwoUsers
C.*point
D.this
E._endline
2. Which statements about inheritance are true?
A. In Java programming language only allows single inheritance.
B. In Iava programming language allows a class to implement only one interface.
C. In Java programming language a class cannot extend a class and implement a interface together.
D. In Java programming language single inheritance makes code more reliable.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82126bdee6a5dd42c0678c30a63fe58c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ee7fae33ae4f6938b65b505fafc48ba/" rel="bookmark">
			Java数据结构与算法笔记——利用栈来消除递归
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		消除递归 递归对于分析问题比较有优势，但是基于递归的实现效率就不高了，而且因为函数栈大小的限制，递归的层次也有限制。所以消除递归就显得很重要了，这样我们可以在分析阶段采用递归思想，而实现阶段把递归转变成非递归算法。
比如：求1+2+…+n的值：
//利用递归，求1+2+3+....+n的值 public static int addn(int n){ if(n==1){ return n; }else { return n+addn(n-1); } } 递归和栈有着紧密的联系，而且大多数编译器都是用栈来实现递归的，这里我们就模拟一下底层编译器的处理方法来转换递归算法。
现在把上面的递归算法，利用栈变成非递归算法：
package recursion; import java.util.Stack; public class RecursionTest7 { public static void main(String[] args) { System.out.println(addn1(4)); } //依靠栈消除递归 public static int addn1(int n){ Stack&lt;Params&gt; stack = new Stack&lt;&gt;(); int currentReturnValue = 0;//记录累加过程的中间结果和最终结果 int currentReturnAddress = 1;//初始化为第一个状态 Params params = null; boolean flag = true; while (flag){ switch (currentReturnAddress){ case 1: //初始化：初始参数封装为对象，压入栈。设置一下走的分支地址 params = new Params(n,6);//adress设置为6，这样当处理到这个Params之后，程序就跳转到case6，循环结束 stack.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ee7fae33ae4f6938b65b505fafc48ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b80bfd56855d99426fb0071b3072cc2d/" rel="bookmark">
			java时间戳与php时间戳_java 时间戳和PHP时间戳 的转换 php time()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在弄discuz,数据库mysql,时间类型int 10
总结一下java 时间戳和PHP时间戳 的转换问题：
由于精度不同，导致长度不一致，直接转换错误。
JAVA时间戳长度是13位，如：1294890876859
PHP时间戳长度是10位， 如：1294890859
主要最后三位的不同，JAVA时间戳在PHP中使用，去掉后三位，如：1294890876859-&gt; 1294890876 结果:2011-01-13 11:54:36
echo date('Y-m-d H:i:s','1294890876');
复制代码
PHP时间戳在JAVA中使用，最后加三位，用000补充,如：1294890859-&gt;1294890859000
结果:2011-01-13 11:54:19
SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
String dateTime = df.format(1294890859000L);
System.out.println(df);
复制代码
总结一下java时间戳和PHP时间戳 的转换问题：
由于精度不同，导致长度不一致，直接转换错误。
JAVA时间戳长度是13位，如：1294890876859
PHP时间戳长度是10位， 如：1294890859
主要最后三位的不同，JAVA时间戳在PHP中使用，去掉后三位，如：1294890876859-&gt; 1294890876 结果:2011-01-13 11:54:36 echo date('Y-m-d H:i:s','1294890876');
PHP时间戳在JAVA中使用，最后加三位，用000补充,如：1294890859-&gt;1294890859000
结果:2011-01-13 11:54:19 SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
String dateTime = df.format(1294890859000L);
System.out.println(df);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77c8c5c734482b862926e0a44fc8a62f/" rel="bookmark">
			EXCEL公式-文本型数据转换为数值型数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从后台导出的销售数据中，金额、订单数等均为文本型数据，无法进行求和计算。
这个时候可以通过*1将文本型数据快速转换为数值型数据。
如下所示：
其中clean函数用于去除字符串中的非打印字符，如Tab制表符等。通过*1，单元格中的内容靠右显示，表示已成功转换为数值型数据。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58fc4588c76e727d742ab8fe437adbaa/" rel="bookmark">
			Angular学习笔记之-11.表单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Angular 表单简介 响应式表单和模板驱动表单以不同的方式处理和管理表单数据。每种方法都有各自的优点。 1.响应式表单提供对底层表单对象模型直接、显式的访问。它们与模板驱动表单相比，更加健壮：它们的可扩展性、可复用性和可测试性都更高。如果表单是你的应用程序的关键部分，或者你已经在使用响应式表单来构建应用，那就使用响应式表单。 2.模板驱动表单依赖模板中的指令来创建和操作底层的对象模型。它们对于向应用添加一个简单的表单非常有用，比如电子邮件列表注册表单。它们很容易添加到应用中，但在扩展性方面不如响应式表单。如果你有可以只在模板中管理的非常基本的表单需求和逻辑，那么模板驱动表单就很合适。 响应式表单 对于响应式表单，你可以直接在组件类中定义表单模型。[formControl] 指令会通过内部值访问器来把显式创建的 FormControl 实例与视图中的特定表单元素联系起来。
import { Component } from '@angular/core'; import { FormControl } from '@angular/forms'; @Component({ selector: 'app-forms-reactive', template: ` &lt;h1&gt;app-forms-reactive&lt;/h1&gt; Favorite Color: &lt;input type="text" [formControl]="favoriteColorControl"&gt; `, }) export class FormsReactiveComponent { favoriteColorControl = new FormControl(''); } 建立模板驱动表单 在模板驱动表单中，表单模型是隐式的，而不是显式的。指令 NgModel 为指定的表单元素创建并管理一个 FormControl 实例。
import { Component } from '@angular/core'; @Component({ selector: 'app-forms-template-driven', template: ` &lt;h1&gt;app-forms-template-driven&lt;/h1&gt; Favorite Color: &lt;input type="text" [(ngModel)]="favoriteColor" /&gt; `, }) export class FormsTemplateDrivenComponent { _favoriteColor = '2222'; get favoriteColor() { return this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58fc4588c76e727d742ab8fe437adbaa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b7de74cdfcfd3f4f888d37eb5aef3f7/" rel="bookmark">
			mysql分区的优点_mysql分区表的原理和优缺点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.分区表的原理
分区表是由多个相关的底层表实现，这些底层表也是由句柄对象表示，所以我们也可以直接访问各个分区，存储引擎管理分区的各个底层表和管理普通表一样(所有的底层表都必须使用相同的存储引擎)，分区表的索引只是在各个底层表上各自加上一个相同的索引，从存储引擎的角度来看，底层表和一个普通表没有任何不同，存储引擎也无须知道这是一个普通表还是一个分区表的一部分。
在分区表上的操作按照下面的操作逻辑进行：
select查询：
当查询一个分区表的时候，分区层先打开并锁住所有的底层表，优化器判断是否可以过滤部分分区，然后再调用对应的存储引擎接口访问各个分区的数据
insert操作：
当写入一条记录时，分区层打开并锁住所有的底层表，然后确定哪个分区接受这条记录，再将记录写入对应的底层表
delete操作：
当删除一条记录时，分区层先打开并锁住所有的底层表，然后确定数据对应的分区，最后对相应底层表进行删除操作
update操作：
当更新一条数据时，分区层先打开并锁住所有的底层表，mysql先确定需要更新的记录在哪个分区，然后取出数据并更新，再判断更新后的数据应该放在哪个分区，然后对底层表进行写入操作，并对原数据所在的底层表进行删除操作
虽然每个操作都会打开并锁住所有的底层表，但这并不是说分区表在处理过程中是锁住全表的，如果存储引擎能够自己实现行级锁，如：innodb，则会在分区层释放对应的表锁，这个加锁和解锁过程与普通Innodb上的查询类似。
2.在下面的场景中，分区可以起到非常大的作用：
A：表非常大以至于无法全部都放在内存中，或者只在表的最后部分有热点数据，其他都是历史数据
B：分区表的数据更容易维护，如：想批量删除大量数据可以使用清除整个分区的方式。另外，还可以对一个独立分区进行优化、检查、修复等操作
C：分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备
D：可以使用分区表来避免某些特殊的瓶颈，如：innodb的单个索引的互斥访问，ext3文件系统的inode锁竞争等
E：如果需要，还可以备份和恢复独立的分区，这在非常大的数据集的场景下效果非常好
F：优化查询，在where字句中包含分区列时，可以只使用必要的分区来提高查询效率，同时在涉及sum()和count()这类聚合函数的查询时，可以在每个分区上面并行处理，最终只需要汇总所有分区得到的结果。
3.分区本身也有一些限制：
A：一个表最多只能有1024个分区(mysql5.6之后支持8192个分区)
B：在mysql5.1中分区表达式必须是整数，或者是返回整数的表达式，在5.5之后，某些场景可以直接使用字符串列和日期类型列来进行分区(使用varchar字符串类型列时，一般还是字符串的日期作为分区)。
C：如果分区字段中有主键或者唯一索引列，那么所有主键列和唯一索引列都必须包含进来，如果表中有主键或唯一索引，那么分区键必须是主键或唯一索引
D：分区表中无法使用外键约束
E：mysql数据库支持的分区类型为水平分区，并不支持垂直分区，因此，mysql数据库的分区中索引是局部分区索引，一个分区中既存放了数据又存放了索引，而全局分区是指的数据库放在各个分区中，但是所有的数据的索引放在另外一个对象中
F：目前mysql不支持空间类型和临时表类型进行分区。不支持全文索引
4.子分区的建立需要注意以下几个问题：
A：每个子分区的数量必须相同
B：只要在一个分区表的任何分区上使用subpartition来明确定义任何子分区，就必须在所有分区上定义子分区，不能漏掉一些分区不进行子分区。
C：每个subpartition子句必须包括子分区的一个名字
D：子分区的名字必须是唯一的，不能在一张表中出现重名的子分区
E：mysql数据库的分区总是把null当作比任何非null更小的值，这和数据库中处理null值的order by操作是一样的，升序排序时null总是在最前面，因此对于不同的分区类型，mysql数据库对于null的处理也各不相同。对于range分区，如果向分区列插入了null，则mysql数据库会将该值放入最左边的分区，注意，如果删除分区，分区下的所有内容都从磁盘中删掉了，null所在分区被删除，null值也就跟着被删除了。在list分区下要使用null，则必须显式地定义在分区的散列值中，否则插入null时会报错。hash和key分区对于null的处理方式和range,list分区不一样，任何分区函数都会将null返回为0.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7fd302c67fdbe3b0d3380914eb07b23/" rel="bookmark">
			Java高级---多线程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java高级—多线程 一、线程的概念 再讲线程之前，那么又又又又又又又要提起进程。（这个又字看多了，好像不认识了）
进程： 程序的一次的执行过程。
线程： 操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。
二、线程的实现和方法 Thread thread = new Thread("线程1");//线程创建 System.out.println(thread.getName());//获取线程名称 thread.start();	//线程启动 thread.setPriority(8); //设置优先级 1~10 thread.getState();	//获取线程状态 thread.isAlive();	//查看线程是否运行 三、多线程的实现方式 实现多线程的方式：
1、继承Thread类
2、实现Runnable接口
3、实现Callable接口
4、线程池
1、继承Thread类
重写run方法
public class MyThread extends Thread{ public void run(){ //线程运行的主体 for (int i = 1; i &lt;= 20; i++) { System.out.println(i+".你好,来自线程"+Thread.currentThread().getName()); } } public static void main(String[] args) { MyThread thread = new MyThread(); MyThread thread2 = new MyThread(); thread.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7fd302c67fdbe3b0d3380914eb07b23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec83adb1d85fee14ceee6a0cbbcf031e/" rel="bookmark">
			Java中Thread.yield详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Thread.yield( )方法：
使当前线程从执行状态（运行状态）变为可执行态（就绪状态）。cpu会从众多的可执行态里选择。这时候，“当前” 也就是刚刚的那个线程还是有可能会被再次执行到的。
public class YieldTest extends Thread { public YieldTest(String name) { super(name); } @SuppressWarnings("static-access") @Override public void run() { for (int i = 1; i &lt;= 5; i++) { System.out.println("" + this.getName() + "-----" + i); // 当i为3时，该线程就会把CPU时间让掉，让其他或者自己的线程执行（也就是谁先抢到谁执行） if (i == 3) { System.out.println(Thread.currentThread().getName() + "让出cpu"); this.yield(); } } } public static void main(String[] args) { YieldTest yt1 = new YieldTest("张三"); YieldTest yt2 = new YieldTest("李四"); yt1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec83adb1d85fee14ceee6a0cbbcf031e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dba5b3f62b38ff9b0c3c831590a164d4/" rel="bookmark">
			Centos7下使用LibreOffice转PDF中文乱码＜转载＞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源博客地址：https://www.jianshu.com/p/faa90891696a 亲测有效
一、查看操作系统是否中文字体 如果出现如图
1.终端输入：yum -y install cups-libs fontconfig
2.成功后，在/usr/share目录就可以看到fonts和fontconfig目录了（之前是没有的）
二、添加中文字体 1.在CentOS中，字体库的存放位置正是上图中看到的fonts目录，所以我们首先要做的就是找到中文字体文件放到该目录下，而中文字体文件在我们的windows系统中就可以找到，打开c盘下的Windows/Fonts目录： 如图，这俩个文件
如图，把上述俩个文件上传到/usr/share/fonts
2.在这之前我们还需要新建目录，首先在/usr/share/fonts目录下新建一个目录chinese：
如图操作，也可以FTP上传
2.然后就是将上面的两个字体上传至/usr/share/fonts/chinese目录下即可
3.chmod -R 755 /usr/share/fonts/chinese
4.yum -y install ttmkfdir
5.然后执行ttmkfdir命令即可：ttmkfdir -e /usr/share/X11/fonts/encodings/encodings.dir
6.vi /etc/fonts/fonts.conf
7.可以看到一个Font list，即字体列表，在这里需要把我们添加的中文字体位置加进去： 如图添加
8.刷新内存中的字体缓存，这样就不用reboot重启了，输入：fc-cache
9.这样所有的步骤就算完成了，最后再次通过fc-list看一下字体列表：
出现如图，表示成功！
作者：会飞的水珠
链接：https://www.jianshu.com/p/faa90891696a
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
------------------------------------------------------------------------------莫得感情的切割线----------------------------------------------------------------------------------------
处理LibreOffice遇见的其他坑，我用的是7.0.4的版本。
刚开始pdf没办法生成，运行 libreOffice 报 libcairo.so.2 动态库找不到，我是执行的yum install libcairo.so.2 安装完动态库可以了。
再执行还报 libcairo.so.2 动态库找不到可以试着运行 yum install -y libreOffice 安装的是5.3的版本。安装不了就把之前的都卸载了。先执行 yum install -y libreOffice 再安装你想要的版本。
这是我遇到的问题，不知道对各位有没有帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef63a3076fcec485d1e2577d52f0e46c/" rel="bookmark">
			mysql&#43;pdo&#43;dsn_使用PDO构造函数连接数据库及DSN详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pdo是php5中新加入的数据库抽象层，为了解决访问不同数据库统一接口的问题。类似于PEAR::DB类和ADODB类的操作，不过它是直接封装再php扩展中，可以自由选择使用。大理石检测平台
在上一篇《什么是PDO？PDO的概特点以及安装PDO的方法》中，我们介绍了什么是PDO，介绍了PDO的特点以及安装，那么我们这篇文章介绍PDO构造函数连接数据库以及DSN详情！
PDO构造函数连接数据库
在PDO中，要建立数据库的连接需要实例化 PDO 的构造函数，PDO构造函数的语法格式如下：
构造函数的参数说明如下：
dsn：数据源名称，包括主机名端口号和数据库名称。
username：连接数据库的用户名。
password：连接数据库的密码。
driver_options:连接数据库的其它选项。
那么我们下面直接用实例讲解，通过PDO连接 MySQL 数据库，具体代码如下：
页面输出的结果如下图：
注意：如果上面有的地方填错了，会通过try catch语句抛出异常！
DSN详解
什么是DSN？
DSN是Data Source Name(数据源名称)的首字母缩写。DSN提供连接数据库需要的信息。PDO的DSN包括3部分：PDO驱动名称(如：mysql、sqlite或者pgsql)、冒号和驱动特定的语法。每种数据库都有其特定的驱动语法。
在使用不同的数据库时，必须明确数据库服务器是完全独立与 PHP 的，是实体。但是在实际的情况可能是数据库服务器与 Web服务器不在同一台计算上，此时需要通过PDO连接数据库时，就修改DSN中的主机名称。
由于数据库服务器只是特定的端口上监听连接请求。每种数据库服务器具有一个默认的端口号(MySQL 是3306)，但是数据库管理员可以对端口号进行修改，因此有可能 PHP找不到数据库的端口号，此时就可以在 DSN中包含端口号。比如：
由于一个数据库中可能同时拥有多个数据库，所以通过DSN连接数据库时，通常都包括数据库名称，这样可以确保连接的是用户想要的数据库，而不是其他的数据库了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fa9d99e3f995598c9709391918a0c11/" rel="bookmark">
			一步一步解读神经网络编译器TVM(一)——一个简单的例子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@TOC
前言 这是一个TVM教程系列，计划从TVM的使用说明，再到TVM的内部源码?为大家大致解析一下TVM的基本工作原理。因为TVM的中文资料比较少，也希望贡献一下自己的力量，如有描述方面的错误，请及时指出。
那啥是TVM？
简单来说，TVM可以称为许多工具集的集合，其中这些工具可以组合起来使用，来实现我们的一些神经网络的加速和部署功能。这也是为什么叫做TVM Stack了。TVM的使用途径很广，几乎可以支持市面上大部分的神经网络权重框架(ONNX、TF、Caffe2等)，也几乎可以部署在任何的平台，例如Windows、Linux、Mac、ARM等等。
以下面一张图来形容一下，这张图来源于(https://tvm.ai/about)：
乍看这么多感觉非常地复杂，但我们只需要知道TVM的核心功能就可以：TVM可以优化的训练好的模型，并将你的模型打包好，然后你可以将这个优化好的模型放在任何平台去运行，可以说是与落地应用息息相关。
TVM包含的东西和知识概念都有很多，不仅有神经网络优化量化op融合等一系列步骤，还有其他更多细节技术的支持(Halide、LLVM)，从而使TVM拥有很强大的功能…好了废话不说了，再说就憋不出来了，如果想多了解TVM的可以在知乎上直接搜索TVM关键字，那些大佬有很多关于TVM的介绍文章，大家可以去看看。
其实做模型优化这一步骤的库已经出现很多了，不论是Nvidia自家的TensorRT还是Pytorch自家的torch.jit模块，都在做一些模型优化的工作，这里就不多说了，感兴趣的可以看看以下文章：
利用Pytorch的C++前端(libtorch)读取预训练权重并进行预测
利用TensorRT实现神经网络提速(读取ONNX模型并运行)
利用TensorRT对深度学习进行加速
开始使用 说到这里了，感觉有必要说下：我们为什么要使用TVM？
如果你想将你的训练模型移植到Window端、ARM端(树莓派、其他一系列使用该内核的板卡)或者其他的一些平台，利用其中的CPU或者GPU来运行，并且希望可以通过优化模型来使模型在该平台运算的速度更快(这里与模型本身的算法设计无关)，实现落地应用研究，那么TVM就是你的不二之选。另外TVM源码是由C++和Pythoh共同搭建，阅读相关源码也有利于我们程序编写方面的提升。
安装 安装其实没什么多说的，官方的例子说明的很详细。大家移步到那里按照官方的步骤一步一步来即可。
不过有两点需要注意下：
建议安装LLVM，虽然LLVM对于TVM是可选项，但是如果我们想要部署到CPU端，那么llvm几乎是必须的因为TVM是python和C++一起的工程，python可以说是C++的前端，安装官方教程编译好C++端后，这里建议选择官方中的Method1来进行python端的设置，这样我们就可以随意修改源代码，再重新编译，而Python端就不需要进行任何修改就可以直接使用了。
利用Pytorch导出Onnx模型 说了这么多，演示一个例子才能更好地理解TVM到底是做什么的，所以我们这里以一个简单的例子来演示一下TVM是怎么使用的。
首先我们要做的是，得到一个已经训练好的模型，这里我选择这个github仓库中的mobilenet-v2，model代码和在ImageNet上训练好的权重都已经提供。好，我们将github中的模型代码移植到本地，然后调用并加载已经训练好的权重：
import torch import time from models.MobileNetv2 import mobilenetv2 model = mobilenetv2(pretrained=True) example = torch.rand(1, 3, 224, 224) # 假想输入 with torch.no_grad(): model.eval() since = time.time() for i in range(10000): model(example) time_elapsed = time.time() - since print('Time elapsed is {:.0f}m {:.0f}s'. format(time_elapsed // 60, time_elapsed % 60)) # 打印出来时间 这里我们加载训练好的模型权重，并设定了输入，在python端连续运行了10000次，这里我们所花的时间为：6m2s。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fa9d99e3f995598c9709391918a0c11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/caac2c9e596d0d76ac6cc55305f9523e/" rel="bookmark">
			# C语言金字塔问题（字符三角形）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# C语言金字塔问题（字符三角形） 题目：
给定一个字符，用它构造一个底边长5个字符，高3个字符的等腰字符三角形。
输入：
输入只有一行， 包含一个字符。
输出：
该字符构成的等腰三角形，底边长5个字符，高3个字符。
样例输入
样例输出
**分析：**这道题通过循环结构即可解出，对于要多少行和每行多少字符大家想必都很熟悉，这里主要讲一下关于空格的问题。经过观察可得，最顶行的空格数为总## 标题层数-1，每一行的空格数又一次减一。
下面的代码对于输入符号和层数可以自己决定，具体可以自行修改。
代码如下：
#include&lt;stdio.h&gt;
int main()
{
char ch1;//输入的字符
int n,i,j,k,m;//n代表金字塔层数，i,j,k做循环计数用，m表示每一层的空格数
printf(“please input what you want to input:\n”);//输入你想要输入的符号，金字塔的每个基本单元将为此符号
scanf("%c",&amp;ch1);
printf(“please input how high about the pyramid:\n”);//输入你想要建立的金字塔层数
scanf("%d",&amp;n);
m=n-1;
for(i=1;i&lt;=n;i++)//按照层数依次建立金字塔
{
for(k=1;k&lt;=m;k++)//用于建立每一层的空格
{
printf(" “);
}
m–;
for(j=1;j&lt;=2*i-1;j++)//用于建立每一层的字符
{
printf(”%c",ch1);
}
printf("\n");
}
return 0;
}
程序运行截图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d08388aed96523a4dd7ae185cdca1c2f/" rel="bookmark">
			mysql shell 配置mysql_mysql shell安装 mysql8.0 MGR
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 节点信息
hostname
IP地址
mysql MGR
mysql1
172.16.230.51
mysql2
172.16.230.52
mysql3
172.16.230.53
2. 三个节点安装mysql8 实例
3. 每个节点初始化mysql账号
create user 'fengjian'@'%' identified by '123456';
grant all on*.* to 'fengjian'@'%' with grant option;
4. 下载 mysql shell
[root@mysql1 ~]# wget https://cdn.mysql.com//Downloads/MySQL-Shell/mysql-shell-8.0.23-linux-glibc2.12-x86-64bit.tar.gz
[root@mysql1 ~]# tar -zxvf mysql-shell-8.0.23-linux-glibc2.12-x86-64bit.tar.gz
[root@mysql1 ~]# mv mysql-shell-8.0.23-linux-glibc2.12-x86-64bit /usr/local/mysqlshell[root@mysql3 ~]# chown -R mysql.mysql /usr/local/mysqlshell
5. 拷贝mysqlshell 到其他节点
[root@mysql1 ~]#scp - /usr/local/mysqlshell root@172.16.230.52:/usr/local/[root@mysql2~]#chown -R mysql.mysql /usr/local/mysqlshell
[root@mysql1~]# scp - /usr/local/mysqlshell root@172.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d08388aed96523a4dd7ae185cdca1c2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c79d23950d91abcf346a0963c7a4165/" rel="bookmark">
			mysql dos入门_mysql入门基本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、连接MySQL
格式： mysql -h主机地址 -u用户名 -p用户密码
1、 连接到本机上的MYSQL。
首先打开DOS窗口，然后进入目录mysql\bin，再键入命令mysql -u root -p，回车后提示你输密码.注意用户名前可以有空格也可以没有空格，但是密码前必须没有空格，否则让你重新输入密码.
如果刚安装好MYSQL，超级用户root是没有密码的，故直接回车即可进入到MYSQL中了，MYSQL的提示符是： mysql&gt;
2、连接到远程主机上的MYSQL。假设远程主机的IP为：139.199.0.74，用户名为root,密码为123456。则键入以下命 令：
mysql -h139.199.0.74 -u root -p 123456;(注:u与root之间可以不用加空格，其它也一样)
3、 退出MYSQL命令： exit (回车)
二、修改密码
格式：mysqladmin -u用户名 -p旧密码 password 新密码。 例如
1、 给root加个密码ab12。首先在DOS下进入目录mysql\bin，然后键入以下命令
mysqladmin -u root -password ab12
2、 再将root的密码改为djg345。
mysqladmin -u root -p ab12 password ******
三、创建数据库
1、 CREATE DATABASE 数据库名;
2、 GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,ALTER ON 数据库名.* TO 数据库名@localhost IDENTIFIED BY ‘密码‘;
3、 SET PASSWORD FOR
‘数据库名‘@‘localhost‘ = OLD_PASSWORD(‘密码‘);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c79d23950d91abcf346a0963c7a4165/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6dd50928afd79cb1989c6a48af241a8/" rel="bookmark">
			移植uboot2019.10到tiny4412开发板（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		宿主机 ： 虚拟机 Ubuntu 16.04
目标板[底板]： Tiny4412SDK
目标板[核心板]： Tiny4412
U-BOOT版本： 2019.10
交叉编译器： gcc-arm-none-eabi-9-2020-q2-update
从网上下载代码到虚拟机，编译代码出现：
root@ubuntu:/home/uboot/source2017.03/u-boot-2019.10# make menuconfig
HOSTCC scripts/basic/fixdep
HOSTCC scripts/kconfig/mconf.o
YACC scripts/kconfig/zconf.tab.c
/bin/sh: 1: bison: not found
make[1]: *** [scripts/kconfig/zconf.tab.c] Error 127
make: *** [menuconfig] Error 2
解决方法：
root@ubuntu:/home/uboot/source2017.03/u-boot-2019.10# sudo apt-get install bison
root@ubuntu:/home/uboot/source2017.03/u-boot-2019.10# sudo apt-get install flex
1.修改arch/arm/mach-exynos/Kconfig文件
config TARGET_TINY4412
bool “Exynos4412 Tiny4412 board”
select SUPPORT_SPL
source “board/samsung/tiny4412/Kconfig”
2.创建tiny4412板级文件
cp board/samsung/origen/ board/samsung/tiny4412/
cd board/samsung/tiny4412/tools/
mv mkorigenspl.c mktiny4412spl.c
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6dd50928afd79cb1989c6a48af241a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ba82f75e03ac76e3b63e47b24150995/" rel="bookmark">
			java oom dump_JVM 在遇到OOM(OutOfMemoryError)时生成Dump文件的三种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JVM 在遇到OOM(OutOfMemoryError)时生成Dump文件的三种方式，以及如何使用Eclips Memory Analyzer(MAT)插件进行堆内存分析。
方法一：
jmap -dump:format=b,file=文件名 [pid]
例如：
jmap -dump:format=b,file=/usr/local/base/02.hprof 12942
方法二：
让JVM在遇到OOM(OutOfMemoryError)时生成Dump文件，需要配置一些信息
-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/usr/local/base
比如：我用eclipse配置一下。如下图所示：
方法三：
使用 jcmd 命令生成 dump 文件
jcmd GC.heap_dump d:\dump\heap.hprof
此方法没有经过博主的测试。
分析：
dump文件可以通过MemoryAnalyzer(MAT)分析查看,可以查看dump时对象数量，内存占用，线程情况等。
我们现在来安装一下eclipse MAT插件
打开Help -&gt; new install software
名字可以随便起，插件地址：http://archive.eclipse.org/mat/1.3/update-site
剩下的就不做多的介绍了，安装完成后，我们来使用方法二来营造一个内存溢出的例子：
比如我写的Java内存溢出程序是：
import java.util.ArrayList;
import java.util.List;
public class OOM {
public static void main(String[] args) {
List list = new ArrayList&lt;&gt;();
// 创建n个1M大小的数组，耗尽内存
for (int i = 0; i &lt; 10000; i++) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ba82f75e03ac76e3b63e47b24150995/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0241ab9cf8102a217e2fc6c80c21bc42/" rel="bookmark">
			理解CNN参数及PyTorch实例,卷积核kernel,层数Channels,步长Stride,填充Padding,池化Pooling,PyTorch中的相关方法,MNIST例子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.34.理解CNN参数及PyTorch实例
1.34.1.卷积核kernel
1.34.2.层数Channels
1.34.3.步长Stride
1.34.4.填充Padding
1.34.5.池化Pooling
1.34.6.PyTorch中的相关方法
1.34.7.MNIST例子
1.34.理解CNN参数及PyTorch实例 参考地址：http://guileen.github.io/2019/12/24/understanding-cnn/
在实际的项目中，会发现CNN有多个参数需要调整，本文主要目的在于理清各个参数的作用。
1.34.1.卷积核kernel Kernel，卷积核，有时也称为filter。在迭代过程中，学习的结果就保存在kernel里面。深度学习，学习的就是一个权重。kernel的尺寸越小，计算量越小，一般选择3x3，更小就没有意义了。
结果是对卷积核与一小块输入数据的点积。
1.34.2.层数Channels 所有位置的点积构成一个激活层。
如果我们有6个卷积核，我们就会有6个激活层。
1.34.3.步长Stride 上图是每次向右移动一格，一行结束向下移动一行，所以stride是1x1，如果是移动2格2行则是2x2。
1.34.4.填充Padding Padding的作用是为了获取图片上下左右边缘的特征。
1.34.5.池化Pooling 卷积层为了提取特征，但是卷积层提取完特征后特征图层依然很大。为了减少计算量，我们可以用padding的方式来减小特征图层。Pooling的方法有MaxPooling核AveragePooling。
1.34.6.PyTorch中的相关方法 torch.nn.Conv2d(in_channels, out_channels, kernel_size, stride=1, padding=0, dilation=1, groups=1, bias=True, padding_mode=’zeros’)
torch.nn.MaxPool2d(kernel_size, stride=None, padding=0, dilation=1, return_indices=False, ceil_mode=False)
stride默认与kernel_size相等
torch.nn.AvgPool2d(kernel_size, stride=None, padding=0, ceil_mode=False, count_include_pad=True, divisor_override=None)
Tensor.view(*shape) -&gt; Tensor
用于将卷积层展开为全连接层
x = torch.randn(4, 4) x.size() “”” 输出结果： torch.Size([4, 4]) “”” y = x.view(16) y.size() “”” 输出结果： torch.Size([16]) “”” z = x.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0241ab9cf8102a217e2fc6c80c21bc42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e54c3489088373c55c210a906bb6461/" rel="bookmark">
			java excel 多列排序_java poi处理excel多sheet并实现排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求：有一个数据字典全量汇总表，其中第一个sheet为目录，包括编号和表名，第二个以后为表的明细。其中sheet名就是表名但无序，sheet内字段序号无序有空行
现在要求将其中101，104，107，111表中的格式列和字段名称以及表名取出，生成批量语句，要求按给的编号有序输出，字段出要有序并排除窄。
输出结果如下：
insert into t_export(export_id,owner,table_name,col_name,format) values(101,'T_A','scott','id','20180308001');
insert into t_export(export_id,owner,table_name,col_name,format) values(101,'T_A','scott','sal','2000');
insert into t_export(export_id,owner,table_name,col_name,format) values(101,'T_A','scott','20','张三');
insert into t_export(export_id,owner,table_name,col_name,format) values(101,'T_A','scott','remark','hello');
insert into t_export(export_id,owner,table_name,col_name,format) values(101,'T_A','scott','birthday','40479');
insert into t_export(export_id,owner,table_name,col_name,format) values(101,'T_A','scott','age','20');
.
.
.
至111
excel如下:
下载poi包poi-3.17.jar并引入eclipse的java工程，仅需要RowInfo.java,ShowExcel.java
RowInfo.java:
package pu;
public class RowInfo implements Comparable{//实现字段排序
private int rownumb;
private int expId;
private String tableName;
private String columnName;
private String formatInfo;
public RowInfo(int rownumb,int expId, String tableName, String columnName,String formatInfo) {
super();
this.rownumb=rownumb;
this.expId = expId;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e54c3489088373c55c210a906bb6461/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bcac322bd0a4eec9e5f85ddb6507c77/" rel="bookmark">
			java中string是什么意思_在java中String...是什么意思
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		展开全部
1、首先String不属于8种基本数据类型，String是一个对象。 因为对象的默e68a84e8a2ad62616964757a686964616f31333365653161认值是null，所以String的默认值也是null；但它又是一种特殊的对象，有其它对象没有的一些特性。
2、关于String的其他知识点
(1)String类是final类，也即意味着String类不能被继承，并且它的成员方法都默认为final方法。在Java中，被final修饰的类是不允许被继承的，并且该类中的成员方法都默认为final方法。
(2)String对象一旦被创建就是固定不变的了，对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象。
(3)每当我们创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么就直接返回常量池中的实例引用。如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中。由于String字符串的不可变性我们可以十分肯定常量池中一定不存在两个相同的字符串
(4)String c = new String("chenssy");/**
* 采用字面值的方式赋值 */public void test1(){
String str1="aaa";
String str2="aaa";
System.out.println("===========test1============");
System.out.println(str1==str2);//true 可以看出str1跟str2是指向同一个对象 }
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc68c4b25272fe5c14ebe76cde415787/" rel="bookmark">
			【Androidx 更新问题】React Native 下安卓环境，Android Studio 构建失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录： 版本说明当前配置信息问题以及对应解决办法 一、版本说明 本机系统： Mac Android studio: 3.6.2 "react": "16.8.3", "react-native": "0.59.9" 二、当前配置信息 2.1、Android Studio 相关配置如下 Android Gradle Plugin Version(3.4.0) 插件版本对应所需 Gradle Version(5.5.1) ，这里版本必须对应，不然会出现各种莫名奇妙的问题 ${项目名}/android/build.gradle 文件中 buildscript { subprojects { afterEvaluate {project -&gt; if (project.hasProperty("android")) { android { compileSdkVersion compileSdkVersion buildToolsVersion "$buildToolsVersion" } } } } ext { buildToolsVersion = "28.0.3" minSdkVersion = 16 compileSdkVersion = 28 targetSdkVersion = 28 supportLibVersion = "25.0.0" } repositories { google() jcenter() maven {url 'http://developer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc68c4b25272fe5c14ebe76cde415787/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/214/">«</a>
	<span class="pagination__item pagination__item--current">215/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/216/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>