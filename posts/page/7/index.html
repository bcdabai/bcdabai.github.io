<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcda17dc8b4ef205ba188facb487e5f8/" rel="bookmark">
			【大数据】流处理基础概念（一）：Dataflow 编程基础、并行流处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		流处理基础概念（一）：Dataflow 编程基础、并行流处理流处理基础概念（二）：时间语义（处理时间、事件时间、水位线）流处理基础概念（三）：状态和一致性模型（任务故障、结果保障） 😊 如果您觉得这篇文章有用 ✔️ 的话，请给博主一个一键三连 🚀🚀🚀 吧 （点赞 🧡、关注 💛、收藏 💚）！！！您的支持 💖💖💖 将激励 🔥 博主输出更多优质内容！！！
流处理基础概念（一）：Dataflow 编程基础、并行流处理 1.Dataflow 编程基础1.1 Dataflow 图1.2 数据并行和任务并行1.3 数据交换策略 2.并行流处理2.1 延迟与吞吐2.1.1 延迟2.1.2 吞吐2.1.3 延迟与吞吐 2.2 数据流上的操作2.2.1 数据接入和数据输出2.2.2 转换操作2.2.3 滚动聚合2.2.4 窗口操作2.2.4.1 滚动窗口2.2.4.2 滑动窗口2.2.4.3 会话窗口2.2.4.4 小结 1.Dataflow 编程基础 1.1 Dataflow 图 Dataflow 程序描述了数据如何在不同操作之间流动。Dataflow 程序通常表示为 有向图。图中 顶点 称为 算子，表示计算；而 边 表示 数据依赖关系。算子是 Dataflow 程序的基本功能单元，它们从输入获取数据对其进行计算，然后产生数据并发往输出，以供后续处理。没有输入端的算子称为 数据源（data sources），没有输出端的算子称为 数据汇（data sinks）。一个 Dataflow 图至少要有一个数据源和一个数据汇。
上图中的 Dataflow 图被称作 逻辑图，因为它们表达了高层视角下的计算逻辑。为了执行 Dataflow 程序，需要将逻辑图转化为 物理 Dataflow 图。后者会指定程序的执行细节，例如，当我们使用分布式处理引擎时，每个算子可能会在不同物理机器上运行多个并行任务。在逻辑 Dataflow 图中，顶点代表算子。在物理 Dataflow 图中，顶点代表任务。如下图所示，“抽取主题标签” 和 “计数” 算子都包含 2 个并行算子任务，每个任务负责计算一部分输入数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcda17dc8b4ef205ba188facb487e5f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3692c278a0885e925f9ba05be8336cbb/" rel="bookmark">
			Python爬虫案例（多线程&#43;消息队列初阶）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
相关库介绍
相关库介绍 BeautifulSoup Beautiful Soup 是一个用于从HTML或XML文件中提取数据的Python库。它提供了一种非常方便的方式来浏览文档、搜索特定标签或内容，以及对标签进行修改。Beautiful Soup的主要作用是帮助解析和提取HTML/XML文档中的数据，使得在Python中处理Web数据变得更加简单。常用方法： BeautifulSoup(markup, 'html.parser'): 创建一个 BeautifulSoup 对象，用于解析 HTML 或 XML 文档。markup 是要解析的字符串或文件对象。find(name, attrs, recursive, string): 查找文档中第一个符合条件的标签。find_all(name, attrs, recursive, string): 查找文档中所有符合条件的标签，返回一个列表。select(selector): 使用 CSS 选择器语法查找元素。tag.text 或 tag.get_text(): 获取标签内的文本内容，包括所有子孙节点的文本。tag.string: 获取标签内的直系文本内容，如果有多个子节点则返回 None。find_all(class_='classname'): 查找具有特定 CSS 类名的所有标签。 Threading threading 是 Python 标准库中用于线程编程的模块。线程是一种轻量级的执行单元，允许程序并发执行多个任务。threading 模块提供了创建、管理和同步线程的工具，可以用于在多任务环境中执行并行的操作常用方法： threading.Thread(target, args, kwargs): 创建一个新线程。target 参数指定线程要执行的目标函数，args 和 kwargs 用于传递给目标函数的参数。start(): 启动线程，调用线程的 run 方法。join(timeout=None): 等待线程终止。如果指定了 timeout 参数，最多等待指定的秒数。 Requests requests 是一个用于发送 HTTP 请求的 Python 库，它简化了与 Web 服务的交互。requests 库支持多种 HTTP 方法，包括 GET、POST、PUT、DELETE 等，并提供了便捷的接口来处理请求和响应。常用方法： response = requests.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3692c278a0885e925f9ba05be8336cbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8934b70020a38777d61845f7a1a45bc/" rel="bookmark">
			线上版本升级 — — pg数据库备份
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线上版本升级 — — pg数据库备份 在版本升级之前，我们通常为了保险都需要将数据库里的数据结构备份一份，防止升级失败之后数据丢失。（根据业务而来，并非所有业务都需要备份）
1 备份 1.1 pg_dump：备份指定数据 只能备份单个数据库，不会导出角色和表空间相关的信息。因此恢复数据库或者表之前，需要保证之前的数据库已经被创建。否则会报数据库not exist.
①参数解析 Usage: pg_dump [OPTION]... [DBNAME] 数据库名放最后，不指定默认是系统变量PGDATABASE指定的数据库。 General options:(一般选项) -f, --file=FILENAME 导出后保存的文件名 -F, --format=c|d|t|p 导出文件的格式(custom, directory, tar, plain, text(default)) -j, --jobs=NUM 并行任务数 -v, --verbose 详细信息 -V, --version 版本信息 -Z, --compress=0-9 压缩格式的压缩级别 --lock-wait-timeout=TIMEOUT 在等待表锁超时后操作失败 -?, --help 帮助信息 Options controlling the output content:(控制输出的选项) -a, --data-only 只导出数据，不包括模式 -b, --blobs 在转储中包括大对象 -c, --clean 在重新创建之前，先清除（删除）数据库对象 -C, --create 在转储中包括命令,以便创建数据库（包括建库语句，无需在导入之前先建数据库） -E, --encoding=ENCODING 转储以ENCODING形式编码的数据 -n, --schema=SCHEMA 只转储指定名称的模式 -N, --exclude-schema=SCHEMA 不转储已命名的模式 -o, --oids 在转储中包括 OID -O, --no-owner 在明文格式中, 忽略恢复对象所属者 -s, --schema-only 只转储模式, 不包括数据(不导出数据) -S, --superuser=NAME 在转储中, 指定的超级用户名 -t, --table=TABLE 只转储指定名称的表 -T, --exclude-table=TABLE 不转储指定名称的表 -x, --no-privileges 不转储权限 (grant/revoke) --binary-upgrade 只能由升级工具使用 --column-inserts 以带有列名的insert命令形式转储数据 --disable-dollar-quoting 取消美元 (符号) 引号, 使用 SQL 标准引号 --disable-triggers 在恢复数据的过程中禁用触发器 --exclude-table-data=TABLE 不转储指定表的数据 --inserts 将数据转储为insert命令，而不是copy命令 --no-security-labels 不分配安全标签进行转储 --no-synchronized-snapshots 不在并行任务中使用同步快照 --no-tablespaces 不转储表空间分配信息 --no-unlogged-table-data 不转储未标记的表数据 --quote-all-identifiers 引用所有标识符( 不是关键字 ) --section=SECTION 转储命名部分(pre-data, data, or post-data) --serializable-deferrable 等待没有异常的情况下进行转储 --use-set-session-authorization 使用SET SESSION AUTHORIZATION命令而不是ALTER OWNER命令来设置所有权 Connection options:(控制连接的选项) -d, --dbname=DBNAME 转储的数据库名 -h, --host=HOSTNAME 数据库服务器的主机名或IP -p, --port=PORT 数据库服务器的端口号 -U, --username=NAME 指定数据库的用户联接 -w, --no-password 不显示密码提示输入口令 -W, --password 强制口令提示 (自动) --role=ROLENAME 转储前设置角色 如果没有提供数据库名字, 那么使用 PGDATABASE 环境变量的数值.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8934b70020a38777d61845f7a1a45bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da6a93ee5621fea5c4a1f1380f80d446/" rel="bookmark">
			c&#43;&#43;中的操作符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一：关系操作符 C 语⾔⽤于⽐较的表达式，称为 “关系表达式”（relational expression），⾥⾯使⽤的运算符就称 为“关系运算符”（relational operator），主要有下⾯6个。
&gt; ⼤于运算符 &lt; ⼩于运算符&gt;= ⼤于等于运算符&lt;= ⼩于等于运算符 == 相等运算符 != 不相等运算符 二：条件操作符 条件操作符也叫三⽬操作符，需要接受三个操作数的：
形式如下： 1 exp1 ? exp2 : exp3
条件操作符的计算逻辑是：如果 exp1 为真， exp2 计算，计算的结果是整个表达式的结果；如果 exp1 为假， exp3 计算，计算的结果是整个表达式的结果。
练习1：使⽤条件操作符表⽰下⾯代码的逻辑
#include&lt;stdio.h&gt; int main() { int a=0; int b=0; scanf("%d%d",&amp;a,&amp;b); if(a&gt;10) b=1; else b=-1; printf("%d\n",b); return 0; 改造后： #include&lt;stdio.h&gt; int main(); int a=0; int b=0; scanf("%d%d",&amp;a,&amp;b); b=a&gt;10 ? 1:-1; printf("%d\n",b); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15e4ec9fab911813d52ae22cf6fc3cd8/" rel="bookmark">
			全新UI基于Thinkphp的最新自助打印系统/云打印小程序源码/附教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这是一款全新的基于Thinkphp的最新自助打印系统，最新UI界面设计的云打印小程序源码，带有简单的教程。
源码下载：YISHEN源码网（ms3.ishenglu.c）om 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00a1a0d1d5c6ccfc91e20ae50721b300/" rel="bookmark">
			24.1.24 DAY1 C&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		思维导图：
1.
提示并输入一个字符串，统计该字符中大写、小写字母个数、数字个数、空格个数以及其他字符个数，要求使用C++风格字符串完成
代码：
#include &lt;iostream&gt; #include &lt;array&gt; using namespace std; int main() { int big=0; int small=0; int num=0; int space=0; int other=0; //string a=""; string a; cout &lt;&lt; "请输入字符串" &lt;&lt; endl; getline(cin,a); cout &lt;&lt; a &lt;&lt;endl; int i=a.size(); cout &lt;&lt; i &lt;&lt; endl; for(i=a.size();i&gt;0;i--) { if(a[i-1]==' ') space++; else if(a[i-1]&lt;='9'&amp;&amp;a[i-1]&gt;='0') num++; else if(a[i-1]&lt;='Z'&amp;&amp;a[i-1]&gt;='A') big++; else if(a[i-1]&lt;='z'&amp;&amp;a[i-1]&gt;='a') small++; else other++; } cout &lt;&lt; "空格数量为" &lt;&lt; space &lt;&lt;endl; cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00a1a0d1d5c6ccfc91e20ae50721b300/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7867e5f23bccb56ab3f46fe32e8ce8b6/" rel="bookmark">
			[docker] Docker资源管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、docker资源控制 Docker通过Cgroup 来控制容器使用的资源配额，包括CPU、内存、磁盘三大方面，基本覆盖了常见的资源配额和使用量控制。Caroup 是ControlGroups的缩写，是Linux 内核提供的一种可以限制、记录、隔离进程组所使用的物理资源(如 cpu、内存、磁盘，io等等)的机制，被LXC、docker等很多项目用于实现进程资源控制。Cgroup本身是提供将进程进行分组化管理的功能和接口的基础结构，I/O或内存的分配控制等具体的资源管理是通过该功能来实现的。
资源限制：可以对任务使用的资源总额进行限制。优先级分配：通过分配的cpu时间片数量以及磁盘IO带宽大小，实际上相当于控制了任务运行优先级。资源统计：可以统计系统的资源使用量，如cpu时长，内存用量等。任务控制： cgroup可以对任务 执行挂起、恢复等操作。 二、docker占用宿主机cpu的限制 2.1 cpu的使用率上限 Linux通过CFS (Completely Fair Scheduler，完全公平调度器）来调度各个进程对ceu的使用。CFS默认的调度周期是100ms 。我们可以设置每个容器进程的调度周期，以及在这个周期内各个容器最多能使用多少CPU时间。
使用--cpu-period 即可设置调度周期，使用--cpu-quota即可设置在每个周期内容器能使用的CPU时间。两者可以配合使用。CFS周期的有效范围是 1ms~1s，对应的--cpu-period 的数值范围是1000~1000000。而容器的CPU配额必须不小于1ms，即--cpu-quota的值必须&gt;= 1000。而容器的CPU配额必须不小于1ms，即--cpu-quota的值必须&gt;= 1000。
docker run -itd --name test5 centos:7 /bin/bash docker ps -a cd/sys/fs/cgroup/cpu/docker/9d415515c01e61a335bdc841e19b60a1ce54dd3cbaefeab7844fdcf785cd5aa4/ cd /sys/fs/cgroup/cpu/docker/ -1 cat cpu.cfs_period_us 100000 #cpu.cfs_period_us：cpu分配的周期(微秒，所以文件名中用 us 表示），默认为100000。 #cpu.cfs_quota_us：表示该cgroups限制占用的时间（微秒），默认为-1，表示不限制。 如果设为50000，表示占用50000/100000=50%的CPU。 进行CPU压力测试 docker exec -it test5 bash vi /cpu.sh #!/bin/bash i=0 while true do let i++ done chmod +x /cpu.sh ./cpu.sh top	#可以看到这个脚本占了很多的cpu资源 设置50%的比例分配CPU使用时间上限 docker run -itd --name test6 --cpu-quota 50000 centos:7 /bin/bash	#可以重新创建一个容器并设置限额 或者 cd/sys/fs/cgroup/cpu/docker/9d415515c01e61a335bdc841e19b60a1ce54dd3cbaefeab7844fdcf785cd5aa4/ echo 50000 &gt; cpu.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7867e5f23bccb56ab3f46fe32e8ce8b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7db3b75947395620d3370c33c3452f61/" rel="bookmark">
			实习记录——第三天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天还是去学习，昨天看另一个实习生有在了解ctf什么的，我就打算也看一看，问了问我的导师，他说我闲了可以看看，把我拉到了公司的ctf组，本来以为会是什么高大上的组织，结果好像就是平时分享分享知识，偶尔打个比赛，今天加进去，一天没任何动静。
简单看了看导师发的资料，web里面好多没见过的漏洞，感觉基础太差了，又找到小迪准备踏实学，害怕这两天让我去客户现场干漏扫，我又看了一下漏扫工具的使用，看是差不多看懂了，但是没用过，还是感觉差点儿。后面我就直接看小迪讲课了，也不知道咋搞的，居然一天就看了一节课，好吧~为了彰显我干的多，我把昨天晚上回学校干的东西也一起写上去，写日报这个事情，上一次实习给我留下很强的影响，每次写不好就被拉出去说，咱就是说，管公司有没有要求我，我都给他写详细仔细了，以下是我的日报：
1.24日总结： 一， 学习昨天剩下的web应用安全测试指南； 二， 对.NET框架进行了一个总结，并写了一篇总结笔记： 1. 了解了.NET项目当中的dll的反编译操作； 2. web.config错误调试，报错处容易造成信息泄露； 3. 此类项目易出现未授权访问，在网上找了几个例子阅读了一下； 三，对cookie和session产生漏洞的原因做了总结，并写了一篇总结笔记： 1. cookie保存在客户端容易被修改伪造窃取； 2. 联动xss可以达到权限维持； 3. session保存在服务器端易产生session劫持； 四，对PHP特征函数做了复习： 1. 手写简单php代码测试函数效果； 2. 了解各个函数常见的绕过方式； 3. 找了几道PHP相关的ctf题目； 感想： 以前我只是简单了解一些Web的CTF题目，但是今天在学习PHP特征函数的过程中，我发现学习CTF并不仅仅是为了参加比赛。很多需要审查代码的地方在实际战斗中仍然会出现。因此，我计划在平时有空的时候多看看相关题目，深入了解和熟悉，以便更好地应对实际挑战。 别看干的多，吸收的并不多，忙着记录实验，没有复盘，晚上星辰（亦师亦友的人）问我你写的都吸收了？这一问我还真不敢说，这才意识到写的挺多，吸收的几个？这个感想我没写到日报里，今天就这样了，明天继续加油！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70d6c28a5431006efa1a159e11938c4c/" rel="bookmark">
			Java基础进阶02-xml
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、XML（可拓展标记语言） 1.学习网站： https://www.w3schoo1.com.cn
标记语言:通过标签来描述数据的一门语言(标签有时我们也将其称之为元素)
可扩展:标签的名字是可以自定义的
2.作用 用于进行存储数据和传输数据
作为软件的配置文件
3.XML标签 标签由一对尖括号和合法标识符组成 &lt; user &gt;
标签必须成对出现&lt; user &gt;&lt; user/&gt;
特殊的标签可以不成对，但是必须有结束标记&lt; user/ &gt;
标签中可以定义属性，属性和标签名空格隔开属性值必须用引号(单/双)引起来&lt; user id = "100"/&gt;
标签需要正确的嵌套
4.XML语法 后缀名为.xml
文档声明必须是第一行第一列
&lt;?xmlversion="1.0”encoding="UTF-8" standalone= “yes”?&gt; 其中 version属性必须存在 encoding属性不是必须的，作用：打开当前xml文件的时候应该是使用什么字符编码表（默认都是UTF-8） standalone属性不是必须的，作用：描述XML文件是否依赖其他的xml文件，取值为yes/no 必须存在根标签
XML文件中可以定义注释信息
XML文件中可以存在以下特殊字符
&amp;lt;-----------------小于 &amp;gt;-----------------大于 &amp;amp;----------------和号（&amp;） &amp;apos;---------------单引号 &amp;quot;---------------引号 XML可以存在CDATA区
&lt;![CDATA[ ...内容...]]&gt; 5.解析XML （1）常见解析思想DOM DOM(DocumentObject Model)文档对象模型：
就是把文档的各个组成部分看做成对应的对象，会把xmI文件全部加载到内存在内存中形成一个树形结构，再获取对应的值
其中DOM对象主要有以下部分
Document对象:整个xml文档
Element对象:所有标签
Attribute对象:所有属性
Text对象:所有文本内容
其中Element，Attribute，Text有一个共同的父类：Node对象
6.常见的解析工具 JAXP：SUN公司提供的一套XML的解析的API
JDOM：开源组织提供了一套XML的解析的API-jdom
DOM4J：开源组织提供了一套XML的解析的API-dom4j
pull ：主要应用在Android手机端解析XML
7.DOM4j的使用 首先下载jar包
xml文件
&lt;?xml version="1.0" encoding="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70d6c28a5431006efa1a159e11938c4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dac9a66574e5a8ea630d490be1925e8/" rel="bookmark">
			设计模式三(原型模式)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在开发过程中，创建多个数据相同的对象，每次new都开销比较大，在这里可以使用对象克隆，以先创建的原型对象为模板进行对象的复制。这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用
浅克隆 在浅克隆中，如果原型对象的成员变量是值类型，将复制一份给克隆对象；如果原型对象的成员变量是引用类型，则将引用对象的地址复制一份给克隆对象，也就是说原型对象和克隆对象的成员变量指向相同的内存地址
public class Person implements Cloneable{ ​ int num; String name; ​ public Person() { } ​ public Person(int num, String name) { this.num = num; this.name = name; } ​ public int getNum() { return num; } ​ public void setNum(int num) { this.num = num; } ​ public String getName() { return name; } ​ public void setName(String name) { this.name = name; } ​ ​ ​ @Override protected Person clone() throws CloneNotSupportedException { Person person = (Person)super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5dac9a66574e5a8ea630d490be1925e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f6deba85f5bd7083bc6bced4b7ea378/" rel="bookmark">
			探索Gin框架：快速构建高性能的Golang Web应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Gin框架是一个轻量级的Web框架，基于Go语言开发，旨在提供高性能和简洁的API。它具有快速的路由和中间件支持，使得构建Web应用变得更加简单和高效。无论是构建小型的API服务还是大型的Web应用，Gin框架都能够满足你的需求。
无论你是一个有经验的开发者，还是一个刚刚入门的初学者，本文都将为你提供清晰的指导和实用的示例代码。无论你是想构建一个简单的API服务，还是一个复杂的Web应用，Gin框架都能够帮助你快速实现你的想法。
目录 ​编辑
前言
适用人群
构建第一个Gin应用
1.下载并安装Gin
2.项目导入
3.快速使用示例
路由和中间件
API路由配置
路由分组
静态文件路由设置
静态路径映射
静态文件路由
路由中间件
优雅封装
Gin客户端初始化
定义api路由
在项目入口启动Gin服务
总结
适用人群 懂得安装 Go 环境及其基本语法会使用 Go Modules 管理项目 构建第一个Gin应用 1.下载并安装Gin go get -u github.com/gin-gonic/gin 2.项目导入 import "github.com/gin-gonic/gin" 3.快速使用示例 package main import "github.com/gin-gonic/gin" func main() { r := gin.Default() r.GET("/ping", func(c *gin.Context) { c.JSON(200, gin.H{ "message": "pong", }) }) r.Run() // 监听并在 0.0.0.0:8080 上启动服务 } 路由和中间件 API路由配置 Gin的API路由配置相当简单，只需要调用对应请求方式的方法，设置请求路径，与请求函数即可
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f6deba85f5bd7083bc6bced4b7ea378/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/352b4d591397732fca53aa51a2021127/" rel="bookmark">
			docker: 搭建 harbor 镜像仓库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		harbor 企业级内网镜像管理软件，加速拉取镜像速度，web 页面管理方便。
系统优化 systemctl stop NetworkManager systemctl disable NetworkManager iptables -F systemctl restart docker 安装docker [root@test05 ~]# yum install -y docker-compose docker [root@test05 ~]# docker-compose version docker-compose version 1.18.0, build 8dd22a9 docker-py version: 2.6.1 CPython version: 3.6.8 OpenSSL version: OpenSSL 1.0.2k-fips 26 Jan 2017 下载软件 mkdir /data &amp;&amp; cd /data # mv /tmp/harbor-offline-installer-v2.10.0.tgz . # wget https://github.com/goharbor/harbor/releases/download/v2.10.0/harbor-offline-installer-v2.10.0.tgz 安装 tar xvf harbor-offline-installer-v2.10.0.tgz mkdir -p /data/harbor/ssl &amp;&amp; cd /data/harbor/ssl 配置证书 openssl genrsa -out ca.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/352b4d591397732fca53aa51a2021127/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1086113fdfbc6e1d24a7b4d92e2e0a31/" rel="bookmark">
			C#学习(十)——WPF重构与美化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Entity Framework Core 特点：【跨平台】，【建模】，【查询、更改、保存】，【并发】，【事务】，【缓存】，【数据迁移】
EF的组件
二、重构：构建数据模型 项目延续C#学习(九)的 项目代码，以此基础进行进一步重构
所需的NuGet包如下：
逆向数据库获得数据模型(Model)
首先在根目录下创建Models文件夹，然后使用Tools-&gt;NuGet包管理器-&gt;程序包管理器控制台
输入指令
Scaffold-DbContext "自己的数据库连接字符串" Microsoft.EntityFrameworkCore.Sqlserver -OutputDir Models -Context AppDbContext 处理完成后，就可以在Models文件夹中看到通过逆向数据库构建的数据模型啦！
三、OMR数据管理 使用Entity Framework 取代SQL语句
使用ORM来自动生成SQL语句，通过数据库的映射框架获取数据模型，通过模型框架的链式结构来处理数据，可以使业务实现在代码中，而不是实现在SQL语句中。因此对于程序员来说，使用对象的链式结构更加符合面向对象的编程理念。
通过数据模型向UI传递和绑定数据
代码改进后如下：
MainWindow.xaml.cs
public partial class MainWindow : Window { public MainWindow() { InitializeComponent(); ShowCustomers(); } //访问数据库 private void ShowCustomers() { try { using(var db = new AppDbContext()) { var customers = db.Customers.ToList(); customerList.DisplayMemberPath = "Name"; customerList.SelectedValuePath = "Id"; customerList.ItemsSource = customers; } }catch (Exception ex) { MessageBox.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1086113fdfbc6e1d24a7b4d92e2e0a31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4d58270a1444ae42cce644001bbc7c8/" rel="bookmark">
			RS485Modbus转Profinet网关在工业现场的应用优势
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在工业自动化领域，RS485Modbus转Profinet网关的应用愈发广泛，其优势在于简化系统架构、提高通信效率、降低成本和便于维护。接下来，本文将详细介绍RS485Modbus转Profinet网关在工业现场的应用优势、实施方案和注意事项。
应用优势：通过RS485Modbus转Profinet网关，可以将原有的RS485Modbus设备无缝接入到Profinet网络中，减少中间环节，使系统架构更加简洁。Profinet协议具有较高的传输速率和实时性，能够满足工业现场对数据通信的高要求。通过RS-485转Profinet网关，可以提高整个系统的通信效率。RS485Modbus转Profinet网关的引入，可以减少硬件设备的投资，如传统的RS-485总线设备、中继器等。同时，由于Profinet网络的易于维护和扩展性，可以降低系统维护成本。RS485Modbus转Profinet网关的引入，使得系统具备统一的管理和维护界面。通过网关，可以实现对RS485Modbus设备的远程监控、故障诊断等功能，大大提高了系统的可维护性。
选择合适的RS485Modbus转Profinet网关：根据实际应用需求，选择具备相应接口、传输速率、安全性能等功能的网关。同时，要考虑网关的兼容性和稳定性。将RS485Modbus设备通过电缆连接到网关的RS485Modbus接口，将网关的Profinet接口与主控设备连接。需要注意的是，遵循正确的接线规范，确保连接稳定可靠。针对具体应用场景，对RS485Modbus转Profinet网关进行配置，如设置IP地址、子网掩码、网关、端口号等。配置完成后，进行调试以确保数据通信正常。
RS485Modbus转Profinet网关的作用就是解决这一问题。这种网关设备可以将RS485Modbus信号转换为Profinet信号，使得RS485Modbus设备能够接入到Profinet网络中，实现高速、远距离、抗干扰的通信。这大大提高了设备的通讯性能，满足了现代工业自动化的需求。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7fd6e83fc2862bcfea3c68232818579/" rel="bookmark">
			System.Threading.Channels 高性能异步队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 System.Threading.Channels 是.NET Core 3.0 后推出的新的集合类型, 具有异步API,高性能，线程安全等特点，它提供一个异步数据集合，可用于生产者和消费者之前的数据异步传递。
它提供如下方法：
BoundedChannelOptions Provides options that control the behavior of bounded Channel&lt;T&gt; instances.
提供通道的行为控制 有限通道
Channel Provides static methods for creating channels.
提供创建通道的静态方法
Channel&lt;T&gt; Provides a base class for channels that support reading and writing elements of type T.
泛型通道，写入和读取方类型都为 T
Channel&lt;TWrite,TRead&gt; Provides a base class for channels that support reading elements of type TRead and writing elements of type TWrite.
泛型通道，分别指定写入和读取方的类型
ChannelClosedException Exception thrown when a channel is used after it's been closed.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7fd6e83fc2862bcfea3c68232818579/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50346757b34d4428b6cec299b1dd8de6/" rel="bookmark">
			JS-对象方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 基础对象方法1. constructor属性2. hasOwnProperty3. isPrototypeOf4. propertyIsEnumerable 对象静态方法1. assign2. create3. getOwnPropertyNames/getOwnPropertySymbols4. getPrototypeOf/setPrototypeOf5. hasOwn6. keys/values/entries7. fromEntries8. freeze9. preventExtensions10. seal11. isExtensible/isFrozen/isSealed 基础对象方法 指的是对象可以直接使用的方法（一般在对象本身或原型中） 1. constructor属性 语法：对象.constructor返回值：创建该对象的构造函数注意：有时候会用于判断数据类型 let arr = [1, 2, 3]; console.log(arr.constructor); // ƒ Array() { [native code] } console.log(arr.constructor === Array); // true console.log({ a: 1 }.constructor === Array); // false 2. hasOwnProperty 语法：对象.hasOwnProperty(属性名)作用：判断传入的属性名是否是对象自身的属性返回值：布尔值 class Person { constructor() { this.age = 17; } } Person.prototype.say = function() {} let p = new Person(); console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50346757b34d4428b6cec299b1dd8de6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bce585ec733cd07123213df2f633170d/" rel="bookmark">
			量涨价涨、量跌价跌、量跌价涨、量涨价跌，到底怎么回事？到底是涨还是跌？...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（1）
上周五：量缩、价跌
本周一：量涨、价跌
本周二（昨天）：量缩、价涨
本周三（今天）：量涨、价涨
很多人问，这些到底意味着什么啊。明天到底是会涨还是会跌啊。
很多人会背顺口溜，什么量涨价跌怎么着怎么着，什么价涨量跌怎么着怎么着。大家也不明白为啥，就死记硬背，认为这就是恒久不变的规律。
所以我给大家通俗讲讲，其实本质很简单。
（2）
其实我看股市很简单，和你到菜市场买卖大白菜一样简单，都是买和卖而已，没有买就不可能有卖的，有卖的但没有买的那卖的也活不了。
只不过菜市场买卖的是大白菜这个商品，你在股票市场买卖的是股票这个商品。其实银行也很简单，买卖的不过是钱这个商品。很多人对钱没啥认知，觉得钱这个东西太神秘了，其实在银行人眼里钱就是个大白菜，和到田间地头各个农民出去收大白菜然后集中起来批发卖高价是一个道理。
所以在股市也这么简单：
菜市场中的大白菜的量多了，人们都想卖出去，那自然竞争到价格很低。
如果菜市场的大白菜这几天由于各种原因量少了，相对来说如果想吃大白菜的人多了，那自然摊主想给大白菜涨价了。
这就是量和价的关系。
你们看各种K线图，本质上看的就是价格的变化。但是你一定要辅助上量这个维度来看，才完整。单看K线图，没毛用。
（3）
完整看量、价，需要看三个维度：
第一个维度是股票的趋势：股票是在上升趋势，还是在下跌趋势。这就一个维度两个变量。
第二个维度是量和价：这就有四个组合变量：量涨价涨、量跌价跌、量跌价涨、量涨价跌。其中有两个是量价同方向的，另两个是量价相互背离的。
第三个维度是买和卖：这个维度就两个变量：卖方、买方。
所以咱们分析问题，都是建模推导问题，不瞎念顺口溜。
（4）
有人说，应该还有第四个维度啊：主力资金和庄家啊。
什么：
吸筹阶段：做买方，平缓量涨价涨
洗盘阶段：做买方，量跌价跌和量跌价涨反复交替
拉升阶段：假做买方真做卖方，量涨价涨
出货阶段：做卖方，量涨价跌
其实我不想谈这个维度，因为中国股市打到现在这样，国家队都不能左右，就如同三国演义初期，全是山头，谁也不能归拢谁。
（5）
股票在上升趋势。
一、量涨价涨：
卖方：股票在上升趋势，而且这几天（今天）也是成交量也在放大、价格也在涨价，那说明行情很好啊。一部分卖家觉得自己已经挣不少钱了，所以乘行情好赶快卖掉挣钱走人。还有的一部分卖家观察了好几天，感觉行情这么好还能再持续几天，就会先捂着再等等看。但大多数人小富即安，已经满足了，赶快赚点小钱喜滋滋的。
买方：行情好啊，感觉应该还能继续涨啊。赶快买买买。难道他不怕买在最高点当接盘侠吗？嘿嘿嘿，这就是中国韭菜，完全是情绪带着走，哪管什么过去分析-这几天分析-下五天分析。看着K线就看不明白，还冷静分析？还有方法地分析？算求，赌一把，能挣则挣，行情这么好，我就不信我是最后那一波。所以中国股市里的每个人都认为自己是最精明的，说起股票都有自己的一套逻辑。
建议：
卖方：卖，见好就收；
买方：建议观望但我怀疑没人听我话，肯定你不买就还涨、你再不买我再涨，等你实在管不了那么多了，咣一下买进去，对不起，你就是最后接盘侠。
二、量跌价跌：
卖方：股票在上升趋势，但是出现了量跌价跌现象，这是要行情反转啊。所以卖方都争先恐后想卖。
买方：有的买方认为这也是要行情反转，所以赶快收紧口袋观望。有的买方认为这就是上升趋势啊，这可能是缓口气继续往上攻，赶快乘此机会买进去啊。所以得看
建议：
卖方：卖
买方：建议观望
三、量跌价涨
卖方：股票在上升趋势，但是量不涨了、缩量了。也就是说：市场上的大白菜少了，但是价格上升了，也就是说，还是有许多人想吃大白菜，所以给出了更高价希望买到大白菜。
买方：股票在上升趋势，如果咱们不考虑有庄家因为小盘股微盘股而拿到了足够的筹码可以自由控盘这个情况，那就该买就买啊。
建议：
卖方：卖高价
买方：买啊
四、量涨价跌
卖方：股票在上升趋势，成交量在放大，成交价格却在下跌，说明市场上的大白菜开始多了起来啊。这是典型的行情要反转。卖，果断卖。
买方：谨慎观望吧
建议：
卖方：卖
买方：不买
有人说，一方想卖，一方不想买，这不就成不了买卖么？对对。所以会有人不断降价希望出货，有人看到价格比最高点时便宜太多了，心动了，就有人做了接盘侠。
（5）
股票在下降趋势。
一、量涨价涨
卖方：股票在下降趋势，但是成交量在放大、成交价格也在上涨，说明行情有反转迹象啊。这是要止跌的迹象。卖方就不要急着卖了，等行情真的进入上涨趋势了，再卖给好价格。
买方：行情这是要变好，那些好不容易解了套的人肯定想赶快卖股票，焦虑压力太大了，嘿嘿嘿，正好买进。
建议：
卖方：谨慎观望
买方：买进
二、量跌价跌
卖方：股票在下降趋势，成交量也在下滑缩小，价格也在跌，唉，这就是还在往深里跌啊。如果家里有其他事急需要用钱，那只能割肉，如果不急着用钱，只能等着量涨价涨时再说。
买方：股票在下降趋势，而且还在往深里跌，那也再等等吧，别抄底抄在半山腰。
建议：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bce585ec733cd07123213df2f633170d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43a0282b312cfc0131cefe0b64592b54/" rel="bookmark">
			ASP.NET Core基础之用扩展方法封装服务配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阅读本文你的收获 了解C#中的扩展方法机制学会在ASP.NET Core 中，用扩展方法封装服务配置，使得代码更加简洁 一、什么是扩展方法 扩展方法使能够向现有类型添加方法，而无需创建新的派生类型、重新编译或以其他方式修改原始类型。
扩展方法的特点 扩展方法被定义为静态方法，但它们是通过实例方法语法进行调用的。
如何定义扩展方法 它们的第一个参数指定该方法作用于哪个类型，并且该参数以 this 修饰符为前缀。
例子：将字符串转换为Int
//EString类里有一个ToInt的静态方法， //他接收一个自身参数this，类型为string，this string必须在方法参数的第一个位置 namespace WebApplication1.Extensions.StringEx { public static class EString { ///&lt;summary&gt; ///将字符串转换为Int ///&lt;/summary&gt; ///&lt;paramname="t"&gt;&lt;/param&gt; ///&lt;returns&gt;当转换失败时返回0&lt;/returns&gt; public static int ToInt(this string t) { int id; int.TryParse(t, out id); //这里当转换失败时返回的id为0 return id; } } } using WebApplication1.Extensions.StringEx; //使用ToInt扩展方法 string str="123"; str.ToInt(); //编译时会转换成：EString.ToInt(str); 分析：string类型里面本身没有ToInt方法，通过扩展方法，给string类型扩展了一个ToInt()方法
二、实用案例：在ASP.NET Core当中封装Swagger的配置 开发环境：
操作系统： Windows 10 专业版
平台版本是：.NET 6
开发框架：ASP.NET Core WebApi
开发工具：Visual Studio 2022
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43a0282b312cfc0131cefe0b64592b54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9184a71660b1c9b69c4d6fbc7b463f2/" rel="bookmark">
			Cesium介绍及3DTiles数据加载时添加光照效果对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Cesium简介 Cesium原意是化学元素铯，铯是制造原子钟的关键元素，通过命名强调了Cesium产品专注于基于时空数据的实时可视化应用。熟悉GIS开发领域的读者都知道，Cesium是一个用于创建3D地理空间应用程序的开源JavaScript库，它允许开发人员在Web浏览器中构建高性能的虚拟地球应用，支持地球上的各种地理空间数据可视化和交互。Cesium主要有以下特点
1.跨平台性: Cesium可以在支持WebGL的各种现代浏览器上运行，包括Google Chrome、Mozilla Firefox、Microsoft Edge等。这使得开发人员能够在不同的平台上提供一致的3D地理空间体验。
2.高性能: Cesium通过使用WebGL技术，以及一系列性能优化和地理空间算法，实现了高性能的3D可视化。这使得它能够处理大规模的地理数据，包括地形、遥感影像、矢量数据等。
3.地理数据支持: Cesium支持多种地理数据格式，包括GeoJSON、KML、CZML等。这使得开发人员能够轻松地集成各种地理信息数据源，从而创建丰富多样的地理空间应用。
4.实时渲染: Cesium支持实时渲染，可以在运行时动态加载和更新地理数据。这使得应用程序能够实时反映地球上的变化，如天气、交通流量等。
5.可定制性: Cesium提供了灵活的API和插件系统，允许开发人员定制和扩展功能。用户可以根据特定需求添加自定义图层、效果和控制器，以满足其应用程序的要求。
6.开源和社区支持: Cesium是一个开源项目，其源代码可在GitHub上获得。这意味着开发人员可以自由查看、修改和共享代码。此外，Cesium有一个活跃的社区，提供了丰富的文档、示例和支持，使开发者能够更轻松地学习和使用这个库。
Cesium广泛应用于多个领域，包括地理信息系统（GIS）、地图服务、军事仿真、科学研究等。它被用于构建虚拟地球应用、飞行模拟、城市规划、自然灾害监测等各种应用场景。
二、3DTiles介绍 前几篇文章中介绍了香港、澳门、台湾、那霸等地区的3DTiles数据；作为构建三维实景的重要数据支撑，这些3DTiles数据在构建三维场景方面比地形瓦片数据在精度上更好，效果表现上更佳。
3D Tiles是Cesium团队提出的一种用于以高效、可扩展的方式存储、传输和渲染大规模3D地理数据的开放规范。该规范由Cesium团队提出，并被许多GIS和虚拟地球应用采用。它主要有以下特点：
1.瓦片（Tiles）结构 3D Tiles使用一种分层的、基于瓦片的结构来组织3D地理数据。每个瓦片包含一个小块的地理信息，这些瓦片可以根据视点的远近进行逐级加载，以实现高效的数据传输和渲染。
2.地理空间数据 3D Tiles支持包括地形、建筑物、植被、点云等在内的各种地理空间数据。这使得它适用于多种应用场景，如城市建模、虚拟地球、地球科学等。
3.支持的数据类型 3DTiles瓦片支持的数据类型包括：
地形瓦片（Terrain Tiles）： 用于表示地球表面的高程数据，支持地球的地形模型。批量化模型瓦片（Batched 3D Model Tiles）： 用于表示建筑物、桥梁、树木等复杂的3D模型。点云瓦片（Point Cloud Tiles）： 用于表示大规模的点云数据，如激光雷达扫描数据。3D模型瓦片（3D Model Tiles）： 用于表示单个3D模型或简单的模型集。
4.瓦片格式 3D Tiles主要使用glTF格式来表示3D模型数据。glTF是一种用于传输3D模型的开放标准，它支持纹理、几何体、材质等多种3D图形元素。
5.优势 3DTiles主要有以下三方面的优势：1.高效性能： 3D Tiles的分层结构允许按需加载，从而提高了性能并降低了网络传输和内存使用。通用性： 3D Tiles适用于不同类型的3D地理数据，使其成为在虚拟地球应用和地理信息系统中通用的标准。可扩展性： 由于其开放的规范，3D Tiles可以灵活地扩展以支持新的数据类型和应用需求，包括模型单体化等新型应用。
三、3DTiles添加光照效果对比 3DTiles在Cesium上表现力，离不开光照效果表达。启用太阳光照，能够使3D模型显示更加真实，具有层次感，下面以澳门3DTiles数据加载，并关闭和启用关照进行对比。
首先关闭光照，使用正常流程进行显示
let tileset = await Cesium.Cesium3DTileset.fromUrl( "http://localhost:8803/tileset.json" ); viewer.scene.primitives.add(tileset); viewer.scene.globe.depthTestAgainstTerrain = false; 在这里未启用光照，只是将tileset对象添加到primitives中，同时depthTestAgainstTerrain设置为false。效果如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9184a71660b1c9b69c4d6fbc7b463f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f20ae4d9b9917d55da12b5c640cf2bf9/" rel="bookmark">
			网络与IO
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		netty
https://www.cnblogs.com/nanaheidebk/p/11025362.html
netty基础知识_netty和websocket区别-CSDN博客
Netty核心概念、架构及用法 - 知乎（有图好理解）
IO
java之NIO简介_nio java-CSDN博客
io、nio、tcp协议、socket、websocket、netty、tomcat_soket nio netty-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f83ad0c3b39c84ec16622ec600091e6a/" rel="bookmark">
			uniapp scroll-view用法[下拉刷新,触底事件等等...](4)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言:可滚动视图区域。用于区域滚动 话不多说 直接上官网属性 官网示例
讲一下常用的几个
@scroll 滚动时触发
@scrolltoupper 滚动到顶部或左边，会触发 scrolltoupper 事件
@scrolltolower 滚动到底部或右边，会触发 scrolltolower 事件
1.纵向滚动 设置scroll-y="true" 开启纵向滚动功能
&lt;view&gt; &lt;scroll-view :scroll-top="scrollTop" scroll-y="true" class="scroll-Y" @scrolltoupper="upper"	@scrolltolower="lower" @scroll="scroll"&gt; &lt;view id="demo1" class="scroll-view-item uni-bg-red"&gt;A&lt;/view&gt; &lt;view id="demo2" class="scroll-view-item uni-bg-green"&gt;B&lt;/view&gt; &lt;view id="demo3" class="scroll-view-item uni-bg-blue"&gt;C&lt;/view&gt; &lt;/scroll-view&gt; &lt;/view&gt; 2.横向滚动 设置scroll-x="true" 开启横向滚动功能
&lt;view&gt; &lt;scroll-view :scroll-top="scrollTop" scroll-x="true" class="scroll-Y" @scrolltoupper="upper"	@scrolltolower="lower" @scroll="scroll"&gt; &lt;view id="demo1" class="scroll-view-item uni-bg-red"&gt;A&lt;/view&gt; &lt;view id="demo2" class="scroll-view-item uni-bg-green"&gt;B&lt;/view&gt; &lt;view id="demo3" class="scroll-view-item uni-bg-blue"&gt;C&lt;/view&gt; &lt;/scroll-view&gt; &lt;/view&gt; 注意：scroll-view本身的display:flex不生效、如果想实现display：flex功能，则可以给scroll-view加上white-space: nowrap，给内容容器加上display:inline-block 3.触底事件 @scrolltolower 滚动到底部或右边，会触发 scrolltolower 事件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f83ad0c3b39c84ec16622ec600091e6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc0c1148a0d8a2d70370859665738243/" rel="bookmark">
			测试——Bug&#43;用例篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、如何创建Bug 创建Bug的要素：
问题出现的版本：edge 版本 120.0.2210.144 (正式版本) (64 位)问题出现的环境：Windows家庭版10出现的步骤：1、打开edge浏览器，输入网址，2、等待页面渲染完成，发现与预期不符预期结果：二维码与登录界面不会遮挡，都会显示出来实际结果：二维码被遮挡住Bug归属：前端问题Bug等级：一般 2、Bug的级别 Bug存在着在不同的严重级别，不同Bug级别惩罚机制不一样，不同的Bug等级也跟开发人员的开发质量有直接关系。
常见的级别：一般、次要、崩溃、严重。
3、Bug的生命周期 New：测试人员创建了一个BugOpen：开发人员要去确认是否是Bug，是Bug的话状态就改为OpenRejected：不是Bug的话就拒绝Fixed：开发人员修复完成之后将Bug的状态改为FixedDelay：确认是Bug之后，如果Bug的优先级比较低且开发人员不能立即修复Bug，状态就改为DelayClosed：Bug确认修复完成之后，测试人员将Bug改为ClosedReopen：Bug确认修复未完成，测试人员将Bug状态改为Reopen 其状态转换图为：
4、跟开发产生争执怎么办？ 多反思自己，是不是Bug创建的时候描述的不太清楚，批判性思维开发人员对Bug级别不认可，Bug的定级一定要有理有据（测试人员需要明确企业Bug定级规范，拿着规范去跟开发人员沟通，为什么这样定级）合理有好的进行沟通，站在用户的角度进行反问：如果你是用户，你能接受这样的功能吗（提Bug必然会增加开发人员的工作量，有些小问题不想解决）不接能够发现问题，最好也能提出解决问题的方案（仅供开发参考）如果确实是Bug，友好沟通已经不能解决问题，那么就召开Bug评审，需要有相关的代表来参加：产品代表、开发代表、测试代表： 1）如何解决bug
2）如何预防类似的Bug再发生
5、测试用例 万能公式：功能测试+性能测试+界面测试+兼容性测试+易用性测试+安全测试
功能测试：可能来时需求文档（软件的功能），可能来自生活经验（水杯）性能测试：功能没有问题不代表性能一定是好的，性能往往表现在一些极端的情况下界面测试：颜色、形状、大小、材质、文字、输入框、图片......可以看到的所有元素兼容性测试：浏览器兼容性、版本兼容性、系统兼容性、数据兼容性易用性测试：软件是否具备简单易上手的属性，是否有提示安全测试：密码是否加密、数据库是否对隐私密码加密、是否防止SQL注入 SQL注入：
假如在前端搜索输入的关键词是 1 or 1 = 1
其代码为 ：select id , info from where name = 1 or 1 = 1;(1 = 1 恒成立)
导致全表以数据返回
6、测试方法 等价类
定义：依据需求将输入（特殊情况下会考虑输出）划分为若干个等价类，从等价类中选出一个测试用例，如果这个测试用例测试通过，增容认为所代表的等价类测试通过，这样就可以用较少的测试用例达到尽量多的功能覆盖，解决了不能穷举测试的问题。等价类分为无效等价类和有效等价类： 无效等价类：针对需求文档的要求是没有意义的集合。 有效等价类：针对需求文档的要求时有异议的集合。
步骤：首先确实有效等价类和无效等价类，然后再编写测试用例。 边界值：是指有效边界值和无效边界值
判定表（设计测试用例步骤）：
确认输入条件和输出条件找出输入条件和输出条件之间的关系画判定表根据判定表编写测试用例 场景设计法：基本事件流和备选事件流（在基本事件流的过程中的意外）
错误猜测法：依赖测试人员的工作经验和积累
7、测试分类 灰盒测试和白盒测试都需要关注代码，一般都是开发人员使用的，但是测试人员也可以使用灰盒测试。
问：为什么不能用灰盒测试来取代黑盒测试和白盒测试？ 答：因为灰盒测试没有白盒测试那么详尽，也没有黑盒测试广度大，所以不能取代。
问：那种测试方法用的多？ 答：黑盒测试和白盒测试测试人员都会使用到，在工作根据具体情况来选择使用黑盒测试和白盒测试，通常情况下测试人员使用黑盒测试多一些。
问：自动化测试能取代人工吗？ 答：不能，自动化测试也是测试人员来写的，是有局限性的，而且自动化测试只是协助测试人员进行测试的一种工具。
冒烟测试： 开发人员完成开发任务之后，交给测试人员进行测试的第一步，评估软件/系统是否具备测试的条件。
回归测试： 对历史版本、历史功能进行测试，保证功能都是符合要求的，一般用自动化来进行回归测试
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cf3b5f3604fca5f7cd33f7752538feb/" rel="bookmark">
			pdf 转html 在线预览和查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方案一： pdf2htmlex package com.realize.controller; import cn.hutool.http.HttpUtil; import com.alibaba.fastjson2.JSONObject; import com.realize.util.MsgUtil; import com.realize.util.OssUtil; import com.realize.util.PdfConvertUtil; import com.realize.util.StreamGobbler; import lombok.extern.slf4j.Slf4j; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.ModelAttribute; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RestController; import java.io.*; import java.nio.charset.Charset; import java.nio.file.Files; import java.nio.file.Paths; import java.util.List; @RestController @Slf4j public class ParserController { @GetMapping("/test") public String test() { return "test"; } // @PostMapping("/parseHtml") // public JSONObject parseHtml(@ModelAttribute("htmlUrl") String htmlUrl) { // try (Playwright playwright = Playwright.create()) { // Browser browser = playwright.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2cf3b5f3604fca5f7cd33f7752538feb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc98484595fb3e66a3e092c6d0a389d8/" rel="bookmark">
			我的docker常用基础命令 docker命令 --- 含打包镜像 批量 save image- 含docker工具镜像- diy-nginx - 含curl nslookup
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# docker工具镜像推荐
打包过程其实很简单
FROM nginx RUN apt update -y &amp;&amp; apt -y install telnet &amp;&amp; apt install inetutils-ping -y &amp;&amp; apt -y install dnsutils &amp;&amp; apt install net-tools -y &amp;&amp; apt install curl -y EXPOSE 80/tcp ENTRYPOINT ["nginx"] CMD ["-g","daemon off;"] docker build -t nginx:telnet . # 打包 docker run -d --name nginx-telnet -p 9080:80 nginx:telnet # 启动容器 docker exec -it nginx-telnet bash # 进入容器 # 推荐文章：https://blog.csdn.net/weixin_44953658/article/details/116021628
批量 分开打包 多个镜像 脚本：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc98484595fb3e66a3e092c6d0a389d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd6656f48af3a121650e541e857c5c74/" rel="bookmark">
			3d导模型赋予材质方法---模大狮模型网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给3D模型赋予材质的方法可以根据您使用的软件和工作流程而有所不同。以下是一般的步骤，您可以根据自己的情况进行调整：
准备模型：首先，确保您的模型已经完全建模并进行了UV映射。UV映射是将2D纹理坐标应用到3D模型表面的过程，以便正确地贴图。
创建材质：打开材质编辑器或材质管理器，创建一个新的材质。您可以根据需要选择颜色、纹理、反射率等属性来设置材质的外观。
贴图应用：为了给模型添加纹理，您可以选择使用已有的图片贴图或者创建自己的纹理。在材质编辑器中，将所选纹理贴图应用到相应的通道，如漫反射、法线、置换等。这样，模型的表面就会显示出所应用纹理的效果。
分配材质：选择要赋予材质的模型或模型的部分，然后将创建的材质分配给它们。这可以通过拖放材质到模型上，或者在软件的对象属性面板中选择材质来实现。
调整材质属性：根据需要，您可以进一步调整材质的各种属性，如颜色、透明度、反射等。这可以通过在材质编辑器中修改相应的参数来完成。
预览和渲染：在3D视图或预览窗口中预览3d模型，并确保材质的外观符合预期。如果一切正常，可以进行最终的渲染以生成最终的图像或动画。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/489c4c5c7fe3dde99a115cc2c368a7f9/" rel="bookmark">
			使用Linux SDK客户端向AWS Iot发送数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考链接：
https://ap-southeast-1.console.aws.amazon.com/iot/home?region=ap-southeast-1#/test
此篇文章用于测试，使用Linux SDK客户端向AWS Iot发送数据，准备环境如下：
1、客户端环境准备 1.1 客户端操作系统 虚拟机一台： Red Hat Enterprise Linux release 8.7 (Ootpa) 1.2 域名解析 确保客户端可以解析AWS iot 的终端节点，可以在下图查询并解析成功
1.3 软件安装 客户端版本语言为Python，且版本需要为Python 3.8及以上。
git安装，否则脚本无法正常运行
2、AWS云端操作 2.1 连接设备 2.2 创建新事物 2.3 平台和SDK 2.4 下载连接工具包 注意：此工具包为必须下载项目
2.5 等待消息 3.客户端操作 3.1 解压基础包 unzip connect_device_package.zip 3.2 脚本加权限并启动 chmod +x start.sh
./start.sh
3.3 故障解决 start.sh脚本中需要去向github的官网下载代码，服务器在国外，国内经常会卡住。
可以通过两种方法解决国内无法正常访问github的问题：
第一种就是修改hosts文件：
https://blog.csdn.net/oyjl__/article/details/132262919
第二种就是使用梯子翻墙软件
4、测试成功 4.1 发送请求 可以把“hello world”修改为自定义的json数据，便于处理
{'deviceId': 'ac1234', 'currentTemp': 21.8, 'desiredTemp': 24, 'mode': 'auto', 'power': 'off'}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/489c4c5c7fe3dde99a115cc2c368a7f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1fd662958546b5da3085a420332e2f7/" rel="bookmark">
			将AWS iot消息数据发送Kinesis Firehose Stream存向S3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 观看此文章之前，请先学习AWS iot的数据收集：
使用Linux SDK客户端向AWS Iot发送数据-CSDN博客
1、工作原理： 1.1 规则 规则可让您的设备与 AWS 服务进行交互。分析规则并根据物品发送的消息执行操作。您可以使用规则来支持任务，例如补充或筛选从设备接收的数据。
1.2 目的地 目的地是定义规则引擎可将数据路由至何处的资源。目的地可以跨规则重复使用，并且可能需要经过确认或配置才能使用。目的地可让规则引擎将数据发送到未与 AWS IoT 原生集成的其他服务。
2、创建消息路由 2.1 点击消息路由，并创建规则 2.2 规则名称 2.3 选择SQL语句 使用以下值输入 SQL 语句：SELECT &lt;Attribute&gt; FROM &lt;Topic Filter&gt; WHERE &lt;Condition&gt;。例如：SELECT temperature FROM 'iot/topic' WHERE temperature &gt; 50。 要了解更多信息，请参阅 AWS IoT SQL 参考。
SELECT * FROM 'sdk/test/python' 2.4 操作写入KFS 2.5 创建Firehose流
源选择 Direct PUT 目标选择Amazon S3
2.5 创建存储桶 2.6 设置目标 2.7 创建新角色 至此，完成消息路由的创建
3、测试 3.1 客户端操作 3.2 检查S3数据 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0204e2b6ae92b38f3b27c6c7593c792/" rel="bookmark">
			sql文件导入：ERROR : (2006, ‘MySQL server has gone away’...)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 mysql备份、恢复亦或迁移，对运维工作者来说，都是一项无法推脱而又不得不做的工作。
这里我将就mysql导入sql文件时报【ERROR : (2006, ‘MySQL server has gone away’...)】这一问题进行解决。
分析及解决 从字面上看，这玩意儿的意思就是【数据库服务丢了，或者断开连接了】
为什么呢？十有八九是客户端与mysql服务端之间的通讯发生了问题，导致服务端拒绝或被动断开了与客户端的连接，最终使sql文件导入工作无法继续进行。
因此，你可能需要从以下几点来判断具体原因：
1、sql文件过大，超出mysql约定文件缓冲区大小（由此，也会引发Your SQL statement was too large错误） max_allowed_packet是MySQL的一个配置参数，用于控制单个查询或数据包的最大大小。
max_allowed_packet的单位是字节（bytes）。
通过配置文件或者动态地修改该参数，可以设置MySQL服务器允许的最大数据包大小。默认情况下，该参数的值为4MB（4 * 1024 * 1024 bytes）或其他值，你需要结合实际比较文件与它的大小，如果文件大于它，那就没办法正常导入。
执行sql语句，看看mysql约定的文件缓冲区大小（下图是我已经调整好的100MB值，默认是4MB，也就是4194304）
show global variables like 'max_allowed_packet'; 如果你的sql文件超过4MB则可能需要更改这个默认值， 才能执行：
通过sql暂时解决，重启mysql后失效：
set global max_allowed_packet=1024*1024*100; 在mysql配置文件 [mysqld] 里增加max_allowed_packet属性来永久解决，这个具体数值可以自由调整
max_allowed_packet = 100M 2、 MySQL连接超时，这个可能是网络原因，也有可能是mysql的wait_timeout配置设的太低了 使用tcping来看看这个mysql端口是否稳定，如果出现频率较高的丢包、延时，则很有可能是网络原因
其次可能是mysql的wait_timeout配置设置太低，下图表示mysql链接在无操作28800秒（也就是8小时）后被自动关闭，这个数值是正常的
这里，你可以通过暂时更改wait_timeout属性来解决，重启mysql服务端后失效
set global wait_timeout=86400 在mysql配置文件 [mysqld] 里增加wait_timeout属性来永久解决
[mysqld] wait_timeout=86400 3、MySQL服务端主动断开（不排除服务端重启可能） 查看mysql日志，看看是不是它有事没事会自动重启
你也可以通过sql来看看它最新一次启动至今的时间间隔，单位是秒
show global status like 'uptime'; 这种是小概率事件，一般不会发生
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78b40043002a8b772099540e72e26fb1/" rel="bookmark">
			2024-01-24（ElasticSearch）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.mysql和elasticsearch的架构： 2.IK分词器利于分中文词汇。 底层是有一个中文字典，这个字典中的中文词汇也是可以拓展的和禁用某些词。
3.mapping常见属性： type：数据类型
index：是否索引
analyzer：分词器
properties：子字段
4.type常见属性： 字符串：text，keyword
数字：long，integer，short，byte，double，float
布尔：boolean
日期：date
对象：object
5.ES通过restful请求操作索引库、文档。请求内容用DSL语句来表示。 创建索引库和mapping的DSL语法如下：
6.ES中的几个核心概念 7.文档操作 创建文档：POST/索引库名/_doc/文档id{json文档}
查询文档：GET/索引库名/_doc/文档id
删除文档：DELETE/索引库名/_doc/文档id
修改文档：
全量修改：PUT/索引库名/_doc/文档id{json文档}
增量修改：POST/索引库名/_update/文档id{"doc":{字段}}
8.DSL语句可以操作索引库和文档，但是作为Java程序员，要用Java代码来操作索引库和文档，因此我们引入了RestClient（ES官方提供）这个类来帮助我们操作ES。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b07373238ab937198883fdbb395e75c4/" rel="bookmark">
			Gateway网关拦截器的ServerWebExchange
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ServerWebExcahnge的解释如下：
Contract for an HTTP request-response interaction. Provides access to the HTTP request and response and also exposes additional server-side processing related properties and features such as request attributes.
大概是说：ServerWebExchange是一个HTTP请求-响应交互的契约。提供对HTTP请求和响应的访问，并公开额外的服务器端处理相关属性和特性，如请求属性，有点像Context的角色。
在 HTTP 协议中，请求头和请求体是请求的重要组成部分，ServerWebExchange 提供了丰富的方法来对其进行处理。
请求数据读取 例如，可以通过 ServerWebExchange.getRequest().getHeaders() 方法获取请求头：
ServerHttpRequest request = exchange.getRequest(); HttpHeaders headers = request.getHeaders(); String userAgent = headers.getFirst(HttpHeaders.USER_AGENT); 可以通过 ServerWebExchange.getRequest().getBody() 方法获取请求体：
ServerHttpRequest request = exchange.getRequest(); Mono&lt;String&gt; requestBody = request.getBody().map(dataBuffer -&gt; { byte[] buffer = new byte[dataBuffer.readableByteCount()]; dataBuffer.read(buffer); DataBufferUtils.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b07373238ab937198883fdbb395e75c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6da6364c71716d512d3473b1113b99ce/" rel="bookmark">
			PHP中一些特征函数导致的漏洞总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一部分： 特征函数
接触到几个常用的函数： \=\= \=\=\= md5 intval strpos in_array preg_match str_replace php用这些函数实现过滤一些代码，漏洞可能有一些特性，利用这些特征代码进行对比；账号密码对比；强制检测数据类型等都会用到这些函数，接下来具体讲解一下各个函数的使用：
= 赋值== 弱类型对比，但是不会对比类型，这种存在缺陷绕过，举个例子，判断一个值是否==1，这种情况用户输入的+1,1.0,1a都会被当成正确的情况进行处理,这点在数据库中也是，当输入的值是字符串类型的时候，1a和1对比时，1a只取1和1对比，和后面的a无关，利用这点，如果1a=1报错，说明是数字型，如果1a=1不报错，说明时字符型，在这里时为了说明如果不进行强类型的对比1后面可以接入字符串。
让我们来拓展一下，如果只进行弱类型对比，假设密码用md5进行加密了存放在数据库中，存放的密码和用户输入的密码的md5加密值中间用/=/=判断而不是用/=/=/=判断的后果，就是可能产生hash碰撞，如下图所示。：
这样就达到了绕过的目的。. === 对比，会对比类型
此时可以使用数组进行绕过，对于数组name[]来说$_GET[‘name’]获取到的值就是null，让我们来看个例子：
如果输入的值是name[]=1&amp;password[]=2的结果就是获取到的值为null，在图中上面的部分，判断的值也就相等了，从而达到绕过的目的。这种情况在ctf中比较常见。
intval()函数：就是把其他类型的东西变成10进制int类型的数据。具体用法参考：https://www.runoob.com/php/php-intval-function.html
这个东西，可以用来过滤sql注入，比如id=1 and 1=1 ，使用这个函数，只能获取到id = 1 ，同时根据文档里的这段话： 语法
int intval ( mixed $var [, int $base = 10 ] )
参数说明：
$var：要转换成 integer 的数量值。
$base：转化所使用的进制。
如果 base 是 0，通过检测 var 的格式来决定使用的进制：
如果字符串包括了 “0x” (或 “0X”) 的前缀，使用 16 进制 (hex)；否则，
如果字符串以 “0” 开始，使用 8 进制(octal)；否则，
将使用 10 进制 (decimal)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6da6364c71716d512d3473b1113b99ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/394861f27d5fbf0231b897e024dfbd56/" rel="bookmark">
			c#模板设计模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 C# 中，模板设计模式是一种行为型设计模式，它允许定义一个算法的框架，并允许子类为一个或多个步骤提供实现。模板设计模式通过定义一个算法的骨架，而将一些步骤的实现延迟到子类中，以实现代码复用和提高扩展性。
以下是模板设计模式的关键要点：
抽象类：定义算法的框架，并包含一个或多个抽象方法，这些抽象方法的具体实现将由子类提供。
具体实现：子类继承抽象类并实现其中的抽象方法，以提供特定步骤的具体实现。
模板方法：定义在抽象类中的方法，它包含算法的框架和调用各个步骤的顺序。这些方法可以包含一些默认的实现，也可以调用抽象方法。
钩子方法：在模板方法中，可能包含一些可选的步骤，这些步骤可以在子类中选择性地实现，称为钩子方法。
示例：
abstract class DataProcessor { // 模板方法 public void ProcessData() { ReadData(); TransformData(); if (IsDataValid()) { LoadData(); } } // 抽象方法 protected abstract void ReadData(); protected abstract void TransformData(); protected abstract void LoadData(); // 钩子方法 protected virtual bool IsDataValid() { return true; // 默认实现，可由子类选择性地覆盖 } } class XmlDataProcessor : DataProcessor { protected override void ReadData() { Console.WriteLine("Reading data from XML file"); } protected override void TransformData() { Console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/394861f27d5fbf0231b897e024dfbd56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd1a4bb87c3f2f0838797f044c307a3b/" rel="bookmark">
			Linux 60秒快速性能分析操作手册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 博文内容为 《BPF Performance Tools》 读书笔记整理，对原书提到的命令做了简单扩充
博文内容涉及 Linux 60秒快速性能分析命令的简单说明以及指标解释：
uptimedmesg | tail &amp;&amp; cat /var/log/messagesvmstat 1mpstat -P ALL 1pidstat 1iostat -xz 1free -msar -n DEV 1sar -n tcp，ETCP 1sar -n SOCK 1 3top 理解不足小伙伴帮忙指正
平平淡淡的接受这本就属于我的人生，每天不会想太多杞人忧天的事情，累了倒头就睡，醒了就接着继续自己没有走完的路，不再去过多的关注自己的结果，用心感受当下的每一天，感受自己走过的和正在走的路，不颓废，不折磨自己，真好！ —知乎(三冬三夏)
Linux 60秒分析 下面这个清单适用于任何性能问题的分析工作，也反映了笔者在实际工作中，当登录到一台表现不佳的 Linux 系统中后，在最初60秒内通常会进行的操作。
uptimedmesg | tail &amp;&amp; cat /var/log/messagesvmstat 1mpstat -P ALL 1pidstat 1iostat -xz 1free -msar -n DEV 1sar -n tcp，ETCP 1sar -n SOCK 1 3top uptime uptime 命令用于显示系统已运行的时间，并提供系统负载平均值的信息。以下是 uptime 命令提供的信息解释：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd1a4bb87c3f2f0838797f044c307a3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a64a2f1bfe4e3cb52191808b43ca9812/" rel="bookmark">
			基于cubeMX的正点原子miniSTM32对W25Q64的存储使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实现目标
使用cubeMX建立项目工程，结合正点原子提供的hal库对W25Q64闪存调用的例程，实现W25Q64的读写。
二、实现过程
1、首先建立cubeMX工程，其他项设置不再叙述，只看连接W25Q64的SPI设置，这里使用SPI1：
设置完成后，使用SPI的引脚会自动标注，如下图
2、手动设置添加W25Q64的片选引脚PA2为输出引脚：
3、设置完成，生成代码
4、打开项目代码后，可看到已经生成的SPI.C代码：
5、添加正点原子hal库的w25q64驱动程序，如下图，注意先添加.C程序后也要添加w25q64.h的头文件路径，具体添加过程不再叙述。
6、添加完成后，需要修改一部分w25q64.c和w25q64.h，首先将片选PA2引脚重新宏定义置高低电平：
7、然后在w25q64.c中添加一个1us的延时函数，因为后面驱动函数中要用到1us延时：
8、然后将w25q64.c中原有初始化SPI的程序代码注释掉
9、最后替换驱动函数中所有的片选引脚的置高和置低语句，如下图：
10、main函数中仍然使用正点原子的例程代码如下
可以实现将TEXT_Buffer数组的数据写入flash中，地址为倒数第100个地址，该地址也可以更改为从0地址开始写，然后从该地址读出数据，显示在屏幕上，从而实现了数据存储在flash中，掉电后flash中的数据不会清空。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ed2b09345fb2d4188d64402d95e5a2e/" rel="bookmark">
			核桃的数量---蓝桥杯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 思路： 题目所代表的意思就是a,b,c这三个必须是核桃数量的因子，即a,b,c三个的最小公倍数
#include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; // int main() { int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; int d=a*b/__gcd(a,b); int e=d*c/__gcd(c,d); cout&lt;&lt;e; // 请在此输入您的代码 return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34dc7867bd8600c87b84b4221c111630/" rel="bookmark">
			R语言-检验正态性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.为什么要检验正态性 首先需要明确正态性与正态分布是有区别的，正态分布（标准分布）是统计数据的分布方式，是个钟形曲线，已平均值为对称轴，数据在对称轴两侧对称分布。正态性是检验实际数据与标准正态分布的相似程度，相似程度高，说明具有正态性。
很多的统计方法是基于正态分布使用的，如T检验、方差检验等，因此需要检验数据的正态性。
2.检验正态性的方法 检验正态性常用的方法包括：
1.看分布
正态分布是个钟形分布，因此我们可以制作直方图，观察数据是否具备，在均值两侧数据对称分布的特点。
2.shapiro-wilk(W检验)
提出者是shapiro和wilk，适合样本量在3~5000
3.Kolmogorov-Smirnov（K-S检验）
适合大样本，5000以上
4.QQ图
QQ图全称quantile-quantile(分位数-分位数图)，以此推断样本的分布是否具有正态性
我们构造随机数据，看一下在R中这些检验结果如何：
par(mfrow=c(1,2)) base &lt;- rnorm(4000, mean = 0, sd = 1) base1 &lt;- rnorm(40000, mean = 0, sd = 1) hist(base) ## 1.查看分布 shapiro.test(base) ## 2.w检验 ks.test(base1,"rnorm") ## 3.ks检验 qqnorm(base) ## 4.qq图 w检验的结果：
是否具有正态性的标准：p&lt;0.1是非正态，w越小，越不是正态
Shapiro-Wilk normality test data: base W = 0.99953, p-value = 0.4566 ks检验的结果：
是否具有正态性的标准：p&lt;0.05非正态，D越小，越不是正态
Asymptotic one-sample Kolmogorov-Smirnov test data: base1 D = 4.6795, p-value &lt; 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34dc7867bd8600c87b84b4221c111630/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/077ad11db86c116a7a573a4d98b0994b/" rel="bookmark">
			Element-UI中的el-upload插件上传文件action和headers参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官网给的例子action都是绝对地址，我现在需要上传到自己后台的地址，只有一个路由地址/task/upload
根据 config/index.js配置，那么action要写成/api/task/upload，另外也可以传入函数来返回地址:action="uploadUrl()"。
另外一个问题就是此插件不会默认带上token，需要手动传递。
&lt;el-upload class="upload-demo" action="/api/task/upload" :multiple="false" name="jarfile" :file-list="fileList" accept="application/java-archive" :on-success="onUploadSuccess" :headers="{'Auth-Token': tokenValue}"&gt; &lt;el-button size="small" type="primary"&gt;点击上传&lt;/el-button&gt; &lt;span slot="tip" class="el-upload__tip" style="margin-left: 10px;"&gt;不要重复上传文件，按需上传&lt;/span&gt; &lt;/el-upload&gt; &lt;script&gt; import store from '@/store' export default { data() { return { tokenValue: store.getters.user.token, fileList: [] } }, computed: {}, components: {}, created() {}, methods: { onUploadSuccess(response, file, fileList) { this.fileList = [] if (response.code === 0) { this.form.command = response.data // this.fileList = [{ name: response.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/077ad11db86c116a7a573a4d98b0994b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2d7f1c19359b668271f0b26b9496090/" rel="bookmark">
			Java：获取pdf中某一页的宽度和高度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
目录
一、背景介绍
二、用Java中的方法
三、用Python中的方法
总结
提示：以下是本篇文章正文内容，下面案例可供参考
一、背景介绍 金融业务，经常会涉及到合同盖章，那么盖章的时候就需要知道位置信息。比如第几页，X坐标，Y坐标。那么如果给出的坐标超出了范围，就会导致章盖不成功，那么我们怎么才能知道这个pdf文件中某一页的XY坐标呢？
二、用Java中的方法 Maven依赖： &lt;dependency&gt; &lt;groupId&gt;org.apache.pdfbox&lt;/groupId&gt; &lt;artifactId&gt;pdfbox&lt;/artifactId&gt; &lt;version&gt;2.0.8&lt;/version&gt; &lt;/dependency&gt; 示例代码：
import org.apache.pdfbox.pdmodel.PDDocument; import org.apache.pdfbox.pdmodel.PDPage; public void 输出pdf页面横纵坐标范围() { String pdfPath = "C:\\Users\\86185\\Desktop\\951bb404d7ae4bc0b0152255a6d79c59.pdf"; try (PDDocument document = PDDocument.load(new File(pdfPath))) { PDPage page = document.getPage(1); float width = page.getMediaBox().getWidth(); float height = page.getMediaBox().getHeight(); System.out.println("页面宽度：" + width); System.out.println("页面高度：" + height); } catch (IOException e) { e.printStackTrace(); } } 三、用Python中的方法 代码示例：
import PyPDF2 def get_page_dimensions(pdf_path, page_number): with open(pdf_path, 'rb') as file: reader = PyPDF2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2d7f1c19359b668271f0b26b9496090/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6efbc303df15c9c9008c22233e4a7dbc/" rel="bookmark">
			客户端请求&#43;返回 服务端之间的请求和返回 实现rpc通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：
1.无论什么类型的游戏，我们都会有rpc通信的需求。
2.由于客户端直连的是游戏服，如果工会，匹配之类的服务是单独的服务的话，必然要进行游戏服到业务服之间的转发，我们是否需要再转发时单独定义Req和Res就是我们考虑到的需求。
3.在vega项目中，我们选择了定义了内部协议的req和res，而不是像热江一样做了统一的封装，看起来麻烦了一点，但是实际上却是非常的清晰。 一个案例如下：
1.发出rpc请求 // GuildService.java getRecommendList方法: // 向world服发送请求推荐列表(GuildBizModule.java进行RECOMMEND_LIST协议的处理) BinaryMsg msg = buildBinaryMsg(GuildLogicEnum.RECOMMEND_LIST, role.getRid()); msg.writeInt(role.getLevel()); // 思考下我们的rpc需要什么参数 // 1.req 请求类型，这个我们希望是pb这种强类型的 // 2.rep.class 返回的类型 // 3.ResponseData&lt;Boolean, Rep&gt; 是否远端处理成功，有时候我们先本地扣东西，用于回滚 // 4.hashId 远端在哪个线程执行 我们一般采用类似于actor模型，因此需要告知远端到底在哪个线程执行 S2SHelper.sendMsg2WorldServer(msg, rid, BizType.GUILD, Constants.BIZ_GUILD_DEFAULT_SUBKEY, new RespCacheCallback&lt;&gt;(role) { @Override public void onCallback(BinaryMsg msg) { int result = msg.readInt(); if (result &lt; 0) { handlerError(role, requestId, msg); return; } JSONObject json = msg.readObject(JSONObject.class); // 这个是要返回给客户端的数据 setData是RespCacheCallback setData(json); } }); // 其实，我也不太需要知道当前是哪个类，通过消息号范围即可 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6efbc303df15c9c9008c22233e4a7dbc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d19b70c652e0e1302faf491c1275b892/" rel="bookmark">
			Package g&#43;&#43; is not configured yet.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 安装依赖包提示Package g++ is not configured yet.
root@ubuntu:/opt# dpkg -i build-essential_12.4ubuntu1_amd64.deb (Reading database ... 70742 files and directories currently installed.) Preparing to unpack build-essential_12.4ubuntu1_amd64.deb ... Unpacking build-essential (12.4ubuntu1) over (12.4ubuntu1) ... dpkg: dependency problems prevent configuration of build-essential: build-essential depends on gcc (&gt;= 4:7.2); however: Package gcc is not configured yet. build-essential depends on g++ (&gt;= 4:7.2); however: Package g++ is not configured yet. dpkg: error processing package build-essential (--install): dependency problems - leaving unconfigured Errors were encountered while processing: build-essential 分析过程，可能是安装过程中包版本不一致 root@ubuntu:/opt# dpkg -l |grep gcc iU gcc 4:7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d19b70c652e0e1302faf491c1275b892/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f255ef8fbfa9b0c547c168f75eeefa40/" rel="bookmark">
			【前端小点】Vue3中的IP输入框组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文章记录,如何在vue3项目开发中,使用ip输入框组件.
之前写过vue2版本的ip组件,为了更好的适应vue3,此次进行vue3代码重写
先上效果图:
禁用效果图:
主要是组件的开发,代码如下,可直接拷贝使用.
大概思路就是: 使用四个输入框拼接,然后给输入内容添加校验操作,添加光标移动,
使用v-model语法糖特性
组件: IpAddress.vue &lt;template&gt; &lt;div :class="{ 'disabled': disabled }"&gt; &lt;ul class="ipAdress"&gt; &lt;li v-for="(item, index) in ipAddress" :key="index"&gt; &lt;input :ref="el =&gt; getInputRef(el, index)" v-model="item.value" type="text" class="ipInputClass" :disabled="disabled" @input="checkIpVal(item)" @keyup="$event =&gt; turnIpPosition(item, index, $event)" @blur="handleBlur" @mouseup="handleMouseUp(index)" /&gt; &lt;div&gt;&lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/template&gt; &lt;script lang="ts" setup name="routePage"&gt; import { ref, watch } from 'vue' // 接收来自上层的数据 const props = defineProps(['value', 'disabled']) // 更新数据 const $emits = defineEmits(['update:value', 'blur']) // 存储四个ref const ipInputRefs = ref&lt;HTMLElement[]&gt;([]); // 存储左右标识位 let markFlag = ref([ { left: false, right: false }, { left: false, right: false }, { left: false, right: false }, { left: false, right: false } ]) // 更新标识 let flag = ref(false) // 鼠标点击 const handleMouseUp = (index: any) =&gt; { let input = ipInputRefs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f255ef8fbfa9b0c547c168f75eeefa40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ec9568294555febeb4d3b3329769549/" rel="bookmark">
			设计模式⑧ ：管理状态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、前言二、Observer 模式1. 介绍2. 应用3. 总结 三、Memento 模式1. 介绍2. 应用3. 总结 四、State 模式1. 介绍2. 应用3. 总结 参考文章 一、前言 有时候不想动脑子，就懒得看源码又不像浪费时间所以会看看书，但是又记不住，所以决定开始写"抄书"系列。本系列大部分内容都是来源于《 图解设计模式》（【日】结城浩 著）。该系列文章可随意转载。
二、Observer 模式 Observer 模式 ： 发送状态变化通知
1. 介绍 Observer 即 “观察者”，在 Observer 模式中，当观察对象的状态发生变化时，会通知给观察者。 Observer 模式适用于根据对象状态进行相应处理的场景。
Observer 模式 中出场的角色：
Subject （观察对象）：Subject 角色表示观察对象。Subject 角色定义了注册观察者和删除观察者的方法。此外，他还声明了 “获取现在的状态” 的方法。ConcreteSubject （具体的观察对象）：ConcreteSubject 角色表示具体的被观察的对象。当自身状态发生变化后，他会通知所有已经注册的 Observer 角色。Observer（观察者）：Observer 角色负责接收来着Subject 角色的状态变化的通知。为此，它声明了 update 方法。ConcreteObserver（具体的观察者）：ConcreteObserver 角色负责具体的 Observer。当他的 update 方法被调用后，会去获取要观察的对象的最新状态。 类图如下：
Demo 如下
// 监听者接口 public interface Observer { void update(NumberGenerator generator); } // 监听者实现类 public class NumberObserver implements Observer{ @Override public void update(NumberGenerator generator) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ec9568294555febeb4d3b3329769549/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24b63eb58d326c02ea13ab83903c11d6/" rel="bookmark">
			设计模式-工厂方法模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、工厂方法 1、生活场景 系统常见的数据导出功能：数据导出PDF、WORD等常见格式。
2、工厂方法模式 是类的创建模式，又叫做虚拟构造子(Virtual Constructor)模式或者多态性工厂（Polymorphic Factory）模式。工厂方法模式的用意是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类中。
3、核心角色 抽象工厂角色
这个角色的是工厂方法模式的核心，任何在模式中创建对象的工厂类必须实现这个接口。在实际的系统中，这个角色也常常使用抽象类实现。
具体工厂角色
担任这个角色的是实现了抽象工厂接口的具体JAVA类。具体工厂角色含有与业务密切相关的逻辑，并且受到使用者的调用以创建导出类。
抽象导出角色
工厂方法模式所创建的对象的超类，也就是所有导出类的共同父类或共同拥有的接口。在实际的系统中，这个角色也常常使用抽象类实现。
具体导出角色
这个角色实现了抽象导出角色所声明的接口，工厂方法模式所创建的每一个对象都是某个具体导出角色的实例。
3、核心角色 抽象工厂角色
这个角色的是工厂方法模式的核心，任何在模式中创建对象的工厂类必须实现这个接口。在实际的系统中，这个角色也常常使用抽象类实现。
具体工厂角色
担任这个角色的是实现了抽象工厂接口的具体JAVA类。具体工厂角色含有与业务密切相关的逻辑，并且受到使用者的调用以创建导出类。
抽象导出角色
工厂方法模式所创建的对象的超类，也就是所有导出类的共同父类或共同拥有的接口。在实际的系统中，这个角色也常常使用抽象类实现。
具体导出角色
这个角色实现了抽象导出角色所声明的接口，工厂方法模式所创建的每一个对象都是某个具体导出角色的实例。
4、UML关系图 5、源代码实现 // 客户端角色 public class C01_FactoryMethod { public static void main(String[] args) { String data = "" ; ExportFactory factory = new ExportWordFactory () ; ExportFile exportWord = factory.factory("user-word") ; exportWord.export(data) ; factory = new ExportPdfFactory() ; ExportFile exportPdf =factory.factory("log-pdf") ; exportPdf.export(data) ; } } // 抽象工厂角色 interface ExportFactory { ExportFile factory (String type) ; } // 具体工厂角色 class ExportWordFactory implements ExportFactory { @Override public ExportFile factory(String type) { if ("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24b63eb58d326c02ea13ab83903c11d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c807a1e6259953722212c2f7c7641b41/" rel="bookmark">
			#Uniapp: uni.previewImage(OBJECT) 预览图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 uni.previewImage(OBJECT) 预览图片。 api地址 媒体-图片
示例 handlePreviewImg(current) { const urls = this.rightList.map(x =&gt; x.icon) uni.previewImage({ urls, current }) } OBJECT 参数说明 参数名类型必填说明平台差异说明countNumber否最多可以选择的图片张数，默认9见下方说明sizeTypeArray否original 原图，compressed 压缩图，默认二者都有App、微信小程序、支付宝小程序、百度小程序extensionArray否根据文件拓展名过滤，每一项都不能是空字符串。默认不过滤。H5(HBuilder X2.9.9+)sourceTypeArray否album 从相册选图，camera 使用相机，默认二者都有。如需直接开相机或直接选相册，请只使用一个选项cropObject否图像裁剪参数，设置后 sizeType 失效App 3.1.19+successFunction是成功则返回图片的本地文件路径列表 tempFilePathsfailFunction否接口调用失败的回调函数小程序、AppcompleteFunction否接口调用结束的回调函数（调用成功、失败都会执行） crop 参数说明
参数名类型必填说明平台差异说明qualityNumber否取值范围为1-100，数值越小，质量越低（仅对jpg格式有效）。默认值为80。widthNumber是裁剪的宽度，单位为px，用于计算裁剪宽高比。heightNumber是裁剪的高度，单位为px，用于计算裁剪宽高比。resizeBoolean否是否将width和height作为裁剪保存图片真实的像素值。默认值为true。注：设置为false时在裁剪编辑界面显示图片的像素值，设置为true时不显示 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87800dc309c9be346fb225f8fa48b5f2/" rel="bookmark">
			SpringMVC基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今日内容
理解SpringMVC相关概念掌握SpringMvc请求参数处理掌握SpringMvc响应结果处理掌握RESTful风格及其使用 1、SpringMVC简介 1.1 背景 Servlet属于web层开发技术，技术特点：
每个请求都需要创建一个Servlet进行处理创建Servlet存在重复操作代码灵活性低，开发效率低 是否有技术方案可以解决以上问题？
1.2 SpringMVC概述 SpringMVC是一种基于Java实现MVC模型的轻量级Web框架详细介绍见官网：https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc优点 使用简单、开发便捷(相比于Servlet)灵活性强 1.3 技术体系定位 web程序通过浏览器访问前端页面，发送异步请求到后端服务器后台服务器采用三层架构进行功能开发 表现层负责接收请求和数据然后将数据转交给业务层业务层负责调用数据层完成数据库表的增删改查，并将结果返给表现层表现层将数据转换成json格式返回给前端 前端页面将数据进行解析最终展示给用户。 变现层采用SpringMVC框架，SpringMVC主要负责的内容有:
controller如何接收请求和数据如何将请求和数据转发给业务层如何将响应数据转换成json发回到前端 2、快速入门 2.1 目的 ​ 能基于SpringMvc快速开发一个web应用
2.2 需求 ​ 搭建SpringMvc工程，定义UserController.save()方法处理/save请求，返回"{‘module’:‘springmvc’}"。
2.3 步骤 创建Maven项目，并导入对应的jar包创建控制器类创建配置类创建Tomcat的Servlet容器配置类 2.4、代码实操 创建Maven项目，并导入对应的jar包 打开IDEA,创建一个新的maven项目
添加SpringMVC需要的依赖
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.itheima&lt;/groupId&gt; &lt;artifactId&gt;springmvc_01_quickstart&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;!--1. 导入SpringMVC与servlet的坐标--&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87800dc309c9be346fb225f8fa48b5f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/813d35f20fa61b335f550ccb35b14594/" rel="bookmark">
			关于预检请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 基本概述 预检请求（Preflight Request）是一种由浏览器自动发起的请求，用于检查实际请求是否安全可行。这种请求通常在跨域请求（CORS）中出现，并且只在某些特定条件下触发。以下是触发预检请求的具体条件：
请求方法不是简单方法之一（GET、HEAD 或 POST）。
POST请求的Content-Type不是简单请求头之一（application/x-www-form-urlencoded、multipart/form-data 或 text/plain）。
请求设置了自定义的头信息。
请求包含了可读流（即使用 ReadableStream 对象）。
当满足以上任一条件时，浏览器会首先发送一个OPTIONS请求到服务器，询问服务器是否允许实际的请求。如果服务器允许，浏览器才会发送实际的请求。这个OPTIONS请求就是所谓的预检请求。
知识拓展 请求方法是简单方法指的是哪些 在 HTTP 规范中，所谓的"简单请求"是指不会触发 CORS 预检请求的那些请求。简单请求需要满足以下所有条件：
只能是以下列出的方法之一：
GET
POST
HEAD
人为设置的头信息字段只能是以下几种：
Accept
Accept-Language
Content-Language
Content-Type (但只限于三个值 application/x-www-form-urlencoded、multipart/form-data、text/plain)
请求中的任何 XMLHttpRequestUpload 对象均没有注册任何事件监听器；也就是说，请求中没有使用 XMLHttpRequestUpload 对象。
请求中没有使用 ReadableStream 对象。
以上这些方法被称为简单方法，它们不会触发 CORS 预检请求。
application/x-www-form-urlencoded application/x-www-form-urlencoded 是一种 MIME 类型，常用于指定 HTTP 请求的内容类型（Content-Type）。当你发送一个 HTTP POST 请求时，需要在请求头中设置 Content-Type 来告诉服务器请求体的数据格式。如果 Content-Type 的值被设置为 application/x-www-form-urlencoded，那么请求体中的数据会被编码为键值对，每对键值之间用 &amp; 分隔，键与值之间用 = 分隔。这种编码方式与 URL 查询字符串的格式相同。例如，如果你有一个 JavaScript 对象 {name: ‘John’, age: 30}，那么在发送请求时，这个对象会被转换为字符串 ‘name=John&amp;age=30’。这种数据格式主要用于提交 HTML 表单数据，因为它能将复杂的表单数据转换为可在 URL 中传输的字符串。 text/plain text/plain 是一种 MIME 类型，用于指定 HTTP 请求或响应的内容类型（Content-Type）。当你设置 Content-Type 为 text/plain 时，意味着你正在发送或接收纯文本数据。这种类型通常用于发送不包含任何标记的纯文本。例如，如果你正在发送一个纯文本文件，或者你正在发送一个不包含 HTML 或其他代码的字符串，那么你应该使用 text/plain 类型。需要注意的是，text/plain 不会对数据进行任何处理或编码，所以它不适合用于发送包含特殊字符的数据。例如，如果你需要发送包含 &amp; 或 = 等特殊字符的数据，那么你应该使用 application/x-www-form-urlencoded 或 multipart/form-data 类型。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/300a1a0985c7bb4ba89c39a18e3b72d3/" rel="bookmark">
			ChatGPT&#43;Midjourney&#43;闲鱼赚钱方法实战探索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近天天在朋友群内看到朋友接单(出售提示词，图片），轻轻松松半小时就赚200-300，特意探索了一下相关玩法，总结出一套ChatGPT+Midjourney+闲鱼赚钱方法，主打的是易上手，有可操作性！
具体方案:
第一步:让 ChatGPT 帮我打工
第一个员工:一个资深闲鱼玩家(小闲)
第二个员工:AIGC提示词大师(小提)
第二步:Midjourney 生成图片
第三步:闲鱼上线
第三个员工:运营大师(小美)
第一步:让 ChatGPT 帮我打工
支付宝开通GPT4.0，最新经验分享-CSDN博客
第一个员工:一个资深闲鱼玩家(小闲)
这个人需要帮我掌握整体运营相关事务，比如:商品简介怎么写、应该配些什么图、怎么推广等。
首先告诉他现在公司情况，为啥上新商品，新商品大概是什么背景，有啥作用，然后让他帮我生成一个商品简介。
继续让他工作，帮我思考商品的定价，以及怎么配图~
说得太笼统，告诉他我们为什么要它说图片的描述，让他修改下。
第二个员工:AIGC提示词大师(小提)
告诉他我们要优化的内容，当然作为公司重要的一员，我们也需要告诉他事情的来龙去脉，这样他才能好好给你建
议。
告诉他我们要优化的内容，当然作为公司重要的一员，我们也需要告诉他事情的来龙去脉，这样他才能好好给你建议。
第二步:Midjourney 生成图片
进入官网，点击Join theBeta即可加入，会跳转到另一个应用Discord(一个流行的在线聊天平台，Midjourney就
在这上面，谷歌或者微软邮箱注册下，很简单)。
进入到Midjourney后，在聊天框输入/imagine就会出现一个选项，选择它。
prompt后输入前面小提帮我优化的提示词，然后回车就可以等Midjourney返回图片给我们了
输入提示词得到回复：
默认生成的是一个带四种风格的图片缩略图，上面的U1-U4表示这四张图片，如果你觉得那一张特别喜欢，想生成
对于的高清大图的话，点击对应序号即可，比如我喜欢U2，点击下会自动帮我生成U2的高清大图。
V1-V4表示4种图片的风格，比如我喜欢图二这种风格，点击V2，会自动帮我生成V2风格的图片。
当然，你要是觉得别人生成的图片很好，也可以直接复制别人的提示词，按自己需求修改修改再让midjourney 生
成。好，到这里，图片生成我们就玩会了。
第三步:闲鱼上线
这步就很简单了，商品标题、文案、定价、配图都有了，在自己咸鱼点上架就行~
第三个员工:运营大师(小美)
这是一个全新的GPT变现玩法~当然大家也可以按自己的思路给GPT文案，做类似的产品。
有闲暇时间的朋友可以去试试，每个人都可以做，也可以尝试其它的ChatGPT+Midjourney+小红书！
大家可以留言谈论自己的想法，更多分享
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ed9084de2b1a175eb6509ffc2214a21/" rel="bookmark">
			BeautifulSoup和Cheerio库：解析QQ音频文件的完整教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在当今数字化的世界中，网络上充斥着各种各样的数据，而这些数据往往以各种不同的格式和结构存在。要从这些数据中获取有用的信息，我们就需要使用一些工具来解析和提取数据。
BeautifulSoup和Cheerio BeautifulSoup是Python中用于解析HTML和XML文档的库，而Cheerio是Node.js中类似的库。它们提供了简单而强大的工具，使我们能够轻松地从网页或其他文档中提取所需的信息。在本文中，我们将介绍如何使用BeautifulSoup和Cheerio库来解析HTML和XML文档，并演示如何应用这些技术来解析QQ音频文件以提取所需的信息。
首先确定了解析目标，我们需要明确自己的解析目标。在解析QQ音频文件时，我们可能希望提取出的信息包括歌曲名称、歌手、专辑信息等。明确了解析目标后，我们就可以开始学习如何使用BeautifulSoup和Cheerio库来实现这个目标。
我们可以使用Python的requests库或Node.js的HTTP模块来获取QQ音频文件的HTML或XML内容。一旦我们获得了这些内容，我们就可以开始使用BeautifulSoup或Cheerio来解析它们。
在Python中，我们可以使用以下代码来使用BeautifulSoup解析HTML内容
from bs4 import BeautifulSoup import requests # 获取QQ音频文件的HTML内容 url = 'https://example.com/qq_audio_file' response = requests.get(url) html_content = response.text # 使用BeautifulSoup解析HTML内容 soup = BeautifulSoup(html_content, 'html.parser') # 提取歌曲名称 song_name = soup.find('div', class_='song-name').text # 提取歌手信息 artist = soup.find('div', class_='artist').text # 提取专辑信息 album = soup.find('div', class_='album').text # 打印提取的信息 print('歌曲名称：', song_name) print('歌手：', artist) print('专辑：', album) 以上代码演示了如何使用BeautifulSoup库来解析QQ音频文件的HTML内容，并获取歌曲名称、歌手和专辑信息。
在Node.js中，我们可以使用Cheerio库来实现类似的功能。以下是一个使用Cheerio库的示例代码：
const cheerio = require('cheerio'); const axios = require('axios'); // 代理信息 const proxyHost = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ed9084de2b1a175eb6509ffc2214a21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6308a9ec7bdc0d98d84e159ca834cef7/" rel="bookmark">
			Google浏览器-下载提示保留文件问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、背景
二、解决方案
一、背景 使用Google浏览器下载文件，每次下载都会提示是否保留文件。
二、解决方案 1、Chrome地址栏输入：chrome://flags/download-bubble；
2、搜索找到Warn on insecure downloads选项，默认为Default并调整为disabled
3、将该项调整为Disable；
4、点击Relaunch按钮，此时会关闭并重启浏览器；
5、重新下载访问，验证生效；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43095276f43f0f63bcae7b7d5ce2bf79/" rel="bookmark">
			【计算机网络】中小型校园网构建与配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		拓扑图配置文件传送门 Packet Tracer-中小型校园网配置布局文件文件
相关文章 【计算机网络】IP协议及动态路由算法
【计算机网络】Socket通信编程与传输协议分析
【计算机网络】网络应用通信基本原理
原理 1. Network 广域网，WAN Wide Area Network；城域网，Metroplitan Area Network；局域网，LAN Local Area Network。 Public IP，直接连入 Internet；Private IP，不连入 Internet，只能使用 NAT 网络地址转换 访问互联网。Private IP 要被互联网访问，可使用端口转换(NAT)技术。NAT 转换示意图如图 1 所示。
2. VLAN VLAN(Virtual Local Area Network)虚拟局域网是由一些局域网网段构成的与物理位置无 关的逻辑组。每一个 VLAN 的帧都有一个明确的标识符，指明发送这个帧的工作站是属于 哪一个 VLAN。可流量隔离(traffic isolation)，并减少广播数量。
3. 无线和蜂窝网络 WLAN/WiFi，IEEE 802.11 WirelessLAN，也称 WiFi，是一种较小范围的接入网技术， 802.11 基本构建模块为基本服务集（Basic Service Set, BSS），一个 BSS 包括多个无线站点和 一个接入点（Access Point, AP, 中央基站）。
过程与结果 1. 拓扑设计 设计一个由 NAT 网关连接内外网的简单的网络拓扑图。NAT 网关用一台 2911 路由器充当。内网用一台交换机连接多台主机构成一个 LAN，内设一台 Web 服务器和一台 DHCP服务器（两台服务器可以在同一主机上实现），有一台无线 AP，多台主机（包括使用 Wi-Fi连接的平板电脑和智能手机）。外网上至少有一台 Web 服务器和一台主机。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43095276f43f0f63bcae7b7d5ce2bf79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5165b116b43dcee0c6b07f0bc661e616/" rel="bookmark">
			Tween.js 使用文档 --- Three.js
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Tween.js官网文档：tween.js user guide | tween.js (tweenjs.github.io)
Tween.js 基本使用 1. 引入Tween.js import TWEEN from "./tween.js-master/dist/tween.esm.js" 2. 定义基本Tween动画 目的：将model模型的位置，从原来的(0,0,0)位置，经过1s移动到(20,50,30)的位置。
模式一：
// 1 设置动画 const action=new TWEEN.Tween({x:0,y:0,z:0}) // 初始值 .to({x:20,y:50,z:30},1000) // 目标值，毫秒数 // 在动画执行期，不断被调用。其中obj为"to"里面的内容 .onUpdate(function(obj){ model.position.x=obj.x; // x:20 model.position.y=obj.y; model.position.z=obj.z; }) .start() // 2 启动动画 function loop(){ // 更新动画 TWEEN.update() requestAnimationFrame(render); } 模式二：
const action=new TWEEN.Tween(model.position) // 初始值：模型的初始位置 .to({x:20,y:50,z:30},1000) // 目标值，毫秒数 .start() 3 字段说明 const action=new TWEEN.Tween(需添加动画的属性) 字段含义示例备注start执行动画action.start( ) action.start(num).start(毫秒数)：延迟n毫秒之后运行动画stop停止动画action.stop( )停止的动画必须为正在运行的动画chain链式执行动画actA.chain(actB,actC)1. 当actA动画执行完后,立即执行actB和actC动画，其中B和C同时被执行。2. 前提:actA.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5165b116b43dcee0c6b07f0bc661e616/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e70ea79cfb6caa225cdf176948d83977/" rel="bookmark">
			基于Apache httpd为windows11搭建代理服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一.概述二.检查电脑系统类型三.下载安装Apache Httpd四.代理服务配置五.代理服务安装六.报错解决方法七.测试是否运行成功7.1 本机测试7.2 局域网代理测试 八.设置特定ip可访问（阻止其他ip访问）九.参考文档 一.概述 出于某些原因，我们需要将自己的windows电脑作为网络代理为局域网内的其他设备做流量代理，那么windows电脑上的一些魔法功能就可以赋能给局域网内其他设备使用（类似于软路由网关），选择将windows作为代理服务器，需要在windows主机上安装代理服务，通常有一些软件客户端，如CCproxy，或者Apache httpd，本文介绍Apache httpd的方法。
二.检查电脑系统类型 检查电脑版本是为 32位操作系统 还是 64位操作系统
检查方式如下：1.在桌面找到【我的电脑】图标，右键属性。
三.下载安装Apache Httpd 下载地址：http://www.apachehaus.com/cgi-bin/download.plx（Apache Haus Downloads）
根据步骤1中电脑的系统位数，选择对应编译好的二进制版本，下载后得到httpd-2.4.25-x64-vc11-r1.zip，解压。
记住存放路径；例如：C:\AppInstall\Apache24
注意：如果选择下载的Apache httpd 与操作系统位数不一致，可能会导致无法正常使用。
四.代理服务配置 进入安装的目录：如 C:\AppInstall\Apache24，目录结构如下，这里需要对conf做一些修改，以适配我们当前的配置，首先进入conf 目录，打开httpd.conf文件：
修改处1：进入conf 目录，打开httpd.conf文件进行修改根目录ServerRoot为自己放置Apache24的目录（我的是C:\AppInstall\Apache24），这里不修改启动会报错。
修改处2：Listen端口修改（修改成自己要监听的端口和ip）
Listen 8989
修改处3：ServerName修改为监听的端口（我设置8989）
修改处4：把以下四句前面的【#】去掉。HTTP 、FTP 、HTTPS sites
#LoadModule proxy_module modules/mod_proxy.so
#LoadModule proxy_connect_module modules/mod_proxy_connect.so
#LoadModule proxy_http_module modules/mod_proxy_http.so
#LoadModule proxy_ftp_module modules/mod_proxy_ftp.so
修改处5：在最后添加Proxy配置
ProxyRequests On &lt;Proxy *&gt; Order allow,deny Allow from all # Deny from 127.0.0.1 # Deny from 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e70ea79cfb6caa225cdf176948d83977/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/698dc28b0627b284e1ad7a85601e13c3/" rel="bookmark">
			labelimg：未找到命令 | 标注工具 labelImg 安装及使用问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标注工具 labelImg 安装及使用问题解决 背景 在图像标注领域，labelImg 是一个广泛使用的工具，它允许用户方便地标注图像以用于机器学习任务。然而，在安装和使用 labelImg
过程中，一些常见问题可能会引起困扰，本文将探讨这些问题并提供解决办法。
出现的问题 1. 未找到 labelImg 命令 在使用 pip install labelimg 安装 labelImg 后，却无法找到 labelImg 命令。
2. PyQt5 和 lxml 依赖问题 在安装过程中，可能会遇到 PyQt5 和 lxml 依赖未能正确安装的问题。
3. labelImg 命令大小写敏感 当输入 labelimg 命令时，未能正确启动 labelImg。
解决办法 1. 未找到 labelImg 命令 确保在虚拟环境中运行时，使用正确的大小写，即 labelImg 而不是 labelimg。
2. PyQt5 和 lxml 依赖问题 在安装 labelImg 之前，可以手动安装 PyQt5 和 lxml 依赖项，确保它们被正确安装。
pip install pyqt5 lxml 3. labelImg 命令大小写敏感 使用正确的命令大小写，即 labelImg。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/698dc28b0627b284e1ad7a85601e13c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43147ef0dc283a9621576477004ab59b/" rel="bookmark">
			35、WEB攻防——通用漏洞&amp;XSS跨站&amp;反射&amp;存储&amp;DOM&amp;盲打&amp;劫持
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 XSS产生于前端的漏洞，常产生于：
XSS分类：
反射型（非持久型）
存储型（持久型），攻击代码被写入数据库中。常见于：写日志、留言、评论的地方
DOM型
DOM型XSS与反射型XSS、存储型XSS的最大区别在于：DOM型XSS前端的数据是传输给前端JS代码进行处理，而反射型XSS、存储型XSS是后端PHP代码对前端数据进行处理。
mXSS（突变型XSS）
UXSS（通用型XSS）
Flash XSS
UTF-7 XSS
MHTML XSS
CSS XSS
VBSrcipt XSS
浏览器会识别并执行HTML代码和JS代码。使用XSS平台获取管理员cookie，可能获取不全。建议用docker版Beef-XSS平台，里面有很多工具。 URL中没有参数接收XSS payload的话，就是不能写&lt;script&gt;alert(1)&lt;/script&gt;，可以尝试在URL路径后写javascript:alert(1)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c032d63d183d555e1f3cd32f4bac2538/" rel="bookmark">
			XMLHttpRequestUpload 对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基本概念 XMLHttpRequestUpload 对象表示一个 XMLHttpRequest 的上传进程。它是 XMLHttpRequest 的一个属性，可以用来监视上传的进度。
XMLHttpRequestUpload 对象有一些事件监听器，可以用来处理上传过程中的各种事件：
loadstart：当上传开始时触发。
progress：在上传过程中定期触发，可以用来更新上传进度条。
abort：当上传被用户取消时触发。
error：当上传过程中出现错误时触发。
load：当上传成功完成时触发。
timeout：当上传超时时触发。
loadend：当上传结束（无论成功或失败）时触发。
这些事件可以让你更好地控制和监视文件上传的过程。例如，你可以使用 progress 事件来显示一个上传进度条，或者使用 error 事件来处理上传过程中的错误。
二、实战示例 function uploadFile(file, url) { var xhr = new XMLHttpRequest(); var formData = new FormData(); formData.append('file', file); // 将文件添加到 FormData 对象中 xhr.open('POST', url, true); // 打开连接 // 监听上传进度 xhr.upload.onprogress = function(event) { if (event.lengthComputable) { var percentComplete = event.loaded / event.total * 100; console.log('上传进度：' + percentComplete + '%'); } }; // 监听上传完成 xhr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c032d63d183d555e1f3cd32f4bac2538/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f8bff40079851b8bbf71682e6ae63ca/" rel="bookmark">
			【Python自动化测试】接口测试一般流程及方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 一般的接口测试其实就属于功能测试，接下来我们以手工接口测试为例进行了流程说明。接口自动化测试的步骤其实跟手工测试流程差不多，只是需要使用脚本代替接口调试工具。
首先我们要明确，通常所接口测试其实就属于功能测试，主要校验接口是否实现预定的功能，虽然有些情况下可能还需要对接口进行性能测试、安全性测试。
在学习接口自动化测试之前，我们先来了解手工接口测试怎样进行。
URL组成 为了更好的理解接口测试，我们需要对接口的URL有所了解，下面以GET请求URL为例，组成示例如下：
通过上图可以看出来，一个典型的GET请求的URL可以分为以下几个部分：
传输协议：工作中接触到的接口一般是http/https协议服务器域名/IP地址：指提供接口的系统所部署的服务器地址端口：不填则默认端口为80资源路径：请求资源所在的服务器路径请求参数：对于GET请求，参数在资源路径后，用?分隔，参数之间用&amp;分隔。如http://127.0.0.1:8080/message?wd=pytest&amp;ie=utf-8，有2个参数 wd、ie POST请求的URL与GET请求URL不一样的地方在于，POST请求参数是放在请求body里而非直接放在URL里。
接口测试流程 手工接口测试的流程如下：
查看需求文档及接口文档，明确测试内容即接口信息。
根据需求文档及接口文档，编写测试用例。
根据测试用例执行测试。
记录测试结果，发送接口测试报告（如果需要）。
接下来以一个登录接口为例来讲解接口测试的流程。
接口文档 对接口进行测试，首先要明确接口的具体信息：请求url、请求方式、请求头、请求体 (字段及说明)、响应体 (字段及说明)。
通过开发提供的接口文档可以查看这些信息，然后再根据接口信息设计测试用例 (接口测试用例的设计主要参考接口文档)。下面示例为一个登录接口的接口文档：
从这个接口文档我们可以看到接口相关的具体信息，但这个文档里没有对请求头Header做说明，所以请求的时候对请求头也不做要求。
用例设计 用例设计方法
设计接口测试用例时，要从考虑输入、逻辑处理、输出三方面考虑：
输入，根据是否必填、参数类型、字节长度、参数组合等设计用例逻辑处理，即按照业务逻辑设计用例输出，即根据输出结果分析并设计用例 除了正向校验功能是否实现外，还应根据业务场景及处理逻辑，考虑一些异常场景，如：
用例编写工具
用例设计的载体有很多种，如Excel，XMind，或一些测试管理平台如testlink等，符合自己习惯、方便管理、一目了然就行。
如果用Excel来设计测试用例，可以参考如下原则：
一个模块对应一个Excel表一个接口对应一张sheet表sheet表中一行对应一条测试用例注明前置条件、后置操作。如登录用例需要先注册用户，测试完成后可能需要删除这个用户，这个时候可以把对应操作写进去。 针对上面的登录接口，使用Excel设计测试用例如下
测试执行 执行接口测试的方式有两种，使用工具或编写代码，工具如：postman、soupUI等，编写代码则一般使用Java、Python。
根据测试用例进行接口测试，手工接口测试一般情况下推荐使用postman进行，方便快捷。
这里以上面的登录接口为例，使用postman进行请求测试，示例如下：
测试结果 测试结果直接记录在测试用例对应的测试结果列里，如果需要提供测试报告的话则需将所有用例测试情况整合在测试报告中。
感谢每一个认真阅读我文章的人，礼尚往来总是要有的，虽然不是什么很值钱的东西，如果你用得到的话可以直接拿走：
这些资料，对于【软件测试】的朋友来说应该是最全面最完整的备战仓库，这个仓库也陪伴上万个测试工程师们走过最艰难的路程，希望也能帮助到你!有需要的小伙伴可以点击下方小卡片领取 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c9819187cdd141cfe740a612652a3ec/" rel="bookmark">
			FineReport链接本地DBeaver
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 finereport链接本地DBeaver fanruan.com/finereport/doc-view-101.html help.fanruan.com/finereport/doc-view-2583.html 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78ec2c30ada65d71e07e6e957ab7d65a/" rel="bookmark">
			Python学习笔记--条件分支控制流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文摘自朱雷老师所著《Python工匠》一书内容，作为笔记予以记录。
《Python工匠》第四章讲解“条件分支控制流”，讲到不要显式地和空值做比较，和None做相等判断时使用is运算符等，对于我这样菜鸟，还是很受益的。
错综复杂的分支语句，让很多代码变得难以维护。可以转化一下思路，那些恼人的if/else分支也许可以被其它东西替代。当代码中的分支越少、分支越扁平、分支的判断条件越简单，代码就越容易为何。
一、Python工匠》第四章总结内容
（1）条件分支语句惯用写法
不要显式地和布尔值做比较利用类型本身的布尔值规则，省略零值判断把not代表的否定逻辑移入表达式内部仅在需要判断某个对象是否是None、True、False时，使用is运算符（其它用==比较） （2）Python数据模型
定义_ _len_ _和 _ _bool_ _魔法方法，可以自定义对象的布尔值规则定义_ _eq_ _ 方法，可以修改对象在进行==运算时的行为 （3）代码可读性技巧
不同分支内容出现重复或类似的代码，把它们抽到分支外可提升代码的可读性使用“德摩根定律”可以让更多重否定的表达式变得更容易理解 （4）代码可维护性技巧
尽可能让三元表达式保持简单扁平优于嵌套：使用“提前返回”优化代码里的多层分支嵌套当条件表达式变得特别复杂时，可以尝试封装新的函数和方法来简化and的优先级比or高，不要忘记使用括号来让逻辑更清晰在使用or运算符替代条件分支时，请注意避开因布尔值运算导致的陷阱 （5）代码的组织技巧
bisect模块可以用来优化范围类分支判断字典类型可以用来替代简单的条件分支语句尝试总结条件分支代码里的规律，用更精简、更容易扩展的方法改写它们使用any()和all()内置函数可以让条件表达式变得更精简 二、重要知识点与技巧
1、基础知识
（1）省略零值判断
编写if分支时，如果需要判断某个类型的对象是否是零值，可能如下写：
if containers_count == 0: # if containers_count != []
...
当某个对象作为主角出现在if分支语句里时，Python解释器会主动对它进行“真假测试”，也就是调用bool()函数获取它的布尔值。而在计算布尔值时，每类对象都有各自的规则，比如整型0的布尔值为False,其它都为True；空列表、字典的布尔值为False,其它为True。
所以，当我们需要在条件语句里做空值判断时，可以直接吧代码简写成如下：
if not containers_count: # containers_count对象无论是数值0,或空列表、空字典
...
布尔值为假：None、0、False、[] 、{} 、() 、set() 、frozenset()，等等布尔值为真：非0的数值、True、非空的列表、元组、字典、集合，用户定义的类和实例，等 （2）把否定逻辑移入表达式内
if not number &lt; 10: # 解释器会1)先做number &lt; 10 比较运算，2)not 运算 ，3）bool测试运算
...
推荐修改为：
if number &gt;= 10 : # 解释器会1)先做number &lt; 10 比较运算，3）bool测试运算
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78ec2c30ada65d71e07e6e957ab7d65a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cd2b01b5246141308e00e9be28e2a8a/" rel="bookmark">
			深度学习(5)--Keras实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.Keras基础概念
二.如何跑通Keras项目
2.1.在cmd上跑通
2.2.在PyCharm上跑通
一.Keras基础概念 Keras是深度学习中的一个神经网络框架，是一个高级神经网络API，用Python编写，可以在TensorFlow，CNTK或Theano之上运行。
Keras优点：
(1). 允许简单快速的原型设计（用户友好性，模块化和可扩展性）。
(2). 支持卷积网络和循环网络，以及两者的组合。
(3). 在CPU和GPU上无缝运行。
二.如何跑通Keras项目 测试项目：
代码：
# 第一个keras神经网络 from numpy import loadtxt from keras.models import Sequential from keras.layers import Dense # 加载数据集 dataset = loadtxt('pima-indians-diabetes.csv', delimiter=',') # 分割为input (X) 和 output (y) 变量 X = dataset[:,0:8] y = dataset[:,8] # 定义keras模型 model = Sequential() model.add(Dense(12, input_dim=8, activation='relu')) model.add(Dense(8, activation='relu')) model.add(Dense(1, activation='sigmoid')) # 编译keras 模型 model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy']) # 在数据集上拟合keras 模型 model.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4cd2b01b5246141308e00e9be28e2a8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c49f1b308f1f6115919ab17a003f5729/" rel="bookmark">
			C&#43;&#43;模板与STL【常用算法】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌈个人主页：godspeed_lucip
🔥 系列专栏：C++从基础到进阶
🎄1 STL常用算法🏆1.1 常用遍历算法🍉1.1.1 for_each🍉1.1.2 transform 🏆1.2 常用查找算法🍋1.2.1 find🍋1.2.2 find_if🍋1.2.3 adjacent_find🍋1.2.4 binary_search🍋1.2.5 count🍋1.2.6 count_if 🏆1.3 常用排序算法🍅1.3.1 sort🍅1.3.2 random_shuffle🍅1.3.3 merge🍅1.3.4 reverse 🏆1.4 常用拷贝和替换算法🥭1.4.1 copy🥭1.4.2 replace🥭1.4.3 replace_if🥭1.4.4 swap 🏆1.5 常用算术生成算法🍍1.5.1 accumulate🍍1.5.2 fill 🏆1.6 常用集合算法🍇1.6.1 set_intersection🍇1.6.2 set_union🍇1.6.3 set_difference 🕮 2 总结 🎄1 STL常用算法 概述:
算法主要是由头文件&lt;algorithm&gt; &lt;functional&gt; &lt;numeric&gt;组成。
&lt;algorithm&gt;是所有STL头文件中最大的一个，范围涉及到比较、 交换、查找、遍历操作、复制、修改等等。
&lt;numeric&gt;体积很小，只包括几个在序列上面进行简单数学运算的模板函数。
&lt;functional&gt;定义了一些模板类,用以声明函数对象。
🏆1.1 常用遍历算法 学习目标：
掌握常用的遍历算法 算法简介：
for_each //遍历容器transform //搬运容器到另一个容器中 🍉1.1.1 for_each 功能描述：
实现遍历容器 函数原型：
for_each(iterator beg, iterator end, _func); // 遍历算法 遍历容器元素
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c49f1b308f1f6115919ab17a003f5729/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3fea3e32613de3b8b262e7dd90cd17e/" rel="bookmark">
			【Linux】—— 信号的基本介绍（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
（一）生活角度的信号
（二）查看信号列表
（三）技术应用角度的信号
（四）信号的概念
（五）小结
（一）生活角度的信号 我们要学习有关信号的相关知识，首先要知道什么是信号。接下来我先从生活中的例子来带大家逐步认识。
在日常生活中，"信号" 这个词可以涵盖多个领域，以下是一些常见的生活中的信号： 红绿灯、语言、姿态、表情 、鸟鸣、风声、情绪、闹钟、狼烟等等 就比如上诉的 红绿灯：我们都知道“红灯停，绿灯行”，对于不同的颜色都会匹配相应的动作。此时我就要问大家为什么会有这个动作呢？
其实很简单，因为曾经有人或者有事等 “培养”过你，使你脑海中产生了这种印象，以至于即使现在不是身处红绿灯处，我们也知道不同的颜色我们该怎么进行处理！！ 同理，若此时存在一个进程，而信号就是一个数字（可以通过 kill -l 查看，稍后会讲），即使进程没有收到信号的时候，它也知道当收到信号的时候能够准备识别并知道该如何处理（因为程序员设计进程的时候，早就已经设计好了对信号识别处理的能力！！） 如果大家还是困惑我在给大家举个例子：
假设你在网上买了很多件商品，在等待不同商品快递的到来。但即便快递没有到来，你也知道快递来临时，你该怎么处理快递。也就是你能“识别快递”；当快递员到了你楼下，你也收到快递到来的通知，但是你正在打游戏，需5min之后才能去取快递。那么在在这5min之内，你并没有下去去取快递，但是你是知道有快递到来了。也就是取快递的行为并不是一定要立即执行，可以理解成“在合适的时候去取”；在收到通知，再到你拿到快递期间，是有一个时间窗口的，在这段时间，你并没有拿到快递，但是你知道有一个快递已经来了。本质上是你“记住了有一个快递要去取”；当你时间合适，顺利拿到快递之后，就要开始处理快递了。而处理快递一般方式有三种：1. 执行默认动作（幸福的打开快递，使用商品）2. 执行自定义动作（快递是零食，你要送给你你的女朋友）3. 忽略快递（快递拿上来之后，扔掉床头，继续开一把游戏）；快递到来的整个过程，对你来讲是异步的，你不能准确断定快递员什么时候给你打电话. （二）查看信号列表
我们可以使用kill -l命令可以察看系统定义的信号列表。具体如下：
【解释说明】
首先，在Linux系统中，【1-31】号的信号通常是标准的POSIX信号，大家也可以叫做普通信号（这是我们学习的主要）；其次，大家可以发现没有32、33号信号，31号之后就是34号。在POSIX标准中，并没有规定32和33号这样的信号，因此在通常的Linux系统中，这些数字对应的信号并没有特殊的含义。这并不是系统实际上没有定义更高编号的信号，而是在POSIX标准中未规定的部分给了系统一些灵活性，使得系统可以自定义和扩展信号的使用；最后34号之后的统称为“实时信号”，对于这部分信号，大家可以不用关心；最后大家也可以发现，每个都是以 数字开头紧跟一个大写的字符串。这里的数字就是“信号”，后面大写的字符串就是“宏”。 SIGHUP (1): 挂起信号SIGINT (2): 中断信号SIGQUIT (3): 退出信号SIGILL (4): 非法指令信号SIGTRAP (5): 跟踪/断点陷阱信号SIGABRT (6): 中止信号SIGBUS (7): 总线错误信号SIGFPE (8): 浮点异常信号SIGKILL (9): 强制杀死进程信号SIGUSR1 (10): 用户自定义信号 1SIGSEGV (11): 段错误信号SIGUSR2 (12): 用户自定义信号 2SIGPIPE (13): 管道破裂信号SIGALRM (14): 超时信号SIGTERM (15): 终止信号SIGSTKFLT (16): 协程栈错误信号SIGCHLD (17): 子进程状态改变信号SIGCONT (18): 继续执行信号SIGSTOP (19): 停止进程信号SIGTSTP (20): 终端停止信号SIGTTIN (21): 后台进程尝试读取控制终端SIGTTOU (22): 后台进程尝试写入控制终端SIGURG (23): 紧急情况信号SIGXCPU (24): 超过CPU时间限制信号SIGXFSZ (25): 超过文件大小限制信号SIGVTALRM (26): 虚拟定时器信号SIGPROF (27): 用于分析的定时器信号SIGWINCH (28): 窗口大小改变信号SIGIO (29): 异步I/O事件通知信号SIGPWR (30): 电源故障信号SIGSYS (31): 非法系统调用信号 （三）技术应用角度的信号 有了上述的 知识储备之后，接下来通过简单的代码来理解信号！！！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3fea3e32613de3b8b262e7dd90cd17e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2d2605c5e38397ff1b1b9fd1841fd7a/" rel="bookmark">
			201903CSPT5 317号子任务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题意：有n个点，m条无向边。n个点中有一些是行星发动机点，现在要求计算出每个点最近的k个行星发动机点的最短路径之和，如果某个点能够达到的行星发动机点不足k个，则求其能到达行星发动机点的最短路径之和。
#include&lt;bits/stdc++.h&gt; using namespace std; struct Node { int w; int v; Node(int w,int v):v(v),w(w){} }; struct node { int u; int d; bool operator &lt;(const node y) const { return d&gt;y.d; } }; vector &lt;Node&gt; V[10010]; vector &lt;int&gt; planet; int dis[10010],vis[10010],qdis[10010]; int planetdis[10010][10010]; int n,m,k,ans=0; void Dij(int s) { for(int i=1;i&lt;=n;i++)dis[i]=1999999999; dis[s]=0; priority_queue &lt;node&gt; q; node t;t.d=0;t.u=s;q.push(t); while(q.size()!=0) { int x=q.top().u;//cout&lt;&lt;x&lt;&lt;" "&lt;&lt;endl; q.pop(); if(vis[x]==1)continue; vis[x]=1; for(int i=0;i&lt;V[x].size();i++) { int y=V[x][i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2d2605c5e38397ff1b1b9fd1841fd7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a73c63820fe76a8ebef964884fcc8f1d/" rel="bookmark">
			vue监听浏览器尺寸变化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.在data中定义一个变量，用于记录屏幕尺寸；
data(){ return{ screenWidth: null, } } 且做好定义为 null
2.使用 window.onresize 方法获取屏幕尺寸；
created() { this.screenWidth = document.body.clientWidth window.onresize = () =&gt; { return (() =&gt; { this.screenWidth = document.body.clientWidth })() } }, 需要在 created() 中
3.使用 watch 方法即可实时监听屏幕尺寸；
watch: { screenWidth: { handler: function (val) { if (val &lt; 900) { console.log(val+'屏幕宽度小于900px') } else { console.log(val+'屏幕宽度大于900px') } }, immediate: true, deep:true }, } 搞定！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5f463941fc722e26c532c5af9c56a01/" rel="bookmark">
			AI嵌入式K210项目（19）-安装CanMV IDE开发软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、软件下载安装二、软件简介三、设备连接四、在线模拟五、开机运行程序附录：MicroPython固件烧录总结 前言 前几章我们介绍K210使用C语言裸机开发方法，大家对K210内部的硬件和各种加速器有了初步的了解，但是开发人工智能相关程序，使用C语言的话复杂度比较高，因此接下来我们逐步学习基于K210芯片使用python开发人工智能相关程序，包含颜色识别，人脸识别，口罩识别等，也包括一些分类应用；
一、软件下载安装 CanMV IDE的GitHub地址，根据自己的系统下载对应的软件安装包：https://github.com/kendryte/canmv_ide/releases
如果被墙了，也可以到嘉楠官网下载：https://developer.canaan-creative.com/resource
下载后得到canmv-ide-windows-vx.x.x-gxxxxxx.exe文件，双击打开安装包
按照个人情况修改安装路径
安装完成
二、软件简介 区域①菜单栏：操作文件，使用工具等。
区域②快捷按钮：区域①中的文件和编辑中部分功能的快捷方式。
区域③连接设备：连接设备和程序控制按钮。
区域④代码编辑区：编辑要运行的代码。
区域⑤串行终端：显示串口打印的调试信息。
区域⑥图像预览：显示摄像头的图像预览。
区域⑦固件信息：显示连接的串口号以及固件的相关信息。
三、设备连接 将K210开发板通过TYPE-C数据线连接到电脑USB口。
然后点击CanMV IDE左下角连接按钮。
注意，如果你是刚做完裸机开发的开发板，需要先烧录MicroPython镜像后再使用canMV，烧录方法见下一小节。
弹出选择串口，选择K210开发板对应的串口号。如果有多个串口请先确定对应的串口号再点击OK打开。
如果连接不上，可以点击高级设置，选择Mode-3（这里可能开发板有差异，如果依旧不行，可以更换其他模式试一下）
连接成功会将图标变为已连接状态，同时灰色播放键变为绿色。
四、在线模拟 如果对程序进行真机在线调试，可以直接单次运行即可
提示：此步骤运行的程序，断开连接、按复位键或者关机后，程序丢失不保存
连接完成后，可以看到左下角的连接图标变成已连接符号。
如果没有打开例程，可打开文件-&gt;示例-&gt;Basics-&gt;helloworld.py
点击绿色按钮直接运行即可
此时可以看到LCD显示摄像头画面，同时IDE右上角也有显示摄像头画面。
绿色播放键图标变成红色停止键，点击一下可以停止运行的程序。
五、开机运行程序 如果调试后的程序符合预期，可以让其在开发板上保留，待下次开机后自动运行
提示：此步骤的程序重新上电后会自动运行
在保持连接的情况，点击工具-&gt;保存当前打开的脚本为（main.py）到CanMV Cam
点击Yes保存程序，完成后，断开连接或者按一下复位按键，程序会自动运行。
如果有插入TF卡，程序优先保存到TF卡，并且优先运行TF卡里的main.py文件。
附录：MicroPython固件烧录 K210官方裸机版本SDK并不支持MicroPython，需要下载CanMV支持的固件才可以使用MicroPython来使用。
K210开发板出厂不烧录microPython版本的出厂固件，如果要使用microPython版本的要自己下载烧录最新的固件才可以用。
出厂固件只提供bin烧录文件，不提供源码。如果需要学习K210的MicroPython底层固件源码，可以打开以下网址学习官方CanMV项目：
https://github.com/kendryte/canmv
为了恢复出厂固件设置，在烧录出厂固件前，请先执行一次全片擦除操作。
注意：此步骤会清空K210开发板的Flash程序空间，清空后程序空间后，请重新烧录固件才能连接CanMV IDE。
CanMV IDE点击工具-&gt;K210烧录工具-&gt;切换到擦除。
在擦除设置中选择模式为全片擦除，选择K210开发板的串口号，点击擦除开始清空程序空间
等待擦除完成后，切换到烧录界面重新烧录固件。
切换到烧录后，点击下载。
完成写入即可
写入后，将K210开发板连接串口助手，用串口助手查看打印的信息，重启开发板得到如下信息，标识固件已经正确烧录，这样再和CanMV连接通讯就可以了
总结 本章介绍了CanMV IDE的安装，Python固件的烧录方法，Python代码的烧录方法，为我们后面学习做个铺垫。好了下面一起开始MicroPython开发人工智能应用的学习吧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/724e82ad86fdaa07be3073226f799406/" rel="bookmark">
			北美“水务巨头”遭遇勒索软件攻击，账单支付系统被破坏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 近日，威立雅北美公司披露了一起勒索软件攻击事件，此次攻击影响了其市政水务部门的部分系统，并破坏了其账单支付系统。
在发现攻击后，该公司立即采取了防御措施，并暂时关闭了部分系统，以避免漏洞造成更大的影响 。威立雅目前正与执法部门和第三方取证专家合作，评估攻击对其运营和系统的影响程度。
威立雅公司称，为应对这一事件他们采取了防御措施，包括将目标后端系统和服务器下线，直至恢复。因此，一些客户在使用我们的在线账单支付系统时出现了延迟。目前这些后端系统和服务器现已重新上线，客户的付款不会受到影响。客户不会因延迟付款而受到处罚，也不会因此次服务中断而被收取账单利息。
这次攻击并没有中断威立雅的水处理业务或废水处理服务。威立雅北美公司表示：这次攻击事件仅限于我们的内部后台系统，没有证据表明它影响了我们的水处理或废水处理业务。
截至目前，该公司发现有少数的个人信息在此次漏洞事件中受到影响，目前正在与第三方取证公司合作，评估此次攻击对其运营和系统的影响程度。
威立雅北美公司为大约 550 个社区提供水和废水处理服务，并为大约 100 个工业设施提供工业用水解决方案，每天在美国和加拿大的 416 个设施处理超过 22 亿加仑的水和废水。
跨国威立雅集团在全球拥有近 21.3 万名员工，2022 年收入达 429 亿欧元，为约 1.11 亿人提供饮用水，为约 9700 万人提供污水处理服务。同年，威立雅生产了近44太瓦时的能源，并处理了6100万吨废物。
关键水基础设施遭受攻击 南方水务公司（Southern Water）是一家为英国各地数百万人提供服务的水处理公司，它也是 Black Basta 勒索软件团伙宣称的勒索软件攻击的受害者。
该公司表示目前没有证据表明公司的客户关系或财务系统受到影响。另外公司服务没有受到影响，目前运行正常。
去年11 月，CISA 警告称有威胁者通过入侵在线暴露的 Unitronics 可编程逻辑控制器 (PLC)，入侵了宾夕法尼亚州的一个美国供水设施，但没有危及所服务社区的饮用水安全。
去年9月，美国网络安全机构发布了一项针对供水设施等关键基础设施的免费安全扫描计划，以帮助它们发现安全漏洞并确保系统免受此类攻击。
近年来，美国水和废水系统 (WWS) 部门的设施多次遭到部署 Ghost、ZuCaNo 和 Makop 勒索软件的多个威胁组织的入侵。
在过去二十年中，还发生过其他水务设施被入侵的事件，其中包括 2011 年南休斯顿的一家污水处理厂、2016 年一家软件和硬件设备过时的水务公司、2020 年 8 月南加州 Camrosa 水区以及 2021 年 5 月宾夕法尼亚州的一个水务系统。
针对水务部门日益成为网络攻击目标的情况，CISA、联邦调查局（FBI）和美国环保署（EPA）上周发布了一份事件响应指南，旨在帮助水务公司尽可能的降低水务设施遭遇攻击的风险。
参考来源：Water services giant Veolia North America hit by ransomware attack 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6b3b3143ee7599021f48de1f09fff29/" rel="bookmark">
			Java中的HTTPS通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Java中实现HTTPS通信，主要涉及到SSL/TLS协议的使用，用于提供数据传输的安全性。下面我们将深入探讨如何使用Java进行HTTPS通信。
一、基本概念
HTTPS，全称为Hypertext Transfer Protocol Secure，是HTTP的安全版本。它使用SSL/TLS协议对传输的数据进行加密，确保数据在传输过程中的安全。
二、设置环境
首先，确保你的Java环境已经安装了适当的SSL/TLS支持。这通常意味着你需要安装Java Cryptography Extension (JCE)无限制强度文件。
三、使用HttpsURLConnection
Java的HttpsURLConnection类是实现HTTPS通信的主要方式。以下是一个简单的示例：
java复制代码
import java.net.HttpURLConnection; import java.net.URL; import java.io.BufferedReader; import java.io.InputStreamReader; import javax.net.ssl.HttpsURLConnection; import javax.net.ssl.SSLSocketFactory; public class HttpsExample { public static void main(String[] args) throws Exception { URL url = new URL("https://www.example.com"); HttpsURLConnection connection = (HttpsURLConnection) url.openConnection(); connection.setSSLSocketFactory(SSLSocketFactory.getDefault()); BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream())); String inputLine; StringBuffer response = new StringBuffer(); while ((inputLine = in.readLine()) != null) { response.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6b3b3143ee7599021f48de1f09fff29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88c85d6c251407f69b338d44969a2126/" rel="bookmark">
			FlinkAPI开发之FlinkSQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.代码中使用FlinkSQL 需要引入的依赖 &lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-table-api-java-bridge&lt;/artifactId&gt; &lt;version&gt;${flink.version}&lt;/version&gt; &lt;/dependency&gt; 这里的依赖是一个Java的“桥接器”（bridge），主要就是负责Table API和下层DataStream API的连接支持，按照不同的语言分为Java版和Scala版。
如果我们希望在本地的集成开发环境（IDE）里运行Table API和SQL，还需要引入以下依赖：
&lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-table-planner-loader&lt;/artifactId&gt; &lt;version&gt;${flink.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-table-runtime&lt;/artifactId&gt; &lt;version&gt;${flink.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-connector-files&lt;/artifactId&gt; &lt;version&gt;${flink.version}&lt;/version&gt; &lt;/dependency&gt; 二. 创建表环境 对于Flink这样的流处理框架来说，数据流和表在结构上还是有所区别的。所以使用Table API和SQL需要一个特别的运行时环境，这就是所谓的“表环境”（TableEnvironment）。它主要负责：
（1）注册Catalog和表； （2）执行 SQL 查询； （3）注册用户自定义函数（UDF）； （4）DataStream 和表之间的转换。 每个表和SQL的执行，都必须绑定在一个表环境（TableEnvironment）中。TableEnvironment是Table API中提供的基本接口类，可以通过调用静态的create()方法来创建一个表环境实例。方法需要传入一个环境的配置参数EnvironmentSettings，它可以指定当前表环境的执行模式和计划器（planner）。执行模式有批处理和流处理两种选择，默认是流处理模式；计划器默认使用blink planner。
批处理表环境 import org.apache.flink.table.api.EnvironmentSettings; import org.apache.flink.table.api.TableEnvironment; EnvironmentSettings settings = EnvironmentSettings .newInstance() .inStreamingMode() // 使用流处理模式 .build(); TableEnvironment tableEnv = TableEnvironment.create(setting); 流处理表环境 对于流处理场景，其实默认配置就完全够用了。所以我们也可以用另一种更加简单的方式来创建表环境：
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment; import org.apache.flink.table.api.EnvironmentSettings; import org.apache.flink.table.api.bridge.java.StreamTableEnvironment; // TODO: 2024/1/23 创建流式表环境 StreamExecutionEnvironment environment = StreamExecutionEnvironment.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88c85d6c251407f69b338d44969a2126/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/720f646d6cab9d96f446cdf565abc9fe/" rel="bookmark">
			【Linux工具篇】编辑器vim
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
vim的基本操作
进入vim(正常模式） 正常模式-&gt;插入模式
插入模式-&gt;正常模式
正常模式-&gt;底行模式
底行模式-&gt;正常模式
底行模式-&gt;退出vim
vim正常模式命令集
vim末行模式命令集
Q1Linux底下多文件操作
Q2批量化注释和去注释
Q3ctrl+z和断网的情况
Q4sudo提权
Q5vim配置 配置文件位置
常用配置选项
使用插件
Linux编译器-vim使用
vim是一款多模式的编辑器。正好和vs这种集成开发环境相反，vim的存在很多模式，我们目前主要掌握三种模式即可。分别是命令模式（command mode），插入模式（Insert mode），底行模式（last line mode）。一共有12种模式:six BASIC modes和six ADDITIONAL modes。各模式的功能区分如下：
正常/普通/命令模式(Normal mode)（核心模式） 允许使用者通过命令来进行文本的编辑控制。控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode。
插入模式(Insert mode) 编辑模式。只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。该模式是我们后面用的最频繁的编辑模式。
末行/底行模式(last line mode) 用来进行让vim进行包括但不限于shell进行交互的。文件保存或退出，也可以进行文件替换，找字符串，列出行号等操作。 在命令模式下，shift+: 即可进入该模式。要查看你的所有模式：打开vim，底行模式直接输入。
:help vim-modes
vim的基本操作 进入vim(正常模式） 进入vim,在系统提示符号输入vim及文件名称后，就进入vim全屏幕编辑画面。 注意：不过有一点要特别注意，就是你进入vim之后，是处于[正常模式]，你要切换到[插入模式]才能够输入文字。刚打开时，暂时无法正常输入。
$ vim test.c 正常模式-&gt;插入模式 输入a输入i输入o 插入模式-&gt;正常模式 目前处于[插入模式]，就只能一直输入文字，如果发现输错了字,想用光标键往回移动，将该字删除，可以先按一下「ESC」键转到[正常模式]再删除文字。当然，也可以直接删除。
按动ESC 正常模式-&gt;底行模式 「shift + ;」, 其实就是输入「:」 底行模式-&gt;正常模式 按动ESC 底行模式-&gt;退出vim 退出vim及保存文件，在[正常模式]下，按一下「shift+;=:」冒号键进入「Last line mode」
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/720f646d6cab9d96f446cdf565abc9fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5feb01745e69ef1a640c4c45cf365d39/" rel="bookmark">
			文本文件的编码详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在程序调试时，程序中用到一个config.json文件，是UTF-8的格式，这是在win11的nodtepad中显示的编码格式，但复制到win7中使用时，出现一个奇特的现象，报文件格式错误，说出现一个特殊字符不识别，这个特殊字符像一个字母i上面有两点的一个特殊字符，但经过目视检查，没有任何问题，百思不得其解，最后还是chatgpt厉害，直接给出了原因和答案。
说这是一个UTF-8 BOM格式，导致的不兼容，解决办法是换成ANSI格式或再转换成标准的UTF-8格式，问题解决。
但怎么会出现这种问题的呢？有必要对文本文件的编码，再做详细的梳理。在win7或以前的系统中的notepad，支持ANSI、unicode、unicode big endian、UTF-8四种格式，如下图所示：
在win11的notepad中，支持ANSI、UTF-16 LE、UTF-16 BE、UTF-8、UTF-8 BOM、GB18030六种格式，如下图所示：
UTF，是Unicode Transformation Format"的缩写。Unicode是一种标准字符集，而UTF则是一种用于在计算机中存储和传输Unicode字符的编码方式。
下面，对这几种编码格式进行一一解释：
1、ANSI（ASCII）：
使用单字节编码，通常每个字符占用一个字节。
仅支持128个基本ASCII字符。
2、UNICODE：
使用两个字节编码，允许表示更多字符，包括国际字符。
提供了对全球范围内字符的支持。
3、UNICODE BIG ENDIAN：
和Unicode相似，但是字节顺序是大端序，即高位字节在前。
4、UTF-8：
使用变长字节编码，一个字符可以由1至4个字节组成。
兼容ASCII，对英文字符使用一个字节，同时支持包括中文在内的多语言字符。
5、UTF-16LE：
使用两个字节编码，但是字节顺序是小端序，即低位字节在前。
6、UTF-16BE：
和UTF-16LE相似，但是字节顺序是大端序，即高位字节在前。
7、UTF-8 BOM（Byte Order Mark）：
UTF-8编码中的一个特殊标记，占用三个字节（0xEF, 0xBB, 0xBF）。
用于标识文本文件使用了UTF-8编码，同时指定字节序。
这些编码方式中，ANSI、UNICODE和UTF-8是最常见的。UTF-8因为其灵活性和对多语言的支持，成为现代互联网中广泛使用的标准编码方式。UTF-16用于某些系统和应用，但在Web开发中并不常见。
BOM是可选的，不是所有UTF-8文件都包含BOM。在UTF-8编码文件中使用BOM可以帮助解释器识别编码方式，但有时也可能引起一些问题，因此在实际使用中需要注意。
由此可见，要特别注意UTF-8和UTF-8 BOM的区别，在win7以前的系统上，并不能识别出来，导致程序兼容性问题。如果用二进制打开文本文件，开头为：0xEF, 0xBB, 0xBF则为UTF-8 BOM格式。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d9f7909969eba87693975e04ddc4579/" rel="bookmark">
			php项目laravel框架下在yapi接口文档中运行生产环境的接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Laravel 中运行 YApi 项目需要经过以下步骤：
1. 安装 Node.js 和 YApi
首先需要在服务器上安装 Node.js 和 YApi，可以按照官方文档进行安装。如果您已经安装了 Node.js，可以使用以下命令安装 YApi：
npm install -g yapi-cli --registry https://registry.npm.taobao.org 2. 创建 YApi 项目
在 Laravel 项目的根目录下创建一个新的目录，用于存放 YApi 项目。使用以下命令创建 YApi 项目：
yapi init 按照提示进行配置，包括数据库、管理员账号等信息。
3. 启动 YApi 服务器
使用以下命令启动 YApi 服务器：
yapi server YApi 服务器将会在本地启动，并监听默认端口 3000。
4. 集成到 Laravel 项目
将 Laravel 项目中的 `/public` 目录下的所有文件复制到 YApi 项目的 `static/` 目录下。
修改 YApi 项目的配置文件 `config.json`，将 `port` 改成 Laravel 项目中想要使用的端口号，例如 8000。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d9f7909969eba87693975e04ddc4579/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9899b8429770b9b4732bed798c659101/" rel="bookmark">
			C语言signal处理的底层机制深度探讨
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在C语言中，signal处理是操作系统级别的事件处理机制，用于响应各种系统级事件，如程序错误、硬件中断等。深入理解signal处理的底层原理、使用方法以及其局限性对于编写稳定、可靠和安全的代码至关重要。本文旨在全面深入到系统调用和内核级探讨C语言signal处理。
一、signal基础 1. signal概念：在Unix-like系统中，signal是一种进程间通信机制，用于通知进程发生了某种特定的事件。
2. C语言中的signal库函数：C语言标准库提供了`&lt;signal.h&gt;`头文件中的相关函数，如`raise()`用于发送信号，`signal()`用于设置信号处理器函数。
二、signal的种类与含义 1. 常见的signal类型：包括`SIGINT`（中断，通常由Ctrl+C触发）、`SIGSEGV`（段错误，通常由非法内存访问触发）、`SIGFPE`（浮点异常，通常由除以零或溢出引发）等。
2. signal的默认行为：每个signal都有一个默认的行为，如终止进程、忽略信号或生成core dump等。
三、signal的处理流程 1. signal的产生：当系统检测到某个信号对应的事件发生时，会生成一个signal，并将其放入目标进程的信号队列。
2. signal的排队与递送：信号可能被阻塞或排队，直到进程解除对相应信号的阻塞，或者信号被递送到进程。
3. signal的处理：当信号被递送到进程时，如果设置了信号处理器函数，那么该函数会被调用；否则，执行默认行为。
四、signal的设置与管理 1. `signal()`函数：`signal()`函数用于设置信号处理器函数，可以指定三种行为：忽略信号、执行默认行为或调用自定义处理器函数。
#include &lt;signal.h&gt;
void handler(int signum) {
// 处理信号的代码
}
int main() {
signal(SIGINT, handler); // 设置SIGINT信号处理器
// ...
}
2. `sigaction()`函数：相比于`signal()`函数，`sigaction()`提供了更丰富的信号处理选项，包括信号掩码的管理、信号处理方式的选择等。
#include &lt;signal.h&gt;
void handler(int signum) {
// 处理信号的代码
}
int main() {
struct sigaction sa;
sa.sa_handler = handler;
sigemptyset(&amp;sa.sa_mask);
sa.sa_flags = 0;
sigaction(SIGINT, &amp;sa, NULL); // 使用sigaction设置SIGINT信号处理器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9899b8429770b9b4732bed798c659101/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/607f399c6f9f822bf6ef5cde8fe8ea53/" rel="bookmark">
			Mysql 数据库(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mysql 数据库 目录名作用bin可执行文件，存放就是命令及工具data不一定在主目录，是可以自定义配置（my.ini）。存放数据的，表结构，表数据docsmysql相关指导文件include包含头文件，提供程序的连接及myqlAPI接口，需要告诉mysql 包含的路径等等配置lib类库，支撑mysql运行的环境库mysql -testreadme文件等，相关一些Demo. 演示类文件scripts脚本文件，初始化数据库，第一次运行mysql ，这个脚本是一定要执行的sharse共享文件等，例如主从服务，分库分表的共享文件sql-bench基准程序和cash-me，copy-db ， 备份恢复，修复等脚本，（运维工程用的比较多）my.ini是mysql有核心配置文件 数据库的基本知识 1， 常用的数据存储方式： 存储位置优点缺点内存（集合，数组，实体对象）存取的速度快不能永久存储文件（IO流，把数据写入文件中）可以永久存储对于数据的管理和维护不便数据库1，可以永久保存2, 数据库的系统有对数据一套专门操作的命令，方便我们管理和维护数据数据库通常花钱的， 2， 什么是数据库 数据存储的仓库，称为数据库
数据库系统：支持数据运行的软件系统
数据库：服务
实列：database， 某一个数据仓库
3， 常见的数据库种类及数据的名字： 分为两大类：关系型数据库，非关系型数据。
关系型数据库有哪些？ mysql ,oracle,DB2，MS SQL Server，SQLite
对于关系型数据，都有一个共同点：都支持SQL语句的操作，如查你会一种（mysql）你也可以用sql操作其它的数据库。(不同的数据之间有差异，大同小异)
他有一个名字叫：RDBMS: （Relational）关系型数据库系统。
非关系型数据库又有哪些？ redis，mongoDB , Memcached
统称为：Nosql. 不是sql的数据库，也叫非关系型数据库，一般来说，Nosql是作为关系型数据库的一种补充。
mysql数据库的结构： 记录对应： 一个实体对象记录的字段：对应的是实体的属性。一张表对应：实体类一个数据库对应：一个系统。
小结：
一个数据库系统可以有多个数据库
一个数据库可以有多张表
一张表可以有多条记录
SQL语句的分类 什么是sql: Structured Query Language 结构化查询语言。
1，DDL：Data Definition Language 数据库的定义语言，主要用于数据库和表的管理
2：DML: Data Manipulation Language 数据库的操纵语言，主要用于表的增删改
3: DQL: Data Query Language 数据库的查询语言, 主要用于表的数据记录查询
4: DCL：Data Control Language 数据库的控制语言， 主要用于用户的权限管理
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/607f399c6f9f822bf6ef5cde8fe8ea53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4324efc2402101b5b6c8087c5396f48/" rel="bookmark">
			Linux基础命令-scp远程复制文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux基础命令-seq打印数字序列
前言 有时候不可避免的需要将文件复制到另外一台服务器上，那么这时就可以使用scp命令远程拷贝文件，scp命令是基于SSH协议，在复制的过程中数据都是加密过的，会比明文传输更为安全。
一.命令介绍 依旧惯例，先到scp的帮助文档中查看命令的概述
NAME scp — secure copy (remote file copy program) DESCRIPTION scp copies files between hosts on a network. It uses ssh(1) for data transfer, and uses the same authentication and provides the same security as ssh(1). scp will ask for passwords or passphrases if they are needed for authentication. File names may contain a user and host specification to indicate that the file is to be copied to/from that host.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4324efc2402101b5b6c8087c5396f48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ec1534f1cf3d06a02f0d59ccdbb4f1b/" rel="bookmark">
			C&#43;&#43;拾遗（一） 内存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内存分区模型 内存四区分布 C++程序在执行时，将内存大方向划分为4个区
代码区：存放函数体（如main函数）的二进制代码，即存放 CPU 执行的机器指令，由操作系统进行管理。
代码区特点：
1.代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可 2.代码区是只读的，使其只读的原因是防止程序意外地修改了它的指令
全局区：存放全局变量和静态变量以及常量，其中常量属于全局区的常量区。该区域的数据在程序结束后由操作系统释放。
栈区：由编译器自动分配释放, 存放函数的参数值，局部变量等
堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收
内存四区意义 不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程
程序执行前后内存分布 程序执行前 在程序编译后，生成了exe可执行程序，未执行该程序前分为两个区域，代码区和全局区
int g_a = 10; int g_b = 10; 定义全局变量，使其属于整个程序，生命周期同原程序一样
const int c_g_a = 10; const int c_g_b = 10; 全局常量，使其属于整个程序，且其值不可被改变
int main() {
int a = 10; int b = 10; 局部变量，使其只属于mai函数
打印地址：利用&amp;获取地址
std::cout &lt;&lt; (int)&amp;a &lt;&lt; std::endl; 以int类型方式打印a地址，&amp;获取a的地址，将a地址转化为int类型打印出去
std::cout &lt;&lt; (int)&amp;b &lt;&lt; std::endl; 打印b地址
std::cout &lt;&lt; (int)&amp;g_a &lt;&lt; std::endl; 打印&amp;g_a地址
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ec1534f1cf3d06a02f0d59ccdbb4f1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cadcfd82966d939811b4d500426e151/" rel="bookmark">
			【刷题】 leetcode 面试题 01.06 字符串压缩
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字符串压缩 字符串压缩思路一（双指针顺畅版）思路二（sprintf函数巧解版） Thanks♪(･ω･)ﾉ谢谢阅读下一篇文章见！！！ 字符串压缩 来看题目：
根据题目所说，我们需要完成函数书写，保证返回一个相对较小的字符数组：如果压缩后比原字符串小，则返回压缩字符串，否则返回原字符串。
思路一（双指针顺畅版） 本思路一步一步操作，逐步完成任务
先确认字符串长度是否小于 2 ，小于直接返回（因为压缩字符串长度至少是2）然后定义双指针和计数位开始遍历 ： *fast 与 *slow 不相等 则 fast向后移动然后记录重复次数重复次数分位数进入数组slow 到 fast 位置 ， 计数归零重复 3 - 6 直到遍历结束 char* compressString(char* S){ int len1 = strlen(S); if(len1&lt;=2) return S; // 双指针 char* slow = S; char* fast = S; //记录次数 每个字母至少出现 1 次 int count = 1; //开辟一个足够大的数组空间 char* ret = (char*)malloc(sizeof(char) * 100001); int i = 0; //开始遍历 while(*fast !='\0'){ //快指针 后移 fast = fast + 1; //向后移动 直到不同 while(*fast == *slow){ fast++; count++; } //计算位数 方便下面的赋值操作 int n = 0; int num = count ; while(num){ num /=10; n++; } int n2 = n; // ret 数组赋值 ret[i++] = *slow; while(n--) { ret[i + n] = count % 10 + '0' ; count /= 10; } // 下标后移 i += n2; // 慢指针移动到快指针位置 slow = fast; //计数重置 count = 1; } //结尾 ‘\0’不能忘记 ret[i] = '\0'; int len2 = strlen(ret); //返回较小的 字符串 if(len2 &lt; len1) return ret; else return S; } 思路二（sprintf函数巧解版） 上一步的写入计数的步骤十分繁琐，而使用sprintf函数可以巧妙化解这个问题
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cadcfd82966d939811b4d500426e151/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/628abf13f566b1b62d2d1e0bed12a301/" rel="bookmark">
			php框架laravel项目中错误与解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Laravel 中，项目解决方案通常包括一系列的组件、模式和约定，用于快速开发高质量的 Web 应用程序。下面是一段关于 Laravel 项目解决方案的简短介绍：
"Laravel 提供了一个完整的项目解决方案，旨在帮助开发人员快速构建可靠、安全且易于维护的 Web 应用程序。该解决方案基于一系列的组件、模式和约定，提供了许多功能和工具，以简化开发过程并提高开发效率。
Laravel 的项目解决方案中包含了以下关键特性：
MVC 架构：Laravel 遵循经典的 MVC（Model-View-Controller）架构模式，使代码分离和组织变得更加清晰。开发人员可以将业务逻辑、数据操作和用户界面分别放置在不同的层中，以提高代码的可读性和可维护性。
路由和控制器：Laravel 提供了强大的路由系统，可以定义 URL 和相应的处理逻辑之间的映射关系。结合控制器，开发人员可以轻松地处理请求和生成响应，实现灵活的路由和请求处理。
数据库访问和迁移：Laravel 内置了 Eloquent ORM，简化了与数据库的交互和操作。通过定义模型和数据迁移，开发人员可以轻松地进行数据库查询、关联和表结构变更等操作，提高开发效率。
视图和 Blade 模板引擎：Laravel 使用 Blade 模板引擎来生成动态的 HTML 视图。Blade 提供了丰富的模板语法和控制结构，使视图的渲染和布局变得更加简单和灵活。
认证和授权：Laravel 提供了完善的身份认证和授权机制，可以轻松地实现用户注册、登录和访问控制等功能。开发人员可以使用内置的认证组件，也可以根据需求进行定制和扩展。
除了上述特性外，Laravel 还拥有丰富的社区和生态系统，提供了大量的扩展包和工具，以满足不同项目的需求。无论是小型应用还是复杂的企业级系统，Laravel 的项目解决方案都能够为开发人员提供一种高效、可靠且愉快的开发体验。
问题一.项目接口调试报错对象成员变量不存在，如下
Trying to get property 'role_id' of non-object
方案：问题定位是由于未获取到相应对象，就直接获取成员变量导致的，解决方案如下，加入空对象判断或非对象数组的判断或者直接转换成数组
问题二.接口报-试图访问null类型值的数组偏移量，如下
Trying to access array offset on value of type null
解决方案：对变量做不存在的默认赋值和数组整体默认定义，防止获取数组的时候变量取不到和数据不存在
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93a1d34a4d0a250325b082ac83c5c25b/" rel="bookmark">
			R语言rvest爬虫如何设置ip代理？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在R语言中使用rvest进行网络爬虫时，可以使用代理服务器来隐藏真实IP地址。有一些R包可以帮助爬虫中设置代理，其中一个常用的包是httr。以下是一个简单的例子，演示如何在rvest中设置IP代理：
library(httr)
library(rvest)
# 设置代理服务器地址和端口
proxy_url &lt;- "http://your_proxy_address:your_proxy_port"
# 创建一个代理配置
proxy_config &lt;- use_proxy(url = proxy_url)
# 使用代理配置进行网络请求
response &lt;- html_session(url = "http://example.com", config = proxy_config)
# 使用rvest提取数据
# 以下是一个简单的例子，你需要根据实际网页结构修改选择器
data &lt;- response %&gt;%
html_nodes("your_css_selector") %&gt;%
html_text()
# 打印提取的数据
print(data)
上述代码中的代理地址（your_proxy_address）和端口（your_proxy_port）应该替换为实际使用的代理服务器地址和端口。
此外，可能需要检查代理服务器是否需要身份验证，如果是，需要在use_proxy函数中提供用户名和密码参数。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01f7253ee6338a1979f936639d18bb19/" rel="bookmark">
			EasyExcel无法转换LocalDateTime日期类型的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EasyExcel是2.x版本时
import com.alibaba.excel.converters.Converter; import com.alibaba.excel.enums.CellDataTypeEnum; import com.alibaba.excel.metadata.CellData; import com.alibaba.excel.metadata.GlobalConfiguration; import com.alibaba.excel.metadata.property.ExcelContentProperty; import java.time.LocalDateTime; import java.time.format.DateTimeFormatter; /** * 解决 EasyExcel 日期类型 LocalDateTime 转换的问题 */ public class LocalDateTimeConverter implements Converter&lt;LocalDateTime&gt; { @Override public Class&lt;LocalDateTime&gt; supportJavaTypeKey() { return LocalDateTime.class; } @Override public CellDataTypeEnum supportExcelTypeKey() { return CellDataTypeEnum.STRING; } @Override public LocalDateTime convertToJavaData(CellData cellData, ExcelContentProperty contentProperty, GlobalConfiguration globalConfiguration) { return LocalDateTime.parse(cellData.getStringValue(), DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")); } @Override public CellData&lt;String&gt; convertToExcelData(LocalDateTime value, ExcelContentProperty contentProperty, GlobalConfiguration globalConfiguration) { return new CellData&lt;&gt;(value.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01f7253ee6338a1979f936639d18bb19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40eebd01159ed9c46855ae19b3e5dfec/" rel="bookmark">
			【nginx实战】nginx正向代理、反向代理、由反向代理实现的负载均衡、故障转移详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一. 正向代理与反向代理的概念二. Nginx服务器的正向代理服务1. Nginx服务器正向代理服务的配置的3个指令1.1. resolver指令1.2. resolver_timeout指令1.3. proxy_pass指令 2. Nginx服务器正向代理服务的使用 三. Nginx服务器的反向代理服务1. 反向代理的基本指令1.1. proxy_pass指令1.2. proxy_set_header指令1.3. proxy_ignore_headers指令1.4. proxy_timeout1.5. proxy_connect_timeout 四. Nginx服务器的负载均衡1. nginx的upstream负载均衡方式1.1. 轮询（默认）1.2. weight1.3. ip_hash1.4. 最少连接least_conn 3. 负载均衡常见参数4. 实现例子4.1. 例子1：轮询4.2. 例子2：对特定资源实现负载均衡 4.3. 例子3：对不同域名实现负载均衡 五. nginx实现故障转移1. 基本逻辑1.1. nginx判断节点失效的逻辑1.2. nginx处理节点失效和恢复的逻辑1.3. 所有节点失效后nginx将重新恢复所有节点进行探测 2. proxy_next_upstream + proxy_connect_timeout3. Backup Servers 六. 案例分析1. 问题描述2. 问题分析与解决 本文将要讨论以下内容
正向代理与反向代理的基本概念Nginx正向代理服务的配置指令、Nginx反向代理服务的配置指令Nginx反向代理服务器的应用——负载均衡、故障转移案例分析 一. 正向代理与反向代理的概念 正向代理的概念
局域网内的机器借助代理服务访问局域网外的网站，此代理服务器提供的服务就为正向代理服务。
作用
主要是为了增强局域网内部网络的安全性，使得网外的威胁因素不容易影响到网内，这里代理服务器起到了一部分防火墙的功能。利用代理服务器也可以对局域网访问外网进行必要的监控和管理。 正向代理服务器不支持外部对内部网络的访问请求，即图的箭头方向不能反过来。
反向代理的概念
如果局域网向Internet提供资源，让Internet上的其他用户可以访问局域网内的资源，此代理服务器提供的服务就叫做反向代理（Reverse Proxy）服务。
小结
正向代理服务器用来让局域网客户机接入外网以访问外网资源，反向代理服务器用来让外网的客户端接入局域网中的站点以访问站点中的资源。
在正向代理服务器中，我们的角色是客户端，目的是要访问外网的资源；在反向代理服务器中，我们的角色是站点，目的是把站点的资源发布出去让其他客户端能够访问。
二. Nginx服务器的正向代理服务 1. Nginx服务器正向代理服务的配置的3个指令 1.1. resolver指令 该指令用于指定DNS服务器的IP地址。DNS服务器的主要工作是进行域名解析，将域名映射为对应的IP地址。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40eebd01159ed9c46855ae19b3e5dfec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb419e3134b7b5e4003e2fcbcf139a79/" rel="bookmark">
			Windows服务启动类型：自动（延迟启动）、自动、手动、禁用介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Windows服务启动类型解析一、Windows服务简介1.1 Windows服务的特点无需用户交互启动时间可配置运行账户可配置 二、Windows服务启动类型详解2.1 自动（延迟启动）2.2 自动2.3 手动2.4 禁用 三、Windows服务启动类型的配置和管理3.1 使用“服务”管理工具3.2 使用PowerShell查看所有服务的状态查看指定服务的状态将指定服务设置为自动（延迟启动）将指定服务设置为自动：将指定服务设置为手动：将指定服务设置为禁用： Windows服务启动类型解析 在Windows操作系统中，许多关键的系统和应用功能是通过后台服务来实现的。这些服务的管理和配置方式对于系统的稳定性、安全性和性能至关重要。本文将深入探讨四种Windows服务的启动类型：自动（延迟启动）、自动、手动、禁用，并提供相关示例代码进行演示。
一、Windows服务简介 Windows服务是运行在Windows操作系统上的长期运行的进程。这些服务可以在系统启动时开始运行，并且在没有用户交互的情况下在后台运行。例如，防火墙服务、打印机服务、数据库服务等都是常见的Windows服务。
1.1 Windows服务的特点 无需用户交互 服务在后台运行，不需要用户的干预。
启动时间可配置 可以配置服务在系统启动时自动启动，也可以配置为手动启动或者完全禁止启动。
运行账户可配置 服务可以运行在指定的用户账户下，这有助于实现权限管理和隔离。
二、Windows服务启动类型详解 Windows服务的启动类型主要有四种：自动（延迟启动）、自动、手动、禁用。它们主要区别在于服务启动的时间和方式。
2.1 自动（延迟启动） 在Windows服务中，将启动类型设置为“自动（延迟启动）”意味着当系统启动时，这个服务不会立即启动，而是会稍微延迟一段时间。这主要是为了优化系统的启动速度。
例如，某些非关键性服务如打印机服务可以设置为自动（延迟启动），这样用户在开机后能更快地访问系统，而打印机服务则会在后台稍后启动。
示例代码：
（注意：命令仅供参考，实际最好通过界面设置）
Set-Service -Name "myservice" -StartupType AutomaticDelayedStart 2.2 自动 如果将服务的启动类型设置为“自动”，则该服务将在系统启动时立即开始运行。对于一些重要的系统服务，如防火墙或者安全更新服务，通常会设置为自动启动。
示例代码：
Set-Service -Name "myservice" -StartupType Automatic 2.3 手动 手动启动类型意味着服务只有在明确收到启动命令时才会运行。这种类型适用于那些并非总是需要运行，但在需要时可以手动启动的服务，例如，一些诊断工具或者测试服务。
示例代码：
Set-Service -Name "myservice" -StartupType Manual 2.4 禁用 禁用启动类型意味着服务无法启动，除非改变其启动类型。这通常用于那些不再需要或者存在安全风险的服务。
示例代码：
Set-Service -Name "myservice" -StartupType Disabled 三、Windows服务启动类型的配置和管理 对Windows服务进行配置和管理，可以通过Windows内置的“服务”管理工具，也可以通过命令行工具如PowerShell进行操作。下面将分别介绍这两种方式。
3.1 使用“服务”管理工具 在Windows系统中，点击“开始”菜单，搜索“服务”，打开后即可看到系统中所有的服务及其当前状态和启动类型。
选择某个服务，右键点击选择“属性”，在打开的窗口中就可以看到该服务的详细信息，包括启动类型。点击下拉菜单就可以修改启动类型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb419e3134b7b5e4003e2fcbcf139a79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea2dea8215558119035a924128432f40/" rel="bookmark">
			“80后”清华博士，成省里新设立的机构“一把手”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		撰文丨余晖 责任编辑：张玉
1月18日，青海省人民政府发布一批职务任免通知，其中任命靳力同志为青海省数据局局长（副厅级），免去其青海省工业和信息化厅副厅长、青海省招商局副局长（兼）职务。
青海省数据局是青海省机构改革后新成立的部门。1月15日，青海省数据局揭牌仪式在西宁举行。
靳力出生于1980年10月，今年44岁，重庆人，籍贯为河北保定。1999年，他被保送进入清华计算机系，2008年获得博士学位。
毕业后，靳力远赴青海工作，挂职省信息中心副主任，一干就是6年多。
2014年9月，他改任海北州发改委主任，次年11月起担任海东市平安区区委书记。2021年，靳力任青海省工信厅副厅长兼省招商局副局长，分管数字经济。
靳力的妻子王晓英也是一名赴青海工作的清华大学博士。
王晓英出生于1982年7月，吉林双辽人，毕业于清华大学计算机系，工学博士学位。2008年8月起在青海大学工作，曾任计算机技术与应用系常务副主任（正处级），2015年6月任校长助理，2018年5月任副校长。
她主要从事计算机专业本科生及研究生教学工作，科研方向为高性能计算、并行计算、绿色计算等。
王晓英目前是正厅级干部。2023年6月，王晓英履新青海省科协党组书记。
毕业那年，靳力和王晓英在接受采访的时候说：“我们要敢于挑战，但是更重要的是坚持。不是为了我们的生活更好，而是为了更多的人生活更好，这是我们的人生观，也是在将来的坎坷道路上让我们能够坚持理想的动力。”
靳力曾在清华大学2021年毕业典礼上发表致辞。他说，“我是1999到2008年在系里本硕博连读，毕业后跟爱人一起到了青海”。
当时，他表示，13年时间，自己从专业干到了经济、政治，又干回了专业，“这个历程中，一路风雨、一路汗水、一路体验、一路美景，目前仍在实现理想的途中”。
如今，靳力履新青海省数据局局长（副厅级）。
1月15日，青海省数据局揭牌仪式在西宁举行。
据《青海日报》报道，该省机构改革新成立青海省数据局，负责全省数字基础设施、数据基础制度、数据共享开发利用、数据安全以及政务服务和公共资源交易监督管理等工作，承担着统筹推进数字青海、数字经济、数字社会发展的职责。
当前，青海省的清洁能源发展优势以及独特的气候条件，为数字经济发展提供了重大机遇。
青海省数据局主要负责同志表示，将尽快完成数据局组建后续工作，按照省委省政府决策部署，主动融入新发展格局，立足省情实际，加强对数字青海、数字治理、数字赋能、绿色算力、数字经济等领域的深入研究，做好工作谋篇布局和顶层设计，依托对口支援、东西部协作、定点帮扶、招商引资等多重机制，加快形成全省数字经济“规划、基地、项目、政策、企业”五位一体协同推进的工作格局，以数字赋能助力打造生态文明高地、建设产业“四地”，为推动全省高质量发展增添新动力。
往期精彩回顾 适合初学者入门人工智能的路线及资料下载(图文+视频)机器学习入门系列下载机器学习及深度学习笔记等资料打印《统计学习方法》的代码复现专辑 交流群 欢迎加入机器学习爱好者微信群一起和同行交流，目前有机器学习交流群、博士群、博士申报交流、CV、NLP等微信群，请扫描下面的微信号加群，备注：”昵称-学校/公司-研究方向“，例如：”张小明-浙大-CV“。请按照格式备注，否则不予通过。添加成功后会根据研究方向邀请进入相关微信群。请勿在群内发送广告，否则会请出群，谢谢理解~（也可以加入机器学习交流qq群772479961）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18d0270b21652588aa0203665cdb56be/" rel="bookmark">
			一文读懂增强现实（AR)技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着信息技术的高速发展，虚拟现实、增强现实等逐渐火热。虚拟现实是一种完全建立虚拟环境，让人类脱离现有环境进入新的世界，它的广泛应用可能还要经过一段时间的积淀，目前虚拟现实主要在科研仿真、虚拟漫游、游戏娱乐、教育培训等领域发挥作用。而从虚拟现实中发展起来的增强现实，旨在增强人类能力，为人类提供各种辅助信息，成为沟通人类个体与信息世界的重要枢纽。目前已经在医疗、交通、教育培训、航天、通信、工业维修等领域发挥作用。相信增强现实的大规模应用会比虚拟现实更早一些，可能取代智能手机，成为下一代智能计算与显示平台，将物理世界与信息世界联系得更加紧密。这里，我们主要谈一下增强现实的相关内容。
1
增强现实概念
增强现实（Augmented Reality，简称AR）技术是一种基于计算机实时计算和多传感器融合，将现实世界与虚拟信息结合起来的技术。该技术通过对人的视觉、听觉、嗅觉、触觉等感受进行模拟和再输出，并将虚拟信息叠加到真实信息上，给人提供超越真实世界感受的体验。目前广泛接受的一种定义是Azume在1997年提出的，他认为AR应该具有三个特征：
结合真实与虚拟
实时交互
支持三维注册
我们所要讨论的增强现实，主要是视觉增强现实技术，核心在于虚拟信息和真实世界在物理空间中的匹配以及可视化。增强现实是一个多学科交叉的研究领域，内容纷繁复杂，选取其中某个点深入下去都可以作为长久的研究课题。一个完整的AR系统至少有三个部分：跟踪、注册和显示。
2
增强现实技术起源
Sutherland在1968年完成了第一台头盔显示器，堪称头盔显示器的开山祖师。不过由于当时技术限制，该设备非常笨重，需要悬挂在房顶上使用，于是被戏称为“达摩克利斯之剑”。
70年代、80年代也有很多研究者做了相关的研究工作，但是直到90年代初期，“Augmented Reality”这个词汇才首次诞生。渐渐地，增强现实脱去虚拟现实的外衣，成为一个独立的研究领域。
随着21世纪初期智能手机的兴起，增强现实有了天然的开发载体，视频式的增强现实迅速发展起来。这也得益于ARToolKit和Vuforia等基于图像的跟踪定位工具的相继推出。如下图，使用智能手机和平板电脑作为平台的增强现实应用，目前已经非常普遍。
但是，智能手机和平板电脑毕竟只是视频式的增强现实，相比于光学式的来说，还是少了一点科技感和刺激感。于是谷歌在2012年发布了Google Glass，为增强现实的发展注入了新的活力。它对于AR发展的作用应该就像是Facebook的Oculus Rift之于虚拟现实一般。2014年3月26日，Facebook宣布将以约20亿美元的总价收购沉浸式虚拟现实技术公司Oculus VR。这一事件极大地推动了虚拟现实的发展。
类似地，Google等商业巨头投身AR，也必将对AR起到巨大作用。尽管后来GoogleGlass停产，但是其作用不可忽视。之后，又有更多的公司推出了自己的光学式增强现实眼镜，最著名的是Microsoft Hololens和Maigc Leap。
3
增强现实研究内容分解
1、显示技术
近眼式显示设备
近眼显示设备主要是指头盔显示器。头盔显示器主要分为两种：光学透射式头盔显示器和视频透射式头盔显示器。当然如果按照显示器件数量，也可以划分为单目头盔显示器和双目头盔显示器。这里主要讨论光学式（左）和视频式（右）的区别。
光学透射式头盔显示器是直接透射外界的光线，并且反射微投影器件产生的虚拟图像到人眼中，达到虚实融合的效果。优点是可以保证正确的视点和清晰的背景，缺点是虚拟信息和真实信息融合度低，且人眼标定比较复杂。目前市面上典型的光学透射式头盔显示器有Hololens和Meta2等。
而视频透射式头盔显示器，是将固定在头盔上的摄像头所捕获的图像，通过视点偏移来显示到眼前的显示器上。优点是虚实融合效果好，无需标定人眼，缺点是视点难以完全补偿到正确的位置，且与镜片范围外的环境不能完美衔接。将上面的光学透射式头盔显示器，加上摄像头，并且把带有增强信息的视频直接全屏显示，就成为了视频透射式设备了。很巧的是，很多光学透射式设备，确实在其上加装了这种摄像头，但是它们的本意是用摄像头来作为跟踪模块的。
手持式显示设备
手持式显示设备，顾名思义就是拿在手上的显示设备。最常见的就是我们的智能手机和平板电脑。这类设备具有很好的便携性，是一种天然的AR设备。它们有摄像头作为图像输入设备，有自带的处理器，有显示单元，具备了进行AR开发的所有条件。在目前市面上，很多增强现实APP都是围绕这类设备开发的。
固定式显示设备
桌面级显示器，这是我们日常生活中最常见的一类显示器了。给它添加一个网络摄像头，就可以完成AR任务了。该摄像头可以捕捉空间中的图像，然后估计摄像头的位置和姿态，最后计算生成虚拟信息，并进行虚实融合，输出到桌面显示器上。这类设备适合做一些科研类的开发，对于商业应用显得有些笨重，比起手机和平板来说稍逊一筹。
虚拟镜子，这是利用摄像头对着人进行拍摄，然后输出到一个类似于镜子的大型显示器上，给人一种照镜子的感觉。同时，还可以进行虚拟换装，或者添加一些虚拟物件，达到AR效果。
还有一些固定显示器，类似于雾幕、水幕、全息膜等，在上面投影出增强信息，可以实现AR效果。
投影式显示设备
投影机是一种重要的虚拟现实和增强现实设备。最常见的基于投影的增强现实系统是在展会上的各种绚丽的投影展品，包括虚拟地球、汽车表面投影等。这类系统属于空间增强现实系统。另外，柱幕、球幕、环幕投影也可以归为基于投影的空间增强现实。
投影机还可以用于构建CAVE系统。手持式投影机结合图像捕捉设备，还可以建立动态的空间增强现实系统。
小结与分析
增强现实中主要的显示设备就是以上这些。如果要开展关于显示技术的研究，从硬件方面来讲，就是显示材料、器件的研发。当然这与增强现实并没有高度相关性，只能说显示设备参数的提升，可以间接促进增强现实系统性能提升。但是显示方面，软件还是可以有些值得做的东西，并且与增强现实体验息息相关。那就是头盔显示器的显示畸变校正和投影机画面拼接融合，这些技术都直接影响着增强现实系统虚实融合精度和整体可用性。
研究增强现实技术的人，很多是侧重于系统集成和应用测评，或者是直接将AR系统应用在其他的研究领域。因此，这些人一般不会研究显示元器件的细节，而更加关注如何拿现有的材料或者设备来构建新型显示系统。如果能够做出新的AR系统，并且具有实用意义，也是非常有研究价值的。
2、跟踪技术
跟踪理论会涉及到一些空间坐标转换的基础知识，以摄像机跟踪为例，分为模型坐标空间、世界坐标空间、摄像机坐标空间和图像坐标空间。由于比较细节，这里不展开讨论，相关知识可以查阅计算机视觉书籍即可。这里以不同种类的跟踪系统为例来讨论跟踪技术。
固定式跟踪系统
机械跟踪器通过控制机械臂各个关节的转动来跟踪机械臂末端的空间位置，属于比较老的跟踪方式，但是精度可以控制得比较高。
电磁跟踪器是通过一个固定的发射源发射出三维正交的电磁场，接收端通过检测接收到的电磁场的方向和强度来确定位姿。
超声波跟踪器则是通过测量一个声音脉冲从发射源到传感器的飞行时间来测量距离。
移动式传感器
GPS，全称是全球定位系统。这个系统在智能手机上应用很普遍。它通过接收多颗卫星信号来确定当前所处的位置。对于户外大范围增强现实有着重要意义。
无线网是通过检测移动设备接入点信息来粗略确定移动设备所处位置的。它可以配合GPS使用。
磁力计，也称电子罗盘，通过检测地球的磁场来确定方向。
陀螺仪和线性加速度计都是依靠惯性来进行测量的。陀螺仪测量三轴角度变化，线性加速度计测量位置变化。它们通常会配合使用，并且常以微机电系统（MEMS, Micro-Electro-Mechanical System）的形式存在。
里程计是通过轮式或者光电编码器来测量所走过路程的一种传感器，常用在机器人或者交通工具中。
光学跟踪技术
（1）跟踪模式
有些跟踪需要对被跟踪的目标预先建模，例如一些图像跟踪工具箱。有的则不需要提前建模，例如同步定位与跟踪技术（SLAM）。多数跟踪是需要提前建立一个待跟踪模型数据库的，然后在运行中实时提取特征并且与数据库中的数据进行比对。而SLAM则可以实时根据获得的特征，自主建立空间地图，并且确定摄像头相对于环境的位置。
目前研究的比较火热的是SLAM。因此，可以研究SLAM中的各个环节，从跟踪、建图、回环检测等角度研究如何提升SLAM系统的精度，以及面对复杂环境的稳定性问题。
（2）照明种类
跟踪的稳定性与环境光有关，尤其是基于视觉的跟踪。有些跟踪系统不需要自主添加光源，只是利用环境光，称为被动照明；有些跟踪需要主动发射某种照明光线，来实现其跟踪，称为主动照明。被动照明是比较常见的，例如平面标志跟踪就是在普通的环境照明下实现的。主动照明最典型的就是结构光照明，例如Kinect。还有一种主动发射红外光的OptiTrack系统，做姿态跟踪效果很好。
（3）人工标志与自然特征
人工标志指的是人造的用于跟踪的图像标志等。例如二维码、棋盘格等。自然特征指的是自然环境中本身就有的特征，不是人为放置用来跟踪的特征。普通的室内环境、街边的楼宇都可以认为是自然特征。人工标志根据其种类不同，需要特定针对性算法进行检测和跟踪，自然特征通常使用SIFT、SURF、ORB等特征描述子来进行特征提取和跟踪。
传感器融合
互补式融合：不同的传感器测量的是不同种类的参数，可以互相补充。
竞争式融合：不同传感器测量的是同一个种类的参数，则使用某种方式将它们结合起来，产生一个更好的测量结果.
协作式融合：不同传感器之间是协作关系，其中某个传感器可能依赖于其他的传感器才能得出结果。
小结与分析
笔者认为，纯粹的跟踪技术研究，不仅可以服务于增强现实，也可以服务于虚拟现实，以及其他需要用到该技术的领域。研究跟踪技术，可以从多视图几何方向入手，通过几何的方式来估计位姿。也可以从特征角度入手，针对特定的问题，设计不同的特征表述方式，解决问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18d0270b21652588aa0203665cdb56be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fcda78154b15f1772f49cd19c622d1c/" rel="bookmark">
			通过rebuttal，分数336的论文变成666，中稿ICRL！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大部分没有投稿经验的科研者在rebuttal时，都不太敢和审稿人正面“刚”，认为rebuttal的作用并不大，甚至无法判断自己的文章是不是应该继续rebuttal还是转投其他会议？
实际上rebuttal是最后一次能够挽救论文的机会，既然设置了这个环节，必然有其存在的合理性！
基于之前多次rebuttal成功并中稿nips、icml、iclr等会议经验，我总结了主要有以下几类审稿人意见：
· 你为什么不跟xxx对比
· 我觉得效果不太行
· 我觉得novelty不够
· 没理解核心贡献而着眼于喷细枝末节的小点
· 我觉得文章写的不清楚
针对以上这些审稿意见，完全可以利用一些巧妙的方法去回答审稿人以及适当时机寻求ac帮助，我将这些经验全部整理成一门课程，限时分享给大家，仅限前100名。
0.01元解锁4节精品课
rebuttal全套技巧
（文末有多项福利可免费领取）
课程目录：
第一节 是否值得Rebuttal
•用数据说话
•基本判断法
第二节 深入剖析Rebuttal
•顶会投稿审稿流程介绍
•审稿人审稿时的心态
•写Rebuttal 应该有的心态
第三节 Rebuttal的有效方法
•四个步骤
•会议和审稿意见的分类
•常用写法
第四节 Rebuttal成功案例解析
•成功案例分析
•失败案例总结
获取大佬科研合作资源
对于本身学历背景不好，但是专业知识扎实的，只是缺少一个“伯乐”的同学，我们为你提供了和Top10名校研究员，例如MIT、Cambridge等名校导师联名合作发表的机会，并提供全额奖学金博士名额机会，涉及计算机视觉、计算机自然语言处理、机器学习、强化学习等多个方向。
滑动查看更多图片
获取合作方式及其他合作项目详情
扫下方二维码
备注：【合作】
送书福利
对于基础薄弱的同学，我们整理了一套人工智能入门必备电子书，只要踏踏实实学习一半，你就能独立进入科研的水平，至少达到发表c类会议水平的科研能力，以下资料全部免费赠送。（部分电子书直接提供中文版，英语不好的同学的也完全不用担心不够友好。）
获取免费书籍，扫下方二维码
备注：【论文】
“为爱发电”项目
为支持广大学术研究者更高效进行科研追踪，上海得思科技助力“为爱发电”项目，一个免费每日论文平台--【学术巷子】（扫码可达）
https://www.xueshuxiangzi.com
01 每日更新全球最新科研论文
网站每日10点将会更新当天全球最新论文，涵盖人工智能、计算机、经济学、数学、统计学等多学科方向。解决最新论文盲点，完全不会错过学术发展前沿。
02 包含中英文双语版本
网站不仅提供英文原版论文，还提供中文翻译版论文，都可直接免费下载！
03 高效选择是否选择精读论文
可根据中文摘要寻找感兴趣的论文，还有QA环节让你提前了解整个论文重点，以此决定是否要精读论文。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a178fe137c9000958ccf97a5c1e77ab1/" rel="bookmark">
			电脑硬盘数据恢复？这3个方法不要错过！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“我在使用电脑办公时，不小心将电脑硬盘里的数据误删了。这些数据对我来说都是比较重要的！有什么比较简单的方可以恢复吗？” 电脑硬盘中一般会保存用户很多重要的资料和数据，如果这些资料误删了，可能会带来各种麻烦和不便。怎么进行电脑硬盘数据恢复呢？对于很多用户来说，这或许是件很困难的事。
但掌握了正确的操作方法，恢复硬盘数据并没有那么难。有需要的用户请继续往下看吧！
方法一：借助回收站恢复硬盘数据 硬盘误删除文件怎么恢复？如果在使用电脑时误删了重要的数据，先别着急，建议先到【回收站】中对相关数据进行查看。回收站会保存电脑里最近删除的一些文件，因此采用该方法有利于快速恢复文件。
步骤1：双击回收站图标，进入后，对文件进行查看和选择；
步骤2：将所有需要恢复的文件都选择完毕后，可点击【还原选定的项目】。
方法二：借助备份恢复硬盘数据 硬盘被格式化了怎么恢复数据？如果曾对硬盘中的重要数据进行过备份，借助备份恢复重要数据是比较高效的。用户可尝试找到备份文件，通过备份数据更快速恢复重要数据。
步骤1：找到备份文件所在的设备或云端；
步骤2：将需要恢复的文件重新复制或保存到电脑上。
方法三：借助专业软件恢复硬盘数据 如果删除的数据是比较重要的，进行电脑硬盘数据恢复更为高效的一种方法是借助专业的数据恢复软件来完成数据恢复。在众多的软件中，数 据 蛙 恢 复 专 家 是更为值得信赖的，软件拥有安全保密的操作系统，且数据恢复的效果较显著，成功帮助众多电脑用户找回了重要的文件。如果发现有重要的数据丢失，建议及时使用该软件。软件的操作步骤如下。
操作环境： 演示机型：华硕TUF Dash FX516PM 系统版本：Windows10 软件版本：数 据 蛙 恢 复 专 家 3.2.12 步骤1：将软件安装在合适的磁盘中并运行软件，进入软件后，先点击【免费试用】；
步骤2：先勾选上要进行扫描的磁盘，再勾选上需要扫描的文件类型（新手建议全选），完成后，点击【扫描】；
步骤3：软件初次扫描完成后，可根据个人喜好选择查看方式，并在右侧对扫描结果进行查看，如果结果中没有找到相应的文件，点击【深度扫描】；
步骤4：软件深度扫描完成后，可对所有扫描到的文件进行扫描，在文件较多的情况下，建议用户借助【筛选器】对重要文件进行定位，完成定位后，勾选上要恢复的文件，并点击【导出】。
提示：在选择导出磁盘时，建议勾选一个与文件原保存磁盘有所区别的磁盘。 总之，在实际使用电脑时，如果遇到电脑文件丢失的问题时，可以尝试使用上述方法找回数据。但电脑硬盘数据恢复是一项需要谨慎和专业技术的工作。如果你不确定如何操作或遇到困难，最好寻求专业的帮助。同时，为了避免数据丢失，建议定期备份重要数据并采取措施保护数据的完整性和安全性。
往期推荐：
回收站删除的照片怎么恢复？恢复文件，3个方法！https://blog.csdn.net/datarecover/article/details/135763939?spm=1001.2014.3001.5501
电脑摄像头设置在哪里？这3种打开方式要记好！https://blog.csdn.net/datarecover/article/details/135764841?spm=1001.2014.3001.5501
我的文档不见了怎么恢复？3个方法快速恢复！https://blog.csdn.net/datarecover/article/details/135765977?spm=1001.2014.3001.5501
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24536378c5537fa1c3fdc0aaae084daf/" rel="bookmark">
			Vue3 Teleport
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✨ 专栏介绍 在当今Web开发领域中，构建交互性强、可复用且易于维护的用户界面是至关重要的。而Vue.js作为一款现代化且流行的JavaScript框架，正是为了满足这些需求而诞生。它采用了MVVM架构模式，并通过数据驱动和组件化的方式，使我们能够更轻松地构建出优雅而高效的Web应用程序。在本专栏中，我们将深入学习Vue.js的核心概念、组件开发、状态管理、路由和性能优化等方面的知识。无论你是初学者还是有一定经验的开发者，通过学习Vue.js，你将能够构建出令人印象深刻的用户界面，并提升自己在Web开发领域的竞争力。让我们一起开始Vue.js之旅吧！
文章目录 ✨ 专栏介绍引言Teleport的介绍示例使用场景示例模态框弹出菜单 总结😶 写在结尾 引言 Vue3是一款流行的JavaScript框架，用于构建用户界面。它提供了许多强大的功能，其中之一就是Teleport。Teleport是Vue3中的一个新特性，它允许我们将组件的内容渲染到DOM树中的任何位置。本文将详细介绍Teleport的实现原理、用法以及各种使用场景示例。
Teleport的介绍 Teleport是Vue3中一个非常有用的功能，它允许我们在组件内部定义内容，并将其渲染到DOM树中的任何位置。这意味着我们可以将组件的内容放置在任何地方，而不仅仅局限于组件自身所在的位置。
Teleport通过使用Vue3提供的teleport指令来实现。该指令接受一个目标元素作为参数，并将组件的内容渲染到该目标元素所在位置。
当使用Teleport时，可以接受以下类型的目标元素：
ID选择器：可以使用#符号加上ID名称来指定目标元素，例如#target。类选择器：可以使用.符号加上类名称来指定目标元素，例如.target。元素选择器：可以直接使用元素名称来指定目标元素，例如div、span等。属性选择器：可以使用方括号加上属性名称和属性值来指定目标元素，例如[data-target=“example”]。 除了以上常见的选择器类型外，Teleport还支持更复杂的选择器语法，如组合选择器、伪类选择器等。
示例 在组件模板中使用teleport指令，并指定目标元素。Vue3会在组件渲染过程中创建一个虚拟节点（VNode）来表示被渲染到Teleport目标元素中的内容。在组件更新过程中，Vue3会检测到Teleport指令，并将虚拟节点渲染到目标元素所在位置。
用法 使用Teleport非常简单。我们只需要在组件模板中使用teleport指令，并指定目标元素的选择器。
下面是一个简单的示例：
&lt;template&gt; &lt;div&gt; &lt;h1&gt;Teleport示例&lt;/h1&gt; &lt;teleport to="body"&gt; &lt;p&gt;这段内容将被渲染到body元素中。&lt;/p&gt; &lt;/teleport&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: 'TeleportDemo', } &lt;/script&gt; &lt;style scoped&gt; #target { background-color: lightblue; } &lt;/style&gt; 在上面的示例中，我们使用了teleport指令，并将内容渲染到了body的元素中。当组件渲染时，
这段内容将被渲染到目标元素中。
会被渲染到body的元素内部。 使用场景示例 Teleport可以用于许多不同的场景。下面是一些常见的使用场景示例：
模态框 &lt;template&gt; &lt;div&gt; &lt;button @click="showModal = true"&gt;打开模态框&lt;/button&gt; &lt;teleport to="#modal"&gt; &lt;modal v-if="showModal" @close="showModal = false"&gt;&lt;/modal&gt; &lt;/teleport&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Modal from '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24536378c5537fa1c3fdc0aaae084daf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6160039d3a07adbcb5714cac4a51d6f/" rel="bookmark">
			idea引入jar包作为maven
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.引入jar包至项目中
2.配置当前项目的maven（如果只想在本机能运行的话，到这一步就够了，后面pom配置也不需要这一步）
3.配置文件的maven依赖路径
这里的 groupId 就是你引入原包的包路径，artifactId、version都是随便填的（artifactId最好是jar包名），scope意思是作用范围，按照这里配置就行了，systemPath指的是jar包的地址（如果你配完了在idea里可以试着点一下它，会到对应的jar包那）
&lt;dependency&gt; &lt;groupId&gt;com.okio.jvm&lt;/groupId&gt; &lt;artifactId&gt;okio-jvm&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;${pom.basedir}/lib/okio-jvm-3.0.0.jar&lt;/systemPath&gt; &lt;/dependency&gt; 4.配置打包插件
我们完成了以上的步骤后，本地是可以随便启动的，但如果你要用jenkins部署什么的，就会出现找不到包的情况
我们需要配置includeSystemScope，让它加入打包的过程中
&lt;includeSystemScope&gt;true&lt;/includeSystemScope&gt; 具体的作用可以看这一篇文章
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdaefc265fe2dea1f08c6ea6e52fd74a/" rel="bookmark">
			2023年第十六届中国系统架构师大会（SACC2023）：核心内容与学习收获（附大会核心PPT下载）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大会以“数字转型 架构演进”为主题，聚焦系统架构在数字化转型中的演进和应用。
与往届相比，本届大会最大的变化是从原来的大会演讲模式变革为专题研讨会模式。专题研讨会主题内容紧扣行业落地实践痛点与难点，多角度聚焦行业的架构演进之路。大会按照技术主线分为传统架构与运维技术发展（高可用架构、云架构、分布式存储、预测性智能运维）、数字化转型企业架构应用（金融行业与制造业）、IT技术前瞻架构（分布式与微服务架构、容器、AIGC）等板块。
本届大会云集了国内众多CTO/CIO、技术总监、高级系统架构师和IT经理等技术人群，共同探讨系统架构在数字化转型中的挑战和机遇。与会者可以深入了解多云多活、海量分布式存储、容器、云成本、AIGC大数据等热门领域，以及系统架构在金融、制造业、互联网、教育等行业的实际应用。
此外，本届大会还邀请了众多行业专家进行主题演讲和圆桌讨论，分享他们在系统架构领域的实践经验和见解。同时，大会还设置了实践工作坊和互动环节，让与会者可以亲身体验和实践相关技术，加深对系统架构的理解和掌握。
一、大会核心内容 1、云计算架构 随着云计算技术的普及，云计算架构的设计和优化成为了业界关注的热点。在会议上，专家学者分享了云计算架构的最佳实践、弹性伸缩技术、微服务架构等方面的经验和见解。
2、大数据架构 大数据技术的广泛应用对系统架构提出了新的挑战。大数据架构的设计与优化成为了重要议题。可以了解到大数据处理的核心技术、实时计算、数据存储等方面的最新进展。
3、人工智能与机器学习 人工智能技术的飞速发展为系统架构带来了新的机遇和挑战。会议邀请业内专家分享人工智能和机器学习在系统架构中的应用，探讨如何构建高效、可扩展的人工智能系统。
4、区块链技术与系统架构 区块链技术的兴起对传统系统架构产生了深远影响。会议深入探讨区块链技术的原理、应用场景以及如何将其应用于系统架构中，以实现更加安全、透明的数据管理。
5、系统安全与可靠性 随着系统规模的扩大和复杂度的增加，系统安全与可靠性成为了业界关注的焦点。会议邀请专家分享系统安全防护的最佳实践、容灾备份技术以及如何提高系统的可靠性和稳定性等方面的知识和经验。
二、能学习到什么？ 1、了解最新技术动态：会议汇聚了业界顶尖的专家学者和企业代表，他们带来最新的研究成果和实践经验。通过与他们的交流，可以了解到云计算、大数据、人工智能等领域的最新技术动态和发展趋势。
2、掌握最佳实践：在会议中，可以听到来自知名企业和研究机构的成功案例分享，了解他们是如何应对系统架构的挑战并取得成功的。这些最佳实践提供了宝贵的经验和启示，帮助更好地应对实际工作中的问题。
3、拓展专业视野：不仅能接触到国内外的先进技术，还能结识到来自不同领域和行业的专业人士。通过与他们的交流和互动，可以拓展专业视野，建立更广泛的人脉关系，为职业发展创造更多机会。
4、激发创新思维：会议议题涵盖了多个领域的前沿技术和热点问题，可以激发创新思维。通过与行业专家的交流和讨论，你将不断挖掘新的思路和方法，为自己的研究和工作带来更多灵感和突破。
5、提高专业技能：可以有机会参加各种专题讲座、工作坊和实践培训活动，提高在系统架构领域的专业技能。这些培训课程将帮助深入了解相关技术的原理和应用方法，提升在实际工作中的能力。
三、峰会核心资料清单 四、峰会核心资料截图示例 五、峰会核心PPT资料下载 本次峰会为系统架构师和技术管理人员提供了一个交流和学习的平台，有助于推动系统架构领域的发展和创新。无论是对系统架构的理论研究还是实际应用，本届大会都是一个难得的机会。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0236788a0859ebe4199f05e2f72f833a/" rel="bookmark">
			Word表格跨页？5个方法轻松解决问题！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“我刚刚在使用Word编辑一个文档时，突然发现我的内容好像比较多，导致表格跨页了，有什么方法可以让表格在同一个页面上吗？” 在处理Word文档时，我们经常需要插入表格以整理和展示数据。然而，当表格内容过多，超出一页时，往往会出现表格跨页的情况，导致表格断开，影响阅读和打印效果。
Word表格跨页如何处理？小编给大家总结了几个比较简单好用的方法，请继续往下看吧！
方法一：调整表格大小 表格跨页怎么调整成一页？如果在使用Word编辑文档时，发现表格成了一页。建议先调整表格大小将表格放置在同一页中。
步骤1：选中表格，点击鼠标右键，选择【表格属性】；
步骤2：在弹出的对话框中，选择【行】选项卡；
步骤3：取消勾选【允许跨页断行】；
步骤4：点击【确定】按钮，完成设置。
方法二：调整段落间距 在使用Word时，如果Word表格跨页显示，尝试对段落间距进行调整也能有效解决该问题。
步骤1：选中表格，点击鼠标右键，选择【段落】；
步骤2：在弹出的对话框中，调整【段前】和【段后】间距至适合的大小；
步骤3：点击【确定】按钮，完成设置。
方法三：调整表格边框 如果表格边框过大，也可能会引起表格跨页显示，建议用户对表格边框进行调整，将表框调小或许也能将表格置于同一页中。
步骤1：选中表格，点击鼠标右键，选择【表格属性】；
步骤2：在弹出的对话框中，选择【表格】；
步骤3：调整【边框和底纹】中的边框宽度至合适大小，点击【确定】，完成设置。
方法四：调整纸张大小和方向 如果表格中内容过多，纵向纸张可能无法完成表格在同一页，建议通过调整纸张大小和方向来使表格在同一页。
步骤1：打开Word文档，点击【页面布局】；
步骤2：选择【纸张大小】，根据需要选择合适的纸张尺寸；
步骤3：调整纸张方向，根据需要选择横向或纵向；
步骤4：点击【确定】，完成设置。
方法五：使用表格自动调整功能 在对表格进行操作时，表格的自动调整功能或许也能完成表格跨页，在进行自动调整时可根据个人喜好进行选择。
步骤1：选中表格，点击鼠标右键，选择【自动调整】；
步骤2：在弹出的下拉菜单中，选择适合的自动调整方式。如【根据内容自动调整表格】或【根据窗口自动调整表格】；
步骤3：点击【确定】按钮，完成设置。
如果在实际的操作中，出现由于内容过多导致表格跨页的情况，可尝试上文中Word表格跨页的相关做法进行处理。但要注意，在处理过程中，保持文档格式的统一和美观，以便更好地呈现和分享你的内容哦！
往期推荐：
电脑文件丢失怎么恢复？这4个方法不可错过！https://blog.csdn.net/datarecover/article/details/135742990?spm=1001.2014.3001.5501
回收站删除的照片怎么恢复？恢复文件，3个方法！https://blog.csdn.net/datarecover/article/details/135763939?spm=1001.2014.3001.5501
我的文档不见了怎么恢复？3个方法快速恢复！https://blog.csdn.net/datarecover/article/details/135765977?spm=1001.2014.3001.5501
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb3388b72be652c24832fcc36db13129/" rel="bookmark">
			鸿蒙系统的APP开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		鸿蒙系统（HarmonyOS）是由华为公司开发的一款分布式操作系统。它被设计用于在各种设备上实现无缝的、统一的用户体验，包括智能手机、平板电脑、智能电视、智能穿戴等设备。鸿蒙系统的核心理念是支持多终端协同工作，使应用能够更灵活地在不同设备之间进行交互。北京木奇移动技术有限公司，专业的软件外包
开发公司，欢迎交流合作。
鸿蒙系统的开发可以分为两个主要方向：
1.应用程序开发： 针对鸿蒙系统开发应用程序，可以使用鸿蒙应用程序框架。该框架支持多种编程语言，包括Java、C、C++、JavaScript等。开发者可以使用自己熟悉的语言和工具来创建应用，并通过鸿蒙的分布式能力实现在不同设备上的运行。
2.设备驱动和系统服务开发： 针对特定设备或硬件平台，开发者可以进行设备驱动和系统服务的开发。这通常需要使用底层的系统API和开发工具，以确保鸿蒙系统在各种设备上能够高效运行。
下面是一些简要的步骤，供你了解如何进行鸿蒙系统的应用程序开发：
设置开发环境： 安装鸿蒙开发工具，并配置相关环境。创建应用项目： 使用鸿蒙开发工具创建一个新的应用项目，选择适当的模板和配置。编写应用代码： 使用支持的编程语言编写应用程序代码，包括界面设计和业务逻辑。调试和测试： 在模拟器或真实设备上进行调试和测试，确保应用程序在不同设备上能够正常运行。打包和发布： 将应用程序打包为安装包，可以通过应用商店或其他分发渠道发布和分享。 请注意，这只是一个概述，具体的开发流程和步骤可能因版本变化而略有不同。建议查阅华为官方的鸿蒙开发文档和教程，以获取详细的指导和最新信息。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aea0ea77429f3d64c25103fba5be635a/" rel="bookmark">
			Flink写Doris又有哪些坑呢
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇写了Spark如何通过structured streaming消费kafka的数据实时写Doris表，表面上看挺简单的一个逻辑，但是却经历了一波三折，好在，最后通过分析源码搞定了。
那么当我后续把spark换成flink之后，会不会要顺利一点呢？
事实证明并没有。
无论是官方文档给的样例，还是GitHub提供的demo，都没有办法直接解决当前我的问题，也还是只能不断试错，官网和源码满地找的方式，踉踉跄跄地把问题给解决了。
那么这篇文章，咱就来看看把spark换成flink之后，还是基于相同的业务场景，又会遇到哪些意想不到的坑呢？
0. 先看兼容性
Flink作为当下炙手可热的计算引擎之一，Doris自然会提供对其的兼容：
同样，官方文档也给出了对Flink不同版本的兼容情况：
而我当前软件工程里的Flink版本为1.15.2、Java版本也为1.8、对应的Doris版本为1.2.3，于是正好对应Doris的1.2.0版本的connector。
1.环境准备
官方文档描述了一堆Flink写Doris前的准备工作，但是读完之后，在我看来，大部分其实是没有必要的(原因跟上一篇通过spark写Doris一样)。
因为我是通过idea开发的代码，对于开发环境来说，理论上我只需要额外引入对应的flink maven依赖，doris connector maven依赖就够了。
因为flink的环境我已经具备现成的了，那么暂时就只需要引入connector依赖就可以：
而至于集群运行环境，我有yarn，理论上也就够了，其他一切花里胡哨的配置全都不需要(当然，你最好要清楚为啥)。
2. SQL API第一次试错
从官方文档描述来看，Doris即支持Flink的Table API(SQL API)，也支持其普通的DataStream API，这个就有点类似spark的Dataset(DataFrame)和RDD。
由于SQL API的语法更加简洁和便利，于是，我决定先用这个API来试试，代码如下：
packagecom.anryg.doris importjava.time.Duration importorg.apache.flink.streaming.api.CheckpointingMode importorg.apache.flink.streaming.api.scala.StreamExecutionEnvironment importorg.apache.flink.table.api.bridge.scala.StreamTableEnvironment /** *@DESC:通过SQLAPI读取kafka数据，写入到Doris *@Auther:Anryg *@Date:2023/8/311:29 */ objectFlinkSQLFromKafka2Doris{ defmain(args:Array[String]):Unit={ valenv=StreamExecutionEnvironment.getExecutionEnvironment env.getCheckpointConfig.setCheckpointStorage("hdfs://192.168.211.106:8020/tmp/checkpoint/FlinkSQLFromKafka2Doris") env.getCheckpointConfig.setAlignedCheckpointTimeout(Duration.ofMinutes(1L)) env.getCheckpointConfig.setCheckpointingMode(CheckpointingMode.EXACTLY_ONCE) //env.setRuntimeMode(RuntimeExecutionMode.BATCH) valtableEnv=StreamTableEnvironment.create(env) /**第一步：读取kafka数据源*/ tableEnv.executeSql( """ Createtabledns_logs_from_kafka( |client_ipSTRING, |domainSTRING, |`time`STRING, |target_ipSTRING, |rcodeSTRING, |query_typeSTRING, |authority_recordSTRING, |add_msgSTRING, |dns_ipSTRING |) |with( |'connector'='kafka', |'topic'='test', |'properties.bootstrap.servers'='192.168.211.107:6667', |'properties.group.id'='FlinkSQLFromKafka2Doris', |'scan.startup.mode'='latest-offset', |'value.format'='csv',//确定数据源为文本格式 |'value.csv.field-delimiter'='|'//确定文本数据源的分隔符 |) "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aea0ea77429f3d64c25103fba5be635a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9cd482ef7afbb4c8b932bc047f6286d/" rel="bookmark">
			谷歌被曝“随机大裁员”？员工直呼是CEO的错，更有18年工程师被裁后“破防”：公司已经变了！...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python入门到精通 Python入门到精通：人生苦短，我用Python！Python每日推送、Python教程、Python资料、Python视频、Python项目、Python学习等。
公众号
该公众号已被封禁
刚刚到来的 2024 年，对于谷歌员工来说似乎不太“友好”：自 1 月 10 日以来，谷歌各部门已裁员 1000+ 人，包括设备和服务部门、助理团队和核心工程团队、广告销售部门以及 YouTube 团队……不仅如此，首席执行官 Sundar Pichai 还在上周的内部备忘录中直接预告，2024 年将有更多裁员计划：
“我们有雄心勃勃的目标，并将在今年投资于我们的重大优先事项。现实情况是，为了创造这种投资的能力，我们必须做出艰难的选择。其中许多变化已经宣布，部分团队将在全年根据需要继续做出具体的资源分配决策，其中某些职位可能会受到影响。”
这个预告，直接引起了诸多谷歌员工的不满——不论他们是否已被裁员：
谷歌软件工程师 Jeremy Joslin 工作了 20 年，仅被一封邮件通知被裁：“很难相信，在谷歌工作 20 年后，我意外地通过电子邮件得知了我的最后一天，真是打脸啊。我真希望我能面对面地和每个人说再见。”
谷歌资深软件工程师 Diane Hirsh Theriault 发布推文，直接指出谷歌裁员似乎是“随机”的：“在我看来，谷歌现在没有半个有远见的领导者，从最高管理层、高级副总裁再到副总裁，他们全部得过且过、目光短浅……如果（新产品）在 6 个月内没有获得 1 亿用户，谷歌就会放弃并关闭它。这就像我在大学里学的那个可笑算法——BogoSort。在算法的每次迭代中，你随机地对所有东西重新排序，如果元素刚好按顺序出现，那就大功告成了。”
除此之外，还有一位在谷歌工作长达 18 年的老员工 Ben Collins-Sussman（2005 年加入谷歌，是芝加哥最早的两名工程师之一，一直担任谷歌芝加哥办事处的工程现场总监），被裁后写了一篇长文直呼破防：谷歌文化已经变了——曾经“把员工看得比什么都重要”，如今却“一波又一波不近人情的裁员”。
以下为译文：
想唤醒一件曾经发生过的美好事情
（免责声明：这篇文章完全基于我在谷歌工作 18 年的亲身经历。我并不了解公司最高领导人的想法，所以我只是分享我的个人感受。）
在过去的几个月里，我曾三次尝试撰写这篇文章，但实话实说：它很棘手。
攻击大公司的文章总是很热门，点击率也很高，尤其炮轰对象还是傲慢的硅谷科技公司时。人们总喜欢看一些“陨落”的故事，但我的目的并不是泼脏水：谷歌是一个很好的工作场所，比大多数公司都要好得多，也仍然在做一些伟大而惊艳的事情——我写这篇文章的目的是，想唤醒一件曾经发生过的、独特而美好的事情，希望有一天它能再次出现。
18 年前，我刚进谷歌的时候特意写过一封邮件，想着等我离开公司的时候可以对比，我觉得这将是一封精彩的时间胶囊。但是如今看来，当时这封邮件主要集中在表面的差异化上，比如免费美食等，可这并不是我来谷歌工作的真正原因。我想谈的是更深层次、更实质性的企业文化。
Ian Hickson 是我的一位老前辈，去年秋天离开谷歌时，他写了一篇博文，其中就谈到了谷歌决策类型的转变：
“为了确保股价逐季增长，谷歌采取了短视的裁员做法，而不是遵循以往的战略，即优先考虑长期的成功，即使这会导致短期的损失（这正是‘不作恶’的精髓）。谷歌目前存在的这些问题，很大程度上源于 Sundar Pichai 缺乏远见卓识的领导力，而且他显然对维持早期谷歌的文化规范缺乏兴趣。”
对于 Ian Hickson 的观点，我基本认同，因此我不会再本文中再一一赘述，我想谈谈其他不同的转变。
早期谷歌：把员工看得比什么都重要，绝不轻易裁员 谷歌早期企业文化给我留下最深刻印象的，就是它把员工看得比什么都重要。我曾在其他公司工作过，从未见过这样的文化，而且这种文化至少维持了我在谷歌工作的前十年，也许更长。
我来解释一下：在一家典型的公司中，当优先事项发生变化时，一般会选择“缩减”一个项目，然后用这笔钱为另一个更重要的项目增加人手——简单来说就是，解雇第一个项目的人员，然后在第二个项目中再重新雇用一批新人。这个做法很简单、很容易，很多公司都是这么做的。
然而，谷歌却采取了不同的方法：他们有一个相当严谨的招聘过程，来寻找有才且通才的人，一般这种人不论处于什么岗位都能茁壮成长。对应聘者和面试官来说，谷歌面试可能都非常艰苦，往往需要耗时几个月的时间。但谷歌坚信，最终这样的努力是值得的：他们相信自己，会招聘到最优秀、最聪明、最灵活的人才。
因此，当优先事项发生变化时，谷歌不会解雇员工，而是小心翼翼地在不同项目之间调动员工。当时谷歌的企业文化原则是：“产品总在不断迭代更换，但我们辛辛苦苦才有了员工......所以我们应该不惜一切代价保护他们，他们是我们最宝贵的资源。”因此每当这种时刻，谷歌会投入大量精力，对一位员工进行合适地重新安置，让他们进入新的项目，并相信通才的他们会茁壮成长，公司将以新的方式发挥他们的才能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9cd482ef7afbb4c8b932bc047f6286d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b95bcc3b230f966dac3b93f9e7942a8c/" rel="bookmark">
			【问题解决】Java-生成word和pdf中文乱码（小方框）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题情境： 项目中生成pdf报告采用的逻辑为：对代码中resoure下的固定的word模版进行文件读取，替换关键字，生成word，然后word转pdf的思路。
在本地运行没有问题，签章和页面字体均为问题，但部署服务器后出现汉字乱码为小方框。
问题产生原因： 服务为docker部署，容器中没有该字体包导致
解决方案： 1.服务器安装字体包，在docker的启动命令中增加对该字体包的指向。
2.我们项目为jenkins打包部署，更改基础镜像，比如之前用的是openjdk:8，为解决字体问题可更换为openjdk-chinese:8（我这边是宋体乱码），根据实际情况可以更换不同的基础镜像。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae6e46a1e9b2b83ad07a5ab7e9d52988/" rel="bookmark">
			【yolov5报错解决】ModuleNotFoundError: No module named‘ultralytics.yolo‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解决办法
pip install ultralytics==8.0.100 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a415bd44f4ac121324b097aa9642cfc/" rel="bookmark">
			SpringBoot3集成Zookeeper
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简介 ZooKeeper是一个集中的服务，用于维护配置信息、命名、提供分布式同步、提供组服务。分布式应用程序以某种形式使用所有这些类型的服务。
二、环境搭建 1、修改配置文件
# 1、拷贝一份样本配置文件 cp zookeeper-3.8.3/conf/zoo_sample.cfg zookeeper-3.8.3/conf/zoo.cfg # 2、修改数据文件地址，注意这里用本地路径 dataDir=/local-path/zookeeper-3.8.3/data # 3、添加一个配置，处理启动日志的提示：ZooKeeper audit is disabled. audit.enable=true 2、服务启动
# 1、启动服务端 zookeeper-3.8.3/bin/zkServer.sh start # 2、停止服务端 zookeeper-3.8.3/bin/zkServer.sh stop # 3、启动客户端 zookeeper-3.8.3/bin/zkCli.sh 3、客户端测几个增删查的命令
[zk: localhost:2181(CONNECTED) 0] create /cicada smile1 Created /cicada [zk: localhost:2181(CONNECTED) 1] get /cicada smile1 [zk: localhost:2181(CONNECTED) 2] ls / [cicada, zookeeper] [zk: localhost:2181(CONNECTED) 3] delete /cicada 三、工程搭建 1、工程结构 2、依赖管理 Curator是一组Java库，它让ZooKeeper的使用变得更加容易，这里的依赖实际是查询匹配版本的时候走了个捷径，也可以参考integration-redis包，熟悉下Spring的封装策略。
&lt;!-- Zookeeper组件 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;${zookeeper.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a415bd44f4ac121324b097aa9642cfc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ba6a3115ec42db1457d3ffa23a36de5/" rel="bookmark">
			回收站被清空如何找回？3个宝藏恢复方法分享！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“大家在清理电脑的时候有没有遇到误清空回收站的情况呀？我刚刚就不小心把回收站都清空了，还有机会恢复吗？有没有比较实用的方法可以推荐的呢？” 在日常生活中，我们经常会把不需要的文件或数据放入回收站，以便日后删除。但有时，我们会不小心清空了回收站，导致重要文件丢失。
回收站被清空如何找回？如果你的回收站里有重要的数据，别着急，继续往下看吧！简单几招教你轻松恢复回收站！
​
方法一：借助快捷键恢复清空的回收站 电脑回收站清空了还能找回吗？是有可能的！如果我们在进行回收站清空操作时意识到操作错误，此时借助快捷键还有机会撤销删除。用户可以这样操作。
第1步：进行完回收站撤销删除操作后，不要进行其他操作；
第2步：按下【Ctrl＋z】对删除操作进行撤销。
提示：如果清空回收站后还进行了其他的操作，则无法使用该方法来恢复重要的数据。 ​
方法二：借助以前的版本恢复清空的回收站 回收站清空了如何恢复回来？在电脑开启了自动备份功能的前提下，用户可以尝试使用以前的版本来对回收站文件进行恢复。但该方法可能会导致部分文件丢失，建议用户谨慎使用。
第1步：找到需要恢复的回收站文件删除前所在的文件夹；
第2步：单击进入其【属性】，选择【以前的版本】；
第3步：看看是否有文件被删除前的版本，找到后，点击还原该版本。
​
方法三：借助专业软件恢复清空的回收站 在没有备份且对电脑各项操作都并不是很熟悉的情况下，回收站被清空如何找回呢？此时建议用户借助专业的数据恢复软件来尝试恢复重要的数据。
数 据 蛙 恢 复 专 家 是比较实用的一款软件。它不仅有专业的扫描和恢复系统，还有简单的操作界面。重要的是，软件支持免费试用，如果不确定文件是否能找回，建议先尝试使用软件进行免费扫描。软件的操作步骤如下：
操作环境： 演示机型：华硕TUF Dash FX516PM 系统版本：Windows10 软件版本：数 据 蛙 恢 复 专 家 3.2.12 第1步：下载软件后，先点击【免费试用】，可对数据进行免费扫描，进入选择界面后，根据实际的恢复需求，勾选上需要扫描的文件类型，同时勾选上【回收站】，单击【扫描】；
​
第2步：快速扫描完成后，建议用户先按照所选的文件类型对文件结果进行查看，看看误删的文件是否被扫描到，如果此次扫描只扫描到部分数据，点击【深度扫描】；
​
第3步：深度扫描完成后，用户可再次对扫描结果进行查看和选择，在文件呈现较多的情况下，用户可以借助【筛选器】提高选择效率，勾选完所有需要恢复的文件后，点击【导出】。
提示：如果所选择的保存位置与文件被删除前一致，软件会弹出提示，更改新的保存位置即可。 ​
回收站为用户找回重要数据做出了重要贡献。回收站被清空如何找回呢？上文已经给大家简单分享了几个好用又简单的操作方法。用户可以挑选喜欢的方法进行尝试哦！当然！在日常使用电脑时，建议大家做好备份，以避免数据丢失。
往期推荐：
电脑摄像头设置在哪里？这3种打开方式要记好！https://blog.csdn.net/datarecover/article/details/135764841?spm=1001.2014.3001.5501
电脑文件丢失怎么恢复？这4个方法不可错过！https://blog.csdn.net/datarecover/article/details/135742990?spm=1001.2014.3001.5501
回收站删除的照片怎么恢复？恢复文件，3个方法！https://www.toutiao.com/article/7327100612448305714/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9fb2b19c20ac3c48dcd332a80b748a6/" rel="bookmark">
			spring mvc 请求与响应
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我是南城余！阿里云开发者平台专家博士证书获得者！
欢迎关注我的博客！一同成长！
一名从事运维开发的worker，记录分享学习。
专注于AI，运维开发，windows Linux 系统领域的分享！
知识库链接：
请求与响应 · 语雀
1. 请求映射路径 get请求是路径传参，而post请求是body传参
2. 传参类型 解决传参类型对应不上 前端传name 后端为username
3. JSON 传参 类型有普通数组、集合类型、实体类型，都需要用到JSON传参
加入xml依赖 核心配置中加入@EnableWebMvc postman json是数据传参操作 json传参在后端 需要添加传参注解@RequestBody 4. 日期类型参数传参 5. 响应 @ResponseBody 将对象转换为JSON返回给前端页面
此方法也需要引入依赖
响应依赖的接口
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07b177c0c1476e5421d986248b53ec21/" rel="bookmark">
			新建一个基于标准库的工程（STM32）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.新建存放工程的文件夹 2.打开KEIL5软件 3.新建一个本次工程的文件夹 完成新建 4.添加工程的必要文件 4.1打开STM32的启动文件 打开E:\STM32入门教程资料\固件库\固件库\STM32F10x_StdPeriph_Lib_V3.5.0\STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\startup\arm
复制文件中的全部文件
到刚才建立的工程文件中，新建一个文件夹start，将刚才复制的文件粘贴进来
4.2： 将E:\STM32入门教程资料\固件库\固件库\STM32F10x_StdPeriph_Lib_V3.5.0\STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x
下面的三个文件也复制下来粘贴到start中：
4.3添加内核寄存器文件 E:\STM32入门教程资料\固件库\固件库\STM32F10x_StdPeriph_Lib_V3.5.0\STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\CMSIS\CM3\CoreSupport
复制两个文件粘贴到start中
则工程的必要文件复制全部结束：
5.回到keil5软件，将刚才复制的那些文件添加到工程中 修改文件名
右击添加已经存在的文件到组里来
5.1添加一个启动文件， 这里选择md.s的启动文件，并按住ctrl选中所有的.c和.h文件，并且点击add,然后点击close
6.在工程选项中添加上这个文件夹的头文件.h路径 7.测试，新建一个main函数，测试工程可行与否 7.1打开工程文件夹，新建文件夹User 7.2
更改名字：
在User右击点击添加新文件
右键 添加头文件
注意文件的最后一行必须是空行，不然会报警告
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/247dad01989cfe9ba9b07df073415b4e/" rel="bookmark">
			【K8S】Service使用NodePort对外暴露应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、背景介绍 Pod是有生命周期的，当一个工作节点(node)销毁时，节点上运行的pods也会被销毁。ReplicationController会动态地在其他节点上创建Pod来保持应用程序的运行，每一个Pod都有一个独立的IP地址，甚至是同一个节点上的Pod。可以看出Pod的IP是动态的，它随Pod的创建而创建，随Pod的销毁而消失，这就引出一个问题：如果由一组Pods组合而成的集群来提供服务，那如何访问这些Pods呢？
Kubenetes的Service就是用来解决这个问题的。一个Service可以看作一组提供相同服务的Pods的对外访问接口，Service作用于哪些Pods是通过label selector来定义的，这些Pods能被Service访问，Pod之间的发现和路由（如应用中的前端和后端组件）由Kubernetes Service处理。 Service有四种type:
ClusterIP(默认）NodePortLoadBalancerExternalName 其中NodePort和LoadBalancer两类型的Services可以对外提供服务。
二、基于NodePort配置对外暴露服务 NodePort：对外暴露应用（集群外）。在每个节点上启用一个端口来暴露服务，可以在集群外部访问。
2.1 创建service.yaml 示例代码：
--- # service apiVersion: v1 kind: Service metadata: name: web-service namespace: web-space spec: selector: app: web # 指定关联Pod的标签 type: NodePort # 这里代表是NodePort类型 ports: - port: 8080 # Service端口，供内部访问（和clusterIP对应，即ip:8080） protocol: TCP # TCP协议 targetPort: 8080 # 容器端口 nodePort: 30001 # 对外暴露的端口，供外部调用 示例图片：
2.2 应用yaml kubectl create -f service.yaml 参考资料 k8s学习(四) k8s使用nodeport方式配置service对外暴露服务k8s service使用NodePort对外暴露应用 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ad86a3324f0c74268964516e28d5635/" rel="bookmark">
			Android解析sdcard下的json文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		bean
public abstract class BaseBean implements Serializable { @NonNull @Override public String toString() { JSONObject jsonObject = new JSONObject(); try { for (Field field : getClass().getDeclaredFields()) { field.setAccessible(true); // Log.d(getClass().getSimpleName(), "field name:" + field.getName() + " value:" + field.get(this)); jsonObject.put(field.getName(), field.get(this)); } return jsonObject.toString(); } catch (IllegalAccessException | JSONException e) { e.printStackTrace(); } return super.toString(); } } public class CheckListItem extends BaseBean implements Comparable&lt;CheckListItem&gt; { public String name; public String result; public String para; public int type; public CheckListItem() { } public CheckListItem(String name, String result, String para, int type) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ad86a3324f0c74268964516e28d5635/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed4067629760b3fdaae2b4b9afc2fa6c/" rel="bookmark">
			黑马Jenkins教程笔记（一）：介绍持续集成概念（Continuous integration，简称 CI）（持续集成三要素：自动构建、版本控制、持续集成服务器（引出Jenkins））
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考文章：黑马Jenkins从环境配置到项目开发实战教程
文章目录 01.Jenkins课程大纲介绍02.软件开发生命周期介绍需求分析设计实现测试进化 03.软件开发的瀑布模型04.软件开发的敏捷开发什么是敏捷开发？==何为迭代开发？====何为增量开发？== 敏捷开发如何迭代？敏捷开发有什么好处？==早期交付====降低风险== 05.什么是持续集成== 持续集成的流程==提交测试（第一轮）测试（第二轮）部署回滚 06.持续集成的组成要素一个自动构建过程， 从检出代码、 编译构建、 运行测试、 结果记录、 测试统计等都是自动完成的， 无需人工干预。一个代码存储库，即需要版本控制软件来保障代码的可维护性，同时作为构建过程的素材库，一般使用SVN或Git。一个持续集成服务器， Jenkins 就是一个配置简单和使用方便的持续集成服务器。 07.持续集成的好处 01.Jenkins课程大纲介绍 02.软件开发生命周期介绍 软件开发生命周期又叫做SDLC（Software Development Life Cycle），它是集合了计划、开发、测试和部署过程的集合。如下图所示 ：
需求分析 这是生命周期的第一阶段，根据项目需求，团队执行一个可行性计划的分析。项目需求可能是公司内部或者客户提出的。这阶段主要是对信息的收集，也有可能是对现有项目的改善和重新做一个新的项目。还要分析项目的预算多长，可以从哪方面受益及布局，这也是项目创建的目标。
设计 第二阶段就是设计阶段，系统架构和满意状态（就是要做成什么样子，有什么功能），和创建一个项目计划。计划可以使用图表，布局设计或者文者的方式呈现。
实现 第三阶段就是实现阶段，项目经理创建和分配工作给开者，开发者根据任务和在设计阶段定义的目标进行开发代码。依据项目的大小和复杂程度，可以需要数月或更长时间才能完成。
测试 测试人员进行代码测试 ，包括功能测试、代码测试、压力测试等。
进化 最后进阶段就是对产品不断的进化改进和维护阶段，根据用户的使用情况，可能需要对某功能进行修改，bug修复，功能增加等。
03.软件开发的瀑布模型 瀑布模型是最著名和最常使用的软件开发模型。瀑布模型就是一系列的软件开发过程。它是由制造业繁衍出来的。一个高度化的结构流程在一个方向上流动，有点像生产线一样。在瀑布模型创建之初，没有其它开发的模型，有很多东西全靠开发人员去猜测，去开发。这样的模型仅适用于那些简单的软件开发， 但是已经不适合现在的开发了。
下图对软件开发模型的一个阐述。
04.软件开发的敏捷开发 什么是敏捷开发？ 敏捷开发（Agile Development） 的核心是迭代开发（Iterative Development） 与 增量开发（Incremental Development） 。
何为迭代开发？ 对于大型软件项目，传统的开发方式是采用一个大周期（比如一年）进行开发，整个过程就是一次"大开发"；迭代开发的方式则不一样，它将开发过程拆分成多个小周期，即一次"大开发"变成多次"小开发"，每次小开发都是同样的流程，所以看上去就好像重复在做同样的步骤。
举例来说，SpaceX 公司想造一个大推力火箭，将人类送到火星。但是，它不是一开始就造大火箭，而是先造一个最简陋的小火箭 Falcon 1。结果，第一次发射就爆炸了，直到第四次发射，才成功进入轨道。然后，开发了中型火箭 Falcon 9，九年中发射了70次。最后，才开发 Falcon 重型火箭。如果SpaceX 不采用迭代开发，它可能直到现在还无法上天。
何为增量开发？ 软件的每个版本，都会新增一个用户可以感知的完整功能。也就是说，按照新增功能来划分迭代。举例来说，房产公司开发一个10栋楼的小区。如果采用增量开发的模式，该公司第一个迭代就是交付一号楼，第二个迭代交付二号楼…每个迭代都是完成一栋完整的楼。而不是第一个迭代挖好10栋楼的地基，第二个迭代建好每栋楼的骨架，第三个迭代架设屋顶…
敏捷开发如何迭代？ 虽然敏捷开发将软件开发分成多个迭代，但是也要求，每次迭代都是一个完整的软件开发周期，必须按照软件工程的方法论，进行正规的流程管理。
敏捷开发有什么好处？ 早期交付 敏捷开发的第一个好处，就是早期交付，从而大大降低成本。 还是以上一节的房产公司为例，如果按照传统的"瀑布开发模式"，先挖10栋楼的地基、再盖骨架、然后架设屋顶，每个阶段都等到前一个阶段完成后开始，可能需要两年才能一次性交付10栋楼。也就是说，如果不考虑预售，该项目必须等到两年后才能回款。 敏捷开发是六个月后交付一号楼，后面每两个月交付一栋楼。因此，半年就能回款10%，后面每个月都会有现金流，资金压力就大大减轻了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed4067629760b3fdaae2b4b9afc2fa6c/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/6/">«</a>
	<span class="pagination__item pagination__item--current">7/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/8/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>