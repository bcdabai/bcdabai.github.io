<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ff9748d5470faee1d2b151b5bb04a03/" rel="bookmark">
			2023年 - 2024年 最新计算机毕业设计 本科 选题大全 汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
1 Javaweb之springboot+vue 管理系统 毕设选题
2 Javaweb之ssm 管理系统 毕设选题
3 小程序端加web端
4 安卓端加web端
5 python+vue|.net+c#|php|.node等网页
6 联系方式
前言 Hello，大家好，我是竹林，大四的同学马上要开始毕业设计开题啦，大家做好准备了没！
1 Javaweb之springboot+vue 管理系统 毕设选题 2.3基于springboot养老院管理系统修改
3.30社区疫情管理系统
3.4基于Java Web的考编论坛网站的设计与实现
3.6仓库管理系统
3.7仓库管理系统springboot
4.24基于SpringBoot的计算机学习系统的设计与实现
it职业生涯规划系统
javaweb的新能源充电系统
springboot+vue智慧养老中心管理系统演示2022_u1yrv
springboot008房屋租赁系统
springboot013基于SpringBoot的旅游网站
springboot027网上点餐系统
springboot032阿博图书馆管理系统
springboot039基于Web足球青训俱乐部管理后台系统开发
springboot064高校学科竞赛平台
springboot068桂林旅游景点导游平台
springboot073车辆管理系统设计与实现
springboot075电影评论网站系统设计与实现
springboot077基于SpringBoot的汽车票网上预订系统
springboot083基于springboot的个人理财系统
springboot084基于springboot的论坛网站
springboot086靓车汽车销售网站
springboot095学生宿舍信息的系统
springboot098基于web的网上摄影工作室的开发与实现
springboot101校园社团信息管理
springboot117基于SpringBoot的企业资产管理系统
springboot117基于SpringBoot的企业资产管理系统
springboot125汽车资讯网站
springboot131企业oa管理系统
springboot138宠物领养系统的设计与实现
springboot139华强北商城二手手机管理系统
springboot143基于SpringBoot的在线家具商城设计与实现
springboot145基于java的在线问卷调查系统的设计与实现
springboot170图书电子商务网站的设计与实现
springboot171社区医院管理系统
springboot175图书管理系统
springboot180基于spring boot的医院挂号就诊系统
springboot185基于vue.js的客户关系管理系统(crm)的设计与实现1
springboot197基于springboot的毕业设计系统的开发
springboot203医疗挂号管理系统
springboot204在线考试系统
springboot208基于springboot物流管理系统
springboot210基于Springboot开发的精简博客系统的设计与实现视频1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ff9748d5470faee1d2b151b5bb04a03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b3416c974aa155faef7bc174c41e3cd/" rel="bookmark">
			（嵌入式c语言）指针&#43;修饰符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		const+指针 当使用指针指向 双引号 “字符串”时， 不可通过此指针p修改该字符串，定义的时候自带const属性。
但是用数组定义的字符串是可以通过指针修改字符串内容的。
volatile+指针 防止优化指向的内存地址
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd87e13c60587a538a4b3eabe531061c/" rel="bookmark">
			Java面试题大全~基础题(55题)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近一段时间在准备面试，所以就整理了一下技术栈。在整理的过程中也能够沉淀一下学过的知识。本篇是Java面试题中的基础篇。总共55题，2万多字，以问答的形式呈现，这样也能更好的模拟面试的环节。本文的答案部分有图有代码，这样解释会更加详细和易懂。 1：final, finally, finalize 的区别是什么？ final 用于修饰属性,方法和类, 分别表示属性不能被重新赋值, 方法不可被覆盖, 类不可被继承。
finally 是异常处理语句结构的一部分，一般以 try-catch-finally 出现， finally代码块表示总是被执行。
finalize 是 Object 类的一个方法， 该方法一般由垃圾回收器来调用， 当我们调用 System.gc() 方法的时候， 由垃圾回收器调用finalize()方法，回收垃圾，JVM并不保证此方法总被调用。
2：equals 与==的有什么区别？ ==
==符号在八种基本类型的作用是比较对应基本类型的数值是否相等==符号在对象类型的作用是比较两个对象是否相等 需要注意几种特例：
在包装类型比较的时候，如果初始化的时候使用字面量进行初始化需要注意包装类对象是否是从缓存中获取，如果是缓存中获取则需注意==的结果在String中使用==的时候也需要注意，字符串是否在常量池中已经创建，是否有拼接的情况。具体可以参考我的这篇文章 equals
在Object中 equals 用来比较对象是否相等在其他对象中需要查看是否重写equals方法，以此判断equals方法的具体逻辑，比如String类重写了equals方法用来判断字符串的值是否相等 3：说一说Object中有哪些方法以及这些方法的功能？ registerNatives()：用户注册Object中native相关的方法（native 方法）getClass(): 返回对象的运行时类的引用，可以获取对象所属的具体类信息（native 方法）hashCode(): 返回对象的哈希码值，用于在哈希表等数据结构中快速定位对象。需要与equals()方法一起重写，以保证相等的对象具有相等的哈希码（native 方法）equals(Object obj): 用于比较两个对象是否相等。默认实现比较对象的内存地址，可以被子类重写以定义自定义的相等逻辑clone(): 创建并返回对象的副本。需要实现Cloneable接口才能调用此方法，否则会抛出CloneNotSupportedException异常（native 方法）toString(): 返回对象的字符串表示形式，常用于调试和日志记录。默认实现返回类名和对象的哈希码notify(): 唤醒等待在该对象上的一个线程。用于线程间的通信（native 方法）notifyAll(): 唤醒等待在该对象上的所有线程。用于线程间的通信（native 方法）wait(long timeout): 在对象上等待一段指定的时间，直到其他线程调用notify()或notifyAll()方法唤醒它，或者超时时间到达（native 方法）finalize(): 在对象被垃圾回收之前调用，用于执行对象的清理操作。已废弃，不推荐使用，应使用try-finally或try-with-resources来代替 4：两个对象的 hashCode()相同，则 equals()是否也一定为 true吗？ 如果两个对象的 hashCode()相同，则 equals()不一定为 true，两个对象equals 相等，则它们的hashcode 必须相等，
hashCode 的常规协定：
1： 在 Java 应用程序执行期间，在对同一对象多次调用 hashCode 方法时， 必须 一 致地返回相同的整数，前提是将对象进行 equals 比较时所用的信息没有被修改。 从某一应用程序的一次执行到同一应用程序的另一次执行， 该整数无需保持一致。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd87e13c60587a538a4b3eabe531061c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65c234975549f9abc3d21f15aa76bbfe/" rel="bookmark">
			vue使用indexDB判断数据库是否存在判断表是否存在
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		let dbName = 'hist-data-1d' const dbs = await window.indexedDB.databases(dbName); const dbExists = dbs.some((db) =&gt; db.name === dbName); if (!dbExists) { const openReq = indexedDB.open(dbName, 1); openReq.onerror = (event) =&gt; { console.log('dbExists,创建数据库失败', dbExists) }; } else { const request = indexedDB.open(dbName); request.onerror = (event) =&gt; { console.log('数据库连接打开失败', event); }; request.onsuccess = async (event) =&gt; { let db = event.target.result; let tablesObj = db.objectStoreNames; const version = db.version; if (tablesObj.contains(tableName)) { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65c234975549f9abc3d21f15aa76bbfe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e9d39cbc9d849491b7c73771dcf3745/" rel="bookmark">
			【测试】pywinauto的简单使用（安装、常用对象、元素控件、鼠标操作、键盘操作）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.说明 pywinauto是一个用于自动化Python 模块，适合Windows系统的软件（GUI），可以通过Pywinauto遍历窗口（对话框）和窗口里的控件，也可以控制鼠标和键盘输入，所以它能做的事情比之前介绍的pysimplegui更多
2.安装 一般使用pip安装就行了
pip install pywinauto 官网文档：https://pywinauto.readthedocs.io/en/latest/
3.Application 我们要控制软件的第一件事就是启动一个Windows软件，每一个软件（进程）都是一个Application对象
实例化Application对象的时候可以传入一个backend参数，可选值为win32（默认）和 uia ，
win32对应的框架：MFC、VB6、VCL、简单的 WinForms 控件和大多数旧的遗留应用程序
uia对应的框架：WinForms、WPF、商店应用程序、Qt5、浏览器
如果无法知道要测试的软件是属于哪种框架，可以使用 Inspect（对应uia） 和 Spy++（对应win32） 看看，你看哪个显示得更全就选哪个。Inspect和Spy++需要自己安装一下
下面是Application对象的主要方法
方法常用参数说明start()cmd_line、timeout、retry_interval通过cmd命令启动一个软件（进程）connect()process、handle、path、timeout连接一个进程，一般是使用进程号（任务管理器可以看到）top_window()/获取应用的顶层窗口window()title、title_re、class_name、best_match获取单个窗口（WindowSpecification）windows()title、title_re、class_name获取多个窗口（UIAWrapper）is64bit()/是否64位应用cpu_usageintervalCPU占用率wait_cpu_usage_lower()threshold、timeout等待CPU占率小于某个阈值active()()/搜索返回一个激活的窗口kill()soft结束进程wait_for_process_exit()timeout、retry_interval等待进程结束 举例，启动一个微信应用，通过进程号连接，进程号就是在任务管理器里详细信息看到的PID
from pywinauto import Application app = Application(backend="uia") # app.start(r"D:\Program Files (x86)\Tencent\WeChat\WeChat.exe") app.connect(process=6556) print("is64bit:", app.is64bit()) print("cpu_usage:", app.cpu_usage()) app.wait_cpu_usage_lower() # app.active() # 如果指定时间内不激活则报错 print("kill:", app.kill()) print("wait_for_process_exit:", app.wait_for_process_exit()) 4.WindowSpecification 我们要获取窗口，一个窗口都是一个WindowSpecification对象，可以通过Application对象的window()方法获取，参数可以是title、classname或者best_match等，这都可以在inspect.exe上看到，不过需要注意的是inspect看到的Name其实对应的是window()的title参数
WindowSpecification对象常用的方法如下
方法常用参数说明maximize()/最大化窗口minimize()/最小化窗口restore()/恢复窗口close()/关闭窗口get_show_state()/获取窗口状态，0正常1最大化2最小化was_maximized()/当前是否最大化draw_outline()colour、thickness给窗口画个框以便定位print_control_identifiers()/打印所有子窗口和子元素（会打印出对应的control_type）child_window()title、control_type获取子窗口exists()timeout窗口是否存在wait()wait_for, timeout等待窗口变成某个状态（exists、visible、enabled、ready、active）wait_not()wait_for_not, timeout等待窗口不处于某个状态（exists、visible、enabled、ready、active） 举个栗子
dlg = app.window(class_name="WeChatMainWndForPC") # dlg = app.window(title="微信") print("get_show_state:", dlg.get_show_state()) print("was_maximized:", dlg.was_maximized()) dlg.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e9d39cbc9d849491b7c73771dcf3745/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d6f320d435b27a94cf2e78a586173c1/" rel="bookmark">
			Shader 用到的数学函数总结及用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在写shader相关的程序的时候往往需要用到 OpenGL内置的数学库，下面列举几个常用的函数用法和效果，下面的所有代码都是运行在shadertoy在线工具上的，推荐一个好用的数学工具desmosDesmos
目录：
abs(x)step(edge,x)dot(uv1,uv2) 1：abs(x) 取绝对值 void mainImage( out vec4 fragColor, in vec2 fragCoord ) { // Normalized pixel coordinates (from 0 to 1) vec2 uv = fragCoord/iResolution.xy; uv -= 0.5; uv.x *= iResolution.x / iResolution.y; vec3 col = vec3(0.); uv = abs(uv); float c = uv.x; // 0.2 &lt;= c =&gt; 0 0.2 &gt; c =&gt; 1 step(.2,c) reverse color col += step(c,.2); // Output to screen fragColor = vec4(col,1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d6f320d435b27a94cf2e78a586173c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08c190296c97f4ee4514e14f08552ad2/" rel="bookmark">
			控制台实现家庭记账本功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求：
在控制台实现家庭记账本的小功能，功能如下
参考代码如下：
import java.util.Scanner; /** * &lt;p&gt;家庭账本-综合案例&lt;/p&gt; * * @author 波波老师(weixin : javabobo0513) */ public class Demo24 { public static void main(String[] args) { int inputNo = 0;//用户输入的编号 int count = 0;//用户记账次数 int[] szArray = new int[100];//存收入或支出的金额的数组 String[] szDescArray = new String[100];//存收入或支出的说明描述 int[] zArray = new int[100];//存每次记账完之后的总账户余额 boolean[] typeArray = new boolean[100];//存记账类型：支出或收入 int sum = 10;//账户初始余额 do{ System.out.println("-------------------家庭收支记账软件-------------------"); System.out.println("1、收支明细"); System.out.println("2、登记收入"); System.out.println("3、登记支出"); System.out.println("4、退出"); System.out.println("请选择1-4："); Scanner sc = new Scanner(System.in); inputNo = sc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08c190296c97f4ee4514e14f08552ad2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39d4006dc943cb1b9bdf8ea224d035a5/" rel="bookmark">
			麒麟操作系统安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官网：麒麟
下载：首页-&gt;桌面操作系统-&gt;银河麒麟桌面操作系统V10-&gt;申请试用
提交后-&gt;银河麒麟桌面操作系统V10-&gt;AMD64版-&gt;选择本地下载链接
安装：
（1）创建新的虚拟机-&gt;自定义(高级)-&gt;稍后安装操作系统&gt;Linux、Ubuntu 64位/其他Linux 5.x内核 64位-&gt;自定义虚拟机名称和位置-&gt;指定处理器和内核数量(我使用了默认值)-&gt;指定内存(电脑内存的1/4为宜)-&gt;使用NAT模式-&gt;LSI Logic(L)-&gt;SCSI-&gt;创建新虚拟磁盘-&gt;指定磁盘大小(50G)、将虚拟磁盘拆分成多个文件-&gt;完成
（2）编辑虚拟机设置-&gt;选择CD/DVD（SATA）-&gt;使用ISO映像文件-&gt;选择之前下载好的iso文件
​​​​​​​
（3）开启次虚拟机-&gt;选择第二项(安装银河麒麟操作系统)-&gt;选择语言-&gt;勾选我已经阅读并同意协议条款-&gt;选择时区-&gt;从Live安装-&gt;选择安装方式(全盘安装、/dev/sda)-&gt;勾选格式化整个磁盘-&gt;立即创建账户-&gt;选择应用（默认安装即可）-&gt;安装完成-&gt;现在重启-&gt;进入桌面
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe56d485dfc1b8507b3fb56844d7effb/" rel="bookmark">
			搜维尔科技：Scalefit -工作场所实时自动处理 3D 姿势分析结果软件！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		比例适合 Scalefit 是一款可在工作场所自动处理 3D 姿势分析结果的软件。这甚至可以在衡量员工的实时发生状况。然后，Scalefit 根据国际标准对姿势、压力和关节力矩进行分析和可视化。
3D姿势分析 如今，Xsens 技术可以快速测量工作场所员工的态度。一套带有 17 个传感器 (IMU) 的套装可以持续记录身体的姿势。员工因此被转变为一个化身，即工业运动员。结果是一个包含任务每一时刻的态度和速度的巨大数据集。因此，不可能在 Excel 中手动处理这些数据。
Scalefit 将来自 Xsens 的姿势数据作为输入，并自动同步处理。这样，他们就可以根据国际标准或KIM等分析方法来解释和可视化姿势、压力和关节力矩。
持续时间姿势：头部、躯干、肩膀、手腕、膝盖和前臂
频率姿势：头部、躯干、肩膀、手腕、膝盖和前臂
力量：颈背椎间盘内压缩力、肩部关节力矩
提升：KIM法
频率姿势：EN 1005-4 Scalefit 将根据欧洲身体姿势标准EN1005-4对动态姿势进行分类和解释。例如，对于背部的弯曲，该标准描述了三个区域：0-20°、20-60°和超过60°的弯曲。
然后，Scalefit 会自动计算员工背部弯曲超过 20° 或超过 60° 的次数。当频率超过2x/min时，后弯60°显然是不可接受的。
持续时间姿势：ISO 11226 对于静态姿势， ISO 11226 标准中的区域可作为参考。对于后弯，区域再次为：0-20°（绿色）、20-60°（黄色）和 &gt;60°（红色）。然后，Scalefit 会查看员工在每个特定区域工作的时间百分比。
绿色：75%以上的时间处于绿色区域
黄色：超过25%的时间处于黄色区域
红色：超过 10% 的时间处于红色区域
这是解释静态姿势的实用方法。然而，这并不完全符合ISO11226标准。毕竟，这将静态姿势定义为保持至少 4 秒的姿势。Scalefit 只是将每个关节区域的姿势的所有秒数相加。
军队 员工使用的体重必须手动输入。基于此，可以计算肩部的关节力矩。另一个已知参数是腰部椎间盘内压力。Scalefit 使用 3200N 作为极限值。颈部椎间盘内压力的极限为 150N。
优势 1.同步数据处理 Scalefit 的一大优点是数据是自动处理的。完成测量后，您将立即获得数据。这些都按身体区域和负载类型直观、清晰地显示。这节省了大量的处理时间。
2.画面显示 数据在人体图上非常直观地呈现。每个身体区域都有重复次数、持续时间、力量和总分的分数。然后，您可以进一步放大每个身体区域的详细信息。最终结果始终是根据交通灯模型的颜色代码：绿色、黄色或红色。
3.多个参数 广泛的生物力学参数允许对每项任务进行评估。绘制整个身体的物理负荷。根据任务或研究问题，可以更详细地解释相关参数。
注意事项
1.手动输入重量 体重是决定力量得分的重要参数。但是，这必须手动输入。如果始终使用相同的权重，则这不一定是问题。由于重量变化很大，例如在超市中，这仍然需要大量工作。
2.标准不切合实际 国际标准的限值基于实验室研究。实际上，这些限制非常严格。手腕、头部和膝盖尤其如此。例如，当没有负重走上楼梯时，肩膀和膝盖已经进入红色区域。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe56d485dfc1b8507b3fb56844d7effb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4e1841228ce0c70f9b031ececef5657/" rel="bookmark">
			（嵌入式c语言）类型修饰符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 类型修饰符 对内存资源存储位置的限定
auto 默认的类型修饰符 修饰的变量可读可写 register 因为你内部寄存器比较少，使用此类型修饰符，会告诉编译器尽量把此数据放到寄存器。
CPU内部寄存器是编号来定义，无地址编号，所以register定义后的数据无法取地址
static 可以修饰局部变量，全局变量，函数
const 定义为常量
只读的变量（通过隐式可修改），无法显式修改，但是可以通过指针修改。
并不是绝对的无法修改的只读类型。
extern 外部声明
volatile 告诉编译器对编译方法的关键字，不优化编译
内存访问符号 () 限制符、函数访问符
[] 内存访问的ID符号
{} 函数体限制符 结构体的成员内存访问符
地址用 -&gt;
变量用 . &amp;取地址符 * 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c47e7bc028adc030964b32c8ef9240a4/" rel="bookmark">
			在表格中使用el-select选中获取options中的item实现数据回显
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要获取整个被选中的item对象，你可以使用el-select组件的@change事件监听器来捕获选项变化，并通过回调函数获取选中的item对象。首先，在&lt;el-select&gt;元素上添加@change属性，绑定一个方法以监听选项变化。
&lt;el-select v-model="scope.row.commodityName" filterable placeholder="请选择" @change="handleSelectChange"&gt; &lt;el-option v-for="item in options" :key="item.commodityName" :label="item.commodityName" :value="item.commodityName"&gt;&lt;/el-option&gt; &lt;/el-select&gt; 如果在回调函数中无法正确打印出item对象，可能是因为选项的值使用了字符串类型的item.commodityName，而v-model绑定的是字符串类型的scope.row.commodityName，导致无法正确匹配选项。你可以尝试将v-model绑定的值改为整个item对象，以便正确获取整个选中的item。
把item绑定到scope.row.commodityName让表格中这个值为一个对象，再通过@change="handleSelectChange(scope.row)"
把表格整行数据带入实现。
或者直接使用input模糊搜索
如数据太多可使用懒加载
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff09e1be493a705bc0ccc35e991bf0e5/" rel="bookmark">
			AD四层板设计（Altium Designer）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AD绘制四层板 前言一、正片层和负片层介绍二、PCB板的叠层设计1.两层板的叠层2.四层板的叠层 三、规则设计参考资料 前言 1、用 Altium Designer 软件绘制电路时，通常2层板能实现设计需求。遇到板框固定，元器件密集的情况下，2 层板无法实现预期功能，考虑设计多层板；
2、本文主要介绍AD四层板的设计流程，其中PCB的叠层设计、内缩设计及DRC设计规则是关键。
3、软件版本：Altium Designer 19.0.4
一、正片层和负片层介绍 1、正片层(Signal)
正片就是平常用在走线的信号层，即走线的地方是铜线，用Polygon Pour进行大块敷铜填充。
2、负片层(Plane)
负片正好相反，即默认敷铜，走线的地方是分割线，也就是生成一个负片之后整一层就已经被敷铜了，要做的事情就是分割敷铜，再设置分割后的敷铜网络。
3、内电层的分割实现
AD中直接用Line，快捷键P+L，来分割，分割线不宜太细，用15mil及以上。
要分割敷铜时，只要用Line画一个封闭的多边形框，在双击框内敷铜设置网络即可。
正负片都可以用于内电层，正片也可通过走线和敷铜实现。
负片的好处：默认大块敷铜填充，在添加过孔，改变敷铜大小等等操作都不需要Rebuild，这样省去了PROTEL重新敷铜计算的时间。中间层用于电源层和GND层时候，层面上大多是大块敷铜，这样用负片的优势就很明显。
建议信号层采取“正片”的方式处理，电源层和GND层采取“负片”的方式处理，可以很大程度上减小文件数据量的大小和提高设计的速度。
二、PCB板的叠层设计 叠层设计遵从以下规定：① 每个走线层都必须有一个邻近的参考层(电源或地层)；② 邻近的主电源层和地层要保持最小间距，以提供较大的耦合电容。 1.两层板的叠层 对于两层板来说，由于板层数量少，已经不存在叠层的问题。控制EMI辐射主要从布线和布局来考虑；
单层板和双层板的电磁兼容问题越来越突出。造成这种现象的主要原因就是因是信号回路面积过大，不仅产生了较强的电磁辐射，而且使电路对外界干扰敏感。
要改善线路的电磁兼容性，最简单的方法是减小关键信号的回路面积。
关键信号：从电磁兼容的角度考虑，关键信号主要指产生较强辐射的信号和对外界敏感的信号。能够产生较强辐射的信号一般是周期性信号，如时钟或地址的低位信号。对干扰敏感的信号是指那些电平较低的模拟信号。
单、双层板通常使用在低于10KHz的低频模拟设计中:
① 在同一层的电源走线以辐射状走线，并最小化线的长度总和；②走电源、地线时，相互靠近；在关键信号线边上布一条地线，这条地线应尽量靠近信号线。这样就形成了较小的回路面积，减小差模辐射对外界干扰的敏感度。当信号线的旁边加一条地线后，就形成了一个面积最小的回路，信号电流肯定会取道这个回路，而不是其它地线路径。③ 如果是双层线路板，可以在线路板的另一面，紧靠近信号线的下面，沿着信号线布一条地线，地线尽量宽些。这样形成的回路面积等于线路板的厚度乘以信号线的长度。 2.四层板的叠层 （1）PCB层介绍
AD19默认的Layer（层）有13个，层介绍如下表： Layer含义Top Layer顶层，该层通常用于布线Bottom Layer底层，该层通常用于布线Mechanical 1机械层1，该层可用于设计PCB的机械外形Top Overlay顶层丝印层，顶层元器件丝印、字符Bottom Overlay底层丝印层，底层元器件丝印、字符Top paste顶层助焊层，一般用于贴片元件的SMT回流焊过程时上锡膏Bottom Paste底层助焊层，一般用于贴片元件的SMT回流焊过程时上锡膏Top Solder顶层阻焊层，敷设阻焊绿油，以防止铜箔上锡，保持绝缘Bottom Solder底层阻焊层，敷设阻焊绿油，以防止铜箔上锡，保持绝缘Drill Guide钻孔定位层，焊盘及过孔的钻孔的中心定位坐标层Keep-Out Layer禁止布线层，可用于设计PCB机械外形Drill Drawing钻孔图纸层，焊盘及过孔的钻孔孔径尺寸描述层Multi-Layer通孔层，抽象的层，仅显示过孔和焊盘 四层板，顾名思义就是有四层的电路板，它通常由顶层信号层、中间层（内电层）Power层、中间层GND层和底层信号层组成。顶层信号层Top Layer和底层信号层Bottom Layer已经存在，中间层的两层需要添加。 （2）四层板的层叠顺序：SIG－GND－PWR －SIG
这种层叠顺序通常应用于板上芯片较多的情况。此方案可得到较好的SI性能，但对于EMI性能来说并不是很好，主要通过走线及其他细节来控制。注意：地层放在信号最密集的信号层的相连层，有利于吸收和抑制辐射；增大板面积，体现20H规则。 （3）层叠设计步骤：
步骤1：快捷键D+K，打开层叠管理器 注意：Dielectric 是电介质，介于Top Layer与Bottom Layer之间的绝缘材料，不用进行操作。四层板设计需要在Top Layer与Bottom Layer之间添加两层中间层。
步骤2：如下图所示，创建第一个负片层，①选择Top Layer所在行 → ②右键选择Insert layer below → ③选择Plane 中间层选择类型，见下表：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff09e1be493a705bc0ccc35e991bf0e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a5ed435c7c614c61292c90db601b4d3/" rel="bookmark">
			mysql5.6.51zip包在windows免安装配置使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载 下载链接： https://downloads.mysql.com/archives/community/
配置 删掉原来的my-default.ini，新建my.ini
[client] port=3307 [mysql] default-character-set=utf8mb4 [mysqld] #skip-grant-table character_set_server=utf8mb4 socket = E:/xxx/mysql-5.6.51-winx64/mysql.sock bind-address = 0.0.0.0 port=3307 skip-name-resolve skip-host-cache basedir = E:/xxx/mysql-5.6.51-winx64 datadir = E:/xxx/mysql-5.6.51-winx64/data tmpdir = E:/xxx/mysql-5.6.51-winx64/tmp pid-file = E:/xxx/mysql-5.6.51-winx64/logs/mysql.pid max_allowed_packet = 100M max_connections=1500 log-error = E:/xxx/mysql-5.6.51-winx64/logs/mysql-error.log interactive_timeout = 86400 wait_timeout = 86400 # 大小写敏感 lower_case_table_names=1 sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES 手动创建配置文件中的文件夹data、tmp、logs
初始化 进入mysql文件夹下bin目录，开一个cmd，确认是管理员身份打开
mysqld --initialize --default-file="my.ini文件路径" 启动 mysqld --console 登录数据库 bin目录下新开一个cmd
mysql -P 3307 -uroot -p 或者 mysql -P 3307 -uroot 如果用的是默认端口3306，可以不用加-P，初始密码为空，直接回车即可登录
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a5ed435c7c614c61292c90db601b4d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/754082ac212d7a3ae6f06e4cef7ea882/" rel="bookmark">
			电脑无法识别硬盘的解决方案：排除故障与恢复数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在现代社会，电脑已成为人们生活和工作的不可或缺的一部分。然而，有时我们可能会遇到一个令人沮丧的问题，即电脑无法识别硬盘。硬盘作为存储数据的关键部件，其异常可能导致数据丢失和系统崩溃，因此这个问题需要及时解决。本文将从排除故障和恢复数据两个方面，为你介绍在电脑无法识别硬盘时的应对方法。
1. 排除故障：
检查物理连接： 首先，我们需要确保硬盘的物理连接是正确的。检查数据线和电源线是否牢固连接在硬盘和主板上。如果连接不良，可能导致硬盘无法被识别。
更换数据线和电源线： 如果连接无误但问题仍存在，可以尝试更换数据线和电源线，有时损坏的线缆会导致硬盘无法正常工作。
检查硬盘电源： 硬盘的电源供应也是必要的。确保硬盘的电源线与电源连接牢固，电源是否正常供电。
在其他电脑上测试： 如果以上步骤都没有解决问题，可以将硬盘连接到另一台电脑上测试，以确定是否硬盘本身存在问题
2. 恢复数据：
使用数据恢复工具： 如果硬盘被检测出问题，但数据仍然可读取，可以尝试使用数据恢复工具。这些工具能够扫描硬盘并尝试恢复丢失的数据。
专业数据恢复服务： 如果硬盘无法正常读取，或者你不具备足够的技术知识，可以考虑寻求专业的数据恢复服务。专业的服务提供商通常拥有更先进的工具和技术，可以从损坏的硬盘中恢复数据。
注意事项：
在处理电脑无法识别硬盘的问题时，需要注意以下事项：
不要自行拆卸硬盘： 如果你不具备硬件维修经验，不建议自行拆卸硬盘，以免造成更严重的损害。
备份数据： 在尝试修复问题之前，应该尽量备份重要的数据。在恢复数据的过程中，有时会导致数据进一步丢失，因此提前备份是明智之举。
避免进一步损害： 如果你怀疑硬盘出现故障，应立即停止使用，并将硬盘与电脑断开，以避免进一步损害。
电脑无法识别硬盘可能是一个令人烦恼的问题，但并非绝望的情况。通过仔细检查物理连接、更换线缆以及使用数据恢复工具或专业的数据恢复服务，我们通常能够找到解决问题的方法。然而，在处理这个问题时，要谨慎小心，尽量避免进一步的数据损失和硬件损害。在电脑故障出现时，保持冷静并采取正确的措施，将有助于最终解决问题并保护你的数据。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3692123204fed89819f2c5ec1ed5a24/" rel="bookmark">
			CH32V307 开启浮点后rtthread的修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方版本是3.1.3，而且只有整数的，开启浮点后要做一些修改，这里问了官方并贴出来方便大家使用：
首先在mounriver开启浮点，步骤：
开启浮点：ide 开启float point-&gt;rvf, floating point abi-&gt;single precision，优化里设置 single precision constants
在cross linker里 misc 设置use float with nano printf
然后rtthread的cpuport.h启用宏 ARCH_RISCV_FPU
最后按下面改4个文件
CH32V307 开启浮点后rtthread的修改-3YL的博客 (labisart.com)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99a457f16bda5f5f2002a59bc941ef0b/" rel="bookmark">
			flex中 align-items与justify-content的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先理解flex中的主轴与交叉轴是定义 Flex中提出了一个重要的概念——轴
默认情况下主轴是水平的
可以通过flex-direction来修改主轴方式。
flex-direction 属性规定灵活项目的方向
row 默认值。灵活的项目将水平显示，正如一个行一样row-reverse 与 row 相同，但是以相反的顺序column 灵活的项目将垂直显示，正如一个列一样column-reverse 与 column 相同，但是以相反的顺序 row效果
row-reverse效果
column效果
column-reverse效果
align-items与justify-content的定义与区别 align-items属性定义了项目在主轴上的对齐方式，如下面默认的方向为从左到右 justify-content属性定义项目在交叉轴上如何对齐，如下面的方向为从上到下 小结 通过flex-direction确定了主轴方向，justify-content确定了再主轴方向的对齐方式，align-items确定了对应垂直方向的对齐方式，基本能满足各种对齐的需求
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64ebe70b7ba262dbe097cf09005b66cf/" rel="bookmark">
			git 创建远程仓库并且本地代码提交到远程仓库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、gitee
二、本地安装git
1.下载
2.设置用户
三、创建远程仓库
四、初始化本地仓库
1.初始化项目文件夹
2.添加所有文件到缓冲区
3.提交代码到本地仓库
4.添加远程仓库的地址
5.拉取远程分支
6.推送代码到远程
总结
前言 本文记录git创建远程仓库，将本地代码提交到远程仓库的过程。这里使用的软件是gitee,同类型的还有github，gitlab等。
一、gitee 在gitee官网注册一个账号，用邮箱接受验证码。
官网地址：Gitee - 企业级 DevOps 研发效能平台
二、本地安装git 1.下载 在官网下载即可，注意一下本机是32还是64位，安装过程中不了解的配置用默认就可以，安装的路径不要有中文。
官网地址：Git
2.设置用户 第一次使用的时候要设置一下用户，命令如下，其中用户名和邮箱都随意就可以，不需要真实邮箱，该设置仅为了区分一下本地用户
git config --global user.email "you@example.com" git config --global user.name "Your Name" 三、创建远程仓库 在gitee账号内新建一个仓库。
在创建仓库页面填写相关信息后，点击创建，成功创建仓库。
创建成功后，会显示创建好的远程仓库地址
四、初始化本地仓库 1.初始化项目文件夹 git init 2.添加所有文件到缓冲区 git add . 3.提交代码到本地仓库 git commit -m "first commit" 4.添加远程仓库的地址 git remote add origin https://gitee.com/username/xxx.git 5.拉取远程分支 如果远程仓库是新创建的，没有提交过代码，这步可以省略。
git pull 若远程代码已存在，使用如下命令合并
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64ebe70b7ba262dbe097cf09005b66cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb32c10cd67aaffebf8a42483520cf54/" rel="bookmark">
			java ftp服务器 多用户、 多文件夹监听文件上传 spring boot整合Ftp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 这里介绍 java创建 Ftp服务器, 并且监测客户端上传文件后，读取文件的操作。使用 hutool 创建Ftp客户端，使用 ftplet-api 下的 DefaultFtplet 进行文件监听。上传的文件夹通过不同用户添加，设置不同的用户名、密码、上传文件夹，测试时通过连接不同的用户，上传文件到指定文件夹。这里有个小小的问题 DefaultFtplet 监听器是 ftp 依赖下的类，测试使用 Hutool 下的 Ftp 类，所以无法通过 hutool的 Ftp类 测试指定文件夹上传，只能上传 创建 Ftp 服务器 时 指定的文件夹，即创建 Ftp服务器时 添加 不同用户 的文件夹 sql 数据表
CREATE TABLE `ftp_info` ( `id` int(11) NOT NULL AUTO_INCREMENT, `ftp_code` varchar(255) NOT NULL COMMENT 'ftp编码', `username` varchar(255) NOT NULL COMMENT '用户名', `password` varchar(255) NOT NULL COMMENT '密码', `upload_folder` varchar(255) NOT NULL COMMENT '上传文件夹', `status` int(11) NOT NULL DEFAULT '0' COMMENT '是否使用 1使用 0 未用', PRIMARY KEY (`id`), UNIQUE KEY `user` (`username`,`password`) ) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4; 数据表实体类
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb32c10cd67aaffebf8a42483520cf54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce3a2712567bf6d59aaf5cde46e71aca/" rel="bookmark">
			ResizeObserver监听元素大小的变化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		window.resize不适用于dom的监听。
ResizeObserver ResizeObserver 接口监视 Element 内容盒或边框盒或者 SVGElement 边界尺寸的变化。
方法 ResizeObserver.disconnect()
取消特定观察者目标上所有对 Element 的监听。
ResizeObserver.observe()
开始对指定 Element 的监听。
ResizeObserver.unobserve()
结束对指定 Element 的监听。
在页面挂载的时候进行某个dom的监听
const theResizeObserver = new ResizeObserver(this.handleResize); theResizeObserver.observe( document.getElementsByClassName("leftSpanRightBoix")[0] ); 在页面销毁的时候取消监听
theResizeObserver.unobserve( document.getElementsByClassName("leftSpanRightBoix")[0] ); // 该元素触发的回调函数
handleResize = (dom) =&gt; { // 我自己的处理逻辑 // ... const height = dom[0].contentRect.height; console.log(height, "aaa========="); if (height &gt; 40) { !this.state.isShowLine &amp;&amp; this.setState({ isShowLine: true, }); } else { if (this.state.isShowLine !== false) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce3a2712567bf6d59aaf5cde46e71aca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a10ac8647f44435341cb7de915b71c14/" rel="bookmark">
			Android创建签名文件，并获取签名文件MD5,SHA1,SHA256值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、创建Android签名文件
使用Android Studio开发工具，可视化窗口进行创建
第一步：点击AndroidStudio导航栏上的 Build→Generate Signed Bundle / APK
第二步：选择APK选项
第三步：创建签名文件
第四步：输入创建签名的文件的各内容信息
点击ok，即可完成签名的文件的创建。
二、并获取签名文件MD5,SHA1,SHA256值
下载Java JDK,目前最新的JDK已不支持获取MD5签名，只支持sha1,sha256两种签名，以下提供可获取MD5签名的JDK版本
百度网盘：
链接：https://pan.baidu.com/s/1BpLLCO1m-i19sXlBKTbD_w
提取码：vwpv
android签名文件分为调试版和正式版，调试版默认使用系统提供的debug.keystore。
（1）获取调试版debug.keystore的SHA1等值的命令：
密钥库口令为：android
（2）获取正式版签名文件SHA1等值的命令：
打开cmd命令行，cd .android定位到 .android文件夹，然后输入命令为：
密钥库口令为：你的证书密码
点击回车就可以看到正式版的SHA1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94d18545a6d327fcc74aef440f23126e/" rel="bookmark">
			jsWebControl解决海康视频插件窗口遮挡层级问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 项目场景:项目中有弹框展示时插件窗口的层级无法进行调整
解决方案:通过控制窗口的显隐来控制窗口层级
oWebControl.JS_HideWnd() oWebControl.JS_ShowWnd() 我是用的是1.0.0版本基于vue开发,可通过监听控制弹框的显隐变量调用 ,3.0版本以上不能调用这个api watch: { //监听dialog弹框 监控层级问题 showpop(newVal) { if(newVal){ this.oWebControl.JS_HideWnd() } else { this.oWebControl.JS_ShowWnd() } }, diaLog(newVal) { if(newVal){ this.oWebControl.JS_HideWnd() } else { this.oWebControl.JS_ShowWnd() } }, }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3013e2e83018019ffbf0d52fc3556c5/" rel="bookmark">
			super iserver发布shp线上地图,获取数据集(超图服务发布 - 保姆式教程)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、下载及安装iServer
下载地址:SuperMap技术资源中心|为您提供全面的在线技术服务
根据电脑系统下载对应的软件和服务,我的是windows10 选择的是SuperMap GIS 10,需要注意的是一定要下载两个包
直接下载到电脑安装操作过程都点下一步就行
两个包都解压成功后要注意 先打软件包的解压文件,打开SuperMap Desktop应用程序登陆授权,程序打开成功后,找到服务包的解压文件找到bin文件下的startup.bat双击打开启动iserver服务,如下图启动成功后在浏览器中输入http://localhost:8090/ 打开服务管理页面
服务管理页面
二.创建shp文件数据集
打开软件后选择新建文件型数据源,输入文件名后保存,保存成功后导入数据集选择本地保存的shp文件
导入成功后,配置坐标系等属性,图片为我自己导入的,默认GCS_China_2000即可
点击投影转换,将shp文件转换为图层
把当前图层保存到工作空间
创建文件保存到电脑,保存成功后即可到isever上发布服务
三.发布
本地浏览器输入http://localhost:8090/ 打开服务管理页面,也就是我们第一步打开的页面
1.点击服务管理
创建服务
选择工作空间点击下一步选择我们刚才保存到工作空间的文件,点击下一步
选择地图服务和数据服务,点击下一步,如果你们项目中需要用到其他服务可进行多个勾选
点击完成后我们的地图服务和数据服务就发布完成了
map开头的为地图,data开头的为数据服务 然后就可以在服务管理中查看刚刚发布的服务了
点击后可直接打开地图服务
同样在数据服务中可查看刚刚发布的数据服务
我们项目是基于mapBox开发,如果同框架开发有疑惑的可评论留言
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dfd2d5ba626f770b145d21c668387ca/" rel="bookmark">
			QT 使用图表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、概念
1.1 坐标轴-QAbstractAxis
1.2 系列-QAbstractSeries
1.3 图例-Legend
1.4 图表-QChart
1.5 视图-QChartView
2、 QT 折线图
2.1 Qt 折线图介绍
2.2 Qt 折线图实现
Qt 图表是专门用来数据可视化的控件
Qt 图表包含折线、饼图、棒图、散点图、范围图等。
使用 Qt 图表时,需要添加 Qt += charts
包含头文件 #include
1、概念 1.1 坐标轴-QAbstractAxis 图表中，一般都有 X、Y 坐标轴，复杂一些的还带有 Z 轴。对应到 Qt 的图表也有 X、Y 轴对象。但是 今天，我们先不展开介绍。如果我们不创建轴坐标对应的对象，可以使用 Qt 的默认轴对象。后面我们会介绍用 法。
1.2 系列-QAbstractSeries 不论是曲线、饼图、棒图还是其他图表，其中展示的内容本质都是数据。一条曲线是一组数据，一个饼图也 对应一组数据。在 Qt Charts 中，这些一组组的数据被称作系列。对应不同类型的图表 Qt 提供了不同的系列。 系列除了负责存储、访问数据，应该还提供了数据的绘制方法，比如折线图和曲线图分别对应 QLineSerie 和 QSPLineSerie。我们可以用不同的系列达到不同的展示目的。
1.3 图例-Legend 类似于 Excel，Qt Charts 中也提供了图例，并且还可以显示或者隐藏图例。
1.4 图表-QChart Qt 提供了 QChart 类来封装前面所说的内容，比如坐标轴、系列、图例等。QChart 承担了一个组织、管理 的角色。QChart 派生自 QGraphicsObject，因此它实际上是一个图元 item。我们可以从 QChart 获取到坐标轴对 象、数据系列对象、图例等等，并且可以设置图表的主题、背景色等样式信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1dfd2d5ba626f770b145d21c668387ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d667ee31953a8e4d5b653dec4e6dfeb8/" rel="bookmark">
			本科双非CS，计算机985 CS，投的IC，记录一下
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		快手 | 视频架构 | 二面 | 8.21
总体情况轻雀平台；60余分钟；八股 + 算法具体问题Java 基础ConcurrentHashMap 底层原理什么是可重入锁ConcurrentHashMap 算是完成了吧。把业务基本功能完成了，之
算是完成了吧。把业务基本功能完成了，之后就是加一些其他策略，优化规范合并之类的，都好做了，但也要认真细心的做。过去几年一直是卷几天摆几个月的状态，工作之后的这两
#牛客在线求职答疑中心(35799)#深
#牛客在线求职答疑中心#深圳睿瀚医疗科技有限公司
简历要在附件里面加上吗
为什么每个官网都要解析一次简历啊🤔️，而且特别难用，每次都要把文字重新复制一次，完了第二次打开我的简历里面好像没简历的pdf了，话说hr看得倒我发得pdf吗 求工作介绍。
22届，前端一年经验。目标是深圳前端岗位，学历是二本。有没有合适的工作岗位介绍 #2022届毕业生现状# 。 #工作介绍#
23届找工作
因为选公司没选好，在现在的公司非常憋屈，面临转正不了的地步，现在还有招收23届的公司吗，交了2个月社保，求求🥺🥺 #找工作中的意难平# #找工作中的意难平
禾赛模拟IC岗 一面
1.面试官很高，像长辈，愿意和你分享、讨论技术相关的问题。2.面试3，40分钟。3.虽然全程无压力面，但感觉他轻松的样子就是kpi面4.希望渺茫
蔚来笔试
算法A卷选择题涵盖机器学习，数据结构，C++语言基础，对我而言偏难，蒙了几个。算法题中规中矩，mid难度。第一题：第二最大2×2池化，直接模拟。第二题：牛牛做生
程序员校招专属的求职讲座来了！
8月26日周六晚19:00，我会从求职筹备、实习、考察点、简历、面试、HR沟通几个方面着手，深入剖析+解读程序员校招求职的全链路方法论经验+落地实操方案。对于时
中望二面-求个hr面
21日上午十点二面，不算老也不算年轻，炮轰我的项目，然后自己也不是很满意。面试官说如果过了的话，一般一周之内会有hr联系。不管怎么样，还是许愿一个hr面吧。
#牛客在线求职答疑中心(35799)#
#牛客在线求职答疑中心# #顺丰信息集散地#兄弟们，顺丰科技实习生有转正机会吗😭，秋招难呐
诺瓦星云拿下
#诺瓦星云2024秋招提前批#
科大讯飞
投了 Java开发和深度学习框架和平台
美团能不能快来约面我啊！
ak了都不约面，急死我啦！！！有没有兄弟们也没约到面的 后端 到家
许愿腾讯ieg冲！
终于准备第一次跳槽啦，记录一下
21届学生，双非一本科读的是通信工程，在校期间没有任何的实习经历还有项目比赛经历，仅有社团经历还有一个稍微高一点点的绩点，毕业的时候手里拿了涂鸦智能还有中电的o
tplink座谈会offer
17号tplink座谈会的兄弟们有收到电话的吗不会真的是烂白菜吧
简历项目怎么深挖
非科班，做的两个项目都是网上找的，想知道佬们如何写的简历以及如何体现自己的思考的，比如经典问题“遇到什么困难，怎么解决，创新点”啥的我现在的写法感觉还是有点问题
西门子ai面
回忆版1.最近的竞赛或者比赛，遇到什么问题，怎么解决的2.学习某技术如何应用于工作学习的3.描述下学习的一项技能，你是如何学习的4.项目中遇到了会导致延期的问题
24届要不要做WXG 转正实习
论文压力很大，思路不太顺畅，害怕影响毕业想问各位大佬，要不要在这个时候做三个月产品实习呢 #秋招#
大疆复筛已通过之后一周多没约面试
想问一下，大疆复筛已通过，🈶️没约面试的情况嘛感觉通过快两周了都还没面试（视觉算法岗） #大疆# #大疆信息集散地# #大疆求职进展汇总#
什么资本家车牌
😅
求多模态方向的实习
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d667ee31953a8e4d5b653dec4e6dfeb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a66f03e202d9149348fb42d6d42ba511/" rel="bookmark">
			Spring—IOC与AOP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.IOC（Inversion of Control，控制反转）介绍 IOC（控制反转）是一种设计思想，其核心原则是将对象的创建、依赖关系的管理从应用程序代码中抽离出来，交给容器来负责。传统的开发方式中，对象的创建和依赖关系需要由开发者显式地在代码中进行处理，而采用IOC的方式，开发者只需通过配置文件或注解等方式描述对象的创建和依赖关系，容器会根据这些描述信息自动完成对象的创建和依赖注入。这样可以降低代码的耦合性，提高可维护性和可扩展性，使得应用程序更加灵活和易于测试。
实现IOC 1.导入IOC相关的jar包 &lt;dependencies&gt; &lt;!-- Spring Core：包含IOC容器的核心功能 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;5.3.10&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring Context：提供了应用程序上下文（ApplicationContext）的支持，包含了IOC容器的实现 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.3.10&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; spring-core：包含IOC容器的核心功能，提供了基础的依赖注入（DI）机制。spring-context：提供了应用程序上下文（ApplicationContext）的支持，是Spring IOC容器的具体实现。 2.创建 User_DemoMapper接口和对应的User_DemoMapperImpl实现类 public interface User_DemoMapper { public void show(); } public class User_DemoMapperImpl implements User_DemoMapper{ @Override public void show() { System.out.println("诸葛亮：我从未见过如此厚颜无耻之人"); } } 3.编写Spring容器，applicationContext.xml文件进行配置 依赖注入 &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;!-- 这里是配置内容 --&gt; &lt;bean id="user_demo" class="com.cskt.poji.User_Demo"&gt; &lt;property name="name" value="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a66f03e202d9149348fb42d6d42ba511/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68dfc083f65f4a92f2d9271f559bde19/" rel="bookmark">
			Stable Diffusion 原理介绍与源码分析（二、DDPM、DDIM、PLMS算法分析）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Stable Diffusion 原理介绍与源码分析（二、DDPM、DDIM、PLMS）
文章目录
Stable Diffusion 原理介绍与源码分析（二、DDPM、DDIM、PLMS）
系列文章
前言（与正文无关，可忽略）
总览
DDPM
对原理进行朴素回顾
DDPM 代码分析
针对 DDPM 的改进
DDIM
PLMS
资源汇总
小结
系列文章
Stable Diffusion 原理介绍与源码分析（一、总览）
前言（与正文无关，可忽略）
发现标题越起越奇怪了…
本文继续介绍 Stable Diffusion 框架的实现。在之前的文章 Stable Diffusion 原理介绍与源码分析（一、总览） 中，我介绍了 Stable Diffusion 文生图框架的整体结构，如下图，并简要描述了其各个重要组成模块： 其中红框中的 UNetModel 已经在上篇文章中介绍过，只需要记住它被用来预估图像的噪声，并且可以保持输入输出的大小不变（我就是这么进行粗浅的记忆的🤣）。而本文则会将目光移向采样阶段，即上图蓝框中的内容，简要介绍扩散模型使用 DDPM、DDIM、PLMS 等算法通过迭代去除噪声，从而生成图像的潜在空间（latent space）表示。
另外需要注意的是，我其实在文章（一）中也进行过说明，我将以伪代码的形式对源码进行分析，这可以刨除大量无关的细节，直达本质，也特别方便后续回顾。
目前 ChatGPT 大火，它能够在一定程度上辅助我们写代码，我们只需要准确描述自己的意图，剩下的工作让它完成就好。（以后和公司谈薪时，对代码进行 Ctrl-C &amp; Ctrl-V 只值 1% 的工资，知道 Ctrl-C &amp; Ctrl-V 哪些 code 值剩下的 99%，哈哈🤣）
总览
本文对 Stable Diffusion 主要使用的如 DDPM、DDIM、PLMS 等算法进行分析，详解其代码实现。
源码地址： Stable Diffusion
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68dfc083f65f4a92f2d9271f559bde19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70db1a0b39644d8c9867c9a4de5ecff3/" rel="bookmark">
			两万字，MySQL压力测试工具sysbench详解（sysbench mysql和mariadb性能测试）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sysbench mysql和mariadb性能测试 sysbench是一个模块化的、跨平台、多线程基准测试工具，主要用于评估测试各种不同系统参数下的数据库负载情况。
主要测试方式cpu性能磁盘io性能调度程序性能内存分配及传输速度POSIX线程性能数据库性能(OLTP基准测试)找范围内最大素数{时间越短越好}不同场景下IOPS{越大越好}线程并发执行，循环响应信号量花费的时间{越少越好}以不同块大小传输一定数量的数据吞吐量大小{越大越好}并发线程同时申请互斥锁循环一定次数花费的时间{越少越好}qps、tps越高越好 目前sysbench主要支持 MySQL,pgsql,oracle 这3种数据库。
安装测试环境为：RHEL7.2 MariaDB5.5.44
安装sysbench-0.5 源码地址https://github.com/BoobooWei/sysbench/archive/master.zip
[root@localhost ~]# unzip sysbench-master.zip [root@localhost ~]# cd sysbench-master/ [root@localhost sysbench-master]# ls autogen.sh configure.ac doc Makefile.am README.md sysbench TODO ChangeLog COPYING install-sh missing README-Oracle.md tests config debian m4 mkinstalldirs README-WIN.txt third_party [root@localhost sysbench-master]# yum install -y automake libtool [root@localhost sysbench-master]# ./autogen.sh ./autogen.sh: running `libtoolize --copy --force' libtoolize: putting auxiliary files in AC_CONFIG_AUX_DIR, `config'. libtoolize: copying file `config/ltmain.sh' libtoolize: putting macros in AC_CONFIG_MACRO_DIR, `m4'.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70db1a0b39644d8c9867c9a4de5ecff3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64b04a8d8176c52f768817ec2bb29e79/" rel="bookmark">
			使用中科大的 Ubuntu 软件源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看系统版本 cat /etc/os-release 选择对应的软件源 打开中科大的软件源选择地址：LUG's repo file generator根据 Ubuntu 系统版本选择对应的软件源： 将 ubuntu 系统中 /etc/apt/sources.list 文件内容设置为上面的内容；执行以下命令进行更新： apt-get update 重启系统 至此，已将 ubuntu 的软件源调整为中科大的软件源。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eebba0790c43c4c1addc35c0cccadad8/" rel="bookmark">
			西南财经大学·奇点工作室·程序设计部 暑期训练营 第五次课后习题题解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		长鑫存储面经攒rp
一面 自我介绍1.cmos工艺2.项目细节，其实整个过程基本都在扒项目细节3.专利的大概思路4.为什么要选择长鑫反问环节 二面 自我介绍更偏向于性格测试1
阿里淘天集团F24秋招开始了
【部门介绍】自营行业技术是淘天集团大淘宝技术的自营领军团队，核心支撑天猫超市、天猫国际、天猫奢品、食品生鲜等类自营电商业务；致力于成为最懂自营商业的技术创新团队
题解 | #统计每个单词出现的个数#
#!/bin/bashcat ./nowcoder.txt|xargs -n1|sort|uniq -c|sort|awk '{print $2,$1}'
民生证券信息技术避坑
最近看到民生证券秋招开了，结合了解到的实习情况来评价一下；首先，民生证券投行还是非常棒的，这里讨论的是民生证券信息技术部，也就是研发岗运维岗什么的，不能因为信息
题解 | #第二列是否有重复#
#!/bin/bashawk '{print $2}' ./nowcoder.txt|sort|uniq -c|sort|tail -n2
字节跳动
字节内推码：V6T75AW字节校招内推来啦！欢迎大家用我的码~校招投递链接: https://jobs.bytedance.com/campus/positio
快手秋招一面二面HR面（回忆版），泡池子
快手也是二进宫，第一次投递的时候，部门筛选简历挂了一面8.9（1个小时）自我介绍项目介绍，项目难点操作系统和计网常规八股文接口与抽象类JVM运行时数据区域Jav
题解 | #提取不重复的整数#
import sysn = int(input())res = []ls = list(map(int, str(n))) # 取出整数的每一位ls = ls
题解 | #二分查找-I#
## 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可## # @param nums int整型一维数组 # @param targe
恒生电子2024校招全面启动！
#内推# #校招# #秋招# Hi，我在恒生电子帮你内推~ 您可登录链接：https://neitui.italent.cn/hscam
题解 | #转置文件的内容#
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eebba0790c43c4c1addc35c0cccadad8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29cbd394584b0f6e0d388cb6a9dbf02c/" rel="bookmark">
			pyQt5环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、PyQt5 及 pyqt5-tools 安装
PyQt可以在所有主流操作系统上运行（Unix，Windows，Mac），可直接用pip安装
pip install PyQt5 pip install pyqt5-tools 建议使用国内资源，可以快速安装：
pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pyqt5 pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pyqt5-tools 2、PyCharm配置环境
启动PyCharm，新建一个PyQt5空项目后，需要配置Qt Designer、pyuic、pyrcc工具。
2.1、Qt Designer 是图形化用户界面的图形设计器，通过拖拽的方式放置控件，并实时查看控件效果进行快速UI设计。
在Pycharm中，依次打开 File - Settings - Tools - External Tools，点击 + Create Tool，配置如下：
Name: QtDisigner Program : C:\python\Lib\site-packages\qt5_applications\Qt\bin\designer.exe # 当前designer目录，请根据实际位置修改 Working directory: $FileDir$ 2.2、Qt Designer 汉化(若有必要)
默认Qt Designer是英文版的，可以使用翻译文件进行汉化。
下载文件 designer_zh_CN.qm后， 拷贝至本地pyqt5_tools的translations文件夹下即可，示例目录如：
C:\Python38\Lib\site-packages\pyqt5_tools\Qt\bin\translations 在PyCharm主界面，依次点击 Tools - External Tools - QtDisigner，即可启动中文界面的Qt Disigner
2.3、PyUIC配置
PyUIC主要是把Qt Designer生成的.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29cbd394584b0f6e0d388cb6a9dbf02c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f48f29dc2c589e864573212e2fd9793e/" rel="bookmark">
			哈夫曼树介绍及Java实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		哈夫曼树 1. 介绍1.1 哈夫曼树1.2 路径、路径长度、结点的权、结点的带权路径长度1.3 树的带权路径长度WPL 2. 哈夫曼树构建步骤3. 代码实现 1. 介绍 1.1 哈夫曼树 哈夫曼树-最优二叉树：树的带权路径长度最小的二叉树；权值均为叶子结点；权值越大，结点距离根节点越近； 1.2 路径、路径长度、结点的权、结点的带权路径长度 1.3 树的带权路径长度WPL 2. 哈夫曼树构建步骤 对权值序列进行升序排列，选出其中最小的两个权值进行合并；将合并结点加入权值序列，重新进行排序；重复执行上述两个操作，直到序列中只剩一个节点即可完成创建；
上述案例的手动构建结果：
3. 代码实现 package com.northsmile.tree.huffman; import java.util.*; /** * @author NorthSmile * @version 1.0 * @date 2023/8/21&amp;18:36 * 哈夫曼树实现 */ public class HuffmanTree { public static void main(String[] args) { Scanner scanner=new Scanner(System.in); int n=Integer.parseInt(scanner.nextLine()); List&lt;TreeNode&gt; nodes=new LinkedList&lt;&gt;(); for (int i=0;i&lt;n;i++){ nodes.add(new TreeNode(Integer.parseInt(scanner.nextLine()))); } root=createHuffmanTree(nodes); // System.out.println(root.val); System.out.println(calWPL()); } // 根节点 private static TreeNode root; // 构建哈夫曼树 public static TreeNode createHuffmanTree(List&lt;TreeNode&gt; nodes){ while (nodes.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f48f29dc2c589e864573212e2fd9793e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2ef6d95537b065879544ec4625837eb/" rel="bookmark">
			ELK日志分析系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
开始
第一台安装elasticsearch-head插件
第一台node1安装logstash
配置收集系统日志 第一台
安装kibana第一台
第三台
简述：
日志分析是运维工程师解决系统故障，发现问题的主要手段。日志主要包括系统日志、应用程序日志和安全日志。系统运维和开发人员可以通过日志了解服务器软硬件信息、检查配置过程中的错误及错误发生的原因,经常分析日志可以了解服务器的负荷，性能安全性，从而及时采取措施纠正错误。
日志是一个非常庞大的数据，并且常常被分散在不同的设备上，这样排查问题的时候找日志就非常繁琐困难。
这时，一个专门处理日志的系统就非常必要，这里介绍其中的一种，ELK日志分析系统（ELasticsearch+Logstash+Kibana）
————————————————
环境：
三台主机
关闭防火墙和安全规则
[root@bogon ~]# iptables -F
[root@bogon ~]# setenforce 0
[root@bogon ~]# systemctl stop firewalld
设置主机名
第一台 elk-node1
第二台 elk-node2
第三台 现在不进行操作 等下用到再说
1，2台都用系统自带java环境
主机映射配置
/etc/hosts
192.168.1.117 elk-node1
192.168.1.120 elk-node2
先说一下这个服务 过程中容易端口丢失 建议调整内核和内存 不然费老大劲了
开始 上传软件包
[root@elk-node1 elk软件包]# rpm -ivh elasticsearch-5.5.0.rpm
警告：elasticsearch-5.5.0.rpm: 头V4 RSA/SHA512 Signature, 密钥 ID d88e42b4: NOKEY
准备中... ################################# [100%]
Creating elasticsearch group... OK
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2ef6d95537b065879544ec4625837eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d37f23a50efc713fb9dc8fea56529f66/" rel="bookmark">
			Jenkins构建前端报错内存溢出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关键报错信息：
关键报错信息：
--- JS stacktrace ---&gt;
13:52:10 13:52:10 FATAL ERROR: Reached heap limit Allocation failed - JavaScript heap out of memory
13:52:10 1: 0xb09c10 node::Abort() [node]
13:52:10 2: 0xa1c193 node::FatalError(char const*, char const*) [node]
13:52:10 3: 0xcf8dde v8::Utils::ReportOOMFailure(v8::internal::Isolate*, char const*, bool) [node]
13:52:10 4: 0xcf9157 v8::internal::V8::FatalProcessOutOfMemory(v8::internal::Isolate*, char const*, bool) [node]
解决方案： 1.在前端项目package.json中将打包命令修改为以下形式（设置最大内存） "build:dev": "node --max-old-space-size=4096 ./node_modules/vite/bin/vite.js build --mode development", "build:prod": "node --max-old-space-size=4096 ./node_modules/vite/bin/vite.js build", 修改后上传git重新构建；
2.设置环境变量（原理同1）： export NODE_OPTIONS=–max_old_space_size=4096 3.查看是否node版本过低，尝试高版本node运行（v12以上优化了内存机制）。 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d37f23a50efc713fb9dc8fea56529f66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/336e3c31e964529349fc2ccf344fe131/" rel="bookmark">
			STM32设置为I2C从机模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32设置为I2C从机模式 目录 STM32设置为I2C从机模式前言1 硬件连接2 软件编程3 运行测试3.1 I2C连续写入3.2 I2C连续读取3.3 I2C单次读写测试 4 总结 前言 STM32的I2C作为主机的情况相信很多同学都用过，网上也有很多教程，但是作为从设备使用的例子应该不多，本文通过硬件和软件的层面，介绍如何把STM32设置为一个I2C从机。
1 硬件连接 测试芯片：STM32F103ZET6
测试方法：用一个USB转I2C的工具接到STM32的I2C引脚上，通过上位机工具进行读写操作。如果没有这个工具，也可以用另外一个stm32或者其他设备测试通讯，同时也可以借助示波器或者逻辑分析仪来辅助调试。
硬件连接：
STM32这边使用硬件I2C1(PB6、PB7)，并外接上拉电阻。
2 软件编程 根据STM32数据参考手册，I2C作为从设备时发送和接收的流程如下：
测试例程：定义一个256字节的buffer用来存放I2C从机的数据，默认赋初值0-255，然后通过中断的方式实现I2C数据读写。
示例代码如下：
#include "stm32f10x.h" #include "stm32f10x_gpio.h" #include "stm32f10x_rcc.h" #include "stm32f10x_i2c.h" #include "misc.h" #define I2CSLAVE_ADDR 0x40 &lt;&lt; 1 // address is 0x40 #define I2C1_CLOCK_FRQ 100000 // I2C-Frq in Hz (100 kHz) #define I2C1_RAM_SIZE 256 // RAM Size in Byte #define I2C1_MODE_WAITING 0 // Waiting for commands #define I2C1_MODE_SLAVE_ADR_WR 1 // Received slave address (writing) #define I2C1_MODE_ADR_BYTE 2 // Received ADR byte #define I2C1_MODE_DATA_BYTE_WR 3 // Data byte (writing) #define I2C1_MODE_SLAVE_ADR_RD 4 // Received slave address (to read) #define I2C1_MODE_DATA_BYTE_RD 5 // Data byte (to read) uint8_t i2c1_mode = I2C1_MODE_WAITING; uint8_t i2c1_ram_adr = 0; uint8_t i2c1_ram[I2C1_RAM_SIZE]; uint8_t Get_I2C1_Ram(uint8_t adr) { return i2c1_ram[adr]; } void Set_I2C1_Ram(uint8_t adr, uint8_t val) { i2c1_ram[adr] = val; return; } void I2C1_Ram_Init(void) { uint16_t i; for (i = 0; i &lt; 256; i++) { Set_I2C1_Ram(i, i); } } void I2C1_Slave_Init(void) { GPIO_InitTypeDef GPIO_InitStructure; NVIC_InitTypeDef NVIC_InitStructure; I2C_InitTypeDef I2C_InitStructure; RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C1, ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE); /* Configure I2C_EE pins: SCL and SDA */ GPIO_InitStructure.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/336e3c31e964529349fc2ccf344fe131/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10fd02a6d914c478e6c7b679c574dd93/" rel="bookmark">
			从SVG到Canvas：选择最适合你的Web图形技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SVG 和 Canvas 都是可以在 Web 浏览器中绘制图形的技术。
众所周知， icon 通常使用 svg（如 iconfont），而交互式游戏采用 Canvas。二者具体的区别是什么？该如何选择？
声明式还是命令式？绘制的图形不同：Svg 绘制矢量图（不依赖分辨率），Canvas 绘制位图（依赖分辨率）；事件处理不同：Svg 基于 XML，对 DOM、事件友好，Canvas 通过 javascript 绘制，内部元素添加事件比较复杂；Svg 对于 css 更加友好 声明式 pk 命令式 Svg 是矢量【声明式】 可缩放矢量图形（Scalable Vector Graphics，SVG）基于 XML 标记语言，用于描述二维的矢量图形。
作为一个基于文本的开放网络标准，SVG 能够优雅而简洁地渲染不同大小的图形，并和CSS、DOM、JavaScript 和 SMIL 等其他网络标准无缝衔接。本质上，SVG 相对于图像，就好比 HTML 相对于文本。
SVG 图像及其相关行为被定义于 XML 文本文件之中，这意味着可以对它们进行搜索、索引、编写脚本以及压缩。此外，这也意味着可以使用任何文本编辑器和绘图软件来创建和编辑它们。
SVG 代码可以直接在 HTML 中运行，就像声明性绘图指令：
&lt;svg viewBox="0 0 100 100"&gt; &lt;circle cx="50" cy="50" r="50" /&gt; &lt;/svg&gt; 和传统的点阵图像模式（JPEG、PNG）不同的是，SVG 格式提供的是**矢量图，这意味着它的图像能够被无限放大而不失真或降低质量，并且可以方便地修改内容，无需图形编辑器。**通过使用合适的库进行配合，SVG 文件甚至可以随时进行本地化。
如果关心图形的灵活性和响应（不失真）能力，SVG 就是最佳选择。
Canvas 是一个 JavaScript 绘图 API【命令式】 Canvas 提供了一个通过 JavaScript 和 HTML 的元素来绘制图形的方式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10fd02a6d914c478e6c7b679c574dd93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7878592cfd046e982d9884c600f096f2/" rel="bookmark">
			JavaScript中删除两个数组对象中id相同的对象以及根据id删除数组中对象。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、filter、some方法删除两个数组对象中id相同的对象 let arr1=[{id:1,name:"张三"},{id:2,name:"李四"}] let arr2=[{id:1,name:"张三"},{id:3,name:"老刘"},{id:6,name:"老牛"},{id:8,name:"老万"},] let add=arr1.filter(item=&gt;!arr2.some(ele=&gt;ele.id===item.id)); //数组1新数组 let add1=arr2.filter(item=&gt;!arr1.some(ele=&gt;ele.id===item.id)); //数组2新数组 1. filter方法 定义和用法
filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。 注意： filter() 不会对空数组进行检测。
注意： filter() 不会改变原始数组。
语法
array.filter(function(currentValue,index,arr), thisValue) 参数说明
2. some方法 定义和用法
some() 方法用于检测数组中的元素是否满足指定条件（函数提供）。
some() 方法会依次执行数组的每个元素：
1.如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测。
2.如果没有满足条件的元素，则返回false。
注意： some() 不会对空数组进行检测。
注意： some() 不会改变原始数组。
语法
array.some(function(currentValue,index,arr),thisValue) 参数说明
二、删除数组中id相同的数据 方法一 let arr1=[{id:1,name:"张三"},{id:3,name:"老刘"},{id:3,name:"老刘"},{id:8,name:"老万"},] let hash = []; const newArr = arr1.reduce((pre, cur) =&gt; { hash[cur.id] ? '' : (hash[cur.id] = true &amp;&amp; pre.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7878592cfd046e982d9884c600f096f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/506aa695a633d1c92ed880415199090a/" rel="bookmark">
			springboot最全，最完整，最适合小白教程（开发实用篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文章为黑马的springboot教程的教学文档，具体视频内容移步至bilibili 黑马程序员官方账号
教程分为基础篇，运维实用篇，开发实用篇，原理篇
基础篇：springboot 基础篇
运维实用篇 ：springboot 运维实用篇
开发实用篇：springboot 开发实用篇
原理篇：springboot 原理篇
SpringBoot开发实用篇 ​ 怀着忐忑的心情，开始了开发实用篇文档的编写。为什么忐忑？特喵的债欠的太多，不知道从何写起。哎，不煽情了，开工。
​ 运维实用篇完结以后，开发实用篇采用日更新的形式发布给各位小伙伴，基本上是每天一集，目前已经发布完毕。看评论区，好多小伙伴在求文档，所以赶紧来补文档，加班加点把开发实用篇的文档刨出来。
​ 开发实用篇中因为牵扯到SpringBoot整合各种各样的技术，由于不是每个小伙伴对各种技术都有所掌握，所以在整合每一个技术之前，都会做一个快速的普及，这样的话内容整个开发实用篇所包含的内容就会比较多。各位小伙伴在学习的时候，如果对某一个技术不是很清楚，可以先跳过对应章节，或者先补充一下技术知识，然后再来看对应的课程。开发实用篇具体包含的内容如下：
热部署配置高级测试数据层解决方案整合第三方技术监控 ​ 看目录感觉内容量并不是很大，但是在数据层解决方案和整合第三方技术中包含了大量的知识，一点一点慢慢学吧。下面开启第一部分热部署相关知识的学习
KF-1.热部署 ​ 什么是热部署？简单说就是你程序改了，现在要重新启动服务器，嫌麻烦？不用重启，服务器会自己悄悄的把更新后的程序给重新加载一遍，这就是热部署。
​ 热部署的功能是如何实现的呢？这就要分两种情况来说了，非springboot工程和springboot工程的热部署实现方式完全不一样。先说一下原始的非springboot项目是如何实现热部署的。
非springboot项目热部署实现原理
​ 开发非springboot项目时，我们要制作一个web工程并通过tomcat启动，通常需要先安装tomcat服务器到磁盘中，开发的程序配置发布到安装的tomcat服务器上。如果想实现热部署的效果，这种情况其实有两种做法，一种是在tomcat服务器的配置文件中进行配置，这种做法与你使用什么IDE工具无关，不管你使用eclipse还是idea都行。还有一种做法是通过IDE工具进行配置，比如在idea工具中进行设置，这种形式需要依赖IDE工具，每款IDE工具不同，对应的配置也不太一样。但是核心思想是一样的，就是使用服务器去监控其中加载的应用，发现产生了变化就重新加载一次。
​ 上面所说的非springboot项目实现热部署看上去是一个非常简单的过程，几乎每个小伙伴都能自己写出来。如果你不会写，我给你个最简单的思路，但是实际设计要比这复杂一些。例如启动一个定时任务，任务启动时记录每个文件的大小，以后每5秒比对一下每个文件的大小是否有改变，或者是否有新文件。如果没有改变，放行，如果有改变，刷新当前记录的文件信息，然后重新启动服务器，这就可以实现热部署了。当然，这个过程肯定不能这么做，比如我把一个打印输出的字符串"abc"改成"cba"，比对大小是没有变化的，但是内容缺实变了，所以这么做肯定不行，只是给大家打个比方，而且重启服务器这就是冷启动了，不能算热部署，领会精神吧。
​ 看上去这个过程也没多复杂，在springboot项目中难道还有其他的弯弯绕吗？还真有。
springboot项目热部署实现原理
​ 基于springboot开发的web工程其实有一个显著的特征，就是tomcat服务器内置了，还记得内嵌服务器吗？服务器是以一个对象的形式在spring容器中运行的。本来我们期望于tomcat服务器加载程序后由tomcat服务器盯着程序，你变化后我就重新启动重新加载，但是现在tomcat和我们的程序是平级的了，都是spring容器中的组件，这下就麻烦了，缺乏了一个直接的管理权，那该怎么做呢？简单，再搞一个程序X在spring容器中盯着你原始开发的程序A不就行了吗？确实，搞一个盯着程序A的程序X就行了，如果你自己开发的程序A变化了，那么程序X就命令tomcat容器重新加载程序A就OK了。并且这样做有一个好处，spring容器中东西不用全部重新加载一遍，只需要重新加载你开发的程序那一部分就可以了，这下效率又高了，挺好。
​ 下面就说说，怎么搞出来这么一个程序X，肯定不是我们自己手写了，springboot早就做好了，搞一个坐标导入进去就行了。
KF-1-1.手动启动热部署 步骤①：导入开发者工具对应的坐标
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 步骤②：构建项目，可以使用快捷键激活此功能
​ 对应的快捷键一定要记得
&lt;CTR&gt;L+&lt;F9&gt; ​ 以上过程就实现了springboot工程的热部署，是不是挺简单的。不过这里需要把底层的工作工程给普及一下。
重启与重载
​ 一个springboot项目在运行时实际上是分两个过程进行的，根据加载的东西不同，划分成base类加载器与restart类加载器。
base类加载器：用来加载jar包中的类，jar包中的类和配置文件由于不会发生变化，因此不管加载多少次，加载的内容不会发生变化restart类加载器：用来加载开发者自己开发的类、配置文件、页面等信息，这一类文件受开发者影响 ​ 当springboot项目启动时，base类加载器执行，加载jar包中的信息后，restart类加载器执行，加载开发者制作的内容。当执行构建项目后，由于jar中的信息不会变化，因此base类加载器无需再次执行，所以仅仅运行restart类加载即可，也就是将开发者自己制作的内容重新加载就行了，这就完成了一次热部署的过程，也可以说热部署的过程实际上是重新加载restart类加载器中的信息。
总结
使用开发者工具可以为当前项目开启热部署功能使用构建项目操作对工程进行热部署 思考
​ 上述过程每次进行热部署都需要开发者手工操作，不管是点击按钮还是快捷键都需要开发者手工执行。这种操作的应用场景主要是在开发调试期，并且调试的代码处于不同的文件中，比如服务器启动了，我需要改4个文件中的内容，然后重启，等4个文件都改完了再执行热部署，使用一个快捷键就OK了。但是如果现在开发者要修改的内容就只有一个文件中的少量代码，这个时候代码修改完毕如果能够让程序自己执行热部署功能，就可以减少开发者的操作，也就是自动进行热部署，能这么做吗？是可以的。咱们下一节再说。
​
KF-1-2.自动启动热部署 ​ 自动热部署其实就是设计一个开关，打开这个开关后，IDE工具就可以自动热部署。因此这个操作和IDE工具有关，以下以idea为例设置idea中启动热部署
步骤①：设置自动构建项目
​ 打开【File】，选择【settings…】,在面板左侧的菜单中找到【Compile】选项，然后勾选【Build project automatically】，意思是自动构建项目
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/506aa695a633d1c92ed880415199090a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/852e07429d31bbd6e1e46be5aa2bff2b/" rel="bookmark">
			SU-03T语音识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		语音识别的由SU-03T、咪头、喇叭、还有一个CH340串口组成。SU-03T不需要代码的写入，直接可以进行配置就可以使用，极大降低了开发难度。 为客户提供超低成本的离线语 音识别方案，可广泛且快速应用于智能家居，各类智能小家电，86 盒，玩 具，灯具等需要语音操控的产品。 该芯片采用 32bit RSIC 架构内核，并加 入了专门针对信号处理和语音识别所需要的 DSP 指令集，支持浮点运算的FPU 运算单元，以及 FFT 加速器。该方案支持 150 条本地指令离线识别， 支持 RTOS 轻量级系统，具有丰富的外围接口，以及简单友好的客制化工具。
接线方式：B7引脚==CH340的RX引脚 B6引脚==CH340的TX引脚
VCC引脚==CH340的5V引脚 GND引脚==CH340的GND
喇叭红色线==SPK+ 喇叭的黑色线==SPK-
咪头红色线==MIC+ 咪头黑色线==MIC-
这是基础的接线，其他的引脚根据你的需求来制定，例如是A25作为高低电平的输出，用于点亮LED灯或者接入stm32IO口读取引脚高低电平而发生功能的改变。
一、百度搜索智能公元或点击网址智能公元/AI产品零代码平台、进行注册并完成配置。
1.点击创建产品
2.任意选择一个即可
3.选择纯离线方案
4.选择模组，选择SU-03T的文字处
5.自已给产品起个名字，语言选择中文，再点击下一步。
6.这里可以选择选择远场，实测在1m以内也可以识别，稳态降噪可以去除一些杂音提高识别能力
7.这里的引脚不是看pin No.的，是看功能列的GPIO才是SU-03T的引脚，可以进行更改
8.更改GPIO_B6为UART1_RX,,B7为TX,GPIO_B3为PWM4，这样SU-03T的B6和B7引脚就可以实现串口通信了，而B3就是PWM模式。
9.这里可以默认，也可以根据你自已喜欢来修改语音内容 10.这里的命令词和回复语也是根据自已喜欢更改
11.点击10处的控制详细-添加控制，这里一定要设定，要不然语音模块无法正常使用
12.剩下的默认或者根据自已的喜爱来设定语音内容，还需要点击右上角的保存，检查无误后再发布版本，为你的设备添加描述。等待生成，生成好了后也会发短信通知。
二、固件下载
1.生成固件后点击下载固件
2.下载完后会有个gz类型的文件，把它放到一个无中文路径的文件夹里，将其解压会生成一个tar类型的文件，再对其解压生成带有bin的文件
3.买模块时问客服要资料，这些资料一般也挺齐全的，找到这个exe文件
4.选择好第2步骤的bin文件，一定是要update.bin的,再点击烧录，其间要拔掉SU-03T模块的电源再重新接上，不行的可重复多几次。
成功烧录后就可以使用语音模块啦，注意一点是使用语音模块时要唤醒它才可以进行其他的控制命令！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd782053342d0f84f8220e0462f2842d/" rel="bookmark">
			springboot最全，最完整，最适合小白教程（基础篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文章为黑马的springboot教程的教学文档，具体视频内容移步至bilibili 黑马程序员官方账号
教程分为基础篇，运维实用篇，开发实用篇，原理篇
基础篇：springboot 基础篇
运维实用篇 ：springboot 运维实用篇
开发实用篇：springboot 开发实用篇
原理篇：springboot 原理篇
SpringBoot 文档更新日志 版本更新日期操作描述v1.02021/11/14A基础篇v1.0.12021/11/30U更新基础篇错别字若干，不涉及内容变更v2.02021/12/01A运维实用篇V3.02022/2/21A开发实用篇V4.02022/3/29A原理篇 前言 ​ 很荣幸有机会能以这样的形式和互联网上的各位小伙伴一起学习交流技术课程，这次给大家带来的是Spring家族中比较重要的一门技术课程——SpringBoot。一句话介绍这个技术，应该怎么说呢？现在如果开发Spring程序不用SpringBoot那就是给自己过不去，SpringBoot为我们开发Spring程序提供了太多的帮助，在此借这个机会给大家分享这门课程，希望各位小伙伴学有所得，学有所用，学有所成。
​ 正如上面提到的，这门技术是用来加速开发Spring程序的，因此学习这门技术是有一定的门槛的。你可以理解为你现在是一门传统的手工艺人，现在工艺升级，可以加速你的生产制作过程，但是前提是你要会原始工艺，然后才能学习新的工艺。嗯，怎么说呢？有一定的门槛，至少Spring怎么回事，与Spring配合在一起工作的一堆技术又是怎么回事，这些搞明白才能来看这个技术，不然就只能学个皮毛，或者学着学着就开始因为其他技术不太过关，然后就学不下去了，然后，就没有然后了，果断弃坑了。不管怎么说，既来之则安之，加油学习吧，投资自己肯定是没毛病的。
课程内容说明 ​ SpringBoot这门技术课程所包含的技术点其实并不是很多，但是围绕着SpringBoot的周边知识，也就是SpringBoot整合其他技术，这样的知识量很大，例如SpringBoot整合MyBatis等等。因此为了能够将本课程制作的能够适应于各个层面的学习者进行学习，本套课程会针对小白，初学者，开发者三种不同的人群来设计全套课程。具体这三种人群如何划分，就按照我的描述形式来分吧，各位小伙伴可以对号入座，每种人群看课程的起始位置略有差别。
学习者归类方式小白完全没有用过SpringBoot技术初学者能使用SpringBoot技术完成基础的SSM整合开发者能使用SpringBoot技术实现常见的技术整合工作 ​ 简单说就是你能用SpringBoot做多少东西，一点不会就是小白，会一点就是初学者，大部分都会就是开发者。其实这个划分也不用过于纠结，这个划分仅仅是为了帮助你对本技术课程所包含的阶段模块划分做一个清晰认知，因为本课程中会将SpringBoot技术划分成4个单元，每个单元是针对不同的学习者准备的。
学习者课程单元小白基础篇初学者应用篇（ 运维实用篇 &amp; 开发实用篇 ）开发者原理篇 ​ 看完这个划分你就应该有这么个概念，我没有用过SpringBoot技术，所以从基础篇开始学习；或者我会一点SpringBoot技术，那我从实用篇开始学就好了，就是这个意思。
​ 每个课程单元内容设置不同，目标也不一样，作为学习者如果想达成最佳的学习效果，最好明确自己的学习目标再进行学习，这样目标明确，学习的时候能够更轻松，你就不会在学习的时候纠结如下的问题了。比如学着基础篇在那想，这个东西是个什么原理啊？这个东西是这么用的，那个东西该怎么用啊？因为原理性的内容统一放置到了原理篇讲解了，应用相关的内容统一放到应用篇里面讲解，你在基础篇阶段纠结也没有用，这一部分不讲这些知识，在基础篇先把SpringBoot的基础使用掌握完再说后面的知识吧。
​ 此外还有一点需要说明的是，目前SpringBoot技术发展速度很快，更新速度也很快，因此后续还会对本套课程进行持续更新，特此在三个课程单元的基础上追加一个番外篇。番外篇的设置为了解决如下问题：
持续更新SpringBoot后续发展出现的新技术讲解部分知识点规模较大的支线知识（例如WebFlux）扩展非实用性知识，扩展学习者视野 ​ 每一个课程单元的学习目标如下，请各位查收，在学习的过程中可以阶段性的给自己提个问题，下面列出来的这些学习目标你是否达成了，可以检验你的学习成果。
课程单元学习目标基础篇能够创建SpringBoot工程
基于SpringBoot实现ssm/ssmp整合应用篇能够掌握SpringBoot程序多环境开发
能够基于Linux系统发布SpringBoot工程
能够解决线上灵活配置SpringBoot工程的需求
能够基于SpringBoot整合任意第三方技术原理篇掌握SpringBoot内部工作流程
理解SpringBoot整合第三方技术的原理
实现自定义开发整合第三方技术的组件番外篇掌握SpringBoot整合非常见的第三方技术
掌握相同领域的更多的解决方案，并提升同领域方案设计能力 ​ 整体课程包含的内容就是这些啦，要想完成前面这些内容的学习，顺利的达成学习目标，有些东西还是要提前和大家说清楚的。SpringBoot课程不像是Java基础，不管你有没有基础，都可以听一听，这个课程还真不行，需要一定的前置知识。下面给大家列表一些前置知识，如果还有不太会的，需要想办法快速补救一下。
课程前置知识说明 课程单元前置知识要求基础篇Java基础语法面向对象，封装，继承，多态，类与接口，集合，IO，网络编程等基础篇Spring与SpringMVC知道Spring是用来管理bean，能够基于Restful实现页面请求交互功能基础篇Mybatis与Mybatis-Plus基于Mybatis和MybatisPlus能够开发出包含基础CRUD功能的标准Dao模块基础篇数据库MySQL能够读懂基础CRUD功能的SQL语句基础篇服务器知道服务器与web工程的关系，熟悉web服务器的基础配置基础篇maven知道maven的依赖关系，知道什么是依赖范围，依赖传递，排除依赖，可选依赖，继承基础篇web技术（含vue，ElementUI)知道vue如何发送ajax请求，如何获取响应数据，如何进行数据模型双向绑定应用篇Linux（CenterOS7）熟悉常用的Linux基础指令，熟悉Linux系统目录结构应用篇实用开发技术缓存：Redis、MongoDB、……
消息中间件:RocketMq、RabbitMq、……原理篇Spring了解Spring加载bean的各种方式
知道Spring容器底层工作原理，能够阅读简单的Spring底层源码 ​ 看着略微有点多，其实还好吧，如果个别技术真的不会，在学习课程的时候多用心听就好，基础篇是可以跟着学下来了，后面的实用篇和原理篇就比较难了。比如我要在Linux系统下操作，命令我就直接使用了，然后你看不懂可能学习起来就比较心累了。
​ 课程安排就说到这里了，下面进入到SpringBoot基础篇的学习
SpringBoot基础篇 ​ 在基础篇中，我给学习者的定位是先上手，能够使用SpringBoot搭建基于SpringBoot的web项目开发，所以内容设置较少，主要包含如下内容：
SpringBoot快速入门SpringBoot基础配置基于SpringBoot整合SSMP JC-1.快速上手SpringBoot ​ 学习任意一项技术，首先要知道这个技术的作用是什么，不然学完以后，你都不知道什么时候使用这个技术，也就是技术对应的应用场景。SpringBoot技术由Pivotal团队研发制作，功能的话简单概括就是加速Spring程序的开发，这个加速要从如下两个方面来说
Spring程序初始搭建过程Spring程序的开发过程 ​ 通过上面两个方面的定位，我们可以产生两个模糊的概念：
SpringBoot开发团队认为原始的Spring程序初始搭建的时候可能有些繁琐，这个过程是可以简化的，那原始的Spring程序初始搭建过程都包含哪些东西了呢？为什么觉得繁琐呢？最基本的Spring程序至少有一个配置文件或配置类，用来描述Spring的配置信息，莫非这个文件都可以不写？此外现在企业级开发使用Spring大部分情况下是做web开发，如果做web开发的话，还要在加载web环境时加载时加载指定的spring配置，这都是最基本的需求了，不写的话怎么知道加载哪个配置文件/配置类呢？那换了SpringBoot技术以后呢，这些还要写吗？谜底稍后揭晓，先卖个关子SpringBoot开发团队认为原始的Spring程序开发的过程也有些繁琐，这个过程仍然可以简化。开发过程无外乎使用什么技术，导入对应的jar包（或坐标）然后将这个技术的核心对象交给Spring容器管理，也就是配置成Spring容器管控的bean就可以了。这都是基本操作啊，难道这些东西SpringBoot也能帮我们简化？ ​ 带着上面这些疑问我们就着手第一个SpringBoot程序的开发了，看看到底使用SpringBoot技术能简化开发到什么程度。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd782053342d0f84f8220e0462f2842d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe87753e29065dce7cb910085af62906/" rel="bookmark">
			搜维尔科技：scalefit-工业运动员职业安全与健康的新途径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		健康工作的生物力学
健康保险公司的年度报告显示:体力劳动引起的肌肉骨骼疾病是旷工的主要原因。重负荷、高重复率或强迫姿势会导致长期疾病和不可逆转的磨损。其后果是工作表现下降、工作天数减少、职业病和人才流失。
我 们的目标是您的利益-通过生物力学和人体工程学可持续预防与工作相关的肌肉骨骼疾病。移动人体工程学实验室 INDUSTRIAL ATHLETE 为公司和员工提供了决定性的优势:
•现场和实时工作场所分析
•根据国际标准进行人体工程学评估
•负荷监测和活体生物反馈
对于职业健康管理的提供者和顾问来说，使用我们的科学方法在内容和经济方面提供了新的可能性:
•有意义的人体工程学和负荷报告
•减少损失天数，提高竞争力
•可盈利的服务扩展
我们的概念于 2016 年根据 DIN SPEC 91020 进行了评估，并与康明斯、美纳里尼或Chempark Dormagen 等工业合作伙伴成功地在工作场所健康促进中实施。
我们的团队由生物力学、职业科学家和 IT专家组成，他们在身体压力和应变、人机交互和与工作相关的肌肉骨骼疾病领域拥有丰富的专业知识。
scalefit 是跨学科网络的一部分，在德国科隆体育大学和德国社会意外保险 osh 研究所拥有多年的经验。我们为公司和研究所(如弗劳恩霍夫)提供科学能力和最先进的检查方法。我们的服务具有高灵活性、短处理时间和良好的性价比。
活动范围
•人体工程学分析
•物理风险评估
•符合人体工程学的工作场所设计
•预防肌肉骨骼疾病
现代测量方法
•IMU 动作捕捉
•工作场所的 3D 负载分析
•High-speed-Video
工业运动员职业安全与健康的新途径
在实时和真实的工作条件下，工业运动员生物力学测量系统分析每个身体区域的肌肉骨骼负荷，并根据职业和生物力学标准对其进行评估。由 IMU 传感器确定的力和力矩以图形动画形式显示，并分配给所执行的活动。这可以检测峰值负荷，减少肌肉骨骼应力并评估辅助设备的有效性。
通过自动结果报告，工业运动员能够快速而有意义的风险评估和符合人体工程学的工作场所设计，而不需要耗时的程序和人力资源。因此，工业运动员通过有针对性的措施为职业安全和健康提供最佳支持:
•预防与工作相关的肌肉骨骼疾病
•符合人体工程学的工作场所设计
•健康工作的可持续意识
工业运动员用于工作场所检查 (例如负荷操纵，强迫或重复活动)，行为预防，以及培训，健康日或预防性保健计划。我们的客户包括工业和咨询公司、WHM 供应商、大学和研究机构。在这里，该系统解释了身体劳损和肌肉骨骼疾病之间的关系，或作为健康研究的定性和定量方法。
我们支持您的努力
今天为员工的健康投资的公司，明天将从增加的吸引力、改善的业绩和可持续的竞争力中受益。我们用最先进的方法和科学的专业知识为您提供支持。
关于搜维尔科技
2023年5月搜维尔正式与人体工程学分析软件供应商scalefit签署代理合作协议，成为其在中国大陆地区的授权代理商。搜维尔现支持scalefit相关产品购买与咨询服务，欢迎致电咨询。
搜维尔科技有限公司专注于提供专业有效的3D/VR虚拟现实解决方案。搜维尔十分注重产品质量与客户满意度，我们不断投入精力和成本引进国际先进技术和设备，以充分满足中国大陆地区客户需求。多年间累积的经验帮助搜维尔赢得了许多客户的信任，并收获到大量用户的好评和认可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/405b5e8eb287022ef0227fd6694c72d4/" rel="bookmark">
			velero和minio实现k8s数据的备份和恢复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概述: Velero（以前称为 Heptio Ark）为您提供了备份和恢复 Kubernetes 集群资源和持久卷的工具，可以安全的备份、恢复和迁移Kubernetes集群资源和持久卷。
Velero主要提供以下能力
备份群集并在丢失时进行还原。 将群集资源迁移到其他群集。 将生产群集复制到开发和测试群集。 Velero 支持备份存储
Azure BloB 存储 Google Cloud 存储 AWS S3 及兼容S3 的存储（比如：MinIO） Aliyun OSS 存储 velero和etcd快照备份的区别：
etcd快照备份是全局备份，即使一个资源对象需要恢复也需要做全局恢复到备份状态及会影响其他的pod和其他namespace的资源
velero可以有针对性的备份，比如按照namespace单独备份、只备份单独资源对象等，在恢复的时候只恢复单独的namespace或资源对象，不影响其他namespace中pod的运行
velero支持ceph，oss等对象存储，etcd快照是一个本地文件
velero支持任务计划实现周期备份，但etcd快照备份也可以基于cronjob实现
velero存储方式:
Restic方式备份
Restic 是一款 GO 语言开发的开源免费且快速、高效和安全的跨平台备份工具。它是文件系统级别备份持久卷数据并将其发送到 Velero 的对象存储。执行速度取决于本地IO能力，网络带宽和对象存储性能，相对快照方式备份慢。 但如果当前集群或者存储出现问题，由于所有资源和数据都存储在远端的对象存储上， 用Restic方式备份可以很容易的将应用恢复。 Tips： 使用 Restic 来对 PV 进行备份会有一些限制：
不支持备份 hostPath，支持EFS、AzureFile、NFS、emptyDir、local 或其他没有本地快照概念的卷类型 备份数据标志只能通过 Pod 来识别 单线程操作大量文件比较慢 快照方式备份
Velero使用一组 BackupItemAction 插件针对 PersistentVolumeClaims 进行备份，执行速度快。它创建一个以 PersistentVolumeClaim 作为源的 VolumeSnapshot 对象， 此 VolumeSnapshot 对象与用作源的 PersistentVolumeClaim 位于同一命名空间中，与VolumeSnapshot对应的 VolumeSnapshotContent 对象是一个集群范围的资源，将指向存储系统中基于磁盘的实际快照。Velero 备份时将所有 VolumeSnapshots 和 VolumeSnapshotContents 对象上传到对象存储系统， 但是Velero 备份后的数据资源仍然保存在集群的存储上。数据可用性依赖于本地存储的高可用性，因为如果是由于存储故障导致的应用问题，Velero的快照备份机制并不能恢复应用数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/405b5e8eb287022ef0227fd6694c72d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5723d56f3c80451be633b329a3c7d060/" rel="bookmark">
			阿里云OSS对象存储上传文件（二）C&#43;&#43;上传（含代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为实际项目需求，需要使用阿里云oss的对象存储来上传文件。本篇将讲述个人代码使用上的经验，不代表适用所有人，仅供参考。
代码尝试前，请先确保SDK安装和lib文件编译等预备工作，详细可查看上一篇文章：
阿里云OSS对象存储上传文件（一）SDK安装
环境是windows系统，vs2017+qt5.14（vs2015+qt5.6也尝试过，效果都一样）
官方示例代码：官方文档：C++上传文件
一、核心需求
简单查看官方文档后，会发现它具备了好几种上传方法，包括简单上传，追加上传，断点续传上传，分片上传，等。因为我的项目核心需求是同时上传单个文件，所以过程中尝试了简单上传和分片上传，其他未做尝试，有兴趣可自行实现。
另一要求则是过程中需要给出进度条的ui提示，这需要获取oss的进度条反馈信息，这部分sdk也是有实现的。
以下先简单讲述以下简单上传和分片上传的优缺点。
（1）简单上传
即直接单次提交整个文件，只要不超过5GB即可。这种方法步骤比较简单，但同时没有办法实现中途中断功能（有人实现了可在评论区告知），并可能因为文件过大，而导致上传过程阻塞过久，往往可能一两分钟，又没办法停止，体验一般。
（2）分片上传
即把文件分成若干片段，分别上传。这种适合大文件的上传，最大不超过48.8TB。当然，几十MB大小的文件也同样可以上传，这个都没有问题。相较于简单上传，分片上传的灵活性显然提高了许多。如果想要实现停止上传，只要完成当前分片的上传把并退出上传循环即可。因为没有到最终的整合分片环节，所以云上的文件并不会最终生成（有没有缓存文件不知道）。
特别说明：
（1）值得一提的是，官方示例中的分片大小是100k，这会造成分片数量太过庞大，导致循环上传中各种初始化资源大量重复。比如上传一个100M的视频文件，用简单上传来整个文件上传，以及使用分片上传，按照100k分片，循环上传1000次，耗时上是有显著增加的。经过尝试，我认为控制在1M的分片会比较恰当，网络通畅的情况下几乎是瞬间上传完毕，不会造成明显的阻塞感。
（2）官方文档中有进度条回调的使用，但注意，不管是对简单上传还是分片上传，它的本质上都是对单次上传的进度条反抗，放在分片上传中，就是对单个切片的进度反馈，而不是一整个的。这在我实现分片上传中的进度条显示中遇到了困难。
a.初步的尝试，是利用切片的数量进行进度显示，即假如分片了100份，那当前上传到哪一片，自然就得到了当前的进度。当你知道的，切片不一定会超过100份，假如只有10份，那进度反馈将是跳跃式的，给人直观上不好。
b.最终的方案是，利用一开始对文件总大小的记录，以及当前上传切片编号，当前上传切片的进度反馈，自行实现数字累加，以达到真实的进度反馈。这部分比较繁琐，但也算是符合常理的。
OK，讲了这么多，接下来详细讲述以下代码。
二、简单上传
//进度条回调 void ProgressCallback(size_t increment, int64_t transfered, int64_t total, void* userData) { std::cout &lt;&lt; "ProgressCallback[" &lt;&lt; userData &lt;&lt; "] =&gt; " &lt;&lt; increment &lt;&lt;" ," &lt;&lt; transfered &lt;&lt; "," &lt;&lt; total &lt;&lt; std::endl; //alioosProgressCallback是我创建的全局回调对象，在这里间接地将进度信息发送到外部 alioosProgressCallback.send_ProgressCallback(transfered, total); } //简单上传 bool AliossUpload::PutObjectFromFile() { //根据自己实际情况，初始OSS账号信息 /* 初始化OSS账号信息 */ /* 如何获取AccessKeyId和AccessKeySecret: https://help.aliyun.com/knowledge_detail/48699.html */ std::string AccessKeyId = _AccessKeyId.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5723d56f3c80451be633b329a3c7d060/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac5eb760845487e1613ed88825434b22/" rel="bookmark">
			小猫爪：嵌入式小知识12 - ISO14229-1（UDS）简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小猫爪：嵌入式小知识12- ISO14229-1（UDS服务）简介 1 前言2 服务数据格式2.1 无子功能的格式2.2 有子功能的格式 3 物理寻址和功能寻址4 服务简介4.1 诊断会话控制(0x10)4.2 ECU复位(0x11)4.3 安全访问(0x27)4.4 读DID数据(0x22)4.5 写DID数据(0x2E)4.6 读取故障码(0x19)4.7 清除故障码(0x14)4.8 例程控制(0x31)4.9 控制输入输出(0x2F) END 1 前言 这一章来说说ISO14229-1(UDS服务)，在上一章介绍了ISO15765，提到了ISO15765-3中规定的UDS服务其实就是照搬的ISO14229-1，所谓UDS服务理解也是非常简单，就是两个角色进行数据交互，这两个角色分别是客户端和服务端，客户端首先向服务端发送服务请求，然后服务端根据服务类型进行回应。这里的客户端一般为诊断仪，而服务端则是车中的ECU模块了。
在这里不妨简单介绍一下ISO14229，ISO14229其实才是最完整的UDS协议规范，它不仅定义了UDS服务端，而且还定义了UDS在不同的硬件总线上的定义和要求，比如CAN，Ethernet，LIN等。ISO14229每个部分的内容如下所示：
UDS定义了几大类服务，分别是诊断和通信管理功能，数据传输功能，存储数据传输功能，输入输出控制功能，例行程序功能，上传下载功能，如下表所示：
2 服务数据格式 上面罗列了所有的诊断服务，种类很多，但是它们在数据组织上都遵循了一定的格式，这个格式理解起来很简单，前面多次提到了UDS其实是一种客户端请求，服务端响应的一种交互模式，这个请求和响应的格式是有一个定式，其中唯一的一个区别就是有无子功能，在服务表标明了每一个服务是否具有子功能。
2.1 无子功能的格式 请求的格式如下：
01 ~ n服务ID用户自定义数据 响应分为正响应和负响应两种，所谓正响应就是指服务端认为请求有效，回复正确响应，而负响应则是指服务端认为该响应无效，有问题，则返回错误代码。
正响应格式如下：
01 ~ n服务ID + 0x40用户自定义数据 负响应格式如下：
0127F服务IDNRC（错误码） 举个简单的没有子功能的请求响应例子，客户端想用22服务（ReadDataByIdentifier）向服务端请求读取地址0xF187的DID数据，其请求和响应如下：
请 求：22 F1 87
正响应：62 F1 87 xx xx xx xx
负响应：7F 22 7E
2.2 有子功能的格式 请求的格式如下：
012 ~ n服务ID子功能ID用户自定义数据 正响应格式如下：
012 ~ n服务ID + 0x40子功能ID用户自定义数据 负响应格式如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac5eb760845487e1613ed88825434b22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfb7f2982794b88181bcf16986126136/" rel="bookmark">
			vue2 引入高德地图API根据城市定位查询天气
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、高德地图API
二、使用步骤
1.引入
2.获取当前定位
3.获取城市的天气信息
总结
前言 本文基于在创作数据大屏时，需要实时显示当前定位的天气情况，因而引入高德地图API来实现天气的数据可视化。
参考文章 手把手教你Vue+ECharts+高德地图API实现天气预报数据可视化
效果图 一、高德地图API 使用高德地图API开发地图应用之前需要的一些准备工作。
先注册一个高德地图API开发者账号。注册成功后，登录账号，进入到控制台页面。在【应用管理】-【我的应用】创建新应用。 选择相应应用类型后新建应用 添加key 点击查看【安全密钥使用说明】 找到方式二，在项目中使用JS API的方法（JSAPI key搭配静态安全密钥以明文设置（不安全，建议开发环境用））
二、使用步骤 1.引入 在index.html文件引入地图 JSAPI 脚本。
引入地图 JSAPI 脚本之前增加设置 JSAPI 安全密钥的脚本标签，并将您的安全密钥【您申请的安全密钥】替换为您的安全密钥；（注意这个设置必须是在 JSAPI 的脚本加载之前进行设置，否则设置无效。）
【您申请的key】替换为申请到的key
&lt;script type="text/javascript"&gt; window._AMapSecurityConfig = { securityJsCode:'您申请的安全密钥', } &lt;/script&gt; &lt;script type="text/javascript" src="https://webapi.amap.com/maps?v=1.4.15&amp;key=您申请的key值"&gt;&lt;/script&gt; 除直接引入JSAPI 脚本之外，还可以点击查看更多JS API加载方式
2.获取当前定位 想要获取天气情况我们先要获得定位，这是需要用到高德地图API。在【开发支持】-【地图 JS API 2.0】-【进阶教程】-【服务插件和工具】-【定位】，找到IP定位获取当前城市信息的方法。
把获取城市定位的代码封装成getCityPosition方法，在mounted()调用该方法获取到当前城市信息。
getCityPosition（）{ AMap.plugin('AMap.CitySearch', function () { var citySearch = new AMap.CitySearch() citySearch.getLocalCity(function (status, result) { if (status === 'complete' &amp;&amp; result.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfb7f2982794b88181bcf16986126136/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39ab507ae94118c670397e2577385db1/" rel="bookmark">
			MyBatis 动态sql（新手版）详细
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.什么是mybatis动态sql
mybatis动态sql标签以及属性的作用
2.示例代码
1.&lt;if test=" "&gt;
2.&lt;choose&gt;
3.&lt;trim&gt;
4.&lt;foreach&gt;
5.&lt;set&gt;
6.&lt;where&gt;
3.Mybatis 动态sql 的好处
1.什么是mybatis动态sql MyBatis动态SQL是指在进行数据库操作时，根据不同的条件动态生成SQL语句的功能。传统的SQL语句是静态的，即固定不变的字符串。而使用动态SQL可以根据不同的条件来拼接生成不同的SQL语句，从而实现更加灵活和可复用的数据库访问。
动态SQL使得在不同的条件下执行不同的查询、插入、更新或删除操作变得非常方便。它能够避免因为大量的if-else语句导致代码冗长和维护困难的问题。
mybatis动态sql标签以及属性的作用 &lt;if test=" "&gt; 用于在SQL语句中添加条件判断test：指定条件表达式，用于判断是否执
行该if块内的SQL语句
&lt;choose&gt; 标签没有特定的属性，只需将&lt;when&gt;和&lt;otherwise&gt;标签作为其子标签使用，
&lt;choose&gt;标签的作用是在多个条件中选择符合条件的分支进行处理
&lt;trim&gt; 用于去除或添加SQL语句中的特定部分,
prefix：在生成的SQL语句前添加前缀。prefixOverrides：去除生成的SQL语句开头多余的内容。suffix：在生成的SQL语句后添加后缀。suffixOverrides：去除生成的SQL语句结尾多余的内容&lt;foreach&gt; 用于循环遍历集合，并将集合元素作为参数传递给SQL语句的占位符
collection：指定要遍历的集合或数组。item：指定当前遍历项的别名。index：指定当前遍历项的索引别名。open：指定生成的SQL语句的起始字符。separator：指定生成的SQL语句每个遍历项之间的分隔符。close：指定生成的SQL语句的结束字符。jdbcType：指定遍历项的JDBC类型。 &lt;set&gt; 标签的作用是生成UPDATE语句中的SET子句，并根据条件动态拼接需要
更新的字段和对应的值。它通常和&lt;if&gt;标签或其他动态SQL标签一起使用。
&lt;where&gt; 作用是生成SQL语句中的WHERE子句，并根据条件动态拼接查询条件。它通
常和&lt;if&gt;标签或其他动态SQL标签一起使用。
这些标签可以组合使用，以根据不同的条件生成不同的SQL语句,可以根据具体需求进行设置，以实现动态生成符合条件的SQL语句。通过灵活应用这些属性，可以使得SQL语句更加可读性高、可维护性强，并且适应不同的业务场景。
2.示例代码 &lt;if test=" "&gt; &lt;select id="getSupplierBysupCodesupName" parameterType="Supplier" resultType="Supplier"&gt; SELECT * FROM t_supplier WHERE 1=1 &lt;if test="supCode!= null"&gt; AND supCode= #{supCode} &lt;/if&gt; &lt;if test="supName!= null"&gt; AND supName= #{supName} &lt;/if&gt; &lt;/select&gt; 通过这样的配置，我们可以根据传入的参数动态生成符合条件的SQL语句。使用&lt;if&gt;标签时，需要注意将它放置在适当的位置，以确保生成的SQL语句的语法正确。在示例中，我们将&lt;if&gt;标签放在WHERE子句中，并使用1=1作为初始条件，这样可以确保WHERE子句始终以AND开头。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39ab507ae94118c670397e2577385db1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f841305392838e38c42e09a45268e904/" rel="bookmark">
			window.open和vue router新开页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 目录
系列文章目录
前言
一、window.open
二、vue-router
三、URLSearchParams
四、新页面接收参数
总结
前言 打开新页面，并实现在新开页面中携带参数，可以使用 URLSearchParams 对象，进行参数的拼接和解析，vue router跳转新页面和window.open都可以，几种方式适应于不同场景，URLSearchParams对象是结合window.open使用的。
一、window.open 使用 window.open() 可以在新窗口或新标签页中打开指定的 URL。
参数如下：
url（可选）：要在新窗口或新标签页中加载的页面的 URL。如果未提供此参数或为空字符串，则新窗口将打开一个空白页面。target（可选）：指定在哪里打开链接的目标窗口或标签页。常用的取值包括： _blank：在新标签页或新窗口中打开链接。_self：在当前窗口中打开链接（默认行为）。_parent：在父级窗口中打开链接。_top：在顶级窗口中打开链接。自定义窗口名称：如果已经存在具有相同名称的窗口，则在该窗口中加载链接，否则会打开一个新的窗口。windowFeatures（可选）：一个包含窗口特性的字符串（目前未在项目中使用过），用于指定新窗口的行为和外观。常用的特性包括： width：新窗口的宽度。height：新窗口的高度。left：新窗口的左侧位置。top：新窗口的顶部位置。scrollbars：是否显示滚动条。resizable：新窗口是否可调整大小。fullscreen：是否以全屏模式打开新窗口。等等。 示例：
//指定新窗口的名称、大小和其他选项window.open('https://www.example.com', '_blank', 'width=800, height=600'); // 在新标签页中打开指定 URL window.open('https://www.example.com'); // 在具有特定名称的窗口中打开链接（如果不存在，则打开新窗口） window.open('https://www.example.com', 'myWindow'); // 在指定大小的新窗口中打开链接 window.open('https://www.example.com', '_blank', 'width=800, height=600'); 注意：由于浏览器的安全限制，对于弹出窗口的行为，大多数浏览器会进行阻止或拦截。为了避免被浏览器拦截，打开新窗口的操作必须是由用户的明确操作触发，例如点击按钮，有些如在点击某个链接后，获取一些参数，再跳转到某个地址的行为，可以按照以下进行：
setTimeout(() =&gt; window.open(url, "_blank"))
浏览器为了避免弹出广告影响用户，禁用了通过代码调用超链接在新标签打开页面的功能，所以必须是用户的明确行为，点击，长按等操作之类的，但把打开链接的操作放到setTimeout里运行，因为setTimeout是在主线程运行的，所以该操作不会被浏览器认定为代码操作的，所以不会拦截。
二、vue-router 官网：Vue Router | Vue.js 的官方路由
这个比较常见，一般跳转页面携带参数常用两种，query，params
// 字符串路径 router.push('/users/eduardo') // 带有路径的对象 router.push({ path: '/users/eduardo' }) // 命名的路由，并加上参数，让路由建立 url router.push({ name: 'user', params: { username: 'eduardo' } }) // 带查询参数，结果是 /register?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f841305392838e38c42e09a45268e904/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1681f3aa5db6bde869cf22b463a888dc/" rel="bookmark">
			MySQL日期时间操作函数（挺全的）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、MySQL常用日期函数 1.1、获取时间 # 获取当前日期时间 select NOW(); # 2021-04-02 09:25:29 # 获取当前日期 SELECT CURDATE(); # 2021-04-02 # 获取当前时间 SELECT CURTIME(); # 09:26:10 # 对于时间2021-04-02 09:25:29，分别获取其年、月、日、时、分、秒 SELECT EXTRACT(YEAR FROM NOW()); # 2021 SELECT EXTRACT(MONTH FROM NOW()); # 4 SELECT EXTRACT(DAY FROM NOW()); # 2 SELECT EXTRACT(HOUR FROM NOW()); # 9 SELECT EXTRACT(MINUTE FROM NOW()); # 25 SELECT EXTRACT(SECOND FROM NOW()); # 29 # 或者从日期格式字符串中获取 SELECT EXTRACT(SECOND FROM '2021-04-02 10:37:14.123456'); # 14 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1681f3aa5db6bde869cf22b463a888dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff035c84c598a65e8afeca45b5a3797b/" rel="bookmark">
			PHP基础详解（全）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 PHP格式PHP函数介绍PHP基础语法PHP变量变量声明与初始化变量释放可变变量($$)变量类型bool类型int 整型float 浮点型string 字符串 PHP常量定义和使用预定义常量 PHP换行PHP算术运算符字符串运算符赋值运算符比较运算符逻辑运算符反引号@ php流程控制顺序执行分支执行 if语句switch 语句判断条件循环执行whiledo whileforbreakcontinueexitcontinueexit PHP格式 &lt;?php // PHP 的开始标记，表示从此标记开始，进入PHP模式 #内容 ?&gt; //PHP的结束标记，表示从开始标记到结束标记，之间的内容是PHP模式 说明：
​ 在PHP文件中，可以与HTML和JavaScript混编。
开始标记&lt;？php表示进入PHP模式，结束标记？&gt;，
标识退出PHP模式。
​ PHP模式之外的内容会被作为字符输出到浏览器中。
HTML或JavaScript对于PHP来说就是纯文本字符串。
PHP函数介绍 &lt;?php phpinfo(); // PHP 代码 ?&gt; 解释：
1.phpinfo是一个函数（功能），这个函数会显示一个当前电脑（服务器）的详细的PHP信息。
2、电脑是一个很笨的东西，需要我们人为的告诉他，代码写完了。我们用分号（；）来告诉他代码写完了。因此只要写完一段代码，就需要在后面加分号。
3、而前后两行的回车空行，是为了让代码更加好看，避免叠在一起，看着不舒服。其实中间有多少个回车空行都没有关系的，保证好看就行了。PHP的语法解释器（PHP最核心部分）不会处理这些空行的。
安全问题：如果是一个在线的网站能够看到phpinfo页面，说明存在敏感信息泄露漏洞，这个漏洞需要体现在后面的渗透测试报告中。
PHP基础语法 PHP变量 &lt;?php $iphone7 = 5880; #分号(;)代表一句PHP代码的结束 $iphone7plus = 6088; echo $iphone6 + $iphone7plus; //echo是在PHP里面最常用的一个输出、显示功能的命令 ?&gt; $叫作美元符，英文单词：dollar。PHP的变量必须以美元符开始。说明搞PHP有”钱”途。
变量的几个特点介绍：
1、必须要以 开始，如变量 ‘ x ‘ 必须要写成 ‘ 开 始 ，如变量`x`必须要写成` 开始，如变量‘x‘必须要写成‘x 2、变量名由字母、数字、下划线组成，并且首字母不能以数字开头，也不能包含空白字符、特殊字符等其他字符。 3、变量的名字区分大小写 4、变量不要用特殊符号、中文，_不算特殊符号 5、变量命名要有意义（别写xxx，aaa，ccc`）这种变量名
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff035c84c598a65e8afeca45b5a3797b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dee870c30d1cf35e2a08f0d4acb12b06/" rel="bookmark">
			运行go程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、在控制台窗口执行exe文件
2、在浏览器打开对应地址
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1951213696c0a860c356a1a4d8c8a00e/" rel="bookmark">
			vue 可拖拽可缩放 vue-draggable-resizable 组件常用总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		特征 没有依赖 使用可拖动，可调整大小或两者兼备定义用于调整大小的句柄限制大小和移动到父元素或自定义选择器将元素捕捉到自定义网格将拖动限制为垂直或水平轴保持纵横比启用触控功能使用自己的样式为句柄提供自己的样式 安装和基本用法 npm install --save vue-draggable-resizable 全局注册组件main.js中写入：
import Vue from 'vue' import VueDraggableResizable from 'vue-draggable-resizable' // 可选择导入默认样式
import ‘vue-draggable-resizable/dist/VueDraggableResizable.css’
Vue.component(‘vue-draggable-resizable’, VueDraggableResizable)
局部注册：在使用的组件里引用
import VueDraggableResizable from 'vue-draggable-resizable' import 'vue-draggable-resizable/dist/VueDraggableResizable.css' 常用属性总结 :w 默认宽度 :h 默认高度 :x="50" 默认水平坐标 注意相对元素是谁 :y="50" 默认垂直最表 注意相对元素是谁 :min-width="50" 最小宽度 :min-height="50" 最小高度 :parent="true" 限制不能拖出父元素 parent=".p-event" 限制不能拖出class为p-event的元素 :grid 水平和垂直移动 每次分别能够走多少像素 class-name 自定义组件class 下面定义一个dragging1 常用事件总结 事件简述 文档（可点击直接进入）中ctrl+f 搜索 “事件” 查看详细事件参数 本demo举例的不一一阐述 @dragging="onDrag" 每当拖动组件时调用。 @resizing="onResize" 每当组件调整大小时调用。 本demo没用到的 可能会用到的
@dragstop=“onDragstop” 每当组件停止拖动时调用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1951213696c0a860c356a1a4d8c8a00e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55cf82d88d1ab48c3991328a5c35676d/" rel="bookmark">
			javaweb、spring、springmvc和springboot有什么区别，都是做什么用的？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先不说Spring那一坨，咋们先来说说JavaWeb。看样子能刷到这个问题的都不是什么JavaWeb的熟手，但是至少Java基础是熟手吧？那么就仔细说说。
JavaWeb，顾名思义就是用Java来做Web程序。那啥又是Web程序呢？那顾名思义就是运行在Web上面的程序。
那Web程序是啥我就不用再解释了吧？复制百度的解释：
“Web应用程序是一种可以通过Web访问的应用程序，程序的最大好处是用户很容易访问应用程序，用户只需要有浏览器即可，不需要再安装其他软件。”
那不就是相当于用浏览器可以访问的程序就是Web程序吗，那Javaweb就是，用Java写出来的一个可以通过浏览器来访问的程序，这就是Java web。
一边是在浏览器上，这就是客户端，Browser；一边是Java写的程序，也就是服务端，Server。
这种模式也就被叫做BS模式【Browser/Server】，当然，除了BS模式以外，还有CS模式，也就是Client/Server，这种是啥呢，就类似于QQ那种，需要安装在你电脑【或者物理机】上的软件，然后对应一个服务器，这就是CS模式。不过呢，JavaWeb搞出来的玩意儿，一般都是BS模式的应用，相当于有一个可以联网的环境，加一个浏览器就可以使用了。
其实一切的技术路线，都离不开历史的发展 一、JDBC是啥？ 我们就来了解一下Java web这段历史是怎么发展过来的吧。那么我们现在学习JavaWeb，接触的一定就是Servlet+JSP + JDBC技术了。
JDBC还好说，Java Database Connectivity，就是一个用Java语言去访问数据库的技术。不会用兄弟连数据库是啥都不知道吧，不知道那该去补一补数据库的课了。
我们平时用的SQLYog，Navicat，Dbeaver那些可不是数据库，那些只是连接到数据库用的第三方软件。数据库其实核心也是一个Server，也叫数据库引擎。
我们平时操作数据库引擎都是用上面说的那些第三方软件，在可视化的界面上手动操作。而JDBC就是，我们需要用Java语言，用编程的方式来连接数据库的引擎。
注意哈，JDBC不是用Java去链接SQLyog，Navicat这些三方可视化客户端，而是用Java去连接类似MySQL服务器，Oracle服务器，SQL Server服务器，Click House服务器，DB2服务器…等等这种。这里稍微解释一下，免得有兄弟搞混了。
毕竟网站运行，后台的服务端是Java程序写的，Java程序运行在JVM上，JVM是基于内存运行的，只要内存一释放，数据就没了。所以某些重要或者关键的数据【就比如用户的账号密码之类，对吧？】需要转移到硬盘上存储，那么数据库就是干这个的。所以访问数据库进行数据保存，在专业和高逼格的角度上又叫数据持久化。JDBC就是通过Java去连接数据库引擎，来实现Java操作数据库的一种技术。
当然，数据库引擎不只是做数据的持久化保存，还可以对于数据库的数据进行增删改查。这点学过数据库的兄弟们都知道的吧？不会还有兄弟不知道增删改查吧？在以后我们一般简称CRUD，也就是增删改查，这里简单提一下。至于为啥要叫CRUD？答主英语不好，不知道，但是别人前辈都是这样叫的，那就这样叫吧。
**二、**Servlet和JSP是啥呢？ Servlet其实就是Service Applet的简写，翻译过来就是服务端小程序。JSP就是Java Server Pages，Java服务端页面。
那这三个玩意儿怎么完成一个JavaWeb程序的呢？其实我们想想就大概知道了：
用户至少不可能在服务器上写代码吧，用户肯定是在浏览器上的网页里面各种点。那么用户在浏览器上的点击部分就会被转化为对于后端服务器的请求。Servlet就是来接受浏览器发过来的请求，这也是他身为服务端小程序的职责所在。然后他通过一系列业务逻辑的处理【业务逻辑这个就不确定了，不同系统有不同业务，对吧？】，比如有时候还需要去本地数据库查询数据，那么这就会用到JDBC技术。然后Servlet最后把解析完成的视图界面【HTML页面】返回给前端浏览器，然后浏览器显示给用户看，这就是JSP。
那这时候有些靓仔就要问了，那你既然是HTML页面，那为啥不直接给浏览器运行呢？为啥还非要Java服务器，把解析好的HTML返回给浏览器显示呢？因为有些页面的数据是需要服务器这边动态渲染的。就比如，一个展示所有用户列表的页面，那些用户数据是写死的吗？那肯定不是啊，那肯定是要根据后端从数据库中查询出来的结果来动态渲染的啊，所以这就是为什么HTML页面也一定要经过后端渲染以后，然后返回给浏览器显示。
所以当时JSP，就是HTML + Java代码混着写的方式，让页面在后端被解析，里面的Java代码被数据动态渲染完成以后，成为浏览器能看懂的纯HTML以后，再通过服务器发送给浏览器显示。这样的方式，使得前后端人员联手开发，效率非常非常的低。后端如果对于JSP里面HTML的样式有意见了，自己改不来，还得让前端小伙伴来看。前端要改JSP呢，里面还耦合着一堆Java代码，前端小伙伴也看不懂，稍有不慎就会让页面中的Java代码报错，错误信息前端小伙伴还看不懂，双方都是一肚子苦水。
所以最早最开始的时候，JavaWeb的开发，所有压力都在服务器这边，不管是JDBC的数据库查询，Servlet的请求接受，还是JSP页面在服务器的动态渲染，对于服务器压力很大。对开发人员的精神攻击也很大。
当时搞开发的后端程序员，不会点前端知识是没法做的，比如session cookie，html+css+javascript+bootstrap【一些前端组件库】，ajax异步请求等等，在那个时候，前后端协同开发效率很低，前端不懂点Java也没法写，后端不懂点前端也没法搞。
服务器又要承担接受请求，又要承担查询数据库的业务逻辑的处理，还要承担把页面渲染好返回的压力，几乎老一代的项目压力全部在后台服务器，如果代码还不进行规范的话就会看着非常混乱，难以维护，也难以扩展，这种代码被叫做屎山。所以网上经常有梗，新手你别动！这个系统就是依靠那个bug跑起来的，你一旦自作主张的优化bug，系统就崩了。
于是在这种情况下，老一辈的程序员们急需一种规范，来规范服务器端的代码。
三、MVC的来历 于是，顺着老一辈猴子们的期望和要求，MVC思想就出来了。MVC设计思想希望程序员对于服务器层面的逻辑进行分层管理，分为Model【这一层主要负责处理业务，包括数据库的交互】，Controller【这一层主要负责接收请求，然后根据不同情况把请求转发给不同的Model层业务组件处理】，View【这一层就专门负责处理视图在后端服务器的渲染】。
所以MVC这种思想【注意，MVC不是一个具体的技术哈，它只是一种指导思想】，也就在那时候流行起来了。所以基于MVC的Servlet + JSP + JDBC + 一些前端知识就构成当时Java web的主要学习路线了。
这时候的MVC就相当于是：
Servlet充当MVC里面的C【Controller】，接受请求JDBC和一些业务类作为MVC里面的M【Model】，用来处理业务逻辑JSP作为MVC里面的V【View】，视图层界面，由后端把数据动态渲染上去以后返回给浏览器前端显示 当然，JavaWeb肯定不止这三个技术，我说的是个大概，比如Web开发三大组件：Servlet Filter Lisenter等等，这个对于目前的刚入门的程序员来说，本人觉得了解就好了，不用太过精通。【就是说没必要用这些技术去做一个完整的项目，只要知道这些技术，会单独用即可】。毕竟现在也不是以前那个时代了。
四、Spring开始统一JavaWeb开发时代的开端： 前面说那么一堆，但这又和Spring有啥关系呢？
这咋们就得说说Java这语言的特性了。
JavaWeb是Java语言开发的对吧。
Java是啥语言？学过都知道，OOP的呗，面向对象为核心原理的语言。
其实不管再怎么复杂，啥封装继承多态，集合泛型反射，然后又是啥JVM JUC并发啥的，还有后面Java一大堆花里胡哨的框架和生态圈。
但是本质呢？其实离不开对象。Java这门语言的开发，就是我们程序员在不断的封装对象，使用对象，管理对象，维护对象之间的关系，来达到我们最终目的的一个过程。
所以回到我们的JavaWeb开发，老一辈做着做着就感觉还是很乱。明明是一个整体的项目，给搞成MVC三层，搞成三层还就算了，比如我想在Controller里面用一次Model的对象，我就得new一次【Controller调用Model前面有讲过】，我比如Controller层调用View层，我又要new一个对象。
这样new，少一点没关系，但是如果项目大起来，new对象就满天飞，这边new一个，那边new一个，Java的GC垃圾回收机制得累死，还不说随便乱new，不管空间回收的话还很容易发生内存溢出。
那咋整呢？这一个项目，里面各种对象new的满天飞，但是我们很多时候new出来就只是为了用一下这个类的对象，来调用里面的一个方法而已呀。
人多了，得找个管事儿的。
对象多了，也得找个管事儿的。
于是Spring就出来了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55cf82d88d1ab48c3991328a5c35676d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1da3cfa8bef95488f111576f2ce56488/" rel="bookmark">
			前端通过账号、密码，显示ftp服务器的图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 src访问格式为：
ftp://用户名:密码@服务器ip:服务器端口/具体文件路径
alt：未找到图片时，显示的内容；
举例
&lt;img src="ftp://wwxtest:123456@172.16.0.183:21/202109/20210924114938.jpg" alt="未找到照片" style="width: 50px; height: 50px;" &gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9bc330d6234eea9c6b79548c9a3448e/" rel="bookmark">
			rust教程 第二章 —— rust基础语法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、变量二、数据类型1.标量2.复合类型 三、函数四、注释五、控制流总结 一、变量 首先要讲解的便是变量，如果你有其它语言基础，相信还是比较好理解的
我们的电脑中，很重要的一个性能指标便是内存大小，而所有的程序便是运行在内存中的：
而变量，就是在这个内存中，申请一块属于自己可以调度的内存块，有了这块内存，我们就能用它来计算、存储等等操作了
rust中声明变量有两种方式：不可变变量、可变变量
首先是不可变变量，使用关键字let
fn main() { let a1=10; } 它的特点便是不可再变，比如如果你想要更改它的值，就会直接报错：
但在vs code中安装了插件后，当你写出错误的代码时，就会直接给你标红。
如果你此时编译运行它，编译器同样会非常精确的给你标注出来你错在了哪里：
这里的意思就是，不可以给不可变变量赋值两次
与不可变变量相对的就是可变变量，使用方法如下：
fn main() { let mut a1=10; a1=20; } 即：只需要在let关键字后面，添加一个mut关键字，就可以声明一个可变的变量了
除了上面两个变量外，rust中也有常量，也就是不可更改的，需要用到const关键字
fn main() { const a1:i32=10; } 可以很明显的看到，常量与不可变的变量还有有些区别的：
常量的名称后面必须紧跟变量的类型，比如这里的 :i32（后面马上讲解到）const 后面不可以添加mut关键字使它可变 所以总的来说，rust中声明变量的方式非常简单，只有三个关键字：let、mut、const
除却这个，对于变量，你还需要注意一点的，rust中的变量支持隐藏，比如下面这段代码：
fn main() { let a=10; let a='c'; } 粗一看，就是让变量a等于两个不同类型的值：数字、字符
但由于数字与字符所占的内存大小不同，对于rust这门编译型的语言，所以这样想肯定是错的。
之所以可以这样写，是因为rust支持变量隐藏，也就是当你后面再用let等关键字等于一个值后，那么前面那个就被隐藏了
比如这里的a，一旦又了第二句，那么在第二句之后再使用a这个变量，都将等于'c'，而前面那个10也并没有在内存中消失，而是被隐藏起来了，你只能在这两句的中间使用到这个数字
fn main() { let a=10; println!("a=={}",a); //a==10 let a='c'; println!("a=={}",a); //a==c } 这里用到了打印宏，先记住这个用法即可，后面会再对它进行详细介绍
这个特性可以方便我们这些取名困难户，可以给很多变量取一样的名称
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9bc330d6234eea9c6b79548c9a3448e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dba0b5a141ad6214659b0b598da15e8f/" rel="bookmark">
			rust教程 第一章 —— 初识rust
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、Rust简介二、安装Rust编译器三、第一个Rust程序四、 IDE环境五、初识包管理六、总结 前言 近些年来不断有新的语言崛起，比如当下非常火的go语言，不过相比于C++，go语言确实是非常简单的。
而rust作为一名新兴语言，却与go不同，因为它的目标是对标系统级开发，也就是试图动摇C、C++这两位纵横编程界数十年的老大哥位置。
比如我们最常用的windows系统，就是用C/C++语言开发，也正因如此，我们才能用C++在VS中可以非常方便的调用win API函数
而同样的，越是涉及到底层，需要控制的细节就会越多，即使是这位试图通过简便语法、便利包管理、安全可靠等良好特性脱颖而出的rust语言，也同样不例外。
在我稍稍学习了几天之后，就知道，这门语言的复杂程度我是完全可以写一系列专栏文章来介绍的。
注意：rust作为一门系统级开发语言，其学习难度并不比C、C++简单多少，但一旦你学会了，就可以快速、高效、安全的开发一系列程序，绝对比C、C++方便无数倍，所以你要想清楚自己是否需要学习这门语言
目前rust语言最大的缺点可能就是由于诞生不过十来年，目前生态还不够完善
比如如果想用rust写GUI程序，就很麻烦，因为官方目前还没有推出GUI库
但这并非是无法解决的，rust同样意识到了这个问题，所以提供了很多绑定C语言库的包，也就是说，只要能用C语言开发的，基本都可以用rust语言进行开发！
比如用rust绑定C开发的FLTK、GTK等GUI库就可以进行开发GUI程序了，当然也有正在发展的库，比如egui、iced等等
而rust带来的代码安全、便捷的开发又是C语言所无法比拟的，所以我预测要不了多少年，随着Rust生态的不断完善，会取代很大一部分C/C++的份额
除非windows、linux、mac三大操作系统以及各种开源库都采用rust语言重写，否则想要彻底取代C/C++还是有些不现实的，因为这些企业级的工程软件并非一朝一夕之功，不是说想要重写就能马上重写出来的，所以在相当长的一段时间内（二三十年？），C/C++程序语言在编程界应该仍然有着不可撼动的地位
因此便有了本文以及本专栏的文章，这是对标我的另一个C/C++实战入门到精通的教程文章。
力图写出即使是新人，也可以快速入门rust、上手开发简单软件、乃至写一些大型的有趣实战项目。
最好对C/C++语言有一定的了解，否则rust里面的很多概念你都可能无法理解
一、Rust简介 参考百度百科：
Rust语言在2006年作为 Mozilla 员工 Graydon Hoare 的私人项目出现，而 Mozilla 于 2009 年开始赞助这个项目。第一个有版本号的 Rust 编译器于2012 年 1 月发布。Rust 1.0 是第一个稳定版本，于 2015年5月15日发布。
可以看到，Rust是2015才对外开放稳定版本的，距今不过到10年，根据目前程序员对Rust这门语言的普遍评价来说，现在学习Rust，还有机会享受到这门语言在不久的将来可能会带来的福利
比如Rust的相关开发岗位可能会越来越多，而目前学习Rust的程序员数量，相比于C/C++来说，还是有些微不足道的，也就是说到时很可能就会出现供不应求的情况，供不应求带来的效益就是，Rust程序员的工资会逐年走高
那么具体来说，Rust能为开发人员带来哪些便利呢？
主要有以下几点：
内存安全： Rust 中的所有内存访问都经过了编译器的严格检查，并且在运行时不会出现空指针异常或数据竞争等问题。这意味着 Rust代码具有更高的可靠性和安全性，可以避免常见的安全漏洞。
而C语言则时常需要担心指针、内存问题，尤其是大项目中，非常容易因此出现各种各样的Bug
高效性能： Rust 具有与 C 和 C++ 相当的性能，并采用了现代语言的特性和设计理念，如智能指针、闭包和模式匹配等。这使得 Rust很适合编写高性能、低延迟的系统级应用程序和库。
并发性： Rust 的所有权系统和借用规则使其易于编写线程安全的代码，即使在多线程环境下也可以保持高效率和可靠性。C/C++中则完全需要自己进行控制
社区支持： Rust 拥有活跃的社区，提供了许多开源库、工具和框架，可以大幅度提升开发效率。C/C++虽然学习的人很多，但却几乎没有官方的、活跃的社区可以供大家交流，都是在各搞各的
统一包管理 C/C++中，最让人诟病的便是包管理了，想要用一个包，还需要自己下载、安装、配置等等，而Rust则直接提供了一个统一的包管理程序，只需要写一行代码，就能自动为你下载配置好你所需要的一切，并且还提供对应的文档，使用起来非常方便！
综上，你便能看出Rust的优势所在了。
Python语言之所以能火，有很多原因，而其中很大的一个原因就是Python有一个统一的包管理程序pip，可以很方便的下载包。
而一旦学会了Rust，即使是作为较为底层的开发人员，我们同样也能享受到这种便利了！
这是学习C/C++所无法想象的（虽然目前有一个vcpkg包管理库很不错，但这毕竟不是标准委员会推出的，而是微软带头组织的一个开源项目，而且如果不会科学上网，中国几乎也无法使用）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dba0b5a141ad6214659b0b598da15e8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a186ba75dce711940e0bc9fee649fc84/" rel="bookmark">
			【ISO14229_UDS_0x34服务详解】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1、0x34服务（RequestDownload，请求下载服务）2、请求报文格式2.1 请求报文定义2.2 请求报文中子函数参数定义2.3 请求报文中数据参数定义 3、肯定应答报文3.1 肯定应答报文格式定义3.2 肯定应答报文数据参数定义 4、支持的否定应答码(NRC_)5、0x34服务（RequestDownload，请求下载服务）案例说明 1、0x34服务（RequestDownload，请求下载服务） Service description：
0x34服务（RequestDownload，请求下载服务）被客户端用于初始化从客户端到服务端的数据传输。
在服务端接收到RequestDownload的请求报文后，在服务端肯定应答之前，应采取所有必要的行为去接收数据。
2、请求报文格式 2.1 请求报文定义 下表定义了请求报文的格式：
字节序号参数值约定字节值#1RequestDownload Request SIDM0x34#2dataFormatIdentifierM0x00 - 0xFF#3addressAndLengthFormatIdentifierM0x00 - 0xFF
#4
.
.
#(m - 1) + 4memoryAddress[] = [
byte#1 (MSB)
.
.
byte#m ]
M
.
.
C1
0x00 - 0xFF
.
.
0x00 - 0xFF
#n-(k-1)
.
.
#nmemorySize[] = [
byte#1 (MSB)
.
.
byte#k ]
M
.
.
C2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a186ba75dce711940e0bc9fee649fc84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d623122ccd1186abce35da90ac4c689/" rel="bookmark">
			Amazon S3 对象存储Java API操作记录（Minio与S3 SDK两种实现）缘起
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		缘起 今年(2023年) 2月的时候做了个适配Amazon S3对象存储接口的需求，由于4月份自学考试临近，一直在备考就拖着没总结记录下，开发联调过程中也出现过一些奇葩的问题，最近人刚从考试缓过来顺手记录一下。
S3对象存储的基本概念 S3是什么？ Amazon S3(Simple Storage Service)对象存储出现得比较早且使用简单的RESTful API，于是成为了对象存储服务(Object Storage Service，OSS)业内的标准接口规范。
S3的逻辑模型 如下图，我们可以把S3的存储空间想象成无限的，想存储一个任意格式的文件到S3服务中，只需要知道要把它放到哪个桶(Bucket)中，它的名字（Object Id）应该是什么。
按图中的模型，可简单理解为S3是由若干个桶（Bucket）组成，每个桶中包含若干个不同标识的对象（Object），还有就是统一的访问入口(RESTful API)，这样基本就足够了。
Minio客户端方式操作S3 详细API文档：Java Client API Reference — MinIO Object Storage for Linux
以下代码异常处理做了简化，真实使用时请注意捕获异常做处理。
引入依赖 Maven:
&lt;dependency&gt;&lt;groupId&gt;io.minio&lt;/groupId&gt;&lt;artifactId&gt;minio&lt;/artifactId&gt;&lt;version&gt;8.5.2&lt;/version&gt;&lt;/dependency&gt; Gradle:
dependencies {implementation("io.minio:minio:8.5.2")} 初始化客户端 private static final String HTTP_PROTOCOL = "http";private MinioClient minioClient;private String endpoint = "http://192.168.0.8:9200";private String accessKey = "testKey";private String secretKey = "testSecretKey";public void init() throws MalformedURLException {URL endpointUrl = new URL(endpoint);try {// url上无端口号时，识别http为80端口，https为443端口int port = endpointUrl.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d623122ccd1186abce35da90ac4c689/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d0979d3f2a1f4491ac87e091bb7f9a5/" rel="bookmark">
			Java中抽象类和接口区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、抽象类：
只支持单继承；
类访问修饰符public，不能使用其他修饰符；
抽象类不允许被实例化，只能被继承，不可以new出来；
抽象类可以包含变量和方法。方法可以是普通方法也可以是抽象方法；
包含抽象方法的一定是抽象类，但是抽象类不一定含有抽象方法；
抽象类中的抽象方法的修饰符只能为public或者protected，缺省情况下默认为public；
类继承抽象类，必须实现抽象类中的所有抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为abstract类。
抽象类可以包含构造方法，但是构造方法不能用于实例化，主要用途是被子类调用。
2、接口：
支持多继承；
接口默认是public，不能使用其他修饰符；
类实现接口的时候，必须实现接口中声明的所有方法；
接口可以包含变量、方法，变量被隐士指定为public static final，方法被隐士指定为public abstract（JDK1.8之前）；
JDK1.8中接口中可以定义静态方法、default方法，枚举类型，接口中还可以定义接口（嵌套）。
JDK1.8中对接口增加了新的特性 - 默认方法：JDK 1.8允许给接口添加非抽象的方法实现，但必须使用default关键字修饰；定义了default的方法可以不被实现子类所实现，但只能被实现子类的对象调用；如果子类实现了多个接口，并且这些接口包含一样的默认方法，则子类必须重写默认方法；
JDK1.8中对接口增加了新的特性 - 静态方法：JDK 1.8中允许使用static关键字修饰一个方法，并提供实现，称为接口静态方法。接口静态方法只能通过接口调用（接口名.静态方法名）。
例子：定义接口
public interface IVehicle { //枚举类型 enum Type { LOW, MEDIUM, HIGH } //嵌套接口 interface IWheel { void run(); } //default方法 default void init() { IVehicle.Type type = IVehicle.Type.LOW; System.out.println(type.ordinal()); } //静态方法 static void printPrice() { System.out.println("打印价格！！！"); } void start(); } 接口实现类及调用：
public class Car implements IVehicle{ @Override public void start() { } } public class Client { public static void main(String[] args) { Car car = new Car(); car.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d0979d3f2a1f4491ac87e091bb7f9a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3ce2f93b33a8ac3ff70928e71d4cb48/" rel="bookmark">
			金额千位符自定义指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自定义指令文件 moneyFormat.js
/** * v-money 金额千分位转换 */ export default { inserted: inputFormatter({ // 格式化函数 formatter(num, util) { if(num == null || num == '' || num == 'undefined' || typeof(num) == 'undefined'){ return '' } if(util == '万元' || util == '万'){ return formatMoney(num,'wan'); }else if(util == '元'){ return formatMoney(num); } // num = num.toString() // let num1 = num.split(".")[0], num2 = num.split(".")[1]; // let c = num1.toString().replace(/(\d)(?=(?:\d{3})+$)/g, '$1,'); // return num.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3ce2f93b33a8ac3ff70928e71d4cb48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c09ce12c9b0e3c6625a4d25fe7999092/" rel="bookmark">
			多层感知机（MLP）代码示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，我们导入所需的库：
import torch import torch.nn as nn import torchvision.transforms as transforms import torchvision.datasets as datasets import matplotlib.pyplot as plt 然后，我们加载MNIST数据集：
train_dataset = datasets.MNIST(root='./data', train=True, transform=transforms.ToTensor(), download=True) test_dataset = datasets.MNIST(root='./data', train=False, transform=transforms.ToTensor()) 接下来，我们定义MLP模型类：
class MLP(nn.Module): def __init__(self, input_size, hidden_size, num_classes): super(MLP, self).__init__() self.fc1 = nn.Linear(input_size, hidden_size) self.relu = nn.ReLU() self.fc2 = nn.Linear(hidden_size, num_classes) def forward(self, x): out = self.fc1(x) out = self.relu(out) out = self.fc2(out) return out 在这个例子中，MLP模型有两个全连接层。在初始化函数__init__()中，我们定义了两个全连接层self.fc1和self.fc2，激活函数ReLUself.relu。在前向传播函数forward()中，我们将输入数据x传递给fc1，然后通过ReLU激活函数，再传递给fc2。
我们继续设置超参数：
input_size = 784 hidden_size = 500 num_classes = 10 num_epochs = 5 batch_size = 100 learning_rate = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c09ce12c9b0e3c6625a4d25fe7999092/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef9ced25482776019a3af488b4e5a3ea/" rel="bookmark">
			logback自定义日志脱敏规则及脱敏开关（动态控制日志加密方式以及加密开关）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：公司日志数据不能暴露账号密码登个人关键信息 常见脱密方式：（推荐使用第二种方式） 1.xml配置对应的key然后对其value进行相应规则的脱敏（此种方式对于没有key的值无法脱敏并且系统重也不好穷尽所有需要脱敏的key）
2.采用正则表达式匹配对应的关键信息进行脱敏（满足正则表达是即可正确的脱敏相应的内容）
下面就对第二种方式详细说明： 1.定义一个SensitiveLogDataConverter import ch.qos.logback.classic.pattern.MessageConverter; import ch.qos.logback.classic.spi.ILoggingEvent; import cn.hutool.core.util.StrUtil; import java.util.HashSet; import java.util.Set; import java.util.regex.Matcher; import java.util.regex.Pattern; public class SensitiveLogDataConverter extends MessageConverter { // 脱敏符号 * public static final String SYMBOL_STAR = "*"; /** * 0 加密前三位 * 1 加密中间四位 * 2 加密后面四位 */ public static Integer logMode = 1; /** * 是否开启加密规则 默认为false */ public static boolean logSensitive = false; /** * 手机号 */ private static final Pattern PHONE_PATTERN = Pattern.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef9ced25482776019a3af488b4e5a3ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42d1b5fa4331b008d9c417521d3241da/" rel="bookmark">
			Vue学习，使用Vue完成商品展示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用前需要前往Vue官网下载vue.js文件，代码如下：
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="js/vue.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;style&gt; * { margin: 0px; padding: 0px; list-style: none; text-decoration: none; } #box { height: 800px; width: 1500px; } .box_left { height: 100%; width: 250px; background-color: seashell; float: left; } .box_right { float: left; height: 100%; width: 1230px; } ul { margin-top: 10px; } .ul_list li { float: left; margin-right: 30px; margin-bottom: 20px; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42d1b5fa4331b008d9c417521d3241da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d8d2521f0bcaf7c221bb51e5e863f46/" rel="bookmark">
			VisDrone数据集格式转换为YOLO格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VisDrone数据集的txt文件的标签内容和yolo的不同，所以需要脚本文件来进行转换。
import os from pathlib import Path from PIL import Image from tqdm import tqdm def visdrone2yolo(dir): def convert_box(size, box): #Convert VisDrone box to YOLO CxCywh box,坐标进行了归一化 dw = 1. / size[0] dh = 1. / size[1] return (box[0] + box[2] / 2) * dw, (box[1] + box[3] / 2) * dh, box[2] * dw, box[3] * dh # (dir / 'labels').mkdir(parents=True, exist_ok=True) # make labels directory (dir / 'Annotations_YOLO').
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d8d2521f0bcaf7c221bb51e5e863f46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc2858b9ce1a3f09d0647e3a579e5809/" rel="bookmark">
			unity 之 Input.GetMouseButtonDown 的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Input.GetMouseButtonDown Input.GetMouseButtonDown 当涉及到处理鼠标输入的时候，Input.GetMouseButtonDown 是一个常用的函数。它可以用来检测鼠标按键是否在特定帧被按下。下面我会详细介绍这个函数，并举两个例子说明如何使用它。
函数签名：
public static bool GetMouseButtonDown(int button); 参数：
button：一个整数，表示要检测的鼠标按键。常用值为 0（左键）、1（右键）、2（中键/滚轮按钮）。 返回值：
返回一个布尔值，表示在当前帧是否按下了指定的鼠标按键。如果按下了指定的鼠标按键，则返回 true，否则返回 false。 例子 1：检测鼠标左键点击
void Update() { if (Input.GetMouseButtonDown(0)) { Debug.Log("鼠标左键被点击！"); } } 在这个例子中，每当玩家点击鼠标左键时，会在控制台输出一条信息。
例子 2：检测鼠标右键点击并进行射击
public GameObject bulletPrefab; public Transform bulletSpawnPoint; void Update() { if (Input.GetMouseButtonDown(1)) // 检测鼠标右键点击 { ShootBullet(); } } void ShootBullet() { GameObject newBullet = Instantiate(bulletPrefab, bulletSpawnPoint.position, bulletSpawnPoint.rotation); Rigidbody bulletRigidbody = newBullet.GetComponent&lt;Rigidbody&gt;(); bulletRigidbody.AddForce(bulletSpawnPoint.forward * 10f, ForceMode.Impulse); } 在这个例子中，我们假设有一个子弹预制体 bulletPrefab，以及一个发射子弹的位置 bulletSpawnPoint。当玩家点击鼠标右键时，会调用 ShootBullet 函数发射子弹。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc2858b9ce1a3f09d0647e3a579e5809/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb3a6cc730e61aa2b73085cbb8a7260d/" rel="bookmark">
			set_up_a_local_testing_server
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://developer.mozilla.org/en-US/docs/Learn/Common_questions/Tools_and_setup/set_up_a_local_testing_server
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bdc5030c269119050e98e2633e9e8f7/" rel="bookmark">
			H.264帧结构和RTSP协议源码框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、H264编码原理和基本概念
1.1、h.264编码原理
1.2、h.264编码相关的一些概念
2、H264的NAL单元详解
2.1、VCL和NAL的关系
2.2、H.264视频流分析工具
2.3、h264视频流总体分析
2.4、相关概念
3、H264的NAL单元---sps和pps
3.1、sps和pps详解
3.2、H264的profile和level
3.3、sequence
4、rtsp协议和源码框架
4.1、源码框架函数调用关系
4.2、直接发送与环状buffer发送
4.3、RTP发送一帧数据的两种不同发送格式-&gt;整发送和分包发送
1、H264编码原理和基本概念 1.1、h.264编码原理 (1)图像冗余信息：空间冗余、时间冗余
(2)视频编码关键点：压缩比高、算法复杂度小、还原度高
(3)H.264的2大组成部分：VCL和NAL
VCL关心如何进行视频压缩
NAL关心压缩后的视频流如何被网络传输和解码播放
1.2、h.264编码相关的一些概念 (1)宏块 MB（macroblock）：多个像素组成的一块，宏块是视频压缩算法的最基本单位
由于图像本身在局部，颜色具有相似性，所以可以把一幅图像分成若干个宏块
(2)片 slice：构成帧的一部分
一帧图像=若干个slice（可以是一个slice）
一个slice=若干个MB
一个MB=多个像素
(3)帧 frame：一整幅完整的图像
(4)I帧、B帧、P帧：帧有好几种类型
I帧：非参考帧，这一帧图像的内容只和本身有关，和前一帧后一帧图像的内容无关，一般作为起始帧，因为这一帧没有任何参考，所以只能对这一帧进行帧内压缩（空间冗余上的优化）
B帧：参考帧，这一帧图像的内容不光和本身有关，还和前一帧或后一帧图像的内容有关（空间冗余+时间冗余的优化）
P帧：参考帧，这一帧图像的内容不光和本身有关，还和前一帧图像的内容有关（空间冗余+时间冗余的优化）
(5)帧率 fps：一秒中有多少帧，帧率高（慢动作），帧率低（快动作）
(6)像素-&gt;宏块-&gt;片-&gt;帧-&gt;序列-&gt;码流
2、H264的NAL单元详解 2.1、VCL和NAL的关系 (1)VCL只关心编码部分，重点在于编码算法以及在特定硬件平台的实现，VCL输出的是编码后的纯视频流信息，没有任何头信息
(2)NAL关心的是VCL的输出纯视频流如何被表达和封包以利于网络传输
(3)SODB：String Of Data Bits（VCL输出的纯视频流）
(4)RBSP：Raw Byte Sequence Payload
(5)NALU：Network Abstraction Layer Units NALU是H264文件的基本组成单元
(6)关系：
SODB + RBSP trailing bits = RBSP
NALU header(1 byte) + RBSP = NALU
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5bdc5030c269119050e98e2633e9e8f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9f228f955f378c18adb9c9c52ab1909/" rel="bookmark">
			Unity- 控制物体旋转、移动、缩放的功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文章主要介绍Unity中控制物体旋转、移动、缩放的方法~
旋转：
（一）控制物体自转
public float speed=45; void Update() { transform.Rotate(Vector3.up * speed * Time.deltaTime); } （二）控制物体A绕着物体B转
脚本放在物体A上，再将物体B拖到脚本相应位置上
public float speed=45; public Transform cube; //物体B void Update() { transform.RotateAround(cube.position, cube.up, speed * Time.deltaTime); } 移动：
物体不断向前移动
public float speed=2; void Update() { transform.Translate(Vector3.forward * speed * Time.deltaTime); } 扩展：使用键盘（上下左右箭头）控制物体前后左右移动
public float speed=3; void Update() { Vector3 v = Input.GetAxis("Vertical") * Vector3.forward; Vector3 h = Input.GetAxis("Horizontal") * Vector3.right; transform.Translate(v * speed * Time.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9f228f955f378c18adb9c9c52ab1909/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09667224a78fcdfe1738dbc671913eed/" rel="bookmark">
			解决：(error) ERR unknown command shutdow，with args beginning with
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、遇到问题
二、出现问题的原因
三、解决办法
一、遇到问题 要解决连接redis闪退的问题，按照许多的方式去进行都没有成功，在尝试使用了以下的命名去尝试时候，发现了这个问题。
二、出现问题的原因 这是一个粗心大意导致的错误，检查自己输入的命令是否正确。 这个错误消息表明你尝试执行了一个 Redis 不识别的命令或命令参数，具体来说，是尝试执行了类似于 shutdow 的命令。正常情况下，正确的命令应该是 shutdown，这是用于关闭 Redis 服务器的命令。
可能的原因和解决方法如下：
拼写错误：你可能在输入命令时拼写错误，导致 Redis 无法识别命令。确保你输入的是正确的命令，例如 shutdown 而不是 shutdow。
自定义命令：如果你在 Redis 中定义了自定义的命令或别名，可能会导致类似的错误。确保你使用了 Redis 原生的命令。
版本问题：不同版本的 Redis 可能会有不同的命令支持。如果你使用的是较旧的 Redis 版本，可能某些命令不被支持。升级到更新的版本可能会解决这个问题。
命令参数错误：如果你在命令后面添加了不正确的参数，也可能导致类似的错误。检查命令及其参数是否正确。
三、解决办法 输入正确的命令：shutdown
有什么问题都可以评论区留言，看见都会回复的
如果你觉得本篇文章对你有所帮助的，多多支持吧！！！
点赞收藏评论，当然也可以点击文章底部的红包或者👇订阅付费文章创作支持一下了。抱拳了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83967fe152f76aec9f62349b01fa5d9c/" rel="bookmark">
			大语言模型的自然语言生成能力和测评
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了更加清晰准确地了解以ChatGPT为代表的大语言模型的能力，前面两篇文章分别专题整理了大语言模型的自然语言理解和自然语言推理方面的测评工作，本篇继续整理对大语言模型在自然语言生成方面一些能力测评工作。
自然语言生成（NLG）是大语言模型在生成特定文本方面的能力，包括摘要生成、对话生成和问答等多个任务。
摘要生成（Summarization）
【能力描述】
生成给定句子或文本的简洁摘要。
【测试数据集举例】
ELIFE: eLife 是一本生物医学和生命科学领域的可开放获取的期刊。ELIFE数据集在 eLife 发表的文章中，部分文章被选中成为摘要的对象，由专家编辑根据文章本身和作者回答的问题撰写的工作的简化摘要。摘要旨在以非专业人士可以理解的语言解释科学文章的背景和意义。
【测试数据实例】
截图：eLife数据集在HuggingFace可以下载。每一个数据记录都包括文章原文(article)，摘要(summary)等属性。
【相关模型】
ChatGPT等
【评估的方法结果】
摘要的量化评估指标比较复杂。在Pu, D. and Demberg, V. 等的工作重综合评估，包括但不限于：
- Flesch 阅读难度（FRE）：是一个衡量给定文本可理解性的度量标准。该指数依赖于每个词的平均音节数和每个句子的平均词数。得分越高表示文本更易理解。
- Coleman-Liau 指数（CLI）：是文本难度级别的一种度量标准，考虑了每个句子的平均字符数和每 100 个词的平均句子数。得分越高表示文本更具挑战性。
- Dale-Chall 可读性分数（DCR）：是通过比较文本中复杂词汇的数量与常用词汇表的列表来计算的。得分越高表示文本更具挑战性。
- Rouge 分数（Lin，2004）来评估 ChatGPT 在文本摘要任务中的性能，以便将其效果与最先进的模型进行比较。
- N-gram 新颖性：评估摘要在多大程度上重新使用了原始文本中的词序列
论文截图：部分对比人类生成摘要和ChatGPT产生摘要的测试结果，
ChatGPT可以在一定程度上根据提供的提示生成不同难度级别的摘要。值得注意的是，ChatGPT为专家风格摘要生成的句子比普通人风格摘要的句子更复杂。然而，两种类型摘要之间的阅读难度得分差异的幅度要比人工撰写的摘要中观察到的幅度小得多。
另外，测试发现，ChatGPT的摘要稍微更多从源文本中复制内容。大模型生成的文本与人工撰写的文本之间存在显著差异。通过提供人类写作风格的目标示例，可以减少这些差异。ChatGPT生成的摘要中还存在幻觉和不准确性的问题。大语言模型在摘要任务上具有一般性能，仍有待提高。
【一些评论】
人类生成摘要是一件相对费脑、比较困难的工作。摘要生成能力的价值没有充分反映在测评结果中。况且，eLife数据集中的摘要是由人类专家生成的（并不能代表普通人的水平）。测试的指标对于生成摘要的质量也难以清晰直接地量化。
对话任务(Dialogue)
【能力描述】
大语言模型的对话能力指的是它在模拟对话过程中所展现出来的语言理解、生成和交流能力。它可以接收用户输入的文本信息，并以自然流畅的方式产生回应，就像两个人在进行真实对话一样。
【测试数据集举例】
MuTual：MuTual是一个用于多轮对话推理的检索式数据集，其改编自中国高中英语听力理解测试数据。
【测试数据实例】
截图：MuTual数据集样例：左侧是对话语境；右侧是候选的回应，其中红色的是正确的回应
【相关模型】
ChatGPT, GPT4等
【评估的方法结果】
论文截图：Qin等就对话任务进行的准确性测评
【一些评论】
在另外一些测评工作中，对话还被分为(1)基于知识的开放域对话和(2)面向任务的对话。评估结果显示，与基于知识的开放域，ChatGPT的性能相对较低。在面向任务的对话中，ChatGPT的性能可接受。ChatGPT在以下问题出现时容易出现错误：长期多轮依赖、基本推理失败和外在幻觉。
问答任务(Question Answering)
【能力描述】
问答是人机交互领域的关键技术之一，已广泛应用于搜索引擎、智能客服和智能问答等场景。衡量问答模型的准确性和效率对于这些应用具有重要意义。
【测试数据集】
问答测试数据集有很多。在Laskar 2023一文中对ChatGPT在多样的学术数据集上的表现进行彻底评估，涵盖了问题回答、文本摘要、代码生成、常识推理、数学问题解决、机器翻译、偏见检测和道德考虑等任务。测评所使用的数据集如下：
论文截图：Laskar测评中所使用的测评数据集
【相关模型】
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83967fe152f76aec9f62349b01fa5d9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e01b2fe33a5b17e0eea364046e4f9ae4/" rel="bookmark">
			C语言编译报错：initialization from incompatible pointer type [-Wincompatible-pointer-types]（传参类型不匹配）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码：
//arnold add 20211213 size_t save_video_box_buffer_size = 1920*1080*3/2; char* save_video_box_buffer = (char*)malloc(save_video_box_buffer_size); //开辟一块内存用来存储即将做编码推流的buffer（这先不用队列，看看写视频的速度怎么样先，不行再用队列） pthread_t main_stream_thread;	// //pthread_create(&amp;main_stream_thread, NULL, MainStream, NULL); //origin pthread_create(&amp;main_stream_thread, NULL, MainStream, save_video_box_buffer); 警告：
ky_ai_camera_engine_origin.c:1519:45: warning: passing argument 3 of ‘pthread_create’ from incompatible pointer type [-Wincompatible-pointer-types] pthread_create(&amp;main_stream_thread, NULL, MainStream, save_video_box_buffer); ^~~~~~~~~~ In file included from /home/yg/rv/sdk/rv1.8/rv1126_rv1109/buildroot/output/rockchip_rv1126_rv1109/build/ky_ai_camera_engine_origin/src/ky_ai_camera_engine_origin.c:7: /home/yg/rv/sdk/rv1.8/rv1126_rv1109/buildroot/output/rockchip_rv1126_rv1109/host/arm-buildroot-linux-gnueabihf/sysroot/usr/include/pthread.h:236:15: note: expected ‘void * (*)(void *)’ but argument is of type ‘void * (*)(char *)’ void *(*__start_routine) (void *), ~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~ 原因是pthread_create()传参类型不一致！传的是void*，需要的是char*
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e01b2fe33a5b17e0eea364046e4f9ae4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1862ff46a6dfa95f33ed70d15b854e22/" rel="bookmark">
			VLAN 实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设置子接口与物理接口 [R1]interface g0/0/0.1 [R1-GigabitEthernet0/0/0.1]ip add 192.168.1.1 24 [R1-GigabitEthernet0/0/0.1]dot1q termination vid 2 #配置封装标准，从此接口进出时要封装vlan id [R1-GigabitEthernet0/0/0.1]arp broadcast enable #开启子接口的arp广播功能 [R1]inter g0/0/0 [R1-GigabitEthernet0/0/0]ip add 192.168.2.1 24 配置DHCP服务 [R1]dhcp enable [R1]ip pool a [R1-ip-pool-a]network 192.168.1.0 mask 24 [R1-ip-pool-a]gateway-list 192.168.1.1 [R1]ip pool b [R1-ip-pool-a]network 192.168.2.0 mask 24 [R1-ip-pool-a]gateway-list 192.168.2.1 [R1-GigabitEthernet0/0/0.1]dhcp select global [R1-GigabitEthernet0/0/0]dhcp select global 创建所需的vlan [SW1]vlan batch 2 to 6 [SW2]vlan batch 2 to 6 设置access接口 [SW1]inter g0/0/3 [SW1-GigabitEthernet0/0/3]port link-type access [SW1-GigabitEthernet0/0/3]port default vlan 2 [SW1]inter g0/0/2 [SW1-GigabitEthernet0/0/2]port link-type access [SW1-GigabitEthernet0/0/2]port default vlan 2 设置trunk干道 [SW1-GigabitEthernet0/0/6]port link-type trunk [SW1-GigabitEthernet0/0/6]port trunk allow-pass vlan 3 5 to 6 [SW2-GigabitEthernet0/0/1]port link-type trunk [SW2-GigabitEthernet0/0/1]port trunk allow-pass vlan 3 5 to 6 设置PC2\4\5\6的接入口 [SW1-GigabitEthernet0/0/4]port hybrid pvid vlan 3 [SW1-GigabitEthernet0/0/4]port hybrid untagged vlan 1 to 6 [SW1-GigabitEthernet0/0/5]port hybrid pvid vlan 4 [SW1-GigabitEthernet0/0/5]port hybrid untagged vlan 1 to 6 PC5除了不能被vlan4的PC4访问 [SW2-GigabitEthernet0/0/2]port hybrid untagged vlan 1 to 3 5 to 6 PC6不能被vlan4的PC4和vlan5的PC5访问 [SW2-GigabitEthernet0/0/3]port hybrid untagged vlan 1 to 3 6 设置SW1到R1的出接口 [SW1-GigabitEthernet0/0/1]port hybrid untagged vlan 1 3 to 6 [SW1-GigabitEthernet0/0/1]port hybrid tagged vlan 2 验证 PC2能ping通PC4\5\6 PC&gt;ping 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1862ff46a6dfa95f33ed70d15b854e22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b27638690ccda7e20bc22677429168f6/" rel="bookmark">
			c语言每日一练(9)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
每日一练系列，每一期都包含5道选择题，2道编程题，博主会尽可能详细地进行讲解，令初学者也能听的清晰。每日一练系列会持续更新，暑假时三天之内必有一更，到了开学之后，将看学业情况更新。
五道选择题： 1、以下 scanf 函数调用选项中， 错误的是（ ）
struct T { char name[20]; int age; int sex; } a[5], *pa=a; A、scanf("%s",a[0].name);
B、scanf("%d", &amp;pa[0].age);
C、scanf("%d",&amp;(pa-&gt;age));
D、scanf("%d", pa-&gt;age);
解析：首先，你要明白scanf需要什么，它需要地址，你只要给它对应数据的地址，它就会根据地址对你所给的目标进行修改。
选项A，通过结构体数组访问到结构体，再通过结构体访问到结构体成员，但它访问的是字符数组，而字符数组的本质就是指针，故A正确。选项B，使用结构体数组的方式访问结构体，再通过结构体访问结构体成员，不同于A的是它访问的是整型变量，整型变量没有字符数组那么特殊，因此要取地址，它也取了，故B正确。
选项C，使用-&gt;的方式取到了结构体成员，并取了地址，和B雷同，C正确。D选项，与C不同的就在于没有取地址，因此，scanf无法正确地执行，故D错误。
2、关于指针下列说法正确的是【多选】（ ）
A、 任何指针都可以转化为void * B、 void *可以转化为任何指针
C、 指针的大小为8个字节 D、 指针虽然高效、灵活但可能不安全
解析：C错误，因为指针的大小是随着平台的变化而变化的，当指针处于32位平台时，大小为4，为64位平台时位8，ABD没有问题。 3、请指出以下程序的错误【多选】（ ）
void GetMemory(char** p, int num) { if (NULL == p &amp;&amp; num &lt;= 0)//1 return; *p = (char*)malloc(num); return; } int main() { char* str = NULL; GetMemory(&amp;str, 80); //2 if (NULL !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b27638690ccda7e20bc22677429168f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2906f6228c5eec80cdf6c8cf3076f158/" rel="bookmark">
			vue 监听dom元素的宽高变化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 vue 监听dom元素的宽高变化 1、准备一个插件
npm install element-resize-detector 2、使用
mounted() { // 直接导入使用，也可以在main.js中引入 const elementResizeDetectorMaker = require('element-resize-detector'); // 创建实例，无参数 const erd = elementResizeDetectorMaker(); // 创建实例带参数 // const erdUltraFast = elementResizeDetectorMaker({ // strategy: 'scroll', // callOnAdd: true, // debug: true // }); //监听class为top的元素 大小变化 erd.listenTo(document.querySelector('.top'),(element)=&gt;{ const width = element.offsetWidth; const height = element.offsetHight; this.selectWidth= (width - 100 ) + 'px' }) }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/330f6ea3977c00a735fb4bb4dd3f22cd/" rel="bookmark">
			博客管理系统|基于SpringBoot&#43;Vue&#43;ElementUI付费博客系统的设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者主页：编程指南针
作者简介：Java领域优质创作者、CSDN博客专家 、掘金特邀作者、多年架构师设计经验、腾讯课堂常驻讲师
主要内容：Java项目、毕业设计、简历模板、学习资料、面试题库、技术互助
收藏点赞不迷路 关注作者有好处
文末获取源码 项目编号：BS-PT-089 二，环境介绍 语言环境：Java: jdk1.8
数据库：Mysql: mysql5.7+Redis
应用服务器：Tomcat: tomcat8.5.31
开发工具：IDEA或eclipse
后台开发技术:springboot+mybatis
前台开发技术：vue+elementUI
二，项目简介 随着网络的迅速崛起，让互联网逐渐成为人们日常生活沟通交流的主要媒介，而具体的交流方式也随着科技的进步不断更新。过去，人们并没 有己的博客，因此只能通过比较分散，又缺乏条理的方式来展现自己的想法与心情，例如通过即时聊天软件或是在论坛上发表贴子等，但这些方法操作复杂，对个人信息的安全保护性能也不是很强。因此随着博客在网络上的普及，人们便可以通过博客表达自己的思想与感受，展示自己并让更多的人了解你，可以说博客是不受局限，言论由的网络个人日记。博客作为一个可以让人们提高写作水平的训练基地，表达文字的网络载体，它注重对自我感受和生活表达，经常写博客能够极快的磨练博主的写作技巧，并能使其思想意识更加深刻、敏锐。
博客，又叫网络日志，是一个通常由个人管理，不定期发布新的文章的网站。博客上的文章通常根据发布的时间，用倒序的方式由新到旧排列。许多博客专注在特定的课题上提供评论和新闻，其他的被作为个人日记。一个典型的博客结合了文字、图像、其他博客或者网站的链接、以及其他相关的主题为主的媒体。能够让读者以互动的方式留下意见，是许多博客的重要要素。大部分的博客内容以文字为主，博客是社会媒体网络的一部分。
各大网站上都有自己的博客系统，但是功能上都有所不同和局限性，我们为了实现一种属于我们自己的博客系统，尽量做到功能简洁，页面美观，更方便于流行的博客系统。
前台包含有5个模块，如图1所示。
用户登录：用户在使用博客系统之前需要登录注册，注册的方式提供了手机号注册和邮箱注册，注册完后登录时还需要验证码验证，验证成功才能进入博客主页。
博客页面展示：主页展示的是所有人的博客信息，用户可以在这里可以根据关键词搜索博客，还可以评论博客，有喜欢的博客还可以收藏起来，还可以根据类型的不同找博客，还有排行榜可以看到优质博客。
个人中心：个人中心展示的是个人信息，订单管理钱包管理还有自己的博客，个人信息里面可以查看浏览记录，可以修改手机号码，邮箱，密码等等，这里还添加了一个身份证的认证。订单管理里面是购买收费博客和广告的记录。钱包里面可以查看余额，可以充值和提现，提现是提现在银行卡里面。
发表博客：发表博客之前要先选择博客的分类，在分类下去新增博客，还可以添加图片到博客中，博客新增完毕可以选择是否收费，选择完毕在发表。
广告模块：这是一个盈利的功能，当用户看博客的时候会有广告在附近，用户可以通过花钱的方式消除广告。
后台包含有6个模块，如图2所示。
用户管理：管理员可以新增用户，修改用户，删除用户，查询用户的信息，用户可以自己注册，也可以管理员手动进行注册，用户名不能重复，如果用户忘记了密码可以联系管理员进行密码重置。
博客审核：用户发布的博客，管理员需要审核，一些非法信息或者暴力的内容等不能展示出来，审核通过后管理员可以手动发布帖子，审核不通过会提示用户，审核不通过。
广告管理：管理员可以新增广告到博客主页上，还可以对广告进行删除，修改的操作，还可以查看广告。
博客管理：管理员可以删除用户发布的博客，也可以修改用户的博客，还可以查询博客。
订单管理：当用户花钱购买付费的博客或者广告时，会生成一个未支付订单，等用户付完款后会修改成已支付订单，主页才能查看博客或者消除广告。
充值提现审核：用户点击提现后，选择提现的金额，发起提现，此时会进入提现审核状态，后台会收到，当管理员审核状态修改成通过时，用户提现的金额才能存到银行卡中，管理员还可以随时查看审核的状态。
1.技术要求
(1)技术实施方案
博客系统采用了前后端分离的技术，前端我使用了vue框架，css，js,html等，使用的开发工具是WebStorm，缓存使用了redis，使用了RESP可视化工具。
后端我使用了SpringBoot快速开发脚手架，使用的开发工具是IDEA，数据库方面我用的是MySql，可视化工具采用的是Navicat。
前后端交互是前端使用Ajax进行跨域访问到后端的数据，得到数据后就返回到前端。
(2)系统测试方案
收集资料对IDEA开发工具，Java语言，Mysql数据库，vue框架进行深入学习和使用。根据系统分析对博客系统进行分类设计和详细设计。根据系统设计和详细设计对各功能进行系统实现。按规定对系统进行完整的测试，找出存在的问题，进一步完善博客系统。
2.工作要求
(1)技术可行性：
使用Vue+SpringBoot实现项目的前后端开发。Vue是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue被设计为可以自底向上逐层应用。Vue的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue也完全能够为复杂的单页应用提供驱动。Vue使用了双向数据绑定，即当数据发生变化的时候，视图也就发生变化，当视图发生变化的时候，数据也会跟着同步变化，这就是Vue的精髓所在。SpringBoot，在当前互联网后端开发中，JavaEE占据了主导地位。对JavaEE开发，首选框架是Spring框架。在传统的Spring开发中，需要使用大量的与业务无关的XML配置才能使Spring框架运行起来，这点备受许多开发者诟病。为了进一步简化Spring应用的开发，SpringBoot诞生了。其设计目的是为了进一步简化Spring应用的搭建及开发过程。Spring Boot 可以轻松创建独立的、生产级的基于 Spring 的应用程序，您可以“直接运行”这些应用程序。我们对 Spring 平台和第三方库采取了固执的观点，因此您可以轻松上手。大多数 Spring Boot 应用程序需要最少的 Spring 配置。所以技术是完全可行的。
三，系统展示 博客前台
用户注册和登录
手机验证码登录：
本博客的特点是可以设置收费的博文和免费的博文，查看收费的博文需要从个人账户中扣费
个人中心中可以绑定自己的银行卡并进行在线充值和提现
提现
发布博文时可以选择收费或是免费的
博文分类浏览
阅读排行榜
我的收藏
浏览记录
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/330f6ea3977c00a735fb4bb4dd3f22cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0018417aaa0f51c66fec54f59375b8d7/" rel="bookmark">
			MyBatis-Puls如何处理Json数据类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MyBatis Puls中已经定义了三种处理方式：FastjsonTypeHandler，GsonTypeHandler，JacksonTypeHandler我们可以直接使用。
在对应的位置添加属性 autoResultMap = true和typeHandler = FastjsonTypeHandler.class即可。
方式一、
import com.alibaba.fastjson.JSONArray; import com.baomidou.mybatisplus.annotation.TableField; import com.baomidou.mybatisplus.annotation.TableName; import com.baomidou.mybatisplus.extension.activerecord.Model; import java.io.Serializable; import com.baomidou.mybatisplus.extension.handlers.FastjsonTypeHandler; @TableName(value = "sys_user", autoResultMap = true) public class SysUser extends Model&lt;SysUser&gt;{ private Integer id; private String userName; @TableField(typeHandler = FastjsonTypeHandler.class) private JSONArray roles; } 方式二、
&lt;resultMap id="sysUserMap" type="com.jayknoxqu.entity.SysUser" autoMapping="true"&gt; &lt;id column="user_id" property="userId"/&gt; &lt;result column="user_name" property="userName"/&gt; &lt;result column="roles" property="role" typeHandler="com.baomidou.mybatisplus.extension.handlers.FastjsonTypeHandler"/&gt; &lt;/resultMap&gt; 方式三、
异常：Data truncation: Cannot create a JSON value from a string with CHARACTER SET ‘binary’
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0018417aaa0f51c66fec54f59375b8d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c791e86b39417a79a1dc127018c295f/" rel="bookmark">
			微服务系列文章之 Springboot&#43;Vue实现登录注册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、springBoot 创建springBoot项目
分为三个包，分别为controller，service， dao以及resource目录下的xml文件。
添加pom.xml 依赖
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.7.9&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.devops&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-vue&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring-boot-vue&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- mybatis 支持 SpringBoot --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql 驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c791e86b39417a79a1dc127018c295f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95a3b61b1bd3f8b5cc8f44dc237c9ce2/" rel="bookmark">
			批量拉取git仓库的shell脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#!/bin/bash # 定义要克隆的仓库列表 REPO_LIST=( "test1-rep" "test2-rep" ) # 遍历仓库列表，并克隆到当前目录 for repo in "${REPO_LIST[@]}"; do git clone git@gitee.com:username/$repo.git done # 显示克隆成功的提示 echo "克隆成功！" 执行前需要给执行权限
chmod +x clonerep.sh
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e46aea712d1664fde7fe7c0a064ac28d/" rel="bookmark">
			Unity进阶–通过PhotonServer实现人物移动和攻击–PhotonServer(五)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Unity进阶–通过PhotonServer实现人物移动和攻击–PhotonServer(五)DLc： 消息类和通信类服务器客户端 Unity进阶–通过PhotonServer实现人物移动和攻击–PhotonServer(五) DLc： 消息类和通信类 Message
namespace Net { public class Message { public byte Type; public int Command; public object Content; public Message() { } public Message(byte type, int command, object content) { Type = type; Command = command; Content = content; } } //消息类型 public class MessageType { //unity //类型 public static byte Type_UI = 0; //账号登录注册 public const byte Type_Account = 1; //用户 public const byte Type_User = 2; //攻击 public const byte Type_Battle = 3; //注册账号 public const int Account_Register = 100; public const int Account_Register_Res = 101; //登陆 public const int Account_Login = 102; public const int Account_Login_res = 103; //角色部分 //选择角色 public const int User_Select = 204; public const int User_Select_res = 205; public const int User_Create_Event = 206; //删除角色 public const int User_Remove_Event = 207; //攻击和移动 //移动point[] public const int Battle_Move = 301; //移动响应id point[] public const int Battle_Move_Event = 302; //攻击 targetid public const int Battle_Attack = 303; //攻击响应id targetid 剩余血量 public const int Battle_Attack_Event = 304; } } peer类
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e46aea712d1664fde7fe7c0a064ac28d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1566a4f21a9b1682b76495429c95d1c4/" rel="bookmark">
			CNN之图像识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是图像识别 • 图像识别技术是信息时代的一门重要的技术，其产生目的是为了让计算机代替人类去处理大量的物理信息。随着计算机技术的发展，人类对图像识别技术的认识越来越深刻 • 图像识别技术的定义为利用计算机对图像进行处理、分析和理解，以识别不同模式的目标和对象的技术 • 图像识别技术的过程分为信息的获取、预处理、特征抽取和选择、分类器设计和分类决策 举个栗子： 好看不？
卧槽，真好看！这进气格栅，这前铲，真大！
臭直男，就知道看车！
那不然呢，这可是AMG GTR诶
......
对象1：奔驰AMG GTR
对象2：妹子
那么问题来了，人眼一眼就能分辨，但是计算机如何分辨呢？
模式识别 • 模式识别是人工智能和信息科学的重要组成部分。模式识别是指对表示事物或现象的不同形式的信息做分析和处理从而得到一个对事物或现象做出描述、辨认和分类等的过程。 • 计算机的图像识别技术就是模拟人类的图像识别过程。在图像识别的过程中进行模式识别是必不可少的。 • 模式识别原本是人类的一项基本智能。但随着计算机的发展和人工智能的兴起，人类本身的模式识别已经满足不了生活的需要，于是人类就希望用计算机来代替或扩展人类的部分脑力劳动。这样计算机的模式识别就产生了。 • 简单地说，模式识别就是对数据进行分类，它是一门与数学紧密结合的科学，其中所用的思想大部分是概率与统计。 还是上图为例，要准确识别出车和车模，就需要大量的车和人的图片对计算机进行训练，让它知道车的特征和人的特征，然后去进行区分
图像识别的过程 1. 信息的获取： 是指通过传感器，将光或声音等信息转化为电信息。也就是获取研究对象的基本信息并通过某种方法将其转变为机器能够认识的信息。 2. 预处理： 主要是指图像处理中的去噪、平滑、变换等的操作，从而加强图像的重要特征。图像增强。 3. 特征抽取和选择： 是指在模式识别中，需要进行特征的抽取和选择。特征抽取和选择在图像识别过程中是非常关键的技术之一。 4. 分类器设计： 是指通过训练而得到一种识别规则，通过此识别规则可以得到一种特征分类，使图像识别技术能够得到高识别率。分类决策是指在特征空间中对被识别对象进行分类，从而更好地识别所研究的对象具体属于哪一类。 分类与检测 当机器看到这张图的时候，首先就要确定这张图片是什么？风景？人物？事物？美食？...这就是分类
当确定类型之后，就要对图中的对象进行进一步检测了，红色框是车模，绿色框是车，这就是检测出来的结果。
物体分类与检测在很多领域得到广泛应用，包括安防领域的人脸识别、行人检测、智能视频分析、行人跟踪等，交通领域的交通场景物体识别、车辆计数、逆行检测、车牌检测与识别，以及互联网领域的基于内容的图像检索、相册自动归类等。 自动驾驶，最常见，最直观。 常见的卷积神经网络 VGG（VGG16） VGG之所以经典，在于它首次将深度学习做得非常“深”，达到了16-19层，同时，它用了非常“小”的卷积核（3X3）。 哇，这个结构的艺术成分很高啊
有多高啊
洪家铁线圈大师的强力推荐（敢说不好，打屎你，以德服人）
来看下它的结构： 具体的过程：
1：输入图像尺寸为224x224x3，经64个通道为3的3x3的卷积核，步长为1，padding=same填充，卷积两次，再经ReLU激活，输出的尺寸大小为224x224x64
2：经max pooling（最大化池化），滤波器为2x2，步长为2，图像尺寸减半，池化后的尺寸变为112x112x64
3：经128个3x3的卷积核，两次卷积，ReLU激活，尺寸变为112x112x128
4：max pooling池化，尺寸变为56x56x128
5：经256个3x3的卷积核，三次卷积，ReLU激活，尺寸变为56x56x256
6：max pooling池化，尺寸变为28x28x256
7：经512个3x3的卷积核，三次卷积，ReLU激活，尺寸变为28x28x512
8：max pooling池化，尺寸变为14x14x512
9：经512个3x3的卷积核，三次卷积，ReLU，尺寸变为14x14x512
10：max pooling池化，尺寸变为7x7x512
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1566a4f21a9b1682b76495429c95d1c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fb627a7c82712c646bc508ff7470b16/" rel="bookmark">
			【Oracle客户端】PLSQL Developer 15 (64 bit)最新版安装使用教程（亲测）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 PLSQL Developer 15 和下载我的信息序列号环境变量1.乱码解决2.数据库实例3.tnsnames.ora 软件内部TNS名称 PLSQL Developer 15 和下载 instantclient-basic-windows.x64-21.7.0.0.0dbru都在里面
通过百度网盘分享的文件：PLSQL De…
链接:https://pan.baidu.com/s/1vhyDHs8XE0En4g3W7LAR4g?pwd=w29c 提取码:w29c复制这段内容打开「百度网盘APP 即可获取」
我的信息 数据库用户为xcc
ip是192.168.220.133
序列号 product code : ke4tv8t5jtxz493kl8s2nn3t6xgngcmgf3 serial Number: 264452 password: xs374ca 或者也可用下面这个 product code: 4vkjwhfeh3ufnqnmpr9brvcuyujrx3n3le serial number: 226959 password: xs374ca 环境变量 1.乱码解决 NLS_LANG SIMPLIFIED CHINESE_CHINA.ZHS16GBK 2.数据库实例 ORACLE_HOME
D:\edge\instantclient-basic-windows.x64-21.7.0.0.0dbru\instantclient_21_7
3.tnsnames.ora TNS_ADMIN
D:\edge\instantclient-basic-windows.x64-21.7.0.0.0dbru\instantclient_21_7\network\admin ORCL = (DESCRIPTION = (ADDRESS_LIST = (ADDRESS = (PROTOCOL = TCP)(HOST = 服务器ip)(PORT = 1521)) ) (CONNECT_DATA = (SERVICE_NAME = ORCL) ) ) 出现以下ORCL就说明，文本内容没错，环境变量也没错
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fb627a7c82712c646bc508ff7470b16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/465d86a848afa4cca14a2b8ce065f50a/" rel="bookmark">
			架构师必备--高可用高性能分布式数据库Tidb安装部署实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文针对分布式、高可用的tidb数据库，从搭建实际生产环境的集群服务，介绍下tidb的安装流程、安装前的环境检测和系统优化、服务访问等方面介绍下具体的流程，希望对大家熟悉和了解tidb数据库有所帮助，减少不必要的弯路。
1.概述 Tidb是PingCAP公司自主设计、研发的开源分布式关系型数据库，同时支持在线事务处理与在线分析处理(HTAP)的融合型分布式数据库产品,具备水平扩容或者缩容、金融级高可用。TiDB 适合高可用、强一致要求较高、数据规模较大等各种应用场景。
2.硬件要求 生产环境最低要求如下：
开发及测试最低要求如下：
以上是tidb数据库的常用组件，本文只安装tidb、pd、tikv和监控组件
3.安装前环境检查及系统优化 3.1 磁盘挂载 生产环境部署，建议使用 EXT4 类型文件系统的 NVME 类型的 SSD 磁盘存储 TiKV 数据文件。这个配置方案为最佳实施方案，其可靠性、安全性、稳定性已经在大量线上场景中得到证实。
使用root用户登录目标机器，将部署目标机器数据盘格式化成 ext4 文件系统，挂载时添加nodelalloc和noatime挂载参数。nodelalloc是必选参数，否则 TiUP 安装时检测无法通过；noatime是可选建议参数。
注意
如果你的数据盘已经格式化成 ext4 并挂载了磁盘，可先执行 umount /dev/nvme0n1p1 命令卸载，从编辑 /etc/fstab 文件步骤开始执行，添加挂载参数重新挂载即可。
3.1.1查看数据盘 fdisk -l 3.1.2创建分区 parted -s -a optimal /dev/nvme0n1 mklabel gpt -- mkpart primary ext4 1 -1 注意
使用 lsblk 命令查看分区的设备号：对于 nvme 磁盘，生成的分区设备号一般为 nvme0n1p1；对于普通磁盘（例如 /dev/sdb），生成的分区设备号一般为 sdb1。
3.1.3格式化文件系统 mkfs.ext4 /dev/nvme0n1p1 3.1.4查看数据盘分区 UUID lsblk -f 3.1.5编辑 /etc/fstab 文件 添加 nodelalloc 挂载参数。 执行如下命令进入fstab文件，然后将文本添加到最后一行并保存
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/465d86a848afa4cca14a2b8ce065f50a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47c5a7690c352e2152175272720ba49f/" rel="bookmark">
			python微信PC端自动化-获取消息发送时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 之前我们讲了如何利用python自动获取微信聊天记录，感兴趣的小伙伴可查看我之前的文章。不过，之前的方法都只获取了微信的聊天内容，有些场景或项目中可能需要我们记录各条消息的发送时间。这一节我们来看一下如何获取微信聊天消息的发送时间。
项目准备 1. 微信PC客户端
（注：这里最好把微信客户端升级至较新版本）
2. python3.x
3. wxauto
pip install wxauto -i https://pypi.tuna.tsinghua.edu.cn/simple
具体方法 在wxauto.py中，有这么一段代码，用于解析微信聊天窗口中的一些系统消息，如：消息发送时间、撤回信息、“某某邀请某某入群”等等。
def SplitMessage(MsgItem): uia.SetGlobalSearchTimeout(0) MsgItemName = MsgItem.Name if MsgItem.BoundingRectangle.height() == WxParam.SYS_TEXT_HEIGHT: Msg = ('SYS', MsgItemName, ''.join([str(i) for i in MsgItem.GetRuntimeId()])) elif MsgItem.BoundingRectangle.height() == WxParam.TIME_TEXT_HEIGHT: Msg = ('Time', MsgItemName, ''.join([str(i) for i in MsgItem.GetRuntimeId()])) elif MsgItem.BoundingRectangle.height() == WxParam.RECALL_TEXT_HEIGHT: if '撤回' in MsgItemName: Msg = ('Recall', MsgItemName, ''.join([str(i) for i in MsgItem.GetRuntimeId()])) else: Msg = ('SYS', MsgItemName, ''.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47c5a7690c352e2152175272720ba49f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd68828b23eaa768d4a6ae01fa26b30d/" rel="bookmark">
			解决pycocotools的安装问题：No module named pycocotools
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题解决过程 为了实现目标检测模型fast_rcnn，准备使用coco数据集进行模型的训练，这里需要导入coco数据集，并且进行数据集处理。
import torch import torchvision import torch.utils.data from pycocotools.coco import COCO def convert_to_coco_api(ds): coco_ds = COCO() # annotation IDs need to start at 1, not 0 ann_id = 1 dataset = {'images': [], 'categories': [], 'annotations': []} categories = set() for img_idx in range(len(ds)): # find better way to get target hw, targets = ds.coco_index(img_idx) image_id = targets["image_id"].item() img_dict = {} img_dict['id'] = image_id img_dict['height'] = hw[0] img_dict['width'] = hw[1] dataset['images'].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd68828b23eaa768d4a6ae01fa26b30d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2668af008863eed54d8100e4549895bb/" rel="bookmark">
			Redis高可用：哨兵机制（Redis Sentinel）详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.什么是哨兵机制（Redis Sentinel）
2.哨兵机制基本流程
3.哨兵获取主从服务器信息
4.多个哨兵进行通信
5.主观下线和客观下线
6.哨兵集群的选举
7.新主库的选出
8.故障的转移
9.基于pub/sub机制的客户端事件通知
1.什么是哨兵机制（Redis Sentinel） Redis Sentinel，即Redis哨兵，在Redis 2.8版本开始引入。哨兵的核心功能是主节点的自动故障转移。
哨兵机制（sentinel）是Redis解决高可用的一种解决方案：它是由一个或者多个sentinel 实例组成的一个sentinel 系统。
下图是一个典型的哨兵集群监控的逻辑图：
哨兵实现了什么功能呢？下面是Redis官方文档的描述：
监控（Monitoring）：哨兵会不断地检查主节点和从节点是否运作正常。自动故障转移（Automatic failover）：当主节点不能正常工作时，哨兵会开始自动故障转移操作，它会将失效主节点的其中一个从节点升级为新的主节点，并让其他从节点改为复制新的主节点。配置提供者（Configuration provider）：客户端在初始化时，通过连接哨兵来获得当前Redis服务的主节点地址。通知（Notification）：哨兵可以将故障转移的结果发送给客户端。 其中，监控和自动故障转移功能，使得哨兵可以及时发现主节点故障并完成转移；而配置提供者和通知功能，则需要在与客户端的交互中才能体现。 2.哨兵机制基本流程 sentinel(哨兵机制)其实就是一个运行在特殊模式下的Redis服务器。
在服务器初始化时，普通Redis服务器初始化时会通过载入RDB文件或者AOF文件来恢复数据库状态，而sentinel服务器由于不使用数据库，所以它在初始化时无需载入RDB文件或者AOF文件。
我们先看监控。监控指的就是哨兵进程运行时，它会周期性地心跳检测，检测所有主从服务器是否正常运行。心跳检测方式为周期性向主从服务器发送PING命令，若主从服务器在规定时间内响应哨兵进程，则判断该服务器处于存活状态；若主从服务器在规定时间内没有响应哨兵进程，则哨兵进程会判定其下线。
如下图所示，主服务器server2在规定时间内未响应sentinel进程，则sentinel进程判断主服务器server2主观下线，进行选举操作。
若主服务器处于下线状态时，哨兵进程会进行故障转移，也就是重新选主。选主就是会从其所属的多个从服务器中选举一个服务器作为新的主服务器，来提供服务。选举成功后，哨兵进程让已下线主服务器属下的所有从服务器去复制新的主服务器，这一动作会通过向从服务器发送SLAVEOF命令来实现。
如下图，则展示了在故障转移操作中，server1已下线server2选举成为主节点,sentinel节点向已下线主服务器server1的两个从服务器server3发送SLAVEOF命令，进行复制新的主服务器数据信息。
若旧的主服务器重新启动后，会成为新的主服务器的从服务器。
如下图所示，旧主服务器server1重新启动后，会默认成为新主服务器server2的从服务器，进行运行。
哨兵选举出新的主服务器后，会将新主服务器信息发送给客户端，让它和新的主服务器建立连接就行，并不涉及决策的逻辑。但是，在监控和选举过程中，哨兵需要做出两个决策：一个是判断主库是否下线；第二个是在选举过程中，选举哪个从服务器作为新的主服务器，提供服务。 3.哨兵获取主从服务器信息 sentinel(哨兵)进程默认会以每隔10秒一次的频率，通过命令连接向被连接的主服务器发送INFO命令，并通过分析INFO命令返回的数据来获取主服务器的当前信息以及所属从服务器信息。
如下图所示，主服务器server2和其三个从服务器server1、server3、server4。sentinel进程会向主服务器server2发送INFO命令，主服务器会返回对应的主服务器和从服务器的信息。
同理，sentinel进程也会向从服务器发送INFO命令，获取从服务器对应的节点信息。频率默认10秒一次。
4.多个哨兵进行通信 在哨兵集群下，哨兵实例进行通信，是基于Redis提供的pub/sub机制的，也就是发布/订阅模式。
在主从集群中，哨兵节点不会直接与其他哨兵节点建立连接，而是首先会和主库建立起连接，然后向一个名为"_sentinel_:hello"频道发送自己的信息（IP+port），其他订阅了该频道的哨兵节点就会获取到该哨兵节点信息，从而哨兵节点之间互知。
通俗讲，Redis哨兵模式中，哨兵节点的互通是通过订阅指定的频道来进行的，而不是直接与其他sentinel节点建立起连接。
举个例子，假如现在有sentinel1、sentinel2、sentinel3三个sentinel在监控同一个服务器，那么当sentinel1向主服务器的_sentinel_:hello频道发送一条信息时，所有订阅了_sentinel_:hello频道的sentinel(包含sentinel自己在内)都会收到这条消息。如下图所示：
当一个sentinel从_sentinel_:hello频道收到一条消息后，sentinel会对这条信息进行分析，提取出信息中的sentinel IP地址、sentinel端口号、sentinel运行ID等八个参数，并进行检查：
如果信息中记录的sentinel运行ID和接收信息的sentinel的运行ID相同，那么说明这条消息是sentinel自己发送的，sentinel将丢失这条信息，不做进一步处理。
相反地，如果信息记录的sentinel运行ID和接收信息的sentinel的运行ID不相同，那么说明这条信息是监控同一个服务器的其他sentinel发来的，接收信息的sentinel将根据信息中的各个参数，对相应主服务器的实例结构进行更新。 5.主观下线和客观下线 哨兵如何判断主库已经下线了呢？
主观下线：任何一个哨兵都是可以监控探测，并作出Redis节点下线的判断；客观下线：有哨兵集群共同决定Redis节点是否下线； 首先先解释一下什么是"主观下线"。
哨兵进程会使用PING命令的方式来检测各个主库和从库的网络连接情况，用来判断实例状态。如果哨兵发现主库或者从库响应超时，那么哨兵会判定其为"主观下线"。
如果哨兵检测从库，发现从库在规定时间内未响应，那么哨兵就会把它标记为"主观下线"，因为从库的下线影响一般不太大，集群的对外服务不会间断。但是，如果检测主库，哨兵不会简单把它标记为"主观下线"，开启主从切换。
因为很有可能会有一种特殊情况：哨兵误判。也就是说主库本身没有故障，但由于哨兵的误判，判断它为下线状态。一旦启动主从切换，后续的选举和通知操作都会带来额外的计算和通信开销。因此，为了不必要开销，我们要严格注意误判的情况。
在哨兵集群中，判定主库是否处于下线状态，不是由一个哨兵来决定的，而是只有大多数哨兵认为主库已经"主观下线"，主库才会标记为"客观下线"。这种判断机制为：少数服从多数。同时会触发主从切换模式。
举个例子，现在有sentinel1、sentinel2、sentinel3三个哨兵和master1一个主库和slave1、slave2、slave3三个从服务器。但sentinel1和sentinel2 判断master1处于上线状态，而sentinel3判断master1处于"主观下线"，那么最终master1仍然为上线状态。
简单的来说，"客观下线"的标准为，当有N个实例，最好要有N/2+1个哨兵实例认为其"主观下线"，那么主库才是"客观下线"。这样的好处减少了误判的概率，避免了不必要的开销。(当然，有多个实例做出"主线下线"的判断才可以，也可以由Redis管理员自行设定)
6.哨兵集群的选举 判断完主库下线后，由哪个哨兵节点来执行主从切换呢？这里就需要哨兵集群的选举机制了。
为什么必然会出现选举/共识机制？ 为了避免哨兵的单点情况发生，所以需要一个哨兵的分布式集群。作为分布式集群，必然涉及共识问题（即选举问题）；同时故障的转移和通知都只需要一个主的哨兵节点就可以了。
哨兵的选举机制是什么样的？ 哨兵的选举机制其实很简单，就是一个Raft选举算法： 选举的票数大于等于num(sentinels)/2+1时，将成为领导者，如果没有超过，继续选举
任何一个想成为 Leader 的哨兵，要满足两个条件： 第一，拿到半数以上的赞成票；第二，拿到的票数同时还需要大于等于哨兵配置文件中的 quorum 值。 以 3 个哨兵为例，假设此时的 quorum 设置为 2，那么，任何一个想成为 Leader 的哨兵只要拿到 2 张赞成票，就可以了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2668af008863eed54d8100e4549895bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/336c2052c3cd27af798c747392985dc3/" rel="bookmark">
			【CSS菜谱】使用纯CSS样式实现加号等符号图标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、加号图标➕ （一）效果展示 （二）原料 主要使用了CSS的伪类机制，即【::befor】和【::after】以及一个标签：【div】、【p】、【image】、【view】等等均可以涉及的属性在后面会具体说明 （三）烹饪 1、设置标签，以div为例 &lt;div class="add"&gt;&lt;/div&gt; 2、设置标签样式 .add { /* 重点属性。absolute或者relative，主要是为了给伪类定位 */ position: relative; width: 150rpx; height: 150rpx; /* 设置圆角 */ border-radius: 50%; /* 设置边框及颜色 */ border: 2rpx solid #5e5e5e; /* 设置背景底色 */ background-color: #c9c9c9; } 效果：
3、画个“横” 这里使用伪类before和其border-top来设置
.add::before { content: ''; /* 使用绝对定位*/ position: absolute; /* 通过left、top设置居中 */ left: 50%; top: 80rpx; /* 左右长度 */ width: 110rpx; margin-left: -55rpx; margin-top: -10rpx; /* 横线厚度 */ border-top: 10rpx solid; /* 颜色 */ color: #dfdfdf; } 效果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/336c2052c3cd27af798c747392985dc3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cd81d113b53dc8064966d4e911078e0/" rel="bookmark">
			IDEA操作小技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		快速的查看选中类, 选中方法的定义 有的时候我们不想进入方法内部, 或者进入类的内部查看细节, 想要在外面就探查清楚, 就可以使用此种方法 ctrl + shift + i 选中当前单词(非常好用)
ctrl + w 列出当前类的所有方法及变量
ctrl + F12 在多个不同的地方添加光标，插入内容 ctrl + shift + 鼠标左键点击 Ctrl + ALT + Enter: 在当前行之前开始新行；
alt + shift + 左键点击： 添加多个光标位置；
ctrl + alt + shift + left/right：向左右延伸代码窗口大小；
ctrl + alt + shift + up/down：向上下延伸控制台窗口大小；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/629c705a63cdd77f9a869b371b2c0be1/" rel="bookmark">
			ffmpeg教程：视频切片与合并，加密与解密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、ffmpeg安装教程
1.1 下载地址
1.2 ffmpeg环境配置
2、视频分割成ts文件
2.1 准备mp4文件
2.2 打开当前目录cmd命令窗口
3、根据m3u8文件合并ts文件
3.1 准备文件
3.2 输入命令
4、视频切片与加密
4.1 下载安装openssl
4.2 配置openssl
4.3 生成密钥
4.4 生成IV
4.5 编写keyinfo文件
4.6 切片与加密命令
4.7 m3u8文件解释
5、解密与合并
5.1 文件准备(来自第四部分)
5.2 解密合并命令
1、ffmpeg安装教程 1.1 下载地址 Releases · BtbN/FFmpeg-Builds (github.com)
1.2 ffmpeg环境配置 复制ffmpeg解压后的路径
配置ffmpeg环境变量:高级系统设置&gt;环境变量&gt;双击系统变量Path&gt;新建&gt;粘贴&gt;确认
2、视频分割成ts文件 2.1 准备mp4文件 part.mp4
2.2 打开当前目录cmd命令窗口 输入命令：
ffmpeg -i part.mp4 -c:v libx264 -c:a aac -strict -2 -f hls -hls_list_size 0 -hls_time 5 part.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/629c705a63cdd77f9a869b371b2c0be1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/491ad58fee2e56bc2ccdbd8284b990d0/" rel="bookmark">
			（转载）CSS3实现缺角矩形，折角矩形以及缺角边框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(转载)CSS3实现缺角矩形，折角矩形以及缺角边框
https://www.jb51.net/css/707136.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1d4a91ac7773a10f8e3047eac5e0c46/" rel="bookmark">
			mysql 主从错误处理：unblock with ‘mysqladmin flush-hosts‘ 和 Slave has more GTIDs than the master has
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		昨天一次插入 10W 条记录、卡死了怎么办，发现从服务器状态错误，因为中途曾经几次 kill process，现在数据没有同步，状态也不对了！
20230818 又一次处理 unblock with ‘mysqladmin flush-hosts’ 之前怎么会处理的那么复杂？
许久不查看 replica，今天查看的时候发现错误了
Last_IO_Error: Error reconnecting to source 'root@192.168.0.201:3306'. This was attempt 2077/86400, with a delay of 60 seconds between attempts. Message: Host '192.168.0.195' is blocked because of many connection errors; unblock with 'mysqladmin flush-hosts' 处理方法
提示信息中已经告知处理方法 ： unblock with ‘mysqladmin flush-hosts’
我还傻乎乎转了一圈
1). 在 master mysql&gt; flush hosts; Query OK, 0 rows affected, 1 warning (0.08 sec) 2).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1d4a91ac7773a10f8e3047eac5e0c46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dddb66ee1da8316158fbecc1c1ca2c8/" rel="bookmark">
			LLaMA模型泄露 Meta成最大受益者
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一份被意外泄露的谷歌内部文件，将Meta的LLaMA大模型“非故意开源”事件再次推到大众面前。“泄密文件”的作者据悉是谷歌内部的一位研究员，他大胆指出，开源力量正在填平OpenAI与谷歌等大模型巨头们数年来筑起的护城河，而最大的受益者是Meta，因为该公司2月意外泄露的LLaMA模型，正在成为开源社区训练AI新模型的基础。
几周内，开发者与研究人员基于LLaMA搞起微调训练，接连发布了Alpaca、Vicuna、Dromedary等中小模型，不只训练成本仅需几百美元，硬件门槛也降低至一台笔记本电脑甚至一部手机，测试结果不比GPT-4差。除了AI模型之外，FreedomGPT等类ChatGPT应用也如雨后春笋般涌现，基于LLaMa的“羊驼家族”不断壮大，这位研究员认为，Meta很可能借此形成生态，从而成为最大赢家。事实上，人工智能的世界里，的确有一部分进入了“安卓时刻”，这个部分就是开源社区。
ChatGPT引爆AI热后，英伟达的CEO黄仁勋将这股浪潮喻为“AI的iPhone时刻”，他认为，AI行业进入了如iPhone诞生颠覆手机行业时的革命性时间点。而当LLaMA开启开源社区的小宇宙后，网友认为，“AI的安卓时刻”来了。 回顾过去，谷歌曾以开源思想让更多的开发者参与到安卓应用生态的建设中，最终让安卓成为电脑与手机的系统/应用主流。如今，LLaMA再次让AI业内看到了开源力量的强大。
特斯拉前AI主管Andrej Karpathy认为：“当前开源大模型的生态之势，已经有了寒武纪大爆发的早期迹象。”确实，开发者对开源的AI模型前所未有的热情正在从Github的打星量指标中溢出：Alpaca获得了23.2k星，llama.cpp获26.3k星，LLaMA获20.8k星……而在“羊驼家族”之前，AutoGPT等开源项目也在Github拥有超高的人气，突破100k星。
此外，为了追赶 ChatGPT，构建大型开源社区的 AI 初创公司Hugging Face 也在近日推出了开源聊天机器人HuggingChat，该机器人的底层模型拥有300 亿个参数，并对外开放了训练数据集。英伟达 AI 科学家 Jim Fan认为，如果后续开发应用程序，Hugging Face将比 OpenAI 更具优势。
开源力量来势汹汹。在不久前的微软Inspire合作伙伴大会上，Meta方面宣布将与包括微软在内的主要云计算服务提供商合作，正式推出新一代开源大模型Llama 2，并将该模型免费开放给商业和研究机构使用。如今回过头来看，Llama的泄露很有可能是Meta有意而为之，并借此来试探社区对于开源大模型的态度，而在得到了社区身体力行的支持后，Llama 2也就很快诞生了。
相关素材整理于《大模型遭泄两月后 Meta意外变赢家》一文
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5625f1a1a53da08c1dbdcfd2b70bc70/" rel="bookmark">
			数据质量指标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据质量指标 1）数据准确性
数据准确性（Accuracy）：指数据采集或者观测值和真实值之间的接近程度，亦可称作误差值，误差越大，准确度越低。
数据中记录的信息和数据是否准确，数据记录的信息是否存在异常或错误。准确性关注的是数据记录中存在的错误，如字符型数据的乱码现象就存在着准确性的问题，还有就是异常的数值：异常大或者异常小的数值、不符合有效性要求的数值等。
2）数据的精确性
数据的精确性（Precision）：指对同一对象的观测数据在重复测量时所得到不同数据间的接近程度。精确性，也可以叫精准性。精确性与我们数据采集的精度有关系。精度高，要求数据采集的粒度越细，误差的容忍程度越低。
例如测量人的身高，我们可以精确到厘米，多次测量差异只会在厘米级别；测量两个地区的距离，我们精确到公里，多次测量结果间的差异会在公里级别；采用游标卡尺测量一个零件的厚度，可以精确到1/50毫米，多次测量的结果间的误差也只会在1/50毫米间。采用的测量方法和手段直接影响着数据的精确性。
3）数据的真实性
数据的真实性，也叫数据的正确性(Rightness)。数据的正确性取决于数据采集过程的可控程度，可控程度高，可追溯情况好，数据的真实性容易得到保障，而可控程度低或者无法追溯，数据造假后无法追溯，则真实性难以保证。为了提高数据的真实性，采用无人进行过程干涉的智能终端直接采集数据，能够更好地保证所采集数据的真实性，减少人为干预，减少数据造假，从而让数据更加正确地反应客观事物。
4）数据的及时性
数据的及时性（In-time）：指数据能否在需要的时候得到保证。
例如月初会对上个月的经营和管理数据进行统计汇总，这些数据能否及时处理完成，财务能否在月度关账后及时核算。数据的及时性是我们数据分析和挖掘及时性的保障。如果公司的财务核算复杂，核算速度缓慢，上个月的数据在月中才能统计汇总完成，等需要调整财务策略的时候，已经到了月底了，一个月已经快过完了。
当公司做大了之后，业务覆盖多个市场，多个国家数据不能及时汇总，会影响到高层决策的及时程度，数据的及时性与企业数据处理的速度和效率有直接的关系，为了提高数据的及时性，越来越多的公司采用管理信息系统，并在管理信息系统中附加各种自动数据外理功能，能够在数据上传系统之后自动完成绝大部分报表，从而保证数据外理的效率。
计算机自动外理中间层数据是提高企业数据处理效率的有效手段。除了保证数据采集的及时性和数据外理的效率问题外，还需要从制度和流程上保证数据传输的及时性，数据报表完成了，要及时或者在要求的时间范围内发送到指定的部门，或者上传到指定的存储空间。
5）数据的即时性
指数据采集时间节点和数据传输的时间节点，一个数据在数据源头采集后立即存储，并立即加工呈现，就是即时数据，而经过一段时间之后再传输到信息系统中，则数据即时性就稍差。
例如微博的数据采集，当用户发布了微博，数据立即能够被抓取和加工，会生成即时微博数据报告，并随着时间推移，数据不断变化，我们可以称作是即时采集和处理的。
一个生产设备的仪表即时反应着设备的温度、电压、电流、气压等数据，这些数据生成数据流，随时监控设备的运行状况，这个数据可以看作是即时数据。而当设备的即时运行数据存储下来，用来分析设备运行状况与设备寿命的关系，这些数据就成为历史数据。
6）数据的完整性
数据的完整性是从数据采集到的程度来衡量的，是应采集和实际采集到数据之间的比例。
比如一条信息采集12个数据点，如我们采集员工信息数据的时候，要求填写姓名，出生日期，性别，民族、籍贯，身高、血型、婚姻状况，最高学历，最高学历专业、最高学历毕业院校、最高学历毕业时间等12项信息，而某一员工仅仅填写了部分信息，如只填写了其中的5项，则该员工所填写数据的完整性只有一半。
一个公司数据的完整性体现着这个公司对数据的重视程度。要求采集数据而实际上并未完整采集，只采集了一部分，这就是不完整的，往往是公司对数据采集质量要求不到位导致的。公司要求每个人都填写完整的个人信息表，而有部分员工拒绝填写，公司2000员工，只有1200人填写了完整的个人信息表，则这个数据集就是不完整的。数据的完整性较差对后续分析决策有较大影响。
另外，对干动态数据，还要从时间轴上去衡量数据采集的完整性。比如，我们要求每小时采集一次数据，每天会形成24个数据点，每日采集的有24条数据，但是由于机器在此期间有故障，只采集了20次，那么这个数据集也是不完整的。
7）数据的全面性
数据的全面性和完整性不同，完整性衡量的是应采集和实际采集的差异。而全面性指的是数据采集点的遗漏情况。
比如说，我们要采集员工行为数据，我们只采集了员工上班打卡和下班打卡的数据，上班时间的员工行为数据并未采集，或者没有找到合适的方法来采集。那么，这个数据集就是不全面的。
比如描述一个产品的包装，仅仅描述了产品包装的正面和背面，没有记录产品包装的侧面，则就是不全面的。我们记录一个客户的交易数据，我们只采集了客户订单中的产品、订单中产品的价格和数量，而没有采集客户送货地址，采购时间，这个数据采集就是不全面的。
比如腾讯QQ和微信的用户数据记录了客户交流沟通的数据；阿里和京东的用户数据记录了用户的购买交易数据；百度地图记录了用户出行的数据；大众点评和美团记录了客户餐饮娱乐的数据。对于全面描述一个人的生活的衣食住行各方面，这些公司的数据都是不全面的，而如果把他们的数据整合起来，则会形成更加全面的数据。所以说，数据的全面性是一个相对的概念。过度追求数据的全面性是不现实的。
8）数据的关联性
数据的关联性是指各个数据集之间的关联关系。
比如员工工资数据和工绩效考核数据是通过员工这个资源关联在一起来的，而且绩效数据直接关系到工资的多少。采购订单数据与生产订单数据之间通过物料的追溯机制进行关联，而生产订单又是由员工完成的，即通过员工作业数据与员工信息数据关联起来。
9）数据的时效性
例如数据在数据仓库中从贴源层（ods）到共享层（dwd）再到应用层(ads),数据从开始到应用层的处理和入库时间，在资源足够调度以及任务都正确，数据来源无问题的情况下相对时间短的时效性则高。
可对数据时延监控、报警、保障：衡量实时数据产出的延迟情况，设定报警阈值，超过阈值触发报警。并且需要对数据产出延迟有一个全链路的视角，保障数据产出延迟在预期范围内。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac92726723114692e411083325ba639a/" rel="bookmark">
			mybatis xml 批量插入 in查询 模糊like查询 字符串转时间区间查询等操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
in 查询：
模糊 like查询：
字符串转时间区间查询：
批量插入：
插入数据返回主键id
in 查询： @Test public void inSelect() { List&lt;Student&gt; list = new ArrayList&lt;&gt;(); Student student = new Student(); student.setName("小王"); Student student1 = new Student(); student1.setName("老王"); list.add(student); list.add(student1); List&lt;Student&gt; resultList = studentMapper.selectListWithList(list); System.out.println(JSONObject.toJSONString(resultList)); } &lt;!-- in 查询 --&gt; &lt;select id="selectListWithList" resultType="com.example.demo.entity.Student"&gt; select id,name,age,city,update_time updateTime from student where name in &lt;foreach collection="list" index="index" item="list" open="(" close=")" separator=","&gt; #{list.name} &lt;/foreach&gt; &lt;/select&gt; 模糊 like查询： @Test public void likeSelect() { Student student = new Student(); student.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac92726723114692e411083325ba639a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae8ce3e34735546bf8a1ced8b65cce84/" rel="bookmark">
			软件测试读后感
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		读了机械工业出版社的软件测试一书，得出如下在意的点。
1.软件测试在整个流程的占比 15% 左右，不知道数据是怎么来的，但是感觉这个过程比较符合现实的
2.软件测试人员需要其注意重源头解决问题，多经验的人尽早接入设计阶段，不要一味的在这个阶段去做测试设计，更多关注产品设计
3.产品测试总结文档，在产品阶段很容易疏忽，这个是pdca流程的关键所在
4.几个词 ：‘准确’ ‘精确’ ‘验证’ ‘确认’
5.公司过程很重要 ，需要QA，及cmm度比较成熟，当前公司看起来还只属于2级边缘。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d844b97f4ca19455694d2f4f2abf93a8/" rel="bookmark">
			1062：最高的分数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1062：最高的分数 时间限制: 1000 ms 内存限制: 65536 KB
提交数: 103077 通过数: 75401
【题目描述】 孙老师讲授的《计算概论》这门课期中考试刚刚结束，他想知道考试中取得的最高分数。因为人数比较多，他觉得这件事情交给计算机来做比较方便。你能帮孙老师解决这个问题吗？
【输入】 输入两行，第一行为整数n（1 &lt;= n &lt; 100），表示参加这次考试的人数.第二行是这n个学生的成绩，相邻两个数之间用单个空格隔开。所有成绩均为0到100之间的整数。
【输出】 输出一个整数，即最高的成绩。
【输入样例】 5 85 78 90 99 60 【输出样例】 99 【思路分析】
首先，读取输入的第一行整数 n，表示考试参加人数。接着，读取输入的第二行成绩，使用循环从第一个学生的成绩开始逐个读取，将当前的成绩存储到变量 a 中。在循环中，比较当前成绩 a 和最高成绩 max 的大小关系： 如果 a 大于 max，则更新 max 的值为 a。如果 a 不大于 max，则继续循环。循环结束后，输出最高成绩 max。 【示例代码】
#include&lt;bits/stdc++.h&gt; using namespace std; int main() { // 声明变量 n, a 和 max，分别表示参加考试人数、当前成绩和最高成绩 long long a, n, max=0; cin &gt;&gt; n; // 读取考试的参加人数 for(int i=1; i&lt;=n; i++) { cin &gt;&gt; a; // 读取当前学生的成绩 if(a &gt; max) { max = a; // 更新最高成绩 } } cout &lt;&lt; max &lt;&lt; endl; // 输出最高成绩 } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c97851e9cee757dd7e2984b09df4ddab/" rel="bookmark">
			VMware虚拟机扩展磁盘空间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在VMware虚拟机上使用Centos7，刚开始创建虚拟机时候磁盘空间设置小了，用久了发现虚拟机的磁盘空间不够了，可以通过以下步骤扩展磁盘空间。
1.先把虚拟机关机找到编辑虚拟机设置，操作如下 点击扩展后出现如下窗口
VMware会提示磁盘已成功扩展，您必须从客户机操作系统内部对磁盘重新进行分区和扩展文件系统。但是还没生效，需要在操作系统里面进行设置后才能使用。
2、启动操作系统Centos7，查看磁盘情况 输入指令
fdisk -l 找到如下文字
设备 Boot Start End Blocks Id System
/dev/sda1 * 2048 2099199 1048576 83 Linux
/dev/sda2 2099200 41943039 19921920 8e Linux LVM
目前是只有两个分区
3、创建第三个分区 输入指令
fdisk /dev/sda 出现如下情况
输入m查看帮助
可自行百度查翻译，我们注意看n那条，意思是添加新分区。我们输入n。
默认回车就行，出现如下代码时输入数字3
Partition number (3-4):3 # 输入3
后面的默认回车，最后输入w保存并退出
再次查看分区情况
fdisk -l 再次找到如下文字
设备 Boot Start End Blocks Id System
/dev/sda1 * 2048 2099199 1048576 83 Linux
/dev/sda2 2099200 41943039 19921920 8e Linux LVM
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c97851e9cee757dd7e2984b09df4ddab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad0e9c99a1139ebdc5a350538211aa59/" rel="bookmark">
			Tomcat启动闪退问题整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Tomcat启动闪退一般有以下几个原因：
1、JDK环境变量配置错误；
2、JDK版本与tomcat版本不匹配（一般jdk1.6，tomcat8.**这样可能会出现类似问题）
3、tomcat内存配置有误（Catalina文件内存配置有误）
4、端口被占用
解决方案： 1、JDK环境变量配置错误；
排查：
1）检查环境变量：cmd启动命令行窗口→通过cd命令到tomcat的bin目录下→运行startup.bat。可以帮助查看变量正确性；
2）打开startup.bat文件，在最后面加上：pause 然后，直接点击运行。也同样可以查看变量
如果是变量问题：
1.1）配置变量方法一：
在桌面上右键 我的电脑à属性à高级à环境变量à系统变量à新建/编辑 JAVA_HOME\ Path\ CLASSPATH三个环境变量:
1)JAVA_HOME: D:\Program Files\Java\jdk1.8
2)Path: %JAVA_HOME%\bin; %JAVA_HOME%\jre\bin;
3)CLASSPATH:D:\ProgramFiles\Java\jdk1.8\lib\tools.jar;D:\Program Files\Java\jdk1.8\lib\dt.jar;
Step3、检测配置是否成功：开始à运行à输入命令：java –version，显示具体的jdk版本,那么说明jdk安装成功.
1.2）配置变量方法二：
右键：startup.bat文件-》编辑，在最顶层加上环境变量代码：
set JAVA_HOME=C:\Program Files\Java\jdk1.8.0_181
set JRE_HOME=C:\Program Files\Java\jdk1.8.0_181\jre
set CATALINA_HOME=D:\apache-tomcat-7.0.92-windows-x64\apache-tomcat-7.0.92
2、JDK版本与tomcat版本不匹配
解决方案：升级JDK
3、tomcat内存配置有误（Catalina文件内存配置有误）
找到配置内存的语句，删除重新配置。
本人配置的语句为：set JAVA_OPTS=%JAVA_OPTS% -Xms512m -Xmx1024m -XX:PermSize=128M -XX:MaxNewSize=256m -XX:MaxPermSize=378m
4、端口被占用
netstat -ano | findstr “8080”
查看此端口是否被占用。如果被占，则：1）修改tomcat端口；2）将现在使用端口的程序kill掉。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c9a745417dc87e38cf9fb2923b9e227/" rel="bookmark">
			python使用xlwt，xlrd，xlutils模块操作Excel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python使用xlwt，xlrd，xlutils模块操作Excel 1.xlrd，xlwt，xlutilsc.copy模块概述开发者：Simplistix项目地址：https://www.python-excel.org/GitHub开源：https://github.com/python-excel 2.xlrd模块2.1 Note2.2 wb=xlrd.open_workbook('filename'，on_demand=True)2.3 Class xlrd.book.BookPropertyFunction 2.4 Class xlrd sheet.SheetPropertyFunction 2.5 Class xlrd.sheet.CellPropertyFunction 2.6 example 3.xlutils.copy模块nwb = copy(wb)example 4.xlwt模块4.1 Note4.2 xlwt.Workbook()4.3 Class xlwt.workbook.Workbook4.4 Calss xlwt.worksheet.Worksheet4.5 xlwt.XFStyle() 1.xlrd，xlwt，xlutilsc.copy模块概述 开发者：Simplistix 项目地址：https://www.python-excel.org/ GitHub开源：https://github.com/python-excel 2.xlrd模块 2.1 Note xlrd模块是Python用来读取".xls"和“.xlsx”格式的Excel文件的模块库。 我们主要用到的API是xlrd.open_workbook(filename)：用来打开我们的Excel工作簿文件[也就是workbook对象] 主要用到的对象/类有：xlrd.book.Book 、xlrd.sheet.Sheet、xlrd.sheet.Cell 分别对应Excel当中的：workbook、worksheet[sheet]、cell xlrd.book.Book对象主要用到了1个属性和4个方法：具体见2.3部分 xlrd.sheet.Sheet对象主要用到了3个属性和6个方法：具体见2.4部分 xlrd.sheet.Cell对象主要用到了2个属性和1个方法：具体见2.5部分 2.2 wb=xlrd.open_workbook(‘filename’，on_demand=True) filename 指定打开文件的文件路径 on_demand——True 按需加载表单/False 直接加载所有表单[可省略] 2.3 Class xlrd.book.Book Property PropertyDescriptionwb.nsheetworkbook对象包含的sheet对象的个数 Function FunctionsDescriptionsheetlist[ ]=wb.sheets()返回一个包含所有sheet对象的列表sheetnamelist[ ]=wb.sheet_names()返回所有表单的名称sheet = wb.sheet_by_index(0)使用序号索引sheet对象sheet = wb.sheet_by_name(name)根据名称索引sheet对象 2.4 Class xlrd sheet.Sheet Property PropertyDescriptionsheet.name表单名称sheet.nrows表单的最大行数sheet.ncols表单的最大列数 Function FunctionDescriptioncell= sheet.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c9a745417dc87e38cf9fb2923b9e227/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89313519bbb4c82a37ea8f36005c196f/" rel="bookmark">
			验证码登录如何实现？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		手机验证码登录 文章目录 手机验证码登录1、需求分析2、数据模型3、代码开发-交互过程4、代码开发-准备工作5、代码开发-修改LoginCheckFilter6、代码开发-接口开发7、前端代码介绍8、启动测试 1、需求分析 为了方便用户登录，移动端通常都会提供通过手机验证码登录的功能。
手机验证码登录的优点:
方便快捷，无需注册，直接登录使用短信验证码作为登录凭证，无需记忆密码安全 登录流程：输入手机号&gt;获取验证码&gt;输入验证码&gt;点击登录&gt;登录成功
注意:通过手机验证码登录，手机号是区分不同用户的标识。
2、数据模型 通过手机验证码登录时，涉及的表为user表，即用户表。结构如下:
3、代码开发-交互过程 在开发代码之前，需要梳理一下登录时前端页面和服务端的交互过程:
在登录页面(front/page/login.html)输入手机号，点击【获取验证码】按钮，页面发送ajax请求，在服务端调用短信服务API给指定手机号发送验证码短信在登录页面输入验证码，点击【登录】按钮，发送ajax请求，在服务端处理登录请求 开发手机验证码登录功能，其实就是在服务端编写代码去处理前端页面发送的这2次请求即可。
4、代码开发-准备工作 在开发业务功能前，先将需要用到的类和接口基本结构创建好:
实体类UserMapper接口UserMapper业务层接口UserService业务层实现类UserServicelmpl控制层Usercontroller工具类SMSutils、ValidateCodeutils 工具类SMSutils（阿里云短信服务）：
package com.mannor.reggie_take_out.Utils; import com.aliyuncs.DefaultAcsClient; import com.aliyuncs.IAcsClient; import com.aliyuncs.dysmsapi.model.v20170525.SendSmsRequest; import com.aliyuncs.dysmsapi.model.v20170525.SendSmsResponse; import com.aliyuncs.exceptions.ClientException; import com.aliyuncs.profile.DefaultProfile; /** * 短信发送工具类 */ public class SMSUtils { /** * 发送短信 * @param signName 签名 * @param templateCode 模板 * @param phoneNumbers 手机号 * @param param 参数 */ public static void sendMessage(String signName, String templateCode,String phoneNumbers,String param){ DefaultProfile profile = DefaultProfile.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89313519bbb4c82a37ea8f36005c196f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/653bd1d0c7c265bc990d671b483e02dc/" rel="bookmark">
			遇到【java.lang.NoClassDefFoundError: javax/xml/bind/DatatypeConverter】的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 手动添加依赖 在pom.xml文件中添加如下依赖：
&lt;dependency&gt; &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.sun.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-impl&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.sun.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-core&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.activation&lt;/groupId&gt; &lt;artifactId&gt;activation&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d1270bbdfd736f5dfa837661a1acbca/" rel="bookmark">
			js金额数字格式化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、使用 toLocaleString() 要格式化金额，可以使用 JavaScript 的 toLocaleString() 方法。该方法可以将数字转换为本地化的字符串表示形式，并可以指定货币符号、小数点和千位分隔符等格式。
美元 const amount = 1234567.89; const formattedAmount = amount.toLocaleString("en-US", { style: "currency", currency: "USD", minimumFractionDigits: 2, maximumFractionDigits: 2, }); console.log(formattedAmount); 人民币 const amount = 1234567.89; const formattedAmount = amount.toLocaleString("zh-CN", { style: "currency", currency: "CNY", minimumFractionDigits: 2, maximumFractionDigits: 2, }); console.log(formattedAmount); 在这个示例中，将数字变量 amount 使用 toLocaleString() 方法转换为本地化的字符串表示形式，并指定了以下格式：
style: 'currency' 表示使用货币格式显示金额。 currency: 'USD' 表示使用美元符号作为货币符号。 minimumFractionDigits: 2 表示最少保留两位小数。 maximumFractionDigits: 2 表示最多保留两位小数。 通过这种方式，可以使用 JavaScript 快速简单地实现金额格式化效果。需要注意的是，toLocaleString() 方法在不同的操作系统中可能存在差异，需要进行兼容性测试和兼容性处理。
二、 使用模板字符串 + toFixed + 正则替换 const amount = 1234567.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d1270bbdfd736f5dfa837661a1acbca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4ec241445b75ac87623a10ffc0cab57/" rel="bookmark">
			vue项目中直接操作cookie
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		封装设定cookie函数 // 没有定义时效 // document.cookie = 'phone=1'; // 设定cookie时效的语法,设定的时效,就是时间对象的时间戳 // JavaScript时间对象的默认时间戳是,本地时间,与服务器时间有时差,必须要计算时差 // 还必须要计算时效时间 // 新的时间戳,要设定为时间对象的时间戳 // document.cookie = 'phone=1;expires=时间对象'; // 删除cookie,只要将时效性定义为-1就行了 // 通过函数的形式来设定cookie,定义时效 // 三个参数:名称,数据,时效 function mySetCookie(key, value, time) { // JavaScript中计时单位都是毫秒 // 1,获取当前时间 let t = new Date(); // 获取当前时间戳 单位是毫秒 // 服务器的事件与当前本地时间相差8个小时,减去8个小时的毫秒 // 还必须计算当前的时效,秒转化为毫秒 // 当前cookie新的时间戳 let t1 = t.getTime() - 8 * 60 * 60 * 1000 + time * 1000; // 将这个新的时间戳,设定为 Date()对象的时间戳 // 将cookie的时效,设定为当前时间对象Date()对象的时间戳 // 将计算好的t1时间戳,设定为t时间对象的时间戳 t.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4ec241445b75ac87623a10ffc0cab57/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/63/">«</a>
	<span class="pagination__item pagination__item--current">64/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/65/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>