<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d913c40cc9860a09984bba61ef433af1/" rel="bookmark">
			jvm堆默认行为
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		堆默认配置 JVM 的默认堆参数是在安装 JDK 时确定的，并且通常是根据系统的物理内存大小和其他配置参数进行设置的。这些默认值在安装时被写入到 JVM 的配置文件中，后续运行时不会自动更改。
默认情况下，JVM 的初始堆大小（InitialHeapSize）和最大堆大小（MaxHeapSize）是根据系统的物理内存大小进行设置的，以提供一个合理的默认值。
但是，开发人员可以通过命令行参数或修改 JVM 配置文件来手动调整初始堆大小和最大堆大小。使用 -Xms 参数可以设置初始堆大小，使用 -Xmx 参数可以设置最大堆大小。这样的设置将会覆盖默认的配置值，并在运行时生效。
需要注意的是，不同的 JVM 实现可能会有略微不同的默认堆参数设置。因此，在部署应用程序时，建议根据实际情况和应用程序的内存需求，仔细选择合适的堆参数配置，以达到最佳的性能和内存利用率。
堆识别异常 JVM 默认堆大小是基于系统的物理内存来设置的，而不是针对单独的内存条。因此，JVM 在识别和设置默认堆大小时并不区分内存条。
如果您在运行 JVM 时发现它似乎只识别了系统中的一根内存条，而忽略了另一根内存条，可能是由于其他因素导致的。这可能是操作系统或硬件配置的问题，例如错误的内存识别或配置问题。
建议您检查以下方面来解决这个问题：
确保操作系统和硬件配置正确识别了所有的内存条。可以通过操作系统提供的工具或 BIOS/UEFI 设置来检查内存条的识别情况。
检查操作系统和 JVM 的相关配置。确保操作系统和 JVM 的配置正确设置了物理内存的信息。
尝试重新安装 JDK 或更新到最新的 JDK 版本。有时，旧版本的 JDK 可能会存在一些问题，通过更新到最新版本可能会解决一些识别问题。
如果问题仍然存在，建议您查阅操作系统和 JVM 的文档，或向相关的技术支持寻求帮助，以获取更具体的解决方案。
如果将 JVM 的最大堆内存参数 -Xmx 设置为超过物理内存的四分之一，那么 JVM 会尝试分配并使用设置的最大堆内存大小。但是，由于超过了物理内存的限制，操作系统可能会触发内存交换（swap）或强制终止 JVM 进程。
在这种情况下，OutOfMemory 错误可能无法准确发生，因为系统级别的内存管理可能会介入并导致其他问题。操作系统可能会通过内存交换来将部分内存写入硬盘，以释放一些物理内存供 JVM 使用。这可能会导致系统整体性能下降，因为硬盘访问速度相对较慢。
总之，尽量避免将 JVM 的最大堆内存参数设置超过物理内存的四分之一，以确保系统的稳定性和性能。
堆默认行为 4g及以上：默认情况下，最大堆内存占用物理内存的1/4，如果应用程序超过该上限，则会抛出OutOfMemoryError异常。初始堆内存大小为物理内存的1/64。
以下：最大堆内存为物理内存的1/2，初始堆内存大小为物理内存的1/64，但当初始堆内存最小为8MB，则为8MB。
默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制；空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制。因此，服务器一般设置-Xms、-Xmx相等以避免在每次GC后调整堆的大小。对象的堆内存由称为垃圾回收器的自动内存管理系统回收。
其中最大堆内存是JVM使用内存的上限，实际运行过程中使用多少便是多少。
本文由 mdnice 多平台发布
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f52b103b8b84bd6efdefb31c3a97fd69/" rel="bookmark">
			基于NVIDIA Jetson AGX Xavier的移动机器人开发（2）——ROS基础操作、Clion配置ROS工作空间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【摘要】环境基本配置完善后，进行开发环境的搭建，使用Clion进行代码和ROS相关的开发。本篇主要回顾和总结ROS的相关基础操作，以及使用Clion配置ROS工作空间进行开发的相关整理。
一、ROS工作空间和功能包 在创建新的ROS代码前，必须先建立一个目录（ROS工作区），且必须要有src子目录mkdir -p ros_ws/src设置环境变量，让操作系统知道工作区的位置source ros_ws/devel/setup.bash编译工作空间，将会自动在src中生成CmakeList.txt文件package是ROS中的一个概念，按代码逻辑分组（如关节控制、规划、建图、感知），在src目录下执行
catkin_create_pkg xxx roscpp rospy std_msgs
xxx为package的名称，后面的参数依赖项。功能包的名字不可重复！此时xxx目录下会存在package.xml，Cmakelist和src及include目录package.xml会重新组织package，其中可以命名、列出依赖项，其中的注释说明了如何编辑。&lt;name&gt;xxx&lt;/name&gt;应该与package名字一致（注意引用其他人的源码时修改），其中包含四种依赖项，首先唯一需要依赖的构建工具为catkin，即：&lt;buildtool_depend&gt;catkin&lt;/buildtool_depend&gt;，&lt;build_depend&gt;......&lt;/build_depend&gt;表示构建的依赖项，&lt;exe_depend&gt;......&lt;/exe_depend&gt;表示运行时的依赖项，此时已经包括roscpp，rospy，std_msgs，其他的依赖可以仿照写roscd pkg_name可以直接进入某个package的目录下ROS依赖Linux中正确的环境变量设置，否则无法编译和运行，打开新终端时，环境将被重置，因此除非将环境变量设置于/home目录下的隐藏文件.bashrc中，否则所有操作需要在同一个终端进行。 二、 使用Clion开发编译 打开新的终端，首先配置环境变量source ros_ws/devel/setup.bash在同一个终端，从源启动clionsh /opt/clion-xxx/bin/clion.sh打开位于package下的CmakeList.txt，作为项目打开在src目录下，添加源文件，如main.cpp修改CmakeList.txt，主要有两处，然后reload add_executable(my_package src/my_package.cpp) target_link_libraries(my_package ${catkin_LIBRARIES}) 三、创建ROS节点（以最小发布器为例） #include &lt;ros/ros.h&gt; #include &lt;std_msgs/Float64.h&gt; int main(int argc, char **argv) { ros::init(argc, argv, "minimal_publisher"); // 节点名 ros::NodeHandle n; // nodehandle可以建立节点间的通信 //实例化发布器对象，向名为topic1的话题进行发布消息 ros::Publisher my_publisher_object = n.advertise&lt;std_msg::Float64&gt; ("topic1", 1); // 实例化消息 std_msgs::Float64 input_float; input_float.data = 0.0; // 此循环只有当关闭roscore时才会停止 while (ros::ok()) { input_float.data += 0.001; my_publisher_object.publish(input_float); } } 编译后首先打开roscore，然后另外开启命令行rosrun package_name minial_publisherrostopic list显示当前的话题；rostopic hz topic_name显示当前发布器向话题发布消息的频率； 在机器人系统内，通常合理的发布频率是1KHZ假设while内部执行需要0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f52b103b8b84bd6efdefb31c3a97fd69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a2439c1f92fad7dbb9720a15269948b/" rel="bookmark">
			【linux命令】Linux shell中 2＞&amp;1的含义解释(标准输入输出)及nohup后台启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 首先了解下1和2在Linux中代表什么1.1 重定向1.2 标准操作符1.3 关于2&gt;&amp;1的含义1.3.1 把标准输出和标准错误输出分别指定到不同的文件中1.3.2 把标准输出和标准错误输出指定到同一个文件中 2. nohup后台启动 1. 首先了解下1和2在Linux中代表什么 在Linux系统中0、1、2是一个文件描述符，如下图所示：
从图中可以看到1代表标准输出，什么是标准输出？就是往屏幕上输出！
同样的0代表标准输入，就是键盘输入！
标准错误输出，就是往屏幕上显示错误信息！
0, 1 和 2 常与操作符一起用，表示输入重定向或输出重定向！
1.1 重定向 什么是重定向？我们先来看下不重定向，也就是默认输出：
echo "hello" 默认的输出就是输出到屏幕上，那么通过重定向符，我们可以改变原本要输出到屏幕的行为，改为输出到指定的文件中，常见的是日志文件之类的场景：
echo "hello" &gt; t.log 这样，我们就把屏幕的输出重定向至t.log 文件中，&gt; 表示重定向符，t.log表示目标文件
1.2 标准操作符 从前文的表格中看的出来，我们平时使用的 “&gt;”符合实现重定向效果：
echo "hello" &gt; t.log 其实也可以写成 “1&gt;”：
echo "hello" 1&gt; t.log 使用 &gt; 或 &gt;&gt; 时，默认为标准输出 1 重定向, 所以 &gt; file 就是 1&gt; file 的省写，1 与 &gt; 之间不能有空格。数字 0, 1, 2 与它后面的操作符 &gt; 或 &lt; 等 总是一个整体.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a2439c1f92fad7dbb9720a15269948b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/125b5bf9bea10d0689c675d0a8747795/" rel="bookmark">
			【Redis】哨兵机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、哨兵机制高可用架构图 哨兵模式时给予主从模式的，是为了解决主从模式单点（master）故障导致服务不可用的问题，但并未解决单节点存储能力有限的问题。
二、心跳检测机制 三、 选举机制 主观下线：主服务器master宕机后，哨兵1检测到这个结果，系统并不会马上进行failover，这仅仅是哨兵1认为主服务器不可用，这种现象称为主观下线。
客观下线：当其他哨兵也检测到主服务器master不可用且数量到达配置的值时，哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器切换成主服务器，这个过程称为客观下线。这样对于客户端而言，一切都是透明的。
当一个master服务器被sentinel视为下线状态后，sentinel之间会选举leader进行故障转移；每个正常的sentinel都可以要求其他sentinel选自己作为leader，选举规则是先到先得；同时，每个sentinel每次选举都会自增配置纪元（选举周期），每个纪元中只会选择一个sentinel的leader；如果超过一半的sentinel选举了某个sentinel做leader，则该sentinel将会作为leader进行故障转移，从存活的slave中选出新的master的过程和集群的master选举类似。哨兵选举leader的规则是： （1）选择在线的节点，过滤掉已经下线的节点；
（2）选择响应速度快的，过滤掉响应慢的节点；
（3）选择与原master断开时间短的，过滤掉断开时间长的；
（4）以上优先级都一致时，选择偏移量较大的、runid偏大的。
哨兵集群选举：哨兵集群只有一个哨兵节点，redis的主从也能正常运行以及选举master，如果master挂了，那唯一的那个哨兵节点就是哨兵leader了，可以正常选举新master。 不过为了高可用一般都推荐至少部署三个哨兵节点。为什么推荐奇数个哨兵节点原理跟集群奇数个master节点类似。
四、故障转移机制 这篇也不错，找时间参考参考《https://huaweicloud.csdn.net/637ef70adf016f70ae4cae5b.html?spm=1001.2101.3001.6650.5&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~OPENSEARCH~activity-5-114832836-blog-131264758.235^v38^pc_relevant_default_base&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~OPENSEARCH~activity-5-114832836-blog-131264758.235^v38^pc_relevant_default_base&amp;utm_relevant_index=6》
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea83ce965ed6116c9fd60e085d22be70/" rel="bookmark">
			vue服务端渲染SSR
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：ssr的理解
1、服务端渲染 Server Side Render
SSR解决方案，后端渲染出完整的首屏的dom结构返回，前端拿到的内容包括首屏及完整spa结构，应用激活后依然按照spa方式运行，这种页面渲染方式被称为服务端渲染 (server side render)
二：Vue SSR实战
1、新建工程
vue-cli创建工程即可
vue create ssr 2、安装依赖
npm install vue vue-server-renderer express -D 3、启动脚本
创建一个express服务器，将vue ssr集成进来，./server/02-simple-ssr.js
// 导入express作为渲染服务器 const express = require("express"); // 导入Vue用于声明待渲染实例 const Vue = require("vue"); // 导入createRenderer用于获取渲染器 const { createRenderer } = require("vue-server-renderer"); // 创建express实例 const app = express(); // 获取渲染器 const renderer = createRenderer(); // 待渲染vue实例 const vm = new Vue({ data: { name: "开课吧" }, template: ` &lt;div &gt; &lt;h1&gt;{{name}}&lt;/h1&gt; &lt;/div&gt; ` }); app.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea83ce965ed6116c9fd60e085d22be70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b47820ecf77a82bbdaf47511716e6085/" rel="bookmark">
			小程序mqtt实现聊天功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mqtt是什么？ MQTT是一个轻量级传输协议，它被设计用于轻量级的发布/订阅式消息传输，MQTT协议针对低带宽网络，低计算能力的设备，做了特殊的优化。是一种简单、稳定、开放、轻量级易于实现的消息协议，在物联网的应用下的信息采集，工业控制，智能家居等方面具有广泛的适用性。
谁发布，谁订阅？ MQTT服务器类似一个公告栏，里面张贴了各种广告。 张三跑过来说，凡是涉及足球的（/public/TEST/Soccer）的都发给自己（订阅） 第二天，李四过来贴广告了，主题是（/public/TEST/Soccer），发布的内容是“30号有比赛” 此时，公告栏会自动发短信给张三，发送的信息为 “30号有比赛” 张三：APP端； 李四：设备端； 公告栏：云端的MQTT服务器 mqtt优点？ 1、MQTT更加简单: MQTT是一种消息队列协议，使用发布/订阅消息模式，提供一对多的消息发布，解除应用程序耦合，相对于其他协议，开发更简单；
2、MQTT网络更加稳定 工作在TCP/IP协议上；由TCP/IP协议提供稳定的网络连接；
3、轻量级 小型传输，开销很小（固定长度的头部是 2 字节），协议交换最小化，以降低网络流量；适合低带宽，数据量较小的应用；
MQTT和Websocket的区别是什么？ MQTT是为了物联网场景设计的基于TCP的Pub/Sub协议，有许多为物联网优化的特性，比如适应不同网络的QoS、层级主题、遗言等等。
WebSocket是为了HTML5应用方便与服务器双向通讯而设计的协议，HTTP握手然后转TCP协议，用于取代之前的Server Push、Comet、长轮询等老旧实现。两者之所有有交集，是因为一个应用场景：如何通过HTML5应用来作为MQTT的客户端，以便接受设备消息或者向设备发送信息，那么MQTT over WebSocket自然成了最合理的途径了。
如何适用mqtt去实现聊天功能？ 首先我们从前端布局样式开始 为了时时滚动到最新消息我们使用 scroll-view 标签包裹 使用它的scroll-into-view属性我们绑定一个自定义id
如图：
我们在创建的元素上绑定一个 id属性，scroll-view 即可自动滚动到其对应位置。
以上就是几种不同消息类型的展示，我们先不考虑类型的样式，我们先来实现聊天左右分布的布局
推荐大家使用 flex 布局去实现
左侧医生：display: flex;justify-content: flex-start; (默认属性) 右侧患者：display: flex;justify-content: flex-end;（尾部对齐）
样式方面主要也就是这两个属性，其他消息类型的，也是在这基础上做修改即可。
2.连接 mqtt
首先我们要引入依赖
var Paho = require('./utils/paho-mqtt-wx.js')
var Paho = require('./utils/paho-mqtt-wx.js') /** * 连接 mqtt */ connectMqtt() { // let t = '异常断线'; var t = {} t.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b47820ecf77a82bbdaf47511716e6085/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/744963a52269f1466659136a1d5c4586/" rel="bookmark">
			华为HCIA进阶笔记：PPPoE原理与配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
PPPoE (Point to Point Protocol over Ethernet) 基于以太网的点对点协议
前言
DSL应用场景
PPPoE在DSL中的应用
PPPoE报文
PPPoE会话建立过程
PPPoE协议报文
PPPoE发现阶段
PPPoE会话阶段
PPPoE会话终结
PPPoE会话建立过程
PPPoE配置
配置验证
配置验证
总结
华为HCIA基础实验 - PPPoE &amp; eNSP
PPPoE 实验
PPPoE (Point to Point Protocol over Ethernet) 基于以太网的点对点协议 运营商希望通过同一台接入设备来连接远程的多个主机，同时接入设备能够提供访问控制和计费功能。在众多的接入技术中，把多个主机连接到接入设备的最经济的方法就是以太网，而PPP协议可以提供良好的访问控制和计费功能，于是产生了在以太网上传输PPP报文的技术，即PPPoE。
PPPoE利用以太网将大量主机组成网络，通过一个远端接入设备连入因特网，并运用PPP协议对接入的每个主机进行控制，具有适用范围广、安全性高、计费方便的特点。
前言 数字用户线路DSL(Digital Subscriber Line)是以电话线为传输介质的传输技术，人们通常把所有的DSL技术统称为xDSL，x代表不同种类的数字用户线路技术。目前比较流行的宽带接入方式为ADSL，ADSL是非对称DSL技术，使用的是PPPoE(PPP over Ethernet)协议。
PPPaE协议通过在以太网上提供点到点的连接，建立PPP会话，使得以太网中的主机能够连接到远端的宽带接入服务器上。PPPoE具有适用范围广、安全性高、计费方便等特点。
DSL应用场景 DSL是一种利用现有电话网络实现数据通信的宽带技术。在使用DSL接入网络时，用户侧会安装调制解调器，然后通过现有的电话线与数字用户线路接入复用器（DSLAM）相连。DSLAM是各种DSL系统的局端设备，属于最后一公里接入设备。
然后，DSLAM通过高速ATM网络或者以太网将用户的数据流量转发给宽带远程接入服务器（BRAS）。BRAS是面向宽带网络应用的接入网关，位于骨干网的边缘层。
PPPoE在DSL中的应用 运营商希望通过同一台接入设备来连接远程的多个主机，同时接入设备能够提供访问控制和计费功能。在众多的接入技术中，把多个主机连接到接入设备的最经济的方法就是以太网，而PPP协议可以提供良好的访问控制和计费功能，于是产生了在以太网上传输PPP报文的技术，即PPPoE。
PPPoE利用以太网将大量主机组成网络，通过一个远端接入设备连入因特网，并运用PPP协议对接入的每个主机进行控制，具有适用范围广、安全性高、计费方便的特点。
PPPoE技术解决了用户上网收费等实际应用问题，得到了宽带接入运营商的认可并被广泛应用。
PPPoE报文 PPPoE报文是使用Ethernet格式进行封装的，Ethernet中各字段解释如下：
DMAC：表示目的设备的MAC地址，通常为以太网单播目的地址或者以太网广播地址（0xFFFFFFFF）。
SMAC：表示源设备的以太网MAC地址。
Type：表示协议类型字段，当值为0x8863时表示承载的是PPPoE发现阶段的报文。当值为0x8864时表示承载的是PPPoE会话阶段的报文。
PPPoE字段中的各个字段解释如下：
VER：表示PPPoE版本号，值为0x01。
Type：表示类型，值为0x01。
Code：表示PPPoE报文类型，不同取值标识不同的PPPoE报文类型。
PPPoE会话ID，与以太网SMAC和DMAC一起定义了一个PPPoE会话。
Length：表示PPPoE报文的Payload长度，不包括以太网头部和PPPoE头部的长度。
PPPoE会话建立过程 PPPoE可分为三个阶段，即发现阶段、会话阶段和会话终结阶段。
PPPoE协议报文 PADI（PPPoE Active Discovery Initiation）报文：用户主机发起的PPPoE服务器探测报文，目的MAC地址为广播地址。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/744963a52269f1466659136a1d5c4586/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c9ab55d77e383a6e16d357bc0d1ba2a/" rel="bookmark">
			H3C S5500 V2基本配置及配置命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		H3C S5500 V2 series 基本配置 1、 配置交换的 web 界面 &lt;h3c&gt;sys( 进入系统模式）
[h3c]int vlan 1( 进入虚接口 VLAN 1 ）
[h3c-int-vlan 1]undo ip address( 清除原地址）
[h3c-int-vlan 1]ip add 2.10.3.1 255.255.255.0( 配置 web 界面 ip 地址）
[h3c-int-vlan 1]quit （返回上一级）
[h3c]ip http enable( 启用 web 服务）
[h3c]local-user admin( 设置本地用户名、此处用户名 admin ）
[h3c-admin]password simple admin( 设置本地密码、此处密码 admin ）
[h3c-admin]service-type telnet level 3( 设置服务等级为 3 级）
[h3c-admin]quit （返回上一级）
[h3c]loal-user admin
[h3c-admin]service-type terminal telnet http https( 安全防护措施、认证方式）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c9ab55d77e383a6e16d357bc0d1ba2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1b992abd1baa285017baebf1947284d/" rel="bookmark">
			兵棋推演的智能决策技术与挑战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源自：自动化学报
作者：尹奇跃 赵美静 倪晚成 张俊格 黄凯奇
摘
要
近年来, 以人机对抗为途径的智能决策技术取得了飞速发展, 人工智能(Artificial intelligence, AI)技术AlphaGo、AlphaStar等分别在围棋、星际争霸等游戏环境中战胜了顶尖人类选手. 兵棋推演作为一种人机对抗策略验证环境, 由于其非对称环境决策、更接近真实环境的随机性与高风险决策等特点, 受到智能决策技术研究者的广泛关注. 通过梳理兵棋推演与目前主流人机对抗环境(如围棋、德州扑克、星际争霸等)的区别, 阐述了兵棋推演智能决策技术的发展现状, 分析了当前主流技术的局限与瓶颈, 对兵棋推演中的智能决策技术研究进行了思考, 期望能对兵棋推演相关问题中的智能决策技术研究带来启发.
关键词
兵棋推演 人机对抗 智能决策技术 博弈学习
作为人工智能(Artificial intelligence, AI)技术的试金石, 针对人机对抗的研究, 近年来获得了举世瞩目的进展. 随着Deep Blue[1]、AlphaGo[2]、Libratus[3]、AlphaStar[4]等智能体分别在国际象棋、围棋、二人无限注德州扑克以及星际争霸中, 战胜顶尖职业人类选手, 其背后的智能决策技术获得了广泛的关注, 也代表了智能决策技术在中等复杂度完美信息博弈[1]、高复杂度完美信息博弈[2]再到高复杂度不完美信息博弈中的技术突破[3].
国际象棋、围棋代表了完美信息博弈, 其状态空间复杂度由10471047增至1036010360, 后者更是被誉为人工智能技术的阿波罗[2]. 相比于上述两种博弈环境, 二人无限注德州扑克尽管状态空间复杂度仅有1016010160, 但其为不完美信息博弈, 相比于国际象棋与围棋信息集大小仅为1, 信息集平均大小达到103103[3]. 而星际争霸作为高复杂度不完美信息博弈的代表, 因相比于上述游戏的即时制、长时决策等特性[4-5], 对智能决策技术提出了更高的要求.
星际争霸突破之后, 研究人员迫切需要新的人机对抗环境实现智能技术的前沿探索. 兵棋推演是一款经典策略游戏[6-8], 也被称为战争游戏, 作为一种人机对抗策略验证环境, 由于其具有不对称环境决策、更接近真实环境的随机性与高风险决策等特点, 受到智能决策技术学者的广泛关注. 近年来, 学者们投入了大量的精力进行兵棋推演智能体研发和兵棋推演子问题求解, 试图解决兵棋推演的人机对抗挑战[9-14].
兵棋推演一直以来都是战争研究和训练的手段. 自1811年冯·莱斯维茨在前人研究成果基础上发明了现代兵棋以来, 兵棋推演迅速流行起来, 并逐渐演化出两个分支, 即“严格式”和“自由式”兵棋推演. 时至今日, 兵棋推演在实战化训练、指挥官培训等任务中扮演着越来越重要的角色[15-17]. 胡晓峰等[6]全面综述了兵棋推演的基本要素(参演人员、兵棋系统模拟的战场环境和作战部队、导演部及导调机构), 指出“兵棋推演的难点在于模拟人的智能行为”, 进而得出“兵棋推演需要突破作战态势智能认知瓶颈”, 最后给出了如何实现态势理解与自主决策可能的路径. 可以看出, 当前兵棋推演的研究集中在如何更真实模拟对抗以及如何实现态势分析与推理, 进而辅助人类指挥决策.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1b992abd1baa285017baebf1947284d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/846d3ed6cf9fa6c826615745d36a5cba/" rel="bookmark">
			Ubuntu 下防火墙UFW使用介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UFW 基础命令 ufw version #查看版本信息 ufw enable #启用防火墙 ufw disable #禁用防火墙 ufw reload #重载防火墙 ufw reset #重新设置防火墙 (注意：这将禁用UFW并删除之前定义的任何规则) ufw verbose #查看防火墙策略 设置UFW默认策略 默认情况下ufw开启会阻止所有传入的流量并且允许所有传出的流量，通过以下命令实现：
ufw default allow outgoing ufw deault deny incoming 设置允许SSH ufw allow ssh 或 ufw allow 22 设置其他端口（含协议限制） 增加协议限制，基于tcp/udp过滤数据包
ufw allow 80/tcp ufw allow 21/udp 拒绝某端口访问 ufw deny 80 删除已经添加的端口 ufw delete allow 80 ufw delete deny 21 或可以通过编号删除
ufw status numbered OutputStatus: active To Action From -- ------ ---- [ 1] 22/tcp ALLOW IN Anywhere [ 2] 443/tcp ALLOW IN Anywhere ufw delete 2 按照范围开通端口 某些应用程序使用多个端口，此时需要指定端口范围。指定端口范围时，必须指定规则应适用的协议（ tcp或udp ）。例如，要允许使用端口9000-9002范围内的连接，可以使用以下命令
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/846d3ed6cf9fa6c826615745d36a5cba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a2987a18e2a5bf2fb04038f2ce77292/" rel="bookmark">
			Python 智能语音机器人（改进版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇为改进版，之前部分代码存在错误，部分网站api也已经失效，现在更换api，并对部分代码进行重写。
本次在Pycharm上测试
相关模块如下：
baidu-aip==4.16.11 beautifulsoup4==4.12.2 chardet==5.1.0 lxml==4.9.2 PyAudio==0.2.13 pycryptodome==3.18.0 pygame==2.4.0 pyttsx3==2.90 requests==2.31.0 wxPython==4.2.1 废话不多说，先上效果图
功能一：人机互动 功能二：播放音乐 功能三：天气 功能四：一句话新闻 把以下参数更换成你自己的 # 百度需要的参数 APP_ID = '000000' API_KEY = 'xxxxxx' SECRET_KEY = 'xxxxxx' # 图灵机器人需要的参数 tuling_apiKey = "xxxxxx" tuling_userId = "000000" # 易客云需要的参数 yikeyun_appid = '000000' yikeyun_appsecret = 'xxxxxx' 易客云平台（https://yikeapi.com/account）
图灵机器人
http://www.tuling123.com/member/robot/index.jhtml
百度语音识别api 介绍请看
https://ai.baidu.com/tech/speech?_=1687103124997
控制台：
https://console.bce.baidu.com/ai/?fromai=1#/ai/speech/overview/index
按照这些步骤一步一步创建自己的应用，完成个人实名认证可以有一定的免费使用量，创建应用完成后，从”我的应用“ 即可看到相应的userid, apikey 等。
import pyaudio import wave import win32com.client from aip import AipSpeech import base64 import random from binascii import hexlify from Crypto.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a2987a18e2a5bf2fb04038f2ce77292/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dcb3d3ca57b7f3efb565cfcde621370/" rel="bookmark">
			docker开启远程访问并配置IDEA连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		docker配置运行远程访问 1、配置docker远程连接端口 vi /usr/lib/systemd/system/docker.service 2、找到 ExecStart，在最后面添加 -H tcp://0.0.0.0:2375 [Service] Type=notify # the default is not to use systemd for cgroups because the delegate issues still # exists and systemd currently does not support the cgroup feature set required # for containers run by docker ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock -H tcp://0.0.0.0:2375 ##这里添加 ExecReload=/bin/kill -s HUP $MAINPID TimeoutSec=0 RestartSec=2 Restart=always 3、重启docker systemctl daemon-reload &amp;&amp; systemctl start docker 4、开放端口和防火墙 firewall-cmd --zone=public --add-port=2375/tcp --permanent iptables -I INPUT -p tcp --dport 2375 -j ACCEPT 5、验证 curl http://192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0dcb3d3ca57b7f3efb565cfcde621370/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/245558077cf39ccf0c4f2ce5a60fee13/" rel="bookmark">
			CUDA11.4配置pytorch、pytorchvision
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 显卡是GeForce RTX 3060 Ti，记录一下使用GeForce RTX 3060 Ti+cuda 11.4搭建Pytorch深度学习环境，当你有了Python环境时记住一个核心命令即可，显卡驱动因该在之前已经安装过了，只需要注意他的版本即可，如果觉着使用显卡训练模型依旧很慢的话可以先装一个cuda tooklit，然后安装一下cudnn加速驱动（具体自己网上百度，这里就不展开说了，据说安装之后可以提速50%）。
可以使用pip在 https://download.pytorch.org/whl/torch/ 网站下载对应版本的torch，在本地进行安装，也可以使用下面的命令进行在线安装。
pip install torch==1.12.0+cu116 torchvision==0.13.0+cu116 torchaudio==0.12.0 -f https://download.pytorch.org/whl/torch_stable.html 安装的时候一定要注意torch有GPU版本与CPU版本两种，如果安装错误很可能无法使用GPU，大家根据自己的Cuda版本修改掉命令中的+cuxxx,比如我是Cuda11.6，我就改成+cu116。然后去后面网址找一找有没有自己想要的torch版本，在安装的时候需要注意torch、torchvision、torchaudio三者的对应关系，以免后面会出现错误
最后，使用以下代码测试torch安装是否成功。
import torch print(torch.cuda.is_available()) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/832c15998d49b6419a44c28dacb79cfb/" rel="bookmark">
			Mac系统jdk环境变量的配置最新版（保姆级教程，超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、介绍
二、找到安装的jdk路径
1.打开系统资源库
2.在资源库里找到自己的jdk路径
三、配置环境变量
1.查看自己的环境变量
2.输入以下命令行配置环境变量
3.输入环境变量的值
4.退出保存环境变量
5.使用终端使环境变量生效
6.再次查看环境变量
四、总结
一、介绍 在大部分情况下，Mac系统在我们安装好jdk之后系统会自动配置Java环境变量，但有时候可能因为Mac版本的不同导致java程序运行不成功，又或者需要更换JDK版本，那么就需要我们自己手动去配置一下环境变量。文章一共分为两个部分，第一部分主要是帮大家找到自己安装好的jdk路径。第二部分就是带大家配置一下环境变量，内容十分细致，堪称保姆级教程。
二、找到安装的jdk路径 大家手否会在Mac环境下想要配置环境变量却找不到自己的jdk路径而感到发愁呢，下面我就来介绍一下怎么找到自己的jdk路径，并附上详细步骤。
1.打开系统资源库 打开“访达”，点击屏幕左上角的“前往”按钮，点击前往文件夹。在弹出的对话框输入:
/Library 这时候系统可能会显示成中文“资源库”，我们直接回车。具体如下：
（1）点击左小角第一个图案，就是“访达”
（2）点击前往，然后点击倒数第二个“前往文件夹”
（3）在弹出的对话框里输入/Library,输好后直接回车，这时我们就会进入到我们自己电脑的资源库
2.在资源库里找到自己的jdk路径 在上一个步骤我们已经打开了资源库，现在我们需要在资源库里找到一个文件名称为Java的文件夹，然后打开这个文件夹，找到Home目录，然后继续在Home目录里找到bin文件夹。具体步骤如下：
（1）双击“java‘”文件夹，这里的java文件夹就在刚刚打开的资源库里，仔细找一下肯定能找到，如果实在找不到可以用上面的搜索功能，记住是要在资源库里搜索。双击之后会有一个名为JavaVirtualMachines的文件夹。如下图
（2）双击JavaVirtualMachines文件夹后会有一个“jdk版本”的文件夹，继续双击会有一个"content"文件夹。双机完"content’文件夹后会有三个文件，我们主要看的是那个Home文件夹，双击打开就找到了jdk的“bin”文件夹。如下图:
(3)复制bin文件夹的目录，这里我们使用鼠标右键点击bin目录，点击拷贝，就能复制bin文件夹的路径。这里可能会有人疑惑，拷贝不是直接复制了整个文件吗，这里大家不要担心，Mac环境变量的配置主要是在终端里进行，把刚刚拷贝的粘贴到终端里就是jdk的路径。到这里我们已经成功地复制到jdk路径。
三、配置环境变量 1.查看自己的环境变量 我们在配置前可以通过输入以下命令来先查看一下自己的环境变量：
echo $PATH 命令行下面这一行就是现在的环境变量
2.输入以下命令行配置环境变量 vi .bash_profile 输入该命令就会进入一个界面，然后动一下你宝贵的手指，敲一下键盘上的i键,一定要敲啊，只有敲了才能输入文本。
3.输入环境变量的值 输入下面的内容配置环境变量。
JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home PATH=$JAVA_HOME/bin:$PATH //给环境变量赋值 export JAVA_HOME //导出使其生效 export PATH 注意了上面JAVA_HOME的值一定要是你自己电脑上的jdk路径。和刚刚的/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home/bin路径有差别的地方是JAVA_HOME后面的路径少了/bin。然后把/bin加在了PATH后面。
4.退出保存环境变量 （1）先摁 ESC键 返回命名行模式（一定要先摁ESC）。
（2）输入 :wq 退出保存环境变量。
大家照着我这个先后顺序在键盘上敲就行
5.使用终端使环境变量生效 在终端输入下面命令行让环境变量生效：
source .bash_profile 6.再次查看环境变量 再次输入echo $PATH命令查看环境变量。
echo $PATH 这是我们可以看到我们的环境变量会多出我们刚刚配置好的jdk路径，说明配置成功。
四、总结 以上就是在Mac环境下配置jdk的全部内容啦，非常感谢大家的翻阅，谢谢大家。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75cb4ef95cd463cc73829b68987aaddf/" rel="bookmark">
			Oracle Spatial定义空间参考系（一、地理坐标系）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍如何在Oracle Spatial空间数据中添加自定义坐标系。
Oracle 11g r2数据库中没有定义2000国家大地坐标系(CGCS2000，SRID=4490)，本文将详细说明添加该坐标系的全过程。
1. 判断Oracle Spatial中是否存在该空间参考系 在视图MDSYS.CS_SRS视图中查找指定SRID值的空间参考系是否存在。
select * from MDSYS.CS_SRS where SRID = 4490; 如果不存在，则按照下面的流程进行添加。
2. 查找空间参考系的详细信息 从EPSG官网 https://epsg.org 查询空间参考系的详细信息。
点击顶部导航栏 EPSG Dataset -&gt; Text Search进入查询页面。
搜索栏中输入 4490 进行搜索。点击搜索结果名称，进入详情页面。如下图所示：
2.1 定义信息 点击右上角的WKT查看以WKT描述内容。
2.2 说明 GEOGCRS[ // 说明括号[]中定义的是一个地理坐标系 "China Geodetic Coordinate System 2000", // 该地理坐标系的名称 DATUM[ // 大地基准面 "China 2000", // 大地基准面名称 ELLIPSOID[ // 椭球体 "CGCS2000", // 椭球体名称 6378137, // 椭球体长半轴长 298.257222101, // 椭球体的扁率的倒数 LENGTHUNIT[ // 长度单位 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75cb4ef95cd463cc73829b68987aaddf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c11c2211396a14fbad56454b31852098/" rel="bookmark">
			Git报错: Please move or remove them before you switch branches.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Bug记录：在我写需求的时候，产品说上个包有崩溃，于是我就控制台 git checkout切分支，结果报错Please move or remove them before you switch branches.下面是被改动的文件，因为是项目build的时候产生的临时文件，一般都不会上传，所以就想着把它删掉。
1.首先：
git status 产看当前分枝的状态 ，知道哪些东西有改动。
2.查看哪些是要删除的
git clean -n 3.如果想彻底删除本地修改，使用git clean -dfx。
git clean -dfx tips：此操作会完全删除本地修改，你的代码就会和远程的代码一致。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d292e120437183ae304c200ba0c3f832/" rel="bookmark">
			自动驾驶中的行人检测技术有哪些？（下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在智慧交通领域，行人检测已经取得了不少成就。
利用图像分割、深度学习等计算机视觉技术，行人检测为自动驾驶行业发展提供了重要的技术保障，使得自动驾驶车辆能够更加准确地感知和理解周围环境，并做出更加智能和安全的决策。
下面，本文将继续介绍自动驾驶中常见的行人检测技术。
一、基于特征提取的行人检测方法 特征提取是计算机视觉与图像处理技术中的一个基本概念，所谓特征提取，是指从目标图像特征中选取一些最具代表性、分类能力强的特征。
每张图像都有很多特征表象，如颜色、灰度、纹理特征等，这些特征从不同的角度代表了整张图像。在行人检测领域，行人是非刚性物体，位置姿态具有多样性，因此辨别能力强，鲁棒性好，较适用于特征提取的检测方法。
底层特征检测法
在众多应用于行人检测的底层特征中，主流的检测法为2005年提出的方向梯度直方图（Histogram of Oriented Gradient，HOG）特征，大多数行人检测法都是基于HOG特征和SVM分类器的思路改进的。
HOG通过计算图像局部信息的梯度、幅值、方向等特征检测人的图形，得出水平和竖直的梯度幅值及像素点的梯度角，利用梯度幅值来对梯度角展开加权，勾勒出图像的局部梯度幅值以及相应的方向，最后利用SVM分类器进行分类预测。
HOG 特征检测法可以让不同模块相互重叠，所以对光照偏移和位置移动有很大的容差性，这种特征具备较高的鲁棒性，可以很好地表现出人体的特征。
混合特征检测法
多特征是在单特征基础上构建起来的，单一特征检测往往存在检测精度较低，泛化能力较弱等缺陷。
如低光照环境中，捕捉到的可见光非常糟糕，基于单可见光模态的道路行人检测器难以获取足够多的行人特征，会给后续检测带来一定困难。
而混合特征检测可以利用多光谱图像进行全方位的识别，将多光谱图像和其他类型的图像特征组合起来，包括纹理特征、形状特征、颜色特征等，在整个图像特征空间中寻找最具代表性的特征，从而削弱光照对检测结果的影响。
常见的多模态检测法为：
● 将HOG特征和描述纹理的LBP特征进行融合，该算法加入了加权部件，对待测图像中的每一目标附上权值，有效降低遮挡或行人目标部分重合造成的影响。
● 基于共生梯度方向直方图 (CoHOG)的行人检测方法，该方法通过多个梯度方向的特征描述行人目标，相较于基于HOG单特征的行人检测方法具有更高的准确率及召回率。
● 基于边缘特征的检测法，结合行人颜色、纹理信息，采用偏最小二乘( PLS)降低维度，提升计算效率。
多模态融合的行人检测方法，其检测速度、准确率、鲁棒性各有不同，因此在不同应用场景下所选择的行人特征描述也各有差异。
二、基于分类与定位的行人检测法 该检测方法可以直接判断待检测图像中是否存在行人并进行窗口定位。目前，常用的分类定位法包括滑动窗口法与超越滑动窗口法。
滑动窗口法
滑动窗口法需要在待测图像中选择一个固定宽高的窗口并依序滑动，并通过分类器模型判别窗口内的行人特征。该方法由整体法与部分法两种方法组成。
● 整体法
整体法可以直接提取窗口内行人目标的全局特征，常见的方法包括SVM、Boosting等。在训练数据集时，整体法只需用矩形框标注出行人区域，这种方法执行效率较高，但同时也容易易忽视细节特征，在拥挤环境、遮挡影响下的行人检测精度会大幅降低，因此该方法不适用于小目标行人的检测。
● 部分法
部分法基本原理是将行人划分为若干个不同部位，再分别对检测不同部位的分类器进行训练，并建立各个部位之间的几何关系。相比整体法，部分法通常对遮挡较多、行人重叠等场景具有较强的鲁棒性，然而各部位与整体图像的匹配需要大量时间，因此在实时性方面难以达到应用要求。
超越滑动窗口法
与滑动窗口法相比，超越滑动窗口法在行人检测技术中应用较少。
● 高效子窗口搜索法：顾名思义，这是一种能快速定位目标的方法，但计算过程较复杂。
● 交替搜索的近似算法：是对高效子窗口搜索法的改进，其速度可增加约900倍，但在遮挡环境下表现较为一般。
● 隐式形状模型：隐式形状模型是前两种方法的结合，它不依赖图像预处理来区别复杂场景，不仅能快速定位，且能有效解决遮挡问题，但其局部特征的检测精度较差，难以兼顾检测实时性，误检率较高。
三、实现细节 行人检测系统的构建除了与特征提取、分类定位、图像分割、深度学习等技术相关外，还与训练样本质量密切相关。
训练样本质量对行人检测系统构建非常重要。在训练深度学习模型时，需要海量优质训练数据才能够提升模型的性能。对于行人检测系统来说，训练样本应该包含各种不同的场景、天气、时间和光照条件下的行人图像，以确保模型在各种情况下都具备较好的泛化能力。
此外，还需要注意训练样本的标注质量，标注的准确性会直接影响行人检测模型的性能和效果。如果标注的边界框和分类标签不准确，模型就会学到错误的特征，导致检测错误率上升。
因此，在进行数据标注时，需要使用高质量的数据标注工具，并由专业的标注人员进行标注。标注人员需要根据预先定义好的标注规则来标注每个行人的边界框并确定其类别。在标注过程中，需要仔细查看每张图片，细致地标注每个行人，确保标注的准确性和一致性。
在标注行人时，常用的工具包括使用语义分割、实例分割、矩形框与多边形标注等，以更直观地标注每个行人的位置和形状，提升标注工作时效性。
“如在拉框标注时，行人训练样本的标注中往往给出的是包含行人的最小矩形窗口，但实际上，可以对框体继续向下延伸，因为行人一般站在地面上，而地面的特征通常相对固定，扩充窗口可以提高行人标注的准确性。”
综上所述，标注数据质量是行人检测系统能否达到预期性能的关键因素。如果标注不准确，训练数据质量差，会严重影响模型的性能，从而导致行人检测精度下降或漏检等问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b5c5cd86bcfa67dbb2c51015dd7c9ff/" rel="bookmark">
			docker-compose安装nginx实现vue项目部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. docker-compose安装nginx version: '3' services: nginx: restart: always container_name: mynginx image: nginx ports: - 80:80 - 8081:8081 - 8082:8082 - 8083:8083 - 443:443 volumes: # 有可能会出现不能挂载，这个时候用手动拷贝配置文件就行 - /home/docker-compose/docker_container/nginx/nginx.conf:/etc/nginx/nginx.conf # vue项目存放路径(其实我也不明白为什么挂载这里要写两次存放路径, #按照我的理解,冒号后面应该是容器内的路径,但是不这样写,我成功不了,有大佬路过求指点!!!) - /home/blog/vue:/home/blog/vue # 这是我的文件上传路径,可以不要 - /home/blog/upload:/home/blog/upload environment: - NGINX_PORT=80 - TZ=Asia/Shanghai privileged: true 2. 编写nginx.conf文件 events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; client_max_body_size 50m; client_body_buffer_size 10m; client_header_timeout 1m; client_body_timeout 1m; gzip on; gzip_min_length 1k; gzip_buffers 4 16k; gzip_comp_level 5; gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png; gzip_vary on; server { listen 80; server_name 121.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b5c5cd86bcfa67dbb2c51015dd7c9ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6dbf507f5975bf6e050b38031351a61/" rel="bookmark">
			联想拯救者电脑触摸板用不了了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 问题分析解决1. 解决方法一2. 解决方法二3. 解决方法三 问题 电脑触摸板用不了了，无论使用怎样的操作均未能完成对鼠标的操作
分析 这是因为被误触了“游戏模式”，就会出现“防误触”开关
解决 1. 解决方法一 （开机输入密码前就能用）Fn+F10多调一下，调节触控板的开关闭。
2. 解决方法二 （开机解锁后才能操作）
1、打开电脑自带的“联想电脑管家”。
2、鼠标找窗口右上角切换到“游戏模式”。
3、点击窗口左侧“实用工具”，就会出现“防误触”开关。
4、开关多点几下，相当于唤醒纠正它，然后按需求设置即可
3. 解决方法三 1.打开设置
2.进入设备界面，找到触摸板】
3.将连接鼠标时让触摸板保持打开选项 ，取消掉
4.拉到最后点击重置
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00c810e3d359c8646383ab8a0c7567c0/" rel="bookmark">
			自学学习网络安全，渗透测试的环境搭建总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文只是汇总学习网络安全需要装什么软件和注意事项，具体每个软件怎么安装是很简单的，我这里就不再重复的叙述了。这里写一个总体的概括。给大家一个整体的感觉。
安装虚拟机vmware软件，简称vm。 2.在vm中安装kali系统，就是黑客的工具包，放在了这一个系统里面方便大家使用。
3.在vm中安装window server 2008r2系统，为靶场搭建提供环境。一个问题是vmware tools安装不起来，需要安装两个插件。已经截图了。大家最好安装一个谷歌浏览器。
4.在server 2008中安装phpStudy2016服务器，因为选择稳定的版本。其中服务器起不来，因为缺少vc9是32位的，注意是32位的。
5.在phpStudy中安装dvwa靶场。靶场的意思是各个漏洞的集合和代码，相当于一个服务集和。
如果需要以上安装包建议私信我，因为放到网盘过一段时间就不能下载了。
至于每一个软件的安装方法可以自行搜索，还是简单的。我这里只是做个汇总总结。
如果以上环境都搭建完毕，你就可以开始自己的渗透测试学习之旅了。
从靠劳力赚钱转变成靠脑力赚钱，想入门渗透测试的小白肯定想知道如何学好？ 👉[[[CSDN大礼包：《黑客&amp;网络安全入门&amp;进阶学习资源》免费分享]]]（安全链接，放心点击）
一、网安学习成长路线图 Python所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。（全套教程文末领取哈）
二、网安视频合集 观看零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
三、精品网安学习书籍 当我学到一定基础，有自己的理解能力的时候，会去阅读一些前辈整理的书籍或者手写的笔记资料，这些笔记详细记载了他们对一些技术点的理解，这些理解是比较独到，可以学到不一样的思路。
四、网络安全源码合集+工具包 光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
五、网络安全面试题 最后就是大家最关心的网络安全面试题板块
这份完整版的学习资料已经上传CSDN，朋友们如果需要可以微信扫描下方CSDN官方认证二维码免费领取【保证100%免费】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91e76afc71d8a737bcfba11144c04e83/" rel="bookmark">
			交叉编译工具链（arm-linux-gcc）使用测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用之前，需要先安装交叉编译工具链（arm-linux-gcc），这里仅提供一个参考链接，不作叙述。
参考链接：(1条消息) Ubuntu 18.04安装arm-linux-gcc交叉编译器（超简单，附安装包下载地址）_安装交叉编译器_难搞哦~的博客-CSDN博客本文主要介绍如何使用交叉编译工具链编译一个简单的c程序到arm板上运行。
1、在ubuntu上写一个简单的c程序，命名为test.c，具体内容如下： #include&lt;stdio.h&gt;
int main()
{
printf("hello ylk\r\n");
return 0;
}
2、使用交叉编译工具链编译，执行命令：arm-linux-gnueabihf-gcc -o test test.c，编译得到可执行文件test。 使用命令file test查看该文件是 32 位 LSB 的 ELF 格式文件，目标机架构为 ARM，说明交叉编译器工作正常。
3、在arm板使用tftp，执行命令： tftp -g -r test 192.168.1.253（关于tftp的使用可以参考我前面的文章）将可执行文件下载到板子上 执行命令：chmod 777 test，给可执行文件test赋权限，然后执行命令./test运行程序，实际效果如下图所示。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/522918e48a780db385a18d2678b77b16/" rel="bookmark">
			MQTT通信协议以及使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MQTT 1.MQTT是什么 MQTT (Message Queue Telemetry Transport) 是一个轻量级传输协议，它被设计用于轻量级的发布/订阅式消息传输，MQTT协议针对低带宽网络，低计算能力的设备，做了特殊的优化。是一种简单、稳定、开放、轻量级易于实现的消息协议，在物联网的应用下的信息采集，工业控制，智能家居等方面具有广泛的适用性。
官网：mqtt.org
MQTT的客户端工具，可以使用MQTTX
MQTT 客户端库 &amp; SDK 大全 | EMQ (emqx.com)
2.MQTT特点 特点：
MQTT更加简单：MQTT是一种消息队列协议，使用发布/订阅消息模式，提供一对多的消息发布，解除应用程序耦合，相对于其他协议，开发更简单；MQTT网络更加稳定：工作在TCP/IP协议上；由TCP/IP协议提供稳定的网络连接；轻量级：小型传输，开销很小（固定长度的头部是 2 字节），协议交换最小化，以降低网络流量；适合低带宽，数据量较小的应用； MQTT支持三种消息发布服务质量(QoS)：
“至多一次”(QoS==0)：消息发布完全依赖底层 TCP/IP 网络。会发生消息丢失或重复。这一级别可用于如下情况，环境传感器数据，丢失一次读记录无所谓，因为不久后还会有第二次发送。“至少一次”(QoS==1)：确保消息到达，但消息重复可能会发生。“只有一次”(QoS==2)：确保消息到达一次。这一级别可用于如下情况，在计费系统中，消息重复或丢失会导致不正确的结果。 MQTT 三种身份：
发布者、代理、订阅者，发布者和订阅者都为客户端，代理为服务器，同时消息的发布者也可以是订阅者（为了节约内存和流量发布者和订阅者一般都会定义在一起）。MQTT传输的消息分为主题（Topic，可理解为消息的类型，订阅者订阅后，就会收到该主题的消息内容（payload））和负载（payload，可以理解为消息的内容）两部分。 应用场景：
遥感数据、汽车、智能家居、智慧城市、医疗医护
即时通讯：MQ 可以通过订阅主题，轻松实现 1对1、1对多的通讯
3.EMQX EMQX大规模分布式 MQTT 消息服务器，大规模可弹性伸缩的云原生分布式物联网 MQTT 消息服务器，高效可靠连接海量物联网设备，高性能实时处理消息与事件流数据，助力构建关键业务的物联网平台与应用。
官网地址：EMQX: 大规模分布式 MQTT 消息服务器
基于Docker安装：
1.执行名称 创建容器
docker run -d --name emqx -p 1883:1883 -p 8083:8083 -p 8084:8084 -p 8883:8883 -p 18083:18083 emqx/emqx:5.0.26
2.连接测试
访问可视化页面：
http://服务器ip:18083
默认的账号 和密码 ：admin/public
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/522918e48a780db385a18d2678b77b16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9e3a669b4db3291ee1cd324dab0606a/" rel="bookmark">
			【设计模式项目】【GUI计算器】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 实例1前言设计模式的使用工厂模式：策略模式：监听器模式：异常处理：设计模式的作用 完整代码实现 实例2前言设计模式工厂模式（Factory Pattern）：策略模式（Strategy Pattern）：监听器模式（Listener Pattern）： 完整代码 实例1 前言 由于Java 课程设计已经完成前期的计算器GUI设计，以及功能实现，现在基于之前的基础，进行设计模式的应用，以完善软件设计。
如果还不了解之前GUI设计的童鞋，可以先查看【Java课程设计】【图形界面程序】【计算器】。
设计模式的使用 使用了以下设计模式：
工厂模式： 工厂模式被用于创建不同类型的操作对象。Operation 接口充当了工厂模式中的产品，每个具体的操作类（例如 Addition、Subtraction 等）都实现了该接口。在 Calculation 类中，根据操作符的类型，使用工厂模式创建了相应的操作对象。
策略模式： 策略模式用于将不同的操作封装成独立的策略，并使它们可以相互替换。Operation 接口代表了策略的抽象，每个具体的操作类都实现了该接口并提供了自己的实现。在 Calculation 类中，根据用户选择的操作符，选择相应的操作策略，并将计算委托给所选策略。
监听器模式： 通过实现 ActionListener 接口，可以为按钮添加监听器，以响应按钮的点击事件。在 Calculation 类中，通过为按钮添加监听器，实现了按钮的点击事件处理。
异常处理： 在 Division 类的 performOperation 方法中，通过抛出 ArithmeticException 异常来处理除以零的情况。在 Calculation 类中，在执行除法操作时，捕获 ArithmeticException 异常，并将错误消息显示在文本框中。
设计模式的作用 这些设计模式的使用让代码更具可扩展性、灵活性和可维护性。工厂模式和策略模式使得添加新的操作变得简单，可以轻松地扩展计算器的功能。监听器模式用于处理用户界面的交互，使得按钮点击事件得以处理。异常处理机制增强了代码的健壮性，能够适当地处理除以零的异常情况。
完整代码实现 package cal1; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; interface Operation { double performOperation(double number1, double number2) throws ArithmeticException; } class Addition implements Operation { @Override public double performOperation(double number1, double number2) { return number1 + number2; } } class Subtraction implements Operation { @Override public double performOperation(double number1, double number2) { return number1 - number2; } } class Multiplication implements Operation { @Override public double performOperation(double number1, double number2) { return number1 * number2; } } class Division implements Operation { @Override public double performOperation(double number1, double number2) throws ArithmeticException { if (number2 !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9e3a669b4db3291ee1cd324dab0606a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76b5faa3c263317e4d1ca8ee6149e8e7/" rel="bookmark">
			使用TFTP实现arm开发板与ubuntu之间数据传输
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在嵌入式开发过程中，arm板和ubuntu之间的数据交互是必不可少的，常见的传输方式式nfs、tftp等，这里介绍的是tftp的环境搭建和简单使用。
1、tftp简介 TFTP全称是（Trivial File Transfer Protocol）简单文件传输协议，是 TCP/IP 协议族中用来在客户端与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。它是以UDP为基础的应用层协议。
2、tftp的环境搭建 2.1 安装和配置 xinetd （1）通过执行以下指令sudo apt-get install xinetd来安装：
至于tftp为什么要安装xinetd，可以参考以下链接学习下。xinetd简单来说是用来管理多种轻量级Internet服务的（tftp包含在其中）。
Linux之Xinetd服务介绍_xinted_鹤啸九天-西木的博客-CSDN博客
（2）执行以下命令ls /etc/xinetd.conf ，查询xinetd的配置文件是否存在，若不存在则执行命令sudo vi /etc/xinetd.conf创建。
（3）新建出来的文件是空的，则填入以下内容：
# Simple configuration file for xinetd
#
# Some defaults, and include /etc/xinetd.d/
defaults
{ # Please note that you need a log_type line to be able to use log_on_success
# and log_on_failure. The default is the following :
# log_type = SYSLOG daemon info }
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76b5faa3c263317e4d1ca8ee6149e8e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d60754158702f0f9d16ee117341952e4/" rel="bookmark">
			Java集合框架：队列、Queue和Deque详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、普通队列
1. 概念
2. Queue（Java集合框架的接口）
3. Queue中的方法
4. 方法使用演示
5. 队列的模拟实现
6. 顺序普通队列的缺点：
二、循环队列
1. 循环队列也是一种数据结构。基于上述队列的缺点，此时就有了循环队列，如下图：
2. 是一个类似圆形的数组：
3. 所以此时有两个问题： 4. 循环队列的实现： （oj题链接：力扣）
三、双端队列（Deque）
1. 概念
2. 双端队列的使用
3. 面试题
两个队列实现一个栈：
两个队列实现一个栈：
前言
队列是一种数据结构，在Java集合框架中，有对应的实现的接口，Queue是一个队列规范的接口，Deque是一个双端队列实现的接口，由于两个都是接口，所以是不能直接进行是实例化的，需要接口引用具体的类来进行实例化，所以底层可以是顺序表（数组），也可以是链表（单 / 双链表）。
一、普通队列 1. 概念 队列：只可以在一段进行插入操作，在另一端进行删除操作的线性表，队列具有先进先出的特性，在插入操作的一端称作队尾，进行删除操作的一端称作队头。
2. Queue（Java集合框架的接口） 如上图：Queue（队列）是一个接口，底层是一个双向链表来实现的，所以Queue不能直接实例化一个对象，只能是接口引用一个具体类（LinkedList）的方式来实例化。
3. Queue中的方法 boolean offer（E e）入队列E poll（）出队列peek（）获取队头元素int size（）获取队列中的有效元素个数boolean isEmpty（）判断队列是否为空 4. 方法使用演示 public static void main(String[] args) { //尾插法和头部删除 MyQueue queue = new MyQueue(); queue.offer(1); queue.offer(2); queue.offer(3); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d60754158702f0f9d16ee117341952e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b27f18e97417f96e74d955b0cd93e09/" rel="bookmark">
			Android记事本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、项目需求分析
1.1、记事功能需求分析：
1.1.1、显示记事
用户打开记事本可以看到之前所写的所有记事内容，进入主页后，软件应该从数据库中搜索出该用户所写的全部记事，并将所有的数据进行显示。
1.1.2、添加记事
设置添加按钮，点击添加按钮之后可以编辑记事的标题和内容。
1.1.3、编辑记事
在主界面的记事列表中，点击一条记事，能够进行编辑，包括更改记事和删除记事。
1.1.4、查询记事
在主界面中设置查询功能，使用户可以通过对标题进行模糊查询。
1.2、账户管理
为了保护用户的隐私，在使用记事本时首先需要进行用户的登录，在登录账号之后才可以使用记事本的功能。
1.2.1、注册账号
使用记事本功能首先需要进行用户的注册，在注册过程中应注意用户名以及密码的正确输入才可注册成功。
1.2.2、登录
登录时需要对账号以及密码进行检测，如果账号密码正确即可进入记事本页面，使用记事本功能。
1.3、数据库需求分析
在该项目中使用了两个数据库表，分别为存储用户信息的users表以及存储记事本内容的note表。
1.4、界面需求分析
在该项目中，一个有六个页面，分别是用户界面activity_user、注册页面activity_register、记事本主页面activity_main、添加页面activity_add、编辑页面activity_edit、删除页面List_item_dialog。
总体布局以及背景色调使用简约风格。
2、项目的设计
2.1、注册功能
图 1 注册功能
2.2、登录功能
图 2 登录功能
2.3、记事功能
图 3 记事功能
3、关键的代码
3.1、页面代码（部分）
3.1.1、用户界面activity_user.xml
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
xmlns:app="http://schemas.android.com/apk/res-auto"
xmlns:tools="http://schemas.android.com/tools"
android:layout_width="match_parent"
android:layout_height="match_parent"
tools:context=".MainActivity"
android:orientation="vertical"&gt;
&lt;androidx.appcompat.widget.Toolbar
android:id="@+id/toolbar"
android:layout_width="match_parent"
android:layout_height="?attr/actionBarSize"
android:background="?attr/colorPrimary"
android:elevation="4dp"
app:popupTheme="@style/ThemeOverlay.AppCompat.Light"
app:title="@string/app_name"&gt;
&lt;/androidx.appcompat.widget.Toolbar&gt;
&lt;LinearLayout
android:layout_width="match_parent"
android:layout_height="wrap_content"
android:orientation="horizontal"
android:layout_marginLeft="20dp"
android:layout_marginRight="20dp"
android:layout_marginTop="40dp"
android:gravity="center_vertical"
&gt;
&lt;TextView
android:layout_width="wrap_content"
android:layout_height="wrap_content"
android:text="账号:"
android:textSize="25sp"
/&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b27f18e97417f96e74d955b0cd93e09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15a5028e4c6133de5eeb0d7b863931bc/" rel="bookmark">
			vue-cli3的安装和项目创建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 vue-cli3的安装
（注意：vue-cli3在安装之前，需要先删除旧版本，即vue-cli2）
cnpm i -g @vue/cli
vue-cli3的卸载：cnpm uninstall -g @vue/cli 然后用命令“vue -V”查看是否删除vue，如果没有删掉，就直接去文件夹里面删除vue文件夹即可
（二）vue-cli3项目创建
1，用dos命令的方式
vue create 项目名
注意：项目名不要有大写字母！！ 并且一定一定要选择lint!!!!!否则会遇到意想不到的错误（scss会疯狂报错）
，回车
空格键选择，上下键移动，回车键确认
空格键选择，上下键移动，回车键确认
然后提示是否将上面的设置设为预设，输入n表示不设预设，输入y表示设置预设，然后写个预设名
注意：在npm run serve命令执行之前需要先执行命令安装依赖：cnpm i
在谷歌浏览器中输入以下地址
出现以下界面表示项目创建成功了！
2，图形化界面的方式 输入命令：vue ui
然后会跳转到浏览器，如果浏览器没反应，就换个浏览器（如谷歌浏览器），重新输入地址：http://localhost:8000/
等“启动app”按钮可点击时，点击即可启动
出现以下界面即成功！
另外：如果想将项目部署到github上，下面这种方式不易出错
1，新建文件夹test_git作为仓库
2，在桌面版GitHub上新建名为test_git的仓库
3，在test_git文件夹中选中路径，输入cmd
4，输入命令 vue create 项目名 创建vue3项目
5，在桌面版GitHub提交项目
————————————————
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2c149328911dca5d2912b01896746b9/" rel="bookmark">
			吉林大学-嵌入式软件团队实践-实验报告及实验代码(白嫖×)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		所有实验报告都是本人亲手敲上去的，实验代码是我一个个调试过去的。请确保你的VM版本是centos7，代码在上面均可运行。白嫖×
购买平台：【闲鱼】https://m.tb.cn/h.UAM50DQ?tk=KQ3EdrTkM79 CZ0001 「我在闲鱼发布了【嵌入式软件团队实践】」
点击链接直接打开
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e32820bfa53249c9f871ae43b15bb772/" rel="bookmark">
			C盘空间清理的常用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、写在前面 很多朋友存在C盘空间不足的问题，可能是因为存在大量的桌面文件、临时缓存文件、软件安装等。
本篇文章旨在分享一些简单的C盘清理方法。希望通过本篇文章，大家的C盘剩余空间能得到一定的改善。
二、C盘空间清理的常用方法 1.移动桌面文件 很多朋友为了平时使用方便，把文件都放置在桌面上。一般桌面上的所有内容都是默认存储在C盘当中的。这种情况其实可以使用“快捷方式”来解决，此外也可以将桌面的内容移动到其它的磁盘当中，同时不会影响桌面文件的使用。下面给大家介绍一下具体的步骤：
（1）打开我的电脑选择桌面文件夹 （2）单击右键选择属性，选择“位置”菜单栏，点击“移动” （3）按情况选择一个除C盘以外的磁盘 ！！！此处需要在磁盘下新建一个文件夹用于存放桌面文件，否则磁盘下的所有文件可能都会显示到桌面上！！！
（4）点击“应用”即可 这是完成移动后的截图。
2.临时文件清理 在日常使用电脑时，经常会产生一些临时文件，这些临时文件在我们完成工作后并不会自动清除，因此我们需要给它删除掉。具体步骤如下：
（1）按住win+R键打开运行程序，然后输入%temp%，点击确定 （2）电脑会自动打开一个文件夹 （3）ctrl+A全选后，使用shift+delete键可以绕过回收站实现永久删除 （4）点击开始菜单，点击设置→系统→存储→临时文件，这里面的内容也是可以直接清理的 至此，我们就清理了C盘的临时文件，这个方法大家可以定期使用一次，防止临时文件过多导致C盘剩余容量不够。
3.磁盘清理 （1）磁盘清理 ①打开我的电脑，右键单击C盘，选择属性，点击磁盘清理
② 电脑会计算可以清理的空间和内容，这些都是可以删除的，尤其是回收站要记得定期清理
③点击确定即可
（2）误装软件清理 建议大家将软件尽量安装在非C盘的磁盘目录下，如果真的很需要运行速度，在占用内存不大的前提下也是可以装在C盘当中的。
此外，在某些网站上下载的Windows安装程序包文件（比如msi）可能会绑定一些别的软件。因此，大家在安装过程中要谨慎，将所绑定软件前面的“√”去掉之后再进行安装。
4.软件缓存位置修改 此处以微信的缓存位置为例，给大家分享一下缓存位置的修改方法，其余软件的缓存也可类比进行设置。
（1）进入微信，选择设置
（2）点击文件管理，查看位置是否在C盘，可按具体情况移动到其他磁盘
5.清理软件推荐 （1）SpaceSniffer 可以使磁盘中文件的大小可视化的软件，将磁盘中的文件大小以块状显示出来，块越大对应的存储空间占用就越大。找到不需要的文件可以右键直接删除，如果误删可以在回收站找回。
（2）CCleaner 一款很强大的PC清理工具。 通过禁用占用资源的应用和程序，更新过时的软件驱动程序等，轻松加速设备。
三、其它可用方法 大家可以通过磁盘扩展的方式来扩展C盘的空间，但也会存在很多的注意事项。相关的博客网络上有很多，需要的朋友可自行查找。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94569d0862f51366b8b877192eaec3d1/" rel="bookmark">
			使用lws编码的注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		libwebsockets: Notes about coding with lws
守护进程 如果你需要实现守护进程，那很简单，lws内置了一个API叫lws_daemonize ，它 能帮你完成守护进程的一切，包括创建锁文件。如果你正在创建一个基础的守护进程，那么，你只需要在初始化的早期调用它，它能fork出一个无头后台进程，并退出当前进程。
注意：守护进程的stdout、stderr和stdin都被重定向到 /dev/null，因此，如果需要调试日志，你需要选择其它实现，比如说syslog。
最大连接数 LWS能处理的最大连接数，是在启动时通过OS查询进程的最大文件描述符个数（比如说Fedora的1024）得到。然后，它分配一个数组来维护连接，剩下的文件描述符再给用户代码使用。
如果你需要限制连接数，或提高连接数，你可以用ulimit或类似机制来改变OS的限制，在libwebsockets 重启之后，限制值就会随之调整。
Libwebsockets是单线程的 Libwebsockets工作在一个序列化的事件循环里，是一个单线程实例。 不允许在其它线程执行websocket操作。除了forked()过程导致的内部数据不一致之外，wsi（websocket连接对象），在服务期间可能会随时因为socket的关闭或wsi喂数据而结束生命。
Websocket写活动只能发生在LWS_CALLBACK_SERVER_WRITEABLE 回调里。
这种将发送新数据与获取先前数据关联在一起的网络编程风格显然与一般用户习惯不同。因此，让我们换句话强调：
***只在WRITEABLE 回调时执行LWS写操作。***
还有另一个网络编程约定可能会让某些人感到惊讶：不能接收太多数据：
***你必须执行RX流量控制。***
相关实例代码，请参考 mirror protocol的实现。
只有活跃连接才会出现在用户的回调中，这消除了所有尝试关闭wsi或向它喂数据的可能性。
除了websocket之外，如果你需要服务于其它socket或文件描述符，你可以把它们与websocket结合，在同一个循环中轮询，请参考后续的“外部轮询循环支持”，并且，依然在同一线程/进程上下文里执行。
如果你坚持尝试使用多线程，你需要特别注意多个线程同时创建多个context的场景。
此外，创建context时会调用SSL_library_init()，这个API也是个不可重入的函数。因此，请至少保证串行创建contexts。
只在socket 可写时写入数据 用户侧只能在LWS_CALLBACK_SERVER_WRITEABLE (或client端的LWS_CALLBACK_CLIENT_WRITEABLE)回调里向一条websocket连接写数据。
如果你需要发送什么数据，不要直接发出，而是要先请求socket的回调：
lws_callback_on_writable(context, wsi)，这是对特定wsi的请求lws_callback_on_writable_all_protocol(protocol) ，这是对同一protocol 下的所有连接同时发出的写请求。 通常，下一次服务循环就会收到回调，但是，如果你的对端响应缓慢或临时失活，那么回调可能会延时。生成写入的内容并发送它应当在WRITEABLE回调里完成。
请参考测试服务端代码，以加深理解。
不要仅依赖自己的WRITEABLE请求出现 如果 LWS碰到需要缓存你所发送的数据的网络条件，它可能会生成额外的LWS_CALLBACK_CLIENT_WRITEABLE 事件。
因此，你的LWS_CALLBACK_CLIENT_WRITEABLE 响应代码需要决定发送什么内容，不能假定writeable回调一定能发送出数据。
任何时候，你都可能会收到“额外的”writeable回调，这时，你只需要return 0 即可，并耐心等待正常的回调。
从用户侧关闭连接 如果你需要关闭一条连接，只需要在处理连接的回调时返回-1就可以。
你可以对wsi调用lws_callback_on_writable ()来触发写回调，如果你想要在回调中关闭连接，只需返回-1。通常，在回调中直接决定关闭连接并返回-1也很简单。
如果socket知道连接僵死，比如对端关闭，或者收到诸如FIN之类的网络错误，那么，LWS将会自动关闭连接。
如果碰到静默死连接，可能是进入这样的状态：数据发出后没有收到ACK，这种连接永远不会再收到可写回调。要覆盖这类场景，你可能用TCP保活（后面会讲）或ping。
消息分片 为了支持消息分片，你需要调用lws_is_final_fragment来检查。这个检查可以结合libwebsockets_remaining_packet_payload 来获取完整的消息内容。比如：
case LWS_CALLBACK_RECEIVE: { Client * const client = (Client *)user; const size_t remaining = lws_remaining_packet_payload(wsi); if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94569d0862f51366b8b877192eaec3d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/680e5c70f4a39b9bc98a73d727c501e9/" rel="bookmark">
			编译原理及应用期末复习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		杂 3型文法 = 右线性文法
短语、直接短语、句柄 、判断是否是二义性文法 1、证明是二义性文法：证明存在一个句子有两颗不同的语法树 ① 画语法分析树
②
、NFA、DFA K：所有状态，包含初始状态
Σ：终结字符集
M：状态转换表达式
S：开始符号
F：结束符号（可以有多个）
最小化 如果给的是一张表，那就先化简，删去那些根本到不了的状态最小化的结果就是画出状态转换图
消除左递归性 First 集 First 集：首符号集
就是找最左边可能出现的终结符
例子：
分三种情况
Follow集 先找到待求的大写字母（只从所有产生式的右部找），然后看他的右边，判断右边属于哪种情况
LR(0)文法 任意一个项目集中都不能出现以下两种情况：
同时出现移进项（点后面是终结符）和归约项（点后面没有东西）同时存在两个及以上归约项
否则他就是LR(0)文法 1、状态分析表 2、LR 分析表 ACTION表（移进项、接受项、归约项） 表头写出所有的终结符
移进项写S几，几是项的序号
接受项写acc
项集是归约项，写r几，几是产生式的序号
GOTO 表（只写待约项的） 表头写出所有的非终结符
待约项直接写数字
LR(0) 分析过程（SLR分析过程类似） 翻译：
对于每一行，都先去分析表中找 第 状态栈栈顶 行，符号栈栈顶 列，看他是啥：
若是移进项，找到S几，脚标放状态栈若是归约项，找到对应序号的产生式：r几 写到 ACTION 列，出栈右部长度个元素，写出GOTO[状态栈的栈顶，左部]，去分析表中寻找第 状态栈栈顶 行，第 左部 列的数字写到GOTO列，同时该数字作为新的状态栈栈顶；而左部作为新的符号栈栈顶 对于发生冲突的项，选择能够继续往下分析的项。（SLR分析）
SLR(1) 分析表 在 LR(0) 分析表的基础上，发生冲突时
对于移进项还按以前的写
对于每个归约项，求他左部的 Follow集，只在出现在 follow 集中的输入符号处写 r几
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/680e5c70f4a39b9bc98a73d727c501e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed2257a8a9178220ee45c5d739accc6c/" rel="bookmark">
			要避免的十大后端开发错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		后端开发在构建健壮且高效的 Web 应用程序中起着至关重要的作用。它涉及服务器端逻辑、数据库和集成的实施和管理，以确保无缝功能。
然而，即使是经验丰富的开发人员也可能会犯下导致性能问题、安全漏洞和用户不满的错误。
在此博客中，我将分享要避免的10 大后端开发错误，阐明常见的陷阱并为成功的开发之旅提供实用的解决方案。
1.输入验证不足
当涉及到用户输入时，验证是最重要的。未能正确验证输入可能会导致安全漏洞，例如 SQL 注入或跨站点脚本 (XSS) 攻击。始终在服务器端验证和清理用户输入，以确保它符合预期的标准并且没有恶意内容。
糟糕的数据库设计
数据库是任何应用程序的支柱。数据库模式设计不当会导致效率低下、查询缓慢和扩展困难。花时间彻底分析需求并设计针对应用程序需求优化的数据库结构。规范化数据，建立适当的关系，并创建索引以提高查询性能。 3.缺乏缓存机制
缓存可以通过减少服务器上的负载和最小化频繁访问数据的响应时间来显着提高后端的性能。忽视实现缓存机制会导致应用程序性能下降和服务器负载增加。利用 Redis 或 Memcached 等技术来缓存数据并优化整体响应时间。
不安全的认证授权
安全应该是后端开发的重中之重。未能实施适当的身份验证和授权机制可能会使您的应用程序容易受到未经授权的访问和数据泄露。利用 OAuth 或 JWT（JSON Web 令牌）等行业标准协议来确保安全的用户身份验证并实施适当的授权控制。 5.忽略错误处理和日志记录
错误在软件开发中是不可避免的，但是您如何处理它们会产生重大影响。忽视正确的错误处理和日志记录可能会导致难以解决问题和确定问题的根本原因。实施强大的错误处理机制和日志记录策略，以有效捕获和跟踪错误，从而及时调试和解决问题。
不优化 API 调用
后端应用程序通常依赖外部 API 来实现各种功能。未能优化 API 调用可能会导致性能瓶颈和不必要的开销。尽量减少 API 请求的数量，实施请求批处理，并在适用的情况下考虑异步处理，以提高后端集成的效率。 7.性能测试不佳
性能测试对于识别瓶颈、优化资源利用率以及确保您的应用程序能够处理预期负载至关重要。忽视全面的性能测试可能会导致响应时间变慢、服务器负载高以及用户体验不尽如人意。定期进行性能测试以及早发现性能问题并相应地优化您的后端基础架构。
8.缺乏可扩展性规划
随着应用程序的增长，可伸缩性变得至关重要。未能从早期阶段规划可扩展性可能会导致在处理增加的流量和用户负载时遇到挑战。在设计后端架构时考虑可扩展性，利用负载均衡器、水平扩展和基于云的解决方案等技术来无缝适应未来的增长。
跟不上安全更新
安全威胁不断演变，后端框架和库中的漏洞经常被发现。忽视将后端依赖项更新到最新的安全版本可能会使您的应用程序暴露在已知漏洞之下。随时了解安全公告，及时应用补丁，并定期检查和更新您的后端依赖项，以确保安全的应用程序环境。
缺乏适当的文件
文档经常被忽视，但在成功的后端开发中起着至关重要的作用。文档不足会使其他开发人员难以理解和维护您的代码，从而导致延迟和协作困难。彻底记录您的代码，包括 API、数据模型和架构决策，以促进更轻松的入职、故障排除和未来开发。
常见问题 (FAQ)
FAQ 1：输入验证不充分的后果是什么？
输入验证不充分可能会导致安全漏洞，例如 SQL 注入或跨站点脚本 (XSS) 攻击。攻击者可以利用这些漏洞执行恶意代码、访问未经授权的数据或破坏整个应用程序。
FAQ 2：如何在后台开发中确保安全的用户认证？
为确保安全的用户身份验证，请使用行业标准协议，例如 OAuth 或 JWT（JSON Web 令牌）。这些协议提供基于令牌的安全身份验证，支持用户身份验证并实施适当的授权控制。
FAQ 3：为什么性能测试对后端开发很重要？
性能测试对于识别瓶颈、优化资源利用率以及确保您的应用程序能够处理预期负载至关重要。它有助于及早发现性能问题并优化后端基础架构，以获得流畅高效的用户体验。
FAQ 4：扩展性规划在后端开发中的意义是什么？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed2257a8a9178220ee45c5d739accc6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a37b78d34acd4ff8b6052f7e83d71cb/" rel="bookmark">
			系统总结整理（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 @[TOC]一.网络1.七层模型2.数据封装过程3.每层对应的协议3.1 应用层3.2 常见的udp协议端口号3.3 传输层tcp udp3.4 网络层: arp icmp3.4.1 arp3.4.2 icmp 3.5 tcp与udp的不同 4.端口号的作用5.VRRP的工作原理 SNAT DNAT5.1 SNAT5.2 DNAT 6.网络架构7.服务架构7.1 接入层7.2 网关层7.3 业务服务层7.4 支撑服务层7.5 平台服务层7.6 基础设置层 8. 云服务的架构 二.系统命令总结1. 基本命令1.1 线上查询及帮助命令1.2 文件和目录操作命令1.3 查看文件及内容处理命令1.4 文件压缩及解压缩命令1.5 信息显示命令1.6 用户管理命令1.7 基础网络操作命令1.8 深入网络操作命令1.9 磁盘与文件系统的命令1.10 系统权限及用户授权相关命令1.11 系统用户登录信息的命令1.12 内置命令及其它1.13 系统管理与性能监视命令1.14 关机/重启/注销和查看系统信息的命令1.15 进程管理相关命令 2. 优化命令2.1 优化命令——mpstat2.1.1 mpstat的语法格式2.1.2 mpstat命令参数2.1.3 示例 2.2 优化命令——top2.3 优化命令——free2.4 优化命令——nload2.5 优化命令——iostat2.6 优化命令——cpuinfo2.7 优化命令——iotop2.8 优化命令——taskset2.9 优化命令——vmstat2.10 优化命令——uptime2.11 优化命令——nice2.12 优化命令——ulimit2.13 优化命令——time 三.网络服务总结1. ftp2. DHCP工作原理2.1 典型的C/S模式2.2 DHCP的分配方式2.3 DHCP工作原理 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a37b78d34acd4ff8b6052f7e83d71cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23ec235c21fa4760b3f1f1e16b4564f5/" rel="bookmark">
			Intellij IDEA设置“选中变量或方法”的背景颜色、字体颜色（Mark Occurrences）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 IDEA 中选中一个变量就会将所有的变量相关变量标出来，这样就很方便知道这个变量出现的地方。Eclipse里头把这个功能叫做 Mark Occurrences，IDEA 里不知道怎么称呼。
我们要解决的痛点就是提示不明显，如下图所示，Macbook这么好的屏幕，无论在暗黑还是白色主题，都不是很清晰（尤其很多人喜欢的暗黑主题，简直无法直视，简直是无法理解为什么这么多人喜欢用呼呼呼一团的dark主题）
（细心的朋友已经观察到，虽然都是相同变量，但是在改变变量的地方和其他情况是不同颜色的）
解决方案 这个改变是全局的，非针对某个project
打开：Settings/Preferences -&gt; Editor -&gt; Color Scheme -&gt; General
修改： “Identifier under caret” 的 “Backgroud” 颜色，注意这里修改的是选中的变量中非赋值的那种，如下图
修改：“Identifier under caret(write)” 的 “Backgroud” 颜色，这里的颜色是控制选中的变量赋值的，如下图
我个人将 “Identifier under caret” 和 “Identifier under caret(write)” 的 “Backgroud” 分别改成 9F9DA7 和 7C52FF
效果如下：
可以看到明显多了，尤其在代码很多的情况下特别明显！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5eabbd6c8412184d1aa25b8eedff10a1/" rel="bookmark">
			【C语言_End】【coredump】【gcc】.../后续更新地方-＞知乎
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录（2023-06-17）：好久没发文章了，之前就更换文章更新的地方了。可能不再在CSDN上发文章。。。目前转移到知乎。。；（有始有终，做个记录）
core#内存只读-&gt;在malloc分配内存时SIGSEGV
https://zhuanlan.zhihu.com/p/636195969 gcc#追踪（trace）程序任意2个位置的函数经历
https://zhuanlan.zhihu.com/p/630212108 gdb#简单的线程查看脚本、持续运行到segFault
https://zhuanlan.zhihu.com/p/617103457 等等。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e06e088a10b16103482b02f0507106c7/" rel="bookmark">
			【gitflow】 概念基本介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 gitflow 简介 什么是gitflow？
我们大家都很会用git，但是我们很少去关心我们要怎么用branch和版本控制。
只知道master是第一个主分支，其他分支都是次要分支， 那你知道如下的问题如何回答吗？
如何保证主分支的稳定性？如何开发新的feature？如何创建分支名称？分支多了如何管理？如何知道每个分支干嘛的呢？哪些分支合并了？哪些分支是release的分支？可以稳定使用的？如果稳定分支代码出现没有测出来的bug，如何创建分支快速修复？ 这个就像写代码，要有个规范一样， 当然我们可以不按照规范来做，git同样能处理。但是定义一个科学的操作规范，往往能让效率事半功倍。
创始人的分享链接：
https://nvie.com/posts/a-successful-git-branching-model/
gitflow 是一种git分支模型，是由创始人Vincent Driessen 2010年创建的。这只是一种建议，在团队合作中，具体项目中要灵活应用，不用可守成规，觉得不合理的地方可以自行修正。
gitflow 流程图 我们来看下创始人最初的流程图：
我们来换个角度来理解
gitflow的核心要素是branch，通过branch来实现工作流。
主要分为两大类：
主分支(Main Branches)辅助分支（supporting branches) 拓展开来：
主分支： Master Develop
辅助分支：Feature、Release、Hotfix
gitflow工作流如何使用 刚开始的时候，我们有个master分支，我们要基于master来创建develop
master master分支上存放的是最稳定的版本，并且该分支的代码是随时可以让用户使用的代码，就是非常非常稳定的代码。当一个版本开发完成之后，交付给客户的时候，master上面的额代码也要被更新。同时，每次更新都要打上相应的tag。
任何人不允许在master上进行代码的直接push提交，只接受其他分支合入。原则上master分支必须是release的分支合过来的代码。
来源只能是：hotfix和release分支。不能是其他分支。
master一定是经过多轮测试，但是不能保证完全没有bug，所以引入hotfix分支，来修复未知bug
develop develop是主开发分支，这个分支上被合并的代码始终是下一个版本需要加入的feature。这个分支可以合并一些feature。当要release的时候，就从这个分支上进行创建release分支。
合并到develop分支上的必须保证功能完整，不影响develop分支的正常运行。
feature feature 分支又叫功能分支，一般命名方法feature/xxx，用来开发版本或者未来要发布新的功能或者探索新功能。（feature 分支功能要保证里面的commit 的粒度要非常细，避免和主分支脱节严重，应该大功能切成一个一个小功能来merge，而不是一次merge一个大的）
Release 这个分支又叫预发布分支，一般命名为 release/1.1.x 这个分支转为发布做准备。允许小量级的bug修复。
release分支只能从develop分支拉过来，用来修复一些bug。（不做feature相关的开发）
hotfix hotfix 叫热修复分支，一般命名为hotfix/4.1.3 为固定某个版本进行修复，当master上遇到严重问题需要修复的时候，就要从master上指定tag拉取。这样做就是为了隔离feature开发和bug修复。
hotfix只能从master上拉去，测试通过之后合并会master和develop
总结 有些人觉得gitflow好用，有些人觉得gitflow太死板，太复杂，团队里面每个人都要遵守这套规则，会很麻烦。毕竟规则越复杂，用起来越难。所以创始人也建议团队根据实际情况调整策略。我觉得有以下几点值得注意：
团队主要成员如果成员固定，并且训练有素，可以考虑用一下。团队人员如果太多，太杂，不建议。如果主要团队人员就1-2个人，也不建议。从时间点上来说，要将团队统一战线，比如master要开始release了，整个团队需要切到release分支去修复bug，并且坚决不允许有feature合入。大feature可以下一个版本进行合并。release要全部测试人员测试完成，没有bug了，再合到master上。一定要保证master上面的有个稳定的代码源（这个是最重要的一点，如果达不到，产品化效果会很差）不同的团队保持并行开发，相互之间干扰要降到最低。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8e780c3b3d9fd0380049d5495cb9403/" rel="bookmark">
			linux中iptables 设置特定IP访问指定端口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		iptables 设置特定IP访问指定端口
查询、删除规则指令 测试telnet
telnet 127.0.0.1 8075 1、查询规则编号：
[root@zabbix_server ~]# iptables --line -nvL INPUT Chain INPUT (policy DROP 83 packets, 4016 bytes) num pkts bytes target prot opt in out source destination 1 8 408 DROP tcp -- * * 0.0.0.0/0 0.0.0.0/0 tcp dpt:8075 2 144M 15G ACCEPT all -- * * 0.0.0.0/0 0.0.0.0/0 state RELATED,ESTABLISHED 可以看到禁止访问8075的规则编号为1
2、删除指定规则编号的规则（如删除编号为1的规则）
iptables -D INPUT 1 实践 1、添加规则：禁止所有IP访问8075
iptables -I INPUT -p tcp --dport 8075 -j DROP 2、添加规则：允许127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8e780c3b3d9fd0380049d5495cb9403/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc1588b3c4ec68ecfd51017f30f0d03c/" rel="bookmark">
			笔记本电脑介绍：记录生活，激发灵感
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔记本电脑是一种轻便、便携的电脑，它的出现改变了人们的工作和生活方式，它的优势在于它的小巧、轻便、便携性，可以满足用户的不同需求。本文将从笔记本电脑的结构、功能、优势和应用四个方面进行详细阐述。
一、笔记本电脑的结构
笔记本电脑的结构主要由显示器、主机、键盘、触摸板、电池等组成。
显示器是笔记本电脑的核心部件，它可以显示用户操作的结果，是笔记本电脑的窗口。
主机是笔记本电脑的核心部件，它是笔记本电脑的大脑，它负责处理用户的操作，并将结果显示在显示器上。
键盘是笔记本电脑的输入设备，它可以让用户输入文字、数字和指令，以便操作笔记本电脑。
触摸板是笔记本电脑的输入设备，它可以让用户通过触摸板来操作笔记本电脑，比如移动鼠标、点击按钮等。
电池是笔记本电脑的重要部件，它可以为笔记本电脑提供电力，使笔记本电脑能够正常运行。
二、笔记本电脑的功能
笔记本电脑的功能主要有文字处理、图像处理、网络通信、多媒体播放等。文字处理功能可以让用户轻松地编辑文字，比如文档、报告等；图像处理功能可以让用户轻松地编辑图像，比如照片、图标等；网络通信功能可以让用户轻松地连接到互联网，比如上网、聊天等；多媒体播放功能可以让用户轻松地播放多媒体文件，比如音乐、视频等。
三、笔记本电脑的优势
笔记本电脑的优势主要有小巧、轻便、便携性、性能高、价格低等。小巧是指笔记本电脑的体积小，可以放在书包里，方便携带；轻便是指笔记本电脑的重量轻，可以放在口袋里，方便携带；便携性是指笔记本电脑可以随身携带，可以随时随地使用；性能高是指笔记本电脑的性能高，可以满足用户的不同需求；价格低是指笔记本电脑的价格低，可以让更多的人负担得起。
四、笔记本电脑的应用
笔记本电脑的应用非常广泛，它可以用于办公、学习、娱乐等。
办公方面，笔记本电脑可以用于文字处理、图像处理、网络通信等；
学习方面，笔记本电脑可以用于查阅资料、写作文章、编写程序等；
娱乐方面，笔记本电脑可以用于播放音乐、观看视频、玩游戏等。
总结：
笔记本电脑是一种轻便、便携的电脑，它的出现改变了人们的工作和生活方式，它的优势在于它的小巧、轻便、便携性，可以满足用户的不同需求。笔记本电脑的结构主要由显示器、主机、键盘、触摸板、电池等组成；它的功能主要有文字处理、图像处理、网络通信、多媒体播放等；它的优势主要有小巧、轻便、便携性、性能高、价格低等；它的应用非常广泛，可以用于办公、学习、娱乐等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acdbede12b2ef8caaec69c8b1148839b/" rel="bookmark">
			U盘无法格式化？快速解决方法大揭秘！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介：本文将介绍如何解决U盘无法格式化的问题，并提供快速解决方法。无法格式化的U盘可能会导致数据无法读取或写入，因此解决这个问题具有重要价值。
工具原料：
电脑品牌型号：Lenovo ThinkPad T480
操作系统版本：Windows 10
软件版本：DiskGenius 5.4.2
一、U盘无法格式化的可能原因 1、病毒感染
2、U盘损坏
3、写保护开关打开
二、解决方法 1、使用病毒查杀软件
步骤：
（1）下载并安装病毒查杀软件，如360安全卫士。
（2）打开病毒查杀软件，进行全盘扫描。
（3）删除或隔离病毒文件。
2、修复U盘文件系统
步骤：
（1）插入U盘，打开“我的电脑”。
（2）右键点击U盘，选择“属性”。
（3）点击“工具”选项卡，点击“检查”。
（4）勾选“自动修复文件系统错误”选项，点击“开始”。
3、使用磁盘管理工具
步骤：
（1）打开磁盘管理工具，如DiskGenius。
（2）选择U盘，右键点击，选择“格式化分区”。
（3）选择文件系统类型和分区大小，点击“开始”。
（4）确认操作，等待格式化完成。
总结： 通过使用病毒查杀软件、修复U盘文件系统和使用磁盘管理工具，可以解决U盘无法格式化的问题。在处理U盘无法格式化问题时，及时采取正确的方法可以保护数据安全，并恢复U盘的正常使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/912cfefa5bec328c38d834854cdfb8b5/" rel="bookmark">
			超详细解析Spring Boot自动装配原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Boot的自动装配原理(易懂) 熟练使用Spring Boot那么自动装配原理的掌握是必不可少的
一、自动装配是什么 Spring Boot的自动装配实际上是从META-INF/spring.factories文件中获取到对应的需要进行自动装配的类，并生成相应的Bean对象，然后将它们交给Spring容器进行管理
二、启动类注解流程关系分析 java
复制代码
@SpringBootApplication public class EntryApplication { public static void main(String[] args) { SpringApplication.run(EntryApplication.class, args); } } 1.首先展示@SpringBootConfiguration注解流程图 @SpringBootApplication
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan
@AutoConfigurationPackage
@Import(AutoConfigurationImportSelector.class)
@Import(AutoConfigurationPackages.Registrar.class)
2.代码块展示@SpringBootConfiguration注解流程 启动类的@SpringBootAppliation注解是一个组合注解,由以下3个注解组成
java
复制代码
@SpringBootConfiguration @EnableAutoConfiguration @ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) }) public @interface SpringBootApplication { 其中@EnableAutoConfiguration 注解又分为以下两种注解
java
复制代码
@AutoConfigurationPackage @Import(AutoConfigurationPackages.Registrar.class) //给容器中导入一个组件 public @interface AutoConfigurationPackage {} //利用Registrar给容器中导入一系列组件 其中@AutoConfigurationPackage 注解则由以下注解构成
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/912cfefa5bec328c38d834854cdfb8b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04a088aff5139485505ab747a57e4bfa/" rel="bookmark">
			2021年全国职业院校技能大赛_高职题目(Ubuntu题)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		任务书_A卷 使用给定的虚拟机系统文件（ova 文件）在服务器电脑上还原 Ubuntu 系
统。 使用控制台命令设置系统拒绝 IP 为 192.168.100.100 这台 PC 机访问。 //禁用ip sudo iptables -I INPUT -s 192.168.100.100 -j DROP // 查看 sudo iptables -L INPUT 任务书_B卷 请使用命令查询网络地址配置结果，请将查询结果界面截图（要求截图
中可以看到具体的命令） ifconfig 配置账户锁定策略，用户尝试登录失败 5 次后锁定用户 5 分钟. // /etc/pam.d/login 该文件需要修改权限或者使用root用户才能修改 vim /etc/pam.d/login //需写在配置文件前方 auth required pam_tally2.so deny=5 even_deny_root root_unlock_time=300 unlock_time=300 配置账户密码最短使用期限为 7 天，最长使用期限为 90 天 vim /ect/login.defs //修改配置 PASS_MIN_DAYS 7 PASS_MAX_DAYS 90 4.配置用户使用 ssh 登录边缘服务器时应该有“For authorized users
only”
sudo nano /etc/motd //在文件中添加需要添加的信息 任务书_C卷 使用 SSH 登录 Ubuntu 系统 sudo apt install openssh-server sudo ufw allow 22 sudo ufw allow 80 vim /etc/sshd/sshd_config PermitRootLogin yes service ssh restart 使用命令查询系统运行时间及负载的状态 uptime 使用命令查看文件系统磁盘空间使用情况。 df 4使用命令统计系统 IO 信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04a088aff5139485505ab747a57e4bfa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a898f9de78b44622b742cf2e255fe268/" rel="bookmark">
			Python实现京东茅台抢购脚本, 原来这么简单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 大家早好、午好、晚好吖 ❤ ~欢迎光临本文章
开发环境: python 3.8 运行代码
pycharm 2022.3.2 辅助敲代码 专业版
京东茅台抢购脚本可以分为以下几部分，具体实现步骤如下：
1. 登录京东账号 首先需要登录京东账号。
一个简单的方式是使用Python的 selenium 库。
在使用 selenium 库前，需要安装 selenium 库和对应的浏览器驱动。
（需要安装教程可看文章下方名片）
示例代码如下所示：
from selenium import webdriver browser = webdriver.Chrome() # 初始化浏览器 browser.get('https://www.jd.com/') # 打开京东首页 # 用户登录，填写用户名和密码 # 完整源码文档：加V:pytho8987免费获取，验证记得备注“777” username = browser.find_element_by_id('username') username.send_keys('your_username') password = browser.find_element_by_id('password') password.send_keys('your_password') submit = browser.find_element_by_id('loginBtn') submit.click() 注意：
在使用 selenium 的时候，要配置对应的浏览器驱动，
这里我选择的是 Chrome 浏览器，所以需要下载 Chrome 浏览器驱动并添加到系统环境变量中。
2. 进入茅台商品页面 登录后需要进入茅台商品页面，获取商品链接。
browser.get('https://item.jd.com/100012043978.html') # 进入茅台商品的页面 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a898f9de78b44622b742cf2e255fe268/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/338a614029e3c5a0704c7bada1076856/" rel="bookmark">
			从0到1ES集群搭建实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ES集群搭建实践
虚拟机安装 下载地址 Windows &amp; Linux：WMware Workstation 16 Pro
MacOS：WMware Fusion
构建CentOS镜像 下载系统镜像 下载地址：https://centos.org/download/
选择符合符合你电脑的指令集版本，比如我的CPU是 x86_64架构
配置网卡信息 vi /etc/sysconfig/network-scripts/ifcfg-ens33 TYPE="Ethernet" PROXY_METHOD="none" BROWSER_ONLY="no" BOOTPROTO="none" # 关闭dhcp，需要固定ip DEFROUTE="yes" IPV4_FAILURE_FATAL="no" IPV6INIT="yes" IPV6_AUTOCONF="yes" IPV6_DEFROUTE="yes" IPV6_FAILURE_FATAL="no" IPV6_ADDR_GEN_MODE="stable-privacy" NAME="ens33" UUID="6dcded77-ba54-4f70-a16c-80535656ba86" DEVICE="ens33" ONBOOT="yes" IPADDR="192.168.3.81" #修改每个节点的ip地址 PREFIX="24" GATEWAY="192.168.3.1" ## 确定网关地址 DNS1="114.114.114.114" DOMAIN="8.8.8.8" IPV6_PRIVACY="no" 重启网卡 service network restart
网卡重启报错的话，重启虚拟机
网卡验证 远程登录验证
创建elastic用户 使用elasticsearch账号操作：启动，关闭等
创建用户 useradd elastic
修改密码命令 passwd elastic
账号添加到sudoer elastic is not in the sudoers file
su visudo -f /etc/sudoers ## Then add the user below admin user like below syntax.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/338a614029e3c5a0704c7bada1076856/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4c322b15ccc622b25a4ab5ee0514a52/" rel="bookmark">
			SpringMVC 中的常用注解和用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		观前提示:本篇博客演示使用的 IDEA 版本为2021.3.3版本,使用的是Java8(又名jdk1.8)
电脑使用的操作系统版本为 Windows 10
目录
前言
Spring Boot
Spring MVC
1. MVC
1.1 MVC 和 Spring MVC 之间的关系
2. 创建 Spring MVC 项目
创建一个 SpringMVC 项目
1. new project
2. 选择 SpringBoot 项目, 选择合适的 jdk 版本, 设置创建项目源
3. 项目的参数
4. 选择Spring Boot 版本, 添加项目依赖
5. 设置项目名称和保存路径
6. 确保 idea 正常加载Spring Boot 项目
7. 删除无用文件(可删可不删)
8. Spring Boot 目录说明
3. SpringMVC 中的常用注解和用法
3.1 实现连接
@RequestMapping 支持 GET 和 POST
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4c322b15ccc622b25a4ab5ee0514a52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6debc541e1a8edcfb794f5b27b202b06/" rel="bookmark">
			txt小说阅读美化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
txt小说阅读美化（电脑edge浏览器） 前言一、效果截屏演示 二、使用步骤版本1：版本22.代码说明 总结 前言 前言：
突然在电脑找到一本txt格式小说，使用浏览器打开后界面太难看
我想试着模拟一下小说网站的阅读，提取个目录出来。。。。并实现点击跳转至对应内容。。
实现功能：
美化界面（bushi)提取目录点击章节跳转对应章节 版本2已解决版本1的不足。
一、效果 截屏 版本1：
版本2：
演示 二、使用步骤 按住ctrl+shift+i
在控制台输入如下代码，然后按回车
版本1： 样式可以，逻辑有些问题，只能匹配第中文章+空格+章名
//设置样式 document.body.style="display: flex;background-color: gainsboro;" let pre=document.querySelector("pre");// pre.setAttribute("style", "word-wrap: break-word;" + "white-space: pre-wrap;margin:auto;"+ "font-size: 21px;width: 40%;"); //必须设置了width不是占100%，再margin:auto，才能让pre居中。。 //获取目录 let text=pre.innerText //[\u4e00-\u9fa5]匹配中文，.匹配除换行符以外的所有符号。 let dir=text.match(/第[\u4e00-\u9fa5]+章 .{1,10}/g) let dirDiv=document.createElement("div") //注意是className dirDiv.className="dirDiv" console.log(dir) //将目录以列表形式展示 for(let i=0;i&lt;dir.length;i++){ let li=document.createElement("li"); //目录里第一章+空格+空格+起始。这里有两个空格，而正文里只有一个，就能保证搜索就会只搜到正文的。 li.innerText=dir[i].substring(0,dir[i].indexOf("章")+1)+' '+dir[i].substring(dir[i].indexOf("章")+2,); console.log(li.innerText) dirDiv.appendChild(li); } document.body.appendChild(dirDiv) //点击目录区域触发事件，事件委托：把原本需要绑定在子元素的响应事件委托给父元素 事件委托的好处:减少对DOM的操作 dirDiv.onclick=(event)=&gt;{ //event.target找到最终点击的元素。最开始冒泡的元素 let dirtitle=event.target.innerText; let keyword=dirtitle.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6debc541e1a8edcfb794f5b27b202b06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a965155243222226f2d58ebf51db80b1/" rel="bookmark">
			python如何查找列表中元素的位置浅谈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章主要介绍了python如何查找列表中元素的位置，具有很好的参考价值，希望对大家有所帮助。
如何查找列表中元素的位置 问题描述 给出一个包含n个整数的数列，问整数a在数列中的第一次出现是第几个。
输入格式 第一行包含一个整数n。
第二行包含n个非负整数，为给定的数列，数列中的每个数都不大于10000。
第三行包含一个整数a，为待查找的数。
样例输入 6
1 9 4 8 3 9
9
样例输出 2
1
2
3
4
5
6
7
8
n = int(input())
x = list(map(int,input().split()))
a = int(input())
if a in x:
b = x.index(a)
print(b+1)
else:
print(-1)
python中list()查找方法 list五种查找方式 in,not in,count,index,find前两种方法是保留字，后两种是列表的方法
函数EXA 1
2
3
4
5
6
7
8
9
10
11
#判断值a是否在列表中，并返回True或False
'a' in lst
'a' not in lst
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a965155243222226f2d58ebf51db80b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aeca892526fd0268724b648de589a435/" rel="bookmark">
			【论文写作】LaTeX学习笔记：一文入门LaTeX（超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、LaTeX源文件的基本结构1.1 基本结构1.2、导言区1.2.1 \documentclass1.2.2 \usepackage1.2.3 封面格式 1.3 正文区1.4 完整示例 二、LaTeX中的中文处理办法2.1 设置支持中文2.1.1 编译器设置2.1.2 引入ctex宏包2.1.3 设置文档格式 2.2 设置中文字体格式 三、LaTeX的字体字号设置3.1 字体属性介绍3.2 字体族设置3.3 字体大小设置3.4 中文字号设置3.5 英文字体格式设置3.6 自定义字体设置命令3.7 完整示例代码 四、LaTeX的篇章结构4.1 \section构建小节4.2 \subsection 构建子小节4.3 \subsubsection 构建子子小节4.4 生成目录4.5 完整代码 五、LaTeX中的特殊字符5.1 空白字符5.2 控制符5.3 排版符号5.4 标志符号5.5 引号5.6 连字符5.7 非英文字符5.8 重音字符（以o为例）5.9 完整代码 六、LaTeX中的插图6.1 基本语法6.1.1 引入宏包6.1.2 指定图片路径6.1.3 语法 6.2 完整代码 七、LaTeX中的表格7.1 基本语法7.2 代码示例 八、LaTeX中的浮动体8.1 基本语法8.2 浮动格式htbp8.3 代码示例 九、LaTeX中的数学公式9.1 行内公式9.2 上下标9.3 希腊字母9.4 数学函数9.5 分式9.6 行间公式9.7 简单矩阵9.8 多行公式 十、LaTeX中的参考文献BibTex10.1 编辑器设置10.2 创建bib文件10.3 指定参考文献样式10.4 完整代码 十一、LaTeX中的自定义命令和环境11.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aeca892526fd0268724b648de589a435/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49538eb22ec7887ebb9caf31781d6626/" rel="bookmark">
			PyQT5介绍及基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 PyQt51. PyQt5的下载与安装1.1 PyQt5介绍1.2 windows PyQt5的安装 2.PyQt5基本UI2.1 第一个PyQt程序2.2 argv2.3 模块介绍 3.基本UI3.1 按钮QPushButton3.2 文本QLabel3.3 输入框3.4 调整窗口大小3.5 调整窗口显示屏幕中间3.6 设置窗口icon 4.布局4.1 QBoxLayout4.1.1 垂直布局4.1.2 水平布局 4.2 QGridLayout网格布局 4.3 QFormLayout4.4 抽屉布局 5. 窗口5.1 分类5.2 QWidget5.2 QMainWindow5.3 QDialog 6. 信号与槽6.1 信号与槽介绍6.2 案例6.3 自定义信号 7.Qt Designer7.1 介绍7.2 下载7.3 安装&amp;运行7.4 使用QT Designer7.5 使用流程 PyQt5 1. PyQt5的下载与安装 1.1 PyQt5介绍 Qt（官方发音 [kju:t]）是一个跨平台的C++开发库，主要用来开发图形用户界面（Graphical User Interface，GUI）程序
Qt 是纯 C++ 开发的，正常情况下需要先学习C语言、然后在学习C++然后才能使用Qt开发带界面的程序
多亏了开源社区使得Qt 还可以用Python、Ruby、Perl 等脚本语言进行开发。
Qt 支持的操作系统有很多，例如通用操作系统 Windows、Linux、Unix，智能手机系统Android、iOS， 嵌入式系统等等。可以说是跨平台的
QT官网：https://doc.qt.io/qt-5/index.html
PyQt的开发者是英国的“Riverbank Computing”公司。它提供了GPL（简单的说，以GPL协议发布到网上的素材，你可以使用，也可以更改，但是经过你更改然后再次发布的素材必须也遵守GPL协议，主要要求是必须开源，而且不能删减原作者的声明信息等）与商业协议两种授权方式，因此它可以免费地用于自由软件的开发。
PyQt可以运行于Microsoft Windows、Mac OS X、Linux以及Unix的多数变种上。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49538eb22ec7887ebb9caf31781d6626/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/857d8e441f49a987e695413a1527078e/" rel="bookmark">
			MSoffice(excel,word,ppt)暴力破解密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先直接上成品，拿来就可以用
https://download.csdn.net/download/wangzhenhaha12/87892912
再来谈思路
win32com.client
Mac上用不了 msoffcrypto pip install msoffcrypto-tool step1 穷举密码 # digit for i in range(48, 58): print(chr(i)) 三层for循环实现密码的穷举
for length in range(1, 1 + 2): base = len(charset) for i in range(base ** length): # print('数%s' % i) for j in range(length, 0, -1): # print('位%s' % j) import itertools i = itertools.product('abcdefghigklmnopqrstuvwxyz1234567890', repeat=20) for j in i: print(j) step2 逐个尝试 import msoffcrypto import io import pandas as pd # BASIC encrypted = open("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/857d8e441f49a987e695413a1527078e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90251237ba0044448bb2ae29b74d6f14/" rel="bookmark">
			Linux开源存储漫谈（1）环境准备篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近几年持续研究本地存储及分布式存储，好多东西学了忘，忘了再学走了一些弯路，总结一下，权作记录，也期望对同样对存储有浓厚兴趣的同学有所借鉴。
存储系统与CPU、内存一样，是计算机不可或缺的组成部分，存储系统的重要性见：存储系统。Linux操作系统因为其开源免费、安全、稳定、可靠，成为企业服务器部署的首选之一，亦是托管平台的首选，同时在云计算领域也得到了广泛应用。我们知道，企业应用大体上可分两种负载，事务型负载及分析负载，但是无论哪一种负载，都需要有足够好的系统整体扩展性以满足急速变化的需求，CPU、内存等计算资源可以通过更换性能更优的硬件满足系统扩展性需求，但是对于存储，容量及吞吐量的同步提升就没有那么容易了，甚至需要系统级的重构。另外，相比于CPU、内存、网络等，存储更容易引起系统性风险。所以，Linux存储必然是构建高可靠企业应用的最重要的必备技能之一
Linux开源存储漫谈，将会涵盖linux IO栈、文件系统、iSCSI、spdk、IO虚拟化等相关的技术原理介绍，配合测试环境，记录并对比不同场景下的性能指标数据，逐步构建Linux存储相关技术及工具的概要认知。但是，由于存储复杂加之本人水平有限，难免有所纰漏，还望指正共同进步
Linux存储涉及的技术比较多，为了减少不必要的干扰，建议从一个全新的、干干净净的、并且内核版本比较高的系统开始
1. 硬件及操作系统信息 CPU：英特尔酷睿10代 I5-10400F，6核12线程，12M缓存Memory：DDR4 2666 32G主板：技嘉B460M硬盘：2T 希捷7200转 256M SATA + 金士顿M.2固态(NVME协议) 1T NV2 PCIe 4.0BIOS开启VT-D操作系统：Ubuntu-live-server 22.04.2，操作系统安装于SATA硬盘，后续spdk测试用NVME盘网络设置，使用dhcp路由器分配ip地址（强烈建议，原因：减少不必要的干扰）执行hostnamectl set-hostname nvme.iscsi.com建议开启root用户（后续未经说明均为root用户执行） 2. 修改Linux启动参数启用iommu 修改/etc/default/grub文件GRUB_CMDLINE_LINUX行，然后执行grub-mkconfig后重启操作系统，使修改生效。
root@nvme:~# cat /etc/default/grub | grep "^GRUB_CMDLINE_LINUX=" GRUB_CMDLINE_LINUX="quiet intel_iommu=on" root@nvme:~# root@nvme:~# grub-mkconfig -o /boot/grub/grub.cfg 通过如下命令检查iommu，注意，开启iommu后/sys/kernel/iommu_groups目录是不为空
root@nvme:~# dmesg | grep "DMAR: Intel" [ 1.493774] DMAR: Intel(R) Virtualization Technology for Directed I/O root@nvme:~# ls /sys/kernel/iommu_groups/ 0 1 2 3 4 5 6 7 8 root@nvme:~# 3. 网桥 测试qemu-kvm场景下LIO iscsi target及spdk iscsi target都会用到，先运行"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90251237ba0044448bb2ae29b74d6f14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33d87a1cf1bb1ff6d1df6401beda752e/" rel="bookmark">
			【Oracle笔记】最详细的操作命令大全（基础版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、创建表2、插入数据3、查询数据4、更新数据5、删除数据6、新增字段7、修改字段8、删除字段9、重命名表10、清空表11、删除表12、表只读13、查看该用户的所有表14、order by 排序15、分组16、备份表17、新增主键18、删除主键19、新增索引20、删除索引21、创建同义词22、删除同义词 1、创建表 create table mytest(id varchar2(2 char),name varchar2(3 char)); 2、插入数据 insert into mytest(id,name) values('01','tom'); 3、查询数据 select * from mytest; 4、更新数据 update mytest set name='mm' where id='03'; 5、删除数据 delete from mytest where id='03'; 6、新增字段 alter table mytest add (address varchar2(100 char)); 7、修改字段 alter table mytest rename column address to addr; alter table mytest modify address varchar2(200 char); 8、删除字段 alter table mytest drop (addr); 9、重命名表 alter table mytest rename to mytest2; 10、清空表 delete from mytest;--删除数据，可回滚 truncate table mytest;--删除数据，不可回滚，并重置计数器 11、删除表 drop table mytest;--删除表，可恢复（flashback table mytest to before drop ） drop table mytest purge;--删除表，无法恢复 12、表只读 alter table mytest read only;--只读 alter table mytest read write;--恢复读写 13、查看该用户的所有表 select table_name from user_tables; 14、order by 排序 desc：降序
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33d87a1cf1bb1ff6d1df6401beda752e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/473a0eb5a7536857aab609e2a5851f7c/" rel="bookmark">
			SQL必须懂的高级查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQL高级查询详解 一、前言二、高级查询2.1、基础查询2.2、条件查询2.3、范围查询2.4、判空查询2.5、模糊查询2.6、分页查询2.7、查询后排序2.8、聚合查询2.9、分组查询 三、联表查询3.1、INNER JOIN3.2、LEFT JOIN3.3、RIGHT JOIN 四、子查询/合并查询4.1、单行子查询4.2、多行子查询4.3 正则表达式 总结 一、前言 SQL 是关系型数据库的标准语言，所有的关系型数据库都支持 SQL，比如 MySQL、Oracle、SQL Server、MS Access、DB2 等。不学习 SQL，就没法使用关系型数据库。SQL 仅仅是一种查询语言，它不是数据库，要想使用 SQL，您需要安装一款数据库。
有些数据库在标准 SQL 的基础上进行了扩展或者裁减，形成了不同的“方言”，比如：
SQL Server 使用 T-SQL.Oracle 使用 PL/SQL；MS Access 使用的 SQL 被称为 JET SQL。 高级查询可以让我们的SQL语句更加灵活，完成更多的任务需求。
二、高级查询 做一下准备，为下面的查询操作建立数据库。
DROP TABLE IF EXISTS `class`; CREATE TABLE `class` ( `cid` int(11) NOT NULL AUTO_INCREMENT, `caption` varchar(32) NOT NULL, PRIMARY KEY (`cid`) ) ENGINE=innoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8; DROP TABLE IF EXISTS `student`; CREATE TABLE `student` ( `sid` int(11) NOT NULL AUTO_INCREMENT, `gender` char(1) NOT NULL, `class_id` int(11) NOT NULL, `sname` varchar(32) NOT NULL, PRIMARY KEY (`sid`), KEY `fk_class` (`class_id`), CONSTRAINT `fk_class` FOREIGN KEY (`class_id`) REFERENCES `class` (`cid`) ) ENGINE=innoDB AUTO_INCREMENT=17 DEFAULT CHARSET=utf8; DROP TABLE IF EXISTS `teacher`; CREATE TABLE `teacher` ( `tid` int(11) NOT NULL AUTO_INCREMENT, `tname` varchar(32) NOT NULL, PRIMARY KEY (`tid`) ) ENGINE=innoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8; DROP TABLE IF EXISTS `course`; CREATE TABLE `course` ( `cid` int(11) NOT NULL AUTO_INCREMENT, `cname` varchar(32) NOT NULL, `teacher_id` int(11) NOT NULL, PRIMARY KEY (`cid`), KEY `fk_course_teacher` (`teacher_id`), CONSTRAINT `fk_course_teacher` FOREIGN KEY (`teacher_id`) REFERENCES `teacher` (`tid`) ) ENGINE=innoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8; DROP TABLE IF EXISTS `score`; CREATE TABLE `score` ( `sid` int(11) NOT NULL AUTO_INCREMENT, `student_id` int(11) NOT NULL, `course_id` int(11) NOT NULL, `num` int(11) NOT NULL, PRIMARY KEY (`sid`), KEY `fk_score_student` (`student_id`), KEY `fk_score_course` (`course_id`), CONSTRAINT `fk_score_course` FOREIGN KEY (`course_id`) REFERENCES `course` (`cid`), CONSTRAINT `fk_score_student` FOREIGN KEY (`student_id`) REFERENCES `student` (`sid`) ) ENGINE=innoDB AUTO_INCREMENT=53 DEFAULT CHARSET=utf8; 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/473a0eb5a7536857aab609e2a5851f7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e90d3bcc11c19a9ba03bb6edb8363ea5/" rel="bookmark">
			关系数据库SQL数据查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关系数据库SQL数据查询 数据查询 一、单表查询 1.查询仅涉及一个表，选择表中的若干列 [例1] 查询全体学生的学号与姓名。 SELECT Sno,Sname FROM Student; [例2] 查询全体学生的姓名、学号、所在系。 SELECT Sname,Sno,Sdept FROM Student; 查询全部列
选出所有属性列：在SELECT关键字后面列出所有列名将&lt;目标列表达式&gt;指定为 * [例3] 查询全体学生的详细记录 SELECT Sno,Sname,Ssex,Sage,Sdept FROM Student; 或 SELECT * FROM Student; 查询经过计算的值
SELECT子句的&lt;目标列表达式&gt;不仅可以为表中的属性列，也可以是表达式 [例4] 查全体学生的姓名及其出生年份。 SELECT Sname,2014-Sage /*假设当时为2014年*/ FROM Student; 输出结果： Sname 2014-Sage 李勇 1994 刘晨 1995 王敏 1996 张立 1995 使用列别名改变查询结果的列标题:
SELECT Sname NAME,'Year of Birth:' BIRTH, 2014-Sage BIRTHDAY,LOWER(Sdept) DEPARTMENT FROM Student; 输出结果： NAME BIRTH BIRTHDAY DEPARTMENT 李勇 Year of Birth: 1994 cs 刘晨 Year of Birth: 1995 cs 王敏 Year of Birth: 1996 ma 张立 Year of Birth: 1995 is 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e90d3bcc11c19a9ba03bb6edb8363ea5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57c3f5aec094edf82971aaee316ca465/" rel="bookmark">
			ubantu20.04 一键部署 RocketChat 服务完整教程（极简）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开始前我们先更新下操作系统
sudo apt update &amp;&amp; sudo apt upgrade 全选代码
复制
安装 Rocket.Chat 最快的方法是使用它的 Snap。Snap 是 Linux 系统上一种软件包管理的方式。它类似一个容器拥有一个应用程序所有的文件和库，各个应用程序之间完全独立。所以使用snap包的好处就是它解决了应用程序之间的依赖问题，使应用程序之间更容易管理。在 Ubuntu 16.04 LTS 以上版本的系统都内置了。
只需部署SNAPD环境包即可：
执行
sudo apt-get install snapd 全选代码
复制
安装 Rocket.Chat 执行 一定要手动输入
sudo snap install rocketchat-server 全选代码
复制
提示了：rocketchat-server (6.x/stable) 6.2.5 from Rocket.Chat (rocketchat✓) installed 则表示安装成功！
可以通过 http://IP:3000访问
安装后，Rocket.Chat 服务会自动启动，检查一下是否在运行：
sudo service snap.rocketchat-server.rocketchat-server status 全选代码
复制
你可以访问 Rocket.Chat snap 查看一些其他命令。
nginx返代理设置
//我们从安装Nginx开始：
# sudo apt install nginx //安装 Nginx 后，我们继续为 RocketChat 配置虚拟主机：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57c3f5aec094edf82971aaee316ca465/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d38fa3e77bdb5279be212e180c4e7a38/" rel="bookmark">
			h264结构与码流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		h264基本概念结构图 H264视频压缩后会成为一个序列帧，帧里包含图像，图像分为很多片，每个片可以分为宏块，每个宏块由许多子块组成
H264结构中，一个视频图像编码后的数据叫做一帧，一帧由一个片（slice）或多个片组成，一个片由一个或多个宏块（MB）组成，一个宏块由16x16的yuv数据组成。宏块作为H264编码的基本单位。
场和帧： 视频的一场或者一帧可以用来产生一个编码图像。在PAL电视中，每个电视帧都是通过扫描屏幕两次而产生的，第二个扫描的线条刚好填满第一次扫描所留下的缝隙。每个扫描即称为一个场(顶场底场)。因此 30 帧/秒的电视画面实际上为 60 场/秒
I帧 P帧 B帧，引用斯巴克兄弟的博客，图文并茂
举个简单的例子，网络上的电影很多采用了B帧，因为B帧记录的是前后帧的差别，比P帧能节约更多的空间。但是如果遇到不支持B帧的播放器就会很尴尬，因为虽然文件通过B帧压缩确实缩小了非常多，但是在解码时，不仅要用之前缓存的画面，还要知道下一个I或者P的画面。如果B帧丢失，就会用之前的画面简单重复，就会造成画面卡，B帧越多，画面越卡。
一般来说，I 帧的压缩率是7（跟JPG差不多），P 帧是20，B 帧可以达到50。
在如上图中，GOP (Group of Pictures)长度为13，S0 ~ S7 表示 8个视点，T0~T12 为 GOP的 13个时刻。每个 GOP包含帧数为视点数 GOP 长度的乘积。在该图中一个 GOP 中，包含94 个 B帧。B 帧占一个 GOP 总帧数的 90.38%。GOP 越长，B 帧所占比例更高，编码的率失真性能越高
I帧只包含I宏块
P帧包含I宏块和P宏块
B帧包含I宏块、P宏块、B宏块
当帧内slice全部为I像片时，则此帧为I帧
当全部为P slice或和I slice的组合时，则为P帧
当为B slice或和I、P slice的组合时，则为B帧。
片（slice）： 每个图像中，若干个宏块被排列成片。片的目的：为了限制误码的扩散和传输，使编码片相互间保持独立。片共有5种类型：I片（只包含I宏块）、P片（P宏块和/或I宏块）、B片（B宏块和/或I宏块）、SP片（用于不同编码流之间的切换，包含P宏块和/或I宏块）和SI片（特殊类型的编码宏块，包含SI宏块）。
I slice只包含I宏块
P slice包含P宏块和/或I宏块
B sliceB宏块和/或I宏块。
宏块： 一个编码图像首先要划分成多个块（4x4 像素）才能进行处理，显然宏块应该是整数个块组成，通常宏块大小为16x16个像素。宏块分为I、P、B宏块，I宏块只能利用当前片中已解码的像素作为参考进行帧内预测；P宏块可以利用前面已解码的图像作为参考图像进行帧内预测；B宏块则是利用前后向的参考图形进行帧内预测
序列（切片slice）和宏块的关系如下
切片头：包含了一组片的信息，比如片的数量，顺序等等
H264编码分层 NAL层:（Network Abstraction Layer,视频数据网络抽象层）： 关心压缩后如何进行传输，它的作用是H264只要在网络上传输，在传输的过程每个包以太网是1500字节，而H264的帧往往会大于1500字节，所以要进行拆包，将一个帧拆成多个包进行传输，所有的拆包或者组包都是通过NAL层去处理的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d38fa3e77bdb5279be212e180c4e7a38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c11a98fee1115689de416743e96fd4e8/" rel="bookmark">
			【VSCODE】3、如何支持点击函数跳转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在安装 vscode 之后，需要配置一下才能支持 【command+鼠标】实现函数跳转
一、配置方式 我要配置的是 python 语言，以 python 语言为例来设置
1、在扩展商店搜索 python 并安装
2、安装完成后点击设置按钮，进入扩展设置
3、在扩展设置中搜索 go to definition，将下面红框的两项设置为 goto
二、如何跳转 在完成上述配置之后 mac 就可以使用 【command+鼠标点击】来实现函数的跳转啦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64fbdf6ebb490a67db1843a12358eaea/" rel="bookmark">
			Ubuntu上用java控制LED灯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、环境介绍
2、设备介绍
3、前期准备
3.1.给Ubuntu安装jdk
4、编写java代码
4.1.获取gpio引脚编号和路径
4.2.编写java代码
5、在Ubuntu系统上运行
6.在Ubuntu上使用终端直接控制LED ,操作如下:
1、环境介绍 JAVA Intellij IDEA 2022.3.3 (Ultimate Edition)
jdk-1.8.0_77
Ubuntu Linux version 5.10.110 (root@seven-HP-ZHAN-99-Pro-G1-MT) (aarch64-none-linux-gnu-gcc (GNU Toolchain for the A-profile Architecture 10.3-2021.07 (arm-10.29)) 10.3.1 20210621, GNU ld (GNU Toolchain for the A-profile Architecture 10.3-2021.07 (arm-10.29)) 2.36.1.20210621) #11 SMP Fri Feb 10 18:15:24 CST 2023
openjdk version "11.0.18" 2023-01-17
OpenJDK Runtime Environment (build 11.0.18+10-post-Ubuntu-0ubuntu120.04.1)
OpenJDK 64-Bit Server VM (build 11.0.18+10-post-Ubuntu-0ubuntu120.04.1, mixed mode)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64fbdf6ebb490a67db1843a12358eaea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e12d019204d8ab296debac784a4bda1/" rel="bookmark">
			电脑重装系统后需要更新哪些驱动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在电脑重装系统后，由于系统的重置，您需要重新安装和更新一些关键的驱动程序，以确保硬件设备正常工作和性能最佳化。以下是在电脑重装系统后需要更新的一些常见驱动程序。
工具/原料：
系统版本：win10系统
品牌型号：戴尔 XPS13-9350-3708
软件版本：魔法猪系统重装大师 v.12.7.48.1940
1. 显卡驱动：显卡驱动是重要的驱动程序之一，它负责控制显示器的输出和图形处理。您可以从显卡厂商的官方网站或驱动程序更新工具中下载最新的显卡驱动程序，并根据您的显卡型号进行安装。
2. 声卡驱动：声卡驱动是控制音频输出和录音功能的关键驱动程序。同样，您可以从声卡厂商的官方网站或驱动程序更新工具中获取最新的声卡驱动程序，并进行安装。
3. 网络适配器驱动：网络适配器驱动负责控制计算机的网络连接。根据您使用的网络适配器类型，您可以从制造商的官方网站或驱动程序更新工具中下载适用于您的网络适配器的最新驱动程序。
4. 主板芯片组驱动：主板芯片组驱动程序是控制主板上各种硬件组件和接口的驱动程序。您可以从主板制造商的官方网站上下载适用于您的主板型号的最新主板芯片组驱动，并进行安装。
5. 其他外部设备驱动：如果您连接了其他外部设备，例如打印机、摄像头、扫描仪等，您可能需要更新这些设备的驱动程序，以确保它们与新系统兼容并正常工作。您可以访问相应设备的制造商网站来获取最新的驱动程序。
请注意，在更新驱动程序之前，确保下载来自官方和可信赖的来源，并根据厂商提供的指导进行安装。此外，您还可以考虑使用专业的驱动程序更新工具，以简化更新过程并确保驱动程序的最新性。
通过更新这些关键的驱动程序，您可以确保系统的稳定性和性能，并充分发挥计算机硬件的潜力。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3204ba945298a8b3a85032d252825d8f/" rel="bookmark">
			SpringBoot项目后端开发逻辑梳理总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot项目中包含Mapper层（Dao层）、Entity层（model层）、DTO层、VO层、Service层和Controller层（本篇以学生信息表增删改查为例，梳理各个层之间的逻辑关系、开发流程和注意事项）。
目录
一、各层之间的逻辑关系
1.Controller层、Service层、Mapper层、Entity层的逻辑关系
2.每层的理解
1.mapper层（Dao层）。
2.Entity层（model层）
3.DTO层
4.VO层
5.service层
6.Controller层
二、运行流程
三、开发流程
1、实体类
2、Service接口
3、xml文件
4、Mapper接口
5、ServiceImpl实现类
6、Controller层调用接口
一、各层之间的逻辑关系 1.Controller层、Service层、Mapper层、Entity层的逻辑关系 2.每层的理解 1.mapper层（Dao层）。 mapper层是操作数据库的一层。想要访问数据库并且操作，只能通过mapper层向数据库发送sql语句，将这些通过接口传给service层，对数据库进行操作。主要实现增删改查操作，在mybatis中与xxx.xml内相互一一映射。
mapper层包含xxxDao.java文件和xxxDao.xml
(.xml文件中写sql语句，配置通用查询映射结果)
（Dao.java相当于xml文件的抽象类）
StudentBaseDao.xml
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="com.ai.citicnet.boss.manage.service.dao.student.StudentBaseDao"&gt; &lt;sql id="baseColumns"&gt; id, name, sex, age, chinese, math, tenglish &lt;/sql&gt; &lt;select id="queryList" parameterType="com.ai.citicnet.boss.manage.remote.model.vo.student.studentBaseForm" resultType="com.ai.citicnet.boss.manage.remote.model.dto.student.studentDTO"&gt; select * from student &lt;/select&gt; &lt;select id="queryRepeat" parameterType="java.util.Map" resultType="com.ai.citicnet.boss.manage.remote.model.dto.student.studentDTO"&gt; select name from student where name = #{abc} &lt;if test="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3204ba945298a8b3a85032d252825d8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/435538de338ece169abe2605bf0fc4e9/" rel="bookmark">
			python爬虫部分基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		模块
requests
requests是一个很实用的Python HTTP客户端库，爬虫和测试服务器响应数据时经常会用到，requests是Python语言的第=方的库，专门用于发送HTTP请求，使用起来比urllib简洁很多。
parsel
parsel是一个python的第三方库，相当于css选择器+xpath+re。
Darsel由scrapy团队开发，是将scrapy中的parsel独立抽取出来的，可以轻松解析html，xm内容，获取需要的数据.
相比于BeautifulSoup，xpath，parsel效率更高，使用更简单。
re
re模块是python独有的匹配字符串的模块，该模块中提供的很多功能是基于正则表达式实现的，而正则表达式是对字符串进行模糊匹配，提取自己需要的字符串部分，他对所有的语言都诵用。
os
os 就是"operating ystem”的缩写，顾名思义，Os模块提供的就是各种 Phon 程席与操作系统进行可的接口。通过使用0s模块，一方面可以方便地与操作系统进行交互，另一方面也可以极大增强代码的可移植性。
CsV它是一种文件格式般也被叫做逗号分隔值文件，可以使用 Excel 软件或者文本文档打开 。其中数据字段用半角逗号间隔(也可以便用其它字符)使用 Excel打开时，逗号会被转换为分隔符。csv 文件是以纯文本形式存储了表格数据，并且在兼容各个操作系统。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee94533eedc6e8d095dd5bdf0369918c/" rel="bookmark">
			idea设置注释模板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 设置注释文件模板设置模板 设置注释文件模板 Ctrl + Alt + S 打开设置，Editor - File and Code Templates 选择class、interface、enum根据自己需要选择需要添加注释的文件，依次添加如下配置内容
/** 1. @ClassName ${NAME} 2. @Description TODO 3. @Author ${USER} 4. @Date ${DATE} ${TIME 5. @Version 1.0 */ 设置模板 Ctrl + Alt + S 依次点击 Editor - Live Templates ，给里面添加一个组，然后在组下添加两个模板，分别是类注释模板和方法注释模板，具体操作如下：
6. 添加group组，名称自己定义
2. 给刚建的组下添加类注释模板，内容填写 **，如下
填写模板内容 template text ，内容如下， 注意开头没有斜杠 ** * @ClassName $NAME$ * @Description TODO * @Author $USER$ * @Date $DATE$ $TIME$ * @Version 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee94533eedc6e8d095dd5bdf0369918c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/350c60d2f5a6b9dc671c447c78ec1a86/" rel="bookmark">
			Linux部署docker（最详细docker，一看就会）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker概述： Docker为什么会出现？ 一款产品：开发...测试..上线,三套环境！
例如：发布一个项目（jar+redis mysql jdk等），项目能不能带上环境安装一起打包
传统：java -- apk（应用）-- 发布（应用商店）--张三使用apk -- 下载安装即可使用
现在：java -- jar（环境）-- 打包项目带上环境（镜像）-- （docker仓库：商店） --下载我们发布的镜像 -- 直接运行即可！
Docker的核心思想：隔离
Docker的历史： 2010年，几个搞it的年轻人，就在美国成立了一家公司叫dotCloud
做一些pass的云计算服务，LXC有关的容器服务！
他们将自己的技术（容器化技术）命名为docker！
Docker刚刚诞生的时候，没有引起行业的注意！dotCloud，就活不下去了！
想到了“开源”
开放源代码！
2013年，docker开源！
Docker越来越多的人发现了docker的优点！火了，docker每个月都会有新的版本诞生！
2014年4月9日，docker1.0发布！
Docker至今短短10年为什么这么火？
十分轻巧
在容器技术出来之前，我们都是使用虚拟机（非常占内存及本地资源），vm、kvm等！
Docker如何安装： Docker的基本组成： 镜像（image）：就好比是个一个模板，可以通过这个模板来启动容器创建容器服务，tomcat镜像 --- run --- tomcat服务，可以经过这个镜像可以启动无数个（最终服务运行或项目运行就是在这个容器中的）
容器（container）：docker利用容器技术，独立运行一个或一组应用，通过镜像来创建的；容器的基本命令，启动、停止、删除！目前就可以把这个容器理解为就是一个简易的Linux系统。
仓库（repository）：仓库就是存放镜像的地方，仓库分为公有仓库和私有仓库。公有仓库有docker Hub（默认是国外的）、阿里云、腾讯云...都有容器服务器（我们需要配置镜像加速）
安装docker： 环境准备：系统centos7
帮助文档：
卸载旧的 版本 yum remove docker \
docker-client \
docker-client-latest \
docker-common \
docker-latest \
docker-latest-logrotate \
docker-logrotate \
docker-engine
安装依赖关系： yum install -y yum-utils
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/350c60d2f5a6b9dc671c447c78ec1a86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6719df2664498435c14aff63f88e3dc2/" rel="bookmark">
			vue2&#43;wangEditor5富文本编辑器（图片视频上传）并加锚链接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、wangEditor文本编辑器使用1、安装使用2、上传图片、视频 二、添加锚链接 一、wangEditor文本编辑器使用 官网：https://www.wangeditor.com/v5/installation.html#npm
1、安装使用 安装
yarn add @wangeditor/editor # 或者 npm install @wangeditor/editor --save yarn add @wangeditor/editor-for-vue # 或者 npm install @wangeditor/editor-for-vue --save 在main.js中引入样式
import '@wangeditor/editor/dist/css/style.css' 在使用编辑器的页面引入js
import { Editor, Toolbar } from "@wangeditor/editor-for-vue"; components: { Editor, Toolbar }, 模板
&lt;template&gt; &lt;div&gt; &lt;div style="border: 1px solid #ccc; margin-top: 10px"&gt; &lt;!-- 工具栏 --&gt; &lt;Toolbar style="border-bottom: 1px solid #ccc" :editor="editor" :defaultConfig="toolbarConfig" /&gt; &lt;!-- 编辑器 --&gt; &lt;Editor style="height: 400px; overflow-y: hidden"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6719df2664498435c14aff63f88e3dc2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5eef33b3cd635fd3d61192d1c52f2916/" rel="bookmark">
			深入浅出Git教程（转载）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		录一、版本控制概要 1.1、什么是版本控制1.2、常用术语1.3、常见的版本控制器1.4、版本控制分类 1.4.1、本地版本控制1.4.2、集中版本控制1.4.3、分布式版本控制1.5、Git与SVN最主要区别二、Git安装与配置 2.1、什么是Git2.2、搭建Git工作环境 2.2.1、下载Git2.2.2、安装Git2.2.3、启动Git2.2.4、Linux与Mac OS安装Git2.2.5、Bash基本操作命令2.3、Git配置 - git config 2.3.1、查看配置 - git config -l2.3.2、Git配置文件分类2.3.3、设置用户名与邮箱（用户标识，必要）2.3.4、添加或删除配置项2.3.5、更多配置项三、Git理论基础 3.1、工作区域3.2、工作流程3.3、图解教程四、Git操作 4.1、创建工作目录与常用指令4.2、获得GIT仓库 4.2.1、创建全新仓库4.2.2、克隆远程仓库4.3、GIT文件操作 4.3.1、文件4种状态4.3.2、查看文件状态4.3.3、添加文件与目录4.3.4、移除文件与目录（撤销add）4.3.5、查看文件修改后的差异4.3.6、签出4.3.6、忽略文件4.3.7、提交4.3.8、日志与历史4.3.9、查看文件列表4.3.10、撤销更新4.3.11、删除文件4.3.12、文件操作小结4.4、GIT分支 4.4.1、新建分支与切换分支4.4.2、查看分支4.4.3、分支合并4.4.4、解决冲突4.4.5、删除分支4.5、Git GUI 操作 4.5.1、GitHub for Desktop4.5.2、Source Tree4.5.3、TortoiseGit4.5.4、Git集成Gui工具4.6、IDE集成的Git客户端 4.6.1、Eclipse – Egit4.6.2、Visual Studio – Git Integration &amp; GitHub Extension4.6.3、IntelliJ IDEA4.7、帮助与代码统计五、远程仓库 5.1、托管平台 5.1.1、GitHub5.1.2、Gitlab5.1.3、Bitbucket5.1.4、开源中国代码托管5.1.5、(推荐)coding.net5.2、申请帐号与设置 5.2.1、申请帐号5.2.2、创建项目5.2.3、提交源代码到远程仓库5.2.4、Markdown文件（.md文件）5.3、远程仓库操作 5.3.1、常用操作指令5.3.2、git clone 克隆5.3.3、git remote5.3.4、git fetch5.3.5、git pull5.3.6、git push5.4、在命令行中同步本地仓库示例 一、版本控制概要 1.1、什么是版本控制 版本控制（Revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。
实现跨区域多人协同开发追踪和记载一个或者多个文件的历史记录组织和保护你的源代码和文档统计工作量并行开发、提高开发效率跟踪记录整个软件的开发过程减轻开发人员的负担，节省时间，同时降低人为错误 简单说就是用于管理多人协同开发项目的技术。
没有进行版本控制或者版本控制本身缺乏正确的流程管理，在软件开发过程中将会引入很多问题，如软件代码的一致性、软件内容的冗余、软件过程的事物性、软件开发过程中的并发性、软件源代码的安全性，以及软件的整合等问题。
1.2、常用术语 1)、仓库（Repository）
受版本控制的所有文件修订历史的共享数据库
2)、工作空间（Workspace) 本地硬盘或Unix 用户帐户上编辑的文件副本
3)、工作树/区（Working tree）
工作区中包含了仓库的工作文件。您可以修改的内容和提交更改作为新的提交到仓库。
4)、暂存区（Staging area）
暂存区是工作区用来提交更改（commit）前可以暂存工作区的变化。
5)、索引（Index）
索引是暂存区的另一种术语。
6)、签入（Checkin）
将新版本复制回仓库
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5eef33b3cd635fd3d61192d1c52f2916/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f858948a7bd0698bedcddc0f12c005bd/" rel="bookmark">
			Python基础教程——bug清除手册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在开始正题之前，让我们先来看看本次学习的重难点。本次的知识点可以分为三个部分：
(1）常见的语法错误。
(2）基础语法中的常见异常。
(3）操作文件过程中的常见异常，这部分也是重难点知识。
编写代码时经常会遇到错误，因此掌握本课的内容对你将来自己做项目非常有帮助。至少可以节省大量排查错误的时间。加油！
常见的语法错误 下面图片中显示的情况，相信你在平时写代码的过程中，肯定已经遇到过不少次了。
如果程序能够顺利运行，是不会出现这样的消息的。
这些在终端显示的"错误消息"表示我们在编写或运行程序时可能出现了问题。通常需要在Python中进行异常处理，以确保程序能够正确运行。
“异常处理”这个名词你应该是第一次接触，它包括我们在程序运行前的处理和在程序运行过程中的处理。
在Python中，异常处理是一门比较深奥的学问，涉及到很多特有的机制。不过我们暂时不需要掌握那么深入的知识，为了方便理解，你可以将解决问题或处理"错误消息"的过程称为"异常处理"。
不过，我们还不需要掌握这么难的知识，为了方便理解，你可以把解决问题或处理“错误消息”的过程称为“异常处理”。
我相信你凭借现有的编程经验，也能发现"错误消息"不仅限于图片中显示的那一种。实际上，按照Python官方文档的定义，这些"错误消息"至少可以分为两类：语法错误(syntax errors)和异常(exceptions)。
1.1 基本概念 **语法错误(syntax errors)**是初学者最容易犯的错误，简单来说就是代码不符合Python的基本语法规范，导致程序出错。
当你的代码完全符合Python的语法规范后，就可以尝试运行程序了。但是在程序运行过程中，仍然可能出现问题，我们称这类问题为异常。
作为一个有经验的人，为了让你少走弯路，我将根据你的技术水平列举一些常见的语法错误和异常。当然，我还会讲解它们产生的原因以及相应的解决办法。
此外，我还总结了一些在操作文件过程中可能遇到的常见异常，希望你引以为戒，尽量避免这些问题。
需要强调的是，本次讲解的语法错误和异常并不能代表全部，实际上，这只是冰山一角，还有许多复杂且棘手的异常等待你以后慢慢解决。
但是不要害怕，这是提高编程水平的必经之路。送你八个字：“遇事不慌，问题不大。”保持积极的心态是最重要的。
好了，按顺序，我们先来学习常见的语法错误。
正如前面所述，**语法错误(syntax errors)**是初学者最容易犯的错误，如果代码不符合 Python 的语法规范，比如漏了冒号，混用中英文符号等，就会出现这种错误。
如下图所示：
想要解决问题，最基本动作就是查看错误消息，终端会显示出现语法错误的那一行，并显示一个箭头^，指向这行里面检测到的第一个错误。
例如，在上图中，line 1和SyntaxError告诉你第一行有语法错误，出错位置很可能是在print() 附近。
需要说明的是，行数告诉你代码出现问题的位置，但不一定是最初出错的地方。有时候，真正的错误可能出现在提示信息所指示的位置之前，通常在前一行。
知道错误出现的位置后，就可以尝试解决错误了。下面我将分别讲解两种常见的语法错误：SyntaxError 和 IndentationError，以及它们产生的原因和相应的解决办法。
1.2 SyntaxError 第一种：SyntaxError: invalid syntax（无效语法）
在Python中，"SyntaxError: invalid syntax"是最常见的语法错误之一。它通常由以下几种情况引起：
一、遗漏了标点符号。
在第一种情况下，我们需要检查是否有遗漏标点符号。例如，在函数定义时，是否忘记了在括号后面加上冒号；在if条件判断和while循环中的条件后面是否有冒号；在for循环的可迭代对象后是否有冒号；以及在字典中的每个键值对之间是否有逗号等等。
此外，还要注意区分等于号（=）和等于比较运算符（==）的使用。
二、关键字拼写错误或遗漏。
第二种情况，很有可能是因为你手抖或者粗心，将 while 写成了 whlie，将 def 写成了 dfe 之类的错误，或者可能是你将 for…in… 中的关键字 in 忘写了。
三、变量名或函数名使用了关键字。
例：
# class 是 Python 的关键字，不可充当变量名 class = False # True 是 Python 关键字，不可作为函数名 def True(): print('好好学习，天天向上') 正如代码里注释写的，class 和 True 都是 Python 中的关键字，关键字是不可以用来作为变量名、函数名或者类名的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f858948a7bd0698bedcddc0f12c005bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9630f6c0ede01ced72373e6e1b7fae87/" rel="bookmark">
			Acwing总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		排序算法 快速排序(基础版-基准值取左端点) #include "bits/stdc++.h" using namespace std; void quickSort(vector&lt;int&gt; &amp;nums, int left, int right) { if (left &gt;= right) return; // 递归终止条件 int l = left, r = right; int pivot = nums[l]; // 选取基准值 while (l &lt; r) { while (l &lt; r &amp;&amp; nums[r] &gt;= pivot) r--; // 从右边找到第一个小于基准值的数 nums[l] = nums[r]; while (l &lt; r &amp;&amp; nums[l] &lt;= pivot) l++; // 从左边找到第一个大于等于基准值的数 nums[r] = nums[l]; } // 退出循环时 l == r nums[l] = pivot; // 将基准值放到中间 quickSort(nums, left, l - 1); // 递归处理左边 quickSort(nums, l + 1, right); // 递归处理右边 } int main() { int n; cin &gt;&gt; n; vector&lt;int&gt; nums(n); for (auto &amp;i: nums) cin &gt;&gt; i; quickSort(nums, 0, n - 1); for (auto i: nums) cout &lt;&lt; i &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9630f6c0ede01ced72373e6e1b7fae87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a034cb269aedb6b278a7b3af7def2854/" rel="bookmark">
			centos 8安装mysql5.7
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		卸载已经安装的MySQL数据库 ## 查询MySQL相关的依赖 rpm -qa |grep mysql ## 如果存在, 则通过rpm -e --nodeps 进行卸载 获取rpm在线安装仓库文件 wget https://dev.mysql.com/get/mysql80-community-release-el7-6.noarch.rpm 安装mysql的仓库文件 rpm -ivh mysql80-community-release-el7-6.noarch.rpm 修改mysql仓库的配置文件 cd /etc/yum.repos.d/ mysql-community.repo: 用于指定下载哪个版本的安装包 mysql-community-source.repo: 用于指定下载哪个版本的源码 `禁用8.0的版本, 启用5.7的版本` 把这两个repo文件，5.7链接下面的enable改为1，8.0链接下面的enable改为0 安装MySQL5.7 ## 导入签名的信息key rpm --import https://repo.mysql.com/RPM-GPG-KEY-mysql-2022 #停用mysql服务 yum module disable mysql ## 安装5.7 yum install -y mysql-community-server 启动数据库 systemctl start mysqld systemctl status mysqld systemctl enable mysqld 登录数据库 ## 查看初始密码 less /var/log/mysqld.log |grep pass ## 登录数据库 mysql -uroot -p'XRY046OefV&lt;7' 修改MySQL数据库密码策略 set global validate_password_length=4; set global validate_password_policy=0; 创建远程登录用户 ALTER USER 'root'@'localhost' IDENTIFIED BY '123456'; #创建一个远程登录用户 create user 'root'@'%' identified by '123456'; # 配置外部访问权限 grant all privileges on *.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a034cb269aedb6b278a7b3af7def2854/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3bc3ec9ba5c66bf1d964300723766c0/" rel="bookmark">
			突破Cloudflare反爬虫，穿云API实现无限制数据采集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文将详细介绍如何通过穿云API实现突破Cloudflare反爬虫机制，实现无限制的数据采集。首先，我们将概述穿云API的功能和优势，然后从四个方面详细阐述其突破Cloudflare反爬虫的能力：使用高质量代理IP、智能识别验证码、模拟真实用户行为以及应对反爬虫策略。最后，我们将对全文进行总结归纳，强调穿云API作为一种有效工具，能够帮助用户突破Cloudflare反爬虫限制，实现无限制的数据采集。
一、引言
随着互联网数据的快速增长，许多网站采取了反爬虫措施来保护其数据资源，其中最常见的就是Cloudflare反爬虫机制。这种机制通过验证用户的身份和限制爬取请求频率等方式，对爬虫行为进行限制。然而，对于需要进行大规模数据采集的用户来说，这种限制成为了一个挑战。穿云API作为一种解决方案，能够帮助用户突破Cloudflare反爬虫限制，实现无限制的数据采集。
二、穿云API概述
穿云API是一个功能强大的工具，为用户提供了突破反爬虫限制的能力。它集成了多种功能，包括高质量代理IP的获取、智能验证码识别、模拟真实用户行为和应对反爬虫策略等，为用户提供了全面的解决方案。
三、使用高质量代理IP
高质量代理IP是绕过Cloudflare反爬虫的关键。通过穿云API，用户可以获取稳定、高匿名度的代理IP，使其爬取请求在Cloudflare的屏蔽范围之外。这样可以有效隐藏真实的爬取来源，提高爬取成功率。
1.代理IP的选择
穿云API支持代理IP，用户可以根据自身需求选择合适的代理IP。在选择时，需要考虑代理IP的稳定性、速度和匿名度等因素，以确保爬取过程的顺利进行。
2.代理IP的合理使用
为了避免引起反爬虫机制的警觉，使用代理IP时需要注意合理设置请求间隔和访问频率。穿云API提供了相关的参数和选项，用户可以根据需要进行调整。合理的请求间隔和访问频率可以模拟真实用户的行为，减少被识别为爬虫的风险，提高数据采集的效果。
四、智能识别验证码
Cloudflare反爬虫机制中常用的一种限制方式是通过验证码来验证用户的身份。穿云API具备智能识别验证码的功能，可以有效应对这一挑战。
1.自动识别验证码
穿云API通过图像处理和机器学习等技术，能够自动识别常见的验证码类型。用户只需将验证码图片提交给API，即可获取验证码的识别结果。这大大减轻了用户手动处理验证码的负担，提高了数据采集的效率。
2.验证码处理策略
对于一些较为复杂或特殊的验证码，穿云API还提供了灵活的处理策略。用户可以根据具体情况选择使用人工识别、打码平台等方法，确保验证码的准确识别和处理。
五、模拟真实用户行为
为了更好地绕过Cloudflare反爬虫机制，穿云API支持模拟真实用户行为，使爬取请求更具可信度。
1.随机请求头和用户代理
穿云API可以生成随机的请求头信息和用户代理，模拟不同浏览器和操作系统的访问行为。这样，爬取请求就更像是真实用户的访问，降低了被反爬虫机制识别的风险。
2.页面渲染和动态加载支持
对于一些动态网页，穿云API提供了页面渲染和动态加载的支持。它能够模拟浏览器的行为，执行JavaScript代码并获取完整的页面内容，确保数据采集的完整性和准确性。
六、应对反爬虫策略
除了以上技术手段外，穿云API还具备应对反爬虫策略的能力，进一步提高数据采集的成功率。
1.动态代理IP切换
穿云API可以实时监测代理IP的状态，并自动切换到可用的IP，避免被屏蔽或封禁。这样可以保持持续的数据采集，并应对网站的反爬虫策略调整。
2.异常处理和重试机制
在数据采集过程中，穿云API具备异常处理和重试机制。当遇到连接超时、请求错误等异常情况时，API会自动进行重试，确保数据采集的连续性和稳定性。同时，API还提供了相关的错误日志和监控功能，帮助用户及时发现和解决问题。
结论：
通过本文对【突破Cloudflare反爬虫，穿云API实现无限制数据采集】进行详细阐述，我们可以得出以下结论：穿云API作为一种有效的工具，能够帮助用户突破Cloudflare反爬虫限制，实现无限制的数据采集。通过使用高质量代理IP、智能识别验证码、模拟真实用户行为以及应对反爬虫策略，用户可以提高数据采集的成功率并降低被屏蔽的风险。穿云API的功能和优势使其成为一种可靠的解决方案，为用户提供了全面的支持和便利。
使用穿云API，您可以轻松地绕过Cloudflare反爬虫的机器人验证，即使您需要发送10万个请求，也不必担心被识别为抓取者。
一个穿云API即可突破所有反Anti-bot机器人检查，轻松绕过Cloudflare验证、CAPTCHA验证，WAF，CC防护，并提供了HTTP API和Proxy，包括接口地址、请求参数、返回处理；以及设置Referer，浏览器UA和headless状态等各浏览器指纹设备特征。
本文来源于：突破Cloudflare反爬虫，穿云API实现无限制数据采集 – 穿云API帮助教程
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/597af8feec91fe1441264414f8b4377a/" rel="bookmark">
			毕业设计 2023-2024年最新软件工程专业毕设选题题目推荐汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0 简介1 如何选题2 最新软件工程毕设选题 0 简介 学长搜集分享最新的软件工程业专业毕设选题，难度适中，适合作为毕业设计，大家参考。
学长整理的题目标准：
相对容易工作量达标题目新颖 1 如何选题 最近非常多的学弟学妹问学长关于选题的问题，所以今天学长来教大家如何进行毕业设计选题！
毕业设计的选题尤为重要，选好题目是最终完成毕业设计的第一步。
因为题目的选择跟之后的设计实现密不可分，如果你所选择的题目是你无法实现的，而且定题以后就不能修改了，这无疑会给你带来很大的困扰。
先介绍一下自己, 本人HIT研究生在读, 接触许多大三大四的实习生，我都会帮他们分析选题的难度，根据他自己对知识掌握的情况来帮他们选题。
一般来说，一套网站系统，像一些基于ssm框架的管理系统比较容易一点，更为容易一些。但今年来，这种前后端系统(统称XXX管理系统)很难通过毕设答辩，因为基本做被烂了，更多的学校要求设计题目内必须包含算法。
选题分享，技术解答
https://gitee.com/yaa-dc/warehouse-1/blob/master/python/README.md
2 最新软件工程毕设选题 基于SSM的热点推荐个性化新闻系统的设计与实现
基于卷积神经网络的共享单车识别系统的设计与实现
基于深度学习的图片自动分类系统的设计与实现
基于VUE框架的实时新闻推送平台的设计与实现
基于卷积神经网络的垃圾短信识别系统的设计与实现
基于卷积神经网络的垃圾短信识别系统的设计与实现
基于遗传算法的股票预测系统设计与实现
基于SSM开发的微博舆情系统的设计与实现
基于SSM的人力资源管理系统的设计与实现
基于卷积神经网络的人体行为识别系统的开发与设计
基于协同过滤算法的图书管理系统的设计与实现
基于BP神经网络的停车场管理系统的设计与实现
基于YOLOV5的火灾快速识别系统的设计与实现
基于CNN算法的图像艺术风格迁移系统的设计与实现
基于React框架开发企业教育平台后台管理系统的设计与实现
基于机器学习的歌曲自动生成系统的设计与实现
基于线性回归的毕业生招聘信息及租房数据系统的设计与实现
基于卷积神经网络的在线作业检测与存档管理系统的设计与实现
基于神经网络模型的文本纠错系统的设计与实现
基于深度学习的驾驶行为识别管理系统的设计与实现
基于卷积神经网络模型的垃圾分类系统的设计与实现
基于CNN的多标签新闻分类系统的设计与实现
基于卷积神将网络的识别图片数字自动打码系统设计与实现
基于BP神经网络的畜牧业养殖场管理系统的设计与实现
基于BP神经网络的人脸朝向系统的设计与实现
基于卷积神经网络的人体关键点识别系统的研究与实现
基于深度学习的相似图片识别系统的设计与实现
基于卷积神经网络的邮件管理系统的设计与实现
基于卷积神经网络模型水果识别分类的设计与实现
基于机器学习的餐饮服务管理系统的设计与实现
基于卷积神经网络算法的车牌识别停车管理系统的设计与实现
基于Bp神经网络的停车场车牌识别系统
基于内容关联的饮食推荐系统在青岛工学院的应用
基于SSM框架的校园帮系统的设计与实现
基于K-means算法的校园美食推荐系统
基于Java的疫苗预约网站的设计与实现
基于协同过滤算法的医院病人健康饮食定制系统的设计与实现
基于深度学习的图片审核系统在微博的应用
基于协同过滤的个性化书籍推荐系统的设计与实现
基于SSM框架的学生实习管理系统的设计与实现
基于DBSCAN算法的可视化数据分析平台的设计与实现
基于Web的农场租赁及农产品销售管理系统
基于卷积神经网络RL人机对弈的应用设计
基于蚁群算法的北京市旅游景点线路优化系统的研究与实现
基于Web的电子产品销售系统的设计与实现
基于SSM+LayUI的租房信息共享系统的设计与实现
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/597af8feec91fe1441264414f8b4377a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/978e5e1b3d6e1f320204a5de2f524a21/" rel="bookmark">
			Acwing 算法学习记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		排序算法 快速排序(基础版-基准值取左端点) #include "bits/stdc++.h" using namespace std; void quickSort(vector&lt;int&gt; &amp;nums, int left, int right) { if (left &gt;= right) return; // 递归终止条件 int l = left, r = right; int pivot = nums[l]; // 选取基准值 while (l &lt; r) { while (l &lt; r &amp;&amp; nums[r] &gt;= pivot) r--; // 从右边找到第一个小于基准值的数 nums[l] = nums[r]; while (l &lt; r &amp;&amp; nums[l] &lt;= pivot) l++; // 从左边找到第一个大于等于基准值的数 nums[r] = nums[l]; } // 退出循环时 l == r nums[l] = pivot; // 将基准值放到中间 quickSort(nums, left, l - 1); // 递归处理左边 quickSort(nums, l + 1, right); // 递归处理右边 } int main() { int n; cin &gt;&gt; n; vector&lt;int&gt; nums(n); for (auto &amp;i: nums) cin &gt;&gt; i; quickSort(nums, 0, n - 1); for (auto i: nums) cout &lt;&lt; i &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/978e5e1b3d6e1f320204a5de2f524a21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0de048ac8f8d02ff82edecb0c089e124/" rel="bookmark">
			十分钟了解布隆过滤器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 什么是布隆过滤器 布隆过滤器（Bloom Filter）： 1970年由布隆提出的。它实际上是一个很长的二进制向量和一系列的随机映射函数（哈希函数）两部分组成的数据结构。
用途： 用于检索一个元素是否在一个集合中。
——你可以永远相信布隆
2 布隆过滤器的原理 布隆过滤器的数据结构是一个位向量，也就是一个由0、1所组成的bit数组
2.1 数据结构 2.2 添加元素 每个元素添加进布隆过滤器前，都会经过多个不同的哈希函数，计算出不同的哈希值，然后映射到位向量上，也就是对应的位"置1"
2.3 判断元素 对元素进行多个不同的哈希运算，得到多个位下标，判断所有映射位置是否都为1，若是，则元素可能存在，否则一定不存在
注意：由于不同的值通过哈希函数之后可能会映射到相同的位置，因此如果一个不存在的元素对应的位都被其他元素所设置1，则查询时就会误判
2.4 删除元素 布隆过滤器对元素的删除不太支持，因为元素删除不能简单的把对应的若干位设置为0，会对其他元素有影响。
目前有一些变形的特定布隆过滤器支持元素的删除(尽可能不考虑删除)。
3 布隆过滤器的优缺点 优点：
时间复杂度低，增加及查询元素的时间复杂度都是O(k)，k为Hash函数的个数；
保密性强，布隆过滤器不存储元素本身；
占用存储空间小，布隆过滤器相对于其他数据结构（如Set、Map）非常节省空间；
缺点：
存在误判，只能证明一个元素一定不存在或者可能存在，返回结果是概率性的，但是可以通过调整参数来降低误判比例；
删除困难，一个元素映射到bit数组上的k个位置为1，删除的时候不能简单的直接置为0，可能会影响到其他元素的判断；
无法通过key找到元素本身；
3 布隆过滤器适用场景 解决Redis缓存穿透问题（访问非法key）黑名单过滤爬虫任务处理过滤，爬过的不再爬解决新闻推荐过的不再推荐(类似抖音刷过的往下滑动不再刷到)HBase\RocksDB\LevelDB等数据库内置布隆过滤器 4 代码示例 4.1 Java示例 // 初始化布隆过滤器，设计预计元素数量为100w，误差率为1‰ BloomFilter&lt;Long&gt; bloomFilter = BloomFilter.create(Funnels.longFunnel(), 1000000, 0.001); int n = 1000000; for (long i = 0; i &lt; n; i++) { bloomFilter.put(i); } int containCount = (n * 5);//匹配总次数 int rightCount = 0;//正确次数 int errCount = 0;//误判次数 for (long i = 0; i &lt; containCount; i++) { if (bloomFilter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0de048ac8f8d02ff82edecb0c089e124/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc3acdd74121a53714e098c12e5df756/" rel="bookmark">
			Web安全渗透详细教程&#43;学习线路&#43;详细笔记「全网最全&#43;建议收藏」
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		互联网刚开始是安全的，但是伴随着黑客的诞生，互联网变得越来越不安全。与此同时，随着Web技术发展越来越成熟，而非Web服务越来越少的暴露在互联网上，现在互联网安全主要指的是Web安全。
为了自身不“裸奔”在大数据里，渐渐开始学习Web安全，在学习Web安全的过程中，发现很大一部分知识点都相对零散，如果没有相对清晰 的脉络作为参考，会给学习带来一些不必要的负担。
于是之后就把一些知识、想法整理记录下来，最后形成了这份 《Web安全学习笔记》。这份文档共11个章节327页，对网络协议、漏洞攻防、内网渗透、防御技术等内容做了详细的讲解，希望这份笔记能够为正在入门的你提供一定的帮助。
【完整版文档领取方式见文末】
【完整版文档领取方式见文末】
文档目录 第一章：序章第二章：计算机网络与协议第三章：信息收集第四章：常见漏洞攻防第五章：语言与框架第六章：内网渗透第七章：防御技术第八章：认证机制第九章：工具与资源第十章：手册速查第十一章：其他
部分内容展示 第二章：计算机网络与协议
第三章：信息收集
第四章：常见漏洞攻防
第五章：语言与框架
第六章：内网渗透
所有资料共282G，朋友们如果有需要全套《网络安全入门+进阶学习资源包》，可以扫描下方二维码或链接免费领取~
读者福利 | CSDN大礼包：《网络安全入门&amp;进阶学习资源包》免费分享 （安全链接，放心点击）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c6bf3eb1a4728e7bd6ad78ad33cb41b/" rel="bookmark">
			基于DINet的虚拟数字人
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个可以是一个简单的用自己脸型进行训练的虚拟数字人项目，机器需求配置有点高需要24G显存，如果没有的话看看就行了，跑不起来，当然效果和之前介绍的wav2lip相似，生成速度稍微会快一些，根据自己实际情况进行取舍。
文章目录 准备工作环境配置环境搭建模型训练数据准备数据预处理 模型训练嘴部区域加载预训练模型加载预训练模型在剪辑训练阶段 模型预测【分享】DINet 准备工作 代码地址：
https://github.com/MRzzm/DINet 在你的项目目录下克隆该项目。
git clone https://github.com/MRzzm/DINet.git 该项目还需要openface作为辅助工具，训练模型和预测需要使用。
项目地址：
https://github.com/TadasBaltrusaitis/OpenFace 这里在win10系统需要一个 OpenFaceOffline.exe 工具。
环境配置 首先要自己配置好 GPU 的 Pytorch 环境。如果不会的话看这里。
Win10+Python3.9+GPU版pytorch环境搭建最简流程
配置环境之后需要基于 Anaconda 环境，环境不会安装看这里。
Python初学者在不同系统上安装Python的保姆级指引
环境搭建 创建虚拟环境并激活，python版本和三方依赖比较紧密，不要随机更换。
conda create -n py36 python=3.6 conda activate py36 安装三方依赖，需要在虚拟环境中安装。
pip install opencv_python == 4.6.0.66 pip install numpy == 1.16.6 pip install python_speech_features == 0.6 pip install resampy == 0.2.2 pip install scipy == 1.5.4 pip install tensorflow == 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c6bf3eb1a4728e7bd6ad78ad33cb41b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71bd78f90a973cb9545ae713945d5adb/" rel="bookmark">
			Vue中如何进行数据可视化大屏展示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue中如何进行数据可视化大屏展示 在现代数据驱动的应用程序中，数据可视化大屏已经成为了非常重要的一环。通过对海量数据进行可视化展示，可以帮助用户更好地理解和分析数据，从而做出更加明智的决策。在Vue中进行数据可视化大屏展示也变得越来越流行，本文将介绍如何在Vue中快速实现数据可视化大屏展示。
前置技能要求 在阅读本文之前，你需要掌握以下技能：
Vue.js：熟悉Vue.js基本语法和组件开发。Echarts：了解Echarts的基本用法，包括如何创建图表和配置图表选项。 如果你还不熟悉这些技能，可以先学习相关的教程和文档。
选择可视化库 在Vue中进行数据可视化大屏展示，首先需要选择一个可视化库。在众多的可视化库中，Echarts是一款非常流行的选择。Echarts是一个基于JavaScript的开源可视化库，提供了丰富的图表类型和交互能力，可以满足大部分的数据可视化需求。
除了Echarts，还有其他可视化库，比如D3.js、Highcharts等。这些库各有特点，可以根据自己的需求进行选择。
创建Vue项目 在开始之前，我们需要先创建一个Vue项目。可以使用Vue CLI来创建一个基础的Vue项目，具体步骤如下：
安装Vue CLI： npm install -g @vue/cli 创建Vue项目： vue create my-project 安装Echarts： npm install echarts --save 创建可视化组件 在Vue中，我们可以将可视化组件封装成一个独立的组件，方便在不同的页面中进行复用。下面是一个简单的可视化组件示例：
&lt;template&gt; &lt;div ref="chart" style="width: 100%; height: 500px;"&gt;&lt;/div&gt; &lt;/template&gt; &lt;script&gt; import * as echarts from 'echarts'; export default { name: 'MyChart', props: ['option'], mounted() { // 初始化图表 this.chart = echarts.init(this.$refs.chart); // 设置图表选项 this.chart.setOption(this.option); }, beforeDestroy() { // 销毁图表 this.chart.dispose(); } }; &lt;/script&gt; &lt;style scoped&gt; /* 可选的组件样式 */ &lt;/style&gt; 在这个组件中，我们通过props来接收一个option参数，这个参数是一个Echarts的图表配置对象。在mounted钩子函数中，我们使用this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71bd78f90a973cb9545ae713945d5adb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdc7a436e80a57adeee73981d7a9b951/" rel="bookmark">
			使用LambdaQueryWrapper 报错MybatisPlusException: can not find lambda cache for this property [****]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
背景
问题
分析
原因
解决方案
深层次原因
背景 进行单元测试编码时，使用了MybatisPlus,在对service层进行单元测试时,为保证数据与应用隔离,采用Mock的方式.
问题 Mockito对Mapper进行mock后,相关的TableInfo信息无法初始化,导致Wrapper组装条件时
报:com.baomidou.mybatisplus.core.exceptions.MybatisPlusException: can not find lambda cache for this property [****] of entity [Entity]
我们在使用mybatisplus 时使用Lambda 表达式做查询条件会遇到mybatis拿不到缓存问题：
错误1：com.baomidou.mybatisplus.core.exceptions.MybatisPlusException: can not find lambda cache for this entity
错误2：can not find lambda cache for this property [XXX] of entity [com.XXX.XXX]
分析 排错时发现LambdaUtils.getColumnMap(aClass)中无数据;
原因 首先是MybatisPlus的bug,经过分析后排除,再次考虑TableInfo的初始化过程被中止,或者被Mock替换了,更有可能是压根就没有触发。
项目中使用JUnit &amp; Mocktio进行单元测试，如果代码中使用LambdaQueryWrapper进行条件构造，在DO类中有类似@TableId、@TableLogic等注解，在执行单元测试时会报错 MybatisPlusException: can not find lambda cache for this property [] of entity []
问题:Mockito对Mapper进行mock后,相关的TableInfo信息无法初始化,导致Wrapper组装条件时
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdc7a436e80a57adeee73981d7a9b951/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58e9331bda4279ffecb0a13efde1b841/" rel="bookmark">
			DOM与JS动态生成抓取，2023必备指南！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2023年06月16日，深入了解JavaScript的开发者们都知道，DOM（文档对象模型）是JavaScript操作网页的重要手段之一。而在实际开发过程中，我们常常需要使用JS动态生成页面元素，并抓取其中的数据。本文将从多个方面介绍DOM和JS动态生成抓取的相关知识点，帮助读者更好地掌握这一技术。
一、DOM简介
DOM是文档对象模型（Document Object Model）的缩写，它是W3C组织推荐的处理可扩展标记语言（XML或HTML）的标准编程接口。通过DOM，开发者可以使用JavaScript和其他脚本语言动态地访问和更新文档内容、结构和样式。
二、JS动态生成页面元素
在实际开发中，我们经常需要使用JavaScript动态生成页面元素，比如添加表格、列表、图片等等。以下代码演示了如何使用JavaScript向页面中添加一个表格：
&lt;script type="text/javascript"&gt; var table=document.createElement("table"); var tbody=document.createElement("tbody"); for(var i=0;i&lt;10;i++){ var tr=document.createElement("tr"); for(var j=0;j&lt;5;j++){ var td=document.createElement("td"); td.innerHTML="Row "+i+", Column "+j; tr.appendChild(td); } tbody.appendChild(tr); } table.appendChild(tbody);9d46f20233f9ce20d3c38ab80b5358bf.body.appendChild(table); &lt;/script&gt; 此代码中，我们首先使用createElement()方法创建一个table元素和一个tbody元素，并使用for循环生成10行5列的表格。然后，通过appendChild()方法将td、tr和tbody添加到table中，最后将table添加到页面中。
三、使用DOM操作页面元素
除了动态生成页面元素，我们还可以使用DOM操作已有的页面元素。以下代码演示了如何使用DOM获取页面中的某个元素并修改其内容：
&lt;script type="text/javascript"&gt; var element=document.getElementById("myDiv"); element.innerHTML="Hello World!"; &lt;/script&gt; 此代码中，我们首先使用getElementById()方法获取id为“myDiv”的元素，然后将其innerHTML属性修改为“Hello World!”。
四、JS动态抓取数据
除了动态生成页面元素，JS还可以用来抓取页面中的数据。以下代码演示了如何使用JS获取页面中所有a标签的href属性值：
&lt;script type="text/javascript"&gt; var links=document.getElementsByTagName("a"); for(var i=0;i&lt;links.length;i++){ console.log(links[i].href); } &lt;/script&gt; 此代码中，我们首先使用getElementsByTagName()方法获取所有a标签，然后通过循环遍历每一个a标签，并输出其href属性值。
五、跨域问题
在进行JS动态抓取数据时，经常会遇到跨域问题。跨域是指浏览器不能执行其他网站的脚本，它是一种安全机制。为了解决跨域问题，我们可以使用JSONP、CORS等技术。
六、AJAX技术
AJAX（Asynchronous JavaScript and XML）是一种创建快速动态网页的技术。通过AJAX，我们可以在页面无需重载的情况下向服务器发送请求并接收响应。以下代码演示了如何使用AJAX向服务器发送POST请求：
&lt;script type="text/javascript"&gt; var xhr=new XMLHttpRequest(); xhr.open("POST",";,true); xhr.setRequestHeader("Content-type","application/json;charset=UTF-8"); xhr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58e9331bda4279ffecb0a13efde1b841/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f86b78ce6efa99428bf997c33c548fd1/" rel="bookmark">
			Bean 的生命周期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		观前提示:本篇博客演示使用的 IDEA 版本为2021.3.3版本,使用的是Java8(又名jdk1.8)
电脑使用的操作系统版本为 Windows 10
目录
Spring 的执行流程
1. 启动容器
2. 根据配置完成 Bean 的初始化
3. 注册 Bean 对象到容器中
4. 装配 Bean 的属性
Bean 的生命周期
Bean 的生命周期代码演示
Spring 的执行流程 在看 Bean 的生命周期之前需要先简单了解一下 Spring 的执行流程
1. 启动容器 ApplicationContext 启动容器
2. 根据配置完成 Bean 的初始化 加载配置文件:类加载路径下的 Beans.xml 3. 注册 Bean 对象到容器中 扫描 org.example 包. 扫描有没有五大类注解, 只有在包扫描的路径上的类, 且使用 Spring 的注解才可以被注册到容器中. 4. 装配 Bean 的属性 如果 Bean 对象需要使用其他 Bean 对象作为属性, 可以使用注解 @Autowired 和 @Resource
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f86b78ce6efa99428bf997c33c548fd1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5b18c85f3154211a8e1aaf3d2f311ab/" rel="bookmark">
			r2pm -ci r2ghidra 时报错：checking pkg-config flags for r_core... no
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考网址：
sys/python.sh fails with `checking pkg-config flags for r_core... no` · Issue #1943 · radareorg/radare2 · GitHub
进入目录/root/.local/share/radare2/r2pm/git/r2ghidra查看configure文件，查找报错位置
执行指令 ：
# pkg-config --cflags r_core Package libxxhash was not found in the pkg-config search path. Perhaps you should add the directory containing `libxxhash.pc' to the PKG_CONFIG_PATH environment variable Package 'libxxhash', required by 'r_hash', not found Package 'libxxhash', required by 'r_hash', not found Package 'libxxhash', required by 'r_hash', not found Package 'libxxhash', required by 'r_hash', not found Package 'libxxhash', required by 'r_hash', not found Package 'libxxhash', required by 'r_hash', not found Package 'libxxhash', required by 'r_hash', not found 安装 libxxhash
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5b18c85f3154211a8e1aaf3d2f311ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ab6b023e19cda44203ded8953b7d4e1/" rel="bookmark">
			在我们编写代码程序的时候，查询数据库想要通过id来查询数据库信息的具体步骤。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		连接数据库：使用 JDBC 连接 MySQL 数据库，可以使用以下代码进行连接： String url = "jdbc:mysql://localhost:3306/数据库名"; String user = "用户名"; String password = "密码"; Connection conn = DriverManager.getConnection(url, user, password); 构造 SQL 语句：使用 SQL 语句查询指定 id 的信息，可以使用以下代码构造 SQL 语句： String sql = "SELECT * FROM 表名 WHERE id = ?"; 其中，? 是占位符，表示需要传入参数。
执行 SQL 语句：使用 PreparedStatement 对象执行 SQL 语句，可以使用以下代码执行 SQL 语句： PreparedStatement pstmt = conn.prepareStatement(sql); pstmt.setInt(1, id); ResultSet rs = pstmt.executeQuery(); 其中，setInt() 方法将参数设置到 SQL 语句中的占位符位置，executeQuery() 方法执行 SQL 语句并返回结果集。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ab6b023e19cda44203ded8953b7d4e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1983472cfe424f8ba3f9f8e1335148e8/" rel="bookmark">
			pycharm双击图标无反应
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可能是之前破*解Idea的时候连带的反应，导致pycharm也出来问题。以下是解决方案：
找到安装目录下的bin目录，
在这上面输入cmd并运行。之后输入pycharm检测pycharm是否能正常运行，理论上会报error。
查看他的文件夹目录
如果没有这个目录的话，创建里面的文件和文件夹。那个jar文件就是破解的时候用的那个jar，把他改成cmd里面需要的那个名称，就是红框的名称。
之后就可以运行了。
这个问题是由于它找不到图示的这个文件了。（它是按cmd命令里的那个路径找的，当然找不到。。。两个不是一个路径。）
如果你想修改到这个路劲就可以这样：打开pycharm，按图中所示来点击
点进去之后换成第一个按钮，点击确认，之后会出现这个文件
把最下面那个路径改成我的想要的路径即可，就是下图所示的地方
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53cc77cbe912c9370506dbf46a030108/" rel="bookmark">
			JavaScript HTML DOM - 改变CSS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要使用JavaScript改变HTML元素的CSS样式，可以通过访问元素的style属性来实现。下面是一些常见的方法：
1. 直接设置样式属性：
```javascript
var element = document.getElementById("myElement");
element.style.color = "red";
element.style.fontSize = "20px";
```
2. 添加或移除CSS类：
```javascript
var element = document.getElementById("myElement");
element.classList.add("newClass");
element.classList.remove("oldClass");
```
3. 修改元素的类列表：
```javascript
var element = document.getElementById("myElement");
element.className = "newClass";
```
4. 使用style.cssText设置一组CSS属性：
```javascript
var element = document.getElementById("myElement");
element.style.cssText = "color: red; font-size: 20px;";
```
这些方法中的`"myElement"`是目标元素的ID，你需要根据实际情况将其替换为正确的ID。
注意：使用JavaScript直接修改样式可能会导致样式与CSS文件中定义的样式冲突。最好的做法是使用JavaScript添加或移除类，然后在CSS文件中定义相应的样式。
另外，请确保在修改元素样式之前，DOM已经加载完毕，可以在`window.onload`事件中执行上述代码，或将其放在页面底部进行执行，以确保元素已经存在于DOM中。
当你点击按钮时，可以使用JavaScript来改变一个元素的背景颜色。以下是一个简单的例子：
HTML代码：
```html
&lt;button οnclick="changeColor()"&gt;改变颜色&lt;/button&gt;
&lt;div id="myElement"&gt;这是一个示例元素&lt;/div&gt;
```
JavaScript代码：
```javascript
function changeColor() {
var element = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53cc77cbe912c9370506dbf46a030108/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39201d1e17b1d5a7d3ff7a582725d204/" rel="bookmark">
			19道经典的AJAX面试题(必知必会)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、什么是AJAX，为什么要使用Ajax（请谈一下你对Ajax的认识）
什么是ajax：
AJAX是“Asynchronous JavaScript and XML”的缩写。他是指一种创建交互式网页应用的网页开发技术。
Ajax包含下列技术：
基于web标准（standards-basedpresentation）XHTML+CSS的表示；
使用 DOM（Document ObjectModel）进行动态显示及交互；
使用 XML 和 XSLT 进行数据交换及相关操作；
使用 XMLHttpRequest 进行异步数据查询、检索；
使用 JavaScript 将所有的东西绑定在一起。
2、为什么要用ajax：
Ajax应用程序的优势在于：
1. 通过异步模式，提升了用户体验
2. 优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用
3. Ajax引擎在客户端运行，承担了一部分本来由服务器承担的工作，从而减少了大用户量下的服务器负载。
2、AJAX最大的特点是什么。
Ajax可以实现动态不刷新（局部刷新）
就是能在不更新整个页面的前提下维护数据。这使得Web应用程序更为迅捷地回应用户动作，并避免了在网络上发送那些没有改变过的信息。
3、请介绍一下XMLhttprequest对象。
Ajax的核心是JavaScript对象XmlHttpRequest。该对象在Internet Explorer 5中首次引入，它是一种支持异步请求的技术。简而言之，XmlHttpRequest使您可以使用JavaScript向服务器提出请求并处理响应，而不阻塞用户。通过XMLHttpRequest对象，Web开发人员可以在页面加载以后进行页面的局部更新。
4、AJAX技术体系的组成部分有哪些。
HTML，css，dom，xml，xmlHttpRequest，javascript
5、AJAX应用和传统Web应用有什么不同。
在传统的Javascript编程中，如果想得到服务器端数据库或文件上的信息，或者发送客户端信息到服务器，需要建立一个HTML form然后GET或者POST数据到服务器端。用户需要点击”Submit”按钮来发送或者接受数据信息，然后等待服务器响应请求，页面重新加载。
因为服务器每次都会返回一个新的页面， 所以传统的web应用有可能很慢而且用户交互不友好。
使用AJAX技术， 就可以使Javascript通过XMLHttpRequest对象直接与服务器进行交互。
通过HTTP Request， 一个web页面可以发送一个请求到web服务器并且接受web服务器返回的信息(不用重新加载页面)，展示给用户的还是通一个页面，用户感觉页面刷新，也看不到到Javascript后台进行的发送请求和接受响应。
6、AJAX请求总共有多少种CALLBACK。
Ajax请求总共有八种Callback
onSuccess
onFailure
onUninitialized
onLoading
onLoaded
onInteractive
onComplete
onException
7.Ajax和javascript的区别。
javascript是一种在浏览器端执行的脚本语言，Ajax是一种创建交互式网页应用的开发技术 ，它是利用了一系列相关的技术其中就包括javascript。
Javascript是由网景公司开发的一种脚本语言，它和sun公司的java语言是没有任何关系的，它们相似的名称只是一种行销策略。
在一般的web开发中，javascript是在浏览器端执行的，我们可以用javascript控制浏览器的行为和内容。
在 Ajax应用中信息是如何在浏览器和服务器之间传递的
通过XML数据或者字符串
8、在浏览器端如何得到服务器端响应的XML数据。
XMLHttpRequest对象的responseXMl属性
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39201d1e17b1d5a7d3ff7a582725d204/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ce5559d5a1b6b8b61bf3d0a5998a023/" rel="bookmark">
			【Java】类和对象详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、面向对象1.1 什么是面向对象1.2 面向对象与面向过程 二、类的定义和实例化2.1 类的定义2.2 类的创建2.3 类的实例化2.4 类和对象的联系 三、认识 this 引用3.1 为什么引入 this 引用3.2 this 引用的功能3.3 this 引用的特性 四、对象的构造初始化4.1 如何初始化对象4.2 构造方法4.3 默认初始化4.4 就地初始化 五、封装5.1 什么是封装5.2 访问限定符 六、包的认识6.1 什么是包6.2 导入包中的类 七、类的 static 成员7.1 static 修饰成员变量7.2 static 修饰成员方法7.3 static 成员变量初始化 八、代码块九、内部类 一、面向对象 1.1 什么是面向对象 面向对象（Object-oriented）是一种程序设计的方法和编程范式，它以对象作为程序的基本单位，通过封装、继承、多态等概念来组织和实现程序逻辑。面向对象的编程思想强调将问题分解为对象的集合，每个对象具有自己的状态（属性）和行为（方法），并通过相互之间的消息传递来实现协助和交互。
1.2 面向对象与面向过程 面向对象和面向过程是两种不同的编程范式，它们在解决问题和设计程序时有着不同的思维方式和方法。
面向过程编程（Procedural Programming）是一种以过程为中心的编程方式，将程序视为一系列的步骤或过程的集合。它关注如何完成任务，通过编写一系列的函数来实现功能，函数接受输入，执行一系列操作，并返回输出。面向过程编程强调算法和步骤的顺序，逐步解决问题。
面向对象编程（Object-Oriented Programming）是一种以对象为中心的编程方式，将程序视为一系列的对象的集合，这些对象通过相互之间的消息传递来协作和交互。面向对象编程关注问题的建模，将问题分解为对象，每个对象具有自己的状态和行为，并通过封装、继承和多态等机制来实现代码的模块化、重用性和灵活性。
例如洗衣服的例子，我们可以将传统洗衣服的过程与现代洗衣服的过程进行对比：
传统洗衣服（面向过程）：
收集脏衣服。排序脏衣服。填充水槽。加入洗衣粉。将脏衣服放入水槽中。搓揉脏衣服。冲洗脏衣服。拧干脏衣服。晾干脏衣服。 在面向过程的洗衣服过程中，步骤和操作是线性的，每一步都按照特定的顺序执行。
现代洗衣服（面向对象）：
准备洗衣机对象。将脏衣服对象放入洗衣机。设定洗衣机的程序（例如洗涤时间、水温等）。开始洗衣机的洗涤过程。洗衣机自动完成洗涤、漂洗、脱水等过程。完成洗涤后，取出干净衣服对象。 在面向对象的洗衣服过程中，洗衣机对象具有自己的状态（如洗涤时间、水温）和行为（如洗涤、脱水等），通过对象之间的消息传递好方法的调用来实现洗衣服的功能。整个过程更加的模块化，洗衣机对象自己管理洗涤的细节，而我们只需要与对象进行交互即可。通过这个例子我们就能很好地理解面向对象和面向过程
二、类的定义和实例化 2.1 类的定义 类（Class）是用来对一个实体（对象）进行描述的，主要包括实体（对象）的属性和行为的描述。在Java语言中，类是面向对象编程的基本组织单位，它是对象的模版或者蓝图，描述了对象的属性和行为。
在Java中，类具有以下特点和概念：
属性（Fields）：类可以定义成员变量，也称为属性或字段。属性表示了对象的状态或特征，用于存储对象的数据。每个对象通过类的属性来描述自己的特定状态。
方法（Methods）：类可以定义成员方法，也称为方法或函数。方法定义了对象的行为或操作，用于执行特定的功能。方法可以访问和操作类的属性，以及与其他对象进行交互。
对象实例化（Instantiation）：类本身只是一个模板，需要通过实例化（Instantiation）来创建对象。通过关键字 “new” 加上类名，可以在内存中创建一个对象的实例。
构造方法（Constructor）：构造方法是一种特殊的方法，在对象实例化时被调用，用于初始化对象的状态。构造方法与类同名，没有返回类型，并可以接受参数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ce5559d5a1b6b8b61bf3d0a5998a023/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8c46fda87d3fb2658ad220aed64583c/" rel="bookmark">
			vue3 &#43; vite 在线预览docx, pdf, pptx（内外网）并实现移动端适配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、内网 1.docx 使用docx-preview
安装插件
npm i docx-preview -S 引入依赖
// docx import { renderAsync } from "docx-preview"; let docx = import.meta.glob("docx-preview"); // vite不支持require &lt;div ref="docxDiv" class="docxDiv" v-if="['docx'].includes(detailItem.fileType)" v-loading="loading" &gt;&lt;/div&gt; //js部分 detailItem.value为当前文件的数据对象 const previewfile = () =&gt; { loading.value = true; fetch(detailItem.value.filePath) .then((response) =&gt; { let docData = response.blob(); let docxDiv= document.getElementsByClassName("docxDiv"); renderAsync(docData, docxDiv[0], null, { inWrapper: true, // 启用围绕文档内容渲染包装器 ignoreWidth: false, // 禁止页面渲染宽度 ignoreHeight: false, // 禁止页面渲染高度 ignoreFonts: false, // 禁止字体渲染 breakPages: true, // 在分页符上启用分页 ignoreLastRenderedPageBreak: true, //禁用lastRenderedPageBreak元素的分页 experimental: false, //启用实验性功能（制表符停止计算） trimXmlDeclaration: true, //如果为真，xml声明将在解析之前从xml文档中删除 debug: false, }).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8c46fda87d3fb2658ad220aed64583c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b143380b1f99afe6a91d2c72e63334b/" rel="bookmark">
			渗透测试之信息收集篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言：一、域名信息收集：1、Whois查询：2、备案信息查询： 二、敏感信息收集：1、Google Hacking语法：2、FOFA网络安全空间搜索：3、Github信息泄露： 三、子域名收集：1、子域名检测工具：2、利用搜索引擎发现子域：3、通过在线工具搜集: 四、端口探测：1、Nmap：2、Masscan扫描工具：3、在线网站：常见的端口及其说明： 五、CMS指纹识别：1、在线网站：2、指纹识别工具：3、CMS漏洞查询： 六、查找真实IP：1、什么是CDN：2、如何判断目标服务器使用了CDN：3、如何寻找真实IP： 七、敏感目录/文件收集：1、dirsearch：2、御剑后台扫描： 八、操作系统识别：九、社会工程学：最后： 前言： 信息收集是进行渗透测试的第一步，也是非常重要的一步。在这个阶段，我们要尽可能地收集目标组织的信息。关于信息收集的重要性我在这学期的护网行动中深有体会，一开始找不到目标资产，一度以为没有资产信息，后来转变了思路才发现原来资产有这么多。因此通过篇文章来系统的总结下信息收集的大致内容和常用方法，话不多说，开干。 (ง •_•)ง
一、域名信息收集： 首先，在得到一个目标的域名后，我们要做的第一件事就是去获取域名的注册信息，即该域名的DNS服务器信息和注册人的个人信息等。
域名信息收集的常用方法有以下几种：
1、Whois查询： Whois是一个标准的互联网协议，可用于查询域名是否被注册，以及注册域名的详细信息(如域名所有人、域名注册商等)。通过Whois查询得到注册人的姓名和邮箱信息对测试个人站点非常有用，因为我们可以通过搜索引擎和社交网络挖掘出域名所有人的很多信息。对中小站点而言，域名所有人很可能就是管理员。
使用方法：
1、通过在线网站：
站长之家：https://whois.chinaz.com/
阿里云域名信息查询：https://whois.aliyun.com
2、通过kali自带的whois查询工具：
也可以在windows下安装使用 下载链接，安装方法可以参考这篇文章：链接，安装完成后使用方法和kali的一样。
2、备案信息查询： 网站备案是根据国家法律法规规定，需要网站的所有者向国家有关部门申请的备案，这是国家信息产业部对网站的一种管理，为了防止在网上从事非法的网站经营活动的发生。主要针对国内网站，如果网站搭建在其他国家，则不需要进行备案。
常用的查询网站有：
ICP备案查询：http://icp.chinaz.com/
天眼查：https://beian.tianyancha.com/
二、敏感信息收集： 面对某些安全做得很好的目标，直接通过技术层面很难完成渗透测试。在这种情况下，可以利用搜索引擎对目标暴露在互联网上的关联信息进行搜集。例如：数据库文件、SQL注入、服务配置信息，甚至是通过Git找到站点泄露源代码，以及Redis等未授权访问、Robots.txt等敏感信息，从而达到渗透目的。
收集敏感信息的常用方法：
1、Google Hacking语法： Google Hack是指使用Google、百度等搜索引擎对某些特定网站主机漏洞（通常是服务器上的脚本漏洞）进行搜索，以达到快速找到漏洞主机或特定主机的漏洞的目的。
对于普通的用户而言，Google只是一款强大的搜索引擎，而对于渗透人员而言，它可能是一款绝佳的黑客工具。正因为Google的检索能力强大，我们可以构造特殊的关键字语法来搜索互联网上的的相关敏感信息。
常用语法：
Site：找到与指定网站有联系的URL。例如输入“Site：family.chinaok.com”。所有和这个网站有联系的URL都会被显示。 Intitle：搜索网页标题中包含有特定字符的网页。例如输入“intitle: cbi”，这样网页标题中带有cbi的网页都会被搜索出来。 Inurl：搜索包含有特定字符的URL。例如输入“inurl:cbi”，则可以找到带有cbi字符的URL。 Intext：搜索网页正文内容中的指定字符，例如输入“intext:cbi”。这个语法类似我们平时在某些网站中使用的“文章内容搜索”功能。 Filetype：搜索指定类型的文件。例如输入“filetype:cbi”，将返回所有以cbi结尾的文件URL。 这些就是Google的常用语法，也是Google Hack的必用语法。虽然这只是Google语法中很小的部分，但是合理使用这些语法将产生意想不到的效果。
例：当我们想获取一些政府网站的后台页面时，可通过构关键字 site:gov.cn intext:后台管理来实现搜集，意思是搜索网页正文中含有“后台管理”并且域名后缀是 gov.cn的网站。
可以看到利用Google Hacking语法搜索，可以很高效地得到我们想要的信息，还可以用它来收集数据库文件、SQL注入、配置信息、源代码泄露、未授权访问和robots.txt等敏感信息。（更详细的Google Hacking语法介绍可以看这篇文章：传送门）
接下来介绍另一款资产信息搜集神器：fofa
2、FOFA网络安全空间搜索： 链接：https://fofa.so/
FOFA网络安全空间搜索 是专为渗透人员设计的一款搜索引擎，其相对于Google 的知名度相对低了一些，但是对于渗透人员这是款信息收集的神器。用途大致和Google一样，就不多介绍了。
来简单说下其查询语法：
官方上给的很清楚，这里简单演示下如何使用：
需要注意，在fofa中，多条件查询是用&amp;&amp;和||来连接的，什么意思就不解释了。
例：查找一些后台管理且地点在杭州的资产信息：构造语法：title ="后台管理"&amp;&amp;city="Hangzhou
还可以查找指定开放的端口网站，例：查找开放了3389 端口的后台管理系统：port="3389"&amp;&amp;title="后台管理"
篇幅有限，更多骚操作可以看这篇文章：https://www.anquanke.com/post/id/84865
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b143380b1f99afe6a91d2c72e63334b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4df15f0b618819f4bcca829634a3a768/" rel="bookmark">
			在OpenWrt上配置原生IPv6 NAT，，实现校园网路由器使用ipv6
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的环境
网络：教育网原生双栈，IPv4地址固定，IPv6地址自动获取
固件版本：OpenWrt Chaos Calmer 15.05-rc2 r45918
内核版本：3.18.14
准备工作
第一步 配置好路由使其能够连接网络，WAN口能够获取全球单播IPv6地址。 步骤如下，将网线插入校园网墙上的网口，另一端连接上电脑。之后按照以下示例操作。（以下步骤同样适用于用来实现电脑连接宿舍有线网的设置）
之后选择
左键单击选择“Internet 协议版本 6（TCP/IPv6）”，然
后单击“属性（R）”在弹出的界面中选择 自动获取ipv6地址 与 dns
第二步 设置路由器步骤 在上一步我们通过设置ipv4地址与dns成功获取到了ipv6地址，可以通过ipv6代理测速测试，现在需要对路由器进行操作，在连接路由器与电脑时需要将上述步骤中的ipv4地址设置为自动获取（参考上一步设置ipv6自动获取的步骤），这样路由器才能正常给电脑分配ip地址，电脑才可以连接路由器。
通过ssh登录openwrt路由器后台，通过网线连接路由器lan口与电脑，通过网线连接路由器wan口（路由器上的蓝色接口）与宿舍墙上接口，之后使用putty进行ssh连接，输入192.168.1.1，用户名与密码为openwrt设置的密码，默认用户名为 root ，密码为 admin
安装ip6tables和kmod-ipt-nat6。在ssh依次输入以下命令：
1 opkg update
2 opkg install ip6tables
3 opkg install kmod-ipt-nat6
更改/etc/config/network,在config interface ‘lan’下添加一行：
option ip6addr ‘fc00:100:100:1::1/64’
更改/etc/config/dhcp,将config dhcp ‘lan’那一栏改为以下内容:
config dhcp ‘lan’
option interface ‘lan’
option start ‘100’
option limit ‘150’
option leasetime ’12h’
option dhcpv6 ‘server’
option ra ‘server’
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4df15f0b618819f4bcca829634a3a768/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3338c604d5c89e16a925a04d5979b1e/" rel="bookmark">
			JavaScript：layer关闭指定弹出窗口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JavaScript：layer关闭指定弹出窗口 前言一、关闭指定窗口1.关闭指定窗口：layer.close(index)——推荐用法2.关闭最新弹出的窗口：layer.close(layer.index)3.iframe关闭自身：parent.layer.close(index) 二、关闭所有窗口：layer.closeAll()三、关闭窗口后自动刷新页面： window.parent.location.reload(); 前言 在前端页面中，用 layer 打开窗口供用户输入或选择是非常常见的用法，但是有时为了完成一次操作，需要弹出多个窗口进行选择、输入或者提示，因此在关闭窗口的时候需要实现指定关闭任意窗口，而不能关闭错了或者乱了
这篇文章介绍了 layer 如何在多个窗口中关闭指定的窗口以及如何一次关闭所有窗口
一、关闭指定窗口 1.关闭指定窗口：layer.close(index)——推荐用法 在用 layer.open()等方法打开一个窗口，都会有一个返回值 index ，这时我们只需要记录下来每个窗口对应的返回值 index ，用layer.close(index)即可关闭指定的窗口
var index1 = layer.open(); var index2 = layer.alert(); var index3 = layer.load(); var index4 = layer.tips(); layer.close(index1);//关闭第1个窗口 layer.close(index3);//关闭第3个窗口 2.关闭最新弹出的窗口：layer.close(layer.index) 我们也可以选择不记录每次弹出的窗口的 index 值，而用 layer.index 去获取最新打开的窗口的 index ，每次将最新打开的窗口关闭
这种方法的优点在于比较简单，因为我们关闭的往往都是最新弹出的，缺点在于没办法关闭指定窗口，只能关闭最新的
layer.open(); layer.alert(); layer.load(); layer.tips(); layer.close(layer.index);//关闭最新弹出的窗口 3.iframe关闭自身：parent.layer.close(index) 和关闭指定窗口的逻辑一样，都是先获取需要关闭的窗口的 index 值，再调用 parent.layer.close(index) 实现关闭指定窗口
var index = parent.layer.getFrameIndex(window.name); //先得到当前iframe层的索引 parent.layer.close(index); //再执行关闭 二、关闭所有窗口：layer.closeAll() layer.closeAll(); //疯狂模式，关闭所有层 layer.closeAll('dialog'); //关闭信息框 layer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3338c604d5c89e16a925a04d5979b1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b39a64468b1f681c38f64718e8085c1/" rel="bookmark">
			如何看懂idea git分支树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 准备 本课程以实操解释为主，需要在gitee创建好项目，分别拉两个本地仓库进行操作，下面统一用仓库1、仓库2描述。
一 、gite tree线 1、gite tree线不代表分支 仓库1commit push branch1仓库2 pull仓库1 commit branch2仓库2 commit branch3仓库1commit push branch4仓库2pull、push，经过双面步骤，可以看到idea git tree会有两条线，并在该步骤汇集到同一个节点 2、拉新分支会产生git tree线 仓库2基于master拉出uat分支仓库1 commit push branch7仓库2 commit branch8（uat分支）仓库1 mege uat分支，可以看到拉出新的git tree线
总结：不同相同分支没有先pull再commit导致代码出现分叉，拉新的分支也会有git tree线
二、不同tag颜色代表的含义 黄色-代表本地仓库当前所在分支，切换uat和master分支可以看到
紫色代表远程分支所在commit节点
-紫色代表本地仓库已经commit，但是没有push到远程 三、查看某个分支的所有commit 查看时branch选择想看的的分支
默认展示所有分支
选择uat分支，可以看到branch7没有在uat，只是在master
四、merge时查看不同commit merge前后的处理 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ede3dad630378e7309a274cd73c843e/" rel="bookmark">
			再见CSDN，我的老朋友
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		与CSDN相识于从大学某年级开始，也就是2011.11.15算起来快有12年的历史了，算是真正的老朋友了，9年义务教育+3年高中+4年本科+3年研究生=都读完都没有12年，你们的小学同学、初中同学还有几个认识的，身边朋友换了几波了。但是我只有CSDN，没有其他的博客目前。
以前查资料大部分都是来自于csdn，可能因为是用习惯了，感觉界面比较友好，适合自己的审美。
后面17年开始，使用csdn当做自己的笔记，写文章是为了给自己看的，把知识点做个个人记录，所以文章写的乱七八糟，但发现还有访问量，但是没有任何反馈，毕竟我是想和大家交流，所以发现csdn有个功能，就是需要关注后才能查看全部文档，当然很多人都不喜欢这功能，但不过，确实这样吸引了一些粉丝。比较粉丝才是创造坚持下去的动力。
发现CSDN仅自己可看的文章，一定要先进入个人中心，然后点击进去，就是编辑模式，感觉不要叫仅自己可看，叫草稿吧。太不方便了。
CSDN再次也发现过多次bug，打开评论相关，卡都卡死，起初以为是公司网络问题，打开其他博客却没有问题，故怀疑就是csdn问题。
2017年开始决定，好记性不如烂笔头，记录自己所学的知识点，故写的比较少，因为大部分属于公司的东西，写的也不好，拍板也不好看，之前主要是想着给自己看的，后面有收到很多赞，就针对入门级小白也写了一些（当年没有人带，自己摸索老走弯路）。
答案是虽然已经破万，上次有评选也是前100名，可是当我看到其他博主也有奖励时，我就想学学其他博主一样，总留点什么。
不想说太多，有时间回来看看，不再定期更新，也不引流，相见于江湖，如果在其他博客上看到我，请点点关注，点点赞。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17de4c886c6bf726ed89fd2511284b10/" rel="bookmark">
			GPS 辅助定位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于 GPS 辅助定位的种类比较多，受限于认知，这里记录 Android 移动设备主要的一些GPS辅助功能说明。
一、AGPS 辅助全球卫星定位系统（Assisted Global Positioning System，简称：AGPS），就是 GPS + 辅助信息。它可以利用手机基地站的资讯，配合传统 GPS 卫星，让定位的速度更快。AGPS 需要额外的辅助服务器支持。支持 AGPS 的手机将自身所接入的基站信息通过移动网络(GSM/GPRS、WCDMA等)提交到辅助服务器，后者返回相应的GPS辅助信息加速手机的GPS定位。AGPS 还会将初步的GPS 定位结果通过移动网络提交到辅助服务器，后者结合差分 GPS 基准站的信息，返回精度更高(比如小于10米)的定位结果。AGPS在拥有上述优点的同时由于使用了移动网络，会产生少量流量，据说每轮定位下来会消耗十几KB的流量。
定位原理：
1、设备通过基站获取到当前所在的大概地理位置（实际是一次COO（Cell of Origin）定位，基于Cell-ID的定位技术）
2、设备通过蜂窝网络将当前位置上传到AGPS的位置服务器
3、APGS位置服务器根据接受到的位置信息，查询该区域当前可用的卫星信息（包括卫星的频段、方位、俯仰角等），并返回给设备
4、设备GPS接收器根据得到的可用卫星信息，可以快速找到当前可用的GPS卫星进行定位
二、MTK EPO EPO（Extended Prediction Orbit）是 MTK 开发的一种离线GPS辅助定位技术。它支持最长30天的GPS卫星轨道预测数据，通过这些数据，可以大幅缩短GPS首次定位时间(TTFF)，显著地提升用户体验。由于GPS一直在校正过程中，GPS卫星轨道预测数据一个月后偏差就较大了，需要进行数据更新，否则，会因为错误的数据导致GPS定位耗时更久甚至异常。
定位原理：
1、当 gps_init 的时候，检测EPO文件是否存在或者仍在有效期
2、文件不存在或者过了有效期的情况下，通过网络从MTK服务器上下载EPO数据包
3、下载EPO文件成功后，且GPS task在20s内检测EPO文件OK，则将EPO数据、UTC时间、当前的经纬度等写入GPS模块；
4、GPS 根据EPO文件里面包含的卫星预测数据，快速搜星定位
注：vendor/mediatek/proprietary/hardware/connectivity/gps/mtk_mnld/etc/gps.conf 中配置
EPO_ENABLE=1//启用EPO
DW_DAYS=9//下载数据最大天数
关于EPO中遇到一些问题见 MTK GPS问题调试
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b0e75d38eaade0331df58628df6d29e/" rel="bookmark">
			MinIO快速入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、MinIO概述 官网地址：http://www.minio.org.cn/
文档地址：http://docs.minio.org.cn/docs/
MinIO是一款基于Apache License v2.0开源协议的分布式文件系统（或者叫对象存储服务），可以做为云存储的解决方案用来保存海量的图片、视频、文档等。由于采用Golang实现，服务端可以工作在Windows、Linux、 OS X和FreeBSD上。配置简单，基本是复制可执行程序，单行命令就可以运行起来。
MinIO兼容亚马逊S3(Simple Storage Service，简单存储服务)云存储服务接口，非常适合于存储大容量非结构化的数据，例如图片、视频、日志文件、备份数据和容器/虚拟机镜像等，而且每个对象文件可以是任意大小，从几kb到最大5T不等。
MinIO特点：
高性能：作为高性能对象存储，在标准硬件条件下它能达到55GB/s的读、35GB/s的写速率；可扩容：不同MinIO集群可以组成联邦，并形成一个全局的命名空间，并跨越多个数据中心；SDK支持: 基于Minio轻量的特点，它得到类似Java、Python或Go等语言的sdk支持；支持纠删码：MinIO使用纠删码、Checksum来防止硬件错误和静默数据污染。在最高冗余度配置下，即使丢失1/2的磁盘也能恢复数据； MinIO基本概念：
bucket（桶） ：类似文件系统的目录(文件夹)；Object ： 类似文件系统的文件；Keys ：类似文件名；MINIO_ACCESS_KEY：访问key，类似账号；MINIO_SECRET_KEY：秘钥，类似密码。 文件存储方式对比：
存储方式优点缺点服务器磁盘开发便捷，成本低扩展困难分布式文件系统（开源：FastDFS、MinIO）容易实现扩展复杂度高第三方存储（阿里云OSS、七牛云）开发简单，功能强大，免维护收费 分布式文件系统对比：
FastDFS是阿里余庆做的个人项目，也是一款开源高性能的分布式文件系统，适合小规模文件数据存储，默认不提供UI界面，安装部署(运维)复杂，很难达到以G为单位的每秒读写速度，没有完备的官方文档，环境搭建较为复杂；MinIO是由MinIO.Inc运营的开源项目，号称世界上速度最快的对象存储服务器，并且社区活跃度高，标准硬件条件下它能达到55GB/s的读、35GB/s的写速率，而且MinIO部署自带管理界面，不需要额外安装；MinIO提供了所有主流开发语言的SDK，并且兼容亚马逊S3云存储服务接口，在MinIO中一个对象文件可以是任意大小，从几KB到最大的5T不等；最后它提供了与k8s、etcd、docker等容器技术深度集成方案，可以说就是为云原生而生的。（缺点，不支持动态增加节点）更详细文章参考：https://www.cnblogs.com/loveer/p/16857625.html 二、MinIO环境搭建 本文基于Docker实现MinIO环境快速部署，Docker安装参考：https://blog.csdn.net/qq_46921028/article/details/129096134
1、拉取镜像（https://hub.docker.com/r/minio/minio/tags）
# 下载新版minio docker pull minio/minio # 或者下载指定版本的minio docker pull minio/minio:RELEASE.2021-04-06T23-11-00Z 2、创建容器
docker run -p 9000:9000 --name minio -d --restart=always -e "MINIO_ACCESS_KEY=minio" -e "MINIO_SECRET_KEY=minio123" -v /docker/minio/data:/data -v /docker/minio/config:/root/.minio minio/minio server /data # 或者指定镜像版本并创建容器 docker run -p 9000:9000 --name minio -d --restart=always -e "MINIO_ACCESS_KEY=minio" -e "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b0e75d38eaade0331df58628df6d29e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/995d6eca1ea3c69f1643cbc3be22b735/" rel="bookmark">
			EasyExcel 批量导出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、EasyExcel 导出封装二、食用步骤1.自定义excel样式2.导出数据 三、复杂excel导出3.1. 自定义复杂表头2. 多sheet 前言 上篇写了数据导入，本文补充一下EasyExcel 批量导出
包括常规excel和复杂excel
一、EasyExcel 导出封装 import com.alibaba.excel.EasyExcel; import com.alibaba.excel.ExcelWriter; import com.alibaba.excel.support.ExcelTypeEnum; import com.alibaba.excel.write.builder.ExcelWriterSheetBuilder; import com.alibaba.excel.write.handler.WriteHandler; import com.alibaba.excel.write.metadata.WriteSheet; import com.google.common.base.Charsets; import com.gsafety.bg.gsdss.common.contants.CommonConstants; import com.gsafety.bg.gsdss.common.exception.BusinessException; import lombok.extern.slf4j.Slf4j; import org.apache.commons.collections4.CollectionUtils; import org.apache.commons.lang3.StringUtils; import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor; import javax.servlet.http.HttpServletResponse; import java.io.OutputStream; import java.net.URLEncoder; import java.util.List; import java.util.Objects; import java.util.concurrent.CompletableFuture; import java.util.concurrent.atomic.AtomicReference; /** * AbstractExcelView */ @Slf4j public abstract class AbstractExcelView&lt;T&gt; { private String excelName; private ExcelTypeEnum excelType; private HttpServletResponse response; public AbstractExcelView(HttpServletResponse response, String excelName, ExcelTypeEnum excelType) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/995d6eca1ea3c69f1643cbc3be22b735/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab8f92a6663db7b33f684ca11fe36dac/" rel="bookmark">
			GET https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.m net::ERR_CONNECTION_TIMED_OUT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springboot项目一启动前端就报这个错，css不显示。但是明明前几天还好用来着，搜索各种解决方式都不好用，然后发现这个网址进不去，然后一打开加速器，好用了。。。页面显示了。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/343fdb25f47d1d01a09f4a5bcb6fc423/" rel="bookmark">
			Axure RP 9 基础教程 元件基础1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一章：Axure RP 9的元件(1)
1、元件的概念
首先我们来认识一下Axure RP 9元件，元件是组成我们原型的零件，也有人翻译成组件。Axure RP 9默认给我们提供了三套元件库，默认元件库、流程图元件库、图标元件库。可以根据自己的需要选择。也可以自己导入第三方的元件库使用。初学者我们使用默认的元件库就够用了。元件库在我们后面章节会仔细讲解，这里就不多说了。下面我们来看看如何使用元件。
2、如何使用元件？
最简单也是最常用的方法，就是用鼠标从元件库中把元件拖拽到画布上。是不是非常简单呢？大家可以把元件库中任意的元件拖进来。
还有一种方法，一般是绘制自定义图形时会用到的，顶部功能菜单中，点击插入，选择对应的图形项目，然后鼠标移入画布区域，按住左键拖动，就可以绘制出对应的图形了。
插入支持快捷键，比如按一下键盘上的O键，按住鼠标左键，在画布中拖动就能快速画出一个椭圆形。
3、如何选中元件。
方式一：单击选中。在画布区域，用鼠标单击对应的元件即可选中。按住shift键或者command/control，可以多选。
方式二：框选。鼠标移动到画布空白处，拖动鼠标，在形成的正方形区域中框住一个或多个元件，可以实现批量选中。框选有两种模式，相交选中和包含选中。在软件左上角这里，可以切换。相交选中，只要框线碰到的就可以选中。包含选中，是框选要完全框住的元件才可以被选中。框选模式我们一般用相交模式。
方式三：在概要里面鼠标单击选中对应的元件。按住shift，可以连续多选。按住command或control，可以任意多选。这种选择模式，在复杂的原型中非常有用。
Command +A 或Control + A可以全选当前页面的所有元件。
4、删除元件
想要删除元件，选中一个或多个想要删除的元件，按delete键，或者返回键即可。
5、复制元件
方式一：Control + C复制 Control + V粘贴
方式二：按住ALT键，鼠标移入想要复制的元件。然后按住鼠标左键，拖动，可以快速复制一个元件。这个快捷键非常好用，在需要大量复制元件时效率会非常高。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c2c21f13873572adc061804c0570ecf/" rel="bookmark">
			vue3 cron表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		my-cron-vue3 这是一个cron表达式生成插件,基于vue3.0与element-plus实现
demo
项目地址 github : https://github.com/sugdove/my-cron-vue3
github项目启动: 1.yarn install 2.yarn serve
依赖 Vue 3.0.0+elementplus 新增回显功能 使用方法请看demo原github地址是 https://github.com/sugdove/my-cron-vue3 安装方式 npm i my-cron-vue3 全局引入方式 //前置配置 import { createApp } from 'vue' import ElementPlus from 'element-plus'; import 'element-plus/lib/theme-chalk/index.css'; import App from './App.vue' //全局引入 import vue3Cron from 'my-cron-vue3' import 'my-cron-vue3/lib/vue3Cron.css' // 引入样式 const app = createApp(App) app.use(ElementPlus).use(vue3Cron).mount('#app') //使用方式：&lt;vue3Cron&gt;&lt;/vue3Cron&gt; 局部引入方式 //局部引入 import { vue3Cron } from 'my-cron-vue3' import 'my-cron-vue3/lib/vue3Cron.css' // 引入样式 export default { template: '&lt;vue3Cron/&gt;', components: { vue3Cron } } 示例 &lt;template&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c2c21f13873572adc061804c0570ecf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ba17017601cd3507b4e0bae123d865a/" rel="bookmark">
			蓝牙遥控器：ESP-BLE-MESH关闭重放攻击检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Replay: src 0x0001 dst 0xc110 seq 0x00004f LOG报这个错，是因为从seq的值小于或等于接收端记录的值，所以接收端（服务端）报这个错。但是我做的是多对多遥控，发射端（客户端）也是Provisioner，所以BLE-MESH网络中存在多个Provisioner，并且src的值是一样的。客户端模型还不能随机指定src的地址值。
解决办法：
1：发射端同步seq值。不太容易实现。
2：关闭接收端的seq检测，ESP-IDF没有提供关闭seq检测的接口，没办法只能自己修改：
esp-idf\components\bt\esp_ble_mesh\mesh_core\transport.c
static int trans_unseg(struct net_buf_simple *buf, struct bt_mesh_net_rx *rx, uint64_t *seq_auth) { uint8_t hdr = 0U; BT_DBG("AFK %u AID 0x%02x", AKF(buf-&gt;data), AID(buf-&gt;data)); if (buf-&gt;len &lt; 1) { BT_ERR("Too small unsegmented PDU"); return -EINVAL; } // 这里注释上就可以了 // if (bt_mesh_rpl_check(rx, NULL)) { // BT_WARN("Replay2: src 0x%04x dst 0x%04x seq 0x%06x", // rx-&gt;ctx.addr, rx-&gt;ctx.recv_dst, rx-&gt;seq); // return -EINVAL; // } hdr = net_buf_simple_pull_u8(buf); if (rx-&gt;ctl) { return ctl_recv(rx, hdr, buf, seq_auth); } else { /* SDUs must match a local element or an LPN of this Friend.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ba17017601cd3507b4e0bae123d865a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/092e51f15188fcd891d01469f96db677/" rel="bookmark">
			STM32F1ADC配置步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、adc单通道配置（采样，保持，转换，编码）
1.首先确定adc的最小刻度，参考电压＋和参考电压- 、然后看adc转换的位数 ，((参考电压 +) -( 参考电压- ))/ adc转换的位数,
以F103ZET6精度固定为12位为例，参考电压如果是3.3和0 ，最小刻度为3.3/4096。
2.确定转换时间，采样时间越长，转换的准确度越高
设定采样周期加上固定的周期，根据adc时钟取倒数乘上上面的周期就是转换周期。
3.模式组合，设置单次转换模式还是循环转换模式，扫描模式还是非扫描模式
其中stm有16个外部通道，单次模式是只转换一次，或者连续转化，扫描模式开启：转换组内其他的通道，不开启只转换指定的通道。
是否开启扫描模式
开启转换一次
用来配置规则组的触发转换
d第8位为转换后的数据定时器的左右对齐，
复位校准： 首先在第3位置1，先初始化校准寄存器，然后在第2位开始校准，由硬件清零，当硬件清零后表示校准完成。
第1位是否开启扫描模式
第0位开启adc
在F1中这个位不但起到给ADC上电的功能，还有触发规则组转换的功能，F4中这个位只起到上电的功能
采样时间寄存器，每个通道有3个位设置，所以有2个寄存器
规则组转换序列，其中20~23位标志规则组中有几个通道进行转换，这个是将通道排序，如果想让通道16第13个转换就将16写入SQ13这几个位中
因为adc是12位的，数据寄存器是16位的，才有左右对齐
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60ecd1bfa879b04d6036de757108ce31/" rel="bookmark">
			面试八股文（c&#43;&#43;）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++ 1.多态，虚函数，纯虚函数的作用？ 多态：一个东西有多种形式。不同的对象，在收到相同的信息时产生不同的行为。
好处：
1.应用程序不必为每个派生类编写功能调用，只需要对抽象基类进行处理即可，大大提高程序的可复用性。
2.派生类的功能可以被基类的方法或引用变量所调用，这叫向后兼容，可以提高可扩充性和可维护性。虚函数作用：允许派生类中重新定义与基类同名的函数，并且可以通过基类指针或引用来访问基类和派生类中的同名函数。纯虚函数作用：在许多情况下，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。 2.Struct和union的区别？ struct和union都是由多个不同的数据类型成员组成的，但是在任何同一时刻，union中只存放一个被选中的成员，而struct的所有成员都存在。
在struct中，各成员都占有自己的内存空间，他们是同时存在的，一个struct变量的总长度等于所有成员长度之和，遵从字节对齐原则。在union中，所有成员不能同时占用它的内存空间，他们不能同时存在，union变量的长度等于最长的成员的长度。对于union的不同成员赋值，将会对其他成员重写，原来成员的值就不存在了，所以，共同体变量中起作用的成员是最后一次存放的成员；而struct的不同成员赋值是互不影响的。 3.Const和#define区别？ 编译器处理方式不同：#define宏是在预处理阶段展开的，不能对宏定义进行调试，而const常量是在编译阶段使用的类型和安全检查不同：#define宏没有类型，不做任何类型检查，仅仅是代码展开，可能产生边际效应等错误，而const常量有具体类型，在编译阶段会执行类型检查存储方式不同：#define宏仅仅是代码展开，在多个地方进行字符串替换，不会分配内存，存储于程序的代码段中，而const常量会分配内存，但只维持一份拷贝，存储在程序的数据段。定义域不同：#define宏不受定义域限制，而const常量只在定义域内有效。 4.内存泄漏的场景及解决方法有哪些？如何避免内存泄漏？ 常见场景：
1.指针重新赋值
2.错误的内存释放
3.返回值的不正确处理
4.在内存分配后忘记使用 free 进行释放
*
解决方法：
1.良好的编程习惯
2.当在堆上申请了空间，一定记得释放
3.使用c++的智能指针
4.避免产生死锁情况
5.打开的文件描述符一定记得关闭
6.利用一些第三方工具，去检测内存泄漏。如何避免？
1.确保没有访问空指针
2.每次分配内存之后都应该有一个free函数与之对应，alloca函数除外。
3.每次分配内存之后都应该及时进行初始化，可以结合memset函数进行初始化，calloc函数除外。
4.每当向指针写入值时，都要确保可用字节数和所写入的字节数进行交叉核对
5.对指针赋值前，一定要确保没有内存位置会变得孤立。
6.每当释放结构化的元素（而该元素又包含指向动态分配的内存位置的指针）时，都应先遍历子内存位置并从那里开始释放，然后再遍历回父节点
7.始终正确处理返回动态分配的内存引用的函数返回值。 5.TCP和UDP的区别？ 6.TCP建立连接时三次握手，为啥断开时是四次挥手？ 这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。
7.常见的多线程之间线程同步的方式有哪些？实际用到的是哪个？ 互斥锁条件变量读写锁信号量 几种线程同步的方式各有利弊，实际开发中需要根据场景选择不同的方式使用开发 8．为什么TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态？ 这是因为虽然双方都同意关闭连接了，而且握手的4个报文也都协调和发送完毕，按理可以直接回到CLOSED状态（就好比从SYN_SEND状态到 ESTABLISH状态那样）；但是因为我们必须要假想网络是不可靠的，你无法保证你最后发送的ACK报文会一定被对方收到，因此对方处于 LAST_ACK状态下的SOCKET可能会因为超时未收到ACK报文，而重发FIN报文，所以这个TIME_WAIT状态的作用就是用来重发可能丢失的 ACK报文。
9.引用和指针的区别 从大小来说：引用是别名，系统不会给引用分配存储单源，指针会占一定的空间，大小为地址总线个bit位从指向来说：引用不可以指向空值，指针可以。引用不可以修改指向，指针可以从初始化来说：引用在声明时必须初始化，而指针不必。从操作来说：引用实际上操作的就是对象本身，指针是间接操作对象 10.虚函数和纯虚函数的共同点和区别 共同点：都可以被子类重写区别：纯虚函数只能在纯虚类中定义，而且不能有函数体，不可以实例化对象
虚函数可以有自己的函数体，可以在任何类中定义，仍可以实例化对象 11.关于linux进程分类 按照进程的功能和运行的程序分类，进程可划分为两大类：
(1) 系统进程：可以执行内存资源分配和进程切换等管理工作；而且，该进程的运行不受用户的干预，即使是root用户也不能干预系统进程的运行。
(2) 用户进程：通过执行用户程序、应用程序或内核之外的系统程序而产生的进程，此类进程可以在用户的控制下运行或关闭。
针对用户进程，又可以分为交互进程、批处理进程和守护进程三类。
(1) 交互进程：由一个shell终端启动的进程，在执行过程中，需要与用户进行交互操作，可以运行于前台，也可以运行在后台。
(2) 批处理进程：该进程是一个进程集合，负责按顺序启动其他的进程。
(3) 守护进程：守护进程是一直运行的一种进程，经常在linux系统启动时启动，在系统关闭时终止。它们独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。例如httpd进程，一直处于运行状态，等待用户的访问。还有经常用的crond进程，这个进程类似与windows的计划任务，可以周期性的执行用户设定的某些任务。"
12.nullptr调用成员函数可以吗？为什么？ 能；原因：因为在编译时对象就绑定了函数地址，和指针空不空没关系。
13.c++为什么要引入weak_ptr? shared_ptr和weak_ptr都是带有引用计数的智能指针，它俩的主要区别就是:
shared_ptr可以改变引用计数的值，但是weak_ptr只是资源的观察者不会对资源的引用计数进行加1的操作使用场景 解决shared_ptr的循环引用问题 14.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60ecd1bfa879b04d6036de757108ce31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c6319b29b37094589fc02c001ccacca/" rel="bookmark">
			微信小程序开发中遇到的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、clearInterval不起作用
2、设置background: linear-gradient(180deg, #FCF8F5 0%, #FCF8F5 99.9%, transparent 100%);解决元素底部有黑线的问题。但是在ios中不起作用。
3、wx.createAnimation，设置的动画只能执行一次
4、swiper在苹果手机上显示不全（打开就这样），安卓手机也会出现这种情况（反复操作后），如图
5、微信小程序跳转报错errMsg: “navigateTo:fail webview count limit exceed“（反复操作页面时出现）
6、ios和安卓时间计算不兼容问题
7、手机获取不到存在本地openid，主要表现在苹果手机
8、onUnload带来的坑
1、clearInterval不起作用 原因：创建了重复的定时器
解决方案：在创建定时器前先进行清空
2、设置background: linear-gradient(180deg, #FCF8F5 0%, #FCF8F5 99.9%, transparent 100%);解决元素底部有黑线的问题。但是在ios中不起作用。 原因：ios不兼容
解决方案：background: linear-gradient(180deg, #FCF8F5 0%, #FCF8F5 99.9%, rgba(255,255,255,0) 100%);
3、wx.createAnimation，设置的动画只能执行一次 原因：动画只执行有差值的动画
解决方案：执行完一次动画后，过几秒在回归到初始状态即可
let animation = wx.createAnimation({ duration: 2000, timingFunction: 'ease', delay: 0, transformOrigin: 'center center 0', }) animation.opacity(0.5).rotate(360).step({ duration: 3000 }) setTimeout(() =&gt; { animation.rotate(0).opacity(1).step({ duration: 10 }) }, 2000); 4、swiper在苹果手机上显示不全（打开就这样），安卓手机也会出现这种情况（反复操作后），如图 原因：swiper和swiper-item加了行内样式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c6319b29b37094589fc02c001ccacca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc934afb032f89a835be7147151969b7/" rel="bookmark">
			Linux---虚拟机配置固定IP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. IP地址 每一台联网的电脑都会有一个地址，用于和其它计算机进行通讯
IP地址主要有2个版本，V4版本和V6版本（V6很少用，课程暂不涉及）
IPv4版本的地址格式是：a.b.c.d，其中abcd表示0~255的数字，如192.168.88.101就是一个标准的
IP地址。
可以通过命令：ifconfig，查看本机的ip地址。
如果无法使用ifconfig命令，可以安装：yum -y install net-tools。
除了标准的IP地址以外，还有几个特殊的IP地址：
127.0.0.1，这个IP地址用于指代本机；
0.0.0.0，特殊IP地址，可以用于指代本机，可以在端口绑定中用来确定绑定关系，也在一些IP地址
限制中，表示所有IP的意思，如放行规则设置为0.0.0.0，表示允许任意IP访问。
2. 主机名 每一台电脑除了对外联络地址（IP地址）以外，也可以有一个名字，称之为主机名。
无论是Windows或Linux系统，都可以给系统设置主机名。
可以使用命令：hostname 查看主机名
可以使用命令：hostnamectl set-hostname 主机名，修改主机名（需root）
重新登录FinalShell即可看到主机名已经正确显示。
3. 域名解析 可以通过主机名找到对应计算机的IP地址，就是主机名映射（域名解析）。
比如访问www.baidu.com：
先查看本机的记录（私人地址本）；
Windows查看：C:\Windows\System32\drivers\etc\hosts
Linux查看：/etc/hosts
再联网去DNS服务器（如114.114.114.114，8.8.8.8等）询问；
配置主机名映射：
在Windows系统的：C:\Windows\System32\drivers\etc\hosts文件中配置记录。
4. 虚拟机配置固定IP 虚拟机的Linux操作系统，其IP地址是通过DHCP服务获取的。
DHCP：动态获取IP地址，即每次重启设备后都会获取一次，可能导致IP地址频繁变更。
固定IP地址的原因：
当要远程连接到Linux系统时，如果IP地址经常变化，就需要频繁修改适配很麻烦；
配置了虚拟机IP地址和主机名的映射后，如果IP频繁更改，也需要频繁更新映射关系。
在VMware Workstation中配置固定IP的步骤：
①：在VMware Workstation（或Fusion）中配置IP地址网关和网段（IP地址的范围）
②：在Linux系统中修改固定IP 使用vim编辑/etc/sysconfig/network-scripts/ifcfg-ens33文件，填入如下内容
执行：systemctl restart network 重启网卡，执行ifconfig即可看到ip地址固定为192.168.88.130。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/78/">«</a>
	<span class="pagination__item pagination__item--current">79/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/80/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>