<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ac1913e1613de4774078ea597237377/" rel="bookmark">
			&#43;&#43;i和i&#43;&#43;的根本区别                                                                                        ...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		至于++i和i++有什么区别，举个例子 1.a = i++; 等校为 a = i; i = i + 1； 2.a = ++i; 等校为 i = i + 1； a = i; i++和++i的 最重要的区别大家都知道就是 +1和返回值的顺序 但，两这还有一个区别（在C++中）就是i++在实现的时候，产 生了一个local object class INT; //++i 的版本 INT INT::operator++() { *this=*this+1; return *this; } //i++ 的版本 const INT INT::operator ++(int) { INT oldvalue=*this; *this=*this+1; return oldvalue } 所以从效率上来说++i比i++来的更有效率 具体细节你可以看More Effective C++ 的M6 看看C++类重载运算符就知道了。 对于i++的实现是： int temp; temp = i; i = i+1; return temp; 而++i的实现是： i = i+1; return i; 比如printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ac1913e1613de4774078ea597237377/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d4f24d4cb37c3c0575b686674f5da39/" rel="bookmark">
			samba共享目录无法访问的一般解决方案，非用户登录和读写权限问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 转自 http://blog.csdn.net/runningsword/article/details/6890159
配smb，被第四点坑了很久，特此转载。
由于这5点都是比较普通的情况，不涉及用户登录和读写权限问题
1)关闭防火墙： #sevice iptables stop
2)修改 /etc/samba/smb.conf，具体配置网上有,我的如下： security = share ---- 这个要用上，share表示安全最低级别，其次是user,最高是server [共享目录名] path = /home/用户名/共享目录名 ;read only = no -----这个需要在前面用分号注释掉 writeable = yes browseable = yes public = yes guest ok = yes 3)SELinux作怪 修改/etc/sysconfig/selinux 把enforcing改成disabled；然后命令行setenforce 0； 或者用Rainsome兄说的 使用selinux强制策略：chcon -R -t samba_share_t /home/suyang/"Fedora Samba" 4)修改目录权限 #chmod 777 /home/wind ; #chmod 777 /home/wind/smbShare; 特别是前面一个做为上层目录权限也需要修改！！！！
5)重启samba服务 #service smb restart 或者 /etc/rc.d/init.d/smb restart 结束。 当然你要在linux与windows之间互相能ping 通。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6aeb7bc3151781e14591b1d9b4243db4/" rel="bookmark">
			m3u8 格式影片加載
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 我想請問一下 使用Mediaplayer 加載這種格式的影片 遠端跟本地端加載m3u8格式影片有何區別 情況是這樣的 假設在以下網址可以載到一個m3u8格式影片 http://www.example.com/a1.m3u8 若要將此m3u8檔設給mideaplayer 就呼叫此方法 mediaplayer.setDataSource(context, Uri.parse("http://www.example.com/a1.m3u8"));
即可,影片的確也正常播放 但是當我將此m3u8檔存入本地端 再由本地端加載, 就會發生未知錯誤 也就是 Error (1,-2147483648)
我想了一下, 是不是因為在本地端加載的話, 就必須給m3u8裡的影片清單全都加上完整的網址 以下假設是a1.m3u8的內容 #EXTM3U
#EXT-X-VERSION:3
#EXT-X-TARGETDURATION:10
#EXT-X-MEDIA-SEQUENCE:101
#EXTINF:9.021333,
aa_101.ts
#EXTINF:9.000000,
aa_102.ts
#EXTINF:8.200000,
aa_103.ts
#EXT-X-ENDLIST
我將之改動為 #EXTM3U
#EXT-X-VERSION:3
#EXT-X-TARGETDURATION:10
#EXT-X-MEDIA-SEQUENCE:101
#EXTINF:9.021333,
http://www.example.com/aa_101.ts
#EXTINF:9.000000,
http://www.example.com/aa_102.ts
#EXTINF:8.200000,
http://www.example.com/aa_103.ts
#EXT-X-ENDLIST
再測試了一下連結(連結全都是假設,請別當真去試) http://www.example.com/aa_101.ts
http://www.example.com/aa_102.ts
http://www.example.com/aa_103.ts
的確可以正常播放影片與下載 於是我將此直接存為a2.m3u8再設給mediaplayer 但仍然是未知錯誤 在此請教各位, 到底是為什麼? 遠端加載就可以, 本地加載就不行 他們差異究竟在哪裡 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccc72824d9686604f7adad3a1293e11f/" rel="bookmark">
			（21）斜轴测投影变换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		投影方向不垂直于投影平面的平行投影称为斜平行投影，也称斜轴测投影。
斜轴测投影可以通过三维空间物体的错切变换后做正投影获得。
斜轴测投影的变换矩阵 斜轴测投影是将物体先沿两个方向产生错切，再向投影平面做正投影而获得。
通常先沿X轴含Y错切，再沿Z轴含Y错切，最后向XOZ平面（V面）做正投影得到，变换矩阵为：
斜轴测投影的轴向变形系数 与正轴测投影一样，沿X、Y、Z方向各取一单位长度，可得三点的齐次坐标分别为A[1 0 0 1]、B[0 1 0 1]、C[0 0 1 1]，分别对它们进行斜轴测投影变换：
变换后，A’、B’、C’分别位于轴测轴O’X’、O’Y’、O’Z’上，且A与A’重合，C与C’重合，即OX与O’X’重合，OZ与O’Z’重合。因此，轴向变形系数为：
根据三个坐标轴的轴向变形系数的关系以及αy的取值，将斜轴测投影分为斜等轴测投影、斜二轴测投影、斜三轴测投影。
斜等轴测投影变换 斜等轴测投影变换的限定条件为：
d 和 f 的正负决定沿X轴和Z轴的错切方向，根据具体情况来定。
若取d=f = 0.707，则斜等轴测投影变换矩阵为：
斜二轴测投影变换 斜二轴测投影变换的限定条件为：
对于斜二轴测图，当物体沿负Z方向错切时立体感较强，故 f 取负值，而 d 的正负决定了沿X轴的错切方向。
若取d = f = -0.354，则斜二轴测投影变换矩阵为：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3eebc004e620d2fd28beccc30018bef1/" rel="bookmark">
			C&#43;&#43;将一个数组内容赋给另一个数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有两种方式：
一、进行数组遍历，依次赋值 int arr1[5] = { 1, 2, 3, 4, 5 }; int arr2[10] ={ 0 }; for(int i=0;i&lt;sizeof(arr1)/sizeof(int);i++) arr2[i] = arr1[i] ; 该段程序功能是遍历数组arr1，逐个赋值到数组arr2对应元素中。
二、借用内存复制函数memcpy，整体赋值 void *memcpy(void *dst, void *src, zize_t size);
这个函数的功能是将src上，大小为size字节的数据赋值到dst上。
调用该寒素需要引用头文件&lt;cstring&gt;，即#include&lt;cstring&gt;
赋值数组的代码为
int arr1[5]={1,2,3,4,5}; int arr2[10]={0}; memcpy(arr2,arr1,sizeof(arr1)); 作者：耑新新，发布于 博客园 转载请注明出处，欢迎邮件交流：zhuanxinxin@foxmail.com
转载于:https://www.cnblogs.com/Amedeo/p/6239624.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d19fae8e3e291e4dbe7cf5cdf04385de/" rel="bookmark">
			局域网内如何连接MYSQL数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		==&gt; 学习汇总（持续更新）
==&gt; 从零搭建后端基础设施系列（一）-- 背景介绍
其实不仅仅是局域网，只要你有数据库所在服务器的公网IP地址都能连上。
步骤如下：
1.在服务器上开放数据库端口，一般是开放3306端口，具体端口根据设置的不同而不同。
2.开放数据库远程连接权限，可以指定给哪个数据库的哪个表开放权限给哪个用户，并且还可以指定特定的IP地址才能远程登陆。语法如下：
开放远程连接权限：grant [权限] on [database.table] to [用户名]@[IP] identified by [密码]; 刷新权限：flush privileges; 例子：
grant all privileges on test.* to user@'%' identified by '1234'; 意思是，test数据库的所有表对任意IP地址的user用户开放所有权限，登陆密码是1234。
如图：
这是在虚拟机中连接主机的例子
当然了，你可以给指定的远程机器创建一个root账户，拥有数据库的全部权限。
3.禁止远程用户的所有权限（可以连接数据库，但不能增删改查）
删除用户权限：revoke all on [database.table] from [user]; 例子：
4.删除用户及权限（登录都登录不了了）
删除用户及权限：drop user 用户名@权限; 例子：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02a8403df534fdc2671cb91f27cdc019/" rel="bookmark">
			git 换行符LF与CRLF转换问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git 换行符LF与CRLF转换问题 一、背景 在各操作系统下，文本文件所使用的换行符是不一样的。UNIX/Linux 使用的是 0x0A（LF），早期的 Mac OS 使用的是0x0D（CR），后来的 OS X 在更换内核后与 UNIX 保持一致了。但 DOS/Windows 一直使用 0x0D0A（CRLF）作为换行符。Git提供了一个“换行符自动转换”功能。这个功能默认处于“自动模式”，当你在签出文件时，它试图将 UNIX 换行符（LF）替换为 Windows 的换行符（CRLF）；当你在提交文件时，它又试图将 CRLF 替换为 LF。Git 的“换行符自动转换”功能听起来似乎很智能、很贴心，因为它试图一方面保持仓库内文件的一致性（UNIX 风格），一方面又保证本地文件的兼容性（Windows 风格）。但遗憾的是，这个功能是有 bug 的，而且在短期内都不太可能会修正。
二、解决方案 1.Git设置 git config --global core.autocrlf false
git config --global core.safecrlf true
含义：
AutoCRLF
#提交时转换为LF，检出时转换为CRLF
git config --global core.autocrlf true #提交时转换为LF，检出时不转换
git config --global core.autocrlf input #提交检出均不转换
git config --global core.autocrlf false
SafeCRLF
#拒绝提交包含混合换行符的文件
git config --global core.safecrlf true #允许提交包含混合换行符的文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02a8403df534fdc2671cb91f27cdc019/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c301e3af994dfc23b6bf8f3ccd447f39/" rel="bookmark">
			mysql注册码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工作之余，有很多朋友问我mysql注册码，今天给大家奉上一个，希望大家编程愉快。
名称和组织不用填写!
注册码：NAVH-WK6A-DMVK-DKW3
另外mysql编码最好通用utf-8，这样有助于大家对编码烦恼的解决。谢谢！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90c06f580648ef42afba8522f7066fc0/" rel="bookmark">
			Zookeeper（二）ZooKeeper服务器的安装与启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Zookeeper官方文档特别强调，由于FreeBSD系统的JVM对Java的NIO Selector支持的不是很好，所以不建议在该系统上部署生产环境的Zookeeper服务器。
zookeeper使用 1，下载Zookeeper安装包。
下载地址为：http://zookeeper.apache.org/releases.html。注意用户可以选择稳定版本进行下载，下载后会得到一个文件名类似于zookeeper-x.x.x.tar.gz的文件，解压到一个目录，例如/opt/zookeeper-3.4.3/目录下，同时我们约定，在下文中使用%ZK_HOME%代表该目录。
2.配置文件zoo.cfg。
初次使用Zookeeper，需要将%ZK_HOME%/conf目录下的zoo_sample.cfg文件重命名为zoo.cfg，并且按照如下代码进行简单配置即可：
tickTime=2000
dataDir=/var/lib/zookeeper/
clientPort=2181
initLimit=5
syncLimit=2
server.1=IP1:28883888
server.2=IP2:2888:3888
server.3=IP3:2888:3888
关于Zookeeper的参数配置，将在后面做详细讲解，这里只是简单地说下
在集群模式下，集群中的每台机器都需要感知到整个集群是由那几台机器组成的，在配置文件中，可以按照这样的格式进行配置，每一行都代表一个机器配置：server.id=host:port:port 其中，id被称为Server ID,用来标识该机器在集群中的机器序号。同时，在每台Zookeeper机器上，我们都需要在数据目录（即dataDir参数指定的那个目录）下创建一个myid文件，该文件只有一行内容，并且是一个数字，即对应于每台机器的Server ID数字。在ZooKeepe的设计中，集群中所有机器上zoo.cfg文件的内容都应该是一致的。因此最好使用SVN或是GIT把此文件管理起来，确保每台机器都能共享到一份相同的配置。上面提到了，myid文件中只有一个数字，即一个Server ID。例如，server.1的myid文件内容就是“1”。注意，请确保每个服务器的myid文件中的数字不同，并且和自己坐在机器的zoo.cfg中server.id=host:port:port的id值一致。另外，id的范围是1~255. 3.创建myid文件。
在dataDir所配置的目录下，创建一个名为myid的文件，在该文件的第一行写上一个数字，和zoo.cfg中当前机器的编号对应上。
4.安装相同的步骤，为其他机器配置zoo.cfg和myid文件。
5.启动ZooKeeper服务
至此，所有的选项都已经基本配置完毕，可以使用%ZK_HOME%bin目录下的zkServer.sh脚本进行服务器的启动，如下：
$sh zkServer.sh start
JMX enabled by default
Using config:/opt/zookeeper-3.4.3/bin/../conf/zoo.cfg
Starting zookeeper .... STARTED
6.验证服务器。
启动完成后，可以使用如下命令来检查服务器启动是否正常：
$telnet 127.0.0.1 2181
Trying 127.0.0.1....
Connected to localhost.localdomain(127.0.0.1).
Escape character is '^]'
stat Zookeeper version:3.4.3-1240972,built on 12/28/2016 10:48 GMT
Clients:
/127.00.1:502557[0](queued=0,recved=1,sent=0)
latency min/avg/max:0/1/4489
Received:8444689
Sent:993100
Outstanding:0
Zxid:0x600084344
Mode:leader
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90c06f580648ef42afba8522f7066fc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7d3e3d747fe693ea23377c9c77c450a/" rel="bookmark">
			SAR 命令详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SAR 命令详解 sar 命令行的常用格式： sar [options] [-A] [-o file] t [n] 在命令行中，n 和t 两个参数组合起来定义采样间隔和次数，t为采样间隔，是必须有 的参数，n为采样次数，是可选的，默认值是1，-o file表示将命令结果以二进制格式 存放在文件中，file 在此处不是关键字，是文件名。options 为命令行选项，sar命令 的 选项很多，下面只列出常用选项： -A：所有报告的总和。 -u：CPU利用率 -v：进程、I节点、文件和锁表状态。 -d：硬盘使用报告。 -r：没有使用的内存页面和硬盘块。 -g：串口I/O的情况。 -b：缓冲区使用情况。 -a：文件读写情 况。 -c：系统调用情况。 -R：进程的活动情况。 -y：终端设备活动情况。 -w：系统交换活动。 下 面将举例说明。 例一：使用命令行 sar -u t n 例如，每60秒采样一次，连续采样5次，观察CPU 的使用情况，并将采样结果以二进制 形式存入当前目录下的文件zhou中，需键入如下命令： # sar -u -o zhou 60 5 屏幕显示： SCO_SV scosysv 3.2v5.0.5 i80386 10/01/2001 14:43:50 %usr %sys %wio %idle(-u) 14:44:50 0 1 4 94 14:45:50 0 2 4 93 14:46:50 0 2 2 96 14:47:50 0 2 5 93 14:48:50 0 2 2 96 Average 0 2 4 94 在显示内容包括： %usr：CPU处在用 户模式下的时间百分比。 %sys：CPU处在系统模式下的时间百分比。 %wio：CPU等待输入输出完成时间的百分比。 %idle：CPU空闲时间百分比。 在所有的显示中,我们应主要注意%wio和%idle，%wio的值过高,表示硬盘存在 I/O瓶颈，%idle值高，表示CPU较空闲，如果%idle值高但系统响应慢时，有可能是CPU等待分配内存， 此时应加大内存容量。%idle值如果持续低于10,那么系统的CPU处理能力相对较低，表明系统中最需要解决的资源是CPU。 如果要查看二进 制文件zhou中的内容，则需键入如下sar命令： # sar -u -f zhou 可见，sar命令即可以实时采样，又可 以对以往的采样结果进行查询。 例二：使用命行sar -v t n 例如，每30秒采样一次，连续采样5次，观察核心 表的状态，需键入如下命令： # sar -v 30 5 屏幕显示： SCO_SV scosysv 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7d3e3d747fe693ea23377c9c77c450a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fbb9d3efd3c9b856cf91f043f9d0c83/" rel="bookmark">
			AIX常见命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AIX常见命令
1. oslevel 显示AIX详细的版本号 oslevel -q 查看曾经安装的软件包版本
2. mkdir -p /home/stewart/newdir1/newdir2 建立多重目录
3. touch newfile 创建一个空文件
4. ls -a 显示所有的文件 ls -l 显示文件的详细信息
5. rm -r dirname 删除目录及其目录下的文件
6. file filename 显示文件的类型
7. whoami 查询自己的身份
8. chown user:group filename
9. chgrp group filename (group 在/etc/group中定义)
10. chmod xxx filename
11. TERM=vt100 ;export $TERM ;echo $TERM
12. finger 用户名
13. su - username(To use the new users profile and variables)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fbb9d3efd3c9b856cf91f043f9d0c83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ce563b1ff676147968630a49df98b39/" rel="bookmark">
			IBM AIX操作系统常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一章 IBM小型机硬件配置信息查询命令 1．小型机机型查询命令 # prtconf |grep Model System Model: IBM,7038-6M2 2．小型机CPU信息查询 # lsdev -Cc processor proc0 Available 00-00 Processor proc1 Available 00-01 Processor proc2 Available 00-02 Processor proc3 Available 00-03 Processor 显示处理器的状态、数量、设备逻辑名称 # lsattr -El proc0 state enable Processor state False type PowerPC_POWER4 Processor type False frequency 1452000000 Processor Speed False 3．小型机内存信息查询 # lsdev -Cc memory mem0 Available 00-00 Memory L2cache0 Available 00-00 L2 Cache # lsattr -El mem0 size 4096 Total amount of physical memory in Mbytes False goodsize 4096 Amount of usable physical memory in Mbytes False 4．小型机硬盘信息查询 # lsdev -Cc disk hdisk0 Available 1Z-08-00-8,0 16 Bit LVD SCSI Disk Drive hdisk1 Available 1Z-08-00-9,0 16 Bit LVD SCSI Disk Drive hdisk2 Available 14-08-L SSA Logical Disk Drive hdisk3 Available 14-08-L SSA Logical Disk Drive # lsattr -El hdisk0 pvid 0058e08d80035d6e0000000000000000 Physical volume identifier False queue_depth 3 Queue DEPTH False size_in_mb 36400 Size in Megabytes False 5．小型机网卡信息查询 # lsdev -Cc adapter|grep ent ent0 Available 1c-08 10/100 Mbps Ethernet PCI Adapter II (1410ff01) ent1 Available 1j-08 10/100 Mbps Ethernet PCI Adapter II (1410ff01) ent2 Available 1n-08 10/100 Mbps Ethernet PCI Adapter II (1410ff01) ent3 Available 11-08 10/100 Mbps Ethernet PCI Adapter II (1410ff01) ent4 Available 1A-08 10/100 Mbps Ethernet PCI Adapter II (1410ff01) ent5 Available 1D-08 10/100 Mbps Ethernet PCI Adapter II (1410ff01) # lsattr -El ent0 busmem 0xe4030000 Bus memory address False rom_mem 0xe4000000 ROM memory address False busintr 101 Bus interrupt level False intr_priority 3 Interrupt priority False txdesc_que_sz 512 TX Descriptor Queue Size True rxdesc_que_sz 512 RX Descriptor Queue Size True tx_que_sz 8192 Software TX Queue Size True rxbuf_pool_sz 1024 Receive Buffer Pool Size True media_speed Auto_Negotiation Media Speed True use_alt_addr no Enable Alternate Ethernet Address True alt_addr 0x000000000000 Alternate Ethernet Address True tx_preload 1520 TX Preload Value True ipsec_offload no IPsec Offload True chksum_offload yes Enable hardware transmit and receive checksum True large_send no Enable TCP Large Send Offload True slih_hog 10 Interrupt Events per Interrupt True rx_hog 1000 RX Descriptors per RX Interrupt True poll_link no Enable Link Polling True poll_link_timer 500 Time interval for Link Polling True 6．小型机SCSI卡信息查询 # lsdev -Cc adapter | grep scsi scsi0 Available 1Z-08 Wide/Ultra-3 SCSI I/O Controller scsi1 Available 1Z-09 Wide/Ultra-3 SCSI I/O Controller 7．小型机光纤卡信息查询 # lsdev -Cc adapter | grep fcp 8．小型机SSA卡信息查询 # lsdev -Cc adapter | grep ssa ssa0 Available 14-08 IBM SSA 160 SerialRAID Adapter (14109100) # lsattr -El ssa0 ucode 14109100.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ce563b1ff676147968630a49df98b39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3faedf773c3434fcd870ce5bce48534/" rel="bookmark">
			HP命令与AIX命令对照表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HP命令与AIX命令对照表 安装和卸载 AIX HP-UX Install Software installp –a swinstall Uninstall software installp –u swremove List installed software lslpp -L all swlist Verify installed software lppchk –v swlist -l fileset -a state List all files lslpp -f fileset swlist -l fileset List installed patches instfix –i swlist -l patch Package owner lslpp -w path swlist -l file | grep path SW Directory /usr/lpp /var/adm/sw/ 磁盘与逻辑卷命令 AIX HP-UX Filesystem table /etc/filesystems /etc/fstab Free disk blocks df –k bdf Device listing lsdev –C /sbin/ioscan Disk information bootinfo -s hdisk# diskinfo /dev/rdsk/c#t#d# Disk Label lspv -l hdisk# pvdisplay -v /dev/dsk/C#t#d# Journal Filesystem type Jfs vxfs Default volume group /dev/rootvg /dev/vg00 Display volume group lsvg -l rootvg vgdisplay -v vg00 Modify physical volume Chpv pvchange Prepare physical disk mkdev -c disk -l hdisk# pvcreate List physical volume Lspv pvdisplay Remove disk from volume group Reducevg vgreduce Move logical volumes Migratepv pvmove Create volume group Mkvg vgcreate Remove volume group vgremove Volume group availability Chvg varyonvg varyoffvg vgchange Restore volume group vgcfgrestore Exports volume group Exportvg vgexport Imports volume group Importvg vgimport Volume group listing Lsvg vgscan Change lv characteristics Chlv lvchange List logical volume Lslv lvdisplay Make logical volume Mklv lvcreate Extend logical volume Extendlv lvextend Reduce logical volume reduce LV lvreduce Remove logical volume Rmlv lvremove Prepare boot volumes bootlist -m normal lvlnboot Remove boot volumes lvrmboot Extend File system chfs extendfs fsadm Split mirrors Rmlvcopy lvsplit Merge mirrors lvmerge Create mirrors mklv -c 2 lvcreate -m 1 Add mirrors mklvcopy lv 2 lvextend -m 1 Create striped volumes mklv -u 3 -S 64K lvcreate -i 3 -I 64 System recovery tape mksysb -i /dev/rmt0 /opt/ignite/bin/make_recovery Backup savevg -i rootvg fbackup Restore restvg frecover TCP-IP相关设置 AIX HP-UX Network IP configuration /etc/rc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3faedf773c3434fcd870ce5bce48534/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1b8e438a1b4d379e48cb0513a37f47c/" rel="bookmark">
			unity3dUGUI的Text实现字体间距的调整
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将脚本TextSpacing 直接挂在到Text组件上，然后调整数值即可
using UnityEngine; using System.Collections; using UnityEngine.UI; using System; using System.Collections.Generic; [AddComponentMenu( "UI/Effects/TextSpacing" )] public class TextSpacing : BaseMeshEffect { public float _textSpacing = 1f; public override void ModifyMesh( VertexHelper vh ) { if ( !IsActive() || vh.currentVertCount == 0 ) { return; } List&lt;UIVertex&gt; vertexs = new List&lt;UIVertex&gt;(); vh.GetUIVertexStream( vertexs ); int indexCount = vh.currentIndexCount; UIVertex vt; for ( int i = 6; i &lt; indexCount; i++ ) { //第一个字不用改变位置 vt = vertexs[i]; vt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1b8e438a1b4d379e48cb0513a37f47c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c92c74257b4d9d9542240f5ae46392e/" rel="bookmark">
			cocos2dx 打印table，打印lua堆栈，重载lua代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：在开发cocos2dx的lua代码的时候，经常会打印log获取信息，不断开关游戏重新更新lua代码。这里分享一份文件，方便大家调试。
function printTT(content, ...) local tab = 0 local out_list = {} local function printk(value, key, tab) if key == nil then return end if type(key) ~= "number" then key = tostring(key) else key = string.format("[%d]", key) end if type(value) == "table" then if key ~= nil then table.insert(out_list, tab .. key .. " =") end table.insert(out_list, tab .. "{") for k, v in pairs(value) do printk(v, k, tab .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c92c74257b4d9d9542240f5ae46392e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f0f3fa0092d40f4f900358a3ccb9065/" rel="bookmark">
			【bzoj1093】【tarjan&#43;dp】最大半联通子图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题意
导出子图：对图 (U,V) ,有 (U′,V′) 满足 U′∈U V’是V中所有与U’相连的边 半连通子图：对图 (U,V) ,对任意 u∈U v∈U 满足 u 到v或 v 到u 有一条有向路径
题解 首先考虑对于一个强连通分量一定是一个半连通导出子图，考虑缩点，对于缩点之后的DAG，在一条链上的强连通分量就为一个半联通子图，问题转化成求DAG最长链，考虑按拓扑序dp，记 l[] 为到该点的最长路径，记 cnt[] 为方案数，对于每个入度为0的点向其连通的点扩展
l[to]=l[u]+size[to](l[to]&lt;l[u]+size[to]) cnt[to]+=cnt[u] 注 这题需要注意缩点之后的重边问题，记录vis为前驱标记，或者建图时优化。
#include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;iostream&gt; #include &lt;queue&gt; #define MAXN 100001 using namespace std; struct edge{ int to; edge *nxt; edge(){} edge(int a):to(a),nxt(NULL){} }; struct li{ edge *pre,*lst; void push(int a){ if(!pre) pre=lst=new edge(a); else lst=lst-&gt;nxt=new edge(a); } }e[MAXN],t[MAXN]; int n,m,X; int bel[MAXN],dfn[MAXN],size[MAXN],low[MAXN],sta[MAXN],top,in[MAXN],P,T; void tarjan(int u){ dfn[u]=low[u]=++T;sta[++top]=u; for(edge *it=e[u].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f0f3fa0092d40f4f900358a3ccb9065/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0384de442ca04427ccc9cb2e1fb2c6f/" rel="bookmark">
			Zookeeper（一）分布式事务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们都知道普通的事务中有原子性，一致性，隔离性，持久性。而分布式事务中也有这些属性，下面我们就来介绍一下分布式事务与普通的事务有何不同之处。
分布式事务 随着分布式计算的发展，事务在分布式中也得到了广泛的应用。在单机数据库中，我们很容易能够实现桃满足ACID特性的事务处理系统，但在分布式数据库中，数据分散在各个不同的机器上，如何对这些数据进行分布式的事务处理具有非常大的挑战。分布式中会有机器宕机和各种网络异常。尽管存在这种种分布式问题，但是在分布式计算领域，为了保证分布式应用程序的可靠性，分布式事务是无法回避的。
分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于分布式系统的不同节点上。通常一个分布式事务中会涉及对多个数据源或业务系统的操作。
我们可以设想一个最典型的分布式事务场景：一个跨银行的转账操作涉及调用两个异地的银行服务，其中一个是本地银行提供的取款服务，两个则是目标银行提供的存款服务，这两个服务本身是无状态并且是相互独立的，共同构成了一个完整的分布式事务。如果从本地银行取款成功，但是因为某种原因存款服务失败了，那么就必须回滚到取款钱的状态，否则用户可能会发现自己的钱不翼而飞了。
从上面这个例子中，我们可以看到，一个分布式事务可以看作是由多个分布式的操作序列组成的，例如上面例子中的取款服务和存款服务，通常可以把这一系列的分布式的操作序列成为子事务。因此，分布式事务也可以被定义为一种嵌套型的事务，同时也就局用了ADID事务特性。但由于在分布式事务中，各个子事务的执行是分布式的，因此要实现一种能够保证ACID特性的分布式事务处理系统就显得格外复杂。
CAP和BASE理论 对于本地事务处理或者是集中式的事务处理系统，很显然我们可以采用已经被实践证明很成熟的ACID模型来保证数据的严格一致性。对于一个高访问量、高并发的互联网分布式系统来说，如果我们期望实现一套严格满足ACID特性的分布式事务，很可能出现的情况就是在系统的可用性和严格一致性之间出现冲突——因为我们要求分布式系统具有严格一致性时，很可能需要牺牲掉系统的可用性。但毋庸置疑的一点是，可用性优势一个所有消费者不允许我们讨价还价的系统属性，比如说像淘宝网这样的在线购物网站，就要求它能够&amp;*24小时不间断地对外提供服务，而对于一致性，则更加是所有消费者对于一个软件系统的刚需。因此在可用性和一致性之间永远无法存在一个两全其美的方案，于是如何构建一个兼顾可用性和一致性的分布式系统成为了无数工程师探讨的难题，出现了诸如CAP和BASE这样的分布式系统经典理论。
CAP理论告诉我们，一个分布式系统不可能同时满足一致性（C:Consistency）、可用性（A:Availability）和分区容错性（P:Partition tolerance）这三个基本需求，最多只能同时满足其中的两项。
一致性 在分布式系统环境中，一致性是指数据在多个副本之间是否能够保持一致性的特性。在一致性的需求下，当一个系统在数据一致的状态下执行更新操作后，应该保证系统的数据仍然处于一致的状态。
对于一个将数据副本分布在不同分布式节点上的系统来说，如果对第一个节点的数据进行了更新操作并且更新成功后，却没有使得第二个节点的数据得到相应的更新，于是在第二个节点的数据进行读取操作时，获取的依然是老数据（或称为脏数据），这就是典型的分布式数据不一致情况。在分布式系统中，如果能够做到针对一个数据项的更新操作执行成功后，所有的用户都可以读取到其最新的值，那么这样的系统就被认为具有强一致性（或严格的一致性）。
可用性 可用性是指系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。这里我们重点看下“有限时间内”和“返回结果”。
“有限的时间内”是指，对于用户的一个操作请求，系统必须能够在指定的时间（即响应时间）内返回对应的处理结果，如果超过了这个时间范围，那么系统就被认为是不可用。另外，“有限的时间内”是一个在系统设计之初就设定好的系统运行指标，通常不同的系统之间会有很大的不同。比如说，对于一个在线搜索引擎来说，通常在0.5秒内需要给出用户搜索关键词对应的检索结果。以Google为例，搜索“分布式”这一关键词，Google能够在0.3秒左右的时间，返回大约上千万条检索结果。而对于一个面向HIVE的海量数据查询平台来说，正常的一次数据检索时间可能在20秒到30秒之间，如果是一个时间跨度较大的数据内容查询，“有限的时间”有时候甚至长达几分钟。
从上面的例子中，我们可以看出，用户对一个系统的请求响应时间的期望值不尽相同。但是，无论系统之间的差异多大，唯一相同的一点就是对于用户请求，系统必须存在一个合理的响应时间，否则用户便会对系统感到失望。
“返回结果”是可用性的另一个非常重要的指标，它要求系统在完成对用户请求的处理后，返回一个正常的响应结果。正常的响应结果通常能够明确地反映出对请求的处理结果，即成功或失败，而不是一个让用户感到困惑的返回结果。
让我们再来看看上面提到的在线搜索引擎的例子，如果用户输入指定的搜索关键词后，返回的结果是一个系统错误，通常类似于“OutOfMemoryError”或“System Has Crashed”等提示语，那么我们认为此时系统是不可用的。
分区容错性 分区容错性约束了一个分布式系统需要具有如下特性：分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。
网络分区是指在分布式系统中，不同的节点分布在不同的子网络（机房或异地网络等）中，由于一些特殊的原因导致这些子网络之间出现网络不连通的状况，但各个子网络的内部网络是正常的，从而导致整个系统的网络环境被切分成了若干个孤立的区域。需要注意的是，组成一个分布式系统的每个节点的加入与退出都可以看作是一个特殊的网络分区。
从CAP理论看出，一个分布式系统不可能同时满足一致性、可用性和分区容错性这三个需求。另一方面，需要明确的一点是，对于一个分布式系统而言，分区容错性可以说是一个最基本的要求。为什么这样说，其实很简单，因为既然是一个分布式系统，那么分布式系统的组件必然需要被部署到不同的节点，否则也就无所谓分布式系统了，因此必然出现子网格。而对于分布式系统而言，网络问题又是一个必定会出现的异常情况，因此分区容错性也就成为了一个分布式系统必然需要面对和解决的问题。因此系统架构设计师往往需要把精力花在如何根据业务特点在C（一致性）和A（可用性）之间寻求平衡。
BASE理论 BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的简写，BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的结论，是基于CAP定理逐步演化而来的，其核心思想是即使无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。接下来我们着重对BASE中的三要素进行详细讲解。
基本可用 基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性——但请注意，这绝不等价于系统不可用，以下两个就是“基本可用”的典型例子。
响应时间上的损失：正常情况下，一个在线搜索引擎需要0.5秒内返回给用户相应的查询结果，但由于出现异常（比如系统部分机房发生断电或断网故障），查询结果的响应时间增加到了1~2秒。功能上的损失：正常情况下，在一个电子商务网站上进行购物，消费者几乎能够顺利地完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。 弱状态也称为软状态，和硬状态相对，是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据听不的过程存在延时。
最终一致性 最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性
亚马逊首席技术官Werner Vogels在于2008年发表的一篇文章中对最终一致性进行了非常详细的介绍。他认为最终一致性时一种特殊的弱一致性：系统能够保证在没有其他新的更新操作的情况下，数据最终一定能够达到一致的状态，因此所有客户端对系统的数据访问都能够胡渠道最新的值。同时，在没有发生故障的前提下，数据达到一致状态的时间延迟，取决于网络延迟，系统负载和数据复制方案设计等因素。
在实际工程实践中，最终一致性存在以下五类主要变种。
因果一致性：
因果一致性是指，如果进程A在更新完某个数据项后通知了进程B，那么进程B之后对该数据项的访问都应该能够获取到进程A更新后的最新值，并且如果进程B要对该数据项进行更新操作的话，务必基于进程A更新后的最新值，即不能发生丢失更新情况。与此同时，与进程A无因果关系的进程C的数据访问则没有这样的限制。
读己之所写：
读己之所写是指，进程A更新一个数据项之后，它自己总是能够访问到更新过的最新值，而不会看到旧值。也就是说，对于单个数据获取者而言，其读取到的数据一定不会比自己上次写入的值旧。因此，读己之所写也可以看作是一种特殊的因果一致性。
会话一致性：
会话一致性将对系统数据的访问过程框定在了一个会话当中：系统能保证在同一个有效的会话中实现“读己之所写”的一致性，也就是说，执行更新操作之后，客户端能够在同一个会话中始终读取到该数据项的最新值。
单调读一致性：
单调读一致性是指如果一个进程从系统中读取出一个数据项的某个值后，那么系统对于该进程后续的任何数据访问都不应该返回更旧的值。
单调写一致性：
单调写一致性是指，一个系统需要能够保证来自同一个进程的写操作被顺序地执行。
以上就是最终一致性的五类常见的变种，在时间系统实践中，可以将其中的若干个变种互相结合起来，以构建一个具有最终一致性的分布式系统。事实上，可以将其中的若干个变种相互结合起来，以构建一个具有最终一致性特性的分布式系统。事实上，最终一致性并不是只有那些大型分布式系统才设计的特性，许多现代的关系型数据库都采用了最终一致性模型。在现代关系型数据库中，大多都会采用同步和异步方式来实现主备数据复制技术。在同步方式中，数据的复制国耻鞥通常是更新事务的一部分，因此在事务完成后，主备数据库的数据就会达到一致。而在异步方式中，备库的更新往往存在延时，这取决于事务日志在主备数据库之间传输的时间长短，如果传输时间过长或者甚至在日志传输过程中出现异常导致无法及时将事务应用到备库上，那么狠显然，从备库中读取的的数据将是旧的，因此就出现了不一致的情况。当然，无论是采用多次重试还是认为数据订正，关系型数据库还是能搞保证最终数据达到一致——这就是系统提供最终一致性保证的经典案例。
总的来说，BASE理论面向的是大型高可用可扩展的分布式系统，和传统事务的ACID特性使相反的，它完全不同于ACID的强一致性模型，而是提出通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。但同时，在实际的分布式场景中，不同业务单元和组件对数据一致性的要求是不同的，因此在具体的分布式系统架构设计过程中，ACID特性与BASE理论往往又会结合在一起使用。
小结： 计算机系统从集中式向分布式的变革随着包括分布式网络、分布式事务和分布式数据一致性等在内的一系列问题与挑战，同时也催生了一大批诸如ACID、CAP和BASE等经典理论的快速发展。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6425ac1038ad66f53700f5003e4e59a/" rel="bookmark">
			魔术方法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		__construct()，类的构造函数 __destruct()，类的析构函数 __call()，在对象中调用一个不可访问方法时调用 __callStatic()，用静态方式中调用一个不可访问方法时调用 __get()，获得一个类的成员变量时调用 __set()，设置一个类的成员变量时调用 __isset()，当对不可访问属性调用isset()或empty()时调用 __unset()，当对不可访问属性调用unset()时被调用。 __sleep()，执行serialize()时，先会调用这个函数 __wakeup()，执行unserialize()时，先会调用这个函数 __toString()，类被当成字符串时的回应方法 __invoke()，调用函数的方式调用一个对象时的回应方法 __set_state()，调用var_export()导出类时，此静态方法会被调用。 __clone()，当对象复制完成时调用 __autoload()，尝试加载未定义的类 __debugInfo()，打印所需调试信息
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a1be4d66efb2b0d1a8d34c324c12f0c/" rel="bookmark">
			数据库mysql 主从方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		双机热备的概念简单说一下，就是要保持两个数据库的状态自动同步。对任何一个数据库的操作都自动应用到另外一个数据库，始终保持两个数据库数据一致。 这样做的好处多。 1. 可以做灾备，其中一个坏了可以切换到另一个。 2. 可以做负载均衡，可以将请求分摊到其中任何一台上，提高网站吞吐量。 对于异地热备，尤其适合灾备。废话不多说了。我们直接进入主题。 我们会主要介绍两部分内容：
一， MySQL 备份工作原理
二， 备份实战
我们开始。
我使用的是mysql 5.5.34，
一， mysql 备份工作原理
简单的说就是把 一个服务器上执行过的sql语句在别的服务器上也重复执行一遍， 这样只要两个数据库的初态是一样的，那么它们就能一直同步。
当然这种复制和重复都是mysql自动实现的，我们只需要配置即可。
我们进一步详细介绍原理的细节， 这有一张图：
上图中有两个服务器， 演示了从一个主服务器（master） 把数据同步到从服务器（slave）的过程。
这是一个主-从复制的例子。 主-主互相复制只是把上面的例子反过来再做一遍。 所以我们以这个例子介绍原理。
对于一个mysql服务器， 一般有两个线程来负责复制和被复制。当开启复制之后。
1. 作为主服务器Master， 会把自己的每一次改动都记录到 二进制日志 Binarylog 中。 （从服务器会负责来读取这个log， 然后在自己那里再执行一遍。）
2. 作为从服务器Slave， 会用master上的账号登陆到 master上， 读取master的Binarylog, 写入到自己的中继日志 Relaylog， 然后自己的sql线程会负责读取这个中继日志，并执行一遍。 到这里主服务器上的更改就同步到从服务器上了。
在mysql上可以查看当前服务器的主，从状态。 其实就是当前服务器的 Binary（作为主服务器角色）状态和位置。 以及其RelayLog（作为从服务器）的复制进度。
例如我们在主服务器上查看主状态：
mysql&gt; show master status\G *************************** 1. row *************************** File: mysql-bin.000014 Position: 107 Binlog_Do_DB: Binlog_Ignore_DB: mysql,information_schema,performance_schema,amh 1 row in set (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a1be4d66efb2b0d1a8d34c324c12f0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93ea3f5cb40b9092873951ec88bdc560/" rel="bookmark">
			pt-online-schema-change
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pt-online-schema-change NAME pt-online-schema-change - ALTER tables without locking them.
------------------------------------------------------------------------------------
目前InnoDB引擎是通过以下步骤来进行DDL的：
1 按照原始表（original_table）的表结构和DDL语句，新建一个不可见的临时表（tmp_table）
2 在原表上加write lock，阻塞所有更新操作（insert、delete、update等）
3 执行insert into tmp_table select * from original_table
4 rename original_table和tmp_table，最后drop original_table
5 释放 write lock。
我们可以看见在InnoDB执行DDL的时候，原表是只能读不能写的。为此 perconal 推出一个工具 pt-online-schema-change ，其特点是修改过程中不会造成读写阻塞。
工作原理：
如果表有外键，除非使用 –alter-foreign-keys-method 指定特定的值，否则工具不予执行。
1 创建一个和你要执行 alter 操作的表一样的空表结构。
2 执行表结构修改，然后从原表中的数据到copy到 表结构修改后的表，
3 在原表上创建触发器将 copy 数据的过程中，在原表的更新操作 更新到新表.
注意:如果表中已经定义了触发器这个工具就不能工作了。
4 copy 完成以后，用rename table 新表代替原表，默认删除原表。
用法介绍：
pt-online-schema-change [OPTIONS] DSN
options 可以自行查看 help，DNS 为你要操作的数据库和表。这里有两个参数需要介绍一下：
–dry-run
这个参数不建立触发器，不拷贝数据，也不会替换原表。只是创建和更改新表。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93ea3f5cb40b9092873951ec88bdc560/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91116f73b4f6d965057274db8394172d/" rel="bookmark">
			高德地图API开发应用-----地图显示&#43;定位&#43;marker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在android项目开发过程中需要用到高德地图，网上查到的好多都是之前的一些开发经验，高德地图对于之前的一些方法都已经弃掉不再使用。很多博客中谈及的方法以及不再适用，同时高德地图官网的开发指南讲的不是那么详细，在刚开始使用的时候总是会进入不少误区，经过自己后来的摸索和学习，最好的学习方法就是下载官网上的demo和开发说明，自己在编译器中运行一下，了解每一个功能的实现原理，明白自己希望在自己的Android项目中加入怎样的功能，根据实现代码去做进一步的研究，这样事半功倍！同时可以在最短的时间内在自己的项目中添加上对应的功能。接下来就针对高德地图中最基本的功能（地图的显示，定位到当前位置并在地图上显示，添加对应的market），步骤如下所示：
1、创建项目； 注意配置AndroidManifest.xml，添加下列权限 &lt;!--用于进行网络定位--&gt; &lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION"&gt;&lt;/uses-permission&gt; &lt;!--用于访问GPS定位--&gt; &lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"&gt;&lt;/uses-permission&gt; &lt;!--用于获取运营商信息，用于支持提供运营商信息相关的接口--&gt; &lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"&gt;&lt;/uses-permission&gt; &lt;!--用于访问wifi网络信息，wifi信息会用于进行网络定位--&gt; &lt;uses-permission android:name="android.permission.ACCESS_WIFI_STATE"&gt;&lt;/uses-permission&gt; &lt;!--用于获取wifi的获取权限，wifi信息会用来进行网络定位--&gt; &lt;uses-permission android:name="android.permission.CHANGE_WIFI_STATE"&gt;&lt;/uses-permission&gt; &lt;!--用于访问网络，网络定位需要上网--&gt; &lt;uses-permission android:name="android.permission.INTERNET"&gt;&lt;/uses-permission&gt; &lt;!--用于读取手机当前的状态--&gt; &lt;uses-permission android:name="android.permission.READ_PHONE_STATE"&gt;&lt;/uses-permission&gt; &lt;!--用于写入缓存数据到扩展存储卡--&gt; &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"&gt;&lt;/uses-permission&gt; &lt;!--用于申请调用A-GPS模块--&gt; &lt;uses-permission android:name="android.permission.ACCESS_LOCATION_EXTRA_COMMANDS"&gt;&lt;/uses-permission&gt; &lt;!--用于申请获取蓝牙信息进行室内定位--&gt; &lt;uses-permission android:name="android.permission.BLUETOOTH"&gt;&lt;/uses-permission&gt;&lt;uses-permission android:name="android.permission.BLUETOOTH_ADMIN"&gt;&lt;/uses-permission&gt;
2、高德地图开发者官网上申请新版的key，具体获取key的方法就不在这里一一阐述了，可以自行到高德官网上查看，链接如下(http://lbs.amap.com/api/android-sdk/guide/creat-project/get-key/#key) 将获取到的key配置到自己的项目中去，在下列代码区中：
&lt;application android:icon="@drawable/icon" android:label="@string/app_name" &gt; &lt;meta-data android:name="com.amap.api.v2.apikey" android:value="请输入您的用户Key"/&gt; …… &lt;/application&gt; 3、为实现如下功能的代码如下：
public class LocationActivity extends Activity implements LocationSource, AMapLocationListener { private AMap aMap; private MapView mapView; private OnLocationChangedListener mListener; private AMapLocationClient mlocationClient; private AMapLocationClientOption mLocationOption; private RadioGroup mGPSModeGroup; private TextView mLocationErrText; private static final int STROKE_COLOR = Color.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91116f73b4f6d965057274db8394172d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/131fcff8b174b5d39300419106e23047/" rel="bookmark">
			TCP Server处理多Client请求的方法—非阻塞accept与select
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 参看基于TCP/UDP的socket代码，同一时间Server只能处理一个Client请求：在使用当前连接的socket和client进行交互的时候，不能够accept新的连接请求。为了使Server能够处理多个Client请求，常见的方法： （1）多进程/线程方法、（2）non-blocking socket(单进程并发)、（3）non-blocking和select结合使用。三种方法各有优缺点，下面进行详细分析和说明。
一、多进程/线程方法 这种方法，每个子进程/线程单独处理一个client连接。以使用进程为例，在每个accept成功之后，使用fork创建一个子进程专门处理该client的connection，父进程(server)本身可以继续accept其他新的client的连接请求。示例代码如下：
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; #include &lt;unistd.h&gt; #include &lt;signal.h&gt; #include &lt;sys/wait.h&gt; #define DEFAULT_PORT 1984 //默认端口 #define BUFFER_SIZE 1024 //buffer大小 void sigCatcher(int n) { //printf("a child process dies\n"); while(waitpid(-1, NULL, WNOHANG) &gt; 0); } int clientProcess(int new_sock); int main(int argc, char *argv[]) { unsigned short int port; //get port, use default if not set if (argc == 2) { port = atoi(argv[1]); } else if (argc &lt; 2) { port = DEFAULT_PORT; } else { fprintf(stderr, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/131fcff8b174b5d39300419106e23047/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f75f50b59351580b188047553f1c8940/" rel="bookmark">
			TensorFlow的卷积神经网络例子解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TensorFlow教程地址：https://www.tensorflow.org/tutorials/mnist/pros/ 讲的是经典的机器学习问题MNIST。 使用卷积神经网络进行训练。
载入MNIST数据 MNIST数据可以从这里下载
from tensorflow.examples.tutorials.mnist import input_data mnist = input_data.read_data_sets('MNIST_data', one_hot=True) 创建多层卷积网络 权重初始化 这里定义两个方法：
def weight_variable(shape): initial = tf.truncated_normal(shape, stddev=0.1) return tf.Variable(initial) def bias_variable(shape): initial = tf.constant(0.1, shape=shape) return tf.Variable(initial) tf.truncated_normal根据截断正态分布产生随机数 tf.constant产生常数
卷积(Convolution)和池化(Pooling) def conv2d(x, W): return tf.nn.conv2d(x, W, strides=[1, 1, 1, 1], padding='SAME') def max_pool_2x2(x): return tf.nn.max_pool(x, ksize=[1, 2, 2, 1], strides=[1, 2, 2, 1], padding='SAME') 先说tf.nn.conv2d，它的参数strides代表切边移动的步长，4个方向，而padding是切片上是否可以越过边缘，有两种方式：”SAME”和”VALID”，”SAME”为越过，“VALID”为不越过，它的意义是决定切片中心是否经过图的边缘。
卷积过程例子如下： 再说tf.nn.max_pool，它是最大化池策略。 参数ksize是要执行取最值的切片在各个维度上的尺寸，四维数组意义为[batch, height, width, channels]。 参数strides是取切片的步长，四维数组意义为四个方向的步长，这里height和width方向都为2，例如原本8x8的矩阵，用2x2切片去pool，会获得5x5的矩阵输出（SAME模式），有效的减少特征维度。 参数Padding同conv2d。
第一个卷积层 W_conv1 = weight_variable([5, 5, 1, 32]) b_conv1 = bias_variable([32]) 第一层将以大小为5x5的切片来生成32个特征， [5,5,1,32] 前两位为patch size，再为in_channel，最后为out_channel。in_channel的意义可理解为一个图像RGB的三层，out_channel即生成的神经元数量，如图中的output volume。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f75f50b59351580b188047553f1c8940/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c83110058d3d182be7bcee38bb540c69/" rel="bookmark">
			cocos2dx 3.12 各平台资源加密解密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言，一般项目发包基本会加密 lua代码，图片资源，现在3.12自带一套加密解密流程，但是这套加密流程只适用于lua代码解密，现在需要对框架进行修改，从而可以解密图片资源。
准备，首先要想好自己的加密解密的密钥 和 文件头签名。 {
如: String key = "KEY_FOR_ENCRYPT_OR_DECRYPT"; String Sign = "SIGN_FOR_ENCRYPT_OR_DECRYPT"; }
一 加密流程，先将lua代码和图片资源进行加密，可以写批处理方法，使用刚才想好的密钥和签名调用cocos2d-x/external/xxtea/xxtea.cpp里面的加密方法(这个加密方法可以改成我们自己的, 同理解密也可改)。将需要加密的lua代码和图片资源进行加密即可。最好可以批处理文件。(注：函数参数不用去改它的) 二 cocos2dx 解密流程
1，首先要在Classes/AppDelegate.cpp里面设置解密密钥
applicationDidFinishLaunching(){ ... LuaStack* stack = engine-&gt;getLuaStack(); String key = "加密Key"; //想好的密钥 String Sign = "文件头签名"; //想好的签名 stack-&gt;setXXTEAKeyAndSign(key, strlen(key), Sign, strlen(Sign)); ... } 实际上就是将密钥和签名设置进去了CCLuaStack，可以用这些去解密lua文件代码 ，如下 （注：如果不做图片的加密，这一步做完lua代码的解密就已经完成了） 2，可以看下lua自带的代码解密流程，实际上就是加载Lua代码的时候CCLuaStack调用CCFileUtil去调用各个平台的FileUtil的GetContens函数，获取文件内容buff，然后在CCLuaStack里面在调用LoadBuff()将解密后的内容buff进行加载的解密流程 (此过程cocos2d 3.12已经自带，所以文章开头说lua代码可以做到自动解密) 如下：
CCLuaStack.cpp int LuaStack::executeScriptFile(const char* filename) { ... //调用各平台的获取文件Utils FileUtils *utils = FileUtils::getInstance(); std::string fullPath = utils-&gt;fullPathForFilename(filename); ... //拿到了文件的**内容buff**, data Data data = utils-&gt;getDataFromFile(fullPath); int rn = 0; if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c83110058d3d182be7bcee38bb540c69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5532b421d495b8dcd2691515962565b/" rel="bookmark">
			某餐厅在线服务APP涉众识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，显而易见的初始涉众有餐厅经营者和顾客，故而我们选出一名顾客代表，并与餐厅经营者代表进行讨论。
通过讨论得出以下结论：
① 餐厅经营者使用本系统时，安排服务员工作，额外涉众有服务员。
② 系统支持在线支付功能，额外涉众有收银员和在线支付平台。
③ 系统允许顾客在线预约并点菜，额外涉众有厨师。
④ 客户使用本系统，需要有移动终端设备并且消耗一定流量或使用wifi，额外涉众有移动终端设备销售商和通信运营商。
通过分析，关键涉众有餐厅经营者、服务员、收银员、厨师、顾客。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3abd3889ab4b9b94e8e63cb79b89fe1a/" rel="bookmark">
			cef相关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 应用
在Windows下进行浏览器相关的开发. 1.使用IE相关的接口, IE控件等进行开发. Windows提供了丰富的接口用起来也是非常方便的. 缺点:例如XP还有很多人使用, 它的IE版本可能比较旧, 对一些新的网页特性可能支持的不好.
2.使用Webkit内核或Chrome浏览器内核. 它们都是开源的. Chrome内核使用的就是Webkit浏览器内核, 它在webkit的基础上进行的改善以及速度提升, 增加了一些新特性. 不过听说编译过程非常复杂. 3.使用CEF(Chromium Embedded Framework). 它是基于Google Chrominum项目开发的一个web浏览器控件. 它对chrome内核进行了封装, 而且它的网站上已经编译好了chrome内核. 我们只要编译CEF并带上chrome内核相关的文件(例如DLL), 即可使用. 其优点是对chrome内核的封装, 简化了chrome内核的调用.
(下载地址: http://opensource.spotify.com/cefbuilds/index.html)
二. CEF介绍
CEF:Chromium Embedded Framework是由MarshallGreenblatt在08年成立的一个开源项目, 目的是开发一个基于Google Chromium项目的Web browser控制器. CEF目前支持大多数编程语言和操作系统, 并可以轻松的整合新的和已存在的应用. 设计的目的也是为了效率/性能和方便使用. 基础的框架包括了借助原生库的C/C++接口, 这样将主机的应用与Chromium和WebKit隔离开来. 它提供了浏览器控制和主机应用程序(包括支持自定义插件, 协议, JavaScript对象和JavaScript扩展)之间紧密的集成. 主机应用程序可以有选择地控制资源加载, 导航, 菜单, 打印等, 当利用了相同的性能和Google Chrome浏览器具备的HTML5技术.
三. CEF编译过程
1. 下载CEF
在http://opensource.spotify.com/cefbuilds/index.html 下载最新版的CEF. 我这里下载的是cef_binary_3.2883.1540.gedbfb20_windows32.tar.bz2,解压后, 使用CMake生成VC工程. 生成的VC工程是这样的.
我的开发环境是Win7 + VC2008. 除了ALL_BUILD工程, 其他每一个工程右键rebuild一下. 遇到什么错误就改什么错误.
https://cefbuilds.com/这里也提供了下载, 但是我在这里下载不了!
http://blog.csdn.net/lixiang987654321/article/details/52120034
http://www.2cto.com/kf/201601/465212.html
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3abd3889ab4b9b94e8e63cb79b89fe1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dae03e2f28d62da4184cdc2e7a972ff/" rel="bookmark">
			adb 版本更新后执行依旧是旧版本解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		adb 版本更新后问题 android 4.2之上的版本，sdk的adb驱动不匹配，会造成使用adb命令调试真机时一直出现offline的情况，解决方法也很简单就是SDK Manager中升级adb，但是！！！升级adb之后发现执行adb version查看adb的版本依旧是老的版本，检查环境变量配置都没有问题，在android-sdk-windows\platform-tools下执行adb version命令得到adb的版本号也是最新的。
google之后发现解决方法 windows下解决方法 1. SDK Manager中更新adb 2. 启动adb在window任务管理器中查看进程找到正在运行的adb.exe，然后点击右键打开文件位置找到正在使用的adb的目录 3. 在window任务管理器中关闭adb.exe进程，如果配置过adb环境变量指向android-sdk-windows\platform-tools，则可以直接删除adb.exe、AdbWinApi.dll、AdbWinUsbApi.dll这三个文件,否则可以把android-sdk-windows\platform-tools下的adb.exe、AdbWinApi.dll、AdbWinUsbApi.dll复制粘帖到上面找到的目录，替换文件 4. adb start-server 5. adb version
linux下解决方法 1. wget -O - https://skia.googlesource.com/skia/+archive/cd048d18e0b81338c1a04b9749a00444597df394/platform_tools/android/bin/linux.tar.gz | tar -zxvf - adb 2. sudo mv adb /usr/bin/adb 3. sudo chmod +x /usr/bin/adb 4. adb version
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b78ebf0f2f8aea2c565f649605b2af6/" rel="bookmark">
			Spring Boot Thymeleaf 解析出错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; 原因就是Spring Boot 默认依赖的是低版本的Thymeleaf，低版本的Thymeleaf不能解析HTML5格式的HTML代码，而是把HTML当成XML解析，所有标签必须闭合！
但是！我试过把标签都闭合之后还是会报错，而且每个标签都闭合实在是很繁琐的过程，就另寻解决方案了。最后在Github中下载了一份源码(Github源码地址)。查看源码后，找到解决方法如下：
在pom.xml中的properties标签中加入如下代码
&lt;!-- 覆盖thymeleaf版本依赖 --&gt; &lt;thymeleaf.version&gt;3.0.2.RELEASE&lt;/thymeleaf.version&gt; &lt;thymeleaf-extras-java8time.version&gt;3.0.0.RELEASE&lt;/thymeleaf-extras-java8time.version&gt; &lt;thymeleaf-layout-dialect.version&gt;2.0.5&lt;/thymeleaf-layout-dialect.version&gt;	这段代码是将Spring Boot 默认依赖的thymeleaf版本替换为我们定义的版本，这里为3.0.2.RELEASE。 3.x 以上的 thymeleaf 已经支持HTML5格式HTML代码解析，报错的问题就解决了！
转载于:https://my.oschina.net/SoneWinstone/blog/809335
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7eefebfd195e87d8c0aeea43bcdabad7/" rel="bookmark">
			Android app日志保存功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		每一个App应用应该都需要有日志保存的功能，日志保存可以记录App运行中所遇到的问题，查Bug也比较方便 等等：
Android日志保存功能，保存某几天的最新日志文件到某个目录，直接看是如何代码实现的：
/** * 带日志文件输入的，又可控开关的日志调试 */ //@SuppressLint({ "SdCardPath", "SimpleDateFormat" }) @SuppressLint({ "SimpleDateFormat", "SdCardPath" }) public class DLLog { @SuppressWarnings("unused") private static char LOG_TYPE = 'v'; // 输入日志类型，w代表只输出告警信息等，v代表输出所有信息 private static Boolean LOG_SWITCH = true; // 日志文件总开关 private static Boolean LOG_WRITE_TO_FILE = true; // 日志写入文件开关 private static int SDCARD_LOG_FILE_SAVE_DAYS = 5; // sd卡中日志文件的最多保存天数 private static String LOGFILENAME = ".txt"; // 本类输出的日志文件名称 private static String LOG_PATH_SDCARD_DIR = "/sdcard/LIUDELI/"; // 日志文件在sdcard中的路径 @SuppressLint({ "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7eefebfd195e87d8c0aeea43bcdabad7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d60f22965fbc83797ce6e957bcdee93/" rel="bookmark">
			C#怎样获得richTextBox的行数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 richtextbox.Lines.Length做了个程序，用了个RichTextBox 来记录程序的日志，每条操作记录放在单独的一行，但随着记录的增加，内存使用也增加。现在想只保留最后的N条记录在RichTextBox 中if( richTextBox1.Lines.Length &gt; 3 ){string[] sLines = richTextBox1.Lines;string[] sNewLines = new string[sLines.Length - 3];Array.Copy( sLines, 3, sNewLines, 0, sNewLines.Length );richTextBox1.Lines = sNewLines;}string[] slines=richtextbox1.Text.Spit('\n'); List&lt;string&gt; line1s=new List&lt;string&gt;(); List&lt;string&gt; line2s=new List&lt;string&gt;(); richtextbox1.Text=""; foreach(string s in slines) { if(s.Contains("字符串1"))line1s.Add(s); else if(s.Contains("字符串2"))line2s.Add(s); else richtextbox1.Text+="\n"+s; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bf5e72ed0e8e88a598d439bc02eab4e/" rel="bookmark">
			vsftp上传文件出现553 Could not create file解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 转载自vsftp上传文件出现553 Could not create file解决方法
因工作需要，需要搭建一个ftp服务器，我使用ubuntu 10.04操作系统，下载vsftpdy源代码，进行了编译，安装，然后按照INSTALL文件，创建了用户等操作。
因为时间比较紧，我采用匿名用户，进行文件的上传测试。修改了/etc/vsftpd.conf文件，将默认注释不让匿名用户上传文件的注释去掉，然后保存，然后杀死vsftpd进程，然后重新运行
进行ftp服务器的启动。使用一个客户端，可以正常的连接，但是当上传文件时，总是报553 Could not create file错误信息。我也是按照网上的做法，对/var/ftp目录进行权限设置，如果设置为chmod -R 777 /var/ftp 还会导致ftp服务器不能启动，经过摸索，终于找到了解决的方法。
首先在ftp的目录中创建一个目录，然后设置权限为777 $ sudo mkdir /var/ftp/write $ sudo chmod -R 777 /var/ftp/write 然后修改vsftp的配置文件/etc/vsftpd.conf文件 在最后添加上 local_root=/var/ftp 保存，然后杀死vsftpd进程，然后重启vsftpd服务器程序。 试试看，将文件上传到write目录，这个时候可以正常的上传文件了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36cf4273af815480079eddd77de3eb06/" rel="bookmark">
			Spring Boot【原理分析】(3)——BeanDefinition
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简介 BeanDefinition描述了一个Bean的实例，包括属性，构造方法参数，注解等更多信息。为后面实例化Bean提供元数据依据。 BeanDefinition的实现类有： 1. RootBeanDefinition：spring BeanFactory运行期里，内部特殊bean的定义。 2. ConfigurationClassBeanDefinition：继承RootBeanDefinition，ConfigurationClassBeanDefinitionReader内部静态类。上文（2）中提到的Configuration Class内定义的Bean被解析成这个BeanDefinition。 3. ChildBeanDefinition：Spring2.5后弃用。 4. GenericBeanDefinition：@EnableConfigurationProperties和Spring显示创建。@ImportResource 5. ScannedGenericBeanDefinition：上文（2）中提到的ComponentScanAnnotationParser扫描的@Component定义被解析成这个BeanDefinition。 6. AnnotatedGenericBeanDefinition：Spring Boot autoconfigure功能spring.facotries中定义的EnableAutoConfiguration，以及内部子Configuration。@Import
二、创建过程 1.GenericBeanDefinition： 这里主要看一下@ImportResource xml中定义的bean。 ConfigurationClassBeanDefinitionReader解析Configuration Class时会解析ImportResource，XmlBeanDefinitionReader具体解析xml中的Beans，最终由BeanDefinitionParserDelegate解析每个Bean:
public AbstractBeanDefinition parseBeanDefinitionElement( Element ele, String beanName, BeanDefinition containingBean) { this.parseState.push(new BeanEntry(beanName)); String className = null; if (ele.hasAttribute(CLASS_ATTRIBUTE)) { className = ele.getAttribute(CLASS_ATTRIBUTE).trim(); } try { String parent = null; if (ele.hasAttribute(PARENT_ATTRIBUTE)) { parent = ele.getAttribute(PARENT_ATTRIBUTE); } //构建GenericBeanDefinition并设置className和parentName AbstractBeanDefinition bd = createBeanDefinition(className, parent); //对scope、abstract、lazy-init、autowire、dependency-check、depends-on、autowire-candidate、primary、init-method、destroy-method、factory-method、factory-bean属性进行解析。 parseBeanDefinitionAttributes(ele, beanName, containingBean, bd); bd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36cf4273af815480079eddd77de3eb06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/545adaf87b15a8d044e4ae26d64d7568/" rel="bookmark">
			Bootstrap—面包屑导航breadcrumb
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是面包屑导航，先来看一下效果：
面包屑导航是具有层次结构的一种显示方式，bootrap中通过 .breadcrumb class 的无序列表实现面包屑导航效果，代码如下：
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;面包屑导航&lt;/title&gt; &lt;link rel="stylesheet" href="../libs/bootstrap-3.3.7/css/bootstrap.css"&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="container"&gt; &lt;ul class="breadcrumb"&gt; &lt;li&gt;&lt;a href="#"&gt;鞋子&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;女鞋&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;高跟鞋&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 本文参考资料来自：http://www.runoob.com/bootstrap/bootstrap-breadcrumbs.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53b5a62651ef40fe7b4302d0f3865666/" rel="bookmark">
			在windows下编译mongodb cxx driver
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MongoDB引用到了openssl和bson库，因此先要安装这2个库， 还需要用到cmake生成vs项目， 这里cmake的安装就直接忽略了， 有需要的同学可自行百度。
1. 下载perl, 点击打开链接
2. 下载openssl 点击打开链接
3. 在VS开发人员工具X64下进入openssl源码目录调用perl Configure VC-WIN64A no-asm --prefix=./lib生成配置
4.运行ms\do_win64a生成nak
5.调用nmake -f ms\nt.mak（ntdll.mak生成动态库）即可 没有错误将生成成out32dll下的文件(nmake在vc所有的bin上目录下)
6.运行nmake -f ms\nt.mak install,将库放在lib 文件夹下。
7.进入mongo-c-driver\src\libbson， 如果没有可以手动下载
8.在libbson目录下执行
cmake -G "Visual Studio 14 2015 Win64" "-DCMAKE_INSTALL_PREFIX=./install/"生成项目文件
打开项目生成ALL并INSTALL
10.在mongo-c-driver目录下执行 cmake -G "Visual Studio 14 2015 Win64" "-DENABLE_SSL=WINDOWS" "-DCMAKE_INSTALL_PREFIX=./install" "-DBSON_ROOT_DIR=./src/libbson/install"
打开项目生成ALL并INSTALL
11.在mongo-cxx-driver目录下执行
cmake -G "Visual Studio 14 2015 Win64" -DCMAKE_INSTALL_PREFIX=./install -DLIBBSON_DIR=../../../mongoc/src/libbson/install/ -DLIBMONGOC_DIR=../../../mongoc/install/ -DBOOST_ROOT=D:\rep\devel\boost_1_62_0_bin
打开项目生成ALL并INSTALL
12.编译mongo-cxx-legacy
scons --64 --cpppath="D:\rep\devel\boost_1_62_0_bin" --libpath="D:\rep\devel\boost_1_62_0_bin\libs" install --dbg=on
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/323b158bd41c895618452394f321d7bf/" rel="bookmark">
			where执行顺序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		where执行顺序是从下到上，可以过滤掉最多数据的条件放到末尾，
转载于:https://my.oschina.net/nisir/blog/806319
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f41029f792316777f2d8747c26db97e3/" rel="bookmark">
			web前端开发学习总结-1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正式开始学习前端开发，以前就会写简单的html，js，现在回来一看，内容实在太丰富了，基本要从基础学起。 努力。。。努力。。。
学前端，首先要选个前端框架，VUE，Angular，React，好吧，对于一个初学者来说，有些晕了。
https://www.zhihu.com/question/27791075
只能往头再捋捋，先把相关知识过一遍。查询vue，发现都是说vue要配合webpack来使用，再看一下什么是webpack：
http://www.w2bc.com/Article/50764
基本概念：
webpack是近期最火的一款模块加载器兼打包工具，它能把各种资源，例如JS（含JSX）、coffee、样式（含less/sass）、图片等都作为模块来使用和处理。
webpack 是以 commonJS 的形式来书写脚本滴，但对 AMD/CMD 的支持也很全面，方便旧项目进行代码迁移。
https://www.zhihu.com/question/20351507/answer/14859415
对于依赖的模块，AMD 是提前执行（异步模块定义，requirejs 是实现），CMD （通用模块定义，seajs是实现）是延迟执行，CommonJs是为了服务器端开发的规范（同步的，node.js是实现）
CommonJs
http://zccst.iteye.com/blog/2215317
根据CommonJS规范，一个单独的文件就是一个模块。加载模块使用require方法，该方法读取一个文件并执行，最后返回文件内部的exports对象。 //require方法默认读取js文件，所以可以省略js后缀 var test = require('./boobar').foobar; test.bar(); CommonJS 加载模块是同步的，所以只有加载完成才能执行后面的操作。像Node.js主要用于服务器的编程，加载的模块文件一般都已经存在本地硬盘，所以加载起来比较快，不用考虑异步加载的方式，所以CommonJS规范比较适用。但如果是浏览器环境，要从服务器加载模块，这是就必须采用异步模式。所以就有了 AMD CMD 解决方案。 AMD异步加载模块。它的模块支持对象 函数 构造器 字符串 JSON等各种类型的模块。 适用AMD规范适用define方法定义模块。 //通过数组引入依赖 ，回调函数通过形参传入依赖
require([module], callback); require(['clock'],function(clock){ clock.start(); }); CMD推崇依赖就近，AMD推崇依赖前置。 AMD支持CMD的写法 //AMD define(['./a','./b'], function (a, b) { //依赖一开始就写好 a.test(); b.test(); }); //CMD define(function (requie, exports, module) { //依赖可以就近书写 var a = require('./a'); a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f41029f792316777f2d8747c26db97e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/296f85d083d58db7f06906b2bb1fd142/" rel="bookmark">
			GH Bladed 软件使用学习笔记（3）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		风电机组在额定风速以下，可以通过控制器改变运行速度，使之跟随风速的变化，从而使叶尖速比保持最佳，气动效率Cp最高。 bladed里面提供两种方法：查表控制和最优控制。 本文就介绍一下这两种控制： 在介绍之前首先确定最佳叶尖速比，最佳叶尖速比是根据选定的叶片来的，可以通过bladed软件确定给定浆叶数据的最佳叶尖速比。 改变pitch angle 就能找出一条Cp-λ曲线 每改变计算一次就出来一条，然后，我们选出一条来作为最佳Cp-λ曲线，选取的原则是： 1，Cp max 要大 2，顶端要尽量平 3，λ要尽可能小（因为风力发电机组的叶尖噪声与叶尖速比λ 的五次方成正比） a，查表控制法 首先在控制策略里面先选择look-up table 查询 添加对应的电机转速和转矩 然后生成转速与转矩控制曲线 一看这条控制曲线就是比较粗犷的控制方式 b，最优控制 按照最佳转矩关系式对转速进行连续控制，使风电机组在各个风速段的转矩平滑，不出现调变，最大限度的适应风电剧组的机械特性。 风速一定,风电系统运行在最大功率点时发电机输出的电磁转矩称为最优转矩。若已知最优风机转速—转矩曲线,通过转矩闭环控制,使得发电机电磁转矩实时跟踪此最优曲线,对应系统运行在最大风能捕获点，虽然避免了风速的检测，但是需要风机转速信息;需要知道最优转矩曲线,而最佳转矩曲线由风机厂家的实验数据拟合而成,它会随环境因素而变化,这限制了控制精度;还需已知发电机电磁转矩值,若增加转矩传感器,将导致系统成本显著增加,若由转矩公式求得该信息,则该方法将会对电机参数有很强的依赖性。 最后 — 仿真比较了一下，最优控制还是优于查表的。
参考文献-风力发电机组的控制技术 –叶杭冶
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdd92a68d5e536e8a781c1ed600094a2/" rel="bookmark">
			HTTP状态码(HTTP Status Code)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTTP状态码(HTTP Status Code) 是当我们访问网页服务器，服务器做出相应的状态的3位数的数字代码。主要包括“1xx”（消息）、“2xx”（成功）、“3xx”（重定向）、“4xx”（请求错误）和“5xx”或“6xx”（服务器错误）五种不同类型。
比较常见的状态码有： HTTP: Status 200 – 服务器成功返回网页 HTTP: Status 404 – 请求的网页不存在 HTTP: Status 503 – 服务不可用
一、“1xx”（消息）(临时响应)： 属于临时相应，代表所发出的请求已经被接受，需要继续进行处理。只包含状态行和某些可选的响应头信息，并以空行结束。由于 HTTP/1.0 协议中没有定义任何 1xx 状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送 1xx 响应。
1、“100 Continue”（继续）： –&gt;表示临时响应并需要请求者继续执行操作的状态代码。 2、“101 Switching Protocols”(切换协议)： –&gt;请求者已要求服务器切换协议，服务器已确认并准备切换。 3、“102 Processing”： –&gt;由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。
二、“2xx”（成功）： 表示成功处理了请求的状态代码;
1、“200 OK”(成功)： –&gt; 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 2、“201 Created”(已创建)： –&gt;请求成功并且服务器创建了新的资源。 3、“202 Accepted”(已接受)： –&gt;服务器已接受请求，但尚未处理。 4、“203 Non-Authoritative Information”(非授权信息): –&gt;服务器已成功处理了请求，但返回的信息可能来自另一来源。 5、“204 No Content”(无内容)： –&gt;服务器成功处理了请求，但没有返回任何内容。 6、“205 Reset Content”(重置内容)： –&gt; 服务器成功处理了请求，但没有返回任何内容。 7、“206 Partial Content”(部分内容)： –&gt;服务器成功处理了部分 GET 请求。 8、“207 Multi-Status”： –&gt;由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bdd92a68d5e536e8a781c1ed600094a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8f8d2e17adba5eda1414e8c7241c97b/" rel="bookmark">
			分别使用sk-learn和mllib进行文本情感分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总体思路 文本预处理提取特征特征选择选择分类算法训练和评估 预处理 包括分句、分词和词干化，使用nltk可以实现。
实现分两个版本：1. scikit-learn版本 2. MLLIB版本 主要是因为运行效率的问题，基于spark的mllib采用分布式的训练算法，速度快很多。
特征提取 tf-idf是基本的文本分类特征提取方法，它是词袋模型的一个信息量衡量方式，也是常用的基准方法。本文就是用tf-idf来构建文本特征，后面会提到使用word2vec进行改进。
scikit-learn特征提取 sklearn库提供tf-idf类，很方便就可以将文本转为向量，还可以定义许多参数，如ngram、最小df、停用词、分词器等
stopword_list = ["it", "this"] # example vectorizer = TfidfVectorizer(min_df=2, ngram_range=（1，2）, stop_words=stopword_list) X = vectorizer.fit_transform(corpus).toarray() mllib特征提取 mllib上许多api都仿照sklearn，所以对sklearn熟悉的人都很容易上手。在这里，我们使用Python语言进行Spark(1.4.1)代码的编写。
from pyspark import SparkContext from pyspark.mllib.feature import HashingTF sc = SparkContext() # Load documents (one per line). documents = sc.textFile("...").map(lambda line: line.split(" ")) hashingTF = HashingTF() tf = hashingTF.transform(documents) from pyspark.mllib.feature import IDF tf.cache() idf = IDF(minDocFreq=2).fit(tf) tfidf = idf.transform(tf) 特征选择 好的特征选择方式能够减少特征的数量，提高训练的效率和分类效果。 对于文本向量来说，未进行特征选择的向量维度为 ∥V∥ ，一般为数万维，这对于一些分类器来说，无疑是灾难，训练时间久又不见得效果好。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8f8d2e17adba5eda1414e8c7241c97b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ad0a372a752e41aa4e732dc409953a4/" rel="bookmark">
			Android全局异常捕获并弹窗提示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android 难免有崩溃的时候，但是崩溃了该如何处理呢？虽然那天有位同仁说 “既然崩溃了，用户体验就差了，心里会想这是毛APP，下次也不想用了” ，所以检查BUG以防崩溃是必须的，但是也需要一个后备方案，崩溃了能友好些，我们也能收集一些崩溃的信息。 说到全局捕获异常的UncaughtExceptionHandler，就不得不说期间遇到的各种坑： 1. 初始化肯定在Application，网上说的Activity启各种不认同。但在Application启就存在不能弹AlertDialog的问题（目前不确定，不知道是自己哪里没处理好还是的确是这个问题，有时间再验证一下） 2. 崩溃不一定是单次，在多层Activity中，崩溃一个顶层的Activity可能导致下层的Activity连续崩溃，所以uncaughtException可能会捕获到多次崩溃信息（具体影响后面会说到） 先来张崩溃后的效果图： 背景是另一个APP，当前的APP已崩溃并弹出该提示 实现流程： 写个类继承于UncaughtExceptionHandler，实现方法 @Override public void uncaughtException(Thread thread, Throwable ex) { if (!handleException(ex) &amp;&amp; mDefaultHandler != null) { // 如果用户没有处理则让系统默认的异常处理器来处 mDefaultHandler.uncaughtException(thread, ex); } else { // 跳转到崩溃提示Activity Intent intent = new Intent(mContext, CrashDialog.class); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); mContext.startActivity(intent); System.exit(0);// 关闭已奔溃的app进程 } } 然后转handleException方法处理异常： private boolean handleException(Throwable ex) { if (ex == null) { return false; } // 收集错误信息 getCrashInfo(ex); return true; } 上面的代码很清楚了，如果异常被捕获到并且异常信息不会NULL，处理完则跳转到CrashDialog。为什么跳Activity用Dialog样式，而不直接弹AlertDialog，是因为的确弹不出来。 收集错误信息： private void getCrashInfo(Throwable ex) { Writer writer = new StringWriter(); PrintWriter printWriter = new PrintWriter(writer); ex.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ad0a372a752e41aa4e732dc409953a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a52725e93b59e68190ba8f66d4a16f1/" rel="bookmark">
			【网络知识点】网络基本架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近都在整理系统相关知识，网络方面的知识还没有开始整理，但赶紧网络这分类有点空，今天就分享一下网络的基础知识--网络基本架构
网络基本架构算是最最最基础的知识点，对于这个基本架构，叫法可能有出入，但大致的划分层次是走不掉的，理解这个基本架构是学习网络的前提。
全球视图：
其中：WAN：广域网，在这里代表一个国家级区域。LAN：局域网，在这里代表一个城市级区域
国家视图：
其中：ISP代表网络服务提供商，用户通过其接入网络，ISP也有分级。
机房视图（核心视图，运维的主要视图）：
解读：
接入层（二层交换机）：
接入层通常指网络中直接面向用户连接或访问的部分。接入层目的是允许终端用户连接到网络，因此接入层交换机具有低成本和高端口密度特性
在核心层和汇聚层的设计中主要考虑的是网络性能和功能性要高
接入层由无线网卡、AP和L2Switch组成，按照宽带网络的定义，接入层的主要功能是完成用户流量的接入和隔离。对于无线局域网WLAN用户，用户终端通过无线网卡和无线接入点AP完成用户接入
汇聚层（二层交换机，三层交换机或堆叠式交换机）：
一般来说，用户访问控制会安排在接入层，但这并非绝对，也可以安排在汇聚层进行。在汇聚层实现安全控制和身份认证时，采用的是集中式的管理模式。当网络规模较大时，可以设计综合安全管理策略，例如在接入层实现身份认证和MAC地址绑定，在汇聚层实现流量控制和访问权限约束。
为接入层提供数据的汇聚\传输\管理\分发处理.汇聚层为接入层提供基于策略的连接,如地址合并,协议过滤,路由服务,认证管理等.通过网段划分(如VLAN)与网络隔离可以防止某些网段的问题蔓延和影响到核心层.汇聚层同时也可以提供接入层虚拟网之间的互连,控制和限制接入层对核心层的访问,保证核心层的安全和稳定
汇聚层交换机与接入层交换机比较，需要更高的性能，更少的接口和更高的交换速率
核心层（三层交换机，路由器）：
核心层的功能主要是实现骨干网络之间的优化传输
主要目的在于通过高速转发通信，提供优化，可靠的骨干传输结构，因此核心层交换机应拥有更高的可靠性，性能和吞吐量
骨干层（路由器，ISP）：
高传输性
PS：本文图均转自拼客科技。
转载于:https://blog.51cto.com/vrfxie/1882237
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/caa6684051e4566fdaabb69604c85c8a/" rel="bookmark">
			电脑设置了计算机管理员密码但是密码忘了怎么办？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种方法： 一般的XP安装光盘里都带破解管理员密码 找张安装盘进入修改一下管理员密码就可以了 第二种方法： 1.xp启动按F8 出现选项后选择“带命令的安全模式” 2.1分钟左右跳出安全模式下的登陆用户：选“Administrator”跳出COMMAND PROMPT窗口。 3.增加用户命令；在窗口输入：net user aaa /add(这个“aaa”是你要增加的用户名可任取) 4.增加管理员权限；在窗口输入：net localgroup administrators .aaa /add 5.重新启动XP，用户名就为：aaa 登陆进去（没有密码） 第三种方法： .xp启动按F8 出现选项后选择“带命令的安全模式” 输入C:\WINDOWS\system32\config 找到里边的 sam文件 删除即可 重新启动XP 密码为空
或者 拆开电脑主机然后进行CMOS放电,10分钟后重新装上即可使系统忘记密码
又或者 开机后，按下F8进入”带命令提示符的安全”模式，输入”NET USER+用户名+123456/ADD”可把某用户的密码强行设置为”123456″
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a956c1b896e886308de0c6fdb57ca67/" rel="bookmark">
			请查资料了解这些术语：/dev/hda, /dev/hdb, /dev/sda, /dev/sdb, 他们之间有什么区别？...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 请查资料了解这些术语：/dev/hda, /dev/hdb, /dev/sda, /dev/sdb, 他们之间有什么区别？
答：hda一般是指IDE接口的硬盘，hda指第一块硬盘，hdb指第二块硬盘,等等；sda一般是指SATA接口的硬盘，sda指第一块硬盘，sdb指第二块硬盘，等等。
2. 为什么 du -b /etc/passwd 和 du -k /etc/passwd 所得到的结果不一致呢？按道理讲1024b 等于 1k 阿铭的 /etc/passwd 为 1181b 而 使用k为单位表示它竟然是 4k. 答：du -b显示的是文件的实际大小；du -k显示的是文件所占磁盘块的大小，du不带参数默认是显示块的大小。一个块大小为4KB，一个块只能存放一个文件，小于4KB的文件占用一个块的大小，大于4KB的文件占用多个块，大小为4KB的整数倍。/etc/passwd大小为1181b，小于4KB，所以使用du 或者du -k显示大小为4KB。
3. 请查资料，了解磁盘的这些概念： heads, sectors, cylinders.
答：硬盘划分为磁头（Heads）、柱面(Cylinder)、扇区(Sector)。
磁头(Heads)：每张磁片的正反两面各有一个磁头，一个磁头对应一张磁片的一个面。因此，用第几磁头就可以表示数据在哪个磁面。
柱面(Cylinder)：所有磁片中半径相同的同心磁道构成“柱面"，意思是这一系列的磁道垂直叠在一起，就形成一个柱面的形状。简单地理解，柱面就是磁道。
扇区(Sector)：将磁道划分为若干个小的区段，就是扇区。虽然很小，但实际是一个扇子的形状，故称为扇区。每个扇区的容量为512字节。
硬盘容量＝磁头数×柱面数×扇区数×512字节。
4. 请计算磁盘分区的时候，每一个柱面空间是多大？ 阿铭的第二块磁盘是8589 MB （8589934592 bytes），总共有1044个柱面。
答：柱面空间=磁盘容量/柱面数=8589934592/1044=8227906bytes
5. 查资料了解ide和scsi接口的磁盘有什么不一样，scsi 磁盘(sda, sdb）最多可以分多少个逻辑分区（这个了解即可）？
答： IDE(Intergrated Device Electronics，电子集成驱动器)一般是有扁平电缆连接的，一个扁平电缆可以连接2个IDE硬盘，而一个计算机一般提供2个扁平电缆，所以一般允许4块IDE硬盘。IDE经过多年的发展，成熟，廉价，稳定。一般老式的电脑中装的都是这种硬盘。目前主流的硬板已经是SATA硬盘了。IDE是平行传输的，而SATA是串行传输的。
SCSI(Small Computer System Interface:小型计算机系统接口)的出现主要是由于原有IDE接口的硬盘转速比较低，传输效率比较慢。由于SCSI硬盘独立于系统总线工作，所以它的最大优点就在于系统的占用率低，当然它还有一些优点，转速高，传输速率快，更稳定。但也有一些缺点，价格高，安装没有IDE方便。
一块SCSI硬盘最大分区只能分三个主分区加一个扩展分区, 而扩展分区最多可分15个逻辑分区, 这是硬件限制，不能突破。
6. 把磁盘格式化成ext4文件系统时，如果指定块大小并不是 1024 2048 4096 会发生什么？指定块大小最小是多少，最大又是多少？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a956c1b896e886308de0c6fdb57ca67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2c15c19c8b94ab2ed224229e66dfb49/" rel="bookmark">
			压力测试就是一种破坏性的性能测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对性能测试、负载测试和强度测试比较混淆。没错，这三个概念是比较容易使人糊涂。负载测试和强度测试，都属于性能测试的子集。下面举个跑步的例子进行解释。
性能测试，表示在一个给定的基准下，能执行的最好情况。例如，在没有负重的情况下，你跑100米需要花多少时间（这边，没有负重是基准）？
负载测试，也是性能测试，但是他是在不同的负载下的。对于刚才那个例子，如果扩展为：在50公斤、100公斤……等情况下，你跑100米需要花多少时间？
强度测试，是在强度情况下的性能测试。对于刚才那个例子，如果改为：在一阵强风的情况下，你在负重或没有负重的情况下，跑100米需要花多少时间？
性能测试（或称多用户并发性能测试）、负载测试、强度测试、容量测试是性能测试领域里的几个方面，但是概念很容易混淆。下面将几个概念进行介绍。
性能测试（PerformanceTest）：通常收集所有和测试有关的所有性能，通常被不同人在不同场合下进行使用。
关注点：howmuch和howfast
负载测试（LoadTest）：负载测试是一种性能测试，指数据在超负荷环境中运行，程序是否能够承担。
关注点：howmuch
强度测试（StressTest）：强度测试是一种性能测试，他在系统资源特别低的情况下软件系统运行情况，目的是找到系统在哪里失效以及如何失效的地方。包括 Spiketesting：短时间的极端负载测试
Extremetesting：在过量用户下的负载测试
Hammertesting：连续执行所有能做的操作
容量测试(VolumeTest)：确定系统可处理同时在线的最大用户数
关注点：howmuch（而不是howfast）
容量测试，通常和数据库有关，容量和负载的区别在于：容量关注的是大容量，而不需要表现实际的使用。
其中，容量测试、负载测试、强度测试的英文解释为：
VolumeTesting=Largeamountsofdata
LoadTesting=Largeamountofusers
StressTesting=Toomanyusers,toomuchdata,toolittletimeandtoolittleroom
性能测试是动力，负载测试载重，压力测试强度
压力测试stresstest是在一定的负荷条件下，长时间连续运行系统给系统性能造成的影响。
负载测试Loadtest：在一定的工作负荷下，给系统造成的负荷及系统响应的时间。
压力测试主要是为了发现在一（任意）定条件下软件系统的性能的变化情况，通过改变应用程序的输入以对应用程序施加越来越大的负载（并发，循环操作，多用户）并测量在这些不同的输入时性能的改变，也就是通常说的概念：压力测试考察当前软硬件环境下系统所能承受的最大负荷并帮助找出系统瓶颈所在。其实这种测试也可以称为负载测试，但是负载测试通常描述一种特定类型的压力测试——增加用户数量以对应用程序进行压力测试。比如实际中我们说从比较小的负载开始，逐渐增加模拟用户的数量，直到应用程序响应时间超时，就是说的负载测试。
压力测试的目标是测试在一定的负载下系统长时间运行的稳定性，尤其关注大业务量情况下长时间运行系统性能的变化（例如是否反应变慢、是否会内存泄漏导致系统逐渐崩溃、是否能恢复）；压力测试是测试系统的限制和故障恢复能力，它包括两种情况：
稳定性压力测试：在选定的压力值下，长时间持续运行。通过这类压力测试，可以考察各项性能指标是否在指定范围内，有无内存泄漏、有无功能性故障等；
破坏性压力测试：在稳定性压力测试中可能会出现一些问题，如系统性能明显降低，但很难暴露出其真实的原因。通过破坏性不断加压的手段，往往能快速造成系统的崩溃或让问题明显的暴露出来；
负载测试的目标是测试在一定负载情况下系统性能（不关注稳定性，也就是说不关注长时间运行，只是得到不同负载下相关性能指标即可）；实际中我们常从比较小的负载开始，逐渐增加模拟用户的数量（增加负载），观察不同负载下应用程序响应时间、所耗资源，直到超时或关键资源耗尽，这就是所说的负载测试，它是测试系统的不同负载情况下的性能指标。
——————————————————————————————
最简单来说：
负载测试是测试软件本身最大所能承受的性能测试；
压力测试就是一种破坏性的性能测试；
只要理解这两点区别，就非常好理解性能测试了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8968c20ce23a18e6fa314dc6b39fd741/" rel="bookmark">
			JQuery Ajax动态加载Table数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在jsp定义一个select和一个table，要求实现根据select的选值，动态加载table数据。
&lt;select id="type" name="type" onchange="reloadTable(this)"&gt;&lt;/select&gt; &lt;table id="import-table" class="table table-striped table-bordered table-hover" width="100%"&gt;&lt;/table&gt; table第一次加载数据的function定义如下：
function loadData() { var c = '&lt;label&gt;&lt;input type="checkbox" id="checkbox1" class="ace" onchange="javascrpt:selectAll(this);"/&gt;&lt;span class="lbl"&gt;&lt;/span&gt;&lt;/label&gt;'; $('#import-table').DataTable({ ajax: { url: '&lt;%=request.getContextPath()%&gt;' + "../../../hot/getByCode.action?code=APP", type: "post", dataType: "json", data: {} }, "scrollCollapse": true, ordering: false, visible: true, api: true, serverSide: true, columns: [{ "data": "id", "class": "center", "width": "80px", "name": "importId", orderable: false, "title": c, "render": function(a, b, c, d) { return getColumnReturnStr("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8968c20ce23a18e6fa314dc6b39fd741/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4296acf242e6931e7b7cb573035c16a6/" rel="bookmark">
			从PHP5到PHP7的注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址：https://www.phpxy.com/article/25.html
PHP7是大势所趋了。PHP7有更多的新特性，更好的性能，更高的速度。并且，从今年8月7日开始发行PHP7.0的beta3 即将发布的PHP7 的RC1版本。脚步越来越近，有更多的人来学习PHP7的新特性。PHP学院将对PHP7的新特性进行连载。
并且，现在国内PHPer中喜欢尝新鲜的人一些人，已经安装好了PHP7。我们来看看PHP7 到底有哪些新特性。
今天我们来讲解的是PHP提倡的一些风格，并且将原有PHP4当中的一些风格进行了禁用。
1，PHP5发行的时候为了讨好ASP程序员，PHP准备了asp_tags全部被禁止
在未来没有&lt;% %&gt; 这种风格，PHP也不再支持这种风格的声明。
&lt;script language="php"&gt;&lt;/script&gt;
2，PHP4的语法风格中的一些东西将被，例如构造函数的用法，会在新的PHP7中完全被抛弃。PHP7将会提示一个： E_DEPRECATED的错误提示。
&lt;?php
class foo {
//方法名类名相同的构造函数的用法不再兼容 function foo() { echo 'I am the constructor'; } } ?&gt;
1. define定义常量不仅仅只支持标量，还支持了数组
&lt;?php define('PHPXY', array( '凤姐', '芙蓉姐姐', '杨幂是臭脚' )); echo PHPXY[1]; // 输出的结果是“芙蓉姐姐” ?&gt;
2.比较的时候支持&lt;=&gt; 可以比较字符串，数组，整型。
&lt;?php // Integers echo 1 &lt;=&gt; 1; // 0 echo 1 &lt;=&gt; 2; // -1 echo 2 &lt;=&gt; 1; // 1 PHP学院评：我们认为实际用户不大，在实际工作中使用量不会很高
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4296acf242e6931e7b7cb573035c16a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfb021c1099314ec43df30a17265575a/" rel="bookmark">
			maven 生成webservice客户端代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt; &lt;artifactId&gt;cxf-rt-frontend-jaxws&lt;/artifactId&gt; &lt;version&gt;${cxf.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt; &lt;artifactId&gt;cxf-rt-transports-http&lt;/artifactId&gt; &lt;version&gt;${cxf.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt; &lt;artifactId&gt;cxf-rt-transports-http-jetty&lt;/artifactId&gt; &lt;version&gt;${cxf.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-webapp&lt;/artifactId&gt; &lt;version&gt;8.1.11.v20130520&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;cxf-date&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt; &lt;artifactId&gt;cxf-codegen-plugin&lt;/artifactId&gt; &lt;version&gt;${cxf.version}&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;generate-sources&lt;/id&gt; &lt;phase&gt;generate-sources&lt;/phase&gt; &lt;configuration&gt; &lt;sourceRoot&gt;src/main/resources/cxf&lt;/sourceRoot&gt;&lt;!--就是生成文件存放的位置；可用这个表示项目路径，和下面的extraarg的包路径相结合${project.build.sourceDirectory}--&gt; &lt;wsdlOptions&gt; &lt;wsdlOption&gt; &lt;wsdl&gt;***?wsdl&lt;/wsdl&gt; &lt;frontEnd&gt;jaxws21&lt;/frontEnd&gt; &lt;faultSerialVersionUID&gt;1&lt;/faultSerialVersionUID&gt; &lt;extraargs&gt; &lt;extraarg&gt;-impl&lt;/extraarg&gt; &lt;extraarg&gt;-client&lt;/extraarg&gt; &lt;extraarg&gt;-p&lt;/extraarg&gt; &lt;!--这里为webservice的包指定到项目里的包目录--&gt; &lt;extraarg&gt; http://www.opentravel.org/OTA/2003/05=com.test.ws.a &lt;/extraarg&gt; &lt;extraarg&gt;-p&lt;/extraarg&gt; &lt;extraarg&gt; http://htng.org/2014B=com.test.ws.b &lt;/extraarg&gt; &lt;/extraargs&gt; &lt;/wsdlOption&gt; &lt;/wsdlOptions&gt; &lt;/configuration&gt; &lt;goals&gt; &lt;goal&gt;wsdl2java&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fdc217e38f9d162c43eef419d556caa/" rel="bookmark">
			Netstat 命令详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：http://www.cnblogs.com/ggjucheng/archive/2012/01/08/2316661.html
参考：http://www.jb51.net/LINUXjishu/152405.html
netstat 命令：http://man.linuxde.net/netstat
Netstat 用于显示与 IP、TCP、UDP 和 ICMP 协议相关的统计数据，一般用于检验本机各端口的网络连接情况。如果你的计算机有时候接收到的数据报导致出错数据或故障，你不必感到奇怪，TCP/IP可以容许这些类型的错误，并能够自动重发数据报。但如果累计的出错情况数目占到所接收的IP数据报相当大的百分比，或者它的数目正迅速增加，那么你就应该使用 Netstat 查一查为什么会出现这些情况了。
在 windows下有个小工具挺好的，TCPView。当然如果要详细分析数据包，可选用 sniffer、Wireshark 等更强大的工具。
1. 网络连接状态详解 共有 12 中可能的状态，前面11种是按照 TCP 连接建立的三次握手和 TCP 连接断开的四次挥手过程来描述的。
1)、LISTEN:首先服务端需要打开一个socket进行监听，状态为LISTEN. /* The socket is listening for incoming connections. 侦听来自远方TCP端口的连接请求 */ 2)、SYN_SENT:客户端通过应用程序调用connect进行active open.于是客户端tcp发送一个SYN以请求建立一个连接.之后状态置为SYN_SENT. /*The socket is actively attempting to establish a connection. 在发送连接请求后等待匹配的连接请求 */ 3)、SYN_RECV:服务端应发出ACK确认客户端的 SYN,同时自己向客户端发送一个SYN. 之后状态置为SYN_RECV /* A connection request has been received from the network. 在收到和发送一个连接请求后等待对连接请求的确认 */ 4)、ESTABLISHED: 代表一个打开的连接，双方可以进行或已经在数据交互了。 /* The socket has an established connection.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fdc217e38f9d162c43eef419d556caa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ea79b751c261d7a8dce1207eeb0cda5/" rel="bookmark">
			图片瀑布流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery-2.2.3.min.js"&gt; &lt;/script&gt; &lt;style type="text/css"&gt; * { margin: 0; padding: 0; } #flow { list-style: none; margin: 0 auto; position: relative; } #flow li { position: absolute; width: 200px; transition: all 0.5s; overflow: hidden; } #flow li img { width: 100%; float: left; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul id="flow"&gt;&lt;/ul&gt; &lt;script type="text/javascript"&gt; $(function() { //高度数组，保存每个li的高度 var hs = []; var lis = []; //布局函数 //当我bol为假时，更新的数组 //创建或者更新li for(var i = 2; i &lt; 41; i++) { var li = $("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ea79b751c261d7a8dce1207eeb0cda5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26cacea62cdae3ac5c54f87cfc615ecf/" rel="bookmark">
			UVA	1380 A Scheduling Problem
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目链接:https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=4126
$LRJ$紫书例题$9-26$
题目大意:
给定一颗树 有些边已经标好方向 现在要给其余的边标上方向 使得最长的有向链最短
$HIT:$ 题目额外给了一个结论 假设已经确定方向的边所能得到的最长链为$k$ 最后的最长链一定$k$ 或$k + 1$
不知道是自己太久没有写树形$DP$还是这题的确比较麻烦 花了好久才折腾出来
首先 利用题目给的结论 我们实际上只需要解决以下这个几乎等价的问题
判断所给的树是否可以构造出最长链不超过$k$的方案
如果是的 那么最长链就是$k$否则为$k + 1$
对于这个可行解问题 我们可以这样考虑
对于每颗子树的最长链 它要么经过这颗子树的根节点 要么在这个根节点的某个儿子所对应的子树中
因此只需递归地去检验每颗子树是否合法即可
我们可以建立三个数组 $f[x][y]$ $up[x]$ $down[x]$
$f[x][y]$代表 到达该根节点$x$的向上的最长链最小值为$y$时向下的最长链最小值为多少
$up[x]$ $down[x]$分别代表该根节点向上/下的最长链的最小值
然后由于数据范围比较小 所以可以直接用这种$O(n^2)$的方法轻松解决
1 #include &lt;bits/stdc++.h&gt; 2 using namespace std; 3 const int N = 210, E = N &lt;&lt; 1; 4 int firste[N], nexte[E], v[E], w[E]; 5 int n, e, ans; 6 void build(int x, int y, int z) 7 { 8 nexte[++e] = firste[x]; 9 firste[x] = e; 10 v[e] = y; 11 w[e] = z; 12 } 13 void init(int uu) 14 { 15 int vv; 16 char ch; 17 n = 0; 18 e = 1; 19 memset(firste, 0, sizeof firste); 20 ans = 0; 21 do 22 { 23 n = max(n, uu); 24 while(scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26cacea62cdae3ac5c54f87cfc615ecf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffa9459f1a9df97bb80521a56b1106af/" rel="bookmark">
			负载均衡的几种实现方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 （1）HTTP重定向负载均衡。 这种负载均衡方案的优点是比较简单，缺点是浏览器需要每次请求两次服务器才能拿完成一次访问，性能较差。 （2）DNS域名解析负载均衡。 DNS域名解析负载均衡的优点是将负载均衡工作交给DNS，省略掉了网络管理的麻烦，缺点就是DNS可能缓存A记录，不受网站控制。 （3）反向代理负载均衡。 优点是部署简单，缺点是反向代理服务器是所有请求和响应的中转站，其性能可能会成为瓶颈。 （4）IP负载均衡。 优点：IP负载均衡在内核进程完成数据分发，较反向代理均衡有更好的处理性能。缺点：负载均衡的网卡带宽成为系统的瓶颈。 （5）数据链路层负载均衡。 避免负载均衡服务器网卡带宽成为瓶颈，是目前大型网站所使用的最广的一种负载均衡手段。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d520ae821b986015abced8164a45a922/" rel="bookmark">
			第十二周利用参数宏进行角度与弧度转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		﻿﻿ 题目描述 定义参数宏AngleToRadian(degree,minute,second)，将度(degree)、分(minute)、秒(second)转换为弧度。（#define PI 3.14159）
#include &lt;stdio.h&gt;
#define PI 3.14159
/**********/
在此补充缺少的代码
/**********/
int main()
{
double degree,minute,second;
scanf("%lf %lf %lf",&amp;degree,&amp;minute,&amp;second);
printf("%f",AngleToRadian(degree,minute,second)); /*参数宏会被替换为定义的表达式，算出结果后输出*/
return 0;
}
输入 度，分，秒
输出 转换后的弧度
样例输入 180 0 0 样例输出 3.141590 解答： #include &lt;stdio.h&gt; #define PI 3.14159 #define PI 3.14159 #define AngleToRadian(d,m,s) ((d) + ((m)+(s)/60)/60)/180*PI int main() { double degree,minute,second; scanf("%lf %lf %lf",°ree,&amp;minute,&amp;second); printf("%f",AngleToRadian(degree,minute,second)); return 0; }
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f5804b9592e7d5c02aeaff900289bc5/" rel="bookmark">
			win2003 序列号 windows2003 sp2可用序列号大全（准版与企业版)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通用性好的win2003序列号: (推荐先用这个里面的)
FJ8DH-TQPYG-9KFHQ-88CB2-Y7V3Y
GRD4P-FTQQF-JCDM8-4P6JK-PFG7M
JD7JX-KCDTH-7WH4X-DM98R-GD73Y
GM34K-RCRKY-CRY4R-TMCMW-DMDHM
BRBJB-B7HQF-YW93Y-RVJVB-K6PMB
F9389-7TWW4-88YYH-RKPFJ-6PV3Y
F947R-VPGDF-RTDK7-WTMBY-PP67M
D4Q7H-MPPR2-23PMH-HQGBG-6X8YB
KW8GQ-DJH7F-6XH6Y-WG3BH-FK8YB
DG473-GKX4K-XVPDY-FCCWH-29G7M
DKDT4-PFCVX-FJ4CR-7W9D6-C7JYB
GPTJB-VMDRP-XCG6H-KGW32-8KMQY
J47YP-KMK8W-FR76X-KFVB6-FJ3HM
KPM7R-RY44D-PVQYG-JFRH9-WKG7M
FMQBH-FRQWB-DRF3T-VT2JF-WR8YB
CMPC2-HBVHC-73BD6-V6PG2-BYH3Y
HXGJH-3J4GY-JMCJQ-DK4MW-99TBB
Windows2003的序列号：
JB88F-WT2Q3-DPXTT-Y8GHG-7YYQY
windows2003序列号：
cky24-q8qrh-x3kmr-c6bcy-t847y
win2003 Server 有三种版本：
win2003 Enterprise Edition 企业版: JCB3T-9CDQ4-K2X38-2HXRB-VX8YB
win2003 Standard Edition 标准版: M6RJ9-TBJH3-9DDXM-4VX9Q-K8M8M
win2003 Web Edition Web版: D42X8-7MWXD-M4B76-MKYP7-CW9FD
win2003 Server 有三种版本 sp2测试可以使用：
win2003 Enterprise Edition 企业版: JCB3T-9CDQ4-K2X38-2HXRB-VX8YB
win2003 Standard Edition 标准版: M6RJ9-TBJH3-9DDXM-4VX9Q-K8M8M
win2003 Web Edition Web版: D42X8-7MWXD-M4B76-MKYP7-CW9FD
Windows2003的序列号(经典的老版本可以使用)：
JB88F-WT2Q3-DPXTT-Y8GHG-7YYQY
windows2003序列号：
cky24-q8qrh-x3kmr-c6bcy-t847y
Windows2003 正版可升级序列号(以下序列号不一定适合所有版本)
JCHGT-JHGW9-7BFRX-R8CQR-JHFDY
JCFKX-6YKVP-HWH4D-W7234-B9MQY
JCDW4-7QB3C-7PGKV-JV7FQ-PB9VM
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f5804b9592e7d5c02aeaff900289bc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9578ac3cf954b18c82a75c74d7edfbc6/" rel="bookmark">
			POJ 1043 What&#39;s In A Name? 已被翻译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf34b2eff5cd419f6bb47c2172111e06/" rel="bookmark">
			如何让写代码更加智能一点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; 对的，就是速度，你可以使用各种方法来加快你写代码的速度，
电脑就是个人机交互的工具，你可以大量的使用输入法，自动补全，甚至语音识别，来更好的人机交互，
为了解放，解放生产力，
学习一门语言，了解其本质，要解决的是什么问题就好了，语法只是个通讯协议， 更好的让计算机理解你的思想而已。
次郎　2016-12-06 17:00:00
转载于:https://my.oschina.net/innovation/blog/800240
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9baf0c47ca95de3b51a59acc251cfff7/" rel="bookmark">
			ThinkPad 触控板双指不可以滑动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		是因为没有装驱动。 http://think.lenovo.com.cn/support/driver/newdriversdownlist.aspx?yt=pt&amp;categoryid=12357&amp;CODEName=ThinkPad%20T460p&amp;wherePage=2&amp;SearchType=0
联想thinkpad驱动的官网，你可以在里面选择你电脑对应的驱动。
选择鼠标的驱动 ，下载安装之后重启。 然后你发现就可以双指滑动了。
如果你不想要触摸板生效，那么在控制面板里面找到鼠标， 然后如图，取消勾选启用TouchPad
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3823c6d9405e7957e09a0ee1ce3478ae/" rel="bookmark">
			关于hibernateProperties配置中hibernate.hbm2ddl.auto参数的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 hibernate.hbm2ddl.auto参数主要用于： 自动创建|更新|验证数据库表结构。如果不是此方面的需求建议set value="none"。 create： 每次加载hibernate时都会删除上一次的生成的表，然后根据你的model类再重新来生成新表，
哪怕两次没有任何改变也要这样执行，这就是导致数据库表数据丢失的一个重要原因。 create-drop ： 每次加载hibernate时根据model类生成表，但是sessionFactory一关闭,表就自动删除。
update(***)： 最常用的属性，第一次加载hibernate时根据model类会自动建立起表的结构（前提是先建立好数据库），
以后加载hibernate时根据 model类自动更新表结构，即使表结构改变了但表中的行仍然存在不会删除以前的行。
要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等 应用第一次运行起来后才会。 validate ： 每次加载hibernate时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2569be5fb8c26040616c4ac27d79380/" rel="bookmark">
			Android Studio查看一个页面的布局层次结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AS提供了一个工具，可以查看手机里任意一个页面的布局层次结构。很好用，这样就可以看大牛app是怎样写布局了。
Tool--Android--Android Device Monitor打开DDMS窗口，USB数据线连接手机（保持手机长亮），选中设备，点击dump-view-hirerchy for UI automator,如图：
打开你想要分析的页面，点击图中按钮后，确保手机屏幕亮着，一会就回看到手机当前页面的布局层次结构图了。数遍点击哪里就回显示选中view的详细信息，如图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4031d2202fa8f18a52e212667c9fb3c3/" rel="bookmark">
			心理调整
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在新公司工作近2个月，还没适应节奏和大公司的沉重流程。占空，有时间写下 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16dd650770c37145b75f6dfb1d1e6efd/" rel="bookmark">
			android lcm驱动解读及调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		lcm驱动的源代码解读 在我们调屏之前，我们一定要弄懂源代码框架以及每一行代码代表的意思，那么就让我们首先来看看代码（以ili9806e为例） 1 #if defined(BUILD_LK) 2 #include &lt;string.h&gt; 3 #else 4 #include &lt;linux/string.h&gt; 5 #endif 6 7 #ifdef BUILD_LK 8 #include &lt;platform/disp_drv_platform.h&gt; 9 10 #elif defined(BUILD_UBOOT) 11 #include &lt;asm/arch/mt_gpio.h&gt; 12 #else 13 //#include &lt;linux/delay.h&gt; 14 #include &lt;mach/mt_gpio.h&gt; 15 #endif 16 #include &lt;cust_gpio_usage.h&gt; 17 18 #include "lcm_drv.h" 19 20 22 // -------------------------------------------------------------------- 23 // Local Constants 24 // --------------------------------------------------------------------- 25 26 #define FRAME_WIDTH (480) 27 #define FRAME_HEIGHT (800) 28 29 #define REGFLAG_DELAY 0xFD 30 #define REGFLAG_END_OF_TABLE 0xFE // END OF REGISTERS MARKER 31 32 #define LCM_DSI_CMD_MODE 0 33 34 35 #ifndef TRUE 36 #define TRUE 1 37 #endif 38 39 #ifndef FALSE 40 #define FALSE 0 41 #endif 42 43 #define GPIO_LCM_ID GPIO18 44 #define LCM_TDT 0 45 46 bool lcm_ili9806e_vendor=LCM_TDT; //default to choose byd panel 47 48 49 //set LCM IC ID 50 #define LCM_ID_ILI9806E (0x980604) 51 52 #define LCM_DEBUG 53 54 55 56 // ---------------------------------------------------------------------- 57 // Local Variables 58 // ---------------------------------------------------------------------- 59 60 static LCM_UTIL_FUNCS lcm_util = {0}; 61 62 //复位引脚 63 #define SET_RESET_PIN(v) (lcm_util.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16dd650770c37145b75f6dfb1d1e6efd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04ac6a878064f7978980e531947d7e45/" rel="bookmark">
			破解 jar 包之直接修改 .class 文件方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、常规 JAVA 软件破解流程 先讲一下常规jar包的破解流程。
1. 快速定位。 1) 通过procmon监控相关软件，查看程序都访问了些啥。
2) 用jd-gui反编译 jar 包，得到源码。
3) 搜索关键字以定位。
这种定位方法只是千万种中的一种，根据不同软件的不同执行特性再具体实施不同的定位方案。
2. 修改破解。 1) 用 dex2jar 将 JAR 包转成 Dex 文件。
2) 再将 Dex 解出 Smali。
3) 修改 Smali 代码
4) 将修改后的文件重新打包回 Dex
5) 最后转成 JAR 包，破解完成。
二、直接修改 .class 字节码的方式实现破解 上面的方式基本已经可以解决破解JAR包的需求。但最近研究了一下直接修改.class 字节码的形式来实现修改程序流程的方法，总有会用得上的应用场景的。下面进入正题。
很多时候别人的 jar 包，反编译过来后是没办法直接用Eclipse创建java 工程再编译通过的。各种引用及反编译带来的错误会让人抓狂。既然破解的关键点已经找到了，我们可以不可以直接修改.class 字节码以实现破解呢，答案是肯定的。
此处省略定位环节，不是本文重点。
准备工具 1. jclasslib 源码地址：https://github.com/ingokegel/jclasslib
2. 010 Editor 神器不多说
参考资料 1. The class file format
https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.6
2. 中文版Class文件结构
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04ac6a878064f7978980e531947d7e45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc33d7382093b64a729ab6f904d87ac4/" rel="bookmark">
			Arduino 2.4G通信实验 nRF24L01模块的简单例子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nRF24L01是底价的2.4G无线传输实现，可以用来做遥控哦。
输出功率频道选择和协议的设置可以通过SPI 接口进行设置。
几乎可以连接到各种单片机芯片，并完成无线数据传送工作。
极低的电流消耗：当工作在发射模式下发射功率为0dBm 时电流消耗为11.3mA ，
接收模式时为12.3mA，掉电模式和待机模式下电流消耗更低。
性能参数编辑
◆ 小体积，QFN20 4x4mm封装
◆ 宽电压工作范围，1.9V~3.6V，输入引脚可承受5V电压输入
◆ 工作温度范围，-40℃～+80℃
◆ 工作频率范围，2.400GHz～2.525GHz
◆ 发射功率可选择为0dBm、-6dBm、-12dBm和-18dBm
◆ 数据传输速率支持1Mbps、2Mbps[1] ◆ 低功耗设计，接收时工作电流12.3mA，0dBm功率发射时11.3mA，掉电模式时仅为900nA
◆ 126个通讯通道，6个数据通道，满足多点通讯和调频需要
◆ 增强型“ShockBurst”工作模式，硬件的CRC校验和点对多点的地址控制
◆ 数据包每次可传输1～32Byte的数据
◆ 4线SPI通讯端口，通讯速率最高可达8Mbps，适合与各种MCU连接，编程简单
◆ 可通过软件设置工作频率、通讯地址、传输速率和数据包长度
◆ MCU可通过IRQ引脚快判断是否完成数据接收和数据发送
问题反馈 解决方法一： 有不少网友反馈接受端只显示0和1
由于我自己没有试过出现这问题，也不知道怎么回事，但总结了一下其中一网友的解决办法，供大家参考
解决方法二: 有网友再提供了一个解决方法，就是再
setup()函数里添加
Mirf.cePin = 9;
Mirf.csnPin = 10;
解决方法三：
由无名网友，折腾三周，心力交瘁下解决得出得方法，感谢网友提供
主要是库的冲突，可能mirf库不稳定，使用nf24库
库下载地址： https://github.com/nRF24/RF24
或者在Arduino IDE 的库管理器中搜索nrf24，作者为TMRh20
安装库后，有例程可参考。
再次实验，重新使用本章的代码，测试通过，没有问题。
但也会因由接线问题，硬件假货问题，库问题，故提供三个解决问题的方法，希望能对你有帮助，
再次感谢提供这些方法的网友。多多交流
实验效果 BOM表 Arduino Uno *2
nRF24L01 * 2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc33d7382093b64a729ab6f904d87ac4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1404d0307ec95b6f8fd0d44a1d4f37bc/" rel="bookmark">
			jquery easy ui中根据第一个下拉框框选中的值，设置第二个下拉框是否可以编辑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		例如“报告交付方式”包含固定交付时，第二个下拉框不可编辑，反之可以编辑，具体代码如下
报告交付方式：&lt;select class="easyui-combobox" panelHeight="auto" style="width:195px" data-options="required:true,valueField:'id',textField:'text'
,
onSelect:function(){
var varSelect = $('#WKBgjffs').combobox('getText'); if(varSelect=='固定交付 网络下载报告'||varSelect=='固定交付'||varSelect=='固定交付+网络下载报告')
{
$('#WKGdjfdz').combobox('enable'); //设置下拉框可编辑
} else if(varSelect!='固定交付 网络下载报告'&amp;&amp;varSelect!='固定交付'&amp;&amp;varSelect!='固定交付+网络下载报告'){ $('#WKGdjfdz').combobox('disable'); //设置下拉框不可编辑
}
}
" id=WKBgjffs&gt;
&lt;%=options_bgjffs%&gt;
&lt;/select&gt;&amp;nbsp;&amp;nbsp;
固定交付地址：&lt;select class="easyui-combobox" panelHeight="auto" style="width:450px" data-options="valueField:'id',textField:'text'" id="WKGdjfdz"&gt;
&lt;option value=""&gt;------ 无 ------&lt;/option&gt;
&lt;%=options_gdjfdz%&gt;
&lt;/select&gt;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49f6f4b7250641de3ae6c70a912c5f42/" rel="bookmark">
			JS 如何判断一个数字在某一个区间内
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		web翎云阁 2016-11-28 10:13 现在有两个数组：revenue和reward
如果收入大于350 小于 450 那么就奖励30
如果收入大于450小于550，就奖励50
要实现的效果跟Excel中的VlookUP函数比较像，怎么写最有效的判断语句。
第一种普通方法：
var revenue = [350,450,550,650,850,1000,1100,1250,1500];
var reward = [0,30,40,50,100,200,240,300,400];
/*
根据指定的值，在revenue查找第一个比它大的值，返回对应的索引，通过索引在reward获取对应的奖励
1：如果值小于revenue最小的值时，则奖励0。所以reward前被了个0
2：如果值大于revenue最大的值时，则奖励最高一档
***注意***
前提是：revenue为整型数组，且已经按照从小到大排好了序的
*/
function find(array,val){
//如果值小于revenue最小的值时，则奖励0
if(val &lt; Math.min.apply(null,array)){
return 0;
}
//如果值大于revenue最大的值时，则奖励最高一档
if(val &gt; Math.max.apply(null,array)){
return array.length-1;
}
var idx = 0,i = 0,j = array.length;
for(i;i&lt;j;i++){
if(array[i] &gt; val){
idx = i;
break;
};
};
return idx;
};
alert('奖励：'+reward[find(revenue,370)]);
第二种二分法：
var range = [350,450,550,650,850,1000,1100,1250,1500];
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49f6f4b7250641de3ae6c70a912c5f42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ae049d487aadfcb56241eb0aab6b9bc/" rel="bookmark">
			android studio build apk 出现大量AGPBI错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将eclipse工程导入android studio，rebuild project 成功，但是build apk出现大量AGPBI错误。在网上找了很多方法，有些说是由于android studio版本问题，于是升级到2.2，问题仍然存在。最后发现一个方法可行，在build.gradle文件中增加multiDexEnabled true
defaultConfig {
applicationId "***.***.***"
minSdkVersion 8
targetSdkVersion 17
multiDexEnabled true
}
在重新编译就能成功生成apk。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ef9aaed45b3444cea982b36874cb6e0/" rel="bookmark">
			Tomcat的配置及常见问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近练习web编程的时候，接触到了Tomcat服务器。就使用而言它非常简便且易掌握，但是新手如果在使用之前的配置上出问题可能就会非常头疼了。这里我简单记录一下关于Tomcat常见的两个配置问题及其解决方法。
（1）启动tomcat服务器，一闪就消失了
这通常是由于安装了jdk却没有配置环境变量JAVA_HOME导致的，只需要将JAVA_HOME配置一下，就能立刻解决了。
（2）Java.NET.BindException: Address already in use: JVM_Bind &lt;null&gt;:8080
这是端口冲突的问题，tomcat默认端口是8080，如果用户的电脑上8080端口已被占用，启动tomcat时就会出现此问题，此时需要对tomcat的启动端口进行一下配置。直接在tomcat的conf目录下，打开server.xml文件，即可进行端口修改。如下，将8080替换成其他端口即可。
&lt;Connector port="8080" protocol="HTTP/1.1"
connectionTimeout="20000"
redirectPort="8443" /&gt;
提示：使用tomcat过程中如果遇到问题却不知道原因时，可以打开cmd窗口，进入到启动tomcat文件所在的路径，执行文件，看到错误信息。如果能看懂即可直接根据问题去试着解决，看不懂也没关系，拿着错误信息上网搜索，你也可以很方便的找到解决办法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a585ea556de6907dc82a32f546d3c9d1/" rel="bookmark">
			那些年踩过的mysql的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章都是平时使用的时候踩到的坑，以后估计坑越来越多，有时间会继续补坑 当然有些问题可能不仅仅是mysql的问题，有些具有普适性～～
1. 锁机制带来的锁死 如果不是通过主键来删除，而是通过其他的字段来删除，那么会导致表级锁，其他insert无法操作。同理，不通过主键update 的时候，也会有锁表的情况，同样导致的相同的情况。 2. 在大表中进行删除 千万别试图删除一张没有索引的大表，时间会超出你的想像。先采用逻辑删除，以后再找个空闲时间在后台慢慢删除。
3. 过分依赖视图而不是表： 过分依赖视图会造成性能瓶颈，特别生成视图底层表的关联比较多的情况。依赖视图不容易优化。
4. 在主库中进行查询 如果需要频繁的查询，但是主库中又存在频繁的update或者insert，那么这样查询也是很慢的。这时可以使用salve数据库，只进行读的操作。如果查询的数据分时间的话，可以按时间进行分表。在每个表中进行查找也会加快速度。
5. 关了connection也会出事情 一般我们在创建连接后，一般都会调用 connection.close() 将连接关掉。如果高频率的创建连接然后关闭，过一段时间后，你会发现端口被用完了，无法创建连接了。明明连接已经关掉了啊。 其实即使你已经close了，mysql服务器仍然会把你连接的信息保存2个小时（默认值），端口暂时也不会给其他进程用。如果你频繁的创建连接，很快就吃完所有的端口。 解决办法也很简单，上连接池吧，推荐两个包：DBUtils和SqlAlchemy
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae29340231994fb7d6b1c99bf3cbe9a1/" rel="bookmark">
			WebView内存泄漏解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：在项目的开发过程中，由于对内存要求较高，最近对应用的内存分析比较在意，前段时间监控图片内存，对Bitmap造成的内存泄漏进行了分析，并解决了问题。但是在图片内存泄漏之后，发现在访问网页的时候，webview竟然也会有内存泄漏，虽然内存占用很小，但是用户多次访问还是存在隐患。
于是，开始对webview进行内存分析，发现webview下面的callback持有activity引用，造成webview内存无法释放，在网上也找了很多方法，但是webview.destory()等方法大都无法解决问题。
最后看到一篇文章，才算明了出现这个bug的原因，按照作者的做法，确实解决了问题，安卓5.1和6.0系统都不存在内存泄漏问题。
文章附下：
销毁webview的方式
从
mWebView.removeAllViews();
/**、
* 这里内存泄漏了，因为它的父容器在退出前没有被销毁，所以就会持有引用，内存泄漏
* */
// mWebView.destroy(); 改为 在 Android 5.1 系统上，在项目中遇到一个WebView引起的问题，每打开一个带webview的界面，退出后，这个activity都不会被释放，activity的实例会被持有，由于我们项目中经常会用到浏览web页面的地方，可能引起内存积压，导致内存溢出的现象，所以这个问题还是比较严重的。
问题分析
使用Android Studio的内存monitor，得到了以下的内存分析，我打开了三个BookDetailActivity界面(都有webview)，检查结果显示有3个activity泄漏，如下图所示：
这个问题还是比较严重的，那么进一步看详细的信息，找出到底是哪里引起的内存泄漏，详情的reference tree如下图所示：
从上图中可以看出，在第1层中的 TBReaderApplication 中的 mComponentCallbacks 成员变量，它是一个array list，它里面会持有住activity，引导关系是 mComponentCallbacks-&gt;AwContents-&gt;BaseWebView-&gt;BookDetailActivity， 代码在 Application 类里面，代码如下所示：
public void registerComponentCallbacks(ComponentCallbacks callback) { synchronized (mComponentCallbacks) { mComponentCallbacks.add(callback); } } public void unregisterComponentCallbacks(ComponentCallbacks callback) { synchronized (mComponentCallbacks) { mComponentCallbacks.remove(callback); } } 上面两个方法，会在 Context 基类中被调用，代码如下：
/** * Add a new {@link ComponentCallbacks} to the base application of the * Context, which will be called at the same times as the ComponentCallbacks * methods of activities and other components are called.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae29340231994fb7d6b1c99bf3cbe9a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02819c1f5c735e2310f06bd653a790ff/" rel="bookmark">
			大疆遭遇“口袋无人机”革命？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大疆遭遇“口袋无人机”革命？（转）
文 / 腾讯科技 卜祥、王潘
11月20日中午，北京下起了小雨，风不大，在中关村软件科技园外，杨建军和一名工程师站在大楼门口的空旷草坪前，通过手机操作，一会儿把一个银色的带有四支螺旋浆的小飞机推向远方20米外的空中，一会儿又拉到近前1.5米处。那名工程师靠近无人机时，两块舒肤佳香皂大小的无人机会自动后退；工程师后退，无人机会自动跟着靠前。
“这用了初步的人脸自动识别功能”，杨建军介绍。而在刚才推远拉近过程中，小无人机已经录制了一段视频，直接可以用手机播放。对于整个测试过程，杨建军大体满意。他向工程师提出了一个观察到的问题，在飞机从手中抛出，自动悬停在空中的瞬间，有那么一秒钟，平飞的机身会有一丝不易察觉的抖动，“这是不是高通平台兼容问题？”
在过去一年半时间里，杨建军创建的零度智控无人机公司折腾出不小动静，借助于美国高通芯片平台整合技术，无人机重量从一公斤以上，迅速下降到200克左右，价格从四五千元下探至2000元左右。与之相比，无人机巨头大疆推出的小型便携产品MavicPro重量743克，售价约5000元。
杨建军干脆给新研发的无人机Dobby冠了一个定语——口袋式无人机。由此，杨建军在大疆专业级别的无人机和许许多多航模型无人机之间创造了一个无人机新品类。“相对于大疆无人机专业级拍摄，是单反相机，口袋便携式无人机可以看作是卡片相机。”杨建军说。
卡片相机俗称傻瓜相机，因为无人机的智能性，杨建军小心地选择了卡片机的名称。在没有被智能手机拍照替代之前，卡片相机出货量和市场占有率远远超过专业级相机，相应地带动了一些公司生意红火。如今，口袋式，包括可以装在背包里的小体积、轻重量无人机市场需求在逐月增长。腾讯科技（微信公众号：qqtech）从上游供应商处获悉，Dobby每个月生产量是25000台，“我们很快要做到3万台。”杨建军说。
“明年肯定能突破100万台”，中科创达高级副总裁、无人机业务负责人张书涛更加乐观，“专业级拍摄无人机（大疆）四五年走过的路，便携无人机一两年可以走完。”实际上，大疆现在一年销售额100亿人民币，以5000元均价估算，约200万台。
更为重要的是，便携式无人机可能仅仅是未来空中机器人方向中一个过渡形态，解决空中拍照和录制视频只是部分功能，未来可能成为一个新的计算平台。随着高通、英特尔、联发科等大的科技巨头进入，外加三星、小米等手机厂商进入，还有像零度、零零无限等无人机公司杀入，将会一起冲击大疆无人机过去10年在无人机领域树立的商业壁垒。对于口袋便携无人机，大疆再不可能一味高昂头颅，漠视不理。
便携无人机如何炼成的？
无人机市场由大疆带热之后，国内外很多厂家跟进，一度火热。但是大疆凭借先发优势和超强研发能力，占据了四旋翼专业级影像拍摄无人机七八成市场份额，其它跟随者都未能反超。想突破大疆，只能另寻它途，其中小型便携化是一个途径，但是限于技术瓶颈，一直进展不大。
杨建军现在还记得与高通工作人员一起把无人机做小过程中，技术攻关时遭受的煎熬。去年8月底，零度和高通双方团队连续加班超过半个月，高通甚至从美国派来了两位工程师，白天到晚上连续加班，可是到底能不能用高通芯片做出一个能飞的东西来仍然是未知数，“当时就觉得快要放弃了。”杨建军向腾讯科技回忆。
最初，杨建军做口袋无人机的出发点是“一拍脑袋”想出来的，只为能拍摄一些静态图，这是无人机差异化方向之一。“记者去抢新闻，能够拍摄一些突发事件，从口袋里掏出无人机抓拍一个空中角度，是一个独家秘密武器。”但是，便携要求做小，是一个极大挑战。
美国芯片商高通对于无人机有一些想法和计划，以801芯片为基础，集成了图像、CPU、通讯和飞控等功能构成一块主板，使整个核心部件体积大为缩小，主板大小为58x40毫米。“但是能不能做出来，谁是他客户？”杨建军认为高通也不知道。高通在手机通讯、芯片集成等方面是世界级公司，找了国内一些无人机公司想打开集成主板新应用突破口，不少人拒绝了。找到杨建军时，杨建军凭着对无人机的敏感，同意与高通合作，“一拍即合”。
杨建军是首次用集成主板。作为第一家合作公司，有很多技术上的坑。零度的算法和操作系统装不进高通集成后的芯片平台，一些接口、管角之类很费劲。零度的工程师和美国来的工程师为了解决核心的飞控，一起做了一个星期，到去年八月，终于把飞机飞起来了。
当时已经是凌晨一点多，大家很振奋。美国工程师连夜发邮件给总部汇报喜讯。紧接着，正是国庆大阅兵前，北京禁飞管控最严的时候，后续的调试、飞行，只能在室内。后来杨建军才知道，解决能飞只是第一步难题，飞机从1.2公斤一下子变成200克左右，真正在变小后做成产品，还有很多难题要克服。
最早的操作系统里面有非常多漏洞，很容易导致飞机突然死机。飞机变小后，散热成了头疼问题，飞机在飞行过程中拍摄，图像功能全开，与手机使用芯片相比，功耗急剧增加，最终得通过内部增加风扇解决。
甚至，在小飞机身上加一块GPS芯片都是重大挑战。同样采用高通平台的零零无限便携无人机第一代Hover Camera，就放弃了GPS，更多场景是在室内飞。
Hover Camera无人机
杨建军坚持留下GPS功能，如果没有GPS，仅靠镜头识别地面，速度慢，看参照目标时会发生漂移，不确性增多，无法应用到户外。留下GPS的代价是程序会复杂，成本增加，电池兼容性要求会更高。
手机GPS只需要一个大致位置，误差大，定位不准备的地方通过地图校准。飞机不一样，没有其它辅助传感器，容忍误差只有半米。恰恰GPS本身高灵敏度，是一个非常微弱的信号接受器。GPS信号从天而降，经历了很大损耗。杨建军需要把信号放大，同时要想办法屏蔽飞机上电池辐射、高频主芯片、内存DDR运行时带来的干扰。要在体积和信号接收之间求平衡。这里有技术难度。
解决了信号问题，接着要解决拍摄不清晰难题。大疆无人机自身像脸盆那么大，可以通过安置机械的三轴云台，消除飞机颤抖对摄像头的影响。在口袋式小无人机上，装一个三轴云台，体积会很大。这个难题最终由杨建军和团队采用自己研发的电子稳像方法解决。
简单来说，飞机头突然猛一往上抬，摄像本来是要看前面的，头往上一抬镜头就看到上面去了，电子稳像方式是把图像根据飞机姿态，进行一个非常精准的整体搬移，让用户看的图像仍然是稳定的。
2016年3月份，杨建军已经可以做到把无人机装进随身口袋，又花了两个多月调试和完善。5月25日正式发布，“跟小米无人机发布同一天”，杨建军记得。所不同的是，后来小米无人机很快经历了炸机事件，整体方案转向与高通合作。而杨建军的无人机每月销售已经过万。
杨建军畅想着更大的应用情景。他发现，Dobby不仅仅可以拍摄静态图片，还可以用于摄像。同时，“用户群变得更广阔了，不光是记者，普通人也能用”。今年六七月份，杨建军进一步明确了产品定义和打法。
他慢慢发现，半径20米内的连续视频，目前是一片空白。便携无人机对普通人而言，旅游时候爬到泰山顶上，或者在湖边，无人机能拍一段别人拍不到的视频，拓展到人加自拍杆达不到的角度。还可以丰富轨迹，预设不同的拍摄移动路线、角度，视频拍摄后放在手机APP里，输出到美拍，美图秀秀和秒拍等进行简单编辑，最后通过微信等社交工具分享。由此，降低用户使用难度，增加用户黏性。
“飞机产品本身是一个引流，是一个入口。”可以想象，一旦新型视频玩法引爆之后，便携式无人机会成为高频日常拍摄工具，进而可能成为消费级电子消费品。在干了9年无人机之后，杨建军这一次似乎找到了绕开大疆无人机的可能。“小，灵活，一旦智能化，能做的事情非常地多”，杨建军说。
现在的他，享受着“痛并快乐着”感觉，零度作为高通头批用户，趟坑很累，好处是别人还在试801平台时，零度第二代无人机上面将搭载820芯片平台，2017年1月份在美国CES展上将正式发布。
当然，对于零度、零零无限等公司趟出的便携式道路，不是每一家无人机公司都立刻跟随。大疆在今年仍然在按照自己的节奏发布万元级别专业化产品，对农业无人机也很上心，并没有立刻推出200克左右的便携式产品。亿航无人机CMO熊逸放则告诉腾讯科技，他认为便携性始终是很多无人机用户的一大核心需求，相信小型化是未来消费级无人机细分市场的发展趋势。
不过他觉得根本还是要看是否契合产品的定位、目标用户需求和使用场景，“如果单纯跟风追求小型而过多牺牲了续航、抗风性、稳定性、相机镜头等其他重要因素，反而体验不佳”。亿航会持续关注技术和市场发展趋势，结合自身的产品定位和目标用户需求，打造“强体验”、“真需求”的无人机产品。
巨头杀入
2015年9月，高通正式推出专为消费级无人机应用而设计的QualcommSnapdragonFlight无人机平台，它基于骁龙801处理器，能够满足OEM厂商及开发者对于无人机产品开发需要。
高通在零度之后，很快有了新客户零零无限。2016年10月16日，零零无限宣布正式在美国发布首款安全便携可像书本一样折叠的跟拍无人机——HoverCameraPassport小黑侠，售价为599美元。主打卖点是安全、便携和易用。零零无限创始人王孟秋称，无人机不再是仅为“航拍”服务的产品，转而全面进入大众消费领域。
杨建军同样认为，“只有一百亿市场的时候，巨头很难入场。三五年之内，消费无人机一定会变成一个千亿级市场，一定会把巨头们给带进来。”
高通正是这样的巨头之一。高通产品市场副总裁颜辰巍告诉腾讯科技，高通切入消费级无人机行业优势有两点：第一，高通能够给厂商提供技术支持。无人机和智能手机很相似。而高通在智能手机上的成就有目共瞩。第二，产品本身优势，高通提供的芯片产品和软件算法。比如，零度所采用的第一代产品基于骁龙801处理器主板，在图像处理、连接性、计算和处理能力方面很强大。
颜辰巍认为，高通的进入，会像智能手机一样，降低行业开发的门槛，方便一些厂商去做产品的用户体验，比如拍照、摄像功能等。具体业务操作时，高通通过与中科创达合资成立的创通联达（ThunderComm）以及深圳的一些ODM合作，来支持更多想采用高通无人机平台做无人机的厂商。
看中无人机前景的不仅是高通。国际上上游芯片强手英特尔、英伟达、联发科等都有涉及，国内联芯公司同样也有意于做消费级便携型无人机。
对此，杨建军持兼容并包态度，他认为各家都有长处，而目前无人机产品并没有像手机那样定型，还充满各种可能性，如果闭门造车，在产品方向上犯错误风险会很大。
据他分析，每个平台都有自己特点。高通优势高度集成化，配套软件做好。有一些无人机所需、智能手机上没有的功能，比如飞行控制，高通集成了飞行控制算法。联芯有个很好的技术，叫做软件无线电SDR技术，可以配置厂商自己的通讯算法，做成一套体系装进去，从而摆脱WiFi等用于手机的通讯方式，一个非常好的应用是用来做高清长距离的图象传输系统。瑞芯微平台特点是上面集成了CEVA的DSP，最新一代DSP，成本又很低，且具有很多很强大功能，比如对于无人机很重要的电子稳像功能，还有卷积深度学习神经网络的搭建，同样胜任。
另外一家无人机新创公司博瑞云飞创始人高鹏告诉腾讯科技，他们公司目前选用了联芯的方案。他认为高通芯片集成度比较高，但是没有过多接口，很难做扩展。他认为，用单个手机芯片做无人机，一旦手机芯片死机，无人机就失控。“我们做了双芯，一个联芯芯片做计算，还有一个芯片专门用来控制飞行”高鹏说，双芯设计还有利于日后扩展升级。
当然，价格也是高鹏考虑联芯的原因之一。他说，中科创达卖高通主板，一块是125美金，约合1000块钱人民币，联芯相应产品是60美金，便宜一半。比较有竞争优势。据博瑞云飞创始人高鹏所知，零度智控最近在高通芯片之外，今年7、8月份开始找联芯合作，除了技术原因，高通方案贵也是原因之一。
不过，真正让杨建军警惕的不是上游这些芯片厂商，也不是大疆，更不是中科创达这样的方案提供商，而是目前正在赚大钱的智能手机厂商。智能手机里有摄像头、CPU、内存和GPS天线等，很多东西和无人机共通，手机厂商来做无人机具有天然优势，同时，它们具备非常强的供应链优势。
“小米（飞米）冲进来以后，所到之处寸草不生，我更愿意和大疆站在一起。”杨建军意味深长地说。实际上，据腾讯科技了解，小米的生态企业飞米已经找到高通，下一步双方将合作推出新的无人机。而有了高通，一款无人机开发流程可能会缩短到四五个月。如果未来上游核心都掌握在外国企业手中，无人机如果同质化，未来或将重演智能手机市场快鱼吃慢鱼、大鱼吃小鱼局面。
卡位空中机器人
对于Dobby无人机，杨建军还在快速迭代，第二代产品散热更好，增加减震后图像更清晰，飞行时间也比第一代9分钟时长有所提升。另外，他想陆续地增加一些新功能。“比如人工智能模块，让它更智能”，杨建军说。智能识别方面而言，不仅能识别人脸，还可以识别更复杂的东西，比如汽车，人体，甚至是手势，到时可以自动避障。
甚至，无人机可以做到中科创达副总裁张书涛所说的“贴身摄像师”，随心地即抓即拍。即便与人进行语言交流，也不是没有可能。
“在手机上指点一个房子，无人机自己就能飞去现实中房子那里，这些都能实现”，杨建军说，在业界，一些高端无人机产品已经实现此功能。在下一代产品上，采用“820芯片变得更强大，更智能，包括自主飞行，这些算法都装上去。”
而大数量级的销售又将使零度处于一个有利位置。用户使用频率高，“会成为我们很多信息收集的点，比那种大的无人机使用频度高，得到更多数据，谁做人工智能最厉害呢？其实就是像谷歌这样的，因为它有全球最多数据。”
正因此种可能，零度智控、零零无限等便携式无人机公司被一些大公司看好。零度智控融资已进入B轮，融资1.5亿人民币。领投者是信达国萃和名航资本两家，高通旗下投资公司也加入。另外，腾讯科技获悉，三星也有意于投资零度智控，相关手续正在办理当中。
智能手机分成通讯和影像、操作系统这三块。无人机基本上也是通讯，影像和操作系统，外加一个飞行控制。智能手机在好多年前，比如Android刚刚开始的时候，很少有人真的能够预测到几年之后，智能机能够给人们带来多少的便捷，并成为个人电脑之后一个新的计算平台。现在无人机，如果能聚集海量用户，慢慢会想出各种各样不同应用和场景，一起把市场拓展得越来越大。
“实际上无人机就像是带着螺旋桨会飞的机器人，这一类产品今后能够给人类想象空间其实是非常大的。”高通颜辰巍说。未来，只要是跟人工智能有关的，语音方面的人工智能、计算机图象处理方面的人工智能，都有可能被用在无人机上。
“革命刚刚开始，有变成一场很大革命的可能。”颜辰巍说。和他一样，杨建军也认为2017年会是无人机智能化元年，计算机视觉、人工智能等等发展迅速，需要一个出口，无人机可能会是这样一个出口。
原文链接：http://xw.qq.com/tech/20161125002231/TEC201611250022310H
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a71067fcc412ef72e4a394059cf36e9f/" rel="bookmark">
			Android 关闭WebView之后，声音或者视频不停止的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决办法如下：
``` 清除webview释放内存防止oom @Override protected void onDestroy() { super.onDestroy(); m_WebView.reload (); m_WebView.removeAllViews(); m_WebView.destroy(); finish(); } “`
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f2cc4abfcd7258e6a057ecc29925d23/" rel="bookmark">
			mysql动态添加字段存储过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 USE `db`; DROP PROCEDURE IF EXISTS schema_change; DELIMITER // CREATE PROCEDURE schema_change() BEGIN DECLARE CurrentDatabase VARCHAR(100); SELECT DATABASE() INTO CurrentDatabase; IF NOT EXISTS (SELECT * FROM information_schema.columns WHERE table_schema=CurrentDatabase AND table_name = 'FILE_PATH_TABLE' AND column_name = 'FILE_NAME') THEN ALTER TABLE FILE_PATH_TABLE ADD FILE_NAME VARCHAR(2000) NULL DEFAULT NULL COMMENT '文件名称'; END IF; END// DELIMITER ; CALL schema_change(); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0955b470a0dbebdd54568f4d73f6a18c/" rel="bookmark">
			订阅RabbitMQ发布的消息，通过WebSocket实现数据实时推送到前端上显
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、架构简单概述
RabbitMQ消息队列服务善于解决多系统、异构系统间的数据交换（消息通知/通讯）问题，并且可以订阅和发布，而随着HTML5诞生的WebSocket协议实现了浏览器与服务器的全双工通信，扩展了浏览器与服务端的通信功能，使服务端也能主动向客户端发送数据。
因此，我们可以使用RabbitMQ的订阅发布技术，订阅后，当RabbitMQ端有新的数据就直接发布到指定的queue，订阅端接收到订阅队列的数据直接通过WebSocket推送到前端，前端拿到数据之后实时解析上显，此过程相比传统的Rest接口定时请求，减去了数据入库、读库、客户端不断的请求服务器和刷新页面，大大的减小了服务器的压力和减少了请求时间。该设计更适用于实时数据接收后直接推送到前端上显的一些不需要处理和统计的场景，如实时船舶的上显，导航等。
二、最终效果
通过RabbitMQ订阅发布的实时消息，并且实时推送到前端，前端接收消息时间几乎和RabbitMQ发布消息同时，更好的实现了数据的实时上显，此处将前端接收到的Json格式数据丢在网页上，拿到数据以后就可以根据坐标位置上显对应的场景（此处未渲染）。
三、代码实现
（1）项目依赖包，maven管理
&lt;dependency&gt; &lt;groupId&gt;javax&lt;/groupId&gt; &lt;artifactId&gt;javaee-api&lt;/artifactId&gt; &lt;version&gt;7.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; （2）前端连接、关闭WebSocket和接收消息代码
&lt;%@ page language="java" pageEncoding="UTF-8" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;WebSocket&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="main"&gt; &lt;div id="message"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script type="text/javascript"&gt; var websocket = null; //判断当前浏览器是否支持WebSocket if ('WebSocket' in window) { //创建一个WebSocket连接，URL：127.0.0.1:8080/realTimeWebSocket/webSocket //注：后端Server在模块realTimeWebSocket下，所以路径下多了一层realTimeWebSocket websocket = new WebSocket("ws://127.0.0.1:8080/realTimeWebSocket/webSocket"); } else { alert('当前浏览器 不支持WebSocket') } //连接发生错误的回调方法 websocket.onerror = function () { setMessageInnerHTML("连接发生错误"); }; //连接成功建立的回调方法 websocket.onopen = function () { setMessageInnerHTML("连接成功"); } //接收到消息的回调方法，此处添加处理接收消息方法，当前是将接收到的信息显示在网页上 websocket.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0955b470a0dbebdd54568f4d73f6a18c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/322912571ce535157472dd1a45bbe37c/" rel="bookmark">
			Qt学习之路系列教程目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 导语 《Qt 学习之路》是在网络上受到一定欢迎的 Qt 入门教程。只是这个系列便携与 2009 年，至今已经有三年多的时间。今天的 Qt 有了很大的变化，包括 Qt Quick 的加入、Qt 底层架构的改变，更重要的是 Qt 5 的发布。本系列文章将会是《Qt 学习之路》的一次升级和修订，着重关注于 Qt 5，同时会结合 Qt 4 进行讲解。希望这个系列也能够像前面一个版本那样，能够更多朋友接触到 Qt 这样一个优秀的开发框架。 为了便于大家更好的学习和交流，将所有教程从作者的博客网站www.devbean.net 同步更新到了Qter论坛（Qter开源社区www.qter.org） 。 目录 第1篇 序 第2篇 Qt简介 第3篇Hello, world! 第4篇 信号槽 第5篇 自定义信号槽 第6篇 Qt模块简介 第7篇MainWindow 简介 第8篇 添加动作 第9篇 资源文件 第10篇 对象模型 第11篇 布局管理器 第12篇 菜单栏、工具栏和状态栏 第13篇 对话框简介 第14篇 对话框数据传递 第15篇 标准对话框 QMessageBox 第16篇 标准对话框 QMessageBox 第17篇 标准对话框 文件对话框 第18篇 标准对话框 事件 第19篇 标准对话框 事件的接受与忽略 第20篇event() 第21篇 事件过滤器 第22篇 事件总结 第23篇 自定义事件 第24篇 Qt绘制系统简介 第25篇 画刷和画笔 第26篇 反走样 第27篇 渐变 第28篇 坐标系统 第29篇 绘制设备 第30篇Graphics View Framework 第31篇 贪吃蛇游戏（1） 第32篇 贪吃蛇游戏（2） 第33篇 贪吃蛇游戏（3） 第34篇 贪吃蛇游戏（4） 第35篇 文件 第36篇 二进制文件读写 第37篇 文本文件读写 第38篇 存储容器 第39篇 遍历容器 第40篇 隐式数据共享 第41篇model/view 架构 第42篇QListWidget、QTreeWidget和 QTableWidget 第43篇QStringListModel 第44篇QFileSystemModel 第45篇 模型 第46篇 视图和委托 第47篇 视图选择 第48篇QSortFilterProxyModel 第49篇 自定义只读模型 第50篇 自定义可编辑模型 第51篇 布尔表达式树模型 第52篇 使用拖放 第53篇 自定义拖放数据 第54篇 剪贴板 第55篇 数据库操作 第56篇 使用模型操作数据库 第57篇 可视化显示数据库数据 第58篇 编辑数据库外键 第59篇 使用流处理 XML 第60篇 使用 DOM 处理 XML 第61篇 使用 SAX 处理 XML 更新中。。。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8fbaa0e34bf3ffeb20c6d4d9f24d19c/" rel="bookmark">
			linux下ifconfig、iwconfig、iwlist命令详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在linux下查看网络信息。
一、ifconfig
用途：配置网络信息。
如果没有参数，将给出当前的active 接口。
# ifconfig eth0 Link encap:Ethernet HWaddr 02:00:E1:00:11:5A inet addr:192.168.1.234 Bcast:192.168.1.255 Mask:255.255.254.0 inet6 addr: fe80::e1ff:fe00:115a/64 Scope:Link UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:17338002 errors:0 dropped:11993 overruns:0 frame:0 TX packets:228594 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:1759095713 (1.6 GiB) TX bytes:67780580 (64.6 MiB) Interrupt:33 Base address:0xc000 lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 inet6 addr: ::1/128 Scope:Host UP LOOPBACK RUNNING MTU:65536 Metric:1 RX packets:43362 errors:0 dropped:0 overruns:0 frame:0 TX packets:43362 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:4835488 (4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8fbaa0e34bf3ffeb20c6d4d9f24d19c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5560db59e738be296e42fdfa4c4450c7/" rel="bookmark">
			非常详细的 Docker 学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 http://blog.csdn.net/zjin_hua/article/details/52041757 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d7192a2a1a7533275f2c2e61906dfe0/" rel="bookmark">
			UEditor上传图片到项目外部目录-java
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相关 百度UEditor是由百度web前端研发部开发所见即所得富文本web编辑器，轻量，可定制，开源基于MIT协议，允许自由使用和修改代码。
原料 1、ueditor源码，包括ueditor.jar的源码 2、ueditor上传文件路径配置官方文档(http://fex.baidu.com/ueditor/#server-path)
需求 查阅官方文档，上传的文件存放路径根据项目根路径配置，若要使文件存放路径配置到项目外，使用相对路径就行 然而对于有些童鞋来说，使用相对路径../../../..会带来很多不确定性，项目迁移或文件服务器变动都需对相对路径进行重新调整，若在window server中跨盘符显然是无法满足的
实操 开源的好处就是自己能动手，对源码进行些扩展以达到自己想要的效果。 学习源码参考：ueditor文件上传研究（http://asialee.iteye.com/blog/2100187），感谢前人提供肩膀。 代码详解上面的文章已经很清楚，这里尽量简洁，后面附上github地址。 源码结构： 源码修改记录：（详见源码，在ueditor.1.5.0.jar中搜索zrk就能搜索到所有修改的代码） config.json配置 config.json中添加如下属性 （一定要添加此属性）：
"physicsPath":"d:/resource", physicsPath ：属性配置文件存放的路径，不同系统环境如“d:/resource”或“/home/resource”，若需使用ueditor默认配置，physicsPath值置为“”（空串）即可。
使用： 仅仅完成上面的配置是不够的，在使用中会图片是上传后是无法预览的，既然文件放在项目路径外部，想通过当前项目来访问这些图片不是好的方式； 既然有将图片存放外部的需求，文件必然是使用单独的文件服务来访问，就需要在返回的路径前附加文件服务访问路径；好在config.json中“imageUrlPrefix”（访问路径前缀）可以满足这个要求（通常在文件存放项目路径下时我们设置“imageUrlPrefix”当前项目名，使用当前项目路径访问文件，文件放存外部后这样就不可行）；
配置说明 “imageUrlPrefix”设置为文件服务访问路径：
"imageUrlPrefix": "http://127.0.0.1:8080/resource", /* 图片访问路径前缀 */ 这时config.json是这样：
{ /* 上传图片配置项 */ "physicsPath":"d:/home/resource", "imageActionName": "uploadimage", /* 执行上传图片的action名称 */ "imageFieldName": "upfile", /* 提交的图片表单名称 */ "imageMaxSize": 2048000, /* 上传大小限制，单位B */ "imageAllowFiles": [".png", ".jpg", ".jpeg", ".gif", ".bmp"], /* 上传图片格式显示 */ "imageCompressEnable": true, /* 是否压缩图片,默认是true */ "imageCompressBorder": 1600, /* 图片压缩最长边限制 */ "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d7192a2a1a7533275f2c2e61906dfe0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d984fdbdf183f73798791fbd1e49299/" rel="bookmark">
			redis 事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		事件是 Redis 服务器的核心，它处理两项重要的任务：
处理文件事件：在多个客户端中实现多路复用，接受它们发来的命令请求，并将命令的执行结果返回给客户端。 时间事件：实现服务器常规操作（server cron job）。 本文以下内容就来介绍这两种事件，以及它们背后的运作模式。
文件事件 Redis 服务器通过在多个客户端之间进行多路复用，从而实现高效的命令请求处理：多个客户端通过套接字连接到 Redis 服务器中，但只有在套接字可以无阻塞地进行读或者写时，服务器才会和这些客户端进行交互。
Redis 将这类因为对套接字进行多路复用而产生的事件称为文件事件（file event），文件事件可以分为读事件和写事件两类。
读事件 读事件标志着客户端命令请求的发送状态。
当一个新的客户端连接到服务器时，服务器会给为该客户端绑定读事件，直到客户端断开连接之后，这个读事件才会被移除。
读事件在整个网络连接的生命期内，都会在等待和就绪两种状态之间切换：
当客户端只是连接到服务器，但并没有向服务器发送命令时，该客户端的读事件就处于等待状态。 当客户端给服务器发送命令请求，并且请求已到达时（相应的套接字可以无阻塞地执行读操作），该客户端的读事件处于就绪状态。 作为例子，下图展示了三个已连接到服务器、但并没有发送命令的客户端：
这三个客户端的状态如下表：
客户端读事件状态命令发送状态客户端 X等待未发送客户端 Y等待未发送客户端 Z等待未发送 之后，当客户端 X 向服务器发送命令请求，并且命令请求已到达时，客户端 X 的读事件状态变为就绪：
这时，三个客户端的状态如下表（只有客户端 X 的状态被更新了）：
客户端读事件状态命令发送状态客户端 X就绪已发送，并且已到达客户端 Y等待未发送客户端 Z等待未发送 当事件处理器被执行时，就绪的文件事件会被识别到，相应的命令请求会被发送到命令执行器，并对命令进行求值。
写事件 写事件标志着客户端对命令结果的接收状态。
和客户端自始至终都关联着读事件不同，服务器只会在有命令结果要传回给客户端时，才会为客户端关联写事件，并且在命令结果传送完毕之后，客户端和写事件的关联就会被移除。
一个写事件会在两种状态之间切换：
当服务器有命令结果需要返回给客户端，但客户端还未能执行无阻塞写，那么写事件处于等待状态。 当服务器有命令结果需要返回给客户端，并且客户端可以进行无阻塞写，那么写事件处于就绪状态。 当客户端向服务器发送命令请求，并且请求被接受并执行之后，服务器就需要将保存在缓存内的命令执行结果返回给客户端，这时服务器就会为客户端关联写事件。
作为例子，下图展示了三个连接到服务器的客户端，其中服务器正等待客户端 X 变得可写，从而将命令的执行结果返回给它：
此时三个客户端的事件状态分别如下表：
客户端读事件状态写事件状态客户端 X等待等待客户端 Y等待无客户端 Z等待无 当客户端 X 的套接字可以进行无阻塞写操作时，写事件就绪，服务器将保存在缓存内的命令执行结果返回给客户端：
此时三个客户端的事件状态分别如下表（只有客户端 X 的状态被更新了）：
客户端读事件状态写事件状态客户端 X等待已就绪客户端 Y等待无客户端 Z等待无 当命令执行结果被传送回客户端之后，客户端和写事件之间的关联会被解除（只剩下读事件），至此，返回命令执行结果的动作执行完毕：
注解
同时关联写事件和读事件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d984fdbdf183f73798791fbd1e49299/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c23ac80f00bb2640157d0c7c0d1f8c19/" rel="bookmark">
			spark&#43;mongodb &#43; quartz
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于业务数据量大，使用普通查询统计已不能满足需求，所以使用spark+mongodb进行聚合统计，两种方案
1使用quartz调度spark，定时进行业务数据统计
2使用crontab调度spark，定时进行业务数据统计
为了便于管理最终使用方案1
quartz调度代码这里就不展示了，只写spark+mongodb调用
1 引入maven依赖
&lt;dependency&gt;
&lt;groupId&gt;org.apache.spark&lt;/groupId&gt;
&lt;artifactId&gt;spark-core_2.10&lt;/artifactId&gt;
&lt;version&gt;1.6.2&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
&lt;groupId&gt;org.mongodb.spark&lt;/groupId&gt;
&lt;artifactId&gt;mongo-spark-connector_2.10&lt;/artifactId&gt;
&lt;version&gt;1.0.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
&lt;groupId&gt;org.apache.spark&lt;/groupId&gt;
&lt;artifactId&gt;spark-hive_2.10&lt;/artifactId&gt;
&lt;version&gt;1.6.2&lt;/version&gt;
&lt;/dependency&gt; 2 第一种方式：使用mongodb做聚合，spark将数据转换成document，然后保存
public class UserFlowCount
{
public static void main(String args[]) throws IOException
{
//spark mongodb 连接配置
SparkConf sc = new SparkConf()
.setMaster("spark://10.1.12.4228:2000") //spark master 地址
.setAppName("MongoSparkConnectorTour") //应用名称
.set("spark.mongodb.input.uri",
"mongodb://bssd:123456@10.1.123.321:34234/bss.AccountDeductionDetailRecord_bak")//mongodb input 连接
.set("spark.mongodb.output.uri",
"mongodb://bssdb:123456@10.1.123.12:234234/bss.myCollection")//mongodb output 连接
.set("spark.mongodb.input.partitioner", "MongoPaginateBySizePartitioner")
.set("spark.cores.max", "12").set("spark.driver.port", "20898")
.set("spark.fileserver.port", "20896").set("spark.broadcast.port", "20895")
.set("spark.blockManager.port", "20894").set("spark.executor.port", "20893")
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c23ac80f00bb2640157d0c7c0d1f8c19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df63ffec8a5bf726919bf31a9561a976/" rel="bookmark">
			web之html，css，javascript 简要概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近学习了一些有关web开发方面的基础知识，包括html，css，javascript等等。其中html曾经有过一些接触，而css及javascript只是听说过，为了 今后能更好的掌握和应用这些知识，在这里就此先做一个小小的总结回顾。 html部分 html（HyperText Mark-up Language）全称超文本标记语言，是用于编写网页的语言。如名字一样，它的作用超出了纯文本的范畴（可以进行改字体， 大小，颜色的改变等），所有的操作均由标签（标记）实现。对于html的语言规范可以概括为以下四点: 1. html程序以&lt;html&gt;开始&lt;/html&gt;结束。 2. 中间由&lt;head&gt;和&lt;body&gt;组成。 3. html的代码不区分大小写， 4. 标签有开始就必须有结束，结束标签或标签内结束如&lt;/html&gt;,&lt;br/&gt;** 以下是一个最基础的html规范的示例： &lt;!-- 这里为注释代码--&gt; &lt;html&gt; &lt;head&gt;设置页面信息&lt;/head&gt; &lt;body&gt;显示到页面上的内容&lt;/body&gt; &lt;/html&gt; **html的操作思想** 网页中存在着各种各样的数据，这些数据都存在对应的标签中，对数据的处理就是通过修改标签属性来完成的，可以将标签理解为容器，对其中的数据 进行包装。 常用的标签有： - 文字标签&lt;font&gt; 常用属性 color：颜色，值有英文单词（red,green 等），十六进制（#ffffff），RGB(255,0,0)等三种表示方式， size：文字大小，取值范围1-7，如果设置大于7的值则依然是7的大小。 - 列表标签&lt;dl&gt;,&lt;ol&gt;,&lt;ul&gt; 定义列表 &lt;dl&gt; 定义列表的范围 &lt;dt&gt;&lt;/dt&gt;: 定义上层内容 &lt;dd&gt;&lt;/dd&gt;: 定义下层内容 &lt;/dl&gt;: 有序列表 &lt;ol&gt;: 定义有序列表的范围 &lt;li&gt;&lt;/li&gt;: 封装具体的内容 &lt;/ol&gt; ol标签的属性type的值表示排序方式； 1（阿拉伯数字排序），a(字母形式)，i（希腊数字排序） 无序列表 &lt;ul&gt; :定义无序列表的范围 &lt;li&gt;&lt;/li&gt;: 封装具体的内容 &lt;/ul&gt; - 图形标签&lt;img/&gt; 用于显示图片，常用属性： src：图片的路径名 width：图片显示宽度 height：图片显示高度 border：图片的边框的粗细 alt: 显示在图片上面的文字内容（鼠标移到图片上显示的文字，部分浏览器支持） - 超链接标签&lt;a&gt; 常用属性 href：链接到的地址（如果不想跳转，值可以为#） target：代开新地址的方式 (“_self”——当前页面,“_blank”——新标签页） - 表格标签&lt;table&gt;,&lt;tr&gt;,&lt;td&gt; &lt;table&gt;&lt;/table&gt;定义表格范围 常用属性 border：设置表格线 bordercolor：设置表格线的颜色 cellspacing: 设置单元格之间的距离 cellpadding: 设置文字和单元格之间的距离 width: 设置表格的宽度 height：设置表格的高度 &lt;tr&gt;&lt;/tr&gt; 表示行 属性： align——设置对其方式 &lt;td&gt;&lt;/td&gt; 表示一个单元格（没有包裹内容时，使用占位符nbsp;替代） 属性： align——设置对其方式 rowspan——跨行 colspan——跨列 &lt;th&gt;&lt;/th&gt;表示具有居中和加粗效果的单元格 表格具体书写形式如下： &lt;table&gt; &lt;tr&gt; &lt;td&gt;一个单元格中显示的内容&lt;/td&gt; &lt;tr&gt; （PS：对于表格的操作，应先数行数，再数每行中的单元格个数） - 表单标签&lt;from&gt; 表单是指将输入的数据提交到服务器上的过程 常用属性 action：提交的服务器的地址 method：表单的提交方式（有很多种，常见的是get和post） - 输入项标签&lt;input&gt;&lt;select&gt;&lt;textarea&gt; **（注：所有的输入项标签均应设置name属性值，没有设置的数据将不会提交出去，其中单选输入项和复选输入项在设置name时，同一组的name值必须相同。 另外单选输入项和复选输入项均需对每一项设置vlaues值）** 提供数据输入和选择的组件 大多都是使用&lt;input&gt;来封装和操作 格式为&lt;input type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df63ffec8a5bf726919bf31a9561a976/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aaec5bb16e740817f289daa4d911908a/" rel="bookmark">
			ios10中禁止用户缩放页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在ios10前我们能通过设置meta来禁止用户缩放页面：
&lt;meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0;" name="viewport" /&gt; 在ios10系统中meta设置失效了：
为了提高Safari中网站的辅助功能，即使网站在视口中设置了user-scalable = no，用户也可以手动缩放。
解决方法：监听事件来阻止
window.οnlοad=function () { document.addEventListener('touchstart',function (event) { if(event.touches.length&gt;1){ event.preventDefault(); } }) var lastTouchEnd=0; document.addEventListener('touchend',function (event) { var now=(new Date()).getTime(); if(now-lastTouchEnd&lt;=300){ event.preventDefault(); } lastTouchEnd=now; },false) } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4325842a6f0322f65d2b3f00678789fb/" rel="bookmark">
			由FocusChange引发的问题手札
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这次碰见了Fragment.replace后发生的focus改变问题。 这个问题是用户用蓝牙键盘的Enter键点击了某个tabContent的内容，该内容由ListFragment来展现，切换的方式是ft.replace。所以发生了显示异常问题（显示的不是所点item对应的内容，而是tab0的内容）。
Fragment fg = AListFragment.getNewInstance(subList, mListMode, mHeaderMode, key, mPlaylistId); FragmentTransaction ft = getFragmentManager().beginTransaction(); ft.replace(android.R.id.tabcontent, fg, Integer.toString(subList)); ft.setTransition(FragmentTransaction.TRANSIT_FRAGMENT_OPEN); ft.addToBackStack(Integer.toString(subList)); ft.commit(); FragmentTransaction的replace最终会引起 removeFragment，而removeFragment就会进而removeFocus。
onTabChanged: tabId= 131073 java.lang.RuntimeException at com.samsung.musicplus.contents.extra.MusicSelectListTabActivity.onTabChanged(MusicSelectListTabActivity.java:236) at android.widget.TabHost.invokeOnTabChangeListener(TabHost.java:462) at android.widget.TabHost.setCurrentTab(TabHost.java:442) at android.widget.TabHost$2.onTabSelectionChanged(TabHost.java:194) at android.widget.TabWidget.onFocusChange(TabWidget.java:683) at android.view.View.onFocusChanged(View.java:6278) at android.widget.TextView.onFocusChanged(TextView.java:9559) at android.view.View.handleFocusGainInternal(View.java:6004) at android.view.View.requestFocusNoSearch(View.java:9077) at android.view.View.requestFocus(View.java:9056) at android.widget.HorizontalScrollView.onRequestFocusInDescendants(HorizontalScrollView.java:2056) at android.view.ViewGroup.requestFocus(ViewGroup.java:3057) at android.view.ViewGroup.onRequestFocusInDescendants(ViewGroup.java:3098) at android.view.ViewGroup.requestFocus(ViewGroup.java:3054) at android.view.ViewGroup.onRequestFocusInDescendants(ViewGroup.java:3098) at android.view.ViewGroup.requestFocus(ViewGroup.java:3057) at android.view.ViewGroup.onRequestFocusInDescendants(ViewGroup.java:3098) at android.view.ViewGroup.requestFocus(ViewGroup.java:3054) at android.view.ViewGroup.onRequestFocusInDescendants(ViewGroup.java:3098) at android.view.ViewGroup.requestFocus(ViewGroup.java:3054) at android.view.ViewGroup.onRequestFocusInDescendants(ViewGroup.java:3098) at android.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4325842a6f0322f65d2b3f00678789fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f401633440186587bd0b8771ec3cf183/" rel="bookmark">
			windows Internet Connection Sharing（ICS）服务的启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这两天因为解决系统更新失败的问题，意外注意到了系统中的Internet Connection Sharing（ICS）这个服务。通过右键点击启动总是会弹出下面这个提示 框 虽然有提示，但却看不懂，于是立刻上网查询原因，没多久就找到了解决办法贴出如下。 经验证确实如此，启动之后貌似会导致同一网络中其他设备无法访问Internet，大概是如服务说明一样，使自己的电脑成了为家庭和小型办公网 络提供网络地址转换、寻址、名称解析和/或入侵保护服务的机器，因而导致其他设备无法正常访问internet（这个是个人猜想，还有待验证）。 不知道今后是否会遇到使用此服务的地方，先记录下来吧。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2243248ba7759a464cd7b3ef6076222/" rel="bookmark">
			Java反射中的setAccessible()方法是否破坏了类的访问规则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java反射机制提供的setAccessible()方法可以取消Java的权限控制检查，下面展示了这种方法的使用。
package test; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; class A { private int i = 5; private void printI() { System.out.println(this.i); } } public class Test { public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchFieldException, SecurityException, NoSuchMethodException, IllegalArgumentException, InvocationTargetException { String name = "test.A"; Class c = Class.forName(name); Object obj = c.newInstance(); Method method = c.getDeclaredMethod("printI"); //使private方法可以被调用 method.setAccessible(true); method.invoke(obj); Field field = c.getDeclaredField("i"); //使private成员可以被访问、修改 field.setAccessible(true); field.set(obj, 10); method.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2243248ba7759a464cd7b3ef6076222/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3320340c81f68102464229a7d0399dd8/" rel="bookmark">
			dedecms在Lniux下的安装及部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://help.dedecms.com/install-use/server/2012/0510/2312.html
http://jingyan.baidu.com/article/fc07f98902d47a12fee51979.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9bc9079750251bab80236686cab9206/" rel="bookmark">
			芝麻分曲线图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文已授权微信公众号：鸿洋（hongyangAndroid）在微信公众号平台发表。
1.简介 其实这个效果几天之前就写了，但是一直没有更新博客，本来想着把芝麻分雷达图也做好再发博客的，然后今天看到鸿洋的微信公众号有朋友发了芝麻分的雷达图，所以就算了，算是一个互补吧。平时文章也写的比较少，所以可能有点杂乱，有什么需要改进的地方欢迎给出建议，不胜感激。
效果图： 2.步骤： 初始化View的属性初始化画笔绘制代表最高分和最低分的两根虚线绘制文字绘制代表月份的属性绘制芝麻分折线绘制代表芝麻分的圆点绘制选中分数的悬浮文字以及背景处理点击事件 3.编码： 初始化View属性 /** * 初始化布局配置 * * @param context * @param attrs */ private void initConfig(Context context, AttributeSet attrs) { TypedArray a = context.obtainStyledAttributes(attrs,R.styleable.ScoreTrend); maxScore=a.getInt(R.styleable.ScoreTrend_max_score,700); minScore=a.getInt(R.styleable.ScoreTrend_min_score,650); brokenLineColor=a.getColor(R.styleable.ScoreTrend_broken_line_color,brokenLineColor); a.recycle(); } 初始化画笔：
private void init() { brokenPath = new Path(); brokenPaint = new Paint(); brokenPaint.setAntiAlias(true); brokenPaint.setStyle(Paint.Style.STROKE); brokenPaint.setStrokeWidth(dipToPx(brokenLineWith)); brokenPaint.setStrokeCap(Paint.Cap.ROUND); straightPaint = new Paint(); straightPaint.setAntiAlias(true); straightPaint.setStyle(Paint.Style.STROKE); straightPaint.setStrokeWidth(brokenLineWith); straightPaint.setColor((straightLineColor)); straightPaint.setStrokeCap(Paint.Cap.ROUND); dottedPaint = new Paint(); dottedPaint.setAntiAlias(true); dottedPaint.setStyle(Paint.Style.STROKE); dottedPaint.setStrokeWidth(brokenLineWith); dottedPaint.setColor((straightLineColor)); dottedPaint.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9bc9079750251bab80236686cab9206/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/031323dba2343d994da20be966a8d6fd/" rel="bookmark">
			ubuntu下查看CPU/GPU/内存使用率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在跑一些程序，例如deep learning的时候，总是希望查看一下cpu、gpu、内存的使用率
1. cpu、内存 使用top命令
$ top http://bluexp29.blog.163.com/blog/static/33858148201071534450856/
有一个更直观的监测工具，叫htop
$ sudo apt-get install htop $ stop 2. 查看gpu 使用 nvidia-smi 命令
$ nvidia-smi 但是这个命令只能显示一次，如果要实时显示，配合watch命令, 让一秒刷新一次
$ watch -n 1 nvidia-smi http://www.cnblogs.com/Suzzz/p/4106581.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cefe362319cb8e4665d1a8bc61c94017/" rel="bookmark">
			ffmpeg视频精准剪切
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 导言 ffmepg剪切视频，很方便，但是也有很大缺陷： （1）剪切时间点不精确 （2）有时剪切的视频开头有黑屏
造成这些问题的原因是ffmpeg无法seek到非关键帧上。 一下本文通过一些参数配置尽可能地减轻以上问题
2. 基本剪切方法 ffmpeg -i test.mp4 -ss 10 -t 15 -codec copy cut.mp4 参数分析：
-i : source -ss:start time -t :duration -c :video,audio codec
时间格式：
x秒HOURS:MM:SS.MICROSECONDS 可以设置输出视频的编码格式
-vcodec xxx -acodec xxx
把-ss, -t参数放在-i参数之后，是对输出文件执行的seek操作 输入文件会逐帧解码，直到-ss设置的时间点为止，这么操作会很慢，虽然时间点是准确的，但是很容易出现黑屏问题。
3. 参数优化 （1）将-ss， -t 参数放在-i参数之前
ffmpeg -ss 10 -t 15 -i test.mp4 -codec copy cut.mp4 对输入文件执行seek操作，会seek到-ss设置的时间点前面的关键帧上。 时间不精确，但是不会出现黑屏
（2）accurate_seek 剪切时间更加精确
ffmpeg -ss 10 -t 15 -accurate_seek -i test.mp4 -codec copy cut.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cefe362319cb8e4665d1a8bc61c94017/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cad652c7816b3e9e087b43808c6bfaac/" rel="bookmark">
			史上最简单，一步集成侧滑(删除)菜单，高仿QQ、IOS。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布
转载请标明出处：
gold.xitu.io/post/58285e…
本文出自:【张旭童的稀土掘金】(gold.xitu.io/user/56de21…)
代码传送门：喜欢的话，随手点个star。多谢
github.com/mcxtzhang/S…
重要的话 开头说，not for the RecyclerView or ListView, for the Any ViewGroup. 本控件不依赖任何父布局，不是针对 RecyclerView、ListView，而是任意的ViewGroup里的childView都可以使用侧滑(删除)菜单。
支持任意ViewGroup、0耦合、史上最简单。
概述 本控件从撸出来在项目使用至今已经过去7个月，距离第一次将它push至github上，也已经2月+。（之前，我发表过一篇文章。传送门:blog.csdn.net/zxt0601/art…, 里面详细描述了本控件V1.0版本是怎么实现的。）
期间有很多朋友在评论、issue里提出了一些改进意见，例如支持设置滑动方向（左右）、高仿QQ的交互、支持GridLayoutManager等，以及一些bug。已经被我全部实、修复。并且将其打包至jitpack，引入更方便。和第一版相比，改动挺多的。故将其整理，新发一版。
那么本文先从如何使用它讲起，然后介绍它包含的特性、支持的属性。最后就几个难点和冲突的解决进行讲解。
代码传送门：喜欢的话，随手点个star。多谢
github.com/mcxtzhang/S…
先上几个gif给各位看官感受一下最新版的魅力（以下版本都顺便展示了可选的双向滑动）
本控件最大魅力就是0耦合,所以先上配合我另一个库组装的效果(ItemDecorationIndexBar + SwipeMenuLayout)：
(ItemDecorationIndexBar : github.com/mcxtzhang/I…)
Android Special Version （无阻塞式，侧滑菜单展开时，依然可以展开其他侧滑菜单，同时上一个菜单会自动关闭）:
GridLayoutManager （和上图的代码比，只需修改RecyclerView的LayoutManager。）:
LinearLayout （不需任何修改，连LinearLayout也可以简单的实现侧滑菜单）:
iOS interaction （阻塞式交互，高仿QQ，侧滑菜单展开式，屏蔽其他ITEM所有操作）:
使用： Step 1. 在项目根build.gradle文件中增加JitPack仓库依赖。
allprojects { repositories { ... maven { url "https://jitpack.io" } } }复制代码 Step 2. Add the dependency
dependencies { compile 'com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cad652c7816b3e9e087b43808c6bfaac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd64f763e383b9260ef70b21e00b95e6/" rel="bookmark">
			【C语言】用递归实现字符串逆序的曲折之路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先看一下简洁版的。 1.成功版
#include&lt;stdio.h&gt; #include&lt;windows.h&gt; char s[1000]; void reverse(char *s) { if (*s) { reverse(s+1); printf("%c", *s); } return; } int main() { gets_s(s, 100); reverse(s); printf("\n"); system("pause"); return 0; } 错误案例1. 输出： 错误案例2. 那++前置怎么样呢？
#include&lt;stdio.h&gt; #include&lt;windows.h&gt; char s[1000]; void reverse(char *s) { if (*s) { reverse(++s); printf("%c", *s); } return; } int main() { gets_s(s, 100); reverse(s); printf("\n"); system("pause"); return 0; } 总结： 1.++s 与s++ 不行 原因还不清楚，反思一下，不知道谁可以解决，共同进步?
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/331b220da8ea6e6f45b66ac4eac79fe8/" rel="bookmark">
			数据结构中二叉树的度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先说说什么是度：通俗的讲二叉树中连接节点和节点的线就是度，有n个节点，就有n-1个度，节点数总是比度要多一个，那么度为0的节点一定是叶子节点，因为该节点的下面不再有线；度为1的节点即：该节点只有一个分支；同理度为2的节点就是有两个分支。在二叉树中不可能存在度为3或大于3的节点！ 关于度和节点之间的关系还有很多公式：度为0的节点数为度为2的节点数加1，即n0=n2+1 这个公式的推理方法如下： 设： k:总度数 k+1:总节点数 n0:度为0的节点 n1:度为1的节点 n2:度为二的节点 根据二叉树中度和节点的守衡原理，可列出以下一组方程： k=n2*2+n1; k+1=n2+n1+n0; 将上面两式相减得到：n0=n2+1； 例如：已知767个节点的完全二叉树，求其叶子节点个数： n0=n2+1;
n=n0+n1+n2;
由上面，消掉n2得到：n=2n0+n1-1;
由于完全二叉树度为1的只有0个或1个两种情况，所以，将0或1带入上面公式，整理后得：
n0=（n+1）/2或者n0=n/2;
看看n是否能被2整除，能则用n0=n/2。否则用n0=（n+1）/2
既叶子节点为n0=（n+1）/2=384
-----------------------------------------------------------------
再比如一棵二叉树有10个度为1的节点，7个度为2的节点，则二叉树有多少个节点（25）
根据刚才说的，节点数比度数多1，可以列出计算式子：
10 * 1 + 7 * 2 + 1 = 25
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ca240e4416f775ae4a11e1c5272c871/" rel="bookmark">
			c语言图形打印 12345
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include&lt;stdio.h&gt; int main() { int i,d,n; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++) { for(d=n;d&gt;i;d--) { printf(" "); } for(d=1;d&lt;=i;d++) { printf("%d",d); } for(d=i-1;d&gt;=1;d--) { printf("%d",d); } printf("\n"); } for(i=1;i&lt;=n-1;i++) { for(d=1;d&lt;=i;d++) { printf(" "); } for(d=1;d&lt;=n-i;d++) \\ 注意1 和 n-i { printf("%d",d); } for(d=n-i-1;d&gt;=1;d--) { printf("%d",d); } printf("\n"); } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e89b9eeeadfc8e6a444cb2182099938/" rel="bookmark">
			基于统计复用的分组交换网络拥塞控制的科普解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近收到很多邮件咨询各种问题，一般而言我能回答的就都回答了，我自有自知之明，绝不是什么大牛，然而也并不是菜鸟，所以说不管什么问题，我不一定能完美回答，但却也不是一点都不懂，因此我会尝试着去作答。 由于最近写了几篇关于TCP拥塞控制的文章，就有人咨询我关于NCL，New Vegas，BBR等相关的问题，其实我知道他们的目的，不外乎两种原因，要么是自己想学习一下原理但可能遇到了看不懂的地方，前来询问，要么就是想自私的加速自己的TCP连接。对于前者，我非常乐意一起探讨，但对于后者，我只能回答“我也不知道”。其实，事实上我真的不知道如何给TCP加速，我唯一知道的就是，老老实实遵循现有的TCP逻辑，毕竟它们已经经过了各种环境的测试并被认为是合理的。对于如何去抢别人的带宽，我对这件事是非常非常反感的。因此我打算利用几乎一个通宵写下本文，意在告诉大家拥塞到底是怎么发生的，以及为什么拥塞是必然发生的，如果你真的理解了，你也就想通了为什么不要去抢别人的带宽，因为你做不到。 本文比较长，但是却比较轻松，科普性质的，没有任何理论基础的人都应该可以看懂，中间加了分割线作为休息和思考的界限。我先从微信朋友圈刷屏开始。 刷屏 &amp; BufferBloat the fucking网络拥塞的原因，其实很简单。 为什么网络会拥塞，答案其实是一个很简单的常识。我再一次以身试法站在一个殉道者的立场上来解释为什么网络会拥塞。我会告诉你们，在另一个网络，制造网络拥塞的那个人，就是我！ 然后你们就会理解到底什么是Buffer Bloat，最终你们会理解本文下面的部分以及BBR算法的核心理念。 我不再用交通拥堵来解释网络拥塞，因为首先大家都这么解释，其次很多人对此早已麻木，毕竟就算堵在路上，不是还可以刷朋友圈逛淘宝么？？所以，我尝试用微信朋友圈来解释网络拥塞，如果你想理解的更深刻，请加我为好友并且在彻底理解Buffer Bloat之前，不要屏蔽我，等你彻底理解了，删除我，删除之前，记得给个红包，5元即可！好吧，让我们上路。 如今大家都玩微信和微博，特别是微信。玩微信的几乎都有刷朋友圈的习惯。你们碰到过有人刷屏吗？肯定碰到过！你们讨厌吗？肯定早就把刷屏者屏蔽了。为了理解什么是Buffer Bloat并且基于此理解网络拥塞的本质，请暂时不要屏蔽这些人，如果你们觉得还想理解的更加深入些，请加上我。 把你们的大脑看作是一种处理信息的资源，微信朋友圈里的内容则是资源的一种。请问，你每天花多长时间刷朋友圈呢？每次多久呢？好吧，我暂且估计是每次10分钟。这10分钟，你能看到多少内容，你又想看到什么内容呢？你希望的朋友圈是这样的： 朋友1：
我昨天晚上挨了一顿打！...
朋友2：
我女朋友跟我分手了...
朋友3：
我把工作辞掉了，无所谓了...
朋友4：
周五我请看电影，想一起的请点个赞！...
朋友5：
人，要学会忍受孤独，因为你的孤独与他人无关【转载的鸡汤文】
朋友6：
年末有好礼，你来我就送！【卖东西的广告】
.... 不可否认，这里面有你不喜欢的内容，比如那个鸡汤可能是你妈转的，虽然不喜欢也还是要点个赞什么的，卖东西的是你朋友或者上司不能得罪...然而，你之所以会花时间浪费你的大脑资源来刷朋友圈，还是希望得到一些你想看的东西的，你非常想看到朋友的八卦新闻，失恋离职之类的，隐约中其实在你内心也希望看到别人发一个生病的消息，然后回复一句无所谓的表现存在感的安慰，当然，你还希望可以从朋友圈信息中得到利益，比如有人请客什么的。 对于发这些信息的人，他们渴望什么呢？既然发出去，就是希望有人看有人关注，不管什么目的，根本原因就是希望有人看！其目的不外乎以下几点： 1.太寂寞(注意，不是孤独)了，需要安慰。当然，也不一定会发信息到朋友圈，这类人估计会同步信息到各个微博，博客，Facebook什么的(漂流吧，我的寂寞和我的泪！)。
2.可能希望被某些人看到制造点影响力，比如让经理看到自己大半夜的电脑屏幕上有个Word文档，这样可能对自己加薪升职可以制造些筹码啥的...
3...我不多扯了，这些话题与本文无关！ 你希望别人看到你发的信息，你希望别人评论你的信息或者转发你的信息，你希望得到关注，你希望获得一种存在感，在人世嘈杂中，你很寂寞，你害怕天黑... -------------------------------------------- 以上有买有卖，你来我往，写者有心，读者有意，看似非常和谐，就算是有人在朋友圈卖东西，相信也是不敢恶意刷屏的，偶尔发个链接啥的也要用哀求的口吻。但是如果你加上我，就不一样了，注意，请不要屏蔽我。你会看到以下的信息： 我：
温州老板是傻逼！
我：
我是傻逼！但这并不意味着其它所有人都是智者！
我：
赐予我水母吧，我是带鱼...
我：
温州皮鞋，下雨进水不会胖！
我：
不是经理的博士，不是好经理；
不是博士的经理，不是好博士。
我：
.....
我：
....
我：
.....
我：
....
我：
.....
我：
....
朋友3：
我要崩溃了，谁可以来帮帮我啊救救我！
我：
都是傻逼！
我：
.....
我：
.... 你10分钟的大脑精力，全部被我占据！你不得不小心翼翼的往上翻屏，生怕漏掉了其它人发的重要信息(比如馈赠，求助之类的)，10分钟时间转瞬即逝，只要我能保证在其它人发的最后一条有价值信息后发的所有信息够你玩10分钟的，我就制造了严重的Buffer Bloat！Buffer就是你的大脑！在这10分钟时间内，你不能刷刷刷地掠过我发的信息，你必须小心翼翼地去”过滤“每一条信息，因为在你看到这个信息是我发的之前，你不能确认它不是你其它的朋友发的！ 然后，你的大脑崩溃了！这就是拥塞崩溃！哦，对了，你可以从此屏蔽我，但现在还不是时候，因为我接下来还要再讲讲网络突发。 如果说上面描述的我的行为是一种恶意制造Buffer Bloat导致了你的脑爆，那么下面的这种方式，则是一种正常的测试，我收回我的恶意。 前几天，真的是前几天，我做了一个实验，那就是把我10月份以来发的所有朋友圈信息，全部删除，然后将它们全部在昨晚一次性发布。在删除之前，我的信息看起来是下面这个样子： 我-2016/10/01：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e89b9eeeadfc8e6a444cb2182099938/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/864a5cfa7e4367c28f11d408eaa9e6e5/" rel="bookmark">
			使用python对中文文档进行词频统计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、使用jieba先对中文文档进行分词处理 需要处理的clean_data.csv文件内容（三列）
http://you.ctrip.com/travels/1322/1360550.html 地中海邮轮+罗马深度自由行 宅猫行天下 http://you.ctrip.com/travels/1400/1600356.html 柏林&amp;安纳西 老鼠m
import sys reload(sys) sys.setdefaultencoding("utf-8") import jieba import jieba.analyse wf = open('clean_title.txt','w+') for line in open('/root/clean_data/clean_data.csv'): item = line.strip('\n\r').split('\t') //制表格切分 # print item[1] tags = jieba.analyse.extract_tags(item[1]) //jieba分词 tagsw = ",".join(tags) //逗号连接切分的词 wf.write(tagsw) wf.close() 输出的clean_title.txt内容 邮轮,地中海,深度,罗马,自由纳西,柏林签证,步行,三天,批准申根,手把手,签证,申请,如何赞爆,法兰,穿越,葡萄酒,风景,河谷,世界欧洲颜色,一种,国家,一个水族箱,帕劳,七日,上帝奥林匹亚,跑步圣托, 里尼,文明古国,探访,爱琴海,魅力,希腊 2、统计词频
#!/usr/bin/python # -*- coding:utf-8 -*- word_lst = [] word_dict= {} with open('/root/clean_data/clean_title.txt') as wf,open("word.txt",'w') as wf2: //打开文件 for word in wf: word_lst.append(word.split(',')) //使用逗号进行切分 for item in word_lst: for item2 in item: if item2 not in word_dict: //统计数量 word_dict[item2] = 1 else: word_dict[item2] += 1 for key in word_dict: print key,word_dict[key] wf2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/864a5cfa7e4367c28f11d408eaa9e6e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/264f0b9e35ec4fc290b4499ddb3bb2b5/" rel="bookmark">
			ROS-----pluginlib使用总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 简介
pluginlib是一个C++库，可以实现为一个ROS包动态的加载和卸载插件。这里的插件通常是一些功能类，且以运行时可动态加载的库（如共享对象，动态链接库）的形式存在。借助pluginlib的帮助，用户不必关心自己的应用程序该如何链接包含自己想使用的的class的库（如定义class的头文件在哪里，如何定义的），因为pluginlib会在你调用时自动打开你需要的插件库（Note：需要提前将插件库注册到pluginlib）。使用插件来扩展或者修改应用程序的功能非常方便，不用改动源码重新编译应用程序，通过插件的动态加载即可完成功能的扩展和修改。
2 插件编写
pluginlib利用了C++多态的特性，不同的插件只要使用统一的接口，便可以替换使用。这样用户通过调用在插件中实现的统一的接口函数，不需要更改程序，也不需要重新编译，更换插件即可实现功能修正。
利用pluginlib编写插件的方法大致包括如下四步：
创建插件基类，定义统一接口（如果为现有接口编写插件，则跳过该步）编写插件类，继承插件基类，实现统一接口导出插件，并编译为动态库将插件加入ROS系统，使其可识别和管理
2.1 创建插件基类 首先，创建工作空间，创建后如下所示
其次，开始编写插件基类，基类所在头文件polygon_base.h放在include/my_plugin_test下即可，
#ifndef POLYGON_BASE_H_ #define POLYGON_BASE_H_ namespace polygon_base { class Polygon{ public: Polygon() {}; virtual ~Polygon() {}; virtual void init(float side_len) = 0; virtual float area() = 0; }; }; #endif 2.2 创建插件类
所插件类的头文件polygon_plugin.h在放在include/my_plugin_test目录下。
#ifndef POLYGON_PLUGIN_H_ #define POLYGON_PLUGIN_H_ #include &lt;cmath&gt; #include &lt;my_plugin_test/polygon_base.h&gt; namespace polygon_plugin{ class Square: public polygon_base::Polygon{ public: Square() {}; virtual ~Square() {}; virtual void init(float side_len) { this-&gt;side_len = side_len; } virtual float area() { return (side_len * side_len); } private: float side_len; }; class Triangle: public polygon_base::Polygon{ public: Triangle() {}; virtual ~Triangle() {}; virtual void init(float side_len) { this-&gt;side_len = side_len; } virtual float area() { return 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/264f0b9e35ec4fc290b4499ddb3bb2b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c91012f106c5549ec71a105f606373c9/" rel="bookmark">
			由一个“两次请求”引出的Web服务器跨域请求访问问题的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们公司的项目都是前后端分离的，上线几个月以来，发现一个很奇怪的问题，每次前端发起请求，通过浏览器的开发者工具都能看到在Network下同一个url有两条请求，第一条请求的Method为OPTIONS，第二条请求的Method才是真正的GET或者POST，并且，第一条请求无数据返回，第二条请求才会返回正常的数据。
发现这个问题之后，立即组织搜索问题产生的原因以及解决方案。在网上搜索了大量资料，得到的一个结论是：第一个OPTIONS的请求是由Web服务器处理跨域访问引发的。网上资料显示，OPTIONS是一种“预检请求”，浏览器在处理跨域访问的请求时如果判断请求为复杂请求，则会先向服务器发送一条预检请求，根据服务器返回的内容浏览器判断服务器是否允许该请求访问。如果web服务器采用cors的方式支持跨域访问，在处理复杂请求时这个预检请求是不可避免的。
查询代码发现，我们的web服务器确实采用的是cors来解决跨域访问的问题，并且我们在header中添加了自定义参数，导致我们的每次请求都为复杂请求，从而产生了每次请求都会发送两条请求的现象。
问题的原因找到了，就要想办法解决这个问题。既然浏览器在处理复杂请求时，不可避免的要发送预检请求，那么能否减少预检请求的次数呢？比如，预检一次设置一个有效期，在有效期内不再重复预检。顺着这个思路，继续搜索相关资料，最终发现设置Access-Control-Max-Age这个参数即可达到预期目标。该参数用来指定本次预检请求的有效期，单位为秒。在服务器上设置该参数之后，问题解决了，大快人心！！！
参考资料：http://blog.csdn.net/charleslei/article/details/51906635
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44e2829c54934022ca0a7aeaa80fab05/" rel="bookmark">
			老电脑跑win7卡慢的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的09年的ideaPad Y450，cpu：T9800 双核2.8GHz 内存：4G 1366hz 跑了几年的win7，越跑越卡，终于忍受不了，重装了xp 64位，结果64位的xp各种软件不兼容，而且用起来也没感觉快，而且系统UI越看越丑，还是换回了win7.
但问题是重装了win7，系统开机就卡的要死，内存占用率大约3G多，我可就开了个浏览器和QQ而已啊，所以就找了找原因。
经查看进程，发现svchost.exe占用了约2个多G的内存，而这个进程是干什么的呢？1.提高系统性能 2.Windows Update
到计算机→管理→服务和应用程序→服务，找到两个服务：Superfetch 和 windowUpdate ，都给禁用掉，瞬间，系统内存由3G降到了600M+，结果就是系统不再卡顿。
（不用担心关闭了WindowsUpdate后系统更新问题，下载个360安全卫士国际版，一个软件，杀毒+安全卫士全搞定，还能打补丁，国际版清爽，好用，而且他们不会瞎给你装助手啦，软件管家啦等等各种你不想要的全家桶）
又发现了一个进程占用cpu资源达49%之多，进程名为 mscorsvw.exe，经查，这是一个.net预编译进程，是win7SP1加进来的，严重拖慢了cpu的执行效率，貌似不执行.net程序就没什么用吧，同样，禁用掉这个服务：Microsoft .NET Framework NGEN，如果是64位的系统，会有俩，Microsoft .NET Framework NGEN x64和Microsoft .NET Framework NGENx32，都禁用掉，这样cpu占用率也下来了。
以上几个进程开机就占着宝贵的资源却没做任何有用的工作，只是给普通用户带来了“自己的老电脑越用越卡顿，估计是硬件老化了吧，看来是该换电脑了”的假象，不知道这是微软和PC厂商共同的阴谋还是其他狗屁原因，反正绝大多数的人根本不知道自己的电脑为什么这么卡，奇怪，我明明是刚装的系统啊。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ca88e43764db09099efce9ba38e9b41/" rel="bookmark">
			sscanf函数和正则表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看了几篇介绍sscanf函数，真是发现自己好多东西没理解透，详细介绍使用在sscanf中使用正则表达式。
第一篇：
此文所有的实验都是基于下面的程序：
char str[10];
for (int i = 0; i &lt; 10; i++) str[i] = '!';
执行完后str的值为
str = "!!!!!!!!!!"
我们把str的每个字符都初始化为惊叹号，当str的值发生变化时，使用printf打印str的值，对比先前的惊叹号，这样就可以方便的观察str发生了怎样的变化。下面我们做几个小实验，看看使用sscanf和正则表达式格式化输入后，str有什么变化。
实验1：
sscanf( "123456" , "%s" , str) ; ---------str的值为 "123456\0!!!"
这个实验很简单，把源字符串"123456"拷贝到str的前6个字符，并且把str的第7个字符设为null字符，也就是\0
实验2：
sscanf( "123456" , "%3s" , str) ; ---------str的值为 "123\0!!!!!!"
看到没有，正则表达式的百分号后面多了一个3，这告诉sscanf只拷贝3个字符给str，然后把第4个字符设为null字符。
实验3：
sscanf( "aaaAAA" , "%[a-z]" , str) ; ---------str的值为 "aaa\0!!!!!!"
从这个实验开始我们会使用正则表达式，括号里面的a-z就是一个正则表达式，它可以表示从a到z的任意字符，
在继续讨论之前，我们先来看看百分号表示什么意思，%表示选择 ，%后面的是条件，比如实验1的"%s"，s是一个条件，表示任意字符，"%s"的意思是：只要输入的东西是一个字符，就把它拷贝给str。实验2 的"%3s"又多了一个条件：只拷贝3个字符。实验3的“%[a-z]”的条件稍微严格一些，输入的东西不但是字符，还得是一个小写字母的字符，所以实验 3只拷贝了小写字母"aaa"给str，别忘了加上null字符。
实验4：
sscanf( "AAAaaaBBB" , "%[^a-z]" , str) ; ---------str的值为 "AAA\0!!!!!!"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ca88e43764db09099efce9ba38e9b41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b91957d31d594601206a5f55931a071c/" rel="bookmark">
			正定矩阵（definite matrix）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 基本定义 在线性规划中，一个对称的 n×n 的实值矩阵 M，如果满足对于任意的非零列向量 z，都有 zTMz&gt;0.
更一般地，对于 n×n 的 Hermitian 矩阵（原矩阵=共轭转置，aij=a¯ji，或者 A=AT¯¯¯¯¯），对于任何的非零列向量 z，z⋆Mz&gt;0；
2. 定理和推论 对称阵 A 为正定的充分必要条件是：
A 的特征值全为正；A 的各阶主子式都为正；对称阵 A 为负定的充分必要条件是：奇数阶主子式为负，偶数阶主子式为正；
3. 正定的几何意义 设 f(x,y) 是二元正定二次型，则 f(x,y)=c （c 为大于 0 的常数）的图形是以
3. 简单举例 单位矩阵 I 是正定矩阵，
zTIz=∥z∥2 对于任何实可逆矩阵，ATA 是正定的，因为对任何非零列向量 z，都有 zTATAz=∥Az∥2，可逆矩阵保证了 Az≠0；
转载于:https://www.cnblogs.com/mtcnn/p/9422877.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/faae6054170f18b461b166a3c4cc3475/" rel="bookmark">
			Linux上Redis加入服务（开机自启）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网上有很多这些文章，但是都不完整，我自己实践成功让redis开机自动启动。
一.先下载解压redis，然后进入utils目录 二.打开文件redis_init_script 三.根据实际环境重新写路径，注意最后的两行蓝色注释要加上。PIDFILE先去/var/run看看有没有redis开头的pid文件，没有的话先去redis-3.2.5/src下执行 ./redis-server ../redis.conf 手动启动redis，然后pid结尾的文件就会生成。 四.将redis_init_script 脚本拷贝到 /etc/init.d 下 修改名字为 redis 五. chmod +x /etc/init.d/redis 修改读写权限
六.重新回来redis目录打开redis.conf,修改如下图，no改成yes 六.尝试启动或停止redis service redis start service redis stop
七. 开启服务自启动 chkconfig redis on
八.加入开机自启服务 chkconfig –add redis
大功完成！机器重启就会看到redis已经启动了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61dc906e85cc67c923d2e7960af2678b/" rel="bookmark">
			批量下载指定公司专利信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		领导安排了一个任务，下载竞争对手公司申请的专利信息，主要对手包括以下几个：Vestas Wind System A/S 集团，歌美飒技术集团股份有限公司，GE，西门子。
google专利被墙了，不好弄，发现美国专利及商标局这个网站还健在，打开https://www.uspto.gov/，发现美帝还是比较良心的，网站简约，搜索人性，检索迅速，比较一下国内的这个网站http://cpquery.sipo.gov.cn/真是高下立判。
检索界面如下：
检索结果如下： 任务就是把这些都批量下载下来，形成一个记录信息的txt文档，同时下载全文pdf，两个文件放进一个文件夹。
talk is cheap，show the code
#爬取美国专利网指定公司的专利 #by---jzx #2016-11-8 import re from bs4 import BeautifulSoup import requests import os #存储数据 def store_data(dictionary, search_string): dictionary['patent_name'] = dictionary['patent_name'].replace('\n', ' ').replace('"', ' ')[:100] folder_name = './' + search_string + '/' + dictionary['patent_name'] + '(' + dictionary['patent_code'] + ')' if not os.path.exists(folder_name): os.makedirs(folder_name) filename = folder_name + '/data.txt' pdfname = folder_name + '/full_pdf.pdf' data_list = ['patent_code', 'patent_name', 'year', 'inventor_and_country_data', 'description', 'full_pdf_file_link'] with open(filename, 'w') as f: for data in data_list: f.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61dc906e85cc67c923d2e7960af2678b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/300/">«</a>
	<span class="pagination__item pagination__item--current">301/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/302/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>