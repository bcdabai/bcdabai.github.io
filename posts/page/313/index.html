<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6d1253774fbd3e554b6d0db0a78bac5/" rel="bookmark">
			尚未备份数据库 &#34;TEST&#34; 的日志尾部。如果该日志包含您不希望丢失的工作，请使用 BACKUP LOG WITH NORECOVERY 备份该日志。请使用 RESTORE 语句的 WITH REPL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天，尝试着第一次在SQL SERVER桑还原数据库完整备份时，如语句：
USE master;
RESTORE DATABASE TEST FROM 我的备份设备1 WITH FILE=8,NORECOVERY
报错：
消息 3159，级别 16，状态 1，第 2 行
尚未备份数据库 "TEST" 的日志尾部。如果该日志包含您不希望丢失的工作，请使用 BACKUP LOG WITH NORECOVERY 备份该日志。请使用 RESTORE 语句的 WITH REPLACE 或 WITH STOPAT 子句来只覆盖该日志的内容。 消息 3013，级别 16，状态 1，第 2 行 RESTORE DATABASE 正在异常终止。
出错原因：
可能是你的数据库服务器中存在同名数据库！
解决办法：
在WITH 后加入 REPLACE 或 STOPAT 就可以还原啦 ！但同名数据库可能被覆盖！
如：
USE master;
RESTORE DATABASE TEST
FROM 我的备份设备1
WITH FILE=8,NORECOVERY,REPLACE
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/871f8e822e74ece6b3fd1a733b9fcdaa/" rel="bookmark">
			shell之sed命令详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sed概念
sed编辑器逐行处理文件。具体过程如下：首先sed把当前正在处理的行保存在一个临时缓存区中（也称为模式空间），然后处理临时缓冲区中的行，每处理完一行就将其从临时缓冲区删除，然后将下一行读入，进行处理和显示。处理完输入文件的最后一行后，sed便结束运行。sed把每一行都存在临时缓冲区中，对这个副本进行编辑，所以不会修改原文件（针对读取）。
调用sed的两种形式
sed [options] 'command' file（s） sed [options] -f scriptfile file（s）
用法
sed [选项]... {脚本(如果没有其他脚本)} [输入文件]...
-n, --quiet, --silent
取消自动打印模式空间
-e 脚本, --expression=脚本
添加“脚本”到程序的运行列表
-f 脚本文件, --file=脚本文件
添加“脚本文件”到程序的运行列表
--follow-symlinks
follow symlinks when processing in place; hard links
will still be broken.
-i[SUFFIX], --in-place[=SUFFIX]
edit files in place (makes backup if extension supplied).
The default operation mode is to break symbolic and hard links.
This can be changed with --follow-symlinks and --copy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/871f8e822e74ece6b3fd1a733b9fcdaa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64977fc2cafd52fb06adea840513f0bc/" rel="bookmark">
			准确率与召回率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准确率与召回率（Precision &amp; Recall）
精度和召回率是广泛用于信息检索和统计学分类领域的两个度量值，用来评价结果的质量。其中精度是检索出相关文档数与检索出的文档总数的比率，衡量的是检索系统的查准率；召回率是指检索出的相关文档数和文档库中所有的相关文档数的比率，衡量的是检索系统的查全率。
一般来说，Precision就是检索出来的条目（比如：文档、网页等）有多少是准确的，Recall就是所有准确的条目有多少被检索出来了。
正确率、召回率和 F 值是在鱼龙混杂的环境中，选出目标的重要评价指标。不妨看看这些指标的定义先：
1. 正确率 = 提取出的正确信息条数 / 提取出的信息条数 2. 召回率 = 提取出的正确信息条数 / 样本中的信息条数 两者取值在0和1之间，数值越接近1，查准率或查全率就越高。 3. F值 = 正确率 * 召回率 * 2 / (正确率 + 召回率) （F 值即为正确率和召回率的调和平均值）
不妨举这样一个例子：某池塘有1400条鲤鱼，300只虾，300只鳖。现在以捕鲤鱼为目的。撒一大网，逮着了700条鲤鱼，200只虾，100只鳖。那么，这些指标分别如下：
正确率 = 700 / (700 + 200 + 100) = 70%
召回率 = 700 / 1400 = 50%
F值 = 70% * 50% * 2 / (70% + 50%) = 58.3%
不妨看看如果把池子里的所有的鲤鱼、虾和鳖都一网打尽，这些指标又有何变化：
正确率 = 1400 / (1400 + 300 + 300) = 70%
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64977fc2cafd52fb06adea840513f0bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e3414caf2a9b57520bab79f776fdb43/" rel="bookmark">
			(转)linux bash shell 入门教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Shell Script(bash)简介
众所皆知地，UNIX上以小工具著名，利用许多简单的小工具，来完成原本需要大量软体开发的工作，这一点特色，使得UNIX成为许多人心目中理想的系统平台。
在众多的小工具中，Shell Script算得上是最基本、最强大、运用最广泛的一个。它运用围之广，不但从系统启动、程式编译、定期作业、上网连线，甚至安装整个Linux系统，都可以用它来完成。
因为Shell Script是利用您平日在使用的一些指令，将之组合起来，成为一个"程式"。如果您平日某些序列的指令下得特别频繁，便可以将这些指令组合起来，成为另一个新的指令。这样，不但可以简化并加速操作速度，甚至还可以干脆自动定期执行，大大简化系统管理工作。
*************************
Bash(GNU Bourne-Again SHell)是许多Linux平台的内定Shell，事实上，还有许多传统UNIX上用的Shell，像tcsh、csh、ash、bsh、ksh等等，Shell Script大致都类同，当您学会一种Shell以后，其它的Shell会很快就上手，大多数的时候，一个Shell Script通常可以在很多种Shell上使用。
这里我介绍您bash的使用方法。事实上，当您"man bash"时，就可以看到bash的说明书，不过对许多人来说，这份说明书犹如"无字天书"一样难懂。这份文件，主要资料来源为"man bash"，我加上一些实际日常的应用例来说明。希望这样能让那些始终不得其门而入的人们，多多少少能有点概念。
教学例子
"Hello world" Shell Script
照传统程式教学例，这一节介绍Shell Script的"Hello World"如何撰写。
*************************
#!/bin/sh
# Filename : hello
echo "Hello world!"
*************************
大家应该会注意到第一行的"#!/bin/sh"。在UNIX下，所有的可执行Script，不管是那一种语言，其开头都是"#!"，例如Perl是"#!/usr/bin/perl"，tcl/tk是"#!/usr/bin/wish"，看您要执行的Script程式位置在那里。您也可以用"#!/bin/bash"、"#!/bin/tcsh"等等，来指定使用特定的Shell。
echo是个bash的内建指令。
*************************
接下来，执行hello这个script:
要执行一个Script的方式有很多种。
*************************
第一种 : 将hello这个档案的权限设定为可执行。
[foxman@foxman bash]# chmod 755 hello
执行
[foxman@foxman bash]# ./hello
hello world
*************************
第二种 : 使用bash内建指令"source"或"."。
[foxman@foxman bash]# source hello
hello world
或
[foxman@foxman bash]# . hello
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e3414caf2a9b57520bab79f776fdb43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/580369bc47c7d68c48628098cb383fa0/" rel="bookmark">
			Delphi7中的函数与过程（Function and Procedure）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.锁住空间的位置，可以选择Edit---&gt;Lock component ,也可以在窗体设计面板下面找到组件排版功能栏，第二排里面有个带锁的图标，表示组件可以被锁住。点击一下，组件的大小和位置就不可改变了。
2.procedure没有返回值，Function有返回值；
3.为过程生明添加过程定义；Ctrl + Shift + C 快捷键；
如在过程生命部分写一个过程 procedure myProc(var str1,str2,str3:string);
按一下快捷键，就可以自动生成过程定义体，在里面编辑即可；
4.Delphi 有点像C语言，先得声明函数，然后才可以定义函数；有点像Java中的接口，但是接口是不允许定义变量的。有点像类，但是类在定义的时候就可以实现函数，而且Java中没有过程和函数一说。有点像抽象类，但是抽象类必须有abstract 关键字声明，有点像PL/SQL，但是PL/SQL不是面向对象编程的。DELphi真几把奇怪。*_*;
5.Delphi中字符串的拼接，用+号
如 messageshow('abcd'+ 'cdef' + 'mopk‘);显示出来的就是，abcdcdefmopk;
6.如果在定义的时候指定过程里的变量为var，而在调用的时候赋值以常量，会发生这样的错误：Constant object cannot be passed as var parameter;这个错误
从错误说明上可以看出，是将常量赋值给变量时发生的错误；
7，函数中的Result是函数名的一个别名，与函数具有相同的返回类型；
8,按值传参和按址传参，不用var是按值传参，用var是按址传参。
9,delphi中的function只可以返回简单的数据类型，不可以像java一样返回复杂的数据类型；
10.在过程和函数中，常数参数在过程或函数体中是不可以改变的。而且也不可以将常数参数当做实参；
11.常数参数用const修饰，但是常数参数如何定义呢？
12.如果在函数声明的时候为参数指定了默认值，则可以不带入实参。如
function myfunc(i:Integer=20;j:Integer=30);
调用的时候可以调用myfunc();也可以调用myfunc(2);也可以调用myFunc（2,3）；默认参数只能出现在最后面；必须为每个参数指定默认参数，而不能一起搞。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bfb496ca53241d9432ab8a2759eb86f/" rel="bookmark">
			linux shell 屏幕显示stdout stderr的同时 分别重定向到文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		I'm assuming you want to still see STDERR and STDOUT on the terminal. You could go for Josh Kelley's answer, but I find keeping a tail around in the background which outputs your log file very hackish and cludgy. Notice how you need to keep an exra FD and do cleanup afterward by killing it and technically should be doing that in a trap '...' EXIT.
There is a better way to do this, and you've already discovered it: tee.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bfb496ca53241d9432ab8a2759eb86f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd4645a8c8d264bb5f145688edfdc5eb/" rel="bookmark">
			yum 命令 update 与 upgrade 的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		man yum ，以及测试（centos 6.4版本）后，我认为，update 与 upgrade 并没有实质性的区别。网上说：
yum -y update
升级所有包，改变软件设置和系统设置，系统版本内核都升级
yum -y upgrade
升级所有包，不改变软件设置和系统设置，系统版本升级，内核不改变
这是错误的！ update If run without any packages, update will update every currently installed package. If one or more packages or package globs are specified, Yum will only update the listed packages. While updating packages, yum will ensure that all dependencies are satisfied. (See Specifying package names for more information) If the packages or globs speci- fied match to packages which are not currently installed then update will not install them.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd4645a8c8d264bb5f145688edfdc5eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8bafb376e419679af1dd944c93ede04/" rel="bookmark">
			深入剖析Socket---TCP通信底层队列填满的死锁问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基础准备 首先需要明白数据传输的底层实现机制，在http://blog.csdn.net/ns_code/article/details/15813809这篇博客中有详细的介绍，在上面的博客中，我们提到了SendQ和RecvQ缓冲队列，这两个缓冲区的容量在具体实现时会受一定的限制，虽然它们使用的实际内存大小会动态地增长和收缩，但还是需要一个硬性的限制，以防止行为异常的程序所控制的单一TCP连接将系统的内存全部消耗。正式由于缓冲区的容量有限，它们可能会被填满，事实也正是如此，如果与TCP的流量控制机制结合使用，则可能导致一种形式的死锁。
一旦RecvQ已满，TCP流控制机制就会产生作用（使用流控制机制的目的是为了保证发送者不会传输太多数据，从而超出了接收系统的处理能力），它将阻止传输发送端主机的SendQ中的任何数据，直到接收者调用输入流的read（）方法将RecvQ中的数据移除一部分到Delivered中，从而腾出了空间。发送端可以持续地写出数据，直到SendQ队列被填满，如果SendQ队列已满时调用输出流的write（）方法，则会阻塞等待，直到有一些字节被传输到RecvQ队列中，如果此时RecvQ队列也被填满了，所有的操作都将停止，直到接收端调用了输入流的read（）方法将一些字节传输到了Delivered队列中。
引出问题 我们假设SendQ队列和RecvQ队列的大小分别为SQS和RQS。将一个大小为n的字节数组传递给发送端write（）方法调用，其中n &gt; SQS，直到有至少n-SQS字节的数据传递到接收端主机的RecvQ队列后，该方法才返回。如果n的大小超过了SQS+RQS，write（）方法将在接收端从输入流读取了至少n-(SQS+RQS)字节后才会返回。如果接收端没有调用read（）方法，大数据量的发送是无法成功的。特别是连接的两端同时分别调用它的输出流的write（）方法，而他们的缓冲区大小又大于SQS+RQS时，将会发生死锁：两个write操作都不能完成，两个程序都将永远保持阻塞状态。
下面考虑一个具体的例子，即主机A上的程序和主机B上的程序之间的TCP连接。假设A和B上的SQS和RQS都是500字节，下图展示了两个程序试图同时发送1500字节时的情况。主机A上的程序中的前500字节已经传输到另一端，另外500字节已经复制到了主机A的SendQ队列中，余下的500字节则无法发送，write（）方法将无法返回，直到主机B上程序的RecvQ队列有空间空出来，然而不幸的是B上的程序也遇到了同样的情况，而二者都没有及时调用read（）方法从自己的RecvQ队列中读取数据到Delivered队列中。因此，两个程序的write（）方法调用都永远无法返回，产生死锁。因此，在写程序时，要仔细设计协议，以避免在两个方向上传输大量数据时产生死锁。
示例分析 回顾前面几篇博客中的TCP通信的示例代码，基本都是只调用一次write（）方法将所有的数据写出，而且我们测试的数据量也不大。考虑一个压缩字节的Demo，客户端从文件中读取字节，发送到服务端，服务端将受到的文件压缩后反馈给客户端。 这里先给出代码，客户端代码如下：
[java] view plain copy print ? import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.net.Socket; public class CompressClientNoDeadlock { public static final int BUFSIZE = 256; // Size of read buffer public static void main(String[] args) throws IOException { if (args.length != 3) // Test for correct # of args throw new IllegalArgumentException("Parameter(s): &lt;Server&gt; &lt;Port&gt; &lt;File&gt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8bafb376e419679af1dd944c93ede04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9eb3125863f55d48f649491b348f6da4/" rel="bookmark">
			CSS文字或图片悬浮于另一张图片上，大小宽度适配手机的！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;div class="header clearfix"&gt; &lt;div class="hd-c"&gt; &lt;div class="banner"&gt; &lt;div class="pic"&gt; &lt;img src="1.jpg" class="png-24" alt="banner"&gt;&lt;!--背景图--&gt; &lt;/div&gt;	&lt;div class="frame"&gt; &lt;img class="changing-over" src="progress.gif"&gt;&lt;!--悬浮图--&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 上面是HTML布局，下面是CSS样式
.clearfix { float: none; clear: both; } .header { position: relative; width: 100%; height: auto; } .hd-c { position: relative; overflow: hidden; width: 100%; height:auto; -moz-background-size: 100% 100%; -o-background-size: 100% 100%; -webkit-background-size: 100% 100%; -ms-background-size: 100% 100%; } .hd-c .banner { width: 100%; height: auto; position: relative; margin: 0 auto; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9eb3125863f55d48f649491b348f6da4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/864da8d6c5f2eb541362ed45c9abb928/" rel="bookmark">
			PLSQL中文乱码问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题导致：
发布在win2008 64bit操作系统的网站，由于某些原因要改成在32bit模式下运行，在iis上面设置了对应的模式后，整个网站访问oracle记录的时候，结果集中的中文都乱码。在该服务器上面用plsql访问也同样有这个问题。
原因分析：
由于plsql这个工具是32bit的工具，该服务器也装了32bit的oracle客户端，plsql是调用该oracle客户端进行访问的，所以plsql出现的乱码和网站出现的乱码是同一个问题引起的。
解决办法为：
创建一个名为“NLS_LANG”的系统环境变量，设置其值为“SIMPLIFIED CHINESE_CHINA.ZHS16GBK”，然后重新启动 pl/sql developer，这样检索出来的中文内容就不会是乱码了。如果想转换为UTF8字符集，可以赋予“NLS_LANG”为 “AMERICAN_AMERICA.UTF8”，然后重新启动 pl/sql developer。其它字符集设置同上。
结果：
网站访问ok，plsql中也ok！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4645a854e26173f4cb81e9207f89cfad/" rel="bookmark">
			【总结】用户权限设置和进程权限提升
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用某些Windows API的时候需要提升进程的默认权限，例如RegRestoreKey需要SE_RESTORE_NAME 和SE_BACKUP_NAME 权限。在这种情况下，我们需要使用到一组Windows API提升进程权限。需要的函数有：
1.OpenProcessToken
2.LookupPrivilegeValue
3.AdjustTokenPrivileges
使用这组函数提升权限的前提是进程具备该权限，只是访问令牌中没有启用该权限。如果进程的访问令牌中本身就没有关联该权限，这AdjustTokenPrivileges函数调用将会返回ERROR_NOT_ALL_ASSIGNED（值为1300L）的错误码。如何让进程具有该权限？可以通过“控制面板”—“管理工具”—“本地安全策略”—“本地策略”—“用户权利指派”设置将该权限关联到指定的用户分组或用户上。具体设置如下图所示：
win7之本地安全策略启动:
1.单击“控制面板”--“系统和安全”--“管理工具”--“本地安全策略”，会进入“本地安全策略”界面。 2..win+R--secpol.msc，也可以。
利用AdjustTokenPrivileges提升权限，准确的说不是提升，而是将访问令牌中禁用的权限启用。
BOOL SetPrivilege( HANDLE hToken, // access token handle LPCTSTR lpszPrivilege, // name of privilege to enable/disable BOOL bEnablePrivilege // to enable or disable privilege ) { TOKEN_PRIVILEGES tp; LUID luid; if ( !LookupPrivilegeValue( NULL, // lookup privilege on local system lpszPrivilege, // privilege to lookup &amp;luid ) ) // receives LUID of privilege { printf("LookupPrivilegeValue error: %u\n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4645a854e26173f4cb81e9207f89cfad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccaf32c5ea9ca1f8b117c5c8531dd985/" rel="bookmark">
			Css：实现背景色透明/半透明而内容不透明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.针对IE浏览器
.demo{ background-color:transparent; filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=#26FFFFFF, endColorstr=#26FFFFFF) } 2.针对FF，谷歌等浏览器 .demo{ background:transparent;&lt;!--背景透明--&gt; color:#fff;&lt;!--字体颜色--&gt; background-color:rgba(255,255,255,0.15)&lt;!--最后一个参数设置透明度，前面三个是RGB颜色值--&gt; } 注意 ：如果容器是a标签的话，需要给a标签加上“display:block”属性。在手机上显示，都是用第二种样式。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ec7e6c65e468e4ee7c0242d54648525/" rel="bookmark">
			PHP导出CSV后，不换行分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PHP导出CSV后，不换行分析 大家在做导出CSV的时候，是否跟我一样，遇到这样的问题。如下面的代码，正常来说，是没有错误的，导出来，是没有问题，但是，导出来后，用Excel打开时，发现，不换行了。 //模似一个从数据库取出来的数据; $body = ""; $data = array( array('id'=&amp;gt;1,'name'=&amp;gt;'Intril','sex'=&amp;gt;'boy'), array('id'=&amp;gt;2,'name'=&amp;gt;'Jack','sex'=&amp;gt;'girl'), array('id'=&amp;gt;3,'name'=&amp;gt;'Lucy','sex'=&amp;gt;'girl'), array('id'=&amp;gt;4,'name'=&amp;gt;'灿灿','sex'=&amp;gt;'boy'), array('id'=&amp;gt;5,'name'=&amp;gt;'Never','sex'=&amp;gt;'boy'), ); $th = 'id,name,sex,\r\n'; foreach($data as $val){ if(!empty($val)){ $body .= implode(',',$val).'\r\n'; } } $filename = "exampl可能有中文"; header("Content-Disposition: attachment; filename=".iconv("utf-8","gbk",$filename).".csv");//处理中文乱码 header('Content-Type:APPLICATION/OCTET-STREAM'); echo iconv("utf-8","gbk",$th);//处理中文乱码 echo iconv("utf-8","gbk",$body);//处理中文乱码 其实出在‘’号上面，由于在PHP中，用‘’比“”性能上来说更好一点，但是正是这个，在导出的CSV文件中，使的\r\n这个符号没有解析出来，导至导出的CSV在Excel中不能换行。如上面的代码，我只要换成下面就可以 &lt;?PHP //模似一个从数据库取出来的数据; $body = ""; $data = array( array('id'=&amp;gt;1,'name'=&amp;gt;'Intril','sex'=&amp;gt;'boy'), array('id'=&amp;gt;2,'name'=&amp;gt;'Jack','sex'=&amp;gt;'girl'), array('id'=&amp;gt;3,'name'=&amp;gt;'Lucy','sex'=&amp;gt;'girl'), array('id'=&amp;gt;4,'name'=&amp;gt;'灿灿','sex'=&amp;gt;'boy'), array('id'=&amp;gt;5,'name'=&amp;gt;'Never','sex'=&amp;gt;'boy'), ); $th = "id,name,sex,\r\n"; foreach($data as $val){ if(!empty($val)){ $body .= implode(',',$val)."\r\n"; } } $filename = "exampl可能有中文"; header("Content-Disposition: attachment; filename="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ec7e6c65e468e4ee7c0242d54648525/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91aa88050a403bc2f076652d3dafe2c2/" rel="bookmark">
			对称加密算法与非对称加密算法的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 对称加密算法与非对称加密算法的区别 对称加密算法 对称加密算法是应用较早的加密算法，技术成熟。在对称加密算法中，数据发信方将明文（原始数据）和加密密钥一起经过特殊加密算法处理后，使其变成复杂的加密密文发送出去。收信方收到密文后，若想解读原文，则需要使用加密用过的密钥及相同算法的逆算法对密文进行解密，才能使其恢复成可读明文。在对称加密算法中，使用的密钥只有一个，发收信双方都使用这个密钥对数据进行加密和解密，这就要求解密方事先必须知道加密密钥。 对称加密算法的特点是算法公开、计算量小、加密速度快、加密效率高。不足之处是，交易双方都使用同样钥匙，安全性得不到保证。此外，每对用户每次使用对称加密算法时，都需要使用其他人不知道的惟一钥匙，这会使得发收信双方所拥有的钥匙数量成几何级数增长，密钥管理成为用户的负担。对称加密算法在分布式网络系统上使用较为困难，主要是因为密钥管理困难，使用成本较高。在计算机专网系统中广泛使用的对称加密算法有DES、IDEA和AES。 不对称加密算法 不对称加密算法使用两把完全不同但又是完全匹配的一对钥匙—公钥和私钥。在使用不对称加密算法加密文件时，只有使用匹配的一对公钥和私钥，才能完成对明文的加密和解密过程。加密明文时采用公钥加密，解密密文时使用私钥才能完成，而且发信方（加密者）知道收信方的公钥，只有收信方（解密者）才是唯一知道自己私钥的人。不对称加密算法的基本原理是，如果发信方想发送只有收信方才能解读的加密信息，发信方必须首先知道收信方的公钥，然后利用收信方的公钥来加密原文；收信方收到加密密文后，使用自己的私钥才能解密密文。显然，采用不对称加密算法，收发信双方在通信之前，收信方必须将自己早已随机生成的公钥送给发信方，而自己保留私钥。由于不对称算法拥有两个密钥，因而特别适用于分布式系统中的数据加密。广泛应用的不对称加密算法有RSA算法和美国国家标准局提出的DSA。以不对称加密算法为基础的加密技术应用非常广泛。 来自：http://blog.712100.com/23611/viewspace-16217 个人理解与总结： 1、基于DES加密算法理解对称加密算法 从DES加密算法可以体会到：对称加密算法在对数据进行加密和解密的过程中，都是使用了数据接收方的密钥(公钥和私钥)，具体做法就是，数据发送方使用接受方的公钥加密数据，而数据接收方使用自己的私钥机密数据，其实围绕的就是数据接收方的密钥。 2、基于RSA加密算法理解非对称加密算法 通过上面对非对称加密算法的叙述，我感觉理解不是很深刻。总体的感觉就是： (1) 基于RSA加密算法比较麻烦，因为RSA加密算法是基于一个大数n的，需要计算出一个密钥对(公钥和私钥)，但是这里公钥和私钥还是一对数，即公钥为(e,n)，私钥为(e,d). (2) 在数据发送方与接受发执行数据传输之前，保证了双方公钥的分发管理，加强了公钥的安全性(比之于在对称加密算法中：公钥就是完全公开的)，这个特点确实加强了加密数据的发送方的身份真实性。 还有待于继续深入理解。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60172482a06038496e0b093e31ad038a/" rel="bookmark">
			NRF24L01通道之我见及基于NRF24L01的无线组网方案的几点看法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说起NRF24L01，想必大家都会知道：通信速率快，使用方便，价格低廉，开发简单……尤其是玩单片机的孩子，这个是必不可少的。
在使用上，两点通信自然不用说，也就是配置个接收地址，配置个发射地址，然后对传就完了，网上例程很多，不赘述。不过小菜有一天突发奇想，用这个玩意来做个无线传感器网络怎么样？这么低廉的价格（做好的模块便宜的只要4~5块）应该是没有其他的可以比了，如能做成也是件功德无量的事了！于是乎就拿起datasheet细看了起来，然后就遇到这个数据通道的问题了……
按datasheet上的说法，一个NRF模块可接收6个不同数据通道的数据，那通道是什么意思呢？研究了一下，发现还有个前提，那就是不同的通道还要有相同的频率！如此说来，通道应该不是物理层上的区别（发射频率、调制方式……）了；再看，“每个通道需要有一个地址，而且不允许不同通道使用相同的地址” ，自觉这是最坑爹的一句话！而这些地址是在初始化的时候写入NRF24L01模块的，在实际使用过程中，我们发送数据和接收数据都不会再用到发送或接收地址了（增强型ShockBurst 模式下发送地址默认为接收通道地址0），再看看它的空中数据包的格式：
前导码 地址 3~5 字节
9 位 标志位
数据 1~32 字节
CRC 校验 0/1/2 字节 其实我们在后来操作的仅仅就是它的最大32字节的数据区！也就是说，通道实际就是你初始化时写到这些地址寄存器的地址值！从网络的角度来理解，也就是MAC地址！NRF模块自带了MAC层协议栈，可以实现自动的对数据包的识别，减去了用户在开发时的数据链路层的麻烦，让你不用担心地址问题和数据丢失重传的问题，但是，它的限制也正是在此！它在运行过程中可以识别的数据包的MAC地址值只有六个，其它的数据包模块都会将其丢弃，因此它就让你的网络节点数限制在了六个（不同MAC地址）！ 这对较大规模组网来说， 无疑是一个噩耗！
那么如果还想继续使用这个无线模块组网，一种解决办法就是，多个节点使用相同的发送通道和接收通道，这样不同模块间的数据都能够相互接收到，然后，再在这32个数据字节中选一个或两个作为网络地址位，通过这个网络地址来识别不同的模块，只要在网络密度及数据量不是特别大的情况下，基本就可以完成任务了。
但是，还有个新的问题来了！大家在进行数据收发的时候，可能都会考虑到数据的可靠性问题，而使用增强型ShockBurst 模式时，模块会自动进行应答（用户是不知道的），根据上面的方法，所有模块的通道（MAC地址）都设为相同，当一个模块发送数据时，其它所有在其无线覆盖范围内的模块都能够接受到这个数据，根据其MAC协议栈特性，所有的接受模块都会给发送模块以应答信号，那么，对发送模块而言，就无法知道到底是哪个接受模块发送来的数据了，也无法知道想要发送的数据已经准确到达，因此，这个基于MAC层的自动应答是完全没有用的！不仅如此，它还增大了空中数据碰撞的几率，反而降低了这个网络的可靠性！
这样，我们还是回归其原始的ShockBurst 发送模式，在这种模式下，去除了基于MAC层的自动应答，因此其空中数据包的体积也有所减小，如下：
前导码 地址 3~5 字节
数据 1~32 字节
CRC 校验 0/1/2 字节
那么，如果这个时候还想要继续保证数据传输的可靠性，就需要用户自己来定义新的应答方法了，根据数据包中的网络地址信息，实现新的应答，一种较好的方法是，在数据包字节中定义地址和数据包类型，然后接收模块就可以根据这个数据包类型决定是否需要进一步处理了，通过完善相应的协议机制，就可以基本实现一个小型的无线传感器网络了。
再回到通道的理念，单从无线传感器网络的角度来说，弄出这么一个东西，真的是多此一举，不仅限制了用户的扩展，还增加了一些无用的数据发射。但是，任何事情都是有利有弊的，通过通道机制，却又能防止其它非相同通道的数据被接收，其三到五个字节的可变地址值，大大增加了网络的安全性，使得不法分子失去了可趁之机；另一方面，利用通道原理，还可以实现对不同类别的设备的区别，例如，一个无线网内的温度采集节点、亮度采集节点等，这样，这个看似累赘的东西反而能使整个网络变得更清晰明了了。
除此之外，小菜还想了个非主流的方法，用通道实现一个六枝树（自创词，欢迎吐槽）的网络，也就是，每个父节点可以连接最多六个的不同通道的子节点，而每个子节点也可以连接最多六个的不同通道的孙子节点，这样，依次往下，也可以实现一个互不干扰的子网，不过，如何实现通道地址的设定就是一个新问题了，就留给感兴趣的大家去慢慢想吧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14b4ad867ea3641ac7ad1fbeae457544/" rel="bookmark">
			基于Android平台的大学生兼职系统（仿赶集网APP）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于LBS的分类信息服务，相信不少的大学生们都有兼职的经历，想要好的兼职机会么，请关注大学生兼职吧
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68acf55edef4dd04a8f4662c7049e78f/" rel="bookmark">
			临界区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 函数 EnterCriticalSection 和 LeaveCriticalSection 声明如下： ? 1 2 3 4 5 6 WINBASEAPI VOID WINAPI EnterCriticalSection( __inout LPCRITICAL_SECTION lpCriticalSection ); 是多线程中用来确保同一时刻只有一个线程操作被保护的数据的操作函数，相关的多线程数据操作函数还有： ? 1 2 3 4 5 6 InitializeCriticalSection(&amp;cs); //初始化临界区 EnterCriticalSection(&amp;cs); //进入临界区 //操作数据 MyMoney*=10; //所有访问MyMoney变量的程序都需要这样写Enter.. Leave... LeaveCriticalSection(&amp;cs); //离开临界区 DeleteCriticalSection(&amp;cs); //删除临界区 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2541cf1154a970f1c13ccbfd74c8541/" rel="bookmark">
			object－c 文件基本读写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NSString *path = @"/Users/beyondsoft/Desktop/file.plist"; NSDictionary *dict = [[NSDictionary alloc]initWithObjectsAndKeys:@"one", @"1", @"2", @"two", @"three", @"5", nil]; [dict writeToFile:path atomically:YES]; [dict release]; NSDictionary *dict = [[NSDictionary alloc]initWithContentsOfFile:path]; NSLog(@"%@", dict); [dict release]; NSArray *array = [[NSArray alloc]initWithObjects:@"one", @"two", @"4", @"6", nil]; [array writeToFile:path atomically:YES]; [array release]; // 写入文件 归档文件，不同格式读写。 NSString *path = @"/Users/beyondsoft/Desktop/file.plist"; NSDictionary *dict = [[NSDictionary alloc]initWithObjectsAndKeys:@"one", @"1", @"2", @"two", @"three", @"5", nil]; NSArray *array = [[NSArray alloc]initWithObjects:@"one", @"two", @"4", @"6", nil]; NSMutableData *data = [[NSMutableData alloc]init]; NSKeyedArchiver *archiver = [[NSKeyedArchiver alloc]initForWritingWithMutableData:data]; [archiver encodeObject:array forKey:@"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2541cf1154a970f1c13ccbfd74c8541/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/977152a171f940bda4efb45bca31ab3b/" rel="bookmark">
			shiro unauthorizedUrl页面不跳转问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近使用shiro框架控制用户权限，用户权限认证未通过时，无法跳转到unauthorizedUrl对应的页面，直接抛出了异常
解决方法：
1、mvc
&lt;!-- 定义需要特殊处理的异常，用类名或完全路径名作为key，异常页名作为值 --&gt;
&lt;property name="exceptionMappings"&gt;
&lt;props&gt;
&lt;prop key="org.apache.shiro.authz.UnauthorizedException"&gt;none_authority&lt;/prop&gt;
&lt;/props&gt;
&lt;/property&gt;
2、web.xml
&lt;error-page&gt; &lt;error-code&gt;500&lt;/error-code&gt; &lt;location&gt;/error.jsp&lt;/location&gt; &lt;/error-page&gt; 原因：
shiro的源代码ShiroFilterFactoryBean.java [java] view plain copy private void applyUnauthorizedUrlIfNecessary(Filter filter) { String unauthorizedUrl = getUnauthorizedUrl(); if (StringUtils.hasText(unauthorizedUrl) &amp;&amp; (filter instanceof AuthorizationFilter)) { AuthorizationFilter authzFilter = (AuthorizationFilter) filter; //only apply the unauthorizedUrl if they haven't explicitly configured one already: String existingUnauthorizedUrl = authzFilter.getUnauthorizedUrl(); if (existingUnauthorizedUrl == null) { authzFilter.setUnauthorizedUrl(unauthorizedUrl); } } } 定义的filter必须满足filter instanceof AuthorizationFilter，只有perms，roles，ssl，rest，port才是属于AuthorizationFilter，而anon，authcBasic，auchc，user是AuthenticationFilter，所以unauthorizedUrl设置后页面不跳转 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c3a0099a48519ff8a09f1c5c62decc8/" rel="bookmark">
			APT工作原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		APT工作原理 Ubuntu采用集中式的软件仓库机制，将各式各样 的软件包分门别类地存放在软件仓库中，进行有效地组织和管理。然后，将软件仓库置于许许多多的镜像服务器中，并保持基本一致。这样，所有的Ubuntu用 户随时都能获得最新版本的安装软件包。因此，对于用户，这些镜像服务器就是他们的软件源（Reposity）。
然而，由于每位用户所处的网络环境不同，不可能随意地访问各镜像站点。为了能够有选择地访问，在Ubuntu系统中，使用软件源配置文件/etc/apt/sources.list列出最合适访问的镜像站点地址。
即使这样，软件源配置文件只是告知Ubuntu系统 可以访问的镜像站点地址，但那些镜像站点具体都拥有什么软件资源并不清楚。若每安装一个软件包，就在服务器上寻找一遍，效率是很低的。因而，就有必要为这 些软件资源列个清单（建立索引文件），以便本地主机查询。这就是APT软件包管理器的工作原理，如图9.1所示。
同时，APT能够检查Ubuntu Linux系统中的软件包依赖关系，大大简化了Ubuntu用户安装和卸载软件包的过程。因而，APT成为Ubuntu Linux中最受欢迎的工具，也成为其他软件包管理工具的底层工具，例如，图形界面的软件包管理工具Synaptic就是在APT基础上工作的。
不过，APT并不是某个具体的命令，应该说是一组命令，以下列举几个常用的APT 命令。
● apt-get：用于管理软件包，包括安装、卸载、升级等操作；
● apt-cache：用于查询软件包信息；
● apt-proxy：用于搭建APT代理服务器；
● apt-show-versions：用于显示系统中软件包版本信息；
● apt-config：用于读取APT配置文件的简单工具；
● apt-cdrom：用于将CD-ROM加入软件源配置文件。
9.2 设置APT源 在安装Ubuntu Linux时，系统会根据用户所选择的国家/时区，推荐合适的软件源地址。通常，用户使用默认的配置文件就可以。不过，当用户发现更合适的软件源镜像站点时，可以重新设置APT源。
9.2.1 软件源配置文件 APT软件包管理器在一个文件中列出可获得软件 包的镜像站点地址，这个软件源配置文件就是/etc/apt/sources.list。这个软件源配制文件的本质就是一个普通的文本文件，可以在超级管 理员授权下，使用任何文本编辑器进行编辑。在该文件中，添加的软件源镜像站点称为一个配置项，并遵循以下格式：
DebType AddressType://Hostaddress/Ubuntu Distribution Component1 Component2……
其中各字段含义如下所示。
● DebType表示Deb软件包类型，使用deb表示二进制软件包，使用deb-src表示源码包；
● AddressType表示访问地址类型，常用类型有：http、ftp、file、cdrom、ssh等；
● Distribution表示Ubuntu的各个发行版本，例如dapper、feisty；
● Component表示软件包组件类别，是由技术支持程度不同而划分的类别，可选择main、restricted、universe和multiverse中的一种或多种。
当然在软件源配置文件中可以添加很多条配置项，这样APT就可以从不同渠道、不同站点获取软件资源。假设要将cn.archive.ubuntu.com作为软件源镜像站点，以下为在/etc/apt/sources.list文件中添加的配置项：
deb http://cn.archive.ubuntu.com/ubuntu/ feisty main restricted universe multiverse
deb-src http://cn.archive.ubuntu.com/ubuntu/ feisty main restricted universe multiverse
以上配置信息告知APT工具，可以从该地址中获得Ubuntu的feisty版本的软件资源，包括二进制软件包（deb）和源码包（deb-src），并指明可以使用所有类别的软件包。
通常，在安装Ubuntu Linux时，系统会根据用户所选择的国家/时区，推荐合适的软件源地址，并自动添加到软件源配置文件中。用户可以使用默认的配置文件。如果需要修改或添 加新的软件源地址，可以直接使用文本编辑器修改，也可以使用第四章介绍的软件源图形工具（单击【系统】|【系统管理】|【软件源】命令，打开【软件源】对 话框）进行配置。
在编辑软件源配置文件时，如果需要暂时屏蔽掉某个配置项，可以在行首加“#”，APT读取文件时会自动跳过。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c3a0099a48519ff8a09f1c5c62decc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9a546768958c5fd304ec350532025de/" rel="bookmark">
			C&#43;&#43; 简单实现HTTP GET/POST 请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTTP(超文本传输协议)是一种客户端与服务端的传输协议，最早用于浏览器和服务器之间的通信，后来因为其使用灵活、方便等特点，广泛用于客户端与服务端的通信。文章将简单介绍HTTP协议，同时以C++方式分别实现HTTP GET、POST 请求
HTTP 请求报文 HTTP请求报文的一般格式由4部分组成：请求行、请求头部、空行、请求数据。如下图所示：
请求行：包含3部分内容：请求方法，URL，协议版本。形式如：GET /?aaa=1 HTTP/1.1。请求方法有GET、POST、HEAD、PUT、DELETE、OPTIONS等。URL指请求服务端的地址，可以是相对地址或域名形式的绝对地址。协议版本主要有HTTP/1.1 HTTP/1.0 HTTP/0.9，后面两种已很少使用了。
请求头部：以key/value形式成对表示头部参数，以英文冒号分隔。key名称的约定写法为Key，Key-Name，自定义key名称一般以“X-”开头。如php的声明“X-Powered-By:PHP/5.5.4-1”
空行：用来标识请求头部的数据已结束。
请求数据：可选项，这块内容只在POST方式下使用，作为POST的数据表示区域。使用这块内容，要在请求头部以Content-Length声明请求数据长度，以Content-Type声明请求数据类型。
C++ 实现HTTP POST请求 HTTP POST方式是把请求参数放到HTTP请求报文的请求数据中，为了让例子更容易看懂，仅保留HTTP Post关键参数，你还可以自定义一些参数，比如浏览器喜欢用的User-Agent，Accept，Connection等等
char *pHttpPost = "POST %s HTTP/1.1\r\n" "Host: %s:%d\r\n" "Content-Type: application/x-www-form-urlencoded\r\n" "Content-Length: %d\r\n\r\n" "%s"; char* addr = "http://localhost/post.php"; char* host = "127.0.0.1"; int port = 80; char* msg = "aaa=1&amp;bbb=2"; char strHttpPost[1024] = {0}; sprintf(strHttpPost, pHttpPost, addr, host, port, strlen(msg), msg); //这里忽略掉了socket连接代码 send(sockClient, strHttpPost, strlen(strHttpPost), 0); C++ 实现HTTP GET请求 HTTP GET方式是把请求参数放到HTTP请求报文的请求行URL中，所以请求行就是“GET /?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9a546768958c5fd304ec350532025de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00de47cae1ea3335848c54c0c203dc41/" rel="bookmark">
			Android抽象布局——include、merge 、ViewStub
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在布局优化中，Androi的官方提到了这三种布局&lt;include /&gt;、&lt;merge /&gt;、&lt;ViewStub /&gt;，并介绍了这三种布局各有的优势，下面也是简单说一下他们的优势，以及怎么使用，记下来权当做笔记。
1、布局重用&lt;include /&gt; &lt;include /&gt;标签能够重用布局文件，简单的使用如下：
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width=”match_parent” android:layout_height=”match_parent” android:background="@color/app_bg" android:gravity="center_horizontal"&gt; &lt;include layout="@layout/titlebar"/&gt; &lt;TextView android:layout_width=”match_parent” android:layout_height="wrap_content" android:text="@string/hello" android:padding="10dp" /&gt; ... &lt;/LinearLayout&gt; 1)&lt;include /&gt;标签可以使用单独的layout属性，这个也是必须使用的。
2)可以使用其他属性。&lt;include /&gt;标签若指定了ID属性，而你的layout也定义了ID，则你的layout的ID会被覆盖，解决方案。
3)在include标签中所有的android:layout_*都是有效的，前提是必须要写layout_width和layout_height两个属性。
4)布局中可以包含两个相同的include标签，引用时可以使用如下方法解决（参考）:
View bookmarks_container_2 = findViewById(R.id.bookmarks_favourite); bookmarks_container_2.findViewById(R.id.bookmarks_list); 2、减少视图层级&lt;merge /&gt; &lt;merge/&gt;标签在UI的结构优化中起着非常重要的作用，它可以删减多余的层级，优化UI。&lt;merge/&gt;多用于替换FrameLayout或者当一个布局包含另一个时，&lt;merge/&gt;标签消除视图层次结构中多余的视图组。例如你的主布局文件是垂直布局，引入了一个垂直布局的include，这是如果include布局使用的LinearLayout就没意义了，使用的话反而减慢你的UI表现。这时可以使用&lt;merge/&gt;标签优化。
&lt;merge xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;Button android:layout_width="fill_parent" android:layout_height="wrap_content" android:text="@string/add"/&gt; &lt;Button android:layout_width="fill_parent" android:layout_height="wrap_content" android:text="@string/delete"/&gt; &lt;/merge&gt; 现在，当你添加该布局文件时(使用&lt;include /&gt;标签)，系统忽略&lt;merge /&gt;节点并且直接添加两个Button。更多&lt;merge /&gt;介绍可以参考《Android Layout Tricks #3: Optimize by merging》
3、需要时使用&lt;ViewStub /&gt; &lt;ViewStub /&gt;标签最大的优点是当你需要时才会加载，使用他并不会影响UI初始化时的性能。各种不常用的布局想进度条、显示错误消息等可以使用&lt;ViewStub /&gt;标签，以减少内存使用量，加快渲染速度。&lt;ViewStub /&gt;是一个不可见的，大小为0的View。&lt;ViewStub /&gt;标签使用如下：
&lt;ViewStub android:id="@+id/stub_import" android:inflatedId="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00de47cae1ea3335848c54c0c203dc41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a1908cd027c83ee1e02b560f2922429/" rel="bookmark">
			c#播放wav/mp3格式的声音
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种方法：
using System.Runtime.InteropServices;
namespace 使用API播放音乐 { public class MP3Player { /// &lt;summary&gt; /// 文件地址 /// &lt;/summary&gt; public string FilePath;
/// &lt;summary&gt; /// 播放 /// &lt;/summary&gt; public void Play() { mciSendString("close all", "", 0, 0); mciSendString("open " + FilePath + " alias media", "",0, 0); mciSendString("play media", "", 0, 0); }
/// &lt;summary&gt; /// 暂停 /// &lt;/summary&gt; public void Pause() { mciSendString("pause media", "", 0, 0); }
/// &lt;summary&gt; /// 停止 /// &lt;/summary&gt; public void Stop() { mciSendString("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a1908cd027c83ee1e02b560f2922429/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a90f1988fdcc45806eaaeb0f3f5c4b54/" rel="bookmark">
			Wondows Sever 2003密钥【收集】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ＰＳ:用vmware安装server 2003时,装系统需要另外创建一个虚拟光驱挂载系统的.iso文件用于安装. 针对大中型企业而设计的 Windows Server 2003企业版是推荐运行某些应用程序的服务器应该使用的操作系统，这些应用程序包括：联网、消息传递、清单和顾客服务系统、数据库、电子商务 Web站点以及文件和打印服务器。Windows Server 2003企业版提供高度的可靠性和性能以及优异的商业价值。企业版可在最新硬件上使用，它同时有 32 位版本和 64位版本，从而保证了最佳的灵活性和可伸缩性。各组织可从优化了的高效结构中获益，这种优化是针对关系到业务的应用程序和服务而进行的。 与 Windows Server 2003标准版的主要差异：支持高性能服务器以及将服务器群集在一起以处理更大负载的能力。这些功能提高了系统的可靠性，即确保无论是出现系统失败或是应用程序变得很大，系统仍然可用。 Windows Server 2003企业版允许通过添加处理器和内存来提高服务器性能和容量。这种提高网络容量的方法称为"扩容"。 通过添加能一起工作的处理器，可以提高服务器计算机的性能。Windows Server 2003 企业版中增强的 SMP支持允许您使用多处理器服务器。 另一种提高服务器性能的方法是添加内存，这样将使计算机能同时处理更多信息。Windows Server 2003企业版包括增强的内存功能，这些功能使服务器处理时可用的内存大幅增加，对于 32 位版本和 64 位版本分别达到 32 GB RAM 和64 GB RAM。 Windows Server 2003 简体中文企业版，真正免激活。 CD-KEY：JB88F-WT2Q3-DPXTT-Y8GHG-7YYQY 安装序列号：JCGMJ-TC669-KCBG7-HB8X2-FXG7M 使用这个序列号 Windows Server 2003 可在线升级! 温馨提醒：解压密码是：www.downxia.com win2003 server sp2的产品密钥 2007-7-5 11:24 提问者： xiongerfei | 浏览次数：20859次 哪位大哥能告诉我啊,越快越好!!!!先谢了 我来帮他解答 2007-7-5 11:40 满意回答 Windows Server 2003 简体中文企业版，真正免激活。 CD-KEY：JB88F-WT2Q3-DPXTT-Y8GHG-7YYQY 安装序列号：JCGMJ-TC669-KCBG7-HB8X2-FXG7M 使用这个序列号 Windows Server 2003 可在线升级!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a90f1988fdcc45806eaaeb0f3f5c4b54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fbbd7f3152484d31e1257973a01deaa/" rel="bookmark">
			事件触发机制：Poll,Select和Epoll实现原理分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Poll和Select和Epoll都是事件触发机制，当等待的事件发生就触发进行处理，多用于linux实现的服务器对客户端连接的处理。
Poll和Select都是这样的机制：可以阻塞地同时探测一组支持非阻塞的IO设备，是否有事件发生（如可读，可写，有高优先级的错误输出，出现错误等等），直至某一个设备触发了事件或者超过了指定的等待时间——也就是它们的职责不是做IO，而是帮助调用者寻找当前就绪的设备。
原文链接：http://blog.chinaunix.net/uid-20792262-id-2909919.html
int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
int poll(struct pollfd *fds, nfds_t nfds, int timeout);
int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
epoll相关系统调用是在Linux 2.5.44开始引入的。该系统调用针对传统的select/poll系统调用的不足，设计上作了很大的改动。select/poll的缺点在于： 1.每次调用时要重复地从用户态读入参数。 2.每次调用时要重复地扫描文件描述符。 3.每次在调用开始时，要把当前进程放入各个文件描述符的等待队列。在调用结束后，又把进程从各个等待队列中删除。 在实际应用中，select/poll监视的文件描述符可能会非常多，如果每次只是返回一小部分，那么，这种情况下select/poll显得不够高效。 epoll的设计思路，是把select/poll单个的操作拆分为1个epoll_create+多个epoll_ctrl+一个wait。此外，内核针对epoll操作添加了一个文件系统”eventpollfs”，每一个或者多个要监视的文件描述符都有一个对应的eventpollfs文件系统的inode节点，主要信息保存在eventpoll结构体中。而被监视的文件的重要信息则保存在epitem结构体中。所以他们是一对多的关系。 由于在执行epoll_create和epoll_ctrl时，已经把用户态的信息保存到内核态了所以之后即使反复地调用epoll_wait，也不会重复地拷贝参数，扫描文件描述符，反复地把当前进程放入/放出等待队列。这样就避免了以上的三个缺点。
select、poll、epoll_wait参数及实现对比
1. int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout); select的第一个参数nfds为fdset集合中最大描述符值加1，fdset是一个位数组，其大小限制为__FD_SETSIZE（1024），位数组的每一位代表其对应的描述符是否需要被检查。
select的第二三四个参数表示需要关注读、写、错误事件的文件描述符位数组，这些参数既是输入参数也是输出参数，可能会被内核修改用于标示哪些描述符上发生了关注的事件。所以每次调用select前都需要重新初始化fdset。
timeout参数为超时时间，该结构会被内核修改，其值为超时剩余的时间。
select对应于内核中的sys_select调用，sys_select首先将第二三四个参数指向的fd_set拷贝到内核，然后对每个被SET的描述符调用进行poll，并记录在临时结果中（fdset），如果有事件发生，select会将临时结果写到用户空间并返回；当轮询一遍后没有任何事件发生时，如果指定了超时时间，则select会睡眠到超时，睡眠结束后再进行一次轮询，并将临时结果写到用户空间，然后返回。
select返回后，需要逐一检查关注的描述符是否被SET（事件是否发生）。
2． poll与select不同，通过一个pollfd数组向内核传递需要关注的事件，故没有描述符个数的限制，pollfd中的events字段和revents分别用于标示关注的事件和发生的事件，故pollfd数组只需要被初始化一次。
poll的实现机制与select类似，其对应内核中的sys_poll，只不过poll向内核传递pollfd数组，然后对pollfd中的每个描述符进行poll，相比处理fdset来说，poll效率更高。
poll返回后，需要对pollfd中的每个元素检查其revents值，来得指事件是否发生。
3． epoll通过epoll_create创建一个用于epoll轮询的描述符，通过epoll_ctl添加/修改/删除事件，通过epoll_wait检查事件，epoll_wait的第二个参数用于存放结果。
epoll与select、poll不同，首先，其不用每次调用都向内核拷贝事件描述信息，在第一次调用后，事件信息就会与对应的epoll描述符关联起来。另外epoll不是通过轮询，而是通过在等待的描述符上注册回调函数，当事件发生时，回调函数负责把发生的事件存储在就绪事件链表中，最后写到用户空间。
epoll返回后，该参数指向的缓冲区中即为发生的事件，对缓冲区中每个元素进行处理即可，而不需要像poll、select那样进行轮询检查。
select、poll、epoll_wait性能对比
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fbbd7f3152484d31e1257973a01deaa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0c00ed12e3001dfe7256c3c96d6cb02/" rel="bookmark">
			算法知识之最长公共子序列问题(动态规划)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近朋友让帮做个关于动态规划的最长公共子序列的问题,翻看以前的笔记并完成该题后,顺便写这样一篇文章,希望对大家有所帮助,同时也帮助自己回顾该知识点.
一.最长公共子序列的定义 子序列:若给定序列X={x1,x2,…,xm},则另一序列Z={z1,z2,…,zk},是X的子序列是指存在一个严格递增下标序列{i1,i2,…,ik}使得对于所有j=1,2,…,k有:zj=xij.
公共子序列:给定2个序列X和Y,当另一序列Z既是X的子序列又是Y的子序列时,称Z是序列X和Y的公共子序列.
最长公共子序列:给定2个序列X={x1,x2,…,xm}和Y={y1,y2,…,yn},找出X和Y的最长公共子序列.
如：序列ABCDEF和ADFGH的最长公共子序列为ADF
注意:最长公共子串(Longest Common Substirng)和最长公共子序列(Longest Common Subsequence,简称LCS)的区别为是最长公共子串的串是一个连续的部分,而最长公共子序列则是从不改变序列的顺序,而从序列中去掉任意的元素而获得新的序列;通俗的说就是子串中字符的位置必须是连续的而子序列则可以不必连续.
二.最优子结构性质 设序列X={x1,x2,…,xm}和Y={y1,y2,…,yn}的最长公共子序列为Z={z1,z2,…,zk} ,则
(1)若xm=yn,则zk=xm=yn,且z1,z2,…, zk-1是否为x1,x2,…,xm-1和y1,y2,…,yn-1的最长公共子序列.
(2)若xm≠yn且zk≠xm,则Z是x1,x2,…,xm-1和Y的最长公共子序列.
(3)若xm≠yn且zk≠yn,则Z是X和y1,y2,…,yn-1的最长公共子序列.
由此可见,2个序列的最长公共子序列包含了这2个序列的前缀的最长公共子序列.因此,最长公共子序列问题具有最优子结构性质.当问题具有最优子结构性质和子问题重叠性质时就可以用动态规划算法解决该问题.
三.动态规划方法分析 由最长公共子序列问题的最优子结构性质建立子问题最优值的递归关系.用c[i][j]记录序列和的最长公共子序列的长度.其中,Xi={x1,x2,…,xi},Yj={y1,y2,…,yj}.当i=0或j=0时,空序列是Xi和Yj的最长公共子序列.故此时C[i][j]=0.其它情况下,由最优子结构性质可建立递归关系如下:
其对应的核心代码如下:
//参数:x字符串长度为m y字符串长度为n void LCSLength(char x[], char y[],int m，int n) { /* 计算最长公共子序列的长度 */ int L[m][n],i，j; for (i = 0; i &lt;= m; i++) L[i][0] = 0; for (i = 0; i &lt;= n; i++) L[0][i] = 0; for (i = 1; i &lt;= m; i++) { for (j = 1; j &lt;= n; j++) { if (x[i]==y[j]) L[i][j]=L[i-1][j-1]+1; else if (L[i-1][j]&gt;= L[i][j-1]) L[i][j]= L[i-1][j]; else L[i][j]= L[i][j-1]; } } return L[m][n]; } 例如:输入字符串“bdcaba”和"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0c00ed12e3001dfe7256c3c96d6cb02/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2b47e083adaba76d4bcfd7db1928fd4/" rel="bookmark">
			我在学习PS过程中有几点很深的体会
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		其实对PS早有耳闻，只是一直没去接触，因为觉得挺专业的，然后也没有遇见一定要用PS的地方，自己也一直挺满足于美图秀秀的，后来因为部门需要不得不接触PS，外加正好电协在做这个的培训，于是毫不犹豫的去了PS培训组。
我最先是看了一本关于PS的书，觉得看了没什么收获，因为并没有实际操作，后来听了一堂课，主要讲解了各种工具的用途，才将书上的东西与实践多少对上了号，自己下来熟悉了几次各种工具的用途以后，便开始尝试着用各种工具进行组合来做效果，这中间对PS产生了不少兴趣，也开始尝试着自己做一些海报；做海报需要对效果进行组合的时候遇见了很多问题，比如抠图等等，自己就尝试着通过网络来解决这些问题，并且在视频上学了一些字体特效，觉得还是进步了不少，只是很可惜最后交流会的时候好忙，就比较应付性质的完成了作业，这大概就是上学期的学历历程吧。
我在学习过程中，有几点很深的体会：
一：自学真的是很重要的能力
PS其实大部分都要靠我自己自学的，中间会遇见比有人教更多的麻烦，但是自己发现问题并予以解决后，那种印象会深很多很多，同时更能了解最本质一点的问题，再来自己解决以后那种成就感是无法言语的，虽然最开始那种混混沌沌的状态真是万分难受。而且本来现在很多的东西也要自己自学啦。
二：学习需要坚持
自学是一个很痛苦的过程，学习都会经历由不懂到懂的过程，而这个过程是极其痛苦的，极容易令人是去耐心的，尤其是PS这种自由组合度很高，专业名词又很多的软件，所以需要学习者有冲破障碍的决心和坚持；我在抠图上遇见过很多问题，抠好多次都弄不好，我的心情也会非常的烦躁，觉得自己很笨很没用，但是总记得小时候妈妈常教导我：坚持就是胜利，才坚持着看了很多这方面的视频，终于有几种抠图方法还算比较应手了，所以说，坚持真的很重要，它决定着你是否前功尽弃。
三：学习要实践
这一点的重要性在学习PS上面尤其明显，看书或者看视频是根本不可能学会PS 的，看了以后还得下来照着做，还要做好多次才能完全的掌握，掌握以后不时的还得用着，，其实这一点是我的弱点，我就是实践操作不多，所以经常记得怎么做然后过一会儿就忘记了，这样会效率很低。
四：学习PS要多变通，多思考
PS有一个很大的魅力就是它给了我们很大的自由发挥空间，工具很多可以自由组合很多效果和元素，可以有很多创意可以实现，当然这要建立在对效果很熟悉的基础上（这点我表示很惭愧），思维要发散才能创造出属于自己艺术风格的作品啊。这一点其实要求挺高的，不仅需要制作人对PS的工具很熟悉，而且还要有整体的构思能力，步骤的安排能力和较强的想象力；同时看见别人的作品也要多思考才能取长补短发散思维吧，多与他人交流和学习可以使自己的思维开阔很多。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/361901e9e42cc93e461b4aa5343eabdb/" rel="bookmark">
			MySQL存储过程详解 mysql 存储过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博客分类： mysql mysql存储过程 mysql存储过程详解 1. 存储过程简介 我们常用的操作数据库语言SQL语句在执行的时候需要要先编译，然后执行，而存储过程（Stored Procedure）是一组为了完成特定功能的SQL语句集，经编译后存储在数据库中，用户通过指定存储过程的名字并给定参数（如果该存储过程带有参数）来调用执行它。 一个存储过程是一个可编程的函数，它在数据库中创建并保存。它可以有SQL语句和一些特殊的控制结构组成。当希望在不同的应用程序或平台上执行相同的函数，或者封装特定功能时，存储过程是非常有用的。数据库中的存储过程可以看做是对编程中面向对象方法的模拟。它允许控制数据的访问方式。 存储过程通常有以下优点： (1).存储过程增强了SQL语言的功能和灵活性。存储过程可以用流控制语句编写，有很强的灵活性，可以完成复杂的判断和较复杂的运算。 (2).存储过程允许标准组件是编程。存储过程被创建后，可以在程序中被多次调用，而不必重新编写该存储过程的SQL语句。而且数据库专业人员可以随时对存储过程进行修改，对应用程序源代码毫无影响。 (3).存储过程能实现较快的执行速度。如果某一操作包含大量的Transaction-SQL代码或分别被多次执行，那么存储过程要比批处理的执行速度快很多。因为存储过程是预编译的。在首次运行一个存储过程时查询，优化器对其进行分析优化，并且给出最终被存储在系统表中的执行计划。而批处理的Transaction-SQL语句在每次运行时都要进行编译和优化，速度相对要慢一些。 (4).存储过程能过减少网络流量。针对同一个数据库对象的操作（如查询、修改），如果这一操作所涉及的Transaction-SQL语句被组织程存储过程，那么当在客户计算机上调用该存储过程时，网络中传送的只是该调用语句，从而大大增加了网络流量并降低了网络负载。 (5).存储过程可被作为一种安全机制来充分利用。系统管理员通过执行某一存储过程的权限进行限制，能够实现对相应的数据的访问权限的限制，避免了非授权用户对数据的访问，保证了数据的安全。 2. 关于MySQL的存储过程 存储过程是数据库存储的一个重要的功能，但是MySQL在5.0以前并不支持存储过程，这使得MySQL在应用上大打折扣。好在MySQL 5.0终于开始已经支持存储过程，这样即可以大大提高数据库的处理速度，同时也可以提高数据库编程的灵活性。 3. MySQL存储过程的创建 (1). 格式 MySQL存储过程创建的格式：CREATE PROCEDURE 过程名 ([过程参数[,...]]) [特性 ...] 过程体 这里先举个例子： mysql&gt; DELIMITER // mysql&gt; CREATE PROCEDURE proc1(OUT s int) -&gt; BEGIN -&gt; SELECT COUNT(*) INTO s FROM user; -&gt; END -&gt; // mysql&gt; DELIMITER ; 注： （1）这里需要注意的是DELIMITER //和DELIMITER ;两句，DELIMITER是分割符的意思，因为MySQL默认以";"为分隔符，如果我们没有声明分割符，那么编译器会把存储过程当成SQL语句进行处理，则存储过程的编译过程会报错，所以要事先用DELIMITER关键字申明当前段分隔符，这样MySQL才会将";"当做存储过程中的代码，不会执行这些代码，用完了之后要把分隔符还原。 （2）存储过程根据需要可能会有输入、输出、输入输出参数，这里有一个输出参数s，类型是int型，如果有多个参数用","分割开。 （3）过程体的开始与结束使用BEGIN与END进行标识。 这样，我们的一个MySQL存储过程就完成了，是不是很容易呢?看不懂也没关系，接下来，我们详细的讲解。 (2). 声明分割符 其实，关于声明分割符，上面的注解已经写得很清楚，不需要多说，只是稍微要注意一点的是：如果是用MySQL的Administrator管理工具时，可以直接创建，不再需要声明。 (3). 参数 MySQL存储过程的参数用在存储过程的定义，共有三种参数类型,IN,OUT,INOUT,形式如： CREATE PROCEDURE([[IN |OUT |INOUT ] 参数名 数据类形.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/361901e9e42cc93e461b4aa5343eabdb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf85222fc4e62f3741dfb43e5f8b135c/" rel="bookmark">
			修改root密码时，提示athentication token manipulation error
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章来自：http://blog.163.com/junwu_lb/blog/static/1916798920120103647199/
发生该错误原因是：
1、分区没有空间导致。 2、/etc/passwd 和/etc/shadow不同步 但是这次上面两条却行不通，通过df查看根分区还有40%剩余。 1、尝试修改密码，出现错误 # passwd Changing password for user root. New UNIX password: BAD PASSWORD: it is WAY too short Retype new UNIX password: passwd: Authentication token manipulation error 2、同步/etc/passwd 和/etc/shadow出错 #pwconv pwconv: can't lock passwd file 通过同步/etc/passwd 和/etc/shadow 我的问题解决了 3、看权限没有异常，也没有进程锁定该文件 # ll /etc/passwd -rwxr--r-- 1 root root 2752 Dec 31 17:29 /etc/passwd # fuser -u /etc/passwd # lsof |grep passwd 4、cp lock文件出错，提示空间不足 # cp /tmp/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf85222fc4e62f3741dfb43e5f8b135c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1769f6fd86f89a0c585f620c63edac37/" rel="bookmark">
			杭电1003 MAX SUN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Problem Description Given a sequence a[1],a[2],a[3]......a[n], your job is to calculate the max sum of a sub-sequence. For example, given (6,-1,5,4,-7), the max sum in this sequence is 6 + (-1) + 5 + 4 = 14. Input The first line of the input contains an integer T(1&lt;=T&lt;=20) which means the number of test cases. Then T lines follow, each line starts with a number N(1&lt;=N&lt;=100000), then N integers followed(all the integers are between -1000 and 1000).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1769f6fd86f89a0c585f620c63edac37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c340c724b123feb70ea49ef8b522abc0/" rel="bookmark">
			http://www.52css.com
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 http://www.52css.com 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7521bfce99f7f84931ca5074af81b4a/" rel="bookmark">
			简单的查找文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//ReadFolder.h #include &lt;string&gt; #include &lt;vector&gt; using namespace std; class FileFind{ public: FileFind(); ~FileFind(); FileFind(char* FileName); bool TraverseFolder(LPCTSTR lpPath);	//遍历lpPath所指目录 bool HuntDeskTopFile();	//在桌面上查找目标文件 void GetTargetFilePath(char* path);	//返回目标文件的绝对路径 vector&lt;string&gt; GetDriverRoot();	//获取固定磁盘更目录 private: char m_FindFileName[MAX_PATH];	//要查找的文件的名称 char m_FindFilePath[MAX_PATH];	//要查找的文件的绝对路径 }; //ReadFolder.cpp #include &lt;stdio.h&gt; #include &lt;tchar.h&gt; #include &lt;Windows.h&gt; #include &lt;shlwapi.h&gt; #include &lt;shlobj.h&gt; #include &lt;shtypes.h&gt; #include &lt;shobjidl.h&gt; #pragma comment(lib,"shlwapi") #include "ReadFolder.h" //char FindFileName[128] = "package.exe";	//要查找的文件的名称 //char FindFilePath[MAX_PATH] = {0};	//要查找的文件的绝对路径 FileFind::FileFind() { memset(m_FindFileName,0,sizeof(m_FindFileName)); memset(m_FindFilePath,0,sizeof(m_FindFilePath)); } FileFind::~FileFind(){} FileFind::FileFind(char* FileName) { memset(m_FindFileName,0,sizeof(m_FindFileName)); memset(m_FindFilePath,0,sizeof(m_FindFilePath)); strcpy(m_FindFileName,FileName); } bool FileFind::TraverseFolder(LPCTSTR lpPath) { TCHAR szFind[MAX_PATH] = {_T("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7521bfce99f7f84931ca5074af81b4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0aab14f2c47f5cf1652d1308e0e4e7b8/" rel="bookmark">
			python 对string去掉标点符号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		delset = string.punctuation
l = line.translate(None,delset)
print l 即为去掉标点符号的 string，而line本身没有变化
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fe3d8bf4864ad337f841e834eab8d37/" rel="bookmark">
			Mac OS Mavericks “本地项目”钥匙串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Apple竟然把OS X 10.9 Mavericks免费了，前天晚上一发布，第二天早上起来就下载，第三天安装，可安装完成之后就不停的报错
Baidu了下，发现原来不是我一个人遇到这个问题，威锋BBS，知乎上都有不少网友遇到这种问题(http://bbs.weiphone.com/read-htm-tid-7168013.html)，不知道是不是bug，解决方法都是使用钥匙串急救或者是重置密码(Apple官方解决方法--http://support.apple.com/kb/HT1631?viewlocale=zh_CN&amp;locale=zh_CN)，但是这两种方法我都试了还是不行。提示“已经检查登录钥匙串 错误:找不到登录钥匙串 修复已意外中止 ”，后来找到一篇文章(http://www.macx.cn/thread-2053948-1-1.html)，这里面提到了 ~/Library/Keychains/目录下的login.keychain文件，我看了下我自己的配置，发现并没有“login.keychain”这个文件，取而代之的是“
login_renamed_1.keychain”，试着
taotaomatoMacBook-Pro:Keychains taojin$ cd ~/Library/Keychains/
taotaomatoMacBook-Pro:Keychains taojin$ ls
E013B341-9063-5271-B1ED-73B0B7509B7F
Microsoft_Intermediate_Certificates
login.keychain
login_renamed_1.keychain
metadata.keychain
taotaomatoMacBook-Pro:Keychains taojin$ rm -rf login.keychain
taotaomatoMacBook-Pro:Keychains taojin$ mv login_renamed_1.keychain login.keychain
taotaomatoMacBook-Pro:Keychains taojin$ ls
E013B341-9063-5271-B1ED-73B0B7509B7F
Microsoft_Intermediate_Certificates
login.keychain
metadata.keychain
再次使用“钥匙串急救”这个功能，成功搞定
猜测是OS Upgrade的时候将login.keychain重命名为login_renamed_1.keychain，导致用户找不到login.keychain这个文件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8b3892d19105a2f9bf5ceb7d2f46443/" rel="bookmark">
			ott概述了解1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OTT TV （Over-The-TopTV），即以Over-The-Top方式服务的互联网电视，如2010年在市场上推出的Apple TV及Google TV即是此种模式。 在国际上，OTT TV指通过公共互联网面向电视传输的IP视频和互联网应用融合的服务。其接收终端为互联网电视一体机或机顶盒+电视机。 随着IPTV业务的发展，对于内容服务提出了越来越高的要求，提供OTT服务，是运营商整合互联网视频资源，拓展内容服务种类的良好途径。
目前对于运营商基于IPTV系统提供OTT 视频业务，一般采取如下模式： （1）运营商与互联网视频内容提供商合作，视频内容提供商将其互联网视频内容，通过运营商提供的内容接口，注入到运营商IPTV系统的CDN中，由运营商CDN给机顶盒用户提供服务。这种方式下，要求运营商的机顶盒支持互相联网视频内容格式的解码与播放。
（2）运营商在其IPTV 的EPG页面上，提供到第三方视频网站的链接，IPTV机顶盒通过该链接，可以直接访问第三方视频网站，点播并观看第三方视频网站上的视频节目。
对于第一种模式，优点是运营商对视频内容的管控能力比较强，在OTT业务运营中占据主动，而且因为ＯＴＴ视频内容已经注入到运营商的ＣＤＮ中，在提供用户服务时，因为网络带宽有保障，稳定性会比较好。缺点是对于运营商管理的要求高，需要寻找合适的互联网内容提供商，确定合作模式及分成模式等。
对于第二种模式，优点是业务的引入比较容易，可以很快提供视频服务。缺点是运营商对OTT业务的管控能力弱，因为是直接连接到Internet视频网站，网络带宽无法保证，视频播放效果可能会不够稳定，另外还可能涉及到版权问题。
基于IPTV系统的OTT视频业务的解决方案如下 ：
基于IPTV的OTT视频业务方案的架构，是运营商自建的系统，包括头端，中间件，CDN，EPG，网管，VAS等模快，另外还包括内容管理系统，其组网结构和原有的IPTV系统基本相同，只是进行了软件的开发与改造。右边部分是互联网上的系统，需要与运营商的IPTV系统（含STB）在IP网络上保持畅通。
OTT视频业务方案中，同时支持“互联网视频内容注入CDN”以及“机顶盒直接连接到第三方视频网站两种模式”，机顶盒用户可以根据需要，使用不同的业务模式。对于第一种模式，互联网视频内容（FLV格式）受到IPTV系统的管理，其注入方式，展现方式，订购方式，使用方式，计费方式与普通的IPTV内容（H.264格式）基本上是相同的，对于运营商的好处是可以迅速利用已有的互联网视频内容，为用户提供更丰富的视频内容服务。对于第二种模式，对于IPTV系统的EPG与机顶盒有一定的要求，用户可以通过EPG门户连接到第三方视频网站视频节目，并且可以方便地回到EPG门户上的IPTV业务展示页面。
1） 内容同步请求
当互联网视频提供商需要发布新视频时，互联网视频管理系统CMS和中间接口机交互，请求视频内容同步。
CDN通过FTP获取需要同步视频，此时CDN中的视频状态为不可用，在EPG上将不可见。
2） 内容审核
运营商对引入内容进行审核，审核结果分别通知内容提供商和CDN。
3） 内容发布
审核完成后，将视频内容根据要求发布到相关CDN节点和EPG。
用户通过业务EPG页面请求一个视频播放，机顶盒向CDN发起服务请求，CDN向STB应答回复视频URL，STB从CDN的HTTP下载服务器拉码流，边拉边放。
1） 用户在STB上发起一个点播请求；
2） EPG向Midware发起鉴权操作；
3） Midware通过处理，返回EPG鉴权结果；
4） 若业务鉴权失败，需要进入订购流程；
5） EPG返回STB用户服务节点等信息；
6） STB向CDN请求内容URL；
7） CDN返回STB内容URL；
8） STB根据上步的结果请求媒体服务；
9） CDN通知Midware服务开始，业务管理平台记录服务开始；
10） CDN向用户提供媒体流服务；
11） 用户发起退出请求，CDN通知业务管理平台服务结束；
12） 业务管理平台生成话单记录。
1.1.1 对IPTV系统的要求 1） 用户管理：
由于互联网视频格式的播放对机顶盒有要求，因此，需要在用户上增加OTT权限，对用户区别管理；
2） 产品包管理：
对互联网视频单独建产品包,只对具有OTT权限的用户开放，同时通过产品包对计费策略区分设置。
3）EPG展现
EPG增加OTT产品列表的展示。
1.1.2 对CDN的要求 在现有的CDN节点上需要部署2个模块，Agent 和HTTP下载服务器，采用HTTP下载方式，边拉边放，给终端提供流媒体服务。CDN应支持以下需求：
n 多业务支持： CDN支持IPTV、OTT两种业务。IPTV保持现有业务不变；OTT只要求支持点播。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8b3892d19105a2f9bf5ceb7d2f46443/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33f19753932ea5f7357fab126a37dbb8/" rel="bookmark">
			awk 处理文本：行转列，列转行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 [root@centos ~]# cat f 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 awk '{for(i=1;i&lt;=NF;i++)a[NR,i]=$i}END{for(j=1;j&lt;=NF;j++)for(k=1;k&lt;=NR;k++)printf k==NR?a[k,j] RS:a[k,j] FS}' f 1 1 1 1 1 2 2 2 2 2 3 3 3 3 3 4 4 4 4 4 5 5 5 5 5 或者 以下一句更简单：
awk '{for(i=0;++i&lt;=NF;)a[i]=a[i]?a[i] FS $i:$i}END{for(i=0;i++&lt;NF;)print a[i]}' 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6355484d269f339808f242eb18f7b24/" rel="bookmark">
			ThinkPad家族全系列解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第1页：最为轻薄—X系列
第2页：性能与便携的完美平衡—T系列
第3页：终极移动工作站—W系列
第4页：成长型全功能笔记本—SL系列第5页：SL系列的延续—L系列
第6页：创新元素融入经典力作—E系列
第7页：魅力商务之选—S系列 http://notebook.pconline.com.cn/guide/time/1205/2771529_all.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ac5cddcd1eceeed93c4fa13484bd48f/" rel="bookmark">
			Iptables详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Iptabels是与Linux内核集成的包过滤防火墙系统，几乎所有的linux发行版本都会包含Iptables的功能。如果 Linux 系统连接到因特网或 LAN、服务器或连接 LAN 和因特网的代理服务器， 则Iptables有利于在 Linux 系统上更好地控制 IP 信息包过滤和防火墙配置。
netfilter/iptables过滤防火墙系统是一种功能强大的工具，可用于添加、编辑和除去规则，这些规则是在做信息包过滤决定时，防火墙所遵循和组成的规则。这些规则存储在专用的信 息包过滤表中，而这些表集成在 Linux 内核中。在信息包过滤表中，规则被分组放在我们所谓的链（chain）中。
虽然netfilter/iptables包过滤系统被称为单个实体，但它实际上由两个组件netfilter 和 iptables 组成。
netfilter 组件也称为内核空间（kernelspace），是内核的一部分，由一些信息包过滤表组成，这些表包含内核用来控制信息包过滤处理的规则集。
iptables 组件是一种工具，也称为用户空间（userspace），它使插入、修改和除去信息包过滤表中的规则变得容易。
优点
netfilter/iptables的最大优点是它可以配置有状态的防火墙。有状态的防火墙能够指定并记住为发送或接收信息包所建立的连接的状态。防火墙可以从信息包的连接跟踪状态获得该信 息。在决定新的信息包过滤时，防火墙所使用的这些状态信息可以增加其效率和速度。这里有四种有效状态，名称分别为 ESTABLISHED 、 INVALID 、 NEW 和 RELATED 。
状态 ESTABLISHED指出该信息包属于已建立的连接，该连接一直用于发送和接收信息包并且完全有效。 INVALID 状态指出该信息包与任何已知的流或连接都不相关联，它可能包含错误的数据或头。状态 NEW 意味着该信息包已经或将启动新的连接，或者它与尚未用于发送和接收信息包的连接相关联。最后， RELATED 表示该信息包正在启动新连接，以及它与已建立的连接相关联。
netfilter/iptables的另一个重要优点是，它使用户可以完全控制防火墙配置和信息包过滤。您可以定制自己的规则来满足您的特定需求，从而只允许您想要的网络流量进入系统。
另外，netfilter/iptables是免费的，这对于那些想要节省费用的人来说十分理想，它可以代替昂贵的防火墙解决方案。
原理
iptables的原理主要是对数据包的控制，看下图：
（1） 一个数据包进入网卡时，它首先进入PREROUTING链，内核根据数据包目的IP判断是否需要转发出去。
（2） 如果数据包就是进入本机的，它就会沿着图向下移动，到达INPUT链。数据包到了INPUT链后，任何进程都会收到它。本机上运行的程序可以发送数据包，这些数据包会经 过OUTPUT链，然后到达POSTROUTING链输出。
（3）如果数据包是要转发出去的，且内核允许转发，数据包就会如图所示向右移动，经过 FORWARD链，然后到达POSTROUTING链输出。
规则、表和链
1.规则（rules）
规则（rules）其实就是网络管理员预定义的条件，规则一般的定义为“如果数据包头符合这样的条件，就这样处理这个数据包”。规则存储在内核空间的信息包过滤表中，这些规则分别指定了源地址、目的地址、传输协议（如TCP、UDP、ICMP）和服务类型（如HTTP、FTP和SMTP）等。当数据包与规则匹配时，iptables就根据规则所定义的方法来处理这些数据包，如放行（accept）、拒绝（reject）和丢弃（drop）等。配置防火墙的主要工作就是添加、修改和删除这些规则。
2.链（chains）
链（chains）是数据包传播的路径，每一条链其实就是众多规则中的一个检查清单，每一条链中可以有一条或数条规则。当一个数据包到达一个链时，iptables就会从链中第一条规则开始检查，看该数据包是否满足规则所定义的条件。如果满足，系统就会根据该条规则所定义的方法处理该数据包；否则iptables将继续检查下一条规则，如果该数据包不符合链中任一条规则，iptables就会根据该链预先定义的默认策略来处理数据包。
3.表（tables）
表（tables）提供特定的功能，iptables内置了4个表，即raw表、filter表、nat表和mangle表，分别用于实现包过滤，网络地址转换和包重构的功能。
（1）RAW表
只使用在PREROUTING链和OUTPUT链上,因为优先级最高，从而可以对收到的数据包在连接跟踪前进行处理。一但用户使用了RAW表,在 某个链上,RAW表处理完后,将跳过NAT表和 ip_conntrack处理,即不再做地址转换和数据包的链接跟踪处理了.
（2）filter表
主要用于过滤数据包，该表根据系统管理员预定义的一组规则过滤符合条件的数据包。对于防火墙而言，主要利用在filter表中指定的规则来实现对数据包的过滤。Filter表是默认的表，如果没有指定哪个表，iptables 就默认使用filter表来执行所有命令，filter表包含了INPUT链（处理进入的数据包），RORWARD链（处理转发的数据包），OUTPUT链（处理本地生成的数据包）在filter表中只能允许对数据包进行接受，丢弃的操作，而无法对数据包进行更改
（3）nat表
主要用于网络地址转换NAT，该表可以实现一对一，一对多，多对多等NAT 工作，iptables就是使用该表实现共享上网的，NAT表包含了PREROUTING链（修改即将到来的数据包），POSTROUTING链（修改即将出去的数据包），OUTPUT链（修改路由之前本地生成的数据包）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ac5cddcd1eceeed93c4fa13484bd48f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54b154cd697699820b817d7bcb1d93bb/" rel="bookmark">
			ASPxGridview使用总结(DEVExpress)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;script type="text/javascript"&gt;
function ontest() {
//PerformCallback（）异步更新aspxgridview 数据 对应的后台事件是CustomCallback 也可参数传递
ASPxClientGridView.Cast("grid").PerformCallback("242343244");
}
&lt;/script&gt;
一。ASPXGridView外观显示
属性:
Caption----列的标题（
KeyFieldName----数据库字段
SEOFriendly 是否启用搜索引擎优化
Summary 指定分页汇总信息的格式
Setting节点的ShowFilterRow=True设置快速查找功能
SettingsBehavior.AllowFocusedRow=true 高亮选中的行,即选中行变色
SettingsBehavior.AllDragDrop=false禁止拖动标题列头
SettingsBehavior.AllowSort实现列头点击后是否可以排序
SettingsPager.ShowEmptyDataRows=True;当数据行为空时，显示空行
SettingsPager.PageSize 每页显示的记录总数
AllButton.Text “全部数据显示”按钮的文本
AllButton.Visible 是否显示“全部数据显示”按钮
FirstPageBuotton/LastPageButton/NextPageButton/PrevPageButton/ 对应首页、末页、下页、上页，设置同上。
NumericButtonCount 最小值为1，控制页码显示个数
protected void ASPxGridView1_PageIndexChanged(object sender, EventArgs e)
{
databind();//只需重新绑定数据即可实现上下翻页
}
新建的列默认是GridViewDataTextColumn类型，选择工具栏的Change To变更列的类型，可以改变新增或修改时的编辑方式。
设置日期类型显示格式，在“行为”PropertiesDateEdit--DisplayFormatString--例如：{0:yyyy年MM月}
当选择了show Group Panel时,FocusedRowChanged事件,重绑定数据,使用时先选中行,再查看
protected void ASPxGridView1_FocusedRowChanged(object sender, EventArgs e)
{
getdata();
}
禁止某一列进行编辑,该列的行为-EditFormSettings-Visible=False
代码中隐藏编辑列的增加，删除，更新按钮
(ASPxGridView1.Columns[编辑列] as GridViewCommandColumn).NewButton .Visible= true;
(ASPxGridView1.Columns[编辑列] as GridViewCommandColumn).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54b154cd697699820b817d7bcb1d93bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8cb8822086b2871010741a22b7d3b33/" rel="bookmark">
			windows下sc create命令行添加/创建/修改服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows下sc create命令行添加/创建/修改服务 windows下sc create命令行添加/创建/修改服务 sc create BITS binpath= "C:\WINDOWS\system32\svchost.exe -k netsvcs" type= share start= auto displayname= "Background Intelligent Transfer Service" depend= RpcSs/EventSystem 修改描述： sc description BITS "利用空闲的网络带宽在后台传输文件。如果服务被停用，例如 Windows Update 和 MSN Explorer 的功能将无法自动下载程序和其他信息。如果此服务被禁用，任何依赖它的服务如果没有容错技术以直接通过 IE 传输文件，一旦 BITS 被禁用，就可能无法传输文件。" 添加服务： sc create PolicyAgent binpath= "C:\WINDOWS\system32\lsass.exe" type= share start= auto displayname= "IPSEC Services" depend= RPCSS/Tcpip/IPSec 修改描述： sc description PolicyAgent "提供 TCP/IP 网络上客户端和服务器之间端对端的安全。如果此服务被停用，网络上客户端和服务器之间的 TCP/IP 安全将不稳定。如果此服务被禁用，任何依赖它的服务将无法启动。" SC命令的更多用法请在查看help sc (注册表修改前请做好备份)， SvcHost共享服务的特别之处：或许重启后还需要到注册表位置：[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SvcHost]，查看"C:\WINDOWS\system32\svchost.exe -k netsvcs"以红色字为名的键(这里以netsvcs为例)，键值里是否定义有sc create BITS蓝色字的服务(这里以BITS为例)，如果没有就在键值把服务名(这里以BITS为例)添加上去,再重启一次。 =================================================================================
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8cb8822086b2871010741a22b7d3b33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1830fad53be48885fc33f6d1e50284e5/" rel="bookmark">
			Informix迁移至Oracle-数据清理方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要做2项数据清理工作：
1.字符串数据类型，出现后带空格情况
2.日期数据类型Date，Timestamp ，在informix中原始值0为1899-12-31，需要讲这些值清理为NULL
清理思路：
1.informix数据采用ETL工具将数据移入Oracle
2.编写Oracle sp对象，查询数据字典，查看每一个表中是否有如上数据类型字段，组装成字符串SQL，采用动态SQL的方式执行SQL语句
3.执行结果写入日志表，以便以后查阅
注意：
清理时，采用一个表一条sql会快很多
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be2a5d1ae36cb9270dcb7c653d43a148/" rel="bookmark">
			Git的诞生
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多人都知道，Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。
Linus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？
事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！
你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。
不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。
安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。
Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的：
Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。
Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。
历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b51eb283f85cd3eae2dff09be47995e/" rel="bookmark">
			步进机堵转检测的一种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		堵转检测其实就只有一种方法,那就是检测相电流,然后跟'参考值'对比.
然后就是这个参考值的选择了.因为输出的变化和电机负载,转速等因素,都会影响到电机的相电流.虽然输出是根据正弦波来变化的,但是最终测得的波形形状并不是正弦波.不过正是因为这样,为我们检测电机的状态留下了很多的线索.
这里,我们用到的是电机堵转以后反电动势的消失,在同样的输出下会引起相电流的增大.
当步进电机发生堵转时,因为其结构的原因,他一般很少能再次启动起来,除非转速非常低或者输出的电压非常大!所以,当电机发生堵转时,检测其相电流是否比正常运转大就可以达到堵转检测的目的.
大概就是这样.
转载于:https://www.cnblogs.com/EIo1jNrK/p/3375185.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45da60e8586fe1aef69b9fe8cc8f7a33/" rel="bookmark">
			windows路径操作API函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		路径截断与合并函数
PathRemoveArgs
去除路径的参数
PathRemoveBackslash
去除路径最后的反斜杠“\”
PathAddBackslash
在路径最后加上反斜杠“\”
PathRemoveBlanks
去除路径前后的空格
PathAddExtension
在文件路径后面加上扩展名
PathRemoveExtension
去除文件路径扩展名
PathRenameExtension
更改文件路径扩展名
PathRemoveFileSpec
去除文件名，得到目录
PathUnquoteSpaces
去除路径中的首尾空格
PathQuoteSpaces
判断路径中是否有空格，有的话，就是用“”引号把整个路径包含起来
PathAppend
将一个路径追加到另一个路径后面
PathCombine
合并两个路径
PathSkipRoot
去掉路径中的磁盘符或UNC部分。
PathStripPath
去掉路径中的目录部分，得到文件名。
PathStripToRoot
去掉路径的文件部分，得到根目录。
PathCompactPath
根据像素值生成符合长度的路径。
如原始路径： C:\path1\path2\sample.txt
根据120像素截断后为： C:\pat...\sample.txt
根据25像素截断后为: ...\sample.txt
PathCompactPathEx
根据字符个数来生成符合长度的路径。
PathSetDlgItemPath
将路径数据设置到对话框的子控件上。
PathUndecorate
去除路径中的修饰——具体还没看明白，MSDN的例子只是去掉了括号。
PathUnExpandEnvStrings
将路径中部分数据替换为系统环境变量格式
路径查找比较函数
PathFindOnPath
从路径中查找路径
PathFindExtension
查找路径的扩展名
PathFindFileName
获取路径的文件名
PathFindNextComponent
查找匹配路径（不太熟悉）
PathFindSuffixArray
查找给定的文件名是否有给定的后缀。
PathGetArgs
获取路径参数
PathGetCharType
获取路径字符类型
PathGetDriveNumber
根据逻辑盘符返回驱动器序号
路径转换函数
PathRelativePathTo
创建一个路径到另一个路径的相对路径。
PathResolve
将一个相对路径或绝对路径转换为一个合格的路径，这个理解起来比较拗口。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45da60e8586fe1aef69b9fe8cc8f7a33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c203a667069fbf67bb16d55394de75d4/" rel="bookmark">
			TRUNC函数的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TRUNC函数的用法 TRUNC函数用于对值进行截断。
用法有两种：TRUNC（NUMBER）表示截断数字，TRUNC（date）表示截断日期。
(1)截断数字：
格式：TRUNC（n1,n2），n1表示被截断的数字，n2表示要截断到那一位。n2可以是负数，表示截断小数点前。注意，TRUNC截断不是四舍五入。
SQL&gt; select TRUNC(15.79) from dual;
TRUNC(15.79)
------------
15
SQL&gt; select TRUNC(15.79,1) from dual;
TRUNC(15.79,1)
--------------
15.7
SQL&gt; select trunc(15.79,-1) from dual;
TRUNC(15.79,-1)
---------------
10
(2)截断日期：
先执行命令：alter session set nls_date_format='yyyy-mm-dd hh24:mi:hh';
截取今天：
SQL&gt; select sysdate,trunc(sysdate,'dd') from dual;
SYSDATE TRUNC(SYSDATE,'DD')
------------------- -------------------
2009-03-24 21:31:17 2009-03-24 00:00:00
截取本周第一天：
SQL&gt; select sysdate,trunc(sysdate,'d') from dual;
SYSDATE TRUNC(SYSDATE,'D')
------------------- -------------------
2009-03-24 21:29:32 2009-03-22 00:00:00
截取本月第一天：
SQL&gt; select sysdate,trunc(sysdate,'mm') from dual;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c203a667069fbf67bb16d55394de75d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0affd0e38b1c29a0d7382027019b2dd/" rel="bookmark">
			impdp导入数据 ORA-31684错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用expdp导出数据时没有任何报错，但在使用impdp导入时报ORA-31684错误
导入语法：
impdp slwebtest/slwebtest directory=slwebtest dumpfile=slwebtest1010.dmp logfile=slwebtest.log schemas=slwebtest 报错误内容：
ORA-31684: Object type USER:"slwebtest" already exists
解决办法：
在导入语法中加入 exclude=user 忽略用户对象已经存在的错误，如下示：
impdp slwebtest/slwebtest directory=slwebtest dumpfile=slwebtest1010.dmp logfile=slwebtest.log schemas=slwebtest exclude=user
转载于:https://blog.51cto.com/168ok8/1310092
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f23614cdc9fc38eb04e2364fabb6b380/" rel="bookmark">
			redhat 中安装rpm包时遇到错误 “error: Failed dependencies:xinetd is needed by ....”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		redhat中安装rpm包时遇到“error: Failed dependencies:”错误，如下：
rpm -ivh telnet-server-0.17-35.i386.rpm
warning: telnet-server-0.17-35.i386.rpm: Header V3 DSA signature: NOKEY,4f2a6fd2
error: Failed dependencies:
xinetd is needed by telnet-server-0.17-35.i386
解决方法：
1、先安装xinetd包
rpm -ivh xinetd-2.3.14-10.el5.x86_64.rpm
此rpm包在光盘介质中可以找到。
2、再安装telnet包
rpm -ivh telnet-server-0.17-35.i386.rpm
3、启动xinetd服务
service xinetd start
总之，需要先安装xinetd包即可。
4. 现在可以安装我们需要的rpm包了
rpm -ivh telnet-server-0.17-35.i386.rpm
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1dbeee4c3c9a53a2857b8886bec8ef7/" rel="bookmark">
			MyEclipse 8.6如何给类加上注释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 菜单：
Window/Preferences/Java/Code Style/Code Templates
Comments
Files 清空，否则类最上面有个空的注释块
Types 设置如下：
/** * @Description: * @Author: nutony * @CreateTime: ${date} */ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c59784c70c057b78d1994cf25387c206/" rel="bookmark">
			数据库编程书写规范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【规则-1】：所有代码统一使用小写字母书写。
例：
create or replace procedure p_check_package(
i_package_code number,
i_user_id number,
o_flag out number ) is
begin
o_flag := 0;
end p_check_package;
/
【规则-2】：确保变量和参数在类型和长度上与表数据列类型和长度相匹配。
说明：如果与表数据列宽度不匹配，则当较宽或较大的数据传进来时会产生运行异常。
【规则-3】：参数和变量的命名符合如下规范：
1、传入参数以“i_”为前缀；
2、传出参数以“o_”为前缀；
3、变量以“v_”为前缀
4、例如：
create or replace procedure P_GET_GLOBAL(i_operator_id in number,
i_session_id in number,
o_flag out number) is
v_cityID varchar(2);
v_region_level number(1);
begin
….
end;
【规则-4】：程序块中的begin、end独立成行。
【规则-5】：程序块采用缩进风格书写，保证代码清晰易读，风格一致，缩进格数统一。
例：
… …
begin
update CFG_CDR_REFRESH set CHANGE_TIME=sysdate where CFG_TYPE=5;
if sql%rowcount = 0 then
insert into CFG_CDR_REFRESH(CFG_TYPE,CHANGE_TIME,STATE)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c59784c70c057b78d1994cf25387c206/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/401bee6dbb0fbe0c0c8c8fe2e6550437/" rel="bookmark">
			iOS 点击return或者点击屏幕键盘消失
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 [cpp] view plain copy //定义两个文本框 UITextField *textName; UITextField *textSummary; //点击return 按钮 去掉 -(BOOL)textFieldShouldReturn:(UITextField *)textField { [textField resignFirstResponder]; return YES; } //点击屏幕空白处去掉键盘 - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event { [self.textName resignFirstResponder]; [self.textSummary resignFirstResponder]; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/041c1a8ea7f3e319f25e8760e86e447b/" rel="bookmark">
			sequence point顺序点，side effect副作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		In C99 --- 6.5 Expressions
Between the previous and next sequence point an object shall have its stored value modified at most once by the evaluation of an expression. Furthermore, the prior value shall be read only to determine the value to be stored 2. Between the previous and next sequence point an object shall have its stored valuemodified at most once by the evaluation of an expression. Furthermore, the prior value shall be read only to determine the value to be stored.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/041c1a8ea7f3e319f25e8760e86e447b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4eb008f49e770ed31a5d139b78c428e4/" rel="bookmark">
			从细节看，为何360能独占鳌头
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天无意翻看工具目录，发现一个截图软件。QQ的很好用，但必须开启QQ。不方便。
试试这个，单击运行很方便，但功能简单，只能抓图，另存图片。不能图上做标记。
无意调整下谷歌工具栏，看到它竟然有截图插件，下载。
很快，但功能也及其简单。只多了打开系统带的画笔。
无意看360工具栏。它也有截图。试试。
强大，其他和QQ无两样。但它有个荧光笔功能，很好用，效果漂亮。
表示钦佩！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82412ba9d758b8b366aa6dd292bf3332/" rel="bookmark">
			MySQL的备份与恢复简介和使用mysqldump备份MySQL数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文首发自《旺旺知识库》http://www.toxingwang.com/database/mysql/1504.html
一、备份的类型和其他说明： 1.1 按备份时服务器是否继续提供服务区分： 热备份：备份时读写都不受影响
温备份：备份时仅可进行读操作
冷备份：也叫离线备份，读写操作均中止
不同的存储引擎对备份的支持也是不一样的，MyISAM存储引擎可以使用LVM快照功能配合实现热备份，如果没有LVM，则只能实现温备份。而InnoDB则可以完全支持热备，可使用的热备工具有：xtrabackup, mysqldump等
从数据的安全角度来说，离线备份（冷备份）是最安全的，且是最快速的。但离线备份需要停止服务，对业务带来影响。如果MySQL服务器存在主从服务器，则可以使用将从服务器停机进行冷备份，即保证服务，又保障数据数据安全。
1.2 按备份操作方式区分： 物理备份：复制数据文件，特点：速度快
逻辑备份：将数据导出至文本文件中，特点：速度慢、丢失浮点数精度；方便使用文本处理工具直接对其处理、可移植能力强
1.3 按是否备份全部数据还是只备份部分数据区别： 完全备份：备份全部需要备份的数据
增量备份：仅备份上次完全备份或增量备份以后变化的数据
差异备份：仅备份上次完全备份依赖变化的数据
一般情况下，根据备份策略组合使用：完全+增量；完全+差异
1.4 其他说明： 备份的目的是在灾难发生时用来还原，因此为了保证可以还原，因此需要定期进行恢复测试，另外还需要根据实际情况制定最优的备份和恢复策略。
那么MySQL备份需要备份那些数据呢？
主要包括：数据、配置文件、二进制日志、事务日志
二、备份工具介绍： 2.1 MySQL备份工具： mysqldump: 逻辑备份工具、MyISAM(温)、InnoDB(热备份)
mysqlhotcopy：物理备份工具、温备份
2.2 文件系统工具： cp：冷备份
lv：逻辑卷的快照功能，可以实现几乎热备的功能，备份过程如下：
mysql&gt; FLUSH TABLES;
mysql&gt; LOCK TABLES
然后创建快照：释放锁，而后复制数据
2.3 第三方工具： ibbackup: 商业工具，备份速度非常快，支持热备份，但同时也非常贵
xtrabackup: 开源工具
三、使用mysqldump对MySQL进行备份： 3.1 基本语法： 备份单个数据或单个数据中的指定表： mysqldump [OPTIONS] database [tb1] [tb2]…
备份多个数据库： mysqldump [OPTIONS] --databases [OPTIONS] DB1 [DB2 DB3...]
备份所有数据库： mysqldump [OPTIONS] --all-databases [OPTIONS]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82412ba9d758b8b366aa6dd292bf3332/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56d8619ff13f3ef296405f266a048b55/" rel="bookmark">
			TimePickerDialog控件详细使用介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		14.1.TimePickerDialog控件 14.1.1.概述 TimerPickerDialog：修改时间对话框，效果如下：
图－1
14.1.2.重要接口、方法 1、OnTimeSetListener
作用：监听图－1中set按钮的单击事件。该接口声明了如下方法：
void onTimeSet(TimePicker view, int hourOfDay, int minute);
参数说明：
第一个参数-view：当前的TimePicker对象。
第二个参数-hourOfDay：设置的小时的值。
第三个参数-minute：设置的分钟的值。
2、public TimePickerDialog(Context context,
OnTimeSetListener callBack,
int hourOfDay, int minute, boolean is24HourView)
作用：构造方法。
参数说明：
第一个参数-context：上下文对象，存放当前Activity对象。
第二个参数－callback：实现了OnTimeSetListener接口的对象。在该对象的onTimeSet方法中编写用户单击图－1中set按钮时的代码。
第四个参数-hourOfDay：设置的小时的值。
第五个参数-minute：设置的分钟的值。
第六个参数-is24HourView：是否按24小时格式显示数字。
14.1.3.示例 //创建TimePickerDialog对象，设置时间为21点30分，按24小时格式显示时间
TimePickerDialog dialog=new TimePickerDialog(this, new OnTimeSetListener() {
//实现响应用户单击set按钮的事件方法
@Override
public void onTimeSet(TimePicker view, int hourOfDay, int minute) {
Toast.makeText(MainAct.this, "TimePicker", 3000).show();
}
}, 21, 30, true);
dialog.show();//显示设置时间对话框
14.2.DatePickerDialog控件 14.2.1.概述 DatePicker：修改日期对话框，效果如图－2所示：
图－2
14.2.2.重要接口、方法 1、OnDateSetListener接口
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56d8619ff13f3ef296405f266a048b55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1d7babc866999bfb2459d06e490929f/" rel="bookmark">
			SSH客户端显示中文乱码问题的解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题描述： LINUX安装时候选择的是中文， SSH 连接LINUX,中文出现乱码 问题原因： 此种情况的乱码，一般都是终端和服务器编码不一致造成的，问题关键是搞清楚两者的编码格式，然后改成一致即可。 SSH使用的是本地编码，比如windows是GBK,而LINUX服务器编码是UTF-8，由于编码不一致导致中文出现乱码。 解决方案： 1）在/etc/sysconfig/i18N下修改配置文件如下： LANG="zh_CN.GB18030" SUPPORTED="zh_CN.GB18030:zh_CN:zh:en_US.UTF-8:en_US:en" SYSFONT="latarcyrheb-sun16" 保存之后，SSH重新登录既可以显示中文了 注意：LANG 设置当前系统的语言环境变量，SUPPORTED 设置系统预置语言支持，SYSFONT定义控制台终端字体 2）无权限修改/etc/sysconfig/i18N时，执行如下命令 #export LANG=C #export LC_ALL=zh_CN.GBK #export LANG=zh_CN.GBK 3）使用其他可以选择编码的工具，比如PuTTy 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc412ae9b5b8624bf746d9720c2ba346/" rel="bookmark">
			通过nginx实现内网hadoop、hbase集群对外访问web界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载请标明出处：http://blackwing.iteye.com/blog/1949154 不少公司为了安全，hadoop、hbase集群都是不对外开放，只有一台入口机对外，那么当要查看hadoop、hbase集群机器状态等信息时，就没办法了。 而要实现内网机器给外网访问，要解决的问题是： 1.hadoop、hbase页面上的url替换成外网能访问的url 2.通过有限的端口、外网ip对外提供整集群访问 强大的nginx正好能解决这个问题。而nginx要替换返回的页面内容，虽然它自己有模块可以实现，但据了解只能替换一次，而网上比较常用的是第三方的替换模块nginx_substitutions_filter，其主页： http://code.google.com/p/substitutions4nginx/ 整个实现步骤为： 1. 下载nginx_substitutions_filter并解压： 根据官方的建议： git clone git://github.com/yaoweibin/ngx_http_substitutions_filter_module.git 2. 下载nginx稳定版并解压： wget http://nginx.org/download/nginx-1.4.2.tar.gz 3. 编译安装 根据自己需要选择要适应的模块，并且指定substitutions4nginx模块的路径 ./configure --prefix=/usr/local/nginx --pid-path=/usr/local/nginx.pid --with-http_dav_module --with-http_flv_module --with-http_realip_module --with-http_gzip_static_module --with-http_stub_status_module --with-debug --add-module=/home/hadoop/nginx/third-party-md/ngx_http_substitutions_filter_module/ make
make install
4. 配置nginx.conf #替换hbase
server {
listen 8000; location / {
proxy_pass http://master;
subs_filter_types text/html text/css text/xml;
subs_filter hd1:60030 192.168.1.25:8000/hd11;
subs_filter hd2:60030 192.168.1.25:8000/hd22;
}
location /hd11/ {
proxy_pass http://192.168.1.25:60030/rs-status;
}
location /hd22/ {
proxy_pass http://192.168.1.30:60030/rs-status;
}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc412ae9b5b8624bf746d9720c2ba346/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3da41aeba46bfb8b67f225c1e25b0c9e/" rel="bookmark">
			在VS C&#43;&#43;中调试DLL工程的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在做项目过程中，需要做一些DLL提供接口，方便调用的，但是DLL工程不能直接运行，需要其他调用才可以，懂的调试DLL是在做项目中学到，贴出来供大家学习。
一般VS版本不一样，可能会有点小差异，但是大体的意思是一致，如下是步骤：
1、找到要调试的DLL项目，将要调试的DLL工程设置为调试启动项目；然后选择DLL项目，点击右键，选择Properties（属性），打开属性页设置页面。
2、在Properties 页面的中，选择Configuration Properties（配置属性）下拉菜单，然后选择Debugging（调试）。
3、在Debugging的页面中，在第一行Debugger to launch（要启动的调试器）的下拉菜单中，如果是本地调试选择Local Windows Debugger，远程调试选择Remote Windows Debugger，效果如下图：
4、在Debugging的页面中，Command中选择下拉菜单，找到引用该dll的应用程序；在Command Arguments中输入$(TargetFileName)，或者自己从下拉框中选择，然后在此字符串后面 输入dll文件导出的函数名：
如我有两个导出函数：fndlltest（）和OutData() ,则应该写为：
$(TargetFileName) fndlltest; OutData 5、在Debugging的页面中，Working Directory下拉菜单，选择当前工作目录，如Debug，效果图如下：
6、在常规中将输出目录设置为调用DLL程序的Debug目录，不然系统会提示dll不存在的提示，须在windows下的system32中添加，效果如下图：
如此在DLL项目要调试的代码段中设置断点，开始调试，就可以跳转到DLL中的断点。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcf40b93ff3d80255b4654cd668f1b40/" rel="bookmark">
			hadoop 三次排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据
10.0.0.1,192.168.0.1,1000010.0.0.1,192.168.0.1,1000110.0.0.1,192.168.0.1,1000210.0.0.1,192.168.0.2,1000010.0.0.1,192.168.0.2,1000110.0.0.1,192.168.0.3,0999910.0.0.1,192.168.0.3,1000010.0.0.2,192.168.0.1,1000110.0.0.2,192.168.0.1,1000210.0.0.2,192.168.0.2,1000010.0.0.2,192.168.0.2,1000310.0.0.3,192.168.0.1,1000010.0.0.3,192.168.0.1,1000110.0.0.3,192.168.0.1,1000110.0.0.3,192.168.0.1,1000210.0.0.3,192.168.0.1,1000410.0.0.3,192.168.0.3,1000510.0.0.3,192.168.0.3,1000610.0.0.3,192.168.0.3,1000710.0.0.3,192.168.0.3,10008 打乱顺序
10.0.0.3,192.168.0.3,1000510.0.0.1,192.168.0.1,1000010.0.0.3,192.168.0.1,1000110.0.0.2,192.168.0.2,1000010.0.0.3,192.168.0.1,1000410.0.0.3,192.168.0.1,1000210.0.0.2,192.168.0.1,1000110.0.0.1,192.168.0.1,1000210.0.0.3,192.168.0.1,1000010.0.0.3,192.168.0.3,1000610.0.0.1,192.168.0.3,0999910.0.0.3,192.168.0.3,1000810.0.0.1,192.168.0.3,1000010.0.0.1,192.168.0.1,1000110.0.0.3,192.168.0.3,1000710.0.0.1,192.168.0.2,1000010.0.0.2,192.168.0.1,1000210.0.0.1,192.168.0.2,1000110.0.0.3,192.168.0.1,1000110.0.0.2,192.168.0.2,10003 自定义结构
import java.io.DataInput;import java.io.DataOutput;import java.io.IOException;import org.apache.hadoop.io.Text;import org.apache.hadoop.io.WritableComparable;import org.apache.hadoop.io.WritableComparator;public class TriTuple implements WritableComparable&lt;TriTuple&gt;{private Text serverIP;private Text clientIP;private Text time;public TriTuple(){serverIP = new Text();clientIP = new Text();time = new Text();}public Text getServerIP(){return serverIP;}public void setServerIP(Text serverIP){this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dcf40b93ff3d80255b4654cd668f1b40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98f4ae98f99b144f840c06b39c2682fe/" rel="bookmark">
			java的MD5加密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 /** * MD5加密 * @param plainText * @return */ public String Md5(String plainText) { String md5=""; try { MessageDigest md = MessageDigest.getInstance("MD5"); md.update(plainText.getBytes()); byte b[] = md.digest(); int i; StringBuffer buf = new StringBuffer(""); for (int offset = 0; offset &lt; b.length; offset++) { i = b[offset]; if(i&lt;0) i+= 256; if(i&lt;16) buf.append("0"); buf.append(Integer.toHexString(i)); } //返回32位加密 md5=buf.toString(); } catch (NoSuchAlgorithmException e) { // TODO Auto-generated catch block e.printStackTrace(); } return md5; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf6778c3efa963ce7c384b885b4b6a88/" rel="bookmark">
			什么是段错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是段错误 段错误是指程序尝试访问一段不可访问的内存。
在类Unix系统中，当出现段错误时，系统发送信号量SIGSEGV给产生段错误的进程；在Windows系统中，系统会发送异常STATUS_ACCESS_VIOLATION给产生段错误的进程。
产生段错误的原因 程序运行过程中能访问到的内存空间主要有栈和堆。栈存放了函数的本地变量，堆是程序运行过程中能够自由分配和使用的内存空间。产生段错误和栈、堆的访问密切相关。
产生段错误的原因主要有：
解引用空指针访问不可访问的内存空间（如内核空间）访问不存在的内存地址试图写一个只读内存空间（如代码段）栈溢出（函数递归调用）使用未初始化的指针（定义时没有初始化或者已经回收） 避免段错误 定义指针后初始化数组下标是否越界在堆上分配空间是否足够（内存限制）变量处理时格式控制是否合理 调试段错误 在Linux系统下，首先开启core dump：
ulimit -c unlimited 然后执行段错误的程序：
./a.out 程序出现段错误后，会出现如下提示：
Segmentation fault (core dumped) 表明生成了core文件，存放在/proc/sys/kernel/core_pattern目录下，然后可以使用GDB进行调试。
$ gdb ./a.out core 用来查看文件出错的情况。
执行bt命令可以查看段出错的过程中调用的函数，如：
#0 0x0000000000441337 in ReorderBySort::Reorder (this=&lt;value optimized out&gt;, index_files=@0x7fff704326b0, order=ReorderBySort::ORIGIN) at /usr/include/c++/4.3/bits/stl_vector.h:688 #1 0x00000000004424e7 in ReorderProcessor::Reorder (this=0x7fff704326b0) at src/reorder.cpp:57 #2 0x00000000004458a9 in Reorder () at src/indexer.cc:396 #3 0x00000000004497ed in main (argc=3, argv=&lt;value optimized out&gt;) at src/indexer.cc:1169 调用顺序是
main -&gt; Reorder -&gt; ReorderProcessor::Reorder -&gt; stl_vector.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf6778c3efa963ce7c384b885b4b6a88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aca9c91f1211282bcf7f2043b5b3a585/" rel="bookmark">
			Linux C 多线程编写-----例子：10个售票窗口协作卖掉150张票
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个是比较简单的例子，有助于初学多线程的人理解多线程的工作模式，后期会不断的跟进多线程的进阶应用等。
储备知识：
1.多线程是一种多任务并发的工作方式，在linux中线程包括内核线程和用户线程，内核线程有内核管理，不需要我们做更多的工作，我们这里将的是用户线程，线程统一由用户线程来切换。
2.线程相关函数：
int pthread_create(pthread_t id,pthread_attr_t *attr, void *(*start_runtine)(void *), void *arg);//线程创建函数
获取线程ID（即上面创建的pthread_t id）:pthread_t pthread_self();
退出线程：void pthread_exit(void *retval);
挂起线程：int pthread_join(pthread_t id,void **return);
线程同步：在POSIX中提供线程同步的方式有两种，条件变量和互斥锁
互斥锁：
pthread_mutex_t *mutex;//互斥锁变量
int pthread_mutex_init(pthread_mutex_t *mutex, pthread_attr_t *attr);//初始化一个互斥锁
int pthread_mutex_lock(pthread_mutex_t *mutex);//锁定互斥锁，这样子当一个线程锁定的话，另一个线程就会处于等待状态
int pthread_mutex_unlock(pthread_mutex_t *mutex);//解锁互斥锁，如果解锁后，处于等待状态的线程就有机会访问临界区
条件变量：其实是对互斥锁的一种补充，因为线程可以在等待条件变量的时候同时解锁，这在生产者和消费者模式可以体现。
pthread_cond_t cond;
int pthread_cond_init(pthread_cond_t *cond, const pthread_cond_addr *attr);//初始化一个条件变量，后面参数attr是条件变量的属性
int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);//释放互斥量mutex，等待条件变量cond
int pthread_cond_timewait(pthread_cond_t *cond, pthread_mutex_t *mutex，const struct timespec *abstime);//释放互斥量mutex，等待条件变量cond,与pthread_cond_wait函数不一样的是，该函数可以是线程在abstime时间内不阻塞。
int pthread_cond_signal(pthread_cond_t *cond);//释放条件变量
int pthread_cond_broadcast(pthread_cond_t *cond);//释放所有由cond阻塞的线程，这里要小心使用
3.线程属性，这些属性在使用前，必须调用相关的初始化函数pthread_xxx_init(xxx *);
线程属性：pthread_attr_t typedef struct { int detachstate; 线程的分离状态，这个跟pthread_join相关，如果一个线程调用join获取另一个线程的状态的时候，就需要用到这个属性。 int schedpolicy; 线程调度策略 struct sched_param schedparam; 线程的调度参数 int inheritsched; 线程的继承性 int scope; 线程的作用域 size_t guardsize; 线程栈末尾的警戒缓冲区大小 int stackaddr_set; void * stackaddr; 线程栈的位置 size_t stacksize; 线程栈的大小 }pthread_attr_t; 上面的相关属性，POSIX大部分都提供了相应的接口来操作。如设置调度测略：int pthread_attr_setschedpolicy(pthread_attr_t *attr, int policy);等 int pthread_attr_init(pthread_attr_t *attr);//初始化线程属性对象
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aca9c91f1211282bcf7f2043b5b3a585/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/447bc99fae0322b9f3f8f9a535d0710d/" rel="bookmark">
			*PyQt4 精彩实例分析* 实例3 各类位置信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qt提供了很多关于获取窗体位置及显示区域大小的函数，本实例利用一个简单的对话框显示窗体的各种位置信息，包括窗体的所在点位置，长，宽信息等。本实例的目的是分析各个有关位置信息的函数之间的区别，如x(),y(),pos(),rect(),size(),geometry()等，以及在不同的情况下应使用哪个函数来获取位置信息。实现的效果如下图：
在实例中，分别调用了x(),y(),frameGeometry(),pos(),geometry(),width(),height(),rect(),size()几个函数，这几个函数均是QWidget提供的。当改变对话框的大小，或移动对话框时，调用各个函数所获得的信息显示也相应地发生变化，从变化中可得知各函数之间的区别。
由于本实例的目的是为了分析各函数之间的区别并获得结论，而程序本身的实现较为简单，因些只简单介绍实现过程。实现代码如下：
[python] view plain copy from PyQt4.QtCore import * from PyQt4.QtGui import * import sys class Geometry(QDialog): def __init__(self,parent=None): super(Geometry,self).__init__(parent) self.setWindowTitle("Geometry") Label1=QLabel("x0:") Label2=QLabel("y0:") Label3=QLabel("frameGeometry():") Label4=QLabel("pos():") Label5=QLabel("geometry():") Label6=QLabel("width():") Label7=QLabel("height():") Label8=QLabel("rect():") Label9=QLabel("size():") self.xLabel=QLabel() self.yLabel=QLabel() self.frameGeoLabel=QLabel() self.posLabel=QLabel() self.geoLabel=QLabel() self.widthLabel=QLabel() self.heightLabel=QLabel() self.rectLabel=QLabel() self.sizeLabel=QLabel() layout=QGridLayout() layout.addWidget(Label1,0,0) layout.addWidget(self.xLabel,0,1) layout.addWidget(Label2,1,0) layout.addWidget(self.yLabel,1,1) layout.addWidget(Label3,2,0) layout.addWidget(self.frameGeoLabel,2,1) layout.addWidget(Label4,3,0) layout.addWidget(self.posLabel,3,1) layout.addWidget(Label5,4,0) layout.addWidget(self.geoLabel,4,1) layout.addWidget(Label6,5,0) layout.addWidget(self.widthLabel,5,1) layout.addWidget(Label7,6,0) layout.addWidget(self.heightLabel,6,1) layout.addWidget(Label8,7,0) layout.addWidget(self.rectLabel,7,1) layout.addWidget(Label9,8,0) layout.addWidget(self.sizeLabel,8,1) self.setLayout(layout) self.updateLabel() def moveEvent(self,event): self.updateLabel() def resizeEvent(self,event): self.updateLabel() def updateLabel(self): temp=QString() self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/447bc99fae0322b9f3f8f9a535d0710d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b38caa5bf9f18a2c7ee9a7945722bc6/" rel="bookmark">
			PHP 多线程扩展（正儿八经的线程）pthreads安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境CentOS 6.3 64bit，php 5.4.5
pthreads需要线程安全环境，
下载php的安装包，解压：
tar zxvf php-5.4.5.tar.gz//名字是不是这个我不确定，自己去下载
安装：
./configure --enable-zts --prefix=/usr/local/php-zts //或者 --enable-maintainer-zts
make
make install
结果就把线程安装版的php安装到了/usr/local/php-zts，目前我不了解开启线程安全到底会带来什么影响，所以，就弄两个测试版本。
如果遇到undefined reference to `executor_globals_id'
make clean就可以了
下载和安装pthreads:
tar zxvf pthreads
cd pthreads-0.0.45 // 本文的是第一个stable版本
/usr/local/php-zts/bin/phpize
./configure --with-php-config=/usr/local/php-zts/bin/php-config
make
make install
/usr/local/php-zts/bin/php -i|grep "php.ini"
找出php.ini的位置，修改它把ext=pthreads.so加入进入进去，因为我原来就有php，现在新装的php.ini文件不存在我就考了一个过去……
pthreads-0.0.45/examples目录下有些示例文件，比文档有用，在线文档根本不能说明问题，我修改了一个，执行了一下：
&lt;?php /* * Sharing symbols 101 * @NOTE Thread::fetch was never included in a release and was superceeded by object handlers * pthreads allows read access to thread data from any context pthreads allows write access to thread data from any context carry on reading .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b38caa5bf9f18a2c7ee9a7945722bc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/781e3b10840cc816eedc71f791b36ef3/" rel="bookmark">
			仿新浪微博客户端--界面设计（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		仿新浪微博客户端--界面设计（1）
2013年9月16日 新浪微博客户端继续开发
其实这些页面已经做好很久了，因为一直有其他事情要做，所以没太多时间发博客。关于新浪微博客户端的界面我想玩过微博的人都比较熟悉了，新版的客户端界面也发生了很大的变化，我这里也无法做到面面俱到，只能参考着来做咯。事先说明，一本人不太会美工，二这个项目只能当作参考，也是作为小巫学习的一个途径。各位有啥问题，自己想法子解决哈。 先来尝尝鲜吧：
以上五个界面就是主界面的效果图啦，布局其实并不复杂就是有点繁琐罢了，一般由三部分组成，顶部是标题栏，中间是显示列表或内容部分，底部是tabbar栏。
下面一个一个界面来说：
首先介绍底部的tabbar吧
/Wwj_sina_weibo/res/layout/tabbar.xml
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;TabHost xmlns:android="http://schemas.android.com/apk/res/android" android:id="@android:id/tabhost" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" &gt; &lt;FrameLayout android:id="@+id/msg_title" android:layout_width="match_parent" android:layout_height="wrap_content" android:visibility="gone" &gt; &lt;/FrameLayout&gt; &lt;FrameLayout android:id="@android:id/tabcontent" android:layout_width="match_parent" android:layout_height="0.0dip" android:layout_weight="1.0" /&gt; &lt;!-- TabHost必须要有 TabWidget 否则要报错,我们这里设置它不可见 --&gt; &lt;TabWidget android:id="@android:id/tabs" android:layout_width="fill_parent" android:layout_height="wrap_content" android:layout_weight="0.0" android:visibility="gone" /&gt; &lt;!-- 底部按钮 --&gt; &lt;RadioGroup android:id="@+id/main_radio" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_gravity="bottom" android:gravity="center_horizontal" android:orientation="horizontal" android:background="@drawable/tabbar_background"&gt; &lt;RadioButton android:id="@+id/tabbar_home" style="@style/main_tab_bottom" android:layout_marginTop="2.0dip" android:drawableTop="@drawable/tabbar_home_selector" android:tag="tabbar_home" android:text="@string/home" /&gt; &lt;RadioButton android:id="@+id/tabbar_message" style="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/781e3b10840cc816eedc71f791b36ef3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2005bc74b8aacc36b4e82e5fec8ad5c4/" rel="bookmark">
			poj 1631 Bridging signals 最长上升子序列的O(n*lgn)方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在普通动规基础上,设一个数组d[i],表示到现在为止长度为i的子序列的末尾数字的最小值.显然对于求最长上升子序列由b[i-1] &lt;= b[i] 则b为有序的,可以只用折半查找，从O(n)降到O(nlgn) 。整体时间由 O(n*n) 降到 O(n * lgn).
代码：
#include &lt;stdio.h&gt; #include &lt;iostream&gt; #include &lt;cstring&gt; using namespace std; int n; #define MAX_N 40001 int N[MAX_N]; int bl=0; int b[MAX_N]; int dp[MAX_N]; /* O(n2) int solve() { int ret =0; dp[0]=0; for(int i=1;i&lt;=n;i++) { int maxl = 0; for(int j=1;j&lt;i;j++) { if(N[j] &lt; N[i] &amp;&amp; dp[j] &gt; maxl) maxl = dp[j]; } dp[i] = maxl+1; if(dp[i] &gt; ret) ret = dp[i]; } return ret; } */ // O(n lg n) 优化 引入b[n]数组 // b[i] d[i],表示到现在为止长度为i的子序列的末尾数字的最小值.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2005bc74b8aacc36b4e82e5fec8ad5c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d8999707624c0d5992109a0936f1427/" rel="bookmark">
			android  代码混淆   不混淆第三方jar包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码混淆比较简单，新版本的是用proguard-project.txt 在project.properties文件最后一行加上下面的指令就行：
proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
（在project.properties文件的注释部分，有上面的指令，直接粘过来就行）
第三方jar包避免混淆用下面的方法：
在proguard-project.txt 文件中加入：
-ignorewarnings
-libraryjars libs/XX （“XX”是jar包名）
-libraryjars libs/XX -libraryjars libs/XX 。
。
例如：混淆android-support-v4.jar
-ignorewarnings
-libraryjars libs/android-support-v4.jar
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/965576c2276811af9700cd2075d9e3ea/" rel="bookmark">
			iOS textView的使用总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在.h文件中声明：
@interface ProtocolViewController :UIViewController&lt;UITextViewDelegate&gt;
{
UITextView *textView;
}
@property (nonatomic,retain)UITextView *textView;
@end
在.m中初始化：
self.textView=[[[UITextView alloc] initWithFrame:self.view.frame] autorelease]; //初始化大小并自动释放 self.textView.textColor = [UIColor blackColor]; //设置textview里面的字体颜色 self.textView.font = [UIFont fontWithName:@ "Arial" size:18.0]; //设置字体名字和字体大小 self.textView.delegate = self; //设置它的委托方法 self.textView.backgroundColor = [UIColor whiteColor]; //设置它的背景颜色 self.textView.text = @ "abcdefghi\nkjhk\nhkjhkjhksaejodslkae\nnfdkshekhfkdsae\nfdhskejhkfhskejh\ngfdhsgaejhgfjhdsgaejhgfjhdsgaejhgfdjsagejhgfhjsagejhgfdsjahgejhfgdsjha" ; //设置它显示的内容 self.textView.returnKeyType = UIReturnKeyDefault; //返回键的类型 self.textView.keyboardType = UIKeyboardTypeDefault; //键盘类型 self.textView.scrollEnabled = YES; //是否可以拖动 self . textView . editable = NO ; //禁止编辑 self.textView.autoresizingMask = UIViewAutoresizingFlexibleHeight; //自适应高度 [self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/965576c2276811af9700cd2075d9e3ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c7c52eed6d6c008f47d03fb5a171a3f/" rel="bookmark">
			JavaBean中的get/set 的命名规范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近的struts项目中遇到了这样的问题： 我的action中全局变量明明有getset方法，而且是自动生成的，但是在使用的时候，总是说找不到这个属性的getset方法，取不到从jsp传来的值， 原因如下：变量名为：hDeptment，在自动生成getset方法为：setHDeptment,getHDeptment。下面是解释这个问题。 （1）JavaBean 类必须是一个公共类，并将其访问属性设置为 public ，如： public class user{......}
（2）JavaBean 类必须有一个空的构造函数：类中必须有一个不带参数的公用构造器 （3）一个javaBean类不应有公共实例变量，类变量都为private ，如： private int id; （4）属性应该通过一组存取方法（getXxx 和 setXxx）来访问，一般是IDE(Eclipse、JBuilder) 为属性生成getter/setter 方法 一般JavaBean属性以小写字母开头，驼峰命名格式，相应的 getter/setter 方法是 get/set 接上首字母大写的属性名。例如：属性名为userName，其对应的getter/setter 方法是 getUserName/setUserName。 但是，还有一些特殊情况： 1、如果属性名的第二个字母大写，那么该属性名直接用作 getter/setter 方法中 get/set 的后部分，就是说大小写不变。例如属性名为uName，方法是getuName/setuName。 2、如果前两个字母是大写（一般的专有名词和缩略词都会大写），也是属性名直接用作 getter/setter 方法中 get/set 的后部分。例如属性名为URL，方法是getURL/setURL。 3、如果首字母大写，也是属性名直接用作 getter/setter 方法中 get/set 的后部分。例如属性名为Name，方法是getName/setName，这种是最糟糕的情况，会找不到属性出错，因为默认的属性名是name。 所以在action的全局变量和JavaBean命名时应该注意符合以上命名规范。 附下表，看看吧：
———————————————————————————————————————————————————————— 属性名/类型 | getter 方法 | setter 方法 ————————————|——————————————————|—————————————————————————— xcoordinate/Double | public Double getXcoordinate() | public void setXcoordinate(Double newValue) ————————————|——————————————————|—————————————————————————— xCoordinate/Double | public Double getxCoordinate() |public void setxCoordinate(Double newValue) ————————————|——————————————————|—————————————————————————— XCoordinate/Double |public Double getXCoordinate() | public void setXCoordinate(Double newValue) ————————————|——————————————————|—————————————————————————— Xcoordinate/Double |不允许 | 不允许 ————————————|——————————————————|—————————————————————————— 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9b29f2e76ad04f4e299c24934031572/" rel="bookmark">
			Never awaitUninterruptibly() on Netty Channels
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		05.03 | Never awaitUninterruptibly() on Netty Channels A quick tip about waiting on Channels in Netty.
TL:DR; When acquiring Channels in Netty, always use a ChannelFutureListenerand never awaitUninterruptibly(). Curious why? Read on.
In the Java SDK for Couchbase, we use Netty to establish and maintain a streaming connection to one of the cluster nodes in order to get notified when topology changes happen. This streaming connection needs to be established during the bootstrap process of the client and we need to block until the connection is established (actually we don't need to, but the current implementation works that way).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9b29f2e76ad04f4e299c24934031572/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9fa9bd81906af1ea5f7643b710db729/" rel="bookmark">
			SQL 描述（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个标题源于大学的一个老师，他说SQL语句可以描述很多东西，而这种能力就叫做SQL描述。我真的信了，我百度了，google了，关于我想的那种解释半点都没。
我记错了？不过这说法还是很不错的，近来做项目，越来越感觉到SQL的强大。我用的是ORACLE，其他数据库接触的不多。先说几个有趣的例子。
1 有限自然数序列
select LEVEL N from dual CONNECT BY LEVEL &lt;=122 level 据说是个伪列，connect by 类似与 for 循环中的 循环变量 2 无限自然数序列 select LEVEL N from dual CONNECT BY 1=1 判断永远成立，就是无限循环
3 斐波那契数列 with G as (select LEVEL N from dual CONNECT BY LEVEL &lt;=122), M as (select n,case when n=1 then 0 when n=2 then 1 else null end as v from g) select n,v from m model dimension by (n) measures (v) ( v[n&gt;2]=v[cv(n)-1]+v[cv(n)-2] ) with 将后面的查询结果集表示为一个表，可以用 逗号 隔开 支持多个结果集表，但最后的针对表的查询后面不用逗号。最后的查询要将前面定义的所有表都使用了，不然报错。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9fa9bd81906af1ea5f7643b710db729/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf7d0be2ff8e6cf55f2da613521d816e/" rel="bookmark">
			iOS pdf的显示和浏览
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一：利用webview -(void)loadDocument:(NSString *)documentName inView:(UIWebView *)webView { NSString *path = [[NSBundle mainBundle] pathForResource:documentName ofType:nil]; NSURL *url = [NSURL fileURLWithPath:path]; NSURLRequest *request = [NSURLRequest requestWithURL:url]; [webView loadRequest:request]; } 利：1.实现简单 2.还是实现简单
弊：1.仅能浏览，拿不到任何回调，safari不会鸟任何人。
2.固定竖版拖动，想实现翻页动效果就扒瞎
下面的方法可以解决webview 显示pdf的弊，相对的，要付出一些汗水作为代价了。
方法二：利用CGContextDrawPDFPage CGPDFDocumentRef GetPDFDocumentRef(NSString *filename) { CFStringRef path; CFURLRef url; CGPDFDocumentRef document; size_t count; path = CFStringCreateWithCString (NULL, [filename UTF8String], kCFStringEncodingUTF8); url = CFURLCreateWithFileSystemPath (NULL, path, kCFURLPOSIXPathStyle, 0); CFRelease (path); document = CGPDFDocumentCreateWithURL (url); CFRelease(url); count = CGPDFDocumentGetNumberOfPages (document); if (count == 0) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf7d0be2ff8e6cf55f2da613521d816e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dca5c96254b8218afd520a86761cc9d/" rel="bookmark">
			开源解析XML的解析库TinyXML
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在做公司项目的需求，要对配置文件进行操作，从而接触了MSXML2和TinyXML，公司的公共库是用微软的MSXML2实现的，实现起来比较麻烦的，刚开始看的时候有点小困难，网上就搜索了一些c++方面的解析器，觉得开源的TinyXML还是不错的，使用起来很舒服，因为它的API接口和JAVA的十分类似，面向对象性很好。
TinyXML是一个开源的解析XML的解析库，能够用于C++，能够在Windows或Linux中编译。这个解析库的模型通过解析XML文件，然后在内存中生成DOM模型，从而让我们很方便的遍历这棵XML树。DOM模型即文档对象模型，是将整个文档分成多个元素（如书、章、节、段等），并利用树型结构表示这些元素之间的顺序关系以及嵌套包含关系。
要用TinyXML，主要需要两个文件头(.h)以及四个源文件(.c++)，将其导入到需要的工程，当然也可以编译成dll文件进行调用，所需要的文件会在我的例子工程中存在，可以自主去下载运行看，以下是TinyXMLDemo源码。
首先要通过TinyXML创建xml文件，代码如下：
bool CreateXmlFile(wstring&amp; szFileName) {//创建xml文件,szFilePath为文件保存的路径,若创建成功返回true,否则false try { //创建一个XML的文档对象。 TiXmlDocument *myDocument = new TiXmlDocument(); //创建一个根元素并连接。 TiXmlElement *RootElement = new TiXmlElement("Persons"); myDocument-&gt;LinkEndChild(RootElement); //创建一个Person元素并连接。 TiXmlElement *PersonElement = new TiXmlElement("Person"); RootElement-&gt;LinkEndChild(PersonElement); //设置Person元素的属性。 PersonElement-&gt;SetAttribute("ID", "1"); //创建name元素、age元素并连接。 TiXmlElement *NameElement = new TiXmlElement("name"); TiXmlElement *AgeElement = new TiXmlElement("age"); PersonElement-&gt;LinkEndChild(NameElement); PersonElement-&gt;LinkEndChild(AgeElement); //设置name元素和age元素的内容并连接。 TiXmlText *NameContent = new TiXmlText("周星星"); TiXmlText *AgeContent = new TiXmlText("22"); NameElement-&gt;LinkEndChild(NameContent); AgeElement-&gt;LinkEndChild(AgeContent); CString appPath = GetAppPath(); wstring seperator = L"\\"; wstring fullPath = appPath.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0dca5c96254b8218afd520a86761cc9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21fb15a149feb8e442c3effd3aa69884/" rel="bookmark">
			【转】解决 由于没有公钥，无法验证下列签名 :NO_PUBKEY
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：http://blog.sina.com.cn/s/blog_613126600100r4uv.html
linux终端报错：
正在读取软件包列表... 完成
W: GPG 错误：http://ppa.launchpad.net natty Release: 由于没有公钥，无法验证下列签名： NO_PUBKEY F1773AF13B1510FD
W: GPG 错误：http://ppa.launchpad.net natty Release: 由于没有公钥，无法验证下列签名： NO_PUBKEY 38B43CC308516FBE 缺少公钥了，看来需要下载公钥。从PGP的公钥服务器上下载公钥
服务器有很多个，我是在 subkeys.pgp.net 找到的。 经常用到的还有 wwwkeys.pgp.net，如果subkeys找不到，考虑换到wwwkeys看看。
gpg --keyserver subkeys.pgp.net --recv 3B1510FD 注意红色部分，是前文中 NO_PUBKEY F1773AF13B1510FD的后8位。
导入KEY
gpg --export --armor 3B1510FD | sudo apt-key add - 完成
转载于:https://www.cnblogs.com/tinanuaa/p/3292040.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/083d978d5e5b2bc83b626d399d39d384/" rel="bookmark">
			NSRange 用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘自：http://hi.baidu.com/ferrari_yang/blog/item/811e92c299396e0a0ef477a7.html NSRange的定义
typedef struct _NSRange
{
NSUInteger location;
NSUInteger length;
} NSRange;
NSRange是一个结构体，其中location是一个以0为开始的index，length是表示对象的长度。他们都是NSUInteger类型。 而NSUInteger类型的定义如下：
#if __LP64__ || TARGET_OS_EMBEDDED || TARGET_OS_IPHONE || TARGET_OS_WIN32 || NS_BUILD_32_LIKE_64
typedef unsigned long NSUInteger;
#else
typedef unsigned int NSUInteger;
#endif
例子：
下面这个例子，将输出IPA
NSString *homebrew = @"Imperial India Pale Ale (IPA)";
// Starting at position 25, get 3 characters
NSRange range = NSMakeRange (25, 3);
// This would also work:
// NSRange range = {25, 3};
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/083d978d5e5b2bc83b626d399d39d384/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ec16135dcf2dca8eba0da1715141c61/" rel="bookmark">
			URAL 1501
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目大意：有两堆数目均为N的仅含有红黑两种颜色的纸牌。现在需要将它们重新分成每堆中的纸牌颜色都相同的两个牌堆，要求分的过程中，新的两堆的纸牌数目相差不能超过1，且分牌时只能从原有牌堆顶部取牌，求一个满足条件的分牌方案。如果没有，输出：Impossible。（不包括句号）
例如：
input output 4 0011 0110 22121112 4 1100 1100 Impossible Time Limit:500MS Memory Limit:65536KB 64bit IO Format:%I64d &amp; %I64u
数据规模：4&lt;=N&lt;=1000。 理论基础：无。
题目分析：受neko13哥的启发，将自己原先的想法抛弃，择优录取，并成功将其想法消化，现来借花献福。
首先，我们思考如果我们将连续的两个操作看成一个集体操作，那么这个操作必然是1红1黑(从头到尾想一下就明白了)。这样的话，我们就只需要考虑三种情况了（dfs+记忆化）：
1.第一个牌堆的最顶上两张牌不相同，那么如果：去掉第一个牌堆顶上的两张牌后仍是有解的则输出“11”（按照递归的化不久解决所有了？太巧妙了）。
2.第一个牌堆的最顶上两张牌不相同，那么同1理即可。
3.如果第一个牌堆与第二个牌堆顶上的两张牌不一样，去掉那两张牌后如果仍有解，则输出“12”。
如此，上述三种情况都无解的话那就只能输出：Impossible了，问题得到解决。
代码如下：
#include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;string&gt; #include&lt;cstdlib&gt; #include&lt;cstdio&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #include&lt;ctime&gt; #include&lt;vector&gt; using namespace std; typedef double db; #define DBG 0 #define maa (1&lt;&lt;31) #define mii ((1&lt;&lt;31)-1) #define ast(b) if(DBG &amp;&amp; !(b)) { printf("%d!!|\n", __LINE__); while(1) getchar(); } //调试 #define dout DBG &amp;&amp; cout &lt;&lt; __LINE__ &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ec16135dcf2dca8eba0da1715141c61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7596af15064db0cca89377195727190/" rel="bookmark">
			URAL 1244
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目大意：给出一个正整数M，给出N个正整数ai，让你在这些数中挑出一些数组成M的一个划分，如果符合条件的划分数超过两个，输出：-1，如果没有输出：0，如果有且仅有一个：则按顺序输出剩下的数的序号。
例如：
input output 270 4 100 110 170 200 2 4 270 4 100 110 160 170 -1 270 4 100 120 160 180 0 测例1中，有且仅有100+170=270，所以输出110与200的序号2 4。测例2中，100+170=160+110=270，所以输出-1。测例3中，没有任何两个数的和为270，所以输出0。
Time Limit:500MS Memory Limit:65536KB 64bit IO Format:%I64d &amp; %I64u
数据规模：0&lt;ai&lt;=1000,2&lt;=N&lt;=100。
理论基础：无。
题目分析：我们用dp[i][j]表示仅用前i个数可以挑出的j的划分的个数。pre[i][j]表示第i个数被选择或者未被选择，用于最后输出结果。
我们可以得出如果需要输出时，那么方案数就是唯一的，所以途径的所有的状态的数都只能是被选或者未被选择，所以我们不用担心，a[i]被选与未被选都有解的情况。因为这时我们不需要输出。
下来是状态转移方程：dp[i][j]=dp[i-1][j]+(j&gt;=a[i])*(dp[i-1][j-a[i]]);在每一层dp时，只要发现dp[i][M]大于等于2即可输出-1退出程序。
如果dp[N][M]为0，则输出0。否则，回溯找回答案并输出。
代码如下：
#include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;string&gt; #include&lt;cstdlib&gt; #include&lt;cstdio&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #include&lt;ctime&gt; #include&lt;vector&gt; using namespace std; typedef double db; #define DBG 0 #define maa (1&lt;&lt;31) #define mii ((1&lt;&lt;31)-1) #define ast(b) if(DBG &amp;&amp; !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7596af15064db0cca89377195727190/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/788874d5ad96a4328197031e6319a377/" rel="bookmark">
			oracle err 959,oracle 错误 959 处理办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		假如有table1和table2在表空间tbs1上，其中table1有blob字段，现在在另外的一台机子上建了oracle实例，表空间名为tbs2，使用imp倒入的时候，table2正常倒入，table1不能倒入，出现错误
"IMP-00017: 由于 ORACLE 错误 959, 以下语句失败: "CREATE TABLE "table1"............... IMP-00003: 遇到 ORACLE 错误 959 ORA-00959: tablespace 'tbs1' does not exist" 可以使用如下方法解决：
例如到处的文件名为：table1.dmp
在Linux系统中使用vim编辑用emp导出的文件：table1.dmp
找到create table1的语句，把其中指定表空间的内容为tbs1的两处内容替换为tbs2。保存退出。
重新在执行导入即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fea97902d39a4da0dfd30251d7ad3e2/" rel="bookmark">
			C&#43;&#43;异常处理之terminate函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++中处理异常的过程是这样的：在执行程序发生异常，可以不在本函数中处理，而是抛出一个错误信息，把它传递给上一级的函数来解决，上一级解决不了，再传给其上一级，由其上一级处理。如此逐级上传，直到最高一级还无法处理的话，运行系统会自动调用系统函数terminate，
学会使用terminate函数有助于异常处理 一 当一个异常产生的时候调用terminate函数，代码：
#include &lt;iostream&gt; #include &lt;exception&gt; using namespace std; void on_terminate(){ cout&lt;&lt;"terninate function called!"&lt;&lt;endl; cin.get(); } int main(void){ set_terminate(on_terminate); throw exception(); cout&lt;&lt;"terminate function not called!"&lt;&lt;endl; cin.get(); return 0; } terminate 被调用的情况：
1 当发送一个异常，并且构造函数产生异常
2 当发送一个异常，或者析构函数产生异常
3 一个静态对象的构造或者析构发送一个异常
4 以atexit注册的函数发生异常的时候
5 自定义一个异常，但是实际上没有异常产生的时候
6 调用缺省的unexcepted()函数时候
例子说话：
#include &lt;iostream&gt; #include &lt;exception&gt; using namespace std; void on_terminate(){ cout&lt;&lt;"terminate function called!"&lt;&lt;endl; cin.get(); } class custom_exception{ custom_exception(){ } custom_exception(const custom_exception&amp; excep){ throw exception(); } }; void case_1(){ try{ throw custom_exception(); } catch(.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fea97902d39a4da0dfd30251d7ad3e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e87ad4e3aeee3175ce505d35fcc39f0/" rel="bookmark">
			Spring英文参考文档翻译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring框架参考文档（3.2.4）
第一部分Spring框架概述 Spring框架是一个轻量级的解决方案以及潜在的一站式企业级应用。但是Spring又是模块化的，各个模块又是相互解耦的。可以在Struts的基础上使用IOC容器，也可以同时使用集成的Hibernate和jdbc。Spring框架支持声明式事务，还可以通过RMI或者Web服务远程访问逻辑层，以及各种类型的持久化数据的方式。它提供了功能强大的MVC框架，将AOP非侵入的植入到应用程序中。Spring被设计成非侵入式的，逻辑代码与Spring框架本身没有关系。在集成层（比如数据访问层）会依赖于第三方数据访问技术或者Spring架包。然而Spring比较容易将依赖包和代码库解耦。
这份文档是描述Spring功能的一个参考文档。关于本文档，如果你有任何意见请及时的通过邮件或者论坛的方式联系我们。
1. Spring框架的介绍 Spring框架是一个全面支持java应用开发的平台，开发者只需关注自己的应用，从而减轻开发者的负担。
Spring可以通过普通的POJO对象来构建应用程序，从而实现非侵入式的企业级应用服务。非侵入式可以应用于J2SE以及J2EE。
下面列举几个作为应用程序员怎样才能充分利用Spring平台的优点：
. java方法在数据库事务中执行时，最好不要涉及到事务API
. 本地java方法进行远程调用，最好不要调用远程API
.本地java方法进行管理操作，最好不要调用JMXAPI
. 本地java方法进行消息处理，最好不要调用JMSAPI
1.1依赖注入和控制反转 背景
“什么才是控制反转？”，2004年，马丁.福勒在他的个人网站上关于IOC提出了这个问题。福勒建议将控制反转改为依赖注入，这样更加简洁明了。关于IOC和DI可以参考他的博文 http://martinfowler.com/articles/injection.html。
Java应用程序，无论是小的applets还是多层的企业级程序，都是松散耦合的代名词，通常由相互关联的对象形成符合要求的应用程序。所以在应用程序中对象是彼此依赖的。
虽然JAVA平台为应用程序的开发提供了丰富的功能，但是任然缺乏一键构造整体模块的方式，往往将需要开发者或者架构师自己来构建。诚然，开发者可以通过设计模式（例如工厂、抽象工厂、装饰器等）构造不同的类或者实例来实现应用程序。然而这些模式是比较简单的：最好的做法是定义模式的名称包括这个模式能做什么的描述，可以应用的范围以及可能存在的问题等等。设计模式是通用的，开发者必须要在应用程序中自己实现。
Spring的IOC为解决模块化问题，提供了一个比较规范的解决方案，可以使用不同的组件构建一个完整的应用程序。Spring定义的IOC可以在应用程序中得到综合的应用。许多项目团队使用Spring框架来构建健壮的可维护的应用程序。
1.2模块 Spring框架总共包括20个模块，模块主要包括：核心容器、数据访问和集成、AOP（面向切面编程）、测试等。
Spring框架的模块示意图
.核心容器
核心容器包括javabeans、核心、上下文，表达式语言模块。
Bean和核心模块是Spring框架的基础模块，包括IOC和DI功能。BeanFactory比较精致的实现了工厂设计模式，它可以根据实际的应用逻辑代码区去耦的配置。 上下文模块是建立在核心和bean模块的基础之上的：这就意味着，基于框架式的对象访问，就有点类似于JNDI注册表。上下文模块继承了bean模块所有的功能，并且还扩展支持国际化（例如资源包的使用）、事件传播、资源加载、以及可以通过Servlet容器透明的创建上下文。上下文模块还支持J2EE特性，比如EJB、JMX和远程登录。ApplicationContext接口是上下文模块中使用最多的。
EL模块提供了强大的表达式查询语言和运行中的操作对象图。它是在JSP2.1规范中统一定义的表达式语言。EL表达式支持设置和获取属性值、属性赋值、方法调用、通过数组访问上下文、集合和索引、逻辑和算术运算符、命名变量、以及通过IOC容器检索Bean的名称。它还支持链表投影和选择，以及常见的链表汇总。
.数据访问和集成
数据访问/集成层包括JDBC，ORM，OXM，JMS和事务模块。JDBC模块提供了JDBC的抽象层，用来消除繁琐的JDBC代码以及用于解析数据库厂商的特有的校验代码。
ORM模块对比较流行的ORM框架提供了集成，包括JPA、JDO、Hibernate、IBatis。结合所有Spring其他的功能特性，利用ORM封装包，你可以使用所有这些O/ R映射框架，如前面提到的简单声明式事务管理功能。
OXM模块提供抽象层支持对象到XML的映射以实现JAXB、Castor、XMLBeans、JiBX和XStream。
Java消息传递服务(JMS)模块能够生成生产和消费消息。
事务模块支持对所有的POJO以及实现接口的类的程序化和声明是事务管理。
.网络
网络层主要包含Web、Web-Servlet、Web-Struts、Web-Portlet(Web组件)。
Spring的Web模块具有Web方向的集成特性，比如文件上传、Servlet监听器初始化IOC容器以及Web方向的上下文环境。Spring同样也包含于Web相关的部分：远程处理。
Web-Servlet主要包含Spring针对于Web应用的SpringMVC。SpringMVC实现了模型与表单的完全解耦，并且集成了Spring所有其他的功能。
Web-Struts主要包含一些对比较经典Struts的web层支持的集成类，但是从Spring3.0开始已经被弃用。主要考虑可以迁移应用到Struts2.0以及Spring的集成或者SpringMVC。
Web-Portlet模块主要包含：组件环境对MVC的支持以及对Web-Servlet的支持。
.面向切面编程
Spring的AOP模块允许自定义面向切面编程，比如将方法拦截与切入点完全解耦的分离。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8f343c83899b3301b13ff34c767b6e4/" rel="bookmark">
			URAL 1352
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目大意：输出T个第ni（i=1,2,3,...,T）个梅森素数的指数。
Time Limit:1000MS Memory Limit:65536KB 64bit IO Format:%I64d &amp; %I64u
数据规模：T为整数，1&lt;=N&lt;=38。
理论基础：梅森素数：2^n-1的素数(n为正整数)。这里n即为所谓的梅森素数的指数。
前42个梅森素数的指数：
2,3,5,7,13,17,19,31,61,89,107,127,521,607,1279,2203,2281,3217,4253,4423,9689,
9941,11213,19937,21701,23209,44497,86243,110503,132049,216091,756839,859433,
1257787,1398269,2976221,3021377,6972593,13466917,20996011,24036583,25964951。
题目分析：表都给你了，还分析个毛线！！！
代码如下：
#include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int x[]={0,2,3,5,7,13,17,19,31,61,89, 107,127,521,607,1279,2203,2281,3217,4253,4423, 9689,9941,11213,19937,21701,23209,44497,86243,110503,132049, 216091,756839,859433,1257787,1398269,2976221,3021377,6972593}; int main() { int T; scanf("%d",&amp;T); while(T--) { int n; scanf("%d",&amp;n); printf("%d\n",x[n]); } return 0; } 唉。。。自己其实也可以先跑出来答案，然后打表。不过目测够呛，像这种找到一个数就可以出名的题，让我们找，那还不是让我们打表？只能呵呵了、、、 参考文献：
http://zh.wikipedia.org/wiki/%E6%A2%85%E6%A3%AE%E7%B4%A0%E6%95%B0
by:Jsun_moon http://blog.csdn.net/jsun_moon
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2015af6c53ec96ae03b645eb7e4ef02/" rel="bookmark">
			vim中文编码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		两篇讲的比较全面的文章：
第一篇：转自http://www.cnblogs.com/hopeworld/archive/2011/04/20/2022331.html
Vim有四个跟字符编码方式有关的选项，encoding、fileencoding、fileencodings、termencoding(这些选项设置请参考Vim文档中encoding-names章节)，它们的意义如下:
encoding
encoding是Vim内部使用的字符编码方式，包括Vim的buffer(缓冲区)、菜单文本、消息文本等。默认是根据你的locale选择。VIM用户手册上建议只在.vimrc中改变它的值，事实上似乎也只有在.vimrc中改变它的值才有意义。你可以用另外一种编码来编辑和保存文件，如你的vim的encoding为utf-8,所编辑的文件采用cp936编码,vim会自动将读入的文件转成utf-8(vim的能读懂的方式），而当你写入文件时,又会自动转回成cp936（文件的保存编码)。fileencoding
Vim中当前编辑的文件的字符编码方式，Vim保存文件时也会将文件保存为这种字符编码方式(不管是否新文件都如此)。fileencodings
Vim自动探测fileencoding的顺序列表，启动时会按照它所列出的字符编码方式逐一探测即将打开的文件的字符编码方式，并且将 fileencoding 设置为最终探测到的字符编码方式。因此最好将Unicode 编码方式放到这个列表的最前面，将拉丁语系编码方式 latin1放到最后面。termencoding
Vim所工作的终端(或者 Windows的Console窗口)的字符编码方式。如果vim所在的term与vim编码相同，则无需设置。如其不然，你可以用vim的termencoding选项将自动转换成term的编码.这个选项对GUI模式Vim(GVim)无效，而对Console模式的Vim而言就是Windows控制台的代码页，并且通常我们不需要改变它。 现在来看看Vim的多字符编码方式支持是如何工作的：
启动Vim，根据.vimrc文件中设置的encoding的值来设置buffer、菜单文本、消息文的字符编码方式。读取需要编辑的文件，根据fileencodings中列出的字符编码方式逐一探测该文件编码方式。并设置fileencoding为探测到的，看起来是正确的字符编码方式。对比fileencoding和encoding的值，若不同则调用iconv将文件内容转换为encoding所描述的字符编码方式，并且把转换后的内容放到为此文件开辟的 buffer 里，此时我们就可以开始编辑这个文件了。注意，完成这一步动作需要调用外部的 iconv.dll，你需要保证这个文件存在于$VIMRUNTIME或者其他列在PATH环境变量中的目录里。编辑完成后保存文件时，再次对比fileencoding和encoding的值。若不同，再次调用iconv将即将保存的buffer中的文本转换为fileencoding所描述的字符编码方式，并保存到指定的文件中。同样，这需要调用iconv.dll由于Unicode能够包含几乎所有的语言的字符，而且Unicode的UTF-8编码方式又是非常具有性价比的编码方式 (空间消耗比 UCS-2 小)，因此建议encoding的值设置为utf-8。这么做的另一个理由是encoding设置为 utf-8 时，Vim 自动探测文件的编码方式会更准确 (或许这个理由才是主要的 ;)。我们在中文Windows里编辑的文件，为了兼顾与其他软件的兼容性，文件编码还是设置为GB2312/GBK比较合适，因此fileencoding建议设置为chinese(chinese是个别名，在Unix里表示gb2312，在Windows里表示cp936，也就是GBK的代码页)。 当vim在utf-8的local下打开gbk文件时，显示的是乱码，可以在~/.vimrc文件中加入如下代码来解决：
set fencs=utf-8,gbk 这一行的作用是告诉vim，打开一个文件时，尝试utf8,gbk两种编码，vim只需要扫描文件的前一段，就可以根据文件里面的数据判断出文件是否用的是utf8或者gbk编码。如果不指定这一行，则vim只会用当前编码 (locale)来打开文件，因为locale是UTF-8，而文件是gbk，所以打开是乱码。
一般vim打开中文文件时出现乱码时可以用下面的方法来解决：
set fileencoding=gb18030 set fileencodings=utf-8,gb18030,utf-16,big5 这样设置的原因说明如下：vim里面的编码主要跟三个参数有关：enc(encoding), fenc(fileencoding)和fencs(fileencodings)。其中fenc是当前文件的编码，也就是说，一个在vim里面已经正确显示了的文件(前提是你的系统环境跟你的enc设置匹配)，你可以通过改变 fenc后再w来将此文件存成不同的编码。比如说，我:set fenc=utf-8然后:w就把文件存成utf-8的了，:set fenc=gb18030再:w就把文件存成gb18030的了。这个值对于打开文件的时候是否能够正确地解码没有任何关系。fencs就是用来在打开文件的时候进行解码的猜测列表。文件编码没有百分百正确的判断方法，所以vim只能猜测文件编码。比如我的vimrc里面这个的设置是：
set fileencodings=utf-8,gb18030,utf-16,big5 所以我的vim每打开一个文件，先尝试用utf-8进行解码，如果用utf-8解码到了一半出错(所谓出错的意思是某个地方无法用utf-8正确地 解码)，那么就从头来用gb18030重新尝试解码，如果gb18030又出错(注意gb18030并不是像utf-8似的规则编码，所以所谓的出错只是 说某个编码没有对应的有意义的字，比如0)，就尝试用utf-16，仍然出错就尝试用big5。这一趟下来，如果中间的某次解码从头到尾都没有出错，那么 vim就认为这个文件是这个编码的，不会再进行后面的尝试了。这个时候，fenc的值就会被设为vim最后采用的编码值，可以用:set fenc?来查看具体是什么。
当然这个也是有可能出错的，比如你的文件是gb18030编码的，但是实际上只有一两个字符是中文，那么有可能他们正好也能被utf-8解码，那么这个文件就会被误认为是utf-8的导致错误解码。
至于enc，其作用基本只是显示。不管最后的文件是什么编码的，vim都会将其转换为当前系统编码来进行处理，这样才能在当前系统里面正确地显示出 来，因此enc就是干这个的。在windows下面，enc默认是cp936，这也就是中文windows的默认编码，所以enc是不需要改的。在 linux下，随着你的系统locale可能设为zh_CN.gb18030或者zh_CN.utf-8，你的enc要对应的设为gb18030或者 utf-8(或者gbk之类的)。
最后再来说一下新建空文件的默认编码。看文档好像说会采用fencs里面的第一个编码作为新建文件的默认编码。但是这里有一个问题，就是fencs 的顺序跟解码成功率有很大关系，根据我的经验utf-8在前比gb18030在前成功率要高一些，那么如果我新建文件默认想让它是gb18030编码怎么 办？一个方法是每次新建文件后都:set fenc=gb18030一下，不过我发现在vimrc里面设置fenc=gb18030也能达到这个效果。
第二篇转自：http://edyfox.codecarver.org/html/vim_fileencodings_detection.html
在 Vim 中，有四个与编码有关的选项，它们是：fileencodings、fileencoding、encoding 和 termencoding。在实际使用中，任何一个选项出现错误，都会导致出现乱码。因此，每一个 Vim 用户都应该明确这四个选项的含义。下面，我们详细介绍一下这四个选项的含义和作用。
1 encoding encoding 是 Vim 内部使用的字符编码方式。当我们设置了 encoding 之后，Vim 内部所有的 buffer、寄存器、脚本中的字符串等，全都使用这个编码。Vim 在工作的时候，如果编码方式与它的内部编码不一致，它会先把编码转换成内部编码。如果工作用的编码中含有无法转换为内部编码的字符，在这些字符就会丢失。因此，在选择 Vim 的内部编码的时候，一定要使用一种表现能力足够强的编码，以免影响正常工作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2015af6c53ec96ae03b645eb7e4ef02/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/399696915f2fab06c4e0d8f75d8686f9/" rel="bookmark">
			Oracle 11gR2(11.2.0.3) Patchset （p10404530）中7个不同文件的作用说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		故事猪脚：Oracle 11.2.0.3 Patchset --- p10404530
在Oracle 10g 版本的Patchset里面，只有一个文件Disk1. Oracle 11.2.0.2和11.2.0.3 的Patchset 或者之后，安装包大小分成了7份。
11.2.0.2 和 11.2.0.3 版本的Patchset 是5G，它由7个文件组成：
p10098816_112020_Linux-x86-64_1of7.zip ---database第一部分 不解释
p10098816_112020_Linux-x86-64_2of7.zip ---database 第二部分 不解释
p10098816_112020_Linux-x86-64_3of7.zip ---grid infrastructure
p10098816_112020_Linux-x86-64_4of7.zip ---client
p10098816_112020_Linux-x86-64_5of7.zip ---Gateway software
p10098816_112020_Linux-x86-64_6of7.zip ---examples，事例库
p10098816_112020_Linux-x86-64_7of7.zip ---deinstall .也就是卸载工具
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f948f9b434f362e1946ac6d3bdadbdcd/" rel="bookmark">
			在域中设置权威时间服务器并发布时间同步策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这段时间发现，整个公司的计算机时间都快了2分钟，后来发现主域控制器上同Internet时间服务器总是无法联系上，我们都知道启用了Windows的Windows Time服务，计算机就会定期同Internet时间同步。同步的都是国外的时间服务器，通常很难连接成功。我们国家也有主时间服务器，国家授时中心服务器的IP地址：210.72.145.44，同这个服务器连接成功率很高。我们就修改域控制器和这个服务器进行时间同步。 一、设置主域控制器与国家授时中心服务器时间同步，同步周期为1天。
1、 添加时间服务器IP（下面这个键存放着时间服务器列表）
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\DateTime\Servers
在右边窗口点右键新建“字符串值”，将此“字符串值”命名为6。双击此新建的“字符串值”，输入IP：210.72.145.44，保存。将“默认”（即第一个“字符串值”）修改为6即可。前面的几个时间服务器分别为：
1 time.windows.com
2 time.nist.gov
3 time-nw.nist.gov
4 time-a.nist.gov
5 time-b.nist.gov
2、 指定时间源
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\W32Time\Parameters
修改键NtpServer的值为210.72.145.44,0x6
3、 设置校时周期
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\W32Time\TimeProviders\NtpClient\SpecialPollInterval
修改键SpecialPollInterval的值为十进制的604800（即为604800秒，1天）
二、设置权威服务器
1、 设置权威服务器
在域控服务器上打开注册表，找到键值
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\W32Time\Config
修改键AnnounceFlags的值为十进制的10。
2、 启用 NTPServer
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\W32Time\TimeProviders\NtpServer
修改键Enabled的值为十进制的1
三、配置组策略，设置时间同步
1、 打开“Active Directory 用户和计算机”，在域上点右键，属性。组策略，打开。
2、 在“Default Domain Policy”上右键，编辑。
3、 计算机配置—管理模板—系统—Windows时间服务，双击“全局时间配置”，选择“已启用”。
修改MaxNegPhaseCorrection的值为3600（即为3600秒，1小时）
修改MaxPosPhaseCorrection的值为3600（即为3600秒，1小时）
修改AnnounceFlags的值为5
点“应用”，“确定”。
4、 计算机配置—管理模板—系统—Windows时间服务—时间提供程序，“启用Windows NTP客户端”，选择“已启用”。
“配置Windows NTP客户端”，选择“已启用”。
修改NtpSever的值为ad-server.rybb.com,0x6
修改Type的值为NTP
修改SpecialPollInterval的值为1800（30分钟）
四、W32tm命令
这个命令很有用啊，举几个例子：
1、 列出本地计算机指定的远程计算机的时间差，我这里和国家授时中心服务器的IP地址：210.72.145.44作比较。
命令：w32tm /stripchart /computer: 210.72.145.44
Tracking 210.72.145.44 [210.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f948f9b434f362e1946ac6d3bdadbdcd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa12849fa32c2fb354fb4a1e6435b17c/" rel="bookmark">
			清理長時間未登陸的計算機
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 查询长时间未登录域的计算机：
1，　查詢4周未登陆的机器以及60天未能更改域计算机密码的机器(数值可自行指定)，然后把它们设成disabled。　dsquery computer -inactive 4 -stalepwd 60|dsmod computer -disabled yes
2， 指定OU操作，查詢4周未登陆的机器以及60天未能更改域计算机密码的机器(数值可自行指定)，然后把它们设成disabled。
dsquery computer "ou=OU Name,dc=xxx,dc=com" -inactive 4 -stalepwd 60|dsmod computer -disabled yes
删除：
dsquery computer -disabled | dsrm –noprompt
查出禁用机器然后删掉。
&lt;script type=text/javascript charset=utf-8 src="http://static.bshare.cn/b/buttonLite.js#style=-1&amp;uuid=&amp;pophcol=3&amp;lang=zh"&gt;&lt;/script&gt; &lt;script type=text/javascript charset=utf-8 src="http://static.bshare.cn/b/bshareC0.js"&gt;&lt;/script&gt; 阅读(389) | 评论(0) | 转发(0) | 0 上一篇：Windows教程目錄
下一篇：DHCP CLIENT不能启动,错误ID 1004,7023
相关热门文章 压力变送器典型测量回路的故障...情感世界的差异对人际关系的影...东莞双眼皮修复术怎么做...07月29日股票投资策略及技术点...中国品牌毛巾网——毛巾产业发... 10种启动故障解决方法（转）...关于自动弹出网页的解决方法...Auto CAD 2007中文版 迅雷免费...出现“high definition audio...全国计算机一级考试试题... 文件去重，如何解决Hash冲突的...配置CI框架的rewrite 老是出...CentOS下，PHP如何实现SSH2扩...做数据统计有没有比较好的PHP... C++ 拷贝一个对象是什么意思... 给主人留下些什么吧！~~ 评论热议 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c97d608d099eb4c5e5d0a83e6a6a020/" rel="bookmark">
			删除系統多余网卡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在电脑的“设备管理器”中..很多人网卡的名称后面有“#2”、“#3”这样的字样..如果你的电脑中只有一块网卡..那么这样的字样就说明该网卡的驱动程序在你的电脑中至少被安装过两次..为什么会出现这样的情况呢.. 这是由于你更改了网卡的扩展插槽造成的..出于有意或无意目的..你可能会在机箱中把网卡从一个插槽更换到另一个插槽..在更换时..即使你在更换插槽之前没有卸载该网卡的驱动程序..在更换后系统仍要求你重新安装该设备的驱动程序..对于即插即用的网卡..系统会自动安装该设备的驱动程序..这样..同一网卡的同一驱动程序就被重复安装了..在更换插槽前被安装的网卡..更换插槽后其驱动程序仍然存在于系统中..但由于失去了网卡的支持..所有只能像“影子”一样隐藏在系统中..我们把这种网卡叫做“影子”网..更换后被再次安装了驱动程序的网卡..由于在系统中已经存在它的“影子”..所以只能在“影子”网卡的名称后面再添加“#2”、“#3”这样的字样.. “影子”网卡有时会给你的系统带来麻烦..比如..如果你为“影子”网卡分配了IP地址..当你更换插槽后再次为该网卡分配同一IP地址时..系统就会提示..你当前分配的IP地址已被系统中的另外一块网卡使用..要求你为该网卡重新分配IP地址.. “影子”网卡在系统中实际上处于禁用状态..当你为网卡分配IP地址出现当前分配的IP地址和“影子”网卡的IP地址冲突的提示时..你可以不理睬该提示..强行将该IP地址分配给网卡..但是我还是建议你利用笔者在下面介绍的方法彻底删除“影子”网卡.. 那么怎么才能删除影子网卡呢？有人说..在“设备管理器”中选择“查看→显示隐藏的设备”就能显示这些“影子”网卡..然后双击该网卡打开该网卡的“属性”对话框..在该对话框的“驱动程序”选项卡上单击“卸载”就能删除该“影子”网卡..以上这种说法根本经不起实践检验..因为按照这种方法..我们根本就看不到“影子”网卡..那就更谈不上卸载“影子”网卡的驱动程序了..下面..还是来看笔者删除“影子”网卡的方法.. 在“开始”菜单单击“运行”..然后在“运行”对话框中输入“CMD”命令打开命令提示符窗口..先输入命令“set devmgr_show_nonpresent_devices=1”..回车后再输入命令“Start DEVMGMT.MSC”即可打开“设备管理器”..现在..在该“设备管理器”的菜单栏上选择“查看→显示隐藏的设备”才能看到隐藏的“影子”网卡..双击该“影子”网卡打开该网卡的“属性”对话框..切换到“驱动程序”选项卡..单击“卸载”..“影子”网卡就会从你的电脑中彻底删除.. &lt;script type=text/javascript charset=utf-8 src="http://static.bshare.cn/b/buttonLite.js#style=-1&amp;uuid=&amp;pophcol=3&amp;lang=zh"&gt;&lt;/script&gt; &lt;script type=text/javascript charset=utf-8 src="http://static.bshare.cn/b/bshareC0.js"&gt;&lt;/script&gt; 阅读(677) | 评论(0) | 转发(0) | 0 上一篇：Unix系统下磁带机配置使用攻略
下一篇：Windows教程目錄
相关热门文章 VMWare克隆或复制Linux虚拟机...什么是现代简约软装设计风格...自强创新之路 打造真正上网不...女生想丑很难 无线网卡8500WN...东莞腋毛怎样完全根除... 10种启动故障解决方法（转）...关于自动弹出网页的解决方法...Auto CAD 2007中文版 迅雷免费...出现“high definition audio...全国计算机一级考试试题... 文件去重，如何解决Hash冲突的...配置CI框架的rewrite 老是出...CentOS下，PHP如何实现SSH2扩...做数据统计有没有比较好的PHP... C++ 拷贝一个对象是什么意思... 给主人留下些什么吧！~~ 评论热议 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cbb31d46ac532e34fc6407a120e9c43/" rel="bookmark">
			Windows Media Player 无法播放
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在一个收费网站下载了视频后一播放就提示:Windows Media Player 无法播放、同步或刻录受保护的文件，因为验证相关许可证时发生了错误。
在网上查找了好多相关网页,甚至到了微软的网站查阅都没能找到解决问题的办法,差点想到用Freeme.exe 来破解.
还好在最后还是在太乐鱼网站找到了解决办法:
点击下面的链接
http://219.239.93.9/WMCheck/WMPCheck.htm
在这个页面按提示信息完成DRM检测。
注: 操作系统支持win98\me\2x\xp,播放器支持 windows media player 9 以上版本
浏览器请使用IE
如果出现问题，请按以下方案尝试解决，如出现其他错误，请先反复尝试以排除网络原因，如果错误问题仍然存在，请详细说明错误表现及详细提示，谢谢！
解决方案：
DRM检测分为两步：
第一步检测:检测您的Windows media player版本是否为9.0以上版本
正确提示：恭喜您，您的 Media Player 完全正常，请继续第二步检测。
错误提示：您的Media Player版本过低，请下载安装最新版的Media Player：
http://www.microsoft.com/windows/windowsmedia/cn/player/download/download.aspx
解决方法：升级您电脑的Media Player，然后再次测试。
第二步检测: 检测能否播放受保护的DRM文件。
正确提示：恭喜您，您可以和太乐鱼一起畅游。
检测成功，您的电脑可以正常播放受DRM保护的文件。请点击“关闭”按钮退出检测。
错误提示：您的Media Player无法播放DRM音乐，请下载安装DRM修复工具： http://rdlink.tailenet.com/AdRedirect.aspx?1006
DRM修复工具的文件大小为6M，下载时间需要2-5分钟
解决办法：下载DRM修复工具后，重新启动电脑，然后运行drm10fix.exe进行修复，然后再次进行检测。
在检测过程中，如果您遇到其他错误，请查看以下内容尝试解决:
一、错误表现：进入页面后，没有任何提示，只看到图片。
解决办法：请点IE栏上的“工具”→“Internet选项”→“安全”→“自定义级别”→“安全级—中” →“重置”→“是”→“确定”。然后再次进行检测。
二、错误表现：在“获取许可证过程中”弹出一个窗口都是乱码。
解决办法：点media player菜单栏上的“工具”→“选项”→“隐私”→“自动获取受保护内容的许可证（前面打勾）” →“应用”→“确定”。然后再次进行检测。
三、错误表现：Windows Media Player 无法播放、同步或刻录受保护的文件，因为验证相关许可证时发生了错误。drm组件包初始化失败。
解决办法：重新启动电脑，使用DRM修复工具，然后再次进行检测。
四、如果有以下错误表现，请先反复尝试，排除网络问题，如仍有问题，请尝试点击http://drmlicense.one.microsoft.com/Indivsite/zh-cn/indivit.asp
进入后点击”upgrade”,升级安全组件，如无法连接到上述网页，表明您所应用的网络代理服务器有限制，请尝试更换代理服务器连接上述网页。
错误表现： 检测时遇到错误，请检查网络连接是否正常。详细信息： Windows Media Player 无法播放该文件。如果该文件在 Internet 中，请连接到 Internet。如果该文件在可移动存储卡中，请插入存储卡。
解决办法：网络问题，请反复尝试。
错误表现：开始安全组件升级...检测时遇到错误，请检查网络连接是否正常。详细信息：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cbb31d46ac532e34fc6407a120e9c43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8da7a4c897e05a9914544f885af399a/" rel="bookmark">
			如何搭建本地的PIP源提高Devstack和venv环境的安装速度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景
使用Devstack进行研发环境搭建的时候，或者在进行单元测试创建venv环境时，总是需要从pip源进行大量安装，而因为网络问题导致无法正常安装的情况屡有发生，那么这里就介绍一下如何搭建本地的OpenStack的PIP源，并且如何在客户端正确设置来使用他们。
PIP源的搭建
首先，无疑先要有个Apache环境，建立一个叫pip的目录，存放所有的pip安装包。
搭建源的方法有两种，一种是直接将公网的pip源下载到本地，之后用crontab定期同步就可以了，这样的好处是大而全，不好的是对于网络带宽较小的，简直就是拉锯战。
这里介绍的第二种方法可能更经济实惠，我是从之前一篇源代码安装OpenStack获得的启发。基本的思路就是把所有的pip-requires和test-requires文件汇聚到一个文件，之后利用pip进行download，做到为OpenStack量身定制。
find . -name pip-requires -exec cat {} \; &gt; pip-requires.all find . -name test-requires -exec cat {} \; &gt; test-requires.all 当然我们也可以把他们合并在一起，方便下载。这里建议把pip升级到最新版本之后再去下载，这里用一小段脚本去实现下载，而并没有用到pip -r的指令，因为通过实践发现，在遇到重复的pip包时候，pip会自动的停止下载。 #!/bin/bash PIP_REQUIRE="pip-requires" CACHE_PATH="pip" while read LINE do if [[ $LINE =~ ^[a-zA-Z] ]] then echo $LINE yes w | pip install $LINE --no-install -d pip -I fi done &lt; $PIP_REQUIRE 这样就完成了定制版pip源的下载。 客户端的设置
经过试验发现，如果通过本地的pip源进行安装，需要让pip和easyinstall同时指向本地pip源，否则仍然会有包从远程进行下载。具体方式如下：
vi $HOME/.pip/pip.conf [global] find-links = http://192.168.0.30/pip no-index = true vi $HOME/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8da7a4c897e05a9914544f885af399a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30bcfa523241f42d294804fd22d03aaf/" rel="bookmark">
			生产者/消费者模式(阻塞队列)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		生产者/消费者模式(阻塞队列) 博客分类： j2EE 制造 thread 多线程 软件测试 JDK 生产消费者模式 貌似也是阻塞的问题 花了一些时间终于弄明白这个鸟东东，以前还以为是不复杂的一个东西的，以前一直以为和观察者模式差不多(其实也是差不多的，呵呵)，生产消费者模式应该是可以通过观察者模式来实现的，对于在什么环境下使用现在想的还不是特别清楚，主要是在实际中还没使用过这个。 需要使用到同步，以及线程，属于多并发行列，和观察者模式的差异也就在于此吧，所以实现起来也主要在这里的差异。 参考地址：http://blog.csdn.net/program_think/ 在实际的软件开发过程中，经常会碰到如下场景：某个模块负责产生数据，这些数据由另一个模块来负责处理（此处的模块是广义的，可以是类、函数、线程、进程等）。产生数据的模块，就形象地称为生产者；而处理数据的模块，就称为消费者。 单单抽象出生产者和消费者，还够不上是生产者／消费者模式。该模式还需要有一个缓冲区处于生产者和消费者之间，作为一个中介。生产者把数据放入缓冲区，而消费者从缓冲区取出数据 ◇解耦 假设生产者和消费者分别是两个类。如果让生产者直接调用消费者的某个方法，那么生产者对于消费者就会产生依赖（也就是耦合）。将来如果消费者的代码发生变化，可能会影响到生产者。而如果两者都依赖于某个缓冲区，两者之间不直接依赖，耦合也就相应降低了。 ◇支持并发（concurrency） 生产者直接调用消费者的某个方法，还有另一个弊端。由于函数调用是同步的（或者叫阻塞的），在消费者的方法没有返回之前，生产者只好一直等在那边。万一消费者处理数据很慢，生产者就会白白糟蹋大好时光。 使用了生产者／消费者模式之后，生产者和消费者可以是两个独立的并发主体（常见并发类型有进程和线程两种，后面的帖子会讲两种并发类型下的应用）。生产者把制造出来的数据往缓冲区一丢，就可以再去生产下一个数据。基本上不用依赖消费者的处理速度。其实当初这个模式，主要就是用来处理并发问题的。 ◇支持忙闲不均 缓冲区还有另一个好处。如果制造数据的速度时快时慢，缓冲区的好处就体现出来了。当数据制造快的时候，消费者来不及处理，未处理的数据可以暂时存在缓冲区中。等生产者的制造速度慢下来，消费者再慢慢处理掉。 用了两种方式实现了一下这个模式，主要参考了网上的一些例子才弄明白，这里对队列的实现有很多种方法，需要和具体的应用相结合吧，队列缓冲区很简单，现在已有大量的实现，缺点是在性能上面(内存分配的开销和同步/互斥的开销)，下面的实现都是这种方式；环形缓冲区(减少了内存分配的开销)，双缓冲区(减少了同步/互斥的开销)。 第一个例子是使用的信号量的东东，没有执行具体的东西，只是实现了这个例子，要做复杂的业务逻辑的话需要自己在某些方法内去具体实现 代码如下： 消费者： Java代码 public class TestConsumer implements Runnable { TestQueue obj; public TestConsumer(TestQueue tq){ this.obj=tq; } public void run() { try { for(int i=0;i&lt;10;i++){ obj.consumer(); } } catch (Exception e) { e.printStackTrace(); } } } 生产者： Java代码 public class TestProduct implements Runnable { TestQueue obj; public TestProduct(TestQueue tq){ this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30bcfa523241f42d294804fd22d03aaf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b56299187aa5146bf1216b29e3e98ec3/" rel="bookmark">
			CentOS中修改系统默认语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CentOS中修改系统默认语言 把原来到中文环境改为英文环境
修改i18n文件
#vi /etc/sysconfig/i18n
--------------内容---------------------
LANG="en_US.UTF-8"
-----------------------------------------
还有一种方法就是改变环境变量LANG
#export LANG="en_US.UTF-8"
不过这样一重新启动就没有，所以要加到/etc/profile里面，这样一开机就会运行这个变量了。
-----------------------------内容-------------------------------
LANG="en_US.UTF-8"
export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE INPUTRC LANG
-------------------------------------------------------------------
改变 redhat 的系统语言/字符集 修改 /etc/sysconfig/i18n 文件，如 LANG="en_US"，xwindow会显示英文界面， LANG="zh_CN.GB18030"，xwindow会显示中文界面。 还有一种方法 cp /etc/sysconfig/i18n $HOME/.i18n vi $HOME/.i18n 文件，如 LANG="en_US"，xwindow会显示英文界面， LANG="zh_CN.GB18030"，xwindow会显示中文界面。 这样就可以改变个人的界面语言，而不影响别的用户
转载：http://blog.163.com/sam_pal/blog/static/53925973200839114644297
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2f11f2fd2432dd368a67c1b0d91dac5/" rel="bookmark">
			《游戏脚本的设计与开发》-(战棋部分)第九章 战场上的寻路和移动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上次已经让我军，友军和敌军都出现在了战场上，本章来说说如何让一个部队在战场上进行移动。在战棋游戏中，我军回合行动的时候，点击我军的某一个部队，会出现选择列表，选择【部队移动】一项后，会出现该部队可能移动的范围，然后点击范围内的某一位置，则部队就会向着这个位置移动。在这一过程中涉及到两个算法，一个是部队移动范围的搜索，另一个就是部队移动时的寻路算法。复杂指数来说，寻路算法相对复杂一些，之前研究AS3的时候，曾经写过一篇A*寻路的分析文章《A*寻路算法与它的速度》，有兴趣的朋友可以看一下。
javascript中的A*算法 其实A*寻路，主要应用在RPG或即时战略等游戏中，用于快速寻找最短路径，战棋游戏中在这方面要求并不高，所以广度优先搜索和深度优先搜索等算法都是无所谓的，不过由于我已经有了之前对AS3版本的A*算法的研究，就直接移植过来了。
原理，我就不多说了，想了解的可以直接看我的《A*寻路算法与它的速度》一文，下面我直接贴出完整代码，有需要的朋友可以直接拿去用。
function LStarQuery(){ var self = this; self._map = [];//地图 self._w = 0;//地图的宽 self._h = 0;//地图的高 self._open = [];//开放列表 self._starPoint = null;//起点 self._endPoint = null;//目标点 self._path = [];//计算出的路径 self.queryType = 0;//寻路方式[0：八方向，1：上下四方向，2：斜角四方向] } LStarQuery.prototype = { drawPath:function(node){ var self = this; var pathNode = node; //倒过来得到路径 while (pathNode != self._starPoint) { self._path.unshift(pathNode); pathNode = pathNode.nodeparent; } }, setStart:function(){ var self = this; for (var y=0; y&lt;self._h; y++) { for (var x=0; x&lt;self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2f11f2fd2432dd368a67c1b0d91dac5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5552e2a48391615ddbdc0dde0db2e441/" rel="bookmark">
			深入理解Spring MVC 3(三)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		十二、如何把全局异常记录到日志中？
在 前的配置中，其中有一个属性warnLogCategory，值是“SimpleMappingExceptionResolver类的全限定名”。我是 在SimpleMappingExceptionResolver类父类AbstractHandlerExceptionResolver类中找到这个 属性的。查看源码后得知：如果warnLogCategory不为空，spring就会使用apache的 org.apache.commons.logging.Log日志工具，记录这个异常，级别是warn。
值：“org.springframework.web.servlet.handler.SimpleMappingExceptionResolver”，是“SimpleMappingExceptionResolver类的全限定名”。这个值不是随便写的。 因 为我在log4j的配置文件中还要加入 log4j.logger.org.springframework.web.servlet.handler.SimpleMappingExceptionResolver=WARN， 保证这个级别是warn的日志一定会被记录，即使log4j的根日志级别是ERROR。
十三、如何给spring3 MVC中的Action做JUnit单元测试？
使用了spring3 MVC后，给action做单元测试也很方便，我以前从来不给action写单元测试的，再在不同了，方便了，所以一定要写。
JUnitActionBase类是所有JUnit的测试类的父类
Java代码 package test; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import org.junit.BeforeClass; import org.springframework.mock.web.MockServletContext; import org.springframework.web.context.WebApplicationContext; import org.springframework.web.context.support.XmlWebApplicationContext; import org.springframework.web.servlet.HandlerAdapter; import org.springframework.web.servlet.HandlerExecutionChain; import org.springframework.web.servlet.HandlerMapping; import org.springframework.web.servlet.ModelAndView; import org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter; import org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping; /** * 说明： JUnit测试action时使用的基类 * * @author 赵磊 * @version 创建时间：2011-2-2 下午10:27:03 */ public class JUnitActionBase { private static HandlerMapping handlerMapping; private static HandlerAdapter handlerAdapter; /** * 读取spring3 MVC配置文件 */ @BeforeClass public static void setUp() { if (handlerMapping == null) { String[] configs = { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5552e2a48391615ddbdc0dde0db2e441/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de01f21dc96ef08521f4fc336a9eee80/" rel="bookmark">
			深入理解Spring MVC 3(二)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要写在DispatcherServlet的前面， 让 defaultServlet先拦截，这个就不会进入Spring了，我想性能是最好的吧。
Tomcat, Jetty, JBoss, and GlassFish 默认 Servlet的名字 -- "default"
Google App Engine 默认 Servlet的名字 -- "_ah_default"
Resin 默认 Servlet的名字 -- "resin-file"
WebLogic 默认 Servlet的名字 -- "FileServlet"
WebSphere 默认 Servlet的名字 -- "SimpleFileServlet" 方案二： 在spring3.0.4以后版本提供了mvc:resources mvc:resources 的使用方法：
Java代码 &lt;!-- 对静态资源文件的访问 --&gt; &lt;mvc:resources mapping="/images/**" location="/images/" /&gt; /images/**映射到 ResourceHttpRequestHandler进行处理，location指定静态资源的位置.可以是web application根目录下、jar包里面，这样可以把静态资源压缩到jar包中。cache-period 可以使得静态资源进行web cache 如果出现下面的错误，可能是没有配置&lt;mvc:annotation-driven /&gt;的原因。 报错WARNING: No mapping found for HTTP request with URI [/mvc/user/findUser/lisi/770] in DispatcherServlet with name 'springMVC'
使用&lt;mvc:resources/&gt;元素,把mapping的URI注册到SimpleUrlHandlerMapping的urlMap中,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de01f21dc96ef08521f4fc336a9eee80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ef728d91602e006dc39e787e9b8fe6d/" rel="bookmark">
			深入理解Spring MVC 3(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言：
大家好，Spring3 MVC是非常优秀的MVC框架，由其是在3.0版本发布后，现在有越来越多的团队选择了Spring3 MVC了。Spring3 MVC结构简单，应了那句话简单就是美，而且他强大不失灵活，性能也很优秀。
官方的下载网址是：http://www.springsource.org/download （本文使用是的Spring 3.0.5版本）
Struts2 也是比较优秀的MVC构架，优点非常多比如良好的结构。但这里想说的是缺点，Struts2由于采用了值栈、OGNL表达式、struts2标签库等，会 导致应用的性能下降。Struts2的多层拦截器、多实例action性能都很好。可以参考我写的一篇关于Spring MVC与Struts2与Servlet比较的文章 http://elf8848.iteye.com/admin/blogs/698217
Spring3 MVC的优点：
1、Spring3 MVC的学习难度小于Struts2，Struts2用不上的多余功能太多。呵呵，当然这不是决定因素。
2、Spring3 MVC很容易就可以写出性能优秀的程序，Struts2要处处小心才可以写出性能优秀的程序（指MVC部分）
3、Spring3 MVC的灵活是你无法想像的，Spring的扩展性有口皆碑，Spring3 MVC当然也不会落后，不会因使用了MVC框架而感到有任何的限制。
Struts2的众多优点：略... (呵呵，是不是不公平？)
众多文章开篇时总要吹些牛，吸引一下读者的眼球，把读者的胃口调起来，这样大家才有兴趣接着往后看。本文也没能例外。不过保证你看了之后不会后悔定有收获。
二、核心类与接口：
先来了解一下，几个重要的接口与类。现在不知道他们是干什么的没关系，先混个脸熟，为以后认识他们打个基础。
DispatcherServlet -- 前置控制器
HandlerMapping接口 -- 处理请求的映射
HandlerMapping接口的实现类：
SimpleUrlHandlerMapping 通过配置文件，把一个URL映射到Controller
DefaultAnnotationHandlerMapping 通过注解，把一个URL映射到Controller类上
HandlerAdapter接口 -- 处理请求的映射
AnnotationMethodHandlerAdapter类，通过注解，把一个URL映射到Controller类的方法上
Controller接口 -- 控制器
由于我们使用了@Controller注解，添加了@Controller注解注解的类就可以担任控制器（Action）的职责,
所以我们并没有用到这个接口。
HandlerInterceptor 接口--拦截器
无图，我们自己实现这个接口，来完成拦截的器的工作。
ViewResolver接口的实现类
UrlBasedViewResolver类 通过配置文件，把一个视图名交给到一个View来处理
InternalResourceViewResolver类，比上面的类，加入了JSTL的支持
View接口
JstlView类
LocalResolver接口
HandlerExceptionResolver接口 --异常处理
SimpleMappingExceptionResolver实现类
ModelAndView类
无图。
三、核心流程图
本图是我个人画的，有不严谨的地方，大家对付看吧。总比没的看强。
四、DispatcherServlet说明
使用Spring MVC,配置DispatcherServlet是第一步。
DispatcherServlet是一个Servlet,所以可以配置多个DispatcherServlet。
DispatcherServlet是前置控制器，配置在web.xml文件中的。拦截匹配的请求，Servlet拦截匹配规则要自已定义，把拦截下来的请求，依据某某规则分发到目标Controller(我们写的Action)来处理。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ef728d91602e006dc39e787e9b8fe6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc35d57a1e510debc6e4b042769e69ec/" rel="bookmark">
			maven使用心得
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		各种版本错.
有myeclipse 8.5、8.6、10，有eclipse juno、kipuler各种版本配置报各种错，真是五花八门，琳琅满目。
大都插件有问题。配置有问题。下载时异常导致本地仓库jar包要么没下下来，要么下下来不可用。
最好的方法如下，先搭建apache maven，保证dos 命令正常。在使用myeclipse或eclipse。而且有时报错不怕。只要项目执行命令正常就无问题。
Maven环境搭建：
本地仓库+maven运行环境+构建项目
1、搭建nexus 本地仓库
1）拷贝jdk1.6和tomcat6
2）配置端口为8010 （端口自行定义，只要下面各处一致即可）
3）复制nexus-2.1.2.war到tomcat/webapps下，改名为nexus.war （这样访问无需加后面的版本号）
4）启动tomcat6 （最好以服务方式启动，否则电脑关机重启后还需手工启动）
访问： http://localhost:8010/nexus
能访问，搭建nexus成功！
初始用户名 admin 密码 admin123
注意：
如成功，nexus将在C盘创建C:\sonatype-work\nexus目录，存放文件
主要文件：C:\sonatype-work\nexus\storage\central
2、搭建maven环境，已执行mvn命令
1）解压apache-maven-3.0.5.zip到D:\javaenv\apache-maven-3.0.5
2）修改D:\javaenv\apache-maven-3.0.5\bin\mvn.bat
36行附近加 set MAVEN_OPTS = -Xms128m - Xmx512m （加大内存，构建大型项目会超出内存）
57行附近加 set JAVA_HOME=D:\\javaenv\\jdk1.6 （无需电脑属性配置JAVA_HOME）
3）配置MAVEN_HOME
电脑属性建立 MAVEN_HOME
D:\javaenv\apache-maven-3.0.5
加入PATH中
;%MAVEN_HOME%\bin
这样在cmd DOS窗口中就可以执行mvn命令
执行 mvn version 命令
提示正常，则搭建成功
4）执行各个mvn命令，下载各个命令插件 （必须执行，maven将自动下载相关的插件）
包括：compile,test,site,install,
install -X （X必须大写，控制信息详细很多，将显示jar依赖结构）
deploy （必须配置发布，才可执行正确，配置下面有）
3、测试mvn环境
1）连接外网
2）找个项目，在cmd的工程目录下执行 mvn test。项目下载jar正常。则maven环境正常。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc35d57a1e510debc6e4b042769e69ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a28d2bbc8d616f57afcc8fa2ffa79e6e/" rel="bookmark">
			iOS学习笔记（十六）——数据库操作(使用FMDB)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		iOS中原生的SQLite API在使用上相当不友好，在使用时，非常不便。于是，就出现了一系列将SQLite API进行封装的库，例如FMDB、PlausibleDatabase、sqlitepersistentobjects等，FMDB (https://github.com/ccgus/fmdb) 是一款简洁、易用的封装库，这一篇文章简单介绍下FMDB的使用。
在FMDB下载文件后，工程中必须导入如下文件，并使用 libsqlite3.dylib 依赖包。
FMDB同时兼容ARC和非ARC工程，会自动根据工程配置来调整相关的内存管理代码。
FMDB常用类： FMDatabase ： 一个单一的SQLite数据库，用于执行SQL语句。
FMResultSet ：执行查询一个FMDatabase结果集，这个和android的Cursor类似。
FMDatabaseQueue ：在多个线程来执行查询和更新时会使用这个类。
创建数据库： db = [FMDatabase databaseWithPath:database_path]; 1、当数据库文件不存在时，fmdb会自己创建一个。 2、 如果你传入的参数是空串：@"" ，则fmdb会在临时文件目录下创建这个数据库，数据库断开连接时，数据库文件被删除。
3、如果你传入的参数是 NULL，则它会建立一个在内存中的数据库，数据库断开连接时，数据库文件被删除。
打开数据库： [db open] 返回BOOL型。 关闭数据库： [db close] 数据库增删改等操作： 除了查询操作，FMDB数据库操作都执行executeUpdate方法，这个方法返回BOOL型。
看一下例子： 创建表： if ([db open]) { NSString *sqlCreateTable = [NSString stringWithFormat:@"CREATE TABLE IF NOT EXISTS '%@' ('%@' INTEGER PRIMARY KEY AUTOINCREMENT, '%@' TEXT, '%@' INTEGER, '%@' TEXT)",TABLENAME,ID,NAME,AGE,ADDRESS]; BOOL res = [db executeUpdate:sqlCreateTable]; if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a28d2bbc8d616f57afcc8fa2ffa79e6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36f925b37485ea1dd9a7f8ddceb04908/" rel="bookmark">
			New妙用和WinForm的Enabled=false时字体不可改变的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		this.btnOk.Enabled=false; this.btnOk.ForeColor = Color.Red; 当我们程序背景色为黑色或灰色时，禁用一个按钮后，此按钮的字体会变成灰色，背景也会变成灰色，就和背景混在一块看不清按钮上面的字是什么了，上面的代码想表达的意思是，在btnOk按钮禁用后，让其Enabled=false时显示的字体为红色，避免和背景混为一体，看不清按钮上的字体，解决方案大概是：button子类+new关键字+重写事件
代码如下：
/// &lt;summary&gt; /// 自定义按钮 /// &lt;/summary&gt; public class YButton : Button { /// &lt;summary&gt; /// 自定义按钮 /// &lt;/summary&gt; public YButton() { this.FlatStyle = System.Windows.Forms.FlatStyle.Flat; this.FlatAppearance.BorderColor = Color.White; this.FlatAppearance.BorderSize = 1; this.BackgroundImageLayout = ImageLayout.Stretch; this.TextAlign = ContentAlignment.MiddleCenter; this.Font = new Font("黑体",9f); this.ForeColor = Color.White; //this.BackgroundImage = WApp.util.Ui.assistant.UIResurece.Own.ImgButtonNormal; this.Size = new Size(102,32); } private Graphics g = null; /// &lt;summary&gt; /// 此组件的前景色，用于显示文本 /// &lt;/summary&gt; [Browsable(true), Category("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36f925b37485ea1dd9a7f8ddceb04908/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3685dfb2de0ccdb187affeecc2114b63/" rel="bookmark">
			程序员考试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 初级，中级，高级程序员考试 http://www.ceiaec.org/zgks.htm 已经更新为 http://www.bjpta.gov.cn/ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02eb2a85b8d65689cee12f49020953cf/" rel="bookmark">
			Java NIO系列教程（三） Buffer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; 原文链接 作者：Jakob Jenkov Java NIO中的Buffer用于和NIO通道进行交互。如你所知，数据是从通道读入缓冲区，从缓冲区写入到通道中的。
缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存。
下面是NIO Buffer相关的话题列表：
Buffer的基本用法 Buffer的capacity,position和limit Buffer的类型 Buffer的分配 向Buffer中写数据 flip()方法 从Buffer中读取数据 clear()与compact()方法 mark()与reset()方法 equals()与compareTo()方法 Buffer的基本用法 使用Buffer读写数据一般遵循以下四个步骤：
写入数据到Buffer 调用flip()方法 从Buffer中读取数据 调用clear()方法或者compact()方法 当向buffer写入数据时，buffer会记录下写了多少数据。一旦要读取数据，需要通过flip()方法将Buffer从写模式切换到读模式。在读模式下，可以读取之前写入到buffer的所有数据。
一旦读完了所有的数据，就需要清空缓冲区，让它可以再次被写入。有两种方式能清空缓冲区：调用clear()或compact()方法。clear()方法会清空整个缓冲区。compact()方法只会清除已经读过的数据。任何未读的数据都被移到缓冲区的起始处，新写入的数据将放到缓冲区未读数据的后面。
下面是一个使用Buffer的例子：
RandomAccessFile aFile = new RandomAccessFile("data/nio-data.txt", "rw"); FileChannel inChannel = aFile.getChannel(); //create buffer with capacity of 48 bytes ByteBuffer buf = ByteBuffer.allocate(48); int bytesRead = inChannel.read(buf); //read into buffer. while (bytesRead != -1) { buf.flip(); //make buffer ready for read while(buf.hasRemaining()){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02eb2a85b8d65689cee12f49020953cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fbd4bc467a89e337d737a3f8f9be3e2/" rel="bookmark">
			JMX 介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 什么是 JMX JMX （Java Management Extensions）是一个为应用程序，设备，系统等植入管理功能的框架。
JMX 规范可以分为三层： 设备层， 代理层， 分布式服务层。 设备层规范定义了编写可由 JMX 管理的资源的标准，即如何写 MBean； 代理曾规范定义了创建代理的规范，封装了 MBean Server；分布式服务层主要定义了对代理层进行操作的管理接口和构件。
如果一个 Java 对象可以由一个遵循 JMX 规范的管理器应用管理，那么这个Java 对象就可以称为一个可由 JMX 管理的资源。
要使一个 Java 对象可管理，则必须创建相应的 MBean 对象，并通过这些 MBean 对象管理相应的 Java 对象。当拥有 MBean 类后，需要将其实例化并注册到 MBeanServer 上。
一共有四种类型的 MBean ， 分别是标准类型 MBean， 动态类型 MBean， 开放类型 MBean 和模型类型 MBean。我们在下文将分别进行介绍。
2. JMX API 简单介绍 本部分对 JMX 中常用的一些类进行简单的介绍。
2.1 MBeanServer public ObjectInstance createMBean(String className, ObjectName name). 创建 MBean，并将其注册到 MBeanServer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fbd4bc467a89e337d737a3f8f9be3e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe727acd8944a5953f27c1746fc798ee/" rel="bookmark">
			[翻译完成] 用vcgencmd获取树莓派硬件状态数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么80%的码农都做不了架构师？&gt;&gt;&gt; 命令可用性 这些是从固件(版本362371)中获得的命令. vcgencmd命令 显示可用的命令列表. root@raspberrypi:~# vcgencmd commands commands="vcos, ap_output_control, ap_output_post_processing, vchi_test_init, vchi_test_exit, pm_set_policy, pm_get_status, pm_show_stats, pm_start_logging, pm_stop_logging, version, commands, set_vll_dir, led_control, set_backlight, set_logging, get_lcd_info, set_bus_arbiter_mode, cache_flush, otp_dump, codec_enabled, measure_clock, measure_volts, measure_temp, get_config, hdmi_ntsc_freqs, render_bar, disk_notify, inuse_notify, sus_suspend, sus_status, sus_is_enabled, sus_stop_test_thread, egl_platform_switch, mem_validate, mem_oom, mem_reloc_stats, file, vctest_memmap, vctest_start, vctest_stop, vctest_set, vctest_get" vcgencmd measure_clock &lt;clock&gt; 显示时序, 可指定arm, core, h264, isp, v3d, uart, pwm, emmc, pixel, vec, hdmi, dpi. root@raspberrypi:~# \ &gt; for src in arm core h264 isp v3d uart pwm emmc pixel vec hdmi dpi ; do \ &gt; echo -e "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe727acd8944a5953f27c1746fc798ee/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/312/">«</a>
	<span class="pagination__item pagination__item--current">313/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/314/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>