<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9659c77b8bb1f07f7670ca8f516a443/" rel="bookmark">
			Python发送邮件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python发送邮件 一、概念二、邮件服务器设置三、发送邮件流程3.1 登录邮箱3.2 准备数据3.3 发送邮件 四、实现4.1 发送文本4.2 发送html4.3 发送图片4.4 发送文件 一、概念 SMTP(Simple Mail Transfer Protocol)，即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。
python的smtplib提供了一种很方便的途径发送电子邮件。它对smtp协议进行了简单的封装。
Python内置对SMTP的支持，可以发送纯文本邮件、HTML邮件以及带附件的邮件。
Python对SMTP支持有smtplib和email两个模块，email负责构造邮件，smtplib负 责发送邮件。
二、邮件服务器设置 发送邮件之前，必需要对邮箱进行设置，邮箱需要开启SMTP服务
以163邮箱为例
选取邮箱设置 开启smtp协议 打开网易邮箱大师，扫码发送短信获取授权码 获取邮箱授权码 三、发送邮件流程 3.1 登录邮箱 导入模块 import smtplib 连接邮箱服务器 服务器地址:smtp.163.com(163邮箱)、smtp.qq.com(qq邮箱)邮箱服务端口:465或者25 连接对象 = smtplip.SMTP_SSL(服务器器地址, 邮箱服务端口) 登录邮箱 连接对象.login(邮箱账号, 授权码) 3.2 准备数据 ​ 数据指的需要发送的内容。邮件内容的构建需要涉及到另外一个库email，它可以用来构建邮件主题以及各种形式的邮件内容，包括文字内容、图片内容、html内容、附件等
导入模块 from email.mime.multipart import MIMEMultipart from email.mime.text import MIMEText from email.header import Header 创建邮件对象 邮件对象 = MIMEMultipart() 设置邮件主题 主题对象 = Header(邮件标题, 编码方式).encode() 设置邮件发送者 # 设置邮件发送者 邮件对象['From'] = '用户名' # 设置邮件接受者 邮件对象['To'] = '收件人1;收件人2;收件人3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9659c77b8bb1f07f7670ca8f516a443/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0f4da7a6845100d8411138dd1c746d2/" rel="bookmark">
			基于FFmpeg,ANativeWindow渲染实现播放器功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、客户端选择音视频文件 MainActivity
package com.anniljing.ffmpegnative; import android.Manifest; import android.content.ContentResolver; import android.content.Context; import android.content.Intent; import android.database.Cursor; import android.net.Uri; import android.os.Bundle; import android.provider.MediaStore; import android.provider.OpenableColumns; import android.text.TextUtils; import android.util.Log; import android.view.SurfaceHolder; import com.anniljing.ffmpegnative.databinding.ActivityMainBinding; import androidx.activity.result.ActivityResultLauncher; import androidx.activity.result.contract.ActivityResultContracts; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import pub.devrel.easypermissions.EasyPermissions; public class MainActivity extends AppCompatActivity implements SurfaceHolder.Callback { private static final String TAG = MainActivity.class.getSimpleName(); private ActivityMainBinding binding; private Context mContext; private FFmpegPlayer mFFmpegPlayer; private String[] PERMISSIONS_STORAGE = {Manifest.permission.READ_EXTERNAL_STORAGE, Manifest.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0f4da7a6845100d8411138dd1c746d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb079880887fc436963c2d06dab8a566/" rel="bookmark">
			idea 弹出Server‘s certificate is not trusted 如何关闭
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（先解决问题，再说一下原因，解决问题是第一步，知道问题原因避免后期出现是关键）
打开idea---&gt;file--&gt;Settings然后搜索Server Certificates把下图中的选项勾上就ok
这里引起这个的根本原因是因为目前使用的idea是所谓的破解版，在本地hosts配置了映射，然后idea检测出来弹出警告 服务器证书不可用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f26e59e4badf2865fcde95249a46c69/" rel="bookmark">
			规则引擎调研情况 URule Pro、VRS和ILOG ODM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近调研了三家公司的规则引擎产品，各有利弊，具体情况如下：
1. URule Pro 配置本地环境： Web端测试样例：
产品特点： 编程语言
Java语言
是否有Python接口
否
核心算法
3.0及之前的版本 Rete算法
4.0之后版本 模式匹配算法(rete升级版)
支持的数据库
包括但不限于Oracle
规则操作
普通决策表、交叉决策表、决策树、决策流
操作环境
只有浏览器版
运行效率
16核+32G内存(普通)-&gt; 2000tps 可参考
优点：
规则定义较灵活支持用Docker部署、私有云部署、热部署支持科学计算支持规则间的继承关系可设置规则执行的优先级支持高并发(多业务同时调用该规则引擎)，具体性能需要测试 缺点：
（1）操作繁琐，比如：库文件需要频繁导入，变量不能复制，上移属性时每次只能移一位。
（2）优先级只在一个规则文件中写多条规则时有用；如果要决定多个规则文件的执行顺序，需要用决策流，但是决策流很难用。
（3）不支持HTTP接口交互和代码生成，只能通过Web端操作
2. Visual Rules Solution(VRS) 试用产品： 产品特点：
编程语言
Java语言(支持Java 8.0及以上版本)
是否有Python接口
是
核心算法
不涉及算法，根据语言逻辑直接生成代码执行
支持的数据库
包含但不限于Oracle、MongoDB、Redis
规则操作
关联决策表、交叉决策表、多维决策表、决策树、决策池、流程图、评分卡、表达式规则、表达式表格
操作环境
有单机版和网页版，单机版开发效率更高
优点：
（1）计算表格对象(多个集合遍历匹配时效率高)
（2）可调用外界的函数
缺点：
（1）规则定义的方式不灵活
（2）此产品不能检测规则间是否存在矛盾
3. ILOG ODM 产品特点： 编程语言
Java语言
是否有Python接口
有
核心算法
Rete算法/顺序执行
支持的数据库
包括但不限于Oracle
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f26e59e4badf2865fcde95249a46c69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30150c9ec2f74082457fb98320c032cf/" rel="bookmark">
			微信小程序通过点击事件跨页面传参以及data-方法传参（data-）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 vue 中，我们可以直接在点击事件中放入传递的参数进行传参；然而微信小程序中并不适用这样的写法，但是微信小程序可以通过自定义属性从而绑定参数使用。
data- 的用法 微信小程序可以通过直接写 data-index="1" 进行数据的绑定 ，利用 bindtap 点击事件执行函数从而获取到参数信息。
&lt;view bindtap="triggers" data-idType="1"&gt;点击&lt;/view&gt; 注意
data- 是固定的写法，- 后面可以取任意的名字，但是需要强调的是在获取的时候要写相对应的名字，例如：data-index = "1" ，获取时就是 e.target.dataset.index 。
示例 &lt;view bindtap="handlePage" data-idType="name" &gt; 跳转页面 &lt;/view&gt; js文件 Page({ data: {}, //点击事件 handlePage(e) { console.log(e.currentTarget.dataset.idtype); // name wx.navigateTo({ url: '/pages/addCustomers/index',// 跳转页面地址 }) }, }) tips 为什么有些时候 target 中也可以取到值？
在事件处理中，e.target 和 e.currentTarget 分别表示事件的目标元素和当前元素。在某些情况下，特别是当你绑定事件处理函数的元素包含子元素时，你可能会在 e.target 中找到你想要的值。
但是，需要注意的是，e.target 和 e.currentTarget 之间的区别很重要：
e.target 表示触发事件的元素，即实际点击的元素。
e.currentTarget 表示绑定事件处理程序的元素，即当前元素。
在代码中，点击了或 元素，它们都是 e.currentTarget 的子元素，但事件实际上是在包含它们的元素上触发的。因此，使用 e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30150c9ec2f74082457fb98320c032cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8d63dbfb891bf9eea49cf72e29d0ae5/" rel="bookmark">
			vue开发结合element-ui之自定义年季度搜索组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.项目要求列表页面增加搜索框，条件为年季度一体的搜索条件，element-ui没有提供，自己发封装一个（支持默认值） 2.组件效果图 3.利用了element的el-cascader组件，代码如下 &lt;template&gt; &lt;div&gt; &lt;template&gt; &lt;el-cascader :options="options" :props="props" v-model="selectedOptions" @change="handleChange" :clearable="false" placeholder="请选择年份季度" &gt; &lt;/el-cascader&gt; &lt;/template&gt; &lt;/div&gt; &lt;/template&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { deepClone } from '../../utils'; export default { props: { readonly: { type: Boolean, default: false, } }, data() { const getYear = new Date().getFullYear() const getMonth = new Date().getMonth() + 1 return { options: [], 下拉数据 props: { value: "value", label: "label", children: "children", }, // 默认本年本季度 selectedOptions: this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8d63dbfb891bf9eea49cf72e29d0ae5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fead4f095ca08f40c568ba65db2cda34/" rel="bookmark">
			微信小程序中miniprogram_npm文件夹怎么生成的(详解)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		遇到问题 在小程序种引入vant组件，并没有找到目录中有miniprogram_npm文件夹，导致vant没有引入成功，
解决办法 vant引入一半， 尝试，
先构建npm，再继续引入vant
果然构建npm后，miniprogram_npm文件夹就生成了，vant也引入成功了
后边发现 在小程序项目中，miniprogram_npm目录是通过使用npm install命令来生成的。该目录存放了通过npm安装的第三方依赖库。
要升级小程序版本并自动生成miniprogram_npm目录，可以按照以下步骤进行操作：
确保你的小程序项目目录下有一个有效的package.json文件。如果没有，可以通过在项目根目录执行npm init来创建一个新的package.json文件。.在项目根目录下执行命令npm install，这会根据package.json文件中的依赖列表，将所需的第三方包安装到node_modules目录中。在小程序开发工具中，点击菜单栏中的“工具”-“构建 npm”，这会自动将node_modules中的依赖复制到小程序根目录下的miniprogram_npm目录中。确认miniprogram_npm目录已经生成后，你就可以在小程序代码中使用通过npm安装的第三方库了。 tips 请注意，在每次执行npm install后，都需要重新执行一次“构建 npm”的操作，以将最新的依赖复制到miniprogram_npm目录中。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ccd473b86bd8211bab33a27cfedb5b1/" rel="bookmark">
			关于打开idea显示“Your idea evaluation has expired. Your session will be limited to 30 minutes”问题的解决办法（两步）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（先解决问题，再说一下原因，解决问题是第一步，知道问题原因避免后期出现是关键）
第一步：打开idea中选择Help中的Eval Reset;
第二步：勾选"Auto reset before per restart"项，再选择Reset；即可解决问题
原理： 在 IntelliJ IDEA 中，选择 Help -&gt; Eval Reset -&gt; Auto reset before per restart，再选择 Reset 的操作会重置 IntelliJ IDEA 的评估（Evaluation）状态。这通常用于重新设置 IDEA 的试用许可证。
具体来说，Auto reset before per restart 意味着在每次重新启动 IntelliJ IDEA 时，都会自动执行重置操作。而选择 Reset 则是手动触发一次重置。
这个功能主要是用于 IntelliJ IDEA 的试用版本。当您试用期满或者需要重新开始试用期时，可以通过执行这个操作来清除之前的评估状态，从而获得一个新的试用期。请注意，这并不会改变您的项目设置或配置，只是与评估许可证相关的状态被重置。
请确保在使用此功能之前已经了解并遵循 IntelliJ IDEA 的使用条款和许可证协议。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdb806ad78c19a1045958f0e498bcd70/" rel="bookmark">
			自动驾驶3.0时代的BEV感知与4D标注技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着BEV+transformer感知技术的量产落地，自动驾驶正式进入3.0时代。从2010年左右以规则为核心的自动驾驶1.0，到2015年左右以卷积神经网络CNN为代表的自动驾驶2.0，再到2022年3.0时代的到来，这一时代的技术让整个自动驾驶感知模块趋向形成高效、统一、简洁的端到端结构。
同时，BEV感知算法的训练数据不仅仅依赖3D位姿标注数据，还需要时间维度，即4D数据。因此，4D标注应运而生，它是在3D的基础上加了时序，为BEV感知提供真值数据。4D Label 生成静态、动态、通用障碍物、以及预测规划等各个任务的真值，实现这些真值的标注过程，实际上就是搭建了一套云端的智驾系统。
（自动驾驶4d标注示意图）
对于自动驾驶算法模型来说，数据是无价之宝，因此 4D Label 的作用非常关键。它有助于迭代算法，算法质量是自动驾驶企业的核心竞争力，可见数据才是真的重要。4D Label提供的真值数据是感知的基础，只有充分了解数据的特性，才能够理解算法模型的底层原理。
目前市面上BEV感知和4D标注相关的资料比较少而且分散、初学者极容易踩坑，为了让同学们系统化地学习BEV感知技术和4D标注方案，深蓝学院联合隋伟博士等三名领域内的专家开设『BEV感知理论与实践』、『面向自动驾驶场景的4D标注』2门课程，希望帮助大家更好地学习相关技术的理论、实践及底层逻辑。
扫码添加，了解详情
Part 1
教研团队
隋伟
地平线机器人事业部算法总监，原4D标注技术负责人
傅东旭
自动驾驶高级算法专家，历任百度自动驾驶高级研发工程师
刘兰个川
Patrick Liu
安克创新AI研究院院长，前小鹏汽车自动驾驶AI团队负责人
Part 2
课程亮点
BEV感知课程 全面梳理BEV感知算法及其发展脉络
细致讲解各类代表性算法的代码实现
分享BEV落地的工程实践经验
4D标注课程 系统梳理4D标注任务及其技术栈
详细介绍BEV感知任务的真值生成原理和细节 分享量产自动驾驶中的数据痛点及潜在方案
Part 3
课程大纲
Part 4
适合人群
1.希望从事自动驾驶视觉感知研发的在校生
2.企业中人工智能算法设计与工程开发的工程师
3.自动驾驶企业中其他方向的研发工程师
Part 5
学习收获
BEV感知课程 1.掌握BEV感知的发展脉络：2D-to-3D方法以及3D-to-2D方法；
2.熟悉BEV感知极具代表性的算法原理：BEVDet/BEVPoolv2/ BEVFusion/ BEVFormer；
3.积累BEV实际落地过程中的经验：数据处理与推理加速。
4D标注课程 1.掌握BEV关键感知任务的真值生成技术
2.学会灵活使用传统SLAM以及感知等技术手段解决驾驶场景中的实际问题
3.通过数据标注更好的理解BEV感知任务以及相关自动驾驶功能模块的底层原理
Part 6
抢占名额
扫码添加，了解详情
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12ce96c1b5ed721b402914cbfb2d7956/" rel="bookmark">
			python中的打开文件的用法,python中打开文件的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，本文将围绕python中的打开文件的用法展开说明，python中打开文件的方法是一个很多人都想弄明白的事情，想搞清楚python文件的打开方法需要先了解以下几个事情。
Python的文件打开方式 一、文件打开语句 1. open语句2. with open as语句对比二、文件打开模式 一、文件打开语句 Python中打开操作文件，实质是建立文件到Python程序中的映射，然后在程序中对映射内容进行操作，最后将映射同步到文件中的过程。
1. open语句 file1 = open('要打开的文件.txt', 'w') 其中，open()的参数中，第一个是要打开的文件名称，第二个是以那种权限打开，例子中‘w’为只写模式打开用python实现流星雨效果的方法详解。
打开后可对file对象进行相应操作，如读取操作：
file1.write('这里是写入内容') 需要注意的是，使用open语句进行文件打开，操作过后，需要执行close语句关闭文件释放资源。
file1.close() 2. with open as语句 加入with语句，通过上下文管理器管理文件。
with open('要打开的文件.txt', 'w') as file1: file1.write('这里是写入内容') 同样完成，1中功能，使用with语句只需要两条语句，省去了手动关闭文件释放资源的过程。当程序跳出with语句时，会自动进行资源释放。
对比 下面以将一个文件内容写入另一文件为例，对比两种方法。
# open方法 file1 = open('要打开的文件.txt', 'w') file2 = open('另一个要打开的文件','r') file1.write(file1.read()) file1.close() file2.close() # with方法 with open('要打开的文件.txt', 'w') as file1: with open('另一个要打开的文件','r') as file2: file1.write(file2.read()) 二、文件打开模式 打开模式描述r以只读模式打开文件，文件的指针将会放在文件的开头w以只写模式打开文件，如果文件不存在则创建，如果文件存在，则覆盖原有内容，文件指针在文件的开头a以追加模式打开文件，如果文件不存在则创建，文件指针在文件开头，如果文件存在，则在文件末尾追加内容，文件指针在原文件末尾b以二进制方式打开文件，不能单独使用，需要与共它模式一起使用，如rb，或者wb+以读写方式打开文件，不能单独使用，需要与其它模式一起使用，如a+ 文本文件：存储的是普通"字符"文本，默认为unicode字符集，可以使用记本事程序打开
二进制文件：把数据内容用"字节"进行存储，无法用记事本打开，必须使用专用的软件打开，举例：mp3音频文件.jpg图片.doc文档等
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cdd3b869379da56f642027ff5700fb8/" rel="bookmark">
			Google Bard 、Bing Copilot 、Claude、文心一言的简介及与ChatGTP异同
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文详细比较了 ChatGTP、Google Bard、Bing Copilot 、 Claude 和文心一言五种文本生成式 AI 。本文共计约 3000字，预计阅读时间为 10-15分钟。
1、ChatGTP 1.1、官网：https://chat.openai.com/ 1.2、简介与主界面 ChatGTP是由OpenAI开发的强大语言模型。它能够理解和生成自然语言文本，广泛用于解答问题、创作内容和模拟对话。ChatGTP具有广泛的应用领域，为用户提供高效、智能的语言交互体验。
1.3、特点 搜索网络：GPT能够通过用户提供的查询，在网络上检索相关信息，包括网页、图片和新闻结果，为用户提供更多知识。
生成图像：借助DALL·E 3图像生成模型，GPT可以根据用户的请求创造多样化的图像，如绘画、漫画、照片和图表，令用户通过文字或图像输入获得惊人的图像结果。
分析数据：GPT可基于用户提供的数据进行分析，执行计算统计量、制图和生成报告等任务。利用Codex代码生成模型，GPT还能根据用户描述生成符合要求的代码片段。
创建GPTs：用户可以定制GPT以满足个人需求，结合指令、额外知识和各种技能。这种个性化的GPTs为用户提供了新途径，可用于学习、工作、娱乐等场景，并支持用户分享创建的个性化GPTs，促进信息和技能的交流。
1.4、回答与Google Bard 、 Bing Copilot(Bing Chat) 、Claude、文心一言的区别 你与Google Bard、Bing Copilot(Bing Chat)、Claude、文心一言的区别是什么 1.5、案例，问同一个问题 树上7只鸟，一枪崩下来一只，树上还剩几只鸟？ 2、Google Bard 2.1、官网：https://bard.google.com/ 2.2、简介与主页面 Google Bard 是基于 Google 的大型语言模型，如 LaMDA 和 PaLM 开发的 AI 聊天机器人。它最初基于 LaMDA，后来迁移到了更先进的 PaLM 模型。
2.3、特点 Bard 提供个性化的响应，并集成了 Google Lens，允许用户上传图像及提示，成为多模态的 AI 聊天工具。用户现在可以以不同方式（简单、长、短、专业或休闲语气）自定义 Bard 的回复。Bard 现在能理解用户发送的链接内容，并支持 40 多种语言的文本转语音。
2.4、回答与chatGTP的区别 你和ChatGTP的区别是什么？ ChatGTP和我都是大型语言模型，但我们之间有一些关键的区别。训练数据不同。ChatGTP在互联网文本上进行了训练，而我则在对话的特定数据集上进行了训练。这意味着ChatGTP更擅长生成段落和摘要以及其他基于文本的处理任务，而我则更擅长对话。模型架构不同。ChatGTP使用了GPT-3模型架构，而我使用了LaMDA模型架构。LaMDA模型架构在生成文本、翻译语言、编写不同类型的创意内容和以信息丰富的方式回答你的问题方面进行了优化开发人员不同。ChatGTP是由OpenAl开发的，而我是由Google A开发的。这意味着ChatGTP的开发目标是创造一个通用的语言模型，而我的开发目标是创造一个能够帮助人们完成任务的语言模型。总的来说，ChatGTP和我都是强大的语言模型，但我们各有优缺点。ChatGTP更擅长生成文本，而我更擅长对话ChatGTP的开发目标是创造一个通用的语言模型，而我的开发目标是创造一个能够帮助人们完成任务的语言模型。
2.5、案例，问同一个问题 树上7只鸟，一枪崩下来一只，树上还剩几只鸟？ 答案是6只。根据题目，树上最初有7只鸟，一枪打死1只，因此树上剩下7-1=6只鸟。这个问题的答案是比较简单的，但也有一些有趣的答案。例如，如果枪声太大，会吓跑其他鸟，那么树上就剩下0只鸟了。又例如，如果打死的鸟是替罪鸟，其他鸟都知道，那么树上也还是剩下6只鸟。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2cdd3b869379da56f642027ff5700fb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0be0207551038639e29660c179991472/" rel="bookmark">
			〖大前端 - 基础入门三大核心之JS篇(58)〗- 面向对象案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明：该文属于 大前端全栈架构白宝书专栏，目前阶段免费，如需要项目实战或者是体系化资源，文末名片加V！作者：哈哥撩编程，十余年工作经验, 从事过全栈研发、产品经理等工作，目前在公司担任研发部门CTO。荣誉：2022年度博客之星Top4、2023年度超级个体得主、谷歌与亚马逊开发者大会特约speaker、全栈领域优质创作者。 🏆 白宝书系列 🏅 启示录 - 攻城狮的自我修养🏅 Python全栈白宝书🏅 ChatGPT实践指南白宝书🏅 产品思维训练白宝书🏅 全域运营实战白宝书🏅 大前端全栈架构白宝书 文章目录 ⭐ 面向对象案例 - 红绿灯⭐ 面向对象案例 - 炫彩小球 ⭐ 面向对象案例 - 红绿灯 接下来我们来做一个面向对象的小案例。
案例： 用面向对象编程的方法制作100个红绿灯，要求：鼠标每点击一次红绿灯，红绿灯的颜色就发生变化，变化顺序如下：红-&gt;黄-&gt;绿-&gt;红…(点击红灯就变黄，点击黄灯就变绿，点击绿灯就变红)，效果图如下：
第一步：定义类（面向对象最重要的就是编写类），完成初始化方法
首先定义一个TrafficLight（红绿灯）类
这个类的属性包括：当前颜色color属性、自己的DOM元素dom（因为在js中定义一个对象，这个对象是一个很抽象的数据结构，这个对象必须要通过自己的DOM属性才能管理自己下辖的这一片DOM，它的图片就是它的DOM）
这个类的方法包括：初始化init()、绑定事件bindEvent()、切换颜色changeColor()
实例化的对象本身是个key-value对的组合，包含color和dom对象，所以初学者可以理解为实例化类出来的这个对象比dom对象要”大“
第一步的代码如下：
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="box"&gt;&lt;/div&gt; &lt;script&gt; // 定义红绿灯类 function TrafficLight() { // 颜色属性，一开始都是红色 // 红色1、黄色2、绿色3 this.color = 1; // 调用自己的初始化方法 this.init(); } TrafficLight.prototype.init = function () { // 创建自己的dom this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0be0207551038639e29660c179991472/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b138d5f4d68b53fff844fbe0a64eab6e/" rel="bookmark">
			pip的基本命令与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、pip简介 pip是Python的包管理器，类似于其他编程语言中的包管理器，如Ruby的gem或Node.js的npm。它可以帮助你轻松地安装、更新和卸载Python包（库或工具）。你可以把pip想象成一个应用商店，你可以从中获取你需要的Python包，然后安装到你的Python环境中。
二、pip基本命令 安装包：
pip install package_name 这个命令会从PyPI（Python Package Index）上下载并安装你指定的包。例如，如果你想安装一个名为requests的HTTP库，你可以运行pip install requests。
升级包：
pip install --upgrade package_name 这个命令会检查已安装的包是否有新版本，并将其升级到最新版本。这对于保持你的包与最新版本兼容性很有用。
卸载包：
pip uninstall package_name 这个命令会卸载你指定的包。它将从你的Python环境中删除该包及其相关的文件。
列出已安装的包：
pip list 这个命令会显示已安装在你的Python环境中的所有包的列表。你可以查看已安装的包的名称和版本号。
查看特定包的版本信息：
pip show package_name 这个命令会显示有关特定包的详细信息，包括其版本号、安装路径和依赖项等。
搜索包：
已经弃用的方式：
pip search package_name 这个命令会在PyPI上搜索你指定的包，并返回与之相关的结果。这可以帮助你找到你想要安装的包的正确名称或找到类似的包。但是因为pip search服务的请求量激增，而开发新的搜索方式需要投入大量的人力物力，所以官方永久禁用XMLRPC搜索功能，具体见上图报错
不过，我们呢可以下载pip-search来代替它!
具体下载命令为：pip install pip-search
然后可以使用 pip_search package_name来查询包。
安装虚拟环境：
虚拟环境允许你在不同的Python项目中创建隔离的环境，每个环境可以有自己的依赖项和包版本。这对于管理不同项目的依赖项非常有用。你可以使用以下命令安装和使用虚拟环境：
安装虚拟环境工具：
pip install virtualenv 创建虚拟环境：
virtualenv venv_name 从提供的信息来看，我们已经成功地使用 Python 创建了一个虚拟环境。这个虚拟环境基于 CPython 3.10.11，并且是64位的。虚拟环境被创建在 C:\Users\JiKangyi\test_venv 目录下。
虚拟环境中还安装了以下包和它们的版本：
pip23.3.1
setuptools69.0.2
wheel==0.42.0
此外，这个虚拟环境支持多种激活方式，包括 Bash、Batch、Fish、Nushell、PowerShell 和 Python。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b138d5f4d68b53fff844fbe0a64eab6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d378ef95e842bfda5cb40da2fa173fca/" rel="bookmark">
			图解TCP滑动窗口！一分钟搞清楚知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【产生背景】
TCP 以1个段为单位，每发一个就需要进行一个确认应答的处理，这样的传输方式有一个缺点：包的往返时间越长通信性能就越低。 ***打个比方好比两个人对话：张三说完一句话，得到李四的确认回答，张三才能说下一句。每一次都是你一句话我一句确认，沟通方式非常低下。
【机制介绍】
为解决这个问题，TCP 引人了“窗口“这个概念，它是操作系统开辟的一个缓存空间，即使RTT（往返时间）较长也能控制网络性能的下降。确认应答以更大的单位进行确认，也就是说，发送端主机在发送了1个TCP段以后不必要一直等待确认应答而是继续发送，转发时间将会被大幅度的缩短。
***也就是张三可以一次性连续说多句话，然后一次性等待李四回复OK就行，李四听不清楚的就重新说，完全听清楚了就继续往下说！
窗口大小就是指无需等待确认应答而可以继续发送数据的最大值，上图的窗口大小为4个段（每个段长度1000）。
【窗口类型】
TCP滑动窗口分为两种：发送窗口和接受窗口。
发送端的滑动窗口包含四个部分：
● 已发送且已收到ACK确认
● 已发送但未收到ACK确认
● 未发送但可以发送
● 未发送且不能发送
上图标注的虚线部分就是发送窗口，TCP发送缓存区，是发送端被允许发送的最大数据包大小
● SND.WND：表示发送窗口的大小，上图虚线框的格子大小就是4000个字节。
● SND.UNA：一个绝对指针，它指向的是已发送但未确认的第一个字节的序列号。
● SND.NXT：下一个发送的位置，它指向未发送但可以发送的第一个字节的序列号。
接收端的滑动窗口包含三个部分：
● 已成功接收并确认
● 未收到数据但可以接收
● 未收到数据并不可以接收的数据
上图虚线矩形框就是接收窗口，TCP接收缓存区，用于存储未被进程使用的传入数据。
● REV.WND：表示发送窗口的大小，上图虚线框的格子大小就是3000个字节。
● REV.NXT：下一个接收的位置，它指向未收到但可以接收的第一个字节的序列号。
【实现方式】
下面小云君用图解的方式说明TCP交互中滑动窗口的实现机制：
上述图解是接收端（服务器）进程能很好的处理掉接收的数据的情况，因此可以保证接收窗口大小不变，能持续很好的滑动窗口接收数据。但设想一下，如果来不及处理就会占满TCP接收缓存区，也就是接收端窗口为0，此时就会通知发送端停止发数据了，这也就是TCP流量控制机制。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e29af9b17efa6b8cfb0b632d9da7bd0/" rel="bookmark">
			人物行迹图/SVG的描点动画
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta name="viewport" content="width=, initial-scale=1.0" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box { width: 10px; height: 10px; background: red; border-radius: 50%; offset-path: path( "M 200 100 Q 300 50 400 100 Q 450 150 400 200 Q 200 200 200 200" ); animation: move 5s linear; animation-fill-mode: forwards; } @keyframes move { 100% { offset-distance: 100%; } } svg { width: 500px; height: 500px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e29af9b17efa6b8cfb0b632d9da7bd0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7822cafe7a94c62475e7256371f05c56/" rel="bookmark">
			月薪30k的软件测试工程师，是一个什么样的工作状态？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一位大佬的亲身经历
用了大概6年的时间，成为了年薪30w+的测试开发。
回顾我从功能测试到测试开发的成长路径，基本上是伴随着“3次能力飞跃”实现的。
年名企大厂测试岗位内推文末获取！2022年名企大厂测试岗位内推文末获取！
第一家入职的时候是一家小公司
刚开始入行的时候，什么也不懂，就是从最简单的手工测试做起。每天做的最多的就是：编写测试用例&gt;提交bug&gt;回归bug。
最开始的时候不懂这些，觉得有所收获，但是3个月后，这些事情搞熟悉了，会有一种浪费时间的感觉。
另外在每次提交bug的时候，都要确认环境，还有一些bug没法复现，一方面老是被开发怼，另一方面也不得不加班。
这个时候我就想，能不能不让开发怼，能不能不加班？
我开始修炼内功，这是第一次能力飞跃的开始：
首先是看需求文档，只有了解了需求，才能知道设计这个功能的目的是什么，进而才能判断这个问题是不是bug，这样做后，一定程度上减少了被开发怼的情况，即使是开撕，也有了一定的依据；
其次就是看开发的设计文档，当然开始不熟的时候可能不给您看。你去研究他的业务逻辑，才能大致判断这个bug是如何产生的，进而能够复现和定位bug。
当然，这个过程肯定不是那么顺利。第一是因为你要主动学习和研究超出能力的事情，必须沉下心来钻研；第二是刚开始接触这些新事物的时候，处理问题会不那么完美，要扛得住质疑的压力；第三是向开发请教或者讨论的时候，必然要面对开发的鄙视和冷漠；第四就是学习会占用你的大量时间，加班不可避免。
这个过程可能1-2年，之后你就能自己排查和定位问题，提交bug之后开发也不再找你了，产品和开发开始对你刮目相看。
在找到的做测试的认同感，坚定了朝着测试持续发展的时候，我又觉得每天的重复性工作太多，能不能提升一下效率，于是我开始研究自动化，这是第二次能力飞跃的开始：
先从学一门语言开始，Java或者Python都行，开始时为了入门更容易，建议先从Python入手。掌握了语言，就可以开始编写一些脚本或者测试工具来提升效率了；
然后去研究架构，从更高的层面去提升效率，可能这个阶段你还达不到设计架构的高度，但是你要往这个方向去思考，要有这个野心。
这个阶段，大概需要2年左右的时间，如果这个阶段你完成了，你才能称得上一名合格的测试工程师，月薪15-20k以上是稀松平常的事情。话说我过了这个阶段已经跳槽了，因为第一家公司团队和业务都太小，自己已经没有太多的成长了。而这个时候，我的薪资达到了25k。
再往后，我又不满足了，不是不满足薪资，而是不满足仅仅提升效率，而是想要更早的预测缺陷以及监控缺陷，这个时候就开始往测试开发的方向去进阶，这是能力的第三次飞跃：
通过“测试左移”，提前与开发人员一起制定测试计划，推动代码评审、代码审计、单元测试、自动化冒烟测试、测试精准化分析以及研发自测等来保证研发阶段的质量；
另外，参与配置部署，将自动化测试用例配置到持续交付链中，并通过“测试右移”，全流程监控发布后的应用质量。
这里我所说的“测试左移”，也就是指的研发阶段的质量保证，“测试右移”也就是发布后的质量监控。搞定了测试开发，以我的经验来看，要去大厂，小公司用不到这个，薪资也给不起。测开目前在北京来说，年薪30W+只能算个起步。
自动化测试相关教程推荐： 2023最新自动化测试自学教程新手小白26天入门最详细教程,目前已有300多人通过学习这套教程入职大厂！！_哔哩哔哩_bilibili 2023最新合集Python自动化测试开发框架【全栈/实战/教程】合集精华，学完年薪40W+_哔哩哔哩_bilibili 测试开发相关教程推荐 2023全网最牛，字节测试开发大佬现场教学，从零开始教你成为年薪百万的测试开发工程师_哔哩哔哩_bilibili postman/jmeter/fiddler测试工具类教程推荐 讲的最详细JMeter接口测试/接口自动化测试项目实战合集教程，学jmeter接口测试一套教程就够了！！_哔哩哔哩_bilibili 2023自学fiddler抓包，请一定要看完【如何1天学会fiddler抓包】的全网最详细视频教程！！_哔哩哔哩_bilibili 2023全网封神，B站讲的最详细的Postman接口测试实战教学，小白都能学会_哔哩哔哩_bilibili 总结： 光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。 如果对你有帮助的话，点个赞收个藏，给作者一个鼓励。也方便你下次能够快速查找。
如有不懂还要咨询下方小卡片，博主也希望和志同道合的测试人员一起学习进步
在适当的年龄，选择适当的岗位，尽量去发挥好自己的优势。
我的自动化测试开发之路，一路走来都离不每个阶段的计划，因为自己喜欢规划和总结，
测试开发视频教程、学习笔记领取传送门！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e6862ff6312a32dd242f44a5a3a7dcd/" rel="bookmark">
			cpp笔记2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 this 友元 友元的目的就是让一个函数或者类 访问另一个类中私有成员
全局函数做友元
friend void goodGay(Building * building); 类做友元
friend class goodGay; 成员函数做友元
//告诉编译器 goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容 friend void goodGay::visit(); 继承 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c9a310a3461c48b1d110e0256debb23/" rel="bookmark">
			【算法】递归、搜索与回溯专题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一. 名词解释1. 递归1.1 什么是递归？1.2 为什么会用到递归？1.3 如何理解递归？1.4 如何写好一个递归？ 2. 遍历和搜索3. 回溯和剪枝 二. 递归系列专题1. 汉诺塔问题2. 合并两个有序链表3. 反转链表4. 两两交换链表中的节点5. pow(x, n) - 快速幂6. 长度最小的子数组7. 最大连续 1 的个数III 一. 名词解释 1. 递归 1.1 什么是递归？ 递归就是函数自己调用自己
1.2 为什么会用到递归？ 本质：我们在解决主问题时，会遇到和主问题相同的子问题，而子问题和主问题的解决方式一样，所以必定会出现函数自己调用自己（即递归）的情况。
递归示例一：二叉树前序遍历
递归示例二：快速排序
递归示例三：归并排序
1.3 如何理解递归？ 实际处理递归问题时，如果能够宏观地看待递归，那么代码就会特别好写。其实做多了一些二叉树类的递归题目后，我们大抵就能够宏观地看待和理解递归了，可以总结出以下三个方面：
不要在意递归的细节展开图，这会让你做题目时非常痛苦把递归的函数当成一个黑盒，我们只用传入参数，然后等待它返回给我们结果相信这个黑盒一定能完成任务 举例：二叉树的后序遍历
1.4 如何写好一个递归？ 先找到相同的子问题（可以帮助我们完成函数头的设计）只关心某一个子问题是如何解决的（有助于我们完成函数体的书写）注意一下递归函数的出口（考虑哪些情况下，递归不能再进行下去） 2. 遍历和搜索 3. 回溯和剪枝 下面我们通过一个走迷宫的例子来解释回溯和剪枝：
我们在看题解的时候，经常看到有些人用深搜，有些人用广搜，还有些人用回溯；其实回溯就是深度优先搜索。
二. 递归系列专题 1. 汉诺塔问题 题目链接
算法原理
代码编写
class Solution { private: void dfs(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B, vector&lt;int&gt;&amp; C, int n) { // 0、递归出口：只剩一个盘子的话就直接移动 if(n == 1) { C.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c9a310a3461c48b1d110e0256debb23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff8f0e7f89d37f4bb2f8c536b06f7a06/" rel="bookmark">
			【算法】栈和队列专题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 专题一：栈系列1. 中缀表达式转后缀表达式（逆波兰式）2. 有效的括号3. 用栈实现队列4. 最小栈 专题一：栈系列 1. 中缀表达式转后缀表达式（逆波兰式） 算法原理
2. 有效的括号 题目链接
算法原理
代码编写
class Solution { public: bool isValid(string s) { stack&lt;char&gt; st; for(const auto ch : s) { if(ch == '(' || ch == '[' || ch == '{') st.push(ch); else { // 1、右括号多 if(st.empty()) return false; char top = st.top(); if(top == '(' &amp;&amp; ch == ')' || top == '[' &amp;&amp; ch == ']' || top == '{' &amp;&amp; ch == '}') st.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff8f0e7f89d37f4bb2f8c536b06f7a06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e21ebf29bc6d82801c5c8b84ad943f2e/" rel="bookmark">
			jasypt中反向推导出jasypt.encryptor.password
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jasypt.encryptor.password 是加密用的盐，有时不知道password是什么，这个时候可以在启动时打上断点，查看password的值。具体方法如下：
在EncryptablePropertyResolverConfiguration中
config方法，返回值里的config对象里有password
另一种方法就是在类中添加属性值
@Value("${jasypt.encryptor.password}") private String jasyptPassword; 具体原理可以参考以下文章
jasypt加密器的设置原理_jasypt加密原理-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7e975feb3e423a90dcd01cb3731b96e/" rel="bookmark">
			基于html&#43;css&#43;js的图书管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目 录
一．项目设计方案 4
二．实施过程分析 4
三．项目设计成果 4
四．项目创新性 4
五．改进及展望 4
六．项目成员 4
附录一 5
一．项目设计方案
本项目是用html，css，js语言编写的图书管理系统，用jquery进行页面的加工，ajax异步读取信息，json数据存储相关信息。
1.项目界面设计
（1）注册界面：主要包含3个输入框，分别是用户名，密码和邮箱。下方一个注册按钮和css制作的小球波浪动画。以贺卡的布局展现整个页面。
（2）登录界面：主要包含2个输入框，分别是用户名，密码。下方一个登录按钮。以贺卡的布局展现整个页面。
（3）主界面：主要包含一个图书信息的表格，添加图书的输入框，搜索框，管理系统的标题，页脚。背景图是一个图书馆的实景图。
2.项目交互设计
本应用涉及到的交互有：
（1）点击注册按钮，如果有输入框内容为空，弹出警告。点击确定重新注册，注册成功后，跳转出注册成功的提示，提示后自动跳转到登录页面。
（2）点击登录按钮，如果如果有输入框内容为空，弹出警告。如果登录的用户名或密码与json数据中存储的不一致，则弹出警告。点击确定重新登录。点击登录按钮，用户名和密码与存储的一致则跳转出现登录成功，本文转载自http://www.biyezuopin.vip/onews.asp?id=15031再自动跳转到主页面。
（3）输入需要增加的图书信息，如果有输入框中内容为空，则出现警告。如果书的数目为负，则出现警告。点击添加图书按钮，图书信息被增加到表格上。
（4）输入需要搜索的图书/作者/出版社信息，点击搜索按钮，弹出图书详细信息。
（5）点击图书列表中的删除按钮，删除单条信息。
3.项目功能设计
（1）注册
用户输入用户名，密码和邮箱进行注册，如果输入框内容为空则报出警告。
（2）登录
用户输入用户名，密码，与已存储的json数据进行验证，验证成功进入主界面，不成功弹出警告。
（3）浏览图书
进入主界面后，可以查看表格中的图书信息，鼠标移动到图书信息上会有一定的效果变化。
（4）增加图书
设置五个输入框，分别是：书名，作者名，数量，出版社，单价。
用户输入信息后点击添加按钮添加到表格上。
如果有输入框为空则弹出警告。
如果书籍数量为负也弹出警告。
（5）删除图书
点击图书表格上每条图书后的删除按钮，删除单条图书信息，新添加后的图书信息也可以删除。
（6）搜索图书
用户在搜索框输入书名/作者/出版社信息，点击搜索按钮，弹出该图书的详细信息，如果没有搜索到，就弹出提示。新增加的信息也可以被搜索到。
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;图书管理系统&lt;/title&gt; &lt;link href="https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.css" rel="stylesheet"&gt; &lt;script type="text/javascript" src="jquery.js"&gt;&lt;/script&gt; &lt;style&gt; table { width: 500px; height: 100px; background-color: white; opacity:0.9; text-align: center; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7e975feb3e423a90dcd01cb3731b96e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a0f5a9db4f29af3f608e7cb9f6059a1/" rel="bookmark">
			Python实现员工管理系统（Django页面版 ) 一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本系统需要实现的板块比较多，为了方便各位能够更加轻松的学习，因为我们分多篇博客来将系统完善，希望能对各位的学习有帮助。作者文化水平有限，如果出现绕口的话请原谅。
本篇博客需要实现的需求：
1. 确定项目整体逻辑结构 2. 创建Django项目
3. 对Djiango项目中的各组件进行配置
4. 对部门表进行创建以及构建部门信息的页面
需求实现： 1. 确定项目整体逻辑结构 在本次项目中，我们需要做一个网页帮助我们进行员工管理的实现，包括部门管理，员工信息管理，账号管理。在初步实现中我会依次实现这四个板块，后续对于整个系统的完善也会在后面的博文中给出。
2. 创建Django项目 1 确认项目启动路径
2 创建Django项目 输入命令django-admin startproject 项目名
3 cd 项目名
4 创建app 输入命令 python manage.py startapp APP名
5 输入命令 python manage.py runserver 即可启动Django项目
通过默认URL我们可以在浏览器打开我们创建的Django页面（不能将我们上面的启动界面关闭） 出现以上界面就代表你的Django项目成功创建
我们通过我们的Pycharm打开我们刚才创建的项目，请注意我下面的打开操作，不然后续对于代码的运行可能会存在问题。
我们需要从你创建的地址下面的项目名进行打开，这样的好处就是你在运行整个Django项目时并不需要每次都输入python manage.py runserver。
基本上是这个界面就代表你项目成功按照我的方式进行打开
点击右上角的运行后即可出现下面的运行效果
我们可以发现里面有一个URL就是我们刚刚在上面进入网页的地址，这样我们可以直接通过点击这个地址即可进入我们的Django网页界面。
3. 对Djiango项目中的各组件进行配置 接下来我们需要对我们的项目对各个组件进行一个基本的配置，后续我们根据需要会不断的进行配置。
APP的配置：打开setting.py进行app的配置
找到INSTALLED_APPS,在里面添加 'project_manage.apps.ProjectManageConfig'，这个其实就是我们的app类的路径
这样我们就可以将我们的app配置成功，app如果配置不成功对于后续的数据库的迁移等操作就会产生影响，因此我们在进行配置项目组件时一定要注意对app的配置。
下面我们需要在app项目名所在的文件下创建两个文件夹，用于我们后续存放我们的html代码以及js代码
static : 用于存放js，css，img的内容
templates：用于存放html代码
4 对部门表进行创建以及构建部门信息的页面 下面是我们对部门表作的一个基本的框架
1. 需要给一个URL地址用于展示部门信息 2. 需要有一个导航栏用于用户对各个内容进行操作
3. 需要有一个部门列表用于存放我们所有的部门信息并展示
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a0f5a9db4f29af3f608e7cb9f6059a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12371899159319639f06113c8e1964e2/" rel="bookmark">
			阿里云 E-MapReduce 全面开启 Serverless 时代
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文整理自阿里云智能 EMR 负责人李钰（花名：绝顶）在 2023 云栖大会开源大数据专场的分享，演讲主题为阿里云 E-MapReduce 全面开启 Serverless 时代。
EMR 2.0 平台
阿里云正式发布云原生开源大数据平台 EMR 2.0 已历经一年时间，如今 EMR 2.0 全新平台在生产上已经全面落地，资源占比超过 60%。EMR 2.0 平台之所以在生产上这么快落地，源于其体验全面提升，更重要的一点是为客户实现了全面降本增效。
EMR 2.0 平台实现降本增效主要源于四个核心能力。 极致弹性 EMR 2.0 平台提供极致弹性的能力，主要表现在两个方面。第一是支持抢占式实例，客户可以指定使用抢占式实例的优先级，单节点组最多选择 10 种不同规格，成本优化策略支持自动选取低价实例规格出价 ，当抢占式实例不足的时候，会给客户补充按量付费的实例，兼顾成本和业务效果。第二就是极速响应能力，单节点组内和多节点组间均支持并行扩容 ，支持缩容期间并行扩容，支持突发业务变化；并且在响应能力上也有大幅提升，扩容速度不随着节点的增加而增加，100 节点扩容时间小于 2 分钟 ，弹性指标检测周期低于 30 秒，能够更好地响应负载变化；而且单次扩容规模能够达到 1000 个节点。
智能诊断 EMR 2.0 平台具备智能诊断能力，通过 EMR Doctor 的集群日报和实时检测功能，可以实现避免资源浪费、风险提前预警和实时分析建议的核心效果：通过健康检查服务的集群日报功能查看集群是否存在资源浪费；通过任务评分倒排 Top N，找到资源浪费最多的作业进行优化；通过持续优化，最大化利用资源，避免浪费。
新硬件支持 EMR 2.0 平台全面支持倚天 ECS 实例，相较 X86 实例成本降低 20%以上。另外在软件层面、计算引擎层面，针对ARM的指令集也做了一系列优化，性能更高，CPU 占用率更低， 在典型 TPC-DS 大数据 Benchmark 下能够进一步将性能提升 1/4，意味着使用 EMR2.0 新平台加上倚天实例构建大数据集群，可以实现 40%成本下降。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12371899159319639f06113c8e1964e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0e17943a531905679a9c5ea92dc6ee8/" rel="bookmark">
			树莓派查看系统资源情况命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在树莓派上，您可以使用多种方式来查看系统资源情况，包括 CPU 使用率、内存占用、磁盘空间等。以下是一些常用的方法：
方法1：使用 top 命令 在终端中输入以下命令：
top top 命令会实时显示系统资源的使用情况，包括 CPU 使用率、内存占用、进程信息等。按下 q 键退出。
方法2：使用 htop 命令 如果没有安装 htop，可以使用以下命令进行安装：
sudo apt-get install htop 然后运行：
htop htop 提供了比 top 更直观和交互式的界面，可以通过箭头键和快捷键进行操作。
方法3：使用 free 命令 查看内存使用情况可以使用 free 命令：
free -h 该命令会显示系统内存的使用情况，包括总内存、已使用、空闲等信息。
方法4：使用 df 命令 查看磁盘空间占用情况可以使用 df 命令：
df -h 该命令会显示文件系统的磁盘空间使用情况，包括总容量、已用、可用等信息。
方法5：使用 vcgencmd 命令（仅适用于树莓派） 树莓派提供了 vcgencmd 命令，可以用于查看一些关于系统状态的信息：
vcgencmd measure_temp # 查看 CPU 温度 vcgencmd get_mem arm # 查看 ARM 内存使用情况 vcgencmd get_mem gpu # 查看 GPU 内存使用情况 方法6：使用 raspi-config 工具（仅适用于树莓派） 在终端中输入以下命令：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0e17943a531905679a9c5ea92dc6ee8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/899b26add10cc83f04922c6609160900/" rel="bookmark">
			什么是抽象语法树和三地址表达（通俗理解版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2.1 什么是抽象语法树和三地址表达（通俗理解版） 文献来源：《编译原理（第2版）》第二章
准备知识：术语 语法（Syntax） 规定了语言得表达形式。可以参考英语学习中的例子。英语句子的正常表达是按照主谓宾结构。例如
I love you. 当写成
I you love 就被认为是语法错误
语义（Semantics） 比如I love you是去爱，那么如果其行为为hate则为错。当然，计算机内部不会有爱与恨，但是有加减乘除等操作。如果是表达式是加法，而其行为是减法，则认为语义有错。
词法单元（Token） 词法分析器（一种对表达式进行分析的程序）处理多个字符组成的构造。比如词法分析器分析下列表达式
count + 1 假设词法分析器内部定义标识符为一个词法单元，那么count就是一个词法单元。
抽象语法树和语法树 语法树(syntax tree)是抽象语法树(abstract syntax tree)的简称。它表示了源程序的层次化语法结构。
假设C语言代码
do{ i = i + 1; }while(a[i]&lt;v); 形成抽象语法树的过程如下。
确定叶子节点。所有的变量，数字都为叶子。 i, 1, a, v 确定父节点。所有运算所涉及的符号 赋值(=), +, do-while逻辑中的循环体，do-while逻辑中的循环条件(&lt;)，索引[] 用叶子节点与父节点构成树形结构。 比如i+1
+ / \ i 1 然后将每一个子树进行组合形成整个表达式的抽象语法树
三地址代码 三地址码（Three Address Code）是一种最常用的中间语言，编译器可以通过它来改进代码转换效率。每个三地址码指令，都可以被分解为一个四元组（4-tuple）的形式：（运算符，操作数1，操作数2，结果）。由于每个陈述都包含了三个变量，即每条指令最多有三个操作数，所以它被称为三地址码。
https://blog.csdn.net/weixin_44966641/article/details/121718233
例如子树
可表达为
i = i + 1 整个抽象语法树的三地址表达为
《编译原理（第2版）》原文：这个中间代码的名字源于它的指令形式：x = y OP z ，其中OP是一个二目运算符，y和z是运算分量的地址，x是运算结果的存放地址。三地址指令最多只执行一个运算，通常是计算、比较或者分支跳转运算。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/899b26add10cc83f04922c6609160900/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/508bca12c2b103f8b22fbfbe5801699b/" rel="bookmark">
			Love 6 实习零碎的碎碎念 总结博客
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前引Love 6 从零开始的计算机学习之路 全系列总结博客1、Struggle &amp; Hustle 大多数零碎的碎碎念2、Record My Life 前引 2023/12/20日
看到这篇被我雪藏的博客 还是颇为感触啊
笔者现在已经秋招结束 坐在工位上 写下这段文字
今年秋招我很顺利的留在了微信部门 实习转正 这是我原来从来不敢想象的
我记得这篇博客很早我就写了出来 而且也是那段最焦虑的时间
下面的博客是我在实习期间 边焦虑 边自言自语的碎碎念 至少那个时候还有喜欢把所有的想法都记录在博客里面的习惯
我现在正在一篇一篇翻着我的草稿箱 找到了这篇
这篇博客我之前把他给转成仅我可见了 因为秋招上岸后 发现原来的博客里面充满了
极度欣喜 快乐 拿到offer时切实的开心 也有 处处碰壁的痛苦 煎熬 不自信 消极的情绪
经过一年的工作 我的心态和思想几乎和去年这个时候的我已经完全不是一个我了
现在的心态更像是一个真的已经入职正式员工干了一年半的员工了
看待互联网大厂 看待工作 也没有之前的各种滤镜和各种不切实际的幻想
原本只想把这些不是很好 幼稚的碎碎念 给藏起来
现在又想起了 原来很喜欢玩ow1 喜欢玩铁拳 然后经常给自己玩的好的几把给录屏录下来 发到b站上去
但是有一天忽然想不开 觉得原来的自己太幼稚了 就把那些视频给删除了
现在距离ow1 也已经几年了 我的铁拳也再也回不来了 我再也没有办法通过看视频的方式
重新回到那段和朋友无忧无虑开黑玩游戏的时光了
我是一个见物思人的人 我看到原来的照片 听到一些感触的歌曲 总会想到以前 想的很远很远
这几篇博客 说实话 想到原来的日子 苦闷却坚持 总会想到很多很难过的回忆
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/508bca12c2b103f8b22fbfbe5801699b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d913521d3d347f15d5cc938474e3aec/" rel="bookmark">
			Mysql高级查询语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下是一些MySQL中的高级查询语句：
1. 聚合函数：
```sql
SELECT COUNT(*) FROM table_name; -- 计算表中行数
SELECT SUM(column_name) FROM table_name; -- 计算列的总和
SELECT AVG(column_name) FROM table_name; -- 计算列的平均值
SELECT MAX(column_name) FROM table_name; -- 获取列的最大值
SELECT MIN(column_name) FROM table_name; -- 获取列的最小值
```
2. 排序：
```sql
SELECT column1, column2, ...
FROM table_name
ORDER BY column_name ASC/DESC; -- 按列升序或降序排序
```
3. 条件查询：
```sql
SELECT column1, column2, ...
FROM table_name
WHERE condition; -- 根据条件筛选查询结果
```
4. 连接查询：
```sql
SELECT column1, column2, .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d913521d3d347f15d5cc938474e3aec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4d042cb8e52182ddbe553ddf48ee0fb/" rel="bookmark">
			毕业设计- 基于Android的教务管理系统（带流程图）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 —— 等风来不如追风去，追逐的过程就是人生的意义。
项目介绍
系统用来管理班级的日常班务信息，系统角色分为三种管理员、班委和学生。
管理员：拥有最高权限，可以管理即增加、查询、修改和删除所有数据。
班委：不能申批学生请假、不能学业指导外，其他权限和管理员一样。
学生：只能查看相关的信息，不能申批不能修改任何数据，如只能查看班会信息、自己的请假申批状态等。
1. 班会管理 管理员和班委可以查看、添加、修改、删除班会信息，学生只能查看班会信息；
2. 活动管理 管理员和班委可以增删改查活动信息，学生只能查看活动信息；
3. 班费管理 管理员和班委可以增删改查班费信息，学生只能查看班费信息；
4. 请假管理 学生提交请假后，只有管理员才能申批，班委可以查看所有学生请假信息，学生只能查看自己的请假信息；
5. 学生管理 管理员和班委可以增删改查学生信息，学生只能查看学生信息；
6. 宿舍卫生 管理员和班委可以增删改查宿舍信息，学生只能查看宿舍信息；
7. 假期管理 管理员和班委可以增删改查学生假期去向信息，学生只能查看学生假期去向信息；
8. 学业指导 只有管理员才可以进行学业指导，班委可以查看所有学业指导内容，学生只能查看自己的学业指导信息；
项目截图
流程图
------转载请注明出处，感谢您对原创作者的支持------
如需要其他项目可留下您的联系方式 也可点个关注 我稍后联系您
o(￣▽￣)ｄ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/789931a7a83760ca6d4eeee1141d3ca1/" rel="bookmark">
			spring中DI依赖注入的两种方式set方法注入（property ）、构造器注入（constructor-arg）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 依赖注入：spring依赖注入的两种方式第一种set方法注入（property标签）第二种构造器注入 依赖注入： 类有属性，创建过程中向属性赋值
1.创建实体类：
public class Book { private String name; private String auth; //set public void setName(String name) { this.name = name; } public void setAuth(String auth) { this.auth = auth; } @Override public String toString() { return "Book{" + "name='" + name + '\'' + ", auth='" + auth + '\'' + '}'; } //构造器 public Book(String name, String auth) { this.name = name; this.auth = auth; } public Book() { } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/789931a7a83760ca6d4eeee1141d3ca1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5a8ebe86109bc5a4ecac3f76c902e48/" rel="bookmark">
			java IO流基础 万字详解（从拷贝文件到模拟上传头像）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、前言：
二、IO流简介：
1.什么是IO流？
2.IO流能干什么？
3.IO流的分类：
4.IO流体系： 三、字符流读写文件：
1.普通字符流读取文件：
前言: ①以单个字符读取: 代码演示（耐心全部看完！）:
②以字符数组读取： 代码演示:
2.普通字符流写入文件： ①按单个字符写入：
代码演示：
②按字符数组写入：
代码演示：
③按字符串写入：
代码演示：
3.字符流拷贝文件:
前言:
IO流拷贝的核心六部曲（全文背诵！）：
①以单个字符拷贝：
代码演示:
②以字符数组拷贝： 代码演示:
4.字符缓冲流（高效字符流）:
①字符缓冲流介绍:
②字符缓冲流的普通用法：
代码演示:
③字符缓冲流的特有用法：
代码演示: 四、字节流读写文件：
1.前言：
2.普通字节流用法：
①一次读写一个字节数组: 代码演示：
3.高效字节流用法：
①前言
②write重载方法：
代码演示:
五、IO流模拟上传头像系统：
六、完结撒❀
一、前言： 大家好，今天给大家带来一篇详解Java IO流基础的博文，也是我们“API——常用工具”专题——IO流篇章的最后一篇博文（异常基础 --&gt; File类 --&gt; IO流基础）。up会从字符流读写文件，字节流读写文件，高效字符流拷贝文件，以及高效字节流拷贝图片等几个方面一一进行代码演示，以帮助大家查缺补漏，快速上手Java IO流。注意事项 : ①代码中的注释也很重要。②不要眼高手低，自己跟着过一遍才真正有收获。③点击侧边栏目录或者文章开头的目录可以跳转。良工不示人以朴，up所有文章都会适时补充完善。感谢阅读！ 二、IO流简介： 1.什么是IO流？ 流是一种抽象概念，它代表了数据的无结构化传递。按照流的方式进行输入输出，数据被当成无结构的字节序列或字符序列。从流中取得数据的操作称为提取操作，而向流中添加数据的操作称为插入操作。用来进行输入输出操作的流就称为IO流。换句话说，IO流就是以流的方式进行输入输出的，即数据像流体一样连绵不绝进行传输。
I 即Input，输入。O 即Output，输出。
2.IO流能干什么？ IO流可以在本地磁盘和网络上对数据进行传输，比如说，字符流可以向一个空的文本文件中写入数据，或是从一个未知文本文件中读取数据，还可以进行文件的拷贝。而字节流则常用于拷贝图片。
3.IO流的分类： 关于IO流的分类，up认为一张图片便可清晰直观地解释，如图：
4.IO流体系： 不多bb，还是直接上图片！如图：
首先是字符流：
再来看一下字符流的类图，如下 : 然后是字节流：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5a8ebe86109bc5a4ecac3f76c902e48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ff91e386456867c721a932948a415dc/" rel="bookmark">
			nmap下载地址，免费使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载官网：https://nmap.
（1）选择最新版本
（2）选择操作系统类型
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3554a76b540355a61c225b389b6665cf/" rel="bookmark">
			实习期间 回忆大学生活的碎碎念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前引（2022/3/7日 笔者留）大一大二的学习历程（一）1、2022/3/7日留（大一到大二下）2、2022/5/12日留（大二下）3、2023/4/13日留（大二下-至今）4、2023/6/27日留（大三下） 前引（2022/3/7日 笔者留） 刚刚看到知乎给我推送了一个 腾讯天美后台开发第一面凉经 然后点进去看了看 发现自己很多问题也回答不出来 然后现在敲字就有些许焦虑 像这种情况 我感觉已经很多很多次了 原来看到真的是心里面一紧 现在感觉自己就已经习惯了 发现自己有很多很多不足的地方 对于很多概念还没有完全清晰 是一件好事情 因为这样会让自己明白 自己真的还有很多地方需要提高 自己后面还需要抓紧时间 不断地提升自己 到后面自己完成了关于网络编程的一些自己能够拿得出手的项目了 最后再去学习一下redis 最后可能还要再去学一下分布式的相关学习了… 忽然发现自己要学的东西还有好多…
当然 有焦虑的感觉是好事 我很清楚 也很明白 第一次拉通学习很多专业学科 肯定有非常多的地方 自己没有深入的学下去 至于对于去补齐那些基本的知识的时候 打算自己最后要腾出来非常多个月 认真的刷面经 开始彻底系统性的总结知识 准备面试了
其实在这里 我刚刚看了一位15级 拿了腾讯后台开发ssp的学长 然后看了看他的学习流程 发现还有很多地方需要补足和补强 我自己也忽然意识到 《linux多线程服务器开发》 将会是作为我的重点去学习的一本书 后面自己也会多去看看很多非常优秀的项目源码
我自己总是有的时候 感觉自己还算不错 但也仅限于 在我们学校这个平台 哈哈 向上看一看 眺望眺望 自己也就忽然发现 自己离在我前面的人好远好远 每次想停下来休息的时候 总会停下来 打开手机 看一看优秀的学长学姐们 哈哈 才发现自己的距离还不知道有多少米 自己也总会本来很浮躁 现在却能够静下来了
这些话写出来 当然也不是对我的自我否定 因为计算机后台开发这条路 我也很清楚 我现在也只是处在刚刚还起步的阶段 我需要去做去完成的事情还有非常非常多 自己当然不能够就这样松懈下来 希望自己也能够接下来坚持下来吧
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3554a76b540355a61c225b389b6665cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4493f3add73c05d0a64e17c04100f65f/" rel="bookmark">
			Docker必知必会
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker必知必会
一、安装docker
二、镜像的所有操作
1.增加镜像（拉取镜像 ）
2.删除镜像
3.修改镜像
4.查询镜像
三、容器的所有操作
1.增加容器
2.删除容器
3.修改容器
4.查看容器
5.启动容器
6.容器的状态：
四、Dockerfile的使用
1.Dockefile是什么有什么用
2.Dockerfile的语法和规范
3.Dockerfile示例
4.使用Dockerfile创建自己的镜像：docker build
5. “.dockerignore”文件
五、docker使用常见问题
1.docker的登录
2.本地容器上传远端仓库
3.本地容器跨服务器传送
4.配置阿里云镜像加速
5.端口映射问题
6.防火墙放行端口问题
7.容器不支持telnet命令
8.容器不支持ps命令
9.容器不支持vim命令
一、安装docker
这里介绍在centos7系统上的docker安装，linux中不同系统不同版本安装docker都会有些差异。
具体步骤见后面链接：centos7中docker的安装
二、镜像的所有操作
这里介绍镜像操作的增删改查，这是docker中比较频繁的操作之一。做这些操作之前请正常安装完成docker并启动。使用docker version可查看是否正常启动了docker。
1.增加镜像（拉取镜像 ）
docker image pull nginx:tag # *****************************************实战分割线*****************************************
#举例子：拉取nginx的最新版本镜像
docker image pull nginx:latest docker pull nginx:latest 1
2
3
4
5
docker image pull 命令主体，其中image是可以省略的，在整个命令中nginx是镜像的名称，tag是版本号，他们使用冒号隔开。如果不显示指定tag时，则默认拉取最新版本也就是latest版本。
2.删除镜像
docker rmi 镜像:tag
docker image rm 镜像名/镜像id
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4493f3add73c05d0a64e17c04100f65f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28e0a56e6dec0fd47affad690c63d10d/" rel="bookmark">
			图片怎么存储到数据库里
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		存储图片到数据库里一般有两种方式： 将图片保存的路径存储到数据库（文件存放在服务器的路径或者FTP服务器的路径）将图片以二进制数据流的形式直接写入数据库字段中（base64形式），不推荐，存储空间太大 图片在数据库的存储用途一般为
用户上传的头像，文章插图，文章首页图片等等其他方面的图片 一般存储图片有两种做法： 图片存储在磁盘上（服务器上），数据库字段中保存的是图片在服务器上存储的路径（推荐这种共做法）把图片直接以二进制形式存储在数据库中，一般数据库提供一个二进制字段来存储二进制数据。比如mysql中有个blob字段。oracle数据库中是blob或bfile类型 将图片转换成二进制存储： 大体思路：
将读取到的图片用自己的程序转化成二进制形式。（一般会有内置函数，可以快速转出为base64格式），Nodejs的话可以这样转化再结合insert into语句插入数据表中的blob类型字段中去。从数据库取出图片展示的时候。则是直接发送图片内容然后前端接收到二进制，展示到需要的位置即可 总结： 处理代码不是很麻烦，使用nodejs很容易就可以处理。但是，我们用得更多的是存储图片的路径，实际图片是在磁盘上保存的(图片二进制放到数据库,把数据库的负担弄重了)。需要代码的话，可以看我nodejs里面对图片的处理。
互联网环境中，大访问量，数据库速度和性能方面很重要。一般在数据库存储图片的做法比较少，更多的是将图片路径存储在数据库中，展示图片的时候只需要连接磁盘路径把图片载入进来即可。
因为图片是属于大字段。一张图片要占用1MB甚至几十MB，所以使用数据库很浪费资源，但是如果图片量很小的情况下可以尝试，或者直接在后台开辟空间存储文件（这样也给服务器造成了不小的压力），所以最好还是使用第三方文件上传平台，像七牛云，阿里云，腾讯云等。
牵扯到一些基本的数据库调优，比如这篇文章分为标题、作者、添加时间、更新时间、文章内容、文章关键字等等。
文章内容一般是比较长的。经常使用text字段去存储。文章的内容就属于大字段。一般文章内容可以拆分到单独一个表中去。不要与文章信息存储在一张表里面。
个人的理解： mysql中一张表的数据是全部在一个数据文件中的，如果大字段的数据也存储在里面，比如，程序展示列表，比如文章列表，这个时候根本不需要展示文章内容的，但是仍然会影响速度。数据库查找数据其实就是扫描那个数据文件，文件容量越小，速度就会越快(为什么单表的容量在1GB–2GB的时候基本上要分表了)。拆分出去到一张单独的表，就是单独的文件了。举一反三，相互独立，分离的思想不仅在系统开发中用到，在现实生活中经常存在的。
总结：三种东西永远不要放到数据库里，图片，文件，二进制数据 原因 对数据库的读/写的速度永远都赶不上文件系统处理的速度数据库备份变的巨大，越来越耗时间对文件的访问需要穿越你的应用层和数据库层把图片缩略图存到数据库里？很好，那你就不能使用nginx或其它类型的轻量级服务器来处理它们了。 关于mysql中的blob类型 bolb(binary large object)二进制大对像就像int型那样，分为blob、MEDIUMBLOB、LONGBLOB。其实就是从小到大
blob容量为64KB MEDIUMBLOB 容量为16MLONGBLOB 容量为4G 说实话，图片用这样子存储用得还真少。使用java的序列化函数进行序列化的值，有人存入这个字段中去。
mysql中blob字段存储图片有个通信大小的设置： 图片要传输给mysql存储起来，那么需要涉及到数据通信。mysql中有个配置是限制通信数据大小的
my.conf配置文件中的max_allowed_packet，mysql默认的值是1M
好多图片尤其是原始图可能不止1m。传输的数据(也就是图片)超过这个设置大小。结果就会出错
其实所谓的性能，最关键是数据库性能。因为随着数据库数据量增大，大部分时间耗费是在php，java等语言等待数据库返回数据的过程中耗费时间。
网站访问量大了后，具体的语言不是瓶颈，瓶颈都在数据库。用c，python，php，java都能操作mysql数据库获取数据。语言之间可能存在速度执行差异，但是其实这种差别已经很小了。至少我觉得，给予用户感觉不到明显。执行相差0.0001秒用户感觉并没有明显的区别。
可能说，大并发(很多用户同时访问)的时候，就会体现到差别了。其实我觉得，大并发访问是数据库瓶颈。等待数据库给予数据。没达到一定级别实在体现不了差别。数据库数据量达到一定级别。语言相差0.001s会给予用户体验上的差别。所以，这也是为什么php很适合做web开发了。
解析页面速度快(解释型语言，不需要编译)。可以用java来与数据库打交道获取数据。php不直接操作数据库，而是调用java提供的数据接口，获取数据，马上展示在页面中。这是利用了php的页面执行速度快的一个优势。
二、数据库中保存图片路径 一般是这样子的：
按照年月日生成路径。具体是按照年月日还是按照年月去生成路径，根据自己需要(不一定是按照日期去生成)。
理解为什么要分散到多个文件夹中去才是关键，涉及到一个原理就明白了： 操作系统对单个目录的文件数量是有限制的。当文件数量很多的时候。从目录中获取文件的速度就会越来越慢。所以为了保持速度，才要按照固定规则去分散到多个目录中去。图片分散到磁盘路径中去。数据库字段中保存的是类似于这样子的”images/2012/09/25/ 1343287394783.jpg”原来上传的图片文件名称会重新命名保存，比如按照时间戳来生成，1343287394783. jpg。这样子是为了避免文件名重复，多个人往同一个目录上传图片的时候会出现。反正用什么样的规则命名图片，只要做到图片名称的唯一性即可。比如网站的并发访问量大，目录的生成分得月细越好。比如精确到小时，一个小时都可以是一个文件夹。同时0.001秒有两个用户同时在上传图片(因为那么就会往同一个小时文件夹里面存图片)。因为时间戳是精确到秒的。为了做到图片名称唯一性而不至于覆盖，生成可以在在时间戳后面继续加毫秒微秒等。总结的规律是，并发访问量越大。就越精确就好了。 有个方面总结一下： 为什么保存的磁盘路径，是”images/2012/09/25/1343287394783.jpg”，而不是” /images/2012/09/25/1343287394783.jpg”(最前面带有斜杠)?
连那个斜杠都不要。这里也是做到方便以后系统扩展。在页面中需要取出图片路径展示图片的时候，如果是相对路径，则可以使用”./”+”images/2012/09/25/1343287394783.jpg”进行组装。如果需要单独的域名(比如做cdn加速的时候)域名，img1.xxx.com,img2.xxx.com这样的域名直接组装 “http://img1.xxx.com/”+”images/2012/09/25/1343287394783.jpg”当然数据库是可以在前面加斜杠/保存起来，/images/2012/09/25/ 1343287394783.jpg其实不方便统一。比如相对路径载入图片的时候，则是”.”+” /images/2012/09/25/ 1343287394783.jpg”可能我还没体会到坏处，以后会遇到问题的。不过，遵循惯例不加斜杠” images/2012/09/25/1343287394783.jpg”就对了。 涉及到一个新问题： 为什么大部分系统都不会域名保存进去，像这样子http://www.xxx.com/images/2012/09/25/1343287394783.jpg保存到数据库中
了解的知识越多，越有利于我们做决定。可能就是一个”感觉区别不是很大”的影响下，去做一个决定，反而对后面是比较大的影响的。至少是增加自己的工作量了。其实把域名保存进去，也不是什么滔天大罪的事情。但凡是经验丰富的开发人员都不会这样子做。这是一个经验积累出来的，所以上海那个网友也对此并没有明显的概念很正常，他说他不知道cdn方面的(当然觉得存个域名进去没什么大不了的)。需要了解cdn知识，什么情况下会用到cdn知识。虽然是做开发人员，不需要关注运维和服务器之类的知识。不过了解一些就有利于理解了。这里涉及到cdn加速。关于cdn原理(就是内容分发网络)，我理解其本质就是为了解决距离远产生的速度问题，使用就近的服务。 CDN 从中国请求美国一台服务器上的图片。一般比较慢，因为距离这么远，网络传输是存在损耗的，距离越远，传输的时间就越长。一般会看到浏览器左下角显示：“已响应,正在传输数据…”。这不是服务器本身问题了。实际上服务器早就响应请求，把数据发给客户端，但是网络问题，就一直在传输，没传完了。在中国，是南北距离远的问题。南北还会涉及到跨网，南方用户使用电信居多，北方用户网通居多。两个线路需要跨越，会有时间延迟。cdn加速就是适应这个需求产生的：现在不请求美国的服务器。直接在中国安放节点(节点是比较笼统的词语，可以理解成一台服务器，也可以理解成一个机房，就是一个点嘛)，请求距离近的节点。这样子就不需要那么远的距离了。 以前在长沙的网站，团购以城市分站的形式。北京和长沙用的是同一套程序。服务器在长沙。北京用户访问北京站的时候,实际上需要远距离访问长沙的服务器。速度怎么都快不起来。跟服务器性能完全没关系。当时不懂这些。不清楚怎么折腾。就想办法去做js代码压缩，浏览器缓存之类的。实际上瞎折腾。不是说这些前端优化不重要，哲学上有主次矛盾之分，瓶颈在哪里就去突破哪里。没解决主要矛盾，问题并不会迎刃而解。当时也不是数据库瓶颈。如果去优化数据库。也不会明显改善。就那点数据量。根本就达不到瓶颈。哪里谈得上主要矛盾。随着后来去其他公司工作，接触一些东西，类似不找瓶颈的优化例子发生在身边好几次了，先没找到瓶颈就瞎去优化。我的同事可能是抱着多多益善的心态去做的，但主要矛盾(技术上说是瓶颈)没找到，也没改善。
当时如果没想到是距离问题。也就不会想到cdn，当时其实我根本不知道cdn服务。我只知道，google这些网站肯定在中国部署的服务器，要不然，中国用户还去访问美国的服务器，那再好的服务器都会速度慢的。
由于自己搭建cdn环境和机房的资金比较大（需要大量的服务器），也需要人力维护。反正一般的公司弄不起，其实根本不划算。淘宝以前用商用的cdn服务，后来商用的扛不住了，就搭建了自己的cdn网。我不知道新浪有没有自己搭建，但其实我觉得跟淘宝的特点有关，店铺很多，无论是商品还是交易记录总计起来商品很多的图片，图片都是静态的部分，cdn本来就是用来做静态的(图片，css，js等)请求分发用的。
之前在网上看到一句话，cdn网络不是一般的公司玩得起的。
一般的公司自己搭建cdn网络成本高，所以就有商业的cdn提供付费租用服务，这是一项很成熟的业务，很多这样的公司，大部分全国性的互联网公司都会使用到cdn。
总结：cdn服务。对于静态内容是非常适合的。所以像商品图片，随着访问量大了后，租用cdn服务，只需要把图片上传到他们的服务器上去。 例子：北京访问长沙服务器，距离太远。我们完全可以把商品图片，放到北京的云服务（我们觉得现在提供给网站使用的云存储其实就是cdn，给网站提供分流和就近访问）上去。这样子北京用户访问的时候，实际上图片就是就近获取。不需要很长距离的传输。
自己用一个域名img.xxx.com来载入图片。这个域名解析到北京的云服务上去。
做法:数据库中保存的是” images/2012/09/25/1343287394783.jpg”,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28e0a56e6dec0fd47affad690c63d10d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1911d7aeba40669797bfe887ea7c0bfe/" rel="bookmark">
			持续集成gitlab-ci.yml配置文档基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0x00 简述 Q:什么是.gitlab-ci.yaml?它有什么作用? 答：gitlab-ci全称是gitlab continuous integration的意思就是持续集成;gitlab-ci.yaml是Gitlab-CI做持续集成和发布的执配置文件，里面定义了如何测试、编译、以及部署阶段执行的脚本，该文件的配置高度依赖于项目本身，以及 CI/CD 流水线的需求。即每次在我们push到gitlab的时候，都会触发此脚本
WeiyiGeek.CI/CD流程概览
WeiyiGeek.CI/CD流程概览
gitlab-ci.yml 其配置文件主要由以下部分组成：
1.Pipeline 描述:一次 Pipeline 其实相当于一次构建任务，里面可以包含很多个流程，如安装依赖、运行测试、编译、部署测试服务器、部署生产服务器等流程。任何提交或者 Merge Request 的合并都可以触发 Pipeline 构建，如下图所示
+----------------+ +----------+ | | trigger | | | Commit / Merge +----------&gt;+ Pipeline | | | | | +----------------+ +----------+ 复制
2.Stages 描述:Stages 表示一个构建阶段，也就是上面提到的一个流程。我们可以在一次 Pipeline 中定义多个 Stages，这些 Stages会有以下特点：
1) 所有 Stages 会按照顺序运行，即当一个 Stage 完成后下一个 Stage 才会开始
2) 只有当所有 Stages 完成后，该构建任务 (Pipeline) 才会成功
3) 如果任何一个 Stage 失败，那么后面的 Stages 不会执行，该构建任务 (Pipeline) 失败 Stages 和 Pipeline 的关系如下所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1911d7aeba40669797bfe887ea7c0bfe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/482dd95c16fcfc57975ded2510c0cf02/" rel="bookmark">
			【计算机网络】八股文 | 第五章
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【计算机网络】八股文 | 第五章 零、前言推荐阅读十二、运输层之TCP与UDP的基础TCP/UDP/IP的定义及概念TCP与UDP的区别TCP和UDP的使用场景关于更多TCP/UDP的基础知识 十三、UDP相关为什么UDP不会粘包？UDP协议为什么不可靠？为什么及时通信要用 UDP 十四、TCP相关TCP粘包是怎么回事，如何处理?TCP为什么是可靠连接TCP的三次握手为什么TCP要三次握手为什么TCP客户端最后还要发送一次确认为什么握手是三次，而不是两次或者四次？三次握手可以携带数据吗？TCP三次握手失败，服务端会如何处理?如果已经建立了连接，但客户端故障了怎么办TCP四次挥手过程（TCP面向连接）需要四次挥手理由TCP 短连接和长连接的区别TCP 最大连接数限制TIME_WAIT状态有什么作用，为什么主动关闭方没有直接进入CLOSED状态释放资源？为什么TIME_WAIT状态需要经过2MSL才能进入CLOASE状态?一台主机上出现大量的TIME_WAIT是什么原因？应该如何处理？一台主机上出现大量的CLOSE_WAIT是什么原因？应该如何处理？TCP的重传机制TCP的流量控制机制TCP的拥塞控制机制TCP连接管理中的保活机制ISN是固定的吗SYN攻击 下一章笔记 零、前言 承接前面第一章的笔记：
【计算机网络】八股文 | 第四章
笔记链接：【计算机网络】八股文 | 第四章笔记主要内容：
主要内容为Cookie/Session/token的相关知识点，以及常见面试题目。 本章内容：主要是TCP与UDP的相关知识
推荐阅读 这里同样也推荐一些我觉得不错的博客，重点在于知识的share。
关于这里我比较推荐的是小林coding, 关于计算机网络小林博主的图解不得不说很nice，主要很直观。👍++
笔记链接：【计算机网络】TCP/UDP篇笔记感受：个人觉得小林coding在TCP篇写得非常奈斯，所以在本篇章笔记中更加推荐大家去阅读这篇章。非常受用、形象且深入。 十二、运输层之TCP与UDP的基础 首先，对于TCP与UDP，我们需要先了解一下相关的概念
TCP/UDP/IP的定义及概念 UDP(User Datagram Protocol,用户数据报协议)
一种无连接的、不可靠的、基于报文的全双工传输层协议。因为不需要建立连接所以 可以在网络上以任何可能的路径传输，因此能否到达目的地、到达目的地的时间以及内容的正确性都是不能被保证的。
【定义的扩展解释】
无连接：知道对方的端口号和IP就可以直接进行传输，不需要建立连接不可靠：没有任何安全机制，发送端发送数据之后就不管对方有没有收到了全双工：UDP的socket既可以读也可以写，这就叫全双工 【特点】
无连接、不可靠尽可能提供交付数据服务，出现差错直接丢弃，无反馈面向报文，发送方的 UDP 拿到上层数据直接添加个 UDP 首部，然后进行校验后就递交给 IP 层，而接收的一方在接收到 UDP 报文后简单进行校验，然后直接去除数据递交给上层应用速度快，因为 UDP 协议没有 TCP 协议的握手、确认、窗口、重传、拥塞控制等机制，UDP 是一个无状态的传输协议，所以它在传递数据时非常快，即使在网络拥塞的时候 UDP 也不会降低发送的数据。 TCP/IP(Transmission Control ProtocolInternet Protocol, 传输控制协议/网际协议)
指能够在多个不同网络间实现信息传输的协议簇 。
TCP/IP协议不仅仅指的是TCP 和IP两个协议，而是指一个由FTP、SMTP、TCP、UDP、IP 等协议构成的协议簇，只是因为在TCP/IP协议中TCP 协议和IP协议最具代表性，所以被称为TCP/IP 协议。
因特网地址是 TCP/IP 协议，比如 “xxx.xxx.xx.xxx” 就是一个 TCP/IP 协议。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/482dd95c16fcfc57975ded2510c0cf02/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/451be0b329aa4db77f19876e341fd669/" rel="bookmark">
			Angular获取及设置input光标位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 获取元素selectionStart获取光标位置下标setSelectionRange设置光标位置 获取元素 &lt;input #myInput (input)="onInput()" type="text"&gt; import { Component, ViewChild, ElementRef } from '@angular/core'; @Component({ ... }) export class YourComponent { @ViewChild('myInput', {static: false}) myInput: ElementRef; } selectionStart获取光标位置下标 onInput() { const cursorPosition = this.myInput.nativeElement.selectionStart; console.log('光标位置：', cursorPosition); } setSelectionRange设置光标位置 this.myInput.nativeElement.setSelectionRange(selectionStart, selectionEnd [, selectionDirection]); 参数介绍：
selectionStart: 被选中的第一个字符的位置索引, 从 0 开始。如果这个值比元素的 value 长度还大，则会被看作 value 最后一个位置的索引。selectionEnd: 被选中的最后一个字符的下一个位置索引。如果这个值比元素的 value 长度还大，则会被看作 value 最后一个位置的索引。selectionDirection：选择方向。forward/backward/none 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fafd43187ea6ea95e9d820dc145e4b11/" rel="bookmark">
			C语言宏定义中的后缀
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #define UART0 0x10000000L 这种写法是在C语言中定义一个宏（macro），它的作用是把UART0这个标识符替换成0x10000000L这个值。0x10000000L是一个十六进制（hexadecimal）的常量（constant），表示一个长整型（long）的数值。表达式后面的L是一个后缀（suffix），用来指定常量的类型（type）。如果没有L，那么常量的类型就是默认的整型（int）。L的作用是让编译器（compiler）知道这个常量是一个长整型，这样可以避免一些类型转换（type conversion）的错误。
U或u：表示无符号整数（unsigned int），例如100U或0x10u。F或f：表示单精度浮点数（float），例如3.14f或1.23e5f。L或l：表示长整数（long int）或长双精度浮点数（long double），例如123L或1.23l。UL或ul：表示无符号长整数（unsigned long int），例如100UL或0x10ul。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51e5195916a81fc4e8acebd0a0f0f1c6/" rel="bookmark">
			SimpleFOC之ESP32（一）—— 搭建开发环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 说明一、ESP32介绍二、Arduino IDE的ESP32开发环境搭建2.1、安装Arduino IDE2.2、安装SimpleFOC库2.3、安装ESP库文件2.5、安装Python2.6、选择ESP32开发板 三、点亮LED3.1、ESP32-DevKitC方案3.2、ESP32drive方案3.3、示例演示 四、系统打印 SimpleFOC教程目录：请点击 说明 2016年春天的时候第一次接触ESP8266，用的ESP-12的模块，串口转wifi通信。本来是很简单的工作，串口发送数据完事，按照习惯看下手册，这一看把我绕晕了，它的与众不同的Xtensa内核，FreeRTOS系统和以开发应用的方式编程，简直就是单片机行业中的外星文明，再搭配超低的价格，深深的震撼了我。
我学习了FreeRTOS，学习了Linux环境下的应用编程，并建议老板在这个芯片上多下点功夫，这个芯片以后一定会大放异彩，但是老板的兴趣显然不在这，没有了支持，我的学习也停留在，只能在ESP8266上做个点亮LED的小应用。
2020年初因为公司业务发展学习了Python，发现ESP8266可以跑MicroPython，于是又拿出来曾经的模块演示一遍，这时候发现ESP的编程方式主要是在Arduino上，还有Lua和MicroPython这些新兴语言的支持。早期的ESP8266提供SDK API，Lubuntu安装包等，但目前的官方似乎已经不再强调这些，ESP中应用程序的开发已经完全软件化，这与STM32的keil编程方式大相径庭（当然keil的库函数和CubeMX也是软件化的一种体现）。
硬件编程软件化是一个趋势，ESP会成为单片机多极化发展中的一极，我看好这个芯片！
一、ESP32介绍 ESP8266：乐鑫公司最早打出知名度的芯片，只有WIFI通信，32-bit LX6单核处理器，160MHz。ESP32：有WIFI、BL4.2和BLE通信，32-bit LX6双核处理器，240MHz。
其它ESP32-S、ESP32-C系列为更高端的芯片，不做介绍。ESP的芯片因为自带wifi和蓝牙，非专业人士设计电磁兼容有难度，所以原厂很体贴的把芯片电路设计好，以模块的方式对外出售，大大降低了普通开发者的使用难度。ESP32官方提供三个系列的模块，分别是： ESP32-SOLO 系列，低档，ESP32-WROOM 系列，中档，ESP32-WROVER 系列，高档，本系列教程以 ESP32-WROOM-32 模块为例。
官方不仅推出了ESP32的模块，还推出了最小系统板ESP32-DevKitC，
官方开发板上的USB转串口用的是CP2102，进口芯片价格偏高，市场上有很多改进版本采用国产芯片CH340，根据本人多年经验，国产同样好用。
二、Arduino IDE的ESP32开发环境搭建 所谓搭建编译环境，就是在Arduino中添加ESP32的库文件和编译器，
你可以按照下面的步骤自己搭建，也可以直接下载本人搭建好的安装包。20220524
SimpleFOC v2.2.2 和 Arduino-1.8.19+STM32开发环境+ESP32开发环境：
链接: https://pan.baidu.com/s/1xT8sMJKPw3QdRs03gPPpUg
提取码: dayk
ESP32的开发环境搭建网上有很多种，为保持文章的完整性，简单说明。
2.1、安装Arduino IDE Arduino IDE下载地址：https://www.arduino.cc/en/software
此软件免安装，下载的文件，放到不包含中文路径的文件夹中，解压后双击图标 打开软件，如果打开失败，可能是需要安装JDK，请先安装Java的JDK。
2.2、安装SimpleFOC库 打开Arduino IDE，点击 工具—&gt;管理库
在打开的小窗口中输入Simple FOC，选择最新版本，点击安装。
2.3、安装ESP库文件 ◆ 2.3.1、下载库文件
https://github.com/espressif，下载arduino-esp32，
下载压缩包，
◆ 2.3.2、安装ESP32库文件
解压压缩包，并修改文件夹名字为esp32，找到Arduino IDE的安装路径，在hardware文件夹下新建espressif文件夹，把解压后的esp32文件夹移动到当前位置，路径及解压后的文件如下图，
◆ 2.3.3、安装ESP32编译器
上面安装的是ESP32的库文件和示例，下面还要再安装编译器。网上主流的教程是：先安装python，然后运行tools文件夹下的 get.exe。（运行get.exe就是启动get.py，这是个python文件，所以必须要安装python。）
本人操作时等了半个小时没反应，网上搜到一篇文章比较专业：https://www.jianshu.com/p/a8f3fc166b5d，
简单的说，要下载的编译器就是三个文件，分别是xtensa-esp32-elf-gcc、esptool_py、mkspiffs，安装ESP32编译器的本质就是去github下载这三个文件放入当前的tools文件夹中，
三个文件的下载路径如下：
https://github.com/espressif/crosstool-NG/releases/download/esp-2021r1/xtensa-esp32-elf-gcc8_4_0-esp-2021r1-win32.ziphttps://github.com/espressif/arduino-esp32/releases/download/2.0.0-alpha1/esptool-3.1.0-windows.ziphttps://github.com/igrr/mkspiffs/releases/download/0.2.3/mkspiffs-0.2.3-arduino-esp32-win32.zip可以直接下载，这样就不用再安装python，也不用在黑窗口里等待。
2.5、安装Python python的安装方法也顺便说下吧，或许能用上。如果编译器已经安装好了可以不用安装python。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51e5195916a81fc4e8acebd0a0f0f1c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/653ba59b82c24bc93a563c3ca748914b/" rel="bookmark">
			备战第15届蓝桥杯的同学注意了！蓝桥算法双周赛开始了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
第十五届蓝桥杯报名：
提升方法
「蓝桥·算法双周赛」
报名和参赛流程
近期场次1
近期场次2（奖品丰厚，建议不容错过）
赛后题解及答疑
赛后排行榜
注意事项
结语
第十五届蓝桥杯报名： 关于开放第十五届蓝桥杯大赛个人赛个人报名功能的通知
什么？竟然还有人不知道蓝桥杯？
蓝桥杯：蓝桥杯全国软件和信息技术专业人才大赛是由工业和信息化部人才交流中心举办的全国性IT学科赛事。每年都有众多高校参赛，且获奖率高达60%，而所有参赛选手均可获得由工业和信息化部人才交流中心及大赛组委会联合颁发的获奖证书，其含金量不言而喻。博主也是参加过13、14两届蓝桥杯，并且还作为14届参赛选手荣获C/C++组国赛二等奖。
蓝桥杯大赛同时还作为重要竞赛项目对个人的大学生评优评先，就业考研都有着重要的助益。怎么样？心动不心动？可能这样就有人问了，我是零基础小白，怎么训练呢？那么接下来便是提升干货！
提升方法 众所周知，如果想要在即将到来的第十五届蓝桥杯中获奖的话，平时的算法训练那是必然少不了的，那么对于算法上的训练，想必部分同学一定是一头雾水的，不知道从何开始，学习哪些算法呢？
这边博主罗列了一些关于蓝桥杯省赛&amp;国赛的常用算法：
DFS（深度优先搜索）、BFS（广度优先搜索）、贪心、二分答案、双指针、动态规划（线性DP，区间DP，背包问题）、最短路、最小生成树等等
在蓝桥杯官网中给各位同学们提供了可供练习这些算法的专门的算法习题：
鼠标移动至对应的算法标签上即可出现该算法的考察频率以及题目跳转链接 当然在日常刷题的过程中如何检验自己的学习成果呢？那么蓝桥算法双周赛便是一个不错的选择
我为什么会推荐呢？那是因为
「蓝桥·算法双周赛」 每两周举办一次，在相邻场次之间留有足够的时间供你对上次比赛查漏补缺以及练习算法从而备战下一次的比赛，什么？你说你没时间？放心，比赛都是在每周六的晚上19:00-21:00，简直不要太爽
比赛报名免费，且人人均可以参与（划重点），不管你是刚学算法的小白，还是磨练速度的入门者均可以报名参赛。并且在赛后都会有现金和实物奖励，单场现金最高可获得300至1000元不等。
在参加比赛的同时不仅能检验自己的学习成果，在拿到相应的名次还有奖励拿。怎么样？香不香？
顺便给你们说一个小秘密：博主当初准备蓝桥省赛以及国赛的时候也在蓝桥杯官网上刷题并参与比赛的哦~
博主之前备赛蓝桥刷的题以及参加的比赛：
刷题是必不可少的，博主截止到目前总共刷了有1000+道题，所以在一定题量的加持下，你一定会得到质的飞跃
目前有两场蓝桥算法双周赛可以参加
报名和参赛流程 算法赛 - 蓝桥云课
近期场次1 比赛时间：2023年12月23日 周六 19:00 - 21:00
比赛详情页：
🕖第2场小白入门赛（积分≥1200分本场不计分）：第 2 场 小白入门赛 - 蓝桥云课
🕖第2场强者挑战赛：第 2 场 强者挑战赛 - 蓝桥云课
近期场次2（奖品丰厚，建议不容错过） 比赛时间：2023年12月27日 周三 19:00 - 21:00
比赛详情页：
🕖第1场算法季度赛（蓝桥&amp;搜狐畅游联名）：第 1 场 算法季度赛 蓝桥&amp;搜狐畅游 - 蓝桥云课
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/653ba59b82c24bc93a563c3ca748914b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97d98e6fb3a477795fb977bd1e2947ec/" rel="bookmark">
			C/C&#43;&#43; 随机数(rand/srand)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C/C++随机数 rand() 随机srand() 随机 (设置一个种子)srand() 指定范围随机随机0.00 ~ 1.00之间的doublesrand() 随机0-9之间的数随机整数范围内的小数 rand() 随机 #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; int main() { // 随机数 rand(每次启动都是一样的数) for (int i = 0; i &lt; 10; i++) { printf("%d \n", rand()); } return 0; } srand() 随机 (设置一个种子) #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;time.h&gt; int main() { // srand 随机数，设置一个种子seed, // 发现每次重启还是一样的值, 只有种子不一样，随机数才不一样 srand(11); for (int i = 0; i &lt; 10; i++) { printf("%d \n", rand()); } // 获取种子每次不一样的值 int seed = time(NULL); // 通常传入当前的时间（保证不重复） srand(seed); for (int i = 0; i &lt; 10; i++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97d98e6fb3a477795fb977bd1e2947ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eca52ae3177720dcb67adb95599bd03f/" rel="bookmark">
			❤ Vue中使用高德地图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		❤ 一、Vue中使用高德地图(script 引入方式实现在线加载) 1、认识 官网找到对应的web服务文档
2、使用 🌂 1、注册自己的高德地图key 2、页面上引入使用自己的高德地图key 安装地图插件 按 NPM 方式安装使用 Loader
npm i @amap/amap-jsapi-loader --save 2.0版本的引入和使用 在线引用 &lt;script type="text/javascript" src="https://webapi.amap.com/maps?v=1.4.15&amp;key=您申请的key值"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="https://webapi.amap.com/maps?v=2.0&amp;key="&gt;&lt;/script&gt; 引入 JS API Loader import AMapLoader from "@amap/amap-jsapi-loader"; JS API Loader 进行加载
window._AMapSecurityConfig = { securityJsCode: "「你申请的安全密钥」", }; mounted() { this.initAMap(); }, initAMap() { AMapLoader.load({ key: "", // 申请好的Web端开发者Key，首次调用 load 时必填 version: "2.0", // 指定要加载的 JSAPI 的版本，缺省时默认为 1.4.15 plugins: [], // 需要使用的的插件列表，如比例尺'AMap.Scale'等 }) .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eca52ae3177720dcb67adb95599bd03f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/269334922999f577811f4e90c8849a63/" rel="bookmark">
			C&#43;&#43;力扣题目206--反转链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。
示例 1：
输入：head = [1,2,3,4,5] 输出：[5,4,3,2,1] 思路：
如果再定义一个新的链表，实现链表元素的反转，其实这是对内存空间的浪费。
其实只需要改变链表的next指针的指向，直接将链表反转 ，而不用重新定义一个新的链表
详细思路类似于数组中的双指针法，已在代码中注释。代码如下：
class Solution { public: ListNode* reverseList(ListNode* head) { ListNode* cur = head; ListNode* pre = NULL;//反向后头结点应指向于空 while (cur) { ListNode* temp = cur-&gt;next;//使用一个临时指针保存快指针的指针域 cur-&gt;next = pre;改变快指针的指针域使之指向其前驱结点，实现反向 pre = cur;//移动慢指针到快指针的位置 cur = temp;//将快指针移动到其后继结点的位置 } return pre; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09920e78b1fd27dad44be7a6256a4587/" rel="bookmark">
			C&#43;&#43;力扣题目 59--螺旋矩阵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。
示例 1：
输入：n = 3 输出：[[1,2,3],[8,9,4],[7,6,5]] 思路：该题考察模拟循环过程，想清楚边界，坚持循环不变量原则，本人采用的是左闭右开，也可以左开右闭，根据自己定好的原则来设计。代码如下：
vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) { vector&lt;vector&lt;int&gt;&gt; v(n, vector&lt;int&gt;(n, 0));//开辟新二维数组 int loop = n / 2;//循环的圈数 int row_start = 0, column_start = 0, now_loop =1, i=1;//循环起始位置，当前循环圈数，计数起始点 for (; loop &gt; 0; loop--) { int row = row_start; int column = column_start; for (; column &lt; n - now_loop;column++)//右开，所以不能等于 { v[row][column] = i++; } for (; row &lt; n - now_loop; row++) { v[row][column] = i++; } for (; column &gt; now_loop-1; column--) { v[row][column] = i++; } for (; row &gt; now_loop-1; row--) { v[row][column] = i++; } now_loop++; column_start++; row_start++; } if (n % 2) { //如果n为奇数，手动为剩余的一个赋值 v[n/2][n/2] = i; } return v; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99034cefd92af815072200f0c16299fe/" rel="bookmark">
			vue路由跳转传参
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1 传值 2 取值 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d6dcebe717d43907ce1a0d43d38cb8a/" rel="bookmark">
			SpringBoot 2.2.5 整合spring-boot-starter-mail邮件功能，实现发送多种邮件的功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明 以目前IT系统功能来看，邮件功能是非常重要的一个功能。例如：找回密码、邮箱验证，邮件动态码、忘记密码，邮件营销等，都需要用到邮件功能。spring-boot-starter-mail支持多种邮件，包括gmail，qq，163，126等等，本文用到的是网易126邮箱。
完整代码地址在结尾！！ 第一步，注册126邮箱， 并且在设置里面授权开通smtp服务，此时会获取到一个邮箱的授权吗，后面要用到，此处不多赘述，不懂请自行百度查询 第二步，在pom.xml加入依赖，如下 &lt;!-- mail --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt; &lt;/dependency&gt; 第三步，配置application.yml，避免端口冲突 server: port: 8081 spring: application: name: mail-demo-server mail: host: smtp.126.com # 不同的邮箱不一致，请自行百度查询 port: 25 # 126邮箱默认25 username: xxx # 发送邮箱 password: xxx # 授权码 protocol: smtp default-encoding: utf-8 # properties: # 此处可以添加ssl端口 # mail.smtp.auth: true # mail.smtp.starttls.enable: true # mail.smtp.starttls.required: true # mail.smtp.socketFactory.port: 465 # mail.smtp.socketFactory.class: javax.net.ssl.SSLSocketFactory # mail.smtp.socketFactory.fallback: false 第四步，创建类服务类，MailService，MailServiceImpl，如下 MailService public interface MailService { /** * 发送简单邮件的接口 * * @param mail 接收邮箱 * @param subject 主题 * @param text 内容 * @return */ boolean sendSimpleMail(String mail, String subject, String text); /** * 发送带附件邮件的接口 * * @param mail 接收邮箱 * @param subject 主题 * @param text 内容 * @param path 附近路径 * @return */ boolean sendMimeMail(String mail, String subject, String text, String path) throws Exception ; /** * 发送带附件邮件的接口，并且正文显示附件内容 * * @param mail 接收邮箱 * @param subject 主题 * @return */ boolean sendMimeMail(String mail, String subject) throws Exception ; } MailServiceImpl import com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d6dcebe717d43907ce1a0d43d38cb8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96d36689efa222f6846b54f7a9382935/" rel="bookmark">
			Android开发中报错总结之一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在我们开发中经常会遇到报错，今天主要是记录一下，我在开发中遇到的问题：
问题一：material-1.5.0-alpha03\res\values-v31\values-v31.xml:3:5-94: AAPT: error: resource android:color/system_neutral1_1000 not found
解决方案：
查看自己app下的build文件中是不是有：
implementation 'com.google.android.material:material:1.5.0'这个依赖 如果有，将这个依赖修改为
implementation 'com.google.android.material:material:1.5.0-alpha02'然后Sync Now就好了 问题二：error: resource android:attr/lStar not found
修改一下app下build文件中：
minSdkVersion 21
targetSdkVersion 31
问题三：Failed to find Build Tools revision 31.0.2
在Settings-&gt;System Settings-&gt;Android SDK-&gt;SDK Platforms中下载中对应的SDK,然后重启IDE就好了
问题四：如图
在清单文件中：application中添加
android:networkSecurityConfig="@xml/network_security_config" android:requestLegacyExternalStorage="true" 以上就是所遇到的问题，之后会慢慢更新记录更多的问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cb9116823e0dd1d9e4e8a8099c87d07/" rel="bookmark">
			记录每日LeetCode 2828.判别首字母缩略词 Java实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述：
给你一个字符串数组 words 和一个字符串 s ，请你判断 s 是不是 words 的 首字母缩略词 。
如果可以按顺序串联 words 中每个字符串的第一个字符形成字符串 s ，则认为 s 是 words 的首字母缩略词。例如，"ab" 可以由 ["apple", "banana"] 形成，但是无法从 ["bear", "aardvark"] 形成。
如果 s 是 words 的首字母缩略词，返回 true ；否则，返回 false 。
初始代码：
class Solution { public boolean isAcronym(List&lt;String&gt; words, String s) { } } 示例1：
输入：words = ["alice","bob","charlie"], s = "abc" 输出：true 解释：words 中 "alice"、"bob" 和 "charlie" 的第一个字符分别是 'a'、'b' 和 'c'。因此，s = "abc" 是首字母缩略词。 示例2：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cb9116823e0dd1d9e4e8a8099c87d07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b30aceabba0d9ee23e372a3bfa4618c1/" rel="bookmark">
			微信小程序ts&#43;less模版引入Rant Weapp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、新建微信小程序模版 选择：不使用云服务 / ts+less
二、引入Rant Weapp https://vant-contrib.gitee.io/vant-weapp/#/quickstart
我使用以下方式
1、第一步 # 通过 npm 安装 npm i @vant/weapp -S --production 2、第二步 将 app.json 中的 "style": "v2" 去除 3、第三步 修改 project.config.json ，ui组件会根据这个路径找 { ... "setting": { ... "packNpmManually": true, "packNpmRelationList": [ { "packageJsonPath": "./package.json", "miniprogramNpmDistDir": "./miniprogram/" } ] } } 4、第四步 重启开发工具、工具 -&gt; 构建 npm 5、第五步 typescript 支持 在 tsconfig.json 中增加如下配置，以防止 tsc 编译报错。 请将path/to/node_modules/@vant/weapp修改为项目的 node_modules 中 @vant/weapp 所在的目录。 { ... "compilerOptions": { .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b30aceabba0d9ee23e372a3bfa4618c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9013a050d27674d21679efb596c2aad/" rel="bookmark">
			前端路由模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、hash 模式Hash 模式的特点window.onhashchange 事件 二、history 模式history APIwindow.onpopstate 事件解决history模式下页面刷新404问题 如何选择合适的路由模式 一、hash 模式 hash 模式是一种把前端路由的路径用 # 拼接在真实 url 后面的模式，通过 hashchange 事件监听 hash 值的改变来渲染页面对应的组件。hash 模式不会向后端发送 http 请求，所有的 hash 值操作都与后端无关。
使用 location.hash 获取 hash 值。
Hash 模式的特点 兼容性好：Hash 模式支持所有现代浏览器，并且在不支持 HTML5 History API 的旧版浏览器上也能正常工作。简单配置：在 Vue 路由中，默认使用 Hash 模式，不需要额外的配置。易于部署：由于使用了 hash，URL 发生变化时不会触发页面刷新，因此部署时只需将静态文件部署到服务器即可。 window.onhashchange 事件 当 URL 的片段标识符（hash 值）更改时，将触发 hashchange 事件 (跟在＃符号后面的 URL 部分，包括＃符号)。
使用 addEventListener 监听 hashchange 事件： window.addEventListener('hashchange', function() { console.log('hash值被修改了') }, false); 使用 onhashchange 事件处理程序 function locationHashChanged() { if (location.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9013a050d27674d21679efb596c2aad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6435ecc5e011dc9e20be604c32716460/" rel="bookmark">
			利用prometheus&#43;grafana进行Linux主机监控
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一.架构说明与资源准备二.部署prometheus1.上传软件包2.解压软件包并移动到指定位置3.修改配置文件4.编写启动脚本5.启动prometheus服务 三.部署node-exporter1.上传和解压软件包2.设置systemctl启动3.启动服务 四.部署grafana1.安装和启动grafana2.设置prometheus数据源3.新增监控模板4.修改模板的变量和配置信息 一.架构说明与资源准备 需要准备的软件包：
node_exporter-1.2.0.tar.gz grafana-7.3.0-1.x86_64.rpm prometheus-2.45.1.linux-amd64.tar.gz 以上软件版本可以有一定的差异，只要兼容RHEL7的操作系统，本次部署的3台虚拟机操作系统是 CentOS Linux release 7.9.2009 (Core) 。
软件包下载地址参考：
https://rpmfind.net/linux/rpm2html/search.php https://sourceforge.net/projects/infozip/files/ https://centos.pkgs.org/7/centos-x86_64/ https://access.redhat.com/downloads 二.部署prometheus 本章操作都在node01进行。
1.上传软件包 首先将软件包上传到/root目录下
2.解压软件包并移动到指定位置 接着创建/data目录，准备将后续解压后的软件文件放在/data目录
mkdir /data tar zxf prometheus-2.45.1.linux-amd64.tar.gz mv prometheus-2.45.1.linux-amd64 /data/prometheus 3.修改配置文件 针对配置文件 /data/prometheus/prometheus.yml 进行修改
global: scrape_interval: 15s evaluation_interval: 15s scrape_timeout: 15s alerting: alertmanagers: - static_configs: - targets: - 192.168.0.201:9093 rule_files: # - "first_rules.yml" # - "second_rules.yml" - rules/*.yml scrape_configs: - job_name: "node_exporter" static_configs: # #监控的主机IP和node-exporter端口 - targets: ['192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6435ecc5e011dc9e20be604c32716460/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82023a3d9fceb47f7c960f557e9008f5/" rel="bookmark">
			AI人工智能课题：图像识别菜品识别系统的设计与实现（基于百度智能云AI接口）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主介绍：黄菊华老师《Vue.js入门与商城开发实战》《微信小程序商城开发》图书作者，CSDN博客专家，在线教育专家，CSDN钻石讲师；专注大学生毕业设计教育和辅导。
所有项目都配有从入门到精通的基础知识视频课程，免费
项目配有对应开发文档、开题报告、任务书、PPT、论文模版等
项目都录了发布和功能操作演示视频；项目的界面和功能都可以定制，包安装运行！！！
如果需要联系我，可以在CSDN网站查询黄菊华老师
在文章末尾可以获取联系方式
图像识别菜品识别系统的设计与实现（基于百度智能云AI接口）
一、研究背景与意义
随着人工智能技术的快速发展，图像识别技术已经广泛应用于各个领域，包括餐饮业。在餐饮业中，菜品识别系统的应用可以提高餐厅的运营效率和服务质量，改善客户体验。因此，设计并实现一个基于百度智能云AI接口的图像识别菜品识别系统具有重要意义。
通过该系统，餐厅可以快速准确地识别出顾客点选的菜品，避免人工误判和漏单等问题，提高餐厅的服务效率和顾客满意度。同时，该系统还可以为餐厅提供菜品销售数据的统计和分析，帮助餐厅管理者更好地了解市场动态和顾客需求，指导餐厅的经营决策。
二、国内外研究现状
目前，国内外在图像识别领域已有一定的研究基础，一些大型科技公司和研究机构已经推出了自己的图像识别技术和产品。在餐饮业中，一些餐厅已经开始尝试使用图像识别技术来提高服务效率和质量。然而，现有的菜品识别系统往往存在识别准确率不高、应用场景有限等问题，无法满足餐厅的实际需求。
三、研究思路与方法
本研究将采用基于百度智能云AI接口的图像识别技术，设计并实现一个图像识别菜品识别系统。具体研究思路如下：
收集并整理不同菜品的图像数据；利用百度智能云AI接口进行图像处理和特征提取；训练分类器模型，实现菜品的自动分类和识别；开发后台管理系统和前端可视化界面；实现数据的实时更新和动态展示；对系统进行测试和性能评估。 四、研究内容与创新点
本研究的主要内容包括：
设计并实现一个基于百度智能云AI接口的图像识别菜品识别系统；实现菜品的自动分类和识别；开发易于使用的用户界面和交互功能；对系统进行测试和性能评估。 本研究的创新点在于：
采用基于百度智能云AI接口的图像识别技术，提高菜品识别的准确率和效率；结合餐厅实际需求设计易于使用的用户界面和交互功能，提高系统的易用性；实现数据的实时更新和动态展示，为餐厅管理者提供及时准确的销售数据和市场动态信息。 五、后台功能需求分析和前端功能需求分析
后台功能需求主要包括：图像数据的收集与整理、图像处理与特征提取、分类器模型的训练与优化等。具体需求包括定期更新菜品图像数据、对图像进行预处理和特征提取、训练并优化分类器模型以提高识别准确率等。前端功能需求主要包括：菜品的可视化展示、用户交互和界面设计等。具体需求包括利用图表、图片等可视化元素展示菜品信息、提供用户交互功能、设计简洁直观的用户界面以及实现实时数据更新等。
六、研究思路与研究方法、可行性
本研究采用的技术路线成熟且广泛应用于相关领域，因此具有较高的可行性。首先，百度智能云AI接口提供了丰富的图像处理和特征提取功能，可以满足菜品识别的需求。其次，本研究将结合餐厅实际需求进行系统设计和开发，确保系统的实用性和易用性。最后，通过对系统进行测试和性能评估，可以验证系统的稳定性和可靠性。
七、研究进度安排
第一阶段：完成文献调研和需求分析（1个月）；第二阶段：完成图像数据的收集和整理（1个月）；第三阶段：完成图像处理、特征提取和分类器模型训练（2个月）；第四阶段：完成后台管理系统和前端可视化界面的开发（2个月）；第五阶段：完成系统测试评估和论文撰写（1个月）。 八、论文（设计）写作提纲
绪论：阐述研究背景和意义、国内外研究现状等；图像识别技术概述：介绍图像识别的基本原理和相关技术；系统架构设计：介绍基于百度智能云AI接口的菜品识别系统的整体架构和各功能模块的设计；后台功能开发与实现：详细介绍后台功能的开发过程和实现方法；前端功能开发与实现：介绍前端界面的设计和实现过程；系统测试与评估：对系统进行功能和性能测试，评估系统的稳定性和可靠性；结论与展望：总结研究成果和不足，提出未来改进和研究方向。 九、主要参考文献
[此处列出与本研究相关的参考文献] 这些参考文献可以包括相关的学术论文、技术文档和案例研究等，用于支持本研究的研究背景和意义、技术方法和实现等方面的论述。
开题报告
一、研究背景与意义
随着人工智能技术的发展和应用的不断拓展，图像识别技术在各个领域得到了广泛的应用。在餐饮行业中，图像识别技术可以被用于菜品的识别和分类，可以帮助餐厅提高效率和服务质量。因此，设计和实现一个基于百度智能云AI接口的图像识别菜品识别系统具有重要的实际意义。
二、国内外研究现状
目前，国内外关于图像识别菜品识别系统的研究已经取得了一定的进展。国外的一些研究者已经提出了一些基于深度学习的图像识别算法，如卷积神经网络（CNN）、循环神经网络（RNN）等，并取得了良好的效果。在国内，很多互联网公司也推出了一些图像识别菜品识别系统，如百度的菜品识别系统、美团的菜品识别系统等。然而，这些系统存在一些问题，如识别准确率不高、系统运行速度慢等。
三、研究思路与方法
本研究将采用基于百度智能云AI接口的图像识别技术，通过训练模型来实现菜品的识别和分类。具体的研究思路和方法如下：
数据收集和预处理：从互联网上收集大量的菜品图片，并对这些图片进行预处理，如去除噪声、调整图像大小和颜色等。
模型选择和训练：选择适合的图像识别算法，在百度智能云AI接口上进行模型训练，优化模型参数，提高识别准确率。
系统设计和实现：设计并实现一个图像识别菜品识别系统，包括后台功能和前端功能。
四、研究内客和创新点
本研究的内客是设计和实现一个基于百度智能云AI接口的图像识别菜品识别系统。创新点主要有以下几个方面：
结合百度智能云AI接口：利用百度智能云提供的图像识别接口，可以方便地实现菜品的识别和分类。
提高识别准确率：通过模型选择和训练，优化算法参数，提高菜品识别的准确率。
设计完善的系统功能：除了基本的菜品识别功能，还可以增加一些额外的功能，如菜品推荐、菜品热度分析等。
五、后台功能需求分析和前端功能需求分析
后台功能需求分析：
图片上传功能：用户可以通过系统上传菜品图片。
图像识别功能：系统能够通过百度智能云AI接口对上传的图片进行识别和分类。
数据存储功能：系统能够将识别结果和图片信息存储到数据库中。
前端功能需求分析：
用户注册和登录功能：用户可以注册和登录系统，以便使用系统的功能。
图片上传功能：用户可以通过系统上传菜品图片。
图像识别结果展示功能：系统可以将识别结果展示给用户，包括菜品名称和识别准确率。
六、研究思路与研究方法、可行性
研究思路和研究方法已在上文中详细描述，本研究的可行性主要体现在以下几个方面：
数据收集和预处理：互联网上有大量的菜品图片可以进行收集和使用，预处理也是图像识别技术的常见环节，具备可行性。
模型训练和优化：百度智能云提供了图像识别接口和训练模型的功能，可以方便地进行模型训练和优化。
系统设计和实现：基于百度智能云的图像识别菜品识别系统已经有一些案例，并且具备一定的可行性。
七、研究进度安排
本研究的进度安排如下：
数据收集和预处理阶段：收集菜品图片并进行预处理，预计耗时1个月。
模型训练和优化阶段：选择合适的算法进行模型训练，并对模型进行优化，预计耗时2个月。
系统设计和实现阶段：根据功能需求进行系统的设计和实现，预计耗时1个月。
测试和优化阶段：对系统进行测试和优化，提高系统的稳定性和性能，预计耗时1个月。
五、论文（设计）写作提纲
引言 1.1 研究背景 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82023a3d9fceb47f7c960f557e9008f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ea31e9de8451dc138930b8b313214a3/" rel="bookmark">
			【IDEA】idea活用设置：隐藏显示指定的项目文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【IDEA】idea活用设置：隐藏显示指定的项目文件 1.需求产生 新建了一个springboot项目，如下图，有很多其他的文件夹，影响观感，怎么隐藏呢？
2.设置隐藏指定后缀的文件 打开idea设置，或在ieda主页点击 file，点击Settings，在搜索框内输入 File Types ； 或根据下图所示标识进入到如下界面的细节：
这里我示例一些，方便开发者取用
*.cmd
*.idea
*.iml
*.log
*.mvn
*.gitignore
添加如上图的几个文件后缀，idea会筛选掉带这一类后缀名的文件（idea并非删除该后缀文件，而是隐藏不显示）。
需要注意的一点 后缀名为.target的文件一般不过滤，某些项目编译后需要检查有没有生成lib等文件夹，就需要在.target文件夹里面查看项目编译的细节。
设置后重启idea即可
最后附一张筛选后截图对比情况
OK
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/487174db1138fc858dfb281e19a72921/" rel="bookmark">
			Maven内网开发使用离线仓库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Maven内网开发使用离线仓库 离线或者内网环境开发与外网不通，中央仓库连不上，使用 Maven 管理项目会遇到很多问题。
比如：依赖包缺失，内网的Nexus私服的包老旧，很久没有维护，项目无法运行打包，第三方非公开的私人 Jar 包引入麻烦。
本文面向这几个问题，提出几个解决方法：
解决方法： 把项目弄外网，打包好再传入；（× 都内网开发了保密要求不行，不耍小聪明）使用本地离线仓库，离线打包；（√ ）先上传到内网Nexus私服，再使用；（√ ） 具体操作： 1.离线仓库： 先说说离线仓库：
首先，在外网新建一个测试项目，把需要的 jar 包依赖坐标都写在 pom.xml 物料清单里，然后把依赖下载到本地仓库。
注意1：
默认本地仓库（比如：D:/maven/maven_repo）可能有历史项目曾用的 Jar 包，占用空间会非常大。可以在 IDEA 的设置搜索Maven，重写本地仓库路径（比如：D:/maven/demo_repo），这里面仅包含本项目用到的 Jar 包。
注意2
把 demo_repo 压缩成 zip 包，搞到内网后，解压在仓库根路径下直接搜索关键字：_remote/ lastUpdate，搜到的文件都删除掉，不然在内网还是去找远程仓库下载，影响打包。
最简单的方法，在本地仓库根目录搜索栏关键字删除：
搜到的文件ctrl+A全选，再delete删除。
命令方式：
# 打开仓库地址，输入cmd 打开命令行，执行下面语句 for /r %i in (_remote.repositories) do del %i for /r %i in (lastUpdate) do del %i 内网操作
进入 Maven 的 conf 目录，复制 settings.xml 并重命名为 settings-offline.xml。修改 settings-offline.xml 文件，修改以下几处。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/487174db1138fc858dfb281e19a72921/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a7dc1a0129d7abe1410d94c15b6329c/" rel="bookmark">
			Polar 这又是一个上传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Polar 这又是一个上传 开局还是一个文件上传界面
有前端后缀检查，这个好绕，抓包改后缀就行
绕过后burp可以直接传一个php上去
getshell
但是无法cat flag，感觉权限不够，需要提权。
查找具有suid权限的命令
1=system('find / -user root -perm -4000 -print 2&gt;/dev/null'); 发现有pkexec。polkit是一个授权管理器，其系统架构由授权和身份验证代理组成，pkexec是其中polkit的其中一个工具，他的作用有点类似于sudo，允许用户以另一个用户身份执行命令
一般不确定是否有提权的时候，我都会上https://gtfobins.github.io/看一下。
看一下版本：
存在CVE-2021-4034 pkexec 本地提权漏洞，可以将用户身份直接变为root
2009年5月至今发布的所有 Polkit 版本都受这个漏洞影响。
注：Polkit预装在CentOS、Ubuntu、Debian、Redhat、Fedora、Gentoo、Mageia等多个Linux发行版上，所有存在Polkit的Linux系统均受影响。
底层原理不过了，直接利用，可以看看的一些文章：
【CVE-2021-4034】 漏洞详细原理以及复现，polkit的pkexec中的本地提权漏洞-CSDN博客
CVE-2021-4034 深入分析及漏洞复现 - 先知社区 (aliyun.com)
CVE-2021-4034 pkexec 本地提权漏洞利用解析-安全客 - 安全资讯平台 (anquanke.com)
CVE-2021-4034 polkit（pkexec）提权漏洞复现-腾讯云开发者社区-腾讯云 (tencent.com)
蚁剑上马，不知道哪里出问题了，目录一直没权限读取，好在/tmp目录还是可以读写的。
/tmp目录有读写权限，右键上传文件。
POC下载地址：
berdav/CVE-2021-4034: CVE-2021-4034 1day (github.com)
奶奶滴，poc解压不了，可以本地解压后上传单个文件，但是执行poc无效，奶奶滴。（发癫）
其他倒是还好，POC无效真的受不了。。。。
大B老师说没完整tty（再次表达感谢~）
如何判断tty是否完整：
为什么没完整tty，会影响提权呢？
因为完整的tty是很多命令执行的前提，比如sudo，不是完整的tty是不能sudo的（感谢叶哥的指导），以下是一些必须依靠tty的命令。
passwd: 修改用户密码时，需要在TTY中输入当前密码和新密码。su / sudo: 切换用户或以管理员权限执行命令时，通常需要在TTY中输入相应的密码。shutdown / reboot: 关机或重启系统时，可能需要在TTY中输入管理员密码或确认操作。top / htop: 查看系统进程和资源占用情况，这些命令在TTY中显示实时信息。vim / nano / emacs: 编辑文本文件时，这些文本编辑器通常在TTY中使用。apt / yum / dnf: Linux 发行版的包管理器，进行软件包安装、更新或删除时需要在TTY中执行。ssh: 通过终端远程登录到其他计算机时，需要在TTY中输入密码或进行身份验证。gnome-terminal / konsole / xterm: 在图形界面下打开终端时，这些终端模拟器在TTY中运行。 接下来使用哥斯拉的superterminal，可以直接解决没完整tty的问题
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a7dc1a0129d7abe1410d94c15b6329c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5736015093ce6d4815885fb93647fce/" rel="bookmark">
			JUC-3-线程池
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线程池 基本概述 线程池：一个容纳多个线程的容器，容器中的线程可以重复使用，省去了频繁创建和销毁线程对象的操作
线程池作用：
降低资源消耗，减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务提高响应速度，当任务到达时，如果有线程可以直接用，不会出现系统僵死提高线程的可管理性，如果无限制的创建线程，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控 线程池的核心思想：线程复用，同一个线程可以被重复使用，来处理多个任务
池化技术 (Pool) ：一种编程技巧，核心思想是资源复用，在请求量大时能优化应用性能，降低系统频繁建连的资源开销
阻塞队列 基本介绍 有界队列和无界队列：
有界队列：有固定大小的队列，比如设定了固定大小的 LinkedBlockingQueue，又或者大小为 0
无界队列：没有设置固定大小的队列，这些队列可以直接入队，直到溢出（超过 Integer.MAX_VALUE），所以相当于无界
java.util.concurrent.BlockingQueue 接口有以下阻塞队列的实现：FIFO 队列
ArrayBlockQueue：由数组结构组成的有界阻塞队列LinkedBlockingQueue：由链表结构组成的无界（默认大小 Integer.MAX_VALUE）的阻塞队列PriorityBlockQueue：支持优先级排序的无界阻塞队列DelayedWorkQueue：使用优先级队列实现的延迟无界阻塞队列SynchronousQueue：不存储元素的阻塞队列，每一个生产线程会阻塞到有一个 put 的线程放入元素为止LinkedTransferQueue：由链表结构组成的无界阻塞队列LinkedBlockingDeque：由链表结构组成的双向阻塞队列 与普通队列（LinkedList、ArrayList等）的不同点在于阻塞队列中阻塞添加和阻塞删除方法，以及线程安全：
阻塞添加 put()：当阻塞队列元素已满时，添加队列元素的线程会被阻塞，直到队列元素不满时才重新唤醒线程执行阻塞删除 take()：在队列元素为空时，删除队列元素的线程将被阻塞，直到队列不为空再执行删除操作（一般会返回被删除的元素) 核心方法 方法类型抛出异常特殊值阻塞超时插入（尾）add(e)offer(e)put(e)offer(e,time,unit)移除（头）remove()poll()take()poll(time,unit)检查（队首元素）element()peek()不可用不可用 抛出异常组： 当阻塞队列满时：在往队列中 add 插入元素会抛出 IIIegalStateException: Queue full当阻塞队列空时：再往队列中 remove 移除元素，会抛出 NoSuchException 特殊值组： 插入方法：成功 true，失败 false移除方法：成功返回出队列元素，队列没有就返回 null 阻塞组： 当阻塞队列满时，生产者继续往队列里 put 元素，队列会一直阻塞生产线程直到队列有空间 put 数据或响应中断退出当阻塞队列空时，消费者线程试图从队列里 take 元素，队列会一直阻塞消费者线程直到队列中有可用元素 超时退出：当阻塞队列满时，队里会阻塞生产者线程一定时间，超过限时后生产者线程会退出 链表队列 入队出队 LinkedBlockingQueue 源码：
public class LinkedBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; implements BlockingQueue&lt;E&gt;, java.io.Serializable { static class Node&lt;E&gt; { E item; /** * 下列三种情况之一 * - 真正的后继节点 * - 自己, 发生在出队时 * - null, 表示是没有后继节点, 是尾节点了 */ Node&lt;E&gt; next; Node(E x) { item = x; } } } 入队：尾插法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5736015093ce6d4815885fb93647fce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a493c9f9fb3555afc89aeb1904c76e6/" rel="bookmark">
			JUC-4-同步器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		同步器 AQS 核心思想 AQS：AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架，许多同步类实现都依赖于该同步器
AQS 用状态属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取锁和释放锁
独占模式是只有一个线程能够访问资源，如 ReentrantLock共享模式允许多个线程访问资源，如 Semaphore，ReentrantReadWriteLock 是组合式 AQS 核心思想：
如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置锁定状态
请求的共享资源被占用，AQS 用队列实现线程阻塞等待以及被唤醒时锁分配的机制，将暂时获取不到锁的线程加入到队列中
CLH 是一种基于单向链表的高性能、公平的自旋锁，AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配
设计原理 设计原理：
获取锁：
while(state 状态不允许获取) {	// tryAcquire(arg) if(队列中还没有此线程) { 入队并阻塞 park } } 当前线程出队 释放锁：
if(state 状态允许了) {	// tryRelease(arg) 恢复阻塞的线程(s) unpark } AbstractQueuedSynchronizer 中 state 设计：
state 使用了 32bit int 来维护同步状态，独占模式 0 表示未加锁状态，大于 0 表示已经加锁状态
private volatile int state; state 使用 volatile 修饰配合 cas 保证其修改时的原子性
state 表示线程重入的次数（独占模式）或者剩余许可数（共享模式）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a493c9f9fb3555afc89aeb1904c76e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee90bb52a358e805b8bcd2d68beaa349/" rel="bookmark">
			越权漏洞（基于catfishcms靶场的垂直越权、水平越权）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 垂直越权 创建一个普通用户test、和管理员用户admin页面的url对比，未发现任何越权url 创建一个后台用户test1、和管理员用户admin页面的url对比 test1后台页面，只有内容管理 admin后台管理页面 在页面管理的新建页面的url和test1用户做比较，多了admin/index/newpage.html 在test1用户管理页面的url后加上admin/index/newpage.html 发现只有admin管理员用户才能访问的新建页面功能被爆出，同理可以爆出其他的比如修改管理员密码和新增加超级管理员 用新增加的超级管理员OMG用户登录 登录成功，此处判定为垂直越权漏洞 水平越权 经过对网页进行一系列查找点击，发现在编辑文章这里有传参，修改参数有跳转，疑似有越权漏洞 添加两个可以编辑发布文章的账户test1、test2 分别用两个用户写两篇文章 在test2用户下点击编辑文章，修改url的art参数为3，发现跳转到了test1用户的文章 修改文章内容，保存查看，修改成功，为水平越权。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59ad201064145151682118c88c710783/" rel="bookmark">
			dts备份
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，
/include/ "system-conf.dtsi" / { model = "DTS Board"; leds { compatible = "gpio-leds"; led@0 { label = "ps_led0"; gpios = &lt;&amp;gpio0 0 0&gt;; linux,default-trigger = "heartbeat"; default-state = "on"; }; }; keys { compatible = "gpio-keys"; autorepeat; net_reset { label = "net_reset"; linux,code = &lt;28&gt;; gpios = &lt;&amp;gpio0 40 1&gt;;	/* 低有效 */ debounce-interval = &lt;15&gt;; autorepeat; }; }; pl-regs { compatible = "cqyt, pl_regs"; interrupt-parent = &lt;&amp;intc&gt;; interrupts = &lt;0 29 4&gt;; reg = &lt;0x83C00000 0x0200&gt;; }; }; &amp;gem0 { status = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59ad201064145151682118c88c710783/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6d9696b2f7fbcb8080a99db55d3cc45/" rel="bookmark">
			vulkan相关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 参考 vulkan-tutorial 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca41c6dcdf9216dbc64cd1018f545ee3/" rel="bookmark">
			Npm包管理工具的下载、安装、发布等使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： NPM的全称是Node Package Manager
是一个NodeJS包管理和分发工具，已经成为了非官方的发布Node模块（包）的标准。
是JavaScript运行时环境Node.js的默认包管理器。
2020年3月17日，Github宣布收购Npm，GitHub现在已经保证Npm将永远免费。
Npm 为你和你的团队打开了连接整个 JavaScript 天才世界的一扇大门。
它是世界上最大的软件注册表，截至2020年3月17日，npm为大约1200万开发人员提供了130万个软件包，这些开发人员每月下载这些软件包达750亿次。
来自各大洲的开源软件开发者使用 Npm 互相分享和借鉴。包的结构使您能够轻松跟踪依赖项和版本。
Npm官网：https://www.npmjs.com
Npm中文网：https://www.npmjs.cn
一、关于Npm 1、Npm 由三个独立的部分组成： （1）网站 https://npmjs.com ，是开发者查找包（package）、设置参数以及管理 npm 使用体验的主要途径
（2）注册表（registry），是一个巨大的数据库，保存了每个包（package）的信息
（3）命令行工具（CLI)）https://docs.npmjs.com/cli/npm ，是通过命令行或终端运行。开发者通过 CLI 与 npm 打交道
2、Npm常用命令: 命令注释npm -v显示版本，检查npm 是否正确安装npm install -g npm to update更新升级npmnpm init 项目名创建项目 手动填写配置信息npm init 项目名 -y创建项目并自动生成配置信息npm list显示当前项目中已安装模块npm list -g显示所以已安装模块npm root显示当前项目 node_modules目录npm root -g显示全局node_modules目录npm show 模块名显示当前项目模块详情npm update升级当前目录下的项目的所有模块npm update 模块名升级当前目录下的项目的指定模块npm install 模块名安装模块（局部安装）npm install -g 模块名全局安装模块npm install 模块1 模块2...同时安装多个模块，中间用空格隔开npm cache clean --force清除npm缓存npm update -g 模块名升级全局安装的模块npm uninstall 模块名删除指定的模块npm config list显示npm相关信息 3、使用Npm安装模块(包) 安装命令：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca41c6dcdf9216dbc64cd1018f545ee3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b33965637058b1146b72f12d04968038/" rel="bookmark">
			Linux 安装MySQL 8.0步骤:
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		First:
1.检查是否安装过MySQL
rpm -qa | grep -i mysql
2.删除MySQL
yum -y remove MySQL-*
注意:一般用rpm -e 的命令删除mysql,这样表面上删除了mysql,可是mysql的一些残余程序仍然存在,并且通过第一步的方式也查找不到残余,而yum命令比较强大,可以完全删除mysql.(ps:用rpm删除后再次安装的时候会提示已经安装了,这就是rpm没删除干净的原因)
3.把所有出现的目录统统删除(删除使用rm -rf 要删除的目录)
find / -name mysql
4.删除配置文件
rm -rf /etc/my.cnf
5.删除MySQL的默认密码
rm -rf /root/.mysql_sercret
注意:删除mysql的默认密码,如果不删除,以后安装mysql这个sercret中的默认密码不会变,使用其中的默认密码就可能会报类似Access denied for user ‘root@localhost’ (using password:yes)的错误.
以上五个步骤(没有安装过可以不执行,但建议执行一次,以降低报错的概率)完成后就可以开始安装MySQL
1.配置MySQL 8.0安装数据源
sudo rpm -Uvh https://dev.mysql.com/get/mysql80-community-release-el7-3.noarch.rpm
安装MySQL 8.0需要注意 必须先更新MySQL GPG密码,否则将会提示报错(源GPG密钥已经过期!)
rpm --import https://repo.mysql.com/RPM-GPG-KEY-mysql-2022
2.安装MySQL 8.0
sudo yum --enablerepo=mysql80-community install mysql-community-server
出现下载插件提示时选择y
看到complet(完毕)就是安装完了
4.启动MySQL服务
sudo service mysqld start
5.查看MySQL的运行状态
service mysqld status
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b33965637058b1146b72f12d04968038/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bacec27010ec96854af252378eb117da/" rel="bookmark">
			【openssl】Linux升级openssl-1.0.1到1.1.1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、openssl是什么？二、使用步骤1.下载2.编译安装3.一些问题 总结 前言 记录一次openssl的升级，1.0.1升级到1.1.1
一、openssl是什么？ OpenSSL是一个开源的加密工具包，广泛用于安全套接层（SSL）和传输层安全（TLS）协议的实现。它提供了一组用于加密通信的库和工具，被许多网络应用和操作系统广泛使用。
二、使用步骤 1.下载 首先，我们需要从官方网站下载最新版本的OpenSSL源代码。你可以访问 OpenSSL官方网站 获取最新的稳定版本。
wget https://www.openssl.org/source/openssl-1.1.1w.tar.gz 2.编译安装 下载完成后，解压缩源代码文件并进入目录：
tar -zxvf openssl-1.1.1w.tar.gz cd openssl-1.1.1w 执行以下步骤进行编译和安装：
./config --prefix=/usr/local/openssl --openssldir=/usr/local/openssl shared make make test sudo make install 最后配一下新版openssl的环境
# 备份一下旧版 mv /usr/bin/openssl /usr/bin/openssl.bak # 新版建立新的软链接 ln -s /usr/local/bin/openssl /usr/bin/openssl # 编辑ld.so.conf，如没有/usr/local/lib，新起一行加进去 vi /etc/ld.so.conf # 加载新配置 ldconfig 结束后如不能使用，退出shell，重新登入，输入openssl version查看版本
[root@xx]# openssl version OpenSSL 1.1.1w 11 Sep 2023 3.一些问题 以下两个问题解决办法
如果你没有lib64，则放lib，请自行审验
openssl: error while loading shared libraries: libssl.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bacec27010ec96854af252378eb117da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd84a4d0fdfcad967eefd526ff2b8cd6/" rel="bookmark">
			Idea远程debugger调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 当我们服务部署在服务器上，我们想要像在本地一样debug,就可以使用idea自带的`Remote JVM Debug` 创建Remote JVM Debug服务器启动jar打断点进入断点 当我们服务部署在服务器上，我们想要像在本地一样debug,就可以使用idea自带的 Remote JVM Debug) 创建Remote JVM Debug 服务器启动jar包的时候要带上面截图的：Command line arguments for remote JVM:
-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=10086
注意：服务器执行命令：10086是 idea和服务器连接socket的端口号 ，和项目本身的端口无关
服务器启动jar nohup java -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=10086 -jar job-hunting.jar &amp; 然后在Idea上启动Remote JVM Debugger 控制柜console 出现:
Connected to the target VM, address: '192.168.128.128:10086', transport: 'socket'
就成功了
打断点 然后就可以在你想要打断点的方法上打断点，访问接口进入断点
进入断点 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39a570ddd246291a5ee7fcf15ec33539/" rel="bookmark">
			【兔子王赠书第13期】AI绘画实战：Midjourney从新手到高手
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 写在前面AI绘画推荐图书一本书读懂AI绘画关键点内容简介作者简介 推荐理由粉丝福利写在后面 写在前面 如今AI技术已经进入了我们的日常学习生活中，如何用一本书轻松玩转AI绘画，领略无限艺术可能呢？
AI绘画 AI绘画是指利用人工智能技术进行绘画创作的一种艺术形式。人工智能绘画可以通过计算机程序模拟艺术家的绘画风格和技巧，自动生成具有艺术价值的绘画作品。
人工智能绘画的原理主要是通过算法模拟人类艺术家的绘画过程。首先，需要对大量艺术作品进行深入的分析和研究，提取出不同艺术家的绘画特点和风格。然后，利用机器学习和神经网络等技术，将这些特点和风格编码为算法，使计算机能够模拟艺术家的绘画过程。最后，通过输入一些参考图像或主题，计算机就可以自动生成具有艺术特点和风格的绘画作品。
AI绘画在艺术创作中有着广泛的应用。一方面，它可以帮助艺术家扩展创作的可能性，通过模拟不同艺术家的风格，让艺术家得到更多的灵感和创作方向。另一方面，它也可以作为一种独立的艺术形式存在，通过机器生成的作品展示出独特的美感和视觉效果。
AI绘画的发展与应用，受到了艺术界和科技界的广泛关注。有些人认为，AI绘画是一种对传统绘画的挑战，甚至对艺术创作的独特性和原创性产生了疑问。而也有些人认为，AI绘画是一种新的艺术表现形式，能够展现出人工智能技术的创新和艺术的魅力。
然而，AI绘画也面临着一些挑战和限制。首先，由于艺术是一种情感和创造性的表达，AI绘画难以真正达到艺术家的感受和想法。其次，AI绘画还面临着版权和原创性等法律和伦理问题。因为机器生成的作品往往没有明确的创作者，导致作品的版权归属和商业价值难以确定。
总的来说，AI绘画作为一种新的艺术形式，对于推动艺术创作的发展和创新，具有重要的意义。通过机器学习和神经网络等技术，AI绘画能够模拟艺术家的风格和技巧，创造出具有艺术价值的作品。然而，AI绘画也面临着一些挑战和限制，需要继续探索和解决。
推荐图书 《AI绘画实战：Midjourney从新手到高手》
当当链接：http://product.dangdang.com/29658182.html
京东链接：https://item.jd.com/13953813.html
一本书读懂AI绘画 Midjourney完全教程从关键提示到效果出图从基础理论到实战应用从工具操作到创意实现一本书轻松玩转AI绘画，领略无限艺术可能 关键点 从零开始：叙述清晰，简明扼要，从零开始手把手教你读懂Midjourney，玩转AI绘画，完成从新手入门到高手进阶。Midjourney全参数详解：浅显易懂解释参数逻辑，条理清晰，全面介绍影响绘画作品生成效果的参数，让提示词更简单易懂。精选海量设计案例：动物拟人化、头像设计、盲盒设计、icon设计、Logo 设计、壁纸设计、表情包制作、海报设计、人像摄影设计、商品包装设计、微缩景观设计、绘本设计……用丰富案例详细介绍应用AI绘画的方方面面。完整提示模板解析：解密生成高质量图像的关键词技巧，给出来直接可用的提示模板，让读者可以拿来就用，快速生成符合自己要求的图像大片。 内容简介 本书以目前AI领域中非常主流的绘画工具之一Midjourney为核心，介绍了Midjourney绘画的各种使用方法与技巧。 全书共7章，详细介绍了Midjourney的基础知识、指令、参数、进阶操作技巧，以及大量实操案例，从最基础的知识讲起，详细介绍Midjourney生成作品的全流程，能够为零基础的读者提供全面指 导，帮助他们快速掌握AI绘画技能；同时本书也适合具备一定绘画基础，希望进一步探索和应用AI技术的读者阅读。帮助读者快速上手Midjourney，掌握AI绘画的各种技能。 本书适合对AI绘画感兴趣的零基础读者，以及有一定AI绘画基础的读者阅读。
作者简介 李艮基（GenJi）2018年创立云顶作坊(后改名鲸海拾贝)，该项目与上海创新创意设计研究院联合成立DIIS X IceWhale数实创新实验室。8年设计和泛编程相关授课经验，B站设计区影响力NO.1账号主理人,微信公众号人工智能领域头部媒体，付费商业课程超20万人报名，职业技能课程垂直影响超5000万人。畅销书作者，主笔多本工具书及教材。
推荐理由 《AI绘画实战：Midjourney从新手到高手》是一本介绍AI绘画技术的实用书籍。本书通过深入浅出的方式，详细解读了人工智能绘画的原理、技巧和应用，并提供了一系列的实战案例和练习，帮助读者从新手逐步成为高手。
首先，本书对于AI绘画的原理和技术进行了系统的介绍。从机器学习和神经网络的基本原理出发，逐步介绍了AI绘画的工作流程和算法模型。通过对实际案例的分析和解读，读者能够深入理解AI绘画的原理和应用，建立起扎实的基础知识。
其次，本书提供了大量的实战案例和练习，帮助读者掌握AI绘画的实际操作技巧。通过跟随书中的练习，读者可以逐步学习如何使用AI绘画工具，调整参数和模型，进行绘画创作。每个案例都有详细的步骤和操作说明，读者可以边学边练，快速提升技能。
此外，本书还结合了一些实际应用场景，如人像绘画、风景绘画等，给出了一些实用的技巧和方法。读者可以通过学习这些案例，了解如何应用AI绘画技术进行具体的创作，提高作品的艺术价值和质量。
最后，本书还介绍了一些最新的AI绘画技术和趋势，帮助读者了解行业的最新发展和应用。随着人工智能技术的不断进步，AI绘画领域也在不断创新和演变。本书提供了一些前沿的案例和研究成果，读者可以了解到最新的技术趋势和创作思路。
总的来说，《AI绘画实战：Midjourney从新手到高手》是一本全面介绍AI绘画技术的实用书籍。通过理论介绍、案例分析和实战练习，读者可以系统地学习和掌握AI绘画的原理和技巧，从而成为一名高水平的AI绘画艺术家。由于书中内容详实，技巧实用，适合广大AI绘画爱好者和从业者阅读学习。
粉丝福利 现在 点赞收藏评论 “人生苦短，我爱绘画”评论区将随机抽取至多三名小伙伴免费赠书一本截止日期：2023年12月25日 写在后面 我是一只有趣的兔子，感谢你的喜欢！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d9bce8caccf2e7628fa99f652e7078b/" rel="bookmark">
			JSON解析错误:无法反序列化类型‘ java.lang ‘的值。字符串‘ from Array value (token ‘ JsonToken.START_ARRAY ‘)；mismatchedi
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错：JSON解析错误:无法反序列化类型' java.lang '的值。字符串' from Array value (token ' JsonToken.START_ARRAY ');mismatchedinputexception:无法反序列化类型' java.lang '的值。字符串'从数组值(令牌' JsonToken.START_ARRAY ')在[来源:(PushbackInputStream);(通过引用链:com.ruoyi.sangao. domain.resident.sysresidentcomplement ["targetList"]-&gt;java.uthil.hArrayList[0]-&gt;com.ruoyi.sangao. domain.residentreplenishdetail ["bqgScnr"])
这个错误的原因 是因为在json数据中，某个字段的值被解析成为数组，导致反序列化失败。解决这个问题的方法是将该字段的类型更改为数组类型，或者修改json数据 以确保该字段的值 是一个字符串而不是一个数组。
o oooo 原来是前端传错数据类型呢。注意跟前端对接数据............实体接参数 要跟前端传过来的数据一致
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5db9e928041065631a0110136eb73074/" rel="bookmark">
			pdf.js-canvas出现文字显示缺失问题处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		哈喽
兄弟们，又见面了，没错前两天才写了一个关于pdf.js的搜索功能使用。现在又遇见一个非常难以解决也是很令我头疼的bug，就是我文件预览的时候，部分文字字体缺失，这对于用户无疑来说是非常难受的，就类似如下。
问题已经找清楚了，话不多说，直接上代码
canvas.getContext('2d', { willReadFrequently: true }) 把预览的关于这个获取文本的方法中这样写入便可以了。最终效果如下：
这两个图片不一样是因为，第一个是半个月前给我提bug的图片，第二个是我刚刚解决的图片。代码很简单，方法要找对，祝各位码农在代码的道路上 少一点bug 多一点开心哦~
seegoodbye~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/607630eea78b16e52faa8e0ab488c55a/" rel="bookmark">
			mojo 新语言 入门体验 环境安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Set up on WindowsNATIVE SUPPORT IS COMING Mojo is not available for Windows yet, but you can use it on a Linux container or remote system. Here's one way you can do that with WSL:
Install VS Code, the WSL extension, and the Mojo extension.Install Ubuntu 22.04 for WSL and open it.In the Ubuntu terminal, install the Modular CLI: curl https://get.modular.com | \ MODULAR_AUTH=mut_5ce480349feb477ebca549faa143b98c \ sh - Command copied to clipboard
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/607630eea78b16e52faa8e0ab488c55a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fe5bf641d0a691a316395f66f6a9f0b/" rel="bookmark">
			Springboot集成Actuator和SpringbootAdminServer监控
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Springboot集成Actuator和SpringbootAdminServer监控 · 深入学习 · 看云
最近在学springclound，然后看书的时候，学习到通过actuator来监控springboot应用的各项指标。又因actuator只提供一组endpoints(restful接口），查看不直观，才有集成springboot admin server来通过界面查看监控。（当然还有其他的界面监控，比如很牛逼的普罗米修斯）
一、springboot actuator介绍 Spring Boot Actuator可以帮助你监控和管理Spring Boot应用，比如健康检查、审计、统计和HTTP追踪等。所有的这些特性可以通过JMX或者HTTP endpoints来获得。
Actuator同时还可以与外部应用监控系统整合，比如 Prometheus, Graphite, DataDog, Influx, Wavefront, New Relic等。这些系统提供了非常好的仪表盘、图标、分析和告警等功能，使得你可以通过统一的接口轻松的监控和管理你的应用。
示例：
http://localhost:9101/actuator/health
{ "status": "UP", "components": { "db": { "status": "UP", "details": { "database": "SQLite", "result": 1, "validationQuery": "SELECT 1" } }, "diskSpace": { "status": "UP", "details": { "total": 250790436864, "free": 64770326528, "threshold": 10485760 } }, "ping": { "status": "UP" }, "redis": { "status": "UP", "details": { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fe5bf641d0a691a316395f66f6a9f0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/217285b31eeef5429229f3798ece8c3e/" rel="bookmark">
			基于ssm电动车上牌管理系统的设计与实现论文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘 要 现代经济快节奏发展以及不断完善升级的信息化技术，让传统数据信息的管理升级为软件存储，归纳，集中处理数据信息的管理方式。本电动车上牌管理系统就是在这样的大环境下诞生，其可以帮助管理者在短时间内处理完毕庞大的数据信息，使用这种软件工具可以帮助管理人员提高事务处理效率，达到事半功倍的效果。此电动车上牌管理系统利用当下成熟完善的SSM框架，使用跨平台的可开发大型商业网站的Java语言，以及最受欢迎的RDBMS应用软件之一的Mysql数据库进行程序开发.电动车上牌管理系统的开发根据操作人员需要设计的界面简洁美观，在功能模块布局上跟同类型网站保持一致，程序在实现基本要求功能时，也为数据信息面临的安全问题提供了一些实用的解决方案。可以说该程序在帮助管理者高效率地处理工作事务的同时，也实现了数据信息的整体化，规范化与自动化。
关键词：电动车上牌管理系统；SSM框架；Mysql；自动化
Abstract
The fast-paced development of the modern economy and the continuous improvement and upgrading of information technology have allowed the management of traditional data information to be upgraded to software storage, induction, and centralized management of data information. This book lending system was born in such a large environment, which can help managers to process huge data information in a short time. Using this software tool can help managers improve transaction processing efficiency and achieve double the result with half the effort.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/217285b31eeef5429229f3798ece8c3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba2506cdf26d019454d4e8515826b1ea/" rel="bookmark">
			【js文件】谷歌地图 markerclusterer.js
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		谷歌地图,点聚合,所使用的js
function MarkerClusterer(map, opt_markers, opt_options) { this.extend(MarkerClusterer, google.maps.OverlayView); this.map_ = map; /** * @type {Array.&lt;google.maps.Marker&gt;} * @private */ this.markers_ = []; /** * @type {Array.&lt;Cluster&gt;} */ this.clusters_ = []; this.sizes = [53, 56, 66, 78, 90]; /** * @private */ this.styles_ = []; /** * @type {boolean} * @private */ this.ready_ = false; var options = opt_options || {}; /** * @type {number} * @private */ this.gridSize_ = options['gridSize'] || 60; /** * @private */ this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba2506cdf26d019454d4e8515826b1ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89d8627e291f65400ede3f269c100cb1/" rel="bookmark">
			Ubuntu基础操作和使用指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu基础操作和使用指南
Ubuntu是一款流行的开源操作系统，广泛应用于个人电脑、服务器和云计算环境。本文将介绍Ubuntu的基础操作和使用，帮助读者更好地使用这个操作系统。
1. 安装和设置
首先，你需要安装Ubuntu。你可以从Ubuntu官方网站下载ISO镜像文件，然后使用USB驱动器或光盘进行安装。在安装过程中，你需要选择语言、键盘布局、网络设置等。
安装完成后，你需要进行一些基本的设置。例如，设置用户、密码、时区等。你可以通过系统设置菜单进行这些操作。
2. 文件管理
Ubuntu使用Nautilus作为默认的文件管理器。你可以通过它来浏览和管理文件。你可以创建文件夹、重命名文件、删除文件等。
3. 软件安装
Ubuntu的软件包管理工具是apt。你可以使用它来安装、更新、升级和删除软件包。例如，要安装一个名为“example”的软件包，你可以运行以下命令：
sudo apt install example 4. 网络配置
Ubuntu默认使用DHCP来获取网络配置。如果你需要手动配置网络，你可以编辑/etc/network/interfaces文件。在这个文件中，你可以设置IP地址、子网掩码、网关等。
5. 终端使用
Ubuntu的终端是命令行界面，你可以使用它来执行各种命令。例如，你可以使用ls命令列出目录内容，使用cd命令改变当前目录，使用pwd命令显示当前路径等。
6. 系统监控和性能优化
Ubuntu提供了许多工具来监控系统和优化性能。例如，你可以使用top命令查看系统进程和资源使用情况，使用htop命令查看更详细的系统信息。你还可以使用sysstat工具来收集系统性能数据。
7. 用户管理
Ubuntu支持多用户登录和管理。你可以创建新的用户、修改用户信息、删除用户等。这些操作可以通过用户管理工具或命令行完成。
8. 软件更新和升级
Ubuntu定期发布新的版本和安全补丁。为了保持系统的安全性和稳定性，你应该定期更新和升级你的系统。你可以通过运行以下命令来更新你的系统：
sudo apt update &amp;&amp; sudo apt upgrade 9. 卸载和清理
如果你不再需要某个软件包或驱动程序，你可以使用apt来卸载它们。例如，要卸载一个名为“example”的软件包，你可以运行以下命令：
sudo apt remove example 如果你需要清理硬盘空间或删除不需要的文件，你可以使用apt clean命令来清理已下载的软件包文件。你还可以使用apt autoremove命令来删除不再需要的自动安装的软件包。
总之，Ubuntu是一个功能强大且易于使用的操作系统。通过掌握这些基础操作和使用技巧，你可以更好地利用Ubuntu来提高你的工作效率和生活质量。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cfcbf4e3748d2491acc9bcb262e0cf9/" rel="bookmark">
			WebGL开发虚拟旅游应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WebGL可以用于开发虚拟旅游应用，提供用户在浏览器中探索虚拟景点和环境的交互体验。以下是在WebGL中开发虚拟旅游应用的一般流程，希望对大家有所帮助。北京木奇移动技术有限公司，专业的软件外包开发公司，欢迎交流合作。
1.需求分析： 确定虚拟旅游应用的具体需求，包括选择的旅游目的地、交互元素（例如导航、信息展示）、用户体验等。
2.选择WebGL框架： 选择适合的WebGL框架，如Three.js、Babylon.js等，以简化3D图形渲染和交互的开发过程。
3.场景设计： 创建虚拟旅游场景，包括地形、建筑、景点等。使用3D建模工具或者导入已有的虚拟场景模型。
4.导航系统： 实现用户在虚拟环境中的导航系统，例如点击或拖拽控制视角、路径导航、虚拟现实（VR）支持等。
5.信息展示： 将有关景点的信息集成到应用程序中，例如历史背景、地理信息、文化解说等。这可以通过标签、信息卡片、语音导览等方式呈现。
6.虚拟现实（VR）支持： 如果需要，可以集成虚拟现实技术，以提供更沉浸式的虚拟旅游体验。WebVR或WebXR API可用于实现这一点。
7.用户交互： 添加用户交互功能，例如点击景点获取详细信息、分享到社交媒体、标记喜欢的景点等。确保用户能够方便地进行虚拟旅游体验。
8.实时性能优化： 考虑虚拟旅游应用可能需要处理大量的3D模型和纹理，因此性能优化是重要的。使用合适的技术，如LOD、纹理压缩等，以确保应用在各种设备上都能够流畅运行。
9.安全性考虑： 考虑应用程序的安全性，特别是当用户在虚拟旅游中提供个人信息时。采取适当的安全措施，保护用户数据的隐私和安全。
10.测试和验证： 在不同浏览器和设备上测试虚拟旅游应用，确保其在各种环境下都能够稳定运行。验证虚拟旅游体验的质量和流畅度。
11.部署： 部署应用程序到您选择的Web服务器或云服务上，以便用户可以访问和体验虚拟旅游。
12.维护和更新： 定期检查并更新应用程序，确保其与最新的WebGL框架和浏览器兼容，并根据用户反馈进行必要的维护。
虚拟旅游应用的开发可以结合多媒体元素、地理信息系统（GIS）、虚拟现实技术等，以提供富有创意和吸引力的体验。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56fb72f7e011caea7a438f47897df017/" rel="bookmark">
			centos定时备份数据库任务crontab
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		crontab 使用 1、安装 crontab 一般 CentOS 会默认安装了 crontab，执行下面命令，查看是否安装：
rpm -qa | grep crontab 如果查询结果类似于下面，说明已安装：
crontabs-1.11-6.20121102git.el7.noarch 如果结果为空，说明没有安装，执行下面命令进行安装即可：
yum install -y crontabs 2、crontab 常用命令 查看 crontab 运行状态：
systemctl status crond 如果显示结果为 Active: active (running) 则表示运行中，Active: inactive (dead) 表示未运行。
如果 crontab 未运行，可以通过下面命令设置开机自启和启动。
设置 crontab 开机自启：
systemctl enable crond 启动 crontab：
systemctl start crond 查看当前用户的定时任务：
crontab -l 3、设置定时任务 这里我们以一个「每日定时备份mysql数据库」任务为例，说明设置定时任务的步骤。
首先，创建一个脚本 test.sh：
vim /root/test.sh 按 i 进入编辑状态，粘贴下面内容：
#!/bin/bash TIMESTAMP=`date +%Y%m%d%H%M%S` BACKUP_DIR="备份存储路径" DB_USER="root" DB_PASS="xxxxxxxxxxxx" # 使用 mysqldump 命令备份数据库 mysqldump -u $DB_USER -p$DB_PASS 数据库名 &gt; $BACKUP_DIR/mysql_数据库名_$TIMESTAMP.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56fb72f7e011caea7a438f47897df017/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a5896168174e835015cdbfed4fa2c4c/" rel="bookmark">
			WebGL开发医学图像应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WebGL可以用于开发医学图像处理应用，帮助医学专业人员更好地理解和分析医学图像。以下是在WebGL中开发医学图像处理应用的一般流程，希望对大家有所帮助。北京木奇移动技术有限公司，专业的软件外包开发公司，欢迎交流合作。
需求分析： 定义医学图像处理应用的具体需求，包括要处理的图像类型（CT扫描、MRI图像等）、功能要求（分割、重建、可视化等）以及用户交互需求。选择WebGL框架： 选择适合的WebGL框架，如Three.js、Babylon.js等，以简化3D图形渲染和交互的开发过程。图像数据加载： 开发用于加载和解析医学图像数据的模块。医学图像通常以DICOM格式存储，您可能需要使用相应的JavaScript库来解析DICOM文件。体积渲染： 利用WebGL进行体积渲染，使医学图像以三维形式呈现。这允许用户从不同角度查看图像，提高对图像结构的理解。图像处理算法： 实现医学图像处理算法，例如图像分割、特征提取、三维重建等。确保这些算法在WebGL环境下能够高效运行。用户交互： 添加用户交互功能，例如放大、缩小、旋转、标记关键区域等。用户应能够通过直观的方式与医学图像进行交互。虚拟现实（VR）支持： 如果需要，集成虚拟现实技术，以提供更沉浸式的医学图像浏览体验。WebVR或WebXR API可用于实现这一点。实时性能优化： 医学图像处理可能涉及大量数据，因此性能优化至关重要。使用合适的数据结构、纹理压缩、LOD（层次细节）等技术来确保应用在各种设备上都能够流畅运行。安全性考虑： 考虑应用程序的安全性，尤其是涉及到敏感的医学数据时。确保采取适当的安全措施，例如使用HTTPS来保护数据传输。测试和验证： 在不同浏览器和设备上测试应用程序，确保其在不同环境下都能够稳定运行。验证医学图像处理的准确性和可行性。部署： 部署应用程序到您选择的Web服务器或云服务上，以便医学专业人员可以访问和使用。维护和更新： 定期检查并更新应用程序，确保其与最新的WebGL框架和浏览器兼容，并根据用户反馈进行必要的维护。 在医学图像处理应用的开发中，对医学数据的保密性和合规性非常重要，因此确保符合相关的法规和标准是必不可少的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac9190c9dc98919141a2625acead312d/" rel="bookmark">
			Vue2（八）TodoList案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、整体思路1.分析结构2.拆html和css3.[初始化列表](https://so.csdn.net/so/search?q=初始化列表&amp;spm=1001.2101.3001.7020)4.实现添加列表功能5.实现勾选功能6.实现删除功能7.实现底部统计功能8.实现全选框的交互（1）每个todo控制全选框（2）全选框控制todo全选或者取消全选：使用点击事件实现。（3）全选框控制todo全选或者取消全选：使用v-model实现。 9.点击右下角按钮删除全部已完成任务 二、代码文件总览1.App.vue2.MyHeader.vue3.MyList.vue4.MyItem.vue5.MyFooter.vue 三、总结1.组件化编码流程：2.props适用于：3.使用v-model时要切记4.关于props 一、整体思路 1.分析结构 确定组件名称（Header,List,Item,Footer）和个数，还有嵌套关系(List里面包含Iterm，List和Hello\Footer为兄弟组件)，然后引入相应的组件
2.拆html和css 分别放到对应的组件里面，style标签中加上scoped属性（保证当前样式只在当前组件中使用，防止样式名字不能重复使用）
3.初始化列表 在List中定义一个数组todos存储每个item为对象，然后在List的标签中写&lt;Item&gt;&lt;/Item&gt;并用v-for遍历数组中的每个对象生成结构，且通过自定义属性todo把每个对象传给子组件Item。
&lt;MyItem v-for="todoObj in todos" :key="todoObj.id" :todo="todoObj"&gt;&lt;/MyItem&gt; 在Item中使用props配置项接收（实现父子组件通信），然后input框里的checked绑定todo.done（这挺巧妙，可以初始化页面）。
4.实现添加列表功能 上一步我们是在List中定义了todos数组，而用户的输入是在Header中，也就是说我们要在Header中收集数据，然后传给List，但是兄弟组件如何通信？全局事件总线、消息订阅与发布、Vuex都可以，但是现在还没学。
之前我们学的props配置项，可以实现父组件给子组件传数据（父组件里写子组件标签并配置属性，子组件使用props接收），现在我们想实现兄弟组件Header和List的通信，可以借助App这个父亲。
（1）把List中的数据todos定义在App里，然后传给List一份（通过props接收，由于是直接传到vc上，模板不会报错）。
（2）在App组件中定义一个函数，函数里面写个参数
addTodo(x) { //借助这个函数，拿到Header中用户输入的东西 this.todos.unshift(x); } （3）把这个函数传给Header，Header用props接收一下，然后在Header中调用这个函数，把用户的输入传给这个函数
const todoObj = { id: nanoid(), title: this.title, done: false }; this.addTodo(todoObj); （4）由于addTodo是定义在App上的，所以App就直接拿到了函数的参数，然后就可以直接添加在todos中，这样的话todos改变，模板重新解析，传给List的todos也改变，List模板重新解析，v-for一遍历，页面就多了一个。tmd这啥玩意儿这都是
5.实现勾选功能 选中：done=true，不选中：done=false。思路：简单来说就是让App拿到要修改的数据的id，找到这个数据然后把done属性取反。
我们先在App组件里定义一个函数，用来接收当前操作对象的id，然后函数里的逻辑是找到这个id，然后done属性取反（记住,数据源在哪里,修改数据的方法就配置在哪里）
changeTodo(id) { this.todos.forEach((todo) =&gt; { if (todo.id === id) todo.done = !todo.done; }) } 然后把changeTodo这个函数通过标签和props传给List，再传给Item
然后在Item组件里定义一个函数handleChange，用来获取当前操作的多选框的id
handleChange(id) { // 不能像下面这样直接修改props的数据,数据源在哪里,我们就去哪里改 // 如下代码也能实现功能,但是不建议这么写,理由就是不能直接改props传来的东西 // this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac9190c9dc98919141a2625acead312d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c996ea95e89165d6938015f8acd23fd0/" rel="bookmark">
			解决方案：aarch64 ARM架构下安装Miniconda &#43; 离线迁移Conda环境的全流程 踩坑避坑指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、安装Miniconda1.1、确认本机架构1.2、下载Miniconda安装包1.3、安装Miniconda 二、离线配置Conda环境2.1、查看本机配置2.2、迁移虚拟环境2.3、可能遇见的报错 最后 在ARM架构下，由于Anaconda并不提供官方的ARM版本，在很多情况下强行在ARM系统中安装Anaconda会出现很多未知错误。因此更适合安装Miniconda。Miniconda是Anaconda的一个精简版本，它只包含conda包管理器和最基本的库，因此在资源受限的环境下更加适用。
本博客记录在华为多瑙 HPC集群的服务器下离线安装Miniconda和迁移虚拟环境的全过程。
一、安装Miniconda 1.1、确认本机架构 在安装前需要查看本机的系统架构，确认机器为ARM架构，输入指令：uname -m，如果返回结果为aarch64：
aarch64表示系统的 CPU 架构是 ARM 64 位架构（ARMv8-a），表明本机无法使用传统的 x86 架构的软件，所以建议不安装Anaconda，而是Miniconda。
1.2、下载Miniconda安装包 进入Miniconda下载官网：https://conda.io/en/latest/miniconda.html
可以看到Miniconda为我们提供了多种配置的安装包，包括Windows、macOS的x86，M1芯片，Linux的aarch64、ppc64le、s390x等多种架构。
根据机器的架构，点击对应的安装包进行下载，下载后是一个Miniconda3-latest-Linux-aarch64.sh文件，放置到服务器上。
1.3、安装Miniconda cd到对应目录，bash启动刚刚的sh文件，这里使用终端输入：bash Miniconda3-latest-Linux-aarch64.sh
进入安装程序后，会返回用户协议，一直enter到最后，输入yes同意协议：
然后会弹出一个询问您是否希望更新您的shell配置文件（例如.bashrc或.zshrc），以便在启动时自动激活Conda环境，并在激活时更改命令提示符
如果您选择“yes”，则Conda将被初始化为在每次启动时都自动激活基础环境（默认情况下为“base”环境），并且在激活时会显示Conda环境的名称。
如果您选择“no”，则不会在启动时自动激活基础环境，您可以在需要时手动使用conda activate 激活环境。
这里可以随意选择，我这里选择yes，然后应该就安装成功了！
【重要】：安装成功后，需要重启终端，重新进入才能正式使用conda，验证conda是否安装成功可以使用conda --version命令，输出版本号即为成功：
二、离线配置Conda环境 2.1、查看本机配置 输出nvida-smi查看本机CUDA版本这里是12.3
所以必须要找一个基本架构类似的新机器安装ARM和CUDA12.3下的环境；
要注意的是，ARM架构下的PyTorch安装比较麻烦，目前提供的镜像源均为cpu版本，得通过编译安装才能安装GPU版本
安装好后对虚拟环境使用进行conda-pack 进行conda 环境打包，打包流程可以看：解决方案：查看机器配置+如何迁移虚拟环境到离线机器
2.2、迁移虚拟环境 打包好后会得到一个 xx.tar.gz的文件，将该.tar.gz压缩包通过mobaxterm或者其他方式把 xx.tar.gz上传到目标服务器的miniconda里的envs/环境名目录里面，一般路径为用户名/miniconda3/envs/自己新建的环境名
上传成功后，在目标服务器（离线的那个）上解压压缩包：tar -xzf xx.tar.gz，解压成功后，在目标服务器上查看虚拟环境：conda info --envs，显示如下，即表示迁移成功了。
2.3、可能遇见的报错 在跑程序的时候如果出现：cannot execute binary file: Exec format error这种错误，说明你正在尝试运行一个不同体系结构的可执行文件，或者文件本身可能已经损坏。极有可能的问题原因就是：你正在ARM架构下运行x86架构的编译！
这说明你的虚拟环境还是不太对，所有环境一定要是ARM架构下的才行，特别是PyTorch系列产品，要安装对应架构的才能避免这个报错。
最后 💖 个人简介：人工智能领域研究生，目前主攻文本生成图像（text to image）方向
📝 个人主页：中杯可乐多加冰
🔥 限时免费订阅：文本生成图像T2I专栏
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c996ea95e89165d6938015f8acd23fd0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a07a1c593224d03fa34616b0a602290/" rel="bookmark">
			WebGL开发的应用程序类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WebGL是一种用于在Web浏览器中进行高性能图形渲染的JavaScript API，它主要用于创建交互式的3D图形和图像。通过WebGL，您可以开发多种类型的Web应用程序，包括但不限于以下几种，希望对大家有所帮助。北京木奇移动技术有限公司，专业的软件外包开发公司，欢迎交流合作。
1.3D可视化应用： WebGL最常见的用途之一是创建令人印象深刻的3D可视化应用。这包括3D模型浏览器、虚拟现实（VR）和增强现实（AR）应用，以及其他需要高性能图形渲染的应用。
2.游戏： WebGL为开发基于Web的游戏提供了强大的工具。使用WebGL框架（如Three.js、Babylon.js），您可以在浏览器中创建高质量的游戏，而无需用户安装任何插件。
3.数据可视化： 对于需要展示大量数据并进行交互的应用程序，WebGL提供了强大的能力。您可以创建实时图表、地图、仪表板等，用于展示和分析数据。
4.图形编辑器和设计工具： 利用WebGL创建在线图形编辑器或设计工具，使用户能够实时绘制、编辑和处理图形元素。
5.科学和教育应用： WebGL可用于创建交互式的科学模拟、实验和教育应用。这包括分子模型、行星系统模拟、物理学模拟等。
6.虚拟旅游和地理信息系统（GIS）： 利用WebGL可以创建虚拟旅游应用，允许用户在浏览器中探索虚拟城市、景点和地理环境。GIS应用也可以通过WebGL进行地图可视化。
7.工程和建筑可视化： 在建筑和工程领域，WebGL可用于创建实时的建筑可视化和工程模型，方便设计师、工程师和客户进行沟通和协作。
8.医学图像处理： 用于显示和处理医学图像，例如CT扫描、MRI图像等。这有助于医学专业人员更好地理解和分析医学图像。
9.音视频处理： WebGL可以用于音视频处理应用，例如音频可视化、视频编辑器等，通过图形硬件加速提高性能。
10.艺术和创意应用： 创建艺术作品、交互式演示或其他创意性的应用程序，通过WebGL可以实现更丰富的视觉效果。
需要注意的是，虽然WebGL提供了强大的图形渲染能力，但某些复杂和计算密集型的应用可能需要进一步的性能优化和硬件要求。在选择WebGL作为开发工具时，务必评估项目的具体需求和性能要求。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3de967414e7b861a4e36a268d91a35cd/" rel="bookmark">
			uniapp自定义tabBar以及页面刷新渲染
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		uniapp自定义tabBar_uniapp自定义底部tabbar-CSDN博客
上文链接 一、pages.json文件中添加tarBar中还需要添加"custom": true 自定义
uni-app 小程序页面重新渲染，强制更新_uniapp重新渲染页面-CSDN博客
我是用第三种方法解决的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af6227d981709aa948437d0522c5594c/" rel="bookmark">
			故障排除: Vcenter Root user password expires in 0 days.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		故障排除: Vcenter Root user password expires in 0 days. 1. 故障现象 登录Vsphere Client显示报错信息如下:
Vcenter Root user password expires in 0 days. 2. 故障排除 2.1 打开Vcenter ssh 访问VMware vCenter Server 管理,即5480端口,比如VMware® vSphere地址是https://192.168.31.200那么管理页地址就是https://192.168.31.200:5480/
使用administrator@vsphere.local账户登录依次点击访问,编辑
打开ssh登录,后点确认.
如果有报错可以忽略.只要保证看到"SSH 登录"是"已启用"的即可 2.2 重置密码 使用root用户SSH登录Vcenter
新旧密码不能相同,且有复杂度要求具体看之前配置反正新密码别太短,一会会改回老密码
进入shell模式
如上图,直接输入shell回车修改密码
这里我们先可以看下过期时间
这里-后面为小写字母L chage -l root 先去除密码过期
这里2个-后面为数字1
chage -M -1 -E -1 root # 再看下过期时间 chage -l root 此时已经永不过期了
4. 将密码改回原密码(选做)
如果想使用新密码那么到此就基本结束了,最后登录下管理页看看是否正常就可以了.
如果想改回老密码
mv /etc/security/opasswd{,.bak} passwd 3. 确认故障排除 使用root用户登录"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af6227d981709aa948437d0522c5594c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27f8b38a4ce2caf775b6d94e83484bf4/" rel="bookmark">
			unity3d 开发笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		unity Unity是一个游戏引擎(类似于软件开发的框架)，它包含渲染引擎，物理引擎，碰撞检测，音效，动画效果，场景管理等功能，可以开发2d游戏，一般是用来开发3d游戏。它的开发效率高、脚本使用C#开发、简单易用、跨平台（可以导出各个平台的程序）。当然还有别的游戏引擎比如虚幻引擎俗称UE (Unreal Engine），使用C++开发脚本，3A大作首选，好多游戏公司都有自己的游戏引擎，下边放一个Unity软件的大图。本人感觉，这个软件还是比较好学习的，比单纯的软件开发有意思的多。
介绍 project面板放游戏资源，hierarcy放游戏对象，inspector显示当前游戏对象和属性信息component组件代表游戏对象的某个功能，所有游戏对象都有transform组件目录下的Assets是最重要的，别的可以不要直接安装unity就可以，也可以不用安装 unity hub（此软件用来管理多个unity editor）ProjectSettings\ProjectVersion.txt 查看项目的unity版本unity package file， unity可以直接导入，类似zip文件，可以右键export package生成，主要使用的unity版本尽量一致 操作 最右上角，面板 layout，选择 2 by 3project面板 右键 one column layoutQ + 鼠标左键（按鼠标滚轮），可以移动scenealt + 右键，缩放视图alt + 左（同只按右键），旋转视图右键 + w a s d q e，场景漫游(不同方向)选择物体，然后按F，视图以物体为中心来居中，或者在hierarcy双击游戏对象也可以选择游戏对象，ctrl + d 可以快速复制一个z轴是正对人的放心，x轴是水平方向，y轴是垂直方向游戏运行时改的值，可以copy component，然后结束调试paste值即可。 视图模式 视图有两种模式，ISO正交模式（2d效果）和 Pers透视模式（近大远小效果）。
坐标系 世界坐标，全局不变的坐标（只有唯一的原点）本地坐标，物体自身坐标，随着旋转而变化
unit使用左手坐标系（左手做成数字8，中指指向自己即可）
场景 场景 scene，是相关联的一组游戏对象的集合，比如一个地图或者游戏的某一关，在scenes文件下，后缀名是 .unity 双击此文件可打开项目。新建的游戏对象，默认在当前视图的场景中间。场景默认自带Main Camera，和Directional Light两个东西。
GameObject 游戏对象，hierachy中的每个对象都是GameObject的子类，都有transform属性。Plane只有正面没有反面，quad相似，只不过是竖着的。任何物体都是三角形拼出来的。
PreFab 预制件 如果在Hierachy面板中，要把一个游戏对象变成模板，直接拖到 Project面板即可，修改PreFab的属性就会影响所有的游戏对象。如果要批量创建模型，最好放到预制件里。
复制参数 如图，如果要复制这些参数给别的组件使用，可以点这里，选择 copy componnet，
然后在新的组件再点这里，选择 Paste Component Values。
保存参数 比如，如果要保存这个transform的参数，给别的项目使用或者给别的组价使用，可以点这里
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27f8b38a4ce2caf775b6d94e83484bf4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a96dd7e513f97de9ae0e023823fb7cf4/" rel="bookmark">
			深度学习常用数学知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 向量的内积 a · bHadamard积 a ⊙ b范数常用范数求导 向量的内积 a · b 向量的内积也称为点积，用来计算两个向量之间的相似度。在数学上，两个向量的内积等于将一个向量投影到另一个向量上得到的长度再乘以两个向量之间的夹角的余弦值。
使用PyTorch进行向量的内积计算非常简单，可以通过torch.dot()函数实现。以下是一个示例代码，计算两个向量的内积：
import torch # 定义两个向量 a = torch.tensor([1, 2, 3]) b = torch.tensor([4, 5, 6]) # 计算内积 dot_product = torch.dot(a, b) # 输出结果 print(dot_product) 运行以上代码，将会输出内积的结果，即32。
注意，向量的内积要求两个向量的维度相同，否则将会报错。 两个向量a和b的内积可以通过以下数学表达式来表示：
a · b = ||a|| · ||b|| cosθ
其中，
a · b 表示向量a和向量b的内积（点积），||a|| 表示向量a的模长（或范数），||b|| 表示向量b的模长（或范数），cosθ 表示向量a和向量b之间的夹角的余弦值。 注意，此表达式适用于二维和三维空间中的向量，对于更高维度的向量同样适用。
另外，如果两个向量a和b是n维向量，可以表示为：
a = [a1, a2, …, an]
b = [b1, b2, …, bn]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a96dd7e513f97de9ae0e023823fb7cf4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4625d0f4602032cf6936464d6d4a17bd/" rel="bookmark">
			ubantu22版本配置静态IP地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 编辑网络配置文件应用网络配置查看网络配置结果 编辑网络配置文件 在Ubuntu中配置静态IP地址可以通过以下步骤实现：
打开终端，使用以下命令编辑网络配置文件 /etc/netplan/00-installer-config.yaml，该文件用于配置网络接口的设置。建议使用root用户或具有sudo权限的用户进行操作。
gsl@gslserver:~$ su - Password: root@gslserver:~# cd /etc/netplan/ root@gslserver:/etc/netplan# ls 00-installer-config.yaml root@gslserver:/etc/netplan# vi 00-installer-config.yaml root@gslserver:/etc/netplan# 输入一下内容：
network: version: 2 renderer: networkd ethernets: eth0: dhcp4: no addresses: - 192.168.1.10/24 routes: - to: 0.0.0.0/0 via: 192.168.1.1 metric: 100 nameservers: addresses: - 8.8.8.8 - 8.8.4.4 应用网络配置 sudo netplan apply 查看网络配置结果 ip add 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20ca3c6befa5cd0a381ea1631319f74d/" rel="bookmark">
			C&#43;&#43;初阶 | [八] (上) vector
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要：vector函数介绍，【例题】杨辉三角
前面已经较为详细的介绍了标准库的string类，这里 vector 的函数接口在使用上和 string类 大差不差，所以对 vector 的介绍不多赘述，仅对一些需要注意的地方做出提示。
#include&lt;vecotr&gt;
1.Constructor 1）default：std::vector&lt;int&gt; v1;
2）fill：std::vector&lt;int&gt; v2(10, 0);
3）range：(iterator) 关键是类型匹配
std::vector&lt;int&gt; v3(v2.begin(), v2.end());
std::string s("xxxxxxxxx");
std::vector&lt;int&gt; v4(s.begin(), s.end());//可以这样构造，此处会发生隐式类型转换
4）copy：std::vector&lt;int&gt; v5(v4);
2.Access 1）常用 [下标] 的方式访问
2）通用 iterator
3.Capacity 1）扩容机制：vs一般1.5倍扩容；g++一般2倍扩容
2）max_size：依据平台写死，是一个固定的数值，不同平台的数值不同
3）reserve：只 改变 capacity （易错！！）—— 开空间也不一定能访问！还取决于 size 的大小！
4.insert 如果我们要在 vector对象 中某个数据的前面插入数据，一般遵循如下步骤：
⑴首先我们要找到这个数据：(#include&lt;algorithm&gt;)std::find( 开始的查找的位置 , 结束查找的位置 , 需要倍找到的数据 )
ps.string类中有自己需求，而这个 std::find 不能满足需求，所以string类有自己的 find函数。
⑵对 find 到的结果的这个位置插入数据
5.没有流插入和流提取重载 因为没有必要提供统一的打印方式，用 iterator 遍历 按自己的需求 打印即可。
以上，对 vector 的介绍仅到此为止。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20ca3c6befa5cd0a381ea1631319f74d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eaa6e4bb8126adbfc7ee4402c56eb8bb/" rel="bookmark">
			注册CSDN应该有20年了吧！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我注册这玩意应该有20年了！
CSDN也真是寿命很长的网站啊！天涯都不行了，当年记得是玩一塌糊涂时，一起注册的CSDN，估计没人知道一塌糊涂是什么了吧！
论坛真的很互联网，当年各种论坛盛行，人们玩的是不亦乐乎，还有各种搭建论坛的工具，记得Discuz非常有名气，老板叫戴什么。
我当年还帮同宿舍一个哥们，搭建了一个求偶网站。好吧，这么说有点太对不起他了。我网站搭建的还是挺好的，可惜求偶失败。照片，文字，页面跳转，还有不知道从哪里搜集来的各种Javascript，弄的界面上blingbling的，很土很炫技。还找了一个免费的网页空间服务器，算上国际互联网上挂号了，结果，失败了，当然觉得很可惜，也很幸灾乐祸。
CSDN做的挺好的，很佩服，很了不起，干了一件了不起的事。
包括InsCode，我是今天才体验这个东西，在线编辑，部署，发布，挺好的。
最近很想把程序猿这个身份，再续一下前缘。当然，我那时“员”还是不是“猿”，更接近“元”。
我不是科班出身，但是真的挺喜欢摆弄这些东西的，网名giszz，是当初最早一波学GIS的，我本科毕业设计是用VB绘制等高线，后来读研时，去了某大厂，绝对大厂，学的JAVA，每天写各种EJB，我于是成为同学中少有的能写CS还能写BS的，当然没啥场景，让我发挥。
哦，个人兴趣也写过一个BS和CS结合的项目，我给一个老师写的桌面端小工具，监控股票价格的。抓一个网站的股票价格变化数据，分析页面标签，取价格，送到小工具上，可以设置各种报警阈值，一键隐藏（老板键哈哈），价格预警了弹出。后来听说老师投影做项目汇报时，工具弹出来了……当时没有赚钱的心眼，其实很多人应该需要这个东西，那时网页还比较傻白甜，没什么安全机制。
再后来，就和很多人一样，搞着搞着，莫名其妙就各种经理了，技术再也不会了。
不知道为啥，忽然想写点东西，那就看能写多久。
从新学习“技术”，记录一下，无他，就是觉得自己还是个搞技术的。
2023-12-14 补记录 还记得当初自己为什么选择计算机？-CSDN博客
没想到，这篇文章，严重影响了我的平均质量分啊！
文字的数量，和质量息息相关，我也承认，但是可以看到，很多文章在凑字数。不过，没有办法，一个政策，没有绝对的好，绝对的差，都是要看是否因地制宜，因时制宜。
转眼粉丝就要过1000了，感谢CSDN平台的新人扶持，虽然我是个很老的用户了，但是居然能得到新手扶持，还是很开心。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50261018a5545b559a7bd0645b3db7d5/" rel="bookmark">
			〖大前端 - 基础入门三大核心之JS篇(57)〗- 继承
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明：该文属于 大前端全栈架构白宝书专栏，目前阶段免费，如需要项目实战或者是体系化资源，文末名片加V！作者：哈哥撩编程，十余年工作经验, 从事过全栈研发、产品经理等工作，目前在公司担任研发部门CTO。荣誉：2022年度博客之星Top4、2023年度超级个体得主、谷歌与亚马逊开发者大会特约speaker、全栈领域优质创作者。 🏆 白宝书系列 🏅 启示录 - 攻城狮的自我修养🏅 Python全栈白宝书🏅 ChatGPT实践指南白宝书🏅 产品思维训练白宝书🏅 全域运营实战白宝书🏅 大前端全栈架构白宝书 文章目录 ⭐ 继承🌟 什么是继承🌟 通过原型链实现继承🌟 借助构造函数🌟 组合继承🌟 原型式继承🌟 寄生式继承🌟 寄生组合式继承 ⭐ 继承 在JavaScript中，继承是一种允许我们创建一个类（子类）从已有的类（父类）上继承所有的属性和方法的机制。这样的机制有助于我们复用和重用代码。
JavaScript原型链实现了继承。每一个对象都有一个内部属性[[prototype]]，这个属性是一个链接/link（也就是一个指针），它指向了创建这个对象的函数的原型对象prototype。其实这就是“原型链”的起点，通过这个链子对象可以访问到父对象的属性。
在ES6之后，JavaScript又引入了基于类的继承，这种继承方式更接近于传统的面向对象语言，如Java，C++等。虽然JavaScript是基于原型的语言，但是为了更好地与其他面向对象编程语言交流和学习，ES6引入了class和extends关键字来实现基于类的继承。
但是无论是原型链继承还是ES6的类继承，其本质上都是原型继承，只是类继承更易于理解和使用。
🌟 什么是继承 先来看两个无关的类：People和Vehicle，这两个类分别描述人类和机动车。People类含有的属性有：name(姓名)、age(年龄)、sex(性别)，方法有：sayHello(打招呼)、sleep(睡觉)；Vehicle类含有的属性有：brand(品牌)、color(颜色)、engineType(发动机型号)、seatingCapacity(座位容量)，方法有：move(移动)、whistle(鸣笛)；可以看出他们的属性和方法几乎没有重复和相关的，所以他们是两个无关的类：
（上面两个图形是来源于UML的类的图形化表示法。UML，是一种统一建模语言，我们作为开发者能看懂图就可以了，不需要深入的了解UML的具体使用方式）
再来看两个有关的类：People和Student，这两个类分别描述人类和学生。Student类含有的属性有：name(姓名)、age(年龄)、sex(性别)、studentNumber(学号)、school(学校)，方法有：sayHello(打招呼)、sleep(睡觉)、study(学习)、exam(考试)。
我们可以发现：
People类拥有的属性和方法Student类都有，并且Student类还扩展了一些属性和方法Student是一种People，两类之间是“is a kind of”关系 这就是**“继承”**关系：Student类继承自People类
People是**“父类”（或“超类”、“基类”）；Student是“子类”**（或”派生类“）
子类丰富了父类，让类描述的更具体，更细化
在UML中，用空心的箭头来描述继承关系，箭头指向父类：
更多继承关系的举例：
父类子类PeopleStudent、TeacherVehicle（机动车）Car（小轿车）、Truck（卡车）、Motocycle（摩托车）Applicance（家用电器）Television（电视）、Refrigerator（冰箱）Publication（出版物）Book（书籍）、Magazine（杂志） 往往一个类只是一个继承”链“中的一环，比如子类也可以有自己的子类，父类也会有自己的父类。所以面向对象方法实际上是模仿了自然界中描述自然事物的方法，这样就使面向对象的编程方式非常容易被理解。
JavaScript 中如何实现继承？
实现继承的关键在于：子类必须拥有父类的全部属性和方法，同时子类还应该能定义自己特有的属性和方法
使用JavaScript特有的原型链特性来实现继承，是普遍的做法
🌟 通过原型链实现继承 首先定义一个构造函数Peolpe，我们可以在People.prototype上定义一些人类的方法（比如sayHello()、sleep()等）然后new出来一个People的实例。然后让Student构造函数的prototype直接指向People的实例（关键步骤），我们把study()方法，和exam()方法直接定义到People的实例上。这样的巧妙之处在于如果我们new出来一个student（如Hanmeimei），就可以行成了一个原型链，Hanmeimei可以调用study()和exam()方法，也可以调用sayHello()和sleep()方法。
下面来敲一些这个demo:
// 父类 function People(name, age, sex) { this.name = name; this.age = age; this.sex = sex; } People.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50261018a5545b559a7bd0645b3db7d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f100590bb76ae4500d2c9934308295d/" rel="bookmark">
			第一章 初识Android开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发Android应用程序 1.Android项目结构分析 .gradle和.idea
这两个目录无须关心，这是Android Studio自动生成的文件，开发者不要手动更改这些文件。
.app
项目中的代码和资源等内容几乎都是放在这个目录下的，在实际编写代码时也都是在这个目录下进行的，随后将会单独对这个目录进行详细讲解。
build
此目录也不必关心，里面主要放置一些编译时生成的文件，开发者也不要手动去更改该目录下的文件。
.gradle
这个目录下包含了gradle wrapper的配置文件，使用gradle wrapper的方式不需要提前将gradle下载好，而是会自动根据本地的缓存情况决定是否需要联网下载gradle。若需要打开，可以通过Android Studio导航栏-&gt;File-&gt;Settings,如下图所示。
.gitignore
此文件用来指定的目录和文件排除在版本控制之外，关于版本控制会在之后的目录中介绍。
build.gradle
这是项目全局的gradle构建脚本，一般此文件中的内容是不需要修改的。稍后详细分析gradle脚本中的内容。
gradle.rpoperties
这个文件是全局的gradle配置文件，在这里配置的属性将会影响到全局的项目中所有的gradle编译脚本。
.gradlew和gradlew.bat
这两个文件是用来在命令行界面中执行gradle命令的，其中gradlew是在Linux或Mac系统中使用的，gradlew.bat是在Windows系统中使用的。
MyFirstAPP.iml
.iml文件是所有IntelliJ IDEA项目中都会自动生成的一个文件（Android Studio是基于IntelliJ IDEA开发的），开发者也不用修改这个文件职工的任何内容。
local.properties
这个文件用于指定本机中的Android SDK路径，通常内容都是自动生成的，并不需要修改。除非用户计算机上的SDK位置发生变化，这是将这个文件中的路径改成新的路径即可。
.settings.gradle
这个文件用于指定项目中所引用的模块。由于MyFirstApp项目中只有一个app模块，因此该文件就引入了app这一模块。通常情况下模块的引入都是自动完成的，需要手动修改这个文件的场景较少，但是要知道这个文件的作用，避免以后开发中遇到此种情况。
至此，整个项目的外层目录介绍完毕。除了app目录之外，绝大多数的文件和目录都是自动生成的，开发者并不需要修改。而app目录才是之后开发的重点目录，将它展开如下图所示。
下面对app目录进行详细分析
build
这个目录和外层build目录类似，都包含一些编译时自动生成的文件，不过它里面的内容更加复杂一些，不需要关心它。
libs
如果项目中使用了第三方jar包，就需要把第三方jar包放在libs目录下，放在这个目录下的jar包都会被自动添加到构建路径中去。
androidTest
此处用来编写Android Test测试用例，可以对项目进行一些自动化测试。
java
毫无疑问.java目录是用来放置java代码的地方，展开该目录，可以看到之前自动创建的MainActivity文件。
res
res中包含多个目录，如drawable，layout，values和mipmap等,分别用于存放项目工程中使用的图片、布局文件、字符串文件和存放自动缩放图片的目录。其中values目录中包含很多XML描述我呢间，包括字符串定义、颜色定义、样式定义和长度定义等。
AndroidMainifest.xml
这是整个Android项目的配置文件,项目中使用到的四大组件都需要在这目录下进行注册。另外，还可以在这个文件中给项目应用添加权限声明。这个文件会经常用到，稍后的内容中会详细讲解。
test
此处是用来编写Unit Test测试用例的，是对项目进行自动化测试的另一种方式。
gitignore
与外层的.gitignore文件作用相似，是将app模块中的指定文件或目录排除在版本控制之外。
app.iml
IntelliJ IDEA 项目自动生成的文件，开发者不需要修改此文件内容。
proguard-rules.pro
这个文件用于指定项目代码的混淆规则，当代码开发完成后打成安装包文件。如果不希望代码被别人破解，通常会将代码进行混淆，从而让破解者难以阅读。
2.程序文件分析 1.Android程序的组成结构 package com.example.myapplication;//包声明语句 //导入包 import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; //定义MainActivity类继承AppCompatActivity public class MainActivity extends AppCompatActivity{ @Override//重写onCreate方法 protected void onCreate(Bundle savedInstanceState) { super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f100590bb76ae4500d2c9934308295d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d46e1f882a2b1fd58a8ac24b0d0659ae/" rel="bookmark">
			软件测试到底干到多少岁才会干不动？每一个阶段需要掌握哪些技术or技能呢？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无论是是什么技术岗位，都需要不断的提高自己，才能面对职场激烈的竞争，才能立于不败之地。
针对题主的疑问和提问说明文字，我认为本题目要拆出3个问题，才能将这个问题阐述清楚：
问题1：为什么会有开发人员（程序员）35岁危机呢？ 拆题2：软件测试有35岁危机吗？那首先要清楚测试和开发在工作中有哪些不一样。 拆题3：为避免35岁危机，测试人员需要做些什么准备工作? 一、为什么开发人员会有35岁危机？ 开发人员为什么会有35岁危机，其实是由多方面造成的。大体可以分为以下几个原因：
1、企业方的需求，程序员淘汰率高才能最划算
思考一个问题:
公司做一款新产品的时候可能需要一百个程序员来开发，但是做完了以后平时只需要五个程序员来维护就够了。那剩下的九十五个程序员怎么办？ 解决方法1：
互联网中大型公司：安排开发其他项目
开发人员完成了一个项目的开发后，公司为避免人员闲置，往往会布置开发人员做其他项目的开发。
而这个项目，往往和之前开发的产品不是同一个类型。比如开发人员开发出了网站，公司是不会白白养着，往往会要求去开发OA、财务软件、通讯软件，手机APP…每种产品的业务逻辑不一样,导致开发经验的可移植性就较差，就需要留给开发人员足够的学习时间。
确是不如直接找有相关项目经验的开发人员性价比更高。
解决方法2：
互联网小公司：95人全部开掉。
很多互联网小公司其实就指着几个项目吃饭，一个项目完了以后未必还能有开发下一个的机会，说不定找不到投资明天就倒闭了。
另外即使到时候又需要人了，直接招新人不香吗？永远会有新的大学毕业生在找工作，他们可能没什么经验，可能技术一般，但是他们要的钱少，身体好，能熬夜，听话，好忽悠。
如果你是一个企业的管理者，排除掉感情因素，你也会用这种性价比高的新零件换掉旧零件。
2、程序员工作本身存在折磨，年龄大真扛不住
这个折磨不是说写代码，觉得写代码是折磨的人干不了这一行。
这里说的是来自同事和需求方的折磨。
写代码对程序员来说不难，难的是需求方的需求变来变去，一开始说要A，代码写到一半说要B，又得重新写，写了一大半又说要添加个C功能，但这个C功能必须底层就写好，不能写一半再加，这时候又要重写。
最后就是整个人都被折磨疯了。
除了需求变来变去之外，还有一个问题就是经常白天被抓去开各种乱七八糟的会，然后只能晚上写代码，这就又造成了加班的现象。
程序员天天加班不假，但并不是加班写代码，主要是白天都被抓去开会，晚上和人撕逼需求，深夜才能写代码。
老这么加班，年轻还可以顶着，年纪大了还真的顶不住。
3、互联网行业发展快，技术更新也快，对程序员的要求还越来越高
技术带来先进生产力的同时，技术的迭代也是非常快的，弄不好分分钟就被淘汰。
不像很多传统行业，技术的积累是逐渐稳固的，越老越吃香。
开发人员可不一样，他们掌握的东西如果不能快速迭代，很容易出现自己被世界淘汰。
买数码产品我们都知道越新越好对吧？技术也是如此【所以如果要选择开发语言，强烈建议选择不容淘汰，市场需求广泛，老当益壮语言，如JAVA，Python等，这两门语言还都可以用来干测试开发】。
2020年，但凡能为程序员开出高薪的公司，对于程序员的筛选都是比较严格的，不对，已经不是比较严格了，是很严格。
不信自己可以去网上搜搜各大公司招聘的面试问题和笔试题，自己试着答一下，看看结果。
从来没有白给钱的事情，高工资带来的必然是高要求。这就意味着开发人员需要不断的去更新自己的知识体系, 个人必须非常努力，努力钻研各种新技术。
总结：
1、企业方的需求，程序员淘汰率高才能最划算 2、程序员工作本身存在折磨，年龄大真扛不住 3、互联网行业发展快，技术更新也快，对程序员的要求还越来越高 所以程序员必须有足够的危机意识。
一方面要费脑筋去开发新产品；一方面又要去学习新的技术；一方面还得与产品经理撕逼；一方面还要白天被琐事纠缠，只能晚上去做开发，加班深夜，用身体抗； 最后还得想办法讨好领导，争取早日坐上技术管理不用在一线写代码。多重折磨之下，这个头发肯定是留不住的。
在35岁这个年纪，往往又有家庭和孩子，精力不能和年轻时一样，全部投入到工作中，所以在职场的竞争力就开始下降。所以就有了35岁危机这一说。
对于程序员而言，不只是所谓的35岁，更是要时刻警醒自己要做架构，研究算法，转管理。
二、软件测试有35岁危机呢？先看下测试和开发在工作中有哪些不一样 区别1、项目开发时，需要100个开发人员，项目研发结束后，只需要5个开发人员维护 ，开发的需求在开发前后有着剧烈的变化。但中国当前测试和开发之比，常常在1:8到1:10之间，不可能像开发一样，对人员的需求存在着如此剧烈变化。因此相对来说，测试工作的稳定性要远高于开发。
区别2、开发人员在工作中，会被多变的需求折磨疯了，所以我们在网上会经常看到产品经理和开相互撕逼的段子和故事。但软件测试是对已经开发好的产品进行测试，不会受到多变的需求方折磨。
区别3、开发经常白天被抓去开各种乱七八糟的会，然后只能晚上写代码。测试也可能会白天被抓去开各种会。但除非项目上线冲刺阶段，需要开发写完代码后立即测试需要加班，比开发走的更晚。但一般情况下，开发晚上写完代码，测试白天测试一样来得及。加班程度远不如开发。
区别4、开发语言技术更迭非常快，开发需为了不被淘汰，需要不停的去学习新的技术，个人压力非常大。而反观测试行业，无论你的产品是什么类型，测试的流程和模块是大体差不多的【功能测试，接口测试，UI测试，性能测试…】，而且测试技术的更新是远远赶不上开发的。这就意味着，我们在测试当前项目所走过的每一个坑，都会成为测试下一个项目的经验和教训。测试很类似于传统行业，技术的积累是逐渐递增的，反倒会越老越吃香。
总结：所以开发人员有35岁危机这么一说，但是对于测试人员，不能说没有35岁危机，但危机程度要比开发人员要好很多。 所以有人说软件测试工程师和医生一样，是最不需要用“青春”来保证的职业。而是随着项目经验的不断增长和对行业背景的深入了解，会越老越吃香 （薪资会越来越高），就像老中医。 是不是测试的薪资越来越高，越来越吃香呢？可以立即去查看职友集的薪资，你就会发现一个让你非常吃惊的事实：
测试的前期平均工资可能比开发低，但是10年这个分界线开始，测试的薪资开始稳稳的超越开发。 三、为避免35岁危机，做为测试工程师需要做哪些准备工作? 35岁危机，虽然测试比开发弱很多，但并不意味着我们不需要做任何准备。因为无论是是什么技术岗位，都需要不断的提高自己，实现“做和自己年龄相匹配的事情”，才能面对职场激烈的竞争，才能立于不败之地。
随着年龄的变大，用人单位对于人才的要求也是随之改变的，比如：对于刚踏入职场的初级软件测试工程师，用人单位的要求更多是能独立完成测试测试任务的执行即可，但随着年龄的增加，就要求软件测试工程师具备项目风险评估，团队管理， 协调资源等等能力。所以需要我们及早规划自己的职业路径（狠狠点击放大下图）：
软件测试也是技术岗位，虽然不如开发更迭速度那么快，但是测试技术也会有技术更新。比如几年前，会功能测试就能找到好工作，但是到今天不懂自动化测试就很难找到好工作。如果想薪资更高，还要去学习性能测试，测试开发。
若你不是在机关工作，当你觉得自己过的很舒服的时候，注意，你离被开除就不远了。
时刻逼自己过的不舒服的测试，才是一个好测试。
-----------------------------------------------------------------
如果你想避免测试职业危机，提升自己的技术能力，但是苦于没有资源，在此，特意给大家准备了一份13G的超实用干货学习资源，涉及的内容非常全面，涵盖功能测试、接口测试、UI自动化测试、性能测试...。
自动化测试相关教程推荐： 2023最新自动化测试自学教程新手小白26天入门最详细教程,目前已有300多人通过学习这套教程入职大厂！！_哔哩哔哩_bilibili 2023最新合集Python自动化测试开发框架【全栈/实战/教程】合集精华，学完年薪40W+_哔哩哔哩_bilibili 测试开发相关教程推荐 2023全网最牛，字节测试开发大佬现场教学，从零开始教你成为年薪百万的测试开发工程师_哔哩哔哩_bilibili postman/jmeter/fiddler测试工具类教程推荐 讲的最详细JMeter接口测试/接口自动化测试项目实战合集教程，学jmeter接口测试一套教程就够了！！_哔哩哔哩_bilibili 2023自学fiddler抓包，请一定要看完【如何1天学会fiddler抓包】的全网最详细视频教程！！_哔哩哔哩_bilibili 2023全网封神，B站讲的最详细的Postman接口测试实战教学，小白都能学会_哔哩哔哩_bilibili 总结： 光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。 如果对你有帮助的话，点个赞收个藏，给作者一个鼓励。也方便你下次能够快速查找。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d46e1f882a2b1fd58a8ac24b0d0659ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b4455e01fa82134a8fec9391e7974a3/" rel="bookmark">
			转发一篇计算机论文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近看到一篇雷军老师在1992年的一篇计算机论文，个人看了对计算机科学从另外一个角度又多了一层理解，感觉很有收获，鉴于网上的图片看起来不清楚，本人特地到中国知网上去下载了这篇论文，希望给有心学习的人一点帮助。我学生时代注册的用户名和邮箱居然还能使用，顿时心中不免有一些感慨！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfa9d65dd6ea593a1b708dd5d4fcdddf/" rel="bookmark">
			duomi靶场（变量覆盖）获取webshell
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		tips 什么是变量覆盖？ 就是用新的值去覆盖原来的值，举个栗子 $a=123; $a=234; //第二个变量a的值覆盖了第一个a的值，所以输出结果是234 echo $a; 变量覆盖漏洞如何入手？ 变量覆盖漏洞大多数由函数使用不当导致，经常引发变量覆盖漏洞的函数有： extract(数组) 把一个数组的键全部变为变量，举个栗子 $a = array('name'=&gt;'tom'); extract($a) //从这里开始，name就是一个变量了，可以调用 $name parse_str(字符串) 把字符串变成变量，举个栗子 parse_str("name=LIHUA&amp;age=18"); //name和age都变成了变量 echo $name echo $age import_request_variables(变量类型) 函数将 GET／POST／Cookie 变量导入到全局作用域中,不区分大小写，所以你可以使用 g 、 p 和 c 的任何组合，举个栗子 //定义一个变量a $a = 'hack'; //把用GET的方法接收的参数变成变量，此时在浏览器url中输入a=Lucy import_request_variables(g); //此时原来的a变量会被替换，输出Lucy echo $a $$ 把变量的值变成变量，常常放入foreach遍历。举个栗子 $a = 'lucy'; $$a =&gt; $lucy; 审计系统代码 绕过登录 查找相关函数： extract、parse_str、import_request_variables都无 查询$$，因为此方法常与foreach搭配，过滤掉上面的找到一条漏洞进行分析/duomiphp/common.php 是一个从GET,POST,COOKIE传入的可以控制的变量，将键值对分离，键变成变量，值变成对应变量的值，RunMagicQuotes相当于addslashes($_v)，过滤特殊符号。 接着看一下触发条件，看到第28行到34行有一个判断退出 将post和get方法传入的参数键值分离，键长度要大于0，键要满足正则表达式必须要有cfg_和GLOBALS，cookie必须要有键名。不满足这三个条件就会exit退出不会执行下面的了。 接下来全局搜索查看什么文件调用了这个common.php文件 foreach一般用于全局变量，用于全局判断的变量中最常用的是记录登陆状态或者用户登录情况的的，在全局搜索出来刚好有登录页面的，去登录页面查看是否有用于记录状态的全局变量。 登录成功后发现多了一个莫名其妙的记录，盲猜是记录登录状态的，定位函数，查看构造 果然是记录状态的函数，继续全文追踪三个session的变量名 一个一个去追太麻烦了，这里直接在登录页面去输出一下session查看当前状态。 也就是到这里，我们就可以通过common.php文件提交这些session，登录的时候就会跳转验证这些session就可以登录。 _SESSION[duomi_ckstr]=dfwb&amp;_SESSION[duomi_ckstr_last]=&amp;_SESSION[duomi_admin_id]=1&amp;_SESSION[duomi_admin_name]=admin&amp;_SESSION[duomi_group_id]=1 但是要写入session，除了找到可以提交变量的文件，还需要一个session_start，现在需要一个文件既有common.php也要有session_start，而且函数要在包含文件之前生效. common.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfa9d65dd6ea593a1b708dd5d4fcdddf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/842f5efeffc80c1589bcb8635a6b25f1/" rel="bookmark">
			音频筑基：瞬态、基音、偏噪信号类型分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 音频筑基：瞬态、基音、偏噪信号类型分析 是什么深入理解从编码角度看，基音信号编码通常会有啥问题？在频域感知编码过程中，瞬态信号会有啥问题？如何解决？瞬态信号场景下，5/10ms帧长编码有啥区别？是否短帧长更有优势？ 在分析音频信号中，不同信号类型如瞬态、基音、偏噪信号是我们经常遇到的概念，这里谈谈自己的理解。
是什么 Transient Signal：瞬态信号 时域表现：时域中信号反复突变，周期不明显，如在动态范围内突变不连续频域表现：频率成分分布广，在有限码率下，以编码频点的方式无法完全刻画信号实例：现实世界里的物品敲击音、乒乓球落地的声音 Pitched Signal：基音信号 时域表现：时域内周期明显，相同包络信号反复拼接频域表现：频域内表现为一根根谐波，层次分明信号实例：人声清唱、钢琴音、琴弦扫弦音 Noise Signal：偏噪信号 时域表现：时域内呈现随机性，变化剧烈频域表现：频谱铺的很满，在基波和次谐波上叠加了许多早是你提供信号实例：乐器嘈杂的流行乐，背景嘈杂的摇滚乐 基音的概念：
基音是指声音中最低的频率成分，也就是声音的基础频率，它是声音音调的主要决定因素之一。
简单说，分析声音信号的频谱，找出其中最强的频率成分，这个频率就是声音的基频或基音。
深入理解 从编码角度看，基音信号编码通常会有啥问题？ 基音信号一般周期会大于帧长，导致无法准确获取谐波。常见的解决方式是加入长短窗切换。 在频域感知编码过程中，瞬态信号会有啥问题？如何解决？ 时域编码对瞬态信号表现好，瞬态为突变信号，频域特征不明显，不利于编码表达。瞬态信号通常会在频域编码中产生预回声问题。 常见解决方法：
长短窗切换，遇到瞬态信号用短窗变换。自适应窗切换技术是感知音频编码技术领域的一项重要技术，其主要作用是抑制暂态信号引起的预回声问题。TNS，在编码段，TNS技术对检测到的暂态信号的频谱系数进行线性预测分析，在解码端，对暂态信号进行频谱预测合成，可以调节误差的形状以适应输入音频信号的时域形状，从而将编码噪声置于解码信号之下，大幅降低量化噪声对解码后音频主观听觉的影响。 瞬态信号场景下，5/10ms帧长编码有啥区别？是否短帧长更有优势？ 客观上，同码率下，短帧长总体残差是要大于长帧长。主观上，短帧长预回声现象减少，突变更清脆，有瞬态感，主观听感短帧长控制的更好。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f74d7012946cd013ab04510273893f29/" rel="bookmark">
			Attempting to renew cert (***.com) from /etc/letsencrypt/renewal/***.com.conf produced an unexpected
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种情况 Attempting to parse the version 0.27.1 renewal configuration file found at /etc/letsencrypt/renewal/***.com.conf with version 0.27.0 of Certbot. This might not work.
Could not choose appropriate plugin: The nginx plugin is not working; there may be problems with your existing configuration.
The error was: NoInstallationError()
Attempting to renew cert (***.com) from /etc/letsencrypt/renewal/***.com.conf produced an unexpected error: The nginx plugin is not working; there may be problems with your existing configuration.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f74d7012946cd013ab04510273893f29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fca428f92e7a26f20f566a7cbc4f868b/" rel="bookmark">
			‘找不到msvcp140.dll无法继续执行代码’的处理方法指南，如何修复msvcp140.dll
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		找不到msvcp140.dll无法继续执行代码的情况你知道怎么处理么？最近有很多小伙伴都在咨询小编这个问题，说他的电脑经常出现这个msvcp140.dll文件的丢失，他都不知道怎么去处理，其实处理这种问题还是比较简单的，今天小编就来给大家详细的说说msvcp140.dll文件的修复方法。
一.为什么会出现找不到msvcp140.dll的情况 msvcp140.dll是一个属于Microsoft Visual C++ Redistributable Packages的一部分的DLL（动态链接库）文件。该文件通常被许多应用程序所依赖，因为它包含C++标准库的函数，用于执行诸如字符串处理、数学计算等常见的编程任务。如果系统中该DLL文件丢失、损坏或未正确安装，当运行依赖它的软件时，就可能出现“找不到msvcp140.dll”或“msvcp140.dll丢失”的错误提示。
二.缺失msvcp140.dll导致的问题 - 卸载或更新操作不当：可能在安装或卸载另一个程序的过程中，意外地删除或破坏了msvcp140.dll文件。
- 恶意软件攻击：恶意软件可能会故意破坏系统文件，包括msvcp140.dll。
- 系统更新错误：在系统升级或更新时，某些DLL文件可能未能正确更新或被覆盖。
- 注册表问题：无效的注册表项也可能导致DLL文件错误加载。
三.如何修复找不到msvcp140.dll的问题 修复方法概览
- 重新安装Microsoft Visual C++ Redistributable：直接从官方网站下载最适合您系统的Microsoft Visual C++ Redistributable版本并安装，通常可以解决问题。
- 使用SFC和DISM命令：利用系统文件检查器（SFC）扫描修复损坏的系统文件，并使用部署映像服务和管理工具（DISM）修复Windows系统映像。
- 使用dll修复工具来解决：如果你是新手小白，不懂得电脑操作，那么使用dll修复工具来解决msvcp140.dll文件就可以了，它支持一键修复，修复起来相对简单很多，不需要你做什么操作。
DLL修复工具_一键修复所有dll缺失msvcp140.dll丢失的解决方法–电脑修复精灵
- 手动下载并安装msvcp140.dll文件：尽管不推荐，但可以从另一台相同架构的计算机上复制msvcp140.dll文件并粘贴到导致错误的计算机上合适的目录中。
四.多种修复msvcp140.dll方法的优劣分析 各种方法的利弊
- 重新安装Microsoft Visual C++ Redistributable：
- 优点：这是最简单和最安全的方法，因为它来自官方渠道，可以保证文件的完整性和兼容性。
- 缺点：需要良好的网络连接下载安装包，而且如果您不确定哪个版本的Visual C++是必需的，可能需要尝试几个不同的版本。
- 使用SFC和DISM工具：
- 优点：它们是内置Windows系统的工具，可以解决许多系统级别的问题，且不需要下载任何外部文件。
- 缺点：扫描和修复过程可能需要较长时间，而且不一定能解决所有DLL文件缺失的问题。
- 使用dll修复工具来解决
- 优点：对于电脑小白来说，使用dll修复工具来解决msvcp140.dll文件丢失会简单一点，一键修复，能节省大量的时间，修复效率高。
- 缺点：市面上的dll修复工具比较多，要仔细甄别，因为有的dll修复工具不靠谱，这点需要我们注意的。
- 手动下载并安装msvcp140.dll文件：
- 优点：如果其他方法不起作用，手动替换文件是直接解决问题的办法。
- 缺点：风险很高，如果来源不可靠，可能会带来安全问题。不正确的文件版本也可能导致新的兼容性问题。
五.修复msvcp140.dll文件的注意事项 在尝试修复msvcp140.dll问题时，请务必注意以下几点：
- 使用官方和可信的来源：始终从官方网站下载文件或安装程序，避免使用第三方软件下载站点。
- 检查系统类型：下载DLL文件或相关安装包前，确保与您的系统架构（32-bit或64-bit）相匹配。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fca428f92e7a26f20f566a7cbc4f868b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bee8fb6abc933b156e15baa5a85affa/" rel="bookmark">
			一个企业为什么要数字化转型？答案在这里！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个企业为什么要数字化转型？ 先简单说说原因。
因为很多行业现在存在大量的产能过剩、产品过剩、服务过剩，经营维度低、行业竞争激烈......企业生存困难，必须改变经营维度才能活下来，才能变现。
单方面举个例子，可能你就明白了~
当前市场上企业用户流量都被“大平台”垄断了，每个企业用户都到了极限，由于竞争激烈等因素，而且用户流失速度很快，大家都在某音、某手、某信等尝试用短视频方式把公域流量转化成自己的私域用户流量，靠吸引私域流量卖产品卖服务。
但是本质上还是产品获利、服务获利思维，还是以自己的企业为中心的思维，不能真正满足用户的所有需要需求，不能锁定用户，也就是都在用发福利低价做同维度竞争流量的事，引流的成本越来越大，但是产品越来越难卖，效率越来越低。
企业必须数字化转型升级，用一款打破边界、以用户为中心的数字化转型工具，满足用户的所有需要需求，靠用户去无边界链接用户，靠用户无边界裂变用户，只有这样才能让企业获得各行各业的利润和数据价值。
数字化转型不需要转行，传统行业转行就是找死，数字化转型可以链接各行各业，获得各行各业的利润和数据价值，所以不需要转行就可以低风险实现经营所有的行业。
去平台中心化、分布式自主经营、资源共享、打破边界链接裂变、算力算法，构建商群诚信生态……这些都是数字化转型的关键特征。
除此之外，一个企业为什么要数字化转型，或多或少还存在以下3个原因。
1、是企业生存与发展的必经之路
前面也拿例子讲到了，在当今的时代背景之下，全球都在朝着数字经济的方向发展。
无论是生产、生活、工作、消费等各个环节都与数字化息息相关。互联网+的到来，更是让整个社会都发生了翻天覆地的变化。这个时候企业如果不寻求创新与变革，不积极拥抱变化，就无法顺应大环境下的规律。而传统的、置身于数字经济之外的企业，最终都会被市场所淘汰出局。
所以说，企业的数字化转型，是让企业逐渐适应数字经济环境，并谋求未来生存与发展的一条必经之路。
2、为企业提供了增长机会
纵观传统产业，大家基本上可以发现其需求疲软、产能过剩、竞争过度等种种突出的矛盾，经济的发展也已经从先前的高速、低质量转向现在的低速、高质量模式。
而一家传统型企业如果仅仅依靠过去的实践经验，是无法适用于未来发展的，反而会在激烈的市场竞争中被打压。而数字化转型可以让企业在产品、业务、营销模式、市场策略等多个方面做出改变，让企业探寻出新的增长机会，将更多的资源用于布局数字经济下的新兴市场。
3、为企业提供了核心动力
企业的数字化转型带来的整个组织的重构和调整，同时也带来了产品、营销、生产、运营等多个体系的变革，因此企业也会从传统生产要素向数据生产要素而变化，在业务模式上有了更加深远的创新。
在运营管理方面更加趋于精细化、在决策方面更加数据化，让企业的运营、研发、营销成本得到了大大的降低，从而为企业提高产品及服务质量、增加效益方面提供了核心的动力。
数字化转型作为企业的大势所趋，能够帮助企业实现业务的转型、创新与增长，也意味着整体的核心竞争力的提升。虽然从短期内来看，很多企业不存在压力，但长期下去还是存在很多不确定因素及挑战，唯有通过数字化手段才能降低企业运营成本。在当今这个数字经济为主导的时代下，作为企业只有拥抱数字化、利用数字化为自己带来成长，才能进一步提高竞争力，在市场中占据一席之地。
企业如何进行数字化转型？标准是什么？ 1、国内企业数字化发展现状
（1）大多数个人和公司混淆了数据管理和技术管理，阻碍了两者的正确管理。
数据管理：简单来说就是利用各种信息技术对数据进行有效的收集、存储、处理和应用的过程。其目的在于充分有效地发挥数据的作用。强调：数据管理和利用。
技术管理：技术管理通常是指在技术行业当中所作的管理工作，管理者一般具有较高的技术水平，同时带领着自己所管理的团队完成某项技术任务。要求管理者对所领导的团队的技术分配，技术指向和技术监察。强调：利用技术知识和能力来提高整个团队的效率。
这和信息化与数字化的关系比较类似，数据管理相当于信息的收集和整合利用，而技术管理需要利用以数据为代表的信息，目的就是提升内部流程运转和提高效率。
（2）信息孤岛阻碍了数据质量并干扰了各级数据共享。
IT和业务团队之间存在相当大的紧张关系。由于缺乏共同语言，技术和业务团队无法相互交谈。
更通俗地理解，技术人员思考的是如何构建系统从而达成某一效果或具备某种功能；而业务人员思考的是如何满足业务需求，怎么让效果达到的更好。
问题就在于：技术人员专业性很高，直白点，太专业的东西说出来业务人员听不懂；业务人员可能知道缺陷在哪个地方或者改进的方向可以是怎样的，但是表达不出来，即使表达出来，技术人员对业务缺乏理解，改进的效果也不那么乐观。
长此以往，IT和业务团队之间的关系越发紧张。
（3）标准化产品呈现市场流失的明显态势。
目前中国的大环境就是：推销标准化产品已经无效，客户要求按照自己的业务发展需求立项，采购，客制化。
标准化产品的优点很明显：专业、针对性比较强。
但缺点和优点一样突出：针对性比较强，但是没有那么强，无法满足每一个企业的每一个需求。同时，不同的标准化产品之间会有信息壁垒，导致后期维护成本很高，升级慢、落地慢，缺点十分明显。
因此越来越多的企业要求按照自己的业务发展需求进行系统构建。
2、企业IT发展经历阶段
Gartner认为，企业IT发展经历了三个阶段：
第一阶段——IT工匠时代：IT部门人员可以称作“工匠”，他们对于技术非常熟悉，但也造就了一个个相互孤立的烟囱式系统；
第二阶段——IT工业化时代：企业要求系统之间互相集成，关注系统的流程和管理；
第三阶段——数字化时代：企业商业模式发生了变化，强调敏捷的开发方案，通过科技赋能商业。
3、顺应时代发展——低代码产品高调亮相
随着不同的系统之间信息孤岛的问题，以及时代高速发展导致需求多变的现象，越来越多的企业要求打破烟囱式信息孤岛，并且使系统更加贴合企业的特定需求。
但是“高额的定制费用”以及“多次定制却始终难以满足需求的状况”让很多企业苦不堪言。
在这样的状况下，以“织信Informat”为代表的低代码厂商出现在大众的面前。
低代码的出现为企业数字化转型注入新动能：
（1）释放企业内部业务端的产品设计潜力，让技术资源从IT部门向业务部门普惠，弱化IT部门与业务部门之间的矛盾，更大程度地利用各类人才。
（2）低代码产品的应用还能联通企业内各系统数据，帮助企业高效挖掘数据价值。
（3）低代码对研发效能的提升缩短了敏态业务需求的响应时滞，盘活了企业间资金、人员和信息资源周转，帮助企业快速把握新机遇，推动企业需求快速响应。
（4）低代码让企业的碎片化开发需求得到满足，激活企业的活力和创新力。
而织信低代码作为低代码厂商的优秀代表之一，自上线以来受到了大量企业客户的认可。
专注国内企业数字化转型服务，现已累计为20多个行业，30000+企业用户提供低代码技术支持。在不同的行业，提出深度场景解决方案，致力于成为企业数字化转型首选方案。
平台基于数据模型优先的设计理念，提供大量标准化的组件，还内置了自动化（自研的一套图形化编程）、脚本、工作流引擎（BPMN2.0）、自定义API等功能，能帮助企业构建高度复杂核心的业务系统。如ERP、PLM、MES、SCM、WMS、OMS、EMS、项目、企业服务等多个应用场景，全面助力企业落地数字化转型战略目标。
4、怎么才算数字化企业？
数字化企业可以按照以下几个方面来定义：
（1）企业内部不存在信息壁垒，所有系统信息完全互通连接：数字化企业内部几乎所有的商业关系，客户、供应商、雇员之间以及核心的业务流程都是通过数字化的信息系统进行连接和沟通。
这里就要介绍几个常见的概念：
CRM：客户管理系统 (customer management system)ERP：企业资源计划(Enterprise Resource Planning)MES：制造执行系统( Manufacturing Execution System)WMS：仓储管理系统( Warehouse Management System)SRM：供应商关系管理（Supplier Relationship Management） （2）电子化管理：核心的企业资产例如智力成果、财务和人力资源也是以数字化信息系统的方式进行管理和运作；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1bee8fb6abc933b156e15baa5a85affa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a0e3b40d18fd8c12ca87d336acc33df/" rel="bookmark">
			技术人应该知道的电商运营小知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔者自入职以来，长期服务于大淘宝消费者运营相关的业务开发，同时也了解过一些行业运营、平台运营、商家运营等相关的工作。在此过程中，其实自己一直对“运营”这个岗位有很大的好奇。但是什么是“运营”，什么是“互联网运营”，什么是“电商运营”，为啥大淘宝里面有这么多“运营”岗位。怀着这些问题，我查询了一些资料，翻看了一些书籍，在此和大家分享下我的所见所得。虽然电商运营有其独特性，但背后的互联网运营本质是相通的，所以希望本文不仅能帮助大家理解电商运营背后的机制，也能对大家日后的业务开发都有所启发。
电商本质
▐ 电商与互联网时代 啥是电商运营 电商运营其实是三个概念的集合体，“电子”+“商务”+“运营”。其中“电子”一般指“互联网”，互联网提供的是连接，连接消费者、品牌方、经销商、供应商、工厂等。“商务”就指上述角色之间产生的买卖行为。“运营”就是最终将这一切变成现实的催化剂。
从职能角度来看，运营工作一般分为六部分，产品运营（负责产品分析，采购），网站运营（线上购物环境基础维护），活动运营（也称营销策划），流量运营（推广），用户运营（客户服务和客户关系管理），数据分析（运营支持）。
产品运营：通过市场分析，向供应商或工厂提出产品需求，不断增强产品在线上的竞争力，同时决定采购产品的种类和数量，保证供应链的稳定，为前端销售提供强大的支持。
网站运营：一般是线上直接销售网站的基础运营，包括产品入库，用户的购物路径规划，导航规划，产品描述页面等基础建设。
活动运营：主要是策划线上活动，包括针对商品打折的活动以及能与消费者产生互动的活动，促进商品销售。
流量运营：专门指投放各种线上广告，需要精通各种互联网广告收费方式，诸如CPC、CPM、CPS等，还需要承担商务拓展（BD）的职责，去与相关流量供给方谈合作。
用户运营：用户运营分两部分，一部分是客户服务，包括售前、售中、售后的服务，均会直接影响产品销售；另一部是客户关系管理（CRM），主要是提升用户满意度，引导用户二次购买（回流和留存），建立会员体系等。
数据分析：为整个电商运营提供数据支持，指导运营团队决策。
综上，电商运营，整体来看就是通过一系列现代数字化工具的使用，对整个商业形态进行升级，提升效率。
互联网运营vs电商运营 互联网网站运营，重点在于“内容建设”和“交互体验”。大部分网站或者APP都依靠“内容”来吸引用户，比如新闻类（今日头条），视频类（bilibili）。“交互体验”是指用户想得到的信息能否快速地被找到，对应的运营方法就是归类，比如导航网站的各种“归类”（2345导航网站）。
电商运营，重点在于“供应链管理”和“购物流程体验”的提升。供应链管理，需要运营通过数据分析去决定销售哪些品类的产品，要准备多少库存，产品的周转期等等指标。购物流程体验则范围较大，简单来说是用户对产品在线上的“找”“选”“买”“付款”“用”“售后”所有流程的设计和规划。
无论互联网网站运营还是电商运营，最终目标是一致的，就是吸引足够多的用户，满足用户需求，留存用户，从而产生大规模稳定的流量，最后能够变现。差别在于，电商本身就是一个流量变现方式，可以直接将流量转变为“营业收入”。相比较于互联网网站运营，其变现能力更强。
▐ 电商是互联网流量变现的捷径 互联网流量变现的3种方式 流量变现的方式（盈利模式）目前大致有3种：商品交易，做广告，增值服务。
商品交易（淘宝、亚马逊），是目前互联网流量变现主要形式，商品可以是实物产品，也可以是虚拟产品。
做广告（谷歌、百度），是目前互联网流量最高效的方式。具体来说就是刊发广告信息，收取广告费用作为营收。这类互联网项目通常以内容来吸引流量，以信息传播为目的。
增值服务（腾讯视频、爱奇艺），可以理解为购买“特权”，用户可以在网站上购买会员资格，以便享有网站带来的更多“特权”。
当然，目前大部分互联网公司的盈利方式会同时包含上述多种，比如阿里妈妈做直钻推（直通车、钻展、超级推荐）等广告业务，天猫也会做额外的增值服务（聚划算）等。
电商运营的内在逻辑
▐ 电商为什么这么依赖运营 互联网业界有句名言：技术驱动的百度，运营驱动的淘宝，产品驱动的腾讯。淘宝的核心业务是电商，是要以运营为基础不断提升用户消费体验，从而保证用户量。究其原因，是跟用户需求特点有关系。在电商领域，用户的需求是快速找到符合个人预期和物美价廉的商品，并且要求付款方便，售后服务也有良好的体验。随着科技的进步，符合个人预期且物美价廉的商品不断变化，单纯通过计算技术和产品功能几乎是无法正确引导用户购买的。同时用户的年龄、性别、文化程度、收入水平、所在地区不同，导致个人偏好存在巨大差异，这就需要对商品的选择具备很强的商业敏感性。
综上，电商运营需要具有前瞻性和及时性，前瞻性是指能感知到消费者需求，提前做好消费者购物路径的优化；及时性是指在不同时间点，给消费者重点展现不同的产品。
▐ 电商的核心-零售 零售有以下4个关键点。
产品 产品是整个零售中最根本的一环。有一个怎样的产品，就可以决定一个品牌、一个运营商，甚至是一个电商平台能走到怎样一个高度。
品牌 品牌是人们对一个企业及其产品、售后服务、文化价值的一种评价和认知，本质其实是信任。品牌已是一种商品综合品质的体现和代表。
供应链 供应链主要包含库存和渠道。库存关系到零售企业的生死存亡。再畅销的产品，只是放在仓库里的话，和一堆石头没啥区别，只有真正销售出去、货品流转起来才有价值。渠道是与用户触达的最终通道，所以在渠道建设上面，各品牌商或者生产商，都有着自己的考量。
服务 服务是一个产品的延伸。好产品的背后一定是有一个优质的服务做支撑。无论是售前服务、售中服务，还是售后服务，全部是重点。
▐ 怎样做好零售分析——人、货、场 人、货、场可能是大家在淘宝内听到最多的一组词。在此做简单的介绍：
人 用户 用户就是这个零售的目标用户。具体点说，就是在互联网大数据的支持下，每个人都具有自己的数据画像，通过一定的技术手段找到目标用户、吸引目标用户、转化目标用户。就是这个商品的目标用户。对于目标用户想清楚了，才能在后面的产品和服务上面有针对性的优化和突破，在营销玩法和推广渠道上面也才会更高效。
合作伙伴 这里的合作伙伴指上下游供应商或者服务商。零售中与“人”有关的量化指标如图所示。
货 货不仅仅指要销售的“商品”，还包含“服务”。服务是贯穿“商品”整个销售环节的重要因素。市面上有特别多的品牌是以“服务”作为突破口。服务质量有时候比产品本身的质量还重要。
产品 产品，毫无疑问是整个零售的中心，是最终产生商业价值的载体。通过这个载体，或解决了人们日常生活中的问题，或节省了人们的时间提升了效率，或享受到了更高品质的生活。
在零售中，会将产品分层，低端产品、中端产品、高端产品。不同层次的产品打开市场的方法也不一样。除了低端、中端、高端这样的分层方法以外，电商更看中“流量入口产品”，也就是通常所说的“爆款”。
除了“爆款”产品，还要有其他3个层次的产品互相配合来综合提升店铺业绩和利润。这3个层次分别为：“利润款”“形象款”和“活动款”。
“利润款”的特征与选品逻辑 利润款产品可以是一个比较高端的同类产品，也可以是一个“辅助产品”。比如我们熟知的手机，很多品牌的手机产品本身的价格非常低，甚至是负毛利出货，真正赚钱的是给用户搭配的贴膜和手机壳等配件。罗永浩老师有句名言“卖手机根本不赚钱，就当交个朋友”其实是有道理的。
“形象款”的特征与选品逻辑 形象款一般都是选择产品线中最高端的产品，不仅在功能、质量上面最优质，价格往往也是最高的。但是，形象款的存在是要给用户一个印象———这个品牌最厉害的产品原来这么高端，有如此高的科技含量，相信他们品牌的技术实力没问题，其他稍微便宜些的产品应该也不会差。这个比较典型的就是小米的透明电视。
﻿
“活动款”的特征与选品逻辑 活动款最大的特点是利润率高、补货速度快、单价相对低、可以反复打折。而且活动款必须是多个产品，每个价位段最好都有一个活动款产品规划。比如苹果的iPhone，常年参加各种营销活动，且销量惊人。
﻿
服务 提到服务我们很容易想到售后，其实零售中的服务除了“售后，还包含“售前”和“售中”。
“售前服务”是指企业在顾客未接触产品之前所开展的一系列刺激顾客购买欲望的服务工作。
“售中服务”是指在产品销售过程中为顾客提供的服务。如热情地为顾客介绍和展示产品，详细说明产品使用方法，耐心帮助顾客挑选商品，解答顾客提出的问题等。
“售后服务”就是在商品出售以后所提供的各种服务活动，包括上门安装、报修、退换货等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a0e3b40d18fd8c12ca87d336acc33df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/029e83e34e2e3d88eed652224a4c9e10/" rel="bookmark">
			C&#43;&#43;入门通讯录综合管理系统代码（自写，开源）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言代码开源 前言 1.代码量约300行，仅实现了基于命令行的简易通讯录管理功能，其中还有许多地方可以拓展改进，以提高代码的可读性和健壮性。
2.综合运用了C++入门的if-else、switch-case、string、for、结构体嵌套、结构体数组、键值判断等思想。
3.技巧上，包括值传递与指针地址传递、函数调用、结构体数组成员变量属性的修改、索引记录等手段。
代码开源 很简单，就不进行解释了。
#include &lt;iostream&gt; #include &lt;string&gt; #include &lt;cstdlib&gt; // 添加这个头文件 using namespace std; #define MAX_NUM 1000 //①实现一个显示菜单的功能函数 void showManu() { cout &lt;&lt; "****************************************" &lt;&lt; endl; cout &lt;&lt; "按'1'——添加联系人" &lt;&lt; endl; cout &lt;&lt; "按'2'——显示联系人" &lt;&lt; endl; cout &lt;&lt; "按'3'——删除联系人" &lt;&lt; endl; cout &lt;&lt; "按'4'——查找联系人" &lt;&lt; endl; cout &lt;&lt; "按'5'——修改联系人信息" &lt;&lt; endl; cout &lt;&lt; "按'6'——清空联系人" &lt;&lt; endl; cout &lt;&lt; "按'0'——退出通讯录管理系统" &lt;&lt; endl; cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/029e83e34e2e3d88eed652224a4c9e10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/059413dc1391fefb341e36d1b65b3c8d/" rel="bookmark">
			去除微信小程序里button的边框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		去除微信小程序里面的button边框 方法一：通过button::after
button::after{
border: none;
}
方法二：给button按钮加上plain属性，属性值为true
&lt;button plain="true"&gt;&lt;/button&gt;
然后设置样式就可以去除边框了
button[plain]{ border:0 }
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/273faa4173d68a0bf8f8a05ab762d4ea/" rel="bookmark">
			2023年第七届强网杯部分WP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.SpeedUp 在这个网站直接记载了2的27次方的阶乘的每一位数字之和
A244060 - OEIS
对4495662081取个sha256即可 flag{bbdee5c548fddfc76617c562952a3a3b03d423985c095521a8661d248fad3797}
二.谍影重重2.0 将数据包导出为json格式
使用脚本提取字段并进行MD5
import json import pyModeS as pms import hashlib with open('123.json', 'r', encoding='utf-8') as file: data = json.load(file) info = [] for packet in data: if 'layers' in packet['_source'] and 'tcp' in packet['_source']['layers']: tcp_layer = packet['_source']['layers']['tcp'] if 'tcp.payload' in tcp_layer: tcp_payload = tcp_layer['tcp.payload'].replace(':','') info.append(tcp_payload) planes_data = [] for i in info: msg = i[18:] if pms.adsb.typecode(msg) &gt;= 19 and pms.adsb.typecode(msg) &lt;= 22: icao = pms.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/273faa4173d68a0bf8f8a05ab762d4ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/851ab6621aafd768b7d2b98ae089f912/" rel="bookmark">
			低代码赋能，解锁汽车行业数字化转型时代下的“新机遇”！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“数字化转型”已经成为现代企业不可忽视的重要话题。虽然不同的企业，转型的方式和效果各有不同，但如果我们从更高的层面去审视，会发现数字化转型的核心其实就是利用云计算、大数据、人工智能、物联网、区块链等数字化技术和能力，来驱动组织商业模式创新和商业生态系统重构的途径和方法。
就汽车行业而言，车企的数字化转型，就是对汽车产业链相关生产业务过程进行的重塑，使其更加适应当前市场环境、生产环境、互联网环境，从零部件采购、产品研发、整装生产、到4S店营销、到用户车机端驾驶体验，以及售后服务，全业务环节数字化。强调通过数字技术对商业模式重塑，不只是单纯的解决企业某个管理问题或业务问题，而是通过数字化技术赋能企业商业模式创新和突破的核心力量。
中国汽车行业发展至今，伴随着新能源的加速推进、新智能技术的演变及新玩家的入局，近年迎来加速转型变革期。中国汽车市场也逐步地从增量市场演变为存量市场，并在市场结构上呈现新能源替代与中高端替代的结构化增量。与此同时，商业模式也从传统经销商制发展出直营、代理及混合等模式，区域及城市管理也随之成为新课题。
在这场变革中，对于汽车企业，特别是中国的汽车企业，同时面临着“新能源转型”与“数字化转型”的双重挤压，如何在转型期生存并发展，如何在保证业绩增长与市场份额的同时完成转型，是他们面临的课题。
一、汽车行业数字化转型所面临的挑战 1、技术路线不明确
传统汽车产业是面向“制造”，而未来车企将是面向“用户的出行服务”，这是与自动驾驶的实现配套的。所以汽车行业面临产品本身和使用产品的方式这两重关键因素叠加，使得数字化转型异常艰难。部分汽车企业缺乏足够的数据平台和数字业务运营经验，在技术平台、技术路线、培育模式方面踌躇不前。
2、管理决策流程长
与其他行业企业相比，汽车企业组织管理模式多为金字塔结构，呈现规模大、层级划分明显、组织结构复杂等特征，导致组织架构调整难度大，市场需求灵活响应不足，集团公司对二级公司管控能力差，易产生管理审批流程长，决策缓慢、市场响应能力差等问题，难以适应数字化转型发展需求。
3、跨部门协同能力弱
数字化转型发展需要企业从上到下各部门间有效协同，通过打造敏捷组织管理模式，建立合适的组织形式、机制、绩效体系。但由于汽车企业长期以来各部门的目标、职权与利益不同，难以打破部门“内部保护主义”的行为惯性思维，因此部门间灵活协同机制仍需完善。
4、数据安全隐患大
智能网联汽车作为新型智能终端、储能设施，采集的数据包括外部环境数据、车辆运行数据、用户驾驶行为数据等，大量且频繁的数据交互给汽车数据安全带来了潜在的风险。但部分汽车企业普遍仅关注传输、存储安全，却忽略了业务应用层的数据安全。
5、产业协同创新机制不健全
产业供应链和数字化转型是需要各企业之间保持紧密合作、优势互补，实现资源共享。但我国汽车行业在产业链和供应链方面存在资源不足、生态不健全等问题，制约了供应链数字化转型的推进。
二、低代码赋能，助力车企实现数字化敏捷创新 近年来，随着碳达峰碳中和目标的引领，汽车产业正朝着电动化、智能化、网联化、共享化方向高速发展。与此同时，汽车强国建设迎来关键的转折点，智能化、低碳化、数字化已成为实现汽车行业高质量发展的核心要素。为此，迫切需要突破核心共性关键环节，掌握引领未来发展的前沿技术，以促进汽车产业链、创新链和价值链的升级与重构。
在这一进程中，织信低代码推出的《汽车行业数字化转型解决方案》将扮演关键角色。基于低代码的快速、灵活等特点，不仅缩短了应用开发周期、提升了效率与生产力，更有力地支持了汽车企业的数字化转型。同时，也将低代码的开发能力赋能到企业更多人才身上，全面推动汽车产业人才结构的升级和优化。
1、低代码赋能，实现应用敏捷迭代
织信低代码以其灵活性和高拓展性，助力车企实现应用的敏捷构建与快速交付，从而支撑业务创新能力，满足业务部门的敏态和长尾需求。这一过程大大缩短了开发周期，为企业带来了显著的经济收益。
同时，由于业务部门能够自行开发轻量级的业务应用，IT人员的时间和精力成本得到了有效节约。这种模式打破了传统的软件开发模式，使得相关人员能够清晰地看到并参与到应用的具体开发过程中。
这种公民开发的模式，提升了企业的数字化意识，进一步缩小了IT部门与业务部门之间的鸿沟，实现了更加紧密的合作。通过这种方式，企业能够更好地理解和应用技术，推动数字化转型的进程。
2、可视化数据，增强领导决策能力
在数据报表方面，很多汽车企业都采用传统模式的Excel或者PPT的形式进行报表制作。需要统计的数据分布在各个业务系统中，根据汇报对象及汇报要求，每次需要进行大量的数据导出、数据匹配、数据统计、图表制作等重复性工作。
解决这一问题其实很简单，汽车企业只需通过将各业务系统的数据按模板导入到织信平台，使用数据表模块对数据进行简单处理后，再使用仪表盘制作交互式可视化报表，并推送管理者。管理者可通过PC或移动端快速查看数据报表，并可自行筛选或联动报表。
值得一提的是，通过织信低代码，原来需要数小时才能完成的报表制作，现在只需几分钟即可完成数据导入和报表更新，极大地降低了人力成本，提高了工作效率。这不仅让报表制作者从繁琐的工作中解脱出来，更有助于企业做出更加明智和及时的决策。
3、跨部门协同，IT与业务深度融合
从企业战略高度，引入业务-IT模式在软件开发中具有显著的提升效应，尤其在提高应用开发效率和质量方面。虽然IT部门在技术层面有明显的优势，但他们往往难以深入理解业务需求和问题。因此，将业务用户纳入开发过程是关键，这有助于IT部门更准确地把握业务需求，从而一次性解决实际问题。
织信低代码平台在促进业务-IT协作方面具有革命性意义。它成功打破了IT与业务部门之间的隔阂，将开发团队、设计师、质检人员和业务领导紧密结合在一起，共同参与应用开发项目。
通过抽象和最小化代码的使用，织信低代码平台显著加速了应用程序开发过程，确保数字化转型能够迅速实现业务目标。对于车企而言，使用低代码平台能够赋予开发团队更多权力，同时培养新的公民开发者和业务用户团队。这些团队在一个整体环境中共同努力，实现业务目标，并保持敏捷性。
4、权限精细化，全面增强数据安全
在汽车企业中，由于人员数量和层级众多，精细化的权限管理显得尤为重要。为了确保企业内部秩序井然，企业需要建立树形组织架构，并在此基础上将权限落实到个人。
权限管理作为企业管理中的核心环节，在实际操作中面临着诸多挑战。为了应对这些挑战，织信低代码平台推出了精细化的权限管理功能。该功能满足大型系统中复杂组织架构的设计需求，将资源、角色、权限授权统一组合到一个权限分组中，实现“统一管理，分级授权”。
通过权限管理，企业可以确保用户在使用系统生成的功能时，仅能访问到其具有权限的数据范围。这包括数据的查看、修改、删除等操作。针对不同的用户角色，企业可以设计不同的数据权限，确保用户只能访问与其身份、组织架构、岗位、角色相符的数据，避免越权访问。
这种精细化的权限管理方式不仅有助于企业实现统一要求，控制风险，提高效率，还能方便管理者把控全局，确保内部管理的顺畅性。同时，它还能增强数据安全性，确保企业核心信息不被泄露或滥用。
5、供应链协同，打造产业数字化生态
在汽车行业中，供应链协同在汽车生产体系里具有不可或缺的重要性。织信低代码平台以其智能化的信息交互能力，为企业量身定制了专业的供应链管理系统，从而大大优化了采购行为，降低了采购过程的随意性。
通过织信平台，汽车企业可以实现对供应商全生命周期的信息化管理，涵盖准入、等级分类、业务协同、整改优化以及淘汰等各个环节。此外，企业还能建立统一的供应商绩效考核机制，从源头上把控质量，确保供应商的透明、有序和高效管理。
不仅如此，织信供应链系统还能助力企业构建统一的门户、采购流程、业务内容、数据集成、业务消息和组织体系。对外，系统支持打通企业与外部供应商的协作通道，形成了一条完整的采购业务数据链，从而大幅提升了双方的业务执行效率。对内，系统还能实现与MES、ERP、PLM、WMS、OMS、TMS、OA等内部业务系统的深度整合，通过精准分析成本数据，为企业带来更加明智的决策支持。并助力企业打造一个更加高效、透明和智慧的产业数字化生态。
三、低代码加速汽车数字化转型的成功案例 某世界500强车企：利用织信低代码打通数字壁垒，构建集团一站式数字化系统。
1、面临的问题：
业务需求堆积，集团型公司存在大量的业务需求和变更，自身的研发人力难以快速响应，导致业务需求堆积。
研发成本过高，研发人员数量居高不下，导致整个公司在研发方面投入了大量的人力成本，公司运营成本亟需进行结构化调整。
数据信息壁垒，集团内部系统复杂多样，部门之间存在较大的数据壁垒，给公司信息化管理运营造成了巨大的阻碍，希望能够构建一套一站式信息化平台。
2、实施方案：
基于织信低代码开发平台的灵活性、可拓展性，集团自主搭建应用，创建中台和系统集成中台，赋能集团统一的业务、流程和数据中台，构建集团数字化生态。
建立应用市场，把集团内部通用类系统应用库集中管理起来，供内部学习参考与使用。
内外系统集成，深度集成公司内部各组织、部门的业务系统，链接各个外部系统数据和原有的内部系统数据。
构建数字化生态，让织信低代码成为集团内部研发团队的高效“开发工具”，帮助企业实现“平台级数字化生态”。
3、项目亮点：
构建多级、多语言、统一的集团门户和应用市场，快速构建可持续迭代的业务应用系统；
打通汽车和应用软件之间的协同，让汽车成为移动智能终端，分享软硬件底座、数据资源、出行场景，实现与生态伙伴的共赢发展，实现真正意义上的“软件定义汽车”。
完全满足所有复杂流程场景，统一的流程待办推送，让审批更高效。
4、实施效益：
应用开发敏捷化。通过使用织信低代码平台，解决了开发管理常年堆积的问题，开发周期平均缩短61%，人力投入减少47%。
管控集团一体化。实现集团内各组织、业务部门通用管理的一体化建设和灵活性搭配，提升工作效率。
战略部署灵活化。无论是多个系统的连接集成，还是匹配创新业务而开发的应用系统，都可以完美适配业务逻辑和场景需求，加速推进数字化生态建设的战略部署，提升集团信息化战略部署的灵活性。
结束语：
未来，随着织信团队持续加大对低代码平台的自主研发，并在业务流程管理、集成和云服务等领域发挥其技术和实践优势。通过深度融合产业与技术，积极推动汽车行业的数字化转型与技术创新，共同引领该行业向着更为环保、智能、高效的未来发展。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5997728bc54a2d276e67db44c731f030/" rel="bookmark">
			[Onnx简化库深度剖析] OnnxSimplifier和OnnxOptimizer解读-(2)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[Onnx简化库深度剖析] OnnxSimplifier和OnnxOptimizer解读-(2) 简介 上篇重点介绍了OnnxSimplifier的库，其中的FixedPointFn迭代优化函数利用到了OnnxOptimizer这个官方的优化库，大部分的优化细节是在OnnxOptimizer内的。因此本篇重点介绍一下OnnxOptimizer库的内部优化细节和逐个介绍每个优化pass和手段。 OnnxOptimizer基本概念原理 Pass 含义：所有优化项的基类，每个优化项必须拥有唯一的名字，用来注册和管理。概念： 优化类型(PassType)： Fuse: 会融合算子的优化项Nop: 会移除无用的算子的优化项Separate：Immutable：Replace： 会进行节点替换的优化项Other： 其他 (PassAnalysisType)： EmptyCountBased (PassEfficiency): PartialComplete (PassOptimizationType): NoneCompute: 针对计算优化Memory： 针对内存优化ComputeMemory： 针对计算和内存优化Stability： 稳定 基类的代码： class Pass { PassType pass_type; PassEfficiency pass_efficiency; PassOptimizationType pass_optimization_type; public: Pass(PassType pass_type, PassEfficiency pass_efficiency, PassOptimizationType pass_optimization_type); virtual ~Pass(); PassType getPassType() const { return this-&gt;pass_type; } PassEfficiency getPassEfficiency() const { return this-&gt;pass_efficiency; } PassOptimizationType getPassOptimizationType() const { return this-&gt;pass_optimization_type; } virtual PassAnalysisType getPassAnalysisType() const = 0; // virtual std::string getPassName() const = 0; // 返回优化项的名字 virtual bool initializePass(Graph &amp;) { // 可有可无的函数实现 return false; } virtual bool finalizePass(Graph &amp;) { // 可有可无的函数实现 return false; } virtual std::shared_ptr&lt;PostPassAnalysis&gt; runPass(Graph &amp;graph) = 0; // 子类必须实现该函数，用于运行模型优化 protected: // Iterates through the elements in the graph and counts the number of times // the transform is successfully run.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5997728bc54a2d276e67db44c731f030/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/33/">«</a>
	<span class="pagination__item pagination__item--current">34/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/35/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>