<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7af909771bd2d64c7b3522a5f511e4a0/" rel="bookmark">
			Linux ：软件包管理器yum
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 软件包yumyum语法yum常用命令yum源配置文件介绍更新yum源 查看已经安装软件的方法参考 软件包 大多数现代的类 Unix 操作系统都提供了一种中心化的机制用来搜索和安装软件。软件通常都是存放在存储库中，并通过包的形式进行分发。处理包的工作被称为包管理。包提供了操作系统的基本组件，以及共享的库、应用程序、服务和文档。软件包和软件包管理器, 就好比 “App” 和 “应用商店” 这样的关系.
包管理系统除了安装软件外，它还提供了工具来更新已经安装的包。包存储库有助于确保你的系统中使用的代码是经过审查的，并且软件的安装版本已经得到了开发人员和包维护人员的认可。
在配置服务器或开发环境时，我们最好了解下包在官方存储库之外的情况。某个发行版的稳定版本中的包有可能已经过时了，尤其是那些新的或者快速迭代的软件。然而，包管理无论对于系统管理员还是开发人员来说都是至关重要的技能，而已打包的软件对于主流 Linux 发行版来说也是一笔巨大的财富。
大多数包系统都是围绕包文件的集合构建的。包文件通常是一个存档文件，它包含已编译的二进制文件和软件的其他资源，以及安装脚本。包文件同时也包含有价值的元数据，包括它们的依赖项，以及安装和运行它们所需的其他包的列表。
虽然这些包管理系统的功能和优点大致相同，但打包格式和工具却因平台而异：
yum yum（ Yellow dog Updater, Modified）是一个在 Fedora 和 RedHat 以及 SUSE 中的 Shell 前端软件包管理器。基于 RPM 包管理，能够从指定的服务器自动下载 RPM 包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。
yum 提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。
需要root权限本地会有个yum的配置文件，告诉yum去哪些网站找资源。 首先要找一个yum库（源），然后确保本地有一个客户端（yum这个命令就是客户端），由yum程序去连接服务器。连接的方式是由配置文件决定的。通过编辑/etc/yum.repos.d/CentOS-Base.repo文件，可以修改设置。 yum 软件可以用 rpm 命令安装，安装之前可以通过如下命令查看 yum 是否已安装： rpm -qa | grep yum ... yum语法 yum [options] [command] [package ...] options：可选，选项包括-h（帮助），-y（当安装过程提示选择全部为 “yes”），-q（不显示安装的过程）等等。command：要进行的操作。package：安装的包名。 yum常用命令 列出所有可安裝的软件清单命令：
yum list | grep 软件包名 yum安装：
yum install -y 软件包名 yum卸载：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7af909771bd2d64c7b3522a5f511e4a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d008141c1697b04622a1955d43dd6e9/" rel="bookmark">
			QT lineEdit控件限制输入内容（自留 仅包含部分功能后续可能添加）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步.h包含头文件并在private下定义指针 #include &lt;QRegExpValidator&gt; 第二步.cpp文件中声明并设置限制参数
MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow) { ui-&gt;setupUi(this); //（"[0-4]"）表示输入0-4的值（"0,1"）表示只能输入0或1
class QRegExp regExp1("[0-4]"); ui-&gt;lineEdit_rate-&gt;setValidator(new QRegExpValidator(regExp1,this)); //默认输入第一位，即0-4的0
ui-&gt;lineEdit_rate-&gt;setText("0"); }
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bdc5f49906f2ccbe120f93bb0b2a137/" rel="bookmark">
			洛谷P5804 [SEERC2019]Absolute Game
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 链接：[SEERC2019]Absolute Game - 洛谷
思路：不管怎么找都会剩一个，既然如此就直接选一个留下来，每个数找一遍就行了，这个数满足的要求就是b组和它最近的两个数的最小绝对值在所有数中最大。
code： #include&lt;bits/stdc++.h&gt; using namespace std; long long q1[1005],q2[1005]; int main(){ int t,x,y,z,max=0,ans=0; scanf("%d",&amp;t); for(int i=1;i&lt;=t;i++) scanf("%d",&amp;q1[i]); for(int i=1;i&lt;=t;i++) scanf("%d",&amp;q2[i]); sort(q2+1,q2+t+1); for(int i=1;i&lt;=t;i++) { z=lower_bound(q2+1,q2+t+1,q1[i])-q2; if(z==1) { if(max&lt;q2[z]-q1[i]) max=q2[z]-q1[i]; } else if(z&gt;1&amp;&amp;z&lt;=t){ if(max&lt;q2[z]-q1[i]&amp;&amp;max&lt;q1[i]-q2[z-1]) max=min(q2[z]-q1[i],q1[i]-q2[z-1]); } else if(z&gt;t){ if(max&lt;q1[i]-q2[z-1]) max=q1[i]-q2[z-1]; } } printf("%d",max); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d33373ab10c9c684a1f2feb19c76f7b/" rel="bookmark">
			用C语言实现删除字符串中所有重复的字符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 要删除重复字符，首先要建立一个字符数组来存放字符串，建立一个char类型的一维数组初始化为零通过使用gets（）从键盘输入字符串，运用for循环来判断是否有重复字符如果有重复字符，将当前位置到字符串末尾向前移动一位，覆盖当前位置，从而达到删除重复字符在从当前位置的前一位再次进行循环，因为当前位置的字符可能还和前一个位置的字符一样（连续几个相同字符）最后输出字符串puts（）； #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(int argc, char *argv[]) { char a[100] = {0}; int n,i,j,k; printf("please input a:"); gets(a); puts(a); for(i=0;a[i];i++) { for(j=i+1;a[j];) { if(a[i] == a[j]) { for(k=j;a[k];k++) a[k] = a[k+1]; } else { j++; } } } puts(a); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0343cd759a96ac880abf8900a1ee767/" rel="bookmark">
			IDEA 找不到或无法加载主类（简单解决）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天我又一次遇到了这个问题——“找不到或无法加载主类”
个人觉得这种不是自己代码逻辑错误的问题非常恼人，很难找到思路。
问题描述： 因为我更改了我的包名，所以缓存没有清掉，重新执行还是执行的以前的缓存。
执行的地方已经变成了红色的。
解决方法 首先清一下缓存，选择下面这个选项
重点！！！！
选择rebuild，再次执行时不要再在上面选择运行，应该单击右键选择运行！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77e06e0891b1782349e1b7d7caba7958/" rel="bookmark">
			IDM最新版软件的安装下载和使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前一段时间跟帖发表了自己对IDM和油猴插件的一些看法，有很多网友就问我这IDM个软件的安装和使用方法。这两天闲下来把这两款软件和其他我经常使用的软件做了下整理，有需要的网友学习（大神请略过），不足之处，敬请谅解：
internet download manager(IDM下载器)是一款很不错的下载工具。有了internet download manager软件，可以提高你下载文件的速度，如果您在下载文件的时候，突然没网了，您可以使用IMD下载器的续传功能非常的方便。
internet download manager(IDM下载器)功能介绍
1、IDM下载器支持HTTP， FTP， HTTPS 和 MMS协议。idm不是p2p下载软件，因此无法用于下载通过bt和eMule发布的内容。
2、IDM下载器的续传功能可以恢复因为断线、网络问题、计算机当机甚至无预警的停电导致下传到一半的软件，具有动态档案分割、多重下载点技术，而且它会重复使用现有的联机，而不需再重新联机登入一遍，聪明的in-speed技术会动态地将所有设定应用到某种联机类型，以充分利用下载速度。
3、Internet Download Manager支持下载队列、防火墙和映射服务器、重新导向、cookies、需要验证的目录，以及各种不同的服务器平台。
此程序紧密地与Internet Explorer和Netscape Communicator结合，自动地处理你的下载需求，此程序还具有下载逻辑功能、检查并读，以及多种偏好设定。
internet download manager(IDM下载器)安装步骤
1、首先下载internet download manager(IDM下载器)软件包，得到rar格式压缩包
2、鼠标右键点击压缩包选择解压到当前文件夹，找到IDMan.exe文件
3、双击exe文件，就可以进入internet download manager(IDM下载器)中文版主界面，无需安装
internet download manager(IDM下载器)使用方法
1、打开下载的internet download manager(IDM下载器)软件，打开软件后点击【下载】。
2、在弹出的选项中点击【选项】。
3、在打开的internet download manager(IDM下载器)选项设置窗口中，选项您要用到的浏览器，选择完成后点击【确定】。
4、打开一个播放的视频，您可以看到视频的右上角显示了一个下载按钮，点击【下载】。
5、在打开的下载窗口中，您可以选择文件的保存位置，选择完成后点击【开始下载】。
耐心等待idm下载完成就可以了。
IDM插件浏览器安装方法
打开浏览器设置选项，找到更多工具，点击开发人员的工具选项，
然后把从网站下载下来的IDM插件直接拖到浏览器窗口即可添加。
安装后浏览器上会出现IDM的图标
在IDM无法下载的情况下，还有几款软件能够很好的补充它的不足，由于各种原因，在此不方便说明，敬请谅解！
油猴插件
1.下载油猴插件CRX文件。离线安装油猴插件的方法参照：chrome插件的离线安装方法。记得用最新(谷歌浏览器)。在浏览器输入Greasy Fork - 安全、实用的用户脚本大全，进入浏览器的扩展程序界面，把“crx安装包”下载到桌面，然后打开Chrome右上角的菜单→更多工具→扩展程序页面，把“crx安装包”拖到页面里安装
如何通过油猴安装第三方扩展程序？
其实，非常简单，你只要进入你想安装的第三方插件的网址，例如这个跳过网站等待、验证码及登录，接着点击一下安装此脚本，等待一下，就可以在油猴的管理面板中看到我们新安装的插件了。像这个插件，看到它的名字就知道是什么作用的了，非常棒，可以跳过网站的倒计时等等!
油猴插件有什么用?
说起油猴插件的作用还真不少，就可以解决视频网站的vip会员问题。在安装上油猴插件后我们还要安装上相应的脚本才能达到具体的功能，这就需要我们到油猴脚本网站上搜到我们所需要的脚本，安装上以后就会实现相应的功能。
IDM最新版下载地址:
https://wm.makeding.com/iclk/?zoneid=34275
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/669262cdc6d352bc65b1f5d784db52f9/" rel="bookmark">
			HTTP请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		127.0.0.1
127.0.0.1
是本机回送地址；即主机IP堆栈内部的IP地址，主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，协议软件立即返回，不进行任何网络传输。
这种形式的地址不得出现在主机之外，拾取定向到127.0.0.1的流量的路由器应该立即丢弃数据包。这可确保没有专门用于主机上的流量进入Internet。
本机回送
即地址为127.0.0.1的数据包不离开主机发送，不是发送到本地网络或internet，它只是在自身上“环回”，发送数据包的计算机成为收件人。
保留地址
127.0.0.0–127.255.255.255，为特定目的保留地址可以很容易地为不同的IP地址建立一般规则和行为。
IPv4：127.0.0.1
IPv6：0000:0000:0000:0000:0000:0000:0000:0001，或截断为::1
localhost 是本地计算机的默认WEB发布路径
如果你最终打算通过LAN或Internet托管服务器或网站，你可以在同一台计算机上运行服务器和客户端，以确保所有基础首先正常工作。例如，如果你在本地计算机上托管了一个专用的Minecraft服务器，你可以通过输入127.0.0.1作为IP地址来连接到它。这同样适用于几乎所有本地托管的服务器。消除与网络相关的复杂性，例如端口配置和延迟问题，可以提高故障排除过程的效率。
本地主机
在大多数情况下，localhost只是默认情况下引用127.0.0.1的简写。它是可以更改的，编辑你的主机文件，你可以让localhost引用任何127.XXX保留地址。你还可以创建其他localhost，例如localhost2，例如可以引用127.0.0.2。
HTTP请求
DNS解析，建立TCP连接，发起HTTP请求
服务器接收HTTP请求，进行处理，返回数据浏览器接收返回的数据，处理数据
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/987976858f352eaaf1705bcc78b26cb3/" rel="bookmark">
			二叉树中序遍历习题引发的时间空间复杂度思考：内存角度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天做了一道简单的二叉树遍历。
首先我们需要了解什么是二叉树的中序遍历：按照访问左子树——根节点——右子树的方式遍历这棵树，而在访问左子树或者右子树的时候我们按照同样的方式遍历，直到遍历完整棵树。因此整个遍历过程天然具有递归的性质，我们可以直接用递归函数来模拟这一过程。
先来看我写的代码：
class Solution { public: vector&lt;int&gt;tmp; vector&lt;int&gt; inorderTraversal(TreeNode* root) { if(root==nullptr){return tmp;} inorderTraversal(root-&gt;left); tmp.push_back(root-&gt;val); inorderTraversal(root-&gt;right); return tmp; } }; 官方的代码：
class Solution { public: void inorder(TreeNode* root, vector&lt;int&gt;&amp; res) { if (!root) { return; } inorder(root-&gt;left, res); res.push_back(root-&gt;val); inorder(root-&gt;right, res); } vector&lt;int&gt; inorderTraversal(TreeNode* root) { vector&lt;int&gt; res; inorder(root, res); return res; } }; 是不是看起来我的代码好简洁，是吧？可是我发现了一个问题，我的时间空间复杂度都不如官方代码，尤其是时间复杂度：
我的代码的用时：
我就在想问题出在哪？
细心的朋友可以看出两个不同之处：
官方的代码是把容器以形参的方式传入到函数中。
有什么作用？
可以看到，递归的代码在内存中会复制多份，里面的容器也会频繁使用。当函数传入参数，内存就不会频繁去找这个容器所在的地址，直接拿来就可以使用。而且函数中 容器 是以引用的形式传入，函数中只会有一个容器的副本，并没有完全copy。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33f42a064213d81628701cb13098ee02/" rel="bookmark">
			开源对象存储方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.MINIO2.Ceph3.OpenIO4.Ozone5.TFS 是淘宝开源的，但是目前已经很少有人维护它并且也不是很活跃。6.GlusterFS为本身是一个非常成熟的对象存储的方案，2011被收购了，原班的人马又做了另外一个存储系统MINIO。7.不能自定义名称的有领英的Ambry，MogileFS8.HBase MOB9.OpenStack Swift10. SeaweedFS，是一个独立的 Apache 许可开源项目，存储数十亿级的文件，快速响应文件 1.MINIO 官网：https://min.io/
github: https://github.com/minio/minio
部署和安装：https://cloud.tencent.com/developer/article/1893329
https://www.talkwithtrend.com/Article/253471
https://www.cnblogs.com/zimug/p/13444086.html
MINIO 是一个开源的对象存储服务，基于 Apache License v2.0 协议，兼容 Amazon S3 云端存储服务，同时也支持本地磁盘、NAS、NFS、公有云存储、分布式云存储，适合用于存储非结构化数据，比如：图片、视频、日志、备份、容器镜像等，对象大小最大能支持到 5TB.
MinIO 是一款开源云存储软件，提供高性能分布式对象存储，专为大规模数据基础设施而设计。它与 Amazon S3 API 兼容，并且它在 GitHub 上拥有超过 26,000 颗星，有超过 680 名贡献者在为它工作。
MinIO 服务器存储所有类型的非结构化数据，例如照片、视频、日志文件等。它也可在开源 Apache V2 许可下使用，许多最强大的大数据和机器学习应用程序都使用 MinIO S3 对象存储。您可以在 MinIO 网站上查看许多其他功能。
Minio是目前全世界增长最快的对象存储系统。
高性能 MinIO 是全球领先的对象存储先锋，目前在全世界有数百万的用户. 在标准硬件上，读/写速度上高达183 GB / 秒 和 171 GB / 秒。对象存储可以充当主存储层，以处理Spark、Presto、TensorFlow、H2O.ai等各种复杂工作负载以及成为Hadoop HDFS的替代品。MinIO用作云原生应用程序的主要存储，与传统对象存储相比，云原生应用程序需要更高的吞吐量和更低的延迟。而这些都是MinIO能够达成的性能指标。 可扩展性 MinIO利用了Web缩放器的来之不易的知识，为对象存储带来了简单的缩放模型。这是我们坚定的理念 “简单可扩展.” 在 MinIO, 扩展从单个群集开始，该群集可以与其他MinIO群集联合以创建全局名称空间, 并在需要时可以跨越多个不同的数据中心。通过添加更多集群可以扩展名称空间, 更多机架，直到实现目标。 云原生支持 MinIO 是在过去4年的时间内从0开始打造的一款软件 ，符合一切原生云计算的架构和构建过程，并且包含最新的云计算的全新的技术和概念。其中包括支持Kubernetes 、微服和多租户的的容器技术。使对象存储对于 Kubernetes更加友好。 开放全部源代码 + 企业级支持 MinIO 基于Apache V2 license 100% 开放源代码 。这就意味着 MinIO的客户能够自动的、无限制、自由免费使用和集成MinIO、自由的创新和创造、 自由的去修改、自由的再次发行新的版本和软件.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33f42a064213d81628701cb13098ee02/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50fdf704b2cc38ef96581b13a04eda41/" rel="bookmark">
			数据结构——查找の选择题整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		顺序查找和折半查找 1、折半查找和二叉排序树的时间性能（）
A、相同
B、有时不相同
C、完全不同
D、无法比较
解析：选B
折半查找的性能可以用二叉排序树来衡量，是O(log2n)，但是二叉排序树的时间性能还与存入的数据有关，如果是性能比较好的情况，则为O(log2n)，如果形成了单侧二叉树，时间性能就为O(n)。如下图：
树型查找 1、含有20个结点的平衡二叉树的最大深度为（）
A、4
B、5
C、6
D、7
解析：选C
平衡二叉树的结点数递推公式为：n0=0，n1=1，n2=2，nh=1+nh-1+nh-2。其中h为二叉树层数，nh表示构造h层二叉树最少需要多少个结点。
2、下列关于红黑树和AVL树的描述中，不正确的是（）
A、两者都属于自平衡二叉树
B、两者插入、删除、查找的时间复杂度都相同
C、红黑树插入和删除过程至多有2次旋转操作
D、红黑树的任一结点的左右子树高度之差不超过2
解析：选C
对于A，自平衡二叉树是指二叉树当达不到平衡时，会自动进行调节，使之再次平衡。显然，红黑树和AVL树都是自平衡二叉树。
对于B，两者插入、删除、查找的时间复杂度都
对于C，在红黑树删除时，可能会出现由情况1（x的兄弟结点w是红色的）变为情况2（x的兄弟结点w是黑色的，w的左孩子是红色的，w的右孩子是黑色的）再变为情况3（x的兄弟结点w是黑色的，w的右孩子是红色的）
对于D，因为红黑树中，根节点到任意叶结点的路径上经过的黑色结点个数都相等，且除了根节点和第二层的叶结点之间，不允许有红红或黑黑的情况出现，红黑必须交叉出现，因此如果高度之差超过2，必定会出现红红或黑黑的情况或者是经过黑色结点数不相等的情况。
3、下列关于红黑树的说法中，正确的是（）
A、红黑树是一种特殊的平衡树
B、如果红黑树的所有结点都是黑色的，那么它一定是一棵满二叉树
C、红黑树的任何一个分支结点都有两个非空孩子结点
D、红黑树的子树也一定是红黑树
解析：选B
对于A，平衡树要求左右子树高度之差不超过1，红黑树只要求不超过2即可。因此不是平衡树。
对于B，因为红黑树的叶结点必须是黑色的，根节点是黑色的，除了第一层了第二层可以连着出现黑黑的情况，其他不允许出现黑黑和红红的情况，且到达叶结点的路径上经过的黑色结点数必须相等，综上所述，所有结点都是黑色的红黑树只能有下图左边两种情况，全都是满二叉树。下图最右边的图可以看到不满足“到达叶结点的路径上经过的黑色结点数必须相等”。
对于C，可以只有一个孩子结点，如下图的右子树中红色的结点，只有一个孩子结点。
对于D，红黑树子树的根结点可能是红色的，因此就不是红黑树，如下图，虚线框里的左子树就不是红黑树。
4、在任意一棵非空平衡二叉树（AVL树）T1中，删除某节点v之后形成平衡二叉树T2，再将v插入T2形成平衡二叉树T3。下列关于T1与T3的叙述中，正确的是（）
a.若v是T1的叶结点，则T1与T3可能不相同
b.若v不是T1的叶结点，则T1与T3一定不相同
c.若v不是T1的叶结点，则T1与T3一定相同
A、仅a
B、仅b
C、仅a和b
D、仅a和c
解析：选A
在下面的图中，分别演示了T1与T3不相等和相等的情况。其中蓝色的结点表示要删除或刚添加的结点。
下图分别是v不是T1的叶结点，T1与T3的情况，由图可知，T1与T3可能相同也可能不相同
B树和B+树 1、具有n个关键字的m阶B树，应有（）个叶结点
A、n+1
B、n-1
C、mn
D、nm/2
解析：选A
叶结点对应的是查找失败的情况，因此求叶结点数量就是求查找失败的数量，即n+1
2、含有n个非叶结点的m阶B树中至少包含（）个关键字
A、n(m+1)
B、n
C、n(⌈ m/2 ⌉-1)
D、(n-1)(⌈ m/2 ⌉-1)+1
解析：选D
⌈ m/2 ⌉-1表示除了根结点之外，其他非叶子结点至少含有的关键字数，除根结点外，共有n-1个非叶子结点，因此共有(n-1)(⌈ m/2 ⌉-1)给关键字，根节点最少可以有1个关键字，因此至少包含关键字数量为：(n-1)(⌈ m/2 ⌉-1)+1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50fdf704b2cc38ef96581b13a04eda41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40f7c78dcbf7edc5097297e181a4104a/" rel="bookmark">
			Java数组的使用和方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、数组的特点
大小固定连续内存地址存储的数据类型固定数组是保存在堆内存中，因此数组是对象 二、java中定义数组的方式
第一种： 数据类型[] 变量名称 = new 数据类型[size];第二种： 数据类型[] 变量名称 = new 数据类型[]{值1，值2，......};第三种： 数据类型[] 变量名称 = {值1，值2，......}; 代码示例：
int[] array1 = new int[4]; //第一种 int[] array2= new int[]{1,2,3,4,5}; //第二种 int[] array3 = {10,20,40,50}; //第三种 二、数组的使用
1.数组的长度
数组的长的即元素的个数。 数组对象.length //属性
代码示例：
public static void main(String[] args){ int[] array3 = {1,2,3,4,5}; System.out.print(array3.length); } /** *输出结果为： *5 * */ 注意：数组的每一元素都有其对应的下标，下标从0开始，想找到这个数组中的某个数据，是通过数组的下标来进行访问的。
数组对象[下标] //通过下标来访问元素的个数
2.下标越界
数组下标从0开始，范围是[0,arr.length),为左闭右开区间，或者[0,arr.length-1]
如下代码是错误的❌
public static void main(String[] args){ int[] array3 = {1,2,3,4,5}; System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40f7c78dcbf7edc5097297e181a4104a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5977d79367a6628a8126be5c16c3dd24/" rel="bookmark">
			ZUFEOJ平台【求一个整数的各位数字】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【题目描述】
输入一个整数，求它的各位数字。
视频讲解：https://v.youku.com/v_show/id_XNDg0NjY3NDM1Ng==.htmlhttps://v.youku.com/v_show/id_XNDg0NjY3NDM1Ng==.html
【输入格式】
-1234 【输出格式】
4 3 2 1 【输入样例 】
520 【输出样例】
0 2 5 【数据范围与提示】
输出各位数字之间有2个空格,
【分类标签】
循环http://acm.ocrosoft.com/problemset.php?search=%E5%BE%AA%E7%8E%AF
ZUFEOJ平台的网址是：首页 - ZUFEOJhttp://acm.ocrosoft.com/index.php 【完整代码】
#include &lt;iostream&gt; #include &lt;cmath&gt; using namespace std; int main() { int n,x; cin&gt;&gt;n; while (abs(n)) { if (n&lt;0) n=n*-1; cout&lt;&lt;n%10&lt;&lt;" "; n=n/10; } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cea0221403a232d76fb72171ba623812/" rel="bookmark">
			【cmake】CMakeList添加库|添加头文件|添加路径|add_executable、add_library、target_link_libraries|添加编译选项|宏开关...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
官网查阅
开胃菜例子
CMakeLists生成和添加依赖库
CMakeLists更多小例子
生成.so共享库文件
调用.so共享库文件
生成一个可执行程序的 CMakeList
生成一个.so动态库的 CMakeList add_library(生成库)，target_link_libraries(生成目标连接的库)，set_target_properties
CMAKE 添加编译选项|-g编译参数/选项
包含文件的的目录include_directories
优化项|优化等级
Cmake设置优化等级| cmake 生成 debug和 release 版
设置默认构建类型
CMake设置编译参数/选项
如何在cmakelists中加入-ldl编译选项
CMake指定gcc,g++版本编译
CMake 关闭警告的方法
关闭编译器优化
CMakeLists 实现动态宏开关
去掉编译优化
CMake--List用法
CmakeLists.txt单行注释和多行注释 CMakeList 通配符
其他未归类
add_custom_target 自定义命令
add_dependencies Cmake条件判断指令|if 判断优先级
设置编译时和程序运行时去哪个目录找动态库
#指定运行时动态库的加载路径
#指定链接时动态库的路径
cmake install 和打包设定
CMakeLists.txt单行注释和多行注释
target_link_libraries 中的PRIVATE, PUBLIC, INTERFACE 区别
作者：bandaoyu，持续更新，链接:https://blog.csdn.net/bandaoyu/article/details/115165199
官网查阅 CMake 3.22.0-rc1文档：https://cmake.org/cmake/help/latest/search.html?q=add_library
https://cmake.org/cmake/help/v3.23/manual/cmake-commands.7.html
CMake Cookbook：《CMake菜谱(CMake Cookbook中文版)》 ：https://www.bookstack.cn/read/CMake-Cookbook/content-preface-preface-chinese.md
开胃菜例子 CMakeLists生成和添加依赖库 原文;cmake之生成动态库：https://www.cnblogs.com/pandamohist/p/13408455.html
1、目录结构
│ CMakeLists.txt │ index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cea0221403a232d76fb72171ba623812/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27e72a75aa47aaa4e9eec19071541137/" rel="bookmark">
			【ceph】CEPH源码解析：读写流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相同过程 Ceph的读/写操作采用Primary-Replica模型，客户端只向Object所对应OSD set的Primary OSD发起读/写请求，这保证了数据的强一致性。当Primary OSD收到Object的写请求时，它负责把数据发送给其他副本，只有这个数据被保存在所有的OSD上时，Primary OSD才应答Object的写请求，这保证了副本的一致性。
写入数据
这里以Object写入为例，假定一个PG被映射到3个OSD上。Object写入流程如图所示。
当某个客户端需要向Ceph集群写入一个File时，首先需要在本地完成前面所述的寻址流程，将File变为一个Object，然后找出存储该Object的一组共3个OSD，这3个OSD具有各自不同的序号，序号最靠前的那个OSD就是这一组中的Primary OSD，而后两个则依次Secondary OSD和Tertiary OSD。
找出3个OSD后，客户端将直接和Primary OSD进行通信，发起写入操作(步骤1)。 Primary OSD收到请求后，分别向Secondary OSD和Tertiary OSD发起写人操作(步骤2和步骤3)。当Secondary OSD和Tertiary OSD各自完成写入操作后，将分别向Primary OSD发送确认信息(步骤4和步骤5)。当Primary OSD确认其他两个OSD的写入完成后，则自己也完成数据写入，并向客户端确认Object写入操作完成(步骤6)。
之所以采用这样的写入流程，本质上是为了保证写入过程中的可靠性，尽可能避免出现数据丢失的情况。同时，由于客户端只需要向Primary OSD发送数据，因此在互联网使用场景下的外网带宽和整体访问延迟又得到了一定程度的优化。
当然，这种可靠性机制必然导致较长的延迟，特别是，如果等到所有的OSD都将数据写入磁盘后再向客户端发送确认信号，则整体延迟可能难以忍受。因此， Ceph可以分两次向客户端进行确认。当各个OSD都将数据写入内存缓冲区后，就先向客户端发送一次确认，此时客户端即可以向下执行。待各个OSD都将数据写入磁盘后，会向客户端发送一个最终确认信号，此时客户端可以根据需要删除本地数据。
分析上述流程可以看出，在正常情况下，客户端可以独立完成OSD寻址操作，而不必依赖于其他系统模块。因此，大量的客户端可以同时和大量的OSD进行并行操作。同时，如果一个File被切分成多个Object，这多个Object也可被并行发送至多个OSD上。
从OSD的角度来看，由于同一个OSD在不同的PG中的角色不同，因此，其工作压力也可以被尽可能均匀地分担，从而避免单个OSD变成性能瓶颈。
读取数据
如果需要读取数据，客户端只需完成同样的寻址过程，并直接和Primary OSD联系。在目前的Ceph设计中，被读取的数据默认由Primary OSD提供，但也可以设置允许从其他OSD中获取，以分散读取压力从而提高性能。
原文链接：https://blog.csdn.net/lhc121386/article/details/113488420
文件读写流程 libcephfs.cc 调用 Client.cc中的client 。client::_write
cephfs：用户态客户端write 摘自：https://zhuanlan.zhihu.com/p/109573019
还是通过cp命令来研究write。
cp 2M_test /mnt/ceph-fuse/test 从fuse到cephfs客户端的函数流程如下
client::_write就是核心函数，可以简单分为两个重要部分：get_caps和file_write部分。代码如下。
int Client::_write(Fh *f, int64_t offset, uint64_t size, const char *buf, const struct iovec *iov, int iovcnt) { // offset = 0, size = 128K, buf是要写的内容，iov = NULL，iovcnt = 0 Inode *in = f-&gt;inode.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27e72a75aa47aaa4e9eec19071541137/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88a603bba9e4f0a9baced1c5338f4542/" rel="bookmark">
			【ceph】Rados的客户端RadosClient|MonClient|Osdc
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍Ceph客户端方面的某些模块的实现。
(摘抄自：https://blog.csdn.net/CSND_PAN/article/details/78707756)
客户端主要是实现了接口，让外部可以调用实现访问操作。上层可以通过调用这些接口来访问Ceph存储。
Ceph的客户端通过一套名为librados的接口进行集群的访问，这里的访问包括：
1)对集群的整体访问
2)对象的访问
两类接口，这套接口(API)包括C、C++和Python常见语言的实现，接口通过网络实现对Ceph集群的访问。在用户层面，可以在自己的程序中调用该接口，从而集成Ceph集群的存储功能，或者在监控程序中实现对Ceph集群状态的监控。上述接口与Ceph集群的关系如图1所示。
RADOS的客户端API 上述接口几乎包括了对Ceph集群和其中数据的所有访问功能：
集群的整体访问：包括连接集群、创建存储池、删除存储池和获取集群状态等等。
对象访问：是指对存储池中对象的访问，包括创建删除对象、向对象写数据或者追加数据和读对象数据等接口。
上述功能通过Rados和IoCtx两个类实现，两个类的主要函数如图2所示(这里仅是示例，实际接口数量要多很多，具体参考源代码)。
为了了解如何使用这些API，我们这里给出一些代码片段。具体完整的代码大家可以参考Ceph官方的示例代码。
librados::IoCtx io_ctx;
const char *pool_name = "test";/* 创建进行IO处理的上下文，其实就是用于访问Ceph的对象 */
cluster.ioctx_create(pool_name, io_ctx);/* 同步写对象 */
librados::bufferlist bl;
bl.append("Hello World!"); /* 对象的内容 */
/*写入对象itworld123*/
ret = io_ctx.write_full("itworld123", bl); /* 向对象添加属性，这里的属性与文件系统
* 中文件的扩展属性类似。 */
librados::bufferlist attr_bl;
attr_bl.append("en_US");
io_ctx.setxattr("itworld123", "test_attr", attr_bl);
/* 异步读取对象内容 */
librados::bufferlist read_buf;
int read_len = 1024;
/* 创建一个异步完成类对象 */
librados::AioCompletion *read_completion = librados::Rados::aio_create_completion();
/* 发送读请求 */
io_ctx.aio_read("itworld123", read_completion, &amp;read_buf, read_len, 0);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88a603bba9e4f0a9baced1c5338f4542/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fd10fe1420e83c83c4a40caaefc3bf6/" rel="bookmark">
			【性能】性能分析工具VTune|perf相关性工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
简介
与perf的区别
入门：使用Intel VTune Profiler进行性能分析及优化
简介 VTune是 Intel 提供性能分析软件，VTune Amplifier XE 2011 集成了Intel VTune Performance Analyzer 和 Thread Profiler的主要功能，同时吸取了Performance Tool Utility 这个产品的优点。
其中，Vtune Performance Analyzer是性能分析工具，找到软件性能热点、瓶颈部分；
Vtune Threading Profiler是线程性能检测工具 , 分析负载平衡、同步开销过大等线程相关的性能问题。
VTune Amplifier XE 可以指明在相关的硬件资源上应用程序的改善点，具体来说，使用该软件用户获取的信息主要有以下几点：
l 确定占用大量处理器时间的区域(热点)；
l 查看应用运行过程中的情况(通过检测绑定process)；
l 没有充分的有效利用可用的处理器时间的代码；
l 影响应用程序性能的同步对象；
l 应用程序是否浪费时间在输入输出操作上，在哪里浪费的，为何浪费；
l 对比不同的同步方法、不同的线程数量、不同的算法之间对性能的影响；
l 线程的活动状态和状态的转换；
l 代码中与硬件相关的性能瓶颈(如缓存缺失、分支预测失败等)；
提供用户界面和命令行下使用的两种模式。普通用户可以获取30天的免费评估版本，下载网址：http://software.intel.com/en-us/articles/intel-vtune-amplifier-xe/，相关教程可以在以下网站查看：http://software.intel.com/zh-cn/forums/185/。
(参考：https://www.cnblogs.com/xingmuxin/p/11328472.html)
与perf的区别 perf 看不到L3cache 等硬件特性，需要更强大的工具
入门：使用Intel VTune Profiler进行性能分析及优化 (摘自：、https://blog.csdn.net/yaojingqingcheng/article/details/120335335)
Intel VTune Profiler是一个全平台的性能分析工具，可以帮助你快速发现和分析应用程序及整个系统的性能瓶颈。工具支持分析本地或远程的Windows，Linux及Android应用，这些应用可以部署在CPU，GPU，FPGA等硬件平台上。支持分析的语言包括：DPC++， C，C++，C#，Fortran，OpenCL，Python，Go，Java，汇编等。
VTune集成了多种性能分析方法
性能快照(Performance Snapshot)生成程序性能问题的分析总结。在总结报告里，会推荐你采用哪些具体的分析手段进行下一步的分析和优化。
算法(ALGORITHM)可以帮助你分析程序中所采用的算法的效率，理解程序最花时的地方在哪里。算法分析组包含了热点，异常探测，内存消耗三种分析方法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fd10fe1420e83c83c4a40caaefc3bf6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63a5b53adb38a412de9fba16858ba53a/" rel="bookmark">
			跑酷小游戏C&#43;&#43;源代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		话不多说，直接上代码！
#include&lt;bits/stdc++.h&gt;	#include&lt;windows.h&gt; #include&lt;stdio.h&gt; #include&lt;conio.h&gt; #include&lt;time.h&gt; #define Nor if(B[b].x&lt;5) B[b].x=5; #define Out1 Bx1-Bvx1&lt;=6||Bx1-Bvx1&gt;=28||By1-Bvy1&lt;=7||By1-Bvy1&gt;=27 #define Out2 Bx2-Bvx2&lt;=6||Bx2-Bvx2&gt;=28||By2-Bvy2&lt;=7||By2-Bvy2&gt;=27 #define Chang1 {Bwhat1=0;Bvx1=Bvy1=0;memset(Bgo1,0,sizeof(Bgo1));} #define Chang2 {Bwhat2=0;Bvx2=Bvy2=0;memset(Bgo2,0,sizeof(Bgo2));} #define Chang3 {Bwhat3=0;Bvx3=Bvy3=0;memset(Bgo3,0,sizeof(Bgo3));} using namespace std; int ti(float a) {return ((int)(a*10+5))/10;} void Setpos(float x,float y){COORD pos;pos.X=ti(y*4)/2;pos.Y=ti(x);SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE),pos);} void Color(int a){if(a==0) SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_INTENSITY|FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE);if(a==1) SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_INTENSITY|FOREGROUND_GREEN|FOREGROUND_BLUE);if(a==2) SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_INTENSITY|FOREGROUND_GREEN);if(a==3) SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_INTENSITY|FOREGROUND_RED|FOREGROUND_BLUE);if(a==4) SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_INTENSITY|FOREGROUND_RED);if(a==5) SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_INTENSITY|FOREGROUND_RED|FOREGROUND_GREEN);if(a==6) SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_INTENSITY|FOREGROUND_BLUE);if(a==7) SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE);if(a==8) SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_RED);if(a==9) SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),BACKGROUND_INTENSITY|BACKGROUND_GREEN|BACKGROUND_BLUE);if(a==10) SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),BACKGROUND_INTENSITY|BACKGROUND_RED|BACKGROUND_BLUE);if(a==11) SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_RED|FOREGROUND_BLUE);if(a==12) SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_RED|FOREGROUND_GREEN);if(a==13) SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_INTENSITY);if(a==14) SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_GREEN|FOREGROUND_BLUE);} int Blomax,Ren,Exp,Expmax,Lv,Lvl,Ice,Drug,ar1,ar2,Tar1,Tar2,bl,br,Win,T,Tb,Sy,Up,Upt,Down,u1,u2,Kill,Killb,L,Ll[4],Li,D,Gd[10],Biao,Fire,Fir,Water,Thun,Wind,Magne,I[20][2],ib,Dis,Disb,Dis1,Disb1,Boss,Bblo,Bblomax,Bwhat1,Bwhat2,Bwhat3,Bgo1[10],Bgo2[10],Bgo3[10],Bbr,Bbl,Bl[4]; float X,Y,Vx,Vy,Ding,Blo,Hui,Bx1,By1,Bx2,By2,Bx3,By3,Bvx1,Bvy1,Bvx2,Bvy2,Bvx3,Bvy3,Bway[1001][2]; struct bullet{float x,y,vx,vy;int what;int a,t,How;int life;bool kill;}B[100001]; void Map(int a,int b); void Pan(int a,float x,float y,int b){ float Nox[4],Noy[4];Nox[0]=X,Noy[0]=Y; if(Down==1&amp;&amp;X==22) Nox[1]=X+1,Noy[1]=Y-0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63a5b53adb38a412de9fba16858ba53a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6cab96b0ef821203472a10d1633202e/" rel="bookmark">
			操作系统之进程问题总结——进来背书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博客主页：🏆看看是李XX还是李歘歘 🏆
🌺每天不定期分享一些包括但不限于计算机基础、算法、后端开发相关的知识点，以及职场小菜鸡的生活。🌺
💗点关注不迷路，总有一些📖知识点📖是你想要的💗
⛽️今天的内容是6000字的进程相关的知识点，篇幅较长，建议先收藏后阅读⛽️💻💻💻
目录 进程
1.进程的概念
2.进程的特征
3.进程的组成部分
4.进程的状态及其转化关系
5.进程的切换 6.进程间的通信
共享内存
消息传递
管道通信
套接字Socket
线程
线程的概念
线程的属性
线程的分类
多线程模型
进程和线程的关系
线程与进程的区别
处理机的调度
调度分级
调度方式
调度算法
进程同步
同步遵循的准则
实现临界区互斥的基本方法
软件实现
死锁
死锁概念
死锁产生的必要条件
死锁的处理逻辑
进程 1.进程的概念 为了更好的描述和控制程序的并发，实现操作系统的并发性和共享性，引入了进程的概念，为每一个进程分配一个专门的数据结构：进程控制块PCB(常驻内存)，保存运行期间进程的数据，PCB 是进程存在的唯一标志。
进程是系统进行资源分配的单位，且每个进程拥有独立的地址空间。（即进程是资源分配和调度的一个独立单元）
2.进程的特征 动态性（进程状态在动态变化），并发性（多个进程实体同时存在于内存中），独立性（有独立的资源和调度），异步性（进程按照各自独立的、不可预知的速度向前推进，异步会导致执行结果不可再现，所以需要配置相应的同步机制），结构性（进程由程序段、数据段和PCB组成）。
3.进程的组成部分 程序段
代码数据，能被进程调度程序调度到CPU执行的程序代码。注意，程序可被多个进程共享。 数据段
与程序逻辑本身相关的数据，可以是进程对应的程序加工处理的原始数括，也可以是程序执行时产生的中间或最终结果。 PCB
进程描述信息：进程标识符（PID）--标志各个进程；用户标识符（UID）--标志进程所属用户进程控制和管理信息：进程当前状态，进程优先级，处理机占用时间等资源分配清单：各种堆栈指针和代码段、数据段指针，处理机相关信息：处理机各种寄存器的值 就绪队列、阻塞队列等队列组织方式：
链接方式将同一状态的PCB链接成一个队列，不同状态对应不同的队列，也可把处于阻塞态的进程的PCB，根据其阻塞原因的不同，排成多个阻塞队列。　索引方式将同一状态的进程组织在一个索引表中，索引表的表项指向相应的PCB，不同状态对应不同的索引表，如就绪索引表和阻塞索引表等。 4.进程的状态及其转化关系 进程具备五种状态，分别为：
创建状态：进程正在被创建，尚未转到就绪状态，创建进程需要申请一个空白的PCB，并向 PCB写一些控制和管理进程的信息，然后由系统分配资源，将进程转入就绪状态。
就绪状态：进程已处于准备执行的状态，获得了除处理机以外的一切所需资源。
执行状态：进程在处理机上运行。在单处理机环境下，每一时刻最多只有一个进程运行。
阻塞状态：进程正在等待某一事件（服务请求）而暂停运行，如等待某资源变为可用（不包括处理机）或等待输入输出 I/O 完成，即使处理机空闲，该进程也不能运行。
结束状态：进程正从系统中消失，这可能是进程正常结束或其他原因中断退出运行，当进程需要结束运行时，系统首先必须置该进程为结束状态，然后再进一步处理资源释放和回收。
注意：
就绪队列在内存中，阻塞队列在外存。执行态变为阻塞态是主动的行为，自身进程需要的东西在忙，主动的去申请和退出(资源)；阻塞态变为就绪态为被动的行为，需要其他相关进程的协助，被动等待资源的释放。 状态变化触发机制：
从运行态到阻塞态---进程的资源不够时从运行态到就绪态---进程的时间片用完了，进程需要重新等待cpu的使用。从就绪态到运行态---获得了处理机的资源从阻塞态到就绪态---所需资源准备好了 5.进程的切换 进程的切换是指处理机从一个进程的运行转到另一个进程上运行，在这个过程中，进程的运行环境产生实质性的变化。过程如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6cab96b0ef821203472a10d1633202e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0df2544f60a003c5fc20b693f72f3b5d/" rel="bookmark">
			Python Excel操作 xlwt xlrd xlutils三个模块的使用，不删除表，往后累加数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
主要代码
其他类引用代码
Python对Excel表格进行操作（不删除表，往后累加数据）
用时需改变五个参数和自己重新定义AddData方法
self.tableName='设置速度报文测试'#表名
self.FileName='./SocketLog.xlsx'#文件路径+文件名
self.col=('次数','发送时间','接收时间','耗时','备注')#列名
self.colNum=5#列数
self.colWidth = 9000#列宽度
有做了两个异常处理
异常一：FileNotFoundError
没有文件时自动创建
异常二：ValueError
没有表时自动添加表
主要代码 import xlwt import xlrd import xlutils.copy from pickle import TRUE from tkinter import FALSE #Excel表格操作（不删除表，往后累加数据） class XL: def __init__(self): self.tableName='设置速度报文测试'#表名 self.FileName='./SocketLog.xlsx'#文件路径+文件名 self.col=('次数','发送时间','接收时间','耗时','备注')#列名 self.colNum=5#列数 self.colWidth = 9000#列宽度 self.style = xlwt.XFStyle() borders = xlwt.Borders()#边框样式 DASHED虚线 NO_LINE没有 THIN实线 borders.left = xlwt.Borders.THIN borders.right = xlwt.Borders.THIN borders.top = xlwt.Borders.THIN borders.bottom = xlwt.Borders.THIN self.style.borders = borders alignment = xlwt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0df2544f60a003c5fc20b693f72f3b5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f85d89b82d36997256d74bb02fd2406/" rel="bookmark">
			win 10 如何卸载解压版 mysql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.进入mysql 的解压的 bin 目录 2.停止mysql net stop mysql 3.卸载mysql mysqld --remove mysql 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3d800623f5bb4e1f1b4181effc8974d/" rel="bookmark">
			linux服务器配置免密登录方式（vscode 以及 MobaXterm 登录）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 免密登录步骤 1. 本地系统安装ssh 2. 本地系统生成秘钥 #cmd窗口 ssh-keygen -t rsa # C:\Users\sly\.ssh 目录下会生成秘钥 # authorized_keys: 存放远程免密登录的公钥,主要通过这个文件记录多台机器的公钥。 # id_rsa: 生成的私钥文件 # id_rsa.pub: 生成的公钥文件 # known_hosts: 已知的主机公钥清单 3. 服务器配置 将本地 id_rsa.pub 文件的内容拷贝至远程服务器的 ~/.ssh/authorized_keys 文件中
特别重要：服务器.ssh目录下权限不能有执行权限，否则，秘钥将失效。权限改为：chmod 644 ./* 4. MobaXterm方式免密登录 5. vscode远程免密登录设置 # C:\Users\sly\.ssh\config文件中设置如下： Host ip HostName xxx User root IdentityFile "C:\Users\sly\.ssh\id_rsa" # 本地私钥路径 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8adebcec2078c8fb0fc3303b6f6cc258/" rel="bookmark">
			SecureRandom生成随机数-验证码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、生成随机数的方法
二、SecureRandom
三、常见使用
四、各种实现及结果验证
五、常见及相关问题总结
一、生成随机数的方法 Math.random（）一随机数 java.util.Random伪随机数（线性同余法生成） java.security.SecureRandom真随机数 二、SecureRandom SecureRandom使用 （1）指定算法名称 仅指定算法名称： SecureRandom random= SecureRandom.getInstance("SHA1PRNG"); //系统将确定环境中是否有所请求的算法实现，是否有多个，是否有首选实现。 既指定了算法名称又指定了包提供程序: SecureRandom random= SecureRandom.getInstance("SHA1PRNG","RUN"); //系统将确定在所请求的包中是否有算法实现；如果没有，则抛出异常。 （2）获取SecureRandom对象后，生成随机数 Integer randNum = random.nextInt();//生成10位数的随机数 Integer randNum = random.nextInt(100);//生成0~99的随机数 三、常见使用 1）生成6为随机验证码
SecureRandom secureRandom = SecureRandom.getInstance("SHA1PRNG"); String verifyCode = String.valueOf(secureRandom.nextInt(900000) + 100000); 四、各种实现及结果验证 package com.basic; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SecureRandom; import java.util.ArrayList; import java.util.Collections; import java.util.Random; /** * 生成6位随机数的三种实现方式 * @author libusi */ public class Test01 { public static void main(String[] args) throws NoSuchAlgorithmException { demo1(); demo2(); demo3(); demo4(); } private static void demo1() { ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 1000; i++) { int intValue = Double.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8adebcec2078c8fb0fc3303b6f6cc258/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3570653e3531b860660d10bbcdb19668/" rel="bookmark">
			DTS设备树规则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 DTS语法标准的propertycompatible属性model属性phandle属性#address-cells、#size-cells属性regs属性ranges属性status属性 dts的中断 标准NodeRoot node/aliases node/memory node/chosen node/cpus node 参考链接： https://kernel.meizu.com/device-tree.html https://zhuanlan.zhihu.com/p/143167176 DTS语法 DeviceTree的结构非常简单，由两种元素组成：Node(节点)、Property(属性)
Node节点。在DTS中使用一对花括号”node-name{}”来定义Property属性。在Node中使用”property-name=value”字符串来定义 标准的property Property的格式为”property-name=value”，其中value的取值类型如下：
Value描述Property值为空，用property本身出现或者不出现来表示一个treue/false值32bit的值，用大端格式存储64bit的值，用大端格式存储字符串混合编码，自定义property的值作为一个句柄指向一个Node，用来引用Node字符串数组 文本字符串（无结束符）可以用双引号表示：string-property = “a string”;无符号整数，用尖括号限定：cell-property = &lt;0xbeef 123 0xabcd1234&gt;;二进制数据用方括号限定：binary-property = [0x01 0x23 0x45 0x67];不同表示形式的数据可以使用逗号连在一起：mixed-property = “a string”, [0x01 0x23 0x45 0x67], &lt;0x12345678&gt;;逗号也可用于创建字符串列表：string-list = “red fish”, “blue fish”; compatible属性 “compatible”属性通常用来device和driver的适配，推荐的格式为”manufacturer,model”，如：compatible = “fsl,mpc8641”, “ns16550”; model属性 “model”属性只是简单的表示型号，root节点用其来传递值给machine_desc_str，如：model = “fsl,MPC8349EMITX”; phandle属性 “phandle”属性通用一个唯一的id来标识一个Node，在property可以使用这个id来引用Node，如：phandle = &lt;1&gt;;在DeviceTree中通过另一种方式进行phandle的定义和引用，定义一个“label：”,通过"&amp;“来引用"label”，在编译是系统会自动为node生成一个phandle属性，如：cpu0: cpu@0{…},cpu = &lt;&amp;cpu0&gt;; #address-cells、#size-cells属性 “#address-cells, #size-cells”属性用来定义当前node的子node中”reg”属性的解析格式#address-cells和#size-cells属性不会从设备树中的父节点继承1.如果node”soc”中”#address-cells=&lt;1&gt;”、”#size-cells=&lt;1&gt;”，那么子node”serial”中”reg”属性的解析为“addr1 = 0x0, size1 = 0x100, addr2 = 0x0, size2 = 0x200” soc { #address-cells = &lt;1&gt;; #size-cells = &lt;1&gt;; serial { reg = &lt;0x0 0x100 0x0 0x200&gt;; } } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3570653e3531b860660d10bbcdb19668/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f2a0b82f6a9677dabc07c718995c8ad/" rel="bookmark">
			语音压缩和无话部分抑制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		语音压缩
数字语音总是源自具有64kbit/s速率的PCM语音流，这将引起一些问题。解决它最简单的方法是对PCM语音流进行某种形式的压缩。尽管通常用“语音压缩”表示这一处理，但是它并不是指压缩语音本身，而是指压缩64kbit/s的PCM语音流。今天可将语音压缩到13khit/s，甚至于8kbit/s。可以通过以下两种方法实现语音压缩：第一种，开发新的芯片组将模拟语音直接转化成上述速率。第二种方法，把64kbit/s的PCM语音流作为第二阶段语音数字化的输入处理对象，这次数字化的输出就是较低速率的语音了。第二种方法不要求全新的模数转化芯片，仅仅是增加一些对64kbit/s速率的PCM语音流进行压缩的芯片。
注意，语音压缩本身不能自动产生突发式语音。8kbit/s的语音仍然是固定比特速率的。要想把语音变为突发式的，就必须将谈话中不说话的部分去除。
无话部分抑制
无话部分抑制是指将谈话中不说话的部分去除。引起没有语音的主要原因是谈话中，总有·方处于玲听状态，也有小部分无语音是由句与句、短语与短语之间的停顿引起的。总之，在一个双向的64kbit/s速率的PCM语音流交谈中，有60%并没有实际语音。
抑制无话部分面对的最大问题是：说话的人在一段沉默之后，如何识别他将于何时再开始说话。为什么这会成为一个困难呢？这是因为谈话方总有些背景噪声的影响，根据无话部分抑制的概念，周围的背景噪声不应被分组化，也不应被发送，系统应该只对真正的语音进行处理，所以必需把背景噪声和真正的语音区分开来。其中的技巧在于可靠地识别出说话人的音量级别远远高于背景噪声的，从而判断出他又开始说话了。比背景噪声高的声音也可能是噪声的突然爆发（比如敲击声）。这就是“语音激活识别”（简称VAD）问题。
如果语音激活识别的级别设置得太低，那么玲听的一方会突然听到敲击声、车鸣声等等外界与谈话无关的声音。如果语音激活识别的级别设置得太高了，那么谈话人再次开始的谈话将被剪辑掉一部分，刚开始的声音因为较低而不被分组化和发送。因为语音分组化的处理是实时的，所以当设置级别过高的VAD进程意识到交谈的人已经开始说话时，已经来不及获取最初的语音了。
当对VoIP分组进行了语音压缩和对抑制无话部分进行处理之后，就可以使它与其他分组一起在64kbit/s的链路上传输了。但这样做，我们将很难将链路上的VoIP分组传输和文件传输、电子邮件传输区别开来。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb19f826abafa60b52881c97766a9759/" rel="bookmark">
			解决：Error:svn: E155037: Previous operation has not finished； run ‘cleanup‘ if it was interrupted
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、介绍：
今天我将admin里的文件复制到公共模块里，然后将代码文件提交到svn的时候同事我这个问题，感觉很常见，记录一下。
二、问题解决：
第一种方式：
1：打开idea的Terminal。
2：直接使用idea自带的terminal运行svn cleanup 就可以解决这个问题。（需要注意的是，要把文件关闭，再备份一次再执行这个命令。）
三、总结。
发现问题先不要慌，平复一下心情，梳理一下流程，问题会很快就解决的，心向阳光 成功可待。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81c76cfc4abaa2d7f14438e1bee4cb57/" rel="bookmark">
			Mysql 隐式类型转换 可能不走索引？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mysql 隐式类型转换 可能不走索引？ 在实际开发和运维过程中有没有发现，在对一张数据量很大的表执行查询的时候，明明 where 条件后面的字段有索引的啊，可是查询耗时却相当长，这是为什么呢？
先说结论：Mysql在 varchar 类型字段的索引中如果发生了隐式类型转换，则索引将失效。
创建user表，具有name 和 age 两个属性，还有一个 id 的主键字段：
CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(255) DEFAULT NULL, `age` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `user_name` (`name`), KEY `user_age` (`age`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 我们分别为 name 和 age 这两个字段建立了索引，下面我们就来对这两个索引进行测试和验证。
我们尝试一下用 age 字段进行正常类型的查询，看看执行计划是什么样的：
mysql&gt; explain select * from user where age = 1; +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+ | 1 | SIMPLE | user | NULL | ref | user_age | user_age | 5 | const | 1 | 100.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81c76cfc4abaa2d7f14438e1bee4cb57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6febfbb03a8e2e6ae03f3e3494ad916c/" rel="bookmark">
			【自动化办公】schedule模块定时执行任务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 适用于定时爬虫和定时替换，尚在研究如何搞事。 此模块中常用schedule.every()和schedule.run_pending()两个函数
schedule.every(number).(seconds,minutes,hours,days).do(task) 表示每隔多少（秒，分钟，小时，天），执行一次任务（设定好的函数）
schedule.run_pending() 立即执行所有被安排进schedule中的任务
例子
import schedule import time def run(): print("Hello world") #每隔十分钟执行一次任务 schedule.every(10).minutes.do(run) #每隔一小时执行一次任务 schedule.every().hour.do(run) #每天的10:30执行一次任务 schedule.every().day.at("10:30").do(run) #每周一的这个时候执行一次任务 schedule.every().monday.do(run) #每周三13:15执行一次任务 schedule.every().wednesday.at("13:15").do(run) #运行所有可以运行的任务 while True: schedule.run_pending() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e9576a275a2a4e815890548dd41465f/" rel="bookmark">
			多线程-万字详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多线程 作者：知否派。
文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！
一、多线程 1.线程池的意义 线程是稀缺资源，它的创建与销毁是个相对偏重且耗资源的操作，而Java线程依赖于内核线程，创建线程需要进行操作系统状态切换，为避免资源过度消耗需要设法重用线程执行多个任务。
线程池就是一个线程缓存，负责对线程进行统一分配、调优与监控。
什么时候使用线程池?
单个任务处理时间比较短需要处理的任务数量很大 线程池优势
重用存在的线程，减少线程创建，消亡的开销，提高性能提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。提高线程的可管理性，可统分配， 调优和监控。 2.线程池的五种状态 Running 能接受新任务以及处理已添加的任务
Shutdown 不接受新任务，可以处理已经添加的任务
Stop 不接受新任务，不处理已经添加的任务，并且中断正在处理的任务
Tidying 所有的任务已经终止，ctl记录的”任务数量”为0, ctl负责记录线程池的运行状态与活动线程数量
Terminated 线程池彻底终止，则线程池转变为terminated状态
3.多线程的使用场景 1.后台任务，例如:定时向大量(100w以上) 的用户发送邮件2.异步处理，例如:统计结果，记录日志发送短信等:3.分布式计算分片下载、断点续传 小结:
任务量比较大， 通过多线程可以提高效率需要异步处理时占用系统资源，造成阻塞的工作时 都可以采用多线程提高效率
4.多线程的创建方式 继承Thread
package com.whcoding.test.thred; /** * @program: spring-boot-learning * @description: * @author: whcoding * @create: 2022-06-10 15:20 **/ public class MyThreadCreateThread extends Thread { @Override public void run() { for (int i = 0; i &lt; 10; i++) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e9576a275a2a4e815890548dd41465f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e96563eda9649769ac285477d4c5737f/" rel="bookmark">
			orbslam_addsemantic 段错误（核心已转储）gdb调试core文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		orbslam_addsemantic 段错误解决 gdb core文件调试 参考博客：https://www.javazxz.com/thread-11338-1-1.html
https://blog.csdn.net/weixin_42017587/article/details/102541514
更改core文件大小限制为unlimited，运行代码，段错误后可在运行路径下生成core文件
gdb调试core文件
查看堆栈
定位错误代码，修改 定位到Frame.cc 的1148行：const float d = imDepth.at&lt;float&gt;(v,u);经CLion调试，发现当v和u等于-1时程序会终止运行，报段错误。这是因为前面代码将动态物体上的关键点坐标设为（-1，-1），这里直接根据坐标从深度图获取深度会出问题，应该先判断是否为-1，若是就continue不获取深度。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e44fed84ab8cfa829610f375c0535e95/" rel="bookmark">
			Linux相关命令详解持续更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.ssh命令 远程连接服务器 ssh -p 端口 用户名@ip地址 端口默认是22，下面给一个实际的示例 ssh -p 22 root@192.168.0.222 2.scp命令 上传文件到服务器和下载服务器的文件到本地 2.1 从服务器下载文件夹到本地 scp -r root@192.168.0.222:/home/tools/test/ ./ 2.2 从本地上传文件夹到服务器 scp -r ./tqf_test root@192.168.0.222:/home/tools/test/ 3.rm删除命令 3.1 删除单个文件 rm -r 文件名 3.2 删除文件 会提示是否确认删除 rm -i 文件名 3.3 删除文件夹 rm -rf 文件夹名称 4.find查找文件命令 4.1 准确查找文件 find ./ -name "tqf1.txt" 4.2 模糊查找文件 find ./ -name "tqf1.*" find ./ -name "tqf*.txt" 5.压缩和解压文件命令 5.1 tar压缩命令 5.1.1 tar压缩文件 -czf命令 tar -czf tqf1.tar.gz tqf1.txt 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e44fed84ab8cfa829610f375c0535e95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15738c6e52fa30594df9522632ced22c/" rel="bookmark">
			centos 7 Redis编译部署最佳实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载安装包 下载链接：
Index of /releases/
根据实际需要安装对应版本的Redis应用服务
对于Redis 6以上版本的，需要高版本的GCC支持
在不升级GCC的情况下安装Redis服务，只针对centos7 有效，centos6无法创建虚拟GCC环境
但是因为是默认情况下会安装现有的低版本GCC，如果去升级的情况下可能会导致有依赖其他的应用服务出现异常的情况，因此可以通过centos 7的虚拟环境的方式去创建Redis服务
具体的配置方式如下：
创建高级版本的GCC环境：
yum install centos-release-scl scl-utils-build yum install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils scl enable devtoolset-9 bash 配置完成之后会生成devtoolset-9-gcc环境
然后再进行安装
cd /usr/local/services/src/redis-6.0.8 make make PREFIX=/usr/local/services/redis-6.0.8 install 部署完成之后会生成对应的bin文件
此时还需要对创建的配置文件创建对应的文件信息
包括etc logs配置
etc的配置信息可以参考源码上的redis.conf配置进行相应的修改
包括绑定的端口 IP地址 logs的日志文件路径和名称
pid的文件路径
以及持久化，读写间隔设置 密码等信息
配置systemctl启动项服务
# systemctl cat redis-server.service # /usr/lib/systemd/system/redis-server.service [Unit] Description=Redis data structure server Documentation=https://redis.io/documentation #Before=your_application.service another_example_application.service #AssertPathExists=/var/lib/redis Wants=network-online.target After=network-online.target [Service] #ExecStart=/usr/local/bin/redis-server --supervised systemd --daemonize no ## Alternatively, have redis-server load a configuration file: ExecStart=/usr/local/services/redis-6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15738c6e52fa30594df9522632ced22c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c4c6e0a3d2a13a0dd1975b3326bfe14/" rel="bookmark">
			在计算机上设置指定当拒绝用户访问文件或文件夹时要显示的自定义消息【Windows操作系统优化配置】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		例如当拒绝方问的用户显示以下信息“您的访问已被拒绝，请联系管理员” 一丶打开本地组策略编辑器 按下“Win+R”快捷键调出运行窗口，输入“gpedit.msc”，并按下回车键 如图所示
二丶找到"访问被拒绝协助"项 左侧路径"计算机配置→管理面板→系统→访问被拒绝协助"
三丶启用并编辑消息 右键 右侧窗口中"自定义被拒绝"错误信息 选择"编辑"项
勾选"已启用"复选框 并在消息栏 编写你想要显示的信息
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fba6d88a5010a1a0856693a06b9ca92c/" rel="bookmark">
			Linux之pinctrl子系统与gpio
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 pinctrl子系统文件列表pinctrl主要数据结构pinctrl_dev 是 pinctrl 子系统的根源结构体函数调用逻辑 设备树实例驱动使用pinctrl与驱动模型的接口和device tree或者machine driver相关的接口 参考链接： http://www.wowotech.net/sort/gpio_subsystem pinctrl子系统文件列表 linux/drivers/pinctrl目录下的源文件列表
源文件列表 文件名描述core.c core.hpin control subsystem的core driverpinctrl-utils.c pinctrl-utils.hpin control subsystem的一些utility接口函数pinmux.c pinmux.hpin control subsystem的core driver(pin muxing部分的代码，也称为pinmux driver)pinconf.c pinconf.hpin control subsystem的core driver(pin config部分的代码，也称为pin config driver)devicetree.c devicetree.hpin control subsystem的device tree代码pinctrl-xxxx.c各种pin controller的low level driver 其他内核模块接口文件，很多内核的其他模块需要用到pin control subsystem的服务，这些头文件就定义了pin control subsystem的外部接口以及相关的数据结构 文件名描述consumer.h其他的driver要使用pin control subsystem的接口：a、设置引脚复用功能 b、配置引脚的电气特性；需要include这个头文件devinfo.h这是linux内核的驱动模型模块使用的接口。struct device中包括struct dev_pin_info *pins的成员，描述了该设备的引脚的初始状态信息，在probe之前，driver model中的core driver在调用driver的probe函数之前会先设定pin statemachine.hmachine模块的接口 Low level pin controller driver接口，提供给底层specific pin controller driver的头文件列表 文件名描述pinconf-generic.h主要是提供给各种pin controller driver使用的，不是外部接口pinconf.hpin configuration 接口pinctrl-state.hpin control state状态定义pinmux.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fba6d88a5010a1a0856693a06b9ca92c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4139e26835e9590bdd39297a4350fce/" rel="bookmark">
			SpringMVC详解及基本使用第一天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一. SpringMVC详解
1.什么是MVC
2.什么是SpringMVC框架
3.为什么要使用SpringMVC框架
二.如何使用springmvc框架
1.创建一个maven-web工程
2.引入springmvc的依赖
3.注册DispatcherServlet到web.xml文件上
4.创建springmvc配置文件 5.创建一个controller类
6.异常处理
7.springmvc的运行流程
三.如何在Servlet中接受请求的参数
1.接受少量的参数
2. 接受大量的参数
（1）自己创建编码过滤器. jdk1.8一定要重写init和destory方法 1.9以后可以不写
(2).springmvc提供了一个编码过滤器
3.接收的参数含有日期类型
4.处理静态资源
一. SpringMVC详解 1.什么是MVC MVC就是一个分层架构模式: MVC是一种软件架构的思想，将软件按照“模型-视图-控制器”来划分
●M:　Model（模型）是应用程序中用于处理应用程序数据逻辑的部分，指JavaBean。通常负责在数据库中存取数据
JavaBean分为两类:
a.一类为实体类Bean:专门存储业务数据的(实体类) b.一类称为业务处理Bean：指Service或Dao对象，专门用于处理业务逻辑和数据访问
●V:　View（视图）是应用程序中处理数据显示的部分。通常是依据模型数据创建的。
●C:　Controller（控制器）是应用程序中处理用户交互的部分。通常负责从视图读取数据，控制用户输入，并向模型发送数据。
MVC的工作流程:
1、客户端向服务器发送请求。
2、服务器把请求分发给Servlet控制器
3、Servlet控制器获取用户输入的数据，并调用(即model层)进行业务处理。
4、Servlet根据处理结果选择一个JSP视图来响应用户。
5、JSP视图显示处理的数据。
2.什么是SpringMVC框架 pringMVC它是spring框架的一个分支，该springMVC框架主要完成的功能是:==接收浏览器的请求响应，对数据进行处理，然后返回页面进行显示== 它的功能和Servlet功能是一样的
3.为什么要使用SpringMVC框架 二.如何使用springmvc框架 1.创建一个maven-web工程 ps: ==将原先web.xml文件中的内容替换为下面的内容（自动生成的web.xml文件内容版本太低） &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0"&gt; &lt;/web-app&gt; 2.引入springmvc的依赖 在pom.xml文件中引入springmvc的jar包
&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.15.RELEASE&lt;/version&gt; &lt;/dependency&gt; 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4139e26835e9590bdd39297a4350fce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f209bc5c3dd222876e5d81473859e02a/" rel="bookmark">
			SmtpClient邮件发送失败汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
错1：命令顺序不正确。 服务器响应为:Error: need EHLO and AUTH first !
错2：参数或变量中有语法错误。 服务器响应为:mail from address must be same as authorization user
错3：根据验证过程，远程证书无效
错4：身份验证失败，因为远程方已关闭传输流
Authentication failed because the remote party has closed the transport stream
错1：命令顺序不正确。 服务器响应为:Error: need EHLO and AUTH first ! SmtpClient client = new SmtpClient { UseDefaultCredentials = true, //Credentials = new NetworkCredential(userName, password),//SMTP认证用户 Credentials = CredentialCache.DefaultNetworkCredentials, Host = str3,//SMTP服务主机 //TargetName = "smtp.office365.com", Port = num,// SMTP服务端口 EnableSsl = true }; (1) Credentials = CredentialCache.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f209bc5c3dd222876e5d81473859e02a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc896fcc4b59911690eee0464f7d7ed9/" rel="bookmark">
			【小白必懂】C语言回文数判断
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		若是大一学子或者是真心想学习刚入门的小伙伴可以私聊我，若你是真心学习可以送你书籍，指导你学习，给予你目标方向的学习路线，无套路，博客为证。
情景再现 👸小媛：小C，今天可以教我回文数吗？ 😱
🐰小C：怎么了？怎么突然想搞回文数。
👸小媛：因为我琢磨了好久回文数，没搞出来。完全没看懂怎么写的，例如判断一个数是否是回文数。 😭
🐰小C：嗯，可以。那你知道什么是回文数吧？
👸小媛：回文数就是正着念和倒着念都是没差别的数字，语文里面还有回文，也就是“我为人人，人人为我”；反过来念也是“我为人人，人人为我”，数学里面就是 151 反过来念也是 151。
🐰小C：那你了解了就行，判断回文数还需要会编写一段代码，这一段代码可是十分的重要。
👸小媛：什么代码？
🐰小C：就是将一个数进行反转的代码，例如有一个数是 123456，你需要将其反转成 654321，否则在一般情况下你就很难去判断这个数字是否是回文数。
👸小媛：对，反正我是一点都没看懂，太难了。 😭
🐰小C：那我们接下来先试着看看如何将一个数进行反转吧。
👸小媛：多谢小C 带我飞。
🐰小C：我们现在第一步，创建两个变量，一个是 a，里面存储 123456，这个变量 a 也是用来进行回文的数；接着，我们需要创建一个变量 b，并且将其赋值为 0。
int a=123456,b=0; 👸小媛：嗯，明白了，接着讲吧。
🐰小C：我就是一步步来怕你不懂，因为第二步就直接进入正题了。
👸小媛：啊，是这样呀，哈哈哈，多谢小C。 😂
🐰小C：那我们接着进入第二步，你看下面程序，你知道这个循环会做些什么吗？
int a=123456,b=0; while(a!=0){ b=a%10; a=a/10; } 👸小媛：你是指 while 循环吗？
🐰小C：是的，你来讲讲这个循环内发生了什么事。
👸小媛：…嗯，就是每次循环，变量 b 就会存储变量 a 取模 10 后得到的数，也就是得到当前变量 a 这个数值的个位，然后 a 每次都缩小 10倍，由于 a 是一个整数类型的变量，所以不能有小数点，此时将会舍弃，那么就是一个整数。
🐰小C：你自己模拟一下循环了 3 次后会怎样，口述出来。
👸小媛：其实就是第一次的时候变量 a 是 123456，接着开始循环；在第一次循环时 123456 % 10 那么结果为 6，取模就是除 10 之后得到一个余数，这就是结果；那么此时将会把这个余数 6 存储在变量 b 中；接下来这个变量 a 将会除 10 会缩小 10倍，接下来就会等于 12345。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc896fcc4b59911690eee0464f7d7ed9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e516d317a8138ebe8fc57883bbcb91f3/" rel="bookmark">
			《看聊天记录都学不会C语言？太菜了吧》（21）（必懂！题解）在现实生活中，打擂台比赛争名次竟用的是冒泡排序？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		若是大一学子或者是真心想学习刚入门的小伙伴可以私聊我，若你是真心学习可以送你书籍，指导你学习，给予你目标方向的学习路线，无套路，博客为证。
本系列文章将会以通俗易懂的对话方式进行教学，对话中将涵盖了新手在学习中的一般问题。此系列将会持续更新，包括别的语言以及实战都将使用对话的方式进行教学，基础编程语言教学适用于零基础小白，之后实战课程也将会逐步更新。
若有想学习的内容可以在评论区留言，根据大家的要求持续更新。点赞过十万就算化成灰我也更新下一篇。（肯定不到，也会更的。）
有问题也可以在评论区留言，也可以私聊我加我好友共同交流一起进步~
喜欢内容欢迎关注我、评论、点赞、收藏，这对我很重要，谢谢~
由于部分粉丝要求想要学python，就更了这个系列，我就算是生产队的驴、化成灰我C语言和python都一周6篇打底。可以关注我加我好友提你们想学的内容哟~ 目录 《看聊天记录都学不会C语言？太菜了吧》（22）（必懂！题解 1-100 内素数）素数原来是质数！为什么你不早说！——（必懂！题解）求素数
《看聊天记录都学不会C语言？太菜了吧》（21）（必懂！题解冒泡排序）在现实生活中，打擂台比赛争名次竟用的是冒泡排序？——（必懂！题解）冒泡必懂
《看聊天记录都学不会C语言？太菜了吧》（20）（必懂！题解指定天数）我能知道2000年后的这个月一共有几天——（必懂！题解）我能知道2000年后的这个月一共有几天
《看聊天记录都学不会C语言？太菜了吧》（19）巩固开始，数字1、2、3、4能够组成多少个 3 位数的不同的排列——巩固1
《看聊天记录都学不会C语言？太菜了吧》（18）2分钟搞结构体——结构体
看聊天记录都学不会C语言？太菜了吧》（17）5分钟搞懂指针与多重指针——指针与多重指针
《看聊天记录都学不会C语言？太菜了吧》（16）我一直以为校花很漂亮，直到我叫了她一声…——生命空间、命名规则
《看聊天记录都学不会C语言？太菜了吧》（15）你学了一节课的函数我5分钟搞定了，还很熟——自定义函数传参、返回值
《看聊天记录都学不会C语言？太菜了吧》（14）这么神奇？我写了20行代码竟然一行就可以搞定？——自定义函数
《看聊天记录都学不会C语言？太菜了吧》（13）（9*9 乘法表）寻找电脑中的盲盒彩蛋——for 循环与循环嵌套 九九乘法表
《看聊天记录都学不会C语言？太菜了吧》（12）循环有多容易？你看一眼就怀…——循环
《看聊天记录都学不会C语言？太菜了吧》（11）2分钟领悟数组——数组
《看聊天记录都学不会C语言？太菜了吧》（10）程序媛聪明绝顶了——逻辑与运算符
《看聊天记录都学不会C语言？太菜了吧》（9）老公饼真的有老公送？——字符数组
《看聊天记录都学不会C语言？太菜了吧》（8）牛郎和织女竟有一个孩子？——多条件if
《看聊天记录都学不会C语言？太菜了吧（7）下一篇文章告诉你牛郎是谁——if逻辑判断
《看聊天记录都学不会C语言？太菜了吧（6）以前跟我说编程很难的给我站出来——浮点数及变量运算
《看聊天记录都学不会C语言？太菜了吧（5）打了一把游戏我学会了一个编程知识？——变量输出及占位符
《看聊天记录都学不会C语言？太菜了吧（4）原来我早就会编程了——变量
《看聊天记录都学不会C语言？太菜了吧（3）代码都在谈恋爱难道你不知道？——头文件及标点
《看聊天记录都学不会C语言？太菜了吧（2）我说编程很容易你们不服？——Devc使用及HelloWorld
《看聊天记录都学不会C语言？太菜了吧（1）我在大佬群里问基础问题没人理？——学习建议
我的其它教程 教程点击进去将会有目录
《看聊天记录都学不会Python到游戏实战？太菜了吧》（1）加载Python神器！亮剑！
《看聊天记录都学不会C#？太菜了吧》（1）从今天开始我是一个游戏开发者
你去约个会，你零基础的同学就学完C语言知识点过完了
【小白进】大佬们学习为什么简单？小白该如何学习？学历不高如何找工作？副业很好赚？了解后少走弯路
作者简介 作者名：1_bit
简介：CSDN博客专家，2020年博客之星TOP5，蓝桥签约作者。15-16年曾在网上直播，带领一批程序小白走上程序员之路。欢迎各位小白加我咨询我相关信息，迷茫的你会找到答案。
博客地址：https://i1bit.blog.csdn.net
🐰小C：小媛，这节课我们开始上数组排序的内容吧。
👸小媛：问题不大，不就是习题嘛，反正你写出来的文章，写得不好肯定被骂的，写得好我就会了。😎
🐰小C：唔，好像很有道理，那开始吧。
👸小媛：好的。
🐰小C：我现在有一个数组，数组里面有打乱顺序的数值，你能把这些数字按照从小到大的排列重写存放到数组之中吗？
int a[] = {11,1, 6, 3, 66, 58, 79, 33}; 👸小媛：你还是慢慢来吧，别直接进入主题，我接受不了，太难了。😭
🐰小C：哈哈哈，今天我们学的排序是一个叫做冒泡排序的方法。
👸小媛：为啥叫这个名字？感觉挺有趣的，名字听起来不难，可是总感觉学起来就超级难了。
🐰小C：哈哈哈，其实不难，我一步步跟你道来。
👸小媛：问题不大，讲吧。
🐰小C：我们可以看我们需要排序的值 11,1, 6, 3, 66, 58, 79, 33，我们需要小的数在左边，大的数在右边，这样就可以实现从小到大排序了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e516d317a8138ebe8fc57883bbcb91f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4cf2138a295980dc8a572c1c7611eee/" rel="bookmark">
			【Maven】一文就解决springboot框架中创建maven所有问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		声明 以下问题均为我创建项目中所遇到的问题，不一定具有普适性。另外错误案例也没有既是保存，还望海涵
下载Maven 首先进入maven官网，地址在这里
windows选择下载图中这个，然后我们会得到一个压缩包，解压到你习惯放的位置，接下来为了能让他成为全局变量，我们需要配置环境变量
window11需要打开设置，下拉到最后找到系统信息，再打开高级系统设置
接下来就开始设置环境变量
以下两个任选其一，系统变量意思是本台机器的环境变量，上面是使用这个微软账户才有的变量，不过大多数笔记本只登录一个账号，所以选择哪个无所谓
然后在环境变量中创建MAVEN_HOME后在环境变量中添加%MAVEN_HOME%\bin 这条语句。
注意 这里的MAVEN_HOME的路径是你解压后的路径，需要注意的是路径不能加上/bin，其实仔细看可以发现环境变量中%MAVEN_HOME%不过是取代了他的路径，但是这种配置方法已经是约定俗成的写法了。
测试 打开cmd 输入mvn -v命令
显示版本号说明成功了
此外还有显示不是内部或外部命令，也不是可运行的程序
或批处理文件。说明你的环境变量配置错误
或java。。。
说明没有安装jdk或以前jdk没有配置环境，这时打开环境变量查看是否有%JAVA_HOME 有的话将其上移到MAVEN_HOME前面，否则需要再次安装以下jdk
修改为国内镜像settings.xml 打开文件后进入conf后再打开settings.xml
这里我用的vscode进行修改
进入阿里云官方网站
复制内容到&lt;mirrors&gt;&lt;/mirrors&gt; 之间并将原来存在的删掉
取出图中标签，删掉原有内容，并添加你喜欢的文件夹（这里存储的是他以后下载的依赖）
至此，Maven配置完成
创建idea项目 下拉Maven主路经选择刚刚配置 好的文件
将用后设置文件重写到刚刚的settings文件
点击刷新即可下载依赖，如果下载后出现找不到路径
原因可能是你的仓库文件夹设置了只读权限，
解决办法是
全部同意后退出即可
至此，问题全部解决
尾声 这是本人第一次创建项目遇见的所有坑，查询了大量博客和视频花费大量时间才得以解决，所以想要记录下来，但是也不一定具有普适性，所以有新的问题或对我的步骤有疑问的欢迎联系我
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d355c3a256d650997d6916f1690e393/" rel="bookmark">
			java 如何调用父类的父类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写代码的时候遇到一个问题
想输出的结果：
结果是这样：
子类调用父类的代码用super.方法名
那么子类的子类调用祖父类的方法怎么调用呢
代码如下：
祖父类为 People类 父类为 ChinaPeople类 子类为 BeijingPeople类
祖父类
package taskJuly.day21.task2; /** * @ClassName People * @Description TODO * @Author Prt * @Date 2022/7/21 14:38 */ public class People { String region; String hello; double height; double weight; public void speakHello(){ System.out.println(this.region+" "+this.hello); } public void averageHeight(){ System.out.println(this.region+" averageHeight = "+this.height); } public void averageWeight(){ System.out.println(this.region+" averageWeight = "+this.weight); System.out.println("\r"); } } 父类
package taskJuly.day21.task2; /** * @ClassName ChinaPeople * @Description TODO * @Author Prt * @Date 2022/7/21 14:46 */ public class ChinaPeople extends People{ public ChinaPeople() { region = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d355c3a256d650997d6916f1690e393/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0898c4c6fa8b1f5af77d98ac96931e87/" rel="bookmark">
			Jetson NX 设置wlan0静态ip
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nvidia Jetson NX设置静态ip Nvidia Jetson NX也是Ubuntu但是设置ip方式与往常不太一样，步骤如下：
打开终端输入 sudo gedit /etc/network/interfaces
注释掉所有信息，输入以下信息
iface wlan0 inet static	# 设置静态ip address 192.168.1.181	# ip地址 netmask 255.255.255.0	# 掩码 gateway 192.168.1.1	# 路由 dns-nameservers 8.8.8.8	#dns 确保是wlan0
刷新ip地址 sudo ip addr flush wlan0
重启网络服务 sudo systemctl restart networking.service
确保重启网络服务管理项启动，确保 managed = true sudo gedit /etc/NetworkManager/NetworkManager.conf
重启机器 sudo reboot
重启后查看ifconfig，发现ip并不是设定的静态ip 不过没关系！直接使用ssh连接设定的ip，输入密码就可以连接了 也可以使用动态分配的ip进行ssh远程连接 这个是比较迷惑的，理论上一个状态下只有一个ip生效，但是确实是发生了这个情况，能使用自己设定的静态ip连接，就说明设置成功了。可能是Jetson版本Linux设定的问题。 有问题欢迎评论区讨论
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39ca5f3d57bc927a22cbe29b961660d7/" rel="bookmark">
			Turtlebot3 Jetson NX在ROS环境下键盘控制小车移动旋转 - 配置环境以及控制设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ROS 工作环境配置 创建工作空间 mkdir -p ~/catkin_ws/src #src名不可变；-p：递归创建所有层级目录
cd ~/catkin_ws/src
catkin_init_workspace #把当前文件夹src初始化成ros工作空间（属性变化）
编译工作空间 cd ~/catkin_ws/
catkin_make #编译src下所有功能包的源码；生成build、devel
创建功能包 cd ~/catkin_ws/src #功能包要放在src中
配置功能包程序依赖 catkin_create_pkg base_controller roscpp
第三方库 下载键盘控制 ROS 包 cd ~/catkin_ws/src git clone http://github.com/ncnynl/teleop_twist_keyboard.git 将 teleop_twist_keyboard.py 设置为可执行文件 下载串口通信的ROS包 cd ~/catkin_ws/src git clone http://github.com/ncnynl/serial.git 控制程序 $ cd ~/catkin_ws/src $ catkin_create_pkg base_controller roscpp $ cd catkin_ws/src/base_controller $ mkdir src $ touch src/base_controller.cpp $ gedit src/base_controller.cpp base_controller.cpp /* base_controller.cpp */ #include "ros/ros.h" //ros需要的头文件 #include &lt;geometry_msgs/Twist.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39ca5f3d57bc927a22cbe29b961660d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b196712dcfb9f3086af024c3fd1a245/" rel="bookmark">
			【Java】面向对象——继承
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		继承 继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。继承是is-a的相互关系 继承的优点 将所有子类的共同属性放入父类，实现代码共享，避免重复，提高开发效率可以使得修改扩展继承而来的实现比较简单 继承的缺陷 父类变，子类就必须变继承破坏了封装，对于父类而言，它的实现细节对与子类来说都是透明的继承是一种强耦合关系 特殊关键字 包package 包是类或接口的容器，是一个用于避免命名冲突的名空间，是一个逻辑命名的概念，与具体的物理位置无关
在具体的实现中，包名称经常和目录名称对应
什么是包 包是类的组织方式，提供名空间和访问控制类似于文件系统的组织 声明包中的类package 语法： package 包名称;
声明包要求是源代码文件的第一个语句。包定义之前可以添加注释信息程序中最多只能有一条package语句，没有包定义的源代码文件成为默认包中的一部分 //默认包中的类可以访问其它命名包或者只能同包访问，其它包不能访问默认包中的类 public class A1 { public void cc() { System.out.println("小胖子醒醒!"); } } 程序中如果有package语句,该语句必须是第一条语句（前面只能有注释或空行）包的命名规则： 全小写使用域名反转的方式定义，例如延安餐饮集团yanan.com的项目，定义包名称为com.yanan如果细分还可以引入功能定义部分，例如数据库访问com.yanan.dao
包的作用 包能将相关的源代码文件组织在一起 com.yanan.dao其中存放操作数据库相关的类文件com.yanan.biz存放相关的业务类文件 包减少了名称冲突带来的问题可以使用package指明源文件中的类属于哪个具体的包
包的使用如果其他人想使用包中类，则需要使用全名 import java.util.Date; public class A{ public static void main(String[] args){ Date now=new Date(); //使用类的简称Date，而不是全名称java.util.Date } } //用法2：全称 java.util.Date now=new java.util.Date(); //不需要import 为了简化书写，Java提供了import语句： import package_name.*; import java.util.*; //使用java.util包中的所有类都不需要再使用import java.util.类名 引入包中的某一个类：import java.util.ArrayList;
引入包importJava缺省引入的包为java.lang System.out.println("显示输出");//不需要import java.lang.System //同包中的其它类不需要导入 package com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b196712dcfb9f3086af024c3fd1a245/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3b56da2e188dbc97fa2629e38b7baf4/" rel="bookmark">
			vscode同时配置C和C&#43;&#43;编译环境（纯小白版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于vscode下载以及环境变量的设置已经有许多的文章，这里不再赘述，这篇文章主要是解决同时配置C和C++两种环境中的问题。
首先配置C语言环境
创建一个.vscode文件夹，在里面创建三个文件c_cpp_properties.json、launch.json、tasks.json
c_cpp_properties.json文件中
{
"configurations": [
{
"name": "Win32",
"includePath": [
"${workspaceRoot}",
"D:/vscode/mingw64/include/**", //以下7行需要修改为自己的地址
"D:/vscode/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++",
"D:/vscode/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/x86_64-w64-mingw32",
"D:/vscode/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/backward",
"D:/vscode/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include",
"D:/vscode/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include-fixed",
"D:/vscode/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/../../../../x86_64-w64-mingw32/include"
],
"defines": [
"_DEBUG",
"UNICODE",
"__GNUC__=6",
"__cdecl=__attribute__((__cdecl__))"
],
"intelliSenseMode": "msvc-x64",
"browse": {
"limitSymbolsToIncludedHeaders": true,
"databaseFilename": "",
"path": [
"${workspaceRoot}",
"D:/vscode/mingw64/include/**", //以下7行需要修改为自己的地址
"D:/vscode/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++",
"D:/vscode/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/x86_64-w64-mingw32",
"D:/vscode/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/backward",
"D:/vscode/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include",
"D:/vscode/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include-fixed",
"D:/vscode/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/../../../../x86_64-w64-mingw32/include"
]
}
}
],
"version": 4
}
launch.json文件中：
{
"version": "0.2.0",
"configurations": [
{
"name": "(Windows) Launch",
"type": "cppvsdbg",
"request": "launch",
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3b56da2e188dbc97fa2629e38b7baf4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a89077e6709268f8f9d6a0255101434/" rel="bookmark">
			基于swagger下载接口文档到本地
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		推荐一款基于swagger的在线接口文档，支持本地下载 网站地址：http://tools.abyss.net.cn/#/swaggerDocument 在于第三方公司做数据对接时，或者撰写技术方案时，需要咱们自己整理接口，这时可以通过这个在线工具将swagger中的接口导出到word文档中。
1.在线工具的如下图：
2.文本框中输入 swagger 访问地址 即可在线预览接口并下载至本地
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5493b609b7a7ad2286a5679fe3b07334/" rel="bookmark">
			js练习题（14个）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;script&gt; function foo(val){ if (val &gt; 5) { console.log('aaa'); }else if(val &gt; 10 ) { console.log('bbb'); }else if(val &gt; 15) { console.log('bbb'); } } foo(6); foo(11); foo(16); //其实这里的if...else if相当于python // 中的if...elif,程序会依次评估寻找第一个结果为true的条件，并且执行对应语句块，结束后跳过整个if/elif/eles结构 // 所以会控制台输出aaa aaa aaa var b = 10; (function b(){ b = 20; console.log(b); }); &lt;/script&gt; &lt;script&gt; function demo(){ console.log(arguments.callee) } demo();//这里采用的就是es3方法 function test(){ "use strict";//必须写在逻辑的最前面 console.log(arguments.callee); } test();//这里用的就是es5模式 &lt;/script&gt; &lt;body&gt; &lt;*node block inline-block table inherit flex grid*&gt; :display类型 &lt;/body&gt; &lt;script&gt; //盒子模型	content-&gt;padding-&gt;border-&gt;margin //margin不占盒子的实际大小（长宽），比如我们自己写的width height就是内容区（content）的宽高 // 改变padding,整个盒子的大小改变，但是margin不会变化 &lt;/script&gt; &lt;style&gt; div{ width: 100px; height: 100px; border: 3px solid red; zoom: 3; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;hello&lt;/div&gt; &lt;script&gt; document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5493b609b7a7ad2286a5679fe3b07334/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3010e2e19861b50f3194665bffa8535a/" rel="bookmark">
			手把手教你在群晖中设置阿里云DDNS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于运营商提供的公网ip是动态的，所以需要设置ddns实时地更新域名服务商处的绑定到我们域名上的ip地址。
1、在阿里云购买一个域名（如何购买不做展示）
2、群晖中安装docker
在群晖的套件中心中安装docker
安装完毕后，打开docker，并单机注册表，然后搜索“aliyun",选择第一个搜索结果aliyun-ddns-cli并按第一行的下载，下载该映像
在左侧单机映像，然后选中刚刚下载的映像，单机第一行的启动
点击启动后会自动进入创建容器窗口
这里我点击左下角的高级设置按钮，然后进入配置窗口，在配置窗口中单机环境选卡：
现在我们需要从阿里云中获取AKID、AKSCT两项内容，他们是登录阿里进行ddns设置的用户权限，这个需要从阿里云的accesskey获取。
登录阿里云的控制台，把鼠标放到右上角头像上会弹出子窗口，选择Accesskey管理
此时会弹出提示窗口：云账号AccessKey是您访问阿里云API的密钥，具有该账户完全的权限，请务必妥善保管。请勿通过任何方式（如Github等）将AccessKey公开至外部渠道，以免被恶意利用而造成安全威胁。强烈建议您遵循阿里云安全最佳实践，使用RAM子用户AccessKey来进行API调用。
当然是给的权限越小约好，就怕万一accesskey被泄露了影响太大，对吧。
所以我们点击开始使用子用户，进入到RA访问控制后，单机蓝色的创建用户按钮：
填写一个用户名和说信息，勾选open API选项就可以了，这个账户不需要控制台登录权限的。
完成后，单击刚刚创建的用户名
单击授权管理
单击添加权限
在随后，选择授权范围为整个云账号、授权主体保持默认的刚刚创建的这个子账户名、在选择权限中输入dns搜索并选择AliyunDNSFullAccess,最后单机左下角的确定按键。
单机完成后，可以看到已经被赋予dns管理权限
回到认证管理页，可以看到一开始已有一个accesskey id了，但是看不到密码，而且这个密码也无法再重新查看了，只能后面新建一个Accesskey id
单击创建AccessKey会弹出新建的id和secret,这个id和secret就是群晖里面需要的信息。
回到群晖，在环境选项卡中输入我们得到的id和secret
AKID:自己域名的AccessKey ID
AKSCT:自己域名的Access Key Secret
Domain:设置访问的域名，可以根据自己的喜欢设置一级或二级域名。如 你的域名为aa.com那就可以pan.aa.com这样到时就可以使用pan.aa.com来访问了。
REDO：设置多少分钟更新一次dns设置，我这里设置的60秒，即1分钟
点击应用后，在容器中可以看到已经在运行了
这时我们可以回到阿里云中查看dns记录是否已经正确添加和更新。
到这里，所以配置就是完工啦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9412840c548a3c1b6316efbccee9311/" rel="bookmark">
			华清远见培训感想
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		读者们好，我是华清远见的一名学员，已经参加培训快一个月了，这一个月的学习，使我学到了许多知识，华清远见的老师真的都超级好，讲课时也非常有趣，不会让你感到枯燥，也非常认真负责，遇到弄不明白的地方老师会耐心为你讲解，而且班级的学习氛围也非常好。
这一个月的时间说长不长，说短也不短，但我是实实在在的学到了很多东西，我学的是嵌入式，这里都是从零基础开始讲的，一开始讲的是C语言基础，老师在讲的时候都是在捞干货给我们，并且还会用好玩的例子使一些难懂的问题变得好理解，上课也不会想的枯燥。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c47a24f461efb3a22ca033fc003c381f/" rel="bookmark">
			vue3源码阅读【compiler-core\src\parse.ts】【baseParse】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		baseParse 根据参数options 和 html字符串执行 createParserContext 生成解析对象 context ，属性 options 值 为 参数 options 和默认配置 defaultParserOptions， 属性 source 和 originalSource 为参数 html字符串 ，barseParse 执行完后返回的是 ast 语法树 export function baseParse( content: string, options: ParserOptions = {} ): RootNode { const context = createParserContext(content, options) const start = getCursor(context) return createRoot( parseChildren(context, TextModes.DATA, []), getSelection(context, start) ) } function createParserContext( content: string, rawOptions: ParserOptions ): ParserContext { const options = extend({}, defaultParserOptions) let key: keyof ParserOptions for (key in rawOptions) { // @ts-ignore options[key] = rawOptions[key] === undefined ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c47a24f461efb3a22ca033fc003c381f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/519da726d1f524437bc8bb31a7779c58/" rel="bookmark">
			UNI-APP_小程序或h5页面背景音乐的播放与暂停
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在线音频mp3测试地址
http://music.163.com/song/media/outer/url?id=447925558.mp3
在uni-app中写小程序或h5页面时，用到背景音乐，以及图标的旋转动画
一、创建music.js 放在static或新建文件夹 const bgm = uni.createInnerAudioContext(); bgm.src = '../static/bgMusic.mp3' bgm.loop = true; //循环播放 // bgm.autoplay=true; //自动播放 bgm.sessionCategory = 'soloAmbient'; //在后台时不播放，如有其他播放，会暂停其他播放（但在移动端h5中 后台不播放失效）（其他属性自行百度） bgm.volume = 0.4 //音量 var music = { //mute 表示是否是静音，，默认静音 playBgm({ mute = true }) { if (!bgm) return; if (mute) { bgm.pause() } else { bgm.play() } bgm.onPause(() =&gt; {}) bgm.onPlay(() =&gt; {}) bgm.onError((res) =&gt; {}) } } module.exports = music 二、挂载到vue实例中，在main.js中 import music from '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/519da726d1f524437bc8bb31a7779c58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b408851415a76530a17cbc5c6173817a/" rel="bookmark">
			常用benchmark小结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目预研和产品开发中经常有性能评估的需求，性能benchmark是评估性能最常用的手段。本文小结下之前用过的benchmark，先记些流水账，后续有时间再详细整理。
下表是linux native的benchmark，除了x86版本外，也都能找到或者编译出arm版本。
工具名称测试项目#########summary#########项目地址coremarkcpu测评cpu的整体性能（列举、矩阵运算、状态机、CRC）https://github.com/eembc/coremarkcoremark_procpucoremark的升级版，测评cpu整体性能super PIcpu测评PI的计算ftp://pi.super-computing.org/Linux/SPECcpu测评cpu性能http://www.spec.org/spec/dhrystonecpu测评CPU整形计算whetstonecpu测评CPU浮点运算stressapptestcpu&amp;mem主要ddr压力测试，也可以提高cpu负载https://github.com/stressapptest/stressapptestnbenchcpu&amp;mem测评CPU运算性能（整数运算、双精度浮点运算）/mem指数主要体现处理器总线、cache和存储器性能http://www.tux.org/~mayer/linux/bmark.htmlutest_memmem测评mem bandwidthcachebenchmem测评mem&amp;cache bandwidthhttp://icl.cs.utk.edu/projects/llcbench/cachebench.htmlcopybwmem测评mem bandwidthhttp://www.tux.org/pub/benchmarks/CPU/copybw.cramspeedmem测评cache有效带宽bonnieIO测评IO性能http://www.textuality.com/bonnie/FioIO测评文件系统IO性能http://freshmeat.net/projects/fio/iozoneIO测评文件系统IO性能http://www.iozone.org/lmbenchCPU/mem/IO测评cpu/mem/IO bandwidth &amp; latencyhttp://lmbench.sourceforge.net/sysbenchCPU/mem/IO多线程性能测试https://github.com/akopytov/sysbenchcyclictest实时性git.kernel.org/pub/scm/linux/kernel/git/clrkwllms/rt-tests.git 目前移动平台应用得最广，因此可应用与android的benchmark也能找到很多。芯片厂商发布SOC时评估算力习惯与Geekbench的结果，国内安卓手机厂商一般都会在Antutu跑个分。这两个应该是认可度比较高的benchmark了，看过它们较早版本的源码，也确实能够测评移动平台的性能。除这两个之外，还有3DMark,PCMark等，这些会更关注GPU和其它多媒体处理的性能了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83751889da689418f2169034438f1d46/" rel="bookmark">
			跟着代码随想录练算法——二叉树（JS）（下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		跟着代码随想录练算法——二叉树 [106. 从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)[105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)[654. 最大二叉树](https://leetcode.cn/problems/maximum-binary-tree/)[617. 合并二叉树](https://leetcode.cn/problems/merge-two-binary-trees/)[700. 二叉搜索树中的搜索](https://leetcode.cn/problems/search-in-a-binary-search-tree/)[98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)[530. 二叉搜索树的最小绝对差](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/)[501. 二叉搜索树中的众数](https://leetcode.cn/problems/find-mode-in-binary-search-tree/)[236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)[235. 二叉搜索树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)[701. 二叉搜索树中的插入操作](https://leetcode.cn/problems/insert-into-a-binary-search-tree/)[450. 删除二叉搜索树中的节点](https://leetcode.cn/problems/delete-node-in-a-bst/)[669. 修剪二叉搜索树](https://leetcode.cn/problems/trim-a-binary-search-tree/)[108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)[538. 把二叉搜索树转换为累加树](https://leetcode.cn/problems/convert-bst-to-greater-tree/) 106. 从中序与后序遍历序列构造二叉树 当中序遍历和后序遍历都为空时，返回null当中序遍历和后序遍历只有一个值时，构造根节点，返回根节点即可拿出后序遍历最后一个元素，这个是当前根节点的val，根据它去分割中序序列，分成左子树的中序结果和右子树的中序结果由于中序和后序的序列长度一定是相等的，于是可以根据上一步分割出来的左子树的中序结果和右子树的中序结果的长度来分割后序序列，分为左子树的后序结果和右子树的后序结果根据前面两部得到的左右子树的中序和后序来递归建立左子树和右子树 /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {number[]} inorder * @param {number[]} postorder * @return {TreeNode} */ var buildTree = function(inorder, postorder) { if(inorder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83751889da689418f2169034438f1d46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53e6995c0500ddd898848b9f5c2530b0/" rel="bookmark">
			【前端性能优化】前端懒加载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是懒加载？什么预加载？ 懒加载也叫做延迟加载、按需加载，指的是在长网页中延迟加载图片数据，是一种较好的网页性能优化的方式。
有的网站图片很多，而如果一上来就加载所有的图片，会导致网页加载很慢
图片懒加载：等图片正式进入到可视区中时，才加载对应的图片，否则不请求图片
预加载指的是将所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源。通过预加载能够减少用户的等待时间，提高用户的体验。我了解的预加载的最常用的方式是使用 js 中的 image 对象，通过为 image 对象来设置 scr 属性，来实现图片的预加载。
二、图片懒加载的基本实现 图片的加载是由src引起的，当对src赋值时，浏览器就会请求图片资源。根据这个原理，我们使用HTML5 的data-xxx属性来储存图片的路径，在需要加载图片的时候，将data-xxx中图片的路径赋值给src，这样就实现了图片的按需加载，即懒加载。
懒加载的实现重点在于确定用户需要加载哪张图片，在浏览器中，可视区域内的资源就是用户需要的资源。所以当图片出现在可视区域时，获取图片的真实地址并赋值给图片即可。
&lt;div class="container"&gt; &lt;img src="loading.gif" data-src="pic.png"&gt; &lt;img src="loading.gif" data-src="pic.png"&gt; &lt;img src="loading.gif" data-src="pic.png"&gt; &lt;img src="loading.gif" data-src="pic.png"&gt; &lt;img src="loading.gif" data-src="pic.png"&gt; &lt;img src="loading.gif" data-src="pic.png"&gt; &lt;/div&gt; &lt;script&gt; var imgs = document.querySelectorAll('img'); function lozyLoad(){ var scrollTop = document.body.scrollTop || document.documentElement.scrollTop; var winHeight= window.innerHeight; for(var i=0;i &lt; imgs.length;i++){ if(imgs[i].offsetTop &lt; scrollTop + winHeight ){ imgs[i].src = imgs[i].getAttribute('data-src'); } } } window.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53e6995c0500ddd898848b9f5c2530b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c404dfd1179dee8304b8cabbf0e60f70/" rel="bookmark">
			Vue 发送数据请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这边是将我之前开发的一个项目开发记录进行分享一下吧，可能写的不是很好，毕竟还只是一个在校生。只能说还是一个新手小白的开发记录吧。
有需要的可以借鉴一下，有问题哈哈 也欢迎指出，毕竟发现问题才能更好的进步
Vue 发送数据请求 首先，我们需要在终端 安装axios
npm install axios --save
这时候就可以在任何地方进行引用
需要用到的时候就在该地方输入
import axios from 'axios'
原先书写的方式 axios.post( "http://127.0.0.1:8000/axios-server", { account: document.getElementById("account").value, pwd: document.getElementById("psd").value, }, { //url params: { account: document.getElementById("account").value, pwd: document.getElementById("psd").value, }, //请求头参数 // headers: { // height: 180, // weight: 180, // }, // 设置请求体 } ) .then((value) =&gt; { console.log(value); }); 每个页面单写接口 不方便统一修改管理 且重复过多
于是我们创建api页面 整个数据请求由api 页面进行发送
import axios from 'axios' const mytry2 = function (data) { axios.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c404dfd1179dee8304b8cabbf0e60f70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/163fbcacb08cf76b46a770beed4c40e1/" rel="bookmark">
			Nacos的简单使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. Nacos简介 1.1 Nacos = 注册中心+配置中心
1.2 Nacos 支持几乎所有主流类型的“服务”的发现、配置和管理，如：
Kubernetes ServicegRPC &amp; Dubbo RPC ServiceSpring Cloud RESTful Service 1.3 Nacos 可与spring，springboot，springcloud，dubbo，docke， k8s一起使用，详细使用教程可参考官网资料：Nacos文档
二. Nacos原理 用户端在nacos注册自身服务，并自动将nacos服务列表拉取到本地服务列表。同时通过心跳定时检测nacos服务列表，若列表有更新，则客户端自动拉取nacos服务列表到本地。客户端通过本地服务列表连接到相应服务。
2.1 注册中心原理
2.2 配置中心原理
三. Nacos的简单使用 3.1 下载安装Nacos
下载地址：Nacos安装包，官方推荐稳定版本是2.0.3
将下载得到的安装包解压后进入bin目录，打开命令窗口
输入命令，等待Nacos执行(standalone代表着单机模式运行，非集群模式)：startup.cmd -m standalone
如下图，Nacos启动成功，Nacos默认启动端口号为8848
通过http://localhost:8848/nacos访问Nacos。Nacos默认登录账户和密码都是nacos
至此，Nacos安装启动成功
3.2 将客户端服务注册到Nacos上
引入Nacos服务发现依赖 &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; 配置Nacos信息，此处为.yml配置用例。name为注册到Nacos上的服务名称（name不支持下划线，可以包含中划线）
nacos上的配置优先级大于客户端本地服务配置优先级，服务启动时优先读取nacos配置文件，相同部分覆盖本地配置信息。 spring: application: name: nacos-test cloud: nacos: discovery: username: nacos password: nacos server-addr: localhost:8848 namespace: public #暴露所有web端点 management: endpoint: web: exposure: include: '*' 在项目启动类上添加注解，让服务能够被注册中心发现：@EnableDiscoveryClient
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/163fbcacb08cf76b46a770beed4c40e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f1610254afc31d0df418b75734d5190/" rel="bookmark">
			队列深度对磁盘IOPS的影响
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、FIO测试命令：
测试命令为：[root@KingStack-FIO ~]# fio -ioengine=libaio -bs=4k -direct=1 -thread -rw=randwrite -size=1000G -filename=/dev/vdb -name="KingStack EBS 4K randwrite test" -iodepth=1 -runtime=60
简单介绍一下FIO的参数： ioengine: 负载引擎，一般使用libaio，发起异步IO请求。
bs: 单次IO的块文件大小为4K。
direct: 绕过操作系统Cache。因为我们测试的是磁盘，而不是操作系统的Cache，所以设置为
1、使测试结果更真实。 rw: randwrite 测试随机写的I/0。
size: 寻址空间，一般设置为磁盘的大小。
filename: 测试对象。
iodepth: 队列深度，只有使用libaio时才有意义。这是一个可以影响IOPS的参数。
runtime: 测试时长。
2、测试分析 下面我们做两次测试，分别 iodepth = 1和iodepth = 4的情况。下面是iodepth = 1的测试结果。
上图中蓝色方框里面是测出的IOPS 4235, 青色方框里面是每个IO请求的平均响应时间，大约是0.22ms。黄色方框表示95%的IO请求的响应时间是小于等于 0.474 ms。紫色方框表示该磁盘的利用率已经达到了91.85%。
下面是 iodepth = 4 的测试: 我们发现这次测试的IOPS所有提高，IO平均响应时间也变大一些。为什么这里提高队列深度起到作用了language呢，原因当队列深度为1时，磁盘的利用率才达到91.85%，说明磁盘还有很多空闲时间可以压榨。对于SSD磁盘，当增加队列深度时，会增加IOPS，同时也会增加响应时间，但达到一定程度后，IOPS反而会下降，此时IO平均响应时间增加较大，因为磁盘利用率已经达到一个稳定状态了。
下面是对一块SSD磁盘的4K随机写性能统计： 3、结论 3.1、增加队列深度，可以看到IOPS不会随着队列深度的增加而一直增加，达到一定值后会有所下降。
3.2、增加队列深度，可以测试出磁盘的峰值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a8dc00038b3197511ebb7b4d35377ce/" rel="bookmark">
			c语言 打印星号金字塔
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 题目要求一、实现代码结果图 二、代码步骤1、画图分析2、实现图一分析2、实现图二分析 三、思考怎么打印倒金字塔 题目要求 1、打印金字塔
2、键盘输入金字塔的层数
一、实现代码 #include&lt;stdio.h&gt; int main() { int j = 1, i = 1, count = 3;//1、1默认层数为3 int k = 0,empty = 0; //2.1、初始化空格 scanf("%d",&amp;count);//3、键盘输入 for (j = 1; j &lt;= count; j++)//金字塔层数 { for (empty = 0; empty &lt; count - j; empty++)//2.2打印空格 { printf(" "); } k = 2 * j - 1;//1.3因为for循环的表达式1会把i初始化所以用k代表结束条件 for (i = 1; i &lt;= k; i++)//1.2每层金字塔的个数 { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a8dc00038b3197511ebb7b4d35377ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d276955307140790978fd8fd30eaf152/" rel="bookmark">
			XJOI一级六段题解（g&#43;&#43;，即C&#43;&#43;），也可视作C&#43;&#43;算法竞赛教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 [Problem 1110](https://xjoi.net/problem/1110) 某年某月有几天一 题目内容二 新知识点2.1 一维数组 三 思路四 AC代码 [Problem 9358](https://xjoi.net/problem/9358) Maoge的游戏一 题目内容二 新知识点三 思路四 AC代码 [Problem 9354](https://xjoi.net/problem/9354) maoge的硬币一 题目内容二 新知识点三 思路四 AC代码 [Problem 1197](https://xjoi.net/problem/1197) 小帅打电话一 题目内容二 新知识点2.1 while循环 三 思路四 AC代码 [Problem 9302](https://xjoi.net/problem/9302) 自动找人系统一 题目内容二 新知识点2.1 long long类型2.2 n n n进制 三 思路四 AC代码 [Problem 3904](https://xjoi.net/problem/3904) 年龄计算一 题目内容二 新知识点三 思路四 AC代码 Problem 1110 某年某月有几天 一 题目内容 时间：1s 空间：256M
题目描述：
闰年问题：已知某年某月，计算该月有几天。
输入格式：
输入一行，包含两个正整数 y e a r , m o n t h year,month year,month ，代表年和月。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d276955307140790978fd8fd30eaf152/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aabd72c5e0f44309bfbafd5619467c9e/" rel="bookmark">
			容器中的nginx日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. nginx容器中的日志2. nginx容器日志持久化 1. nginx容器中的日志 root@op-web-584664588b-629q2:/var/log/nginx# pwd /var/log/nginx root@op-web-584664588b-629q2:/var/log/nginx# ls -l total 32 lrwxrwxrwx 1 root root 11 Jul 22 10:13 access.log -&gt; /dev/stdout lrwxrwxrwx 1 root root 11 Jul 22 10:13 error.log -&gt; /dev/stderr 如上可见：
日志位置
/var/log/nginx目录下日志输出
是两个软连接，分别输出到/dev/stdout和/dev/stderr两个位置。
这实际是输出到了容器的前台日志。（我们在容器中读这个文件是没有输出的） 2. nginx容器日志持久化 持久化存储只需要将/var/log/nginx 目录挂载出来，两个软连接自然就没有了，日志被保存在文件中。
但此时，容器前台日志也不会输出这些信息了。
测试一下
nginx.conf 设置如下（当然k8s是通过configmap挂载出来的）
为了对比，我们保留两个软连接，重新创建两个日志文件 http { error_log /var/log/nginx/error2.log info; rewrite_log on; access_log /var/log/nginx/access2.log; ...... 结果
root@op-web-584664588b-629q2:/var/log/nginx# ls -l total 44 lrwxrwxrwx 1 root root 11 Jul 22 10:13 access.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aabd72c5e0f44309bfbafd5619467c9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4184394fbde7b32c6b2bbf589080bb79/" rel="bookmark">
			【15】SpringBoot快速整合Mybatis&amp;MybatisPlus
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot快速整合Mybatis&amp;MybatisPlus 01、目标 整合mybatis和mybatis-plus实现数据库的增删改查 。
官方文档和学习资料 参考课程：https://www.kuangstudy.com/course/detail/1321004290617901058
mybatis-plus官方手册：https://mp.baomidou.com/guide/
02、整合mybatis 02-01、引入mybatis-plus依赖 &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.17&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatis-plus--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.0&lt;/version&gt; &lt;/dependency&gt; 注意：这个时候很多的刚搭建框架的时候就遇到的问题？如下： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Q0M3nd2t-1658332051279)(assets/1624715371572.png)]
02-02、在application.yml进行配置数据源 1、新建一个applicaiton.yml # 环境隔离 spring: profiles: active: dev server: compression: # 请求gzip压缩 enabled: true mime-types: text/html,text/xml,text/plain,text/css,text/javascript,application/javascript,application/json,application/xml min-response-size: 1024 application: name: edu-front-web # 模板视图 thymeleaf thymeleaf: cache: false prefix: classpath:/templates/ mode: HTML encoding: UTF-8 # json的转换配置 jackson: date-format: yyyy-MM-dd HH:mm:ss time-zone: GMT+8 locale: zh_CN generator: write-numbers-as-strings: true write-bigdecimal-as-plain: true ##mybatis的原生态支持 mybatis-plus: mapper-locations: classpath*:/mapper/*.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4184394fbde7b32c6b2bbf589080bb79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/700b7b2231a69e51d051ae6998784058/" rel="bookmark">
			warmup_csaw_2016
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、查看文件二、拖入IDA pro 中反编译三、编写代码总结 一、查看文件 先file ./warmup_csaw_2016查看文件类型再checksec --file=warmup_csaw_2016检查一下文件保护情况。
二、拖入IDA pro 中反编译 用IDA Pro 64bit打开warmup_csaw_2016后按 F5 反汇编源码并查看主函数，发现 gets()函数读取输入到变量 v5 中， v5 的长度只有 0x40，即可用栈大小只有64字节，但是gets()函数并没有限制输入，显然存在栈溢出漏洞。
在Functions window可以看到有一个sub_40060D()函数，按F5反汇编可以看到这是一个系统调用，且sub_40060D()函数的起始地址为0x40060D。
三、编写代码 from pwn import * # remote()建立远程连接,指明ip和port io = remote('node4.buuoj.cn', 26694) payload = b'a'*(0x40 + 0x8) + p64(0x40060D) io.sendline(payload) #发送数据 io.interactive() #与shell进行交互 总结 做了几道入门的题，从原来的柔弱蚂蚁到现在稍稍强壮的蚂蚁，我决定实施菜狗子计划，让蚂蚁继续进化。
题目中的思路很清晰，对于栈溢出，我们先判断是否有栈溢出的漏洞，之后去找系统调用的函数，然后查到他的地址，最后就是我们的代码构建了。
偏移量的计算=（数组本身大小+对应位的偏移 64位是 ox8 ）
然后加上我们系统调用函数的地址。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e25bd613a680704f71f05cbf4f46baa1/" rel="bookmark">
			DBSCAN点云聚类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、DBSCAN算法原理 DBSCAN是一种基于密度的聚类方法，其将点分为核心点与非核心点，后续采用类似区域增长方式进行处理。下图为DBSCAN聚类结果，可见其可以对任意类别的数据进行聚类，无需定义类别数量。
DBSCAN聚类说明
DBSCAN聚类过程如下：
1、首先，DBSCAN算法会以任何尚未访问过的任意起始数据点为核心点，并对该核心点进行扩充。这时我们给定一个半径/距离ε，任何和核心点的距离小于ε的点都是它的相邻点。
2、如果核心点附近有足够数量的点，则开始聚类，且选中的核心点会成为该聚类的第一个点。如果附近的点不够，那算法会把它标记为噪声（之后这个噪声可能会成为簇中的一部分）。在这两种情形下，选中的点都会被标记为“已访问”。
3、一旦聚类开始，核心点的相邻点，或者说以该点出发的所有密度相连的数据点（注意是密度相连）会被划分进同一聚类。然后我们再把这些新点作为核心点，向周围拓展ε，并把符合条件的点继续纳入这个聚类中。
4、重复步骤2和3，直到附近没有可以扩充的数据点为止，即簇的ε邻域内所有点都已被标记为“已访问”。
5、一旦我们完成了这个集群，算法又会开始检索未访问过的点，并发现更多的聚类和噪声。一旦数据检索完毕，每个点都被标记为属于一个聚类或是噪声。
与其他聚类算法相比，DBSCAN有一些很大的优势。首先，它不需要输入要划分的聚类个数。其次，即使数据点非常不同，它也会将它们纳入聚类中，DBSCAN能将异常值识别为噪声，这就意味着它可以在需要时输入过滤噪声的参数。第三，它对聚类的形状没有偏倚，可以找到任意大小和形状的簇。
DBSCAN的主要缺点是，当聚类的密度不同时，DBSCAN的性能会不如其他算法。这是因为当密度变化时，用于识别邻近点的距离阈值ε和核心点的设置会随着聚类发生变化。而这在高维数据中会特别明显，因为届时我们会很难估计ε。
从已有的聚类效果上来看，将一些点定义成噪声点，没有进行聚类。因此也可以理解成这样：先对点进行去噪处理，再使用距离聚类（如欧氏聚类）实现点的聚类。
对三维点云数据的聚类结果如下：
2、源码下载 基于C++编写的源代码下载地址：
https://download.csdn.net/download/qq_32867925/86246799
只需要将三个头文件加载到工程中即可
DBSCAN核心代码：
DBSCANKdtreeCluster&lt;pcl::PointXYZ&gt; ec; ec.setCorePointMinPts(10); // test 4. uncomment the following line to test the EuclideanClusterExtraction // pcl::EuclideanClusterExtraction&lt;pcl::PointXYZ&gt; ec; pcl::search::KdTree&lt;pcl::PointXYZ&gt;::Ptr tree(new pcl::search::KdTree&lt;pcl::PointXYZ&gt;); tree-&gt;setInputCloud(cloud); std::vector&lt;pcl::PointIndices&gt; cluster_indices; ec.setClusterTolerance(0.1);//搜索近邻点半径 ec.setMinClusterSize(100);//最小簇点数要求 ec.setMaxClusterSize(5000000);//最大簇点数限制 ec.setSearchMethod(tree); ec.setInputCloud(cloud); ec.extract(cluster_indices); clock_t end_ms = clock(); std::cout &lt;&lt; "cluster time cost:" &lt;&lt; double(end_ms - start_ms) / CLOCKS_PER_SEC &lt;&lt; " s" &lt;&lt; std::endl; pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr cloud_clustered(new pcl::PointCloud&lt;pcl::PointXYZI&gt;); int j = 0; // visualization, use indensity to show different color for each cluster.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e25bd613a680704f71f05cbf4f46baa1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dce6e43234dc4935b6fa69335a3d3f3/" rel="bookmark">
			事件绑定和移除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		事件：是用户与页面交互的桥梁，页面通过事件告诉用户做了哪些操作
事件的绑定方式
1 如果事件函数代码量少，可以直接写标签的onlick属性上面
&lt;button οnclick="var con='hello';alert(con)"&gt;点我1&lt;/button&gt;
2 绑定方式 添加onclick属性=函数调用格式
&lt;button οnclick="f1()"&gt;点我&lt;/button&gt;
3 绑定方式 通过js添加onclick属性进行绑定
&lt;button id="b3"&gt;点我3&lt;/button&gt;
4 绑定方式
&lt;button id="b4"&gt;点我4&lt;/button&gt;
function f1(){
console.log(this,"++++")//window
console.log(event)//事件对象
//event.target 代表的是按钮元素对象
event.target.style.backgroundColor="red"
}
//DOM0事件：通过添加onclick属性进行绑定事件的方式，只能绑定一个方法。
var btn3=document.querySelector("#b3")
btn3.οnclick=function(){
console.log*(this,"++++")//buttton对象
console.log(event)
this.style.backgroundColor="yellow"
}
btn3.οnclick=function(){
console.log("ddd");
}
//把事件移除的方式 dom移除方式 把onclick属性=""或者null
//btn3.οnclick=''
//btn3.οnclick=null
//DOM2事件 可以绑定多个事件函数，并且可以通过true/false设置在捕捉或者冒泡过程触发函数
var btn4=document.querySelector("#b4")
//addEventListener() 添加事件监听
//参数1 事件名，不带on的
//参数2 事件函数
//参数3 true/false
function ff(){
console.log("ff")
}
function fff(){
console.log("fff")
}
btn4.addEventListener("click",ff,false)
btn4.addEventListener("click",fff,false)
//移除事件函数
btn4.removeEventListener("click",fff)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f85ca53cfcabbc5c11fcba6cb54da88a/" rel="bookmark">
			麒麟安装nodeps
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载nodejs
解压上传到linux相关路径下，一般是/usr/local/，并执行如下命令 xz -d node-xxxx.tar.xz ---将tar.xz解压成tar文件
tar -xvf node-xxxx.tar ---将tar文件解压成文件夹
mv node-xxx node ----改文件夹的名字，改成node
三、检查是否可以安装成功 四、配置软连接，使全局都可以使用node命令 ln -s /usr/local/node/bin/node /usr/bin/node --将node源文件映射到usr/bin下的node文件
ln -s /usr/local/node/bin/npm /usr/bin/npm
五、配置node文件安装路径 进入/usr/local/node/路径下:
mkdirnode_global
mkdirnode_cache
npm config set prefix "node_global"
npm config set cache "node_cache"
六、当你觉得npm慢的时候，可以安装cnpm npm install cnpm -g --registry=https://registry.npm.taobao.org
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/969b52b3c430c4fd78252b3bd9cabf78/" rel="bookmark">
			烽火通信重磅发布：智慧光网LIGHTS解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以光为引，智引未来。7月20日上午，烽火通信面向全网线上直播发布智慧光网最新成果，以极简Lite、智能Intelligent、绿色Green、融合Hybrid、高效Turbo和安全Safe六大特性组成LIGHTS解决方案。
发布会上，烽火通信总裁蓝海发表致辞讲话，蓝海表示，烽火通信此次智慧光网LIGHTS解决方案发布，是在算力网络背景下，以不断强化光网络效能为指引，夯实数字化中国这一宏伟蓝图的地基，在组网思路、网络架构以及绿色低碳等多个维度的创新。
烽火通信副总裁范志文发表了题为《以光为引，智引未来》的主旨演讲，对LIGHTS解决方案的六大特性进行了详尽讲解。在演讲中，范志文提到算力网络是推动数字经济发展的重要基础设施，算力网络包括算力基础设施、网络基础设施以及算网大脑。智慧光网“极简、智能、绿色、融合、高效、安全”的应用优势，有利于推动“算光协同”向“算光融合”直至“算光一体”的最终目标不断演进和落地。
• Lite极简，化繁为简效率提升
全光网络的极简包括极简架构、极简开通和极简运营，目标是化繁为简，进行效率提升。依托ROADM/OXC可在全国范围内构建“1ms(市内)-5ms(省内)-20ms(全国)”时延圈，OXC的应用还大幅降低了85%机房空间和80%机盘槽位占用，从而实现了光网的极简架构。通过DHCP、ZTP等新技术的引入，站点的光层、电层开通时间大幅缩减，业务下发进一步优化至分钟级，实现了业务的极简开通。业务的运营从过去的跨部门、多流程审批的纸质工单演变至线上APP，用户可以自开通、自管理和自调整，实现极简运营。
• Intelligent智能，自感知自配置自优化
网元智能化是自治网络的基石，通过光纤光缆、光器件、光链路的数字化可实现资源可视化，以及引入AI技术并结合网元运行过程中的管理和控制，可实现网元自配置、自优化；管控层是实现单域自治的大脑，依托数字孪生技术构建与物理网络实时交互的平行世界，可实现各单域产品的“感知-分析-决策-执行”智能闭环，并贯穿“规划-建设-维护-优化-运营”全流程；通过智慧大脑、数智中台的构建可实现跨域协同的数智大脑，实现业务协同与网络协同，推动业务运营的高质量、高效率发展。通过多产品拉通形成业务闭环，实现网络协同支撑运维降本增效，以及基于多维数据的事件管理，能够实现全域故障关联、智能工单压减、RCA告警压缩等功能。
• Green绿色，积极响应双碳战略
智慧光网依托自身优势，努力推动双碳战略目标实现。在设备层面，依托芯片制程工艺、光电集成工艺和AI节能等技术的提升，可大幅减少设备自身能耗；在网络组织层面，包括全光接入、全光传输和全光交换在内的全光网络，较之传统的铜线接入、IP承载等在能耗方面具有明显优势。就社会发展而言，“东数西算”国家战略工程依托光网络强大运力并利用东西部自然条件差异形成的PUE差别，以一个1万架规模的数据中心为例，每年可节约1.7亿度电能能源消耗，从而产生巨大社会价值。
• Hybrid融合，算光一体价值创新
智慧光网依托技术和架构的先进性，可实现光电、业务和算网三个层面的融合，助力算光一体价值创新。三混、OSU技术实现业务的高效承载，光电混合交叉既满足了中小颗粒业务的灵活调度又支持了波长级大颗粒业务的“一站直达”；信元统一交换技术支持了ODUk/TDM/PKT业务的统一承载，OTN CPE加强了OTN网络的覆盖，OTN网络由过去的管道转变为支持ToC/ToB/ToH业务开展的业务网络；通过地址感知、流量感知、算力感知等技术，进一步增强OTN网络业务感知能力，并依据业务感知信息进行网络灵活弹性调度，做到一点接入，用户灵活联接多算力节点，业务级动态调整并最终实现算光一体的目标。
• Turbo高效，面向用户提供差异化服务
智慧光网支持高效运力、高效承载和高效运营，可面向用户提供差异化服务。400G结合C+L波段扩展技术可在单根光纤上提供32 Tbits/s的超强运力，100T用户数据在400G速率下仅需4.25分钟就可实现数千公里的“搬运”。智慧光网可在时隙、端口和波长等不同维度支持端到端切片，在一张物理网络上为不同客户、不同等级业务实现差异化承载。通过光层OVPN技术可实现不同用户切片资源的单独管理，从而实现一网承载、多子网运营的目标。通过北向开放可编程，将网络能力提供并开放给上层系统和最终用户，实现NaaS网络服务以及跨域跨厂商的网络能力开放。
• Safe 安全，立体全方位护航
算力网络时代，在资源高度协同、网络灵活开放、数据高速流通的应用环境下，在网络层面如何提供立体全方位安全保护变得尤为重要。智慧光网可在介质、信道和业务三个层面提供安全保护，保障用户业务安全无忧。介质层面，依托光纤传感、AI和光层数字化等技术可对光缆的施工、主备路由同缆进行预警，主动强化介质层面安全。信道层面，烽火已支持自主可控满足国密标准的加密方式，支持量子密钥分发功能的引入，按需为用户提供不同方式的信道加密服务。业务层面电层分布式ASON、光层集中式WSON已在现网进行大规模应用，光层和电层保护与恢复的相结合，实现了资源与业务安全性的较优均衡。
智慧光网LIGHTS解决方案的提出，离不开光网技术创新作为支撑和保障。在本次发布会中，烽火通信网络产出线副总裁张宾介绍了LIGHTS解决方案背后的四大黑科技支柱：通信元宇宙、算力最优解、集约低功耗和安全防护伞，进一步诠释烽火在算力时代下的光网技术突破。
• 通信元宇宙
通信元宇宙将通信场景和通信系统进行仿真建模加以孪生，在时间和空间等多个维度上，实现网络数字化构建。烽火通过光网感知算法对底层数据进行订阅式网络遥测以及高维清洗，对体量庞大的底层数据精准实时获取；通过CNN算法以及eHMI交互构成模型构建算法，搭建高真实性、可视化的数字孪生网络，增强用户体验，让业务触手可及；通过仿真预测模型算法在时间和逻辑两个层面评判网络事件间的关联性，从而实现万级要素预测。
• 算力最优解
烽火通信算力板卡不仅能提升网络节点的处理能力，也能充当算网节点，在有特定需求的算网场景下与MEC边缘云贴近客户提供算力输出。同时，智慧光网算力大脑能够在局端路由计算中实时感知链路时延和负载，采用“节点+负载”双重因子加权测算，从而得到算力链路最优解。
• 集约低功耗
设备器件集约化、设备管理智能化是网络节能降耗的两条有效途径。在器件级节能方面，烽火通信通过设计、应用先进制程芯片，将Fabric芯片、业务处理芯片SoC集成合2为1，减少芯片Serdes互联，以及光电共封装实现光网大幅节能降耗；在AI智能降耗方面，烽火通信通过网络AI智能管控，采用灵活池化供电的高效电源池、领先的无级变速设备散热系统以及自适应休眠技术，在管控层面实现节能降耗。器件与管控节能相结合，助力双碳目标达成。
• 安全防护伞
烽火通信始终致力于保障客户网络安全平稳运行，为光网络提供立体式网络保护方案。在算法密钥级加密层面，烽火通信独创量子加密创新方案，实现QKD与OTN完美整合，实现加密及密钥分发一体。烽火通信自主研发基于L波段的光纤振动传感技术，区别于传统C波段振动传感技术，传感信号更好的与业务信号共纤传输，并能实现100公里传感距离，±50m振动点感知精度。通过光栅阵列大容量光纤传感网络技术，针对隧道、路网、桥梁等大型公共设施应用场景构建全时全域全天候感知体系，具备大容量、广覆盖、高精度、高可靠等特点，服务行业基础设施应用，实现多维度安全保障。 数字连接是数字中国高质量发展的重要基础设施，光网络是信息通信基础设施的坚实底座。烽火通信始终践行“最大限度挖掘数字连接价值，造福人类社会”的企业使命，以智慧光网构建全光底座为云网、算网业务发展奠定坚实基础，并持续推动算力网络从“算光协同”向“算光融合”直至“算光一体”的最终目标不断演进，助力“东数西算”国家战略落地。以光为引，智引未来，共同推进光网络产业繁荣与发展。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/523a7f04aebf871afaff1dd6e665a39a/" rel="bookmark">
			m3u8 ts文件利用系统工具COPY合并序列TS文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现原理：
1、批量下载.ts文件到系统文件夹，
2、不破坏文件命名规则-重命名，并保存在一个INT数组
如：我下载的文件名都是：
191925499348-3_3990_16.ts
191925499348-3_3989_17.ts
191925499348-3_3968_18.ts
191925499348-3_3968_19.ts
191925499348-3_3968_X.ts
前面是一个数字串的规则我们不管。一会我们重命名的时候，只要记录尾数的序号。将尾数（16、17、18...存入数组）
3、生成COPY语句，TS文件由升序排列：copy /b 16.ts+17.ts+18.ts+19.ts+20.ts...
4、打开 CMD,复制语句执行。
Private Sub Form_Load() Dim strDir$ Dim strFile$ Dim sPath$: sPath = "E:\迅雷下载\视频任务组_20210702_1129\" Dim newPath$: newPath = "E:\迅雷下载\视频任务组_20210702_xyb\" Dim fnamelst$ Dim Wjm() As String strDir = Dir("E:\迅雷下载\视频任务组_20210702_1129\") Dim firstRedim As Boolean Do If InStr(strDir, ".ts") &gt; 0 Then strFile = strFile &amp; "+" &amp; strDir Dim fname$: fname = Split(strDir, ".")(0) Dim newFname$ newFname$ = Right(fname, Len(fname) - InStrRev(fname, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/523a7f04aebf871afaff1dd6e665a39a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18ae4b34f81a56f5dca20523c7c118c7/" rel="bookmark">
			国际顶级会议--计算机视觉\人工只能\机器人
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. Robotics 机器人 会议 ICRA：IEEE International Conference on Robotics and Automation 即IEEE机器人和自动化国际会议，由IEEE Robotics and Automation Society (RAS,机器人和自动化学会)主办该领域规模（千人以上）和影响力最大的顶级国际会议。至今（2012年）已经成功举办了29届，只在中国举办过一次（2011年，中国上海）。ICRA每年都设立一个主题（Theme），例如"Better Robots, Better life"@2011，"Robots and Automation: Innovation for Tomorrow's Needs."@2012。另外，ICRA附带有一个精彩的展览，例如ICRA2012上露面的包括全球第一个宇航机器人Robonaut、当今最先进的医疗机器人Davinc...ICRA一般每年9月截止收稿，来年5月中上旬举行会议，全EI光盘版收录。近两年收稿情况：2011年，收稿约2000余，录用约980，录用率约49%；2012年，收稿2032篇，录用818篇，录用率40.25%，为历年最低。ICRA2013、2014将分别在Karlsruhe, Germany和中国香港举行
IROS：IEEE\RSJ International Conference on Intelligent Robots and Systems 即IEEE\RSJ智能机器人与系统国际会议，主要由IEEE RAS，RSJ（the Robotics Society of Japan）等五个协会发起，规模（千人左右）和影响力仅次于ICRA的顶级国际会议。IROS始于1988年、日本，曾在中国举办过两次：2006年北京和2010年台湾，2012年10月将在葡萄牙举行第24届年会。与ICRA一样，IROS一般也有主题并附带一个机器人展览。一般每年3月截止收稿，同年10月中旬举行会议，全EI光盘版收录。近两年收稿情况不详，但录用率大概在30-50%之间，IROS2011貌似创造了历史新低。IROS2013、2014将分别在日本东京和美国芝加哥举行。
ROBIO: IEEE International Conference on Robotics and Biomimetics 即IEEE机器人学和仿生学国际会议，同样是IEEE RAS门下的系列会议之一。规模（数百）与影响力次于前两者，截至2011年已成功举办了8届。特别要提一下的是：ROBIO目前实力比前两者是差些，但它是该领域华人区着力打造的品牌国际会议，希望大家共同出份力！也正因此，ROBIO经常光临中国,可能用“经常在中国混”更准确。一般每年7月中旬截止收稿，同年12月初举行会议，一般也是全EI光盘版收录。ROBIO2012将在中国广州举行，
Journal 二区 International Journal of Robotics Research(IJRR) 中科院分区: (2021)
大类学科: 工程技术 2区: 小类学科: ROBOTICS 机器人学2区
大类学科: 计算机科学 3区: 小类学科: ROBOTICS 机器人学3区
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18ae4b34f81a56f5dca20523c7c118c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad1f4a2483ad29b250849b1ff7265d06/" rel="bookmark">
			第一个python自动化实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载python安装
验证是否安装pip
python -m pip --version 输出如下，表示安装 pip 19.2.3 from C:\_Program\Python27\lib\site-packages\pip (python 2.7) 安装selenium pip install selenium 查看chrome版本，然后到https://chromedriver.storage.googleapis.com/index.html下载对应的win32.zip
解压zip文件，放在chrome浏览器根目录下
验证是否安装：直接在cmd目录下执行chromedriver即可
配置环境变量，将chrome根目录和python根目录添加到环境变量中。
添加test.py文件，代码如下
# coding=utf-8 from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.common.action_chains import ActionChains from selenium.webdriver.support import expected_conditions from selenium.webdriver.support.wait import WebDriverWait from selenium.webdriver.common.keys import Keys from selenium.webdriver.common.desired_capabilities import DesiredCapabilities class TestTest01(): def __init__(self): self.driver = webdriver.Chrome() self.vars = {} def over(self): self.driver.quit() def test_test01(self): self.driver.get("https://www.baidu.com/") self.driver.set_window_size(1088, 816) self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad1f4a2483ad29b250849b1ff7265d06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b66ecc5823aa100afaca34d4242a37a/" rel="bookmark">
			vxe-table表格自适应高度的实现方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 对于常用的一些管理系统里，其中一种比较常用的布局为比较经典的侧边栏、头部、脚部、以及主题部分的布局，如下图：
如果在上图的Main部分，放置一个表格组件，出于用户体验方面的考虑，需要对表格自适应Main部分宽度、高度进行平铺，即表格组件完整的铺满Main部分，并且需要展示出滚动条方便用户操作。
方案 方案1 vxe-table组件，本身自带一个height属性，height属性可以设置按百分比%设置，也可以按px设置，另外可以设置为'auto'。官方文档对于设置为'auto'的解释如下：
支持铺满父容器或者固定高度，如果设置 auto 为铺满父容器（如果设置为 auto，则必须确保存在父节点且不允许存在相邻元素）
简单点可以直接对vxe-table组件设置height="auto"，即可实现铺满效果。但是需要注意的是，height="auto"只能保证铺满父节点，比如父节点高度100px，那只能铺满100px的高度，再比如父节点高度500px，就只能铺满500px。并且使用时前提是父节点下只能有vxe-table一个组件，否则会导致高度计算错误。
另外需要注意的是，设置height="auto"后，在部分情况下，可能会导致虚拟滚动卡顿的问题，可能是由于在虚拟滚动时重新计算表格高度导致，在这里不展开来说明。
具体代码如下：
&lt;template&gt; &lt;div style="width: 100vw; height: 100vh; background-color: #eee; display: flex" &gt; &lt;div style="width: 150px"&gt;Aside&lt;/div&gt; &lt;div style="width: calc(100vw - 150px)"&gt; &lt;div style="height: 60px; line-height: 60px; background-color: #ddd"&gt; Header部分 &lt;/div&gt; &lt;!-- 需要设置高度，保证父div铺满 --&gt; &lt;div style="height: calc(100vh - 60px - 40px)"&gt; &lt;vxe-table border :data="tableData" height="auto"&gt; &lt;vxe-column type="checkbox" width="60"&gt;&lt;/vxe-column&gt; &lt;vxe-column field="name" title="Name"&gt;&lt;/vxe-column&gt; &lt;vxe-column field="sex" title="Sex"&gt;&lt;/vxe-column&gt; &lt;vxe-column field="date" title="Date"&gt;&lt;/vxe-column&gt; &lt;vxe-column field="address" title="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b66ecc5823aa100afaca34d4242a37a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f47177a607fdfdfe1bbcbedd7bc861f3/" rel="bookmark">
			网络电话通信基础知识-什么是软交换？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		百度百科是这样说的：软交换是一种功能实体，为下一代网络NGN提供具有实时性要求的业务的呼叫控制和连接控制功能，是下一代网络呼叫与控制的核心。 简单地看，软交换是实现传统程控交换机的“呼叫控制”功能的实体，但传统的“呼叫控制”功能是和业务结合在一起的，不同的业务所需要的呼叫控制功能不同，而软交换是与业务无关的，这要求软交换提供的呼叫控制功能是各种业务的基本呼叫控制。
交换系统
多媒体软交换是为提供以下类型的业务和应用而设计的：
· 会话式多媒体－－在两方或更多方之间同时使用多种媒体进行的实时、延迟敏感的多向通信，如可视电话或视频会议。视频会议可以轻松处理媒体，在会话过程中添加或删除媒体
· 组合业务－－会话业务结合信息相关应用，如目录信息或基于位置的业务（例如业务和白板的存在调用）
·会话业务与其它多媒体业务组合－－如在线游戏结合可视电话或3D电话会议，组成包含社交活动的有趣而丰富多彩的业务。
支持这些类型的业务需要开放体系结构、API和协议。系统必须能够处理多媒体，包括实时视频、视频数据流、三维环绕立体声、数据（包括文本）、图像（如相片和图片）、以及传统但可以选择质量等级的话音。
由于在开始时极少使用新特性，这样，就没有必要在这种平台上重复提供PSTN业务，事实上那样做是一种倒退。
此外，还需要通过互联网上的应用开发商社区以低成本进行应用开发和部署；同样还需要为新用户设备提供多种能力以进行媒体播放和用户输入。
理想情况是，多媒体软交换系统构建在与3GPP（第3代移动网络标准）相同的体系结构之上，并使用会话始发协议（SIP）。SIP是一种新兴的互联网标准，能够灵活地集成消息传递、存在业务、多媒体会议和实时通信（如电话）。它经过精心设计，采用模块化结构，以创新方法集成应用，可以扩展，从而支持新的技术。
使用SIP并在3GPP标准上构建体系结构具有许多重要优势。
首先，SIP是互联网社区的理想选择，基于文本的简单格式使应用开发商能够很快上手（例如，它比二进制格式的H.323更容易使用）。这意味着SIP能够支持更多的应用。
第二，在支持3G移动网络的3GPP体系结构上构建，这就可以使用一个平台为固定和移动用户提供通用的多媒体应用。
第三，SIP使用支持Web应用（如电子邮件和Web浏览器）的现有协议，同时H.323也可以或多或少地重新用于处理这些应用。这意味着在SIP环境中可以更轻松和平滑地进行互通。
爱立信确信SIP是对会话式多媒体通信进行会话控制的一种出色协议。与多媒体业务解决方案相比，新型多媒体软交换系统能够以更高的安全性和更优异的服务质量（QoS）提供多媒体业务，并灵活地进行计费。
传统电话软交换系统
100多年以来，传统电话一直是大型运营商的核心业务，而且电路交换机也在有线和移动网络中得到广泛部署。时分复用（TDM）交换技术是网络中最核心的技术之一，它具有集成应用、控制和连接平台，并且与接入和传统运营支持系统（OSS）密切相关。如果运营商大规模更换他们的TDM交换机，则不但可能失去收入丰厚的本地和汇接电话业务，而且还有为分离接入和OSS付出高昂成本的风险。
最近的标准化工作规定使用H.248和BICC等新信令协议把传统电路交换网络融合到分组交换网络。TDM交换机被撤销，连接平台也从中央处理器和应用软件中分离出来。连接主要由分组基础设施（ATM或IP）来执行，其余的交换机则变成了电话服务器。电话服务器解决方案重新使用电话应用软件和处理器在多业务网络上无逢提供传统电话业务。
多功能软交换解决方案
软交换主要针对特定用户需求，并仅限于满足当前的运营商要求。因此为了充分利用新的市场机遇，需要提供多功能软交换解决方案。
随着新业务的开发和在用户群中的部署，运营商可以在传统电话业务的收入基础上获得额外的收入。
但是，必须认识和考虑到创新性新业务使用率增长缓慢的现状：移动电话和文本消息传递业务经历了5-10年之久才被大众市场广泛接受。包含更多功能的新业务将最终取代传统的电话业务；并且如上所述，个性化的存在管理将会加快这些新业务的流行。因此，在新平台上重新实施所有传统电话业务没有经济价值。此外，这将为现有业电话业务的服务透明度、服务质量以及收入带来风险。
另一方面，使用同一多功能软交换解决方案在彼此独立的呼叫或会话控制平台上分别实施传统电话业务和新型多媒体业务，这意味着可以在避免突然改变收入来源的同时迅速融合所有的传统业务。这还意味着拥有足够的时间等待从软交换系统的各个方面获得回报。此外，在QoS分组骨干上进行构建还意味着这种投资可以使OPEX和CAPEX降至最低，而不会失去任何新的多媒体商机。
采用多功能软交换解决方案，运营商们可以确保现有传统业务的总体透明度；同时获得一个通过全新业务实现收入增长的稳定平台。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27748d04ac4e5f1c4df6a79bd9b2995c/" rel="bookmark">
			报错：Cannot interpret ‘＜attribute ‘dtype‘ of ‘numpy.generic‘ objects＞‘ as a data
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错： 运行info()或者describe()报错： Cannot interpret ‘&lt;attribute ‘dtype’ of ‘numpy.generic’ objects&gt;’ as a data
问题是由numpy、pandas版本引起的，版本过低，无法将 ‘numpy.generic’ objects&gt;’ 的 '&lt;attribute ‘dtype’ 解释为数据类型。
解决方案： 分别更新numpy、pandas到新版本：
pip install -U numpy
pip install -U pandas
如果pip需要更新，可尝试：pip install --user --upgrade pip
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06d3b2da089cd9a161a06be2ab0d9025/" rel="bookmark">
			DHCP服务与配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.DHCP服务
1.1什么是DHCP
1.2DHCP的好处
1.3DHCP分配方式
二.DHCP工作原理
2.1DHCP租约过程
2.2DHCP更新租约
2.3重新登录
三.DHCP配置
3.1DHCP服务安装
3.2DHCP全局配置
ensp配置
引言：在网络地址配置中，当主机比较多的时候，为每台机器配置静态IP时，工作量过于庞大，这个时候我们就需要设置一个动态的获取IP地址方式，也就是今天所说的DHCP。
一.DHCP服务 1.1什么是DHCP DHCP动态主机配置协议：是专门为TCP/IP网络中计算机自动分配TCP/IP参数的协议
DHCP采用C/S架构，C-client（客户机），S-server（服务器）
DHCP服务采用传输层UDP协议，因为是C/S架构，所以客户机端口号是67，服务器端口号是68
1.2DHCP的好处 使用动态主机配置协议。可以减少网络管理员的工作量；避免手动配置时的错位配置；避免IP地址冲突；当更改IP网段时，不需要重新分配每个用户的IP地址；可以提高IP地址使用率；方便客户端的配置。
优点：
减少管理员的工作量
避免输入错误的可能
避免IP地址冲突
当更改IP地址段时，不需要重新配置每个用户的IP地址
提高了IP地址的利用率
方便客户端的配置
1.3DHCP分配方式 1.自动分配：分配一个IP地址后永久使用
2.手动分配：由网络管理员指定IP地址
3.动态分配：使用完后释放该IP，供其它客户机使用
二.DHCP工作原理 2.1DHCP租约过程 DHCP客户端向DHCP服务端请求IP地址的过程，我们称为租约过程
（1）客户机请求IP地址，当一个DHCP客户机启动时，客户机还没有IP地址，所以客户机要通过DHCP获取一个合法IP地址，此时DHCP客户机就会以广播方式发送DHCP Discover发现信息来寻找DHCP服务器
（2）服务器响应当DHCP服务器接收到来自客户机请求IP地址信息时，它就在自己的IP地址池中，查找是否有合法的IP地址提供给客户机，如果有DHCP服务器就将此IP地址做上记号，加入到DHCP offer的消息中，然后DHCP就广播一则DHCP offer消息
（3）客户机选择IP地址，DHCP客户机从接收到的第一个DHCP offer消息中提取IP地址，发出IP的DHCP服务器将该地址保留,这样该地址就不能再分配给另一个DHCP用户，之后DHCP客户机会向服务器发送DHCP Request消息
（4）服务器确定租约DHCP服务器接收到DHCP Request消息后，以DHCP ACK消息的形式向客户机广播成功确认，该消息包含有IP地址的有效租约和其他可配置的信息，当客户机收到DHCP ACK消息时，它就配置 了IP地址，完成TCP/IP的初始化
2.2DHCP更新租约
当DHCP服务器向客户机出租的IP地址租期达到50%时，就需要更新租约； 客户机直接向提供租约的服务器发送DHCP Request包，要求更新现有的地址租约。
2.2DHCP更新租约 当DHCP服务器向客户机出租的IP地址租期达到50%时，就需要更新租约； 客户机直接向提供租约的服务器发送DHCP Request包，要求更新现有的地址租约。
2.3重新登录 DHCP客户机每次重新登录网络时，不需要再发送DHCP Discover信息,而是直接发送包含前一次所分配的IP地址的DHCP Request请求信息。如果次IP地址未被使用，则DHCP服务端发送DHCP ACK确认信息，让客户机继续使用该IP。
若该IP地址被其它客户机使用，DHCP服务端会发送DHCP Nack否认信息。让客户机重新发送DHCP Discover请求，进行新的租约请求。
三.DHCP配置 3.1DHCP服务安装 Linux系统默认是没有DHCP服务的，需要我们自行进行安装
安装DHCP服务：
1.检查并安装dhcp服务
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06d3b2da089cd9a161a06be2ab0d9025/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd3d44e69faa6984dc4608d22281b435/" rel="bookmark">
			【vue】el-form-item添加icon和tooltip
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.el-form-item添加icon与tooltip 使用slot="label"解决，代码如下：
&lt;el-form-item prop="examine6Remark"&gt; &lt;template slot="label"&gt; 审查项目6描述 &lt;/template&gt; &lt;el-input type="textarea" :autosize="{ minRows: 3, maxRows: 6}" placeholder="请输入审查项目6描述" v-model="form.examine6Remark" maxlength="255"&gt; &lt;/el-input&gt; &lt;/el-form-item&gt; 2.tooltip换行实现 使用slot="content"解决，代码如下：
&lt;el-tooltip class="item" effect="dark" placement="bottom"&gt; &lt;div slot="content"&gt; 供应商不得在“信用中国”网站&lt;br/&gt; （www.creditchina.gov.cn）&lt;br/&gt; 被列入“失信被执行人名单”。 &lt;/div&gt; &lt;i class="el-icon-question"&gt;&lt;/i&gt; &lt;/el-tooltip&gt; 最终效果 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c328059c41b3f48a701d784457a9b1dd/" rel="bookmark">
			【微信小程序】组件使用及属性参考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 3.1　视图容器组件3.1.1　视图容器view3.1.2　滚动视图scroll-view3.1.3　可移动视图movable-view3.1.4　覆盖视图3.1.5　滑块视图swiper 3.2　内容组件3.2.1　图标icon3.2.2　进度条progress3.2.3　文本text 3.3　导航组件3.4　小程序UI框架3.4.1　WeUI3.4.2　iView3.4.3　Vant Weapp 3.5　小结 小程序组件微信小程序的开发实际上也是前端开发的一种。我们想要开发一个前端程序，首先要做的就是创建美观的页面，然后处理好业务代码。在用户眼中首先会看到的是页面，而不会关心代码的实现，所以在学习前端开发时通常都是先从HTML、CSS入手，再去学习JavaScript。所以，本章先进行小程序组件的讲解。掌握了视图容器组件、内容组件，并学会使用导航组件进行跳转后，我们就可以开始搭建各种页面了。
本章主要涉及的知识点有：
视图容器组件内容组件导航组件小程序UI框架 3.1　视图容器组件 视图容器组件的主要作用就是“容器”，与按钮、文字、进度条等组件不同，它主要由普通视图、滑动视图、拖动视图等构成，就像我们在画图时的一个个背景画布。
3.1.1　视图容器view view是最基本的视图容器，与前端的div标签比较类似，自身没有任何大小颜色属性，通常作为一个基本容器存在。view的自带属性如表3.1所示。
【示例3-1】
（1）新建一个项目components，用于本节的代码展示。（2）清空index.wxml和index.js的代码，并输入以下代码：
//index.wxml &lt;view&gt;小程序视图组件测试&lt;/view&gt; &lt;button style="margin-top:15px" bindtap="testView"&gt;view&lt;/button&gt; &lt;button style="margin-top:15px" bindtap="testScrollView"&gt;scroll-view&lt;/button&gt; &lt;button style="margin-top:15px" bindtap="testMovableView"&gt;movable-view&lt;/button&gt; &lt;button style="margin-top:15px" bindtap="testCoverView"&gt;cover-view&lt;/button&gt; &lt;button style="margin-top:15px" bindtap="testSwiper"&gt;swiper&lt;/button&gt; //index.wxss view{ margin:16px; } //index.js testview(){ wx.navigateTo({ url:'../view/view',})}, testscrollView(){ wx.navigateTo({ url:'../scroll-view/scroll-view'}) testMovableView(){ wx.navigateTo({ url:'../movable-view/movable-view',})}, testCoverView(){ wx.navigateTo({ url:'../cover-view/cover-view',})}, testSwiper(){ wx.navigateTo({ url:'.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c328059c41b3f48a701d784457a9b1dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27f0ab791419071abd4f7c40aade3491/" rel="bookmark">
			Python之split函数&amp;字符串最后一个单词的长度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python之split函数&amp;字符串最后一个单词的长度 这是牛客一道字符串题 描述
计算字符串最后一个单词的长度，单词以空格隔开，字符串长度小于5000。（注：字符串末尾不以空格为结尾）
输入描述：
输入一行，代表要计算的字符串，非空，长度小于5000。
输出描述：
输出一个整数，表示输入字符串最后一个单词的长度。
示例1
输入：
hello nowcoder
复制
输出：
8
复制
说明：
最后一个单词为nowcoder，长度为8
我的解法是由后往前遍历整个字符串，然后逐个判断他是否是空格，遇到空格停止，然后记录下他的下标，最后算出空格之后的字符串长度。但是可以就有个问题，如果只有一个单词没有空格呢，所以要加个判断，判断一个单词情况，也就是要考虑边界条件。这样代码才不会有奇怪的错。欢迎大佬对我的代码进行优化，因为我只是初步想法。
代码如下：
s = input() a = 0 for i in range(len(s) - 1, 0, -1): if s[i] == ' ': j = (i + 1) a = 1 break # for i in range(j,len(s)-1): # print(s[i]) if a == 1: print(len(s) - i - 1) else: print(len(s)) 牛客大佬解法内存占资源小 通过split函数以空格分割字符串，然后转成数组存起来，这样只要取数组下标最后一个，然后用len函数直接取长度就行。不过这样会比我的时间要久。因为他这个分割是从前往后逐个分割，取最后一个时间势必会久一些。
str = input() arr = str.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27f0ab791419071abd4f7c40aade3491/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28d9614cd087db71cacd9c12d4b6ce9e/" rel="bookmark">
			配置nacos注意点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nacos 概念：nacos是一种将springcloud的每个微服务进行一个统一配置，除此之外，当springCloud的微服务比较多那么，nacos就可以使用命名空间的为每一种类型的服务进行一个区分方便阅读。
nacos配置 第一种可以自主配置，自己区配置nacos。直接使用官方的配置使用 nacos启动以及微服务的配置 注意：nacos的配置必须要与alibaba的依赖管理的版本进行匹配
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-aIQmRPzO-1658249669090)(C:\Users\邪主\AppData\Roaming\Typora\typora-user-images\image-20220720004512796.png)]
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-cQmuydNg-1658249669092)(C:\Users\邪主\AppData\Roaming\Typora\typora-user-images\image-20220720004449019.png)]
在配置属性上的书写方式： application.yml配置文件：
#配置nacos的地址映射 cloud: nacos: discovery: server-addr: localhost:8848 #给微服务取别名 application: name: gulimall-product 在配置Nacos的时候注意： 第一种：检查配置版本是否符合官方要求的配置目标第二种：检查web依赖项是否添加成功第三中：检查：Spring cloud bootstrap依赖项是否添加 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-bootstrap&lt;/artifactId&gt; &lt;version&gt;3.0.4&lt;/version&gt; &lt;/dependency&gt; 注意点： 1.nacos的相关配置，必须配置在bootstrap.xxx(xxx可以是properties，也可以是yaml，还可以是yml)中。因为项目必须要先到配置中心拉取配置信息，需要在application.xml之前执行，在application.xml.中配置无效 2.必须在application.xml中指定使用的环境文件，即明确指出spring.profiles.active:xxx (xxx为你配置文件的环境) spring.profiles.active:xxx (xxx为你配置文件的环境)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f976fbdb6d39ab36f7d82596bc343116/" rel="bookmark">
			smbms 获取角色操作，角色管理实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了我们职责统一，可以把角色的操作单独放在一个包中，和pojo中的对应。
RoleDao（接口）：
package com.Li.dao.role; import com.Li.pojo.Role; import java.sql.Connection; import java.sql.SQLException; import java.util.List; //专职搞Role这一块。 public interface RoleDao { //获取角色列表 public List&lt;Role&gt; getRoleList(Connection connection) throws SQLException; } RoleDaoImpl（实现类）：
package com.Li.dao.role; import com.Li.dao.BaseDao; import com.Li.pojo.Role; import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; import java.util.ArrayList; import java.util.List; public class RoleDaoImpl implements RoleDao{ //获取角色列表 public List&lt;Role&gt; getRoleList(Connection connection) throws SQLException { PreparedStatement pstm = null; ResultSet resultSet = null; ArrayList&lt;Role&gt; roleList = new ArrayList&lt;Role&gt;(); if (connection!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f976fbdb6d39ab36f7d82596bc343116/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bdb50b0ee71df061d72f67261f66bcd/" rel="bookmark">
			js常用逻辑题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一次发csdn，从事这个行业两年多了，也有很多同学也是这个行业，有一些也在大厂混的风生水起，自我认为，想要学好js这门语言，想要在js这条路上走得远，你的逻辑也是很重要的。下面的题是我自己稍微总结的，自己写了下。有一些解题思路也有点复杂。这里圈重点。如果有大神看到，请温柔点喷我。
第一题
将下划线风格的变量名转换成驼峰风格，如： 输入 alipay_first_quiz 返回 alipayFirstQuiz
注：下划线只会出现在单词中间，不会出现在开头或者结尾
function snake2camel(str) { if(str=='' || str == undefined || str == null || str == ''){ return '' }else{ let arr = str.split(''); let a = [] let arr1 = arr.map((el,ind) =&gt; { if(el === '_'){ a.push(ind+1) return el = arr[ind+1].toUpperCase() }else{ return el } }) for(i=a.length-1;i&gt;=0;i--){ arr1.splice(a[i],1) } return arr1.join('') } } 第二题
将驼峰风格的变量名转换成下划线风格，如： 输入 alipayFirstQuiz 返回 alipay_first_quiz function camel2snake(str) { if(str=='' || str == undefined || str == null || str == ''){ return '' }else{ let arr = str.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7bdb50b0ee71df061d72f67261f66bcd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab48f642467b78eead552104e1f39835/" rel="bookmark">
			【Java】面向对象基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		重点回顾 数组的创建： 动态创建： 数据类型[] 数组变量名=new 数据类型[元素个数]静态创建： 数据类型[] 数组变量名={元素1,元素2,…}动态创建并赋初始值： 数据类型[] 数组变量名=new 数据类型[]{元素1,元素2,…} 数组特点： 只能存储相同类型的数据数组中的值可以重复数组的长度是固定的数组是连续的内存空间 相关的算法 冒泡排序二分法查找 系统预定义类型引入 基本类型及其包装类字符串类型日期类型基础随机数 Math.random()Random r=new Random() 练习题 第1题：用递归实现不死神兔：斐波那契在他的一部著作中提出了一个有趣的问题：假设一对刚出生的小兔一个月后就能长成大兔，再过一个月就能生下一对小兔，并且此后每个月都生一对小兔，没有发生死亡
问：现有一对刚出生的兔子2年后(24个月)会有多少对兔子?第2题：猴子吃桃子问题，猴子第一天摘下若干个桃子，当即吃了快一半，还不过瘾，又多吃了一个。第二天又将仅剩下的桃子吃掉了一半，又多吃了一个。以后每天都吃了前一天剩下的一半多一个。到第十天，只剩下一个桃子。试求第一天共摘了多少桃子？第3题：通项公式如下：f(n)=n + (n-1) + (n-2) + … + 1，其中n是大于等于5并且小于10000的整数，例如：f(5) = 5 + 4 + 3 + 2 + 1，f(10) = 10 + 9 + 8 + 7+ 6 + 5 + 4 + 3 + 2 + 1，请用递归的方式完成方法long f( int n)的方法体。第4题：假设有n级台阶，一个人可以一次上1级或者2级台阶，问有多少种上法 参考答案 第1题
public class Test01 { public static void main(String[] args) { Count c = new Count(); int sum = c.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab48f642467b78eead552104e1f39835/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52393e4f4a7eaeba998a827ae9735d7c/" rel="bookmark">
			【故事证明和概率公理】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		故事证明 通过故事来证明一些常用的公式
① C n k = C n n − k C_n^k=C_n^{n-k} Cnk​=Cnn−k​
这个的证明相对较为简单，假设我们有10个人要分成两队，两队的人数分别是4人和6人那么先挑出4人队的成员与先挑出6人队的成员结果相同 ② n C n − 1 k − 1 = k C n k nC_{n-1}^{k-1}=kC_n^k nCn−1k−1​=kCnk​
假设我们要从 n n n个人中选出 k k k个人，并将其中的一人指定为统领，那么将会有两种思路思路一：首先从 n n n人中选出 k k k人，即 C n k C_n^k Cnk​，再从 k k k个之一选出统领，即 k C n k kC_n^k kCnk​思路二：首先从 n n n人中选出一个统领，即 n n n，再从 n − 1 n-1 n−1个人中选出 k − 1 k-1 k−1个人，即 n C n − 1 k − 1 nC_{n-1}^{k-1} nCn−1k−1​因此 n C n − 1 k − 1 = k C n k nC_{n-1}^{k-1}=kC_n^k nCn−1k−1​=kCnk​ ③ C m + n k = ∑ j = 0 k C m j C n k − j C_{m+n}^k=\sum\limits_{j=0}^kC_m^jC_n^{k-j} Cm+nk​=j=0∑k​Cmj​Cnk−j​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52393e4f4a7eaeba998a827ae9735d7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17a240837dba1fbae96d5f97fef0895e/" rel="bookmark">
			linxu 部署 nodejs 环境 / centos 部署 nodejs 环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该文档以 CentOS 6.5 64位 为例
一、安装并配置nodejs 1、下载 nodejs 官网地址：https://nodejs.org/en/download/
2、 上传 nodejs 安装包 将下载的 node-v16.15.1-linux-x64.tar.xz（不同时期不同版本号） 上传至服务器上的 /usr/local/nodejs 文件夹中（nodejs 是手动新建的空文件夹，一般是没有的）
3、解压 nodejs 安装包 3.1、到 /usr/local/nodejs 目录下执行以下命令 tar -xvf node-v16.15.1-linux-x64.tar.xz 3.2、解压完之后更改 文件夹的名字 mv node-v16.15.1-linux-x64/ node 4、更改配置文件 4.1、打开配置文件 vi /etc/profile 4.2、在 profile 的配置文件中的尾部加入以下代码 export PATH=$PATH:/usr/local/nodejs/node/bin 4.3、执行以下命令保存配置 source /etc/profile 5、检查 node 是否安装成功 node -v npm -v 二、可能遇到的报错 在检查 node 是否安装成功的时候可能会遇到以下报错
node: /lib64/libc.so.6: version `GLIBC_2.16' not found (required by node) node: /lib64/libc.so.6: version `GLIBC_2.17' not found (required by node) node: /lib64/libc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17a240837dba1fbae96d5f97fef0895e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/396dac5e817f4444b3dd098b174d4407/" rel="bookmark">
			初学者必看Markdown 使用指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是 Markdown ？
Markdown 文档遵循一种特定的语法，容易阅读和写作。它们是纯文本，所以能够通过电脑上的任何文本编辑器来创建。然后这些文档能够转换成网页 —— 而网页是用一个叫做 HTML 的语言标记创建的。
Markdown 只是一种不必（即使知道怎么做）写 HTML 代码就能够创建网页的方式。实际上，如果你不转换成 HTML 的话，Markdown 甚至是个对纯文本格式化的好方法。有人曾这样对我描述 Markdown ：
“ 它不是所见即所得，而是所见即所意 ”。
然而，Markdown 不只是一个简单的格式化体系，它也是一个纯文本格式转化到 HTML 的一个软件工具。
这就是为什么语法很重要。如果你想在网页上起个标题，Markdown 将会基于你标题前面的字符来创建。Markdown 的一些语法示例如截图所示：
Markdown to HTML conversion
所以我怎样才能使纯文本文件转换成 HTML 格式呢? John Gruber 的 Markdown 是一个运行在命令行上的 Perl 脚本。也就是说，它可以读取你创建的 Markdown 文本并用它来构建网页。
由于有许多著名的编辑器 可以为你做这个转换，我在这里尽量避免使用命令行。不仅如此，许多这样的编辑器会让你写下你的文本，并同时向你展示网页的样子（称为渲染）。
Markdown 编辑器总的来说设置了两帧：左边部分是你要写你文本的地方，右边部分是用 HTML 语言显示给你格式化后文本的样子：
Most Markdown editors have two panes to write and preview the text
当你用它满意地完成你的写作，只需保存 Markdown 文件即可。就像这样，之后一旦你需要编辑和修改的时候，你就会用到它。文件保存后，你可以用编辑器将 Markdown 文档导出为 HTML 格式的文档。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/396dac5e817f4444b3dd098b174d4407/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39305b11443d6f3215c006416b443af0/" rel="bookmark">
			经典实例分割模型Mask RCNN原理与测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Mask RCNN简介 区域卷积神经网络 RCNN（Region-Convolutional Neural Networks）为两阶段目标检测器。通过对图像生成候选区域，提取特征，判别特征类别并修正候选框位置。 RCNN系列目前包含两个代表模型：Faster RCNN，Mask RCNN。
Mask R-CNN是He Kaiming大神2017年的力作，其在进行目标检测的同时进行实例分割，取得了出色的效果。
Mask-RCNN使用Resnet101作为主干特征提取网络，也就是图中的CNN部分，其对输入的图像image要求其是正方形且宽高可以整除2的6次方，不足的将会在外侧添加灰色区域。
Resnet101主干特征提取（CNN） 一张图像image传入到 Resnet101(CNN) 之后，会对其进行特征提取，然后将图像长宽压缩两次、三次、四次、五次来构造特征金字塔，目的是为了实现特征多尺度融合。
也就是下图中的左侧部分，分别得到了C2、C3、C4、C5五种特征层（五种尺寸的图像）。
P5：对最小的C5(32,32)图像进行二维卷积，然后再次卷积作为一个有效特征层P5(32,32)（下方绿色框）P6：将P5(32,32)最大池化得到有效特征层P6(16,16)。P4：将C5(32,32)一次卷积的结果上采样得到(64,64)图像，与C4(64,64)进行Add运算，然后再次卷积得到另一个有效特征层P4。P3：将C4一次卷积结果上采样，并与C3进行Add运算，然后再次卷积得到有效特征层P3。P2：将C3一次卷积结果上采样，并与C2进行Add运算，再次卷积得到有效特征层P2。 提取到的P2、P3、P4、P5、P6五个有效特征层，就是Resent101的输出feature maps，可以用于接下来RPN建议网络获取建议框。
RPN区域建议网络（Region Proposal） 对有效特征层使用RPN建议网络（region proposal），获得许多建议框regions，这些建议框可能包含物体，可能没包含物体。不管包括没包括，接下来都会利用这些建议框截取P2~P5的图像，得到一个个可能存在目标的截取图像（P6不截取）。
ROI区域对齐（ROI Align） 对于所有建议框截取图像，RoI Align都会将其调整图像尺寸为一个正方形，便于后续特征的匹配操作。这样经过所有ROI Align后的建议框截取图像，
FC Layers 根据截取出的建议框图像，利用Classifier回归模型判断截取的区域是否有物体，然后利用Classifier预测框网络对有效特征层进行解码获得最终的预测框。
Mask语义分割网络 利用获取的最终预测框，再次在有效特征层P2~P5中截取目标图像（这次由于相当于进行了以便筛选，截取出的图像数量会少很多），将这次截取出的图像传给Mask语义分割网络进行语义分割。
二、Mask R-CNN实现过程 2.1 Resnet101-主干特征提取网络 ResNet101有两个基本的块，分别是Conv Block和Identity Block。其中Conv Block的输入和输出维度不同，不能持续串联，它的作用是改变网络的维度；Identity Block的输入维度和输出维度相同，可以串联，用于加深网络。
以coco数据集中输入的shape为例，输入的shape为1024x1024，shape变化如下：
我们取出长宽压缩了两次、三次、四次、五次的结果来进行下面特征金字塔结构的构造。
相关代码：
from keras.layers import ZeroPadding2D,Conv2D,MaxPooling2D,BatchNormalization,Activation,Add def identity_block(input_tensor, kernel_size, filters, stage, block, use_bias=True, train_bn=True): nb_filter1, nb_filter2, nb_filter3 = filters conv_name_base = 'res' + str(stage) + block + '_branch' bn_name_base = 'bn' + str(stage) + block + '_branch' x = Conv2D(nb_filter1, (1, 1), name=conv_name_base + '2a', use_bias=use_bias)(input_tensor) x = BatchNormalization(name=bn_name_base + '2a')(x, training=train_bn) x = Activation('relu')(x) x = Conv2D(nb_filter2, (kernel_size, kernel_size), padding='same', name=conv_name_base + '2b', use_bias=use_bias)(x) x = BatchNormalization(name=bn_name_base + '2b')(x, training=train_bn) x = Activation('relu')(x) x = Conv2D(nb_filter3, (1, 1), name=conv_name_base + '2c', use_bias=use_bias)(x) x = BatchNormalization(name=bn_name_base + '2c')(x, training=train_bn) x = Add()([x, input_tensor]) x = Activation('relu', name='res' + str(stage) + block + '_out')(x) return x def conv_block(input_tensor, kernel_size, filters, stage, block, strides=(2, 2), use_bias=True, train_bn=True): nb_filter1, nb_filter2, nb_filter3 = filters conv_name_base = 'res' + str(stage) + block + '_branch' bn_name_base = 'bn' + str(stage) + block + '_branch' x = Conv2D(nb_filter1, (1, 1), strides=strides, name=conv_name_base + '2a', use_bias=use_bias)(input_tensor) x = BatchNormalization(name=bn_name_base + '2a')(x, training=train_bn) x = Activation('relu')(x) x = Conv2D(nb_filter2, (kernel_size, kernel_size), padding='same', name=conv_name_base + '2b', use_bias=use_bias)(x) x = BatchNormalization(name=bn_name_base + '2b')(x, training=train_bn) x = Activation('relu')(x) x = Conv2D(nb_filter3, (1, 1), name=conv_name_base + '2c', use_bias=use_bias)(x) x = BatchNormalization(name=bn_name_base + '2c')(x, training=train_bn) shortcut = Conv2D(nb_filter3, (1, 1), strides=strides, name=conv_name_base + '1', use_bias=use_bias)(input_tensor) shortcut = BatchNormalization(name=bn_name_base + '1')(shortcut, training=train_bn) x = Add()([x, shortcut]) x = Activation('relu', name='res' + str(stage) + block + '_out')(x) return x def get_resnet(input_image,stage5=False, train_bn=True): # Stage 1 x = ZeroPadding2D((3, 3))(input_image) x = Conv2D(64, (7, 7), strides=(2, 2), name='conv1', use_bias=True)(x) x = BatchNormalization(name='bn_conv1')(x, training=train_bn) x = Activation('relu')(x) # Height/4,Width/4,64 C1 = x = MaxPooling2D((3, 3), strides=(2, 2), padding="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39305b11443d6f3215c006416b443af0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9f228d83c7a2881a42a93f461c80358/" rel="bookmark">
			【自动化办公】python批量替换word中的内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		background
例行吐槽：由于各种原因，放弃了目标检测这条路，换条路走走。
入职普普通通行政文员，搞搞事情。
发现有很多文件其实只是里面的一些东西需要替换，（其实用word的查找替换也可以，不过，搞搞事情嘛）。
模板中使用占位符，然后替换成数据。
1.导入包读取文件 from docx import Document from docx.shared import Pt #磅数 from docx.oxml.ns import qn #chinese #读取文件 document=Document('/Users/apple/Desktop/xxx.docx') 2.定义替换函数（这里代码非原创，忘记哪里看到的了orz） def change_text(old_text, new_text,document): #遍历文档内所有段落 all_paragraphs = document.paragraphs for paragraph in all_paragraphs: for run in paragraph.runs: if old_text in run.text: run.text = run.text.replace(old_text, new_text) #遍历文档内所有表格 all_tables = document.tables for table in all_tables: for row in table.rows: for cell in row.cells: for paragraph in cell.paragraphs: for run in paragraph.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9f228d83c7a2881a42a93f461c80358/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52895e30e8dd56af3b992f59f9d3d151/" rel="bookmark">
			SpringCloudAlibaba 2021.0.1.0 版本整合分布式事务Seata
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		事务简介 事务（Transaction）是访问并可能更新数据库中各种数据项的一个程序执行单元。在关系数据库中，一个事务由一组SQL语句组成。事务应该具有四个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为ACID特性。
原子性（atomicity）：一个事务是一个不可分割的工作单位，事务中包括各种操作，要么都做，要么都不做。
一致性（consistency）：事务必须是使数据库从一个一致性状态变到另一个一致性状态，事务的中间状态不能被观察到的。
隔离性（isolation）：一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发其他事务是隔离的，并发执行的各个事务之间不能互相干扰。隔离性又分为四个级别：读未提交（read uncommitted）、读已提交（read committed，解决脏读）、可重复读（repeatable read，解决幻读）、串行化（serializable，解决幻读）。
持久性（durability）：持久性也成为永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来其他操作或故障不应该对其他有任何影响。
任何事务机制在实现时，都应该考虑事务的ACID特性，包括：本地事务、分布式事务，及时不能都很好的满足，也要考虑支持到什么程度。
本地事务 @Transational
大多数据场景下，我的应用都只需要操作单一的数据库，这种情况下的事务成为本地事务（Local Transaction）。本地事务的ACID特性是数据库直接提供支持的。
1.Seata是什么？ Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。
官网：https://seata.io/zh-cn/docs/overview/what-is-seata.html
源码：https://github.com/seata/seata
GitHub - seata/seata-samples: seata-samples
1.1 Seata的三大角色 在Seata的架构中，一共有三个角色：
TC（Transaction Coordinator）- 事务协调者
维护全局和分支事务的状态，驱动全局事务提交和回滚。
TM（Transaction Manager）- 事务管理器
定义全局的事务的范围：开始全局事务、提交或回滚全局事务。
RM（Resource Manager）- 资源管理器
管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。
其中，TC为单独部署的Server服务端，TM和RM为嵌入到应用中的Client客户端。
1.2常用分布式事务解决方案 Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。
seata 阿里分布式事务框架消息队列sagaXA 四种分布式事务
Seata AT 模式（auto transaction）
AT模式是一种无侵入的分布式事务解决方案
●一阶段：
在一阶段，Seata会拦截“业务SQL”，首先解析SQL语义，找到“业务SQL”要更新的业务数据，在业务数据被更新前，将其保存成“before image”，然后执行“业务SQL”更新业务数据，在业务数据更新之后，再将其保存“afger image”，最后生成行锁。以上操作全部再一个数据库事务内完成，这样保证了一阶段操作的原子性。
●二阶段提交
二阶段如果是提交的话，因为“业务SQL”在一阶段已经提交至数据库，所以Seata框架只需将一阶段保存的快照数据和行锁删掉，完成数据清理。
●二阶段回滚
二阶段如果是回滚的话，Seata就需要回滚一阶段已经执行的“业务SQL”，还原业务数据。回滚方式是使用“before image”还原业务数据；但在还原前首先要校验脏写，对比“数据库当前业务数据”和“after image”，如果两份数据完全一致就说明没有脏写，可以还原业务数据，如果不一致就说明有脏写，出现脏写就需要人工处理。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52895e30e8dd56af3b992f59f9d3d151/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d36647412d846f7d590b979bdd4f18ce/" rel="bookmark">
			【模型评估】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文目录 2.1 评估指标的局限性2.1.1 准确率的局限性2.1.2 精确率与召回率的权衡2.1.3 平方根误差的“意外” 2.2 ROC曲线2.2.1 什么是ROC曲线？2.2.2 如何绘制ROC曲线？2.2.3 如何计算AUC?2.2.4 ROC曲线与P-R曲线有什么特点？ 2.3 余弦距离的应用2.3.1 为什么一些场景要使用余弦相似度，而非欧氏距离？2.3.2 余弦距离是否是一个严格定义的距离？ 2.4 A/B测试的陷阱2.4.1 在对模型进行充分评估之后，为什么还需要进行A/B测试？2.4.2 如何进行线上A/B测试2.4.3 如何划分实验组和对照组 2.5 模型评估的方法2.5.1 在模型评估过程中，有哪些主要的验证方法，它们的优缺点是什么？2.5.2 对 n n n个样本进行 n n n次自助采样，当 n → ∞ n\rightarrow\infty n→∞时，有多少数据未被选择过？ 2.6 超参数调优2.7 过拟合与欠拟合 模型的评估主要分为离线评估和在线评估两个阶段。针对分类、排序、回归、序列等不同类型的机器学习问题，评估的指标选择也不同。知道每种评估指标的精确定义、有针对性的选择合适的评估指标、根据指标的反馈来调整模型，是很关键的问题。 2.1 评估指标的局限性 大部分评估指标只能片面的反应模型的一部分性能。如果不能合理的运用评估指标，不仅不能发现模型本身的问题，而且还会得出错误的结论。
2.1.1 准确率的局限性 问题场景：
HULU的奢侈品广告主们希望把广告定向投放给奢侈品用户。HULU通过第三方数据管理平台拿到了一部分奢侈品用户的数据，并且利用该数据进行了模型训练，训练准确率达到了95%，但在实际投放过程中，该模型还是把大部分广告投放给了费奢侈品用户，这是为什么？
在回答这个问题之前，我们先来看一下准确率的定义。准确率是指分类正确的样本数量占总样本数量的比例，即：
a c c u r a c y = n c o r r e c t n t o t a l accuracy=\frac{n_{correct}}{n_{total}} accuracy=ntotal​ncorrect​​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d36647412d846f7d590b979bdd4f18ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8713e757f55f99ff950b5446f4c834d0/" rel="bookmark">
			pytorch训练过程中释放显存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在python程序中需要显存暴增的问题，可以试试
在代码中插入
torch.cuda.empty_cache() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/740d0f752ad0c60368e146ab8388d721/" rel="bookmark">
			优化C#程序的四十七种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		资源来自交流群
一、用属性代替可访问的字段
1、.NET数据绑定只支持数据绑定，使用属性可以获得数据绑定的好处；
2、在属性的get和set访问器重可使用lock添加多线程的支持。
二、readonly（运行时常量）和const（编译时常量）
1、const只可用于基元类型、枚举、字符串，而readonly则可以是任何的类型；
2、const在编译时将替换成具体的常量，这样如果在引用中同时使用了const和readonly两种值，则对readonly的再次改变将会改变设计的初衷，这是需要重新编译所更改的程序集，以重新引用新的常量值。
3、const比readonly效率高，但失去了应用的灵活性。
三、is与as
1、两者都是在运行时进行类型的转换，as操作符只能使用在引用类型，而is可以使用值和引用类型；
2、通常的做法是用is判断类型，然后选择使用as或强类型转换操作符（用operater定义的转换）有选择地进行。
四、ConditionalAttribute代替#if #endif条件编译
1、ConditionalAttribute只用于方法级，对其他的如类型、属性等的添加都是无效的；而#if #endif则不受此限制；
2、ConditionalAttribute可以添加多个编译条件的或（OR）操作，而#if #endif则可以添加与（AND）[这里可以完全定义为另一个单独的符号]；
3、ConditioanlAttribute定义可以放在一个单独的方法中，使得程序更为灵活。
五、提供ToString()方法
1、可以更友好的方式提供用户详细的信息；
2、使用IFormatter.ToString()方法提供更灵活的定制，如果添加IFormatProvider 和ICustomFormatter接口则更有意义的定制消息输出。
六、值和引用类型的区别
1、值类型不支持多态，适合存储应用程序操作的数据，而引用则支持多态，适用于定义应用程序的行为；
2、对于数组定义为值类型可以显著提高程序的性能；
3、值类型具有较少的堆内存碎片、内存垃圾和间接访问时间，其在方法中的返回是以复制的方式进行，避免暴露内部结构到外界；
4、值类型应用在如下的场景中：类型的职责主要是用于数据存储；公共接口完全由一些数据成员存取属性定义；永远没有子类；永远没有多态行为.
七、值类型尽可能实现为常量性和原子性的类型
1、使我们的代码更易于编写和维护；
2、初始化常量的三种策略：在构造中；工厂方法；构造一个可变的辅助类（如StringBuilder）。
八、确保0为值得有效状态
1、值类型的默认状态应为0；
2、枚举类型的0不应为无效的状态；在FlagsAttribute是应确保0值为有效地状态；
3、在字符串为为空时可以返回一个string.Empty的空字符串。
九、相等判断的多种表示关系
1、ReferenceEquals()判断引用相等，需要两个是引用同一个对象时方可返回true；
2、静态的Equals()方法先进行引用判断，再进行值类型判断的；
3、对于引用类型的判断可以在使用值语义时使用重写Equals()方法；
4、重写Equals()方法时也应当重写GetHashCode()方法，同时提供operater==()操作。
十、理解GetHashCode()方法的缺陷
1、GetHashCode()仅应用在基于散列的**定义键的散列值，如HashTable或Dictionary；
2、GetHashCode()应当遵循相应的三条规则：两个相等对象应当返回相同的散列码；应当是一个实例不变式；散列函数应该在所有的整数中产生一个随机的分布。
十一、优先使用foreach循环语句
1、foreach可以消除编译器对for循环对数组边界的检查；
2、foreach的循环变量是只读的，且存在一个显式的转换，在对象的对象类型不正确时抛出异常；
3、foreach使用的需要有：具备公有的GetEnumberator()方法；显式实现了IEnumberable接口；实现了IEnumerator接口；
4、foreach可以带来资源管理的好处，因为如果编译器可以确定IDisposable接口时，可以使用优化的try…finally块；
十二、默认字段的初始化优于赋值语句
1、字段生命默认会将值类型初始化为0，引用类型初始化为null；
2、对同一个对象进行多次初始化会降低代码的执行效率；
3、将字段的初始化放到构造器中有利于进行异常处理。
十三、使用静态构造器初始化静态成员
1、静态构造器会在一个类的任何方法、变量或者属性访问之前执行；
2、静态字段同样会在静态构造器之前运行，同时静态构造器有利于异常处理。
十四、利用构造器链（在.NET 4.0已经用可选参数解决了这个问题）
1、用this将初始化工作交给另一个构造器，用base调用基类的构造器；
2、类型实例的操作顺序是：将所有的静态字段都设置为0；执行静态字段初始化器；执行基类的静态构造器；执行当前类型的静态构造器；
将所有的实例字段设置为0；执行实例字段初始化器；执行合适的基类实例构造器；执行当前类型的实例构造器。
十五、利用using和try/finally语句来清理资源
在IDisposable接口的Dispose()方法中用GC.SuppressFinalize()可通知垃圾收集器不再执行终结操作。
十六、尽量减少内存垃圾
1、分配和销毁一个堆上的对象都要花费额外的处理器时间；
2、减少分配对象数量的技巧：经常使用的局部变量提升为字段；提供一个类，用于存储Singleton对象来表达特定类型的常用实例。
3、用StringBuilder进行复杂的字符串操作。
十七、尽量减少装箱和拆箱
1、关注一个类型到System.Object的隐式转换，同时值类型不应该被替换为System.Object类型；
2、使用接口而不是使用类型可以避免装箱，即将值类型从接口实现，然后通过接口调用成员。
十八、实现标准Dispose模式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/740d0f752ad0c60368e146ab8388d721/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73f480db1c10b840cc1b89991e246611/" rel="bookmark">
			基于全志RK3568J的RGB和SATA功能转接模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. RGB功能转接模块
FET3568-C核心板一共支持五种显示接口，大家可以在开发板上看到的分别是HDMI、eDP、LVDS和MIPI，而第五个显示接口其实是一个复用接口。
​
CPU内部是将RGB和部分的UART、SPI、IIC、GPIO复用了，开发板默认预留了2.54mm的排针，方便用户插杜邦线扩展功能模块，如我们的温湿度传感器、UART转RS485等等。
RGB功能的实现就需要用到转接模块---将2.54mm排针转换成飞凌标准液晶模块的连接器。
​
现在是要使用LCD，下载用户资料，打开Linux目录，会有两个文件夹，查看LCD转接模块的使用文档，after和before是修改前和修改后的设备树文件。
​
点击after进入到最底层目录，将DTSI文件拷入VM开发环境，使用命令cp，将其拷贝到对应位置，然后编译一下内核，生成boot.img用于单步烧写。
​
将生成的boot文件放到桌面，使用单步烧写工具，识别设备，读设备分区表，单独烧写一下boot，点击执行，使用PuTTy软件，打开串口，等待开发板启动，这时LCD屏幕已经显示logo，但是没有显示启动后的界面。
​
用命令查看LCD是否加载成功，可以看到已经加载成功，但是屏幕没亮，现在需要将LVDS的显示关闭，首先重新启动，再进入uboot选屏，然后将LVDS显示关闭，关闭成功后，选择重启，接下来就可以正常操作了。
​
2. SATA功能转接模块
除了显示接口，PCIe2.1和SATA也是有复用的，这两个功能都是工程师们常用的功能，飞凌也为大家做了转接设计，PCIe插槽转接成SATA连接器。
​
现在是要使用PCLe转SATA，下载用户资料，打开Linux目录，会有两个文件夹。
查看SATA转接板模块的使用文档，after和before是修改前和修改后的设备树文件，点击after进入到最底层目录，将DTSI文件拷入VM开发环境，使用命令cp，将其拷贝到对应位置，然后编译内核，生成boot.img用于单步烧写。
​
将生成的boot文件放到桌面，使用单步烧写工具，识别设备，读设备分区表，单独烧写一下boot，点击执行，使用PuTTy软件，打开串口，等待开发板启动，用df-h命令可以看到已经有了这三个设备挂载。
​
用lspci可以看到没有PCIe设备，用cd命令访问目录，可以看到硬盘内的文件，说明成功了https://www.forlinx.com/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12b795255823d58a70615d5dcc45453d/" rel="bookmark">
			nodejs面经
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		怎么看待nodejs可支持高并发 1、nodejs的单线程架构模型 nodejs并不是真正的单线程架构，其中还有I/O线程（网络I/O、磁盘I/O），这些线程是由更底层的libuv处理，js运行在v8上是单线程的。
单线程的好坏 优势： 省去了线程切换的开销线程的同步、冲突问题不需要担心 劣势： 无法充分利用CPU资源单线程崩溃程序就无了只能用一个cpu，一旦其被某个计算占用，后续请求就会被一直挂起 2、Node.js中的事件循环机制 事件循环允许Node.js执行非阻塞I/O操作.尽管JavaScript是单线程的.通过尽可能将操作卸载到系统内核。由于大多数现代内核都是多线程的，因此它们可以处理在后台执行的多个操作。当其中一个操作完成时，内核会告诉Node.js,以便可以将相应的回调添加到轮询队列中以最终执行
EventLoop 中的 6个步骤都是相对于宏任务（Macro）的讲述的。NodeJs执行完成一个宏任务后会立即清空当前队列中产生的所有微任务。
timers 执行setTimeout(),setInterval（）回调函数
pending callbacks 执行I/O回调
idle，prepare 尽在NodeJs内部调用，无法操作
poll 获取新的I/O事件
如果 轮询 队列 不是空的 ，事件循环将循环访问回调队列并同步执行它们，直到队列已用尽，或者达到了与系统相关的硬性限制。
如果 轮询 队列 是空的 ，还有两件事发生：
如果脚本被 setImmediate() 调度，则事件循环将结束 poll(轮询) 阶段，并继续 check(检查) 阶段以执行那些被调度的脚本。如果脚本 未被 setImmediate()调度，则事件循环将等待回调被添加到队列中，然后立即执行。 poll可以提前结束使事件循环，提升效率
check 执行setImeediate回调
close callbacks 执行socket的close事件回调
执行一些列关闭的回调函数，socket.on( 'close' , . . )
什么是同步异步 同步 等待被调用方执行完毕才能继续执行会阻塞后面代码的执行异步 不需要一直等待被调用方响应，调用方的主动轮询和被调用方的主动通知不会阻塞后面代码的执行区别：调用过程中是主动等待还是被动通知，是否阻塞 什么是阻塞非阻塞 区别：调用状态，调用方在获取结果的过程中是干等还是互不耽误异步非阻塞是节约调用方时间的（nodejs 一大特点） 典型
setTimeout(function timeout () { console.log('timeout'); },0);
setImmediate(function immediate () { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12b795255823d58a70615d5dcc45453d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6273ff15b6c45ddfdb62dd3aa4ddce34/" rel="bookmark">
			SpringCloudAlibaba 2021.0.1.0 版本整合Nacos配置中心
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nacos安装教程：服务注册中心和配置中心nacos安装 一、组件版本关系 SpringCloudAlibaba、SpringCloud、SpringBoot对应版本
Spring Cloud Alibaba VersionSpring Cloud VersionSpring Boot Version 2021.0.1.0
Spring Cloud 2021.0.1
2.6.3
Nacos对应版本
Spring Cloud Alibaba VersionSentinel VersionNacos VersionRocketMQ VersionDubbo VersionSeata Version 2021.0.1.0
1.8.3
1.4.2
4.9.2
2.7.15
1.4.2
官方提醒：每个 Spring Cloud Alibaba 版本及其自身所适配的各组件对应版本（经过验证，自行搭配各组件版本不保证可用）
更多版本对应关系参考：版本说明 Wiki
二、集成Nacos配置中心 1、SpringCloudAlibaba依赖 &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.6.3&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;2021.0.1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;2021.0.1.0&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; 2、启动配置管理 启动了 Nacos server 后，需要添加依赖
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6273ff15b6c45ddfdb62dd3aa4ddce34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/295ac79468c914d022c95e122f141016/" rel="bookmark">
			UE4 合并静态网格体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题： 如下图，如何将世界大纲中的所有静态网格体（StaticMeshActor ）合并为一个模型？
实现效果： 解决步骤： 1.在世界大纲中找到所有存在的静态网格体
2.Ctrl+A 全选
3.在菜单栏点击 窗口-》开发者工具-》合并Actor
4.在弹出的窗口中点击合并Actor
5.选择合并后模型的存放地点，并为模型命名，点击保存
6.最后，你可能需要为合并后的模型设置碰撞体，可参考这篇文章： UE4 设置碰撞体
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/558d359a1b86814f6fbd9fffe9f54a7c/" rel="bookmark">
			Dev C&#43;&#43;调试 点击下一步无反应问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近用Dev C++做UVA的题，调试代码点击下一步总是没有反应，查了一下资料，初步解决了问题。 参考博客
Dev c++单步调试 + 点下一步无反应 + 显示STL容器内容
已解决】Dev C++调试模式按下一步卡住（断点语句为cout）
问题原因
只要添加了变量查看，点击下一步就没有反应（待解决）；遇到cout语句中有endl时，点击下一步无反应，需将endl改为\n；或直接添加 #define endl '\n' 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e6e6ea1cf66055301632f4dbe470c3a/" rel="bookmark">
			ubuntu20.04 noetic版本&#43;机器人TF坐标变换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sudo apt-get install ros-noetic-turtle-tf
roslaunch turtle_tf turtle_tf_demo.launch
#rosrun turtlesim turtle_teleop_key
只有一只乌龟，还报错，跟python有关？？
cd /usr/bin
sudo cp python3 python
rosrun turtlesim turtle_teleop_key
rosrun tf view_frames
出错
1 Listening to /tf for 5.0 seconds
2 Done Listening
3 b’dot - graphviz version 2.42.3 (0)\n’
4 Traceback (most recent call last):
5 File “/opt/ros/melodic/lib/tf/view_frames”, line 119, in 6 generate(dot_graph)
7 File “/opt/ros/melodic/lib/tf/view_frames”, line 89, in generate
8 m = r.search(vstr)
9 TypeError: cannot use a string pattern on a bytes-like object
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e6e6ea1cf66055301632f4dbe470c3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4394137d719759c05678e94342bd8b1/" rel="bookmark">
			springboot openfeign服务端与客户端调用演示demo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 server demo 演示创建server项目application.properties配置import jar [pom.xml]创建服务端的restful controller验证 openfeign client demo创建client项目import jar【pom.xml】注意 springboot与springcloud版本的一个对照 参考 application.properties配置调用服务端的client接口编码客户端restful controller编码客户端调用验证 源码写在最后 server demo 演示 创建server项目 application.properties配置 spring.application.name=springboot-sample-openfeign-server server.port=8086 import jar [pom.xml] &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.gaoxinfu.springboot.sample.openfeign&lt;/groupId&gt; &lt;artifactId&gt;springboot-sample-openfeign-server&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;name&gt;springboot-sample-openfeign-server&lt;/name&gt; &lt;description&gt;springboot-sample-openfeign-server&lt;/description&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;maven-public&lt;/id&gt; &lt;name&gt;maven-public&lt;/name&gt; &lt;url&gt;http://localhost:8081/repository/maven-public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;updatePolicy&gt;always&lt;/updatePolicy&gt; &lt;checksumPolicy&gt;warn&lt;/checksumPolicy&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4394137d719759c05678e94342bd8b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/998d37e29febbeb999686df74bf25e4b/" rel="bookmark">
			约瑟夫环问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		约瑟夫环 【题目描述】
n 个人围成一圈，从第一个人开始报数,数到 mm 的人出列，再由下一个人重新从 11 开始报数，数到 mm 的人再出圈，依次类推，直到所有的人都出圈，请输出依次出圈人的编号
【输入形式】
输入两个整数 n,m。
【输出形式】
输出一行 nn 个整数，按顺序输出每个出圈人的编号。
【实例】
10 3
3 6 9 2 7 1 8 5 10 4
【题解】
#include&lt;bits/stdc++.h&gt; typedef struct queuee { int data[101]; int fron; int rear; }queue; int main() { /*队列的初始化*/ queue *q; q=(queue *)malloc(sizeof(queuee)); q-&gt;fron=q-&gt;rear=0; int m,n,a=1; scanf("%d%d",&amp;m,&amp;n); for(int i=1;i&lt;=m;i++) { q-&gt;data[q-&gt;rear]=i; q-&gt;rear=(q-&gt;rear+1)%101; } while(!(q-&gt;rear==q-&gt;fron)) { if(a==n) { printf("%d ",q-&gt;data[q-&gt;fron]); q-&gt;fron=(q-&gt;fron+1)%101; a=1; } else { a++; q-&gt;data[q-&gt;rear]=q-&gt;data[q-&gt;fron]; q-&gt;rear=(q-&gt;rear+1)%101; q-&gt;fron=(q-&gt;fron+1)%101; } } return 0; } 【题解】
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/998d37e29febbeb999686df74bf25e4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f7d754f488ddbbdd81030fe4f32d9ca/" rel="bookmark">
			UIPath指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 弹出框Message Box弹出输入框：Input Dialog变量（Variables面板） 变量指令相关函数整型Int32数据表（读取自excel的数据）DataTable日期DateTime（1）与DataTable相区分；（2）时间格式化表示：sometime.ToString(“yyyy-MM-dd HH:mm:ss”)日期间隔TimeSpan（1）默认格式：day.hh:mm:ss；（2）现在：Now；日期减法：日期1.subtract（时间间隔）；Substract是减法函数字符串string（1）转换为字符串 something.ToString;（2）用+号链接字符串数组[](1)表示方式：int32{ele1,ele2,…,elen};str{“ele1”,“ele2”,…,“elen”};(2)元素取用方式：数组名(下标) 输入框，既可作简单输入框又可用作浏览器搜索框的输入：TypeInto为变量赋值：Assign | 区别于等于：=条件判断：Flow Decision；可以是一个boolean类型的变量，也可以是表达式；可以指定条件满足或不满足时程序的走向，使用引导线。求余：mod读取excel表：Excel Application Scope，excel相关衍生命令： 用途指令相关说明Read Range读取某个范围读取结果赋值给DataTable类型的变量Write Range写入某个范围Read Cell读一个单元格Write Cell写一个单元格Read Row读一行Write Row写一行Read Column读一列Write Column写一列Insert/delete Row插入或删除一行(1)NoRows: 希望添加或者删除的行数(2)Position: 从哪一行开始添加或者删除Insert/delete Column插入或删除一列(1)NoColumns: 希望添加或者删除的列数;(2) Position: 从哪一列开始添加或者删除 参数（Arguments面板），在两个文件之间传递；导入参数命令：Invoke Second workflow条件判断： if逻辑表达式 逻辑命令指令或or且and 循环 循环类型指令其他说明迭代列表、数组For Eachbreak、continue只能应用于ForEach循环，且需要和if结合着使用先判断后执行While先执行后判断Do While 日志：Log Message打开浏览器：Open Browser最大化窗口：Maximize Window鼠标操作元素：总指令mouse 说明指令相关说明单击Click有单机文本、图像、元素，元素使用较为频繁，在屏幕指定即可选定目标元素双击Double Click悬浮Hover 键盘： 说明指令发送Sendhotkey 粘贴板：
设置剪切板（SettoClipboard）,
从剪切板获取（GetfromClipboard）设置文本：Set Text，可以为搜索框输入信息，可以结合从粘贴板中获得检测页面中是否存在文本、元素、图片。返回值为boolean类型，将返回值赋值给Output对应的变量。输入：要查找的值、选定浏览器上的元素 类型指令文本Text Exists元素Element Exists 动态选择器：通配符*，可以匹配0-n个字符，？可以匹配1个字符延时：delay，格式为HH:mm:ss 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fdf8873009339e639a6063173954ba1/" rel="bookmark">
			Redis配置（linux傻瓜式单机配置 cv即可）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 安装gcc环境 （Redis是C语言编写）
yum install gcc-c++ 查询是否已经安装了gcc
rpm -qa | grep gcc 将下载的Redis源码包上传到Linux服务器中
安装wget
yum install wget wget下载redis-3.0.0.tar .gz到linux当前文件夹（/opt）
wget http://download.redis.io/releases/redis-3.0.0.tar.gz 解压到当前文件夹
tar -zxf redis-3.0.0.tar.gz 编译redis源码
cd redis-3.0.0 make 安装redis （路径安装路径 ）
make install PREFIX=/opt/redis 到此redis单机模式安装完毕
redis前端启动（进入到redis安装的bin目录下）不推荐 ctrl+C退出
/opt/redis/bin/redis-server 后端启动 推荐
将redis源码包中的redis.conf配置文件复制到/opt/redis/bin下
cd /opt/redis-3.0.0 修改/opt/redis/bin下的redis.conf，将daemonize由no改为yes
vi redis.conf 修改密码：requirepass +密码
cp redis.conf /opt/redis/bin/ 修改配置完成后到redis文件夹启动redis
./redis-server redis.conf 使用指令查看是否启动成功
后端关闭redis的两种方式
方式1：
./redis-cli shutdown 方式2：
先使用 ps -ef | grep redis 查出进程号 pid
kill -9 pid 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6baeed0131293c2efb0aa1340667b597/" rel="bookmark">
			非spring项目使用mybatis-plus
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		非spring项目使用mybatis-plus
写在前面
初始化项目
项目最终结构如下
使用junit初始化数据源
编写测试代码
运行效果如下
构建mybatis-plus里面的SqlSessionFactoryBuilder对象
创建entity对象
创建mapper接口
创建mapper.xml
编写单元测试方法
添加after方法，用于方法执行完毕，关闭session
测试mybatis-plus的增删改查
selectList
insert
selectPage
updateById
deleteById
testFindAll
testFindAllPage
junit全部代码如下
sql
写在后面
写在前面
这里讲解如何在非spring项目下使用mybatis-plus，并集成mybatis-plus的特性，实现数据库的增删改查
1
初始化项目
项目由maven构建,并且使用junit做项目测试实验，pom配置如下
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.lhstack.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-test&lt;/artifactId&gt; &lt;version&gt;0.0.1&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt; &lt;mybatis-plus.version&gt;3.4.3&lt;/mybatis-plus.version&gt; &lt;hikaricp.version&gt;4.0.3&lt;/hikaricp.version&gt; &lt;mysql.version&gt;8.0.23&lt;/mysql.version&gt; &lt;junit.version&gt;4.13&lt;/junit.version&gt; &lt;slf4j.version&gt;1.7.31&lt;/slf4j.version&gt; &lt;logback.version&gt;1.2.3&lt;/logback.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;${logback.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;${slf4j.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;${junit.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6baeed0131293c2efb0aa1340667b597/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/338ed26442c2e56532be29d82f3940fc/" rel="bookmark">
			Markdown学习笔记（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Markdown学习笔记（三） 今天是学习Markdown的第三天，话不多说我们开始吧~
目录 列表语法 1.1 无序列表 1.2 有序列表 1.3 定义型列表 1.4 列表中的嵌套 以下是正文部分
列表语法 官网教程链接: 列表语法
无序列表
使用”*“、”+“、”-“表示无序列表。
要创建无序列表，在每个列表项的前面添加星号，加号或者破折号，缩进一个或者多个列表项可以创建嵌套列表。
无序列表的HTML形式下：
tips：整个列表以&lt; ul &gt;开头，以&lt; /ul &gt;结束；每个列表项以&lt; li &gt;开头，以&lt; /li &gt;结束。若还要在某个列表项下再创建一个列表，则同样以&lt; ul &gt;开头，以&lt; /ul &gt;结束；其中的每个列表项依旧以&lt; li &gt;开头，以&lt; /li &gt;结束。
有序列表
有序列表使用数字接着一个英文句点。
要创建有序列表，在每个列表项的前面添加数字并紧跟一个英文句点，数字不需要按照数字顺序排序，但是列表应该从数字1开始。
创建一个普通的列表如下：
tips：在每个列表项的前面添加数字并紧跟一个英文句点，要注意句点后面要留出一个空格（这时候会发现序号字体变为蓝色，表明列表此时是创建成功的）。
创建一个序号不按数字顺序排序的列表（且某个列表项下再创建列表）如下：
HTML下创建列表：
tips：整个列表以&lt; ol &gt;开头，以&lt; /ol &gt;结束；每个列表项以&lt; li &gt;开头，以&lt; /li &gt;结束。若还要在某个列表项下再创建一个列表，则同样以&lt; ol &gt;开头，以&lt; /ol &gt;结束；其中的每个列表项依旧以&lt; li &gt;开头，以&lt; /li &gt;结束。
定义型列表
定义型列表由名词和解释组成。空一行，然后一行写上定义，紧跟着一行写上解释。解释的写法：紧跟一个缩进（Tab）
举两个例子： Markdown : Text-to-HTML conversion tool Authors : John : Luke （很奇怪的是我的电脑上用普通的定义型列表的定义方式貌似没反应，只有用HTML的方式才可行。把官网这部分的教程链接放上：链接: Markdown定义列表）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/338ed26442c2e56532be29d82f3940fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5df89b1164fb739ea5af1f0c8f20bb09/" rel="bookmark">
			用切片操作去除字符串首尾的指定字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		发现自己的抽象能力和逻辑能力好像并不好，这个代码的逻辑演练了好久
def trim(text, s=' '): """ 利用切片实现去除首尾指定字符串 """ for i in range(2): temp = '' text = text[::-1] if i == 1 else text for index, i in enumerate(text): temp += i if len(temp) == len(s): if temp != s: text = text[index-(len(s)-1):] break temp = '' if temp == '': return temp s = s[::-1] text = text[::-1] return text print(trim('nbnbpytonnbnb', 'nb')) 其他输入，我也是测试过的，如果觉得不错，点个赞呗~
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/143/">«</a>
	<span class="pagination__item pagination__item--current">144/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/145/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>