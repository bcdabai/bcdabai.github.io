<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4f019d713bca202254c00ee713b35e2/" rel="bookmark">
			WallpaperEngine壁纸提取工具，pkg文件提取静态图片，pkg文件转jpg，pkg文件转png
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一期给大家带来了【Wallpaper Engine】离线版，可以免费在Windows平台体验“不一样”的动态壁纸。但当电脑进入锁屏界面，是不是有一种被打回原形的感觉？
怎么让我们的锁屏界面和桌面【保持一致】或者说让我们的【锁屏界面】也能花哨起来呢？
壁纸工具“二连弹”——Wallpaper Engine壁纸提取工具
本文摘要：
一、如何使用壁纸提取工具提取Wallpaper Engine中的壁纸
二、什么类型的壁纸无法提取
三、壁纸提取工具【免费下载链接】
【Wallpaper Engine】中的动态壁纸是以scene.pkg格式存储的，上一期说到每一个壁纸文件对应一个文件夹，打开文件夹后通常找不到常见的.jpg或.png格式的图片文件，文件夹中的scene.pkg才是壁纸的主体，而壁纸提取工具的作用就是从scene.pkg文件中抽取出壁纸对应的.jpg或.png格式的文件。
一、如何使用壁纸提取工具提取Wallpaper Engine中的壁纸
1、拿到压缩包后首先还是进行解压，得到一个文件夹【RePKG-GUI】，进入文件夹后可以看到四个文件，选择【RePKG-GUI.exe】运行，该程序是图形界面的程序。
2、运行后出现如下窗口，按钮不多，操作起来也非常简单。
（1）可以选择直接将【壁纸文件夹】中的【scene.pkg】文件拖到第一个灰色的输入框，也可以选择点击【PKG】按钮从文件夹中选择【scene.pkg】文件。
（2）在完成第一步后，输出位置会默认在【scene.pkg】文件所在的位置创建一个【scene】文件夹，如果需要更改输出位置，则点击【输出】按钮，选择其他【文件夹】保存输出的文件。
（3）点击【提取】按钮，即可提取对应的壁纸为.jpg格式或.png等常见图片格式。
手动更改保存位置后不会在所选位置自动创建【scene】文件夹，如果选择【桌面】为保存位置，则点击【提取】按钮后，桌面上将出现以下【文件和文件夹】，其他输出位置同理：
注意：不要勾选【不把TEX文件转换为图像】这个选项，否则无法得到对应的壁纸图片。
3、找到第二步中设置的输出位置，打开【materials】文件夹，该文件夹下就能找到壁纸对应的图片文件。小编提取的静态壁纸有12M这么大，放再大也不会失真，做锁屏壁纸简直不要太合适。
完整演示动图如下：
附Windows锁屏壁纸设置方法：
鼠标右键桌面，选择【个性化】
二、什么类型的壁纸无法提取
简单来说，没有【scene.pkg】文件的壁纸就无法用这个软件提取壁纸。
一些和视频一样的壁纸（实际上就是视频）在对应文件夹下找不到sence.pkg文件，这种壁纸的主体是一个.mp4视频文件，这种类型的壁纸不能用该软件提取静态壁纸（话说就算提取也不知道提取哪一帧吧）
三、壁纸提取工具
链接：https://pan.baidu.com/s/1p4MU8VC2FHhPKifchJmkig?pwd=2g5d
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ade9073579733ba1772c064044c24765/" rel="bookmark">
			浅谈函数调用的汇编实现细节（用栈来传递参数）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言程序分析总结 前言 要想理解函数调用的汇编实现，需要清楚几个基本概念。在此针对的是用栈来传递参数。
1，调用现场的保护：假设函数A调用函数B，一旦程序执行进入函数B中，当函数B执行结束后，我们肯定需要执行流继续从函数A调用现场（callsite）的下一条语句继续执行函数A。当然，各种应用程序在操作系统上也是这样运行，否则的话，程序不就飞了？这不符合操作系统有始有终的性格。这一点特别像递归函数，虽然一层层嵌套，但是最终还是需要一层层返回的，即从哪个函数开始，就从哪个函数结束。
所以，当函数A准备调用函数B时，需要先把A中调用语句的下一条语句保存起来，通常都是保存到栈里面，这样当函数B返回后，将之前压入栈中的待执行语句从栈中弹出，然后执行流从这条语句接着执行，即函数A继续执行。
2，关于栈的增长方向：栈是从高地址向低地址方向增长的。即栈底处于高地址，栈顶处于低地址，每次入栈时需要将栈指针减小，每次出栈时需要将栈指针增加。这点可以查看Ubuntu系统中的程序运行时空间布局得知。在Windows系统中也是一样，通过相关的程序分析工具可以直观的看到。
3，参数和返回值：函数调用在通常情况下都是需要传递参数和返回值的。系统API大都是采用_stdcall调用约定，函数入口参数按从右到左的顺序入栈，由被调用者清理栈中的参数，返回值放在eax寄存器中。而C代码中的子程序采用的是C调用约定，函数入口参数按从右到左的顺序入栈，由调用者清理栈中的参数。
4，ebp和esp：在x86指令集中，ebp寄存器为栈帧寄存器，用来保存每一个函数的栈底位置（内存地址）；esp寄存器为栈顶寄存器，用来保存每一个函数当前的栈顶位置。eip表示当前程序执行的指令地址。
程序分析 void f(int x,int y) { int a,b; a=7,b=9; x=x+y; } int g=3; int main() { f(g,5); return 0; } 上面是一个简单的c程序函数调用。在main函数调用了函数 f。从程序语义上来分析，虽然这个 f 函数啥也没干，不过不影响我们分析它的函数调用结构。
main函数对应的汇编代码如下：
push 5 mov eax,[00422ab6] ;假设全局变量g存放的地址为0x00422ab6 push eax call f add esp,8 注意函数调用语句 f(g,5) 是从右往左将参数压栈的。
其中第一条语句将参数 5 压入栈中；
第二条语句取得 g 的值并存放到 eax 中，第三条语句将 eax 压入栈中，整体实现功能将参数 g 压入栈中；
然后是 call f 语句，可能有不明白的朋友会好奇为什么没有将下一条语句 add esp,8 的指令地址保存呢？这个牵扯到 call 指令的功能了，它会先保存下一条指令的地址，然后再调用函数 f ；(具体的可以参考博客https://blog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ade9073579733ba1772c064044c24765/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a695aab82d72d4f92abacc85955f3922/" rel="bookmark">
			Jetson 系统监视程序Jtop（CPU/GPU/MEM...)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“我怎么知道安装的Jetpack版本是多少？”
“我怎么看[GPU]的使用率？”
“我的Jetson机器工作在什么模式下？”
“我的CPU用了几个？“
“散热片好烫，风扇有在工作么？”
有一个Jetson的小工具：Jtop（一个系统监视实用程序，可在终端上运行，并实时查看和控制 NVIDIA Jetson的状态 ），安装也非常方便，如果Jetson产品上已安装了Jetpack SDK，可以按照如下步骤安装运行：
安装及运行 $sudo apt-get install python3-pip $sudo pip3 install jetson-stats (包含jtop） $sudo jtop 开启后的界面如下：
jtop.png
非常方便地看到当前Jetson 机器上的各种完整信息，一般在首页就可以读取到很丰富的数据信息：
ALL
包含模块运行信息包括：CPU、内存、GPU、磁盘、风扇、jetson_clock状态、NVPModel等等GPU
实时GPU状态CPU
实时CPU状态CTRL
可以控制的状态INFO
Lib库、CUDA、Serial Number、Interface等信息 可以使用以下键盘命令，控制NVIDIA Jetson的相关配置：
在第3页MEM中 ：
c : 清除缓存s : 启用/禁用额外交换+/-: 增加和减少交换大小 在第4页中CTRL ：
启动 /停止jetson_clocks服务（注：仅jetson_clocks从时间60秒后开始）e: 在启动时启用/禁用jetson_clocks+/-: 增加和减少NVP模型f: 风扇的手动/ jetson_clocks模式p/m: 增加和降低风扇速度 1、jetson_release 命令显示NVIDIA Jetson的状态和所有信息
nvidia@nx:~$ jetson_release - NVIDIA Jetson Xavier NX * Jetpack 4.4 DP [L4T 32.4.2] * NV Power Mode: MODE_15W_6CORE - Type: 2 * jetson_clocks service: inactive - Libraries: * CUDA: 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a695aab82d72d4f92abacc85955f3922/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae5f124c7228ce26c0ecbe65ff39f50b/" rel="bookmark">
			树莓派：查看硬件设备命令RAM显示“NoneMb”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		刚买来的树莓派4B8G的板子，想看硬件信息，输入命令pinout即可
但事情总有意外，我的板子显示RAM列表出现NoneMb，如下
赶紧上网查了下:
第一：看下树莓派官网Troubleshooting，目前这是树莓派一个BUG，如果又立刻想知道是不是8G的内存，可以使用linux的命令“free”查看，如下：
第二：可以解决这个问题，就是更新下系统：
sudo apt-get update
sudo apt-get upgrade
sudo apt-get install python-dev
然后重启即可解决次问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3dc136c6f8b78a7ec86c75ffa5755b1/" rel="bookmark">
			微信小程序第三篇：获取页面节点信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 获取节点信息createSelectorQueryselectViewportboundingClientRectfields 获取节点信息 createSelectorQuery wx.createSelectorQuery()可以用于获取节点属性、样式、在界面上的位置等信息。
最常见的用法是使用这个接口来查询某个节点的当前位置，以及界面的滚动位置。
示例代码：
const query = wx.createSelectorQuery() query.select('#the-id').boundingClientRect() query.selectViewport().scrollOffset() query.exec(function(res){ res[0].top // #the-id节点的上边界坐标 res[1].scrollTop // 显示区域的竖直滚动位置 }) 在自定义组件或包含自定义组件的页面中，使用 this.createSelectorQuery 来代替 wx.createSelectorQuery ，这样可以确保在正确的范围内选择节点。
selectViewport selectViewport() 可以用来获取 scroll-view 的尺寸、滚动位置等信息
*注意：selectViewport()没有参数的 选择显示区域。可用于获取显示区域的尺寸、滚动位置等信息 onLoad: function (options) { const query=wx.createSelectorQuery();	//创建一个SelectorQuery 对象实例 query.selectViewport().	//选择显示区域 scrollOffset(function(res){	//查询节点（必须是scroll-view / viewport）的滚动位置 res.id // 节点的ID res.dataset // 节点的dataset res.scrollLeft // 节点的水平滚动位置 res.scrollTop // 节点的竖直滚动位置 }).exec() } boundingClientRect 添加节点的布局位置的查询请求。相对于显示区域，以像素为单位。
在执行 SelectorQuery.exec 方法后，节点信息会在 callback 中返回。
示例代码：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3dc136c6f8b78a7ec86c75ffa5755b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a7c93780062caf2b1a8e57be7397d2a/" rel="bookmark">
			微信小程序第二篇：七种主流通信方法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 通信方法组件通信propertiestriggerEventselectComponent 页面通信getCurrentPageswx.navigateTo 全局通信globalDatastorage 通信方法 组件通信 properties 父组件向子组件通信，与 Vue 的 props 作用相同。
父组件向子组件传数据：
&lt;my-component list="{{list}}"&gt;&lt;/my-component&gt; 子组件接收数据：
Component({ properties:{ list:{ type: Array, value: [] } }, attached(){ console.log(this.list) } }) triggerEvent 子组件向父组件通信，与 Vue 的 $emit 作用相同
子组件触发自定义事件：
Component({ attached(){ this.triggerEvent('customEvent',{ id: 10 }) } }) 父组件接收自定义事件：
&lt;my-component list="{{list}}" bind:customEvent="customEvent"&gt;&lt;/my-component&gt; Page({ customEvent(e){ console.log(e.detail.id) } }) selectComponent 使用选择器选择组件实例节点，返回匹配到的第一个组件实例对象，类似 Vue 的 ref
注意：获取节点实例应该放在 onReady 生命周期函数中
&lt;my-component id="mycomponent" list="{{list}}"&gt;&lt;/my-component&gt; Page({ onLoad(){ let mycomponent = this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a7c93780062caf2b1a8e57be7397d2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f52e91b3166f5d47b06baf58dd455e0b/" rel="bookmark">
			Spring(完整版)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Spring(一)、Spring简介1、Spring概述2、Spring家族3、Spring Framework1、Spring Framework五大功能模块2、Spring Framework特性 (二)、控制反转IOC1、IOC容器1、IOC思想2、IOC容器在Spring中的两种实现方式①BeanFactory②ApplicationContext③ApplicationContext的主要实现类 2、基于XML管理bean1、搭建Spring环境①创建Maven工程②引入依赖③创建Spring的配置文件 ApplicationContext.xml④在Spring的配置文件中配置bean⑤创建Bean工厂⑥注意Spring 底层⑦获取IOC容器的方式 2、获取bean的几种方式①方式一：根据id获取②方式二：根据类型获取③方式三：根据id和类型获取④扩展⑤结论 3、依赖注入(DI)的几种方式方式一：依赖注入之setter注入1、set注入的写法2、用set方法赋值的genBean底层： 方式二：依赖注入之构造器注入1、构造器注入的写法2、用构造方法给属性赋值的getBean的底层 4、特殊值赋值处理①字面量赋值②null值③特殊字符 5、为类类型属性赋值方法一：引用外部已声明的bean方法二：内部bean方法三：级联属性赋值 6、为数组类型属性赋值7、为集合类型属性赋值①为List集合类型属性赋值②为Map集合类型属性赋值 8、p命名空间9、引入外部属性文件10、bean的加载机制（bean的作用域）11、bean的生命周期①具体的生命周期过程②bean的作用域对生命周期的影响：③bean的前置和后置处理器④验证bean生命周期的方法 12、FactoryBean①简介②用法 13、基于xml的自动装配1、手动装配的方式2、自动装配的方式： 3、基于注解管理bean1、标记与扫描2、标识组件的常用注解1、以上四个注解有什么关系和区别？ 3、扫描组件的方式方式一：最基本的扫描方式方式二：指定要排除的组件方式三：仅扫描指定组件 4、组件所对应的bean的id5、基于注解的自动装配①场景模拟②@Autowired注解③@Autowired注解其他细节④@Autowired的工作流程 (三)、代理模式1、场景模拟2、提出问题①现有代码缺陷②解决思路③困难 3、静态代理和动态代理1、概念①介绍②生活中的代理③相关术语 2、静态代理3、动态代理 (四)、AOP概念及相关术语1、概述2、相关术语①横切关注点②通知③切面④目标⑤代理⑥连接点⑦切入点 3、作用4、切面的优先级 (五)、基于注解的AOP1、技术说明2、案例①添加依赖②准备被代理的目标资源③创建切面类并配置 3、各种通知及各种通知的执行顺序1、各种通知2、各种通知的执行顺序 4、切入点表达式语法①作用②语法细节 5、重用切入点表达式1、概念2、用法一：局部的声明式表达式3、用法二：声明公共的切入点表达式①在同一个切面中使用②在不同切面中使用 4、获取通知的相关信息①获取连接点信息②获取目标方法的返回值③获取目标方法的异常 5、环绕通知 (六)、基于XML的AOP(七)、Spring的AOP总结(八)、声明式事务1、JdbcTemplate1、简介2、准备工作①加入依赖②创建jdbc.properties③配置Spring的配置文件④、测试 2、声明式事务概念1、编程式事务2、声明式事务 3、基于注解的声明式事务①模拟场景②观察结果③解决方案：加入事务1、声明式事务的配置（步骤）：步骤1和2：添加事务配置并开启事务的注解驱动步骤3：添加事务注解 2、加入事务后观察结果 ④@Transactional注解标识的位置 4、事务属性：1、只读①介绍②使用方式③注意 2、超时①介绍②使用方式③观察结果 3、回滚策略①介绍②使用方式③观察结果 4、事务隔离级别①介绍②使用方式 5、事务传播行为①介绍②测试③观察结果 (九)、基于XML的声明式事务1、场景模拟2、修改Spring配置文件 （十）、Spring注解的总结 一、Spring (一)、Spring简介 1、Spring概述 官网地址：https://spring.io/
可以理解为是一个管理者，管理的是整个分层架构中的每一个对象,将每一个对象称为JavaBean
目的：Spring 框架的目标是使 J2EE 开发变得更容易使用，通过启用基于 POJO
编程模型来促进良好的编程实践。
Spring最主要学习的内容：
IOC:控制反转
DI:依赖注入，DI有的前提是有IOC
AOP:面向切面编程
Spring 是最受欢迎的企业级 Java 应用程序开发框架，数以百万的来自世界各地的开发人员使用
Spring 框架来创建性能好、易于测试、可重用的代码。
Spring 框架是一个开源的 Java 平台，它最初是由 Rod Johnson 编写的，并且于 2003 年 6 月首
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f52e91b3166f5d47b06baf58dd455e0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1b146046aa679090f3f84fbe8052abd/" rel="bookmark">
			使用Nacos bootstrap application 远程配置优先级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		结论 先说结论，bootstrap配置文件中的与nacos服务相关的配置不会被application配置文件覆盖
但是如果想要在bootstrap中配置项目应用所需的属性，那么优先级低于application配置文件。会被覆盖
这也符合bootstrap本身是用于引导的作用。
至于nacos服务器上的配置，默认最大（可以配置修改），即使是命令参数也无法覆盖。
加载bootstrap配置文件 springBoot启动时当执行到prepareContext触发environmentPrepared事件，会触发BootstrapApplicationListener#onApplicationEvent
然后进入org.springframework.cloud.bootstrap.BootstrapApplicationListener#bootstrapServiceContext
StandardEnvironment bootstrapEnvironment = new StandardEnvironment(); //将默认Environment的PropertySource全部清空 MutablePropertySources bootstrapProperties = bootstrapEnvironment .getPropertySources(); for (PropertySource&lt;?&gt; source : bootstrapProperties) { bootstrapProperties.remove(source.getName()); } String configLocation = environment .resolvePlaceholders("${spring.cloud.bootstrap.location:}"); Map&lt;String, Object&gt; bootstrapMap = new HashMap&lt;&gt;(); //将配置文件名指定为bootstrap bootstrapMap.put("spring.config.name", configName); ····省略代码··· SpringApplicationBuilder builder = new SpringApplicationBuilder() .profiles(environment.getActiveProfiles()) //不打印启动banner .bannerMode(Mode.OFF) //设置新创建的Environment .environment(bootstrapEnvironment) // Don't use the default properties in this builder .registerShutdownHook(false).logStartupInfo(false) .web(WebApplicationType.NONE); //设置primarySource为 BootstrapImportSelectorConfiguration builder.sources(BootstrapImportSelectorConfiguration.class); //又新创建了一个springCloud的springAplication final SpringApplication builderApplication = builder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1b146046aa679090f3f84fbe8052abd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfa8d99d8c0d6481ca97f2b2f955f591/" rel="bookmark">
			Springboot项目，前端上传富文本内容给后台，后台接收到的内容有标签丢失。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 主要是Springboot项目配置了防止XSS攻击。
修改application.yml文件中的配置即可
# 防止XSS攻击 xss: # 过滤开关 enabled: true # 排除链接（在过滤链接中，哪些不需要过滤，可使用*通配符，多个用逗号分隔） excludes: /system/contentSave/*,/system/Xxxxx/* # 匹配链接（哪些链接需要开启过滤） urlPatterns: /system/*,/monitor/*,/tool/* 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5645c387fb34640c1ec7b5f3a288a2e1/" rel="bookmark">
			Games101-作业一: 旋转与投影
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		模拟一个基于CPU的光栅化渲染器的简化版本 作业要求: 需要我们填充MVP变换中的M(模型变换)和P(投影变换) get_model_matrix()函数: 由作业框架中给出的注释得知, 需要创建用于围绕 Z 轴旋转三角形的模型矩阵
直接套用如下公式:
完整代码如下: (注意弧度rotation_angle与角度的换算)
get_projection_matrix()函数: 由作业框架中给出的注释得知, 用给定参数创建透视投影矩阵
相关参数解析:
t, b, l, r, n, f 各对应上、下、左、右、近、远平面, 公式中的这些参数表示原点距离平面的距离, 例如: t=-b , l=-r
正交投影矩阵公式如下:
透视变正交投影矩阵公式如下:
透视投影矩阵 == 正交投影矩阵 乘以 透视变正交矩阵
注意事项: 求出t , r 给出的参数中有 eye_fov(垂直可视角度), aspect_ratio(宽高比), zNear(相机与近平面的距离), zFar(相机与远平面的距离)
下图中通过 zNear / eye_fov 的三角关系得出 height, 也就是我们需要求的原点与上平面的距离(t)
用aspect_ratio * t得出 r.
完整代码如下:
提高项 这里使用的是第三节课讲的罗德里格旋转公式（Rodrigues' rotation formula） 完整代码如下:
get_rotation(围绕axis这条轴, 旋转angle度)
写好了被调用的函数, 现在就差调用接口没有设置了
我比较省事(其实就是懒哈哈哈), 所以直接用原来的接口, 直接替换参数
main()函数: (只改变划线处)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5645c387fb34640c1ec7b5f3a288a2e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bce0d9367660f012448ed5139676ce9/" rel="bookmark">
			超详细ubuntu安装redis及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ubuntu安装redis及使用 有些代码或者步骤可能有些区别和不妥，欢迎指正
参考博客：ubuntu 安装redis
ubuntu安装redis及使用 ubuntu安装redis及使用redis安装redis主从复制注意主从复制原理 redis哨兵模式实现 redis安装 我安装的redis版本为5.0.14.1
虚拟机有网络应该是可以使用命令下载的
redis下载
首先在windows下将安装包下载下来，再传输到虚拟机中。
我使用的是xftp进行文件传输和连接虚拟机
先使用ifconfig命令查看本机ip
使用xftp建立连接
主机填写查到的ip地址，用户名密码填写你的。
连接建立后将下载的文件拖拽过去即可：
一直连接不上的可以看看虚拟机中是否配置了ssh服务，未配置的需要下载ssh服务
下载： sudo apt install openssh-server 开启： sudo service sshd start 将下载好的redis压缩包解压缩
我将其移动到usr/local下面（mv指令显示权限不够，需要root权限）
进入redis文件夹，安装redis
初始的redis下不包含redis.server和redis.cli等文件，需要安装后才会有，执行make命令
注意
在这里没有make工具的需要下载，在更新时遇到类似
: 仓库 “https://mirrors.tuna.tsinghua.edu.cn/ubuntu impish-backports Release” 没有 Release 文件。 问题的需要更换软件源，可参考下面的博客
仓库 “https://mirrors.tuna.tsinghua.edu.cn/ubuntu xenial Release” 没有 Release 文件
下载make工具
继续操作：
再在redis的src目录下看见redis-cli和server即成功
修改配置文件redis.conf
打开文件：
gedit redis.conf 修改密码
修改bind，在末尾追加本机的ip地址（允许其他服务器连接）
启动redis服务
src目录下，执行启动命令（指定配置文件启动redis）
可以通过修改redis.conf中的daemonize，设置为yes，则切换启动方式为后台启动
连接redis客户端
![在这里插入图片描述](https://img-blog.csdnimg.cn/044047193a874951a31bb2ecd0e3bede.png
redis主从复制 搭建一主多从
配置一主两从：
桌面新建一个myredis文件夹，复制redis.conf到文件夹
创建三个配置文件redis6378.conf，redis6380.conf，redis6381.conf，并在文件中写入相应内容（通过include引入原始配置）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1bce0d9367660f012448ed5139676ce9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af337e06f3315c90ffb9e756922c1e98/" rel="bookmark">
			(C语言)printf打印的字符串太长了，我想分两行！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本文来自于公众号：C语言编程技术分享
一、提问 有下述C程序：
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() {	printf("123456789012345678901234567890\n"); system("pause"); return 0; } printf函数要打印的字符串是“123456789012345678901234567890\n”，太长啦，可不可以分为两行写呀~~~
当然可以了！
二、知识点 C语言中，printf函数在打印很长的一行字符串时，为了美观我们可以分成两行写，第一个方法就是在字符串中间使用 \ 即可，也就是：
“123456789012345678901\
234567890\n”
那么上述C程序可以写成：
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() {	printf("1234567890123456789\ 01234567890\n"); system("pause"); return 0; } 可以运行一把，结果如下：
还有第二个方法，分两行写的话每一行都用双引号括起来，就像这样：
"1234567890123456789"
"01234567890\n"
那么上述C程序就可以写成：；
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() {	printf("1234567890123456789" "01234567890\n"); system("pause"); return 0; } 运行结果如下：
这个知识点就说清楚了！
三、留个疑问 如果我这样写的话，下述C程序会有什么问题？欢迎留言讨论。
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() {	printf("1234567890123456789\ 01234567890\n"); system("pause"); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fff5b83227fdf49191a781062f5f860/" rel="bookmark">
			会搜索但是迟迟不会动态规划，看这篇就够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题简述 给定 n n n 个点 m m m 条边的有向简单图，每条边有个边权，代表经过这条边需要花费的时间，我们只能从编号小的点走到编号大的点，问从 1 1 1 号点走到 n n n 号点最少需要花费多少时间？
输入格式
第一行两个整数 n n n， m m m。
接下来 m m m 行，每行三个整数 u u u， v v v， w w w，表示存在一条从 u u u 到 v v v 的边权为 w w w 的有向边。保证存在一条 1 1 1 到 n n n 的路径。
输出格式
输出一个数，表示答案。
此时我们先看样例：
我们通过枚举所有可行的边，发现红线标出的路时本图的最短路，长度为 14。
思路 尝试 贪心 首先我们的第一个思路是贪心——从 1 出发，枚举连出来的边，每次只走能走到的边中最短的那一条，这样时间复杂度就是我们走过的那一条路径，非常快。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fff5b83227fdf49191a781062f5f860/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32612782e4249c0fe65edfcabcbd4447/" rel="bookmark">
			STM32CubeMX之定时器PWM输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32CubeMX之定时器PWM输出 知识百科 – PWM简介 PWM是一种对模拟信号电平进行​​ ​​数字编码​​​​​的方法。通过高​​ ​​分辨率​​​​计数器的使用，方波的占空比被调制用来对一个具体​​ ​​模拟信号​​​​的电平进行编码。PWM信号仍然是数字的，因为在给定的任何时刻，满幅值的直流供电要么完全有（ON），要么完全无（OFF）。电压或电流源是以一种通（ON）或断（OFF）的重复脉冲序列被加到模拟负载上去的。通的时候即是直流供电被加到负载上的时候，断的时候即是供电被断开的时候。只要带宽足够，任何模拟值都可以使用PWM进行编码。
脉宽调制（PWM，Pulse Width Modulation）是利用微处理器的数字输出来对模拟电路进行控制的一种非常有效的技术，广泛应用在从测量、通信到功率控制与变换的许多领域中 。
PWM的一个优点是从处理器到​​ ​被控系统​​​信号都是数字形式的，再进行数模转换。可将噪声影响降到最低（可以跟电脑一样）。噪声只有在强到足以将逻辑1改变为逻辑0或将逻辑0改变为逻辑1时，也才能对数字信号产生影响。
STM32定时器PWM输出简介 定时器脉冲宽度调制模式可以产生一个由TIMx_ARR寄存器确定频率、由TIMx_CCRx寄存器确定占空比的信号。在TIMx_CCMRx寄存器中的OCxM位写入’110’(PWM模式1)或’111’(PWM模式2)，能够独立地设置每个OCx输出通道产生一路PWM。必须设置TIMx_CCMRx寄存器OCxPE位以使能相应的预装载寄存器，最后还要设置TIMx_CR1 寄存器的ARPE位， (在向上计数或中心对称模式中)使能自动重装载的预装载寄存器。
仅当发生一个更新事件的时候，预装载寄存器才能被传送到影子寄存器，因此在计数器开始计数之前，必须通过设置TIMx_EGR寄存器中的UG位来初始化所有的寄存器。OCx的极性可以通过软件在TIMx_CCER寄存器中的CCxP位设置，它可以设置为高电平有效或低电平有效。 TIMx_CCER寄存器中的CCxE位控制OCx输出使能。
PWM模式介绍 在计数器向上计数模式下(即TIMx_CR1的DIR位为0) ，当TIMx_CNT&lt;TIMx_CCRx时PWM信号参考OCxREF为高，否则为低。如果TIMx_CCRx中的比较值大于自动重装载值(TIMx_ARR)，则OCxREF保持为’1’。如果比较值为0，则OCxREF保持为’0’。 下图为TIMx_ARR=8(ARR重装载寄存器，表示定时器的计数周期)时边沿对齐的PWM波形实例。
本示例实现 IO 输出模式–PWM 波形输出。 以 LED 驱动为例， 使用定时器高级功能(PWM 模式)， 实现呼吸灯效果。
1.硬件接口 本硬件平台有3个LED灯分别为LED2、LED3、LED4LED2接PA1，LED2接PB8，LED4接PB9,硬件原理图如下：
根据STM32引脚定义手册或者STM32CUbeMX软件我们可得知定时器4的CH1和CH2对应外部引脚PB8和PB9。
2 软件设计 打开STM32CubeMX工具，配置定时器4，将PB8配置为定时器4通道3（复用推挽输出），PB9配置为定时器4通道4（复用推挽输出）。
定时器4 基本配置及PWM模式配置
配置定时器通道模式为PWM模式，设置分频系数为72，重装载值为500，设置有效电平为低电平。
3.参数说明 模式说明Input capture direct mode输入捕获直接模式Input capture indirectmode输入捕获间接模式Input capture triggered by TRC输入捕获触发器模式Output compare no output输出比较（冻结模式000 ）Output compare CH3输出比较(001)PWM Generation No outputPWM产生无输出PWM Generation CH3PWM输出到CH3CH3 Combined channels联合通道xor activation定时器输入异或模式 4. 代码生成 TIM4基本功能配置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32612782e4249c0fe65edfcabcbd4447/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9e5826a6b6544015bd8ab6939cf873a/" rel="bookmark">
			C&#43;&#43;版忍者跑酷小游戏（可直接复制程序源代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		声明：本文为转载文章，特别鸣谢Harry_g_Potter博主，谢谢
话不多说，直接上代码 ：
#include&lt;bits/stdc++.h&gt; #include&lt;windows.h&gt;
#include&lt;stdio.h&gt;
#include&lt;conio.h&gt;
#include&lt;time.h&gt;
#define Nor if(B[b].x&lt;5) B[b].x=5;
#define Out1 Bx1-Bvx1&lt;=6||Bx1-Bvx1&gt;=28||By1-Bvy1&lt;=7||By1-Bvy1&gt;=27
#define Out2 Bx2-Bvx2&lt;=6||Bx2-Bvx2&gt;=28||By2-Bvy2&lt;=7||By2-Bvy2&gt;=27
#define Chang1 {Bwhat1=0;Bvx1=Bvy1=0;memset(Bgo1,0,sizeof(Bgo1));}
#define Chang2 {Bwhat2=0;Bvx2=Bvy2=0;memset(Bgo2,0,sizeof(Bgo2));}
#define Chang3 {Bwhat3=0;Bvx3=Bvy3=0;memset(Bgo3,0,sizeof(Bgo3));}
using namespace std;
int ti(float a) {return ((int)(a*10+5))/10;}
void Setpos(float x,float y){COORD pos;pos.X=ti(y*4)/2;pos.Y=ti(x);SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE),pos);}
void Color(int a){if(a==0) SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_INTENSITY|FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE);if(a==1) SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_INTENSITY|FOREGROUND_GREEN|FOREGROUND_BLUE);if(a==2) SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_INTENSITY|FOREGROUND_GREEN);if(a==3) SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_INTENSITY|FOREGROUND_RED|FOREGROUND_BLUE);if(a==4) SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_INTENSITY|FOREGROUND_RED);if(a==5) SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_INTENSITY|FOREGROUND_RED|FOREGROUND_GREEN);if(a==6) SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_INTENSITY|FOREGROUND_BLUE);if(a==7) SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE);if(a==8) SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_RED);if(a==9) SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),BACKGROUND_INTENSITY|BACKGROUND_GREEN|BACKGROUND_BLUE);if(a==10) SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),BACKGROUND_INTENSITY|BACKGROUND_RED|BACKGROUND_BLUE);if(a==11) SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_RED|FOREGROUND_BLUE);if(a==12) SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_RED|FOREGROUND_GREEN);if(a==13) SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_INTENSITY);if(a==14) SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_GREEN|FOREGROUND_BLUE);}
int Blomax,Ren,Exp,Expmax,Lv,Lvl,Ice,Drug,ar1,ar2,Tar1,Tar2,bl,br,Win,T,Tb,Sy,Up,Upt,Down,u1,u2,Kill,Killb,L,Ll[4],Li,D,Gd[10],Biao,Fire,Fir,Water,Thun,Wind,Magne,I[20][2],ib,Dis,Disb,Dis1,Disb1,Boss,Bblo,Bblomax,Bwhat1,Bwhat2,Bwhat3,Bgo1[10],Bgo2[10],Bgo3[10],Bbr,Bbl,Bl[4];
float X,Y,Vx,Vy,Ding,Blo,Hui,Bx1,By1,Bx2,By2,Bx3,By3,Bvx1,Bvy1,Bvx2,Bvy2,Bvx3,Bvy3,Bway[1001][2];
struct bullet{float x,y,vx,vy;int what;int a,t,How;int life;bool kill;}B[100001];
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9e5826a6b6544015bd8ab6939cf873a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/658159990f2e24663e4694898b8d71da/" rel="bookmark">
			SpringBoot 使用 Feign 无废话 All-in-one 指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开篇 Feign 是声明式、模板化的 HTTP 客户端， 可以帮助我们更快捷、优雅地调用 HTTP API；Spring Cloud 为 Feign 添加了 Spring MVC 的注解支持，并整合了 Ribbon 和 Eureka 来为使用 Feign 时提供负载均衡；在 Spring Cloud 中使用 Feign 是非常容易的。
本篇主要介绍 SpringBoot 中要玩转 Feign 需要掌握的如添加 pom 依赖、客户端注解启用、切换底层 HttpClient、配置数据压缩、调整日志级别、定制配置、配置的优先级机制、增加拦截器以及拦截器的追加机制等知识。
一、使用 Feign 的示例 1.1 添加依赖 &lt;dependencies&gt; &lt;!--openfein的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;version&gt;2.1.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 复制代码 1.2 启用 Feign 在 SpringBoot 的启用类上添加注解@EnableFeignClients，@EnableFeignClients用于开启 Feign，会自动扫描@FeignClient标注的 FeignClient 接口。
@SpringBootApplication @EnableFeignClients @EnableWeb public class FeignApplication { public static void main(String[] args) { SpringApplication.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/658159990f2e24663e4694898b8d71da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c334e0ad68f655f20038b620a56c0de0/" rel="bookmark">
			Springboot中常用注解的使用语境、方法以及常用的maven坐标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、注解
1. 关于 @Slf4j 注解的使用说明
2. @Configuration 注解
例子：
注意 ： @Configuation总结： @Configuation等价于 @Bean等价于 @ComponentScan等价于
补充：
3.灌入REST风格有关的注解
理解：
例子：
前提：
4.@RestControllerAdvice注解
理解：
特点：
例子：
5.@Data注解
作用： 使用前提：
5.@Mapper注解
例子:
前提：
例子： 6.@TableName、 @TableId、 @TableField注解
使用前提：
7.有关@Component、@Service、@Controller、@Repository注解
作用：
@Component注解：
@Service服务注解：
@Controller控制器注解：
@Repository注解：
8.有关@Autowired、@Qualifier、@Resource、@Value注解
@Autowired注解：
@Qualifier注解：
@Resource注解
@Value注解：
9.@ConfigurationProperties注解
10.@EnableConfigurationProperties注解
11.@DurationUnit注解与@DataSizeUnit注解
12.Bean属性校验有关的注解@Validated、@MAX、@MIN
13.@Import注解使用
14.@SpringBootTest完成web环境模拟测试
15.关于@Transactional与@RollBack注解 二、常用maven坐标
1. lombok坐标的使用，参照注解1 与注解5
2.解决“未配置Springboot配置注释处理器” 问题的maven坐标 参考注解9
3.Bean属性校验Maven坐标
4.使用hibernate框架提供的校验器做实现类
一、注解 1. 关于 @Slf4j 注解的使用说明 作用：帮我们创建一个Logger对象，如下图代码所示
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c334e0ad68f655f20038b620a56c0de0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48e91a3c01e363337611aadab4967192/" rel="bookmark">
			[洛谷]欢乐的跳P1152
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不是很难，一开始没仔细审题，没注意是连续，结果多算了好多。
连续的话就简单多了。n个数字的连续之差只有n-1个；所以每一个数字都不能歪
用桶排序，将相邻的数字之差的绝对值 i 存到b[i]，（让b[i]加1来进行记录）
同时如果i&gt;n-1 就不要进行存入，或者直接可以输出结果了
同时如果b[i]为2，即i被存了2此，也可以直接输出了
最后遍历一个b[i] 有0 就输出 over，
能出循环就输出成功
//数组要开大一点，
#include &lt;bits/stdc++.h&gt; using namespace std; int n; int a[10011]; int b[10011]; int i, j; int temp; int main() { cin &gt;&gt; n; for (i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i]; } for (i = 2; i &lt;= n; i++) { temp = abs(a[i] - a[i - 1]); if (temp &lt;= n - 1) { temp++; } } for (i = 1; i &lt;= n - 1 ; i++) { if (b[i] == 0) { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48e91a3c01e363337611aadab4967192/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53b42e6e23d3049b2a226e91ed946ab1/" rel="bookmark">
			暴力拆卸tomcat8-NioEndpoint
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		tomcat的初始化nio模型是一个Accept,2个Poller。详见NioEndpoint.startInternal();
private int pollerThreadCount = Math.min(2,Runtime.getRuntime().availableProcessors()); protected int acceptorThreadCount = 1; Accept负责处理连接，serverSock为阻塞模式serverSock.configureBlocking(true);，客户端socket为非阻塞模式socket.configureBlocking(false);。并把socket包装NioChannel，NioChannel使用栈机制SynchronizedStack，重复利用对象。NioChannel通过getPoller0().register(channel);方法注册给poller.SynchronizedQueue事件队列，队列会在poller线程中一直查看是否有事件，有事件注册到selector。
Poller负责处理读写selector.selectedKeys().iterator()事件。获取到事件给processKey(sk, attachment);方法，交给线程池处理。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a675cb15140ef940a014a4d42e5ba66/" rel="bookmark">
			华为PPPOE协议&#43;配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 PPPOE基本概念PPPOE会话建立PPPOE报文类型PPPOE详细建立过程PPPOE配置：PPPOE服务器端配置：PPPOE客户端端配置： PPPOE基本概念 PPPOE是在一个广播域中的两个以太网端口上建立点到点的隧道的协议。
PPPOE会话建立 1、PPPOE发现阶段：用来发现PPPOE服务器。
2、PPPOE会话阶段：和PPP的建立流程一样（LCP协商、认证协商、NCP协商）。
3、PPPOE终止阶段：客户不再使用服务，关掉PPPOE会话。
PPPOE报文类型 PPPOE详细建立过程 1、发现阶段：PPPOE客户端通过广播发送PADI报文来发现接入服务器。所有PPPOE服务器在收到PADI报文后，将客户端请求的服务与自己能提供的服务进行比较，如果可以提供，则单播回复PADO报文。PPPOE客户端选择最先收到的PADO报文对应的PPPOE服务器，并单播发送一个PADR报文。PPPOE服务器生成唯一的PPPoE Session ID分配给客户端,并发送会话建立确认报文PADS给客户端。
2、会话阶段：分为两个阶段：PPP协商与PPP报文传输阶段。PPPOE上的PPP协议和普通的PPP协商方式一样，分为LCP、认证、NCP三个阶段。PPP协商成功后，就可以传输PPP数据。详细的PPP协商请点击观看：PPP协议协商详细步骤
3、会话终止阶段：客户端想关掉链接时，会向PPPOE服务器发送PADT报文，用于终止PPPOE会话。
PPPOE配置： PPPOE服务器端配置： 配置aaa
[PPPOE server]aaa
[PPPOE server-aaa]local-user wangluo password cipher wangluo
[PPPOE server-aaa]local-user wangluo service-type ppp
配置地址池p1
[PPPOE server]ip pool p1
[PPPOE server-ip-pool-p1]network 12.1.1.0 mask 24
[PPPOE server-ip-pool-p1]excluded-ip-address 12.1.1.1
配置VT接口
[PPPOE server]inter Virtual-Template 1
[PPPOE server-Virtual-Template1]ppp authentication-mode chap
[PPPOE server-Virtual-Template1]remote address pool p1 //动态为对端分配IP
[PPPOE server-Virtual-Template1]ip address 12.1.1.1 24
绑定端口
[PPPOE server]interface GigabitEthernet 0/0/0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a675cb15140ef940a014a4d42e5ba66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83796ab1283e5e43dea0fb3966303d2a/" rel="bookmark">
			【MYSQL】在线恢复主从复制方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、恢复前提 因复杂情况，从库无法从binlog中恢复主从复制关系，需要从备份文件中恢复。恢复过程的几个关键点为：
1、从库现有数据的清理。本方案采用覆盖的方式，导出时添加add-drop参数即可。还有一个方案是手动删除数据文件，再初始化数据库。
2、主库导出之前一定要reset master清除日志文件，否则备库连上后会执行binlog的语句出现各种各样的问题。
二、恢复步骤 1、备份主库、备库文件系统/data
mkdir -p /mysqlrecovery
mount 109.0.14.58:/appm/aixinst/mysql_install/MaterSlaveRecovery /mysqlrecovery
cd /mysqlrecovery
tar cf mysql_master.tar /data/mysql_5.7_3306
tar cf mysql_slave.tar /data/mysql_5.7_3306
2、主库清理binlog
mysql -uroot -pxxxx -e “reset master;”
3、备库导出、获取备份文件
mysqldump -h109.6.45.35 -uroot -pxxxx --triggers --routines --events --single-transaction --add-drop-database --add-drop-table --add-drop-trigger --all-databases &gt; /mysqlrecovery/mysql_data.sql 2&gt;/mysqlrecovery/mysql_data.sql.exp.log
echo $?
cat /mysqlrecovery/mysql_data.sql.exp.log
4、备库上恢复数据。
mysql -uroot -pxxxx -e “stop slave;”
mysql -uroot -pxxxx -e “reset slave;”
mysql -uroot -pxxxx -e “reset master;”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83796ab1283e5e43dea0fb3966303d2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a720d4149745d777ef0c2dd43f341eef/" rel="bookmark">
			Chrome漏洞分析与利用(十三)——issue-1182647(CVE 2021-21195)漏洞分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		POC let s = []; function foo() { var arr = Array(1000); function bar() { try { const err_obj = {a: p4nda, b: arr}; } catch(e) { return e; } } for (var i = 0; i &lt; 25; i++) bar(); var ret = bar(); /p4nda/.test({}); // Deopt here. s[0] = arr; arr.shift(); return ret; } %PrepareFunctionForOptimization(foo); foo(); foo(); %OptimizeFunctionOnNextCall(foo); let r = foo(); gc(); gc(); 由于调用了gc函数，所以在使用d8执行时需要加上–expose-gc 参数，执行后。
漏洞分析 调试 issue 1182647
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a720d4149745d777ef0c2dd43f341eef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b36667b42f79c40b423f41a8dd77186/" rel="bookmark">
			pandas实现列转行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pandas实现列转行 1、原始数据如下：
姓名 学号 英语 数学 语文
A 1001 90 80 85
B 1002 60 98 90
C 1003 70 80 75
2、要转换为如下格式：
姓名 学号 科目 分数
A 1001 英语 90
A 1001 数学 80
A 1001 语文 85
B 1002 英语 60
B 1002 数学 98
B 1002 语文 90
C 1003 英语 70
C 1003 数学 80
C 1003 语文 75
代码实现如下：
df = pd.DataFrame({‘姓名’: [‘A’,‘B’,‘C’],
‘学号’:[‘1001’,‘1002’,‘1003’],
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b36667b42f79c40b423f41a8dd77186/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73e6d6461e8592e34f4768107f68b3f8/" rel="bookmark">
			Beyond compare 全红问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Beyond compare 在比较时首先会比对两个文件的大小和时间戳，我们经常会碰到两个同名文件大小内容都一样但是就是红色的，只有点进去比较之后才会变成默认颜色，这就是因为时间戳不同引起的，现在针对这个问题，提供一种解决方法；
1、在菜单栏中找到“规则”选项；
2、 在“规则”菜单中，选择第二项“比较”，将“比较时间戳”取消勾选
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/505c68255e56b0ca1617661b7f7b7629/" rel="bookmark">
			css-实现卡牌的发牌和翻转动画
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景描述： 打开抽卡界面，卡牌出现并发牌至固定的位置，此时展示的是卡牌的背面；用户点击卡牌时，卡牌进行翻转，并展示卡牌内容，或者发牌后自动进行翻转和展示。
本实例在页面挂载后自动播放动画，若需点击后再播放，只需将事件写入click事件当中即可
卡牌样式可根据具体需求设置
实现思路： html结构：
动态设置class属性，即可实现动态的css样式及动画
&lt;template&gt;
&lt;div class="cardContent"&gt;
&lt;div class="cardBox"&gt;
&lt;div
:class="['card-item', `card-item-${index + 1}`]"
v-for="(item, index) in drawList"
:key="index"
&gt;
&lt;!-- 数组中存入index值时，将写有动画的class属性赋给标签，即开始播放动画 --&gt;
&lt;div
:class="['card', selectArr.includes(index) ? 'cardAnimate' : '']"
&gt;卡牌背面&lt;/div&gt;
&lt;div
:class="['contxt', selectArr.includes(index) ? 'contxtAnimate' : '']"
&gt;卡牌{{index+1}}正面
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/template&gt;
翻牌动画在挂载后自动执行，
//数组中存入index值时，将写有动画的class属性赋给标签，即开始播放动画
//自动播放翻牌动画，1500ms后播放第一张翻牌动画，然后每200ms播放一张
for (let i = 0; i &lt; 6; i++) {
setTimeout(() =&gt; {
this.selectArr.push(i);
}, 1500 + (i - 1) * 200);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/505c68255e56b0ca1617661b7f7b7629/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b21cf17e3388c2f4c47f9eb926c9e383/" rel="bookmark">
			java读取文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先看项目截图
public class FileTest { public static void main(String[]args) throws IOException { String path = Objects.requireNonNull(FileTest.class.getClassLoader().getResource("config/First.xml")).getPath(); System.out.println(path); System.out.println("***********"); String result = FileUtils.readFileToString(new File(path), StandardCharsets.UTF_8); System.out.println(result); } } 文件放在resources目录下，用上面的方式就能读。
那如果文件放到src目录下呢？
比较麻烦
为什么？因为我们知道java的运行是把后缀名为java的文件进行编译，编译成.class文件， 然后统一放到/Users/dongleifeng/IdeaProjects/parent_pro/spring_boot/target/classes/ 下面这个位置
我们可以看到target下有两个文件夹一个classes和一个test-classes
如上图所示，我用的ide是idea，idea默认只把
src/main/java 下的后缀名为.java的文件进行了编译，复制到classes文件夹
src/main/resources 下的所有配置文件复制到classes文件夹
还有test下面的对应文件复制到test-classes
加入你把配置文件放到src下面，最终咱们的业务逻辑是在classes文件夹里开始的，那自然就没法感知到原来的src/main/java下面的配置文件了。
怎么办，既然知道了为什么访问不到文件，那想办法让idea把src下面的非java文件也复制到target/classes下面不就OK了？
解决方案见：
https://blog.csdn.net/shifangwannian/article/details/48882201
但是我觉得不好，最好的方式依然是把配置文件放到resources目录下
人家规范都定好了
src下面是源文件
resources下是配置文件
为啥要打破这个规则呢？
另外再附一个读取properties文件的方式
pom如下：
&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-configuration2&lt;/artifactId&gt; &lt;version&gt;2.8.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- commons-configuration2 的实现需要依赖commons-beanutils --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-beanutils&lt;/groupId&gt; &lt;artifactId&gt;commons-beanutils&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt; &lt;/dependency&gt; 代码如下：
package com.alibaba; import org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b21cf17e3388c2f4c47f9eb926c9e383/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8aa318d1c400990e472194f3f42cb5d8/" rel="bookmark">
			关闭eclipse控制台console中的非Java Server(ESLint、Angular Language Server等)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、问题 日常开发用eclipse的时候发现console里面有很多非java的server，不仅占用内存，切换server的console的时候也麻烦
2、解决 1）Window——&gt;Preferences——&gt;搜索Language Servers——&gt;去掉勾选不必要的server——&gt;保存设置
2）重启启动eclipse
3）再也可以不用看到不想看到server了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9964a61ac2e1c5cce2db3ba9a97eefba/" rel="bookmark">
			Mockito教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 Mockito 介绍
1.1 Mockito是什么？
1.2 为什么需要Mock
1.3 Stub和Mock异同
1.4 Mockito资源
1.5 使用场景
2 使用Mockito
2.1 验证行为
2.2 模拟我们所期望的结果
2.3 RETURNS_SMART_NULLS和RETURNS_DEEP_STUBS
2.4 模拟方法体抛出异常
2.5 使用注解来快速模拟
2.6 参数匹配
2.7 自定义参数匹配
2.8 捕获参数来进一步断言
2.9 使用方法预期回调接口生成期望值（Answer结构）
2.10 修改对未预设的调用返回默认期望
2.11 用spy监控真实对象 2.12 真实的部分mock
2.13 重置mock
2.14 验证确切的调用次数
2.15 连续调用
2.16 验证执行顺序
2.17 确保模拟对象上无互动发生
2.18 找出冗余的互动(即未被验证到的)
3 Mockito如何实现Mock
参考
1 Mockito 介绍 [3] 返回
1.1 Mockito是什么？ Mockito是mocking框架，它让你用简洁的API做测试。而且Mockito简单易学，它可读性强和验证语法简洁。
1.2 为什么需要Mock 测试驱动的开发( TDD)要求我们先写单元测试，再写实现代码。在写单元测试的过程中，我们往往会遇到要测试的类有很多依赖，这些依赖的类/对象/资源又有别的依赖，从而形成一个大的依赖树，要在单元测试的环境中完整地构建这样的依赖，是一件很困难的事情。如下图所示： 为了测试类A，我们需要Mock B类和C类（用虚拟对象来代替）如下图所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9964a61ac2e1c5cce2db3ba9a97eefba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/544cba8f3df07b588c16df5772eb9db4/" rel="bookmark">
			java--Lambda （5）表达式的引用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0 写在前面1.1 静态方法引用1.2参数方法引用1.3实例方法引用2 构造器引用 3 写在最后 0 写在前面 引用是基于方法调用的事实提供一种简短的语法，让我们无需看完整的代码就能弄明白代码的意图。
Lambda 表达式的引用分为：方法引用 和 构造器引用两类。
方法引用格式：类名::方法名
构造器引用格式：类名::new
方法引用有三种：
静态方法引用；参数方法引用；实例方法引用。 简单记录一下：
1.1 静态方法引用 格式：类名::方法名
静态方法应用就是调用类的静态方法。
被引用的参数列表和接口中的方法参数一致；接口方法没有返回值的，引用方法可以有返回值也可以没有；接口方法有返回值的，引用方法必须有相同类型的返回值。
举例(Java代码)：
//接口 public interface Finder { public int find(String s1, String s2); } //带有静态方法的类 public class StaticMethodClass{ public static int doFind(String s1, String s2){ return s1.lastIndexOf(s2); } public static void main(String[] args) { Finder finder = StaticMethodClass :: doFind; int i = finder.find("123abc", "b");//此时，Finder 接口引用了 StaticMethodClass 的静态方法 doFind。 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/544cba8f3df07b588c16df5772eb9db4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83de0ad71764ae3f944c23b0ba9621a2/" rel="bookmark">
			iOS 一行代码实现单行多按钮单选按钮事例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、经常有单行多按钮单选效果的设计，大多数人第一想到的就是for循环UI和frame来创建，但
是项目中又引入了 masonry框架，masonry原本就是做UI布局的，那可不可以利用起来呢？答案
是可以的；
2、下面就使用masonry来简单实现一下单行多按钮单选效果，并且默认第一个按钮为默认按钮的场景：
// @property (nonatomic, strong) UIView *rootView; // @property (nonatomic, strong) UIButton *childSelectedBtn;//声明一个全局默认按钮 NSMutableArray *arraychildView = [NSMutableArray new]; NSArray *titlechildArr = @[@"班级",@"院校",@"省份"]; for (int i = 0; i &lt; titlechildArr.count; i++) { UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom]; button.backgroundColor = [UIColor colorWithHexString:@"F3F4F5"]; button.tag = 1000 + I; [button setTitleColor:[UIColor colorWithHexString:@"000000"] forState:UIControlStateNormal]; [button setTitle: titlechildArr[i] forState:UIControlStateNormal]; [button addTarget:self action:@selector(childAction:) forControlEvents:UIControlEventTouchUpInside]; [self.rootView addSubview:button]; [arraychildView addObject:button]; if(button.tag == 1000) { self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83de0ad71764ae3f944c23b0ba9621a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41ec5e1cb6de6c94279063a588b2af5c/" rel="bookmark">
			nginx(四十六)log阶段log模块学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 ngx_http_log_module
说明：这是'nginx' 11个阶段的'最后'一个阶段 理想: nginx如果能记录最终'匹配的location'和'server_name'就好了 现实的情况： 往往需要根据'Host'头、$proxy_pass、$request '综合'判断 --&gt;由于'内部重定向' nginx何时记录日志 ① access_log
1）path 了解
nginx syslog记录日志
语法：access_log syslog:server=address[,parameter=value] [format]; 特点：可以将nginx日志'直接传输'到logstash中而'不落盘',但是这种方法传输的日志'不可靠'，并且会对nginx产生'性能'影响,可以在'测试'的时候使用 2）buffer和gzip 了解
细节点： 打开gzip的时候,默认已经'开启'buffer了 3）if 掌握
② log_format
1）日志'格式'应该使用'哪些'变量才能帮助'运维人员快速定位'问题 --&gt;'运维' 2）日志格式'包含哪些信息'来方便我们'提取有效'信息进行全局分析 --&gt;'反馈' 1）默认的日志格式 2）细节阶段
1）default定义'普通的文本'格式转义字符的处理规则 --&gt;体会'default'和'json'转义规则的不同 2）json定义了 'json 格式字符串(单双引号)'中一些'非法字符的转义'规则 --&gt; '1.11.8版本引入' escape=json '{"realip":"$remote_addr","@timestamp":"$time_iso8601"}'; --&gt;'外围单引号' 场景： nginx日志json化,方便在'es'中生成方便'检索的索引' 3) 日志格式'隐私'问题--&gt;Cookie包含很多'隐私key和value',之记录通用能'识别用户身份'的即可 4）建议变量'使用' --&gt; [$varable]的形式 5）关于'日志使用哪些变量'帮助我们'快速'判断问题,后续讲解 3） 日志显示l乱码(16进制)
json url中文编码
nginx没有开启ssl导致日志是16进制的
1）在nginx'没有开启ssl支持'的情况下,nginx将https连接建立过程中的'客户端hello报文'当作http报文处理 2）暴力的'截取'了报文中指定位置的十六进制字符串当作了$request的http请求方法、URL和版本号 3）所以access日志中会出现'十六进制'字符串 非法转义的处理
③ open_log_file_cache 了解
之前写的比较烂日志相关的博客
Logging to syslog
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41ec5e1cb6de6c94279063a588b2af5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79a828da0cd307d8f0d40eb2e01a1c5f/" rel="bookmark">
			Ubuntu server 22.04 安装kvm
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人有一台工控机， 5500u cpu， 8g 内存，本来是打算用来跑docker的， 但是因为要装
k8s, 虚拟机会更加合适方便，
宿主机的系统是ubuntu server 22.04.1 LTS, 没有安装GUI。 所以vmware virtualbox就不考虑了。 纯命令行估计kvm 会更加合适。 一台机当两三台机用了。
Step 1 检查cpu是否开启虚拟化 国际惯例， 首先检查cpu有没开启虚拟化。
现在市面上估计都买不到不支持虚拟化的cpu了， 问题是我们也要检查下bios上有没enable虚拟化特性。
gateman@homeserver2:~$ kvm-ok INFO: /dev/kvm exists KVM acceleration can be used Step 2 安装kvm sudo apt update sudo apt install qemu qemu-kvm libvirt-bin bridge-utils virt-manager 问题是 这个 libvirt-bin, 提供了virsh等命令工具帮助我们更好地管理kvm 实例。
而且比我以前用kvm时多了个系统服务libvirtd.service， 简单来讲，这个服务会用1个common的账号 libvirt 去启动kvm 实例进程。
所以我们的iso文件， 虚拟硬盘文件都必须放在能让libvirt 账号可以访问的地方。
如果是ubuntu 20.04 则有可能找不到libvirt-bin的包， 要分开安装
libvirt-daemon-system libvirt-clients 安装上面的东西后， 检查libvirtd服务有没有启动.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79a828da0cd307d8f0d40eb2e01a1c5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff0e48035e7541e5cb61ea608d69f30b/" rel="bookmark">
			WSL 可视化桌面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文目的 记录一下如何在 Windows 上可视化 Linux 子系统 (WSL)。
方法一 (Xming) Step#1:
在 Windows 系统上安装 Xming : Xming X Server for Windows download | SourceForge.net
Step#2:
安装之后运行 XLaunch：
选择 one window, display number 默认为 0:
选择 start no client
勾选 clipboard 以及 No Access Control
点击完成后出现空白 Display screen
Step#3
在 WSL 中安装必要的应用：
sudo apt-get install xfce4 sudo apt-get install xfce4-terminal Step#4
在 WSL 的 ~/.bashrc 文件中加上以下两行：
export hostip=$(cat /etc/resolv.conf |grep -oP '(?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff0e48035e7541e5cb61ea608d69f30b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44abc2e0479d908239369349e4abd1bb/" rel="bookmark">
			搜索框功能测试点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		搜索框功能测试
1.验证搜索框的功能是否与需求一致
2.查看搜索框内的默认内容是否与设置的一致，焦点放置搜索框中，搜索框默认内容是否自动被清空
3.鼠标移动到搜索框，是否有hover效果
4.输入框为空/空格/前有空格/中有空格/后有空格
5.输入超长字符，系统是否会截取允许的长度来检验结果
6.输入搜索框限制长度的字符串n个字符
7.输入限制长度的字符串n-1个字符
8.输入限制长度的字符串n+1个字符
9.输入字母/数字/文字/特殊字符，单独/组合进行搜索
10.输入敏感词汇，提示用户无权限等
11.模糊搜索（包含拼音）
12.精确搜索（包含拼音）
13.输入内容之后，默认提示消失，显示输入字符，右侧出现删除icon
14.输入内容之后，切换到其他界面，再切换回来
15.输入内容之后，光标在界面其他地方进行点击
16.反复输入相同的数据（5 次以上）看是否报错
17.输入系统中不存在的与之匹配的条件
18.输入系统中存在的与之匹配的条件,看其的查询后数据的完整性
19.使用复制粘贴，测试搜索框是否能执行
20.是否支持回车键搜索
21.点击输入框删除icon，是否可以删除
22.是否支持历史记录，便于查找检索过的内容
23.是否支持动态搜索
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/279a592dd23e13e9fbf53bab65f17642/" rel="bookmark">
			程序员专属浪漫：如何用java代码画❤️
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有位小伙伴说，看到一个帖子，一个计算机博士接亲时，要求现场写代码，5分钟做出一个爱心。我们就看看如何用java设计出心形的代码。
我找了一下，发现方法竟然很多，我们就来见识一下，最后我们看一下如何用简单的java代码实现一个心。
一.❤️的数学背景 据说，心形线起源于法国的笛卡尔，他曾认识一位瑞典小公国的公主克里斯汀，并成为了公主的数学老师，并渐渐产生爱慕之心，但是被国王阻止了（想象一段狗血的剧情）。笛卡尔被迫流放回法国，对公主日夜思念便写信，但是又怕被人看到，于是就想到了用数学公式画心形线来表白心迹。
笛卡尔的心形线是这样的：
这个心有点肥是不？看一个更广为流传的：
在坐标系中画出来是这样的：
想要个更苗条的是不：
还想要个实心的是不：
如果想要更好看的，就需要matlab等工具进行渲染了
二.java 实现❤️ 首先来一个7行就能搞定的：
public static void heart1(){ float x,y,a; for(y=1.3f;y&gt;-1.1f;y-=0.06f){ //这里的参数皆可以调，条件就是看着顺眼 for(x=-1.2f;x&lt;=1.2f;x+=0.025f){ a=x*x+y*y-1; System.out.print(a*a*a-x*x*y*y*y&lt;=0.0f?' ':'$'); } System.out.println(); } } 画出来的结果是这样的：
再来一个心中有无数爱的：
public static void heart2(){ double x,y,a; char s[]=new char[]{'I',' ','l','o','v','e',' ','y','o','u','!'}; int index=0; for(y=1.3f;y&gt;-1.1f;y-=0.06f){ index=0; for(x=-1.1f;x&lt;=1.1f;x+=0.025f){ double result=x*x+pow((5.0*y/4.0-sqrt(abs(x))),2); if(result&lt;=1){ System.out.print((s[index])); index=(index+1)%11; } else{ System.out.print(' '); } } System.out.println(" "); } } 执行之后是这样的：
怎么样，是不是程序员的专属浪漫？
三.一个双心的例子 有个小伙伴给贡献了一段代码，效果是这样的：
代码如下：
import javax.swing.*; import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/279a592dd23e13e9fbf53bab65f17642/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66edaa9b4596196f072ac92919f18001/" rel="bookmark">
			由于找不到msvcp140.dll，无法继续执行代码。重新安装可能会解决此问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		msvcp140.dll丢失的解决方法：
1、首先进入“控制面板”，
2、找到“程序”并点击，进入下一步操作；
3、然后在“程序和功能”中选择“卸载程序”；
4、接着找到Microsoft Visual...并选中；
5、最后点击“更改”并选择修复。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b5886c57cf3839bd73d5d467aa04bdb/" rel="bookmark">
			段式LCD原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近做的一款产品中涉及到段式LCD的显示，在网上查询了很多资料，这篇资料对我的帮助最大，特别搜录下来供参考。
lcd段码屏 &amp; 数码管(RT)
段码液晶屏最重要的参数：占空比、工作电压、偏压比。这三个参数都是非常重要的，都必须要满足。
驱动的方式：我们根据 LCD 的驱动原理可以知道，LCD的像素点上面只能够加上 AC的电压，LCD显示器的对比度则是由 COM脚上的电压值减去 SEG 脚上的电压值来决定，当这个电压差在大于 LCD 饱和电压时就能够打开像素点，小于 LCD 阈值电压时就能关闭像素点了，LCD 型的MCU 已经由内建的 LCD 驱动电路自动产生出LCD驱动信号了，因此只需要 I/O 口能仿真输出该驱动的信号，就能够完成 LCD 的驱动了。
段码液晶屏主要是有两种引脚，COM和SEG，和数码管比较像，但是，压差必须要是交替变化的，例：第一时刻是正向的3V，那么第二时刻就必须要是反向的3V，注意一点，如果你给段码液晶屏通直流电，那么不用多久这个屏幕就会报废，所以千万要注意.
1.段电极SEG、公共极COM
一般段码屏有段电极和公共极，就像在图中，SEG为段电极，COM为公共极。段码屏中的每个段，都填充了一种特殊的液态晶体。在电场的作用下，晶体的排列方向会发生扭转，因而改变其透光性，从而可以看到显示的内容。一般电场电压就加在段电极和公共极的两端。
2.供电电压、偏压比（偏置比）Bias、占空比Duty
（1）占空比：1根COM线在扫描过程中所占的时间，假如一共用了2根COM线，Duty=1/2，假如一共用了3根COM线，Duty=1/3，假如一共用了4根COM线，Duty=1/4。
HT1621一共可驱动4根COM，占空比 Duty 取值范围是1/2或1/3或1/4。
（2）偏压比：偏压就是用于控制液晶偏转角度的电压，HT1621的偏压比 Bias 取值范围是1/2或1/3。当供电电压为3.3V，偏压比为1/3时，求得偏压为 3.3V*（1/3）=1.1V
共阳数码管是指将所有发光二极管的阳极接到一起形成公共阳极(COM)的数码管，当某一字段发光二极管的阴极为低电平时，相应字段就点亮，当某一字段的阴极为高电平时，相应字段就不亮。共阴数码管是指将所有发光二极管的阴极接到一起形成公共阴极(COM)的数码管，当某一字段发光二极管的阳极为高电平时，相应字段就点亮，当某一字段的阳极为低电平时，相应字段就配空不亮。
3.数码管公共极的连接不同
共阳数码管在应用时应将公共极COM接到+5V，共阴数码管在应用时应将公共极COM接到地线GND上。
LCD的驱动不像LED那样，加上电压（LED实际上是电流驱动）就可以长期显示的。LCD驱动必须使用交流电压驱动才能保持稳定的显示，如果在LCD上加上稳定的直流电压，不但不能正常显示，时间久了还会损坏LCD。一段LCD由背电极和段电极组成，需要显示时， 在背电极和段电极之间加上合适的交流电压（通常使用方波）。为了调节对比度，可以 调节方波中每半个周期中显示的时间（即占空比）来实现。 通常，为了节约驱动口，将多个背电极连在一起，形成公共背电极端：COM。另外，再将属于不同COM的段电极连接在一起，形成公共段电极端：SEG。当在某个COM和 某个SEG之间加了足够的交流电压之后，就会将对应的段点亮（实际上是变黑）。 像万利的板子上使用的这种LCD，有4个COM，还有16个SEG。要想某一SEG显示时，需要在对应的SEG和COM之间加上足够的交流电压。在万利的板子上，COM驱动使用了两个电阻分压，输出电压为1/2Vcc，当不想让某位显示时，就将它的电压设置为1/2Vcc（通过 设置IO口为高阻态来完成），这样加在对应的SEG和COM之间的电压只有1/2Vcc，不足以点亮对应的SEG。需要显示的，就将COM电压设置为0或者1，这样SEG电压跟COM电压相反的段就被点亮了（变黑），因为它们之间的电压为Vcc。通过定期扫描每个COM，即可稳定的在LCD上显示需要的图形了。需要显示字符或者数字时，自己先将对应的图案设计好，在显示时，发送到相应的SEG和COM上即可。但是如果使用100%的时间都驱动的话，会造成对比度太高，甚至出现不该显示的地方也显示了。因此在显示一段时间后，就将COM和SEG都设置为低，以关闭它的显示，降低对比度。通过调节关闭时间的长短（PWM），可以调节对比度。在下面的测试程序中，为了简化程序，使用了50%固定的占空比。 为了方便描述，我们把COM为低电平时点亮叫做正亮，COM为高电平时点亮叫做负亮。扫描每个COM分成4个阶段：正亮，关闭，负亮，关闭。因此对于本板子上的LCD驱动，总共有16个状态，每个COM都有上面所说的4个状态。我们每隔2ms就切换一次状态，这样整个扫描周期就是2*16=32ms，基本上感觉不到闪烁。 但是需要注意的是，这个LCD中的每个COM并不是刚好对应着显示图案中的一个字符的位置。每个COM都对应着每个显示字符中的相同4段！换句话说，要显示第一个字符位置的字符，每个COM都要被用到。因此，要改变某个字符位置的显示，就需要改变每次COM输出时对应的SEG中的4段。为此，建立一个缓冲区，当需要修改显示字符时，就修改缓冲区中的内容。这个缓冲区有4行，每行中有16个SEG，对应着一个COM。需要修改显示时，把每行中对应的4个SEG设置为需要的值，这样就实现了某个显示位置图案的修改。 为了显示字符，需要事先把需要显示的字符按照SEG和COM的分布，制作成数据保存起来，需要显示时，就把它复制到显示缓冲区中对应的位置去。另外，由于输入的参数是字符的ASCII码，因此还需要将ASCII码转换为对应的字符图案的索引值。使用一个专门的函数来完成这些转换和 填充缓冲区，在需要修改显示数据时，就调用该函数。 为了方便大家对这个LCD的驱动方式和编程，下面简单的画一下驱动的波形图。 这里只画出2个SEG波形图，实际有16个SEG，只要你理解了2个SEG的，那么16个的也是一样的意思。如图所示，所有偶数阶段都是关闭显示阶段，这时COM和SEG都是0，将不会有段被点亮，通过调节关闭显示阶段所占的时间百分比，即可调节总体显示的对比度。SEG和COM之间电平相差1格的显示不出来或者浓度不够，而SEG和COM之间电平相差2格的则可以显示出来或者浓度较深。例如第一阶段中的SEG1和COM1之间相差2格，第三阶段中COM1和SEG1相差2格，因而SEG1和COM1之间的交叉点（即点1）被显示。又如第九阶段的SEG1和COM3之间相差2格，第十一阶段中的COM3和SEG1之间相差2格，因而SEG1和COM3之间的交叉点（即点5）被显示出来。其它点以此类推。
最后，再来看看万利板子上的LCD的COM和SEG之间的关系图，如下图所示。
图中显示，S0、S1、S2、S3属于第一个字符，在显示第一个字符时，只要在对应的COM选中时，将需要显示的SEG放在上面即可。其余几个字符类似。例如要显示一个数字3，则应该将A段、B段、C段、D段、G段、K段显示。某段显示，用1表示，不显示用0表示，得到的各段值如下：
X=0 I="0" A="1" DP="0"
F=0 H="0" J="0" B="1"
E=0 G="1" K="1" C="1"
L=0 M="0" N="0" D="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b5886c57cf3839bd73d5d467aa04bdb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1728a3fba723b8da813b9dbb15f4e6c6/" rel="bookmark">
			IOS逆向-入门篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		教程 JailBreak爱思助手unc0ver JailBreak-BypassOpenSSHnetstat命令Frida安装旧版本修改端口 抓包获取APP BundleID逆向系统Framework JailBreak 爱思助手 下载爱思助手并打开软件，使用USB连接IPhone确认设备连接成功后，点击 工具箱-&gt;一键越狱勾选unc0ver，点击开始越狱输入APPLE ID和密码，点击确定即可在手机界面找到unc0ver app,左上角设置: 选择安装openssh和cydia, 点击jailbreak等待重启即可重启后如果能打开cydia即jailbreak成功 unc0ver 下载 AltStore(https://altstore.io/)点击菜单栏的App图标-&gt; 点击Install altstore -&gt; 选择IPhone -&gt;登陆AppleID安装Mail plugin -&gt; 打开邮件应用App -&gt; 登陆AppleID邮件(保持打开)-&gt; 偏好设置-&gt; 管理插件 -&gt;允许勾选-&gt;重启邮件、AltStore重新执行步骤2手机侧: 安装成功后-&gt;点击信任App下载unc0ver,用手机safari打开 https://unc0ver.dev/重启手机再打开uncOver 注意
MAC登陆的AppleID、邮件登陆的AppleID、AltStrore输入的AppleID以及手机的AppleID必须一致，并且必须保持登陆状态
参考
“Could not connect to Mail plug-in"
JailBreak-Bypass 越狱反检测插件
打开Cydia添加软件源: https://apt.wxhbts.com搜索HideJB或者FlyJB打开手机设置-&gt; 往下滑动找到HideJB -&gt; 选择应用
注意: 需要打开Substitute的Enable Tweak Injection开关 OpenSSH 打开Cydia点击软件源/变更点击刷新/更新安装OpennSSH默认密码: alpine netstat命令 Network Commands插件
在越狱ios系统中使用netstat命令，如果提示该命令不存在时，则需要在cydia中安装Network Commands插件。
打开cydia搜索"Network Commands"安装插件 Frida 打开Cydia添加软件源: https://build.frida.re搜索Frida安装测试命令: frida-ps -U 安装旧版本 Github上下载frida-1.1.1-iphoneos.debscp传输到手机上安装 dpkg -i frida-1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1728a3fba723b8da813b9dbb15f4e6c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b50fc4d36d5ec24973ab16ceea1bfec8/" rel="bookmark">
			Oracle rman定时备份策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、备份脚本 &lt;1&gt;.0级备份 vim level0_backup.sh
#!/bin/bash # .bash_profile # Get the aliases and functions if [ -f ~/.bashrc ]; then . ~/.bashrc fi # User specific environment and startup programs PATH=$PATH:$HOME/bin export PATH export ORACLE_SID=orcl export ORACLE_BASE=/u01/app/oracle export ORACLE_HOME=$ORACLE_BASE/product/11.2.0/db_1 export PATH=$PATH:$ORACLE_HOME/bin dateTime=`date +%Y-%m-%d` rman cmdfile=/u01/app/ora_backup/backup_scripts/level0_backup.rcv msglog=/u01/app/ora_backup/backup_logs/level0_${dateTime}.log vim level0_backup.rcv
connect target sys/***@orcl run{ crosscheck backup; crosscheck archivelog all; delete noprompt obsolete; delete noprompt expired backup; allocate channel d1 type disk; allocate channel d2 type disk; backup incremental level 0 as compressed backupset database format '/dbbak/backup/LEVEL0/level0_%d_%s_%p_%u.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b50fc4d36d5ec24973ab16ceea1bfec8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fd61a65525c7e76f389396f5a35661b/" rel="bookmark">
			搜索与回溯算法 C&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 1347: 八皇后
#include&lt;iostream&gt; using namespace std; const int N=200; int c[N],dg[N],udg[N];//c为行，f为对角线，s为反对角线 int n,sum=0; //sum几种答案 int ans[N];//保存路径 void dfs(int u) { if(u&gt;n) { if(sum&lt;3) //只输出前3个 { for(int i=1;i&lt;=n;i++) { cout&lt;&lt;ans[i]&lt;&lt;" "; } cout&lt;&lt;endl; } sum++; //可行方案+1 return ; } for(int i=1;i&lt;=n;i++) //枚举 { if( !c[i] &amp;&amp; !dg[u-i+n] &amp;&amp; !udg[u+i] ) //如果都没有标记，执行 { c[i]=dg[u-i+n]=udg[u+i]=1; //标记 ans[u]=i ;//赋值 dfs(u+1);//递归到下一层 c[i]=dg[u-i+n]=udg[u+i]=-0; //回溯 } } } //搜索 int main() { cin&gt;&gt;n; dfs(1); cout&lt;&lt;sum; return 0; } 此题枚举与标记不清楚的思路主要在:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1fd61a65525c7e76f389396f5a35661b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94a5e8a344c444b2892114a231703745/" rel="bookmark">
			apache编译安装httpd-2.4.54
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大佬写的保姆级
无敌
https://www.cnblogs.com/tushanbu/p/16473452.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c99eccc8e15f95f2c3f367daddd2037e/" rel="bookmark">
			selenium使用cookie管理进行免密登录博客园
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 cookie管理cookie原理cookie应用场景cookie的方法实例 cookie管理 cookie原理 ​ 对于页面来说，正常我们输入用户名和密码后，服务端会生成对应的token或者session，随着接口返回token和session，页面将数据保存在cookie中
cookie应用场景 ​ 对于有些页面进行登录除了需要输入用户名和密码外还需要进行滑块验证等，这就能体现出cookie的好处了
cookie的方法 ​ 在了解cookie的原理后，我们知道登录后我们客户端会生成cookie保存用户信息，所以我们在selenium的方法中就有我们的get_cookies方法进行cookie的信息获取，等打开新页面后我们要实现登录，只要把对应cookie添加到浏览器中即可，所以有我们的add_cookie方法
实例 以我们博客园1为例
from selenium import webdriver from selenium.webdriver.common.by import By driver = webdriver.Chrome() driver.maximize_window() driver.get('https://www.cnblogs.com/') driver.find_element(By.LINK_TEXT,'登录').click() time.sleep(20) #获取登录后的cookie信息并保存在list变量中 list = driver.get_cookies() driver = webdriver.Chrome() driver.maximize_window() driver.get('https://www.cnblogs.com/') #清除新打开浏览器的所有cookie信息 driver.delete_all_cookies() for i in list: #增加过期时间的判断防止添加过程中出现失效情况 if 'expiry' in i: del i['expiry'] #正常我们操作只需要传入name和value即可 driver.add_cookie(i) driver.refresh() print ("#######################################") print (driver.get_cookies()) time.sleep(10) PS：配套视频大家可以查看：https://space.bilibili.com/432730836/
博客园这个比较特殊，正常我们在页面操作过程中只需要传入name和value值就好了，但是博客园不行需要除了expiry字段外所有的信息都要传入，否则无法登录，所以我们要在一种方法不行的情况下多尝试一下其他方法 ↩︎
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8381ab7631883567bf4681ea1aad988/" rel="bookmark">
			CLIPstyler: Image Style Transfer with a Single Text Condition(2022 CVPR)（单文本风格转换）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.CLIPstyler: Image Style Transfer with a Single Text Condition(2022 CVPR)（单文本风格转换）
机构：Dept. of Bio and Brain Engineering1, Kim Jaechul Graduate School of AI2, KAIST
2.GitHub地址：https://github.com/cyclomon/CLIPstyler
3.介绍和摘要：
我们提出了一个新的框架，该框架可以 “不带” 样式图像进行样式转换，只使用所需样式的文本描述。使用预训练文本图像嵌入模型CLIP，我们演示了仅在单个文本条件下对内容图像样式的调制。具体来说，我们提出了一种具有多视图增强功能的补丁式文本图像匹配损失，以实现逼真的纹理传输。
摘要：
现有的神经样式转换方法需要参考样式图像来将样式图像的纹理信息转换到内容图像。但是，在许多实际情况下，用户可能没有参考样式图像，但仍然对仅通过想象样式来转移样式感兴趣。为了处理此类应用程序，我们提出了一个新的框架，该框架可以 “不带” 样式图像进行样式传输，但只能使用所需样式的文本描述。使用剪辑的预训练文本图像嵌入模型，我们演示了仅在单个文本条件下对内容图像样式的调制。具体来说，我们提出了一种具有多视图增强功能的补丁式文本图像匹配损失，以实现逼真的纹理传输。广泛的实验结果证实了具有反映语义查询文本的逼真纹理的成功图像样式传输
4.method
我们框架的目的是通过预先训练的文本-图像嵌入模型CLIP 将目标文本tsty的语义样式转移到内容图像Ic。与现有方法的主要区别在于，在我们的模型中，没有样式图像可作为参考。
我们有几个技术问题需要解决：
1）如何从 CLIP 模型中提取语义“纹理”信息并将纹理应用于内容图像.
2）如何对训练进行正则化，以使输出图像不受到质量损害.
我们引入了一个 CNN 编码器-解码器模型 f，它可以捕获内容图像的层次视觉特征，同时在深度特征空间中对图像进行风格化，以获得逼真的纹理表示。因此，我们的风格化图像 Ics 为 f(Ic)，我们的最终目标是优化 f 的参数，使其输出具有目标纹理。
5.Loss function 为了引导内容图像遵循目标文本的语义，最简单的基于 CLIP 的图像处理方法 是最小化全局CLIP损失函数
CLIP loss:
其中 是 CLIP 空间余弦距离。该损失函数将整个输出图像转换为遵循文本条件的语义。然而，当使用这种全局 CLIP 损失时，输出质量往往会受到破坏，并且在优化过程中稳定性较低.
为了解决这个问题，StyleGAN-NADA 提出了一种定向 CLIP 损失，它将源和输出的文本图像对之间的 CLIP 空间方向对齐。因此，我们也采用了定向 CLIP 损失。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8381ab7631883567bf4681ea1aad988/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9912b70f0620399f040123230b463939/" rel="bookmark">
			新版androd studio怎样连接第三方模拟器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 大家在做Android开发的时候都会用模拟器进行启动开发，AS自带的模拟器太慢，而且无法连接网络（其实是我不会哦！），在学习过程中，老师让做一个网页，点击按钮就可以跳转到百度，由于AS自带模拟器未联网，所以没有出结果，我改用MUMU模拟器。但有的时候开启AS后无法连接找到模拟器，可以通过以下方法进行启动，避免了再次重启模拟器的麻烦。
我们需要先开启MUMU模拟器，再开启Android studio
在我们没有进行连接时是没有MUMU模拟器的
二、开始连接MUMU模拟器
1.我们需要找到我们的MUMU模拟器根目录路径
依次打开你安装MUMU模拟器的磁盘/首个文件夹的名字/之后按照红框里的内容依次点击最后进入bin目录下
这个即为我安装MUMU模拟器的完整路径
2.开始配置
1）点击win+r
2) 输入cmd,点击确定。
3）输入mumu模拟器的根目录
注意：我的MUMU模拟器是放在G盘，但cmd一开始显示的是C盘，所以先要找G盘的位置（具体看你的软件放那个盘以此类推），找到G盘后，搜索目录前记得加"cd"
依次一个一个的输入mumu模拟器的目录
如下图：
之后我们输入：adb_server.exe connect 127.0.0.1:7555 附：
夜神模拟器：adb connect 127.0.0.1:62001
逍遥安卓模拟器：adb connect 127.0.0.1:21503
天天模拟器：adb connect 127.0.0.1:6555
海马玩模拟器：adb connect 127.0.0.1:53001
网易MUMU模拟器：adb connect 127.0.0.1:7555
原生模拟器：adb connect (你的IP地址)：5555
4）回到AS查看是否有mumu模拟器的选项
这个即为 mumu模拟器，我们点击就可以使用了!
三、电脑桌面启动MUMU模拟器的快捷方式
1.我们需要找到我们的MUMU模拟器根目录路径
里面有如上三个文件，我们在其中创建文本文档(mumu.txt），写入adb_server.exe connect 127.0.0.1:7555，修改文件名mumu.bat(后缀改为bat)另存为根目录，在创建快捷方式!
2.我们需要创造桌面快捷方式
把上面的mumu.bat快捷方式发送到桌面
当无法连接MUMU模拟器时，切记需要先打开Android studio，再打开MUMU模拟器，最后双击该文件就可以连接了。
江湖路远，让我们顶峰相见！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e11a66ab6419830d713dad6ec6891734/" rel="bookmark">
			Android 查看并解决重复依赖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接
exclude group: ‘com.squareup.okhttp3’
exclude group: ‘com.squareup.okio’
exclude group: ‘com.google.code.gson’
//exclude(module: ‘gson’) // 防止版本冲突
}
Android 获取所有依赖库的几种方式
方式一：通过 dependencies 命令
./gradlew :app:dependencies
注意：这里的 app 是指工程下的 app 目录，如果你工程下没有 app 而是别的目录，要把这个 app 改为你的工程实际目录名字。
该 task 会显示如下所示的输出：
输出列表展示了所有 configuration 下的依赖树，依赖关系明显，层次清晰。如果觉得输出的结果太冗长 (通常情况下包含几十个 configuration)，可以通过指定 configuration 来显示特定的依赖树:
./gradlew :app:dependencies --configuration releaseCompileClasspath
该命令只会显示 release 模式下编译过程中的依赖树。
方式二： 通过 androidDependencies 命令
./gradlew :app:androidDependencies
输出结果如下：
图所示，该 task 会平铺展示依赖树，并且只展示几个主要的 variant，看起来较为清爽，但是缺点是不能像方式一那样指定 configuration。
方式三：自定义 task 获取
project.afterEvaluate { project.android.applicationVariants.all { variant -&gt; tasks.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e11a66ab6419830d713dad6ec6891734/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e08b443babacd07cc5ea30a69add0e1/" rel="bookmark">
			python3--socket编程(tcp协议)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		socket概念
socket层
理解socket
Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议
简单来说
其实站在你的角度上看，socket就是一个模块。我们通过调用模块中已经实现的方法建立两个进程之间的连接和通信。 也有人将socket说成ip+port，因为ip是用来标识互联网中的一台主机的位置，而port是用来标识这台机器上的一个应用程序。 所以我们只要确立了ip和port就能找到一个应用程序，并且使用socket模块来与之通信。 套接字（socket）的发展史
套接字起源于 20 世纪 70 年代加利福尼亚大学伯克利分校版本的 Unix,即人们所说的 BSD Unix。 因此,有时人们也把套接字称为“伯克利套接字”或“BSD 套接字”。一开始,套接字被设计用在同 一台主机上多个应用程序之间的通讯。这也被称进程间通讯,或 IPC。套接字有两种（或者称为有两个种族）,分别是基于文件型的和基于网络型的
基于文件类型的套接字家族
套接字家族的名字：AF_UNIX
unix一切皆文件，基于文件的套接字调用的就是底层的文件系统来取数据，两个套接字进程运行在同一机器，可以通过访问同一个文件系统间接完成通信
基于网络类型的套接字家族
套接字家族的名字：AF_INET
(还有AF_INET6被用于ipv6，还有一些其他的地址家族，不过，他们要么是只用于某个平台，要么就是已经被废弃，或者是很少被使用，或者是根本没有实现，所有地址家族中，AF_INET是使用最广泛的一个，python支持很多种地址家族，但是由于我们只关心网络编程，所以大部分时候我么只使用AF_INET)
tcp协议和udp协议
.TCP（Transmission Control Protocol）可靠的、面向连接的协议（eg:打电话）、传输效率低全双工通信（发送缓存&amp;接收缓存）、面向字节流。使用TCP的应用：Web浏览器；电子邮件、文件传输程序。
UDP（User Datagram Protocol）不可靠的、无连接的服务，传输效率高（发送前时延小），一对一、一对多、多对一、多对多、面向报文，尽最大努力服务，无拥塞控制。使用UDP的应用：域名系统 (DNS)；视频流；IP语音(VoIP)
套接字（socket）初使用
基于TCP协议的socket
tcp是基于链接的，必须先启动服务端，然后再启动客户端去链接服务端
windows如果不通，注意关闭防火墙
server端
import socket sk = socket.socket() # 实例化一个对象sk sk.bind(('192.168.11.224', 8989)) # 把地址绑定到套接字 sk.listen() # 监听链接 conn, addr = sk.accept() # 接收客户端链接 print(addr) # 打印出客户端的地址+端口 conn.send('hello'.encode('utf-8')) # 向客户端发送信息 ret = conn.recv(1024) # 接收客户端信息(1024字节) print(ret.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e08b443babacd07cc5ea30a69add0e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d5ba020666daec7d7e7e6003d702fbd/" rel="bookmark">
			Centos8界面语言怎么设置? Centos用户界面语言的设置方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Centos8怎么给用户设置界面语言？想要设置界面语言，该怎么设置呢？下面我们就来看看详细的教程。
1、Gnome桌面环境下，在桌面空白处右键选择【设置】。
2、在【设置】中点【详细信息】。
3、之后点【用户】。
4、首先单击选中要设置的用户，默认用户语言设置处为灰色，需要点右上角的【解锁】，输入管理员密码获得权限才可以设置。
5、获得权限后点【语言】。
6、在弹出的语言界面，选择相应的语言即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1948cbc976a6d2aeb3fc0e08c2635fb0/" rel="bookmark">
			如何在nginx中配置静态资源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2.在nginx中配置静态资源 ​ 在nginx中配置静态资源首先要保证你的项目是通过nginx来访问网关请求请求的！，因为静态资源是保存在nginx中的，可以大大的减少运行速度！
​ 首先，我们需要将静态资源导入到nginx中 譬如：你现在有一个静态资源的文件夹！包含你项目的所有静态资源，将其放入到nginx下的HTML文件夹下
其次，进入conf.d的文件夹下，修改gulimall.conf的配置
在此处加上：
location /static/ { root /usr/share/nginx/html; } 使得所有/static/下的所有文件都走下面的路径
注意：这里的 /usr/share 不是文件路径，而是nginx的内部路径，也就是挂载路径;根据一下命令可自行查看！
docker exec -it nginx /bin/bash 最后需要改一下自己项目中静态资源引用的地址，如：
记住，必须保证自己的static文件夹下有该文件！
完工！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c497a0547e1385f1c0309f4bfe7b8c63/" rel="bookmark">
			【Python】使用Geopy的geocoders模块，通过经纬度获取 城市信息及地区的邮编
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Geopy的geocoders模块通过经纬度获取邮编 Geopy库简介安装 Geopy导入模块基本用法通过经纬度查询城市信息及邮编 Geopy库简介 Geopy是Python的一个用于地理编码的库，通过这个库能够定位世界各地的地址、城市、国家和地标的坐标及信息。
Geopy作为一个专注于地理位置处理包，能实现地理编码、逆地理编码功能；此外，还可以根据两个经纬度坐标计算在地球上的最短距离。
安装 Geopy 在终端中运行pip进行安装。
pip install geopy 导入模块 # 导入geocoders模块 from geopy.geocoders import Nominatim 基本用法 使用地理编码功能时，需要借助Geopy中的geocoders模块。
例如：选用 OpenStreetMap 平台上提供的 Nominatim 地理编码器，因为可以免费供我们使用，不需要申请 API ，但缺点是限流，限额，不能大规模频繁访问，否则会返回 403，429错误代码
from geopy.geocoders import Nominatim geolocator = Nominatim() location = geolocator.geocode("上海市静安区") print(location.address) # 地址信息 print(location.latitude,location.longitude) #经纬度 通过经纬度查询城市信息及邮编 reverse 方法接收经纬度字符串作为输入，返回的值是所在地的信息，其中包含邮编。
from geopy.geocoders import Nominatim # 初始化api geolocator = Nominatim() # 邮编 place = "40.056793 116.305811" location = geolocator.reverse(place) # 纬度在前，经度在后 # 获得数据 data = location.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c497a0547e1385f1c0309f4bfe7b8c63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e036d9d4c789f5c09f7824ae359902ce/" rel="bookmark">
			C&#43;&#43;：函数：回调函数：还不懂回调函数来捶我
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 不知道你是否有这样的疑问，我们为什么需要回调函数，直接调用函数不就可以了吗？回调函数到底有什么用？程序员该如何理解回调函数了？
这篇文章就为你解答这些问题，读完这篇文章后，你的编程技术将得到质的提高。
同步调用 做一件事情，程序员传统并且最熟悉思维模式一般是这样：
调用某个函数，获取结果处理获取到的结果 result = request()
handles(result)
如果 request()函数是同步调用，只有request()函数返回拿到结果后，才能调用handle函数进行处理，request()函数返回前我们必须等待，这就是同步调用，控制流程就是这样的
异步调用 但是如果我们想更加高效的话，那么就需要异步调用了，我们不去直接调用handle函数，而是作为参数传递给 request()
request(handle) 所以，我们根本不关心request什么时候真正的获取结果，这是request该关心的事情，我们只需要把获取到的结果，该怎么处理告诉request就可以了，因此 request函数可以立即返回，真正获取结果是可能在另一个线程，进程，甚至另一台机器上完成，这就是异步调用。
从编程思维上看，异步调用和同步有很大的差别，如果我们把处理流程当做一个任务来的话，那么同步流程下，整个任务都是我们实现的，但是异步流程情况下：任务的处理流程被分为两部分：
第一部分，我们处理，也就是调用 request函数之前的部分。第二部分：不是我们处理的，而是在其他线程、进程或者另一台机器完成 重点来了：
第二部分的调用不在我们控制范围内，同时只有调用方才知道该做什么，什么时候调用，因此在这种情况下，就需要一种必要的机制-------》这个机制就是回调。
在java/Android中，我们通常定义一个接口，然后我们实现这个接口，将接口类型作为参数传给服务方，然后服务方自己决定什么时候去调用这个接口的函数（这个接口函数是我们客户端实现的）.在C++中没有Java这种类似的接口函数回调，但是C++中有函数指针这个概念，它可以做为参数传给服务端，同样也可以起到和 java类似的功能效果。 回调函数正式定义 回调函数就是一个函数和其他函数没有任何区别。
一般函数：我们自己编写函数会在自己的程序内调用，也就是说函数的编写放方式我们自己，调用方也是我们自己
回调函数：编写方是我们自己，但是函数调用方不是我们，而是我们引用的其他模块，也就是三方库，我们调用第三方库中的函数，并把回调函数传递给第三方库，第三方库中的函数调用我们编写的函数。
回调函数实际应用：（回调函数作为事件处理函数） 如上图所示：我们抽象出这样一个模型：主应用程序--------库函数--------回调函数。库函数是不知道某个节点（或者业务完成之后在去做什么）。例如接收到 网络数据、文件读取完成之后，该做什么这些只有库的使用者才知道，设计编写库的作者并不知道，也无法针对主应用程序编写具体代码，只能对外提供一个回调函数(声明一个回调函数)，库的使用方来实现该函数（定义该函数），库在特定的时机，特定的节点回调该函数就可以了。我们在抽象一下：如果把接收网络数据，文件读取看做是事件也就是 event， 那么本质上我们编写的回调函数就是用来处理Event的，因此从这个角度看回调函数不过就是 event handler ，因此回调函数天然适用于 事件驱动编程 event--driven 。 同步回调 这种回到就是常说的同步回调 synchronous callbacks 、也有将其称为阻塞式回调 blocking callbacks ，或者什么修饰都没有，就是回调callback ，这是我们最熟悉 的回调方式。当我们调用某个函数A并以参数的形式 传入回调函数后，在A返回之前 回调函数会 被执行，也就是 说我们的主程序会等待回调函数执行完成，这就是同步回调。 异步回调 不同于同步回调，当我们调用某个函数A并以参数的形式传入回调函数后，A函数立即返回，也就是函数A并不会阻塞我们的主程序，一段时间后回调函数开始被执行，此时我们的主程序可能在忙其他任务，回调函数的执行 和我们主程序的运行同时进行。既然我们的主程序和回调函数的执行可以同时发生 ，因此一般情况下，主程序和回调函数的执行位于不同的线程或者进程中。 这就是所谓的异步回调，asynchronous callbacks ，也有资料称为 deferred callbacks ，名字很形象，延迟回调。
回调对应的编程思维模式 假设我们向处理某项任务，这项任务需要依赖某项服务S，我们可以将任务的处理分为两部分，调用服务S的前部分 PA ，调用服务S后面部分为 PB。常规模式 下，PA和PB都是服务调用方执行，也就是我们自己的主程序执行 PA，等待服务S返回后再执行PB部分。回调模式下：PA是服务调用方执行，也就是我们自己 的主程序执行PA，等待服务S返回后，服务S在去调用PB.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e036d9d4c789f5c09f7824ae359902ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/192a18e3b708029d4ffc417db325db74/" rel="bookmark">
			解决 Compilation of Maven projects is supported only if external build is started
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IEDA问题： Compilation of Maven projects is supported only if external build is started
解决方法： 设置好配置就行，setting.xml
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fd15754bc1de79b98a357659d015b02/" rel="bookmark">
			【FileZila】实现windows与Linux系统文件互传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、下载安装FileZila客户端
根据自己的PC系统版本，下载对应的FileZila客户端https://www.filezilla.cn/download/client
2、Linux服务端，安装配置vsftpd
2.1 安装ftp服务
sudo apt-get install vsftpd 2.2 配置ftp服务
（1）打开ftp服务配置文件
sudo vi /etc/vsftpd.conf （2）跳转到30行附件，取消write_enable的#注释符
（3）重启ftp服务
sudo /etc/init.d/vsftpd restart 4、查看linux端IP地址
ifconfig 5、配置FileZila客户端，连接Linux端ftp服务器
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f559db592bd2d3636dff90af7b68864/" rel="bookmark">
			vue3 斗兽棋游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近来掘金举办前端比赛，所以写了一个小游戏参加，而且熟悉一下vue3,写了一下游戏，思来想去就写了一个斗兽棋游戏。
欢迎去给我加油 点赞评论收藏 ，试玩地址 游戏地址 童年斗兽棋 - 码上掘金
https://code.juejin.cn/pen/7168678657873969160 进入有点击右上方 ‘运行’
下面写一下思路
斗兽棋上下各八个棋子，一个16位置的格子，本来用一个数组写出来，后来想起需要空位，还有棋子跳转路径规则，所以设置了以下结构
dataList: [ { index: 0,//当前位置 ruleval: [1, 4],//规则 carStutas: false,//当前位有牌 }, { index: 1, ruleval: [0, 2, 5], carStutas: false,//当前位有牌 }, 然后设置每个棋子信息
{ 'id': i, //每个id 'Ranking': i, //棋子的权重 'url': "http://www.jmyuyu.cn/demo/img/b" + i + ".png",//棋子图片 'rote': false,//是否已经翻牌 'Belonging': 'blue',//所属蓝方 'colorStutas': false,//显示选中的图标 } 然后设置图片 图片为两张图片 第一张为背面 第二张为棋牌
最重要的是css 点击后两张翻转180度 第一张用到了一个 backface-visibility: hidden;，，此为翻转后消失的css.注意背面的棋牌需要先翻转180，这样转过来正好是正面。
然后翻牌
// 判断翻牌 const flop = (item) =&gt; { if (infor.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f559db592bd2d3636dff90af7b68864/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67d8ba3ce52443f613f1db4cad4fb6f3/" rel="bookmark">
			镜头眩光如何避免 镜头眩光避免方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在拍照过程中偶尔会需要在逆光背景下拍摄，而逆光拍摄可能会产生一些和光圈实际形状一致的光斑，我们称之为炫光。那么该如何有效地避免镜头炫光呢?一起来看看。
一. 什么是镜头眩光
当光源直射入镜头，但没有出现在照片上时，会在照片上看到起雾的现象。这种光雾会降低照片对比度和饱和度，黑暗的部分也会亮起来。如果光源也出现在照片上，就会看到不希望出现的“光线”，就像从光源到相机之间连接的一条“光路”。这些现象是由于光线在镜头内部的扩散和反射造成的。所以变焦镜头上 出现眩光的情况比定焦镜头要严重，因为前者拥有更多的光学元件，光的扩散和反射都更多。
不过不要误会，眩光其实也可以成为摄影中有用的工具。在拍摄晴天下的人物，或者lomo效果时，就很有用。但同时，眩光也可能成为严重的问题。拍摄角度可能会在照片上引起强烈的光雾，甚至连Photoshop都无可奈何。这时就该镜头遮光罩上场了。
二.遮光罩
遮光罩应该是每一个摄影师包中的必备，无论是职业摄影师、业余爱好者还是初学者。遮光罩可以有效减少不想要的眩光，放过想要的。
不过遮光罩也有很多种，特别是佳能的。事实上，佳能(美国)网站上说他们提供40——没错，40——种不同类型和尺寸的遮光罩。别忘了镜头也是有不同尺寸的，每一支都要配特定尺寸的：46mm、49mm、52mm、55mm、58mm、62mm、67mm、72mm、以及77mm，其中58mm是最流行的。
总之，并不需要这么多特制的遮光罩。只需要最普通的就好，通常是橡胶做的，不像特制遮光罩通常用特殊塑料制造。
三. 如何使用
大多数遮光罩，可以拧在镜头或滤镜上。装上遮光罩之后，看看取景器，确认遮光罩不会遮住取景框。如果用超广角镜头和一个长遮光罩，画面四周就会出现暗角。这种情况只出现在同时使用长遮光罩和广角镜头时。即使已经装了遮光罩，眩光还是不会完全消除。对着太阳试拍几张，但是不要把太阳摄入画面，现在眩光的影响就几乎为0了。
四. 有用的提示
1. 使用遮光罩。用遮光罩总是有用的。
2. 减少光线通过的玻璃元件数量。摘掉镜头前的滤镜。尽量用定焦镜头代替变焦镜头。
3. 调整光圈。不同的光圈值会产生不同的眩光。
变焦镜头的广角端产生的眩光比长焦端更严重。
以上就是我介绍的“如何避免镜头眩光，镜头眩光怎么办”，希望能给你帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/632fa2a76629814274b72dd42ea37417/" rel="bookmark">
			The project in using an incompatible version(AGP 7.3.0) of the Android Gradle plugin Latest support
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		The project in using an incompatible version(AGP 7.3.0) of the Android Gradle plugin Latest supported version is AGP 7.2.2
红色方框里我刚从远程仓库下在下别人的项目时写的是version 7.3.0，应该是版本太高了，查了查资料说是7.2.1是稳定版，就改成了7.2.1，然后刷新同步就解决这个报错了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/042f9bb4bd4252a39a3b851c34ee75fd/" rel="bookmark">
			迭代器内容详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 迭代器可迭代对象创建迭代器迭代器应用场景 迭代器 可迭代对象 迭代器是实现迭代器协议的对象，它包含__iter__()和___next_()方法，我们常见的可迭代对象有列表、元组、字典，字符串,我们可以从这些迭代对象中获取迭代器，从而进行迭代
生成迭代器实例
list =["iterable","tuple"] #生成迭代器 l = next(list) #使用next进行迭代 next(l) 遍历可迭代对象
multi = ("a", "b", "c") for x in multi: print(x) #实际上也是生成了迭代器，然后执行next方法 创建迭代器 class MyNum: def __iter__(self): self.num=1 #生成迭代器对象返回self本身 return self def __next__(self): self.num+=1 #next方法获取迭代的对象值 return num #生成迭代器对象 a= iter(MyNum()) #next方法进行迭代 next(a) next(a) 迭代器应用场景 ​ 迭代器最核心的功能就是通过next()函数的调用返回下一个函数值，它是可以通过程序按照规律来进行生成，不用依赖已有的集合（列表、字典等），也就是不用缓存数据节省内存空间。
​ 我们的斐波那契数列1我们就可以用迭代器来实现
class MyNum: def __iter__(self): self.a =0 self.b =1 return self def __next__(self): self.num = self.a+self.b self.a= self.b self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/042f9bb4bd4252a39a3b851c34ee75fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f368901fab2f735c8ed6df90bb268a53/" rel="bookmark">
			VScode格式化代码换行问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意：应该是去更改vetur的默认代码 我是安装这个插件了
之前格式化之后会变成这样
少了还好 标签一多 找的时候就特别麻烦，下边的办法就是解决这个问题的
附：修改后的效果图
1、打开文件 首选项 设置 点击右上角的文档图标
2、随便找个地儿加上这段代码 "vetur.format.defaultFormatterOptions": { "js-beautify-html": { "wrap_line_length": 120, "wrap_attributes": "auto",//代码换行模式 auto force force-aligned force-expand-multiline "end_with_newline": false } }, 3、保存就可以了 附带几个模式效果图
auto
force
force-aligned
force-expand-multiline
选自己喜欢的用吧
解决你的问题了吗
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a9b45962c0b9d9242c5ecbbcd5c1c0a/" rel="bookmark">
			ping windows电脑无法ping通的命令行处理办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ping windows电脑无法ping通的命令行处理办法
管理员身份运行cmd，输入以下命令
打开回显
netsh firewall set icmpsetting 8 关闭回显
netsh firewall set icmpsetting 8 disable 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9faf59596325ebc7dbd74c311b1f74ac/" rel="bookmark">
			git 的批量克隆 批量切换分支 批量pull
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		批量克隆 将cloneList.txt和git_clone_batch.bat两个文件，放到用于存放项目的根目录。
在cloneList.txt文件中维护需要批量克隆的http地址，每行一个项目地址。注释用#开头。
双击执行git_clone_batch.bat，则会进行批量克隆项目，若项目已存在，命令会提示已存在该项目，会继续执行下一条命令。
cloneList.txt文件内容示例如下
# 若不指定分支，则下载该项目的默认分支 "git项目的http地址" # 下载指定分支的代码 #-b "分支名" "git项目的http地址" git项目的http地址如下
git_clone_batch.bat脚本内容如下
::for loop test chcp 65001 @echo off for /f delims^=^ eol^=^# %%c in (cloneList.txt) do git clone %%c pause 批量更新 将git_pull_batch.bat文件，放到用于存在项目的根目录，双击执行，则会对该目录下所有项目执行git pull 操作。
PS：使用前应先确认项目是否有未提交的代码，避免存在冲突的情况。
@echo off chcp 65001 for /d %%i in (*) do ( if not %%i==[Filter] ( if exist "%~dp0%%i\.svn\" ( echo 正在更新svn项目 %%i @cd %cd%\%%i &amp;&amp; @svn update ) else if exist "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9faf59596325ebc7dbd74c311b1f74ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1662b44569b8333cbe2cffc1e027e36a/" rel="bookmark">
			apisix健康检查测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		健康检查简介 健康检查的目的是动态地将上游服务器标记为健康或不健康的状态。开启健康检查功能后，当后端某台上游服务器健康检查出现异常时，负载均衡会自动将新的请求分发到其它健康检查正常的上游服务器上；而当该上游服务器恢复正常运行时，负载均衡会将其自动恢复到负载均衡服务中。
如果业务对负载敏感性高，高频率的健康检查探测可能会对正常业务访问造成影响。可以结合业务情况，通过降低健康检查频率、增大健康检查间隔、七层检查修改为四层检查等方式，来降低对业务的影响。但为了保障业务的持续可用，不建议关闭健康检查。(http健康检查是一种比较精确地检查服务是否正常的情况，因为只是做端口探测的话，如果服务僵死了，端口还是探测得通的)
nginx的健康检查 nginx是没有针对负载均衡后端节点的健康检查的，但是可以通过默认自带的ngx_http_proxy_module和ngx_http_upstream_module模块中的相关指令来完成：当后端节点出现故障时，自动切换到健康节点来提供访问。
nginx自带健康检查的缺陷：
1、nginx只有当有访问时后，才发起对后端节点探测。
2、如果本次请求中，节点正好出现故障，Nginx依然将请求转交给故障的节点,然后再转交给健康的节点处理。所以不会影响到这次请求的正常进行。但是会影响效率,因为多了一次转发
3、自带模块无法做到预警
4、被动健康检查
nginx’自带’的check模块相对来说比较"粗糙",推荐使用’淘宝技术团队’开发的nginx_upstream_check_module
特点：
1、‘主动’地健康检查,nignx’定时’主动地去ping后端的服务列表；
2、当发现某’服务出现异常’时，把该服务从健康列表中’移除’；
3、当发现某服务’恢复’时,又能够将该服务’加回’健康列表中；
nginx_upstream_check_module指令 Syntax: check interval=milliseconds [fall=count] [rise=count] [timeout=milliseconds] [default_down=true|false] [type=tcp|http|ssl_hello|mysql|ajp] [port=check_port]
Default: 如果没有配置参数，默认值是：interval=30000 fall=5 rise=2 timeout=1000 default_down=true type=tcp
Context: upstream 该指令可以打开后端服务器的健康检查功能。指令后面的参数意义是：
interval：向后端发送的健康检查包的间隔。
fall(fall_count): 如果连续失败次数达到fall_count，服务器就被认为是down。
rise(rise_count): 如果连续成功次数达到rise_count，服务器就被认为是up。
timeout: 后端健康请求的超时时间。
default_down: 设定初始时服务器的状态，如果是true，就说明默认是down的，如果是false，就是up的。默认值是true，也就是一开始服务器认为是不可用，要等健康检查包达到一定成功次数以后才会被认为是健康的。
type：健康检查包的类型，现在支持以下多种类型
tcp：简单的tcp连接，如果连接成功，就说明后端正常。
ssl_hello：发送一个初始的SSL hello包并接受服务器的SSL hello包。
http：发送HTTP请求，通过后端的回复包的状态来判断后端是否存活。
mysql: 向mysql服务器连接，通过接收服务器的greeting包来判断后端是否存活。
ajp：向后端发送AJP协议的Cping包，通过接收Cpong包来判断后端是否存活。
port: 指定后端服务器的检查端口。你可以指定不同于真实服务的后端服务器的端口，比如后端提供的是443端口的应用，你可以去检查80端口的状态来判断后端健康状况。默认是0，表示跟后端server提供真实服务的端口一样。该选项出现于Tengine-1.4.0。
Syntax: check_keepalive_requests request_num
Default: 1
Context: upstream 该指令可以配置一个连接发送的请求数，其默认值为1，表示Tengine完成1次请求后即关闭连接。
Syntax: check_http_send http_packet
Default: "GET / HTTP/1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1662b44569b8333cbe2cffc1e027e36a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04b23e715d95c56fd2d9781ef86b0413/" rel="bookmark">
			Python绘制GPS轨迹图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import folium import os def draw_gps(locations1, locations2,color1,color2): """ 绘制gps轨迹图 :param locations: list, 需要绘制轨迹的经纬度信息，格式为[[lat1, lon1], [lat2, lon2], ...] :param output_path: str, 轨迹图保存路径 :param file_name: str, 轨迹图保存文件名 :return: None """ m1 = folium.Map(locations1[0], zoom_start=15, attr='default') # 中心区域的确定 m2 = folium.Map(locations2[0], zoom_start=15, attr='default') # 中心区域的确定 folium.PolyLine( # polyline方法为将坐标用线段形式连接起来 locations1, # 将坐标点连接起来 weight=3, # 线的大小为3 color=color1, # 线的颜色为橙色 opacity=0.8 # 线的透明度 ).add_to(m1) # 将这条线添加到刚才的区域m内 folium.PolyLine( # polyline方法为将坐标用线段形式连接起来 locations2, # 将坐标点连接起来 weight=3, # 线的大小为3 color=color2, # 线的颜色为橙色 opacity=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04b23e715d95c56fd2d9781ef86b0413/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38b4898ec3f3ab5c4eed3ae1a392edf0/" rel="bookmark">
			k8s1.25版本集群部署（亲测有效）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.实验环境准备
准备三台centos7虚拟机，用来部署k8s集群：
master（hadoop1，192.168.229.111）配置：
操作系统：centos7.3以及更高版本都可以配置：4核cpu，4G内存，30G硬盘
网络：网络地址转换
node（hadoop2，192.168.229.112）配置：
操作系统：centos7.3以及更高版本都可以配置：4核cpu，4G内存，30G硬盘
网络：网络地址转换
2.初始化实验环境（所有节点）
2.1 配置静态IP
#查看网络信息
#配置静态IP
#重启网络服务
systemctl start network.service或者service network restart
#重启虚拟机
2.2 修改yum源
#yum在线下载wgetyum -y install wget#备份原有yum源mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup#下载阿里云yum源wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo#生成新的yum缓存yum makecache fast#配置k8s需要的yum源cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo[kubernetes]name=Kubernetesbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64enabled=1gpgcheck=0EOF#清理缓存yum clean all#生成新的yum缓存yum makecache fast#更新yum源yum -y update#安装软件依赖包yum -y install yum-utils device-mapper-persistent-data lvm2 备注：yum-utils是yum的安装工具包，可以简化安装过程中设置安装源的配置过程。docker内部容器如果需要进行数据存储，需要通过device-mapper-persistent-data和lvm2数据存储驱动来完成数据存储。
#添加新的docker软件源
yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repoyum clean allyum makecache fast 2.3 安装基础软件包
yum -y install wget net-tools nfs-utils lrzsz gcc gcc-c++ make cmake libxml2-devel openssl-devel curl curl-devel unzip sudo ntp libaio-devel wget vim ncurses-devel autoconf automake zlib-devel python-devel epel-release openssh-server socat ipvsadm conntrack ntpdate 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38b4898ec3f3ab5c4eed3ae1a392edf0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95a9dd7035e5ad993d4ca679e6087041/" rel="bookmark">
			Linux查看显卡信息和NVIDIA驱动查询命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看显卡信息
lspci | grep -i nvidia
型号翻译
PCI devices
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/783d68d1058b178f02ec1a474bdaa027/" rel="bookmark">
			外部H5页面打开微信小程序最新流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当前时间2022年11月22日，记录一下外部H5如何打开指定微信小程序的指定页面最新流程。
因为微信小程序后台已关闭生成 小程序 scheme 码 入口，所以只能通过如下方式：
1.服务端获取微信小程序 scheme 码 前提条件：目前仅针对国内非个人主体的小程序开放。
以上适用于短信、邮件、外部网页、微信内等拉起小程序的业务场景。
建议这步由后端完成
请求方式：POST
接口url：https://api.weixin.qq.com/wxa/generatescheme?access_token=ACCESS_TOKEN
(注意:这个token是拼接在url中，不是在body中,后端根据微信接口可以生成，不做详细介绍，可参考https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/access-token/auth.getAccessToken.html)
请求body示例:
{ "jump_wxa": { "path": "/pages/publishHomework/publishHomework", "query": "" }, "expire_type":1, "expire_interval":2 } 返回：
{ "errcode": 0, "errmsg": "ok", "openlink": “weixin://dl/business/?t=xxxxxxx”, } 这里的openlink即是微信小程序 scheme 码，注意：
自 2022 年 4 月 11 日起，URL Scheme有效期最长 30 天，不再支持永久有效的URL Scheme、不再区分短期有效URL Scheme与长期有效URL Scheme。若在微信外打开，用户可以在浏览器页面点击进入小程序。每个独立的URL Scheme被用户访问后，仅此用户可以再次访问并打开对应小程序，其他用户无法再次通过相同URL Scheme打开该小程序。 在本次规则调整生效前已经生成的URL Scheme，如果有效期超过30天或长期会被降级为30天有效，只能被1个用户访问，开始时间从调整日期开始计算。 为了保证用户每次都可以正常访问小程序，建议每次生成新的scheme 码。
2.自有H5页面内内嵌一下跳转小程序的代码 示例如下：
location.href = 'weixin://dl/business/?t=xxxxxxx' 该跳转方法可以在用户打开 H5 时立即调用，也可以在用户触发事件后调用，根据个人情况添加。
比如我就是在一个div标签添加onClick事件，事件内加上如上代码即可。
3.H5页面部署一下，使用手机自带浏览器打开H5页面的url，即可通过H5先唤醒微信客户端App，再唤醒微信小程序 注意，正常来说这个h5 url在微信内部网页是无法打开的，微信内部网页需要使用到微信组件wx-open-launch-weapp，具体使用方法请参考官方文档：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/783d68d1058b178f02ec1a474bdaa027/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c11eee070b91fef2cd6b6279755d75a/" rel="bookmark">
			工作中如何优雅说不
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《左耳听风》专栏读书笔记。
有一些事情已经超出个人控制范畴，不尊重科学和客观规律，在这种情况下，要学会对某些事说“不”，甚至是学习对老板说不。这其实是一种“向上管理”的能力。
1、当你面对做不到的需求时，你不要说这个需求做不到。尤其是，你不要马上说做不到，你要先想一下，这样让别人觉得你是想做的，但是，在认真思考过后，你觉得做不到，并且给出一个你觉得能做到的方案。这里的诀窍是——给出另一个你可以做到的方案，而不是把对方的方案直接回绝掉。
2、当你面对过于复杂的需求时，你不要说不。你要反问一下，为什么要这样做？这样做的目的是什么？当了解完目的以后，你可以给出一个自己的方案，或是和对方讨论一个性价比更好的方案。你可以回复说，这个需求好复杂，我们能不能先干这个，再做那个，这样会更经济一些。这里的诀窍是——我不说我不能完全满足你，但我说我可以部分满足你。
3、当你面对时间完全不够的需求时，你也不要说不。既然对方把压力给你，你要想办法把这个压力还回去，或是让对方来和你一同分担这个压力。
我惯用的方式是给回三个选择：
a. 我可以加班加点完成，但是我不保证好的质量，有 bug 你得认，而且事后你要给我 1 个月的时间还债。
b. 我可以加班加点，还能保证质量，但我没办法完成这么多需求，能不能减少一些？
c. 我可以保质保量地完成所有的需求，但是，能不能多给我 2 周时间？
我不能说不，但是我要有条件地说是。而且，我要把你给我的压力再反过来还给你，看似我给了需求方选择，实际上，掌握了主动。
这就是学会说“不”的方法。说白了，你要学会在“积极主动的态度下对于不合理的事讨价还价”。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9b088fa9049212f06747df26652eb87/" rel="bookmark">
			技术领导力学习之道
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源于《左耳听风》技术专栏读书笔记
技术领导力，前提是得有扎实的技术功底。目前技术层出不穷，其核心底层原理基本相同。
1、吃透基础技术，基础技术是各种上层技术共同的基础 具体来说，主要是编程和系统。这些基础知识通常是不可以速成的，可以在一两年看完相关书籍，但是灵活应用需要用一生的时间来学习和感悟。
1）C语言：学习好C语言的好处可以了解应用程序和操作系统编程，还可以更清楚知道程序是怎样精细控制底层资源的，比如内存管理、文件操作、网络通信等。
2）编程范式：面向对象编程（C++、Java）、泛型编程（C++、Go等）、函数式编程（python、JavaScript）等
3）算法和数据结构
4）计算机系统原理：CPU 的体系结构（指令集 [CISC/RISC]、分支预测、缓存结构、总线、DMA、中断、陷阱、多任务、虚拟内存、虚拟化等），内存的原理与性能特点（SRAM、DRAM、DDR-SDRAM 等），磁盘的原理（机械硬盘 [盘面、磁头臂、磁头、启停区、寻道等]、固态硬盘 [页映射、块的合并与回收算法、TRIM 指令等]），GPU 的原理等。
5）操作系统原理和基础：：进程、进程管理、线程、线程调度、多核的缓存一致性、信号量、物理内存管理、虚拟内存管理、内存分配、文件系统、磁盘管理等。学习操作系统的价值在于理解程序是怎样被管理的，操作系统对应用程序提供了怎样的支持，抽象出怎样的编程接口（比如 POSIX/Win32 API），性能特性如何（比如控制合理的上下文切换次数），怎样进行进程间通信（如管道、套接字、内存映射等），以便让不同的软件配合一起运行等。要学习操作系统知识，一是要仔细观察和探索当前使用的操作系统，二是要阅读操作系统原理相关的图书，三是要阅读 API 文档（如 man pages 和 MSDN Library），并编写调用操作系统功能的程序。这里推荐三本书：《UNIX 环境高级编程》《UNIX 网络编程》和《Windows 核心编程》。学习操作系统基础原理的好处是，这是所有程序运行的物理世界，无论上层是像 C/C++ 这样编译成机器码的语言，还是像 Java 这样有 JVM 做中间层的语言，再或者像 Python/PHP/Perl/Node.js 这样直接在运行时解释的语言，其在底层都逃离不了操作系统这个物理世界的“物理定律”。所以，了解操作系统的原理，可以让你更能从本质理解各种语言或是技术的底层原理。一眼看透本质可以让你更容易地掌握和使用高阶技术
6）网络基础：计算机网络是现代计算机不可或缺的一部分。需要了解基本的网络层次结构（ISO/OSI 模型、TCP/IP 协议栈），包括物理层、数据链路层（包含错误重发机制）、网络层（包含路由机制）、传输层（包含连接保持机制）、会话层、表示层、应用层（在 TCP/IP 协议栈里，这三层可以并为一层）。比如，底层的 ARP 协议、中间的 TCP/UDP 协议，以及高层的 HTTP 协议。这里推荐书籍《TCP/IP 详解》，学习这些基础的网络协议，可以为我们的高维分布式架构中的一些技术问题提供很多的技术方案。比如 TCP 的滑动窗口限流，完全可以用于分布式服务中的限流方案
7）数据库原理
8）分布式技术架构：数据库和应用程序服务器在应对互联网上数以亿计的访问量的时候，需要能进行横向扩展，这样才能提供足够高的性能。为了做到这一点，要学习分布式技术架构，包括负载均衡、DNS 解析、多子域名、无状态应用层、缓存层、数据库分片、容错和恢复机制、Paxos、Map/Reduce 操作、分布式 SQL 数据库一致性（以 Google Cloud Spanner 为代表）等知识点。学习分布式技术架构的有效途径是参与到分布式项目的开发中去，并阅读相关论文
2、提高学习能力 所谓学习能力，就是能够很快地学习新技术，又能在关键技术上深入的能力。
1)、学习的信息源。常见的信息源有 Google 等搜索引擎，Stack Overflow、Quora 等社区，图书，API 文档，论文和博客等
2)、与高手交流：可以通过技术社区、开源项目来和高手切磋
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9b088fa9049212f06747df26652eb87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d3f4a7cc9271223b4adb392709bbe7f/" rel="bookmark">
			Perl语言哈希的运用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是哈希？
哈希是一种数据结构，它和数组的相似之处在于可以容纳任意多的值并能按需取用，而它和数组的不同在于索引方式，数组是以数字来索引，哈希则以名字来索引。也就是说，哈希的索引值，此处称为键( key )，并不是数字、而是任意唯一的字符串。
键总会被转换为字符串
哈希的值可以是数字、字符串、undef，或是这些类型的组合。
哈希的键则必须全部是唯一的字符串。
为何使用哈希？
事实上只要问题中带有"找出重复"、“唯一”、“交叉引用”、"查表"之类的字眼，实现时就很有可能会用到哈希。
访问哈希元素 $hash{$some_key}
（1）在挑选哈希名的时候，最好使得哈希名和键之间能放进去一个 “for” 字。
比如"family_name for fred是flintstone"，因此把哈希命名为family_name能清晰地反映出键和值之间的关系。
my %family_name; $family_name{'fred'} = 'flintstone'; $family_name{'barney'} = 'rubble'; foreach my $person (qw&lt; fred barney&gt;){ print "I've heard of $person $family_name{$person}.\n"; } （2）哈希键可以是任意的表达式：
$foo = 'bar'; print "barney =&gt; $family_name{ $foo . 'ney'}"; （3）若对某个已存在的哈希元素赋值，就会覆盖之前的值：
$family_name{'fred'} = 'astaire'; print "fred =&gt; $family_name{'fred'}.\n"; （4）哈希元素会因赋值而诞生：
$family_name{'wilma'} = 'flintstone'; $family_name{'betty'} = $family_name{'barney'}; my @family_name = %family_name; print "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d3f4a7cc9271223b4adb392709bbe7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ae147c481f3565614eeb9df9be6f3ae/" rel="bookmark">
			搭建一个基于 Markdown的文档编辑框架 - vue3 - vuepress （下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue3-vuepress 搭建一个基于 Markdown的文档编辑框架 - vue3 - vuepress （下）
gitee:vue3-vuepress
Markdown语法 MarkDown是一种轻量级标记语言，使用易读易写的纯文本格式编写文档。2004年由约翰·格鲁伯创建。使用MarkDown编写的文档可以导出HTML、Word、图像、PDF、Epub等多种格式的文档。MarkDown编写的文档，后缀名为.md或.markdown。
1.标题 # 我是一级标题 ## 我是二级标题 ### 我是三级标题 #### 我是四级标题 ##### 我是五级标题 ###### 我是六级标题 我是一级标题 我是二级标题 我是三级标题 我是四级标题 我是五级标题 我是六级标题 2.块引用 &gt; 单引用 单引用
&gt; 多引用 多引用（使用空 &gt; 强制换行）
引用
&gt; 嵌套引用 &gt;&gt; 第二级引用 &gt;&gt;&gt; 第三级引用 嵌套引用
第二级引用
第三级引用
3.列表 有序列表
1. 列表1 2. 列表2 3. 列表3 列表1列表2列表3 无序列表 * _ +(效果一样)
- 无序列表 * 无序列表 + 无序列表 无序列表 无序列表 无序列表 嵌套列表
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ae147c481f3565614eeb9df9be6f3ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f78370cdc6de3ed15accc992d84c9d02/" rel="bookmark">
			NewStarCTF 公开赛-web
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 week1HTTPHead?Header!我真的会谢NotPHP 函数绕过Word-For-You 万能密码 week2Word-For-You(2 Gen) 报错注入IncludeOne 文件包含+伪随机数UnserializeOne 反序列化ezAPI graphQL week3BabySSTI_OnemultiSQL 堆叠注入IncludeTwo pearcmd.php的利用Maybe You Have To think More week4So Baby RCEBabySSTI_TwoUnserializeThree phar反序列化又一个SQL week5Give me your photo PLZ 图片马Unsafe Apache Apache版本漏洞利用So Baby RCE AgainBabySSTI_ThreeFinal round 时间盲注 week1 HTTP cookie 修改admin 源码发现key GET和POST传参即可
Head?Header! User-Agent: CTF Referer: ctf.com X-Forwarded-For: 127.0.0.1 我真的会谢 信息泄露
robots.txt
www.zip
源码 + /.index.php.swp
NotPHP 函数绕过 if(file_get_contents($_GET['data']) == "Welcome to CTF"){ if(md5($_GET['key1']) === md5($_GET['key2']) &amp;&amp; $_GET['key1'] !== $_GET['key2']){ if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f78370cdc6de3ed15accc992d84c9d02/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2964acfea37ab54f7442cd3af85453f/" rel="bookmark">
			关于激光雷达传感器分类及简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于激光雷达传感器（根据特性进行分类介绍） 0一些激光雷达的厂商总结1 基本介绍2 基本分类及组成2.1 激光雷达的相关分类2.1.1 机械式激光雷达：2.1.2 混合固态激光雷达：2.1.3 固态激光雷达：OPA和Flash固态激光雷达 2.2 机械式激光雷达系统组成 3 基本原理3.1 工作过程：3.2 测距原理 4 激光雷达域ROS Author（作者）： Nirvana Of Phoenixl
*Proverbs for you（送给你的哦）：There is no doubt that good things will always come, and when it comes late, it can be a surprise.如有转载请注明，谢谢！
本文主要介绍关于激光传感器的分类，对于不同工作员的激光传感器，帮助记录并理解激光传感器。如有错误请指正，如转载请注明。
0一些激光雷达的厂商总结 激光雷达应用场合很多在机器人、无人驾驶、测绘、安防灯领域。
1 基本介绍 激光雷达传感器实际上可以分为两部分：激光和雷达。激光（Light Amplification by Stimulated Emission of Radiation）原子受激辐射的光，故名“激光”其光子光学特性高度一致。因此激光相比普通光源单色性、方向性好，亮度更高。雷达，是英文Radar的音译，源于radio detection and ranging的缩写，意思为"无线电探测和测距"，即用无线电的方法发现目标并测定它们的空间位置。因此，雷达也被称为“无线电定位”。雷达是利用电磁波探测目标的电子设备。雷达发射电磁波对目标进行照射并接收其回波，由此获得目标至电磁波发射点的距离、距离变化率（径向速度）、方位、高度等信息。
激光雷达（英文：Laser Radar），是以发射激光束探测目标的位置、速度等特征量的雷达系统。其工作原理是向目标发射探测信号（激光束）,然后将接收到的从目标反射回来的信号（目标回波）与发射信号进行比较,作适当处理后,就可获得目标的有关信息,如目标距离、方位、高度、速度、姿态、甚至形状等参数,从而对飞机、导弹等目标进行探测、跟踪和识别。
2 基本分类及组成 2.1 激光雷达的相关分类 激光雷达应用场合很多在机器人、无人驾驶、测绘、安防等领域应用。按照不同的标准和方式可以将其分为不同的类别。下面介绍几种分类，在目前来说最明显也最广泛的分类为按照结构或者扫描方式分类。
通常来说我们会将激光雷达按照结构分为三类：机械式激光雷达、固态激光雷达、混合固态激光雷达。
2.1.1 机械式激光雷达： 指其发射系统和接收系统存在宏观意义上的转动，也就是通过不断的旋转发射头，将速度根块、发射更准的激光从“线”变成“面”，并在竖直方向上排布多束激光，形成多个面，达到动态扫描并动态接收信息的目的。因其带有机械旋转机构，其最大特点是自生可以转动。也是目前应用最为广泛的和成熟的激光传感器，在激光雷达市场占有统治地位。
2.1.2 混合固态激光雷达： 机械式激光雷达在工作时发射系统和接收系统360°旋转，而混合固态激光雷达工作时，但从外观上是看不到旋转的，巧妙之处在于将机械旋转部件做的更加小巧且深深隐藏于外壳。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2964acfea37ab54f7442cd3af85453f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/054f258e9e985420513bd185e88bbb1f/" rel="bookmark">
			Android——广播接收者的动态注册之电量过低提示案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		广播接收者 Android系统提供了一个BroadcastReceiver（广播接收者）组件。
当Android系统产生一个广播事件时，可以有多个对应的BroadcastReceiver接收并进行处理，这些广播接收者只需要在代码中进行注册并指定要接收的广播事件，然后创建一个继承自BroadcastReceiver的类，重写onReceive（）方法，并在该方法中对广播事件进行处理。
电量过低提示案例 1.创建一个名为BroadcastReceiver的程序，包名指定为cn.itcast.broadcastreceiver。
2.右击cn.itcast.broadcastreceiver包，【new】-【Java class】创建一个BatteryReceiver类继承自BroadcastReceiver。
重写onReceive（）方法
package cn.itcast.broadcastreceiver; import android.content.BroadcastReceiver; import android.content.Context; import android.content.Intent; import android.os.Bundle; import android.widget.Toast; public class BatteryReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { Bundle bundle =intent.getExtras(); int current =bundle.getInt("level"); int taotal= bundle.getInt("scale"); if(current *1.0 /taotal &lt;0.15){ Toast.makeText(context, "电量过低，请尽快充电", Toast.LENGTH_LONG).show(); } } } 3.在MainActivity中动态注册广播接收者
通过registerReceiver()方法注册广播接收者，该方法中第一个参数表示广播接收者，第二个参数表示实例化的过滤器
package cn.itcast.broadcastreceiver; import android.support.v7.app.AppCompatActivity; import android.os.Bundle; import android.content.Intent; import android.content.IntentFilter; public class MainActivity extends AppCompatActivity { BatteryReceiver receiver; @Override protected void onCreate(Bundle savedInstanceState) { super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/054f258e9e985420513bd185e88bbb1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f527a6b6a4d0eda913411b1faad45d75/" rel="bookmark">
			windows DHCP服务器部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.关于windows-dhcp服务器
1.1 关于dhcp
1.2 DHCP续约
二.DHCP服务器部署
2.1 关于DHCP服务器
2.2部署DHCP服务器
2.3 保留特定IP地址
2.4 相关dos命令使用 2.5 多个地址池的配置以及选项优先级
3. DHCP服务端口号udp 67/68 相关操作
4.DHCP的攻击和防御
一.关于windows-dhcp服务器 1.1 关于dhcp 就是动态的主机配置协议，实现自动分配IP地址；可以减少工作量，避免冲突，提高地址利用率；但是同时也是一种租约过程，实现起来会有一定程度上的困扰，因为可能会由于某种情况会回收正在使用的ip，重新分配，造成了一定的麻烦，如果是在外面的续约则会更麻烦，变更会更多，例如使用公共的WiFi，变更频率会直线上升，对于ip地址的利用也是到了极致；
地址池\作用域：在用户定义了 DHCP 可用IP范围及排除范围后，剩余的地址构成了一个地址池，地址池中的地址可以动态的分配给网络中的客户机使用。dhcp会分配正常上网需要的ip 子网掩码 网关 dns；
dhcp协议端口是udp（udp是区别于tcp的不安全传输方式，但是udp用于dhcp可以极大的方便分配，因为udp不需要有那么多建立连接，可以直接使用；）
1.2 DHCP续约 DHCP的租约过程会比较麻烦，会在某个时候来发包询问你要不要续约，等你返回包会进行续约；如果你在那个时候没有相应，你用的还是你本来的，但是可以使用的时间一直在减少，所以会再发包问你要不要继续用，等你返回包，如果有返回就续约上了，如果没有就会一直重复这个过程，直到续约成功或者到约期结束；
续约的过程:
1）客户机发送dhcp discovery广播包
客户机广播请求IP地址（包含客户机的amc地址）
2）服务器响应dhcp offer广播包
服务器响应提供的IP地址（也可以确认使用哪个ip）
3）客户机发送dhcp request广播包
客户机选择ip（也可以认为确认了要使用哪个ip）
4）发送dhcp ack广播包
服务器确认了租约，并提供网卡详细参数ip 掩码 网关 dns 租期等
DHCP续约（客户机有ip之后再发送request包目的就是续约）
当过50%后，客户机会再次发送dhcp request包，进行续约，如服务器无响应，
则继续使用并在87.5%再次发送dhcp request包，进行续约，如果仍然无响应，
并释放IP地址，及重新发送dhcp discovery广播包来获取IP地址
当无任何服务器响应时，自动给自己分配一个169.254.x.x/16，属于全球统一无效地址，用于临时内网通信！
二.DHCP服务器部署 2.1 关于DHCP服务器 Windows、Linus、三级交换机、路由器等均可部署DHCP服务器，小公司以及可以用路由器自带的DHCP服务器，中大型企业一般单独做另外部署，建议做多几个；
接下来用虚拟机，winxp作为客户机，win2003作为服务器，首先就是先进行桥接，配置到同一个局域网，eg vmnet1；部署DHCP服务器，需要用到服务器软件来开启服务端口，一般就是在windows服务器管理里面“开始&gt;管理工具”里面就可以找到已经安装好的服务器软件；
2.2部署DHCP服务器 1.打开虚拟机，xp作为客户机，03作为服务器，桥接网络，配置到同一局域网（这里使用的是vmnet1桥接）
2.IP地址规划：DHCP服务器的IP地址需要固定，就是说DHCP的地址是静态的，DHCP是动态的服务，固定的地址；部署服务器前对未来所需服务器数量进行预判规划，预留一定数量的固定IP地址，常用前20位，同时规划地址池/作用域。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f527a6b6a4d0eda913411b1faad45d75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aab96ca0780f10f5dfaa5199cedb475f/" rel="bookmark">
			vue3使用富文本编辑器wangEditor-v5（未使用composition api写法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果 安装 安装核心库和其vue组件库
yarn add @wangeditor/editor yarn add @wangeditor/editor-for-vue@next 使用v-model封装富文本组件editor.vue &lt;template&gt; &lt;div class="editor-box"&gt; &lt;Toolbar class="toolbar" :editor="editor" :defaultConfig="toolbarConfig" :mode="mode" ref="t" /&gt; &lt;Editor class="editor" v-model="html" :defaultConfig="editorConfig" :mode="mode" @onCreated="onCreated" /&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import "@wangeditor/editor/dist/css/style.css" import { Editor, Toolbar } from "@wangeditor/editor-for-vue" import { DomEditor } from "@wangeditor/editor" export default { components: { Editor, Toolbar }, data() { return { editor: null, toolbarConfig: { // 不需要的工具栏选项，这里去除了emoji表情 excludeKeys: ["emotion"], }, editorConfig: { placeholder: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aab96ca0780f10f5dfaa5199cedb475f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/add2ce047977774be863d75bdef5074b/" rel="bookmark">
			arm或者aarch64 架构安装 conda 环境，迁移环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		arm或者aarch64 架构安装 conda 环境
如果latest版本安装报错，
安装miniconda时，遇到这个问题（自行安装的时候安装的Miconda3-lateset-Linux-aarch64.sh和Miniconda3-py37_4.11.0-Linux-aarch64.sh）这两个版本均失败，error信息就是illegal instruction (core dump）
使用
wget https://repo.anaconda.com/miniconda/Miniconda3-py37_4.9.2-Linux-aarch64.sh
py37_4.9.2这个版本，4.11，4.12，latest，conda版本都报错
jetson tx2 安装miniconda失败原因（illegal instruction (core dump）原因解析与简易安装miniconda_须臾一念的博客-CSDN博客_jetson miniconda
安装miniconda
/bin/bash Miniconda3-py37_4.9.2-Linux-aarch64.sh -f -b -p /opt/conda
添加清华源
#查看当前conda配置
conda config --show channels
#设置通道
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/
#设置搜索是显示通道地址
conda config --set show_channel_urls yes
conda设置清华源_mjiansun的博客-CSDN博客_conda 清华源
删除默认源
conda config --remove channels defaults
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/add2ce047977774be863d75bdef5074b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b39385835ef4916ba00df2699b658412/" rel="bookmark">
			VUE跨域、常用解决跨域的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我们遇到请求后台接口遇到 Access-Control-Allow-Origin 时，那说明跨域了。
跨域是因为浏览器的同源策略所导致，同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能，同源是指：域名、协议、端口相同
解决跨域常用方法：
一、VUE2.0中常用proxy来解决跨域问题
1、在vue.config.js中设置如下代码片段
module.exports = { dev: { // Paths assetsSubDirectory: 'static', assetsPublicPath: '/', proxyTable: { // 配置跨域 '/api':{ target:`http://www.baidu.com`, //请求后台接口 changeOrigin:true, // 允许跨域 pathRewrite:{ '^/api' : '' // 重写请求 } } }, } 2、创捷axioss实例时，将baseUrl设置为 ‘/api’
const http = axios.create({ timeout: 1000 * 1000000, withCredentials: true, BASE_URL: '/api' headers: { 'Content-Type': 'application/json; charset=utf-8' } }) 二、JSONP解决跨域
Jsonp(JSON with Padding) 是 json 的一种"使用模式"，可以让网页从别的域名（网站）那获取资料，即跨域读取数据。
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b39385835ef4916ba00df2699b658412/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc1b8164036ebf345b54247fd9e625dc/" rel="bookmark">
			深度学习入门——基于TensorFlow的鸢尾花分类实现（TensorFlow_GPU版本安装、实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于TensorFlow的鸢尾花分类实现 0 引言1 基本介绍和环境搭建1.1关于TensorFlow-GPU环境搭建第一步:安装Anaconda：第二步：安装GPU版本需要，明确显卡型号第三步：打开conda终端建立Tensorflow环境第四步：激活虚拟环境：第五步：安装ensorflow gpu版本：第六步：安装keras：pip install keras -i 软件源第七步：进入IDE（Pycharm或者VScode）切换环境为tensorflow-gpu调试 1.2关于鸢尾花数据集介绍 2 实现过程及分析2.1 数据集可视化化以及PCA降维：2.2 实验结果如下：2.3 分析结论 附录（完整Python代码） Author（作者）： Nirvana Of Phoenixl
Proverbs for you（送给你的哦）：There is no doubt that good things will always come, and when it comes late, it can be a surprise.
文章可以作为深度学习或者TensorFlow入门的了解学习。使用PyChram和Python实现，安装过程中最容易出现的问题是GPU版本的与显卡的问题。如果需要对应版本的TensorFlow，可以私信一下，呜呜我懒的放上来，可以发一份给你们！
0 引言 本文主要是基于TensorFlow和Keras框架实现的鸢尾花分类，主要包含关于深度学习TensorFlow-GPU环境的搭建，以及实现框架的实现，其实验目的是实现鸢尾花分类，本质是通过简单的实践理解深度学习基本流程，加深对于代码实现的理解，通过对框架中的参数修改和完善理解调参对于框架识别精度的影响。最终目标是熟悉包括软件安装在内的深度学习环境的搭建、框架的构建、参数的调整做一个系统的学习和理解。
1 基本介绍和环境搭建 1.1关于TensorFlow-GPU环境搭建 深度学习的核心概念就是以张量（矩阵）运算模拟神经网络的。TensorFlow主要的设计就是让矩阵运算达到最高性能，并且能够在各种不同的平台下运行。TensorFlow最初由谷歌开发，深度学习的发展是由前景的，谷歌希望建立一个开源的社区，强大TensorFlow使其更加完善，最后开源。TensorFlow架构主要由处理器（cpu/gpu/tpu）、平台（win/linux/android/ios/raspi）、tensoflow引擎、前端语言（python/c++）、高级api（keras/TF-learn/TF-slim/TF-layer）组成。如下图所示，TensorFlow架构组成。
图1 TensorFlow架构组成
TensorFlow是比较低级深度学习API，所以在程序设计模型时必须自行设计：张量乘积、卷积等底层操作，好处是我们可以自行设计各种深度学习模型，但缺点是开发时需要编写更多的程序代码，并且需要花费很长的时间。所以网上的开发社区以TensorFlow为底层开发很多高级的深度学习API，例如Keras、TF-Learn等。这样可以使得开发者使用更简洁、更具可读性的程序代码就可以构建出各种复杂的深度学习模型。本文主要采用Keras，因为Keras功能最为完整。
下面介绍如何在Windows上安装TensorFlow-GPU版本，因为其计算能力更强。因为之前本人已经安装过了TensorFlow-GPU版本，并搭建了环境，参考代码实现了一些经典数据集的学习训练，比如Keras MINIST、Keras-CIFAR-10等。下面将讲解如何安装和踩坑出现的问题。首先明确，对于GPU版本的TensorFlow主要通过NVIDIA提供的CUDA和cudnn存取GPU，CUDA是NVIDIA推出的整合技术，实质功能就是一种通过应用显卡处理数量较大的数据问题的架构，而cudnn是NVIDIA深度学习SDK的一部分，用于提供GPU深度学习库和加速深度学习的。
具体的安装步骤：
第一步:安装Anaconda： 指的是一个开源的Python发行版本，其包含了conda、Python等180多个科学包及其依赖项。（按步骤安装即可）
图示上下分别为基本环境和新建的虚拟的GPU环境。
第二步：安装GPU版本需要，明确显卡型号 （目前绝大多数时NVIDIA的显卡），去官方的网址下载CUDA和cudnn（注意这里需要明确版本对应查找适合是显卡型号的CUDA然后根据CUDA确定cudnn）实际在我测试过程当中可以低版本安装，但是不能高于当前适用的版本安装。（实际显卡提示安装CUAD11.0，cudnn 8.0但是我安装的是CUDA10.0和cudnn7.4）
图示 为安装CUDA版本的版本，cudnn对应可以去配置文件里面查看。
第三步：打开conda终端建立Tensorflow环境 conda create –name tensorflow-gpu python=3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc1b8164036ebf345b54247fd9e625dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98f101505b578604a7b700dd9cd4f4b5/" rel="bookmark">
			使用pkg打包node.js为可执行文件（exe）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		生成了exe文件后，可以不依赖node环境，就可以执行
安装npm install -g pkg
可以使用pkg -h查看相关命令
将app.js编译成 pkg app.js 报错：
Error! Not able to build for 'linux' here, only for 'win' 环境只支持编译为windows系统的可执行文件
pkg -t win app.js Error! AssertionError [ERR_ASSERTION]: The expression evaluated to a falsy value: 缓存里缺少相应的二进制文件
查看自己的node版本node -v
关于node的输入输出 rl.on()
rl.on(‘line’,(line)=&gt;{})相当于开启读行的监听，读完一行执行回调。
rl.on(‘close’,()=&gt;{})结束读取的回调。可以在这里处理全局变量
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ad4b8965a931fbbbb0833f3b0f2f0a3/" rel="bookmark">
			【QT】编译QtWebEngine（Build QtWebEngine from source）Win10&#43;QT5.7.1_x64&#43;VS2015
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、前言 关于QtWebEngine是干什么的，怎么用的，不在此赘述。
1.1、为什么要编译QtWebEngine QT默认的QtWebEngine是不支持mp3、mp4解码的，也就是说，如果想要在QT浏览网页的时候支持在线播放音视频，就需要让QtWebEngine支持对音视频格式的解码。QtWebEngine底层使用了chromium库，可能是为了避免知识产权方面的问题，QT并没有直接提供对应的音视频解码的第三方库，只提供了第三方库的源码，所以就需要自己手动编译了。
2、编译环境 在编译的时候遇到了各种奇奇怪怪的问题，基本上都是编译环境引起。通过不断的尝试，摸索出来按照以下的环境进行配置成功率会比较高。
环境的配置比较全面并且麻烦，建议有条件的尽量按照文档中所描述的进行配置。
2.1、操作系统 首先就是操作系统，建议尽量通过虚拟机进行操作。
在虚拟机中安装一个纯净的操作系统, 本文档中使用的是Win10_x64。并且最好把操作系统的语言设置成英文，设置成英文会避免在编译时出现一些字符格式上的错误。
1）修改操作系统语言
这个需要下载英语的语言包。
2）修改操作系统区域
将操作系统的区域设置为美国：
2.2、软件安装 我会把用到的软件放到网盘中，有需要的可以直接下载，网盘地址：
链接：https://pan.baidu.com/s/18WSYn6Jf02z9e-74A_-2EQ。
提取码：js87
2.2.1、VS2015 下载地址：下载 Visual Studio Tools - 免费安装 Windows、Mac、Linux。
安装VC++模块，SDK Windows 10 (10.0.xxxxx.x)
可以将VS2015的显示语言改成英文，否则在编译时，部分字符会显示成乱码，不确定是否会影响正常编译。
2.2.2、QT5.7.1 下载地址：Index of /new_archive/qt/5.7/5.7.1。
本文档中安装的是 qt-opensource-windows-x86-msvc2015_64-5.7.1
安装：
一定要勾选Source和QtWebEngine! 一定要勾选Source和QtWebEngine! 一定要勾选Source和QtWebEngine!
安装完成之后，将qt安装目录下的bin路径添加至系统环境变量。
2.2.3、Python2.7 下载地址：Python Releases for Windows | Python.org。
一定要安装2.7.x的版本，不支持python3！
本文档中安装的是 python-2.7.18.amd64
安装完成之后，将安装目录添加至系统环境变量中。
2.2.4、Perl 下载地址：Strawberry Perl for Windows。
本文档中使用的是 strawberry-perl-5.32.1.1-64bit
安装完成之后，会自动将bin目录添加至系统环境变量。
2.2.5、Bison and Flex 下载地址：https://sourceforge.net/projects/winflexbison/。
将win-bison.exe重命名为bison.exe，将win-flex.exe重命名为flex.exe。
然后将bison.exe和flex.exe的路径添加至系统环境变量。
2.2.6、Gperf 下载地址：Gperf for Windows。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ad4b8965a931fbbbb0833f3b0f2f0a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84e90225620999af814b6937783bae49/" rel="bookmark">
			实现Excel文件xls与xlsx格式批量互相转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 python实现方法VBA实现方法 python实现方法 将文件夹中的所有xls或xlsx文件转换为xlsx或xls文件
import win32com.client as win32 # 需安装pywin32 import os.path import glob excel = win32.gencache.EnsureDispatch('Excel.Application') #简易使用方法 #filename = r'E:\xlsx\1.xls' #wb = excel.Workbooks.Open(filename) #wb.SaveAs(filename+'x', FileFormat=51) #FileFormat=51 是 .xlsx 的扩展 #wb.Close() #FileFormat=56 是 .xls 的扩展 #excel.Application.Quit() def xls2xlsx(xls_path, xlsx_path): # xls_path参数为待转换的xls文件所在文件夹 # xlsx_path参数为转换完成的xlsx文件保存文件夹 # 当xlsx保存文件夹存在同名原xls时，会弹窗提示是否替换，建议保存至空文件夹​ path_list = glob.glob(xls_path + '\\*.xls') # 获取文件夹下所有xls for file in path_list: filename = os.path.basename(file).replace('.xls', '.xlsx') # 获取文件名 wb = excel.Workbooks.Open(file) wb.SaveAs(xlsx_path + '\\' + filename, FileFormat=51) # xlsx为51 wb.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84e90225620999af814b6937783bae49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99f17f18cc3ca20539d6b5c316fc2a75/" rel="bookmark">
			@ApiLog编写spring日志打印注解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
声明一个注解
@interface
@Target修饰注解
@Retention修饰注解
@Document修饰注解 @Inherited修饰注解
编写@ApiLog的实现切面类
声明一个注解 基本元素:
描述
修饰符
访问修饰符必须为public,不写默认为pubic
关键字
关键字为@interface
注解名称
注解名称为自定义注解的名称，使用时还会用到
注解类型元素
注解类型元素是注解中内容，可以理解成自定义接口的实现部分
@interface 注解名称为自定义注解的名称，使用时还会用到
注解类型元素
注解类型元素是注解中内容，可以理解成自定义接口的实现部分
例：
public @interface ApiLog { } @Target修饰注解 @Target用以表明该注解可以应用的java元素类型
类型描述
ElementType.TYPE
//应用于类、接口(包括注解类型)、枚举
ElementType.FIELD
//应用于属性(包括枚举中的常量)
ElementType.METHOD
//应用于方法
ElementType.PARAMETER
//应用于方法的形参
ElementType.CONSTRUCTOR
//应用于构造函数
ElementType.LOCAL_VARIABLE
//应用于局部变量
ElementType.ANNOTATION_TYPE
//应用于注解类型
ElementType.PACKAGE
//应用于包
ElementType.TYPE_PARAMETER
//1.8版本新增，应用于类型变量
ElementType.TYPE_USE
//1.8版本新增，应用于任何使用类型的语句中(例如声明语句、泛型和强制转换语句中的类型)
例： @Target({ElementType.TYPE, ElementType.METHOD}) public @interface ApiLog { } @Retention修饰注解 类型描述
RetentionPolicy.SOURCE
编译时被丢弃，不包含在类文件中
RetentionPolicy.CLASS
JVM加载时被丢弃，包含在类文件中，默认值
RetentionPolicy.RUNTIME
由JVM 加载，包含在类文件中，在运行时可以被获取到
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99f17f18cc3ca20539d6b5c316fc2a75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a792328d87699c137b66ed02f95b380a/" rel="bookmark">
			爱心代码—（免费分享）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可加名字 的爱心 可变颜色 方法很简单
首先在桌面新建一个文本：
然后在复制我下面的代码在文本里面并保存：
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset="utf-8" /&gt;
&lt;title&gt;💗&lt;/title&gt;
&lt;style&gt;
html,
body {
height: 100%;
padding: 0;
margin: 0;
background: #000;
}
canvas {
position: absolute;
width: 100%;
height: 100%;
animation: anim 1.5s ease-in-out infinite;
-webkit-animation: anim 1.5s ease-in-out infinite;
-o-animation: anim 1.5s ease-in-out infinite;
-moz-animation: anim 1.5s ease-in-out infinite;
}
#name {
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
margin-top: -20px;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a792328d87699c137b66ed02f95b380a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ac385381c4bbc4cbb6bd3006ec109c3/" rel="bookmark">
			CentOS 7 修改默认 yum 源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、修改CentOS默认yum源为mirrors.aliyun.com 1、首先备份系统自带的yum源配置文件
[root@localhost ~]# mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup
2、进入yum配置文件所在文件夹
[root@localhost ~]# cd /etc/yum.repos.d/
3、下载aliyun的yum源配置文件到：
[root@localhost ~]# cd /etc/yum.repos.d/
[root@localhost yum.repos.d]# wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo
CentOS 7:
# wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo
CentOS 6:
# wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repo
CentOS 5:
# wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-5.repo
二、修改CentOS默认yum源为mirrors.163.com 1、首先备份系统自带的yum源配置文件 /etc/yum.repos.d/CentOS-Base.repo
# mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup
2、进入yum源配置文件所在的文件夹
# cd /etc/yum.repos.d/
3、下载163的yum源配置文件到/etc/yum.repos.d/
CentOS 7:
# wget http://mirrors.163.com/.help/CentOS7-Base-163.repo
CentOS 6:
# wget http://mirrors.163.com/.help/CentOS6-Base-163.repo
CentOS 5:
# wget http://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ac385381c4bbc4cbb6bd3006ec109c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fd1839ac21fd33d0943bd845ea3dcf4/" rel="bookmark">
			Word处理控件Aspose.Words功能演示：使用 Python 查找和替换 Word 文档中的文本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多时候，您需要替换 Word 文档中的特定文本或短语。MS Word 具有针对此类情况的内置功能，您可以一键替换所需的文本。在本文中，您将学习如何使用 Python 以编程方式查找和替换 Word 文档中的文本。当您需要替换一堆文档中的文本时，这可能很有用。此外，您可以在您的 Python 应用程序中嵌入此功能，以便在共享之前检查 Word 文档。
Aspose.Words for .NET 最新下载https://www.evget.com/product/564/download
用于替换 Word 文档中的文本的 Python 库
要查找和替换 DOCX 或 DOC 文件中的文本，我们将使用 Aspose.Words for Python。它是一个功能丰富的 Python 库，可让您无缝地创建和操作 MS Word 文档。 您可以使用以下 pip 命令从PyPI安装库 。
pip install aspose-words 使用 Python 在 Word 文档中查找和替换文本
以下是使用 Python 在 Word 文档中查找和替换文本的步骤。
使用Document类加载文档。使用Document.range.replace(string, string, aw.replacing.FindReplaceOptions(aw.replacing.FindReplaceDirection.FORWARD))方法替换文本。使用Document.save(string)方法保存更新的文档。 以下是我们在此示例中使用的输入 Word 文档。
以下是替换文字后更新后的Word文档。
使用正则表达式替换 Word 文档中的文本
在某些情况下，您可能希望替换与特定模式匹配的文本。例如，您可能希望在在线共享文档之前省略文档中写入的电子邮件地址。对于这种情况，您可以指定正则表达式来替换匹配的文本。以下是基于正则表达式替换 Word 文档中的文本的步骤。
使用Document类加载文档。创建FindReplaceOptions类的对象。使用Document.range.replace_regex(string, string, FindReplaceOptions)方法根据正则表达式替换文本。使用Document.save(string)方法保存更新的文档。 以下是使用 RegEx 替换文本后的 Word 文档的屏幕截图。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1fd1839ac21fd33d0943bd845ea3dcf4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c186c12e3da9515382197a7d66fd2cc/" rel="bookmark">
			Python单元测试：pytest
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pytest默认使用的是main system packages，如果需要在虚拟环境中运行，需要运行：
python -m pytest test.py
如果需要打印中间结果：
pytest test.py -s
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f02cc18c0a4ad2cea64da2e1d3a712a/" rel="bookmark">
			vue获取当前日期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在项目开发中，我遇到了日期范围选择器，两种获取当前日期并做处理的写法，这里记录一下。
1、第一个处理就是显示近七天的时间
&lt;DatePicker v-model="timeList" type="daterange" :editable="false" :clearable="false" :options="$datePickerOptions" placeholder="请输入" style="max-width: 200px" /&gt; import { formatTime } from 'comutils' //npm 安装 comutils import dayjs from 'dayjs' //去官网看怎么安装引入 https://dayjs.fenxianglu.cn/ ... //这里获取的是前6天-当前的日期一共7天的时间范围 //第一种写法 timeList：[ formatTime(new Date().getTime() - 6 * 24 * 60 * 60 * 1000, 'yyyy-MM-dd'), formatTime(new Date(), 'yyyy-MM-dd'), ] //第二种写法 daterange: [dayjs().subtract(6, 'day').format('YYYY-MM-DD'), dayjs().format('YYYY-MM-DD')], 2、第二个处理是能选择的日期范围不能大于今天（即今天以后的日期都不可选）
$datePickerOptions 对应上面的 :options，如果不需要，就用默认的就行。
//在main.js里写 (Vue.prototype.$datePickerOptions = { disabledDate(date) { return date &amp;&amp; date.valueOf() &gt; Date.now() }, }), 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38d6ba9c1356ce652251c40be6d0a9b3/" rel="bookmark">
			【CNN】ZFNet——让卷积神经网络不再是一个黑盒模型。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 ZFNet在2013年 ILSVRC 图像分类竞赛获得冠军，错误率11.19% ，比2012年的AlexNet降低了5%，ZFNet是由 Matthew D.Zeiler 和 Rob Fergus 在 AlexNet 基础上提出的大型卷积网络。ZFNet解释了为什么卷积神经网络可以在图像分类上表现的如此出色，以及研究了如何优化卷积神经网络。ZFNet提出了一种可视化的技术，通过可视化，我们就可以了解卷积神经网络中间层的功能和分类器的操作，这样就就可以找到较好的模型。ZFNet还进行消融实验来研究模型中的每个组件，它会对模型有什么影响。
1. ZFNet简介 ZFNet其实跟AlexNet很像， ZFNet 仅仅是在 AlexNet 上做了一些调参：
改变了 AlexNet 的第一层，即将卷积核的尺寸大小 11x11 变成 7x7，并且将步长 4 变成了 2（就这么一点点操作就改变了整个卷积神经网络的性能，并在2013年ImageNet大赛中夺冠） 。下面是ZFNet和AlexNet的详细网络参数：
除此之外，ZFNet最大的贡献是对卷积操作为什么对图像数据有效这个问题做出的一系列实验和解释。
2. 对卷积计算结果（feature maps）的可视化 作者将卷积核的计算结果（feature maps）映射回原始的像素空间（映射的方法为反卷积，反池化）并进行可视化。例如，下图Layer1区域最左上角的九宫格代表第一层卷积计算得到的前九张feature maps映射回原图像素空间后的可视化（称为f9）。第一层卷积使用96个卷积核，这意味着会得到96张feature maps，这里的前九张feature maps是指96个卷积核中值最大的9个卷积核对应生成的feature maps（这里称这9个卷积核为k9，即，第一层卷积最关注的前九种特征）。可以发现，这九种特征都是颜色和纹理特征，即蕴含语义信息少的结构性特征。
为了证明这个观点，作者又将数据集中的原始图像裁剪成小图，将所有的小图送进网络中，得到第一层卷积计算后的feature maps。统计能使k9中每个kernel输入计算结果最大的前9张输入小图，即9*9=81张，如下图红框中右下角所示。结果表明刚刚可视化的f9和这81张小图表征的特征是相似的，且一一对应的。由此证明卷积网络在第一层提取到的是一些颜色，纹理特征。
同理，观察Layer2和Layer3的可视化发现，第二次和第三次卷积提取到的特征蕴含的语义信息更丰富，不再是简单的颜色纹理信息，而是一些结构化的特征，例如蜂窝形状，圆形，矩形等等。那么网络的更深层呢？我们看下图：
在网络的深层，如第四层，第五层卷积提取到的是更高级的语义信息，如人脸特征，狗头特征，鸟腿鸟喙特征等等。
最后，越靠近输出端，能激活卷积核的输入图像相关性越少（尤其是空间相关性），例如Layer5中，最右上角的示例：feature map中表征的是一种绿色成片的特征，可是能激活这些特征的原图相关性却很低（原图是人，马，海边，公园等，语义上并不相干）；其实这种绿色成片的特征是‘草地’，而这些语义不相干的图片里都有‘草地’。‘草地’是网络深层卷积核提取的是高级语义信息，不再是低级的像素信息，空间信息等等。
总结：CNN输出的特征图有明显的层级区分。
越靠近输入端，提取的特征所蕴含的语义信息比较少，例如颜色特征，边缘特征，角点特征等等；
越靠近输出端，提取的特征所蕴含的语义信息越丰富，例如Layer4中的狗脸，鸟腿等，都属于目标级别的特征。
3. 网络中对不同特征的学习速度 如下图所示，横轴表示训练轮数，纵轴表示不同层的feature maps映射回像素空间后的可视化结果：
由此可以看出，low-level的特征(颜色，纹理等)在网络训练的训练前期就可以学习到， 即更容易收敛；high-level的语义特征在网络训练的后期才会逐渐学到。 由此展示了不同特征的进化过程。这也是一个合理的过程，毕竟高级的语义特征，要在低级特征的基础上学习提取才能得到。
4. 图片平移，缩放，旋转对CNN的影响 下图是探究图片平移对卷积模型影响的实验，a1是五张不同的图片经过不同大小的左右平移后的结果。
a2是原始图片与经过平移后的图片分别送进卷积网络后，第一层卷积计算得到的feature maps之间的欧氏距离，可以看出当图片平移0个像素时（即图中横轴=0处），距离最小（等于0）。其他位置随着左右平移，得到的距离都会陡增或陡减。五条彩色曲线分别代表五张不同的原始图片。
a3是原始图片与经过平移后的图片分别送进卷积网络后，第七层卷积计算得到的feature maps之间的欧氏距离，可以看出趋势与a2类似；但是，增减的曲线变换更平缓，这一定程度上说明了网络的深层提取的是高级语义特征，而不是低级的颜色，纹理，空间特征。这种语义信息不会随着平移操作而轻易改变，例如狗的图片平移后还是狗。
这个性质叫做：卷积拥有良好的平移不变性。
最后，a4表示的是原始图片与经过平移后的图片分别送进卷积网络后，卷积网络最后的识别结果。可以看出识别准确率是相对平稳的，且在横轴x=0时，识别准确率较高（此时，图片不平移，识别物体基本在图片中心位置）。
下图探究图片缩放对卷积模型影响的实验，实验方法和表述与上面探讨平移时的设置类似。结果表明，网络的浅层相较于网络的深层对缩放操作更敏感；且最终的识别准确率较平稳。这个趋势跟探究平移操作对卷积模型影响的趋势类似，即：卷积操作也具有良好的缩放不变性。
下图是探究图片旋转对卷积模型影响的实验，可以看出旋转操作对卷积的影响正好与平移和缩放相反：卷积第一层对旋转的敏感程度较低，第七层对旋转的敏感程度高。这是因为颜色，纹理这些低级特征旋转前后还是相似的特征；但是目标级别的高级语义特征却不行，例如“特征9”旋转180°后变成了“特征6”. 看最终的识别准确率曲线也能发现旋转0°和350°时模型的识别准确率最高，因为此时旋转后模型最接近原始图片。对于某些存在对称性质的特征，例如原图中的电视，在旋转90°，180°，270°时都有不错的识别准确率。因此，卷积操作不具有良好的缩放不变性。
总结：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38d6ba9c1356ce652251c40be6d0a9b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f02b6412b224ad8216aec6ca629d605/" rel="bookmark">
			建立安全连接失败连接到 120.79.9.99:9200 时发生错误。SSL 接收到一个超出最大准许长度的记录。错误代码：SSL_ERROR_RX_RECORD_TOO_LONG
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		建立安全连接失败
连接到 120.79.9.99:9200 时发生错误。SSL 接收到一个超出最大准许长度的记录。
错误代码：SSL_ERROR_RX_RECORD_TOO_LONG
因为我是用https访问的需要安全协议只要改为http就行啦
或者直接IP加端口号就行了。主要是自己粗心没有注意。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c51a70f4d5f1625db663782069cc1df5/" rel="bookmark">
			解决Module not found: Error: ‘element-plus/lib/theme-chalk/index.css‘，通过下载插件，使用的是vue ui项目仪表盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.首先在package.json中查看vue版本和element-ui版本
2.找到element-ui官网https://element.eleme.cn/#/zh-CN/component/quickstart，点击element-ui
3.进入到element–ui组件下载的地址
https://github.com/ElementUI/vue-cli-plugin-element 4.下载插件 vue-cli-plugin-element
git clone https://github.com/ElementUI/vue-cli-plugin-element.git
5.根据README
没有项目就创建项目
vue create 项目名 eg：vue create vue-democd 项目名 eg：cd vue-demovue add element
有项目直接就在项目的终端输入 vue add element
6.下载完成之后在项目终端 输入 vue ui进入项目管理仪表盘
搜索element可以看见vue-cli-plugin-element已经安装了
7.在项目里可以看见element文件
测试一下引入elemen-ui组件
运行项目 可以看见已经能正常使用组件了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1edbe9b326664ba8ed23c33679053c1d/" rel="bookmark">
			Python算法刷题常用函数备忘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 strip()split()join()find(str, beg=0, end=len(string))python 字符串格式化输出lower()upper()title() strip() lstrip()
截掉字符串左边的空格或指定字符。rstrip()
删除字符串末尾的空格或指定字符。strip([chars])
在字符串上执行 lstrip()和 rstrip() split() split(str=“”, num=string.count(str))
以 str 为分隔符截取字符串，如果 num 有指定值，则仅截取 num+1 个子字符串
join() 合并为字符串
s1 = "-" s2 = "" seq = ("r", "u", "n", "o", "o", "b") # 字符串序列 print (s1.join( seq )) print (s2.join( seq )) find(str, beg=0, end=len(string)) 检测 str 是否包含在字符串中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1
python 字符串格式化输出 name = '阿昌' print("大家好，我叫%s"%name) lower() str.lower() 转换为小写
upper() str.upper() 转换为大写
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1edbe9b326664ba8ed23c33679053c1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55473d4e8146f71fc570ff02c26aa490/" rel="bookmark">
			红黑树的插入与验证——附图详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 红黑树性质 红黑树的插入前言寻找插入位置情况 1.0情况 1.1情况 1.2情况 1.3 情况 2.0情况 2.1情况 2.2情况 2.3 完整代码红黑树的检验验证代码和用例 红黑树 上篇文章我们说到 AVL 树在新增 / 减少结点的时候会进行旋转以保持 AVL 树的高度平衡, 但是实际上在需要 频繁加入 / 删除结点的场景中, AVL 树在旋转上开销会很大, 总体效率也会较为低下。
故而有这样一个数据结构——红黑树, 这里我们不再讨论平衡因子, 而是维护结点中的颜色（只有红或黑）来间接地调整树的「相对平衡」，也就是说红黑树的平衡并没有 AVL 树那样严格，所以相比 AVL 树，红黑树有的旋转次数会显著减少，我们来具体看看：
性质 如果一棵树是红黑树，它必然有如下性质：（这几条性质建议多熟悉一下）
结点只有红，黑两种属性（显而易见对吧，红黑树嘛）根节点为黑色叶子结点视为黑色，这里的叶子结点指的是最底层的空节点不能存在两个连续的红色节点从「任意节点开始到其后代叶子节点」的简单路径上，有「相同数量的黑色节点」 具备了以上几条性质，我们就能保证：红黑树最长路径是最短路径的两倍
因为在「从任意结点开始到叶子结点具有相同数量的黑色结点」和「不能连续存在两个红色结点」的限制，最短路径就是路径上 N 个点全是 黑色的，最长路径就是这 N 个黑色结点和 N 个红色结点交替出现，长度最多是2 N，故而具备了这个特点。
然后对于红黑树的节点，我们定义为：
private static class RBTreeNode { private RBTreeNode parent; private RBTreeNode left; private RBTreeNode right; private COLOR color; // 结点颜色 int val ; } // 在另一个 Java 文件中 public enum COLOR { BLACK, RED } 红黑树的插入 前言 首先对于一个新节点的插入，这个新节点我们需要先默认设置为红色，那为什么不设置成黑色呢？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55473d4e8146f71fc570ff02c26aa490/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/911ab84a3dcef59982edb4b201a57698/" rel="bookmark">
			JAVA代码编译流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JAVA代码编译流程 前言文本即代码？JDK与JRE的爱恨情仇JRE是JDK的子集编译阶段1. 词法分析&amp;语法分析2. 填充符号表3. 注解处理4. 语义分析4.1 标注检查4.2 数据流分析 5. 解语法塘6. 生成Class文件 前言 写了这么多年的代码，对于Java代码运行的全流程你心里有清晰的脉络吗？
大家是不是跟我最开始一样，觉得在IDE里点一下RUN按钮，我们写的代码就直接跑起来了吧？
俗话说的好，你觉得岁月静好，其实只是因为有人在为你负重前行，编译器和虚拟机默默的承受了这一切。
小小的一个RUN，背后却是很多组件共同努力的结果，它们必须非常努力，才能看起来毫不费力。
问题来了，计算机能看懂我们写的代码？
众所周知，Java是一门"一次编写，到处运行"的语言，也就是所谓的平台无关性，不管在哪个平台都能够运行，且保证运行的结果与期待的一致。
Java实现”平台无关性“的原理也非常简单，就是利用中间格式来进行过渡，也就是我们常说的字节码，通过将Java源码转换成字节码，保证JVM（Java虚拟机）读取到的一定是自己能够识别的字节码格式。
一个通俗的解释：你不会说法语，法国人不会讲中文，但是你们或多或少都会点英语，把英语作为你们的中间格式，保证双方都能明白对方的意思，这就是所谓的跨平台。
Java源码首先被编译成字节码，而这个字节码就是实现平台无关性的关键，无论是什么类型的平台，只要安装了能够识别字节码的JVM（Java虚拟机），通过JVM对字节码文件进行解析，把字节码转换成具体平台上的机器指令，就可以实现跨平台的运行了。
因此别说让计算机底层读到写的代码了，就连Java虚拟机都拿不到我们原汁原味的代码，在编译器的努力下，Java源代码已经变成大白话的Class文件了。
所以，操作系统欣赏不到我们”诗一样的代码“，我们所写的每一行代码，都会变成一条条指令，对操作系统来说，它看到的不是编程的艺术，只是自己需要完成的一条条KPI罢了。
文本即代码？ 如果我们写了具有同样内容的Java文件和txt文本，他们在文本编辑器中长得是没有区别的。
有一句名言是：世界上最好的IDE是txt文本编辑器。现在我们可能用IDE都用顺手了，很多的操作都习惯于让IDE给我们提示，依赖于IDE的代码补全和快捷键。
但在传说中，有一群用记事本就能打出优美代码的大佬，到了这个境界时，已经是人码合一，无需语法高亮，无需补全提示，所有的正确语法都了然于心，打出来的每一行代码都是可以直接编译run起来且零BUG的好代码
扯得有点远，但用记事本确实是可以实现开发功能，只要你自己打的代码逻辑正确，且没有语法错误，最后保存的后缀是.java，就能作为代码去运行了。
因此，从本质来说，我们所打出来的txt文本和Java代码在一开始是没有多大区别的，用普通的文本编辑器也能打开我们的.java后缀的文件。但是文本编辑器能做到的也仅仅限于看到.java文件里面的代码文本而已了。
Java编译器才是最终，能够识别并理解.java文件的存在。
Java代码想要运行起来，第一步就是得到编译器的认可。编译器的任务很简单，就是将符合Java语言源码编译为符合 Java虚拟机规范的Class文件，如果输入的Java源码不符合规范则需要报告错误。
可以说，编译的过程是Java开发的一小步，但也是程序的一大步。
JDK与JRE的爱恨情仇 初学java时，一定安装过所谓的java环境，当我们自信满满地点进了Oracle的Java官网，映入眼帘的是两个看起来很像的安装包
先理清楚所谓的JDK和JRE到底有什么区别吧，来看一张Java 8的体系架构图（https://docs.oracle.com/javase/8/docs/）
JDK全称是Java开发工具包（Java Development Kit），它包含了Java从开发到运行的各种工具。
JRE指的则是Java运行环境（Java Runtime Environment），它包含了基础类库和JVM虚拟机。
上图展示的是Java 8的体系结构，最左边的一栏很清晰的表明了JDK和JRE各自的范围
JRE是JDK的子集 既然你要搞开发，肯定得保证自己写的代码能运行起来吧，所以当开发人员安装好JDK之后里面已经包含了一个运行环境JRE，保证自己的代码能够得到运行和验证，这就是为什么JRE被包含在JDK中。
但如果是普通用户并不关心开发，甚至根本不懂代码，只是想要代码跑起来的结果，那只需要本地有JRE运行环境就行了。
反向思维一下，既然安装JRE就能运行JAVA代码，但要需要完整的JDK才能完成开发，那他们之间的差集肯定跟开发的过程有关。
所以接下来一起炭烤一下为什么缺少这一块内容就只能成为运行环境，而不能承担开发功能呢？
这一块可以看到几个很熟悉的命令：
javac：用于编译java源代码，生成class文件；javap：用于反编译，根据class文件，反解析出其中的汇编指令和其他信息；javadoc：用于生成java文档的命令。 其中，我们最常用的、最重要的就是javac命令。这是JDK中内嵌的编译器，通过这个命令，可以将java源文件转换成class文件。这个javac编译器就是JRE相比于JDK少了开发功能的决定性元素！！
举一个简单的例子看看，开发者编写好的java代码在完整的JDK架构下，经过JDK、JRE以及JVM的运行过程。
可以看到，通过JDK中的javac命令，我们才能将java源代码编译成class文件，而前面也提到了，这个class文件才是最终放到JVM中运行的文件。
java源码到class文件的过程称之为编译阶段，class文件到JVM中运行得到结果的阶段称为运行阶段。
因此，如果只有JRE而没有完整的JDK的话，相当于就少了编译源代码的关键工具，那么只能依赖人家传递的，已经编译好的class代码，将程序运行起来，而不具备修改、开发的能力。
这时你会发现，既然虚拟机运行需要的其实是class文件，因此它对于最前面用的是什么语言其实并不关心，只要支持生成JVM能够识别的字节码就行了。JVM虚拟机跨平台的特征就源于此
很多语言依赖了这种特性，将自己本身的源代码，编译生成class文件，并基于JVM虚拟机运行。比较常用的有Scala和Kotlin等，它们甚至可以跟Java语言相互调用，因为最终都是要编译成class文件到虚拟机中运行嘛，所以即使在源代码阶段是不同的语言，经过编译器之后，大家都变成了一样的字节码。
当然，要是再极端一点，由于class文件本质上也是一个二进制的文件，因此只要你足够强，能够徒手写出自己需要的二进制文件，你也就不再需要编译器了
很多读者就要说了：”我们是来学技术的，不是来学仙术的“。
先别笑，直接改字节码并不是什么天上飞的仙术，而是实打实的技术。像我们熟悉的lombok，就能够根据我们编写的注解生成字节码，实现字节码的修改增强（lombok就是利用了编译器的一些特性，是在编译阶段触发操作的）。
类似的还有诸如ASM等一些字节码增强技术，也是通过直接操作字节码来实现的。
通过字节码增强技术可以实现热部署等操作，让你修改代码之后无需重启服务就能生效；也可以实现日志注入等功能，在不需要改变客户端调用方式情况下完成对指定方法增加缓存或日志的功能。
但对于大部分的普通开发者来说，编译器还是必不可少的。
编译阶段 当调用javac命令，触发java代码的编译过程，将.java文件编译成了.class二进制文件。
那么，在编译器中，源代码到底是怎么一步步变化的呢。
注意：javac是javac编译器的自带的命令，但市面上可用的并不只有javac这一种编译器，有一些其他的厂商也根据java的标准开发了自己的编译器。例如Eclipse的ecj（the Eclipse Compiler for Java）等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/911ab84a3dcef59982edb4b201a57698/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06da3c707e13fbb0f27afd99dc9f321a/" rel="bookmark">
			CAS号：143364-95-8,十三肽KKSRGDYMTMQIG
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Axltide 是基于小鼠胰岛素受体的底物1 (氨基酸 979-989)。Axltide 是 Axl、DDR2、Mst1和JAK2激酶的底物。
Axltide is based on the mouse Insulin receptor substrate 1 (amino acid 979-989). Axltide is a substrate for Axl, DDR2, Mst1, and JAK2 kinases[1].
编号: 140432
中文名称: 十三肽KKSRGDYMTMQIG
英文名: KKSRGDYMTMQIG
CAS号: 143364-95-8
单字母: H2N-KKSRGDYMTMQIG-OH
三字母: H2N-Lys-Lys-Ser-Arg-Gly-Asp-Tyr-Met-Thr-Met-Gln-Ile-Gly-COOH
氨基酸个数: 13
分子式: C63H107N19O20S2
平均分子量: 1514.77
精确分子量: 1513.74
等电点(PI): 10.91
pH=7.0时的净电荷数: 2.97
平均亲水性: 0.39090909090909
疏水性值: -1.09
来源: 人工化学合成，仅限科学研究使用，不得用于人体。
纯度: 95%、98%
盐体系: 可选TFA、HAc、HCl或其它
生成周期: 2-3周
储存条件: 负80℃至负20℃
标签: RGD、RAD肽 酶底物肽
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06da3c707e13fbb0f27afd99dc9f321a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24450b49ca43f07be48752e47dd8006c/" rel="bookmark">
			Word查找技巧：批量删除文档中空格、空行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在日常工作中我们经常会碰到以下2个困扰：
如，很多网上下载或拷贝到Word的纯文本形式的资料，最烦的莫过于文档中有一大堆空格或空行（回车符），格式非常混乱，完全不符合排版要求，如图所示。如果要一行一行的删除它们，却费时费力。
为了快速让文本规范整洁，效果如图所示。
接下来，教大家2个小妙招，只需几秒钟，让你轻松删除所有空格、空行。
1、批量删除空格
（1）点击【开始】-【编辑】-【替换】按钮或按【Ctrl+H】组合键，打开“查找与替换”对话框，将鼠标光标定位于“查找内容”文本框中，然后点击“更多”按钮。
（2）展开“替换”栏，点击“特殊格式”按钮，在弹出菜单中选择“空白区域”选项。
（3）点击“全部替换”按钮，在“全部完成”的提示框中单击“确定”按钮，所有空格即被删除。
2、批量删除空行
Word中，回车符又称为段落标记，一个回车符表示一行结束，所以删除空行就是删除多余的回车符（段落标记），简单来说，就是把多个连续的回车符（段落标记）换成一个回车符，方法如下：
（1）打开“查找与替换”对话框，将鼠标光标定位于“查找内容”文本框中，然后点击“更多”按钮。
（2）展开“替换”栏，点击“特殊格式”按钮，在弹出菜单中选择“段落标记”选项。此时，会发现“查找内容”文本框中自动添加了^p。（但这里需要注意，空行是由多个连续的回车符（段落标记）形成）。因此，我们需要在【查找内容】中输入两个^p^p，表示查找两个连续的段落标记；而在【替换为】文本框中输入1个^p，表示将查找到的内容替换为1个段落标记。
（3）点击“全部替换”按钮，在“全部完成”的提示框中单击“确定”按钮，所有空行即被删除。
提示：
如果在“查找内容”中输入1个^p，或“替换为”的内容为空，则文档中所有回车符（段落标记）都会被删除，所有内容会成为一个段落。
反之，如果我们想要添加空行，则可把替换内容颠倒过来：
此外，如果文档中空行处不是回车样式的段落标记，而是向下箭头的手动换行符（即按Shift+Enter键形成的空行)，如图所示，该怎么办？
对于手动换行符形成的空行，可在替换时选择"特殊字符"中的"手动换行(L)" 选项两次，即“查找内容”中输入2个"^l^l"；替换为中输入"^P"，空行即可删除。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2590b06c3eff4c79e0e07ede7e991c36/" rel="bookmark">
			C语言_函数(Function)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@/" 1&gt; 函数概述2&gt; 函数分类3&gt; 函数声明3.1&gt; 函数名3.2&gt; 形参列表3.3&gt; 返回值类型3.4&gt; 函数声明位置 4&gt; 函数定义5&gt; 函数调用 1&gt; 函数概述 函数声明，函数定义，函数调用
#include &lt;stdio.h&gt; /* 子函数声明 */ int add(int a, int b); /* 主函数 */ int main() { int c = 0; /* 函数调用 */ c = add(5, 6); printf("c = %d", c); return 0; } /* 子函数定义 */ int add(int a, int b) { return a + b; } 函数是程序的基本单元；
把复杂问题，模块化；
2&gt; 函数分类 //--------------------------// 按返回值类型分类： 1&gt; 返回值为int，就称整型函数； 2&gt; 返回值为double，浮点型函数； .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2590b06c3eff4c79e0e07ede7e991c36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bf93b3bac23832fc2ad91688d99d8b5/" rel="bookmark">
			基于docker-k8s的web集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
网络拓扑图
基于docker-k8s的web集群搭建
项目描述
详细步骤
1、集群ip地址的规划
2、Ansible批量部署服务器
3、创建k8s集群
4、配置NFS服务
5、pv，pvc，与NFS融合
6、配置Nginx负载均衡
7、 使用prometheus监控整个Docker-K8S集群
​​​​​​​
网络拓扑图 基于docker-k8s的web集群搭建 项目描述 实现一个高可用的负载均衡器的Web服务器集群，使用Kubeadm搭建K8s集群，底层采用K8s管理的Docker集群来提供Web服务，大量使用容器来完成Web服务的扩展性、高可用性。
详细步骤 1、集群ip地址的规划 master ：192.168.44.31 k8s master节点
node1 ：192.168.44.32 k8s node1节点
node2 ：192.168.44.33 k8s node2节点
Ansible-server ：192.168.44.34 ansible 服务器
NFS-server：192.168.44.35 nfs服务器
Nginx-server ：192.168.44.36 nginx负载均衡服务器
prometheus ：192.168.44.37 prometheus监控服务器
######################################################################## 2、Ansible批量部署服务器 使用ansible服务器给所有服务器之间建立免密通道
[root@ansible-server ~]# ssh-keygen -t rsa Generating public/private rsa key pair. Enter file in which to save the key (/root/.ssh/id_rsa): Created directory '/root/.ssh'. Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /root/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8bf93b3bac23832fc2ad91688d99d8b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df7799dfba3c8590f5cea44e1438e16d/" rel="bookmark">
			wireshark工具详解、数据包抓取分析、使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Wireshark界面 Wireshark查看数据捕获列表 数据包概要信息窗口：描述每个数据包的基本信息。如图，点击某行数据，即可在下方显示该数据包的信息。
1、数据包解析窗口：显示被选中的数据包的解析信息，包含每个数据包的整体信息、数据链路层、网络层、传输层、应用层的信息，可以点击每层信息的左侧的三角形的下拉选项，打开每层信息的详细解析。
2、数据包数据窗口：显示该数据包的具体数据内容，最左侧的“0000、0010…"为该行数据在整个数据包中的整体偏移量，所有数据以 16 进制显示。
每层信息的左侧的三角形的下拉选项，打开每层信息的详细解析。
3、数据包数据窗口：显示该数据包的具体数据内容，最左侧的“0000、0010…"为该行数据在整个数据包中的整体偏移量，所有数据以 16 进制显示。
wireshark过滤器表达式的规则 根据过滤器可以快速捕获或者查找相应的数据包
抓包过滤器语法和实例
1、抓包过滤器类型Type（host、net、port）、 2、方向Dir（src、dst）、 3、协议Proto（ether、ip、tcp、udp、http、icmp、ftp等）、 4、逻辑运算符（&amp;&amp; 与、|| 或、！非） （1）协议过滤
比较简单，直接在抓包过滤框中直接输入协议名即可。
TCP，只显示TCP协议的数据包列表
HTTP，只查看HTTP协议的数据包列表
ICMP，只显示ICMP协议的数据包列表
（2）IP过滤
原地址（请求本机ip） 和目标地址（响应主机ip）查询
1.原地址查询：ip.src_host == 192.168.1.111
2.目标地址查询：ip.dst_host == 33.110.192.103
3.原地址和目标地址组合查询：
ip.src_host == 192.168.1.111 or ip.dst_host == 33.110.192.103
不分原地址和目标地址，两者中只要其中一个符合即可：
（3）端口过滤
tcp.port 80, 显示源主机或者目的主机端口为80的数据包列表。
tcp.srcport == 80, 只显示TCP协议的源主机端口为80的数据包列表。
tcp.dstport == 80，只显示TCP协议的目的主机端口为80的数据包列表
（5） Http模式过滤
http.request.method“GET”, 只显示HTTP GET方法的。
Wireshark三次握手四次挥手推荐文章 : Wireshark三次握手四次挥手 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fe3014d764a786fd2be64caf45ced0e/" rel="bookmark">
			SSM框架-Spring(二)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 手写spring框架
2 Spring IoC注解式开发
2.1 回顾注解
2.2 声明Bean的注解
2.3 Spring注解的使用
2.4 选择性实例化Bean
2.5 负责注入的注解
2.5.1 @Value
2.5.2 @Autowired与@Qualifier
2.5.3 @Resource
2.6 全注解式开发
3 JdbcTemplate
3.1 环境准备
3.2 新增
3.3 修改
3.4 删除
3.5 查询一个对象
3.6 查询多个对象
3.7 查询一个值
3.8 批量添加
3.9 使用回调函数
3.10 使用德鲁伊连接池
4 GoF之代理模式
4.1 代理模式的理解
4.2 静态代理
4.3 动态代理
4.3.1 JDK动态代理
4.3.2 CGLIB动态代理
5 面向切面编程AOP
5.1 AOP介绍
5.2 AOP的七大术语
5.3 切点表达式
5.4 使用Spring的AOP
5.4.1 准备工作
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fe3014d764a786fd2be64caf45ced0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39e7ec61788d18001b16befe0f3108fb/" rel="bookmark">
			25条提高SQL运行效率的方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这些准则不仅适用于熟悉SQL语句的玩家，而且适用于新手，可以多看几遍
1、查询SQL尽量不要使用select *，而是select具体字段。 反例：
select * from employee; 正例：
select id，name from employee; 理由：
只取需要的字段，节省资源、减少网络开销。select * 进行查询时，很可能就不会使用到覆盖索引了，就会造成回表查询。 2、如果知道查询结果只有一条或者只要最大/最小一条记录，建议用limit 1 假设现在有employee员工表，要找出一个名字叫jay的人.
CREATE TABLE `employee` ( `id` int(11) NOT NULL, `name` varchar(255) DEFAULT NULL, `age` int(11) DEFAULT NULL, `date` datetime DEFAULT NULL, `sex` int(1) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 反例：
select id，name from employee where name='jay' 正例：
select id，name from employee where name='jay' limit 1; 理由：
加上limit 1后,只要找到了对应的一条记录,就不会继续向下扫描了,效率将会大大提高。当然，如果name是唯一索引的话，是不必要加上limit 1了，因为limit的存在主要就是为了防止全表扫描，从而提高性能,如果一个语句本身可以预知不用全表扫描，有没有limit ，性能的差别并不大。 3、应尽量避免在where子句中使用or来连接条件 新建一个user表，它有一个普通索引userId，表结构如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39e7ec61788d18001b16befe0f3108fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eeb21275ac242bfe5af2186426b77c62/" rel="bookmark">
			为什么使用WebFlux
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WebFlux 一、Reactive Programming（响应式编程)1、变化传递（propagation of change)2、数据流（data stream）3、声明式（declarative）4、总结 二、Reactive Stream（响应式流）1、阻塞、非阻塞以及同步、异步2、流量控制—回压 三、Reactor1、 Mono 与 Flux2、subscribe；订阅前什么都不会发生3、 操作符4、 异常处理5、调度器与线程模型 四、WebFlux1、Pom2、Controller3、Service4、压力测试效果 一、Reactive Programming（响应式编程) 响应式编程（reactive programming）是一种基于数据流（data stream）和变化传递（propagation of change）的声明式（declarative）的编程范式。
推荐博文：https://blog.51cto.com/liukang/2090163
1、变化传递（propagation of change) 举个简单的例子，某电商网站正在搞促销活动，任何单品都可以参加“满 199 减 40”的活 动，而且“满 500 包邮”。
“商品金额”是通过“单价 x 数量”得到的，“满 199 减 40”会判断该商品金额是否满 199 并根据 情况减掉 40，右侧“订单总金额”是“满 199 减 40”这一列的和，“邮费”会根据订单总金额计 算，“最终应付款”就是订单总金额加上邮费。
响应式的核心特点之一：变化传递（propagation of change）。一个单元格变化之后，会像多米诺骨牌一样，导致直接和间接引用它的其他单元格均发生相应变化。
生产者只负责生成并发出数据/事件，消费者来监听并负责定义如何处理数据/事件的变化传递方式。
2、数据流（data stream） 数据/事件在响应式编程里会以数据流的形式发出。
小明选购商品的过程，为了既不超预算，又能省邮费，有时加有时减
这一次一次的操作就构成了一串数据流，如果我们能够及时对数据流的每一个事件做出响应，会有效提高系统的响应水平。这是响应式的另一个核心特点：基于数据流（data stream）。
public Invoice(Cart cart) { ... this.listenOn(cart.eventStream()); // 1 ... } //cart.eventStream()是要监听的购物车的操作事件数据流，listenOn 方法能够对数据流中到来的元素依次进行处理。 3、声明式（declarative） 我们再到 listenOn 方法去看一下： Invoice 模块中，上边的一串公式被组装成如下的伪代码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eeb21275ac242bfe5af2186426b77c62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d09df74df9cfaecdbd209227dfa1d442/" rel="bookmark">
			测试平台python函数驱动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何选择 前端使用的是vue3，看到很多代码编辑器都是vue2版本，所以当时选的时候花了比较长的时间，中间用了vue3-ace-editor和vue-codemirror这两个组件，但是效果都没有Monaco Editor的好，所以后面又替换掉
效果图 代码 关于自动补全，默认下的keywords只要140多个，对自动补全不是很友好
实现自定义关键字来补全，可以添加自己常用的库，只需要修改keywords字段就可以实现
在python代码中的lib加上自己常用的库，修改javascript中keywords为python的数据结果即可
由于只用了python语言，所以直接屏蔽掉其他语言，主题也选择自己看着比较顺眼的
from importlib import import_module def is_public(name): return not (name.startswith('__') and name.endswith('__')) def get_functions(source): return [name for name in dir(source) if callable(getattr(source, name)) and is_public(name)] lib = ['requests', 'math', 'datetime', 'string', 're', 'os', 'io', 'time'] func = ['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'exec', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'print', 'raise', 'return', 'try', 'while', 'with', 'yield', 'int', 'float', 'long', 'complex', 'hex', 'abs', 'all', 'any', 'apply', 'basestring', 'bin', 'bool', 'buffer', 'bytearray', 'callable', 'chr', 'classmethod', 'cmp', 'coerce', 'compile', 'complex', 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'execfile', 'file', 'filter', 'format', 'frozenset', 'getattr', 'globals', 'hasattr', 'hash', 'help', 'id', 'input', 'intern', 'isinstance', 'issubclass', 'iter', 'len', 'locals', 'list', 'map', 'max', 'memoryview', 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property', 'reversed', 'range', 'raw_input', 'reduce', 'reload', 'repr', 'reversed', 'round', 'self', 'set', 'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'unichr', 'unicode', 'vars', 'xrange', 'zip', '__dict__', '__methods__', '__members__', '__class__', '__bases__', '__name__', '__mro__', '__subclasses__', '__init__', '__import__'] for j in lib: func.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d09df74df9cfaecdbd209227dfa1d442/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/121/">«</a>
	<span class="pagination__item pagination__item--current">122/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/123/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>