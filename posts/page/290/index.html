<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1937b010f1b8a7f0cef3abcc2b06288f/" rel="bookmark">
			scrapy入门小案例--爬取电影天堂最新电影下载地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文开发环境：ubuntu16.04 + scrapy1.5 + python3.5 + pycharm2017.03 scrapy学习也有段时间了，刚开始也是跟着视屏一点点学习，看着挺简单的，到了动手的时候就不知道如何下手。现在通过一个小案例来总结下如何使用，如果能帮到你那我就很欣慰了。
必备技能：
python基础 推荐廖雪峰python教程网页基础 W3Cschoolxpath 推荐W3Cschool Xpath教程 正文
我们来看看电影天堂的网站结构。我们进入最新电影。 这里可以看到这里有很多电影，我们看到总共有173页。 光有下载连接可不行，我们还要电影的名称和上传时间。 下面看看怎么提取。 先回到第一页，然后CTRL + shift + X打开xpath helper，在电影名称上面右键–检查—copy–copy xpath，粘贴入Query那一栏，单击，看看是不是取到了名称，哈哈。 但是只是取到了一个，我们要这一页的全部名称，而且这么长的xpath表达式看着一点也不优雅。我们我们来修改下。 通过观察，我们所需要的内容是在一个&lt;div class="co_content8"&gt;里面的。 所以，我们的xpath规则可以写成（名称）
//div[@class='co_content8']/ul/table//a/text() 是不是都取到了电影名称。哈哈。同理上传日期：
//div[@class='co_content8']/ul/table//tbody//font/text() 名称和时间都取到了，让我们看看怎么取每部电影的下载地址。进入详情页。打开xpath helper，F12进入调试模式。可以看到有两个下载地址。既然这样，那就全要了。 FTP:
//tbody//td[@style="WORD-WRAP: break-word"]//a/@href[0] 迅雷：
//tbody//td[@style="WORD-WRAP: break-word"]//a/@href[1] 现在我们已经取到第一页的数据，那如何跟进取到后面所有页的数据呢？一种办法是在第一页取到下一页的链接，然后进入下一页取数据。当然有第二种方法。我们右键查看源代码的时候，鼠标拉到最下边，可以看到：
&lt;option value='list_23_1.html' selected&gt;1&lt;/option&gt; &lt;option value='list_23_2.html'&gt;2&lt;/option&gt; &lt;option value='list_23_3.html'&gt;3&lt;/option&gt; 这里列出了全部页面的链接。只要我们取到value的值，就可以遍历所有的页面了，哈哈，是不是很方便？电影天堂详情页虽然乱七八糟，但一点还是很赞的。 那我们怎么取到value的值，一样的。
这里注意一下，有些xpath规则在xpath helper里面正常，但到了scrapy就不行。原因就是在浏览器加载页面的时候帮我们优化了，而scrapy取到的是网页源代码。这就是个坑。所以，提取规格的时候要在scrapy shell验证好。
取全部页面链接的xpath规则：
//table//b/a/@href 好了，现在我们就可以开始写代码了。
在命令行中：
scrapy startproject Dianying 然后使用scrapy创建默认spider文件：
scrapy genspider dytt "www.ygdy8.net" 我的目录结构是这样的： 1. 编写要爬取的内容items.py
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1937b010f1b8a7f0cef3abcc2b06288f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e75b20c8717dce4476f6ece93bd27d37/" rel="bookmark">
			【MySQL】死锁案例之七
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 前言 死锁，其实是一个很有意思也很有挑战的技术问题，大概每个DBA和部分开发同学都会在工作过程中遇见 。关于死锁我会持续写一个系列的案例分析，希望能够对想了解死锁的朋友有所帮助。 二 案例分析 2.1 业务场景 业务开发同学想同步数据，他们的逻辑是通过update 更新操作，如果更新记录返回的affect_rows为0，然后就调用insert语句进行插入初始化。如果插入失败则再进行更新操作，多个会话并发操作的情况下就出现死锁。 2.2 环境说明 MySQL 5.6.24 事务隔离级别为RR create table ty ( id int not null primary key auto_increment , c1 int not null default 0, c2 int not null default 0, c3 int not null default 0, unique key uc1(c1), unique key uc2(c2) ) engine=innodb ; insert into ty(c1,c2,c3) values(1,3,4),(6,6,10),(9,9,14); 2.3 测试用例 sess1 sess2 begin; begin; T1 update ty set c3=2 where c2=4; T2 update ty set c3=2 where c2=4; T3 insert into ty (c1,c2,c3) values(3,4,2); T4 insert into ty (c1,c2,c3) values(3,4,2); ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e75b20c8717dce4476f6ece93bd27d37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4023f70aa653f8cc169ec13ecd39b03/" rel="bookmark">
			航迹规划——Dubins曲线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Dubins曲线简介 Dubins曲线是在满足曲率约束和规定的始端和末端的切线方向的条件下，连接两个二维平面（即X-Y平面）的最短路径，并假设车辆行驶的道路只能向前行进。如果车辆也可以在反向行驶，则路径为Reeds–Shepp曲线。 在1957念, Lester Eli Dubins (1920–2010) 证明任何路径都可以由最大曲率和/或直线段组成（两点之间的路径必须存在）。 换句话说，连接两点的最短路径将通过最大曲率的曲的圆弧和直线段的构成。 后来Pontryagin的最大原则证明了相同的结果。 如图1所示，A是目标点，B是起始点，A、B两点的方向均为箭头所指方向（竖直向上），则从点B到点A的最短路径为紫色线段，此处的紫色线段即为Dubins曲线。
Dubins曲线通常用于机器人和控制理论领域，作为规划轮式机器人、飞机和水下车辆路径的一种方式。
Dubins分析 例如，在轮式机器人的情况下，系统的简单运动学模型是： 其中（x，y）是汽车的位置，θ 是航向，汽车以恒定速度移动 V，转弯速度控制 u 是有界的。 在这种情况下，最大转弯速率对应于某个最小转弯半径（以及等效的最大曲率）。 规定的初始和终端切线方向对应于初始和终端坐标。 Dubins 路径给出了两个定向点的最短路径，这对于轮式机器人模型是可实际运行路线。
最佳路径类型可以用与右转（R），左转（L）或驾驶’直（S）’的汽车类比来描述。 最佳路径总是至少有六种类型之一：RSR，RSL，LSR，LSL，RLR，LRL。 例如，考虑到对于某些给定的初始位置和最终位置以及切线，最佳路径显示为“RSR”类型。 然后这对应于右转弧（R），接着是直线段（S），接着是另一个右转弧（R）。 沿着这个序列中的每个段移动适当的长度将形成最短的曲线，它将起始点A连接到终点B，并在每个端点处具有所需的切线并且不超过给定的曲率。 例如： RSL Dubins 路径 RSR Dubins 路径 LRL Dubins 路径 Dubins曲线存在的问题 Dubins间隔问题是Dubins路径问题的一个关键点，即在初始点和终点指定了航向的间隔。 也就是说路径在初始点和终点处的切线方向被限制在指定的间隔内。 Matlab代码 图1中Matlab代码可以直接运行~
参考文献 Dubins_path
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72930fec153d68b9363d64c87cb32d88/" rel="bookmark">
			Python入门三：安装Pyqt5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装
1、官网：www.riverbankcomputing.com
2、使用命令安装，可以自动去官网查找与Python版本号相同的程序进行下载，比较方便，如果不是这样也可从PyQt官网上下载与Python相匹配的程序文件
3、安装PYQT前，首先安装 SIP 运行--&gt;CMD--&gt;pip3 install Sip 4、安装PyQt5 执行命令：pip3 install PyQt5
5、安装PyQt5 tools
pip install PyQt5-tools -i http://pypi.douban.com/simple --trusted-host=pypi.douban.com
安装完成后，在./Python/Lib/site-packages/pyqt5-tools目录下可找到designer.exe
6、添加环境变量
QT_QPA_PLATFORM_PLUGIN_PATH
D:\Python\Python36\Lib\site-packages\PyQt5\Qt\plugins 二、配置PyCharm
1、打开PyCharm，执行快捷键ctrl+alt+s打开设置界面，输入tool，点开external tools，配置qtdesigner。
点击左上角的加号，作如下配置：
在Qt Designer的设置中，Program选择PyQt安装目录中 designer.exe 的路径
Work directory 使用变量 $FileDir$ 2、设置“PyUIC” -- 这个主要是用来将 Qt界面 转换成 py代码
在PyUIC的设置中，其他的都差不多，Program 写入Python的地址，Parameters写入
-m PyQt5.uic.pyuic $FileName$ -o $FileNameWithoutExtension$.py
把上面的Python路径修改成自己的即可！
Work directory 使用变量 $FileDir$
三、安装异常及解决
1、安装 SIP异常
到 https://pypi.python.org/pypi/pip
选择第二个；下载后,解压缩
进入解压的文件,安装
python setup.py install
查看版本 pip --version
安装成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2fede20dc9fd5aaea0d18edbd01015b/" rel="bookmark">
			高空坠球 【物理】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		7-3 高空坠球（20 分）
皮球从某给定高度自由落下，触地后反弹到原高度的一半，再落下，再反弹，……，如此反复。问皮球在第n次落地时，在空中一共经过多少距离？第n次反弹的高度是多少？ 输入格式:
输入在一行中给出两个非负整数，分别是皮球的初始高度和n，均在长整型范围内。 输出格式:
在一行中顺序输出皮球第n次落地时在空中经过的距离、以及第n次反弹的高度，其间以一个空格分隔，保留一位小数。题目保证计算结果不超过双精度范围。 输入样例:
33 5
输出样例:
94.9 1.0
思路
模拟这个过程就可以了 但是要注意 n == 0 的情况 剩用 –n
AC代码
#include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;ctype.h&gt; #include &lt;cstdlib&gt; #include &lt;cmath&gt; #include &lt;climits&gt; #include &lt;ctime&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;deque&gt; #include &lt;vector&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;map&gt; #include &lt;stack&gt; #include &lt;set&gt; #include &lt;numeric&gt; #include &lt;sstream&gt; #include &lt;iomanip&gt; #include &lt;limits&gt; #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std; typedef long long ll; typedef long double ld; typedef unsigned long long ull; typedef pair &lt;int, int&gt; pii; typedef pair &lt;ll, ll&gt; pll; typedef pair&lt;string, int&gt; psi; typedef pair&lt;string, string&gt; pss; const double PI = 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2fede20dc9fd5aaea0d18edbd01015b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff5e05f9e9eedf95e7cb156304c5be61/" rel="bookmark">
			was cached in the local repository, resolution will not be reattempted until the update interval of
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		was cached in the local repository, resolution will not be reattempted until the update interval of nexus has elapsed or updates are forced -&gt;
Maven 报错
解决办法:
1 一种可能就是本地没有下载完整，这里的原因可能第一次下载由于网络原因不成功，之后maven也没在尝试。
2 另一种情况就是我们依赖的nexus也没有下载完整，这时候可能是配置的中央仓库代理仓库根本就不存在此jar，或者需要在第三方仓库中才能找到，此时我们应该尝试检查和配置代理仓库。
参考资料：
1、Maven依赖中类似was cached in the local repository样的错误 https://blog.csdn.net/shierqu/article/details/44787025
2、was cached in the local repository, resolution will not be reattempted until https://blog.csdn.net/zyf_balance/article/details/47171723
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18dec83d6f4e180e566899207c191161/" rel="bookmark">
			MySQL请求处理过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.客户端发送SQL请求给服务器
2.服务器检查是否可以在查询缓存中命中该SQL
3.服务器端进行SQL解析，预处理，再由优化器生成对应的执行计划
这个阶段包括多个子过程：解析SQL，预处理，优化SQL执行计划
4.根据执行计划，调用存储引擎API来查询数据。
5.将结果返回到客户端。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3347990d66616499930890a695f30da/" rel="bookmark">
			BGP13条选路原则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BGP选路原则 最高有weight优先，默认为0(思科特有，选大的)
本地优先级高的优先（只可以在IBGP邻居之间传递）
起源本路由器上的路由（network、aggregate-address）
as-path最短的优先
最小的起源代码 (IGP 优先 EGP 优先 incomplete)
最低的med
ebgp&gt;ibgp
通过最近BGP邻居的路由
如果配置了maixmum-path[IBGP]，就负载均衡
最老的EBGP邻居学到的路由,是路由最老
更低的router-id
始发路由器ID相同，那么选择 cluster-list短的
优选来自于最低的邻居地址的路径，是BGP的neigbor配置中地址 一、Weight值
简介：
1.优选有最大Weight的路由(范围0到65535)，weight是CISCO私有的参数。
2. 缺省情况下，通过本路由器宣告、重分布或者汇总的路由的weight为32768，从BGP邻居学习到的路由的weight为0。
3：只在本地(影响自己一个路由器)有用，影响本路由的选路。
修改方法：
1、neighbor xxx weight xxx (从此xxx邻居学到的所有的路由都加)
2、route-map xxx permit 10 set weight xxx
只能在本路由器的入方向上做。
二、local-prefrence 理论简介：
1.通过第一条选路原则不能选出最优BGP条目的情况下，优选有最大local preference值的BGP条目。
2.local preference值只在IBGP邻居之间传递，在EBGP邻居之间不能传递，也就是说不能在EBGP的出方向上做,因为只在本AS内生效。
3.对于从EBGP邻居学习到的BGP条目，local preference缺省值为100，这个值可以通过命令bgp default local-preference修改。
修改方法：
（1）bgp default local-preference xxx
修改后，对IBGP学来的路由不起作用，只对EBGP传来的和自己产生的路由起作用。
（2）route-map xxx permit 10
set local-preference xxx
（3）不能在EBGP邻居关系的出方向做修改。
3、local-preference的默认值是100
在show ip bgp 中看到是空，其实也是100，show ip bgp xxxx 看明细的时候可看见路由的local-preference。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3347990d66616499930890a695f30da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e526f20fc979f90098e45a5d1934feef/" rel="bookmark">
			简述 TensorFlow 计算模型——计算图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Tensorflow 是一个通过计算图的形式来表述计算的编程系统，计算图也叫数据流图，可以把计算图看做是一种有向图，Tensorflow 中的每一个计算都是计算图上的一个节点，而节点之间的边描述了计算之间的依赖关系。
一个计算图实例： relu = tf.nn.relu(tf.matmul(w, x) + b) TensorFlow 的计算机制 TensorFlow 中的 Tenso r表示张量（多维数组），TensorFlow 中的 Flow 表示张量之间通过计算流相互转换的过程。TensorFlow 的每一个计算都是图上的一个节点，节点之间的边描述了节点之间的依赖关系。
TensorFlow 程序一般分为两个阶段：
构建过程：会构建出一个图（graph），即所谓的计算图（computation graph）;执行过程：使用 session 执行构建过程中生成的图中的操作。 代码示例： import tensorflow as tf #定义两个常量向量a b a = tf.constant([1.0,2.0],name="a") b = tf.constant([2.0,3.0],name="b") #将两个向量加起来 result = a+b #生成一个会话 sess = tf.Session() #通过会话来计算结果 xxx = sess.run(result) print(result) #Tensor("add:0", shape=(2,), dtype=float32) print(xxx) #[ 3. 5.] sess.close() 从程序运行截图可辅助理解 TensorFlow的 计算模型机制。张量中并没有真正的保存数字，它保存的只是如何得到这些数字的计算过程。例如实例代码中的 result 输出结果为Tensor(“add:0”, shape=(2,), dtype=float32)–add:0表示 result 这个张量是计算节点“add”输出的第一个结果；shape=(2,) 标识张量的维度信息，说明了张量 result 是一个一维数组，数组长度为2；dtype=float32 标识张量的类型为浮点型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e526f20fc979f90098e45a5d1934feef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64c49ec63859a92a5727809aec45cd86/" rel="bookmark">
			Hive整合HBase完整笔记（亲测）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hive与HBase整合文档 1、 Hive整合HBase配置
1.1 拷贝hbase 相关jar包
将hbase 相关jar包拷贝到hive lib目录下
hbase-client-0.98.13-hadoop2.jar
hbase-common-0.98.13-hadoop2.jar
hbase-server-0.98.13-hadoop2.jar
hbase-common-0.98.13-hadoop2-tests.jar
hbase-protocol-0.98.13-hadoop2.jar
htrace-core-2.04.jar
hive-hbase-handler-1.0.0.jar
zookeeper-3.4.5.jar
1.2 修改hive-site.xml配置文件
将上述jar包添加到hive-site.xml配置的hive.aux.jars.path属性中。
修改hive.zookeeper.quorum属性
添加hbase.zookeeper.quorum属性，此属性hive-site.xml之前不存在。
1.3 修改hive-env.sh配置文件
同默认配置文件中copy一份hive-env.sh文件
修改hive-env.sh配置文件
1.4 启动Hive
上述配置完成之后，通过bin/hive命令启动hive
如果出现以上输出信息，说明hive整合hbase成功。
2、 Hive整合HBase后使用
2.1 准备测试数据
（1）测试数据文件
创建测试文件course.csv
第一列为课程名称，第二列为课程分数
（2）数据加载到HDFS
在hdfs文件系统中创建hive-hbase目录，并加载测试数据。
查看hdfs文件目录
创建/hive-hbase/course目录
将course.csv文件上传至/hive-hbase/course目录下
（3）创建Hive数据库
进入Hive Shell 客户端创建库course
（4）创建Hive表
进入Hive Shell 客户端创建外部表。
create external table if notexists course.testcourse(cname string,score int) row format delimited fieldsterminated by '\t' stored as textfile location '/hive-hbase/course';
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64c49ec63859a92a5727809aec45cd86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74f02c771c10b5f26707534f2dea295a/" rel="bookmark">
			Spring源码分析之BeanPostProcessor接口和BeanFactoryPostProcessor接口方法不执行原因分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		过程分析的很精彩，原文转载：https://blog.csdn.net/u011734144/article/details/72600932
首先下面是我的Bean
[html] view plain copy /* * Copyright 2002-2017 the original author or authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74f02c771c10b5f26707534f2dea295a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77cb9ac1fb16b08cb7d500bf50ab50d6/" rel="bookmark">
			Python Django 集成Redis Sentinel（哨兵）集群开发秒杀系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们知道秒杀系统最大特点是瞬时高并发、高访问量的系统。我们还要保证它的高可用性。
这里我们采用Python Django 集成Redis Sentinel（哨兵）集群开发秒杀系统。
Redis Sentinel（哨兵）集群
Redis哨兵为Redis集群提供了高可用性。实际上这意味着我们可以使用哨兵模式创建一个可以不用人为干预而应对各种故障的Redis集群部署。可大大提高系统的高可用性。
哨兵模式还提供了其他的附加功能，如监控，通知，为客户端提供配置。
下面是在宏观层面上哨兵模式的功能列表：
监控：哨兵不断的检查master和slave是否正常的运行。通知：当监控的某台Redis实例发生问题时，可以通过API通知系统管理员和其他的应用程序。自动故障转移：如果一个master不正常运行了，哨兵可以启动一个故障转移进程，将一个slave升级成为master，其他的slave被重新配置使用新的master，并且应用程序使用Redis服务端通知的新地址。配置提供者：哨兵作为Redis客户端发现的权威来源，客户端连接到哨兵请求当前可靠的master的地址。如果发生故障，哨兵将报告新地址。 Redis哨兵是一个分布式系统,采用多个哨兵对一个master不再可用达成一致时执行故障检测。这会降低错误判断的概率。即使在不是所有的哨兵都工作时哨兵也会工作，使系统健壮的抵抗故障。
我们课程采用三Redis哨兵集成Redis实例(master和slave)集群来构建秒杀系统的缓存系统。
秒杀系统部署图：
秒杀系统涉及主要技术有：
Pytho Django 开发；Django web 页面静态化；Python Redis Sentinel（哨兵）集群开发；Redis 管道、事务实现对秒杀库库的管理；Redis队列对访问流量进行分流；Redis Sentinel（哨兵）集群；Nginx 负载均衡、反向代理等；高并发的Gunicorn web应用服务；Supervisor管理进程；Django应用部署；分布式集群部署； ...... 对相关技术有兴趣的，可访问我们的课程51CTO学院:升职加薪视频课程：高并发秒杀系统架构分析设计与开发 转载于:https://blog.51cto.com/13340781/2091092
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e14839a1b86d19ae39a4620883dec881/" rel="bookmark">
			java-FFmpeg读取视频随机截图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package per.qy.dexter.video; import java.awt.image.BufferedImage; import java.io.FileOutputStream; import java.io.IOException; import java.util.ArrayList; import java.util.List; import java.util.UUID; import javax.imageio.ImageIO; import org.bytedeco.javacv.FFmpegFrameGrabber; import org.bytedeco.javacv.Frame; import org.bytedeco.javacv.Java2DFrameConverter; import org.junit.Test; public class FFmpegTest { @Test public void splitVideo() { FFmpegFrameGrabber frameGrabber = null; try { frameGrabber = FFmpegFrameGrabber.createDefault("d:/111.mp4"); frameGrabber.start(); long frameTime = frameGrabber.getLengthInTime() / 1000000; int frameLength = frameGrabber.getLengthInFrames(); List&lt;Integer&gt; list = random(frameTime, frameLength); for (int i = 0; i &lt; frameLength; i++) { Frame frame = frameGrabber.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e14839a1b86d19ae39a4620883dec881/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3918dad9880f041b0129353b08067d47/" rel="bookmark">
			生成随机数（C语言，任意随机）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 随机函数用于产生伪随机数，需要头文件stdlib.h。 int rand()可以产生一个[0,RAND_MAX]范围内的伪随机数，其中RAND_MAX是一个系统定义的常量。 使用rand()时，如果不设定随机数序列标签则只会得到重复的随机数序列。为了得到不同的伪随机数序列，可以使用 void srand(unsighed int seed)设置伪随机数序列表签。一般使用时间作为标签。 示例代码：使用随机数函数获得10个随机数 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { int x,i; printf("随机数序列为："); for(i=0;i&lt;10;i++) { x=rand()%100; printf("%d ",x); } return 0; } 运行程序两次，第一次结果如下： 第二次运行结果： 我们发现，在不设置标签的情况下，每次生成的随机数是相同的。为了每次运行得到不同的随机数，可以利用系统时间作为标签，获得不同的随机数序列。 示例代码： #include &lt;stdio.h&gt; #include &lt;time.h&gt; #include &lt;stdlib.h&gt; int main() { int x,i; time_t t=time(NULL); srand(t); printf("随机数序列为："); for(i=0;i&lt;10;i++) { x=rand()%100; printf("%d ",x); } return 0; } 两次运行结果如下： 第二次： 我们发现两次生成的随机数序列不同，说明使用系统时间作为标签是可行的。 我们在对比两个函数，会发现第二次的代码比第一次的代码多了一点东西，那就是#include&lt;time.h&gt; 如需了解time头文件 点击了解详情 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58bb511b57328131502ed72185bb4c58/" rel="bookmark">
			typescript多维对象数组仿List泛型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定义对象：
namespace entity{ export class MyClass{ public value:number; public rect:string; public constructor(){ } } } 二维对象数组：
let myClass= new Array&lt;Array&lt;entity.MyClass&gt;&gt;(); 多维数组：
let myArray: number[][][][] = [] 任意类型数组：
let myArray:any[]=[]; myArray[0]=[{key:1,keyA:"a"},[1,2]]; let arr = [{key:1,keyA:"a"},[1,2]]; 泛型类：
namespace entity{ export class MyClass&lt;T&gt;{ public myArray:T[]; public constructor(){ } } } 转载于:https://www.cnblogs.com/guochunyang2004/p/8638405.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3df868b4eb1508136cbbcdb50af9fc04/" rel="bookmark">
			微信网页授权失败原因总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.项目中网页授权回调地址与微信公众号设置的回调地址不一样
2.如果公众号为服务号，没有把MP_verify_zoOZRR6Jqi5eQA1n.txt粘贴进项目里
3.如果公众号为服务号，项目必须要用域名访问地址
4.如果公众号为测试号，也不可以用ip地址做项目访问地址，因为用ip地址访问的话微信会弹出一个提示界面，当你点击确定的时候，刚刚获得到的code就被第二次使用了，这是不允许的
5.检查网页授权的各种参数与你所需是否一致
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2aee5eea0941d75077126cec8023037a/" rel="bookmark">
			matlab二维特殊函数柱状图bar()函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（只作为个人笔记，根据我个人需要而记录肯定没有手册里那么全，有问题欢迎指出）
柱状图：
bar(y) 以y中的值为长度画一个长柱 %出来了个正方形。。
bar(x,y) 该函数在指定的横坐标x上画出y
bar(x,y,width) 设置宽度 width 设置柱的宽度 默认值为0.8 大于1会相互重叠
bar(...,'style') 默认为group 可以设定为'stack' 就是把y的每行摞起来
bar(...,'bar_color') 定义柱的颜色
函数barh()可以绘制水平柱状图，用法与bar()相同
例：
figure;
x=[1 3 5 9 3 2 6;4 5 2 6 8 9 1;3 4 5 6 7 8 9]';
subplot(121);
barh(1:7,x);
subplot(122);
barh(1:7,x,'stack')
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e140a2285916f03bbd8ae8359376ac3/" rel="bookmark">
			pandas 性能优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 过早的优化是万恶之源 开发的时候尽量先保证可读性和松耦合，性能的问题稍微考虑一下就行。开发完成后出现了性能问题后再进行tuning。
2. 优化前使用工具进行性能分析 个人更喜欢line_profiler。看每一行执行的时间占比，也大概知道原因出在什么地方了。自带的profile会深入到包的底层运算逻辑，不是特别清晰。下面是line_profiler的使用方法，个人感觉比装饰器的方式好用太多：
from line_profiler import LineProfiler import random def do_stuff(numbers): s = sum(numbers) l = [numbers[i]/43 for i in range(len(numbers))] m = ['hello'+str(numbers[i]) for i in range(len(numbers))] numbers = [random.randint(1,100) for i in range(1000)] lp = LineProfiler() lp_wrapper = lp(do_stuff) lp_wrapper(numbers) lp.print_stats() 3. 尽量不要在pandas中使用循环（行遍历） pandas作为一个非常“高级”的包，为了易用性牺牲了很多效率。在使用循环时，会产生类型推断等额外的操作，而且没法利用到pandas内部的特殊优化。
4. 如果循环很难避免，在循环体中使用numpy做计算 numpy的底层使用C构建的，而且anaconda的中numpy包使用了MKL，可以针对CPU的指令集进行优化，针对于数值或者矩阵运算，还有相当优秀的算法算法来优化，所以效率是相当高的。在很多情景之下，如果核心部分改为numpy的话，说不定就已经解决了问题。
5. 如果numpy效率还是不够理想 可以试试cython，你可以把cython当做新的语言，是python的一个超集。结合了C和python的特性，比如变量声明等要符合C的特性，但是又可以使用numpy的一些包。当编译器事先知道变量的类型可以很好的优化代码，这是纯解释语言天生的缺陷。但是在个人的实际使用中，发现仅仅增加类型声明并没有特别多的提升，可能是相关的计算逻辑已经被numpy优化的差不多了吧。但是这种方法的坏处显而易见，代码的可读性明显降低了。。。
6. 不要使用.ix操作符 尽量使用.loc和.iloc来获取数据。而且.ix未来很快就会在pandas中移除。
7. 在有序列中查找使用pandas.Series.searchsorted 这种查找底层使用二分查找，效率会高很多。
8. 统计某个值出现的次数时 尽量不要使用len(df[df[‘report_month’]==3)这种方式，使用pandas.Series.value_counts效率会更高一点。最快的还是numpy：
np.in1d(normal_reports['report_month'],3).sum() 9. 不要做重复的计算 tickerdateclose0000012016010111000001201801011200000220160101130000022018010114 假设有3000多只股票，每个股票都取了同样时间范围的2年数据。我现在要把date字段从string类型转化为datetime类型。如果直接用pd.to_datetime(date)，那么其实效率奇慢。日期的转化需要一些推断的操作，非常耗时。其实只要第一只股票对于的日期转化后，后面的时间区间都是一样的，不需要做重复的转化，幸好pandas支持map操作，下面的代码会极大的提升效率：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e140a2285916f03bbd8ae8359376ac3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72a3af304c735f6e71191a3bfad9af81/" rel="bookmark">
			Unable to parse template &#34;Class&#34; Error message: Selected class file name &#39;ProductServlet.java&#39; mappe
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		状况：创建.class文件出错 报错：
Unable to parse template “Class” Error message: Selected class file name ‘ProductServlet.java’ mapped to not java file type ‘Text files’
解决： 1. 百度结果为修改模板后无法创建.class文件，观察后发现我的模板没有错
.class的文件模板 setting-&gt;editor-&gt;file and code templeates –class文件
#if (${PACKAGE_NAME} &amp;&amp; ${PACKAGE_NAME} != "")package ${PACKAGE_NAME};#end #parse("File Header.java") public class ${NAME} { } 深入分析后发现，我只是不能创建ProductServlet.java这一个文件，而不是不能创建以.java为后缀名的文件，我估计我是创建一个TXT文件的时候，以ProductServlet.java为模板，导致后来都不能创建该文件了。 https://stackoverflow.com/questions/15915202/intellij-not-recognizing-a-particular-file-correctly-instead-its-stuck-as-a-tex
这个时候在Stack Overflow上面找到了这个回答， 但是第一次找的时候，我在java source 文件下面找到.java并没有找到， http://www.it610.com/article/2299280.htm
在这里面找到问题所在，intellij idea误建文件类型不能关联错误解决; Error message: Selected class file name ‘SomeFileName.java’ mapped to not java file type ‘Text files’”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72a3af304c735f6e71191a3bfad9af81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/575f18bfec2dabddc4b79f8dc20c175f/" rel="bookmark">
			kafka connect，将数据批量写到hdfs完整过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		版权声明：本文为博主原创文章，未经博主允许不得转载
本文是基于hadoop 2.7.1，以及kafka 0.11.0.0。kafka-connect是以单节点模式运行，即standalone。
一. 首先，先对kafka和kafka connect做一个简单的介绍
kafka：Kafka是一种高吞吐量的分布式发布订阅消息系统，它可以处理消费者规模的网站中的所有动作流数据。比较直观的解释就是其有一个生产者（producer）和一个消费者（consumer）。可以将kafka想象成一个数据容器，生产者负责发送数据到这个容器中，而消费者从容器中取出数据，在将数据做处理，如存储到hdfs。
kafka connect：Kafka Connect是一种用于在Kafka和其他系统之间可扩展的、可靠的流式传输数据的工具。它使得能够快速定义将大量数据集合移入和移出Kafka的连接器变得简单。即适合批量数据导入导出操作。
二. 下面将介绍如何用kafka connect将数据写入到hdfs中。包括在这个过程中可能碰到的一些问题说明。
首先启动kafka-connect:
bin/connect-standalone.sh config/connect-standalone.properties config/connector1.properties 这个命令后面两个参数，
第一个是指定启动的模式，有分布式和单节点两种，这里是单节点。kafka自带，放于config目录下。
第二个参数指向描述connector的属性的文件，可以有多个，这里只有一个connector用来写入到hdfs。需要自己创建。
接下来看看connector1.properties的内容，
name="test" #该connector的名字
#将自己按connect接口规范编写的代码打包后放在kafka/libs目录下，再根据项目结构引用对应connector
connector.class=hdfs.HdfsSinkConnector #Task是导入导出的具体实现，这里是指定多少个task来并行运行导入导出作业，由多线程实现。由于hdfs中一个文件每次只能又一个文件操作，所以这里只能是1 tasks.max=1 #指定从哪个topic读取数据，这些其实是用来在connector或者task的代码中读取的。
topics=test #指定key以那种方式转换，需和Producer发送方指定的序列化方式一致
key.converter=org.apache.kafka.connect.converters.ByteArrayConverter value.converter=org.apache.kafka.connect.json.JsonConverter #同上 hdfs.url=hdfs://127.0.0.1:9000　#hdfs的url路径，在Connector中会被读取
hdfs.path=/test/file　#hdfs文件路径，同样Connector中被读取
key.converter.schemas.enable=true　#稍后介绍，可以true也可以false，影响传输格式
value.converter.schemas.enable=true　#稍后介绍，可以true也可以false
三. 接下来看代码，connect主要是导入导出两个概念，导入是source，导出时Sink。这里只使用Sink，不过Source和Sink的实现其实基本相同。
实现Sink其实不难，实现对应的接口，即SinkConnector和SinkTask两个接口，再打包放到kafka/libs目录下即可。其中SinkConnector只有一个，而Task可以有多 先是Connector
public class HdfsSinkConnector extends SinkConnector { //这两项为配置hdfs的urlh和路径的配置项，需要在connector1.properties中指定 public static final String HDFS_URL = "hdfs.url"; public static final String HDFS_PATH = "hdfs.path"; private static final ConfigDef CONFIG_DEF = new ConfigDef() .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/575f18bfec2dabddc4b79f8dc20c175f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d854e50f6c856ec1164d6e7f7dd8b61f/" rel="bookmark">
			对统计规律的理解与应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们通常对统计中的内容有困惑，就是各种统计模型有什么用？实际中哪有符合这种统计模型的？
这个问题要这样看，分两步，第一步要看实际中是否有稳定的统计规律，确认有之后，第二步就是确认实际中是什么统计规律。
统计模型千万种，为何高斯总不休？
这是因为大数定律，大数定律将最后的统计规律指向高斯分布。
那么实际中有没有完全符合统计规律的，答案是没有！
原因嘛，一句话，哪有人的脚是照着鞋子的尺寸和形状长的，都是依据人的脚，量身定做鞋子。
统计也一样，依据实际情况，定做统计模型，然后依据统计模型进行处理。
统计的作用在哪？
大得很，统计规律虽不会告诉你具体会发生什么，但会告诉你可能会发生什么，每种情况的大致发生概率是多少！
通俗的说，就是统计规律不会告诉你某个人早餐吃什么，但会告诉你他早餐吃的可能性哪些，是油条+豆浆，还是稀饭+馒头，或者牛奶+面包，并且还会告诉你每种情况的概率是多少？
你会问：这有什么用？
我会说，这用处大得很，比如有100万人，每个人吃的是什么，选择的概率为多少，那么你就知道是要生产30万份豆浆油条还是50万份豆浆油条，生产20万份牛奶+面包还是40万份牛奶+面包。如果实际可能需要30万份牛奶+面包，而你只生产了20万份，那么可能你就要少赚10万份的利润了，10万份。每份赚2元，就是20万/天。而如果你生产了40万份牛奶+面包，而只需要30万份，那你就要亏本了，10万份就“臭了”，假如每份成本3元，你一天就亏了30万。
所以是每天多赚20万，还是亏30万，这就是统计的威力，你说统计重要不重要？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c11dbd6984efb658cfb5fae955ee9d4a/" rel="bookmark">
			用js实现千位分隔符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用js实现千位分隔符，适用于金额展示（正则+replace）
function commafy(num) { return num &amp;&amp; num .toString() .replace(/(\d)(?=(\d{3})+\.)/g, function($0, $1) { return $1 + ","; }); } console.log(commafy(1312567.903000)); // 或者 function moneyFormat (num) { return (Number(num).toFixed(2).replace(/(\d)(?=(\d{3})+\.)/g, '$1,')) } console.log(moneyFormat(1312567.903000)); 结果：1,312,567.903 结果：1,312,567.90
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f81e0494367d5d955f058a3fc5104657/" rel="bookmark">
			Java对象拷贝(BeanUtil.copyProperties 方法)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简介： BeanUtils提供对Java反射和自省API的包装。其主要目的是利用反射机制对JavaBean的属性进行处理。我们知道，一个JavaBean通常包含了大量的属性，很多情况下，对JavaBean的处理导致大量get/set代码堆积，增加了代码长度和阅读代码的难度。
二、用法：
如果你有两个具有很多相同属性的JavaBean，一个很常见的情况就是Struts里的PO对象（持久对象）和对应的ActionForm。例如：一个用户注册页面，有一个User实体类和一个UserActionForm，我们一般会在Action里从ActionForm构造一个PO对象，传统的方式是使用类似下面的语句对属性逐个赋值：
[html] view plain copy // 获取 ActionForm 表单数据 UserActionForm uForm = (UserActionForm) form; // 构造一个User对象 User user = new User(); // 逐一赋值 user.setUsername(uForm.getUsername); user.setPassword(uForm.getPassword); user.setAge(uForm.getAge); // 然后调用JDBC、或操作Hibernate 持久化对象User到数据库 通过这样的方法如果表单数据N多、100、1000（夸张点。哈哈）、、、、那我们不是要写100、、、1000行set、get了。谁都不愿意这样做。
而我们使用 BeanUtils.copyProperties() 方法以后，代码量大大的减少，而且整体程序看着也简洁明朗，代码如下：
[html] view plain copy // 获取 ActionForm 表单数据 UserActionForm uForm = (UserActionForm) form; // 构造一个User对象 User user = new User(); // 赋值 BeanUtils.copyProperties(user, uForm); // 然后调用JDBC、或操作Hibernate 持久化对象User到数据库 ....... 注：如果User和UserActionForm 间存在名称不相同的属性，则BeanUtils不对这些属性进行处理，需要手动处理。例如：
User类里面有个createDate 创建时间字段，而UserActionForm里面无此字段。BeanUtils.copyProperties()不会对此字段做任何处理。必须要自己手动处理。
Date为null时拷贝会报错
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f81e0494367d5d955f058a3fc5104657/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40471edf102a6f70db21888a00af89f7/" rel="bookmark">
			QST培训日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		复习Java
泛型的定义语法为：[访问符] class 类名&lt;类型参数列表&gt;{ //类体.... }
例如public class Gen&lt;T&gt; { private T data; ...... }
在调用泛型的时候指明类型即可Gen&lt;String&gt; g=new Gen&lt;String&gt;("hello");
泛型的通配符是“？”
泛型可以在其定义的时候指定类型参数的上届 [访问符] class 类名&lt;类型参数 extends 父类（即上届）&gt;{ //类体.... }
也可以在使用泛型时指定其上届 泛型类&lt;? extends 父类（上届）&gt;
而下届只能在使用时指定 例如 public static void My(Gen &lt;? super String&gt; g)
javaweb
巩固servlet相关知识，并深化其内部实现原理即相应思路
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ddfb85c4a7f6933dc8977baa1b82cd3/" rel="bookmark">
			通过给的libc泄露函数地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		libc中的函数相对于libc的基地址的偏移都是确定的，如果有一道题给你了libc的文件，就可以通过libc文件泄露出system函数和binsh的地址，然后再构造payload。
一般通过write（）函数泄露 ，通过ELF获得write函数在got表和plt表中的地址
同时获得程序start地址 构造payload payload 一般是填充字符（栈的大小）+ ‘aaaa’（覆盖EBP）+ p32(write_plt) + p32(start)(返回地址） + p32(1)+ p32(write_got)+p32(4)
后面三个是write函数的参数 write(1,'write_got',4) 4代表输出4个字节，write_got则为要泄露的地址
write函数原型是write(fd, addr, len)，即将addr作为起始地址，读取len字节的数据到文件流fd（0表示标准输入流stdin、1表示标准输出流stdout）
binsh在libc中的地址可以直接搜索得到 binsh_libc = libc.search('/bin/sh').next()
其中地址计算如：
libc_base = leak_add - leak_libc(函数在libc中的偏移)
system_add = libc_base + system_libc
binsh_add = libc_base + binsh_libc
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a1430b3aa2d7e4810510ac3513d1ddc/" rel="bookmark">
			xilinx原语使用文献
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		xilinx原语使用文献 0赞 发表于 2012/11/24 10:20:00 阅读（5105） 评论（2） 原语,即primitive.
不同的厂商,原语不同;
同一家的FPGA,不同型号的芯片,可以也不一样;
原语类似最底层的描述方法.
使用原语的好处,
可以直接例化使用,不用定制IP;
即可通过复制原语的语句,然后例化IP,就可使用;
题外话, Altera和Xilinx在例化IP使用时,所用方法不同.
Altera是通过原语例化后,在通过defparam来重新定义参数,再使用;
Xilinx是通过直接修改原语中的参数再例化IP来使用;
最近用到xilinx的芯片,
看到它原语的介绍,摘录如下.以后用在Altera的再补充.
X公司的原语分为10类,包括:计算组件,IO端口组件,寄存器/锁存器,时钟组件,
处理器组件,移位寄存器,配置和检测组件,RAM/ROM组件,Slice/CLB组件,G-tranceiver.
以最常用的时钟组件举例.
其中,以上的DCM_,在某些器件里都可以换成PLL_.
BUFG
具有高扇出的全局时钟缓冲器.通过它可接入到全局时钟网络中.
也常接复位,时钟使能信号等.
Eg. BUFG bufg_inst( .O(clk_o), .I( clk_i));
BUFMUX
全局时钟利用器,选择两个输入时钟I0或I1中的一个作为输出;S为选择信号,
S=0时,输出I0, S=1时,输出I1;
Eg. BUFGMUX bufgmux_inst(.O(clk_o),
.I0(clk1_i),
.I1(clk2_i),
.S(s)
);
BUFIO
本地IO时钟缓冲器.使用独立于全局时钟网络的专用时钟网络来驱动纵向IO管脚.
非常适合同步数据采集;BUFIO要求时钟和相应的IO必须在同一时钟区域,而不同的时钟网络的驱动需要BUFR原语来实现.由于BUFIO引出的时钟只到达了IO列,所以不能来驱动逻辑资源,比如CLB和BRAM.
Eg. BUFIO bufio_inst( .O(clk_o), .I(clk_i0));
BUFR
本地IO时钟逻辑缓冲器.与BUFIO一样是将驱动时钟引入某一时钟区域的专用时钟网络,而独立于全局时钟网络;不同的是,BUFR不仅可以跨越不同的时钟区域(最多3个),还能够驱动IO逻辑以及自身或邻近时钟区域的逻辑资源.BUFIO的输出和本地内部互联都能驱动BUFR组件.此外,BUFR能完成输入时钟1—8的整数分频.因些BUFR是同步设计中实现跨时钟域以及串并转换的最佳方案.
Eg. BUFR #(
.BUFR_DIVEDE(“BYPASS”),//分频比,可选择BYPASS,1—8
.SIM_DEVICE(“VIRTEX4”)
)BUFR_inst(
.O(clk_o),
.CE(CE),
.CLR(clr),
.I(clk_i)
);
DCM_BASE
基本数字时钟管理模块的缩写,是相伴和频率可配置的数字锁相环电路,常用于FPGA系统中复杂的时钟管理.如需要频率和相位动态生配置,则可以选用DCM_ADV原语,如果需要相位动态偏移,可使用DCM_PS原语.
Eg. DCM_BASE#(….)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a1430b3aa2d7e4810510ac3513d1ddc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6004e758be77655a907c4b6bfb8562ce/" rel="bookmark">
			关于微信订阅号无法网页授权与服务号结合实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求场景： 最近公司做了一个小游戏想通过小游戏来吸一波粉丝到指定的订阅号，类似关注公众号后领取100钻石。（模仿微信爱微游，疯狂游乐场）游戏有用户系统（根据openid记录每个用户的钻石数量，皮肤数量等等），问题来了订阅号是没有网页授权的，只有跟订阅号发生交互后才能获取到用户的信息也包括openid，也就是说只有先来订阅号这边关注才能获取用户的唯一标识openid,才能进行游戏，这样不利于一个链接就能传播，不利于形成爆款。有的同学就问了为啥不直接用服务号，因为服务号每个月只能发四次推送不利于维护粉丝。在此需求场景下，下面是解决思路。
主要功能： 1.获取到玩家的唯一标示openid（作为玩家在游戏中的id） 2.判断玩家是否关注了公众号,未关注引导关注，关注后领取钻石 3.分享功能（日常操作，此文不详细讲述）
解决思路： 可以准备两个公众号一个是服务号用来进行网页授权，一个是订阅号（引导玩家关注这个订阅号），玩家通过朋友分享的链接或者在朋友圈看到的链接进入游戏后通过服务号的接口进行网页授权，这里说一个坑，授权有两种方式：
应用授权作用域，snsapi_base （不弹出授权页面，直接跳转，只能获取用户openid）， snsapi_userinfo （弹出授权页面，可通过openid拿到昵称、性别、所在地。并且， 即使在未关注的情况下，只要用户授权，也能获取其信息 ） 必须使用snsapi_userinfo方式在未关注服务号的情况下只有这种方式才能获取到用户的信息（有的同学肯定疑惑为啥要获取信息获取openid不久行啦，下面会讲）。获取到玩家的微信信息主要有：
{ "openid":" OPENID", " nickname": NICKNAME, "sex":"1", "province":"PROVINCE" "city":"CITY", "country":"COUNTRY", "headimgurl": "http://thirdwx.qlogo.cn/mmopen/g3MonUZtNHkdmzicIlibx6iaFqAc56vxLSUfpb6n5WKSYVY0ChQKkiaJSgQ1dZuTOgvLLrhJbERQQ4eMsv84eavHiaiceqxibJxCfHe/46", "privilege":[ "PRIVILEGE1" "PRIVILEGE2" ], "unionid": "o6_bmasdasdsad6_2sgVt7hMZOPfL" } 这些信息都会存入数据库的service_user表，为了实现第二个功能，就是判断玩家是否关注，因为关注的根本就是另一个公众号（订阅号）所以不能用openid的，那就只能用用户的一些基本信息做判断啦，玩家在关注了订阅号后就跟订阅号产生了互动就可以获取到玩家的基本信息，此时获取到的用户信息存入数据库的另一张表subscription_user。 当玩家进入游戏被引导关注订阅号后会根据获取到的该玩家的nickname，sex，city去查订阅号的用户表subscription_user表如果查到了说明玩家关注了订阅号粉丝转化成功，发放钻石。当然发放钻石的openid是有记录的，每个玩家只能领取一次奖励。有的小伙伴就会问啦那我关注后领取了钻石在取消关注怎么办，嗯，从技术上角度是可以获取到取消关注玩家的信息的，难道让玩家的钻石凭空消失？ 从产品和人文关怀角度当然不能这么做，这就是运营人员的事情了，可以从公众号的内容上留住玩家，也可以定期发放礼包，只要游戏好玩有趣还是可以留住大部分玩家的。最后有相关疑问可以加我微信d523205909，备注csdn。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7e22f3227ee5aa4032ac463c35bec6e/" rel="bookmark">
			Linux下安装JDK(多个版本) 切换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、检查系统是否自带了OpenJDK以及相关安装包，如果有的话则应先将其卸载。 检查命令：
java -version
rpm -qa | grep java
rpm -e --nodeps tzdata-java-2013g-1.el6.noarch
rpm -e --nodeps java-1.6.0-openjdk-1.6.0.0-1.66.1.13.0.el6.i686
rpm -e --nodeps java-1.7.0-openjdk-1.7.0.45-2.4.3.3.el6.i686
2、将jdk安装文件 jdk7u79linuxx64.tar.gz 拷贝到 linux 服务器上，/usr/local/software/
3、解压安装文件： 创建文件夹 mkdir /usr/local/java放置 解压后的文件
tar -zxvf jdk7u79linuxx64.tar.gz -C /usr/local/java
4、删除安装文件： rm -rf jdk7u79linuxx64.tar.gz
5、配置环境变量： vim /etc/profile
在文件尾部添加如下配置：
export JAVA_HOME=/usr/local/java/jdk1.7.0_79
export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
export PATH=.:$ZOOKEEPER_HOME/bin:$JAVA_HOME/bin:$PATH
:wq 保存， 输入 source /etc/profile 重新加载 /etc/profile 文件
6、输入 java -version 查看一下jdk版本信息出现如下信息，表示 jdk 安装成功
7、多个版本的jdk (etc/profile 文件中配置的 javaHome 需要去掉 不然可能会导致显示不正确)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7e22f3227ee5aa4032ac463c35bec6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8df1782b0a43c499d0fe1c922c097059/" rel="bookmark">
			JAVA多线程实现-可控最大并发数线程池(newFixedThreadPool)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上篇文章中介绍了单线程化线程池newSingleThreadExecutor，可控最大并发数线程池(newFixedThreadPool)与其最大的区别是可以通知执行多个线程，可以简单的将newSingleThreadExecutor理解为newFixedThreadPool(1)。例如运行一下两个程序：
单线程化线程池（newSingleThreadExecutor）示例：
import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class ThreadPoolByNewSingleThreadExecutor { public static void main(String[] args) { /** * 单线程化的线程池 */ ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor(); for (int i = 0; i &lt; 10; i++) { final int index = i; singleThreadExecutor.execute(new Runnable() { @Override public void run() { Thread.currentThread().setName("Thread i = " + index); System.out.println(Thread.currentThread().getName() + " index = " + index); try { Thread.sleep(500); } catch (InterruptedException e) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8df1782b0a43c499d0fe1c922c097059/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8b0b0bf3f87eadd78957487ee98e047/" rel="bookmark">
			目标检测之VOC2007格式数据集制作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.前序 前几天师弟问我如何做自己的VOC2007数据集的事情，当时跟他说网上资料很多，让他自己查查，但不知道什么原因和我说还是没搞好。自己想想也是，不熟悉的东西即便在别人眼里看似很简单，到了自己跟前也变得深奥到天际。所以这里方便大家一起学习就写了这篇博客，供大家和师弟参考，如有错误的地方还请大家指教。
在做目标检测时，我们需要准备好自己的数据集，将其制作为VOC2007格式的数据集，这里可以下载原始VOC2007数据集：VOC2007数据集，我们来看看这个数据集到底是什么样的。
解压VOC2007数据集后可以看到VOC2007文件夹下有以下5个文件夹：
Annotations文件夹
该文件下存放的是xml格式的标签文件，每个xml文件都对应于JPEGImages文件夹的一张图片。JPEGImages文件夹
改文件夹下存放的是数据集图片，包括训练和测试图片。ImageSets文件夹
该文件夹下存放了三个文件，分别是Layout、Main、Segmentation。在这里我们只用存放图像数据的Main文件，其他两个暂且不管。SegmentationClass文件和SegmentationObject文件。
这两个文件都是与图像分割相关。 2.开始制作 制作自己的VOC2007格式数据集其实不需要上述那么多内容，我们只要做三个部分即可：Annotations文件夹、JPEGImages文件夹、ImageSets文件夹下的Main文件。
第一步：我们参照原始VOC2007数据集的文件层次创建上述四个文件夹，也就是创建一个VOCdevkit文件夹，下面再创建Annotations、JPEGImages、ImageSets三个文件夹，最后在ImageSets文件夹下再创建一个Main文件夹。
创建好所有文件夹后，我们将自己的数据集图片都放到JPEGImages文件夹下。按照习惯，我们将图片的名字修改为000001.jpg这种格式的（参照原始数据集图片命名规则），统一命名方法网络上有很多，网上很多，这里就不多赘述了。
另外强调两点：第一点是图片的格式，图片需是JPEG或者JPG格式，其他格式需要转换一下。第二点是图片的长宽比，图片长宽比不能太大或太小，这个参考原始VOC2007数据集图片即可。
第二步：我们来制作Annotations文件夹下所需要存放的xml文件。这里我们需要借助大神带给我们的福利了：LabelImg工具，可以按照上面的说明进行安装和使用。看到满篇的英文是不是很晕，那这里有个简单的方法可以帮助到大家！当然lxml 库文件还是要装的，但如果你用的是Anaconda环境，那么你什么都不用做，只需要点击这里：LabelImg标注工具，根据自己的情况选择下载window版本还是linux版本，然后解压使用就行了！
关于如何使用，这里以window版本的为例说明。下载解压后会得到一个exe可执行文件，另一个是data文件夹，这里面有个txt文件，内容是预定义的分类标签名，里面的标签可以根据自己的需要进行修改。执行exe文件打开标注界面就可以进行操作了，操作方法可以参考这篇文章：使用方法
这里给张标注工具的参考图：
下面就进行漫长的标注工作吧。。。
说明：每标注完一张图片后进行保存，保存的xml文件名要与对应图片名一致，大家可以参考原始VOC2007数据集中JPEGImages文件夹下图片的命名和Annotations文件夹中的xml文件命名规则。
备注：这里还有个制作工具VOC2007数据格式制作工具 也很好用，大家也可以试一试。这个是在网上看到的，忘记作者了，在这里表示感谢。
第三步：我们来制作ImageSets文件夹下Main文件夹中的4个文件（test.txt、train.txt、trainval.txt、val.txt）。
首先我们先来了解下这四个文件到底是干什么用的，当然从文件的命名上我们也都能大体猜得上来他们的作用，不过这里还是简单的说明一下吧。
test.txt：测试集
train.txt：训练集
val.txt：验证集
trainval.txt：训练和验证集
在原始VOC2007数据集中，trainval大约占整个数据集的50%，test大约为整个数据集的50%；train大约是trainval的50%，val大约为trainval的50%。所以我们可参考以下代码来生成这4个txt文件：
import os import random trainval_percent = 0.5 train_percent = 0.5 xmlfilepath = 'Annotations' txtsavepath = 'ImageSets/Main' total_xml = os.listdir(xmlfilepath) num=len(total_xml) list=range(num) tv=int(num*trainval_percent) tr=int(tv*train_percent) trainval= random.sample(list,tv) train=random.sample(trainval,tr) ftrainval = open(txtsavepath+'/trainval.txt', 'w') ftest = open(txtsavepath+'/test.txt', 'w') ftrain = open(txtsavepath+'/train.txt', 'w') fval = open(txtsavepath+'/val.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8b0b0bf3f87eadd78957487ee98e047/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f1c6ed9f27d323fec877ef3c94bb17e/" rel="bookmark">
			华为watch手表打开USB调试与驱动安装方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这一篇文章要来说的就是华为watch手表打开USB调试的方法，很多朋友们在好奇，智能手表也有开发者选项吗，是的，咱们的华为手表也有开发人员选项呢，但是我们要怎么来打开它连接电脑呢？连接电脑后又如何安装驱动呢，小编就在下面给大家整理一个详细的步骤，参考方法如下：
一：先来说说华为watch手表打开USB调试的方法：
1：先在手表待机画面中，向左划动，进入手表的【设置】：
2：进入最下方的关于→版本号，逛点版本号七次以上，，会提示已经开启开发者选项
3：手表中弹出打开ADB调试，点击确认即可：
二：再来说说华为watch手表驱动下载与安装方法：
1：华为手表驱动要先下载，和手机是一样的，点击这里下载，
2：下载好了解压，然后双击里面的MSI程序一直点击【next】安装就可以了。
到此华为watch手表打开USB调试与驱动安装方法的全部结束了，需要更多关于华为手表的内容，可以继续关注本站
文章标题为：华为watch手表打开USB调试与驱动安装方法 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b43d8c1ffd16aae97347f8d74c26e8a5/" rel="bookmark">
			linux下OpenCasCade初始化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		头文件需要自己引用一下
初始化代码如下
Handle(Aspect_DisplayConnection) aDisplayConnection = new Aspect_DisplayConnection(); // Get graphic driver if it exists, otherwise initialise it if (myGraphicDriver.IsNull()) { myGraphicDriver = new OpenGl_GraphicDriver(aDisplayConnection); } // Get window handle. This returns something suitable for all platforms. WId window_handle = (WId) winId(); // Create appropriate window for platform #ifdef WNT Handle(WNT_Window) wind = new WNT_Window((Aspect_Handle) window_handle); #elif defined(__APPLE__) &amp;&amp; !defined(MACOSX_USE_GLX) Handle(Cocoa_Window) wind = new Cocoa_Window((NSView *) window_handle); #else Handle(Xw_Window) wind = new Xw_Window(aDisplayConnection, (Window) window_handle); #endif // Create V3dViewer and V3d_View myViewer = new V3d_Viewer(myGraphicDriver, Standard_ExtString("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b43d8c1ffd16aae97347f8d74c26e8a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2556e14bf665973680b332c1d567caf4/" rel="bookmark">
			JAVA多线程实现-单线程化线程池newSingleThreadExecutor
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JAVA通过Executors提供了四种线程池，单线程化线程池(newSingleThreadExecutor)、可控最大并发数线程池(newFixedThreadPool)、可回收缓存线程池(newCachedThreadPool)、支持定时与周期性任务的线程池(newScheduledThreadPool)。本篇文章主要介绍newSingleThreadExecutor，其他三种线程池将在后续的文章中一一阐述。
单线程化线程池(newSingleThreadExecutor)的优点，串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。（在后续阐述(newFixedThreadPool)时，我们会再做阐述）。
使用单线程化线程池(newSingleThreadExecutor)的一般方法下代码所示。
import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.TimeUnit; public class ThreadPoolByNewSingleThreadExecutor { public static void main(String[] args) { /** * 单线程化的线程池 */ ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor(); for (int i = 0; i &lt; 10; i++) { final int index = i; singleThreadExecutor.execute(new Runnable() { @Override public void run() { Thread.currentThread().setName("Thread i = " + index); System.out.println(Thread.currentThread().getName() + " index = " + index); try { Thread.sleep(500); } catch (InterruptedException e) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2556e14bf665973680b332c1d567caf4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/750a1034c365d993801a056dad394137/" rel="bookmark">
			阿里巴巴电话面试C/C&#43;&#43;基础知识整理【面试经验】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔者今天接到阿里巴巴的电话面试邀请，感觉基础知识薄弱。还需要加强学习，下面将这方面相关的知识整理，与大家共同学习共勉。
基础的知识： STL容器，算法。
重点的知识：C/C++强调速度和内存管理，指针，内存这是重点。
引用和指针的区别与联系 区别
指针是一个实体他在栈中有自己使用的空间，但是引用没有；引用必须初始化，指针不用但是最好初始化指针使用时必须加*，引用不用；引用只能初始化一次是个专一的人，指针不是；引用不用const去修饰，但是指针可以指针和地址运用自增（++）不同，引用是值进行自增，而指针是地址进行自增； 联系
引用的内部使用指针实现的引用是受了限制的指针 内存分配的3个空间哪个效率更高 分配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持，分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。
STL容器各自的优缺点 如果需要高效的随机存取，不在乎插入和删除的效率，使用vector；如果需要大量的插入和删除元素，不关心随机存取的效率，使用list；如果需要随机存取，并且关心两端数据的插入和删除效率，使用deque；如果打算存储数据字典，并且要求方便地根据key找到value，一对一的情况使用map，一对多的情况使用multimap；如果打算查找一个元素是否存在于某集合中，唯一存在的情况使用set，不唯一存在的情况使用multiset。 算法： 字典算法，快排，简单说明原理 基于二分法。快速排序之所比较快，因为相比冒泡排序，每次交换是跳跃式的。每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。
2018年3月21日 08:36:18 补充语言类相关知识
对主流语言进行分类，从该语言的最初目的了解该语言的重点。
计算机技术的演进过程 年代时代名称 需要解决的问题2017-至今人工智能时代 人类的问题2008-2016复杂信息系统时代数据问题1981-2008网络和视窗时代 交互问题1946-1981计算机结构时代计算能力问题 C语言：发展在一个对计算机运行速度和性能要求较高的年代，当时的计算机内存资源有限，需要合理调用计算机内存才能高效使用，使得程序较好的运行在计算机上。 学习重点：指针、内存、数据类型。
语言本质：理解计算机系统结构
解决问题：性能
适用对象：计算机类专业
Java：解决计算机语言跨平台的问题，面向对象的语言，方便在不同的系统，乃至手机上可以运行的程序。 学习重点：对象、跨平台、运行时等
语言本质：理解主客体关系
解决问题：跨平台
适用对象：软件类专业
C++：该门语言是对C语言的一个升级，同时兼具java和C的优点 学习重点：对象、多态、继承
语言本质：理解主客体关系
解决问题：大规模程序
适用对象：计算机类专业
VB：面向对象解决桌面应用的交互逻辑问题 学习重点：对象、按钮、文本库
语言本质：理解交互逻辑
解决问题：Windows桌面应用
适用对象：不确定
Python：各类编程语言所处历史时期和使命不同，Python是一门超级语言，语法简单，具有很大的生态系统，而且开源人人都能使用和做出贡献。 学习重点：编程逻辑、第三方库
语言本质：理解问题求解
解决问题：各类问题都可以应用
适用对象：所有专业
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89f8fe3747df2d3518f721ca171afb0f/" rel="bookmark">
			nginx 1.12安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备工作 使用root用户安装。 到nginx官网下载Linux源码或者执行：wget http://nginx.org/download/nginx-1.12.2.tar.gz。 到pcre站点下载zlilb源码或者执行：wget https://ftp.pcre.org/pub/pcre/pcre-8.41.tar.gz。 到zlib官网下载zlilb源码或者执行：wget https://ncu.dl.sourceforge.net/project/libpng/zlib/1.2.11/zlib-1.2.11.tar.gz。 到openssl官网下载openssl源码或者执行：wget https://www.openssl.org/source/openssl-1.1.0g.tar.gz。 一般编译nginx时，都要先安装pcre、zlib、openssl等，然后编译安装nginx时指定这些程序的安装目录，这样nginx在每次启动的时候，就会去动态加载这些程序了。但是也可以将这些程序静态编译到nginx里面，这样nginx启动时就不用动态加载了，这种方式效率更高，也更方面替换这些程序的版本，因为像zlib会被很多程序依赖，不好升级。因此下载完以上4个tar.gz后，全部解压缩到/home/test： tar -zxvf nginx-1.12.2.tar.gz -C /home/test tar -zxvf pcre-8.41.tar.gz -C /home/test tar -zxvf zlib-1.2.11.tar.gz -C /home/test ar -zxvf openssl-1.1.0g.tar.gz -C /home/test 构建和安装 构建时使用configure命令进行配置，它定义了系统的各个方面，包括nginx被允许用于连接处理的方法。最后，它创建了一个Makefile。configure支持的参数可以使用./configure --help查看： --prefix：定义一个将保存服务器文件的目录。此目录也将用于configure命令配置的(除库源文件路径外)和nginx.conf配置文件中的所有相对路径。默认路径为/usr/local/nginx。 --sbin-path=path：设置nginx可执行文件的路径。此路径仅在安装期间使用。默认路径为prefix/ sbin/nginx。 --conf-path=path：设置nginx.conf的路径。如有必要，总是可以 在nginx启动时通过命令行参数-c file指定一个不同的配置文件路径。 默认路径为prefix/conf/nginx.conf。 --pid-path=path：设置nginx.pid文件的路径，这个文件将存储主进程的进程ID。安装完成后，此路径可以在nginx.conf文件中使用pid指令更改。默认路径为prefix/ logs/nginx. pid。 --error-log-path=path：设置记录主要错误、警告以及诊断文件的路径。安装完成后， 该路径总是可以在nginx.conf文件中用 error_log 指令更改。 默认路径为prefix/logs/error.log。 --http-log-path=path：设置记录HTTP服务器主要请求日志的完整路径。安装完成后， 该路径总是可以在nginx.conf文件用 access_log 指令来修改。 默认路径为prefix/logs/access.log。 --build=name：设置一个可选的nginx构建名称。 --user=name： 设置工作进程以某非特权用户的身份运行。安装完成后，该用户名总是可以在 nginx.conf文件用user指令来修改。 默认值为nobody。 --group=name：设置工作进程以某非特权用户组的身份运行。安装完成后，该用户名总是可以在 nginx.conf用user指令来修改。 默认名称与--user相同。 --with-select_module：启用或禁用构建一个允许服务器使用select()方法的模块。如果平台不支持更合适的方法比如 kqueue，epoll，/dev/poll，则该模块是自动构建的。 --with-poll_module：启用或禁用构建一个允许服务器使用poll()方法的模块。如果平台不支持更合适的方法比如 kqueue，epoll，/dev/poll，则该模块是自动构建的。 --without-http_gzip_module：不构建HTTP服务器的压缩响应模块ngx_http_gzip_module。该模块需要zlib库才能构建和运行。 --without-http_rewrite_module：不构建允许HTTP服务器重定向请求和更改请求的URI的模块ngx_http_rewrite_module。该模块需要PCRE库才能构建和运行。 --without-http_proxy_module：不构建HTTP服务器代理模块ngx_http_proxy_module。 --with-http_ssl_module：构建一个让HTTP服务器支持https协议的模块，这个模块默认不会构建。该模块需要OpenSSL库才能构建和运行。 --with-pcre=path：设置PCRE库源文件的路径。PCRE库的发行版(version 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89f8fe3747df2d3518f721ca171afb0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c30c622ae8993787b33b8ecd1f7a619/" rel="bookmark">
			启动hive错误：Exception in thread &#34;main&#34; java.lang.IllegalArgumentException
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		启动hive时报错了 报错信息： Exception in thread "main" java.lang.IllegalArgumentException: java.net.URISyntaxException: Relative path in absolute URI: ${system:java.io.tmpdir%7D/$%7Bsystem:user.name%7D at org.apache.hadoop.fs.Path.initialize(Path.java:205) at org.apache.hadoop.fs.Path.&lt;init&gt;(Path.java:171) at org.apache.hadoop.hive.ql.session.SessionState.createSessionDirs(SessionState.java:659) at org.apache.hadoop.hive.ql.session.SessionState.start(SessionState.java:582) at org.apache.hadoop.hive.ql.session.SessionState.beginStart(SessionState.java:549) at org.apache.hadoop.hive.cli.CliDriver.run(CliDriver.java:750) at org.apache.hadoop.hive.cli.CliDriver.main(CliDriver.java:686) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.apache.hadoop.util.RunJar.run(RunJar.java:221) at org.apache.hadoop.util.RunJar.main(RunJar.java:136) Caused by: java.net.URISyntaxException: Relative path in absolute URI: ${system:java.io.tmpdir%7D/$%7Bsystem:user.name%7D at java.net.URI.checkPath(URI.java:1823) at java.net.URI.&lt;init&gt;(URI.java:745) at org.apache.hadoop.fs.Path.initialize(Path.java:202) ... 12 more 创建一个目录 mkdir /home/hadoop/apps/hive-2.3.2/tmp 编辑hive-site.xml,将system:java.io.tmpdir替换成刚刚创建目路径，我搜了下发现有四个地方需要修改
&lt;property&gt; &lt;name&gt;hive.exec.local.scratchdir&lt;/name&gt; &lt;value&gt;${system:java.io.tmpdir}/${system:user.name}&lt;/value&gt; &lt;description&gt;Local scratch space for Hive jobs&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hive.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c30c622ae8993787b33b8ecd1f7a619/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c24b31e35aeb7e1d1318d6a4eb63b07/" rel="bookmark">
			HDFS写数据流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HDFS写数据流程 概述 客户端要向HDFS写数据，首先要跟namenode通信以确认可以写文件并获得接收文件block的datanode，然后，客户端按顺序将文件逐个block传递给相应datanode，并由接收到block的datanode负责向其他datanode复制block的副本
步骤图 详细过程 客户端执行写入操作
DistributedFileSystem用RPC调用元数据节点，在文件系统的命名空间中创建一个新的文件。元数据节点首先确定文件原来不存在，并且客户端有创建文件的权限，然后创建新文件。DistributedFileSystem返回DFSOutputStream，客户端用于写数据。客户端开始写入数据，DFSOutputStream将数据分成块，写入data queue。Data queue由Data Streamer读取，并通知元数据节点分配数据节点，用来存储数据块。分配的数据节点放在一个pipeline里。Data Streamer将数据块写入pipeline中的第一个数据节点。第一个数据节点将数据块发送给第二个数据节点。DFSOutputStream为发出去的数据块保存了ack queue，等待pipeline中的数据节点告知数据已经写入成功。如果数据节点在写入的过程中失败： 关闭pipeline，将ack queue中的数据块放入data queue的开始。当前的数据块在已经写入的数据节点中被元数据节点赋予新的标示，则错误节点重启后能够察觉其数据块是过时的，会被删除。失败的数据节点从pipeline中移除，另外的数据块则写入pipeline中的另一个数据节点。元数据节点则被通知此数据块是复制块数不足，将来会再创建备份。当客户端结束写入数据，则调用stream的close函数。此操作将所有的数据块写入pipeline中的数据节点，并等待ack queue返回成功。最后通知元数据节点写入完毕。 部分参考：http://www.cnblogs.com/forfuture1978/archive/2010/03/14/1685351.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d00fa8ad460d79cae74cbb9adf4527a3/" rel="bookmark">
			查看服务器被远程登录的事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于在项目开发过程中，不少人接触到服务器登录密码，必要时候要收回密码，确保服务器的安全。
WINDOWS服务器具备登录日志功能，下面记录一下如何查看服务器的远程登录日志。
1.控制面板——管理工具——事件查看器——Windows日志——安全——右键“筛选当前日志”
2008或者2012输入 事件ID：**** 可以查看远程登录的记录
如ID:4624 是登录类别事件
ID:4672是特殊登录类别事件
ID:4776是凭据验证类别事件
每一个事件都有详细信息，点击即可，详细信息里面登录的IP，还有一个LogonType:
输入事件ID：1102，可以查看删除日志的记录。
2.在CMD下面输入 netstat，可以查看目前的连接情况，也可以看到远程连接的IP
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e93c665f7594808162e210fa188875e2/" rel="bookmark">
			Android 蓝牙自动配对连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		蓝牙工具类：
public class BTReceiverUtils { /** * 与设备配对 */ static public boolean createBond(Class btClass, BluetoothDevice btDevice) throws Exception { Method createBondMethod = btClass.getMethod("createBond"); Boolean returnValue = (Boolean) createBondMethod.invoke(btDevice); return returnValue.booleanValue(); } /** * 与设备解除配对 */ static public boolean removeBond(Class&lt;?&gt; btClass, BluetoothDevice btDevice) throws Exception { Method removeBondMethod = btClass.getMethod("removeBond"); Boolean returnValue = (Boolean) removeBondMethod.invoke(btDevice); return returnValue.booleanValue(); } /** * 进行配对 */ static public boolean setPin(Class&lt;? extends BluetoothDevice&gt; btClass, BluetoothDevice btDevice, String str) throws Exception { try { Method removeBondMethod = btClass.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e93c665f7594808162e210fa188875e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac2408fc5a29cd46a83d4705c8b0d97f/" rel="bookmark">
			js立即执行函数与分组操作符()的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、圆括号运算符
圆括号运算符也叫分组运算符，它有两种用法：如果表达式放在圆括号中，作用是求值；如果跟在函数后面，作用是调用函数
把表达式放在圆括号之中，将返回表达式的值
console.log((1)); //1 console.log(('a')); //'a' console.log((1+2)); // 3 把对象放在圆括号之中，则会返回对象的值，即对象本身
var o = {p:1}; console.log((o));// Object {p: 1} 将函数放在圆括号中，会返回函数本身。如果圆括号紧跟在函数的后面，就表示调用函数，即对函数求值
function f(){return 1;} console.log((f));// function f(){return 1;} console.log(f()); // 1 [注意]圆括号运算符不能为空，否则会报错
();//SyntaxError: Unexpected token ) 由于圆括号的作用是求值，如果将语句放在圆括号之中，就会报错，因为语句没有返回值
console.log(var a = 1);// SyntaxError: Unexpected token var console.log((var a = 1));// SyntaxError: Unexpected token var 二、立即执行函数
原文链接：http://web.jobbole.com/82520/ 和 https://www.cnblogs.com/xiaoh...
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e97d8adcdd2ff53bb863c851cafa11a/" rel="bookmark">
			cmd新建、删除文件和文件夹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新建文件夹和文件
cd .. 返回上一级 md test 新建test文件夹 md d:\test\my d盘下新建文件夹 cd test 进入test文件夹 cd.&gt;cc.txt 新建cc.txt文件 dir 列出文件夹下所有文件及文件夹 删除文件夹和文件
cd test 进入test文件夹 dir 查看所有文件目录 del a.txt 删除a.txt的文件 del *.txt 删除所有后缀为.txt的文件 rd test 删除名为test的空文件夹 rd /s D:\test 删除D盘里的test文件夹 会出现如下 test, 是否确认(Y/N)? 直接输入 Y 在回车 rd test/s 删除此文件夹下的所有文件 test, 是否确认(Y/N)? 直接输入 Y 在回车 其他操作
cls 清空当前窗口 D: 切换盘符到D盘 F: 切换盘符到F盘 ren 重命名 如： ren files file 有兴趣的可以关注下小编的公众号，持续更新哦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b033e43c9c6adc9dc6e0ec44d8796756/" rel="bookmark">
			Cocos2d-x的lua官方加密的解密方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0x01 加密方式分析 Cocos2d-x对于lua脚本加密提供了一种轻量级解决方案， 加密算法是xxtea， 下面是这个打包脚本 cocos2d.py加密参数的说明 主要就是两个部分，sign和key，sign是加密标记，用于判断脚本是否加密，key是xxtea解密时候的秘钥，下面是Cocos2d-x部分源码 这里设置了sign和key 这里就是通过对比文件开头的字符串是否为所设置的sign判断是否加密，如果加密的话就解密，解密后才加载脚本 0x02 寻找sign和key 将apk解压之后就找到src这个目录，这里放着lua脚本 这里的lua脚本是加密的，用记事本打开，可以看到开头的字符串"CreatByDartou"，这就是上面所说的sign ，知道sign之后下面就要找key 找key很简单，用IDA载入libcocos2dlua.so这个库，打开string窗口，直接搜索sign，key就在附近,"thirteenPokerCOCOS"就是key，知道了这些就可以解密了。 解密算法和加密算法可以在https://github.com/cocos2d/cocos2d-x-3rd-party-libs-bin/tree/v3/xxtea找到 0x03 编写解密程序 解密思路很简单，无非就是读取文件，调用xxtea_decrypt来解密，然后写入文件，写好代码编译运行即可 解密成功 为了实现批量解密，可以编写个脚本去实现（为啥不直接在解密程序中实现批量？本人比较懒，脚本代码少些 ） [Shell] 纯文本查看 复制代码 ? 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 #!/bin/sh process_file(){ for file in ` ls -a $1` do if [ x "$file" != x "." -a x "$file" != x "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b033e43c9c6adc9dc6e0ec44d8796756/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c7107ef651eb8a2832638bf52160616/" rel="bookmark">
			[教你一招]设置Linux下中文显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在编译一个程序的时候，我们往往会出现或多或少的错误，在Linux下默认的是英文显示，对于查错就不是很方便了，此篇博客重在给大家介绍一个简单的方法，来更改Linux下的显示为我们熟悉的中文显示。
首先在command输入locale，可以看到Linux下默认的系统语言的是英文 vim ~/.bashrc打开这个文件夹，该文件夹相当于系统配置文件 打开后，将后三行命令输入到文档中，最后保存退出 运行这个修改文件，命令为source ~/.bashrc，如果运行不成功，可以在命令前加sudo,sudo是root权限运行 运行后，再输入locale命令，查看系统语言是否已经改成 查看当前的文件信息 我们的中文显示就设置成功了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cadf0c3dbfa218cdd53a435299955efe/" rel="bookmark">
			java-poi3.17读取ppt文本和图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package per.qy.dexter.fileoperate; import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.util.List; import java.util.UUID; import org.apache.poi.hslf.usermodel.HSLFSlideShow; import org.apache.poi.hslf.usermodel.HSLFTable; import org.apache.poi.hslf.usermodel.HSLFTableCell; import org.apache.poi.hslf.usermodel.HSLFTextShape; import org.apache.poi.sl.usermodel.PictureData; import org.apache.poi.sl.usermodel.Shape; import org.apache.poi.sl.usermodel.Slide; import org.apache.poi.sl.usermodel.SlideShow; import org.apache.poi.xslf.usermodel.XMLSlideShow; import org.apache.poi.xslf.usermodel.XSLFTable; import org.apache.poi.xslf.usermodel.XSLFTableCell; import org.apache.poi.xslf.usermodel.XSLFTextShape; import org.junit.Test; public class PptTest { @SuppressWarnings({ "rawtypes", "unchecked" }) @Test public void testPpt() { String path = "D:\\temp\\temp\\test.ppt"; // String path = "D:\\temp\\temp\\test.pptx"; File file = new File(path); InputStream is = null; SlideShow slideShow = null; try { is = new FileInputStream(file); if (path.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cadf0c3dbfa218cdd53a435299955efe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23f9112f5a73f0b983d11e662424e8e2/" rel="bookmark">
			java-poi3.17读取excel文本和图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package per.qy.dexter.fileoperate; import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.util.List; import java.util.UUID; import org.apache.poi.hssf.usermodel.HSSFWorkbook; import org.apache.poi.ss.usermodel.Cell; import org.apache.poi.ss.usermodel.CellType; import org.apache.poi.ss.usermodel.PictureData; import org.apache.poi.ss.usermodel.Row; import org.apache.poi.ss.usermodel.Sheet; import org.apache.poi.ss.usermodel.Workbook; import org.apache.poi.xssf.usermodel.XSSFWorkbook; import org.junit.Test; public class ExcelTest { @Test public void testExcel() { String path = "D:\\temp\\temp\\test.xls"; // String path = "D:\\temp\\temp\\test.xlsx"; File file = new File(path); InputStream is = null; Workbook workbook = null; try { is = new FileInputStream(file); if (path.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23f9112f5a73f0b983d11e662424e8e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63326c42e446e3f3bf23aa95e84307d6/" rel="bookmark">
			rem与mod的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 从老师提供的PPT中复制出来的，感觉还行直接用了，算是转载吧。
rem与mod的区别
不仔细区分的话，可把rem和mod都当作是求余数的命令。
&gt;&gt;mod(3,2) ans=1 &gt;&gt;rem(3,2) ans=1这两个数的符号一致时的结果是一样 的，但是当两个数的符号不一样时，就会出现不同了。 &gt;&gt;mod(3,-2) ans=-1 &gt;&gt;rem(3,-2) ans=1主要区别在: rem(x, y)返回的是x-n.*y，当y~=0时，n=fix(x./y)， mod(x, y)返回的是x-n.*y，当y~=0时，n=floor(x./y) 因此他们之间的区别主要在与fix与floor的区别： fix：向最近的整数取整 floor：向负无穷取整。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f93d1657ca541eff68ea0fb5cdbe51df/" rel="bookmark">
			多线程的同步与互斥
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当多个控制线程共享相同的内存时，要确保对数据访问的正确性，就需要做线程的同步与互斥工作。先看下面这个例子：
为什么要进行线程的同步与互斥 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;pthread.h&gt; #include &lt;signal.h&gt; size_t count = 0; void ModifyCount() { ++count; } void* ThreadEntry(void *arg) { (void)arg; for(size_t i = 0; i &lt; 10000; ++i){ ModifyCount(); } return NULL; } int main() { pthread_t tid1, tid2; pthread_create(&amp;tid1, NULL, ThreadEntry, NULL); pthread_create(&amp;tid2, NULL, ThreadEntry, NULL); pthread_join(tid1, NULL); pthread_join(tid2, NULL); printf("count: %ld\n", count); return 0; } 我们让两个线程同时对一个全局变量做 ++ 操作，各自增加 10000次，如果程序执行无误，结果应该是 20000，实际上运行结果如下： 我们让该程序执行了多次，发现只有两次的结果正确，而其他的结果都超出了我们的预期，原因在哪呢？ 我看看看++ 操作的汇编代码： 对 count 的增加有三步：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f93d1657ca541eff68ea0fb5cdbe51df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e3fac6f29cd37fdf9cf9c2c11ac5e15/" rel="bookmark">
			经典卷积神经网络    之   ZFNet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ZFNet 时间： 2013年
出处： Matthew D.Zeiler 和 Rob Fergus （纽约大学）2013年撰写的论文： Visualizing and Understanding Convolutional Networks
目的： AlexNet的提出使得大型卷积网络开始变得流行起来，但是人们对于CNN网络究竟为什么能表现这么好，以及怎么样能变得更好尚不清楚，因此为了针对上述两个问题，提出了一个新颖的可视化技术，“理解”中间的特征层和最后的分类器层，并且找到改进神经网络的结构的方法
做法： 使用反卷积（Deconvnet），可视化特征图（feature map） 通过Deconvnet技术，可视化Alex-net，并指出了Alex-net的一些不足，最后修改网络结构，使得分类结果提升 与AlexNet相比，前面的层使用了更小的卷积核和更小的步长，保留了更多特征
成就： ZFNet是2013年ILSVRC的冠军
贡献： CNN领域可视化理解的开山之作，作者通过可视化解释了为什么CNN有非常好的性能、如何提高CNN性能，然后进行调整网络，提高了精度
论文主要贡献如下： 特征可视化 使用反卷积，可视化feature map 通过feature map可以看出，特征分层次体系结构 前面的层学习的是物理轮廓、边缘、颜色、纹理等特征，后面的层学习的是和类别相关的抽象特征
CNN学习到的特征具有平移和缩放不变性，但是，没有旋转不变性
对于CNN结构的改进 通过特征可视化可以知道，Krizhevsky的CNN结构学习到的第一层特征只对于高频和低频信息有了收敛，但是对于中层信息却还没有收敛；同时，第二层特征出现了混叠失真，这个主要是因为第一个卷积层的层的步长设置为4引起的，为了解决这个问题，作者不仅将第一层的卷积核的大小设置为7*7,同时，也将步长设置为2
对于遮挡的敏感性 通过遮挡，找出了决定图像类别的关键部位当，在输入图片中遮挡了学习到的特征时，分类效果会很差。
关联分析 作者认为深度结构隐形地学习到不同图像中一些特定结构的关联性。通过遮挡不同图像的相同结构，然后计算学习的特征与没有遮挡之前学习到的特征之间的差，然后这些差的Hamming距离Δ，当Δ越小时，说明了网络还是学习到了一定的结构关联性。(这个地方不理解)
特征提取的通用性 这个部分主要是作者通过实验说明了，将使用ImageNet2012数据集训练得到的CNN,在保持前面七层不变的情况，只在小数据集上面重新训练softmax层，通过这样的实验，说明了使用ImageNet2012数据集训练得到的CNN的特征提取功能就有通用性。
特征分析 作者通过实验证明了，不同深度的网络层学习到的特征对于分类的作用，说明了深度结构确实能够获得比浅层结构更好的效果。 通过实验，说明了深度增加时，网络可以学习到更具区分的特征。 底层特征在迭代次数比较少时就能收敛，高层需要的迭代次数比较多 越是高层的特征，其用来做分类的性能越好
技术分析 1、反池化过程
我们知道，池化是不可逆的过程，然而我们可以通过记录池化过程中，最大激活值得坐标位置。然后在反池化的时候，只把池化过程中最大激活值所在的位置坐标的值激活，其它的值置为0，当然这个过程只是一种近似，因为我们在池化的过程中，除了最大值所在的位置，其它的值也是不为0的。刚好最近几天看到文献：《Stacked What-Where Auto-encoders》，里面有个反卷积示意图画的比较好，所有就截下图，用这篇文献的示意图进行讲解： 此处输入图片的描述
以上面的图片为例，上面的图片中左边表示pooling过程，右边表示unpooling过程。假设我们pooling块的大小是3*3，采用max pooling后，我们可以得到一个输出神经元其激活值为9，pooling是一个下采样的过程，本来是3*3大小，经过pooling后，就变成了1*1大小的图片了。而upooling刚好与pooling过程相反，它是一个上采样的过程，是pooling的一个反向运算，当我们由一个神经元要扩展到3*3个神经元的时候，我们需要借助于pooling过程中，记录下最大值所在的位置坐标(0,1)，然后在unpooling过程的时候，就把(0,1)这个像素点的位置填上去，其它的神经元激活值全部为0。再来一个例子： 此处输入图片的描述
在max pooling的时候，我们不仅要得到最大值，同时还要记录下最大值得坐标（-1，-1），然后再unpooling的时候，就直接把(-1-1)这个点的值填上去，其它的激活值全部为0。
2、反激活
我们在Alexnet中，relu函数是用于保证每层输出的激活值都是正数，因此对于反向过程，我们同样需要保证每层的特征图为正值，也就是说这个反激活过程和激活过程没有什么差别，都是直接采用relu函数。
3、反卷积
对于反卷积过程，采用卷积过程转置后的滤波器(参数一样，只不过把参数矩阵水平和垂直方向翻转了一下)，这一点我现在也不是很明白，估计要采用数学的相关理论进行证明。
最后可视化网络结构如下： 此处输入图片的描述
网络的整个过程，从右边开始：输入图片-》卷积-》Relu-》最大池化-》得到结果特征图-》反池化-》Relu-》反卷积。到了这边，可以说我们的算法已经学习完毕了，其它部分是文献要解释理解CNN部分，可学可不学。
反卷积可视化以各层得到的特征图作为输入，进行反卷积，得到反卷积结果，用以验证显示各层提取到的特征图。举个例子：假如你想要查看Alexnet 的conv5提取到了什么东西，我们就用conv5的特征图后面接一个反卷积网络，然后通过：反池化、反激活、反卷积，这样的一个过程，把本来一张13*13大小的特征图(conv5大小为13*13)，放大回去，最后得到一张与原始输入图片一样大小的图片(227*227)。
通过反卷积Deconvnet实现可视化：
在每个卷积层都加上了一个反卷积层。在卷积、ReLU、Max-pooling之后，不仅输出给下一层用作输入，也为反卷积提供输入。而反卷积层依次进行unpooling、ReLU和反卷积。见图2。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e3fac6f29cd37fdf9cf9c2c11ac5e15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28a450ad4c04a580aa86a2fccff64b24/" rel="bookmark">
			JSP文件下载中文和空格显示Content-Disposition设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Content-disposition 是 MIME 协议的扩展，MIME 协议指示 MIME 用户代理如何显示附加的文件。当 Internet Explorer 接收到头时，它会激活文件下载对话框，它的文件名框自动填充了头中指定的文件名。（请注意，这是设计导致的；无法使用此功能将文档保存到用户的计算机上，而不向用户询问保存位置。） 服务端向客户端游览器发送文件时，如果是浏览器支持的文件类型，一般会默认使用浏览器打开，比如txt、jpg等，会直接在浏览器中显示，如果需要提示用户保存，就要利用Content-Disposition进行一下处理，关键在于一定要加上attachment：
Response.setHeader("Content-Disposition","attachment;filename=FileName.txt");
备注：这样浏览器会提示保存还是打开，即使选择打开，也会使用相关联的程序比如记事本打开，而不是IE直接打开了。
另外原始的空格使用urlEncode 编码后转换为+号(基于历史原因)，而ie解析时会直接作为+号处理，因此需要手工替换一下这个特殊字符 --&gt;详细请看情况四
下面是各种响应头设置的情况演示:
情况一:(下载文件名为Download)
1.有文件扩展名
2.名字默认为Download
//得到要下载的文件名 String fileName = request.getParameter("filename"); System.out.println("fileName: " + fileName); //设置响应头,控制浏览器下载该文件 response.setHeader("content-disposition","attachment;filename=" + fileName); 情况二:(下载文件名为spring+-+副本+%284%29)
1.没有文件扩展名
2.不能正常显示符号
//处理文件名 int index = fileName.lastIndexOf("."); String realname = fileName.substring(0,index); System.out.println("realname : " + realname); //设置响应头,控制浏览器下载该文件 response.setHeader("content-disposition", "attachment;filename=" + URLEncoder.encode(realname, "UTF-8")); 情况三:(下载文件名为spring+-+副本+(2))
1.能正常显示符号
2.名字出现"+"
//设置响应头,控制浏览器下载该文件 response.setHeader("content-disposition","attachment;filename*=UTF-8''" + URLEncoder.encode(fileName,"UTF-8")); 情况四:(下载文件名为spring - 副本 (3))
1.能正常显示符号
2.解决名字出现"+"问题
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28a450ad4c04a580aa86a2fccff64b24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccd1fc8f259219e9594ac6c2fa2aff78/" rel="bookmark">
			微信小程序---显示与隐藏hidden
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、wx.wxml页面部分
&lt;view bindtap='clickMe'&gt;点击&lt;/view&gt; //这是显示隐藏的部分 &lt;view hidden="{{hiddenName}}"&gt;隐藏显示部分&lt;/view&gt; 2、wx.js js部分
page({ data:{ hiddenName:true }, clickMe:function(e){ this.setData({ hiddenName:!this.data.hiddenName }) } }) 注意：hidden用于频繁切换
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7484083eda971fd71e75e031817dd499/" rel="bookmark">
			supermap iobjects学习——workspace，WorkspaceControl，控件交互
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工作空间（Workspace）是SuperMap中的一个重要的概念，工作空间存储了一个工程项目中所有的数据源，地图的组织关系，工作空间通过其中的数据源集合对象（ Datasources），地图集合对象（ Maps）来管理其下的数据源和地图。
工作空间中的数据源集合（ Datasources）只存储数据源的连接信息和位置等，实际的数据源都存储在数据库或者UDB中。
工作空间中的地图集合（ Maps）中存储的是地图的配置信息，如地图包含图层的个数，图层引用的数据集，地图范围，背景风格等。
在当前版本中，一个应用程序中允许多个工作空间共存，每个工作空间可以管理自己的一套数据源和地图等。不同的工作空间不可相互操作。
注意：当用户使用该工作空间对象进行编程时，如果将Workspace与 MapControl建立了关联，那么在进行对象的关闭时，一定需要注意关闭的顺序，如下：
1、 关闭map 对象；
2、 关闭MapControl对象；
3、 关闭Workspace对象。
以下代码示范如何打开工作空间，从工作空间中取数据源，从数据源取数据集，查看数据集的描述信息以及如何保存或另存工作空间。
public void OpenWorkspace() { // 打开工作空间，取出工作空间中名为“World”的数据集，查询其描述信息 Workspace workspace = new Workspace(); WorkspaceConnectionInfo workspaceConnectionInfo = new WorkspaceConnectionInfo(); workspaceConnectionInfo.Type=WorkspaceType.SXWU; String file = @"D:\world\world.sxwu"; workspaceConnectionInfo.Server=file; workspace.Open(workspaceConnectionInfo); Datasource datasource = workspace.Datasources[0]; DatasetVector dataset = (DatasetVector) datasource.Datasets["World"]; Console.WriteLine("数据集的描述信息为："+dataset.Description); // 保存工作空间 workspace.Save(); // 另存工作空间 String file_saveAs = "D:/world/world_saveAs.sxwu"; WorkspaceConnectionInfo workspaceConnectionInfo_saveAs = new WorkspaceConnectionInfo(file_saveAs); if (workspace.SaveAs(workspaceConnectionInfo_saveAs)) { Console.WriteLine("另存工作空间成功！"); } // 释放资源 dataset.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7484083eda971fd71e75e031817dd499/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e995cafb821c1e10e0b7c811d369686b/" rel="bookmark">
			SpringBoot----实现简单的邮件发送
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot----实现简单的邮件发送 1、新建一个Maven项目springboot8，使用jdk8，在配置文件pom.xml中添加如下依赖：
&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.etc&lt;/groupId&gt; &lt;artifactId&gt;springboot8&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;springboot8&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.4.7.RELEASE&lt;/version&gt; &lt;relativePath /&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- SpringBoot导入的jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 邮件 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 模板thymeleaf --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- SpringBoot 测试包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 2、在com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e995cafb821c1e10e0b7c811d369686b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdc3e5fd114d09bc78cd81ed0b4ef9fc/" rel="bookmark">
			python敲得代码（从入门到实践书中代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		8.3.4
'''与用户打招呼，随时按q退出''' def get_formatted_name(first_name,last_name): full_name = first_name +' '+ last_name return full_name.title() while True: print('\nPlease tell me your name:') print("(enter 'q' at any time to quit)") f_name = input('First name:') if f_name == 'q': break l_name = input('Last name:') if l_name == 'q': break formatted_name = get_formatted_name(f_name,l_name) print('\nHello,' + formatted_name + '!') 8-7专辑
def make_album(singer,album,number=''): album = {'singer_name':singer,'album_name':album} if number: album['number'] = number return album zhou = make_album('Zhoujielun','daoxiang',5) lin = make_album('Linjunjie','shashou') xu = make_album('Xusong','zaiyebujian',8) print(zhou) print() print(lin) print() print(xu) 8-8
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fdc3e5fd114d09bc78cd81ed0b4ef9fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc11d0f1b6cbce30b26ad90ae7a554a0/" rel="bookmark">
			python3下使用requests实现模拟用户登录 —— 基础篇（马蜂窝）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python3下使用requests实现模拟用户登录 —— 基础篇（马蜂窝） ##1. 了解cookie和session
首先一定要先了解到cookie和session是什么，这是后面理解网站交互，模拟用户登录的基础。
###1.1. 无状态协议：Http
如上图所示，HTTP协议 是无状态的协议，用户浏览服务器上的内容，只需要发送页面请求，服务器返回内容。对于服务器来说，并不关心，也并不知道是哪个用户的请求。对于一般浏览性的网页来说，没有任何问题。
但是，现在很多的网站，是需要用户登录的。以淘宝为例：比如说某个用户想购买一个产品，当点击 “ 购买按钮 ” 时，由于HTTP协议 是无状态的，那对于淘宝来说，就不知道是哪个用户操作的。
为了实现这种用户标记，服务器就采用了cookie这种机制来识别具体是哪一个用户的访问。
###1.2. 了解cookie
如图，为了实现用户标记，在Http无状态请求的基础之上，我们需要在请求中携带一些用户信息（比如用户名之类，这些信息是服务器发送到本地浏览器的，但是服务器并不存储这些信息），这就是cookie机制。如下图所示，在登录马蜂窝网站之后，就可以看到浏览器已经保存了一些cookie信息（chrome浏览器为例）：
需要注意的是：cookie信息是保存在本地浏览器里面的，服务器上并不存储相关的信息。 在发送请求时，cookie的这些内容是放在 Http协议中的header 字段中进行传输的。
几乎现在所有的网站都会发送一些 cookie信息过来，当用户请求中携带了cookie信息，服务器就可以知道是哪个用户的访问了，从而不需要再使用账户和密码登录。
但是，刚才也提到了，cookie信息是直接放在Http协议的header中进行传输的，看得出来，这是个隐患！一旦别人获取到你的cookie信息（截获请求，或者使用你的电脑），那么他很容易从cookie中分析出你的用户名和密码。为了解决这个隐患，所以有了session机制。
###1.3. 了解session
刚才提到了cookie不安全，所以有了session机制。简单来说（每个框架都不一样，这只是举一个通用的实现策略），整过过程是这样：服务器根据用户名和密码，生成一个session ID，存储到服务器的数据库中。用户登录访问时，服务器会将对应的session ID发送给用户（本地浏览器）。浏览器会将这个session ID存储到cookie中，作为一个键值项。以后，浏览器每次请求，就会将含有session ID的cookie信息，一起发送给服务器。服务器收到请求之后，通过cookie中的session ID，到数据库中去查询，解析出对应的用户名，就知道是哪个用户的请求了。 ####1.3.1. 看一下Django是如何实现session机制的，来加深对session的了解
第一步：对用户登录信息进行加密，生成一个sessionID，存储到数据库中。
Session_key：服务器给用户返回的ID Session_data：一段加密的文字。用户名，密码，一些其他的用户信息。把这些信息生成一段字符串，是加密的 expire_date：django后台会设置过期时间。 主要是担心session被黑客截取，那就一直可以用，盗用数据。 第二步，当用户登录时，服务器会给本地浏览器返回一些cookie信息，包括session ID。
第三步：以后浏览器每次访问时，浏览器都会把 session ID带过来，这样服务器不需要知道你的用户名，就知道是哪个用户的访问了。
服务器是如何把sessionID转换成用户名的？
如上图所示，在Django中，需要对session进行配置。这个INSTALLED_APPS 是会对每次request和response进行拦截，拦截到浏览器发送过来的request时，找到其中的session信息，然后到数据库中进行查询，找到session_data，再做解密，就知道所有的用户信息了，取出user信息。新建完Django项目之后，这个sessions信息就配置好了。如果注释掉这一个session配置，自动登录机制就会失效，无法使用。
###1.4. 总结一下
cookie 在客户端（本地浏览器），session 在服务器端。cookie是一种浏览器本地存储机制。存储在本地浏览器中，和服务器没有关系。每次请求，用户会带上本地cookie的信息。这些cookie信息也是服务器之前发送给浏览器的，或者是用户之前填写的一些信息。Cookie有不安全机制。 你不能把所有的用户信息都存在本地，一旦被别人窃取，就知道你的用户名和密码，就会很危险。所以引入了session机制。服务器在发送id时引入了一种session的机制，很简单，就是根据用户名和密码，生成了一段随机的字符串，这段字符串是有过期时间的。一定要注意：session是服务器生成的，存储在服务器的数据库或者文件中，然后把sessionID发送给用户，用户存储在本地cookie中。每次请求时，把这个session ID带给服务器，服务器根据session ID到数据库中去查询，找到是哪个用户，就可以对用户进行标记了。session 的运行依赖 session ID，而 session ID 是存在 cookie 中的，也就是说，如果浏览器禁用了 cookie ，那么同时 session 也会失效（但是可以通过其它方式实现，比如在url中传递 session ID）用户验证这种场合一般会用 session。 因此，维持一个会话的核心就是客户端的唯一标识，即session ID ##2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc11d0f1b6cbce30b26ad90ae7a554a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f40639f130df489d18ff1cfa8f273bb/" rel="bookmark">
			Maven build：关于“No plugin found for prefix &#39;tomcat7&#39; in the current project and in the plugin groups
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在build Maven工程时，有时候会遇到以下的异常：
异常分析：从字面上理解，该异常指的是Maven工程缺少tomcat7相依的插件，所以，需要我们手动添加插件。
解决方案：
1) 选中需要build的工程，右键 Maven--&gt;Add Plugin;
2)根据所需要添加的插件版本信息，填写Group Id及Artfact Id、Version值，如：tomcat7的配置信息为：
配置完成之后，点击“OK”，最后，在项目的pom.xml文件中会出现添加的插件的配置信息，此时，表示插件添加成功；
3）重新Maven build项目即可解决问题。
关于这个异常的出现的原因及处理方式在网上有很多种情况，在这里只是把我自己遇到的情况及解决方案与大家交流，希望能帮到你们解决问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2884b00924fa546c1e7c749288e6590e/" rel="bookmark">
			Spring Boot之JPA杂记Inner Join
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		只为了实现一个很简单的操作：
select t1.id,t1.studentname,t2.gradename from student t1 inner join grade t2 on t1.gradeid=t2.id 先创建了两个Entity
@Entity public class Grade { @Id @GeneratedValue private Long id; private String gradename; //省略set get public Grade(Long id, String gradename) { super(); this.id = id; this.gradename = gradename; } } @Entity public class Student { @Id @GeneratedValue private Long id; private Long gradeid; private String studentname; //省略set get public Student(Long id, Long gradeid, String studentname) { super(); this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2884b00924fa546c1e7c749288e6590e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/956fc7cd79cc2258f0b84bf3a962d33f/" rel="bookmark">
			批处理系列(5) - 根据文件名自动创建目录存放文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		结合本系列文章第一篇，看本文。
应用场景：
一个目录下有若干文件，但是，有一定规则，如有按年份命名，
1998-001.jpg ~ 1998-xxx.jpg 1999-001.jpg ~ 19998-xxx.jpg ... 这样，根据"tokens=1,* delims=-"切分字符串，并创建年份的目录，保存对应的所有文件。
@echo off @REM @Author: xianghongai@gmail.com title 根据文件名自动创建目录存放文件 by：小可(xianghongai@gmail.com) @echo 根据文件名自动创建目录存放文件 @echo ------------------------------------- :GTBegin @echo 默认处理目录下所有格式文件，确定继续？(y/n) set /p GTConfirm= if "%GTConfirm%"=="y" goto GTYES if "%GTConfirm%"=="Y" goto GTYES if "%GTConfirm%"=="n" goto GTNO if "%GTConfirm%"=="N" goto GTNO echo 请输入正确的指令 pause &gt;nul goto GTBegin :GTYES @echo ------------------------------------- set /p FilePath=需要处理的目录: cd /d %FilePath% for /f "tokens=1,* delims=-" %%J in ('dir /b *.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/956fc7cd79cc2258f0b84bf3a962d33f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d76d9acef9729a2b3cbf281267e38043/" rel="bookmark">
			论文笔记：Neural Factorization Machines for Sparse Predictive Analytics
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hexiangnan
2017 Neural Factorization Machines for Sparse Predictive Analytics
Many predictive tasks of web applications need to model categorical variables, such as user IDs and demographics like genders and occupations. To apply standard machine learning techniques, these categorical predictors are always converted to a set of binary features via one-hot encoding, making the resultant feature vector highly sparse. To learn from such sparse data effectively, it is crucial to account for the interactions between features.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d76d9acef9729a2b3cbf281267e38043/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e3ea29b94a6752241ca020d6226b321/" rel="bookmark">
			Thymeleaf读取html字符串自动转义问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目中因为要做高亮显示，所以后台传来的数据，对于关键字会用&lt;em&gt;标签做高亮显示
但是使用 th:text输出时候会自动进行转义，导致直接输出标签文本
解决办法：
把 th:text 换成 th:utext
原来：th:text="${law.id}"
现在:th:utext="${law.id}"
完毕之后已经可以正常显示高亮效果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9782ffa921b1a906118cf15b74be9a4/" rel="bookmark">
			刷题系列之Python基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、题目描述： 下列表达式的值为True的是： A、5+4j &gt; 2-3j B、3&gt;2&gt;2 C、（3,2）&lt;（’a’,’b’） D、’abc’ &gt;’xyz’
对于A：复数不能比较大小 B: Python2支持连续比较，相当于3&gt;2and2&gt;2，所以B不对 C:元组类型的比较是元素多的大于元素少的，若元素个数相等，则从第一个元素开始依次向后比较，直到两个元素不相等才结束。也就是判断3&lt;’a’就结束了，因为两者不等 在比如，比较（1,9） &lt;（2,3） ,也是返回True，因为1&lt;2就结束了。 D:字符串的比较不会像tuple一样先看长短，而是直接从第一个开始比较，直到两者不等就结束，这里’a’&lt;’x’结束了。
2、解释性语言的特性：
A. 非独立 B. 效率低 C. 独立 D. 效率高
解释性语言和编译性语言的定义： 计算机不能直接理解高级语言，只能直接理解机器语言，所以必须要把高级语言翻译成机器语言，计算机才能执行高级语言编写的程序。 翻译的方式有两种，一个是编译，一个是解释。两种方式只是翻译的时间不同。
解释性语言的定义： 解释性语言的程序不需要编译，在运行程序的时候才翻译，每个语句都是执行的时候才翻译。这样解释性语言每执行一次就需要逐行翻译一次，效率比较低。 现代解释性语言通常把源程序编译成中间代码，然后用解释器把中间代码一条条翻译成目标机器代码，一条条执行。
编译性语言的定义： 编译性语言写的程序在被执行之前，需要一个专门的编译过程，把程序编译成为机器语言的文件，比如exe文件，以后要运行的话就不用重新翻译了，直接使用编译的结果就行了（exe文件），因为翻译只做了一次，运行时不需要翻译，所以编译型语言的程序执行效率高。
非独立：依赖解释器
3、下面哪个不是Python合法的标识符： A.int32 B. 40XL C. self D. name
正像其他普通编程语言的通用规则，Python中的标识符不能以数字开头。
4、有一段python的编码程序如下：urllib.quote(line.decode(“gbk”).encode(“utf-16”)),请问经过该编码的字符串的解码顺序是（ ） 字符串编译的过程：gbk==&gt;unicode==&gt;utf16==&gt;url解码 字符串解码顺序为：url解码==&gt;utf16==&gt;unicode==&gt;gbk
5、任何数的0次方都等于1
6、下列对象的布尔值都是False： NONE; False(布尔类型) 所有的值为零的数 0（整型） 0.0（浮点型） 0L(长整型) 0.0+0.0j(复数) “”(空字符串) [] (空列表) () (空元组) {} (空字典)
7、unicode是一种编码标准，具体的实现标准可能是utf-8，utf-16，gbk ……python 在内部使用两个字节来存储一个unicode，使用unicode对象而不是str的好处，就是unicode方便于跨平台。你可以用如下两种方式定义一个unicode: s1 = u”人生苦短” s2 = unicode(“人生苦短”, “utf-8”)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9782ffa921b1a906118cf15b74be9a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07ad35fa863ba95ee078b6a9e7f99894/" rel="bookmark">
			主板BIOS设置来电开机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来电开机等主板BIOS设置
一、来电自动开机一般计算机在市电停电再来电后主机不会自动开启，你需要按一下POWER键重新开机，而服务器一般都能在市电断开再来电的时候自动加电开机，这一功能是怎么实现的呢？其实很简单，你家的计算机也有这样的功能，只需进入BIOS进行设置即可。开机按“DEL”键，进入主板的BIOS，选择“PowerManagementSetup（电源管理设置）”，其中有一个选项为“PwronAfterPW-Fail”意思是：电源故障断电之后，来电自动开机。默认设置值是“Disabled”，即接通电源后不会自动开机，我们把该项设置值改为“Enabled”，这样断电恢复后就能自动开机了。不过，并不是每一款主板都支持这项功能的，你自己进入BIOS，实地查看一下就知道了。不同的主板，设置项不同，有些主板是要像如下这样设置：PowerManagementSetup（电源管理设定）→PowerAgain（再来电状态），此项决定了开机时意外断电之后，电力供应恢复时系统电源的状态。设定值有：PowerOff（保持系统处于关机状态）PowerOn（保持系统处于开机状态）LastState（恢复到系统断电前的状态）进入挂起/睡眠模式，但若按钮被揿下超过4秒，机器关机。或者是这样：选择[POWERMANAGEMENTSETUP]，再选择[PWRLostResumeState]，这一项有三个选择项。选择[KeepOFF]项，代表停电后再来电时，电脑不会自动启动。选择[TurnOn]项，代表停电后再来电时，电脑会自动启动。选择的[LastState]，那么代表停电后再来电时，电脑恢复到停电前电脑的状态。断电前如果电脑是处于开机状态，那么来电后就会自动开机。断电前是处于关机状态，那么来电后电脑不会自动开机。
二、定时开机现在有很多定时关机的软件，可以设计一个时间，计算机到时间自动关机。但是开机就不会受软件的控制了，只能通过主板的BIOS设置来解决。方法是，开机按Del键，进入BIOS设置程序画面。选择“PowerManagementSetup”(电源管理设置)，将“RTCAlarmResume”(预设时间启动)一项设置为“Enabled”，下面出现两个设置项，“Dateofmonth”(系统开机日期)和“Time(hh:mm:ss)”(系统开机时间)，通过这两项设置开机的日期和时间，日期可以设置为“EventDay”（每天）,设置好后，计算机就会根据你设定的时间自动开机了。
三、鼠标开机开机按Del键，进入BIOS设置程序画面。选择“PowerManagementSetup”(电源管理设置)选项，将“MousePowerOn”的值改为“Enabled”，保存退出，这样通过双击鼠标按键就可以开机了。
四、键盘开机同鼠标开机设置方法差不多，开机按Del键，进入BIOS设置程序画面。将“PowerManagementSetup”(电源管理设置)下面的选项“KeyboardPowerOn”的值改为“Enabled”，这样通过按键盘上的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd598b181a146d1a4bebb52855a8ea8c/" rel="bookmark">
			Windows 查看哪个进程在使用指定的文件 - 文件被占用，无法删除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打开任务管理器
选择“Resource Monitro”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ba1746775b9c71a5419ea630fd03a29/" rel="bookmark">
			Android安卓抖动动画的实现方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果：
一、使用Animation(补间动画) 1.1代码实现
/** * 晃动动画 * * @param counts 0.5秒钟晃动多少下 * @return */ public static Animation shakeAnimation(int counts) { Animation translateAnimation = new TranslateAnimation(0, 10, 0, 0); //设置一个循环加速器，使用传入的次数就会出现摆动的效果。 translateAnimation.setInterpolator(new CycleInterpolator(counts)); translateAnimation.setDuration(500); return translateAnimation; } /** * 0.1秒钟摇动3下 * @param counts * @param view */ public static void overshootAnimation(int counts, View view) { TranslateAnimation animation = new TranslateAnimation(0, -5, 0, 0); animation.setInterpolator(new OvershootInterpolator()); animation.setDuration(100); animation.setRepeatCount(3); animation.setRepeatMode(Animation.REVERSE); view.startAnimation(animation); } 1.2xml动画布局文件实现
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ba1746775b9c71a5419ea630fd03a29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a4e7883c4aba740cfc58f89947d6bd8/" rel="bookmark">
			树莓派扩展磁盘空间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用树莓派自建的工具可以快速将树莓派挂载所有的SD卡空间。
命令行输入：sudo raspi-config
然后在选择Advancd Options -&gt; Expand Filesystem
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7044e9167dc001cdddc1d87aa4a2533e/" rel="bookmark">
			Open the Java build path property page of project &#39;XXX&#39;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Open the Java build path property page of project ‘XXX’ http://blog.csdn.net/yoen_qin/article/details/24362537 原因：JDK版本不一致。
解决办法： 1. 打开window—&gt;preferences，在java—&gt;installed JREs里面有一个编辑jre的功能，选择你的jdk.
ArtifactTransferException: Failure to transfer解决方法 http://blog.csdn.net/ayouaretheone/article/details/52274814 maven库里面能找到这个依赖的jar文件，但是在本地的maven库里面找不到 错误翻译：对于这个包从maven中心传输到本地仓库失败，决定不会重新尝试下载jar包，直到mavne再改更新索引，或强制更新。
解决方法：将本地库里面这个依赖对应的文件夹删掉，然后在eclipse里面执行update dependencies。成功解决问题！ 右键单击项目-&gt;maven-&gt;update dependencies。 或者配置一下在eclipse中maven的本地仓库
Eclipse错误 1. Implicit super constructor Object() is undefined for default constructor. Must define an explicit constructor 解决方案：把java的类库加载进去，在工程上右键选择属性-&gt;Java Build Path的Libraries-&gt;Add Library选择JRE System Library-&gt;点击Next-&gt;选择Execution environment并选择版本或workspace default jre-&gt;点击Finish。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56f7a42447ba0db56c3810a4832b9ba6/" rel="bookmark">
			浅析Kubernetes StatefulSet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; StatefulSet和Deployment的区别 “Deployment用于部署无状态服务，StatefulSet用来部署有状态服务”。
具体的，什么场景需要使用StatefulSet呢？官方给出的建议是，如果你部署的应用满足以下一个或多个部署需求，则建议使用StatefulSet。
稳定的、唯一的网络标识。稳定的、持久的存储。有序的、优雅的部署和伸缩。有序的、优雅的删除和停止。有序的、自动的滚动更新。 稳定的主要是针对Pod发生re-schedule后仍然要保持之前的网络标识和持久化存储。这里所说的网络标识包括hostname、集群内DNS中该Pod对应的A Record，并不能保证Pod re-schedule之后IP不变。要想保持Pod IP不变，我们可以借助稳定的Pod hostname定制IPAM获取固定的Pod IP。借助StatefulSet的稳定的唯一的网络标识特性，我们能比较轻松的实现Pod的固定IP需求，然后如果使用Deployment，那么将会复杂的多，你需要考虑滚动更新的过程中的参数控制(maxSurge、maxUnavailable)、每个应用的IP池预留造成的IP浪费等等问题。
因此，我想再加一个StatefulSet的使用场景：
实现固定的Pod IP方案, 可以优先考虑基于StatefulSet； 最佳实践 StatefulSet对应Pod的存储最好通过StorageClass来动态创建：每个Pod都会根据StatefulSet中定义的VolumeClaimTemplate来创建一个对应的PVC，然后PVS通过StorageClass自动创建对应的PV，并挂载给Pod。所以这种方式，需要你事先创建好对应的StorageClass。当然，你也可以通过预先由管理员手动创建好对应的PV，只要能保证自动创建的PVC能和这些PV匹配上。
为了数据安全，当删除StatefulSet中Pods或者对StatefulSet进行缩容时，Kubernetes并不会自动删除StatefulSet对应的PV，而且这些PV默认也不能被其他PVC Bound。当你确认数据无用之后再手动去删除PV的时候，数据是否删除取决于PV的ReclaimPolicy配置。Reclaim Policy支持以下三种:
Retain，意味着需要你手动清理；
Recycle，等同于rm -rf /thevolume/*
Delete，默认值，依赖于后端的存储系统自己实现。
注意：
目前只有NFS和HostPath支持Recycle;EBS,GCE PD, Azure Disk，Openstack Cinder支持Delete。 请小心删除StatefulSet对应的PVC，首先确保Pods已经完全Terminate，然后确定不需要Volume中的数据后，再考虑删除PV。因为删除PVC可能触发对应PV的自动删除，并根据StorageClass中的recalimPolicy配置可能造成volume中的数据丢失。
因为部署的是有状态应用，我们需要自己创建对应的Headless Service，注意Label要和StatefulSet中Pods的Label匹配。Kubernetes会为该Headless Service创建对应SRV Records，包含所有的后端Pods，KubeDNS会通过Round Robin算法进行选择。
在Kubernetes 1.8+中，你必须保证StatefulSet的spec.selector能匹配.spec.template.metadata.labels，否则会导致StatefulSet创建失败。在Kubernetes 1.8之前，StatefulSet的spec.selector如果没指定则默认会等同于.spec.template.metadata.labels。
对StatefulSet进行缩容前，你需要确认对应的Pods都是Ready的，否则即使你触发了缩容操作，Kubernetes也不会真的进行缩容操作。
如何理解稳定的网络标识 StatefulSet中反复强调的“稳定的网络标识”，主要指Pods的hostname以及对应的DNS Records。
HostName：StatefulSet的Pods的hostname按照这种格式生成：$(statefulset name)-$(ordinal)， ordinal从0 ~ N-1(N为期望副本数)。 StatefulSet Controller在创建pods时，会给pod加上一个pod name label：statefulset.kubernetes.io/pod-name, 然后设置到Pod的pod name和hostname中。pod name label有啥用呢？我们可以创建独立的Service匹配到这个指定的pod，然后方便我们单独对这个pod进行debug等处理。DNS Records： Headless Service的DNS解析：$(service name).$(namespace).svc.cluster.local 通过DNS RR解析到后端其中一个Pod。SRV Records只包含对应的Running and Ready的Pods，不Ready的Pods不会在对应的SRV Records中。Pod的DNS解析：$(hostname).$(service name).$(namespace).svc.cluster.local解析到对应hostname的Pod。 如何理解稳定的持久化存储 每个Pod对应一个PVC，PVC的名称是这样组成的:$(volumeClaimTemplates.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56f7a42447ba0db56c3810a4832b9ba6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/554c9fc958b9d98cb913378c9b6b58ed/" rel="bookmark">
			unity如何恢复崩溃前的Scene
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 unit有时会遇到unity崩溃后，辛辛苦苦做的场景就这么没了的情况，这种情况非常忧伤的，其实unity是提供了一种拯救场景的措施的； 首先unity崩溃后不要重新打开unity，切记，不然就之前的成果就找不回来了；打开你的工程所在目录，找到Temp文件夹（该文件夹正常情况下在工程里是没有的，只有崩溃后才出现，重新打开unity，该文件夹就会消失），在其中找到_Backupscenes文件夹，然后打开_Backupscenes文件夹，找到其中的0.backup文件，没错，就是它，将backup后缀改成a.unity，然后将文件存放到其他地方去（非Temp文件夹）。然后重新打开unity，将a.unity文件拖到unity中即可； 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5f9c99f998368d141d6bf08d4dab772/" rel="bookmark">
			树莓派3b——连接18b20测温度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看自身cpu的温度：
vcgencmd measure_temp 或
cat /sys/class/thermal/thermal_zone0/temp 查看cpu当前频率：
vcgencmd measure_clock arm 树莓派系统包含了18b20的驱动（1-wire interface），我们只需要将其开启即可。有两种开启方式：
方式一：输入raspi-config命令，然后在interfacing options –&gt; 1-wire中设为enable。方式二：在/boot/config.txt文件中，添加dtoverlay=w1-gpio,gpiopin=4 这两种方式最终都是在config.txt文件中添加了如上命令。记得配置完后重启下开发板。
开始，第一步，连线 从前面步骤可以看到，我们开启了gpio4作为数据输入口，gpio4对应针脚7。
18b20针脚： 树莓派针脚： 连线图，注意，一定要接上拉电阻！一定要接上拉电阻！一定要接上拉电阻！否则18b20会无法识别： 第二步，查看18b20的温度
要注意的是，多个18b20并联的话，它们可以同时工作。
cd /sys/bus/w1/devices/ 然后ls一下，如果一切正常，你连接了几个18b20，这里就有几个28-xxx打头的目录，我们随便进入其中一个，然后cat一下w1_slave这个文件：
cd 28-05fsda5f9dsa5f90dsa cat w1_slave 此时会输出如下信息：
70 01 4b 46 7f ff 10 10 e1 : crc=e1 YES 70 01 4b 46 7f ff 10 10 e1 t=23000 其中那个YES表示温度是否采集成功，t=23000表示采集的温度数据，将其除以1000即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5323db644a1106e7126d9fe3730a2a9a/" rel="bookmark">
			SpringBoot----利用JpaRepository实现数据的增删查改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot----利用JpaRepository实现数据的增删查改 1、新建一个Maven项目，使用jdk1.8，在pom.xml中添加如下依赖：
&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.etc&lt;/groupId&gt; &lt;artifactId&gt;springboot4&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;springboot4&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.4.7.RELEASE&lt;/version&gt; &lt;relativePath /&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- SpringBoot web开发包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- SpringBoot 测试包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- mysql --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.35&lt;/version&gt; &lt;/dependency&gt; &lt;!-- data jpa依赖包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5323db644a1106e7126d9fe3730a2a9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba2ea94f983f5518507b0f1752e7af83/" rel="bookmark">
			电源已接通，未充电——解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 笔记本出现这个问题已经很久了，之前我一直以为是电池坏了，遂买了块新电池，然仍然充不进去电，终于找到了正确解决方案。
首先，并不是电池坏了，因为如果电池坏了的话是会接通不了的，这时候你可以试试把电池拔了开机，显示的并不相同，那样会显示检测不到电源。
然后坏掉的地方可能是主板、适配器，或者什么都没坏
如果是硬件损坏那就只能拿去修了，然而如果什么都没坏，又是为什么呢？ 如果是一些软件为了保护电池把其充电禁止了，那么开启即可。而另外一种情况，就比较玄学了。
换个排插吧，多换几个排插试试，贴吧里说：如果是交流电的话是充不进电的。但是我想说的是难道不都是交流电嘛 可是就是这么神奇，换一个插孔就充进去了
欢迎大家加入QQ群一起交流讨论， 「吟游」程序人生——YinyouPoet 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1d6337597cab5d2d9b86f6dd5be0e80/" rel="bookmark">
			树莓派命令行模式调整音量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在命令行中输入
alsamixer 1 会进入图形界面，在图形界面中进行更改音量。 最大音量了100%.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c564cda1da4c842be94be6a99b2ef97d/" rel="bookmark">
			树莓派更改软件源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文基本涵盖树莓派Raspbian主流国内软件源（stretch及jessie）及少量国外知名软件源。
目前最新的系统Raspbian（2017-08-16及以后的系统）已经基于Debian 9 Stretch，请选择正确的软件源。
更换源后，需要更新本地软件索引：
sudo apt-get update 零、一键换源 直接执行以下两步，即可替换将官方默认软件源替换为
中科大镜像源
sudo sed -i 's#://mirrordirector.raspbian.org#s://mirrors.ustc.edu.cn/raspbian#g' /etc/apt/sources.list sudo sed -i 's#://archive.raspberrypi.org/debian#s://mirrors.ustc.edu.cn/archive.raspberrypi.org#g' /etc/apt/sources.list.d/raspi.list 或换为清华镜像源
sudo sed -i 's#://mirrordirector.raspbian.org#s://mirrors.tuna.tsinghua.edu.cn/raspbian#g' /etc/apt/sources.list sudo sed -i 's#://archive.raspberrypi.org/debian#s://mirrors.tuna.tsinghua.edu.cn/raspberrypi#g' /etc/apt/sources.list.d/raspi.list 一、树莓派基金会提供的源 /etc/apt/sources.list.d/raspi.list里的软件源是树莓派基金会单独（非Raspbian开发者）提供/维护的软件源，主要包括raspi-config、minecraftpi、树莓派桌面环境、内核固件驱动等少量软件。
这个软件源相关资料比较少，国内目前只有清华（201709开始提供）和中科大有提供
Stretch（三选其一即可）
中科大 deb https://mirrors.ustc.edu.cn/archive.raspberrypi.org/ stretch main ui 清华 deb https://mirrors.tuna.tsinghua.edu.cn/raspberrypi/ stretch main ui 默认官方源 deb http://archive.raspberrypi.org/debian/ stretch main ui Jessie（三选其一即可）
中科大 deb https://mirrors.ustc.edu.cn/archive.raspberrypi.org/ jessie main ui 清华 deb https://mirrors.tuna.tsinghua.edu.cn/raspberrypi/ jessie main ui 默认官方源 deb http://archive.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c564cda1da4c842be94be6a99b2ef97d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d52127567ecbe5187611e528044a41be/" rel="bookmark">
			Q_OBJECT 导致 error: undefined reference to `vtable for XXXX&#39; 错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Qt 编译环境下，自定义类继承 Qt 类时，程序报错 error: undefined reference to `vtable for XXXX'。这个错误看起来是虚函数表无法引用到，也就是继承 Qt 类失败了。
解决方案：删除编译文件夹，重新 rebuild 工程。
出于对 Q_OBJECT 宏的好奇，大致读了下 Qt 帮助文档对 Q_OBJECT 宏的解释，具体如下（英语不太好，谅解）：
Using the Meta-Object Compiler(moc)
元对象编译器(moc)它是用来处理 Qt's C++ 扩展程序。
moc 工具读取一个 C++ 头文件，如果它一个或多个在类声明中包含 Q_OBJECT 宏，它会为这些类产生一个包含元对象代码 C++ 源文件。除了其他方面，对于信号槽机制、运行时类型信息、动态属性系统，元对象代码是必须的。
由 moc 生成的 C++ 源文件必须被编译并与实现类相链接。
如果你使用 qmake 去创建你的 makefiles，在需要的时候编译规则将包括调用 moc，因此你不需要直接使用 moc。针对更多关于 moc 信息，请看 Why Does Qt Use Moc for Signals and Slots? Usage
moc 典型的用法是和一个包含类声明的输入文件，就像这样：
class MyClass : public QObject { Q_OBJECT public: MyClass(QObject* parent = 0); ~MyClass(); signals: void mySignal(); public slots: void mySlot(); } 除上面所示的信号和槽之外， moc 还实现了对象属性就像下一个例子。Q_PROPERTY() 宏声明了一个对象属性，而Q_ENUMS() 宏声明一系列枚举类型在类里面，它对属性系统里面是有用的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d52127567ecbe5187611e528044a41be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db0a46551da1c9756f1dfd72fcb3cada/" rel="bookmark">
			postgresql数据库的 to_date 和 to_timestamp 将 字符串转换为时间格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 数据库中：字符串 转换为 时间格式 二者区别： to_data 转换为 普通的时间格式 to_timestamp 转换可为 时间戳格式 出错场景： 比较同一天 日期大小的时候，很容易出错 例如： select current_timestamp from pub_employee 结果如下： select current_timestamp &lt;= to_date('2018-03-12 18:47:35','yyyy-MM-dd hh24:mi:ss') flag from pub_employee 语句中的 2018-03-12 18:47:35 要比 current_timestamp当前的时间 大两个小时， 但是结果如下： 结果是 false 原因是：select to_date('2018-03-12 18:47:35','yyyy-MM-dd hh24:mi:ss') from pub_employee 的结果如下：并不是时间戳 正确的写法 select current_timestamp &lt;= to_timestamp('2018-03-12 18:47:35','yyyy-MM-dd hh24:mi:ss') flag from pub_employee 结果： 为true 因为：select to_timestamp('2018-03-12 18:47:35','yyyy-MM-dd hh24:mi:ss') from pub_employee ============================================================ to_date: 方式一：正确 select to_date('2018-03-08','yyyy-MM-dd') from pub_employee 方式二： select to_date('2018-03-08 18:55:33','yyyy-MM-dd') from pub_employee 方式三： select to_date('2018-03-08 18:55:33','yyyy-MM-dd hh24:mi:ss') from pub_employee 使用to_date 返回的都是以下结果： to_timestamp: 方式一： select to_timestamp('2018-03-08','yyyy-MM-dd') from pub_employee 方式二： select to_timestamp('2018-03-08 18:55:33','yyyy-MM-dd') from pub_employee 方式一和二都是以下格式，虽然都是时间戳，但是后面一截是0 方式三：正确 select to_timestamp('2018-03-08 18:55:33','yyyy-MM-dd hh24:mi:ss') from pub_employee 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07d1f178760440b550368bb05f0e2c68/" rel="bookmark">
			《怎么挑笔记本电脑》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 我是一名在校大二学生，凭着对电脑的兴趣，大学选择了软件开发专业。接触电脑已有五六年了（不是高手），一开始只会点鼠标，且当时每次关机是直接长按电源键强制关机（强制关机会损坏电脑甚至丢失宝贵资料或数据） …… 而现在，我对电脑的了解还算是可以的了（第一次写博客，害怕大神）。并且最近有很多高中同学，学弟叫我帮忙挑笔记本电脑，因为他们是小白，我直接说你就买这台可能会问：为什么是这台呢？而我做出科学而又不失专业解释后却又一脸萌 = =|| 。于是我写这么一篇博客（同时也是提升自己的写作能力，早就想写博客了，我知道CSDN是程序员论坛，请容许我用我更熟的知识写一篇博客练练手 ^_^）。那么开始进入正文：
如何选笔记本？那么电脑和手机一样，都是看配置，看性价比，看质量的。那么我从选电脑的配置来说怎么选电脑：
一. 中央处理器（CPU）：CPU是电脑的最核心部件之一，被称为电脑的心脏，大脑。它的性能会直接影响电脑运行速度。CPU是有型号的，比如英特尔公司现在比较流行CPU有酷睿系列，比如酷睿i3，i5，i7等，一般来说 i7性能&gt;i5性能&gt;i3性能（但具体还是要看型号的），也就是处理速度更快，更"聪明"，好的CPU开个软件可能瞬间就打开了，而弱一点的可能要等个几秒甚至更久。而大家浏览电脑时，会发现：i3，i5或i7后面还接了一串数字和字母，比如i5-8250U，i7-7700HQ等等。那么这是什么意思呢？这就是CPU的具体型号，数值越大表示CPU越是近几年研发生产出来的，同时性能就越好，当然价格更贵。而后面的英文字母是什么意思呢？
M：代表标准电压CPU并且是可以拆卸的；
U：代表低电压版CPU，就是说比原有CPU基础更省电（非常适合用于轻薄的办公笔记本），但相对削弱了一点性能。，可以拆卸的；
H：是高电压的（一般用于游戏本），焊接在主板上的，不能拆卸；
X：代表高性能，可拆卸；
Q：代表至高性能级别；
Y：代表超低电压的，性能被阉割的更多，且不可拆卸；
两个字母的，属于上面这些字母的组合：比如HQ高电压至高性能处理器。
那么衡量CPU速度的单位是什么？现在一般用GHz（G赫兹），比如一块cpu的速率是2.4GHz，一块是1.9GHz，那么理论上2.4GHz比1.9GHz快。 如果你想更了解最准确的CPU性能排行，可以百度搜索：“最新CPU天梯图”，一定要是近期更新的噢。
这是一块英特尔（intel）i3系列处理器：
二. 硬盘（Hard Disk）：硬盘就是存储数据的场所（非易失储存），比如你安装了QQ，QQ所占的空间就在硬盘里，用去了多少空间，硬盘就少了多少空间，当然是可以删除或清理这些数据的。硬盘越大，你能保存的资料就越多。那么硬盘像CPU一样有速度单位吗？有的，硬盘一般用读写速度衡量其性能，比如某硬盘读速度为100M/s，那么代表它一秒钟可以读取硬盘中100M(兆)的数据，写速度为70M/s，那么你一秒内最多可以向里面存70M数据（就像吃饭一样，最多一口吃多少，吃得下多少就看肚子容量了）。吃饭并不推荐狼吞虎咽，但是硬盘是机器，我们追求速度，从而达到更高效率，于是我们就是要硬盘读写快，就是要它“狼吞虎咽”（毫无人性= =）。
然而，小白们必须知道，现在市面上主要有两种类型硬盘：1.固态硬盘（英文缩写：SSD）2.机械硬盘（英文缩写：HDD）。
那他俩有啥子区别？ 它们最明显的区别就是名字不一样，开玩笑的，最明显的区别就是速度，读写速度，SSD的读写速度普遍高于HDD的读写速度，SSD的读写速度一般为HDD的几倍甚至几十倍。我们前面说过：就是要硬盘“狼吞虎咽”，那么可想而知SSD强于HHD。但这个说法是片面的，因为SSD虽然速度上有优势，但是价格很贵，1000G的HDD市场价在350左右，而1000G的SSD要2000人民币甚至更多。我们一般不推荐全是使用SSD的电脑，因为价格太昂贵了，只有土豪才会怎么做。小伙伴们是不是会看到电脑店里会有很多套餐：128G+500G，128G+1T(1T就是1000G)等等的套餐？128就代表128Gr容量的SSD，500或1T就代表500G或1000G容量的HDD。为什么一台电脑要使用两种硬盘呢？因为这样会对电脑开机速度有很大提升，后面将会说到。
以下分别是笔记本硬盘（小）与台式机硬盘（大）：
三. 内存（Memory）: 内存也是是储存数据的场所，但不同的是，你关机后里面数据会被清空（易失性储存）。比如说你电脑安装了QQ，你打开QQ这个程序，QQ是被放在硬盘的，而当你打开QQ开始运行时，这些需要处理的数据会被临时搬运到内存中，进而让CPU进行处理，从而达到软件运行效果。
那么内存有单位吗？有，它有容量单位，比如4G，8G，16G等等等等，这是个容量是什么意思？怎么相对于硬盘而言这么小？举个栗子：比如开一个QQ要占用100M内存，那么你内存就会减少100M，开两个-200M，开三个-300M…… 容量越大，那么你同时能开的软件就更多(只要不是特别需求，比如使用大型3D绘图软件，玩大型3D游戏，4G内存在现在还是勉强够用的，经济条件允许就8G吧！)。内存还有类型的，比如DDR3，DDR4等等，我就不讨论了，当然4&gt;3，所以，速度自然更快。
下面是一条笔记本内存条（左）和一条台式机内存条（右），笔记本内存条与台式机内存不通用喲，大小接口都不一样：
四. 显卡（Graphics Card）：什么是显卡？顾名思义，显卡就是专门处理图形显示的一个硬件。你的显卡越好，那么你的电脑在使用大型绘图软件，大型3D游戏这些吃显卡配置的软件时候会如鱼得水（非常流畅，当然有时也会要求CPU配置要跟得上，也就是说你cpu很慢，显卡再强也没用，这就有点像木桶效应了），如果你不玩游戏，不用3D绘图，可以略过此段。现在流行的笔记本显卡是英伟达（NVIDA）显卡和AMD公司的显卡，比如现在英伟达公司的GTX系列显卡就非常火，很多游戏本都会选择GTX系列（AMD党勿喷= =||）。GTX后面有具体型号，当然也是数字越大越好，不用说也就更贵。比如性能规律（类似CPU的）：GTX-1060m &gt; GTX-1050Ti &gt; GTX-1050m （英文字母“m”就是mobile的缩写，移动版的意思，相对的是桌面版，可以理解为台式机版，它们不能通用，就是说：笔记本的显卡就是笔记本的显卡，不能用在台式机上，反之亦然。一般台式机显卡更大更强更耗电，移动版小而省电）。如果你想更了解最准确的显卡性能，可以百度搜索：“最新显卡天梯图”，一定要是近期更新的噢。
下面是一块台式机显卡（左）和一块笔记本显卡（右），它们之间也不可通用噢！
五. 显示器（Displayer）：显示器我不说大家应该知道是什么，显示器当然也有好坏，除了质量好坏，还有那些标准呢？
1.分辨率（resolution）：什么是分辨率？我简单解释一下：屏幕能显示出多种多样的图画，都是由一个一个像素点（pixel）构成的，只是它们排列地非常有规律，从而构成了我们能直接看懂的文字，图片，画面等等。那么有些电脑的详情介绍会说到：XX显示器分辨率：1366 x 768 ，这就代表这显示器横排有1366个像素点，竖排有768个像素；XX显示器分辨率：1920 x 1080，这就代表这显示器横排有1920个像素点，竖排有1080个像素点，从而构成一个满是像素点的矩形屏幕。聪明的小伙伴已经知道了，分辨率越高，也就是数值越大，显示器就越清晰，当然就越贵，像现在（2018年）这样网速高速发展的时代，1080分辨率是首选（根据小伙伴自身经济情况）。
2.色域： 我们通常用“色域（比如72% NTSC）”来描述一个显示器的色彩鲜艳程度，百分比越高颜色越鲜艳（说明这个显示器能表示更多的颜色，并不是表面意思的鲜艳，我这里不再讨论这个问题，小伙伴可以百度百科搜索“色域”的概念）。小编推荐色域百分比越高越好（我的笔记本是40%左右的NTSC，跟同桌的颜色没法比，一般70%左右的NTSC就很好了），但不是特别影响你眼睛的体验。
六. 其他：小编以上说的的是我在挑选电脑时主要看的几个方面，当然还有其他方面，比如：笔记本外观颜色，大小，重量，厚度，散热性能，质量，稳定性，售后服务，键盘手感，数据接口（USB，投影仪，显示器接口等等）是否够用等等…… 最后，小编提醒各位小伙伴，电脑一用就是四五年甚至更久，一般来说品牌电脑也不容易坏，一分钱一分货，不要贪图去便宜买个差劲的，不仅速度慢，卡顿，可能用个半年一年就没用了，这样就得不偿失了。像买贵重的东西推荐小伙伴去天猫，京东这样的网站，更放心。当然带着懂得电脑的人去实体店购买也行。
还有，小编可能描述的有点少，不详细，大家可在评论区留下问题，假如小伙伴要靠自己的想法去买一台电脑，而自己又不够懂，你可以问身边的懂这行的“前辈”，去网上查阅大量有关资料，直至自己很懂了再下决定，正所谓三思而后行（用错词没有？不管了）。
小编第一次写CSDN博客，望广大前辈指出不足，谢谢。
转载请注明出处，谢谢~ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2557143c1fc2729ad6403f710d271723/" rel="bookmark">
			js给json对象添加、删除、修改属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;script type="text/javascript"&gt; //json对象 var json={ "firstName":"Bill" , "lastName":"Gates"}; //给json对象添加新的属性并赋值 json.sex="man"; //也可以如下添加新的属性并赋值 json["sex"]="man"; //删除json对象的firstName属性 delete json.firstName; //也可以如下删除firstName属性的值 delete json["firstName"]; //修改json对象的firstName属性的值 json.firstName="Thomas"; //也可以如下修改firstName属性的值 json["firstName"]="Thomas"; &lt;/script&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3ac6c6e7e632aa6799d2bf589898cf0/" rel="bookmark">
			开机启动screen并在后台运行其他程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先我们需要制作一个脚本。在终端下输入并回车新建脚本文件start.sh
touch start.sh chmod 777 start.sh 然后向rc.local文件添加启动代码
修改rc.local文件，在终端输入并回车：
sudo vi /etc/rc.local 在打开的文本中找到exit 0，在此之前添加的代码在启动时都会被执行，在exit 0 之前添加一行代码：
没有 exit 0 的话在最后追加上就可以了。
注：pi 是用户名， 如果需要使用root用户执行脚本 直接填写引号内的内容即可。
su pi -c "exec /home/pi/start.sh" 保存并退出
然后 编辑start.sh
如果我们直接在脚本里写 screen -S my_screen, 会导致脚本无法继续执行。为了使脚本执行下去，创建screen的具体代码如下： screen_name="my_screen" screen -dmS $screen_name 现在，我们就已经创建了一个名为 my_screen 的窗口。然后，我们需要向其发送具体的命令。我们用如下命令：
cmd="python test.py"; screen -x -S $screen_name -p 0 -X stuff "$cmd" screen -x -S $screen_name -p 0 -X stuff '\n' 这样，我们就向screen发送了一条python test.py命令了。
以后其他的开机启动命令都可以放在start.sh中
不过这种方式发送的命令不能太长，否则会导致脚本卡住。
如果需要发送一条很长的命令，或者连续发送许多条命令，最好单独写一个脚本，发送一个脚本命令给screen，让screen执行新的脚本。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/185c01721449ad4860ea81fd2f0d0415/" rel="bookmark">
			vue-cli打包成apk的完整方法和打包成app所遇到的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 vue-cli适合写spa(单页面应用程序)，因此，我们常会用它来开发app,当我们在pc端开发完成之后，肯定需要打包成apk或者ios（ios我在这里先不阐述）。 我的方法是利用hbuilder来构建apk文件。我们将vue项目创建好后，cd项目文件夹，输入npm run dev(3.0以下版本的命令)/npm run serve(3.0以上命令)，打开浏览器，在8080(默认)下查看是否正常显示。 然后用npm run build命令将vue项目进行打包，打包完成后，在项目文件夹中多了一个dist文件夹，这时我们用hbuilder打开vue项目 ， 右键将之转换成移动app ，如果这时候直接将之打包成apk，则会遇到一个巨大的问题，那就是apk安装之后，内容都是空白，没有一点东西，原因就是：路径问题，路径问题，路径问题（重要的事情说三篇），打包好后，所有的路径都是/开头的，/开头表示从根目录开始，而我们需要做的就是将dist项目中的所有/都改为./，./的意思就是当前目录。 然后点击在项目栏中的发行——&gt;云打包，打原生安装包——&gt;最后点击打包完成（如果遇到要配置参数，按需求配置即可）. 下图就是我将打包好的apk安装到手机之后的图片。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbfed53f98c5e47ef6722e8255b397bd/" rel="bookmark">
			38. Count and Say
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：
The count-and-say sequence is the sequence of integers with the first five terms as following:
1. 1 2. 11 3. 21 4. 1211 5. 111221 1 is read off as "one 1" or 11.
11 is read off as "two 1s" or 21.
21 is read off as "one 2, then one 1" or 1211.
Given an integer n, generate the nth term of the count-and-say sequence.
Note: Each term of the sequence of integers will be represented as a string.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbfed53f98c5e47ef6722e8255b397bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/491ab16ca7995caa685c57c2516ca84a/" rel="bookmark">
			string.punctuation
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		string.punctuation：找出字符串中的所有的标点（针对英文）
str='dfaggfgfg,fdfad'
l = str.translate(None,string.punctuation)
将str按照string.punctuation规则转换，即标点符合转换成None
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51d2bec37e4fbef844d97a0a24882e48/" rel="bookmark">
			编程验证哥德巴赫猜想：任意一个充分大的偶数，可以用两个素数之和表示。如： 4 = 2 &#43; 2    6 = 3 &#43; 3。 **输入格式要求：&#34;%d&#34; 提示信息：&#34;Input a number:\n&#34;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;stdio.h&gt; #include &lt;math.h&gt; int main() { int i, m; int p, q, flagp, flagq; printf ( "Input a number:\n" ); scanf ( "%d" , &amp;m); if (m % 2 == 0) { for (p = 2; p &lt; m; p++) { q = m - p; /*以下判断p是否为素数*/ flagp = 1; for (i = 2; i &lt;= sqrt (p) &amp;&amp; flagp; i++) { if (p % i == 0) { flagp = 0; } } /*以下判断q是否为素数*/ flagq = 1; for (i = 2; i &lt;= sqrt (q) &amp;&amp; flagq; i++) { if (q % i == 0) { flagq = 0; } } /*若是素数将其打印，并退出循环*/ if (flagp &amp;&amp; flagq) { printf ( "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51d2bec37e4fbef844d97a0a24882e48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87bff591719fd568911b5b6dfa772049/" rel="bookmark">
			莫凡Python学习笔记——PyTorch 动态神经网络（五）：卷积神经网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内容原文：https://morvanzhou.github.io/tutorials/machine-learning/torch/
一、什么是卷积神经网络CNN（深度学习）
卷积神经网络也近些年来逐步兴起的一种人工神经网络，因为利用卷积神经网络在图像和语音识别方面能够给出更好的预测结果，所以这一技术也被广泛的传播可利用。卷积神经网络最常被应用的方面是图像识别，不过现在在视频分析，自然语言处理，药物发现等等都有了比较多的应用，很火的Alpha Go，也是利用了卷积神经网络，让计算机看懂围棋。
卷积神经网络如何运作？
神经网络都是有一系列的神经层组成，每一层又存在很多神经元，我们的数据就是经过这一个个神经元的处理从而得到我们最后的结果的。
当输入数据是一张图片的时候，计算机看到的并不是一个个图像，而是一组数据，让计算机面对这样一组数据的时候，卷积神经网络便有了优势。
卷积？
卷积神经网络的卷积就是说，计算机在处理数据的时候并不是一个个像素点去处理，而是将图片分成一个个的小区域，让计算机去处理一个个区域，这样计算机就可以看到图像了，增强了计算机输入数据的连续性，同时增强了计算机对于整张图片的理解。
卷积神经网络有一个批量过滤器，持续不断的在图片上滚动收集图片的信息，每一次收集来的信息只是一小块像素区域，然后把收集来的信息进行整理，然后使信息有一个实际上的呈现，比如说计算机就可以看到图片的边缘信息，然后再以同样的步骤，用类似的批量过滤器扫过产生的这些边缘信息，神经网络利用这些边缘信息总结出更高层次的信息，比如，可利用这些边缘信息画图鼻子眼睛等轮廓，再经过一次过滤，脸部的信息也从这些边缘信息中总结出来，然后再把这些信息套入普通的全连接神经网络进行分类，这样就能得到输入的图片能够分为哪一类的结果了。
看上面这张图来理解图片的卷积，每个输入图片都有width，height，depth三个信息，其中depth是计算机呈现颜色的信息，如果是黑白图片的，那他的depth是1，如果是彩色图片那他的depth是3.
迭代器不断扫描，输出一个高度更高，宽和长更小的图片信息，然后再经过这样一次次的卷积，慢慢输出，更高更小的图片，就有了对输入图片更深的理解，加压缩的信息嵌入普通的神经层上，就能对图片进行分类了。
池化（pooling）
在每一次卷积的时候，神经层总是可能会无意的丢失一些信息，所以要利用pooling来解决这一问题。也就是说在卷积的时候，我们不压缩长宽，尽量保持更加完整的信息，保留更多的信息，而压缩的工作就交给池化。
池化其实是一个筛选过程，能将layer中有用的信息筛选出来，给下一层分析，同时也减轻了神经网络的计算负担和工作的准确有效性。
比较流行的一种方式就是这样，从下到上，先是输入图片（image），经过一层卷积层（convolution），然后在用池化（pooling）方式处理卷积的信息，这里使用的是max pooling的方式。然后再经过一次同样的处理，把得到的第二次处理的信息传入两层全连接的神经层（fully connected），这也是一般的两层神经网络层，最后在接上一个分类器（classifier）进行分类预测。
二、CNN的使用
import torch import torch.nn as nn from torch.autograd import Variable import torch.utils.data as Data import torchvision import matplotlib.pyplot as plt #Hyper Parameters EPOCH = 1 #train the traning data n times, to save time, we just train 1 epoch BATCH_SIZE = 50 LR = 0.001 #learning rate DOWNLOAD_MNIST = False #如果你自己下载好了mnist数据了的话，将download设置成FALSE，如果还没有下载好数据的话，那就设置成TRUE train_data = torchvision.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87bff591719fd568911b5b6dfa772049/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6116701930c44d17f282bc54a0e1e0a/" rel="bookmark">
			Android Studio 中超级常用的快捷键使用，提高代码编写效率。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android Studio 中的快捷键是非常多的，熟练使用可以极大程度上的提高代码的编写效率。它和Eclipse的快捷键有所不同，虽然可以在AS上使用Eclipse中的快捷键，但是难免有所冲突，而且不能使用AS中的新增的更人性化的快捷键了。分享一下Android Studio中非常常用的快捷键的使用方法。
总体上有这些：
下面介绍一下如何使用。
1、logt + Enter 快速生成TAG字段
它可以快速生成一个TAG字段，默认是当前活动的名字。这样再使用TAG字段的时候就可以直接引用了。
2、logd + Enter 快速生成一条d级别的log信息
它会把设置好的TAG信息自动引用，输出字符串默认使用当前函数的名字，我们可以自行修改。同理，如果输出e级别的，就loge + Enter，以此类推即可。
3、logm + Enter 快速生成一条带有参数的Log信息
它默认使用的是当前函数的参数。
4、Toast + Tab 快速生成一条Toast语句
这个就不能使用Enter了，开始使用的时候总是按回车，然后就跑下一行去了，哈哈。不过习惯就好了。
另外：log信息的输出，例如1-3，都可以使用logd + Tab的形式去编写代码。统一使用Tab也可。
5、Ctrl + D 复制当前行到下一行，也可以选中多行
非常常用的快捷键！！再也不用Ctrl + C，然后再Ctrl + V了。慢慢纠正，就会感受到Ctrl + D的便利！
6、Ctrl + Y 删除当前行，也可以选中多行
再也不用鼠标左键拖动，选中一行后，在delete了。非常便捷。
7、Ctrl + W 按一下选中当前行，多按选中多行
多数都是用于选中一行。选中多行就多按几次W就好了。
8、Ctrl + N 查找并打开类
如果知道类的名字，只需要按下快捷键后查找，不需要想这个类在哪里定义的，再打开工程面板去点开文件查找。这种方式非常便捷，编写代码时，如果忘记了类中的方法名等信息时，这个功能就可以快速定位类了。
9、Ctrl + B 快速定位变量定义的位置
Ctrl + 鼠标左键 同样可以达到这样的效果，但是为什么使用这种方式呢？是因为这可以使代码编写与鼠标分离。不再依赖鼠标，增加右手劳动。听起来挺吓人的，非常实用就对了。
10、Ctrl + O 快速重写父类方法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6116701930c44d17f282bc54a0e1e0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7d834684df057be59e8d7de5b694856/" rel="bookmark">
			粒子群算法（初步）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文参照：http://blog.csdn.net/liangyixin19800304/article/details/12361165
给出了一种C++解决的方法，非常简单，希望与大家共同交流。目前我的疑惑是，在粒子群算法中的那些参数应该如何选取？
1.惯性系数采用了线性变化的形式，在一开始注重大范围搜索，w值比较大为0.9，最后注重局部走索，w为0.4。（论文上说0.9到0.4）。
2.通过查阅论文，c1和c2的取值应该在1.5到2之间，而且通常而言，应该一开始c1比较大，后期c2比较大。
3.惯性参数可以采用线性变化，也可以用指数函数，有相关论文的。
4.速度限幅决定了精度大小。
5.第二份代码，尝试用粒子群算法解决多峰问题，并且得到比较好的结果。
#include "iostream" #include "algorithm" #include "vector" #include "random" #include "iterator" using namespace std; #define MAX_COUNT 500 #define MAX_M 0.9 #define MIN_M 0.4 double fitness_function(double x) { return -x*(x - 1);//适应函数 } class seed { public: seed() = default; seed(seed&amp; s) { speed = s.speed; w = s.w; c1 = s.c1; c2 = s.c2; present = s.present; } seed&amp; operator=(const seed&amp; s) { if (this == &amp;s) return *this; speed = s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7d834684df057be59e8d7de5b694856/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5169495765fca36531b18618516ea27/" rel="bookmark">
			Spring源码分析总结——Mybatis的整合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该文章基于《Spring源码深度解析》撰写，感谢郝佳老师的奉献
Mybatis与Spring整合 和之前分析的步骤相同，我们先从工厂方法开始分析，对于Mybatis整合的工厂类就是org.mybatis.Spring.SqlSessionFactoryBean 其中有两个值得一提的接口，就是 InitializingBean接口：实现此接口的bean会在初始化时调用器afterPropertiesSet方法来进行bean的逻辑初始化，并通过configuration实例来承载每一步所获取的信息，为创建SqlSessionFactory实例作准备。 FactoryBean接口：将getBean方法转换为getObject方法，所以实际上得到的是通过onfiguration属性和getObject方法返回的初始化后的sqlSessionFactory属性
接下来时另一个配置bean MapperFactoryBean 我们通过区分两种获取XXMapper的方式可以看出一些区别： 1.单独使用Mybatis时： XXMapper xxmapper = sqlsession.getMapper(XXMapper.class); 2.Spring整合之后 XXMapper xxmapper = (XXMapper)context.getBean(“XXMapperID”)； Mapper的类继承关系如上图所示，可以看到它和SqlSessionFactoryBean一样实现了InitializingBean接口和FactoryBean接口，这两个接口的功能就不再赘述。 InitializingBean接口： 需要注意的是InitializingBean接口的afterPropertiesSet()是由DaoSupport类实现的，在该父类的方法中实现了以下几个功能： 1.父类对于sqlSesion不为空的验证，sqlSession作为根据接口创建映射器代理的接触类一定不可以为空，而sqlSession又是在设定sqlSessionFactory属性时完成的，所以实际上将会检测： &lt;bean id=… class=”org.mybatis.Spring.mapper.MapperFactoryBean”&gt; &lt;property name=”sqlSessionFactory” ref=..&gt;该属性是否存在 &lt;bean&gt; 2.映射接口的验证（sqlSession会根据接口动态的创建相应代理类，所以接口必不可少） 3.映射文件存在性验证 FactoryBean接口 源代码
public T getObject() throws Exception { return this.getSqlSession().getMapper(this.mapperInterface); } 很简单，就是将已经注册的MapperInterface返回
如果我们需要指定搜索的包路径我们需要在applicationContext.xml中添加额外的配置
&lt;bean class="org.mybatis.Spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="指定的搜索路径"&gt; &lt;/bean&gt; 这时我们又会引入新的类MapperScannerConfigurer，看一下这个类的类层次结构： 其中出现了我们一直提到的接口InitializingBean接口，但是结果并没有那么顺利，这个接口的作用只是对一堆属性的验证代码。 但是我们还有一个经常出现的接口BeanFactoryPostProcessor及其子类BeanDefinitionRegistryPostProcessor接口，这两个接口都会在Spring初始化的过程中进行调用。 首先看BeanFactoryPostProcessor接口的postProcessBeanFactory方法
public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) { } 这是一个空实现，看看BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry方法：
public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) { if (this.processPropertyPlaceHolders) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5169495765fca36531b18618516ea27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fec71bfe84faa15456fca0622617b942/" rel="bookmark">
			IIS7如何实现访问HTTP跳转到HTTPS访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通常情况下我们是用的都是http的路径，对于https的使用也很少，但是随着https的普及越来越多的域名访问需要用到https的，这个我们就演示怎么设置在我们对一个http的网站进行访问时候自动跳转至https下。
用到的工具及软件:
系统：windows2008R2
软件：IIS7.0，IIS的microsoft URL重写模块2.0
操作步骤：
1、我们需要下载并在IIS中安装microsoft URL重写模块2.0
下载地址：http://www.microsoft.com/zh-cn/download/details.aspx?id=7435 下载安装后我们重启IIS，再打开后会发现在功能视图中又多出了个URL重写的功能
2、对站点进行域名绑定
我们需要将https和http绑定在需要的站点上
3、进程SSL设置
在要求SSL的选择前取消勾选
4、在URL中新建规则
新建一个空白规则，让http的访问跳转到https上
起一个名字例如HTTP to HTTPS redirect
模式：(.*)
添加条件：{HTTPS} 模式：off 或 ^OFF$
在操作设置中选择重定向：https://{HTTP_HOST}/{R:1}
重定向类型：已找到(302) 或 参阅其它(303)
选择应用就可以了
5、测试
转载于:https://www.cnblogs.com/xiefengdaxia123/p/8542737.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9cdd2f2e28e4acf031904b21f613d61/" rel="bookmark">
			割点和割边
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定义 割点的定义(均在无向图中):在一个连通图中,如果有一个顶点集合,删除这个集合中的点以及相关的边之后,连通块的数量会增多.我们就称这个顶点集合为割点集合.如果这个点集合中只有一个点,那么这个点就叫做割点. 割边的定义(均在无向图中):在一个连通图中,如果删去其中一条边后,连通块的数量会增多,那么我们称这条边为桥或者是割边.
例如这个图:A和B都是割点,其中A-B为桥或割边 性质 1).若割点将一个图划分为两个部分U与W,那么所有的u∈U,v∈W,v 处于u到v的每一条路上. 2).每个非平凡的连通图中至少有两个点不是割点. 证明:每个非平凡的连通图中均存在一棵生成树,而非平凡的树上至少有两个度为1的顶点,而这两个顶点正好就是不是割点的两个点
DFS搜索树 1-&gt;2-&gt;3-&gt;5-&gt;4,然后我们可以根据这个序列画出一棵树.
我们把绿色的边称作树边(tree edge),黑色的边称作回边(back edge),通过回边可以访问到之前已经访问过的点.注意,我们常常在遇到一个点去访问它的父节点时,不会将回边表示出来.(如2与3) 这样,我们就得到了一棵DFS搜索树 Tarjan算法 首先选择一个根节点,从它开始进行DFS遍历. 对于根节点来说,判断它是否为割点是十分容易的.我们只需要看它的字树的数量即可.若它的子树的数量&gt;=2,那么它必定为一个割点.(使得子树与子树之间失去了联系) 那么我们只需要求非根节点是否为割点即可.
首先,我们需要定义两个数组:low[]和dfn[]. dfn[u]为u点在上述dfs中是被访问到的第几个点。 low[u]为从u点及u点的子孙出发仅经过一次回边能到达的最小dfn。（如上图low[2]=1 2&gt;3&gt;1）
割点 如果一条边满足low[v]&gt;=dfn[u],那么u点即为一个割点. 证明:如果存在这样一条边满足这样的性质,那么u的儿子v就永远不会访问到早于u的点,那么也就是说,从v出发形成的环中不会包括u,那么从u断开的话,就会形成两个或多个连通块,满足了割点的需求.
首先,low[u]可以先初始化为dfn[u],我们认为u至少能通过回边访问到自己(其实也就是没有回边).然后我们在遍历的过程中,考虑两种情况:一种是v点还没有被访问过,那么它的low[u]=min(low[u],low[v])(此时low[v]已经在dfs的过程中求出来了(在回溯的过程中),v能访问到的最早的点u同样也能访问到). 在过程中如果访问到一个已经访问过的点,那么有low[u]=min(low[u],dfn[v]).然后返回.
割边 割边的求法类似于割点.之前我们说到,在判断非根节点是否为割点时,我们采用了看low[v]&gt;=dfn[u]的做法,在这里我们的做法更加简单. 不需要考虑根节点的问题,只需要判定low[v]&gt;dfn[u]即可.(如之前给出来的图)
例题 题目描述 给出一个无向连通图, 求出所有割点与割边的数量。
输入 第1行: 2个整数N，M (1 &lt;= N &lt;= 5,000，N-1 &lt;= M &lt;= 10,000)，分别表示顶点数和边数 接下来M行，每行2个整数，表示图中的一条边。
输出 第1行：1个整数，表示割点数 第2行：1个整数，表示割边数
样例输入 11 13 1 2 1 4 1 5 1 6 2 11 2 3 4 3 4 9 5 8 5 7 6 7 7 10 11 3 样例输出 4 3 代码 #include&lt;cstdio&gt; #define MAXN 5000 #define MAXM 10000 struct node { int v; node *next; }edge[MAXM * 2 + 5]; node *adj[MAXN+5]; node *ecnt = &amp;edge[0]; int dfn[MAXN+5], low[MAXN+5]; bool vis[MAXN+5]; int n, m; int cp = 0, ce = 0; int dcnt = 0; int rtson = 0; void AddEdge(int u, int v) { node *p = ecnt++; p-&gt;v = v, p-&gt;next = adj[u], adj[u] = p; p = ecnt++; p-&gt;v = u, p-&gt;next = adj[v], adj[v] = p; } void Init() { scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9cdd2f2e28e4acf031904b21f613d61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5be57179a567f49bd407eb72e03c451c/" rel="bookmark">
			微信小程序上传图片 后台Java&#43;spring接收
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在做微信小程序图片上传，将代码上传，造福后来人，废话不多说，贴代码：
微信小程序端
chooseImage(){ wx.chooseImage({ success: function (res) { var tempFilePaths = res.tempFilePaths wx.uploadFile({ url: 'http://127.0.0.1:8888/pesss/weChat/uploadImage.do', filePath: tempFilePaths[0], name: 'file', formData: { 'user': 'test' }, success: function (res) { var data = res.data //do something },fail:function(err){ console.log(err) } }) } }) } java 端：
import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.multipart.MultipartFile; import org.springframework.web.multipart.MultipartHttpServletRequest; import org.springframework.web.servlet.ModelAndView; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.File; import java.io.IOException; @Controller public class ImageTestWebchatController { @RequestMapping(value = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5be57179a567f49bd407eb72e03c451c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3c9d3eb34adf5000469429ac4419272/" rel="bookmark">
			nodejs之Buffer(缓冲区)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：http://www.runoob.com/nodejs/nodejs-buffer.html
JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。
但在处理像TCP流或文件流时，必须使用到二进制数据。因此在 Node.js中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。
在 Node.js 中，Buffer 类是随 Node 内核一起发布的核心库。Buffer 库为 Node.js 带来了一种存储原始数据的方法，可以让 Node.js 处理二进制数据，每当需要在 Node.js 中处理I/O操作中移动的数据时，就有可能使用 Buffer 库。原始数据存储在 Buffer 类的实例中。一个 Buffer 类似于一个整数数组，但它对应于 V8 堆内存之外的一块原始内存。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3558106b840fc235d51467f3d8cbca0c/" rel="bookmark">
			Oracle database audit file housekeeping methods – adump purge
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		oracle audit trace file housekeeping
For Oracle database,SYS, SYSDBA or SYSOPER connections to the Oracle database are always audited. Sometimes this can lead to the creation of an excessive number of audit files. When this is considered to be a problem it cannot be solved at the database side and it must be investigated why the ‘client’ applications including Oracle Enterprise Manager (OEM) Components and agents are connecting so frequently as SYSDBA/SYSOPER.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3558106b840fc235d51467f3d8cbca0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93e520c72bea0c30e2fd93fbb716e39b/" rel="bookmark">
			Lua面向对象学习记录二
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		元表的学习 为表添加操作符 直接看栗子：
function table_maxn(t) local mn = 0 for k, v in pairs(t) do if mn &lt; k then mn = k end end return mn end -- 两表相加操作 mytable = setmetatable({ 1, 2, 3 }, { __add = function(mytable, newtable) for i = 1, table_maxn(newtable) do table.insert(mytable, table_maxn(mytable)+1,newtable[i]) end return mytable end }) secondtable = {4,5,6} mytable = mytable + secondtable for k,v in ipairs(mytable) do print(k,v) end 或者http://blog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93e520c72bea0c30e2fd93fbb716e39b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8906e6e3acd7a76024a7bbec60060278/" rel="bookmark">
			Linux下使用anaconda安装Keras
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、Linux下安装Python
二、Linux下Python安装完成后如何使用pip命令
三、Linux下Python安装完成后如何使用yum命令
四、Linux下安装Anaconda
五、Linux下使用anaconda安装Keras
上一篇博客中介绍了Linux下如何安装anaconda，这篇博客介绍一下如何在Linux下使用anaconda安装Keras。
安装Keras其实很简单，使用conda命令即可：这里需要注意的是，有些包会存在下载不下来的情况，可以设置清华镜像源进行操作，具体如下：
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/menpo/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/ conda config --set show_channel_urls yes 然后再执行conda install keras命令即可。 回车进行安装即可。可能会有很多人奇怪，Keras安装会需要很多其他的依赖，例如：TensorFlow、Theano等。这里直接使用conda安装会不会缺少那些依赖？事实上，使用conda install keras直接安装Keras，Keras所需要的依赖会一并安装。安装完成之后进行测试，如下图所示：
进入python，导入Keras的包如果成功说明Keras包安装成功。
你们在此过程中还遇到了什么问题，欢迎留言，让我看看你们都遇到了哪些问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01847d642d6f58edf6375d2692318f02/" rel="bookmark">
			sqlplus显示乱码--Windows10 处理方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设置环境变量 export NLS_LANG="AMERICAN_AMERICA.AL32UTF8"
格式：NLS_LANG=NLS_LANGUAGE_NLS_TERRITORY.NLS_CHARACTERSET
执行下面的SQL找出这3个值设置环境变量后，重新开启一个CMD窗口登陆sqlplus问题解决。
SQL&gt; select * from nls_database_parameters where parameter in ('NLS_LANGUAGE','NLS_TERRITORY','NLS_CHARACTERSET');
PARAMETER -------------------------------------------------------------------------------- VALUE -------------------------------------------------------------------------------- NLS_LANGUAGE AMERICAN NLS_TERRITORY
AMERICA NLS_CHARACTERSET AL32UTF8
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a5175e8cf39b5ed94c104fdee25a601/" rel="bookmark">
			SpringBoot---使用Mybatis配置文件实现数据的增删查改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot---使用Mybatis配置文件实现数据的增删查改 1、新建一个Maven项目，在pom.xml中添加必要的依赖：
&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.etc&lt;/groupId&gt; &lt;artifactId&gt;springboot&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;springboot&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.4.7.RELEASE&lt;/version&gt; &lt;relativePath /&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.7&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- SpringBoot导入的jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- freemarker模版 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- jdbc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.35&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a5175e8cf39b5ed94c104fdee25a601/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53907bae63e39755ba71524666580c35/" rel="bookmark">
			30分钟后页面自动跳转到登录页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		年前到年后这段时间很浮躁，继续学习之旅，从这篇博客开始，2018，加油！
梭哈梭哈。。。。
代码拿去，妥妥的，什么session，什么filter，什么listener
&lt;script language="javascript"&gt; var myTime = setTimeout("Timeout()", 60000); function resetTime() { clearTimeout(myTime); myTime = setTimeout('Timeout()', 60000); } function Timeout() {
alert("您的登录已超时, 请点确定后重新登录!"); document.location.href='login.jsp';
} document.documentElement.onkeydown=resetTime;
document.doocumentElement.onclick=resetTime; &lt;/script&gt;
拿走了也回来瞅瞅，我感觉不靠谱呢，其实还得session，做技术不能偷懒，其实filter的我感觉最靠谱，网上自行百度把，删除session,跳转页面退出吧，还得稳稳地才行
http://www.jb51.net/article/85800.htm
看看人家的，我和他的经历一样，最终解决。
转载于:https://www.cnblogs.com/jianzhixuan/p/8515327.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66b3b8a746a2f65f302b40ab4462affc/" rel="bookmark">
			python真假判断
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、如下是以下值就认为是假
1、None–&gt;None值
2、False–&gt;False值
3、0–&gt;数值零不管它是int,float还是complex类型
4、”,(),[]–&gt;任何一个空的序列
5、{}–&gt;空的集合。 二、所有不满足False条件的值就当成True
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96d7450e70eca5b0ab0a9befecdf562c/" rel="bookmark">
			syntax error near unexpected token `do
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这种情况发生的原因是因为你所处理的文件换行符是dos格式的"\r\n" 可以使用 cat -v 文件名 来查看换行符是否是。如果是上述的，则行结尾会是^m，需要转换成linux/unix格式的"\n"。
#!/bin/sh^M ^M #frist^M #test script ^M #auther data^M ^M for file in *^M do^M if grep -q POSIX $file^M then^M echo $file^M fi^M done^M ^M 具体转换办法就是转换换行符 可以用sed命令处理一下文件，命令如下：
sed 's/\r//' 原文件 &gt; 转换后文件这是不同系统编码格式引起的：在windows系统中编辑的.sh文件可能有不可见字符，所以在Linux系统下执行会报以上异常信息。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cbca54008951f60af26ac2d913f4ac3/" rel="bookmark">
			Mysql被黑客入侵及安全措施总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		情况概述 今天登陆在腾讯云服务器上搭建的Mysql数据库，发现数据库被黑了，黑客提示十分明显。
Mysql中只剩下两个数据库，一个是information_schema，另一个是黑客创建的PLEASE_READ，其中有一张info表，内容如下：
Info: Your DB is Backed up at our servers, to restore send 0.2 BTC to the Bitcoin Address then send an email with your server ipBitcoin_Address: 1F33LEJjdphD6YpaonNCHejwLcgkgDGQW9Email: mysqldata@mail2tor.com 显然，我这是遇到比特币敲诈了。我的数据在别人的服务器里安然的躺着，需要向黑客支付0.2比特币才有可能恢复。按照当前的汇率，0.2比特币大约为1400人民币，这是我第一次遇到网络敲诈，金额还不小。
所幸数据库里并没有值钱的数据，就当是送给黑客了，不过 数据库安全问题 引起了我的注意。
安全措施 由于缺乏必要的安全措施和备份机制，数据库中原有的数据均已丢失。为了恢复到Mysql初始的状态，重新安装了Mysql数据库，并且重新创建原先存在的数据库，同时，为了防止再次被黑客入侵，对Mysql进行了一些安全配置。
禁用或限制远程访问。若允许远程访问，需要确保特定主机才拥有访问权。对用户进行合理授权，应用程序中最好不要直接使用root用户。限制打开网络socket，此时仍可以建立与Mysql服务器的本地连接。 [mysqld] skip-networking 强迫Mysql仅监听本机。 [mysqld] bind-address=127.0.0.1 更改root用户的登录名称和密码。移除测试数据库和匿名账户及废弃的账户。禁用LOCAL INFILE。 [mysqld] set-variable=local-infile=0 删除历史命令记录。 cat /dev/null &gt; ~/.bash_history cat /dev/null &gt; ~/.mysql_history 及时安装Mysql安全补丁。使用chroot限制Mysql运行环境。自动定期备份数据库。 用防火墙实现mysql绑定多个ip
my.cnf中有选项bind-address=127.0.0.1，是说mysql server监听的是本地发来的请求，如果是任意主机都可以请求，则写为0.0.0.0，但是这样又不太安全。监听某ip，指定此ip地址即可，但是要保证mysql的user中有允许此ip访问，否则不能对数据库操作。那么是否可以在配置里只规定几个ip呢？
简单直接回答：不可能
请参考：http://dev.mysql.com/doc/refman/5.1/en/server-options.html#option_mysqld_bind-address
The MySQL server listens on a single network socket for TCP/IP connections.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2cbca54008951f60af26ac2d913f4ac3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0cdb9fe57cd18b85a3e9d43053af98b/" rel="bookmark">
			34.	注入篇——Cookie注入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Cookie注入原理 （1）数据读取流程：对于WEB服务器而言，读取数据的流程是先取GET中的数据，如果GET中没有数据信息，那么再取POST中的数据，如果POST中也没有那么就会去取COOKIE中的数据
（2）防注入系统的常例：系统一般只会对GET、POST中的数据进行检测，如果有特殊的字符就禁止数据的提交，但是很少检测COOKIE中的数据信息。
（3）ASP中的request对象：Request对象被用于从用户那里获取信息。Request.[某一结果集的名称]（参数名称），比如获取表单中提交的数据：request.form("参数名称")，同时对于ASP而言，这里的结果集名称也可以省略，直接使用“request(参数名称)”，如果使用这样的方式，ASP规定按照QueryString、Form、Cookies、ServerVariables的顺序来获取数据。这样一来，如果我们使用request("参数名称")方式获取客户端提交的数据，并且没有对使用request.cookies("参数名称")方式提交的数据进行过滤时，Cookie注入就产生了。
Cookie注入步骤 （1）使用Baidu、Google等浏览器搜寻目标站点：
inurl:asp?id=（2） 去掉“?id=xx”查看页面显示是否正常，如果不正常，说明参数在数据传递中是直接起作用的。 （3）清空浏览器地址栏，输入“javascript:alert(document.cookie="id="+escape("xxxx"));”，按Enter键后弹出一个对话框，内容是“id=xxxx”，然后用原来的URL刷新页面，如果显示正常，说明应用使用Request("id")这种方式获取数据的。
（4）重复上面的步骤，将常规SQL注入中的判断语句带入上面的URL，例如：
“javascript:alert(document.cookie="id="+escape("xx and 1=1"));” “javascript:alert(document.cookie="id="+escape("xx and 1=2"));”
和常规SQL注入一样，如果分别返回正常和不正常页面，则说明该应用存在注入漏洞，并可以进行cookie注入。
（5）之后使用常规注入语句进行注入即可。
说明部分：
document.cookie="id="+escape("xxxx")的作用是把XXXX保存到COOKIE的ID中
Cookie注入中转 使用注入中转生成器来实现注入：
之后点击“生成ASP”就可以在程序的根目录下面生成一个用来中转的ASP文件！之后我们需要把该ASP文件上传到一个支持ASP的网络空间中去，之后进行访问！
此时，虽然你输入的地址不是之前存在COOKIE注入的网址，但是确实显示相同的界面。
但是，没有参数的页面是无法进行注入的，所以此时要将上面所显示的POST提交值添加到单前的URL后面（中间不可少“？”），之后就可以像普通的注入网站那样进行注入了，可以使用啊D、明小子等来注入
使用Sqlmap进行Cookie注入 在SQLmap中有一个参数“--Level”,当“leavel&gt;=2”时就会检测COOKIE后面的参数，当“level&gt;3”时将会检测User-Agent和Referer,这为COOKIE的注入提供了便利：
例如：
sqlmap -u http://xxx.xx.xx.xx:xx/test.php --cookie id=1 --dbs --leavel 2之后可以陆续的查询表、字段、字段值等内容。 Cookie注入防御 COOKIE注入的防御可以通过以下方法来解决：
（1）指明客户端数据提交方式，或者使用Request.QueryString("id")方式来获取通过GET方式提交的数据。
（2）修改防注入程序，增加对Request.Cookies("id")数据提交方式的过滤。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a85ca1cb3b7f9adfc6098d8a17f0da6/" rel="bookmark">
			排序算法 Java 实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 冒泡排序进阶之路 /** * 最简单的交换排序：每个数与之后的所有数比较 * @param arr */ public void simpleSort(int[] arr){ for (int i = 0; i &lt; arr.length; i++) { for (int j = i+1; j &lt; arr.length; j++) { if(arr[i] &gt; arr[j]){ swap(arr, i, j); } } } } /** * 正宗的冒泡排序：每次从最后开始找出最小的数放在最前面，最小的数像气泡一样慢慢浮出水面 * @param arr */ public void bubbleSort(int[] arr){ for (int i = 0; i &lt; arr.length; i++) { for (int j = arr.length-1; j &gt; i; j--) { if(arr[j] &lt; arr[j-1]){ swap(arr, j, j-1); } } } } /** * 进阶的冒泡排序：增加状态flag判断，若已经交换过则不再进行排序，这样已经排好序的序列就没必要做剩下几次的遍历 * @param arr */ public void bubbleSortAdvanced(int[] arr){ boolean flag = true; for (int i = 0; i &lt; arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a85ca1cb3b7f9adfc6098d8a17f0da6/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/289/">«</a>
	<span class="pagination__item pagination__item--current">290/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/291/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>