<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a039aef3deaff0b8440082e68338305a/" rel="bookmark">
			lvds屏线接口图解_液晶屏LVDS线类型图文讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明：
1、本资料是部分显示屏所使用的LVDS线汇总表，其中对LVDS接口插座、特征、编码等作了介绍。如果这些显示屏的LVDS线损坏，可参考；
2、由于1920X1080高清屏对应的数字板LVDS接口电路标准化较统一，可考虑通过更换LVDS线，对高清屏代用表中LVDS插座及排序不同的屏进行代用；
3、由于非1920X1080显示屏对应的数字板LVDS接口电路标准化不统一，如果代用屏的机芯与被代用屏的机芯相同，则可考虑通过更改LVDS线，对标清屏代用表中LVDS插座及排序不同的屏进行代用；如果代用屏的机芯与被代用屏的机芯不同，则不能通过更改LVDS线，对这些屏进行代用。
4、本资料可能会有不准确之处，供大家参考，并请大家指出错误之处，谢谢！
一、26寸以下（含26寸部分屏和三星2010年后32寸屏）
参数：
1366*768
60Hz
端子：FI-X30S1
特征：LVDS Pin 30，29，28供电 2、5组LVDS数据双绞线
材料：A46-BB40DL-SSXH1G400 该接口适用于26寸以下（含26寸部分屏、2010年后三星32寸HD屏）分辨率为HD（1366*768） 的屏
参数:
1440*900
60Hz
1680*1050
60Hz
1920*1080
60Hz
端子：FI-X30S
特征：1、LVDS Pin 30，29，28供电 2、10组LVDS数据双绞线
典型和材料号：46-AB250L-CM0C1G
长度：250
该接口适用于26寸以下（含26寸部分屏），除分辨率1366*768外的屏
二、26寸以上（含26寸部分屏）
参数：1366*768 60Hz
端子：FI-X30S
1、LVDS Pin1--4 供电 2、5组LVDS数据双绞线
46-AB45DL-LGXJ1G
长度：450
备注：该接口适用于26寸以上（含26寸部分屏）分辨率为HD即1366*768 的屏，主要使用于除三星屏外的其他厂家的屏，如LG,AUO,CMO,Sharp等，
参数：1366*768 60Hz
端子：FI-E30S
特征1、LVDS Pin28--30 供电
2、5组LVDS数据双绞线
材料：46-BB350B-SS5H1G
长度：350
备注：该接口适用于32寸以上分辨率（1366*768）三星旧型号屏，如三星32寸SS5；2010年后HD屏不再使用该接口
参数：1920*1080 60Hz
端子：FI-RE51
特征：1、LVDS Pin1--4 供电
材料: 46-FB40HL-SS9M1G
长度：400
备注：该接口适用于分辨率（1920*1080）三星屏,其他厂家panel 参考选用。
参数：1920*1080 60Hz
端子：FI-RE51
特征：1、LVDS Pin48--51 供电
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a039aef3deaff0b8440082e68338305a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0a65f543542f1e5ac4aa9400444c6af/" rel="bookmark">
			kill进程_还在使用kill -9 pid结束spring boot项目吗？不妨试试这几种优雅的方式！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
kill -9 pid ？？？kill -9 pid 带来的问题优雅结束服务 kill -15 pidConfigurableApplicationContext colseactuator数据备份操作 kill -9 pid ？？？ kill可将指定的信息送至程序。预设的信息为SIGTERM(15)，可将指定程序终止。若仍无法终止该程序，可使用SIGKILL(9)信息尝试强制删除程序。程序或工作的编号可利用ps指令或jobs指令查看（这段话来自菜鸟教程）。
讲的这个复杂，简单点来说就是用来杀死linux中的进程，啥？你问我啥是进程？请自行百度。
我相信很多人都用过kill -9 pid 这个命令，彻底杀死进程的意思，一般情况我们使用它没有上面问题，但是在我们项目中使用它就有可能存在致命的问题。
kill -9 pid 带来的问题 由于kill -9 属于暴力删除，所以会给程序带来比较严重的后果，那究竟会带来什么后果呢？
举个栗子：转账功能，再给两个账户进行加钱扣钱的时候突然断电了？这个时候会发生什么事情？对于InnoDB存储引擎来说，没有什么损失，因为它支持事务，但是对于MyISAM引擎来说那简直就是灾难，为什么？假如给A账户扣了钱，现在需要将B账户加钱，这个时候停电了，就会造成，A的钱被扣了，但是B没有拿到这笔钱，这在生产环境是绝对不允许的，kill -9 相当于突然断电的效果。
当然了，像转账这种，肯定不是使用MyISAM引擎，但是如今分布式火了起来，跨服务转账已经是很平常的事情，这种时候如果使用kill -9 去停止服务，那就不是你的事务能保证数据的准确性了，这个时候你可能会想到分布式事务，这个世界上没有绝对的安全系统或者架构，分布式事务也是一样，他也会存在问题，概率很小，如果一旦发生，损失有可能是无法弥补的，所以一定不能使用kill -9 去停止服务，因为你不知道他会造成什么后果。
在MyISAM引擎中表现的更明显，比如用户的信息由两张表维护，管理员修改用户信息的时候需要修改两张表，但由于你的kill -9 暴力结束项目，导致只修改成功了一张表，这也会导致数据的不一致性，这是小事，因为大不了再修改一次，但是金钱、合同这些重要的信息如果由于你的暴力删除导致错乱，我觉得可能比删库跑路还严重，至少删库还能恢复，你这个都不知道错在哪里。
那我们应该怎么结束项目呢？
其实java给我们提供了结束项目的功能，比如：tomcat可以使用shutdown.bat/shutdown.sh进行优雅结束。
什么叫优雅结束？
第一步：停止接收请求和内部线程。 第二步：判断是否有线程正在执行。 第三步：等待正在执行的线程执行完毕。 第四步：停止容器。 以上四步才是正常的结束流程，那springboot怎么正常结束服务呢？下面我介绍几种正常结束服务的方案，请拿好小本本做好笔记。
优雅结束服务 kill -15 pid 这种方式也会比较优雅的结束进程（项目），使用他的时候需要慎重，为什么呢？我们来看个例子
我写了一个普通的controller方法做测试
@GetMapping(value = "/test") public String test(){ log.info("test --- start"); try { Thread.sleep(100000); } catch (InterruptedException e) { e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0a65f543542f1e5ac4aa9400444c6af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/675f2b59921b470bbd3c6462e3d3a589/" rel="bookmark">
			curl: (7) Failed to connect to raw.github.com port 443: 拒绝连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在使用快捷命令安装oh-my-zsh时出现如题错误。
原因：你机器所配置的DNS服务器无法解析raw.github.com，也就是我们经常说的被墙了，可以通过科学上网解决。
本文附上另外一种解决方法，如果你不满足科学上网的条件，你可以采用这种方法。
通过站长工具解析出无法访问域名的IP地址
点此从新标签页打开站长工具
查询你需要的IP地址
选择一个IP地址，将其填写到我们本地的Hosts文件中
例：我这边选择 151.101.228.133
修改本地的Hosts文件
以Ubuntu 20.10 为例
vim /etc/hosts 在文件末尾新增一行如下
151.101.228.133 raw.github.com 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e334886eb34cf4ef426eef44d76f41be/" rel="bookmark">
			Ubuntu 20.04 开启SSH服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 更新软件下载源
sudo apt update 安装ssh服务
sudo apt install openssh-server 开启防火墙ssh的服务端口
sudo ufw allow ssh 附：还可以查看或更改ssh服务的状态
查看ssh服务状态
systemctl status ssh 关闭ssh服务
systemctl stop ssh 开启ssh服务
systemctl start ssh 重启ssh服务
systemctl restart ssh 设置开启自启
sudo systemctl enable ssh 关闭开机自启
sudo systemctl disable ssh 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b52da327549d34571787821980c9b974/" rel="bookmark">
			推荐系统深度学习篇-DCN网络介绍(2)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、DCN网络简介 DCN算法是2017年由斯坦福大学提出，其主要目的是，为了减少人工特征工程的繁琐工作，cross network能有效的学习bounded-degree的特征交互，且每一层都实现feature crossing，且参数量较dnn而言少近一个数量级。
论文地址为：https://link.zhihu.com/?target=https%3A//arxiv.org/pdf/1708.05123.pdf
其结构图为
这篇论文重点是提出了cross layer的概念，其核心思想是以有效的方式进行显示的特征交叉，结构图如下
二、代码展示 1、cross layer
#@tf.function def cross_layer(x0, xl): embed_dim = xl.shape[-1] w = tf.Variable(tf.random.truncated_normal(shape=(embed_dim,), stddev=0.01),trainable=True) b = tf.Variable(tf.zeros(shape=(embed_dim,)),trainable=True) # reshape操作相当于将列向量转换为行向量 xl_t = tf.reshape(xl, [-1, 1, embed_dim]) xl_w = tf.tensordot(xl_t, w, axes=1) cross = x0 * xl_w return cross + b + xl #@tf.function def build_cross_layer(x0, num_layer=3): """ 构建多层cross layer @param x0: 所有特征的embeddings @param num_layers: cross net的层数 """ # 初始化xl为x0 xl = x0 # 构建多层cross net for i in range(num_layer): xl = cross_layer(x0, xl) return xl Edited by ：Eshter
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b52da327549d34571787821980c9b974/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ee2bffd3ad1e4e73d068327b350245b/" rel="bookmark">
			ORACLE 碎片整理小结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		oracle碎片小结
我们在使用windows的时候，都知道要定期整理磁盘碎片，因为磁盘碎片会影响性能，给管理上带来额外的
负担。那oracle更是如此，当随着数据增加，oracle处理海量数据本身就已经很费力了啊，如果再有大量
的碎片，那就是雪上加霜啊。所以碎片要引起dba的高度重视，尽早发现尽早处理。
碎片是怎么产生的呢？
简单理解就是由于更新和删除产生一些碎小的不能被再次使用的空间，根据每种不同的碎片他们的产生也是有区别的
block-level的碎片，而block又分为data block和index block，在data block中存放的是row数据，在index block
中存放的是索引键值数据，所以按上面所说，block-level碎片有细分为row-level碎片和Index Leaf Block-level碎片。
oracle的每一个对象都是存储在segment中，而oracle的最小分配单位是extents（区），在数据更新删除中也会产生碎片
这一级别的碎片就是segment碎片。segment又存在datafile中，而tablespace又是包含datafile的逻辑概念。所以这一层
是tablespace-level碎片；tablespace是在disk上存储，所以这一层就是disk-level碎片。
简单图示如下
disk-level fragmention
tablespace-level fragmentation
segment-level fragmentation
block-level fragmentation
row-level fragmentation
index leaf block-level fragmentation
顺便提下oracle extents存在的理由
一个extents是由多个相连的block组成的，多个extents做成一个segment；extent是oracle的最小分配单位
extent的优点：
提高空间分配，释放的效率，降低管理block的资源成本提高扫描的效率，因为extent是由相连blocks做成的特性，可以一次读取更多的内容，较低io读写次数 extent的缺点
容易产生碎片
如何确定产生了碎片的呢？
一。表空间碎片确定参考
由于自由空间碎片是由几部分组成，如范围数量、最大范围尺寸等，我们可用 FSFI–Free Space Fragmentation Index
(自由空间碎片索引)值来直观体现：
FSFI=100*SQRT(max(extent)/sum(extents))*1/SQRT(SQRT(count(extents)))
可以看出，FSFI 的最大可能值为 100 (一个理想的单文件表空间)。随着范围的增加， FSFI 值缓慢下降，而随着最大范
围尺寸的减少，FSFI 值会迅速下降。通过如下语句查询FSFI：
select tablespace_name, sqrt(max(blocks) / sum(blocks)) * (100 / sqrt(sqrt(count(blocks)))) FSFI from dba_free_space group by tablespace_name order by 1; 在一个有着足够有效自由空间，且FSFI 值超过30的表空间中，很少会遇见有效自由空间的问题。当一个空间将要接近
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ee2bffd3ad1e4e73d068327b350245b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81619b0841057bcbbee871a4baada33a/" rel="bookmark">
			sqlplus 中的spool命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Spool常用的设置 set arraysize 5000; //此参数可提高SPOOL卸载的速度，最大可以设置为5000
set autotrace on; //设置允许对执行的sql进行分析
set colsep ',';　//域输出分隔符
set echo off;　//显示start启动的脚本中的每个sql命令，缺省为on
set feedback off;　//回显本次sql命令处理的记录条数，缺省为on，设置显示“已选择XX行”
set heading off;　//输出域标题，字段的名称，缺省为on
SET LINESIZE 2500; //每行允许的最大字符数，设置大些，免得数据被截断，但不宜过大，太大会大大降低导出的速度(注意必须与trimspool结合使用防止导出的文本有太多的尾部空格)
set newpage 1; //设置页与页之间的分隔{1|n|NONE};当值为0时在每页开头有一个小的黑方框;当值为n时在页和页之间隔着n个空行;当为none时，会在页和页之间没有任何间隔；
set newp none; //设置查询出来的数据分多少页显示，如果需要连续的数据，中间不要出现空行就把newp设置为none，这样输出的数据行都是连续的，中间没有空行之类的
set num 18; //设置数字的长度，如果不够大，则用科学记数法显示
set numwidth 12;　//输出number类型域长度，缺省为10
SET NULL text; //显示时,用text值代替NULL值
set pagesize 2000;　//输出每页行数，页面大小，缺省为24,为了避免分页，可设定为0
set serveroutput on; //设置允许显示输出类似dbms_output;--编写存储过程时,大多会将必要的信息输出；
SET SPACE 0;
set term off; //不在屏幕上输出执行结果
set termout off;　//显示脚本中的命令的执行结果，缺省为on
set timing on; //显示每个sql语句花费的执行时间，设置显示“已用时间：XXXX”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81619b0841057bcbbee871a4baada33a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37810c94e0ccd82774bb6a4a58059c20/" rel="bookmark">
			python canvas画弧度_编程作战丨如何利用python绘制可爱皮卡丘？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		好莱坞真人电影《精灵宝可梦：大侦探皮卡丘》预告片已经发布了，正片将于今年5月10日上映。
如果要做一个「童年梦想排行榜」的话，相信「拥有一只皮卡丘」这个梦想一定会名列前茅！
毕竟，谁不想揉揉这张可爱的小胖脸呢~
可爱的皮卡丘触动了少年时的那颗童心啊。于是突发奇想，利用python中的turtle画了一个皮卡丘的小胖脸，哈哈哈哈哈。
首先我们要好好观察皮卡丘面部的特点：
1、黄色的大脸；
2、一个鼻子；
3、两只黑眼睛；
4、眼白；
5、储存电力的两个红腮；
6、一个嘴巴；
那具体怎么利用python绘制出皮卡丘可爱的小胖脸呢？看下面动图
虽然看似很简单，但不仔细找好位置，嘴巴和鼻子随时都可能会画歪了。下面就说说绘制的思路和步骤吧。
1. 学员登陆智慧山上课网站，在python课程中找到一个练习；
2. 画皮卡丘的脸：
我们要设置一块画布；然后用黄色：’yellow’填充这个画布，填充好后就是我们皮卡丘的主调色了；
3. 画皮卡丘的鼻子：
我们首先把画笔设置画布中间的位置，然后设置鼻子为黑色，最后利用画圆的代码就画出黑色的鼻子了；
4. 两只黑色的眼睛：
这个很简单哦，只要画两个黑色的圆就可以了，两个圆的纵坐标是一样的，找好对称的位置就好了，同学们可以想一想；
5. 两个眼白：
这个和上面是很相似的，只是设置了白色，小朋友要自己多动手尝试哦。
6. 两个储存电力的红腮：
这个也很简单哦，想想上面的步骤；
7. 最后是皮卡丘的嘴：
这个稍微有点难度，首先定义嘴的位置，然后设置画笔的颜色，这一点要注意，当你改变画笔的颜色时，想要改变后面的颜色要提前设置好相对应的颜色。然后要利用t.circle()设置弧度，当你想要改变方向时也可以利用t.seth()改变角度，画出嘴巴的轮廓后，最后填充好颜色就可以了，记住画笔的宽度可以更改哦。
同学们，你们学会了吗？赶紧登陆亲自去试试吧。
智慧山：育儿先育己，陪孩子一起成长！
戳文末“了解更多”，免费领取小学生必备学习资源
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c433d77c942bdfad1d2409060801daf/" rel="bookmark">
			Ubuntu 系统查看、安装和开启 ssh 服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 查看 ssh 服务的开启状态 ps -e|grep ssh 如果终端返回结果中没有 sshd，则说明系统还没有安装 ssh-server 服务
安装 ssh 服务
sudo apt-get install openssh-server 启动 ssh 服务 sudo /etc/init.d/ssh start 确认 ssh 服务开启情况 ps -e|grep ssh 其他 ssh 配置，可以通过 vim 修改 ssh 的配置文件 sudo vim /etc/ssh/sshd_config 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae563e59b99d01a909405de587489619/" rel="bookmark">
			Centos8安装docker-ce的时候errordman-1.6.4-10.module_el8.2.0&#43;305&#43;5e198a41.x86_64 requires runc ＞= 1.0.0-57
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Centos8环境安装docker的时候报错：
Error: Problem: problem with installed package podman-1.6.4-10.module_el8.2.0+305+5e198a41.x86_64 - package podman-1.6.4-10.module_el8.2.0+305+5e198a41.x86_64 requires runc &gt;= 1.0.0-57, but none of the providers can be installed - package containerd.io-1.3.7-3.1.el8.x86_64 conflicts with runc provided by runc-1.0.0-65.rc10.module_el8.2.0+305+5e198a41.x86_64 - package containerd.io-1.3.7-3.1.el8.x86_64 obsoletes runc provided by runc-1.0.0-65.rc10.module_el8.2.0+305+5e198a41.x86_64 - package docker-ce-3:19.03.13-3.el8.x86_64 requires containerd.io &gt;= 1.2.2-3, but none of the providers can be installed - conflicting requests - package runc-1.0.0-64.rc10.module_el8.2.0+304+65a3c2ac.x86_64 is filtered out by modular filtering (try to add '--allowerasing' to command line to replace conflicting packages or '--skip-broken' to skip uninstallable packages) 这个问题搜了两个发现 low code，于是就进入了stackoverflow，于是就解决了！！！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae563e59b99d01a909405de587489619/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/967663f7ec6f6794a6be3d3c3cfb9b8b/" rel="bookmark">
			LVDS接口分类与数据格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转发路径：https://blog.csdn.net/a617996505/article/details/82386952
1.LVDS接口分类与数据格式
单路6it LVDS
这种接口电路中，采用单路方式传输，每个基色信号采用6位数据，共18位RGB数据，因此，也称18位或18bit LVDS接口。此，也称18位或18bit LVDS接口。 双路6bit LVDS
这种接口电路中，采用双路方式传输，每个基色信号采用6位数据，其中奇路数据为18位，偶路数据为18位，共36位RGB数据，因此，也称36位或36bit LVDS接口。
单路8bit LVDS
这种接口电路中，采用单路方式传输，每个基色信号采用8位数据，共24位RGB数据，因此，也称24位或24bit LVDS接口。
双路8bit LVDS
这种接口电路中，采用双路方式传输，每个基色信号采用8位数据，其中奇路数据为24位，偶路数据为24位，共48位RGB数据，因此，也称48位或48bit LVDS接口
现在市场上基本是8bit和6bit的屏幕，
LVDS接口电路中，将像素的并行数据转换为串行数据的格式主要有两种标准：VESA和JEIDA
1）VSEA标准格式如下图所示：
以上图片是单路的VESA标准信号，对一行数据输入则多2bit。
关于双路的信号格式这个可以举个例子：
以上图片是双路8bit 的VSEA标准信号。
2)JEIDA标准是由日本电子行业开发协会(JAPANELECTRONIC INDUSTRY DEVELOPMENT ASSOCIATION)制定的标准，其格式如下:
可以对比参照查看，如果像素为6bit RGB，则每个通道只需要最上面的3对数据线，其中的R9…R4, G9…G4, B9…B4 对应实际的R5…R0, G5…G0, B5…B0；同样，如果像素是 8 bit RGB,则每个通道只需要靠上面的4对数据线，其中的R9…R2, G9…G2, B9…B2 对应实际的R7…R0, G7…G0, B7…B0。
基本上每个屏幕的datesheet上都有相关信号图。
由这些信号图基本上可以判断： 1.单双路； 2.是多少bit RGB； 3.数据信号格式；
查看IMX6Q_LDB Control Register，内有相关设置：
1.单双路； 2.是多少bit RGB； 3.数据信号格式；
有设备树的内核可以直接修改设备树来操作寄存器，红色部分即可修改的三个参数:
&amp;ldb { status = "okay";
dual-mode = &lt;1&gt;; //这里为单路LVDS，双路应设为 split-mode = &lt;1&gt;;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/967663f7ec6f6794a6be3d3c3cfb9b8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bda2bd785197454536833a9c4b9fba73/" rel="bookmark">
			【uniapp】uniapp之websocket心跳重连机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;script&gt; export default { data() { return { timeout: 30000, // 30s timeoutObj: null }; }, onLoad() { // .判断是否已连接 this.checkOpenSocket(); }, methods: { // 判断是否已连接 checkOpenSocket() { uni.sendSocketMessage({ data: 'ping', success: res =&gt; { return; }, fail: err =&gt; { // 未连接打开websocket连接 this.openConnection(); } }); }, openConnection() { // 打开连接 // uni.closeSocket(); // 确保已经关闭后再重新打开 uni.connectSocket({ url: 'ws:........', success(res) { console.log('连接成功 connectSocket=', res); }, fail(err) { console.log('连接失败 connectSocket=', err); } }); uni.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bda2bd785197454536833a9c4b9fba73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bb22b5c6d22de77619eff8206e6683e/" rel="bookmark">
			js防抖、节流（立即执行/非立即执行 &#43; 立即取消等待）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、防抖（立即执行/非立即执行 + 立即取消等待）1.1 非立即执行版1.2 立即执行版1.3 合并版1.4 合并版 + 立即取消等待 二、节流（立即执行/非立即执行 + 立即取消等待）2.1 非立即执行版2.2 立即执行版2.3 合并版2.4 合并版 + 立即取消等待 一、防抖（立即执行/非立即执行 + 立即取消等待） 什么是防抖：一个事件在触发后，设置定时器，若n秒内该事件没有再次发生，那么执行这个函数，如果n秒内该事件再次发生了，那么定时器重新开始计时。 应用 每次 resize / scroll 触发统计事件文本输入的验证 （连续输入文字后发送AJAX请求进行验证，验证一次就好） 1.1 非立即执行版 //防抖(非立即执行) function debounce_1(fn,wait){ let timerId = null; return function(){ clearTimeout(timerId); timerId = setTimeout(() =&gt; { fn.apply(this,arguments) },wait) } } 1.2 立即执行版 //防抖(立即执行) function debounce_2(fn,wait){ let timerId = null; let flag = true; return function(){ clearTimeout(timerId); if(flag){ fn.apply(this,arguments); flag = false } timerId = setTimeout(() =&gt; { flag = true},wait) } } 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7bb22b5c6d22de77619eff8206e6683e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b073ab84c4b3d361703c2cb2a8f420d/" rel="bookmark">
			type-c接口是什么意思_科普时间：雷电3接口什么意思？和Type C接口有什么区别？...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		科普时间：雷电3接口什么意思？和Type C接口有什么区别？ 现在的部分笔记本电脑上，用上了一种“新”的接口，叫做“雷电3”，但其实你仔细看的话，这不就是USB-Type C接口吗？为什么叫做雷电3接口呢？USB Type C接口和雷电3接口一样吗？现在我就给大家一步一步的介绍一下它俩到底有什么区别？为什么很多笔记本电脑都用雷电3接口！
USB Type C是接口类型，而USB 3.1是接口协议，这个大家要分清楚，虽然Type C和USB 3.1协议是一同推出的，但是这两者不一定相互包含，简单来说，就是Type C接口不一定支持USB 3.1协议，而使用USB 3.1标准的接口也不一定要是USB Type C接口，也可以是Type A。
USB Type C是USB接口的其中一种接口类型(外形)，还有其他好几种大家应该都清楚，Type C的优点在于正反两面都一样，可以随便插，并且体积小，最高可达到10Gbps的传输速度，同时还能承载100W电力传输，当然视频传输也可以，反正就是很强大，以后USB接口也是Type C的天下，不过现在普及程度还不高。
其实很多笔记本电脑都开始使用雷电3接口了，有的电脑已经成了标配，但是很多小伙伴不知道，在笔记本上有这么一个接口既可以传数据，又可以外接显示器，甚至还可以给笔记本充电，它就是雷电3接口，下面就带大家了解一下。
雷电接口是由Intel开发制定的，苹果有参与，接口为mini DP，此前因为雷电仅苹果设备上使用，再加上会用雷电mini DP接口的外设的价格都非常高，所以推广难度很大，直到Intel看见USB Type C逐渐普及之后，就宣布将雷电3的原接口mini DP改为USB Type C。
雷电(Thunderbolt)是一种扩展接口，最初由英特尔研发，目的是作为PC与其他设备之间的连接总线。雷电接口已经迭代了三个版本，最新的接口是雷电3。
目前有很多笔记本都配备了雷电3接口，比如MacBook Air/Pro、新款华为MateBook X Pro、ThinkPad X1 Carbon 2018、LG gram系列等等。
雷电3接口标志
雷电3接口在外观上和USB Type-C无异，支持正反插，非常方便，雷电3接口一般都会在旁边标注一个闪电的标志，以此来突显身份。 雷电3接口最突出的特点就是可以一口多用、化繁为简，它主要有以下三个功能：
1、传输数据
雷电3接口可以像USB接口一样传输数据，其带宽高达40Gb/s，是USB 3.0(5Gb/s)的8倍，USB 3.1(10Gb/s)的4倍。雷电3也是目前传输速度最快的USB接口。
2、外接显示器
雷电3可以作为视频输出接口外接显示器，它可以连接两个4K分辨率/60Hz的显示器或者一个5K分辨率/60Hz的显示器。加上笔记本本身的屏幕，用户最多可以享受到3块显示器带来的震撼体验。
3、充电
雷电接口是由Intel开发制定的，苹果有参与，接口为mini DP，此前因为雷电仅苹果设备上使用，再加上会用雷电mini DP接口的外设的价格都非常高，所以推广难度很大，直到Intel看见USB Type C逐渐普及之后，就宣布将雷电3的原接口mini DP改为USB Type C。
所以，一个雷电3接口就可以搞定传输数据、外接显示器、双向充电等功能，它将为我们使用笔记本带来很大的方便
因此，USB Type C只是雷电3的依附接口类型，外形看起来一样，但是雷电3可以实现Type C的绝大多数功能，并且传输效率更高，而为了区分雷电3接口，该接口会在附近使用一个“闪电”标志。
因此，现在的雷电3接口，可以看成是原有的雷电3抛弃mini DP接口改用USB Type C接口后，再配合USB 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b073ab84c4b3d361703c2cb2a8f420d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1aae544e326cd58bc516d84f89989162/" rel="bookmark">
			雷电三接口有什么用_支持正反插拔的雷电接口，还有什么让人无法拒绝的特性呢...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ThunderBolt 3 也就是雷电3接口
在诸多 ThinkPad 2018款新品上也已见到
如 X1 Carbon 2018
T480 / T580等
除了支持正反插拔外
雷电接口拥有非常强大的扩展性能
可以称之为“万能接口”
所以
今天跟随小微一起再来回顾一下这款接口吧！
什么是雷电接口？
Thunderbolt(雷电) 连接技术融合了PCIExpress数据传输技术和DisplayPort显示技术，可以同时对数据和视频信号进行传输。雷电接口自2011年推出至今已经经过6年的发展，接口标准也从最开始的雷电1接口更新到今天的雷电3接口。
雷电3接口，基于USB Type-C接口开发，理论传输速度高达40Gb/s，是目前最快USB协议的四倍！
更强大的 Type-C 接口
雷电3接口，外观上和普通的Type-C长得一样，雷电接口会在接口旁边有一个“雷电”的标识以示区分。
雷电3接口正是利用了USB Type-C不分正反随便插拔的特性，在此基础上，才有了如今的雷电3接口。
纵观雷电接口的发展史，每一代雷电接口在接口额物理形态上并没有别出心裁出花样(前代接口采用mini DP)，而是把功夫都下在了内在速度方面。而消费者得到的好处就是不需要额外配备转接头就可以享受更好的使用体验。
雷电3接口能干啥？
和其他众多接口相比，雷电3似乎生来就是富二代，40Gb/s的速度也让其他接口望尘莫及，当然除了参数之外，雷电3还可以这么玩。
最高8K视频输出
雷电3中采用最新的DisplayPort1.3。DisplayPort1.3的速度在1.2的基础上也提升了一倍，将DisplayPort的等效信道从4变成了8，本质上则是让一个雷电3线缆携带两个DisplayPort1.2连接。
最终的结果是雷电3将能够驱动DisplayPort1.3的显示设备——比如8K显示器和5K单片显示器；当然，雷电3也能轻松驱动DisplayPort1.2所能驱动的一切，包括4K 60Hz显示器或5K多片显示屏。
显卡也可以热插拔
雷电理论上总是能够支持外接显卡(本质上就是PCIe总线)，对于设计师亦或者游戏玩家，简直是福音。
外接显卡的实现意味着，设计师下班回家需要工作的时候只需要带一台支持雷电3的笔记本，然后在家备一块高性能外置显卡，而不必因为回家耽误灵感。
对于游戏玩家来说，过节回家而又不想扛着沉重的台式机的时候，只需要带上一台支持雷电3的笔记本，然后从主机上拔下显卡，打包带回家就可以一边与家人团聚，而又不会耽误游戏排名。
相比外接显卡，雷电3最大的亮点应该对GPU热插拔和所谓“意外断开”的情况的支持。试想一下未来的外接显卡设备就像随身携带的U盘一样，支持随时插拔这样一来也许显卡也会成为笔记本的“模块”
万兆以太网连接
多台支持雷电3的设备，通过模拟一个万兆以太网连接而实现雷电网络，两台计算机通过雷电线缆进行连接，或者在高端工作站和服务器中实现外部几乎不可见的万兆以太网连接，这将是一个比千兆以太网络更为实用的解决方案。
多台设备串联
凭借超高的带宽，雷电3接口支持多设备串联，以前如果你需要外接4连屏，那么对于显卡可能需要有四个视频输出接口，而借助雷电3，你只需要一个接口便可实现四屏输出(显示器需要支持串联)。
看完这些，雷电3接口的强大功能，是不是心动了呢？不过这在之前你首先需要一台支持雷电3的设备！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c36c3019865a6ecce9e6e72cebbacad/" rel="bookmark">
			雷电三接口有什么用_笔记本的Type-C接口有哪几种？为什么都说雷电3接口更好用？...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Type-C接口就是我们现在手机都在用的接口，具备快充、正反面充电等多种优点。其实，除了在手机中，很多笔记本都采用了这种接口。而不一样的笔记本所搭载的Type-C接口也不相同，主要分为三种类型。
​
第一种：低价位笔记本 这种笔记本虽然使用的是Type-C接口，但是其作用，就相当于一个普通的USB接口，其功能，只能用于数据传输。
​
第二种：中端笔记本 稍微好一些的笔记本会用全功能的Type-C接口，其用途也会比低价位的笔记本接口要多的多。除了充电、数据传输的基础性功能，还可以进行视频输出，也就是可以外接屏幕，进行投屏使用。
​
第三种：高端笔记本 如果你买的是一台高端型笔记本，那么，它搭载的就是雷电3Type-C接口。不仅可以做到4k、5k的视频输入，6k也是可以的。而且这种接口还可以支持菊花链，用一个Type-C接口就可以串联出好几个屏幕。这种接口还可以用来外接显卡，增强游戏性能。
​
上面关于笔记本的Type-C接口分类介绍就到这里结束了，如果买笔记本对接口的功能有这样的特殊要求，哪一定要要搞清楚它搭载的是那种Type-C接口了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e77182741463be2f26ca5d59779ccbc/" rel="bookmark">
			CORS（跨域资源共享） 的 tomcat 配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 再tomcat下web.xml中加入一下
&lt;filter&gt; &lt;filter-name&gt;CORS&lt;/filter-name&gt; &lt;filter-class&gt;com.thetransactioncompany.cors.CORSFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;cors.allowOrigin&lt;/param-name&gt; &lt;param-value&gt;*&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;cors.supportedMethods&lt;/param-name&gt; &lt;param-value&gt;GET, POST, HEAD, PUT, DELETE&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;cors.supportedHeaders&lt;/param-name&gt; &lt;param-value&gt;Accept, Origin, X-Requested-With, Content-Type, Last-Modified&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;cors.exposedHeaders&lt;/param-name&gt; &lt;param-value&gt;Set-Cookie&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;cors.supportsCredentials&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CORS&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 将 java-property-utils-1.9.jar 和 cors-filter-1.7.1.jar 两个jar包放入tomcat下的lib中
可以从 http://search.maven.org 上搜索下载
也可以从 : https://pan.baidu.com/s/1XynaO3poOTWCo9Zt0bOpBA 提取码: b2ps 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccd0a82a0e06e809ef914b7dca64be59/" rel="bookmark">
			OJ6-3 C. radix sort
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C. radix sort
题目描述
radix sort
Given a sequence of numbers seperated by comma, you should sort them by radix sort.Output the step result of each pass
input
2 line
the first line is a sequence of numbers(&lt;20) seperated by comma;the second is the step pass number(&lt;5).
output
1 line
the sequence of the pass seperated by comma
#include &lt;stdio.h&gt; void sort(int a[], int n, int exp); int main() { int x = 0; char y; int a[20]; int top = -1; while ((y = getchar()) !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccd0a82a0e06e809ef914b7dca64be59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/431105c9e48dcf43846055ea71b51ba0/" rel="bookmark">
			使用Python读取串口数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python读取串口数据 使用Python读取串口数据1.编程流程2.应用serial库3.编码设计4.编程实现 使用Python读取串口数据 1.编程流程 串口数据流程为，
1.实例化串口连接，
2.初始化设置连接属性，
3.连接串口硬件，
4.读取传输缓存区的串口数据。
使用Python的serial库进行读写串口数据。
pip3 install serial 技巧：重复运行上述pip指令，可输出当前serial依赖库的存放位置。
参考教程：https://www.jb51.net/article/170801.htm.
2.应用serial库 分析1中功能流程，进行如下汇总：
串口连接配置1：实例化串口连接串口连接配置2：配置串口参数，并连接串口串口连接配置3：读取串口数据加上功能：核验接收数据 3.编码设计 将上面的功能，进行如下进行设计：
串口参数配置设为变量，初始化串口连接时进行调用读取串口数据，写入文件判断：串口数据数据格式，每包数据长度 4.编程实现 编写函数,实现读取串口操作 def msg_list(): # 新建一个列表，返回该串口数据，做后续数据处理使用 msg_list = list() # 准备一个文件，保存数据 r = r'E:\py\0.txt' write_file = open(r, 'wb') # 配置串口名称、比特率、超时时间 port = 'COM3' bps = 1152000 timex = 1 # 连接串口 ser = serial.Serial(port, bps, timeout=timex) print(ser) # 等下时间，去启动串口发送程序。不然，程序会直接进入判断串口数据直接结束 time.sleep(3) # 进入读写过程 while True: # 判断当前写入区有没有串口数据 if ser.in_waiting: # 读数据 msg = ser.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/431105c9e48dcf43846055ea71b51ba0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7acb8f42ccdb1d899a6345da401b3b6e/" rel="bookmark">
			Selecting Windows SDK version 10.0.19041.0 to target Windows 10.0.17763.  缺失丢失
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cmake的时候缺少
Selecting Windows SDK version 10.0.19041.0 to target Windows 10.0.17763.
The C compiler identification is MSVC 19.28.29333.0
The CXX compiler identification is MSVC 19.28.29333.0
Detecting C compiler ABI info
控制面板，卸载 掉其他的， 只留这一个。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a38d6d8939d78fa17c5027c31d937d6f/" rel="bookmark">
			rabbitmq消费者“无故消失”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导读：9月1号17:12左右，发现影子队列存在大量“unacked”（收到了消息，但是还没有手动确认消息）的消息，一段时间后“unacked”的数量没有减少，但是观察消费者端的日志，并没有新消息进来，
原因竟是。。。
关键词：rabbitmq，Tcp Window full
问题背景：
9月1号17:12左右，收到实施人员投诉，有部分设备不能正常升级、收不到控制台下发的指令等问题，同事查看control工程（后面简称control）那边的日志，发现control没有收到设备上报的影子信息，所以没有下发指令。control工程直接对接设备，根据设备上报的信息对设备下发一些指令及配置信息，包扣升级、上报日志等，IoT上线之前control依赖心跳上报来获取设备的当前信息，IoT上线之后依赖设备影子信息
来获取设备的当前信息，control会订阅设备的影子信息，但影子信息是由影子服务（简称IoT）转发过去的，它不直接对接设备影子上报，具体流转细节，请看这下面两个图：
应用程序（control）获取设备状态
应用程序（control）下发设备指令
得知control收不到影子消息以后，我立马去rabbitmq的控制台查看是否有消息，确定两个事：1.设备是否上报了消息 2.rabbitmq是否正常，下面图1、图2是当时截取的rabbitmq控制台的两个图，从图1可以很清楚的确定设备是有消息上报的，但是有很多消息是unacked（说明已经投递给了消费者，只是消费者没有ack而已，理论上等待一段时间就能正常）的，具体是哪个队列堆积unacked的消息请看图2，“spacebridgeiot-shadow”正是我们用来接收设备上报的影子信息的，消息都被堆积到队列了所以没有转发到control也是合理的，观察了一段时间发现unacked的数量变成了0，但是total的总数确没有太大变化，给人的感觉像是unacked的消息重新回到了消息队列里等待投递，果然过了几分钟以后又发现有大量unacked的消息，过了几分钟以后这部分unacked的消息重新回到队列里，control那边依然没有收到消息，这时查看IoT那边的日志发现竟然没有影子消息进来，在rabbitmq的控制台查看“spacebridgeiot-shadow”这个队列下居然没有消费者了，如图3所示。这时查看rabbitmq的日志确实有错误信息，如图4所示，rabbitmq主动关闭了连接。
图1：rabbitmq概览图
图2：rabbitmq队列统计图
图3：spacebridgeiot-shadow 概览
图4：rabbitmq报错信息
临时解决方案：
由于当时已经有大量投诉过来了，所以采用了比较暴力的解决办法“将堆积的消息删除”，删除以后果然正常了（备注：线上问题必须尽快解决，没有时间允许我们去分析日志然后有条不紊的解决，必须快）。
通过线下环境复现问题：
1.往10.200.41.166环境的rabbitmq的队列“mirrorTestQueue”堆积大量消息（起码万级）
2.停掉mirrorTestQueue的消费者，待堆积完成以后重新启动
3.堆积完成，重新启动消费者
和我们设想的一样，几秒内有几千条消息推给了消费者，持续几分钟以后rabbitmq主动关闭了和消费者之间的连接，这时从控制台看不到队列的消费者。由于我们的消费者设置了自动恢复，所以过一阵又会自动连上，
但很快又会被断连，和我们线上遇到的问题基本一样，究竟是什么导致了这个问题呢？说实话当时没有什么思路，网上找了一圈也没找到什么特别满意的答案（当时没有抓到问题的本质，搜的关键词太泛了），后来
我们猜测可能是TCP层面出了什么问题，所以决定抓包试试能不能找到什么端倪。果然，幸运的事情发生了，话不多说，直接上图。
13:06:25.643428之前rabbitmq还一直在给消费者推消息，直到13:06:25.643428这个时间点，开始出现消费者tcp窗口被打满的情况，大概持续了30秒左右，rabbitmq主动断开了连接（发了一个rst包），之后消费者重连，然后窗口又继续被打满，又持续30秒左右继续被断连。
感觉还挺有规律，每次持续30s，感觉是可配置的一个参数，大概总结一下就是“tcp full window导致了服务端主动rst连接，而且还有规律”
这次换了一下搜索的关键词找到了答案，rabbitmq有一个参数叫tcp_listen_options.send_timeout 是来控制写超时的一个参数，当写超时了以后就会触发tcp的RST(https://github.com/rabbitmq/rabbitmq-java-client/issues/341)，修改一下试试效果如何：
1. 将写超时时间改成10s
tcp_listen_options.send_timeout = 10000
2.抓包看看是否起作用
从窗口满到关闭连接持续10s左右。
现象复盘：
由于rabbitmq的消费端没有设置prefetch所以rabbitmq一次性给消费端投递了过多的消息，从而导致消费端的 tcp 窗口被占满，进而触发了rabbitmq 的tcp_listen_options.send_timeout，这个写超时达到一个阈值后会触发rabbitmq断开消费者的tcp 连接。
终极解决方案：
之前删除消息只是迫不得已的方案，虽然解决了问题但太暴力，我们需要找到一个优雅的方案来应对，既然是推给消费者的消息太多造成了tcp窗口被打满，那我们就应该在接收速率上下点功夫，在连接rabbitmq的时候告诉它别给我发太多就行。（后面这段话摘自https://blog.csdn.net/james_searcher/article/details/70308565）rabbitmq有一个属性叫prefetch，prefetch是指单一消费者最多能消费的unacked messages数目。如何理解呢？mq为每一个 consumer设置一个缓冲区，大小就是prefetch。每次收到一条消息，MQ会把消息推送到缓存区中，然后再推送给客户端。当收到一个ack消息时(consumer 发出baseack指令)，mq会从缓冲区中空出一个位置，然后加入新的消息。但是这时候如果缓冲区是满的，MQ将进入堵塞状态。更具体点描述，假设prefetch值设为10，共有两个consumer。也就是说每个consumer每次会从queue中预抓取 10 条消息到本地缓存着等待消费。同时该channel的unacked数变为20。而Rabbit投递的顺序是，先为consumer1投递满10个message，再往consumer2投递10个message。如果这时有新message需要投递，先判断channel的unacked数是否等于20，如果是则不会将消息投递到consumer中，message继续呆在queue中。之后其中consumer对一条消息进行ack，unacked此时等于19，Rabbit就判断哪个consumer的unacked少于10，就投递到哪个consumer中。
具体到代码里就是
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/193610ab5166e2535a239d3032b5fb43/" rel="bookmark">
			win10虚拟内存怎么设置最好_win10系统电脑增加虚拟内存设置教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小编给大家浅析win10系统电脑增加虚拟内存设置教程，使用电脑过程中，有时会遇到需要增加虚拟内存解决电脑内存配置不高的问题，不知如何设置的用户，可参照以下的方法进行操作。
尽管现在的电脑很发展，配置很好，但是使用旧式的电脑的用户还是有很多的，而且普遍的配置都不高，内存也少的可怜，如果我们的电脑配置内存在2GB以下，那么这个时候就需要我们进行修改虚拟内存了，以便更好地释放电脑的压力，不知如何增加虚拟内存的用户，下面就让小编教你win10系统电脑增加虚拟内存设置教程吧。
增加虚拟内存：
首先点击开始菜单按钮，把鼠标指向“我的计算机”。然后点击鼠标右键，在弹出来的菜单中选择“属性”
在系统信息窗口中，点击左边的“高级系统设置”
接下来在系统属性窗口中，选中“高级”选项卡，点击性能下面的“设置”按钮
在性能属性窗口中选中“高级”选项卡，然后点击下面的“更改”按钮
接下来，就可以对虚拟内存的大小进行设置了。先取消“自动管理所有驱动器分页文件大小”前面的小勾，然后再选中“自定义大小”
在设置虚拟内存大小的时候，不是越大越好。应该根据我们的实际物理内存来设置，一般是物理实际内存的1.5倍左右。比如我的电脑内存是 2G 的，建议设置虚拟内存的大小在 2048M到4096M，输入完成以后，点击“设置”按钮
注：1G=1024M 设置完成以后，我们就可以看到在 C 盘的虚拟内存大小已经更改为我们设置的大小了。然后点击下方的“确定”按钮
注：我们也可以把虚拟内存分页文件设置在其它盘，比如 D，E盘等，建议设置在 C 盘。 接下来系统会提示我们需要重新启动计算机才能使更改生效，再次点击“确定”按钮
最后一路点击“确定”按钮，系统会再次提醒我们“必须立即启动才能生效”。根据自己的需要选择“立即重启或稍后重启”
以上就是win10系统电脑增加虚拟内存设置教程介绍了!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a0a659f6fbd5fa3e03ec4ce29bb3bad/" rel="bookmark">
			win10设置虚拟内存_win10增加虚拟内存的方法教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虚拟内存是计算机系统内存管理的一种技术。如果虚拟内存设置的太小，可能会影响软件和操作系统的正常使用。这时候您就需要增加虚拟内存了。那怎样增加虚拟内存呢?今天小编就来跟大家说说增加虚拟内存的方法，一起来看看吧。
win10增加虚拟内存的方法
1.进入win10系统桌面，鼠标右键“我的电脑”，选择“属性”打开。
2.在新出现的界面中选择“高级系统设置”打开。
3.在弹出的界面中点击“高级”，在性能的右下边，选择“设置”打开。
4.在“性能选项”界面中切换到“高级”，选择“更改”打开。
5.将虚拟内存界面中的勾去除，选择“自定义”，托管的系统选择C盘。
6.设置虚拟内存建议最多不超过实际内存的2倍，设置完毕后点击确定，重启系统即可应用设置。
相关设置说明：
虚拟内存设置大小一般应该为物理内存的1.5倍为好，
如果物理内存为2G，虚拟内存应该设置为3G=3072MB，
如果物理内存为4G，那虚拟内存应该设置为6G=6144MB，
我的物理内存为1G，那虚拟内存应该设置为1.5G=1536MB，
注：1G=1024MB
以上就是怎样增加虚拟内存 win10增加虚拟内存的方法教程的全部内容了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a07e654fc811e779fde44dfef52f7978/" rel="bookmark">
			lua中的闭包(closure或者匿名函数)的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		闭包和upvalue lua构建一个新的函数时, 会创建一个函数对象, 其中包含了函数本身的原型还有函数使用到的外部变量或者常量. 当这个新的函数处于某个函数内部, 我们将这个对象称之为闭包, 它所引用的外部函数的局部变量叫做upvalue.
下面是一个例子:
function f1(n) local upvalue = "hello" local f2 = function() print(upvalue .. " " .. n) end return f2 end g1 = f1(500) g1() print(g1) g2 = f1(1500) g2() print(g2) $ luajit copy.lua $ hello 500 $ function: 0x00921ae0 $ hello 1500 $ function: 0x00926f28 每次调用f1将生成一个以f2为函数原型, 加上两个upvalue值(n, upvalue)的新函数(闭包). 每个新的闭包保持同一函数原型, 分别保存不同的upvalue. 严格来说, 闭包属于动态的概念, 是在程序运行阶段确定的.
upvalue值的作用域 upvalue实际上是闭包的外部函数的局部变量, 存在于外部函数的堆栈中, 在外部函数的执行过程中, 闭包通过访问外部函数堆栈的upvalue引用来访问upvalue, 一旦外部函数的调用过程完毕, 函数的堆栈被清空, upvalue也会被清除, 此时闭包会将upvalue复制到自己的函数堆栈中以便使用.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a07e654fc811e779fde44dfef52f7978/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecbd632bd1fb90017cb8b0489489f31b/" rel="bookmark">
			win10安全模式都进不去_Win10系统电脑开机按F8无法进入安全模式的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Win10系统开机按F8不能进安全模式怎么办？最近有用户反映，Win10系统开机按F8一直进不了安全模式，这是怎么回事？Win10系统该如何进入安全模式呢？下面给大家介绍具体操作。
操作方法： 1、使用win+r，直接打开“运行”窗口，并输入“msconfig”，回车。
2、进入界面中，直接点击“引导”选项，并勾选安全引导，点击确定。
3、这个时候系统会有“提示”窗口，并点击重新启动。
4、完成重新启动后，系统就会自动进入安全模式了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18504cdbfcb4a94fbb8440dd309bb160/" rel="bookmark">
			产品运行所需的信息检索失败_域名解析失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电脑是属于电子产品，而网络则是属于虚拟的，我们看不着摸不着，如果网络出现问题的话，或许是硬件问题，也可能是设置问题。那么，域名解析失败怎么办？下面将会为大家介绍。
域名解析失败
1、如果遇到域名解析错误的情况，可以按下【Win】+【R】组合键调出【运行】；
2、在运行的文本框中输入【cmd】，然后点击【确定】；
3、在打开的命令行中，输入ipconfig/flushdns；然后点击回车键就可以清空DNS的缓存就可以正常上网了；
4、如果以上的方式不能解决，也可以点击打开【网络和共享中心】，点击打开【更改适配器设置】；
5、右键点击【以太网】打开【属性】；点击打开【IPv4】，选择【使用下面的DNS服务器地址】，通过手动设置的方式设置DNS地址；各地的宽带运营商的实际DNS服务器地址不一样；
以上就是关于域名解析失败的解答，希望可以帮助到大家。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2068839c92504b7ca05481deee30f29/" rel="bookmark">
			为什么单例模式可以支持多线程并发访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么spring单例模式可以支持多线程并发访问？
1、spring单例模式是指，在内存中只实例化一个类的对象
2、类的变量有线程安全的问题，就是有get和set方法的类成员属性。执行单例对象的方法不会有线程安全的问题
因为方法是磁盘上的一段代码，每个线程在执行这段代码的时候，会自己去内存申请临时变量
为什么局部变量不会受多线程影响？
1、对于那些会以多线程运行的单例类，例如Web应用中的Servlet，每个方法中对局部变量的操作都是在线程自己独立的内存区域内完成的，所以是线程安全的
2、局部变量不会受多线程影响
3、成员变量会受到多线程影响
4、对于成员变量的操作，可以使用ThreadLocal来保证线程安全
JVM是如何实现线程的独立内存空间？
Java中的栈
1、每当启用一个线程时，JVM就为他分配一个Java栈，栈是以帧为单位保存当前线程的运行状态。某个线程正在执行的方法称为当前方法，当前方法使用的栈帧称为当前帧，当前方法所属的类称为当前类，当前类的常量池称为当前常量池。当线程执行一个方法时，它会跟踪当前常量池。
2、每当线程调用一个Java方法时，JVM就会在该线程对应的栈中压入一个帧，这个帧自然就成了当前帧。当执行这个方法时，它使用这个帧来存储参数、局部变量、中间运算结果等等。
3、Java栈上的所有数据都是私有的。任何线程都不能访问另一个线程的栈数据。所以我们不用考虑多线程情况下栈数据访问同步的情况。
spring是否使用了threadlocal？
ThreadLocal是JDK提供的为解决线程安全的一种解决办法
spring自己肯定用到了ThreadLocal
参考资料：
https://blog.csdn.net/hello_ken/article/details/20177341
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aedee31f7bb01918e92bbf22649214ad/" rel="bookmark">
			计算机组成原理：1.2 计算机的基本组成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.2 计算机的基本组成 文章目录 1.2 计算机的基本组成1 冯·诺伊曼计算机的特点2 计算机硬件结构框图3 计算机的工作流程3.1 主存储器3.2 CPU：运算器3.3 CPU：控制器3.4 I/O3.5 ✊总结，全流程 1 冯·诺伊曼计算机的特点 计算机由运算器、存储器、输入设备、输出设备、控制器五大部件组成指令和数据以同等地位存放于存储器内，并可按照地址寻访指令和数据均以二进制数表示指令由操作码和地址码组成，操作码用来表示操作的性质，地址码用来表示操作数在存储器中的位置。指令在存储器内按顺序存放。通常指令是按顺序执行的，在特定条件下可根据运算结果或者根据设定的条件改变执行顺序。机器以运算器为中心，输入输出设备与存储器间的数据传送通过运算器完成。 2 计算机硬件结构框图 图1
图2
运算器和控制器在逻辑关系和电路结构上联系紧密，所以通常被集成在一个芯片上，因此将他们合称为CPU（Center Processing Unit）；输入和输出设备统称为IO设备。
所以现代计算机可以认为是三大部分组成：CPU、I/O设备、主存储器
图3
主存储器（Main Memory）：存储子系统的一类，用来存放程序和数据，可以直接与CPU交换信息。另一类称为辅助存储器，简称辅存，又称外存。
算术逻辑单元（Arithmetic Logic Unit）：简称算逻部件，用来完成算术逻辑运算。
控制单元（Control Unit）：用来解释存储器中的指令，并发出各种操作命令来执行指令。
3 计算机的工作流程 我的书写顺序可能跟书上不太一样，编制解题程序的机器指令放到了本节最后
图4
ACC（Accumulator）：累加器
MQ（Multiplier-Quotient Register）：乘商寄存器
X：操作数寄存器
PC（Program Counter）：程序计数器
IR（Instruction Register）：指令寄存器
MAR（Memory Adress Register）：存储器地址寄存器
MDR（Memory Data Register）：存储器数据寄存器
3.1 主存储器 图5
存储体由很多存储单元组成，每个存储单元里面又包含很多存储元件，每个存储元件能够寄存一位二进制代码0或者1，所以，一个存储单元能够存储一串二进制代码，那么这串二进制代码被称为一个存储字，这串二进制代码的长度被称为存储字长
一个存储字可以表示一个数字、一串字符或者一条指令。
主存的工作方式是按存储单元的地址号来实现对存储字各位的存取，这种方式被称为按地址存取方式
我们看图4中的MAR和MDR，MAR是存储器地址寄存器，我们使用MAR是要寄存存储单元的地址，那么有多少存储单元，MAR就要能构成多少个地址。比如我有64个存储单元，那么MAR必定有6位，因为2^6=64，只有六位才能产生64个不同的地址。
而下面几个小节我们会提到，MDR是存储器数据寄存器，从存储体中获得的数据（存储字）需要寄存到MDR中，那么MDR的位数应该和存储字的长度相同（即存储字长）
所以假设MAR的位数位n，MDR的位数为m，那么我们会有 2 n 2^n 2n个存储单元，每个单元又会有m个存储元件，那么总容量应该为 ( 2 n ) × m (2^n)\times m (2n)×m。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aedee31f7bb01918e92bbf22649214ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/798e3820165ed602a26f8c925f2a35a6/" rel="bookmark">
			idea更新版本2017切换到2020
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近组内的项目中，有人用到了lombok，我的idea运行会报错，可能是由于我的idea版本是2017的原因；所以我就重新下载了idea 2020.2.3，原版本没动；
从就版本导出了settings文件，可行；
下午手欠删除了旧版本的文件，我这个新版本莫名启动不了了，现象是双击没反应。。。
我做了以下操作：
控制面板卸载2020版本，重新下载----报错；百度后，打开idea安装文件的bin目录下，找到idea.bat;编辑后再最后一行写“pause”，然后保存退出，双击idea.bat，弹出黑窗口，会有报错信息；“Error opening zip file or JAR manifest missing : D:\IntelliJ IDEA 2017.3.4\b”，然后我发现报错信息含有我之前删除的内容，就说明有些地方还没删除干净，于是百度了下，在c盘的用户目录下有个关于idea的文件未删掉，将这个删除后再重新下载安装就可以了； 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88f034e06413f378bbd59b6a71c29c1d/" rel="bookmark">
			解决Ajax返回值过大时，速度慢的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 ajax请求成功后，Response返回值过大，约为3.6M，导致加载速度很慢，当网络环境不好时，居然耗时36s…忍不了！
问题解决 tomcat 加属性
其实就是启用压缩，由服务器端进行压缩，客户端进行解压 &lt;Connector port="8088" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" compression="on" //是否启用压缩 on为启用（文本数据压缩） off为不启用， force 压缩所有数据 compressionMinSize="1536"//1.5MB，表示压缩响应的最小值,当超过最小数据大小才进行压缩 noCompressionUserAgents="gozilla, traviata"//对于以下的浏览器，不启用压缩，默认是不限制 compressableMimeType="text/html,text/xml,text/plain,text/javascript,text/csv,application/javascript,application/json"//配置想压缩的数据类型，默认是 text/html,text/xml,text/plain 说明 虽然速度变快了不少，但是这样做会增加服务器端和用户端CPU的压力，compressionMinSize不是越小越好
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c49c346456dc1f1805d32b14474d3f87/" rel="bookmark">
			【图文教程】Ansible
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ansible 1. Ansible介绍2. 安装Ansible3. Ansible远程执行命令4. Ansible操作文件和目录5. Ansible远程执行脚本6. Ansible管理任务计划7. Ansible软件、服务管理8. Ansible文档的使用 1. Ansible介绍 官网 www.ansible.com
在线电子书：https://getansible.com
Ansible是一款由RedHat赞助的开源软件。它是一款可以在整个IT团队中使用的自动化语言，从系统到网络到开发。它目前已经整合了虚拟化（Vmware、RHEV、Xen等）、网络设备（思科、F5、OpenSwitch）、容器（Docker、LXC）、公有云（亚马逊云AWS、微软Azure）、DEVOPS（Gitlab、Github、Jenkins）、监控/分析（Splunk、InfluxDB）等多个领域。
2. 安装Ansible 文档：https://docs.ansible.com/ansible/latest/index.html
在CentOS7上安装Ansible 1. yum install -y epel-release 2. yum install -y ansible 另外，ansible也支持使用pip安装 pip install ansible Ansible因为是angent-less，所以只有一个控制中心，其他机器无需安装任何软件包。但，要想控制远程机器，还需要配置密钥认证。 1. 在控制中心生成密钥对 最好是先检查一下，ls ~/.ssh/，看看该目录下有没有id_rsa以及id_rsa.pub两个文件。如果没有执行如下命令 ssh-keygen 举例： [root@test01 ~]# ssh-keygen Generating public/private rsa key pair. Enter file in which to save the key (/root/.ssh/id_rsa): #直接回车 Created directory '/root/.ssh'. Enter passphrase (empty for no passphrase): #直接回车 Enter same passphrase again: #直接回车 Your identification has been saved in /root/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c49c346456dc1f1805d32b14474d3f87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9c66b519af3ecb4a5611ca807a7bae2/" rel="bookmark">
			STM32四种库对比：寄存器、标准外设库、HAL、LL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关注+星标公众号，不错过精彩内容
作者 | strongerHuang
微信公众号 | strongerHuang
1.我是选择寄存器开发STM32，还是标准外设库呢？
2.你有STM32L0标准外设库吗？
3.HAL库和LL库有什么差异？
。。。
下面就来讲讲开发STM32的四种库：
STM32Snippets
Standard Peripheral Library
STM32Cube LL
STM32Cube HAL
1
STM32Snippets 什么是STM32Snippets？
STM32Snippets可翻译为“代码片段”、“裁剪”，其实他就是我们常说的“寄存器”开发STM32的底层驱动代码。
比如配置ADC引脚的代码片段：
__INLINE void ConfigureGPIOforADC(void) { /* (1) Enable the peripheral clock of GPIOA, GPIOB and GPIOC */ /* (2) Select analog mode for PA1 */ /* (3) Select analog mode for PB1 */ /* (4) Select analog mode for PC0 */ RCC-&gt;AHBENR |= RCC_AHBENR_GPIOAEN | RCC_AHBENR_GPIOBEN | RCC_AHBENR_GPIOCEN; /* (1) */ GPIOA-&gt;MODER |= GPIO_MODER_MODER1; /* (2) */ GPIOB-&gt;MODER |= GPIO_MODER_MODER1; /* (3) */ GPIOC-&gt;MODER |= GPIO_MODER_MODER0; /* (4) */ } STM32Snippets是高度优化的示例代码集合，使用符合CMSIS的直接寄存器访问来减少代码开销，从而在各种应用程序中最大化STM32 MCUs的性能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9c66b519af3ecb4a5611ca807a7bae2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58eae41e43649c31853d42b54ea842b1/" rel="bookmark">
			CentOS Linux 7.9 (2009) 发布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CentOS 7.9 已发布，其开发团队也通过邮件列表宣布适用于 x86_64 架构的 CentOS Linux 7 (2009) 已正式 GA。CentOS 由 Red Hat Enterprise Linux 源代码重新编译而成，CentOS 7.9 的上游版本为 Red Hat Enterprise Linux 7.9。
主要改动
现已备有 Python 3。安装 python3 组件将会为你提供 Python 3.6 解释器
SSSD 已改版为 1.16.5pacemaker 已改版为 1.1.23MariaDB 已改版为 5.5.68 自 1503 发行版本（abrt&gt;= 2.1.11-19.el7.centos.0.1）开始，CentOS-7 可以直接向 bugs.centos.org 汇报错误，你可以在 这里 找到更多关于此功能的数据
如果你准备在 Anaconda 采用安全性配置文件，请参阅此 链接
很多组件已获得重要更新。详情见 上游的文档
缺省的桌面报告已更改，并记载于 上游
另外要注意的是，旧的内容以及被相同应用的新版本所取代的内容，会从 Extras/ 和 Plus/ 等仓库中被删除，本次更新还对托管在 mirror.centos.org 的 SIG 内容进行同样的处理，旧的 EOL 内容也会被删除。团队表示他们发布的所有内容，都会一直在 vault 服务上提供给仍在寻找并有实际需求的人。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58eae41e43649c31853d42b54ea842b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50ea1df22e85eda21cdb8b08b17b1e65/" rel="bookmark">
			application.yml 多环境配置 一、
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、便捷的多环境配置环境 只存在一个application.yml (该特性需要.yml文件 .properties 文件不适用 )
使用.yml 的特性 (---) 连接符 创建application.yml: 如下 #全局设置 my: val: aa: 123 --- spring: profiles: dev #在dev中获取的值是123 server: port: 8081 --- spring: profiles: test #在test中获取的值是33333222 server: port: 8089 my: val: aa: 33333222 上方可以有全局设置,通过—进行间隔 就可以实现在不同环境部署不同的配置
在Idea 中启动需要声明需要读取的配置文件环境:–spring.profiles.active=test
在linux 环境中启动 :
java -jar xxxxx.jar --spring.profiles.active=test 表示加载测试环境的配置
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb8c981f05459fcb858d9f003e9223aa/" rel="bookmark">
			JAVA之Thread类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、主线程 主线程：执行主方法的线程(main)
JVM执行main()，main()会进入到栈内存，JVM会找操作系统开辟一条main方法通向CPU的执行路径
CPu就可以通过这个路径来执行main方法，而这个路径就叫做主（main）线程。
单线程程序：Java程序只有一个线程
Java程序属于抢占式调度，哪个线程的优先级高，就优先调度；同级随机调度。
二、如何多线程程序 创建多线程程序有两种方法。
1、一种方法是将类声明为 Thread 的子类。该子类应重写 Thread 类的 run 方法。
创建多线程程序的第一种方式：创建Thread类的子类
java.lang.Thread类：是描述线程的类，需继承Thread类。
实现步骤：
1、创建一个Thread类的子类
2、在Thread类的子类中重写Thread类的run()，设置线程任务（开启线程要做什么）
3、创建Thread类的子类对象
4、调用Thread类的start()，开启新线程，执行run()
void start() 使该线程开始执行；JVM调用该线程的run()
Thread子类代码如下：
package test.day22Process; /* Java程序属于抢占式调度，哪个线程的优先级高，就优先调度；同级随机调度。 创建多线程程序的第一种方式：创建Thread类的子类 java.lang.Thread类：是描述线程的类，需继承Thread类 实现步骤： 1、创建一个Thread类的子类 2、在Thread类的子类中重写Thread类的run()，设置线程任务（开启线程要做什么） 3、创建Thread类的子类对象 4、调用Thread类的start()，开启新线程，执行run() void start() 使该线程开始执行；JVM调用该线程的run() */ public class Demo02Thread extends Thread { //设置线程的任务 @Override public void run() { for (int i = 0; i &lt; 20; i++) { System.out.println("run" + i); } } } 测试代码如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb8c981f05459fcb858d9f003e9223aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d15f9d7d7ff30795f819cd57db32538/" rel="bookmark">
			相同类名Bean注入Spring解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/liuyueyi25/article/details/83280239
多个相同Class　类
@LoadBalanced @Bean //必须new 一个RestTemplate并放入spring容器当中,否则启动时报错 public RestTemplate restTemplate() { RestTemplate restTemplate = new RestTemplate(); restTemplate.setRequestFactory(clientHttpRequestFactory); restTemplate.setErrorHandler(new ClientExceptionHandler()); return restTemplate; } @Bean // 调用消息中心时使用此restTemplate public RestTemplate normalRestTemplate() { RestTemplate restTemplate = new RestTemplate(); // 建立http连接时间 clientHttpRequestFactory.setConnectTimeout(1000 * 60); // 5分钟不返回数据则为超时 clientHttpRequestFactory.setReadTimeout(1000 * 60 * 5); restTemplate.setRequestFactory(clientHttpRequestFactory); restTemplate.setErrorHandler(new ClientExceptionHandler()); return restTemplate; } 通过Spring 容器寻找时　可通过
@Autowired private final RestTemplate normalRestTemplate; 属性名称指定注入时的方法进行指定
如果注入的是某个接口，需要找到下面实现类，也是类似　属性名称指定为需要注入的实体类名称
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5718e7fb28e2e7c9a799b3884c46065b/" rel="bookmark">
			iptv电视直播_简单介绍IPTV电视中的组播技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		家里使用的是电信宽带，电脑上网时经常在网页右下角弹出运营商推送的弹窗图片提示，提醒用户升级高清网络机顶盒。IPTV定制机顶盒首页也出现提醒页面：预存话费，升级组播机顶盒，赠送三个月的VIP会员。营业厅业务员也打来电话，催促尽快去办理，并告知最近开始关停IPTV点播，只能用组播网络机顶盒了。机顶盒提醒页面如下图所示。
我原来使用的IPTV机顶盒是单播的，通过WiFi连接到无线路由器即可观看。通过查阅资料得知，单播时，电视直播播放地址就是一个网址，类似http网址的形式。这样每个电视台对应一个网址，每个用户观看时都会与直播服务器建立一个网络连接，当用户数目庞大时，服务器会建立大量连接，服务器负载很重，为缓解服务器压力，运营商就需要建立众多直播服务器。这点类似网络访问，每个用户对网站一个文件的访问，就会产生一个连接。
为了解决单播IPTV技术对服务器的压力，运营商逐渐推出更适合电视直播的IPTV组播技术。任何用户的IPTV机顶盒开机通过账号验证后，就加入了一个播放组，这样原理的直播服务器不再单独对一个用户发送数据，而是直接对这个组发送，这样大大缓解了服务器压力。用户越多，组播技术优势越明显。普通用户可以这样判断，只能通过光猫ITV网口连接机顶盒观看电视直播的就是采用的组播，通过普通路由器网口或无线WiFi连接就可以观看的，一般就是采用的单播技术。
当然，对光猫和无线路由器经过特殊设置，利用组播技术的机顶盒也可以通过无线路由器的特定网口联网后观看。
以上就是对组播技术的简单通俗的解释，欢迎补充完善。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2dc4668d294c8ab48456751db8c06ef/" rel="bookmark">
			HTTPS之TLS证书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一. TLS概述1. TLS概述2. `HTTPS` 协议栈与 `HTTP` 的唯一区别3. TLS协议版本 二. TLS证书格式1. 概述2. 示例：知乎网站证书解析(mac系统)3. 通过openssl获取证书的含义 三. 证书链（Certificate Chain）1. 背景2. 概述3. 背景问题的解释 参考资料 一. TLS概述 1. TLS概述 TLS 握手的作用之一是身份认证），被验证的一方需要提供一个身份证明。在 HTTPS 的世界里，这个身份证明就是 「TLS 证书」，或者称为 「HTTPS 证书」。 例如，我们在访问 https://www.youzan.com 时，浏览器会得到一个 TLS 证书，这个数字证书用于证明我们正在访问的网站和证书的持有者是匹配的，否则因为身份认证无法通过，连接也就无法建立。
浏览器得到的是一个证书的链表，这个链表叫证书链（Certificate Chain）。
2. HTTPS 协议栈与 HTTP 的唯一区别 HTTPS 多了一个安全层（Security Layer），即 TLS/SSL 。SSL 是最早的安全层协议， TLS 由 SSL 发展而来，下面我们统称 TLS 。
3. TLS协议版本 OkHttp是android端最火热的一个轻量级框架，用于替代HttpUrlConnection和Apache HttpClient。它用一个 enum 类型来表示 TLS 协议的不同版本。可以看到最早的版本是 SSLv3，诞生于 1996 年，最新的版本是 TLSv1.3。 public enum TlsVersion { TLS_1_3("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2dc4668d294c8ab48456751db8c06ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99cab236b514426d98b5fd14db362bb0/" rel="bookmark">
			qc是什么职位_质量管理部门该干什么？又该怎么干？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 质量管理部门职责不清，不仅影响到工作效率，职责错位还容易导致人心不稳。
质量管理部门管理要点、职责和岗位设置
1、质量管理组织内部管理要点：
应有文件化的品管组织和隶属关系；品管内部的人员要有明确的职责分工(职位说明书)；文件化的品管权限－如原料，半成品，成品放行权等；有培训计划和培训执行记录；有内部奖惩制度，并与工资挂钩；要对产品质量数据的收集和分析，并与部门及责任人绩效挂钩。 2、质量管理部门的一般职责：
进料检验－原料，辅料，包装物料等；过程监控－人、机、料、法、环；成品检验－人员，时机，依据，权限；监视测量装置的校准与管理；品质保证能力－质量体系的建立和推进；品质计划－产品标准，作业指导书，工艺文件，记录；客户投诉相关过程的管理－原因分析，就正措施，程序化；样品管理。 3、质量管理部门的主要岗位
原料/辅料/包装物料验收员(原料专员)；品管员－过程监控和监督，客户投诉的处理与跟踪；质检员－半成品、成品感官检验，检测样品取样；化验员－化验室检测；发货监装员；体系推进和考核；标准化管理员－官方文件的接收和处理，企业标准起草、备案，本部门第三层文件起草、修订，计量器具管理。 4、质量部门设置及分工是什么？
质量检验工作：制程(生产过程)质量检验(IPQC)，进料质量检验(IQC)，装配质量检验，出货质量检验(OQC)；质量体系(QS)，品质工程(QE)，品质保证(QA)，供应商质量管理(SQA)。
5、质量部工作的主要考核项目和指标：
(1)主要项目：
质量管理、质量检验制度是否完善；产品质量检验、生产过程控制是否完善、有效；计量检验器具是否定期校准，质量标准贯彻执行的情况；对关键生产工序的质量检验制度执行的情况；对原材料、外购件、成品的质量检验是否到位，是否有记录；质量管理体系运行是否全面、有效。 (2)主要指标：
产品质量合格率；制成不良率；监测和测量仪器校准率；产品检验状态标识率；质量计划指标完成率；管理评审整改措施完成率；抽检不良率；纠正措施的有效率；原材料消耗下降率；质量成本指标完成率。 6、质量部门应达到的标准：
质量管理的要求贯穿于企业经营管理的各项活动中，质量检验贯穿于产品生产经营的全过程，确保产品状态标识易于识别和可追溯；建立起规范的不合格品的鉴别、识别、记录、评审和处置办法；制订有效的预防措施，以消除潜在的不合格的原因，防止不合格的发生；制订有效的纠正措施标准，以消除不合格产生的原因以及顾客不满意的情况；建立并实施采购检验标准，以确保采购的产品满足规定的质量要求；质量记录完整、规范，内部审核、管理评审按计划执行，管理目标完成情况良好。 质量管理部门各项工作的具体内容
1、进料管理：
有明确的检验标准；验收流程要清晰；抽样的方法需正确；应定期对供应商进行现场评估；定期统计供应商的所供原料的品质状况；供应商的产品品质发生异常应及时与其沟通；应有明确的供应商考核办法；供应商连续出现质量问题应有相应的处理办法；供应商产品质量进行改进后要及时跟踪；明确规定因供应商原材料质量问题造成损失的责任承担办法，并在相应的合同中予以明确；进料检验组人员的应有必要的专业知识和职业素质；进料检验报告要清晰，并得到合理的保存；原材料存在轻微质量问题，而生产车间又急需用时，应有明确的特采程序，并规定特采批准人；紧急放行应有明确的程序，并规定紧急放行批准人；不合格的原材料要有明确的处置方式；规定退回供应的产品应及时退回。 2、过程管理—人员
合理配备过程检验和监控人员；过程检验和监控人员的能力和素质应符合要求；过程检验和监控的力度要达到企业预防产品出现不合格品的需要；过程产品出现不合格品如何处置要有明确的措施；产品出现不合格时信息要及时传递；产品出现不合格品原因要明确由谁来分析；过程所运用的统计技术应满足企业的需要；过程检验和监控人员与各车间要有良好的沟通渠道，并形成产品质量是制造出来的，而不是检验出来的理念；产品订单的特殊要求要能及时传递到过程监控人员。 3、过程管理－文件和标准
有准确、适宜和充分的作业指导书；有准确、适宜和充分的过程检验标准；有明确的过程检验流程及质量控制点；有过程检验记录/监督监控记录且真实可行；有文件化过程异常处理的程序；要明确规定半成品放行权；有文件化的过程检验状态标准及区分，且有效执行；有相关品质问题及统计分析。 4、成品管理
要有明确的成品检验标准；成品检验(含化验员)人员的能力和素质要达到相应的要求；成品检验的抽样方法要合理；每一客户/订单的特殊要求都准确无误地传递到相关人员；有文件规定成品的标识方法并得到有效执行；有有效防止成品漏检的方法；有文件化规定成品异常处理程序，如处理方法、批准权限；成品检验结果由谁批准；成品是否可以特别放行，如可以特别放行应达到怎样的程度才可特别放行，审批权限要得到明确的规定；成品检验报告要清晰，并得到合理保存，通过成品检验报告能追溯到相应的生产组、批号、日期及重要原材料等；要有发货监装记录且记录完整；要形成长期积压库存定期报告制度；库存积压产品出厂前要重新检验确认。 5、监视和测量装置管理
计量/检测没备要形成台账统一管理，台帐要实行动态管理，定时更新；各质量检验流程要明确规定所使用仪器名称；计量/检测设备的精确度要达到测量的使用要求；计量/检测设备要按要求定期进行校验(外/内)；计量设备的使用状态标识要明确；计量设备所使用的环境要达到其设备本身要求的环境条件；复杂的计量设备要形成操作指导书指导员工如何操作；检测设备要定期保养且建档。 6、质量保证－体系推进和考核
建立完整的质量管理体系(从设计一试产—生产—检测—出货一服务)；整体管理架构要完整，各级管理职能要明确；以文件形式规定质量目标且为员工所理解，并分解到各部门且得以执行；各相关单位对质量记录要的收集、发放、借阅等要进行管制；产品生产过程中各产品的状态有标识并有追溯性；客户抱怨处置及时，定期进行客户满意度调查；对体系运行情况进行定期的考核和改进。 7、质量保证－品质计划
生产前有完善的品质计划(作业指导书/加工工艺/质量记录/卫生保证措施/质量控制点的确定)，尤其对特殊的产品有无特别的规定；客户的要求被相关质量管理人员熟知；各相关人员均进行了岗位培训，且考试通过方可上岗，并有相应记录；对可能发现的异常进行分析识别，并采取预防措施；开展有助于质量提升的5S、QC等活动；涉及产品更改，要有书面的会签确认，并对相应品质再检验确认且有相应记录；品质控制各阶段保证没有漏检发生，并有相应方法或程序支持。 8、质量保证－制度、文件及其它
内部要有明确的奖罚制度；各员工的工作职责要明确；各种工作流程要做出合理明确的规定；本部门能够得到技术文件的最新版本；文件的保存安全可靠，便于索引与使用，并能防止错用文件；员工均进行适当的培训，确保其胜任本岗位的工作；公司上级文件与思想及时向下传达；与其他部门建立了良好的沟通。 9、客户投诉
每一次客户投诉要以最快的速度回复，并尽量让顾客满意；客户投诉的处理流程及由谁来处理要有明确规定；客户投诉回复内容要适当，并有文件明确规定批准人；每次客户投诉都要进行相应原因分析，制定了必要的纠正和预防措施，并标准化；对客户投诉要进行定期统计和分析；交货的及时性等方面投诉也应进行统计和管理。 10、实物样品(或图片)
当不便用文字表达或用文字表达不清楚时，要形成实物样品封存或拍成照片作为参照；实物样品(图片)是否分为合格限度样品与不合格限度样品，让员工明确判断标准；实物样品(图片)是否定期确认和更新；进料、制造过程、成品各过程中在需要的地方均有便于参照的实物样品(图片)；合理保存实物样品(图片)，使其不易变质。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e3e429d3ed58a1ee7656a85dc7c3c54/" rel="bookmark">
			想要降低gradle版本时遇到“Minimum supported Gradle version is XXX. Current version is XXX.”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 要降低的gradle版本超过目前支持最低版本 原因： 在Android Studio中有Gradle版本号和Gradle插件版本号，他们对应的关系如下图所示
当“要降低的Gradle版本” 低于 Gradle插件版本对应的“所需的Gradle版本时”就会出现“Minimum supported Gradle version is XXX. Current version is XXX.”
解决方法： 将Gradle插件版本号设低一些，直至满足“要降低的Gradle版本号”，要修改的代码如下所示：
buildscript { ....... dependencies { classpath "com.android.tools.build:gradle:3.3.0"//在这里修改gradle插件版本号 classpath "com.chaquo.python:gradle:8.0.0" } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/635434f1563bffee76f34b35e21f45d8/" rel="bookmark">
			Android Studio Gradle下载慢解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android Studio Gradle下载慢解决方法 一、添加镜像 要修改的位置在Android项目下的"build.gradle"文件，如图1.1所示。
图1.1 在 “buildscript” → “repositories” 下 ① 添加两行代码
maven{url 'http://maven.aliyun.com/nexus/content/groups/public/'}//添加 maven{url "https://jitpack.io"}//添加 ② 注释一行代码
//jcenter()//注释 结果如图1.2所示
图1.2 在 “allprojects” → " repositories" 下 ① 添加一行代码
maven{url 'http://maven.aliyun.com/nexus/content/groups/public/'}//添加 ② 注释一行代码
//jcenter()//注释 结果如图1.3所示：
图1.3 嘿嘿，完工~
不过有时候可能也不行，就要执行方案 二
二、直接下载 在Android的项目下打开 “gradle-wrapper.properties” 文件，该文件位置如图2.1所示。 注：要用 “ Project”模式打开，在图2.1左上角的红色框框
图2.1 修改图2.2中红色框框的代码，该部分代码表示需要需要的gradle版本号，本仔此次要下载的是gradle6.5，故代码设为“gradle-6.5”。 点击“sync”后，就会自动下载，但没用镜像和科学上网，下载老慢了 此时就要用 “直接下载大法” ，如图2.2中所示，当Android studio自动下gradle时，进入“红框1” 的 “Build” 窗口，会看到 “红框2” 的下载地址(gradle6.5的下载地址），复制它。接着使用迅雷大法，用复制好的下载地址新建迅雷任务进行下载，速度起飞。
图2.2 如图2.3所示，接着进入 “我的文档” → “.gradle” → “wrapper” → “dists”，找到刚才下载版本对应的文件夹（刚才下载gradle6.5，故选择红框里的文件夹） 图2.3 进入后，出现一个无规律名字的文件夹，不要理它，继续点击进去，就出现如图2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/635434f1563bffee76f34b35e21f45d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efb18d72e658d79b4119513903ae1fe0/" rel="bookmark">
			AQS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AQS 什么是AQS 我们在使用锁时，一般会有如下几点考虑：
希望这个锁是同一时间只能被一个线程获取的，还是能够被多个线程获取。当几个线程在同时争抢锁的占有权时，怎么处理没有获取到锁的线程某个线程一直获取不到锁，怎么处理中断 基于JVM实现的锁Synchronized只支持独占，并且无法处理中断，也不支持公平和非公平的选择。所以在JDK1.5时引入了基于AQS实现的锁，它们功能更加地强大，比如ReentrantLock、CountDownLatch、CyclicBarrier等等。
AQS即AbstractQueuedSynchronizer的缩写，它是Java并发用来构建锁和其他同步组件的基础框架。在内部维护了一个Volatile的变量state和一个CLH队列
state 代表着共享资源，获取和释放锁本质上就是对state进行的修改，修改成功则获取锁，否则会被加入到等待队列
state值描述0当前锁没有线程持有1被线程持有大于1同一个线程重复获得了锁（锁的可重入性） CLH队列 CLH队列：是一个FIFO的双端双向队列，如下图：
该队列由Node结点构成，每个Node结点维护一个pre引用和next引用，分别指向前驱节点和后继节点。AQS维护两个指针，分别指向队列的头结点和尾节点
CLH队列其实就是一个双端双向链表，当线程获取资源失败（tryAcquire失败）时会被构造成一个Node结点加入CLH队列，同时该线程会被阻塞。当持有锁的线程释放锁时会唤醒后继结点再次尝试获取锁
Node结点 获取锁失败的线程会被包装成一个Node结点加入到CLH队列中，它是AQS中的一个静态内部类，其中有一个int变量waitStatus标识结点的状态
waitStatus值描述CANCELLED (1)表示当前线程超时、中断SIGNAL （-1）表示后续节点会被唤醒PROPAGATE （-2）表示下一次唤醒是共享的，会无条件地传播下去（主要实现共享锁）waitStatus （0）初始状态 AQS的使用 AQS采用了模板方法模式进行设计，使用方法如下：
使用者继承AbstractQueuedSynchronizer并重写指定的方法（就是对于共享资源state的修改操作）
在具体的锁中创建一个内部类继承自AQS，并调用其模板方法
需要重写的方法：
方法名描述tryAcquire独占获取锁，成功返回true，失败falsetryRelease独占释放锁，等待队列中的其他线程此时将有机会获取到同步状态tryAcquireShared共享获取锁，返回值大于等于0表示成功tryReleaseShared共享释放锁，成功返回true 如何使用 首先，我们需要去继承AQS类，然后根据需要去重写对应的方法，比如要实现独占锁就去重写tryAcquire、tryRelease方法。最后在我们的锁中调用AQS的模板方法就可以了，而这些模板方法会调用我们重写的方法
public final void acquire(int arg) { if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); } tryAcquire就是我们需要重写的，而像addWaiter、acquireQueued方法是AQS为我们写好的
AQS源码分析 接下来通过ReentrantLock、CoutDownLatch来分别讲下AQS的独占功能和共享功能以及整个加锁释放锁流程是怎么实现的
独占锁 假设这里有3个线程ThreadA、ThreadB、ThreadC，一个独占锁ReentrantLock
第一个线程获取锁 在进行锁的创建时通过传入的boolean值决定该锁是公平锁还是非公平锁。如果不传入值则默认是非公平锁
整个锁的获取流程如上图所示：首先线程调用lock方法开始尝试获取锁，然后会调用acquire方法，AQS会调用重写的tryAcquire方法
public final void acquire(int arg) { if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); } 任何一种基于AQS实现的独占锁都会来到这一步，各种锁通过对tryAcquire的不同的重写方式实现了不同的功能。比如ReentrantLock就是通过两个不同的内部类重写了tryAcquire方法来实现了公平与非公平锁
公平与非公平的区别就是公平锁在尝试获取时会进行一次判断，当前等待队列中是否有结点而且是当前结点的前驱节点
最开始等待队列是这个样子：
接着通过CAS操作更新state的值,更改成功，则获取锁成功
如果State的值不为0，也就是说当前锁已经被占有了，那就判断是否是重入地获得锁。
第一个线程时由于tryAcquire方法成功，因此能够直接获取锁
第二个线程尝试获取锁 依然是会调用tryAcquire方法，这里以公平锁为例
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/efb18d72e658d79b4119513903ae1fe0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb80f1d228810b3d185fd882ea612e10/" rel="bookmark">
			iptv电视直播_IPTV电视直播系统apk运营—怎么让视频更流畅
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多IPTV电视直播系统运营者都会有这样的疑问：怎么才能让视频更流畅的播放？
这里小编就可能影响APK播放视频流畅度的原因做简单分析。
视频源的清晰度和流畅度 我们知道视频的 清晰度和大小和视频的码率有关，如果运营者自己的源本身就是码率高的，而且在VLC等常用播放器中都可以流畅播放的话，那么在电视盒中如果其他条件都是比较好的话，那么就可以实现清晰流畅播放。
播放器性能 很多IPTV电视直播系统的APK软件商的播放器是自己研发的，但是也不排除有些是用的开源的系统，相比开源系统播放器，自主研发的会在很多方面做改进，尤其是已经在市场上使用几年的播放器，对盒子的适配播放等方面都有优势。
IPTV电视直播系统
盒子解码能力 视频的解码分为硬件和软件，硬件使用的是硬件本身的GPU解码，而软解则是使用的CPU解码。所以盒子的解码能力对于视频的流畅播放也是很重要的。点量IPTV电视系统在解码播放方面设置的是可做到软硬解自适应，优先选择合适的解码方式。
带宽等硬件情况 最后就是并发人数和带宽的情况了，一般来说清晰度越高码率越高，并发人数越多，需要的带宽就越大。但是在实际中并不会单纯使用带宽来支撑力量，而是选择CDN加速或者P2P来做加速。关于CDN和P2P加速两种不同情况，小编在后期的文章中会和大家分享交流。
PS：小编不是专业技术出身，所分享皆为实际中自己经验累积，如有错误或者不同意见，欢迎下方留言交流。
​
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/498341706d5527e0f5dcc2de1afe311b/" rel="bookmark">
			后端处理前端传递过来的base64文件，上传到ftp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		改公司一个app,他们用canvas做手动签名，上传过程中后端用MultipartFile接收，接收到的文件没后缀名。
后面百度知道base64头部有文件类型，需要在后端处理。
大概思路就是base64转MultipartFile然后在调用以前文件上传的方法。
======================================前端
let path = res.tempFilePath;
uni.showLoading({title: '上传中...',mask: true});//遮罩层
uni.uploadFile({
url: request.baseUrl + '/xxController/uploadImg?fId=' + that.id,
header: {
'token': that.$store.state.token
},
file: path,//修改前的参数传递
name: 'file',
formData: {//修改后参数传递：将文件base64通过额外参数传递到后台
'base64Str':path
},
success: (res) =&gt; {
path变量在前端打印的格式：
头部data:image/png;base64, 文件内容去除头部部分
data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAtoAAAMQCAYAAAAZ6sJVAAAgAElEQVR4Xu3dC9AvaV0f+G+8RWuAGQRFkyhQtVmjRkHxVonZmaktozUagTW73IwMK1fRAGIC7iLDJcmiRsBNMMCiDK4gWDGAF9aNW8uQ1ZRGkEtQd7Nby4yuishlQEy8s/WD/ytnDud9+/Lv/nf305+uOjXodD...
======================================后端
第一步:我们需要一个base64转MultipartFile的类【直接拷贝用就行】
package com.synda.cgegov.utils; import org.springframework.web.multipart.MultipartFile; import java.io.*; public class BASE64DecodedMultipartFile implements MultipartFile { private final byte[] imgContent; private final String header; public BASE64DecodedMultipartFile(byte[] imgContent, String header) { this.imgContent = imgContent; this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/498341706d5527e0f5dcc2de1afe311b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30d0ca68e23a03a9772205e5ee254a86/" rel="bookmark">
			电信PPPoE拨号失败，获取不到IP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		症状：光猫指示灯一切正常，防火墙接口物理状态UP，协议状态down，获取不到IP。
先说结论：原本的光猫太旧，电信系统更新后协议匹配不上，联系电信更换光猫就好。
------------------------------------------------------------------------------------------------------------------
在冲浪的时候同事反映网速慢，我们有两条线，一个专线一个pppoe的，其中一条挂了的话流量就会挤进另一条，导致网络变慢。
我登上华为一看，原来是pppoe没获取到IP，身为甩锅达人，我当场就打电话给电信，电信表示我们的线路是正常的。
好吧，线路没问题那就是设备问题找华为吧
这里不得不说一下华为的技术，质量参差不齐，每次找技术跟抽奖一样，居然跟我说这是正常的状态，我要不是看过ccna就信了
在经过多个技术提出的多种方法的实验后发现，华为把包发出去，但是没有收到回复，问题指向了电信
其实之前我就直连光猫测试过了是可以上网的，但是现在问题指向了电信，只能再试了。
网线一接上，电脑右下角立马internet访问，我？？？，我都还没拨号呢！
马上查看本机IP，192.168.1.62，我？？？，原来电信把我的外网IP变成了内网IP，所以不用拨号就能上网！
好了，问题发现了，先恢复网络(把连接方式改DHCP)，然后喝口茶，再给电信电话。
电信马上派工程师带着光猫过来更换了，工程师说电信系统更新，光猫太旧跟系统连接失败就会获取到内网IP(半信半疑)
等他更换好，把接口连接方式改回pppoe，完事。
--------------------------------------------------------------------------------------------------------------
眼尖的小伙伴可能发现了，既然pppoe一直不行，那为什么我直连测试的时候可以呢？
答案是也不行，那时候我新建了宽带连接，接入网线后弹了两个出来，我手快都点了，后面报了651错误，我以为是重复登录的问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06860e1d614486e3ceda18649bf285f8/" rel="bookmark">
			CVE-2015-4852漏洞利用 weblogic远程代码执行的反序列化漏洞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0x00 漏洞产生原因
org.apache.commons.collections组件存在潜在的远程代码执行漏洞
0x01 影响范围
weblogic 10.3.6.0 12.2.1.0 12.2.2.0 12.2.3.0
0x02 漏洞利用
1.首先准备工具ysoserial,官方下载地址：点这，百度云链接：点这 提取码：k0n1
2.准备复现脚本：github脚本：https://github.com/nex1less/CVE-2015-4852
0x04 修复建议
升级weblogic版本
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9d1ca489bb34c394f78148b29650713/" rel="bookmark">
			7-26 单词长度（15分）你的程序要读入一行文本，其中以空格分隔为若干个单词，以.结束。你要输出每个单词的长度。这里的单词与语言无关，可以包括各种符号，比如it‘s算一个单词，长度为4。注意，行中可
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include&lt;stdio.h&gt; int main() { char input, blank = ' '; int num_letter = 0; int flag=0; while((input = getchar()) != '.'){ if(input != ' '){ num_letter++; } else if(num_letter != 0){ if(flag != 0){//如果前面有单词，则flag必为1 ，则输出一个空格 putchar(blank); } flag = 1; printf("%d",num_letter); num_letter = 0; } else{ continue; } } if(flag == 1&amp;&amp;num_letter != 0){//在最后一个单词时，读到空格就直接跳到continue，然后读到‘.’就退出循环了 putchar(blank);//保证前面一定有单词 输出一个空格 } if(num_letter){ printf("%d",num_letter);//输出在循环中计算的最后一个单词个数 } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bede63a09ba8a62c00360abca2fe4675/" rel="bookmark">
			Redis介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第1章 关系型与非关系型 关系型： mysql oracle
非关系型：redis mongo ES
第2章 Redis重要特性 AK47 1.速度快 c语言写的
代码优雅
单线程架构
2.支持多种数据结构 字符串，哈希，列表，集合，有序集合，地理位置
3.丰富的功能 天然计数器
健过期功能
消息队列
4.支持客户端语言多 php,java,python
5.数据持久化 所有的数据都运行在内存中
支持2种格式持久化数据AOF RDB AOF&amp;RDB
6.自带多种高可用架构 主从
哨兵
集群
第3章 redis应用场景 1.缓存-键过期时间 把session会话存在redis,过期删除
缓存用户信息，缓存Mysql部分数据，用户先访问redis，redis没有再访问mysql，然后回写给redis
商城优惠卷过期时间
2.排行榜-列表&amp;有序集合 热度/点击数排行榜
直播间礼物积分排行
3.计数器-天然支持计数器 帖子浏览数
视频播放数
评论数
点赞/踩
4.社交网络-集合 粉丝
共同好友
兴趣爱好
标签
5.消息队列-发布订阅 配合ELK缓存收集来的日志
第4章 Redis安装部署 1.redis官网 https://redis.io/
2.版本选择 2.x very old
3.x redis-cluster
4.x 混合持久化
5.x 新增加了流处理类型 最新稳定版
3.规划目录 /data/soft 下载目录
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bede63a09ba8a62c00360abca2fe4675/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53e16ac535c99e1e8097d10c54c29d46/" rel="bookmark">
			CMakeList 中 find_library 用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在CMakeList中，有时需要 寻找 三方库，通常是使用 find_libaray 来进行查找的。
find_library（名称1 [path1 path2 …]）作用：用于查找库。
VAR 创建名为的缓存条目以存储此命令的结果。
如果找到了库，结果将存储在变量中，除非清除变量，否则将不会重复搜索。
如果什么也没找到，结果将是-NOTFOUND。
REQUIRED如果未找到任何内容，该选项将停止处理并显示一条错误消息，
否则，下次使用相同的变量调 用find_library时，将再次尝试搜索。NAMES 为库指定一个或多个可能的名称。HINTS， PATHS 除了默认位置，还指定要搜索的目录。该子选项读取系统环境变量的路径。DOC 指定缓存条目的文档字符串。REQUIRED 如果未找到任何内容，则停止处理并显示错误消息。 Example1 ：
比如，我们经常会查找三方库。我们以VTK的中CMakeList 为例，如下
FindGLEW.cmake
find_library(GLEW_LIBRARY NAMES GLEW glew32 DOC "glew library") # ${CMAKE_CURRENT_LIST_DIR}/lib/Release 目录下，查找gpgjpeg库文件。 find_library(GPUJPEG_LIBRARY NAMES gpujpeg HINTS ${CMAKE_CURRENT_LIST_DIR}/lib/Release) find_library(GPUJPEG_LIBRARY_RELEASE NAMES gpujpeg HINTS ${CMAKE_CURRENT_LIST_DIR}/lib/Release) find_library(GPUJPEG_LIBRARY_DEBUG NAMES gpujpeg HINTS ${CMAKE_CURRENT_LIST_DIR}/lib/Debug) # 将GPUJPEG_LIBRARY 这个变量设置在THIRDPARTY_LIBRARIES 中 set(THIRDPARTY_LIBRARIES ${GPUJPEG_LIBRARY}) set(THIRDPARTY_LIBRARIES_RELEASE ${GPUJPEG_LIBRARY_RELEASE}) set(THIRDPARTY_LIBRARIES_DEBUG ${GPUJPEG_LIBRARY_DEBUG}) # 设置 TARGETS_GPUJPEG 路径文件，如果包含这个路径的文件，则包含这个*.cmake set (TARGETS_GPUJPEG "${CMAKE_CURRENT_LIST_DIR}/cmake/gpujpeg-targets.cmake") if(EXISTS ${TARGETS_GPUJPEG}) include(${TARGETS_GPUJPEG}) endif() 参考：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53e16ac535c99e1e8097d10c54c29d46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4b9829bb9a7dbabd3e79c57f9e99783/" rel="bookmark">
			CMakeLists.txt 之C&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.codekissyoung.com/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/cmake CMake 入门实战
CMake Official Tutorial——教程还是官方的好
cmake 教程 基本语法
一、什么是Cmake CMake是一个跨平台的、开源的安装(编译)工具， 因为它使用和平台、编译器无关的配置文件（较为简单的语句）来描述编译控制，所以他能够输出各种各样的makefile或者project文件,能测试编译器所支持的C++特性,类似UNIX下的automake。
二、常用命令 1. 指定 cmake 的最小版本 cmake_minimum_required(VERSION 3.15) 可选命令，如果 CMakeLists.txt 中使用了高版本 cmake 特有的命令，需要use这一行加以声明，会check and advice 升级到该版本或以上。
2. 设置项目名称 project(demo) 这个命令不是强制性的，加上它会引入两个变量 demo_BINARY_DIR 和 demo_SOURCE_DIR，同时，cmake 自动定义了两个等价的变量 PROJECT_BINARY_DIR 和 PROJECT_SOURCE_DIR。
3. 设置支持C++版本 set(CMAKE_CXX_STANDARD 14) 这里CMake 3.1或者更高版本支持使用这个，更低版本使用如下：
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11") 也可以使用如下，我最早接触是这个：
add_definitions(-std=c++11) #add_definitions("-Wall -std=c++14") 4. 设置编译器类型 set(CMAKE_CXX_COMPILER g++) 系统默认的gcc/g++在/usr/bin目录下。
我们升级安装的gcc目录在/usr/local/bin目录下，现在我们希望使用升级后的gcc。
通过百度搜索出来的结果，大多是如下操作:
在CMakeLists.txt中调用编译器之前添加：
SET(CMAKE_C_COMPILER "/usr/local/bin/gcc")
SET(CMAKE_CXX_COMPILER "/usr/local/bin/g++")
然而经过本人亲自实践，该方法不起作用，正确的做法是：
执行cmake命令之前，在shell终端先设置如下两个变量：
export CC=/usr/local/bin/gcc
export CXX=/usr/local/bin/g++
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4b9829bb9a7dbabd3e79c57f9e99783/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f75939bb20336f504a2e20092a3cb57/" rel="bookmark">
			Tips--解决Deepin20系统安装完毕无WiFi问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决Deepin系统安装完毕无WiFi问题 1. 问题描述2. 解决方案 1. 问题描述 Deepin前不久推出了全新的V20版本，抱着支持国产的态度体验了一下V20，发现安装完毕之后没有WiFi这个选项，只能链接有线网络。但是我的电脑有无线网卡，看来这是无线网卡驱动的问题。我的笔记本是thinkpad E480，网卡是RTL8821CE,　这个网卡巨坑，之前安装Ubuntu的时候就遇到这个网卡驱动没装上的问题。
2. 解决方案 解决方法就是安装网卡RTL8821CE的驱动了，如果你不确定你自己的笔记本无线网卡的型号是什么，可以在终端上通过这个语句来查询：
lspci 会出现下图所示的信息：
其中黑色标记部分就是我们要查询的网卡型号，我的网卡型号是RTL8821CE.
找到网卡型号之后就是安装相应的驱动了，我找了许多教程，发现安装该驱动需要修改makefille文件，这个对于小白来说可能有点麻烦，所以我找到了一个不需要额外修改makefile的驱动，下载链接在百度云网盘，提取密码是：gmp7
链接失效了或者无法下载了请及时留言～
下面就是安装驱动了，很简单：
将下载好的驱动的放在任意一个文件夹下从终端进入到该文件夹的目录分别运行一下指令： make clean make sudo make install sudo modprobe -a 8821ce 等待安装成功我们就会发现我们的电脑多了一个WiFi的图标哦～
然后进行享受deepin系统吧～
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8124fcf01a2e22c19ccf18a533b6fbf0/" rel="bookmark">
			小程序学习笔记04（零基础玩转小程序）--自定义组件、组件的回调方法，父组件向子组件传递数据，子组件向父组件传递数据，生命周期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、自定义组件–概述 新增组件：
创建文件夹，右键-》新建component一个组件由4个文件组成（js，json，wxml，wxss），如tabs.js,tabs.json等 申明组件
在需要使用组件的文件的json文件中的“usingComponent”，放入自定义组件，如tabs组件（通过添加键值对的形式完成，其中值为自定义组件的路径）实际就是哪个页面要使用这个组件，就在哪个页面的json文件中申明 { "usingComponents": { "tabs":"../../components/tabs/Tabs" } } 使用组件
在使用组件的页面使用该组件的标签，如
&lt;tabs&gt;&lt;/tabs&gt; 案例
1、创建自定义组件tabs
2、在tabs组件的js中完善数据部分 Component({ /** * 组件的属性列表 */ properties: { }, /** * 组件的初始数据 */ data: { tabs:[ {id:0,name:"首页",isActive:true}, {id:1,name:"原创",isActive:false}, {id:2,name:"分类",isActive:false}, {id:3,name:"关于",isActive:false} ] }) 3、在tabs组件的wxml页面中创建整个组件的布局 &lt;view class="tabs"&gt; &lt;view class="tabls_title"&gt; &lt;view wx:for="{{tabs}}" wx:key="id" class="title_item {{item.isActive?'active':''}}"&gt;{{item.name}}&lt;/view&gt; &lt;/view&gt; &lt;view class="tabs_content"&gt;内容&lt;/view&gt; &lt;/view&gt; 4、给整个tabs组件调整样式 .tabs{} .tabls_title{ display: flex; padding: 10rpx; } .title_item{ flex: 1; display: flexbox; justify-content: center; align-items: center; text-align: center; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8124fcf01a2e22c19ccf18a533b6fbf0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b61988e1c2d9d21b8464ee19e92b0e7/" rel="bookmark">
			虚拟顺丰快递生成器_【头条】可循环包装箱、环保PE袋，快递业将迎绿色“双11”...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原标题：【头条】可循环包装箱、环保PE袋，快递业将迎绿色“双11”
“双11”过后，大大小小的包装箱如何处理是个难题。记者从顺丰、百世快递、圆通速递等快递公司了解到，这个“双11”不少快递公司都试点使用可循环包装箱。此外，顺丰用智能安检机辅助人工筛查，并在收件端推出“脱敏呼叫”功能，较好地保护了消费者的隐私，这也是物流业首次实现消费者电话号的全流程隐匿。
11月11日，东大桥顺丰快递营业点，快递工作人员按地点将快递进行分类。 亮点1
试点使用可循环包装箱
昨日下午在快递营业站点，记者看到一个黑色的特殊包装箱，它材质偏硬，里面的拉扣可以方便固定货物。姚宏旭称，这就是可循环使用的包装箱，“快递小哥可以根据用户的需求，免费向用户提供，用户使用完包装箱后，小哥再回收回来继续使用。”
据介绍，这种可循环包装箱顺丰在北京投入了大约5万个，每个包装箱最高循环利用率可达到100次。
百世快递相关负责人也表示，今年“双11”， 已投入使用2000万条环保PE袋、60万余条环保可循环集包袋，并在全国快递网点和百世邻里首批铺设了5000多个绿色回收箱。
针对今年“双11”，圆通总部也根据业务量数据，提前储备可循环中转袋到全网，预计“双11”期间每天使用将达210万。
亮点2
快递小哥首次用上“虚拟号码”
地址、姓名、电话……消费者在填写物流单据时，这些信息缺一不可。信息虽然详细，但是也存在一定隐私泄露风险。
针对快件流转过程中可能出现的快件和用户信息安全风险，顺丰在今年“双11”推出了新的“黑科技”。在发件端，用智能安检机辅助人工筛查，对品种多样、规格不一、数量繁多的双11快件进行多方面检测，提升安检精度与效率，以此保障快件安全。在收件端推出的“脱敏呼叫”功能，接触过快件的所有工作人员仅能通过此功能与消费者进行联系，个人无法获悉用户电话号码。这也是物流业首次实现消费者电话号的全流程隐匿。
“这有点儿像咱们在网约车平台上约车，司机是通过虚拟号码联系到乘客，这样能够比较好地保护消费者隐私。”姚宏旭解释说。
本文来源于网络，版权归原作者所有!好文章要和大家分享，如有侵权，请联系删除！我们只是和大家一起分享原作者的好文章，如果真正侵害到原作者，或原作者文字不希望转载，请您及时通知我们，我们会马上删除。谢谢！感谢每一位辛勤著写的作者，感谢每一位的分享。共享经济的社会，我们需要共享与分享信息！返回搜狐，查看更多
责任编辑：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd5c97a53d89d1c073ab3f2b3fad1124/" rel="bookmark">
			Oracle基础包之DBMS_LOGMNR(十二)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 通过使用包DBMS_LOGMNR和DBMS_LOGMNR_D,可以分析重做日志和归档日志所记载的事务变化,最终确定误操作(例如DROP TABLE)的时间,跟踪用户事务操作,跟踪并还原表的DML操作.
回到顶部
包的组成 dbms_logmnr.add_logfile 作用： 用于为日志分析列表增加或删除日志文件，或者建立日志分析列表。
语法： dbms_logmnr.add_logfile(LogFileName in varchar2,Option in binary_integer default addfile); --其中LogFileName指定要增加或删除的日志文件名称，Option指定选项(dbms_logmnr.new建立日志分析列表，dbms_logmnr.addfile增加日志文件，dbms_logmnr.removefile删除文件) dbms_logmnr.start_logmnr 作用： 用于启动logmnr会话
语法： dbms_logmnr.start_logmnr(startscn in number default o,endscn in number default 0, starttime in date default '01-jan-1988',endtime in date default '01-jan-2988', dictfilename in varchar2 default '',option in binary_integer default 0); --其中startscn指定日志分析的起始scn值，endscn指定日志分析的结束scn值，starttime指定日志分析的起始时间，endtime指定日志分析的结束时间， --dictfilename指定日志分析要使用的字典文件名，option指定logminer分析选项。 dbms_logmnr.end_logmnr 作用： 结束logminer会话
语法： dbms_logmnr.end_logmnr dbms_logmnr.mine_value 作用： 用于返回要摘取的列信息，该函数在启动logminer之后调用。
语法： dbms_logmner.mine_value(sql_redo_undo in raw,column_name in varchar2 default '') return varchar2; --其中sql_redo_undo用于指定要摘取的数据(redo_value或undo_value)，column_name用于指定要摘取的列(格式：schema.table.column); dbms_logmnr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd5c97a53d89d1c073ab3f2b3fad1124/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dca54c1afd1bf581421bddde4f7c92f7/" rel="bookmark">
			Android Progressbar是否可见，获取以及设置进度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目源码：
UIWidgetTest
https://github.com/Phil-tom/Android-The-First-Line-of-Code/tree/main/Chapter3/UIWidgetTest
Q：如何才能让进度条在加载完成后消失呢？
Android控件的可见属性，所有的Android空间都有这个属性，可以通过android:visiablity进行指定。有三种值可选。
visiable：表示控件是可见的，默认值。
invisible：表示控件不可见，但它仍然占据着原来的位置和大小。
gone：表示控件不仅不可见，而且不在占用任何屏幕空间。
布局文件main.xml
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;ProgressBar android:id="@+id/progress_bar" android:layout_width="match_parent" android:layout_height="wrap_content" /&gt; &lt;Button android:id="@+id/button" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="button" android:textAllCaps="false"/&gt; &lt;/LinearLayout&gt; 在java代码中动态改变progressbar的可见性，为了查看值设置为gone时候的效果，把progressbar放在button的上面
@Override public void onClick(View v) { switch (v.getId()) { case R.id.button: if (progressBar.getVisibility() == View.GONE) { progressBar.setVisibility(View.VISIBLE); } else { progressBar.setVisibility(View.GONE); } break; default: break; } } 还可以设置进度条的style，最大值（max）等
每点击一次Button，进度条的进度就会增加10
@Override public void onClick(View v) { switch (v.getId()) { case R.id.button: //获取ProgressBar的进度 int progress = progressBar.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dca54c1afd1bf581421bddde4f7c92f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fb7df20e60c763cd13e594de387cbe4/" rel="bookmark">
			python 实现SOM: 函数更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因作业要求，我在之前的代码（python 实现SOM：代码注释与应用示例）上做了一点修改（增加了几个简单的函数与功能），这里同时对各个函数的功能做一个列表提示。
先创建一个MiniSom的类对象：
som = MiniSom(x,y,input_len,sigma=1.0,learning_rate=0.5,neighborhood_function='gaussian') """ 参数说明（这里只列出了几个常用的参数）： x: 竞争层x维度，int y: 竞争层y维度，int input_len:输入层的向量维度，int sigma: 获胜邻域的初始半径（参数） neighborhood_function： 获胜邻域的计算方式，常用的包括“gaussian”，"bubble"，"mexican_hat"，'triangle'，"winner_take_all"。其中"winner_take_all"模式是我新加的，等价于"bubble"下sigma=1的情况。 """ 常用的函数功能介绍如下：
初始化函数：
不使用以下初始化函数时，网络的自带初始化算法，把权重初始化为[-1,1]之间的小数，​​​​ som.random_weights_init(data):从数据集中随机采样初始化网络权重， som.random_weights_init_random01():（新加）用（0，1）之间的小数初始化权重， som.pca_weights_init(data):用数据集计算PCA提取主分量初始化网络权重，有时更利于收敛 网络训练函数：
som.train(data, num_iteration, random_order=False, verbose=False):用数据集训练网络。 random_order=True : 打乱data中的顺序输入som ​​​​​​​ random_order=False : 按data中的样本顺序输入som som.train_random(data, num_iteration,verbose=False):等价于som.train(data, num_iteration, random_order=True, verbose=False) train_batch(self, data, num_iteration, verbose=False):等价于som.train(data, num_iteration, random_order=False, verbose=False) 网络应用分析函数：
som.get_weights():返回一个张量表示所有神经元的权重，shape=[x,y,input_len],weight[i,j,:]表示网络的第（i,j）位置处的神经元的权重矢量。 som.winner(x): 返回一个坐标，样本x激活的竞争层神经元的坐标。 som.activation_response(data): 返回一个矩阵，统计每个神经元被激活的次数 som.win_map(data, return_indices=False):返回一个字典，反映每个神经元收集到的样本。字典的索引是竞争神经元的坐标，字典的内容是该神经元收集到的数据集样本，当return_indices=True时字典的内容是该神经元收集到的样本在data中的索引。 som.labels_map(data, labels):返回一个双层字典，反映每个神经元收集到的标签种类，及每个标签下的样本个数。 som.get_data_winner_map(data):（新加）返回一个矩阵，反映data中每个样本的神经元激活结果，是一个01矩阵，适用于“winner_take_all”模式。可用于CPN网络。 som.activate(x):返回一个矩阵，描述输入样本x到所有神经元的距离。 源码如下：
from math import sqrt import numpy as np from numpy import (array, unravel_index, nditer, linalg, random, subtract, max, power, exp, pi, zeros, ones, arange, outer, meshgrid, dot, logical_and, mean, std, cov, argsort, linspace, transpose, einsum, prod, nan, sqrt, hstack, diff, argmin, multiply) from numpy import sum as npsum from numpy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fb7df20e60c763cd13e594de387cbe4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dc6866823051f0fffc506bfa1a223de/" rel="bookmark">
			H3C交换机WEB管理时间_带菜鸟起飞-从零开始配置交换机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		此篇为带菜鸟起飞-从零开始配置交换机的第1篇，此类文章主要面向安防行业的项目经理及技术，有配置经验请直接跳过，阅读小编的后面几篇文章。
小编在智能化行业已经有多年的工作经验，知道各位项目经理在综合布线，实施方面都有丰富的经验，但碰到网络就头疼，特别是可网管的交换机，没有web界面的就头疼，小编之前在做工厂物联网的时候，走访过很多大厂的机房，发现很多大厂的机房网管交换机啥都不配，很多功能，都没启用，甚至还有些交换机就放旁边，电都没上，询问之后才知道工厂的技术能力有限，不会配置，现在小编以华三交换机为例，一步一步教大家如何配置，刚好家中有台H3C S3110V2系列交换机给大家做演示。现在跟着小编一起学。
一、计算机如何连接可网管交换机
1、准备材料
①RJ45转串口线一条
②USB转串口
一般笔记本不自带串口哦，所以自备一条，USB转串口的线
③可网管交换机一台
二、安装线缆
1、USB转串口连交换机
USB转串口线一头连接电脑，另外一头RJ45连接交换机，现在交换机管理接口一般都是RJ45。
进设备管理器发现USB没有被识别，需要更新串口驱动
更新驱动后，COM5正常出现了
2、下载SecureCRSecureFXPortable64软件
①打开软件，在软件端口选择COM5,波特率改为9600，去掉RTS/CTS
点击链接。
三、交换机配置
1、连接交换机
普通用户模式
2、进入系统配置
①&lt;H3C&gt;system-view
3、Telnet登录交换机
①如果选择了密码认证，则要配置一个登录密码，并选择密码加密方式，一般推荐密文加密cipher，其他版本还提供了hash算法等加密类型，可以提供相对较高的安全性。然后再配一下通过用户界面登录后的用户级别即可。
[H3C ]interface vlan-interface 1（创建并进入管理VLAN1）
[H3C VLAN 1]ip address 192.168.1.1 255.255.255.0（管理地址）
[H3C ]user-interface vty 0 4（0-4虚拟终端）
[H3C vty0-4]authentication-mode password
[H3C vty0-4]set authentication password cipher 123456（密文密码）
[H3C vty0-4]user privilege level 3（级别3级）
[H3C ui-vty0-4]quit （退出） [H3C 5120]telnet server enable （开启Telnet服务）
②xshell 登录
输入密码 用户系统模式 4、web登录模式
配置命令如下
&lt;h3c&gt;sys (进入系统模式)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6dc6866823051f0fffc506bfa1a223de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bb44d2a403dfc4197134eecbc550db8/" rel="bookmark">
			linux修改文件夹下所有文件的权限（常用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 linux修改文件夹权限 sudo chmod 600 ××× （只有所有者有读和写的权限） sudo chmod 644 ××× （所有者有读和写的权限，组用户只有读的权限） sudo chmod 700 ××× （只有所有者有读和写以及执行的权限） sudo chmod 666 ××× （每个人都有读和写的权限） sudo chmod 777 ××× （每个人都有读和写以及执行的权限） tip:以上方法只能改变单个文件或文件夹
修改文件夹下所有文件的权限 sudo chmod -R 777 filename filename为要修改的文件夹名字。-R应该是表示递归修改filename文件夹下所有文件的权限。
其实整个命令的形式是
sudo chmod -（代表类型）×××（所有者）×××（组用户）×××（其他用户） 三位数的每一位都表示一个用户类型的权限设置。取值是0～7，即二进制的[000]~[111]。
这个三位的二进制数的每一位分别表示读、写、执行权限。
如000表示三项权限均无，而100表示只读。这样，就有了下面的对应：
0 [000] 无任何权限 4 [100] 只读权限 6 [110] 读写权限 7 [111] 读写执行权限 现在看上面的几个常用用法就非常清楚了。试着自己来修改权限吧
查询文件（或文件夹）权限的命令 ls -l 文件名称 （文件夹将-l改为-ld） 为所有者（u）增加脚本执行权限(+v) chmod u+x install_nginx.sh 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/934316ee91626759419000426442ccfa/" rel="bookmark">
			esp8266引脚图及功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		esp8266引脚图及功能
ESP8266特性
*802.11 b/g/n
*内置低功耗32位CPU：可以兼作应用处理器
*内置10 bit高精度ADC
*内置TCP/IP协议栈
*内置TR开关、balun、LNA、功率放大器和匹配网络
*内置PLL、稳压器和电源管理组件
*支持天线分集
*STBC、1x1 MIMO、2x1 MIMO
*A-MPDU、A-MSDU的聚合和0.4 s的保护间隔
*WiFi @ 2.4 GHz，支持 WPA/WPA2 安全模式
*支持STA/AP/STA+AP工作模式
*支持Smart Config功能（包括Android和iOS设备）
*SDIO 2.0、（H） SPI、UART、I2C、I2S、IR Remote Control、PWM、GPIO
*深度睡眠保持电流为10 uA，关断电流小于5 uA
*2 ms之内唤醒、连接并传递数据包
*802.11b模式下+20 dBm的输出功率
*待机状态消耗功率小于1.0 mW （DTIM3）
*工作温度范围：-40°C - 125°C
*通过 FCC， CE， TELEC， WiFi Alliance 及 SRRC 认证
WeMos中定义的arduino引擎编号其实是与ESP8266上的GPIO引擎编号对应.即: 16=D2; 14 = D5/D13; 12 = D6/D12; 13 = D7/D11; 15 = D10; 2 = D9; 4 = D4; 5 = D3; 0 = D8; 这算第一个坑，不过好在 经过测试，这些引脚都可以作为数字引脚输入与输出。难道以后 都要先查表，再通过数字 控制IO口？太不方便了，上网继续找答案，发现原来可以这样操纵 直接用 D0~D13。这样就是与板子上的资源对应了。 继续测试板子，从网上下载了超声波的程序，控制我的超声波模块，一次成功。再测试控制舵机，也是一次搞定。真心话，Arduino控制真的简单，简简单单几句话，超声波模块就能够用了，无论51、STM32都没能这么简单。Arduino不用管时间寄存器，打开串口也是拿来就用。 本以为这样就要一帆风顺了，慢着，还有坑在等我。心理想着 这个板子既然功能这么强大，那么用来控制电机，应该也很好吧！所以我要用他的pwm功能。网上一查，PWM很简单啊，用 用analogWrite(pin, val) pin引脚的编号，传说中只能用 3,5,6,9,10,11 这几条；val 是 0~255 的整数值，对应电压从 0 到+5V。这样对应我这个板子，那就应该是 0~3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/934316ee91626759419000426442ccfa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/533588aa854053a88fc6fb821d68ae51/" rel="bookmark">
			Android DrawerLayout 监听事件简单应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有的书上或者博客上写的是mDrawerLayout.setDrawerListener，不过Android Studio显示该方法已经被弃用，所以我选择了addDrawerListener。
mDrawerLayout.setDrawerListener(new DrawerLayout.SimpleDrawerListener() { @Override public void onDrawerSlide(View drawerView, float slideOffset) { super.onDrawerSlide(drawerView, slideOffset); } @Override public void onDrawerOpened(View drawerView) { super.onDrawerOpened(drawerView); } @Override public void onDrawerClosed(View drawerView) { super.onDrawerClosed(drawerView); } @Override public void onDrawerStateChanged(int newState) { super.onDrawerStateChanged(newState); } }); 声明私有变量
private DrawerLayout mDrawerLayout; private static final String TAG = "StuListActivity"; 核心代码
mDrawerLayout.addDrawerListener(new DrawerLayout.SimpleDrawerListener() { @Override public void onDrawerSlide(View drawerView, float slideOffset) { super.onDrawerSlide(drawerView, slideOffset); /* //在里面可以对侧边栏动态设置TextView等的文本内容 TextView username = (TextView) drawerView.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/533588aa854053a88fc6fb821d68ae51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fab9afe5b762b68aba80265c7c0b8304/" rel="bookmark">
			浏览器怎么扫描二维码_Google Chrome开启二维码功能 可将网页共享到Android版浏览器...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Google Chrome浏览器，已经允许登录用户在设备之间共享标签页，现在Chromium小组正尝试通过“ QR Code”提供另一种方式，将页面共享至Android 版Chrome浏览器，该功能已经可以在Windows，Mac，Linux和Chrome OS的Chrome Canary金丝雀版本当中开启。
用户只需在地址栏当中输入Chrome://flags，在页面上找到名称为“通过二维码启用共享页面”的二维码生成器即可。
如果启用此功能，则在页面的右键菜单上将提供一个新的“为此页面生成二维码”选项，选择该选项，将为页面地址生成二维码，它将与“下载”选项一起显示在地址栏中，以保存到用户设备。
您可以使用Play商店中提供的智能手机相机或QR扫描仪应用程序扫描二维码，并在Android设备上获取页面地址以进行阅读或购物。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aabae7e1db96428a4c480d3cb589f97d/" rel="bookmark">
			c&#43;&#43;有趣的代码_GitHub 又放大招：全方位代码审查神器，你值得拥有！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是小 G。
你是否同我一样，总感觉最近 GitHub 平台风平浪静，没再出啥新花招了？
如果你也这么想，那你就大错特错了！
昨日凌晨，GitHub Services DevOps Engineering 团队正式开源了一个代码库：Super Linter。
当你把这个代码库搭配 GitHub Actions 一同使用后，便可保证代码风格与文档的一致性。如此一来，就能极大降低代码审查成本，顺带提升整个项目的代码质量。
就目前而言，这款插件主要具备以下几项核心功能：
防止将破坏性代码上传到主分支；构建多种语言的编码最佳实践；构建代码布局与代码格式指南；自动化流程，简化代码审查工作。 在代码库宣布开源后的短短一天内，已在知名程序员社区 Hacker News 上引起了广泛讨论，点赞数也成功突破 500：
从代码库的 README 上看，Super Linter 目前已支持 Go、JavaScript、JSON、Markdown、Python3、Ruby 等 18 种编程语言，并将于后续添加更多编程语言的支持：
具体使用方式如下：
在 GitHub Actions 的工作流中添加 Super-Linter 开始感受更稳定、更简洁的代码仓库查看项目的 WiKi 页面了解更多自定义配置 最后，小 G 给大家放上该项目的相关链接，感兴趣的同学可前往查看。
GitHub：
https://github.com/github/super-linter/
官方公告：
https://github.blog/2020-06-18-introducing-github-super-linter-one-linter-to-rule-them-all/ --
文末，照旧安利一波我们的公众号：GitHubDaily，目前每天都会在上面更新至少 3 篇文章，主要分享比较实用或有趣的开发工具与开源项目，偶尔也会聊聊技术圈内最近发生的新鲜事，感兴趣的小伙伴可以关注一下哈。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c309e41500234e082d88cbec8196ffa6/" rel="bookmark">
			CentOS 7 中添加新用户
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、添加新用户1、创建新用户 2、授权1、添加 sudoers 文件可写权限2、修改 sudoers 文件3、收回 sudoers 文件可写权限 3、备注1、Linux 删除用户账号和主目录2、查看文件内容命令 1、添加新用户 创建新用户：useradd -d 指定目录文件夹 -m 新账号名 -c comment	指定一段注释性描述。 -d 目录 指定用户主目录，如果此目录不存在，则同时使用 -m 选项，可以创建主目录。 -g 用户组	指定用户所属的用户组。 -G 用户组,用户组 指定用户所属的附加组。 -s Shell文件 指定用户的登录Shell。 -u 用户号 指定用户的用户号，如果同时有 -o 选项，则可以重复使用其他用户的标识号。 1、创建新用户 Linux 创建新用户，当前用户必须为 root 用户
useradd [用户名] // 默认主文件夹在 `/home` 目录 passwd [用户名]	// 设置用户密码 2、授权 新创建的用户并不能使用 sudo 命令，需要给他添加授权。
1、添加 sudoers 文件可写权限 chmod -v u+w /etc/sudoers 2、修改 sudoers 文件 使用 vim 编辑器打开 sudoers 文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c309e41500234e082d88cbec8196ffa6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62597c8ca5bcb149fdf1158f93276740/" rel="bookmark">
			webapi同时获取到POST参数和GET参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[HttpPost] public object Me(string action) { objPost = System.Web.HttpContext.Current.Request.Form["uid"]; return new {get=action,post=objPost }; } //访问地址:http://localhost:8082/api/me/me.aspx?action=count POST提交为：uid=6 最后还是用到对象
System.Web.HttpContext
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2628ea7a936804234d87e0fd042e6cb/" rel="bookmark">
			【Matlab】牛顿迭代法实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 题目：牛顿迭代法程序1：牛顿迭代法通用函数程序2：求最大Delta程序3：观察结果 题目：牛顿迭代法 程序1：牛顿迭代法通用函数 function [x] = newton(x0,epsilon,f,print_flag) digits(10) % 控制牛顿迭代法的运算精度，精度太大迭代速度过慢 syms x f(x) = f; df(x) = diff(f); count = 0; e = 1; while abs(e) &gt; epsilon x1 = vpa(x0 - f(x0)/df(x0)); e = vpa(x1 -x0); x0 = x1; count = count + 1; if count&gt;100 fprintf('牛顿迭代发散。\n') break end if print_flag fprintf('已迭代 %d 次,', count) fprintf('x为：%f,', x0) fprintf('误差为：%f\n', e) end end if print_flag fprintf('Newton迭代的近似解 x = %f\n',x1) fprintf('迭代次数count = %d\n',count) end x = x0; end 程序2：求最大Delta clc;clear;close all %% 定义方程 syms x f(x) = x^3 / 3 - x %% 寻找delta范围 delta = 0; % delta的绝对值：|delta| step = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2628ea7a936804234d87e0fd042e6cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bda0e0ef0939597b424e4107ae0f76e2/" rel="bookmark">
			#SATA# SATA 实际管脚接线图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 概述实际接线管脚图PATA 接口M.2U.2AHCINVMe 概述 SATA是Serial ATA的缩写，即串行ATA。它是一种电脑总线，主要功能是用作主板和大量存储设备（如硬盘及光盘驱动器）之间的数据传输。这是一种完全不同于并行PATA的新型硬盘接口类型，由于采用串行方式传输数据而得名。SATA总线使用嵌入式时钟信号，具备了更强的纠错能力，与以往相比其最大的区别在于能对传输指令（不仅仅是数据）进行检查，如果发现错误会自动矫正，这在很大程度上提高了数据传输的可靠性。串行接口还具有结构简单、支持热插拔的优点。
2000年11月由“Serial ATA Working Group”团体所制定，SATA已经完全取代旧式PATA（Parallel ATA或旧称IDE）接口的旧式硬盘，因采用串行方式传输数据而得名。在数据传输上这一方面，SATA的速度比以往更加快捷，并支持热插拔，使电脑运作时可以插上或拔除硬件。另一方面，SATA总线使用了嵌入式时钟频率信号，具备了比以往更强的纠错能力，能对传输指令（不仅是数据）进行检查，如果发现错误会自动矫正，提高了数据传输的可靠性。不过，SATA和以往最明显的分别，是用上了较细的排线，有利机箱内部的空气流通，某程度上增加了整个平台的稳定性
现时，SATA分别有SATA 1.5Gbit/s、SATA 3Gbit/s和SATA 6Gbit/s三种规格。未来将有更快速的SATA Express规格。
与并行ATA相比，SATA具有比较大的优势：
首先，Serial ATA以连续串行的方式传送数据，可以在较少的位宽下使用较高的工作频率来提高数据传输的带宽。Serial ATA一次只会传送1位数据，这样能减少SATA接口的针脚数目，使连接电缆数目变少，效率也会更高。实际上，Serial ATA 仅用四支针脚就能完成所有的工作，分别用于连接电缆、连接地线、发送数据和接收数据，同时这样的架构还能降低系统能耗和减小系统复杂性。
其次，Serial ATA的起点更高、发展潜力更大，Serial ATA 1.0定义的数据传输率可达150MB/sec，这比最快的并行ATA(即ATA/133)所能达到133MB/sec的最高数据传输率还高，而在已经发布的Serial ATA 2.0的数据传输率将达到300MB/sec，最终Serial ATA 3.0将实现600MB/sec的最高数据传输率。
实际接线管脚图 PATA 接口 IDE作为非常老牌的传输协议，为计算机能够更轻松的操作硬盘数据起到了非常重要的作用。但是随着计算机对速度的需求，与其配备的传输总线（ATA-133）以及自身的功能都太少了。也渐渐被AHCI与SATA所淘汰。
Tips：实际上，PATA的出现是因为SATA的出现，而为了防止ATA与SATA混淆，所以把ATA改名为PATA。
M.2 U.2 AHCI IDE过低的速度，以及老旧的协议，催生了AHCI传输协议，AHCI相比于IDE，其每次传输传输一个队列中，携带32条指令，同时优化了硬盘队列，通过NCQ技术，使硬盘能够快速顺畅的读取数据而减少磁头移动带来的时间浪费。而与AHCI相匹配的SATA接口，能够提供比ATA总线更高的传输速度。但是，AHCI终究是为了机械硬盘而产生的产物，随着SSD的普及，SSD的高响应速度与读写能力在压榨着传输总线与传输协议的最大速度。因此而诞生了为SSD而生的新协议。
NVMe 如上文所属，为了能够让SSD更好的发挥速度与读写能力。NVMe随之产生。相比于AHCI，NVMe单次提供641024个请求队列，而每个队列达到了641024个请求。远超AHCI单队列32个请求的规模。NVMe可以说完全释放了传输协议的限制，而为了能够与传输协议的速度匹配，使用NVMe的设备都直接连接到了PCIE总线上。更直接的总线为NVMe设备提供绝对强大的传输速度。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f801526c07894fcfb33b7d14a20a2534/" rel="bookmark">
			3.动态规划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3.动态规划 3.1记忆搜索算法 对斐波那契数列进行改进，使用记忆功能来保存已经完成过的计算，当下次需要某个计算时，如果记忆列表中有计算结果，则直接使用。否则进行迭代。
from collections import defaultdict from datetime import datetime total = defaultdict(int) # 存储已经计算好的值 def fib_test(k): # 递归求解第k个数的值 assert k &gt; 0, "k必须大于0" if k in [1, 2]: return 1 global total if k in total: result = total[k] else: result = fib_test(k - 1) + fib_test(k - 2) total[k] = result return result if __name__ == "__main__": # 搜索+记忆 算法 start_time = datetime.now() print("斐波那契数列第50次的结果为：{}".format(fib_test(50))) print("循环耗时:{}".format((datetime.now() - start_time).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f801526c07894fcfb33b7d14a20a2534/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45c09c7e23c4b7fbfb62182bc84f23e4/" rel="bookmark">
			2.回溯法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2回溯法 回溯法是一个求解“全部解”问题的方法。
回溯法是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法。而满足回溯条件的某个状态的点称为“回溯点”。
2.1八皇后问题 第一 分别尝试所有的位置。
第二 可以分别尝试所有的位置，前提条件是这个位置不能和已有的皇后冲突，只能放第二排。
第三 可以分别尝试所有的位置，前提条件是这个位置不能和已有的皇后冲突，只能放第三排。
结束条件：
第八个皇后放完以后。
# 八皇后问题 存储空间 board = [ [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0] ] # 方案数量 total = 0 def can_place(x, y): # 判断(x,y)坐标能否放皇后 # 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45c09c7e23c4b7fbfb62182bc84f23e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e57bf833b9f05c6d572232e33e3df23/" rel="bookmark">
			1.递归
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1递归 什么是递归？递归不是算法，函数内部调用函数本身。
递归一定要终止，怎么写终止条件很重要。
1.1斐波拉契数列 斐波拉契数列又称为黄金分割数列，因为数学家列昂纳多 斐波那契以兔子繁殖为列子而引入，故又称为“兔子数列”。
指的是这样一个数列：1、1、2、3、5、8、13、21、34、…后面的数都等于前面的数的和。
1.2斐波那契数列的计算 递归求解 from collections import defaultdict= total = {} total = defaultdict(int) def fib_test(k): # 递归求解第k个数的值 if k in [1, 2]: return 1 global total total[k] += 1 return fib_test(k - 1) + fib_test(k - 2) if __name__ == "__main__": from datetime import datetime start_time = datetime.now() fib_test(35)# 迭代9227464次 fib_test(34) # 迭代5702886次 # 递归由于重复计算的次数非常多，因此特别耗时 print("递归耗时:{}".format((datetime.now() - start_time).total_seconds())) print(total) 循环求解 def fib_test2(k): # 循环求解第k个数的值 assert k &gt; 0, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e57bf833b9f05c6d572232e33e3df23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f12d2a869a648744471053a5538535fd/" rel="bookmark">
			MySQL的分布式——flask-sqlalchemy实现读写分离
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1、复制1.1 主从架构（一主多从）1.2 主备架构1.3 高可用复合架构 2、flask-sqlalchemy实现读写分离3、分片3.1 垂直拆分3.1.1 垂直分表3.1.2 垂直分库 3.2 水平拆分3.2.1 水平分表 4、分布式的问题4.1 分布式事物问题解决方案4.2 解决跨节点 Join/排序/分页 1、复制 作用：
对数据进行备份，实现高可用HA通过读写分离，提高吞吐量，实现高性能 原理：
当主库中有数据更新时，主库会将该操作写入一个二进制日志文件中，从库中专门有一个io线程去读取主库的二进制文件的内容，但不会立即写入从库，而是将它写入一个延后中继日志文件，然后再通过SQL线程，重做中继日志文件中的数据修改的操作，保存到从库中去，从而完成主库和从库的数据同步。 1.1 主从架构（一主多从） 读写分离，提高吞吐量 主库只有一台，一旦挂了，无法写入，所以主库并没有实现高可用 从库实现了高可用 1.2 主备架构 单库读写，没有实现读写分离, 性能一般 高可用, 一旦主库挂了, 就启用备库 这种方案被阿里云、美团等企业广泛使用 问题: 既然主备互为备份, 为什么不采用双主方案, 提供两台主进行负载均衡?
原因是：为了避免数据的冲突，防止造成数据的不一致性。 虽然在两边执行的修改有先后顺序，但由于 Replication 是异步的实现机制，同样可能会导致 晚做的修改被早做的修改所覆盖
1.3 高可用复合架构 相当于优化前面两个方案
读写分离, 提高吞吐量 高可用, 一旦主库挂了, 就启用备库，主从库都实现了高可用 2、flask-sqlalchemy实现读写分离 sqlalchemy 并没有像 django-orm 一样内置完善的读写分离方案, 但是提供了可以自定义的接口: 官方文档, 我们可以借此对 flask-sqlalchemy 进行二次开发, 实现读写分离
基本实现思路:
实现自定义的 session类, 继承 SignallingSession类重写 get_bind方法, 根据读写需求选择对应的数据库地址实现自定义的 SQLAlchemy类, 继承 SQLAlchemy类重写 create_session方法, 在内部使用自定义的 Session类 环境准备：搭建好两台数据库，1个主、2个从数据库
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f12d2a869a648744471053a5538535fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6eb82be2fb762e6e3a1becc71ffe04d/" rel="bookmark">
			statsmodels.tsa.arima.model.ARIMA用户手册（中文）（statsmodels包）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0. 前言 class statsmodels.tsa.arima.model.ARIMA(endog, exog=None, order=0, 0, 0, seasonal_order=0, 0, 0, 0, trend=None, enforce_stationarity=True, enforce_invertibility=True, concentrate_scale=False, trend_offset=1, dates=None, freq=None, missing='none', validate_specification=True) 源码source
自回归综合移动平均值（ARIMA）模型和扩展
该模型是ARIMA型模型（包括具有外生回归变量的模型和具有季节性成分的模型）的基本接口。 模型的最一般形式是 S A R I M A X （ p ， d ， q ） x （ P ， D ， Q ， s ） SARIMAX（p，d，q）x（P，D，Q，s） SARIMAX（p，d，q）x（P，D，Q，s）。 它还允许所有特殊情况，包括:
autoregressive models（自回归模型）: AR( p )
moving average models（移动平均模型）: MA(q)
mixed autoregressive moving average models（混合自回归移动平均模型）: ARMA(p, q)
integration models（整合模型）: ARIMA(p, d, q)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6eb82be2fb762e6e3a1becc71ffe04d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcd5d15d54ca06bb704cd5d60f6ed71b/" rel="bookmark">
			H3C SS5500 交换机配置操作记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		交换机Port1 vlan1 上联华三网关，port4 5 vlan100 被镜像到 port9，dhcp 服务器，可接电脑或者AP。
&lt;H3C&gt;system-view
#配置DHCP 服务器
1)创建V100
dhcp server ip-pool vlan100
network 172.16.100.0 mask 255.255.255.0
gateway-list 172.16.100.1 dns-list 114.114.114.114
expired day 8
dhcp enable
2)创建V100
vlan 100
qu
interface Vlan-interface 100
ip address 172.16.100.1 255.255.255.0 #配置vlan100 网关和掩码：注意要和dhcp网关配置一致，否则网络也不通
3) 无标题
qu
dhcp server forbidden-ip 172.16.100.1 172.16.100.100 interface range GigabitEthernet 1/0/4 to GigabitEthernet 1/0/5 port access vlan 100
dis vlan 100 查看
4)保留交换机的第1个口做为连接到路由器的口，把他配置到默认的vlan1中
[H3C]dis vlan 1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcd5d15d54ca06bb704cd5d60f6ed71b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e4cc8e62fd63f439827dc578428d4cb/" rel="bookmark">
			爬虫基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		爬虫的基本原理：
可以把互联网比作一张大网，而爬虫（即网络爬虫） 便是在网上爬行的蜘蛛。 把网的节点比作一个个网页， 爬虫爬到这就相当于访问了该页面，获取了其信息 。可以把节点间的连线比作网页与网页之间的链接关系， 蜘蛛通过一个节点后，可以顺着节点连线继续爬行到达 下一个节点，即通过一个网页继续获取后续的网页，这 样整个网的节点便可以被蜘蛛全部爬行到，网站的数据 就可以被抓取下来了 。互联网上的WEB页面可以抽象化为一张有向图。图的遍历就是用来解决节点的 访问顺序问题。图的遍历算法有两种，即深度优先算法DFS和宽度优先算法BFS。
爬虫的概念：
网络爬虫(Spider)是一种程序，它的主要目的是将互联网上的网页下载到本地 并提取出相关数据。网络爬虫可以自动化的浏览网络中的信息，然后根据我们制 定的规则下载和提取信息。网络爬虫就像一只蜘蛛一样在互联网上沿着URL的丝线爬行，下载每一个URL所指向的网页，分析页面内容。
危害：
性能骚扰 ：
Web服务器默认接收人 类访问，而受限于编写水平 和目的，网络爬虫将会为 Web服务器带来巨大的资源 开销。
法律风险 ：
服务器上的数据有产 权归属，而网络爬虫获取 数据后牟利将带来法律风 险。隐私泄露 ：
网络爬虫可能具备突 破简单访问控制的能力， 获得被保护数据从而泄露 个人隐私
爬虫的应用
动态网页与静态网页
robots协议的定义及如何查看某个网站的bobots协议
robots.txt是一个存放在网站根目录下的ASCII编码的文本文件。爬虫在爬网站之 前，需要首先访问并获取这个robots.txt文件的内容，这个文件里面的内容会告 诉爬虫哪些数据是可以爬取的，哪些数据是不可以爬取的。  要查看一个网站的robots.txt，只需要访问“网站域名。
urlib库中的robotparser模块提供了一个类RobotFileParser解析网站的robots.txt文 件来判断一个爬取爬虫是否有权限来爬取这个网页。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72907b593f73f13382daf324a148abb2/" rel="bookmark">
			python赶集网bs4爬取内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 下面展示一些 内联代码片。
// A code block var foo = 'bar'; // An highlighted block import requests,csv from bs4 import BeautifulSoup list=[] herders={"User-Agent":"Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Mobile Safari/537.36" } url="http://bj.ganji.com/zufang/f4/pnl/" r=requests.get(url,headers=herders).text soup=BeautifulSoup(r,'lxml') div=soup.find('div',class_='f-list js-tips-list').find_all("dl",class_="f-list-item-wrap min-line-height f-clear") for i in div: name=i.find("dd",class_="dd-item title").a.string struct=i.find("dd",class_="dd-item size").span.text price=i.find("dd",class_="dd-item info").find("span",class_="num").string list.append([name,struct,price]) with open("赶集网.csv","w+",encoding="utf-8",newline="") as f: w=csv.writer(f) w.writerows(list) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35d9b2c87cde41cd4cc4eb9bd01fcb51/" rel="bookmark">
			四元数　右手坐标系　转　左手坐标系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先记录一个结果，下次来补上推导过程
假定右手系下的四元数为：RQ=(w, x, y, z)
那么RQ在左手坐标系下的表示为：
１.当X轴朝向取反
LQ=(w, x, -y, -z)
2.当Y轴朝向取反
LQ=(w, -x, y, -z)
3.当Z轴朝向取反
LQ=(w, -x, -y, z)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6abd9bae5887e62dda4a35692164c84e/" rel="bookmark">
			Java中thread.yield()方法的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java中thread.yield()方法的使用
​ Java线程开启是使用star()方法，启动线程，让线程变成就绪状态等待 CPU 调度后执行。而thread.yield()方法则是使当前线程由执行状态，变成为就绪状态，让出cpu时间，在下一个线程执行时候，此线程有可能被执行，也有可能没有被执行。我们做一个测试的例子
一、YieldTest.java代码 class ThreadA extends Thread{ public ThreadA(String name){ super(name); } public void run(){ for(int i=0; i &lt;10; i++){ System.out.printf("%s [%d]:%d\n", this.getName(), this.getPriority(), i); // i整除9时，调用yield if (i % 9 == 0) Thread.yield(); } } } public class YieldTest{ public static void main(String[] args){ ThreadA t1 = new ThreadA("t1"); ThreadA t2 = new ThreadA("t2"); t1.start(); t2.start(); } } 运行结果：
t2 [5]:0 t1 [5]:0 t2 [5]:1 t2 [5]:2 t2 [5]:3 t2 [5]:4 t2 [5]:5 t2 [5]:6 t2 [5]:7 t2 [5]:8 t2 [5]:9 t1 [5]:1 t1 [5]:2 t1 [5]:3 t1 [5]:4 t1 [5]:5 t1 [5]:6 t1 [5]:7 t1 [5]:8 t1 [5]:9 我们可以看到首先运行的的是t2 [5]:0。如果改为整除5的话，在运行至输出t1 [5]:5的时候也没有转到其他。yield()虽然可以让线程由“运行状态”进入到“就绪状态”；但是，它不一定会让其它线程获取CPU执行权(即，其它线程进入到“运行状态”)，即使这个“其它线程”与当前调用yield()的线程具有相同的优先级。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6abd9bae5887e62dda4a35692164c84e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e667795d2b2e35f2a43d9bd0293452f7/" rel="bookmark">
			AcWing | 【DFS】排列数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目内容
给定一个整数n，将数字1~n排成一排，将会有很多种排列方法。
现在，请你按照字典序将所有的排列方法输出。
输入格式
共一行，包含一个整数n。
输出格式
按字典序输出所有排列方案，每个方案占一行。
数据范围
1≤n≤7
输入样例：
3 输出样例：
1 2 3 1 3 2 2 1 3 2 3 1 3 1 2 3 2 1 思路：
题目要求输出数组的全排列，核心是考虑清楚以什么样的顺序搜索最方便：
注意需要回溯，以保证下一次搜的时候是按最原始的时候搜的。 完整代码：
#include&lt;iostream&gt; using namespace std; const int N=10; int n; int path[N];//用来存路径 bool st[N];//用来存状态 是否被用过 void dfs(int u){ if(u==n){//如果已经全部遍历完了 就直接输出路径即可，u相当于树的层数 for(int i=0;i&lt;n;i++)printf("%d ",path[i]); puts(" "); return; } for(int i=1;i&lt;=n;i++){ if(!st[i]){//如果i没被用过 就用一下他 path[u]=i;//把路径记录下来 st[i]=true;//修改状态表示已经被用过了 dfs(u+1);//递归下一位 st[i]=false;//回溯 恢复现场 } } } int main(){ cin&gt;&gt;n; dfs(0); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c59dfd116f353dae21d7f9105fe6dd69/" rel="bookmark">
			modbusrtu master_Modbus TCP和Modbus RTU协议的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Modbus协议包括ASCII、RTU、TCP等，并没有规定物理层。此协议定义了控制器能够认识和使用的消息结构，而不管它们是经过何种网络进行通信的。标准的Modicon控制器使用RS232C实现串行的Modbus。Modbus的ASCII、RTU协议规定了消息、数据的结构、命令和就答的方式，数据通讯采用Maser/Slave方式，Master端发出数据请求消息，Slave端接收到正确消息后就可以发送数据到Master端以响应请求;Master端也可以直接发消息修改Slave端的数据，实现双向读写。
Modbus具有以下几个特点：
(1)标准、开放，用户可以免费、放心地使用Modbus协议，不需要交纳许可证费，也不会侵犯知识产权。目前，支持Modbus的厂家超过400家，支持Modbus的产品超过600种。 (2)Modbus可以支持多种电气接口，如RS-232、RS-485等，还可以在各种介质上传送，如双绞线、光纤、无线等。 (3)Modbus的帧格式简单、紧凑，通俗易懂。用户使用容易，厂商开发简单。 Modbus rtu和Modbus tcp两个协议的本质都是MODBUS协议，都是靠MODBUS寄存器地址来交换数据;但所用的硬件接口不一样，Modbus RTU一般采用串口RS232C或RS485/422，而Modbus TCP一般采用以太网口。现在市场上有很多协议转换器，可以轻松的将这些不同的协议相互转换。 实际上Modbus协议包括ASCII、RTU、TCP。 标准的Modicon控制器使用RS232C实现串行的Modbus。Modbus的ASCII、RTU协议规定了消息、数据的结构、命令和就答的方式，数据通讯采用Maser/Slave方式。 Modbus协议需要对数据进行校验，串行协议中除有奇偶校验外，ASCII模式采用LRC校验，RTU模式采用16位CRC校验。 ModbusTCP模式没有额外规定校验，因为TCP协议是一个面向连接的可靠协议。 TCP和RTU协议非常类似，只要把RTU协议的两个字节的校验码去掉，然后在RTU协议的开始加上5个0和一个6并通过TCP/IP网络协议发送出去即可。
Modbus TCP和Modbus RTU协议的区别​www.alotcer.com 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a50b717123a6753dcb8ebe9a3e3803a5/" rel="bookmark">
			G1调优实践日记--G1HeapWastePercent和InitiatingHeapOccupancyPercent的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 最近有个算文本相似度的需求，当然这算法copy过来没做过什么验证就直接上线了，然后应用程序莫名就开始OOM，然后进程直接被kill掉，当然一开始我没想起来是这段算法代码的锅，我把java_pid18776.hprof文件down下来先用jprofiler研究了一番，居然发现没有什么大对象，然后我以为是其它原因，比如kafka消费量大导致的问题，然后去折腾jvm参数。直接导致我因为没有找到根本原因白白浪费时间。但是有失必有得，这次我也了解了G1的一些有用的调优参数，帮助我后期更了解G1
顺便抱怨一句，下图是jhat和jprofiler加载同一个堆文件，jhat直接告诉了OOM的根本原因，而jprofiler直接没有关键信息，不知道是不是软件bug。
G1HeapWastePercent和InitiatingHeapOccupancyPercent 当然，这篇文章的重点是两个参数的介绍。这里推荐先看看oracle对G1的官方说明。理解g1的基本原理，对调优参数的使用会有帮助
Getting Started with the G1 Garbage Collector
G1跟之前的垃圾回收器一样，只是它在老年代回收垃圾时更复杂一点，官方对在老年代的回收整体上称为Concurrent Marking Cycle Phases(并发标记周期阶段)，而具体每个阶段做了什么可以详细看官方的说明。
而 Concurrent Marking Cycle Phases 带来的总结说明文档也有写。大致就是
可以同时回收年轻代和老年代。在标记阶段是并发执行(没有STW),重新标记阶段比CMS效率更高。 而今天我们介绍的两个参数就是在调Concurrent Marking Cycle Phases。
首先第一个是 XX:InitiatingHeapOccupancyPercent
-XX:InitiatingHeapOccupancyPercent=45 - Percentage of the (entire) heap occupancy to start a concurrent GC cycle. It is used by G1 to trigger a concurrent GC cycle based on the occupancy of the entire heap, not just one of the generations. A value of 0 denotes ‘do constant GC cycles’.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a50b717123a6753dcb8ebe9a3e3803a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b3fe3a2307aebc6ac062bd87d096075/" rel="bookmark">
			Linux 安装 MySQL8.0.11
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、安装 MySQL 1、下图是需要安装的 rpm
2、切换目录到安装目录，我选择的是 /home/ 目录，进行安装（注意先后次序，不然可能会报错）
安装 mysql-community-common-8.0.11-1.el7.x86_64.rpm （一般不会报错） [root@VM-0-16-centos home]# rpm -ivh ./resources/mysql8/mysql-community-common-8.0.11-1.el7.x86_64.rpm warning: ./resources/mysql8/mysql-community-common-8.0.11-1.el7.x86_64.rpm: Header V3 DSA/SHA1 Signature, key ID 5072e1f5: NOKEY Preparing... ################################# [100%] Updating / installing... 1:mysql-community-common-8.0.11-1.e################################# [100%] 安装 mysql-community-libs-8.0.11-1.el7.x86_64.rpm （如果已经存在依赖，会报错） 报错问题
[root@VM-0-16-centos home]# rpm -ivh ./resources/mysql8/mysql-community-libs-8.0.11-1.el7.x86_64.rpm warning: ./resources/mysql8/mysql-community-libs-8.0.11-1.el7.x86_64.rpm: Header V3 DSA/SHA1 Signature, key ID 5072e1f5: NOKEY error: Failed dependencies: mariadb-libs is obsoleted by mysql-community-libs-8.0.11-1.el7.x86_64 解决办法
运行 yum remove mysql-libs，清除之前安装过的依赖，再次安装即可。
[root@VM-0-16-centos home]# rpm -ivh .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b3fe3a2307aebc6ac062bd87d096075/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2fc5084a493e3d0c652eb2abfe5e988/" rel="bookmark">
			解决linux终端按退格键无法回退的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题： 在下载某些依赖或者安装包后发现终端乱序，输入命令时按退格键不能回退反而向后加空格；并且某些快捷键无法使用等问题；
原因 终端依赖的包ncurses-base被删除；
解决办法 终端输入：
sudo apt install ncurses-base 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef348d035111237dcd2f322c452394b6/" rel="bookmark">
			gcc: error: unrecognized command line option ‘-std=c&#43;&#43;14’  问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题描述： 安装一些python包(实际场景为py3安装infomap)时报错：gcc: error: unrecognized command line option ‘-std=c++14’ 环境 centos版本：CentOS Linux release 7.6.1810 (Core)
gcc版本：gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-39)
g++版本：g++ (GCC) 4.8.5 20150623 (Red Hat 4.8.5-39)
解决方案 升级gcc版本为5.2.0
升级g++版本为5.2.0
实施步骤 cd /usr/local/src # 下载gcc5.2.0源码 wget http://ftp.gnu.org/gnu/gcc/gcc-5.2.0/gcc-5.2.0.tar.bz2 tar -jxvf gcc-5.2.0.tar.bz2 # 进入gcc目录安装 cd gcc-5.2.0 # 下载某些依赖包 ./contrib/download_prerequisites # 创建bulid文件夹 mkdir build cd build ../configure --prefix=/usr/local/gcc --enable-languages=c,c++ --disable-multilib # 编译安装,此过程耗时较长 make &amp;&amp; make install # 修改软连接 mv /usr/bin/gcc /usr/bin/gcc_bak ln -s /usr/local/gcc/bin/gcc /usr/bin/gcc mv /usr/bin/g++ /usr/bin/g++_bak ln -s /usr/local/gcc/bin/g++ /usr/bin/g++ # 查看升级后版本 gcc --verson g++ --version 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/139b9a32c44ebb4b76835cbe0b629af2/" rel="bookmark">
			Dear PyGui 学习中遇到的坑（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近两天看见Dear PyGui挺好玩的，就先上手来试一下，中间遇到一些坑，先来记录一下。
好像这个库使用者目前还不多，遇到的问题很难搜索到解决方案。
根据官方教程，在进行到“Value &amp; Data Storage”这一部分的时候，遇到了怪异现象，给大家一起分享一下。
完整代码：
from dearpygui.core import * from dearpygui.simple import * add_additional_font('仿宋_GB2312.ttf', 18, glyph_ranges='chinese_simplified_common') def print_me(sendar, data): log_debug(f"单选框数值: {get_value('value_1')}") log_debug(f"文本数值: {get_value('value 2')}") log_debug(f"颜色数值: {get_value('color4')}") def reset(sender, data): set_value("value_1", False) set_value("value 2", "你好！") show_logger() with window('数值测试'): add_checkbox("单选1", source="value_1") add_checkbox("单选2", source="value_1") add_input_text("输入框1", source="value 2") add_input_text("文本输入框2", source="value 2", password=True, tip="输入内容将作为密码使用！") add_button("打印源数值", callback=print_me) add_button("重置源数值", callback=reset) add_value("color4", (0.0, 0.0, 0.0, 0.0)) add_color_edit3("RGB颜色选择 3", source="color4") add_color_edit4("RGBA颜色选择 4", source="color4") start_dearpygui() 先上一张截图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/139b9a32c44ebb4b76835cbe0b629af2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d055594eab4c38f0707c7b0fe031f6b/" rel="bookmark">
			idea 的MAVEN Lifecycle 基本用法  包括 install package
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考链接 1.clean
用于清除之前构建生成的所有文件
其中具体为清楚了Target目录中的所有文件，包括该目录
i.e：删除了install生成的所有文件
2.validate
用于验证项目是否真确，并且其说有必要信息是否都可用
3.compile
编译项目的源代码，主要是java文件
一般是编译scr/main/java或是scr/test/java里面的文件
4.test
用合适的测试框架来进行测试，测试compile中编译出来的代码
测试的东西一般不加包和部署
5.packaging
获取compile中编译好的代码并将其打包成可分类的格式，i.e:JAR
6.vertify
这步是用来验证test
检查test的结果是否满足标准
7.install
将软件包安装到本地存储库中
确保本地其他项目可能需要使用他（eg:装了core才能用oms）
9.deploy
复制最终的包至远程仓库
共享给其它开发人员和项目
PS:在install的时候可能会出现乱码，此时对着install点右键，选择create xxx install
在command line里写 install -Dmaven.test.skip=true -f pom.xml 然后用新写的命令代替旧的install即可 plugin
帮组分析项目依赖
依赖就是在maven里面要用哪个包就在标签里面写东西
一般不用自己写
可以在google里面搜索“maven xxx repository”
或者直接在http://mvnrepository.com/里面搜索xxx
将资源文件过滤 resources用来处理资源
compiler用来编译java文件
快速在web上部署 进行调试的时候比较方便和节省时间
可以分为 全局配置：为全局有效
配置：为针对不同的profile配置
build里面有和两种标签
他们都是把一些默认方法放在其他文件路径的文件放到“src/main/java”里面
打包方式主要有JAR和WAR两种 其中JAR用于比较小的项目，好处为不用依赖包，因为他把应用依赖的所有依赖包和程序打包在一个全量包里，他说packaging的默认方式
WAR适用于需要部署的项目
适用范围主要分为test和provided两种 test对测试范围有效
provided对编译和测试过程都有效
PS：
1.匹配符**可以匹配路径，*只能匹配名字
2.如果启动失败先看错误信息
3.jetty：run要create一个再运行，不用直接运行，因为直接运行可能会调用到了其他人的profiles
4.运行maven之前先看一块profile的配置环境有没有勾选错别人的环境
这辈子坚持与不坚持都不可怕,怕的是独自走在坚持的道路上！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0c4de4196973ca2042cdd9e1990055d/" rel="bookmark">
			JS的 typeof 与 instanceof 的判断范围详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们都知道JS是一门弱类型语言，变量可以通过var、let或const声明任意类型，在执行程序时，我们可以通过 typeof 与 instanceof用于判断变量数据的类型，便于进一步操作数据，那它们两个判断类型都是有限制的，只能判断某一类，下面我们会明确区分它们的判断类型。
JS有五种基本数据类型：
nullundefinednumberbooleanstring 三种复杂类型：
Object（任意对象）Function（一种可以执行的特殊对象）Array（一种数值类型的下标的特殊对象） 注意：函数和数组也是对象。
1.typeof的判断范围
可判断：undefined、数值、字符串、布尔值、function
不可判断：null与object、array与object
可判断举例：
let name = undefined let age = 18 let sex = '男' let func = function () {} let checked = true console.log(typeof name === 'undefined') console.log(typeof age === 'number') console.log(typeof sex === 'string') console.log(typeof func === 'function') console.log(typeof checked === 'boolean') 上面举例了typeof可以判断的五种类型，除了这五种就超出了 typeof 的能力。
不可判断举例：
举例一：不可判断null与object
var obj = null var obj1 = { name: '鸭绒', } console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0c4de4196973ca2042cdd9e1990055d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7703f28755eeff21b2e8aae64f1fb742/" rel="bookmark">
			Vue中的响应式处理（源码解读）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 响应式处理入口Observer类defineReactive（响应式处理）依赖收集数组的响应式处理过程派发更新dep.notify总结 响应式处理入口 Observer函数定义在src/core/observer/index.js中，首先，我们来看一下这个函数的源码：
export function observe (value: any, asRootData: ?boolean): Observer | void { // 判断value是否是对象 if (!isObject(value) || value instanceof VNode) { // 如果不是一个对象或者是vNode的一个实例，则直接返回，不需要做响应式处理 return } let ob: Observer | void if (hasOwn(value, '__ob__') &amp;&amp; value.__ob__ instanceof Observer) { // 如果value有__ob__（observer对象）属性，则令ob为value.__ob__，并返回ob ob = value.__ob__ } else if ( shouldObserve &amp;&amp; !isServerRendering() &amp;&amp; (Array.isArray(value) || isPlainObject(value)) &amp;&amp; Object.isExtensible(value) &amp;&amp; !value._isVue ) { // 创建一个Observer对象 ob = new Observer(value) } // 如果是根数据 if (asRootData &amp;&amp; ob) { ob.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7703f28755eeff21b2e8aae64f1fb742/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5200d51d94ac133cdc0bb09ca1e7b27d/" rel="bookmark">
			软件 获取mp3毫秒_网易云歌曲Mp3直链解析软件，复制地址便可下载音乐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网易云歌曲Mp3直链解析软件是一款由吾爱网友针对网易云音乐打造的MP3歌曲解析工具，软件可以帮助用户对网易云音乐的直链进行解析，用户只需输入歌曲或歌手便可快速获取歌曲的信息并且得到歌曲直链地址，大家可以使用这个地址进行歌曲的播放和下载操作，非常方便，有需要的伙伴们请私信软件名+邮箱号，登录电脑后会在同个时间内为大家统一发送的!
网易云歌曲Mp3直链解析软件使用说明：
1.下载解压，双击网易云歌曲Mp3直链解析软件.exe进入软件使用界面
网易云歌曲Mp3直链解析软件
2.输入歌手名称或歌曲名称，点击查询
网易云歌曲Mp3直链解析软件
3.右键点击想要下载的歌曲，此时显示功能，可以复制歌曲名、艺术家、专曲名、歌曲ID、直链地址，我们选择直链地址
网易云歌曲Mp3直链解析软件
4.将复制的链接到粘贴到浏览器(或迅雷、百度云)上
网易云歌曲Mp3直链解析软件
5.点击下载的图标，会弹出下载提示，点击下载即可
网易云歌曲Mp3直链解析软件
6.下载完成后就可以自行保存和播放自己喜欢的音乐啦
网易云歌曲Mp3直链解析软件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c17e4df5c61614057ba75e9887558521/" rel="bookmark">
			MongoDB数据插入、删除、更新、批量更新某个字段
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		批量更新某个字段 例1：
db.getCollection('bond_sentiment_news').find({"source" : 2,"siteUrl" : "http://www.21jingji.com/"}).forEach( function(item){ db.getCollection('bond_sentiment_news').update({"_id":item._id},{$set:{"siteName":"21经济网"}}) } ) 例2：
db.getCollection('my_booking').find({"hospitalName":/xx医院/,openId:/^2/}).forEach( function(item){ db.getCollection('my_booking').update({"_id":item._id},{$set:{"payType": "1"}}) } ) 查询出hospitalName是xx医院和openId以2开头的所有记录，并且更新my_booking表中的payType为1.
例3：
db.getCollection('my_booking').find({"hospitalName":/运城市中心医院/,openId:{$not:/^2/}}).forEach( function(item){ db.getCollection('my_booking').update({"_id":item._id},{$set:{"outTradeNo1": item.outTradeNo2}}) } ) 查询出xx医院和不已2开头的openId的所有记录，并且将每条记录的outTradeNo2赋值给outTradeNo1.
1. MongoDB数据插入 MongoDB插入文档 // 插入语法 db.[collectionName].insert({}) // example db.sample.insert({name:"mongo"}) sample结果： 2. 批量插入文档 shell 这样执行是错误的 db.[collectionName].insert([{},{},{},……..]),这样仅可以插入第一条数据。 如图： shell 不支持批量插入 想完成批量插入可以用MongoDB的应用驱动或是shell的for循环 3.Save操作 save操作和insert操作区别在于当遇到_id相同的情况下 save完成保存操作 insert则会报错 如图： 2. MongoDB数据删除 删除列表中所有数据 db.[collectionName].remove({}) 集合的本身和索引不会被删除根据条件删除数据 db.[collectionName].remove({key:value}) 删除集合sample中name等于c的纪录
db.sample.remove({name:"c"}) 3.小技巧 如果你想清除一个数据量十分庞大的集合直接删除该集合并且重新建立索引的办法比直接用remove的效率会高很多
3. MongoDB数据更新 强硬的文档替换式更新操作 // 语法 db.[collectionName].update({查询器},{修改器}) 此种文档更新方式，会用新的文档代替老的文档，因此要明确是否是真的符合自己的需求。 强硬的更新会用新的文档代替老的文档 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c17e4df5c61614057ba75e9887558521/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40320574fd4968734656f83876775b92/" rel="bookmark">
			割点（tarjan算法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 割点(无向图).总结：割点算法实现模拟题解思考再来一题 割点(无向图). P3388 【模板】割点（割顶）题目链接:洛谷
tarjan遍历过程视频链接
总结： 1.图用dfs的遍历。dfs对图，就会形成树 (写dfs代码时刻要有"栈"的思想)
2.Tarjan算法求非强连通图，主要用到了两个数组，dfn和low数组。
3.在dfs中如何加东西：
dfs（i）后面语句怎么写？每次dfs完成后，就是对前面的影响，
像栈一样。
4.无向图实际是 在无向树的基础上节点添加边。
连通图定义：
在无向图中，一个连通图中任意两点均可到达，称为连通图。
割点的定义：
在一个无向图里，去掉一个顶点，及其去掉该点的所有边,剩下的图
不连通，那么这个点就是个割点。
割边的定义： （不会不会，以后再补 。）
在一个无向图里，去掉一条边，图就不连通了。
举个栗子：下图的无向图的割点为：0,3。
割点算法实现模拟 ps：以下两图来自上文视频链接截下来的图。
在下图 上面数字dfn数组，下面数字low数组。
用了一个栈更好理解。
其中满足low[u]=dfn[u]，退栈到u.
dfn中是时间戳是，1-2-3-4
然后回退到2 ， 2-5
再回退到1， 1到6.
最后回退到1.结束。
强连通分量怎么就有了呢?
在退栈2时，进栈5，判断1时，low[5]=dfn[1];
之后在5中退出。
有个5-1，形成了一个1-2-5-1的环，这不就成了一个强连通分量了。
之后就是这么执行。
下面图举例（方便理解后续的代码）： 我画成树的样子，再在节点随意连，就成了无向图。
1号是该的根节点 ：那么子节点是两个， 就不是三个了？
为什么呢？
原因是： 我们在遍历的时候深度搜索，搜到3时，3就搜到4,4被标记了，退回到1节点，4节点已经标记了，1节点就不会对4搜。
所以1节点的子节点是2个。
所以只要根节点的子节点有两个及以上，根节点就是割点。（这里的子节点要细心些）。
题解 样例输入：
上图。
题解代码如下
代码如下：
割点针对无向图！！
#include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;set&gt; using namespace std; int read(){ int s = 0, f = 1; char ch = getchar(); while(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40320574fd4968734656f83876775b92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9302fba7d8065e7140d9df85a94fa5f9/" rel="bookmark">
			常见的异常与分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 NO.1 Java.alng.NullPointerException 这个异常大家肯定都经常遇到，异常的解释是 “程序遇上了空指针 “，简单地说就是调用了未经初始化的对象或者是不存在的对象，这个错误经常出现在创建图片，调用数组这些操作中，比如图片未经初始化，或者图片创建时的路径错误等等。对数组操作中出现空指针，很多情况下是一些刚开始学习编程的朋友常犯的错误，即把数组的初始化和数组元素的初始化混淆起来了。数组的初始化是对数组分配需要的空间，而初始化后的数组，其中的元素并没有实例化， 依然是空的，所以还需要对每个元素都进行初始化（如果要调用的话）。 在jsp编程中经常出现：if (request.getParameter(“username”).equals(“xxx”))、out.println(session.getAttribute(“record”))等。解决这个问题的方法是在使用前进行判空比较： if (request.getParameter(“username”)!=null) {if if (request.getParameter(“username”). equals(“xxx”))…} NO.2　java.lang.ClassNotFoundException 这个异常是很多原本在JB等开发环境中开发的程序员，把JB下的程序包放在WTk下编译经常出现的问题，异常的解释是 “指定的类不存在 “，这里主要考虑一下类的名称和路径是否正确即可，如果是在JB下做的程序包，一般都是默认加上Package的，所以转到WTK下后要注意把Package的路径加上。 NO.3　java.lang.ArithmeticException 这个异常的解释是 “数学运算异常 “，比如程序中出现(1/0)除以零这样的运算就会出这样的异常，对这种异常，大家就要好好检查一下自己程序中涉及到数学运算的地方，公式是不是有不妥了。 NO.4　java.lang.ArrayIndexOutOfBoundsException 这个异常相信很多朋友也经常遇到过，异常的解释是 “数组下标越界 “，现在程序中大多都有对数组的操作，因此在调用数组的时候一定要认真检查，看自己调用的下标是不是超出了数组的范围，一般来说，显示（即直接用常数当下标）调用不太容易出这样的错，但隐式（即用变量表示下标）调用就经常出错了，还有一种情况，是程序中定义的数组的长度是通过某些特定方法决定的，不是事先声明的，这个时候，最好先查看一下数组的length，以免出现这个异常 NO.5　java.lang.IllegalArgumentException 这个异常的解释是 “方法的参数错误 “，很多J2ME的类库中的方法在一些情况下都会引发这样的错误，比如音量调节方法中的音量参数如果写成负数就会出现这个异常，再比如g.setColor(int red,int green,int blue)这个方法中的三个值，如果有超过２５５的也会出现这个异常，因此一旦发现这个异常，我们要做的，就是赶紧去检查一下方法调用中的参数传递是不是出现了错误。 NO.6　java.lang.IllegalAccessException 这个异常的解释是 “没有访问权限 “，当应用程序要调用一个类，但当前的方法即没有对该类的访问权限便会出现这个异常。对程序中用了Package的情况下要注意这个异常。 NO.7　java.lang.IncompatibleClassChangeError 不兼容的类变化错误。当正在执行的方法所依赖的类定义发生了不兼容的改变时，抛出该异常。一般在修改了应用中的某些类的声明定义而没有对整个应用重新编译而直接运行的情况下，容易引发该错误。 NO.8　java.lang.InstantiationError 实例化错误。当一个应用试图通过Java的new操作符构造一个抽象类或者接口时抛出该异常。 NO.9　java.lang.LinkageError 链接错误。该错误及其所有子类指示某个类依赖于另外一些类，在该类编译之后，被依赖的类改变了其类定义而没有重新编译所有的类，进而引发错误的情况。 NO.10　java.lang.StackOverflowError 堆栈溢出错误。当一个应用递归调用的层次太深而导致堆栈溢出时抛出该错误。 关于异常的全部说明，在api里都可以一一查阅。大家也不用把其中的所有内容都背在脑中，只要做到对常见异常有一些印像，在真正遇到时知道去哪找就差不多了，毕竟Java程序员最最痛苦就是他的知识容量太大，而我们每天都会遇到新的错误与新的问题及新的知识，所以掌握一套自己的排错方法最重要。一个合格的程序员，需要对程序中常见的问题有相当的了解和相应的解决办法，否则仅仅停留在写程序而不会改程序的话，会极大影响到自己的开发的。真正能说明你Coding水平的标准中，对异常的认识就是其中非常重要的一条！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6bdf5c2286846cc8b3c5994a0580baa/" rel="bookmark">
			通过线程池创建线程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/** * 创建线程池（推荐） */ @Test public void createThreadPoolTask() throws InterruptedException { ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( /** * 该线程池核心线程数 最小存在数 在创建该线程池时 是没有初始化该线程的 * 如果在创建线程池时初始化核心线程时需要调用 * this.prestartAllCoreThreads() 方法初始化核心线程 */ 1000, /** * 最高线程数 该线程池可存在的最高线程数 */ 3000, /** * 如果有空闲线程 则该空闲线程能够存在最大时间 需要结合TimeUnit使用 */ 5, /** * 空闲时间单位 */ TimeUnit.SECONDS, //线程池缓存队列数 /** * 阻塞队列与队列规则和队列数量 * workQueue的类型为BlockingQueue&lt;Runnable&gt;，通常可以取下面三种类型： * ArrayBlockingQueue：基于数组的先进先出队列，此队列创建时必须指定大小； * LinkedBlockingQueue：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE； * synchronousQueue：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。 */ new LinkedBlockingQueue&lt;Runnable&gt;(100000), /** * 创建Thread的线程工厂 如果在不自定义线程工厂的情况下建议使用Hutool的线程工厂 里面可以自定义线程的属性: * ThreadUtil.createThreadFactoryBuilder()xxxxxxxxx .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6bdf5c2286846cc8b3c5994a0580baa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2d47d6a2976637ea06b82dc0dfb0a1c/" rel="bookmark">
			SSH 远程登录错误解决办法 WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、问题 WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!2、原因3、解决办法 1、问题 WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! Windows 系统 cmd 登陆时出现如下错误：
2、原因 在 Linux 根节点上有 .ssh 文件夹：
在 Windows 当前用户根节点上也有 .ssh 文件夹：
其中 known_hosts 是记录远程主机的公钥的文件，一个新的 Linux 服务器，保存的公钥还是初始的系统公钥，在 ssh 链接的时候首先会验证公钥，如果公钥不对，就会报错！
3、解决办法 方法一：
将 known_hosts 文件中的与登录错误的 IP 的公钥删除即可，，再 ssh 登录就登录成功了。
方法二：
将 known_hosts 文件中的内容清空即可，但不建议使用此方法，里面还保存有其他机子的公钥。
方法三：
使用 shh-keygen 命令 （建议使用此方法）
比如：要将 122.51.xxx.xxx 的公钥信息清除，使用命令（请自己将 122.51.xxx.xxx 替换成自己的 IP 或域名）：
ssh-keygen -R 122.51.xxx.xxx 结果如下图（Linux 相同）：
完毕之后就可以了，再次登陆就后要求确认是否公钥：
C:\WINDOWS\system32&gt;ssh 用户名(Linux 服务器的)@122.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2d47d6a2976637ea06b82dc0dfb0a1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a44aad5dd518db56c998032f77719cf9/" rel="bookmark">
			CI/CD准备——私库registry/ harbor搭建使用（docker-compose）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		私有docker仓库：常用有registry、harbor两种，registry简单，但默认没有web管理界面，访问控制等必须功能，harbor包较大，依赖多个容器，占用较多系统资源。
1.registry使用 1.安装registry仓库 docker run -d -v /opt/registry:/var/lib/registry -p 5001:5000 --name myregistry registry:2 2.将registry:2另打个tag docker tag docker.io/registry:2 localhost:5001/test:1.0 3.将localhost:5001/registry:2.1镜像push上去 docker push localhost:5001/test.1.0 默认支持https，需要修改vim /etc/docker/daemon.json，配置{ "insecure-registries":["192.168.203.132:5001"] } 再重启docker 及registry容器 4.谷歌访问查看是否推上去了 http://192.168.203.132:5001/v2/_catalog 2.harbor使用 2.1 github下载安装包,1.8.0+版本需要较高版本的docker版本，因docker版本较低，这里使用了稍低的版本
wget https://storage.googleapis.com/harbor-releases/release-1.6.0/harbor-offline-installer-v1.6.3.tgz 2.2 修改harbor.cfg ，hostname = 192.168.203.132， sh install.sh 进行启动，该脚本会检查docker,docker-compose版本等，然后执行docker-compose启动多个容器，包括nginx容器。
1.github安装方式：docker-compose安装 https://github.com/docker/compose/releases curl -L https://github.com/docker/compose/releases/download/1.25.4/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose chmod +x /usr/local/bin/docker-compose 2.本地安装：由于网络原因可能下载很慢，下载https://pan.baidu.com/s/1dZvRlh92ftjFd0M94JBS-w mv docker-compose-Linux-x86_64-1.22.0 /usr/local/bin/docker-compose chmod +x /usr/local/bin/docker-compose 插曲：docker-compose.yml基本结构，已influxdb+cadvisor+grafana为例
version: '3.2' volumes: grafana_data: {} services: influxdb: image: tutum/influxdb:0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a44aad5dd518db56c998032f77719cf9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c21274ff06e97933512bc42b068e7f20/" rel="bookmark">
			在windows中将go项目编译成Linux下可执行的二进制文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天有个朋友向我吐槽说他的工作环境是 windows ，新写的项目怎么也打包不成Linux可执行的二进制文件，oh gods， 难道还在为这个困扰么，操作其实很简单，几步搞定就！
一步就可以搞定：
env GOOS=linux GOARCH=amd64 go build
下面是具体详细步骤：
打开Terminal 执行命令：
set GOARCH=amd64
set GOOS=linux
go build xx.go
会生成一个没有后缀的xx二进制文件
将该文件放入linux系统某个文件夹下
赋予权限 chmod 777 xx
执行 ./xx
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc4fa006cca9b1ebe3171dc1f284218b/" rel="bookmark">
			关于Shiro使用密码加密加盐之后序列化失败的问题(十四)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文：https://blog.csdn.net/qq_34021712/article/details/84567437
shiro使用密码加盐之后,序列化失败 ERROR Failed to serialize 之前的博客一直都是使用的明文存储,一直没有写对密码进行加密、加盐处理,有很长时间没有写关于shiro的博客了,期间有很多人加我咨询shiro的问题,今天有个哥们说使用密码加盐后出现序列化失败的问题,找了一下原因，最后记录到博客，希望能给遇到此问题的人一些帮助。
原shiro配置 这里只贴出来造成序列化失败相关的配置,完整的原始配置参考：https://blog.csdn.net/qq_34021712/article/details/80791339
/** * @author: wangsaichao * @date: 2018/5/10 * @description: Shiro配置 */ @Configuration public class ShiroConfig { /** * 身份认证realm; (这个需要自己写，账号密码校验；权限等) * @return */ @Bean public ShiroRealm shiroRealm(){ ShiroRealm shiroRealm = new ShiroRealm(); shiroRealm.setCachingEnabled(true); //启用身份验证缓存，即缓存AuthenticationInfo信息，默认false shiroRealm.setAuthenticationCachingEnabled(true); //缓存AuthenticationInfo信息的缓存名称 在ehcache-shiro.xml中有对应缓存的配置 shiroRealm.setAuthenticationCacheName("authenticationCache"); //启用授权缓存，即缓存AuthorizationInfo信息，默认false shiroRealm.setAuthorizationCachingEnabled(true); //缓存AuthorizationInfo信息的缓存名称 在ehcache-shiro.xml中有对应缓存的配置 shiroRealm.setAuthorizationCacheName("authorizationCache"); //配置自定义密码比较器 shiroRealm.setCredentialsMatcher(retryLimitHashedCredentialsMatcher()); return shiroRealm; } /** * 配置密码比较器 * @return */ @Bean("credentialsMatcher") public RetryLimitHashedCredentialsMatcher retryLimitHashedCredentialsMatcher(){ RetryLimitHashedCredentialsMatcher retryLimitHashedCredentialsMatcher = new RetryLimitHashedCredentialsMatcher(); retryLimitHashedCredentialsMatcher.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc4fa006cca9b1ebe3171dc1f284218b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2f174dea0037626b1d9d567c07c596a/" rel="bookmark">
			域名/IP访问显示“拒绝了我们的连接请求”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.先ping看ping的通不
2.查看Apache,Nginx等web服务器是否正常
3.查看服务器防火墙是否关闭
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8413f09ac7252e57c0f092234788a63/" rel="bookmark">
			IDEA Maven 依赖加载慢
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在pom文件下右击创建seetings.xml文件 ，添加镜像
具体如下
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;settings xmlns="http://maven.apache.org/SETTINGS/1.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd"&gt; &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;uk&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://uk.maven.org/maven2/&lt;/url&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;CN&lt;/id&gt; &lt;name&gt;OSChina Central&lt;/name&gt; &lt;url&gt;http://maven.oschina.net/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;name&gt;internal nexus repository&lt;/name&gt; &lt;url&gt;http://repo.maven.apache.org/maven2&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt; &lt;/settings&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac870eac0dbd9e5d73b438044c10f3fc/" rel="bookmark">
			数据库引擎错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该表包含错误消息编号和描述，它是sys.messages目录视图中错误消息的文本。 如果适用，错误编号是指向更多信息的链接。
此列表并不详尽。 有关所有错误的完整列表，请使用以下查询查询sys.messages目录视图：
SELECT message_id AS Error, severity AS Severity, [Event Logged] = CASE is_event_logged WHEN 0 THEN 'No' ELSE 'Yes' END, text AS [Description] FROM sys.messages WHERE language_id = 2052 --所需的语言，例如1033（美国英语） ORDER BY message_id ErrorSeverityEvent LoggedDescription2120No警告: 在 %2! 出现错误 %1!。请记录该错误和时间，并与您的系统管理员联系。10115No在 Waitfor 中不允许使用查询。10215No“%1!”附近有语法错误。10315No以 ‘%2!’ 开头的 %1! 太长。最大长度为 %3!。10415No如果该语句包含 UNION、INTERSECT 或 EXCEPT 运算符，则 ORDER BY 项必须出现在选择列表中。10515No字符串 ‘%1!’ 后的引号不完整。10616No查询中的表名太多。最多允许有 %1! 个。10715No列前缀 ‘%1!’ 与查询中使用的表名或别名不匹配。10815NoORDER BY 位置号 %1! 超出了选择列表中项数的范围。10915NoINSERT 语句中列的数目大于 VALUES 子句中指定的值的数目。VALUES 子句中值的数目必须与 INSERT 语句中指定的列的数目匹配。11015NoINSERT 语句中列的数目小于 VALUES 子句中指定的值的数目。VALUES 子句中值的数目必须与 INSERT 语句中指定的列的数目匹配。11115No%1!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac870eac0dbd9e5d73b438044c10f3fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7181cbbc0671f9ea60c91e235fa36dfe/" rel="bookmark">
			MapReduce程序的Type mismatch异常处理方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Type mismatch in key from map: expected org.apache.hadoop.io.Text, received org.apache.hadoop.io.Lon
这个异常是因为你的 map函数和reduce函数调用了它们的父类，将那个语句删除就ok啦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eca5c0a25f36cfc668631fde8cf49a3b/" rel="bookmark">
			python画一个可爱的皮卡丘（完整代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先看效果图：
然后不说那么多，我就直接上代码了，主要是为了好玩，需要讲解的，可以直接看我发的海龟入门：
# coding:utf-8 from turtle import * import turtle as t from random import * def infoPrt(): print('coordinate: ' + str(t.pos())) print('angle: ' + str(t.heading())) t.pensize(3) t.hideturtle() t.colormode(255) t.color("black") t.setup(700, 650) t.speed(1) t.st() #t.dot() t.pu() #t.goto(-150,100) t.goto(-210,86) t.pd() infoPrt() # 头 print('头') t.seth(85) t.circle(-100,50) #t.seth(78) #t.circle(-100,25) infoPrt() t.seth(25) t.circle(-170,50) infoPrt() # 右耳 print('右耳') t.seth(40) #t.circle(-250,52) t.circle(-250,30) infoPrt() # 右耳尖 t.begin_fill() # 左 t.circle(-250,22) #t.fillcolor("pink") # 右 t.seth(227) t.circle(-270, 15) prePos = t.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eca5c0a25f36cfc668631fde8cf49a3b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/227/">«</a>
	<span class="pagination__item pagination__item--current">228/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/229/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>