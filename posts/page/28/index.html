<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26a58380cfbafcb0b104818ab84d654a/" rel="bookmark">
			Visio导出eps格式图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Visio导出eps格式图片 文章目录 Visio导出eps格式图片1. Visio中使用Adobe Acrobat虚拟打印2. Adobe Acrobat中裁剪并另存为eps格式 如何使用Visio绘图然后导出.eps格式的图片呢？这个过程需要用到Adobe Acrobat，使用Adobe Acrobat的虚拟打印功能，可以导出.eps格式的图片。
1. Visio中使用Adobe Acrobat虚拟打印 首先在Visio中选中图片区域
然后使用Adobe Acrobat进行虚拟打印
2. Adobe Acrobat中裁剪并另存为eps格式 点击编辑PDF
进行裁剪，首先选择裁剪区域，然后点击Enter进行确认
然后选择删除白边并且确认
然后直接另存为eps格式图片即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3c84f4fb67e1462c5745d5939511541/" rel="bookmark">
			排序算法：希尔排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在实现希尔排序的过程中，我们需要先对整个序列进行分组，然后组内进行插入排序，这样可以将元素快速的移动到大致所在的位置，然后不断减少分组的步长，最后对整个序列进行插入排序，因为此前已经将元素大跨步的移动到大致所在的位置，所以最后进行的插入排序进行比较的次数也会减小。整个希尔排序的流程大致如下所示：
先对整个序列进行分组：
组内进行插入排序，排序后的序列为：
接着缩小步长为2进行分组：
再进行插入排序：
接着缩小步长为1进行分组（即整个序列为1组）：
对组内进行排序，对步长为1的组进行排序是在找元素的精确位置：
整个序列就排序完毕，这就是希尔排序的大致流程，总体思路为先大致确定元素所在的位置，再精确确定元素的位置。
代码如下：
#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; void shellsort(int *nums, int length){ int step = length/2; while(step!=0){ for(int i=0; i&lt;step; i++){ for(int j=i+step; j&lt;length; j+=step){ int index = j; for(int k=j-step; k&gt;=0; k-=step){ if(nums[k]&gt;nums[j]){ index = k; }else{ break; } } int temp = nums[j]; for(int l=j; l&gt;index; l-=step){ nums[l] = nums[l-step]; } nums[index] = temp; } } step/=2; } } int main(){ int * nums = NULL; int n; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3c84f4fb67e1462c5745d5939511541/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7f51c1f5505a606ebb780127ce54c86/" rel="bookmark">
			【Web开发】会话管理与无 Cookie 环境下的实现策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🍎个人博客：个人主页
🏆个人专栏： Web开发 ⛳️ 功不唐捐，玉汝于成
目录
前言
正文
问题：
思路： 方法：
结语
我的其他博客
前言 在当今Web应用程序中，会话管理是确保用户状态和数据一致性的关键组成部分。然而，随着一些客户端禁用Cookie的趋势，传统的Cookie依赖型会话管理受到了挑战。在这篇文章中，我们将探讨在无Cookie环境下实现会话管理的不同策略，以确保在各种情况下都能有效地维护用户会话。
正文 问题： 客户端禁止 cookie 能实现 session 还能用吗
思路： 如果客户端禁用了 Cookie，传统的基于 Cookie 的会话管理机制将受到影响，因为会话（session）通常依赖于 Cookie 来在客户端和服务器之间保持状态信息。在这种情况下，你可能需要考虑其他方法来实现会话管理。
一种替代的方法是使用 URL 重写或者将会话标识符嵌入到请求参数中。这样，即使客户端禁用了 Cookie，服务器仍然能够通过 URL 或请求参数来识别用户的会话。然而，这样的做法可能会引入一些安全性问题，因为会话标识符可能会出现在 URL 中，可能被恶意用户截获。
在一些情况下，你也可以考虑使用其他的存储机制，如将会话信息存储在服务器端的数据库或缓存中，而不是依赖于客户端的 Cookie。这种方式通常被称为"无状态"或"无会话"的设计，其中服务器不依赖客户端存储状态，而是通过其他手段来标识和管理用户会话。
总的来说，虽然禁用 Cookie 会影响传统的基于 Cookie 的会话管理方式，但仍然有其他方法来实现会话管理，取决于应用程序的需求和安全性考虑。 方法： 实现会话管理的方法主要取决于应用程序的需求、安全性要求以及客户端禁用 Cookie 的具体背景。以下是一些可能的方法：
URL 重写： 将会话标识符嵌入到URL中，以便在请求之间传递会话信息。这样即使禁用了 Cookie，服务器仍然可以通过解析URL来维护用户的会话状态。但需要注意的是，这可能导致一些安全风险，因为 URL 可能会被记录在各种地方，包括浏览器历史记录和服务器日志中。
请求参数： 类似于URL重写，可以将会话标识符作为请求参数的一部分传递。这种方法可以通过在每个链接和表单中添加会话标识符来实现。然而，同样需要注意潜在的安全风险。
无状态设计： 考虑设计无状态的应用程序，其中服务器端不依赖于客户端的存储状态。所有的会话信息都保存在服务器端的数据库或缓存中，而客户端只需要在每个请求中提供身份验证凭证。这样可以避免在客户端存储敏感信息，提高安全性。
基于 Token 的认证： 使用基于 Token 的认证机制，例如 JSON Web Tokens (JWT)。每个请求都携带一个包含会话信息的令牌，服务器验证令牌以识别用户会话。这种方法不依赖于 Cookie，而是将会话信息嵌入到令牌中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7f51c1f5505a606ebb780127ce54c86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/345f7a2094bc537d18df42d6a61507df/" rel="bookmark">
			Redisson与SQL乐观锁：实现接口幂等性的终极指南与实战演示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Redisson与SQL乐观锁：实现接口幂等性的终极指南与实战演示
Redisson与SQL乐观锁：实现接口幂等性的终极指南与实战演示
接口幂等性.md 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e2a73d9fb4338d82cb0d28c516acbec/" rel="bookmark">
			Kali Linux——设置中文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【问题现象】 从下图可以看到，菜单全是英文的。对于英文不好的同学，使用起来很难受。
【解决方法】 1、获取root权限 su root 2、进入语言设置 dpkg-reconfigure locales 3、选择zh_CN.UTF-8 UTF-8 4、设置默认 5、安装完成 6、重启虚拟机 reboot 7、文件夹名称更新语言 8、成功
现在我们可以看到都变成中文了。
记得拍摄个快照。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d542a558d4f6fe3c75643b28aa703eec/" rel="bookmark">
			华为深信服信息安全从业者考试认证大全（cwasp/cisp/nisp sisp-pte......
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		证书是IT从业者知识水平能力的一个体现，考证同时也是拓展自身知识的一个方法。近年来，安全行业风生水起，各种认证层出不穷，眼花缭乱。这里不对任何一个证书做评价，只是做出介绍，在国内，对任何事物的评价都会引起围攻。所以笔者不敢妄谈一个证书的含金量，会具体谈到每个证书笔者所了解的作用，并将所有证书在此汇总，若有缺失，还请评论补充。笔者自信，只要不再出相关认证，此篇即是最全最完善的证书介绍。废话不多说，切入正题。
这里将按照发证部门来将证书分类介绍。
首先，是国内的。国内安全相关大概有：软考，华为系，公安部系，信息安全测评中心系，深信服的SCSA，云安全联盟系列（CCSK/CCCSP)，信息安全认证中心的CISAW。软考为中级的信息安全工程师，华为分为中级的HCNP（HCIP)-security及HCIE-security，信息安全测评中心发的一些：cwasp（安全开发认证）、cisp(注册信息安全人员）、cisp-pte(渗透测试方向）、cisp-ire(应急响方向）、 CISP-A（审计方向）、NISP二级等等。公安部发的是等级测评师及CIIP。
其次为国际的。国际的首先是ISC发的CISSP、CCSP、CCLSP，其次为kali系（OSCE\OSCP)，完了是ISO相关、ISACA系（CISA/CISM）、国际电子商务顾问委员会（EC-Council）的CEH（道德黑客）， CompTIA美国计算机协会系（security+及 PenTest+）等等。
接下来分别介绍每个证，排名不分先后，从以下几个维度，考证费用，知识相关，持证人数，证书作用来介（ping)绍(jia)。
考试认证题库，需要点击下方链接即可前往获取：
CSDN大礼包：《对标阿里黑客&amp;网络安全入门&amp;进阶学习资源包》免费分享
信息安全测评中心系 信息安全侧测评中心介绍：
首先，这是我党授权的部门，即有牌照的，官方话就是政府权威职能机构。承担信息技术产品和系统的安全漏洞分析和信息通报；党政机关信息网络、重要信息系统的安全风险评估；开展信息技术产品、系统和工程建设的安全性测试和评估；开展信息安全服务和专业人员的能力评估与资质审核；从事信息安全测试评估的理论研究、技术研发、标准研制等。
1. CISP(注册信息安全人员）(CISE/CISO) 考证费用：12800/9800/8000/0（公司报销）
知识相关：信息安全保障概述、信息安全技术、信息安全管理、信息安全工程和信息安全标准法规
持证人数：2W+
证书作用及相关介绍：
1) 说明持证人拥有风险评估的能力及相关意识，对于一个安全服务工程师绰绰有余。
2) 官方说，每个公司必须拥有一定数量的CISP才能申请安全服务资质，实则两个证就行了。
3) 目前仍是最火的认证，因为好考，准备准备就过了。实质就是扫盲并实(hua)力(qian)拿证
2. NISP 考证费用：4800+480+4000换证
知识相关：信息安全保障概述、信息安全技术、信息安全管理、信息安全工程和信息安全标准法规
持证人数：1W+
证书作用及相关介绍：
1) 说明持证人拥有风险评估的能力及相关意识，对于一个安全服务工程师绰绰有余。
2) 官方说，每个公司必须拥有一定数量的CISP才能申请安全服务资质，实则两个证就行了。
3) 目前仍是最火的认证，因为好考，准备准备就过了。实质也是实(hua)力(qian)买证
4) 这不是复制的CISP嘛，对就是复制的，校园版的CISP不就是复制的。跟CISP一样的，满足换证条件，换证下来8000多。
考试认证题库，需要点击下方链接即可前往获取：
CSDN大礼包：《对标阿里黑客&amp;网络安全入门&amp;进阶学习资源包》免费分享
3. CISP-PTE 考证费用：19800
知识相关：Web安全基础、中间件安全基础、操作系统安全基础、数据库安全基础
持证人数：1W+
证书作用及相关介绍：
1) 说明持证人拥有基本的渗透测试能力。
2) 与CISP同等效力，即也能拿来申请资质。
3) 目前考的人不少，作为渗透测试的唯一国内认证，深受渗透测试人员的吹捧。
4. CISP-IRE 考证费用：19800
知识相关：应急响应概况、应急响应基础、应急响应事 件监测、应急响应事件分析与处置、企业应急响应典型事件
持证人数：5000+
证书作用及相关介绍：
1) 说明持证人对应急响应有充分认识，做一般的应急没有问题。
2) CISP同等效力，即也能拿来申请资质
3) 因为才出来不久，并没有多少人考这个方向，除非公司报销，否则不建议考。
5. CWASP CSSD 考证费用：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d542a558d4f6fe3c75643b28aa703eec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f24291d61cd1ca0173aac5f928bc677/" rel="bookmark">
			GD32F1硬件开发指南之复位电路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GD32F10x系列复位控制包括三种复位：电源复位、系统复位和备份域复位。
电源复位为冷复位，电源启动时复位除了备份域的所有系统。电源和系统复位的过程中，NRST会维持一个低电平，直至复位结束。MCU无法执行起来时，可以通过示波器监测NRST管脚波形来判断芯片是否有一直发生复位事件。 芯片内部集成POR/ PDR(上电/掉电复位)电路，用于检测电源并在电压低于阈值时产生电源复位信号复位除备份域之外的整个芯片。GD32F1中flash容量不超过128KB的GD32F103产品，VPOR表示上电复位的阈值电压，典型值约为2.4V，VPDR表示掉电复位的阈值电压，典型值约为2.35V，迟滞电压Vhyst值约为50mV。flash容量大于128KB的GD32F103产品，VPOR表示上电复位的阈值电压，典型值约为2.4V，VPDR表示掉电复位的阈值电压，典型值约为1.8V，迟滞电压Vhyst值约为600mV。
注意：适用于GD32F101及flash容量不超过128KB的GD32F1产品。
注意：适用于flash容量大于128KB的GD32F103产品。
LVD的功能是检测VDD/VDDA供电电压是否低于低电压检测阈值(2.2 V~2.9V)，该阈值由电源控制寄存器中的LVDT[2:0]位进行配置。LVD通过LVDEN置位使能，位于电源状态寄存器中的LVDF位表示低电压事件是否出现，该事件连接至EXTI的第16线，用户可以通过配置EXTI的第16线产生相应的中断。迟滞电压Vhyst值为100mV。
LVD应用场合：当MCU电源受到外部干扰时，如发生电压跌落，我们可通过LVD设置低电压检测阈值，一旦跌落到该阈值，LVD中断被打开，可在中断函数里设置软复位等操作，避免MCU发生其他异常。
另外，MCU复位源可以通过查询寄存器RCU_RSTSCK来判断，该寄存器只有上电复位才能清除标志位，所以在使用过程中，获取到复位源后，可通过RSTFC控制位清除复位标志，那样发生看门狗复位或其他复位事件时，才能较准确在RCU_RSTSCK寄存器中体现 出来：
MCU内部集成有上电/掉电复位电路，在设计外部复位电路时，NRST管脚必须要放置一个电容，确保NRST管脚上电能产生一个至少20us的低脉冲延时，完成有效上电复位过程。
注意：
1，内部上拉电阻RPU = 40kΩ，建议接外部上拉电阻10kΩ即可，以使得电压干扰不会导致芯 片工作异常；
2. 若考虑静电等影响，可在NRST管脚处放置ESD保护二极管；
3. 尽管MCU内部有硬件POR电路，仍推荐外部加NRST复位阻容电路；
4. 如果MCU启动异常，可适当增加NRST对地电容值，拉长MCU复位完 成时间，避开上电异常时序区。
==========
往期回顾：
解决printf无法打印输出的问题
SHT3x-DIS驱动及应用详解
两步判断U盘读写性能示波器最重要的三个参数
全攻略自制esp8266 WIFI智能排插教程
==========
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78e03d04025c4ce147ceb987600001f4/" rel="bookmark">
			Mybatis缓存相关面试题有多卷
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MyBatis 是一个流行的持久层框架，它提供了一个灵活且高效的方式来访问关系型数据库。其中一个重要的特性是缓存机制，它可以帮助提升数据库查询的性能。
MyBatis 的缓存分为一级缓存和二级缓存两种：
一级缓存：默认情况下，MyBatis 开启了一级缓存。一级缓存是指在同一个 SqlSession 中，执行相同的 SQL 语句，返回的结果会被缓存起来，下次再执行相同的 SQL 语句时，直接从缓存中获取结果，而不需要再去数据库查询。一级缓存的范围是 SqlSession 级别的，也就是在同一个 SqlSession 中，多次执行相同的 SQL 语句只会查询数据库一次。二级缓存：二级缓存是指在不同的 SqlSession 之间共享缓存。通过配置开启二级缓存后，当一个 SqlSession 执行查询时，查询的结果会被保存到共享的缓存中，其他的 SqlSession 在执行相同的查询时，可以直接从缓存中获取结果，而不需要再去查询数据库。二级缓存的范围是 Mapper 级别的，默认情况下是关闭的，需要手动进行配置开启。 需要注意的是，一级缓存是默认开启的，并且无法关闭，而二级缓存是需要手动进行配置开启的。
使用 MyBatis 缓存机制需要注意以下几点：
对于频繁更新和变动的数据，不适合使用缓存。对于数据的一致性要求比较高的场景，不适合使用缓存。如果配置了二级缓存，需要确保缓存的数据不会影响到其他业务模块的数据。在使用缓存时，需要注意缓存的命中率和缓存的过期策略，避免缓存过期导致查询性能下降。 目录
一、描述一下MyBatis的一级缓存是什么？
二、MyBatis的一级缓存如何工作？
三、MyBatis的一级缓存是怎样管理的？
四、在MyBatis中如何清除一级缓存？
五、何时使用一级缓存是不合适的？
六、MyBatis 一级缓存可能带来的问题是什么？
七、如何配置MyBatis以禁用一级缓存？
八、如何监控MyBatis的一级缓存？
九、在分布式系统中，一级缓存会造成哪些影响？
十、MyBatis一级缓存的范围是如何确定的？
十一、对于MyBatis来说，有哪些操作会触发一级缓存的失效？
十二、使用MyBatis一级缓存需要注意哪些最佳实践？
十三、MyBatis在缓存查询结果时用的是哪些关键信息？
十四、MyBatis的懒加载是什么，它与一级缓存有什么关联？
十五、MyBatis 一级缓存和二级缓存的区别是什么？
十六、什么是MyBatis的二级缓存？
十七、如何启用MyBatis的二级缓存？
十八、MyBatis二级缓存可以整合哪些第三方缓存框架？
十九、MyBatis的二级缓存在什么时候会清空？
二十、​​​​​​​使用MyBatis二级缓存有哪些注意事项或最佳实践？
二十一、二级缓存的读写策略有哪些？
二十二、如果开启了二级缓存，MyBatis是如何确定缓存的键值的？
二十三、在嵌套查询中，MyBatis的二级缓存如何工作？
二十四、MyBatis二级缓存中的数据如何保证同步/一致性？
二十五、MyBatis的缓存穿透是什么意思，如何防止？
二十六、如果应用重启，MyBatis二级缓存中的数据会怎样？
二十七、如何动态地清除MyBatis的二级缓存？
二十八、MyBatis二级缓存是否支持事务？
二十九、MyBatis二级缓存数据如何保证一致性？
三十、如何描述MyBatis的二级缓存，并说明它与其他缓存（如数据库缓存、应用缓存等）的区别？
一、描述一下MyBatis的一级缓存是什么？ 答：在MyBatis中，一级缓存是指SqlSession级别的缓存。当执行查询操作时，查询结果会存储在SqlSession的一级缓存中。后续如果在相同的SqlSession中执行相同的查询操作，则会直接从缓存中获取数据，而不是访问数据库。这个缓存只在SqlSession内部有效，也就是说，当SqlSession被关闭或者提交（commit）时，缓存将被清空。
二、MyBatis的一级缓存如何工作？ 答：一级缓存的工作机制是：在第一次查询数据时，会从数据库中检索结果并将其存储在一级缓存（即当前的SqlSession中）。之后，如果有相同的查询请求发起，并且这个查询请求在同一个SqlSession的生命周期内，MyBatis会检测到这个请求的结果已经被缓存，于是直接从缓存中获取数据，而不是再执行数据库查询。
三、MyBatis的一级缓存是怎样管理的？ 答：MyBatis的一级缓存默认是开启的，并不需要专门的配置。它是通过SqlSession来维护的，每个SqlSession都有自己的一级缓存。一级缓存的生命周期与SqlSession的生命周期相同，当SqlSession关闭或提交时，它的一级缓存也会被清空。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78e03d04025c4ce147ceb987600001f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bac98dcd9bd19027723a18527b2537f4/" rel="bookmark">
			HDU 1205：吃糖果 ← 鸽巢原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【题目来源】
http://acm.hdu.edu.cn/showproblem.php?pid=1205
【题目描述】
HOHO，终于从Speakless手上赢走了所有的糖果，是Gardon吃糖果时有个特殊的癖好，就是不喜欢将一样的糖果放在一起吃，喜欢先吃一种，下一次吃另一种，这样；可是Gardon不知道是否存在一种吃糖果的顺序使得他能把所有糖果都吃完？请你写个程序帮忙计算一下。
【输入格式】
第一行有一个整数T，接下来T组数据，每组数据占2行，第一行是一个整数N（0&lt;N&lt;=1000000)，第二行是N个数，表示N种糖果的数目Mi(0&lt;Mi&lt;=1000000)。
【输出格式】
对于每组数据，输出一行，包含一个"Yes"或者"No"。
【输入样例】
2
3
4 1 1
5
5 4 3 2 1
【输出样例】
No
Yes
【算法分析】
鸽巢原理（Pigeonhole Principle），或称抽屉原理（Drawer Principle）。
鸽巢原理常见的两种表述如下所述：
● 将 个物体，划分为 组，那么有至少一组有两个（或以上）的物体。
● 将 个物体，划分为 组，那么至少存在一个分组，含有大于或等于 个物品。
本题是鸽巢原理的典型应用：若设数量最多的某种糖果数为 N，其他糖果总数为 S。若视 N 个糖果为 N 个隔板，并把每个隔板的右边看成一个空间，则可隔成 N 个空间。
若 S&lt;N-1（也即，N&gt;S+1），则至少有两个隔板之间没有糖果，而隔板代表同一种糖果，故无解。
若 S&gt;=N-1（也即，N&lt;=S+1），肯定有解。
依据一种取巧的方法，“若整数位数超过10位，就选择用 long long 型”。故本题中的若干变量不定义为 int 型，而定义为 long long 型，因为计算过程中，极大可能会超过 10 位数。
【算法代码】
#include &lt;iostream&gt; using namespace std; typedef long long LL; LL imax,sum; LL n,x; int main() { LL T; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bac98dcd9bd19027723a18527b2537f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21de61d61e1e12a00654f80b2cdb4a29/" rel="bookmark">
			SpringBoot基于Redis(7.2)分片集群实现读写分离
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、前置提要二、集群搭建三、SpringBoot访问分片集群 一、前置提要 SpringBoot访问Redis分片集群和Redis哨兵模式，使用上没有什么区别。唯一的区别在于application.yml配置上不一样。
二、集群搭建 首先，无论如何，得先有一个Redis分片集群，具体可以参考下面这篇文章
Docker-Compose部署Redis(v7.2)分片集群(含主从) 搭建完成后大致得到如下图描述的一个集群。
三、SpringBoot访问分片集群 其次，具体如何结合Idea和Docker让本地开发的SpringBoot项目访问Redis分片集群，可以参考下面这篇文章
SpringBoot基于哨兵模式的Redis(7.2)集群实现读写分离 要注意的是，yaml文件要从
spring: redis: sentinel: master: mymaster nodes: - 172.30.1.11:26379 - 172.30.1.12:26379 - 172.30.1.13:26379 password: 1009 password: 1009 变成
spring: redis: cluster: nodes: - 172.30.2.11:6379 - 172.30.2.12:6379 - 172.30.2.13:6379 - 172.30.2.21:6379 - 172.30.2.22:6379 - 172.30.2.23:6379 其余基本一致。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e24c18a7020db38a6329e2e65caf368/" rel="bookmark">
			架构的本质是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近总是有小伙伴问我，如何成长为一名优秀的架构师，我也不知道该如何去回答，但是我想聊一下架构的本质。
架构不是互联网行业独有的 架构及对应的架构师职位并不是互联网行业独有的，只要存在组织的地方就存在架构。
比如一个木工，在开始制作家具之前是不是要做好图纸，就算没有图纸，人家也会在脑海中勾兑出一张家具图，这样木工才会参照这张家具图去做家具。
架构的理念是无处不在的，只要有人活动的地方都会存在，只是说职位名称不一样而已。
就算是古代的行政机构，比如皇帝，他设计了一套完整的中央集权的组织，并利用这个组织中的成员去管理这个国家，比如明朝的中书省，它就是皇帝作为国家的首席架构师去搭建的，并希望这个机构去高效的管理这个国家。
也就是皇帝希望官员执行这个机构的架构理念，并高效的去工作，皇帝最终的目的就是要官员执行它的架构思想。
那么互联网领域的架构其实也是一样的，架构师要做的事情就是如何让开发人员理解自己的架构思想，并严格的执行自己的方案，最终高效的完成产品研发工作，最终的落脚点都是要能够高效的成事，而不是虚无缥缈的概念。
假如皇帝制定了一大堆关于管理国家的架构理念，比如建文帝，要执行削藩，那么朱棣就不满了，坚决不执行且还造反，那么最终建文帝是很难成事的，最终就灭亡了。
同样架构师也一样，假如你底下的技术开发都不买你的账，且一致的抵制你的技术方案，那么你这个架构师大概率是要被撸走的。
架构的目的是解决问题 架构的目的就是为了解决问题，假如违背了这个初衷，那么架构就没必要存在了。
还是拿木工做家具这个例子来分析，假如木工事先不设计图纸，只是漫无目的的做家具，那么出错了怎么办呢？木工只能不断的返工，甚至最后直接推倒重来，这样家具的容错率太低了。
如果他有图纸，就可以事先设计好，并反复的推演家具的模型，最终确定家具的模型，并生成图纸，就算是生产出现错误，木工也是有图纸作为依据，再去重新制定一张新的图纸，而不是靠记忆和经验去重新开始设计，那样效率太低且不能真正的解决问题。
互联网行业的架构师也是为了解决问题而存在的，假如你的产品团队中的架构师不能为团队分担问题（无论是业务还是技术问题），那么这架构师就是不合格的，或者是团队根本不需要专职的架构师。
我也见过很多刚开始做架构师的小伙伴，非常的努力，总是冲在业务的第一线且收集了很多业务痛点，并制定了很多技术方案，花费了大量的时间去给技术开发人员去宣讲自己的架构理念。
初步一看，这样也是没错的，也是架构师的工作内容，但是这位架构师小伙伴的群众反馈并不高，甚至在绩效考核的时候，KPI还不如那些一线的技术开发小伙伴。
其实这个也是刚开始做架构师的技术人都会犯的一个通病，那就是没有抓住架构师的目的，那就是解决问题。
诚然这个架构师小伙伴很努力，针对调研的问题输出了很多技术方案，也一一的宣讲了这些架构方案，技术小伙伴也都参加了，但是最终人家就像看电影一样，匆匆看完，匆匆离场，也就是对于他们而言，这个不是他们该考虑的事情，也不是他们的责任，这个是你架构师该考虑的。
哈哈，说到这里我想小伙伴应该很清楚了吧，这个架构师就是犯了这样的错误，没有将自己输出的技术方案转换为责任，并分担给技术开发人员。
更加直白的说那就是没有将技术方案转换为技术开发人员的KPI，导致你的技术方案永远只停留在你的PPT和图纸上。这样领导肯定会绝对你的技术方案根本不能帮他去解决问题，只是过了一下嘴瘾而已。
以上这个例子是做架构师的时候经常会犯的一个错误，只是不会将技术方案转换为KPI，那么接下来这个小伙伴犯的错误，就更好玩了。
同样也是一个非常努力的架构师，调研了很多技术和业务问题，并输出了很多技术方案，但是这个架构师输出的方案太大了，几乎每一个方案都是要将之前的产品规划推倒重来，并在宣讲的过程中一五一十的将这些方案全部讲了出来，参与的技术开发人员刚开始会觉得这个架构师非常的牛逼，非常的专业，但是慢慢的人家会感觉到“工作量太大了”，这个饼画的也太大了。
这个架构师小伙伴也没有给人家一一拆解，而是一股脑的将这些技术方案下放给需要配合改造的业务产品负责人，并将相关责任也关联给人家，以为这样就可以大功告成了。
那么人家肯定是一脸懵逼，嘴上肯定答应我会配合你的，但是人家手上也有很多紧急的任务和需求要做，只会将你这个改造任务的优先级降到最低。
事实上你的技术方案等于还是没有落脚点，还是虚的，虽然了下放给了相关责任人，也或多或少放到了KPI中，但是优先级太低了。
当然以上问题也是想做架构师的技术小伙伴经常会犯的一个错误，其实这个错误的本质也是没有真正的理解架构师就是要解决问题的
这些技术方案，架构师需要将它拆解为一个个小的里程碑任务，并和相关责任人一起穿插到技术开发人员的开发规划中。
至于如何穿插，这个就要考量你架构师的功底了，不仅仅需要你要有很强的技术硬实力和业务理解能力，也需要你有很强的软实力，并说服人家去改造。
我可以列举一个简单的例子，假如你需要技术开发人员配合你完成微服务框架的升级，比如统一使用Spring Cloud Alibaba，那么你调研了公司目前的微服务框架，并做了详细的对比，但是你不能单单去给技术开发人员去讲解Spring Cloud Alibaba的技术原理和使用方式，而是要去讲解如何将现有的服务从旧的微服务框架升级为Spring Cloud Alibaba，一定要细节到开发、测试和发布上线，以及如何回滚等。
当然除了技术层次的开发流程，你还要考虑业务层次的流程，比如优先改造哪一批服务的技术风险和工作量最小，落地的可能性最大等。
也就是前面常说的，你要学会将一个大饼拆解为可以落地和度量的小的子任务，让技术开发人员不被吓到，从非常乐意的帮你去落地。
其实架构师是否优秀，就是基于这一点去评判的，你要能够让技术开发人员参与到你的技术方案中，并非常快乐的一起去做有意义和有价值的事情，而不是带着情绪去做事情。
架构的本质就是用最优解去解决问题 一个资深架构师总是时刻让自己奔跑在寻找问题最优解的路上，这个是区分架构师水平的唯一标准。
在产品研发的过程中，问题太多了，且能够解决问题的方法有很多，有些是拿来主义，有些是需要自己去加工一下，有些需要自己花费很多时间去研究并转化为工具，但是它们都将作为一种方法去解决问题，但是是否是最优解，这个就会考量一个架构师的水平了。
寻找问题的最优解是非常难的，就算是工作多年的我，在解决一个非常棘手的问题且非常紧急时，也都是把优先解决问题放在第一位，这个也是你领导经常和技术开发人员说的话，只要能够解决问题就行，要的就是速度。
当然这种说法也是没问题的，毕竟没有那么多时间让你去折腾和研究技术，解决问题效率是最重要的。
但是作为一个架构师，你不能这样就放弃了最优解，就算是当下没时间去研究，你一定要事后去复盘，并找到问题的最优解，从而将这个转换为经验和可以参考的架构方案，方便以后可以借鉴，这个就是你作为架构师的技术和架构经验的沉淀。
我可以再列举一个技术问题，那就是你在业务开发过程中经常会碰到线程安全的问题，当然你可以图省事，直接使用Java的同步字段（同步锁），直接放在方法上，但是你有没有想过，你的方法中所有的代码都需要用同步锁去确保线程安全吗？是否锁的粒度太大呢？
因此你就需要考虑锁的粒度和范围的问题，是否可以将部分代码用同步锁，这样可以减少一些性能损耗。
也就是你作为架构师，你要考虑解决线程安全的最优解，这样你的技术视野和抓细节的能力才会越来越强。
好吧，比较零散的和大家聊了这么多，希望对想要成为架构师的技术人有帮助吧。
另外我的新书RocketMQ消息中间件实战派上下册，在京东已经上架啦，目前都是5折，非常的实惠。 https://item.jd.com/14337086.html​编辑https://item.jd.com/14337086.html
“RocketMQ消息中间件实战派上下册”是我既“Spring Cloud Alibaba微服务架构实战派上下册”之后，又一本历时超过1年半的巨无霸技术实战类型的书籍。
为了提高读者阅读本书的体验性，本书总共设计了十个特色，下面我一一的给技术小伙伴阐述一下。 【特色一】由浅到深 本书将RocketMQ的技术原理和最佳实践体系化，按照由浅到深的顺序呈现给读者，使读者可以按照章节顺序按部就班地学习。当学习完全书内容之后，读者不仅能熟悉RocketMQ的核心原理，还能充分理解RocketMQ的“根”。
【特色二】技术新 本书不仅包括RocketMQ4.x（4.9.2版本）的核心原理分析和最佳实践，还包括RocketMQ5.x（5.1. 0版本）的新特性分析和最佳实践。
【特色三】精心设计的主线：零基础入门，循序渐进，直至彻底掌握RocketMQ 本书精心研究了程序类、架构类知识的认知规律，全书共分为6篇：①基础；②进阶；③高级；④高并发、高可用和高性能；⑤应用；⑥新特性，是一条相对科学的主线，让读者快速从“菜鸟”向“RocketMQ分布式架构实战高手”迈进。
【特色四】绘制了大量的图，便于读者理解RocketMQ的原理、架构、流程 一图胜于文，书中在涉及原理、架构、流程的地方配有插图，以便读者更加直观地理解。
【特色五】从架构师和技术专家的视角分析RocketMQ 本书创造性地分析了RocketMQ具备高并发、高可用和高性能的功能及原理，并从架构的视角展开分析，这些也是程序员进阶为技术专家或架构师必备的技能。
以下为从架构师和技术专家的视角分析RocketMQ典型案例，读者阅读完本书之后，也能够达到这样的水准。
【特色六】不仅有原理分析，还有大量的实战案例 本书介绍了大量的实战案例，能让读者“动起来”，在实践中体会功能，而不只是一种概念上的理解。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e24c18a7020db38a6329e2e65caf368/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bee739742cd9e3e8fe51d488bb7ecff9/" rel="bookmark">
			Springboot支付宝沙箱支付（完整详细步骤）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Springboot支付宝沙箱支付（完整详细步骤） 网页操作步骤1.进入支付宝开发平台—沙箱环境2.点击沙箱进入沙箱环境3.进入沙箱，配置接口加签方式4.配置应用网关5.生成自己的密钥 IntelliJ IDEA 操作步骤1.导入依赖2.在 application.yml 里面进行配置：3.alipay的JAVA配置：AlipayConfig.java4.支付接口 新建一个 AliPayController.java5.在拦截器里面加上 忽略alipay接口的配置6.回调接口 退款流程订单三十分钟未支付自动取消使用消息队列优缺点 网页操作步骤 1.进入支付宝开发平台—沙箱环境 使用开发者账号登录开放平台控制平台
2.点击沙箱进入沙箱环境 说明：沙箱环境支持的产品，可以在沙箱控制台 沙箱应用 &gt; 产品列表 中查看。
3.进入沙箱，配置接口加签方式 在沙箱进行调试前需要确保已经配置密钥/证书用于加签，支付宝提供了 系统 默认密钥 及 自定义密钥 两种方式进行配置。 这里我采取的是默认方式： 开发者如需使用系统默认密钥/证书，可在开发信息中选择系统默认密钥。注意:使用API在线调试工具调试OpenAPI必须使用系统默认密钥。
4.配置应用网关 应用网关用于接收支付宝沙箱环境的异步通知（对接 From 蚂蚁消息），如创建门店的被动通知。 注意：仅 HTTP 订阅模式的 From 蚂蚁消息才需要配置应用网关，WebSocket 订阅模式的 From 蚂蚁消息无需配置应用网关。
5.生成自己的密钥 到这，网页操作完成
IntelliJ IDEA 操作步骤 1.导入依赖 &lt;dependency&gt; &lt;groupId&gt;com.alipay.sdk&lt;/groupId&gt; &lt;artifactId&gt;alipay-sdk-java&lt;/artifactId&gt; &lt;version&gt;4.22.110.ALL&lt;/version&gt; &lt;/dependency&gt; 2.在 application.yml 里面进行配置： alipay: appId: appPrivateKey: alipayPublicKey: notifyUrl: （回调接口） 3.alipay的JAVA配置：AlipayConfig.java 读取yml中的配置信息，自动填充到对应的属性
@Data @Component @ConfigurationProperties(prefix = "alipay") public class AliPayConfig { private String appId; private String appPrivateKey; private String alipayPublicKey; private String notifyUrl; } 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bee739742cd9e3e8fe51d488bb7ecff9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ead34078150287cabf26721a3aaf15f1/" rel="bookmark">
			Linux Bonding 技术解析与配置指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 在复杂的网络环境中，为了提高带宽、负载均衡和冗余备份，Linux 提供了 Bonding 技术。Bonding 技术允许将多个物理网络接口绑定在一起，形成一个逻辑接口，以提高网络性能和可用性。
Bonding 七种模式 Linux Bonding 支持多种模式，每种模式都有其独特的特性和应用场景。
俗称配置简称英文名中文名解释bond0balance-rrRound-robin policy平衡轮询策略传输数据包顺序是依次传输，直到最后一个传输完毕，此模式提供负载平衡和容错能力。bond1active-backupActive-backup policy活动备份策略只有一个设备处于活动状态。一个宕掉另一个马上由备份转换为主设备。mac地址是外部可见得。此模式提供了容错能力。bond2balance-xorXOR policy平衡策略传输根据 (源MAC地址 xor 目标MAC地址) mod 设备数量 的布尔值选择传输设备。 此模式提供负载平衡和容错能力。bond3broadcastBroadcast policy广播策略将所有数据包传输给所有设备。此模式提供了容错能力。bond4802.3adIEEE 802.3ad Dynamic link aggregationIEEE 802.3ad 动态链接聚合创建共享相同的速度和双工设置的聚合组。此模式提供了容错能力。每个设备需要基于驱动的重新获取速度和全双工支持；如果使用交换机，交换机也需启用 802.3ad 模式。bond5balance-tlbAdaptive transmit load balancing适配器传输负载均衡通道绑定不需要专用的交换机支持。发出的流量根据当前负载分给每一个设备。由当前设备处理接收，如果接受的设 备传不通就用另一个设备接管当前设备正在处理的mac地址。bond6balance-albAdaptive load balancing适配器负载均衡包括mode5，由 ARP 协商完成接收的负载。bonding驱动程序截获 ARP在本地系统发送出的请求，用其中之一的硬件地址覆盖从属设备的原地址。就像是在服务器上不同的人使用不同的硬件地址一样。 mode0，mode2 和 mode3 理论上需要静态聚合方式bond1，mode5 和 mode6 不需要交换机端的设置，网卡能自动聚合bond4 需要支持 802.3ad，配置交换机 1. Active-Backup 模式 在此模式下，只有一个网络接口是活动的，其他的是备份的。如果活动接口失效，备份接口会接管。这种模式适用于对网络连接的高可用性要求。
2. Balance-RR (Round Robin) 模式 数据包按照轮询的方式分发到所有可用的网络接口。这是一种基于轮询的负载均衡模式，但不能充分利用带宽。
3. 802.3ad (LACP) 模式 使用 Link Aggregation Control Protocol (LACP) 协议，将多个接口绑定在一起，提供负载均衡和冗余备份。需要交换机支持。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ead34078150287cabf26721a3aaf15f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e36ad0b9db679e6ad3d5447bef6f7aeb/" rel="bookmark">
			Java刷题错题笔记-day06-集合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.遍历List集合时删除元素可能会发生什么异常？ ConcurrentModificationException
在 Java 中，ArrayList 是一个使用 Fail-Fast 机制的例子。
ConcurrentHashMap是一个使用 Fail-Safe机制的例子。
Fail-Fast 机制，当在迭代过程中检测到集合被修改（添加、删除元素）时，立即抛出ConcurrentModificationException异常，以避免出现并发修改导致的不确定性行为。
在Java中，Fail-Fast 和 Fail-Safe 是两种不同的迭代器（Iterator）机制，它们主要涉及到在遍历集合时对集合的修改的处理方式。以下是它们的简要介绍：
Fail-Fast（快速失败）机制： 定义： 当在迭代过程中检测到集合被修改（添加、删除元素）时，立即抛出ConcurrentModificationException异常，以避免出现并发修改导致的不确定性行为。
实现： 基于集合（AbstractList）内部维护的一个"modCount"变量，该变量记录了集合被修改的次数。在每次迭代开始时，迭代器会自己维护一个"expectedModCount"变量，初始值取自集合的"modCount"变量，在迭代过程中，如果"modCount"和"expectedModCount"不一致，就抛出异常。
public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt; { // ... //继承自AbstractList，写在这里便于理解 private int modCount = 0; // ... public Iterator&lt;E&gt; iterator() { return new Itr(); } //迭代器 private class Itr implements Iterator&lt;E&gt; { int cursor; // 当前元素的索引 int expectedModCount = modCount; // 迭代器创建时的集合修改次数 // ... public E next() { checkForComodification(); // 检查是否有并发修改 // 返回下一个元素 } final void checkForComodification() { if (modCount !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e36ad0b9db679e6ad3d5447bef6f7aeb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ce28b79f38b0f72dfcbeafcfbb05726/" rel="bookmark">
			【提示学习论文五】Conditional Prompt Learning for Vision-Language Models论文原理及复现工作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Conditional Prompt Learning for Vision-Language Models 视觉语言模型的条件提示学习 文章介绍 这篇文章于2022年发表在CVPR（Conference on Computer Vision and Pattern Recognition），作者是kaiyang.zhou, jingkang001, ccloy, ziwei.liu。研究发现CoOp的问题：泛化性差，CoOp在训练时对于已知类别（base classes）过拟合，学习的上下文向量不能推广到同一数据集中的未知类。作者提出Conditional Context Optimization（CoCoOp）。CoCoOp在CoOp基础上引入一个轻量级的神经网络为每张图像生成 input-conditional tokens（vectors），这些tokens会加到原本CoOp的learnable vectors上，从而可以学习到更泛化的prompt。 问题背景 CoOp是一种有效利用数据的方法，只需少量标记图像数据即可训练上下文向量，以提高模型性能。然而，CoOp存在一个问题，其学到的上下文信息无法推广到同一数据集中更广泛的未知类别，CoOp在训练中过于专注于特定类别，导致模型无法很好地泛化到其他类别上。作者认为，通过实例条件化上下文，可以更好地泛化，因为这使得模型不再专注于特定一组类别，而是关注于每个输入实例及整个任务。为了解决这个问题，提出了CoCoOp方法。 设计 简单实现方法: 构建 M M M个神经网络来生成 M M M个上下文标记，但这会增加计算资源的需求。参数效率设计: 作者提出了更高效的设计方案，该方案在M个上下文向量的基础上进一步学习一个轻量级的神经网络（Meta-Net）。这个Meta-Net用于为每个输入图像生成一个条件化的标记，并将其与上下文向量结合。 模型结构 CoOp
CoCoOp：由两个可学习的组件组成，一组上下文向量和一个轻量级神经网络（Meta-Net），为每个图像生成一个输入条件token输入图像编码器生成的图像 x \mathbf{x} x 特征 ，通过 Meta-Net 生成相应的条件标记 t y ( x ) \mathbf{t}_y (\mathbf{x}) ty​(x)计算输入图像 x \mathbf{x} x 与每个类别提示 t i ( x ) \mathbf{t}_i (\mathbf{x}) ti​(x)之间的相似度对于每个类别 i i i ，将相似度值作为指数项应用于指数函数，同时用温度参数 τ \tau τ 进行缩放，将相似度映射为概率得分将所有类别的指数项相加并归一化，得到每个类别的归一化概率分布最终的预测概率表示为给定输入图像 x \mathbf{x} x下属于每个类别的可能性。 实现细节 p ( y ∣ x ) = exp ⁡ ( sim ⁡ ( x , g ( t y ( x ) ) ) / τ ) ∑ i = 1 K exp ⁡ ( sim ⁡ ( x , g ( t i ( x ) ) / τ ) p(y | \mathbf{x}) = \frac{\exp (\operatorname{sim} (\mathbf{x}, g(\mathbf{t}_y (\mathbf{x}))) / \tau )}{\sum_{i=1}^K \exp (\operatorname{sim} (\mathbf{x}, g(\mathbf{t}_i (\mathbf{x})) / \tau )} p(y∣x)=∑i=1K​exp(sim(x,g(ti​(x))/τ)exp(sim(x,g(ty​(x)))/τ)​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ce28b79f38b0f72dfcbeafcfbb05726/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fac45fd911b4bd6b4f30df5b5fd90e21/" rel="bookmark">
			ADB安装及使用详解（非常详细）从零基础入门到精通，看完这一篇就够了_
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、ADB简介 1、什么是adb ADB 全称为 Android Debug Bridge，起到调试桥的作用，是一个客户端-服务器端程序。其中客户端是用来操作的电脑，服务端是 Android 设备。
ADB 也是 Android SDK 中的一个工具，可以直接操作管理 Android 模拟器或者真实的 Android 设备。
2、为什么要用adb 运行设备的 shell(命令行)
管理模拟器或设备的端口映射
计算机和设备之间上传/下载文件
可以对设备的应用进行卸载安装等
在 App 遇到 ANR/Crash 等 bug 时，可以通过 ADB 来抓取日志
简而言之，ADB 就是连接 Android 手机与 PC 端的桥梁，所以ADB又称为安卓调试桥（注意：是安卓，不是iOS），可以让用户在电脑上对手机进行全面的操作！
二、准备工具 单独安装adb，不安装sdk
1、下载adb Google很好心，直接放出ADB的zip供人下载。路径如下：
Windows版本：https://dl.google.com/android/repository/platform-tools-latest-windows.zip
Mac版本：https://dl.google.com/android/repository/platform-tools-latest-windows.zip
Linux版本：https://dl.google.com/android/repository/platform-tools-latest-linux.zip
2、配置环境变量 解压安装后，把解压路径放到系统变量里去（Path），
环境变量如何配置，比如我的配置如下图：
3、连接 可以通过模拟器连接，也可以通过数据线连接。
通过数据线连接时，手机进入“开发者选项”，打开“usb调试”。
不同品牌安卓机型，首次打开“开发者选项”方式不一样，大多是双击手机版本号3~5次，会toast提醒“开发者模式已打开”，具体打开方式可根据手机品牌进行百度查询
4、电脑打开cmd窗口 输入 adb version ：显示 adb 版本，说明安装成功
三、ADB命令详解 1、基本命令 adb version ：显示 adb 版本
adb help：帮助信息，查看adb所支持的所有命令
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fac45fd911b4bd6b4f30df5b5fd90e21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dda9b09a63e64a9d2f1b1d838021ed16/" rel="bookmark">
			差分电路原理以及为什么输出电压要偏移
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在使用放大器芯片的时候，除了对放大器芯片本身应用外，通常还需要搭建一些外围电路来满足放大器芯片的使用条件，最终满足应用的功能，下面通过一个差分电路来熟悉这些应用。
差分运算放大电路，对共模信号得到有效抑制，而只对差分信号进行放大，因而得到广泛的应用。差分电路的电路构型如下图：
目标处理电压：是采集处理电压，比如在系统中像母线电压的采集处理，还有像交流电压的采集处理等。差分同相/反相分压电阻：为了得到适合运放处理的电压，需要将高压信号进行分压处理，如图1中V1与V2两端的电压经过分压处理，最终得到适合运放处理的电压Vin+与Vin-。
放大电路和比较电路的区别：差分放大电路的反馈，对于运算放大电路来说，运放工作在线性区，所以这里一定是负反馈。没有反馈（开环）或者是正反馈，那是比较器电路而不是放大电路，这时候运放工作在饱和区或称为非线性工作区，正因为饱和，输出才是电源电压的幅值。下面几张图的目的是从运放的定义开始，说明只有处于负反馈的时候，运放才能工作在线性区。
下图是一种带正反馈的运放电路，这里就不能叫运算放大电路了，因为运放的开环放大倍数理想是无限大，当然实际中不可能无限大，所以如下结构是迟滞电压比较器，运放工作在非线性区或饱和区。
假如R74=R75=R76，因为运放工作在非线性区或饱和区，此时不能运用虚短和虚断的原理，根据分压原理则输出为电源范围内的高低电平:|(-15V-Vref)|x1/3+(-15V)或者(+15V-Vref)x2/3+Vref。
下图依然是电压比较器结构，上面已经提到，运放开环增益很大，不带负反馈，工作就如非线性区，当做电压比较器来使用。此时的输出电压就是Vin跟Vref直接比较的结果，或者为-15V，或者为+15V。
运算放大器，反馈电阻从输出接到反相端"-"就是负反馈，当然在输出信号不超过电源电压时（注：一切信号的能量来源是电源，输出当然不可能超过电源幅值），实现的功能就是放大信号的功能，接到同相端"+"就是正反馈，电路功能是电压比较器。当然在实际当中我们并不提倡用运放去做电压比较器，而是选用专用的比较器，如LM339、LM393、LM211等，因为比较器和运放在实际当中内部器件的工作状态还是有区别的。比较器接了限流电阻-"R74、R77"，这是因为比较器在幅值切换时，快速上升或下降沿对后级容性负载进行充放电，这个充放电电流来自这个有源器件—比较器，因此加限流电阻目的是防止电流冲击。
RC滤波：可以酌情调节，目的是防止输出过冲等信号失真问题。
差分输入电压的计算
如下图电路，为了便于计算，我们给定每个阻值。差分电路的另一个特点是对称性，R40=R56及R47=R55，差分分压两个支路电阻也是相等的。
Vin+和Vin-的值是如何计算的？我们先通过繁琐的计算来得到，然后再简化计算。首先，运放的同相端5引脚和反相端6引脚，利用"虚短"得到，其中系数6是指6个100k的电阻，方便简化式子：
那么通过分压关系得到Vin+：
再次通过分压关系得到Vin-：
那么就得到Vin+减Vin-的值，其实还有一种简单方法得到Vin+减Vin-的值，利用运放的虚短特点，可将电路等效为：
所以要计算Vin+减Vin-的值，变得很容易，只是一个简单的分压电路而已，如下计算得到差分电压输入值是0.84V。
差分放大电路的计算
计算公式推导，依旧遵循运放的虚短和虚断特性，当R56=R40，R47=R55时，差分计算可以简化为：实际应用电路中，我们为了简化计算，也是用最简方法计算，经常使用的电路也是上述电路，令电阻相等关系，简化计算。
放大电路的"偏移计算"
为什么要对输出电压进行偏移？这是因为当采集负值时，我们的采样芯片和MCU几乎都不支持负值采样的时候，你就必须进行偏移，使得输出总是为正值。偏移电路，如图8，在原来同相端电阻接地GND的地方，我们接一个电压值，通常也称为偏移电压。那么最终表达式是什么？
通过叠加定理最终得到：
这里公式的成立，保证R64=R72，R73=R57，那么最终得到偏移公式是在原来基础上加个电压偏移量2.5V_Ref：
只要根据实际应用选择合适的偏移量，输出总会为一个正值。
比如，上图电路，输入电压变为-100V，那么最终输出电压就为：这样就将负电压偏移为正电压，处理器符合处理器处理要求了，偏移电路在采集如交流电、以及存在负直流电压的控制电路中广泛使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aaec16dc43b4295d3a559189740f23f0/" rel="bookmark">
			kafka中，使用ack提交时，存在重复消费问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ack提交时，存在重复消费？？ 往consumer监听的topic中，增加了一条数据，但是代码消费了好几次，而且确实也走ack.acknowledge();这块逻辑了，因为处理的逻辑是要入库的，导致数据多了好几条，后排查得知是配置问题
…
spring.kafka.consumer.enable-auto-commit=true
spring.kafka.consumer.auto-offset-reset=latest
代码是刚拿到手，没有注意这块配置问题，因为上述配置导致重复消费，改成下面这种就可以了
…
spring.kafka.consumer.enable-auto-commit=false
spring.kafka.consumer.auto-offset-reset=latest
原因：一旦设置了 enable.auto.commit 为 true，Kafka 会保证在开始调用 poll 方法时，提交上次 poll 返回的所有消息。从顺序上来说，poll 方法的逻辑是先提交上一批消息的位移，再处理下一批消息，提交顺序问题导致重复消费
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/496f6b669fd567f25211fec325475e89/" rel="bookmark">
			清华大佬亲自推荐的爆笑python漫画，236万人在学，作者：学不会我退出编程界
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 说起编程语言，Python 也许不是使用最广的，但一定是现在被谈论最多的。随着近年大数据、人工智能的兴起，Python 越来越多的出现在人们的视野中。
在各家公司里，Python 还常被用来做快速原型开发，以便更快验证产品概念。而众多极客也把 Python 作为实现自己天马行空想法的神兵利器。
有着如此广泛的应用，再加上简单易懂的语法，使得 Python 成为一门既适合初学，又值得深入的语言。 即使不是程序员，能用 Python 写上一小段程序，调用几个接口，也能极大提升工作效率。所以连 C++ 大牛 Bruce Eckel 也要感叹：
Life is short, you need Python
人生苦短，你需要 Python
由此来看，Python 越来越热也是情理之中的事情。以致于现在各行各业都有人不断的加入到Python的学习潮流之中，但是对于想要入门Python的同学仍一头雾水，虽然网上的资料很多，但是很多资料都比较片面化，且很多是纯文字文档，对于一些想要自学转行或是刚入门的同学不太友好。
今天给大家分享一份由华为官方出品的《看漫画学Python》，本书作者对每一幅漫画表达的准确性也进行了反复推敲，向广大读者奉献一本精品漫画Python技术书。
适用人群： 无论您是计算机相关专业的大学生，还是正在从事软件开发的职场人，甚至是完全零基础的外行小白，本书都适合您阅读和学习。
总共495页，其中包含数据类型的数据、运算符、程序流程控制、字符串、函数、文件读写和多线程等内容, 任何人都可以阅读和学习,建议拿过去学习一下！以下是这份资料的部分内容截图展示。
由于篇幅原因，需要完整PDF电子版的小伙伴，可以在文末免费获取！
目录 邮箱加满！准备出发！编程基础的那点事数字类型的数据运算符程序流程控制容器类型的数据字符串函数类与对象异常处理 数字类型的数据 Python中的数据类型整数类型浮点类型复数类型布尔类型数字类型的相互转换 由于篇幅原因，所有章节就不一一截图展示，上述这份完整版的Python全套学习资料已经上传CSDN，朋友们如果需要可以微信扫描下方CSDN官方认证二维码免费领取【保证100%免费】
函数 定义函数调用函数参数的默认值可变参数函数中变量的作用域函数类型Lambda函数 常用的内置模块 数学计算模块日期时间模块正则表达式模块如何使用官方文档查找模块帮助信息 访问数据库 字符串 字符串的表示方式字符串与数字的相互转换格式化字符串操作字符串动动手——统计英文文章中单词出现的频率练一练 第8章 函数 定义函数调用函数参数的默认值可变参数函数中变量的作用域函数类型lambda（）函数动动手——使用更多的lambda（）函数练一练 第9章 类与对象 面向对象定义类创建对象类的成员封装性继承性多态性练一练 第10章 异常处理 第一个异常——除零异常捕获异常使用finally代码块释放资源自定义异常类动动手——手动引发异常练一练 第11章 常用的内置模块 数学计算模块——math日期时间模块——datetime正则表达式模块——re点拨点拨——如何使用官方文档查找模块帮助信息练一练 第12章 文件读写 打开文件关闭文件读写文本文件动动手——复制文本文件读写二进制文件动动手——复制二进制文件练一练 第13章 图形用户界面 Python中的图形用户界面开发库安装wxPython第一个wxPython程序自定义窗口类在窗口中添加控件事件处理布局管理控件点拨点拨——如何使用wxPython官方文档练一练
… 资料领取 这份完整版的Python全套学习资料已经上传网盘，朋友们如果需要可以点击下方微信卡片免费领取 ↓↓↓【保证100%免费】 或者
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/496f6b669fd567f25211fec325475e89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94a969f65bc22f67987c98080f02998a/" rel="bookmark">
			Python最强IDE PyCharm详细使用指南？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本篇文章主要给大家介绍下Pycharm的使用与详细配置。
Pycharm创建项目和Python文件 我们使用Pycharm开发工具编写Python，首先是要先创建项目，然后在项目中创建包或者Python文件。双击安装好的Pycharm
如果在已经打开的项目中创建新的项目，按照下方方式操作
接下来会出现如下弹窗，填入项目名称和选择解释器（第一次创建默认是新的虚拟环境），最后点击Create
创建完成之后出现左侧的项目浏览目录，此时可以选择新建Python文件或者Python包
如果要创建Python文件
输入完名字后回车即可创建Python文件（PyCharm 会自动添加后缀 .py），可以在新建的Python文件中输入简单的Python代码进行测试
运行代码，可以在Python页面点击右键，选择Run 你的文件名运行代码
运行代码也可以选择菜单栏的Run运行代码，点击Run... ,然后选择要运行的文件即可
如果你运行过程序也可以点击右上侧的按钮完成
快捷键：Shift + F10 同样也可以运行你的代码哦！
Pycharm相关设置 主题设置
Pycharm的主题风格是指包含整体风格 、字体、背景颜色、背景图片等相关的整体设置。 点击 Appearance &amp; Behavior -----&gt; Appearance，设置 IDE 主题 （Theme），推荐 Darcula（就是当前大家看到的这个黑色背景的），点击右下角的Apply进行应用
字体相关设置
默认的字体大小是13（当前版本），这个字号个人感觉对于长时间对着屏幕的编程者来说有点太小了，可以进行设置。
点击 Editor ------&gt; Font 设置代码编辑器的字体和字号
字体 (Font) 推荐使用 Droid Sans Mono，个人比较喜欢，字号 (Size) 推荐设置为15，默认的有点偏小。
如果想还设置主题的颜色显示，可以选择 Editor ----&gt; Color Scheme 设置,代码编辑器样式 (Color Scheme)，推荐 Monokai(如果 PyCharm 安装完成后，第一次启动时错过了设置，可以在这里做)
快捷键设置 快捷键的设置在Keymap中，点击Keymap，右侧的下拉框中会出现三种快捷键的选项，每一种具体的快捷键内容都可以在下面窗口进行具体的查看。
如果默认的不能满足需求，也可以点击Gets more keymaps in settings ｜Plugins进行下载
下载完成之后，在Keymap中的选择就会更多了，默认是Windows，如果Eclipse这款软件的快捷键你更加熟悉，可以选择Eclipse 的快捷键组合。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94a969f65bc22f67987c98080f02998a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cc1d16573ae34df0f8c0fb19652cf91/" rel="bookmark">
			知乎神回复：计算机还能火多久呢？它能够成为永远滴神吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 师范，永远滴神；
医学，永远滴神；
公务员，永远滴神；
法学，永远滴神；
是的，在知乎上吹师医公，吹法律，吹体制内；但这都是站在中产家庭的情况下说的。
对于农村贫困家庭，师医公法恐怕都不是最明智的选择，对于穷人家的孩子，需要钱就去赚钱，用钱去解决家庭中的问题。对于穷人家的孩子，年轻的时候需要钱买房结婚，家里帮不上忙，只能靠自己。师医公法这些后期型职业，恰恰年轻时给不了穷人家孩子太多帮助。
起薪给年轻人最多的恐怕就是计算机了。而且起薪还有不断提高的趋势。年轻时干互联网，挣笔钱作为人生的启动资金，到了三十来岁考公上岸或者转进金融机构it部门，也是不错的规划。
至于互联网大厂高薪还能火多久，我再复述一遍我的雇佣兵理论：
首先，很多人没有理解程序员的本质，虽然程序员自黑自己是码农，但程序员性质并不接近农民，而是更接近雇佣兵。
现在互联网从增量时代进入存量时代。大家都没有办法把蛋糕做大了，就只能相互抢对方的蛋糕了。要想抢蛋糕就必须要有能打仗的雇佣兵军团，因为计算机行业的“人月神话”，单纯堆人数并没有办法提高战斗力，提高战斗力的最佳方式是提高单兵素质。
但中国互联网大厂的兵源非常有限，基本就中游以上985+两电一邮，大多数互联网大厂员工都是这样的出身背景。
一方面，至于为啥不扩大学校范围，我觉得一大原因是其他大学计算机教育的水平实在太差了，远远无法满足大厂的需求。
一方面，兵源学校的计算机类专业扩招非常有限。哈工大现在的计算机类专业毕业生数量和十年前本差不多。
我整理了一些学习Python的视频教程，有兴趣或者正在学习的小伙伴可以去看一看，或许对你有帮助！
零基础Python学习资源介绍 👉Python学习路线汇总👈 Python所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。（全套教程文末领取哈）
👉Python必备开发工具👈 温馨提示：篇幅有限，已打包文件夹，获取方式在：文末
👉Python学习视频600合集👈 观看零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
👉Python基础👈 👉Python自动化办公教程👈 👉python爬虫 👈 👉python机器学习 👈 👉实战案例👈 光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
👉100道Python练习题👈 检查学习结果。
👉面试刷题👈 资料领取 这份完整版的Python全套学习资料已经上传网盘，朋友们如果需要可以点击下方微信卡片免费领取 ↓↓↓【保证100%免费】 或者
【点此链接】领取
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16830696b040ba97d755d1776d7c4da9/" rel="bookmark">
			深入剖析pcap中的网络异常：TTL过期攻击、ARP中毒、TCP重传与重叠碎片等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络流量数据包捕获是网络安全领域的重要部分，而pcap文件则是这一过程的常见载体。为了深入解析pcap文件中潜在的可疑网络流量，我们需要运用强大的网络安全威胁评估与审计工具。这些工具能够帮助我们捕捉、记录、检测和诊断网络中的数据传输问题，及时发现异常活动，保护我们的网络安全。
在处理pcap文件时，我们主要关注的是那些可能表明潜在威胁的特征。例如，TTL（Time To Live）过期攻击是一种常见的网络攻击方式，除此之外，ARP（Address Resolution Protocol）中毒也是一种常见的网络威胁，TCP重传是一种利用TCP协议缺陷进行的攻击，重叠碎片攻击是一种利用IP分片漏洞进行的攻击，除了以上提到的几种攻击方式外，我们还需要关注多个TTL值的问题等等。
TTL过期攻击
TTL（Time to Live）是IP包中的一个字段，它表示数据包在网络中能够存活的最长时间，一般以秒为单位。当一个数据包经过一个路由器时，该路由器会将数据包的TTL字段减1，当TTL减为0时，路由器会丢弃该数据包。TTL过期攻击是指攻击者发送大量的IP数据包，并设置TTL为较小的值，以达到消耗目标主机资源的目的。这类攻击主要是利用目标主机处理TTL减少的数据包需要耗费更多的处理资源，从而导致目标主机的性能下降甚至崩溃。应对策略：网络管理员可以通过设置防火墙等安全设备，限制传入的TTL值，并进行流量监控和流量分析，及时发现异常流量并采取相应的措施。 ARP中毒
ARP协议（Address Resolution Protocol）是将IP地址解析成MAC地址的一种协议。ARP中毒攻击是指攻击者伪造ARP响应包，欺骗目标主机与攻击者主机之间的通信流量。攻击者通常会向目标主机发送虚假的ARP响应包，将目标主机的IP地址与攻击者的MAC地址绑定，从而导致目标主机的通信流量被重定向到攻击者主机。应对策略：网络管理员可以使用安全工具对局域网中的ARP响应进行检测和监控，定期清除异常的ARP缓存，限制ARP协议的使用，以及使用静态ARP表进行MAC地址与IP地址的绑定。 TCP重传与重叠碎片
TCP重传是指在数据包传输过程中，某个数据包丢失或未及时到达目标主机，发送方会重新发送该数据包。TCP重叠碎片是指MTU（Maximum Transmission Unit）大小限制导致的数据包分片，在发送方和接收方之间重新组装的过程中，发生了重叠。TCP重传和重叠碎片可能会导致网络延迟增加、传输速率降低，甚至数据丢失。应对策略：网络管理员可以通过调整TCP的超时重传时间、优化网络拓扑结构和路径，或通过升级硬件设备来减少重传和重叠碎片的发生。 多个TTL值的识别与应对
在进行数据包分析时，可能会遇到多个不同的TTL值，这可能是由于同一个数据包经过了不同的网络节点。识别多个TTL值可以帮助定位网络中的故障点或恶意行为。应对策略：网络管理员可以使用网络监控工具进行数据包的抓取和分析，识别不同TTL值的源头和节点，进而定位异常的网络流量和行为，采取相应的防御措施。 深入剖析pcap中的网络异常：TTL过期攻击、ARP中毒、TCP重传与重叠碎片等(C/C++代码实现)
void my_packet_handler(u_char *args,const struct pcap_pkthdr *header,const u_char *packet); int help(); void activate_verbose(); void activate_debug(); void activate_linux_cooked(); void analysis(char* file_in, char* file_out); void print_flag(int flag); void print_flag_json(FILE *fp, int flag); void exclude(char* excl); void save_json(char* filename); /* Ethernet header */ struct sniff_ethernet { u_char ether_dhost[D_HOST_MAC_ADDR]; /* destination host address */ u_char ether_shost; /* source host address */ u_short ether_type; /* IP?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16830696b040ba97d755d1776d7c4da9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3ae6bd2a8fb3a38796daf6312f13d5c/" rel="bookmark">
			STM32 JLINK SWD调试器手动复位才能烧写的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32 JLINK SWD调试器手动复位才能烧写的问题 Chapter1 STM32 JLINK SWD调试器手动复位才能烧写的问题 Chapter1 STM32 JLINK SWD调试器手动复位才能烧写的问题 原文链接：https://blog.csdn.net/denghuajing/article/details/121649667
问题
只有手动复位的情况下，才能进行烧写。板子使用的是SWD调试口？
SWD需不需要reset pin？STM32CubeMX的程序就有问题？
为什么烧录程序一次后就无法连接调试器烧录，一定要手动复位？
连接不上调试器？
SWD调试口一般来说需要4条线 V+（3.3）GND SCLK SWIO
标准SWD 无需reset Pin！
调试器和MCU连接烧录的时候，会对CPU或者外设进行reset动作，这个动作在没有reset pin的时候是通过发送指令进行的。
MDK中关于reset的设置比较复杂一般使用normal，如果有兴趣可以通过下链接了解
官方的说明 这里
如果我们使用的代码对SWD口进行了一些配置，导致reset指令无法通过SWD口接收的话，调试器就无法reset MCU。这样只能手动复位，而且时机很难把握。解决办法就是不要复用SWDIO 口，否则使用reset pin。
综上，SWD调试口如果需要复用端口，需要使用reset pin。
SWD的PIN 专用，不用resret pin
手动写代码的时候，SWDIO我们可以自己把握，不去配置就可以用，所以一般来说都在掌控中。
但是在STM32CubeMX 如果不打开SWD口，会导致烧录过一次程序后，无法自动烧录的问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65103f088d735e307ca14fa7039fbba8/" rel="bookmark">
			HPM6750开发笔记《DMA接收和发送数据UART例程深度解析》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
概述：
端口设置：
代码分析：
运行现象：
概述： DMA（Direct Memory Access）是一种计算机系统中的数据传输技术，它允许数据在不经过中央处理器（CPU）的直接控制下在内存和外设之间传输。UART（Universal Asynchronous Receiver/Transmitter）是一种串行通信协议，用于在设备之间传输数据。
在DMA接收和发送数据的情况下，DMA可以用于管理UART通信中的数据传输。具体来说：
DMA接收数据：
当UART接收到数据时，通常会触发中断来通知CPU。使用DMA时，DMA控制器可以直接从UART接收缓冲区中读取数据，并将其存储到内存中，而无需CPU的干预。这允许在数据到达时实现高效的数据传输，减轻了CPU的负担。 DMA发送数据：
当需要通过UART发送数据时，通常需要将数据写入UART的发送缓冲区，并等待发送完成。使用DMA时，DMA控制器可以直接从内存中获取要发送的数据，并将其传输到UART发送缓冲区，而无需CPU的干预。这提高了数据传输的效率，因为CPU可以继续执行其他任务而无需等待数据发送完成。 总的来说，DMA在UART通信中的应用可以提高数据传输的效率，减少对CPU的依赖，使系统能够更有效地处理数据。
端口设置： 波特率115200 1位停止位 无奇偶校验
代码分析： 包含了一些头文件，包含了与底层硬件和外设驱动相关的定义和函数声明
义了一些与UART相关的宏，如UART的基地址、时钟名、DMA请求等
声明了两个全局变量 uart_tx_dma_done 和 uart_rx_dma_done，用于表示UART的发送和接收DMA是否完成
#include "board.h" #include "hpm_clock_drv.h" #include "hpm_uart_drv.h" #ifdef CONFIG_HAS_HPMSDK_DMAV2 #include "hpm_dmav2_drv.h" #else #include "hpm_dma_drv.h" #endif #include "hpm_dmamux_drv.h" #include "hpm_l1c_drv.h" #include "hpm_common.h" #define TEST_UART BOARD_APP_UART_BASE #define TEST_UART_CLK_NAME BOARD_APP_UART_CLK_NAME #define TEST_UART_TX_DMA_REQ BOARD_APP_UART_TX_DMA_REQ #define TEST_UART_RX_DMA_REQ BOARD_APP_UART_RX_DMA_REQ #define TEST_UART_DMA_CONTROLLER BOARD_APP_HDMA #define TEST_UART_DMAMUX_CONTROLLER BOARD_APP_DMAMUX #define TEST_UART_TX_DMA_CHN (0U) #define TEST_UART_RX_DMA_CHN (1U) #define TEST_UART_TX_DMAMUX_CHN DMA_SOC_CHN_TO_DMAMUX_CHN(TEST_UART_DMA_CONTROLLER, TEST_UART_TX_DMA_CHN) #define TEST_UART_RX_DMAMUX_CHN DMA_SOC_CHN_TO_DMAMUX_CHN(TEST_UART_DMA_CONTROLLER, TEST_UART_RX_DMA_CHN) #define TEST_UART_DMA_IRQ BOARD_APP_HDMA_IRQ #define TEST_BUFFER_SIZE (16U) ATTR_PLACE_AT_NONCACHEABLE uint8_t uart_buff[TEST_BUFFER_SIZE]; volatile bool uart_tx_dma_done; volatile bool uart_rx_dma_done; hpm_stat_t uart_tx_trigger_dma(DMA_Type *dma_ptr, uint8_t ch_num, UART_Type *uart_ptr, uint32_t src, uint32_t size) { dma_handshake_config_t config; dma_default_handshake_config(dma_ptr, &amp;config); config.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65103f088d735e307ca14fa7039fbba8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2b2b3e35d6bc79e7f773c9bbffa767f/" rel="bookmark">
			为什么现在Python在量化交易中这么火？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Python作为发展较快的编程语言，可以让程序员更加高效地工作和集成系统。Python的语法也是优先考虑了可读性，同时支持较少的代码行。
一般来说，Python语言是中低端量化交易平台最普遍的选择。中低端量化交易平台，支持复杂度不高的脚本语言实现策略逻辑，多数是在图表上加载技术指标，进行自动化交易的。
01、Python在量化领域的现状 和Java在web领域无可撼动的地位一样，Python也已经在金融量化投资领域占据了重要位置，从各个业务链条都能找到相应的框架实现。
在量化投资（证券和比特币）开源项目里，全球star数排名前10位里面，有7个是Python实现的。从数据获取到策略回测再到交易，覆盖了整个业务链。
而全球注册用户数最多的商业量化平台Uqer优矿，也同样是基于Python实现和提供服务的。可见Python在量化平台应用的绝对占有程度。
Python是数字华尔街上一颗冉冉升起的新星,Python非常适合开发分析工具和数量分析模型,这些分析工具和模型对于投资银行和对冲基金的交易策略来说至关重要。
02、Python为什么发展这么快 Python，由程序员Guido van Rossum，于1989年圣诞假期着手开发，在1991年，初代版本面世。从1991年到2014年，Python名不见经传，却在2014年之后爆发式发展，大器晚成。
Python的火爆很大程度上是由于移动互联网的发展，信息量和数据量大幅增加，从而带动了对大数据的处理需求，并推动了人工智能技术的发展，而Python则搭上了大数据和人工智能的快车。
但同样是大数据和人工智能的爆发，为什么搭上这趟快车的是Python，而不是其他语言，这就要从Python的核心优势讲起。
03、python的核心优势 Python是一种高级、解释，交互式和面向对象的脚本语言。Python的设计具有高可读性。它经常使用英语关键词，而其他语言使用标点符号，并且它的语法结构比其他语言少。
动态类型、内置数据结构、功能强大的库、框架和社区支持都是 Python吸引快速开发任何应用的几个方面。
与其他语言相比，Python 有以下特性：
（1）易于编程
Python是所有完整的计算机语言中最简单的，这点是Python的核心优势。同样的功能，用C++可能需要1000行代码，用JAVA需要300行代码，而用Python最多50行搞定。对于量化公司，Python满足了策略快速迭代的需求。
（2）开源
Python编程语言的特点之一就是开源，每个人都可以构建和修改它。并且在大数据处理和人工智能方面有更丰富的库可供调用，完全免费。
Matlab能不能实现的功能，Python都可以实现。量化基金公司纷纷转向Python，直接省下了每年几十万元的软件费用。
（3）GUI编程支持
Python可以使用 PyQt5、PyQt4、wxPython等模块来创建图形用户界面。
Python为设计图形用户界面提供了很多可能性。Tkinter是最常用的GUI技术，它是Python提供的Tk GUI工具包的一个标准Python接口。
用户界面通常包括诸如图标、按钮、图形、显示文本等视觉元素，以及各种输入手段，如复选框、文本输入框等等。使用Python编程语言，以及快捷、省力的图形工具，使得构建用户界面应用非常容易。
（4）支持高级语言
Python支持高级语言。当编写Python程序时，不需要回忆机器结构或操作内存。在很多方面的应用中，它的设计理念首先要考虑代码的可读性。它的语言元素和面向对象的方法，其目的是帮助程序员为小型和大型项目，编写清晰的、有逻辑的代码。
（5）可扩展性
可扩展性是属于Python的特性之一。可以将以其他语言编写的代码包含在你的 Python源代码中，例如C++。
Python是一种可扩展的语言，这意味着它可以被扩展到其他语言。Python可扩展的特性是指Python的部分代码可以用C或C++来编写。这可以让Python和其他语言开发的库连接起来。
（6）可移植性
Python是一种跨平台的编程语言，这意味着建立在Window环境、或Mac OSX上的Python应用程序，可以在Linux操作系统上运行，反之亦然。
只需安装Python解释器，Python程序就可以在各种系统上运行，包括 Windows、Linux、Unix和Macintosh。
（7）解释性语言
有些编程语言有两种类型的代码转换器用于语言转换。即解释器和编译器。编译器会编译整个程序，而解释器会逐行转换代码。
Python使用了解释器，这意味着它的代码是逐行执行的。不同于C、C++、Java等其他编程语言。Python的代码无需编译，因此更易于调试。Python的源代码被转换为字节码，是代码的实例化。
（8）面向对象程序设计语言
面向对象程序设计语言，可以对现实世界进行建模，集成了数据和函数。另一方面，面向过程的语言围绕着函数展开，函数是可重复使用的代码片段。
Python同时支持面向过程和面向对象的编程。与Java不同，它还允许多重继承。
（9）其他特性
Python有几种侧重于答案而非语法的结构；Python也可以作为脚本语言使用，或者编译成用于开发大型应用程序的字节码；支持动态类型验证，并提供非常高级的动态数据类型；会自动支持垃圾收集；Python能与C、C++、COM、ActiveX、CORBA和Java无缝集成。
总的来说，Python是一门比较全面与平衡的语言，面对中低门槛的量化平台。既能满足包括中大型系统应用的开发，又能满足数据统计分析等数学领域的计算需求，同时也能与其它开发语言互通融合。
在数据量化分析、金融数据处理方面，Python既能精于计算又能保持性能，对于时间序列数据的处理展现了简单便捷的优势。
读者福利：知道你对Python感兴趣，还准备了这套python学习资料
对于0基础小白入门：
如果你是零基础小白，想快速入门Python是可以考虑的。
一方面是学习时间相对较短，学习内容更全面更集中。
二方面是可以找到适合自己的学习方案
包括：Python永久使用安装包、Python web开发，Python爬虫，Python数据分析，人工智能、机器学习等学习教程。带你从零基础系统性的学好Python！
零基础Python学习资源介绍 👉Python学习路线汇总👈 Python所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。（全套教程文末领取哈）
👉Python必备开发工具👈 温馨提示：篇幅有限，已打包文件夹，获取方式在：文末
👉Python学习视频600合集👈 观看零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
👉实战案例👈 光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
👉100道Python练习题👈 检查学习结果。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2b2b3e35d6bc79e7f773c9bbffa767f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b78a39b704fa7bcfaf7177afb4295ef/" rel="bookmark">
			MyBatisPlus学习三：Service接口、代码生成器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习教程 黑马程序员最新MybatisPlus全套视频教程，4小时快速精通mybatis-plus框架
Service接口 简介
在MyBatis-Plus框架中，Service接口的作用是为实体类提供一系列的通用CRUD（增删改查）操作方法。通常情况下，Service接口中的方法会对应数据库表中的操作，例如插入一条数据、根据主键查询数据、更新数据等。
Service接口与继承BaseMapper的区别在于，Service接口封装了一些常用的数据库操作方法，使得开发者可以直接调用这些方法，而不需要自己手动编写SQL语句和操作数据库。这样可以减少开发者的工作量，并提高开发效率。
另外，Service接口还可以定义一些业务相关的方法，例如根据条件查询数据、批量插入数据等。这些方法可以根据具体的业务需求来定义，提供了更加灵活的操作方式。
而继承BaseMapper接口，则是为了实现自定义的数据库操作方法。通过继承BaseMapper接口，可以使用MyBatis-Plus提供的一系列的数据库操作方法，例如插入、更新、删除等。这样可以方便地使用MyBatis-Plus的功能，并减少手动编写SQL语句的工作量。
总之，Service接口和继承BaseMapper接口都是为了简化数据库操作的方式，提高开发效率，并提供了一些常用的数据库操作方法。具体使用哪种方式，可以根据具体的业务需求和开发习惯来选择。
基本步骤
1、需要有一个自己的Service接口，这个接口要继承
UserService
// 自定义的接口，继承mybatis-plus中的IService接口 public interface UserService extends IService&lt;User&gt; { } 2、对自己的Service接口进行继承并实现
UserServiceImpl
// 1、继承mybatis-plus提供的Service实现类，指定对应的mapper接口和实体类 // 2、继承自定义的UserService接口 // 3、添加上@Service注解 @Service public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService { } 3、使用mybatis-plus实现好的方法进行查询
UserController
@Controller public class UserController { @Autowired private UserService userService; @RequestMapping("/userlist") @ResponseBody public List&lt;User&gt; selectAllUser() { // 查询所有用户，调用mybatis-plus实现的方法 List&lt;User&gt; users = userService.list(); return users; } } 文件梳理
现有文件如下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b78a39b704fa7bcfaf7177afb4295ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07273e67af02b5b2bf0287ce60f78580/" rel="bookmark">
			50行Python代码实现自动下载小说，并打包exe直接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 室友喊着没有小说看，让我给他推荐几本，这能难倒我？
分分钟就用python给他把整个网站的小说都给下载下来了，不愧是我啊！
话不多说，我们直接开整！ （文末送读者福利）
要准备的东西
软件
python 3.8 pycharm 使用的模块
requests &gt;&gt;&gt; pip install requests 数据请求 parsel &gt;&gt;&gt; pip install parsel 数据解析 (完善功能) 添加搜索功能 搜索小说名字或者作者名字 tqdm &gt;&gt;&gt; pip install tqdm 下载进度条显示模块 pandas &gt;&gt;&gt; pip install pandas 输入的格式好看一些 win + R 输入cmd 输入安装命令 pip install 模块名 ；
如果出现爆红，可能是因为，网络连接超时，切换国内镜像源；
黄色是警告 ，可以忽略；
输入小说名下载
打包成exe程序, 是需要安装 pyinstaller ，命令提示符窗口输入 pip install pyinstaller
代码展示 # 导入数据请求模块 import requests # 导入数据解析模块 import parsel # 导入正则表达式模块 import re # 导入pandas import pandas as pd # 导入进度条显示模块 from tqdm import tqdm while True: key_word = input('请输入你想要下载的小说名字(输入0即可退出): ') if key_word == '0': break search_url = f'https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07273e67af02b5b2bf0287ce60f78580/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d76c06839499dc19e7c23f73e19b408/" rel="bookmark">
			CTF 逆向涉及的各种加密算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		rc4 原理研究 在密码学中，RC4（来自 Rivest Cipher 4 的缩写）是一种流加密算法，密钥长度可变。它加解密使用相同的密钥，因此也属于对称加密算法。RC4 是有线等效加密（WEP）中采用的加密算法，也曾经是 TLS 可采用的算法之一。RC4 算法的原理非常简单，包括初始化算法（KSA）和伪随机子密码生成算法(PRGA)两大部分。
RC4 算法流程简单实现 1. 1-256 初始化 S-Box 和临时向量 T
for i in range(0,255):S[i]=iT[i]=K[imodkeylen] 2.初始排列 S-Box 并作乱序处理
j=0for i in range(0,255):j=(j+S[i]+T[i]) %256swap(s[i],s[j]) 3.生成密钥流 len:明文为 len 个字节 int i=0,j=0,t;while(len--)i=(i+1)%256;j=(j+S[i])%256;S[i]=S[i]+S[j];S[j]=S[i]-S[j];S[i]=S[i]-S[j];t=(S[i]+S[j])%256;k.push_back(S[t]); 将子密钥序列同明文进行异或得到密文
Data[k]^=S[T] RC4 算法流程简单总结 可能这样还是不便于理解，我们简单来写就是：
1、先初始化状态向量 S（256 个字节，用来作为密钥流生成的种子 1）
按照升序，给每个字节赋值 0,1,2,3,4,5,6.....,254,255
2、初始密钥（由用户输入），长度任意
如果输入长度小于 256 个字节，则进行轮转，直到填满
例如输入密钥的是 1,2,3,4,5 , 那么填入的是 1,2,3,4,5,1,2,3,4,5,1,2,3,4,5........
3、开始对状态向量 S 进行置换操作（用来打乱初始种子 1）
按照下列规则进行：
从第零个字节开始，执行 256 次，保证每个字节都得到处理,确保处理后的状态向量 S 带有一定的随机性。
j = 0;for (i = 0 ; i &lt; 256 ; i++){j = (j + S[i] + T[i]) mod 256;swap(S[i] , S[j]);} 4、密钥流的生成与加密
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d76c06839499dc19e7c23f73e19b408/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0208b99c9bb487cbb366c1b57c14151/" rel="bookmark">
			表哥推荐python自学书籍：从入门到精通，读这十本书就够了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 人生苦短，我学python。
python编程语言在各种榜单上经常拿到前列位置，在全球范围内都非常受欢迎。
Python作为一种不受局限、跨平台的开源编程语言，其数据处理速度快、功能强大且简单易学。而且，Python采用解释运行的方式，编写后无需进行编译即可直接通过解释器执行，具有典型的动态语言特点，编程效率极高。
不仅如此，Python的应用范围也非常广泛，在数据分析、人工智能、网络爬虫、运维测试都多个领域都有应用。
想要入门和深入学习python，以下书籍不容错过！
Python编程：从入门到实践（第2版） 中文版重印30余次，热销100万册
针对Python 3新特性升级，重写项目代码
真正零基础，自学也轻松
配套学习视频，边看边学更便捷
简介：本书是针对所有层次Python读者而作的Python入门书。全书分两部分：第一部分介绍用Python编程所必须了解的基本概念；第二部分将理论付诸实践，讲解如何开发三个项目，并帮助读者解决常见编程问题和困惑。
Python3网络爬虫开发实战（第2版） Python 之父 Guido van Rossum 强力推荐
爬虫入门书，第 1 版销量近 100000 册
微软中国大数据工程师、博客文章过百万的静觅大神力作
简介：本书介绍了如何利用 Python 3 开发网络爬虫。本书为第 2 版，相比于第 1
版，为每个知识点的实战项目配备了针对性的练习平台，避免了案例过期的问题。另外，主要增加了异步爬虫、JavaScript 逆向、App
逆向、页面智能解析、深度学习识别验证码、Kubernetes
运维及部署等知识点，同时也对各个爬虫知识点涉及的请求、存储、解析、测试等工具进行了丰富和更新。
流畅的Python PSF研究员、知名PyCon演讲者心血之作，Python核心开发人员担纲技术审校
全面深入，对Python语言关键特性剖析到位
大量详尽代码示例，附有主题相关高质量参考文献
兼顾Python 3和Python 2
简介：本书致力于帮助Python开发人员挖掘这门语言及相关程序库的优秀特性，避免重复劳动，同时写出简洁、流畅、易读、易维护，并且具有地道Python风格的代码。本书尤其深入探讨了Python语言的高级用法，涵盖数据结构、Python风格的对象、并行与并发，以及元编程等不同的方面。
Python基础教程（第3版） 久负盛名的Python入门经典
中文版累计销量200 000+册
针对Python 3全新升级
简介：本书层次鲜明、结构严谨、内容翔实，特别是后面几章，作者将前面讲述的内容应用到10个引人入胜的项目中，并以模板的形式介绍了项目的开发过程，手把手教授Python编程实践，让读者从项目中领略Python的真正魅力。本书既适合初学者夯实基础，又能帮助Python程序员提升技能，即使是中高级Python程序员，也能从书里找到耳目一新的内容。
父与子的编程之旅 与小卡特一起学Python（第3版） Python编程启蒙畅销书全新升级
为希望尝试亲子编程的父母省去备课时间
问答式讲解，从孩子的视角展现逻辑思维过程
全彩印刷，插图生动活泼
简介：编程是一项充满乐趣的挑战，想上手非常容易！在本书中，沃伦和卡特父子以亲切的笔调、通俗的语言，透彻、全面地介绍了计算机编程世界。他们以简单易学的Python语言为例，通过可爱的漫画、有趣的示例，生动地介绍了变量、循环、输入和输出、数据结构以及图形用户界面等基本的编程概念。与第2版不同，第3版的示例使用Python3而不是Python2，另外添加了关于网络的新内容。
Python数据结构与算法分析（第2版） 用Python描述数据结构与算法的开山之作
美亚 4.3 星评
经典计算机科学教材，多家高校采用
实战性极强，示意图形象直观
简介：本书是用Python描述数据结构与算法的开山之作，汇聚了作者多年的实战经验，向读者透彻讲解在Python环境下，如何通过一系列存储机制高效地实现各类算法。通过本书，读者将深刻理解Python数据结构、递归、搜索、排序、树与图的应用，等等。
Excel+Python：飞速搞定数据分析与处理 流行 Python 库 xlwings 创始人亲授
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0208b99c9bb487cbb366c1b57c14151/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e395580d712dc37d222fafcf6cf6c0a/" rel="bookmark">
			#error 在C语言中的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、#error命令是C/C++语言的预处理命令之一 #error 是C语言中的预处理指令之一，用于在编译时生成一个错误消息。当编译器遇到 #error 指令时，会立即停止编译，并将指定的错误消息输出到编译器的错误信息中。
在给定的代码中，#error 是一个空指令，没有提供错误消息。因此，编译器会报告一个空错误消息，并停止编译过程。这通常用于强制要求开发者在特定条件下停止编译，或者提醒开发者注意某些特定的编译配置或条件。
2、举例 #include &lt;stdio.h&gt; //#define SHOW_INFO #ifndef SHOW_INFO #error you must define SHOW_INFO marco. #endif int main(void) { printf("hello world!\n"); getchar(); return 0; } 这里的 #error，用于判断程序是否定义了 SHOW_INFO 这个宏，如果定义了则正常执行；如果未定义，则引起编译器报错，错误提示信息就是 #error 后面的内容。
如图所示（注释掉 SHOW_INFO 宏定义）：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b4402259509ee9fda5aebdb4bad4243/" rel="bookmark">
			零基础python入门书籍推荐读哪些书？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 零基础python入门书籍推荐读哪些书？很多Python 初学者都希望有经验的资深人士能推荐一些入门书籍，于是你就会搜到有网友推荐的超长的入门书单，然而这简直跟没推荐一样。这些书籍并不适合初学者，对于零基础学员看到各种代码就已经头大了。小编整理了一些适合小白学习的零基础python入门书籍分享给大家。（文末送福利，限领50份）
python入门书籍推荐一：《Python基础教程（第2版·修订版）》 这本书是经典的Python入门教程，层次鲜明，结构严谨，内容翔实，特别是最后几章，作者将前面讲述的内容应用到10个引人入胜的项目中，并以模板的形式介绍了项目的开发过程，手把手教授Python开发，让读者从项目中领略Python的真正魅力。这本书既适合初学者夯实基础，又能帮助Python程序员提升技能，即使是Python方面的技术专家，也能从书里找到耳目一新的内容。
python入门书籍推荐二：《Python Cookbook（第3版）中文版》 这本书包含大量实用Python编程技巧和Python黑魔法，对于深入理解Python编程是有很大帮助的，这是一本工具书，每个小节都是围绕着解决问题出发的，强烈推荐！
python入门书籍推荐三：《用Python写网络爬虫》 [澳]理查德 劳森(Richard Lawson) 这本书介绍了如何写网络爬虫，书不厚，但介绍的点多，虽不详细，但对后续深入学习有帮助。
python入门书籍推荐四：《精通Scrapy网络爬虫》 这本书介绍了scrapy异步爬虫框架，除了学习爬虫技巧外，还了解了异步这一机制，对后续异步编程的理解有帮助。
python入门书籍推荐五：《Python算法教程》 算法是计算机中最核心的部分，这本书以python为工具，详细介绍了算法的分析方法及其原理设计，简单易懂，愿意学习python和了解算法的朋友，可以认真读一读，python的算法教程绝对会让你的python编程能力提高一大截。
python入门书籍推荐六： 《Python科学计算(第2版)》 此书详细介绍Python科学计算中最常用的扩展库NumPy、SciPy、matplotlib、Pandas、SymPy、TTK、Mayavi、OpenCV、Cython，涉及数值计算、界面制作、三维可视化、图像处理、提高运算效率等多方面的内容。
python入门书籍推荐七：《Python核心编程（第二版）》(Python领域经典作品、非常有名的开发指南) 这本书出版得有点早，很多内容是以前版本的介绍，但对于整个理解Python还是非常好的一本入门书。
python入门书籍推荐八：《“笨办法”学Python（第3版）》 这是一本Python入门书籍，适合对计算机了解不多，没有学过编程，但对编程感兴趣的初学者使用。这本书结构非常简单，其中覆盖了输入/输出、变量和函数三个主题，以及一些比较高级的话题，如条件判断、循环、类和对象、代码测试及项目的实现等。每一章的格式基本相同，以代码习题开始，按照说明编写代码，运行并检查结果，然后再做附加练习。这本书以习题的方式引导读者一步一步学习编程，从简单的打印一直讲授到完整项目的实现，让初学者从基础的编程技术入手，最终体验到软件开发的基本过程。
知道你对Python感兴趣，便准备了这套python学习资料，毕竟小编也是用这套方法自学并成功上岸的
对于0基础小白入门：
如果你是零基础小白，想快速入门Python是可以考虑培训的。
一方面是学习时间相对较短，学习内容更全面更集中。
零基础Python学习资源介绍 👉Python学习路线汇总👈 Python所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。（学习教程文末领取哈）
👉Python必备开发工具👈 温馨提示：篇幅有限，已打包文件夹，获取方式在：文末
👉Python学习视频600合集👈 观看零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
👉实战案例👈 光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
👉100道Python练习题👈 检查学习结果。
👉面试刷题👈 资料领取 这份完整版的Python全套学习资料已经上传网盘，朋友们如果需要可以点击下方微信卡片免费领取 ↓↓↓【保证100%免费】 或者
【点此链接】领取
好文推荐 了解python的前景：https://blog.csdn.net/weixin_49895216/article/details/127186741
了解python能做什么：https://blog.csdn.net/weixin_49895216/article/details/127124870
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd01ce345dfad5bfa0a13c9af7470e13/" rel="bookmark">
			(15)微信自动化测试-针对微信主窗体的行为控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		应一位药厂的朋友咨询，他说他想知道如何实现下面的功能，都是针对微信主窗体的一些控制！今天我就给他解惑并安排！
微信主窗体是否当前处于最小化。微信主窗体是否隐藏到了系统托盘。最小化微信主窗体。最大化微信主窗体。微信主窗体隐藏到系统托盘后恢复到默认状态。控制微信主窗体移动位置。设置微信主窗体从失去焦点到恢复焦点。 接下来用3个视频演示上面的功能
视频一微信是否最小化，并执行最大化最小化操作
微信最大化最小化操作
视频二设置微信窗体焦点和移动到屏幕某个位置
设置焦点和移动到某个位置
视频三微信是否隐藏到系统托盘并从系统托盘恢复
微信系统托盘操作
以下是演示代码，核心源码比较多，建议收藏联系我获取！
判断微信是否最小化
private void 是否最小化(object sender, EventArgs e) { var result = Win32_WindowMin.Do(WXWin32.GetWeiXin()); if (result) { MessageBox.Show("微信已最小化"); } else { MessageBox.Show("微信未最小化"); } } 设置最小化
private void 最小化(object sender, EventArgs e) { Win32_SetForegroundWindow.Do(WXWin32.GetWeiXin()); Win32_ShowWindow.Min(WXWin32.GetWeiXin()); } 设置最大化
private void 最大化(object sender, EventArgs e) { Win32_SetForegroundWindow.Do(WXWin32.GetWeiXin()); Win32_ShowWindow.Max(WXWin32.GetWeiXin()); } 让微信获得焦点
private void 设置焦点(object sender, EventArgs e) { var id = WXWin32.GetWeiXin(); Win32_SetForegroundWindow.Do(id); } 移动微信主窗体到某个位置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd01ce345dfad5bfa0a13c9af7470e13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1512d02244614d10c455ef5a11b60121/" rel="bookmark">
			gbd调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		gdb /home/xu/ZME/obstacle_map/install/obstacle_map/lib/obstacle_map/obstacle_map_node
set args --ros-args --ros-args --params-file /home/xu/ZME/ChargingPileBackFlushing/install/VMarkTof/share/VMarkTof/config/config.yaml
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0830e79e63c30ab09c534f337df5775/" rel="bookmark">
			如何学好python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学好python的方法： 1、勤加练习，需要多敲代码，记住并且知道怎么使用；
2、看基础讲解的书籍；
3、进阶中高级，需要一些中高级的教程，或者试着解决一些有难度的问题；
4、保持连续性，学习编程比较忌讳学习的过程中经常断；
5、练习搭建项目。
1、勤加练习，对于初学者来说，对于python语言会比较陌生，因为每种语言都有自己的语法，自己的特点，比如python内置了许多的函数，但是需要多敲代码，记住并且知道怎么使用。
2、看基础讲解的书籍，如果你没有过编程经验还想自学python的话，最好买一本基础的书籍看，因为书籍讲的比较系统，比如《python从入门到实践》。
3、进阶中高级，基础学完之后，就可以向中高级进阶了，需要一些中高级的教程，或者试着解决一些有难度的问题，深入了解语言的特性及实现。
4、保持连续性，学习编程比较忌讳学习的过程中经常断，因为变成需要让大脑保持对程序的熟悉和记忆，所以学习python要保持连续性。
5、进入实战，地基建完之后，就需要建楼了，否则搭建地基也没什么用，可以自己搭建一个项目，在项目中遇到的问题会让你有不一样的收获。
6、看牛人代码，因为看别人代码，可以看到别人对问题不一样的解决方式，可以看到不一样的实现方法，可能会让你学到你未曾掌握的知识。
知道你对python感兴趣，所以给你准备了下面的资料
关于Python技术储备 点击链接直达获取资料（安全链接，大家可放心点击）
Python学习路线（2023修正版）附涉及资料《Python学习资料》，已经打包好了，自取【ps：需要领取的资料（请备注清楚，查找与发送给你）】。因链接常https://mp.weixin.qq.com/s/UVxw0daFCgAMFhz9cfrjAQ学好 Python 不论是就业还是做副业赚钱都不错，但要学会 Python 还是要有一个学习规划。最后大家分享一份全套的 Python 学习资料，给那些想学习 Python 的小伙伴们一点帮助！
一、Python所有方向的学习路线 Python所有方向路线就是把Python常用的技术点做整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。
二、学习软件 工欲善其事必先利其器。学习Python常用的开发软件都在这里了，给大家节省了很多时间。
三、入门学习视频 我们在看视频学习的时候，不能光动眼动脑不动手，比较科学的学习方法是在理解之后运用它们，这时候练手项目就很适合了。
四、实战案例 光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
五、面试资料 我们学习Python必然是为了找到高薪的工作，下面这些面试题是来自阿里、腾讯、字节等一线互联网大厂最新的面试资料，并且有阿里大佬给出了权威的解答，刷完这一套面试资料相信大家都能找到满意的工作。
👉 这份完整版的Python全套学习资料已经上传，朋友们如果需要可以扫描下方CSDN官方认证二维码或者点击链接免费领取【保证100%免费】
CSDN2024开年大礼包：《python学习路线&amp;全套学习资料》免费分享
​
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/104de406e524a66d90822170902852f5/" rel="bookmark">
			动态内存管理:malloc free
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//——————1.动态内存管理（内存空间）
共四个函数：malloc free calloc realloc
1. 为什么存在动态内存分配
我们已经掌握的内存开辟方式有：
int val = 20;//在栈空间上开辟四个字节
char arr[10] = { 0 };//在栈空间上开辟10个字节的连续空间
但是上述的开辟空间的方式有两个特点：
1. 空间开辟大小是固定的（不够方便）。
2. 数组在声明的时候，必须指定数组的长度，它所需要的内存在编译时分配。
但是对于空间的需求，不仅仅是上述的情况。有时候我们需要的空间大小在程序运行的时候才能知道，那数组的编译时开辟空间的方式就不能满足了。
这时候就引入了动态内存开辟。
——————2动态内存函数的介绍
2.1 malloc和free
malloc:头文件是&lt;stdlib.h&gt; 或&lt;malloc.h&gt;
C语言提供了一个动态内存开辟的函数：
void* malloc (size_t size);
这个函数向内存申请一块连续可用的空间，并返回指向这块空间的指针。
如果开辟成功，则返回一个指向开辟好空间的指针。
如果开辟失败，则返回一个NULL指针，因此malloc的返回值一定要做检查。
返回值的类型是 void* ，所以malloc函数并不知道开辟空间的类型，具体在使用的时候使用者自己进行强制类型转换来决定。
如果参数 size（申请字节的大小） 为0，malloc的行为是标准是未定义的，取决于编译器。
C语言提供了另外一个函数free（与malloc对应），专门是用来做动态内存的释放和回收的，函数原型如下：
void free(void* ptr);
free函数用来释放动态开辟的内存。
1.如果参数 ptr 指向的空间不是动态开辟的，那free函数的行为是未定义的。
//#include&lt;stdio.h&gt;//程序会报错
//int main()
//{
// int a = 1;
// int* p = &amp;a;
// free(p);
// p = NULL;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/104de406e524a66d90822170902852f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/746cd72ece4bea85e1be483ff7514e11/" rel="bookmark">
			Oracle VM VirtualBox xx needs the Micrsoft Visual C&#43;&#43; 2019错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误展示 解决方法 重修安装 Visual C++ 文件
1、前往官网 C++ 中 Windows 编程概述 | Microsoft Learn
2、找到对应的包 左边导航栏依次选择： 部署本机桌面应用程序-----重新分发Visual C++ 文件-----最新受支持的Visual C++可再发型程序包下载
根据自己电脑系统进行选择哦
3、安装
1、前往官网
https://learn.microsoft.com/zh-cn/cpp/windows/
2、找到对应的包
左边导航栏一次选择： 部署本机桌面应用程序-----重新分发Visual C++ 文件-----最新受支持的Visual C++可再发型程序包下载
3、安装Visual C++ 按照电脑提示一直点下一步即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e629c27bee10f6b8e148334d9ee1ee83/" rel="bookmark">
			where: supR3hARDENEDwINrEsPAWN WHAT: 5 VERR_INVALID_NAME(-104)-invalid(malformed)file/pathname.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		产生原因 大致为三种情况：
１. VirtualBox核心驱动未安装或损坏（重装inf.文件就行）
２. 第三方反病毒软件干扰（可以先关闭防火墙进行安装，但一般推荐先看第三种情况）
３. Windows系统更新后不兼容
解决办法 建议从前往后都试一下以下方法，然后重启电脑，看看能不能打开虚拟机（这些方法不仅仅适用于以上报错）。
禁用时时病毒防护或直接卸载。确保Hyper-V（win10系统内置的虚拟机）是禁用的。方法：控制面板-程序-程序和功能-打开或关闭Windows功能。 找到VirtualBox下载目录，进入drivers-vboxdrv，找到inf类型文件，右键安装。 卸载并重装不同版本的VirtualBox。（win11一定要安装最先版本）打开注册表，找到 计算机\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\VBoxDrv
双击Start，将数值1（或者其他）改为2就行（我在这一步成功修好）。（注释2）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0be4ae24bc25ac3fe413df6b9a70250f/" rel="bookmark">
			ssm基于Java Web的怀旧唱片售卖系统论文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘 要 传统办法管理信息首先需要花费的时间比较多，其次数据出错率比较高，而且对错误的数据进行更改也比较困难，最后，检索数据费事费力。因此，在计算机上安装怀旧唱片售卖系统软件来发挥其高效地信息处理的作用，可以规范信息管理流程，让管理工作可以系统化和程序化，同时，怀旧唱片售卖系统的有效运用可以帮助管理人员准确快速地处理信息。
怀旧唱片售卖系统在对开发工具的选择上也很慎重，为了便于开发实现，选择的开发工具为Eclipse，选择的数据库工具为Mysql。以此搭建开发环境实现怀旧唱片售卖系统的功能。其中管理员管理用户，新闻公告。
怀旧唱片售卖系统是一款运用软件开发技术设计实现的应用系统，在信息处理上可以达到快速的目的，不管是针对数据添加，数据维护和统计，以及数据查询等处理要求，怀旧唱片售卖系统都可以轻松应对。
关键词：怀旧唱片售卖系统；SSM框架，系统分析，数据库设计
Abstract
The traditional method of managing public transportation information first takes more time, and secondly, the data error rate is relatively high, and it is more difficult to modify the wrong data, and finally, it is laborious and laborious to retrieve the data. Therefore, installing the public transportation query website software on the computer to play its role in efficient information processing can standardize the public transportation information management process, so that the management work can be systematized and programmed.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0be4ae24bc25ac3fe413df6b9a70250f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae4501577850d7674f91de694a80b722/" rel="bookmark">
			电脑开启虚拟化如何查看自己的主机主板型号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 在使用virtualbox、vmware安装虚拟机的时候，需要本机电脑能够支持虚拟化。
但是不同厂家的主机（主板）幸好并不一致，所以需要先了解自己的电脑主板型号
操作方法 1、win + r 键打开运行窗口，输入cmd并确定打开终端
2、输入 wmic baseboard get product,manufacturer,version,serialnumber
这个命令会显示电脑主板的产品名、制造商、版本和序列号。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c579d1fcd811b04a14f197569137cdd/" rel="bookmark">
			Python开发环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python程序设计语言是解释型语言，其广泛应用于运维开发领域、数据分析领域、人工智能领域，本文主要描述Python开发环境的搭建。
www.python.org
如上所示，从官方网站下载Python最新的稳定版本3.12.1
如上所示，在本地的开发环境安装Python最新版本成功、运行Python代码执行终端测试代码成功
www.jetbrains.com/pycharm
如上所示，从jetbrains官方网站下载开源社区版本的Python代码集成开发工具PyCharm最新版本
如上所示，安装PyCharm代码集成开发工具成功、在PyCharm中设置Python解析器成功
如上所示，新建Python项目testCode成功、运行testCode.py成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6bbb84bfcf12eb77fb04b4a1d3a182c/" rel="bookmark">
			Keil MDK 6 的使用教程来了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关注+星标公众号，不错过精彩内容
作者 | strongerHuang
微信公众号 | strongerHuang
很多读者都比较关心 Keil MDK 6 的消息。。。
Keil MDK 6来了吗？
Keil MDK 6 和 Keil Studio 桌面版什么关系？
Keil Studio 桌面版就是VS Code插件吗？
Keil Studio 桌面版如何使用？
······
虽然Keil被很多网友吐槽存在各种不足，但目前主流的单片机（MCU）开发工具，使用较多的依然还是Keil这个工具。所以，有很多网友比较关心“传说中”的Keil MDK 6。
Keil MDK 6来了吗？
说到 Keil MDK 6，就要说到Keil Studio。
早在2021年的时候，Keil官方就悄悄上线了Keil Studio Cloud（网页版），当时我也第一时间给大家写了一篇文章《Keil MDK 将升级为 Keil Studio，你想要的黑色主题来了，附手把手使用教程》。
从那个时候开始，大家就开始关心 Keil 升级改版的问题。但是，大家一次次的期待，等来的却是一次次的“失望”。
官方从Keil MDK V5.36，一直升级到现在最新的V5.39都还是以前的“老样子”，而没有升级到大家期待的更现代的IDE工具。
2023年3月份的时候，官方说2023年底正式推出Keil MDK 6：
现在看来，Keil MDK 6是来了，但结果有点让大家失望，Keil MDK 6（社区版）就是包含Keil Studio for VS Code、Keil Studio Cloud和Keil μVision的一个“大融合”工具。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6bbb84bfcf12eb77fb04b4a1d3a182c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2be705d72c9dd0703e9a0e62affd3050/" rel="bookmark">
			GLTF编辑器设置3D纺织纹理贴图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在线工具推荐： 3D数字孪生场景编辑器 - GLTF/GLB材质纹理编辑器 - 3D模型在线转换 - Three.js AI自动纹理开发包 - YOLO 虚幻合成数据生成器 - 三维模型预览图生成器 - 3D模型语义搜索引擎 位移贴图是一种纹理映射技术，通过改变顶点的位置来模拟细节和几何体的细微变化。在纺织品设计中，位移贴图可以模拟不同织物表面： 通过位移贴图，可以模拟出棉、丝绸、羊毛等各种纤维材料的表面特性和纹理。
创造自然纹理和图案： 使用位移贴图，设计师可以实现各种自然纹理，如皱褶、纹路、线条，使布料看起来更加真实。个性化定制设计： 利用位移贴图技术，可以根据客户需求创建个性化的纹理和图案，满足不同市场和产品定位的需求。 1. 细节增强 皱纹和肌肉纹理： 位移贴图可以用于在角色模型的皮肤表面添加皱纹、肌肉纹理等微小细节，使角色看起来更加生动和有层次感。衣物褶皱： 游戏中的角色通常穿着各种服装，位移贴图可以被用来模拟衣物的褶皱，使服装看起来更逼真。 2. 模型形状调整 个性化角色： 通过位移贴图，可以根据游戏中角色的不同状态或特征，实时调整模型的形状，例如表达角色的情绪或动作。装备添加： 在角色换装时，位移贴图可以帮助模拟不同装备对角色外观的影响，而无需修改模型的基本几何结构。 3. 优化性能 资源消耗： 相较于修改模型的几何结构，使用位移贴图在一定程度上减少了性能消耗，特别是在移动端或对性能要求较高的游戏场景中。动态效果： 通过动态更新位移贴图，可以实现一些动态效果，如角色受伤时的皮肤凹陷效果，而不需要重新渲染整个模型。 本文将讲解如何使用GLTF 编辑器 -NSDT 在线材质编辑工具为动物3D模型设置逼真的毛发效果，在开始之前我们先了解下纹理里纹理贴图的一些基本概念。
1、位移贴图的作用和原理 位移贴图（Displacement Map）是一种用于在三维图形渲染中创建表面细节和形状的技术。它通过在表面上应用灰度图像来调整顶点的位置，从而改变模型的几何形状。以下是关于位移贴图的详细介绍：
原理： 位移贴图利用灰度图像的不同灰度值来表示不同高度，通过将这些高度信息应用于模型表面上的顶点，实现对模型几何结构的细致调整。作用： 主要用于在渲染过程中增加模型的细节，使其表面呈现出更加真实和复杂的外观。这对于模拟真实世界中的表面细节和形状变化非常有用。 2、位移贴图的有点和应用场景 优点：
提高模型细节，使其更真实。相对于几何细分，消耗较少的计算资源。 应用场景：
角色建模：为角色模型添加皱纹、肌肉纹理等细节。场景建模：在地面上添加石块、草丛等自然元素的细节。游戏开发、电影制作等领域中广泛应用。 3、GLTF 编辑器 在选择合适的纹理工具时，请考虑项目的复杂性和您对软件的熟悉程度。初学者倾向于 GLTF 编辑器 -NSDT，GLTF 编辑器是一款专门用于3D模型纹理贴图的工具，它支持3D模型各种材质纹理贴图的编辑修改，包括：颜色、粗糙度、金属度、贴图、顶点颜色、自发光贴图、透明贴图、凹凸贴图、法线贴图、位移贴图、粗糙贴图、金属贴图、光照贴图、透明度等。
4、GLTF 编辑器如何实现3D电影角色 使用专业的建模软件来设置模型的纹理贴图确实是个不错的选择，但是对于新手小白来说却是不那么友好了，软件的安装、使用都比较麻烦，而GLTF 编辑器 -NSDT 作为一款在线材质纹理编辑工具，基于Three.js 开发，可以在任意支持webGL的浏览器运行，不需要安装下载额外的插件或者以来，打开浏览器就能使用。
以下是如何使用 GLTF 编辑器 -NSDT 设置纹理贴图的方法和步骤：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2be705d72c9dd0703e9a0e62affd3050/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6304476e0372efa1b869a5513816f1b4/" rel="bookmark">
			阿里云服务器Centos安装宝塔面板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阿里云服务器Centos安装宝塔面板 1 背景1.1 aliyun1.2 Linux 2 安装步骤2.0 环境配置2.1 安装前准备2.2 宝塔安装2.3 建站 3 centos常用命令3.1 防火墙相关 1 背景 1.1 aliyun 阿里云服务器是阿里云提供的一项云计算服务，它能够帮助用户快速搭建网站、应用和服务，提供高效稳定的数据存储和计算能力，满足用户的各种业务需求。
阿里云服务器是一种简单高效、处理能力可弹性伸缩的计算服务。它提供了多种规格的服务器，包括弹性计算型、计算型、内存计算型、GPU计算型和神舟系列服务器等，能够满足不同用户的需求。用户可以根据自己的业务需求选择合适的服务器规格。
阿里云服务器提供了高效稳定的数据存储和计算能力，用户可以通过API接口进行服务器的管理和控制，非常方便。此外，它还提供了丰富的监控和日志功能，方便用户进行故障排查和性能优化。
阿里云服务器还提供了多种计费模式，包括按需付费、包年包月、长期包、预留实例等，用户可以根据自己的业务需求选择合适的计费模式。
小结：阿里云服务器是一款功能强大、稳定可靠的云计算服务，它能够帮助用户快速搭建网站、应用和服务，提供高效稳定的数据存储和计算能力，满足用户的各种业务需求。
1.2 Linux Linux是一套免费使用和自由传播的类Unix操作系统，它是由林纳斯·本纳第克特·托瓦兹（Linus Benedict Torvalds）于1991年首次发布的。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。Linux有上百种不同的发行版，如基于社区开发的debian、archlinux，和基于商业开发的Red Hat Enterprise Linux、SUSE、Oracle Linux等。
2 安装步骤 2.0 环境配置 2.1 安装前准备 购买阿里云服务器安装centos系统 2.2 宝塔安装 Centos/Alibaba Cloud Linux 安装命令：
yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh 我的是CentOS系统直接复制第一条到ssh回车，就开装了。遇到一个确认，输入‘y’回车，等安装完就可以了。
耐心等待几分钟，出现面板账号密码信息。
直接复制宝塔链接到浏览器，页面打开后输入账号密码，然后登录，这个是正版的宝塔会要求注册宝塔账号密码。那就注册呗。注册完之后登录。就可以进入宝塔管理界面了。
【云服务器】请在安全组放行 13816 端口
因默认启用自签证书https加密访问，浏览器将提示不安全
点击【高级】-【继续访问】或【接受风险并继续】访问
教程：https://www.bt.cn/bbs/thread-117246-1-1.html
安装必要的软件，我这里选择的事LNMP安装
时间比较久，耐心等待安装完成。
安装完成的样子。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6304476e0372efa1b869a5513816f1b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a90d48c50ebb72e6967f0e97f3864702/" rel="bookmark">
			DMX512输出协议详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
​编辑
1、DMX512协议简介
2、DMX512协议分析
DMX512指令帧介绍
DMX512信息包
3、DMX512接口电路
4、参考代码
1、DMX512协议简介 DMX512是一种用于舞台灯光控制的数字传输协议。它是由美国舞台灯光协会（USITT）于1990年发布的工业标准，全称为USITT DMX512(1990)。DMX512协议定义了灯光控制器与灯具设备之间进行数据传输的电气特性、数据协议和数据格式等方面的内容。通过DMX512协议，可以实现对舞台灯光设备的精确控制，包括调整亮度、颜色、运动等。DMX512协议常用于舞台演出、演唱会、剧院等场合，以及其他需要对灯光进行精确控制的应用领域。
DMX512是一种用于控制舞台灯光和特效设备的通信协议。它在物理层采用EIA-485差分信号，并结合可变尺寸和基于分组的通信协议。DMX512是单向的，意味着只能从控制器发送数据到灯光和特效设备，而不能反向传输数据。
DMX512协议不包含自动错误检查和纠正功能，因此不适用于一些危险应用，如烟火或舞台装置的移动。电磁干扰、静电放电、不正确的电缆端接、电缆过长或电缆质量等因素可能会导致虚假触发或通信错误。
2、DMX512协议分析 DMX512指令帧介绍 每一个DMX 控制字节叫做一个指令帧，称作一个控制通道，可以控制灯光设备的一个或几个功能。一个DMX 指令帧由1个开始位(S)、8个数据位(D0-D8)和2个结束位(E)共11位构成，采用单向异步串行传输，如图：
图1 中虚线内控制指令中的S为开始位，宽度为一个比特，是受控灯具准备接收并解码控制数据的开始标志;
E为结束位，宽度为两个比特，表示一个指令帧的结束;
D0～ D7为8 位控制数据，其电平组合从00000000一11111111 共有256个状态(对应十进制数的0～255)，控制灯光的亮度时，可产生256个亮度等级，0000~ (0)对应灯光最暗，11111111(255)对应灯光最亮。
DMX512指令的位宽(每比特宽度)是4 us，每一个指令帧11位，故指令帧宽度为44 us，传输速率为1/44us = 250 kbps。
DMX512信息包 一个完整的DMX512信息包(Packet)由一个MTBP位、一个Break 位、一个MAB位、一个SC 和512个数据帧构成。
MTBP(Mark TimeBetween Packets)标志着一个完整的信息包发送完毕，是下一个信息包即将开始的“空闲位”，高电平有效。
Break为中断位，对应一个信息包结束后的程序复位阶段，宽度不少于两个帧(22 比特)。程序复位结束后应发送控制数据，
MAB位，由于每一个数据帧的第一位(即开始位)为低电平，所以必须用一个高电平脉冲间隔前后两个低电平脉冲，这个起间隔、分离作用的高电平脉冲即MAB(Mark After Break)，此脉冲一到，意味着“新一轮”的控制又开始了。
SC(Start Code)意为开始代码帧(图1中的第0帧)，和此后到来的数据帧一样，也是由11 位构成，除最后的两个高电平的结束位之外，其他9位全部是低电平，通常将其叫做第0 帧或第0通道(Ch~nel No 0)，可理解为一个不存在的通道(Non一~istent Channe1)。
DMX512 信息包定时表：
表1 是DMX512 信息包的定时表，表中NS意为自己设定，宽度没有严格限制，由程序设计者自行决定，比如MTBP的宽度可以介于0～1秒之间，其他建议采用典型值。
调光控制台每发送一个信息包，可以对全部512个受控通道形成一次全面的控制。发送一个信息包的时间大约是23 ms，每秒钟将对所有512个受控通道完成44 次控制，即受控光路的刷新频率44 Hz，如果实际受控通道少于512个，那么刷新频率将相应提高。
3、DMX512接口电路 以下是使用RJ45连接器的接线及驱动电路 ：
(XLR-5和RJ45基本类似)
表2 DMX512 设备使用RJ45连接器的接线表
4、参考代码 #include "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a90d48c50ebb72e6967f0e97f3864702/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c6174fe4871a8a4fc29fec94188b6c2/" rel="bookmark">
			互联网防反爬机制的六种反爬技术大解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 互联网时代，无论在工作上，还是生活上都离不开网络，而网络能给我们带来什么？
新闻，小说，资料，各行业的数据或者报表等等；
比如：快毕业了为了论文，在各种网站上爬取需要的数据进行分析；还有一些为了兴趣爱好，爬取各种类型的图片，视频，文章，数据等。
各网站的开发人员为了约束这种行为，开始绞尽脑汁，采取各种手段去约束爬虫，于是，有了反爬机制！
反爬虫 今天小编来和大家谈谈反爬技术。要了解反爬技术就必须要知道爬虫，所谓爬虫其实就是由计算机自动与服务器交互获取数据的工具。
目前常见而好用的反爬技术有七种，它们分别是：user-agent，验证码，封IP，滑块验证，关联请求上下文，JavaScript 参与运算以及提高数据获取成本。
仔细分析这七种反爬技术 1、user-agent 数据请求头，最初级的反爬，只要在请求中模拟请求头即可轻松飘过。
解决方法：可以自己设置一下user-agent，或者更好的是，可以从一系列的user-agent里随机挑出一个符合标准的使用
无论是浏览器，程序，还是爬虫，在向服务器发起网络请求时，都会先发送一个请求头文件 headers
比如：
{ "headers": { "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9", "Accept-Encoding": "gzip, deflate, br", "Accept-Language": "zh-CN,zh;q=0.9,zh-HK;q=0.8", "Host": "httpbin.org", "Sec-Fetch-Dest": "document", "Sec-Fetch-Mode": "navigate", "Sec-Fetch-Site": "none", "Upgrade-Insecure-Requests": "1", "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Safari/537.36", "X-Amzn-Trace-Id": "Root=1-5fe2b4fe-6e4edc1c4dbbe85a3c25492b" } } # "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Safari/537.36" 请求头大部分的字段主要是浏览器向服务端 “表明自己的身份”用的，很多网站都会建立 user-agent 白名单，只有在正常范围内的 user-agent 才能正常访问 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c6174fe4871a8a4fc29fec94188b6c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3175da9b8ec16e7b6ac8e5b70fcd27ae/" rel="bookmark">
			C&#43;&#43;的介绍前景和在实际开发中的运用及与java对比（嵌入式，游戏）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 .C++ 简介 C++ 是一门非常经典的高级编程语言。顾名思义，C++可以看做是C语言的增强版，在C的基础上扩展了更多的功能；最主要的扩展，就是面向对象和泛型编程。
因此C++融合了多种不同的编程方式：以C语言为代表的面向过程编程；面向对象编程；以及模板化的泛型编程。
可以说，C++一门“大而全”的编程语言，你可以用它实现想要的任何功能；与此同时，学习C++需要掌握的内容也会比较多。
1.1 C和C++ 20世纪70年代，贝尔实验室的Dennis Ritchie为了开发UNIX操作系统，专门设计了一门结构化的高级语言，这就是大名鼎鼎的C语言。因为是为操作系统设计的语言，它本身是比较底层的，所以C具有低级语言的高运行效率、硬件访问能力，此外又融合了高级语言的通用性。
C语言语法清晰，具有非常好的结构化编程的特性。于是C语言快速地统治了底层的系统级编程，并成为了之后几十年内经典的教学语言。
C语言编程的整体思路是“过程式”的，也就是说，我们把想让计算机执行的操作按照步骤一步步定义好，然后用C语言写出来；所以我们写的代码，就是一个处理流程的描述。这种方式很容易理解，也可以非常方便地翻译成计算机能懂的机器语言；但是在面对大型项目、代码量非常大时，就会显得杂乱无章，代码的可读性就大大降低了。
于是另一种编程方式应运而生，这就是面向对象编程。这种方式的主要思路是先构建“对象”，然后通过定义好的对象行为，实现我们想要的操作。
贝尔实验室的 Bjarne Stroustrup（比雅尼·斯特劳斯特鲁普），在20世纪80年代创建了一个新的面向对象语言——C++。
名字一目了然，它是基于C的，扩展了C的功能；所以C++是C语言的超集，所有C语言程序都可以在C++的环境下运行。而扩展的部分，主要就是引入了面向对象的特性，并实现了对C的泛型编程支持。
C++的出现极大地扩充了C的应用场景，为C语言的长盛不衰提供了很大的助力。所以我们平常看招聘要求的技术栈描述，往往是把C/C++放在一起说的。
2. C++ 的应用场景 C++完全兼容C，具有C面向硬件的特性；此外还拥有面向对象和泛型编程的扩展。所以C++编写的程序运行效率高、功能强大，特别适合用在系统级应用场景上。所以我们经常可以看到，偏向底层、系统的开发，一般用的语言都是C++。
底层硬件，系统编程：JVM的底层，Python解释器的底层，都离不开C/C++的身影；人工智能核心库的代码，也大多是C++写的
2.1 嵌入式开发场景： 1.驱动开发：嵌入式系统通常需要与各种外设进行交互，如传感器、执行器、显示屏等。使用C++可以很方便地编写驱动程序，通过封装设备的底层操作，提供简洁、高效的接口供上层应用程序使用。 2.通信模块：很多嵌入式系统需要与其他设备或者远程服务器进行通信，例如通过串口、网络等方式发送和接收数据。C++提供了丰富的库函数支持，使得通信模块的开发更加便捷和高效。 3.系统任务调度：嵌入式系统通常需要同时处理多个任务，如数据采集、实时控制等。C++提供了多线程和多任务调度的支持，可以实现任务的并发执行和优先级管理，提高系统的响应速度和实时性。 4.图像处理：许多嵌入式系统需要进行图像处理，如机器视觉、图像识别等。C++提供了丰富的图像处理库，如OpenCV，可以方便地实现各种图像处理算法。 5.对象导向编程（OOP）：C++的主要特征之一是面向对象编程，这使得程序员能够以更模块化和可维护的方式构建嵌入式系统。类和对象的概念使得代码更易于组织和理解，有助于大型项目的开发。 6.标准模板库（STL）：C++的STL提供了丰富的数据结构和算法，如向量、队列、映射等，可以在嵌入式系统中提供高效的数据管理和处理。这使得开发者能够更方便地使用标准的数据结构，而不必从零开始实现。 7.内存管理：C++允许程序员手动管理内存，这在嵌入式系统中是一项重要的功能。对于资源受限的设备，精确的内存控制是确保系统性能和稳定性的关键。 8.多线程支持：在某些嵌入式应用中，需要同时处理多个任务。C++支持多线程编程，这使得开发者能够更容易地实现并行处理，提高系统的响应速度和效率。
2.2 嵌入式开发所用到的行业： 1.汽车行业：C++常用于汽车电子系统的开发，包括车载娱乐系统、车辆控制单元（ECU）等。
2.无人机和自动驾驶：在飞行控制系统和自动驾驶系统中，C++被用于实现实时控制和数据处理。
3.工业自动化：工业控制器、机器人控制系统等通常使用C++进行开发。
4.通信设备：路由器、交换机等网络设备的嵌入式软件通常采用C++编写。
5.医疗设备：医疗影像设备、监护仪等嵌入式系统通常会使用C++进行开发。
6.物联网设备：智能家居、智能穿戴设备等物联网设备的嵌入式软件开发也会使用C++语言。
2.3 c++在游戏开发的具体场景 游戏引擎开发：C++被广泛用于游戏引擎的开发。游戏引擎是一个包含多个子系统的复杂系统，负责图形渲染、物理模拟、音频处理、人工智能等核心功能。C++提供了高性能和底层控制力，使得游戏引擎开发者可以实现这些复杂的任务。一些著名的游戏引擎，如Unreal Engine和Unity，都是使用C++编写的。
游戏逻辑开发：C++不仅用于游戏引擎的底层开发，还常用于游戏逻辑的高层次开发。游戏逻辑包括游戏的各种规则和机制，例如角色的动作、AI决策、任务流程等。C++的面向对象特性使得开发者可以更容易地组织和管理这些逻辑，提高代码的可维护性和可扩展性。
渲染引擎开发：C++常用于实现高效的渲染引擎，如OpenGL和DirectX。这些渲染引擎负责将3D模型转换成2D图像，以便在屏幕上显示。C++提供了对底层硬件的直接访问，使得开发者可以实现高性能的图形渲染效果。
工具开发：游戏开发中需要使用各种工具来辅助开发过程，如3D建模软件、动画编辑器、场景编辑器等。C++常被用于这些工具的开发，因为它提供了强大的功能和灵活性，可以满足各种特定需求。
网络编程：在线多人游戏需要处理大量的玩家请求和逻辑计算，因此需要高效的编程语言来实现高性能的服务器。C++常被用于游戏服务器的开发，因为它提供了对网络通信和并发处理的良好支持。
2.4 金融领域： C++在金融领域中应用广泛，如高频交易、算法交易和风险管理等。这些应用需要高效的性能和对硬件的直接控制，而C++正好具备这些特性。
2.5 图形图像处理 C++可以用于开发图形和图像处理应用程序，如计算机视觉、计算机图形学和人工智能领域。
2.6 科学计算 C++在科学计算领域应用广泛，例如在数值模拟和高性能计算等领域。
2.7 网络软件 C++拥有许多成熟的网络通信库，适用于开发各种网络软件，例如服务器端程序、网络通信协议等。
2.8 分布式应用 C++可以用于开发分布式应用程序，以实现跨平台的协同工作和资源共享。
2.8 操作系统 虽然C语言是主要的系统级编程语言，但C++也可以用于开发操作系统中的一些组件，如文件系统、内存管理等。
2.9 设备驱动程序 C++在设备驱动程序开发中也有应用，特别是在需要高效性能和底层控制的场景下。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3175da9b8ec16e7b6ac8e5b70fcd27ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c926f4595fe5c941bfa955076c11cab/" rel="bookmark">
			Stable Diffusion架构的3D分子生成模型 GeoLDM - 测评与代码解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前，向大家介绍过3D分子生成模型 GeoLDM。
GeoLDM按照Stable Diffusion架构，将3D分子生成的扩散过程运行在隐空间内，优化了基于扩散模型的分子生成。可能是打开Drug-AIGC的关键之作。让精确控制分子生成有了希望。
详见：分子生成领域的stable diffusion - GEOLDM-CSDN博客）
作者提供了GitHub代码：https://github.com/MinkaiXu/GeoLDM。
因此，我特意测试了一下代码质量。
一、代码测试 首先 git clone 项目代码：
git clone https://github.com/MinkaiXu/GeoLDM.git 项目目录为：
. ├── LICENSE ├── README.md ├── build_geom_dataset.py ├── configs ├── data ├── egnn ├── equivariant_diffusion ├── eval_analyze.py ├── eval_conditional_qm9.py ├── eval_sample.py ├── main_geom_drugs.py ├── main_qm9.py ├── qm9 ├── requirements.txt ├── train_test.py └── utils.py 6 directories, 11 files 其中，qm9文件夹包含了qm9数据集预处理到dataloader的方法，qm9数据集会自动下载train, valid, test分割好的数据集;drug数据则需要自己下载，然后执行build_geom_dataset.py（见下文）。
1.1 环境安装 安装torch及其组件， rdkit, numpy,tqdm等（macOS系统）：
conda install pytorch::pytorch torchvision torchaudio -c pytorch conda install -c conda-forge rdkit conda install numpy pandas scipy tqdm conda install imageio pip install msgpack # 时序数据库 安装过程比较简单，没有遇到任何问题。 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c926f4595fe5c941bfa955076c11cab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98b736ad4ca5cdf323d98250ea941a07/" rel="bookmark">
			【comp221】Flask Python Web
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A Simple Holiday House Rental System Develop a Flask Python Web App for a Holiday House Rental System. The application should include a login system and separate dashboards for three user roles: customer, staff and admin. Users should be able to login to the system and access their respective dashboards as well as to perform specific actions related to holiday house rental operations. This is a simplified version without the booking and rental functionalities as the focus is on providing different level of access for different user roles.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98b736ad4ca5cdf323d98250ea941a07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4269ec0cb9487581ddcbe5744bed0947/" rel="bookmark">
			Java刷题错题笔记-day05-集合（CopyOnWriterArrayList、HashMap）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.CopyOnWriterArrayList是强一致性列表吗？ 不是
CopyOnWriteArrayList 不提供强一致性主要是因为它的修改操作是在一个新的拷贝上进行的，而不是直接在原始数据结构上。这种设计决策带来了一些影响：
读取操作不阻塞： CopyOnWriteArrayList 的读取操作是在原始数组上进行的，无锁，而写入在原数组的拷贝上进行。因此，写入操作期间，读取操作不会被阻塞，允许并发读取。但这也意味着在写入操作完成之前，读取操作可能会看到旧的数据。写入操作的延迟： 当有写入操作发生时，CopyOnWriteArrayList 会创建一个新的数组，并在上面执行修改。在这个过程中，其他线程可能仍然在引用旧的数组。因此，在写入操作完成之前，其他线程可能无法感知到最新的修改。 下面是简化的 CopyOnWriteArrayList 的部分关键代码，以便更好地理解：
public class CopyOnWriteArrayList&lt;E&gt; { private transient volatile Object[] array; // ... /** *写入操作 / public boolean add(E element) { synchronized (this) { Object[] currentArray = array; //1.拷贝原数组 Object[] newArray = Arrays.copyOf(currentArray, currentArray.length + 1); //2.在新副本上执行添加操作 newArray[currentArray.length] = element; //3.将原数组引用指向新副本 array = newArray; return true; } } // ... public E get(int index) { return (E) array[index]; } // .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4269ec0cb9487581ddcbe5744bed0947/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05896c29616784e9e8dcd031ae74f151/" rel="bookmark">
			opencv收录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.介绍 OpenCV是计算机视觉中经典的专用库，其支持多语言、跨平台，功能强大。
OpenCV-Python为OpenCV提供了Python接口，使得使用者在Python中能够调用C/C++，在保证易读性和运行效率的前提下，实现所需的功能。
2.图像处理基本方法 1、图像读入：cv2.imread() 使用函数cv2.imread() 读入图像。第一个参数是图片的路径，第二个参数是要告诉函数应该如何读取这幅图片。 • cv2.IMREAD_COLOR：读入一副彩色图像。 • cv2.IMREAD_GRAYSCALE：以灰度模式读入图像 • cv2.IMREAD_UNCHANGED：读入完整图片，包括alpha通道 import cv2 img = cv2.imread('lena.jpg',0) 2、显示图像cv2.imshow() 使用函数cv2.imshow() 显示图像。窗口会自动调整为图像大小。第一个参数是窗口的名字，第二个参数图像。 cv2.imshow('image',img) cv2.waitKey(0) cv2.destroyAllWindows() #cv2.destroyWindow('image') 3、保存图像cv2.imwrite() cv2.imwrite(file，img，num)保存图像。第一个参数是要保存的文件名，第二个参数是要保存的图像。可选的第三个参数，它针对特定的格式：对于JPEG，其表示的是图像的质量，用0 - 100的整数表示，默认95;对于png ,第三个参数表示的是压缩级别。默认为3. cv2.imwrite('lena.png',img) 4、图像的分割与合并 import cv2 lena=cv2.imread("lenacolor.png") b, g, r=cv2.split(lena) bgr=cv2.merge([b, g, r]) rgb=cv2.merge([r, g, b]) cv2.imshow("lena", lena) cv2.imshow("bgr", bgr) cv2.imshow("rgb", rgb) cv2.waitKey() cv2.destroyAllWindows() 5、获取图像属性 在图像处理过程中，经常需要获取图像的属性，例如图像的大小、类型等。这里介绍几个常用的属性。 ● shape：如果是彩色图像，则返回包含行数、列数、通道数的数组；如果是二值图像或者灰度图像，则仅返回行数和列数。通过该属性的返回值是否包含通道数，可以判断一幅图像是灰度图像（或二值图像）还是彩色图像。 ● size：返回图像的像素数目。其值为“行×列×通道数”，灰度图像或者二值图像的通道数为1。 ● dtype：返回图像的数据类型。 6、图像的运算 ①使用运算符“+”对像素值为a和b的两个像素点进行操作时，运算结果为:mod(a+b,256),就是两像素值相加后的结果对256取模求余数。 import numpy as np image1=np.random.randint(0,256,(3,3),dtype=np.uint8) image2=np.random.randint(0,256,(3,3),dtype=np.uint8) image3=image1+image2 print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05896c29616784e9e8dcd031ae74f151/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc77f066636c624ee6bd734a267f17fe/" rel="bookmark">
			Python中__call__属性的使用指南详细解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概要 在Python中，类可以具有许多特殊方法，以控制其行为。其中之一是__call__方法，它使一个类的实例可以像函数一样被调用。本文将深入探讨__call__方法的用途、示例和实际应用。
__call__方法的基本用法 __call__方法可以将一个类的实例作为函数来调用。要使用__call__方法，需要在类中定义它，并在实例中设置相应的属性。
下面是一个基本的示例：
class MyCallableClass: def __init__(self): self.value = 0 def __call__(self, x): self.value += x return self.value # 创建一个可调用的实例 my_instance = MyCallableClass() # 调用实例就像调用函数一样 result1 = my_instance(5) result2 = my_instance(10) print(result1) # 输出结果：5 print(result2) # 输出结果：15 用途示例：实现计数器 __call__方法通常用于实现可变对象的实例，例如计数器。
下面是一个示例，演示如何使用__call__方法实现一个简单的计数器：
class Counter: def __init__(self): self.count = 0 def __call__(self): self.count += 1 return self.count # 创建一个计数器实例 counter = Counter() # 调用计数器实例来增加计数 print(counter()) # 输出结果：1 print(counter()) # 输出结果：2 print(counter()) # 输出结果：3 实际应用：装饰器 __call__方法还可用于创建装饰器。装饰器是一种可以修改函数或方法行为的技术。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc77f066636c624ee6bd734a267f17fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0878dff1c19e85bf643a2bf25b973b0/" rel="bookmark">
			【SpringCloud】设计原则之 DevOps 与无状态服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、设计原则之 DevOps DevOps 一词来自 Development 和 Operation 的组合，突出重视软件开发人员和运维人员的沟通合作，通过自动化流程来使得软件构建、测试、发布更加快捷、频繁和可靠。它要求开发、测试、运维进行一体化的合作，进行更小、更频繁、更自动化的应用发布，以及围绕应用架构来构建基础设施的架构。这就要求应用充分内聚，也方便运维和管理。这个理念与微服务理念不谋而合。 DevOps 的出现是为了填补开发端和运维端之间的信息鸿沟，改善团队之间的协作关系。不过需要澄清的一点是，从开发到运维，中间还有测试环节。DevOps 其实包含了三个部分：开发、测试和运维。 换句话说，DevOps 希望做到的是软件产品交付过程中 IT 工具链的打通，使得各个团队减少时间损耗，更加高效地协同工作。 那么如何来评估 DevOps 的能力呢？可以通过能力环来对环境进行整体评估。DevOps 能力环如图所示。 无尽头的可能性：DevOps 涵盖了代码、部署目标的发布和反馈等环节，闭合成一个完整的 DevOps 能力闭环。 良好的闭环可以大大增加整体的产出。 执行 DevOps 的推荐工具如表所示。 服务注册与发现部署监控 ZooKeeper
Doozer
etcd
SmartStack
Eureka
NSQ
Serf
Spotify
DNS
SkyDNS
Consul
Cloud Foundry
Gradle
Docker
Docker Hub
Docker Machine
Kitematic
Docker Compose
Docker Swarm
AWS
Jenkins
Continuum
Hudson
Artifactory
Terraform
Grunt
OpenShift
SonarCube
Logstash
New Relic
Graphite
Mesosphere / DCOS
Winston
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0878dff1c19e85bf643a2bf25b973b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5751adfd22f9f2253edc2ab58080558/" rel="bookmark">
			亲测解决unable to import torch, please install it if you want to pre-compile any deepspeed ops.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个问题是小虎在win上下载deepspeed导致。原因是windows不支持deepspeed。
问题背景 unable to import torch, please install it if you want to pre-compile any deepspeed ops. DS_BUILD_OPS=1 解决方法 windows上面不能使用deepspeed，因为deepspeed用到了linux系统的libaio-dev模块。所以截至目前只能在linux系统上使用deepspeed。
另外，小虎运行的程序是BEiT2，在注释了有关deepspeed的语句后，程序正常运行。因为deepspeed的功能是用来加速程序运行的。
原版笔记 Cannot use deepspeed in windows. Quite funny. Since microsoft developed deepspeed.
参考 Unable to pre-compile async_io on Windows
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/779bdeaca82048020d8691606d6ae73f/" rel="bookmark">
			食谱检测 — 一场基于 CNN 的食谱改革
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		食谱检测项目旨在开发一种算法或系统，能够从各种来源（如图像、文本或二者的组合）识别和分类不同的食谱。其目标是使用户能够上传一张图像或输入描述一道菜肴的文本，并使系统能够准确识别食谱并提供相关信息，如食材、制作步骤和营养信息。该项目可能涉及使用大量食谱的数据集对机器学习模型进行训练，使系统能够学习和识别特定菜肴的模式和特征。诸如图像识别、自然语言处理和数据挖掘等技术可能被采用以提高食谱检测系统的准确性和效率。
这种系统的潜在应用是多种多样的。它可以帮助有饮食限制或特定口味偏好的人找到合适的食谱。在食品行业中，它还可以用于菜单设计、食谱管理，甚至用于自动生成个性化的餐饮计划。总体而言，食谱检测项目旨在使找到食谱的过程变得更加方便。
什么是深度学习？
通过计算机视觉技术，该应用程序可以分析烹饪菜肴的图像并提取视觉特征，以识别其中的食材。这使得用户只需拍摄一道菜肴的照片，即可获得其中使用的食材列表。此外，通过利用CNN，卷积神经网络在食品行业中的应用近年来备受关注和普及。CNN在食品识别、成分识别和质量检验等各种任务中都表现出极高的效果。
通过整合这些深度学习技术，该应用程序为用户提供了一种方便的方式，使其能够轻松地从图像中识别食材，并根据现有的食材获取烹饪建议。这对于烹饪爱好者和想尝试新菜肴的个人来说都是一种有价值的工具。
1. 引言
使用深度学习进行食物图像的食谱检测是一种技术，利用神经网络识别和分类图像中存在的不同类型的食物。通过在大量带有相应食谱信息的食物图像数据集上对深度学习模型进行训练，模型学会将图像中的特定视觉模式与具体食谱相关联。
该过程通常包括多个步骤，从预处理食物图像以提高其质量并去除任何不相关信息开始。接下来，使用卷积神经网络（CNNs）等技术对经过预处理的图像对模型进行训练。在训练过程中，模型学会从图像中提取代表不同类型食物的特征。然后，使用这些特征根据提供的食谱将食物图像分类到不同的类别中。
一旦深度学习模型训练完成，它就可以部署以将新的食物图像分类到相应的食谱类别中。这对于诸如食品推荐系统、饮食分析和自动生成食谱等各种应用非常有帮助。在这个项目中，我们努力通过迁移学习将印度美食的照片分类到它们的各个类别中。使用卷积神经网络等深度学习方法进行图像分类因其在学习和分类复杂特征方面的有效性而引起了极大的关注。对模型准确性和验证损失进行了比较。
2. 数据集
有许多公开可用的数据集可用于使用深度学习进行食物检测，特别是使用VGG16模型。一个热门的数据集是Food-101数据集，其中包含101个食品类别，共计101,000张图像。每个图像都标有相应的食品类别。可以利用该数据集来训练VGG16模型进行食物图像分类。
训练样本图像，分别为Samosa、Cake、Vada pav、Curry、Fried Rice和Brownie Cake
另一个可用的数据集是UEC-FOOD100数据集，包含100个食品类别，共计9,020张图像。每个图像都标有相应的食品类别。这个数据集也可以用于训练VGG16模型以检测和分类不同类型的食物。
此外，还有其他可用的食品图像数据集，如Food-5K数据集、中国食材数据集和Food20数据集。这些数据集提供了各种各样的食品类别，可以用于训练深度学习模型，包括VGG16。
3. 数据预处理
数据架构流程图
数据预处理是使用卷积神经网络（CNN）进行食物图像的食谱检测任务中的一个关键步骤。它涉及多个关键步骤，以提高模型的性能和准确性：
图像的调整大小和归一化：确保所有图像具有相同的尺寸和像素值。这使得CNN能够有效且一致地处理数据。可以应用图像增强技术，如旋转、平移和翻转，以增加训练数据的多样性。这有助于模型更好地泛化，并在未见过的图像上表现良好。
进行数据清理和过滤以删除数据集中的任何不相关或嘈杂的图像是至关重要的。这降低了模型被不相关特征或离群值困扰的可能性。
在预处理阶段，特征提取和表示发挥了至关重要的作用：CNN能够自动学习有意义的特征，但选择适用于食谱检测任务的适当网络架构和预训练权重是很重要的。
4. 模型训练
使用卷积神经网络（CNN）进行食物图像的食谱检测模型训练涉及多个步骤。
CNN训练流程图
需要收集大量带有相应食谱标签的食物图像数据集。该数据集应涵盖各种不同的食谱和食物类型，以确保模型的鲁棒性。
对数据集进行预处理以增强训练过程。这可能包括调整图像大小、归一化像素值，并通过执行随机翻转、旋转或裁剪来增加数据集。这些步骤有助于模型更好地泛化到未见的数据。
将数据集分为训练集和验证集。训练集用于馈送模型，而验证集用于在训练期间评估其性能并防止过拟合。
需要定义模型架构。由于CNN能够捕捉空间特征，因此通常用于图像识别任务。CNN的层包括卷积层、池化层、激活层和全连接层。
I. 卷积层：这些层对输入图像应用一组可学习的滤波器，以提取重要的特征，如边缘、角和纹理。
II. 池化层：这些层通过总结输入图像的小区域中的特征存在来减小卷积层输出的空间尺寸（高度和宽度）。
III. 激活层：这些层对前一层的输出应用非线性函数，以在模型中引入非线性并提高其学习复杂模式的能力。
IV. 全连接层：这些层将一个层中的每个神经元连接到下一层中的每个神经元。它们通常放置在网络的末尾，以帮助分类或回归任务。
5. Web应用
我们构建了Web应用程序和可消耗的REST API，供用户集成到其应用程序中，以评估和捕获反馈。应用程序的架构如下图所示。
Web应用程序设计和架构
该图显示了一个五层应用程序，包括客户端、服务器、应用服务器、建模和数据库。功能包括图像分类、预测菜肴图像中的食材、获取相似的图像以及在给定一组食材的情况下推荐菜肴。客户端通过进行HTTP GET或PUT请求与服务器进行交互。
6. 实验
我们使用来自各个类别的10,000张图像对应用程序进行了评估。近年来，使用深度学习进行食物图像的食谱检测是一项引人注目的实验。深度学习算法，特别是卷积神经网络（CNNs），在准确识别和分类图像中的不同食物方面取得了令人鼓舞的结果。该实验涉及在大量食物图像及其相应食谱的数据集上训练CNN模型。模型学会从图像中提取有意义的特征并将其与具体的食谱关联起来。通过分析图案、形状和颜色，CNN可以识别食材、烹饪技巧，甚至估计食物的营养价值。
我们还为每个模型构建了REST API，使应用程序成为开源并可供其他用户使用。
6.1 图像分类
将输入图像通过CNN网络进行分类。当对10,000张图像运行分类模型时，达到了95%的准确性。
分类模型输出分类模型输出
7. 反馈
使用深度学习进行食物图像的食谱检测是一个有趣而具有挑战性的问题。深度学习技术，如卷积神经网络（CNNs），在各种图像识别任务中表现出了令人鼓舞的结果。然而，由于食物外观和成分的固有变异性，从食物图像中检测食谱仍然是一项复杂的任务。
一种可能的食谱检测方法可能涉及在一个大型的带有相应食谱标签的食物图像数据集上训练CNN。CNN将学会从图像中提取有用的特征，并将其分类到不同的食谱类别中。迁移学习，即在食物图像数据集上微调预训练的CNN，也可能是一个可行的选择。
另一个需要考虑的方面是食谱数据的可用性和质量。获取大型、多样化且精确标记的食物图像及其相应食谱数据集可能是一项具有挑战性且耗时的任务。确保标记数据的质量和准确性是至关重要的，以实现令人满意的性能。
8. 结论
总的来说，对食物图像中的食谱进行检测可以极大地增强我们的烹饪体验并简化我们的烹饪过程。通过实施先进的图像识别技术和机器学习算法，我们可以准确识别食物图像中描绘的各种食材和烹饪技巧。这使我们能够获取详细的食谱信息和逐步的说明，从而更轻松地重新制作这道菜。
食物图像中的食谱检测的好处多种多样。通过消除基于模糊描述或食材手动搜索食谱的需求，它节省了时间和精力。对于那些有饮食限制或过敏的人来说，检测系统可以根据特定的饮食偏好来过滤食谱，提供解决方案。
此外，食谱检测技术可以激发厨房中的创造力。通过分析不同菜肴的成分和烹饪过程，用户可以轻松地收集想法并尝试加入他们自己独特的元素。
总的来说，对食物图像中的食谱进行检测为家庭厨师和美食爱好者提供了无限的可能性。它彻底改变了我们寻找和准备食物的方式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/779bdeaca82048020d8691606d6ae73f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9f618eaaac0cfc677711f6896c64ca0/" rel="bookmark">
			前缀和算法模板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一维前缀和 算法用途：快速求出数组中某一连续区间的和
一维前缀和算法模板
1、预处理出一个 dp 数组
要求原数组存储在 n + 1 的空间大小中，其中后 n 个空间存数据。
dp数组，数组开 n + 1个空间，dp[i] 表示 [ 1, i ] 区间内所有元素的和。
处理方法： dp[ i ] = dp[ i - 1 ] + arr[ i ] 2、使用前缀和数组
区间 l 到 r 的和： sum = dp[ r ] - dp[ l - 1 ] 复杂度分析
处理前缀和数组，需要 O(N) 的空间复杂度和空间复杂度，求一次区间 l 到 r 的和，需要 O(1) 的时间复杂度，如果需要求 q 次和，则时间复杂度就是 O(q) + O(N)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9f618eaaac0cfc677711f6896c64ca0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc379387250ae93d0a1d21d52b830cca/" rel="bookmark">
			第P9周：YOLOv5-Backbone模块实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 前期准备 1. 设置GPU 我的是笔记本电脑，没有GPU
import torch import torch.nn as nn import torchvision.transforms as transforms import torchvision from torchvision import transforms, datasets import os,PIL,pathlib,warnings warnings.filterwarnings("ignore") #忽略警告信息 device = torch.device("cuda" if torch.cuda.is_available() else "cpu") print(device) cpu 2. 导入数据(数据使用的仍然是天气图片) import os,PIL,random,pathlib data_dir = './9-data/' data_dir = pathlib.Path(data_dir) data_paths = list(data_dir.glob('*')) classeNames = [str(path).split("\\")[1] for path in data_paths] classeNames ['cloudy', 'rain', 'shine', 'sunrise'] train_transforms = transforms.Compose([ transforms.Resize([224, 224]), # 将输入图片resize成统一尺寸 # transforms.RandomHorizontalFlip(), # 随机水平翻转 transforms.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc379387250ae93d0a1d21d52b830cca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c05775314bf3bc84ca63ecd4f0c6c07e/" rel="bookmark">
			cocos creator 如何绑定参数到编辑器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多cocos creator同学不知道如何绑定组件属性到编辑器上，今天我们来教大家如何绑定
1: 基本数据属性绑定到编辑器
这个非常简单，模板是属性名字: 默认的值;
Is_debug: false,
speed: 100,
2: 系统组件类型与节点绑定到编辑器
属性名字: {
type: 组件类型(cc.Sprite, cc.Label, cc.Node, cc.Prefab等)
default: 一般为null, 默认值;
}
3: 资源绑定到编辑器上
属性名字: {
url: cc.AudioClip
default: null,
}
4: 自定义组件类型
通过require获取组件类型:
var a_type = require(“脚本”);;
属性名字: {
type: a_type,
default: null,
}
5: 定义的属性如何访问
这些属性最终在构造组件实例的时候，都会被添加到组件实例的object里面，所以在代码里面访问属性，this(当前组件实例).xxxx属性就可以访问得到
6: 如果想定义属性但是不绑定到面板呢？
方法1: 将属性定义成_(下划线)开头的名字;
方法2: game_over: {
type: cc.Node,
default: null,
visible: false, // 可见性==false;
},
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58f365f4e7e853178ebf6d6391e985b4/" rel="bookmark">
			Python画草莓熊
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 今天，我们来画草莓熊。
一、草莓熊 草莓熊，英文名Lotso，迪士尼公司和皮克斯动画工作室公司于2010年合作推出的动画片《玩具总动员3》(Toy Story3)的反派角色。Lotso就是大受欢迎的反派"草莓熊"--这是一个特殊的角色，他看上去是粉红色、毛茸茸的，闻起来是香甜的草莓味，实则在憨厚可爱的外表下有一颗阴暗扭曲的心。虽然是剧中的反派，他却收获了无数粉丝。剧中草莓熊的悲伤往事，从一开始的阳光明媚、温馨灿烂瞬间转到雷电交加、风雨冰凉，再加上小提琴曲的泣血伴奏，不禁让人黯然泪下，大呼心疼。
代码：
import turtle as t t.colormode(255) t.speed(0) t.screensize(850, 760, "white") t.setup(width=850, height=760, startx=None, starty=None) t.resizemode('noresize') t.tracer(1) scolor = ["#E6005C", "#00BFFF", "#538a30", "#F28500"] qcolor = ["#FF007F", "#87CEFA", "#7fbc2b", "#FFA500"] blsize = 80 bs = 2**0.5/2*blsize zjb = blsize/2 zjsjxxb = 2**0.5 * zjb length = 1.7*blsize width = 2/15*blsize def fongche(): t.penup() t.goto(-205, -42) t.begin_fill() t.pensize(4) t.pencolor("#321320") t.fillcolor("#D2B48C") t.circle(15) t.end_fill() t.penup() t.goto(-220, 80) t.pendown() t.setheading(-90) t.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58f365f4e7e853178ebf6d6391e985b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d42d24e79b1326a9d9b690d3c4fc0432/" rel="bookmark">
			在openEuler环境下快速编译GreatSQL RPM包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在上一篇中，已经介绍了在CentOS环境下编译GreatSQL RPM包的过程，本文再介绍如何在openEuler环境下编译GreatSQL RPM包。
运行环境是docker中的openEuler 22.03 x86_64：
$ docker -v Docker version 20.10.10, build b485636 $ docker run -itd --hostname oe --name oe openeuler/openeuler bash 1d2839ec30c28c7b20bbd6f469964b0b68ddf6485a0c4136b030c14812f8dec3 $ docker exec -it oe bash 1、准备工作 1.1、配置yum源 用默认的yum源即可，无需额外添加。
1.2、安装编译所需要的软件包 安装 rmp-build 包，它会附带安装其他必要的相关依赖包，并同步安装其他必要的软件包，如cmake、gcc等：
[root@oe /]# dnf install -y automake bison bison-devel bzip2 bzip2-devel clang cmake cmake3 diffutils expat-devel file flex \ gcc gcc-c++ gcc-toolset-12-cpp gcc-toolset-12-gcc graphviz jemalloc jemalloc-devel libaio-devel \ libarchive libcurl-devel libevent-devel libffi-devel libicu-devel libssh libtirpc libtirpc-devel \ libtool libxml2-devel libzstd libzstd-devel lz4-devel lz4-static make ncurses-devel ncurses-libs \ net-tools numactl numactl-devel numactl-libs openldap-clients openldap-devel openssl openssl-devel \ pam pam-devel perl perl-Env perl-JSON perl-Memoize perl-Time-HiRes pkg-config psmisc re2-devel \ readline-devel rpcgen rpm-build rpm-build snappy-devel tar time unzip vim wget zlib-devel 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d42d24e79b1326a9d9b690d3c4fc0432/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc4cbbfbb4ca4917d115d6e409dd6b2d/" rel="bookmark">
			fmincon函数求解非线性超越方程的学习记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近的算法中用到了fmincon函数，寻找多变量非线性方程最小值的函数；因此学习一下；
fmincon函数的基础语法如下所示：
fmincon函数是为了求解下列方程的最小值；
b 和 beq 是向量，A 和 Aeq 是矩阵，c(x) 和 ceq(x) 是返回向量的函数，f(x) 是返回标量的函数。f(x)、c(x) 和 ceq(x) 可以是非线性函数。x、lb 和 ub 可以作为向量或矩阵传递；
1 应用一：求解线性不等式约束方程 x= fmincon(fun,x0,A,b),从 x0 开始，尝试在满足线性不等式 A*x&lt;b 的情况下寻找 fun 中所述的函数的最小值点 x。x0 可以是标量、向量或矩阵。
代码实例：
fun = @(x)100*(x(2)-x(1)^2)^2 + (1-x(1))^2; x0 = [-1,2]; A = [1,2]; b = 1; x = fmincon(fun,x0,A,b) 代码功能：
函数： f [x(1),x(2)] = 100*(x(2)-x(1)^2)^2 + (1-x(1))^2;
从点[-1，2]开始求最小值，约束方程为： x(1)+2x(2) &lt;= 1 。 这个方程的系数矩阵为 [1,2]，最大值为1，因此设置 A = [1,2] , b = 1 ，最终函数以 A*x &lt; b 形式表达此约束。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc4cbbfbb4ca4917d115d6e409dd6b2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/869087e7f5f122904adcb9919d3f34b7/" rel="bookmark">
			java--连接池
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		连接池作用：
每次连接数据库时，都需创建及销毁连接；在频繁访问数据库的情况下，是非常耗费资源的
连接池可以批量创建多个连接，提升性能，避免资源浪费.
我们可以将建立连接和销毁连接封装起来，方便调用
private static ArrayList&lt;Connection&gt; list= new ArrayList(); Class.forName("com.mysql.jdbc.Driver"); for(int i = 0; i &lt; 3; i++) {//批量建立链接 Connection conn = DriverManager.getConnection("jdbc:mysql:///mydb_21", "root", "root"); list.add(conn);//放入集合 取连接：
public Connection getConnection() throws SQLException{//取链接 if(list.size() &lt;= 0){//集合中无可用链接则重新创建 for(int i = 0; i &lt; 3; i++){ Connection conn = DriverManager.getConnection("jdbc:mysql:///mydb_21","root","root"); } } return list.remove(0); } 还连接 ：
public void retConnection(Connection conn){//还链接 if(conn != null) list.add(conn); } 整体代码：
import javax.sql.DataSource; import java.io.PrintWriter; import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/869087e7f5f122904adcb9919d3f34b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/861c04a28bbe54f8e48b21f4fd6a8fa9/" rel="bookmark">
			【算法笔记】深入理解dfs（两道dp题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DFS过程的概述 一个一个节点的搜，如果是树状结构的话，先找到最左边那一条分支搜到最后一个节点，这个时候最后一个节点（假设是b）的数据会被更新（具体看题目的要求），然后返回到上一个节点(假设是a)（如果有两层dfs的话，需要画个分叉图辅助理解）。 此时a节点使用下层刚刚被更新过的数据(即b节点)来更新a节点的数据。更新完后如果a节点下方还有一个节点，那么就要继续往下搜索，继续把a节点的数据更新完全（也就是把a节点的分支都找完了）。那么当a节点的数据被完全更新完后，又会重复上面那个过程。也就是说我们可以把以a节点为根的子树看成一个新的节点（这样子方便理解）
从上面的分析可以看出，dfs会把更新后的数据存储起来，不管这个更新是完全更新还是部分更新。这个也很好理解，因为一次dfs只会对一个节点进行操作（而且是从下往上的过程）（这就说明一个节点可能要经过多次dfs才能把数据完全更新），也就是用一种很笨的方法（如果没有剪枝的话，和暴搜没区别）去更新数据和答案。
有依赖的背包问题 思路:在这一题里，我们需要更新每颗子树的最大价值，然后计算出包括根节点的树的最大价值。对于树的遍历，我们一般可以用dfs来遍历，因为dfs从最底层的节点开始往上遍历。
这里的f[ i ][ j ]的含义是考虑第i个物品为根节点的子树，且选上i，体积不超过j的最大价值。
#include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; using namespace std; const int N = 110; vector&lt;int&gt; g[N]; int v[N], w[N]; int f[N][N]; int n, m; void dfs(int u) { for(int i = v[u]; i &lt;= m; i ++) f[u][i] = w[u]; for(int i = 0; i &lt; g[u].size(); i ++) { int y = g[u][i]; dfs(y); //一直往下搜索树的节点，直到找到最底层的节点，然后执行状态转移方程，然后返回到上一个节点 for(int j = m; j &gt;= v[u]; j --) for(int k = 0; k &lt;= j - v[u]; k ++) { f[u][j] = max(f[u][j], f[y][k] + f[u][j-k]); } } } int main() { int root; cin&gt;&gt;n&gt;&gt;m; for(int i = 1; i &lt;= n; i ++) { int fa; cin&gt;&gt;v[i]&gt;&gt;w[i]&gt;&gt;fa; if(fa == -1) root = i; else g[fa].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/861c04a28bbe54f8e48b21f4fd6a8fa9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bc72162bc681a68e59c65eafb1e8cc7/" rel="bookmark">
			Java并行流parallelStream()下InheritableThreadLocal引起的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java并行流parallelStream()下InheritableThreadLocal引起的问题
引起问题的代码。
List orgs00 = Arrays.asList( new Org("aaa"), new Org("bbb"), new Org("aa0") ); List orgs = orgs00.parallelStream() .map(org -&gt; { // 模拟从数据库中获取 Org 对象的操作 // 这里可以是实际的数据库查询操作 ConditionImpl cmd = new ConditionImpl(); cmd.op("orgName", Op.eq, org.getOrgName()); //	cmd.orderBy("name", OrderType.ASC); System.out.println("-----------------111111111111111111111111-"); List select1 = getSuidRich().select(new Org(), cmd); //语句1：这句会调用数据库 return new Org(org.getOrgName()); }) .collect(Collectors.toList()); 问题：语句1调用的方法有条词句： private static ThreadLocal&gt;&gt; sqlPreValueLocal; 经过orgs00.parallelStream().map()) 执行调用语句1，sqlPreValueLocal是同一个本地变量吗？ 并行流场景下使用 ThreadLocal， sqlPreValueLocal = new InheritableThreadLocal&lt;&gt;(); //语句1
或者
sqlPreValueLocal = new ThreadLocal&lt;&gt;();//语句2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bc72162bc681a68e59c65eafb1e8cc7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afe00f44197eac331a54f882af1b7a3b/" rel="bookmark">
			ChatGPT实战手册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ChatGPT是 OpenAI 的一个强大的自然语言处理模型，它可以生成人类般的文本。在这篇文章中，我们将通过一个实战示例来展示如何安装、配置和使用 ChatGPT。
安装 首先，你需要安装 OpenAI 的 Python 客户端库。你可以使用 pip 来安装：
pip install openai 配置 然后，你需要获取一个 OpenAI 的 API 密钥。你可以在 OpenAI 的网站上注册一个账户，然后在你的账户设置中生成一个新的 API 密钥。
在你的 Python 脚本或 Jupyter notebook 中，你需要导入 openai 模块，并设置你的 API 密钥：
import openai openai.api_key = 'your-api-key' 使用 现在，你可以开始使用ChatGPT了。你可以使用 ​​openai.ChatCompletion.create()​​ 方法来生成一个聊天响应。你需要提供一个模型（例如 "智能小助手-3.5-turbo"）和一个消息列表。每个消息都有一个角色（"system"、"user" 或 "assistant"）和一个内容。
回答问题 以下是一个示例，展示如何使用ChatGPT来回答问题：
response = openai.ChatCompletion.create( model="gpt-3.5-turbo", messages=[ {"role": "system", "content": "You are a helpful assistant."}, {"role": "user", "content": "Who won the world series in 2020?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afe00f44197eac331a54f882af1b7a3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11ccaeb18a4c65cd5e7765cb03a2b956/" rel="bookmark">
			淘宝网简易实现, Html &#43; css &#43; Javascript &#43; Jquery &#43;Swiper &#43;Vue, 期末js大作业
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先上一张页面效果图, 下载地址往最下面翻
🎨本项目演示地址: 淘宝网-淘！我喜欢https://mobeicanyue.github.io/taobao/
项目亮点: (相应代码)
导航栏的下拉动画, jQuery实现 $('#me').hover( function () { $('#me1').slideDown().fadeIn(200) }, function () { $('#me1').slideUp().fadeOut(100) }) $('#folder').hover( function () { $('#folder1').slideDown().fadeIn(200) }, function () { $('#folder1').slideUp().fadeOut(100) }) 搜索框和按钮双向绑定(VUE实现) (其实就是复习一下vue的知识, 没有特别的) &lt;div class="search-m-input"&gt; &lt;label&gt; &lt;input class="box1" type="text" name="search" placeholder="search..." v-model="name"&gt; &lt;/label&gt; &lt;button class="btn" type="submit" id="search" onclick="window.location.href='jump.html'"&gt; 搜索{{name}} &lt;/button&gt; &lt;/div&gt; &lt;script&gt; new Vue({ el: '.search-m-input', data: { name: '' } }) &lt;/script&gt; 按钮放大缩小动画,jQuery实现 function toBig(item) { let i = $(item); i.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11ccaeb18a4c65cd5e7765cb03a2b956/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4621367abead906eef7475e1fe6f8feb/" rel="bookmark">
			【mysql】报错1349 - View‘s SELECT contains a subquery in the FROM clause
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 操作 创建视图的sql语句中有不支持子查询
mysql创建视图
select * from ( select name,age from table_name where 1=1 and name='a' ) tb where 1=1 and type=1 问题 报错1349 - View’s SELECT contains a subquery in the FROM clause
原因 原因创建视图的sql语句中有不支持子查询，
解决 需要将子查询的结果单独创建一个视图，将子查询创建的视图v_table_a，然后在建一张表v_table_b去查询v_table_a
子查询视图表v_table_a select name,age from table_name where 1=1 and name='a' 再创建视图v_table_a查询子查询v_table_b select * from v_table_a where 1=1 and type=1 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0240676537da4385fc54cba2a06366f9/" rel="bookmark">
			硬盘技术深度解析：协议、总线、接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		硬盘技术深度解析：协议、总线、接口 硬盘是计算机存储系统的核心组件，其协议、总线和接口的选择直接影响着系统性能和应用场景。本文将深入探讨当前主流硬盘技术，以表格形式呈现各项技术规格。
1. 硬盘协议 协议描述特点IDE已淘汰的协议传输速度相对较低，适用性有限AHCIAdvanced Host Controller Interface适用于SATA设备，提供高级硬盘控制功能NVMeNon-Volatile Memory Express面向固态硬盘，提供卓越性能SCSISmall Computer System Interface用于服务器领域，支持多设备连接，提供高可靠性和性能 2. 硬盘总线 总线描述特点SATASerial ATA适用于个人计算机和消费电子产品，广泛兼容PCIePeripheral Component Interconnect Express高速串行点对点连接，主要用于固态硬盘SASSerial Attached SCSI用于服务器和高性能计算环境，提供更高可靠性和性能 3. 硬盘接口 接口描述特点SATASerial ATA传统机械硬盘常用，广泛兼容mSATAMini SATA小型SATA接口，适用于轻薄型设备SATA ExpressSATA混合PCIe接口提供更高数据传输速度M.2M.2接口（B-key &amp; M-key）小型高性能接口，适用于高性能固态硬盘PCIePeripheral Component Interconnect Express主要用于固态硬盘，提供更快数据传输速度U.2U.2接口用于连接高性能存储设备，适用于企业级应用SASSerial Attached SCSI连接服务器级别硬盘，提供高可靠性和性能 以上表格详细呈现了硬盘协议、总线和接口的特点，深入了解这些关键技术有助于为个人和企业选择最优硬盘提供指导。
参考：
http://t.csdnimg.cn/NHxIb
http://t.csdnimg.cn/Nw8Fk
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a4acbb0f3b01857a42898b84d481ad4/" rel="bookmark">
			【Linux Shell】8. test 命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 【 1. 数值测试 】【 2. 字符串测试 】【 3. 文件测试 】 Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。 【 1. 数值测试 】 参数作用-eq等于则为真-ne不等于则为真-gt大于则为真-ge大于等于则为真-lt小于则为真-le小于等于则为真 实例 #!/bin/bash num1=100 num2=100 if test $[num1] -eq $[num2] then echo "EQUAL" else echo "NOT EQUAL" fi 【 2. 字符串测试 】 参数作用=等于则为真!=不相等则为真-z字符串 字符串的长度为零则为真-n字符串 字符串的长度不为零则为真 实例 #!/bin/bash str1="Promethus" str2="Jarvis" if test $str1 = $str2 then echo '两个字符串相等!' else echo '两个字符串不相等!' fi 【 3. 文件测试 】 参数作用-e 文件名如果文件存在则为真-r 文件名如果文件存在且可读则为真-w 文件名如果文件存在且可写则为真-x 文件名如果文件存在且可执行则为真-s 文件名如果文件存在且至少有一个字符则为真-d 文件名如果文件存在且为目录则为真-f 文件名如果文件存在且为普通文件则为真-c 文件名如果文件存在且为字符型特殊文件则为真-b 文件名如果文件存在且为块特殊文件则为真 实例1：查看文件是否存在。 #!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a4acbb0f3b01857a42898b84d481ad4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6660443c139a5434ca7ac84983171e80/" rel="bookmark">
			详解结构体（包含结构体内存对齐，柔性数组，位段）【尊嘟很详细】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 结构体结构体的定义结构变量定义：初始化：运算：传参： 用typedef给结构体命名结构体的内存对齐（用干计算结构体的大小）：偏移量结构体的对齐规则: 位段：位段的定义：位段的特点：位段中的截断位段的跨平台问题：位段总结: 柔性数组：定义：特点：柔性数组的使用：柔性数组的好处总结 结构体 结构体是一些值的集合，这些值称为成员变量，结构的成员可以是标量、数组、指针,甚至是其他结构体。
成员名可以与程序中其它变量同名，互不干扰。
一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一
结构体的定义 （struct+结构名+{}）
struct books { int a; char b; struct book* c; };//分号不能少// 结构体成员不能在结构体内赋初值
关键字struct与结构名一起构成结构类型名
例
struct books是一个结构类型名
结构体可以嵌套定义
但结构体定义时不允许将成员的数据类型定义成自身的结构类型，这是因为结构类型的声明是构造阶段，系统还不知道需要分配多少内存空间。
但是结构类型中可以含有指向自身类型的指针变量。
一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一
结构变量 定义： ①在结构体定义时定义，此时变量位于结构体{}之后的；之前
②在结构体定义完后定义
③在匿名结构体定义时定义
由于此定义省去了结构名在此定义语句后面无法再定义这个类型的其他结构变量,除非把定义过程再写一遍。
另外，以后如果再声明成员完全相同的结构类型，也和此次定义的结构类型属于不同的结构类型。
一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一
初始化： 对结构变量初始化时,需要按照其成员出现的顺序对每个成员依次赋值.
不能跳过前面的成员给后面的成员赋值
例如下面的用法是错误的：
struct books ps = { 1002, ,p}; 一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一
运算： 相同类型的结构体变量可以进行整体赋值，但不能进行关系运算
一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一
传参： ①传值：要重新拷贝一份结构体变量，空间和时间的浪费比较大。
②传址：只需要传4/8个字节，速度更快。
所以结构体传参的时候最好使用传址调用
一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一
用typedef给结构体命名 结构体的类型名是 struct+结构名，如果觉得它太长了，可以在定义时/定义完成后用typedef给结构体重命名。
重命名方法：
①非匿名结构体重命名
②匿名结构体重命名
结构体重命名之后就可以像定义int 类型变量一样，定义结构变量了
也可以在定义后给结构体重命名（此时只能给非匿名结构体重命名，
给匿名结构体重命名会报错）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6660443c139a5434ca7ac84983171e80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/159e5adb3abf7f993d628b4e671dcca1/" rel="bookmark">
			新手如何下载并安装Tableau？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Tableau是当前最流行的BI分析软件之一，它的可视化及数据分析能力非常强大，而且操作简单，适合非IT岗位当作主力数据工具。在Gartner BI最新排名中，Tableau仅次于微软的PowerBI，排名第二。
我身边很多财务、会计、销售、产品等在使用Tableau开发数据，上手起来并不难。
Tableau有个产品家族，其中Desktop是桌面BI软件，也就是我们常说的Tableau。Prep是数据预处理软件，能对数据源进行清洗并接入Desktop。Server是在线共享中心，可以提供线上自助式分析。
使用Tableau Desktop的第一步是下载并安装，作为商业软件，你需要购买Tableau的产品秘钥，才能激活软件。当然你也可以试用14天，再考虑是否购买。
1、下载Desktop Tableau一般每个季度会进行版本更新，现在大概是2022.4版本，软件会向前兼容。
你可以去Tableau中国官网下载最新的Desktop，也可以安装历史版本。
[Tableau Desktop]
需要下载的安装包大小大概600M，需要你的硬盘有5G左右的剩余空间来安装。
下载完成后，直接点击打开即可，会进入安装界面。
2、安装Desktop 安装需要自定义存储位置，建议放非C盘，其他无需操作，一路next即可。
安装好后进行注册并输入秘钥，就可以激活使用。
如下表示激活成功。
接下来就可以使用Tableau来搭建BI看板了。
在学习python中有任何困难不懂的，可以微信扫描下方CSDN官方认证二维码加入python交流学习多多交流问题，互帮互助，这里有不错的学习教程和开发工具。
（这里每天都会不定时更新python不同题型和教程，希望大家一起学习，一起进步）
👉[[CSDN大礼包：《python安装包&amp;全套学习资料》免费分享]]（安全链接，放心点击）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c222f87dbcc2aafb57fb3a616307b45d/" rel="bookmark">
			Python 自动化办公- openpyxl 创建一个 Excel 写入数据自动存储
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇 自动化办公文章中介绍了 openpyxl 模块处理 Excel 文件的一些基本命令，但文章中涉及的操作命令并不是很全，因此就有了本篇文章；引入一个例子从 创建 Workbook 到存储到本地磁盘，涉及的操作命令会更全面一些，内容概括如下：
新建 Workbook，并保存；新建 sheet ，修改标题、tabColor；对 sheet 中的单元格进行赋值；删除 sheet 中指定行、列(可多行、多列)；插入 sheet 中指定行、列(可多行、多列)；sheet 中指定列添加筛选机制；合并单元行；设置单元格字体样式、填充样式、对齐样式；应用 Excel 表格中函数命令； 本文下面Python构建的办公自动化项目都有详细的配套教程以及源码，都已经打包好上传到百度云了，链接在文章结尾处！
扫码此处领取大家自行获取即可~~~
1，创建一个新的 Excel 文件(Workbook)
from openpyxl import Workbook from openpyxl.utils import get_column_letter wb = Workbook() dest_filename = "Empty_book.xlsx" wb.save(dest_filename) 2，更改 sheet 标题
ws1 = wb.active ws1.title = 'range names' **3，在第一个 sheet 40*600 个单元格中填充数据 **
for row in range(1,40): ws1.append(range(600)) 4，应用求和函数公式
openpyxl 还有一个强大的功能，可以使用 Excel 表格内置函数；函数语法与 Excel 中的基本相同，使用之前需要在 导入模块加入一行代码导入 FORMULAE 模块
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c222f87dbcc2aafb57fb3a616307b45d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34fd421a0eccc5f2f0eecd9222c69bed/" rel="bookmark">
			面试经典题---6.Z字形变换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		6.Z字形变换
我的解法：
首先定义了3个变量：index、add和step。
index：当前处理字符在原字符串中的下标；add：Z字形中相邻两个字符在原字符串中的下标之差（非固定值，值随着行的改变会发生变化，这里是除了Z字形的第一行和最后一行）；step：Z字形中第一行和最后一行相邻两字符在原字符串中的下标之差（固定值2*numRows-2） 之后使用for循环，每轮确定最终Z字形的一行数据，因此共有numRows次循环。
每轮循环中元素下标index从i开始，再使用while循环确定当前Z字形这一行所对应的字符，通过add和step确定Z字形这一行当前元素的下一元素在原字符串中的下标（第一行和最后一行，下一元素的下标增加了step，其余行，下一元素下标多了add）
N字形示意图，其中x代表numRows
class Solution { public: string convert(string s, int numRows) { if(numRows == 1){ return s; } string res; int n = s.length(); int index,add,step = 2 * numRows - 2; for(int i = 0; i &lt; numRows; ++i){ index = i; add = 2 * i; while(index &lt; n){ res += s[index]; add = step - add; index += (i == 0 || i == numRows - 1) ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34fd421a0eccc5f2f0eecd9222c69bed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef46ccac96283b358f0c277500a11dfa/" rel="bookmark">
			关于《码农翻身》一书的读后感以及自己的一些拙见汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		书籍名称 《码农翻身》 | 刘欣（@码农翻身） 著 |
文章将以问答的形式进行叙述 1.是从什么渠道接触到《码农翻身》的
一个工作日的下午，手上的任务基本结束，翻了翻桌上的书和笔记之类的，同事见我在看书，于是向我推荐了《码农翻身》这本书，他跟我简单介绍了下这本书的易读性，以及大概章节，感觉文章的叙述方式蛮有意思的，就借来了
2.用时多久读完
从同事那里借来以后，到今天看完有大概半个月的时间，因为内容是以第三人称展开的，所以都得比较快，很惭愧没有细读
3.为什么会对此书独有情钟，想要总结读后感
这是我为数不多的从头到尾读完的，当时同事跟我讲解的时候，随便翻了几页当时就有了这个想法，到今天全部读完以后，感觉是有很多收获的，也想记录下读书心得
4.大致讲一下此书的内容
总共分为六个章节（内容比例大概为4:4:2:1:1:1)，前五章讲的是计算机以及编程方面的基础知识，最后一章是工作以及学习中的提升效率方法
第一章 计算机的世界
该部分的内容占比较多，通过第三人称的视角讲述了我们日常使用的电脑在另一个维度的情景，每个零件每个程序都有自己的身份，开篇以一个线程的视角展开计算机世界的宇宙观，结合古时驿站传递消息的背景分析了TCP/IP之间的连接方式和演进史，到后面的CPU（阿甘）的工作原理，再到后面的输入输出设备，从每个零件的视角讲解了我们使用的计算机底层是怎么运行起来的，以及零件之间的工作关系。大致就是专业课四大天书中的《计算机网络》《计算机操作系统》《计算机组成原理》的微宇宙版本，但是没有书上覆盖的这么全面
第二章 Java的世界
该部分占比与第一章相差无几，开章从古时帝国的崛起以及殖民统治的环境，以C语言的长时间统治下，Java语言是如何突破重围以及打压并得到大多程序员的拥赖的故事线展开的，介绍了Java语法中常见的一些语法介绍，比如泛型，动态代理，继承，序列化等，并且介绍了与别的中间件的联系，比如数据库连接、消息队列的工作原理，spring注解开发的演进史等。大致就是刚开始学习Java时的路线，从Java基础，面向对象开发，数据库，Spring系列等等粗略的过了一遍
第三章 Web的世界
该部分占比只有前两章的一半左右，开章从超链接的形成开始入手，捋了一遍HTTPS数据传送的安全性是如何一步一步演进到全面的，着重讲解了数据库，并且引进了常用的非关系型数据库Redis是如何互相搭配工作的，除了数据库还讲到了Tomcat，Nginx等工具。就像当时出学Java web的时候，自己搭建Tomcat服务器，连接数据库等等在框架没使用之前需要手动操作的步骤，这里有从第三视角讲解
第四章 代码管理的演变
该部分占比就少很多，只有第三章的一半不到，开篇也是从第三视角讲解代码的版本管理演变，从最开始的锁定文件避免冲突，到后面的允许冲突，再到后面的微服务管理，阐述了Git等版本管理工具的演变史，一样的而手法，叙述了管理工具Maven的崛起，以及后面敏捷开发和代码重构。这里就是涉及到编码中用到的管理工具Maven以及工作中常用的Git代码管理工具，以及代码重构的讲解
第五章 编程语言史
该部分与第四章的占比相差无几，从JavaScript的视角，讲述了如何从草根逆袭到与Java不相上下的过程，通过讲解C语言，Java语言，Python语言，Ruby等语言的热榜交替分析了编程语言世界中的竞争激烈，最后以命令式编程和声明式编程收掉本章的结尾。该部分大致讲解了JavaScript语言从前端语言演变到服务器端浏览器端都可用的过程
第六章 持续提升能力的愿景
该部分作为全书的结尾，占比不是很多，开篇讲解程序员的发展道路，以及编码时一些常用的提高效率的技巧，最后以作者对自己的编码经验总结为末结束了全文，全书的最后两页也是教唆我们不要想文中所举的例子一样，”摇摆不定“、”行动的矮子“、”不看书“、”半途而废“
5.有怎样的阅读感受
首先，文章是以一种新颖的角度来讲解我们认为比较抽象的计算机底层逻辑，可以帮我们更加容易理解平时所学的理论知识，比如计算机网络方面的TCP通信协议的原理、三次握手等，计算机组成原理中讲解的计算机的主要构成以及每个部件在操作系统中发挥的作用，作者通过第三人称的角度将每个零件描绘的有声有色，让充满机械感的计算机也有不一样的生命感
其次，文章对初入门的程序员也是很友好，因为在读书过程中会给人一种恍然大悟的感觉，“嗷，原来专业书上讲的是这个意思！”，当然，我觉得对于计算机专业的小白来讲也是挺不错的，可以全面的了解自己未来要接触的专业课知识的构成，以及未来从事自己喜欢的开发语言，起到一个启迪的作用
最后呢，如果以后有机会的话，我希望能静下心来再仔细阅读一遍，因为我始终相信，“温故而知新”，也相信下次读完之后会有更深刻的理解，对我的未来职业规划也是有很大帮助的
6.后续计划
在第一次接触这种类型的技术文章后，越发觉得这种生动形象的描绘出较为抽象的知识很重要，我也会继续寻找此类书籍，并且遇到比较好的一些也会记录下来，以供大家参考
------------------------------------------------ END -------------------------------------------------------------------
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84cbacf09fba2dd0c28e9381b878e125/" rel="bookmark">
			c&#43;&#43;属于同一个类的不同对象之间可相互访问private和protected成员
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先看一个代码例子：
#include &lt;stdio.h&gt; class A { private: char* name; void printA_Name() const { printf(name); } public: A(char* name) { this-&gt;name = name; } void printA_Name(const A&amp; a) { printf(a.name); } void printA_Name2(const A&amp; a) { a.printA_Name(); } }; int main(void) { A a1("a1"); A a2("a2"); a2.printA_Name(a1); a1.printA_Name2(a2); } 这个例子是能正常编译通过。按照c++的语法，一个对象的私有成员或保护成员不能在类的外部被访问。但是有个例外，同属于一个类的不同对象之间可相互访问private和protected成员（包括成员变量或成员函数）。原来关键字private和protected是基于类的而不是基于对象的。这样的设计多少有点破坏了封装的思想，可是没有办法，考虑这样一种情况：在实现类的拷贝构造函数和赋值运算符的时候，就需要去访问另一个对象的private和protected成员（如果有的话），假如限制了同属于一个类的不同对象之间去访问private和protected成员，就无法实现了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/172eccbdaef700bbda3c38d3c4dc6179/" rel="bookmark">
			个人对STM32 SysTick的总结(寄存器操作)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概述：
SysTick是一个简单的递减24位计数器。如果你不需要再应用程序中嵌入操作系统，SysTick可以作为简单的延时和产生周期性的中断。
状态控制寄存器的第0位可以使能计数器，当前值寄存器随着时钟一直递减，当他减到0的时候，重装载寄存器就会重新装载这只的值，计数器继续从这个值递减。
二、相关寄存器：
2.1 SysTick-&gt;CTRL 状态和控制寄存器
位16：当前值寄存器递减到0，位16置1
位2：时钟源选择位，0：使用外部参考时钟；1：使用内核时钟
位1：使能SysTick中断，当前值寄存器递减到0时产生中断
位0：SysTick时钟使能
2.2 SysTick-&gt;LOAD 重装载值寄存器
当前值寄存器为0时，自动将重装载值重装到当前值计数器，重装载值的大小需要自己设置。
2.3 SysTick-&gt;VAL当前值寄存器
可读可写，当计数器使能时，这个寄存器的值开始递减，使用前后注意清零。
三、SysTick逻辑图
四、时钟频率与延时
4.1时钟选择
采用参考8分频的参考时钟比较准，所以此处SysTick计数器选择21M的时钟。
4.2 如何延时1us
时钟频率为21M，也就是1s的时间技术21M次。由此可知计数一次用了 (1/21000000)s ，用了(1/21000)ms, 用了(1/21) us，所以，1us计数21次。
4.3 如何延时1ms
因为1ms = 1000us，所以综上所述，1ms计数1000*21次计数，1ms也就是21000次计数
4.4最大延时
24位计数器能保存的最大值 : 16777215。最大延时时间=16777215 /21=798915us=798.915ms
五、示例代码
#include "delay.h" #define Value_us 21 #define Value_ms 21000 void delay_init(void) { SysTick-&gt;CTRL &amp;= (1 &lt;&lt; 2); //控制寄存器位2置0，选择8分频时钟 SysTick-&gt;CTRL &amp;= ~(1 &lt;&lt; 0); //关闭计数器 } void delay_us(u32 num) { SysTick-&gt;LOAD = num * Value_us; SysTick-&gt;VAL = 0; SysTick-&gt;CTRL |= (1 &lt;&lt; 0); //使能计数器 while (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/172eccbdaef700bbda3c38d3c4dc6179/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34fdb1eb3bd19d75bcef1839b789ff07/" rel="bookmark">
			Java刷题错题笔记-day04-集合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.在JDK8中，ConcurrentHashMap的数据结构是怎样的？ 数组+链表+红黑树，和HashMap一样
Node数组： ConcurrentHashMap内部维护一个Node数组，其中每个Node就是键值对的存储单元。链表： 每个Node实际上是一个链表的头节点。当发生哈希冲突时，新的节点会被添加到对应位置的链表中。红黑树： 当链表长度达到一定阈值（默认是8），链表会被转换成红黑树。这是为了在高并发情况下提高查找效率。 2.在JDK8中，ConcurrentHashMap如何保证线程安全的？ 运用CAS+synchronized机制
ConcurrentHashMap在putVal方法中，添加元素时，
若链表为空，此时使用CAS乐观锁机制添加元素
若链表不为空，（存在Hash冲突场景）使用synchronized悲观锁来保证线程安全
3.在JDK8中，ConcurrentHashMap的get方法如何保证数据一致性的? volatile+CAS(修改操作时)
1.volatile关键字： 在ConcurrentHashMap的Node类中，键值对的value字段被声明为volatile。这意味着对该字段的读取和写入操作都是原子的，并且会立即被其他线程可见。这有助于确保当一个线程修改了Node中的值时，其他线程能够立即看到最新的值。
static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; { final int hash; final K key; volatile V val; volatile Node&lt;K,V&gt; next; // ... } 2.CAS操作： ConcurrentHashMap使用CAS操作来更新Node中的值。当多个线程同时尝试更新同一个Node的值时，只有一个线程会成功，其他线程需要重试。这确保了在并发情况下对Node值的更新是线程安全的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e737c4e19f8df95b5f1117f7edd711d6/" rel="bookmark">
			实战干货：用 Python 批量下载百度图片！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了做一个图像分类的小项目，需要制作自己的数据集。要想制作数据集，就得从网上下载大量的图片，再统一处理。
这时，一张张的保存下载，就显得很繁琐。那么，有没有一种方法可以把搜索到的图片直接下载到本地电脑中呢？
有啊！用python吧！
我以“泰迪”、“柯基”、“拉布拉多”等为关键词，分别下载了500张图片。下一篇，我打算写一个小狗分类器，不知道各位意见如何！
结果演示：
首先，打开百度图片首页，注意下图url中的index
接着，把页面切换成传统翻页版（flip），因为这样有利于我们爬取图片！
对比了几个url发现，pn参数是请求到的数量。通过修改pn参数，观察返回的数据，发现每页最多只能是60个图片。
注：gsm参数是pn参数的16进制表达，去掉无妨
然后，右键检查网页源代码，直接（ctrl+F）搜索 objURL
这样，我们发现了需要图片的url了。
2.把图片链接保存到本地
现在，我们要做的就是将这些信息爬取出来。注：网页中有objURL，hoverURL…但是我们用的是objURL，因为这个是原图那么，如何获取objURL？用正则表达式！那我们该如何用正则表达式实现呢？其实只需要一行代码…
results = re.findall('"objURL":"(.*?)",', html) 核心代码：
1.获取图片url代码：
# 获取图片url连接 def get_parse_page(pn,name): for i in range(int(pn)): # 1.获取网页 print('正在获取第{}页'.format(i+1)) # 百度图片首页的url # name是你要搜索的关键词 # pn是你想下载的页数 url = 'https://image.baidu.com/search/flip?tn=baiduimage&amp;ie=utf-8&amp;word=%s&amp;pn=%d' %(name,i*20) headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.104 Safari/537.36 Core/1.53.4843.400 QQBrowser/9.7.13021.400'} # 发送请求，获取相应 response = requests.get(url, headers=headers) html = response.content.decode() # print(html) # 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e737c4e19f8df95b5f1117f7edd711d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1f016f95abbae18998e660698e0ede4/" rel="bookmark">
			Python for循环详解【附代码实例】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、for循环二、for循环语法如下三、 for循环应用案例 案例一：for循环实现方式案例二：遍历字典案例三：for循环嵌套 四、总结for循环与while循环的异同五、for循环控制循环次数：range()六、for循环的跳出 练习一：练习二： 读者福利零基础Python学习资源介绍 一、Python所有方向的学习路线二、Python学习软件三、Python入门学习视频四、Python练习题五、Python实战案例六、Python面试资料七、资料领取 一、for循环 for循环：循环就是重复做某件事，for循环是python提供第二种循环机制（第一种是while循环），理论上for循环能做的事情，while循环都可以做。
目的：之所以要有for循环，是因为for循环在循环取值（遍历取值）比while循环更简洁。
（文末送读者福利）
二、for循环语法如下 for 变量名 in 可迭代对象: # 此时只需知道可迭代对象可以是字符串\列表\字典，其实也可以是tuple(),set()
代码一
代码二
# # for循环 # # 列表取值 # l = ['lsj','a','b'] # for x in l: # print(x) lsj a b ... # 参照例1来介绍for循环的运行步骤 # 步骤1：从列表['lsj','a','b']中读出第一个值赋值给x（x=‘lsj’），然后执行循环体代码 # 步骤2：从列表 ['lsj','a','b'] 三、 for循环应用案例 案例一：for循环实现方式 # 简单版：for循环的实现方式 # l = ['lsj', 'b', 'c'] # 定义一个列表 # for x in l: # print(x) # lsj # b # c # 复杂版：while循环的实现方式 l = ["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1f016f95abbae18998e660698e0ede4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e88f9d7e819dc36253b36a00113b0530/" rel="bookmark">
			软件测试|教你如何使用UPDATE修改数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 简介 在SQL（Structured Query Language）中，UPDATE语句用于修改数据库表中的数据。通过UPDATE语句，我们可以更新表中的特定记录或多条记录，从而实现数据的修改和更新。本文将详细介绍SQL UPDATE语句的语法、用法以及一些注意事项。
UPDATE语句 SQL是一种用于管理和操作关系型数据库的语言，其中的UPDATE语句用于修改数据库表中的数据。通过UPDATE语句，我们可以针对特定的记录或多条记录进行修改，以满足数据的更新需求。
基本语法
UPDATE table_name SET column1 = value1, column2 = value2, ... WHERE condition; 参数解析
UPDATE关键字指示要执行数据更新操作table_name是要更新的目标表的名称SET关键字后面是列名和对应的新值，用等号连接。我们可以指定多个列和值，用逗号分隔WHERE关键字用于指定更新操作的条件。只有满足条件的记录才会被更新。如果没有指定WHERE条件，则将更新表中的所有记录 示例 假设我们有一个名为"Customers"的表，包含列"FirstName"、"LastName"和"City"和"Country"，我们可以使用UPDATE语句来修改特定记录或多条记录。
更新单条记录 UPDATE Customers SET City = 'New York' WHERE CustomerID = 1; 这将把CustomerID为1的客户的City修改为"New York"。
更新多条记录 UPDATE Customers SET City = 'Shanghai' WHERE Country = 'China'; 这将把所有Country为"China"的客户的City修改为"Shanghai"。
注意事项 在使用UPDATE语句时，请确保仔细考虑更新的条件，以免意外修改了不应被修改的记录。在修改多条记录时，可以使用WHERE子句来限制更新的范围，确保只更新符合条件的记录。在执行UPDATE操作之前，最好先备份数据或在测试环境中进行验证，以防止意外修改或数据丢失。了解目标表的结构和列名是非常重要的，确保在SET子句中指定正确的列名和对应的值。 总结 通过SQL的UPDATE语句，我们可以修改数据库表中的数据。理解UPDATE语句的基本语法和用法，以及注意更新条件的准确性，将帮助我们有效地进行数据修改和更新操作，确保数据库中的数据保持最新和准确。
最后感谢每一个认真阅读我文章的人，礼尚往来总是要有的，虽然不是什么很值钱的东西，如果你用得到的话可以直接拿走：
这些资料，对于【软件测试】的朋友来说应该是最全面最完整的备战仓库，这个仓库也陪伴上万个测试工程师们走过最艰难的路程，希望也能帮助到你！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cfee880b82b932956c69d7006d2b7d9/" rel="bookmark">
			DLT：dlt-daemon示例解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		dlt-daemon中带有一些示例程序，路径为dlt-daemon/examples/，这里对example1进行解析。
这个示例展示了怎样创建dlt程序，包括注册和取消注册，发送log等。log的值可通过dlt-viewer查看。
dlt对一些函数用宏进行了封装，这样可以减少开发的代码量。
示例1：
//example1.cpp #include &lt;stdio.h&gt; /* for printf() and fprintf() */ #include &lt;stdlib.h&gt; /* for atoi() and exit() */ #include &lt;dlt.h&gt; DLT_DECLARE_CONTEXT(con_exa1); int main() { struct timespec ts; DLT_REGISTER_APP("app1", "First Example"); DLT_REGISTER_CONTEXT(con_exa1, "con1", "First context"); DLT_LOG(con_exa1, DLT_LOG_INFO, DLT_STRING("Hello world! This is first example")); ts.tv_sec = 1; ts.tv_nsec = 1000000; nanosleep(&amp;ts, NULL); DLT_UNREGISTER_CONTEXT(con_exa1); //CMakeLists.txt ####### # SPDX license identifier: MPL-2.0 # # Copyright (C) 2011-2015, BMW AG # # This file is part of GENIVI Project DLT - Diagnostic Log and Trace.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cfee880b82b932956c69d7006d2b7d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5542a9abf9d82bf8fd651def31874d8/" rel="bookmark">
			stm32学习总结：6、Proteus8&#43;STM32CubeMX&#43;MDK仿真蜂鸣器及ADC读取电压（Proteus标签整理原理图）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		stm32学习总结：6、Proteus8+STM32CubeMX+MDK仿真蜂鸣器及ADC读取电压（Proteus标签整理原理图） 文章目录 stm32学习总结：6、Proteus8+STM32CubeMX+MDK仿真蜂鸣器及ADC读取电压（Proteus标签整理原理图）一、前言二、资料收集三、STM32CubeMX配置按键及蜂鸣器连接口1、按键及LED的IO口配置2、蜂鸣器IO口配置3、ADC口配置 四、MDK工程代码五、Proteus增加元器件及布局配置1、新增元器件2、标签优化3、蜂鸣器和滑动变阻器配置 六、仿真测试结果七、最后 一、前言 接下来我们在上一节的基础上增加一个蜂鸣器，当按下开机按钮时蜂鸣器滴响一声，关机时蜂鸣器滴滴滴响三声，并且通过ADC方式读取一下电压值。于此同时，我们发现线路变的越来越复杂了，线再怎么改，原理图都显得比较杂乱，因此我们需要调整一下原理图，通过Proteus的标签功能整理一下原理图，让它显得整洁一些。
二、资料收集 蜂鸣器：https://zh.wikipedia.org/zh-cn/%E8%9C%82%E9%B3%B4%E5%99%A8
https://blog.csdn.net/m0_69455439/article/details/124932955?utm_medium=distribute.pc_relevant.none-task-blog-2defaultbaidujs_baidulandingword~default-0-124932955-blog-92814535.235v39pc_relevant_3m_sort_dl_base3&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3
https://blog.51cto.com/u_15909288/5928372
ADC：https://zh.wikipedia.org/zh-cn/%E9%A1%9E%E6%AF%94%E6%95%B8%E4%BD%8D%E8%BD%89%E6%8F%9B%E5%99%A8
https://blog.csdn.net/qq_50652615/article/details/123644039
https://blog.csdn.net/qq_41873311/article/details/119078754
Proteus标签相关：
https://www.labcenter.com/downloads/
https://labcenter.s3.amazonaws.com/downloads/vsmTutorialSpanish89.pdf
http://www.51hei.com/bbs/dpj-111690-1.html
https://blog.csdn.net/haigear/article/details/121029243
三、STM32CubeMX配置按键及蜂鸣器连接口 1、按键及LED的IO口配置 PA1将会外接开关按钮，配置为输出IO，使用默认配置即可，默认输出低电平，修改用户标签便于后续代码查找；PA4-PA8为LED1-LED5，配置为输出IO，使用默认配置，默认输出低电平，修改用户标签便于后续代码查找； 2、蜂鸣器IO口配置 PA11引脚会接蜂鸣器三极管及电阻，蜂鸣器使用有源蜂鸣器（有源蜂鸣器控制较简单，一般的场景够用了），因此PA11默认拉高，当按下开关后设置对应IO拉低使蜂鸣器响一段时间再拉高就会让蜂鸣器发出’滴‘的一声；
3、ADC口配置 打开ADC1，我这里使用IN8，对应PB0，配置使用默认配置即可：
之后生成代码即可。
四、MDK工程代码 按键、日志等代码不变，不清楚的可以看上一节，这节新增加的内容就是在pwr.c中增加控制蜂鸣器和adc读取电压即可。
#include "pwr.h" #include "log.h" #include "gpio.h" #include "adc.h" void TurnOnLED(int flag) { switch (flag) { case 1: HAL_GPIO_WritePin(GPIOA, LED_1_Pin, GPIO_PIN_RESET); break; case 2: HAL_GPIO_WritePin(GPIOA, LED_2_Pin, GPIO_PIN_RESET); break; case 3: HAL_GPIO_WritePin(GPIOA, LED_3_Pin, GPIO_PIN_RESET); break; case 4: HAL_GPIO_WritePin(GPIOA, LED_4_Pin, GPIO_PIN_RESET); break; case 5: HAL_GPIO_WritePin(GPIOA, LED_5_Pin, GPIO_PIN_RESET); break; } } void TurnOffLED(int flag) { switch (flag) { case 1 : HAL_GPIO_WritePin(GPIOA, LED_1_Pin, GPIO_PIN_SET); break; case 2 : HAL_GPIO_WritePin(GPIOA, LED_2_Pin, GPIO_PIN_SET); break; case 3 : HAL_GPIO_WritePin(GPIOA, LED_3_Pin, GPIO_PIN_SET); break; case 4 : HAL_GPIO_WritePin(GPIOA, LED_4_Pin, GPIO_PIN_SET); break; case 5 : HAL_GPIO_WritePin(GPIOA, LED_5_Pin, GPIO_PIN_SET); break; } } void ADC_TO_VOL() { HAL_ADC_Start(&amp;hadc1); int ADC_Value; if (HAL_ADC_PollForConversion(&amp;hadc1, 10) == HAL_OK) { ADC_Value = HAL_ADC_GetValue(&amp;hadc1); } LOG(LOG_DEBUG, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5542a9abf9d82bf8fd651def31874d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fe3653a3597b09b1cc817bec33f7277/" rel="bookmark">
			如何进行Web渗透测试，渗透步骤和方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是渗透测试 渗透测试是渗透测试工程师对黑客可能用来深入检测目标网络、主机和应用程序安全的攻击技术和漏洞发现技术的完整模拟，并找到系统之中最易受攻击的环节
如何进行web渗透测试 完整的web渗透测试框架当有数千个web应用程序需要测试时，有必要建立一个完整的安全测试框架。该流程的最高目标是确保向客户提供的安全测试服务的质量。
项目立项：
项目立项、时间安排、人力配置、目标制定、厂商接口人确定
系统分析与威胁分析：针对具体的web应用，分析系统架构、使用的组件、内部提供的接口等，以STERID作为威胁模型进行相应的安全威胁分析，输出安全威胁分析表，关注后三名威胁
制定测试用例：根据威胁分析结果制定相应的测试用例。测试用例根据模板输出，可以执行
测试执行和漏洞挖掘：测试用例执行和发散测试，挖掘相应的安全问题或漏洞
问题修复和回归测试：指导客户端应用程序开发人员修复安全问题或漏洞，并进行回归测试，以确保安全问题或漏洞得到修复，并且没有引入新的安全问题
项目总结审查：项目过程总结，输出文档审阅，以及相关文档归档[2]。
web应用程序
渗透测试过程主要分为三个阶段：信息收集→ 漏洞发现→ 漏洞利用率。让我们仔细分析每个阶段的过程：
I.信息收集 在信息收集阶段，我们需要收集尽可能多的有关目标web应用程序的信息，例如脚本语言类型、服务器类型、目录结构、使用的开源软件、数据库类型所有链接页面、使用的框架、，etc
脚本语言类型：常见的脚本语言类型包括：PHP、ASP、ASPX、JSP等
测试方法：
1抓取网站的所有链接并检查后缀
2直接访问不存在的页面，然后进行不同的后缀测试
3检查robots Txt，检查后缀
服务器类型：常见的web服务器包括Apache、Tomcat、IIS、，ngnix等
测试方法：
1检查头部并判断服务器类型
2根据错误信息判断
3根据默认页面判断
目录结构：了解更多目录，并可能发现更多弱点，如目录浏览、代码泄露等
使用Google
robot 1获取整个目录，或者使用Google
robot 2搜索整个目录Txt是否披露使用的开源软件
如果我们知道目标公司使用的开源软件，我们可以找到相关软件的漏洞，直接测试网站
Fingerprint identification（网络之上有很多开源的指纹识别工具）
数据库类型：不同的数据库有不同的测试方法
1。使用应用程序报告错误并检查错误信息
2扫描服务器的数据库端口（在未完成NAT且未过滤防火墙时生效）
所有链接页面：这与以前的目录结构类似，但这不仅是为了获取网站的所有功能页面，但也要获取管理员备份的源代码有时
1使用字典枚举页面
2使用爬虫对整个网站进行爬网，或使用谷歌等搜索引擎获取
3查看机器人Txt是否泄漏
许多网站使用开源框架快速开发网站，因此，收集网站的框架信息也非常重要。指纹识别（网络之上有许多开源的指纹识别工具）
2.漏洞发现 在这个阶段，我们应该在测试时对案例应用正确的药物，而不能盲目扫描。首先，我们应该确定目标应用程序是否使用开源软件、开源框架等，然后进行深入的漏洞扫描
关于开源软件的漏洞发现
开源软件：常见的开源软件包括WordPress、phpbb、dedecms等。
开源框架：常见的开源框架包括struts 2，spring MVC、ThinkPHP等
下方件服务器：常用中间件服务器包括JBoss、Tomcat、Weblogic等
数据库服务：常用数据库服务MSSQL、mysql、Oracle、redis、Sybase、mongodb DB2等
开源软件测试方法
1通过指纹识别软件判断开源软件的版本信息，并根据不同的版本信息，在开放的漏洞数据库之中找到相应版本的漏洞进行测试
2默认后台登录页面可以进行简单的暴力破解，数据库服务端口身份验证和其他条目默认密码尝试和其他操作
3使用开源漏洞发现工具扫描漏洞，例如wpscan
3.漏洞利用 针对不同的漏洞，有不同的漏洞利用方法，需要更多的知识点。通常，该阶段包括两种方式：一种是手动测试，另一种是工具测试
手动测试是一种漏洞检测技术，通过客户端或服务器访问目标服务，手动向目标程序发送特殊数据，包括有效和无效输入，观察目标的状态及其对各种输入的响应，并根据结果发现问题。手动测试不需要额外的辅助工具，但可以由测试人员独立完成，实现起来相对简单。然而，这种方法高度依赖于测试人员，这需要测试人员更好地了解目标。手动测试可用于需要用户交互的web应用程序、浏览器和其他程序。
从靠劳力赚钱转变成靠脑力赚钱，想入门渗透测试的小白肯定想知道如何学好？ 👉[[[CSDN大礼包：《黑客&amp;网络安全入门&amp;进阶学习资源》免费分享]]]（安全链接，放心点击）
从靠劳力赚钱转变成靠脑力赚钱，想入门黑客的小白肯定想知道如何学好？ 👉[[[CSDN大礼包：《黑客&amp;网络安全入门&amp;进阶学习资源》免费分享]]]（安全链接，放心点击）
一、网安学习成长路线图 网安所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。（全套教程文末领取哈）
二、网安视频合集 观看零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fe3653a3597b09b1cc817bec33f7277/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/010c3712a1807349b52e487f107f386a/" rel="bookmark">
			一本书全面搞懂分布式架构中如何使用RocketMQ的原理和实战案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		另外我的新书RocketMQ消息中间件实战派上下册，在京东已经上架啦，目前都是5折，非常的实惠。 https://item.jd.com/14337086.html​编辑https://item.jd.com/14337086.html
“RocketMQ消息中间件实战派上下册”是我既“Spring Cloud Alibaba微服务架构实战派上下册”之后，又一本历时超过1年半的巨无霸技术实战类型的书籍。
为了提高读者阅读本书的体验性，本书总共设计了十个特色，下面我一一的给技术小伙伴阐述一下。 【特色一】由浅到深 本书将RocketMQ的技术原理和最佳实践体系化，按照由浅到深的顺序呈现给读者，使读者可以按照章节顺序按部就班地学习。当学习完全书内容之后，读者不仅能熟悉RocketMQ的核心原理，还能充分理解RocketMQ的“根”。
【特色二】技术新 本书不仅包括RocketMQ4.x（4.9.2版本）的核心原理分析和最佳实践，还包括RocketMQ5.x（5.1. 0版本）的新特性分析和最佳实践。
【特色三】精心设计的主线：零基础入门，循序渐进，直至彻底掌握RocketMQ 本书精心研究了程序类、架构类知识的认知规律，全书共分为6篇：①基础；②进阶；③高级；④高并发、高可用和高性能；⑤应用；⑥新特性，是一条相对科学的主线，让读者快速从“菜鸟”向“RocketMQ分布式架构实战高手”迈进。
【特色四】绘制了大量的图，便于读者理解RocketMQ的原理、架构、流程 一图胜于文，书中在涉及原理、架构、流程的地方配有插图，以便读者更加直观地理解。
【特色五】从架构师和技术专家的视角分析RocketMQ 本书创造性地分析了RocketMQ具备高并发、高可用和高性能的功能及原理，并从架构的视角展开分析，这些也是程序员进阶为技术专家或架构师必备的技能。
以下为从架构师和技术专家的视角分析RocketMQ典型案例，读者阅读完本书之后，也能够达到这样的水准。
【特色六】不仅有原理分析，还有大量的实战案例 本书介绍了大量的实战案例，能让读者“动起来”，在实践中体会功能，而不只是一种概念上的理解。
在讲解每一个知识模块时，我在思考：在这个知识模块中，哪些是读者必须实现的“标准动作”（实例）；哪些“标准动作”是可以先完成的，以求读者能快速有一个感知；哪些“标准动作”具有一定难度， 需要放到后面完成。读者在实践完书中的案例之后，就能更容易理解那些抽象的概念和原理了。
本书的目标之一是，让读者在动手中学习，而不是“看书时好像全明白了，一动手却发现什么都不会”。通过体系化的理论和实战案例去培养读者的主动学习能力，这样本书的价值就会被最大化。 本书相信“知行合一”的理念，而不是“只知，而不行”，避免开发人员出现眼高手低的现象。尤其是在技术面试过程中，面试官更加看重的是既懂原理，又能够主动是实践技术的技术人。
【特色七】深入剖析原理 本书以系统思维的方式，从业务功能视角剖析 RocketMQ 底层的技术原理，使读者具备快速阅读 RocketMQ 框架源码的能力。读者只有具备了这种能力，才能举一反三，实现更复杂的功能，应对更复杂的应用场景。
【特色八】从运维的视角分析 RocketMQ 的最佳实践 【特色九】参与开源 本书向读者展示了如何修改 RocketMQ 源码，并快速验证案例分析。这样，读者可以从中学到参与开源的技能，并为后续自己能够参与开源做准备。
【特色十】双色印刷，读者体验会更好 为了提高读者阅读本书的体验，在有上下两册的前提下（巨无霸，超过800页），出版社不吝啬印刷成本，依然采用双色印刷。
【推荐】本书的最佳学习路径 为了提高读者学习RocketMQ的效率，我这边结合我自身从RocketMQ小白到RocketMQ专家的经历，为读者汇总了一条最佳学习路径。
【寄语】作者寄语 RocketMQ是我深度参与研究的一款开源消息中间件，无论是从源码，还是架构场景，我都提炼了很多最佳实践。
在开源领域，技术小伙伴可以使用的开源消息中间件非常的多，比如Kafka、Pulsar等，我之所以选择研究RocketMQ，除了工作内容和角色需要之外，更多的还是自己感兴趣，因此我建议技术小伙伴一定要先培养自己的兴趣，兴趣才是提升技术硬实力的第1要素。
当然我并不止研究了RocketMQ，还研究了Pulsar和Kafka等（包括开源消息中间件生态中的主流框架），只是本书作为一本关于RocketMQ实战派的书籍，我必须要以RocketMQ为主。
假如技术小伙伴想成为Java领域的架构师或者技术专家，我强烈建议你去研究RocketMQ，它会给你带来很多意想不到的技术和架构方法论的收获，这个也是我写本书的主要目的之一。
建议技术小伙伴按照本书设计的学习路线，逐章的去阅读和实战，这样学习效果会更好。
如果技术小伙伴有技术交流的，可以通过博文视点官方的读者群找到我的联系方式，并与我沟通，我会实时的解答读者的疑问。
本文公众号“架构随笔录”
本人视频号“架构随笔录”
【博文视点】2021年度优秀作者 2021年我和博文视点合作了一本技术类型的书籍“Spring Cloud Alibaba微服务架构实战派上下册”，它是我涉足知识输出领域以来的第一本书，同时它也是我自己积累的技术池中部分技术的产出。
为了写好那本书，我几乎花费了所有的休息时间，并主动的承担了书的售后技术辅导和咨询的职责（几乎是有问必答，坚持了整整两年）。
所谓有付出总会有回报，Alibaba这本书的销量还不错，我也因此获得了博文视点颁发的2021年度优秀作者。
我很清楚，这个是博文视点为了鼓励我继续去用心写书，因此我又花了接近1年半的时间去写了RocketMQ消息中间件实战派上下册这本书。
所谓一分耕耘一份收获，我将我对RocketMQ的理解体系化的输出给喜欢技术的技术人，希望真的对大家有帮助。
【博文视点】2023技术成长领路人 2022年，我开始涉足技术直播和技术讲师领域，并和博文视点合作几次技术直播，直播效果还不错，再加上我孜孜不倦的布道“Spring Cloud Alibaba微服务架构实战派上下册”这本书相关的技术，并且这些技术都是有助于“技术人”快速成长的，因此也获得了博文视点颁发的“2023技术成长领路人”这个技术奖项，这个奖项也是为了鼓励我继续通过技术直播的方式给技术人去布道技术，因此只要我有时间，我就会孜孜不倦的去讲和聊技术。
【四维口袋】2022 KVP最具价值技术专家 2022年，我开始涉足企业培训和相关技术直播，并和“四维口袋”合作了几次技术直播，并荣获了2022 KVP最具价值技术专家的技术奖项。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2da341598a16407108c3d387b8fa16ac/" rel="bookmark">
			Python入门必看的10本书籍（附电子书）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着最近Python的热度上涨，学习的人数也在增多，也因为Python这门语言的简短、易学、语言优美的优点，吸引了很多人来学习它。初学者想要入门，就必须先通过阅读，学习大量的理论知识对Python有一定的了解。这里小编推荐一些初学者python入门必看书籍。
1、《Python基础教程：入门到实践》
《Python基础教程》是经典的Python入门教程书籍，本书层次鲜明，结构严谨，特别是在最后几章中，作者将前面讲述的内容应用到项目中，并以模板的形式介绍了项目的开发过程，手把手教授Python开发，让读者从项目中领略Python的真正魅力。这本书既适合初学者夯实基础，又能帮助Python程序员提升技能，即使是Python方面的技术专家，也能从书里找到耳目一新的内容。
2、《Python基础教程第2版 》
本书是经典教程的全新改版，作者根据Python 3.0版本的种种变化，全面改写了书中内容，如果你没有任何编程基础，那么，你最好先读完第一本的《Python 编程：从入门到实践》开始学习，之后选择这本作为你的第二本 Python 书。值得一提的是，书中最后几章的10各项目更是这本书最大的亮点，不仅实用而且讲解到位，作者Magnus Lie Hetland是挪威科技大学副教授，黑客，喜欢钻研新锐编程语言，写过很多Python方面的书和在线教程，深受读者喜爱。
3、《流畅的Python》
2017年最佳Python进阶书籍，本书由奋战在Python开发一线近20年的Luciano Ramalho执笔，Victor Stinner、Alex Martelli等Python大咖担纲技术审稿人，从语言设计层面剖析编程细节，兼顾Python 3和Python 2，告诉你Python中不亲自动手实践就无法理解的语言陷阱成因和解决之道，教你写出风格地道的Python代码。
4、《Python Cookbook》
本书介绍了Python在各个领域中的一些技巧和方法，从最基本的字符、文件序列、字典和排序，到进阶的面向对象编程、数据库和数据持久化、 XML处理和Web编程，再到高级和抽象的描述符、装饰器、元类、迭代器和生成器，均有涉及。但本书比较厚重，可以放在手边没事就看一下，书中有很多的经验之谈，会在你思路堵塞的时候给以启发。
5、《Python数据分析与挖掘实战》
本书前面的基础部分介绍的很详细也很全面，是一本Python入门的好书，在后面的Demo也很贴近实战，并且介绍了使用Python进行数据挖掘的详细案例，数据和代码都可以下载，有极强的实用性。
6、《集体智慧编程》
本书以机器学习与计算统计为主题背景，专门讲述如何挖掘和分析Web上的数据和资源，如何分析用户体验、市场营销、个人品味等诸多信息，并得出有用的结论，通过复杂的算法来从Web网站获取、收集并分析用户的数据和反馈信息，以便创造新的用户价值和商业价值。
7、《“笨办法”学Python（第3版）》
一本Python入门书籍，适合对计算机了解不多，没有学过编程，但对编程感兴趣的读者学习使用。此书结构非常简单，其中覆盖了输入/输出、变量和函数三个主题，以及一些比较高级的话题。每一章的格式基本相同，以代码习题开始，按照说明编写代码，运行并检查结果，然后再做附加练习。这本书以习题的方式引导读者一步一步学习编程，从简单的打印一直讲授到完整项目的实现，让初学者从基础的编程技术入手，最终体验到软件开发的基本过程。
8、《像计算机科学家一样思考Python》
本书更多的是想培养读者以计算机科学家的思维方式来理解Python语言编程。贯穿全书的主体是如何思考、设计、开发的方法。从基本的编程概念开始，一步步引导读者了解Python语言，再逐渐掌握函数、递归、数据结构和面向对象设计等高阶概念。每个章节后面都有练习，可以帮助读者加深对刚学的编程概念的理解。而且，本书的示例代码均在GitHub仓库中维护，读者很容易下载和修改。
9、《爱上Python 一日精通Python编程》
本书将复杂的编程概念分解成简单的步骤，作者通过多年的教学经验精心挑选出了有特点的例子，手把手地实例教学。这本书选择Python 3.4.2作为学习平台，把看似冗长的编程学习精简，让书“读得很薄”，学习更加轻松。以“一学就会”的理念讲授，Python是什么？需要哪些软件？相对应的模块怎么使用？让那些没有编程经验的初学者也能够轻松学习Python编程。
10、《More Python Programming for the Absolute Beginner》
通过一系列小游戏的制作来学习 Python，当你读完这本书的时候，你基本精通Python，并能够将你学到的基本编程原则应用到你想要学习的下一种编程语言中。每个章节结束的项目都是基于游戏的，使得编程变得有趣并且易于访问。
这些书都十分适合初学者入门python并逐渐深入学习的，看完这些书, 你的知识储备绝对没有问题了。当然同学们学习python只是看书是不够的，更重要的是从实际应用场景出发。
上述书籍的电子版我已经整理打包好了，需要的话可以微信扫描二维码免费领取，还有更多python学习资料等你来哦~
零基础Python学习资源介绍 一、Python所有方向的学习路线 Python所有方向路线就是把Python常用的技术点做整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。
二、Python学习软件 工欲善其事，必先利其器。学习Python常用的开发软件都在这里了！
三、Python入门学习视频 还有很多适合0基础入门的学习视频，有了这些视频，轻轻松松上手Python~
四、Python练习题 每节视频课后，都有对应的练习题哦，可以检验学习成果哈哈！
五、Python实战案例 光学理论是没用的，要学会跟着一起敲代码，动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。这份资料也包含在内的哈~
六、Python面试资料 我们学会了Python之后，有了技能就可以出去找工作啦！下面这些面试题是都来自阿里、腾讯、字节等一线互联网大厂，并且有阿里大佬给出了权威的解答，刷完这一套面试资料相信大家都能找到满意的工作。
七、资料领取 上述完整版Python全套学习资料已经上传CSDN官方，需要的小伙伴可自行微信扫描下方CSDN官方认证二维码输入“领取资料”免费领取！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56cf4ea9e7b55c8a255d2bd33e1ac0fb/" rel="bookmark">
			python如何实现批量下载网易云音乐？来看看完整项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有很多学习python的小伙伴都一开始被python的爬虫所吸引，那么到底python的爬虫到底是不是那么神乎，小编给大家分享一个实战案例让大家来更具体的了解一下python爬虫。
小编给大家分享一个完整的python实现下载网易云免费的音乐案例。项目代码如下：
# -*- coding:utf-8 -*- import requests, hashlib, sys, click, re, base64, binascii, json, os from Crypto.Cipher import AES from http import cookiejar """ Website:http://cuijiahua.com Author:Jack Cui Refer:https://github.com/darknessomi/musicbox """ class Encrypyed(): """ 解密算法 """ def __init__(self): self.modulus = '00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e82047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7' self.nonce = '0CoJUm6Qyw8W8jud' self.pub_key = '010001' # 登录加密算法, 基于https://github.com/stkevintan/nw_musicbox脚本实现 def encrypted_request(self, text): text = json.dumps(text) sec_key = self.create_secret_key(16) enc_text = self.aes_encrypt(self.aes_encrypt(text, self.nonce), sec_key.decode('utf-8')) enc_sec_key = self.rsa_encrpt(sec_key, self.pub_key, self.modulus) data = {'params': enc_text, 'encSecKey': enc_sec_key} return data def aes_encrypt(self, text, secKey): pad = 16 - len(text) % 16 text = text + chr(pad) * pad encryptor = AES.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56cf4ea9e7b55c8a255d2bd33e1ac0fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1d5c8c11d1ae600117e57c382570e38/" rel="bookmark">
			MyBatisPlus学习二：常用注解、条件构造器、自定义sql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常用注解 基本约定 MybatisPlus通过扫描实体类，并基于反射获取实体类信息作为数据库表信息。可以理解为在继承BaseMapper 要指定对应的泛型
public interface UserMapper extends BaseMapper&lt;User&gt; 实体类中，类名驼峰转下划线作为表名、名为id的字段作为主键、变量名驼峰转为下划线作为表的字段名
常见注解 @TableName ：用于指定表名@TableId：用于指定表中的主键字段信息@TableField：用于指定表中的普通字段信息（变量名与数据库字段名不一致；变量名以is开头，并且是布尔类型；变量名与数据库关键字冲突的） 当实体类中类名和字段名不一致时可以使用上面的注解进行指定。使用时需要使用双引号，单引号好像会有问题
具体用法见官方文档：注解
条件构造器 mybatis-plus 支持各种复杂的where 条件，可以满足日常开发的所有需求，这里需要使用条件构造器。
Wrapper 更新李四的年龄为20
@Service public class UserService { @Autowired private UserMapper userMapper; // 查询用户 public List&lt;User&gt; selectUser() { UpdateWrapper&lt;User&gt; updateWrapper = new UpdateWrapper&lt;&gt;(); // 标签好像要用双引号 updateWrapper.set("age", 20); // 条件 updateWrapper.eq("name", "李四"); // 更新 int count = userMapper.update(null, updateWrapper); // 查询更新后的数据 QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.eq("name", "李四"); List&lt;User&gt; userList = userMapper.selectList(queryWrapper); return userList; } } 查询年龄大于20的男生的名称、年龄
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1d5c8c11d1ae600117e57c382570e38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c68f21ddc8b8b95c2647de119ec0ec1f/" rel="bookmark">
			macOS(m1)安装centOS7
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装 VMware ​ VMware个人免费,可以直接在官网下载
官网地址:https://www.vmware.com/cn.html
2.安装 1.下载镜像 永久链接 提取码：1yg4
!!!这里是一个大坑,从官网下载的镜像,没办法使用,我下载了五六个arm镜像,全是卡在安装界面,一直在下边的页面反复横跳,然后在网上搜,发现能运行的似乎都是那一个版本的
阿里云盘 : https://www.aliyundrive.com/s/G2AN7NWP11T
提取码io47 ​ 1. 创建新的虚拟机
创建自定义虚拟机 选择系统 选择虚拟磁盘(根据自身情况新建或使用现有) 修改存放位置 进入到虚拟机后 ​ 然后开机,选择第一个选项
等待一会进入语言选择页面(跳过),进入安装页面
然后开始安装,安装后重启即可
yum源配置 (这个也挺坑的,M1 linux切换阿里好像只能用这一)
先安装 wget
yum install wget -y 备份旧的 yum源
mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo_bak
获取阿里yum源配置文件
wget http://mirrors.aliyun.com/repo/Centos-altarch-7.repo -O /etc/yum.repos.d/CentOS-Base.repo
更新缓存
yum makecache
可以用 Termius替代 finalshell
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d89b60ea7c4aba5b9d95af9a235d4ae2/" rel="bookmark">
			2024最新Java基础面试题大全（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、String可以被继承？ 不能被继承，因为String类有final修饰符，而final修饰的类是不能被继承的。
public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence { // 省略...　} 2、常见集合类 Java集合框架主要包括两种类型的容器，一种是集合（Collection），另一种是图（Map）。Collection接口又有3种子类型，List、Set和Queue，再下面是一些抽象类，最后是具体实现类，常用的有ArrayList、LinkedList、HashSet、LinkedHashSet、HashMap、LinkedHashMap等等。Map常用的有HashMap,LinkedHashMap等
1.List List接口扩展自Collection，它可以定义一个允许重复的有序集合，从List接口中的方法来看，List接口主要是增加了面向位置的操作，允许在指定位置上操作元素，同时增加了一个能够双向遍历线性表的新列表迭代器ListIterator。AbstractList类提供了List接口的部分实现，AbstractSequentialList扩展自AbstractList，主要是提供对链表的支持。下面介绍List接口的两个重要的具体实现类，也是我们可能最常用的类，ArrayList和LinkedList。
1.1ArrayList 通过阅读ArrayList的源码，我们可以很清楚地看到里面的逻辑，它是用数组存储元素的，这个数组可以动态创建，如果元素个数超过了数组的容量，那么就创建一个更大的新数组，并将当前数组中的所有元素都复制到新数组中。假设第一次是集合没有任何元素，下面以插入一个元素为例看看源码的实现。
1、找到add()实现方法。 public boolean add(E e) { ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; } 2、此方法主要是确定将要创建的数组大小。 private void ensureCapacityInternal(int minCapacity) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); } ensureExplicitCapacity(minCapacity); } private void ensureExplicitCapacity(int minCapacity) { modCount++; if (minCapacity - elementData.length &gt; 0) grow(minCapacity); } 3、最后是创建数组，可以明显的看到先是确定了添加元素后的大小之后将元素复制到新数组中。 private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d89b60ea7c4aba5b9d95af9a235d4ae2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7aa8379a0830235c72652a46eec56113/" rel="bookmark">
			干货！10个程序员证书，含金量超高
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 某乎上有一个话题：程序员考证的意义是什么？
程序员考证的意义
很多人说，程序员大概是除医疗、建筑以外所考证书最多的一个行业。考证，不仅是对个人实力的一种展示，同样也是通过考证来检验和复习自己的知识与技术的手段。
当然，考验一个程序员的能力从来不由一两本证书决定，但作为一个技术至上的行业，证书有总比没有好，有些证书可以为简历更加分，或为落户、申请技能补贴增加助力，有些岗位则需要一些证书加持，而如果要从事国企体制内单位，证书必然少不了。
今天，知了堂知了姐整理出10个程序员高含金量证书，供大家参考。
1、软考 计算机技术与软件专业技术资格证书
软考全称为计算机技术与软件专业技术资格考试，是程序员最值得考的证书，由工业和信息化部承办，专业性和难度很高，签章单位除了工信部，还有人社部，后期可帮助评职称，所以有志于往事业单位和国企发展的同学建议考它！
报名时间： 每年的3月、8月
⚡ 考试时间： 每年的5月、11月
考试费用： 纸笔科目按每人每科63元收取，机考科目按每人每科73元收取。
*报考任何级别不受学历、年龄、资历条件的限制，只要达到相应的专业技术水平就可以报考相应的级别。
2、NISP NISP即国家信息安全水平考试，由中国信息安全测评中心实施培养国家网络空间安全人才的项目，**属于从事网络安全专业必考的证书。**目前只有考取NISP一级证书才有机会考取NISP二级。
NISP和CISP无缝对接，持有NISP二级证书可以免培训、免考试申领换取CISP证书，填补了在校大学生无法考取CISP证书的空白，因此被称为“校园版CISP”。
证书Tips
1️⃣证书分为一级和二级；
2️⃣年满16周岁均可报考；
3️⃣由中国信息安全测评中心颁发；
4️⃣适用于从事信息安全行业的人员。
3、CISP CISP即“注册信息安全专业人员”，由中国信息安全测评中心根据中央编办授权，系国家对信息安全人员资质的高度认可。
CISP资质认证属于国家级行业准入证书，是目前国内权威性很高的信息系统安全认证，也是从事信息安全工作人员必备的“专业身份证”。
适用人群
IT技术人员或安全顾问、信息安全类讲师或培训人员、信息安全服务提供商、信息安全事件调查人员、其他从事与信息安全相关工作的人员、IT审计人员、信息安全管理人员
报考条件
硕士研究生以上，具有1年工作经历；本科毕业，具有2年工作经历；大专毕业，具有4年工作经历；专业工作经历，至少具备1年从事信息安全有关的工作经历；获得官方授权培训机构出具的CISP培训合格证明
证书期限
CISP证书有效期为3年
4、CISP-PTE CISP-PTE即注册信息安全渗透测试工程师，发证机构是中国信息安全测评中心。
证书专注于培养考核高级应用安全人才，是业界首个理论与实践相结合的技能水平注册考试，国内唯一认可的渗透测试认证，专业性强,技能要求高，想要在信安行业发展，这本证书建议考一考。
适用人群
(1) 准毕业生or在校生
(2) 信息安全从业人员
(3) 网络安全兴趣爱好者
5、PMP PMP，即项目管理专业人士资格认证，由美国项目管理协会（Project Management Institute，简称PMI）发起，在全球200多个国家和地区都得到高度认可，是项目管理业界认可度最高的项目管理人士资格认证，含金量很高，很适合程序员后期转型管理报考的证书。
⚡ 考试时间： 每年3、6、9、12月
考试内容： 项目管理5过程（启动、规划、执行、监控、收尾）
6、华为认证 华为认证是华为基于“平台+生态”战略，围绕“云-管-端”协同的新ICT技术架构，打造的业界覆盖ICT领域最广的认证体系，匹配的岗位以网络工程师、系统集成工程师或系统运维工程师为主。
华为认证主要分为三档
1️⃣HCIA： 华为认证ICT工程师
2️⃣HCIP： 华为认证ICT高级工程师
3️⃣HCIE： 华为认证ICT专家
7、思科认证 思科认证的含金量也非常高，依旧是针对网络方向，不过它的主要就业市场以国外为主，建议大家可以根据自己的发展方向选择是否报考。
思科认证有CCNA、CCDA、CCNP、CCDP、CCSP、CCIP、CCVP、CCIE等多种不同级别、不同内容、不同方向的各种认证，比较常用的、社会需求量比较大的是CCNA、CCNP、路由交换类CCIE三种认证。
认证等级
工程师、资深工程师和专家
8、微软认证 微软认证是微软公司设立的推广微软技术，培养系统网络管理和应用开发人才的完整技术金字塔证书体系，在全世界90多个国家认可有效，并且可以作为薪资职位变迁的有效证明。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7aa8379a0830235c72652a46eec56113/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/758dc306c634093da937238c0a90549e/" rel="bookmark">
			推荐几个免费的HTTP接口Mock网站和工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在前后端分离开发架构下，经常遇到调用后端数据API接口进行测试、集成、联调等需求，比如：
（1）前端开发人员很快开发完成了UI界面，但后端开发人员的API接口还没有完成，不能进行前后端数据接口对接和联调，很容易影响开发进度。前端开发人员用的比较多的开源组件有mock.js，但该组件缺乏界面管理，因为这样做很容易造成代码耦合，甚至一不小心就会把Mock代码打包到生产环境。
（2）在一些数据大屏可视化、报表开发、调用远程服务等业务场景中，常常需要远程http接口数据的支撑，往往把JSON数据写死到代码里，或者通过spring mvc开发数据接口，这些工作都比较耗时，且日后不好更改和维护。当然，也可以使用开源软件json-server用于模拟服务端接口数据，根据json数据建立一个完整的web服务。JSON-Server 是一个 Node 模块，运行 Express 服务器，你可以指定一个 json 文件作为 api 的数据源。
以下介绍两种快速调用数据mock接口的方式，一种是使用在线免费的http接口，另一种是基于数据mock工具动态生成接口。
一、 免费在线HTTP服务接口，模拟假数据 JSONPlaceholder 是一个提供免费的在线 REST API 的网站，我们在开发时可以使用它提供的 url 地址测试下网络请求以及请求参数。当我们程序需要获取一些假数据、假图片或者mock数据接口时可以使用它。其返回的数据为 JSON 格式，且同时支持 HTTP 和 HTTPS 这两种请求类型，支持跨域，如 CORS 和 JSONP，支持GET、POST、PUT、PATCH、DELETE 几个请求方法。网站地址：JSONPlaceholder - Free Fake REST API
以下示例均通过了Postman测试，模拟了GET请求多条数据接口、单条数据接口、大量数据接口、图片资源接口、restful风格参数接口、url带?参数接口、返回复杂JSON数据格式接口等，方便前端开发人员开始测试或者mock数据时使用。
1、获取100篇文章数据（GET无参数请求） 返回100条数据，每条内容都有帖子 ID、发贴人 ID、标题、以及简介。
http://jsonplaceholder.typicode.com/posts
2、根据文章ID获取文章数据（GET带restful风格参数） 根据文章 ID 获取指定文章的数据，传递的参数为restful风格参数。
返回：文章 ID、发贴人 ID、标题、以及内容。
http://jsonplaceholder.typicode.com/posts/3
本例传入的 ID 为3，返回 ID 为3的数据。
3、获取某个用户所有的帖子（GET带?风格参数） 根据用户 ID 获取指定用户的数据，传递的产生为url中带问号的风格
https://jsonplaceholder.typicode.com/posts?userId=2
4、添加文章（POST请求，模拟提交JSON数据） 使用 POST 发送一篇文章，发送成功会返回一个文章 ID 回来。
http://jsonplaceholder.typicode.com/posts
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/758dc306c634093da937238c0a90549e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6a3c6654c74713e32aed98079b44955/" rel="bookmark">
			2024最新Java面试题及答案！（ 2024年 1 月最新版，持续更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024了发现网上很多Java面试题都没有答案，所以花了很长时间搜集整理出来了这套Java面试题大全~
这套互联网 Java 工程师面试题包括了：Java面试、Spring、JVM、MyBatis、Redis、MySQL、并发编程、微服务、Linux、Springboot、SpringCloud、MQ、Kafka 面试专题面试专题
一、Java 基础
1.Java 中的线程池是如何实现的 创建一个阻塞队列来容纳任务，在第一次执行任务时创建足够多的线程，并处理任务，之后每个工作线程自动从任务队列中获取线程，直到任务队列中任务为0为止，此时线程处于等待状态，一旦有工作任务加入任务队列中，即刻唤醒工作线程进行处理，实现线程的可复用性。
线程池一般包括四个基本组成部分：
（1）线程池管理器
用于创建线程池，销毁线程池，添加新任务。
（2）工作线程
线程池中线程，可循环执行任务，在没有任务时处于等待状态。
（3）任务队列
用于存放没有处理的任务，一种缓存机制。
（4）任务接口
每个任务必须实现的接口，供工作线程调度任务的执行，主要规定了任务的开始和收尾工作，和任务的状态。
2. String str="i"与 String str=new String("i")一样吗？
不一样，因为内存的分配方式不一样。String str="i"的方式，java 虚拟机会将其分配到常量池中；而 String str=new String("i") 则会被分到堆内存中。
3. 如何将字符串反转？
使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。
篇幅限制下面就只能给大家展示小册部分内容了。包括了：Java面试、Spring、JVM、MyBatis、Redis、MySQL、并发编程、微服务、Linux、Springboot、SpringCloud、MQ、Kafka 面试专题
需要全套资料的在【文章底部点击名片】即可免费获取 备注：“CSDN”
Java面试题目录
MyBatis面试篇
Zookeeper面试篇
Java基础篇（45道面试题）
字符串&amp;&amp;集合篇（74道）
并发编程篇（79道）
JVM篇（56道）
数据结构与算法（56道）
MySQL篇（59道）
另外还附带了 52条SQL优化策略 以及一千行SQL命令
Redis篇（48道）
Mongo篇（83道）
Spring篇（58道）
MyBatis篇（47道）
SpringBoot篇（43道）
常用注解篇
篇幅限制下面就只能给大家展示小册部分内容了。包括了：Java面试、Spring、JVM、MyBatis、Redis、MySQL、并发编程、微服务、Linux、Springboot、SpringCloud、MQ、Kafka 面试专题
需要全套资料的在【文章底部点击名片】即可免费获取 备注：“CSDN”
这里就不一一展示了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49958f7917b2966e824249679eb9f85a/" rel="bookmark">
			学习Python的10大刷题网站，练完这些你就遥遥领先！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. LeetCode LeetCode 是一个刷算法题的网站，里面有多种语言可选 ，题目分为简单、中等和困难三个级别，可以根据自己的水平进行选择，想进大厂的话，这可能是必不可少的一关。
网址：https://leetcode-cn.com/problemset/all
2. PythonTip PythonTip 里面的练习题主要偏向 Python 基础和一些基础的算法，比较适合作为新手的入门练习题。
网址：http://www.pythontip.com/coding/code_oj
3. Coding Games 一边玩游戏，一边挑战编程难题。Coding games 支持包括 Python、Java、C 在内的 20 多种编程语言。用户界面功能强大，可以定制。例如，你可以选择你的代码编辑器的风格：Emacs、Vim、Classic。
如果你想提升编程技能，玩 Coding games 是一种有趣的途径。
网址：http://www.codingame.com
4. CodeCombat CodeCombat 是一款网页编程游戏。这款编程游戏借鉴了游戏的很多设计元素，游戏剧情十分丰富。
CodeCombat 能够学习 Python 等多种语言，这些语言能够运用到游戏设计、网页应用、App 的开发上。
codecombat 教学版网址：https://koudashijie.com
5. Checkio Check iO 是一个基于浏览器的游戏，你需要使用 Python 或 JavaScript 来解决问题才能将游戏进行下去（需要登录）。
网址：http://checkio.org
6. Cyber Dojo Cyber-dojo 是一个提供给程序员们练习写程序的地方。支持 Python、JavaScript、Java、PHP、Ruby 等语言。
网址：http://www.cyber-dojo.org
源代码：https://github.com/JonJagger/cyber-dojo
7. Code Monkey CodeMonkey 是一款非常富有童趣的网页编程游戏，玩家通过编程向怪兽小猴子传达指令，帮助小猴子吃到香蕉就可以过关了。
CodeMonkey 以游戏闯关的方式进行教学，总共有 300 多个关卡，涉及到编程的各种概念。
网址：http://www.playcodemonkey.com
8. Codewars 在战斗中进行学习，和其他人一起在真实的编程挑战中提升技巧，支持 Python、JavaScript、C#、Java、Python 等语言（支持的语言见下图）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49958f7917b2966e824249679eb9f85a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f76992ffca206732f1ba84e80f60e34/" rel="bookmark">
			#React-Native#
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#React-Natice 开发环境搭建# Node &gt;=16 npm 设置淘宝镜像
JDK (Java SE Development Kit) 17 Android Studio
VS code (开发工具)
注意
强烈建议始终选择 Node 当前的 LTS （长期维护）版本，一般是偶数版本，不要选择偏实验性质的奇数版本。
不要使用 cnpm！cnpm 安装的模块路径比较奇怪，packager 不能正常识别！
查看jdk版本 javac -version 低于 0.73 版本的 React Native 需要 JDK 11 版本，而低于 0.67 的需要 JDK 8 版本
1:卸载react-native-cli
npm uninstall -g react-native-cli @react-native-community/cli
2:安装react-native-cli
npm install -g react-native-cli 全局安装
3:创建项目
npx react-native init AwesomeProject
4：运行项目
cd AwesomeProject
yarn android
# 或者
yarn react-native run-android
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f76992ffca206732f1ba84e80f60e34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f9d5f64dbcf6c001bfde57401903b83/" rel="bookmark">
			python爬虫详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python爬虫详解 1、基本概念 1.1、什么是爬虫 网络爬虫，是一种按照一定规则，自动抓取互联网信息的程序或者脚本。另外一些不常使用的名字还有蚂蚁、自动索引、模拟程序或者蠕虫。随着网络的迅速发展，万维网成为大量信息的载体，如何有效地提取并利用这些信息成为一个巨大的挑战。例如：传统的通用搜索引擎AltaVista，Yahoo!和Google等，作为一个辅助人们检索信息的工具也存在着一定的局限性，通用搜索引擎的目标是尽可能大的网络覆盖率，返回的结果包含大量用户不关心的网页，为了解决上述问题，定向抓取相关网页资源的爬虫应运而生。
由于互联网数据的多样性和资源的有限性，根据用户需求定向抓取网页并分析，已成为主流的爬取策略。只要你能通过浏览器访问的数据都可以通过爬虫获取，爬虫的本质是模拟浏览器打开网页，获取网页中我们想要的那部分数据。
1.2、**Python为什么适合爬虫** --------------------- 因为python的脚本特性，python易于配置，对字符的处理也非常灵活，加上python有丰富的网络抓取模块，所以两者经常联系在一起。
相比与其他静态编程语言，如java，c#，C++，python抓取网页文档的接口更简洁;相比其他动态脚本语言，如perl，shell，python的urllib2包提供了较为完整的访问网页文档的API。此外，抓取网页有时候需要模拟浏览器的行为，很多网站对于生硬的爬虫抓取都是封杀的。这是我们需要模拟user agent的行为构造合适的请求，譬如模拟用户登陆、模拟session/cookie的存储和设置。在python里都有非常优秀的第三方包帮你搞定，如Requests，mechanize。
抓取的网页通常需要处理，比如过滤html标签，提取文本等。python的beautifulsoap提供了简洁的文档处理功能，能用极短的代码完成大部分文档的处理。
1.3、Python爬虫组成部分 Python爬虫架构主要由五个部分组成，分别是调度器、URL管理器、网页下载器、网页解析器、应用程序（爬取的有价值数据）。
调度器：相当于一台电脑的CPU，主要负责调度URL管理器、下载器、解析器之间的协调工作。
URL管理器：包括待爬取的URL地址和已爬取的URL地址，防止重复抓取URL和循环抓取URL，实现URL管理器主要用三种方式，通过内存、数据库、缓存数据库来实现。
网页下载器通过传入一个URL地址来下载网页，将网页转换成一个字符串，网页下载器有urllib（Python官方内置标准库）包括需要登录、代理、和cookie，requests(第三方包)
网页解析器：将一个网页字符串进行解析，可以按照我们的要求来提取出我们有用的信息，也可以根据DOM树的解析方式来解析。网页解析器有正则表达式（直观，将网页转成字符串通过模糊匹配的方式来提取有价值的信息，当文档比较复杂的时候，该方法提取数据的时候就会非常的困难）、html.parser（Python自带的）、beautifulsoup（第三方插件，可以使用Python自带的html.parser进行解析，也可以使用lxml进行解析，相对于其他几种来说要强大一些）、lxml（第三方插件，可以解析 xml 和 HTML），html.parser 和 beautifulsoup 以及 lxml 都是以 DOM 树的方式进行解析的。
应用程序：就是从网页中提取的有用数据组成的一个应用。
1.4、URI和URL的概念 在了解爬虫前，我们还需要了解一下什么是URL？
1.4.1、网页、网站、网络服务器、搜素引擎 网页：一份网页文档是交给浏览器显示的简单文档。这种文档是由超文本标记语言HTML来编写的，网页文档可以插入各种各样不同类型的资源：
样式信息 — 控制页面的观感
脚本— 为页面添加交互性
多媒体— 图像，音频，和视频
网络上所有可用的网页都可以通过一个独一无二的地址访问到。要访问一个页面，只需在你的浏览器地址栏中键入页面的地址，即URL。
网站：网站是共享唯一域名的相互链接的网页的集合。给定网站的每个网页都提供了明确的链接—一般都是可点击文本的形式—允许用户从一个网页跳转到另一个网页。要访问网站，请在浏览器地址栏中输入域名，浏览器将显示网站的主要网页或主页。
网络服务器：一个网络服务器是一台托管一个或多个网站的计算机。 "托管"意思是所有的网页和它们的支持文件在那台计算机上都可用。网络服务器会根据每位用户的请求，将任意网页从托管的网站中发送到任意用户的浏览器中。别把___网站和网络服务器弄混了。_例如，当你听到某人说：“我的网站没有响应”，这实际上指的是网络服务器没响应，并因此导致网站不可用。
搜索引擎：搜索引擎是一个特定类型的网站，用以帮助用户在其他网站中寻找网页。例如：有Google, Bing, Yandex, DuckDuckGo等等。浏览器是一个接收并显示网页的软件，搜索引擎则是一个帮助用户从其他网站中寻找网页的网站。
1.4.2、什么是URL 早在1989年，网络发明人蒂姆·伯纳斯 - 李（Tim Berners-Lee）就提出了网站的三大支柱：
1）URL ,跟踪Web文档的地址系统
2）HTTP，一个传输协议，以便在给定URL时查找文档
3）HTML, 允许嵌入超链接的文档格式
Web的最初目的是提供一种简单的方式来访问，阅读和浏览文本文档。从那时起，网络已经发展到提供图像，视频和二进制数据的访问，但是这些改进几乎没有改变三大支柱。
在Web之前，很难访问文档并从一个文档跳转到另一个文档。WWW（World Wide Web，万维网）简称为3W，使用统一资源定位符（URL）来标志WWW上的各种文档。
完整的工作流程如下∶
1）Web用户使用浏览器（指定URL）与Web服务器建立连接，并发送浏览请求。 2）Web服务器把URL转换为文件路径，并返回信息给 Web浏览器。 3）通信完成，关闭连接。 HTTP:超文本传送协议（HTTP）是在客户程序（如浏览器）与WWW服务器程序之间进行交互所使用的协议。HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接，它使用TCP连接进行可靠传输，服务器默认监听在80端口。 **URL:代表_统一资源定位器_。URL 只不过是 Web 上给定的唯一资源的地址。理论上，每个有效的 URL 都指向一个唯一的资源。此类资源可以是 HTML 页面、CSS 文档、图像等**。 **URL的组成：** 1）协议部分(http:):它表示浏览器必须使用的协议来请求资源（协议是在计算机网络中交换或传输数据的一套方法），通常对于网站，协议是 HTTPS 或 HTTP（其不安全版本）。这里使用的是HTTP协议,在"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f9d5f64dbcf6c001bfde57401903b83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51cc71ec5342163c51fb4179a63fcc3d/" rel="bookmark">
			分享两个python爬虫练习网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写爬虫程序，很多人会担心写爬虫触犯一些法律什么的，事实上不侵犯损害他人利益以及不影响网站正常工作，只是娱乐正常使用是没问题的，尤其是批量化大规模操作的时候，所以一开始写爬虫代码时，了解一些还是有必要的。
比如我自己在课程中第一次进行批量操作的时候就会告知可能的影响。
爬虫程序其实就是用代码来模拟打开网页的一个过程。如果你表现的和一个正常访问网页的人一样，那是没什么问题的，比如限制一下爬取的速度。
学习爬虫时，网站很重要，很多人找不到合适的网站练习，因为很多案例的网站动不动就会消失，或者改掉数据结构等等，下面分享两个国内可访问的，专门练习的网站：
第一个：http://www.glidedsky.com/
首先需要注册登录，进入后依次闯关，到第三关就要小心了，你的IP可能会被屏蔽访问不了了。
第二个：https://cuiqingcai.com/9522.html
上面的链接是各个爬虫网站的入口，《python3 网络爬虫开发实战》这本书的作者发布的一站式爬虫练习平台，里面有各种可以练习的场景。
感兴趣的可以去看看。
最后 在学习python中有任何困难不懂的可以微信扫描下方CSDN官方认证二维码加入python交流学习
多多交流问题，互帮互助，这里有不错的学习教程和开发工具。
（python兼职资源+python全套学习资料）
一、Python所有方向的学习路线 Python所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。
二、Python必备开发工具 四、Python视频合集 观看零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
五、实战案例 光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
六、Python练习题 检查学习结果。
七、面试资料 我们学习Python必然是为了找到高薪的工作，下面这些面试题是来自阿里、腾讯、字节等一线互联网大厂最新的面试资料，并且有阿里大佬给出了权威的解答，刷完这一套面试资料相信大家都能找到满意的工作。
最后，千万别辜负自己当时开始的一腔热血，一起变强大变优秀。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba3c24fdb002d08c2e3bbb6c621ad50f/" rel="bookmark">
			万物皆可秒——淘宝秒杀Python脚本，扫货618，备战双11！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总是抢不到想要的宝贝？试试Python脚本
对于淘宝、天猫，相信大家已经无比的熟悉，在每年的双十一、双十二，或是其他购物节，平台都会上架性价比超高的一些商品，商品的性价比越高，自然吸引购买者的眼光也越多。不知道你是否有这样的经历，半夜卡着点等待心仪商品放出，狂点手机，却一秒库存不足。这是因为，背后有许许多多的抢购机器人，在与你竞争，在程序面前，眼睛看到+手工点击的速度，无疑是慢了。
本次的文章，技术宅将分享一个淘宝/天猫的秒杀脚本，这个脚本用Python编写，使用到了Python的三方库selenium，并且通过selenium + chromedriver，用程序控制chrome浏览器，完成抢购的一系列操作。有了这个脚本，大家至少可以与其他的机器人站在同一起跑线上，公平的抢购喜欢的宝贝。
另外怕大家不会使用，直接给大家准备了写好的，直接下载打开即可使用！
源码放在百度云盘上了需要可以微信扫描下方CSDN官方认证二维码免费领取
selenium 安装与 chromedriver安装 我们前文提到，Python脚本中使用了selenium库，而selenium又通过chromedriver来控制浏览器的鼠标点击等操作。所以，我们的第一步，是正确的安装与配置selenium以及chromedriver。
selenium的安装很简单，与其他Python三方库一样，我们直接用pip安装。
pip install selenium
chromedriver的安装，首先，chromedriver的版本很关键，我们需要选择的chromedriver版本，一定要与Chrome的版本一致。因此， 我们需要查看Chrome版本，在浏览器中输入chrome://version/
这个示例中Chrome的版本是 72.0.3626， 我们再到以下两个网站的其中之一，去下载对应版本的chromedriver。
下载完成后，解压压缩包，找到chromedriver.exe复制到chrome的安装目录（其实也可以随便放一个文件夹）。复制chromedriver.exe文件的路径并加入到电脑的环境变量中去。具体的：
进入环境变量编辑界面，添加到用户变量即可，双击PATH，将文件位置（例如我们的是 C:\Program Files (x86)\Google\Chrome\Application\）添加到后面。
完成安装后，我们到cmd界面， 输入chromedriver，如果下方给出了chromedriver的版本号，说明已经安装成功。
我们再通过Python库selenium，来调用chromedriver，以此来简单测试chromedriver的功能。如果我们未配置环境变量，可用如下代码进行测试
from selenium import webdriver import time def main(): chrome_driver = 'C:\Program Files (x86)\Google\Chrome\Application\chromedriver.exe' #chromedriver的文件位置 b = webdriver.Chrome(executable_path = chrome_driver) b.get('https://www.google.com') time.sleep(5) b.quit() if __name__ == '__main__': main() 而如果我们已经配置好了环境变量，可以通过另一端代码来进行测试 from selenium import webdriver import time def main(): b = webdriver.Chrome() b.get('https://www.baidu.com') time.sleep(5) b.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba3c24fdb002d08c2e3bbb6c621ad50f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13013b1341d3c8b082815208499e1b42/" rel="bookmark">
			秒杀脚本丨Python淘宝或京东等秒杀抢购脚本实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 我们的目标是秒杀淘宝或京东等的订单，这里面有几个关键点，首先需要登录淘宝或京东，其次你需要准备好订单，最后要在指定时间快速提交订单。
这里就要用到一个爬虫利器Selenium，Selenium是一个用于Web应用程序测试的工具，Selenium可以直接运行在浏览器中，通过后台控制操作浏览器，完成购买操作，利用它我们可以驱动浏览器执行特定的动作，抢购脚本就是通过Selenium来完成自动登录和自动购买的操作的。
环境 操作系统：Win10Python版本：3.7.4Chrome浏览器版本：100.0.4896.60ChromeDriver版本：100.0.4896.60ChromeDriver下载：下载地址 注意：Chrome浏览器版本和ChromeDriver版本要保持一致
安装 1.ChromeDriver安装
步骤一：将下载好的chromedriver.exe文件放置到chrome浏览器所在目录
步骤二：复制该目录配置到Windows系统环境变量中
步骤三：我的电脑→属性→高级系统设置→环境变量→系统变量→Path→编辑→新建，将复制的目录粘贴确定即可，注意：要一路确定返回。
2.Seleuinm安装 Selenium模块是Python的第三方库，可以通过pip进行安装
pip install selenium
或python中导入
3.淘宝秒杀脚本 rom selenium import webdriver import datetime import time # 连接Chrome浏览器 driver = webdriver.Chrome() def login(url): # 打开淘宝登录页，并进行登录 driver.get("https://www.taobao.com") time.sleep(3) if driver.find_element_by_link_text("亲，请登录"): # F12 点击事件name定位（注意空格） driver.find_element_by_link_text("亲，请登录").click() print("请在20秒内完成登录") time.sleep(20) driver.get(url) time.sleep(3) now = datetime.datetime.now() print('login success:', now.strftime('%Y-%m-%d %H:%M:%S')) def buy(buytime): while True: now = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.%f') # 对比时间，时间到的话就点击结算 if now &gt;= buytime: try: # 立即抢购 if driver.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13013b1341d3c8b082815208499e1b42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12195648001c620368a10a5cff63f3f1/" rel="bookmark">
			最适合Python入门到大牛必看的7本书籍，一定要收藏！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python零基础应该阅读哪些书籍？我推荐这三本书 1、《Python学习手册（第4版）》
以计算机科学家一样的思维方式来理解Python语言编程，实用的学习指南，适合没有Python编程经验的程序员阅读，本书的第2版与第1版相比，做了很多更新，将编程语言从Python 2升级成Python 3
2、《笨办法学Python（第3版）》
面向实践的Python编程实用指南。本书的目的，不仅是介绍Python语言的基础知识，而且还通过项目实践教会读者如何应用这些知识和技能。
3、《Python编程：从入门到实践》
本书是一本针对所有层次的Python 读者而作的Python 入门书。全书分两部分：第一部分介绍用Python 编程所必须了解的基本概念，包括matplotlib、NumPy和Pygal 等强大的Python 库和工具介绍，以及列表、字典、if 语句、类、文件与异常、代码测试等内容；第二部分将理论付诸实践，讲解如何开发三个项目，包括简单的Python 2D 游戏开发如何利用数据生成交互式的信息图，以及创建和定制简单的Web 应用，并帮读者解决常见编程问题和困惑
大牛应该看哪些书籍呢？推荐以下4本书籍 1、《流畅的Python》
本书由奋战在Python开发一线近20年的Luciano Ramalho执笔，Victor Stinner、Alex Martelli等Python大咖担纲技术审稿人，从语言设计层面剖析编程细节，兼顾Python 3和Python 2，告诉你Python中不亲自动手实践就无法理解的语言陷阱成因和解决之道，教你写出风格地道的Python代码。
2、《Python核心编程 第3版》
针对所有层次的Python 读者而作的Python入门书，理论与实践相结合，前面部分是基础知识，后面有实战项目帮助你更好的运用这些知识。
3、《Python编程快速上手 让繁琐工作自动化》
美亚畅销Python编程图书，帮助你通过编程快速实现工作自动化在本书中，你将学习利用Python 编程，在几分钟内完成手工需要几小时的工作，而事先却无需具备编程经验。一旦掌握了编程的基础知识，你就可以毫不费力地创建Python 程序，完成高效的自动化工作。
4、《Python高级编程 第2版》
本书的重点是让你熟悉zui佳实践、有用的工具以及标准，这都是Python专业人士每天使用的。首先，你将了解Python 3.5中新增加的功能以及可以提高生产力的快速技巧。
看这些书籍的作用何在？ 可以在书籍中获取Python进阶知识；这些Python书籍可以扩充知识面，提高阅读能力和写作水平；通过阅读Python书籍可以结合书本知识解决实际生活中问题的方法；Python书籍可以增见识长学问，拓展思路，改变思维习惯，促进个人进步。 怎么有效的阅读这些书籍？ 1、驱动读书
首先最主要的就是读书的驱动力，一种是带着问题的好奇心寻求解答，另一种是自己的兴趣使然。
2、读书技巧
阅读一本书，不需要通读，也不需要每个部分都匀速地去阅读。重点部分可以反复阅读，非重要的部分则可以扫两眼就过去。这也要求了我们要带着问题去阅读，可以更快地找到答案，即书中的精华。
3、建立知识库
得到了知识，就要把这些知识存档起来。
首先是存档什么样的知识。原尻淳一给出的一种方式是：将知识分为三类，分别为“菜谱信息”“食材信息”“装盘信息”。每一种分类的比喻都很形象，可以理解为方法论、素材和形式。妈妈们都会积累自己的食谱，我们也要积累自己的知识食谱。
4、总结输出
总结输出说的主要是非虚构类书籍，毕竟这些可以更好的化为己用。
看再多的书，得到再多的知识和经验，不去总结出来、不去实践也是无用。所以我们在读完一本书之后，就应该将所得投入实践，以改进自身。知行结合，才能够让我们更上一层楼。并且，我们可以以著书立说为目标，用所学和经验整理出属于自己的独门秘籍。
今天的内容介绍到这里就全部结束了，关注我持续输出干货，咱们下期再见
以上就是今天的全部内容分享，觉得有用的话欢迎点赞收藏哦！
Python经验分享 学好 Python 不论是用于就业还是做副业赚钱都不错，而且学好Python还能契合未来发展趋势——人工智能、机器学习、深度学习等。
小编是一名Python开发工程师，自己整理了一套最新的Python系统学习教程，包括从基础的python脚本到web开发、爬虫、数据分析、数据可视化、机器学习等。如果你也喜欢编程，想通过学习Python转行、做副业或者提升工作效率，这份【最新全套Python学习资料】 一定对你有用！
小编为对Python感兴趣的小伙伴准备了以下籽料 ！
对于0基础小白入门：
如果你是零基础小白，想快速入门Python是可以考虑培训的！
学习时间相对较短，学习内容更全面更集中可以找到适合自己的学习方案 包括：Python激活码+安装包、Python web开发，Python爬虫，Python数据分析，人工智能、机器学习、Python量化交易等学习教程。带你从零基础系统性的学好Python！
一、Python所有方向的学习路线 Python所有方向路线就是把Python常用的技术点做整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12195648001c620368a10a5cff63f3f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7047cdaa51da664fa7ebd25d62697c72/" rel="bookmark">
			FAST-LIO2:论文和算法解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 摘要一、简介二、相关工作2.1雷达惯导里程计2.2 建图过程中的动态数据结构 三、系统架构四、状态估计A. 卡尔曼模型1.状态转换模型2.测量模型 B.迭代卡尔曼滤波1. 预测过程2. 残差计算3.迭代更新 五、建图A.地图管理B.树的结构与创建1.数据结构2.ikd树的创建 C.地图的增量式更新1.基于树降采样操作的点插入2.基于延迟标签的逐框删除3.属性更新 D.平衡的恢复1.平衡准则2.重建及并行重建 E. K-邻域搜索F.时间复杂度分析1.增量操作2.子树重建3.最近邻搜索 六、试验结果A.软硬件环境B.ikd-tree数据结构评估C.精度估计D.实时性评估 七、实车测试 题目：FAST-LIO2:快速直接激光雷达惯性里程计 参考链接： ikd-Tree: 港大开源增量式 kd-tree 结构 kd-tree 原理深入理解 本文对FAST-LIO2论文进行翻译解析，非逐句翻译，对一些介绍性内容进行总结，对关键算法给出一些自己的理解。
整体上看，FAST-LIO2的改进点主要在第一个版本上增加了ikd-tree和去除了特征匹配，采用直接匹配的方式构建残差。
摘要 本文介绍了FAST-LIO2算法：一种快速、鲁棒、通用的激光雷达-惯性里程计框架。FAST-LIO2基于高效的紧密耦合迭代卡尔曼滤波器，具有两个关键的新颖之处，可实现快速，稳健和准确的激光雷达导航(和测绘)。
第一种方法是直接将原始点注册到地图上然后更新地图，而不提取特征。这样可以利用环境中的细微特征，从而提高准确性。消除手工设计的特征提取模块，也使其能够适应不同扫描模式的新兴激光雷达;第二个主要的新颖之处是通过增量k-d树数据结构(ikd-Tree)来维护映射，这使得增量更新(即激光点插入、删除)和动态重新平衡成为可能。与现有的动态数据结构(八叉树，R*-tree，nanoflann k-d tree)相比，ikd-Tree进行下采样时可以获得更好的整体性能。
我们对来自各种公开LiDAR数据集的19个序列进行了详尽的基准比较。FAST-LIO2与其他先进的激光雷达惯性导航系统相比，在更低的计算负荷下实现了更高的精度。在小视场的固态激光雷达上进行了各种实际实验。总体而言，FAST-LIO2具有计算效率高(例如，在大型室外环境中高达100Hz的里程计和建图)，鲁棒性强(例如，在旋转高达1000度/秒的杂室内环境中得到可靠的姿态估计)，多用途(即适用于多线机械雷达和固态激光雷达，无人机和手持平台，以及基于英特尔和arm的处理器)，同时仍然实现比现有方法更高的精度。我们实现的系统FAST-LIO2和数据结构ikd-Tree在Github上都已经开源。
一、简介 视觉SLAM可以提供精确的定位结果，但是无法提供3D稠密地图用于避障和路径规划。
激光LIDAR可以解决上述问题，且当前激光雷达的体积结构、成本和性能都在不断优化。使得广泛应用和商业化成为可能。
激光雷达在SLAM技术中的应用同样也存在一些问题：
LIDAR数据量庞大，对计算效率要求高面对无结构环境，基于特征提取的激光SLAM方法效果不佳，同时也会收到FOV、扫描方式和点密度的影响，需要很多额外数据处理的适配工作IMU可以弥补LIDAR的运动畸变，但本身的偏置和外参等信息需要进行标注和更新针对点云在空间中的稀疏分布问题，需要高效的点云检索方法 在这项工作中，我们通过两个关键的新技术:增量k-d树和直接点配准来解决这些问题。更具体地说，我们的贡献如下:
增量k-d树数据结构
提供高校的最近邻搜索，支持增量式地图更新，包括云点的插入与删除、树的上采样和下采样，极大减少计算成本，在计算资源受限可以达到100HZ的里程计和建图频率。基于IKD-TREE的原始点云配准
基于ikd-Tree，实现原始点云的注册，而非基于特征提取方法，使算法可以适应不同的环境和LIDAR传感器。将上述改进应用到FAST-LIO中在丰富的数据集和工作环境测了算法的性能，并和其他算法进行对比分析。 二、相关工作 2.1雷达惯导里程计 1. 纯激光SLAM
目前纯激光SLAM多参考了LOAM结构，分为特征提取，里程计和建图三个模块。为减小匹配计算量对点云进行了特征提取，然后通过scan-to-scan和scan-to-map获取精确的位姿信息。LEGO-LOAM在匹配时分离的地面点减小计算，并引入回环检测。LOAM-Livox算法直接基于scan-to-map实现里程计位姿估计提高了位姿估计精度，但是由于每一步都需要更新地图点k-d树使得计算量增加。
2. 雷达-惯导里程计
IMU在激光SLAM中的作用主要有3个：
（1）提供点云匹配的初始位姿
（2）用于去除点云的运动畸变
（3）将基于IMU的状态估计加入到SLAM的残差方程，实现紧耦合
FAST-LIO2基于FAST-LIO算法实现，在之前工作的基础上提出一种新的数据结构数据结构ikd-Tree，同时基于该数据结构实现点云到地图的直接匹配，在减小计算量的同时scan-to-map的匹配方式提高了位姿估计精度。
2.2 建图过程中的动态数据结构 为了实现建图，需要一种动态的数据结构支持增量更新和高校的kNN搜索。
R-TREE
基于数据在空间上的接近程度聚类为一个矩形，该矩形包括了相互距离接近的几个叶节点。然后该矩形和其同一节点的其他矩形被更大的矩形包含，依次类推直到根节点。
R*-TREE
R* 树和R树一样允许矩形的重叠，但在构造算法R*树不仅考虑了索引空间的“面积”，而且还考虑了索引空间的重叠。
八叉树
八叉树通过递归地将空间均匀地分成八个轴对齐的立方体来组织三维点云。当立方体为空或满足停止规则(例如，最小分辨率或最小点数)时，立方体的细分停止。新的点被插入到八叉树上的叶节点上，如果有必要，将应用进一步的细分。八叉树同时支持kNN搜索和箱形搜索，后者返回给定轴对齐长方体中的数据点。
K-D树
（1）最上层为根节点，最下层为叶子节点，其余为中间节点
（2）上层节点是下层节点的父节点
（3）下层节点是上层节点的子节点，子节点根据维度的比较分左右子节点，也即父节点的左子树和右子树
（4）每一层都需要指定一个维度(如3D坐标XYZ中的X维度)，并在该维度上取一个值，X小于该值的点被划分到左子树，大于该值被划分为右子树
（5）每到下一层，需要选择新的划分维度和划分值，采用方差较大的维度作为本层分割的维度
增量kd树：ikd-Tree
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7047cdaa51da664fa7ebd25d62697c72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4c1a4b72f728b34223b349d29d8da6e/" rel="bookmark">
			Linux 系统 curl 命令详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		curl 是一个功能强大的命令行工具，用于与 Web 服务器进行数据通信。它支持多种协议，如 HTTP、HTTPS、FTP、SFTP、SMTP 等，并提供了丰富的选项和参数来执行各种操作，如发送请求、下载文件、上传文件等。下面我将详细介绍 curl 命令的用法。
基本语法：
curl [选项] [URL] 常用选项： -X, --request &lt;METHOD&gt;：指定请求方法，如 GET、POST、PUT、DELETE 等。-H, --header &lt;HEADER&gt;：添加请求头信息。可以使用该选项多次添加多个请求头。-d, --data &lt;DATA&gt;：发送 POST 请求时附带的数据。-F, --form &lt;KEY=VALUE&gt;：以表单形式发送 POST 请求时提交数据。-o, --output &lt;FILE&gt;：将响应保存到指定文件。-O, --remote-name：将响应保存到当前目录下的文件，文件名使用 URL 的最后一部分。-L, --location：如果服务器返回重定向，则跟随重定向。-c, --cookie &lt;COOKIE&gt;：发送请求时携带的 Cookie。-b, --cookie-jar &lt;FILE&gt;：将服务器返回的 Cookie 保存到指定文件。-u, --user &lt;USER:PASSWORD&gt;：设置用户名和密码，用于进行身份验证。-s, --silent：静默模式，不显示进度信息。-v, --verbose：显示详细的调试信息。-i, --include：在输出中包含响应头信息。-A, --user-agent &lt;USER_AGENT&gt;：设置 User-Agent 头信息。-e, --referer &lt;URL&gt;：设置 Referer 头信息。-H, --host &lt;HOSTNAME&gt;：设置 Host 头信息。-I, --head：只获取响应头信息，不下载内容。-k, --insecure：忽略 SSL 证书验证。-m, --max-time &lt;SECONDS&gt;：设置请求的最大执行时间。-x, --proxy &lt;PROXY&gt;：设置代理服务器。--data-urlencode &lt;DATA&gt;：URL 编码发送的数据。--compressed：使用压缩传输。 常用命令 发送 GET 请求并显示响应内容：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4c1a4b72f728b34223b349d29d8da6e/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/27/">«</a>
	<span class="pagination__item pagination__item--current">28/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/29/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>