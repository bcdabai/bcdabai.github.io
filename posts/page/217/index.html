<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f2838a9f6c43d07f98c09e5450fc551/" rel="bookmark">
			Flink-windows10测试环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.JDK安装 安装(不会请百度)—版本在1.8及之上(如果有多版本的话,在path中将JAVA_HOME放在最前面)
2.Scala安装 下载地址:https://www.scala-lang.org/download/
环境变量的配置
新增环境变量: SCALA_HOME
3.Flink的下载(JDK1.8及之上) 下载地址: https://flink.apache.org/downloads.html
此处使用版本的是1.9.1
下载后直接解压可使用;
进入解压目录的bin目录，运行start-cluster.bat，启动成功后本地访问http://localhost:8081
4.测试 flink 提供两种任务运行入口
1、flink.bat脚本启动任务程序
2、页面上传任务程序包运行
通过脚本启动任务
运行字统计任务demo程序
flink.bat run ../examples/batch/WordCount.jar 页面上提交
实时任务
使用nc进行数据输入
windows环境下nc(netcat)的安装及使用
一、下载
url：https://eternallybored.org/misc/netcat/
打开下载的压缩包，找到nc.exe,复制粘贴到 c盘 users/当前登录用户目录下即可
输入 nc -L -p 9000
启动flink任务读取端口数据
flink.bat run ../examples/streaming/SocketWindowWordCount.jar --port 9000 在idea中就可以跑单元测试了
但是我遇到一个错误
Error running 'testapi': Command line is too long. Shorten command line for testapi or also for Application default configuration. 解决方法
在项目所在目录下找到.idea/workspace.xml文件，在名为 PropertiesComponent 的 component 标签里面添加
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f2838a9f6c43d07f98c09e5450fc551/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1e1954da1e8a27e8b347e775fc6ddbf/" rel="bookmark">
			mysql mgr 启动_使用MySQL Shell创建MGR
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇知识点：
配置MGR所需的参数
使用MySQL Shell配置MGR
shell.connect()
var 设定临时变量
dba.createCluster()
dba.getCluster()
dba.addInstance()
dba.removeInstance()
dba.switchToMultiPrimaryMode()
dba.switchToSinglePrimaryMode()
完全依靠MySQL Shell自动生成参数究竟靠不靠谱？
MGR 原理探索
环境信息
IPportroleinfo
192.168.188.81
3306
node1
null
192.168.188.82
3306
node2
null
192.168.188.83
3306
node3
null
CentOS Linux release 7.6.1810 (Core)
MySQL Ver 8.0.20 for Linux on x86_64 (MySQL Community Server - GPL)
MySQL Router Ver 8.0.20 for Linux on x86_64 (MySQL Community - GPL)
MySQL Shell Ver 8.0.20 for Linux on x86_64 - for MySQL 8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1e1954da1e8a27e8b347e775fc6ddbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17ac5f594aaea93b495d3ab8b27e1d7b/" rel="bookmark">
			mysql 类型转换 索引_经过字段类型转化后的查询不走索引
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总结：索引字段上有发生int到varchar、varbinary的类型转换，不会使用到索引
而如在索引字段上发生varchar向int的类型转化，仍然会使用到索引
表结构如下：
mysql&gt; show create table tag_item_list\G
*************************** 1. row ***************************
Table: tag_item_list
Create Table: CREATE TABLE `tag_item_list` (
`tag_item_list_id` bigint(20) unsigned NOT NULL auto_increment,
`tag_id` bigint(20) unsigned NOT NULL,
`item_type` bigint(20) unsigned NOT NULL,
`item_id` varchar(100) NOT NULL,
`list_id` bigint(20) unsigned NOT NULL,
`deleted` tinyint(1) NOT NULL,
`item_ext1` bigint(20) NOT NULL default '0',
`item_ext2` bigint(20) NOT NULL default '0',
`item_ext3` bigint(20) NOT NULL default '0',
`relation_ext1` bigint(20) NOT NULL default '0',
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17ac5f594aaea93b495d3ab8b27e1d7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92c96bc8c6976fed38ae07765f51bf32/" rel="bookmark">
			Linux驱动 GPIO标准接口函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 GPIO标准接口函数所在头文件 #include &lt;linux/gpio.h&gt; 申请GPIO接口函数 void gpio_request(unsigned gpio , const char * label); 参数说明： gpio:引脚的编号。 label:自定义引脚的名字。 GPIO释放函数 void gpio_free(unsigned gpio); 参数说明： gpio:引脚的编号。 配置GPIO为输出引脚的函数 int gpio_direction_output(unsigned gpio,int value); 参数说明： gpio:引脚的编号。 value:	1为输出高电平 ， 0 为输出低电平。 配置GPIO为输入引脚的函数 int gpio_direction_input(unsigned gpio); 参数说明： gpio：为引脚编号。 设置GPIOG的输出值 void gpio_set_value(unsigned gpio,int value); 参数说明： gpio:引脚编号。 value： 1 为输出高电平 ，0 为输出低电平。 获取GPIO的输入值 int gpio_get_value(unsigned gpio); 参数说明： gpio:引脚编号。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05c6b8e72276d661b03252dc3eac8150/" rel="bookmark">
			maya导出obj分组_maya2017怎么导入obj序列？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		谢谢邀请！
首先不太清楚你导入序列的目的是什么，不过猜测大概有两种情况为材质导入序列帧，比如电视机屏幕，电脑的屏幕的材质等。
导入序列帧作为产考动画，就像导入产考图片那样。
第一种情况，首先要强调的是序列帧的格式不同于正常格式 要按照 名称+扩展名+序列号的格式修改，中间以点号隔开。 比如 一张叫 photo001.obj 的图 修改后应为 photo.obj.001 建议可以使用ACDSee批量修改。 修改完就和正常赋予材质一样了，选择材质的color属性，添加文件节点，勾选节点下的 use image sequence，然后路径指认到序列帧的第一张图，指认路径对话框下有文件类型(files of taye)的选项，一定要选择 all files。
第二种情况，把序列帧用maya自带的FCheck播放器播放一遍，然后执行File-Save Animation命令， 然后打开maya，在任意窗口，执行View-Image Plane-Import Image导入第一张序列， Ctrl+a打开属性窗口，Image Plane Attributes栏，Use Image Sequence前面勾选。
希望对你有所帮助！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d719f5e62bceff68957753f2016a261a/" rel="bookmark">
			【网络爬虫 08】解析链接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		urllib 库里还提供了 parse 这个模块，它定义了处理 URL 的标准接口，例如实现 URL 各部分的抽取、合并以及链接转换。它支持如下协议的 URL 处理：file、ftp、gopher、hdl、http、https、imap、mailto、 mms、news、nntp、prospero、rsync、rtsp、rtspu、sftp、 sip、sips、snews、svn、svn+ssh、telnet 和 wais。本节中，我们介绍一下该模块中常用的方法来看一下它的便捷之处。 1.urlparse()
实现 URL 的识别和分段 from urllib.parse import urlparse result = urlparse('http://www.baidu.com/index.html;user?id=5#comment') print(type(result), result) &lt;class 'urllib.parse.ParseResult'&gt; ParseResult(scheme='http', netloc='www.baidu.com', path='/index.html', params='user', query='id=5', fragment='comment') 这里利用 urlparse() 方法进行了一个 URL 的解析。首先，输出了解析结果的类型，然后将结果也输出出来。返回结果是一个 ParseResult 类型的对象，它包含 6 部分，分别是 scheme、netloc、path、params、query 和 fragment。 URL http://www.baidu.com/index.html;user?id=5#comment urlparse() 方法将其拆分成了 6 部分// 前面的就是 scheme，代表协议第一个 / 前面便是 netloc，即域名? 前面是 params，代表参数 标准的链接格式 scheme://netloc/path;parameters?query#fragment urlparse()的API urllib.parse.urlparse(urlstring, scheme='', allow_fragments=True) urlstring这是必填项，即待解析的 URLscheme它是默认的协议（比如 http 或 https 等）。假如这个链接没有带协议信息，会将这个作为默认的协议。allow_fragments即是否忽略 fragment。如果它被设置为 False，fragment 部分就会被忽略，它会被解析为 path、parameters 或者 query 的一部分，而 fragment 部分为空。 from urllib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d719f5e62bceff68957753f2016a261a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37bafbd4d132d8a2e4f70f20dbe99299/" rel="bookmark">
			Day12 重写，构造器，及多态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Day12 方法的重写（override，overwrite） 在子类继承父类之后，可以对父类中的同名同参数的方法进行覆盖。
要求：方法名和形参列表都要一样，否则就是重载，而非重写
重写之后，当创建子类对象之后，通过子类对象调用子，父类中同名同参方法，世界上调用子类重写之后 的方法
重写的规定：
子类重写的方法名和形参列表和父类被重写的方法名和形参列表相同子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符 子类不能重写父类中private的方法 返回值类型： 如果父类被重写的方法的返回值是void，则子类必须是void父类被重写的方法的返回值是A类，则子类重写的方法的返回值可以是A类或A类的子类父类被重写的方法的返回值为基本数据类型，则子类重写的方法的返回值必须是相同的基本数据类型 子类重写的方法抛出的异常的类型不大于父类被重写的方法抛出的异常的类型 子类和父类中同名同参的方法要么都为非static（考虑重写），要么都声明为static（不是重写）
super 理解为：父类的
可以用来调用：属性，方法，构造器
一般使用：
可以在子类的方法或构造器中，通过"super."的方式调用父类的属性或方法，通常情况下省略（属性在内存中不会像方法一样被覆盖，有两个同名属性，默认调用子类，this调用子类，super调用父类）
this.data;// 子类中的data super.data;//父类中的data //考虑 ID 和 身份证号 和 学生证号 等的 关系 子类父类中定义同名的属性时，默认调用子类的，使用super可以调用父类中声明的属性
当子类重写父类中的方法后，我们想在子类的方法中调用父类中被重写方法，必须使用super
调用构造器
我们可以在子类的构造器中显式地使用”super（参数列表）“的方式，调用父类中声明的指定的构造器”super（形参列表）“的使用，必须声明在子类构造器的首行在类的构造器中”this（）”和“super（）”只能二选一，不能同时出现在构造器的首行没有显示地声明“this（）”或“super（）”，默认调用父类中无参构造器 子类对象实例化的过程 结果上看：（继承性）
子类继承父类后，自动获得父类定义的属性和方法
创建子类对象，在堆空间中就加载类父类定义的属性
从过程上看：
通过子类的构造器创建对象时，一定会直接或间接地调用其父类的构造器，从而调用父类的父类的构造器
直到调用java.lang.Object的无参构造器，因为加载过所有父类的结构，所以才可以看到内存中有父类中的结构，子类对象才可以调用
==虽然重建子类对象的时候调用过父类的构造器，但自始至终仅创建过一个对象，即为子类对象。
多态 理解：一个事物的多种形态。以下讲解什么时多态性。
对象的多态性 可以声明父类对象承载子类对象父类的引用指向子类的对象
Person p = new Man(); 通过这种形式调用子父类同名同参的方法时，实际调用的时子类重写的方法——————虚拟方法调用
在编译期，只能调用父类声明的方法，在运行的 时候，实际执行的是子类重写的方法
让秘书去叫一个人，秘书可以叫一个男人或者一个女人。
但是无法调用子类特有的方法和属性多态的使用前提 类的继承关系方法重写 多态不适用于属性 ###　虚拟方法调用
在子类中定义于父类同名同参的方法，在多态情况下，将此时父类的方法称为虚拟方法，父类根据赋给它　的不同子类对象动态地调用子类的方法。这样的方法调用在编译期间时无法确定的，而是在运行时确定。——动态绑定
多态是运行时行为
证明如下：
用随机数进行选择子类，然后调用，只有运行时才能确定调用的是哪个子类的方法
对于重载，他们的调用地址在编译期间就已经绑定了，在调用之前，编译器就知道要调用的方法。这称为“早绑定”或“静态绑定”
对于多态，只有等方法调用的那一刻，编译器（？）才确定所要调用的方法。这称为“晚绑定”或“动态绑定”
不要犯傻，如果他不是晚绑定，他就不是多态——Bruce Eckel
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da16310d27c0cb20b88a94c938e4b8d3/" rel="bookmark">
			@RequestBody的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基础知识介绍： @RequestBody主要用来接收前端传递给后端的请求体中的数据； GET方式无请求体，所以使用@RequestBody接收数据时，前端不能使用GET方式提交数据，而需要用POST方式进行提交。在后端的同一个接收方法里，@RequestBody与@RequestParam()可以同时使用，@RequestBody最多只能有一个，而@RequestParam()可以有多个。
注意：一个请求，只有一个RequestBody，但是可以有多个RequestParam。
这很好理解，请求体只有一个，请求参数可以有多个
当同时使用@RequestParam()和@RequestBody时，@RequestParam()指定的参数类型可以是普通元素、数组、集合、对象等等
即:当@RequestBody 与@RequestParam()可以同时使用时，原SpringMVC接收参数的机制不变，只不过RequestBody 接收的是请求体里面的数据；而RequestParam接收的是url里的key-value参数，所以它会被切面进行处理从而可以用普通元素、数组、集合、对象等接收)。
如果参数是放在请求体中，依照application/json传入后台的话，那么后台要用@RequestBody才能接收到；如果不是放在请求体中的话，那么后台接收前台传过来的参数时，要用@RequestParam来接收，或者形参前什么也不写也能接收。
如果参数前写了@RequestParam(xxx)，那么前端必须有对应的xxx名字才行(不管其是否有值，当然可以通过设置该注解的required属性来调节是否必须传)，如果没有xxx名的话，那么请求会出错，报400。
如果参数前不写@RequestParam(xxx)的话，那么就前端可以自由选择是否传对应xxx的参数，如果有xxx的参数，那么就会自动匹配；没有的话，请求也能正确发送。
追注：这里与feign消费服务时不同；feign消费服务时，如果参数前什么也不写，那么会被默认是 ‘’ @RequestBody的。
如果后端参数是一个对象，且该参数前是以@RequestBody修饰的，那么前端传递json参数时，必须满足以下要求：
1. 后端@RequestBody注解对应的类在将HTTP的输入流(含请求体)装配到目标类时，会根据json字符串中的key来匹配对应实体类的属性，如果匹配一致且json中的该key对应的值符合(或可转换为) 实体类的对应属性的类型时,会调用实体类的setter方法将值赋给该属性。
2. json字符串中，如果value为"“的话，后端对应属性如果是String类型的，那么接受到的就是”"，如果是后端属性的类型是Integer、Double等类型，那么接收到的就是null。
3. json字符串中，如果value为null的话，后端对应收到的就是null。
如果某个参数没有value的话，在传json字符串给后端时，要么干脆就不把该字段写到json字符串中；要么写value时， 必须有值，null 或"“都行。千万不能有类似"stature”:，这样的写法，如下:
示例详细说明： User实体类：
Team实体类：
@RequestBody直接以String接收前端传过来的json数据：
Postman测试结果:
@RequestBody以简单对象接收前端传过来的json数据：
@RequestBody以复杂对象接收前端传过来的json数据：
@RequestBody与简单的@RequestParam()同时使用： @RequestBody接收请求体中的json数据；不加注解接收URL中的数据并组装为对象： @RequestBody与前端传过来的json数据的匹配规则 根据不同的Content-Type等情况,Spring-MVC会采取不同的HttpMessageConverter实现来进行信息转换解析。
下面介绍的是最常用的：前端以Content-Type 为application/json,传递json字符串数据;后端以@RequestBody 模型接收数据的情况。
解析json数据大体流程概述：
Http传递请求体信息，最终会被封装进com.fasterxml.jackson.core.json.UTF8StreamJsonParser中(提示：Spring采用CharacterEncodingFilter设置了默认编码为UTF-8)，然后在public class BeanDeserializer extends BeanDeserializerBase implements java.io.Serializable中，通过 public Object deserializeFromObject(JsonParser p, DeserializationContext ctxt) throws IOException方法进行解析。
核心逻辑分析示例： 假设前端传的json串是这样的： {"name1":"邓沙利文","age":123,"mot":"我是一只小小小小鸟~"} 后端的模型只有name和age属性，以及对应的setter/getter方法；给出一般用到的deserializeFromObject(JsonParser p, DeserializationContext ctxt)方法的核心逻辑：
小技巧之指定模型中的属性对应什么key 详细可参考：
public class BeanPropertyMap implements Iterable&lt;SettableBeanProperty&gt;,Serializable
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da16310d27c0cb20b88a94c938e4b8d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/422273c57178785b214a686625014270/" rel="bookmark">
			hmcl启动器怎么联机_HMCL 启动器教程 #1 安装启动器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HMCL 和其他第三方 Minecraft 启动器的安装流程比别的软件都难多了。它们不提供核善的安装程序，所以格外麻(quan)烦(tui)。下面是 HMCL 详细安装教程。
安装 Java 运行时环境(JRE)
注意选择正确的版本。
创建一个空的文件夹
这个文件夹用于安放你的游戏文件夹(.minecraft)、启动器及其文件，还有一堆杂七杂八的东西。
你可以将这个文件夹放在电脑上任何地方，但是不建议在 C 盘，因为你应该不希望看到 C 盘存储空间提示条变红的样子。
不要为了图省事，用桌面顶替空文件夹。虽然这样做游戏也能正常运行，但相信我，你会后悔的。
一定要记住这个空文件夹的路径，以后会经常用到。(此处是 "D:\HMCL 测试\")
(别告诉我你连新建文件夹都不会)
下载 HMCL 启动器本体
下载链接：
如果你是 Windows 用户，选择 .exe 版本；如果你是其他系统的用户，选择 .jar 版本。
然后把下载好的程序文件放进你创建的空文件夹中。鬼知道这图片怎么这么糊
(别告诉我你连移动文件都不会)
填写账户信息
打开该程序，填写你的账户信息以新建账户，正版玩家将登录方式改成正版登录，盗版玩家则是离线登录(不提倡盗版，不提倡盗版，不提倡盗版)。操作界面过于简单，只要你有一个健康的大脑都能完成。
完成后
最后，如果需要，可以在桌面上创建一个快捷方式，指向那个程序。
(别告诉我你连创建快捷方式都不会)
如果喜欢，可以把 HMCL 固定到任务栏。
至此，HMCL 已经可以正常使用了。但是由于你还没有安装游戏本体，所以还不能玩 MC。下一期会教你如何安装游戏。
Enjoy! XD
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d48246f30b754a1109fe8d5b9c01cfa4/" rel="bookmark">
			移动光猫：家庭存储
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：
最近家里更换宽带，新装移动宽带，送的光猫名称为吉比特无源光纤接入用户端设备具体的型号没有留意，发现上面有U口，有的人认为是调试升级用的，本人不以为然。
个人思路：
本人认为u口可用于下载外接设备或者共享打印机之类的，后在百度中进行搜索，发现帖子数量屈指可数，唯独只有一篇文章大致介绍了功能与结果，实现的方法没有呈现出来，后自己探索研究，找到共享设置的方法。
本文技术概要：
实现过程很简单，只需要插上U盘，进入FTP地址即可，写本文纯属是闲的没事干！
（其实更多的是为了那些想百度，想学习，想探索更多，却找不到资料感到无助的人，当然，我也小题大做了。）
实现流程：
1，首先保证能够连接到光猫管理后台，一般地址都在光猫底部有写；写的内容不仅包括管理地址（如192.168.X.X，一般为192.168.1.1）的文本。
2，用户名与密码，在光猫的底部也有写，可以使用此用户名与密码进入后台，但是，进入没用，与本文意图相反，需要使用隐藏的账密，
帐：CMCCAdmin
密：aDm8H%MdA
这个账户是通用账户，全国同型号通用？部分地区可能不一样，当然，这个账号也都烂大街了。
3，进入后，“应用”–“家庭存储”。（此步无用，只是为了让大家看一下在哪），具体如何设定，这里先不阐述，
4，将U盘插入光猫，光猫USB的指示灯上会亮起黄绿色的灯，就证明插上了。
5，本文重点，打开我的电脑，在地址中输入：ftp://192.168.1.1(此处为你光猫的IP地址)，为什么我要强调这里，因为，在此之前，我使劲进192.168.1.1就是进不去，然后百度上说就是需要在电脑里面进入，后来我发现原来是FTP。。。我人傻了，真的。
6，最终测试结果，我使用台式机复制一个23MB的exe文件，然后再用笔记本无线连接ftp，拷出操作，速度很慢，真的，拷入U盘消耗1m38s，拷入笔记本1m40s（截图就不放了），速度慢的一批，怪不得我看那篇文章说很慢，确实如此。
注：cmcc的管理员账密一个字母都不能错，否则进不去
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b6bfdff8d2b501a0d5f1f24ecaaaae6/" rel="bookmark">
			0x000000f怎么修复 win10_win10系统开机蓝屏错误代码0xc000000f怎么解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虽然win10是最新的操作系统，但是windows系统都有一个毛病，就是蓝屏，动不动就蓝屏，有用户在启动win10系统时突然显示蓝屏，提示Recovery，你的系统需要修复，File:\Boot\BCD,Error code:0xc000000f，这个是BCD引导文件损坏的故障，需要通过系统修复解决。下面小编跟大家介绍win10专业版开机蓝屏错误代码0xc000000f解决方法。
一、准备工作
1、制作当前win10系统版本一致原版镜像盘：win10 u盘安装盘制作教程
2、设置从系统盘引导：电脑设置u盘启动教程
二、修复系统步骤
1、引导后，出现下面的安装界面第一屏，选择【下一步】；
2、选择左下的修复【计算机】；
3、选择【疑难解答】；
(请留意，此处并没有系统的启动项)
4、选择【命令提示符】；
5、输入命令bootrec /rebulidbcd回车【注意空格】；
6、回车后，提示等待。等待后续显示的扫描结果；
7、根据扫描结果，选择需要的恢复模式，一般单系统输入y之后，回车即可。大小写均不影响。
8、修复结果如下：
(一般都是上一步y回车之后，秒出结果)
9、输入exit回车，或者右上角红叉，关闭当前命令提示符界面；
10、修复好之后，即可看到正常可用的【继续】的系统启动项；
11、稍后，即可进入系统中，至此BCD蓝屏修复完毕。
win10系统开机蓝屏错误代码0xc000000f修复系统方法就是这样子，有遇到这个蓝屏故障的用户，可以通过上面的方法来解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5790f72e10359afb116ec827616c067/" rel="bookmark">
			xyz后缀的网站_.XYZ五岁了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		五年前的今天很难相信所有的互联网用户都将可以使用.xyz域名。在2014年初只有少量的好域名可供选择，而许多最好的域名已经被注册。这使得希望首次建立网站的用户感到挫败，并对他们仅有的选择感到不满。谁想要搜索十多次，最终却不得不选一个低标准的域名呢？
2014年6月2日.xyz成功启动了互联网的重置按钮，为全球互联网用户提供了新的，令人难忘且价格合理的域名选择。随着我们数百家热忱的注册商合作伙伴启动分销，.xyz迅速壮大并成为全球最受欢迎的新域名。五年后，我们继续为创作者和创新者服务，为互联网的未来铺平道路。
唯一的通用选择
XYZ通常被以字母表最后三个字母所认知，而以同样的方式结束一个域名组合也变得自然。这便是成千上万的企业家，小企业和创作者选择.xyz域名后缀的原因。作为增长最快的新域名后缀之一，.xyz网站不仅出现在网上，也出现在了杂志、广告牌和广播广告中。.xyz是一个你无法忘记的域名后缀，它正迅速成为互联网用户的普遍选择。
下一代
你有没有给过孩子一个老式录音带让他们播放？他们困惑的目光会很有趣但也可以理解。 技术在眨眼之间更迭，而下一代域名现已可以提供更多的选择和创新。如果你问一个年轻人，你希望如何选择什么样的域名结尾？答案可能会让你大吃一惊。.xyz是一个大胆、新颖的域名后缀，是各年龄段的首选。
好事将近
对于我们来说，2019年是增长和应用方面的重要一年。我们正在扩展营销计划，以提高市场对.xyz的认识，使其成为各类网络存在的首选。下一代互联网用户想要一个全球性的、令人难忘的域名后缀，而我们将继续为他们提供最佳选择：.xyz
请务必访问我们的周年庆祝页面，并在七月份到我们的零售合作伙伴处获得优惠！此外，别忘了订阅我们的新闻并关注我们@xyz网站域名。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d822d71c21fc58f91e11277cdfe6c52/" rel="bookmark">
			Unity各个版本的离线文档下载和配置方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unity各版本离线文档的下载链接：
Unity2020.2版本的英文离线文档
Unity2020.1版本的中文离线文档
Unity2019.4版本的中文离线文档
Unity2019.3版本的中文离线文档
Unity2019.2版本的中文离线文档
Unity2018.4版本的中文离线文档
Unity2018.3版本的中文离线文档
Unity2018.2版本的中文离线文档
Unity2018.1版本的中文离线文档
Unity2017.4版本的中文离线文档
Unity2017.3版本的中文离线文档
Unity2017.2版本的中文离线文档
Unity2017.1版本的中文离线文档
Unity5.6版本的英文离线文档
Unity5.5版本的中文离线文档
找到自己下载的Unity的安装目录，并进入到Data子文件夹，可以参考我的路径： Unity\2019.4.17f1c1\Editor\Data
把下载的离线文档解压后，把里面的Documentation直接覆盖目标Documentation就可以了 3.配置好后可以在Unity中快速打开
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1cbd95370310d34e4c6de3d6a5da11e/" rel="bookmark">
			mc422mysql_绝对mc发布诛仙422完整服务端支持诛仙2进本端补丁修改(此帖子已经整合到最前面)注 - 网游单机资源下载 - g1（Absolute MC released 422 full ...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		绝对mc发布诛仙422完整服务端支持诛仙2进本端补丁修改(此帖子已经整合到最前面)注 - 网游单机资源下载 - g1(Absolute MC released 422 full server support Zhu Xian Zhu Xian 2 in the end (this post patch changes have been integrated into the front) - single o
绝对mc发布诛仙422完整服务端支持诛仙2进本端补丁修改(此帖子已经整合到最前面)注 - 网游单机资源下载 - g1(Absolute MC released 422 full server support Zhu Xian Zhu Xian 2 in the end (this post patch changes have been integrated into the front) - single o
Absolute MC released 422 full server support Zhu Xian Zhu Xian 2 in the end (this post patch changes have been integrated into the front) - online single download - G156 Game Forum Raiders Cheats game download patch _ _ _ Archive - Powered by Discuz _ modifier 156= to play!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1cbd95370310d34e4c6de3d6a5da11e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b6c962f625d16adc210276e68f2da34/" rel="bookmark">
			金蝶专业版怎么反过账当月_金蝶kis怎么反记账-反过账-反结账
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原标题：金蝶kis怎么反记账-反过账-反结账
反结账是指在会计电算化过程中的一个模块或操作步骤，是将业务期间反结到上一期的功能，反结账之后不会删除任何任务数据。相信大多数从事财务和会计工作者都会遇到反结账的时候，有很多的金蝶kis系列用户都反应说金蝶kis怎么反记账-反过账-反结账？其实这是比较简单的操作，现在小编就以为例为大家解答这个问题，金蝶kis迷你版、金蝶kis专业版、金蝶kis标准版等的操作雷同
更多使用教程请访问：
金蝶KIS记账王修改已结账凭证的步骤：
1、打开软件后，直接同时按快捷键Ctrl+F12，随后弹出反结账界面，如果没有设置口令，直接点击“完成”即可，设置了口令的话需要输入口令，否则无法继续。温馨提示，如果Ctrl+F12被系统占用请尝试同时按住Ctrl+Fn+F12，优先选择仍然是Ctrl+F12。
金蝶KIS记账王反结账页面
2、金蝶KIS记账王反过账操作方法是在反结账后，直接同时按住快捷键Ctrl+F11，弹出界面如下图所示：
金蝶KIS记账王反过账界面
当然，如果Ctrl+F11被系统占用，用户可以尝试同时按住Ctrl+Fn+F11，反过账操作可以将本期输入的所有或部分记账凭证都恢复成过账前的状态，所以请用户慎重使用“反过账”功能，可以设置限制此功能只允许系统管理员使用。
3、做完反结账反过账操作后，系统界面由过滤条件直接进入会计分录序时簿的反审核凭证，进入会计分录序时簿后找到工具栏上的“编辑”按键并点击，下拉出菜单，然后找到“成批销章”按键，该按键即为反审核按键，反审核凭证后即可对凭证进行修改。返回搜狐，查看更多
责任编辑：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6205612fd61f3b993a266cee4a5a1b77/" rel="bookmark">
			群晖（Synology）NAS 升级硬盘扩展空间小记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经历过几次硬盘损坏完全丢失数据后，痛定思痛，在 2019 年的时候上了个 NAS。
在上这个 NAS 的时候买了个 8 盘位的，顺便把手上的各种容量的硬盘都拿来装上了，所以硬盘的容量在 NAS 里面也是五花八门。
这样的配置通常不能够将容量用到最大化，但是好歹比单盘的要保险多了。
中途经历过一次硬盘损坏，换过一次硬盘升级过一次空间。
最近又有一块从老台式机上的硬盘被替换下来了，所以想着替换掉 NAS 中容量比较小的 500G 的硬盘。
扩充流程是：
更换硬盘扩充存储池扩充卷 必须要按照上面的顺序进行扩充，在扩充存储池的时候非常耗时，要有心理准备。
找到容量最小的盘位 首先要在你的 NAS 存储中，找到容量最小的盘位。
按照官方的推荐替换原则就是，为了保障存储空间的最大利用，你替换的新硬盘容量要大于等于 NAS 最大容量的硬盘，然后从 NAS 中容量最小的硬盘开始替换。
所以正确的打开姿势是，针对我的 NAS，需要最少容量是 6TB 的，并且从最小容量的盘位开始替换。
因为我这是用的老的台式机硬盘，一般来说替换的新硬盘大于你要替换的存储空间就 OK。
缺点是存储空间的提升很有限，不是你想的那样的算法。
下面的图显示的是，我们替换掉的第 6 盘位的硬盘，这块硬盘在没有替换之前和第8盘位的硬盘容量是一样的，都是 500 GB
替换下来后看了下老的硬盘，居然是 2007 年生产的，到现在已经有 14 年了，是有点老了。
修复存储池 替换硬盘后的下一步就是修复存储池。
当硬盘替换后，会提示你的存储池显示为降级，如果没有这个显示的话，你可以重启下你的 NAS。
然后在存储池上 Action 上会有一个提示为修复，单击修复就会弹出下面的界面。
在上面的界面中，NAS 已经告诉你识别到了新的硬盘和容量。
然后单击下一步继续。
下一步继续后如上图所示，你将会看到确定配置。在这个确定配置上面有一个总的容量。
这个容量就是在修复存储池后你的 NAS 将会扩展到的存储池容量。
确定后继续，然后你会看到 NAS 正在尝试帮你修复存储池。
这里的修复非常耗时，你可以准备 1 天的样子来完成。当上面正在修复的时候，你可以去休息休息了。
在修复的时候是不影响 NAS 使用的，你可以正常使用 NAS。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6205612fd61f3b993a266cee4a5a1b77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9d82ebdfdacca575ea422c58fdb4e1b/" rel="bookmark">
			网络设置巨形帧_修改网卡配置连接千兆网络的详细步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原标题："Win7电脑修改网卡配置连接千兆网络的方法是什么？"相关电脑问题教程分享。 - 来源:191路由网。
目前有很多的电脑都是使用realtek网卡的，当时奇怪的是网卡连接到h3或者d-link千兆交换机的时候，那么网速就会变得非常缓慢，网速直接下降到100兆或者10兆，想要实现千兆的连接就需要重启计算机才可以。想要直接连接千兆网速，那么就需要网卡配置才可以，就下来191路由网小编就为大家带来win7电脑修改网卡配置的方法。
Win7系统修改网卡配置方法：
1、打开控制面板——设备管理器。
2、在网络适配器中打开网卡属性。
3、切换到高级，选中流控制/FlowControl，并在右侧选择关闭，点击确定。如图所示：
4、按照以上步骤修改电脑网卡高级设置可以提高网络速度。另外，建议关闭在Realtek网卡高级设置中的以下其他选项：巨型帧/Jumboframe、大量传送负载/OffloadLargesend、EEE(Energy Efficient Ethernet)、环保节能/GreenEthernet、硬件效验和/OffloadChksum。
5、最后还有连接速度和双工模式，你是10M或10M 以下的宽带，建议选择10M全双工，100M或100M以下的就选择100M全双工。
以上内容就是win7电脑修改网卡配置连接千兆网络的详细方法了，如果有用户遇到相同情况却不知道该如何进行修改，那么就按照上述的方法进行操作。希望可以帮助到大家。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec983310c9cf10e3e3eb14339a2b2e0a/" rel="bookmark">
			AVL树删除节点deletenode函数分析 （C&#43;&#43;实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先放一下代码：（这里只放一些必要的内容。因为每个人的习惯不同，只有思路可以借鉴。请注意注释。关于旋转函数，我在上一篇帖子分析insert时贴出过，仅供参考。如果在某个地方没有理解，请先继续往下看一会，或许能找到答案。如果发现代码和解释有问题，请务必指出。）
avltree deletenode(int X, avltree T) { //X为删除目标的关键字值 //info为关键字值 position tmp; if (T == NULL) return NULL; else if (X &lt; T-&gt;info) { T-&gt;left=deletenode(X, T-&gt;left); if (Height(T-&gt;right)-Height(T-&gt;left) &gt;= 2)//height函数用于返回节点所处的高度 { tmp = T-&gt;right; if(Height(tmp-&gt;right)&gt;Height(tmp-&gt;left)) T = SingleRotateWithRight(T);//右树单旋转 else T = DoubleRotateWithRight(T);//右树双旋转 } } else if (X &gt; T-&gt;info) { T-&gt;right=deletenode(X, T-&gt;right); if (Height(T-&gt;left) - Height(T-&gt;right) &gt;= 2) { tmp = T-&gt;left; if (Height(tmp-&gt;left) &gt; Height(tmp-&gt;right)) T = SingleRotateWithLeft(T);//左树单旋转 else T = DoubleRotateWithLeft(T);//左树双旋转 } } else { if (T-&gt;left == NULL &amp;&amp; T-&gt;right == NULL)//若目标节点没有为叶子 { delete T; return NULL; } else if (T-&gt;right == NULL)//若目标节点只有左子树 { tmp = T-&gt;left; delete T; return tmp; } else if (T-&gt;left==NULL)//若目标节点只有右子树 { tmp = T-&gt;right; delete T; return tmp; } else//若目标节点左右都有子树 { if (Height(T-&gt;left) &gt; Height(T-&gt;right)) { tmp = findmax(T-&gt;left);//找出参数节点中最大的节点，返回地址 T-&gt;info = tmp-&gt;info; T-&gt;left = deletenode(tmp-&gt;info,T-&gt;left); } else { tmp = findmin(T-&gt;right);//找出参数节点中最小的节点，返回地址 T-&gt;info = tmp-&gt;info; T-&gt;right = deletenode(tmp-&gt;info, T-&gt;right); } } } T-&gt;height = max(Height(T-&gt;left), Height(T-&gt;right)) + 1; return T; } 前提条件：假设现在面对的是一颗完整正确的AVL树，而我们需要对其进行删除节点的操作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec983310c9cf10e3e3eb14339a2b2e0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30c4f574cb9cd939028cd6c686e3a5e5/" rel="bookmark">
			C语言 - 键盘输入一个小于1000的正数，要求输出它的平方根（如平方根不整数，则输出其整数部分）。 要求在输入数据后先对其进行检查是否为小于1000的正数。如不是，则要求重新输入。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 从键盘输入一个小于1000的正数，要求输出它的平方根（如平方根不整数，则输出其整数部分）。
要求在输入数据后先对其进行检查是否为小于1000的正数。如不是，则要求重新输入。
程序源码 #include &lt;stdio.h&gt; #include &lt;math.h&gt; int main() { int n = 0; while( n &lt; 1 || n &gt; 1000 ) { printf("请输入一个小于1000的正数："); scanf("%d", &amp;n); } printf("它的平方根是：%d\n", (int)sqrt(n)); return 0; } 运行结果 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79788ab6f18cb86ce309d545459d942e/" rel="bookmark">
			Kafka 副本leader选举
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		谁来实施 分区leader副本的选举由Kafka Controller 负责具体实施。 选举时间 leader挂掉时broker挂掉时,然后broker上可能有某些leader 选举资格 Kafka在Zookeeper中为每一个partition动态的维护了一个ISR，这个ISR里的所有replica都跟上了leader，只有ISR里的成员才能有被选为leader的可能（unclean.leader.election.enable=false）
如果ISR为空怎么办?
在ISR中至少有一个follower时，Kafka可以确保已经commit的数据不丢失，但如果某一个partition的所有replica都挂了，就无法保证数据不丢失了。这种情况下有两种可行的方案：
等待ISR中任意一个replica“活”过来，并且选它作为leader 选择第一个“活”过来的replica（并不一定是在ISR中）作为leader 如果一定要等待ISR中的replica“活”过来，那不可用的时间就可能会相对较长。而且如果ISR中所有的replica都无法“活”过来了，或者数据丢失了，这个partition将永远不可用。选择第一个“活”过来的replica作为leader,而这个replica不是ISR中的replica,那即使它并不保障已经包含了所有已commit的消息，它也会成为leader而作为consumer的数据源。默认情况下，Kafka采用第二种策略，即unclean.leader.election.enable=true，也可以将此参数设置为false来启用第一种策略。
unclean.leader.election.enable这个参数对于leader的选举、系统的可用性以及数据的可靠性都有至关重要的影响
选举流程 没找到相关资料
总结 简而言之,就是从ISR中选leader,如果ISR中一个都么有,那就从其他副本选
参考 kafka leader选举
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0fac2cb07409d2454b2d77efb893521/" rel="bookmark">
			如何彻底卸载3dmax2020_3dsmax2020卸载/安装失败/如何彻底卸载清除干净3dsmax2020注册表和文件的方法...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3dsmax2020提示安装未完成，某些产品无法安装该怎样解决呢？一些朋友在win7或者win10系统下安装3dsmax2020失败提示3dsmax2020安装未完成，某些产品无法安装，也有时候想重新安装3dsmax2020的时候会出现本电脑windows系统已安装3dsmax2020，你要是不留意直接安装3dsmax2020，只会安装3dsmax2020的附件或者直接提示失败，3dsmax2020是不会安装上的。这种原因就是大家在之前卸载3dsmax2020时没有把3dsmax2020残留注册表信息删除或者是因为C++版本不对，下面我来教大家如何把3dsmax2020强力卸载掉然后重新安装，最后完美安装运行3dsmax2020，如果纯手工删除3dsmax2020会有几千条注册表记录要删。
AUTO Uninstaller 更新下载地址
1、在软件中选择3dsmax
2、选择3dsmax的版本
3、点击“开始卸载/修复”按钮，等待卸载结束
4、重新安装、可以使用了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e7ffca92b0b1c2e7a4053291d1544d4/" rel="bookmark">
			一张图看懂计算机网络——网络安全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9e9a47d8dc07b0789678bad37dfc512/" rel="bookmark">
			微信小程序中地图--行走轨迹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;map id="map" longitude="{{longitude}}" latitude="{{latitude}}" scale="16" bindcontroltap="controltap" bindmarkertap="markertap" markers="{{markers}}" polyline="{{polyline}}" bindregionchange="regionchange" show-location style="width: 100%; height:{{height}}px;" &gt; &lt;/map&gt; &lt;view class="padding flex flex-wrap justify-between align-center bg-white"&gt; &lt;button class='cu-btn bg-green shadow sm' bindtap='beginTrack'&gt; 开始 &lt;/button&gt; &lt;button class='cu-btn bg-orange shadow sm' bindtap='pauseTrack'&gt; 暂停 &lt;/button&gt; &lt;button class='cu-btn bg-red shadow sm' bindtap='endTrack'&gt; 结束 &lt;/button&gt; &lt;/view&gt; javascript 页面
//index.js //获取应用实例 const app = getApp() Page({ data: { StatusBar: app.globalData.StatusBar, CustomBar: app.globalData.CustomBar, height: wx.getSystemInfoSync().windowHeight, latitude: 0, longitude: 0, playIndex: 0, timer: null, markers: [], polyline: [], pointsInfo:[] }, regionchange(e) { //console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9e9a47d8dc07b0789678bad37dfc512/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67cded36b6a93cbfd71623c047b2b171/" rel="bookmark">
			高通骁龙480 5G处理器规格书/datasheet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qualcomm®骁龙480 5G移动平台在4系列的移动连接方面取得了巨大的飞跃。Snapdragon X51 5G Modem-RF系统以闪电般的速度支持多种5G频谱、模式和频率。凭借对2x2 Wi-Fi（双天线）的支持和高级功能，比以往任何时候都有更多的用户可以在家中和旅途中访问广泛，稳定的连接。该平台是一个真正的里程碑，它具有突破性的4系列成就，包括三重ISP捕获，基于AI的回声消除，Qualcomm®Quick Charge 4+技术以及对120 fps显示屏的支持。这些4系列首创产品使大众市场的消费者能够通过游戏，实时聊天，共享等方式建立真正的联系-达到这一层级之前从未有过的质量水平。
骁龙480特征：
4系列首次真正实现全球5G连接
支持TDD，FDD和动态频谱共享，以实现全球5G覆盖
超低功耗集线器，用于音频，语音和传感器
能够融合上下文数据流，包括传感器，音频和语音
支持多个硬件加速的永远在线语音助手
多麦克风远场检测和回声消除
LTE和Wi-Fi之间具有通话连续性的Wi-Fi通话
Qualcomm®Signal Boost天线调谐
Qualcomm®Kryo™460 CPU与上一代产品相比，性能提高了100％以上
Qualcomm®Adreno™619 GPU的性能比上一代提高了100％以上
4系列首款8纳米制程，可改善性能并降低功耗
高通® AI引擎和QUALCOMM®六角™矢量扩展提供从上一代AI的表现超过70％的改善
Qualcomm®Sensing Hub使您最喜欢的语音助手始终在线，等待您的命令
4系列中首个基于AI的回声消除和背景噪声抑制功能，可提高通话清晰度。
具有Qualcomm SPECtra™345的4系列首款三重ISP，专为多摄像机支持和节能而设计，每次充电可获取更多照片和视频
Qualcomm®AI引擎，用于增强AI摄影功能。
技术指标：（请下载文件查看）
更多内容及文件下载请点击：http://bbs.16rd.com/thread-569924-1-1.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/717e47ddd2999d5ca8d784fea9921b13/" rel="bookmark">
			分库分表mysql mariadb_MariaDB10.1.22 Spider3.3腾讯补丁版分库分表下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		鉴于腾讯Tspider未开源，我拿到了原作者Kentoku Shiba的Spider3.3源代码(集成了腾讯的补丁，性能有所加强)，并且编译到MariaDB 10.1.22 GA版本里，二进制下载地址
http://www.liyanlan.com/download/mariadb/spider/mariadb-10.1.22-spider-3.3.11-linux-x86_64.tgz
注：新版本的参数为110个，比之前的3.2.37RC公测版多了9个参数。
调优参数：
spider
spider_multi_split_read = 1
spider_low_mem_read = 0
spider_conn_recycle_mode = 1
spider_bgs_mode = 1
spider_bka_mode = 2
spider_quick_mode = 3
spider_casual_read = 1
optimizer_switch = ‘engine_condition_pushdown=on,mrr=on,mrr_sort_keys=on’
spider_block_size = 4294967295
spider_remote_trx_isolation = 1
spider_remote_autocommit = 1
spider_remote_default_database = ON
spider_use_pushdown_udf = 1
spider_semi_trx = 1
spider_semi_trx_isolation = 1
sysbench压测
sysbench --test=/root/sysbench-0.5/sysbench/tests/db/oltp.lua --report-interval=1 --oltp-read-only=on --oltp_tables_count=1 --oltp-table-size=1000000 --max-requests=0 --max-time=10 --num-threads=64 --mysql-host=192.168.143.206 --mysql-port=3303 --mysql-user=admin --mysql-password=123456 --mysql-db=test --mysql-engine-trx=yes run
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/717e47ddd2999d5ca8d784fea9921b13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b54dc2bb0be681c573e7e53b9de30d0/" rel="bookmark">
			vue 设置所有的输入框只读_antD vue input输入限制以及提示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载注明出处
1.定义表单输入框中的值的规则
在ant design vue中， "v-decorator"可以看成是v-model，和vue中的双向绑定作用类似
——v-decorator="[id, options]"
其中的id:必填输入控件唯一标志。支持嵌套式的写法。——算是一个普通的id名
options：一般是书写对于表单框中的值的验证 ——即 validatorRules.(自定义的变量值)
2.书写表单规则
rules：支持多个api(官网中有说)
len：字段长度 number
max：最大长度 number
message：校验文案(即提醒信息) string
min：最小长度 number
pattern：正则表达式校验 RegExp
required：表单框是否必填 boolean
validator： 自定义校验规则(校验函数) function(rule,value,callback)
whitespace： 必填时空格是否会被视为错误
validatorRules:{//修改
name:{
rules:[//rules是验证规则，
{
required:true, //是否为必填，否则将会出现提示信息
message:'请输入团名称' //当输入框为空时，呈现出的提示信息
},
{
validator:this.checkName //自定义的校验函数
}
]
}//修改
},
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efeeaf2cfe038471291cdeef21dde5bc/" rel="bookmark">
			每日一题——leetcode643. 子数组最大平均数 I
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 给定 n 个整数，找出平均数最大且长度为 k 的连续子数组，并输出该最大平均数。
示例：
输入：[1,12,-5,-6,50,3], k = 4
输出：12.75
解释：最大平均数 (12-5-6+50)/4 = 51/4 = 12.75
提示：
1 &lt;= k &lt;= n &lt;= 30,000。
所给数据范围 [-10,000，10,000]。
题目链接：https://leetcode-cn.com/problems/maximum-average-subarray-i
解答 思路一：滑动窗口（窗口大小固定的场景）。
一个数组nums，先算合最大的连续数组，最后再除k。重点变成了计算合最大的连续数组，从index=0l开始遍历，先计算第一个K长度的数组的合sums[0]，然后依次向后遍历，每向后滑动一个此时index为i，重新得到的数组的合为sums[i-1]-nums[i-1]+nums[i+k]，将sums[i]都放到sums数组里，最后使用max(sums)就可以啦
class Solution: def findMaxAverage(self, nums: List[int], k: int) -&gt; float: sums = [] sums.append(sum(nums[:k])) for i in range(1, len(nums)-k+1): sums.append(sums[i-1]-nums[i-1]+nums[i+k-1]) return max(sums)/k 或
class Solution(object): def findMaxAverage(self, nums, k): """ :type nums: List[int] :type k: int :rtype: float "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/efeeaf2cfe038471291cdeef21dde5bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f24387ec8f3bad84d5b24c8a8a338496/" rel="bookmark">
			Win10打开老游戏血战上海滩
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个网上给了好多方法，我试了试，没什么用，自己摸索着，改了一些设置，就可以打开，并且鼠标在游戏里正常使用。（鼠标不能正常使用可能是游戏的分辨率和电脑显示的分辨率没有对应好。）
不管在哪下载的文件包吧，首先，建立一个开始游戏exe的快捷方式。
然后打开这个快捷方式的属性界面，更改目标程序，在后面加入“ -windows”，注意前面有一个空格；然后更改运行方式为最大化。
在兼容性界面，以兼容性模式运行这个程序，另外取消勾选用640 x 480屏幕分辨率运行，最后禁用全屏优化，这样就可以全屏打开这个游戏了。
最后把电脑分辨率调为1024 x 768，然后双击你建立好的快捷方式，就可以正常游戏辣~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecdf9a23557a34d3359169ec5b70dc3f/" rel="bookmark">
			使用Elcomsoft Advanced Office Password Recovery对Office文档进行密码恢复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		划重点=&gt;软件链接
注：博主测试用的97-2003版本的Excel
一、打开软件 选择一种文档破解方法
二、破解密码 1、文件-&gt;打开文件 选中文件打开即可开始破解密码
如图，密码1234，打开Office文档输入密码即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe91d579cc81a522042b2a3f7caa9f3a/" rel="bookmark">
			Flask报错The server encountered an internal error and was unable to complete your request. Either the
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		The server encountered an internal error and was unable to complete your request. Either the server is overloaded or there is an error in the application.
原因：可能是重复跑了好几次代码，导致服务器崩溃
方法1：关机重启，，不太方便
方法2：https://blog.csdn.net/weixin_41733260/article/details/100532091
一般flask启动时监听的是5000端口，如果修改的话更改后面的端口号 找出端口5000的进程，将进程杀死
netstat -ano | findstr 5000
taskkill /pid XXXXX /f （XXXXX的地方用进程号替换）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14abc9db5971956e44393f70fa86189e/" rel="bookmark">
			小程序退出后音乐还会播放解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;script&gt; var hidden = "hidden"; //各个浏览器属性兼容 if (hidden in document) document.addEventListener("visibilitychange", onchange); else if ((hidden = "mozHidden") in document) document.addEventListener("mozvisibilitychange", onchange); else if ((hidden = "webkitHidden") in document) document.addEventListener("webkitvisibilitychange", onchange); else if ((hidden = "msHidden") in document) document.addEventListener("msvisibilitychange", onchange); else if ("onfocusin" in document) document.onfocusin = document.onfocusout = onchange; else window.onpageshow = window.onpagehide = window.onfocus = window.onblur = onchange; function onchange(evt) { if (document[hidden]) { $('#audio').removeClass('play'); document.getElementById("bgm").pause(); // document.title = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14abc9db5971956e44393f70fa86189e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22174f2040aae0bedd956b6ffdc38233/" rel="bookmark">
			利用pyinstaller将python项目脚本打包成可执行文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用pyinstaller打包python项目 由于本文讲述还算比较详细， 如果对pyinstaller有一定的了解，只需快速上手，可以直接跳到第四章结合实例进行操作。 1简介及安装pyinstaller 1.1简介 PyInstaller是一个第三方库，它能够在Windows、Linux、 Mac OS X 等操作系统下将 Python 源文件打包，通过对源文件打包， Python 程序可以在没有安装 Python 的环境中运行，也可以作为一个独立文件方便传递和管理。 PyInstaller支持Python 2.7和Python 3.3+。可以在Windows、Mac OS X和Linux上使用，但是生成的可执行文件并不是跨平台的，也就是说如果要是希望打包成.exe文件，需要在Windows系统上运行PyInstaller进行打包工作；打包成mac app，需要在Mac OS上使用；而linux系统下打包的可执行文件则没有后缀，比如对xxx.py进行打包，打包后的文件名为xxx。 后续章节将主要以在windows系统下打包成exe可执行文件为例进行讲解。 1.2 安装pyinstaller PyInstaller 库会自动将 PyInstaller 命令安装到 Python 解释器 目录中，与 pip 或 pip3 命令路径相同，因此可以直接使用。 无论是linux、mac或者windows都可以直接使用pip命令进行安装，pip安装命令如下： pip install pyinstaller 2 pyinstaller的基本使用 2.1基本命令及常用参数 Pyinstaller可以通过简单的命令进行python代码的打包工作，其基本的命令为： pyinstaller -option xxx.py 其中xxx.py就是需要打包的python脚本，option为pyinstaller中的参数选项，其中 option默认为“-D” 。 完成后生成三个文件夹“__pycache__”(缓存)、“build”(临时文件)、“dist”(生成文件)和 一个文件“xxx.spec”(配置文件)。生成的应用程序就在“dist”文件夹中。 如在Windows下打包主文件为main.py的python项目脚本，只需在main.py所在路径下的cmd中执行下面的代码即可： pyinstaller main.py 图2-1 打包前项目文件 图2-2 打包后文件 PyInstaller既可以在Windows平台上使用，也可以在 Mac OS X 平台上运行。在不同的平台上使用 PyInstaller 工具的方法是一样的，它们支持的选项也是一样的。其常用选项如下： 表2-1 pyinstaller常用参数 可选参数 格式举例 功能说明 -F pyinstaller -F demo.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22174f2040aae0bedd956b6ffdc38233/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e5c7d0dcfbeb1ef540bce695f6c8c26/" rel="bookmark">
			【重学面向对象】篇一：到底什么是多态？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 接触Java这么久，我们一定都知道，作为面向对象阵营的典型代表，封装、继承、多态 (其实还应该包含抽象)是其三大基本特征
但是到底什么是多态，它的底层又是如何实现的，又有什么优缺点，可能就没那么容易说清楚
今天我们从它的近亲 C++ 语言来重新审视下，到底什么是多态
下面，正文开始！
什么是多态 多态（Polymorphism）是面向对象的三大基本特征之一，多态是在 面向对象 的语境下，将数据模型封装为类对象，而对象之间又含有继承关系，一个基类（base class）可以有不同的派生类（derived class），不同的派生类有各自不同的行为，这种用法就叫做多态
多态是怎么实现的 从语言层面讲，多态依赖于面向对象的继承（implement）和函数的重写来实现，一个基类可以派生出不同的子类对象,不同的子类对象可以有各自不同的行为，正所谓，龙生九子，凤育九雏
从编译器角度讲，多态依赖于不同的派生类有相同的 指针类型 ，所以创建一个类的时候，可以指向他的基类
进一步讲，派生类和基类的函数会有一个虚函数表（vtable）来存储他们的指针，以达到子类能继承和调用基类成员的功能，如下图所示
图片引自 JerryFu 的博客 &gt;&gt;&gt; https://www.cnblogs.com/jerry-fuyi/p/value_polymorphism.html
多态有什么好处 我们经常强调要 面向接口编程/面向父类编程 ，一个定义良好的基类，基本上是不需要修改的，需要修改的只有不同派生类的不同行为而已
因此，当我们在调用层面需要改变具体的行为时，可以修改派生类或者重新创建一个派生类，来满足业务需求
而调用层只需要将原来的派生类改为我们重新创建的派生类即可，达到以最少的代码改动实现对应需求的效果
多态有什么缺点 多态的缺点在于，其针对真实世界 对象 的模拟，在基类定义不准确时，会产生行为不一致的后果
比如我们定义一个基类 Bird ，根据常识，飞行是鸟的基本能力，所以我们定义了一个函数 fly()
不同的鸟类可能又有各自的不同的行为，我们再定义一个派生类 Ostrich (鸵鸟)， 但是鸵鸟是不会飞的，这就导致了派生类与基类行为不一致的后果
这个问题是多态没有办法解决的，所以必须通过其他形式给多态打个 补丁 ，即通过函数重写，来改变基类方法，实现派生类自己的行为；但函数重写没有办法解决的是在调用层进行调用时，行为不一致导致的业务逻辑混乱，这时则需要更多的代码去修改调用层
所以当我们定义基类的时候，尽量要想清楚，哪些函数是公共的，需要放在基类中的，以减少这种情况的发生
多态的写法 上面讲了很多理论，下面我们通过代码来看一看，C++中多态的写法
源码请查看 &gt;&gt;&gt; https://github.com/liyilin-jack/cpp_samples/blob/main/main.cpp
话说上帝创造人类的时候，也是使用了面向对象的思想
上帝先定义了一个基类Human ，Human中有定义了虚函数 pee()和 walk() ，交给派生类去实现 , 由于所有人类都会爬行，所以这里直接实现了爬行的函数
#include &lt;string&gt; #include &lt;vector&gt; using namespace std; class Human{ public: string name = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e5c7d0dcfbeb1ef540bce695f6c8c26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dd4f4b84068344b72fae14b6c0d94b8/" rel="bookmark">
			谷歌浏览器:检查更新时出错：无法启动更新检查（错误代码为 4: 0x80070005 -- system level）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： 谷歌浏览器更新出现
检查更新时出错：无法启动更新检查（错误代码为 4: 0x80070005 -- system level） 原因分析： 未打开谷歌更新服务
解决方案： 第一步:打开任务管理器
第二步:找到跟新服务点击打开
第三步:在弹出的框中找到服务点击属性
第四步:将启动类型改为手动或自动
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb1f8b2228ad7de700f569052315bc74/" rel="bookmark">
			python给子线程加参数_python中的线程threading.Thread()使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 线程的概念：
线程，有时被称为轻量级进程(Lightweight Process，LWP)，是程序执行流的最小单元。一个标准的线程由线程ID，当前指令指针(PC)，寄存器集合和堆栈组成。另外，线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源。
2. threading.thread()的简单使用
2.1 python的thread模块是比较底层的模块，python的threading模块是对thread做了一些包装的，可以更加方便的被使用
import threading
import time
def saySorry():
print("亲爱的，我错了，我能吃饭了吗？")
time.sleep(1)
if __name__ == "__main__":
for i in range(5):
t = threading.Thread(target=saySorry)
t.start() #启动线程，即让线程开始执行
运行结果：
使用说明：
可以明显看出使用了多线程并发的操作，花费时间要短很多
当调用start()时，才会真正的创建线程，并且开始执行
每个线程都有一个唯一标示符，来区分线程中的主次关系
主线程:mainThread,Main函数或者程序主入口，都可以称为主线程
子线程:Thread-x 使用 threading.Thread() 创建出来的都是子线程
线程数量：主线程数 + 子线程数
2.2 主线程会等待所有的子线程结束后才结束
import threading
from time import sleep,ctime
def sing():
for i in range(3):
print("正在唱歌...%d"%i)
sleep(1)
def dance():
for i in range(3):
print("正在跳舞...%d"%i)
sleep(1)
if __name__ == "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb1f8b2228ad7de700f569052315bc74/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ac653b990465f5ca187f260f0364818/" rel="bookmark">
			把Java程序的输出结果写入文件的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将Java程序的输出结果写到txt文件中的方法 1.将输出结果输出到txt文件 直接安排代码：
//导包 import java.io.FileNotFoundException; import java.io.PrintStream; public class Test { public static void main(String[] args) throws FileNotFoundException { // 创建一个打印输出流，输出的目标是D盘下的1.txt文件 PrintStream ps = new PrintStream("D:\\1.txt"); //可能会出现异常，直接throws就行了 System.setOut(ps); //把创建的打印输出流赋给系统。即系统下次向 ps输出 System.out.println("看看我在哪里？"); System.out.println("=============="); System.out.println("我在D盘下的1.txt文件中去了。"); ps.close(); } } 运行结果：
2.将输出结果重新输出到屏幕 其实代码跟前面只有一点出入。
强调：
在把系统的输入方向改变时，如果还要重新回到系统默认输出的话，就一定要在改变之前保存原来系统的输出方向。
//导包 import java.io.FileNotFoundException; import java.io.PrintStream; public class Test { public static void main(String[] args) throws FileNotFoundException { // 创建一个打印输出流，输出的目标是D盘下的1.txt文件 PrintStream out = System.out; // 先保存系统默认的打印输出流缓存 //一定要先保存系统最初的打印输出，不然后面就改不回来了！！！ PrintStream ps = new PrintStream("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ac653b990465f5ca187f260f0364818/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e83cf6469057c63aee0a435b445c144/" rel="bookmark">
			python图片对比并确定_python如何对比图像的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python对比图像的区别方法：首先使用【pylab.imread】读取图片；然后使用【matplotlib.pylab - plt.imshow】显示图片；接着灰度图与RGB图相互转换；最后保存图片即可。
【相关学习推荐：python教程】
python对比图像的区别方法：
一、读取图片
pylab.imread和PIL.Image.open读入的都是RBG顺序，
而cv2.imread读入的是BGR顺序，混合使用的时候要特备注意
1 matplotlib.pylabimport pylab as plt
import numpy as np
img = plt.imread('examples.png')
print(type(img), img.dtype, np.min(img), np.max(img))
[out]
(, dtype('float32'), 0.0, 1.0) # matplotlib读取进来的图片是float，0-1
2 PIL.image.openfrom PIL import Image
import numpy as np
img = Image.open('examples.png')
print(type(img), np.min(img), np.max(img))
img = np.array(img) # 将PIL格式图片转为numpy格式
print(type(img), img.dtype, np.min(img), np.max(img))
[out]
(, 0, 255) # 注意，PIL是有自己的数据结构的，但是可以转换成numpy数组
(, dtype('uint8'), 0, 255) # 和用matplotlib读取不同，PIL和matlab相同，读进来图片和其存储在硬盘的样子是一样的，uint8，0-255
3 cv2.imreadimport cv2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e83cf6469057c63aee0a435b445c144/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efaba28e6e47aa76079ba507688fcf45/" rel="bookmark">
			python制作可视化界面_python可视化界面怎么做？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个非常简单，PyQt就可以轻松实现，一个基于Qt的接口包，可以直接拖拽控件设计UI界面，下面我简单介绍一下这个包的安装和使用，感兴趣的朋友可以自己尝试一下：
1.首先，安装PyQt模块，这个直接在cmd窗口输入命令“pip install pyqt5”就行，如下，整个模块比较大，下载过程需要等待一会儿，保持联网：
2.安装完成后，我们就可以直接打开Qt自带的Qt Designer设计师设计界面了，这里默认会安装到site-packages-&gt;PyQt5-&gt;Qt-&gt;bin目录，打开后的界面如下，可以直接新建对话框等窗口，所有的控件都可以直接拖拽，编辑属性，非常方便：
3.这里我简单的设计了一个登录窗口，2个输入框和2个按钮，如下，这里可以直接使用QSS对界面进行美化(设置styleSheet属性即可)，类似网页的CSS，如果你有一定的前端基础，那么美化起来会非常容易：
设计完成后，还只是一个ui文件，不是现成的Python代码，还需要借助pyuic5工具(也在bin目录下)才能将ui文件转化为Python代码，切换到ui文件所在目录，输入命令“pyuic5 -o login.py login.ui”即可(这里替换成你的ui文件)，转化成功后的Python代码如下(部分截图)：
还需要在最下面添加一个main函数，创建上面Ui_Form类对象显示窗口即可，如下：
最后点击运行程序，效果如下，和刚才设计的界面效果一模一样：
至此，我们就完成了利用Python的PyQt模块直接拖拽控件来设计UI界面。总的来说，整个过程非常简单，只要你有一定的Python基础，熟悉一下操作过程，很快就能掌握的，当然，还有许多其他UI开发模块，像tkinter，wxPython，Eric6等，也都非常不错，网上也有相关教程和资料，介绍的非常详细，感兴趣的话，可以搜一下，希望以上分享的内容能对你有所帮助吧，也欢迎大家评论、留言进行补充。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae94a4c69c36de02aa1a0a4764dfb5b6/" rel="bookmark">
			倾囊相授-总结非常全面到位的性能分析思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		年轻的时候，经常听一些大会或者演讲。有些人说，思路逻辑非常重要。我那时就想，你肯定是瞎忽悠的，因为我怎么就没听懂你说的思路呢？
而现在轮到自己来写或者讲一些东西的时候，才发现他们说得很对，而我之所以不理解，也是有原因的。
性能分析思路和具体的实现之间，有一道鸿沟，那就是操作的能力。之前我为什么听不懂那些人的思路，其实是因为我没有操作的功底。
而有了操作的功底之后，还有一个大的鸿沟要越过去，那就是从操作到对监控计数器的理解。这一步可以说让很多性能测试人员都望而却步了。
但是这还不算完，这一步迈过去之后，还有一个跳跃，就是相关性分析和证据链分析的过程。
如此一来，就会得到一张性能测试分析的能力阶梯视图，如下：
工具操作：包括压力工具、监控工具、剖析工具、调试工具。
数值理解：包括上面工具中所有输出的数据。
趋势分析、相关性分析、证据链分析：就是理解了工具产生的数值之后，还要把它们的逻辑关系想明白。这才是性能测试分析中最重要的一环。
最后才是调优：有了第 3 步之后，调优的方案策略就有很多种了，具体选择取决于调优成本和产生的效果。 那么怎么把这些内容都融会贯通呢？下面我们就来说说性能测试分析的几个重要环节。
应该说，从我十几年的性能工作中，上面讲的这些内容是我觉得最有价值的内容了。在今天的文章中，我们将对它做一次系统的说明。我先把性能分析思路大纲列在这里：
瓶颈的精准判断；线程递增的策略；性能衰减的过程；响应时间的拆分；构建分析决策树；场景的比对。 一、瓶颈的精准判断 TPS 曲线 对性能瓶颈做出判断是性能分析的第一步，有了问题才能分析调优。
之前有很多人在描述性能测试的过程中，说要找到性能测试中曲线上的“拐点”。我也有明确说过，大部分系统其实是没有明确的拐点的。
举例来说，TPS 的视图如下：
显然，这是一个阶梯式增加的场景，非常好。但是拐点在哪呢？有人说，显然在 1200TPS 左右的时候。也有人说了，显然是到 1500TPS 才是拐点呀。但是也有人说，这都已经能到 2000TPS 了，显然 2000TPS 是拐点。
我们再来看一下这张图对应的响应时间视图：
是不是有人要说响应时间为 4.5ms 时是拐点了？
其实这些对拐点的判断，都是不合理的。如果我们对 TPS 的增加控制得更为精准的话，那么这个 TPS 的增加是有一个有清晰的弧度，而不是有一个非常清晰的拐点。
但是至少我们可以有一个非常明确的判断，那就是瓶颈在第二个压力阶梯上已经出现了。因为响应时间增加了，TPS 增加得却没有那么多，到第三个阶梯时，显然增加的 TPS 更少了，响应时间也在不断地增加，所以，性能瓶颈在加剧，越往后就越明显。
那么我们的判断就是：
有瓶颈！
瓶颈和压力有关。
压力呈阶梯，并且增长幅度在衰减。
如果你觉得上面的瓶颈还算清晰的话，那么我们再来看一张图：
在这个 TPS 的曲线中，你还能判断出拐点在哪吗？
显然是判断不出来拐点的，但是我们根据图得出以下几个结论：
有瓶颈！
瓶颈和压力有关。
压力也是阶梯的，但是并没有明确的拐点。
我们再来看一个 TPS 图：
看到这张图，是不是明显感觉系统有瓶颈呢？那么瓶颈是不是和压力大小有关呢？
这种比较有规律的问题，显然不是压力大小的原因。为什么呢？因为 TPS 周期性地出现降低，并且最大的 TPS 也都恢复到了差不多的水位上。所以，即使是压力降低，也最多降低最大的 TPS 水位，会让问题出现得更晚一点，但是不会不出现。
综合以上，如果画一个示意图的话，TPS 的衰减过程大概会如下所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae94a4c69c36de02aa1a0a4764dfb5b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c378a5d1c209fd0f021779d5f336950/" rel="bookmark">
			vue-grid-layout实现桌面拖拽布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue-grid-layout实现拖拽布局 想实现桌面自由拖拽布局的效果，找到了vue-grid-layout栅格布局插件，可以完美解决。
初始布局，拖动可改变布局。
安装vue-grid-layout npm install vue-grid-layout --save 引入vue-grid-layout import VueGridLayout from 'vue-grid-layout' 示例 &lt;template&gt; &lt;div class="board" style="width: 100%"&gt; &lt;div class="home"&gt; &lt;grid-layout :layout="layoutData" :col-num="layoutConfig.collomn" :maxRows="layoutConfig.maxRows" :row-height="layoutConfig.rowHeight" :is-draggable="layoutConfig.dialogVisible" :is-resizable="layoutConfig.isResizeable" :is-mirrored="layoutConfig.isMirrored" :vertical-compact="layoutConfig.vertical" :margin="layoutConfig.margin" :use-css-transforms="layoutConfig. " @layout-created="layoutCreatedEvent" @layout-before-mount="layoutBeforeMountEvent" @layout-mounted="layoutMountedEvent" @layout-ready="layoutReadyEvent" @layout-updated="layoutUpdatedEvent" &gt; &lt;grid-item v-for="(item) in layoutData" :x="item.x" :y="item.y" :w="item.w" :h="item.h" :i="item.i" :key="item.i" @resize="resizeEvent" @move="moveEvent" @resized="resizedEvent" @moved="movedEvent" &gt; {{item.i}} &lt;/grid-item&gt; &lt;/grid-layout&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import VueGridLayout from 'vue-grid-layout' const GridLayout = VueGridLayout.GridLayout const GridItem = VueGridLayout.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c378a5d1c209fd0f021779d5f336950/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1f1cb41f3b1405882ce4c29328ad48f/" rel="bookmark">
			mysql查找倒数_mysql倒数十条记录怎么查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql倒数十条记录怎么查询
发布时间：2020-09-23 10:26:09
来源：亿速云
阅读：87
作者：Leah
本篇文章给大家分享的是有关mysql倒数十条记录怎么查询，小编觉得挺实用的，因此分享给大家学习，希望大家阅读完这篇文章后可以有所收获，话不多说，跟着小编一起来看看吧。
sql命令：select * from [tabale_name] order by [id] desc limit 1,10
说明：
如果你将LIMIT row_count子句与ORDER BY子句组合在一起使用的话，MySQL会在找到排序结果的第一个row_count行后立即停止排序，而不是对整个结果进行排序。
如果使用索引来完成排序，这将非常快。如果必须执行文件排序，则在找到第一个row_count行之前，选择所有与查询匹配但不包括LIMIT子句的行，并对其中大部分或所有行进行排序。
一旦找到第一个row_count之后，MySQL不会对结果集的任何剩余部分进行排序。这种行为的一种表现形式是，一个ORDER BY查询带或者不带LIMIT可能返回行的顺序是不一样的。
以上就是mysql倒数十条记录怎么查询，小编相信有部分知识点可能是我们日常工作会见到或用到的。希望你能通过这篇文章学到更多知识。更多详情敬请关注亿速云行业资讯频道。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43cba0d06f8c595724f5d5c86be91d7c/" rel="bookmark">
			1142: m行n列矩阵转置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1142: m行n列矩阵转置 题目描述
求一个N行N列的矩阵的转置矩阵。（矩阵的行换成列，列换成行。）
输入
第一行一个整数n&lt;20，表示有n组测试数据，下面是n组数据;
第二行是一个数N（2&lt;N&lt;10）
接下来N行每行有N个整数（所有数据均小于10000）。
输出
输出每组测试数据的转置矩阵；
每个数字后加一个空格，
请在每组输出之后加一个换行。
提示（每行最后一个数字后面也有一个空格）
样例输入
2
3
1 2 3
4 5 6
7 8 9
3
9 8 7
6 5 4
3 2 1
样例输出
1 4 7
2 5 8
3 6 9
9 6 3
8 5 2
7 4 1
代码如下:
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { int n,m,i,j; scanf("%d",&amp;n);//确定有几组测试数据 while(n--) { scanf("%d",&amp;m); int a[m][m],b[m][m]; for(i=0;i&lt;m;i++) { for(j=0;j&lt;m;j++) { scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43cba0d06f8c595724f5d5c86be91d7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26548559addcb09ce410772846e532d5/" rel="bookmark">
			python中seek函数_Python seek()函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		"""
注:在windows中,换行符是\r\n,为2个字符,而在linux中,换行符是\n,为1个字符
f.seek(offset,whence)
offset:偏移量,即偏移(略过)多少个字符开始读取,默认为0
whence:0--&gt;从头开始读取,1--&gt;当前位置继续读取,2--&gt;末尾开始读取
为方便显示文件换行符,尝试用notepad打开,视图--&gt;显示符号--&gt;显示所有符号
另:
当查阅不到文档时,尝试:help(obj.attribute)
"""
with open('4.缓冲区.py.txt', 'r', encoding='utf-8') as f:
# print(f.tell()) # 0
# line = f.readline()
# print(repr(line), len(line)) # 'hello world!\n' 13
# f.seek(1)
# print(f.tell()) # 1
# line = f.readline()
# print(repr(line), len(line)) # 'ello world!\n' 12
# 按理来说,一行13个字符,偏移(略过)13个后应该读取第二行内容,实际结果却是:'\n'
# 为何?hello world!共12个字符,换行符为\r\n
# 读取到\r时,被认为是一行,共13个字符
# 故偏移13个字符再次读取到的是'\n'
# windows中,应该偏移len()+1个字符才能读取到下一行内容
# f.seek(13, 0)
# print(f.tell()) # 13
# line = f.readline()
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26548559addcb09ce410772846e532d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b0312e484851c9dd8f7468b8e1c16fb/" rel="bookmark">
			[转载] python的变量和C&#43;&#43;的变量有什么区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考链接： 如何使用Python和其他语言(Java/C++/C)为变量赋值
#include &lt;iostream&gt;
using namespace std;
int main(int argc,char *argv[]){
int a = 10;
for (int i = 0; i &lt; 5; i++)
{
a = a+1;
cout &lt;&lt; &amp;a &lt;&lt; endl;
}
return 0;
}
a = 10
print("a += 1")
for i in range(5):
a += 1;
print(id(a))
print("a = a + 1")
for i in range(5):
a += 1;
print(id(a))
根据上面两段代码可知python每次赋值都是指针的迁移,原本地址的值不会改变,C++则是在原来的地址进行操作
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f575a97e32a742b9db53feff4867833/" rel="bookmark">
			python turtle详细教程_python 中的turtle使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python2.6版本中引入的一个简单的绘图工具，叫做海龟绘图(Turtle Graphics)
1.使用海龟绘图首先我们需要导入turtle，如下所示：
from turtle import * #将turtle中的所有方法导入
2.海龟绘图属性：
(1)位置
(2)方向
(3)画笔(画笔的属性，颜色、画线的宽度)
3.操纵海龟绘图有着许多的命令,这些命令可以划分为两种:一种为运动命令，一种为画笔控制命令
(1)运动命令:
forward(degree) #向前移动距离degree代表距离
backward(degree) #向后移动距离degree代表距离
right(degree) #向右移动多少度
left(degree) #向左移动多少度
goto(x,y) #将画笔移动到坐标为x,y的位置
stamp() #复制当前图形
speed(speed) #画笔绘制的速度范围[0,10]整数
(2)画笔控制命令:
down() #移动时绘制图形,缺省时也为绘制
up() #移动时不绘制图形
pensize(width) #绘制图形时的宽度
color(colorstring) #绘制图形时的颜色
fillcolor(colorstring) #绘制图形的填充颜色
fill(Ture)
fill(false)
4.关于turtle简介许多下面我们看个实例：
(一)绘制正方形：
import turtle
import time
#定义绘制时画笔的颜色
turtle.color("purple")
#定义绘制时画笔的线条的宽度
turtle.size(5)
#定义绘图的速度
turtle.speed(10)
#以0,0为起点进行绘制
turtle.goto(0,0)
#绘出正方形的四条边
for i in range(4):
turtle.forward(100)
turtle.right(90)
#画笔移动到点(-150,-120)时不绘图
turtle.up()
turtle.goto(-150,-120)
#再次定义画笔颜色
turtle.color("red")
#在(-150,-120)点上打印"Done"
turtle.write("Done")
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f575a97e32a742b9db53feff4867833/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad8e28ba708afbcc003500fa3824b4fa/" rel="bookmark">
			p51 thinkpad 拆解_ThinkPad P51自己加装内存操作图解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		把全部螺丝拧松之后，从缺口发力，分别沿着两个方向逐步拉开盖板，最终把整个盖板拆下来。
第二步：拆键盘螺丝
打开大盖板之后，还有三个键盘螺丝要拆，具体位置如图所示。图片看不清的话，注意查看螺丝附近的标记，看到是键盘标记的就拆下来就对了。这是三根长螺丝，拆下来后放在旁边。
P51有2个硬盘位，4个内存卡位(后置两个、前置两个)，后置的内存卡位和硬盘位就在图中指出的位置。
第三步：拆键盘
拆掉后面的螺丝之后，打开电脑，用指甲扣住键盘下边缘平滑的向前推动。等到键盘下方卡扣完全露出后，轻轻向上拉起，就可以取下键盘。注意不要幅度过大，键盘下方还有排线连接主板，只需要把键盘翻转过来就可以了。
第四步：拆内存盖板
翻开键盘后，可以看到一个正方形的金属盖板，这下面就是内存槽位。把图中的螺丝拧开，然后把盖板向右滑动，就可以取下这块盖板。
第五步：加装内存
拆下改版后，取出你买来的内存条，看清长短方向后插入内存槽位，然后向下压。如果能压下去就说明你安装成功，如果压不下去，请拔下来看看方向及力度，重新调整后插入直到完全安装。
第六步：重新装好
装好内存后，按照与拆机相反的顺序把笔记本重新装上就可以了，顺利的话，3-4分钟就可以完成操作。
整体来说，ThinkPad P51加装内存还是比较容易的，只要稍微细心一点就可以了。
更多ThinkPad相关信息，欢迎关注@张sir很靠谱，一起讨论交流！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adea153e82d9ebdca007d83139056f08/" rel="bookmark">
			Python教程导航
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Python 教程Python 简介Python 环境搭建Python 中文编码Python 基础语法Python 变量类型Python 运算符Python 条件语句Python 循环语句Python 数字Python 列表(List)Python 字符串Python 元组Python 字典(Dictionary)Python 日期和时间Python 函数Python 模块Python File及os模块Python文件IOPython 异常处理Python 面向对象Python正则表达式Python CGI编程python操作mysql数据库Python 网络编程Python使用SMTP发送邮件Python 多线程Python XML解析python GUI编程(Tkinter)Python2.x与3​​.x版本区别Python IDEPython JSONPython 100例Python实例教程Python3 实例教程 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28e8af36c54cddbe5980629ebd7f2249/" rel="bookmark">
			mysql建立数据库需要注意什么_创建数据库的语句是什么 MySQL数据库使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建数据库的语句是：【CREATE DATABASE [IF NOT EXISTS] [[DEFAULT] CHARACTER SET ] [[DEFAULT] COLLATE ];】。
本文操作环境：windows10系统、mysql 5.7、thinkpad t480电脑。
(学习视频分享：mysql视频教程)
详细介绍：
在 MySQL 中，可以使用 CREATE DATABASE 语句创建数据库，语法格式如下：
[ ]中的内容是可选的。语法说明如下：
：创建数据库的名称。MySQL 的数据存储区将以目录方式表示 MySQL 数据库，因此数据库名称必须符合操作系统的文件夹命名规则，不能以数字开头，尽量要有实际意义。注意在 MySQL 中不区分大小写。
IF NOT EXISTS：在创建数据库之前进行判断，只有该数据库目前尚不存在时才能执行操作。此选项可以用来避免数据库已经存在而重复创建的错误。
[DEFAULT] CHARACTER SET：指定数据库的字符集。指定字符集的目的是为了避免在数据库中存储的数据出现乱码的情况。如果在创建数据库时不指定字符集，那么就使用系统的默认字符集。
[DEFAULT] COLLATE：指定字符集的默认校对规则。
举例：
在 MySQL 中创建一个名为 test_db 的数据库。在 MySQL 命令行客户端输入 SQL 语句CREATE DATABASE test_db;即可创建一个数据库，输入的 SQL 语句与执行结果如下。
“Query OK, 1 row affected (0.12 sec);”提示中，“Query OK”表示上面的命令执行成功，“1 row affected”表示操作只影响了数据库中一行的记录，“0.12 sec”则记录了操作执行的时间。
相关推荐：mysql教程
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23ea88a196ab25e17c42cb0d172af058/" rel="bookmark">
			mysql副本集_MySQL Shell副本集和MGR快速搭建详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		####配置
#vi /etc/profilt
export PATH=/opt/idc/mysql-shell8.0.20/bin:$PATH
#Source /etc/profile
说明：
https://dev.mysql.com/doc/mysql-shell/8.0/en/mysql-shell-connections.html
备注：是不是很简单，但需要注意每个mysql版本都有对应shell版本。建议对应版本使用。shell 是跟着mysql版本进行维护的。
ReplicaSet：只能搭建主从架构
ReplicaSet：只能搭建主从架构
通过shell脚本 搭建主从
创建集群
[root@ens8 idc]# mysqlsh
MySQL Shell 8.0.20
Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.
Oracle is a registered trademark of Oracle Corporation and/or its affiliates.
Other names may be trademarks of their respective owners.
Type 'help' or '?' for help; 'quit' to exit.
MySQL JS &gt; connect root@192.168.244.129:3380
MySQL 192.168.244.129:3380 ssl JS &gt; var rs = dba.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23ea88a196ab25e17c42cb0d172af058/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c0ef7e01dd397ad14777949f5182447/" rel="bookmark">
			mysql从0开始_MySQL数据库之Mysql存储过程从0开始（上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要向大家介绍了MySQL数据库之Mysql存储过程从0开始(上) ，通过具体的内容向大家展现，希望对大家学习MySQL数据库有所帮助。
1、首先你要明白，mysql也是一种语言，他也可以编写程序，也是支持逻辑判断，if,elseif,else,switch，while等等的判断
2、mysql赋值一个变量的值操作：set @a = 1; 查看这个变量为select @a;
3、当你创建存储过程的时候你要先选择Mysql的数据库，然后才能进行操作，比如创建
(1)create procedure hanshuming() //方法体： select concat(@a,' world');
concat是链接字符串，set @a="Hello";
(2)调用是call hanshuming();
4、简单的入门的存储过程小例子
mysql &gt; DELIMITER // //首先你要转义，防止mysql把你的语句当成sql语句执行
mysql &gt; CREATE PROCEDURE proc1 --proc1存储过程名
-&gt; (IN parameter1 INTEGER)
-&gt; BEGIN
-&gt; DECLARE variable1 CHAR(10); --declare 是命名变量
-&gt; IF parameter1 = 17 THEN
-&gt; SET variable1 = 'birds';
-&gt; ELSE
-&gt; SET variable1 = 'beasts';
-&gt; END IF;
-&gt; INSERT INTO table1 VALUES (variable1);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c0ef7e01dd397ad14777949f5182447/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e74d502b70368a84f695ef0c396e8e63/" rel="bookmark">
			mysql中求闰年的函数_MS SQL判断闰年的语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们可通过如下的两种语句来判断是否为闰年：
①代码
SELECT case day(dateadd(mm, 2, dateadd(ms,-3,DATEADD(yy, DATEDIFF(yy,0,getdate()), 0)))) when 28 then ''平年'' else ''闰年'' end
②代码
select case datediff(day,datename(year,getdate())+''-02-01'',dateadd(mm,1,datename(year,getdate())+''-02-01'')) when 28 then ''平年'' else ''闰年'' end
下面再来看看case…when…end的用法：
Case具有两种格式。简单Case函数和Case搜索函数。
以上是简单Case函数的用法
CASE sex
WHEN '1' THEN '男'
WHEN '2' THEN '女'
ELSE '其他' END
--Case搜索函数
CASE WHEN sex = '1' THEN '男'
WHEN sex = '2' THEN '女'
ELSE '其他' END
这两种方式，可以实现相同的功能。简单Case函数的写法相对比较简洁，但是和Case搜索函数相比，功能方面会有些限制，比如写判断式。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bca295af83c340ebbf44e70a1c59207/" rel="bookmark">
			算法笔记：贪心算法 Kruskal生成最小树 / prim生成最小树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.kruskal #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;string.h&gt; #include &lt;string&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; # define N 1000 using namespace std; struct Graph{ int u, v, cost;	// 顶点u, v, 边的权重是cost void set(int a, int b, int w){ u = a; v = b; cost = w; } }; Graph graph[N * (N + 1) / 2];	// 顶点数n,边的数量是 &lt;= n * (n+1) / 2 void intiGraph(int m){ int i; int v, w, edge; for(i = 0;i &lt; m;i++){ cin &gt;&gt; v &gt;&gt; w &gt;&gt; edge; graph[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bca295af83c340ebbf44e70a1c59207/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a812150273423f1f875479281529d1a/" rel="bookmark">
			HAProxy
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 HAProxy简介四层调度七层调度 HAProxy安装HAproxy基本配置HAproxy配置段globalproxies 日志系统访问控制常用的leyword HAProxy简介 HAProxy可以进行伪四层调度和七层调度，注意HAProxy只支持TCP/HTTP反向代理，nginx可以支持UDP
HAProxy架构中名词和LVS也不太一样
调度器后端的真实服务器:backend server(haproxy),real server(LVS)
四层调度 七层调度 HAProxy安装 我是docker安装的一条命令搞定
docker run -d --name my-running-haproxy \ -v /etc/docker/haproxy:/usr/local/etc/haproxy:ro \ -p 20006:23306 -p 30006:33306 -p 6888:7888 \ --sysctl net.ipv4.ip_unprivileged_port_start=0 haproxy:2.3 注意
在我们-v指定本地:容器目录映射的时候本地目录必须要有haproxy.cfg这个文件不然容器就运行不起来还有就是要设置系统内核参数使其user用户也可以访问使用小于1024的端口号，因为2.4之后的haproxy容器以普通用户运行 为了测试后端的backend server我们创建2个httpd的容器
docker run -dit --name httpd1 -v /etc/docker/httpd1/html/:/usr/local/apache2/htdocs/ httpd:2.4 docker run -dit --name httpd2 -v /etc/docker/httpd2/html/:/usr/local/apache2/htdocs/ httpd:2.4 //注意/usr/local/apache2/htdocs/是httpd容器用来放置html文件的位置 haproxy没有自己的日志，其日志功能都是交给第三方日志管理，我们用rsyslog
rsyslog分为facility和priority2个概念
facility就是将日志对象分类，比如kernel，user，ftp，secure等等，其中有local0到local7是用于自定义服务的haproxy用的就是local7priority分为7个等级(越高日志越详细)
0 Emergency
1 Alert
2 Critical
3 Error
4 Warning
5 Notice
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a812150273423f1f875479281529d1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/578301b7238cf87a86bbad71954d3a6b/" rel="bookmark">
			Git Flow 分支开发工作流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		程序员微信社区 添加小编微信：372787553
分支开发工作流 现在你已经学会新建和合并分支，那么你可以或者应该用它来做些什么呢？ 在本节，我们会介绍一些常见的利用分支进行开发的工作流程。而正是由于分支管理的便捷， 才衍生出这些典型的工作模式，你可以根据项目实际情况选择一种用用看。
长期分支 因为 Git 使用简单的三方合并，所以就算在一段较长的时间内，反复把一个分支合并入另一个分支，也不是什么难事。 也就是说，在整个项目开发周期的不同阶段，你可以同时拥有多个开放的分支；你可以定期地把某些主题分支合并入其他分支中。
许多使用 Git 的开发者都喜欢使用这种方式来工作，比如只在 master 分支上保留完全稳定的代码——有可能仅仅是已经发布或即将发布的代码。 他们还有一些名为 develop 或者 next 的平行分支，被用来做后续开发或者测试稳定性——这些分支不必保持绝对稳定，但是一旦达到稳定状态，它们就可以被合并入 master 分支了。 这样，在确保这些已完成的主题分支（短期分支，比如之前的 iss53 分支）能够通过所有测试，并且不会引入更多 bug 之后，就可以合并入主干分支中，等待下一次的发布。
事实上我们刚才讨论的，是随着你的提交而不断右移的指针。 稳定分支的指针总是在提交历史中落后一大截，而前沿分支的指针往往比较靠前。
Figure 26. 趋于稳定分支的线性图
通常把他们想象成流水线（work silos）可能更好理解一点，那些经过测试考验的提交会被遴选到更加稳定的流水线上去。
Figure 27. 趋于稳定分支的流水线（“silo”）视图
你可以用这种方法维护不同层次的稳定性。 一些大型项目还有一个 proposed（建议） 或 pu: proposed updates（建议更新）分支，它可能因包含一些不成熟的内容而不能进入 next 或者 master 分支。 这么做的目的是使你的分支具有不同级别的稳定性；当它们具有一定程度的稳定性后，再把它们合并入具有更高级别稳定性的分支中。 再次强调一下，使用多个长期分支的方法并非必要，但是这么做通常很有帮助，尤其是当你在一个非常庞大或者复杂的项目中工作时。
主题分支 主题分支对任何规模的项目都适用。 主题分支是一种短期分支，它被用来实现单一特性或其相关工作。 也许你从来没有在其他的版本控制系统（VCS）上这么做过，因为在那些版本控制系统中创建和合并分支通常很费劲。 然而，在 Git 中一天之内多次创建、使用、合并、删除分支都很常见。
你已经在上一节中你创建的 iss53 和 hotfix 主题分支中看到过这种用法。 你在上一节用到的主题分支（iss53 和 hotfix 分支）中提交了一些更新，并且在它们合并入主干分支之后，你又删除了它们。 这项技术能使你快速并且完整地进行上下文切换（context-switch）——因为你的工作被分散到不同的流水线中，在不同的流水线中每个分支都仅与其目标特性相关，因此，在做代码审查之类的工作的时候就能更加容易地看出你做了哪些改动。 你可以把做出的改动在主题分支中保留几分钟、几天甚至几个月，等它们成熟之后再合并，而不用在乎它们建立的顺序或工作进度。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/578301b7238cf87a86bbad71954d3a6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/beaabdf6b1e01d770578a0d00fae2101/" rel="bookmark">
			tf::transformPose 坐标系变换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用tf::transformPose进行坐标变换时候报错：
[ERROR] [1456669076.279804500]: Lookup would require extrapolation into the future. Requested time 1456669076.279616253 but the latest data is at time 1456669076.159341977, when looking up transform from frame … 原始变换代码类似如下：
#include &lt;tf/transform_listener.h&gt; #include &lt;nav_msgs/Odometry.h&gt; #include &lt;ros/ros.h&gt; void odomCallBack(const nav_msgs::Odometry::ConstPtr&amp; odom) { // transform from "odom" to "map" tf::TransformListener listener; geometry_msgs::PoseStamped pose_odom; pose_odom.header = odom-&gt;header; pose_odom.pose = odom-&gt;pose.pose; geometry_msgs::PoseStamped pose_map; try{ // listener.waitForTransform(...); //这里省略这个书写，实际中可能会用到 listener.transformPose("map", pose_odom, pose_map); } catch( tf::TransformException ex) { ROS_WARN("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/beaabdf6b1e01d770578a0d00fae2101/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d82b672bfd294e121557b12b514f4f7a/" rel="bookmark">
			luogu P3956 [NOIP2017 普及组] 棋盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目描述 有一个m×m的棋盘，棋盘上每一个格子可能是红色、黄色或没有任何颜色的。你现在要从棋盘的最左上角走到棋盘的最右下角。
任何一个时刻，你所站在的位置必须是有颜色的（不能是无色的）， 你只能向上、 下、左、 右四个方向前进。当你从一个格子走向另一个格子时，如果两个格子的颜色相同，那你不需要花费金币；如果不同，则你需要花费 1个金币。
另外， 你可以花费 2个金币施展魔法让下一个无色格子暂时变为你指定的颜色。但这个魔法不能连续使用， 而且这个魔法的持续时间很短，也就是说，如果你使用了这个魔法，走到了这个暂时有颜色的格子上，你就不能继续使用魔法； 只有当你离开这个位置，走到一个本来就有颜色的格子上的时候，你才能继续使用这个魔法，而当你离开了这个位置（施展魔法使得变为有颜色的格子）时，这个格子恢复为无色。
现在你要从棋盘的最左上角，走到棋盘的最右下角，求花费的最少金币是多少？
输入格式 第一行包含两个正整数m, n以一个空格分开，分别代表棋盘的大小，棋盘上有颜色的格子的数量。
接下来的n行，每行三个正整数x, y, c， 分别表示坐标为(x,y)的格子有颜色c。
其中c=1代表黄色，c=0 代表红色。 相邻两个数之间用一个空格隔开。 棋盘左上角的坐标为(1,1)，右下角的坐标为(m,m)。
棋盘上其余的格子都是无色。保证棋盘的左上角，也就是(1, 1)一定是有颜色的。
输出格式 一个整数，表示花费的金币的最小值，如果无法到达，输出−1。
分析： 对于此题可以利用DFS来解决，数组mp记录棋盘，f记录从起始位置走到当前位置所需要花费的最小代价
f是一直在变化的直到变化到最小值，逐渐收敛
还需要利用magic记录当前是否可以使用魔法，魔法不可以连续使用
而利用color记录当前所处位置的颜色，也可以直接利用mp来判断颜色，但是利用mp判断颜色要注意在使用魔法离开后棋盘会恢复白色。
#include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; int n,m; int mp[1001][1001],f[1001][1001]; int dx[]={1,-1,0,0}; int dy[]={0,0,1,-1}; void dfs(int x,int y,int s,int magic,int col){ if(f[x][y]&lt;=s) return; f[x][y]=s; for(int i=0;i&lt;4;i++){ int nx=x+dx[i],ny =y+dy[i]; if(nx&lt;1||nx&gt;n||ny&lt;1||ny&gt;n) continue; if(col==mp[nx][ny]) dfs(nx,ny,s,1,col); else{ if(!mp[nx][ny]){ if(magic) dfs(nx,ny,s+2,0,col); }else dfs(nx,ny,s+1,1,mp[nx][ny]); } } } int main(){ cin&gt;&gt;n&gt;&gt;m; while(m--){ int x,y,c; cin&gt;&gt;x&gt;&gt;y&gt;&gt;c; mp[x][y]=c+1; } for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) f[i][j]=1e7; dfs(1,1,0,1,mp[1][1]); if(f[n][n]==1e7) cout&lt;&lt;-1&lt;&lt;endl; else cout&lt;&lt;f[n][n]&lt;&lt;endl; return 0;	} 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a01f3a68a2e09efeadbf63c70565a527/" rel="bookmark">
			【C语言】将一个字符串插入至另一个源字符串的某个位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 将一个字符串插入至另一个源字符串的某个位置
程序源码 #include &lt;stdio.h&gt; #include &lt;string.h&gt; char *insert(char *s1, char *s2, int n); int main(void) { char s1[50]; char s2[50]; int n; char *newstr; printf("请输入第一个字符串："); scanf("%s", s1); printf("请输入第二个字符串："); scanf("%s", s2); printf("请输入插入的位置："); scanf("%d", &amp;n); newstr = insert(s1, s2, n); printf("%s\n", newstr); getchar(); return 0; } char *insert(char *s1, char *s2, int n) { int len1 = 0, len2 = 0, i, j = 0, k = 0; char s3[50]; if (s1 == NULL) return NULL; if (s2 == NULL) return s1; len1 = strlen(s1); if(n &gt; len1) return NULL; len2 = strlen(s2); for ( i = 0; i &lt; n; i++) j++; for ( i = 0; i &lt; len1; i++) s3[k++] = s1[i]; for ( i = 0; i &lt; len2; i++) s1[j++] = s2[i]; for( i = n; i &lt; len1; i++) s1[j++] = s3[i]; s1[j] = '\0'; return s1; } 运行结果 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ac5ba444385cb6becc256b27a517b62/" rel="bookmark">
			Windows平台三大软件开发工具Delphi、WPF .NET Framework和Electron开发对比综述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Embarcadero委托白皮书研究了Delphi，WPF .NET Framework和Electron之间用于构建Windows桌面应用程序的区别。由三个Delphi最有价值专家（MVP）志愿者，一名WPF专业开发人员和一名Electron自由开发人员在每个框架中重新创建了基准应用程序– Windows 10 Calculator计算器克隆。在此博客文章中，我们将探讨长期可行性指标，该指标是白皮书中使用的功能比较的一部分。
计算器软件 长期可行性 当企业选择Delphi作为其开发框架时，他们将投资具有专有成本（包括运行时库源代码）的专有框架，该框架具有前期成本和可选的年度更新费用。以此为代价，他们获得了稳定，向后兼容且不断发展的框架，并且可以确信今天开发的应用程序将在将来得到支持和可维护。
带有.NET Framework的Windows Presentation Foundation在Microsoft的全力支持下为企业提供了一个经济的框架，但包括了Microsoft选择带来的所有挑战。WPF的历史比Delphi短，但是它于2018年开源，尽管它与大多数Windows开发的专有.NET Framework有联系，但它的某些版本可能具有光明的长期前景。微软表示，.NET Framework 4.8是2019年4月18日的最后版本。
Electron是一个免费的开源平台，为企业提供了从任何主要操作系统开发应用程序的机会。然而，Electron的未来发展还不确定。Electron项目由GitHub运行，而GitHub现在是Microsoft的子公司。它是三个框架中的最新框架，仍处于初始阶段。它缺少本机IDE，为企业提供了选择的余地，但也消除了一些便利，例如集成编译和包含测试库。与其他框架相比，使用Electron开发内部工具的企业将度过更艰难的学习曲线。
让我们看一下每个框架。
Delphi 自1995年以来，Delphi就一直在成长，成熟和扩展。它的发展保持了向后兼容性，以至于可以将1995年的应用程序移植到当前的Delphi版本中，而无需进行任何改动。全面的文档帮助维护，并且完整的支持团队可提供升级，迁移或故障排除帮助。在撰写本文时，最新版本的Delphi已在2020年9月2日发布的RAD Studio 10.4.1 Sydney中提供。想要了解更多信息吗？查看许多Delphi版本的发行说明。
对于编程语言时间轴的某些情况，C ++于1983年问世，Python于1991年问世，Java于1995年问世，PHP于1995年问世，JavaScript于1995年问世，Delphi于1995年问世。1995年是诞生之年。如您所见，其中有很多这些编程语言。Delphi Anniversary网站包含1995年至今的Delphi发布时间表。这是过去25年发行时间表的摘录。
DELPHI 1 – 1995年2月14日
16位Windows 3.1支持，Visual Two-Way工具，组件/ VCL，通过BDE和SQL链接支持数据库，在设计时实时运行数据库数据
DELPHI 2（1996）
32位Windows 95支持，数据库网格，OLE自动化，可视窗体表单继承，长字符串，随附的16位Delphi 1
DELPHI 3（1997）
接口（基于COM），代码洞察，组件模板，DLL调试，WebBroker，ActiveForm，组件包，MIDAS多层体系结构
DELPHI 4（1998）
对接，锚定和约束，方法重载，动态数组，Windows 98支持 DELPHI 5（1999）
桌面布局，框架，XML支持，DBGo for ADO，语言翻译 DELPHI 6（2001）
结构窗口，SOAP Web服务，dbExpress，BizSnap，WebSnap，DataSnap DELPHI 7（2002）
Web应用程序开发，Windows XP主题 DELPHI 8（2003）
.NET支持 DELPHI 2005（2004）
多单元名称空间，Error Insight，“历史记录”选项卡，用于..in，函数内联，启用主题的IDE，重构，使用中的通配符语句，数据浏览器，集成单元测试 DELPHI 2006（2005）
操作符重载，静态方法和属性，设计器准则，窗体定位器视图，实时代码模板，块完成，行号，更改栏，同步编辑，代码折叠和方法导航，调试工具提示，可搜索工具面板，FastMM内存管理器，对MySQL的支持，dbExpress，TTrayIcon，TFlowPanel，TGridPanel中的Unicode支持
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ac5ba444385cb6becc256b27a517b62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8c3c999b847edf585c5e8e551726acb/" rel="bookmark">
			Android设备通过fastboot刷入TWRP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android设备通过fastboot刷入TWRP 方法一：通过fastboot刷入TWRP的方式
首先去TWRP官网下载TWRP安装文件https://twrp.me/Devices/
1.进入bootloader
adb reboot bootloader
也可在开机时，同时按住电源键+音量减，进入bootloader (不同的手机进入方式稍微有所差别)
2.输入以下指令
fastboot devices -l
若出来一串序列号，说明安卓设备已连接
3,解锁bootloader
如果你的设备已经锁定bootloader，首先需要解锁才可刷机（某些厂商还需要申请解锁码才可以）
2015和以后的设备: $ fastboot flashing unlock
2014以前的设备: $ fastboot oem unlock
4.刷入TWRP
fastboot flash recovery twrp-3.0.2-0-hammerhead.img
fastboot reboot
至此，TWRP安装成功，重启后敲入以下命令进入recovery看TWRP 的强大风采吧！
adb reboot recovery
方法二：已Root手机可通过TWRP官方应用TWRP Manager的方式安装
下载TWRP Manager.apk后安装，首先授予Root权限，然后选择自己设备后会自动下载相应刷机包，根据提示进行操作即可
原文地址：https://my.oschina.net/robslove/blog/2876303
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/407bf2162c4fd7df2d14b8a29ca652f4/" rel="bookmark">
			【LeetCode】C&#43;&#43; ：简单题 - 字符串 1694. 重新格式化电话号码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1694. 重新格式化电话号码
难度简单6
给你一个字符串形式的电话号码 number 。number 由数字、空格 ' '、和破折号 '-' 组成。
请你按下述方式重新格式化电话号码。
首先，删除 所有的空格和破折号。其次，将数组从左到右 每 3 个一组 分块，直到 剩下 4 个或更少数字。剩下的数字将按下述规定再分块： 2 个数字：单个含 2 个数字的块。3 个数字：单个含 3 个数字的块。4 个数字：两个分别含 2 个数字的块。 最后用破折号将这些块连接起来。注意，重新格式化过程中 不应该 生成仅含 1 个数字的块，并且 最多 生成两个含 2 个数字的块。
返回格式化后的电话号码。
示例 1：
输入：number = "1-23-45 6" 输出："123-456" 解释：数字是 "123456" 步骤 1：共有超过 4 个数字，所以先取 3 个数字分为一组。第 1 个块是 "123" 。 步骤 2：剩下 3 个数字，将它们放入单个含 3 个数字的块。第 2 个块是 "456" 。 连接这些块后得到 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/407bf2162c4fd7df2d14b8a29ca652f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ac048d7ca22a878a18dc5826d62f9e7/" rel="bookmark">
			docker 改host_Docker容器修改端口映射
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于已经建立的docker容器，需要新增容器对主机的端口映射，主要分为三种：
一：通过修改配置文件修改docker容器端口映射
1.使用docker ps -a命令找到要修改容器的CONTAINER ID
2.运行以下命令，进入该容器目录
docker inspect【CONTAINER ID】| grep Id
cd /var/lib/docker/containers
2.停止容器
docker stop [容器id]
3.停止主机docker服务
systemctl stop docker
4.进入2得到的文件夹内，修改hostconfig.json 和 config.v2.json
vi hostconfig.json
比如新增一个 80 端口，在PortBindings下边添加以下内容，端口配置之间用英文字符逗号隔开
"80/tcp": [
{
"HostIp": "0.0.0.0",
"HostPort": "80"
}
]
接着修改vi config.v2.json, 找到ExposedPorts和Ports 仿照之前内容添加端口映射
"ExposedPorts": {
"2000/tcp": {}
},
"Ports":{
"2000/tcp":[
{
"HostIp": "0.0.0.0",
"HostPort": "2000"
}
]
},
5.保存之后重启docker服务和容器
systemctl start docker
docker start [docker id]
二：把运行中的容器生成新的镜像，再新建容器
1.提交一个运行中的容器为镜像
docker commit [containerid] [new_imagename]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ac048d7ca22a878a18dc5826d62f9e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/876eb759a3da2bdd8efefa064bddf4e7/" rel="bookmark">
			关于Pyqt中designer.exe的文件位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于Pyqt中designer.exe的文件位置 前言正文 前言 新接触该模块，相关该模块的部分文章中提到designer.exe的文件夹位置大多都找不到，可能原因是版本更新。现提供该文件的位置。
正文 这是我电脑的目录，具体位置因个人而异。基本上都在自己python环境下Lib文件夹中。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b14599df4b4e95cbcdb39c1fb0d859e/" rel="bookmark">
			Shell字符串与数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Shell字符串 一、字符串设置 字符串可不用引号，也可用单引号和双引号
单引号特点 单引号中的变量无效(单引号内嵌套的一对单引号，可以包含变量)单引号中不能出现单个单引号，但可以出现成对的单引号作为字符拼接使用 双引号特点 双引号内的变量有效双引号内可以使用转义字符 a=cindy b="hello,$a" c="hello,"$a"" d='hello,'$a'' e='hello,$a' f="hello,'$a'" g='hello,"$a"' h="hello,\"$a\"" #双引号内用转义符\ echo $b! $c! $d! $e! $f! $g! $h! hello,cindy! hello,cindy! hello,cindy! hello,$a! hello,'cindy'! hello,"$a"! hello,"cindy"! 二、字符长度 echo ${#变量名}
a=cindy echo ${#a} 5 #输出变量a的字符长度为5 三、截取字符串 echo ${变量名:起始位置:截取长度}
a=cindy echo ${a:1:2} in #输出第二个字符开始的2个字符 四、获取子字符串 echo `expr index “$变量名” n`
a=cindy echo `expr index "$a" n` 3 #输出n在cindy中的第三个位置 Shell数组 shell的数组元素以空格分开，数组大小无限制，只支持单维数组
一、数组定义： 整体定义：arrayname=(value1 value2 … valuen)单元素定义(下标可不连续，没有定义的下标对应元素默认为空)：
arrayname[0]=value1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b14599df4b4e95cbcdb39c1fb0d859e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/914dfdfc885327210649c9f4f693d8ae/" rel="bookmark">
			计算1！&#43;2！&#43;. . . &#43;10！的值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算1！+2！+. . . +10！的值 #include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int main()
{
int n = 0;
int ret = 1;
int sum = 0;
for (n = 1; n &lt;= 10; n++)
{
ret = ret*n;
sum = sum + ret; } printf("sum=%d\n ", sum); system(“pause”);
return 0;
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20861f14e212202156c0c280397757dd/" rel="bookmark">
			std::function的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍： std::function是一个可调用对象包装器，是一个类模板，可以容纳所有可调用对象，它可以用统一的方式处理函数、函数对象、函数指针，并允许保存和延迟它们的执行。
头文件：#include &lt;functional&gt;
定义格式： std::function&lt;函数类型&gt;
因为std::function是一种模板，所以要传入类型，将其当做std::vector&lt;&gt;这样的模板， 像std::vector&lt;int&gt;传入类型int一样，std::function传入的是函数类型&lt;返回值 （参数类型）&gt;，如：std::function&lt;void (int)&gt;。
作用： std::function可以取代函数指针的作用，因为它可以延迟函数的执行，特别适合作为回调函数使用。它比普通函数指针更加的灵活和便利。
代码示例：
1、普通函数：
void func1(int val1,int val2) { cout &lt;&lt; "func1:" &lt;&lt; val1 + val2 &lt;&lt; endl; } int main() { function&lt;void(int val1,int val2)&gt; funcPtr = nullptr; funcPtr = func1; funcPtr(1,2); getchar(); return 0; } 2、模板函数：
T g_Add(T i, T j) { cout &lt;&lt; i + j; return i + j; } std::function&lt;int(int,int)&gt; f = nullptr; f = g_Add&lt;int&gt;; f(1,3); 3、匿名函数：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20861f14e212202156c0c280397757dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59b40f412b565322ac229484b3bcef3d/" rel="bookmark">
			Evo评测工具对VIORBSLAM2进行评估（详细步骤!!!）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VIORBSLAM实在orbslam2的基础上进行改进的，使用单目相机和IMU进行状态估计。由于 VI ORB SLAM2 并没有官方的版本，我们主要使用王京实现的一个版本（https://github.com/jingpang/LearnVIORB）作为基础更改来进行测试。
王京的版本实在ROS下运行的。 由于EuRoC 测试集有 VIO 的数据，我使用了 EuRoC 测试集进行测试。
在测试前需要对王京的代码进行修改：
一、修改 System 保存 TUM 观测值：
我们修改一下创建一个新的函数 SaveTrajectory 用来保存单目 VIO 数据，其实原来的 SaveKeyFrameTrajectoryNavState的函数保存的轨迹txt格式文件是16列，和tum文件不一致，tum文件是8列，包括(time, t x , t y , t z , q x , q y , q z , q w )，所以其实可以默认输出原来的16列txt文件在进行裁剪（裁剪用到的指令为
cut --delimiter " " --fields 1-8 KeyFrameNavStateTrajectory.txt &gt; clean.tum 其中 KeyFrameNavStateTrajectory.txt为 SaveKeyFrameTrajectoryNavState的函数保存的轨迹txt格式文件，clean.tum是裁剪后的tum文件是8列。
）。
我们为了避免每次都要运行上述裁剪命令，所以我们创建一个新的函数 SaveTrajectory 用来保存成tum文件是8列包括(time, t x , t y , t z , q x , q y , q z , q w )。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59b40f412b565322ac229484b3bcef3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5da641847f799619b640e6b0e8062ed4/" rel="bookmark">
			centos7安装 rabbitmq-server
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装rabbitmq-server 1、下载rabbtmq-server2、安装erl重新安装erl3、安装rabbitmq-server并启动4、安装web管理插件5、管控台权限控制 还是要练习看第一手资料，国内的很多博客文档写的一塌糊涂。相对自己在官网上查看，虽然开始慢一点，但是成功率相对看国内博客要高得多。
yum安装rabbitmq-server需要手动安装几个包：
//erl、socat、logrotate yum -y install socat 1、下载rabbtmq-server 第一次使用rabbitmq，所以需要先安装server。
1、官方文档：https://www.rabbitmq.com/
官网首页宣称：RabbitMQ is the most widely deployed open source message broker.（吹吹牛B不犯法）。
安装最新版（3.8.11稳定版，不要用beta），找到The Latest Release。https://github.com/rabbitmq/rabbitmq-server/releases
注意：
This release no longer supports Erlang 21.3. Erlang 21.3 is no longer supported.22.3 or 23.2 releases are recommended. 2、下载页：https://www.rabbitmq.com/download.html ，rabbitmq-server包通过rpm管理
https://www.rabbitmq.com/install-rpm.html#downloads 选择阿里云对应的系统版本
wget https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.8.11/rabbitmq-server-3.8.11-1.el7.noarch.rpm 2、安装erl 1、rabbitmq是erlang语言写的，所以要先安装环境。有三种安装方式，我们选择一种rabbitmq提供的方案
Before installing RabbitMQ, you must install a supported version of Erlang/OTP. There are three commonly used sources for Erlang packages on RPM-based distributions.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5da641847f799619b640e6b0e8062ed4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5f89e993f3ef144a2e96d429a694c8d/" rel="bookmark">
			【GNSS】GNSS数据下载工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GNSS数据下载工具 ​ 该脚本为武汉大学测绘学院李星星教授开源的linux端GNSS数据下载脚本，脚本为perl语言编写，可支持下载rinexo，rinexn，rinexc，snx等常用格式的GNSS数据，支持常用mgex机构切换。
原地址为 http://igmas.users.sgg.whu.edu.cn/group/tool/4
网站还有其他有用的小工具，感兴趣的可以去看一下。
【所属分类】：perl脚本
【开发工具】：perl
【文件大小】：13KB
【使用说明】：使用前需要注册cddis账号，并将账号密码写.netrc文件放在用户根目录下
文件格式如下：machine urs.earthdata.nasa.gov login username password password
【使用示例】：
# 可下载的文件种类如下： -obs daily daily_v2 daily_v3 hourly hourly_v2 hourly_v3 -nav brdc hourly daily -dcb cas code (dlr not supported now) -snx igs -orb gfz wum grg cod igs -clk gfz wum grg cod igs -eop all daily gpsrapid -slr all 代码 #!/usr/bin/perl ## # Usage : IGS/MGEX data/products downloading # Created : Yuan Yongqiang, 2020/10/24 # Updated : Yuan Yongqiang, 2020/10/25, adding EOP and PRODUCTS downloading # # -obs daily daily_v2 daily_v3 hourly hourly_v2 hourly_v3 # -nav brdc hourly daily # -dcb cas code (dlr not supported now) # -snx igs # -orb gfz wum grg cod igs # -clk gfz wum grg cod igs # -eop all daily gpsrapid # -slr all # ## 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5f89e993f3ef144a2e96d429a694c8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5f36394170fc90eefac581c5701a45a/" rel="bookmark">
			树莓派4B/400/3B&#43;等等 的USB大容量存储启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		仅在Raspberry Pi 2B v1.2、3A +，3B，3B +，4B，400，计算模块3，计算模块3+和计算模块4上可用。
本页说明如何从USB大容量存储设备（如闪存驱动器或USB硬盘）引导Raspberry Pi。连接USB设备（尤其是硬盘和SSD）时，请注意其电源要求。如果您希望在Pi上连接多个SSD或硬盘，则通常需要外部电源-有源硬盘盒或有源USB集线器。请注意，Pi 4B之前的型号存在已知问题，无法使用某些USB设备引导。
树莓派400 要从USB大容量存储设备启动Pi 400，只需使用Raspberry Pi Imager实用程序使用Raspberry Pi OS 2020-08-20或更高版本对USB驱动器进行映像：从SD CardRaspberry Pi Imager的列表中选择USB驱动器。
树莓派4B 根据Raspberry Pi 4B的制造时间，可能需要更新Bootloader EEPROM才能从USB大容量存储设备启动。
检查您的Pi 4B是否具有所需的Bootloader EEPROM版本
要检查您的Pi 4B是否具有所需的Bootloader EEPROM版本，请在未插入SD卡且显示器连接至HDMI端口之一的情况下打开电源。Pi 4B将在随附的显示器上显示诊断屏幕，该诊断屏幕的顶部包括引导加载程序的EEPROM版本。引导加载程序必须标有日期Sep 3 2020或更高版本才能支持USB大容量存储引导。如果诊断屏幕报告的日期早于Sep 3 2020，或者没有显示诊断屏幕，则需要首先更新Bootloader EEPROM以启用USB大容量存储引导。
要在Pi 4B上启动USB大容量存储，需要使用Raspberry Pi OS 2020-08-20或更高版本。
通过更新引导加载程序EEPROM在Pi 4B上启用USB大容量存储引导
如果您的Pi 4B需要更新的引导程序EEPROM以支持USB大容量存储引导，则可以执行以下更新：
使用Raspberry Pi Imager中的“其他实用程序映像”选项来创建具有最新“ Raspberry Pi 4 EEPROM引导恢复”映像的SD卡。
使用此SD卡引导Pi 4B。
引导加载程序EEPROM将更新为最新的出厂版本，然后Pi将快速闪烁其绿色ACT灯，并在HDMI输出上显示绿色，以指示成功。
Pi 4B现在可以从USB大容量存储设备启动。
更改Pi 4B和Pi 400的启动顺序
该raspi-配置实用程序可用于SD / USB（默认）或SD /网络引导模式之间进行选择。
完整的引导模式选项集记录在引导加载程序配置页面上。
树莓派3B + Raspberry Pi 3B +支持开箱即用的USB海量存储启动。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5f36394170fc90eefac581c5701a45a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63dbdfeed81e7875b3dc0f99b4524da7/" rel="bookmark">
			如何制作网站的入门教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、设计网站样式并切图。根据网站的功能需求，用Photoshop软件将网站样式设计出来，并将其中涉及到的图标等进行切图，用于后续的网站页面开发。参考文章：http://www.xdy666.com/
2、编写网站样式。编写网站样式需要用到html、css、js知识，缺一不可，通过三种语言用代码编写出网站样式。
3、创建数据库。大部分网站需要进行数据交互，所以需要学习数据库的相关知识，包括sql语言编写方式及数据库管理工具。
4、实现网站交互逻辑。网站交互逻辑一般运用PHP语言，将网站与数据库数据交互编写出来。
5、购买服务器及IP。为了能够将网站部署在服务器中，需要购买服务器、IP。
6、将网站部署到服务器中。购买服务器后，可通过客服交接项目部署的步骤，将网站部署到服务器中，这样就成功地制作出一个网站了。
相关文章：http://www.jieba8.com/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d2b2233640befbf03d2654fc652730c/" rel="bookmark">
			RocketMQTemplate 注入失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在使用rocketmq 发送消息时，会发现
@Autowired private RocketMQTemplate rocketMQTemplate; 注入RocketMQTemplate 失败。
究其原因是因为,配置文件中，我们没有添加
上图中蓝色的两行代码，指定发送的组名。写上后，问题解决。
这辈子坚持与不坚持都不可怕，怕的是独自走在坚持的道路上！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97fbda3b0b84e20522c05a8ea6dc2af9/" rel="bookmark">
			Caused by: org.springframework.messaging.MessagingException: No route info of this topic: queue_test
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在使用rocketmq消息中间件发送消息的时候,会出现标题这种错误。
其实意思很明显,就是提示我们中间件中不存在queue_test这个topic。
所以我们应该先创建这个topic。
我们可以使用这种可视化工具
先添加queue_test这个topic,发现在进行发送消息时,就不会发生这个异常。
这辈子坚持与不坚持都不可怕,怕的是独自走在坚持的道路上。。。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e31e5fda3376ebaeb9cea196a27457c/" rel="bookmark">
			负数转换二进制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		负数转换二进制 对于负数转二进制，我们把它分三步：
（举例 ‘ -9 ’ ）
1） 先把正数二进制表示出来。1001
2） 取反。0110
3）在取反的基础 +1。0111
所以 -9的二进制是 ：0111。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2b93c7e912f42fb9fb3633faff39351/" rel="bookmark">
			idea中Project JDK is not defind的其中之一解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看了很多解决办法发之后都没有解决。。。
然后仔细检查project后发现，原本在Day0129项目下创建的work模块。
打开时直接打开的work模块，关掉项目后重新打开正确的项目之后就好了。
以下是错误是的截图。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/375cda61a5b529226bd932400f93efc5/" rel="bookmark">
			[管理员手册]（三）Ubuntu server 20.04网卡驱动安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		裸机没有网络，USB连接Android手机，Android手机共享网络
网卡状态
1）系统安装后不能直接上网，首先需要查看网线是否连到主板对应的端口上，服务器主板（supermicro X10DRi）有三个LAN端口，分别是主板固件内置的Dedicated LAN和Intel® i350 Dual port GbE LAN。
2）利用sudo lshw -C network命令查询网卡状态，其中
UNCLAIMED 是系统不识别，没有安装驱动
DISABLED是安装驱动但是网线没查或者没有配置
其他为正常
[1] Ubuntu Server 20.04 no internet connection/network unclaimed https://askubuntu.com/questions/1270046/ubuntu-server-20-04-no-internet-connection-network-unclaimed
[2] Can't get RTL8125B working on 20.04https://askubuntu.com/questions/1259947/cant-get-rtl8125b-working-on-20-04
驱动更新
1）显示所有网卡#ifconfig –a
2）查看网卡所需驱动#ethtool -i enp4s0f0 (enp4s0f0本网卡名称) 注：intel I350网卡 为igb 驱动程序。
3）到intel官网下载网卡驱动
4)安装ReadMe文件中提示进行编译安装
[1] intel I350 网卡驱动安装方法http://blog.chinaunix.net/uid-31410005-id-5780988.html
[2]适用于 Linux * 的82575/6、82580、I350 和 I210-at/211 千兆位网络连接的英特尔®网络适配器驱动程序https://downloadcenter.intel.com/zh-cn/download/13663/Intel-Network-Adapter-Driver-for-82575-6-82580-I350-and-I210-211-Based-Gigabit-Network-Connections-for-Linux-
网络配置
通过sudo vi /etc/netplan/01-network-manager-all.yaml 来设置静态或者动态IP
network:
version: 2
renderer: NetworkManager
ethernets:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/375cda61a5b529226bd932400f93efc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c66997ba41c2dfc55970d8c35bfe212f/" rel="bookmark">
			win10电脑发现不了华为share_电脑发现不了华为分享？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		展开全部
与电脑系636f70793231313335323631343130323136353331333433633436统有关系！
自 Windows 10 1709版本起，若用户 15 天未使用 SMB1 协议，则将自动卸载 SMB1 客户端(您可以在“设置”&gt;“系统”&gt;“关于”中确认Windows的具体版本)。由于 Huawei Share 采用 SMB1 协议作为文件共享协议，Windows侧卸载 SMB1 客户端后，电脑将无法通过 Huawei Share 发现、连接手机。若您使用的是 Windows 10 电脑，请前往“控制面板”&gt;“程序”，在“程序和功能”目录下点击“启用或关闭 Windows 功能”，确保已勾选“SMB 1.0/CIFS 客户端”。若您使用 Windows XP 系统的电脑，或者曾修改过电脑工作组设置，请前往“控制面板”&gt;“系统” &gt;“计算机名”(Windows XP) 或 “控制面板”&gt;“系统和安全” &gt;“查看该计算机的名称”&gt;“更改设置”(Windows 10)点击“更改”，将工作组名称修改为“WORKGROUP”，并按照电脑上的指引重启电脑，再重试本功能。请前往“此电脑”(Windows 10) (或“计算机”(Windows 7) &gt;“网络”如果出现提示“文件共享已关闭，看不到网络计算机和设备”，则点击点击屏幕上方的提示条。在弹出的扩展菜单中，选择“启用文件共享和网络发现”项，刷新后重试。您使用的Wi-Fi (尤其是部分公共网络) 可能打开了“AP隔离”功能，这会限制同网络内设备的互相访问。您可以尝试在路由器设置中关闭“AP隔离”功能。
供参考！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/168d3a3005ff7963a90cdca22fd051e0/" rel="bookmark">
			w10投影全屏设置_教你win10连接投影仪显示比例不正常的解决教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在升级win10之后，尤其是目前的高分辨率电脑，经常会遇到用投影仪投影或者连接第二个屏幕的时候出现无法识别分辨率，或投影出来的头像比例被拉扯或压缩的现象。今天小编整理了win10连接投影仪显示比例不正常的解决教程，现分享给大家。
最近有用户反馈，升级windows10系统后，连接投影仪使用，发现显示比例不正常的问题，不知如何解决，其实这是高分辨率电脑无法识别分辨率投影仪的问题，小编整理了二种解决方法，有需要的用户，请来看看win10连接投影仪显示比例不正常的解决教程吧。
投影仪显示比例：
方法一：
很简单，win+P，打开投影显示设置
选择模式为拓展这样子第二屏幕或者投影仪会自动适配分辨率参数，可以完成投影
方法二：#f#
在电脑桌面，右键--显示设置--显示适配器属性
在弹出的窗口中，选择适配器目录下列出所有模式
在跳出的列出所有模式窗口的有效模式列表中选择合适你投影仪或者显示器的模式，一般的投影器1024X768基本可以解决。当然，你可以尝试其他参数直到适合为止。
以上便是win10连接投影仪显示比例不正常的解决教程介绍了，需要的小伙伴赶紧动手试试看吧，希望可以帮助到你。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c61c28aa6715af09c3f17590b25ba91/" rel="bookmark">
			sql转python_编写Python脚本把sqlAlchemy对象转换成dict的教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在用sqlAlchemy写web应用的时候，经常会用json进行通信，跟json最接近的对象就是dict，有时候操作dict也会比操作ORM对象更为方便，毕竟不用管数据库session的状态了。
假设数据库里有一张post表，其中一种方法就是
p = session.query(Post).first()
p.__dict__
但由于p是sqlAlchemy的对象，所以p.__dict__中会有一些其他的属性比如_sa_instance这种我们不需要关注的
那么我们可以给model的基类加一个方法，假设models.py中原来是这样
Base = sqlalchemy.ext.declarative.declarative_base()
class Post(Base):
__tablename__ = 'post'
id = Column(Integer, primary_key=True)
title = Column(String)
那么我们可以加一个to_dict()方法到Base类中
def to_dict(self):
return {c.name: getattr(self, c.name, None) for c in self.__table__.columns}
Base.to_dict = to_dict
这样就可以
p = session.query(Post).first()
p.to_dict()
当然，如果model没有和table绑定的话model里是没有__table__的信息的，可能也会出问题，不过我目前觉得这样最方便了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3565696cc258774f76d8893c559289b6/" rel="bookmark">
			sql是什么mysql是什么_sql是什么意思
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sql全称是结构化查询语言，即Structured Query Language，是一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统，同时也是数据库脚本文件的扩展名。
SQL是高级的非过程化编程语言，允许用户在高层数据结构上工作。它不要求用户指定对数据的存放方法，也不需要用户了解具体的数据存放方式，所以具有完全不同底层结构的不同数据库系统, 可以使用相同的结构化查询语言作为数据输入与管理的接口。结构化查询语言语句可以嵌套，这使它具有极大的灵活性和强大的功能。
结构化查询语言SQL包含6个部分：
1、数据查询语言(DQL:Data Query Language)：
其语句，也称为“数据检索语句”，用以从表中获得数据，确定数据怎样在应用程序给出。保留字SELECT是DQL(也是所有SQL)用得最多的动词，其他DQL常用的保留字有WHERE，ORDER BY，GROUP BY和HAVING。这些DQL保留字常与其他类型的SQL语句一起使用。
2、数据操作语言(DML：Data Manipulation Language)：
其语句包括动词INSERT，UPDATE和DELETE。它们分别用于添加，修改和删除表中的行。也称为动作查询语言。
3、事务处理语言(TPL)：
它的语句能确保被DML语句影响的表的所有行及时得以更新。TPL语句包括BEGIN TRANSACTION，COMMIT和ROLLBACK。
4、数据控制语言(DCL)：
它的语句通过GRANT或REVOKE获得许可，确定单个用户和用户组对数据库对象的访问。某些RDBMS可用GRANT或REVOKE控制对表单个列的访问。
5、数据定义语言(DDL)：
其语句包括动词CREATE和DROP。在数据库中创建新表或删除表(CREAT TABLE 或 DROP TABLE)；为表加入索引等。DDL包括许多与人数据库目录中获得数据有关的保留字。它也是动作查询的一部分。
6、指针控制语言(CCL)：
它的语句，像DECLARE CURSOR，FETCH INTO和UPDATE WHERE CURRENT用于对一个或多个表单独行的操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f566deec5f3750d0d907f925c638b229/" rel="bookmark">
			slam特征点深度 svd_（七）ORBSLAM特征点的三角化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ORBSLAM2特征点三角化简介
插入关键帧以后，我们还需要插入新的地图点。为了确保新插入的地图点是足够鲁棒的，进行严格的检查是必要的。ORBSLAM2在插入地图点的时候也十分仔细，上一讲我们提到了地图的更新策略，唯独三角化没有细讲，倒不是因为它不重要而不提，而是因为三言两语说不清楚，所以才需要单独用一讲来说说这个方法。
接下来，笔者将会从一下两个方面来介绍本讲的内容：
1. 线性三角化方法；
2. 创建新地图点的方法提纲；
线性三角化方法
同之前一样，笔者会介绍创建新地图点所必要的技术细节，然后再讲方法提纲。
在ORBSLAM2源码中，创建新的地图点采用的是线性三角化方法，当然有些点并不是用这个方法创建的，但是这一小节我们不提，留到方法提纲那一节再介绍。
OK，我们就直接进入主题吧。
ORBSLAM2采用的是针孔模型的相机，而不是鱼眼或者事件相机之类的。因此这类相机的投影模型，大家应该都是比较熟悉的。笔者就不赘述了。
假设三维空间点为 $P_{w} = [ X, Y, Z, 1 ]^{T}$，参考帧的相机位姿为 $T_{rw} = [ R_{rw} | t_{rw} ]$，表示从世界坐标系变换到参考帧坐标系，同理，当前帧的相机位姿为 $T_{cw} = [ R_{cw} | t_{cw} ]$。点 $P_{w}$ 在参考帧归一化平面里的位置为 $p_{r} = [ x_{r}/z_{r}, y_{r}/z_{r}, 1 ]^{T}$，深度为 $z_{r}$，在当前帧归一化平面里的位置为 $p_{c} = [ x_{c}/z_{c}, y_{c}/z_{c}, 1 ]^{T}$，深度为 $z_{c}$。根据位置变换关系有：
\begin{equation}
z_{r}p_{r} = T_{rw}P_{w}
\end{equation}
\begin{equation}
z_{c}p_{c} = T_{cw}P_{w}
\end{equation}
对公式 $(1)$ 和公式 $(2)$ 分别叉乘对应的归一化平面的点，得到：
\begin{equation}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f566deec5f3750d0d907f925c638b229/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac7aebfbcd0a8e87c0a49097e795c702/" rel="bookmark">
			连接mysql错误2000_mysql连接错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.错误信息
Message: mysqli::real_connect(): (HY000/2000): mysqlnd cannot connect to MySQL 4.1+ using the old insecure authentication. Please use an administration tool to reset your password with the command SET PASSWORD = PASSWORD('your_existing_password'). This will store a new, and more secure, hash value in mysql.user. If this user is used in other scripts executed by PHP 5.2 or earlier you might need to remove the old-passwords flag from your my.cnf file
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac7aebfbcd0a8e87c0a49097e795c702/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d44245d1d8dec70681732787afaa6b3d/" rel="bookmark">
			python语言func_python中func什么意思
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python中的func表示自定义的函数，func只是一个函数名，它的名字不是固定不变的，自定义的函数的参数包括无参数，也可以根据函数动能传递必备参数、位置参数以及关键字参数等。
小白在学习python的时候，都会遇到func，一脸蒙！是什么意思呢？在python中，func表示的自定义函数。python中的函数分为内置函数和自定义函数，内置函数是python本身自带的，func函数是人为定义的。func只是一个函数名,名称不是固定的，你可以取其他的名字，但要避免与python关键字冲突！
python中如何定义函数？
函数代码块以 def 关键词开头，后接函数标识符名称和圆括号()。
任何传入参数和自变量必须放在圆括号中间。圆括号之间可以用于定义参数。
函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。
return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None
1、无参数
2、必备参数
3、关键字参数
使用关键字参数允许函数调用时参数的顺序与声明时不一致
4、默认参数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2010ec2f7b4c2ca9c36e807b73cf6b00/" rel="bookmark">
			python计算结果传给spark_python将csv数据发送到spark streaming
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我想尝试在python中加载一个csv数据，并通过spark流来流化每一行spark。在
我对网络很陌生。如果我要创建一个服务器python脚本，一旦它建立了连接(使用spark streaming)，它就会开始发送每一行。在Spark流媒体文档中，他们做了一个nc-l9999，如果im正确，这是一个netcat服务器监听9999端口。所以我尝试创建一个类似的python脚本来解析csv并发送到60000端口import socket # Import socket module
import csv
port = 60000 # Reserve a port for your service.
s = socket.socket() # Create a socket object
host = socket.gethostname() # Get local machine name
s.bind((host, port)) # Bind to the port
s.listen(5) # Now wait for client connection.
print('Server listening....')
while True:
conn, addr = s.accept() # Establish connection with client.
print('Got connection from', addr)
csvfile = open('Titantic.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2010ec2f7b4c2ca9c36e807b73cf6b00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75fb7a2db9b40f4ac7c6553e744a17a4/" rel="bookmark">
			Ubuntu 18.04.4 卸载 php7并安装php5.6
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		默认源安装的php版本为7.x版本，我们都知道php7.0已经舍弃了很多旧版本的函数等内容，这对旧系统来说是致命的，那么，我们就有了安装旧版php的需求，而同一主机安装两个版本的php，如果不做配置会报错。那么，我们就需要：
一、卸载php7.x；
1）如果我们知道在安装php7的时候都安装了那些包及扩展，可以直接使用命令（php_xxx为您安装的php集扩展）来卸载；
sudo apt-get - -purge remove php_xxx 2）不知道安装了那些扩展，可以使用以下方法来卸载；
a、安装aptiude
sudo apt-get install aptitude b、检索并卸载php现有版本
sudo aptitude purge `dpkg -l | grep php| awk '{print $2}' |tr "\n" " "` 二、安装旧版php（我这里以php5.6为例）
1）添加支持php5.6源
sudo add-apt-repository ppa:ondrej/php 2）更新ubuntu源
sudo apt-get update 3)安装php5.6及常用组件
sudo apt-get install php5.6
sudo apt-get install php5.6-gd
sudo apt-get install php5.6-mysql
sudo apt-get install php5.6-mbstring
sudo apt-get install php5.6-zip
sudo apt-get install php5.6-curl
Apache2重启：
sudo /etc/init.d/apache2 restart
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4442d5d9bd81887eee7f257ed541a297/" rel="bookmark">
			竟是CPU BUG？--记ARM指令SWP导致的QT卡住问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		竟是CPU BUG？--记ARM指令SWP导致的QT卡住问题
现象：QT运行一段时间后会卡住
环境：QT版本为4.4
CPU为三星EXYNOS 4412，Cortex A9 4核心，1.5G
过程及原因分析：
既然程序会卡住，一定是什么地方出了问题，这个时候，最直接高效的方式是使用GDB查看进程的堆栈。
但是，如果进程编译时没有使用-g选项，也就是编译的release版本，或者连接的库有release版本，则堆栈有可能出现符合无法解析的问题。
这个时候，可以尝试使用addr2line工具来分析，或者查看进程proc下的mmap，猜测地址在哪个模块中，看是否能够缩小范围。
如果缩小范围后的代码属于本工程编译的，也就是非第三方的，则可以重新编译debug版本替代，再次复现问题，打印堆栈。
通过gdb挂载进程，发现问题不在QT应用中，而是在QT框架内，重新编译了debug版本的QT框架。debug版本的体积会大很多，如果可以的话，可以只对特定库编译带符号版本。
再次gdb挂载，就可以看到出问题时的完整堆栈了：
(gdb) bt #0 0x40cd901c in qt_atomic_yield () from /opt/Qtopia4.4.3/lib/libQtCore.so.4 #1 0x407a0f0c in QRegion::copy () from /opt/Qtopia4.4.3/lib/libQtGui.so.4 #2 0x407a10c4 in QRegion::detach () from /opt/Qtopia4.4.3/lib/libQtGui.so.4 #3 0x407a1930 in QRegion::translate () from /opt/Qtopia4.4.3/lib/libQtGui.so.4 #4 0x407a1a30 in QRegion::translated () from /opt/Qtopia4.4.3/lib/libQtGui.so.4 #5 0x406e7260 in QWidgetPrivate::getOpaqueSiblings () from /opt/Qtopia4.4.3/lib/libQtGui.so.4 #6 0x406e7474 in QWidgetPrivate::subtractOpaqueSiblings () from /opt/Qtopia4.4.3/lib/libQtGui.so.4 #7 0x407fab50 in QWidgetBackingStore::updateWidget () from /opt/Qtopia4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4442d5d9bd81887eee7f257ed541a297/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed6244ca05864658aeaa3e8be5464c19/" rel="bookmark">
			RTL仿真时信号竞争问题——通过delta-cycle查看严格的时序逻辑前后关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于采样和驱动的信号竞争问题可以看我的这篇文章
https://blog.csdn.net/qq_39794062/article/details/113379285
接下来这篇文章通过一个RTL仿真例子，来讲解竞争问题。
race.sv
`timescale 1ns/1ns module race1; bit clk1, clk2; bit rstn; logic[7:0] d1; initial begin forever #5 clk1 &lt;= !clk1;	//5ns一翻转，所以时钟周期是10ns end always @(clk1) clk2 &lt;= clk1;	//当clk1上升沿到来时，赋值给clk2，利用组合逻辑使得clk2跟着clk1一起跳转 initial begin #10 rstn &lt;= 0; #20 rstn &lt;= 1; end always @(posedge clk1, negedge rstn) begin if(!rstn) d1 &lt;= 0; else d1 &lt;= d1 + 1;	//当clk1，rstn都为1时，d1加1 end always @(posedge clk1) $display("%0t ns d1 value is 0x%0x", $time, d1);	//clk1上升沿时打印d1此时刻的值 always @(posedge clk2) $display("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed6244ca05864658aeaa3e8be5464c19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e219f34a58fa64880b6dc71f2ced072/" rel="bookmark">
			python如何将图片打包进exe里_史上最详细的Python打包成exe文件教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打包成exe文件可以让python代码在没有python环境的条件下，依然能够运行，实在是码农们写追女朋友表白、情人节浪漫的必需品!
1、使用豆瓣镜像源下载: pyinstaller
有需要了解如何使用国内镜像的小伙伴可以滴滴到此:
国内镜像源详细使用教程!
https://blog.csdn.net/xtreallydance/article/details/112596963
在python终端或者cmd中输入此命令:
pip install pyinstaller -i https://pypi.doubanio.com/simple/ --trusted-host pypi.doubanio.com pip
小夜斗是在cmd终端上下载的，成功的结果如图所示：
2、小夜斗学会的一个python整蛊游戏，就拿这个代码来实现打包，看能否直接使用，这个文件执行后会出现很多弹框，内容可以根据自己修改，代码执行结果如下所示:
3、开始打包: 首先cmd或者pycharm终端路径切换到你代码所在的文件夹目录
这是小夜斗代码文件放置的位置，接下来我们使用cmd终端切换到此位置:
L:\python package\python小项目\python整蛊小游
4、最终输入打包命令如下:
Pyinstaller -F 随机弹框.py
打包后文件夹新增了一个dist文件夹和一些配置文件, 如图所示:
5、然后我们进入dist文件夹，会发现有一个exe可执行文件!
最后让我们执行它可以发现，真的可以成功运行!
Pyinstaller -F 随机弹框.py # 执行exe文件时会出现cmd弹框
Pyinstaller -F -w 随机弹框.py # 执行exe文件时没有出现cmd弹框
Pyinstaller -F -w -i abc.ico 随机弹框.py # 没有弹框，exe文件的图标是abc.ico，需要你在该打包代码文件夹放置相应的图标，否则会报错!
好啦今天的分享就到这里啦，然后小夜斗就要滚去学习啦，see you!
总结
到此这篇关于Python打包成exe文件教程的文章就介绍到这了,更多相关Python打包成exe文件内容请搜索脚本之家以前的文章或继续浏览下面的相关文章希望大家以后多多支持脚本之家！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffd7915b04a0133ea0c4e0f0b31f418e/" rel="bookmark">
			调用其他项目接口的几种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、通过HttpClient的方式
package com.zoey.http.utils; import com.alibaba.fastjson.JSONObject; import lombok.extern.slf4j.Slf4j; import org.apache.http.HttpResponse; import org.apache.http.client.config.RequestConfig; import org.apache.http.client.methods.HttpPost; import org.apache.http.entity.StringEntity; import org.apache.http.impl.client.CloseableHttpClient; import org.apache.http.impl.client.HttpClients; import org.apache.http.util.EntityUtils; import java.net.SocketTimeoutException; import java.nio.charset.Charset; /** * TODO * * @author zoey * @date 2021/1/29 16:29 */ @Slf4j public class HttpClientUtils { /** * 发送HttpClient请求 * @param requestUrl * @param requestParams * @return */ public static String sendPost(String requestUrl,String requestParams) { JSONObject jb = new JSONObject(); jb.put("code",0); try { CloseableHttpClient httpClient = HttpClients.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffd7915b04a0133ea0c4e0f0b31f418e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eca464d881d1e19e1705898d07d94eb5/" rel="bookmark">
			xxl-job 执行器时间轮
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是时间轮 时间轮出自Netty中的HashedWheelTimer，是一个环形结构，可以用时钟来类比，钟面上有很多bucket，每一个bucket上可以存放多个任务，使用一个List保存该时刻到期的所有任务，同时一个指针随着时间流逝一格一格转动，并执行对应bucket上所有到期的任务。任务通过取模决定应该放入哪个bucket。和HashMap的原理类似，newTask对应put，使用List来解决 Hash 冲突。
以上图为例，假设一个bucket是1秒，则指针转动一轮表示的时间段为8s，假设当前指针指向 0，此时需要调度一个3s后执行的任务，显然应该加入到(0+3=3)的方格中，指针再走3s次就可以执行了；如果任务要在10s后执行，应该等指针走完一轮零2格再执行，因此应放入2，同时将round(1)保存到任务中。检查到期任务时只执行round为0的，bucket上其他任务的round减1。
存入时间轮 // 时间轮的数据结构 private volatile static Map&lt;Integer, List&lt;Integer&gt;&gt; ringData = new ConcurrentHashMap&lt;&gt;(); // 存入时间轮 private void pushTimeRing(int ringSecond, int jobId) { // push async ring List&lt;Integer&gt; ringItemData = ringData.get(ringSecond); if (ringItemData == null) { ringItemData = new ArrayList&lt;Integer&gt;(); ringData.put(ringSecond, ringItemData); } ringItemData.add(jobId); logger.debug( "&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, schedule push time-ring : " + ringSecond + " = " + Arrays.asList(ringItemData)); } 上面是处理存储的方法，接下来通过注释来表示，执行器怎么执行的
//获取当前时间（ms） long nowTime = System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eca464d881d1e19e1705898d07d94eb5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0d9b677e7577c8d6d448abf1f0953e3/" rel="bookmark">
			Keycloak 常用API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.得到Token POST url: http://127.0.0.1:8082/auth/realms/master/protocol/openid-connect/token
2.得到userinfo GET url: http://127.0.0.1:8082/auth/realms/master/protocol/openid-connect/userinfo
需要提供上面得到的access_token信息。
3.得到所有的realm roles GET url: http://127.0.0.1:8082/auth/admin/realms/master/roles (Keycloak Admin REST API)
需要提供上面得到的access_token信息。
4.得到所有的Realm Group: GET url: http://127.0.0.1:8082/auth/admin/realms/master/groups
需要提供上面得到的access_token信息。
5.得到具体的group信息： GET url: http://127.0.0.1:8082/auth/admin/realms/master/groups/b62ea16a-2fbe-49f3-b7b6-c4681883038a (/{realm}/groups/{id})
需要提供上面得到的access_token信息，以及具体group的id 信息。
6.创建Group： POST URL: http://127.0.0.1:8082/auth/admin/realms/master/groups
需要提供上面得到的access_token信息，并加入到Header中
然后会遇到403错误，说没有权限去进行添加Group操作，怎么解决呢？
给用户添加role，并且这个role必须具有一定的权限。创建一个role，并为其分配client "master-realm"所拥有的权限"manage-users"，如下图所示
其中的"query-users"和"view-users"是用来做查询的，不能用于去创建group。
总结： 更多的Keycloak Admin REST API请参考： https://www.keycloak.org/docs-api/5.0/rest-api/index.html#_overview
需要注意的是，在使用Admin REST API的时候，一定要在Path的开头加上“auth/admin/realms/”，例如下面的得到所有realm group信息的API，应该这样访问
http://127.0.0.1:8082/auth/admin/realms/master/groups
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b64e485b27da08cbd87800804e67d02d/" rel="bookmark">
			修改idea使用本地maven配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.解决的问题 在idea中新创建了springboot项目，但pom中依赖的包总是无法导入。工作的网络不能直接访问外网，需要配置代理。
本地的maven已经做了配置，并把资料库改为了淘宝的。
需要把idea的默认maven改为本地maven。
2.本地maven配置 maven的安装和配置，不在赘述，见：
maven的配置文件：MAVEN_HOME\conf\settings.xml。关键内容如下：
&lt;!-- localRepository | The path to the local repository maven will use to store artifacts. | | Default: ${user.home}/.m2/repository &lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt; --&gt; &lt;localRepository&gt;D:\Maven\local-repo&lt;/localRepository&gt; &lt;proxies&gt; &lt;!-- proxy | Specification for one proxy, to be used in connecting to the network. | &lt;proxy&gt; &lt;id&gt;optional&lt;/id&gt; &lt;active&gt;true&lt;/active&gt; &lt;protocol&gt;http&lt;/protocol&gt; &lt;username&gt;proxyuser&lt;/username&gt; &lt;password&gt;proxypass&lt;/password&gt; &lt;host&gt;proxy.host.net&lt;/host&gt; &lt;port&gt;80&lt;/port&gt; &lt;nonProxyHosts&gt;local.net|some.host.com&lt;/nonProxyHosts&gt; &lt;/proxy&gt; --&gt; &lt;proxy&gt; &lt;id&gt;optional&lt;/id&gt; &lt;active&gt;true&lt;/active&gt; &lt;protocol&gt;http&lt;/protocol&gt; &lt;host&gt;********&lt;/host&gt; &lt;port&gt;80&lt;/port&gt; &lt;nonProxyHosts&gt;*******.com.cn&lt;/nonProxyHosts&gt; &lt;/proxy&gt; &lt;/proxies&gt; &lt;mirrors&gt; &lt;!-- mirror | Specifies a repository mirror site to use instead of a given repository.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b64e485b27da08cbd87800804e67d02d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c4747623526e5083aaec87e38d7f92c/" rel="bookmark">
			【Mysql】select * from test group by id引发的错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		昨天同事写了一段sql没报错(开发环境)，我本地报错了，sql如下
select * from test group by id 一般情况下，select查询的字段，如果用group by 分组查询的话，必须把select后面的字段全部分组，解决这问题需要我们自己配置来解决
查询配置，本地环境和开发环境的确实是不一样
修改配置
找到mysql目录下的my.cnf，如果是windows的话，则是my.ini
在[mysqld]下删除**ONLY_FULL_GROUP_BY **
重启mysql服务就生效了。
查询下
SELECT @@sql_mode;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69e00f9af4e796e50f1868433d98d384/" rel="bookmark">
			python十大排序例题_Python对获取数据并排序，编程练习题实例三十七
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python对input获取到的数据进行排序计算的练习，需要用到input及range、append及if控制流语句等等的综合应用练习。
Python解题思路分析：
首先可以利用选择法，即从9个数据进行比较过程中，先选择一个最小的与第一个元素交换。之后以此类推，即用第二个元素与后8个进行比较，并进行交换。
Python对获取数据并排序，编程练习题实例三十七具休操作源码如下：
#!/usr/bin/python
# -*- coding: UTF-8 -*-
#www.iplaypy.com
if __name__ == "__main__":
N = 10
# input data
print 'please input ten num:\n'
l = []
for i in range(N):
l.append(int(raw_input('input a number:\n')))
print
for i in range(N):
print l[i]
print
# sort ten num
for i in range(N - 1):
min = i
for j in range(i + 1,N):
if l[min] &gt; l[j]:min = j
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69e00f9af4e796e50f1868433d98d384/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55d0626e76649d6c86a7615b8dfaa433/" rel="bookmark">
			JPA No EntityManager with actual transaction available for current thread 问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： Caused by: javax.persistence.TransactionRequiredException: No EntityManager with actual transaction available for current thread - cannot reliably process 'remove' call
问题分析： 1、在进行删除操作时，需要开启事务才行执行删除操作。
解决办法：在删除方法上面或删除方法的类上面加上@Transactional注解。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fba4ed102b6c8e8b6dc8e0cf35f737e9/" rel="bookmark">
			图像分割为三个灰度等级_uNetXST：将多个车载摄像头转换为鸟瞰图语义分割图像...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目地址：https://github.com/ika-rwth-aachen/Cam2BEV
论文地址：https://arxiv.org/pdf/2005.04078.pdf
概述
准确的环境感知对于自动驾驶来说是非常重要的，当用单目摄像头时，环境中的距离估计是一个很大的挑战。当摄像机视角转换为鸟瞰视角(BEV)时，距离能够更加容易的建立。对于扁平表面，逆透视映射能够准确的转换图像到BEV。但是对于三维物体来说，会被这种转换所扭曲，使得很难估计他们相对于传感器的位置。
这篇文章描述了一种获取360°鸟瞰图的方法，这些图像来自于多个摄像头。对校正后的BEV图像进行语义分割，并预测遮挡的部分。该方法不需要手工标注数据，而是在合成数据集上面进行训练，这样就能够在真实世界表现更好的效果。
介绍
最近，自动驾驶受到工业研究的广泛关注。自动驾驶的其中一个关键因素是准确的感知周围的环境，这对于安全来说至关重要。
不同的环境表示通过环境中的坐标信息都能够被计算出来，在用于了解环境的不同类型的传感器中，摄像机因其低成本和成熟的计算机视觉技术而流行。由于单目摄像机只能提供图像平面上位置的信息，因此可以对图像进行透视变换。
透视变换是从一个视角所看到的相同场景的近似，在这个视角中，成像平面与摄像机前面的地平面对齐。将相机图像转换为BEV的方法通常称为逆变换角度映射(IPM)。IPM假设世界是扁平的，但是任何三维物体都会违背这一假设，所以不太适用。
尽管IPM引入的错误是可以校正的，但是仍然需要在BEV中检测目标。深度学习方法对于语义分割等任务来说非常有效，但是需要标记数据，尽管模拟可以获得这些数据，和真实数据比起来还是有一些差距。从模拟中学习到的复杂任务到现实世界的归纳是困难的，为了缩小差距，许多方法都旨在使模拟数据更加真实。
在本文中，作者提出了一种不受IPM下的平度假设所带来的误差影响的BEV图像获取方法。通过计算语义分割的摄像机图像，从真实数据中去除大部分不必要的纹理。
通过语义分割的输入，该算法能够获取类信息，从而能够将这些信息纳入IPM生成的图像的校正中。模型的输出是输入场景的语义分段BEV，由于对象形状被保留，输出不仅可以用于确定自由空间，而且可以定位动态对象。
此外，语义分割的BEV图像包含了未知区域的颜色编码，这些未知区域被遮挡在原始摄像机图像中。IPM得到的图像和所需的真实BEV图像如下图所示。
这项工作的贡献如下所示：
1：提出了一种在BEV中能够将多个车载摄像机图像转换为语义分割图像的方法；
2：使用不同的神经网络架构，设计并比较了两种不同的方法，其中一种是专门为这项任务设计的；
3：在设计过程中，不需要对BEV图像进行人工标记来训练基于神经网络的模型；
4：最后展示了一个成功的实际应用的模型。
相关工作
许多文献都说到了视角到BEV的转变，大多数作品都是基于几何的，重点是对地面的精确描绘。只有少数作品将摄像机图像转换成BEV与场景理解的任务结合起来。然而，他们却忽略了物体检测可以提供物体几何形状的线索，从而使变换受益。最近，一些深度学习方法展示了复杂的神经网络帮助改进经典的IPM技术，使其有助于环境感知。
比如说移除动态和三维物体来提高对道路场景的理解【1】，或者通过一个前置摄像头，合成整个道路场景的精确BEV表示【2】，这些方法都用到了GAN网络。还有很多方法，但是在作者看来，追求将多个语义分割的图像直接转换为BEV的想法的唯一来源是一篇博客文章【3】。该文章设计的神经网络是一个全卷积的自编码器，伴随着很多缺点，比如准确的目标检测范围相对较低。
方法
该作品基于卷积神经网络(CNN)的使用，但是大多数的CNNs只处理一个输入图像。为了融合安装在车辆上的多个摄像头的图像，单输入网络可以将多个图像按其通道级联作为输入。然而，这将导致输入和输出图像之间的空间不一致，卷积层在局部操作。针对这个问题的学习方法需要能够处理多视点图像，这表明需要一种额外的机制。
就像前面说到的，IPM会引入误差，但该技术至少能够产生与地面真实BEV图像相似的图像。由于这种相似性，将IPM作为一种机制来提供输入和输出图像之间更好的空间一致性似乎是合理的。
下面将介绍基于神经网络的方法的两种变体，它们都包含IPM的应用。在介绍这两种神经网络结构之前，作者详细介绍了应用的数据预处理技术。
1、处理遮挡：当只考虑输入域和期望的输出时，会出现一个明显的难题:交通参与者和静态障碍可能会遮挡部分环境，使得在BEV图像中预测这些区域几乎不可能。举个例子，当你在卡车后面行驶时，就会出现这样的遮挡：卡车前面发生的情况不能仅从车载摄像机的图像可靠地判断出来。
如何解决这位问题？作者对于每个车辆摄像机，虚拟光线从其安装位置投射到语义分割的地面真值BEV图像的边缘。对沿着这些射线的所有像素进行处理，根据以下规则确定它们的遮挡状态:
1.1：一些语义类如建筑、卡车总是阻塞视线;
1.2：一些语义类如道路从不遮挡视线;
1.3：汽车会挡住视线，但后面较高的物体如卡车、公共汽车除外;
1.4：部分被遮挡的物体仍然完全可见;
1.5：物体只有在所有的相机透视图中都被遮挡的情况下才被标记为被遮挡。
根据这些规则修改的真实BEV图像如下图所示。
2、投影预处理：IPM技术作为方法中的一部分，作者推导了汽车摄像机框架与BEV之间的投影变换，确定了单应矩阵涉及的相机内部和外部参数，并应在下面简要说明。
世界坐标xw和图像坐标xi之间的关系由以下投影矩阵P给出：
投影矩阵将相机的内在参数如焦距编码为一个矩阵K和外参(世界坐标系中的旋转R和平移t)：
假设存在从道路平面xr到世界坐标系的变换M：
就可以获得从图像坐标xi到道路平面xr的转换：
设置该变换作为捕捉与真实BEV图像相同的视野。由于这一区域被所有摄像机图像的并集覆盖，因此它们首先通过IPM分别变换，然后合并成一个单独的图像，以下称为单应图像。重叠区域中的像素，即从两个摄像机可见的区域，从变换后的图像中任意选择一个。
3、变体1-单输入模型：作者预先计算如上节所示的单应性图像，以弥补相机视图和BEV之间的很大一部分差距。作者在此提供了神经网络输入与输出在一定程度上的空间一致性，网络的任务就是纠正IPM带来的错误。
由于单应性图像和期望的目标输出图像覆盖相同的空间区域，作者使用已有的CNNS进行图像处理，这在语义分割等其他任务上已经被证明是成功的。最后作者选择了DeepLabv3+作为单网络输入的架构。
4、变体2-多输入模型：该模型处理来自车辆摄像头的所有非转换图像作为输入，在未转换的相机视图中提取特征，因此不完全受IPM引入的误差的影响。作为一种解决空间不一致性问题的方法，作者将射影变换集成到网络中。
为了构建一个多输入单输出图像的架构，作者将现有的CNN扩展为多个输入流，并在内部融合这些流。由于其简单性和易于扩展性，作者选择了流行的语义分割架构U-Net作为扩展的基础。最后简单的网络结构如下所示：
结果展示
在模拟数据集上面的测试效果
在真实世界的测试效果
总结和思考
作者提出了一种能够通过多个车载摄像头采集到的数据，获得道路状况鸟瞰图的方法。其中解决了一些不利因素的影响，如前面提到不正确的平面假设所产生的误差，并且无需人工标记BEV数据集，最后产生的效果如上图所示。
在我看来，这是一项非常棒的工作，对于自动驾驶环境感知的研究有很大帮助。但是仍然有一些不足，在模拟数据集上面的效果和标签相差无几，在真实世界的效果却不是很好。同时道路交通也是一个非常复杂的情况，需要更深层次的研究。
【1】T. Bruls, H. Porav, L. Kunze, and P. Newman, “The Right (Angled) Perspective: Improving the Understanding of Road Scenes Using Boosted Inverse Perspective Mapping,” in 2019 IEEE Intelligent Vehicles Symposium (IV), 2019, pp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fba4ed102b6c8e8b6dc8e0cf35f737e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1620cdbedb63bca2cf05362f2ce899a3/" rel="bookmark">
			vue中监听页面滚动和监听元素滚动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 监听页面滚动 在生命周期mounted中进行监听滚动：
mounted () { window.addEventListener('scroll', this.scrollToTop) }, 在方法中定义监听滚动执行的方法：
scrollToTop() { var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop; console.log(scrollTop) }, 监听某元素滚动 tips：需要监听的这个元素需要拥有固定的高度
&lt;div id="app" ref="app" @scroll="handleScroll"&gt;&lt;/div&gt; handleScroll() { const scrollTop = this.$refs.app.scrollTop console.log(scrollTop) }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27957618d248166e2949284f0debdd63/" rel="bookmark">
			分页插件pageHelper 不生效的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述：
近期做项目的时候用到了该分页插件，测试的时候遇到一个现象，pagehelper有些时候分页没有效果。
原因分析： 1.首先确保pageHelper引用 和写法无误的情况（因为我这边的现象是有些页面分页有效，有些无效，说明不是插件的引用配置问题。）
2.排除使用该插件一系列问题之后，我查了下pageHelper相关问题，终于发现了问题所在：
首先第一个：PageHelper.startPage(1,10); pageHelper只对该语句以后的第一个查询语句得到的数据进行分页。 第一个查询语句是指什么呢?举个例子吧,比如你有一个查询数据的方法，写在了PageHelper.startPage(1, 10);下面，但是这个查询方法里面，包含两个查询语句的话（假设一个是基础数据的查询语句，另一个是
你要分页返回的最终数据的查询语句），该插件就只会对你代码中PageHelper.startPage(1, 10);紧随其后的第一查询语句查询的数据进行分页，而此时你需要分页的那个查询方法不是排在最前面的。所以结果
并不是对返回最终数据的查询出来的数据进行分页，而是对基础查询的数据进行分页。
解决方案： 此时解决方案就明确了：
改变一下自己的代码结构,让最终需要的数据所需要的查询语句放在PageHelper.startPage(1, 10)下面就行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61dbb8dfbd1aab839679cbd883de8384/" rel="bookmark">
			数组地址加一详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.一维数组 int a[5]={1,2,3,4,5}; //int *a=new int[5]; int *ptr=(int*)(&amp;a+1); //&amp;a+1相当于加了数组的一个单位（也就是一行），即&amp;a[5] printf("%d", *(p-1)) //指针p-1相当于前移一个元素，输出为5 a是数组首地址a[0]的地址，&amp;a是对象（数组）首地址；
a+1，表示指针指向下一个元素a[1]，这是因为系统在内存中为数组分配一个连续大小为20字节的大小，并把首地址赋值给数组名a，那么&amp;a+1就是表示这个内存的下一个地址。
（int）a表示的把数组地址即内存单元的编号转换成整数，那么此时的（int）a+1加一相当于加一个整数
2.二维数组 int a[2][3] = { {1,2,3},{4,5,6} };
a代表二维数组中第一个一维数组a[0]的首地址，a+1代表移动到下一个一维数组a[1]的首地址
int (*p)[3];//一定要加上括号，因为[]的优先级高于*
p=a;//相当于p&amp;a[0]，也就是指向第一个数组a[0]的首地址
cout&lt;&lt;p+1&lt;&lt;endl;//数组a[1]的首地址
int *p=&amp;a[0][0];//数组元素首地址p相当于&amp;a[0][0]
cout&lt;&lt;p+1&lt;&lt;endl;//p+1相当于&amp;a[0][1]
参考：
1.https://www.cnblogs.com/zzdbullet/p/9392726.html
2.https://blog.csdn.net/nice__xixi/article/details/82081595
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78825257e60f2e72e3714aa49daf0102/" rel="bookmark">
			C&#43;&#43;    string和char* 区别,   char** a 和 char* a[ ] 区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. string和char* 区别 1、定义：
string：string是STL当中的一个容器，对其进行了封装，所以操作起来非常方便。
char*：char *是一个指针，可以指向一个字符串数组，至于这个数组可以在栈上分配，也可以在堆上分配，堆得话就要你手动释放了。
2、区别：
string的内存管理是由系统处理，除非系统内存池用完，不然不会出现这种内存问题。
char *的内存管理由用户自己处理，很容易出现内存不足的问题。
当我们要存一个串，但是不知道其他需要多少内存时， 用string来处理就最好不过了。
当你知道了存储的内存的时候，可以用char *，但是不如用string的好，用指针总会有
隐患。
用string还可以使用各种成员函数来处理串的每一个字符，方便处理。
用char *处理串，就不如string的方便了，没有相应的函数来直接调用，而是要自己编
写函数来完成串的处理，而且处理过程中用指针还很容易出现内存问题。
char *s="string"的内容是不可以改的；char s[10]="string"的内容是可以改的
3、注意：
当我们定义了一个string，就不能用scanf("%s",s)和printf("%s",s)输入输出。主要是因为%s要求后面是对象的首地址
4、转化：
当 string 直接转化成 const char *时，可以通过两个函数c_str()，data()成员函数。
将char *转化成string，直接转化就可以。就是注意输出的问题。
二. char** a 和 char* a[ ] 区别 1. char** a
在 char** a 中，a 是一个指针，这个指针（a）指向一块内存地址，该内存地址中存储的是 char* 类型的数据。指针的加减运算在这里的体现为：a + 1 表示地址加8字节（在32位系统中，地址加4字节）。
char* 也是一个指针，用 *a 表示，这个指针（*a）指向一块内存地址，该内存地址中存储的是 char 类型的数据。指针的加减运算在这里的体现为：(*a) + 1 表示地址加1字节。
说明：
在32位系统中，一个指针占用4字节；在64位系统中，一个指针占用8字节；由于a指向一个指针类型（char*），故 a + 1 操作就是对指针类型的地址进行操作，所以 a + 1 表示地址加8字节；*a指向一个char类型，char类型占用1个字节，故 *a + 1操作就是对char类型的地址进行操作，所以 *a + 1表示地址加1字节。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78825257e60f2e72e3714aa49daf0102/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80f4ece6d036e3e4858938470a081cce/" rel="bookmark">
			wsl中的ubuntu终端光标消失的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在window 10的wsl中安装ubuntu，通过terminal进入linux，刚开始使用时光标是有的，但是使用一些时间后会发现光标不见了，虽然可以使用，但是不方便，解决方案是：
要显示光标可以使用以下命令：
echo -e "\033[25h" 要隐藏光标可以使用以下命令：
echo -e "\033[25l" 但是要记住这些命令不容易，目前我的方法是在 ~/.bashrc 或者 ~/.zshrc中添加以下两条别名：
alias cs='echo -e "\033[25h"' #c for cursor ,s for show alias ch='echo -e "\033[25l"' #c for cursor ,h for hidden 当然，可以自定义别名为其他。这样，在发现没有光标是输入命令：
cs
即可。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/216/">«</a>
	<span class="pagination__item pagination__item--current">217/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/218/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>