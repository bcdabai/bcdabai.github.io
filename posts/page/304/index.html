<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77cd582267dccf1215007eb91bc7b6a4/" rel="bookmark">
			回调操作(Call Back)请求超时
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误信息：
发送到 net.tcp://10.10.77.28:8003/MyHello 的请求操作在配置的超时(00:01:00)内未收到回复。分配给该
操作的时间可能是更长超时的一部分。这可能由于服务仍在处理操作或服务无法发送回复消息。请考虑增加操
作超时(将通道/代理转换为 IContextChannel 并设置 OperationTimeout 属性)并确保服务能够连接到客户端。
解决：
在客户端应用程序中配置回调服务实现：[CallbackBehavior(UseSynchronizationContext = false)]
二、
问题：超时问题，在最后获取数据的时候突然提示服务超时，服务已断开
解决：配置文件添加：
&lt;bindings&gt; &lt;wsHttpBinding&gt; &lt;binding name="BindConfig" closeTimeout="00:01:00" openTimeout="00:01:00" receiveTimeout="00:30:00" sendTimeout="00:30:00" bypassProxyOnLocal="false" transactionFlow="false" hostNameComparisonMode="StrongWildcard" maxBufferPoolSize="524288" maxReceivedMessageSize="65536" messageEncoding="Text" textEncoding="utf-8" useDefaultWebProxy="true" allowCookies="false"&gt; &lt;readerQuotas maxDepth="32" maxStringContentLength="8192" maxArrayLength="16384" maxBytesPerRead="4096" maxNameTableCharCount="16384" /&gt; &lt;reliableSession ordered="true" inactivityTimeout="00:10:00" enabled="false" /&gt; &lt;security mode="None"&gt; &lt;transport clientCredentialType="Windows" proxyCredentialType="None" realm="" /&gt; &lt;message clientCredentialType="Windows" negotiateServiceCredential="true" algorithmSuite="Default" establishSecurityContext="true" /&gt; &lt;/security&gt; &lt;/binding&gt; 问题三：解决上述问题之后又出现了新问题，在服务端可以获取得到数据，但是到了客户端总是空，然后准备测试数据，在服务端只给一个int型的变量，客户端获取的到，但是一旦换成自己的自定义类，客户端就获取不到
解决：在服务端和客户端都要有自定义类，代码要一样，另外还要保证两个类的命名空间一致
如：服务端
[DataContract(Namespace = "Rostering.BO")] [Serializable] public class NewAttendancePlan { [DataMember] public int AttendancePlan_Id { get; set; } } 客户端一样：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77cd582267dccf1215007eb91bc7b6a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2ba32055a3903e8b3bfda7f89e5b6ec/" rel="bookmark">
			浅谈Java的反射机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述
Java反射是可以让我们在运行时获得类的方法、属性、父类、接口等类的内部信息的机制。也就是说反射本身是一个“反着来”的过程。我们通过new创建类的实例时实际上是JVM在运行时根据这个类的class对象构建出来的，而反射是在运行时通过类的class对象获得他的内部定义信息。
Class类
我们知道使用javac能够将.java文件编译成.class文件，这个.class文件包含了我们对类的原始定义信息（构造函数、方法、属性、父类、接口等）。我们又知道.class文件在运行时会被类加载器(ClassLoader)加载到JVM中，当一个.class文件被加载后，JVM会为之生成一个class对象，我们在程序中通过new实例化的对象实际上是在运行时根据相应的class对象构造出来的。确切的说这个class对象是java.lang.Class&lt;T&gt;泛型类的一个实例比如Class&lt;Human&gt;对象即为一个封装了Human类的定义信息的Class&lt;T&gt;实例。由于java.lang.Class&lt;T&gt;类不存在公有构造函数，因此我们不能直接实例化这个类，我们可以通过一下方法获得一个class对象。例如我们定义了一个Human类
class Human { private String sex;//性别 private Integer age;//年龄 public Human(String sex,Integer age){ this.sex=sex; this.age=age; } public void eat(){//吃饭行为 System.out.println("吃早餐"); } } 1）通过类名获取其class对象
Class&lt;Human&gt; humanClass=Human.class; 2）通过类的完整路径名获取其class对象 try { Class&lt;Human&gt; humanClass2=(Class&lt;Human&gt;) Class.forName("javaBasic.Human"); } catch (ClassNotFoundException e) { e.printStackTrace(); } 3）通过对象本身获取其class对象 Human h=new Human(); Class&lt;Human&gt; humanClass3=(Class&lt;Human&gt;) h.getClass(); 通过反射获取类中定义的内部信息 1) 获取类构造器
一旦我们获得了Human的class对象，我们就能够通过这个class对象获得Human类的原始定义信息，首先我们来获取Human类的构造器对象，有了构造器对象我们就能够构造出一个Human对象出来。注意，当通过反射获取到类的 Constructor、Method、Field对象后，在调用这些对象的方法之前，先将此对象的 accessible 标志设置为 true，以取消 Java 语言访问检查，可以提升反射速度。
Class&lt;Human&gt; humanClass=Human.class; try { Constructor&lt;Human&gt; c=humanClass.getConstructor(String.class,Integer.class); c.setAccessible(true); Human human=c.newInstance("男","21"); human.eat(); } catch (Exception e) { e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2ba32055a3903e8b3bfda7f89e5b6ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9129f153376c6eaf47e6b15851386a1e/" rel="bookmark">
			Java super关键字详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一.super关键字作用
1：主要存在于子类方法中，用于指向子类对象中父类对象。
2：访问父类的属性
3：访问父类的函数
4：访问父类的构造函数
二. super注意的地方 this和super很像，this指向的是当前对象的调用，super指向的是当前调用对象的父类。类加载完毕，创建对象，父类的构造方法会被调用（默认自动无参），然后执行子类相应构造创建了一个子类对象，该子类对象还包含了一个父类对象。该父类对象在子类对象内部。this super只能在有对象的前提下使用，不能在静态上下文使用。
三.super关键字的使用
1.子类的构造函数默认第一行会默认调用父类无参的构造函数，隐式语句
super();
Son(int y) { //super();隐式语句 this.y = y + x; System.out.println("这是子类的有参构造"); } 2.子类显式调用父类构造函数
在子类构造函数第一行通过super关键字调用父类任何构造函数。如果显式调用父类构造函数，编译器自动添加的调用父类无参数的构造就消失。构造函数间的调用只能放在第一行，只能调用一次。super()和this()不能同时存在构造函数第一行。
Son(int y) { super(y);// 子类显式调用父类构造函数 this.y = y + x; System.out.println("这是子类的有参构造"); } 四.super思考 如果开发者自定义了一个类，没有显示的进行类的继承，那么该类中成员函数是否可以使用super关健健字？可以使用，继承了Object类，Object类是所有类的父类。
class Demo7 { public void print(){ System.out.println(super.toString()); } public static void main(String[] args){ new Demo7().print(); System.out.println(); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5247920c3916303ad9ccb7beec1c7e04/" rel="bookmark">
			while语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：语句格式格式1：
while(条件表达式) 语句1;说明：语句1是while循环语句的循环体，它将在满足条件的情况下被重复执行。 格式2： while(条件表达式) { 语句1; 语句2; } 说明：while语句是一个典型的当型循环，循环体部分由多个语句组成时，应由一对花括号括起来，构成一个语句块的形式。 程序风格提示：写while循环语句的时候，循环体的语句对于while缩进两格。 二：语句执行过程
（1）计算作为循环控制条件表达式的值，得到逻辑真或假，假定用M表示。
（2）若M为真，则执行一边循环体，否则离开循环体，结束整个while语句的执行。
（3）循环体的所有语句执行结束后，自动转向第（1）步执行。
三：格式例举
（1）
int i=0; while(i&lt;10) ++i; //功能：当i的值小于10，重复执行++i语句。 （2） while(cin&gt;&gt;x,x&lt;0) //相当于cin&gt;&gt;x; while(x&lt;0) cin&gt;&gt;x; //功能：当输入的数据小于0时，重复读数据。注：while括号中可以包含多个语句（中间用逗号隔开），但时只判读最后一个语句是否为真，如：while(x&gt;10,x==10,x&lt;10)，如果x&lt;10，则继续执行循环，否则推出循环。 例1： 求s=1+2+3+...+n,当加到几的时候，s的值会超过1000？ 源代码： #include&lt;iostream&gt; #include&lt;cstdio&gt; using namespace std; int main() { int n=0,s=0; while(s&lt;=1000) { ++n; s+=n; } printf("%d\n",n); system("pause"); return 0; } 例2： 输入一些整数，求出它们的最小值，最大值和平均值（保留3位小数）。输入保证这些数都是不超过1000的整数。 输入样例：2 8 3 5 1 7 3 6
输出样例：1 8 4.37
源代码： #include&lt;iostream&gt; #include&lt;cstdio&gt; #define INF 100000000 using namespace std; int main() { int x,n=0,max=-INF,min=INF,s=0; while(scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5247920c3916303ad9ccb7beec1c7e04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c36cdacee6d86eb9e004de3403dc1eea/" rel="bookmark">
			图像聚类-K均值聚类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近做的一个东西跟这个相关，本来希望是用深度学习对于没有标签的图像数据进行分类，但是通常情况下，深度学习是对有标签的数据进行学习，目的是用来自动提取特征，代替传统的手工提取特征。因此，比较容易想到，对于无标签又需要分类的图像数据，可以尝试先采用聚类来解决.
下面的内容是译自Jan Erik Solem的《Programming Computer Vision with Python》的第6章，该书已经由朱文涛和袁勇学长对该书进行了翻译，主要涉及相关代码和实例，可以转至http://yongyuan.name/pcvwithpython/。 我仅对其中第6章的理论进行翻译，中途穿插自己的理解。
该博文仅供交流学习，如有侵权，请联系删除。
====================================================================
第6章 图像聚类
这一章节主要介绍了几种聚类方法，显示了如何将其用在聚类图像中从而找到相似图片的组。聚类可以用于识别，用于将图像数据集进行分类，用于组织和导航。我们也关注将聚类用于图像间的相似度的可视化。
6.1 K均值聚类（K-meansClustering）
K均值是一个非常简单的聚类算法，将输入数据分到K个类中。K均值是通过循环更新类中心的初始估计值来实现的，其步骤如下：
1.初始化类重心ui, I = 1, …k, 可以通过随机初始化或者使用一些猜测的值；
2.将每一个数据点赋给距离类ci最近的中心；
3.更新中心为赋给某一类的所有数据点的平均值；
4.重复步骤2和3直至收敛。
K均值尽可能地最小化类之间的方差：
其中xj是数据向量。上面的算法是一个启发式的提炼算法，对于大多数的情况是试用的，但是不能够保证得到的结果是最好的。为了避免找到一个不好的中心的初始化的影响，该算法通常是使用不同的初始化中心运行几次。然后从这些结果中选择具有最小方差V的作为最后的结果。
该算法的主要缺陷是，类的数目需要提前确定，也就是说，我们必须一开始指定将数据聚成几类，也就是传入的参数K。这样的话，一个不恰当的选择可能就会导致很差的聚类结果。其优势是实现起来很简单，是并行化的，并且对于大范围的问题不需要任何调整就可以实现很好的结果。
SciPy聚类包
由于该书的例子都是使用python实现，因此需要介绍一些必要的包。
尽管K均值算法容易实现，但是也不是没有必要实现一下。SciPy向量量化包sciPy.cluster.vq自带一个K均值的实现。下面是它如何使用的。
让我们首先从创建一些二维样本数据来说明。
这个可以在二维下生成2个正态分布的类。为了聚类这些点，可以设置k=2运行下面的k聚类：
方差会被返回但是事实上我们不是非常需要，因为SciPy实现计算了几次运行（默认是20）然后为我们选择了有着最小方差的一个返回。现在，需要在SciPy包中确认是否每一个数据点都使用向量量化函数被赋值了。
通过检查code的值，我们可以看到是否存在不正确的赋值。为了可视化，我们可以将这些点和最后的中心都画出来。
这里函数where()是给出每一个类的索引。通过运行代码，可以得到下面的结果：
图1- 2D点的K均值聚类的样例
这是我重新跑的结果，因为书上的图不是特别清楚。其中类重心是被标记为绿色的环，预测的类别分别是蓝色的星星和红色的点点。
图像聚类
下面我们将K均值算法运用在书中前面章节提到过的字体图像中。文件selectedfontimages.zip包含66张从这个字体数据集中提取的图像（这些选择都是为了在显示类时容易观察，另住：这些数据也可以通过最开始提到的链接中下载到）。作为每一个图像的描述向量，我们将会使用映射系数，在映射到先计算好的前40个首要主成分之后。使用pickle加载模型文件，然后主成分上的图像映射和聚类就可以按照下面的代码实现：
跟之前一样，code包含了对于每一张图像的聚类赋值。在这个实例中，我们令k=4。我们也使用sciPy的whiten()函数将数据进行漂白，归一化，使得每一个特征都有单位方差。尽力改变像使用的主成分的数目和k的值这样的参数为了观察聚类结果是如何改变的。聚类可以通过下面的代码被可视化：
这里，我们对每一个类都使用一个单独的最多显示40张图像的网格窗口来显示。我们使用PyLab函数subplot()来定义这个网格。一个实例结果如下。
图2- 使用40个主成分的字体图像，k=4的K均值聚类
如果需要更多的SciPy实现的K均值的细节，可以查看参考资料http://docs.scipy.org/doc/scipy/reference/cluster.vq.html。
主成分可视化图像
为了看使用一些主成分的聚类如何实现，我们可以通过在一组主成分方向上基于它们的坐标可视化图像。其中一个方法是通过改变映射得到相关的坐标（在这个例子中，V[[0,2]]给出第一个和第三个）而映射到两个成分上。另外，映射所有的主成分，然后选出你需要的列。
为了可视化，我们将使用PIL中的ImageDraw。假设你已经有了所有的映射图像和图像列表，下面的代码将生成图3
图3- 在成对主成分上的字体图像的映射。
左边是第一和第二个主成分，右边是第二和第三个
这里，我们使用了整数和地板整数运算符//，该运算符通过移除小数点后的值返回一个整数像素位置。
像这样的图说明了在40维中图像是如何被分布的，并且在选择一个好的描述符时非常有用。已经在这二维映射中的相似的字体图像的分界线可以清晰可见。
像素聚类
在这一节结束之前，我们将看一个聚类单独的像素而不是整个图像的例子。将图像区域（和像素）分组成有意义的成分叫做图像分割，这也是后面第9章的内容。将K均值算法简单的应用到像素值上是不能够得出任何有意义的东西的，除非是在非常非常简单的图像中。更加复杂的类模型（比平均像素颜色）或者空间一致性是需要来产生更加有用的结果。现在，我们将K均值应用到RGB值上，之后再考虑解决分割问题（章节9.2会有详细描述）。
下面的代码样本输入一张图像，将其减到一个更低的分辨率的版本，其中像素是原始图像区域（大小step * step的正方形网格表示）的平均值，并使用K均值聚类这些区域。
K均值的输入时一个有着steps * steps行的数组，每一个包含R，G和B的均值。为了可视化结果，我们使用SciPy的imresize()函数来显示在最初图像坐标处的steps * steps的图像。参数interp指定使用哪一种插值方式，这里我们使用最近邻，这样我们在类之间的转换时不需要引入新的像素值。
图4显示了使用50x50和100x100区域用于两个相对简单的样例图像的结果。需要注意的是，K均值标签（这个情况下是结果图像中的颜色）的顺序是任意的。正如你所看到的，尽管下采样为了只使用一些区域结果也是比较有噪的。没有空间一致性，也很难分离区域，像下面例子中的男孩和草地。
空间一致性和更好的分离将在之后被处理，与其他的图像分割算法一起。
图4-使用K均值给予它们颜色值的像素聚类。左边是原始图片，
中间是k=3和50x50分辨率的聚类结果，右边是k=3和100x100分辨率的聚类结果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a677e1afa54fde30cd5a7b790b8c40d3/" rel="bookmark">
			使用 adb 命令一次性为多个设备安装 apk
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		命令简介 adb install [-lrtsdg] (file)
把包文件推送到设备上并安装。
-l 锁定应用 -r 替换已存在的应用 -t 允许安装测试包 -s 安装到sd卡中 -d 可以安装低版本安装包 -p 安装部分应用 -g 授权所有运行时权限 adb uninstall [-k] (package)
卸载设备上的应用包，-k表示保存数据和缓存目录。
Shell 版本 顺序安装 adb_install.sh
#!/bin/bash echo $1 adb devices &gt; devices.txt echo "开始读取设备" line_num=0 while read -r line do if [ $line_num != 0 ] &amp;&amp; [ -n "$line" ]; then devices_info=`echo $line | cut -d " " -f 1` echo $devices_info adb -s $devices_info install -d -r $1 fi let line_num++ done &lt; devices.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a677e1afa54fde30cd5a7b790b8c40d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f78470355394a16caec31465257dbeac/" rel="bookmark">
			Boost 15 进程间通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 介绍 Boost.Interprocess库简化了使用通用的进程间通信和同步机制。并且提供这些机制的部件：
* 共享内存
* 内存映射文件
* 信号量，互斥量，条件变量和可升级的互斥量类型，该类型可以放入共享内存和内存映射文件中
* 命名版本的同步对象
* 文件锁
* 相对指针
* 消息队列
Boost.Interprocess还提供了更高级的进程间机制，用于动态分配共享内存或者内存映射文件。：
* 在共享内存或者文件映射中动态创建匿名或者命名对象。
* 与共享内存或者文件映射兼容的类似STL的容器
* 可在共享内存和文件映射中使用的类似STL的分配器，类似内存池。
1.1. 构建Boost.Interprocess 没必要编译Boost.Interprocess，因为都是头文件。只需要添加Boost头文件目录到你的编译器包含路径中。
Boost.Interprocess依赖于Boost.DateTime库，但是该库是需要编译的。
1.2. 测试过的编译器 2. 快速试用 2.1. 将共享内存作为无名内存块池使用 你只需要分配共享内存段的一部分，拷贝消息到该缓冲区中，发送该内存部分的偏移给另外进程，然后就完成了。让我们看看例子：
#include &lt;boost/interprocess/managed_shared_memory.hpp&gt; #include &lt;cstdlib&gt; #include &lt;sstream&gt; int main( int argc,char* argv[]){ using namespace boost::interprocess; if( argc==1 ){ // 父进程 struct shm_remove{ shm_remove(){ shared_memory_object::remove(“MySharedMemory”);} ~shm_remove(){ shared_memory_object::remove(“MySharedMemory”); } }remover; // 创建一个被管的共享内存段 managed_shared_memory segment(create_only,”MySharedMemory”,65536); // 分配段的一部分（原始内存） managed_shared_memory::size_type free_memory = segment.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f78470355394a16caec31465257dbeac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd9a80f409cede1839ec6a79eac93f54/" rel="bookmark">
			Java 构造函数的详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们人出生的时候，有些人一出生之后再起名字的，但是有些人一旦出生就已经起好名字的。那么我们在java里面怎么在对象一旦创建就赋值呢？
1.构造方法的作用：
构造方法作用：对对象进行初始化.
如图：
2.构造函数与普通函数的区别：
（1）. 一般函数是用于定义对象应该具备的功能。而构造函数定义的是，对象在调用功能之前，在建立时，应该具备的一些内容。也就是对象的初始化内容。
（2）. 构造函数是在对象建立时由jvm调用, 给对象初始化。一般函数是对象建立后，当对象调用该功能时才会执行。
（3）. 普通函数可以使用对象多次调用，构造函数就在创建对象时调用。
（4）. 构造函数的函数名要与类名一样，而普通的函数只要符合标识符的命名规则即可。
（5）. 构造函数没有返回值类型。
3.构造函数要注意的细节： （1）. 当类中没有定义构造函数时，系统会指定给该类加上一个空参数的构造函数。这个是类中默认的构造函数。当类中如果自定义了构造函数，这时默认的构造函数就没有了。
备注：可以通过javap命令验证。
（2）.在一个类中可以定义多个构造函数，以进行不同的初始化。多个构造函数存在于类中，是以重载的形式体现的。因为构造函数的名称都相同。
class Perosn{ private int id; private String name; private int age; public Perosn(){ cry(); } public Perosn(int id, String name, int age) { this.id = id; this.name = name; this.age = age; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd9a80f409cede1839ec6a79eac93f54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cab0c009435ebe93c0c3ab5abc999744/" rel="bookmark">
			lower_bound(）返回值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		lower_bound()函数实现功能就是二分查找，函数lower_bound()在first和last中的前闭后开区间进行二分查找，返回大于或等于val的第一个元素位置。如果所有元素都小于val，则返回last的位置。 举例说明： 例如有数组a[]={1,2,3,4,5,6,7,10}，lower_bound(a,a+5,4)-a的返回值就是3(需要注意的是这里必须减去a)，返回值3也就是数组中4的下标；那么lower_bound(a,a+8,15)-a的返回值应该是什么？是8，这是因为如果所有元素都小于val，则返回last的位置。 测试代码:
#include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; int main() { int a[]={1,2,3,4,5,6,10,11,12,13}; cout&lt;&lt;lower_bound(a+5,a+10,13)-a&lt;&lt;endl; cout&lt;&lt;lower_bound(a,a+10,5)-a&lt;&lt;endl; cout&lt;&lt;lower_bound(a,a+10,20)-a&lt;&lt;endl; return 0; } 如有不当之处欢迎指出！！
转载于:https://www.cnblogs.com/flyawayl/p/8305614.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0443c624b1363f2655470d59c4f8327/" rel="bookmark">
			angularJS 发起$http.post和$http.get请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AngularJS发起$http.post请求 代码如下：
$http({ method:'post', url:'post.php', data:{name:"aaa",id:1,age:20} }).success(function(req){ console.log(req); }) 这时候你会发现收不到返回的数据，结果为null，这是因为要转换成form data。 解决方案：
配置$httpProvider： var myApp = angular.module('app',[]); myApp.config(function($httpProvider){ $httpProvider.defaults.transformRequest = function(obj){ var str = []; for(var p in obj){ str.push(encodeURIComponent(p) + "=" + encodeURIComponent(obj[p])); } return str.join("&amp;"); } $httpProvider.defaults.headers.post = { 'Content-Type': 'application/x-www-form-urlencoded' } }); 或者在post中配置: $http({ method:'post', url:'post.php', data:{name:"aaa",id:1,age:20}, headers:{'Content-Type': 'application/x-www-form-urlencoded'}, transformRequest: function(obj) { var str = []; for(var p in obj){ str.push(encodeURIComponent(p) + "=" + encodeURIComponent(obj[p])); } return str.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0443c624b1363f2655470d59c4f8327/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4772a1499ff52c68e01dbc5753dbfd4c/" rel="bookmark">
			SRM549
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		250 PointyWizardHats 题意：n个圆锥型小帽子和m个圆锥形大帽子,现在要把一顶小帽子和一顶大帽子组合起来，组合的条件是xxx,问最多能组合多少对
分析：直白的二分图匹配，少见250出这个
600 MagicalHats 题意：一块13*13的板子，一些位置有帽子，某些帽子后面藏有面值不同的硬币，且任意时刻每个帽子后面只有至多一枚硬币，现在要猜K次，魔术师在每次猜之前可以改变硬币所属的帽子（被猜过的地方就不能改了），并且保证任意时刻每行每列帽子数和硬币数的奇偶性相同，你的目标是最大化得到的硬币价值，魔术师的目标,保证最多有13顶帽子
分析：3进制压一下状态，预处理出每个状态是否合法，记忆化搜索一下
950 CosmicBlocks 题意：有6种颜色的砖块，每种有若干个(&lt;=7500)，现在要把这些所有砖块搭起来，要求相同颜色的砖块高度相同；定义两种本质不同的方案当且仅当在一种方案中存在一个颜色的砖块在另一个颜色的下面，而在第二种方案中不存在这对颜色，问有多少种方案的拓扑排序种数在[L,R]
分析：因为颜色数只有6，可以爆搜所有方案，判断一下合不合法，判断的时候需要用网络流。不过有一种 2n 枚举行看和是否够的方法可以过，可能是数据问题
class CosmicBlocks { public: vector&lt;int&gt;V; int minWays,maxWays; int ans; int n; int ned[11]; int cnt[8]; int bel[11]; int tot;//maxH+1 vector&lt;int&gt;G[11];//edge vector&lt;int&gt;has[11];//v in hi int fa[7]; int occ[7]; int dp[(1&lt;&lt;6)+3]; bool check(){ for(int i=1;i&lt;tot;i++){ vector&lt;int&gt;tmpV=V; for(int j=0;j&lt;has[i].size();j++){ int u=has[i][j]; for(int it=0;it&lt;G[u].size();it++){ int v=G[u][it]; tmpV[v]--; tmpV[u]--; } } for(int j=0;j&lt;n;j++)if(tmpV[j]&lt;0)return 0; for(int mask=0;mask&lt;1&lt;&lt;has[i].size();mask++){ memset(occ,0,sizeof(occ)); int nedcost=0,hascost=0; for(int j=0;j&lt;has[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4772a1499ff52c68e01dbc5753dbfd4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebc15e644e1164349fe0fd92f25eca2c/" rel="bookmark">
			SRM546
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		250 KleofasTail 题意：定义x的生成数列为 f(x)=x&amp;1?x−1:x/2 ,给出K,L,R,询问有多少个位于L,R之间的数，它们的生成数列中至少出现一次K. 0≤L,R,K≤1018 分析： 观察发现生成数列中含有K的充要条件是二进制前缀与K相同(K为奇数)，或者与K+1相同(K为奇数)，因此只要枚举位数，算一下与L,R的交即可
500 FavouriteDigits 题意：求最小的&gt;=N的数满足十进制表示中至少含有d1个c1和d2个c2 d1+d2≤15，N≤1015 分析：根据题目限制，显然答案小于 1015,因此只要数位dp搞搞就可以 1000 FleaCircus 题意：You are given a permutation Q. Count all permutations P such that P^4 = Q
分析：长度为n的循环的四次方的长度为n/gcd(n,4);根据这个结论，如果循环的大小是偶数k，那么对应的n=4k,否则n=k或者2k或者4k;对应的计数可以dp算算，复杂度O(n)；也可以直接枚举2k和4k的；具体来说就是枚举其中一个特殊的循环是构成k的还是2k的还是4k的，对应的转移一下即可
#include &lt;cstdio&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;set&gt; #include &lt;vector&gt; #include &lt;sstream&gt; #include &lt;typeinfo&gt; #include &lt;fstream&gt; using namespace std; const int M=1e9+9; typedef long long LL; const int Maxn=777; class FleaCircus { public: vector&lt;int&gt;V; int n; int cnt[777]; bool done[777]; int F[777],G[777]; int C[777][777]; void getC(){ memset(C,0,sizeof(C)); for(int i=0;i&lt;Maxn;i++)C[i][0]=1; for(int i=1;i&lt;Maxn;i++){ for(int j=1;j&lt;=i;j++){ C[i][j]=(C[i-1][j]+C[i-1][j-1])%M; } } } void getF(){ memset(F,0,sizeof(F)); F[0]=F[4]=1; for(int i=8;i&lt;Maxn;i+=4)F[i]=1LL*C[i-1][3]*F[i-4]%M; memset(G,0,sizeof(G)); G[0]=G[2]=1; for(int i=4;i&lt;Maxn;i+=2)G[i]=1LL*G[i-2]*(i-1)%M; } int powmod(int x,int y,int mod){ int ret=1; while(y){ if(y&amp;1)ret=1LL*ret*x%mod; y&gt;&gt;=1; x=1LL*x*x%mod; } return ret; } int cal(int x,int ty){ if(ty==4)return 1LL*x*x%M*x%M*6%M; if(ty==2)return x; if(ty==1)return 1; return -1; } int solveodd(int x,int y){//x:geshu,y:val int ret=0; int t1=cal(y,4); int t2=cal(y,2); //printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebc15e644e1164349fe0fd92f25eca2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d0679b9e0e1f086c48c7b8b4842aea0/" rel="bookmark">
			SRM545
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 275 StrIIRec 题意：求一个字典序最小的排列满足他的字典序&gt;=minStr并且逆序&gt;=minInv，n&lt;=20
分析：枚举第一个不同的位置，然后从小到大暴力填，判断一下逆序是否足够
500 Spacetsk 题意：求有多少个K元组，满足 0≤x≤L,0≤y≤H 并且它们在一条直线上，且这条直线和x轴有非负整数交点 L,H,K≤2000 分析：枚举与x轴交点再枚举这条直线斜率，枚举斜率可以用反演优化，复杂度 O(n7/4) ，当然也可以直接枚举直线，算一下上下界，复杂度 O(n2logn) 975 SetAndSet 题意：给出n个数，要给这n个数染红色或者蓝色，问有多少种方法使得染红的数的&amp;和与染蓝的相同
分析：容易想到&amp;和不为0必然是因为所有数这一位都是1，因此没必要考虑，只需要考虑&amp;为0的那部分；剩下就是一个容斥，预处理每一位哪些数为0，假如这一位不满足则意味着这一位为0的所有数都染了同一种颜色；注意到方案数与联通块的个数有关，因此只要再dfs的时候并查集维护即可；由于最多只有20个联通快，复杂度可以做到 O(ns∗2ns) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/179f45ef358d06540090eaa8573a65ba/" rel="bookmark">
			iOS 笔记  精确计算 NSDecimalNumber
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天因为出现了 str 转float 的误差问题, 接触到了NSDecimalNumber这个类, 在别人那里找来了一些现成的笔记, 记录一下 /**由于NSDecimalNumber能够存储很大的值（大到38位 x 10^+/-128）。这样进行一些大数值运算时也很方便，但是直接使用C的标量值会比通过NSDecimalNumber更快，所以需要慎重选择该方法。通常来说，这只在集合中使用。
*/
//NSDecimalNumber常见用法
//1.小数位处理及约数方式
NSDecimalNumberHandler * roundUp = [NSDecimalNumberHandlerdecimalNumberHandlerWithRoundingMode:NSRoundBankersscale:2raiseOnExactness:NOraiseOnOverflow:NOraiseOnUnderflow:NOraiseOnDivideByZero:YES]; //保留两位小数（scale）
/** RoundingMode：NSRoundPlain //貌似取整
NSRoundDown, // Always down == truncate //只舍不入
NSRoundUp, // Always up // 只入不舍
NSRoundBankers // on a tie round so last digit is even //貌似四舍五入
**/
NSDecimalNumber *subtotal = [NSDecimalNumberdecimalNumberWithString:@"90.7049"];
NSDecimalNumber *discount = [NSDecimalNumberdecimalNumberWithString:@"0.22"];
NSDecimalNumber *total = [subtotaldecimalNumberByAdding:discount withBehavior:roundUp];
//按照roundUp规定好的进行相加：四舍五入、保留两位小数
NSLog(@"Rounded total: %@", total);
//2.次方计算
NSDecimalNumber*price;
price = [NSDecimalNumberdecimalNumberWithMantissa:1599exponent:-2 //10的－2次方
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/179f45ef358d06540090eaa8573a65ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5673889cfd629ad45f3b9b31d4c2724/" rel="bookmark">
			C &#43;&#43; extern &#34;C&#34;的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在C++的很多代码中，我们经常看到有extren "C"的代码片段，很多人并不清楚其中的含义。而且，我们在C/C++中还会经常看到一个关键字，extren。因此，这样造成了很多的用法和理解上的混淆。
我们先说一下extren关键字，这个关键字在C中就已经存在了，它是用来修饰一个变量的。例如：extren const int m_val；这是告知编译器，该变量已经在其他文件中有所定义，此处是将其进行声明扩展，以便于这个变量在当前文件的使用。这种用法也是为了方便模块间的通信。
再说，extren “C”，当这两个关键字进行组合的时候，它会有两个用法。
1.告知编译器，当前的函数或对象，以C语言的方式进行编译和执行。之所以如此，是因为C++在C语言的基础上，对c 语言的库函数进行了进一步的封装。而我们需要在C++的代码中用到C语言的库函数。因此，通过该方式可以兼容C语言代码。
2.告知编译器，当前函数不要偷换函数名。何意？因为C++中有一个函数名重载机制，即相同的函数名，不同的参数列表，用以实现接近的功能。而所谓的相同的函数名，其实是为了方便程序员阅读理解，在C++编译器中，都会对函数名进行添加符号。例如：
int Add(int a,int b);//在编译之后，函数名可能为 Add_fun_a_b. int Add(float a,float b);//在编译之后，函数名可能为Add_fun_floatab; 当我们不希望编译器将函数名更改时，则引入extren "C"。即告知编译器，被修饰的函数，在编译之后，函数名仍然不被修改。 当然，第二种在实际使用中并不常见，而在一些dll的编写过程中，则是大量的出现。
为什么会有这种需求呢?这就不得不称赞C++设计者的高明和灵活之处了。由于编译器厂商的不同，对C++的实现方式也有不同。不同的编译器对相同的函数名重载的规则略有不同，即编译之后的函数名会不同。而对于dll而言，我们需要兼容不同的编译器，所以阻隔掉因编译器类型不同，而造成的函数入口无法正确定位的问题。所以，才会有这种的使用方式。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a052e14db05f4e075c03a0c57778850a/" rel="bookmark">
			rdlc打印多出空白页的问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.控件的left+width要小于打印机的宽度，比如打印机是80mm，可用空间是72mm，那么rdlc内的控件left+width（之和）&lt;=72mm
2.注意一下这个细节，请看图1-2：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93eaef3ce2b34eafaa1f426ed131d53d/" rel="bookmark">
			smbusers
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 shareuser = "network username" fanlh = "network username" beijy = "network username" hzs = "network username" lyz = "network username" zhuozm = "network username" 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02508358b847f0a27158bc360d03f515/" rel="bookmark">
			smb.conf
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# # Sample configuration file for the Samba suite for Debian GNU/Linux. # # # This is the main Samba configuration file. You should read the # smb.conf(5) manual page in order to understand the options listed # here. Samba has a huge number of configurable options most of which # are not shown in this example # # Some options that are often worth tuning have been included as # commented-out examples in this file.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02508358b847f0a27158bc360d03f515/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ae0ae3b02069de35ab4f86cbdb7faef/" rel="bookmark">
			经典蓝牙连接-蓝牙音箱或蓝牙耳机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		生活中我们经常使用蓝牙耳机来接听电话，而隨著科技的進步，現在蓝牙多了一种新的规范：A2DP(Advance Audio Distribution Profile)，可以用 44.1 kHz 的 來传输声音，因此現在可以使用蓝牙耳机來享受音樂，接下來就來介紹如何在 Android 中连接 A2DP 的蓝牙设备。
使用 Bluetooth 最主要的一個类就是 BluetoothAdapter，我們会通过这個类來启动、停止蓝牙或做搜索 (Discovery)蓝牙设备的动作，首先我們先取得该类实例：
mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter(); 接著查看蓝牙是否有開啟，沒有的話我們直接將蓝牙设备打开：
public boolean enableBluetooth() { if (!mBluetoothAdapter.isEnabled()) { if (!mBluetoothAdapter.enable()) { return false; } } return true; } 成功启动蓝牙後，我們就可以開始來搜索周围的蓝牙设备了。在探索之前，我們必須先注册 Broadcast Receiver ，因為搜索到的蓝牙设备会通过 Broadcast 的方式通知。 这里注册BluetoothDevice.ACTION_FOUND 以及 BluetoothAdapter.ACTION_DISCOVERY_FINISHED：
IntentFilter intentFilter = new IntentFilter(); intentFilter.addAction(BluetoothDevice.ACTION_FOUND); intentFilter.addAction (BluetoothDevice.ACTION_BOND_STATE_CHANGED); intentFilter.addAction (BluetoothAdapter.ACTION_SCAN_MODE_CHANGED); intentFilter.addAction (BluetoothAdapter.ACTION_STATE_CHANGED); // 注册广播接收器，接收并处理搜索结果 registerReceiver(mReceiver, intentFilter); 接著我們就可以通过BluetoothAdapter 來搜索周围的 蓝牙设备 了： public void startDiscovery() { if (mBluetoothAdapter !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ae0ae3b02069de35ab4f86cbdb7faef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dffc75e37d762645043338a174f0fb6/" rel="bookmark">
			C#.net4建设网页上传图片前客户端预览图片不能显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		搞了好半天，完全照教学资料设的javascrip脚本，但就是显示不了，后来才发觉，原来客户端要把该网站设为信任才能显示。
所以记录一下，以后备查。
&lt;script type="text/javascript"&gt;
function showphoto() {
alert(document.getElementById("FileUpload1").value);
//把所选图片的全路径+文件名以“file:///R:\test.jpg”赋给预览控件Image1.src
//注意：要把客户端对本站点设为信任，才能执行该脚本预览图片。
document.getElementById("Image1").src = document.getElementById("FileUpload1").value;
}
&lt;/script&gt;
&lt;asp:FileUpload ID="FileUpload1" runat="server" Height="19px" Width="222px" οnchange="javascript:showphoto();"/&gt;
&lt;asp:Image ID="Image1" runat="server" Height="93px" Width="103px" AlternateText="没选图片"/&gt;
转载于:https://www.cnblogs.com/yxlq/p/5658411.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f43b415f20cc8a18e7f0f3b44c380869/" rel="bookmark">
			MySQL基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.运算符 一种符号，它是用来进行列间或者变量之间的比较和数学运算的，分为算术运算符、赋值运算符、比较运算符、逻辑运算符 四种。
算术运算符
运算符 说 明
+ 加运算，求两个数或表达式相加的和，如6+8
- 减运算，求两个数或表达式相减的差 * 乘运算，求两个数或表达式相乘的积 / 除运算，求两个数或表达式相除的商，如5/3的值为1
% 取模运算，求两个数或表达式相除的余数，如：5%3的值为2 赋值运算符
运算符 说 明
= 把一个数或变量或表达式赋值给另一变量，如：Name='王华' 比较运算符
运算符 说 明
AND 当且仅当两个布尔表达式都为true时，返回TRUE。
OR 当且仅当两个布尔表达式都为false，返回FALSE。
NOT 对布尔表达式的值取反 逻辑运算符
运算符 说 明
= 等于，例如：age=23 &gt; 大于，例如：price&gt;100 &lt; 小于 &lt;&gt; 不等于
&gt;= 大于等于
&lt;= 小于等于
!= 不等于（非SQL-92标准 ）
二.语句 插入数据行语法 :INSERT [INTO] 表名 [(列名)] VALUES (值列表)
例子：
insert into Students (name,SCode,SAddress,SGrade,SEmail) values ('张青裁',2,'新加坡科技园',1,'ZQC@Sohu.com') ; 注意： 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f43b415f20cc8a18e7f0f3b44c380869/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b693967581847dfbb8202d991388e0da/" rel="bookmark">
			编程开发经验谈:其实Unix很简单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载此文的原因是我对作者提到Windows的一些缺点很认同 很多编程的朋友都在网上问我这样的几个问题，Unix怎么学？Unix怎么这么难？如何才能学好？并且让我给他们一些学好Unix的经验。在绝大多数时候，我发现问这些问题的朋友都有两个特点：
1）对Unix有畏难心理，对其没有信心； 2）喜欢用拿Windows来和Unix做比较。 这两种特点就像两个“心理暗示”，暗示着自己Unix很不好学，暗示着Unix很糟糕，不如Windows好。于是，自己也就被自己的这种长期的“暗示” 所催眠了。因为，从一开始就有畏难情绪，所以也就觉得Unix不好，觉得非常很吃力，最后还会导致对Unix的厌恶和反感的情绪。所以，为了纠正上述朋友们的“心理暗示”。我想写下这篇文章，想告诉大家，Unix真的很简单。 在正式叙述“简单的Unix”之前，我想做几点说明：（以免陷入无意义的争论） 1） 本文是站在开发者的角度来说明的，所以，如果有朋友不同意我的观点，请也以开发者的角度来向我提出质问和讨论，本人非常欢迎。 2） 本文难免要用Windows来和Unix做对比。这并不代表我不喜欢Windows，也不代表我要叫你放弃Windows。我们也知道这种对比已经没有什么意思了，但因为众多的朋友被Windows先入为主了，所以，我一定要拿Windows来开刀，才能扭转那个“心理暗示”。仅此而已。 OK，言归正传。先说Unix的一个最重要的特点——“高内聚，低藕合”！也就是说，Unix下的各种应用程序都和别人不相干。这就是贯穿整个Unix的思维——模块和程序的高度独立性。这样的设计和做法，会让你的系统比较的稳定，也会让你的系统特别地容易管理和维护。Unix下的应用程序们就像一支正规军一样排列地整整齐齐，只要司令（内核）还在，系统是不会因为某个军队的损失而无法自举的。而Windows的应用程序们就像一片树林一样，从地表上看过去，树木们排列地整整齐齐，但是他们的树根在地下却相互缠绕在一起，剪不断，理还乱，异常地复杂。 “高内聚，低藕合”的给Unix造成的结果是，其系统中基本上都是功能单一的小程序，这些小程序就像积木一样，当我们需要构造建一个自定义的建筑时，大多数情况下，我们只需要做的只是一个“搭积木”的简单游戏。Windows建设得富丽堂皇，可惜，别人的“积木”你几乎不可能拿到自己的建筑中来。总是要你模仿或重写。 （插一句：你是否注意到在网上下载Windows的软件时，会有一种所谓的“绿色软件”？这就是对Windows的最大讽刺，Windows下装一个软件，N个DLL放到Windows系统目录下，注册表里写入N个键值，还有很多你不知道的动作。而在Unix装软件，你不用担心你的系统目录下会莫明其妙地多出些乱七八糟的文件。就是copy那么简单，那怕是rpm自动安装，安装完后，你也能够查询到软件安装后对系统所做的改变。所以，你在Unix下分发你的软件时，你会觉得比Windows下要做得简单了许多许多。） 再说说Unix的另一个最重要的特点——“所有的设备都可以像文件一样地操作”。简单吧。所有的调备，文件、打印机、显示器、终端、网络、软盘、磁带、USB、CDROM、等等的I/O操作，都以文件描述符的方式进行操作。两个Unix下最重要的系统调用read/write就可以胜任所有设备的I/O了。Unix早就在/dev目录下为你建好了这些文件。使用起来很简单。 也许很多人都觉得Unix的命令行太过复杂。一个命令有着若干的参数，异常地复杂。但之所以今天Unix下的应用程序还在以字符界面为主，这恰好体现了Unix的简单的特征。这也是Unix的另一个特点——“命令的相互支持性”，命令们通过一个管道或是重定向，可以互相联系在一起，再加以 Shell脚本的支持，哪怕要实现一些复杂的功能（比如一个小型的文本数据库），也是简单之极。 如果上面的论述依然不能让你信服Unix很简单，那么，让我们来用一些具体地实际的例子来看一下，Unix是如何简单的。让我们试着做下面的这样一个假设：“如果我们在学习编程的时候一开始是学Unix，然后转去做Windows”，那会是怎么样的一个情况？ 1） 我们在Unix下创建进程，使用fork调用。到了Windows下，我们查了MSDN，发现了一个叫CreateProcess的系统调用可以创建进程，但我们却发现这个系统调用有10个参数。而Unix下的fork却一个参数都没有。这种情况下，你是否会有一种头大的感觉？因为，在Unix 下，你根本看不到会有10参数这样复杂的系统调用API。 2） 我们在Unix下操作文件权限很简单，文件权限分三组（本人，同组，别人），每组都是可读，可写，可执行。两个简单的系统调用 chmod/chown就搞定。到了Windows下，如果是NTFS，如果要以程序的方式设置文件权限，呵呵，你需要先了解什么是：SID，什么是 DACL，什么是SACL，什么是ACE，还有十几相关的系统API函数等着你。（参看我的《以程序操作NTFS文件权限》）你也许会觉得这么复杂的安全策略是让系统更安全的基础，可以自从Windows出现的那一天以后，在安全方面的表现就没有胜过Unix。这无疑让人感到Windows做了一件吃力不讨好的事。 （插一句：Unix下的用户切换是相当简易方便的。而Windows下的用户切换会导致你需要退出当前用户的前台程序。这导致了Windows下的用户几乎无一例外地都会选择在超级用户的权限下工作/上网，这完全是让自己的机器在裸奔，所以，Windows下的病毒一旦在系统中运行就为所欲为了。而Unix下，很少用户会以root身份操作本机，因为切换用户非常方便。） 3） 在Unix下，用户有ID，用户组有ID，进程/线程都有ID。ID很简单易懂，就像我们的身份证一样。到了Windows下，用户标识叫 Token，进程标识叫Handle（其实也就是一个DWORD的类型），我看到网上很多问题都在问Windows下的Handle的概念问题。我一直在想，为什么微软不取一个简单易懂的术语？要取得那么抽象，那么让人很迷惑。虽然这让Windows看起很NB，但也会因此加大了学习复杂度。（Windows的开发学习复杂度要比Unix复杂多了，而且有太多的看似很高深的术语让人一头雾水） 4） 让我们再来看一下用户管理和程序所有者方面的东西。在Unix下，需要你做的是配置NIS服务器和NFS服务器（以Autofs自动 mount），简洁，清楚。到了Windows下，与其相似的是一个叫Domain的东西（主域控制器），首先，为了加入域，你需要重启电脑（Unix下只需要配置/etc/nsswitch.conf文件来告诉本机的用户登录源，无需重启），而对开发者来说，Unix的这个配置对程序是完全透明的。而 Windows的域用户和本地用户需要一个域名来区分。在程序中切换用户时，Unix只需要setuid/seteuid就行了，Windows对此有三个比较复杂的API：CreateProcessAsUser, ImpersonateLoggedOnUser, LogonUser，其复杂度就不用比较了。另外，在Domain方式下，你的Document and Setting目录下的文件，会全部放到Domain服务器上去，你在别的机器上登录时，需要下载这些文件。最后，我倒不担心你和网友的MSN聊天记录会因为你的登录而到处都是，我担心的是，你在这么复杂的管理环境中写出来的代码是否能让别人放心？:-( 5） 在Unix下，要把自己的程序加入系统的启动服务只需要在/etc/init.d中配置就行了。写下一个有启动停止功能脚本，以特殊命名的方式链接到不同启动模式目录下就行了。Windows下加一个启动服务，如果你不编写程序，估计比较困难。 6） 在Unix下，如果要取得系统的信息。只需要到/proc目录下去cat那堆文件。所有进/线程的状态、命令行、内存/交换区使用情况、打开的文件描述符，等等，系统的CPU，内存，交换区，内存文件IO，分区，信息，网络，系统运行状态，系统设备，等等，要有多详细就有多详细，而且完全是纯文本的，直接就可以看了。到了Windows下，要穷举系统当前进程的信息，就不是一样很容易的事，更别说要取得别的信息了。 我很佩服微软把操作系统搞得那么复杂，又是注册表，又是安全策略，又是OLE，又是COM……。每次打开regedit.exe时，我根本不敢碰HKEY_CLASSES_ROOT，因为我看着里面那些成千上万个CLSID，我有点晕菜。 自1995年以来，10来年过去了。微软推出了多种各式各样的技术。我还记得Visual Studio 6.0中还有两个叫做FoxPro和J++的东西，FoxPro来自Foxbase，还有个几年，J++好像就没有几年。ActiveX Control完全是一个失败的技术，而那个叫做VB的编程语言，今天看来，它的确毁了很多很有潜力的程序员。在COM出现的时候，不知道今天还有多少人还记得一个叫MTS的玩意？今天，不知道还有多少人记得有一个叫ODBC的东西？在这种复杂混乱的Windows世界中，是否让你疲于追赶？今天的.NET不知道又有多少技术会随着时间所沉淀？在Windows上面，我们学习了许多的失败技术或是说是过渡技术。而我们的Unix自从上纪70年代以来，就没有多大的变化，而因为Unix应运而生的C语言直到今天依然光彩夺目。我相信这个30多年来久经考验还那么简单的Unix。 Unix就是这么简单，各位想在Unix下学开发的朋友，Windows那么复杂的操作系统都过来了，你还会怕这么简单的Unix么？
转载地址:http://www.lupaworld.com/portal.php?mod=view&amp;aid=213078&amp;page=all
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67ba176a75951501cffc41002cc81aff/" rel="bookmark">
			file_get_contens  POST传值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;?php echo "&lt;pre&gt;"; print_r($_POST); print_r($_COOKIE); ?&gt; 本文讲述的只是http post请求的发送,所以,目标页只是回显所收到的post和cookie
2.请求页
request.php
&lt;? $data = array("name" =&gt; 'tim',"content" =&gt; 'test'); $data = http_build_query($data); $opts = array( 'http'=&gt;array( 'method'=&gt;"POST", 'header'=&gt;"Content-type: application/x-www-form-urlencoded\r\n". "Content-length:".strlen($data)."\r\n" . "Cookie: foo=bar\r\n" . "\r\n", 'content' =&gt; $data, ) ); $cxContext = stream_context_create($opts); $sFile = file_get_contents("http://localhost/response.php", false, $cxContext); echo $sFile; ?&gt; 这个文件首先使用stream_context_create()构造了一个http请求,然后使用file_get_contents发送出去,返回的结果是:
Array ( [name] =&gt; tim [content] =&gt; test ) Array ( [foo] =&gt; bar ) 所以上可以看出,只要你了解http协议,完全可以使用这两个函数构造出所有正常的http请求,比如代理,断点续传等…
&lt;?php $option = array( 'http' =&gt; array( 'method' =&gt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67ba176a75951501cffc41002cc81aff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9461100baabd3663d2ef799a2ae088b/" rel="bookmark">
			Android模块化编程——WebView使用之清理缓存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		清理缓存： 在WebView使用中可能会遇到一个问题，那就是加载了很多页面，退不出去了，你需要一直按返回键很多次。体验非常差。这是你除了按照上篇博客，在特定网页捕获返回键。还可以清理缓存。 // 清理缓存 private void clearHistory() { mWebView.postDelayed(new Runnable() { @Override public void run() { mWebView.clearHistory(); } }, 1000); } 这里为啥要延迟1s呢？这是WebView内部缺陷， 如果你不延迟1s，她会保留新页面的前一页。下面是我如何调用。 private View.OnClickListener mListener = new View.OnClickListener() { public void onClick(View paramAnonymousView) { MainActivity.this.showMainWeb(); MainActivity.this.mWebView.stopLoading(); // if (MainActivity.this.selectedView != null) switch (paramAnonymousView.getId()) { case R.id.activity_main_iv_index: // mWebView.clearCache(true); MainActivity.this.mWebView.loadUrl(MainActivity.this.serviceURL + "index.aspx"); ((ImageView) paramAnonymousView).setImageResource(R.drawable.bt_bg_index_selected); // btIndex.setImageResource(R.drawable.bt_bg_index); btWeiXin.setImageResource(R.drawable.bt_bg_type); btContactUs.setImageResource(R.drawable.bt_bg_contact_us); btShoppingCart.setImageResource(R.drawable.bt_bg_shopping_cart); btMine.setImageResource(R.drawable.bt_bg_mine); clearHistory(); return; case R.id.activity_main_iv_weixin: // mWebView.clearCache(true); MainActivity.this.mWebView.loadUrl(MainActivity.this.serviceURL + "category.aspx"); ((ImageView) paramAnonymousView).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9461100baabd3663d2ef799a2ae088b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a716980e462002798c67085bc5ba953e/" rel="bookmark">
			Windows 10 连接 Zune 直接拷歌的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 昨天买了一台 Zune 来怀旧，其系统是 1.0 TEST 版本系统，但是发现在电脑系统为 Windows 10 时，设备连接上电脑后，会自动更新驱动，然后就无法识别为可移动设备，必须通过微软提供的 Zune Software 进行歌曲的传输。但是如此一来，原本在里面的歌曲就无法读取到了，所以决定还是使用直插直拷的方式。
在网上搜索一圈后，发现大部分地方提供的方法不外乎两种
断网，卸载驱动，手动安装为 USB 设备使用策略组禁止设备安装驱动 这两种方法都不是太好，第一种方法可以达到目的，但是每次都得断网，而且要手动重做一遍卸载驱动的动作，太麻烦，第二种方法根本不可行，因为禁止安装驱动的话，会让你手动安装驱动也失败。摸索后发现，可以通过设置，让系统不自动更新驱动程序，来达到目的，方法如下：
在“此电脑”图标上单击鼠标右键，菜单中点击“属性”； 在系统界面，点击左侧“高级系统设置”； 在系统属性对话框内，点击顶部的“硬件”选项卡，在设备安装设置项目下面的“设备安装设置”； 在设备安装设置界面，首先点击选择“否，让我选择要执行的操作”，随后下面会出现不同选项，取消默认设置，点击选择“从不安装来自Windows更新的驱动程序软件”后，点击底部“保存更改”就可以了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad68189931d01bc51c337f8cc62c9803/" rel="bookmark">
			跟我学Android之九  日期时间组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本章内容
第1节 AnalogClock和DigitalClock
第2节 CalendarView
第3节 DatePicker和TimerPicker
第4节 Chronometer
第5节 Timer类
本章目标 掌握图形时钟和数字时钟的用法。
掌握日历视图的用法。
熟练掌握日期和时间选择器的用法。
熟练掌握Chronometer的用法。
熟练掌握Timer类的用法。
AnalogClock是一个模拟时钟视图，使用AnalogClock标签进行布局，除了长宽外基本需要其他属性，对应的Java类是android.widget.AnalogClock，布局示例如下： &lt;AnalogClock android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt; DigitalClock是一个数字时钟视图，使用DigitalClock标签进行布局，除了长宽外基本需要其他属性，对应的Java类是android.widget.DigitalClock，布局示例如下：
&lt;DigitalClock android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt; 日历视图CalendarView，可用于显示和选择日期
&lt;CalendarView android:layout_width="match_parent" android:layout_height="match_parent" android:firstDayOfWeek="3" android:shownWeekCount="4" android:selectedWeekBackgroundColor="#aff" android:focusedMonthDateColor="#f00" android:weekSeparatorLineColor="#ff0" android:unfocusedMonthDateColor="#f9f" android:id="@+id/calendarView" /&gt; 事件，选项改变事件 public void onSelectedDayChange(CalendarView view, int year, int month, int dayOfMonth) { // 使用Toast显示用户选择的日期 Toast.makeText(CalendarViewTest.this, "你生日是" + year + "年" + month + "月" + dayOfMonth + "日" , Toast.LENGTH_SHORT).show(); } }); DatePicker是一个用于日期选择的控件，使用DatePicker进行布局，常用属性如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad68189931d01bc51c337f8cc62c9803/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b87d1bf4060493a15439f5ffb9331dc2/" rel="bookmark">
			bean的加载（二） FactoryBean的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般情况下，Spring通过反射机制利用bean的class属性指定实现类来实例化bean.某些情况下，实例化bean过程比较复杂，如果按照传统的方式，则需要在&lt;bean&gt;中提供大量的的配置信息，配置方式的灵活性是受限的，这是采用编码的方式可能会得到一个简单的方案。Spring为此提供了一个org.Springframework.bean.factory.FactoryBean的工厂类接口，用户通过实现该接口定制实例化bean的逻辑。
FactoryBean接口对于Spring框架来说占有重要的地位，Spring自身就提供了70多个FactoryBean的实现。它们隐藏了实例化一些复杂bean的细节，给上层应用带来了便利。从Spring3.0开始，FactoryBean开始支持泛型。FactoryBean&lt;T&gt;。
该接口中定义了3个方法。
T getObject():返回由FactoryBean创建的bean实例，如果isSingleton()返回true,则该实例会放到Spring容器中单例缓存池中。boolean isSingleton();返回由FactoryBean创建的bean实例的作用域是singleton还是prototype.Class&lt;T&gt; getObjectType():返回FactoryBean创建的bean类型 当配置文件中&lt;bean&gt;的class属性配置的实现类是FactoryBean时，通过getBean（）方法返回的不是FactoryBean本身，而是FactoryBean#getObejct()方法所返回的对象，相当于FactoryBean#getObject（）代理了getBean()方法。例如如果使用传统方式配置下面Car的&lt;bean&gt;属性时，Car的每个属性分别对应一个&lt;property&gt;元素标签。
public class Car{
private int maxSpeed;
private String brand;
private double price;
}.
如果用FactoryBean的方式实现就会灵活一些，下例通过逗号分隔符的方式一次性地为Car的所有属性指定配置值：
public class CarFactoryBean implements FactoryBean&lt;Car&gt;{
private String carInfo;
}
有了这个CarFactoryBean后，就可以在配置文件中使用下面这种自定义的配置方式配置CarBean了：
&lt;bean id="car" class="com.test.factorybean.CarFactoryBean" carInfo="超级跑车，400，200000"/&gt;
当调用getBean("Car")时，Spring通过泛着机制发现CarFactoryBean实现了FactoryBean的接口，这时Spring容器就调用接口方法CarFactoryBan#getObject()返回。如果希望获取CarFactoryBean的实例，则需要在使用getBean(beanName)方法时候在beanName前面加上”&amp;“前缀，例如getBean("&amp;Car").
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2009a7f35d699726f5cbf8c4d570d06/" rel="bookmark">
			struts2 登录拦截，以及涉及到的session的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、struts2 拦截登录
功能描述：登录进去的用户存在session中，若用户执行退出系统或者未登录系统，则无论访问哪个action或者页面，只能停在登录页面。
实现：
1.LoginInterceptor.java
public class LoginInterceptorimplements Interceptor
{
privateString exclude;
public void destroy()
{
// TODO Auto-generated method stub
}
public void init()
{
// TODO Auto-generated method stub
}
publicString intercept(ActionInvocation arg0) throws Exception
{
//若为登录的action则不拦截
String actionName =arg0.getProxy().getActionName();
// System.out.println("************actionName:"+ actionName);
if(exclude.equals(actionName))
{
return arg0.invoke();
}
ActionContext ac =arg0.getInvocationContext();
Map session = ac.getSession();
AdminInfoadmin = (AdminInfo) session.get("admins");
if(admin != null)
{
returnarg0.invoke(); }
else
{
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2009a7f35d699726f5cbf8c4d570d06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/646c154c66544505a3c74f3b98eac983/" rel="bookmark">
			Java 入门--在控制台下运行java程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 基础知识---在控制台下运行java程序 1.如何在控制台运行一个java程序？？
原理：javac是编译命令，经过编译之后，生成一个.class文件，java是执行命令
主要代码：javac 类名.java(一定要使用.java后缀)
java 类名(一定不能加.java后缀)
步骤如下：
1)使用MyEclipse,在E:\workspace下，新建一个Java Project,名为Basic1
2)创建一个在com.etc.demo下的ConsoleDemo.java,自动生成main方法
代码如下：
package com.etc.demo; public class ConsoleDemo { public static void main(String[] args) { System.out.println("Hello World!"); } } 3)win+R ,cmd 切换到控制台:
4)对控制台进行操作
C:\Users\Administrator&gt;E:
E:&gt;cd E:\workspace\JavaBasic\Basic1\src\com\etc\demo
E:\workspace\JavaBasic\Basic1\src\com\etc\demo&gt;javac ConsoleDemo.java(未执行之前，目录下还是只有ConsoleDemo.java文件，执行完之后，多了.class文件)
E:\workspace\JavaBasic\Basic1\src\com\etc\demo&gt;java ConsoleDemo
Hello World
其中有一个问题：
执行E:\workspace\JavaBasic\Basic1\src\com\etc\demo&gt;java ConsoleDemo执行
找不到或无法加载主类的错误一直存在！！！！！！！！！！！(环境变量配置成功，编译也能通过，MyEclipse下可以执行成功)
最后在src目录下创建ConsoleDemo.java，使用javac,java命令才能运行成功！！
说是与包的问题有关，但是执行时，使用 java 包名.类名 仍旧不能成功！！
究竟包对控制台有什么样的影响？？？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8576a2274ceac12197e2a853359f88a5/" rel="bookmark">
			HTML5区块和大纲算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：
Using HTML sections and outlines - Mozilla Developer Network每集HTML5+CSS3网页布局教程-2大纲算法 HTML5标准带来了几个带有标准语义的新元素来描述Web文档结构。本文会介绍这些元素，并且讨论如何用这些元素定义令人满意的文档大纲。 HTML4时代的文档结构 文档的结构（或者可以说在body标签之间的结构）是展示和表现web页面的基础。HTML4使用了区块（sections）和子区块（sub-sections）的概念来描述文档的结构。使用div元素来定义一个区块，并且使用标题元素（h1-h6）来定义这个区块的标题。它们之间的关系决定了web文档的结构和大纲。
下面的这些代码：
&lt;div class="section" id="forest-elephants" &gt; &lt;h1&gt;Forest elephants&lt;/h1&gt; &lt;p&gt;In this section, we discuss the lesser known forest elephants. ...this section continues... &lt;div class="subsection" id="forest-habitat" &gt; &lt;h2&gt;Habitat&lt;/h2&gt; &lt;p&gt;Forest elephants do not live in trees but among them. ...this subsection continues... &lt;/div&gt; &lt;/div&gt; 可以提炼出如下的大纲：
1. Forest elephants 1.1 Habitat 定义一个大纲中的节点不一定非要使用div元素，其实，只要一个标题元素（h1-h6）就已经足够用来暗示一个节点了，所以这些标签：
&lt;h1&gt;Forest elephants&lt;/h1&gt; &lt;p&gt;In this section, we discuss the lesser known forest elephants.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8576a2274ceac12197e2a853359f88a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d4694741c96d8f7a5039f596502b55a/" rel="bookmark">
			搭建elasticsearch集群及故障转移（3）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、书接上文
上篇博客说到单台es状态为yellow，需要搭建集群解决。如果你资源有限只有一台机器, cp一个elasticsearch，使用相同命令在本机再启动一个es实例，再次检查集群健康, 发现unassigned_shards减少, active_shards增多。下面看es介绍、es配置文件和es集群搭建。
二、es介绍
1、elasticsearch(下文称es)是一款分布式且高可扩展的全文搜索和分析引擎，本身是基于Lucene进行开发，但ES足够简单易用，提供丰富的API，部署容易。elasticsearch 已经提供了大部分设置，都是合理的默认配置。所以你不必进行烦人的配置就可以尝试一下。大多数时候，这些默认的配置就足以运行一个生产集群了。
2、分片以及水平扩展.
elasticsearch用于构建高可用和可扩展的系统。扩展的方式可以是购买更好的服务器(纵向扩展)或者购买更多的服务器（横向扩展）,elasticsearch能从更强大的硬件中获得更好的性能，但是纵向扩展也有一定的局限性。真正的扩展应该是横向的，它通过增加节点来传播负载和增加可靠性。对于大多数数据库而言，横向扩展意味着你的程序将做非常大的改动来利用这些新添加的设备。对比来说，elasticsearch天生是分布式的：它知道如何管理节点来提供高扩展和高可用。
3、集群和节点
节点(node)是你运行的elasticsearch实例。一个集群(cluster)是一组具有相同cluster.name的节点集合，他们协同工作，共享数据并提供故障转移和扩展功能，当有新的节点加入或者删除节点，集群就会感知到并平衡数据。集群中一个节点会被选举为主节点(master),它用来管理集群中的一些变更，例如新建或删除索引、增加或移除节点等,当然一个节点也可以组成一个集群。
4、节点通信
我们能够与集群中的任何节点通信，包括主节点。任何一个节点互相知道文档存在于哪个节点上，它们可以转发请求到我们需要数据所在的节点上。我们通信的节点负责收集各节点返回的数据，最后一起返回给客户端。这一切都由elasticsearch透明的管理。
4、分片(shard)与副本分片(replica shard)
分片用于elasticsearch在你的集群中分配数据。想象把分片当作数据的容器。文档存储在分片中，然后分片分配给你集群中的节点上。当你的集群扩容或缩小，elasticsearch将会自动在你的节点间迁移分片，以使集群保持平衡。
一个分片(shard)是一个最小级别的“工作单元(worker unit)”,它只是保存索引中所有数据的一小片.我们的文档存储和被索引在分片中，但是我们的程序不知道如何直接与它们通信。取而代之的是，他们直接与索引通信.elasticsearch中的分片分为主分片和副本分片,复制分片只是主分片的一个副本，它用于提供数据的冗余副本，在硬件故障之后提供数据保护，同时服务于像搜索和检索等只读请求，主分片的数量和复制分片的数量都可以通过配置文件配置。但是主切片的数量只能在创建索引时定义且不能修改.相同的分片不会放在同一个节点上。
5、集群生态:
(1)、同集群中节点之间可以扩容缩容
(2)、主分片的数量会在其索引创建完成后修正，但是副本分片的数量会随时变化
(3)、相同的分片不会放在同一个节点上
6、集群健康(cluster health)
es中用三种颜色状态表示:green，yellow，red.
green：所有主分片(Primary Shard)和副本分片(Replica Shard)都可用
yellow：所有主分片可用，但不是所有副本分片都可用
red：不是所有的主分片都可用
[root@ossec-server plugins]# curl -XGET http://localhost:9200/_cluster/health\?pretty
{
"cluster_name" : "elasticsearch", #集群的名字
"status" : "yellow", #集群的状态 "timed_out" : false,
"number_of_nodes" : 2, #节点数
"number_of_data_nodes" : 1, #数据节点数
"active_primary_shards" : 216, #主分片数，216个index库
"active_shards" : 216, #共有216个分片
"relocating_shards" : 0,
"initializing_shards" : 0,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d4694741c96d8f7a5039f596502b55a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81fafd00d71ebee3d178fd7a9a7923ae/" rel="bookmark">
			qt android 开发篇之如何实现圆盘（hsv）颜色选择器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在很多情况，我们开发应用的时候经常会用到颜色选择器，大一的时候我做一个涂鸦软件的时候遇到的一个问题，就是如何在qt上做一个圆盘的
颜色选择器，这次做一个例子来让大家了解这种控件是怎么做的。
首先我们要理解颜色中的hsv的概念，大家可以直接百度hsn color 的颜色分布原理
首先给大家介绍hsv颜色选择器的原理：
看上图是qt文档中qcolor的帮助文档，我就是用这个类来实现颜色数据转换的，图中的点对应的是hsv中的h(Hue)的值，值范围为（0,360）整形，而且它的颜色区间对应着这个值如上图所示。很好，就这里我们能
联想到360刚好是一个颜色圆盘选择器的起点。
接下来我们要理解hsv中的s的值，如上图，我们看到不管圆盘的角度怎么样，大家发现越靠近中间颜色是不是越白？对，s的值就是这里的奥妙。s值是颜色的饱和度，它的值范围是0~255整形。通过这个我们应该大致知道颜色圆盘选择起是怎么实现了吧？
最后一步就是理解v值，v值的意思就是颜色的深度值，从上图我们就可以知道
好了基本的概念都有了，我们就可以在qt中做这个颜色圆盘选择器了！看下图效果：
对于QColor这个类就不详细介绍了，大家可以自己在帮助文档中参考参考，耐心半个小时就能活用这个类啦！
由于在使用颜色选择器的时候需要用到Hsv 转换RGB，qt友好的帮我们解决了这个麻烦的公式问题，就在qcolor中！
我们先写一个专门转换颜色格式的类：
colortransformer.h
#ifndef COLORTRANSFORMER_H #define COLORTRANSFORMER_H #include "jni.h" #include &lt;QObject&gt; #include &lt;QColor&gt; class ColorTransFormer: public QObject { Q_OBJECT public: ColorTransFormer(); ~ColorTransFormer(); Q_INVOKABLE void set_hsv(int h,int s,int v){ mcolor.setHsv(h,s,v); } Q_INVOKABLE int get_red(){ return mcolor.red(); } Q_INVOKABLE int get_blue(){ return mcolor.blue(); } Q_INVOKABLE int get_green(){ return mcolor.green(); } Q_INVOKABLE QColor get_rgb(){ return mcolor.toRgb(); } Q_INVOKABLE int get_h(){ return mcolor.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81fafd00d71ebee3d178fd7a9a7923ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5493da17f97e952b1fa5421d1a1fd0d/" rel="bookmark">
			qt android 开发之wifi开发篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小编简单介绍如何通过调用android API来获取wifi服务（
非常感谢作者安晓辉发布了qt android 核心编程这本书，让我两天搞懂了很多在qt中开发安卓的要领，现在跟大家分享下！至于还没知道
怎么配置qt android换将的开发者，极力推荐先去看看qt android 核心编程这本书（哈哈，一知道要出这本书， 还没出版的时候我天天看着京东
有货了没！）
上代码！
工程源码(这些都是大二大三时候造的,代码可能有点烂)
ExtendsQtWithJava.java
package an.qt.extendsQtWithJava; import android.app.PendingIntent; import android.widget.Toast; import android.os.Handler; import android.os.Message; import android.util.Log; import android.net.ConnectivityManager; import android.net.NetworkInfo; import android.net.Uri; import android.location.LocationManager; import android.location.Criteria; import android.provider.Settings; import android.location.Location; import android.location.LocationListener; import android.location.LocationProvider; import java.lang.ClassLoader; import dalvik.system.DexClassLoader; import java.lang.reflect.Field; import android.os.Bundle; import android.os.Environment; import java.io.File; //tommego import java.util.List; import android.net.wifi.ScanResult; import android.net.wifi.WifiConfiguration; import android.net.wifi.WifiInfo; import android.net.wifi.WifiManager; import android.net.wifi.WifiManager.WifiLock; import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5493da17f97e952b1fa5421d1a1fd0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3db6289909b3621d3d3be8792b51d966/" rel="bookmark">
			(自定义view)点击“更多”查看更多，自定义collapsibletextview;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先自定义view，直接上代码public class collapsible extends LinearLayout{ private LinearLayout containner; private TextView textView1; private TextView textView2; public int showType = 0; public collapsible(Context context, AttributeSet attrs) { super(context, attrs); containner = (LinearLayout) inflate(context,R.layout.collapsible_main,this); textView1 = (TextView) containner.findViewById(R.id.show_view); textView2 = (TextView) containner.findViewById(R.id.show_button); textView2.setOnClickListener(new OnClickListener() { @Override public void onClick(View view) { if(showType ==0){ showType = 1; }else { showType = 0; } requestLayout(); } }); TypedArray typedArray = context.obtainStyledAttributes(attrs,R.styleable.collapsible); textView1.setText(typedArray.getString(R.styleable.collapsible_collapsibletext)); typedArray.recycle(); } public collapsible(Context context){ super(context,null); } public void setTextView1(String str){ textView1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3db6289909b3621d3d3be8792b51d966/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13b579bcaebc8c28f23059ff36465827/" rel="bookmark">
			latex参考文献样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址
http://sites.stat.psu.edu/~surajit/present/bib.htm#bibstyle
参考文献默认样式\bibliographystyle{plain}默认引用格式\cite，但是样式是[1]，而不是author，有一些宏包可以用来设置author样式的引用。
bibliographystyle \bibliographystyle可以用来设置参考文献标号及参考文献列表的样式，常用的style有 abbrv, acm, alpha, apalike, ieeetr, plain, siam, unsrt 使用方式为
\bibliographystyle{ieeetr} % or: plain,unsrt,alpha,abbrv,acm,apalike,... ... \begin{document} ... Reference to a paper in proceedings \cite{fanty:icassp93}, to an article \cite{linde:tcom80}, and to a book \cite{abut:book90}. ... \bibliography{abbr_long,pubext} % expansion macro's + entries from pubext.bib ... \end{document} 使用效果如下
ieeetr Reference to a paper in proceedings [1], to an article [2], and to a book [3]. References [1] M. Fanty, P.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13b579bcaebc8c28f23059ff36465827/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a029e95473943371498a9c3c9be5bc2/" rel="bookmark">
			iOS开发 正则表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正则表达式是通过特定的语法来查找指定字符串中的符合要求的子串,比如在一串数字中找到电话号,多用于图文混排
正则表达式基本语法:
简单几个例子
1.@"abc" : 在目标字符串中查找内容为 @"abc"的字串
2.@"[abc]": 在目标字符串中查找内容为 @"a" 或者 @"b" 或者 @"c"的字串
3.@"[0-9]": 在目标字符串中查找内容为 数字的字串 如@"1", @"2";
4.@"[0-9][a-z]" :在目标字符串中查找内容为 一个数字后有一个字母的字串, 如@"1a", @"1d"
5.@"[0-9a-z]" 在目标字符串中查找内容为 字母或数字的子串 如@"1" ,@"z"
还有很多不一一写出来了, 一般也用不到,有需要可以再网上搜
开发中正则表达式的使用
定义一个包含电话号码的字符串,
NSString *str =@"hjadhj1233asdwa51013223332333jkhsdkj123456789511hwua5462jsn";
这里的电话号码是13223332333 用正则表达式找打它 定义一个规则对象 NSRegularExpression *a = [[NSRegularExpressionalloc] initWithPattern:@"1[1356789][0-9]{9}"options:0 error:nil];
pattern 就是规则 以1开头 1或3或56789第二, 后面有九个数字{}代表重复次数,{9}表示重复9次,也可以这么写{1, 3}表示重复1次或者3次都符合规则 然后用定义好的规则检验字符串, 用一个数组保存结果集 NSArray *array = [amatchesInString:str options:0 range:NSMakeRange(0, str.length)];
打印array
NSLog(@"%@", array);
// 打印结果
for (NSTextCheckingResult * res in array) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a029e95473943371498a9c3c9be5bc2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f8f14a62b30b3aa14096aaa41fa8d14/" rel="bookmark">
			elasticSearch/elasticSearch-sql初探
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		刚刚接触ES，许多问题可能不是很准确，请谅解。
一、概念的东西就不啰嗦了。就说说我遇到的问题吧
1.错误信息：Exception in thread "main" NoNodeAvailableException[None of theconfigured nodes are available:
解决方法：增加settings设置(红色标记)。
Settingssettings= Settings.settingsBuilder()
.put("cluster.name","elasticSearchDemo").build();
Client client = TransportClient.builder().addPlugin(DeleteByQueryPlugin.class).settings(settings).build().addTransportAddresses(address1,address2);
2.问题2-&gt;Term查询不到数据：创建索引的时候没有说明不使用分词器（默认使用分词器），当用Term查询时，原来数据中的大写转换成小写，可以在测试分词器中测试一下。如果仍然用大写字母查询，导致查询不到数据。如{"term":{"gender":"F"}},必须写成{"term":{"gender":"f"}}
3问题3 注意各种默认值,比如ES-sql中默认limit为200，term中size默认为10.例子如下：
SearchResponseresponse= client.prepareSearch(TEST_INDEX)
.setSearchType(SearchType.QUERY_THEN_FETCH)
.setQuery(queryBuilder)
.addAggregation(AggregationBuilders.terms("ageAgg").field("age").size(100)
.subAggregation(AggregationBuilders.stats("ageStat").field("age")))
.execute().actionGet();
其中按照age分组统计，其中size默认为10（红色部分）.不确定可以写size(0)，代码自动写为maxInt。
3.问题.(脑裂)
今天集群中的健康值为yellow，查看日志报错为网络异常。错误的时间已经过去10个小时，现在网络也没有异常。刚开始的时候一直怀疑网络故障，问题一直找不到突破口，分别访问没有在集群的节点，也是没有问题的。网上搜索说是由于ping.timeout默认为3秒，如果超时就会出现多个集群的现象。联想到本系统中的网络异常，发现为两个集群。可查看每个节点的集群状态的primary属性。
修改方式：
discovery.zen.ping.timeout: 60s discovery.zen.minimum_master_nodes:3
4. elasticSearch-sql查询语句
4.1groupby语句其中group by之后的字段顺序重要。Limit属性为默认group by之后的第一个字段，如果没有limit默认为elasticSearch-sql自定义的200。源码在AggregationQueryAction中的explain()方法（((TermsBuilder) lastAgg).size(select.getRowCount());[大概在60L,version：2.3]）
Group by 之后的字段默认为全部查询源码在源码在AggregationQueryAction中的explain()方法（((TermsBuilder) subAgg).size(0);[大概在94L,version：2.3]）4. elasticSearch-sql查询语句
4.1groupby语句其中group by之后的字段顺序重要。Limit属性为默认group by之后的第一个字段，如果没有limit默认为elasticSearch-sql自定义的200。源码在AggregationQueryAction中的explain()方法（((TermsBuilder) lastAgg).size(select.getRowCount());[大概在60L,version：2.3]）
Group by 之后的字段默认为全部查询源码在源码在AggregationQueryAction中的explain()方法（((TermsBuilder) subAgg).size(0);[大概在94L,version：2.3]）
5.ES-sql中的like(%)查询（包括其他特殊字符）
es中的默认百分号（%）查询，如果查询结果 的文本中有百分号，ES默认like中是没有办法查询的。原因就是源码中会替换所有的百分号。代码在org.nlpcn.es4sql.query.maker.Maker类中[大概在143L,version：2.3]）源码如下：
case LIKE:
case NLIKE:
String queryStr = ((String) value);
queryStr = queryStr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f8f14a62b30b3aa14096aaa41fa8d14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ef9a77e7bbaf9ad27491b1c6cf24a18/" rel="bookmark">
			Spring源码深度解析（四）容器的基础XmlBeanFactory
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在我们已经对Srping的容器有了一个大概的了解，尽管很多地方还很迷糊，但是不要紧，下面我们开始探讨每个步骤的详细实现。接下来我们要深入分析以下代码的实现：
BeanFactory bf = new XmlBeanFactory(new ClassPathResource("beanFactoryTest.xml"));
通过XmlBeanFactory初始化时序图，图2—7，我们看下上面代码的执行逻辑：
时序图从BeanFactoryTest测试类开始，通过时序图我们可以一目了然地看到整个逻辑处理顺序。先调用了ClassPathResource的构造函数来构造Resource资源文件的实例对象，后续的资源处理就可以用Resource提供的各种服务来操作了，当我们有了Resource后就可以进行XmlBeanFactory的初始化了。那么Resource文件是如何封装的呢？
Spring的配置文件的读取时通过ClassPathResource进行封装的，如new ClassPathResource("beanFactoryTest.xml"),那么ClassPathResource完成了什么功能呢？
在java中，将不同来源的资源抽象成URL,通过注册不同的handler(URLStreamHander)来处理不同来源的资源的读取逻辑，一般handler的类型使用不同的前缀（协议，Protocol）来识别，如“file:”,"http:","jar："等，然而URL没有默认定义相对Classpath或ServletContext等资源的handler,虽然可以注册自己的URLStreamHandler来解析特定的URL前缀（协议），比如“classpath:”，然而这需要了解URL的实现机制，而且URL也没有提供一些基本的方法，如检查当前资源是否存在，检查当前资源是否可读等方法。因而Spring对其内部使用到的资源实现了自己的抽象结构：Resource接口来封装底层资源。
这两个类都是属于Spring-core包中的
InputStreamSource封装任何能返回InputStream的类，比如File,Classpath下的资源和Byte Array等。它只有一个方法定义：getInputStream(),该方法返回一个新的InputStream对象。
Resource接口抽象了所有Spring内部使用到的底层资源：File,URL，Classpath等。首先，它定义了3个判断当前资源状态的方法：存在性（exists）,可读性（isReadable）,是否处于打开状态（isOpen）.另外，Resource接口还提供了不同资源到URL,URI,File类型的转换，以及获取lastModified属性，文件名（不带文件信息的文件名，getFilename()）的方法。为了便于操作，Resource还提供了基于当前资源创建一个相对资源的方法：createRelative().在错误处理中需要详细地打印出错的资源文件，因而Resource还提供了getDescription()方法用于在错误处理中的打印信息。
对不同来源的资源文件都有相应的Resource实现：文件（FileSystemResource），Classpath资源（ClasspathResource）,URL资源（URLResource）,InputStream资源（InputStreamResource）,Byte数组（ByteArrayResource）等。相关类图如2-8所示。
在日常的开发工作中，资源文件的加载也是经常用到的，可以直接使用Spring提供的类，比如在希望加载文件时可以使用以下代码：
Resource resource = new ClassPathResource("beanFactoryTest.xml");
InputStream inputStream = resource.getInputStream();
得到inputStream后，我们可以按照以前的开发方式进行实现了，并且我们已经可以利用Resource及其子类为我们提供好的诸多特性。
有了Resource接口便可以对所有资源文件进行统一处理。至于实现，其实是非常简单的，以getInputStream为例，ClassPathResource中的实现方式便是通过class或者classLoader提供的底层方法进行调用，而对于FileSystemResource的实现其实更简单，直接使用FileInputStream对文件进行实例化。
ClassPathResource.java:
FileSystemResource.java:
当通过Resource相关类完成了对配置文件进行封装后配置文件的读取工作就全权交给XmlBeanDefinitionReader来处理了。
了解了Spring中将配置文件封装为Resource类型的实例方法后，我们就可以继续探讨XmlBeanFactory的初始化方法了，XmlBeanFactory初始化有许多方法，Spring中提供了很多的构造函数，在这里分析的是使用Resource实例作为构造函数参数的方法，代码如下：
上面函数的代码中，this.reader.loadBeanDefinitions(resource)才是资源加载的真正实现，也是我们分析的重点之一。我们可以看到时序图中提到的XmlBeanDefinitionReader加载数据就是这里完成的，但是在XmlBeanDefinitionReader加载数据前还有一个调用父类构造函数初始化的过程：super(parentBeanFactory)，跟踪代码到父类AbstractAutowireCapableBeanfactory的构造函数中：
AbstractAutowireCapableBeanFactory.java:
这里有必要提及下ignoreDependencyInterface方法。ignoreDependencyInterface的主要功能，是忽略给定接口的自动装配功能，那么，这样做的目的是什么呢？会产生什么样的效果呢？
举例来说，如果A中有B属性，Spring在获取A的时候会自动初始化B,但某些情况下B不需要被初始化，有种情况就是B实现了BeanNameAware接口。Spring中是这样介绍的，自动装配的时候，忽略给定的依赖接口，典型的应用是通过其他方式解析Application上下文注册依赖，类似于BeanFactory通过BeanFactoryAware进行注入或者ApplicationContext通过ApplicationContextAware进行注入。
内容有点多，下面一节会讲解XmlBeanFactory如何通过XmlBeanDefinitionReader进行加载Bean
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/961372ba33fdaa0e0855f4534001e0e7/" rel="bookmark">
			cmake 添加头文件目录，链接动态、静态库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		罗列一下cmake常用的命令。
CMake支持大写、小写、混合大小写的命令。
1. 添加头文件目录INCLUDE_DIRECTORIES
语法：
include_directories([AFTER|BEFORE] [SYSTEM] dir1 [dir2 ...]) 它相当于g++选项中的-I参数的作用，也相当于环境变量中增加路径到CPLUS_INCLUDE_PATH变量的作用。
include_directories(../../../thirdparty/comm/include) 2. 添加需要链接的库文件目录LINK_DIRECTORIES
语法：
link_directories(directory1 directory2 ...) 它相当于g++命令的-L选项的作用，也相当于环境变量中增加LD_LIBRARY_PATH的路径的作用。
link_directories("/home/server/third/lib") 3. 查找库所在目录FIND_LIBRARY
语法：
A short-hand signature is: find_library (&lt;VAR&gt; name1 [path1 path2 ...]) The general signature is: find_library ( &lt;VAR&gt; name | NAMES name1 [name2 ...] [NAMES_PER_DIR] [HINTS path1 [path2 ... ENV var]] [PATHS path1 [path2 ... ENV var]] [PATH_SUFFIXES suffix1 [suffix2 ...]] [DOC "cache documentation string"] [NO_DEFAULT_PATH] [NO_CMAKE_ENVIRONMENT_PATH] [NO_CMAKE_PATH] [NO_SYSTEM_ENVIRONMENT_PATH] [NO_CMAKE_SYSTEM_PATH] [CMAKE_FIND_ROOT_PATH_BOTH | ONLY_CMAKE_FIND_ROOT_PATH | NO_CMAKE_FIND_ROOT_PATH] ) 例子如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/961372ba33fdaa0e0855f4534001e0e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/031d1b532b545530f92b35f260f21e0f/" rel="bookmark">
			程序员福利：大牛收藏5年的开发资料
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		好东西不私藏，分享给需要的朋友，不用谢，推荐订阅本博客及微博，随时分享技术学习资源
收集五年的开发资料下载地址： http://pan.baidu.com/share/home?uk=4076915866&amp;view=share
下载地址发在我的微博上了：http://weibo.com/5717080324/profile?topnav=1&amp;amp;wvr=6&amp;amp;is_all=1
收藏者本人地址：http://zz563143188.iteye.com/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a59bc6a888c98f07da93f0e6fa10d88/" rel="bookmark">
			com.alibaba.dubbo.rpc.RpcException的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在开发SpringMVC+dubbo框架时，从消费者跳转到提供者时总是报错，报错信息如下：
2016-6-27 15:23:05 org.apache.catalina.core.StandardWrapperValve invoke 严重: Servlet.service() for servlet [spring] in context with path [/mp_consumer] threw exception [Request processing failed; nested exception is com.alibaba.dubbo.rpc.RpcException: Failed to invoke the method login in the service com.MP.manager.JcManager. No provider available for the service com.MP.manager.JcManager from registry 127.0.0.1:2181 on the consumer 192.168.2.215 using the dubbo version 2.5.3. Please check if the providers have been started and registered.] with root cause com.alibaba.dubbo.rpc.RpcException: Failed to invoke the method login in the service com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a59bc6a888c98f07da93f0e6fa10d88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e78ecbf9720619d85db736061afd2a9/" rel="bookmark">
			alsa 驱动介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Machine 以装配有CS4270的一款android 智能电视的为例 /sound/soc/samsung/exynos.c Platform 以Samsung cpu exynos4412为例 /sound/soc/samsung/ Codec 以wolfson的Codec芯片cs4270为例 /sound/soc/codecs/cs4270.c ALSA 框架介绍 Alsa 太多太杂，很难整理的规整，只能看到哪里写到哪里 ASoC被分为Machine，Platform和Codec三大部件，
Platform驱动的主要作用是完成音频数据的管理，最终通过CPU的数字音频接口（DAI）把音频数据传送给Codec进行处理，最终由Codec输出驱动耳机或者是喇叭的音信信号。在具体实现上，ASoC有把Platform驱动分为两个部分：snd_soc_platform_driver和snd_soc_dai_driver。其中，platform_driver负责管理音频数据，把音频数据通过dma或其他操作传送至cpu dai中，dai_driver则主要完成cpu一侧的dai的参数配置，同时也会通过一定的途径把必要的dma等参数与snd_soc_platform_driver进行交互。
Machine 是指某一款机器，可以是某款设备，某款开发板，又或者是某款智能手机，由此可以看出Machine几乎是不可重用的，每个Machine上的硬件实现可能都不一样，CPU不一样，Codec不一样，音频的输入、输出设备也不一样，Machine为CPU、Codec、输入输出设备提供了一个载体。
Platform 一般是指某一个SoC平台，比如pxaxxx,s3cxxxx,omapxxx等等，与音频相关的通常包含该SoC中的时钟、DMA、I2S、PCM等等，只要指定了SoC，那么我们可以认为它会有一个对应的Platform，它只与SoC相关，与Machine无关，这样我们就可以把Platform抽象出来，使得同一款SoC不用做任何的改动，就可以用在不同的Machine中。实际上，把Platform认为是某个SoC更好理解。 Codec 字面上的意思就是编解码器，Codec里面包含了I2S接口、D/A、A/D、Mixer、PA（功放），通常包含多种输入（Mic、Line-in、I2S、PCM）和多个输出（耳机、喇叭、听筒，Line-out），Codec和Platform一样，是可重用的部件，同一个Codec可以被不同的Machine使用。嵌入式Codec通常通过I2C对内部的寄存器进行控制。 Machine驱动的初始化，codec和dai的注册，都会调用snd_soc_instantiate_cards()进行一次声卡和codec，dai，platform的匹配绑定过程，这里所说的绑定，正如Machine驱动一文中所描述，就是通过3个全局链表，按名字进行匹配，把匹配的codec，dai和platform实例赋值给声卡每对dai的snd_soc_pcm_runtime变量中。一旦绑定成功，将会使得codec和dai驱动的probe回调被调用 alsa架构的数据交互，是通过对PCM设备的操作来完成的， PCM设备分成playback和capture两个stream, 每个stream底下有N个substream。 alsa驱动最底层需要调试的有三块： DMA部分，IIS驱动部分，codec部分 IIS介绍 A）I2S有四根线， 1.串行时钟SCLK，也叫位时钟（BCLK），即对应数字音频的每一位数据，SCLK都有1个脉冲。SCLK的频率=2×采样频率×采样位数。 2. 帧时钟LRCK，(也称WS)，用于切换左右声道的数据。LRCK为“1”表示正在传输的是右声道的数据，为“0”则表示正在传输的是左声道的数据。LRCK的频率等于采样频率。 3.串行数据SDATA，就是用二进制补码表示的音频数据。 4.有时为了使系统间能够更好地同步，还需要另外传输一个信号MCLK，称为主时钟，也叫系统时钟（Sys Clock），是采样频率的256倍或384倍。 B）声音数据DAT一般在CLK的上升沿进行采样，有些DAC也是可以调的。每个声道里面可以容纳的CLK数必须多于数据的位数，多出来的时钟和数据DAC会丢弃不用，比如16bit采样的声音数据当一个声道是32个CLK且left-justify的时候，后面十六个时钟的数据会被DAC丢掉，不影响的。
C）I2S数据的格式分I2S， Left-justify， Right-justify。三种格式的区别在于声音数据与WS的对应关系： 1 . I2S模式DAT的MSB在WS变化后的第二个上升沿开始传输 2. Left-justify模式DAT的MSB在WS变化后的第一个上升沿开始传输 3. Right-justify模式DAT的LSB在WS即将变换到下一声道前的最后一个时钟传输 I2S部分涉及的几个频率: * 输出采样频率 fs = 44.1KHz. (也有其它fs的音源, 但加了resampler后, 都变成44.1KHz输出了). 这是个关键频率. * LRCLK, 就等于fs. (L/R声道信号) * BCLK = 32倍fs = 1411.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e78ecbf9720619d85db736061afd2a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df937586f3a00cd449c4ddc0d608ef7c/" rel="bookmark">
			gdb 查看当前位置的指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		where
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eafd4879fd48b9b0135b952eb87388d3/" rel="bookmark">
			go语言 - 设计哲学
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		go语言是互联网时代的语言，融合了众多互联网时代程序设计的特征。
并行与分布式支持。多核化和集群化是互联网时代的典型特征。 并发执行的“执行体” 执行体是个抽象的概念，在操作系统层面有多个概念与之对应，如操作系统自己掌管的进程(process)、进程内的线程(thread)以及进程内的协程 (coroutine，也叫轻量级线程)。多数语言在语法层面并不直接支持协程，而通过库的方式支持的协程的功能也并不完整，比如仅仅提供协程的创建、销毁与切换等能力。如果在这样的协程中调用一个同步IO操作，比如网络通信、本地文件读写,都会阻塞其他的并发执行协程，从而无法真正达到协程本身期望达到的目标。 Go语言在语言级别支持协程，叫goroutine。Go语言标准库提供的所有系统调用(syscall)操作，当然也包括所有同步IO操作，都会出让CPU给其他goroutine，这让事情变得非常简单。
go语言异步程序示例：
func run(arg string) { // ... } func main() { go run("test") ... } 关于进程、线程、协程的区别可以参考如下几篇文章：
谈谈并发编程中的协程 一个“蝇量级” C 语言协程库 编程中的进程、线程、协程、同步、异步、回调
执行体间的通信 执行体间通信的方式：
执行体之间的互斥与同步执行体之间的消息传递 执行体之间的互斥与同步 当执行体之间存在共享资源(一般是共享内存)时，为保证内存访问逻辑的确定性，需要对访问该共享资源的相关执行体进行互斥。当多个执行体之间 的逻辑存在时序上的依赖时,也往往需要在执行体之间进行同步。
多数语言在库层面提供了线程间的互斥与同步支持，但却找不到协程的影子。
执行体之间的消息传递 两种并发编程模型：
共享内存模型消息传递模型 go语言整合了两种并发编程模型，但其推荐“消息传递模型”。其建议适度使用“共享内存模型”。在Go语言中，内置了消息队列的支持，其叫通道(channel)。两个goroutine之间可以通过通道来进行交互。
软件工程支持。工程规模不断扩大是产业发展的必然趋势。 随着工程规模的变大，多数软件需要多人协作完成。所以编程规范化，对于多人协作编程是非常必要的。
go语言是非常规范化的语言，其规范化主要体现在一下几个方面：
代码风格规范错误处理规范包管理契约规范(接口)单元测试规范功能开发的流程规范 【示例】go语言的错误处理规范：
f, err := os.Open(filename) if err != nil { log.Println("Open file failed:", err) return } defer f.Close() ... // 操作已经打开的f文件 编程哲学的重塑 当今主要的编程范式：
面向过程编程(C)面向对象编程(C++，Java)函数式编程(Python)面向消息编程(Erlang) 如果需要对“函数式编程”有所了解，阅读这篇文章：
函数式编程
go语言对所有这些编程思想做了一次梳理，融合众家之长，但时刻警惕特性复杂化，极力维持语言特性的简洁，力求小而精。 例如，Go语言接受了“函数式编程”的一些想法，支持匿名函数与闭包。再如，Go语言接受了以Erlang语言为代表的“面向消息编程”思想，支持goroutine和通道。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2d5b45a3221d1ca6f7d636459f96104/" rel="bookmark">
			入职两个月的一些感受
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在最前：
今晚闲下来，发觉时间过得好快，不知不觉已经周五了，入职新公司已经两个月拉。以前从来没有写总结之类的习惯，但突然今天就想把自己这两个月的一些感受记录下来，以后决定每年写一篇年终总结，季度总结看心情写吧。
这两个月的感受：
入职这家公司之前，虽说自己正式工作算起的话已经两年开发经验了，但自知自己欠缺的还很多，一些基础知识还不够牢固，导致在做项目遇到瓶颈。前几天项目中用到的泛型，不能灵活的运用，看来基础还是很重要的嘛。现在的这家公司是一个物流快递公司，刚进去不久，发现公司的IT部门的人几乎都是跟我差不多同时进来的，之前待在公司的老员工占少数，然后我被分到了架构部，最最关键的是我们架构部的只有我经理一个人(深圳这边)，并且是唯一的架构师，像开发部进来很多人之后差不多有二十多个人，总觉得有点汗颜。。。进去的第一天，主要是报道然后熟悉一下办公室的环境吧，第二天老大就领着我去IT部跟其他人一一打招呼简单认识一下，由于我本人不善表达，打招呼的时候有点尴尬，我觉得与人交流是我很要命的弱点。刚开始的时候在办公室很不习惯，不过现在好一点了，主要是因为之前的公司是十个人的办公室，很安静，现在的办公室还包含其他非it部门的人，每天都吵吵的，可能对于有些习惯安静的开发环境的程序员很要命。然后就开始熟悉java项目，与之前公司项目不同的是，之前公司的项目用的是hibernate，struts mvc.....，现在mybatis，spring mvc......，不过都明白，差别不是很大，然后花了一些时间将c#的webservice改成java，然后老大说准备用redis缓存框架去整合项目，毕竟为了以后考虑嘛。于是redis学习就开始了，但我觉得我比较笨，学习redis的过程中有点木有针对性，而且感觉学习效率很低，写demo的时候遇到了问题几天都解决不了，都说遇到困难正是学习提高的时候，但因为实在解决不了，我开始怀疑自己了。不过还是很感谢老大，在我遇到困难的时候对我引导、帮助，给我时间去学习。渐渐地，写了一个单机redis服务并整合到项目中，oracle的数据就可以同步到redis了，以后用户就可以直接从redis缓存中直接拿数据了。目前仅仅是单机redis，以后肯定会用到redis集群，所以准备这段时间继续学习redis集群的知识。还有就是在这两个月的观察学习中，可以知道我们老大确实是大牛，虽然平时很低调的感觉，希望可以跟着他多学习学习。还有一群跟我差不多同时进来的小伙伴，希望他们多学习，毕竟在这两个月的接触中，真心觉得其中有些人基础太薄弱啦(包括我)。总之，希望每个小伙伴越来越好，为公司和自己的发展多努力！
写在最后：
暂时只想到这么多啦，还有就是最近也在看一些android方面的学习资料，希望在今年结束之前抽空写两三个app，还有一句话与大家共勉：做到别人不能做的，才能得到别人不能得到的！嘿嘿~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6837ea13dc3976fb1769a57391d9593c/" rel="bookmark">
			mysql-\g和\G的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		\g 的作用是分号和在sql语句中写’;’是等效的 \G 的作用是将查到的结构旋转90度变成纵向
\g的使用例子：查找一个表的创建语句
mysql&gt; create table mytable(id int)\g Query OK, 0 rows affected (0.21 sec) mysql&gt; show create table mytable \g +---------+-------------------------------------------------------------------------------------------+ | Table | Create Table | +---------+-------------------------------------------------------------------------------------------+ | mytable | CREATE TABLE `mytable` ( `id` int(11) DEFAULT NULL ) ENGINE=InnoDB DEFAULT CHARSET=utf8 | +---------+-------------------------------------------------------------------------------------------+ 1 row in set (0.04 sec) 上面的查找的表的创建语句看着很别扭，那么可以使用\G,试一下就知道它的用途了
mysql&gt; show create table mytable \G *************************** 1. row *************************** Table: mytable Create Table: CREATE TABLE `mytable` ( `id` int(11) DEFAULT NULL ) ENGINE=InnoDB DEFAULT CHARSET=utf8 1 row in set (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6837ea13dc3976fb1769a57391d9593c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73406d04487ddac1b30e4bb193534e97/" rel="bookmark">
			解决读取文件乱码问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		==&gt; 学习汇总（持续更新）
==&gt; 从零搭建后端基础设施系列（一）-- 背景介绍
一般在windows上的txt文本文件要么以ANSI编码要么以Unicode编码，而用C ,C++，MFC编写的程序一般人只会处理一种编码格式的文本，因为不懂怎么判断读取的文件是以哪种编码格式存储的。那么重点就是判断读取的文件是以哪种方式存储的！有两种方式解决。
一.用二进制方式打开文件，前两个字节为FFFE就是Unicode文件,ANSI则无格式定义.
如图：
这是以16进制打开Unicode文件，很明显看到前两个字节是FFFE
再来，用C语言读取文件，如图：
把buf的地址在内存中显示出来，其内容是FFFE两个字节
因为编译器是32位的，所以最后显示如图:
所以现在基本确定判断Unicode的方法了.
例如：
int main(void) { if (IsUnicode("H:\\Unicode.txt")) printf("打开的是Unicode文件\n"); else printf("打开的是ANSI文件\n"); return 0; } IsUnicode函数实现如下：
bool IsUnicode(char* fileName) { FILE* fp = fopen(fileName, "rb"); if (!fp) { printf("打开文件失败!\n"); return 1; } char buf[2] = { 0 }; fread(buf, 1, 2, fp); char byte1[10] = { 0 }; char byte2[10] = { 0 }; sprintf(byte1, "%X", buf[0]); sprintf(byte2, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73406d04487ddac1b30e4bb193534e97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83da276a80845af9c2e03ed06a0ca83b/" rel="bookmark">
			JVM JRE JDK三者的区别和联系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 详细介绍 1、JVM -- java virtual machine JVM就是我们常说的java虚拟机，它是整个java实现跨平台的 最核心的部分，所有的java程序会首先被编译为.class的类文件，这种类文件可 以在虚拟机上执行，也就是说class并不直接与机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解 释给本地系统执行。 JVM 是 Java 平台的基础，和实际的机器一样，它也有自己的指令集，并且在运行 时操作不同的内存区域。 JVM 通过抽象操作系统和 CPU 结构，提供了一种与平台无关的代码执行方法，即与特殊的实现方 法、主机硬件、主机操作系统无关。但是在一些小的方面， JVM 的实现也是互不相同的，比如 垃圾回收 算法， 线程调度 算法（可能不同 OS 有不同的实现）。 JVM 的主要工作是解释自己的指令集（即字节码）到 CPU 的指令集或 OS 的系统调用，保护用户免被恶意程序骚扰。 JVM 对上层的 Java 源文件是不关心的，它关注的只是由源文件生成的类文件（ class file ）。类文件的 组成包括 JVM 指令集，符号表以及一些补助信息。 2、JRE -- java runtime environment JRE是指java运行环境。光有JVM还不能成class的 执行，因为在解释class的时候JVM需要调用解释所需要的类库lib。 在JDK的安装目 录里你可以找到jre目录，里面有两个文件夹bin和lib,在 这里可以认为bin里的就是jvm，lib中则是jvm工 作所需要的类库，而jvm和 lib和起来就称为jre。所以，在你写完java程序编译成.class之后，你可以把这个. class文件 和jre一起打包发给朋友，这样你的朋友就 可以运行你写程序了。（jre里有运行.class的java.exe） JRE 是 Sun 公司发布的一个更大的系统，它里面就有一个 JVM 。 JRE 就与具体的 CPU 结构和操作系统有关，我们从 Sun 下载 JRE 的时候就看到了不同的各种版本。同 JVM 一起组成 JRE 的还有一些 API （如 awt ， swing 等）。 JRE 是运行 Java 程序必不可少的。 JRE （ Java Runtime Environment ），是运行 Java 程序必不可少的（除非用其他一些编译环境编译成.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83da276a80845af9c2e03ed06a0ca83b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b36bb9f5023ae0b2670bef871cc076f/" rel="bookmark">
			Windows 2008 Fileserver Permission Access Deny
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 windows 2008 administrator an error occurred while appling security information I resolved this problem with the following steps: Open a Command Prompt "As Administrator" Run the following commands:
takeown /f G:\folder /r /d y icacls G:\folder /grant administrators:F /T 当在Windows文件服务器中使用了拒绝Auth用户后重新获取权限请使用上面的二个命令组合。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/783f6f87c05298d023c09c18ac60c1aa/" rel="bookmark">
			真阳率(tp)、假阳率(np)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 很早以前就知道这些概念了，不过由于跟自己的认知习惯不一样，所以碰到了还是经常会忘。于是索性把这些概念总结一下，以后再忘了也好找（其他的文章太啰嗦了，计算方法也写的不清不楚….） 另外我也会陆续更新一些其他的机器学习相关概念和指标，即是方便自己，也方便他人吧。
注意：本文将混用正负样本和阳性(+)阴性(-)这两套说法
真阳率、假阳率 这些概念其实是从医学那边引入到机器学习里面的，所以其思维逻辑多多少少会跟做机器学习的有点出入。我们去看病，化验单或报告单会出现（+）跟（-），其分别表型阳性和阴性。比如你去检查是不是得了某种病，阳性（+）就说明得了，阴性（-）就说明没事。 那么，这种检验到底靠不靠谱呢？科研人员在设计这种检验方法的时候希望知道，如果这个人确实得了病，那么这个方法能检查出来的概率是多少呢（真阳率）？如果这个人没有得病，那么这个方法误诊其有病的概率是多少呢（假阳率）？ 具体来说，看下面这张表（摘自百度百科）： 真阳率（True Positive Rate, TPR）就是： 真阳率=aa+c 含义是检测出来的真阳性样本数除以所有真实阳性样本数。 假阳率（False Positive Rate, FPR）就是： 假阳率=bb+d 含义是检测出来的假阳性样本数除以所有真实阴性样本数。 ROC（Receiver Operating Characteristic） 很简单，就是把假阳率当x轴，真阳率当y轴画一个二维平面直角坐标系。然后不断调整检测方法（或机器学习中的分类器）的阈值，即最终得分高于某个值就是阳性，反之就是阴性，得到不同的真阳率和假阳率数值，然后描点。就可以得到一条ROC曲线。 需要注意的是，ROC曲线必定起于（0，0），止于（1，1）。因为，当全都判断为阴性(-)时，就是（0，0）；全部判断为阳性(+)时就是（1，1）。这两点间斜率为1的线段表示随机分类器（对真实的正负样本没有区分能力）。所以一般分类器需要在这条线上方。
画出来大概是长下面这样（转自这里）： AUC（Area Under Curve） 顾名思义，就是这条ROC曲线下方的面积了。越接近1表示分类器越好。 但是，直接计算AUC很麻烦，但由于其跟Wilcoxon-Mann-Witney Test等价，所以可以用这个测试的方法来计算AUC。Wilcoxon-Mann-Witney Test指的是，任意给一个正类样本和一个负类样本，正类样本的score有多大的概率大于负类样本的score（score指分类器的打分）。
方案一： 我们可以对于总样本中的M个正样本和N个负样本，组成 M×N 个pair，如果某个pair正样本score大于负样本，则记1分，反之记0分，相等记0.5分。然后总分除以 M×N 就是AUC的值了。复杂度 O(M×N) 方案二： 基本思想一样，不过复杂度可以缩减到 O((M+N)log(M+N)) 。 首先，我们将所有样本得分从大到小排序，则排名最高的样本rank为M+N，第二的为M+N-1，以此类推。然后我们将所有正样本的rank加和，其思想为：排名k的正样本至多比k-1个负样本的score要大。当我们将正样本的rank加和后，再减去 (1+M)M/2 ，即正样本的个数，就是正样本score比负样本score大的pair个数。再除以 O(M×N) 就是AUC的值了，公式如下： AUC=∑i∈positiveranki−(1+M)M2M×N 注意：对score相等的样本，需要赋予相同的rank(无论这个相等的score是出现在同类样本还是不同类的样本之间，都需要这样处理)。具体操作就是把所有这些score相等的样本的rank取平均。然后再使用上述公式。比如score为0.8的有两个样本，rank为7和8，则其最终代入公式的rank为7.5 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67baed4c9a266536214555173de7d8e5/" rel="bookmark">
			结合芯片exynos 4412介绍V4L2用来视频编解码的驱动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里结合芯片exynos 4412介绍一下V4L2用来视频编解码的驱动结构 内核代码基于3.4.106 linux-3.4.106\drivers\media\video\s5p-mfc linux-3.4.106\drivers\media\video 1，V4L2结构
2，几个主要接口 主要接口（ioctl下面的一层） vidioc_qbuf vidioc_dqbuf vidioc_reqbufs vidioc_s_fmt 3，主要数据结构 struct vb2_queue struct v4l2_buffer struct s5p_mfc_ctx struct vb2_buffer 4，接口调用链 V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE是未解码数据，存放ES流数据 V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE是已经解码数据，存放frame data buffer v4l2_qbuf流程 vidioc_qbuf--vb2_qbuf
--- __enqueue_in_driver
---- q-&gt;ops-&gt;buf_queue(vb);
---- s5p_mfc_buf_queue
---- list_add_tail(&amp;mfc_buf-&gt;list, &amp;ctx-&gt;dst_queue);
---- s5p_mfc_try_run
v4l2_dqbuf流程
解出来一帧： s5p_mfc_irq
--- s5p_mfc_handle_frame
--- s5p_mfc_handle_frame_new
--- vb2_buffer_done
--- wake_up(&amp;q-&gt;done_wq);
---- list_add_tail(&amp;vb-&gt;done_entry, &amp;q-&gt;done_list); 把解出来的一帧挂上队列
vidioc_dqbuf
--- vb2_dqbuf
--- __vb2_get_done_vb
--- __vb2_wait_for_done_vb（查找是否有可用的vb）
--- wait_event_interruptible(q-&gt;done_wq,
5，内存管理方式
主要队列： 分为capture plane(解码后)和output plane（解码前） 从另外一个维度看， 每个plane都有一个done_list队列，表示解码完比的，不用的ES buffer,或者存有有效YUV数据的Frame data buffer,用户态dqbuffer就从这里面取 每个plane都有一个另外的queue队列，表示要解码的ES buffer,或者已经显示完毕的YUV数据的Frame data buffer,用户态qbuffer就从这里取 v4l2-core操作的是vb2-buffer, 这只是个handle而已，实际给MFC的是5p_mfc_buf ， 这两种buffer通过v4l2-buffer里面的index来对应起来
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67baed4c9a266536214555173de7d8e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a10082e7a311caf12d41d69e63e678d5/" rel="bookmark">
			exynos 4412 mfc 介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		exynos 系列处理器的多媒体编解码依靠的是mfc硬件模块
目前对MFC的介绍较少。
这里粗略的总结一下
MFC 有个RISC的小核，有8K的Icache，4K的Dcache，这个RISC可以对ES流每一帧的头数据进行分析或者合成 MFC由以下部分构成：RISC， MFC core（各种加速器），寄存器组，总线接口，内存接口 RISC和HOST都可以访问寄存器组，通过寄存器组互相通信，RISC通过产生一个中断，告诉HOST有消息，HOST收到消息后处理，
然后写MFC_RISC_HOST_INT 寄存器清掉中断位
MFC有两个AXI 总线接口。构成两个通道，可以同时全速运行。从而同时进行两路的编解码。 上图中的Search SRAM用来防止参考image, 这个主要是在运动估计和运动补偿的时候用到 Share SRAM的作用主要是保存共享当前视频帧。供前后帧在编码的时候使用。 Pixel cache， 这个位于MFC core内部，用来减少对参考帧的访问次数。对亮度数据有2K的缓存，对色度数据有1K的缓存 Host 和MFC之间通过共享内存来交换要解码的数据和解码完毕的数据 MFC的固件版本会更新，很多编解码的内部的状态设置，参数设置会变化，所以不能用寄存器这种固定的东西来实现，要用共享内存来实现主机和MFC的互联 S5PV210 mfc寄存器分为以下几类 1，buffer地址设置类 2，R2H,H2R设置类 3，一些相对固定的编解码器状态设置/读取类 R2H H2R是什么东西？
R2H，主要用在了中断，H2R主要用在告诉MFC的一些状态，例如wake up，sleep等，似乎和解码的具体细节无关
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b250ad1271bb07fdd022dc133a4afb3/" rel="bookmark">
			使用video.js播放视频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.下载video.js插件
2.引入相关标签，包括css、js等
&lt;link href="${path }/static/video/video-js/video-js.css" rel="stylesheet"&gt;
&lt;script src="${path}/static/video/video-js/video.js"&gt;&lt;/script&gt;
&lt;script&gt; _V_.options.flash.swf = "http://example.com/path/to/video-js.swf" &lt;/script&gt;
3、html页面播放视频部分
&lt;video id="example_video_1" class="video-js vjs-default-skin" controls preload="auto" width="800" height="500" style="margin:0 auto" poster="" data-setup='{"example_option":true}'&gt; &lt;source src="视频地址" type='video/mp4' /&gt;
&lt;/video&gt; 4、支持的视频格式
&lt;source src= "xxx.mp4" type= 'video/mp4; codecs="avc1.42E01E, mp4a.40.2"' /&gt; &lt;source src= "xxx.webm" type= 'video/webm; codecs="vp8, vorbis"' /&gt; &lt;source src= ".ogv" type= 'video/ogg; codecs="theora, vorbis"' /&gt;
可以用视频转码工具实现，最好用MP4格式
5、对于ie9以下版本对video标签不支持，请在页面head部分加入以下标签
&lt;script src="http://api.html5media.info/1.1.8/html5media.min.js"&gt;&lt;/script&gt;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e80a0e9867fd8b60fc46d4b1f8b95ac/" rel="bookmark">
			如何优雅地送妹子礼物？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一颗林萌 ，剁手已剁成哆啦A梦。 刘巍然-学酥 等 15268 人赞同 -----------------------------------------------------------------------------------------
有转载需要请私信，不接受未通知作者本人直接转载的行为，按原创法规直接举报。 因为工作原因经常接触买买买，加上生活里经常剁手...长了经验，也见过一些或实用或纯有趣的产品推荐给大家。PS：我并没有每个都用过（用过的描述里有使用感受），主要是自己用过+朋友用过+了解推荐，以女性的角度觉得这些礼物还不错： 一是不可能适用于每个妹子，请自行判断妹子喜好； 二是有的产品只从象征意义和颜值来推荐，没用过的产品我无法考虑性能，请自己看网友评测； 三是答案不会以化妆品为主，因为肤色、肤质不定因素太多，男生容易选错。 四是以新奇/有设计感的产品为主，有的妹子觉得不实在，嘴上说着送钱，其实拿到手会让南票跪搓衣板没诚意吧啊！而且...礼物本来的意义就是送你想买又觉得没X用或买不起的啊（我们就是这么地口是心非） -------------------------------------------正文----------------------------------------------- 我是妹子，曾经做过一个列表里面专门放适合送妹子的礼物，得到了很多男性朋友的喜欢和实践！！是时候放出来了！ 有评论说送给女朋友蛮喜欢的，作为直男的好gay蜜 ，开心 _(:з」∠)_ 先说几个小法则：
1.重要场合比如告白、纪念日在你经济范围内的越贵越好，贵总有它贵的道理，当然量力而行吧。如果你不懂她的爱好兴趣，试着从她周围的闺蜜、SNS去了解。这个因人而异，妹子之间差异也很大，我的回答并不是都适用，性别可以定义一个人的话就见鬼了啦。 2.想要礼物显得有档次，同样的价格去买小件而不是大件：500元的指甲刀和500元的手机，前者是高档品，后者会很辣鸡。 3.礼物并不是最重要的，关键看你用不用心，除了送礼，能附上自己亲手的一个小作品就更好啦，像我的设计师朋友做表白动画，程序员做个小游戏之类的。我的回答主要是创意/实用类，有的价格不算很高，场景更适合日常送礼而不是重大纪念日。 4.想要了解女人，请远离泡学啊...那种90年代偶像剧的撩妹技巧至少本妹子觉得都是套路，对演技要求也是很高的。倒是可以看看《女人来自金星男人来自火星》，男女思考方式太特么不一样了，有助于了解女生想法，提高撩妹技巧。 其实女生很难懂，但也没有那么难，你真诚对方是能感受到。重点是注意表达和沟通方式，女生天生是倾诉派，喜欢维护人际关系，男生是解决问题派，因此造成的差异非常大。 5.女生对男生的好感在于持久度，而不是礼物价值。你送我1次500元的，效果不一定有送我5次100元的产品好。女生要的是小确幸，持久的关怀和爱。 6.感觉女生都懂女生，空有一身撩妹技巧的我也好想去撩妹啊~~~~羡慕男人有那么多软妹等着撩呢！！ -----------------------------------------------------------------------------------------------
不要光收藏不关注好嘛，相遇是缘啊胖友 (´-ωก`) &gt;&gt;&gt; @ 一颗林萌 关于购买：
1/ 总有人问购买链接，有靠谱官网或自己/朋友买过的靠谱渠道会放在标题链接里。 2/ 或者顺手加个产品介绍的超链接。 3/ 啥都没写的&gt;&gt;&gt;说明间歇性懒癌犯了╮(╯▽╰)╭自行搜索咯 不跑题： 其实还有很多想要安利的好东西，但不符合本题送妹子文风，可看结尾处答案《有哪些不为人知的好东西？》，慢慢更新ing...有想看的内容可以留言。 2月14号更新 信息隐藏戒 $120—$1000（依材质定价） 情人节来分享个很有意思又腹黑的戒指……戒指戴久了的jji戒痕惊喜。材质方面有14K金（黄金、白金、玫瑰金可选）、纯银，内部的字体也是有“marry me”、“always”、❤形……适合闷骚（且有闲钱）的男人，蛮新奇的。不过不一定好买和实用咯。（是的第一个就是纯好玩并不知道哪里买╮(╯▽╰)╭） Lumio - 一本发出暖心亮光的书 关起来是本书，可以徐徐展开到360°，自己玩过，暖暖内含光，非常漂亮~送给你妹子去朋友圈炫耀吧=。= 反正一朋友在朋友圈发了条状态很多人问是啥东西，新奇度和颜值都有的，略贵是真，但和TB的山寨货绝不是一个档次的（用过正品，没对比过山寨品，可看购买评价），正版的1000多。 猫爪棉花糖 ¥138 小女生萌妹子会喜欢死，实际效果有晒单，好萌。不过海淘从日本到保质期很捉急（印象里只有半个多月）&gt;&gt;&gt;这有个网友晒单&gt;&gt; 感觉这就是专门拿来送人的。 tb上很多仿品，谨慎选购哦。 每个妹子都爱美， 但男生买护肤品化妆品真的不推荐，除非你清楚知道她确切想要的，或是有很了解她的闺蜜助攻，毕竟妹子皮肤种类不尽相同~这是个复杂的问题，嗯！所以美容向的考虑送仪器吧，洁面仪呢从C家mia和F家mini入门的比较多： Clarisonic Mia 声波洁面仪 1200+ 用过。用法是将洁面乳涂抹在湿润的皮肤或湿润刷头，选择合适振动速度，用刷头轻柔地在脸上打小圆圈~还蛮舒爽的 优点：洗完之后很干净，清爽的感觉，护肤品会更好吸收 缺点：这款刷头200左右，3个月一换，就像电动牙刷刷头一样是长期投资，身边妹子因为这个原因果断入了下面这个FOREO FOREO LUNA 超声波硅胶洗脸机 1200/1800/海淘大概可以一半。觉得上个产品的刷头贵的请看这个：用过。优点：不用换刷头，因为采用的无菌硅胶；温和，比起C家更适合皮薄的妹子。省了一笔更换刷头的钱。 价格：mini的1200+，大的1800+，国内丝芙兰有卖，当然要省钱还是香港买或海淘的好~身边妹子海淘mini700左右不用谢~ 两者都很火，网上很多测评，感兴趣可以搜搜，但个人感受（混皮）是FOREO更好。 Tangle Teezer梳子 125+ 用过+送过。实用，还算便携，妹子都可以用不挑人。 秀发对妹子很重要！！冬天妹子头发打结很厉害，头发长甚至会扯得头皮痛，送这款 Tangle Teezer 绝对贴心！它是来自英国的殿堂级美发梳（待考证），每天从起床梳头就想到你！身边2个朋友都买了也送了一把出去，早上梳头效率提高很多，大概是因为梳齿多且防静电，效果不错，推荐。 缺点：这款表面容易留指纹，取下清理头发时有点蛋疼。可以在标题链接购买，非常靠谱，因为.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e80a0e9867fd8b60fc46d4b1f8b95ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b28998e7a21dd37334dae44a6819249e/" rel="bookmark">
			device_create 函数详细分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在刚开始写Linux设备驱动程序的时候，很多时候都是利用mknod命令手动创建设备节点，实际上Linux内核为我们提供了一组函数，可以用来在模块加载的时候自动在/dev目录下创建相应设备节点，并在卸载模块时删除该节点，当然前提条件是用户空间移植了udev。 内核中定义了struct class结构体，顾名思义，一个struct class结构体类型变量对应一个类，内核同时提供了class_create(…)函数，可以用它来创建一个类，这个类存放于sysfs下面，一旦创建好了这个类，再调用device_create(…)函数来在/dev目录下创建相应的设备节点。这样，加载模块的时候，用户空间中的udev会自动响应device_create(…)函数，去/sysfs下寻找对应的类从而创建设备节点。 注意，在2.6较早的内核版本中，device_create(…)函数名称不同，是class_device_create(…)，所以在新的内核中编译以前的模块程序有时会报错，就是因为函数名称不同，而且里面的参数设置也有一些变化。 struct class和device_create(…) 以及device_create(…)都定义在/include/linux/device.h中，使用的时候一定要包含这个头文件，否则编译器会报错。
在2.6.26.6内核版本中，struct class定义在头文件include/linux/device.h中： /*device classes*/ struct class { const char *name; struct module *owner; struct kset subsys; struct list_head devices; struct list_head interfaces; struct kset class_dirs; struct semaphore sem; /* locks children, devices, interfaces */ struct class_attribute *class_attrs; struct device_attribute *dev_attrs; int (*dev_uevent)(struct device *dev, struct kobj_uevent_env *env); void (*class_release)(struct class *class); void (*dev_release)(struct device *dev); int (*suspend)(struct device *dev, pm_message_t state); int (*resume)(struct device *dev); }; class_create(…)在/drivers/base/class.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b28998e7a21dd37334dae44a6819249e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72d3ff1d5a58b6eff6c8611a62f7dc7f/" rel="bookmark">
			流量整形，延迟以及ACK丢失对TCP发送时序的影响
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TCP是一个连续不断的涓涓细流或者滚滚长江，但这只是理想情况！经过诸多中间网络设备，最终一个TCP流到达接收端的时候，将可能不再保持一个流的形式，而变成了一阵阵的突发...这些突发产生的ACK反过来反馈到发送端，进而对发送端的发送时序产生影响，也就是说对发送端的数据流进行整形，这真是一个典型的涡轮增压反馈系统，根本不是通常认为的那样不可控或者说另一个极端，仅仅是端到端！想驾驭它其实不是那么难，如果有人说仅仅可以靠感觉就可以驾驭它，倒不如说它本来就是1+1=2那般有条有理。如果觉得TCP的行为很难理解，可能只是因为你在试图破坏网络的规则，网络的规则只有两点：效率和公平。真的，杀一个人很容易，却代价高昂，与人相处，很难，却可以细水长流终一生！ 本文介绍一下网络对TCP发送端时序的影响如何在报文序列上体现出来，使用Wireshark。 1.如何Wireshark看TCP拥塞窗口的大小Wireshark是网络协议分析的利器，不光如此，使用它还可以分析“未体现在数据包”里的信息，比如TCP的拥塞窗口的大小。 TCP的拥塞窗口并未体现在数据包本身，它完全是端到端利用网络的反馈信息通过协议栈自己算出来的，这种反馈包括ACK序列以及超时事件等。那么如何通过Wireshark展示的一个TCP流的包序列分析出TCP的拥塞窗口大小呢。 其实很简单，只要算出in flight的数量即可。TCP的发送窗口等于拥塞窗口(cwnd)与对端通告窗口(awnd)中的最小值： wnd=min(awnd,cwnd) 如果cwnd比awnd大，那可以不关注cwnd，因此其对数据发送无影响(TCP自带了拥塞窗口限制机制，使其不会大得太多，此为制止突发)，因此只关注cwnd小于awnd的情形，此时： wnd=cwnd 我们知道，在TCP形成一个连续的ACK时钟后，发送是平缓的，所谓的平缓指的是发送行为基于网络上的数据包守恒原则，被确认一个，发送一个，因此： cwnd=in flight+tosend tosend是我们将要发送的数据包数量，按照数据包守恒，可以认为tosend是当前被ACK的数据量，按照段数计数，如果接收端未启用delay ACK，那么每次将ACK一个段，即： cwnd=in flight+1 看上面的公式时，请暂时忘记拥塞窗口的突变，后面会讲。接下来，如果对端启用了delay ACK，那么每次将最多ACK 2个段，即： cwnd=in flight+max(thisACKed,2) 请暂时忘记ACK丢失的情况，这个普遍可能发生的现象会在TCP发送端到底是数ACK的数量还是数ACK确认的字节数之间引发争议，我个人倾向于这个选择交给TCP自己来做，这充分考虑到昂贵的无线链路中带宽的前向后向不对称性。然后考虑到拥塞避免阶段，我们可以认为： cwnd=cwnd+(1/cwnd|1) 如果在慢启动阶段，则： cwnd=cwnd+1 因此，最终我们可得到拥塞窗口的大小： cwnd=in flight+max(thisACKed,2)+(1/cwnd|1) 现在的问题是如何去求in flight的大小。非常简单，公式如下： in flight=当前发送到的-当前最后被确认的 我们用一个实际的抓包结果来确认一下，在此之前说明，Wireshark可以为你分析出大多数的in flight报文，只要它能精确确认两个数值：当前发送到的序列号以及当前最后被确认的序列号。因此你可以不必自己去按照上述公式自己去计算，而是直接通过Wireshark就可以看到。我先展示一个确认包： 然后看一下到此为止发送的数据包的序列号： 最后我们算一下in flight的数量以及Wireshark展示的相应的值： 它们是完全一致的！ 有的时候，你可能会发现点击Wireshark中某个数据包的时候，并没有展示出in flight的值，那是因为前面有些数据包没有抓到，而且这些未抓取到的数据包和当前数据包之间又没有ACK包，所以不足以提供上述计算in flight值所需要的元素，因此就不会替你计算，不是没有，而是丢失了信息，计算不出来而已。 但是有的时候，有人完全迷信Wireshark的结果(其实说的就包括我自己)，所以造成了令人遗憾又可悲的结果。这到底是怎么回事呢？且看下节。 2.多余的数据包flight到哪儿了？我做了一个测试，在TCP的发送端加入下列命令模拟一个300ms的数据包延迟： tc qdisc add dev eth0 root netem delay 300ms 然后同样在TCP发送端进行tcpdump抓包，然后用Wireshark来解析。 我们来看3064号ACK包到达发送端时候的情景： 在收到该ACK包之前，发送端发送的最后一个数据包是3063号包，从3063号包中可以看到in flight的大小(见前面计算方法)，数据包里显示的in flight只有不到5个数据包，而这是几乎不可能的，我只是在千兆网络上模拟了一个300ms的延迟而已。此时同步用tcpprobe抓取内核协议栈的相关信息，二者的比较如下所示： 为了展示协议栈里面in flight的值，我修改了tcpprobe，加入了tcp_packets_in_flight(tp)的统计。可以看到732*1460这个大小和Wireshark展示的5840相差甚远！缺失的那些数据flight到哪里了？根据tcpprobe的同一行展示的SND_NXT，我们在Wireshark里面找相关信息： 3633号包和3063号包之间正好相隔570个包，加上3063号包那里已经计算的4个包，一共也才574到575个包，而tcpprobe显示的是732个数据包in flight，那些缺失的哪里去了？这个是因为tcpdump在抓包的时候，由于packet套接字的效率问题，缓冲区爆满，被kernel丢弃了。这就是抓包时显示的“142 packets dropped by kernel”所表达的含义。 要想明确知道原因，需要对抓包的位置有足够的理解。tcpprobe显示的是TCP栈那里的情景，而tcpdump抓取的确实网卡边界的情景，中间隔了一个“qdisc”逻辑，即队列管理。也就是说TCP确实将732个数据段发出去了，因此它会认为其已经in flight了，但是这些数据并没有到达网上，而是到达了qdisc队列里面，考虑到是千兆网络同一网段的模拟，基本可以忽略传输延迟，因此tcpdump抓取的所谓in flight只是qdisc后面到达接收端的in flight。如果用端到端的观点，qdisc确实也是sky的一部分，但是对于tcpdump附着的网卡来讲，qdisc只是一个island，我想这就是区别： 这下上面的疑问应该可以解释了。接下来我先扯一点理论方面的东西。 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72d3ff1d5a58b6eff6c8611a62f7dc7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e05e6601f93a72ba0896cd3dc96c0d31/" rel="bookmark">
			printf()的返回值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { int i=43; printf( "%d\n",printf("%d" ,printf("%d",i))); system( "pause"); return 0; } printf() 返回一个int值，表示被打印的字符数
i=43，先输出43
43为两个字符，输出2
2为一个字符，输出1
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { int n=printf("Hello world!\n"); printf("%d",n); system("pause"); return 0; } 输出结果：Hello world!
13
本文出自 “追寻内心的声音” 博客，转载请与作者联系！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30f604ecc228f47d9791d4c6a51e0a96/" rel="bookmark">
			排序算法-10-算法-分治法（Divide and Conquer）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		##Divide and Conquer - 分治法 在计算机科学中，分治法是一种很重要的算法。分治法即**『分而治之』**，把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个思想是很多高效算法的基础，如排序算法（快速排序，归并排序）等。
###分治法思想 分治法所能解决的问题一般具有以下几个特征：
问题的规模缩小到一定的程度就可以容易地解决。问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。利用该问题分解出的子问题的解可以合并为该问题的解。该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。 分治法的三个步骤是：
分解（Divide）：将原问题分解为若干子问题，这些子问题都是原问题规模较小的实例。解决（Conquer）：递归地求解各子问题。如果子问题规模足够小，则直接求解。合并（Combine）：将所有子问题的解合并为原问题的解。 分治法的经典题目：
Divide and Conquer - 分治法 在计算机科学中，分治法是一种很重要的算法。分治法即『分而治之』，把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个思想是很多高效算法的基础，如排序算法（快速排序，归并排序）等。
分治法思想 分治法所能解决的问题一般具有以下几个特征：
问题的规模缩小到一定的程度就可以容易地解决。 问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。 利用该问题分解出的子问题的解可以合并为该问题的解。 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。 分治法的三个步骤是：
分解（Divide）：将原问题分解为若干子问题，这些子问题都是原问题规模较小的实例。 解决（Conquer）：递归地求解各子问题。如果子问题规模足够小，则直接求解。 合并（Combine）：将所有子问题的解合并为原问题的解。
分治法的经典题目：
二分搜索大整数乘法Strassen矩阵乘法棋盘覆盖归并排序快速排序循环赛日程表汉诺塔 转载于:https://my.oschina.net/corwien/blog/693536
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9883552c29e15b2d54737f591fd4ca7/" rel="bookmark">
			html自动循环播放视频列表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有多个视频，一个播放完以后另一个播放，知道最后，再从头循环播放。 代码如下：
&lt;video id="video1" class="indexBanner" autoplay&gt; &lt;!-- &lt;source src="vedio/first.mp4" type="video/mp4" /&gt; &lt;source src="vedio/second.mp4" type="video/mp4" /&gt; --&gt; &lt;!-- &lt;source src="vedio/second.ogg" type="video/ogg" /&gt; --&gt; Your browser does not support HTML5 video. &lt;/video&gt; &lt;script type="text/javascript"&gt; debugger; var vList = [ 'vedio/first.mp4', 'vedio/second.mp4' ]; // 初始化播放列表 var vLen = vList.length; // 播放列表的长度 var curr = 0; // 当前播放的视频 var video = document.getElementById("video1"); video.addEventListener('ended', play); play(); function play() { var video = document.getElementById("video1"); video.src = vList[curr]; video.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9883552c29e15b2d54737f591fd4ca7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb03e29c33772c016b053ba1a7883b0b/" rel="bookmark">
			svn  TortoiseSVN 回滚版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SVN是一个版本管理工具，在工作中经常使用，尤其是多人合作开发的时候，版本管理显得更加重要。需要使用回退的场景往往都比较“紧急”，今天就记录一下在使用SVN的时候怎么回退到指定的版本，方便以后随时查看。
方法一
右击文件（也可以是文件夹），TortoiseSVN – show log，右击你想要回滚到的版本。
可以看到两个选项：“Revert to this revision”和“Revert changes from this revision”。下面一个一个说：
我们假设有个文件a.js，有版本1，版本2…版本5。首先看“Revert to this revision”，这个比较好理解，也比较常用。就是把文件恢复到某个版本，然后commit，文件就回滚成功了。回滚成功后，所有的历史还存在。例如回滚到版本4，commit之后，会出现新的版本6，但是他的内容和版本4是一样的。
再来看看“Revert changes from this revision”，这个就比较纠结了，他的意思是“取消这个版本的修改”，例如我们在版本1上执行“Revert changes from this revision”，这时候问题就来了，你取消了一个“已经过期的修改”，那么这个文件该使用版本1的前一个版本呢？还是是使用当前的最新版本呢？SVN知道该怎么做，所以它提示冲突，把选择权交给用户：
如果我们同时选中版本1到最新版，执行“Revert changes from this revision”，就没有问题了，因为你把版本1之后的所有修改都“取消”了，SVN自然把文件恢复到版本1之前的版本。但是这和“Revert to this revision”的作用一样了。所以我们一般使用“Revert to this revision”就够了。
方法二
另一个方法就是使用merge命令：
选择第三个，“merge two different trees”，大意就是合并两个版本。
之后选择：把最新版本合并成你想回滚到的那个版本：
注意：不该填的不要填
点击next，后面什么都不用改，点击”Merge”
文件就回滚到了指定的版本了，commit之后，回滚完成。
参考：
http://keenwon.com/1072.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48f099d2eaa1c0e16451829b8d084e23/" rel="bookmark">
			GMT与Etc/GMT地区信息的时区转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 GMT 地区信息的时区 在将来的版本中可能不再支持以下左面一列中的地区信息的时区。可能从 /usr/share/lib/zoneinfo 删除这些文件。左列中的地区信息的时区用右列中对等的时区来替换。 注意： 当设置对一个 zoneinfo GMT[+-]* timezone 变化的 TZ 环境时，时区前必须带一个冒号 (':')。例如，将地区信息的时区设置 TZ=:GMT+1（它位于子午线以东 1 小时）用对等的地区信息的时区设置 TZ=:Etc/GMT-1 替换。
计划删除地区信息 GMT[+-]* 时区不会影响 POSIX-style GMT[+-]* 时区设置，例如 TZ=GMT+1（没有冒号）。相反可能使用与位于 /usr/share/lib/zoneinfo/Etc 下具有相同名称的对等的地区信息时区。POSIX 样式的时区在简写的时区名称中可能只显示字符串 "GMT"，而地区信息的时区显示与 GMT 的偏差。例如，将 POSIX 样式的时区设置 TZ=GMT+1 用对等的地区信息的时区设置 TZ=:Etc/GMT+1 来替换。
参见 environ.5 和 zoneinfo.4 以获取更多信息。
表 4-1 GMT 地区信息的时区 在将来的版本中可能会删除地区信息的时区 用对等的地区信息的时区替换的方法 GMT-12 Etc/GMT+12 GMT-11 Etc/GMT+11 GMT-10 Etc/GMT+10 GMT-9 Etc/GMT+9 GMT-8 Etc/GMT+8 GMT-7 Etc/GMT+7 GMT-6 Etc/GMT+6 GMT-5 Etc/GMT+5 GMT-4 Etc/GMT+4 GMT-3 Etc/GMT+3 GMT-2 Etc/GMT+2 GMT-1 Etc/GMT+1 GMT+1 Etc/GMT-1 GMT+2 Etc/GMT-2 GMT+3 Etc/GMT-3 GMT+4 Etc/GMT-4 GMT+5 Etc/GMT-5 GMT+6 Etc/GMT-6 GMT+7 Etc/GMT-7 GMT+8 Etc/GMT-8 GMT+9 Etc/GMT-9 GMT+10 Etc/GMT-10 GMT+11 Etc/GMT-11 GMT+12 Etc/GMT-12 GMT+13 Etc/GMT-13 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4575c6fa74c9bd4dfd64e77d1cd8ab23/" rel="bookmark">
			oracle--dual-伪表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Oracle提供的最小的工作表，只有一行一列，具有某些特殊功用。
特性 Oracle提供的最小的 表，不论进行何种操作（不要删除记录），它都只有一条 记录——'X'。 例如：执行select * from dual，里面只有一条记录；执行insert into dual values('Y')后，再次查询dual表，仍然显示一条记录。 是sys用户下的一张内部表，所有用户都可以使用DUAL名称访问，无论什么时候这个表总是存在。 例如：执行一个查看当前日期的语句 select sysdate from dual，这条语句在放在放在任何一个 oracle数据库当中都不会报错，所以一般做一些特定查询的时候用这个表是最稳妥的。 用途 select计算常量表达式、 伪列等值 oracle内部处理使它只返回一行数据，而使用其它表时可能返回多个数据行。 查看当前用户 select user from dual; select count(*) from dual; 用做计算器 select 7*9*10-10 from dual； 调用 系统函数 获得当前系统时间 select to_char(sysdate,'yyyy-mm-dd hh24:mi:ss') from dual; 获得主机名 select sys_context('userenv','terminal') from dual; 获得当前locale select sys_context('userenv','language') from dual; 获得一个随机数 select DBMS_RANDOM.random from dual; 查看序列值 创建序列aaa 以1开始，每次加1 create sequence aaa increment by 1 start with 1; 获得序列aaa 的下一个序列值 select aaa.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4575c6fa74c9bd4dfd64e77d1cd8ab23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7823ffe70595d8fccccfc45a1db921e3/" rel="bookmark">
			c&#43;&#43;：指向学生类的指针：求最高成绩
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;iostream&gt; using namespace std; class Student { public: Student(int n,double s) { num=n; score=s; } void out_put(Student stu[],int i) { cout&lt;&lt;"第"&lt;&lt;i+1&lt;&lt;"个学生学号为："&lt;&lt;stu[i].num&lt;&lt;" 学生成绩为："&lt;&lt;stu[i].score&lt;&lt;endl; } int getNumber() { return num; } double getScore() { return score; } private: int num; double score; }; int Max(Student *A) { int k; double MaxScore=A[0].getScore(); for(int i=1;i&lt;5;i++) { if(A[i].getScore()&gt;MaxScore) { MaxScore=A[i].getScore(); k=i; } } return A[k].getNumber(); } int main() { Student stu[5]= { Student(1001,86.5),Student(1002,85.5),Student(1003,100), Student(1004,98.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7823ffe70595d8fccccfc45a1db921e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c5a487d018be3543f2a8530ee9f2dac/" rel="bookmark">
			Linux中的eval的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 功能：告知shell取出eval的参数，重新计算求出参数的内容 语法：eval[参数] eval 可取一连串的参数，然后再依参数本身的特性来执行 参数：参数不限数目，彼此之间用分号隔开 1.执行命令行之前扫描它两次，再次运算求出参数的内容 前面放上eval时，其结果是shell在执行命令行之前扫描它两次 shell第一次执行时，它替换pipe的值 | ，接着eval使它再次扫描命令行，这时shell把 | 看做管道符号了 第一次扫描，变量置换，第二次扫描，执行该字符串所包含的命令cat test.txt 2.eval取得最后一个参数
第一遍扫描后，shell把反斜杠（\）去掉了，当shell再次扫描该行时，它替换了$4的值，并执行echo命令 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/958051a524c9290cba651b1e2f71ae20/" rel="bookmark">
			Android 关闭WebView之后 ，声音或者视频不停止
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 @Override protected void onPause () { _webview.reload (); super.onPause (); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61c6bbc992a94194036820ae2f158c30/" rel="bookmark">
			spark on yarn 的那些坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在公司6个节点的测试集群运行得好好的，结果也很正常，然后放上60个节点的预生产环境，我勒个擦，搞了我两天，主要是生产环境的那些家伙不配合，一个问题搞得拖啊拖
，首先是安全认证问题，截取一两个有意义的吧：
1.没有认证
Caused by: java.io.IOException: javax.security.sasl.SaslException: GSS initiate failed [Caused by GSSException: No valid credentials provided (Mechanism level: Failed to find any Kerberos tgt)]
at org.apache.hadoop.ipc.Client$Connection$1.run(Client.java:680)
at java.security.AccessController.doPrivileged(Native Method)
at javax.security.auth.Subject.doAs(Subject.java:415)
at org.apache.hadoop.security.UserGroupInformation.doAs(UserGroupInformation.java:1671)
at org.apache.hadoop.ipc.Client$Connection.handleSaslConnectionFailure(Client.java:643)
at org.apache.hadoop.ipc.Client$Connection.setupIOstreams(Client.java:730)
at org.apache.hadoop.ipc.Client$Connection.access$2800(Client.java:368)
at org.apache.hadoop.ipc.Client.getConnection(Client.java:1521)
at org.apache.hadoop.ipc.Client.call(Client.java:1438)
... 28 more
Caused by: javax.security.sasl.SaslException: GSS initiate failed [Caused by GSSException: No valid credentials provided (Mechanism level: Failed to find any Kerberos tgt)]
at com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61c6bbc992a94194036820ae2f158c30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4edb2808e7ec9837fbf75ac3bf677524/" rel="bookmark">
			第四节：教你如何快速让浏览器兼容ES6特性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在正文前，本来这一节的内容应该放在第二节更合适，因为当时就有同学问ES6的兼容性如何，如何在浏览器兼容ES6的特性，这节前端君会介绍一个抱砖引玉的操作案例。
为什么ES6会有兼容性问题？
由于广大用户使用的浏览器版本在发布的时候也许早于ES6的定稿和发布，而到了今天，我们在编程中如果使用了ES6的新特性，浏览器若没有更新版本，或者新版本中没有对ES6的特性进行兼容，那么浏览器肯定无法识别我们的ES6代码，好比浏览器根本看不懂我写的let和const是什么东西？只能报错了。这就是浏览器对ES6的兼容性问题。
好消息
哪里有灾难，哪里就有勇士和救兵，针对ES6的兼容性问题，很多团队为此开发出了多种语法解析转换工具，把我们写的ES6语法转换成ES5，相当于在ES6和浏览器之间做了一个翻译官。比较通用的工具方案有babel，jsx，traceur，es6-shim等。
此外，浏览器自身也加快速度兼容ES6的新特性，其中对ES6新特性最友好的是Chrome和Firefox浏览器。
各大转换工具、javascript解析引擎对ES6的支持程度情况，可以参查看这个地址：
'http://kangax.github.io/compat-table/es6/'
坏消息 即使浏览器对ES6新特性开始渐渐支持，但是这还需要很长一段时间，我们不能百分百依赖浏览器本身对ES6的支持度来开发。
虽然出现了各种转换工具，但是到目前为止，还没有一款工具能百分百将ES6的新特性完美地转换成ES5，因为在ES6新增的内容中，存在一些无法在ES5中找到与之匹配的语法，所以不建议在生产环境中使用支持度较低的新特性，后续的教程章节中介绍的新特性前端君也会特意提醒它的兼容性。
学习热情不减
但是，这并不影响我们学习ES6的热情，因为ES6是未来的标准，浏览器支持只是迟早的事。
本节介绍其中一个转换工具的安装和使用情况，安装使用以简单为主，主要是让新手和刚接触的同学对转换工具有感性的认知。再次表明，即使使用了转换工具，我们还是不建议在生产环境大量地使用ES6的特性。
使用转换工具babel
我们选择Babel作为学习和讲解的工具，以及最多人使用的windows作为操作系统。
接下来的前端君建议你打开电脑，跟着教程一步步操作。（没有也不要紧，先收藏此文）
步骤1：制作ES6文件
新建一个html文件，取名为：ES6.html，加上含有ES6新特性的代码，比如：
&lt;script&gt;
const Name = '张三';//使用新增的关键字：const声明常量
alert(Name);
&lt;/script&gt;
步骤2：测试const兼容性
我们在chrome浏览器（版本不能太低）运行ES6.html，会正常运行，弹出“张三”。
接下来我们运行在IE 9，会看到这样的情况：
IE 9浏览器会提示我们第9行出现一个语法错误，相当于告诉我们它看不懂const是什么鬼，但是学过ES6入门系列第三节的我们都知道const是ES6的新增关键字，用于声明一个常量。这个时候我们知道const在IE9浏览器出现了兼容性问题了。
下面我们开始用Babel来兼容它。
我们可以使用npm来安装babel，npm是随同Nodejs一起安装的包管理工具，新版的nodejs已经继承了npm，我们只要安装nodejs即可。对于nodejs的安装，不在本节的学习范围，我就不作展开说明了..........才怪。（说好的简单易懂，前端君怎么会半途掉链子）
步骤3：安装node
来，没安装过的node的同学，我们来一起安装：
node官网（下载安装包.msi）：https://nodejs.org/
（nodejs官网首页截图）
我们点击v4.4.5LTS进行下载，下载后找到node-v4.4.5-x64.msi双击运行,点击next（下一步）安装即可。期间你可以自定义选择安装的位置，默认是C:\ProgramFiles\。最后一步点击 Finish（完成）按钮退出安装向导。
步骤4：检测node是否安装成功
安装结束后，我们检测是否安装成功：
点击 “开始”-&gt; “运行”-&gt; 输入“cmd”-&gt; 进入命令提示符窗口，输入“node --version”来检测当前node的版本。
出现：v4.4.5就表示安装成功，因为我们下载的就是v4.4.5LTS。
步骤5：用npm安装babel
好了，node安装好了，也就是它集成的npm包管理工具也安装好了，接下来，我们利用npm来安装我们最想要的babel。
同样我们启动命令提示符窗口并且输入：npm install babel-core@5，然后回车，这里要稍等片刻：
看到上面的界面就是表示你安装babel成功，你会在电脑盘中找到这样的目录：C:\Users\Administrator\node_modules\babel-core，打开后你会看到：
在这个目录里面我们找到babel的浏览器版本browser.js(未压缩版)和browser.min.js(压缩版)。
步骤6：使用babel
然后我们将这个文件使用在我们的ES6.html中。
&lt;script src="browser.min.js"&gt;&lt;/script&gt;
&lt;script type="text/babel"&gt;
const Name = '张三';//使用新增的关键字：const声明常量
alert(Name);
&lt;/script&gt;
我们把browser.min.js引入（文件位置的路径要确保正确）。并且设置第二个script标签的type为”text/babel”。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4edb2808e7ec9837fbf75ac3bf677524/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd336a082af9ef9456bd6f3788b601f0/" rel="bookmark">
			Linux下Clion编译Cmake报错的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前段时间，在linux下安装了一个C++ 开发的神奇，由JetBrain公司开发的IDE--CLion。之所以称CLion为神器的原因是因为，在linux下没有比这款IDE更强大的开发工具了。
所以，我迫不及待的跑到官网上下载了一个最新版本的Clion，由于我下载的版本是绿色版，不需要进行编译。直接进行解压就好了。linux下的解压命令 tar －zxvf clion.xx.xx;
然后通过bash命令，启动clion，开始了clion下的第一个程序，心情很激动。但是，就在我写完开始build的时候，一直无法编译成功。报的错误都是Cmake相关的。由于现在我已经解决啦，所以就没有对错误现场的截图。然后我以为是我的Cmake版本不对，又跑到cmake官网上进行了最新版本的更换。结果依然抱错。
我在setting中进行cmake设置，发现clion已经包含了正确的cmake版本了。也不是clion的问题。这个时候，我就很困惑了，到网上查很多资料，都没有结果。
后来，我想查询一下我的系统的cmake 版本，所以输入cmake --version。结果提示无cmake命令，我意识到了可能是我linux系统由于是刚刚安装的，没来的及安装cmake，所以才会导致这个原因。
然后，通过：
yum install cmake 完成了cmake的安装，再重新启动clion，结果就正常了。
所以，如果你在linux下进行Clion程序编译是，报的错误是Cmake相关的，可以检查一下Cmake版本和系统是否安装了Cmake。
检查Cmake版本的命令为：
cmake --version 特别提示：cmake由于在linux下的较为复杂，我们直接采用yum install cmake进行安装即可。不要先进行boostrap、make等的安装步骤。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/499481c8c332a28501497f33c618e613/" rel="bookmark">
			OSPF中224.0.0.5和 224.0.0.6两个地址的具体区别是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		224.0.0.6指代一个多路访问网络中DR和BDR的组播接收地址，224.0.0.5指代在任意网络中所有运行OSPF进程的接口都属于该组，于是接收所有224.0.0.5的组播数据包。重点理解好 属于某一组 和 接收怎样的组播数据包，比如 DR/BDR属于组播地址为224.0.0.6的组（Group），因此它接收目的地址为224.0.0.6的组播数据包，也就可以理解为何多路访问通过设置DR/BDR可以防止信息过多处理（因为属于某组的接收者（指OSPF接口），只会剥离到二层，而不会进一步处理，也就省去了很多资源浪费）。
转载于:https://blog.51cto.com/fengye0660/1786531
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ae94a02b5e46886115a666a9995d961/" rel="bookmark">
			【线段树】动态最值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 有一个包含n个元素的数组，要求实现以下操作： DELETE k：删除位置k上的数。右边的数往左移一个位置。 QUERY i j：查询位置i~j上所有数的最小值和最大值。 例如有10个元素： QUERY 2 8的结果为2 9。依次执行DELETE 3和DELETE 6（注意这时删除的是原始数组的元素7）后数组变为： 输入 输入文件minmax.in第一行包含两个数n, m，表示原始数组的元素个数和操作的个数。第二行包括n个数，表示原始数组。以下m行，每行格式为1 k或者2 i j，其中第一个数为1表示删除操作，为2表示询问操作。输出 输出文件minmax.out对每个询问操作输出一行，包括两个数，表示该范围内的最小值和最大值。样例输入 10 4 1 5 2 6 7 4 9 3 1 5 2 2 8 1 3 1 6 2 2 8样例输出 2 9 1 7提示 50%的数据满足1&lt;=n, m&lt;=10^4，删除操作不超过100个 100%的数据满足1&lt;=n, m&lt;=10^6, 1&lt;=m&lt;=10^6 对于所有的数据，数组中的元素绝对值均不超过10^9 题目大意 一段区间可支持删除某节点并且编号改变（类似数组中删除元素）并且支持查询区间最大值最小值。 乍一看这题是一个数组和链表的结合体，想到用块状链表，但是计算一下时间代价是 109 会超时(这里我同学写了，果然超时，详情见传送门)，然后乍一瞅区间最值，也许是线段树，但是又不会删除，就懵逼了。。 后来才知道，原来线段树也可以支持删除节点，只需要在原来的存储方式上变化一下就好了。 做法：把原来的几点存区间左右边界变成类似平衡树那样的存节点size，然后查询的时候比较左右节点的size和当前要查询的点号就行： 查询分三种情况： 1. 查询区间左端点比当前左节点的size小，右端点比做节点size大，证明区间在左右子树中，分别查询。 2. 查询区间左端点比左子节点size小，右端点比左子节点size小，查左子树。 3. 查询区间左端点比左子节点size大，右子节点也比它大，查右子树。 删除分两种： 1. 删除number比左size小，递归左； 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ae94a02b5e46886115a666a9995d961/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c90c480cb1d6ffb128b72d53c44c655/" rel="bookmark">
			Qt简单编程--获取编辑器Text Edit的光标行文本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要获取编辑器Text Edit的光标行文本，本来很简单，可是搜索了半天竟然无果。 有一贴子，看到回复人批评提问者不看帮助，于是我第一次打开帮助搜索Text Edit与QTextCursor，并得到结果。 我从不怀疑所有问题都在Help中得到解答，只是埋怨Qt不是国产的。 真的很简单，一行可获取。
QTextCursor tc; tc = ui-&gt;te_main-&gt;textCursor(); ui-&gt;statusBar-&gt;showMessage(tc.block().text()); te_main就是Text Et控件件。 要注意的是要包括必要的文件头。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a53035500ce5a6bdf315797a1979e15/" rel="bookmark">
			2. Spring Boot返回json数据【从零开始学Spring Boot】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【视频 &amp; 交流平台】 学院中有Spring Boot相关的课程：
à悟空学院：https://t.cn/Rg3fKJD
SpringBoot视频：http://t.cn/A6ZagYTi
Spring Cloud视频：http://t.cn/A6ZagxSR
SpringBoot Shiro视频：http://t.cn/A6Zag7IV
SpringBoot交流平台：https://t.cn/R3QDhU0
SpringData和JPA视频：http://t.cn/A6Zad1OH
SpringSecurity5.0视频：http://t.cn/A6ZadMBe
Sharding-JDBC分库分表实战：http://t.cn/A6ZarrqS
分布式事务解决方案「手写代码」：http://t.cn/A6ZaBnIr
在做如下操作之前，我们对之前的Hello进行简单的修改，我们新建一个包com.kfit.test.web然后新建一个类HelloControoler,然后修改App.java类，主要是的这个类就是一个单纯的启动类。
主要代码如下：
App.java
packagecom.kfit;
importorg.springframework.boot.SpringApplication;
importorg.springframework.boot.autoconfigure.SpringBootApplication;
/**
* Hello world!
*
*/
//其中@SpringBootApplication申明让spring boot自动给程序进行必要的配置，等价于以默认属性使用@Configuration，@EnableAutoConfiguration和@ComponentScan
@SpringBootApplication
public class App {
publicstatic void main(String[] args) {
SpringApplication.run(App.class, args);
}
}
com.kfit.test.web.HelloController：
package com.kfit.test.web;
importorg.springframework.web.bind.annotation.RequestMapping;
importorg.springframework.web.bind.annotation.RestController;
@RestController//标记为：restful
publicclass HelloController{
@RequestMapping("/")
public String hello(){
return"Hello world!";
}
}
运行代码和之前是一样的效果的。
我们在编写接口的时候，时常会有需求返回json数据，那么在spring boot应该怎么操作呢？主要是在class中加入注解@RestController,。
返回JSON之步骤：
(1)编写一个实体类Demo
(2)编写DemoController；
(3)在DemoController加上@RestController和@RequestMapping注解；
(4)测试
具体代码如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a53035500ce5a6bdf315797a1979e15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2779fe52c14a6c0e88eb34b1a2a9c024/" rel="bookmark">
			Qt 预编译头文件(precompiled headers) 加快编译速度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		预编译头文件: precompiled headers, 将不经常改动的代码编译成二进制文件, 在之后每次编译的时候可会直接调用这些预编译头文件的二进制文件, 实现加快编译速度.
简单点说就是: 可以把不常更改的头文件, 通过预编译头文件的方式进行一次编译, 提高之后的编译速度. 就是为了加快编译速度, 就是为了加快编译速度, 就是为了加快编译速度!
1. Qt支持的平台 qmake 支持的预编译头(precompiled headers)的编译器包括: - Windows nmake Visual Studio projects (VS 2008 and later) - OS X and iOS Makefile Xcode - Unix GCC 3.4 and above 2. 具体使用 非常简单, 官方有介绍.
2.1 先写一个stable.h 这个stable.h里面包含的就是需要预编译的头文件
// Add C includes here #if defined __cplusplus // Add C++ includes here #include &lt;stdlib&gt; #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;QApplication&gt; // Qt includes #include &lt;QPushButton&gt; #include &lt;QDebug&gt; #include "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2779fe52c14a6c0e88eb34b1a2a9c024/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ffb43d69f06183e0351e6d52fb4767d/" rel="bookmark">
			群体寻路算法Flow Field Pathfinding
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AI Flow Field Pathfinding Flow Field Pathfinding Leif Erkenbrach December 5, 2013 AI, Programming One of the most important and wide reaching subjects of artificial intelligence in video games is pathfinding. One of the most commonly used methods of pathfinding in games at the moment is the A* algorithm. This algorithm is capable of finding the shortest path between two points when given a graph to traverse. This method is an acceptable solution to pathfinding in most situations, but there are a few cases where A* is not able to meet the requirements of an application.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ffb43d69f06183e0351e6d52fb4767d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba9f7183f7172553cfe32606af29c450/" rel="bookmark">
			J2ee项目从0搭建(一):eclipse下载、安装、使用习惯配置迁移
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 JDK安装我们默认已经安装好了，推荐JDK1.7以上。 1.eclipse下载：在eclipse官网下载最新版本，http://www.eclipse.org/downloads/：在这里我们选择Eclipse IDE for Java EE Developers，如图按步下载；也可以通过我的网盘地址直接下载：https://yunpan.cn/cS435Jnw9dgxm 访问密码 6e42 2、eclipse安装：将压缩包解压到指定目录，在解压的eclipse目录下找到eclipse.exe点击右击发送桌面快捷方式，即可点击桌面图标启动. 3、eclipse启动:双击启动后，弹出项目空间选择框，可以使用默认空间，也可以自己指定项目空间。勾选Use this as the default and do not ask again.此对话框就不会每次弹出了。 4、eclipse使用习惯配置迁移：换电脑、换公司、换eclipse版本，每次都配置一些字体、大小以及个性化的设置比较浪费时间，其实eclipse可以将General下的Preferences到出并导入到另一个eclipse中就可以将使用习惯带入新的eclipse中。 导出：点击File-&gt;Export-&gt;General-&gt;Preferences，点击Next，点击Browse，选择eclipse.epf（我这么命名的）的存储路径，最终点击Finish。 导入：点击File-&gt;Import-&gt;General-&gt;Preferences，点击Next，点击Browse，选择刚才导出所保存的eclipse.epf文件，最终点击Finish。 效果对比： 原始效果： 改变效果： 我的eclipse.epf是这样的： http://download.csdn.net/detail/u010246789/9538743 ====================================================================================================================== 为了便于大家学习，项目将被开源在我的github上： 项目地址：https://github.com/gubaijin/buildmavenweb 如何将项目开源道github，请看我的另一篇博文：GitHub上创建项目 并初始化本地工程提交到GitHub上 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75f286147b64e3db7285cf8489d08f42/" rel="bookmark">
			CC2530之UART串口通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用单片机的串口与计算机通信，可方便对各种实验数据进行观察。 CC2530有两个串口，分别为USART0和USART1。由于采用了引脚复用功能，外设与引脚对应的关系可根据外设控制寄存器PERCFG进行配置，具体对应情况如下： UART0对应的外部引脚关系，位置1：Rx - P0_2 Tx - P0_3 ；位置2：Rx - P1_4 Tx - P1_5 UART1对应的外部引脚关系，位置1：Rx – P0_5 Tx – P0_4；位置2：Rx - P1_7 Tx - P1_6 由寄存器UxBAUD.BAUD_M[7： 0]和UxGCR.BAUD_E[4： 0]定义波特率。 串口波特率设置公式： 选择外部32MHz晶振时，具体值可参阅下表： 测试程序如下： #include &lt;iocc2530.h&gt; #define uint unsigned int #define uchar unsigned char void setSysClock(); void uart0Init(); void uart0SendStr(uchar *str); void main() { setSysClock(); uart0Init(); uart0SendStr("Hello world\n"); while (1) { } } /** * 设置系统时钟为32MHz */ void setSysClock() { CLKCONCMD &amp;= ~0x40; // 选择系统时钟源为外部32MHz crystal oscillator while(CLKCONSTA &amp; 0x40); // 等待晶振启动 CLKCONCMD &amp;= ~0x47; // 设置系统时钟频率为32MHZ } /** * 8-bit数据位，无奇偶校验，Baud:115200bps */ void uart0Init() { PERCFG = 0x00; // 外设控制，UART0选择端口位置1 P0SEL = 0x0C; // 端口0功能选择，P0_2、P0_3用作串口 P2DIR &amp;= ~0xC0; // 端口0外设优先级控制，高2位置0，USART0优先 U0CSR |= 0x80; // UART模式 U0GCR |= 11; U0BAUD |= 216; // 采用32MHz系统时钟时，波特率设置为115200 UTX0IF = 0; // UART0 TX中断标志初始置位0 } void uart0SendStr(uchar *str) { while (*str !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75f286147b64e3db7285cf8489d08f42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf0e6bc64648394565e41476a5af13af/" rel="bookmark">
			bitmap.setPixels()方法及自己理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给bitmap赋像素值的方法有两种：
1. bitmap.setPixel(int x,int y,color)此方法功能为给bitmap中的某个像素赋RGB值。
参数 x,y表示该像素的坐标。color为整型的RGB值。
2.bitmap.setPixels(int [] pixels,int index,int stride, int x,int y,int width, int length)
参数 pixels数组表示像素RGB值
index表示从数组的那里开始
stride表示bitmap的跨宽，其中除了一行像素点的个数外还有其他信息，所以通常stride要大于width的值。
x,y表示从bitmap的哪个坐标开始。
width, length表示多宽多行
其中记住width*length要小于或等于pixels的数组长度，否则会抛出异常。
注：本人第一次写博客，存在很多瑕疵甚至错误，希望各大神指教！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95d13bb467ac59b625ce51d4f4c0c3d5/" rel="bookmark">
			音频格式DTS 和 AC3 和 AAC简单介绍及HDTV
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DTS：全称为Digital Theater Systems(数字影院系统)，是一种有损多声道家庭影院音频格式，但它用了很高的码率进行编码，通常为768-1536kbps，能够营造出比AC3更好的影院效果。
AC3, 全称为Audio Coding version 3，是Dolby实验室所发展的有损音频编码格式。AC3最被广泛应用于5.1声道，是Dolby Pro Logic的继承者，不同的地方在于AC3提供6个独立的声道而Pro Logic混合其环绕声道。AC3普及度很高，以384-448 kbps的码率应用于LaserDisc和DVD，也经常以640 kbps的码率广泛用在电影院。
比较一下AC3和DTS
AC3（Dolby Digital Audio Code v3）和DTS(Digital Theater Sound)这两种影院级的数字环绕系统已被广泛运用在DVD影碟的声音编码。也是爱好者们讨论最多的话题。两者都是基于多声道的编码技术，通用5.1声 道（三组全频立体声）--左/右前置，中置/低音，左/右后置环绕。其中低音单元专门重放120HZ以下的低频，以增强效果。
从数据流量来看，AC3通常为384/448Kbps,采用了高压缩编码（12：1），通过大副删除在理论上认为多余的细节信号，从而达到减少数据 量的目的。实际上AC3的编码技术相当优秀，在如此低的数据流量下带给观众的依然是较为真实的声音体验。
DTS的数据流量通常为768/1536Kbps,压缩比只有3：1，其从提高数字空间的利用率着手，使信息数据得以充分利用。理论上它的声场无论 在真实性、细腻性、连续性、宽广性和层次性方面优于AC3。
因为DTS与AC3格式大多数音响发烧友都很熟悉，下面主要介绍AAC。
AAC，全称为Advanced Audio Coding(高级音频解码)，是一种由MPEG-4标准定义的有损音频压缩格式，由Fraunhofer发展，Dolby, Sony和AT&amp;T是主要的贡献者。在使用MP4作为各种内容的容器格式的新多媒体MPEG-4标准中，它是MPEG Layer III( MP3)的天然后继者。AAC能够在一条音轨中包括48条全带宽（直到96khz）音频声道，加上15条低频增强（LFE，限制到120Hz）声道，直到15条数据流并且更多。杜比也参与了AAC的开发，MPEG规格的一部分，及考虑继承MP3。AAC能输出AC-3的任何码率，胜过AC-3，压缩率更高，但技术上更加复杂。AAC在5.1声道中以400 Kbps和双声道中以180 Kbps输出，就已经能提供良好的聆听效果。
ACC 的特点：提升的压缩率：可以以更小的档大小获得更高的音质；支持多声道 ： 可提供最多48 个全音域声道；更高的分辨率：最高支持96KHz 的取样频率；提升的解碼效率：译码播放所占的资源更少。
AAC 是个大家族，目前已经制定了如下的9 种规格，以适应不同场合的需要：
MPEG-2 AAC LC 低复杂度规格（Low Complexity）
MPEG-2 AAC Main 主规格
MPEG-2 AAC SSR 可变取样率规格（Scalable Sampling Rate）
MPEG-4 AAC LC 低复杂度规格
MPEG-4 AAC Main 主规格
MPEG-4 AAC SSR 可变取样率规格（Scalable Sampling Rate）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95d13bb467ac59b625ce51d4f4c0c3d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92b179b6032421e5253c30a187360695/" rel="bookmark">
			Mantle迅速上手
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，不要害怕，他是帮助我们简化问题的（比如自动降NSNull转成nil，减少崩溃的可能），所以并不会难用。 我们通常用的就是MTLJSONAdapter，MTLModel tip 1：继承MTLModel，遵守MTLJSONSerializing协议 你需要实现这个方法来写明一下映射关系，这个是我觉得Mantle不好的一点，如果属性和传过来的接口是一样的名字，也必须要在这个方法里一一对应，不太好，MJExtension就不需要。
+ (NSDictionary *)JSONKeyPathsByPropertyKey 用的时候 data转字典
[NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers error:nil]; 字典转模型
Model *model = [MTLJSONAdapter modelOfClass:[Model class] fromJSONDictionary:dict error:nil]; 如果你的模型里面想要的是NSDate， 但是传过来的是NSNumber的话，你可以实现这个方法来转换一下。
+ (NSValueTransformer *)dateJSONTransformer { // 这里要注意哦，你要在方法名前面加上你要修改的属性名哦 return [MTLValueTransformer reversibleTransformerWithForwardBlock:^(NSNumber *dateNum) { return [NSDate dateWithTimeIntervalSince1970:dateNum.floatValue]; } reverseBlock:^(NSDate *date) { return [NSString stringWithFormat:@"%f",[date timeIntervalSince1970]]; }]; } 这里面reverseBlock是用来模型转json的
也就是这个方法
+ (NSDictionary *)JSONDictionaryFromModel: 当你的模型里有的属性是数组的话，你就需要告诉他一下，这个数组里面放的是什么模型，也就是实现这个方法
+ (NSValueTransformer *)recommendListJSONTransformer { // 这里的命名方式同上 return [MTLJSONAdapter arrayTransformerWithModelClass:[XXXModel class]]; } 如果你的模型里的一个属性是另一个Model的话，那么你就需要实现这个方法
+ (NSValueTransformer *)companyInfoJSONTransformer { // 这里的命名方式同上 return [MTLJSONAdapter dictionaryTransformerWithModelClass:[XXXModel class]]; } 当你想把模型存储起来的时候你可以酱紫操作。 归档操作
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92b179b6032421e5253c30a187360695/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11b6bfcef8764a1d636339e400defbda/" rel="bookmark">
			单例模式惹得祸
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景
有个单例的工具类需要用到GLmapView的接口，为了使用方便吧GLmapView作为了单例对象的成员，后来发现在切后台回来会偶现调用GLmapView的接口会不生效。
二、问题原因
GLmapView和MapContainer是共生共存的，而MapContainer附着在NewMapActivity窗口上，在程序切后台时窗口有可能被onDestroy掉，MapContainer自然也被销毁了，待界面回到前台MapContainer和GLmapView都要被重新创建，所以此时操作的是一个应该被废弃的句柄，这样做不仅会走到错误的指针上，还有可能因为使用强引用导致引擎无法回收这个GLmapView.
三、埋坑
如果一定需要作为工具类的成员使用，首先应该把它转化为弱引用，其次每次在使用的时候都给它传一个最新的句柄
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1bdedd9189ee728b22cfbb0508c24e0/" rel="bookmark">
			Arduino 和LCD1602液晶屏 I2C接口实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LCD1602液晶屏 带I2C接口 为什么使用I2C接口？因为省IO口啊，只需要4条线，可以看看之前发的实验，接线多复杂呀，对吧。
（传送门：Arduino携手LCD1602 向世界问好“hello World！”）
还有背光灯，和可调节对比度（就是背面蓝色那块可以旋转的调）
具体怎么实现解决问题，请往下看
引脚说明 GND ------ 地线 VCC ------ 电源（5V or 3.3v 电源不同显示效果有点差别）
SDA ------ I2C 数据线
SCL ------ I2C 时钟线
接线方法 LCD1602 i2c模块 Ardunio Uno
GND &lt;------&gt; GND接地线
VCC &lt;------&gt; 5V 接电源
SDA &lt;------&gt; A4
SCL &lt;------&gt; A5
程序实现 需要用到LCD1602 I2C的库，下载地址是 https://github.com/marcoschwartz/LiquidCrystal_I2C
把下载的库放到Arduino的库里（PS：不懂库是啥？请点击这里）
程序和库打包下载：https://u16460183.ctfile.com/fs/16460183-295783929
文件夹说明：
LiquidCrystal_I2C-master ——LCD1602 I2C库(库需要复制在arduino的库目录里)
LS_LCD1602 ——主程序
//LingShun lab #include &lt;Wire.h&gt; #include &lt;LiquidCrystal_I2C.h&gt; //引用I2C库 //设置LCD1602设备地址，这里的地址是0x3F，一般是0x20，或者0x27，具体看模块手册 LiquidCrystal_I2C lcd(0x3F,16,2); void setup() { lcd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1bdedd9189ee728b22cfbb0508c24e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d99082c60005950c501ff27a52e03ce1/" rel="bookmark">
			为什么构造函数不能够使虚函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虚函数可谓是C＋＋与其它的面向对象语言最大的区别了。虚函数的存在使为了多态，Java当然也有多态。不过实现方式并不是通过虚函数，我们这里就不做介绍了。
虚函数的作用主要是为了继承的时候，子类通过继承虚函数的接口，而实现子类自定义的函数接口，我们通过虚函数表的方式寻找到子类对应的接口。从而实现，一个接口多种实现方式的多态功能。
那么，有一个问题，构造函数是否能够设置为虚函数？答案是否定的。但是为什么呢？构造函数之所以不能设置成虚函数，主要有以下的几个原因。下面分别阐述一下。
1.虚函数的作用是什么？是实现部分或默认的功能，而且该功能可以被子类所修改。如果父类的构造函数设置成虚函数，那么子类的构造函数会直接覆盖掉父类的构造函数。而父类的构造函数就失去了一些初始化的功能。这与子类的构造需要先完成父类的构造的流程相违背了。而这个后果会相当严重。
2.虚函数的调用是需要通过“虚函数表”来进行的，而虚函数表也需要在对象实例化之后才能够进行调用。在构造对象的过程中，还没有为“虚函数表”分配内存。所以，这个调用也是违背先实例化后调用的准则。
3.虚函数的调用是由父类指针进行完成的，而对象的构造则是由编译器完成的，由于在创建一个对象的过程中，涉及到资源的创建，类型的确定，而这些是无法在运行过程中确定的，需要在编译的过程中就确定下来。而多态是在运行过程中体现出来的，所以是不能够通过虚函数来创建构造函数的，与实例化的次序不同也有关系。
那么虚够函数为什么可以设计成虚函数呢？由于虚函数是释放对象的时候才执行的，所以一开始也就无法确定析够函数的。而去由于析构的过程中，是先析构子类对象，后析构父类对象。所以，需要通过虚函数来指引子类对象。所以，如果不设置成虚函数的话，析构函数是无法执行子类的析构函数的。
所以，基于以上几点原因，构造函数是不能够设置成虚函数的，而析构函数是要设置成虚函数的。而且这个也是面试中会经常提及的考点。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6828df9c332b5b4f093e5ec0f50af97a/" rel="bookmark">
			使用ajax遇到的的不提交服务器问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么80%的码农都做不了架构师？&gt;&gt;&gt; 在使用ajax异步发送数据时，一定要使用post方式，否则会出现第一次提交成功，而出现第二次不提交的问题。
也可以使用这种方式解决：
在服务器端使用response.setHeader("Cache-Control","no-cache");来解决。 转载于:https://my.oschina.net/csmw00/blog/683666
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46555d1824dc8e53f7462c0b2779614a/" rel="bookmark">
			BigDecimal的用法详解(保留两位小数,四舍五入,数字格式化，科学计数法转数字，数字里的逗号处理）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简介 Java在java.math包中提供的API类BigDecimal，用来对超过16位有效位的数进行精确的运算。双精度浮点型变量double可以处理16位有效数。在实际应用中，需要对更大或者更小的数进行运算和处理。float和double只能用来做科学计算或者是工程计算，在商业计算中要用java.math.BigDecimal。BigDecimal所创建的是对象，我们不能使用传统的+、-、*、/等算术运算符直接对其对象进行数学运算，而必须调用其相对应的方法。方法中的参数也必须是BigDecimal的对象。构造器是类的特殊方法，专门用来创建对象，特别是带有参数的对象。
二、构造器描述 BigDecimal(int) 创建一个具有参数所指定整数值的对象。
BigDecimal(double) 创建一个具有参数所指定双精度值的对象。
BigDecimal(long) 创建一个具有参数所指定长整数值的对象。
BigDecimal(String) 创建一个具有参数所指定以字符串表示的数值的对象。
三、方法描述 add(BigDecimal) BigDecimal对象中的值相加，然后返回这个对象。
subtract(BigDecimal) BigDecimal对象中的值相减，然后返回这个对象。
multiply(BigDecimal) BigDecimal对象中的值相乘，然后返回这个对象。
divide(BigDecimal) BigDecimal对象中的值相除，然后返回这个对象。
toString() 将BigDecimal对象的数值转换成字符串。
doubleValue() 将BigDecimal对象中的值以双精度数返回。
floatValue() 将BigDecimal对象中的值以单精度数返回。
longValue() 将BigDecimal对象中的值以长整数返回。
intValue() 将BigDecimal对象中的值以整数返回。
四、常用方法
4.1、保留两位小数
/** * 保留两位小数 */ @org.junit.Test public void formatTest() { double num=13.154215; //方式一 DecimalFormat df1 = new DecimalFormat("0.00"); String str = df1.format(num); System.out.println(str); //13.15 //方式二 // #.00 表示两位小数 #.0000四位小数 DecimalFormat df2 =new DecimalFormat("#.00"); String str2 =df2.format(num); System.out.println(str2); //13.15 //方式三 //%.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46555d1824dc8e53f7462c0b2779614a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/082feb2ae005ceb1b5889a4d20d1072d/" rel="bookmark">
			angularjs对json数据的操作--收货地址列表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文包含方法 angular.fromJson，angular.forEach，angular.toJson的使用
这是一个收货地址列表，实现点击删除地址功能。
数据库中是 存的 json字符串
浏览器获取数据后，转成了json格式
注意： //这个不需要删除，因为发送的时候不在参数里面,大概是firebug的原因吧，不过没关系。 //delete address_paramater.$$hashKey; 页面加载时获取到的地址列表
........ var address_json=angular.fromJson(usersaddress);//转换为json console.info(address_json); //提取address 去掉一层壳 $rootScope.addresslist = address_json.address; $scope.addlist = $rootScope.addresslist; 删除方法的代码
$scope.onItemDelete = function(item) { //这个是demo自带的方法 $scope.addlist.splice($scope.addlist.indexOf(item), 1); //通过console.log发现，splice后的$scope.addlist 就是减掉之后，目前的数据，下图 var address_paramater=$scope.addlist; //这个不需要删除，因为发送的时候不在参数里面 //delete address_paramater.$$hashKey; //因为发送的地址 必须要带[],循环将对象插入集合 //test1 = []; //angular.forEach(address_paramater,function(data,index,array){ // //data:遍历时当前的数据 data等价于array[index] // //index:遍历时当前索引 // //array:需要遍历的集合，每次遍历时都会把objs原样的传一次。 // test1.push(data); //}) //包一层address //var address_string=angular.toJson({'address':test1}); var address_string=angular.toJson({'address':address_paramater}); //执行修改 update_address.updatauseraddress(uid, address_string); //接收到返回的通知 $scope.$on('updata.usersaddress', function () { var bool = update_address.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/082feb2ae005ceb1b5889a4d20d1072d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a7a36a91fd52f47ac9de8a67bb4ac58/" rel="bookmark">
			device_create_file函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. device_create_file
int device_create_file(struct device *, struct device_attribute *);
在/sys/devices/xxx/目录下创建device属性文件
void device_remove_file(struct device *, struct device_attribute *);
移除/sys/devices/xxx/目录下的device属性文件 2. driver_sysfs_add
from link：http://blog.csdn.net/yj4231/article/details/7799245（Linux设备模型——设备驱动模型和sysfs文件系统解读）
static int driver_sysfs_add(struct device *dev) { int ret; /* 在/sys/bus/platform/drivers/s3c2410-spi目录下建立symlink，链接名为kobj-&gt;name(s3c2410-spi.0)， 链接指向/sys/devices/platform/s3c2410-spi.0 */ ret = sysfs_create_link(&amp;dev-&gt;driver-&gt;p-&gt;kobj, &amp;dev-&gt;kobj, kobject_name(&amp;dev-&gt;kobj)); if (ret == 0) { /* 在/sys/devices/platform/s3c2410-spi.0/下建立symlink，链接名为driver， 指向/sys/bus/drivers/s3c2410-spi */ ret = sysfs_create_link(&amp;dev-&gt;kobj, &amp;dev-&gt;driver-&gt;p-&gt;kobj, "driver"); if (ret) sysfs_remove_link(&amp;dev-&gt;driver-&gt;p-&gt;kobj, kobject_name(&amp;dev-&gt;kobj)); } return ret; } static int driver_sysfs_add(struct device *dev) { int ret; /* 在/sys/bus/XXX/drivers/XXX目录下建立symlink，链接名为kobj-&gt;name， 链接指向/sys/devices/platform/XXX */ ret = sysfs_create_link(&amp;dev-&gt;driver-&gt;p-&gt;kobj, &amp;dev-&gt;kobj, kobject_name(&amp;dev-&gt;kobj)); if (ret == 0) { /* 在/sys/devices/platform/XXX/下建立symlink，链接名为driver， 指向/sys/bus/xxx/drivers目录下的某个目录*/ ret = sysfs_create_link(&amp;dev-&gt;kobj, &amp;dev-&gt;driver-&gt;p-&gt;kobj, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a7a36a91fd52f47ac9de8a67bb4ac58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cb5b8fd9378333f81159248e2be25e1/" rel="bookmark">
			Java抽象类与接口的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/* * 当一个抽象类中的方法都是抽象的时候,这时可以将该抽象类用另外一种形式定义和表示,就是 接口 interface * * 对于接口当中常见的成员,而且这些成员都是固定的修饰符 * 1.全局变量:public static final * 2.抽象方法 public abstract * 由此得出结论,接口中的成员都是公共的权限 */ /* * 定义接口 */ interface Demo{ public static final int NUM = 4; public abstract void show1(); public abstract void show2(); } /* * 类与类之间是继承关系,类与接口之间是实现关系 */ /* * 接口不可以实例化 * 只能由实现了接口的子类并覆盖了接口中所有的抽象方法后,该子类才可以实例化,否则,这个子类就是一个抽象类 */ class DemoImpl implements Demo{ public void show1() { } public void show2() { } } /* * 在Java中不直接支持多继承,因为会出现调用的不确定性 * 所以Java将多继承机制进行改良,在Java中变成了多实现 * 一个类可以实现多个接口 */ /* * 接口的出现避免了单继承的局限性 */ /* * 接口与接口之间是继承关系,而且接口可以多继承 * 类与类直接是继承,单继承 * 类与接口是实现,可以多实现 */ /* * 接口的特点 * 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cb5b8fd9378333f81159248e2be25e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2791a9661c0584f0bc2df9a88c622455/" rel="bookmark">
			QCustomPlot实现矩形缩放图表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QCustomPlot实现矩形缩放图表 意图 我们知道图表有些基本的功能，比如放大（ZoomIn）、缩小（ZoomOut）、拖拽（Drag）、恢复（1：1或ZoomReset）。这些功能QCustomPlot已经几乎都有了，但是选择矩形区域进行缩放的功能没有给出很好的接口，这可能就要我们自己实现了，这就是写这篇文章的目的。
实现 QCustomPlot本身有缩放的功能，但是没有实现矩形缩放的接口，所以实现的话无非是在图表上面实现鼠标选择的矩形区域，然后进行比例缩放。我们借助Qt自带的QRubberBand来实现矩形选择区域。看帮助文档和源码，我们可以看到当鼠标在图表区域上的时候，包括鼠标按下，移动，释放，这些动作会发送信号。
所以有两种方法实现：
我们只要以父控件实现槽函数来绑定这些信号来做特定处理就行了实现QCustomPlot的子类，重载鼠标按下，移动，释放等鼠标事件函数 父控件槽函数实现方法 按照QCustomPlot提供的例子，我们写一个最简单的例子。 把QCustomPlot设为MainWindow的centralWidget。
少废话了，上源码吧： MainWindow的头文件
#ifndef MAINWINDOW_H #define MAINWINDOW_H #include &lt;QMainWindow&gt; #include &lt;QRubberBand&gt; namespace Ui { class MainWindow; } class MainWindow : public QMainWindow { Q_OBJECT public: explicit MainWindow(QWidget *parent = 0); ~MainWindow(); private slots: void mousePress(QMouseEvent* mevent); void mouseMove(QMouseEvent *mevent); void mouseRelease(QMouseEvent *mevent); void slotBtn(); private: Ui::MainWindow *ui; QRubberBand *rubberBand; QPoint rubberOrigin; }; #endif // MAINWINDOW_H MainWindow的构造函数实现
//初始化QRubberBand rubberBand = new QRubberBand(QRubberBand::Rectangle, ui-&gt;customPlot); //从自带的例子中复制的代码 ui-&gt;customPlot-&gt;addGraph(); ui-&gt;customPlot-&gt;graph(0)-&gt;setPen(QPen(Qt::blue)); // line color blue for first graph ui-&gt;customPlot-&gt;graph(0)-&gt;setBrush(QBrush(QColor(0, 0, 255, 20))); // first graph will be filled with translucent blue ui-&gt;customPlot-&gt;addGraph(); ui-&gt;customPlot-&gt;graph(1)-&gt;setPen(QPen(Qt::red)); // line color red for second graph // generate some points of data (y0 for first, y1 for second graph): QVector&lt;double&gt; x(250), y0(250), y1(250); for (int i=0; i&lt;250; ++i) { x[i] = i; y0[i] = qExp(-i/150.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2791a9661c0584f0bc2df9a88c622455/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2a95f6d1d92c4abb58813760aa03ae5/" rel="bookmark">
			行内元素产生水平空隙的原因及解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近发现行内元素有时会莫名其妙的产生水平空隙，开始以为是外边距导致的，于是把所有的行内元素外边距都设置为0，结果还是存在，代码如下：
&lt;div class="span-wrap"&gt; &lt;span&gt;行内元素&lt;/span&gt; &lt;span&gt;行内元素&lt;/span&gt; &lt;span&gt;行内元素&lt;/span&gt; &lt;span&gt;行内元素&lt;/span&gt; &lt;span&gt;行内元素&lt;/span&gt; &lt;span&gt;行内元素&lt;/span&gt; &lt;/div&gt; 效果如下： 最终发现行内元素之间产生空隙的，是由于换行符、tab（制表符）、空格等字符引起。
下面提供了四种解决方案：
方法一：暴力删除行内元素之间的换行符、tab（制表符）、空格等字符
&lt;div class="span-wrap"&gt;&lt;span&gt;行内元素&lt;/span&gt;&lt;span&gt;行内元素&lt;/span&gt;&lt;span&gt;行内元素&lt;/span&gt;&lt;span&gt;行内元素&lt;/span&gt;&lt;span&gt;行内元素&lt;/span&gt;&lt;span&gt;行内元素&lt;/span&gt;&lt;/div&gt; 这种方法会造成代码堆成一堆，看起来很不舒服，影响阅读
方法二：利用HTML注释
&lt;div class="span-wrap"&gt; &lt;span&gt;行内元素&lt;/span&gt;&lt;!-- --&gt;&lt;span&gt;行内元素&lt;/span&gt;&lt;!-- --&gt;&lt;span&gt;行内元素&lt;/span&gt;&lt;!-- --&gt;&lt;span&gt;行内元素&lt;/span&gt;&lt;!-- --&gt;&lt;span&gt;行内元素&lt;/span&gt;&lt;!-- --&gt;&lt;span&gt;行内元素&lt;/span&gt; &lt;/div&gt; 这种方法不仅增加了代码量，而且影响了HTML的代码结构
方法三：指定margin属性为负数
.span-wrap span{ margin-left: -4px; } 这是最糟糕的方案了，因为你必须根据具体情况去计算，有时还不对，你应该尽量避免这样做。
方法四：设置font-size：0，消除换行符、tab（制表符）、空格等字符
使用此方法时需要注意两点：
1.IE6，IE7浏览器当设置font-size：0时，换行符、tab（制表符）、空格始终存在1px的空隙 2.最新版本的Safari浏览器，Chrome浏览器不支持字体大小为0的浏览器
通过查找资料后，一种比较正常的解决方法如下：
1.针对IE6、7浏览器，使用word-spacing 修复 IE6、7 中始终存在的 1px 空隙，减少单词间的空白（即字间隔） word-spacing:-1px;
2.使用webkit的私有属性，让字体大小不受设备终端的调整，可定义字体大小小于12px html{-webkit-text-size-adjust:none;}
css代码如下：
html{ -webkit-text-size-adjust:none;/* 使用webkit的私有属性，让字体大小不受设备终端的调整，可定义字体大小小于12px */ } .span-wrap { font-size:0;/* 所有浏览器 */ *word-spacing:-1px;/* 使用word-spacing 修复 IE6、7 中始终存在的 1px 空隙，减少单词间的空白（即字间隔） */ } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2a95f6d1d92c4abb58813760aa03ae5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99531db5002b31fbd9a7dc25e7926374/" rel="bookmark">
			系统断点在哪里&amp;&amp;如何断在TLS回调前
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统断点 Windows
当你调试一个程序时，系统给了我们一次机会在被调试前。 ntdll.dll-LdrpDoDebuggerBreak() 如图： 通过一个int3断点来实现应用程序启动前将控制权传递给调试器。该函数一般被映射在0x771E1CC8，如果不存在调试器或者，启动应用的调试器不理睬这个断点，该函数自己的异常处理程序。 有些壳程序的反调试也是采用类似的手法，一旦壳程序的异常处理程序没有被调用，则表明有调试程序接管了壳程序埋伏的异常。
由ntdll将调用权交给主线程的位置-如何断在TLS回调前 我真心想分享自己调试的内容给你。但是不同系统位置不同。
win7专业版64bit系统32bit程序： 断在：0x77479ED0，即ntdll.dll(32bit)是一条call eax，可以断下所有模块加载前，包括TLS回调前和主程序前。位于___RtlUserThreadStart(x,x)
win7家庭版64bit系统32bit程序： 断在TLS前： kernel32.dll;offset:3388
jne call edx;在这里。 push eax call 你可以通过用VS编写一个TLS回调程序，用VS断在该代码，通过栈回溯，找到是谁调用了该代码。
如何找到dll模块的调用关键点呢？ 它在ntdll.dll(32bit)的如下位置： 掌握自己系统中的常用断点位置，调试时候少很多周折。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ad373e15200c325035aa59a46f833ab/" rel="bookmark">
			Cause: java.sql.SQLException: Connection is read-only. Queries leading to data modification are not
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Cause: java.sql.SQLException: Connection is read-only. Queries leading to data modification are not 在进行修改数据库的时候出现了这个异常 很明显这个是只读引起的
可是事实上我们的数据账号权限很高，说明不是权限问题，说明是事务问题了 原因：你配置了只读事务 解决办法：
看下你的service层是否配置@Transactional(readOnly=true) 如果上面你没有配置的话，那就是spring切面引起的 在spring的配置文件中：
&lt;aop:config &lt;aop:advisor pointcut-ref="servicePointcut" advice-ref="txAdvice"/&gt; &lt;/aop:config&gt; &lt;!-- 事务的传播特性 --&gt; &lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;tx:attributes&gt; &lt;tx:method name="get*" propagation="REQUIRED" read-only="true"/&gt; &lt;tx:method name="find*" propagation="REQUIRED" read-only="true"/&gt; &lt;tx:method name="query*" propagation="REQUIRED" read-only="true"/&gt; &lt;/tx:attributes&gt; 你是不是有类似于这样的，如果你的service方法名称是findpassword的话那么就会被拦截到了，然后就read-only了 所以改一下你的方法名称吧
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80ca1a1876d68df644a14f8068f4a4be/" rel="bookmark">
			Windows下wamp sever&#43;sendmail使用mail()函数时的配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我在自己的Windows 7系统下安装了wampserver服务器，但是使用mail()函数发送邮件时却报错了，于是在网上看了mail()函数的手册和相关信息，发现可以使用很多方法实现php脚本发送邮件，暂时记录一个比较简单的：
1，下载sendmail.zip 地址：http://glob.com.au/sendmail/；
2，解压缩sendmail.zip到sendmail文件夹，并将该文件夹移动到c:\wamp\下；
3，打开php.ini，可先打开wamp，点击其图标php-&gt;php.ini找到该文件，打开即可，在里面搜索到
describe1:
[mail function] ; For Win32 only. ; http://php.net/smtp ;SMTP = localhost ; http://php.net/smtp-port ;smtp_port = 25 ; For Win32 only. ; http://php.net/sendmail-from ;sendmail_from = you@yourdomain ps:请注意上面这些内容全部需要用;号注释掉！
describe2:
; For Unix only. You may supply arguments as well (default: "sendmail -t -i"). ; http://php.net/sendmail-path sendmail_path ="C:\wamp\sendmail\sendmail.exe -t" ps:上面这行填写的是sendmail的路径，将其告知php解析器
describe3:
; Force the addition of the specified parameters to be passed as extra parameters ; to the sendmail binary.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80ca1a1876d68df644a14f8068f4a4be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e71dc54a25968ea762137f53892a5be4/" rel="bookmark">
			SetUnhandledExceptionFilter让程序优雅的崩溃（转）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 虽然是大公司的产品，QQ它还是会在我们的折腾下崩溃的，但是它总是崩溃的很优雅，还要弹出自己的对话框来结束。并且发送报告，去掉了系统默认的发送报告的对话框。
所以一拍脑袋，想让自己的程序崩溃的体面一点。
自己想了大概的思路，觉得可以用一个进程来监控目标程序。的确也可以拿到了目标程序崩溃的信息，知道它什么时候崩溃的，也可以做额外的操作，但是这样是没办法把默认的发送错误的对话框去掉的。
然后又有人说是不是采用了类似钩子的方法把这个东西在哪里勾掉了。
最后网上查了一番，发现SetUnhandledExceptionFilter这个函数解决了一切。
总结了下搜到的资料，这个函数的返回值有三种情况：
EXCEPTION_EXECUTE_HANDLER equ 1 表示我已经处理了异常,可以优雅地结束了 EXCEPTION_CONTINUE_SEARCH equ 0 表示我不处理,其他人来吧,于是windows调用默认的处理程序显示一个错误框,并结束 EXCEPTION_CONTINUE_EXECUTION equ -1 表示错误已经被修复,请从异常发生处继续执行 具体使用方法如下：
#include 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfb88cb4199bd0e1acddcf03824bd30f/" rel="bookmark">
			iOS线程通信和进程通信的例子（NSMachPort和NSTask，NSPipe）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原创：http://blog.csdn.net/yxh265/article/details/51483822
iOS线程间的通信 iOS中，两个线程之间要想互相通信，可以使用：NSMachPort 下面是例子
#define kMsg1 100 #define kMsg2 101 - (void)viewDidLoad { [super viewDidLoad]; //1. 创建主线程的port // 子线程通过此端口发送消息给主线程 NSPort *myPort = [NSMachPort port]; //2. 设置port的代理回调对象 myPort.delegate = self; //3. 把port加入runloop，接收port消息 [[NSRunLoop currentRunLoop] addPort:myPort forMode:NSDefaultRunLoopMode]; NSLog(@"---myport %@", myPort); //4. 启动次线程,并传入主线程的port MyWorkerClass *work = [[MyWorkerClass alloc] init]; [NSThread detachNewThreadSelector:@selector(launchThreadWithPort:) toTarget:work withObject:myPort]; } - (void)handlePortMessage:(NSMessagePort*)message{ NSLog(@"接到子线程传递的消息！%@",message); //1. 消息id NSUInteger msgId = [[message valueForKeyPath:@"msgid"] integerValue]; //2. 当前主线程的port NSPort *localPort = [message valueForKeyPath:@"localPort"]; //3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfb88cb4199bd0e1acddcf03824bd30f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52b4bd65d8e5ee1a9b00d17a77cb11ba/" rel="bookmark">
			媒体查询使用方法@media
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Media Queries能在不同的条件下使用不同的样式，使页面在不同在终端设备下达到不同的渲染效果。前面简单的介绍了Media Queries如何引用到项目中，但Media Queries有其自己的使用规则。具体来说,Media Queries的使用方法如下。
@media 媒体类型and （媒体特性）{你的样式} 注意：使用Media Queries必须要使用“@media”开头，然后指定媒体类型（也可以称为设备类型），随后是指定媒体特性（也可以称之为设备特性）。媒体特性的书写方式和样式的书写方式非常相似，主要分为两个部分，第一个部分指的是媒体特性，第二部分为媒体特性所指定的值，而且这两个部分之间使用冒号分隔。例如：
(max-width: 480px)
从前面表中可以得知，主要有十种媒体类型和13种媒体特性，将其组合就类似于不同的CSS集合。
但与CSS属性不同的是，媒体特性是通过min/max来表示大于等于或小于做为逻辑判断，
而不是使用小于（&lt;）和大于（&gt;）这样的符号来判断。接下来一起来看看Media Queries在实际项目中常用的方式。 1. 最大宽度max-width
“max-width”是媒体特性中最常用的一个特性，其意思是指媒体类型小于或等于指定的宽度时，样式生效。如：
@media screen and (max-width:480px){ .ads { display:none; } } 上面表示的是：当屏幕小于或等于480px时,页面中的广告区块（.ads）都将被隐藏。
2.最小宽度min-width “min-width”与“max-width”相反，指的是媒体类型大于或等于指定宽度时，样式生效。
@media screen and (min-width:900px){ .wrapper{width: 980px;} } 上面表示的是：当屏幕大于或等于900px时，容器“.wrapper”的宽度为980px。
3.多个媒体特性使用 Media Queries可以使用关键词"and"将多个媒体特性结合在一起。也就是说，一个Media Query中可以包含0到多个表达式，表达式又可以包含0到多个关键字，以及一种媒体类型。
当屏幕在600px~900px之间时，body的背景色渲染为“#f5f5f5”，如下所示。
@media screen and (min-width:600px) and (max-width:900px){ body {background-color:#f5f5f5;} } 4.设备屏幕的输出宽度Device Width 在智能设备上，例如iPhone、iPad等，还可以根据屏幕设备的尺寸来设置相应的样式（或者调用相应的样式文件）。同样的，对于屏幕设备同样可以使用“min/max”对应参数，如“min-device-width”或者“max-device-width”。
&lt;link rel="stylesheet" media="screen and (max-device-width:480px)" href="iphone.css" /&gt; 上面的代码指的是“iphone.css”样式适用于最大设备宽度为480px，比如说iPhone上的显示，这里的“max-device-width”所指的是设备的实际分辨率，也就是指可视面积分辨率。
5. not关键词 使用关键词“not”是用来排除某种制定的媒体类型，也就是用来排除符合表达式的设备。换句话说，not关键词表示对后面的表达式执行取反操作，如：
@media not print and (max-width: 1200px){样式代码} 上面代码表示的是：样式代码将被使用在除打印设备和设备宽度小于1200px下所有设备中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52b4bd65d8e5ee1a9b00d17a77cb11ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6449ae5066d5bbdc61e4b7d1a47144e/" rel="bookmark">
			如何将div悬浮在另外一个div之上？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决方案1 如何“悬浮”是想让一个层叠加在另一个层上的话，你可以利用相对定位和绝对定位来实现 比如: 你在父元素上设置position:relative; 在子元素上设置position:absolute;top:10px;left:10px; 这样如果父元素里面有其他元素的话 上面定义的这个子元素就可以”悬浮”在他上面了
解决方案2 .如果你说的悬浮是一个元素固定在窗口的某个位置 拉滚动条他也不动 那么你可以使用固定定位 比如:你在需要悬浮的元素上设置position:fixed; top:10px;left:10px; 参考 http://wenwen.soso.com/z/q71516616.htm
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2c4afd6caab962dad93ddfe5ba5dc4c/" rel="bookmark">
			redis学习之Jedis使用线程池封装redis的基本操作及spring的简单封装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天是521，作为单身狗屌丝一枚，还是像往常一样没任何感觉，好悲哀。不多说，进入今天的redis学习之Jedis使用线程池封装redis的基本操作及spring的简单封装。例子都是整理好的，供工作学习只需
一、Jedis使用线程池封装redis的基本操作
redis客户端jedis常用的操作：key value,hash,list,set,zset的基本操作；
package util;
import java.util.List;
import java.util.Map;
import java.util.Set;
import redis.clients.jedis.Jedis;
import redis.clients.jedis.JedisPool;
import redis.clients.jedis.JedisPoolConfig;
import redis.clients.jedis.BinaryClient.LIST_POSITION;
/**
* &lt;p&gt;redis通用工具类&lt;/p&gt;
*
*/
publicclass RedisUtil {
private JedisPoolpool =null;
/**
* &lt;p&gt;传入ip和端口号构建redis连接池&lt;/p&gt;
* @param ipip
* @param prot端口
*/
public RedisUtil(String ip,int prot) {
if (pool ==null) {
JedisPoolConfig config = new JedisPoolConfig();
//控制一个pool可分配多少个jedis实例，通过pool.getResource()来获取；
//如果赋值为-1，则表示不限制；如果pool已经分配了maxActive个jedis实例，则此时pool的状态为exhausted(耗尽)。
config.setMaxActive(500);
//控制一个pool最多有多少个状态为idle(空闲的)的jedis实例。
config.setMaxIdle(5);
//表示当borrow(引入)一个jedis实例时，最大的等待时间，如果超过等待时间，则直接抛出JedisConnectionException；
config.setMaxWait(1000 * 100);
//在borrow一个jedis实例时，是否提前进行validate操作；如果为true，则得到的jedis实例均是可用的；
config.setTestOnBorrow(true);
// pool =new JedisPool(config, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2c4afd6caab962dad93ddfe5ba5dc4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c1bf6bc130916a7bc0bda1f5ba551a6/" rel="bookmark">
			关于word中插入知网e-study插件问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写论文过程中难免会出现word中e-study莫名其妙的被禁止，估计是被杀毒软件或启动项什么的优化禁止了。
打开word--&gt;word选项---&gt;加载项-------&gt;管理-----&gt;禁用项目-----&gt;把e-study相关插件删除 在COM-加载项中将 e-study加载项对勾打上 问题基本会解决！
-----------xc2444
转载于:https://www.cnblogs.com/xc2444/p/5515248.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/058da658886069abd1204cd3865eefba/" rel="bookmark">
			Matlab中给ｆｉｇｕｒｅ添加图例（legend），标题（ｔｉｔｌｅ）和颜色（ｃｏｌｏｒ）...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在Matlab绘图过程中，尤其是需要将多个图绘制在相同的坐标轴中时，通常需要将不同的曲线设置成为不同的颜色。此外，为了直观，还需要给这张图标增添标题和图例。这篇文章展示了在Ｍａｔｌａｂ的绘图窗口（ｆｉｇｕｒｅ）中设置曲线颜色、添加图例（legend）和标题（title）的方法。
在Matlab中，给曲线设定颜色可以采用plot函数实现。如下所示的语句中： plot(x, y, 'r'); 是以 x 变量为横坐标，y 变量为纵坐标绘制红色曲线。其中，颜色控制由 ‘r’实现。在Matlab中，预先留了7种颜色，分别为‘r’‘g’‘b’‘c’‘m’‘y’‘k’。如果需要更多的颜色调整，可以采用‘color’关键词实现，具体语法如下： plot(x, y, 'color', [0.1 0.2 0.3]); 其中，出现在‘color’关键词之后的矩阵，控制绘制出来的图像的颜色。 当绘制出一个曲线之后，可以采用 title 函数为绘图增加标题。具体的代码格式如下所示： figure; plot(x, y, 'r') title('这是你绘制的曲线'); 此外，绘制多条曲线时，为了对曲线进行区分，还需要增添图例，可以采用legend函数实现。具体代码格式如下： figure; plot(x, y, 'r') legend('这是你需要的图例'); 最后，下面一段代码是将上面所有功能集合的演示，如下图所示： figure; plot([1:10],[5:14]); title('这是标题'); hold on plot([1:10],[1:2:20],'color',[0.1 0.7 0.3]); hold off legend('line 1','line 2'); 运行结果如下： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74f1ce4d2fee91284f65f8633a451586/" rel="bookmark">
			destoon网站根目录license.txt不允许修改或删除，请检查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在admin/login.inc.php中，注释掉下面几行字即可。另外建议删除license.txt，以免被人知道用的什么系统，容易受到黑客攻击。
//$DT_LICENSE = md5(file_get(DT_ROOT.'/license.txt'));
//#exit($DT_LICENSE); //if($DT_LICENSE != 'ede11fdcdb179260657dba4f3fc42b0e' &amp;&amp; $DT_LICENSE != '624100e3dd1887d79ef4c713f0f30cb2') msg('网站根目录license.txt不允许修改或删除，请检查'); 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/303/">«</a>
	<span class="pagination__item pagination__item--current">304/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/305/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>