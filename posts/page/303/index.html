<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df524a65ba20e6045f401b76dd5b32c4/" rel="bookmark">
			C&#43;&#43;知识体系结构框图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cec3aa045b8454f2d409da22b632ca55/" rel="bookmark">
			python的类，元类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		类实例化过程： 例子： class Custom: def __init__(self): print("Init method") def __new__(cls,*args,**kwargs): print("new Instance") return object.__new__(cls,*args,**kwargs) if __name__ == '__main__': Custom() 运行结果： new Instance Init method 类也是一个对象，但是具有创建其自身实例的能力。 类可以和一个变量进行绑定 可以为类增加属性 可以将类作为函数的参数传递 ============================================== 元类（type) 类的创建和管理者 所有的类都是元类（type)的实例 元类实例化的过程： __new__() __init__() 目的：对其创建的类进行预处理 Python3.x中对元类的应用 类继承中提供关键字参数：metaclass=元类名 Python3.x中对元类的应用 定义一个模块级变量： __metaclass__=元类名 为某个类添加类属性： __metaclass__=元类名 自定义元类（Python3中） 例子： class MyMeta(type): def __init__(self,name,bases,dicts): print("init method") def __new__(cls,name,bases,dicts): #给元类添加一个方法 dicts['info'] = lambda self:print('Djx') #创建实例对象 res = type.__new__(cls,name,bases,dicts) #给元类添加一个属性 res.company = 'Maizi' return res #Python3.x中对元类的应用 class custom(metaclass=MyMeta): pass #Python2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cec3aa045b8454f2d409da22b632ca55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28327f32ab3d1e2b6487cde90f615b62/" rel="bookmark">
			c语言和java中的基本数据类型都一样吗，都有哪些，长度是多少
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 基本数据类型应该是一样的，不同的是在java中byte(占1个I字节) ，char (2个字节)，short(2.),int (4),long (8),fload(4),double(8),这个不管在window,linux等操作系统中都不会改变，而在C中，这些基本数据的大小是会更具不同操作系统发生变化的 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dafd9b277242488f39f33540c725115/" rel="bookmark">
			Windows下bat脚本获取时间对比Linux下shell脚本获取时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近几天做了一项window下的打包工作，因为每天都要制作安装包，所以要设置一下时间戳，为此研究了一下Windows下bat脚本获取时间和Linux下shell脚本获取时间。
1、Windows下bat脚本获取时间 （1）windows下DOS窗口date的结果 2016/09/03 周六，我们需要将其进行格式化显示，如：YYYY-MM-DD 就要进行如下操作：
日期截取遵从格式 %date:~x,y%，表示从第x位开始，截取y个长度(x,y的起始值为0)
年份从第0位开始截取4位，月份从第5位开始截取2位，日期从第8位开始截取2位
（2）windows下DOS窗口time的结果 12:05:49.02 我们需要将其进行格式化显示，如：HH:MM:SS就要进行如下操作：
时间截取遵从格式 %time:~x,y%，表示从第x位开始，截取y个长度(x,y的起始值为0)
时钟从第0位开始截取2位，分钟从第3位开始截取2位，秒钟从第6位开始截取2位
详见脚本DateTime.bat
:: 脚本创建时最好选择GB2312编码(方式很简单，新建txt文件，输入几个中文字符保存后将后缀.txt改成.bat) :: @echo off 表示不回显执行的命令 @echo off @echo =========Windows的原本日期时间格式======================= :: 设置变量，使用变量时需要用一对%包起来 set ORIGINAL_DATE=%date% echo %ORIGINAL_DATE% @echo =========日期按照YYYY-MM-DD格式显示====================== :: 日期截取遵从格式 %date:~x,y%，表示从第x位开始，截取y个长度(x,y的起始值为0) :: windows下DOS窗口date的结果 2016/09/03 周六 :: 年份从第0位开始截取4位，月份从第5位开始截取2位，日期从第8位开始截取2位 set CURRENT_DATE=%date:~0,4%-%date:~5,2%-%date:~8,2% echo %CURRENT_DATE% @echo =========时间按照HH:MM:SS格式显示======================== :: 时间截取遵从格式 %time:~x,y%，表示从第x位开始，截取y个长度(x,y的起始值为0) :: windows下DOS窗口time的结果 12:05:49.02 :: 时钟从第0位开始截取2位，分钟从第3位开始截取2位，秒钟从第6位开始截取2位 set CURRENT_TIME=%time:~0,2%:%time:~3,2%:%time:~6,2% echo %CURRENT_TIME% @echo =========日期时间按照YYYY-MM-DD HH:MM:SS格式显示========= set CURRENT_DATE_TIME=%date:~0,4%-%date:~5,2%-%date:~8,2%-%time:~0,2%:%time:~3,2%:%time:~6,2% echo %CURRENT_DATE_TIME% @echo =========日期时间按照YYYYMMDD_HHMMSS格式显示============= set CURRENT_DATE_TIME_STAMP=%date:~0,4%%date:~5,2%%date:~8,2%_%time:~0,2%%time:~3,2%%time:~6,2% echo %CURRENT_DATE_TIME_STAMP% @echo ========================================================= 运行结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5dafd9b277242488f39f33540c725115/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b46f6debba34412c0edcb20d6acb6568/" rel="bookmark">
			笔试选择题17
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、int add(int a,int b)的重载可以是int add(double a,double b)， int add(int a,int b,int c)，int add(int a ,double b)等 override是重写（覆盖）了一个方法，以实现不同的功能。一般是用于子类在继承父类时，重写（重新实现）父类中的方法。 重写（覆盖）的规则： 1、重写方法的参数列表必须完全与被重写的方法的相同,否则不能称其为重写而是重载. 2、重写方法的访问修饰符一定要大于被重写方法的访问修饰符（public&gt;protected&gt;default&gt;private）。 3、重写的方法的返回值必须和被重写的方法的返回一致； 4、重写的方法所抛出的异常必须和被重写方法的所抛出的异常一致，或者是其子类； 5、被重写的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行重写。 6、静态方法不能被重写为非静态的方法（会编译出错）。 overload是重载，一般是用于在一个类内实现若干重载的方法，这些方法的名称相同而参数形式不同。 重载的规则： 1、在使用重载时只能通过相同的方法名、不同的参数形式实现。不同的参数类型可以是不同的参数类型，不同的参数个数，不同的参数顺序（参数类型必须不一样）； 2、不能通过访问权限、返回类型、抛出的异常进行重载； 3、方法的异常类型和数目不会对重载造成影响； 二、 用命令（）可以查看mysql数据库中user表的表结构？ 查看Mysql表结构的命令，如下: desc 表名;
show columns from 表名;
describe 表名;
show create table 表名;
use information_schema
select * from columns where table_name='表名';
三、常见不能声明为虚函数的 1.普通函数（不能被覆盖） 2.友元函数（C++不支持友元函数继承） 3.内联函数（编译期间展开，虚函数是在运行期间绑定） 4.构造函数（没有对象不能使用构造函数，先有构造函数后有虚函数，虚函数是对对象的动作） 5.静态成员函数（只有一份大家共享） 四、为了提高数据库的性能，需要针对系统设计基准测试进行压力测试，那么进行压力测试时需要考虑以下哪些指标（） 响应时间，并发性，吞吐量等 五、 管道实际上是一种固定大小的缓冲区，管道对于管道两端的进程而言，就是一个文 件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在于内存中。它类似于通信中半双工信道的进程通信机制，一个管道可以实现双向 的数据传输，而同一个时刻只能最多有一个方向的传输，不能两个方向同时进行。管道的容 量大小通常为内存上的一页，它的大小并不是受磁盘容量大小的限制。当管道满时，进程在 写管道会被阻塞，而当管道空时，进程读管道会被阻塞， 六、 一个直线将一个平面分成 2 部分，两条直线分成 4 部分，如果直线不平行，多条直线不共一点，问 100 条直线将平面分成几部分？ 运用数学穷举法，探索规律。比如： 1条直线 2个平面 2条直线 4个平面 3条直线 7个平面 4条直线 11个平面 。。。。。。。。。 n条直线 ：f(n)=f(n-1)+n 七、 如何减少换页错误？ 访问局部性（locality of reference）满足进程要求 局部性原理是一个经典的原理，分为时间局部性和空间局部性，意思是应用一旦访问了一个空间的数据，则这个空间中的相邻区域的内容也很可能被访问，一旦访问了某一段代码，则其周围的代码也很可能被访问。局部性原理的运用就是根据这个，把可能访问的数据和代码都加在到内存中，以后访问就不用加载了（因为主要的消耗在IO端）。这也是迪杰斯特拉提出的goto语句有害的依据，应为goto语句能打破局部性原理，造成计算机的延迟加剧。 换页错误又称缺页错误，当一个程序试图访问没有映射到物理内存的地方时，就会出现缺页错误， 这时操作系统就要去虚拟内存中加载这块内存页。 百度了一下，减少换页错误的方法，即降低缺页中断率： 1、内存页框数。增加作业分得的内存块数。 2、页面大小。页面划分越大，中断率越低。 3、替换算法的优劣影响缺页中断次数 4、程序局部性。程序局部性好可减少缺页中断（为什么？）。 那么B是对的，而对于D，最短剩余时间调度是CPU调度就绪进程的方式，与页面置换算法无关，不要搞混淆了。 八、排序算法的常规实现中，哪些空间复杂度是O(1)。（1）直接插入（2）直接选择（3）shell排序（4）堆排序（5）冒泡排序 九、设内存的分配情况如表所示。若要申请一块40KB字节的内存空间，采用最佳适应算法，则所得到的分区首址为（ ）。 分区表 分区首址/KB 状态 000K 占用 100K 180K 占用 190K 280K 占用 330k 390k 占用 410k 最佳适应算法：空闲分区按容量递增形成分区链，找到第一个能满足要求的空闲分区。 所以 空闲容量 首地址 60KB 330KB 80KB 100KB 90KB 190KB 而容量需要是40KB, 因此选择首地址是330 十、 在多级队列调度和多级反馈队列的调度的叙述中，正确的是（）。 多级反馈队列的调度中就绪队列的设置不是像多级队列调度一样按作业性质划分，而是按时间片的大小划分 多级队列：该算法将系统中的进程就绪队列从一个拆分为若干个，将不同类型或性质的进程固定分配在不同的就绪队列，不同的就绪队列采用不同的调度算法，一个就绪队列中的进程可以设置不同的优先级，不同的就绪队列本身也可以设置不同的优先级。 多级队列调度算法由于设置多个就绪队列，因此对每个就绪队列就可以实施不同的调度算法，因此，系统针对不同用户进程的需求，很容易提供多种调度策略。 多级反馈队列：1）设置多个就绪队列。在系统中设置多个就绪队列，并未每个队列赋予不同的优先级。第一个队列的优先级最高，第二个次之，其余的优先级逐个降低。该算法为不同的队列中的进程所赋予的执行时间片的大小也各不相同，在优先级愈高的队列中，其时间片就愈小。 2）每个队列都采用FCFS算法。3）按队列优先级调度。 十一、以下关于linux操作系统中硬链接和软链接的描述,正确的是?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b46f6debba34412c0edcb20d6acb6568/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d257c9f4909fb9fca5deb1372e2cb6fd/" rel="bookmark">
			oracle snapshot too old异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		继oracle外键不加索引会死锁之后，又看到oracle一个有名的异常，snapshot too old，情景是这样的
假设有一个表，有一亿行数据，现在第一个任务在执行select *操作，第二个任务修改了第5000万行的数据，并进行了commit，那么等到第一个任务执行到第5000万行数据时，就会报snapshot too old异常，为什么会这样呢？
其实一般情况下，数据库都会有一个类似于innodb的非一致性读功能：在某一时刻开始一个查询操作，那么查到的数据就一定是此刻所有数据的状态，即使有些数据被进行了修改，这个功能是通过undo log保证的。如上边的例子，当第二个任务将第5000万行数据进行修改之后，这个操作会被存储到undo log里面去，用来处理后续的读操作或者回滚操作。但很遗憾的是，oracle的undo log容量有限，如果上边第一个查询任务执行时间过长，而且第二个任务已经commit，那么第二个任务的undo log记录很可能被后边事务的undo log覆盖掉，那么当第一个任务执行到第5000万行查询时，就找不到了本该有的undo 记录，所以snapshot too old就准时出现了。
但是innodb却是可以避免这个问题的，原因在于innodb不会对undo log大小进行限制，只会在后台通过master thread定时清理undo log，而且清理的时候，也会判断当前要清理的undo log会不会被用到，所以就基本避免了这个问题。
那么如何防范这个问题呢：
1.不要对undo log设置太小，或者定期增大undo log容量
2.优化sql，不要进行过长时间的查询，那样的话，undo log就会消耗不小的资源。
感觉oracle确实厉害，但mysql却后来居上，做的很精致，弥补了好多oracle的不足之处，还好用的mysql，没有这些莫名其妙的问题！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ad1f1dcd15fce5340f94e18929aaa38/" rel="bookmark">
			luvcview分析--3.用SDL显示camera的图像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 用SDL显示camera图像 1. SDL 虽然把图像写到文件中去己经很好很强大了,但进一步实时的显示图片是不是更好？ 这就需要用到SDL了 2. 源码 2.1 display.c cong@msi:/work/test/uvcview/3display$ cat display.c #include "utils.h" #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; #include &lt;linux/videodev2.h&gt; #include &lt;sys/mman.h&gt; #include &lt;SDL/SDL.h&gt; #define VIDEO_DEVICE "/dev/video0" #define NB_BUFFER 4 int fd; int ret = 0; struct v4l2_capability cap; struct v4l2_format fmt; struct v4l2_requestbuffers rb; struct v4l2_buffer vbuf; void* vmem[NB_BUFFER]; unsigned char* tempbuffer; unsigned char* framebuffer; int type; int framesize; int width = 640; //1280; //640; int height= 480; // 720; // 480; float fps = 30.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ad1f1dcd15fce5340f94e18929aaa38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e155bc29830ba878b14c87185075c1cb/" rel="bookmark">
			luvcview分析--1.环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 源码编译及目标 1.luvcview源码下载 cong@msi:/tmp$ sudo apt-cache showsrc luvcview //a.查看有没有这个源码包 cong@msi:/tmp$ sudo apt-get source luvcview //b. 这就在当前目录下 cong@msi:/tmp$ ls luvcview_0.2.6-6.dsc luvcview-0.2.6 luvcview_0.2.6.orig.tar.gz luvcview_0.2.6-6.debian.tar.gz 2. luvcview编译 cong@msi:/work/test/busytest/luvcview-0.2.6$ make //直接make就可以了 Package libv4l2 was not found in the pkg-config search path. //提示libv4l2包没有找到 Perhaps you should add the directory containing `libv4l2.pc' No package 'libv4l2' found v4l2uvc.c:28:21: fatal error: libv4l2.h: No such file or directory //缺少libv4l2头文件 #include &lt;libv4l2.h&gt; cong@msi:/work/test/busytest/luvcview-0.2.6$ sudo apt-cache search libv4l2 //查找libv4l2包 libv4l-dev - Collection of video4linux support libraries (development files) cong@msi:/work/test/busytest/luvcview-0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e155bc29830ba878b14c87185075c1cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96a45db906b0154fe5f7e89fc6e2127a/" rel="bookmark">
			八点办资讯|和上司相处，这几个细节你不知道就“狗带”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		身在职场的人最少不了的就是跟上司打交道，有的人云里雾里，相处不愉快，徒增无限烦恼，有的人深谙此道，相处融洽，混的风生水起，那么跟上司相处的细节你要注意哪些呢？
l 切莫嚼舌头，薄纸难包火
别奢望你私下说的话老板就听不到。老板能知道一切，这是真理。场就是这么神奇的地方，只要你不是一个人自言自语，你的谈话对象就有一定几率把你的话传出去。最残酷的是，每一句议论公司的话好像百分九十九都能传到老板耳朵里。所以，不该说的和可以不说的都可以烂在心里。
l 伴君如伴虎，交心须谨慎　曾经有个哥们，平日里就跟我们讲，在公司如何如何跟经理交好，而在公司业务出问题的时候，他却成了经理的替罪羊，被无情的踢出了公司。就像这样的事很多，记住，促膝长谈是种手段，交心也是交际的一种，这样的手段必须点到即止。什么都说的人绝对是职场头号笨蛋。偶尔的交心，说些无关紧要的私己话，让老板觉得你是自己人就够了。在职场人赤裸相见，热泪盈眶的人，永远是最早被出卖的那个。
l 背靠大树好乘凉，自己枝繁叶茂是王道
在职场中，怎么样才能保证存活和上升呢？和上司们搞好关系是一门必须的功课，你能力强你脑子好，上司不跟你施展的机会一样无用。金子的确早晚都会发光，但上司会决定这个被发现日期的长短。而比此更重要的，是让自己有足够的价值，不管是业务上还是为人上，都要保持一定的水准，让自己成为关键人物很重要，这个每一个上司都会看好你。
l 切勿被画出的大饼砸昏头
初入职场的人，常常中的陷阱就是HR给画的大饼，而久经战场的老鸟们面对的就是上司给画的病。当一个上司对你说，你是他的人时，心里一定要清楚，上司并不是你的人。你们俩永远不是一条船上的人啊。两人利益方向相同时，可能给你的错觉就是上司对你千好百好，然而，你是他的，他是他自己的。当你的事情与上司的利益有冲突时，他们会毫不犹豫的出卖你。记住，只有自己对自己才能负责。对上司的蛋糕保持敬畏之心，切勿中了陷阱啊。
l “口是心非”与“心领神会”
说起“揣摩圣意”，乾隆年间的和珅是把好手。在职场上，上司没有皇帝那么难伺候，你也没有必要像和珅一样工于心计，但是上司爱“口是心非”却是常见的，比如如果上司真的对你放心，他根本不用经常提及。真正的信任，是有重要利益相关的事让你一起做来体现的。而上司口头说对你放心，则反而要当心了，很可能你做了什么，让上司产生你不忠的怀疑。所以有的话听起来好听，但可能是上司在敲打你。
l 立场切换与利益相关　做事就怕没有分寸，跟上司相处就怕心里没有自己的账本。当一件事在传到你这的时候，你要站在上司立场上去考虑问题，去分析上司的利害关系，然后再转回自己的角度决定要不要做。再忠心的人也不是什么事情都会做的，总有一些你要去推脱，去搪塞。用自己能做的事让老板满意，觉得不想做的事，你也要让上司知道你已经尝试过了。
l 留着缺点给人看
俗话说的好，不遭人嫉是庸才，在职场上打拼，你的闪光点是一定会遭人嫉妒的，这不可避免。同样，在职场，一定要有缺点，一个完美而毫无缺点的人，会遭人嫉恨，会让人敬而远之。如果连上司都对你敬而远之，那职场之路就危险了。试着暴露些无关痛痒的缺点，让你能融入一个好的氛围这绝对是超值的。
l 越俎代庖要不得
上司是企业的管理层，他们喜欢的就是掌控权，但公司的发声人却不应该只是管理层，普通员工也应该是谏言者，但有的人提着提着建议就走到上司的位置上拍板决定了，举个我们公司的例子，总理刚提出互联网+时代，他就去拿着几套方案去给老板建议公司无纸化移动办公，上司研究了许久，敲定了用永久免费的第二代移动办公八点办，不仅夸他爱动脑，还奖了他奖金呢。送建议做方案的人上司绝对欢迎，但替老板决定的人久而久之就被边缘化了。
其实事情说这么多，诸位白，做起来比说难的太多，尽管都倡的是要把本职工作、业务做好，但在职场的人稍微用心跟上司相处的好一些，活的也舒服些嘛。
下载地址：
http://app.8office.cn/download/gd?invitecode=iulum&amp;version=540
转载于:https://my.oschina.net/duqiu/blog/740947
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6392261f9dda7839cf28a923a2b4e1d4/" rel="bookmark">
			初入职场应该注意那些细节~八点办
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天和同事们一起探讨分享，初入职场刚注意那些？
有的回答，我很关注工资，不加班，朝九晚五。也有部分同事回答，我关心我能学到什么，是否能提升？我只是来这学习镀金的。初入职场有这些想法是很正常的事情。
自己的未来是怎么规划，怎么去发展？要得到快速提升，必须踏踏实实的认真做好几件事，你离成功就不远了。
第一：能力的提升比高工资更重要，虽然此刻的你特别缺钱，刚进入职场谁不缺钱啊，官二代、富二代另当别论。先别去要求我是名校毕业，必须是高岗位高薪。踏实从小做起，盖高楼前打好基础。学校里面的理论再加上实践，才是真才实学。
第二：老板不是资本家，他（她）也没有剥削你。
第三：注意仪容仪表，也许你是工程师、或者研发人员，但也不能穿得太邋遢，衣服整洁，每天洗头，刮胡子。也注意适当收拾办公桌。
第四：和同事及身边的人搞好关系。他们也许以后是你的上司或者下属更或者是以后的合作伙伴。一定要给对方留个好印象。
第五：做好每件小事，处理好每件小事的细节，做不好的地方自己要有总结，找到原因以便改进。相信我，这时候你真不是做大事的料。这些看不上的小事其实非常的难做，做好现在的小事，成就以后的大事。
第六：在客户那里，你代表的就是你所在公司形象。别跟客户抱怨公司的产品不够好不给力或者是公司各方面都不好，这样是非常对自己不利的做法。你抱怨公司的同时也是在抱怨自己，那么垃圾的公司你还留下，证明你也好不到那去。
第七： 提高沟通能力，锻炼自己高强度的适应能力。适应跟不同风格的人合作。
第八：养成一个好习惯，比如每天做工作记录，每天回顾自己，那里做的不做及时发现及时改正。跳槽后你会发现比很多人都牛。一个好习惯能秒掉一大部分人，如果能多培养几个好习惯，你已经非常优秀了。
第九：借助提升效率的办公工具，八点办移动办公APP就非常不错，趣味社交，高效办公，还是永久免费的，“连接.沟通.执行”在手机上快速解决，提高执行力，也是快速提升自我的一款辅助利器。 八点办是一款很好的移动办公软件，它既要满足管理者的控制欲，又要给予团队成员足够的归属感和责任感，同时还要让公司低成本运作，八点办引领一种新的工作方式。 第十：业余时间锻炼身体。从校门出来的时候身体基础还不错，别过了几年身体就垮了。身体要是不舒服做什么都是白搭。
做到以上10条，你想不成功就很难。 刚步入职场的好好注意小细节，细节决定成败，这句话经过我这么多年的职场经验，是正确的。回想起来，我当初只做到一小部分，好可惜，要不我现在的成就就会更好的。
八点办办公APP下载地址：
http://app.8office.cn/download/gd?invitecode=iulum&amp;version=540
转载于:https://my.oschina.net/duqiu/blog/740186
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9162f79cfd93f4444e157447155a732/" rel="bookmark">
			APPScan配置URL连接后无法正常访问地址原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本地能够正常访问需要测试的URL地址，但是在appscan中设置需要访问的URL后，无法访问，如下
原因：appscan默认应该是调的IE进行浏览访问，查看本地IE代理设置了代理，取消代理设置，appscan访问成功，如图取消设置代理：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9b10decf9861ffede9251ac11401fb4/" rel="bookmark">
			八点办~你最理想工作是这样的吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你最理想的工作是什么样的，今天我们一起探讨下吧。我曾经很个别朋友讨论过这个问题，得到的回复让人哭笑不得。 理想的工作是：每周上2休5，工作日8小时，高薪。不要遇到暴躁的老板和上司，工作时要开心。我忍不住呐喊了，这哪家公司，我就是脱光衣服被领导潜规则我也要进这公司。 理想的工作是：不用工作，吃和睡。牛顿说，那是猪的理想。 不管自己有什么理想，最终逃脱不了要工作的局面，既然逃不了，那就好好的面对，摆正心态，咱没钱，就认命吧。 一个人类的理想应该是劳动,是工作，而且应该是享受工作，让八点办给你这份享受。只需轻轻一点定位打卡,工作汇报,请假审核``````你能用的到的工作的一切,你在这里都能找到, 人生应该有追求,然后,留一点时间给生活。 如果老板是暴戾苛刻的,你会努力的小心翼翼,如果员工是消沉慵懒的,你可能会满腔怒火,如果工作杂乱无章,你可能会焦头烂额,如果任务无从下手,你可能会慌乱无措…如果如果按照传统的方式,工作总给你暴击,你会不会去摸索另外一种方法去尝试?八点办,给你多一种从容的选择。 其实我不仅想承包你的工作，还有一点野心，那就是给你一点乐趣。APP积分商城同步上线，生成我们特意为你准备的专属二维码，随时随地随人邀请就能得积分。积分在我这等同于人民币，准备的东西就像我的诚意一样，很大很满。总而言之，你敢邀请我就敢兑。老板吐着血说，邀请积分无限制。如果说方便工作是我的目的，给你欢乐那就是我的初衷。 从来不说自己做的是变革，会影响世界，但我会努力改变所有遇到我的人。其实怕什么真理无穷，进一寸有一寸的欢喜，向前我从不止步。能工作、能赚钱、有追求、有乐趣，我是一个不太一样的APP，不信你就用用看，三十分钟后你会爱上我。 点击下方链接了解产品详情：
http://app.8office.cn/download/gd?invitecode=iulum&amp;version=540
转载于:https://my.oschina.net/duqiu/blog/739666
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2caac8c9c26eddd9a15ef616032ab9ce/" rel="bookmark">
			大数据概述及其生态圈（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大数据是什么 经常听别人说“我要去学习大数据”，乍一听大数据应该是某个技术。
百度解释：无法在规定时间内用给现有的常规软件工具对其内容进行抓取、管理和处理的数据集合。通俗讲，大数据就是大到难以处理的数据集合，是社会技术发展过程中碰到的棘手问题。
于是，我们为了解决这个问题，衍生出各种技术，而这些技术才是我们学习的内容。所以说，“我要去学习大数据”完整的说法应该是“我要去学习处理大数据问题的技术”。
大数据技术生态圈 先放图：
注：图中左侧是技术大分类，右侧是技术细分，括号中是列举的具体技术关键字
大数据技术分类大数据技术与工具基础架构支持云计算平台（Apache Hadoop、OpenStark）储存虚拟化、分布式存储虚拟化（VM、Docker）网络（OpenFlow）数据采集数据总线ETL工具（flume、kafka、sqoop）数据存储分布式文件系统（HDFS、GFS）关系型数据库（Oracle、MySQL）Nosql数据库（HBase、Redis）关系型数据库和非关系新数据库的融合（Newsql）内存数据库（MemCache）数据计算数据查询、统计与分析（MapReduce、Pig、hive）数据预测与挖掘（Spark、Mahout）图谱处理BI商业智能展示和交互图形与报表（Hue）可视化工具（D3、Echart、MapV、谷歌地图）增强现实技术（Google眼镜） 大数据技术分类详解 遮住右边的技术细分，我们看左边的五个大分类。我用一个通俗的案例帮助大家理解和记忆。
假设，现在我们要搞大数据了，买来了200台计算机，并整齐地放在了某个房间里。那么问题来了，怎么有效的组织这些计算机，让它们协同工作呢？“技术架构支持”这类技术就是为了解决这个问题。
好了，现在我们已经将200台计算机有效组织，并能配合工作。开始搞大数据，哎？一拍脑瓜，数据哪来？“数据采集”呼之欲出，它帮你解决数据哪来的问题。
现在，我们已经找到了数据源，并且有了采集的技术，但是呢，我们放哪啊？“数据存储”技术为你服务。
一步步攻克难题，我们现在已经可以从我的网站或者各类系统将数据持续不断地存储到一个数据仓库。那么我们如何使用这些宝贵的数据，挖掘出它们无尽的价值呢？“数据计算”登场了。
万事俱备，就差最后一步了。现在我们已经从大量数据中挖掘提取出了有价值信息。我们需要展示出来啊！对，“展示和交互”氤氲而出。
到此，我们的大数据实践之旅完美结束。
技术细分和相关具体技术的讲解，由于时间原因，将留到下一节中。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6af29f0abb7d94d87ee810d87117504f/" rel="bookmark">
			为什么java接口中可以有default或者static修饰的方法？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：http://zhidao.baidu.com/link?url=Ai_0Rsueo5r2gqN5w3Q5UvAwWGHRuxqD5CYmRse1Xa10_-e01RneZO_7GnGGk7AqCNX96vedQ21j8jk2tLhbefQ2iZe4jLrpFjs6Z9GD06W
为什么java接口中可以有default或者static修饰的方法？
首先，java的成员变量（属性）都有public、static、final关键字修饰，成员方法都有public修饰（可以不用显示指明该关键字）。
java接口中的default方法是在java 8之后引入的，即在不破坏java现有实现架构的情况下能往接口里增加新方法。 Java接口现在可以有非抽象方法了。Default 方法带来的好处是，往接口新增一个Default 方法，而不破坏现有的实现架构。尽管如此，Default 方法不适合过多使用，但是对于Java集合API的优化升级，并达到无缝地结合Lambda表达式来说，Default 方法是至关重要的特性。 这个是1.8的新特性，使用 default关键字给接口添加一个非抽象的方法实现，这个特征又叫做扩展方法，子类可以直接调用！ 接口中用static修饰的方法也可以有方法体，和类的静态方法一样，可以通过 接口名.方法名 进行接口中 static方法的调用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c17352eec48ab128ca2cef310cc116a/" rel="bookmark">
			选择工作时，该去大公司还是小公司？~八点办
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在一个交流群里面，看见很多人都在抱怨自己工作的公司这不好，那不好，想去各种大公司。
到底是该去大公司工作还是去小公司？
估计超过90%的人都会说，脑子没被门挤过，都会选择去大公司。只有能力不足，学历低的才去小公司。
选择大公司的确有很多好处，有很完善的工作流程，成熟的各种体系，专人专事，不会让你身兼多职，女人不会当男人用，男人不会当畜生用。大公司工资稳定，还有不错的福利。大公司还有很好的光环，到亲戚朋友同学圈都有面子，我现在在某某大公司名企工作，大家都是膜拜的眼神啊，都夸你好有本事，混的不错。
很多人都说，我们都是出来工作的，不就是为了这些么？大公司完善的工作流程，意外着你的工作已经被模式化，很少有创新。成熟的开发体系，培训体系，销售体系，管理体系等，未必能释方你的全部生产力，新的技术或者创意未必能给你机会发挥。专业的人做专业的事，看起来是好事，但是同时也意外着你的职业有风险，专业分的越细，意味着你更依赖于整个体系，但是脱离这个环境你可能就是一无是处。至于工资和待遇，你的工资可能永远买不起房，依靠父母付首付按揭房，然后你这一辈子工资就交给银行。
在大企业做事情，视乎都是大项目，大单子。所以芝麻大的事情也会整成西瓜大的事，召集一群人反复开会、讨论、分析、论证、预测等，这对技术或者是市场真的是一种无情的摧残。
小公司，当然有很多小公司的老板是走捷径或者依赖于某种潜规则赚钱的，这样的公司赶紧离开。时间久了对自己没好处。如果你所在的公司很小，但是有活力，有潜力。虽然短期内不会让你赚很多钱，但能让你受到很大的锻炼，对于未来的潜在收益更大。小公司总有一天会淘汰现在的大公司，自己也会变成大公司。要不然我们现在看到的全是恐龙级别的企业了。这个和人一样，都有新陈代谢，这个是社会发展的必然规律。
如果你对小公司，尤其是初创公司有过失望或者抱怨的话，你就能保证你到大公司一切都好起来的吗？在小公司想象大公司的一切都很美好。你要自己尝试做一些改变了，你要想自己提升，不能全寄托于周围的环境。你到大公司真的就可以得到锻炼，你的短板就会得到弥补？技能提升快速？视野得到了拓宽？
大公司很少的情况下会变小公司，但小公司随时都有机会变成大公司。去大公司还是小公司这个在于自己的决策，别人也不能干预什么，自己的路自己去走。
不管大小公司，要自己很突出，不是靠原始方式去做的，要借助现代化管理工具，八点办移动办公APP就很好，趣味社交，高效办公，还永久免费。
一款很好的移动办公软件，它既要满足管理者的控制欲，又要给予团队成员足够的归属感和责任感，同时还要让公司低成本运作，八点办引领一种新的工作方式。
点击下方链接了解产品详情：
http://app.8office.cn/download/gd?invitecode=iulum&amp;version=540
转载于:https://my.oschina.net/duqiu/blog/739103
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c095388e55eead81220bdacb43eb31eb/" rel="bookmark">
			五分钟利用docker搭建好php7.0.10&#43;nginx服务环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/home/wwwroot/ 为网站根目录 自动创建一个叫www的帐号，给网站、nginx、php专用 上面的域名为website.com，可以按需进行更改。 多域名的时候，进去~/nginx_config 复制多一份，进行修改即可
将下面文本保存为script.sh文件 在linux命令行下输入 sudo ./script.sh 即可一键搭建
系统：centos 7.0
#! /usr/bin yum install -y docker PHP_VERSION=7.0.10 # PHP_VERSION 可以改为以下PHP版本的FPM #7.0.10 #7.0 #7 #5.6.25 #5.6 #5 service start docker docker rm -f php docker rm -f nginx groupadd -g 2016 www adduser -g 2016 -u 2016 www mkdir -p /home/wwwroot/ chown -R www:www /home/wwwroot/ chmod -R 755 /home/wwwroot/ { \ echo "&lt;?php"; \ echo "echo '&lt;h1&gt;This is one key web service for Docker.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c095388e55eead81220bdacb43eb31eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7206705742435adef1a1e8d2a92897c2/" rel="bookmark">
			贪心算法----整数区间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、题目描述 给n个区间，形式为[a, b]，a和b均为整数，且a &lt; b。
求一个最小的整数点的集合，使得每个区间至少2个不同的元素(整数点)属于这个集合。
求这个集合的元素个数。
输入
第1行：1个整数n(1 &lt;= n &lt;= 10000)
接下来n行，每行2个整数，表示区间的左右端点a, b(0 &lt;=a &lt; b &lt;= 10000)
输出
第1行：1个整数，表示集合的元素的个数
样例输入
4
3 6
2 4
0 2
4 7
样例输出
4 二、定义解释 区间：就像线段一样，给出线段的端点坐标a、b（a&lt;b），a和b之间的部分就叫区间。 开区间：(a,b)------区间中不包含a,b的值。 闭区间：[a,b]------区间中包含a,b的值。 整数闭区间中的元素：如：闭区间[3,6]中的元素有3、4、5、6. 集合：满足某条件的所有的数。 三、分析 这道题比较难懂，我看了很久才发现题目的意思，就是给你n个闭区间，找一些数使每一个闭区间都有这些数中的两个数。我们可以先把原数据存入结构体中，再重载运算符，方便排序。 #include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node{
int x,y,s;
bool operator &lt; (const node &amp;p)const {
if(y&lt;p.y) return 1;
else if(y==p.y&amp;&amp;x&lt;=p.x) return 1;
return 0;
}
}a[10005],t;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7206705742435adef1a1e8d2a92897c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79b1f53a0c855e48ede924505f53e509/" rel="bookmark">
			微博URL短地址lua生成算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		短地址（Short URL），或 叫短网址、短链接等等 ，就是比较短的URL地址。 借助短地址，可以将原来冗长的网址替换成简短的网址，让使用者可以更容易分享链接。 在Web 2.0的今天，不得不说，这是一个潮流（我喜欢这句话，就 原封不动 从别人文章复制过来了）。 例如：http://t.cn/pQ8LLW 短地址，主要应用场景是微博。微博消息限制字数为140字，如果要发一些链接，这个网址可能占用一半字数了，所以短地址就应运而生。 短地址的生成算法有很多种，这里取其中一种做实现。无论哪种算法都不能避免重复，所以要结合数据库对网址和短地址做映射。 结合MD5的实现算法： 1. 将网址md5后生成32位串，分4段， 每段8字节 2. 对这四段循环处理，和0x3FFFFFFF与运算，即保留30位数据 3. 根据字母表长度取索引值，如a-zA-Z0-9，就有62位，取0x3D （下标从0开始） 4. 将前面的30位数据分成6段，每5位再和0x3D与运算，算得字母表下标，取到6位字符串 这种算法，会生成4个6位字符串。 lua版的算法如下： local md5 = require "md5.core" function md5.sumhexa(k) k = md5.sum(k) return (string.gsub(k, ".", function (c) return string.format("%02x", string.byte(c)) end)) end local SHORT_BASE = { "a" , "b" , "c" , "d" , "e" , "f" , "g" , "h" , "i" , "j" , "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79b1f53a0c855e48ede924505f53e509/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a68fad09a5cbaf77b259d1cbe14de092/" rel="bookmark">
			hibernate 多查询or的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 @RequestMapping(params = "datagridError") public void datagridError(UadptTacActDataEntity uadptTacActData,HttpServletRequest request, HttpServletResponse response, DataGrid dataGrid) { CriteriaQuery cq = new CriteriaQuery(UadptTacActDataEntity.class, dataGrid); //查询条件组装器 org.jeecgframework.core.extend.hqlsearch.HqlGenerateUtil.installHql(cq, uadptTacActData, request.getParameterMap()); try{ //自定义追加查询条件，statusTac是实体类的属性，0是为了优化，比不等于1效率高 cq.add(Restrictions.or( Restrictions.eq("statusTac", 0), Restrictions.eq("statusTerminal", 0), Restrictions.eq("statusBrand", 0), Restrictions.eq("statusModel", 0), Restrictions.eq("statusCmType", 0), Restrictions.eq("statusDual", 0), Restrictions.eq("statusSoftLock", 0), Restrictions.eq("statusNettypeUni", 0), Restrictions.eq("statusNettypeOth", 0))); }catch (Exception e) { throw new BusinessException(e.getMessage()); } cq.add(); this.uadptTacActDataService.getDataGridReturn(cq, true); TagUtil.datagrid(response, dataGrid); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc342bd2f06fae6bca52b0f3cb37d231/" rel="bookmark">
			hibernate多个查询or的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目是hibernate加springMVCpackage com.iujin.web.uadpt.controller.admin; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.util.Iterator; import java.util.List; import java.util.Map; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import org.apache.log4j.Logger; import org.hibernate.criterion.Restrictions; import org.jeecgframework.core.common.controller.BaseController; import org.jeecgframework.core.common.exception.BusinessException; import org.jeecgframework.core.common.hibernate.qbc.CriteriaQuery; import org.jeecgframework.core.common.model.json.AjaxJson; import org.jeecgframework.core.common.model.json.DataGrid; import org.jeecgframework.core.constant.Globals; import org.jeecgframework.tag.core.easyui.TagUtil; import org.jeecgframework.web.system.service.SystemService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.ResponseBody; import org.springframework.web.multipart.MultipartFile; import org.springframework.web.multipart.MultipartHttpServletRequest; import org.springframework.web.multipart.commons.CommonsMultipartResolver; import org.springframework.web.servlet.ModelAndView; import com.iujin.web.uadpt.entity.admin.UadptTacActDataEntity; import com.iujin.web.uadpt.service.admin.UadptTacActDataServiceI; @Controller @RequestMapping("/uadptTacActDataController") public class UadptTacActDataController extends BaseController { @SuppressWarnings("unused") private static final Logger logger = Logger.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc342bd2f06fae6bca52b0f3cb37d231/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fc773cbb11b21ad5cc521b8d6e5b329/" rel="bookmark">
			8点办~互联网公司频繁的会议是团队潜在的敌人
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我看到很多公司把会议放在非工作时间，尤其是下午下班后或者周末开会成常态。
如果一个团队负责人不觉得这样做有什么问题反而大力宣扬，当成团队有战斗力的表现，那么整个团队的味道已经发生变化了。
很多团队负责人开会成瘾。但是很悲哀的是绝大多数的会议是没任何价值的。任何一个团队，不管是大公司还是创业公司，频繁开2小时以上的会议都是没有必要的。这样的会议除了浪费大多数参会者的时间，不能减少任何工作量，甚至还会帮倒忙。在会议中，大多数人是和这场会议是没任何关系的，但是参与进来了，只能听了，偶尔还遇到几个搅屎棍，多数的时候还是领导，那么整个会议会很糟糕，毫无价值的会议。
如何开更加有效的会议？不要让会议毫无价值？
个人建议：
1、参会的人尽可能少，少到只需要面对面沟通，比如2个人的会议。这样的会议效果事半功倍。
2、尽量克制开会，只开必要的会议。
3、借助高效办公管理工具，个人觉得“八点办”移动办公APP就不错，免费还高效。任务、计划、审批、管理等，在上面随时进行。哪怕在千里之外也能随时掌握团队所做的任何项目进度及结果。
借助管理工具，提高所有工作效率，不浪费团队成员时间。员工开心，领导也便于随时随地掌控。所以没必要随时把整个团队拉进会议室开会。
点击下方链接了解产品详情：
http://app.8office.cn/download/gd?invitecode=iulum&amp;version=540
转载于:https://my.oschina.net/duqiu/blog/738127
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbd2df608b34e9781ab84f5151addd3d/" rel="bookmark">
			再谈STM32的CAN过滤器-bxCAN的过滤器的4种工作模式以及使用方法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 前言 bxCAN是STM32系列最稳定的IP核之一，无论有哪个新型号出来，这个IP核基本未变，可见这个IP核的设计是相当成熟的。本文所讲述的内容属于这个IP核的一部分，掌握了本文所讲内容，就可以很方便地适用于所有STM32系列中包含bxCAN外设的型号。有关bxCAN的过滤器部分的内容在参考手册中往往看得“不甚明白“，本文就过滤器的4种工作模式进行详细讲解并使用具体的代码进行演示，这些代码都进行过实测验证通过的，希望能给读者对于bxCAN过滤器有一个清晰的理解。
2. 准备工作 2.1. 为什么要过滤器？ 在这里，我们可以将CAN总线看成一个广播消息通道，上面传输着各种类型的消息，好比报纸，有体育新闻，财经新闻，政治新闻，还有军事新闻，每个人都有自己的喜好，不一定对所有新闻都感兴趣，因此，在看报纸的时候，一般人都是只看自己感兴趣的那类新闻，而过滤掉其他不感兴趣的内容。那么我们一般是怎么过滤掉那些不感兴趣的内容的呢？下面有两种方法来实现这个目的：
第一种方法：
每次看报纸时，你都看下每篇文章的标题，如果感兴趣则继续看下去，如果不感兴趣，则忽略掉。
第二种方法：
你告诉邮递员，你只对财经新闻感兴趣，请只将财经类报纸送过来，其他的就不要送过来了，就这样，你看到的内容必定是你感兴趣的财经类新闻。
上面那种方法好呢？很明显，第二种方法是最好的，因为你不用自己每次判断哪些新闻内容是你感兴趣的，可以免受“垃圾”新闻干扰，从而可以节省时间忙其他事。bxCAN的过滤器就是采用上述第二种方法，你只需要设置好你感兴趣的那些CAN报文ID，那么MCU就只能收到这些CAN报文，是从硬件上过滤掉，完全不需要软件参与进来，从而节省了大大节省了MCU的时间，可以更加专注于其他事务，这个就是bxCAN过滤器的意义所在。
2.2. 两种过滤模式(列表模式与掩码模式) 假设我们是bxCAN这个IP的设计者，现在由我们来设计过滤器，那么我们该如何设计呢？
首先我们是不是很快就会想到只要准备好一张表，把我们需要关注的所有CAN报文ID写上去，开始过滤的时候只要对比这张表，如果接收到的报文ID与表上的相符，则通过，如果表上没有，则不通过，这个就是简单的过滤方案。恭喜你！bxCAN过滤器的列表模式采用的就是这种方案。
但是，这种列表方案有点缺陷，即如果我们只关注一个报文ID，则需要往列表中写入这个ID，如果需要关注两个，则需要写入两个报文ID，如果需要关注100个，则需要写入100个，如果需要1万个，那么需要写入1万个，可问题是，有这个大的列表供我们使用吗？大家都知道，MCU上的资源是有限的，不可能提供1万个或更多，甚至100个都嫌多。非常明显，这种列表的方式受到列表容量大小的限制，实际上，bxCAN的一个过滤器若工作在列表模式下,scale为32时，每个过滤器的列表只能写入两个报文ID，若scale为16时，每个过滤器的列表最多可写入4个CAN ID，由此可见，MCU的资源是非常非常有限的，并不能任我们随心所欲。因此，我们需要考虑另外一种替代方案，这种方案应该不受到数量限制。
下面假设我们是古时候一座城镇的守卫，城主要求只有1156年出生的人才可以进城，我们又该如何执行呢？假设古时候的人也有类似今天的身份证（...-&gt;_&lt;-…）,大家都知道，身份份证号码中有4位是表示出生年月，如下图：
图 1 18位身份证号码的各位定义
如上图，身份证中第7~10这4位数表示的是出生年份，那么，我们可以这么执行：
检查想要进城的所有人的身份证号码的第7~10位数字，如果这个数字依次为1156则可以进入，否则则不可以，至于身份证号码的其他位则完全不关心。假如过几天城主放宽进城条件为只要是1150年~1160前的人都可以进城，那么，我们就可以只关注身份证号码的第7~9这3位数是否为115就可以了，对不对？这样一来，我们就可以非常完美地执行城主的要求了。
再变下，假设现在使用机器来当守卫，不再是人来执行这个“筛选”工作。机器是死的，没有人那么灵活，那么机器又该如何执行呢？
对于机器来说，每一步都得细化到机器可以理解的程度，于是我们可以作如下细化：
第一步：获取想进城的人的身份证号码
第二步：只看获取到身份证的第7~9位，其他位忽略
第三步：将忽略后的结果与1156进行比较
第四步：比较结果相同则通过，不同则不能通过
这种方式，我们称之为掩码模式。
2.3. 验证码与屏蔽码仔细查看上面4个步骤，这不就是C代码中的if语句吗？如下： if( x &amp; y ==z) //x表示待检查身份证号码，y表示只关注第7~9位的屏蔽码，Z则为1156，这里叫做验证码 { //可以通过 } else { //不可以通过 } 对于机器来说，我们要为它准备好两张纸片，一片写上屏蔽码，另一片纸片写上验证码，屏蔽码上相应位为1时，表示此位需要与验证码对应位进行比较，反之，则表示不需要。机器在执行任务的时候先将获取的身份证号码与屏蔽码进行“与”操作，再将结果与验证码的进行比较，根据判断是否相同来决定是否通过。整个判别流程如下所示：
图 2 掩码模式的计算过程
从上图可以很容易地理解屏蔽码与验证码的含义，这样一来，能通过的结果数量就完全取决于屏蔽码，设得宽，则可以通过的多(所有位为0，则不过任何过滤操作，则谁都可以通过)，设得窄，则通过的少(所有位设为1，则只有一个能通过)。那么知道这个有什么用呢？因为bxCAN的过滤器的掩码模式就是采用这种方式，在bxCAN中，分别采用了两个寄存器(CAN_FiR1,CAN_FiR2)来存储屏蔽码与验证码，从而实现掩码模式的工作流程的。这样,我们就知道了bxCAN过滤器的掩码模式的大概工作原理。
但是，我们得注意到，采用掩码模式的方式并不能精确的对每一个ID进行过滤，打个比方，还是采用之前的守卫的例子，假如城主要求只有1150~1158年出生的人能通过，那么，若我们还是才用掩码模式，那么掩码就设为第7~9位为”1”，对应的，验证码的7~9位分别为”115”，这样就可以了。但是，仔细一想，出生于1159的人还是可以通过，是不是？但总体来说，虽然没有做到精确过滤，但我们还是能做到大体过滤的，而这个就是掩码模式的缺点了。在实际应用时，取决于需求，有时我们会同时使用到列表模式和掩码模式，这都是可能的。
2.4. 列表模式与掩码模式的对比 综合之前所述，下面我们来对比一下列表模式与掩码模式这两种模式的优缺点。
模式优点缺点列表模式能精确地过滤每个指定的CAN ID有数量限制掩码模式取决于屏蔽码，有时无法完全精确到每一个CAN ID，部分不期望的CAN ID有时也会收到数量取决于屏蔽码，最多无上限 2.5. 标准CAN ID与扩展CAN ID 1986 年德国电气商BOSCH公司开发出面向汽车的CAN 通信协议，刚开始的时候，CAN ID定义为11位，我们称之为标准格式，ISO11898-1标准中CAN的基本格式如下图所示：
图 3 标准CAN报文格式定义
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbd2df608b34e9781ab84f5151addd3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ad5d458adb40bc43b73fd9653465dcb/" rel="bookmark">
			QQ邮箱发送失败: 命令顺序不正确 Error: need EHLO and AUTH first
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用 System.Net.Mail组建发送邮件的时候出现了"命令顺序不正确。 服务器响应为: Error: need EHLO and AUTH first !"异常
1. 需要开启 POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV服务 并且记住授权码
2. 使用授权码(不要用qq邮箱登录密码)
3.启用smtp.EnableSsl = true;
参考:http://m.blog.csdn.net/article/details?id=52023475
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14b1fa343fe0c12d564a61ec092f3450/" rel="bookmark">
			HelloCharts demo附最新jar下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HelloCharts demo附最新jar下载 最近在做一个项目接触到了Hellocarts开源图表库，现在把代码记一下，以防健忘症又犯。
XML控件引用 &lt;lecho.lib.hellocharts.view.PieChartView android:id="@+id/chart" android:layout_width="match_parent" android:layout_height="match_parent" /&gt; 数据填入 private List&lt;SliceValue&gt; data = new ArrayList&lt;SliceValue&gt;(); SliceValue s1=new SliceValue(); s1.setLabel("收入"+bean.getIncome()+"元"); s1.setValue(Float.valueOf(bean.getIncome())); s1.setColor(getResources().getColor(R.color.main_top)); data.add(s1); setLabel()方法是用于在饼形图上显示的字符，必须设置pieChardata.setHasLabels(true)，如果不这样做，饼形图上面没有字符显示。如果不使用这个方法，饼形图上显示的是setValue()中你加入的值 setValue()方法填入Float的数据 无须担心显示不全的问题 它会自动计算占有的比例。 setColor()设置这个数据在饼形图的区域背景色。
数据通过PieChartData .setValues()方法 填入PieChartView中。
点击事件 PieChartView.setOnValueTouchListener(new TouchListener())； class TouchListener implements PieChartOnValueSelectListener{ //点击某一区域之后 点击其它非数据区域的时候触发 public void onValueDeselected() { Log.e("sss", "onValueDeselected"); } //点击数据在饼形图的区域时触发 @Override public void onValueSelected(int arg0, SliceValue arg1) { } } [如下图，点击花销的时候触发onValueSelected 如下图点击非数据区域时触发onValueDeselected 但是事先必须先点击饼形数据区域 饼形图详细设置 PieChartData pieChardata = new PieChartData(); pieChardata.setHasLabels(false);// 是否显示表情 pieChardata.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14b1fa343fe0c12d564a61ec092f3450/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f6a5e04153fc6c8b1f513ecced7106b/" rel="bookmark">
			python 处理csv，对比两个csv的不同
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		做个记录,备份一下，思路只适合我自己，估计对大家也没有参考价值 import csv def walk_list(a,b,c): list=[] for i in range(len(a)): list.append([a[i],b[i],c[i]]) return list with open('D:\表1相同部分 - 副本.csv','r') as f: readers1=csv.reader(f) list1=[row for row in readers1] #print(list1) # list2=[] # for i in range(len(list1)): # list2.append(list1[i][0]) with open('D:\表2相同部分 - 副本.csv','r') as f: readers1=csv.reader(f) list2=[row for row in readers1] #print(list2) ###打印initiavalue # initiavalue1=[] # initiavalue2=[] # name1=[] # name2=[] # name3=[] # name4=[] # for i in range(len(list2)): # if list1[i][1]!=list2[i][1]: # name1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f6a5e04153fc6c8b1f513ecced7106b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd8c5f132190f7a8c29bdb4307d260ab/" rel="bookmark">
			8点办~互联网公司加班该不该有加班费
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在大多互联网公司，普遍存在加班问题，特别是程序员哥哥们，几乎都会加班的。小编前男友在张江那边的互联网公司上班，他就是程序员哥哥，加班是很厉害的，好像没加班费一说吧，不停的在赶项目进度。
那么一说到加班，可是该不该有加班费呢？到底怎样才算加班呢？ 我自己是工作者，但很不幸，也算个管理者。这意味着我来讨论这个问题，无论说什么，大家都会认为你是站在公司的立场上考虑的，肯定不希望有加班费了。但是我还是以个人的身份来讨论这个加班的问题。
很多人都是拒绝加班的，大多都是我加班了，别给我扯别的，加班费呢？ 加班要加班费的，请问你现在工作做的顺心吗？你是否从来不需要加班呢？是准时在上下班吗？在公司每一分钟都不浪费的努力工作了吗？如果你浪费了工作时间，每月薪水有少发一分吗？每一次加班几小时你去要加班费了吗？每一次加班你都有加班费吗？
现在很多毕业生非常青睐的公务员类的工作，是不是不需要加班，如果加班有加班费吗？ 人性化、福利好而知名的很多外企，需不需要加班，加班有加班费？ 加班分自愿加班和强制加班，当然自愿加班肯定没有加班费了，自愿加班老板都认为是你自己效率太低，需要加班来弥补。
不加班，只有提高工作效率了，借助办公管理工具。移动办公“八点办”APP就非常好，趣味社交、高效办公。最重要还免费的。销售管理、外出管理、项目进度、日报、周报、申请、审批等在八点办APP里面应有尽有，涵盖了办公所需的常备功能。
你上班的时候是否全力在工作，加班的时候真的在加班吗？如果没有，赶紧用“八点办”来协助你提高效率吧。工作的同时还能额外有积分，积分随时随地可以换取自己中意的商品。
点击下方链接了解产品详情：
http://app.8office.cn/download/gd?invitecode=iulum&amp;version=540
转载于:https://my.oschina.net/duqiu/blog/737594
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1054e92a284f0e62cc14da23d495dc0d/" rel="bookmark">
			JSON中单双引号的处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在项目中 , 经常需要将数据封装为一个JSON对象返回给前台进行解析 . 但如果数据中包含双引号或单引号 , 就会导致部分框架在解析JSON时失败 , 无法处理(笔者后台采用的fastjson封装json , 前台用jquery解析json) , 所以这部分数据就需要进行特殊处理 , 使之能够正常解析.
一般来说 , 碰到单引号或双引号 , 用斜杠"\"转义就行 . 但在实际应用中 , 这种方法总是会出现各种问题 , 并且随着jQuery对json的格式严格要求 , 所以只有符合它的标准才能被其解析.
问题示例 : 后台封装JSON
前台解析JSON
解析失败 , 提示报错
我的解决方法是 : 在生成JSON时 , 将特殊的单引号用自定义的字符占位 , 到前台解析时 , 先进行复原
解决方案 : @RequestMapping() public String index(Model model){ JSONObject result = new JSONObject(); result.put("name", "Tony'Fu".replaceAll("'", "%DYH%"));//用特殊符号进行占位 model.addAttribute("data", result); return "demo"; } &lt;script type="text/javascript"&gt; var data = $.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1054e92a284f0e62cc14da23d495dc0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02723187eee5a52fa5f19fc47e9f2a81/" rel="bookmark">
			获取checkbox返回值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;div class="checkbox"&gt; &lt;label&gt; &lt;input type="checkbox" value="0" name="全选" ng-checked="isSelected('0')" ng-click="updateSelection($event,'0')"&gt;全选 &lt;/label&gt; &lt;label&gt; &lt;input type="checkbox" value="1" name="BANNER" ng-checked="isSelected('1')" ng-click="updateSelection($event,'1')"&gt;BANNER &lt;/label&gt; &lt;label&gt; &lt;input type="checkbox" value="2" name="资料库" ng-checked="isSelected('2')" ng-click="updateSelection($event,'2')"&gt;资料库 &lt;/label&gt; &lt;label&gt; &lt;input type="checkbox" value="3" name="最新公告" ng-checked="isSelected('3')" ng-click="updateSelection($event,'3')"&gt;最新公告 &lt;/label&gt; &lt;/div&gt; $scope.selected=[]; var updateSelected=function(action,value){ if(action=="add"&amp;&amp;$scope.selected.indexOf(value)==-1){ $scope.selected.push(value); } if(action=="remove"&amp;&amp;$scope.selected.indexOf(value)!=-1){ var idx=$scope.selected.indexOf(value); $scope.selected.splice(idx,1); } } $scope.isSelected=function(value){ if(value=="0"){ return $scope.selected.indexOf("1")&gt;=0&amp;&amp;$scope.selected.indexOf("2")&gt;=0&amp;&amp;$scope.selected.indexOf("3")&gt;=0; }else{ return $scope.selected.indexOf(value)&gt;=0; } } $scope.updateSelection=function(event,value){ var checkbox=event.target; var action=(checkbox.checked?"add":"remove"); if(value=="0"){ updateSelected(action,"1"); updateSelected(action,"2"); updateSelected(action,"3"); }else{ updateSelected(action,value,checkbox.name); } } 转载于:https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02723187eee5a52fa5f19fc47e9f2a81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5db39ecafb3d320b3810d199fb04102d/" rel="bookmark">
			There was a problem importing one of the Python modules required to run yum
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么80%的码农都做不了架构师？&gt;&gt;&gt; 最近从python 2.6 升级到python2.7 导致 yum 不可用，
原因主要是yum 不支持python27 因此需要更改yum的可用路径
which yum
查看下yum的安装路径
/usr/bin/yum
vi /usr/bin/yum
更改#!/usr/bin/python 为#!/usr/bin/python2.6
更改完成之后就可以了
转载于:https://my.oschina.net/ayy/blog/736512
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fede7991b14fe3453131b924bf8cf2e/" rel="bookmark">
			phalcon 中常用的phql语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先引入Builder类
use Phalcon\Mvc\Model\Query\Builder as QueryBuilder; public function mytestAction(){ $builder = new QueryBuilder(); //确定查询表 $builder -&gt; from(['parts'=&gt;'Test3\Frontend\Models\Parts']); //关联表 $builder -&gt; innerJoin('Test3\Frontend\Models\Robots', 'robots.id = parts.robots_id','robots'); // 需要查询的字段，这里两个表的字段都可以 $builder -&gt; columns([ 'robots.name', 'parts.id', 'count(parts.id) as count', //当数据很大时，统计数据时用 ]); // where条件 $builder -&gt; where('parts.id = :id:',array('id' =&gt;1)); // andWhere $builder -&gt; andWhere('robots.name = :name:',array('name' =&gt; '你好')); //执行搜索 if (isset($params['conditions'])) { foreach ($params['conditions'] as $field =&gt; $val) { if (!preg_match('/^\s*$/', $val)) { //执行模糊搜索 $builder-&gt;andWhere("providers.$field like :$field:"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fede7991b14fe3453131b924bf8cf2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a80fba247d5102fb8aae0cd3185f9a0/" rel="bookmark">
			exp-00003 no storage definition found for segment(0, 0)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		刚为用户升级到11.2.0.4.160419，但居然还会出现此类大多数在9.2下出现的问题： 连接到: Oracle Database 11g Enterprise Edition Release 11.2.0.4.0 - 64bit Production With the Partitioning, Real Application Clusters, Automatic Storage Management, OLAP, Data Mining and Real Application Tes 已导出 ZHS16GBK 字符集和 AL16UTF16 NCHAR 字符集 即将导出指定的用户... . 正在导出 pre-schema 过程对象和操作 . 正在导出用户 TAMIC 的外部函数库名 . 导出 PUBLIC 类型同义词 . 正在导出专用类型同义词 . 正在导出用户 TAMIC 的对象类型定义 即将导出 TAMIC 的对象... . 正在导出数据库链接 . 正在导出序号 . 正在导出簇定义 . 即将导出 TAMIC 的表通过常规路径... . . 正在导出表 AA1导出了 34 行 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a80fba247d5102fb8aae0cd3185f9a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62dd5d120a8acbe3f0fcf60cd48aa537/" rel="bookmark">
			解决vim编辑文件时中文乱码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		情况1：在centOS或debian等Unix系统上，使用vim编辑文件时，输入中文时，中文乱码：
#vim /root/.vimrc
输入如下配置：
syntax onset fileencodings=ucs-bom,utf-8,utf-16,gbk,big5,gb18030,latin1set fileencoding=utf-8 :wq
再次vim编辑时OK。
解释下：syntax on表示语法高亮；fileencoding表示保存文件时的默认文件编码；fileencodings表示vim读取文件时，采用的编码识别序列，从左往右匹配。
情况2：在windows上编写的文件，上传至Linux上，vim编辑时乱码。原因是windows默认使用gbk编码，在Linux上，使用iconv命令可以转码： #iconv -f GBK -t UTF-8 test.txt -o test2.txt
再次vim编辑时OK。
情况3：在secureCRT或xshell等SSH工具上，vim编辑文件时乱码。这个情况很办好：修改客户端的编码格式即可。以secureCRT为例：找到options---session options---terminal---Appearance，把charset encoding改为utf-8就好了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39b577183d17fc9ae1ee5ecc0682d3fc/" rel="bookmark">
			Windows系统SNMP数据监测与OID
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Window通过SNMP获取系统数据的说明
初步接触SNMP（Simple Network Management Protocol）简单网络管理协议之后，对windows系统的监测有了兴趣，通过一段时间的查找资料与实际测试，将系统的一些简单数据通过SNMP协议测试了出来，和大家一起分享。
要想使用SNMP协议监测系统，这里仅说windows操作系统，当然SNMP协议对网络设备基本适用，首先需要做的就是开通并配置好SNMP的服务，具体配置，大家可以上百度搜索或者关注我之后发表的博文（一直较忙，可能上传较晚，望见谅！）。
这里给大家推荐几款关于SNMP的调试工具：
ManageEngine MibBrowser（适用与有现成的.mib库文件）
Paessler SNMP Tester（测试OID）
FreeSnmp（使用Walk探测OID）
对于系统的主要数据，基本在”hostmib.mib”这个库中，至于“lmminb2.mib”库和“mib_ii.mib”库不做太多的说明，我就从这里面提取了部分数据，“mib_ii.mib”库基本上是数据流量的统计。
一、hostmib.mib库
系统运行时间：返回数值以秒为单位
OID：.1.3.6.1.2.1.25.1.1.0
系统当前时间：
OID：.1.3.6.1.2.1.25.1.2.0
主机会话数
OID：.1.3.6.1.2.1.25.1.5.0
系统进程数
OID：.1.3.6.1.2.1.25.1.6.0
系统物理内存
OID：.1.3.6.1.2.1.25.2.2.0 (4088864)
标识：
OID：.1.3.6.1.2.1.25.2.3.1.3.1 C:\ Label: Serial Number 665445ee
OID：.1.3.6.1.2.1.25.2.3.1.3.2 D:\ Label: Serial Number d852e62c
OID：.1.3.6.1.2.1.25.2.3.1.3.3 E:\ Label: Serial Number 57c15850
OID：.1.3.6.1.2.1.25.2.3.1.3.4 F:\ Label: Serial Number b17429e7
OID：.1.3.6.1.2.1.25.2.3.1.3.5 Virtual Memory
OID：.1.3.6.1.2.1.25.2.3.1.3.6 Physical Memory
每个箸/块的大小
OID：.1.3.6.1.2.1.25.2.3.1.4.1 (4096)
OID：.1.3.6.1.2.1.25.2.3.1.4.2 (4096)
OID：.1.3.6.1.2.1.25.2.3.1.4.3 (4096)
OID：.1.3.6.1.2.1.25.2.3.1.4.4 (4096)
OID：.1.3.6.1.2.1.25.2.3.1.4.5 (65536)
OID：.1.3.6.1.2.1.25.2.3.1.4.6 (65536)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39b577183d17fc9ae1ee5ecc0682d3fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c1cad774c06f217c2dc1d3d3a6c7ab8/" rel="bookmark">
			Http中Get/Post请求区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Http中Get/Post请求区别 （1）get是从服务器上获取数据，post是向服务器传送数据。
（1） 在客户端，Get方式在通过URL提交数据，数据在URL中可以看到；POST方式，数据放置在HTML HEADER内提交。
（2） 对于get方式，服务器端用Request.QueryString获取变量的值，对于post方式，服务器端用Request.Form获取提交的数据。
（2） GET方式提交的数据最多只能有1024字节，而POST则没有此限制。
（3） 安全性问题。正如在（1）中提到，使用 Get 的时候，参数会显示在地址栏上，而 Post 不会。所以，如果这些数据是中文数据而且是非敏感数据，那么使用 get；如果用户输入的数据不是中文字符而且包含敏感数据，那么还是使用 post为好。
注：所谓安全的意味着该操作用于获取信息而非修改信息。幂等的意味着对同一 URL 的多个请求应该返回同样的结果。完整的定义并不像看起来那样严格。换句话说，GET 请求一般不应产生副作用。从根本上讲，其目标是当用户打开一个链接时，她可以确信从自身的角度来看没有改变资源。比如，新闻站点的头版不断更新。虽然第二次请求会返回不同的一批新闻，该操作仍然被认为是安全的和幂等的，因为它总是返回当前的新闻。反之亦然。POST 请求就不那么轻松了。POST 表示可能改变服务器上的资源的请求。仍然以新闻站点为例，读者对文章的注解应该通过 POST 请求实现，因为在注解提交之后站点已经不同了（比方说文章下面出现一条注解）。
以下内容引自：http://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html
Http定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE。URL全称是资源描述符，我们可以这样认为：一个URL地址，它用于描述一个网络上的资源，而HTTP中的GET，POST，PUT，DELETE就对应着对这个资源的查，改，增，删4个操作。到这里，大家应该有个大概的了解了，GET一般用于获取/查询资源信息，而POST一般用于更新资源信息。
1.根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。
(1).所谓安全的意味着该操作用于获取信息而非修改信息。换句话说，GET 请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。
* 注意：这里安全的含义仅仅是指是非修改信息。
(2).幂等的意味着对同一URL的多个请求应该返回同样的结果。这里我再解释一下幂等这个概念：
幂等（idempotent、idempotence）是一个数学或计算机学概念，常见于抽象代数中。 幂等有一下几种定义： 对于单目运算，如果一个运算对于在范围内的所有的一个数多次进行该运算所得的结果和进行一次该运算所得的结果是一样的，那么我们就称该运算是幂等的。比如绝对值运算就是一个例子，在实数集中，有abs(a) = abs(abs(a))。 对于双目运算，则要求当参与运算的两个值是等值的情况下，如果满足运算结果与参与运算的两个值相等，则称该运算幂等，如求两个数的最大值的函数，有在在实数集中幂等，即max(x,x) = x。 看完上述解释后，应该可以理解GET幂等的含义了。
但在实际应用中，以上2条规定并没有这么严格。引用别人文章的例子：比如，新闻站点的头版不断更新。虽然第二次请求会返回不同的一批新闻，该操作仍然被认为是安全的和幂等的，因为它总是返回当前的新闻。从根本上说，如果目标是当用户打开一个链接时，他可以确信从自身的角度来看没有改变资源即可。
2.根据HTTP规范，POST表示可能修改变服务器上的资源的请求。继续引用上面的例子：还是新闻以网站为例，读者对新闻发表自己的评论应该通过POST实现，因为在评论提交后站点的资源已经不同了，或者说资源被修改了。
上面大概说了一下HTTP规范中GET和POST的一些原理性的问题。但在实际的做的时候，很多人却没有按照HTTP规范去做，导致这个问题的原因有很多，比如说：
1.很多人贪方便，更新资源时用了GET，因为用POST必须要到FORM（表单），这样会麻烦一点。
2.对资源的增，删，改，查操作，其实都可以通过GET/POST完成，不需要用到PUT和DELETE。
3.另外一个是，早期的Web MVC框架设计者们并没有有意识地将URL当作抽象的资源来看待和设计，所以导致一个比较严重的问题是传统的Web MVC框架基本上都只支持GET和POST两种HTTP方法，而不支持PUT和DELETE方法。
* 简单解释一下MVC：MVC本来是存在于Desktop程序中的，M是指数据模型，V是指用户界面，C则是控制器。使用MVC的目的是将M和V的实现代码分离，从而使同一个程序可以使用不同的表现形式。
以上3点典型地描述了老一套的风格（没有严格遵守HTTP规范），随着架构的发展，现在出现REST(Representational State Transfer)，一套支持HTTP规范的新风格，这里不多说了，可以参考《RESTful Web Services》。
说完原理性的问题，我们再从表面现像上面看看GET和POST的区别：
1.GET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，参数之间以&amp;相连，如：login.action?name=hyddd&amp;password=idontknow&amp;verify=%E4%BD%A0%E5%A5%BD。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如：%E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。
POST把提交的数据则放置在是HTTP包的包体中。
2."GET方式提交的数据最多只能是1024字节，理论上POST没有限制，可传较大量的数据，IIS4中最大为80KB，IIS5中为100KB"？？！
以上这句是我从其他文章转过来的，其实这样说是错误的，不准确的：
(1).首先是"GET方式提交的数据最多只能是1024字节"，因为GET是通过URL提交数据，那么GET可提交的数据量就跟URL的长度有直接关系了。而实际上，URL不存在参数上限的问题，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。
注意这是限制是整个URL长度，而不仅仅是你的参数值数据长度。[见参考资料5]
(2).理论上讲，POST是没有大小限制的，HTTP协议规范也没有进行大小限制，说“POST数据量存在80K/100K的大小限制”是不准确的，POST数据是没有限制的，起限制作用的是服务器的处理程序的处理能力。
对于ASP程序，Request对象处理每个表单域时存在100K的数据长度限制。但如果使用Request.BinaryRead则没有这个限制。
由这个延伸出去，对于IIS 6.0，微软出于安全考虑，加大了限制。我们还需要注意：
1).IIS 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c1cad774c06f217c2dc1d3d3a6c7ab8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02b5165403f45dd7bf602bc34d4e1162/" rel="bookmark">
			linux下安装tcl8.5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先去这里下载：
www.activestate.com
http://downloads.activestate.com/ActiveTcl/Linux/8.5.0/
然后解压
对于.tar.gz的后缀文件可以使用tar zxvf 。。。.tar.gz解压
安装 Tcl
为编译 Tcl 做准备:
cd 到tcl文件夹里然后
cd unix
./configure
编译软件包:
make
安装软件包:
make install
这个时候在命令行就可以输入tclsh进入tcl解释器了
转载于:https://blog.51cto.com/axiaolily/1839955
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82a24dffd19aa285384c9a710cad03f2/" rel="bookmark">
			Intellij idea 主题下载网址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Intellij idea 主题下载网址
http://color-themes.com/?view=index
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/920ce7212116f8995f2c51a564a0d985/" rel="bookmark">
			DB_NAME,SID,ORACLE_SID等参数的剖析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Oracle中，我们会遇到下面一系列的十分重要的参数。同时他们的含义也常常让我们混淆。这些参数有： ORACLE_SID, SID, INSTANCE_NAME, SERVICE_NAME, SERVICES_NAMES, DB_NAME, GLOBAL_DBNAME, SID_NAME，以及网络服务名(net service name)，实例服务名(instance service name)等。下面我一个一个的来学习他们。 1. ORACLE_SID 与 SID 和 INSTANCE_NAME 以及 SID_NAME ORACLE_SID：即ORACLE System IDentifier,它是一个环境变量。我们一般在oracle用户的home目录中的.bash_profile中进行定义，一般该文件包含下面一行： [oracle@localhost ~]$ pwd /home/oracle [oracle@localhost ~]$ grep ORACLE_SID .bash_profile export ORACLE_SID=jiagulun 其作用就是： 在我们使用在sqlplus工具中startup启动数据库时， OS就是利用这个环境变量来fork创建构成Oracle实例的各个进程，以及来命名一些文件的名字。如下所示： [oracle@localhost ~]$ ps -ef | grep oracle oracle 31707 1 0 13:41 ? 00:00:01 ora_pmon_ jiagulun oracle 31709 1 0 13:41 ? 00:00:00 ora_psp0_ jiagulun oracle 31711 1 0 13:41 ? 00:00:00 ora_mman_ jiagulun oracle 31713 1 0 13:41 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/920ce7212116f8995f2c51a564a0d985/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1d223908ad40243fee78d13d451781e/" rel="bookmark">
			Rotate Array数组旋转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		189. Rotate Array 返回将一维数组向右旋转k个位置的结果
Rotate an array of n elements to the right by k steps.
For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4]
如果允许额外分配线性空间，那么可以错位复制原有数组的元素。如果允许修改原有数组，那么可以通过三次反转
数组来实现收旋转，不需要申请额外空间，并且每次反转时间为O(n)，
三次反转数组：第一次反转整个数组；第二次反转数组的前K个数；第三次反转数组剩下的数
例如：
一维数组[1,2,3,4,5,6,7],k=3
第一次反转：7,6,5,4,3,2,1
第二次反转：5,6,7,4,3,2,1
第三次反转：5,6,7,1,2,3,4 最终结果
public class Solution { public void rotate(int[] nums, int k) { k %= nums.length;//k值超过数组长度时 reverse(nums, 0, nums.length-1);//翻转整个数组 &lt;span style="white-space:pre"&gt;	&lt;/span&gt; reverse(nums, 0, k-1);//翻转前k个数 &lt;span style="white-space:pre"&gt;	&lt;/span&gt; reverse(nums, k, nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1d223908ad40243fee78d13d451781e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3b91250a4043fce31b84338d0e5780b/" rel="bookmark">
			归并排序算法的java实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		归并排序的思想是对问题进行分解，比如将数据分成两部分，两部分分别进行归并排序，然后对已经有序的两个部分进行合并，合并的过程只需对两部分数据进行一次遍历即可。归并排序、快速排序、和插入排序在java源码中均有应用，实际应用中往往是多种排序的综合，具体根据问题规模来选择，这在Arrays.sort方法中体现很清晰，后续会出一篇文章进行介绍。以下是归并的简单实现。
public static void mergeSort(int[]a, int m, int n) { if(m &gt;= n) //终结条件 return; int mid ; mid = (m+n)/2; mergeSort(a, m, mid);//前半段归并排序 mergeSort(a, mid+1, n);//后半段归并排序 merge(a, m, mid, n);//合并过程 } public static void merge(int[]a, int m, int mid, int n) { int[] tmp = new int[n-m+1]; // int[] tmp = Arrays.copyOf(a, a.length); int i = m, j = mid+1, k=0; while(i &lt;= mid &amp;&amp; j &lt;= n) { if(a[i]&lt;a[j]) { tmp[k] = a[i]; k++; i++; } else { tmp[k] = a[j]; k++; j++; } } if(i &gt; mid) { while(j&lt;=n) { tmp[k] = a[j]; k++; j++; } } else { while(i &lt;= mid) { tmp[k] = a[i]; k++; i++; } } //copy数组 for(i=0;i&lt;tmp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3b91250a4043fce31b84338d0e5780b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abaf767f2be49113fbd30453e950d15f/" rel="bookmark">
			knockoutjs ajax请求，然后输出到模板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ajax请求数据，返回一个json数组，然后输出到模板
html代码：
&lt;table class="table table-bg table-border table-bordered"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;&lt;/th&gt; &lt;th&gt;表名&lt;/th&gt; &lt;th&gt;注释&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody data-bind="foreach: list"&gt; &lt;tr&gt; &lt;td&gt; &lt;input type="radio" /&gt; &lt;/td&gt; &lt;td data-bind="text:name"&gt;&lt;/td&gt; &lt;td data-bind="text:commnet"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; js代码： &lt;script&gt; var data = []; var viewModel= { list: ko.observableArray(data) }; ko.applyBindings(viewModel); $(function(){ $.ajax({ type:"get", url:"{:url('home/project/getTablesName')}", async:true, success: function(res){ viewModel.list(res); } },'json'); }); &lt;/script&gt; 数据库返回来的josn格式：
[ { name: "masterslave", commnet: "" }, { name: "wmy_account_apply", commnet: "开通/锁定帐号申请表" }, { name: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abaf767f2be49113fbd30453e950d15f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af8d8a3adb7f2be81d597b558ac03b9d/" rel="bookmark">
			dubbo Can not lock the registry cache file
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用dubbo 出现以下异常 要怎么处理诶； 2016-01-22 09:27:06 WARN [com.alibaba.dubbo.registry.support.AbstractRegistry.doSaveProperties(AbstractRegistry.java:221)] - &lt; [DUBBO] Failed to save registry store file, cause: Can not lock the registry cache file C:\Users\Administrator.dubbo\dubbo-registry-127.0.0.1.cache, ignore and retry later, maybe multi java process use the file, please config: dubbo.registry.file=xxx.properties, dubbo version: 2.5.3, current host: 127.0.0.1&gt; java.io.IOException: Can not lock the registry cache file C:\Users\Administrator.dubbo\dubbo-registry-127.0.0.1.cache, ignore and retry later, maybe multi java process use the file, please config: dubbo.registry.file=xxx.properties at com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af8d8a3adb7f2be81d597b558ac03b9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e52ed221929bfb1614cae145efe7afcf/" rel="bookmark">
			Java中迭代器是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可迭代是Java集合框架下的所有集合类的一种共性，也就是把集合中的所有元素遍历一遍。迭代的过程需要依赖一个迭代器对象，那么什么是迭代器呢？
迭代器（Iterator）模式，又叫做游标模式，它的含义是，提供一种方法访问一个容器对象中各个元素，而又不需暴露该对象的内部细节。
注意：Java的集合框架的集合类，有的时候也称为容器。
从定义上看，迭代器是为容器而生，它本质上就是一种遍历的算法。因为容器的实现千差万别，很多时候不可能知道如何去遍历一个集合对象的元素。Java为我们提供了使用迭代的接口，Java的所有集合类丢失进行迭代的。
简单的说，迭代器就是一个接口Iterator，实现了该接口的类就叫做可迭代类，这些类多数时候指的就是java.util包下的集合类。示例代码如下：
public class Test3 { public static void main(String[] args) { List&lt;String&gt;list=new ArrayList&lt;&gt;(); list.add("a"); list.add("b"); Iterator&lt;String&gt;it=list.iterator();//得到lits的迭代器 //调用迭代器的hasNext方法，判断是否有下一个元素 while (it.hasNext()) { //将迭代器的下标移动一位，并得到当前位置的元素值 System.out.println(it.next());	}	} } 首先，创建了一个List的集合对象，并放入了俩个字符串对象，然后通过iterator()方法得到迭代器。iterator()方法是由Iterable接口规定的，ArrayList对该方法提供了具体的实现，在迭代器Iteartor接口中，有以下3个方法：
1.hasNext() 该方法英语判断集合对象是否还有下一个元素，如果已经是最后一个元素则返回false
2.next() 把迭代器的指向移到下一个位置，同时，该方法返回下一个元素的引用
3.remove() 从迭代器指向的Collection中移除迭代器返回的最后一个元素，该操作使用的比较少。
注意：从Java5.0开始，迭代器可以被foreach循环所替代，但是foreach循环的本质也是使用Iterator进行遍历的。
总结： 迭代器，提供一种访问一个集合对象各个元素的途径，同时又不需要暴露该对象的内部细节。java通过提供Iterator和Iterable俩个接口来实现集合类的可迭代性，迭代器主要的用法是：首先用hasNext（）作为循环条件，再用next（）方法得到每一个元素，最后在进行相关的操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8aa7af9d1404c08557fe989bbe84eb83/" rel="bookmark">
			Modbus TCP和Modbus Rtu的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实际上Modbus协议包括ASCII、RTU、TCP。 标准的Modicon控制器使用RS232C实现串行的Modbus。Modbus的ASCII、RTU协议规定了消息、数据的结构、命令和就答的方式，数据通讯采用Maser/Slave方式。 Modbus协议需要对数据进行校验，串行协议中除有奇偶校验外，ASCII模式采用LRC校验，RTU模式采用16位CRC校验. ModbusTCP模式没有额外规定校验，因为TCP协议是一个面向连接的可靠协议。
TCP 协议是MODBUS RTU/ascii协议封装成TCP报文的，本质上没有太大差异，但一个运行于232或485串行通讯平台，一个是运行于以太网平台。
TCP和RTU协议非常类似，只要把RTU协议的两个字节的校验码去掉，然后在RTU协议的开始加上5个0和一个6并通过TCP/IP网络协议发送出去即可
默认服务端口502 计数 未定义 帧长 2Byte 2个0 2Byte 计数：二个字节，内容任意，注意返回帧返回的计数与发送帧的计数相同 帧长：二个字节，从设备地址开始算起的命令帧长度（RTU命令帧去掉校验后的长度） 说明：TCP和RTU协议非常类似，我们只要把RTU协议的两个字节的校验码去掉，然后在RTU协议的开始加上6个字节的数据（如上表所示）并通过TCP/IP网络协议发送出去即可。
我触摸屏上自带了一个以太网口，可设置为MODBUS TCP/IP方式通讯，但另一端是是一个232/485的接口的设备，支持（自带）标准的的MODBUS RTU协议，目前市场上有一种串口服务器，可以将串口和以太网协议相转换，我相求教的是，MODBUS TCP/IP 与MODBUS RTU协议能否通过这种模块进行转换。这种模块叫串口服务器
两个协议的本质都是MODBUS协议，都是靠MODBUS寄存器地址来交换数据；但所用的硬件接口不一样，Modbus RTU一般采用串口RS232C或RS485/422，而Modbus TCP一般采用以太网口。现在市场上有很多协议转换器，可以轻松的将这些不同的协议相互转换，比较有名的我用过的是研华（Advantech）的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d73749487c35cfcfefb993ad26c0f47e/" rel="bookmark">
			Java 数组中new Object[5]语句是否创建了5个对象？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 数组的本质是一个Java类，它是通过new语句来实例化，但是这个new语句却不会实例化数组中的对象，我们对它的理解有些偏差。
对于基本类型的数组，在new语句创建数组实例时，会为该数组分配指定长度的内存空间，并把数组的每个元素的初始化为0。那么，引用类型的数组又是如何来创建和初始化这些内存空间的？其实，引用数据类型的数组也会分配指定长度的内存空间，只不过这些内存空间是用来保存引用的，而不是具体的值，它的初始化值为null。
Object[]obj=new Object[5];
以上代码中，创建了一个Object数组，长度为5，这5个元素的值都是null，然后把创建好的数组实例的引用赋给obj变量。如果需要为这些元素分配具体的对象，则需要分别指定或用{}符号进行初始化，如下所示：
Object[]obj=new Object[]{new Object(),null,null,null,new String("123")};//引用类型的数组
或 obj[0]=new Object();//数组元素在赋对象引用
obj[4]=new String("123");
以上数组实例的内存构成，如图：
总结：
答案为否。其实是创建了一个数组实例，长度为5，每个数组元素的值均为null，并没有创建5个Object对象。如果需要创建5个Object对象，则需要为每个数组元素分别指定或用符号{}。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c69564c9850369b445572e23c3c6dc12/" rel="bookmark">
			windows下创建镜像虚拟磁盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于虚拟磁盘这种技术的应用，在平时的开发过程当中并不会很常见，主要是因为现在的磁盘较大，分区较多，加上现在的IDE功能较为强大。所以运用虚拟磁盘的地方并不多。但是，在很多需要通过脚本来进行程序编译、链接的地方，由于指定固定路径会导致无法在其他PC上使用以及编译容易出错等等问题。所以，通过虚拟磁盘来完成脚本对软件的编译则是十分重要的应用。
虚拟映射磁盘值得是将本地的一个磁盘或文件夹目录映射成一个虚拟的磁盘驱动器，而通过访问这个虚拟映射出来的镜像磁盘，我们就可以直接进入指定的文件夹路径。而脚本访问路径的时候则会变得更加的方便。
创建一个镜像虚拟磁盘的命令为：subst U:(镜像磁盘名称) E:\FolderABC(实际的文件夹路径)。创建成功之后，就可以在我的电脑上产看到新增的磁盘U。
当然，有一些脚本也会自己创建一些镜像映射磁盘，而这些磁盘在我的电脑中无法直接看到，他们是供给脚本编译软件使用的。有时候，我们的映射出来的磁盘可能与已经存在的磁盘相冲突了，发生这种情况该怎么办呢？
一般的处理方式为：现将已经存在的虚拟映射磁盘关闭映射，而后重新映射新的虚拟磁盘。
查看当前虚拟磁盘的命令是：subst;
取消镜像虚拟磁盘的命令是：subst U:(镜像磁盘名称) /D
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c20c363d377bdcea3cb57c1da3cd5a2/" rel="bookmark">
			Oracle脚本工具1.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04fd0d6f28eaee764f50ad43418122b1/" rel="bookmark">
			CentOS7安装和配置FTP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 安装vsftpd #安装vsftpd yum install -y vsftpd #设置开机启动 systemctl enable vsftpd.service # 重启 service vsftpd restart # 查看vsftpd服务的状态 systemctl status vsftpd.service 2. 配置vsftpd.conf #备份配置文件 cp /etc/vsftpd/vsftpd.conf /etc/vsftpd/vsftpd.conf.bak #执行以下命令 sed -i "s/anonymous_enable=YES/anonymous_enable=NO/g" '/etc/vsftpd/vsftpd.conf' sed -i "s/#anon_upload_enable=YES/anon_upload_enable=NO/g" '/etc/vsftpd/vsftpd.conf' sed -i "s/#anon_mkdir_write_enable=YES/anon_mkdir_write_enable=YES/g" '/etc/vsftpd/vsftpd.conf' sed -i "s/#chown_uploads=YES/chown_uploads=NO/g" '/etc/vsftpd/vsftpd.conf' sed -i "s/#async_abor_enable=YES/async_abor_enable=YES/g" '/etc/vsftpd/vsftpd.conf' sed -i "s/#ascii_upload_enable=YES/ascii_upload_enable=YES/g" '/etc/vsftpd/vsftpd.conf' sed -i "s/#ascii_download_enable=YES/ascii_download_enable=YES/g" '/etc/vsftpd/vsftpd.conf' sed -i "s/#ftpd_banner=Welcome to blah FTP service./ftpd_banner=Welcome to FTP service./g" '/etc/vsftpd/vsftpd.conf' #添加下列内容到vsftpd.conf末尾 use_localtime=YES listen_port=21 chroot_local_user=YES idle_session_timeout=300 guest_enable=YES guest_username=vsftpd user_config_dir=/etc/vsftpd/vconf data_connection_timeout=1 virtual_use_local_privs=YES pasv_min_port=10060 pasv_max_port=10090 accept_timeout=5 connect_timeout=1 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04fd0d6f28eaee764f50ad43418122b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/838c7556cc81911573a1036958550cf6/" rel="bookmark">
			如何理解奇偶校验只能发现数据代码中奇数位出错的情况
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先要理解：奇数＋奇数＝偶数；偶数＋奇数＝奇数；偶数＋偶数＝偶数；奇数＋偶数＝奇数；
所以可以得知：一个数加上一个奇数可以改变其原有的奇偶行，然而偶数不可以。所以，只有出现了奇数个错误，才会改变整个数据中的1的个数，
才可以被发现；而发生了偶数个错误，即使发生了也不能发现，因为奇偶校验不能时通过观察1个数的变化来发现错误的，而是通过奇偶行的变化来发现错误的。
所以，只能发现数据代码中奇数位出错的情况。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e174e0e0971825606d6295185df3e0fa/" rel="bookmark">
			iOS中的URL处理中文乱码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.url编码 ios中http请求遇到汉字的时候，需要转化成UTF-8，用到的方法是： NSString * newUrlStr = [urlString stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];
2.url解码 请求后，返回的数据，如何显示的是这样的格式：%3B%2C%2A，此时需要我们进行UTF-8解码，用到的方法是： NSString *str = [urlString stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding];
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdd30d2c400b9ccaf26ec0362453e0d2/" rel="bookmark">
			【电信计费系统项目实战】介绍篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#写在前面
技术源于分享，本篇我主要介绍一下达内的一个web项目：电信计费系统，它是基于struts2+jdbc+oracle实现的，当时完成它感觉并没有完完全全弄透，不过现在一看，咋这么简单呢(嘿嘿！勿喷)。现在拿出来分享给大家，毕竟还是可以学到一些东西的。今天主要给大家看下这个项目及结构，后续篇章将一步步讲解，并用一些其他的技术重构代码。
#电信计费系统项目及其结构展示
#写在最后
这里我就大概的贴出其中几个截图，到后面如果新加了什么技术或模块，我会补充的，欢迎大家提出宝贵的意见。目前这个项目结构是最原始的，如果有同学希望拿去学习，留下你的邮箱，我会抽空发给你。学习的路上，共同进步！
--------------------------------------下载地址----------------------------------------------
下载地址：https://github.com/wblearn/dianxinjifei
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6245c952cc05a95ebce5e770d486355/" rel="bookmark">
			redis学习之集群报错Node is not empty
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 继上一篇redis3.0.x集群搭建完成之后，当然要用客户端JedisCluster简单测试一下集群啦，这样就要将redis.conf里bind 127.0.0.1改成bind +真机ip(我的192.168.161.131),下面简单地将测试中遇到的问题及解决办法记录在本篇。
遇到的问题及解决办法 在redis.conf里bind 真机ip后，接着重新执行每个redis.conf，最后再创建集群，但报错，如下图所示： 图中报的错即：
[ERR] Node 192.168.161.131:7000 is not empty. Either the node already knows other nodes (check with CLUSTER NODES) or contains some key in database 0. 这就奇怪了，于是我又去检查了一下redis.conf，ip我确实改过来了 想了一会发现这三个文件appendonly.aof dump.rdb nodes.conf是之前执行ip127.0.0.1时生成的，在我改为真机ip后在执行并没有生效。 这里解释一下dump.rdb文件：
dump.rdb是由Redis服务器自动生成的 默认情况下 每隔一段时间redis服务器程序会自动对数据库做一次遍历，把内存快照写在一个叫做“dump.rdb”的文件里，这个持久化机制叫做SNAPSHOT。有了SNAPSHOT后，如果服务器宕机，重新启动redis服务器程序时redis会自动加载dump.rdb，将数据库状态恢复到上一次做SNAPSHOT时的状态。
知道原因后就好办了，解决办法：
1)将每个节点下aof、rdb、nodes.conf本地备份文件删除； 2)172.168.63.201:7001&gt; flushdb #清空当前数据库(可省略) 3)之后再执行脚本，成功执行；
问题解决了之后就可以成功从java客户端测试了： ps:这里大家不要这样测试，可以将其写在配置文件里，我这里是为了方便。
写在最后 其实平时在测试中遇到的很多问题，都可以在网上找到答案，这里只是简单的记录其中的一个。关于关于redis集群的介绍，了解请看 redis中文介绍
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e25c21225f98acb5131476de962052d/" rel="bookmark">
			Shell重定向  ＆&gt;file、2&gt;&amp;1、1&gt;&amp;2 、/dev/null的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在shell脚本中，默认情况下，总是有三个文件处于打开状态，标准输入(键盘输入)、标准输出（输出到屏幕）、标准错误（也是输出到屏幕），它们分别对应的文件描述符是0，1，2 。
&gt; 默认为标准输出重定向，与 1&gt; 相同
2&gt;&amp;1 意思是把 标准错误输出 重定向到 标准输出.
&amp;&gt;file 意思是把标准输出 和 标准错误输出 都重定向到文件file中
/dev/null是一个文件，这个文件比较特殊，所有传给它的东西它都丢弃掉
举例说明:
当前目录只有一个文件 a.txt.
[root@redhat box]# ls
a.txt
[root@redhat box]# ls a.txt b.txt
ls: b.txt: No such file or directory 由于没有b.txt这个文件, 于是返回错误值, 这就是所谓的2输出
a.txt 而这个就是所谓的1输出
再接着看: [root@redhat box]# ls a.txt b.txt 1&gt;file.out 2&gt;file.err
执行后,没有任何返回值. 原因是, 返回值都重定向到相应的文件中了,而不再前端显示
[root@redhat box]# cat file.out
a.txt
[root@redhat box]# cat file.err
ls: b.txt: No such file or directory
一般来说, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e25c21225f98acb5131476de962052d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84c63a0be08d2ba843cf3ee22c259ca2/" rel="bookmark">
			PyCharm中运行django程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用PyCharm开发django程序，发现如果不在命令行而在IDE的django项目中直接运行django程序，发现报错，程序如下：
def main(): from people.models import Blog blog = Blog() blog.name = 'blog1' blog.tagline = 'tagline1' blog.save() if __name__ == '__main__': main() print('Done......') 抛出的异常如下：
C:\python\python.exe C:/Users/Administrator/PycharmProjects/mydjango/mytest.py Traceback (most recent call last): File "C:/Users/Administrator/PycharmProjects/mydjango/mytest.py", line 10, in &lt;module&gt; main() File "C:/Users/Administrator/PycharmProjects/mydjango/mytest.py", line 3, in main from people.models import Blog File "C:\Users\Administrator\PycharmProjects\mydjango\people\models.py", line 4, in &lt;module&gt; class Person(models.Model): File "C:\Users\Administrator\PycharmProjects\mydjango\people\models.py", line 5, in Person name = models.CharField(max_length=30) File "C:\python\lib\site-packages\django-1.10-py3.5.egg\django\db\models\fields\__init__.py", line 1043, in __init__ super(CharField, self).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84c63a0be08d2ba843cf3ee22c259ca2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c6674701bd614499b3d6a4148ad3a19/" rel="bookmark">
			Java中JDK和JRE的区别是什么？它们的作用分别是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JDK和JRE是Java开发和运行工具，其中JDK包含了JRE，但是JRE是可以独立安装的~
它们在Java开发和运行的时候起到不同的作用~
关于JDK和JRE，大家一定会记得，在安装JDK的时候需要分为俩个步骤：安装JDK和JRE，大家一般会一起安装，也建议大家分开装，因为这样更能帮助大家弄清它们的区别
JRE是Java Runtime Environment的缩写，是Java程序的运行环境。既然是运行，当然要包含JVM，也就是所谓的Java虚拟机，还有所以的Java类库的class文件，都在lib目录下，并且都打包成了jar。
至于在Windows上的虚拟机是哪个文件呢？就是&lt;JRE安装目录&gt;/bin/server中的jvm.dll。
JDK是Java Development Kit的缩写，是Java的开发工具包，主要包含了各种类库和工具，当然也包含了另外一个JRE，那么为什么要包含另外一个JRE呢？而且&lt;JDK安装目录&gt;/JRE/bin目录下，包含有server一个文件夹~包含一个jvm.dll，这说明JDK提供了一个虚拟机。另外，JDK的bin目录下有各种Java程序需要用到的命令，与JRE的bin目录最明显的区别就是JDK文件下才有javac，这一点很好理解，因为JRE只是一个运行环境而已，与开发无关。正因为如此，具备开发功能的JDK所包含的JRE下才会同时有server的JVM，而仅仅作为运行环境的JRE下，只需要server的jvm.dll就够了。
注意：JDK所提供的运行环境和工具度需要进行环境变量的配置以后，才能使用，最主要的配置就是把&lt;JDK安装目录&gt;/bin目录设置为Path环境变量值的一部分。
另外，安装JRE的时候安装程序会自动把JRE的java.exe添加到了系统变量中。系统变量Path的最前面有%SystemRoot%system32;%SystemRoot%;这样的配置，那样到Windows/system32目录下main去看看，会发现一个java.exe文件。这样就无需配置环境变量，也可以运行Java程序了。
可以这样回答：
JDK是Java的开发工具，它不仅提供了Java程序运行所需的JRE，还提供了一系列的编译，运行等工具，如javac，java，javaw等。JRE只是Java程序的运行环境，它最核心的内容就是JVM（Java虚拟机）及核心类库。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7efb4275410d95d663867a89b8020482/" rel="bookmark">
			新建maven管理的web项目,java目录不全的问题解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新建maven工程：新建maven project，填好信息之后下一步，输入web，然后选择maven-artyfape-webapp，点击完成。这才是一个maven web工程，别选错了哦。
使用sts进行开发时，经常出现新建的maven项目java目录不全的问题。src/main下只有resources一个目录，这是不对的。解决方法如下:
1、修改build path，默认是jre1.5，要改成你所安装的jdk的版本。一般这一步配置完之后，src/main下的目录就都出来了。
2、为了使开发的环境彻底一致。可以配置java compiler里的编译环境为1.7。
3、把project facets 里的jdk配置成1.7，然后把dynamic web module配置成2.5或3.0。
至此 ，开发环境就彻底正确了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60cc9b7bd1218b3c75c169767647c77e/" rel="bookmark">
			杭电 oj2546~0-1背包问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		饭卡 Time Limit: 5000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 22962 Accepted Submission(s): 8047
Problem Description 电子科大本部食堂的饭卡有一种很诡异的设计，即在购买之前判断余额。如果购买一个商品之前，卡上的剩余金额大于或等于5元，就一定可以购买成功（即使购买后卡上余额为负），否则无法购买（即使金额足够）。所以大家都希望尽量使卡上的余额最少。 某天，食堂中有n种菜出售，每种菜可购买一次。已知每种菜的价格以及卡上的余额，问最少可使卡上的余额为多少。 Input 多组数据。对于每组数据： 第一行为正整数n，表示菜的数量。n&lt;=1000。 第二行包括n个正整数，表示每种菜的价格。价格不超过50。 第三行包括一个正整数m，表示卡上的余额。m&lt;=1000。 n=0表示数据结束。 Output 对于每组输入,输出一行,包含一个整数，表示卡上可能的最小余额。 Sample Input 1 50 5 10 1 2 3 2 1 1 2 3 2 1 50 0 Sample Output -45 32 Source UESTC 6th Programming Contest Online 1 #include&lt;iostream&gt; 2 #include&lt;cstring&gt; 3 #include&lt;algorithm&gt; 4 using namespace std; 5 int main() 6 { 7 int n,m; 8 int price[1050]; 9 int d[1050]; 10 while(cin&gt;&gt;n,n) 11 { 12 memset(d,0,sizeof(d)); 13 14 for(int i=1;i&lt;=n;i++) 15 cin&gt;&gt;price[i]; 16 cin&gt;&gt;m; 17 sort(price+1,price+n+1); 18 if(m&lt;5) 19 { 20 cout&lt;&lt;m&lt;&lt;endl; 21 } 22 else 23 { 24 m-=5; 25 for(int i=1;i&lt;n;i++) 26 for(int j=m;j&gt;=price[i];j--) 27 { 28 29 d[j]=max(d[j],d[j-price[i]]+price[i]); 30 } 31 32 cout&lt;&lt;m+5-d[m]-price[n]&lt;&lt;endl; 33 } 34 } 35 return 0; 36 } 状态转移方程 d[j]=max(d[j],d[j-price[i]]+price[i]).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60cc9b7bd1218b3c75c169767647c77e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/311b95dd5df0afc3adad7fbbc877abdd/" rel="bookmark">
			Tomcat8.x web.xml过滤器的配置的解析-&gt;过滤器的实例化-&gt;过滤器的调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Tomcat8.x web.xml过滤器的配置的解析-&gt;过滤器的实例化-&gt;过滤器的调用
// web.xml过滤器的配置的解析、过滤器的实例化、过滤器的调用 // web.xml过滤器的配置的解析、过滤器的实例化-------------1 class org.apache.catalina.core.StandardContext{ protected synchronized void startInternal() throws LifecycleException { // 解析上下文的web.xml文件 fireLifecycleEvent(Lifecycle.CONFIGURE_START_EVENT, null); // 触发事件 "configure_start"------- if (ok) { // 启动过滤器，会把org.apache.tomcat.util.descriptor.web.FilterDef 转成对象 org.apache.catalina.core.ApplicationFilterConfig if (!filterStart()) { log.error(sm.getString("standardContext.filterFail")); ok = false; } } } // 把org.apache.tomcat.util.descriptor.web.FilterDef 转成对象 org.apache.catalina.core.ApplicationFilterConfig public boolean filterStart() { // Instantiate and record a FilterConfig for each defined filter boolean ok = true; synchronized (filterConfigs) { filterConfigs.clear(); for (Entry&lt;String,FilterDef&gt; entry : filterDefs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/311b95dd5df0afc3adad7fbbc877abdd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af58a8677927c33beb4a040a529c3b0b/" rel="bookmark">
			关于论文的修改--对小修的response
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 http://blog.sciencenet.cn/blog-230403-309735.html 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6278dde9322a1e8f543e18364d0fd7bd/" rel="bookmark">
			java.security.NoSuchAlgorithmException: TLS SSLContext not available
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 使用httpclient的时候运行时如下代码报错
CloseableHttpClient httpclient = HttpClients.createDefault(); 异常信息如下
Exception in thread "main" org.apache.http.ssl.SSLInitializationException: TLS SSLContext not available at org.apache.http.ssl.SSLContexts.createDefault(SSLContexts.java:58) at org.apache.http.impl.client.HttpClientBuilder.build(HttpClientBuilder.java:966) at org.apache.http.impl.client.HttpClients.createDefault(HttpClients.java:58) at yan.javatips.closure.HttpTest2.main(HttpTest2.java:26) Caused by: java.security.NoSuchAlgorithmException: TLS SSLContext not available at sun.security.jca.GetInstance.getInstance(GetInstance.java:159) at javax.net.ssl.SSLContext.getInstance(SSLContext.java:156) at org.apache.http.ssl.SSLContexts.createDefault(SSLContexts.java:54) ... 3 more 可是同样的程序在windows平台下没有问题，对应的jar文件在linux平台运行却报错。
解决办法 最初以为是jdk版本不一致，以及linux平台openssl版本过低等原因，中间还遇到了依赖编译、classpath路径设置等问题。主要由于是windows平台下eclipse编写开发，而非在linux平台下直接开发，有些问题可能就没有注意到，比如所需的包是否存在，但是linux下java编译也是通过的。
而后找了源码，发现对应sslcontext是在jsse.jar中，看了看windows目录jre对应文件夹下有此包，再去看linux的jre文件夹下，发现是jsse.pack。使用如下命令转换即可：
root@XXXX:/usr/java/jdk1.8.0_101# cd jre/lib root@XXXX:/usr/java/jdk1.8.0_101/jre/lib# unpack200 jsse.pack jsse.jar root@XXXX:/usr/java/jdk1.8.0_101/jre/lib# 再次运行，一切ok！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f5953cf5e89406211c5cb1c915de586/" rel="bookmark">
			Log4j使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近版本的Log4j，使用maven，导入两个jar包，依赖如下：
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-api&lt;/artifactId&gt; &lt;version&gt;2.6.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.6.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 然后在自己的resource文件下，新建
log4j.properties,运行不了。 修改依赖文件： &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 然后就可以了，不同的的版本不一样，新版本的用法要继续学习。 然后配置文件详解： log4j.rootLogger = INFO, File, stdout rootLogger是设置日志级别和输出端的地方。 比如这句， 日志级别是INFO， 输出地方WieFile 和 stdout两个地方。 然后在下面要配置输出地方的位置，格式，比如下面： Here, we use two appenders, one appender to log to a file and another one to log to the console. The first appender uses the org.apache.log4j.FileAppender and the second one the org.apache.log4j.ConsoleAppender. The first appender has a fileattribute, where the logging file is set, whereas the second one has a target attribute which is set to System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f5953cf5e89406211c5cb1c915de586/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4a6f4c98de224a0fac138cc8b1b62a8/" rel="bookmark">
			redis学习之redis3.0.x集群搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 2015年2月，Redis3.0.0 发布，redis3.0版本之后支持Cluster，关于redis集群的介绍，了解请看 redis中文简介 。 我准备在一台linux中来部署redis集群，因为集群的运行需要6台服务才能正常运行，所以我在一台linux服务上创建6个节点，用来模拟3主3从这种伪分布式集群。redis3.0及之后的releases版本，大家可以直接访问redis.io官网，下载redis.tar.gz。
集群搭建 1.下载和解包 cd /usr/local/ wget http://download.redis.io/releases/redis-3.0.3.tar.gz (大家可以选择自己想安装的releases版本)
tar -zxvf redis-3.0.3.tar.gz mv redis-3.0.3 redis 2.编译安装 cd redis make &amp;&amp; make install 有些人在这里可能会碰到一个错误导致编译不过(如下)
make[1]: Entering directory /redis/src' CC adlist.o In file included from adlist.c:34: zmalloc.h:50:31: error: jemalloc/jemalloc.h: No such file or directory zmalloc.h:55:2: error: #error "Newer version of jemalloc required" make[1]: *** [adlist.o] Error 1 make[1]: Leaving directory/redis/src’ make: * [all] Error 2Error 2
原因是没有安装jemalloc内存分配器，可以安装jemalloc 或 直接 输入make MALLOC=libc &amp;&amp; make install
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4a6f4c98de224a0fac138cc8b1b62a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46aea8a83007530f856b2175a272a3df/" rel="bookmark">
			Js 取模运算、取商、取整方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.Js代码：
//求余数 document.write(1%4); document.write(6%4); //求商 console.info(1/4); console.info(6/4); //求商，取整 console.info(parseInt(1/4)); console.info(parseInt(6/4)); console.info('----'); //天花板取整 console.info(Math.ceil(1/4)); //地板取整 console.info(Math.floor(1/4)); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7831fda15d7331a949efd3b052429ac1/" rel="bookmark">
			js各类验证和数据处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/** * 验证密码复杂度（必须包含数字字母） * @param str * @returns true:满足规则，false:不满足 */ function validateStr(str){ var reg1 = /^(([0-9]{1,})([a-z]{1,}))|(([a-z]{1,})([0-9]{1,}))$/; var reg2 = /^(([0-9]{1,})([A-Z]{1,}))|(([A-Z]{1,})([0-9]{1,}))$/; //var reg3 = /^([a-zA-Z]{0,})[0-9a-z-A-z]{0,}[~`!@#$%^&amp;*.]{0,}$/; str = valueTrim(str); //if(reg3.test(str)){ //	return true; //} if(reg1.test(str)){ return true; } if(reg2.test(str)){ return true; } return false; } /** * 判断字符串长度 必须大于8位小于20位，一般用于密码 * @param str 字符串 * @returns 满足返回true */ function valiDateLength(str){ if(str==null || str==''){ return false; } str = valueTrim(str); if(parseFloat(str.length)&lt;8 ){ return false; } if(parseFloat(str.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7831fda15d7331a949efd3b052429ac1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ad02959ef58343054eaa406f5b7e115/" rel="bookmark">
			设置请求头信息的不同方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文：http://blog.csdn.net/magiclr/article/details/49643277
在AngularJs中有三种方式可以设置请求头信息：
1、在http服务的服务端发送请求时，也就是调用http()方法时，在config对象中设置请求头信息：
$http.post('/somePath' , someData , { headers : {'Authorization' : authToken} }).success(function(data, status, headers, config) { //... }).error(function(data, status, headers, config ) { //... }); 这种方法的好处是针对不同路径的请求，可以个性化配置请求头部；
缺点就是，不同路径请求都需要单独配置。
2、第二种设置请求头信息的方式就是在$httpProvider.defaults.headers属性上直接配置。
angular.module('app', []) .config(function($httpProvider) { $httpProvider.defaults.headers.common = { 'My-Header' : 'value' } }) $httpProvider.defaults.headers有不同的属性，如common、get、post、put等。因此可以在不同的http请求上面添加不同的头信息，common是指所有的请求方式。
这种方式添加请求头信息的优势就是可以给不同请求方式添加相同的请求头信息；
缺点就是不能够为某些请求path添加个性化头信息。
3、第三种设置请求头信息的地方是$httpProvider.interceptors。也就是为请求或响应注册一个拦截器。使用这种方式首先需要定义一个服务。
myModule.factory('authInterceptor', function($rootScope, $cookies){ return { request: function(config){ config.headers = config.headers || {}; if($cookies.get('token')){ config.headers.authorization = 'Bearer ' + $cookies.get('token'); } return config; }, responseError: function(response){ // .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ad02959ef58343054eaa406f5b7e115/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14cc95d00030b8f83dbea725b1461077/" rel="bookmark">
			android--登录例子，保存用户名和密码到这个应用所在文件中，从文件中读取用户名和密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		登录例子，保存用户名和密码到这个应用所在文件中，从文件中读取用户名和密码 1.写登录界面activity_main.xml
&lt;span style="font-size:18px;"&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="fill_parent" android:layout_height="fill_parent" android:orientation="vertical" &gt; &lt;EditText android:id="@+id/tname" android:layout_width="match_parent" android:layout_height="wrap_content" android:hint="@string/input_username" /&gt; &lt;EditText android:id="@+id/tpass" android:layout_width="match_parent" android:layout_height="wrap_content" android:hint="@string/input_pass" /&gt; &lt;RelativeLayout android:layout_width="match_parent" android:layout_height="wrap_content" &gt; &lt;CheckBox android:id="@+id/chk" android:layout_centerVertical="true" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@string/remember" /&gt; &lt;Button android:id="@+id/btn" android:layout_alignParentRight="true" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="right" android:paddingLeft="50dp" android:paddingRight="50dp" android:text="@string/login" /&gt; &lt;/RelativeLayout&gt; &lt;/LinearLayout&gt;&lt;/span&gt; String.xml中代码如下： &lt;span style="font-size:18px;"&gt;&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;resources&gt; &lt;string name="app_name"&gt;login&lt;/string&gt; &lt;string name="hello_world"&gt;Hello world!&lt;/string&gt; &lt;string name="action_settings"&gt;Settings&lt;/string&gt; &lt;string name="input_pass"&gt;请输入密码&lt;/string&gt; &lt;string name="input_username"&gt;请输入用户名&lt;/string&gt; &lt;string name="login"&gt;登录&lt;/string&gt; &lt;string name="remember"&gt;记住我&lt;/string&gt; &lt;/resources&gt; &lt;/span&gt; 2.在MainActivity.java中获取相应的值，注册点击事件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14cc95d00030b8f83dbea725b1461077/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f843a996c5ae46bb1fe8c4b59471bb70/" rel="bookmark">
			后序线索化二叉树及遍历（图解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇博客对于 二叉树线索化以及线索化的先序、中序、后序遍历做了比较详细的描述
写在前面
其实，我还是很想把本篇博客和二叉树的线索化写在一块的，但是考虑到可能这博客的内容就看足以超过了上一篇的篇幅，考虑到读者可能会疲乏，而且这篇也是线索二叉树中最难的了（查阅了很多网上的资料也鲜有人来讲述后序线索二叉树的遍历，有的就算有也只是把代码放在那里，理解 对于初学者还是有点困难的）
构建节点（多了双亲节点节点）
typedef enum { Link, Thread }Pointer; typedef struct TriTreeNode { TriTreeNode(const char data) :_data(data) , pLeft(NULL) , pRight(NULL) , pParent(NULL) , Ltag(Link) , Rtag(Link) {} char _data; struct TriTreeNode* pLeft; struct TriTreeNode* pRight; struct TriTreeNode* pParent;//双亲 Pointer Ltag, Rtag; }TriTreeNode; 还是先给出一个树结构吧：
后序线索化二叉树
后序的顺序是：左- 右-根
思路：和先序、中序线索化二叉树的顺序是一样的，在此不再赘述，想看的话上一篇博客会让你满意的。
上代码：
void _PostThreading(TriTreeNode*&amp; Root) { if (Root) { _PostThreading(Root-&gt;pLeft); _PostThreading(Root-&gt;pRight); if (Root-&gt;pLeft == NULL) { Root-&gt;pLeft = Prev; Root-&gt;Ltag = Thread; } if (Prev &amp;&amp; Prev-&gt;pRight == NULL ) //条件 Prev { Prev-&gt;pRight = Root; Prev-&gt;Rtag = Thread; } Prev = Root; } } 如下图，后序线索化的二叉树
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f843a996c5ae46bb1fe8c4b59471bb70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c6c77ef6a8d91c59f5fa8cfdf57573c/" rel="bookmark">
			ubuntu 下配置并使用SQLite3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介：SQLite，是一款轻型的数据库，是遵守ACID的关系型数据库管理系统，它包含在一个相对小的C库中。它是D.RichardHipp建立的公有领域项目。它的设计目标是嵌入式的，而且目前已经在很多嵌入式产品中使用了它，它占用资源非常的低，在嵌入式设备中，可能只需要几百K的内存就够了。它能够支持Windows/Linux/Unix等等主流的操作系统，同时能够跟很多程序语言相结合，比如 Tcl、C#、PHP、Java等，还有ODBC接口，同样比起Mysql、PostgreSQL这两款开源的世界著名数据库管理系统来讲，它的处理速度比他们都快。SQLite第一个Alpha版本诞生于2000年5月。 至2015年已经有15个年头，SQLite也迎来了一个版本 SQLite 3已经发布。 1、ubuntu下安装sqlite3 第一步：输入命令sudo apt-get install sqlite3 ，安装sqlite3; 第二步：输入命令：sqlite3 -help，显示以下内容，则安装成功，可以输入sqlite3 -version查看版本信息； 2、sqlite3的简单使用 2.1、创建一个数据库 命令：sqlite3 + 数据库名 如：sqlite3 test.db : 创建一个名为test的数据库 2.2、数据库中表(table)操作 命令：create table + 表名(字段名)。 如： create table class(ID int primary key , name text):创建一个名为class的表，字段包含 ID ，name 命令：.tables :查看数据库包含的表 命令：.schema + 表名: 查看表中的字段信息 如：.schema class : 查看表class字段内容 命令：drop table + 表名 ：删除指定的表 如：drop table class ：删除名叫class的表 2.3、表中的记录操作 命令：insert into + 表名 values（… , … , … , … , …）; 如：insert into class values （1 , ‘Mike’）：向class表中插入一条记录 可以调整显示格式 sqlite&gt;.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c6c77ef6a8d91c59f5fa8cfdf57573c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74252865e31a716493ef1e90a30d6570/" rel="bookmark">
			java.io.EOFException: Unexpected end of ZLIB input stream异常处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java.io.EOFException: Unexpected end of ZLIB input stream异常处理 因需要完成压缩与解压缩功能，所以使用到java.util.zip中的类。同时使用了jdk 1.7 try with resource 的特性，结果暴出java.io.EOFException: Unexpected end of ZLIB input stream异常。
java.io.EOFException: Unexpected end of ZLIB input stream at java.util.zip.InflaterInputStream.fill(InflaterInputStream.java:240) at java.util.zip.InflaterInputStream.read(InflaterInputStream.java:158) at java.util.zip.GZIPInputStream.read(GZIPInputStream.java:117) at java.io.FilterInputStream.read(FilterInputStream.java:107) at com.sf.framework.rpc.util.NioUtils.unzip(NioUtils.java:27) at framework.rpc.util.NioUtilsTest.unzipTest(NioUtilsTest.java:24) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:497) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) at org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74252865e31a716493ef1e90a30d6570/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b068f099886ee92e27ed493dee08a625/" rel="bookmark">
			22. Spring Boot 拦截器HandlerInterceptor【从零开始学Spring Boot】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【视频 &amp; 交流平台】 à SpringBoot视频
http://study.163.com/course/introduction.htm?courseId=1004329008&amp;utm_campaign=commission&amp;utm_source=400000000155061&amp;utm_medium=share
à SpringCloud视频
http://study.163.com/course/introduction.htm?courseId=1004638001&amp;utm_campaign=commission&amp;utm_source=400000000155061&amp;utm_medium=share
à Spring Boot源码
https://gitee.com/happyangellxq520/spring-boot
à Spring Boot交流平台
http://412887952-qq-com.iteye.com/blog/2321532
上一篇对过滤器的定义做了说明，也比较简单。过滤器属于Servlet范畴的API，与Spring 没什么关系。 Web开发中，我们除了使用 Filter 来过滤请web求外，还可以使用Spring提供的HandlerInterceptor（拦截器）。
HandlerInterceptor 的功能跟过滤器类似，但是提供更精细的的控制能力：在request被响应之前、request被响应之后、视图渲染之前以及request全部结束之后。我们不能通过拦截器修改request内容，但是可以通过抛出异常（或者返回false）来暂停request的执行。
实现 UserRoleAuthorizationInterceptor 的拦截器有： ConversionServiceExposingInterceptor CorsInterceptor LocaleChangeInterceptor PathExposingHandlerInterceptor ResourceUrlProviderExposingInterceptor ThemeChangeInterceptor UriTemplateVariablesHandlerInterceptor UserRoleAuthorizationInterceptor
其中 LocaleChangeInterceptor 和 ThemeChangeInterceptor 比较常用。
配置拦截器也很简单，Spring 为此提供了基础类WebMvcConfigurerAdapter ，我们只需要重写addInterceptors 方法添加注册拦截器。
实现自定义拦截器只需要3步： 1、创建我们自己的拦截器类并实现 HandlerInterceptor接口。
2、创建一个Java类继承WebMvcConfigurerAdapter，并重写 addInterceptors 方法。
2、实例化我们自定义的拦截器，然后将对像手动添加到拦截器链中（在addInterceptors方法中添加）。
PS：本文重点在如何在Spring-Boot中使用拦截器，关于拦截器的原理请大家查阅资料了解。
代码示例：
com.kfit.interceptor.MyInterceptor1.java
package com.kfit.interceptor;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;
/**
* 自定义拦截器1
*
* @author Angel
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b068f099886ee92e27ed493dee08a625/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a6d4605856337fef95172a7cb70b07d/" rel="bookmark">
			ReportViewer 只报 “本地报表处理期间出错” 其它很多原因的！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、检查是否安装了 ReportViewer 插件，一般在新系统上就会忘了安装这个插件，把项目拷贝过来后就出现这些鬼问题，
2、 设置c:windows\temp 目录访问权限 temp--&gt; 属性--&gt;安全-- &gt; 添加network service --&gt;并赋予其权限为 读 和 写--&gt; 确定
3、 设置c:windows\temp 目录访问权限 temp--&gt; 属性--&gt;安全-- &gt; 添加IIS_IUSRS --&gt;并赋予其权限为 读 和 写--&gt; 确定
4、 设置发布网站的程序目录中bin文件夹的权限 同样添加 network service 并设置权限为读取、 运行 5、检查数据源是不是匹配，或许就差一个字符就弄死你， 7、对应参数是否对应一致，很多时候参数不一致也这样子提示， 这些问题都是常的问题，但是系统就只报 “本地报表处理期间出错” ，一般拒绝访问什么什么文件的 就是上面的权限没给的问题。 8. 2.拷贝三个dll到Bin内：
Microsoft.ReportViewer.Common.dll
Microsoft.ReportViewer.WebForms.dll
Microsoft.ReportViewer.ProcessingObjectModel.dll
其中，第一个和第二个可以在项目中直接添加引用，引用后右键属性，将“复制到本地”设置成true，这样就添加到了项目中。第三个有些复杂，它需要运行在GAC中，不能像其他两个一样直接操作。微软也意识到了这一点，就专门制作了一个安装包，安装后直接把第三个安装到了GAC中。因为我的版本是vs2010，所以提供2010版的下载链接：点击这里 。其他版本的下载地址可以该页面的下方的“相关资源”链接中找到。
至此，应该可以解决99%的问题，但是我在寻找答案的过程中发现该方法可解决不了。
提供2010版的下载链接（ReportViewer）
https://www.microsoft.com/en-us/download/confirmation.aspx?id=6442
问题二：System.UnauthorizedAccessException: 对路径“D:\RDIMS\TCPortal\rdlc\ORC\4396.jpeg”的访问被拒绝
引发类型为“System.Web.HttpUnhandledException”的异常。
System.Web.HttpUnhandledException (0x80004005): 引发类型为“System.Web.HttpUnhandledException”的异常。 ---&gt; System.UnauthorizedAccessException: 对路径“D:\RDIMS\TCPortal\rdlc\ORC\4396.jpeg”的访问被拒绝。 在 System.IO.__Error.WinIOError(Int32 errorCode, String maybeFullPath) 在 System.IO.File.InternalDelete(String path, Boolean checkHost) 在 TCPortal_Print_RnQRCodeEncoder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a6d4605856337fef95172a7cb70b07d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e237c87adfa101473d838764bfc8a10b/" rel="bookmark">
			Shell_Find
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		find 1.基本格式（绿色的部分为固定参数）
（1）find 路径 -name‘*.txt’;表示查找以.txt结尾的文件 &amp;example: find . -name '*.txt' /*表示查找当前目录下的以.txt结尾的文件*/ （2）find 路径 -name‘[a-z]*’ ; 表示查找以字母a-z开头的文件
example: find . -name '[a-z]*' （3） find 路径 -name ‘host*’ ； 查找以字母“host”开头的文件 （4）find 路径 -perm775 ； 查找权限是 775 的文件 （5）find 路径 -userroot ； 查找文件用户是root 的文件 （6）find 路径 -mtime +n(-n) ；查找 当前目录下n天以前（n天以内的） （7）find 路径 -type f ； 查找当前目录下类型是file的文件（d：目录文件，l ： 链接文件） （8）find 路径 -size +1000000c ; 查找当前目录下，文件大小超过1M的文件，“-”以内的，c代表字节。 2.扩展 (1)创建多个文件，当前权限相同，修改这些用户的权限，目标权限相同 find . -perm 664 | xargs chmod 775 （2）文件批量删除同理 find .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e237c87adfa101473d838764bfc8a10b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5586e52e4f697cfc99c3e570828a7254/" rel="bookmark">
			Java Map集合的详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，Map
先说一下Map吧~
如果程序中存储了几百万个学生，而且经常需要使用学号来搜索某个学生，那么这个需求有效的数据结构就是Map。
Map是一种依照键（key）存储元素的容器，键（key）很像下标，在List中下标是整数。在Map中键（key）可以使任意类型的对象。Map中不能有重复的键（Key），每个键（key）都有一个对应的值（value）。
一个键（key）和它对应的值构成map集合中的一个元素。
Map中的元素是两个对象，一个对象作为键，一个对象作为值。键不可以重复，但是值可以重复。
看顶层共性方法找子类特有对象.
Map与Collection在集合框架中属并列存在
Map存储的是键值对
Map存储元素使用put方法，Collection使用add方法
Map集合没有直接取出元素的方法，而是先转成Set集合，在通过迭代获取元素
Map集合中键要保证唯一性
也就是Collection是单列集合, Map 是双列集合。
总结: Map一次存一对元素, Collection 一次存一个。Map 的键不能重复，保证唯一。
Map 一次存入一对元素,是以键值对的形式存在.键与值存在映射关系.一定要保证键的唯一性.
查看api文档:
interface Map&lt;K,V&gt;
K - 此映射所维护的键的类型
V - 映射值的类型
概念
将键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。
特点
Key和Value是1对1的关系，如：门牌号 ：家 老公:老婆
双列集合
Map学习体系： ---| Map 接口 将键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。 ---| HashMap 采用哈希表实现，所以无序 ---| TreeMap 可以对健进行排序 ---|Hashtable: 底层是哈希表数据结构，线程是同步的，不可以存入null键，null值。 效率较低，被HashMap 替代。 ---|HashMap: 底层是哈希表数据结构，线程是不同步的，可以存入null键，null值。 要保证键的唯一性，需要覆盖hashCode方法，和equals方法。 ---| LinkedHashMap： 该子类基于哈希表又融入了链表。可以Map集合进行增删提高效率。 ---|TreeMap: 底层是二叉树数据结构。可以对map集合中的键进行排序。需要使用Comparable或者Comparator 进行比较排序。return 0，来判断键的唯一性。 常见方法
1、添加： 1、V put(K key, V value) （可以相同的key值，但是添加的value值会覆 盖前面的，返回值是前一个，如果没有就返回null） 2、putAll(Map&lt;?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5586e52e4f697cfc99c3e570828a7254/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85c5ada20540e73ed4597cdca210825a/" rel="bookmark">
			Java Set集合的详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，Set Set:注重独一无二的性质,该体系集合可以知道某物是否已近存在于集合中,不会存储重复的元素 用于存储无序(存入和取出的顺序不一定相同)元素，值不能重复。
对象的相等性
引用到堆上同一个对象的两个引用是相等的。如果对两个引用调用hashCode方法，会得到相同的结果，如果对象所属的类没有覆盖Object的hashCode方法的话，hashCode会返回每个对象特有的序号（java是依据对象的内存地址计算出的此序号），所以两个不同的对象的hashCode值是不可能相等的。
如果想要让两个不同的Person对象视为相等的，就必须覆盖Object继下来的hashCode方法和equals方法，因为Object hashCode方法返回的是该对象的内存地址，所以必须重写hashCode方法，才能保证两个不同的对象具有相同的hashCode，同时也需要两个不同对象比较equals方法会返回true
该集合中没有特有的方法，直接继承自Collection。
---| Itreable 接口 实现该接口可以使用增强for循环 ---| Collection	描述所有集合共性的接口 ---| List接口	可以有重复元素的集合 ---| ArrayList ---| LinkedList ---| Set接口	不可以有重复元素的集合 案例：set集合添加元素并使用迭代器迭代元素。
public class Demo4 { public static void main(String[] args) { //Set 集合存和取的顺序不一致。 Set hs = new HashSet(); hs.add("世界军事"); hs.add("兵器知识"); hs.add("舰船知识"); hs.add("汉和防务"); System.out.println(hs); // [舰船知识, 世界军事, 兵器知识, 汉和防务] Iterator it = hs.iterator(); while (it.hasNext()) { System.out.println(it.next()); } } } 二，HashSet ---| Itreable 接口 实现该接口可以使用增强for循环 ---| Collection	描述所有集合共性的接口 ---| List接口	可以有重复元素的集合 ---| ArrayList ---| LinkedList ---| Set接口	不可以有重复元素的集合 ---| HashSet 线程不安全，存取速度快。底层是以哈希表实现的。 HashSet
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85c5ada20540e73ed4597cdca210825a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e70e3e6e517443073c55bd71e71829e/" rel="bookmark">
			Java 迭代器Iterator的详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了方便的处理集合中的元素,Java中出现了一个对象,该对象提供了一些方法专门处理集合中的元素.例如删除和获取集合中的元素.该对象就叫做迭代器(Iterator).
对 Collection 进行迭代的类，称其为迭代器。还是面向对象的思想，专业对象做专业的事情，迭代器就是专门取出集合元素的对象。但是该对象比较特殊，不能直接创建对象（通过new），该对象是以内部类的形式存在于每个集合类的内部。
如何获取迭代器？Collection接口中定义了获取集合类迭代器的方法（iterator（）），所以所有的Collection体系集合都可以获取自身的迭代器。
1.Iterable
正是由于每一个容器都有取出元素的功能。这些功能定义都一样，只不过实现的具体方式不同（因为每一个容器的数据结构不一样）所以对共性的取出功能进行了抽取，从而出现了Iterator接口。而每一个容器都在其内部对该接口进行了内部类的实现。也就是将取出方式的细节进行封装。
Jdk1.5之后添加的新接口, Collection的父接口. 实现了Iterable的类就是可迭代的.并且支持增强for循环。该接口只有一个方法即获取迭代器的方法iterator（）可以获取每个容器自身的迭代器Iterator。（Collection）集合容器都需要获取迭代器（Iterator）于是在5.0后又进行了抽取将获取容器迭代器的iterator（）方法放入到了Iterable接口中。Collection接口进程了Iterable，所以Collection体系都具备获取自身迭代器的方法，只不过每个子类集合都进行了重写（因为数据结构不同）
2.Iterator iterator() 返回该集合的迭代器对象
该类主要用于遍历集合对象，该类描述了遍历集合的常见方法
1：java.lang. Itreable ---| Itreable 接口 实现该接口可以使用增强for循环
---| Collection 描述所有集合共性的接口
---| List接口 可以有重复元素的集合
---| Set接口 不可以有重复元素的集合
public interface Iterable&lt;T&gt;
Itreable 该接口仅有一个方法，用于返回集合迭代器对象。
Iterator&lt;T&gt; iterator() 返回集合的迭代器对象
Iterator接口定义的方法
Itreator	该接口是集合的迭代器接口类，定义了常见的迭代方法 1：boolean hasNext() 判断集合中是否有元素，如果有元素可以迭代，就返回true。 2： E next() 返回迭代的下一个元素，注意： 如果没有下一个元素时，调用 next元素会抛出NoSuchElementException 3： void remove() 从迭代器指向的集合中移除迭代器返回的最后一个元素（可选操 作）。 思考：为什么next方法的返回类型是Object的呢？ 为了可以接收任意类型的对象,那么返回的时候,不知道是什么类型的就定义为object
3.迭代器的遍历
第一种方式：while循环
public static void main(String[] args) { ArrayList list = new ArrayList(); // 增加：add() 将指定对象存储到容器中 list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e70e3e6e517443073c55bd71e71829e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/922edb67e7453ba77304be1b29087e89/" rel="bookmark">
			C&#43;&#43;和Java，绝不只是语法不同这么简单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说到面向对象，我们的脑海中立马会涌现出C++，java，object-C 这几个大类的语言，甚至是C#。似乎看来，他们都是面向对象的不同实现而已（博主这句话就很C++了）。尤其对于初学者而言，很难显见他们之间的不同以及设计哲学上的差异，这种差异需要我们有过几年的编程经验，同时对几种语言都比较熟悉的时候才能够深刻的感受到。
以前有人说C++就是强化版的C++，现在应该没有人继续有这种思想了吧。之所以会有这种思想，就是没有真正心领神会C++的设计哲学，而只是将C++当做一个对C语言进行过封装和代码构造优化的语言而已。其实不然，C++和C是两个完全不同的世界，新东方的创始人之一的王强，曾在美国贝尔实验室工作。他曾谈到C与C++之间的区别，就曾提到这是两个完全不同的语言，只是仅仅有部分语言相似而已。带来对事物的理解也更是不同的，C++的世界观本质就是面向对象的，而非C语言结构式的世界观。我们可以很大胆的说，C++的设计哲学是要高于C语言的，它的出现不是仅仅为了填补C语言在大工程方面构造能力的不足，而是创造了一种新的语言和思想，用以工程化设计和实现。
曾有人诟病，说C++的效率低于C语言，而这个问题早已经被验证了，同样的函数，由于C++内部早已经经过十分巧妙的设计和优化，效率不仅不低于C语言，甚至在很多方面会高于C语言的执行方式。
说完了C语言和C++的不同之后，现在来说说java和C++。我觉得讨论他们之间的热度已经超过了以前对C语言和C++之间的争论了。喜欢java的人说，java 才是真正的面向对象语言，C++属于半面向对象，甚至还扬言以后C++会被java取代。java由于其良好的内存管理机制，导致了程序员获得了生产力的解放，可以进行更多工程方面的工作，而不用陷于代码的结构中。今天我们不说语法差异，我觉得对于两种语言都使用过之后，微小的语法差异并不是他们之间最大的不同。而两个语言之间的使用感受不同，才是他们真正的不同。
1.面向对象思想，对于java而言，每一个操作都是由对象来执行完成的。即所有的操作执行都是由对象这个发起的。而C++则不同，除了以面向对象作为完全的主体之外，还保留了一些较为灵活的设置，可以采用非面向对象的方式执行，这大概是由于它兼容C语言才有的特殊性质吧。
2.内存管理机制，Java的内存管理是java语言自身进行管理的，它依靠的是一个线程优先级很低的一个线程对内存进行监控，当有内存长时间处于未使用，则对其进行回收。而这一点，C++把这些留给了程序员自己。这个虽然看起来是一个极大的灵活度，却也是导致了C++特别难学的一个关键因素。
3.第三方库支持，由于java程序员的人数在过去的几年中暴烈增长，导致市场上对于java的一些库市场也十分丰富。这一点，C++则显的要寒酸一些了，由于C++的库主要都是一些底层的应用的API库，而底层设计和开发的需求相对于应用而言，要少很多。所以C++的库支持相对要少一些。
4.对程序员的灵活度，这个java是没有的，由于java主要用作应用层开发，其本身的封装性，让程序员在酣畅淋漓的编程中也无法了解到底层的一些实现机制。同时，程序员无法直接去操作编译器，连接器等等。相比较而言，C++则是方便的多，它甚至可以修改函数执行的入口，函数定义的时间以及其他更为复杂和灵活的操作。
5.执行效率，不得不说，这个可能是争论最多的一个地方了。首先，何为效率？是指代码运行的速度？还是指我们总得人力成本时间占比？单纯从一两行代码中，我们当然会说C++效率远胜java。但是，有没有考虑投入的人力成本和后期的维护成本.由于C++的高深艰涩，其维护成本更是与工程师的水平相关极大，这个成本算起来的话。或许，就不能轻易下结论了。
总结，其实两种语言都由来已久，对于程序员而言，或许对技术的偏执会让你喜欢某一种语言而诟病另外一种语言。而这种思想本身就是错误的，每一种语言都有他自身的设计哲学，如果只是因为个人使用经验不足或者对其了解程度不够深入就妄下判断，这无疑会阻碍自身的进步。
最后说一句，人生很短，来不及体会那么多，我要去学python了，慢了就赶不上了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/549be18b21d6f53227fac778b912f19d/" rel="bookmark">
			springMVC版本和jdk版本不匹配造成的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个简单的例子项目，使用springMVC的版本是3.2，jdk的版本是1.7，使用的是注解的处理器适配器和处理器映射器。spring的xml配置文件中单独配置每个handler，可以正常的使用，如果使用context:component-scan(组件扫描)的方式自动注册handler，在浏览器中输入访问url的时候，服务器报一下错误。
经过搜索查看是因为jdk的版本过高导致的，因此升级springMVC到4.2版本，可以正常使用。
java.lang.IllegalArgumentException at org.springframework.asm.ClassReader.(Unknown Source) at org.springframework.asm.ClassReader.(Unknown Source) at org.springframework.asm.ClassReader.(Unknown Source) at org.springframework.core.type.classreading.SimpleMetadataReader.(SimpleMetadataReader.java:53) at org.springframework.core.type.classreading.SimpleMetadataReaderFactory.getMetadataReader(SimpleMetadataReaderFactory.java:80) at org.springframework.core.type.classreading.CachingMetadataReaderFactory.getMetadataReader(CachingMetadataReaderFactory.java:102) at org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider.findCandidateComponents(ClassPathScanningCandidateComponentProvider.java:266) at org.springframework.context.annotation.ClassPathBeanDefinitionScanner.doScan(ClassPathBeanDefinitionScanner.java:242) at org.springframework.context.annotation.ComponentScanBeanDefinitionParser.parse(ComponentScanBeanDefinitionParser.java:84) at org.springframework.beans.factory.xml.NamespaceHandlerSupport.parse(NamespaceHandlerSupport.java:73) at org.springframework.beans.factory.xml.BeanDefinitionParserDelegate.parseCustomElement(BeanDefinitionParserDelegate.java:1438) at org.springframework.beans.factory.xml.BeanDefinitionParserDelegate.parseCustomElement(BeanDefinitionParserDelegate.java:1428) at org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader.parseBeanDefinitions(DefaultBeanDefinitionDocumentReader.java:195) at org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader.doRegisterBeanDefinitions(DefaultBeanDefinitionDocumentReader.java:139) at org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader.registerBeanDefinitions(DefaultBeanDefinitionDocumentReader.java:108) at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.registerBeanDefinitions(XmlBeanDefinitionReader.java:493) at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.doLoadBeanDefinitions(XmlBeanDefinitionReader.java:390) at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:334) at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:302) at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:174) at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:209) at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:180) at org.springframework.web.context.support.XmlWebApplicationContext.loadBeanDefinitions(XmlWebApplicationContext.java:125) at org.springframework.web.context.support.XmlWebApplicationContext.loadBeanDefinitions(XmlWebApplicationContext.java:94) at org.springframework.context.support.AbstractRefreshableApplicationContext.refreshBeanFactory(AbstractRefreshableApplicationContext.java:130) at org.springframework.context.support.AbstractApplicationContext.obtainFreshBeanFactory(AbstractApplicationContext.java:537) at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:451) at org.springframework.web.servlet.FrameworkServlet.configureAndRefreshWebApplicationContext(FrameworkServlet.java:651) at org.springframework.web.servlet.FrameworkServlet.createWebApplicationContext(FrameworkServlet.java:602) at org.springframework.web.servlet.FrameworkServlet.createWebApplicationContext(FrameworkServlet.java:665) at org.springframework.web.servlet.FrameworkServlet.initWebApplicationContext(FrameworkServlet.java:521) at org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/549be18b21d6f53227fac778b912f19d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cafdb31eebe4e7ff8853f763ab449b5/" rel="bookmark">
			洛谷 P1057 传球游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目描述
上体育课的时候，小蛮的老师经常带着同学们一起做游戏。这次，老师带着同学们一起做传球游戏。
游戏规则是这样的：n个同学站成一个圆圈，其中的一个同学手里拿着一个球，当老师吹哨子时开始传球，每个同学可以把球传给自己左右的两个同学中的一个（左右任意），当老师在此吹哨子时，传球停止，此时，拿着球没有传出去的那个同学就是败者，要给大家表演一个节目。
聪明的小蛮提出一个有趣的问题：有多少种不同的传球方法可以使得从小蛮手里开始传的球，传了m次以后，又回到小蛮手里。两种传球方法被视作不同的方法，当且仅当这两种方法中，接到球的同学按接球顺序组成的序列是不同的。比如有三个同学1号、2号、3号，并假设小蛮为1号，球传了3次回到小蛮手里的方式有1-&gt;2-&gt;3-&gt;1和1-&gt;3-&gt;2-&gt;1，共2种。
输入输出格式 输入格式：
输入文件ball.in共一行，有两个用空格隔开的整数n，m（3&lt;=n&lt;=30，1&lt;=m&lt;=30）。
输出格式：
输出文件ball.out共一行，有一个整数，表示符合题意的方法数。
输入输出样例
输入样例#1： 3 3
输出样例#1： 2
说明
40%的数据满足：3&lt;=n&lt;=30，1&lt;=m&lt;=20
100%的数据满足：3&lt;=n&lt;=30，1&lt;=m&lt;=30
2008普及组第三题
【分析】
很裸的动规（或者说是递推），然而还是想了半天才想出来（真是智障哟） f[i][j]表示第i次传球传到编号为 j 的人的手中的方案数 那么得到关系式：f[i][j]=f[i-1][j-1]+f[i-1][j+1] 初始化：f[0][1]=1 然后在递推时判个边界就好啦
【代码】
//P1057 传球游戏 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #define fo(i,j,k) for(i=j;i&lt;=k;i++) using namespace std; int f[31][31]; int main() { int n,m,i,j,k,j1,j2; scanf("%d%d",&amp;n,&amp;m); f[0][1]=1; fo(i,1,m) fo(j,1,n) { if(j+1&gt;n) j1=1; else j1=j+1; if(j-1&lt;1) j2=n; else j2=j-1; f[i][j]=f[i-1][j1]+f[i-1][j2]; } printf("%d\n",f[m][1]); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afe10be1372be4e1a620556197cc8839/" rel="bookmark">
			CCD、COMS，数字摄像头、模拟摄像头、TVL、PAL、AV、CVBS等的联系和区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、就CCD和CMOS而言： ADC的位置和数量是最大的不同。CCD曝光结束后，进行电信号转移，将每一行中每一个象元的电荷信号依行序依次传入每行的“缓冲器”中，由底端线路依次将每行的电信号引导输出至 CCD 旁的放大器进行放大，再串联 ADC 输出，此为线阵CCD；另外一种是每行均有放大电路，各行同时将捕捉的当前图像信息进行ADC，既可以同时接受一幅完整的图像信息，此为面阵CCD。 CMOS 的设计中每个像素就直接连着 ADC，电信号直接放大并转换成数字信号。 比较：CCD的特色在于充分保持信号在传输时不失真，透过每一个像素集合至单一放大器上再做统一处理，可以保持图像的完整性；CMOS的制程较简单，没有专属通道的设计，因此必须先行放大再整合各个像素的资料。由此可见，CMOS的成像过程更加容易出现坏点，使图像失真，但随着他工艺的可兼容性和功耗，使得它更加适合嵌入式的需要，同时，产生的图像失真可以通过相应的算法进行补偿，但这里需要注意的是，CMOS的成像特点决定了它非常容易受到外界环境光的影响，在使用的过程中，一定要设计出符合要求的光源。实质上，CCD和CMOS不具有深挖其内涵的需要，对使用者而言，感光度、解析度、噪点、RGB分割、CMYK分割还是RGBE分割，等这些指标体现不出来使用差异了！工作过程中，没有多大的区别，尤其在最近几年，随着CMOS工艺的不断完善，最高端的摄像头都有采用CMOS的。 2、有关分辨率的理解 分辨率：有关分辨率的概念描述是很多的，但他们都是指行象素和列象素的乘积。但由于显示器、图像等的表述对象差异，理解方式就不同。以下摘抄网络上一些精确的定义，并做整理。 显示器的分辨率：就是屏幕图像的精密度，是指显示器所能显示的点数的多少。由于屏幕上的点、线和面都是由点组成的，显示器可显示的点数越多，画面就越精细，屏幕区域内能显示的信息也越多，所以分辨率是个非常重要的性能指标之一。可以把整个图像想象成是一个大型的棋盘，而分辨率的表示方式就是所有经线和纬线交叉点的数目。 以分辨率为1024×768的屏幕来说，即每一条水平线上包含有1024个像素点，共有768条线，即扫描列数为1024列，行数为768行。分辨率不仅与显示尺寸有关，还受显像管点距、视频带宽等因素的影响。其中，它和刷新频率的关系比较密切，严格地说，只有当刷新频率为“无闪烁刷新频率”，显示器能达到最高多少分辨率，才能称这个显示器的最高分辨率为多少。 在图形环境中，高分辨率能有效地收缩屏幕图象。这就是为什么显示器选择的分辨率越大，显示屏上的图像越小的原因了。同样5×5的图标被放在了更大的棋盘格里当然会变小。 LCD液晶显示器和传统的CRT显示器，分辨率都是重要的参数之一。由于其成像原理不同，传统CRT显示器所支持的分辨率较有弹性，而LCD的像素间距已经固定，所以支持的显示模式不像CRT那么多。LCD的最佳分辨率，也叫最大分辨率，在该分辨率下，液晶显示器才能显现最佳影像（所以最好把你的LCD显示器放心的调整到最大的分辨率显示吧）。 图像的分辨率：指图像中存储的信息量，图像分辨率和图像的像素有直接的关系。一张分辨率为640 x 480的图片，那它的分辨率就达到了307，200像素，也就是我们常说的30万像素，而一张分辨率为1600 x 1200的图片，它的像素就是200万。这样，我们就知道，分辨率的两个数字表示的是图片在长和宽上占的点数的单位。一张数码图片的长宽比通常是4：3。 3、数字摄像头和模拟摄像头 这两个摄像头的区别困扰我很久，因为我总是把这两种摄像头的区别归因于所选的感光元件的差异，其实是大错特错。 区别1：输出。其实不管你选择CCD还是CMOS，只要你输出的信号是数字的，就称为数字摄像头；输出的是标准模拟信号的，就是模拟摄像头，或多称为模拟摄像机。 区别2：接口。数字摄像头有USB接口（聊天用的），1394火线（高分辨率），千兆网接口（网络摄像头）；模拟摄像头（机）多采用AV视频端子（信号线＋地线）或S-VIDEO端子（俗称莲花头），输出标准电视信号(PAL或NTSC)。 区别3：分辨率。这个区别是很显著的。模拟摄像头的感光器件，其象素指标一般都维持在752（H）×582（V）左右这个水平，像素数也就是41W左右。数字摄像头的分辨率（这里说分辨率指的都是感光器件而不是采集到的图像的）有市面上常看到的百万级的像素数。但这并不能说数字摄像头的成像分辨率就比模拟摄像头的高，原因在于模拟摄像头输出的是模拟视频信号，它输出的模拟信号直接输入至电视或监视器，其感光器件的分辨率与电视信号的扫描线数呈一定的换算关系，图象的显示介质已经确定，因此模拟摄像机没有必要采用高分辨率的感光器件，换句话说，模拟摄像头的感光器件分辨率不是不能做高，而是没必要做高。 4、象元及其相关 象元其实就是感光器件上分布的一个个小感光点。它与显示在显示设备或图像上的象素点是一一对应的。象元的尺寸当然是越大约好，因为象元的尺寸越大，感受光线的能力也就越强，单一象素点反映出的色彩也就越准确。但这又产生了一系列的矛盾，象元尺寸越大，单位面积的象元点个数就会随之减少，整体显示出来的像素数就会变小，更加不利于高分辨率图像的显示；然而增大象元点面积的同时增加感光元件的尺寸的话，又会使感光器件的成品率下降，造价上升。
下面进行个人总结：
为什么市面上会有模拟相机和数字相机呢？主要的原因是输出的数据大小。这也是为什么市面上的模拟相机都是应用在监控和航模航拍相机上，这是因为其文件一般是Mpg（其是编码为MPEG-1的视频的一种扩展名，最大压缩比可以达到200:1，其是比AVI格式的还小数据量），这种视频的数据量很小，利于监控摄像头的长时间录像、航模的图传。 对于批判他们的分辨率分别是TVL 、像素。
分辨率里的TVL的解释？
TVL的意思是“电视行",用来衡量“分解被拍摄景物细节”的能力； 像素: 就是各种颜色的一个一个小点，像素越多，图可以放得越大越清晰。 为什么会有这两者分类？是因为他们的图像成像原理是不同的。
其中的模拟相机的图像是由线构成的，其成像时是以行为单位统一成像的，然后组成一幅图像。如果TVL图像仔细看的话，会发现上面有一条一条的线。其跟电视的的显示原理一样，是线扫描成像的，故其使用线来进行衡量其清晰度，因为线越多则越高清。其与像素分辨率可以转换，不过转化出来的像素值大小是没有意义的，不能说像素值越大图像越大，应当看线数，线数越大越清晰。
从上面可以看出模拟相机的像素值一般就只有几十万像素，其不是做不高，而是没必要，因为现在的线数可以满足大部分的要求，记住模拟相机追求的是数据量小并且有清晰。1080P指的是逐行扫描其是1080线，540I是隔行扫描就是1080线。
数字相机的图像是有像素构成的，以一个个像素为单位单独成像，然后构成一幅图像。其中相机分辨率以1080P 、I等分的话，其是模拟相机的说法。
不过现在的有些相机是模式混合的，采集的是数字信号，然后转换为模拟信号以线数输出。
3.AV与CVbs、音频的关系和s-video信号联系和区别。
其中AV信号就是包含有video、audio，如果把其分开了就是一般有三条线，分别为黄色--视频、红白色--R L音频。其中的黄色线的视频我们叫做cvbs信号，其是不包含有音频的信号。这就是为什么单头的模拟相机都只有一个黄色的线和黑色的电源线出来，单独的线我们叫做cvbs线，如果三个一起的我们就叫做av线，其中cvbs输出的是模拟视频信号，其中hd-sdi输出的高清数字视频信号，其要使用能播放sdi视频的显示器才能显示。
还有一个就是s-video也叫s端子其是只有一个video的没有音频的，一般我们使用是使用在投影仪、液晶电视里，其与av公用音频输入端子，为什么起不使用cvbs端子呢？是因为其要把视频里的亮度和色度分离传输，避免了混合视频信号传输是亮度与色度之间的干扰。其如下图：
4.PAL制式与NTSC制式直接的关系和联系。
PAL与NTSC都是视频制式--字面上的意思就是视频的制作方式，指其制作的分辨率、帧率等，从中可以看出其与上面的AV、S等端子没有关系。其中PAL的是（H x V）720*576，而NTSC的是760*480. 其两者是部分模拟信号还是数字信号的。由于这两者的分辨率是固定的，所以当随着高清电视液晶等的诞生，这里也开始慢慢改变制式了，例如1080p的使用HDTV制式，当时其也向下兼容PAL、NTSC制式的视频。
疑问：现在的航拍摄像头都是模拟的，但是其判断高清与否的标准是线TVL,其下面给出的PAL就不是标准的，不知道怎么理解PAL？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/731b2a52afe87e2adc6951c6fe68aea8/" rel="bookmark">
			ajax设置默认值 ajaxSetup
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jQuery ajaxSetup() 方法 $(function(){ // 设置jQuery Ajax全局的参数 $.ajaxSetup({ type: "POST", async: false, cache: false, dataType: "JSON", error: function(jqXHR, textStatus, errorThrown){ switch (jqXHR.status){ case(500): alert("服务器系统内部错误"); break; case(401): alert("未登录"); break; case(403): alert("无权限执行此操作"); break; case(408): alert("请求超时"); break; default: alert("未知错误"); } }, success: function(data){ alert("操作成功"); } }); }); 当设置该属性后，在其他jQuery没有设置的ajax中，默认设用该设置。
----------------------------------------------------------------------------------------------------
Cache缓存问题
由于IE的缓存处理机制问题，每次通过XMLHttpRequest访问动态页面返回的总是首次访问的内容，解决方法有：
1. 客户端通过添加随机字符串解决。如：
var url = 'http://url/';
url += '?temp=' + new Date().getTime();
url += '?temp=' + Math.random();
2. 在HTTP headers禁止缓存。如：
HTTP:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/731b2a52afe87e2adc6951c6fe68aea8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bd6c4b93927261987a96fde332c2c9d/" rel="bookmark">
			Error: need EHLO and AUTH first
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用 System.Net.Mail组建发送邮件的时候出现了"命令顺序不正确。 服务器响应为: Error: need EHLO and AUTH first !"异常
解决方法如下:
1.如果使用了qq邮箱请使用授权码(不要用qq邮箱登录密码)
2.启用smtp.UseDefaultCredentials = true;
3.启用smtp.EnableSsl = true;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69c9cfe0c114be6fd7d6fff6f9c4dd46/" rel="bookmark">
			Hyper-V双网卡的正确设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、成功安装Hyper-V Manager后，打开Virtual Network Manager，把已经安装设置好的虚拟网卡移除（如果没有安装，可以忽略此步骤）
2、打开网络连接，你应该看到你主板上安装的两块网卡（如有虚拟网卡存在，请操作第一步），以下为两块网卡的设置：
网卡1：通过DHCP获得IP，或者指定IP
网卡2：打开该网卡属性，取消所有项目的勾，即不勾选任何服务项，包括TCP/IPv6和TCP/IPv4
3、确定以上步骤后，网卡2应该不含有任何IP信息，双击查看，应该是空白的。这时，回到Hyper-V Manager下的Virtual Network Manager，手动添加网卡2（一定要是刚刚取消所有服务项的那块网卡）作为External的虚拟网卡。
4、确定后，关闭所有正在运行的虚拟机。分别打开各个虚拟机的设置，重新为其添加网卡。保存后启动虚拟机。
5、再次Ping网关，没有出现packet loss了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac367f6c52826da5b20a6e1c58e95efb/" rel="bookmark">
			Hibernate中的Session详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Session缓存 session缓存是由一系列的Java集合构成的。当一个对象被加入到Session缓存中，这个对象的引用就加入到了java的集合中，以后即使应用程序中的引用变量不再引用该对象，只要Session缓存不被清空，这个对象一直处于生命周期中。
Session缓存的作用：
1）减少访问数据库的频率。
2）保证缓存中的对象与数据库中的相关记录保持同步。
Session清理缓存的时机：
1）当调用Transaction的commit()方法时，commit()方法先清理缓存（前提是FlushMode.COMMIT/AUTO），然后再向数据库提交事务。
2）当应用程序调用Session的find()或者iterate()时，如果缓存中的持久化对象的属性发生了变化，就会先清理缓存，以保证查询结果能反映持久化对象的最新状态。
3）当应用程序显示调用Session的flush()方法的时候。
Session清理模式执行清理缓存操作的时间点：
Session接口 Session接口是Hibernate向应用程序提供的操纵数据库的最主要的接口，它提供了基本的保存，更新，删除和查询的方法。
1.save()： 把一个临时对象加入到缓存中，是它变成持久化对象
--&gt;选用映射文件指定的主键生成器为持久化对象分配唯一的OID
--&gt;计划一条insert语句，把参数对象当前的属性值组装到insert语句中，但是save()方法并不立即执行SQL insert语句，只有当Session清理缓存时候才会执行。
--&gt;如果在save()方法之后，又修改了持久化对象的属性，会使得Session在清理缓存的时候额外执行SQL update语句。
注意：save()方法是用来持久化一个临时对象的！
如果将一个持久化对象传给save()方法将不会执行任何操作，多余的步骤
如果将一个游离态对象传给save()方法，session会将它当作临时对象来处理，再次向数据库中插入一条记录，不符合业务需求！
2.update()：把Customer对象重新加入到Session缓存中，使之变为持久化对象。
---&gt;计划一条update语句，只有在清理缓存的时候才会执行，并且在执行的时候才会把参数对象中的属性值组装到update语句中。
注意：update()是将一个游离对象转变为持久化对象的。
只要通过update()方法使游离对象被一个session关联，即使没有修改参数对象的任何属性，Session在清理缓存的时候也会执行由update方法计划的Update语句。
3.saveOrUpdate()：同时包含了save()与update()方法的功能，如果传入的参数是临时对象，调用save方法，如果参入参数是游离对象，调用update()方法，如果传入的是持久化对象，直接返回。
4.load()/get(): 都会根据给定的OID从数据库中加载一个持久化对象，区别在于，当数据库中不存在与OID对应的记录时，load()方法会抛出ObjectNotFoundException异常，而get()方法返回null.
5.delete()：用于从数据库中删除与参数对象对应的记录，如果传入的参数是持久化对象，Session就计划执行一个delete语句，如果传入的参数是游离对象，先使游离对象被Session关联，使它变为持久化对象，然后计划一个delete语句，在清理缓存的时候执行。
6.evict()：从缓存中清除参数指定的持久化对象。
适用场合：不希望Session继续按照该对象的状态改变来同步更新数据库。
在批量更新或批量删除的场合，当更新或者删除一个对象后，及时释放该对象占用的内存。当然批量操作优先考虑JDBC.
7.clear()：清空缓存中所有持久化对象。
下一篇说一下Hibernate的get和load方法的区别~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/916b1f0334ecbb4dec9bb4d6ef2ea2dc/" rel="bookmark">
			DOM节点操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、节点名称及类型 节点类型nodeTypenodeNamenodeValue含义ELEMENT_NODE1标签名（eg:DIV）null元素节点ATTRIBUTE_NODE2特性名（eg:class）特性值特性节点TEXT_NODE3#text文本的内容文本节点CDATA_SECTION_NODE4#cdata-sectionCDATA文本的内容CDATA区段节点ENTITY_REFERENCE_NODE5实体引用名称null实体引用节点ENTITY_NODE6实体名称null实体节点PROCESSING_INSTRUCTION_NODE7target节点的内容处理指令节点COMMENT_NODE8#comment注释的内容注释节点DOCUMENT_NODE9#documentnullHTML文档节点（即document）DOCUMENT_TYPE_NODE10DTD声明内容null文档类型（DTD声明）节点DOCUMENT_FRAGMENT_NODE11document 片段null文档片段（?）节点NOTATION_NODE12符号名称null? 二、节点相关属性 nodeType：显示节点的类型 nodeName：显示节点的名称 nodeValue：显示节点的值 attributes：获取一个属性节点 firstChild：表示某一节点的第一个节点 lastChild：表示某一节点的最后一个子节点 childNodes：表示所在节点的所有子节点 parentNode：表示所在节点的父节点 nextSibling：紧挨着当前节点的下一个节点 previousSibling：紧挨着当前节点的上一个节点 ownerDocument：返回拥有该元素的文档元素（document）
三、节点相关方法 方法描述createAttribute (name)用给定名称name创建特性节点createCDATASection (text)用包含文本text的文本子节点创建一个CDATA SectioncreateComment(text)创建包含文本text的注释节点createDocumentFragment()创建文档碎片节点createElement (tagname)创建标签名为tagname的元素createEntityReference(name)创建给定名称的实体引用节点createProcessingInstruction(target, data)创建包含给定target和data的PI节点createTextNode(text)创建包含文本text的文本节点appendChild(node)将node添加到childNodes的末尾insertBefore (newnode,refnode)在childNodes中的refnode之前插入newnoderemoveChild(node)从childNodes中删除nodereplaceChild (newnode,oldnode)将childNodes中的oldnode替换成newnodehasChildNodes()当childNodes包含一个或多个节点时，返回真cloneNodd(boolean)克隆节点，参数为真时同时克隆子节点 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1f19ca4f2a5fba80466101858a13427/" rel="bookmark">
			第一章 银联8583报文解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1报文格式定义 POS终端上送POS中心的消息报文结构包括TPDU、报文头和应用数据三部分： —— TPDU说明：长度为10个字节, 压缩时用BCD码表示为5个字节长度的数值。 —— 报文头说明：总长度为12字节，压缩时用BCD码表示为6个字节长度的数值。 在POS上送的请求/通知报文中，该数值由POS终端应用程序在打包上送时根据POS终端参数和当前状态填入应用类别、软件总版本号、终端状态和软件分版本号（具体指各厂商的程序版本号），用于POS中心根据数值进行相应的处理。 在POS中心返回的应答报文中，由POS中心填入处理要求，其他域保持原值返回，POS将根据收到报文头中的处理要求进行相应处理。
2 看懂8583报文需要知道的概念 BCD码：用4位二进制数来表示1位十进制数中的0~9这10个数码。举个列子，’0x03 0x02’的BCD码表示为0X32，将前一个的低四位转移到后一个的高四位，具体实现会单独开一章。这里知道如何用即可。
3实例报文解析 这里举个签到报文的例子。原始报文: 00 3B 60 00 06 00 00 60 22 00 00 00 00 08 00 00 20 00 00 00 C0 00 12 00 12 47 35 38 44 30 31 31 31 35 38 38 37 35 38 44 30 34 38 31 36 35 35 35 35 00 11 00 00 00 01 00 30 00 02 30 31 拿到原始报文后我们来拆分一下。根据上面的报文格式定义，我们先拆分出来TPDU和报文头：TPDU占5个字节，报文头占6个字节，还有报文的前两个字节是报文长度，那么： 报文长度：00 3B=59个字节 TPDU：60 00 06 00 00 Header：60 22 00 00 00 00
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1f19ca4f2a5fba80466101858a13427/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad23df8b287fe55d60cb7805a8ba3ba5/" rel="bookmark">
			Hprof
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载地址：http://geek.csdn.net/news/detail/90509 一、开发者的自测利器-Hprof命令 1. 示例演示
例子程序：
/** * PROJECT_NAME: test * DATE: 16/7/22 * CREATE BY: chao.cheng **/ public class HProfTest { public void slowMethod() { try { Thread.sleep(1000); } catch (Exception e) { e.printStackTrace(); } } public void slowerMethod() { try { Thread.sleep(10000); } catch (Exception e) { e.printStackTrace(); } } public static void main(String[] args) { HProfTest test = new HProfTest(); test.slowerMethod(); test.slowMethod(); } } 注：这是一段测试代码通过sleep方法进行延时，在程序运行过程中很慢，我想知道到底是哪段程序影响的整体性能呢？
我在这个java程序中，加了如下运行参数：
-agentlib:hprof=cpu=times,interval=10 /* times：java函数的执行时间 hprof=cpu是针对cpu统计时间 interval=10 采样10次 */ 再次运行这段程序显示如下图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad23df8b287fe55d60cb7805a8ba3ba5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cc76ea89df783c7a207b1012653c579/" rel="bookmark">
			iOS笔记监听键盘状态 获取键盘高度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在viewdidload注册消息, 调用 registerForKeyboardNotifications 方法
- (void) registerForKeyboardNotifications
{
[[NSNotificationCenterdefaultCenter]addObserver:selfselector:@selector(keyboardWasShown:)name:UIKeyboardDidShowNotificationobject:nil];
[[NSNotificationCenterdefaultCenter] addObserver:selfselector:@selector(keyboardWasHidden:)name:UIKeyboardDidHideNotificationobject:nil];
}
在键盘弹出时获取键盘高度 加个动画改变视图位置
- (void) keyboardWasShown:(NSNotification *) notif
{
NSDictionary *info = [notifuserInfo];
NSValue *value = [infoobjectForKey:UIKeyboardFrameEndUserInfoKey];
CGSize keyboardSize = [valueCGRectValue].size;
[UIViewbeginAnimations:@"xxx"context:nil];
[UIViewsetAnimationDuration:0.5];
self.tableView.frame =CGRectMake(0,0,W(self.view),H(self.view) - keyboardSize.height);
[UIViewcommitAnimations];
NSLog(@"keyBoard:%f", keyboardSize.height); //216
///keyboardWasShown = YES;
}
在键隐藏时时获取键盘高度
- (void) keyboardWasHidden:(NSNotification *) notif
{
NSDictionary *info = [notifuserInfo];
NSValue *value = [infoobjectForKey:UIKeyboardFrameEndUserInfoKey];
CGSize keyboardSize = [valueCGRectValue].size;
NSLog(@"keyboardWasHidden keyBoard:%f", keyboardSize.height);
// keyboardWasShown = NO;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cc76ea89df783c7a207b1012653c579/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29ed7b72468ec1f0e481623357fda467/" rel="bookmark">
			windows虚拟内存管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内存管理是操作系统非常重要的部分，处理器每一次的升级都会给内存管理方式带来巨大的变化，向早期的8086cpu的分段式管理，到后来的80x86 系列的32位cpu推出的保护模式和段页式管理。在应用程序中我们无时不刻不在和内存打交道，我们总在不经意间的进行堆内存和栈内存的分配释放，所以内存是我们进行程序设计必不可少的部分。
CPU的内存管理方式 段寄存器怎么消失了？ 在学习8086汇编语言时经常与寄存器打交道，其中8086CPU采用的内存管理方式为分段管理的方式，寻址时采用：短地址 * 16 + 偏移地址的方式，其中有几大段寄存器比如：CS、DS、SS、ES等等，每个段的偏移地址最大为64K，这样总共能寻址到2M的内存。但是到32位CPU之后偏移地址变成了32位这样每个段就可以有4GB的内存空间，这个空间已经足够大了，这个时候在编写相应的汇编程序时我们发现没有段寄存器的身影了，是不是在32位中已经没有段寄存器了呢，答案是否定了，32位CPU中不仅有段寄存器而且它们的作用比以前更大了。 在32位CPU中段寄存器不再作为段首地址，而是作为段选择子，CPU为了管理内存，将某些连续的地址内存作为一页，利用一个数据结构来说明这页的属性，比如是否可读写，大小，起始地址等等，这个数据结构叫做段描述符，而多个段描述符则组成了一个段描述符表，而段寄存器如今是用来找到对应的段描述符的，叫做段选择子。段寄存器仍然是16位其中高13位表示段描述符表的索引，第二位是区分LDT(局部描述符表)和GDT（全局描述符表），全局描述符表是系统级的而LDT是每个进程所独有的，如果第二位表示的是LDT，那么首先要从GDT中查询到LDT所在位置，然后才根据索引找到对应的内存地址，所以现在寻址采用的是通过段选择子查表的方式得到一个32位的内存地址。由于这些表都是由系统维护，并且不允许用户访问及修改所以在普通应用程序中没有必要也不能使用段寄存器。通过上面的说明，我们可以推导出来32位机器最多可以支持2^(13 + 1 + 32) = 64T内存。
段页式管理 通过查表方式得到的32位内存地址是否就是真实的物理内存的地址呢，这个也是不一定的，这个还要看系统是否开启了段页式管理。如果没有则这个就是真实的物理地址，如果开启了段页式管理那么这个只是一个线性地址，还需要通过页表来寻址到真实的物理内存。 32位CPU专门新赠了一个CR3寄存器用来完成分页式管理，通过CR3寄存器可以寻址到页目录表，然后再将32位线性地址的高10位作为页目录表的索引，通过这个索引可以找到相应的页表，再将中间10为作为页表的索引，通过这个索引可以寻址到对应物理内存的起始地址，最后通过这个其实地址和最后低12位的偏移地址找到对应真实内存。下面是这个过程的一个示例图： 为什么要使用分页式管理，直接让那个32位线性地址对应真实的内存不可以吗。当然可以，但是分页式管理也有它自身的优点： 1. 可以实现页面的保护：系统通过设置相关属性信息来指定特权级别和其他状态 2. 可以实现物理内存的共享：从上面的图中可以看出，不同的线性地址是可以映射到相同的物理内存上的，只需要更改页表中对应的物理地址就可以实现不同的线性地址对应相同的物理内存实现内存共享。 3. 可以方便的实现虚拟内存的支持：在系统中有一个pagefile.sys的交互页面文件，这个是系统用来进行内存页面与磁盘进行交互，以应对内存不够的情况。系统为每个内存页维护了一个值，这个值表示该页面多久未被访问，当页面被访问这个值被清零，否则每过一段时间会累加一次。当这个值到达某个阈值时，系统将页面中的内容放入磁盘中，将这块内存空余出来以便保存其他数据，同时将之前的线性地址做一个标记，表名这个线性地址没有对应到具体的内存中，当程序需要再次访问这个线性地址所对应的内存时系统会再次将磁盘中的数据写入到内存中。虽说这样做相当于扩大了物理内存，但是磁盘相对于内存来说是一个慢速设备，在内存和磁盘间进行数据交换总是会耗费大量的时间，这样会拖慢程序运行，而采用SSD硬盘会显著提高系统运行效率，就在于SSD提高了与内存进行数据交换的效率。如果想显著提高效率，最好的办法是加内存毕竟在内存和硬盘间倒换数据是要话费时间的。
保护模式 在以前的16位CPU中采用的多是实模式，程序中使用的地址都是真实的物理地址，这样如果内存分配不合理，会造成一个程序将另外一个程序所在的内存覆盖这样对另外一个程序将造成严重影响，但是在32位保护模式下，不再会产生这种问题，保护模式将每个进程的地址空间隔离开来，还记得上面的LDT吗，在不同的程序中即使采用的是相同的地址，也会被LDT映射到不同的线性地址上。 保护模式主要体现在这样几个方面： 1.同一进程中，使用4个不同访问级别的内存段，对每个页面的访问属性做了相应的规定，防止错误访问的情况，同时为提供了4中不同代码特权，0特权的代码可以访问任意级别的内存，1特权能任意访问1…3级内存,但不能访问0级内存,依次类推。通常这些特权级别叫做ring0-ring3。 2. 对于不同的进程，将他们所用到的内存等资源隔离开来，一个进程的执行不会影响到另一个进程。
windows系统的内存管理 windows内存管理器 我们将系统中实际映射到具体的实际内存上的页面称为工作集。当进程想访问多余实际物理内存的内存时，系统会启用虚拟内存管理机制（工作集管理），将那些长时间未访问的物理页面复制到硬盘缓冲文件上，并释放这些物理页面，映射到虚拟空间的其它页面上；系统的内存管理器主要由下面的几个部分组成： 1. 工作集管理器(优先级16)：这个主要负责记录每个页面的年龄，也就有多久未被访问，当页面被访问这个年龄被清零，否则每过一段时间就进行累加1的操作。 2. 进程/栈交换器(优先级23)：主要用于在进行进程或者线程切换时保存寄存器中的相关数据用以保存相关环境。 3. 已修改页面写出器(优先级17)：当内存映射的内容发生改变时将这个改变及时的写入到硬盘中，防止由于程序意外终止而造成数据丢失 4. 映射页面写出器(优先级17)：当页面的年龄达到一定的阈值时，将页面内容写入到硬盘中 5. 解引用段线程(优先级18)：释放以写入到硬盘中的空闲页面 6. 零页面线程(优先级0)：将空闲页面清零，以便程序下次使用，这个线程保证了新提交的页面都是干净的零页面
进程虚拟地址空间的布局 windows为每个进程提供了平坦的4GB的线性地址空间，这个地址空间被分为用户分区和内核分区，他们各占2GB大小，其中内核分区在高地址位，用户分区在低地址位，下面是内存分布的一个表格：
分区地址范围NULL指针区0x00000000-0x0000FFFF用户分区0x00010000-0x7FFEFFFF64K禁入区0x7FFF0000-0x7FFFFFFF内核分区0x80000000-0xFFFFFFFF 从上面的图中可以看出，系统的内核分区是2GB而用户可用的分区并没有2GB，在用户分区的头64K和尾部的64K不允许用户使用。 另外我们可以压缩内核分区的大小，以便使用户分区占更多的内存，这就是/3GB方式，下面是这种方式的具体内存分布：
分区地址范围NULL指针区0x00000000-0x0000FFFF用户分区0x00010000-0xBFFEFFFF64K禁入区0xBFFF0000-0xBFFFFFFF内核分区0xC0000000-0xFFFFFFFF windows虚拟内存管理函数 VirtualAlloc VirtualAlloc函数主要用于提交或者保留一段虚拟地址空间，通过该函数提交的页面是经过0页面线程清理的干净的页面。
LPVOID VirtualAlloc( LPVOID lpAddress, //虚拟内存的地址 DWORD dwSize, //虚拟内存大小 DWORD flAllocationType,//要对这块的虚拟内存做何种操作 DWORD flProtect //虚拟内存的保护属性 ); 我们可以指定第一个参数来告知系统，我们希望操作哪块内存，如果这个地址对应的内存已经被保留了那么将向下偏移至64K的整数倍，如果这块内存已经被提交，那么地址将向下偏移至4K的整数倍，也就是说保留页面的最小粒度是64K，而提交的最小粒度是一页4K。 第三个参数是指定分配的类型，主要有以下几个值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29ed7b72468ec1f0e481623357fda467/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d01bd999fdf7486bfb8fd2539ff92eb/" rel="bookmark">
			mac下安装OCLint、xctool、及配置环境变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先配置环境变量，要先创建一个这个文件 touch .bash_profile
然后vi进行编辑
输入需要配置的内容
更新配置的环境变量 source .bash_profile
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1809c0dfdb7213497c1bce0a3e8bf141/" rel="bookmark">
			Android使用WebView加载有声音或视频的网页时，关闭webView时，声音没有关闭的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 笔者最近使用AS开发Android移动应用app，其实有一个功能是使用Android系统自带的WebView控件加载网页代码来播放视频。
说两点容易出现的情况。
1、加载网页代码 WebView默认是不支持JavaScript 、IFrame或者是任何的框架语法的。通过设webview.getSettings().setJavaScriptEnabled(true); 就可以打开JavaScript. webView.requestFocus()如果不设置的话，会出现不能弹出软键盘或者网页代码加载不出来等问题。
2、退出WebView,声音未停止
webView顺利加载带声音的视频，在包括WebView的Activity被Finish之后。声音或者视频仍然在后台播放，声音也不停止。再一次打开Activity之后，会重复的播放声音或者视频。
网上说：webView.onPause(); // 暂停网页中正在播放的视频 这个方法对视频是有效的，但是对于声音就无能为力。 后来经过多次测试，发现一个规律，就是在finish之前，Activity被重新载的页面地址是啥，下次打开之后，还显示什么页面（因为笔者使用：web.loadData("about:blank");方法测试时，发现下次打开时，显示的是空白页面，开始以为是页面没有加载成功，后来无意中灵机一动，会不会是关闭之前加载的页面，下次打开时还是加载哪个呢？）。后来测试了一下，关闭之前加载了一下百度页面，发现下次打开时，还真是显示的百度百度页面。那就将错就错，直接重新加载当前页面地址，不就ok了吗。一试，还真可以。声音或者视频停止了，下次打开，页面也能够正常加载了。真是得来全不废功夫。
最后，解决方案：
一句话解决问题。
@Override protected void onPause () { WebView.reload (); super.onPause (); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/225e6c0eacffe8ef203f2cb5766faf44/" rel="bookmark">
			JDK, JRE和JVM的区别与联系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JDK: java development kit, java开发工具包，针对开发者，里面主要包含了jre, jvm, jdk源码包，以及bin文件夹下用于开发，编译运行的一些指令器。
JRE: java runtime environment, java运行时环境，针对java用户，也就是拥有可运行的.class文件包（jar或者war）的用户。里面主要包含了jvm和java运行时基本类库（rt.jar）。rt.jar可以简单粗暴地理解为：它就是java源码编译成的jar包（解压出来看一下），用eclipse开发时，当你ctrl点击发现不能跳转到源文件时，需要把rt.jar对应的源码包加进来，而这里的源码包正是jdk文件夹下的src.zip。如下图：
JVM: java虚拟机，将它理解为可以识别class文件的一个小型系统，class文件直接和它交互，所以它让class文件和用户真实的操作系统隔离，屏蔽了用户系统的差异性，给人一种感觉就是java出道的最大特点：一次编译，处处运行（跨平台）。而这也正是java跨平台引起过争议的一点，曾经一些人觉得java跨平台是个幌子，因为前提是用户机子上必须安装了JVM（准确地说是JRE）。
JDK和JRE区别：去bin文件夹下你会发现，JDK有javac.exe而JRE里面没有，众所周知javac指令是用来将java文件编译成class文件的，这是你开发去做的事，用户是不会去做的。JDK还有jar.exe, javadoc.exe等等用于开发的可执行指令文件。这也证实了一个是开发环境，一个是运行环境。
JRE和JVM区别：有些人觉得，JVM就可以执行class了，其实不然，JVM执行.class还需要JRE下的lib类库的支持，尤其是rt.jar。
抽象问题具体化理解：
JDK包含了JRE，JRE包含了JVM（简单粗暴式理解）。
你现在想用一段代码对全世界用计算机的人们说一句：hello world, 你首先想到可以将这两个单词写在每个用户计算机txt的里面，这太麻烦了，有些用户不是windows系统，他没有txt文件，你不知道怎么写，需要的是代码实现。然后你程序猿朋友在txt里面写了一个main，main里面写一句system.out.println("hello world"); 私下里 编译之后给到了你，说它很神奇，把它运行起来就能达到目的，你查了一下有个JVM的东西能运行这个文件，但是失败了，原因是JVM没那么智能，它不知道里面system, out, println这三个单词是用来做什么的，朋友告诉你要安装JRE，你安装后惊奇发现成功了。后来你逮谁就找谁实验，你只需要把JRE和你朋友给你的这个文件放上去，就能跟他说hello world。你按捺不住内心的崇拜之情，对朋友说：大牛，带我飞吧。朋友微微一笑，抛给你一个JDK，说拿去玩吧这就是武功秘籍。从此你踏上了java开发的不归路。
参考：http://www.zhihu.com/question/20317448
http://playkid.blog.163.com/blog/static/56287260201372113842153/
http://docs.oracle.com/javase/7/docs/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57b7bd9798da5c956f9af2160cdc4172/" rel="bookmark">
			Java基础之（八）方法覆盖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		子类从父类中继承方法，有时子类需要修改父类中定义的方法的实现，这称作方法覆盖。比如下面这个例子：
class Person { String name; int age; void introduce(){ System.out.println("我的姓名是：" + name+",我的年龄是"+ age); } } class Student extends Person { String address; void introduce(){ System.out.println("我的姓名是"+ name + ",我的年龄是"+ age); System.out.println("我的家在"+ address); } } class Test{ public static void main(String args[]){ Student s = new Student(); s.name = "张三"; s.age = 20; s.address = "北京"; s.introduce(); } } introduce()方法在Person类中定义，在Student类中修改。并且这两个方法定义（返回值类型、方法名、参数列表）相同，只不过方法体不一样，这样的两个方法的关系我们称之为方法覆盖，有的书上也称之为方法重写/复写。
1.语法特征 在具有父子关系的两个类中父类和子类中各有一个函数，这两个函数的定义完全相同 输出结果： 我的姓名是张三，我的年龄是20 我的家在北京 2.super调用成员方法 在上面的代码中我们能够发现重复代码:
System.out.println("我的姓名是"+ name + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57b7bd9798da5c956f9af2160cdc4172/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b33c7807042184003cfc95c9c3f40a24/" rel="bookmark">
			不能修改“System Roots”钥匙串 要更改根证书是否会被信任，请在“钥匙串访问”中打开它，然后修改它的信任设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解决方法：
1、点击“钥匙串访问”页面左侧“种类”中的“登陆”或“login”，然后把要安装的 根证书 拖进去，就行啦。
添加钥匙串 最后拖入要添加的证书 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a580dc535a3252e8d005f50044ba8b8f/" rel="bookmark">
			Mockito浅谈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mockito浅谈 Mockito浅谈Mockito简介Mock的好处是什么Mockito使用示例 模拟对象模拟方法调用的返回值模拟方法调用抛出异常模拟调用方法时的参数匹配模拟方法调用次数校验行为模拟方法调用Stubbing参数匹配校验方法调用次数模拟无返回方法抛出异常校验方法调用顺序校验方法是否从未调用快速创建Mock对象自定义返回不同结果对返回结果进行拦截Mock函数操作暗中调用真实对象改变默认返回值捕获函数的参数值部分Mock重置Mock序列化检查超时Mock详情 Mockito简介 什么是mock？ 在软件开发的世界之外, “mock”一词是指模仿或者效仿。 因此可以将“mock”理解为一个替身，替代者. 在软件开发中提及”mock”，通常理解为模拟对象或者Fake。
为什么需要Mock? Mock是为了解决units之间由于耦合而难于被测试的问题。所以mock object是unit test的一部分。
Mock的好处是什么? 提前创建测试，TDD（测试驱动开发） 这是个最大的好处吧。如果你创建了一个Mock那么你就可以在service接口创建之前写Service Tests了，这样你就能在开发过程中把测试添加到你的自动化测试环境中了。换句话说，模拟使你能够使用测试驱动开发。 团队可以并行工作 这类似于上面的那点；为不存在的代码创建测试。但前面讲的是开发人员编写测试程序，这里说的是测试团队来创建。当还没有任何东西要测的时候测试团队如何来创建测试呢？模拟并针对模拟测试！这意味着当service借口需要测试时，实际上QA团队已经有了一套完整的测试组件；没有出现一个团队等待另一个团队完成的情况。这使得模拟的效益型尤为突出了。
你可以创建一个验证或者演示程序。 由于Mocks非常高效，Mocks可以用来创建一个概念证明，作为一个示意图，或者作为一个你正考虑构建项目的演示程序。这为你决定项目接下来是否要进行提供了有力的基础，但最重要的还是提供了实际的设计决策。 为无法访问的资源编写测试
这个好处不属于实际效益的一种，而是作为一个必要时的“救生圈”。有没有遇到这样的情况？当你想要测试一个service接口，但service需要经过防火墙访问，防火墙不能为你打开或者你需要认证才能访问。遇到这样情况时，你可以在你能访问的地方使用MockService替代，这就是一个“救生圈”功能。 Mock 可以交给用户 在有些情况下，某种原因你需要允许一些外部来源访问你的测试系统，像合作伙伴或者客户。这些原因导致别人也可以访问你的敏感信息，而你或许只是想允许访问部分测试环境。在这种情况下，如何向合作伙伴或者客户提供一个测试系统来开发或者做测试呢？最简单的就是提供一个mock，无论是来自于你的网络或者客户的网络。soapUI mock非常容易配置，他可以运行在soapUI或者作为一个war包发布到你的java服务器里面。
隔离系统 有时，你希望在没有系统其他部分的影响下测试系统单独的一部分。由于其他系统部分会给测试数据造成干扰，影响根据数据收集得到的测试结论。使用mock你可以移除掉除了需要测试部分的系统依赖的模拟。当隔离这些mocks后，mocks就变得非常简单可靠，快速可预见。这为你提供了一个移除了随机行为，有重复模式并且可以监控特殊系统的测试环境。 Mockito使用示例 模拟对象 // 模拟LinkedList 的一个对象 LinkedList mockedList = mock(LinkedList.class); // 此时调用get方法，会返回null，因为还没有对方法调用的返回值做模拟 System.out.println(mockedList.get(0)); 模拟方法调用的返回值 // 模拟获取第一个元素时，返回字符串first。 给特定的方法调用返回固定值在官方说法中称为stub。 when(mockedList.get(0)).thenReturn("first"); // 此时打印输出first System.out.println(mockedList.get(0)); 模拟方法调用抛出异常 // 模拟获取第二个元素时，抛出RuntimeException when(mockedList.get(1)).thenThrow(new RuntimeException()); // 此时将会抛出RuntimeException System.out.println(mockedList.get(1)); 如果一个函数没有返回值类型，那么可以使用此方法模拟异常抛出
doThrow(new RuntimeException("clear exception")).when(mockedList).clear(); mockedList.clear(); 模拟调用方法时的参数匹配 // anyInt()匹配任何int参数，这意味着参数为任意值，其返回值均是element when(mockedList.get(anyInt())).thenReturn("element"); // 此时打印是element System.out.println(mockedList.get(999)); 模拟方法调用次数 // 调用add一次 mockedList.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a580dc535a3252e8d005f50044ba8b8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3577c2b96c8ca1d0b1cd1cb67a7ced72/" rel="bookmark">
			Spring整合MyBatis(二)源码分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Spring配置Mybatis的文件中我们可以看到如下代码： &lt;!-- 扫描dao --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="org.tarena.note.dao"&gt; &lt;/property&gt; MapperScannerConfigurer，让它扫描特定的包，自动帮我们成批地创建映射器。这样就大大减少了配置的工作量。
basePackage属性是让你为映射器接口文件设置基本的包路径。可以使用分号或逗号作为分隔符设置多于一个的包路径。每个映射器都会在指定的包路径中递归地被搜索到。被发现的映射器将会使用Spring对自动侦测组件默认的命名策略来命名。也就是说，如果没有发现注解，它就会使用映射器的非大写的非完全限定类名。如果发现了@Component或JSR-330@Named注解，它会获取名称。
通过上面的配置，Spring就会帮助我们对test.mybatis.dao下面所有接口进行自动的注入，而不需要为每个接口重复在Spring配置文件中进行声明了。那么这个功能如何做到的呢？MapperScanner Configurer中又有哪些核心操作呢？同样首先看下这个类实现了InitializingBean接口。马上查找afterPropertiesSet方法来看看类的初始化逻辑。
public class MapperScannerConfigurer implements BeanDefinitionRegistryPostProcessor, InitializingBean, ApplicationContextAware, BeanNameAware {但没有任何有意义的实现，我们看到MapperScannerConfigurer还实现了接口BeanDefinitionRegistryPostProcessor接口的方法： public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException { if (this.processPropertyPlaceHolders) { processPropertyPlaceHolders(); } ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry); scanner.setAddToConfig(this.addToConfig); scanner.setAnnotationClass(this.annotationClass); scanner.setMarkerInterface(this.markerInterface); scanner.setSqlSessionFactory(this.sqlSessionFactory); scanner.setSqlSessionTemplate(this.sqlSessionTemplate); scanner.setSqlSessionFactoryBeanName(this.sqlSessionFactoryBeanName); scanner.setSqlSessionTemplateBeanName(this.sqlSessionTemplateBeanName); scanner.setResourceLoader(this.applicationContext); scanner.setBeanNameGenerator(this.nameGenerator); scanner.registerFilters(); scanner.scan(StringUtils.tokenizeToStringArray(this.basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS)); } 正是这里。大致看下代码实现，正是完成了对指定路径扫描的逻辑。那么，我们就以此为入口，详细地分析MapperScannerConfigurer所提供的逻辑实现。 1.processPropertyPlaceHolders属性的处理
首先，难题就是processPropertyPlaceHolders属性的处理。或许许多人并未接触过此属性。我们只能查看processPropertyPlaceHolders()函数来反推此属性所代表的功能。
private void processPropertyPlaceHolders() { Map&lt;String, PropertyResourceConfigurer&gt; prcs = applicationContext.getBeansOfType(PropertyResourceConfigurer.class); if (!prcs.isEmpty() &amp;&amp; applicationContext instanceof GenericApplicationContext) { BeanDefinition mapperScannerBean = ((GenericApplicationContext) applicationContext) .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3577c2b96c8ca1d0b1cd1cb67a7ced72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a45a8d784c0ccbf422a468a0bf6d9c5e/" rel="bookmark">
			iOS开发textField点击背景空白隐藏收起键盘的N种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 iOS点击空白处或点击背景收起键盘 在viewDidLoad中添加手势 - (void)viewDidLoad{ [super viewDidLoad]; //添加手势 UITapGestureRecognizer *tap1 = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(viewTapped:)]; tap1.cancelsTouchesInView = NO; [self.view addGestureRecognizer:tap1]; } 然后 实现方法即可 -(void)viewTapped:(UITapGestureRecognizer*)tap1 { [self.view endEditing:YES]; } 最简单粗暴的,只要在 任何 UIView子类结束编辑即可: 在一个VIewController收起键盘的方法如下: -(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event { [self.view endEditing:YES]; } 释放编辑框TextField(TextView同理)的第一响应者TextField点击Reture收起键盘 步骤:实现委托协议,释放第一响应者 self.textField.delegate=self; -(BOOL)textFieldShouldReturn:(UITextField *)textField { [self.textField resignFirstResponder]; return YES; } 背景设置一个 UIButton,给button一个回调,当点击按钮的时候释放键盘的第一响应者 同上 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8d3db22f1fd55c3728a272de584664d/" rel="bookmark">
			tensorflow 图像分类实战解析（上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前一直是想解决从规定的文件名列表里面读取图片并且放入TF训练的问题，stackoverflow上面找到了这个答案:http://stackoverflow.com/questions/37450620/tensorflow-image-classification，虽然并非是我最想达到的效果，但毕竟是一个有用的蓝本，在之后以这个为基础再进行改进吧，所以想把这一段代码深入理解一下。
from __future__ import absolute_import from __future__ import division from __future__ import print_function import time import math import numpy import numpy as np import random from PIL import Image 使用IPL库来读取图片，其实在这个框架里面就算使用pyplot.iamge来读取图片也没有什么问题 我对比了一些开源库对于读取图像这个问题的解决方案，能够跑的动的方案其实效果都不是非常理想。比如可以使用opencv来做读图图像的接口，YOLO-py中就是这么做的，大致代码如下:
import cv2 img = cv2.imread("xxx.jpg") #you can do some cv2 process img_arrayy = np.array(img).resize(imagePixes,1) #do some tensorflow process feeddict = {placeholder:im_array} 但是这些方法依然存在着内存消耗过大的问题（在较多训练样本的情况下，没有办法一次性导入大量样本，毕竟这些样本全部都存在于内存中）现在拟定的解决方案是按照batch分批次读取图片，这个在后续的更新中会把代码放出来
from six.moves import xrange # pylint: disable=redefined-builtin import tensorflow as tf # Basic model parameters as external flags.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8d3db22f1fd55c3728a272de584664d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/391f82abe7e3fe1b6a0678e6670e5dab/" rel="bookmark">
			CentOS7下安装配置Jenkins
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面简单介绍了下CentOS7下安装配置nuxus和CentOS7下防火墙的配置，今天继续介绍CentOS7下jenkins的安装配置。
下载 我在安装配置时，用的是jenkins的rpm包，下载地址如下：
https://jenkins.io/index.html
安装配置 第一：安装rpm包：
tar -zxvf nexus-2.11.3-01-bundle.tar.gz 第二：进入jenkins的系统配置文件并修改相关端口号（也可以不修改）
jenkins的默认JENKINS_PORT是8080，JENKINS_AJP_PORT默认端口是8009，这同tomcat的默认端口冲突。我这更改为8088和8089。
vi /etc/sysconfig/jenkins 第三：检测jdk是否安装，若没有安装jdk，则安装jdk
第四：检查jenkins是否配置jdk，在candidates后面加上自己的jdk路径，如下：
vi /etc/rc.d/init.d/jenkins 启动 service jenkins start 访问 启动成功后，就可以访问了，访问地址如下：192.168.8.128:8088，如下：
配置 安装好，能成功访问，紧接着就进行自动化构建项目配置。 第一：进入页面，点击新建 输入项目名称，选择“构建maven项目” 第二：进入配置 在源码管理处选择svn，因为我用的是svn，配置相应的url地址，如下 如果是首次输入需要输入对应的svn仓库的用户名和密码。 第三：构建触发器 第四：选择系统管理，系统设置 jdk配置：别名随便输入，配置你的JAVA_HOME maven配置如下： 邮件通知 这样就配置好了，保存之后，点击立即构建，因为是第一次构建，所以需要一点耐心。
常见错误 错误一：jenkins启动时出现Warning。 解决方案：使用以下命令解决 systemctl daemon-reload
systemctl restart Jenkins
错误二：jenkins整个安装配置正确，但是最后在访问的时候却不能访问成功。其原因是防火墙不允许对应的端口访问。
解决方案：增加对防火墙的配置，配置方式可以参照上篇博客：CentOS7防火墙修改。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56133f8df004f112d2e1e9bfa8dae976/" rel="bookmark">
			mysql sql_mode小分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql sql_mode参数小节 mysql，sql实例
SELECT charges,mealstime,name,sd_meal.id,fixedcharges,balancecharges,payablecharges FROM sd_meal,lcmemdata,sd_conservation WHERE sd_meal.childuid=lcmemdata.childid AND lcmemdata.muid=#{id} AND sd_conservation.childuid=sd_meal.childuid GROUP BY mealstime 在执行sql时。保错 Exception #1………GROUP BY mealstime 当时觉得太怪了，在其他电脑上可以运行 在百度了一下后查询了sql_mode
slelct @@sql_mode 有一个only_full_group_by sql_mode常用值如下： ONLY_FULL_GROUP_BY： 对于GROUP BY聚合操作，如果在SELECT中的列，没有在GROUP BY中出现，那么这个SQL是不合法的，因为列不在GROUP BY从句中
NO_AUTO_VALUE_ON_ZERO： 该值影响自增长列的插入。默认设置下，插入0或NULL代表生成下一个自增长值。如果用户 希望插入的值为0，而该列又是自增长的，那么这个选项就有用了。
STRICT_TRANS_TABLES： 在该模式下，如果一个值不能插入到一个事务表中，则中断当前的操作，对非事务表不做限制 NO_ZERO_IN_DATE： 在严格模式下，不允许日期和月份为零
NO_ZERO_DATE： 设置该值，mysql数据库不允许插入零日期，插入零日期会抛出错误而不是警告。
ERROR_FOR_DIVISION_BY_ZERO： 在INSERT或UPDATE过程中，如果数据被零除，则产生错误而非警告。如 果未给出该模式，那么数据被零除时MySQL返回NULL
NO_AUTO_CREATE_USER： 禁止GRANT创建密码为空的用户
NO_ENGINE_SUBSTITUTION： 如果需要的存储引擎被禁用或未编译，那么抛出错误。不设置此值时，用默认的存储引擎替代，并抛出一个异常
PIPES_AS_CONCAT： 将”||”视为字符串的连接操作符而非或运算符，这和Oracle数据库是一样的，也和字符串的拼接函数Concat相类似
ANSI_QUOTES： 启用ANSI_QUOTES后，不能用双引号来引用字符串，因为它被解释为识别符
ORACLE的sql_mode设置等同：PIPES_AS_CONCAT, ANSI_QUOTES, IGNORE_SPACE, NO_KEY_OPTIONS, NO_TABLE_OPTIONS, NO_FIELD_OPTIONS, NO_AUTO_CREATE_USER.
如果使用mysql，为了继续保留大家使用oracle的习惯，可以对mysql的sql_mode设置如下：
在my.ini添加如下配置 sql-mode=”STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d48f10d566c3e5f00f3ec315a2f0b7e4/" rel="bookmark">
			通过 python 打开 SecureCRT 软件并实现自动连接主机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何通过 python 打开 SecureCRT 软件并实现自动连接主机？这个问题是我在实际应用中遇到的问题。做运维的工作上经常需要通过 SecureCRT 连接某个系统内的所有主机，话说 boss 们嫌这样太麻烦，希望通过编写一个程序软件，在该软件上通过下拉框选择特定的系统，再点击按钮就可实现连接该特定系统的所有主机。这是很好的想法，毕竟还是要方便嘛！ 通过 python 里的 os.system() 可以打开外部程序，当然也可以打开 SecureCRT 啦，通过os.system('...\\SecureCRT.exe') 即可（其中 ... 代表 SecureCRT 的安装路径），但是这仅仅是打开了 SecureCRT 软件而已，并不能实现自动连接主机啊。实际上通过运行 bat 文件调用 vbs 脚本可以实现自动打开 SecureCRT 并连接特定的主机。 我们写的 login.bat 文件的代码如下：
@set /p name=用户名： @set /p pwd=密码： start "" "D:\Program Files\SecureCRT\SecureCRT.exe" /SCRIPT "D:\test\login.vbs" /arg %name% /arg %pwd% :end exit login.vbs 脚本的代码如下： #$language = "VBScript" #$interface = "1.0" Dim UsrID '用户名 Dim UsrPass '密码 Public Sub login UsrID=crt.Arguments.Getarg(0) UsrPass=crt.Arguments.Getarg(1) End Sub Sub main login WXB End Sub Sub WXB crt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d48f10d566c3e5f00f3ec315a2f0b7e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/748e9b858f8f7ebde48694fb7a0dbdf5/" rel="bookmark">
			js处理数据的方式记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		条件判断 JavaScript把null、undefined、0、NaN和空字符串''视为false，其他值一概视为true。
js中常用的数据处理记录 //下拉框选中项的内容 $("#subsidyType option:selected").text(); //IE有时处理中文乱码 var _borrowName = encodeURIComponent($.trim($("#userName").val())); window.open(encodeURI('http://api.xxx.cn/share/qqim?url=${weburl}/user/register.html?ui=${ui}&amp;title=我在某某某网站帮你抢到注册壕礼&amp;summary=快来领取和我一起赚钱吧！')); // input控件选择器 $("input[name='username']") // 连续对一个对象的属性处理 $(".offline_on_detail").attr("style","display:none").attr("data-status","off"); 时间工具 //时间处理文件------------------------------------------------------------- var now = new Date(); //当前日期 var nowDayOfWeek = now.getDay(); //今天本周的第几天 var nowDay = now.getDate(); //当前日 var nowMonth = now.getMonth(); //当前月 var nowYear = now.getYear(); //当前年 nowYear += (nowYear &lt; 2000) ? 1900 : 0; //格局化日期：yyyy-MM-dd function formatDate(date) { var myyear = date.getFullYear(); var mymonth = date.getMonth()+1; var myweekday = date.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/748e9b858f8f7ebde48694fb7a0dbdf5/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/302/">«</a>
	<span class="pagination__item pagination__item--current">303/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/304/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>