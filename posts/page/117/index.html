<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62050de75e57b135daa1fc32be4143f7/" rel="bookmark">
			C语言 easyx图形库相关常用函数介绍(非常详细)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：easyx图形库是C++里面的一个图形库，其装有一些基本的绘图函数，可以通过这些绘图函数来创建一个窗口，从而绘制你想要的图像。这个非常适合初学者使用，能够帮助初学者快速上手图形库，同时我们还可以通过easyx图形库来制作有趣的图片，或者制作游戏。 目录
C语言图形库函数easyx下载
1.创建窗口函数
2.设置窗口背景颜色
3.清屏函数
4.打印文字
5.画线段
6.画圆
7.画矩形
8.设立填充颜色函数
9.画点
10.画弧
11.双缓冲（防止屏幕的跳动）
12.贴图（放出图片）
13.鼠标操作
14.获取一个点的颜色
15.关闭绘图窗口
这个是我个人通过easyx图形库制作的流星雨动态图
流星雨
首先下载easyx图形库到你的VS 编译器里
C语言图形库函数easyx下载 easyx下载
也可以复制EasyX Graphics Library for C++浏览器下载
头文件 #include&lt;easyx.h&gt; //或者#include&lt;graphics.h&gt; 1.创建窗口函数 initgraph(900, 600,SHOWCONSOLE);//其中900表示长，600表示高 //其中的SHOWCONSOLE是展示控制台，可以用1来代替，即initgraph(900, 600,1); //这个参数可以不用 2.设置窗口背景颜色 setbkcolor(RGB(66, 52, 200));//RGB(a,b,c)其中a是表示红色，b是表示绿色，c是表示蓝色 setbkcolor(GREEN);//我们也可以这样直接表示窗口背景为绿色 RGB三原色每个参数的取值范围是0~255.不同的参数混合起来会展现出不同的颜色。
RGB
3.清屏函数 cleardevice();//清除当前画图窗口 4.打印文字 settextstyle(x, y, "幼圆");//表示字体的风格 //x是表示单个字体的高度；y是表示字体的平均宽度，一般设为0为默认值 setbkmode(TRANSPARENT);//这个可以设置背景字体背景颜色为透明，字体本身是有背景颜色的 settextcolor(BLUE); //settextcolor(RGB(40,50,100)); (表示设立字体的颜色，有以上的两种写法 )
outtextxy(X,Y , "我爱中国!"); //我们也可以这样子输出 char str[20]={"我爱中国！"}; outtextxy(50,50,str); 其中X表示字体所放的横坐标，Y表示纵坐标（原点是在窗口的左上角）
5.画线段 setlinecolor(GREEN);//表示设立线段的颜色 //同样可以这样写setlinecolor(RGB(50,40,150)); 一般先设立好线段的颜色，再去画线段
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62050de75e57b135daa1fc32be4143f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36fb1279268295aebc452252c238dc6d/" rel="bookmark">
			RTL9010调试记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 简介 rtl9010是一款100/1000BASE-T1的车载以太网PHY芯片
2. 手册解读 2.1 软复位 Page0，寄存器0x00，bit[15]=1,即BMCR寄存器。
Use the BMCR reset command at Page 0x0, Reg 0x00, bit[15] = 1, see 8.2.1, to reset the chip. When a
software reset is done, poll the value of Page 0x0 until Reg 0x00 is equal to 0x0140, or wait for at least
20ms before accessing the other registers of the PHY. Please note that after the software reset, the speed will return to 1000M.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36fb1279268295aebc452252c238dc6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c42dce852dcc6c027d032aaec8d94b29/" rel="bookmark">
			基于Java的网上商城系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、项目介绍 乐购网上商城采用当前最流行的Springboot SpringMVC Mybatis框架开发,前端使用目前最流行的VUE框架，数据库采用开源Mysql。架构前后端分离。功能方面：模拟完整的购物流程，商品浏览，商品分类，商品搜索，商品详情，购物车，订单支付，个人中心，登录注册等模块。
二、技术介绍: Java;Springboot;VUE;Mysql
三、开发工具: 1.IntelliJ IDEA或者Myeclipse 3.Navicat 3.Mysql 4.JDK8
四、提供的服务： 源代码（前后端源代码+sql脚本）配套文档（一万字以上）一键启动项目（适合基础薄弱的同学，一键启动，无需搭建复杂环境）远程调试 源代码和配套文档领取加文章最下方的名片哦~
1.1 引言 产业的发展往往会推进技术更新换代，与互联网也有非常大的关系。现实生活中，之所以迫切需要产品本身具有较好的品质，但是无法即使将好的商品卖到较远的地区，主要是卖家与买家沟通不顺畅，信息流通不畅，小型的商家往往采用比较传统的记录数据、处理商品的模式。传统的数据处理模式最大的问题就是数据处理的效率低下、错误率大，由此会引发订单管理混乱、商品信息更新响应慢、投入大量的人力却得不到对应的正回报。在这种情况下，商家的经营必定会逐渐在行业竞争中落下风，小型企业往往会面临资金链压力较大而倒闭的危机。所以开发设计一个轻便的网上商城不可谓不重要。 1.2 系统开发背景及目的 目前很多商品销售还处于线下实体销售的状态，这种方式在，由于信息沟通不顺畅导致销售成本巨大，商品无法及时卖出，部分商品又具有很强的时时效性，给厂家带来巨大的损失。基于以上背景急需一个专门为商品销售而生的电商平台，买家和卖家可以在此平台上进行销售和交易，节约了大量的线下时间成本。
1.3 系统简介 本次开发的系统为基于Java的电商平台，主要用于商品的线上销售。该系统特点是功能基本能满足商品的销售企业或个体户，轻便快捷又不缺失该有的功能。功能模块具体可分为：系统用户登录及注册模块（，商品模块（商品的搜索、详情、加入购物车）、订单模块（购物车下单支付）、商品评论模块。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b254e53284d61f5fe1f1ea4ed296d37e/" rel="bookmark">
			基于Java的宿舍管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、项目介绍： 宿舍管理系统采用SSM（SpringMVC Spring Mybatis）框架开发,数据库采用Mysql数据库，页面采用JSP技术。功能上支持普通用户和管理员登录。登录进入系统可以查看学习信息，班级信息，寝室信息，寝室卫生情况，寝室访客等级。支持各种信息的Excel导出功能。
二、技术介绍: Java;SSM框架;Mysql;JSP
三、开发工具: 1.IntelliJ IDEA或者Myeclipse 3.Navicat 3.Mysql 4.JDK8
四、提供的服务： 源代码（前后端源代码+sql脚本）配套文档（一万字以上）一键启动项目（适合基础薄弱的同学，一键启动，无需搭建复杂环境）远程调试 源代码和配套文档领取加文章最下方的名片哦~
可行性分析是用最小的代价在最短的时间内确定问题是否能够解决。我首先需要进一步对上一章节目前宿舍管理系统现状的分析。之后初步的确定项目的规模跟目标，确定项目的约束跟限制，必须分析几种可能解法的利弊，从而判定原定系统的目标和规模是否能够实现，系统完成后带来的效益是否能够达到最大值。总之，只有认真的进行了可行性分析，才会避免或者减轻项目开发后期可能出现的困境。
1. 经济可行性
经济可行性的重要方面是研究成本,其中包含毕业设计所需的开发成本，对开发成本是不是会大于开发项目前期预计利润进行预算。在结合上述所有情况的分析下，我觉得自己的毕设课题是经济可行性好的。首先开发此次毕设软件不要前期的投入资金，其次是自己设计的，最多是自己去图书馆找书，在实验室做项目，通过老师教导，同学帮助，这些都是免费的，再有就是需要一台电脑，这些都是能接受的，成本很小的同时我也可能够提升我在编码方面的实现能力。
2. 技术可行性
本课题使用的是Java技术，开发平台选用Eclipse，Eclipse有着完整配备的功能，便于初学者使用还有代码提示，让我使用更加得心应手。在决定了编程框架后，再说用Java语言编码的优点：快，精简，可用性高等。同时，使用的数据库是MySQL，开源的MySQL增添了可视化和稳定化的优点，而且安全方面也做得很好，更别说它的强大的保存数据功能以及查询数据功能。
操作可行性 该网络宿舍管理系统部署容器为tomcat，当需要进行宿舍管理时，只需要配置tomcat服务器，便可进行操作。本系统采用jsp技术，利用网络就能够进行访问和操作，且界面简单易操作，用户只要有电脑，都能进行访问和操作。本系统具有易操作、易管理、交互性好的特点，在操作上是非常简单的。因此本系统可以进行开发。
package com.itheima.controller; import com.itheima.po.Dormitory; import com.itheima.po.PageInfo; import com.itheima.service.DormitoryService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.ResponseBody; import javax.servlet.http.HttpSession; import java.util.List; /** * 用户控制器类 */ @Controller public class DormitoryController { // 依赖注入 @Autowired private DormitoryService dormitoryService; /** * 分页查询 * pageIndex 当前页码 * pageSize 显示条数 */ @RequestMapping(value = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b254e53284d61f5fe1f1ea4ed296d37e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9c2d3d410035f7cd2e10482657627b4/" rel="bookmark">
			excel日期函数技巧：到期时间提醒的几种设置方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在平时的工作应用中，我们都喜欢用Excel表格来记录整理数据，数据里会包含到期时间，比如订单到期日期、合同到期日期、产品到期日期等。对于这类数据，我们希望能够有一个到期提醒功能来帮助我们管理数据，如何在Excel里实现这么一个日期到期提醒功能，就是我们今天要讨论的话题，由浅入深分为五层境界，以下用一个药品的有效期数据为例，下面和大家一层一层来了解，原始数据如图所示。
第一层境界：备注列计算到期天数
这个方法是最简单最初级的，只需要用到一个函数TODAY，该函数不需要参数，可以直接返回当前的系统日期，用到期日期-当前日期即可得到还有多少天到期，公式为：=D4-TODAY()
注意两点：
1.如果输入公式后显示不正确，可以将单元格格式修改为常规；
2.因为使用了TODAY()函数，所以每天打开表格时备注栏的数字都是会发生变化的，表示距到期日还有多少天，如果是负数说明已经过期了。
第二层境界：更加人性化的备注信息
这一次需要用到TEXT来实现我们想要的效果，对负数统一显示为“已过期”，对正数显示为“还有多少天到期”，公式为：=TEXT(D4-TODAY(),"还有0天到期;已过期;;")
只是利用了TEXT函数对第一层得到的天数做了一些处理。
第三层境界：只显示需要关注的信息
备注栏如果显示全部的结果，其实并不能突出需要关注的重点数据，假如只对未来30天以内到期的数据做提示，超过30天的不显示任何内容，这样的结果看起来会更加直观，此时让IF出马更为合适，公式进一步优化为：=IF(D4-TODAY()&lt;31,TEXT(D4-TODAY(),"还有0天到期;已过期;;"),"")
使用公式也就只能做到这个程度了，如果还要提升境界，就必须条件格式登场。 第四层境界：条件格式控制显示效果
这一次要实现的效果是让30天内到期的数据整行显示黄色，已过期的整行显示红色，这个要求涉及到两条规则，设置步骤如下。
首先选中数据区域，再打开条件格式中的新建规则，选择使用公式确定要设置格式的单元格，公式输入=$D4&lt;today()，然后设置格式，完成后一直点确定退出，就能看到效果了，操作步骤看动画演示。
操作要点：只选择需要应用条件格式的区域，也就是从第4行开始选。
重复这个过程，再次设置条件格式，区别就是公式变成=$D4-TODAY()&lt;31，再看一次动画演示。
操作要点：设置完成后在条件格式的管理规则中调整一下两条规则的顺序。
公式中的&lt;31也可以改成&lt;=30，这个很好理解。
如果还需要对60天内到期的数据做提醒，对应增加规则就可以了。
比这个效果更高级的那就是增加了按钮来控制到期提醒，这就要用到控件了。
第五层境界：利用按钮控制到期提醒
该设置分为两部分操作，控件按钮的添加和条件格式的设置，先来看看控件怎么用。
添加控件不是很难，选择选项按钮后在表格里拖动一个矩形框就可以完成添加。
添加后修改说明文字，再根据自己的需要复制几个选项按钮，做成这种效果。
在其中一个控件上面点右键，设置控件格式，然后选择表格空白区域的一个单元格。
完整的操作看动画演示。
这一步的原理就是利用控件在单元格得到对应选项的数字，为下一步的设置提供一个条件。
接下来设置条件格式，过程和第四部分的一样，只是公式有所不同，因为这里有三个选项，所以需要设置三次规则，公式分别为：
规则1：=AND($K$2=1,$D4&lt;TODAY())
规则2：=AND($K$2=2,$D4-30&lt;TODAY(),$D4&gt;=TODAY())
规则3：=AND($K$2=3,$D4-60&lt;TODAY(),$D4-30&gt;=TODAY())
如果还需要设置更多选项，按照对应的条件修改公式添加即可。
最终效果如图所示。
小结：任何看上去高大上的应用都是从最基本的功能一点一点优化出来的，而且需要各种功能相互配合才能实现，今天的例子，从最开始很简单的一个公式，到最后应用了条件格式以及控件，就是最好的一个实证。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f24313be203e530971f2148ed27e4a7a/" rel="bookmark">
			Vue路由跳转的五种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue路由跳转的五种方式 目录 Vue路由跳转的五种方式1. router-link2. this.$router.push()3. this.$router.replace() (用法同push)4. this.$router.go(n)5. location扩展this.$ router.push()和 this.$ router.replace()的区别params和query的区别 路由跳转有两种形式：声明式导航、编程式导航
1. router-link 声明式prop=&gt; :to=“…”相当与 router.push(…) router-link中链接如果是’ / '开始，就是从根路由开始
如果开始不带 ’ / '，则是从当前路由开始
例子
&lt;template&gt; &lt;div&gt; router-link 第一种方式 &lt;router-link :to="{name:'home'}"&gt; &lt;router-link :to="{path:'/home'}"&gt; name,path都行, 建议用name &lt;router-link :to"{ name:'page1', query:{key:'我是传递的参数'} }"&gt; 传递参数 &lt;/router-link&gt; &lt;/div&gt; &lt;/template&gt; 2. this.$router.push() 可追溯编程式router.push(…)//该方法的参数可以是一个字符串路径，或者一个描述地址的对象。会向history栈添加新纪录方式 name route-nameparams //params传参 1.路由配置： name: 'home', path: '/home/:id'(或者path: '/home:id') 2.跳转： this.$router.push({name:'home',params: {id:'1'}}) 注意： // 只能用 name匹配路由不能用path // params传参数(类似post) 路由配置 path: "/home/:id" 或者 path: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f24313be203e530971f2148ed27e4a7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b6b516dd5d58078c2563f598dfd56fc/" rel="bookmark">
			扫雷游戏优化详解——c语言实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录
一、扫雷游戏的简单认识与解释 二、扫雷游戏的代码及思路实现
一、扫雷游戏的思路
1、菜单打印 2、创建扫雷区
3、初始化雷区
4、打印雷区
5、布置雷区
6、排雷
三、扫雷游戏代码的整合
game.h
game.c
test.c 标题：扫雷小游戏 作者：@Ggggggtm 寄语：与其忙着诉苦，不如低头赶路，奋路前行，终将遇到一番好风景 一、扫雷游戏的简单认识与解释 相信大家都玩过扫雷游戏吧。但是你真的会玩扫雷游戏吗？那就让我来给你具体讲一下扫雷游戏的玩法。规则如下：
首先是已经布置好雷区，第一次排雷全靠运气；当未踩中雷，会显示出以你排的位置为中心，9x9的范围内有多少颗雷；当未踩中雷，且9x9的范围内没有雷时，会直接拓展区域，直到周围有雷停止拓展；当你踩中雷时，游戏直接结束；直到你排完雷，才算游戏取得胜利。 既然我们熟悉了规则，那我们来看一下具体的代码及思路的实现吧。
二、扫雷游戏的代码及思路实现 一、扫雷游戏的思路 我们先来大概想一下整体的思路。简单的可分为以下步骤：
菜单打印创建扫雷区域初始化扫雷区域打印雷区布置雷区排雷 有了上面的整体的扫雷实现思路，我们就来一一展开实现。当然在不同板块实现中还有很多的小细节，具体的细节我们再实现中一一引出来分析。
1、菜单打印 菜单的打印需要简单明了即可。且实现比较简单。注意要单独放在一个自定义函数中，让主函数中的代码尽量减少，方便观察。
void meau() { printf("************************\n"); printf("***** 1、play *****\n"); printf("***** 0、exit *****\n"); printf("************************\n"); } 通过上面的菜单，我们可以很容易的看出选择 ‘ 1 ’ 开始游戏，选择 ‘ 0 ’ 退出游戏。
2、创建扫雷区 创建雷区需要注意的是，我们后期可能要改变雷区的大小。为了方便后期更改雷区大小，所以我们这里选择define定义常量。
我们在这里创建雷区时选择创建两个二位数组。一个数组放雷，另一个数组输出提示。这样会更加方便实现。假如我们这里只创建一个二维数组的话，在扫雷的同时还需要输出提示会很麻烦。
当我们选择9x9的雷区时，我们定义的雷区需要在上下左右各加一行，以便后面我们排雷时不会越界访问数组。代码如下：
#define ROW 9 #define COL 9 #define ROWS ROW+2 #define COLS COL+2 char mine[ROWS][COLS] = { 0 }; //放雷数组 char show[ROWS][COLS] = { 0 }; //输出数组 3、初始化雷区 我们先把两个数组初始化。在mine[ROWS][COLS]中，我们将整个数组初始化成 ’ 0 ’；将show[ROWS][COLS] 全部初始化成 ‘*’。把mine数组初始化成’ 0 ’，是因为我们要把雷设置成 ‘ 1 ’，以便我们后期统计雷的数量。把show数全部初始化成 ‘ * ’，是因为输出的时候可看性比较高。接下来我们看一下代码的实现：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b6b516dd5d58078c2563f598dfd56fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae52a25e17452d5359c8ad2d31c1d1a8/" rel="bookmark">
			PX4 磁罗盘干扰分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		磁罗盘干扰分析 推力与磁场关系正常情况干扰情况与推力相关解决方法 与推力不相关 罗盘补偿操作流程获取用于分析的日志分析日志调整罗盘补偿参数 推力与磁场关系 无人机上的电机电流会干扰无人机上搭载的磁罗盘，PX4官方提供了一些方式，通过分析飞行日志，判断电机是否对磁罗盘有严重影响。
PX4官方手册介绍：Thrust and Magnetic Field
将飞行日志导入PX4官方的Flight Review中，其中图表Thrust and Magnetic Field展示了推力和磁罗盘采集的原始磁场向量的模长之间的关系。
正常情况 正常状况下，飞行全程磁罗盘的曲线接近为一个常值，并且推力与磁场之间不存在相关性。
干扰情况 与推力相关 明显可以看出，磁场受到推力变化的影响。两者存在相关性
解决方法 1.增加外置罗盘
2.远离电机安装
3.罗盘补偿（后文会介绍）
与推力不相关 还有一种情况，即磁场不明显与推力相关，但不维持在一个常值。这种情况可能有两个原因：
1.磁罗盘没有正确校准
2.飞行过程受到外部干扰
罗盘补偿 无人机的磁罗盘应该安装在远离大电流的位置，比如安装时应远离电机，因为电流的诱发磁场会干扰磁罗盘的读数。同时磁场强度是按与电缆距离的二次方衰减的，因此最有效的排除干扰方式应当是改变安装位置，但如果无法改变安装位置，那么也可以在软件层面，通过推力补偿/电流补偿尽量消除这部分影响。
PX4官方手册介绍：Compass Power Compensation
操作流程 获取用于分析的日志 所使用固件最好是v1.11.0之后版本执行磁罗盘校准修改参数SDLOG_MODE = 2，使无人机从上电后就开始记录日志修改参数SDLOG_PROFILE，使用外力固定无人机。因为后续要推动油门，需要确保无人机无法移动，但不能影响到电机的正常转动。飞行模式要调整为ACRO，在该模式下，无人机不会尝试补偿外界阻力，从而得到更为准确的数据。 开始实验：
解锁无人机，缓慢推动油门到最高位置油门到达最高位置后，缓慢降低油门到0将无人机上锁 分析日志 PX4源码里提供了分析磁罗盘补偿参数的脚本
具体目录：
PX4-Autopilot/src/modules/sensors/vehicle_magnetometer/mag_compensation/python/mag_compensation.py
用下述命令运行该脚本
python mag_compensation.py ~/path/to/log/logfile.ulg thrust(current) /* * ~/path/to/log/logfile.ulg是实验日志的存放目录 * thrust/current选择用推力补偿或是用电流补偿 */ 会得到拟合度曲线
和计算得到的补偿参数的数值：
调整罗盘补偿参数 得到上述补偿参数的数值 CAL_MAGx_XCOMP、CAL_MAGx_YCOMP、CAL_MAGx_ZCOMP之后。首先需要修改参数CAL_MAG_COMP_TYPE：
如果是用推力补偿，CAL_MAG_COMP_TYPE = 1
如果是用电流补偿，CAL_MAG_COMP_TYPE = 2
然后修改对应参数CAL_MAGx_XCOMP、CAL_MAGx_YCOMP、CAL_MAGx_ZCOMP的数值即可。
附上一个对比结果：
补偿前：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae52a25e17452d5359c8ad2d31c1d1a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93db28a2164a305c4943a04060cfea61/" rel="bookmark">
			Python WEB 自动化测试实战，项目场景（详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录：导读 前言一、文件上传二、弹窗处理1、alter弹框2、confirm弹框3、prompt 弹框 三、总结 前言 手工测试的占重比例达到了70%，相对开发来说，测试的门槛低，薪资也相对比开发的低不少，所以做自动化测试。
一方面是为了提升自己技术层面的深度。
另一方面是为了解决目前国内缺乏更高效的测试技术难题，最后就是为了提高自己在市场中的竞争力，想拿到高薪，不与时俱进是不可能的。
接下来我们就来讲解自动化测试实战场景文件上传与弹窗处理。
我自己看的这个视频就感觉挺不错的
一、文件上传 input 标签使用自动化上传，先定位到上传按钮，然后 send_keys 把路径作为值给传进去.
如图所示，是企业微信文件上传的页面 定位到标签为 input，type 为 file 的元素信息，然后使用 send_keys 把文件路径作为值给传进去。
Python 版本：
driver.find_element(By.CSS_SELECTOR, "#js_upload_input").send_keys("./hogwarts.png") Java 版本：
driver.findElement(By.cssSelector("#js_upload_input")).sendKeys("./hogwarts.png"); 二、弹窗处理 在页面操作中有时会遇到 JavaScript 所生成的 alert、confirm 以及 prompt 弹框，可以使用switch_to.alert()方法定位到。
然后使用 text、accept、dismiss、send_keys 等方法进行操作。
switch_to.alert()：获取当前页面上的警告框。
text：返回 alert、confirm、prompt 中的文字信息。
accept()：接受现有警告框，即点击确定。
dismiss()：解散现有警告框，即点击取消。
send_keys(keysToSend)：发送文本至警告框。keysToSend:将文本发送至警告框。
1、alter弹框 输入一段文本点击比如提交按钮，会弹出确认内容的弹框，这种场景可以使用下面的方式处理：
Python 版本：
"""Alert弹窗获取文本与确认操作""" driver.get("http://xxxxx") driver.find_element_by_name("b1").click() # 添加显示等待，等待弹框的出现 WebDriverWait(driver, 5, 0.5).until(EC.alert_is_present()) # 切换到弹框 alert = driver.switch_to.alert # 打印弹框的文本 print(alert.text) #点击确定 alert.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93db28a2164a305c4943a04060cfea61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/193e627da1f6341aefd28c752a46a327/" rel="bookmark">
			基于Sobel算子的图像边缘检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Sobel算子 Sobel边缘检测算法比较简单，实际应用中效率比canny边缘检测效率要高，但是边缘不如Canny检测的准确，然而在很多实际应用的场合，sobel边缘却是首选，Sobel算子是高斯平滑与微分操作的结合体，所以其抗噪声能力很强，用途较多。尤其是在对效率要求较高，而对细纹理不太关系的时候。
使用Sobel算子提取图像边缘分3个步骤：
提取X方向的边缘，X方向一阶Sobel边缘检测算法为：
[ − 1 0 1 − 2 0 2 − 1 0 1 ] \begin{bmatrix} -1 &amp; 0 &amp; 1 \\ -2 &amp; 0 &amp; 2 \\ -1 &amp; 0 &amp; 1\end{bmatrix} \quad ​−1−2−1​000​121​ ​提取Y方向的边缘，Y方向一阶Sobel边缘检测算法为：
[ − 1 − 2 − 1 0 0 0 1 2 1 ] \begin{bmatrix} -1 &amp; -2 &amp; -1 \\ 0 &amp; 0 &amp; 0 \\ 1 &amp; 2 &amp; 1\end{bmatrix} \quad ​−101​−202​−101​ ​综合两个方向的边缘信息得到整幅图像的边缘。 二、Python代码实现 import cv2 import os def SobelSeg(image): img = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/193e627da1f6341aefd28c752a46a327/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08c27484b9087925fda2034d5270bf38/" rel="bookmark">
			FastAdmin插件开发辅助增强插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人开发的FastAdmin插件开发辅助增强插件 不改变官方的开发习惯，但更丝滑，尽最大的努力生成你想要的代码
非常重要 非常重要 非常重要 写在最前面是为了不要漏了，导致插件没有正常工作。
编写代码都在插件myaddon目录下，不管前台还是后台的
后台代码project/addons/myaddon/application目录下的代码，断点调试需要在project/application下找到对应的文件进行断点调试
使用本插件必须修改配置文件applicatin/config.php，位置大概在文件的第295行。
如果不修改，【FastAdmin插件开发辅助增强插件】不能正常工作。应为本插件是为开发环境准备的，所以不用担心性能安全等问题。生产环境不用调整。
//插件纯净模式，插件启用后是否删除插件目录的application、public和assets文件夹 //默认是true，生产环境设置为true，开发环境设置false 'addon_pure_mode' =&gt; false, 解决了如下问题： 1）开发插件的时候不想分离代码 官方命令行crud生成的代码跟插件分离。开发的时候代码应该在插件包内才友好！代码尽收眼底，结构清晰。
2）约定大于配置 官方命令生成插件命名空间的代码时候，需要给控制器参数添加目录。其实大多数情况都会用插件名称作为目录，好处是不用思考指定的目录代码到底会在哪里？
3）关联模型生产错误代码 官方命令crud设置关联表，希望使用插件命名空间的模型的时候，有时候跟预期不一致，会默认在app/admin/model下生成代码，其实期望的是app/admin/model/插件名称下生成代码，比如模型。解决关联模型外键匹配模型失败了而生成错误代码的问题。
4）多次关联同一张表,完美配合hasone,belongsto,hasmany 完美解决不重复生成关联方法
5）打包插件不想拷贝文件,过滤版本文件.git 插件打包省去了拷贝文件到插件包的问题。生成的代码都在插件的包内。官方的打包没有成功忽略.git
6）开发的时候希望自动完成代码更新 像前端工程师开发nodejs项目的时候一样酷，在命令终端监测代码更新，并及时更新
7) 文件代码已经变更，但是表结构新增了部分字段，还可以用crud吗？ 完全可以。这样的情况经常出现。现在用PC端的crud完美解决了。生成代码预览和新旧代码的对比视图。复制你需要的代码到你的ide，是不是有了非一般的感觉。
8) 导出菜单代码 将插件的菜单从数据库导出，并格式成插件的配置代码。如果控制器的action增加或减少，直接编辑选择生成菜单，不用勾选覆盖代码，直接点击保存就会更新菜的功能。再导出型的菜单代码。
9) 支持生成tree列表视图 选择树视图为是，并根据自己关联自己通过pid，设置关联控制器，最后设置关联展示字段只需要设置一个字段用来显示
10) 记录代码覆盖之前的文件 解决不小心覆盖，还可以恢复的机会
如何使用插件 详细的命令参数
php think help addon-crud php think help addon-dev 一键生成CRUD(addon-crud) 只比官方多一个参数
增加了一个参数 -A, --addon=addonname 插件名
常见命令
//生成fa_test表的CRUD php think addon-crud -A mydemo -t test //生成fa_test表的CRUD且一键生成菜单 php think addon-crud -A mydemo -t test -u 1 //删除fa_test表生成的CRUD php think addon-crud -A mydemo -t test -d 1 //生成fa_test表的CRUD且控制器生成在二级目录下 php think addon-crud -A mydemo -t test -c test //删除fa_test表生成的二级目录的CRUD php think addon-crud -A mydemo -t test -c test -d 1 //生成fa_test_log表的CRUD且生成对应的控制器为testlog php think addon-crud -A mydemo -t test_log -c testlog //生成fa_test表的CRUD且对应的模型名为testmodel php think addon-crud -A mydemo -t test -m testmodel //生成fa_test表的CRUD且生成关联模型category，外链为category_id，关联表主键为id php think addon-crud -A mydemo -t test -r category -k category_id -p id //生成fa_test表的CRUD且所有以list或data结尾的字段都生成复选框 php think addon-crud -A mydemo -t test --setcheckboxsuffix=list --setcheckboxsuffix=data //生成fa_test表的CRUD且所有以image和img结尾的字段都生成图片上传组件 php think addon-crud -A mydemo -t test --imagefield=image --imagefield=img //关联多个表,参数传递时请按顺序依次传递，支持以下几个参数relation/relationmodel/relationforeignkey/relationprimarykey/relationfields/relationmode php think crud -t test --relation=category --relation=admin --relationforeignkey=category_id --relationforeignkey=admin_id //生成v_phealth_db2数据库下的fa_test表的CRUD php think addon-crud -A mydemo -t test --db=v_phealth_db2 一键管理插件(addon-dev) 只比官方多一个行为-c watch,比如mydemo插件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08c27484b9087925fda2034d5270bf38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2349a4dc43239b99d8af1c9034bd390d/" rel="bookmark">
			acwing DFS BFS学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DFS（回溯+剪枝） DFS注意顺序
一条路走到黑即选择一个方法一直走到尾部，到尾部之后返回上一个节点判断另一个方案直到本节点可以访问的节点区别访问完毕
桉树型结构来理解的话类似前序遍历
树的前序遍历是指对于树中的每个节点，先访问该节点，然后递归地访问该节点的左子树，再递归地访问该节点的右子树。树的中序遍历是指对于树中的每个节点，先递归地访问该节点的左子树，再访问该节点，最后递归地访问该节点的右子树。树的后序遍历是指对于树中的每个节点，先递归地访问该节点的左子树，再递归地访问该节点的右子树，最后访问该节点。简单来说，前序遍历是根左右，中序遍历是左根右，后序遍历是左右根。这三种遍历的顺序不同，因此它们可以被用来完成不同的任务。例如，在二叉搜索树中，中序遍历可以按照顺序访问树中的所有节点，因此可以用来排序。后序遍历则可以用来计算树中节点的后继和前驱。
经典案例：
给定一个整数 nn，将数字 1∼n1∼n 排成一排，将会有很多种排列方法。
现在，请你按照字典序将所有的排列方法输出。
输入格式
共一行，包含一个整数 nn。
输出格式
按字典序输出所有排列方案，每个方案占一行。
数据范围
1≤n≤71≤n≤7
输入样例：
3 输出样例：
1 2 3 1 3 2 2 1 3 2 3 1 3 1 2 3 2 1 package ACWing.SearchAndGraphTheory.DFS; //842. 排列数字 ​ import java.util.ArrayList; import java.util.Scanner; ​ /** * @author :chenjie * @date :Created 2022/12/15 18:42 */ public class StaggeredNumerals { public static void main(String[] args) { Scanner sc=new Scanner(System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2349a4dc43239b99d8af1c9034bd390d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d8199f2b8666b16bdca61e8a95c1f67/" rel="bookmark">
			PyCharm中无法调用numpy，报错ModuleNotFoundError: No module named ‘numpy‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原因分析：pycharm所使用的解释器并不是已经安装的python3.6，而是自带了python.exe解释器。
解决方法:在PyCharm的settings（ File-&gt;settings-&gt;project:当前项目名-&gt;Project Interpreter）中设置一下Interpreter
解决步骤：
第一步 Setting
第二步
第三步
第四步 找到你自己的python安装目录，里面有一个python.exe文件，选中它。
第五步
第六步
第七步 测试
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87d76a31cd36d534e3884cf74a76c289/" rel="bookmark">
			timm(图像Imagenet预训练模型库)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PyTorch Image Models (timm)是一个图像模型（models）、层（layers）、实用程序（utilities）、优化器（optimizers）、调度器（schedulers）、数据加载/增强（data-loaders / augmentations）和参考训练/验证脚本（reference training / validation scripts）的集合，目的是将各种SOTA模型组合在一起，从而能够重现ImageNet的训练结果。
作者：Ross Wightman，来自加拿大温哥华。
git地址：https://github.com/rwightman/pytorch-image-models#introduction
涵盖的模型： Aggregating Nested Transformers - https://arxiv.org/abs/2105.12723
BEiT - https://arxiv.org/abs/2106.08254
Big Transfer ResNetV2 (BiT) - https://arxiv.org/abs/1912.11370
Bottleneck Transformers - https://arxiv.org/abs/2101.11605
CaiT (Class-Attention in Image Transformers) - https://arxiv.org/abs/2103.17239
CoaT (Co-Scale Conv-Attentional Image Transformers) - https://arxiv.org/abs/2104.06399
CoAtNet (Convolution and Attention) - https://arxiv.org/abs/2106.04803
ConvNeXt - https://arxiv.org/abs/2201.03545
ConViT (Soft Convolutional Inductive Biases Vision Transformers)- https://arxiv.org/abs/2103.10697
CspNet (Cross-Stage Partial Networks) - https://arxiv.org/abs/1911.11929
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87d76a31cd36d534e3884cf74a76c289/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5aa1b131e8c6ae1317a7e471b662c983/" rel="bookmark">
			请求报错No route to host (Host unreachable)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		请求报错No route to host (Host unreachable); nested exception is java.net.NoRouteToHostException: No route to host (Host unreachable) 报错原因 请求对方机器的端口没有打开，访问的目标地址路由不可达，这个no route to host的报错是由于收到icmp路由不可达报文而导致的。
如果是linux，是iptables阻挡造成的，可以用service iptables stop关闭iptables试试
或者开通防火墙对应的端口
查询防火墙 是否开启28083端口 sudo firewall-cmd --zone=public --query-port=28083/tcp
防火墙 开启28083端口 sudo firewall-cmd --zone=public --add-port=28083/tcp --permanent
防火墙重新加载才能生效 sudo systemctl restart firewalld
或者命令
firewall-cmd --reload
查看防火墙已经开放的端口 sudo firewall-cmd --list-ports
报错信息 2022-12-23 12:57:06.147 ERROR [DZ_SYS,LOW-CODE-DEMO,default,dzsditest:LOW-CODE-DEMO:28085,87866156e76587e4,053a43d0ac923f19,87866156e76587e4,] 18416 --- [http-nio-28085-exec-7] c.p.e.s.e.ControllerExceptionHandler : Request: POST /api/lowcode/contributions, UserInfo: 1:admin, DataSourceInfo: [init=10, min=10, max=50, idle=10, busy=0, unclosedOrphaned=0], Thread: Thread[http-nio-28085-exec-7,5,main], CPU: 50%, SystemMemory: 91% [total:15884MB, free:1425MB, used:14459MB], JvmMemory: 16% [max:3531MB, total:1515MB, free:1261MB, used:254MB] Request Headers: { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5aa1b131e8c6ae1317a7e471b662c983/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39cb311c4546882000d2392ef6e707f2/" rel="bookmark">
			在IDEA中 基于内核的Flink任务提交
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内部实现Flink任务的提交，本文尽量以通俗易懂的方式去解释如果在内部去提交一个flink任务，目前已经实现了standalone、yarn-perjob、yarn-session、yarn-application模式的任务的部署提交
1. 什么是内部提交 想想我们以前部署Flink任务的方式，就是在命令行界面，调用flink run然后指定参数提交到对应的集群中去。
什么是内部提交呢？想想一个场景，现在我们需要做一个计算平台，在计算平台上去写sql管理任务等等，然后提交到集群中去。网上有一种解决方案是在计算平台的程序端，利用Runtime.exec(cmd)去构建flink命令然后执行该命令进行提交，实际上这有点套娃了，为什么这么说呢？
本质上flink run命令也是调用java程序解析客户端命令，然后部署到集群中的，所以我们完全可以绕开构建命令的这个环节。
2.了解Flink部署流程 关于flink部署流程，我推荐去看一下尚硅谷的视频解析（针对1.12版本的），看了之后再仔细捉摸一下就能对flink的任务提交流程有一个很好的理解了。视频链接我放在了文章最后的参考资料上
2.1 几个概念 StreamGraph
JobGraph
如果你对flink的相关运行概念不是很了解，那么就可以参考这篇文章：Flink 作业执行深度解析
2.2 部署相关的类 我们知道flink程序最终都会去执行StreamExecutionEnvironment#execute()方法，内部通过跟踪可以看到最核心的就是在
/** * Triggers the program execution asynchronously. The environment will execute all parts of the * program that have resulted in a "sink" operation. Sink operations are for example printing * results or forwarding them to a message queue. * * @param streamGraph the stream graph representing the transformations * @return A {@link JobClient} that can be used to communicate with the submitted job, completed * on submission succeeded.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39cb311c4546882000d2392ef6e707f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6f195343b43990edebf1fca8d690a33/" rel="bookmark">
			js 金钱数字添加千分位分隔符号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		输出格式 000,000,000.00
// opt 数值，isZero 是否保留两位小数点 numSymbol (opt, isZero = true) { if (opt) { const str = opt + '' // 把数字变成string类型 if (str.indexOf('.') !== -1) { // 判断是否附带小数 const intSum = str .substring(0, str.indexOf('.')) .replace(/\B(?=(?:\d{3})+$)/g, ',') // 取到整数部分 let dot = str.substring(str.length, str.indexOf('.')) // 取到小数部分搜索 // 不足2位补0 if (dot.length === 1) { dot = dot + '00' } else if (dot.length === 2) { dot = dot + '0' } const ret = intSum + dot return ret } else { const ret = str.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6f195343b43990edebf1fca8d690a33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e03e64eb1e4ffe37d187c778740a710b/" rel="bookmark">
			jQuery 动画
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 jQuery 动画概述显示和隐藏动画show() 和 hide()toggle() 淡入和淡出动画fadeIn() 和 fadeOut()fadeToggle()fadeTo() 滑上和滑下动画slideUp()和slideDown()slideToggle() 自定义动画简单动画jquery.color.js 累积动画回调函数 队列动画取消动画延迟动画判断动画状态 jQuery 动画 概述 在实际开发中，使用CSS3来实现动画有一定的局限性，有些地方必须使用jQuery才能实现动画，例如下面几种情况：
控制动画的执行。结合DOM操作。动画执行后返回一个函数。 显示和隐藏动画 在jQuery中，如果想要实现元素的显示与隐藏效果，有以下两种方式：
show()和hide()toggle() show() 和 hide() 语法
$(元素).show(speed, fn) $(元素).hide(speed, fn) 说明
show()方法会把元素由display:none;还原为原来的状态（display:block、display:inline-block等）。
hide()方法会为元素定义display:none;。
speed参数：可选参数。有2种取值，一种是具体的数值；另一种是关键字，slow表示200毫秒、normal表示400毫秒、fast表示600毫秒。
fn参数：可选参数。表示动画执行完后的回调函数。
无动画使用
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="js/jquery-1.12.4.min.js"&gt;&lt;/script&gt; &lt;script&gt; $(function() { $("#show-btn").click(function() { $("img").show(); }); $("#hide-btn").click(function() { $("img").hide(); }); }) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input id="show-btn" type="button" value="显示"&gt; &lt;input id="hide-btn" type="button" value="隐藏"&gt; &lt;br&gt; &lt;img src="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e03e64eb1e4ffe37d187c778740a710b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19fc5edd7ad2a9687770c97906e6aac9/" rel="bookmark">
			apollo7.0 planning设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Apollo 7.0 planning是一种自动驾驶系统规划框架，它旨在为自动驾驶汽车提供高精度的路径规划能力。它通过收集来自传感器和地图的信息，并使用最新的机器学习技术来分析数据，帮助自动驾驶汽车在复杂的城市环境中安全高效地行驶。 Apollo 7.0 planning还可以考虑道路条件、交通规则以及汽车周围的障碍物，并根据这些信息为自动驾驶汽车生成最优的行驶路线。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4694b882bffd8898b8778199b62772b3/" rel="bookmark">
			谷粒商城P184中elasticsearch出错问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Elasticsearch exception type报错是一般是elasticsearch中的mapping出错的。按报错提示改就行了。或者看这个同学的
谷粒商城P184 ES报错_BugMaker-的博客-CSDN博客
我是继续报错
java.lang.IndexOutOfBoundsException: Index: 0, Size: 0
上面会显示一些错误后台点进去看
说是attrname为空 但是我打断点是有值 而且在此之前已经得到了attrid的值说明es应该是没有多大问题。我百度一下在分组的时候加上.keyword但是网上说是加在brandname后面但是我还是错误。我就一个一个调试 只在聚合添加keyword可行 因为自己没有系统学过elasticsearch为什么也不知道 若干你还是不行希望你自己跟据那个报错多试试添加在哪里。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56903114238772c4a803623d3b337a4e/" rel="bookmark">
			网络实验之VTP协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、VTP协议简介 VLAN中继协议，VTP，VLAN TRUNKING PROTOCOL，是CISCO专用协议，大多数交换机都支持该协议。VTP负责在VTP域内同步VLAN信息，这样就不必在每个交换上配置相同的VLAN信息。如协议名称，VTP协议需要依赖trunk链路承载。VTP是一种消息协议，使用第2层帧，在全网的基础上管理VLAN的添加、删除和重命名，以实现VLAN配置的一致性。可以用VTP管理网络中VLAN1到1005。有了VTP，就可以在一台交换机上集中进行配置变更，所作的变更会被自动传播到网络中所有其他的交换机上。（前提是在同一个VTP域）。VTP协议需要为了实现此功能，必须先建立一个VTP管理域，VTP有三种运行模式Server、Transparent、Client，Server模式是默认模式，各模式的区别如下：
功能项ServerClientTransparent（透明模式）增/删/改√×√（仅在本地有效）转发VTP(vlan)信息√√√同步vlan信息√√×保存NVRAM√×√ 二、VTP协议实践 1、实验环境说明 博文实验环境采用GNS3模拟器搭建VTP网络实验环境，三层交换机使用3640，iso系统版本为c3640-jk9o3s-mz.124-10a.bin。
2、拓扑图 如下拓扑图，网络中存在三个网段，分别属于不同的vlan，网关位于SW1交换机上。SW1交换机作为VTP的server，负责维护整个VTP域的vlan信息，SW3和SW4作为末端交换机，配置VTP client模式，从SW1同步vlan信息。SW2配置为transparent模式，可以传递VTP信息，但是不更新本地vlan信息，自行维护。
3、网络配置 初始配置的情况下，SW1手动创建了vlan100-102，并配置了interface100-102的网关地址，SW2手动创建了vlan100，SW3-SW4通过VTP自动学习到vlan100-102。
交换机SW1配置 #如下是vlan database模式下配置 SW1#vlan database SW1(vlan)#vtp server SW1(vlan)#vtp domain sunsite SW1(vlan)#vlan 100 name vlan100 SW1(vlan)#vlan 101 name vlan101 SW1(vlan)#vlan 102 name vlan102 SW1(vlan)#exit #如下是全局模式下配置 conf t hostname SW1 interface FastEthernet0/14 switchport mode trunk switchport trunk allow vlan all switchport trunk encapsulation dot1q no shutdown ! interface FastEthernet0/15 switchport mode trunk switchport trunk allow vlan all switchport trunk encapsulation dot1q no shutdown !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56903114238772c4a803623d3b337a4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60a371bada430b9d9670fa70a1b87eb3/" rel="bookmark">
			解决PageHelper版本不匹配，结果可能全部返回问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.问题：
使用 pagehelper ，如果和mybatis版本不匹配，就会出现返回结果错误问题，比如：本来想返回pageNum：1，pageSize:1的数据，但却是全部返回。自己的代码没问题的情况下，最有可能的就是版本不匹配的问题。
2.解决方案：
出现这个问题很可能就是版本不匹配。可以使用下面的版本进行测试，本人测试成功。
&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.4.1&lt;/version&gt; &lt;/dependency&gt; 3.pagehelper使用示例如下：
可以看到：使用的时候只需要pagehelper.startPage方法；然后在new Page放入返回列表就行。
3.1.server impl层
@Override public PageInfo listForAdmin(Integer pageNum, Integer pageSize) { PageHelper.startPage(pageNum, pageSize, "type, order_num"); List&lt;Category&gt; categoryList = categoryMapper.selectList(); PageInfo pageInfo = new PageInfo(categoryList); return pageInfo; } 3.2.service层 PageInfo listForAdmin(Integer pageNum, Integer pageSize); 3.3.controller层
@ApiOperation("后台目录列表") @GetMapping("admin/category/list") @ResponseBody public ApiRestResponse listCategoryForAdmin(@RequestParam Integer pageNum, @RequestParam Integer pageSize) { PageInfo pageInfo = categoryService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60a371bada430b9d9670fa70a1b87eb3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8599672c054fd3e37ce22e6ccde1330c/" rel="bookmark">
			解决OpenSSL SSL_read: Connection was reset, errno 10054
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错问题： fatal: unable to access ‘https://github.com/Sunyt1992/ref-comet.git/’: OpenSSL SSL_read: Connection was reset, errno 10054
OpenSSL SSL_read:连接已重置，错误号10054
字面意思：服务器的SSL证书灭有经过第三方机构的签署。
网上信息也有的说可能是网络不稳定，连接超时导致。
解决办法 第一种 git config --global https.sslVerify "false" git config --global http.sslVerify "false" # 刷新ip缓存 ipconfig /flushdns 第二种 git push报错：OpenSSL SSL_read: Connection was reset
问题描述
好久没有跟新github今天提交了一次发现报错了
fatal: unable to access ‘https://github.com/Sunyt1992/ref-comet.git/’: OpenSSL SSL_read: Connection was reset, errno 10054
问题分析
从报错中可以看出ssl 链接重置了
解决方法
1.查看git配置
git config --global -l 2.检查环境变量
env|grep -i proxy 第三种 Failed to connect to github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8599672c054fd3e37ce22e6ccde1330c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f044444d1d4c9b24705bfa72f6161a3/" rel="bookmark">
			CVE-2019-0708远程桌面服务远程执行代码漏洞复现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、相关简介
Windows再次被曝出一个破坏力巨大的高危远程漏洞CVE-2019-0708。攻击者一旦成功利用该漏洞，便可以在目标系统上执行任意代码，包括获取敏感信息、执行远程代码、发起拒绝服务攻击等等攻击行为。2019年5月14日微软官方发布安全补丁,修复了windows远程桌面服务的远程代码执行漏洞,该漏洞影响了某些旧版本的Windows系统，此漏洞是预身份验证且无需用户交互,这就意味着这个漏洞可以通过网络蠕虫的方式被利用，利用此漏洞的任何恶意软件都可能从被感染的计算机传播到其他易受攻击的计算机。
2、流程演示
打开Metasploit, search 0708，使用扫描模块（scanner），发现目标是脆弱的
换用攻击模块，设置好目标IP，开始攻击，发现无法建立连接
强化攻击载荷，多次攻击依旧无法建立连接
查看3389端口是处于开启状态的
cmd里面
netstat -na
根据提示查看攻击目标类型
show targets
修改目标类型继续尝试攻击，仍然无法建立连接
应该是我装的win7的虚拟机不在攻击目标的版本类型里
本想更新MSF框架，但升级没有找到工具位置
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15cbaa5fd37687025b12f9e45dfac775/" rel="bookmark">
			程序员应了解的那些事（112）~原子操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、C语言中的原子操作 什么是原子操作？ 原子操作是不可分割的，在执行完毕之前不会被任何其它任务或事件中断，可以视为最小的操作单元，因此称为原子操作（个人认为叫"原子级操作更为形象"）。
（可以是一条指令，也可以是一系列整体性操作）
在编程语言中一般分为两种情况（两种都应该满足）：
1） 在单线程中， 能够在单条指令中完成的操作都可以认为是" 原子操作"，因为中断只能发生于指令之间。（多体现在单条汇编指令语句中）
2） 在多线程中，不能被其它进程（线程）打断的操作就叫原子操作。
为什么存在原子操作？ 在多核处理器的机器上，对于同一个变量值所存在的内存区域可能被多个CPU短时间内同时访问，从而导致该值得不稳定性。例如在多线程中，初始化i=0,对于i++这个操作，同时有2个线程对其进行了调用则有可能导致第一个线程用时i的值为2。（详解如下）
i++是否为原子操作？ ①内存访问，读取i变量的值到CPU的寄存器中 ②使寄存器中的值+1 ③将寄存器中的值写回到内存 由此可见，i++并不是原子操作，在没有线程保护的多线程处理器中，每一步都有可能被外部中断给打断，从而影响到 i 的值。
在上一问中，2个线程同时调用了i++，i直接从0变为2，则极有可能是线程1在寄存器中使得i自增1的同时线程2也在做此操作，因此当取出寄存器中i的值到内存时，i 不知不觉被加了2次。
二、什么叫原子操作？使用这个东西有什么目的？ （1）我们要先搞明白什么叫原子操作？使用这个东西有什么目的？
原子操作：能够操作最接近机器的指令，这个和硬件相关了，虽然和硬件相关，但我们的Ｃ11还是整合了这一切，让原子操作有了共同的调用接口。
目的：使用这个的目的说实话，就是让你更了解机器已及多线程同步的原理和秘密，当然有一些需求较简单的，使用原子操作可能比封装好的更有效率！！用了百遍的mutex可能你现在还不知道他们是怎么互斥的~当然内部还是通过了原子操作来的！
（2）讲讲原理
原子操作只有2种状态，一种是没做，一种是做完了，看不到正在做的状态，这个是在任何线程下都满足这个要求，当两个线程同时访问一块内存的时候，如果有任何一个在写，那肯定会产生竞争，如果两个同时读，没有问题，那如何用原子操作来控制不产生竞争呢？可以这样来想，当两个线程在访问的时候，一定有一个先后顺序，谁先访问，谁后访问，这就是修改顺序，我们要在任何线程可以看到这样的顺序！然后就可以通过一定的逻辑来处理并发竞争的情况了！
（3）标准库操作
例：实现一个线程读取，一个线程写入，当然，要先写入才能读取，所以这个是顺序问题。
方法一：condition_variable来操作 使用condition_variable，读线程wait，直到写线程调用 notify_all,即停止等待：
#include &lt;thread&gt; #include &lt;condition_variable&gt; #include &lt;iostream&gt; using namespace std; condition_variable g_CV; mutex g_mtx; void read_thread() { while (true) { unique_lock&lt;mutex&gt; ul(g_mtx); g_CV.wait(ul); cout &lt;&lt; g_value &lt;&lt; endl; } } void write_thread() { while (true) { Sleep(1000); lock_guard&lt;mutex&gt; lg(g_mtx); g_value++; g_CV.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15cbaa5fd37687025b12f9e45dfac775/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/152d63e6fee4409839b2f26203d3b0ab/" rel="bookmark">
			SpringBoot学习笔记02
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot起步依赖原理 spring-boot-starter-parent 依赖管理：主要定义了版本信息。大部分技术的版本在经过组合测试不会产生冲突后，会在父工程中确定好并锁定。用户在使用时，不需要自己挑选和组合不同技术版本，避免了版本冲突问题
spring-boot-starter-web 依赖传递:starter-web依赖于特定的坐标（如下图所示），项目依赖于starter-web，则项目间接依赖于这些坐标。用户在使用时只需要导入一个starter-web，而不需要自己将所需坐标一个个进行导入，简化了操作
总结 在spring-boot-starter-parent中定义了各种技术的版本信息，组合了一套最优搭配的技术版本。在各种starter中，定义了完成该功能需要的坐标合集，其中大部分版本信息来自于父工程。我们的工程继承parent，引入starter后，通过依赖传递，就可以简单方便获得需要的jar包，并且不会存在版本冲突等问题 SpringBoot配置 配置文件分类 properties:server.port=8080 yml（yaml）:server: port: 8080 1.properties 在resources/application.properties（自动生成）中配置端口（默认为8080），然后启动项目，可以看到端口已经改为8081
2.yml（yaml） yml（yaml）文件同理，但是文件需要自己新建
基本语法 大小写敏感数据值前面必须有空格，作为分隔符使用缩进表示层级关系缩进不允许使用Tab键，只允许使用空格使用#表示注释 数据格式 对象（map）:键值对的集合person: name: zhangsan #行内写法 person: {name: zhangsan} 数组address: - beijing - shanghai #行内写法 address: [beijing,shanghai] 纯量msg1: 'hello \n world' #单引忽略转义字符 msg2: 'hello \n world' #双引识别转义字符 参数引用 name: lisi person: name: ${name} #引用上面定义的name值 优先级 在同级目录下，优先级
properties &gt; yml &gt; yaml
读取配置内容 @ValueEnvironment@ConfigurationProperties yml配置文件：
name: abc #对象 person: name: zhangsan age: 20 #数组 address: - beijing - shanghai 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/152d63e6fee4409839b2f26203d3b0ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c593460d631e8192844a0ea3ea87ee9/" rel="bookmark">
			GPIO基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基础知识介绍 GPIO是什么呢，它的相关寄存器又怎么设置呢，它有哪些工作模式呢，我们一起了解了解吧！
1、GPIO是什么 GPIO为通用的输入输出端口，其端口可通过程序配置成输入或输出【输出的高低电平也通过程序配置】
tips:引脚和GPIO不完全相同，STM32的部分引脚做GPIO使用，部分是电源引脚/复位引脚/启动模式引脚/晶振引脚/调试下载引脚
2、GPIO引脚个数 STM32F429中，PA~PH每组有16个IO，PI只有PI0~PI11个引脚的IO口，一共有16*8+12个引脚，即140个引脚。
3、复用 没有复用，则引脚组1和引脚组2分别控制IO口控制电路和串口控制电路；若复用则是通过开关控制分别控制IO控制电路和串口控制电路。
二、GPIO工作模式 1、工作模式 输入模式： 输入浮空、输入上拉、输入下拉、模拟输入
输出模式（带上下拉）： 开漏输出、开漏复用功能、推挽式输出、推挽式复用
四种最大输出速度（可配置IP口）：2MHZ(低速）、25MHZ(中速）、50MHZ(快速）、100MHZ（高速）
例如：
开漏输出模式 【适合做电流型的驱动，其吸收电流的能力相对强】
当CPU写入1时，N-MOS会截至，对IO端口无影响，如果需要IO口为高电平则需要接一个低上拉电阻使之输出高电平；当CPU写入0时，则会使IO端口输出低电平；
推挽输出模式（连接数字器件）
当写入0时，P-MOS取反后会变为1，而N-MOS会为0，于是P-MOS管截止，N-MOS管导通接地，于是输出低电平；
当写入1时，P-MOS取反后会变为0，而N-MOS为1，于是N-MOS截止，P-MOD接Vdd，于是输出高电平；
2、上电复位工作状态 上电复位以后，GPIO默认为输入浮空状态，部分特殊功能引脚为特定状态
注意：复位以后，调试引脚处于复用功能上拉/下拉的状态，而非作为IO口使用，要使用需要配置
【PA15、PA14、PA13、PB4、PB3】
三、GPIO的寄存器设置 每组GPIO端口的寄存器包括：
注意：每组IO口由十个寄存器组成
1、端口模式寄存器 每个小组代表一个IO口，通过设置16个小组里面的每一组来设置每一个IO口的端口
2、端口输出类型寄存器
设置0~15低十六位，高十六位保留不使用
3、端口输出速度寄存器 4、端口上拉/下拉寄存器 5、端口输入数据寄存器 r为1表示该端口输入的数据值为1，为0表示该端口输入的数据值为0；只使用低16位、高16位仍然保留 ；
6、端口置位/复位寄存器 该寄存器为了单独赋值某一位但是不会影响其他位数；如果没有BSRR寄存器，需要通过设置IDR寄存器，一次性将所有位数读出再写入；
BSRR的值最终还是会映射到ODR上
7、复用功能寄存器
分为高位AFRH和低位AFRL，分别控制8个IO口
通过每个IO口四位AFSELy的选择，设置每个IO口多个功能的其中一种
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea0b58f0f0f8d1c56bc5ff773d47f6be/" rel="bookmark">
			GPU与CPU的性能比较及影响因素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CPU的主要指标是主频和线程。
Intel：后缀F表示无核显，后缀K代表可以超频，H代表移动端；AMD：后缀G代表有核显，后缀X代表加强版，后缀XT代表超级加强版。 CPU 常见计算操作：
数据加载、数据预处理、模型保存、loss 计算、评估指标计算、日志打印、指标上报、进度上报。
GPU任务处理流程
GPU 任务交替使用 CPU 和 GPU 进行计算，当 CPU 计算成为瓶颈时，GPU 会等待，GPU 利用率降低了。
GPU 性能主要依靠制程技术(nm)、GPU架构、线路设计、数字表示方式；
通常制程技术的进步只能让GPU的性能提高到原来的1.5或2倍，
GPU性能的提升主要是靠GPU架构和线路设计、数字表示方式的完善。
GPU的架构适合集群，GPU架构的更新同时更新集群方案。
计算量：即一个深度学习模型需要多少次计算才能完成一次前馈。内存带宽：带宽影响计算速度，即GPU内存带宽是深度学习性能提升的主要瓶颈。 一般的算力评价指标：TFLOPS（具体分单精度、双精度、Tensor）；
在硬件架构相同的条件下，核越来以及带宽越高，性能就越好。
影响GPU性能：
英特尔的 CPU 有AVX，一条指令可以做 512bit 的浮点操作，换算成32位浮点就是16个OPs，CPU 每个时钟周期可以做一次浮点乘加，相当于两个浮点运算，一个时间周期有 32 个FLOP，乘以 CPU 频率及核数，12 核，3GHz 的英特尔 CPU 运算性能 12 * 32 * 3G = 1152GFLOPS，论文显示 GPU 可达到 200GFLOPS，性能瓶颈并不在计算单元上，而是访存；CPU 的访存比GPU 大，只要 CPU 的访存能放得下，CPU 完全可能比GPU快。当访存放不下时，就要比较内存带宽，GPU 比 CPU快，对小规模数据，CPU 处理快，大规模数据，GPU 处理快。
数据加载问题：
1. 数据存储与计算资源间物理距离过远；
2. 数据存储介质导致读写能力不同，不同存储介质读写性能：SSD &gt; ceph &gt; cfs-1.5 &gt; hdfs &gt; mdfs
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea0b58f0f0f8d1c56bc5ff773d47f6be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d12a7d80f29f83b1099bb752b8464d9/" rel="bookmark">
			[MySQL]-压力测试之性能监测指标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[MySQL]-压力测试之性能监测指标 森格 | 2022年12月
本文主要是介绍在数据库的压测过程中，要时刻的一些指标，尤其是当数据库的性能达到瓶颈时，要注意哪个指标已经打满。
一、前文回顾 在前面量两篇文章中，分别介绍了两款压测数据库的工具，Sysbench 与 TPCC-MySQL，大家可以点击链接回顾一下（大概需要10分钟）。在压力测试中，我们不断增加并发数去获取当前数据库配置下的最大性能（QPS、TPS、TPMC等）。
今天呢，我们来注意下在这过程中，是哪些方面的原因导致了性能达到了瓶颈。
二、机器配置 对于压力测试前，我们需要对我们的机器大概的配置有一个了解，在这里个人写了个shell脚本供大家做参考：
#!/bin/sh #Date：2022年10月21日 #author：liangsen # echo -e "\033[41;30;30mI will show computer Infomation there\033[0m" echo "" echo -e "\033[44;30;30m====================CPU========================\033[0m" grep "model name" /proc/cpuinfo echo "" echo -e "\033[44;30;30m================Memory Size====================\033[0m" grep MemTotal /proc/meminfo echo "" echo -e "\033[44;30;30m=================32/64Bit=======================\033[0m" getconf LONG_BIT echo "" echo -e "\033[44;30;30m===============Linux version====================\033[0m" cat /etc/redhat-release echo "" echo -e "\033[44;30;30m=================Linux Core=====================\033[0m" uname -r echo "" echo -e "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d12a7d80f29f83b1099bb752b8464d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2c7b7ef047d67ed6c5cf5d71a40173c/" rel="bookmark">
			宜搭免登获取表单数据详细教程（含源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、首先要准备接口资料 1、宜搭应用的应用参数和秘钥
2、钉钉开发者 AppKey和AppSecret
开发者中心记得开放权限
3、最后还需要准备一个钉钉的userid,随意一个组织内成员的userid都可以，需要登录钉钉OA后台：钉钉管理后台 - 钉钉统一身份认证
切换到旧版 二、下面开始上代码 1、登录阿里云账号，开通云函数计算FC
把下面代码丢进去
这个是getToken函数，获取token鉴权接口
var getRawBody = require('raw-body'); const Url = require('url'); const API_SERVER = 'https://api.dingtalk.com'; const API_VERSION = 'v1.0'; exports.handler = (req, resp, context) =&gt; { resp.setHeader('Content-type', 'application/json'); getRawBody(req, function (err, body) { post( `${API_SERVER}/${API_VERSION}/oauth2/accessToken`, { appKey: 'dinglg-xxxxxx', //钉钉开发者appkey appSecret: 'h1g7F3-xxxxxx', //钉钉开发者appsecret }, function (data) { data = JSON.parse(data); if (data.expireIn) { var respBody = new Buffer.from(JSON.stringify(data)); resp.setStatusCode(200); resp.send(respBody); } else { var respBody = new Buffer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2c7b7ef047d67ed6c5cf5d71a40173c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61a742e65c5fc2c2cd5c70b700c1d529/" rel="bookmark">
			网站设置为黑白色的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种：修改CSS文件
我们可以在网页的CSS文件中添加以下的CSS代码，来实现网页黑白色，也就是网站变灰.(如果是小白站长们，可以把这段代码和到百度统计放在一起，放之前一定要记得换行隔开）
CSS代码
html { filter: progid:DXImageTransform.Microsoft.BasicImage(grayscale=1); -webkit-filter: grayscale(100%); } 第二种：在网页的&lt;head&gt;标签内加入以下代码
如果你不想改动CSS文件，你可以通过在网页头部中的&lt;head&gt;标签内部加入内联CSS代码的形式实现网站网页变灰。放到标签&lt;head&gt;与&lt;/head&gt;底部即可。
代码
&lt;style type="text/css"&gt; html { filter: progid:DXImageTransform.Microsoft.BasicImage(grayscale=1); -webkit-filter: grayscale(100%);} &lt;/style&gt; 第三种：修改&lt;html&gt;标签加入内联样式
如里上面的两种方式都不喜欢，可以通过修改&lt;html&gt;标签，以加入内联样式的方法，达到网页变灰的效果
代码
&lt;html style="filter: progid:DXImageTransform.Microsoft.BasicImage(grayscale=1); -webkit-filter: grayscale(100%);"&gt; 第四种：修改CSS代码
body *{ -webkit-filter: grayscale(100%); /* webkit */ -moz-filter: grayscale(100%); /*firefox*/ -ms-filter: grayscale(100%); /*ie9*/ -o-filter: grayscale(100%); /*opera*/ filter: grayscale(100%); filter:progid:DXImageTransform.Microsoft.BasicImage(grayscale=1); filter:gray; /*ie9- */ } 以上几种方法，都是通过CSS的滤镜来控制页面的显示而已，唯一不同的就CSS代码调用的方式。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43d58b6c1e4a52b7668d497dd36ec7a1/" rel="bookmark">
			js七牛云下载视频、音频、pdf、图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 近期碰到一个需求，浏览器下载视频、音频等附件，原生组件video、audio倒是支持下载，但是别的类型不行，而且无法通过下载按钮进行，常规下载思路使用a标签download属性下载附件，但是浏览器兼容性不好，而且针对视频、音频、pdf等浏览器可预览文件默认还是预览而无法直接下载
经过多位小伙伴调试给出最终解决方案，看代码
&lt;!-- 七牛云下载--&gt; &lt;a onclick="downLoadByUrl('https://qiniu.sicaa.org.cn/1670574047545.mp4')"&gt;下载&lt;/a&gt; &lt;script&gt; function downLoadByUrl(url){ var xhr = new XMLHttpRequest(); //GET请求,请求路径url,async(是否异步) xhr.open('GET', url, true); //设置请求头参数的方式,如果没有可忽略此行代码 // xhr.setRequestHeader("token", token); //设置响应类型为 blob xhr.responseType = 'blob'; //关键部分 xhr.onload = function (e) { //如果请求执行成功 if (this.status == 200) { var blob = this.response; var filename = "我是文件名.mp4";//如123.xls var a = document.createElement('a'); //创键临时url对象 var url = URL.createObjectURL(blob); a.href = url; a.download=filename; a.click(); //释放之前创建的URL对象 window.URL.revokeObjectURL(url); } }; //发送请求 xhr.send(); } &lt;/script&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70a046c13ef7c101eaa7c0ea78d7608d/" rel="bookmark">
			【全栈接口测试进阶系列教程】postman接口测试实战cookie，token，session鉴权，Base64，MD5，RSA加密，Sign签名，持续集成postman&#43;Newman&#43;jenkins
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
【一：postman简介和安装以及postman的登录和注册】
一、postman下载
二、安装、注册/登陆
三、简单使用
1.postman模拟发送get请求：
2.postman模拟发送post请求：
3.post数据类型说明：
【二：postman发送get请求，post请求实战以及页签详解】
发送GET请求
响应页面
发送POST请求
【三：postman环境变量和全局变量】
1.在postman点击小齿轮，再选中manage environments　进入到环境变量添加环境变量。
２、添加测试环境的名称，变量名和对应的值。
３、做接口请求，切换到当前的测试环境下，把变量ｕｒｌ　添加
全局变量设置步骤
１、点击小眼睛进入到环境变量添加页面，点击add添加环境变量
２、新增环境输入变量名称和变量值
【四：postman三种接口关联的方式和实战详解】 一、为什么要做接口测试？
二、目前市面工具
三、接口测试
四、组合API（接口关联，接口串联，上一个接口的返回值作为下一个接口的参数）
1. json提取器
2. 正则表达式提取器
3. cookie提取器（通过cookie来取值）
五、动态参数
六、扩展
1.cookie关联2.断言3.自定义动态参数4.csv数据驱动
5.带请求头的接口6.mock7.cookie鉴权8.加密9.sign签名10.postman+newman+git+jenkins持续集成（也叫接口自动化或接口测试）
七、postman,jmeter都有，很强大，很好用，做什么接口自动化？
【五：postman内置动态参数以及自定义动态参数】
【六：postman常规断言。动态参数断言以及全局断言】 【七：postman必须带请求头的接口测试实战以及常用请求头详解】 【八：postman流程控制语句】
流程控制
postman.setNextRequest('下一个接口名');
调试
公共函数
外部数据文件
【九：postman接口测试实战之csv或json文件实现数据驱动】 【十：postman接口测试实战之前置脚本】 前置脚本
九、接口关联
[十一：postman后置脚本]
【十二：】 postman之cookie，token，session鉴权
一、鉴权 、授权
1、cookies 和 session
2、token 鉴权
【十三：postman之console日志查看和应用调式】
[十四：postman之mcok server自定义接口服务器]
【十五：postman接口测试加密（base64.md5.rsa等）】
RSA签名就写这些，接下来写AES加密。
【十六：postman接口签名sign接口测试实战】
【一：postman简介和安装以及postman的登录和注册】 一、postman下载 postman分为chrome插件版本和客户端版本。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70a046c13ef7c101eaa7c0ea78d7608d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cf5365bccd7a0394d04b168b55f4ebf/" rel="bookmark">
			论坛回顾｜蚂蚁供应链安全建设实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文整理自 OSCS 软件供应链安全技术论坛- 边立忠（京蛰）老师的分享《蚂蚁供应链安全建设实践》。
边立忠，蚂蚁集团高级安全专家，蚂蚁集团应用安全产品中台负责人，主要负责蚂蚁 SCA、IAST、SAST、镜像安全扫描等供应链安全相关产品的建设和技术研究。
大家好，我是边立忠，很高兴今天有机会给大家做一个软件供应链安全相关的分享。
我在蚂蚁主要负责 DevSecOps 的工具链，或者叫工具矩阵的建设，以及供应链相关的产品建设。所以今天带来的软件供应链安全建设除了囊括我团队负责的这一部分以外，还会囊括蚂蚁其他在供应链相关的建设的内容。今天我作为代表，整体来给大家做这样一个分享和介绍。
将从以下几个部分来进行分享：
蚂蚁供应链安全概述：风险、挑战、建设思路；风险检测；安全管控；纵深防御；Log4j经典案例：如何被应急响应、处置和管控风险 蚂蚁供应链安全概述 软件供应链安全范畴 蚂蚁从供应链相关的风险来区分供应链安全，对我们实际的业务造成了安全影响，就把它定为一个供应链安全相关的范畴。
蚂蚁当前最大供应链风险：代码的直接或间接依赖、三方软件。
直接依赖会直接影响业务可信，其中包括：
源代码代码的直接依赖运行时系统软件容器镜像及OS底层硬件设备 间接依赖间接影响业务可信，其中包括：
研发工具、平台代码的间接依赖制品下载分发平台人、角色制品更新平台 次间接依赖存在更多的攻击渠道，其中包括：
人所处物理环境人使用的设备人所在网络环境间接依赖的上下游…… 随着蚂蚁整个应用的量级、业务的量级不断增长、不断膨胀，直接依赖同样有着非常大的增长。在直接依赖本身增长的前提下，间接依赖和次间接依赖就会呈几何量级出现爆发式增长。这种爆发式增长的上下游依赖，给我们带来了难以穷举的防护目标。
但是从历史的 case 来看，其实蚂蚁供应链最大的风险一方面是来自应用的直接依赖和间接依赖，另一部分是来自于三方软件。所以说今天我的分享是会围绕这个范畴来给大家展开。
软件供应链风险态势 第一，软件的下载量逐年呈现快速增长。软件本身在增长的前提下，软件的量级增长，就会引入错综复杂的应用的供应链关系。
另一个是供应链的攻击事件。供应链的安全事件也在逐年呈指数级增长。并且它的攻击手法更加的隐蔽，影响范围也更加广泛。
以下列出了从 15 年到 21 年的比较严重或者说大家认知、感受比较明显的供应链的事件。对于蚂蚁来说，从安全的维度供应链的风险分为两类，一类是漏洞，另一类是供应链的投毒。那后面也是会围绕这两个方向给大家展开来做介绍。
蚂蚁供应链安全防护体系 对于应对漏洞以及投毒的风险，蚂蚁是如何进行防护的 。
整个供应链安全防护体系主要分为三个部分（三位一体的防护体系），包括风险监测（发现风险）、安全管控（控制风险）以及纵深防御（化解风险），每一部分需要的一些工具能力如下图。
就像是当下的疫情防控的几个阶段，核酸检测-风险管控-疫情治疗。
风险检测-发现风险
情报监控/收集潜在供应链漏洞挖掘供应链投毒检测影响面快速排查 安全管控-控制风险
供应链组件准入供应链组件引用准入 市面上的开源供应链到底有哪些风险、哪些有风险，哪些没风险，我哪些应该管控。所以中间总会存在一些漏网之鱼，或者说总会存在预期之外的情况。但是对于蚂蚁金融属性非常强的公司来说，这样的风险遗漏是无法承受的。我们就提出了纵深防御的概念，我们需要通过纵深防御的理念，在真正发生风险的时候，供应链的组件实际触发风险的时候，能够来对风险进行管控。
纵深防御-化解风险
攻击检测攻击阻断风险隔离 三位一体的防御体系，最终达到的目的是风险的发现，控制风险以及风险的化解。
风险检测 供应链安全检测产品矩阵 这是我们供应链安全检测的整个的产品矩阵，可以分成上中下三部分来理解。
首先上面是各个业务，同时这些供应链的产品为了服务业务线，我们实现了独立部署平台化，包括多租户的 SaaS 化模式。
另一个当供应链风险发生的时候，需要检测的范围是什么？所以说我们会有自己的资产平台，围绕我们保护的资产到底要什么？举个例子：首先我们知道 URL 和域名是什么、 URL 和域名对应的 IP 是什么、 VIP 对应的主机是什么、主机开的端口是什么、端口所对应的进程是什么、进程上跑的应用是什么？应用哪些、接口包括应用的代码库是什么、数据是不是敏感数据、能够访问到的数据用到的数据是什么？基于这样的资产的透视，我们就可以知道要保护的目标是什么。
基于我们保护的目标，就会去构建整体的供应链的检测产品。供应链检测的产品也可以分为上下两个部分来解读。下面这部分更多是说我们实际发现哪些组件存在供应链的风险。这中间就包含了我们要做情报的收集，情报的监控，包括自研的收集渠道，外采的渠道，以及墨菲合作的情报收集、监控。并且情报是需要有研判的，因为很多 cve 的漏洞，这些情报好多都是实际没有什么风险的，没有实际攻击的链路，但是它也会被作为一个情报公开出来。所以说情报首先是需要做研判的，另外也会对公开的情报、非公开情、潜在非公开漏洞或潜在漏洞的进行研究。
这里就涉及到了工业软件的可证，基于我们污点建模的能力，构建出了静态和动态的跟踪能力，包括重打包的能力。前面的老师也有讲到说，那我这有一个包，比如说我有 Fastjson 这个包，我拿过来内部改一改，直接把代码引入到我的项目里面去。那这其实也是一个供应链的问题，我们也会有这样代码相似度的检测，在里头去发现重打包的一些问题。
另一个我们会有一些投毒检测，它包含了通过底层的操作系统切面，包括一些应用的切面，在实际的运行过程当中去感知它有没有投毒的行为。这中间就包含安装的检测、 query 的检测，以及函数实际调用过程当中 fuzz 的检测。那么基于这个能力，上半年总共检测出来 1000 多个存在投毒的 node 的组件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cf5365bccd7a0394d04b168b55f4ebf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1436087667e18a0b3c9205253b12a6fa/" rel="bookmark">
			微信小程序Smartconfig配网实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SmartConfig配网小程序开发 操作场景 基本原理 设备进入 Wi-Fi 混杂模式（promiscuous mode）以监听捕获周围的 Wi-Fi 报文。由于设备暂未联网，且 Wi-Fi 网络的数据帧已通过加密，设备无法获取 payload 的内容，但可以获取报文的某些特征数据，例如每个报文的长度。同时对于某些数据帧，例如 UDP 的广播包或多播包，其报文的帧头结构比较固定，较容易识别。此时在手机 App 或者小程序侧，即可通过发送 UDP 的广播包或多播包，并利用报文的特征，例如长度变化进行编码。将目标 Wi-Fi 路由器的 SSID/PSW 字符以约定的编码方式发送出去，设备端在捕获到 UDP 报文后，按约定的方式进行解码，即可得到目标 Wi-Fi 路由器的相关信息并进行联网。 设备绑定流程 SmartConfig 方式配网，每个厂商的编码方式和报文选择上有自己的协议，对于 ESP8266，采用的协议是乐鑫 ESP-TOUCH协议。
基于该协议，设备端在连接 Wi-Fi 路由器成功后，将会告知手机端自己的 IP 地址。目前本小程序已支持采用 ESP-TOUCH 协议进行 SmartConfig 配网。
SmartConfig 方式配网及设备绑定的示例流程图如下：
为了减轻局域网络负担，本实现采用组播方式，组播地址生成代码如下：
let _count = 0 function getTargetHostname() { _count %= 100 _count++ return `234.${_count}.${_count}.${_count}` }; 乐鑫ESPTOUCH编码原理时将ssid字符串转成ASCII编码数据流，加入CRC，AP的MAC地址本身就是16进制数据无需转换ASCII码，IP地址转整型数据。最终生成的数据流转换为uint16后，利用uint16去调制udp数据包长度代码如下：
function toDatumCode(apSsid, apBssid, apPassword, ipAddress, isSsidHidden = false) { let totalXor = 0 const apSsidRaw = bufferFromString(apSsid) const apSsidCrc = crcBuffer(apSsidRaw) const apSsidLen = apSsidRaw.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1436087667e18a0b3c9205253b12a6fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5a28e5cf8ba1cff6a917d5a3a67e927/" rel="bookmark">
			Ubuntu 安装 intel 编译器并配置Set Environment Variables
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载 intel 编译器
Free Intel® Software Development Tools
下载Base Toolkit for Linux
Command Line Download Command Line Installation Parameters
wget https://registrationcenter-download.intel.com/akdlm/irc_nas/18679/l_HPCKit_p_2022.3.0.8751_offline.sh sudo sh ./l_HPCKit_p_2022.3.0.8751_offline.sh Installation Instructions The initial download is for the installer application files only. The installer will acquire all the tools during the installation process.
SStep 1: From the console, locate the downloaded install file.
Step 2: Use $ sudo sh ./&lt;installer&gt;.sh to launch the GUI Installer as root.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5a28e5cf8ba1cff6a917d5a3a67e927/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19bb548810de17f63fa7638a5179b2a8/" rel="bookmark">
			Twaver 区域点击事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 区域点击事件 您可以把这个区域，注册成一个图片，然后设置成网元设置成这个图片。
参照官网： http://doc.servasoft.com/twaver-document-center/recommended/twaver-html5-guide/vector-and-data-binding/
2. 代码 network.addInteractionListener(function (e) { if (e.kind === 'clickElement') { if (e.element === "您想要的网元") { // code start here } } }); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e352af3188de752f514f181b0a89c25/" rel="bookmark">
			参数分布估计方法(矩量法和极大似然方法)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 分布的概念要解决的问题解决方法一(矩量法)解决方法二(极大似然方法） 分布的概念 ​ 首先，我们要了解一下，我们所要求的分布就是一个什么东西。
​ **分布的表示：**P(x)
​ P(x)表示该分布中采样到样本x的概率，试想如果我们知道该分布中每个样本的采样概率，那么这个分布也就可以以这种形式表示出来了。
​ **含参分布的表示：**P(x;θ)
​ 其中θ 表示该分布的参数，一般这参数是待估计的，比如 P(x;θ) 可以是高斯分布， θ = [ μ , σ ] \theta=[\mu, \sigma] θ=[μ,σ],就是高斯分布的均值 μ \mu μ和方差 σ \sigma σ。
要解决的问题 给定一个数据分布 P d a t a ( x ) P_{data}(x) Pdata​(x)
假设一个由参数 θ θ θ定义的数据分布 P G ( x ; θ ) P_G(x;θ) PG​(x;θ)， θ \theta θ是未知的
我们希望求得参数 θ θ θ使得 P G ( x ; θ ) P_G(x;θ) PG​(x;θ)尽可能接近 P d a t a ( x ) P_{data}(x) Pdata​(x)、
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e352af3188de752f514f181b0a89c25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99342cc8eca28b1d999e03a73f9b45fd/" rel="bookmark">
			为什么你的程序跑不满CPU？——简单聊聊多核多线程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近同事测试自己的程序，感觉处理耗时太长，一看CPU使用率，才25%。想要提高CPU使用率降低处理时长，于是向我询问。以此为契机写了这篇，聊聊多核多线程。水平有限，仅供参考。
1.单核单线程 一切开始的前提是，你需要知道，CPU执行的所有代码其实就是一条条指令。
首先来聊聊单核单线程下你的程序是怎么运行的。假如你的程序就两行代码：
b=a+1;
c=b+1;
而你的CPU每运行一行代码需要1秒，那么很明显，对于单核CPU来说，运行你的代码需要2秒。但实际上这往往需要2秒多，因为你的CPU还需要处理很多可能的中断，比如当你的CPU刚执行完b=a+1时， 这个时候插入了一台USB设备，它触发了一个中断，中断你可以简单理解为一个函数，这里的USB中断你可以理解为，插入了USB就要执行一个“USB函数”，这个过程不受控制（实际过程复杂的多）。一般来说中断优先级是高于你的用户代码的，所以CPU只能转头去执行USB函数中的代码，这个时候你的代码才执行到了一半，当执行完USB函数后，CPU才会转头回来继续执行你的代码。最终你的代码可能运行了3秒甚至更久。
2.单核多线程 你可能觉得2秒甚至更久的时间对你的程序来说太长了，那是否可以使用多线程优化程序的执行？
其实仔细想一下就知道，无论使用多少个线程，假如CPU每执行一行代码就是1秒，那这两行代码怎么也得要2秒。所以单核情况下，多线程并不会提高代码执行效率。单核多线程的意义在于，当你的代码中有需要等待的地方，CPU可以在等待时去做其他事，这里你需要知道，CPU调度的最小单位是线程。比如上文中的例子假如是这样：
b=a+1;
sleep(1);
d=c+1;
正常你用单个线程去跑这段代码假如需要3秒，最后我们需要的结果是b和d，但很明显d=c+1在这里需要等待sleep休眠1秒后才能计算，而实际上这行代码和前文并没有数据上的关联和依赖。如果此时我们用两个线程，线程1跑【b=a+1;sleep(1)】，线程2跑【d=c+1】，虽然我们的CPU是单核的，意味着同一时间只能跑一行代码，但是在线程1运行完b=a+1后，sleep时，CPU可以转去执行d=c+1，这样最终我们只用了2秒就可以得到b和d的结果，此时多线程的运用相当于填补了CPU执行sleep等类似的等待过程。
单核多线程的另外一个意义是可以做到多个线程“同时”进行，注意这里的同时是加引号的。这种情况下每个线程如果优先级相同，则它们可能消耗相同的时间片，你可以把时间片简单理解为每个线程每次能够运行的最大时间。这适用于对时间不敏感，但是强调了同时的程序。比如你的代码是这样的：
b=a+1;
d=c+1;
f=e+1;
h=g+1;
很明显这段代码运行需要最少4秒，上文我说过，使用多线程并不能缩短这个时间，但是你希望【b=a+1;d=c+1】和【f=e+1;h=g+1】这两段代码“同时”执行，这种情况下使用多线程也是可以的，假如时间片=1秒，如果把这两段代码分别放在两个线程，且它们优先级相同，则CPU的执行顺序可能是这样的：
第一秒：先执行线程1的b=a+1;
第二秒：线程1的时间片消耗完了，CPU转去执行线程2的f=e+1;
第三秒：线程2的时间片消耗完了，CPU转去执行线程1的d=c+1;
第四秒：线程1的时间片又消耗完了，CPU又转去执行线程2的h=g+1;
最终CPU还是消耗了4秒执行上述代码，但是却是两个线程交替执行。这在某些场景，比如播放电影（我们需要播放画面的同时，播放音频）时，是很有用的。
单核情况下的多线程叫做并发。也就是所谓的单核多线程其实只是在同一个CPU上交替执行多个线程，但实际是，在任意时间点，只能有一个线程执行，只不过CPU切换的速度很快，给你造成一种多个线程同时运行的假象。只有多核才能做到真正意义上的同时运行。更多细节可以搜索并发与并行的区别。
3.多核单线程 假如你有一个四核CPU，每个核还是1秒执行1行代码，而你的代码是：
b=a+1;
c=b+1;
e=d+1;
f=e+1;
如果把这四行代码放在一个mian函数里执行，你会发现CPU在程序执行的时候，只有25%。这是否是因为有3个核压根就没有工作？
其实不然，这种情况下，无论是只使用1个核还是四个核都使用，CPU使用率最多都是25%。为什么？
假如你的程序只放在第一个核上运行，这很好理解：
表1 时间CPU0使用率CPU1使用率CPU2使用率CPU3使用率第1秒100%0%0%0%第2秒100%0%0%0%第3秒100%0%0%0%第4秒100%0%0%0% 4秒内，CPU实际可以执行16行代码，而实际只有CPU0执行了4行，所以CPU在4秒内总的使用率为4/16=25%。
假如你的程序在4个核上运行，则可能是：
表2 时间CPU0使用率CPU1使用率CPU2使用率CPU3使用率第1秒100%0%0%0%第2秒0%100%0%0%第3秒0%0%100%0%第4秒0%0%0%100% 同样的也是25%。你可以能会好奇为何CPU不是按下面的方式运行的：
表3 时间CPU0使用率CPU1使用率CPU2使用率CPU3使用率第1秒100%100%100%100%第2秒0%0%0%0%第3秒0%0%0%0%第4秒0%0%0%0% 在这种情况下，我们统计CPU占用率的周期很重要，如果以4秒为一个周期，那CPU使用率还是25%，如果以1秒为周期则第一秒使用率是100%，后面3秒使用率都是0%。但我们最关心的还是这种情况下可以把程序执行需要4秒给缩短到1秒。但这种情况是不可能发生的，当你使用单线程写了一个程序时，就注定了你的每行代码都要依次执行（这里不考虑CPU乱序执行，且就算乱序也不影响），你的第二行代码就必须等第一行代码执行完毕才能执行，无论第一行代码或是第二行代码在哪个CPU上执行！所以，无论以哪种情况来说，你的CPU从你的代码开始到结束，占用率最多25%，且必须耗时4秒甚至更久才能执行完。
4.多核多线程 按照上面的说法，我们是否可以把4行代码分别放在四个线程中，这样岂不是可以实现表3？
实际是可以实现的，但可惜的是，计算结果是错误的。因为我们可以看到，4行代码里面，数据是有依赖关系的，计算c之前需要保证先计算b，计算b之前，需要保证a是正确的。这就是所谓的线程间同步。所以即使是使用4个线程，为了使计算结果正确，我们也没有办法做到耗时1秒。
在这个例子中，假如我们把四行代码分别放在四个线程中，然后四个线程分别在4个核上运行，比如第一个核上运行线程1，执行的是第一行代码，以此类推。
那我们的代码在实际考虑数据依赖关系后，很可能是：
第一秒，线程1执行，其他线程都等待，也就是虽然其他线程放在其他核上，但是其他核使用率仍然为0%。
第二秒，线程1执行完毕，告诉了线程2，然后线程2开始执行，此时CPU0、2、3核都没在使用。
第三秒，线程2执行完毕，告诉了线程3，然后线程3开始执行，此时CPU0、1、3核都没在使用。
第四秒，线程3执行完毕，告诉了线程4，然后线程4开始执行，此时CPU0、1、2核都没在使用。
其中一个线程如何告诉另一个线程可以搜索线程（进程）间同步方式相关资料。
我们看下来，发现好像使用多线程也并没有缩小耗时，也就是说，如果你的程序执行有数据依赖关系的，多线程并不能优化执行效率，因为你后面的代码即使可以执行，也无法执行，因为它要等待前面的代码计算完成，用前面的计算结果继续计算。
细心的你可能发现，上面例子中第三行代码并不需要等待第二行代码执行完毕，因为c=b+1和e=d+1并没有关系，也就是第二行代码必须等第一行计算完毕，第四行代码必须等第三行计算完毕，但是前两行和后两行并没有一点关系，那我们完全可以把第1、2行代码放在线程1中，运行在其中一个核上，把第3、4行代码放在线程2中，运行在另一个核上，最终CPU使用率是：
表4 时间CPU0使用率CPU1使用率CPU2使用率CPU3使用率第1秒100%100%0%0%第2秒100%100%0%0%第3秒0%0%0%0%第4秒0%0%0%0% 之前的多核单线程中，程序需要运行4秒，总体CPU使用率25%，现在程序只需要运行2秒，总体CPU使用率50%。此时才把多核多线程优势完全发挥出来。
这是否就是多线程优化极限了？
其实在特殊情况下，还可以再次优化。
多级流水线 很多情况下，我们的程序需要处理的数据是流式的，比如音视频，也就是数据会每隔一定时间来一帧，而我们的程序需要每来一帧处理一次，这个时候如果数据来的时间大于数据处理的时间，我们可以仿照CPU的多级流水线的设计思路优化我们的处理。 按照我们上文的例子，假如我们的处理流程是这样的：
在这里，a和d每隔2秒来一次的话是可以正常输出c和f的值的，如果a和d每隔1秒来一次的话，等到下一次数据来，我们上次数据还没有计算完成，肯定会卡顿，导致数据丢失，而且这种情况无法通过缓存输入数据解决，因为这会越堆积越多。但是如果我们按照下面的思路修改：
程序运行流程是这样的：
第一秒：第一帧数据到来，线程1和线程3执行，因为没有线程1和3的结果，线程2和线程4运行跳过，最终没有输出c、f，CPU使用率50% 第二秒：第二帧数据到来，线程1和线程3计算第二次来的数据，线程2和线程4计算上一轮中线程1和线程3输出的数据，最终输出第一帧数据对应的c、f，CPU使用率100%
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99342cc8eca28b1d999e03a73f9b45fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b20a622982f9e9b1e131febcfe16b2e2/" rel="bookmark">
			安卓逆向-某音乐软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初学安卓逆向，如有错误请指教 某我音乐9.3.4.4版本，需要资源的请流言（也可以自行去下载）
直接将apk拖入到AndroidKiller里面(该工具自行下载)
首先去除广告
直接全局搜索KEY_EXTRA_AUTH，可以只在.smali文件里面搜索
可以看到后面进行了判断，只要相等就会跳转，我们这里直接注释掉，或者改为if-ne
然后是破解主题
全局搜索下载并使用(这里要转码，不然搜索不到)
看到进行了直接跳转，直接注释掉
主题破解完成,然后保存再次回到搜索界面,开始解锁VIP
搜索isOverseasDownloadVIP这个方法名，点进去后把我框选的代码改为const/4 v0, 0x1(原本的代码为const/4 v0, 0x0,也就是把结尾0改为1)
然后一直向上滑,找到isDownloadFree(注意,这个方法名在比较上面的地方,不是isOverseasDownloadVIP上面的那一个)，修改方法同上 下面还是解锁VIP,搜索我们都很熟悉的isVIP,并在779行处强行赋值: 代码const/4 v0, 0x1 然后搜索getviptype,经过分析跳转，在该.smali文件下加入代码
全局搜索订单支付成功(同样需要转码)
可以看到成功代表的是:pswitch_1
全局搜索:pswitch_1，并将所以都改成:pswitch_1(这里是已经修改好的)
保存进行编译
编译成功（但是安装后笔者显示网络错误，可能是已经修复的原因，或者哪里出现了错误，敬请指教）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cb1a542a50193ce55fb6bae67ec3173/" rel="bookmark">
			word导航窗格应用：如何对文档进行快速查找定位？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导航，已成为我们日常生活中必不可少的一部分，平常出门游玩时，若要寻找陌生地点，开个导航就可以解决问题。
那么，如果要在Word中快速定位并找到自己需要的内容，又该怎么办呢？
在这里向大家介绍一个超实用的功能——【导航窗格】，它是文档的GPS，不仅集成了查找、定位功能，并且还可以对文档结构进行快速调整，对提高工作效率十分有帮助哦！
一、如何打开【导航】窗格？
Word看打开【导航】窗格通常有2种方法：
方法1：点击【视图】-【显示】选项卡，勾选【导航窗格】复选框，即可显示导航窗格；取消勾选则会隐藏导航窗格。
方法2：直接按【Ctrl+F】组合键可快速调出【导航窗格】。
二、使用导航窗格实现快速定位
在导航窗格中，提供了3种导航方式：标题、页面和结果，其作用分别如下：
1.标题导航
如果你文档中的内容设置了级别，那么，在导航窗格中就会显示有类似目录一样的标题列表，点击对应标题可快速定位并浏览相应章节的内容。
2.页面导航
除了使用标题快速定位外，在页面导航下，可以通过页面快速定位，点击可跳转到具体页。
3.结果导航
可在搜索框中输入关键词快速定位，Word会自动在“结果”窗口下显示出含该关键词的所有内容，并对搜索词进行加粗显示。
此外，除了可以定位搜索文字之外，点击搜索框右侧的“放大镜“图标，还可以查找和定位图片、表格、批注、公式、脚注等。
三、使用导航窗格快速调整文档结构
1.章节顺序切换
编辑文档时，若发现某两节内容的逻辑顺序不对，想要调换一下。这时候，可直接在导航窗格中进行调整。
在【导航】-【标题】栏下，使用鼠标左键选中需要调整的章节标题，长按并上下移动到指定位置即可。
2.章节的结构性操作
在【导航】-【标题】栏下，点击鼠标右键，你会发现隐藏的“新大陆”。
①大纲级别的升降：选中某个标题，单击鼠标右键，选择“升级”或“降级”选项，便可调整标题的大纲级别。在显示上表现为“向左缩进”距离变长为“升级”，“向左缩进”距离变短为“降级”。
②内容增减：点击“新标题之前/在后面插入新标题”选项，可以在当前标题前后新增同等级别的标题；点击“新增副标题”选项 ，则可在当前标题下增加子标题；点击“删除”选项，可删除当前章节及其内容。
③内容选择与打印：有时，当只想打印某章节的内容，可以不用在文档中选定该章节的内容后再打印，可直接在“导航窗格”中快速选择并打印。
只需在需要打印的章节上单击鼠标右键，然后选择“打印当前标题及内容”选项即可。
④显示设置：通过“全部展开/折叠”选项可对标题列表的显示进行调整。
至此，导航窗格的常用功能就介绍完了，你学会了吗？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/506a4cace1089c80d04a80b1225c51ea/" rel="bookmark">
			java 客户端调用minio服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		maven项目引入jar 依赖
&lt;dependency&gt;
&lt;groupId&gt;io.minio&lt;/groupId&gt;
&lt;artifactId&gt;minio&lt;/artifactId&gt;
&lt;version&gt;8.3.5&lt;/version&gt;
&lt;/dependency&gt;
一、链接客户端
//构造方法 minio客户端
MinioClient minioClient = MinioClient.builder()
.endpoint("http://youduk1:9029")
.credentials("admin", "admin456789")
.build();
System.out.println("客户端链接成功");
MinioClient minioClient =
MinioClient.builder()
.endpoint("https://play.min.io:9000")
.credentials("Q3AM3UQ867SPQQA43P2F", "zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG")
.region("eu-east-1")
.httpClient(customHttpClient)
.build();
二、桶操作
1、判断桶是否存在
boolean found =
minioClient.bucketExists(BucketExistsArgs.builder().bucket("my-bucketname").build());
if (found) {
System.out.println("my-bucketname exists");
} else {
System.out.println("my-bucketname does not exist");
}
2、创建桶
// 创建桶
boolean boo = minioClient.bucketExists(BucketExistsArgs.builder().bucket("my-bucketname1").build());
if (!boo) {
minioClient.makeBucket(MakeBucketArgs.builder().bucket("my-bucketname1").build());
System.out.println("my-bucketname1 is created successfully");
}
//创建桶指定区域
if (!minioClient.bucketExists(
BucketExistsArgs.builder().bucket("my-bucketname-in-eu").build())) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/506a4cace1089c80d04a80b1225c51ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bc33ead0722cc53d968eeaeac8f3bc5/" rel="bookmark">
			网络编程套接字Socket(通过两个用例,逐行注释,详细理解)干活满满建议收藏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言1.分类1.流套接字2.数据报套接字3.原始套接字 2.Socket通信模型 3.UDP套接字编程1. DatagramSocket API1.构造方法1.DatagramSocket()2.DatagramSocket(int port) 2.常用方法1.receive(DatagramPacket p)2.send(DatagramPacket p) 2. DatagramPacket API1.构造方法1.DatagramPacket(byte[] buf,int length)2.DatagramPacket(byte[] buf,int offset,int length,SocketAddress address) 2. 常用方法1. getAddress()2.getPort()3.getData() 3.InetSocketAddress API1.构造函数2.可用方法 4.TCP套接字1.ServerSocket API1.构造方法2.常用方法1. accept()2. close() 2.Socket API1.构造方法2.常用方法1.getInetAddress()2.getInputStream()3.getOutputStream() 5.UDP示例(实现回显服务器和词典功能)1.服务器端的示例2. 客户端的示例 6.TCP示例(实现词典功能)1.服务器示例2.客户端示例 7.结果执行展示 前言 `Socket套接字,是系统提供的用于网络通信的技术,是基于TCP/IP协议的网络通信的基本单元,基于Socket套接字的网络程序开发就是网络编程,Sevrlet是socket的一种应用
1.分类 Socket套接字分为三类
1.流套接字 传输层使用TCP协议,对于字节流来说,传输流是基于IO流
流式数据的特征在流没有关闭的情况下,可以多次发送,切没有边界,也可以分开发送
具体TCP的特征可以看我前面的文章
2.数据报套接字 传输层使用UDP协议
对于数据来说,可以理解成是发送数据和接受数据都必须一块一块的接受和发送,切不能分次
3.原始套接字 原始套接字用于自定义传输层的协议,用于读写内核没有处理的IP协议数据
2.Socket通信模型 这张图可以很好的展现出由TCP建立连接的通信模型
3.UDP套接字编程 UDP套接字编程,我们的java给我们提供了一个API叫做DatagramSocket
1. DatagramSocket API 1.构造方法 这个API有5个构造方法,但是我们只需要学习2个
我们可以去Java的官方文件中查看
这里只需要学习划红框的两个即可
1.DatagramSocket() 这个是将我们的数据包套接字绑定到我们本地的随机端口,一般用于客户端
2.DatagramSocket(int port) 这个是将我们的数据包套接字绑定到我们本地的指定端口,一般用于服务器
这里可能优点抽象,不过没关系,我们根据下文中的示例来理解,就会清晰很多
2.常用方法 这里我们DatagramSocket的方法有很多,但是我们只需要知道三个常用的就行了
1.receive(DatagramPacket p) 这个方法是从套接字中接受数据包,括号内的参数就是套接字,结果会传回到参数中去
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bc33ead0722cc53d968eeaeac8f3bc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c54ea4ebbfc88f840a5ede60c4f78d8a/" rel="bookmark">
			SSM框架项目实战-CRM(客户关系管理1)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录​​​​​​​ 1 项目介绍
1.1 crm简介
1.2 业务流程
1.3 crm的技术架构
2 物理模型设计
2.1 crm表的结构
2.2 主键字段
2.2 外键字段
2.3 关于日期和时间的字段
3 搭建项目环境
3.1 添加maven依赖
3.2 添加配置文件
3.3 添加页面和静态资源
​编辑
4 首页index
5 登录功能
5.1 登录页面
5.2 登录功能
5.2.1 添加mybatis逆向工程
5.2.2 编写service层和mapper层
5.2.3 实现controller层
5.2.4 实现页面层
5.2.5 优化登录功能
5.3 登录后显示名称
5.4 实现回车登录
5.5 记住密码功能
5.6 安全退出
5.7 登录验证功能
注意：本次项目是观看的是动力节点的视频：CRM-首页功能分析与设计_哔哩哔哩_bilibili
1 项目介绍 1.1 crm简介 CRM(Customer Relationship Management)客户关系管理是管理企业与客户之间关系的新型管理机制。终极目标是吸引新客户、保留老客户以及将已有客户转变为忠诚客户，以增加市场份额。它是一个完整的客户关系管理系统，包括市场、销售、服务3大环节，产品成熟，操作简单，功能强大。帮您从客户全生命周期的各个阶段获取价值。
1.2 业务流程 市场活动:市场部人员。
线索：销售部人员。(线索购买意愿非常强烈的时候，可以转换)
客户：线索中的公司信息
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c54ea4ebbfc88f840a5ede60c4f78d8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef401c12b7572dd581c9c3e62cc16812/" rel="bookmark">
			从0开发一个Django博客系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、项目准备
1.1 项目分析
1.2 工程创建和配置
二、注册
2.2 定义用户模型类
2.3 图形验证码
2.4 短信验证码
2.5 用户注册实现
2.6 展示首页
2.7 状态保持
三、登录
3.1 手机登录
3.2 首页用户名展示
3.3 退出登录
四、忘记密码
五、用户中心
5.2 用户中心修改
六、写博客
6.1 写博客页面展示
6.2 文章分类模型
6.3 文章分类后台管理
6.4 写博客页面展示分类
查询数据并展示
6.5 文章模型
6.6 博客保存
七、博客首页
7.1 首页分类数据展示
7.2 首页文章数据展示
八、博客详情
8.1 详情页面展示
8.2 404页面展示
修改查询不到数据返回的响应
8.3 推荐文章数据展示
8.4 评论模型
8.5 发表评论
8.6 详情评论数据展示
一、项目准备 1.1 项目分析 需求分析原因 项目中，需求驱动开发。即开发人员需要以需求为目标来实现业务逻辑。 需求分析方式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef401c12b7572dd581c9c3e62cc16812/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ff19c62775d308378445a6f5d666b47/" rel="bookmark">
			Wireshark导出rtp音频数据并使用Audacity分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近调试B-CALL走RTP传输遇到一些问题，如何从抓包的数据导出rtp音频数据进行分析记录一下 一 相关工具 wireshark version 4.0.2
Audacity 3.2.2
二 wireshark导出RTP音频流原始数据 打开已抓取的pcap文件，过滤出RTP协议报文 选择“电话”---“RTP流分析” 选择“Play Streams”弹出RTP播放器窗口，选择“Export”---"Payload"导出RAW文件 三 Audacity分析RTP音频数据 用Audacity导入文件分析 使用“Detect”自动检测编码等属性，然后“导入” 然后分析音频数据，比如播放声音是否正常等 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0b133286da87330b692ae681dd6602c/" rel="bookmark">
			获取微信公众号历史文章列表页链接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通用公式：https://mp.weixin.qq.com/mp/profile_ext?action=home&amp;__biz=这里替换你的biz==
Tips:红字内容为下面找到的biz值，切记蓝色双‘==’必须要有，不然无法使用
1、复制公众号任意文章的链接在浏览器打开
2、浏览器右键查看网页源码，新开页面搜索（常规浏览器快捷键ctrl+f）‘biz=’，如下图找到红框部分值，复制即为上文biz值
3、拼接通用公式生成链接即为微信公众号历史文章列表链接，例：验证https://mp.weixin.qq.com/mp/profile_ext?action=home&amp;__biz=MjM5NTYxNDUwNQ==
4、链接分享、发送到微信即可访问，注意该链接仅可在微信客户端使用，外部浏览器无法打开
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c50c9b0bd339366cd6ebdb7657c88d90/" rel="bookmark">
			怎么才能用C语言敲Hello Word呢?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		章节目录 第一个C语言程序数据类型变量&amp;常量定义变量的方法初始化的区别变量的分类变量的命名规则常量变量的使用作用域和生命周期 字符串和转义字符字符串转义字符 注释注释风格 选择语句循环语句函数数组数组的使用 关键字常见关键字关键字[typedef](https://cplusplus.com/doc/tutorial/other_data_types/)关键字static 人与人之间沟通,使用的语言分为汉语，英语，日语等一系列语言，而C语言则是人与电脑之间沟通协作所使用的高级编程语言中的一种。
第一个C语言程序 例如下述代码，就是告诉电脑在屏幕上输出 Hello world！
#include &lt;stdio.h&gt;//包含头文件 int main()//主函数 { printf("Hello World！");//输出字符串 return 0; } 数据类型 char //字符数据类型 short //短整型 int //整形 long //长整型 long long //更长的整形 float //单精度浮点型 double //双精度浮点型 注意:这里的单双精度浮点型是指小数位后显示精度，单精度浮点型在使用时显示小数点位后值少导致精度丢失，所以称为单精度，双精度则是精度高称为双精度
（1）在内存中占有的字节数不同
•单精度浮点数在机内占4个字节
•双精度浮点数在机内占8个字节
（2）有效数字位数不同
•单精度浮点数有效数字8位
•双精度浮点数有效数字16位
（3）所能表示数的范围不同
•单精度浮点的表示范围：-3.40E+38 ~ +3.40E+38
•双精度浮点的表示范围：-1.79E+308 ~ +1.79E+308
（4）在程序中处理速度不同 一般来说，CPU处理单精度浮点数的速度比处理双精度浮点数快
在一个固定大小的盒子中，我们一般放入的东西都是刚好契合它的大小，如果放不下，我们就会更换一个适合他大小的盒子，数据类型也是同理，不同的数据类型大小也是不一样的，为了更灵活的使用有限的内存，也是为了更丰富表达生活中的各种值，所以衍生出了这么多不同的数据类型
#define _CRT_SECURE_NO_WARNINGS 1 #include &lt;stdio.h&gt; int main() { printf("%d \n", sizeof(char)); printf("%d \n", sizeof(short)); printf("%d \n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c50c9b0bd339366cd6ebdb7657c88d90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43e3eea35cb08ad61b76b4d22a3022a6/" rel="bookmark">
			3、Spring源码之lookup-method replace-method
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题抛出： 1、假如spring想在一个单例对象中引用原型对象如何实现呢？
我们都知道spring默认的对象都是单例对象、默认放到一级缓存中，假如一个单例Bean想要引用原型Bean, 就需要使用lookup-method 、replace-method.
注：源码跟踪示例使用配置文件方式 毕竟使用的方式千篇一律 有趣的原理才是万里挑一
源码跟踪： 提示：源码跟踪禁忌抠每一行代码 弄清源码功能整体的脉络思路就好
doCreateBean方法里面调用一个方法prepareMethodOverrides. public void prepareMethodOverrides() throws BeanDefinitionValidationException { // Check that lookup methods exist and determine their overloaded status. if (hasMethodOverrides()) { getMethodOverrides().getOverrides().forEach(this::prepareMethodOverride); } } ①通过跟踪代码逻辑：当前Bean的定义信息是否有methodOverrides，其实就是指的是Bean是否有lookup-method标签和reoplace-method标签。进入到prepareMethodOverride这个方法我当时都懵了，也没有对这两个标签进行处理逻辑啊，这里就是做了一个标记。官方翻译[将重写标记为未重载，以避免arg类型检查的开销。] 说实话我没看懂什么意思 不影响这里脉络. 这里我的理解标记MethodOverride的overloaded的属性为false 方便Cglib方法拦截器MethodInterceptor去处理MethodOverride 。
②这里为什么又提到Cglib呢 因为如果一个Bean有lookup-method 或replace-method，spring首先将这个Bean生成代理对象 放到一级缓存，这个代理对象设置了三个方法拦截器分别是NoOp、LookupOverrideMethodInterceptor、LookupOverrideMethodInterceptor
③这里还要说明 比如这个代理对象 具体会执行那个方法拦截器呢？ 这里就要用到Cglib的过滤器(setCallbackFilter)了 这里是MethodOverrideCallbackFilter，通过accept方法返回的int下标，用于指定调用哪个拦截器进行拦截处理。这里下标取值的方法 就是用到①里面的标记MethodOverride的overloaded的属性为false逻辑
实例化Bean的方法 instantiate @Override public Object instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner) { // Don't override the class with CGLIB if no overrides.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43e3eea35cb08ad61b76b4d22a3022a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28367d687f243e665d2e8bfabb0a6884/" rel="bookmark">
			lsyncd 详细介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		lsyncd lsyncd 简介 Lsyncd功能跟Inotify和Sersync相同，属于实时同步工具，但是Lsyncd功能更加强大，Lysncd 实际上是lua语言封装了 inotify 和 rsync 工具，采用了 Linux 内核 *（2.6.13 及以后）里的 inotify 触发机制，然后通过rsync去差异同步，达到实时的效果。Lsyncd最强大之处在于简单高效传输海量数据并且Lsyncd支持多种工作模式。
github 项目地址：https://github.com/axkibe/lsyncd
lsyncd 安装与程序环境 yum -y install lsyncd	# 该包属于epel仓库，如果没有需要提前配置好epel仓库 程序环境：
[root@localhost ~]\# rpm -ql lsyncd /etc/logrotate.d/lsyncd /etc/lsyncd.conf	# 配置文件 /etc/sysconfig/lsyncd /usr/bin/lsyncd	# 主程序 /usr/lib/systemd/system/lsyncd.service	# Unit FIle ... lsyncd 简单示例 角色IP主 lsyncd Server192.168.8.176备 rsync Client192.168.8.113 为了方便起见，在这里我关闭了Selinux和防火墙.
在 Server 端 编辑/etc/lsyncd.conf配置文件：
settings { logfile = "/var/log/lsyncd/lsyncd.log", statusFile = "/var/log/lsyncd/lsyncd.status", inotifyMode = "CloseWrite", maxProcesses = 8, } sync { default.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28367d687f243e665d2e8bfabb0a6884/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7469570acf6313466693b6b7c94b81d6/" rel="bookmark">
			Git拒绝在变基上合并不相关的历史
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问： 在 git rebase origin/development 期间，Git 显示以下错误消息：
fatal: refusing to merge unrelated histories Error redoing merge 1234deadbeef1234deadbeef 我的 Git 版本是 2.9.0。它曾经在以前的版本中工作正常。
如何使用新版本中引入的强制标志继续此变基以允许不相关的历史记录？
答1: huntsbot.com高效搞钱，一站式跟进超10+任务平台外包需求
您可以使用 --allow-unrelated-histories 强制合并发生。
这背后的原因是自 Git 2.9 以来默认行为发生了变化：
“git merge”用于允许合并两个默认情况下没有共同基础的分支，这导致创建现有项目的全新历史，然后被毫无戒心的维护者拉取，这允许将不必要的并行历史合并到现有项目中.该命令已被教导默认情况下不允许这样做，并在罕见事件中使用逃生舱口 --allow-unrelated-histories 选项，该事件合并了两个独立开始其生活的项目的历史。
有关详细信息，请参阅 Git release changelog。
知道合并更改，但此选项不适用于 rebase
是否有任何选项可以永久开启 --allow-unrelated-histories？
@jmarceli “因为这种“两个项目合并”是罕见的事件，所以没有添加始终允许这种合并的配置选项。”。所以不行。
我试图以这种方式为不同的 repo 合并一个分支，但它在我当前的分支上创建了一个新的提交，并且没有保留来自其他 repo 的历史记录。然后我从另一个 repo 中检查了一个本地分支，然后才合并它，突然出现了一个正常的合并提交。诡异的。
非常好，也适用于 git pull。在那次“罕见的事件中，合并了两个独立开始生活的项目的历史”。 git --work-tree="." pull --allow-unrelated-histories
答2: huntsbot.com – 高效赚钱，自由工作
在我的情况下，每次尝试的错误只是 fatal: refusing to merge unrelated histories，尤其是远程添加 Git 存储库后的第一个拉取请求。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7469570acf6313466693b6b7c94b81d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0af78d93179bba815c1e68549cde98b7/" rel="bookmark">
			软件测试最新复习【太原理工大学】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下内容均为老师直播内容，搬运！
目录
一、题型
二、小题
三、大题
一、题型 1. 单选题 15 个，每个 2 分，共 30 分。（老师说单选题比较简单）
2. 判断题 10 个，每个 1 分，共 10 分。（她说判断题更简单）
3. 填空题 10 个，每个 1 分，共 10 分。（需要简单记忆）
4. 简答题 4 个，每个 5 分，共 20 分。
5. 应用题 3 个，每个 10 分，共 30 分。
二、小题 1. 软件测试的目的是什么？（尽可能地发现并排除潜在的错误，它不是把所有的错误都测出来，而且也不可能把所有的错误都测出来）
2. 什么是导致软件缺陷的最大原因？（不是程序员，也不是测试的问题，而是需求规格说明书有问题，它是最原始的问题）
3. 测试用例主要由哪两部分组成？（第一是输入数据，第二是预期结果）
4. 软件测试和软件质量保证不是同一个概念。（软件测试只是我们从技术的角度尽可能地发现错误，而软件质量保证不仅仅是从技术的角度，是要各个层次的人去全局统筹的概念）
5. 白盒测试有哪些方法，黑盒测试有哪些方法？（牢记）
6. 因果图不会考画图，但是会考概念，比如什么时候会用到因果图？（输入条件和输出条件组合情况比较多的时候，我们就要用到因果图）
7. 负载测试。（输入参数和输出参数）
8. 安全性测试的方法。
9. 容错性测试的两个层次。
10. 软件缺陷的生命周期。（重点，倒背如流，大阶段、小阶段）
11. 软件缺陷产生的原因。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0af78d93179bba815c1e68549cde98b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d842d1fe0b5829e724bd171c08434603/" rel="bookmark">
			2023最新STM32毕业设计项目集合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1前言2 STM32 毕设课题3 如何选题3.1 不要给自己挖坑3.2 难度把控3.3 如何命名题目 4 最后 1前言 🥇 更新单片机嵌入式选题后，不少学弟学妹催学长更新STM32和C51选题系列，感谢大家的认可，来啦！
以下是学长亲手整理的STM32相关的毕业设计选题，都是经过学长精心审核的题目，适合作为毕设，难度不高，工作量达标，对毕设有任何疑问都可以问学长哦！
学长整理的题目标准：
相对容易工作量达标题目新颖，含创新点 毕设帮助，开题指导，资料分享：
https://gitee.com/yaa-dc/warehouse-1/blob/master/iot/README.md
2 STM32 毕设课题 基于stm32的智能衣柜系统设计
基于stm32的智慧家庭健康医疗系统设计
基于stm32的智能饮水机系统设计
基于STM32的寻迹小车设计
基于STM32的快递箱的设计
基于STM32的智能节能风扇的设计
基于STM32的个人健康助手的设计
基于STM32的快递箱的设计
基于STM32的智能节能风扇的设计
基于STM32的个人健康助手的设计
基于STM32的病房监控系统的设计
基于STM32的智能书房系统的设计
基于stm32的香薰灯的设计
基于stm32的智能药盒的设计
基于stm32的伸缩晒衣架的设计
物联网技术在智能校园中的应用和设计
智能换气系统的设计与实现
基于stm32的智能体重秤设计与实现
物联网智能家居的远程视频监控系统设计
高校智慧教室物联网系统设计与实现
基于RFID物联网技术下物流智能仓储系统的研究
物联网虛拟仿真实验教学中心平台建设
基于语音控制的智能家居系统的设计
基于stm32技术的智慧超市系统的研究
新型物联网创新实践教学体系建设
基于stm32的智能家居控制系统设计与实现
基于stm32的仓库环境监测系统
基于云计算的物联网数据网关的建设研究
物联网智能仓储系统的设计
物联网工程专业实验室建设方案研究
基于stm32的农业大棚环境监测系统设计
基于stm32的智能家居系统研究
厨房安全监控系统的设计与实现
基于RFID的农产品质量追溯系统设计
基于RFID技术的小区门禁系统设计
基于stm32的血压监护系统设计
基于stm32的公司考勤系统设计
基于stm32的智能LED照明集中控制系统
基于stm32的仓储管控一体化系统实现路径
基于stm32的日温室远程监控系统设计
物联网社区信息化管理系统设计
物联网中基于WIFI的室内温度检测系统设计
基于stm32架构的温室环境温湿度传感器节点设计
可燃气体远程报警装置的设计
生理体征无线检测系统设计
家居远程安防报警系统设计
基于stm32的路灯监控系统设计
基于stm32的楼道照明系统设计
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d842d1fe0b5829e724bd171c08434603/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/114f98137f4fe2a5a0e2f6edef4b06ac/" rel="bookmark">
			Redis 主从配置（带密码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看master主从信息：info replication 发现connected_slave数量为0
127.0.0.1:6379&gt; info replication # Replication role:master connected_slaves:0 2、修改你的从节点reidis.config文件，添加主节点密码:
masterauth your_password 3、在从节点上执行下面命令 REPLICAOF master_ip master_port 4、重新查看master主从信息：info replication 发现connected_slave数量变为1
127.0.0.1:6379&gt; info replication # Replication role:master connected_slaves:1 master 与 slave 没有部署在同一机器时
redis.config配置文件需要关闭网络保护&amp;注释掉访问的bind配置
protected-mode no #bind 127.0.0.1 -::1 添加sentinel 编辑sentinel.conf 文件添加如下信息
sentinel monitor mymaster yourIP yourPort 2 sentinel down-after-milliseconds mymaster 30000 sentinel parallel-syncs mymaster 1 sentinel failover-timeout mymaster 180000 sentinel monitor mymaster yourIP yourPort 2
监控的master的名字叫做mymaster,地址为yourIP yourPort，行尾最后的一个2代表什么意思呢？我们知道，网络是不可靠的，有时候一个sentinel会因为网络堵塞而误以为一个master redis已经死掉了，当sentinel集群式，解决这个问题的方法就变得很简单，只需要多个sentinel互相沟通来确认某个master是否真的死了，这个2代表，当集群中有2个sentinel认为master死了时，才能真正认为该master已经不可用了。
down-after-milliseconds
sentinel会向master发送心跳PING来确认master是否存活，如果master在“一定时间范围”内不回应PONG 或者是回复了一个错误消息，那么这个sentinel会主观地(单方面地)认为这个master已经不可用了(subjectively down, 也简称为SDOWN)。而这个down-after-milliseconds就是用来指定这个“一定时间范围”的，单位是毫秒。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/114f98137f4fe2a5a0e2f6edef4b06ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a54ef655f6fad331e98a77289d10b2c1/" rel="bookmark">
			企业微信应用开发实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、开发者中心 https://developer.work.weixin.qq.com/document
二、管理后台： https://work.weixin.qq.com/
三、企业内部应用开发 前提：域名已经备案，且在管理后台网页授权及JS-SDK可信域名已开启。
如果是JS-SDK开发，文件引用使用以下形式：
1、多页中（版本必须正确）
&lt;script src="//res.wx.qq.com/open/js/jweixin-1.2.0.js"&gt;&lt;/script&gt; 2、单页中（版本必须正确）
npm i weixin-js-sdk@1.2.0 -S 使用说明 - 接口文档 - 企业微信开发者中心
&lt;template&gt; &lt;div id="app"&gt; ... &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import wx from "weixin-js-sdk"; import axios from "axios"; export default { mounted() { const timestamp = Math.round(new Date().getTime() / 1000).toString(); const url = window.location.href.split("#")[0]; const config = { beta: true, // 必须这么写，否则wx.invoke调用形式的jsapi会有问题 debug: true, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。 appId: "ww5600436da68bc9e4", // 必填，企业微信的corpID timestamp, // 必填，生成签名的时间戳 nonceStr: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a54ef655f6fad331e98a77289d10b2c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2df18c7b0ec61732ff9f3ae938af8ac3/" rel="bookmark">
			echarts柱状图的x轴（刻度、标签名、刻度线），y轴（单位、刻度线样式（虚线、实线、）、字体样式（颜色、大小），图例排列 、柱状宽度、颜色，柱状背景）完整的柱状图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		完整的数据大屏柱状图要从哪些方面考虑 1.x轴要考虑那些？ 1. 标签文字要不要 2.刻度要不要 3.x轴的颜色要不要 例子三要素 代码对应的是我上面最终的样式 xAxis: [ { type: "category", data:XLabel, axisTick: { // 轴刻度 show: false, }, axisLabel: { // 轴文字 show:false, color: "#A0B2D3", fontSize: 12, }, axisLine: { // 轴线 show: true, color:'#268C8C', }, }, ], 2.y轴要考虑那些？ 1.字体颜色、字体大小 2.单位 单位和字体不一样单位的配置有三种方式 放一个单位配置的文档你要用哪个 这个是segmentfault的作者写的我只是借鉴参考https://segmentfault.com/a/1190000040213263 3.网格线的type是否是虚线 4.网格线的间距(这个我不需要，需要的百度一下很方便的) yAxis: [ { type: "value", name: "单位：个", nameTextStyle: { color: "#268C8C", fontSize: 12, padding: [0, 0, 10, -30], //name文字位置 对应 上右下左 }, axisTick: { // 轴刻度 show: false, }, splitLine: { // 网格线 show: true, lineStyle: { //分割线 color: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2df18c7b0ec61732ff9f3ae938af8ac3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/656f461e68671fc0f6cda68e9a9a9fd0/" rel="bookmark">
			圣诞树代码html和css页面的制作源码，开箱即用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 代码地址：效果图： 代码地址： 圣代树代码拉取地址
需要修改的地址，Ctrl+F就可以搜索到Mylables 效果图： 第一种
第二种
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b21de49fba499dcd62524c52aec1ad1a/" rel="bookmark">
			mciSendString函数简介（播放音乐以及录音相关操作）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数功能：播放多媒体音乐，视频等
mciSendString是用来播放多媒体文件的API指令，可以播放MPEG,AVI,WAV,MP3,等等。这个函数有自己的mci指令，可以通过不同的指令实现不同的功能。这里我会详细讲解mciSendString这个函数的常见用法，以及怎么去对音乐播放，快进、快退、录音等功能。
目录
设置环境
mciSendString函数相关介绍
mciSendString函数的参数（一共有4个参数）：
1.播放功能
2.关闭结束播放
3.暂停与继续
4.音量的调节
5.快进，快退
6.进度条显示以及打印进度条
7.录音功能
设置环境 首先要建立一个vs文件
建立好了之后，要调整项目的属性
改用为多字节字符集，否则会报错。
然后点去链接器中的输入，找到附加依赖项，点进去编译，导入静态库，winmm.lib
最后去关闭 SDL安全检查，改成否就行了
mciSendString函数相关介绍 头文件：#include&lt;Windows.h&gt;
#include&lt;mmsystem.h&gt;
静态库：#pragma comment(lib,"winmm.lib")
在文件项目已经导入静态库的情况下，可加可不加；如果没有导入静态库，就必须在头文件下面加上静态库
mciSendString函数的参数（一共有4个参数）： #include&lt;Windows&gt; #include&lt;mmsystem.h&gt; #pragma comment(lib,"winmm.lib")//已导入静态库，可写可不写 MCIERROR mciSendString( LPCTSTR lpszCommand, //命令字符串：如 open、play 、close等 LPTSTR lpszReturnString, //接受返回信息的字符串 ，即字符串 UINT cchReturn, //返回字符串的大小，sizeof HANDLE hwndCallback //回调窗口句柄，一般设置为NULL ); //模板 mciSendString(操作指令 , 获取返回的信息(字符串) , 返回信息的长度 , 窗口句柄(一般为NULL)); 相关指令：
1.播放功能 这里我的当前音乐文件相对路径 kk.mp3 , 如果想要播放这个音乐，我们可以通过open与play这两个指令进行播放。
mciSendString("open kk.mp3 alias music", 0, 0, 0);//alias是别名的意思，下面就可以去直接用music来代替kk.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b21de49fba499dcd62524c52aec1ad1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4380b998c1cadb41da85e3c144f709c9/" rel="bookmark">
			MySQL笔记-10 数据完整性约束
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 定义完整性约束1.1 实体完整性1.1.1 主键约束1.1.2 候选键约束 1.2 参照完整性1.3 用户定义完整性1.3.1 非空约束1.3.2 CHECK约束1.3.2.1 对列实施CHECK约束1.3.2.2 对表实施CHECK约束 2 命名完整性约束3 更新完整性约束3.1 删除完整性约束3.2 修改完整性约束 数据完整性是指数据的正确性和相容性，是为了防止数据库中存在不符合语义的数据，即防止数据库中存在不正确的数据。在MySQL中提供了多种完整性约束，它们作为数据库关系模式定义的一部分，可以通过CREATE TABLE或ALTER TABLE语句来定义。一旦定义了完整性约束，MySQL服务器会随时检测处于更新状态的数据库内容是否符合相关的完整性约束，从而保证数据的一致性与正确性。这样，既能有效地防止对数据库的意外破坏，又能提高完整性检测的效率，还能减轻数据库编程人员的工作负担。
1 定义完整性约束 关系模型的完整性规则是对关系的某种约束条件。在关系模型中，提供了实体完整性、参照完整性和用户定义完整性3项规则。下面将分别介绍MySQL中对数据库完整性3项规则的设置和实现方式。
1.1 实体完整性 实体(Entity)是一个数据对象，是指客观存在并可以相互区分的事物，如一个教师、一个学生或一个雇员等。一个实体在数据库中表现为表中的一条记录。通常情况下，它必须遵守实体完整性规则。 实体完整性规则（Entity Integrity Rule）是指关系的主属性，即主码（主键）的组成不能为空，也就是关系的主属性不能是空值（NULL）。关系对应于现实世界中的实体集，而现实世界中的实体是可区分的，即说明每个实例具有唯一性标识。在关系模型中，是使用主码（主键）作为唯一性标识的，若假设主码（主键）取空值，则说明这个实体不可标识，即不可区分，这个假设显然不正确，与现实世界应用环境相矛盾，因此不能存在这样的无标识实体，从而在关系模型中引入实体完整性约束。 例如，学生关系（学号、姓名、性别）中，“学号”为主码（主键），则“学号”这个属性不能为空值，否则就违反了实体完整性规则。
在MySQL中，实体完整性是通过主键约束和候选键约束来实现的。
1.1.1 主键约束 主键可以是表中的某一列，也可以是表中多个列所构成的一个组合；其中，由多个列组合而成的主键也称为复合主键。在MySQL中，主键列必须遵守以下规则:
每一个表只能定义一个主键。唯一性原则。主键的值，也称键值，必须能够唯一标识表中的每一行记录，且不能为NULL。也就是说一张表中两个不同的行在主键上不能具有相同的值。最小化规则。复合主键不能包含不必要的多余列。也就是说，当从一个复合主键中删除一列后，如果剩下的列构成的主键仍能满足唯一性原则，那么这个复合主键是不正确的。一个列名在复合主键的列表中只能出现一次。 在MySQL中，可以在CREATE TABLE或者ALTER TABLE语句中，使用PRIMARY KEY子句来创建主键约束，其实现方式有以下两种:
1）作为列的完整性约束
在表的某个列的属性定义时，加上PRIMARY KEY关键字实现。 create table tb_user( id int auto_increment primary key， user varchar(30) not null， password varchar(30) not null， createtime datetime); 2）作为表的完整性约束
在表的所有列的属性定义后，加上PRIMARY KEY(index_col_name，…)子句实现。 create table tb_student ( id int auto_increment， name varchar(30) not null， sex varchar(2)， classid int not null， birthday date， PRIMARY KEY (id，classid) ); 如果主键仅由表中的某一列所构成，那么以上两种方法均可以定义主键约束；如果主键由表中多个列所构成，那么只能用第二种方法定义主键约束。另外，定义主键约束后，MySQL会自动为主键创建一个唯一索引，默认名为PRIMARY，也可以修改为其他名称。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4380b998c1cadb41da85e3c144f709c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb6d9d083dc38ed64168e68e288f9239/" rel="bookmark">
			数据结构的概念及定义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、数据结构的概念及定义 1. 定义 数据结构是相互之间存在一种或多种特定关系的数据元素的集合。“结构”就是指数据元素之间存在的关系，一般分为逻辑结构和存储结构
1. 数据逻辑结构 指反应数据元素之间的逻辑关系的数据结构，其中逻辑关系是只数据之间的前后关系，而与他们在计算机中的存储位置无关。逻辑结构包括：
集合：数据结构中的元素之间除了“同属一个集合”的相互关系外，别无其它关系线性结构:数据结构中的元素存在一对一的相对关系树形结构:数据结构中的元素存在一对多的相互关系图形结构：数据结构中的元素存在多对多的相互关系 2. 数据物理结构 数据的物理结构是数据在计算机中的表示(又称映像)，他包括数据元素的机内表示和关系的机内表示。由于具体的实现方法有顺序、连接、索引、散列等多种，所以，一种数据结构可表示成一种或多种存储结构。
数据元素的机内表示(映像方式):用二进制位的位串表示数据元素。通常这种位串称之为节点（node）。所以，节点是数据元素的机内表示(或机内映像)关系的机内表示(映像方式):数据元素的关系的机内表示可以分为顺序映像和非顺序映像,常用两种存储结构：顺序存储结构和链式存储结构。顺序映像借助元素在存储器的相对位置来表示数据元素之间的逻辑关系。非顺序映像借助指示元素存储位置的指针来表示数据元素之间的逻辑关系 3. 数据存储结构 数据的逻辑结构在计算机存储空间中的存放形式称为数据的物理结构(也成为物理结构)。一般来说，一种数据结构的逻辑结构根据需要可以表示成多种存储结构，常用的存储结构有顺序存储、链式存储、索引存储和哈希存储等。
数据顺序存储的特点是：借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系；非顺序存储的特点是：借助指示元素存储地址的指针表示数据元素之间的逻辑关系
2. 分类 数据结构一般分为多种，一般来说，按照数据逻辑结构对齐进行简单的分类，包括线性结构和非线性结构两类。
1. 线性结构 线性结构就是表中各个数据节点具有线性关系。线性结构应该包括一下几点：
线性结构是非空集。线性结构有且仅有一个开始和一个结束节点。线性结构的所有节点都最多只有一个直接前驱节点和一个直接后继节点 2. 非线性结构 非线性结构就是表中各个数据节点具有多个对应关系，非线性结构应该包括一下几点：
非线性结构是非空集。非线性结构的一个节点可能有多个直接前驱节点或多个直接后继节点。 二、常用数据结构 1. 数组（Array） 数组是一种聚合数据类型，他是将具有相同数据类型的若干变量有序的组织在一器的集合。数组可以说是最基本的数据结构,在各种编程语言中都有对应。一个数组可以分解为多个数组元素，按照数据元素的类型，数组可以分为整型数组、字符串型数组、浮点型数组、指针数组和结构数组。数组还可以有一维、二维及多维等表现形式。
2. 栈（Stack） 栈是一种特殊的线性表，它只能在一个表的固定端进行插入和删除操作。栈按照先进后出或后进先出的原则来存储数据，也就是说，先进的数据将压入栈底，最后插入的数据在栈顶，读出数据时，从栈顶开始逐个读出。栈在汇编语言中，经常用户重要数据的先出保护。栈中没有数据时称为空栈。
3. 队列(Queue) 队列和栈类似，也是一种认识的线性表。和栈不同的是，对了只允许在表的一段进行插入操作，而在另一端进行删除操作。一般来说，进行插入操作的一段称为队尾，进行删除操作的一段称为对头。队列中没有元素时，称为空队列。
4. 链表(Linked List) 链表是一种数据元素按照链式存储结构进行存储的数据结构，这种存储结构具有在物理上存在非连续的特点。链表由一系列的数据节点构成，每个数据节点包括数据域和指针域两部分。其中，指针域保存了数据结构中下一个元素存放的地址。链表结构中数据元素的逻辑属性是通过链表中的指针链接次序来实现的。
5. 树（Tree） 树是典型的非线性结构，它包括2个节点的有穷集合K。在树结构中有且仅有一个根节点，该节点没有前驱节点。在树结构中的其它节点都有且仅有一个前驱节点，而且可以有2个后继节点。
6. 图(Graph) 图是另一种非线性数据结构。在图结构中，数据节点一般称为顶点，而边是顶点的有序偶对。如果2个顶点间存在一条边，那么就表示这两个顶点存在相邻关系。
7. 堆（Heap） 对是一种特殊的树形数据结构，一般讨论的堆都是二叉堆。堆的特点是根节点的只是所有节点中最小的或最大的，并且根节点的两个子树也是一个堆结构
8. 散列表(Hash) 散列表源自于散列函数,其思想是如果在结构中存在关键字和T相等的记录，那么必定在F(T)的存储位置可以找到该记录，这样就可以不用进行比较操作而直接取得所查记录。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7696fe0f50c8c5ba8018c1943d13216e/" rel="bookmark">
			Python&#43;Vue计算机毕业设计插画网站oi408（源码&#43;程序&#43;LW&#43;部署）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该项目含有源码、文档、程序、数据库、配套开发软件、软件安装教程
项目运行环境配置：
Python3.7.7+Django+Mysql5.7+pip list+HBuilderX（Vscode也行）+Vue+Pychram社区版。
项目技术：
Django + Vue +Python+Mysql 等等组成，B/S模式等等。
环境需要
1.运行环境：最好是安装Python3.7.7，我们在这个平台上运行的。其他版本理论上也可以。
2.IDE环境：Python和Python 社区版都可以。推荐Python 社区版;
3.硬件环境：windows 7/8/10 1G内存以上；或者 Mac OS；
技术栈
1. 后端：Python、Vue、Django、Mysql
2. 前端：vue+css+javascript+jQuery+easyUI+highcharts
Python-Django毕设帮助，指导，本源码(见文末)，调试部署
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e2903fdf0fd650de71bf2b3a5ee71c3/" rel="bookmark">
			【娱乐大闯关】C语言实现学生信息录入系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、StuSystem.h1、头文件2、所录信息3、函数声明 二、Main_stusystem.c1、选择菜单2、选择器3、主函数 三、Fun_stusystem.c1、初始化2、信息录入3、追加信息4、修改信息5、删除信息6、查找信息7、显示信息8、退出 四、执行结果 一、StuSystem.h 1、头文件 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; 2、所录信息 #define MAX 20 typedef struct STUDENT { char xh[MAX], xm[MAX];//学号、姓名 float cj;//成绩 struct STUDENT* next; }Student; typedef struct HEADER { char bjm[MAX];//班级名 int cnt;//班级人数 struct STUDENT* next; }Header; 3、函数声明 void menu(); void InitStu(Header* head); void InputStu(Header* head); void AppendStu(Header* head); void ModifyStu(Header* head); void DelStu(Header* head); void FindStu(Header* head); void ShowStu(Header head); int Exit(); 二、Main_stusystem.c 1、选择菜单 void menu() { puts("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e2903fdf0fd650de71bf2b3a5ee71c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45de9cf494de3182ec2359aad721a5ff/" rel="bookmark">
			C&#43;&#43;零基础项目：俄罗斯方块！详细思路&#43;源码分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		游戏介绍 这是使用 C++ 和 EasyX 写的一个俄罗斯方块小游戏，里面用到的 C++ 特性并不多。
游戏主要分成了两个类来实现：Game 和 Block 类，分别用来实现游戏逻辑和单独的俄罗斯方块，里面顶多就用到了静态成员函数和变量的特性，但主要的游戏逻辑还是放到了 main 函数中实现。这样，每个类分工明确，就实现了俄罗斯方块游戏。
代码非常简单，里面的每个游戏逻辑都值得初学者分析和学习。
游戏截图 代码分析 1. Block 类 这个类主要封装了俄罗斯方块中的独立小方块，提供了各种函数来操作方块，比如 move 移动方块、clear 清除方块、draw 绘制方块等等。但其中的重点是方块碰撞的判断和旋转方块的算法：方块碰撞的判断可以先移动方块，接着遍历方块在地图上每一个块的位置，如果这里有块，就说明发生碰撞了；而旋转方块的算法，因为除了长条占四格以外，其它方块只占三格，所以我们采用最简单的方法，只旋转三格以内的块，具体做法是中心块不变，分别旋转十字中心和四个角，长条方块另外处理。这样简单的实现方法 “小学生” 也能看懂，于是就实现了 Block 类。
2. Game 类 这个类的主要功能是完成游戏界面的绘制和方块满行的判断。游戏界面的绘制很简单，而对于方块满行的判断，可以先遍历一行，如果满行，就将上面的每一行都下移一格位置。这样，Game 类的实现也就大功告成了！
视频教程 C++俄罗斯方块https://nxv.xet.tech/s/3uAEYJ
源码 #include &lt;easyx.h&gt; #include &lt;ctime&gt; #define MAP_WIDTH 10	// 地图宽度 #define MAP_HEIGHT 20	// 地图高度 #define BLOCK_WIDTH 20	// 方块宽度 // 游戏类 class Game { public: void drawMap() const;	// 绘制地图 void drawPrompt() const;	// 绘制提示界面 bool checkLine(const unsigned&amp; line) const;	// 判断满行 void clearLine();	// 清除满行 // 内联函数 public: // 设置地图 void setMap(const int&amp; x, const int&amp; y, const bool&amp; value) { map[x][y] = value; } // 获取地图 const bool&amp; getMap(const int&amp; x, const int&amp; y) const { return map[x][y]; } // 添加游戏时间 void addGameTime() { gameTime += 500; } private: bool map[MAP_WIDTH][MAP_HEIGHT] = { 0 };	// 地图数组 unsigned score = 0;	// 游戏分数 unsigned gameTime = 0;	// 游戏时间 }; void Game::drawMap() const { // 绘制边框 roundrect(10, 10, 340, 430, 10, 10); rectangle(20, 20, 220, 420); // 绘制地图 setfillcolor(LIGHTCYAN); for (int i = 0; i &lt; MAP_WIDTH; i++) { for (int j = 0; j &lt; MAP_HEIGHT; j++) { if (map[i][j]) { int left = 20 + 20 * i, top = 20 + 20 * j; fillrectangle(left, top, left + 20, top + 20); } } } } void Game::drawPrompt() const { // 设置字体 LOGFONT f; gettextstyle(&amp;f); f.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45de9cf494de3182ec2359aad721a5ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a34f33c5ff4dc364f1e81797be34ee8/" rel="bookmark">
			python爬虫滑块验证怎么解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于 Python 爬虫中遇到的滑块验证，你可以考虑以下几种方法来解决：
手动解决滑块验证：在爬虫程序中手动解决滑块验证，比如通过手动模拟鼠标滑动操作来完成滑块验证。
使用浏览器插件解决滑块验证：你可以使用浏览器插件，比如 Chrome 浏览器中的「验证码识别」插件，来自动识别并填写滑块验证。
使用 Selenium 来解决滑块验证：你可以使用 Selenium 这个自动化测试工具来模拟人的操作，完成滑块验证。
使用极验滑块验证破解工具：极验是目前常用的滑块验证服务商，你可以使用极验滑块验证破解工具来绕过极验的滑块验证。但是这种方法不合法，并且可能会被封禁 IP。
总的来说，建议你使用第 1 种或第 2 种方法来解决滑块验证，避免不必要的风险。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4a57d93a6d0221b49f1d59016f5e23a/" rel="bookmark">
			什么是正定矩阵？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正定矩阵是一种特殊的矩阵，它的特点是对于任意的非零列向量 $x$，都有 $x^T A x &gt; 0$。也就是说，如果将矩阵 $A$ 作为一个线性变换的映射矩阵，那么对于任意的非零列向量 $x$，其经过线性变换后的模长 $||Ax||$ 都大于零。因此，正定矩阵具有保持向量模长的性质。
如果一个矩阵是对称矩阵，那么它就是正定矩阵，但正定矩阵不一定是对称矩阵。
正定矩阵在很多领域都有广泛的应用，如最小二乘法、协方差矩阵、卡尔曼滤波器等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49d122e98d898a9d18b0619fd2e35887/" rel="bookmark">
			软件工程毕设新颖课题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0 前言1 java web 管理系统 毕设选题2 java web 平台/业务系统 毕设选题3 游戏设计、动画设计类 毕设选题 (适合数媒的同学)4 算法开发5 数据挖掘 毕设选题6 大数据处理、云计算、区块链 毕设选题7 网络安全 毕设选题8 通信类/网络工程 毕设选题9 嵌入式 毕设选题10 开题指导11 最后 0 前言 Hi，大家好，大四的同学马上要开始毕业设计啦，大家做好准备了没！
学长给大家详细整理了计算机毕设最新选题，对选题有任何疑问，都可以问学长哦~
毕设帮助，开题指导，资料分享：
https://gitee.com/yaa-dc/warehouse-1/blob/master/python/README.md
1 java web 管理系统 毕设选题 java web 系统往年很常见，不太推荐纯管理系统作为毕设了。
学籍管理系统设计与实现
教务管理系统设计与实现
网上考试系统设计与实现
在线考试系统设计与实现
题库（及试卷）管理系统设计与实现
网络远程作业处理系统设计与实现
毕业论文管理系统的设计与实现
毕业设计管理系统设计与实现
毕业生学历证明系统设计与实现
基于jsp的毕业生派遣管理系统设计与实现
XX学院信息化办公平台-公文、组织机构管理系统的设计与实现
XX学院师资培养管理系统设计与实现
基于web的师资管理系统设计与实现
高校评教教师工作量管理系统设计与实现
教师信息管理系统设计与实现
教师档案管理系统设计与实现
教学进度管理系统设计与实现
网络教学平台-教师子系统设计与实现
学生日常行为评分管理系统设计与实现
学生成绩学分制管理系统设计与实现
学生社团管理系统设计与实现
可视化学生宿舍管理系统设计与实现
班级管理系统设计与实现（或者是班级网站）
高校实验室教学管理系统的设计与实现
校园新闻管理系统设计与实现
基于SSM的学科竞赛管理系统
办公管理系统设计与实现
库存管理系统设计与实现
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49d122e98d898a9d18b0619fd2e35887/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd84b14ad8553660a6d12de2947f94d1/" rel="bookmark">
			python 怎么打开文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Python 中打开文件可以使用内置的 open 函数。
例如，你可以使用如下代码来打开一个文本文件并读取其内容：
with open('filename.txt', 'r') as f: content = f.read() 在这里，'r' 表示以只读模式打开文件。如果你希望以写入模式打开文件，可以使用 'w' 或 'a' 参数。
使用 with 关键字可以确保文件在使用完后被关闭。这样就可以确保在程序执行期间文件不被意外修改或删除。
如果你希望在打开文件时控制权限，可以使用如下代码：
f =open('filename.txt', 'r') content = f.read() f.close() 在这种情况下，你需要自己负责在使用完文件后关闭它。
希望这些信息对你有帮助！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4ce919ca13e6d736f274c38115e8d39/" rel="bookmark">
			[MySQL]SELECT list is not in GROUP BY clause and contains nonaggregated column...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目在windows上运行正常，迁移到Linux系统上就出现了这个错，经查是由于本人sql不规范且恰好mysql的sql_mode启用了only_full_group_by，当sql语句中使用了分组查询，并且查询的字段不在group by子句中就会出现这个报错提示。
报错详情：(sql版本8.0.13)
SELECT list is not in GROUP BY clause and contains nonaggregated column '***' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by ... 解决方法：去除sql模式中的ONLY_FULL_GROUP_BY即可
1、进入sql命令行查看自己的sql_mode配置：
select @@global.sql_mode; 2、修改sql_mode：
方式1：复制上一步中查到的sql_mode值，去掉ONLY_GROUP_BY，
在命令行中输入 set sql_mode='***,***';
set sql_mode='STRICT_TRANS_TABLES,NO_ENGINE_SUBSTITUTION'; PS：这种方式仅单次有效，当MySQL重启后需要重新设置。
方式2[Linux]：直接修改MySQL配置文件
命令行打开mysql.cnf，默认路径：/etc/mysql/conf.d/mysql.cnf
sudo vim /etc/mysql/conf.d/mysql.cnf 在文件底部添加：
[mysqld] sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES 保存退出，重启mysql即可
sudo service mysql restart ————————————————
原文链接：https://blog.csdn.net/qmohan/article/details/120738004
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/459b9357592e13abe3991593ac0aff1e/" rel="bookmark">
			通过python获取当前的时间，并格式化输出，某年某月某日，几分几秒
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Python 中，可以使用 datetime 模块中的 datetime 类来获取当前的时间。
下面是一个示例代码：
from datetime import datetime # 获取当前时间 now = datetime.now() # 格式化输出 print(f'{now.year}年{now.month}月{now.day}日 {now.hour}时{now.minute}分{now.second}秒') 上面的代码会输出当前的年月日时分秒，如：2022年12月20日 10时30分15秒。
需要注意的是，这里的时间是本地时间(即你的计算机所在地的时间)，如果需要获取 UTC 时间，可以使用 datetime.utcnow() 方法。
你也可以使用 strftime 方法来格式化时间输出，例如：
print(now.strftime('%Y年%m月%d日 %H时%M分%S秒')) 这样就可以得到格式化的输出：2022年12月20日 10时30分15秒。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6b82db67f446f5f0fcec5d185fe60db/" rel="bookmark">
			JS实现千分位分隔符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一：最简单的实现 缺点：兼容性不是很好
parseFloat(1000000.88).toLocaleString() // 整数型 parseInt(1000000.88).toLocaleString() 123456789..toLocaleString('zh-hans-cn-u-nu-hanidec',{useGrouping: false}); //"一二三四五六七八九" 123456789..toLocaleString('zh-hans-cn-u-nu-hanidec',{useGrouping: true}); //"一二三，四五六，七八九" new Date().toLocaleString('zh-hans-cn-u-nu-hanidec'); //"二〇一九/五/二九 下午三:一五:四〇" 方法二：除法+求模（性能最好） function format_with_mod(number) { let n = number; let r = ''; let temp = ''; do { // 求模的值， 用于获取高三位，这里可能有小数 mod = n % 1000; // 值是不是大于1，是继续的条件 n = n / 1000; // 高三位 temp = ~~mod; // 1.填充: n &gt; 1 循环未结束， 就要填充为比如 1 =&gt; 001 // 不然temp = ~~mod的时候, 1 001， 就会变成 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6b82db67f446f5f0fcec5d185fe60db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85993a7b7e0c65be5465b8cd83e20c31/" rel="bookmark">
			Zabbix 安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Zabbix 安装 Zabbix 简介 Zabbix 组成 Zabbix 由前端、服务端、代理段、客户端、Java 监控网关几个组件组成前端由 PHP 语言编写服务端、代理端、客户端由 C 语言编写Java 监控网关 Java 开发 Zabbix 架构 详细参考：[Zabbix 详细介绍](./Zabbix 详细介绍.md)
预先环境配置 为了简化安装部署过程，安装之前关闭SElinux和firewalld防火墙等.
# 关闭SElinux sed -i "s/SELINUX=enforcing/SELINUX=disabled/" /etc/selinux/config # 关闭firewalld/ufw防火墙 systemctl stop firewalld 环境概述：
角色主机-IPzabbix-server、zabbix-agentmaster.agou-ops.com(172.16.1.130)zabbix-agentnode01.agou-ops.com(172.16.1.129) 将zabbix-web，数据库，zabbix-server都装在master主机之上.
Zabbix-server 安装 安装LNMP环境 yum install -y httpd mariadb-server mariadb php php-cli php-common php-devel php-pear php-gd php-mbstring php-mysql php-xml php-bcmath 启动服务
systemctl start httpd mariadb 安装最新版 Zabbix 安装 Zabbix 源 rpm -Uvh https://repo.zabbix.com/zabbix/4.4/rhel/7/x86_64/zabbix-release-4.4-1.el7.noarch.rpm yum clean all 安装Zabbix server，Web前端，agent等相关包 yum install zabbix-server-mysql zabbix-web-mysql zabbix-web zabbix-agent zabbix-get zabbix-sender -y 连入mysql/pgsql数据库创建所需数据库 create database zabbix character set utf8 collate utf8_bin; 创建zabbix账户并进行授权 # grant all privileges on zabbix.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85993a7b7e0c65be5465b8cd83e20c31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ab79b446b5b59d1c189aa381cdfdd4c/" rel="bookmark">
			基于springboot layui前后端分离的宿舍管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统以MySQL 为数据库，在Spring Boot + SpringMVC + MyBatis + Layui框架下基于B/S架构设计开发而成。系统中的用户分为三类，分别为学生、宿管、后勤。这三类用户拥有不同的操作权限。
系统中用到的技术包括Axios, Echarts, POI。特色功能有人性化的宿舍分配，可视化的账单管理、房间管理、记账管理，Excel文件上传后数据导入数据库等等。
运行教程 1. 准备工作 1.1 开发环境 JDK 1.8
MySQL 8.0 （替代品：MySQL 5.7）
1.2 开发工具 WebStorm 2020.3（替代品：Visual Studio Code）
IntelliJ IDEA 2020.3（替代品：Eclipse【界面、图标太丑，不推荐】）
DataGrip 2020.3（替代品：Navicat）
Google Chrome 90.0
2. 打开项目文件并运行 本系统将前后端开发分离：分别在IntelliJ IDEA（后端）与WebStrom（前端）中进行开发。
因此，在此用IntelliJ IDEA 2020.3与WebStrom 2020.3进行演示。
2.1 IntelliJ IDEA 点击Open，选择源文件中的dormitory文件并打开。
演示视频：
基于springboot layui前后端分离的宿舍管理系统源码
package com.silk.controller; import com.github.pagehelper.PageInfo; import com.silk.entity.Intention; import com.silk.entity.User; import com.silk.service.IntentionService; import com.silk.service.RoomService; import com.silk.service.UserService; import com.silk.utils.Result; import org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ab79b446b5b59d1c189aa381cdfdd4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98af3d2dab55f9fbfb95622e590e1672/" rel="bookmark">
			DeepSpeed使用指南(简略版)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在的模型越来越大，动辄几B甚至几百B。但是显卡显存大小根本无法支撑训练推理。例如，一块RTX2090的10G显存，光把模型加载上去，就会OOM，更别提后面的训练优化。
作为传统pytorch Dataparallel的一种替代，DeepSpeed的目标，就是为了能够让亿万参数量的模型，能够在自己个人的工作服务器上进行训练推理。
本文旨在简要地介绍Deepspeed进行大规模模型训练的核心理念，以及最基本的使用方法。更多内容，笔者强烈建议阅读HuggingFace Transformer官网对于DeepSpeed的教程：
Transformer DeepSpeed Integration
1. 核心思想 (TLDR) DeepSpeed的核心就在于，GPU显存不够，CPU内存来凑。
比方说，我们只有一张10GB的GPU，那么我们很可能需要借助80GB的CPU，才能够训练一个大模型。
看一下官网对于这个理念的描述：
Why would you want to use DeepSpeed with just one GPU?
It has a ZeRO-offload feature which can delegate some computations and memory to the host’s CPU and RAM, and thus leave more GPU resources for model’s needs - e.g. larger batch size, or enabling a fitting of a very big model which normally won’t fit.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98af3d2dab55f9fbfb95622e590e1672/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cec1fa9ecc2d3fad7593155abb4fcbfa/" rel="bookmark">
			echarts环形图的图例引导线水平加圆点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是引导线? 引导线就是label(文本标签)链接的线 引导线分两段 从拐弯的地方开始分，接近圆的是length(引导线1)，接近label的是length2(引导线2) 需求一：要求水平引导线 让第一段引导线长度为0，第二段自己调试长度 let data = [ { name: "业务1", value: 10 }, { name: "业务2", value: 15 }, { name: "业务3", value: 15 }, { name: "业务4", value: 25 }, { name: "业务5", value: 10 }, { name: "业务6", value: 25 }, ]; let color = ["#fec101", "#D1C76B ", "#ff6226", "#f60000", "#2cc78f", "#2ca7f9"]; // 这步主要是为了让小圆点的颜色和饼状图的块对应，如果圆点的颜色是统一的，只需要把itemStyle写在series里面 let setLabel = (data) =&gt; { let opts = []; for (let i = 0; i &lt; data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cec1fa9ecc2d3fad7593155abb4fcbfa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/441eab3ca87c69f5fc30f9126dbe652c/" rel="bookmark">
			esp32开发板 Arduino IDE 2.0环境搭建--2022年记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我用的是Arduino IDE 2.0版的。
1.首先打开Arduino，然后点击File→Preferences，在弹出的对话框里填入下面的链接，接着点击确定并关闭对话框。
https://www.arduino.cn/package_esp32_index.json
2.在开发板管理器里头搜索esp32，选最新的版本下载（我下载的是2.0.3版的包），如下图。总共下载了8个文件，725M。国内的网络环境应该是很难完成下载，所以建议【科学上网】。另外我也把我下载的这些文件放到云盘上供大家下载，见文末。
3.Arduino IDE下载完对应的文件后，会自动的安装。安装完成后如下图：
4.安装完后，就可以在tools→board→esp32里头看到好多板子了。大功告成！
----------------------------------------------------------------------------------------------------------------------------
大家如果在Arduino内无法完成下载，可以到下面的云盘里头去下载文件，然后把这些文件放到下面的路径。注意，我的这些文件对应的是2.0.3版本的。文件放好后，再次启动Arduino，重复执行上面的第2个步骤，这时候Arduino会跳过下载，直接安装，大功告成。
路径：C:\Users\你电脑的名字\AppData\Local\Arduino15\staging\packages
链接：https://pan.baidu.com/s/1ax-tObmM4bm8hIR6e-GB6g 提取码：1217
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/437774d2fbfd6eda81fdb10563345461/" rel="bookmark">
			k8s-Deployment
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 Deployment 为 Pod 和 Replica Set 提供声明式更新。
Deployment 是建立在 rs 之上的一个控制器，可以管理多个 rs，每次更新镜像版本，都会生成一个新的 rs，把旧的 rs 替换掉，多个 rs 同时存在，但是只有一个 rs 运行。
之前在 rs 的介绍时说过，rs 只有在修改了 pod 数时，才会触发更新，如果更改的是 template 或者 标签，不会主动触发更新。
而使用 deployment ，更改了模版，例如 镜像版本号，deployment 会根据新的模版产生一个新的 rs，每当新的 rs 中生成一个 pod，旧的 rs 中的 pod 就会删除一个。
deployment 还提供了版本回滚等操作。
示例 apiVersion: apps/v1 &lt;-- 版本号 kind: Deployment &lt;-- pod 类型 metadata: name: nginx-deployment &lt;-- pod 名称 spec: selector: &lt;-- rs 的标签选择器，选择要管理 pod 的标签 matchLabels: app: nginx replicas: 3 &lt;-- 副本数量 template: &lt;-- pod 模版 metadata: labels: &lt;-- rs 所管理的普通 pod 的标签 app: nginx spec: containers: &lt;-- 容器信息 - name: nginx image: nginx:1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/437774d2fbfd6eda81fdb10563345461/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0966c6dbdfc033d3559a7e855ee32782/" rel="bookmark">
			Python第三方库安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python第三方库安装教程 Life is short,you need python.
人生苦短，我用Python。我是PythonUser10235。许多时候，我们需要安装一个库，来减少代码长度。但并不是所有库都是不用安装的，许多的第三方库需要安装。那么。我们该如何安装第三方库呢？
1.pip pip是Python最常用的第三方库之一，用来管理和安装第三方库。如果你安装Python3.x的话，大概率会包括一个pip库。pip的安装指令是：
pip install package 这里的package要替换成库名。假如我要安装语音库pyttsx3，那么在cmd里输入：pip install pyttsx3
安装时就会这样：
如果安装后有黄色警告，就像下图，不用理会。不过建议在输入一次python -m pip install --upgrade pip
python -m pip install --upgrade pip 2.pycharm安装 pycharm有一个库管理功能，也可以安装库。步骤如下：
1.打开文件
2.按下Ctrl+Alt+S或设置（T），打开一下窗口。
按下项目，里面有个解释器选项（Interprepter）
3。点击我圈起来的加号
4.在打开的窗口中输入你要下载的库的名字
点击安装即可。
另： pip list可以查看你有哪些库！未激活的Windows有无法使用pip的概率！调用库和普通库相同：import package
Life is short,you need python!我是PythonUser10235，一个编程菜鸟。
停，别走！ 我知道各位不想打字评论。点个赞总行吧？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f85783e2a3785a1360754ccde1680ac8/" rel="bookmark">
			Python -- 文件操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.文件的打开与关闭
1.1 打开文件
1.2 关闭文件
2.文件的读取和写入
2.1 文件的读写
3.CSV文件的读写
3.1 CSV文件的写入
4.将数据写入
4.1 StingIO
4.2 BytesIO
5.练习：实现文件拷贝
6.序列化和反序列化
6.1 使用JSON实现列化
6.2 使用JSON实现反序列化
6.3 pickle模块
7.异常处理
7.1 读取文件异常
7.2 try...except语句
7.3 try...else语句
7.4 try...finally语句
8.with关键字的使用
9.自定义异常
1.文件的打开与关闭 想一想：
如果想用word编写一份简历，应该有哪些流程呢？
打开word软件，新建一个word文件
写入个人简历信息
保存文件
关闭word软件
同样，在操作文件的整体过程与使用word编写一份简历的过程是很相似的
打开文件，或者新建立一个文件
读/写数据
关闭文件
1.1 打开文件 在python，使用open函数，可以打开一个已经存在的文件，或者创建一个新文件
open(文件路径，访问模式)
示例如下：
f = open('test.txt', 'w') 说明:
文件路径
文件的路径分为相对路径和绝对路径两种。
绝对路径：指的是绝对位置，完整地描述了目标的所在地，所有目录层级关系是一目了然的。
例如：C:/Users/chris/AppData/Local/Programs/Python/Python37/python.exe，从电脑的盘符开始，表示的就是一个绝对路径。
相对路径：是从当前文件所在的文件夹开始的路径。
test.txt，是在当前文件夹查找 test.txt 文件
./test.txt，也是在当前文件夹里查找test.txt文件， ./ 表示的是当前文件夹。
../test.txt，从当前文件夹的上一级文件夹里查找 test.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f85783e2a3785a1360754ccde1680ac8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfcaa309daec0d133c6a436c77def53b/" rel="bookmark">
			【数据结构】Java实现顺序表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 线性表顺序表顺序表的模拟实现1、新增元素,默认在数组最后新增2、判定是否包含某个元素3、查找某个元素对应的位置4、获取顺序表长度5、在 pos 位置新增元素6、获取 pos 位置的元素7、给 pos 位置的元素设为 value8、删除第一次出现的关键字key9、清除顺序表 线性表 什么是线性表呢？线性表是一种在实际中广泛运用的数据结构，例如：顺序表、链表、栈和队列。线性表在逻辑结构上是线性结构，就是一条线连续的，但是在物理结构上并不一定连续，今天我们要学习的顺序表就是线性结构的一种。
顺序表 顺序表名字听起来挺高大上的，但其实底层的逻辑就是一个数组，是用一段物理地址连续的存储单元依次存储数据结构元素的线性结构。
顺序表的模拟实现 首先我们先来创建一个顺序表：
public class SeqList { private int[] array;//数组 private int usedsize;//当前数组有多少个元素，初始为0 private static int DEFAULT_SIZE = 5; // 默认构造方法 public SeqList(){ array = new int[DEFAULT_SIZE];//创建顺序表对象时创建一个5个元素的数组 } } 便于我们检测我们写的方法的正确性，我们可以写一个打印顺序表的方法。
// 打印顺序表，注意：该方法并不是顺序表中的方法，为了方便看测试结果给出的 public void display() { for(int i = 0;i &lt; usedsize;i++) { System.out.print(array[i] + " "); } System.out.println(); } 这样就可以遍历打印数组中的元素了，也就是遍历打印顺序表。
1、新增元素,默认在数组最后新增 //判断顺序表是否满 private boolean isFullAdd(int[] array) { return usedsize == array.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfcaa309daec0d133c6a436c77def53b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/449e1c674336c99b837b1604c82d5dca/" rel="bookmark">
			在HBuilderX中使用git导入项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 HBuilderX中集成了git功能，可以讲我们的项目代码上传到gitcode中，并可以随时克隆的本地。
HBuilderX顶部菜单，【工具】-&gt; 【插件安装】，即可打开插件安装窗口，如下图所示，找到Git插件，点击【安装】即可。
克隆或导入项目 顶部菜单【文件】-&gt; 【导入】-&gt; 【从Git导入】，即可打开导入窗口或从项目管理器，空白处，右键菜单【导入】-&gt; 【从Git导入】 Git操作菜单 项目管理器，选中项目，右键菜单，即可看到git相关操作菜单，点击相关菜单，即可调起TortoiseGit。
备注：HBuilderX Git插件，都是调用TortoiseGit，因此本文不再详细描述TortoiseGit操作教程。
Pull拉取 项目管理器，选中项目，右键菜单 【Git pull】
Push推送 项目管理器，选中项目，右键菜单 【Git Push】
备注：git push --force: 表示将目前自己本机的代码库推送到远端，并覆盖。请谨慎使用。
快捷键配置 点击菜单【工具】--&gt;【自定义快捷键】文档左侧底部可看到所有git命令 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12549dc476d7b8168123168f8b43190d/" rel="bookmark">
			Docker 安装Oracle 11g
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 想装个oracle又怕占内存，于是就想用docker装一个，在网上找了很多资料，期间遇见过很多的坑。下面是我总结并实验成功的方法，直接无脑粘贴复制 就行
docker-compose文件 version: '3' services: oracle: image: registry.cn-hangzhou.aliyuncs.com/helowin/oracle_11g restart: always container_name: oracle volumes: - ./data:/u01/app/oracle ports: - 1521:1521 创建文件夹 mkdir -p /usr/local/docker/oracle/data 放入yml文件至/usr/local/docker/oracle
启动oracle docker-compose up -d 配置oracle 进入docker容器内部
docker ps -a docker exec -it xxx /bin/bash 使用内部root 用户下，密码为 helowin
su root helowin 修改保存配置文件
vi /etc/profile export ORACLE_HOME=/home/oracle/app/oracle/product/11.2.0/dbhome_2 export ORACLE_SID=helowin export PATH=$ORACLE_HOME/bin:$PATH source /etc/profile ln -s $ORACLE_HOME/bin/sqlplus /usr/bin 切回oracle用户
su oracle 修改密码
// 1.使用nolog方式登录 sqlplus /nolog // 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12549dc476d7b8168123168f8b43190d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/911ad6d8fc7d470e9c90faebd00bdff5/" rel="bookmark">
			【产品经理必备文档】述职报告/年终总结汇报ppt模板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天和大家免费分享产品必备文档模板——产品经理述职文档（年终总结汇报）的ppt模板~~~
【文档下载】
这个ppt模板可以在下方小程序里免费下载哦
【编写教程】
个人工作年终总结一般分成4部门：个人岗位职责、工作完成情况、年度经验总结、
1、个人工作职责
主要谈谈今年个人工作的重点内容，就是让领导和同事知道你今年做了什么工作，一般产品经理的工作内容基本相同，不同公司会有部分区别，大家根据实际情况填写即可。大体分为需求挖掘（市场调研、用户访谈…）、产品设计（原型模板、需求文档…）、产品开发（培训、指导开发…）、产品运营（数据分析……）、产品迭代、产品推广……
2、工作完成情况
前面部分内容介绍的的是我们做了什么工作，那第二部分内容就是介绍我们工作的成绩。
我们可以先简单介绍今天我们做了什么项目，如果同时做多个项目的可以简单的简述
然后在详细展开，一个一个项目谈谈自己的工作。
首先是项目进展，我们可以用时间轴的方式，结合第一点个人职责，介绍自己在该项目里主要负责的内容
介绍完负责的内容之后，我们就谈成果了，最好能用图表列出具体数据，对比上线前后分析，这样会更加具有说服力。
根据不同的项目，会有不同的指标，例如营收增长了多少、成本节约了多少、风险降低了多少、效率提高了多少……
如果同时兼多个项目的话，我们介绍完一个项目之后，可以用同样的方式介绍其他的项目，先介绍在该项目里主要负责的内容，然后在用数据介绍成果。
3、年度经验总结
这部分要分成两部分内容第一是经验成绩的积累，第二部分是当前不足和措施
第一部分经验成绩的积累主要展示你在这一年工作学习中，积累到的工作经验、掌控到的知识内容、岗位技能、方法论……并且谈谈这些个人成长对你日后工作的帮助。
第二部分当前不足和措施，主要是对今年工作中经验总结思考后，发现一些工作中的瑕疵，并且对当前工作不足提出加以改善的措施。
4、明年工作规划
主要介绍自己明年的岗位工作和学习规划。我们同样分成两部分，第一部分是工作和学习目标，第二是详细的计划。
第一部分工作和学习的目标，我们最好根据公司目标和部门目标来规划，这里展示个人发展和公司发展是同步的，是能承接公司、部门明年工作规划的
介绍完目标之后，我们简述一下自己的详细计划，这部分内容要根据第一点个人工作职责，对应不同的职责，我要做什么的工作，制定一个计划表
这样一个年终工作总结报告就完成了。
本文内容及原型模板，由微信公众号：Axure高保真原型 原创发布，未经许可，禁止转载和商用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f8e97d0dde8b130ca8828e91c10084f/" rel="bookmark">
			基于Unity整合BEPUphysicsint物理引擎实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一节我们详细的讲解BEPUphysicsint 的物理事件。此物理引擎会产生了碰撞事件与非碰撞事件，碰撞事件大家好理解，非碰撞事件例如: 物理Entity的update事件,Entity的activation/deactivation事件等。本节课来实战如何编译BEPUphysicsint源码到自己的项目, 如何整合物理引擎与Unity图形渲染。本文分成4个部分:
对啦！这里有个游戏开发交流小组里面聚集了一帮热爱学习游戏的零基础小白，也有一些正在从事游戏开发的技术大佬，欢迎你来交流学习。
1: 源码编译, 将github上的源码下载下来编译到Unity项目;
2: 在Unity中初始化BEPUphysicsint的物理世界;
3: 编写PhyBoxEntity组件创建物理Entity并同步Unity图像;
4: 使用Unity自带碰撞器组件,来生成创建PhyBoxEntity;
创建项目,源码编译BEPUphysicsint
准备源码，我们从github上面下载下来BEPUphysicsint的源码，下载地址为:
https://github.com/sam-vdp/bepuphysics1int
下载下来以后，解压开来代码截图,如图1.4-1:
图1.4-1 项目源码目录截图
下载下来源码后怎么用到Unity(百度也百度不到)，我的方法是先分析文件夹，搞清楚每个文件夹的大概的功能与作用,看下项目，打开vs的工程BEPUphysics.sln看下源码项目如何组织的，如图1.4-2:
图1.4-2 工程目录截图
结合我们的文件夹，我们大胆来猜测分析下代码的作用，哪些我们可能需要的，哪些要删除的。分析时，我一般会先根据名字来猜测，再核对一下里面的代码。BEPUbenchmark/BEPUfloatBenchmark,我先查找名字benchmark的意思,benchmark的英文有类似单元测试，实例代码的意思，所以这两个文件夹下的代码应该是供我们整合到项目做的实例参考，可以阅读里面的源码，但是不用放Unity源码编译。进一步核实一下里面的代码验证一下自己的判断，打开入口文件Benchmark.cs,里面讲解的就是如何setup物理世界等。如图1.4-3所示:
图1.4-3 示例代码构建物理世界
BEPUik/ BEPUphysics: ik与physics看上去就是物理引擎的核心代码库，打开代码大概验证一下，ik里面有IKJoint.cs相关代码, physics里面有Entity, Space等代码,所以这个应该是核心代码，等会要放入Unity项目工程。如图1.4-4所示
图1.4-4 物理引擎核心代码
经过类似的分析名字与内容，我们发现BEPUutilities(工具代码)+ BEPUik+ BEPUphysics+ FixedMath.Net文件夹所对应的代码为引擎编译所依赖的必须代码, ConversionHelper这里是向量定点与浮点的转换代码，在Unity中可能用到或参考，可以考虑放项目中。
接下来创建Unity项目来编译源码(参考unity 2020.3.33f1版本)。项目创建完成后分好文件夹，这里我分了3个一级目录文件夹: AssetsPackage, Scenes, Scripts,Scripts又分为了3rd, Framework, 两个文件夹,如图1.4-5:
图1.4-5 物理引擎核心代码
其中3rd用来存放第三方的代码，我在里面又新建了一个BEPU的文件夹,拷贝我们分析的必须代码到Unity项目。
图1.4-6 移植物理引擎源码到项目
不出意外的话，大量的报错,主要分成几类, AssemblyInfo.cs 里面的代码报错，打开这个代码一看，没有什么用，直接连同里面的” Properties”一起删除掉。又发现源码文件夹里面”bin”与”obj”文件夹，这个是源码工程的编译时生成的目录，删掉。如图1.4-7:
图1.4-7 删除原项目工程编译文件夹
接着就是BoxBoxCollider.cs代码报错，打开代码一看，对比原版，发现原版里面有个编译的宏开关ALLOWUNSAFE,原版本打开了，Unity版本没有，我们在Unity PlayerSetting里面加上这个宏，如图1.4-8:
图1.4-8 打开编译宏开关
经过这些操作，代码很神奇的就全部编译过了。接下来往Unity里来构建我们的物理世界了。
在Unity中初始化BEPUphysicsint的物理世界
这个简单多了，打开BEPUphysicsint的benchmark代码参考,copy过来就可以了。初始化的时,主要做的事情有: 构建物理世界, 配置物理世界重力，设置物理迭代的参数，关闭原来Unity自带物理引擎, Update中迭代物理世界。这里是全局执行一次，新建一个BEPUPhyMgr.cs的全局单例，用来做初始化。代码实现在Framework/BEPUWrapper文件夹下，直接上代码:
publicclassBEPUPhyMgr : MonoBehaviour { public BEPUphysics.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f8e97d0dde8b130ca8828e91c10084f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a1128cb7c734fb350cf33ef8da5d205/" rel="bookmark">
			浅谈MyBatis中模糊查询LIKE的几种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在操作数据库时，查询是最常用的语句，模糊查询也是数据库SQL中使用频率很高的SQL语句，利用MyBatis框架来进行更加灵活的模糊查询，介绍以下两种常用的方式。
利用Mysql的CONCAT()函数 MySQL的CONCAT()函数用于将多个字符串连接成一个字符串，是最重要的mysql函数之一。用法：CONCAT(str1,str2,…)
mapper层接口如下：
/** * 根据用户名模糊查询用户信息 * * @param name * @return */ List&lt;UserInfo&gt; getUserList(@Param("name") String name); mapper文件如下：
&lt;select id="getUserList" resultType="com.sinosoft.springbootplus.systems.domain.domainobject.UserInfo"&gt; SELECT u.id, u.user_name, u.nick_name, u.phone, u.email, u.sex, u.head, u.remark, u.state, u.lock_state, u.lock_time, u.pwd_last_updae, u.department_id, u.deleted, u.version, u.create_time, u.update_time FROM sys_user u WHERE u.deleted = 0 &lt;if test="name != null and name != ''"&gt; AND u.user_name LIKE CONCAT('%',#{name},'%') &lt;/if&gt; &lt;/select&gt; 注意：
此方法只针对mysql数据库所用，如果换成Oracle数据库则需要修改sql代码，因此此方法不通用，但可以使用。
利用mybatis的bind元素 mybatis针对这种情况作出了调整，提供了一个bind元素，此元素可以跨越数据库限制，也就是说不管是mysql还是Oracle数据库都可以通用模糊查询。
mapper层接口如下：
/** * 根据用户名模糊查询用户信息 * * @param name * @return */ List&lt;UserInfo&gt; getUserList(@Param("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a1128cb7c734fb350cf33ef8da5d205/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee3432e49e9b1a11c8fa1ce5fbde64cf/" rel="bookmark">
			TypeError: ***() got an unexpected keyword argument ‘***‘ self._target(*self._args, **self._kwargs)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个报错属于是给我整不会了,查了一下才发现我还是对python传参不太了解
创建一个线程时如果使用了kwargs属性传递字典
就需要在创建线程的target属性指向的函数中写上所有这个字典的键（应该有别的办法）,否则就会报这个错
比如这里传递的字典的键就是dd
import threading def img(dd): print(dd) thread = threading.Thread(target=img, kwargs={"dd": "111222333444"}) thread.start() 很多时候打代码就是能遇到这种很不可思议的事，毕竟我学python也就看看教程，没练啥项目，用的少，很难遇到，现在做东西遇到这种问题就比较头疼了。
不过 当你踩遍了bug的时候你就会对这门语言使用的更熟练，所谓孰能生巧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87932e327be848211e617636ece5952b/" rel="bookmark">
			HBase 热点数据怎么处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HBase 是一个分布式的 NoSQL 数据库，它可以存储大量的结构化数据，并支持快速读写和查询操作。HBase 使用了列存储模型，可以将数据存储在列族中，并使用行键来唯一标识数据行。
在 HBase 中，热点数据是指经常被读写或查询的数据。这些数据可能会导致 HBase 集群中的某些机器负载过高，影响系统的性能。为了解决这个问题，我们可以采取以下措施来处理 HBase 的热点数据：
分片：将数据分成多个区间，并使用分布式算法将这些区间均匀地分配到集群中的机器上，从而减少单台机器的负载。
缓存：使用缓存技术，将经常被访问的数据存储在内存中，以提高数据访问速度。
负载均衡：通过调整 HBase 集群中的机器的负载，使得每台机器的负载保持均衡，从而提高系统的性能。
分布式锁：使用分布式锁机制，避免多个请求同时对热点数据进行修改，从而保证数据的一致性。
总的来说，我
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0eabd89a97180d6a126182306c5216a1/" rel="bookmark">
			C语言—while语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;stdio.h&gt; int main() { int i = 0; while (i &lt; 100) { printf("%d\t", i); i++; } } 只要表达式为真就一直执行循环体里的语句；
当i&lt;100的是否，打印i的值，i自加1；
打印0到99后，i等于100的时候，不满足条件，跳出循环；
#include &lt;stdio.h&gt; int main() { int i = 0; while (i &lt; 100) { printf("%d\t", i); i++; if (i &gt; 10) { break; } } } while循环里，嵌套if语句，当达到某条件后，执行break，跳出循环；
while循环，当i等于11时，跳出循环体；
#include &lt;stdio.h&gt; int main() { int i = 0; while (i &lt; 100) { i++; if (i % 2 == 0) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0eabd89a97180d6a126182306c5216a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d21ffd8fdd5884c42543409516fd5c45/" rel="bookmark">
			kali中nmap的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nmap使用 一，探测主机是否存活1.1 发送udp包探测1.2 发送ack包探测 二，探测一台主机上的端口2.1 探测UDP端口开放情况2.2 探测TCP端口开放情况2.2.1隐蔽扫描2.2.2 全连接扫描2.2.3僵尸扫描 三nmap服务扫描3.1 banner3.2服务版本检测3.3操作系统版本检测3.4 识别目标操作系统 nmap -h 可查看所有的参数，推荐使用这个来查看。
一，探测主机是否存活 扫描ip地址：
wireshark流量抓包：
1.1 发送udp包探测 原理：通过ICMP不可达判断主机是否开放（结果不是太准确可尝试多试几次）
栗子：
nmap 192.168.0.1-254 -PU -sn 判断 c 类 ip 的 1到254 的主机，-PU 是发送UDP 包，-sn 是探测主机 1.2 发送ack包探测 栗子：
nmap 192.168.0.1-254 -PA -sn 判断 c 类 ip 的 1到254 的主机，-PA 是发送ack 包，-sn 是探测主机 二，探测一台主机上的端口 2.1 探测UDP端口开放情况 扫描一台主机上的端口
栗子：
nmap -sU 192.168.0.103 默认进行端口扫描，时间较长途中可按回车查看进度及剩余时间 nmap -sU 192.168.0.108 -p1-65535 nmap -sU 192.168.0.108 -p1- 进行全端口扫描 指定端口进行扫描
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d21ffd8fdd5884c42543409516fd5c45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2be4a675f10b3713c9e93fcf039fcbbb/" rel="bookmark">
			ubuntu安装qtcreator后没有桌面图标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 找到qtcreator的路径，添加一个软链接，我安装的5.12.9版本。我的路径在/opt/Qt5.12.9/Tools/QtCreator/bin添加一个软路由 名字叫做qtt，别添加在当前目录下，因为当前目录没有添加环境变量，这里我是把软路由添加在/usr/bin下。添加完后在任何路径执行qtt即可打开 sudo ln -s /opt/Qt5.12.9/Tools/QtCreator/bin/qtcreator /usr/bin/qtt 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f490fa5b601d6c0277ac08750558b8c/" rel="bookmark">
			Java8之JMX与MBean
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考文章：
《JMX超详细解读》
《JMX》
写在开头：本文为学习后的总结，可能有不到位的地方，错误的地方，欢迎各位指正。
在学习tomcat源码架构的时候了解到其中使用了JMX来实现一些管理工作，于是便整理了这篇文章出来。
目录
一、JMX入门
1、JMX概念
2、JMX的架构
1、基础层
2、适配层
3、接入层
二、JMX的使用
1、使用Jconsole访问
1.1、资源注册
1.2、启动监控
2、通过JMX提供的工具页访问
3、通过客户端程序进行远程访问
三、补充
常用的 MBean
一、JMX入门 1、JMX概念 JMX(Java Management Extensions)是一个为应用程序植入管理功能的框架。JMX是一套标准的代理和服务，实际上，用户可以在任何Java应用程序中使用这些代理和服务实现管理。
个人理解其实就是Java 管理扩展，用来管理和监测 Java 程序。最常用到的就是对于 JVM 的监测和管理，比如 JVM 内存、CPU 使用率、线程数、垃圾收集情况等等。
比如${JAVA_HOME}的/bin目录下的jconsole，正式利用的JMX实现的资源监控。
2、JMX的架构 整个架构可以由底向上分为基础层（探测层）、适配层（代理层）、接入层（远程管理层），下面我们来分别介绍下。
1、基础层 这其中主要是被管理的资源MBean，MBean主要有四种，Standard MBean、Dynamic MBean、Open MBean、Model MBean，源码主要在 java.lang.management 和 javax.management包里面。
Standard MBean这种类型的MBean最简单，它能管理的资源（包括属性，方法，时间）必须定义在接口中，然后MBean必须实现这个接口。它的命名也必须遵循一定的规范，例如我们的MBean为Hello，则接口必须为HelloMBean。
Dynamic MBean必须实现javax.management.DynamicMBean接口，所有的属性，方法都在运行时定义。另外还有两类 MBean：Open MBean 和 Model MBean，实际上它们也都是动态 MBean。
2、适配层 MBeanServer 是负责管理 MBean 的，一般一个 JVM 只有一个 MBeanServer，所有的 MBean 都要注册到 MBeanServer 上，并通过 MBeanServer 对外提供服务。一般用 ManagementFactory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f490fa5b601d6c0277ac08750558b8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4754ec894eb543b782a819bfcb9ce1a6/" rel="bookmark">
			前端基础 HTML
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端基础 HTML 概述 HTML：Hyper Text Markup Language，超文本标记语言 超文本：包括文字、图片、音频、视频、动画等 HTML发展史： 1993年6月：HTML1995年11月：HTML2.01996年1月14日：HTML3.21997年12月8日：HTML4.01999年12月24日：HTML4.012000年1月26日：XHTML1.02001年1月26日：XHTML1.1XHTML2.02013年5月6日：HTML5 HTML5提供了新的元素和特性，同时也建立了一些新的规则提供了许多新功能： 网页实现动态渲染图形、图表、图像和动画无需安装插件可直接使用的网页播放视频 优势： 知名浏览器对HTML5的支持市场需求大跨平台 标准 W3C：World Wide Web Consortium，万维网联盟 成立于1994年，Web技术领域最权威和最具影响力的国际中立性技术标准机构网址： http://www.w3.org/http://www.chianw3c.org/ W3C标准 结构化标准语言：HTML、XML表现标准语言：CSS行为标准语言：DOM，ECMAScript 常见开发工具： 记事本DreamWeaverIDEAWebStormVisual Studio Code 调试方法：浏览器-&gt;右键-&gt;查看网页源码 / 审查元素 / 检查基本结构 其中： 成对出现的标签为双标签，如&lt; head&gt;和&lt; /head&gt;，分别称为开放标签和闭合标签单个出现的标签为单标签 &lt;!DOCTYPE html&gt; &lt;!--文档类型声明--&gt; &lt;html lang="en"&gt; &lt;!--网页头部--&gt; &lt;head&gt; &lt;!--头部开放标签--&gt; &lt;!--meta为描述标签，用于描述网站基本信息--&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;!--网页标题--&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;!--头部闭合标签--&gt; &lt;!--网页主体--&gt; &lt;body&gt; &lt;!--主体开放标签--&gt; &lt;/body&gt; &lt;!--主体闭合标签--&gt; &lt;/html&gt; 基本操作 基本标签 &lt; meta&gt;描述标签 描述网站基本信息一般用于做SEO(网页优化） &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4754ec894eb543b782a819bfcb9ce1a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fd8439c56050376584294920a5e5840/" rel="bookmark">
			ARMv7,ARM7,ARMA7有什么区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 随着ARM的发展，芯片也越来越多，对芯片的称呼也多了。首先，ARMv7属于内核版本号，而ARM 7则为Soc的称号。其中，内核的版本号，是有V1到V2 V3等，从小到大，性能越来越好。如下图，ARM7（soc版本号）是ARMV4内核版本下的。
ARM是从Cortex系列有了一个大的转折。ARM Cortex系列是经典处理器ARM11以后产品的新的命名系列，只在各种不同的市场提供服务，采用的是ARMv7（或者ARMv8体系结构，）。cortex系列分为三个子系列，分别是Cortex-A，Cortex-R，Cortex-M。 性能从高到低，价格也是从高到低*
Cortex-A系列用于应用处理器Application processor：主要用于手机平板等高性能计算场景。例如骁龙865采用基于Cortex-A77（大小核）魔改后的Kryo，麒麟9000也基于Cortex-A77和Cortex-A55（大小核），ARMA7就是cortex-A系列下的cortexA7。Cortex-R主要用于实时控制Real-time controller：汽车电子中用的多，不太了解Cortex-M系列用于微控制Micro controller：可以叫做单片机，有我们常见的stm32。例如stm32f407采用cortex-M4内核,stm32f103采用Cortex-M3内核 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf0d8e97ca56150a6ca154757c5cc726/" rel="bookmark">
			全国计算机二级MS-Office真题及参考答案931题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		世界上首先实现存储程序的电子数字计算机是____。 A、ENIAC B、UNIVAC C、EDVAC D、EDSAC
2、计算机科学的奠基人是____。
A、查尔斯.巴贝奇 B、图灵
C、阿塔诺索夫 D、冯.诺依曼
世界上首次提出存储程序计算机体系结构的是____。 A、艾仑•图灵 B、冯•诺依曼 C、莫奇莱 D、比尔•盖茨
计算机所具有的存储程序和程序原理是____提出的。 A、图灵 B、布尔 C、冯•诺依曼 D、爱因斯坦
电子计算机技术在半个世纪中虽有很大进步，但至今其运行仍遵循着一位科学家提出的基本原理。他就是____。 A、牛顿 B、爱因斯坦 C、爱迪生 D、 冯•诺依曼
1946年世界上有了第一台电子数字计算机，奠定了至今仍然在使用的计算机____。 A、外型结构 B、总线结构 C、存取结构 D、体系结构
在计算机应用领域里，____是其最广泛的应用方面。过程控制 B、科学计算 C、数据处理 D、计算机辅助系统 1946年第一台计算机问世以来，计算机的发展经历了4个时代，它们是____。 A、低档计算机、中档计算机、高档计算机、手提计算机
B、微型计算机、小型计算机、中型计算机、大型计算机
C、组装机、兼容机、品牌机、原装机
D、电子管计算机、晶体管计算机、小规模集成电路计算机、大规模及超大规模集成电路计算机
以下属于第四代微处理器的是____。 A、Intel8008 B、Intel8085
C、Intel8086 D、Intel80386/486/586
Pentium IV处理器属于____处理器。 A、第一代 B、第三代
C、第四代 D、第五代
计算机能够自动、准确、快速地按照人们的意图进行运行的最基本思想是____。 A、采用超大规模集成电路 B、采用CPU作为中央核心部件
C、采用操作系统 D、存储程序和程序控制
计算机工作最重要的特征是____。 A、高速度 B、高精度
C、存储程序和程序控制 D、记忆力强
计算机业界最初的硬件巨头“蓝色巨人”指的是____。 A、IBM B、Microsoft C、联想 D、Sun
第四媒体是指（ ）。 A、报纸媒体 B、网络媒体 C、电视媒体 D、广播媒体
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf0d8e97ca56150a6ca154757c5cc726/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e12ace6b574ad0537639194057d089bc/" rel="bookmark">
			Vit 中的 Token 改进版本：Token Mreging: Your Vit But Faster 论文阅读笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vit 中的 Token 改进版本：Token Mreging: Your Vit But Faster 论文阅读笔记 一、Abstract二、引言三、相关工作3.1 有效的 Transformer3.2 Token 的减少3.3 Token 的联合 四、Token 融合4.1 策略4.2 Token 相似性4.3 双边软匹配4.4 追踪 Token 的尺寸4.5 采用融合操作的训练 五、图像实验5.1 设计的选项5.2 模型间的比较5.3 与其他方法的比较5.4 可视化的结果 六、视频实验七、音频实验八、结论 写在前面 都快一个月没写博客了，事情太多，又有拖延症，得改啊 (＞﹏＜)
论文题目：TOKEN MERGING: YOUR VIT BUT FASTER代码地址：https://github.com/facebookresearch/ToMe预计提交于 ICCV 2023 一、Abstract 本文引入一种 Token 融合的方法（Token Merging — ToMe），在无需额外训练的情况下增强现有 ViT 的性能。具体来说在 transformer 中使用一个通用且轻量化的匹配算法来逐步融合相似的 tokens。在图像、视频、音频上的性能绝佳。
二、引言 Transformer 的应用很广，效果也很好，就是训练速度太慢。最近提出的一些方法在修剪 tokens，然而有一些缺点：减少的 tokens 可能会使得信息丢失；可能需要重新训练才能让模型更有效；大部分方法不能用于加快模型的训练；根据输入的内容来修剪 tokens，会使得批量推理存在麻烦。
本文提出了 ToMe 来结合 tokens，而不是裁减掉这些。同时本文采用自定义的匹配算法，相对于剪枝来说更快且精度更高。此外，本文提出的方法需要或者不需要训练都可，在应用于大模型时只是会造成轻微的精度下降。在训练时如果使用 ToMe，时间会缩短，甚至在某些情况下训练时间减半。应用 ToMe 到图像、视频、音频上时能够达到 Sota 的效果。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e12ace6b574ad0537639194057d089bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/510348cf06c70bd3556ee43bb3e04ada/" rel="bookmark">
			音乐播放器微信小程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：学习目标：
掌握swiper组件、scroll-view组件的使用；掌握image组件的使用；掌握slider组件的使用；掌握音频API的使用； 二：目录：
1. 开发前的准备
1.1 音乐小程序项目展示：
1.1.1：音乐推荐界面展示：
1.1.2：播放器界面展示：
1.1.3：播放列表界面展示：
1.2：项目分析：
①：音乐播放器项目（项目结构图）
tab导航栏 content内容区 player音乐播放控件 ②：音乐播放器小程序项目主要文件：
app.js：应用程序的逻辑文件app.json：应用程序的配置文件pages/index/index1.js：index页面的逻辑文件pages/index/index1.json：index页面的配置文件pages/index/index1.wxss：index页面的样式文件pages/index/index1.wxml：index页面的结构文件pages/index/info.wxml：“音乐推荐”标签页的结构文件pages/index/play.wxml：“播放器”标签页的结构文件pages/index/playlist.wxml：“播放列表”标签页的结构文件images：图片文件 1.3：项目初始化：
开发者工具创建项目：
2. 标签页切换 2.1：任务分析：
标签页和页面结构图：
2.2 前导知识：
swiper组件常用属性：
可选值
说明
默认
indicator-dots
Boolean
是否显示面板指示点，默认为false
indicator-color
Color
指示点颜色，默认为rgba(0,0,0,.3)
indicator-active-color
Color
当前选中的指示点颜色，默认为#000000
autoplay
Boolean
是否自动切换，默认为false
current
Number
当前所在滑块的index，默认为0
current-item-id
String
当前所在滑块的item-id（不能同时指定current）
interval
Number
自动切换时间间隔（毫秒），默认为5000
duration
Number
滑动动画时长（毫秒），默认为500
circular
Boolean
是否采用衔接滑动，默认为false
vertical
Boolean
滑动方向是否为纵向，默认为false
bindchange
EventHandle
current改变时会触发change事件
swiper组件编写滑动页面结构 index1.wxml（本项目已完成，无此项代码）
③：include主要用途：
将代码拆分到多个文件中，可以更方便地查找代码。将代码公共部分抽取出来。通过外部文件引入。 ④：编写页面结构和样式-tab导航栏 2.3 编写页面结构和样式 ：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/510348cf06c70bd3556ee43bb3e04ada/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e61caf2c0100d171770e01f537c97de/" rel="bookmark">
			curl: (1) Protocol “‘http“ not supported or disabled in libcurl的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【现象】
C:\Users\Administrator&gt;curl -XPUT 'http://192.168.0.107:9200/cloud?pretty'
curl: (1) Protocol "'http" not supported or disabled in libcurl
C:\Users\Administrator&gt;
【解决方法】
url -XPUT 'http://192.168.0.107:9200/cloud?pretty'
修改为：
url -XPUT "http://192.168.0.107:9200/cloud?pretty"
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/989dd788212e18800481142ef61206ee/" rel="bookmark">
			软考初级-信息处理技术员
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		22年下半年也是顺利通过了软考初级-信息处理技术员，明年再报一次软设，今年上半年软设下午题没过，总结还是代码敲的少，想的太多hh，下面来看看我总结的上午题考点，非常感谢我好友老郑教我指点了我excel的函数，十分感谢😄，下面就是成绩图（成绩不高），总结下来刷题就稳过（就是考试的时候上午和历年真题偏差有点大，下午题一致）
上午题刷题即可
下午题刷题：一级ms office 下载链接：https://xhkt006.lanzoui.com/b00nrb2la
接下来会更新我在刷题反复错和混淆的知识点（具体的还得大家去刷题） 目录
excel函数：
引用符号：
国家标准知识：
数据库知识：
计算机基础知识： 计算机网络知识：
ppt知识： word知识： excel函数： power:次方
len:返回文本字符串 MAX:最大 MIN:最小 ABS:计算绝对值
例如:ABS(sum(A1:B1))是A1到B1单元格和的绝对值
AVERAGE:平均值 RouND(A1,0)的含义是对A1单元格中的值四舍五入不保留小数点 counta（B3,B12）的含义是：计算机B3到B12非空单元格的数量
product（A1:A2）/ABS (A3-A4)的含义是：A1和A2单元格中中的值的积除A3和A4单元格值的差的绝对值
TRUE：对（0），FALSE错（1） INT：向下取整函数：（-99.9）=-100 RIGHT("CHINA",1):表示字符串右端的1个字符 poundup的含义是向上舍入（3.1415912，2）=3.15表示对数据取两位，若后面有数字就舍入
RAND：随机数 md是产生0&lt;s&lt;1之间的随机数
MID（A1，8，4）含义从A1格中information第八位开始截取计算结果：tion
MEDIAN（A1:E5）含义：计算A1到E5单元格中数值的中值
NOT：求反函数。NOT（A1&lt;A2）为真则结果为假，反之则真
SIGN是求和函数，SIGN（100）=1 SIGN（-100）=-1 SIGN（0）=0
正数是1，负数是-1，0是0
绝对引用地址不变，相对引用地址会改变：
LIKE表示一种模糊查询
后面带*表示长度不限的任意字符
例如广*可以表示广东省
？表示点位符
例如：广？-----广东、广西......等 引用符号： " : "是等的意思
数学：+，-，*，/，%，^
比较：=，&lt; ,&gt; , &lt;=, &gt;= ,&lt;&gt;
文字运算符：&amp;可以将两个文本连接在一起
优先级：引用---算术-----文本----比较（由高到低）
国家标准知识： GB属于国家标准，T属于推荐标准
ISO是国际标准化，由ISO以及编号指明了iso发布的目标标准
com表示商业机构
gov表示政府机构
edu表示教育机构
net表示网络机构
org表示非赢利机构 数据库知识： 数据库的基本对象是：表、查询、报表、和窗体
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/989dd788212e18800481142ef61206ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b2a8cb82a9a92879ec5d958b4f24f0e/" rel="bookmark">
			《谷粒商城》开发记录 11：消息队列和分布式事务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、消息队列 1 使用场景 消息队列通常有三个使用场景：
● 异步：对于页面请求，只需要将消息发送给消息队列，就可以立即返回。
● 解耦：消息的发送方和接收方可以是两个毫不相干的系统。
● 流量控制(削峰)：消息接收方可以自定义接收消息的规则，在大流量下保证最后落到数据库的请求数不超出数据库的处理能力。
2 基本概念 ● AMQP：Advanced Message Queuing Protocol，一个提供统一消息服务的应用层高级消息队列协议，基于此协议的客户端与消息中间件之间可以传递消息。RabbitMQ的实现是基于AMQP协议的。
● Message：消息。由消息头和消息体组成。消息头包含了路由键、优先级、传输模式等内容。消息体是不透明的。
● Publisher：生产者。向消息队列推送消息的客户端应用程序。
● Consumer：消费者。从消息队列中获取消息的客户端应用程序。
● Broker：经纪人。消息队列服务器的整体。
● Virtual host：虚拟主机。Broker中可以单独完成消息队列功能的单位，包含一批交换器和队列。
● Exchange：交换器。负责接收生产者发送的消息，再按照一定的路由规则将这些消息路由给队列。
● Queue：队列。从交换器获得消息、保存消息，等消息被消费者处理后，删除消息。
● Binding：绑定。基于路由键，将交换器和队列连接起来的路由规则。
● Connection：连接。网络连接。
● Channel：信道。多路复用连接中的一条独立的双向数据流通道，是建立在真实的TCP连接内的虚拟连接。不管是发布消息、订阅队列还是接收消息，都通过信道完成。
3 交换器的路由规则 交换器共有四种类型：direct、fanout、topic、headers。
● direct：交换器将消息发送给绑定的、队列名与路由键(routing key)完全一致的单个队列。
● fanout：交换器将消息发送给绑定的每个队列。
● topic：交换器将消息发送给绑定的、队列名与路由键匹配的队列。队列名由若干个单词组成，单词之间使用"."隔开。路由键可以使用两个通配符："#"和"*"，"#"匹配0个或多个单词，"*"匹配一个单词。
● headers：在匹配规则上与direct相似，但是性能差很多，目前基本上不用了。
4 RabbitMQ 4.1 整合Spring Boot 1. 引入依赖。
groupId: org.springframework.boot
artifactId: spring-boot-starter-amqp
2. 在配置文件中添加配置。
spring.rabbitmq.host=192.168.56.10
spring.rabbitmq.port=5672
spring.rabbitmq.virtual-host=/
3. 在服务启动类上添加@EnableRabbit注解。
4. 在虚拟机上运行RabbitMQ。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b2a8cb82a9a92879ec5d958b4f24f0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b88a4910556d2ca869517a500434bb3/" rel="bookmark">
			Pycharm代码自动补全中的c，m,F, f，v，P, p分别是代表什么意思？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 大家往下看就明白了，图片下面翻译好了！希望有帮助到您！
简写图标代表（描述）中文意思cClass类m Method类实例方法FFunction函数fField类属性，域VVariable变量PPropertypython内置函数pParameter参数&lt;&gt;Element元素 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b902814792c247655aa7ffca55c6755d/" rel="bookmark">
			TypeScript接口、type关键字详解（可读、只读属性、继承接口|类、规范类、函数|可索引|类|混合类型接口、ReadonlyArray、接口&amp;type、映射类型）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
TypeScript接口
可选属性
:?
只读属性
ReadonlyArray
接口继承接口（extends）
接口继承类（extends）
接口规范类（implements）
函数类型接口
可索引类型接口
只读设置
类类型接口
规定构造函数 混合类型接口
type关键字
type扩展（&amp;）
interface继承type
映射类型
type高级使用
TypeScript接口 用于规范定义变量的类型，规定变量应该具有什么属性或函数入参什么值返回什么值等。
interface IUser { name: string age: number } let user: IUser = { name : 'yf', age: 32 } 可选属性 带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个?符号。定义的属性可以不用实现。
interface IUser { name: string age?: number } let user: IUser = { name : 'yf' } :? 注意区分冒号后也可以接问号。
const gender: ?number = undefined; // 等同于下面这种写法 const gender: number | null | void = undefined 只读属性 只读属性只能在对象刚刚创建的时候修改其值。 在属性名前用readonly来指定只读属性 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b902814792c247655aa7ffca55c6755d/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/116/">«</a>
	<span class="pagination__item pagination__item--current">117/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/118/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>