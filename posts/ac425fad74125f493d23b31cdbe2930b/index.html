<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>有向图的无权图最短路径算法与带权图的Dijkstra算法 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="有向图的无权图最短路径算法与带权图的Dijkstra算法" />
<meta property="og:description" content="最短路径算法是图论中的常见问题，在实际中有着较为广泛的应用，比如查找从一个地方到另一个地方的最快方式。问题可以概括为，对于某个输入顶点s，给出s到所有其它顶点的最短路径。水平有限，暂时先对这个问题的求解做简单记录。
无权图是有权最短路径的特例，即边的权重均是1。算法类似于BFS（宽度优先搜索），在实现时需要一个宽度优先搜索的队列。全局变量Distance用来保存所有点到输入顶点的距离。以邻接表表示图，无权图最短路径算法：
//无权图的最短路径算法 static void UnweightedShortestPath(Graph g, int start){ Queue&lt;Integer&gt; Q = new LinkedList&lt;Integer&gt;(); int v,w; Q.offer(start); g.getVertics().get(start).setVivited(true); //输入顶点被标记为已访问 for(int i=0;i&lt;g.getVertexCount();i&#43;&#43;) Distance[i] = -1; //初始化Distance，都为-1 Distance[start] = 0; while(!Q.isEmpty()){ v = Q.remove(); //v是队首的整数，记录了图中顶点的序号 while(g.getAdjUnvisitedVertex(v)!=-1){ //寻找顶点v指向的所有的点 w = g.getAdjUnvisitedVertex(v); g.getVertics().get(w).setVivited(true); //图的对应部分标记为已访问,每个顶点只能被访问一次 if(Distance[w] == -1){ Distance[w] = Distance[v]&#43;1; Path[w] = v; Q.offer(w); } }//while }//while } Dijkstra算法是解决最短路径问题的常见算法，过程需要使用优先队列来代替无权图最短路径算法。源点到某个顶点的距离为从源点到该顶点的路径上的所有边权值之和，当新计算得到的距离小于原有的距离时，更新距离。 //Dijkstra算法 static void Dijkstra(Graph g, int start){ MinHeap PQ = new MinHeap(10, 0); //最小堆实现优先队列 int v,w; PQ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/ac425fad74125f493d23b31cdbe2930b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-04-20T18:48:22+08:00" />
<meta property="article:modified_time" content="2017-04-20T18:48:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">有向图的无权图最短路径算法与带权图的Dijkstra算法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>  最短路径算法是图论中的常见问题，在实际中有着较为广泛的应用，比如查找从一个地方到另一个地方的最快方式。问题可以概括为，对于某个输入顶点s，给出s到所有其它顶点的最短路径。水平有限，暂时先对这个问题的求解做简单记录。</p> 
<p>  无权图是有权最短路径的特例，即边的权重均是1。算法类似于BFS（宽度优先搜索），在实现时需要一个宽度优先搜索的队列。全局变量Distance用来保存所有点到输入顶点的距离。以邻接表表示图，无权图最短路径算法：</p> 
<p></p> 
<pre><code class="language-java">//无权图的最短路径算法
	static void UnweightedShortestPath(Graph g, int start){
		Queue&lt;Integer&gt; Q = new LinkedList&lt;Integer&gt;();
		int v,w;
		Q.offer(start);
		g.getVertics().get(start).setVivited(true);  //输入顶点被标记为已访问
		for(int i=0;i&lt;g.getVertexCount();i++)
			Distance[i] = -1;   //初始化Distance，都为-1
		Distance[start] = 0;
		while(!Q.isEmpty()){
			v = Q.remove();    //v是队首的整数，记录了图中顶点的序号
			while(g.getAdjUnvisitedVertex(v)!=-1){           //寻找顶点v指向的所有的点
				w = g.getAdjUnvisitedVertex(v);
				g.getVertics().get(w).setVivited(true);  //图的对应部分标记为已访问,每个顶点只能被访问一次
				if(Distance[w] == -1){
					Distance[w] = Distance[v]+1;
					Path[w] = v;
					Q.offer(w);
				}
			}//while
		}//while
	}</code></pre>  Dijkstra算法是解决最短路径问题的常见算法，过程需要使用优先队列来代替无权图最短路径算法。源点到某个顶点的距离为从源点到该顶点的路径上的所有边权值之和，当新计算得到的距离小于原有的距离时，更新距离。 
<p></p> 
<p></p> 
<pre><code class="language-java">//Dijkstra算法
	static void Dijkstra(Graph g, int start){
		MinHeap PQ = new MinHeap(10, 0);     //最小堆实现优先队列
		int v,w;
		PQ.Insert(new NodeWithProority(0,0));//NodeWithprority是一个只包括顶点的序号和权值（到给定起始点的距离）的类
		g.getVertics().get(start).setVivited(true);
		for( int i=0;i&lt;g.getVertexCount();i++ )
			Distance[i]=-1;
		Distance[start] = 0;
		while(!PQ.isEmpty()){
			v = PQ.DeleteMin().node;
			while(g.getAdjUnvisitedVertex(v)!=-1){
				w = g.getAdjUnvisitedVertex(v);
				g.getVertics().get(w).setVivited(true);  //图的对应部分标记为已访问,每个顶点只能被访问一次
				int d = Distance[v]+g.Weight(v, w);      //计算新的距离
				if(Distance[w] == -1){
					Distance[w] = d;
					PQ.Insert(new NodeWithProority(w, d));
					Path[w] = v;
				}//if
				if(Distance[w] &gt; d){                    //如果新的距离比原有的小，需要更新距离
					Distance[w] = d;
					for(int i=0;i&lt;PQ.count;i++){
						if(PQ.array[i].node == w){
							PQ.array[i].priority = d;
							PQ.Parent(0);
						}
					}
					Path[w] = v;
				}//if
			}//while
			for(int j=0;j&lt;g.getVertexCount();j++)  //将访问标记初始化
				g.getVertics().get(j).setVivited(false);
		}//while
	}</code></pre> 
<br> 
<br> 
<br> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b42a8f1f6c790d3d5d1a35f9ac94642d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Mac admin用户sudo权限失效</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a798d6d482335b57080e8855bb158fc7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java和php时间戳转换问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>