<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java集合之ArrayList解析 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java集合之ArrayList解析" />
<meta property="og:description" content="ArrayList是基于动态数组实现增删改查操作,进行顺序存储的,在内存中各个元素的地 址是连续的.
ArrayList组织结构图: 根据上面的结构图知道ArrayList继承AbstractList并实现了RandomAccess,Cloneable,Serializable这三个标记接口,所以AbstractList具有如下特性: AbstractList:实现了增删改查的集合操作,并可以对集合进行迭代查询。RandomAccess:随机访问性能很高.Cloneable:ArrayList对象可以进行克隆.Serializable:ArrayList对象可以进行序列化和反序列化存储和读取. ArrayList简要基本用法: public boolean add(E var1)//在集合末尾添加数据var1
public void add(int index, E var2)//在索引位置为index的位置处插入数据var2
public E remove(int index)//删除集合中索引位置为index的元素.
public boolean remove(Object var1)//删除集合中值为var1的元素,查找元素var1是用var1的equals方法比对的,如果var1是null,就查找集合中值为null的元素并删除.(这里需要注意的是删除的元素是集合中第一个为var1或null的元素,并不是所有).
public E set(int index, E var2)//修改索引为index元素的值为var2;
public E get(int index)//获取索引index处的元素数据.
ArrayList的遍历: 增强式for循环
ArrayList&lt;Integer&gt; arrayList=new ArrayList&lt;&gt;(); arrayList.add(1); arrayList.add(2); arrayList.add(3); for (Integer integer:arrayList){ System.out.println(integer); } Iterator迭代
ArrayList&lt;Integer&gt; arrayList=new ArrayList&lt;&gt;(); arrayList.add(1); arrayList.add(2); arrayList.add(3); Iterator&lt;Integer&gt; iterator=arrayList.iterator(); while (iterator.hasNext()){ System.out.println(iterator.next()); } ArrayList的元素过滤 Iterator迭代过滤
ArrayList&lt;Integer&gt; arrayList=new ArrayList&lt;&gt;(); arrayList.add(1); arrayList.add(2); arrayList.add(3); Iterator&lt;Integer&gt; iterator=arrayList." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/2dd1e95b562792cb5d507e0ba374981b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-09-13T15:05:34+08:00" />
<meta property="article:modified_time" content="2017-09-13T15:05:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java集合之ArrayList解析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>ArrayList是基于动态数组实现增删改查操作,进行顺序存储的,在内存中各个元素的地 <br> 址是连续的.</p> 
</blockquote> 
<h6 id="arraylist组织结构图">ArrayList组织结构图:</h6> 
<p><img src="https://images2.imgbox.com/85/17/WU6BVPJT_o.jpg" alt="这里写图片描述" title=""></p> 
<h6 id="根据上面的结构图知道arraylist继承abstractlist并实现了randomaccesscloneableserializable这三个标记接口所以abstractlist具有如下特性">根据上面的结构图知道ArrayList继承AbstractList并实现了RandomAccess,Cloneable,Serializable这三个标记接口,所以AbstractList具有如下特性:</h6> 
<ul><li>AbstractList:实现了增删改查的集合操作,并可以对集合进行迭代查询。</li><li>RandomAccess:随机访问性能很高.</li><li>Cloneable:ArrayList对象可以进行克隆.</li><li>Serializable:ArrayList对象可以进行序列化和反序列化存储和读取.</li></ul> 
<h6 id="arraylist简要基本用法">ArrayList简要基本用法:</h6> 
<blockquote> 
 <p>public boolean add(E var1)//在集合末尾添加数据var1</p> 
 <p>public void add(int index, E var2)//在索引位置为index的位置处插入数据var2</p> 
 <p>public E remove(int index)//删除集合中索引位置为index的元素.</p> 
 <p>public boolean remove(Object var1)//删除集合中值为var1的元素,查找元素var1是用var1的equals方法比对的,如果var1是null,就查找集合中值为null的元素并删除.(这里需要注意的是删除的元素是集合中第一个为var1或null的元素,并不是所有).</p> 
 <p>public E set(int index, E var2)//修改索引为index元素的值为var2;</p> 
 <p>public E get(int index)//获取索引index处的元素数据.</p> 
</blockquote> 
<h6 id="arraylist的遍历">ArrayList的遍历:</h6> 
<p><font color="#ff00">增强式for循环</font></p> 
<pre class="prettyprint"><code class=" hljs avrasm">ArrayList&lt;Integer&gt; arrayList=new ArrayList&lt;&gt;()<span class="hljs-comment">;</span>
        arrayList<span class="hljs-preprocessor">.add</span>(<span class="hljs-number">1</span>)<span class="hljs-comment">;</span>
        arrayList<span class="hljs-preprocessor">.add</span>(<span class="hljs-number">2</span>)<span class="hljs-comment">;</span>
        arrayList<span class="hljs-preprocessor">.add</span>(<span class="hljs-number">3</span>)<span class="hljs-comment">;</span>

        for (Integer integer:arrayList){
            System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(integer)<span class="hljs-comment">;</span>
        }
</code></pre> 
<p><font color="#ff00">Iterator迭代</font></p> 
<pre class="prettyprint"><code class=" hljs oxygene"> ArrayList&lt;Integer&gt; arrayList=<span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        arrayList.<span class="hljs-keyword">add</span>(<span class="hljs-number">1</span>);
        arrayList.<span class="hljs-keyword">add</span>(<span class="hljs-number">2</span>);
        arrayList.<span class="hljs-keyword">add</span>(<span class="hljs-number">3</span>);

        <span class="hljs-keyword">Iterator</span>&lt;Integer&gt; <span class="hljs-keyword">iterator</span>=arrayList.<span class="hljs-keyword">iterator</span>();
        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">iterator</span>.hasNext())<span class="hljs-comment">{
            System.out.println(iterator.next());
        }</span></code></pre> 
<h5 id="arraylist的元素过滤">ArrayList的元素过滤</h5> 
<p><font color="#ff00">Iterator迭代过滤</font></p> 
<pre class="prettyprint"><code class=" hljs oxygene">ArrayList&lt;Integer&gt; arrayList=<span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        arrayList.<span class="hljs-keyword">add</span>(<span class="hljs-number">1</span>);
        arrayList.<span class="hljs-keyword">add</span>(<span class="hljs-number">2</span>);
        arrayList.<span class="hljs-keyword">add</span>(<span class="hljs-number">3</span>);

        <span class="hljs-keyword">Iterator</span>&lt;Integer&gt; <span class="hljs-keyword">iterator</span>=arrayList.<span class="hljs-keyword">iterator</span>();
        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">iterator</span>.hasNext())<span class="hljs-comment">{
            Integer integer=iterator.next();
            if(integer&gt;=3){//删除ArrayList集合中大于等于3的所有元素
                iterator.remove();
            }</span>
        }</code></pre> 
<p><font color="#ff00">for循环过滤</font></p> 
<h6 id="抛出javautilconcurrentmodificationexception异常所以这种方式是错误的后面会介绍原因">抛出java.util.ConcurrentModificationException异常,所以这种方式是错误的,后面会介绍原因.</h6> 
<pre class="prettyprint"><code class=" hljs oxygene">ArrayList&lt;Integer&gt; arrayList=<span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        arrayList.<span class="hljs-keyword">add</span>(<span class="hljs-number">1</span>);
        arrayList.<span class="hljs-keyword">add</span>(<span class="hljs-number">2</span>);
        arrayList.<span class="hljs-keyword">add</span>(<span class="hljs-number">3</span>);

        <span class="hljs-keyword">for</span>(Integer e:arrayList)<span class="hljs-comment">{
            if(e&gt;=3){
                arrayList.remove(e);
            }</span>
        }</code></pre> 
<hr> 
<h5 id="arraylist源码解析">ArrayList源码解析</h5> 
<p>成员变量说明:</p> 
<blockquote> 
 <p>private static final int DEFAULT_CAPACITY = 10默认存储空间为10</p> 
 <p>private static final Object[] EMPTY_ELEMENTDATA = new Object[0]空动态数组</p> 
 <p>private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = new Object[0];空容量数组</p> 
 <p>transient Object[] elementData;动态获取存储地址的数组elementData,它是不可以进行序列化的,作用与static修饰符一样.</p> 
 <p>private int size;数组中有效元素的个数。</p> 
 <p>private static final int MAX_ARRAY_SIZE = 2147483639;//动态数组的最大容量.</p> 
</blockquote> 
<p>构造函数说明:</p> 
<h6 id="默认构造函数创建一个空容量的数组给elementdata">默认构造函数,创建一个空容量的数组给elementData</h6> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span>() {
        <span class="hljs-keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    }</code></pre> 
<h6 id="创建指定容量的数组集合">创建指定容量的数组集合。</h6> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span>(<span class="hljs-keyword">int</span> var1) {
        <span class="hljs-keyword">if</span>(var1 &gt; <span class="hljs-number">0</span>) {<!-- --><span class="hljs-comment">//大于0创建指定长度的数组给elementData</span>
            <span class="hljs-keyword">this</span>.elementData = <span class="hljs-keyword">new</span> Object[var1];
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span>(var1 != <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Illegal Capacity: "</span> + var1);<span class="hljs-comment">//如果小于0抛出异常</span>
            }

            <span class="hljs-keyword">this</span>.elementData = EMPTY_ELEMENTDATA;<span class="hljs-comment">//若等于0赋值空数组.</span>
        }

    }</code></pre> 
<h6 id="创建一个初始数据为var1的集合给elementdata">创建一个初始数据为var1的集合给elementData;</h6> 
<pre class="prettyprint"><code class=" hljs actionscript"><span class="hljs-keyword">public</span> ArrayList(Collection&lt;? <span class="hljs-keyword">extends</span> E&gt; var1) {
        <span class="hljs-keyword">this</span>.elementData = var1.toArray();<span class="hljs-comment">//首先调用集合的toArray转换为数组并赋值给elementData</span>
        <span class="hljs-keyword">if</span>((<span class="hljs-keyword">this</span>.size = <span class="hljs-keyword">this</span>.elementData.length) != <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.elementData.getClass() != Object[].<span class="hljs-keyword">class</span>) {
                <span class="hljs-keyword">this</span>.elementData = Arrays.copyOf(<span class="hljs-keyword">this</span>.elementData, <span class="hljs-keyword">this</span>.size, Object[].<span class="hljs-keyword">class</span>);
            }
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">this</span>.elementData = EMPTY_ELEMENTDATA;<span class="hljs-comment">//长度为0，赋值空数组</span>
        }

    }</code></pre> 
<p>公共方法解析:</p> 
<p>add方法源码:</p> 
<pre class="prettyprint"><code class=" hljs java">   <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span>(E var1) {
        <span class="hljs-keyword">this</span>.ensureCapacityInternal(<span class="hljs-keyword">this</span>.size + <span class="hljs-number">1</span>);
        <span class="hljs-keyword">this</span>.elementData[<span class="hljs-keyword">this</span>.size++] = var1;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }       </code></pre> 
<p>1.它首先调用ensureCapacityInternal确保数组元素的空间足够, ensureCapacityInternal源码如下:</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacityInternal</span>(<span class="hljs-keyword">int</span> var1) {
        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
            var1 = Math.max(<span class="hljs-number">10</span>, var1);
        }

        <span class="hljs-keyword">this</span>.ensureExplicitCapacity(var1);
    }</code></pre> 
<p>2.判断数组是不是空的,如果是空的，则首次为它分配的容量至少为10,然后调用ensureExplicitCapacity.</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureExplicitCapacity</span>(<span class="hljs-keyword">int</span> var1) {
        ++<span class="hljs-keyword">this</span>.modCount;
        <span class="hljs-keyword">if</span>(var1 - <span class="hljs-keyword">this</span>.elementData.length &gt; <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">this</span>.grow(var1);
        }
    }</code></pre> 
<p>3.modCount表示内部修改次数(后面会解释),判断需要的长度是否大于当前数组elementData的长度,如果是就执行grow方法进行扩容.</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">grow</span>(<span class="hljs-keyword">int</span> var1) {
        <span class="hljs-keyword">int</span> var2 = <span class="hljs-keyword">this</span>.elementData.length;
        <span class="hljs-keyword">int</span> var3 = var2 + (var2 &gt;&gt; <span class="hljs-number">1</span>);<span class="hljs-comment">//右移一位相当于除2，所以是1.5倍</span>
        <span class="hljs-keyword">if</span>(var3 - var1 &lt; <span class="hljs-number">0</span>) {
            var3 = var1;
        }

        <span class="hljs-keyword">if</span>(var3 - <span class="hljs-number">2147483639</span> &gt; <span class="hljs-number">0</span>) {
            var3 = hugeCapacity(var1);
        }

        <span class="hljs-keyword">this</span>.elementData = Arrays.copyOf(<span class="hljs-keyword">this</span>.elementData, var3);
    }</code></pre> 
<p>4.首先将当前数组的长度扩容为1.5倍，如果此时扩容后的容量仍然小于需要的长度,就将当前数组的长度改为需要的长度.</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span>(<span class="hljs-keyword">int</span> index, E var2) {
        <span class="hljs-keyword">this</span>.rangeCheckForAdd(var1);
        <span class="hljs-keyword">this</span>.ensureCapacityInternal(<span class="hljs-keyword">this</span>.size + <span class="hljs-number">1</span>);
        System.arraycopy(<span class="hljs-keyword">this</span>.elementData, var1, <span class="hljs-keyword">this</span>.elementData, var1 + <span class="hljs-number">1</span>, <span class="hljs-keyword">this</span>.size - var1);
        <span class="hljs-keyword">this</span>.elementData[var1] = var2;
        ++<span class="hljs-keyword">this</span>.size;
    }
</code></pre> 
<p>这个方法与add(E var1)差不多,实现的思想是首先判断索引是否越界,如果越界抛出IndexOutOfBoundsException异常,否则执行确保容量足够的方法,其次将index索引后的所有元素向后移动, z在index索引处插入元素var1，最后修改size+1;</p> 
<h5 id="remove操作">remove操作</h5> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">public</span> E <span class="hljs-title">remove</span>(<span class="hljs-keyword">int</span> var1) {
        <span class="hljs-keyword">this</span>.rangeCheck(var1);
        ++<span class="hljs-keyword">this</span>.modCount;
        Object var2 = <span class="hljs-keyword">this</span>.elementData(var1);
        <span class="hljs-keyword">int</span> var3 = <span class="hljs-keyword">this</span>.size - var1 - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span>(var3 &gt; <span class="hljs-number">0</span>) {
            System.arraycopy(<span class="hljs-keyword">this</span>.elementData, var1 + <span class="hljs-number">1</span>, <span class="hljs-keyword">this</span>.elementData, var1, var3);
        }

        <span class="hljs-keyword">this</span>.elementData[--<span class="hljs-keyword">this</span>.size] = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">return</span> var2;
    }
</code></pre> 
<p>首先检查是否数组越界,如果没有越界执行modCount+1,修改modCound的值,然后获得数组elemntData中索引为var1的元素,计算index数组复制的便宜量,即将index+1处的所有元素向前移动,最后修改数组末尾的元素值为null,等待GC回收并返回删除的元素.</p> 
<pre class="prettyprint"><code class=" hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span>(Object var1) {
        <span class="hljs-keyword">int</span> var2;
        <span class="hljs-keyword">if</span>(var1 == <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">for</span>(var2 = <span class="hljs-number">0</span>; var2 &lt; <span class="hljs-keyword">this</span>.size; ++var2) {
                <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.elementData[var2] == <span class="hljs-keyword">null</span>) {
                    <span class="hljs-keyword">this</span>.fastRemove(var2);
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
                }
            }
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">for</span>(var2 = <span class="hljs-number">0</span>; var2 &lt; <span class="hljs-keyword">this</span>.size; ++var2) {
                <span class="hljs-keyword">if</span>(var1.equals(<span class="hljs-keyword">this</span>.elementData[var2])) {
                    <span class="hljs-keyword">this</span>.fastRemove(var2);
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
                }
            }
        }

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fastRemove</span>(<span class="hljs-keyword">int</span> var1) {
        ++<span class="hljs-keyword">this</span>.modCount;
        <span class="hljs-keyword">int</span> var2 = <span class="hljs-keyword">this</span>.size - var1 - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span>(var2 &gt; <span class="hljs-number">0</span>) {
            System.arraycopy(<span class="hljs-keyword">this</span>.elementData, var1 + <span class="hljs-number">1</span>, <span class="hljs-keyword">this</span>.elementData, var1, var2);
        }

        <span class="hljs-keyword">this</span>.elementData[--<span class="hljs-keyword">this</span>.size] = <span class="hljs-keyword">null</span>;
    }
</code></pre> 
<p>remove(Object var1)删除数组元素需要区分null和非null值,非null值比较的对象是用equals.上面源码比较简单不再重复赘述.</p> 
<h5 id="清空arraylist集合元素">清空ArrayList集合元素</h5> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span>() {
        ++<span class="hljs-keyword">this</span>.modCount;

        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> var1 = <span class="hljs-number">0</span>; var1 &lt; <span class="hljs-keyword">this</span>.size; ++var1) {
            <span class="hljs-keyword">this</span>.elementData[var1] = <span class="hljs-keyword">null</span>;
        }

        <span class="hljs-keyword">this</span>.size = <span class="hljs-number">0</span>;
    }</code></pre> 
<p>实现思想是:迭代数组中的元素分别设置为null,修改size为0，modCount++;</p> 
<h5 id="arraylist实现了iterable接口">ArrayList实现了Iterable接口</h5> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> Iterable&lt;T&gt; {
    Iterator&lt;T&gt; iterator();
}</code></pre> 
<p>子类需要实现iterator()方法并返回Iterator对象</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> Iterator&lt;E&gt; {
    boolean hasNext();

    E next();

    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> remove() {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException(<span class="hljs-string">"remove"</span>);
    }</code></pre> 
<p>调用ArrayList的iterator()方法调用下面的逻辑实现:</p> 
<pre class="prettyprint"><code class=" hljs cs"> <span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title">iterator</span>() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList.Itr();
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> Itr implements Iterator&lt;E&gt; {
        <span class="hljs-keyword">int</span> cursor;
        <span class="hljs-keyword">int</span> lastRet;
        <span class="hljs-keyword">int</span> expectedModCount;

        <span class="hljs-keyword">private</span> <span class="hljs-title">Itr</span>() {
            <span class="hljs-keyword">this</span>.lastRet = -<span class="hljs-number">1</span>;
            <span class="hljs-keyword">this</span>.expectedModCount = ArrayList.<span class="hljs-keyword">this</span>.modCount;
        }

        <span class="hljs-keyword">public</span> boolean <span class="hljs-title">hasNext</span>() {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.cursor != ArrayList.<span class="hljs-keyword">this</span>.size;
        }

        <span class="hljs-keyword">public</span> E <span class="hljs-title">next</span>() {
            <span class="hljs-keyword">this</span>.checkForComodification();
            <span class="hljs-keyword">int</span> var1 = <span class="hljs-keyword">this</span>.cursor;
            <span class="hljs-keyword">if</span>(var1 &gt;= ArrayList.<span class="hljs-keyword">this</span>.size) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();
            } <span class="hljs-keyword">else</span> {
                Object[] var2 = ArrayList.<span class="hljs-keyword">this</span>.elementData;
                <span class="hljs-keyword">if</span>(var1 &gt;= var2.length) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">this</span>.cursor = var1 + <span class="hljs-number">1</span>;
                    <span class="hljs-keyword">return</span> var2[<span class="hljs-keyword">this</span>.lastRet = var1];
                }
            }
        }

        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span>() {
            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.lastRet &lt; <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException();
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">this</span>.checkForComodification();

                <span class="hljs-keyword">try</span> {
                    ArrayList.<span class="hljs-keyword">this</span>.remove(<span class="hljs-keyword">this</span>.lastRet);
                    <span class="hljs-keyword">this</span>.cursor = <span class="hljs-keyword">this</span>.lastRet;
                    <span class="hljs-keyword">this</span>.lastRet = -<span class="hljs-number">1</span>;
                    <span class="hljs-keyword">this</span>.expectedModCount = ArrayList.<span class="hljs-keyword">this</span>.modCount;
                } <span class="hljs-keyword">catch</span> (IndexOutOfBoundsException var2) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();
                }
            }
        }</code></pre> 
<p>实际上得到的是内部类Itr的实例,注意上面执行next()方法每次迭代器操作的时候都要首先调用checkForComodification(),它是什么呢？</p> 
<pre class="prettyprint"><code class=" hljs java">  <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> checkForComodification() {
            <span class="hljs-keyword">if</span>(ArrayList.<span class="hljs-keyword">this</span>.modCount != <span class="hljs-keyword">this</span>.expectedModCount) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();
            }
        }</code></pre> 
<p>看到了吧它就是用来比对modCount与expectModCount的值,这里就知道了为什么对集合进行删除，添加的时候需要修改modCount的值,当二者不等的时候抛出异常.</p> 
<p>iterator执行remove()方法时会执行this.expectedModCount = ArrayList.this.modCount;二者永远相等所以进行迭代执行过滤操作的时候不会出现异常。而for循环是发生了并发修改异常，为什么呢？迭代器内部会维护一些索引位置相关的数据，要求在迭代过程中，容器不能发生结构性变化，否则这些索引位置就失效了。所谓结构性变化就是添加、插入和删除元素，只是修改元素内容不算结构性变化。</p> 
<hr> 
<h5 id="arraylist的特点">ArrayList的特点:</h5> 
<ul><li>查询效率高</li><li>删除和添加元素需要移动数组所以效率比较低</li><li>与LinkList正好相反,后面会分析LinkList的实现源码。</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e6b4b8a765d05112d7d05d4258c3b9b6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">linux内核态文件操作filp_open/filp_close/vfs_read/vfs_write</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6d4ca34d2096a3dba25638860723d71a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java杂文系列(2) eclipse集成drools规则引擎</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>