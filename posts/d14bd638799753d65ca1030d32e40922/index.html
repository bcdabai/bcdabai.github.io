<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>前端知识点总结——蔚来一面面经 / webpack打包的入口 / loader和plugin的区别 / 语义化代码 / Vue路由守卫 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="前端知识点总结——蔚来一面面经 / webpack打包的入口 / loader和plugin的区别 / 语义化代码 / Vue路由守卫" />
<meta property="og:description" content="webpack打包的入口 在vue-cli3中查看webpack的配置信息，输入vue inspect &gt; output.js
entry 入口，告诉webpack要使用哪个模块作为构建项目的起点，默认为./src/main.js entry: { app: [ &#39;./src/main.js&#39; ] } output 出口，告诉webpack在哪里输出它打包好的代码以及如何命名，默认为./dist output: { path: &#39;/Users/zhangzhenkun/Desktop/JS高级/VueTest/vue_test/dist&#39;, filename: &#39;js/[name].js&#39;, publicPath: &#39;/&#39;, chunkFilename: &#39;js/[name].js&#39; } loader和plugin的区别 Loader 本质就是一个函数，将一个语言转换为另一个语言。webpack自身只支持js和json这两种格式的文件，对于其他文件需要通过loader将其转换为commonJS规范的文件后，webpack才能解析到
css-loader：加载 CSS
style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS
image-loader：加载并且压缩图片文件
Plugin 就是插件，在打包前和打包后对结果再次进行操作。是用于在webpack打包编译过程里，在对应的事件节点里执行自定义操作，比如资源管理、bundle文件优化等操作。
uglify-webpack-plugin：丑化代码
ignore-plugin：忽略部分文件
babel-polyfill：es5转换为es6
语义化代码 意义：根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。作用： 在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息便于团队开发和维护，语义化更具可读性 新增的语义化标签：header footer nav audio video Vue路由守卫 路由守卫执行顺序：
路由守卫可以简单描述为路由跳转过程中的一些钩子函数，在路由跳转的过程中通过定义一些函数执行一些操作。
完整的导航解析流程： 导航被触发。在失活的组件里调用 beforeRouteLeave 守卫。调用全局的 beforeEach 守卫。在重用的组件里调用 beforeRouteUpdate 守卫 (2.2&#43;)。在路由配置里调用 beforeEnter。解析异步路由组件。在被激活的组件里调用 beforeRouteEnter。调用全局的 beforeResolve 守卫 (2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/d14bd638799753d65ca1030d32e40922/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-08-23T10:10:27+08:00" />
<meta property="article:modified_time" content="2021-08-23T10:10:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">前端知识点总结——蔚来一面面经 / webpack打包的入口 / loader和plugin的区别 / 语义化代码 / Vue路由守卫</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="webpack_0"></a>webpack打包的入口</h2> 
<p>在vue-cli3中查看webpack的配置信息，输入<code>vue inspect &gt; output.js</code><br> <img src="https://images2.imgbox.com/1f/3a/iApfzWQX_o.png" alt="在这里插入图片描述"></p> 
<ol><li>entry 入口，告诉webpack要使用哪个模块作为构建项目的起点，默认为./src/main.js</li></ol> 
<pre><code class="prism language-js">  entry<span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
    app<span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token string">'./src/main.js'</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
</code></pre> 
<ol start="2"><li>output 出口，告诉webpack在哪里输出它打包好的代码以及如何命名，默认为./dist</li></ol> 
<pre><code class="prism language-js">  output<span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
    path<span class="token operator">:</span> <span class="token string">'/Users/zhangzhenkun/Desktop/JS高级/VueTest/vue_test/dist'</span><span class="token punctuation">,</span>
    filename<span class="token operator">:</span> <span class="token string">'js/[name].js'</span><span class="token punctuation">,</span>
    publicPath<span class="token operator">:</span> <span class="token string">'/'</span><span class="token punctuation">,</span>
    chunkFilename<span class="token operator">:</span> <span class="token string">'js/[name].js'</span>
  <span class="token punctuation">}</span>
</code></pre> 
<h2><a id="loaderplugin_21"></a>loader和plugin的区别</h2> 
<ol><li> <p><code>Loader</code> 本质就是一个函数，<strong>将一个语言转换为另一个语言</strong>。webpack自身只支持js和json这两种格式的文件，对于其他文件需要通过loader将其转换为commonJS规范的文件后，webpack才能解析到<br> <code>css-loader</code>：加载 CSS<br> <code>style-loader</code>：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS<br> <code>image-loader</code>：加载并且压缩图片文件</p> </li><li> <p><code>Plugin</code> 就是插件，<strong>在打包前和打包后对结果再次进行操作</strong>。是用于在webpack打包编译过程里，在对应的事件节点里执行自定义操作，比如资源管理、bundle文件优化等操作。<br> <code>uglify-webpack-plugin</code>：丑化代码<br> <code>ignore-plugin</code>：忽略部分文件<br> <code>babel-polyfill</code>：es5转换为es6</p> </li></ol> 
<h2><a id="_32"></a>语义化代码</h2> 
<ol><li>意义：根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。</li><li>作用： 
  <ol><li>在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构</li><li>和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息</li><li>便于团队开发和维护，语义化更具可读性</li></ol> </li><li>新增的语义化标签：<code>header</code> <code>footer</code> <code>nav</code> <code>audio</code> <code>video</code></li></ol> 
<h2><a id="Vue_40"></a>Vue路由守卫</h2> 
<p>路由守卫执行顺序：<br> <img src="https://images2.imgbox.com/bb/0b/DK4GS5HM_o.png" alt="在这里插入图片描述"><br> 路由守卫可以简单描述为路由跳转过程中的一些钩子函数，在路由跳转的过程中通过定义一些函数执行一些操作。</p> 
<ul><li>完整的导航解析流程：</li></ul> 
<ol><li>导航被触发。</li><li>在失活的组件里调用 beforeRouteLeave 守卫。</li><li>调用全局的 beforeEach 守卫。</li><li>在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。</li><li>在路由配置里调用 beforeEnter。</li><li>解析异步路由组件。</li><li>在被激活的组件里调用 beforeRouteEnter。</li><li>调用全局的 beforeResolve 守卫 (2.5+)。</li><li>导航被确认。</li><li>调用全局的 afterEach 钩子。</li><li>触发 DOM 更新。</li><li>调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。</li></ol> 
<p><strong>当点击切换路由时：<br> beforeRouterLeave–&gt;beforeEach–&gt;beforeEnter–&gt;beforeRouteEnter–&gt;beforeResolve–&gt;afterEach–&gt;beforeCreate–&gt;created–&gt;beforeMount–&gt;mounted–&gt;beforeRouteEnter的next的回调</strong></p> 
<p>主要应用场景：<a href="https://www.jianshu.com/p/0e3e760a08ce" rel="nofollow">使用路由守卫实现用户登陆跳转例子讲解</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7dadfcd1655d6fbe7fc2b67544efa7b4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【命令行问题】`complete:13: command not found: compdef `</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e71ede93aa3d3bffa431795d5a37bcf5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">mobx环境配置、基础知识</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>