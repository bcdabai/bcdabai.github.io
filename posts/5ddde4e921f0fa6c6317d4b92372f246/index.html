<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java错题集(十四) - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java错题集(十四)" />
<meta property="og:description" content="目录
以下代码段执行后的输出结果为
java语言的下面几种数组复制方法中，哪个效率最高？
在 myjsp.jsp 中，关于下面的代码说法错误的是： ( ) 下面代码的输出是什么？
关于ThreadLocal类 以下说法正确的是
下面程序的输出是:()
使用mvc模式设计的web应用程序具有以下优点,除了？
Java数据库连接库JDBC用到哪种设计模式?
关于Java和C/C&#43;&#43;的比较，下列哪个描述是错误的？
关于volatile关键字，下列描述不正确的是？
JVM内存不包含如下哪个部分( )
以下哪些继承自 Collection 接口（）
事务隔离级别是由谁实现的？
计算机所能处理的最小的数据项称为（）
顺序执行下列程序语句后，则b的值是（）
下面有关forward和redirect的描述，正确的是() ？
下列那些方法是线程安全的(所调用的方法都存在)
以下代码段执行后的输出结果为 public class Test { public static void main(String args[]) { int x = -5; int y = -12; System.out.println(y % x); } } 正确答案: D 你的答案: D (正确)
-1 2 1 -2 来源：https://www.nowcoder.com/questionTerminal/7b4ec6887dc04af992ce10dadfb532bb
Y(被除数) % X(除数) 当除数与被除数的符号相同时，取余和取模的结果是完全相同的； 当除数与被除数的符号不相同时，结果不同。
具体说，取余结果的符号与被除数相同；取模结果的符号与除数相同。
1.取余 rem(3,2)=1 rem(-3,-2)=-1 rem(3,-2)=1 rem(-3,2)=-1 2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/5ddde4e921f0fa6c6317d4b92372f246/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-02-09T17:51:30+08:00" />
<meta property="article:modified_time" content="2021-02-09T17:51:30+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java错题集(十四)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%BB%A5%E4%B8%8B%E4%BB%A3%E7%A0%81%E6%AE%B5%E6%89%A7%E8%A1%8C%E5%90%8E%E7%9A%84%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%E4%B8%BA-toc" style="margin-left:80px;"><a href="#%E4%BB%A5%E4%B8%8B%E4%BB%A3%E7%A0%81%E6%AE%B5%E6%89%A7%E8%A1%8C%E5%90%8E%E7%9A%84%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%E4%B8%BA" rel="nofollow">以下代码段执行后的输出结果为</a></p> 
<p id="java%E8%AF%AD%E8%A8%80%E7%9A%84%E4%B8%8B%E9%9D%A2%E5%87%A0%E7%A7%8D%E6%95%B0%E7%BB%84%E5%A4%8D%E5%88%B6%E6%96%B9%E6%B3%95%E4%B8%AD%EF%BC%8C%E5%93%AA%E4%B8%AA%E6%95%88%E7%8E%87%E6%9C%80%E9%AB%98%EF%BC%9F-toc" style="margin-left:80px;"><a href="#java%E8%AF%AD%E8%A8%80%E7%9A%84%E4%B8%8B%E9%9D%A2%E5%87%A0%E7%A7%8D%E6%95%B0%E7%BB%84%E5%A4%8D%E5%88%B6%E6%96%B9%E6%B3%95%E4%B8%AD%EF%BC%8C%E5%93%AA%E4%B8%AA%E6%95%88%E7%8E%87%E6%9C%80%E9%AB%98%EF%BC%9F" rel="nofollow">java语言的下面几种数组复制方法中，哪个效率最高？</a></p> 
<p id="%E5%9C%A8%20myjsp.jsp%20%E4%B8%AD%EF%BC%8C%E5%85%B3%E4%BA%8E%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81%E8%AF%B4%E6%B3%95%E9%94%99%E8%AF%AF%E7%9A%84%E6%98%AF%EF%BC%9A%20(%20%C2%A0)%20%C2%A0%C2%A0-toc" style="margin-left:80px;"><a href="#%E5%9C%A8%20myjsp.jsp%20%E4%B8%AD%EF%BC%8C%E5%85%B3%E4%BA%8E%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81%E8%AF%B4%E6%B3%95%E9%94%99%E8%AF%AF%E7%9A%84%E6%98%AF%EF%BC%9A%20%28%20%C2%A0%29%20%C2%A0%C2%A0" rel="nofollow">在 myjsp.jsp 中，关于下面的代码说法错误的是： (  )   </a></p> 
<p id="%E4%B8%8B%E9%9D%A2%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BE%93%E5%87%BA%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-toc" style="margin-left:80px;"><a href="#%E4%B8%8B%E9%9D%A2%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BE%93%E5%87%BA%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" rel="nofollow">下面代码的输出是什么？</a></p> 
<p id="%E5%85%B3%E4%BA%8EThreadLocal%E7%B1%BB%C2%A0%E4%BB%A5%E4%B8%8B%E8%AF%B4%E6%B3%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%98%AF-toc" style="margin-left:80px;"><a href="#%E5%85%B3%E4%BA%8EThreadLocal%E7%B1%BB%C2%A0%E4%BB%A5%E4%B8%8B%E8%AF%B4%E6%B3%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%98%AF" rel="nofollow">关于ThreadLocal类 以下说法正确的是</a></p> 
<p id="%E4%B8%8B%E9%9D%A2%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BE%93%E5%87%BA%E6%98%AF%3A()-toc" style="margin-left:80px;"><a href="#%E4%B8%8B%E9%9D%A2%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BE%93%E5%87%BA%E6%98%AF%3A%28%29" rel="nofollow">下面程序的输出是:()</a></p> 
<p id="%E4%BD%BF%E7%94%A8mvc%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1%E7%9A%84web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%85%B7%E6%9C%89%E4%BB%A5%E4%B8%8B%E4%BC%98%E7%82%B9%2C%E9%99%A4%E4%BA%86%EF%BC%9F-toc" style="margin-left:80px;"><a href="#%E4%BD%BF%E7%94%A8mvc%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1%E7%9A%84web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%85%B7%E6%9C%89%E4%BB%A5%E4%B8%8B%E4%BC%98%E7%82%B9%2C%E9%99%A4%E4%BA%86%EF%BC%9F" rel="nofollow">使用mvc模式设计的web应用程序具有以下优点,除了？</a></p> 
<p id="Java%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E5%BA%93JDBC%E7%94%A8%E5%88%B0%E5%93%AA%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%3F-toc" style="margin-left:80px;"><a href="#Java%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E5%BA%93JDBC%E7%94%A8%E5%88%B0%E5%93%AA%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%3F" rel="nofollow">Java数据库连接库JDBC用到哪种设计模式?</a></p> 
<p id="%E5%85%B3%E4%BA%8EJava%E5%92%8CC%2FC%2B%2B%E7%9A%84%E6%AF%94%E8%BE%83%EF%BC%8C%E4%B8%8B%E5%88%97%E5%93%AA%E4%B8%AA%E6%8F%8F%E8%BF%B0%E6%98%AF%E9%94%99%E8%AF%AF%E7%9A%84%EF%BC%9F-toc" style="margin-left:80px;"><a href="#%E5%85%B3%E4%BA%8EJava%E5%92%8CC%2FC%2B%2B%E7%9A%84%E6%AF%94%E8%BE%83%EF%BC%8C%E4%B8%8B%E5%88%97%E5%93%AA%E4%B8%AA%E6%8F%8F%E8%BF%B0%E6%98%AF%E9%94%99%E8%AF%AF%E7%9A%84%EF%BC%9F" rel="nofollow">关于Java和C/C++的比较，下列哪个描述是错误的？</a></p> 
<p id="%E5%85%B3%E4%BA%8Evolatile%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%8C%E4%B8%8B%E5%88%97%E6%8F%8F%E8%BF%B0%E4%B8%8D%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%98%AF%EF%BC%9F-toc" style="margin-left:80px;"><a href="#%E5%85%B3%E4%BA%8Evolatile%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%8C%E4%B8%8B%E5%88%97%E6%8F%8F%E8%BF%B0%E4%B8%8D%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%98%AF%EF%BC%9F" rel="nofollow">关于volatile关键字，下列描述不正确的是？</a></p> 
<p id="JVM%E5%86%85%E5%AD%98%E4%B8%8D%E5%8C%85%E5%90%AB%E5%A6%82%E4%B8%8B%E5%93%AA%E4%B8%AA%E9%83%A8%E5%88%86(%20)-toc" style="margin-left:80px;"><a href="#JVM%E5%86%85%E5%AD%98%E4%B8%8D%E5%8C%85%E5%90%AB%E5%A6%82%E4%B8%8B%E5%93%AA%E4%B8%AA%E9%83%A8%E5%88%86%28%20%29" rel="nofollow">JVM内存不包含如下哪个部分( )</a></p> 
<p id="%E4%BB%A5%E4%B8%8B%E5%93%AA%E4%BA%9B%E7%BB%A7%E6%89%BF%E8%87%AA%C2%A0Collection%C2%A0%E6%8E%A5%E5%8F%A3%EF%BC%88%EF%BC%89-toc" style="margin-left:80px;"><a href="#%E4%BB%A5%E4%B8%8B%E5%93%AA%E4%BA%9B%E7%BB%A7%E6%89%BF%E8%87%AA%C2%A0Collection%C2%A0%E6%8E%A5%E5%8F%A3%EF%BC%88%EF%BC%89" rel="nofollow">以下哪些继承自 Collection 接口（）</a></p> 
<p id="%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%98%AF%E7%94%B1%E8%B0%81%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F-toc" style="margin-left:80px;"><a href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%98%AF%E7%94%B1%E8%B0%81%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F" rel="nofollow">事务隔离级别是由谁实现的？</a></p> 
<p id="%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%89%80%E8%83%BD%E5%A4%84%E7%90%86%E7%9A%84%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E9%A1%B9%E7%A7%B0%E4%B8%BA%EF%BC%88%EF%BC%89-toc" style="margin-left:80px;"><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%89%80%E8%83%BD%E5%A4%84%E7%90%86%E7%9A%84%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E9%A1%B9%E7%A7%B0%E4%B8%BA%EF%BC%88%EF%BC%89" rel="nofollow">计算机所能处理的最小的数据项称为（）</a></p> 
<p id="%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%E4%B8%8B%E5%88%97%E7%A8%8B%E5%BA%8F%E8%AF%AD%E5%8F%A5%E5%90%8E%EF%BC%8C%E5%88%99b%E7%9A%84%E5%80%BC%E6%98%AF%EF%BC%88%EF%BC%89-toc" style="margin-left:80px;"><a href="#%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%E4%B8%8B%E5%88%97%E7%A8%8B%E5%BA%8F%E8%AF%AD%E5%8F%A5%E5%90%8E%EF%BC%8C%E5%88%99b%E7%9A%84%E5%80%BC%E6%98%AF%EF%BC%88%EF%BC%89" rel="nofollow">顺序执行下列程序语句后，则b的值是（）</a></p> 
<p id="%E4%B8%8B%E9%9D%A2%E6%9C%89%E5%85%B3forward%E5%92%8Credirect%E7%9A%84%E6%8F%8F%E8%BF%B0%EF%BC%8C%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%98%AF()%C2%A0%EF%BC%9F-toc" style="margin-left:80px;"><a href="#%E4%B8%8B%E9%9D%A2%E6%9C%89%E5%85%B3forward%E5%92%8Credirect%E7%9A%84%E6%8F%8F%E8%BF%B0%EF%BC%8C%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%98%AF%28%29%C2%A0%EF%BC%9F" rel="nofollow">下面有关forward和redirect的描述，正确的是() ？</a></p> 
<p id="%E4%B8%8B%E5%88%97%E9%82%A3%E4%BA%9B%E6%96%B9%E6%B3%95%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84(%E6%89%80%E8%B0%83%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%E9%83%BD%E5%AD%98%E5%9C%A8)-toc" style="margin-left:80px;"><a href="#%E4%B8%8B%E5%88%97%E9%82%A3%E4%BA%9B%E6%96%B9%E6%B3%95%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%28%E6%89%80%E8%B0%83%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%E9%83%BD%E5%AD%98%E5%9C%A8%29" rel="nofollow">下列那些方法是线程安全的(所调用的方法都存在)</a></p> 
<hr id="hr-toc"> 
<h4 id="%E4%BB%A5%E4%B8%8B%E4%BB%A3%E7%A0%81%E6%AE%B5%E6%89%A7%E8%A1%8C%E5%90%8E%E7%9A%84%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%E4%B8%BA">以下代码段执行后的输出结果为</h4> 
<pre><code class="language-java">public class Test {
    public static void main(String args[]) {
        int x = -5;
        int y = -12;
        System.out.println(y % x);
    }
}</code></pre> 
<p><span style="color:#7c79e5;"><strong>正确答案: D   你的答案: D (正确)</strong></span></p> 
<pre>-1</pre> 
<pre>2</pre> 
<pre>1</pre> 
<pre><span style="color:#86ca5e;">-2</span></pre> 
<blockquote> 
 <p>来源：<a href="https://www.nowcoder.com/questionTerminal/7b4ec6887dc04af992ce10dadfb532bb" rel="nofollow">https://www.nowcoder.com/questionTerminal/7b4ec6887dc04af992ce10dadfb532bb</a></p> 
 <p><span style="color:#86ca5e;"><strong>Y(被除数) % X(除数) </strong></span></p> 
 <p>当除数与被除数的<span style="color:#86ca5e;"><strong>符号相同时</strong></span>，取余和取模的结果是<span style="color:#86ca5e;"><strong>完全相同的</strong></span>； 当除数与被除数的<span style="color:#86ca5e;"><strong>符号不相同时</strong></span>，<span style="color:#86ca5e;"><strong>结果不同</strong></span>。</p> 
 <p>具体说，<span style="color:#e579b6;"><strong>取余结果</strong></span>的符号与<span style="color:#e579b6;"><strong>被除数相同</strong></span>；<span style="color:#3399ea;"><strong>取模结果</strong></span>的符号与<span style="color:#3399ea;"><strong>除数相同</strong></span>。</p> 
 <p>1.取余 　　 rem(3,2)=1 　　 rem(-3,-2)=-1 　　 rem(3,-2)=1 　　 rem(-3,2)=-1 　　</p> 
 <p>2.取模 　　 mod(3,2)=1 　　 mod(-3,-2)=-1 　　 mod(3,-2)=-1 　　 mod(-3,2)=1</p> 
</blockquote> 
<p> </p> 
<h4 id="java%E8%AF%AD%E8%A8%80%E7%9A%84%E4%B8%8B%E9%9D%A2%E5%87%A0%E7%A7%8D%E6%95%B0%E7%BB%84%E5%A4%8D%E5%88%B6%E6%96%B9%E6%B3%95%E4%B8%AD%EF%BC%8C%E5%93%AA%E4%B8%AA%E6%95%88%E7%8E%87%E6%9C%80%E9%AB%98%EF%BC%9F">java语言的下面几种数组复制方法中，哪个效率最高？</h4> 
<p><span style="color:#7c79e5;"><strong>正确答案: B   你的答案: D (错误)</strong></span></p> 
<pre>for 循环逐一复制</pre> 
<pre>System.arraycopy</pre> 
<pre>Array.copyOf</pre> 
<pre>使用clone方法</pre> 
<blockquote> 
 <p>来源：<a href="https://www.nowcoder.com/questionTerminal/e7c2d52c9cf0476bbba6aae6713dd303" rel="nofollow">https://www.nowcoder.com/questionTerminal/e7c2d52c9cf0476bbba6aae6713dd303</a></p> 
 <p><img alt="" src="https://images2.imgbox.com/b4/26/VTdGDsBs_o.png"></p> 
 <p><strong>总结： </strong></p> 
 <p><strong>（1）从速度上看：<span style="color:#86ca5e;">System.arraycopy &gt; clone &gt; Arrays.copyOf &gt; for</span> </strong><br><strong>（2）<span style="color:#86ca5e;">for</span>的速度之所以最慢是因为<span style="color:#86ca5e;">下标表示法每次都从起点开始寻位到指定下标处</span>（现代编译器应该对其有进行优化，改为指针），另外就是它<span style="color:#86ca5e;">每一次循环都要判断一次是否达到数组最大长度和进行一次额外的记录下标值的加法运算。</span> </strong><br><strong>（3）查看<span style="color:#86ca5e;">Arrays.copyOf</span>的源码可以发现，它其实<span style="color:#86ca5e;">本质上是调用了System.arraycopy。</span>之所以时间差距比较大，是因为<span style="color:#86ca5e;">很大一部分开销全花在了Math.min函数上了。</span></strong></p> 
 <pre><code class="language-java">public static byte[] copyOf(byte[] original, int newLength) { 
    byte[] copy = new byte[newLength];
    System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); 
    return copy;
}</code></pre> 
 <p><strong>（4）查看<span style="color:#86ca5e;">System.arraycopy</span>的源码，可以发现它<span style="color:#86ca5e;">实质上是通过Jni调用本地方法，及c/c++已经编译成机器码的方法</span>，所以快。</strong></p> 
 <pre><code class="language-java">public static native void arraycopy(Object src, int srcPos,
                                    Object dest, int destPos, int length);</code></pre> 
 <p><strong>（5）native方法，<span style="color:#86ca5e;">但并未手写，需要JNI转换</span>。</strong></p> 
</blockquote> 
<p> </p> 
<h4 id="%E5%9C%A8%20myjsp.jsp%20%E4%B8%AD%EF%BC%8C%E5%85%B3%E4%BA%8E%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81%E8%AF%B4%E6%B3%95%E9%94%99%E8%AF%AF%E7%9A%84%E6%98%AF%EF%BC%9A%20(%20%C2%A0)%20%C2%A0%C2%A0">在 myjsp.jsp 中，关于下面的代码说法错误的是： (  )   </h4> 
<p>&lt;%@ page language="java" import="java.util.*" errorPage="error.jsp" isErrorPage="false" %&gt; </p> 
<p><span style="color:#7c79e5;"><strong>正确答案: A   你的答案: C (错误)</strong></span></p> 
<pre><span style="color:#86ca5e;">该页面可以使用 exception 对象</span></pre> 
<pre>该页面发生异常会转向 error.jsp</pre> 
<pre>存在 errorPage 属性时，isErrorPage 是默认为 false</pre> 
<pre>error.jsp 页面一定要有isErrorPage 属性且值为 true</pre> 
<blockquote> 
 <p>来源：<a href="https://www.nowcoder.com/questionTerminal/b07dfbf3f5d7428aacb7387f48084030" rel="nofollow">https://www.nowcoder.com/questionTerminal/b07dfbf3f5d7428aacb7387f48084030</a></p> 
 <p>exception是JSP九大内置对象之一，其实例代表其他页面的异常和错误。</p> 
 <p>只有<span style="color:#86ca5e;"><strong>当页面是错误处理页面时</strong></span>，即<span style="color:#86ca5e;"><strong>isErroePage为 true时</strong></span>，该对象才可以使用。</p> 
 <p>对于C项，<span style="color:#86ca5e;"><strong>errorPage的实质就是JSP的异常处理机制,发生异常时才会跳转到 errorPage指定的页面，没必要给errorPage再设置一个errorPage。</strong></span></p> 
 <p>所以当<span style="color:#86ca5e;"><strong>errorPage属性存在时， isErrorPage属性值为false</strong></span></p> 
</blockquote> 
<p> </p> 
<h4 id="%E4%B8%8B%E9%9D%A2%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BE%93%E5%87%BA%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">下面代码的输出是什么？</h4> 
<pre><code class="language-java">public class Base
{
    private String baseName = "base";
    public Base()
    {
        callName();
    }

    public void callName()
    {
        System. out. println(baseName);
    }

    static class Sub extends Base
    {
        private String baseName = "sub";
        public void callName()
        {
            System. out. println (baseName) ;
        }
    }
    public static void main(String[] args)
    {
        Base b = new Sub();
    }
}</code></pre> 
<p><span style="color:#7c79e5;"><strong>正确答案: A   你的答案: B (错误)</strong></span></p> 
<pre><span style="color:#86ca5e;">null</span></pre> 
<pre>sub</pre> 
<pre>base</pre> 
<blockquote> 
 <p>来源：<a href="https://www.nowcoder.com/questionTerminal/c2bfb1512dfa4a7eab773a5871a52402" rel="nofollow">https://www.nowcoder.com/questionTerminal/c2bfb1512dfa4a7eab773a5871a52402</a></p> 
 <p> <strong><span style="color:#86ca5e;">new Sub()</span></strong>；<span style="color:#86ca5e;"><strong>在创造派生类的过程中首先创建基类对象</strong></span>，<span style="color:#86ca5e;"><strong>然后才能创建派生类</strong></span>。</p> 
 <p>创建基类即默认调用Base()方法，在方法中调用callName()方法，<span style="color:#86ca5e;"><strong>由于派生类中存在此方法，则被调用的callName（）方法是派生类中的方法</strong></span>，<span style="color:#86ca5e;"><strong><u>此时派生类还未构造</u>，</strong></span>所以变量baseName的值为null<br>  </p> 
 <p>《Thinking in JAVA》201页提到，<span style="color:#86ca5e;"><strong>如果不需要内部类对象与其外部类对象之间有联系</strong></span>，那么可以<span style="color:#86ca5e;"><strong>将内部类声明为static</strong></span>，</p> 
 <p>对于这种说法，我尝试着在<span style="color:#86ca5e;"><strong>A包下面建了一个类X</strong></span>，并在<span style="color:#86ca5e;"><strong>其内部声明了一个静态内部类Y（也叫嵌套类）</strong></span>，然后同样是在<span style="color:#86ca5e;"><strong>A包下面，我新建了一个类B</strong></span>，然后<span style="color:#86ca5e;"><strong>在这个类中引用前面那个类Y</strong></span>，发现<span style="color:#86ca5e;"><strong>可以直接引用</strong></span>，<span style="color:#86ca5e;"><strong>说明X与Y的确没有联系</strong></span>（虽然引用的时候需要用X.Y的方式引用，不过貌似好像就这点联系了。）</p> 
 <p>如果<span style="color:#86ca5e;"><strong>Y没有声明为static</strong></span>，那么是<span style="color:#86ca5e;"><strong>无法在B中引用Y的</strong></span>。其实说了这么多，总结来讲，就是<span style="color:#86ca5e;"><strong>static的作用是相当于建立了2个类</strong></span>，<span style="color:#86ca5e;"><strong>在工作目录下的确也是生成了2个class文件，既然是2个类，那么这两个类的关系就是单纯的继承关系了。</strong></span></p> 
</blockquote> 
<p> </p> 
<h4 id="%E5%85%B3%E4%BA%8EThreadLocal%E7%B1%BB%C2%A0%E4%BB%A5%E4%B8%8B%E8%AF%B4%E6%B3%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%98%AF">关于ThreadLocal类 以下说法正确的是</h4> 
<p><span style="color:#7c79e5;"><strong>正确答案: D E   你的答案: A B C D E (错误)</strong></span></p> 
<pre>ThreadLocal继承自Thread</pre> 
<pre>ThreadLocal实现了Runnable接口</pre> 
<pre>ThreadLocal重要作用在于多线程间的数据共享</pre> 
<pre><span style="color:#86ca5e;">ThreadLocal是采用哈希表的方式来为每个线程都提供一个变量的副本</span></pre> 
<pre><span style="color:#86ca5e;">ThreadLocal保证各个线程间数据安全，每个线程的数据不会被另外线程访问和破坏</span></pre> 
<blockquote> 
 <p>来源：<a href="https://www.nowcoder.com/questionTerminal/b82e4a85a66e4dc488a5ab49094976e9" rel="nofollow">https://www.nowcoder.com/questionTerminal/b82e4a85a66e4dc488a5ab49094976e9</a></p> 
 <p>1、ThreadLocal的类声明：</p> 
 <p><span style="color:#86ca5e;"><strong>public class ThreadLocal&lt;T&gt;</strong></span></p> 
 <p>可以看出ThreadLocal<span style="color:#86ca5e;"><strong>并没有继承自Thread，也没有实现Runnable接口</strong></span>。所以AB都不对。</p> 
 <p>2、ThreadLocal类为<span style="color:#86ca5e;"><strong>每一个线程都维护了自己独有的变量拷贝</strong></span>。<span style="color:#86ca5e;"><strong>每个线程都拥有了自己独立的一个变量</strong></span>。</p> 
 <p>所以<span style="color:#86ca5e;"><strong>ThreadLocal重要作用并不在于多线程间的数据共享，而是数据的独立</strong></span>，C选项错。</p> 
 <p>由于每个线程在访问该变量时，读取和修改的，都是自己独有的那一份变量拷贝，不会被其他线程访问，</p> 
 <p>变量被彻底封闭在每个访问的线程中。所以E对。</p> 
 <p>3、<span style="color:#86ca5e;"><strong>ThreadLocal中定义了一个哈希表用于为每个线程都提供一个变量的副本</strong></span>：</p> 
 <p> static class ThreadLocalMap {<!-- --></p> 
 <p> </p> 
 <p>        static class Entry extends WeakReference&lt;ThreadLocal&gt; {<!-- --></p> 
 <p>            /** The value associated with this ThreadLocal. */</p> 
 <p>            Object value;</p> 
 <p> </p> 
 <p>            Entry(ThreadLocal k, Object v) {<!-- --></p> 
 <p>                super(k);</p> 
 <p>                value = v;</p> 
 <p>            }</p> 
 <p>        }</p> 
 <p> </p> 
 <p>        /**</p> 
 <p>         * The table, resized as necessary.</p> 
 <p>         * table.length MUST always be a power of two.</p> 
 <p>         */</p> 
 <p>        private Entry[] table;</p> 
 <p>}</p> 
 <p>所以D对。</p> 
</blockquote> 
<p> </p> 
<h4 id="%E4%B8%8B%E9%9D%A2%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BE%93%E5%87%BA%E6%98%AF%3A()">下面程序的输出是:()</h4> 
<pre><code class="language-java">String x="fmn";
x.toUpperCase();
String y=x.replace('f','F');
y=y+"wxy";
System.out.println(y);</code></pre> 
<p><span style="color:#7c79e5;"><strong>正确答案: D   你的答案: D (正确)</strong></span></p> 
<pre>FmNwxy</pre> 
<pre>fmnwxy</pre> 
<pre>wxyfmn</pre> 
<pre><span style="color:#86ca5e;">Fmnwxy</span></pre> 
<blockquote> 
 <p>来源：<a href="https://www.nowcoder.com/questionTerminal/caa9ea2063624a04afc91df682bb4729" rel="nofollow">https://www.nowcoder.com/questionTerminal/caa9ea2063624a04afc91df682bb4729</a></p> 
 <p>String x="fmn";  “fmn”是在常量池里的不可变对象。</p> 
 <p>x.toUpperCase();   <span style="color:#86ca5e;"><strong>在堆中new一个"FMN"对象，但无任何引用指向它。</strong></span></p> 
 <p>String y=x.replace('f','F'); 在堆中 new一个"Fmn"对象，y指向它。</p> 
 <p>y=y+"wxy"; 在堆中 重新new一个"Fmnwxy"对象， 修改y指向，现在y指向它。</p> 
</blockquote> 
<p> </p> 
<h4 id="%E4%BD%BF%E7%94%A8mvc%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1%E7%9A%84web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%85%B7%E6%9C%89%E4%BB%A5%E4%B8%8B%E4%BC%98%E7%82%B9%2C%E9%99%A4%E4%BA%86%EF%BC%9F">使用mvc模式设计的web应用程序具有以下优点,除了？</h4> 
<p><span style="color:#7c79e5;"><strong>正确答案: D   你的答案: C (错误)</strong></span></p> 
<pre>可维护行强</pre> 
<pre>可扩展性强</pre> 
<pre>代码重复少</pre> 
<pre><span style="color:#86ca5e;">大大减少代码量</span></pre> 
<blockquote> 
 <p>来源：<a href="https://www.nowcoder.com/questionTerminal/940d9dd9a582442090b42443f8883f5e" rel="nofollow">https://www.nowcoder.com/questionTerminal/940d9dd9a582442090b42443f8883f5e</a></p> 
 <p><br> MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。<br> MVC只是将分管不同功能的逻辑代码进行了隔离，增强了可维护和可扩展性，<span style="color:#86ca5e;"><strong>增强代码复用性，因此可以减少代码重复。但是不保证减少代码量，多层次的调用模式还有可能增加代码量</strong></span></p> 
</blockquote> 
<p> </p> 
<h4 id="Java%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E5%BA%93JDBC%E7%94%A8%E5%88%B0%E5%93%AA%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%3F">Java数据库连接库JDBC用到哪种设计模式?</h4> 
<p><span style="color:#7c79e5;"><strong>正确答案: B   你的答案: A (错误)</strong></span></p> 
<pre>生成器</pre> 
<pre><span style="color:#86ca5e;">桥接模式</span></pre> 
<pre>抽象工厂</pre> 
<pre>单例模式</pre> 
<blockquote> 
 <p>来源：<a href="https://www.nowcoder.com/questionTerminal/134a62da02d34bc6a7ff309af3fbb76f" rel="nofollow">https://www.nowcoder.com/questionTerminal/134a62da02d34bc6a7ff309af3fbb76f</a></p> 
 <p><span style="color:#86ca5e;"><strong>JDBC提供两套接口，一个面向数据库厂商，一个面向JDBC使用者。</strong></span></p> 
 <p><strong>桥接模式：</strong></p> 
 <p><strong>定义</strong> ：<span style="color:#86ca5e;"><strong>将抽象部分与它的实现部分分离，使它们都可以独立地变化。</strong></span></p> 
 <p><strong>意图</strong> ：将抽象与实现解耦。</p> 
 <p><strong>桥接模式所涉及的角色</strong><br> 1.  <strong>Abstraction</strong> ：定义抽象接口，拥有一个Implementor类型的对象引用<br> 2.  <strong>RefinedAbstraction</strong> ：扩展Abstraction中的接口定义<br> 3.  <strong>Implementor</strong> ：是具体实现的接口，Implementor和RefinedAbstraction接口并不一定完全一致，实际上这两个接口可以完全不一样Implementor提供具体操作方法，而Abstraction提供更高层次的调用<br> 4.  <strong>ConcreteImplementor</strong> ：实现Implementor接口，给出具体实现</p> 
 <p>Jdk中的桥接模式：JDBC<br> JDBC连接 <a href="http://www.2cto.com/database/" rel="nofollow">数据库</a> 的时候，在各个数据库之间进行切换，基本不需要动太多的代码，甚至丝毫不动，原因就是JDBC提供了统一接口，<span style="color:#86ca5e;"><strong>每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了</strong></span></p> 
</blockquote> 
<p> </p> 
<h4 id="%E5%85%B3%E4%BA%8EJava%E5%92%8CC%2FC%2B%2B%E7%9A%84%E6%AF%94%E8%BE%83%EF%BC%8C%E4%B8%8B%E5%88%97%E5%93%AA%E4%B8%AA%E6%8F%8F%E8%BF%B0%E6%98%AF%E9%94%99%E8%AF%AF%E7%9A%84%EF%BC%9F">关于Java和C/C++的比较，下列哪个描述是错误的？</h4> 
<p><span style="color:#7c79e5;"><strong>正确答案: C D   你的答案: D (错误)</strong></span></p> 
<pre>Java不支持指针，C/C++支持</pre> 
<pre>Java程序不需要显式地关心内存释放，而C/C++需要</pre> 
<pre><span style="color:#86ca5e;">Java和C++一样，是纯编译型语言，因此它们的class都是在编译时静态联编(static binding)的</span></pre> 
<pre><span style="color:#86ca5e;">Java数组、字符串不可能溢出，C/C++数组、字符串则有可能溢出边界</span></pre> 
<blockquote> 
 <p>来源：<a href="https://www.nowcoder.com/questionTerminal/b6f55c8749764ed2876f76a84c4c46a4" rel="nofollow">https://www.nowcoder.com/questionTerminal/b6f55c8749764ed2876f76a84c4c46a4</a></p> 
 <p><strong>Java和C++的区别：</strong></p> 
 <p><strong>1.<span style="color:#86ca5e;"> Java</span>是解释型语言，所谓的<span style="color:#86ca5e;">解释型语言</span>，就是<span style="color:#86ca5e;">源码会先经过一次编译，成为中间码，中间码再被解释器解释成机器码。</span>对于Java而言，中间码就是字节码(.class)，而解释器在JVM中内置了。</strong></p> 
 <p><strong>2. <span style="color:#86ca5e;">C++</span>是编译型语言，所谓<span style="color:#86ca5e;">编译型语言</span>，就是<span style="color:#86ca5e;">源码一次编译，直接在编译的过程中链接了，形成了机器码。</span></strong></p> 
 <p><strong>3. C++比Java执行速度快，但是Java可以利用JVM跨平台。</strong></p> 
 <p><strong>4. Java是纯面向对象的语言，所有代码（包括函数、变量</strong><strong>）都必须在类中定义。而<span style="color:#86ca5e;">C++中还有面向过程的东西，比如是全局变量和全局函数。</span></strong></p> 
 <p><strong>5. C++中有指针，Java中没有，但是有引用。</strong></p> 
 <p><strong>6. C++支持多继承，Java中类都是单继承的。但是继承都有传递性，同时Java中的接口是多继承，类对接口的实现也是多实现。</strong></p> 
 <p><strong>7. C++中，开发需要自己去管理内存，但是Java中JVM有自己的GC机制，虽然有自己的GC机制，但是也会出现OOM和内存泄漏的问题。C++中有析构函数，Java中Object的finalize方法</strong></p> 
 <p><strong>8. <span style="color:#86ca5e;">C++运算符可以重载，但是Java中不可以。</span>同时<span style="color:#86ca5e;">C++中支持强制自动转型，Java中不行</span>，会出现ClassCastException（类型不匹配）。</strong></p> 
</blockquote> 
<p> </p> 
<h4 id="%E5%85%B3%E4%BA%8Evolatile%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%8C%E4%B8%8B%E5%88%97%E6%8F%8F%E8%BF%B0%E4%B8%8D%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%98%AF%EF%BC%9F">关于volatile关键字，下列描述不正确的是？</h4> 
<p><span style="color:#7c79e5;"><strong>正确答案: B D   你的答案: B C (错误)</strong></span></p> 
<pre>用volatile修饰的变量，每次更新对其他线程都是立即可见的。</pre> 
<pre><span style="color:#86ca5e;">对volatile变量的操作是原子性的。</span></pre> 
<pre>对volatile变量的操作不会造成阻塞。</pre> 
<pre><span style="color:#86ca5e;">不依赖其他锁机制，多线程环境下的计数器可用volatile实现。</span></pre> 
<blockquote> 
 <p>来源：<a href="https://www.nowcoder.com/questionTerminal/3f6c5287a9fa4d0baa162e44970a343d" rel="nofollow">https://www.nowcoder.com/questionTerminal/3f6c5287a9fa4d0baa162e44970a343d</a></p> 
 <p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p> 
 <p>1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</p> 
 <p>2）禁止进行指令重排序。</p> 
 <p>volatile只提供了保证访问该变量时，每次都是从内存中读取最新值，<span style="color:#86ca5e;"><strong>并不会使用寄存器缓存该值——每次都会从内存中读取。</strong></span></p> 
 <p><span style="color:#86ca5e;"><strong>而对该变量的修改，volatile并不提供原子性的保证。</strong></span></p> 
 <p>由于及时更新，很可能导致另一线程访问最新变量值，无法跳出循环的情况</p> 
 <p><strong>多线程下计数器<span style="color:#86ca5e;">必须使用锁保护。</span></strong></p> 
 <p><strong>由于有些时候对</strong> <strong>volatile的操作，<span style="color:#86ca5e;">不会被保存，说明不会造成阻塞。不可用与多线程环境下的计数器。</span></strong></p> 
</blockquote> 
<p> </p> 
<h4 id="JVM%E5%86%85%E5%AD%98%E4%B8%8D%E5%8C%85%E5%90%AB%E5%A6%82%E4%B8%8B%E5%93%AA%E4%B8%AA%E9%83%A8%E5%88%86(%20)">JVM内存不包含如下哪个部分( )</h4> 
<p><span style="color:#7c79e5;"><strong>正确答案: D   你的答案: C (错误)</strong></span></p> 
<pre>Stacks</pre> 
<pre>PC寄存器</pre> 
<pre>Heap</pre> 
<pre><span style="color:#86ca5e;">Heap Frame</span></pre> 
<blockquote> 
 <p>来源：<a href="https://www.nowcoder.com/questionTerminal/04c442aaf1e14bf9819075cc1f29d899" rel="nofollow">https://www.nowcoder.com/questionTerminal/04c442aaf1e14bf9819075cc1f29d899</a></p> 
 <p>JVM内存五大区域：<strong><span style="color:#86ca5e;">左边私有，右边共享</span></strong></p> 
 <p><img alt="" height="508" src="https://images2.imgbox.com/4e/f8/eBbnms7H_o.png" width="1074"></p> 
 <p> </p> 
</blockquote> 
<p> </p> 
<h4 id="%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%98%AF%E7%94%B1%E8%B0%81%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F">事务隔离级别是由谁实现的？</h4> 
<p><span style="color:#7c79e5;"><strong>正确答案: C   你的答案: B (错误)</strong></span></p> 
<pre>Java应用程序</pre> 
<pre>Hibernate</pre> 
<pre><span style="color:#86ca5e;">数据库系统</span></pre> 
<pre>JDBC驱动程序</pre> 
<blockquote> 
 <p>来源：<a href="https://www.nowcoder.com/questionTerminal/ce23bb5a36b54849a05f11187eacb23c" rel="nofollow">https://www.nowcoder.com/questionTerminal/ce23bb5a36b54849a05f11187eacb23c</a></p> 
 <p><br> A，我们写java程序的时候只是设定事物的隔离级别，而不是去实现它</p> 
 <p>B，Hibernate是一个java的数据持久化框架，方便数据库的访问</p> 
 <p>C，<span style="color:#86ca5e;"><strong>事物隔离级别由数据库系统实现，是数据库系统本身的一个功能</strong></span></p> 
 <p>D，JDBC是java database connector，也就是java访问数据库的驱动</p> 
</blockquote> 
<p> </p> 
<h4 id="%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%89%80%E8%83%BD%E5%A4%84%E7%90%86%E7%9A%84%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E9%A1%B9%E7%A7%B0%E4%B8%BA%EF%BC%88%EF%BC%89">计算机所能处理的最小的数据项称为（）</h4> 
<p><span style="color:#7c79e5;"><strong>正确答案: A   你的答案: B (错误)</strong></span></p> 
<pre><span style="color:#86ca5e;">位</span></pre> 
<pre>字节</pre> 
<pre>字</pre> 
<pre>双字</pre> 
<blockquote> 
 <p>来源：<a href="https://www.nowcoder.com/questionTerminal/fd9860e9c28e4b1dbbe024ee1b590671" rel="nofollow">https://www.nowcoder.com/questionTerminal/fd9860e9c28e4b1dbbe024ee1b590671</a></p> 
 <p><span style="color:#86ca5e;"><strong>位&lt;字节&lt;字&lt;双字</strong></span></p> 
</blockquote> 
<p> </p> 
<h4 id="%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%E4%B8%8B%E5%88%97%E7%A8%8B%E5%BA%8F%E8%AF%AD%E5%8F%A5%E5%90%8E%EF%BC%8C%E5%88%99b%E7%9A%84%E5%80%BC%E6%98%AF%EF%BC%88%EF%BC%89">顺序执行下列程序语句后，则b的值是（）</h4> 
<p>String a="Hello";</p> 
<p>String b=a.substring(0,2);</p> 
<p> </p> 
<p><span style="color:#7c79e5;"><strong>正确答案: C   你的答案: B (错误)</strong></span></p> 
<pre>Hello</pre> 
<pre>Hel</pre> 
<pre><span style="color:#86ca5e;">He</span></pre> 
<pre>null</pre> 
<blockquote> 
 <p><strong>substring</strong>    方法将返回一个包含从   <strong> <em>start</em>    到最后（<span style="color:#86ca5e;">不包含</span>  <em>end</em> ）的子字符串的字符串。</strong></p> 
</blockquote> 
<p> </p> 
<h4 id="%E4%B8%8B%E9%9D%A2%E6%9C%89%E5%85%B3forward%E5%92%8Credirect%E7%9A%84%E6%8F%8F%E8%BF%B0%EF%BC%8C%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%98%AF()%C2%A0%EF%BC%9F">下面有关forward和redirect的描述，正确的是<u>()</u> ？</h4> 
<p><span style="color:#7c79e5;"><strong>正确答案: B C D   你的答案: B C (错误)</strong></span></p> 
<pre>forward是服务器将控制权转交给另外一个内部服务器对象，由新的对象来全权负责响应用户的请求</pre> 
<pre><span style="color:#86ca5e;">执行forward时，浏览器不知道服务器发送的内容是从何处来，浏览器地址栏中还是原来的地址</span></pre> 
<pre><span style="color:#86ca5e;">执行redirect时，服务器端告诉浏览器重新去请求地址</span></pre> 
<pre><span style="color:#86ca5e;">forward是内部重定向，redirect是外部重定向</span></pre> 
<pre>redirect默认将产生301 Permanently moved的HTTP响应</pre> 
<blockquote> 
 <p>来源：<a href="https://www.nowcoder.com/questionTerminal/e14e58a3d78346be9540a3fbefd62ee3" rel="nofollow">https://www.nowcoder.com/questionTerminal/e14e58a3d78346be9540a3fbefd62ee3</a></p> 
 <p>1.从<span style="color:#86ca5e;"><strong>地址栏显示</strong></span>来说</p> 
 <p>forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址.</p> 
 <p>redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL.</p> 
 <p> </p> 
 <p>2.从<span style="color:#86ca5e;"><strong>数据共享</strong></span>来说</p> 
 <p>forward:<span style="color:#86ca5e;"><strong>转发页面和转发到的页面可以共享request里面的数据.</strong></span></p> 
 <p>redirect:<span style="color:#86ca5e;"><strong>不能共享数据.</strong></span></p> 
 <p> </p> 
 <p>3.从<span style="color:#86ca5e;"><strong>运用地方</strong></span>来说</p> 
 <p>forward:<span style="color:#86ca5e;"><strong>一般用于用户登陆的时候,根据角色转发到相应的模块.</strong></span></p> 
 <p>redirect:<span style="color:#86ca5e;"><strong>一般用于用户注销登陆时返回主页面和跳转到其它的网站等.</strong></span></p> 
 <p> </p> 
 <p>4.从<span style="color:#86ca5e;"><strong>效率</strong></span>来说</p> 
 <p>forward:高.</p> 
 <p>redirect:低.</p> 
</blockquote> 
<p> </p> 
<h4 id="%E4%B8%8B%E5%88%97%E9%82%A3%E4%BA%9B%E6%96%B9%E6%B3%95%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84(%E6%89%80%E8%B0%83%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%E9%83%BD%E5%AD%98%E5%9C%A8)">下列那些方法是线程安全的(所调用的方法都存在)</h4> 
<p><span style="color:#7c79e5;"><strong>正确答案: A C D   你的答案: C D (错误)</strong></span></p> 
<pre><code class="language-java">A.
public class MyServlet implements Servlet {
    public void service (ServletRequest req, ServletResponse resp) {
        BigInteger I = extractFromRequest(req);
        encodeIntoResponse(resp,factors);
    }
}


B.
public class MyServlet implements Servlet {
    private long count =0;
    public long getCount() {
        return count;
    }
    public void service (ServletRequest req, ServletResponse resp) {
        BigInteger I = extractFromRequest(req);
        BigInteger[] factors = factor(i);
        count ++;
        encodeIntoResponse(resp,factors);
    }
}

C.
public class MyClass {
    private int value;
    public synchronized int get() {
        return value;
    }
    public synchronized void set (int value) {
        this.value = value;
    }
}

D.
public class Factorizer implements Servlet {
    private volatile MyCache cache = new MyCache(null,null);
    public void service(ServletRequest req, ServletResponse resp) {
    BigInteger i = extractFromRequest(req);
    BigInteger[] factors = cache.getFactors(i);
    if (factors == null) {
        factors = factor(i);
        cache = new MyCache(i,factors);
    }
    encodeIntoResponse(resp,factors);
}</code></pre> 
<blockquote> 
 <p>来源：<a href="https://www.nowcoder.com/questionTerminal/2d312b47ce1b4921a301db97c1eb4caa" rel="nofollow">https://www.nowcoder.com/questionTerminal/2d312b47ce1b4921a301db97c1eb4caa</a><br><br> 这几个类<span style="color:#86ca5e;"><strong>都没有类属性，不存在共享资源</strong></span>，为了满足题目的意思，应该是多线程情况下使用同一个对象，以达到使成员成为共享资源的目的；</p> 
 <p>A：<span style="color:#86ca5e;"><strong>没有成员（没有共享资源）</strong></span><strong>，线程安全</strong>；</p> 
 <p>B：假设存在线程1和线程2，count初始值为0，当线程1执行count++中count+1（此时未写回最终计算值），这时线程2执行count++中读取count，发生数据错误，导致线程1线程2的结果都为1，而不是线程1的结果为1，线程2的结果为2，线程不安全；</p> 
 <p>C：<span style="color:#86ca5e;"><strong>成员私有，对成员的set get方法都加重量级锁</strong></span>，线程安全；</p> 
 <p>D：volatile有两个作用：可见性（volatile变量的改变能使其他线程立即可见，但它不是线程安全的，参考B）和禁止重排序；这里是可见性的应用，类中方法对volatile修饰的变量只有赋值，线程安全.</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b1b2bc24cf35144d386fdd8e6ebdc938/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">出现报错FileNotFoundError: [Errno 2] No such file or directory：xxx解决方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ee8efeb09c4546e931864946e0f40cbb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">7-2 一元多项式的乘法与加法运算 (20 分) （链表实现）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>