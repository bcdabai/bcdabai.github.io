<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>python 理解 ‘*‘、‘*args‘、‘**‘ 和 ‘**kwargs‘ - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="python 理解 ‘*‘、‘*args‘、‘**‘ 和 ‘**kwargs‘" />
<meta property="og:description" content="目录 1、了解 * 在函数调用中的作用2、`*args`在函数定义中做什么？3、通过一个函数的调用来理解’`**`’的作用4、**kwargs在函数定义中的含义5、给出一个实例说明我们为什么要用`*args`, `**kwargs`？ 当我开始学习Python的，我很迷茫关于什么args，kwargs，*和**做。我觉得有很多像我一样有这种困惑和问题的人。通过这篇文章，我打算减少（希望我能消除）这种混乱。 在这篇文章中，我将使用 ipython，我建议你也尝试在 ipython 上使用所有东西。一路上我们会故意犯一些错误，以便更好地理解这个话题。
1、了解 * 在函数调用中的作用 让我们定义一个函数“fun”，它接受三个位置参数：
In [5]: def fun(a, b, c): ...: print a, b, c 调用此函数传递三个位置参数：
In [7]: fun(1,2,3) 1 2 3 #Output 因此，通过传递三个位置参数来调用此函数，打印传递给该函数的三个参数。
让我们创建一个包含三个整数值的列表。
In [8]: l = [1,2,3] 让我们*现在使用。
In [9]: fun(*l) 1 2 3 #Output *做了什么？
它将列表中的值解包l为位置参数。然后将解包后的值作为位置参数传递给函数“fun”。
因此，将 list 中的值解包并将其更改为位置参数意味着 fun(*l)与 fun(1,2,3)等效。请记住，l=[1,2,3]。让我们尝试使用 的其他一些值l。
In [10]: l=[5,7,9] In [11]: fun(*l) 5 7 9 #Output 现在让我们犯一些错误。让我们在“l”中放入四个值：
In [12]: l=[3,5,6,9] 现在，尝试调用函数“fun”:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/ceb3c6e71492b309301cd8d0a9b3926d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-07-26T21:51:31+08:00" />
<meta property="article:modified_time" content="2021-07-26T21:51:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">python 理解 ‘*‘、‘*args‘、‘**‘ 和 ‘**kwargs‘</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><ul><li><ul><li><a href="#1___6" rel="nofollow">1、了解 * 在函数调用中的作用</a></li><li><a href="#2args_107" rel="nofollow">2、`*args`在函数定义中做什么？</a></li><li><a href="#3_193" rel="nofollow">3、通过一个函数的调用来理解’`**`’的作用</a></li><li><a href="#4kwargs_271" rel="nofollow">4、**kwargs在函数定义中的含义</a></li><li><a href="#5args_kwargs_373" rel="nofollow">5、给出一个实例说明我们为什么要用`*args`, `**kwargs`？</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<br> 当我开始学习Python的，我很迷茫关于什么args，kwargs，*和**做。我觉得有很多像我一样有这种困惑和问题的人。通过这篇文章，我打算减少（希望我能消除）这种混乱。 
<p></p> 
<p>在这篇文章中，我将使用 ipython，我建议你也尝试在 ipython 上使用所有东西。一路上我们会故意犯一些错误，以便更好地理解这个话题。</p> 
<h4><a id="1___6"></a>1、了解 * 在函数调用中的作用</h4> 
<p>让我们定义一个函数“<code>fun</code>”，它接受三个位置参数：</p> 
<pre><code>  In [5]: def fun(a, b, c):
     ...:     print a, b, c
</code></pre> 
<p>调用此函数传递三个位置参数：</p> 
<pre><code>In [7]: fun(1,2,3)
1 2 3                     #Output
</code></pre> 
<p>因此，通过传递三个位置参数来调用此函数，打印传递给该函数的三个参数。</p> 
<p>让我们创建一个包含三个整数值的列表。</p> 
<pre><code>In [8]: l = [1,2,3]
</code></pre> 
<p>让我们<code>*</code>现在使用。</p> 
<pre><code>In [9]: fun(*l)
1 2 3                     #Output
</code></pre> 
<p><strong><code>*</code>做了什么？</strong></p> 
<p>它将列表中的值解包<code>l</code>为位置参数。然后将解包后的值作为位置参数传递给函数“fun”。</p> 
<p>因此，将 list 中的值解包并将其更改为位置参数意味着 <code>fun(*l)</code>与 <code>fun(1,2,3)</code>等效。请记住，<code>l=[1,2,3]</code>。让我们尝试使用 的其他一些值<code>l</code>。</p> 
<pre><code>In [10]: l=[5,7,9]

In [11]: fun(*l)
5 7 9                     #Output
</code></pre> 
<p>现在让我们犯一些错误。让我们在“l”中放入四个值：</p> 
<pre><code>In [12]: l=[3,5,6,9]
</code></pre> 
<p>现在，尝试调用函数“fun”:</p> 
<pre><code>In [13]: fun(*l)
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)

/home/akshar/branding_git/netconference/&lt;ipython console&gt; in &lt;module&gt;()

TypeError: fun() takes exactly 3 arguments (4 given)
</code></pre> 
<p>因此，在我们的最后一条语句中，<code>fun(*l)</code>我们没有得到正确的输出并且引发了 TypeError。看到错误，它说“TypeError: fun() 需要 3 个参数（给定4 个）”。</p> 
<p><strong>为什么会这样？</strong></p> 
<p>列表 ‘<code>l</code>’ 包含四个值。因此，当我们尝试调用<code>fun(*l)</code>， <code>l</code>被解包，以便它的值可以作为位置参数发送。但是，<code>l</code>里面有四个值。所以，<code>fun(\*l)</code>与<code>fun(3,5,6,9)</code>等效。但是，<code>fun</code>的定义只采用三个位置参数，因此我们得到了这个错误。类似地，您可以对列表 <code>'l'</code> 中的两个值执行相同的步骤并注意错误。</p> 
<pre><code>In [14]: l=[5,6]

In [15]: fun(*l)
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)

/home/akshar/branding_git/netconference/&lt;ipython console&gt; in &lt;module&gt;()

TypeError: fun() takes exactly 3 arguments (2 given)
</code></pre> 
<p>让我们给定<code>*l</code>和一个位置参数。</p> 
<pre><code>In [16]: fun(1, *l)
1 5 6                  #Output.
</code></pre> 
<p>在这里，我们给出了一个位置参数，即 1 和两个值，即 5 和 6 从“l”中解包出来，因此 1,5 和 6 被传递给 ‘fun’。</p> 
<p>希望您能够了解<code>*</code>在函数调用中使用时的作用。</p> 
<p>了解*args函数定义中的含义。<br> 现在让我们更改函数定义。</p> 
<pre><code>In [18]: def fun(*args):
   ....:     print args
</code></pre> 
<p>使用一个位置参数调用此函数：</p> 
<pre><code>In [19]: fun(1)
(1,)                  #Output
</code></pre> 
<p>现在使用两个位置参数或您希望的任意数量的位置参数调用此函数：</p> 
<pre><code>In [20]: fun(1,2,3)
(1, 2, 3)
</code></pre> 
<h4><a id="2args_107"></a>2、<code>*args</code>在函数定义中做什么？</h4> 
<p>它接收一个包含超出形式参数列表的位置参数的元组。所以，<code>args</code>是一个元组。不要担心我们解释中的“形参列表”部分，接下来的几个例子会很清楚。在我们打印“args”的最后一个示例中，它打印了一个元组，其中包含我们在调用函数时传递的所有值。</p> 
<p>让我们把<code>*args</code>和一些“形参列表”混合使用。请注意，在我们的最后一个示例中，我们没有任何形参列表。让我们重新定义我们的函数。</p> 
<pre><code>In [21]: def fun(a, *args):
   ....:     print "a is ", a
   ....:     print "args is ", args
</code></pre> 
<p>在这个函数定义中，参数“a”构成了“形式参数列表”。让我们用四个位置参数来称呼“乐趣”。</p> 
<pre><code>In [22]: fun(1, 2, 3, 4)
a is  1                                #Output
args is  (2, 3, 4)
</code></pre> 
<p>所以，我们可以看到 ‘a’ 被赋值为 1，这是第一个位置参数。在“a”后只定义了一个参数<code>*args</code>。因此，“args”收到一个元组，其中包含形参列表之外的位置参数。</p> 
<p>因此，args 接收到 2、3 和 4 作为元组。</p> 
<p>我们也可以只用一个位置参数来调用“fun”：</p> 
<pre><code>In [23]: fun(1)
a is  1                                #Output
args is  ()                            #args received an empty tuple
</code></pre> 
<p>Here, we passed only one argument to the function which was assigned to the formal parameter ‘a’. So, ‘args’ received an empty tuple as can be seen from the output.</p> 
<p>在这里，我们只给函数传递了一个参数，这个函数被赋值给形参‘ a’。因此，从输出中可以看到，“ args”接收到一个空元组。</p> 
<p>在我们有了“ args”之后，我们可以提取这些值并做任何我们想做的事情。让我们重新定义“ fun”。</p> 
<pre><code>In [24]: def fun(a, *args):
   ....:     print a
   ....:     print "args can receive a tuple of any number of arguments. Let's print all that."
   ....:     for arg in args:
   ....:         print arg
</code></pre> 
<p>我们可以调用包含任意数量参数的函数“fun”。</p> 
<pre><code>In [25]: fun(1,5,6,7)
1                                                                         #Output
args can receive a tuple of any number of arguments. Let's print all that.
5
6
7
</code></pre> 
<p>因为“ args”是一个元组，所以我们可以遍历它。</p> 
<p>现在，让我们考虑一个案例，我们使用我们在这里看到的任何东西。这里我们需要使用两个函数。第一个函数必须接受任意数量的参数，它必须计算除第一个参数以外的所有参数的和。此外，这个函数必须使用另一个函数来求和。这里的目标是了解如何在一个函数中获得可变数量的参数，并将这些参数传递给另一个函数。</p> 
<p>让我们先写一个函数来求和，也就是第二个函数。对于我们的例子，这个函数将用于我们尚未编写的第一个函数。</p> 
<pre><code>In [26]: def calculate_sum(*args):
   ....:     return sum(args)
   ....:
</code></pre> 
<p>这里我们使用‘ sum’。函数‘ sum’是一个内置函数，它接受一个元组或一个列表，并返回元组中所有元素的和。从我们的函数定义中可以看到，“ args”将接收一个包含传递给该函数的所有位置参数的 tuple。因此，“ args”是一个元组，可以直接用作函数“ sum”的参数。让我们编写另一个函数，它接受任意数量的参数，并使用以前的函数计算除第一个参数以外的所有参数的和。</p> 
<pre><code>In [29]: def ignore_firstargs_calculate_sum(a, *iargs):
   ....:     required_sum = calculate_sum(*iargs)
   ....:     print "sum is", required_sum
   ....:
   ....:
</code></pre> 
<p>我们可以向这个函数传递任意数量的参数。第一个参数由 a 接收，a 是一个形式参数。所有其他的参数都会被“ iargs”作为一个元组来接收。根据我们正在考虑的情况，我们希望计算除第一个参数以外的所有参数的和。因此，当 a 接收到第一个参数时，我们留下 a。‘ iargs’是包含除第一个参数以外的所有参数的元组。我们将利用函数‘ calculate _ sum’。但是‘ calculate _ sum’期望发送给它的位置参数数量，它将在‘ args’中以元组的形式接收这些参数。所以，在函数‘ ignore _ firstargs calculate _ sum’中，我们需要解压缩 iargs，因为它是一个 tuple，然后发送解包的位置参数来‘ calculate _ sum’。记住，我们用 * 来解包列表/元组。</p> 
<p>因此，我们写下 <code>required _ sum = calculate _ sum (* iargs)</code>。</p> 
<p>我们不能写下 <code>required _ sum = calculate _ sum (iargs)</code> ，因为在发送 <code>calculate _ sum</code> 之前，我们需要解包 tuple iargs 中的值。不使用 <code>*</code> 将不会解包这些值，则不会发生期望的动作。</p> 
<pre><code>In [34]: ignore_firstargs_calculate_sum(3,1,2,6)
sum is 9                          #Output
</code></pre> 
<p>输出是除第一个参数之外所有参数的和。</p> 
<h4><a id="3_193"></a>3、通过一个函数的调用来理解’<code>**</code>’的作用</h4> 
<p>让我们首先考虑一个简单的例子，让我们定义一个有三个参数的函数。</p> 
<pre><code>In [35]: def fun(a, b, c):
   ....:     print a, b, c
   ....:
   ....: Let's call this function in various ways.

In [36]: fun(1,2,3)
1 2 3                            #Output

In [37]: fun(1, b=4, c=6)
1 4 6                            #Output
</code></pre> 
<p>使用”<code>**</code>”调用函数，需要一个字典 。注意：在函数调用中使用 <code>*</code> 时，我们需要一个 list/tuple。为了在函数调用中使用 <code>* *</code> ，我们需要一个字典。</p> 
<pre><code>In [38]: d={'b':5, 'c':7}
</code></pre> 
<p>让我们在函数调用中使用 <code>* *</code> 来调用 fun：</p> 
<pre><code>In [39]: fun(1, **d)
1 5 7
</code></pre> 
<p><strong><code>**</code>在函数调用中做了什么</strong></p> 
<p>它解包了字典，并将字典中的项目作为关键字参数传递给函数。所以<code>fun(1, **d)</code>等同于<code>fun(1, b=5, c=7)</code>。</p> 
<p>让我们尝试更多示例以更好地理解它。</p> 
<pre><code>In [40]: d={'c':3}

In [42]: fun(1,2,**d)           #This is equivalent to fun(1,2,c=3)
1 2 3

In [43]: d={'a':7,'b':8,'c':9}

In [44]: fun(**d)
7 8 9                           #Output
</code></pre> 
<p>现在让我们犯一些错误：</p> 
<pre><code>In [45]: d={'a':1, 'b':2, 'c':3, 'd':4}

In [46]: fun(**d)
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)

/home/akshar/branding_git/netconference/&lt;ipython console&gt; in &lt;module&gt;()

TypeError: fun() got an unexpected keyword argument 'd'
</code></pre> 
<p>最后一条语句相当于<code>fun(a=1, b=2, c=3, d=4)</code>. 但是，<code>fun</code>预计只有三个参数，因此我们得到了这个错误。</p> 
<pre><code>In [47]: d={'a':1, 'b':5, 'd':9}

In [48]: fun(**d)
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)

/home/akshar/branding_git/netconference/&lt;ipython console&gt; in &lt;module&gt;()

TypeError: fun() got an unexpected keyword argument 'd'
</code></pre> 
<p>最后一条语句等价于 <code>fun(a=1, b=5, d=9)</code>。虽然它传递了三个参数，这是“<code>fun</code>”需要的参数数量，但“fun”的参数列表中没有“d”。但是，“d”作为关键字参数传递，因此我们得到了这个错误。</p> 
<p>因此，<code>**</code>解包字典，即字典中的键值对作为关键字参数，并将这些作为关键字参数发送给被调用的函数。<code>*</code>解包一个列表/元组，即列表中的值作为位置参数，这些值作为位置参数发送到被调用的函数。</p> 
<h4><a id="4kwargs_271"></a>4、**kwargs在函数定义中的含义</h4> 
<p>让我们重新定义我们的函数“fun”。</p> 
<p>理解在函数定义中的<code>**kwargs</code><br> 让我们重新定义我们的函数 fun。</p> 
<pre><code>In [49]: def fun(a, **kwargs):
   ....:     print a, kwargs
   ....:
   ....:
</code></pre> 
<p>因此，这个函数只能接受一个位置参数，因为形式参数列表只包含一个变量’a’。但是使用 * * kwargs，它可以接受任意数量的关键字参数。让我们看一些例子。</p> 
<pre><code>In [50]: fun(1, b=4, c=5)
1 {'c': 5, 'b': 4}                #Output

In [51]: fun(2, b=6, c=7, d=8)
2 {'c': 7, 'b': 6, 'd': 8}        #Output
</code></pre> 
<p>#当<code>**kwargs</code>用在函数定义中是什么意思？</p> 
<p>随着<code>**kwargs</code>在函数定义中，<code>kwargs</code>将接收一个字典，其中包含形参列表之外的所有关键字参数。记住kwargs是一个字典。</p> 
<p>在我们前面的两个例子中，当我们打印时<code>kwargs</code>，它打印了一个字典，其中包含形参列表之外的所有关键字参数。</p> 
<p>让我们再次重新定义我们的函数：</p> 
<pre><code>In [54]: def fun(a, **kwargs):
   ....:     print "a is", a
   ....:     print "We expect kwargs 'b' and 'c' in this function"
   ....:     print "b is", kwargs['b']
   ....:     print "c is", kwargs['c']
   ....:
   ....:
</code></pre> 
<p>现在开始调用函数"<code>fun</code>"：</p> 
<pre><code>In [55]: fun(1, b=3, c=5)
a is 1
We expect kwargs 'b' and 'c' in this function
b is 3
c is 5
</code></pre> 
<p>让我们现在犯一些错误：</p> 
<pre><code>In [56]: fun(1, b=3, d=5)
a is 1
We expect kwargs 'b' and 'c' in this function
b is 3
c is---------------------------------------------------------------------------
KeyError                                  Traceback (most recent call last)

/home/akshar/branding_git/netconference/&lt;ipython console&gt; in &lt;module&gt;()

/home/akshar/branding_git/netconference/&lt;ipython console&gt; in fun(a, **kwargs)

KeyError: 'c'
</code></pre> 
<p>我们可以调用函数。第一个位置参数被打印出来。已打印关键字参数“b”。但我们传递的另一个关键字参数是“d”。因为函数需要关键字参数“c”，并试图从字典“kwargs”访问它。但是由于我们没有传递任何关键字参数’c’，我们得到了这个错误。如果我们在函数调用中添加一个关键字参数’c’，我们就不会再得到错误了。</p> 
<pre><code>In [57]: fun(1, b=3, d=5, c=7)
a is 1
We expect kwargs 'b' and 'c' in this function
b is 3
c is 7
</code></pre> 
<p>由于函数参数列表中有<code>**kwargs</code>，因此我们可以传递任意数量的关键字参数。我们传递了<code>d</code>，但没有在函数中使用它。</p> 
<p>让我们再犯一个错误：</p> 
<pre><code>In [58]: fun(1, {'b':2, 'c':3})
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)

/home/akshar/branding_git/netconference/&lt;ipython console&gt; in &lt;module&gt;()

TypeError: fun() takes exactly 1 argument (2 given)
</code></pre> 
<p>正如错误所示，函数“fun”只需要一个位置参数，却得到了两个。因此，尽管“kwargs”将关键字参数作为字典接收，但不能将字典作为位置参数传递给“kwargs”。尽管你可以做一些事情，比如：</p> 
<pre><code>In [59]: fun(1, **{'b':2, 'c':3})
a is 1
We expect kwargs 'b' and 'c' in this function
b is 2
c is 3
</code></pre> 
<p>在字典前面使用<code>**</code>解包字典， 并将字典中的项作为关键字参数传递。</p> 
<h4><a id="5args_kwargs_373"></a>5、给出一个实例说明我们为什么要用<code>*args</code>, <code>**kwargs</code>？</h4> 
<p>每当我们继承一个类并重写继承类的一些方法时，我们应该使用<code>*args</code>和<code>**kwargs</code>，并将接收到的位置和关键字参数传递给超类(父类)方法。用一个例子可以更好地理解。</p> 
<pre><code>In [4]: class Model(object):
   ...:     def __init__(self, name):
   ...:         self.name = name
   ...:     def save(self, force_update=False, force_insert=False):
   ...:         if force_update and force_insert:
   ...:             raise ValueError("Cannot perform both operations")
   ...:         if force_update:
   ...:             #Update an existing record
   ...:             print "Updated an existing record"
   ...:         if force_insert:
   ...:             #Create a new record
   ...:             print "Created a new record"
   ...:
</code></pre> 
<p>我们定义了一个类。我们可以创建这个类的对象，这个类的对象有一个方法“save()”。假设类的对象可以通过save()方法保存到数据库中。根据我们传递给 save() 方法的参数，确定是需要在数据库中创建新记录，还是需要更新现有记录。</p> 
<p>构建一个新类，类有“Model”的动作，但只有满足一些条件才保存这个类的对象。因此，让我们继承 ‘Model’ 并重写 ‘Model’ 的 ‘save()’。</p> 
<pre><code>In [6]: class ChildModel(Model):
   ...:     def save(self, *args, **kwargs):
   ...:         if self.name=='abcd':
   ...:             super(ChildModel, self).save(*args, **kwargs)
   ...:         else:
   ...:             return None
   ...:
</code></pre> 
<p>实际上对应的保存动作发生在’Model’的’save’方法中。所以我们调用子类的的’save()’方法而非’Model’的方法.子类ChildModel的’save()’接收任何父类save()需要的参数，并传给父类方法。因此,子类’save()’方法参数列表中有”<code>*args</code>”和<code>”**kwargs</code>”,它们可以接收形参列表之外的任意位置参数或键值参数。</p> 
<p>下面创建ChildModel实体并保存:</p> 
<pre><code>In [7]: c=ChildModel('abcd')
</code></pre> 
<p>因此，我们创建了一个名称为 =‘abcd’ 的 ChildModel 实例。</p> 
<pre><code>In [9]: c.save(force_insert=True)
Created a new record       #Output
</code></pre> 
<p>在这里，我们向对象的 save() 传递了一个关键字参数。我们把<code>save()</code>叫做子类<code>save()</code>。它接受一个包含关键字参数的字典<code>kwargs</code>。然后用<code>**</code>解包这个字典作为关键字参数，然后将它传递给父类save()。所以，父类save()得到了一个关键字参数<code>force_insert</code>并完成相应的操作。</p> 
<p>让我们尝试传递另一个关键字参数。</p> 
<pre><code>In [10]: c.save(force_update=True)
Updated an existing record      #Output
</code></pre> 
<p>这就是全部。希望你喜欢这篇文章。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/549599ecaa901a08822f0cdbdbbe12bb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">F6-预编译&amp;编译&amp;安装</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/582c9085b1399eb15aeed997292a5ffb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">计算机组策略没有权限,gpedit.msc组策略无权限运行</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>