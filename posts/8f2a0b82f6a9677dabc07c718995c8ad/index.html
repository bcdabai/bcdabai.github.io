<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>语音压缩和无话部分抑制 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="语音压缩和无话部分抑制" />
<meta property="og:description" content="语音压缩
数字语音总是源自具有64kbit/s速率的PCM语音流，这将引起一些问题。解决它最简单的方法是对PCM语音流进行某种形式的压缩。尽管通常用“语音压缩”表示这一处理，但是它并不是指压缩语音本身，而是指压缩64kbit/s的PCM语音流。今天可将语音压缩到13khit/s，甚至于8kbit/s。可以通过以下两种方法实现语音压缩：第一种，开发新的芯片组将模拟语音直接转化成上述速率。第二种方法，把64kbit/s的PCM语音流作为第二阶段语音数字化的输入处理对象，这次数字化的输出就是较低速率的语音了。第二种方法不要求全新的模数转化芯片，仅仅是增加一些对64kbit/s速率的PCM语音流进行压缩的芯片。
注意，语音压缩本身不能自动产生突发式语音。8kbit/s的语音仍然是固定比特速率的。要想把语音变为突发式的，就必须将谈话中不说话的部分去除。
无话部分抑制
无话部分抑制是指将谈话中不说话的部分去除。引起没有语音的主要原因是谈话中，总有·方处于玲听状态，也有小部分无语音是由句与句、短语与短语之间的停顿引起的。总之，在一个双向的64kbit/s速率的PCM语音流交谈中，有60%并没有实际语音。
抑制无话部分面对的最大问题是：说话的人在一段沉默之后，如何识别他将于何时再开始说话。为什么这会成为一个困难呢？这是因为谈话方总有些背景噪声的影响，根据无话部分抑制的概念，周围的背景噪声不应被分组化，也不应被发送，系统应该只对真正的语音进行处理，所以必需把背景噪声和真正的语音区分开来。其中的技巧在于可靠地识别出说话人的音量级别远远高于背景噪声的，从而判断出他又开始说话了。比背景噪声高的声音也可能是噪声的突然爆发（比如敲击声）。这就是“语音激活识别”（简称VAD）问题。
如果语音激活识别的级别设置得太低，那么玲听的一方会突然听到敲击声、车鸣声等等外界与谈话无关的声音。如果语音激活识别的级别设置得太高了，那么谈话人再次开始的谈话将被剪辑掉一部分，刚开始的声音因为较低而不被分组化和发送。因为语音分组化的处理是实时的，所以当设置级别过高的VAD进程意识到交谈的人已经开始说话时，已经来不及获取最初的语音了。
当对VoIP分组进行了语音压缩和对抑制无话部分进行处理之后，就可以使它与其他分组一起在64kbit/s的链路上传输了。但这样做，我们将很难将链路上的VoIP分组传输和文件传输、电子邮件传输区别开来。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/8f2a0b82f6a9677dabc07c718995c8ad/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-22T16:32:05+08:00" />
<meta property="article:modified_time" content="2022-07-22T16:32:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">语音压缩和无话部分抑制</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p class="img-center"><img alt="" src="https://images2.imgbox.com/1a/64/Lf4orzar_o.png"></p> 
<p><br><strong>语音压缩</strong></p> 
<p>       数字语音总是源自具有64kbit/s速率的PCM语音流，这将引起一些问题。解决它最简单的方法是对PCM语音流进行某种形式的压缩。尽管通常用“语音压缩”表示这一处理，但是它并不是指压缩语音本身，而是指压缩64kbit/s的PCM语音流。今天可将语音压缩到13khit/s，甚至于8kbit/s。可以通过以下两种方法实现语音压缩：第一种，开发新的芯片组将模拟语音直接转化成上述速率。第二种方法，把64kbit/s的PCM语音流作为第二阶段语音数字化的输入处理对象，这次数字化的输出就是较低速率的语音了。第二种方法不要求全新的模数转化芯片，仅仅是增加一些对64kbit/s速率的PCM语音流进行压缩的芯片。</p> 
<p>       注意，语音压缩本身不能自动产生突发式语音。8kbit/s的语音仍然是固定比特速率的。要想把语音变为突发式的，就必须将谈话中不说话的部分去除。</p> 
<p><strong>无话部分抑制</strong></p> 
<p>       无话部分抑制是指将谈话中不说话的部分去除。引起没有语音的主要原因是谈话中，总有·方处于玲听状态，也有小部分无语音是由句与句、短语与短语之间的停顿引起的。总之，在一个双向的64kbit/s速率的PCM语音流交谈中，有60%并没有实际语音。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/39/84/6eXQO2K0_o.png"></p> 
<p>       抑制无话部分面对的最大问题是：说话的人在一段沉默之后，如何识别他将于何时再开始说话。为什么这会成为一个困难呢？这是因为谈话方总有些背景噪声的影响，根据无话部分抑制的概念，周围的背景噪声不应被分组化，也不应被发送，系统应该只对真正的语音进行处理，所以必需把背景噪声和真正的语音区分开来。其中的技巧在于可靠地识别出说话人的音量级别远远高于背景噪声的，从而判断出他又开始说话了。比背景噪声高的声音也可能是噪声的突然爆发（比如敲击声）。这就是“语音激活识别”（简称VAD）问题。</p> 
<p>      如果语音激活识别的级别设置得太低，那么玲听的一方会突然听到敲击声、车鸣声等等外界与谈话无关的声音。如果语音激活识别的级别设置得太高了，那么谈话人再次开始的谈话将被剪辑掉一部分，刚开始的声音因为较低而不被分组化和发送。因为语音分组化的处理是实时的，所以当设置级别过高的VAD进程意识到交谈的人已经开始说话时，已经来不及获取最初的语音了。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/8e/b6/pmmGs4nm_o.png"></p> 
<p>       当对<a href="https://www.dsliu.com/" rel="nofollow" title="VoIP">VoIP</a>分组进行了语音压缩和对抑制无话部分进行处理之后，就可以使它与其他分组一起在64kbit/s的链路上传输了。但这样做，我们将很难将链路上的VoIP分组传输和文件传输、电子邮件传输区别开来。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fb19f826abafa60b52881c97766a9759/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">解决：Error:svn: E155037: Previous operation has not finished； run ‘cleanup‘ if it was interrupted</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3570653e3531b860660d10bbcdb19668/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">DTS设备树规则</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>