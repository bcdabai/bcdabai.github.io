<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java经典面试题整理及答案详解（一） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java经典面试题整理及答案详解（一）" />
<meta property="og:description" content="Java在编程语言中，占据着重要的地位，随着技术的更新与发展，越来越多的人进入互联网行业、踏上Java编程之旅。本系列内容来源于阿里云大学Java面试技巧，面试真题&#43;理论解析，主要针对Java编程应用领域就业的人群，找工作前看一看，希望该系列面试真题能助您一臂之力～
1.说一下java类集 类集是java实现的数据结构应用，如果只是使用，那么类集的操作非常简单，因为类集的核心接口有List，Set、Map、Iterator、Enumeration；List子接口：是可以根据索引号取得内容，而在list集合里最容易问到的问题：ArrayList（包装了数组的集合，比较常用，数组是可变的）、LinkedList（链表的实现，搜索数据的时间复杂度为：n） 区别；有需要Java课程及面试资料的可以私信博主直接拿走噢Set子接口：排序子类、HashSet与hashCode（）和equals的关系；
— Hashset：重复的判断依靠的是hashcode（）和equals（），但是它是无序的 — TreeSet：是有序的，依靠的是Comparable排序
— LinkedHashSet：继承了HashSet的特点，但是属于有序（增加顺序为保存顺序）
Map接口：Map.Entry、Iterator输出、HashMap、WeakHashMap（弱引用）。
如果只回答这一个问题，按以上几点说，这道题基本上就可以拿下，但也有可能追问其他的问题，例如：可能要求你现场编写一个链表，或者编写一个二叉树。这时候就要熟悉链表与二叉树的数据结构。 2、字符串哈西相等，equals相等吗?反过来呢？ 凡是这类问相不相等的，写个程序测试是比较方便的办法。
范例：首先观察直接赋值
*提到字符串，首先就要想到共享数据词，共享常量词
范例：采用构造法
范例：字符串
总结：从正常道理来讲，如果hashCode()相等，equals不一定相等。反过来equals相等，那么hashCode()一定相等。
3、Spring的工作原理，控制反转是怎么实现的？自己写过滤器过滤编码怎么实现？ Spring的核心组成：IOC&amp;DI(工厂设计)、AOP(代理设计、动态代理设计)；
-Spring之中针对于XML的解析处理采用的是DOM4J的实现； -Anntation的时候必须要求有一个容器；
对于编码过滤需要考虑两种情况：
-Struts1.x、SpringMVC、JSP&#43;Servlet：都可以以直接通过过滤器完成； -Struts2.x：必须通过拦截器完成；
-实现：考虑到可扩展性的配置，所以在配置文件里面设置编码，在程序运行的时候动态取得设置的编码进行操作。但是需要设置两个操作：请求编码、回应编码。
4、框架的源码有没有看过？ 不要回答没有，即使你真的没有，你也别回答没有看过；框架的核心思想：反射&#43;XML(Annotation)
-Struts2.X的设计：请求交由过滤器执行，而后过滤器交给控制器完成，后面由于将跳转路径等信息都写在了配置文件或知识Annoration里面，所以还需要进行这部分内容的加载； -SpringMVC：它是基于方法的请求处理，所有的参数都提交到方法上，本质上还是一个DispatcherServlet；
-Hibernate：就是反射和DOM4J解析处理流程。
5、动态代理是怎么实现的？ 直接使用Invocation Handler接口进行实现，同时利用Proxy类设置动态请求对象；使用CGLIB来避免对于“代理设计模式需要使用接口实现”的限制。 6、action是单实例还是多实例? Struts 2.x和Spring MVC中的Action都是多实例；Struts 1.x的Action是单实例；Struts 2.x和Spring MVC是否单实例可以控制，只要交由Spring管理的Action类，都可以通过“@scope=“prototype””来进行控制。 7、怎么配置bean？ 这样的配置主要是在Spring里面，重点只有xml和annotation的扫描负责：
xml中直接使用&#34;bean&#34;，这样在Spring容器启动的时候就可以通过容器进行初始化；annotation必须设置context命名空间，而后进行扫描包的配置。 8、修改单实例多实例. “@scope=“prototype””来进行控制。
9．Java的设计模式 工厂设计模式、代理设计模式、单例设计模式、合成设计模式、门面设计模式（JDBC）、装饰设计模式、模版设计模式。
10.事务的控制 MySQL数据库如果想要使用事务，必须使用“type=innodb”这个数据引擎；事务的核心控制：commit、rollback；在Spring里面，利用AspectJ可以设置AOP的切面，而后进行声明式事务控制。 11. 脏读、幻读、不可重复读 脏读：脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。幻读：是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新的数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好像发生了幻觉一样。不可重复读：是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，第一个事务两次读到的数据可能是不一样的，这样就发生了在一个事务内两次读到的事务是不一样的，因此成为不可重复读。 12 .事务的传播属性 在Transaction Definition接口中定义了七个事务传播行为：
PROPAGATION REQUIRED：如果存在一个事务，则支持当前事务，如果没有事务则开启一个新的事务；PROPAGATION SUPPORTS：如果存在一个事务，支持当前事务，如果没有事务则非事务的执行，但是对于事务同步的事务管理器，PROPAGATION SUPPORTS与不使用事务有少许不同；PROPAGATION MANDATORY：如果已经存在一个事务，支持当前事务，如果没有一个活动的事务，则抛出异常；PROPAGATION REQUIRES NEW：总是开启一个新的事务，如果一个事务已经存在，则将这个存在的事务挂起；PROPAGATION_NOT_SUPPORTED：总是非事务地执行，并挂起任何存在的事务；PROPAGATION_NEVER：总是非事务地执行，如果存在一个活动事务，则抛出异常；PROPAGATION NESTED：如果一个活动的事务存在，则运行在一个嵌套的事务中，如果没有活动事务，则按Transaction Definition.PROPAGATION_REQUIRED属性执行。 13.购物车是怎么实现的? 购物车的实现基于：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/b156f02fe7702d5d3d4ade70c71f8e1b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-09T09:48:57+08:00" />
<meta property="article:modified_time" content="2022-10-09T09:48:57+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java经典面试题整理及答案详解（一）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-left:0;"><span style="color:#24292e;"><span style="background-color:#ffffff;">Java在编程语言中，占据着重要的地位，随着技术的更新与发展，越来越多的人进入互联网行业、踏上Java编程之旅。本系列内容来源于阿里云大学Java面试技巧，面试真题+理论解析，主要针对Java编程应用领域就业的人群，找工作前看一看，希望该系列面试真题能助您一臂之力～</span></span></p> 
<h4 id="slide-0" style="margin-left:0;"><span style="color:#181818;"><span style="background-color:#ffffff;">1.说一下java类集</span></span></h4> 
<ul style="margin-left:0;"><li><strong>类集是java实现的数据结构应用</strong>，如果只是使用，那么类集的操作非常简单，因为类集的核心接口有List，Set、Map、Iterator、Enumeration；</li><li><strong>List子接口</strong>：是可以根据索引号取得内容，而在list集合里最容易问到的问题：ArrayList（包装了数组的集合，比较常用，数组是可变的）、LinkedList（链表的实现，搜索数据的时间复杂度为：n） 区别；<strong>有需要Java课程及面试资料的可以私信博主直接拿走噢</strong></li><li><strong>Set子接口</strong>：排序子类、HashSet与hashCode（）和equals的关系；<br> — Hashset：重复的判断依靠的是hashcode（）和equals（），但是它是无序的</li></ul> 
<p style="margin-left:0;"><span style="color:#24292e;"><span style="background-color:#ffffff;">— TreeSet：是有序的，依靠的是Comparable排序<br> — LinkedHashSet：继承了HashSet的特点，但是属于有序（增加顺序为保存顺序）</span></span></p> 
<ul style="margin-left:0;"><li><strong>Map接口</strong>：Map.Entry、Iterator输出、HashMap、WeakHashMap（弱引用）。<br> 如果只回答这一个问题，按以上几点说，这道题基本上就可以拿下，但也有可能追问其他的问题，例如：可能要求你现场编写一个链表，或者编写一个二叉树。这时候就要熟悉链表与二叉树的数据结构。</li></ul> 
<h4 id="slide-1" style="margin-left:0;"><span style="color:#181818;"><span style="background-color:#ffffff;">2、字符串哈西相等，equals相等吗?反过来呢？</span></span></h4> 
<p style="margin-left:0;"><span style="color:#24292e;"><span style="background-color:#ffffff;">凡是这类问相不相等的，写个程序测试是比较方便的办法。<br><strong>范例：首先观察直接赋值</strong><br> *提到字符串，首先就要想到共享数据词，共享常量词</span></span></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/21/ad/b4jkMBP9_o.png"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/08/88/sSxARues_o.png"></p> 
<p style="margin-left:0;"><span style="color:#24292e;"><span style="background-color:#ffffff;"><strong>范例：采用构造法</strong></span></span></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/db/c1/QHDJjEVa_o.png"></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"><span style="color:#24292e;"><span style="background-color:#ffffff;"><strong>范例：字符串</strong></span></span></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/91/da/lAxFxX4J_o.png"></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"><span style="color:#24292e;"><span style="background-color:#ffffff;">总结：从正常道理来讲，如果hashCode()相等，equals不一定相等。反过来equals相等，那么hashCode()一定相等。</span></span></p> 
<h4 id="slide-2" style="margin-left:0;"><span style="color:#181818;"><span style="background-color:#ffffff;">3、Spring的工作原理，控制反转是怎么实现的？自己写过滤器过滤编码怎么实现？</span></span></h4> 
<ul style="margin-left:0;"><li><strong>Spring的核心组成</strong>：IOC&amp;DI(工厂设计)、AOP(代理设计、动态代理设计)；<br> -Spring之中针对于XML的解析处理采用的是DOM4J的实现；</li></ul> 
<p style="margin-left:0;"><span style="color:#24292e;"><span style="background-color:#ffffff;">-Anntation的时候必须要求有一个容器；</span></span></p> 
<ul style="margin-left:0;"><li><strong>对于编码过滤需要考虑两种情况</strong>：<br> -Struts1.x、SpringMVC、JSP+Servlet：都可以以直接通过过滤器完成；</li></ul> 
<p style="margin-left:0;"><span style="color:#24292e;"><span style="background-color:#ffffff;">-Struts2.x：必须通过拦截器完成；<br> -实现：考虑到可扩展性的配置，所以在配置文件里面设置编码，在程序运行的时候动态取得设置的编码进行操作。但是需要设置两个操作：请求编码、回应编码。</span></span></p> 
<h4 id="slide-3" style="margin-left:0;"><span style="color:#181818;"><span style="background-color:#ffffff;">4、框架的源码有没有看过？</span></span></h4> 
<ul style="margin-left:0;"><li><strong>不要回答没有，即使你真的没有，你也别回答没有看过</strong>；</li><li><strong>框架的核心思想：反射+XML(Annotation)</strong><br> -Struts2.X的设计：请求交由过滤器执行，而后过滤器交给控制器完成，后面由于将跳转路径等信息都写在了配置文件或知识Annoration里面，所以还需要进行这部分内容的加载；</li></ul> 
<p style="margin-left:0;"><span style="color:#24292e;"><span style="background-color:#ffffff;">-SpringMVC：它是基于方法的请求处理，所有的参数都提交到方法上，本质上还是一个DispatcherServlet；<br> -Hibernate：就是反射和DOM4J解析处理流程。</span></span></p> 
<h4 id="slide-4" style="margin-left:0;"><span style="color:#181818;"><span style="background-color:#ffffff;">5、动态代理是怎么实现的？</span></span></h4> 
<ul style="margin-left:0;"><li>直接使用Invocation Handler接口进行实现，同时利用Proxy类设置动态请求对象；</li><li>使用CGLIB来避免对于“代理设计模式需要使用接口实现”的限制。</li></ul> 
<h4 id="slide-5" style="margin-left:0;"><span style="color:#181818;"><span style="background-color:#ffffff;">6、action是单实例还是多实例?</span></span></h4> 
<ul style="margin-left:0;"><li>Struts 2.x和Spring MVC中的Action都是多实例；</li><li>Struts 1.x的Action是单实例；</li><li>Struts 2.x和Spring MVC是否单实例可以控制，只要交由Spring管理的Action类，都可以通过“@scope=“prototype””来进行控制。</li></ul> 
<h4 id="slide-6" style="margin-left:0;"><span style="color:#181818;"><span style="background-color:#ffffff;">7、怎么配置bean？</span></span></h4> 
<p style="margin-left:0;"><span style="color:#24292e;"><span style="background-color:#ffffff;">这样的配置主要是在Spring里面，重点只有xml和annotation的扫描负责：</span></span></p> 
<ul style="margin-left:0;"><li>xml中直接使用"bean"，这样在Spring容器启动的时候就可以通过容器进行初始化；</li><li>annotation必须设置context命名空间，而后进行扫描包的配置。</li></ul> 
<h4 id="slide-7" style="margin-left:0;"><span style="color:#181818;"><span style="background-color:#ffffff;">8、修改单实例多实例.</span></span></h4> 
<p style="margin-left:0;"><span style="color:#24292e;"><span style="background-color:#ffffff;">“@scope=“prototype””来进行控制。</span></span></p> 
<h4 id="slide-8" style="margin-left:0;"><span style="color:#181818;"><span style="background-color:#ffffff;">9．Java的设计模式</span></span></h4> 
<p style="margin-left:0;"><span style="color:#24292e;"><span style="background-color:#ffffff;">工厂设计模式、代理设计模式、单例设计模式、合成设计模式、门面设计模式（JDBC）、装饰设计模式、模版设计模式。</span></span></p> 
<h4 id="slide-9" style="margin-left:0;"><span style="color:#181818;"><span style="background-color:#ffffff;">10.事务的控制</span></span></h4> 
<ul style="margin-left:0;"><li>MySQL数据库如果想要使用事务，必须使用“type=innodb”这个数据引擎；</li><li>事务的核心控制：commit、rollback；</li><li>在Spring里面，利用AspectJ可以设置AOP的切面，而后进行声明式事务控制。</li></ul> 
<h4 id="slide-10" style="margin-left:0;"><span style="color:#181818;"><span style="background-color:#ffffff;">11. 脏读、幻读、不可重复读</span></span></h4> 
<ul style="margin-left:0;"><li><strong>脏读</strong>：脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。</li><li><strong>幻读</strong>：是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新的数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好像发生了幻觉一样。</li><li><strong>不可重复读</strong>：是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，第一个事务两次读到的数据可能是不一样的，这样就发生了在一个事务内两次读到的事务是不一样的，因此成为不可重复读。</li></ul> 
<h4 id="slide-11" style="margin-left:0;"><span style="color:#181818;"><span style="background-color:#ffffff;">12 .事务的传播属性</span></span></h4> 
<p style="margin-left:0;"><span style="color:#24292e;"><span style="background-color:#ffffff;"><strong>在Transaction Definition接口中定义了七个事务传播行为：</strong></span></span></p> 
<ul style="margin-left:0;"><li>PROPAGATION REQUIRED：如果存在一个事务，则支持当前事务，如果没有事务则开启一个新的事务；</li><li>PROPAGATION SUPPORTS：如果存在一个事务，支持当前事务，如果没有事务则非事务的执行，但是对于事务同步的事务管理器，PROPAGATION SUPPORTS与不使用事务有少许不同；</li><li>PROPAGATION MANDATORY：如果已经存在一个事务，支持当前事务，如果没有一个活动的事务，则抛出异常；</li><li>PROPAGATION REQUIRES NEW：总是开启一个新的事务，如果一个事务已经存在，则将这个存在的事务挂起；</li><li>PROPAGATION_NOT_SUPPORTED：总是非事务地执行，并挂起任何存在的事务；</li><li>PROPAGATION_NEVER：总是非事务地执行，如果存在一个活动事务，则抛出异常；</li><li>PROPAGATION NESTED：如果一个活动的事务存在，则运行在一个嵌套的事务中，如果没有活动事务，则按Transaction Definition.PROPAGATION_REQUIRED属性执行。</li></ul> 
<h4 id="slide-12" style="margin-left:0;"><span style="color:#181818;"><span style="background-color:#ffffff;">13.购物车是怎么实现的?</span></span></h4> 
<p style="margin-left:0;"><span style="color:#24292e;"><span style="background-color:#ffffff;"><strong>购物车的实现基于：</strong></span></span></p> 
<ul style="margin-left:0;"><li>Session：浏览器关闭后消失；</li><li>Cookie：数据保存在本地，如果切换到手机上无效；</li><li>数据库：可以在不同的终端上持续操作。<br> 你的实现：Ajax处理操作，处理购物车的应用，考虑到用户如果多的情况，并且访问量频繁，要单独设计一个购物车的子系统模块。</li></ul> 
<h4 id="slide-13" style="margin-left:0;"><span style="color:#181818;"><span style="background-color:#ffffff;">14.统计一天的订单量</span></span></h4> 
<ul style="margin-left:0;"><li>如果一天的订单预估才1W条，随便你折腾；</li><li>绝对不可能使用COUNT()和WHERE；<br> 分时统计，如果系统统计到位，可以单独配置一个文件进行计数（需要考虑同步，一同步就慢），不应该出现在抢购环节中。</li></ul> 
<h4 id="slide-14" style="margin-left:0;"><span style="color:#181818;"><span style="background-color:#ffffff;">15.IN HAVING exsit</span></span></h4> 
<p style="margin-left:0;"><span style="color:#24292e;"><span style="background-color:#ffffff;"><strong>IN是判断具体的几项数据</strong>:<br> HAVING是针对于分组后的数据的筛选，依然要使用统计函数处理；<br> EXISTS：只是需要判断子查询里面是否有数据。</span></span></p> 
<h4 id="slide-15" style="margin-left:0;"><span style="color:#181818;"><span style="background-color:#ffffff;">16.有没有用过定时任务？</span></span></h4> 
<p style="margin-left:0;"><span style="color:#24292e;"><span style="background-color:#ffffff;"><strong>Java本身提供有定时任务</strong>：Time Task、Timer；但是此类操作对于定时很难完成，它只能够做频率，但是这个频率不准，所以在定时开发之中会使用quartz组件，而且spring里面也提供有自己的定时实现，这个实现的好处是可以在准确的时间上进行触发。</span></span></p> 
<h4 id="slide-16" style="margin-left:0;"><span style="color:#181818;"><span style="background-color:#ffffff;">17.JVM的内存管理</span></span></h4> 
<p style="margin-left:0;"><span style="color:#24292e;"><span style="background-color:#ffffff;"><strong>内存分为</strong>：栈（java虚拟机栈）、堆、程序计数器（类似于寄存器）、方法区、本地方法栈。<br><strong>垃圾处理操作指的是堆内存</strong>：年轻代、老年代、永生代（JDK1.8移除）。会直接牵扯到JVM的内存调优问题。<br> 推荐《深入java虚拟机》</span></span></p> 
<h4 id="slide-17" style="margin-left:0;"><span style="color:#181818;"><span style="background-color:#ffffff;">18．堆内存、栈内存溢出</span></span></h4> 
<p style="margin-left:0;"><span style="color:#24292e;"><span style="background-color:#ffffff;"><strong>栈溢出</strong>：栈帧，所有的方法调用都是通过栈帧的形式控制的。栈如果保存的数据过多，那么就会产生内存溢出，如果堆内存中产生的数据量过大，那么就有可能出现“OutOfMemoryError”错误。</span></span></p> 
<h4 id="slide-18" style="margin-left:0;"><span style="color:#181818;"><span style="background-color:#ffffff;">19.说一下缓存</span></span></h4> 
<p style="margin-left:0;"><span style="color:#24292e;"><span style="background-color:#ffffff;">缓存的主要目的是提高查询的效率，常见的两种缓存组件：EhCache（用于数据库）、OSCache（用于页面），除了这样的操作之外，还有缓存的数据库：redis、memcached，其中redis可以将数据保存到磁盘上，并且支持的数据类型要多于memcached。这种redis的数据库每秒并发的访问量可以达到15W次。</span></span></p> 
<h4 id="slide-19" style="margin-left:0;"><span style="color:#181818;"><span style="background-color:#ffffff;">20.统计所有重名用户</span></span></h4> 
<p style="margin-left:0;"><span style="color:#24292e;"><span style="background-color:#ffffff;">还是需要考虑数据量问题，如果数据量大，考虑使用位图索引，如果数据量小就直接分组统计即可。</span></span></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f08eb72c257c38833e83267ebdaabd15/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java中的继承</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6ead1f69787b1ef2f6775e36b509d8fb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">WPF入门0：WPF的基础知识</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>