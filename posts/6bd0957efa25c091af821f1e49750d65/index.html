<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>笔试的一些题目 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="笔试的一些题目" />
<meta property="og:description" content="int Strcmp(char *str1, char *str2)
{
int i=0;
int b=0;
while(str1[i]||str2[i])
{
if(str1[i]&gt;str2[i])
{
b=1;break;
}
else if(str1[i]&lt;str2[i])
{
b=-1;break;
}
i&#43;&#43;;
}
return b;
}
***************************************************************************************************************
1.说出下面这个程序的运行结果，并简要叙述其理由：
char buf1[10]=&#34;hello&#34;;
char buf2[10]=&#34;hello&#34;;
if (buf1==buf2)
printf(&#34;equal!&#34;);
else printf(&#34;not equal!&#34;);
因为buf1,buf2分配了不同的内存块，而比较的是数组名，实际上是两个分别指向数组起始元素地址的指针。
2.指出下面这段程序中存在一些什么问题：
int loop,a[5];
int* p=a;
for (loop=0;loop&lt;5;loop&#43;&#43;)
{ p&#43;&#43;;
*p=loop;
}
数组a[5]在创建时没有初始化， 在for循环里也没有起到完全初始化数组的作用，而且对一块未知内存赋值。在最后一轮循环
结束时p指向了数组a[5]的最后一个元素的下一个地址。
string 系列
char * strcpy( char *strDest, const char *strSrc ) {
assert( (strDest != NULL) &amp;&amp; (strSrc !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/6bd0957efa25c091af821f1e49750d65/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2005-12-14T16:44:00+08:00" />
<meta property="article:modified_time" content="2005-12-14T16:44:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">笔试的一些题目</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>int Strcmp(char *str1, char *str2)<br>{<!-- --><br>   int i=0;<br>   int b=0;<br>   while(str1[i]||str2[i])<br>   {<!-- --><br>      if(str1[i]&gt;str2[i])<br>      {<!-- --><br>         b=1;break;<br>      }<br>      else if(str1[i]&lt;str2[i])<br>      {<!-- --><br>         b=-1;break;<br>      }<br>      i++;<br>   }<br>   return b;<br>}</p> 
<p>***************************************************************************************************************<br>1.说出下面这个程序的运行结果，并简要叙述其理由：</p> 
<p>char buf1[10]="hello";<br>char buf2[10]="hello";<br>if (buf1==buf2)<br>printf("equal!");<br>else printf("not equal!");<br>因为buf1,buf2分配了不同的内存块，而比较的是数组名，实际上是两个分别指向数组起始元素地址的指针。</p> 
<p>2.指出下面这段程序中存在一些什么问题：</p> 
<p>int loop,a[5];<br>int* p=a;<br>for (loop=0;loop&lt;5;loop++)<br>{ p++;<br>*p=loop;<br>}</p> 
<p>数组a[5]在创建时没有初始化， 在for循环里也没有起到完全初始化数组的作用，而且对一块未知内存赋值。在最后一轮循环<br>结束时p指向了数组a[5]的最后一个元素的下一个地址。</p> 
<p>string 系列</p> 
<p>char * strcpy( char *strDest, const char *strSrc ) <br>{<!-- --><br>　assert( (strDest != NULL) &amp;&amp; (strSrc != NULL) );<br>char *address = strDest; <br>　while( (*strDest++ = * strSrc++) != ‘/0’ ); <br>return address;<br>}</p> 
<p>char* strncpy(char* strdest, const char* strsrc, int n)<br>{<!-- --><br>   assert((strdest != NULL) &amp;&amp; (strsrc != NULL));<br>   char* address = strdest;<br>   while(n-- &gt; 0)<br>      *strdest++ = *strsrc++;<br>   return address;<br>}</p> 
<p>int strcmp(const char* str1, const char* str2)<br>{<!-- --><br>   assert((str1 != NULL) &amp;&amp; (str2 != NULL);<br>   int ret = 0;<br>   while (!(ret = (unsigned char*)*str1 - (unsigned char*)*str2) &amp;&amp; (*str2))<br>   {<!-- --><br>      str1++;<br>      str2++;<br>   }<br>   if (ret &gt; 0)<br>      ret = 1;<br>   else if (ret &lt; 0)<br>      ret = -1;<br>   return ret;<br>}</p> 
<p>int strlen(const char* str)<br>{<!-- --><br>   assert(str != NULL);<br>   int len = 0;<br>   while ('/0' != *str++)<br>      len++;<br>   return len;<br>}<br>类string的构造函数<br>string::string(const char* str)<br>{<!-- --><br>   if(str == NULL)<br>   {<!-- --><br>      m_data = new char[1];<br>      *m_data = '/0';<br>    }<br>    else<br>    {<!-- --><br>       int length = strlen(str);<br>       m_data = new char[str + 1];<br>       strcpy(m_data, str);<br>     }<br>}</p> 
<p>string 的析构函数<br>string::~string()<br>{<!-- --><br>   delete [] m_data;<br>}</p> 
<p>string 的拷贝构造函数<br>string ::string(const string&amp; other)<br>{<!-- --><br>   int len = strlen(other.m_data);<br>   m_data = new char[len + 1];<br>   strcpy(m_data, other.m_data);<br>}</p> 
<p>string 的赋值函数<br>string&amp; string::operator=(const string&amp; other)<br>{<!-- --><br>   if (this == &amp;other)<br>      return *this;<br>   delete [] m_data;<br>   int len = strlen(other.m_data);<br>   m_data = new char[len + 1];<br>   strcpy(m_data, other.m_data);<br>   return *this;<br>}   </p> 
<p><br>不用任何局部和全局变量实现int strlen(char *a) </p> 
<p>int strlen(char *a) {<!-- --><br>    if('/0' == *a)<br>        return 0;<br>    else <br>        return 1 + strlen(a + 1);<br>}</p> 
<p><br>1)sizeof相关系列问题<br>2)const相关系列问题<br>3)大量林锐书的习题，以及各种变种<br>这三个几乎是每次必出现<br>下面的这些是程序相关题,很多都是以前有讨论过的,还请各位大侠能整理个比较适合做面试时答案的解答,多谢了.最好能给出<br>讨论链接,让我等后辈有学习的机会.<br>1)求出相似度的算法.<br>2)写出二分查找的代码.<br>int binary_search(int* arr, int key, int n)<br>{<!-- --><br>   int low = 0;<br>   int high = n - 1;<br>   int mid;<br>   while (low &lt;= high)<br>   {<!-- --><br>      mid = (high + low) / 2;<br>      if (arr[mid] &gt; k)<br>         high = mid - 1;<br>      else if (arr[mid] &lt; k)<br>         low = mid + 1;<br>      else<br>         return mid;<br>   }<br>   return -1;<br>}<br>   <br>3)写出在母串中查找子串出现次数的代码.<br>*4)写出快速排序或者某种排序算法代码<br>出现次数相当频繁<br>5)写出查找从一个集合中输出所有子集合的算法.<br>*6)实现strcpy函数<br>char* strcpy(char* dest, const char* src)<br>{<!-- --><br>   assert((dest != NULL) &amp;&amp; (src != NULL));<br>   char* address = dest;<br>   while ('/0' != (*dest++ = *src++));<br>   return address;<br>}<br>出现次数相当频繁<br>*7)实现strcmp函数<br>int mystrcmp(const char* str1, const char* str2)<br>{<!-- --><br>   assert((str1 != NULL) &amp;&amp; (str2 != NULL));<br>   int ret = 0;<br>   while (!(ret = *(unsigned char*)str1 - *(unsigned char*)str2) &amp;&amp; *str2)<br>   {<!-- --><br>      str1++;<br>      str2++;<br>   }<br>   if (ret &gt; 0)<br>      ret = 1;<br>   else if (ret &lt; 0)<br>      ret = -1;<br>   return ret;<br>}<br>   <br>出现次数相当频繁<br>8)将一个单链表逆序<br>struct test<br>{<!-- --><br>   int number;<br>   double score;<br>   test* next;<br>}<br>void reverse(test*&amp; head)<br>{<!-- --><br>   test* pe = head;<br>   test* ps = head-&gt;next;<br>   while(ps != NULL)<br>   {<!-- --><br>      pe-&gt;next = ps-&gt;next;<br>      ps-&gt;next = head;<br>      head = ps;<br>      ps = pe-&gt;next;<br>    }<br>}  <br>   <br>      <br>      <br>9)循环链表的节点对换和删除。<br>*10)将一个数字字符串转换为数字."1234" --&gt;1234<br>＃i nclude&lt;iostream&gt;<br>using namespace std;</p> 
<p>int f(char* s)<br>{<!-- --><br>   int k = 0;<br>   while (*s)<br>   {<!-- --><br>      k = 10 * k + (*s++)- '0';<br>      <br>   } <br>   return k;<br>}</p> 
<p>int main()<br>{<!-- --><br>   int digit = f("4567");<br>   cout&lt;&lt;digit&lt;&lt;endl;<br>   cin.get();<br>}<br>出现次数相当频繁<br>11)实现任意长度的整数相加或者相乘功能。<br>*12)写函数完成内存的拷贝<br>一个内存拷贝函数的实现体</p> 
<p>void *memcpy(void *pvTo,const void *pvFrom,size_t size)</p> 
<p>{<!-- --></p> 
<p>assert((pvTo!=NULL)&amp;&amp;(pvFrom!=NULL));</p> 
<p>byte *pbTo=(byte*)pvTo; //防止地址被改变</p> 
<p>byte *pbFrom=(byte*)pvFrom;</p> 
<p>while (size-- &gt;0)</p> 
<p>*pbTo++ = *pbForm++;</p> 
<p>return pvTo;</p> 
<p>} </p> 
<p>出现次数相当频繁</p> 
<p> </p> 
<p><br>.笔试: <br>1)写一个内存拷贝函数,不用任何库函数.就是前些时候本版讨论的那个问题.<br> void* memcpy(void* pvTo, const void* pvFrom, size_t size)<br> {<!-- --><br>    assert((pvTo != NULL) &amp;&amp; (pvFrom != NULL));<br>    byte* pbTo = pvTo;<br>    byte* pbFrom = pbFrom;<br>    while (size-- &gt; 0)<br>    {<!-- --><br>       *pbTo++ = *pbFrom++;<br>    }<br>    return pvTo;<br> }<br>2)将一个单链表逆序.(这个问题是个常规的数据结构问题.不过不小心时会损失效率) <br>3)客房预定的问题.根据客户报的人数,客房等级来从预备的客房中选择出所有符合要求的 </p> 
<p>客房号.客户没有要求等级时,只考虑人数因素就可以了.要考虑有些客房已经预定的情况. </p> 
<p>(写代码是要考虑好彼此的效率) <br>4)对于一个无序序列进行二分查找 <br>线排序再查找</p> 
<p>5)将一个数字字符串转换为数字."1234" --&gt;1234<br>int convert(char* str)<br>{<!-- --><br>   int k = 0;<br>   while (*str != '/0')<br>   {<!-- --><br>      k = k * 10 + *s++ - '0';<br>   }<br>   return k;<br>} <br>6)在文件(调用库函数创建的,不用考虑数据库的方式)中读入信息(包括职工号,职工产量) </p> 
<p>.根据输入的信息(包括职工号,职工产量)..检测是否有相同的职工号记录,如有,则增加其 </p> 
<p>产量.如没有,则创建新的记录.最后的记录排序的依据是职工产量(降序),如果产量相同,则 </p> 
<p>按职工号(升序). (具体的题目记不太清了,这个题目有点长.哪位也去笔试了.请修正一下 </p> 
<p>子) <br>. <br>2.面试 <br>1)找出两个中文句子的相似度.(例如"中国江苏南京" "江苏省中国南京市".实际上是指的 </p> 
<p>同一个地方.面试官的要求是一分钟给出求相似度的算法.)(幸好听老师讲过中文分词,要不 </p> 
<p>然当场就挂了) <br>2)写出二分查找的代码. <br>3)将上述代码通用化.(在 C 的规范内.就是我前面所的那个问题) <br>4)写出在母串中查找子串出现次数的代码.(不顾及效率时好说.当时一不留神把 KMP 说了 </p> 
<p>出来,结果又让我描述整个过程.汗..只好从头又学了.不过没有冷场,边学边说.hoho) <br>5)如何看待在函数中定义很多静态变量. <br>6)写出quick_sort <br>7)写出查找从一个集合中输出所有子集合的算法. <br>8)有关于各种类型指针.各种数据类型的 sizeof 运算结果( 在 C 中) </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/828ba2e5c55e2a3f5e115f5d05b5d3b6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">银河麒麟服务器操作系统2.0 BEA Platform MySQL JDK Tomcat实战</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ed8190f56fab8d8ab7876824235e64b4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">轻松为Windows配置多个网关</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>