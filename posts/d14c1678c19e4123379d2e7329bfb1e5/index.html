<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数字图像处理之均值滤波，高斯滤波，中值滤波，双边滤波 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数字图像处理之均值滤波，高斯滤波，中值滤波，双边滤波" />
<meta property="og:description" content="滤波器作为图像处理课程的重要内容，大致可分为两类，空域滤波器和频率域滤波器。本文主要介绍常用的四种滤波器：中值滤波器、均值滤波器、高斯滤波器、双边滤波器，并基于opencv做出实现。空域的滤波器一般可以通过模板对原图像进行卷积进行，卷积的相关知识请自行学习。
理论知识： 线性滤波器表达公式：，其中均值滤波器和高斯滤波器属于线性滤波器，首先看这两种滤波器
均值滤波器：
模板：
从待处理图像首元素开始用模板对原始图像进行卷积，均值滤波直观地理解就是用相邻元素灰度值的平均值代替该元素的灰度值。
高斯滤波器：
模板：通过高斯内核函数产生的
高斯内核函数：
例如3*3的高斯内核模板：
中值滤波：同样是空间域的滤波，主题思想是取相邻像素的点，然后对相邻像素的点进行排序，取中点的灰度值作为该像素点的灰度值。
双边滤波：
C&#43;&#43;代码实现： static void exchange(int&amp; a, int&amp; b) {	int t = 0; t = a; a = b; b = t; } static void bubble_sort(int* K, int lenth) { for (int i = 0; i &lt; lenth; i&#43;&#43;) for (int j = i &#43; 1; j &lt; lenth; j&#43;&#43;) { if (K[i]&gt;K[j]) exchange(K[i], K[j]); } } ///产生二维的高斯内核 static cv::Mat generate_gassian_kernel(double u, double sigma, cv::Size size) { int width = size." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/d14c1678c19e4123379d2e7329bfb1e5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-10-28T18:45:23+08:00" />
<meta property="article:modified_time" content="2017-10-28T18:45:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数字图像处理之均值滤波，高斯滤波，中值滤波，双边滤波</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>滤波器作为图像处理课程的重要内容，大致可分为两类，空域滤波器和频率域滤波器。本文主要介绍常用的四种滤波器：中值滤波器、均值滤波器、高斯滤波器、双边滤波器，并基于opencv做出实现。空域的滤波器一般可以通过模板对原图像进行卷积进行，卷积的相关知识请自行学习。</p> 
<h3><strong>理论知识：</strong></h3> 
<p>线性滤波器表达公式：<img src="https://images2.imgbox.com/32/66/SBPZZLSt_o.png" alt="">，其中均值滤波器和高斯滤波器属于线性滤波器，首先看这两种滤波器</p> 
<p>均值滤波器：</p> 
<p>模板：</p> 
<p><img src="https://images2.imgbox.com/a6/df/qgGnZ7iM_o.png" alt=""></p> 
<p></p> 
<p>从待处理图像首元素开始用模板对原始图像进行卷积，均值滤波直观地理解就是用相邻元素灰度值的平均值代替该元素的灰度值。</p> 
<p>高斯滤波器：</p> 
<p>模板：通过高斯内核函数产生的</p> 
<p>高斯内核函数：<img src="https://images2.imgbox.com/dd/bb/tiAwY9LP_o.png" alt=""></p> 
<p>例如3*3的高斯内核模板：</p> 
<p><img src="https://images2.imgbox.com/64/46/7VguaLfY_o.png" alt=""><br> </p> 
<p></p> 
<p>中值滤波：同样是空间域的滤波，主题思想是取相邻像素的点，然后对相邻像素的点进行排序，取中点的灰度值作为该像素点的灰度值。</p> 
<p>双边滤波：</p> 
<p><img src="https://images2.imgbox.com/cb/68/VCVctqhY_o.png" alt=""><br> </p> 
<p></p> 
<h3><strong>C++代码实现：</strong></h3> 
<p></p> 
<p></p> 
<pre><code class="language-cpp">static void exchange(int&amp; a, int&amp; b)
{	
	int t = 0;
	t = a;
	a = b;
	b = t;
}

static void bubble_sort(int* K, int lenth)
{
	for (int i = 0; i &lt; lenth; i++)
		for (int j = i + 1; j &lt; lenth; j++)
		{
			if (K[i]&gt;K[j])
				exchange(K[i], K[j]);
		}
}
///产生二维的高斯内核
static cv::Mat generate_gassian_kernel(double u, double sigma, cv::Size size)
{
	int width = size.width;
	int height = size.height;
	cv::Mat gassian_kernel(cv::Size(width, height), CV_64FC1);
	double sum = 0;
	double sum_sum = 0;
	for (int i = 0; i &lt; width; i++)
		for (int j = 0; j &lt; height; j++)
		{
			sum = 1.0 / 2.0 / CV_PI / sigma / sigma * exp(-1.0 * ((i - width / 2)*(i - width / 2) + (j - width / 2)*(j - width / 2)) / 2.0 / sigma / sigma);
			sum_sum += sum;
			gassian_kernel.ptr&lt;double&gt;(i)[j] = sum;
		}
	for (int i = 0; i &lt; width; i++)
		for (int j = 0; j &lt; height; j++)
		{
			gassian_kernel.ptr&lt;double&gt;(i)[j] /= sum_sum;
		}
	return gassian_kernel;
}
///均值滤波
void lmt_main_blur(cv::Mat&amp; img_in, cv::Mat&amp; img_out, int kernel_size)
{
	img_out = img_in.clone();
	cv::Mat mat1;
	cv::copyMakeBorder(img_in, mat1, kernel_size, kernel_size, kernel_size, kernel_size, cv::BORDER_REPLICATE);

	int cols = mat1.cols;
	int rows = mat1.rows;
	int channels = img_out.channels();
	const uchar* const pt = mat1.ptr&lt;uchar&gt;(0);
	uchar* pt_out = img_out.ptr&lt;uchar&gt;(0);

	for (int i = kernel_size; i &lt; rows - kernel_size; i++)
	{
		for (int j = kernel_size; j &lt; cols - kernel_size; j++)
		{
			if (channels == 1)
			{
				long long int sum_pixel = 0;
				for (int m = -1 * kernel_size; m &lt; kernel_size; m++)
					for (int n = -1 * kernel_size; n &lt; kernel_size; n++)
					{
						sum_pixel += pt[(i + m)*cols + (j + n)];
					}
				img_out.ptr&lt;uchar&gt;(i - kernel_size)[j - kernel_size] = (double)sum_pixel / (kernel_size*kernel_size * 4);
			}
			else if (channels == 3)
			{
				long long int sum_pixel = 0;
				long long int sum_pixel1 = 0;
				long long int sum_pixel2 = 0;
				for (int m = -1 * kernel_size; m &lt; kernel_size; m++)
					for (int n = -1 * kernel_size; n &lt; kernel_size; n++)
					{
						sum_pixel += pt[((i + m)*cols + (j + n))*channels + 0];
						sum_pixel1 += pt[((i + m)*cols + (j + n))*channels + 1];
						sum_pixel2 += pt[((i + m)*cols + (j + n))*channels + 2];
					}
				img_out.ptr&lt;uchar&gt;(i - kernel_size)[(j - kernel_size)*channels + 0] = (double)sum_pixel / (double)(kernel_size*kernel_size * 4);
				img_out.ptr&lt;uchar&gt;(i - kernel_size)[(j - kernel_size)*channels + 1] = (double)sum_pixel1 / (double)(kernel_size*kernel_size * 4);
				img_out.ptr&lt;uchar&gt;(i - kernel_size)[(j - kernel_size)*channels + 2] = (double)sum_pixel2 / (double)(kernel_size*kernel_size * 4);
			}
		}
	}

}
///中值滤波
void lmt_median_blur(cv::Mat&amp; img_in, cv::Mat&amp; img_out, int kernel_size)
{
	img_out = img_in.clone();
	cv::Mat mat1;
	cv::copyMakeBorder(img_in, mat1, kernel_size, kernel_size, kernel_size, kernel_size, cv::BORDER_REPLICATE);

	int cols = mat1.cols;
	int rows = mat1.rows;
	int channels = img_out.channels();

	cv::Mat mat[3];
	cv::Mat mat_out[3];
	cv::split(mat1, mat);
	cv::split(img_out, mat_out);
	for (int k = 0; k &lt; 3; k++)
	{
		const uchar* const pt = mat[k].ptr&lt;uchar&gt;(0);
		uchar* pt_out = mat_out[k].ptr&lt;uchar&gt;(0);
		for (int i = kernel_size; i &lt; rows - kernel_size; i++)
		{
			for (int j = kernel_size; j &lt; cols - kernel_size; j++)
			{
				long long int sum_pixel = 0;
				int* K = new int[kernel_size*kernel_size * 4];
				int ker_num = 0;
				for (int m = -1 * kernel_size; m &lt; kernel_size; m++)
					for (int n = -1 * kernel_size; n &lt; kernel_size; n++)
					{
						K[ker_num] = pt[(i + m)*cols + (j + n)];
						ker_num++;
					}
				bubble_sort(K, ker_num);
				mat_out[k].ptr&lt;uchar&gt;(i - kernel_size)[j - kernel_size] = K[ker_num / 2];
			}
		}
	}
	cv::merge(mat_out, 3, img_out);
}
///高斯滤波
void lmt_gaussian_blur(cv::Mat&amp; img_src, cv::Mat&amp; img_dst, cv::Size kernel_size)
{
	img_dst = cv::Mat(cv::Size(img_src.cols, img_src.rows), img_src.type());
	int cols = img_src.cols;
	int rows = img_src.rows;
	int channels = img_src.channels();
	cv::Mat gassian_kernel = generate_gassian_kernel(0, 1, kernel_size);
	int width = kernel_size.width / 2;
	int height = kernel_size.height / 2;
	for (int i = height; i &lt; rows - height; i++)
	{
		for (int j = width; j &lt; cols - width; j++)
		{
			for (int k = 0; k &lt; channels; k++)
			{
				double sum = 0.0;
				for (int m = -height; m &lt;= height; m++)
				{
					for (int n = -width; n &lt;= width; n++)
					{
						sum += (double)(img_src.ptr&lt;uchar&gt;(i + m)[(j + n)*channels + k]) * gassian_kernel.ptr&lt;double&gt;(height + m)[width + n];
					}
				}
				if (sum &gt; 255.0)
					sum = 255;
				if (sum &lt; 0.0)
					sum = 0;
				img_dst.ptr&lt;uchar&gt;(i)[j*channels + k] = (uchar)sum;
			}
		}
	}

	
}
///双边滤波
void lmt_bilateral_filter(cv::Mat&amp; img_in, cv::Mat&amp; img_out, const int r, double sigma_d, double sigma_r)
{
	int i, j, m, n, k;
	int nx = img_in.cols, ny = img_in.rows, m_nChannels = img_in.channels();
	const int w_filter = 2 * r + 1; // 滤波器边长  

	double gaussian_d_coeff = -0.5 / (sigma_d * sigma_d);
	double gaussian_r_coeff = -0.5 / (sigma_r * sigma_r);
	double  **d_metrix = new double *[w_filter];
	for (int i = 0; i &lt; w_filter; ++i)
		d_metrix[i] = new double[w_filter];
	
	double r_metrix[256];  // similarity weight  
	img_out = cv::Mat(img_in.size(),img_in.type());
	uchar* m_imgData = img_in.ptr&lt;uchar&gt;(0);
	uchar* m_img_outData = img_out.ptr&lt;uchar&gt;(0);
	// copy the original image  
	double* img_tmp = new double[m_nChannels * nx * ny];
	for (i = 0; i &lt; ny; i++)
		for (j = 0; j &lt; nx; j++)
			for (k = 0; k &lt; m_nChannels; k++)
			{
				img_tmp[i * m_nChannels * nx + m_nChannels * j + k] = m_imgData[i * m_nChannels * nx + m_nChannels * j + k];
			}

	// compute spatial weight  
	for (i = -r; i &lt;= r; i++)
		for (j = -r; j &lt;= r; j++)
		{
			int x = j + r;
			int y = i + r;

			d_metrix[y][x] = exp((i * i + j * j) * gaussian_d_coeff);
		}

	// compute similarity weight  
	for (i = 0; i &lt; 256; i++)
	{
		r_metrix[i] = exp(i * i * gaussian_r_coeff);
	}

	// bilateral filter  
	for (i = 0; i &lt; ny; i++)
		for (j = 0; j &lt; nx; j++)
		{
			for (k = 0; k &lt; m_nChannels; k++)
			{
				double weight_sum, pixcel_sum;
				weight_sum = pixcel_sum = 0.0;

				for (m = -r; m &lt;= r; m++)
					for (n = -r; n &lt;= r; n++)
					{
						if (m*m + n*n &gt; r*r) continue;

						int x_tmp = j + n;
						int y_tmp = i + m;

						x_tmp = x_tmp &lt; 0 ? 0 : x_tmp;
						x_tmp = x_tmp &gt; nx - 1 ? nx - 1 : x_tmp;   // 边界处理，replicate  
						y_tmp = y_tmp &lt; 0 ? 0 : y_tmp;
						y_tmp = y_tmp &gt; ny - 1 ? ny - 1 : y_tmp;

						int pixcel_dif = (int)abs(img_tmp[y_tmp * m_nChannels * nx + m_nChannels * x_tmp + k] - img_tmp[i * m_nChannels * nx + m_nChannels * j + k]);
						double weight_tmp = d_metrix[m + r][n + r] * r_metrix[pixcel_dif];  // 复合权重  

						pixcel_sum += img_tmp[y_tmp * m_nChannels * nx + m_nChannels * x_tmp + k] * weight_tmp;
						weight_sum += weight_tmp;
					}

				pixcel_sum = pixcel_sum / weight_sum;
				m_img_outData[i * m_nChannels * nx + m_nChannels * j + k] = (uchar)pixcel_sum;

			} // 一个通道  

		} // END ALL LOOP  
	for (i = 0; i &lt; w_filter; i++)
		delete[] d_metrix[i];
	delete[] d_metrix;
}
</code></pre> 
<br> 
<p></p> 
<h3><strong>Opencv API函数实现：</strong></h3> 
<p></p> 
<p align="left">opencv相关函数简介：</p> 
<p align="left">双边滤波函数：bilateralFilter(InputArray src, OutputArray dst, int d, double sigmaColor, double sigmaSpace,int borderType=BORDER_DEFAULT )</p> 
<p align="left">   src待滤波图像 </p> 
<p align="left">   dst滤波后图像 </p> 
<p align="left">   d滤波器半径 </p> 
<p align="left">   sigmaColor滤波器值域的sigma </p> 
<p align="left">   sigmaSpace滤波器空间域的sigma </p> 
<p align="left">   borderType边缘填充方式 BORDER_REPLICATE BORDER_REFLECT BORDER_DEFAULT BORDER_REFLECT_101BORDER_TRANSPARENT BORDER_ISOLATED</p> 
<p align="left"> </p> 
<p align="left">均值滤波函数：blur(InputArray src, OutputArray dst, Size ksize, Point anchor=Point(-1,-1), intborderType=BORDER_DEFAULT );</p> 
<p align="left">   src待滤波图像</p> 
<p align="left">   dst滤波后图像</p> 
<p align="left">   ksize 均值滤波器的大小</p> 
<p align="left">   anchor均值滤波器的锚点也就是模板移动点</p> 
<p align="left">   borderType边缘填充方式 BORDER_REPLICATE BORDER_REFLECT BORDER_DEFAULT BORDER_REFLECT_101BORDER_TRANSPARENT BORDER_ISOLATED</p> 
<p align="left"> </p> 
<p align="left">高斯滤波函数：GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY=0,int borderType=BORDER_DEFAULT );</p> 
<p align="left">   src待滤波图像</p> 
<p align="left">   dst滤波后图像</p> 
<p align="left">   ksize 高斯滤波器的大小</p> 
<p align="left">   sigmaX 高斯滤波器的x方向的滤波器高斯sigma</p> 
<p align="left">   sigmaY 高斯滤波器的y方向的滤波器高斯sigma</p> 
<p align="left">   borderType边缘填充方式 BORDER_REPLICATE BORDER_REFLECT BORDER_DEFAULT BORDER_REFLECT_101BORDER_TRANSPARENT BORDER_ISOLATED</p> 
<p align="left"> </p> 
<p align="left">中值滤波函数：medianBlur(InputArray src, OutputArray dst, int ksize );</p> 
<p align="left">    src待滤波图像</p> 
<p align="left">    dst滤波后图像</p> 
<p>    ksize 中值滤波器的大小</p> 
<p>函数演示：</p> 
<pre><code class="language-cpp">void bilateral_filter_show(void)
{
	cv::Mat mat1 = cv::imread("F:\\CVlibrary\\obama.jpg", CV_LOAD_IMAGE_GRAYSCALE); //灰度图加载进来，BGR-&gt;HSV 然后取H参数
	if (mat1.empty())
		return;
	cv::imshow("原图像", mat1); 
	cv::Mat src = cv::imread("F:\\CVlibrary\\obama.jpg");
	cv::imshow("原始彩色图像", src);
	std::cout &lt;&lt; "channel = " &lt;&lt; mat1.channels() &lt;&lt; std::endl;
	
	cv::Mat mat3;
	cv::bilateralFilter(src, mat3, 5, 50, 50,cv::BORDER_DEFAULT);
	cv::imshow("opencv给出的双边滤波器", mat3);
	cv::Mat mat4;
	cv::blur(src, mat4, cv::Size(3, 3));
	cv::imshow("均值滤波", mat4);
	cv::Mat mat5;
	cv::GaussianBlur(src, mat5, cv::Size(5, 5), 1,1);
	cv::imshow("高斯滤波器", mat5);
	cv::Mat mat6;
	cv::medianBlur(src, mat6, 3);
	cv::imshow("中值滤波", mat6); 
	cv::Mat mat7;
	lmt_gaussian_blur(src, mat7, cv::Size(5, 5));
	cv::imshow("my gaussian image",mat7);

	cv::waitKey(0);
}
</code></pre> 
<br> 
<br> 
<p><br> </p> 
<p><br> </p> 
<p><br> </p> 
<p><br> </p> 
<p><br> </p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0598308b9386fca658b38cccee9c9ac4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java中jsp的八大隐式对象</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9e09dba53e8ffb7078cd8ae1aafa094a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">第一周周总结</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>