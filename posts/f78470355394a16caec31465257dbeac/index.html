<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Boost 15 进程间通信 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Boost 15 进程间通信" />
<meta property="og:description" content="1. 介绍 Boost.Interprocess库简化了使用通用的进程间通信和同步机制。并且提供这些机制的部件：
* 共享内存
* 内存映射文件
* 信号量，互斥量，条件变量和可升级的互斥量类型，该类型可以放入共享内存和内存映射文件中
* 命名版本的同步对象
* 文件锁
* 相对指针
* 消息队列
Boost.Interprocess还提供了更高级的进程间机制，用于动态分配共享内存或者内存映射文件。：
* 在共享内存或者文件映射中动态创建匿名或者命名对象。
* 与共享内存或者文件映射兼容的类似STL的容器
* 可在共享内存和文件映射中使用的类似STL的分配器，类似内存池。
1.1. 构建Boost.Interprocess 没必要编译Boost.Interprocess，因为都是头文件。只需要添加Boost头文件目录到你的编译器包含路径中。
Boost.Interprocess依赖于Boost.DateTime库，但是该库是需要编译的。
1.2. 测试过的编译器 2. 快速试用 2.1. 将共享内存作为无名内存块池使用 你只需要分配共享内存段的一部分，拷贝消息到该缓冲区中，发送该内存部分的偏移给另外进程，然后就完成了。让我们看看例子：
#include &lt;boost/interprocess/managed_shared_memory.hpp&gt; #include &lt;cstdlib&gt; #include &lt;sstream&gt; int main( int argc,char* argv[]){ using namespace boost::interprocess; if( argc==1 ){ // 父进程 struct shm_remove{ shm_remove(){ shared_memory_object::remove(“MySharedMemory”);} ~shm_remove(){ shared_memory_object::remove(“MySharedMemory”); } }remover; // 创建一个被管的共享内存段 managed_shared_memory segment(create_only,”MySharedMemory”,65536); // 分配段的一部分（原始内存） managed_shared_memory::size_type free_memory = segment." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f78470355394a16caec31465257dbeac/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-07-15T09:41:09+08:00" />
<meta property="article:modified_time" content="2016-07-15T09:41:09+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Boost 15 进程间通信</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>1. <strong>介绍</strong></h2> 
<p>Boost.Interprocess库简化了使用通用的进程间通信和同步机制。并且提供这些机制的部件：</p> 
<p> * 共享内存</p> 
<p> * 内存映射文件</p> 
<p> * 信号量，互斥量，条件变量和可升级的互斥量类型，该类型可以放入共享内存和内存映射文件中</p> 
<p> * 命名版本的同步对象</p> 
<p> * 文件锁</p> 
<p> * 相对指针</p> 
<p> * 消息队列</p> 
<p> </p> 
<p>Boost.Interprocess还提供了更高级的进程间机制，用于动态分配共享内存或者内存映射文件。：</p> 
<p> * 在共享内存或者文件映射中动态创建匿名或者命名对象。</p> 
<p> * 与共享内存或者文件映射兼容的类似STL的容器</p> 
<p> * 可在共享内存和文件映射中使用的类似STL的分配器，类似内存池。</p> 
<p> </p> 
<h3>1.1. <strong>构建Boost.Interprocess</strong></h3> 
<p>没必要编译Boost.Interprocess，因为都是头文件。只需要添加Boost头文件目录到你的编译器包含路径中。</p> 
<p>Boost.Interprocess依赖于Boost.DateTime库，但是该库是需要编译的。</p> 
<p> </p> 
<h3>1.2. <strong>测试过的编译器</strong></h3> 
<p> </p> 
<h2>2. <strong>快速试用</strong></h2> 
<h3>2.1. <strong>将共享内存作为无名内存块池使用</strong></h3> 
<p>你只需要分配共享内存段的一部分，拷贝消息到该缓冲区中，发送该内存部分的偏移给另外进程，然后就完成了。让我们看看例子：</p> 
<pre class="has"><code class="language-cpp">#include &lt;boost/interprocess/managed_shared_memory.hpp&gt;
#include &lt;cstdlib&gt;
#include &lt;sstream&gt;


int main( int argc,char* argv[]){
    using namespace boost::interprocess;

    if( argc==1 ){ // 父进程
        struct shm_remove{
            shm_remove(){ shared_memory_object::remove(“MySharedMemory”);}

            ~shm_remove(){ shared_memory_object::remove(“MySharedMemory”); }
        }remover;

        // 创建一个被管的共享内存段
        managed_shared_memory segment(create_only,”MySharedMemory”,65536);

        // 分配段的一部分（原始内存）
        managed_shared_memory::size_type free_memory = segment.get_free_memory();
        void* shptr = segment.allocate(1024/*分配的字节数*/);

        // 检测是否没变
        if( free_memory &lt;= segment.get_free_memory() )
            return 1;

        // 从地址获取到的handle可以标识任何字节的共享内存段，即使它们被映射到不同内存空间
        managed_shared_memory::handle_t handle = segment.get_handle_from_address( shptr );

        std::stringstream s;
        s &lt;&lt; argv[0] &lt;&lt;” “&lt;&lt; handle;
        s &lt;&lt; std::ends;

        // 启动子进程
        if( 0!-std::system(s.str().c_str()) )
            return 1;

        // 检测被释放的内存
        if( free_memory != segment.get_free_memory() )
            return 1;
    }else{
        // 子进程中打开被管理的段
        managed_share_memory segment(open_only,”MySharedMemory”);
        managed_shared_memory::handle_t handle = 0;

        std::stringstream s;
        s &lt;&lt; argv[1];
        s &gt;&gt; handle;

        // 通过handle获取缓冲区地址
        void * msg = segment.get_address_from_handle( handle );

        // 释放父进程分配的内存
        segment.deallocate(msg);
    }
    return 0;
}</code></pre> 
<h3>2.2. <strong>创建命名共享内存对象</strong></h3> 
<p>用户希望创建共享内存段对象，指定对象的名字。这样另外的进程可以找到它们，并且删除。代码如下：</p> 
<p> </p> 
<p>#include &lt;boost/interprocess/managed_shared_memory.hpp&gt;</p> 
<p>#include &lt;cstdlib&gt;</p> 
<p>#include &lt;cstddef&gt;</p> 
<p>#include &lt;cassert&gt;</p> 
<p>#include &lt;utility&gt;</p> 
<p> </p> 
<p>int main( int argc,char* argv[] )</p> 
<p>{<!-- --></p> 
<p>using namespace boost::interprocess;</p> 
<p>typedef std::pair&lt;double,int&gt; MyType;</p> 
<p> </p> 
<p>if( argc==1){<!-- --></p> 
<p>// 父进程</p> 
<p>// 在构造函数和析构函数中移除共享内存</p> 
<p>struct shm_remove{<!-- --></p> 
<p>shm_remove(){ shared_memory_object::remove(“MySharedMemory”); }</p> 
<p>~shm_remove(){ shared_memory_object::remove( “MySharedMemory”）；}</p> 
<p>} remover;</p> 
<p> </p> 
<p>// 构造被管理的共享内存</p> 
<p>managed_shared_memory segment( create_only,”MysharedMemory”,65536 );</p> 
<p> </p> 
<p>// 创建一个MyType的对象初始化为(0.0, 0)</p> 
<p>MyType* instance = segment.construct&lt;MyType&gt;</p> 
<p>(“MyType instance”) // 对象名</p> 
<p>( 0.0, 0 ); // 构造函数参数</p> 
<p> </p> 
<p>// 创建一个数组有10个元素，并都初始化为(0.0, 0 )</p> 
<p>MyType* array = segment.construct&lt;MyType&gt;</p> 
<p>(“MyType array”)</p> 
<p>[10]</p> 
<p>(0.0, 0);</p> 
<p> </p> 
<p>// 构造一个有3个元素的数组</p> 
<p>float float_initializer[3] = { 0.0, 1.0, 2.0 };</p> 
<p>int int_initializer[3] = { 0, 1, 2 };</p> 
<p> </p> 
<p>MyType * array_it = segment.construct_it&lt;MyType&gt;</p> 
<p>(“MyType array from it”) // 对象名称</p> 
<p>[3] // 元素个数</p> 
<p>( &amp;float_initializer[0],&amp;int_initializer[0] ); // 初始化参数</p> 
<p> </p> 
<p>// 启动子进程</p> 
<p>std::string s( argv[0] );</p> 
<p>s += “ child ”;</p> 
<p>if( 0!=std::system(s.c_str()));</p> 
<p>return 1;</p> 
<p> </p> 
<p>// 检测子进程是否清除掉所有对象</p> 
<p>if( segment.find&lt;MyType&gt;(“MyType array”).first ||</p> 
<p>segment.find&lt;MyType&gt;(“MyType instance”).first ||</p> 
<p>segment.find&lt;MyType&gt;(“MyType array from it”).first )</p> 
<p>return 1;</p> 
<p>}else{<!-- --></p> 
<p>// 子进程</p> 
<p>// 打开共享内存</p> 
<p>managed_shared_memory segment( Open_only, “MySharedMemory”);</p> 
<p> </p> 
<p>std::pair&lt;MyType*,managed_shared_memory::size_type&gt; res;</p> 
<p> </p> 
<p>// 查找数组</p> 
<p>res = segment.find&lt;MyType&gt;(“MyType array”);</p> 
<p>// 长度应该为10</p> 
<p>if( res.second!=10)</p> 
<p>return 1;</p> 
<p> </p> 
<p>// 查找对象</p> 
<p>res = segment.find&lt;MyType&gt;(“MyType instance”);</p> 
<p>if( res.second != 1 )</p> 
<p>return 1;</p> 
<p> </p> 
<p>// 查找由迭代器构建的数组</p> 
<p>res = segment.find&lt;MyType&gt;(“MyType array from it”);</p> 
<p>if( res.second != 3 )</p> 
<p>return 1;</p> 
<p> </p> 
<p>// 都找到了，删除所有对象</p> 
<p>segment.destroy&lt;MyType&gt;(“MyType array”);</p> 
<p>segment.destroy&lt;MyType&gt;(“MyType instance”);</p> 
<p>segment.destroy&lt;MyType&gt;(“MyType array from it”);</p> 
<p>}</p> 
<p> </p> 
<p>return 0;</p> 
<p>}</p> 
<p> </p> 
<h3>2.3. <strong>使用共享内存的偏移精灵指针</strong></h3> 
<p>Boost.Interprocess提供了offset_ptr精灵指针族，保存有该存储区内该指针的地址偏移。</p> 
<p> </p> 
<p>#include &lt;boost/interprocess/managed_shared_memory.hpp&gt;</p> 
<p>#include &lt;boost/interprocess/offset_ptr.hpp&gt;</p> 
<p> </p> 
<p>using namespace boost::interprocess;</p> 
<p> </p> 
<p>// 共享内存链表节点</p> 
<p>struct list_node{<!-- --></p> 
<p>offset_ptr&lt;list_node&gt; next;</p> 
<p>int value;</p> 
<p>}</p> 
<p> </p> 
<p>int main(){<!-- --></p> 
<p>// 删除共享内存</p> 
<p>struct shm_remove{<!-- --></p> 
<p>shm_remove(){ shared_memory_object::remove(“MySharedMemory”);}</p> 
<p>~shm_remove(){ shared_memory_object::remove(“MySharedMemory”); }</p> 
<p>} remover;</p> 
<p> </p> 
<p>// 创建共享内存</p> 
<p>managed_shared_memory segment( create_only,”MySharedMemory”,65536);</p> 
<p> </p> 
<p>// 在共享内存中创建10个元素的链表</p> 
<p>offset_ptr&lt;list_node&gt; prev = 0, current, first;</p> 
<p> </p> 
<p>int i;</p> 
<p>for( i=0; i&lt;10;++i, prev = current ){<!-- --></p> 
<p>current = static_cast&lt;list_node*&gt;(segment.allocate(sizeof(list_node)));</p> 
<p>current-&gt;value = i;</p> 
<p>current-&gt;next = 0;</p> 
<p>if( !prev )</p> 
<p>first = current;</p> 
<p>else</p> 
<p>prev-&gt;next = current;</p> 
<p>}</p> 
<p> </p> 
<p>// 与其他进程通信</p> 
<p>// ...</p> 
<p>// 结束后，销毁链表</p> 
<p>for( current = first; current; /**/ ){<!-- --></p> 
<p>prev = current;</p> 
<p>current = current-&gt;next;</p> 
<p>segment.deallocate(prev.get());</p> 
<p>}</p> 
<p> </p> 
<p>return 0;</p> 
<p>}</p> 
<p> </p> 
<p>为了帮助基本数据结构，Boost.Interprocess提供了容器，类似vector,list,map。所有用户应该避免使用手工数据结构，只需要像标准容器一样。</p> 
<h3>2.4. <strong>在共享内存中创建vector</strong></h3> 
<p>Boost.Interprocess允许在共享内存和内存映射文件中创建复杂的对象。例如：可以在共享内存中创建类似STL的容器。要实现这样的功能，我们只需要创建一个特殊的共享内存段，声明一个Boost.Interprocess分配器和构造向量。</p> 
<p>在共享内存中允许构造复杂结构的类是boost::interprocess::managed_shared_memory.</p> 
<p> </p> 
<p>#include &lt;boosst/interprocess/managed_shared_memory.hpp&gt;</p> 
<p>#include &lt;boost/interprocess/containers/vector.hpp&gt;</p> 
<p>#include &lt;boost/imterprocess/allocators/allocator.hpp&gt;</p> 
<p>#include &lt;string&gt;</p> 
<p>#include &lt;cstdlib&gt;</p> 
<p> </p> 
<p>using namespace boost::interprocess;</p> 
<p> </p> 
<p>// 定义一个STL兼容的分配器，从managed_shared_memory中分配整型。</p> 
<p>// 这个分配器允许放置容器到段里</p> 
<p>typedef allocator&lt;int,managed_shared_memory::segment_manager&gt; ShmemAllocator;</p> 
<p> </p> 
<p>typedef vector&lt;int, ShemAllocator&gt; MyVector;</p> 
<p> </p> 
<p>// 主函数，argc==1运行父进程，argc==2运行子进程</p> 
<p>int main( int argc,char* argv[] ){<!-- --></p> 
<p>if( argc==1 ){ // 父进程</p> 
<p>struct shm_remove{<!-- --></p> 
<p>shm_remove(){ shared_memory_object::remove(“MySharedMemory”); }</p> 
<p>~shm_remove(){ shared_memory_object::remove(“MySharedMemory”); }</p> 
<p>} remover;</p> 
<p> </p> 
<p>managed_shared_memory segment(create_only,”MySharedMemory”,65536);</p> 
<p> </p> 
<p>// 初始化共享内存STL兼容分配器</p> 
<p>const ShmemAllocator alloc_ins( segment.get_segment_manager() );</p> 
<p> </p> 
<p>// 构造一个向量，命名为MyVector</p> 
<p>MyVector * myvector = segment.construct&lt;MyVector&gt;(“MyVector”)(alloc_inst);</p> 
<p> </p> 
<p>for( int i=0;i&lt;100;++i )</p> 
<p>myvector-&gt;push_back(i);</p> 
<p> </p> 
<p>std::string s(argv[0]);</p> 
<p>s += “child”;</p> 
<p>if( 0!= std::system( s.c_str()))</p> 
<p>return 1;</p> 
<p> </p> 
<p>if( segment.find&lt;MyVector&gt;(“MyVector”).first )</p> 
<p>return 1;</p> 
<p>}else{ // 子进程</p> 
<p>managed_shared_memory segment(open_only,”MySharedMemory”));</p> 
<p> </p> 
<p>MyVector* myvecor = segment.find&lt;MyVector&gt;(“MyVector”).first;</p> 
<p> </p> 
<p>std::sort(myvector-&gt;rbegin(),myvector-&gt;rend));</p> 
<p> </p> 
<p>segment.destory&lt;MyVector&gt;(“MyVector”);</p> 
<p>}</p> 
<p>return 0;</p> 
<p>}</p> 
<p> </p> 
<p>The parent process will create an special shared memory class that allows easy construction of many complex data structures associated with a name. The parent process executes the same program with an additional argument so the child process opens the shared memory and uses the vector and erases it.</p> 
<h3>2.5. <strong>在共享内存中创建map</strong></h3> 
<p> </p> 
<p>#include &lt;boost/interprocess/managed_shared_memory.hpp&gt;</p> 
<p>#include &lt;boost/interprocess/containers/map.hpp&gt;</p> 
<p>#include &lt;boost/interprocess/allocators/allocator.hpp&gt;</p> 
<p>#include &lt;functional&gt;</p> 
<p>#include &lt;utility&gt;</p> 
<p> </p> 
<p>int main(){<!-- --></p> 
<p>using namespace boost::interprocess;</p> 
<p> </p> 
<p>struct shm_remove{<!-- --></p> 
<p><a name="OLE_LINK1"></a>shm_remove(){ shared_memory_object::remove(“MySharedMemory”); }</p> 
<p>~shm_remove(){ shared_memory_object::remove(“MySharedMemory”); }</p> 
<p>} remover;</p> 
<p> </p> 
<p>managed_shared_memory segment( create_only, “MySharedMemory”,65536);</p> 
<p> </p> 
<p>typedef int KeyType;</p> 
<p>typedef float MappedType;</p> 
<p>typedef std::pair&lt;const int,float&gt; ValueType;</p> 
<p> </p> 
<p>typedef allocator&lt;ValueType,managed_shared_memory::segment_manager&gt; ShmemAllocator;</p> 
<p> </p> 
<p>typedef map&lt;KeyType,MappedType,std::less&lt;KeyType&gt;, ShmemAllocator&gt; MyMap;</p> 
<p> </p> 
<p>ShmemAllocator alloc_inst( segment.get_segment_manager() );</p> 
<p> </p> 
<p>MyMap * mymap = segment.construct&lt;MyMap&gt;(“MyMap”)</p> 
<p>(std::less&lt;int&gt;(),</p> 
<p>alloc_inst);</p> 
<p> </p> 
<p>for( int i=0;i&lt;100;++i ){<!-- --></p> 
<p>mymap-&gt;insert( std::pair&lt;const int,float&gt;(i,(float)i);</p> 
<p>}</p> 
<p>return 0;</p> 
<p>}</p> 
<p> </p> 
<h2>3. <strong>基本说明</strong></h2> 
<p> </p> 
<h3>3.1. <strong>进程和线程</strong></h3> 
<p>Boost.Interprocess不仅工作在进程间，也工作在线程间。Boost.Interprocess的同步机制可以在不同进程的线程之间同步，也可以在相同进程的不同线程间同步。</p> 
<h3>3.2. <strong>进程间共享信息</strong></h3> 
<p>在传统的编程模式中，一个操作系统有多个进程运行在其自身的地址空间内。想要共享信息时，我们有一些可以替代的方法：</p> 
<p>l 两个进程使用一个文件共享信息。要访问数据，每个进程使用文件的读写机制。当更新或读取共享文件时，我们需要一些机制来同步，将读进程从写进程中保护起来。</p> 
<p>l 两个进程共享驻留在操作系统内核中的信息。这正是，例如，传统的消息队列。同步由操作系统内核保证。</p> 
<p>l 两个进程可以共享一个内存区间。这正是经典的共享内存或者内存映射文件机制。一旦进程设置好内存区域，进程就可以像其他内存段一样读写数据，而不需要调用内核。这种操作也需要在进程间手工同步。</p> 
<p> </p> 
<h3>3.3. <strong>Interprocess机制的持久性</strong></h3> 
<p>进程间通信机制的最重大的议题之一是进程间通信机制的生命期。明白进程间通信机制什么时候从系统中消失是很重要的。在Boost.Interprocess中，我们有3中持久性：</p> 
<p>l 进程范围的持久性。这种机制持续到所有打开它的进程关闭该机制，进程退出或者崩溃。</p> 
<p>l 内核范围的持久性。这种机制持续到操作系统内核重启或者显式的删除它。</p> 
<p>l 文件系统范围的持久性。这种机制一直持续到显式的删除为止。</p> 
<p> </p> 
<p>有些原著的POSIX和Windows IPC机制在持久性上有比较大的差异，很难保证它们在Windows和POSIX系统之间的可移植性。Boost.Interprocess类有以下的持久性：</p> 
<table><tbody><tr><td> <p><strong>Mechanism </strong></p> </td><td> <p><strong>Persistence </strong></p> </td></tr><tr><td> <p>Shared memory</p> </td><td> <p>Kernel or Filesystem</p> </td></tr><tr><td> <p>Memory mapped file</p> </td><td> <p>Filesystem</p> </td></tr><tr><td> <p>Process-shared mutex types</p> </td><td> <p>Process</p> </td></tr><tr><td> <p>Process-shared semaphore</p> </td><td> <p>Process</p> </td></tr><tr><td> <p>Process-shared condition</p> </td><td> <p>Process</p> </td></tr><tr><td> <p>File lock</p> </td><td> <p>Process</p> </td></tr><tr><td> <p>Message queue</p> </td><td> <p>Kernel or Filesystem</p> </td></tr><tr><td> <p>Named mutex</p> </td><td> <p>Kernel or Filesystem</p> </td></tr><tr><td> <p>Named semaphore</p> </td><td> <p>Kernel or Filesystem</p> </td></tr><tr><td> <p>Named condition</p> </td><td> <p>Kernel or Filesystem</p> </td></tr></tbody></table> 
<p>如你所见，Boost.Interprocess定义了一些具有“内核或文件系统”持久性的机制。这是因为POSIX允许原著进程间通信实现具有这种功能。用户可以实现共享内存，使用映射文件和获取文件系统持久性。</p> 
<h3>3.4. <strong>Interprocess机制的名称</strong></h3> 
<p>有些进程间机制是在共享内存或内存映射文件中创建的匿名对象，但是有些进程间机制需要一个名字或者标识，这样两个没有关系的进程可以使用相同的interprocess机制对象。例如：共享内存，命名互斥量，命名信号量。</p> 
<p>用于标识一个interprocess机制的名称是不具备可移植性的，纵使是在不同的UNIX系统之间。正因为如此，Boost.Interprocess限制名字：</p> 
<p>l 以字母开始，小写或大写。如：Sharedmemory，sharedmemory，sHaReDmOry</p> 
<p>l 可以包含字母，下划线，数字。如：shm1,shm2and3,Shm4Plus4</p> 
<h3>3.5. <strong>构造，析构和Interprocess命名资源的生命周期</strong></h3> 
<p>命名的Boost.Interprocess资源具有内核或者文件系统级别的持久性，包括共享内存，内存映射文件，命名互斥量，命名条件变量，命名信号量。意味着即使所有打开该资源的进程都结束了，资源将任然可以被从新打开并访问；这些资源只能被显式的调用它们的静态移除函数。这种行为很容易理解，因为它和控制文件打开，创建，删除的函数机制是一样的。</p> 
<p>Boost.Interprocess和文件系统对比</p> 
<table><tbody><tr><td> <p><strong>Named Interprocess resource </strong></p> </td><td> <p><strong>Corresponding std file </strong></p> </td><td> <p><strong>Corresponding POSIX operation </strong></p> </td></tr><tr><td> <p>Constructor</p> </td><td> <p>std::fstream constructor</p> </td><td> <p>open</p> </td></tr><tr><td> <p>Destructor</p> </td><td> <p>std::fstream destructor</p> </td><td> <p>close</p> </td></tr><tr><td> <p>Member remove</p> </td><td> <p>None. std::remove</p> </td><td> <p>unlink</p> </td></tr></tbody></table> 
<p>下面是POSIX和Boost.Interprocess的共享内存和命名信号量之间的对比。</p> 
<p><strong>Table 15.3. Boost.Interprocess-POSIX shared memory</strong></p> 
<table><tbody><tr><td> <p><strong>shared_memory_object operation </strong></p> </td><td> <p><strong>POSIX operation </strong></p> </td></tr><tr><td> <p>Constructor</p> </td><td> <p>shm_open</p> </td></tr><tr><td> <p>Destructor</p> </td><td> <p>close</p> </td></tr><tr><td> <p>Member remove</p> </td><td> <p>shm_unlink</p> </td></tr></tbody></table> 
<p> </p> 
<p><strong>Table 15.4. Boost.Interprocess-POSIX named semaphore</strong></p> 
<table><tbody><tr><td> <p><strong>named_semaphore operation </strong></p> </td><td> <p><strong>POSIX operation </strong></p> </td></tr><tr><td> <p>Constructor</p> </td><td> <p>sem_open</p> </td></tr><tr><td> <p>Destructor</p> </td><td> <p>close</p> </td></tr><tr><td> <p>Member remove</p> </td><td> <p>sem_unlink</p> </td></tr></tbody></table> 
<p>最重要的属性是析构命名资源不会移除资源，而只是释放系统为该进程分配的资源。要从系统移除该资源必须使用remove操作。</p> 
<h3>3.6. <strong>权限</strong></h3> 
<p>Boost.Interprocess提供的命名资源必须处理平台相关的权限，包括创建文件的权限。如果一位程序员希望在不同用户之间分享共享内存，内存映射文件或者命名的同步机制，必须指明哪些权限。可悲的是，传统的UNIX和Windows的权限差别非常大，Boost.Interprocess不打算标准化权限，但是也不会忽略它们。</p> 
<p>所有的命名资源创建函数有一个可选的权限对象，可以使用平台相关权限进行配置。</p> 
<p>由于每种机制可以被不同机制模拟。权限类型可能会改变。为了防止这种情况，Boost.Interprocess依赖类似文件的权限，共享内存需要文件read-write-delete权限。</p> 
<h2>4. <strong>在进程间共享内存</strong></h2> 
<h3>4.1. <strong>共享内存</strong></h3> 
<h4>4.1.1. <strong>什么是共享内存？</strong></h4> 
<p>共享内存是最快的进程间通信机制。操作系统在多个进程的地址空间映射一个内存段，这些进程就可以读写这个内存段了，而不需要调用操作系统函数。然而，我们需要在这些读写操作中增加同步机制。</p> 
<p>考虑当一个服务进程想要通过网络机制发送一个HTML文件给它的一个客户端进程时，会发生什么？</p> 
<p>l 服务器必须读取文件到内存，并且通过网络函数，将它的内存拷贝到操作系统内部内存。</p> 
<p>l 服务器使用网络函数拷贝操作系统内存数据到其进程空间内存。</p> 
<p> </p> 
<p>正如我们可以看到的，有两份拷贝，一种是内存到网络，而另外一种是网络到内存。而且这两份拷贝是靠操作系统调用来实现的，一般都是比较费资源的。共享内存避免了这种天花板，但是我们需要同步两个进程：</p> 
<p>l 服务器进程映射一个共享内存到地址空间，并且也获取一个同步机制。服务器使用同步机制获取排他地访问内存，将文件拷贝到内存。</p> 
<p>l 客户端映射该共享内存到地址空间。等待服务器释放排他访问，然后读取该内存。</p> 
<p> </p> 
<p>使用共享内存，我们可以避免两份数据拷贝，但是我们必须在共享内存段访问上增加同步。</p> 
<h4>4.1.2. <strong>创建可进程间共享的内存段</strong></h4> 
<p>要使用共享内存，必须执行以下两步基本步骤：</p> 
<p>l 向操作系统请求一个可以共享的内存段。该用户可以创建、销毁、打开这个内存，通过一个共享内存对象：该对象代表可以同时被多个进程映射到其自己地址空间的内存。</p> 
<p>l 将该内存的一部分或者全部关联到调用的进程的地址空间。操作系统在该进程地址空间内寻找一个足够大的内存地址范围，并且标记该地址范围为一个特殊范围。其他进程关联到的地址范围各不相同。</p> 
<p> </p> 
<p>这两步成功完成后，进程可以读写该地址空间。下面看看Boost.Interprocess如何做的。</p> 
<h4>4.1.3. <strong>头文件</strong></h4> 
<p>管理共享内存，必须包含下列头文件：</p> 
<p>#include &lt;boost/interprocess/shared_memory_object.hpp&gt;</p> 
<p> </p> 
<h4>4.1.4. <strong>创建共享内存段</strong></h4> 
<p>我们必须使用shared_memory_object类来创建、打开和销毁可以被多个进程映射的共享内存段。我们必须指明访问该共享内存对象的模式（只读，后者读写），就像一个文件一样：</p> 
<p>l 创建一个共享内存段。如果已经存在，则抛出异常：</p> 
<p>using boost::interprocess;</p> 
<p>shared_memory_object shm_obj</p> 
<p>( create_only // 只是创建</p> 
<p>,”shared_memory”// 名字</p> 
<p>,read_write // 读写模式</p> 
<p>);</p> 
<p> </p> 
<p>l 打开或者创建一个共享段</p> 
<p>using boost::interprocess;</p> 
<p>shared_memory_object shm_obj</p> 
<p>( open_or_create // 打开或者创建</p> 
<p>,”shared_memory” // 名字</p> 
<p>,read_only // 只读模式</p> 
<p>);</p> 
<p> </p> 
<p>l 只打开一个共享内存段。如果不存在抛出异常：</p> 
<p>using boost::interprocess;</p> 
<p>shared_memory_object shm_obj</p> 
<p>( open_only // 只是打开</p> 
<p>,”shared_memory” // 名字</p> 
<p>,read_write // 读写模式</p> 
<p>);</p> 
<p>当一个共享内存对象被创建，其大小为0.用户必须使用truncate函数设置该共享内存大小。该对象必须具备read-write模式：</p> 
<p>shm_obj.truncate(10000);</p> 
<p>remove函数可能会失败返回false，因为共享内存不存在，或者文件被打开或者文件还被其他进程映射：</p> 
<p>using boost::interprocess;</p> 
<p>shared_memory_object::remove(“shared_memory”);</p> 
<p> </p> 
<h4>4.1.5. <strong>映射共享内存段</strong></h4> 
<p>一旦创建或者打开，进程只需要映射共享内存对象到其地址空间。用户可以映射整个共享内存，也可以映射一部分到地址空间。映射进程使用类mapped_region类。该类代表一个从共享内存对象或其他可映射的设备获取的内存区域。事实上shared_memory_object是memory_mappable对象。</p> 
<p>using boost::interprocess;</p> 
<p>std::size_t ShmSize = ...</p> 
<p> </p> 
<p>// 映射后半部分</p> 
<p>mapped_regin region</p> 
<p>( shm // 可映射对象</p> 
<p>, read_write // 访问模式</p> 
<p>, ShmSize/2 // 起始偏移</p> 
<p>,ShmSize-ShmSize/2 // 长度</p> 
<p>);</p> 
<p> </p> 
<p>// 获取映射后区域地址</p> 
<p>region.get_address();</p> 
<p> </p> 
<p>// 获取区域的长度</p> 
<p>region.get_size();</p> 
<p> </p> 
<p>The user can specify the offset from the mappable object where the mapped region should start and the size of the mapped region. If no offset or size is specified, the whole mappable object (in this case, shared memory) is mapped. If the offset is specified, but not the size, the mapped region covers from the offset until the end of the mappable object.</p> 
<p>For more details regarding mapped_region see the <a href="" rel="nofollow"> <u>boost::interprocess::mapped_region</u></a> class reference.</p> 
<p> </p> 
<h4>4.1.6. <strong>一个简单例子</strong></h4> 
<p>让我们看一个共享内存用法的简单例子：一个服务器进程创建了一个共享内存对象，映射并且初始化所有字节。然后客户端进程打开这个共享内存，映射并检测数据的正确性：</p> 
<p>#include &lt;boost/interprocess/shared_memory_object.hpp&gt;</p> 
<p>#include &lt;boost/interprocess/mapped_region.hpp&gt;</p> 
<p>#include &lt;cstring&gt;</p> 
<p>#include &lt;cstdlib&gt;</p> 
<p>#include &lt;string&gt;</p> 
<p> </p> 
<p>int main( int argc,char* argv[] )</p> 
<p>{<!-- --></p> 
<p>using namespace boost::interprocess;</p> 
<p>if( argc==1 ){ // 父进程</p> 
<p>// 在构造和析构中移除共享内存</p> 
<p>struct shm_remove{<!-- --></p> 
<p><a name="OLE_LINK2"></a>shm_remove(){ shared_memory_object::remove(“MySharedMemory”);}</p> 
<p>~shm_remove(){ shared_memory_object::remove(“MySharedMemory”);}</p> 
<p>} remover;</p> 
<p> </p> 
<p>// 创建共享内存</p> 
<p>shared_memory_object shm( create_only, “MySharedMemory”, read_write );</p> 
<p>shm.truncate(1000);</p> 
<p> </p> 
<p>mapped_region region(shm,read_write);</p> 
<p>std::memset(region,get_address(),1,region.get_size());</p> 
<p> </p> 
<p>std::string s(argv[0]);</p> 
<p>s += “ child “;</p> 
<p>if( 0!=std::system(s.c_str()))</p> 
<p>return 1;</p> 
<p>}else{ // 子进程</p> 
<p>shared_memory_object shm( open_only,”MySharedMemory”,read_only );</p> 
<p>mapped_region region(shm,read_only);</p> 
<p> </p> 
<p>char *mem = static_cast&lt;char*&gt;(region.get_address());</p> 
<p>for( std::size_t i=0;i&lt;region.get_size();++i )</p> 
<p>if( *mem++ != 1 )</p> 
<p>return 1;</p> 
<p>}</p> 
<p>}</p> 
<p> </p> 
<p> </p> 
<h4>4.1.7. <strong>为不具备共享内存对象系统模拟</strong></h4> 
<p>Boost.Interprocess以POSIX形式提供了可移植的共享内存。有些操作系统不支持POSIX定义的共享内存：</p> 
<p>l Windows操作系统提的供共享内存由分页文件支持的内存，但是其生命期语义不同于POSIX中定义。</p> 
<p>l 有些UNIX系统不完全支持POSIX中共享内存对象。</p> 
<p> </p> 
<p>在那些平台中，共享内存使用映射文件来模拟。这些文件在临时文件夹的boost_interprocess目录内。在Windows平台，如果注册表中有“Common AppData”键值，boost_interprocess文件夹就建在该目录下，in XP usually "C:\Documents and Settings\All Users\Application Data" and in Vista "C:\ProgramData"). For Windows platforms without that registry key and Unix systems, shared memory is created in the system temporary files directory ("/tmp" or similar).</p> 
<p>由于是模拟的，这些共享内存具有文件系统的持久性。</p> 
<h4>4.1.8. <strong>移除共享内存</strong></h4> 
<p>shared_memory_object类提供了一个静态函数remove用于移除共享内存对象。</p> 
<p>这个函数可能会执行失败：比如共享内存对象不存在，或者被其他进程打开着。需要注意的是这个函数与标准C中的int remove( const char* path)函数相似， shared_memory_object::remove调用shm_unlink：</p> 
<p>l 该函数将会移除由name指定的共享内存的名字</p> 
<p>l 如果一个或多个引用存在，此时执行分离，函数返回前名字会被删除，但是内存对象的内容删除会被拖延到所有打开和映射都关闭后。</p> 
<p>l 如果在调用最后一个函数后，对象继续退出，再用这个名字将会导致重新创建一个共享内存对象，但是好像这个名字的对象从来没有创建过一样。</p> 
<p> </p> 
<p>在windows系统中，当前版本支持一种通常可接受的UNIX的解除动作的模拟行为：当最后一个打开句柄被关闭时，文件名被重命名为一个随机名，并且标记为已删除。</p> 
<h4>4.1.9. <strong>UNIX系统中的匿名共享内存</strong></h4> 
<p>当关联多个进程时，创建共享内存段，并且映射它，这些操作有一点枯燥。如果是UNIX系统中石油fork()函数关联起来的，一种更简单的方法可以使用，就是使用匿名共享内存。</p> 
<p>这个特性在UNIX系统中被实现时，映射设备\dev\zero或者传递参数MAP_ANONYMOUS给mmap系统调用。</p> 
<p>在Boost.Interprocess中封装这种特性在函数anonymous_shared_memory()中，该函数返回含有匿名共享内存段的对象mapped_region。这个对象可以在关联进程中共享。</p> 
<p>例子如下：</p> 
<p>#include &lt;boost/interprocess/anonymous_shared_memory.hpp&gt;</p> 
<p>#include &lt;boost/interprocess/mapped_region.hpp&gt;</p> 
<p>#include &lt;iostream&gt;</p> 
<p>#include &lt;cstring&gt;</p> 
<p> </p> 
<p>int main(){<!-- --></p> 
<p>using namespace boost::interprocess;</p> 
<p>try{<!-- --></p> 
<p>mapped_region region(anonymous_shared_memory(1000));</p> 
<p>std::memset(region.get_address(),1,region.get_size());</p> 
<p>}catch( interprocess_exception &amp; ex ){<!-- --></p> 
<p>std::cout &lt;&lt; ex.what() &lt;&lt; std::endl;</p> 
<p>return 1;</p> 
<p>}</p> 
<p> </p> 
<p>return 0;</p> 
<p>}</p> 
<h4>4.1.10. <strong>Windows的原著共享内存</strong></h4> 
<p>Windows操作系统也有共享内存，但是它的生命期却不是kernel或者filesystem。它是由页面文件做支撑创建的，当最后一个进程与它分离时，会被自动销毁。</p> 
<p>因为这个原因，没有很好的方法可以使用原著windows共享内存来模拟kernel或者filesystem持久性。Boost.Interprocess模拟共享内存时使用内存映射文件。这样就能保证在POSIX和Windows操作系统之间的可移植性了。</p> 
<p>然而Boost.Interprocess用户对原著Windows的共享内存的访问的需求也是需要的，因为他们有时需要和不是使用Boost.Interprocess创建共享内存的进程交互。这样Boost.Interprocess也提供了管理windows原著共享内存的类：windows_shared_memory。</p> 
<p>Windows共享内存的创建与可移植共享内存不太一样:段大小必须在创建时指定，而不能使用truncate来设置。注意的是，当使用共享内存的最后一个进程销毁时，共享内存也会被销毁。</p> 
<p>后台服务程序和应用程序的共享内存也不一样。要在服务程序和应用程序之间共享内存，该共享内存的名字必须以”Global\\”开头，是一个全局名称。服务进程可以创建全局名称的共享内存，然后客户端程序可以打开该共享内存。</p> 
<p>The creation of a shared memory object in the global namespace from a session other than session zero is a privileged operation.</p> 
<p> </p> 
<p>举例：</p> 
<p>#include &lt;boost/interprocess/windows_shared_memory.hpp&gt;</p> 
<p>#include &lt;boost/interprocess/mapped_region.hpp&gt;</p> 
<p>#include &lt;cstring&gt;</p> 
<p>#include &lt;cstdlib&gt;</p> 
<p>#include &lt;string&gt;</p> 
<p> </p> 
<p>int main(int argc, char *argv[])</p> 
<p>{<!-- --></p> 
<p>   using namespace boost::interprocess;</p> 
<p> </p> 
<p>   if(argc == 1){  //Parent process</p> 
<p>      //Create a native windows shared memory object.</p> 
<p>      windows_shared_memory shm (create_only, "MySharedMemory", read_write, 1000);</p> 
<p> </p> 
<p>      //Map the whole shared memory in this process</p> 
<p>      mapped_region region(shm, read_write);</p> 
<p> </p> 
<p>      //Write all the memory to 1</p> 
<p>      std::memset(region.get_address(), 1, region.get_size());</p> 
<p> </p> 
<p>      //Launch child process</p> 
<p>      std::string s(argv[0]); s += " child ";</p> 
<p>      if(0 != std::system(s.c_str()))</p> 
<p>         return 1;</p> 
<p>      //windows_shared_memory is destroyed when the last attached process dies...</p> 
<p>   }</p> 
<p>   else{<!-- --></p> 
<p>      //Open already created shared memory object.</p> 
<p>      windows_shared_memory shm (open_only, "MySharedMemory", read_only);</p> 
<p> </p> 
<p>      //Map the whole shared memory in this process</p> 
<p>      mapped_region region(shm, read_only);</p> 
<p> </p> 
<p>      //Check that memory was initialized to 1</p> 
<p>      char *mem = static_cast&lt;char*&gt;(region.get_address());</p> 
<p>      for(std::size_t i = 0; i &lt; region.get_size(); ++i)</p> 
<p>         if(*mem++ != 1)</p> 
<p>            return 1;   //Error checking memory</p> 
<p>      return 0;</p> 
<p>   }</p> 
<p>   return 0;</p> 
<p>}</p> 
<h4>4.1.11. <strong>XSI共享内存</strong></h4> 
<p> In many UNIX systems, the OS offers another shared memory memory mechanism, XSI (X/Open System Interfaces) shared memory segments, also known as "System V" shared memory. This shared memory mechanism is quite popular and portable, and it's not based in file-mapping semantics, but it uses special functions (shmget, shmat, shmdt, shmctl...).</p> 
<p> </p> 
<p>Unlike POSIX shared memory segments, XSI shared memory segments are not identified by names but by 'keys' usually created with ftok. XSI shared memory segments have kernel lifetime and must be explicitly removed. XSI shared memory does not support copy-on-write and partial shared memory mapping but it supports anonymous shared memory.</p> 
<p> </p> 
<p>Boost.Interprocess offers simple (xsi_shared_memory) and managed (managed_xsi_shared_memory) shared memory classes to ease the use of XSI shared memory. It also wraps key creation with the simple xsi_key class.</p> 
<p> </p> 
<p>Let's repeat the same example presented for the portable shared memory object: A server process creates a shared memory object, maps it and initializes all the bytes to a value. After that, a client process opens the shared memory, maps it, and checks that the data is correctly initialized.</p> 
<p> </p> 
<p>This is the server process:</p> 
<p> </p> 
<p>#include &lt;boost/interprocess/xsi_shared_memory.hpp&gt;</p> 
<p>#include &lt;boost/interprocess/mapped_region.hpp&gt;</p> 
<p>#include &lt;cstring&gt;</p> 
<p>#include &lt;cstdlib&gt;</p> 
<p>#include &lt;string&gt;</p> 
<p> </p> 
<p>using namespace boost::interprocess;</p> 
<p> </p> 
<p>void remove_old_shared_memory(const xsi_key &amp;key)</p> 
<p>{<!-- --></p> 
<p>   try{<!-- --></p> 
<p>      xsi_shared_memory xsi(open_only, key);</p> 
<p>      xsi_shared_memory::remove(xsi.get_shmid());</p> 
<p>   }</p> 
<p>   catch(interprocess_exception &amp;e){<!-- --></p> 
<p>      if(e.get_error_code() != not_found_error)</p> 
<p>         throw;</p> 
<p>   }</p> 
<p>}</p> 
<p> </p> 
<p>int main(int argc, char *argv[])</p> 
<p>{<!-- --></p> 
<p>   if(argc == 1){  //Parent process</p> 
<p>      //Build XSI key (ftok based)</p> 
<p>      xsi_key key(argv[0], 1);</p> 
<p> </p> 
<p>      remove_old_shared_memory(key);</p> 
<p> </p> 
<p>      //Create a shared memory object.</p> 
<p>      xsi_shared_memory shm (create_only, key, 1000);</p> 
<p> </p> 
<p>      //Remove shared memory on destruction</p> 
<p>      struct shm_remove</p> 
<p>      {<!-- --></p> 
<p>         int shmid_;</p> 
<p>         shm_remove(int shmid) : shmid_(shmid){}</p> 
<p>         ~shm_remove(){ xsi_shared_memory::remove(shmid_); }</p> 
<p>      } remover(shm.get_shmid());</p> 
<p> </p> 
<p>      //Map the whole shared memory in this process</p> 
<p>      mapped_region region(shm, read_write);</p> 
<p> </p> 
<p>      //Write all the memory to 1</p> 
<p>      std::memset(region.get_address(), 1, region.get_size());</p> 
<p> </p> 
<p>      //Launch child process</p> 
<p>      std::string s(argv[0]); s += " child ";</p> 
<p>      if(0 != std::system(s.c_str()))</p> 
<p>         return 1;</p> 
<p>   }</p> 
<p>   else{<!-- --></p> 
<p>      //Build XSI key (ftok based)</p> 
<p>      xsi_key key(argv[0], 1);</p> 
<p> </p> 
<p>      //Create a shared memory object.</p> 
<p>      xsi_shared_memory shm (open_only, key);</p> 
<p> </p> 
<p>      //Map the whole shared memory in this process</p> 
<p>      mapped_region region(shm, read_only);</p> 
<p> </p> 
<p>      //Check that memory was initialized to 1</p> 
<p>      char *mem = static_cast&lt;char*&gt;(region.get_address());</p> 
<p>      for(std::size_t i = 0; i &lt; region.get_size(); ++i)</p> 
<p>         if(*mem++ != 1)</p> 
<p>            return 1;   //Error checking memory</p> 
<p>   }</p> 
<p>   return 0;</p> 
<p>}</p> 
<p> </p> 
<h3>4.2. <strong>内存映射文件</strong></h3> 
<h4>4.2.1. <strong>什么事内存映射文件？</strong></h4> 
<p>文件映射就是将文件的内容和一个进程的地址空间相关联。系统创建文件映射来关联文件和地址空间。映射区间是进程使用的地址段，可以访问文件内容。一个文件映射，可以有多个映射区间，因此用户可以不需要映射文件的全部内容，而只是映射一部分到地址空间，因为有时候文件会非常大，超过进程的地址空间。进程使用指针读写文件，就像动态内存。文件映射有以下优点：</p> 
<p>l 统一资源使用。文件和内存可以使用相同函数对待</p> 
<p>l 自动从操作系统对文件数据同步和缓存</p> 
<p>l 在文件中利用C++工具（STL容器，算法）</p> 
<p>l 在多个应用程序中共享内存</p> 
<p>l 允许高效地工作在大文件上，不需要映射整个文件到内存</p> 
<p>l 如果多个进程使用相同的文件映射来创建映射区间，每个进程有相同的文件拷贝。</p> 
<p> </p> 
<p>文件映射不仅仅用于进程间通信，还可以用于简化文件用法，这样用户没必要使用文件管理函数来写文件。用户只是往进程地址内写数据，操作系统会将数据导入文件。</p> 
<p>当两个进程映射同一个文件到内存，一个进程写的数据会被另外一个进程读到，所以，内存映射文件可以作为进程间通信的机制。我们可以说内存映射文件提供与共享内存相同的进程间通信服务，只是是filesystem级别的持久性。然而，因为操作系统需要同步数据到文件中，所以，内存映射文件没有共享内存快。</p> 
<h4>4.2.2. <strong>使用映射文件</strong></h4> 
<p>要使用内存映射文件，我们有两步基本操作：</p> 
<p>l 创建一个可映射的对象代表一个文件系统内存在的文件。这个对象将来用于创建该文件的多个映射区间。</p> 
<p>l 关联整个文件或者文件的一部分到调用的进程地址空间。操作系统在调用进程内寻找足够大的内存地址范围，并标记该范围为特殊应用。其他也映射该文件的进程地址区间会不同。</p> 
<p> </p> 
<p> </p> 
<h4>4.2.3. <strong>头文件</strong></h4> 
<p>#include &lt;boost/interprocess/file_mapping.hpp&gt;</p> 
<p> </p> 
<h4>4.2.4. <strong>创建文件映射</strong></h4> 
<p>创建代表文件的可映射对象：</p> 
<p>using boost::interprocess;</p> 
<p>file_mapping m_file</p> 
<p>(“/usr/home/file” // 文件名</p> 
<p>,read_write // 读写模式</p> 
<p>);</p> 
<p> </p> 
<h4>4.2.5. <strong>映射文件内容到内存</strong></h4> 
<p>创建文件映射之后，进程只需要将功能内存映射到进程的地址空间。用户可以映射全部文件，也可以只映射一部分。映射过程使用类mapped_region实现。</p> 
<p>using boost::interprocess;</p> 
<p>std::size_t FileSize = ...</p> 
<p> </p> 
<p>mapped_region region</p> 
<p>( m_file</p> 
<p>, read_write</p> 
<p>, FileSize / 2</p> 
<p>, FileSize - FileSize/2</p> 
<p>);</p> 
<p> </p> 
<p>region.get_address();</p> 
<p> </p> 
<p>region.get_size();</p> 
<p>如果多个进程映射了相同文件，当一个进程对映射的内存区间内容修改了，而其他进程也映射了该区间，那么其他进程立即能看到该进程的修改。但是，硬盘上文件的内容是不会里面同步更新的，因为那会伤害性能。如果用户希望确保已经更新到文件内容，可以flush一个区间到磁盘。当函数返回时，flush过程已经开始，但是不能保证完成。</p> 
<p>// flush全部区间</p> 
<p>region.flush();</p> 
<p> </p> 
<p>// flush从offset开始后的所有数据</p> 
<p>region.flush( offset );</p> 
<p> </p> 
<p>// flush从offset开始后size长度的数据</p> 
<p>region.flush( offset, size );</p> 
<p> </p> 
<p>记住这里的offset不是文件的全局偏移，而是映射区间内部偏移。</p> 
<h4>4.2.6. <strong>简单例子</strong></h4> 
<p> </p> 
<p>#include &lt;boost/interprocess/file_mapping.hpp&gt;</p> 
<p>#include &lt;boost/interprocess/mapped_region.hpp&gt;</p> 
<p>#include &lt;iostream&gt;</p> 
<p>#include &lt;fstream&gt;</p> 
<p>#include &lt;string&gt;</p> 
<p>#include &lt;vector&gt;</p> 
<p>#include &lt;cstring&gt;</p> 
<p>#include &lt;cstddef&gt;</p> 
<p>#include &lt;cstdlib&gt;</p> 
<p> </p> 
<p>int main( int argc,char* argv[] )</p> 
<p>{<!-- --></p> 
<p>using namespace boost::interprocess;</p> 
<p> </p> 
<p>const char* FileName = “file.bin”;</p> 
<p>const std::size_t FileSize = 10000;</p> 
<p> </p> 
<p>if( argc==1 ){ // 父进程</p> 
<p>{ // 创建文件</p> 
<p>file_mapping::remove(FileName);</p> 
<p>std::filebuf fbuf;</p> 
<p>fbuf.open( FileName, std::ios_base::in|std::ios_base::out|std::ios_base::trunc|std::ios_base::binary);</p> 
<p>fbuf.pubseekoff( FileSize -1, std::ios_base::beg);</p> 
<p>fbuf.sputc(0);</p> 
<p>}</p> 
<p> </p> 
<p>// 退出时删除文件</p> 
<p>struct file_remove{<!-- --></p> 
<p>file_remove( const char* FileName ):FileName_(FileName){}</p> 
<p>~file_remove(){ file_mapping::remove(FileName_);}</p> 
<p>const char* FileName_;</p> 
<p>}</p> 
<p> </p> 
<p>// 创建一个文件映射</p> 
<p>file_mapping m_file(FileName, read_write );</p> 
<p> </p> 
<p>// 映射整个文件到内存空间</p> 
<p>mapped_region region(m_file,read_write);</p> 
<p> </p> 
<p>std::memset( region.get_address(),1,region.get_size());</p> 
<p> </p> 
<p>// 启动子进程</p> 
<p>std::string s(argv[0]);</p> 
<p>s += “ chile “;</p> 
<p>if( 0!=std::system(c.c_str()) )</p> 
<p>return 1;</p> 
<p>}else{ // 子进程</p> 
<p>{ // 打开文件映射，并以只读模式映射</p> 
<p>file_mapping m_file(FileName,read_only);</p> 
<p>mapped_region region(m_file,read_only);</p> 
<p> </p> 
<p>const char* mem = static_cast&lt;char*&gt;(region.get_address());</p> 
<p>for( std::size_t i = 0;i&lt;region.get_size();++i )</p> 
<p>if( *mem++ != 1 )</p> 
<p>return 1;</p> 
<p>}</p> 
<p>{ // 测试读取文件</p> 
<p>std::filebuf fbuf;</p> 
<p>fbuf.open( FileName, std::ios_base::in|std::ios_base::binary);</p> 
<p> </p> 
<p>std::vector&lt;char&gt; vect(FileSize,0);</p> 
<p>fbuf.sgetn(&amp;vect[0],std::streamsize(vect.size()));</p> 
<p> </p> 
<p>const char* mem = static_cast&lt;char*&gt;(&amp;vect[0]);</p> 
<p>for( std::size_t i=0;i&lt;FileSize;++i )</p> 
<p>if( *mem++ != 1 )</p> 
<p>return 1;</p> 
<p>}</p> 
<p>}</p> 
<p>return 0;</p> 
<p>}</p> 
<h3>4.3. <strong>深入映射区域</strong></h3> 
<h4>4.3.1. <strong>一个类管理它们所有</strong></h4> 
<p>正如我们看到的，shared_memory_object和file_mapping对象都可以用于创建mapped_region对象。他们使用同一个映射区间类有很多优点。</p> 
<p>One can, for example, mix in STL containers mapped regions from shared memory and memory mapped files. Libraries that only depend on mapped regions can be used to work with shared memory or memory mapped files without recompiling them.</p> 
<h4>4.3.2. <strong>在多个进程中映射地址</strong></h4> 
<p>在例子中我们看到，映射到进程空间的地址是由操作系统选择的。如果多个进程映射同一个对象，映射区域的地址，在各进程中肯定是不一样的。这样在映射的内存区间使用指针是无效的，因为只有保存指针值得进程有效。解决办法就是使用偏移而不是指针：两个对象地址的距离在不同进程中是一样的。</p> 
<p>所以，第一条建议是在映射共享内存或者内存映射文件时，避免使用原始指针，除非你了解你在做什么。使用数据之间的偏移，或者相对指针来获取指针功能。Boost.Interprocess提供一个智能指针类boost::interprocess::offset_ptr，可以用于安全的放在共享内存中，执行共享内存中的其他对象。</p> 
<p> </p> 
<h4>4.3.3. <strong>固定地址映射</strong></h4> 
<p>使用相对指针和使用原始指针比，效率要差一些。如果用户可以将共享内存或者映射文件加载到相同的地址空间，使用共享内存将是最好的选择。</p> 
<p>要映射到一个固定地址，使用下面的构造函数：</p> 
<p>mapped_region region( shm // 映射共享内存</p> 
<p>, read_write // 使用读写模式</p> 
<p>,0 // 偏移为0</p> 
<p>,0 // 全部长度</p> 
<p>, (void*)0x3F000000 // 期望的地址</p> 
<p>);</p> 
<p>然而，用户不能将地址映射到随意位置，即使该地址没有被占用。后面再限制里会讨论。</p> 
<h4>4.3.4. <strong>映射偏移和地址局限性</strong></h4> 
<p>大部分的操作系统要求映射的地址和被映射对象的偏移值必须是页大小的倍数。这是因为操作系映射时是整个页映射的。</p> 
<p>如果使用固定地址映射，偏移和地址参数应该是页大小的整数倍。对于32位系统页大小典型值有：4KB，8KB。</p> 
<p>因为操作系统执行映射时，是整页的，指定大小或者偏移不是页大小整数倍时，会浪费更多的系统资源。比如你映射1字节时：</p> 
<p>mapped_region region( shm,read_write,0,1);</p> 
<p>操作系统会保留整个页面，其他的映射将不会再使用它，所以，我们将浪费pagesize-1的空间。如果我们想要高效操作系统资源，我们可以创建区间大小是页大小整数倍的区间。</p> 
<p>mapped_region region1( shm, read_write</p> 
<p>,0 // 偏移为0</p> 
<p>,page_size/2 ); // 大小是页面的一半，实际是一个页面</p> 
<p> </p> 
<p>mapped_region region2(shm,read_write</p> 
<p>, page_size/2 // 实际偏移是0，浪费一半</p> 
<p>3*page_size/2); //</p> 
<p>如何获取页面大小呢。</p> 
<p>std::size_t page_size = mapped_region::get_page_size();</p> 
<p> </p> 
<h3>4.4. <strong>在映射区间构造对象的限制</strong></h3> 
<p>当两个进程都创建了相同可映射对象的映射区间时，两个进程可以通过该内存读写来通信。一个进程可以在该映射区间构造C++对象，这样另外一个进程可以使用。然而，共享的映射区间并不能承载所有的C++对象，因为不是所有的类都是准进程共享对象，尤其是映射区间地址还不一样。</p> 
<h4>4.4.1. <strong>偏移指针代替原始指针</strong></h4> 
<p>将对象放入一个映射区间，并且在不同进程中映射的区间地址不一样，原始指针是个问题，因为他们只在放入区间的进程有效。为了解决这个问题，Boost.Interprocess提供了一种特殊的智能指针用于替代原始指针。这样用户类中含有原始指针的不能安全的放入映射区间。这些指针必须用偏移指针替换，并且这些指针只能指向同一个映射区间内的对象。</p> 
<h4>4.4.2. <strong>禁用引用</strong></h4> 
<p>引用也有同指针一样的问题（原因是他们实现像指针）。然而，不可能创建一个完全可工作的智能引用，在当前的C++中（例：运算符.()不能被覆盖）。正因如此，如果用户想要放一个对象到共享内存，对象内不能有引用成员。</p> 
<p> </p> 
<h4>4.4.3. <strong>禁用虚性</strong></h4> 
<p>虚表指针和虚表存在于创建对象的进程地址空间，所以如果我们要放一个有虚函数或者虚基类的类，其他进程会崩溃。</p> 
<p>这个问题非常难解决，因为每个进程需要不同的虚表指针。</p> 
<h4>4.4.4. <strong>注意静态成员</strong></h4> 
<p>类的静态成员是全局对象，在进程中作为全局变量。</p> 
<h2>5. <strong>映射地址无关的指针：offset_ptr</strong></h2> 
<p>当为两个进程通信创建共享内存和内存映射文件时，内存段在每个进程中有不同地址。</p> 
<p>#include &lt;boost/interprocess/shared_memory_object.hpp&gt;</p> 
<p>//...</p> 
<p>using boost::interprocess;</p> 
<p> </p> 
<p>// 打开一个共享内存段</p> 
<p>shared_memory_object shm_obj</p> 
<p>( open_only,</p> 
<p>,”shared_memory”</p> 
<p>,read_only</p> 
<p>);</p> 
<p> </p> 
<p>// 映射整个共享内存</p> 
<p>mapped_region region</p> 
<p>( shm</p> 
<p>, read_write</p> 
<p>);</p> 
<p> </p> 
<p>// 这个地址在不同进程中会不同</p> 
<p>void* addr = region.get_address();</p> 
<p>这样的话，在映射区间创建复杂对象就非常困难：存放在一个映射区间的C++实例可能有指向其他对象的指针。由于指针保存了一个绝对地址，而该地址只在产生该对象的进程中有效。除非所有进程将映射区间映射到统一地址。</p> 
<p>为了在映射区间能够模拟指针，用户必须使用相对偏移替代绝对地址。对象之间的偏移在所有进程中是一样的。为了方便使用偏移，Boost.Interprocess提供offset_ptr。</p> 
<p>offset_ptr封装了作为指针接口的所有后台操作。该类接口灵感来自Boost的智能指针，它保存了指向对象地址与其本身的偏移。想象通用32位处理器中的一个结构：</p> 
<p>struct structure</p> 
<p>{<!-- --></p> 
<p>int integer1; // 编译器将这个成员放在结构体的偏移是0</p> 
<p>offset_ptr&lt;int&gt; ptr; // 偏移是4</p> 
<p>int integer2; // 偏移是8</p> 
<p>}</p> 
<p> </p> 
<p>structure s;</p> 
<p> </p> 
<p>// &amp;s.integer1 - &amp;s.ptr = -4</p> 
<p>s.ptr = &amp;s.integer1;</p> 
<p> </p> 
<p>// &amp;s.integer2 -&amp;s.ptr = 4</p> 
<p>s.ptr = &amp;s.integer2;</p> 
<p> </p> 
<p>offset_ptr最大的问题是如何表示一个空指针。null指针不能像偏移一样安全地表示，因为0地址往往不在映射区间。而每个进程映射区间的基址各不相同。</p> 
<p>有些实现选用偏移0作为空指针，事实上按照offset_ptr的规则，是一个指向其本身的指针。但是很多使用场合是不合适的，比如很多时候链表结构或者STL容器需要指向其自身，这时0偏移指针是需要的。还有一种实现是指针保存除了偏移量之外，还保存一个布尔值是否为空指针，这种方式也不可取，增加指针对象空间，损害性能。</p> 
<p>最后，offset_ptr定义偏移1作为空指针，表示该类型不可能指向它自己之后的一个字节：</p> 
<p>using namespace boost::interprocess;</p> 
<p>offset_ptr&lt;char&gt; ptr;</p> 
<p> </p> 
<p>// 指向其地址的下一个自己的地址，是空地址</p> 
<p>ptr = (char*)&amp;ptr + 1;</p> 
<p> </p> 
<p>// 判断是否为空</p> 
<p>assert(!ptr);</p> 
<p> </p> 
<p>// 同样是设置空指针</p> 
<p>ptr = 0;</p> 
<p> </p> 
<p>assert(!ptr);</p> 
<p>在实践中，这个限制其实不重要，因为用户基本不会需要指向其后一个字节的地址。</p> 
<p>offset_ptr提供了所有指针类似的操作和随机访问迭代器类型。所有该类可以在STL算法中使用。更多内容查看offset_ptr参考文档。</p> 
<h2>6. <strong>同步机制</strong></h2> 
<h3>6.1. <strong>同步机制概览</strong></h3> 
<p>通过共享内存对象或者内存映射文件对象，在进程间共享内存,如果没有有效的同步的话，这种能力不是很有用。同样的问题在多线程中，线程之间共享的堆内存，全局变量等，也需要线程同步机制：互斥量和条件变量。Boost.Threads库实现了同一进程中线程之间同步的功能。Boost.Interprocess库实现了类似的机制来同步不同进程内的线程。</p> 
<h4>6.1.1. <strong>命名的和匿名的同步机制</strong></h4> 
<p>Boost.Interprocess提供了两类同步对象：</p> 
<p>l 命名设施：当两个进程想要创建一个这类对象时，两个进程必须创建或者打开一个使用相同名字的对象。就像创建或打开文件一样：一个进程创建一个文件使用fstream和文件名，并且另外一个进程打开那个文件使用另外一个fstream和相同文件名。每个进程使用不同对象访问资源，但是两个进程都是使用相同底层资源。</p> 
<p>l 匿名设施：因为这些设施都没有名字，两个进程必须通过共享内存或者内存映射文件共享同一个对象。这和传统的线程同步对象相似：两个进程都共享相同对象。不同于线程同步，同一个进程中的线程间共享全局变量和堆内存，两个进程之间共享对象只能通过映射区间。</p> 
<p> </p> 
<p>每种类型都有其优点和缺点：</p> 
<p>l 命名设施对于简单的同步任务来说更容易控制，因为两个进程不是必须创建一个共享内存区间和创建同步机制。</p> 
<p>l 当使用内存映射对象获取自动持久性时，匿名设施可以被序列化到磁盘。用户可以在一个内存映射文件中构造一个同步设施，重启系统，重新映射文件，再次使用同步设施不会有任何问题。这种功能不能再命名同步机制中实现。</p> 
<p> </p> 
<p>匿名设施和命名设施之间的接口区别在构造函数。通常，匿名设施只有一个构造函数。而命名设施有多个构造函数，而且第一个参数用于说明请求创建，打开，还是打开或创建底层设施。</p> 
<p>using namespace boost::interprocess;</p> 
<p> </p> 
<p>// 创建一个命名同步设施，如果已经存在，则抛出错误</p> 
<p>NamedUtility(create_only,...);</p> 
<p> </p> 
<p>// 打开一个命名同步设施，如果不存在，则创建</p> 
<p>NamedUtility(open_or_create,...);</p> 
<p> </p> 
<p>// 打开一个同步设施，如果不存在，则抛出错误</p> 
<p>NamedUtility(open_only,...);</p> 
<p>匿名同步设施只能被创建，进程间必须使用其他机制来同步到创建的进程：</p> 
<p>using namespace boost::interprocess;</p> 
<p> </p> 
<p>// 创建一个匿名同步设施</p> 
<p>AnonymousUtility(...);</p> 
<p> </p> 
<h4>6.1.2. <strong>同步机制类型</strong></h4> 
<p>且不考虑命名和匿名属性，Boost.Interprocess提供了一下同步工具：</p> 
<p>l 互斥量(命名的和匿名的)</p> 
<p>l 条件变量(命名的和匿名的)</p> 
<p>l 信号量(命名的和匿名的)</p> 
<p>l 可升级互斥量</p> 
<p>l 文件锁</p> 
<h3>6.2. <strong>互斥量</strong></h3> 
<h4>6.2.1. <strong>互斥量是什么?</strong></h4> 
<p>互斥量代表了互斥的执行，是进程间同步的最基本形式。互斥量保证只有一个执行线程可以锁定一个互斥量对象。如果一段代码由一个互斥量的锁定和释放包围，那么就能保证同时只能有一个线程执行该段代码。当一个线程解锁后，其他线程才可以进入该代码段。</p> 
<p>互斥量可以是递归的或者非递归的：</p> 
<p>l 递归互斥量可以被同一个线程多次锁定。要完全解锁这个互斥量，线程必须执行解锁次数和锁定次数相同。</p> 
<p>l 非递归互斥量不能被同一线程多次锁定。如果一个线程第二次锁定一个互斥量，结果不可预期，可能抛出错误，也可能会发生死锁。</p> 
<p> </p> 
<h4>6.2.2. <strong>互斥量操作</strong></h4> 
<p>Boost.Interprocess实现了互斥量类型的如下操作：</p> 
<p>void lock()</p> 
<p>调用线程获取互斥量的所有权。如果其他线程已经拥有该互斥量，调用线程会一直等待直到获取到该互斥量。互斥量被一个线程获取后，必须由该线程解锁。如果互斥量支持递归，解锁次数必须和锁定次数相同。</p> 
<p>错误时，该函数抛出异常interprocess_exception。</p> 
<p> </p> 
<p>bool try_lock()</p> 
<p>调用线程尝试获取互斥量的所有权。如果另外一个线程拥有该互斥量，那么立即返回获取失败。如果互斥量支持递归锁，互斥量必须被解锁相同次数。</p> 
<p>错误时，该函数抛出异常interprocess_exception。</p> 
<p> </p> 
<p>bool timed_lock( const boost::posix_time::ptime &amp;abs_time );</p> 
<p>在没有到时间前，调用线程会一直尝试获取互斥量所有权。如果互斥量支持递归，必须被解锁相同次。</p> 
<p>如果获取成功，返回true，如果超时，返回false。</p> 
<p>如果有错误，抛出错误interprocess_exception。</p> 
<p> </p> 
<p>void unlock();</p> 
<p>前提是调用线程已经排他地用于互斥量的所有权。调用线程释放它已经获取到的互斥量所有权。如果互斥量支持递归，必须解锁相同次数。</p> 
<p>如果有错误，抛出一个interprocess_exception的子类。</p> 
<p> </p> 
<p>注意：Boost.Interprocess同步机制中的boost::posix_time::ptime是UTC时间点，不是本地时间点。</p> 
<h4>6.2.3. <strong>Boost.Interprocess互斥量类型</strong></h4> 
<p>Boost.Interprocess提供以下互斥量类型：</p> 
<p>#include &lt;boost/interprocess/sync/interprocess_mutex.hpp&gt;</p> 
<p>l interprocess_mutex:一个非递归匿名互斥量。可以放在共享内存或者内存映射文件.</p> 
<p> </p> 
<p>#include &lt;boost/interprocess/sync/interprocess_recursive_mutex.hpp&gt;</p> 
<p>l interprocess_recursive_mutx:一个递归的匿名互斥量。可以放在共享内存或者内存映射文件。</p> 
<p> </p> 
<p>#include &lt;boost/interprocess/sync/named_mutex.hpp&gt;</p> 
<p>l named_mutex:一个非递归命名互斥量</p> 
<p> </p> 
<p>#include &lt;boost/interprocess/sync/named_recursive_mutex.hpp&gt;</p> 
<p>l named_recursive_mutex:一个递归的命名互斥量</p> 
<h4>6.2.4. <strong>范围锁</strong></h4> 
<p>进程在读取或者写入数据后解锁互斥量是非常重要的。但是在抛出异常的代码中，实现解锁也不容易，所有通常使用一个范围锁，即使有异常抛出，也能自动解锁。要使用范围锁，需要包含头文件：</p> 
<p>#include &lt;boost/interprocess/sync/scoped_lock.hpp&gt;</p> 
<p>原理上，范围锁类在其析构函数中调用unlock()操作，这样当异常抛出是，互斥量总是能被解锁。范围锁有很多构造函数来lock,try_lock,timed_lock或者根本不锁。</p> 
<p>using namespace boost::interprocess;</p> 
<p> </p> 
<p>MutexType mutex;</p> 
<p>{<!-- --></p> 
<p>scoped_lock&lt;MutexType&gt; lock(mutex); // 锁定</p> 
<p>}</p> 
<p> </p> 
<p>{<!-- --></p> 
<p>scoped_lock&lt;MutexType&gt; lock(mutex, try_to_lock);</p> 
<p> </p> 
<p>// 检测是否获取锁</p> 
<p>if( lock ){<!-- --></p> 
<p> </p> 
<p>}</p> 
<p>}</p> 
<p> </p> 
<p>{<!-- --></p> 
<p>boost::posix_time::ptime abs_time = ...</p> 
<p>scoped_lock&lt;MutexType&gt; lock(mutex, abs_time);</p> 
<p> </p> 
<p>if( lock ){<!-- --></p> 
<p>}</p> 
<p>}</p> 
<p>更多内容参考scoped_lock的参考手册。</p> 
<h4>6.2.5. <strong>匿名互斥量举例</strong></h4> 
<p>想象两个进程需要往一个共享内存中的循环缓冲区中写入轨迹。每个进程都需要排他地访问这个循环缓冲区，并将轨迹写入，然后继续运行。</p> 
<p>为了保护循环缓冲区，我们可以保存一个进程共享的互斥量在这里面。每个进程将在写数据之前锁定该互斥量，并且在写入轨迹后，写入一个标志。</p> 
<p>定义一个头文件doc_anonymous_mutex_shared_data.hpp：</p> 
<p>#include &lt;boost/interprocess/sync/interprocess_mutex.hpp&gt;</p> 
<p> </p> 
<p>struct shared_memory_log</p> 
<p>{<!-- --></p> 
<p>enum { NumItems = 100 };</p> 
<p>enum { LineSize = 100 };</p> 
<p> </p> 
<p>shared_memory_log()</p> 
<p>: current_line(0)</p> 
<p>,end_a(false)</p> 
<p>,end_b(false)</p> 
<p>{}</p> 
<p> </p> 
<p>boost::interprocess::interprocess_mutex mutex;</p> 
<p> </p> 
<p>char items[NumItems][LineSize];</p> 
<p>int current_line;</p> 
<p>bool end_a;</p> 
<p>bool end_b;</p> 
<p>}</p> 
<p>下面是主进程，创建共享内存，构造循环缓冲区和写轨迹：</p> 
<p>#include &lt;boost/interprocess/shared_memory_object.hpp&gt;</p> 
<p>#include &lt;boost/interprocess/mapped_region.hpp&gt;</p> 
<p>#include &lt;boost/interprocess/sync/scoped_lock.hpp&gt;</p> 
<p>#include “doc_anonymous_mutex_shared_data.hpp”</p> 
<p>#include &lt;iostream&gt;</p> 
<p>#include &lt;cstdio&gt;</p> 
<p> </p> 
<p>using namespace boost::interprocess;</p> 
<p> </p> 
<p>int main()</p> 
<p>{<!-- --></p> 
<p>try{<!-- --></p> 
<p>struct shm_remove</p> 
<p>{<!-- --></p> 
<p>shm_remove() { shared_memory_object::remove(“MySharedMemory”);}</p> 
<p>~shm_remove() { shared_memory_object::remove(“MySharedMemory”);}</p> 
<p>} remover;</p> 
<p> </p> 
<p>shared_memory_object shm</p> 
<p>( create_only</p> 
<p>,”MySharedMemory”</p> 
<p>,read_write );</p> 
<p> </p> 
<p>shm.truncate(sizeof(shared_memory_log));</p> 
<p> </p> 
<p>mapped_region region( shm,read_write);</p> 
<p> </p> 
<p>void * addr = region.get_address();</p> 
<p> </p> 
<p>shared_memory_log * data = new (addr) shared_memory_log;</p> 
<p> </p> 
<p>for( int i=0;i&lt;shared_memory_log::NumItems;++i ){<!-- --></p> 
<p>scoped_lock&lt;interprocess_mutex&gt; lock(data-&gt;mutex);</p> 
<p>std::sprintf( data-&gt;items[(data-&gt;current_line++) % shared_memory_log::NumItems],”%s_%d”,”process_a”,i);</p> 
<p>if( i==(shared_memory_log::NumItems-1) )</p> 
<p>data-&gt;end_a = true;</p> 
<p>}</p> 
<p> </p> 
<p>// 等待另外一个进程结束</p> 
<p>while( 1 ){<!-- --></p> 
<p>scoped_lock&lt;interprocess_mutex&gt; lock(data-&gt;mutex);</p> 
<p>if( data-&gt;end_b)</p> 
<p>break;</p> 
<p>}</p> 
<p>}catch( interprocess_exception &amp; ex ){<!-- --></p> 
<p>std::cout &lt;&lt; ex.what() &lt;&lt; std::endl;</p> 
<p>return 1;</p> 
<p>}</p> 
<p> </p> 
<p>return 0;</p> 
<p>}</p> 
<p>另外一个进程打开共享内存，获取权限访问循环缓冲区并开始写入轨迹。</p> 
<p>#include &lt;boost/interprocess/shared_memory_object.hpp&gt;</p> 
<p>#include &lt;boost/interprocess/mapped_region.hpp&gt;</p> 
<p>#include &lt;boost/interprocess/sync/scoped_lock.hpp&gt;</p> 
<p>#include “doc_anonymous_mutex_shared_data.hpp”</p> 
<p>#include &lt;iostream&gt;</p> 
<p>#include &lt;cstdio&gt;</p> 
<p> </p> 
<p>using namespace boost::interprocess;</p> 
<p>int main(){<!-- --></p> 
<p>struct shm_remove{<!-- --></p> 
<p>~shm_remove(){ shared_memory_object::remove(“MySharedMemory”);}</p> 
<p>} remover;</p> 
<p> </p> 
<p>shared_memory_object shm( open_only,”MySharedMemory”,read_write );</p> 
<p> </p> 
<p>mapped_region region( shm,read_write );</p> 
<p> </p> 
<p>void * addr = region.get_address();</p> 
<p> </p> 
<p>shared_memory_log * data = static_cast&lt;shared_memory_log*&gt;(addr);</p> 
<p> </p> 
<p>for( int i=0;i&lt;100;++i ){<!-- --></p> 
<p>scoped_lock&lt;interprocess_mutex&gt; lock(data-&gt;mutex);</p> 
<p>std::sprintf(data-&gt;items[(data-&gt;current_line++)%shared_memory_log::NumItems]</p> 
<p>,”process_b_%d”,i);</p> 
<p>if( i==(shared_memory_log::NumItems-1))</p> 
<p>data-&gt;end_b = true;</p> 
<p>}</p> 
<p> </p> 
<p>while(1){<!-- --></p> 
<p>scoped_lock&lt;interprocess_mutex&gt; lock(data-&gt;mutex);</p> 
<p>if( data-&gt;end_a)</p> 
<p>break;</p> 
<p>}</p> 
<p>return 0;</p> 
<p>}</p> 
<p>正如我们看到的，互斥量在保护数据上非常实用，但是在通知事件给其他进程却不行。因为这个原因，我们需要使用条件变量，下一节中会使用。</p> 
<h4>6.2.6. <strong>命名互斥量举例</strong></h4> 
<p>现在想象两个进程都想写日志到一个文件中。他们先写自己的名称，然后写消息。因为操作系统会随意中断一个进程，这样会将两个进程的消息混在一起。因此，我们需要一种方式来写完整的消息到文件中。为了实现这个目标，我们使用命名互斥量，可以让每个进程在写日志之前锁定该互斥量：</p> 
<p>#include &lt;boost/interprocess/sync/scoped_lock.hpp&gt;</p> 
<p>#include &lt;boost/interprocess/sync/named_mutex.hpp&gt;</p> 
<p>#include &lt;fstream&gt;</p> 
<p>#include &lt;iostream&gt;</p> 
<p>#include &lt;cstdio&gt;</p> 
<p> </p> 
<p>int main(){<!-- --></p> 
<p>using namespace boost::interprocess;</p> 
<p>try{<!-- --></p> 
<p>struct file_remove{<!-- --></p> 
<p>file_remove() { std::remove(“file_name”); }</p> 
<p>~file_remove(){ std::remove(“file_name”); }</p> 
<p>} file_remover;</p> 
<p> </p> 
<p>struct mutex_remove{<!-- --></p> 
<p>mutex_remove() { named_mutex::remove(“fstream_named_mutex”); }</p> 
<p>~mutex_remove(){ named_mutex::remove(“fstream_named_mutex”); }</p> 
<p>} remover;</p> 
<p> </p> 
<p>named_mutex mutex( open_or_create, “fstream_named_mutex” );</p> 
<p>std::ofstream file(“file_name”);</p> 
<p> </p> 
<p>for( int i=0;i&lt;10;++i ){<!-- --></p> 
<p>scoped_lock&lt;named_mutex&gt; lock(mutex);</p> 
<p>file &lt;&lt; “process name, “;</p> 
<p>file &lt;&lt; “This is iteration #”&lt;&lt;i;</p> 
<p>file &lt;&lt; std::endl;</p> 
<p>}</p> 
<p>}catch( interprocess_exception &amp; ex ){<!-- --></p> 
<p>std::cout &lt;&lt; ex.what() &lt;&lt; std::endl;</p> 
<p>return 1;</p> 
<p>}</p> 
<p> </p> 
<p>return 0;</p> 
<p>}</p> 
<p> </p> 
<h3>6.3. <strong>条件变量</strong></h3> 
<h4>6.3.1. <strong>条件变量是什么?</strong></h4> 
<p>在上一个例子中，互斥量用于锁定，但是我们不能用它来进行有效的等待条件满足后再执行。而条件变量却可以实现下面两件事情：</p> 
<p>l 等待：线程被阻塞，直到其他线程通知它可以继续执行，因为导致等待的条件已经消失。</p> 
<p>l 通知：线程发送信号给阻塞的线程，或者给所有阻塞的线程，告诉它们等待的条件已经具备。</p> 
<p> </p> 
<p>等待条件变量，往往和一个互斥量关联。互斥量必须在执行等待前，被获取。当执行等待时，线程自动解锁并等待。</p> 
<h4>6.3.2. <strong>Boost.Interprocess的条件变量类型</strong></h4> 
<p>Boost.Interprocess提供如下条件变量：</p> 
<p>#include &lt;boost/interprocess/sync/interprocess_condition.hpp&gt;</p> 
<p>l interprocess_condition:是一个匿名条件变量。可以在共享内存或者内存映射文件保存，和boost::interprocess::interprocess_mutex配合使用。</p> 
<p> </p> 
<p>#include &lt;boost/interprocess/sync/interprocess_condition_any.hpp</p> 
<p>l interprocess_condition_any:是一个匿名条件变量。可以在共享内存或者内存映射文件中保持。可以和任何锁类型配合使用。</p> 
<p> </p> 
<p>#include &lt;boost/interprocess/sync/named_condition.hpp&gt;</p> 
<p>l named_condition:是一个命名条件变量，需要和named_mutex配合使用</p> 
<p> </p> 
<p>#include &lt;boost/interprocess/sync/named_condition_any.hpp&gt;</p> 
<p>l named_condition_any:是一个命名条件变量，可以和任何锁一起使用。</p> 
<p> </p> 
<p>命名条件变量和匿名条件变量很相似，但是需要和命名互斥量配合使用。有时我们不希望将同步对象和同步数据一起保存。</p> 
<p>· We want to change the synchronization method (from interprocess to intra-process, or without any synchronization) using the same data. Storing the process-shared anonymous synchronization with the synchronized data would forbid this.</p> 
<p>· We want to send the synchronized data through the network or any other communication method. Sending the process-shared synchronization objects wouldn't have any sense.</p> 
<p> </p> 
<h4>6.3.3. <strong>匿名条件变量举例</strong></h4> 
<p>设想一个进程将日志写入一个简单的共享内存中，而另外一个进程逐条打印。第一个进程写日志并且等待其他进程打印。为了实现这样的功能，我们使用两个条件变量：第一个条件变量用于阻塞发送者直到第二个进程已经打印该信息；第二个条件变量用于阻塞接收者直到有新的日志可以打印。</p> 
<p>共享日志缓存定义在doc_anonymous_condition_shared_data.hpp中：</p> 
<p>#include &lt;boost/interprocess/sync/interprocess_mutex.hpp&gt;</p> 
<p>#include &lt;boost/interprocess/sync/interprocess_condition.hpp&gt;</p> 
<p> </p> 
<p>struct trace_queue</p> 
<p>{<!-- --></p> 
<p>enum { LineSize = 100 };</p> 
<p> </p> 
<p>trace_queue():message_in(false){}</p> 
<p> </p> 
<p>boost::interprocess::interprocess_mutex mutex;</p> 
<p>boost::interprocess::interprocess_condition cond_empty;</p> 
<p>boost::interprocess::interprocess_condittion cond_full;</p> 
<p> </p> 
<p>char items[LineSize];</p> 
<p>bool message_in;</p> 
<p>};</p> 
<p>这里是主进程。创建共享内存，写消息，直到写最后一条消息。</p> 
<p>#include &lt;boost/interprocess/shared_memory_object.hpp&gt;</p> 
<p>#include &lt;boost/interprocess/mapped_region.hpp&gt;</p> 
<p>#include &lt;boost/interprocess/sync/scoped_lock.hpp&gt;</p> 
<p>#include &lt;iostream&gt;</p> 
<p>#include &lt;cstdio&gt;</p> 
<p>#include “doc_anoymous_condition_shared_data.hpp&gt;</p> 
<p> </p> 
<p>using namespace boost::interprocess;</p> 
<p> </p> 
<p>int main()</p> 
<p>{<!-- --></p> 
<p>struct shm_remove</p> 
<p>{<!-- --></p> 
<p>shm_remove(){ shared_memory_object::remove(“MySharedMemory”); }</p> 
<p>~shm_remove(){ shared_memory_object::remove(“MySharedMemory”); }</p> 
<p>} remover;</p> 
<p> </p> 
<p>shared_memory_object shm(create_only,”MySharedMemory”,read_write);</p> 
<p>try{<!-- --></p> 
<p>shm.truncate( sizeof(trace_queue) );</p> 
<p>mapped_region region( shm,read_write);</p> 
<p> </p> 
<p>void * addr = region.get_address();</p> 
<p> </p> 
<p>trace_queue* data = new (addr) trance_queue;</p> 
<p> </p> 
<p>const int NumMsg = 100;</p> 
<p>for( int i=0;i&lt;NumMsg;++i ){<!-- --></p> 
<p>scoped_lock&lt;interprocess_mutex&gt; lock(data-&gt;mutex);</p> 
<p>if( data-&gt;message_in ){<!-- --></p> 
<p>data-&gt;cond_full.wait(lock);</p> 
<p>}</p> 
<p> </p> 
<p>if( i==(NumMsg-1) )</p> 
<p>std::sprintf( data-&gt;items,”%s”,”last message”);</p> 
<p>else</p> 
<p>std::sprintf( data-&gt;items,”%s_%d”,”my_trace”,i);</p> 
<p> </p> 
<p>data-&gt;cond_empty.notify_one();</p> 
<p>data-&gt;message_in = true;</p> 
<p>}</p> 
<p>}catch( interprocess_exception &amp; ex ){<!-- --></p> 
<p>std::cout &lt;&lt; ex.what() &lt;&lt; std::endl;</p> 
<p>return 1;</p> 
<p>}</p> 
<p>return 0;</p> 
<p>}</p> 
<p>第二个进程打开共享内存并且打印消息。</p> 
<p>#include &lt;boost/interprocess/shared_memory_object.hpp&gt;</p> 
<p>#include &lt;boost/interprocess/mapped_region.hpp&gt;</p> 
<p>#include &lt;boost/interprocess/sync/scoped_lock.hpp&gt;</p> 
<p>#include &lt;iostream&gt;</p> 
<p>#include &lt;cstring&gt;</p> 
<p>#include “doc_anoymous_condition_shared_data.hpp&gt;</p> 
<p> </p> 
<p>using namespace boost::interprocess;</p> 
<p> </p> 
<p>int main(){<!-- --></p> 
<p>shared_memory_object shm( open_only,”MySharedMemory”,read_write);</p> 
<p>try{<!-- --></p> 
<p>mapped_region region( shm,read_write);</p> 
<p>void * addr = region.get_address();</p> 
<p> </p> 
<p>trace_queue* data = static_cast&lt;trace_queue*&gt;(addr);</p> 
<p> </p> 
<p>bool end_loop = false;</p> 
<p>do{<!-- --></p> 
<p>scoped_lock&lt;interprocess_mutex&gt; lock(data-&gt;mutex);</p> 
<p>if( !data-&gt;message_in ){<!-- --></p> 
<p>data-&gt;cond_empty.wait(lock);</p> 
<p>}</p> 
<p> </p> 
<p>if( std::strcmp(data-&gt;items,”last message”)==0 )</p> 
<p>end_loop = true;</p> 
<p>else{<!-- --></p> 
<p>std::cout &lt;&lt; data-&gt;items &lt;&lt; std::endl;</p> 
<p>data-&gt;message_in = false;</p> 
<p>data-&gt;cond_full.notify_one();</p> 
<p>}</p> 
<p>} while( !end_loop );</p> 
<p>}catch( interprocess_exception&amp; ex ){<!-- --></p> 
<p>std::cout &lt;&lt; ex.what() &lt;&lt;std::endl;</p> 
<p>return 1;</p> 
<p>}</p> 
<p>return 0;</p> 
<p>}</p> 
<p>因为条件变量，进程可以阻塞自己，而当可继续执行的条件满足时，其他进程可以唤醒它。</p> 
<p> </p> 
<h3>6.4. <strong>信号量</strong></h3> 
<h4>6.4.1. <strong>信号量是什么？</strong></h4> 
<p>信号量是一种进程间的同步机制。基于一个内部计数。</p> 
<p>l 等待：测试信号量的计数，如果小于等于0，则等待。否则，减少计数。</p> 
<p>l 公布：增加信号量的计数。如果有阻塞的进程，那么唤醒其中之一。</p> 
<p> </p> 
<p>如果初始信号量计数为1，等待操作就等同于互斥量的锁操作，而公布操作就等同于解锁。这种锁也被称为二进制信号量。</p> 
<p>虽然信号量可以像互斥量一样用，它们却有个不同于互斥量的唯一特性，公布操作不要求由等待那个进程或线程来执行。谁都可以执行。</p> 
<h4>6.4.2. <strong>Boost.Interprocess的信号量类</strong></h4> 
<p>Boost.Interprocess提供如下类型的信号量：</p> 
<p>#include &lt;boost/interprocess/sync/interprocess_semaphore.hpp&gt;</p> 
<p>l interprocess_semaphore:是一种匿名信号量，可以保存到共享内存或者内存映射文件中。</p> 
<p> </p> 
<p>#include &lt;boost/interprocess/sync/named_semaphore.hpp&gt;</p> 
<p>l named_semaphore:是一种命名信号量</p> 
<h4>6.4.3. <strong>匿名信号量使用举例</strong></h4> 
<p>我们将在共享内存中实现一个整数数组。用于在进程间传递数据。第一个进程将会写一些整数到数组中，如果数组已经满了，则会阻塞。</p> 
<p>第二个进程会拷贝发送过来的数据，如果没有新的数据，将会阻塞。</p> 
<p>公共的整数数组定义在doc_anonymous_semaphore_shared_data.hpp中：</p> 
<p>#include &lt;boost/interprocess/sync/interprocess_semaphore.hpp&gt;</p> 
<p>struct shared_memory_buffer{<!-- --></p> 
<p>enum { NumItems = 10 };</p> 
<p>shared_memory_buffer():mutex(1),nempty(NumItems),nstored(0){}</p> 
<p> </p> 
<p>boost::interprocess::interprocess_semaphore mutex, nempty, nstored;</p> 
<p>int items[NumItems];</p> 
<p>};</p> 
<p>下面是主处理进程。创建共享内存，放入整数到整数数组，满了则阻塞。</p> 
<p>#include &lt;boost/interprocess/shared_memory_object.hpp&gt;</p> 
<p>#include &lt;boost/interprocess/mapped_region.hpp&gt;</p> 
<p>#include &lt;iostream&gt;</p> 
<p>#include “doc_anonymous_semaphore_shared_data.hpp”</p> 
<p> </p> 
<p>using namespace boost::interprocess;</p> 
<p>int main(){<!-- --></p> 
<p>struct shm_remove{<!-- --></p> 
<p>shm_remove() {  shared_memory_object::remove(“MySharedMemory”); }</p> 
<p>~shm_remove() { shared_memory_object::remove( “MySharedMemory”); }</p> 
<p>} remover;</p> 
<p> </p> 
<p>shared_memory_object shm( create_only, “MySharedMemory”,read_write );</p> 
<p> </p> 
<p>shm.truncate( sizeof(shared_memory_buffer));</p> 
<p>mapped_region region( shm,read_write);</p> 
<p> </p> 
<p>void* addr = region.get_address();</p> 
<p>shared_memory_buffer * data = new (addr) shared_memory_buffer;</p> 
<p> </p> 
<p>const int NumMsg = 100;</p> 
<p> </p> 
<p>for( int i=0;i&lt;NumMsg;++i ){<!-- --></p> 
<p>data-&gt;nempty.wait();</p> 
<p>data-&gt;mutex.wait();</p> 
<p>data-&gt;items( i% shared_memory_buffer::NumItems] = i;</p> 
<p>data-&gt;mutex.post();</p> 
<p>data-&gt;nstored.post();</p> 
<p>}</p> 
<p>return 0;</p> 
<p>}</p> 
<p>第二个进程打开共享内存并且拷贝接收到的数据到其自己缓冲区：</p> 
<p>#include &lt;boost/interprocess/shared_memory_object.hpp&gt;</p> 
<p>#include &lt;boost/interprocess/mapped_region.hpp&gt;</p> 
<p>#include &lt;iostream&gt;</p> 
<p>#include “doc_anonymous_semaphore_shared_data.hpp”</p> 
<p> </p> 
<p>using namespace boost::interprocess;</p> 
<p> </p> 
<p>int main(){<!-- --></p> 
<p>struct shm_remove{<!-- --></p> 
<p>~shm_remove(){ shared_memory_object::remove(“MySharedMemory”);}</p> 
<p>} remover;</p> 
<p> </p> 
<p>shared_memory_object shm( open_only,”MySharedMemory”,read_write);</p> 
<p>mapped_region region( shm, read_write );</p> 
<p> </p> 
<p>void * addr = region.get_address();</p> 
<p> </p> 
<p>shared_memory_buffer * data = static_cast&lt;shared_memory_buffer*&gt;( addr );</p> 
<p>const int NumMsg = 100;</p> 
<p>int extracte_data[NumMsg];</p> 
<p> </p> 
<p>for( int i=0;i&lt;NumMsg;++i ){<!-- --></p> 
<p>data-&gt;nstored.wait();</p> 
<p>data-&gt;mutex.wait();</p> 
<p>extracted_data[i] = data-&gt;items[i%shared_memory_buffer::NumItems];</p> 
<p>data-&gt;mutex.post();</p> 
<p>data-&gt;nempty.post();</p> 
<p>}</p> 
<p>return 0;</p> 
<p>}</p> 
<p>同样的进程间通信可以使用条件变量和互斥量来实现，但是有些同步模式，使用信号量更有效。</p> 
<h3>6.5. <strong>可共享和可升级的互斥量</strong></h3> 
<h4>6.5.1. <strong>可共享和可升级的互斥量是什么？</strong></h4> 
<p>可共享和可升级互斥量是特殊的互斥量类型，比普通互斥量多一些锁的可能，我们可以考虑读取数据和修改数据。如果有些线程需要修改相同数据，那么一个普通互斥量用来保护数据防止并发访问，并发被很好的限制：两个线程读数据将会被顺序安排而不是并发执行。</p> 
<p>如果我们允许读数据可以并发，而避免都和修改或者都修改的线程并发，显然我们可以提高性能。在应用中，这尤其是肯定的。数据读取比数据修改更加普遍。共享锁有两种锁类型：</p> 
<p>l 独占锁：与普通互斥量类似。如果一个线程获取到一个独占锁，其他线程只能在该线程释放锁之后才能获取锁，不管是独占的还是其他的。如果其他线程有其他的非独占锁，线程想要获得独占锁，将会被阻塞。独占锁应该被那些需要修改数据的线程获取。</p> 
<p>l 共享锁：如果一个线程获取到共享锁，其他线程不能获取独占锁。如果其他线程获取独占锁，线程想要获取共享锁将被阻塞。共享锁应该被那些需要读数据的线程取得。</p> 
<p> </p> 
<p>而可升级的互斥量增加一个升级锁：</p> 
<p>l 升级锁：获取一个升级锁，类似于获取一个特权共享锁。如果一个线程获取一个升级锁，其他线程可以获取共享锁。如果任何线程获取了排他锁或者升级锁，线程想要获取升级锁，就会被阻塞。已经取得升级锁的线程，可以确保自动获取一个排他锁，当其他线程已经获取共享锁的线程释放时。这个可以用于那些可能需要修改数据，但是大部分时间是读数据的线程。该线程获取升级锁，而其他线程可以获取共享锁。如果升级锁线程读取数据，然后还需要修改数据，线程可以提示获取一个排他锁：当所有共享线程是否它们的共享锁时，升级锁自动升级为独占锁。只能有一个线程可以获取升级锁。</p> 
<p> </p> 
<p>小结：</p> 
<table><tbody><tr><td> <p><strong>If a thread has acquired the... </strong></p> </td><td> <p><strong>Other threads can acquire... </strong></p> </td></tr><tr><td> <p>Sharable lock</p> </td><td> <p>many sharable locks</p> </td></tr><tr><td> <p>Exclusive lock</p> </td><td> <p>no locks</p> </td></tr></tbody></table> 
<p> </p> 
<p> </p> 
<table><tbody><tr><td> <p><strong>If a thread has acquired the... </strong></p> </td><td> <p><strong>Other threads can acquire... </strong></p> </td></tr><tr><td> <p>Sharable lock</p> </td><td> <p>many sharable locks and 1 upgradable lock</p> </td></tr><tr><td> <p>Upgradable lock</p> </td><td> <p>many sharable locks</p> </td></tr><tr><td> <p>Exclusive lock</p> </td><td> <p>no locks</p> </td></tr></tbody></table> 
<p> </p> 
<h4>6.5.2. <strong>可升级互斥量的锁转移</strong></h4> 
<p>一个可共享的互斥量没办法自动将获取到的锁转变成其他锁。</p> 
<p>另一方面，对于一个可升级的互斥量，已经获取该锁的线程可以尝试自动获取另外锁。所有锁转换不能保证全部成功。自动意味着在转换过程中没有其他线程会取得升级锁或者独占锁，因此数据不会被修改。</p> 
<table><tbody><tr><td> <p><strong>If a thread has acquired the... </strong></p> </td><td> <p><strong>It can atomically release the previous lock and... </strong></p> </td></tr><tr><td> <p>Sharable lock</p> </td><td> <p>try to obtain (not guaranteed) immediately the Exclusive lock if no other thread has exclusive or upgrable lock</p> </td></tr><tr><td> <p>Sharable lock</p> </td><td> <p>try to obtain (not guaranteed) immediately the Upgradable lock if no other thread has exclusive or upgrable lock</p> </td></tr><tr><td> <p>Upgradable lock</p> </td><td> <p>obtain the Exclusive lock when all sharable locks are released</p> </td></tr><tr><td> <p>Upgradable lock</p> </td><td> <p>obtain the Sharable lock immediately</p> </td></tr><tr><td> <p>Exclusive lock</p> </td><td> <p>obtain the Upgradable lock immediately</p> </td></tr><tr><td> <p>Exclusive lock</p> </td><td> <p>obtain the Sharable lock immediately</p> </td></tr></tbody></table> 
<p>我们可以看出，可升级互斥量是一个强大的机制工具，可以提升并发性。然而，如果大部分时间我们需要修改数据，或者同步代码段非常短，使用普通互斥量可能效率更高。</p> 
<h4>6.5.3. <strong>可升级互斥量操作</strong></h4> 
<p>所有Boost.Interprocess的可升级互斥量类型实现以下操作：</p> 
<p>6.5.3.1. <strong>独占锁定（可共享的和可升级的互斥量)</strong></p> 
<p>l void lock():调用该函数的线程一直获取独占锁。错误时抛出interprocess_exception。</p> 
<p>l bool try_lock():调用该函数的线程尝试获取独占锁。如果有其他线程持有锁（独占锁或其他），则立即返回失败，否则立即返回成功。如果错误则抛出interprocess_exception。</p> 
<p>l bool timed_lock( const boost::posix_time::ptime &amp; abs_time ):调用线程在预期的时间内获取独占锁。</p> 
<p>l void unlock():前提是该线程必须已经独占该互斥量。</p> 
<p>6.5.3.2. <strong>共享锁定（可共享和可升级的互斥量）</strong></p> 
<p>l void lock_sharable():调用该函数的线程尝试获取该互斥量的共享所有权，如果其他线程拥有该线程的独占所有权，该线程将一直等待，直到获取共享所有权成功。如果有错误则抛出interprocess_exception。</p> 
<p>l bool try_lock_sharable():调用该函数的线程无等待地尝试获取该互斥量的共享所有权。如果没有其他线程有排他所有权，则成功。</p> 
<p>l bool timed_lock_sharable( const boost::posix_time::ptime &amp;abs_time ):</p> 
<p>l void unlock_sharable():</p> 
<p>6.5.3.3. <strong>升级锁定（可升级互斥量）</strong></p> 
<p>l void lock_upgradable(): 调用线程尝试获取升所有权，如果其他线程有互斥权限或者升级权限，线程一直阻塞直到成功获取。</p> 
<p>l bool try_lock_upgradable()</p> 
<p>l bool timed_lock_upgradable( const boost::posix_time::ptime &amp; abs_time )</p> 
<p>l void unlock_upgradable()</p> 
<p>6.5.3.4. <strong>下调（可升级互斥量）</strong></p> 
<p>l void unlock_and_lock_upgradable():前提条件是该线程已经获取到独占锁。线程自动释放独占所有权，并且获取升级所有权。该操作非阻塞的。</p> 
<p>l void unlock_and_lock_sharable(): 前提条件是该线程已经取得独占权限。线程自动释放独占所有权，并且获取共享所有权。该操作非阻塞。</p> 
<p>l void unlock_upgradable_and_lock_sharable(): 前提是线程已经取得可升级权限。线程自动释放可升级权限，并且获取共享权限。该操作非阻塞。</p> 
<p>6.5.3.5. <strong>提升（可升级互斥量）</strong></p> 
<p>l void unlock_upgradable_and_lock(): 前提是线程已经取得可升级权限。线程自动释放可升级权限，并且尝试获取独占权限。该操作会阻塞线程直到所有共享线程释放。</p> 
<p>l bool try_unlock_upgradable_and_lock()：前提是线程已经获取到可升级权限。</p> 
<p>l bool timed_unlock_upgradable_and_lock( const boost::posix_time::ptime &amp; abs_time ):</p> 
<p>l bool try_unlock_sharable_and_lock():</p> 
<p>l bool try_unlock_sharable_and_lock_upgradable():</p> 
<p> </p> 
<h4>6.5.4. <strong>Boost.Interprocess可共享且可升级互斥量类型</strong></h4> 
<p>Boost.Interprocess提供如下可共享互斥量：</p> 
<p>#include &lt;boost/interprocess/sync/interprocess_sharable_mutex.hpp&gt;</p> 
<p>l interprocess_sharable_mutex:是一个非递归的，匿名共享互斥量。可以保存到共享内存或者内存映射文件中。</p> 
<p> </p> 
<p>#include &lt;boost/interprocess/sync/named_sharable_mutex.hpp&gt;</p> 
<p>l named_sharable_mutex:是一个非递归的，命名共享互斥量。</p> 
<p> </p> 
<p>#include &lt;boost/interprocess/sync/interprocess_upgradable_mutex.hpp&gt;</p> 
<p>l interprocess_upgradable_mutex:是一个非递归的，匿名可升级互斥量。可以保存到共享内存或者内存映射文件中。</p> 
<p> </p> 
<p>#include &lt;boost/interprocess/sync/named_upgradable_mutex.hpp&gt;</p> 
<p>l named_upgradable_mutex: 是一个非递归的，命名可升级互斥量。</p> 
<h4>6.5.5. <strong>可共享锁和可升级锁</strong></h4> 
<p>对于普通互斥量，释放已经取得的锁是非常重要的，即使是遇到异常抛出。Boost.Interprocess互斥量最好和scoped_lock工具配合使用，但是这个类只提供独占锁。</p> 
<p>可是我们还有共享锁定和升级锁定，以及可升级互斥量，我们有两个新的工具：sharable_lock和upgradable_lock。两种类型和scoped_lock相似，只是sharable_lock在构造函数中获取的是共享锁，而upgradable_lock在构造函数中获取的是可升级锁。</p> 
<p>这两种设施可以和任何同步对象一起使用。例如：用户定义互斥量类型没有课升级锁特性，可以和sharable_lock如果同步对象提供lock_sharable()函数和unlock_sharable()操作。</p> 
<p>6.5.5.1. <strong>共享锁定和升级锁定头文件</strong></p> 
<p>#include &lt;boost/interprocess/sync/sharable_lock.hpp&gt;</p> 
<p>#include &lt;boost/interprocess/sync/upgradable_lock.hpp&gt;</p> 
<p>sharable_lock调用unlock_sharable()在其析构函数中，而upgradable_lock在其析构函数中调用unlock_upgradable()函数。所以，可升级互斥量总是被解锁，就算是异常发生了。</p> 
<p>using namespace boost::interprocess;</p> 
<p>SharableOrUpgradableMutex sh_or_up_mutex;</p> 
<p> </p> 
<p>{<!-- --></p> 
<p>sharable_lock&lt;SharableOrUpgradableMutex&gt; lock(sh_or_up_mutex);</p> 
<p>// some code</p> 
<p>// The mutex will be unlocked here</p> 
<p>}</p> 
<p> </p> 
<p>{<!-- --></p> 
<p>// 这个构造函数不会自动锁定</p> 
<p>sharable_lock&lt;SharableOrUpgradableMutex&gt; lock(sh_or_up_mutex, defer_lock);</p> 
<p> </p> 
<p>lock.lock();</p> 
<p> </p> 
<p>// some code</p> 
<p>// 互斥量会被自动解锁</p> 
<p>}</p> 
<p> </p> 
<p>{<!-- --></p> 
<p>   //This will call try_lock_sharable()</p> 
<p>   sharable_lock&lt;SharableOrUpgradableMutex&gt; lock(sh_or_up_mutex, try_to_lock);</p> 
<p> </p> 
<p>   //Check if the mutex has been successfully locked</p> 
<p>   if(lock){<!-- --></p> 
<p>      //Some code</p> 
<p>   }</p> 
<p>   //If the mutex was locked it will be unlocked</p> 
<p>}</p> 
<p> </p> 
<p>{<!-- --></p> 
<p>   boost::posix_time::ptime abs_time = ...</p> 
<p> </p> 
<p>   //This will call timed_lock_sharable()</p> 
<p>   scoped_lock&lt;SharableOrUpgradableMutex&gt; lock(sh_or_up_mutex, abs_time);</p> 
<p> </p> 
<p>   //Check if the mutex has been successfully locked</p> 
<p>   if(lock){<!-- --></p> 
<p>      //Some code</p> 
<p>   }</p> 
<p>   //If the mutex was locked it will be unlocked</p> 
<p>}</p> 
<p> </p> 
<p>UpgradableMutex up_mutex;</p> 
<p> </p> 
<p>{<!-- --></p> 
<p>   //This will call lock_upgradable()</p> 
<p>   upgradable_lock&lt;UpgradableMutex&gt; lock(up_mutex);</p> 
<p> </p> 
<p>   //Some code</p> 
<p> </p> 
<p>   //The mutex will be unlocked here</p> 
<p>}</p> 
<p> </p> 
<p>{<!-- --></p> 
<p>   //This won't lock the mutex()</p> 
<p>   upgradable_lock&lt;UpgradableMutex&gt; lock(up_mutex, defer_lock);</p> 
<p> </p> 
<p>   //Lock it on demand. This will call lock_upgradable()</p> 
<p>   lock.lock();</p> 
<p> </p> 
<p>   //Some code</p> 
<p> </p> 
<p>   //The mutex will be unlocked here</p> 
<p>}</p> 
<p> </p> 
<p>{<!-- --></p> 
<p>   //This will call try_lock_upgradable()</p> 
<p>   upgradable_lock&lt;UpgradableMutex&gt; lock(up_mutex, try_to_lock);</p> 
<p> </p> 
<p>   //Check if the mutex has been successfully locked</p> 
<p>   if(lock){<!-- --></p> 
<p>      //Some code</p> 
<p>   }</p> 
<p>   //If the mutex was locked it will be unlocked</p> 
<p>}</p> 
<p> </p> 
<p>{<!-- --></p> 
<p>   boost::posix_time::ptime abs_time = ...</p> 
<p> </p> 
<p>   //This will call timed_lock_upgradable()</p> 
<p>   scoped_lock&lt;UpgradableMutex&gt; lock(up_mutex, abs_time);</p> 
<p> </p> 
<p>   //Check if the mutex has been successfully locked</p> 
<p>   if(lock){<!-- --></p> 
<p>      //Some code</p> 
<p>   }</p> 
<p>   //If the mutex was locked it will be unlocked</p> 
<p>}</p> 
<p> </p> 
<h3>6.6. <strong>通过Move语法锁转移</strong></h3> 
<p>Interprocess使用其自己的move语法仿真代码为那些不支持右值操作的编译器。这只是个临时的解决办法，直到Boost move语义库被引入。</p> 
<p>范围锁及其相似设施提供简单资源管理的可能，但是对于高级互斥量，比如可升级互斥量，就存在操作自动释放锁又获取另外锁。这个时候使用可升级互斥量的unlock_and_lock_sharable()之类的操作了。</p> 
<p>这些操作可以使用锁转移操作管理更有效。一个锁转移操作明确表示一个互斥量的锁转移到另外锁执行自动解锁加上锁操作。</p> 
<h4>6.6.1. <strong>简单锁转移</strong></h4> 
<p>设想一个线程最开始修改了一些数据，然后，需要在很长一段时间内读取该数据。代码可以获取独占锁，修改数据并且自动释放独占锁和锁定共享锁。</p> 
<h4>6.6.2. <strong>锁转移总结</strong></h4> 
<h4>6.6.3. <strong>转移未上锁的锁</strong></h4> 
<h4>6.6.4. <strong>转移失败</strong></h4> 
<h3>6.7. <strong>文件锁</strong></h3> 
<p> </p> 
<h3>6.8. <strong>消息队列</strong></h3> 
<p> </p> 
<h2>7. <strong>被管的内存段</strong></h2> 
<h2>8. <strong>分配器、容器和内存分配算法</strong></h2> 
<h2>9. <strong>内存分配算法</strong></h2> 
<h2>10. <strong>直接IO流格式化：向量流和缓存流</strong></h2> 
<h2>11. <strong>权限精灵指针</strong></h2> 
<h2>12. <strong>体系结构和内幕</strong></h2> 
<h2>13. <strong>用户定制Boost.Interprocess</strong></h2> 
<h2>14. <strong>感谢、提示和连接</strong></h2> 
<h2>15. <strong>索引和参考</strong></h2>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bd9a80f409cede1839ec6a79eac93f54/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java 构造函数的详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a677e1afa54fde30cd5a7b790b8c40d3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">使用 adb 命令一次性为多个设备安装 apk</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>