<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>什么是好的FPGA编码风格？（3）--尽量不要使用锁存器Latch - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="什么是好的FPGA编码风格？（3）--尽量不要使用锁存器Latch" />
<meta property="og:description" content="前言 在FPGA设计中，几乎没人会主动使用锁存器Latch，但有时候不知不觉中你的设计莫名其妙地就生成了一堆Latch，而这些Latch可能会给你带来巨大的麻烦。
什么是锁存器Latch？ Latch，锁存器，一种可以存储电路状态信息的组合逻辑元件，和同样可以保存电路状态的时序逻辑元件–触发器（Flip-Flop，FF）不同，锁存器只在其使能端口有效时，将输入传递给输出；而在其使能端口无效时，输出则保持不变，就像被“锁住储存”起来了一样。
下图是一个典型的Latch的门电路结构。当使能信号E无效时，两个与门的输出均为0，对后面的SR锁存器即或非门无影响，所以无论输入D的值为1或0，输出Q的值都不会改变，就像被“锁住”了。
当使能信号E有效且输入D为1时，两个与门的输出分别为0和1、此时的输出Q值为1，与输入D一致。
当使能信号E有效且输入D为0时，两个与门的输出分别为1和0、此时的输出Q值为0，同样与输入D一致。
Latch有什么危害？ 当Latch的使能信号有效时，直接让输入信号通过，使得输出完全等于输入。这一特性无疑会很容易地引入毛刺，使得设计不稳定；其次，Latch没有时钟信号，是一个异步电路元件，这就使得综合工具对Latch的静态时序分析十分困难。
而同步逻辑所使用的触发器FF，它的典型结构是这样的，由2个Latch&#43;1个反相器组成。
当时钟信号Clock为高电平时，第1个Latch的使能有效，输入数据直接通过；由于反向器的存在，第2个Latch的使能端无效，所以其输出保持不变。
当时钟信号Clock为低电平时，第1个Latch使能无效，其输出保持不变，而这个输出也就是在时钟信号处于下降沿时的输入信号；由于反向器的存在，第2个Latch的使能端有效，输入直接传递到输出，此时最终输出的是在时钟下降沿时采集的输入信号。
可以看到，在同步电路中，FF的输出只在时钟边沿（这里是下降沿）变化，而在其他时间是保持不变的，这样一来，即使某些时刻在输入上出现了毛刺，但只要这个毛刺不发生在时钟边沿，那它就不会传递到输出进而影响后面的电路。
显然，同一个时钟周期比起来，时钟边沿持续的时间实在是微不足道，所以这大大降低了毛刺影响电路的概率。这也是同步电路相对于异步电路的一个大优点。
什么样的代码会生成Latch 下面的一些代码风格是会生成Latch的：
if-else语句不完整的组合逻辑 在组合逻辑中，如果if-else语句没有写完整的话，是会生成Latch的（不管你是有意还是无意的），因为缺失掉的条件会被综合工具理解成不变，即锁存。
module test( input data, input en, output reg	q ); always@(*)begin if(en) q = data; end endmodule Vivado中生成的RTL电路如下–一个Latch。
生成Latch的时候，Vivado也会报警告，所以设计的时候请务必多多关注这些信息！
有些时候，尽管你的if-else语句已经很完整了，也还是会生成Latch，就像这样：
module test( input data, input en, output reg	q ); always@(*)begin if(en) q = data; else	q = q;	//输出反馈给了输入，相当于没变 end endmodule 这是因为输出直接反馈给了输入，使得输出等于输入，相当于没变化，依然是被锁存住了。
消除Latch的方法有两种：
1、补全if-else语句。注意不能将输出反馈给输入，而是应该给输入赋一个其他值，例如0、1或其他变量。 module test( input data, input en, output reg	q ); always@(*)begin if(en) q = data; else	q = 1&#39;b0;	//q = 1&#39;b1也可以 end endmodule 2、赋初值。在条件语句之前给输出一个初始值。 module test( input data, input en, output reg	q ); always@(*)begin q = 1&#39;b0;	//q = 1&#39;b1也可以 if(en) q = data; end endmodule 两种方法中推荐第一种方法，因为比较规范，代码风格容易统一。这样的代码不会生成Latch，而是生成一个组合逻辑用的2选1MUX：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/df6ab7a6a6397a9a09bc8ebac52d2be4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-27T07:36:41+08:00" />
<meta property="article:modified_time" content="2023-11-27T07:36:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">什么是好的FPGA编码风格？（3）--尽量不要使用锁存器Latch</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>前言</h2> 
<p>在FPGA设计中，几乎没人会主动使用<strong>锁存器Latch</strong>，但有时候不知不觉中你的设计莫名其妙地就生成了一堆Latch，而这些Latch可能会给你带来巨大的麻烦。</p> 
<h2><a id="Latch_3"></a>什么是锁存器Latch？</h2> 
<p>Latch，锁存器，一种可以存储电路状态信息的组合逻辑元件，和同样可以保存电路状态的时序逻辑元件–触发器（Flip-Flop，FF）不同，锁存器只在其使能端口有效时，将输入传递给输出；而在其使能端口无效时，输出则保持不变，就像被“<strong>锁住储存</strong>”起来了一样。</p> 
<p>下图是一个典型的Latch的门电路结构。当使能信号E<strong>无效</strong>时，两个与门的输出均为0，对后面的SR锁存器即或非门无影响，所以无论输入D的值为1或0，输出Q的值都不会改变，就像被“<strong>锁住</strong>”了。<br> <img src="https://images2.imgbox.com/20/e9/aiQ15LUy_o.png" alt="在这里插入图片描述"><br> 当使能信号E<strong>有效</strong>且输入D为1时，两个与门的输出分别为0和1、此时的输出Q值为1，与输入D一致。<br> <img src="https://images2.imgbox.com/c3/62/yTOOUz6h_o.png" alt="在这里插入图片描述"><br> 当使能信号E<strong>有效</strong>且输入D为0时，两个与门的输出分别为1和0、此时的输出Q值为0，同样与输入D一致。<br> <img src="https://images2.imgbox.com/47/0f/12BWLNM1_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="Latch_12"></a>Latch有什么危害？</h2> 
<p>当Latch的使能信号有效时，直接让输入信号通过，使得输出完全等于输入。这一特性无疑会很容易地引入毛刺，使得设计不稳定；其次，Latch没有时钟信号，是一个异步电路元件，这就使得综合工具对Latch的静态时序分析十分困难。</p> 
<p>而同步逻辑所使用的触发器FF，它的典型结构是这样的，由2个Latch+1个反相器组成。<br> 当时钟信号Clock为高电平时，第1个Latch的使能有效，输入数据直接通过；由于反向器的存在，第2个Latch的使能端无效，所以其输出保持不变。<br> <img src="https://images2.imgbox.com/e1/ec/ALTcoNNO_o.png" alt="在这里插入图片描述"><br> 当时钟信号Clock为低电平时，第1个Latch使能无效，其输出保持不变，而这个输出也就是在时钟信号处于下降沿时的输入信号；由于反向器的存在，第2个Latch的使能端有效，输入直接传递到输出，此时最终输出的是在时钟下降沿时采集的输入信号。<br> <img src="https://images2.imgbox.com/36/f3/i8X9Vj3m_o.png" alt="在这里插入图片描述"><br> 可以看到，在同步电路中，FF的输出只在时钟边沿（这里是下降沿）变化，而在其他时间是保持不变的，这样一来，即使某些时刻在输入上出现了毛刺，但只要这个毛刺不发生在时钟边沿，那它就不会传递到输出进而影响后面的电路。</p> 
<p>显然，同一个时钟周期比起来，时钟边沿持续的时间实在是微不足道，所以这大大降低了毛刺影响电路的概率。这也是同步电路相对于异步电路的一个大优点。</p> 
<h2><a id="Latch_24"></a>什么样的代码会生成Latch</h2> 
<p>下面的一些代码风格是会生成Latch的：</p> 
<h3><a id="ifelse_26"></a>if-else语句不完整的组合逻辑</h3> 
<p>在组合逻辑中，如果if-else语句没有写完整的话，是会生成Latch的（不管你是有意还是无意的），因为缺失掉的条件会被综合工具理解成不变，即锁存。</p> 
<pre><code>module test(
	input 		data,
	input 		en,
	output reg	q
);

always@(*)begin
	if(en)
		q = data;
end

endmodule
</code></pre> 
<p>Vivado中生成的RTL电路如下–一个Latch。<br> <img src="https://images2.imgbox.com/0d/ff/9xBIdzbx_o.png" alt="在这里插入图片描述"><br> 生成Latch的时候，Vivado也会报警告，所以设计的时候请务必<strong>多多关注这些信息！</strong><br> <img src="https://images2.imgbox.com/1e/f4/cY9Z1wih_o.png" alt="在这里插入图片描述"><br> 有些时候，尽管你的if-else语句已经很完整了，也还是会生成Latch，就像这样：</p> 
<pre><code>module test(
	input 		data,
	input 		en,
	output reg	q
);

always@(*)begin
	if(en)
		q = data;
	else	
		q = q;		//输出反馈给了输入，相当于没变
end

endmodule
</code></pre> 
<p>这是因为输出直接反馈给了输入，使得输出等于输入，相当于没变化，依然是被锁存住了。</p> 
<p>消除Latch的方法有两种：</p> 
<ul><li>1、<strong>补全if-else语句</strong>。注意不能将输出反馈给输入，而是应该给输入赋一个其他值，例如0、1或其他变量。</li></ul> 
<pre><code>module test(
	input 		data,
	input 		en,
	output reg	q
);

always@(*)begin
	if(en)
		q = data;
	else	
		q = 1'b0;		//q = 1'b1也可以
end

endmodule
</code></pre> 
<ul><li><strong>2、赋初值</strong>。在条件语句之前给输出一个初始值。</li></ul> 
<pre><code>module test(
	input 		data,
	input 		en,
	output reg	q
);

always@(*)begin
		q = 1'b0;		//q = 1'b1也可以
	if(en)
		q = data;
end

endmodule
</code></pre> 
<p>两种方法中<strong>推荐第一种方法</strong>，因为比较规范，代码风格容易统一。这样的代码不会生成Latch，而是生成一个组合逻辑用的2选1MUX：<br> <img src="https://images2.imgbox.com/63/d2/6Y32Xd22_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="case_106"></a>case语句不完整的组合逻辑</h3> 
<p>与if-else句类似，如果case语句的分支没有列举完全，也是会生成Latch的，比如这样：</p> 
<pre><code>module test(
	input 		data0,data1,
	input		sel,
	output reg	q
);

always@(*)begin
	case(sel)
		1'b0: q = data0;
	endcase
end

endmodule
</code></pre> 
<p>Vivado中生成的RTL电路会有Latch：<br> <img src="https://images2.imgbox.com/bc/a5/kJTV3oxn_o.png" alt="在这里插入图片描述"><br> 类似的，有些时候尽管你的case语句已经很完整了，但因为出现了反馈语句（即输出反馈给输入）也还是会生成Latch，就像这样：</p> 
<pre><code>module test(
	input 		data0,data1,
	input		sel,
	output reg	q
);

always@(*)begin
	case(sel)
		1'b0: q = data0;
		1'b1: q = q;		//反馈语句
	endcase
end

endmodule
</code></pre> 
<p>消除锁存器的方法有三种：</p> 
<ul><li>1、<strong>补全case语句</strong>。注意不能将输出反馈给输入，而是应该赋一个其他值，例如0、1或其他变量。</li></ul> 
<pre><code>module test(
	input 		data0,data1,
	input		sel,
	output reg	q
);

always@(*)begin
	case(sel)
		1'b0: q = data0;
		1'b1: q = data1;		
	endcase
end

endmodule
</code></pre> 
<ul><li><strong>2、赋初值</strong>。在case语句之前给输出一个初始值。</li></ul> 
<pre><code>module test(
	input 		data0,data1,
	input		sel,
	output reg	q
);

always@(*)begin
	q = data1;	
	case(sel)
		1'b0: q = data0;		
	endcase
end

endmodule
</code></pre> 
<ul><li><strong>3、使用default语句作为默认语句</strong>。default语句用来补充其他所有没有列举出来的结果。</li></ul> 
<pre><code>module test(
	input 		data0,data1,
	input		sel,
	output reg	q
);

always@(*)begin
		
	case(sel)
		1'b0: 		q = data0;
		default:	q = data1;
	endcase
end

endmodule
</code></pre> 
<p>在实践中，<strong>最推荐第三种写法</strong>。风格比较规范和统一。有时候编码的时候可能会把case语句的所有分支都列举出来，这种情况下<strong>依然建议保留default语句</strong>。</p> 
<p>这样的代码就不会生成Latch了，而是生成一个组合逻辑用的2选1MUX：<br> <img src="https://images2.imgbox.com/12/da/HhhCLBoi_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="Latch_199"></a>时序逻辑电路会生成Latch吗？</h3> 
<p>如果以上出现Latch的写法转换成时序逻辑，是否也会生成Latch？比如这样：</p> 
<pre><code>module test(
	input 		data,
	input 		en,
	input		clk,
	output reg	q
);

always@(posedge clk)begin
	if(en)
		q &lt;= data;
end

endmodule
</code></pre> 
<p>答案是不会。只会生成一个寄存器reg（实际上就是一个FF）。<br> <img src="https://images2.imgbox.com/f8/10/1GLOnqLB_o.png" alt="在这里插入图片描述"><br> 因为在时序逻辑中，即使不补全if-else语句，由于FF/REG的特性，它本身就可以在非时钟边沿存储数据，所以像这样的语句：</p> 
<blockquote> 
 <p>else q &lt;= q; //保存值</p> 
</blockquote> 
<p>写或不写在功能上都是一样的。但是在实践中，<strong>还是建议补全</strong>，目的是养成风格统一、良好的编码习惯。</p> 
<h2><a id="LatchFPGA_225"></a>Latch在FPGA中是什么情况？</h2> 
<p>网上有种说法：在FPGA设计中不使用Latch的一个很大原因是FPGA中没有现成的Latch资源，如果要用，则需要消耗非常多的资源来构建Latch。</p> 
<p>**这种说法是错的。**以Xilinx的7系列FPGA为例，Latch实际上是其内部存在的固定资源。一个Slice中有一半的逻辑资源可以被配置为Latch或FF，另一半只能被配置成FF。但是需要注意的是，如果Silice中的FF被配置成了Latch，那么剩余的4个FF就不能用了，这样确实是会造成资源的浪费。<br> <img src="https://images2.imgbox.com/ba/3e/v2ZexLBQ_o.png" alt="在这里插入图片描述"><br> Xilinx的7系列FPGA中的FF可以被配置成两种类型的Latch： <strong>LDCE和LDPE。</strong></p> 
<ul><li>异步复位的<strong>LDCE</strong>：比我们熟知的Latch多了一个<strong>异步复位</strong>端口。<br> <img src="https://images2.imgbox.com/94/9f/z9kkMZoj_o.png" alt="在这里插入图片描述"></li><li>异步置位的<strong>LDPE</strong>：比我们熟知的Latch多了一个<strong>异步置位</strong>端口。</li></ul> 
<p><img src="https://images2.imgbox.com/eb/38/1g9l3ZTL_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="LatchFPGA_238"></a>所以听起来似乎毫无用处的Latch，为什么还存在于FPGA中？</h2> 
<ul><li> <p>首先Latch是被做成了和部分FF二选一的一个器件，而不是独立器件，这确实也说明在FPGA设计中确实需求不高，不然肯定就做成了FF这种固定的底层器件了。但这样一来，也增加了FPGA底层资源的灵活性，保留了更多的设计可能。</p> </li><li> <p>其次，Latch在某些特定应用还是需要的，比如IC设计中的time borrowing来提高时序性能、门控时钟、某些总线接口用来锁存数据等。</p> </li></ul> 
<p>总之，Latch的用武之地<strong>确实有，但不多。</strong> 不是特殊需求，<strong>请尽量避免使用Latch！</strong></p> 
<hr> 
<ul><li>📣您有任何问题，都可以在评论区和我<strong>交流</strong>📃！</li><li>📣本文由 <strong>孤独的单刀</strong> 原创，首发于<strong>CSDN平台</strong>🐵，博客主页：<a href="https://wuzhikai.blog.csdn.net" rel="nofollow">wuzhikai.blog.csdn.net</a></li><li>📣您的支持是我持续创作的最大动力！如果本文对您有帮助，还请多多<strong>点赞👍、评论💬和收藏⭐</strong>！</li></ul> 
<hr>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7be0e8b6a3e292e9b57f9a352b3150e3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">如何下载OpenEuler Linux的iso镜像？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/42cc266f39e2b6b97de0d30ed64ccea0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MVC、MVP、MVVM三种区别及适用场合</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>