<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java中的clone()方法 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java中的clone()方法" />
<meta property="og:description" content="clone()方法的约定 Cloneable接口的目的是作为对象的一个混合接口，表明这样的对象允许克隆（clone），但是这个接口却没有定义clone()，这是它的缺陷：无法约束子类实现clone()方法。Object定义了一个受保护的clone()方法。Cloneable虽然没有定义clone()方法，但是却影响了Object.clone()方法的行为：如果一个类实现了Cloneable，调用Object的clone()就会返回该对象的逐域拷贝，否则抛出CloneNotSupportedException。这真是一种非常规的用法，Cloneable接口没有规定实现类的视图，却改变了父类受保护方法的行为。调用clone()会创建并返回对象的拷贝，看看JDK文档中对clone()方法的约定：
（1）x.clone() != x; 克隆对象与原对象不是同一个对象
（2）x.clone().getClass() == x.getClass(); 克隆的是同一类型的对象
（3）x.clone().equals(x) == true,如果x.equals()方法定义恰当的话
注意，上面的三条规则要求不是绝对的，一般来说前两条是必需的，第三个也应该尽量遵守。
实现Cloneable接口的类和其所有超类都必需遵守一个复杂、不可实施、且没有文档说明的协议，由此得到一种语言之外的机制：无需调用构造器就可以创建对象。然而，“不调用构造器”的规定有些僵硬，行为良好的clone()方法可以调用构造器创建对象，比如final类，它不会有子类，所以在它的clone()方法中调用构造器创建对象是一种合理的选择。
使用clone()的规则 “如果你覆盖了非final类中的clone方法，则应该返回一个通过调用super.clone()而得到的对象”，这是使用clone()方法的规则，如果不遵守这条规则，在clone()方法中调用了构造器，那么就会得到错误的类。如代码所示：
class A implements Cloneable { //类A的clone()直接调用构造器 public A clone() { return new A(); } } class B extends A { public B clone() { try { return (B) super.clone(); } catch (CloneNotSupportedException e) { throw new AssertionError(); } } } 类 B 的 clone() 方法就不会得到正确的对象，因为 super .clone() 返回的是使用 A 的构造器创建的类 A 的对象。如果类 B 的 clone 方法想得到正确的对象，那么 A 的 clone 方法应该这样写：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/78dc4f5e86c56e00f9e0b4ee167a901c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-12T11:18:22+08:00" />
<meta property="article:modified_time" content="2022-01-12T11:18:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java中的clone()方法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="clone_0"></a>clone()方法的约定</h3> 
<p>Cloneable接口的目的是作为对象的一个混合接口，表明这样的对象允许克隆（clone），但是这个接口却没有定义clone()，这是它的缺陷：无法约束子类实现clone()方法。Object定义了一个受保护的clone()方法。Cloneable虽然没有定义clone()方法，但是却影响了Object.clone()方法的行为：如果一个类实现了Cloneable，调用Object的clone()就会返回该对象的逐域拷贝，否则抛出CloneNotSupportedException。这真是一种非常规的用法，Cloneable接口没有规定实现类的视图，却改变了父类受保护方法的行为。调用clone()会创建并返回对象的拷贝，看看JDK文档中对clone()方法的约定：</p> 
<p>（1）x.clone() != x; 克隆对象与原对象不是同一个对象</p> 
<p>（2）x.clone().getClass() == x.getClass(); 克隆的是同一类型的对象</p> 
<p>（3）x.clone().equals(x) == true,如果x.equals()方法定义恰当的话</p> 
<p>注意，上面的三条规则要求不是绝对的，一般来说前两条是必需的，第三个也应该尽量遵守。</p> 
<p>实现Cloneable接口的类和其所有超类都必需遵守一个复杂、不可实施、且没有文档说明的协议，由此得到一种语言之外的机制：无需调用构造器就可以创建对象。然而，“不调用构造器”的规定有些僵硬，行为良好的clone()方法可以调用构造器创建对象，比如final类，它不会有子类，所以在它的clone()方法中调用构造器创建对象是一种合理的选择。</p> 
<h3><a id="clone_14"></a>使用clone()的规则</h3> 
<p>“如果你覆盖了非final类中的clone方法，则应该返回一个通过调用super.clone()而得到的对象”，这是使用clone()方法的规则，如果不遵守这条规则，在clone()方法中调用了构造器，那么就会得到错误的类。如代码所示：</p> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token keyword">implements</span> <span class="token class-name">Cloneable</span>
<span class="token punctuation">{<!-- --></span>   <span class="token comment">//类A的clone()直接调用构造器</span>
	<span class="token keyword">public</span> A <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">public</span> B <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">try</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token punctuation">(</span>B<span class="token punctuation">)</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CloneNotSupportedException</span> e<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">AssertionError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>类 B 的 clone() 方法就不会得到正确的对象，因为 super .clone() 返回的是使用 A 的构造器创建的类 A 的对象。如果类 B 的 clone 方法想得到正确的对象，那么 A 的 clone 方法应该这样写：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> A <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">try</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CloneNotSupportedException</span> e<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">AssertionError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>由此，我们可以看出调用super.clone()最终会调用Object类的clone方法，前提是子类的所有超类都遵循了上面的规则，否则无法实施。注意，A和B的clone方法的返回值不必是Object，Java1.5引入了协变返回类型作为泛型，覆盖方法的返回值可以是被覆盖方法返回值的子类。</p> 
<p>Cloneable实在是一个失败的接口，它并没有指明实现它的类需要承担哪些责任，通常情况下，实现Cloneable的类应当提供一个功能适当的公有的clone()方法。</p> 
<h3><a id="_58"></a>浅克隆</h3> 
<p>克隆出来的对象的所有变量含有与原来的对象相同的值，而对其他对象的引用都指向原来的对象。也就是说，浅克隆仅仅克隆所考虑的对象。Object的clone就是"shallow copy"。如果类的每个域都是基本类型的值，或者是指向不可变对象的引用，那么调用Object.clone()就能得到正确的对象。</p> 
<pre><code class="prism language-java"><span class="token comment">/**
 *如果每个域都是基本类型，或者指向不可变对象的引用
 *那么这个类只需要声明实现Cloneable接口，提供公有的clone()方法
 */</span>
<span class="token keyword">class</span> <span class="token class-name">ShallowCopy</span> <span class="token keyword">implements</span> <span class="token class-name">Cloneable</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">private</span> String name<span class="token punctuation">;</span>
	<span class="token keyword">private</span> <span class="token keyword">int</span> no<span class="token punctuation">;</span>
 
	<span class="token keyword">public</span> <span class="token function">ShallowCopy</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span><span class="token keyword">int</span> no<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>no <span class="token operator">=</span> no<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
 
	<span class="token comment">/*只需调用super.clone()就能得到正确的行为*/</span>
	<span class="token keyword">public</span> ShallowCopy <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">try</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token punctuation">(</span>ShallowCopy<span class="token punctuation">)</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CloneNotSupportedException</span> e<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">AssertionError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>通常情况下，我们已经得到了正确的对象，但是如果类里面包含代表序列号或者唯一ID的域，或者创建时间的域，还需要对这些域进行修正。</p> 
<h3><a id="_93"></a>深克隆</h3> 
<p>深克隆把引用域所指向的对象也克隆一遍。考虑下面这样一个类：</p> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Person</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">private</span> Dog friend<span class="token punctuation">;</span>
	<span class="token keyword">public</span> <span class="token function">Person</span><span class="token punctuation">(</span>Dog dog<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		friend <span class="token operator">=</span> dog<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Dog</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">private</span> String name<span class="token punctuation">;</span>
	<span class="token keyword">public</span> <span class="token function">Dog</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>Person类的friend域不是基本类型，而是指向了可变的对象，这个时候如果调用Object.clone()进行浅克隆，那么克隆出来的对象的friend指向的还是原来的dog，就是说：</p> 
<p>Person p = new Person(new Dog(“金毛”));</p> 
<p>p.clone().friend== p.friend;//true</p> 
<p>p.clone().friend.name = “狼狗”;</p> 
<p>p.friend.name.equals(“狼狗”);//true，改变克隆对象，却同时更改了原对象</p> 
<p>实际上，clone方法是另一种构造器：你必须确保不会伤害到原来的对象。为了使Person的clone方法正确工作，也要对friend进行克隆，最简单的做法就是调用friend.clone()：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> Person <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">try</span><span class="token punctuation">{<!-- --></span>
			Person result <span class="token operator">=</span> <span class="token punctuation">(</span>Person<span class="token punctuation">)</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			result<span class="token punctuation">.</span>friend <span class="token operator">=</span> friend<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CloneNotSupportedException</span> e<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			<span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">AssertionError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>可是，如果friend域是final的，那么上面的clone()也无法正常工作，因为super.clone()时已经给friend赋一次值了，不能再去修正克隆对象的friend域了。这是个根本问题：clone架构与引用可变对象的final域的正常用法是不相兼容的！</p> 
<p>抛去final域的问题不谈，递归的调用clone()方法就解决问题了吗？问题在于，深克隆要深入到哪一层，是一个不易确定的问题。考虑下面的类：</p> 
<pre><code class="prism language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span>
<span class="token comment">/**
 *内部实现了单向链表
 *buckets里的每个元素保存一个单向链表
 *
 */</span>
<span class="token keyword">class</span> <span class="token class-name">NMap</span> <span class="token keyword">implements</span> <span class="token class-name">Cloneable</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">private</span> Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> buckets<span class="token punctuation">;</span>
	
	<span class="token keyword">public</span> <span class="token function">NMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		buckets <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
			buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">(</span><span class="token string">"M10"</span><span class="token punctuation">,</span><span class="token string">"Messi"</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">(</span><span class="token string">"X6"</span><span class="token punctuation">,</span> <span class="token string">"Xavi"</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
 
	<span class="token keyword">public</span> Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getBuckets</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> buckets<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
 
   <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">final</span> Object key<span class="token punctuation">;</span>
		Object value<span class="token punctuation">;</span>
		Entry next<span class="token punctuation">;</span>
 
		<span class="token function">Entry</span><span class="token punctuation">(</span>Object key<span class="token punctuation">,</span>Object value<span class="token punctuation">,</span>Entry next<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>
			<span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
			<span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
 
		<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setNext</span><span class="token punctuation">(</span>Entry next<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		
		<span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			String result <span class="token operator">=</span>  key <span class="token operator">+</span> <span class="token string">":"</span> <span class="token operator">+</span> value <span class="token operator">+</span> <span class="token string">"  "</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span>
				result <span class="token operator">+=</span> next<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">return</span> result<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
 
	<span class="token keyword">public</span> NMap <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">try</span>
		<span class="token punctuation">{<!-- --></span>
			NMap result <span class="token operator">=</span> <span class="token punctuation">(</span>NMap<span class="token punctuation">)</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">//数组被视为实现了Cloneable接口</span>
			result<span class="token punctuation">.</span>buckets <span class="token operator">=</span> buckets<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">return</span> result<span class="token punctuation">;</span>
		<span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CloneNotSupportedException</span> e<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			<span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">AssertionError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
 
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		NMap map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NMap</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	    
		System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">getBuckets</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		NMap clone <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		Entry entry <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">(</span><span class="token string">"G4"</span><span class="token punctuation">,</span><span class="token string">"Guadiorla"</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">(</span><span class="token string">"R9"</span><span class="token punctuation">,</span><span class="token string">"Ronaldo"</span><span class="token punctuation">,</span>null<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span>Entry ent <span class="token operator">:</span> clone<span class="token punctuation">.</span><span class="token function">getBuckets</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
			ent<span class="token punctuation">.</span><span class="token function">setNext</span><span class="token punctuation">(</span>entry<span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">getBuckets</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>运行这段代码之后会发现，虽然克隆对象有自己的数组buckets，但是数组中引用的链表与原始对象是一样的，修改克隆对象数组中的链表，原始对象中数组保存的对象也会随之而修改。解决这种问题的方法是在Entry类中增加一个“深度拷贝（deep copy）”方法。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> Entry <span class="token function">deepEntry</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	Entry result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>value<span class="token punctuation">,</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span>Entry p <span class="token operator">=</span> result<span class="token punctuation">;</span> p<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span>
		p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>next<span class="token punctuation">.</span>key<span class="token punctuation">,</span>p<span class="token punctuation">.</span>next<span class="token punctuation">.</span>value<span class="token punctuation">,</span>p<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
NMap的<span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法如下：
<span class="token keyword">public</span> NMap <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">try</span>
	<span class="token punctuation">{<!-- --></span>
		NMap result <span class="token operator">=</span> <span class="token punctuation">(</span>NMap<span class="token punctuation">)</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//数组被视为实现了Cloneable接口</span>
		result<span class="token punctuation">.</span>buckets <span class="token operator">=</span> buckets<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> buckets<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span>
				result<span class="token punctuation">.</span>buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">deepEntry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> result<span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CloneNotSupportedException</span> e<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">AssertionError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>克隆复杂对象还有一种方法，先调用super.clone()得到类型正确的对象，然后把所有域都设置成空白状态，然后调用高层的方法重新产生对象的状态。这种做法会产生一个简单、合理且相当优美的clone方法，运行速度稍慢。</p> 
<h3><a id="_242"></a>总结</h3> 
<p>1.Cloneable接口是一个失败的接口，它没有提供clone()方法，却影响了Object.clone()克隆的行为：如果类没有实现Cloneable接口，调用super.clone()方法会得到CloneNotSupportedException。</p> 
<p>2.所有实现了Cloneable接口的类都应该提供一个公有的方法覆盖clone()，此公有方法首先调用super.clone()，然后修正域，此公有方法一般不应该声明抛出CloneNotSupportedException。</p> 
<p>3.如果为了继承而设计的类不应该实现Cloneable接口，这样可以使子类具有实现或者不实现Cloneable接口的自由，就仿佛它们直接扩展了Object一样。父类没有实现Cloneable接口，也没有覆盖clone()，子类如果实现了Cloneable,在覆盖的clone()中调用super.clone()是可以得到正确对象的。</p> 
<p>据说很多专家级程序猿从来都不使用clone()方法。</p> 
<h3><a id="_252"></a>更好的方法</h3> 
<p>等等，为了实现clone()方法的功能，有必要这么复杂吗？很少有这种必要。为了实现对象拷贝的更好的方法是提供一个拷贝构造器或者拷贝工厂，它们接受这类的一个对象作为参数。</p> 
<p>public Yum( Yum yum);//拷贝构造器</p> 
<p>public static YumcopyInstance(Yum yum);//拷贝工厂</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c141a5e8deed322234835df84cbc6ca3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C语言--打印正金字塔和倒金字塔</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/91ae692a8543f0d84243cab27f143ec2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">预备内容 STM32CubeMX安装与快速入门</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>