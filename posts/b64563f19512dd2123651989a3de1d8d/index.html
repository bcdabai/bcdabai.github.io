<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>vue01-组件通信 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="vue01-组件通信" />
<meta property="og:description" content="父组件 --&gt;子组件 属性props //child props:{msg:String} //parent &lt;HelloWorld msg=&#34;***********&#34;/&gt; refs //parent &lt;HelloWorld ref=&#34;hw&#34;/&gt; //赋值 this.$refs.hw.msg = &#34;******&#34;; children //parent this.$children[0].msg = &#34;****&#34;; 子组件--&gt;父组件 自定义事件 //chidren this.$emit(&#34;add&#34;,data); //parent &lt;HelloWorld @add=&#34;funcName&#34;/&gt; .sync修饰符
*实现父子组件数据的双向绑定
官网：https://cn.vuejs.org/v2/guide/components-custom-events.html#sync-%E4%BF%AE%E9%A5%B0%E7%AC%A6
//父组件语法 v-bind:propName.sync = &#34;data&#34;; // v-bind.sync=&#34;obj&#34;;[这种语法只适用于对象] //子组件语法 com.$emit(&#34;update:propName&#34;,newData) //parent &lt;Hello1 v-bind:msg.sync=&#34;msg&#34;&gt;&lt;/Hello1&gt; &lt;Hello2 v-bind.sync = &#34;myData&#34;&gt;&lt;/Hello2&gt; data() { return { msg: &#34;msgmsgmgsg&#34;, myData:{ a:1,b:2,c:3 } } } //Hello1 fun1() { this.$emit(&#34;update:msg&#34;,&#34;hello1的新数据&#34;) } //Hello2 /* myData对象中的每一个属性 (如a) 都作为一个独立的 prop 传入， 各自添加用于更新的 v-on 监听器*/ fun1() { this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/b64563f19512dd2123651989a3de1d8d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-12-03T23:07:31+08:00" />
<meta property="article:modified_time" content="2019-12-03T23:07:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">vue01-组件通信</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>父组件 --&gt;子组件</h4> 
<ul><li><strong>属性props</strong></li></ul> 
<pre class="has"><code>//child
props:{msg:String}
//parent
&lt;HelloWorld msg="***********"/&gt;</code></pre> 
<ul><li><strong>refs</strong></li></ul> 
<pre class="has"><code>//parent
&lt;HelloWorld ref="hw"/&gt;
//赋值
this.$refs.hw.msg = "******";</code></pre> 
<ul><li><strong>children</strong></li></ul> 
<pre class="has"><code>//parent
this.$children[0].msg = "****";</code></pre> 
<h4>子组件--&gt;父组件</h4> 
<ul><li><strong>自定义事件</strong></li></ul> 
<pre class="has"><code>//chidren
this.$emit("add",data);
//parent
&lt;HelloWorld @add="funcName"/&gt;</code></pre> 
<ul><li> <p><strong>.sync修饰符</strong></p> </li></ul> 
<p>*实现父子组件数据的双向绑定</p> 
<p>官网：<a href="https://cn.vuejs.org/v2/guide/components-custom-events.html#sync-%E4%BF%AE%E9%A5%B0%E7%AC%A6" rel="nofollow">https://cn.vuejs.org/v2/guide/components-custom-events.html#sync-%E4%BF%AE%E9%A5%B0%E7%AC%A6</a></p> 
<pre class="has"><code>//父组件语法 v-bind:propName.sync = "data";
//          v-bind.sync="obj";[这种语法只适用于对象] 

//子组件语法 com.$emit("update:propName",newData)

//parent
&lt;Hello1 v-bind:msg.sync="msg"&gt;&lt;/Hello1&gt;
&lt;Hello2 v-bind.sync = "myData"&gt;&lt;/Hello2&gt;
data() {
      return {
          msg: "msgmsgmgsg",
          myData:{
              a:1,b:2,c:3
          }
      }
  }

//Hello1
fun1() {
   this.$emit("update:msg","hello1的新数据")
}

//Hello2
/* myData对象中的每一个属性 (如a) 都作为一个独立的 prop 传入，
   各自添加用于更新的 v-on 监听器*/
fun1() {
   this.$emit("update:a","ahello2的新数据")
   this.$emit("update:b","bhello2的新数据")
   this.$emit("update:c","chello2的新数据")
}</code></pre> 
<h4>兄弟组件</h4> 
<ul><li><strong>通过共同的祖辈组件$parent/$root</strong></li></ul> 
<pre class="has"><code>// brother1 监听事件
 created () {
      this.$parent.$on("fun1",()=&gt;{
          console.log("there is hello2")
      });
  }
// brother2 触发事件
 &lt;div @click="$parent.$emit('fun1')"&gt;
    &lt;h1&gt;HelloWorld1&lt;/h1&gt;
  &lt;/div&gt;</code></pre> 
<p>事件由谁派发就由谁监听；</p> 
<p>$on和v-on的区别</p> 
<p><a href="https://www.cnblogs.com/surfer/p/9815692.html" rel="nofollow">https://www.cnblogs.com/surfer/p/9815692.html</a></p> 
<p>$on 监听实例的事件</p> 
<p>v-on监听dom的事件</p> 
<h4><span style="color:#333333;"><strong>祖先和后代之间</strong></span></h4> 
<ul><li><strong><span style="color:#333333;">provide/inject</span></strong><span style="color:#333333;"><strong>：能够实现祖先给后代传值</strong></span></li></ul> 
<pre class="has"><code>// ancestor 
provide() { return {foo: 'foo'} }
// descendant 
inject: ['foo']</code></pre> 
<p>*适用于多层嵌套，但传值不建议修改，且该方法多见于开源组件，日常开发不建议使用；</p> 
<p>*不能适用于后代向祖先传值；</p> 
<h4><span style="color:#333333;"><strong>任意两个组件之间</strong></span></h4> 
<ul><li><strong><span style="color:#333333;">事件总线：创建一个</span><span style="color:#333333;">Bus</span><span style="color:#333333;">类负责事件派发、监听和回调管理</span></strong></li></ul> 
<pre class="has"><code>// Bus：事件派发、监听和回调管
class Bus{ 
  constructor(){ 
    this.callbacks = {} 
  }
  $on(name, fn){ 
    this.callbacks[name] = this.callbacks[name] || [] this.callbacks[name].push(fn) 
  }
  $emit(name, args){ 
    if(this.callbacks[name]){ 
      this.callbacks[name].forEach(cb =&gt; cb(args)) 
    } 
  } 
}
// main.js 
Vue.prototype.$bus = new Bus();
Vue.prototype.$bud = new Vue(); 
// com1 
this.$bus.$on('foo', callback); 
// com2 
this.$bus.$emit('foo',data);</code></pre> 
<ul><li><strong><span style="color:#333333;">vuex</span><span style="color:#333333;">：创建唯一的全局数据管理者</span><span style="color:#333333;">store</span><span style="color:#333333;">，通过它管理数据并通知组件状态变更</span></strong></li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9a6ff25015dfb24eb34c01c97db514ec/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">js-5秒之后跳转页面</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ad2aaee8db2e74079d35223ebbf1338c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java面试题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>