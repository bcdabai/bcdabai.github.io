<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>基于STM32的DMX512开发笔记 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="基于STM32的DMX512开发笔记" />
<meta property="og:description" content="首先基本了解一下DMX512的基本协议
一、 DMX512协议
DMX 是Digital MultipleX 的缩写，意为多路数字传输。DMX512控制协议是美国舞台灯光协会（usITT）于1990年发布的灯光控制器与灯具设备进行数据传输的工业标准，全称是USITTDMX512（1990），包括电气特性、数据协议、数据格式等方面的内容。
每一个DMX 控制字节叫做一个指令帧，称作一个控制通道，可以控制灯光设备的一个或几个功能。一个DMX 指令帧由1个开始位、8个数据位和2个结束位共11位构成，采用单向异步串行传输，如图1所示。
图1 DMX512 定时程序的帧结构（上图）和信息包结构（下图）
图1 中虚线内控制指令中的S 为开始位，宽度为一个比特，是受控灯具准备接收并解码控制数据的开始标志；E为结束位，宽度为两个比特，表示一个指令帧的结束；D0～ D7为8 位控制数据，其电平组合从0000~一l1111111 共有256个状态（对应十进制数的0～255），控制灯光的亮度时，可产生256个亮度等级，0000~ （0）对应灯光最暗，l1111111（255）对应灯光最亮。DMX512指令的位宽（每比特宽度）是4 us，每帧宽度为44 us，传输速率为250 kbps。
一个完整的DMX512信息包（Packet）由一个MTBP位、一个Break 位、一个MAB位、一个SC 和512个数据帧构成。MTBP（Mark TimeBetween Packets）标志着一个完整的信息包发送完毕，是下一个信息包即将开始的“空闲位”，高电平有效。Break为中断位，对应一个信息包结束后的程序复位阶段，宽度不少于两个帧（22 比特）。程序复位结束后应发送控制数据，但由于每一个数据帧的第一位（即开始位）为低电平，所以必须用一个高电平脉冲间隔前后两个低电平脉冲，这个起间隔、分离作用的高电平脉冲即MAB（Mark After Break），此脉冲一到，意味着“新一轮”的控制又开始了。SC（Start Code）意为开始代码帧（图1中的第0帧），和此后到来的数据帧一样，也是由11 位构成，除两个高电平的结束位之外，其他9位全部是低电平，通常将其叫做第0 帧或第0通道（Ch~nel No 0），可理解为一个不存在的通道（Non一~istent Channe1）。
表1 DMX512 信息包定时表
表1 是DMX512 信息包的定时表，表中NS意为Nm Spec~ed，宽度没有严格限制，由程序设计者自行决定，比如MTBP的宽度可以介于0～1秒之间。
调光控制台每发送一个信息包，可以对全部512个受控通道形成一次全面的控制。发送一个信息包的时间大约是23 ms，每秒钟将对所有512个受控通道完成44 次控制，即受控光路的刷新频率44 Hz，如果实际受控通道少于512个，那么刷新频率将相应提高。
根据标准的512协议，其物理连接与传统上的RS485是完全一致的，并没有什么差别，差别只是在协议上的不同，工业上应用的主要是modbus协议，而这里是用512通信协议。
DMX512数据协议是美国舞台灯光协会（USITT）于1990年发布的一种灯光控制器与灯具设备进行数据传输的标准。它包括电气特性，数据协议，数据格式等方面的内容。
512协议规定使用的波特率是250Kbps，而stm32可以支持上Mbps的波特率，所以说这不是什么大问题。
该协议发送的数据帧一共11位，
1位开始位，
8位数据，
2个停止位，无校验位。
根据波特率可以知道，位时间是4us，11位数据供需要44us的时间。当然对于标准的512协议是需要break和mark after break 帧的，break是一个92us的低电平，而mark after break是一个12us的高电平，
512协议必须有break和mark，但是在我们通常的非标准收发中，检测break和mark相对比较困难，如果非要做，耗费的资源也比较多，比如定时器计时，中断等等。如果不是做标准控制器的，完全可以另辟蹊径。
每一串数据的开始都要有一个起始码，也称复位码，其数据为0，但是从开始位数至第十位是0，用来声明数据传输开始，随后包含1-512个数据，也称调光数据，其是标准的数据帧，所以第十位是1，所以我们可以根据这个第十位来进行做文章。大家都知道，一般的单片机，像51，avr等都是支持8-9位数据发送的，所以我们就是用9位数据，
1位停止位，无校验位，通过检测检测第十位，也就是所谓的RB8来进行数据的接收与传输，不需要发送break和mark。
1、发送端 串口设为 9位数据， 1停止位，无校验位，波特率250000 void USART1_Configuration(void) { USART_InitTypeDef USART_InitStructure; USART_InitStructure." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/28c24a2bcf0cccd67cb7929bcef2b7e1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-07-23T17:26:19+08:00" />
<meta property="article:modified_time" content="2019-07-23T17:26:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">基于STM32的DMX512开发笔记</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>首先基本了解一下DMX512的基本协议</p> 
<p>一、       DMX512协议</p> 
<p>       DMX 是Digital MultipleX 的缩写，意为多路数字传输。DMX512控制协议是美国舞台灯光协会（usITT）于1990年发布的灯光控制器与灯具设备进行数据传输的工业标准，全称是USITTDMX512（1990），包括电气特性、数据协议、数据格式等方面的内容。</p> 
<p>      每一个DMX 控制字节叫做一个指令帧，称作一个控制通道，可以控制灯光设备的一个或几个功能。一个DMX 指令帧由1个开始位、8个数据位和2个结束位共11位构成，采用单向异步串行传输，如图1所示。</p> 
<p>图1 DMX512 定时程序的帧结构（上图）和信息包结构（下图）</p> 
<p> </p> 
<p>       图1 中虚线内控制指令中的S 为开始位，宽度为一个比特，是受控灯具准备接收并解码控制数据的开始标志；E为结束位，宽度为两个比特，表示一个指令帧的结束；D0～ D7为8 位控制数据，其电平组合从0000~一l1111111 共有256个状态（对应十进制数的0～255），控制灯光的亮度时，可产生256个亮度等级，0000~ （0）对应灯光最暗，l1111111（255）对应灯光最亮。DMX512指令的位宽（每比特宽度）是4 us，每帧宽度为44 us，传输速率为250 kbps。</p> 
<p>       一个完整的DMX512信息包（Packet）由一个MTBP位、一个Break 位、一个MAB位、一个SC 和512个数据帧构成。MTBP（Mark TimeBetween Packets）标志着一个完整的信息包发送完毕，是下一个信息包即将开始的“空闲位”，高电平有效。Break为中断位，对应一个信息包结束后的程序复位阶段，宽度不少于两个帧（22 比特）。程序复位结束后应发送控制数据，但由于每一个数据帧的第一位（即开始位）为低电平，所以必须用一个高电平脉冲间隔前后两个低电平脉冲，这个起间隔、分离作用的高电平脉冲即MAB（Mark After Break），此脉冲一到，意味着“新一轮”的控制又开始了。SC（Start Code）意为开始代码帧（图1中的第0帧），和此后到来的数据帧一样，也是由11 位构成，除两个高电平的结束位之外，其他9位全部是低电平，通常将其叫做第0 帧或第0通道（Ch~nel No 0），可理解为一个不存在的通道（Non一~istent Channe1）。</p> 
<p> </p> 
<p>表1 DMX512 信息包定时表</p> 
<p> </p> 
<p>       表1 是DMX512 信息包的定时表，表中NS意为Nm Spec~ed，宽度没有严格限制，由程序设计者自行决定，比如MTBP的宽度可以介于0～1秒之间。</p> 
<p>       调光控制台每发送一个信息包，可以对全部512个受控通道形成一次全面的控制。发送一个信息包的时间大约是23 ms，每秒钟将对所有512个受控通道完成44 次控制，即受控光路的刷新频率44 Hz，如果实际受控通道少于512个，那么刷新频率将相应提高。</p> 
<p> </p> 
<ul><li> </li></ul> 
<p>根据标准的512协议，其物理连接与传统上的RS485是完全一致的，并没有什么差别，差别只是在协议上的不同，工业上应用的主要是modbus协议，而这里是用512通信协议。</p> 
<p> </p> 
<p> DMX512数据协议是美国舞台灯光协会（USITT）于1990年发布的一种灯光控制器与灯具设备进行数据传输的标准。它包括电气特性，数据协议，数据格式等方面的内容。</p> 
<p> </p> 
<p>512协议规定使用的波特率是250Kbps，而stm32可以支持上Mbps的波特率，所以说这不是什么大问题。</p> 
<p> 该协议发送的数据帧一共11位，</p> 
<p>1位开始位，</p> 
<p>8位数据，</p> 
<p>2个停止位，无校验位。</p> 
<p>根据波特率可以知道，位时间是4us，11位数据供需要44us的时间。当然对于标准的512协议是需要break和mark after break </p> 
<p>帧的，break是一个92us的低电平，而mark after break是一个12us的高电平，</p> 
<p> </p> 
<p>512协议必须有break和mark，但是在我们通常的非标准收发中，检测break和mark相对比较困难，如果非要做，耗费的资源也比较多，比如定时器计时，中断等等。如果不是做标准控制器的，完全可以另辟蹊径。</p> 
<p> </p> 
<p> </p> 
<p>每一串数据的开始都要有一个起始码，也称复位码，其数据为0，但是从开始位数至第十位是0，用来声明数据传输开始，随后包含1-512个数据，也称调光数据，其是标准的数据帧，所以第十位是1，所以我们可以根据这个第十位来进行做文章。大家都知道，一般的单片机，像51，avr等都是支持8-9位数据发送的，所以我们就是用9位数据，</p> 
<p>1位停止位，无校验位，通过检测检测第十位，也就是所谓的RB8来进行数据的接收与传输，不需要发送break和mark。</p> 
<p> </p> 
<pre class="has"><code class="language-objectivec">1、发送端


串口设为
9位数据，
1停止位，无校验位，波特率250000 

void USART1_Configuration(void) 

{  

  USART_InitTypeDef USART_InitStructure; 

  USART_InitStructure.USART_BaudRate = 250000; 

  USART_InitStructure.USART_WordLength = USART_WordLength_9b; 

  USART_InitStructure.USART_StopBits = USART_StopBits_1; 

  USART_InitStructure.USART_Parity = USART_Parity_No; 

  USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; 

  USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx; 

  /* Configure USART1 */ 

  USART_Init(USART1, &amp;USART_InitStructure);   

  /* Enable USART1 Receive and Transmit interrupts */ 

  USART_ITConfig(USART1, USART_IT_RXNE, ENABLE); 

  //USART_ITConfig(USART1, USART_IT_TC, ENABLE); 

  /* Enable the USART1 */ 

  USART_Cmd(USART1, ENABLE); 

} 

注意在初始化串口的时候别忘了485芯片设为发送状态接下来主要就是数据包的发送，发送的时候注意起始码的数据第九位设为0，调光数据第九位设为1. 

void DMX_SendPacket(void) 

{ 

  pDMX_buf = 0; 

  while (pDMX_buf &lt;= 512) //1-512 

  { 
/* send data packet to slaves*/ 
if(USART1-&gt;SR &amp; (1&lt;&lt;6)) 
{  
/*发送起始码 00*/ 
if (0 == pDMX_buf)  
{ 
USART1-&gt;DR = ((USART1-&gt;DR) &amp; 0xfe00);  
 //第九位置0 
} 
else 
{ 
USART1-&gt;DR = 0x0100 | DMX_buf[pDMX_buf];  
 //第九位置1 
} 

pDMX_buf++; 
}
  } 
} 

在main函数中进行循环数据的发送了，每200ms发送一次，由于发送快，偶尔的错误也不是很明显。

 

2,、接收端


接收端得工作就是接收的信息进行解码，关键是对RB8的处理，接收用到了中断接收，所以需要使能接收中断。

 

void USART1_Configuration(void) 

{  

  USART_InitTypeDef USART_InitStructure; 

  USART_InitStructure.USART_BaudRate = 250000; 

  USART_InitStructure.USART_WordLength = USART_WordLength_9b; 

  USART_InitStructure.USART_StopBits = USART_StopBits_1; 

  USART_InitStructure.USART_Parity = USART_Parity_No; 

  USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; 

  USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx; 

  /* Configure USART1 */ 

  USART_Init(USART1, &amp;USART_InitStructure);   

  /* Enable USART1 Receive and Transmit interrupts */ 

  USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);//

使能接收中断

 

  //USART_ITConfig(USART1, USART_IT_TC, ENABLE); 

  /* Enable the USART1 */ 

  USART_Cmd(USART1, ENABLE); 

} 

void NVIC_Configuration(void) 

{ 

  NVIC_InitTypeDef NVIC_InitStructure; 

#ifdef  VECT_TAB_RAM 

  /* Set the Vector Table base location at 0x20000000 */ 

  NVIC_SetVectorTable(NVIC_VectTab_RAM, 0x0); 

#else  /* VECT_TAB_FLASH  */ 

  /* Set the Vector Table base location at 0x08000000 */ 

  NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x0); 

#endif 

  

  

//
设置优先级分组：先占优先级和从优先级 ，先占优先级0位，从优先级4位
 

  NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0); 

  /* Enable the USART1 Interrupt */ 

  NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn; 

  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0; 

  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1; 

  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; 

  NVIC_Init(&amp;NVIC_InitStructure); 

} 

void USART1_IRQHandler(void) 

{ 

  uint16_t UDR; 
  static uint16_t RXB8; 
  static uint16_t pDMX_buf = 0; //数据指针

 

  static uint8_t fDMX_buf_right = 0;  //接收数据

  if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)//USART_FLAG_RXNE 

  { 


//USART_ClearITPendingBit(USART1,USART_FLAG_RXNE); 

UDR = USART_ReceiveData(USART1); 

RXB8 = (UDR &amp; 0x0100); 

if (RXB8 == 0) //复位信号

{  

 if (!UDR) 
 { 
 fDMX_buf_right = 1;//接收数据正确
 

 pDMX_buf = 1; //直接接收第一个数据不保存第0个数据。

 } 

} 

else //rb8 =1  pDMX_buf=1 调光数据

{ 
 if (1 == fDMX_buf_right) 
 { 

   DMX_buf[pDMX_buf++] = (u8)UDR;  //接收到512个数据
   if (pDMX_buf &gt; 512) 

   { 

fDMX_buf_right = 0; 

tim_update = SET; //

更新调光数据
}}
}</code></pre> 
<p> </p> 
<p>  </p> 
<p>   </p> 
<p>   } </p> 
<p>  </p> 
<p>   </p> 
<p> } </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/be781dc70d4a23017f3f43bcd627bf1e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">openwrt 框架分析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1d47b0ed8013e5c3286679b29248abd4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">react native 安卓中headerTitle居中对齐</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>