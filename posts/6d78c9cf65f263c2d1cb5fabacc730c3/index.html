<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>一篇搞定Flutter面试(持续更新) - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="一篇搞定Flutter面试(持续更新)" />
<meta property="og:description" content="Dart 部分 如果您学习过 JavaScript 或者 Java/Kotlin ，那么在学习 Dart 上难度并不大，Dart 综合了动态语言和静态语言的特性, 他也有一些自己的特点。
1、Dart 属于是强类型语言 ，但可以用 var 来声明变量，Dart 会自推导出数据类型，var 实际上是编译期的“语法糖”。dynamic 表示动态类型， 被编译后，实际是一个 object 类型，在编译期间不进行任何的类型检查，而是在运行期进行类型检查。
2、Dart 中 if 等语句只支持 bool 类型，switch 支持 String 类型。
3、Dart 中数组和 List 是一样的。
4、Dart 中，Runes 代表符号文字 , 是 UTF-32 编码的字符串, 用于如 Runes input = new Runes(’\u{1f596} \u{1f44d}’);
5、Dart 支持闭包。
6、Dart 中 number 类型分为 int 和 double ，没有 float 类型。
7、Dart 中 级联操作符 可以方便配置逻辑，如下代码：
event ..id = 1 ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/6d78c9cf65f263c2d1cb5fabacc730c3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-04-22T22:53:39+08:00" />
<meta property="article:modified_time" content="2021-04-22T22:53:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">一篇搞定Flutter面试(持续更新)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="Dart__0"></a>Dart 部分</h3> 
<p>如果您学习过 JavaScript 或者 Java/Kotlin ，那么在学习 Dart 上难度并不大，Dart 综合了动态语言和静态语言的特性, 他也有一些自己的特点。<br> 1、Dart 属于是强类型语言 ，但可以用 var 来声明变量，Dart 会自推导出数据类型，var 实际上是编译期的“语法糖”。dynamic 表示动态类型， 被编译后，实际是一个 object 类型，在编译期间不进行任何的类型检查，而是在运行期进行类型检查。<br> 2、Dart 中 if 等语句只支持 bool 类型，switch 支持 String 类型。<br> 3、Dart 中数组和 List 是一样的。<br> 4、Dart 中，Runes 代表符号文字 , 是 UTF-32 编码的字符串, 用于如 Runes input = new Runes(’\u{1f596} \u{1f44d}’);<br> 5、Dart 支持闭包。<br> 6、Dart 中 number 类型分为 int 和 double ，没有 float 类型。<br> 7、Dart 中 级联操作符 可以方便配置逻辑，如下代码：</p> 
<pre><code class="prism language-java">event
  <span class="token punctuation">.</span><span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token number">1</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token string">""</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span>actor <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>
</code></pre> 
<p>8、赋值操作符<br> 比较有意思的赋值操作符有：<br> AA ?? “999” ///表示如果 AA 为空，返回999<br> AA ??= “999” ///表示如果 AA 为空，给 AA 设置成 999<br> AA ~/999 ///AA 对于 999 整除<br> 9、可选方法参数<br> Dart 方法可以设置 参数默认值 和 指定名称<br> 比如：</p> 
<pre><code class="prism language-java"><span class="token function">getDetail</span><span class="token punctuation">(</span>Sting userName<span class="token punctuation">,</span> reposName<span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span>branch <span class="token operator">=</span> “master”<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
 <span class="token punctuation">}</span> 
</code></pre> 
<p>方法，这里 branch 不设置的话，默认是 “master” 。参数类型 可以指定或者不指定。调用效果：</p> 
<pre><code class="prism language-java"><span class="token function">getRepositoryDetailDao</span><span class="token punctuation">(</span>“aaa"<span class="token punctuation">,</span> “bbbb”<span class="token punctuation">,</span> branch<span class="token operator">:</span> “dev”<span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre> 
<p>10、作用域<br> Dart 没有关键词 public 、private 等修饰符，_ 下横向直接代表 private ，但是有 @protected 注解 。</p> 
<p>11、构造方法<br> Dart 中的多构造方法，可以通过命名方法实现。<br> 默认构造方法只能有一个，而通过 Model.empty() 方法可以创建一个空参数的类，其实方法名称随你喜欢，而变量初始化值时，只需要通过 this.name 在构造方法中指定即可：</p> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">ModelA</span> <span class="token punctuation">{<!-- --></span>
  String name<span class="token punctuation">;</span>
  String tag<span class="token punctuation">;</span>

  <span class="token comment">//默认构造方法，赋值给name和tag</span>
  <span class="token function">ModelA</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>tag<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">//返回一个空的ModelA</span>
  ModelA<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">//返回一个设置了name的ModelA</span>
  ModelA<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>12、getter setter 重写<br> Dart 中所有的基础类型、类等都继承 Object ，默认值是 NULL， 自带 getter 和 setter ，而如果是 final 或者 const 的话，那么它只有一个 getter 方法，Object 都支持 getter、setter 重写：</p> 
<pre><code class="prism language-java"> <span class="token annotation punctuation">@override</span>
  Size get preferredSize <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> Size<span class="token punctuation">.</span><span class="token function">fromHeight</span><span class="token punctuation">(</span>kTabHeight <span class="token operator">+</span> indicatorWeight<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre> 
<p>13、Assert(断言)<br> assert 只在检查模式有效，在开发过程中，assert(unicorn == null); 只有条件为真才正常，否则直接抛出异常，一般用在开发过程中，某些地方不应该出现什么状态的判断。<br> 14、重写运算符，如下所示重载 operator 后对类进行 +/- 操作。</p> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Vector</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">final</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span>

  <span class="token function">Vector</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>

  Vector operator <span class="token operator">+</span><span class="token punctuation">(</span>Vector v<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token function">Vector</span><span class="token punctuation">(</span>x <span class="token operator">+</span> v<span class="token punctuation">.</span>x<span class="token punctuation">,</span> y <span class="token operator">+</span> v<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
  Vector operator <span class="token operator">-</span><span class="token punctuation">(</span>Vector v<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token function">Vector</span><span class="token punctuation">(</span>x <span class="token operator">-</span> v<span class="token punctuation">.</span>x<span class="token punctuation">,</span> y <span class="token operator">-</span> v<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>

  ···
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">final</span> v <span class="token operator">=</span> <span class="token function">Vector</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">final</span> w <span class="token operator">=</span> <span class="token function">Vector</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">assert</span><span class="token punctuation">(</span>v <span class="token operator">+</span> w <span class="token operator">==</span> <span class="token function">Vector</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">assert</span><span class="token punctuation">(</span>v <span class="token operator">-</span> w <span class="token operator">==</span> <span class="token function">Vector</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>支持重载的操作符 ：<br> <img src="https://images2.imgbox.com/d8/53/j3RAP4CG_o.png" alt="在这里插入图片描述"><br> 15、类、接口、继承<br> Dart 中没有接口，类都可以作为接口，把某个类当做接口实现时，只需要使用 implements ，然后复写父类方法即可。<br> Dart 中支持 mixins ，按照出现顺序应该为extends 、 mixins 、implements 。</p> 
<p>16、Zone<br> Dart 中可通过 Zone 表示指定代码执行的环境，类似一个沙盒概念，在 Flutter 中 C++ 运行 Dart 也是在 _runMainZoned 内执行 runZoned 方法启动，而我们也可以通过 Zone ，在运行环境内捕获全局异常等信息:</p> 
<pre><code class="prism language-java"> <span class="token function">runZoned</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">runApp</span><span class="token punctuation">(</span><span class="token function">FlutterReduxApp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> onError<span class="token operator">:</span> <span class="token punctuation">(</span>Object obj<span class="token punctuation">,</span> StackTrace stack<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">print</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">print</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>同时你可以给 runZoned 注册方法，在需要时执行回调，如下代码所示，这样的在一个 Zone 内任何地方，只要能获取 onData 这个 ZoneUnaryCallback，就都可以调用到 handleData</p> 
<pre><code class="prism language-java"><span class="token comment">///最终需要处理的地方</span>
<span class="token function">handleData</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"VVVVVVVVVVVVVVVVVVVVVVVVVVV"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">///返回得到一个 ZoneUnaryCallback </span>
var onData <span class="token operator">=</span> Zone<span class="token punctuation">.</span>current<span class="token punctuation">.</span>registerUnaryCallback<span class="token generics function"><span class="token punctuation">&lt;</span>dynamic<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>handleData<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">///执行 ZoneUnaryCallback 返回数据</span>
Zone<span class="token punctuation">.</span>current<span class="token punctuation">.</span><span class="token function">runUnary</span><span class="token punctuation">(</span>onData<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>异步逻辑可以通过 scheduleMicrotask 可以插入异步执行方法：</p> 
<pre><code class="prism language-java">Zone<span class="token punctuation">.</span>current<span class="token punctuation">.</span><span class="token function">scheduleMicrotask</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
  <span class="token comment">//todo something</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>17、Future<br> Future 简单说就是对 Zone 的封装使用。<br> 比如 Future.microtask 中主要是执行了 Zone 的 scheduleMicrotask ，而 result._complete 最后调用的是 _zone.runUnary 等等。</p> 
<pre><code class="prism language-java">  factory Future<span class="token punctuation">.</span><span class="token function">microtask</span><span class="token punctuation">(</span>FutureOr<span class="token generics function"><span class="token punctuation">&lt;</span>T<span class="token punctuation">&gt;</span></span> <span class="token function">computation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    _Future<span class="token generics function"><span class="token punctuation">&lt;</span>T<span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">_Future</span><span class="token generics function"><span class="token punctuation">&lt;</span>T<span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">scheduleMicrotask</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
        result<span class="token punctuation">.</span><span class="token function">_complete</span><span class="token punctuation">(</span><span class="token function">computation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">e</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">_completeWithErrorCallback</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> e<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre> 
<p>Dart 中可通过 async/await 或者 Future 定义异步操作，而事实上 async/await 也只是语法糖，最终还是通过编译器转为 Future。</p> 
<p>18、Stream<br> Stream 也是有对Zone 的另外一种封装使用。<br> Dart 中另外一种异步操作， async* / yield 或者 Stream 可定义 Stream 异步， async* / yield 也只是语法糖，最终还是通过编译器转为 Stream。<br> Stream 还支持同步操作。</p> 
<p>1）、Stream 中主要有 Stream 、 StreamController 、StreamSink 和 StreamSubscription 四个关键对象，大致可以总结为：<br> StreamController ：如类名描述，用于整个 Stream 过程的控制，提供各类接口用于创建各种事件流。<br> StreamSink ：一般作为事件的入口，提供如 add ， addStream 等。<br> Stream ：事件源本身，一般可用于监听事件或者对事件进行转换，如 listen 、where 。<br> StreamSubscription ：事件订阅后的对象，表面上用于管理订阅过等各类操作，如 cacenl 、pause ，同时在内部也是事件的中转关键。<br> 2)、一般通过 StreamController 创建 Stream；通过 StreamSink 添加事件；通过 Stream 监听事件；通过 StreamSubscription 管理订阅。<br> 3)、Stream 中支持各种变化，比如map 、expand 、where 、take 等操作，同时支持转换为 Future 。</p> 
<h3><a id="Flutter__160"></a>Flutter 部分</h3> 
<p>Flutter 和 React Native 不同主要在于 Flutter UI是直接通过 Skia 渲染的 ，而 React Native 是将 js 中的控件转化为原生控件，通过原生去渲染的。</p> 
<ul><li>Flutter 中存在 Widget 、 Element 、RenderObject 、Layer 四棵树，其中 Widget 与 Element 是多对一的关系 ，</li><li>Element 中持有Widget 和 RenderObject ， 而 Element 与 RenderObject 是一一对应的关系 ，</li><li>当 RenderObject 的 isRepaintBoundary 为 true 时，那么个区域形成一个 Layer，所以不是每个 RenderObject 都具有 Layer 的，因为这受 isRepaintBoundary 的影响。</li><li>Flutter 中 Widget 不可变，每次保持在一帧，如果发生改变是通过 State 实现跨帧状态保存，而真实完成布局和绘制数组的是 RenderObject ， Element 充当两者的桥梁， State 就是保存在 Element 中。</li><li>Flutter 中的 BuildContext 只是接口，而 Element 实现了它。</li><li>Flutter 中 setState 其实是调用了 markNeedsBuild ，该方法内部标记此Element 为 Dirty ，然后在下一帧 WidgetsBinding.drawFrame 才会被绘制，这可以看出 setState 并不是立即生效的。</li><li>Flutter 中 RenderObject 在 attch/layout 之后会通过 markNeedsPaint(); 使得页面重绘，流程大概如下：<br> <img src="https://images2.imgbox.com/68/18/QPThXnYt_o.png" alt="在这里插入图片描述"></li></ul> 
<p>通过isRepaintBoundary 往上确定了更新区域，通过 requestVisualUpdate 方法触发更新往下绘制。</p> 
<ul><li> <p>正常情况 RenderObject 的布局相关方法调用顺序是 ： layout -&gt; performResize -&gt; performLayout -&gt; markNeedsPaint , 但是用户一般不会直接调用 layout，而是通过 markNeedsLayout ，具体流程如下：<br> <img src="https://images2.imgbox.com/83/d3/W9lZ0eCW_o.png" alt="在这里插入图片描述"></p> </li><li> <p>Flutter 中一般 json 数据从 String 转为 Object 的过程中都需要先经过 Map 类型。</p> </li><li> <p>Flutter 中 InheritedWidget 一般用于状态共享，如Theme 、Localizations 、 MediaQuery 等，都是通过它实现共享状态，这样我们可以通过 context 去获取共享的状态，比如 ThemeData theme = Theme.of(context);</p> </li></ul> 
<blockquote> 
 <p>在 Element 的 inheritFromWidgetOfExactType 方法实现里，有一个 Map&lt;Type, InheritedElement&gt; _inheritedWidgets 的对象。<br> _inheritedWidgets 一般情况下是空的，只有当父控件是 InheritedWidget 或者本身是 InheritedWidgets 时才会有被初始化，而当父控件是 InheritedWidget 时，这个 Map 会被一级一级往下传递与合并 。<br> 所以当我们通过 context 调用 inheritFromWidgetOfExactType 时，就可以往上查找到父控件的 Widget 。</p> 
</blockquote> 
<ul><li>Flutter 中默认主要通过 runtimeType 和 key 判断更新：</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">static</span> bool <span class="token function">canUpdate</span><span class="token punctuation">(</span>Widget oldWidget<span class="token punctuation">,</span> Widget newWidget<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> oldWidget<span class="token punctuation">.</span>runtimeType <span class="token operator">==</span> newWidget<span class="token punctuation">.</span>runtimeType
        <span class="token operator">&amp;&amp;</span> oldWidget<span class="token punctuation">.</span>key <span class="token operator">==</span> newWidget<span class="token punctuation">.</span>key<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="Flutter__191"></a>Flutter 中的生命周期</h3> 
<ul><li>initState() 表示当前 State 将和一个 BuildContext 产生关联，但是此时BuildContext 没有完全装载完成，如果你需要在该方法中获取 BuildContext ，可以</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">new</span> <span class="token class-name">Future<span class="token punctuation">.</span>delayed</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token function">Duration</span><span class="token punctuation">(</span>seconds<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token comment">//context}); </span>
</code></pre> 
<p>一下。</p> 
<ul><li> <p>didChangeDependencies() 在 initState() 之后调用，当 State 对象的依赖关系发生变化时，该方法被调用，初始化时也会调用。</p> </li><li> <p>deactivate() 当 State 被暂时从视图树中移除时，会调用这个方法，同时页面切换时，也会调用<br> dispose() Widget 销毁了，在调用这个方法之前，总会先调用 deactivate()。</p> </li><li> <p>didUpdateWidge 当 widget 状态发生变化时，会调用。<br> <img src="https://images2.imgbox.com/41/15/P1YUz2zh_o.png" alt="在这里插入图片描述"></p> </li><li> <p>通过 StreamBuilder 和 FutureBuilder 我们可以快速使用 Stream 和 Future 快速构建我们的异步控件</p> </li><li> <p>Flutter 中 runApp 启动入口其实是一个 WidgetsFlutterBinding ，它主要是通过 BindingBase 的子类 GestureBinding 、ServicesBinding 、 SchedulerBinding 、PaintingBinding 、SemanticsBinding 、 RendererBinding 、WidgetsBinding 等，通过 mixins 的组合而成的</p> </li><li> <p>Flutter 中的 Dart 的线程是以事件循环和消息队列的形式存在，包含两个任务队列，一个是 microtask 内部队列，一个是 event 外部队列，而 microtask 的优先级又高于 event 。</p> </li></ul> 
<blockquote> 
 <p>因为 microtask 的优先级又高于 event， 同时会阻塞event 队列，所以如果 microtask 太多就可能会对触摸、绘制等外部事件造成阻塞卡顿哦。</p> 
</blockquote> 
<ul><li>Flutter 中存在四大线程，分别为 UI Runner、GPU Runner、IO Runner， Platform Runner （原生主线程） ，同时在 Flutter 中可以通过 isolate 或者 compute 执行真正的跨线程异步操作。</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4efd62e828ab2432798e192f9d3be894/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">1：App启动流程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3caf59d7e04f915eebf7cc8755e5c35e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SAMBA文件共享与DNS域名服务</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>