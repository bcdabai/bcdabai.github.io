<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;游戏开发《天天酷跑》 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;游戏开发《天天酷跑》" />
<meta property="og:description" content="总代码:其中包含了自制的头文件和cpp文件tool用来实现特定的功能
/*	* 天天酷跑开发日志 * 1.创建项目 * 2.导入素材 * 3.游戏界面 * 实际的开发流程 * 选择图形库或基于其他引擎 * 本项目基于EASY X * 1)创建游戏窗口 * 2)设计游戏背景 * a.3重背景不同的速度同时移动 * b.循环滚动背景的实现 * 3)实现游戏背景 * a.加载背景资源 * b.渲染 * 4.实现玩家奔跑 * 5.实现玩家跳跃 * 6.实现随机小乌龟 * 7.创建障碍物结构体数据类型 * 8.使用障碍物结构体后的重新初始化 * 9.封装后多个障碍物的显示 * 10.实现下蹲 * 11.实现悬挂障碍物 * * */ #include&lt;iostream&gt; #include&lt;graphics.h&gt; #include&lt;conio.h&gt; #include&#34;tools.h&#34; #include&lt;vector&gt; using namespace std; #define SCREEN_LONG 1012 #define SCREEN_WIDTH 396 #define OBSTACLE_COUNT 10 #define WIN_SCORE 10 IMAGE images[3]; int bgX[3]; int bgSpeed[3] = { 1,3,19 }; IMAGE heroImg[12]; int heroIndex; int heroX; int heroY; bool herojump; //表示玩家正在跳跃 bool heroDown; //玩家下蹲 int jumpMaxHeight; int heroJumpOff; int updata; //表示是否需要马上刷新画面 int heroBlood; int score; typedef enum { TORTOISE, LION, HOOK1, HOOK2, HOOK3, HOOK4, OBSTACLE_TYPE_COUNT }obstacle_type; //int data[3][5] vector&lt;vector&lt;IMAGE&gt;&gt; obstacleImgs; //特殊的二维数组 typedef struct obstacle { int type; //障碍物类型 int imgIndex; //当前显示的图片的序号 int x, y; //障碍物的坐标 int speed; int power; //杀伤力 bool exist; //障碍物是否存在 bool hited; //表示是否已经发生碰撞 bool passed; //表示是否已经被通过 }obstacle_t; obstacle_t obstacles[OBSTACLE_COUNT]; IMAGE imgDOWN[2]; IMAGE imgSZ[10]; void init() { initgraph(SCREEN_LONG, SCREEN_WIDTH); char name[64]; for (int i = 0; i &lt; 3; i&#43;&#43;) { sprintf_s(name, &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/efbc8967d1adde1da3b6c5b6fd85d152/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-08T16:30:01+08:00" />
<meta property="article:modified_time" content="2023-08-08T16:30:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;游戏开发《天天酷跑》</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p> <strong>总代码</strong>:其中包含了自制的头文件和cpp文件tool用来实现特定的功能</p> 
<pre><code class="language-cpp">/*	
* 天天酷跑开发日志
* 1.创建项目
* 2.导入素材
* 3.游戏界面
*  实际的开发流程
*  选择图形库或基于其他引擎
*  本项目基于EASY X
* 1)创建游戏窗口
* 2)设计游戏背景
*  a.3重背景不同的速度同时移动
*  b.循环滚动背景的实现
* 3)实现游戏背景
*   a.加载背景资源
*   b.渲染
* 4.实现玩家奔跑
* 5.实现玩家跳跃
* 6.实现随机小乌龟
* 7.创建障碍物结构体数据类型
* 8.使用障碍物结构体后的重新初始化
* 9.封装后多个障碍物的显示
* 10.实现下蹲
* 11.实现悬挂障碍物
* 
* 
*/
#include&lt;iostream&gt;
#include&lt;graphics.h&gt;
#include&lt;conio.h&gt;
#include"tools.h"
#include&lt;vector&gt;
using namespace std;
#define SCREEN_LONG   1012
#define SCREEN_WIDTH  396
#define OBSTACLE_COUNT 10
#define WIN_SCORE 10
IMAGE images[3];
int bgX[3];
int bgSpeed[3] = { 1,3,19 };
IMAGE heroImg[12];
int heroIndex;
int heroX;
int heroY;
bool herojump;     //表示玩家正在跳跃
bool heroDown;     //玩家下蹲
int jumpMaxHeight;
int heroJumpOff;
int updata;        //表示是否需要马上刷新画面
int heroBlood;
int score;
typedef enum {
	TORTOISE,
	LION,
	HOOK1,
	HOOK2,
	HOOK3,
	HOOK4,
	OBSTACLE_TYPE_COUNT
}obstacle_type;

//int data[3][5]
vector&lt;vector&lt;IMAGE&gt;&gt; obstacleImgs;     //特殊的二维数组



typedef struct obstacle {
	int type;          //障碍物类型
	int imgIndex;                //当前显示的图片的序号
	int x, y;                    //障碍物的坐标
	int speed;
	int power;                   //杀伤力
	bool exist;  //障碍物是否存在
	bool hited;                  //表示是否已经发生碰撞 
	bool passed;                 //表示是否已经被通过
}obstacle_t;
obstacle_t obstacles[OBSTACLE_COUNT];
IMAGE imgDOWN[2];
IMAGE imgSZ[10];
void init() {
	initgraph(SCREEN_LONG, SCREEN_WIDTH);
	char name[64];
	for (int i = 0; i &lt; 3; i++) {
		
		sprintf_s(name, "res/bg%03d.png", i + 1);
		loadimage(&amp;images[i], name);
		bgX[i] = 0;
	}
	//加载玩家奔跑素材
	for (int i = 0; i &lt; 12; i++) {
		char name[64];
		sprintf_s(name, "res/hero%d.png", i + 1);
		loadimage(&amp;heroImg[i], name);
	}

	//设置玩家初始位置
	heroIndex = 0;
	heroX = SCREEN_LONG / 2 - heroImg[heroIndex].getwidth();
	heroY = 345 - heroImg[heroIndex].getheight();
	herojump = false;
	jumpMaxHeight= 345 - heroImg[heroIndex].getheight()-120;
	heroJumpOff = -12;
	updata = true;
	//wuguiExist = false;
	//wuguiIndex = 0;
	//wuguiY = 345 - wuguiImg[wuguiIndex].getheight()-50;
	加载小乌龟
	//for (int i = 0; i &lt; 7; i++) {
	//	char name[64];
	//	sprintf_s(name,"res/t%d.png", i + 1);
	//	loadimage(&amp;wuguiImg[i], name);
	//}
	IMAGE imgTort;
	loadimage(&amp;imgTort, "res/t1.png");
	vector&lt;IMAGE&gt; imgTortArray;
	imgTortArray.push_back(imgTort);
	obstacleImgs.push_back(imgTortArray);
	IMAGE imgLION;
	vector&lt;IMAGE&gt;imgLionArray;
	for (int i = 0; i &lt; 6; i++) {
		sprintf_s(name, "res/p%d.png", i + 1);
		loadimage(&amp;imgLION, name);
		imgLionArray.push_back(imgLION);
		}
	obstacleImgs.push_back(imgLionArray);

	//初始化障碍物
	for (int i = 0; i &lt; OBSTACLE_COUNT; i++) {
		obstacles[i].exist = false;
	}

	//加载下蹲素材
	loadimage(&amp;imgDOWN[0], "res/d1.png");
	loadimage(&amp;imgDOWN[1], "res/d2.png");
	heroDown = false;

	IMAGE imgH;
		
	for (int i = 0; i &lt; 4; i++) {
		vector&lt;IMAGE&gt; imgHookArray;
		sprintf(name, "res/h%d.png", i + 1);
		loadimage(&amp;imgH, name, 63, 260, true);
		imgHookArray.push_back(imgH);
		obstacleImgs.push_back(imgHookArray);
	}

	heroBlood = 100;
	//预加载音效
	preLoadSound("res/hit.mp3");
	mciSendString("play res/bg.mp3", 0, 0, 0);
	score = 0;

	for (int i = 0; i &lt; 10; i++) {
		sprintf_s(name, "res/sz/%d.png", i);
		loadimage(&amp;imgSZ[i], name);
	}
}

void updateBg() {
	putimagePNG2(bgX[0], 0, &amp;images[0]);
	putimagePNG2(bgX[1], 119, &amp;images[1]);
	putimagePNG2(bgX[2], 330, &amp;images[2]);

}
void jump() {
	herojump = true;
	updata = true;
} 
void down() {
	updata = true;
	heroDown = true;
	heroIndex = 0;
}
// 处理用户按键
void keyEvent() {
	if (_kbhit()) {
		char ch = _getch();
		if (ch == ' ') {
			jump();
		}
		if (ch=='a') {
			down();
		}
	}
}
void updataEnemy() {
	//渲染小乌龟
	/*if (wuguiExist) {
		putimagePNG2(wuguiX, wuguiY, SCREEN_LONG,&amp;wuguiImg[wuguiIndex]);
	}*/
	for (int i = 0; i &lt; OBSTACLE_COUNT; i++) {
		if (obstacles[i].exist) {
			putimagePNG2(obstacles[i].x, obstacles[i].y, SCREEN_LONG,
				&amp;obstacleImgs[obstacles[i].type][obstacles[i].imgIndex]);
		}
	}
}
void creatObstacle() {
	int i;
	for ( i = 0; i &lt; OBSTACLE_COUNT; i++) {
		if (obstacles[i].exist == false) {
			break;
		}
	}
	if (i &gt;= OBSTACLE_COUNT) {
		return;
	}
	obstacles[i].exist = true;
	obstacles[i].imgIndex = 0;
	obstacles[i].hited = false;
	obstacles[i].passed = false;
	obstacles[i].type =(obstacle_type)( rand() % 3);
	if (obstacles[i].type == HOOK1) {
		obstacles[i].type += rand() % 4;
	}
	obstacles[i].x = SCREEN_LONG;
	obstacles[i].y = 345 + 5 - obstacleImgs[obstacles[i].type][0].getheight();
	if (obstacles[i].type == TORTOISE) {
		obstacles[i].speed = 0;
		obstacles[i].power = 5;
	}
	else if (obstacles[i].type == LION) {
		obstacles[i].speed = 4;
		obstacles[i].power = 20;
	}
	else if (obstacles[i].type &gt;= HOOK1 &amp;&amp; obstacles[i].type &lt;= HOOK4) {
		obstacles[i].speed = 0;
		obstacles[i].power = 20;
		obstacles[i].y = 0;
	}
}
void checkHit() {
	for (int i = 0; i &lt; OBSTACLE_COUNT; i++) {
		if (obstacles[i].exist&amp;&amp; obstacles[i].hited == false) {
			int a1x, a1y, a2x, a2y;
			int off = 30;
			if (!heroDown) {
				a1x = heroX + off;
				a1y = heroY + off;
				a2x = heroX + heroImg[heroIndex].getwidth() - off;
				a2y = heroY + heroImg[heroIndex].getheight();
			}
			else {
				a1x = heroX + off;
				a1y = 345 - imgDOWN[heroIndex].getheight();
				a2x = heroX + imgDOWN[heroIndex].getwidth() - off;
				a2y = 345;
			}
			int b1x = obstacles[i].x + off;
			int b1y = obstacles[i].y + off;
			int b2x = obstacles[i].x + obstacleImgs[obstacles[i].type][obstacles[i].imgIndex].getwidth()-off;
			int b2y = obstacles[i].y + obstacleImgs[obstacles[i].type][obstacles[i].imgIndex].getheight() - 10;
			if (rectIntersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y)) {
				heroBlood -= obstacles[i].power;
				cout &lt;&lt; "剩下" &lt;&lt; heroBlood&lt;&lt;" 血量"&lt;&lt;endl;
				playSound("res/hit.mp3");
				obstacles[i].hited = true;
			}
		}
	}
}
void fly() {
	for (int i = 0; i &lt; 3; i++) {
		bgX[i] -= bgSpeed[i];
		if(bgX[i]&lt;= -SCREEN_LONG){
			bgX[i] = 0;
		}
	}
	//实现跳跃
	if (herojump == true) {
		
		if (heroY &lt; jumpMaxHeight) {
			heroJumpOff = 12;
		}
		heroY += heroJumpOff;
		if (heroY &gt; 345 - heroImg[heroIndex].getheight()) {
			herojump = false;
			heroJumpOff = -12;
		}
	}
	else if (heroDown) {
		static int count = 0;
		int delays[2] = { 4,10 };
		count++;
		if (count &gt;= delays[heroIndex]) {
			count = 0;
			heroIndex++;
			if (heroIndex &gt;= 2) {
				heroIndex = 0;
				heroDown = false;
			}
		}
		
	}
	else {//不跳越
		heroIndex = (heroIndex + 1) % 12;
	}
	//创建小乌龟
	static int frameCount = 0;
	static int enemyFre = 50;
	frameCount++;
	if (frameCount &gt; enemyFre) {
		frameCount = 0;
		enemyFre =25 + rand() % 25;
		creatObstacle();
		
	}
	//更新障碍物的坐标
	for (int i = 0; i &lt; OBSTACLE_COUNT; i++) {
		if (obstacles[i].exist) {
			obstacles[i].x -= obstacles[i].speed + bgSpeed[2];
			if (obstacles[i].x &lt; obstacleImgs[obstacles[i].type][0].getwidth()-100) {
				obstacles[i].exist = false;
			}
			int len = obstacleImgs[obstacles[i].type].size();
			obstacles[i].imgIndex = (obstacles[i].imgIndex + 1) % len;
		}
	}
	checkHit();
}
void updataHero() {
	if (!heroDown) {
		putimagePNG2(heroX, heroY, &amp;heroImg[heroIndex]);
	}
	else {
		int y = 345 - imgDOWN[heroIndex].getheight();
		putimagePNG2(heroX,y,&amp;imgDOWN[heroIndex]);
	}
}
void updataBloodBar() {
	drawBloodBar(10, 10, 200, 10, 2, BLUE, DARKGRAY, RED, heroBlood / 100.0);
}
void cheakOver() {
	if (heroBlood &lt;= 0) {
		loadimage(0, "res/over.png");
		FlushBatchDraw();
		mciSendString("stop res/bg.mp3",0,0,0);
		system("pause");
		system("cls");
		cout &lt;&lt; "按q退出，按其他键继续游戏";
		char ch = _getch();
		if (ch == 'q') {
			exit(-1);
		}
		heroBlood = 100;
		score = 0;
		mciSendString("play res/bg.mp3", 0, 0, 0);

	}
}
void cheakScore() {
	for (int i = 0; i &lt; OBSTACLE_COUNT; i++) {
		if (obstacles[i].exist &amp;&amp; obstacles[i].passed == false&amp;&amp;
			obstacles[i].x+obstacleImgs[obstacles[i].type][
			0].getwidth() &lt;heroX&amp;&amp;obstacles[i].hited==false) {
			score++;
			obstacles[i].passed = true;
			cout &lt;&lt; "现在是" &lt;&lt; score &lt;&lt; "分";
		}
	}
}
void updataScore() {
	char str[8];
	sprintf_s(str, "%d", score);
	int x = 20;
	int y = 25;
	for (int i = 0; i &lt; str[i]; i++) {
		int sz = str[i] - '0';
		putimagePNG(x, y, &amp;imgSZ[sz]);
		x += imgSZ-&gt;getwidth() + 5;
	}
}
void cheakWin() {
	if (score &gt;= WIN_SCORE) {
		mciSendString("play res/win.mp3", 0, 0, 0);
		Sleep(1000);
		loadimage(0, "res/win.png");
		FlushBatchDraw();
		mciSendString("stop res/bg.mp3", 0, 0, 0);
		system("pause");
	}
}
int main() {
	init();
	loadimage(0, "res/over.png");
	system("pause");


	int timer = 0;
	while (1) {
		keyEvent();
		timer += getDelay();
		if (timer &gt; 30) {
			timer = 0;
			updata = true;	
		}
		if (updata) {
			updata = false;
			BeginBatchDraw();
			updateBg();
			updataHero();
			updataEnemy();
			updataBloodBar();
			updataScore();
			EndBatchDraw();
			cheakOver();
			cheakScore();
			cheakWin();
			fly();
		}

	}
	
	system("pause");
	return 0;
}</code></pre> 
<p><strong>实现效果</strong></p> 
<p><img alt="" height="527" src="https://images2.imgbox.com/6f/8e/EYQMkxxM_o.png" width="1200"></p> 
<p><img alt="" height="522" src="https://images2.imgbox.com/ca/5f/F9mucwKS_o.png" width="1200"></p> 
<p> 下面来带大家一步步实现。</p> 
<p><strong>一.游戏界面开发</strong></p> 
<pre><code class="language-cpp">#include"tools.h";
#include&lt;iostream&gt;
#include&lt;graphics.h&gt;
using namespace std;
#define SCREEN_LONG 1012
#define SCREEN_WIDTH 396
IMAGE bg_Img[3];			//存放游戏背景图片
int bgX[3];                 //背景图片的X坐标
int bg_Speed[3] = { 1,3,6}; //背景图片滚动的速度
bool updata;				//当前是否需要刷新
//游戏的初始化
void init() {
	initgraph(SCREEN_LONG, SCREEN_WIDTH);


	char name[64];
	for (int i = 0; i &lt; 3; i++) {
		sprintf_s(name, "res/bg%03d.png",i+1);
		loadimage(&amp;bg_Img[i], name);
	}
	updata = true;
}
//渲染背景图片
void updataBg() {
	putimagePNG2(bgX[0], 0, &amp;bg_Img[0]);
	putimagePNG2(bgX[1], 119, &amp;bg_Img[1]);
	putimagePNG2(bgX[2], 330, &amp;bg_Img[2]);
}
void fly() {
	for (int i = 0; i &lt; 3; i++) {
		bgX[i] -= bg_Speed[i];
		if (bgX[i] &lt; -SCREEN_LONG) {
			bgX[i] = 0;
		}
	}
}
int main() {
	init();
	int timer=0;
	while (1) {	
		timer += getDelay();
		if (timer &gt; 30) {
			timer = 0;
			updata = true;
		}
		if (updata) {
			updata = false;
            BeginBatchDraw();
			updataBg();
            EndBatchDraw();
			fly();
		}
		
	}
	
	system("pause");
	return 0;
}</code></pre> 
<p><strong>实现效果</strong></p> 
<p>可以滚动的背景图片</p> 
<p><img alt="" height="520" src="https://images2.imgbox.com/e5/25/YsLqHHOu_o.png" width="1200"></p> 
<p> <strong>要点详解</strong></p> 
<p><strong>1.让背景图片滚动起来</strong></p> 
<p>定义数字bgX[3]用来存放三张图片的X坐标，bg_Speed[3]存放三张图片的速度。</p> 
<p>只要让背景图片的X坐标不断的减少，背景图片就会不断的向左移动，所以我们需要写一个循环让背景图片的左边持续的减小，直到减小到和我们显示窗口的长度一样时，将bgX重新赋值为0，这样就可以做到无缝链接。</p> 
<p><strong>2.帧等待</strong></p> 
<p>定义bool updata判断现在是否需要刷新页面。初始值设为true（刚开始肯定要刷新一下嘛）,定义timer用来判断多久刷新一次图片,<strong>getDelay是返回距离上一次调用间隔的时间</strong>，当时间累加到30ms的时候我们刷新一次图片,当timer&gt;30的时候，updata=true，刷新页面。</p> 
<p><strong>二.实现人物奔跑</strong></p> 
<pre><code class="language-cpp">#include"tools.h";
#include&lt;iostream&gt;
#include&lt;graphics.h&gt;
using namespace std;
#define SCREEN_LONG 1012
#define SCREEN_WIDTH 396
IMAGE bg_Img[3];			//存放游戏背景图片
int bgX[3];                 //背景图片的X坐标
int bg_Speed[3] = { 1,3,6}; //背景图片滚动的速度
bool updata;				//当前是否需要刷新
IMAGE heroImg[12];			//存放人物背景图片
int heroX;					//人物X坐标
int heroY;					//人物Y坐标
int heroIndex;
//游戏的初始化
void init() {
	initgraph(SCREEN_LONG, SCREEN_WIDTH);


	char name[64];
	//导入背景图片
	for (int i = 0; i &lt; 3; i++) {
		sprintf_s(name, "res/bg%03d.png",i+1);
		loadimage(&amp;bg_Img[i], name);
	}
	updata = true;
	//导入人物奔跑图片
	for (int i = 0; i &lt; 12; i++) {
		sprintf_s(name, "res/hero%d.png",i+1);
		loadimage(&amp;heroImg[i], name);
	}
	heroIndex = 0;
	heroX = SCREEN_LONG/2 - heroImg[heroIndex].getwidth();
	heroY = 345-heroImg[heroIndex].getheight();

}
//渲染背景图片
void updataBg() {
	putimagePNG2(bgX[0], 0, &amp;bg_Img[0]);
	putimagePNG2(bgX[1], 119, &amp;bg_Img[1]);
	putimagePNG2(bgX[2], 330, &amp;bg_Img[2]);
}
void updataHero() {
	putimagePNG2(heroX, heroY, &amp;heroImg[heroIndex]);
}
void fly() {
	for (int i = 0; i &lt; 3; i++) {
		bgX[i] -= bg_Speed[i];
		if (bgX[i] &lt; -SCREEN_LONG) {
			bgX[i] = 0;
		}
	}
	heroIndex = (heroIndex + 1) % 12;
}
int main() {
	init();
	int timer=0;
	while (1) {	
		timer += getDelay();
		if (timer &gt; 30) {
			timer = 0;
			updata = true;
		}
		if (updata) {
			updata = false;
			BeginBatchDraw();
			updataBg();
			updataHero();
			EndBatchDraw();
			fly();
		}
		
	}
	
	system("pause");
	return 0;
}</code></pre> 
<p><strong>实现效果</strong></p> 
<p><img alt="" height="532" src="https://images2.imgbox.com/83/e2/bmWonSgc_o.png" width="1200"></p> 
<p><strong>要点详解</strong></p> 
<p></p> 
<p>无难点，只需要循环播放人物背景图片即可。</p> 
<p><strong>三.实现人物跳跃下蹲</strong></p> 
<pre><code class="language-cpp">#include"tools.h";
#include&lt;iostream&gt;
#include&lt;graphics.h&gt;
#include&lt;conio.h&gt;
using namespace std;
#define SCREEN_LONG 1012
#define SCREEN_WIDTH 396
IMAGE bg_Img[3];			//存放游戏背景图片
int bgX[3];                 //背景图片的X坐标
int bg_Speed[3] = { 1,3,6}; //背景图片滚动的速度
bool updata;				//当前是否需要刷新
IMAGE heroImg[12];			//存放人物背景图片
int heroX;					//人物X坐标
int heroY;					//人物Y坐标
int heroIndex;
bool heroJump;
bool heroDown;
int heroJumpOff;			//人物跳跃速度
int heroJumpMax;			//人物跳跃高度
IMAGE imgDown[2];
//游戏的初始化
void init() {
	initgraph(SCREEN_LONG, SCREEN_WIDTH);


	char name[64];
	//导入背景图片
	for (int i = 0; i &lt; 3; i++) {
		sprintf_s(name, "res/bg%03d.png",i+1);
		loadimage(&amp;bg_Img[i], name);
	}
	updata = true;
	//导入人物奔跑图片
	for (int i = 0; i &lt; 12; i++) {
		sprintf_s(name, "res/hero%d.png",i+1);
		loadimage(&amp;heroImg[i], name);
	}
	heroIndex = 0;
	heroX = SCREEN_LONG/2 - heroImg[heroIndex].getwidth();
	heroY = 345-heroImg[heroIndex].getheight();
	

	
	heroJump = false;
	heroDown = false;
	heroJumpOff = -12;
	heroJumpMax = 345 - heroImg[heroIndex].getheight() - 120;
	//加载下蹲素材
	loadimage(&amp;imgDown[0], "res/d1.png");
	loadimage(&amp;imgDown[1], "res/d2.png");

}
//渲染背景图片
void updataBg() {
	putimagePNG2(bgX[0], 0, &amp;bg_Img[0]);
	putimagePNG2(bgX[1], 119, &amp;bg_Img[1]);
	putimagePNG2(bgX[2], 330, &amp;bg_Img[2]);
}
void updataHero() {
	if (!heroDown) {
		putimagePNG2(heroX, heroY, &amp;heroImg[heroIndex]);
	}
	else {
		int y = 345 - imgDown[heroIndex].getheight();
		putimagePNG2(heroX, y, &amp;imgDown[heroIndex]);
	}
}
void fly() {
	for (int i = 0; i &lt; 3; i++) {
		bgX[i] -= bg_Speed[i];
		if (bgX[i] &lt; -SCREEN_LONG) {
			bgX[i] = 0;
		}
	}
	
	//跳跃
	if (heroJump == true) {
		if (heroY &lt; heroJumpMax) {
			heroJumpOff = 12;
		}	
		heroY += heroJumpOff;
		if (heroY &gt;= 345-heroImg[heroIndex].getheight()){
			heroJumpOff = -12;
			heroJump = false;
		}
	}
	else if (heroDown == true) {
		static int count = 0;
		int delay[2] = { 4,10 };
		count++;
		if (count &gt;= delay[heroIndex]) {
			count = 0;
			heroIndex++;
			if (heroIndex &gt;= 2) {
				heroIndex = 0;
				heroDown = false;
			}
		}

	}
	 else {//不跳越不下蹲
		heroIndex = (heroIndex + 1) % 12;
	}


}
void Jump() {
	heroJump = true;
	updata = true;
}
void Down() {
	heroDown = true;
	updata = true;
	heroIndex = 0;
}
void keyEvent() {
	if (_kbhit())
	{
		char ch = _getch();
		if (ch == ' ') {
			Jump();
		}
		if (ch == 'a') {
			Down();
		}

	}
}
int main() {
	init();
	int timer=0;
	while (1) {	
		timer += getDelay();
		if (timer &gt; 30) {
			timer = 0;
			updata = true;
		}
		if (updata) {
			keyEvent();
			updata = false;
			BeginBatchDraw();
			updataBg();
			updataHero();
			EndBatchDraw();
			fly();
		}
		
	}
	
	system("pause");
	return 0;
}</code></pre> 
<p> <strong>实现效果</strong></p> 
<p><img alt="" height="541" src="https://images2.imgbox.com/58/2c/bN0mJG6M_o.png" width="1200"></p> 
<p> <img alt="" height="541" src="https://images2.imgbox.com/34/18/uaOx3rQv_o.png" width="1200"></p> 
<p> <strong>要点详解</strong></p> 
<p><strong>跳跃实现机制</strong>，我们设定跳跃幅度heroJumpOff和跳跃高度heroJumpMax,当按下跳跃键空格时，如果heroY小于最大高度，heroJumpOff=-12，heroY-12就可以实现向上移动，通过while循环一直跳到最大高度，当heroY小于最大高度时，让heroJumpOff=12实现下降，当下降到一定位置时，让heroJumpOff=-12，heroJump=false,以供下次跳跃使用。</p> 
<p> <strong>下蹲实现机制</strong>，通过延迟播放两张下蹲图片实现。delay[2]存放的两个数字就是第一张和第二章图片延长的时间。</p> 
<p><strong>四.障碍物结构体初始化</strong></p> 
<pre><code class="language-cpp">#include"tools.h";
#include&lt;iostream&gt;
#include&lt;graphics.h&gt;
#include&lt;conio.h&gt;
#include&lt;vector&gt;
using namespace std;
#define SCREEN_LONG 1012
#define SCREEN_WIDTH 396
IMAGE bg_Img[3];			//存放游戏背景图片
int bgX[3];                 //背景图片的X坐标
int bg_Speed[3] = { 1,3,6}; //背景图片滚动的速度
bool updata;				//当前是否需要刷新
IMAGE heroImg[12];			//存放人物背景图片
int heroX;					//人物X坐标
int heroY;					//人物Y坐标
int heroIndex;
bool heroJump;
bool heroDown;
int heroJumpOff;			//人物跳跃速度
int heroJumpMax;			//人物跳跃高度
IMAGE imgDown[2];
enum obstacle_type {
	TORTOISE,
	LION,
	HOOK1,
	HOOK2,
	HOOK3,
	HOOK4,
	OBSTACLE_TYPE_COUNT
};
struct obstacle_t {
	int type;				//障碍物类型
	int imgIndex;			//障碍物图片序号
	int x, y;				//障碍物坐标
	int speed;				//障碍物速度
	int power;				//障碍物攻击力
	bool exist;				//障碍物当前是否存在
	bool hit;				//障碍物和人物是否发生碰撞
	bool passed;			//障碍物是否被通过
};
obstacle_t obstacles[OBSTACLE_TYPE_COUNT];    //储存障碍物信息的一维数组
vector&lt;vector&lt;IMAGE&gt;&gt; obstacleImgs;			//特殊的二维数组
//游戏的初始化
void init() {
	initgraph(SCREEN_LONG, SCREEN_WIDTH);


	char name[64];
	//导入背景图片
	for (int i = 0; i &lt; 3; i++) {
		sprintf_s(name, "res/bg%03d.png",i+1);
		loadimage(&amp;bg_Img[i], name);
	}
	updata = true;
	//导入人物奔跑图片
	for (int i = 0; i &lt; 12; i++) {
		sprintf_s(name, "res/hero%d.png",i+1);
		loadimage(&amp;heroImg[i], name);
	}
	heroIndex = 0;
	heroX = SCREEN_LONG/2 - heroImg[heroIndex].getwidth();
	heroY = 345-heroImg[heroIndex].getheight();
	

	
	heroJump = false;
	heroDown = false;
	heroJumpOff = -12;
	heroJumpMax = 345 - heroImg[heroIndex].getheight() - 120;
	//加载下蹲素材
	loadimage(&amp;imgDown[0], "res/d1.png");
	loadimage(&amp;imgDown[1], "res/d2.png");

	//加载各种障碍物的信息
	IMAGE imgTort;						//乌龟
	loadimage(&amp;imgTort, "res/t1.png");
	vector&lt;IMAGE&gt;imgTortArray;
	imgTortArray.push_back(imgTort);
	obstacleImgs.push_back(imgTortArray);

	IMAGE imgLion;
	vector&lt;IMAGE&gt;imgLionArray;
	for (int i = 0; i &lt; 6; i++) {
		
		sprintf_s(name, "res/p%d.png", i + 1);
		loadimage(&amp;imgLion, name);
		imgLionArray.push_back(imgLion);
	}
	obstacleImgs.push_back(imgLionArray);

	IMAGE imgH;
	
	for (int i = 0; i &lt; 4; i++) {
		vector&lt;IMAGE&gt;imgHookArray;
		sprintf_s(name, "res/h%d.png", i + 1);
		loadimage(&amp;imgH, name,63,260,true);
		imgHookArray.push_back(imgH);
		obstacleImgs.push_back(imgHookArray);
	}
	//初始化障碍物
	for (int i = 0; i &lt; OBSTACLE_TYPE_COUNT; i++) {
		obstacles[i].exist = false;
	}

}
void updataObstacle() {
	for (int i = 0; i &lt; OBSTACLE_TYPE_COUNT; i++) {
		if (obstacles[i].exist) {
			putimagePNG2(obstacles[i].x, obstacles[i].y, SCREEN_LONG,
				&amp;obstacleImgs[obstacles[i].type][obstacles[i].imgIndex]);
		}
	}
}
void creatObstacle() {
	int i;
	for (i = 0; i &lt; OBSTACLE_TYPE_COUNT; i++) {
		if (obstacles[i].exist == false) {
			break;
		}
	}
	if (i &gt;= OBSTACLE_TYPE_COUNT) {
		return;
	}
	obstacles[i].exist = true;
	obstacles[i].imgIndex = 0;
	obstacles[i].hit = false;
	obstacles[i].passed = false;
	obstacles[i].type = rand() % 3;
	if (obstacles[i].type == HOOK1) {
		obstacles[i].type += rand() % 4;
	}
	obstacles[i].x = SCREEN_LONG;
	obstacles[i].y = 345 + 5 - obstacleImgs[obstacles[i].type][0].getheight();
	if (obstacles[i].type == TORTOISE) {
		obstacles[i].speed = 0;
		obstacles[i].power = 5;
	}
	else if (obstacles[i].type == LION) {
		obstacles[i].speed = 4;
		obstacles[i].power = 20;
	}
	else if (obstacles[i].type &gt;= HOOK1 &amp;&amp; obstacles[i].type &lt;= HOOK4) {
		obstacles[i].speed = 0;
		obstacles[i].power = 20;
		obstacles[i].y = 0;
	}
}
//渲染背景图片
void updataBg() {
	putimagePNG2(bgX[0], 0, &amp;bg_Img[0]);
	putimagePNG2(bgX[1], 119, &amp;bg_Img[1]);
	putimagePNG2(bgX[2], 330, &amp;bg_Img[2]);
}
void updataHero() {
	if (!heroDown) {
		putimagePNG2(heroX, heroY, &amp;heroImg[heroIndex]);
	}
	else {
		int y = 345 - imgDown[heroIndex].getheight();
		putimagePNG2(heroX, y, &amp;imgDown[heroIndex]);
	}
}
void fly() {
	for (int i = 0; i &lt; 3; i++) {
		bgX[i] -= bg_Speed[i];
		if (bgX[i] &lt; -SCREEN_LONG) {
			bgX[i] = 0;
		}
	}
	
	//跳跃
	if (heroJump == true) {
		if (heroY &lt; heroJumpMax) {
			heroJumpOff = 12;
		}	
		heroY += heroJumpOff;
		if (heroY &gt;= 345-heroImg[heroIndex].getheight()){
			heroJumpOff = -12;
			heroJump = false;
		}
	}
	else if (heroDown == true) {
		static int count = 0;
		int delay[2] = { 4,30 };
		count++;
		if (count &gt;= delay[heroIndex]) {
			count = 0;
			heroIndex++;
			if (heroIndex &gt;= 2) {
				heroIndex = 0;
				heroDown = false;
			}
		}

	}
	 else {//不跳越不下蹲
		heroIndex = (heroIndex + 1) % 12;
	}

}
void Jump() {
	heroJump = true;
	updata = true;
}
void Down() {
	heroDown = true;
	updata = true;
	heroIndex = 0;
}
void keyEvent() {
	if (_kbhit())
	{
		char ch = _getch();
		if (ch == ' ') {
			Jump();
		}
		if (ch == 'a') {
			Down();
		}

	}
}
int main() {
	init();
	int timer=0;
	while (1) {	
		timer += getDelay();
		if (timer &gt; 30) {
			timer = 0;
			updata = true;
		}
		if (updata) {
			keyEvent();
			updata = false;
			BeginBatchDraw();
			updataBg();
			updataHero();
			updataObstacle();
			EndBatchDraw();
			fly();
		}
		
	}
	
	system("pause");
	return 0;
}</code></pre> 
<p> <strong>要点详解</strong></p> 
<p>定义枚举类型储存乌龟，狮子，以及四根柱子，定义障碍物结构体，一个结构体数组，一个vector类型的二位数组去储存障碍物的信息，在init函数里分别对乌龟，狮子，四根柱子进行初始化。这样二维数组obstacleImgs分别储存着乌龟图片数组，狮子图片数组以及四根柱子的图片。在updataObstacle中去渲染障碍物，在creatObstacle中去创建障碍物。(注意，HOOK的初始化中，必须多加三个参数，63，260，true去调整图片大小。否则会导致运行异常)</p> 
<p><strong>五.障碍物出现。</strong></p> 
<pre><code class="language-cpp">#include"tools.h";
#include&lt;iostream&gt;
#include&lt;graphics.h&gt;
#include&lt;conio.h&gt;
#include&lt;vector&gt;
using namespace std;
#define SCREEN_LONG 1012
#define SCREEN_WIDTH 396
#define OBSTACLE_COUNT 10
IMAGE bg_Img[3];			//存放游戏背景图片
int bgX[3];                 //背景图片的X坐标
int bg_Speed[3] = { 1,3,12}; //背景图片滚动的速度
bool updata;				//当前是否需要刷新
IMAGE heroImg[12];			//存放人物背景图片
int heroX;					//人物X坐标
int heroY;					//人物Y坐标
int heroIndex;
bool heroJump;
bool heroDown;
int heroJumpOff;			//人物跳跃速度
int heroJumpMax;			//人物跳跃高度
IMAGE imgDown[2];
enum obstacle_type {
	TORTOISE,
	LION,
	HOOK1,
	HOOK2,
	HOOK3,
	HOOK4,
	OBSTACLE_TYPE_COUNT
};
struct obstacle_t {
	int type;				//障碍物类型
	int imgIndex;			//障碍物图片序号
	int x, y;				//障碍物坐标
	int speed;				//障碍物速度
	int power;				//障碍物攻击力
	bool exist;				//障碍物当前是否存在
	bool hit;				//障碍物和人物是否发生碰撞
	bool passed;			//障碍物是否被通过
};
obstacle_t obstacles[OBSTACLE_COUNT];    //储存障碍物信息的一维数组
vector&lt;vector&lt;IMAGE&gt;&gt; obstacleImgs;			//特殊的二维数组
//游戏的初始化
void init() {
	initgraph(SCREEN_LONG, SCREEN_WIDTH);


	char name[64];
	//导入背景图片
	for (int i = 0; i &lt; 3; i++) {
		sprintf_s(name, "res/bg%03d.png",i+1);
		loadimage(&amp;bg_Img[i], name);
	}
	updata = true;
	//导入人物奔跑图片
	for (int i = 0; i &lt; 12; i++) {
		sprintf_s(name, "res/hero%d.png",i+1);
		loadimage(&amp;heroImg[i], name);
	}
	heroIndex = 0;
	heroX = SCREEN_LONG/2 - heroImg[heroIndex].getwidth();
	heroY = 345-heroImg[heroIndex].getheight();
	

	
	heroJump = false;
	heroDown = false;
	heroJumpOff = -12;
	heroJumpMax = 345 - heroImg[heroIndex].getheight() - 120;
	//加载下蹲素材
	loadimage(&amp;imgDown[0], "res/d1.png");
	loadimage(&amp;imgDown[1], "res/d2.png");

	//加载各种障碍物的信息
	IMAGE imgTort;						//乌龟
	loadimage(&amp;imgTort, "res/t1.png");
	vector&lt;IMAGE&gt;imgTortArray;
	imgTortArray.push_back(imgTort);
	obstacleImgs.push_back(imgTortArray);

	IMAGE imgLion;
	vector&lt;IMAGE&gt;imgLionArray;
	for (int i = 0; i &lt; 6; i++) {
		
		sprintf_s(name, "res/p%d.png", i + 1);
		loadimage(&amp;imgLion, name);
		imgLionArray.push_back(imgLion);
	}
	obstacleImgs.push_back(imgLionArray);

	IMAGE imgH;
	
	for (int i = 0; i &lt; 4; i++) {
		vector&lt;IMAGE&gt;imgHookArray;
		sprintf_s(name, "res/h%d.png", i + 1);
		loadimage(&amp;imgH, name,63,260,true);
		imgHookArray.push_back(imgH);
		obstacleImgs.push_back(imgHookArray);
	}
	//初始化障碍物
	for (int i = 0; i &lt; OBSTACLE_COUNT; i++) {
		obstacles[i].exist = false;
	}

}
void updataObstacle() {
	for (int i = 0; i &lt; OBSTACLE_COUNT; i++) {
		if (obstacles[i].exist) {
			putimagePNG2(obstacles[i].x, obstacles[i].y, SCREEN_LONG,
				&amp;obstacleImgs[obstacles[i].type][obstacles[i].imgIndex]);
		}
	}
}
void creatObstacle() {
	int i;
	for (i = 0; i &lt; OBSTACLE_COUNT; i++) {
		if (obstacles[i].exist == false) {
			break;
		}
	}
	if (i &gt;= OBSTACLE_COUNT) {
		return;
	}
	obstacles[i].exist = true;
	obstacles[i].imgIndex = 0;
	obstacles[i].hit = false;
	obstacles[i].passed = false;
	obstacles[i].type = rand() % 3;
	if (obstacles[i].type == HOOK1) {
		obstacles[i].type += rand() % 4;
	}
	obstacles[i].x = SCREEN_LONG;
	obstacles[i].y = 345 + 5 - obstacleImgs[obstacles[i].type][0].getheight();
	if (obstacles[i].type == TORTOISE) {
		obstacles[i].speed = 0;
		obstacles[i].power = 5;
	}
	else if (obstacles[i].type == LION) {
		obstacles[i].speed = 4;
		obstacles[i].power = 20;
	}
	else if (obstacles[i].type &gt;= HOOK1 &amp;&amp; obstacles[i].type &lt;= HOOK4) {
		obstacles[i].speed = 0;
		obstacles[i].power = 20;
		obstacles[i].y = 0;
	}
}
//渲染背景图片
void updataBg() {
	putimagePNG2(bgX[0], 0, &amp;bg_Img[0]);
	putimagePNG2(bgX[1], 119, &amp;bg_Img[1]);
	putimagePNG2(bgX[2], 330, &amp;bg_Img[2]);
}
void updataHero() {
	if (!heroDown) {
		putimagePNG2(heroX, heroY, &amp;heroImg[heroIndex]);
	}
	else {
		int y = 345 - imgDown[heroIndex].getheight();
		putimagePNG2(heroX, y, &amp;imgDown[heroIndex]);
	}
}
void fly() {
	for (int i = 0; i &lt; 3; i++) {
		bgX[i] -= bg_Speed[i];
		if (bgX[i] &lt; -SCREEN_LONG) {
			bgX[i] = 0;
		}
	}
	
	//跳跃
	if (heroJump == true) {
		if (heroY &lt; heroJumpMax) {
			heroJumpOff = 12;
		}	
		heroY += heroJumpOff;
		if (heroY &gt;= 345-heroImg[heroIndex].getheight()){
			heroJumpOff = -12;
			heroJump = false;
		}
	}
	else if (heroDown == true) {
		static int count = 0;
		int delay[2] = { 4,10 };
		count++;
		if (count &gt;= delay[heroIndex]) {
			count = 0;
			heroIndex++;
			if (heroIndex &gt;= 2) {
				heroIndex = 0;
				heroDown = false;
			}
		}

	}
	 else {//不跳越不下蹲
		heroIndex = (heroIndex + 1) % 12;
	}
	static int frameCount = 0;
	static int enemyFre = 50;
	frameCount++;
	if (frameCount &gt; enemyFre) {
		frameCount = 0;
		enemyFre = 25 + rand() % 25;
		creatObstacle();

	}
	//更新障碍物的坐标
	for (int i = 0; i &lt; OBSTACLE_COUNT; i++) {
		if (obstacles[i].exist) {
			obstacles[i].x -= obstacles[i].speed + bg_Speed[2];
			if (obstacles[i].x &lt; obstacleImgs[obstacles[i].type][0].getwidth() - 100) {
				obstacles[i].exist = false;
			}
			int len = obstacleImgs[obstacles[i].type].size();
			obstacles[i].imgIndex = (obstacles[i].imgIndex + 1) % len;
		}
	}
}
void Jump() {
	heroJump = true;
	updata = true;
}
void Down() {
	heroDown = true;
	updata = true;
	heroIndex = 0;
}
void keyEvent() {
	if (_kbhit())
	{
		char ch = _getch();
		if (ch == ' ') {
			Jump();
		}
		if (ch == 'a') {
			Down();
		}

	}
}
int main() {
	init();
	int timer=0;
	while (1) {	
		timer += getDelay();
		if (timer &gt; 30) {
			timer = 0;
			updata = true;
		}
		if (updata) {
			keyEvent();
			updata = false;
			BeginBatchDraw();
			updataBg();
			updataHero();
			updataObstacle();
			EndBatchDraw();
			fly();
		}
		
	}
	
	system("pause");
	return 0;
}</code></pre> 
<p><strong>实现效果</strong> </p> 
<p><img alt="" height="531" src="https://images2.imgbox.com/43/db/35zF8yP7_o.png" width="1200"></p> 
<p> </p> 
<p><strong>要点详解</strong></p> 
<p>在我们的fly函数中进行障碍物的显示</p> 
<pre><code class="language-cpp">static int frameCount = 0;
	static int enemyFre = 50;
	frameCount++;
	if (frameCount &gt; enemyFre) {
		frameCount = 0;
		enemyFre = 25 + rand() % 25;
		creatObstacle();

	}</code></pre> 
<p>这一段函数是障碍物产生的频率，可以自己调整增加难度。</p> 
<pre><code class="language-cpp">for (int i = 0; i &lt; OBSTACLE_COUNT; i++) {
		if (obstacles[i].exist) {
			obstacles[i].x -= obstacles[i].speed + bg_Speed[2];
			if (obstacles[i].x &lt; 0) {
				obstacles[i].exist = false;
			}
			int len = obstacleImgs[obstacles[i].type].size();
			obstacles[i].imgIndex = (obstacles[i].imgIndex + 1) % len;
		}
	}</code></pre> 
<p>这一段是更新障碍物的坐标。当障碍物的x坐标&lt;0也就是到达屏幕最左边时，将这个障碍物删除.</p> 
<p><strong>六.加载音乐，检验碰撞。</strong></p> 
<pre><code class="language-cpp">#include"tools.h";
#include&lt;iostream&gt;
#include&lt;graphics.h&gt;
#include&lt;conio.h&gt;
#include&lt;vector&gt;
using namespace std;
#define SCREEN_LONG 1012
#define SCREEN_WIDTH 396
#define OBSTACLE_COUNT 10
IMAGE bg_Img[3];			//存放游戏背景图片
int bgX[3];                 //背景图片的X坐标
int bg_Speed[3] = { 1,3,12}; //背景图片滚动的速度
bool updata;				//当前是否需要刷新
IMAGE heroImg[12];			//存放人物背景图片
int heroX;					//人物X坐标
int heroY;					//人物Y坐标
int heroIndex;
bool heroJump;
bool heroDown;
int heroJumpOff;			//人物跳跃速度
int heroJumpMax;			//人物跳跃高度
IMAGE imgDown[2];
int heroBlood;
enum obstacle_type {
	TORTOISE,
	LION,
	HOOK1,
	HOOK2,
	HOOK3,
	HOOK4,
	OBSTACLE_TYPE_COUNT
};
struct obstacle_t {
	int type;				//障碍物类型
	int imgIndex;			//障碍物图片序号
	int x, y;				//障碍物坐标
	int speed;				//障碍物速度
	int power;				//障碍物攻击力
	bool exist;				//障碍物当前是否存在
	bool hit;				//障碍物和人物是否发生碰撞
	bool passed;			//障碍物是否被通过
};
obstacle_t obstacles[OBSTACLE_COUNT];    //储存障碍物信息的一维数组
vector&lt;vector&lt;IMAGE&gt;&gt; obstacleImgs;			//特殊的二维数组
//游戏的初始化
void init() {
	initgraph(SCREEN_LONG, SCREEN_WIDTH);


	char name[64];
	//导入背景图片
	for (int i = 0; i &lt; 3; i++) {
		sprintf_s(name, "res/bg%03d.png",i+1);
		loadimage(&amp;bg_Img[i], name);
	}
	updata = true;
	//导入人物奔跑图片
	for (int i = 0; i &lt; 12; i++) {
		sprintf_s(name, "res/hero%d.png",i+1);
		loadimage(&amp;heroImg[i], name);
	}
	heroIndex = 0;
	heroX = SCREEN_LONG/2 - heroImg[heroIndex].getwidth();
	heroY = 345-heroImg[heroIndex].getheight();
	

	
	heroJump = false;
	heroDown = false;
	heroJumpOff = -12;
	heroJumpMax = 345 - heroImg[heroIndex].getheight() - 120;
	//加载下蹲素材
	loadimage(&amp;imgDown[0], "res/d1.png");
	loadimage(&amp;imgDown[1], "res/d2.png");

	//加载各种障碍物的信息
	IMAGE imgTort;						//乌龟
	loadimage(&amp;imgTort, "res/t1.png");
	vector&lt;IMAGE&gt;imgTortArray;
	imgTortArray.push_back(imgTort);
	obstacleImgs.push_back(imgTortArray);

	IMAGE imgLion;
	vector&lt;IMAGE&gt;imgLionArray;
	for (int i = 0; i &lt; 6; i++) {
		
		sprintf_s(name, "res/p%d.png", i + 1);
		loadimage(&amp;imgLion, name);
		imgLionArray.push_back(imgLion);
	}
	obstacleImgs.push_back(imgLionArray);

	IMAGE imgH;
	
	for (int i = 0; i &lt; 4; i++) {
		vector&lt;IMAGE&gt;imgHookArray;
		sprintf_s(name, "res/h%d.png", i + 1);
		loadimage(&amp;imgH, name,63,260,true);
		imgHookArray.push_back(imgH);
		obstacleImgs.push_back(imgHookArray);
	}
	//初始化障碍物
	for (int i = 0; i &lt; OBSTACLE_COUNT; i++) {
		obstacles[i].exist = false;
	}
	heroBlood = 100;         //初始化血量
	preLoadSound("res/hit.mp3");   //预加载碰撞音效
	mciSendString("play res/bg.mp3", 0, 0, 0);   //加载背景音乐
}
void updataObstacle() {
	for (int i = 0; i &lt; OBSTACLE_COUNT; i++) {
		if (obstacles[i].exist) {
			putimagePNG2(obstacles[i].x, obstacles[i].y, SCREEN_LONG,
				&amp;obstacleImgs[obstacles[i].type][obstacles[i].imgIndex]);
		}
	}
}
void creatObstacle() {
	int i;
	for (i = 0; i &lt; OBSTACLE_COUNT; i++) {
		if (obstacles[i].exist == false) {
			break;
		}
	}
	if (i &gt;= OBSTACLE_COUNT) {
		return;
	}
	obstacles[i].exist = true;
	obstacles[i].imgIndex = 0;
	obstacles[i].hit = false;
	obstacles[i].passed = false;
	obstacles[i].type = rand() % 3;
	if (obstacles[i].type == HOOK1) {
		obstacles[i].type += rand() % 4;
	}
	obstacles[i].x = SCREEN_LONG;
	obstacles[i].y = 345 + 5 - obstacleImgs[obstacles[i].type][0].getheight();
	if (obstacles[i].type == TORTOISE) {
		obstacles[i].speed = 0;
		obstacles[i].power = 5;
	}
	else if (obstacles[i].type == LION) {
		obstacles[i].speed = 4;
		obstacles[i].power = 20;
	}
	else if (obstacles[i].type &gt;= HOOK1 &amp;&amp; obstacles[i].type &lt;= HOOK4) {
		obstacles[i].speed = 0;
		obstacles[i].power = 20;
		obstacles[i].y = 0;
	}
}
//渲染背景图片
void updataBg() {
	putimagePNG2(bgX[0], 0, &amp;bg_Img[0]);
	putimagePNG2(bgX[1], 119, &amp;bg_Img[1]);
	putimagePNG2(bgX[2], 330, &amp;bg_Img[2]);
}
void checkHit() {
	for (int i = 0; i &lt; OBSTACLE_COUNT; i++) {
		if (obstacles[i].exist &amp;&amp; obstacles[i].hit == false) {
			int a1x, a1y, a2x, a2y;
			int off = 30;
			if (!heroDown) {
				a1x = heroX + off;
				a1y = heroY + off;
				a2x = heroX + heroImg[heroIndex].getwidth() - off;
				a2y = heroY + heroImg[heroIndex].getheight();
			}
			else {
				a1x = heroX + off;
				a1y = 345 - imgDown[heroIndex].getheight();
				a2x = heroX + imgDown[heroIndex].getwidth() - off;
				a2y = 345;
			}
			int b1x = obstacles[i].x + off;
			int b1y = obstacles[i].y + off;
			int b2x = obstacles[i].x + obstacleImgs[obstacles[i].type][obstacles[i].imgIndex].getwidth() - off;
			int b2y = obstacles[i].y + obstacleImgs[obstacles[i].type][obstacles[i].imgIndex].getheight() - 10;
			if (rectIntersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y)) {
				heroBlood -= obstacles[i].power;
				cout &lt;&lt; "剩下" &lt;&lt; heroBlood &lt;&lt; " 血量" &lt;&lt; endl;
				playSound("res/hit.mp3");
				obstacles[i].hit = true;
			}
		}
	}
}
void updataHero() {
	if (!heroDown) {
		putimagePNG2(heroX, heroY, &amp;heroImg[heroIndex]);
	}
	else {
		int y = 345 - imgDown[heroIndex].getheight();
		putimagePNG2(heroX, y, &amp;imgDown[heroIndex]);
	}
}
void fly() {
	for (int i = 0; i &lt; 3; i++) {
		bgX[i] -= bg_Speed[i];
		if (bgX[i] &lt; -SCREEN_LONG) {
			bgX[i] = 0;
		}
	}
	
	//跳跃
	if (heroJump == true) {
		if (heroY &lt; heroJumpMax) {
			heroJumpOff = 12;
		}	
		heroY += heroJumpOff;
		if (heroY &gt;= 345-heroImg[heroIndex].getheight()){
			heroJumpOff = -12;
			heroJump = false;
		}
	}
	else if (heroDown == true) {
		static int count = 0;
		int delay[2] = { 4,10 };
		count++;
		if (count &gt;= delay[heroIndex]) {
			count = 0;
			heroIndex++;
			if (heroIndex &gt;= 2) {
				heroIndex = 0;
				heroDown = false;
			}
		}

	}
	 else {//不跳越不下蹲
		heroIndex = (heroIndex + 1) % 12;
	}
	static int frameCount = 0;
	static int enemyFre = 50;
	frameCount++;
	if (frameCount &gt; enemyFre) {
		frameCount = 0;
		enemyFre = 25 + rand() % 25;
		creatObstacle();

	}
	//更新障碍物的坐标
	for (int i = 0; i &lt; OBSTACLE_COUNT; i++) {
		if (obstacles[i].exist) {
			obstacles[i].x -= obstacles[i].speed + bg_Speed[2];
			if (obstacles[i].x &lt;0 ) {
				obstacles[i].exist = false;
			}
			int len = obstacleImgs[obstacles[i].type].size();
			obstacles[i].imgIndex = (obstacles[i].imgIndex + 1) % len;
		}
	}
	checkHit();
}

void Jump() {
	heroJump = true;
	updata = true;
}
void Down() {
	heroDown = true;
	updata = true;
	heroIndex = 0;
}
void keyEvent() {
	if (_kbhit())
	{
		char ch = _getch();
		if (ch == ' ') {
			Jump();
		}
		if (ch == 'a') {
			Down();
		}

	}
}
int main() {
	init();
	int timer=0;
	while (1) {	
		timer += getDelay();
		if (timer &gt; 30) {
			timer = 0;
			updata = true;
		}
		if (updata) {
			keyEvent();
			updata = false;
			BeginBatchDraw();
			updataBg();
			updataHero();
			updataObstacle();
			EndBatchDraw();
			fly();
		}
		
	}
	
	system("pause");
	return 0;
}</code></pre> 
<p> <strong>要点详解</strong></p> 
<p>检验碰撞我们采用了别人做好的工具rectIntersect()函数，我们只需要提供四个坐标</p> 
<p><img alt="" height="330" src="https://images2.imgbox.com/ef/b7/4jR3rJQx_o.png" width="774"></p> 
<p> 当人物与障碍物的坐标相遇的时候，函数就会检测到碰撞。</p> 
<p><strong>七.显示血条分数以及游戏结束条件。</strong></p> 
<pre><code class="language-cpp">#include"tools.h";
#include&lt;iostream&gt;
#include&lt;graphics.h&gt;
#include&lt;conio.h&gt;
#include&lt;vector&gt;
using namespace std;
#define SCREEN_LONG 1012
#define SCREEN_WIDTH 396
#define OBSTACLE_COUNT 10
IMAGE bg_Img[3];			//存放游戏背景图片
int bgX[3];                 //背景图片的X坐标
int bg_Speed[3] = { 1,3,12}; //背景图片滚动的速度
bool updata;				//当前是否需要刷新
IMAGE heroImg[12];			//存放人物背景图片
int heroX;					//人物X坐标
int heroY;					//人物Y坐标
int heroIndex;
bool heroJump;
bool heroDown;
int heroJumpOff;			//人物跳跃速度
int heroJumpMax;			//人物跳跃高度
IMAGE imgDown[2];
int heroBlood;
int score;
IMAGE imgSZ[10];
#define WIN_SCORE 10
enum obstacle_type {
	TORTOISE,
	LION,
	HOOK1,
	HOOK2,
	HOOK3,
	HOOK4,
	OBSTACLE_TYPE_COUNT
};
struct obstacle_t {
	int type;				//障碍物类型
	int imgIndex;			//障碍物图片序号
	int x, y;				//障碍物坐标
	int speed;				//障碍物速度
	int power;				//障碍物攻击力
	bool exist;				//障碍物当前是否存在
	bool hit;				//障碍物和人物是否发生碰撞
	bool passed;			//障碍物是否被通过
};
obstacle_t obstacles[OBSTACLE_COUNT];    //储存障碍物信息的一维数组
vector&lt;vector&lt;IMAGE&gt;&gt; obstacleImgs;			//特殊的二维数组
//游戏的初始化
void init() {
	initgraph(SCREEN_LONG, SCREEN_WIDTH);


	char name[64];
	//导入背景图片
	for (int i = 0; i &lt; 3; i++) {
		sprintf_s(name, "res/bg%03d.png",i+1);
		loadimage(&amp;bg_Img[i], name);
	}
	updata = true;
	//导入人物奔跑图片
	for (int i = 0; i &lt; 12; i++) {
		sprintf_s(name, "res/hero%d.png",i+1);
		loadimage(&amp;heroImg[i], name);
	}
	heroIndex = 0;
	heroX = SCREEN_LONG/2 - heroImg[heroIndex].getwidth();
	heroY = 345-heroImg[heroIndex].getheight();
	

	
	heroJump = false;
	heroDown = false;
	heroJumpOff = -12;
	heroJumpMax = 345 - heroImg[heroIndex].getheight() - 120;
	//加载下蹲素材
	loadimage(&amp;imgDown[0], "res/d1.png");
	loadimage(&amp;imgDown[1], "res/d2.png");

	//加载各种障碍物的信息
	IMAGE imgTort;						//乌龟
	loadimage(&amp;imgTort, "res/t1.png");
	vector&lt;IMAGE&gt;imgTortArray;
	imgTortArray.push_back(imgTort);
	obstacleImgs.push_back(imgTortArray);

	IMAGE imgLion;
	vector&lt;IMAGE&gt;imgLionArray;
	for (int i = 0; i &lt; 6; i++) {
		
		sprintf_s(name, "res/p%d.png", i + 1);
		loadimage(&amp;imgLion, name);
		imgLionArray.push_back(imgLion);
	}
	obstacleImgs.push_back(imgLionArray);

	IMAGE imgH;
	
	for (int i = 0; i &lt; 4; i++) {
		vector&lt;IMAGE&gt;imgHookArray;
		sprintf_s(name, "res/h%d.png", i + 1);
		loadimage(&amp;imgH, name,63,260,true);
		imgHookArray.push_back(imgH);
		obstacleImgs.push_back(imgHookArray);
	}
	//初始化障碍物
	for (int i = 0; i &lt; OBSTACLE_COUNT; i++) {
		obstacles[i].exist = false;
	}
	heroBlood = 100;
	preLoadSound("res/hit.mp3");
	mciSendString("play res/bg.mp3", 0, 0, 0);
	score = 0;
	for (int i = 0; i &lt; 10; i++) {
		sprintf_s(name, "res/sz/%d.png", i);
		loadimage(&amp;imgSZ[i], name);
	}
}
void updataObstacle() {
	for (int i = 0; i &lt; OBSTACLE_COUNT; i++) {
		if (obstacles[i].exist) {
			putimagePNG2(obstacles[i].x, obstacles[i].y, SCREEN_LONG,
				&amp;obstacleImgs[obstacles[i].type][obstacles[i].imgIndex]);
		}
	}
}
void creatObstacle() {
	int i;
	for (i = 0; i &lt; OBSTACLE_COUNT; i++) {
		if (obstacles[i].exist == false) {
			break;
		}
	}
	if (i &gt;= OBSTACLE_COUNT) {
		return;
	}
	obstacles[i].exist = true;
	obstacles[i].imgIndex = 0;
	obstacles[i].hit = false;
	obstacles[i].passed = false;
	obstacles[i].type = rand() % 3;
	if (obstacles[i].type == HOOK1) {
		obstacles[i].type += rand() % 4;
	}
	obstacles[i].x = SCREEN_LONG;
	obstacles[i].y = 345 + 5 - obstacleImgs[obstacles[i].type][0].getheight();
	if (obstacles[i].type == TORTOISE) {
		obstacles[i].speed = 0;
		obstacles[i].power = 5;
	}
	else if (obstacles[i].type == LION) {
		obstacles[i].speed = 4;
		obstacles[i].power = 20;
	}
	else if (obstacles[i].type &gt;= HOOK1 &amp;&amp; obstacles[i].type &lt;= HOOK4) {
		obstacles[i].speed = 0;
		obstacles[i].power = 20;
		obstacles[i].y = 0;
	}
}
//渲染背景图片
void updataBg() {
	putimagePNG2(bgX[0], 0, &amp;bg_Img[0]);
	putimagePNG2(bgX[1], 119, &amp;bg_Img[1]);
	putimagePNG2(bgX[2], 330, &amp;bg_Img[2]);
}
void checkHit() {
	for (int i = 0; i &lt; OBSTACLE_COUNT; i++) {
		if (obstacles[i].exist &amp;&amp; obstacles[i].hit == false) {
			int a1x, a1y, a2x, a2y;
			int off = 30;
			if (!heroDown) {
				a1x = heroX + off;
				a1y = heroY + off;
				a2x = heroX + heroImg[heroIndex].getwidth() - off;
				a2y = heroY + heroImg[heroIndex].getheight();
			}
			else {
				a1x = heroX + off;
				a1y = 345 - imgDown[heroIndex].getheight();
				a2x = heroX + imgDown[heroIndex].getwidth() - off;
				a2y = 345;
			}
			int b1x = obstacles[i].x + off;
			int b1y = obstacles[i].y + off;
			int b2x = obstacles[i].x + obstacleImgs[obstacles[i].type][obstacles[i].imgIndex].getwidth() - off;
			int b2y = obstacles[i].y + obstacleImgs[obstacles[i].type][obstacles[i].imgIndex].getheight() - 10;
			if (rectIntersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y)) {
				heroBlood -= obstacles[i].power;
				cout &lt;&lt; "剩下" &lt;&lt; heroBlood &lt;&lt; " 血量" &lt;&lt; endl;
				playSound("res/hit.mp3");
				obstacles[i].hit = true;
			}
		}
	}
}
void updataBloodBar() {
	drawBloodBar(10, 10, 200, 10, 2, BLUE, DARKGRAY, RED, heroBlood / 100.0);
}
void updataHero() {
	if (!heroDown) {
		putimagePNG2(heroX, heroY, &amp;heroImg[heroIndex]);
	}
	else {
		int y = 345 - imgDown[heroIndex].getheight();
		putimagePNG2(heroX, y, &amp;imgDown[heroIndex]);
	}
}
void fly() {
	for (int i = 0; i &lt; 3; i++) {
		bgX[i] -= bg_Speed[i];
		if (bgX[i] &lt; -SCREEN_LONG) {
			bgX[i] = 0;
		}
	}
	
	//跳跃
	if (heroJump == true) {
		if (heroY &lt; heroJumpMax) {
			heroJumpOff = 12;
		}	
		heroY += heroJumpOff;
		if (heroY &gt;= 345-heroImg[heroIndex].getheight()){
			heroJumpOff = -12;
			heroJump = false;
		}
	}
	else if (heroDown == true) {
		static int count = 0;
		int delay[2] = { 4,10 };
		count++;
		if (count &gt;= delay[heroIndex]) {
			count = 0;
			heroIndex++;
			if (heroIndex &gt;= 2) {
				heroIndex = 0;
				heroDown = false;
			}
		}

	}
	 else {//不跳越不下蹲
		heroIndex = (heroIndex + 1) % 12;
	}
	static int frameCount = 0;
	static int enemyFre = 50;
	frameCount++;
	if (frameCount &gt; enemyFre) {
		frameCount = 0;
		enemyFre = 25 + rand() % 25;
		creatObstacle();

	}
	//更新障碍物的坐标
	for (int i = 0; i &lt; OBSTACLE_COUNT; i++) {
		if (obstacles[i].exist) {
			obstacles[i].x -= obstacles[i].speed + bg_Speed[2];
			if (obstacles[i].x &lt;0 ) {
				obstacles[i].exist = false;
			}
			int len = obstacleImgs[obstacles[i].type].size();
			obstacles[i].imgIndex = (obstacles[i].imgIndex + 1) % len;
		}
	}
	checkHit();
}

void Jump() {
	heroJump = true;
	updata = true;
}
void Down() {
	heroDown = true;
	updata = true;
	heroIndex = 0;
}
void keyEvent() {
	if (_kbhit())
	{
		char ch = _getch();
		if (ch == ' ') {
			Jump();
		}
		if (ch == 'a') {
			Down();
		}

	}
}
void cheakOver() {
	if (heroBlood &lt;= 0) {
		loadimage(0, "res/over.png");
		FlushBatchDraw();
		mciSendString("stop res/bg.mp3", 0, 0, 0);
		system("pause");
		system("cls");
		cout &lt;&lt; "按q退出，按其他键继续游戏";
		char ch = _getch();
		if (ch == 'q') {
			exit(-1);
		}
		heroBlood = 100;
		score = 0;
		mciSendString("play res/bg.mp3", 0, 0, 0);

	}
}
void cheakScore() {
	for (int i = 0; i &lt; OBSTACLE_COUNT; i++) {
		if (obstacles[i].exist &amp;&amp; obstacles[i].passed == false &amp;&amp;
			obstacles[i].x + obstacleImgs[obstacles[i].type][
				0].getwidth() &lt; heroX &amp;&amp; obstacles[i].hit == false) {
			score++;
			obstacles[i].passed = true;
			cout &lt;&lt; "现在是" &lt;&lt; score &lt;&lt; "分";
		}
	}
}
void updataScore() {
	char str[8];
	sprintf_s(str, "%d", score);
	int x = 20;
	int y = 25;
	for (int i = 0; i &lt; str[i]; i++) {
		int sz = str[i] - '0';
		putimagePNG(x, y, &amp;imgSZ[sz]);
		x += imgSZ-&gt;getwidth() + 5;
	}
}
void cheakWin() {
	if (score &gt;= WIN_SCORE) {
		mciSendString("play res/win.mp3", 0, 0, 0);
		Sleep(1000);
		loadimage(0, "res/win.png");
		FlushBatchDraw();
		mciSendString("stop res/bg.mp3", 0, 0, 0);
		system("pause");
	}
}
int main() {
	init();
	int timer=0;
	while (1) {	
		timer += getDelay();
		if (timer &gt; 30) {
			timer = 0;
			updata = true;
		}
		if (updata) {
			keyEvent();
			updata = false;
			BeginBatchDraw();
			updataBg();
			updataHero();
			updataObstacle();
			updataBloodBar();
			updataScore();
			EndBatchDraw();
			cheakOver();
			cheakScore();
			cheakWin();
			fly();
		}
		
	}
	
	system("pause");
	return 0;
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/55fb35945bc557e4be93ef4eca45bcfd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">不得不吐槽的暗黑4的游戏设计问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5c17e15061d750e2f6366d42f42f7c79/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Jupyter Notebook 遇上 NebulaGraph，可视化探索图数据库</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>