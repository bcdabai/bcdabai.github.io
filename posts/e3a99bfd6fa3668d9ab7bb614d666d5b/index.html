<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>STM32自定义串口通信协议 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="STM32自定义串口通信协议" />
<meta property="og:description" content="/* USER CODE BEGIN Header */ /** ****************************************************************************** * @file usart.c * @brief This file provides code for the configuration * of the USART instances. ****************************************************************************** * @attention * * Copyright (c) 2023 STMicroelectronics. * All rights reserved. * * This software is licensed under terms that can be found in the LICENSE file * in the root directory of this software component. * If no LICENSE file comes with this software, it is provided AS-IS." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/e3a99bfd6fa3668d9ab7bb614d666d5b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-28T11:11:26+08:00" />
<meta property="article:modified_time" content="2023-07-28T11:11:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">STM32自定义串口通信协议</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p> </p> 
<pre><code class="hljs">/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file    usart.c
  * @brief   This file provides code for the configuration
  *          of the USART instances.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2023 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "usart.h"

/* USER CODE BEGIN 0 */
int fputc(int ch, FILE *f)
{
	HAL_UART_Transmit(&amp;huart3, (uint8_t *)&amp;ch,1,0xffff);
  return ch;
}

#include &lt;string.h&gt;
#define UART_BUFFER_SIZE 100
#define MAX_RETRIES 2   // 最大重试次数
#define TIMEOUT_MS 100

// 自定义通信协议数据结构
typedef struct
{
    uint8_t start_byte;     // 开始标识（1字节）
    uint8_t source;         // 数据来源（1字节）
    uint8_t type;           // 数据类型（1字节）
    uint16_t length;        // 数据长度（2字节）
    uint8_t* data;          // 数据
    uint16_t checksum;      // 校验和（2字节）
    uint16_t end_byte[2];   // 结束标识（2字节）
} CustomProtocol;

// 定时器超时标志
volatile uint8_t timeoutFlag = 0;
/* USER CODE END 0 */

UART_HandleTypeDef huart3;

/* USART3 init function */

void MX_USART3_UART_Init(void)
{

  /* USER CODE BEGIN USART3_Init 0 */

  /* USER CODE END USART3_Init 0 */

  /* USER CODE BEGIN USART3_Init 1 */

  /* USER CODE END USART3_Init 1 */
  huart3.Instance = USART3;
  huart3.Init.BaudRate = 115200;
  huart3.Init.WordLength = UART_WORDLENGTH_8B;
  huart3.Init.StopBits = UART_STOPBITS_1;
  huart3.Init.Parity = UART_PARITY_NONE;
  huart3.Init.Mode = UART_MODE_TX_RX;
  huart3.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart3.Init.OverSampling = UART_OVERSAMPLING_16;
  if (HAL_UART_Init(&amp;huart3) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN USART3_Init 2 */

  /* USER CODE END USART3_Init 2 */

}

void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle)
{

  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(uartHandle-&gt;Instance==USART3)
  {
  /* USER CODE BEGIN USART3_MspInit 0 */

  /* USER CODE END USART3_MspInit 0 */
    /* USART3 clock enable */
    __HAL_RCC_USART3_CLK_ENABLE();

    __HAL_RCC_GPIOB_CLK_ENABLE();
    /**USART3 GPIO Configuration
    PB10     ------&gt; USART3_TX
    PB11     ------&gt; USART3_RX
    */
    GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_11;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART3;
    HAL_GPIO_Init(GPIOB, &amp;GPIO_InitStruct);

    /* USART3 interrupt Init */
    HAL_NVIC_SetPriority(USART3_IRQn, 0, 0);
    HAL_NVIC_EnableIRQ(USART3_IRQn);
  /* USER CODE BEGIN USART3_MspInit 1 */

  /* USER CODE END USART3_MspInit 1 */
  }
}

void HAL_UART_MspDeInit(UART_HandleTypeDef* uartHandle)
{

  if(uartHandle-&gt;Instance==USART3)
  {
  /* USER CODE BEGIN USART3_MspDeInit 0 */

  /* USER CODE END USART3_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_USART3_CLK_DISABLE();

    /**USART3 GPIO Configuration
    PB10     ------&gt; USART3_TX
    PB11     ------&gt; USART3_RX
    */
    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_10|GPIO_PIN_11);

    /* USART3 interrupt Deinit */
    HAL_NVIC_DisableIRQ(USART3_IRQn);
  /* USER CODE BEGIN USART3_MspDeInit 1 */

  /* USER CODE END USART3_MspDeInit 1 */
  }
}

/* USER CODE BEGIN 1 */
// 计算CRC校验码的函数
uint16_t calculateCRC(uint8_t* data, uint8_t length) 
{
    // 在此实现CRC计算逻辑
    uint16_t crc = 0xFFFF;
    
    for (int i = 0; i &lt; length; i++) {
        crc ^= data[i];
        
        for (int j = 0; j &lt; 8; j++) {
            if (crc &amp; 0x0001) {
                crc &gt;&gt;= 1;
                crc ^= 0xA001;
            } else {
                crc &gt;&gt;= 1;
            }
        }
    }
    
    return crc;
}

// 发送数据函数
void sendData(uint8_t* data, uint8_t length, uint8_t source) 
{
    // 计算CRC校验码
    uint16_t crc = calculateCRC(data, length);
    
    // 创建发送缓冲区，包括数据和CRC校验码
    uint8_t uartTxBuffer[UART_BUFFER_SIZE];
	  uint8_t ack_RxBuffer[UART_BUFFER_SIZE];
    uint8_t txIndex = 0;
    uint8_t ack_rxIndex = 0;

    // 添加开始标识
    uartTxBuffer[txIndex++] = 0xAA; // 可根据需要修改为实际的开始标识
    
    // 添加数据来源
    uartTxBuffer[txIndex++] = source;
    
    // 添加数据类型
    uartTxBuffer[txIndex++] = 0x00; // 数据类型为0x00
    
    // 添加数据长度
    uartTxBuffer[txIndex++] = length &amp; 0xFF;
    uartTxBuffer[txIndex++] = (length &gt;&gt; 8) &amp; 0xFF;
    
    // 添加数据
    memcpy(uartTxBuffer + txIndex, data, length);
    txIndex += length;
    
    // 添加校验和
    uartTxBuffer[txIndex++] = crc &amp; 0xFF;
    uartTxBuffer[txIndex++] = (crc &gt;&gt; 8) &amp; 0xFF;

    // 添加结束标识
    uartTxBuffer[txIndex++] = 0xBB;
    uartTxBuffer[txIndex++] = 0xCC;
    
    // 使用UART发送数据
    //HAL_UART_Transmit(&amp;huart3, uartTxBuffer, txIndex, HAL_MAX_DELAY);
		for (int i = 0; i &lt; txIndex; i++) 
		{
        printf("%02x ", uartTxBuffer[i]);
    }
    printf("\n");
    
    // 等待接收ACK超时时间
    uint32_t startTime = HAL_GetTick();
    
    // 接收ACK确认消息
    while (1) 
    {
        if (HAL_UART_Receive(&amp;huart3, &amp;ack_RxBuffer[ack_rxIndex], 1, HAL_MAX_DELAY) == HAL_OK) 
        {
            // 检查是否接收到开始标识
            if (ack_RxBuffer[ack_rxIndex] == 0xAA) // 可根据实际情况修改为实际的开始标识
            {
                if (ack_rxIndex &gt;= 4) // 校验接收到的数据长度，确保长度足够包含相关字段
                {
                    uint16_t length = ack_RxBuffer[2] + (ack_RxBuffer[3] &lt;&lt; 8);
                    
                    if (ack_rxIndex == length + 5) // 校验数据长度
                    {
                        CustomProtocol protocol;
                        
                        // 解析接收到的数据
                        protocol.start_byte = ack_RxBuffer[0];
                        protocol.source = ack_RxBuffer[1];
                        protocol.length = length;
                        protocol.data = &amp;ack_RxBuffer[4];
                        protocol.checksum = ack_RxBuffer[ack_rxIndex - 2] + (ack_RxBuffer[ack_rxIndex - 1] &lt;&lt; 8);
                        protocol.end_byte[0] = ack_RxBuffer[ack_rxIndex - 6];
                        protocol.end_byte[1] = ack_RxBuffer[ack_rxIndex - 5];
                        
                        // 校验校验和和结束标识
                        if (protocol.checksum == calculateCRC(protocol.data, protocol.length) &amp;&amp;
                            protocol.end_byte[0] == 0xBB &amp;&amp; protocol.end_byte[1] == 0xCC) 
                        {                                            
                            // 判断数据类型是否为0xFF
                            if (protocol.data[0] == 0xFF)
                            {
                                // 接收到ACK确认消息，处理确认逻辑
                                handleAck();
                                break;
                            }
                            else
                            {
                                // 接收到无效数据，继续等待
                                continue;
                            }                           
                        } else 
                        {
                            continue;
                        }
                    }
                }
            }           
        }
        ack_rxIndex++;
    }
        
        // 检查是否超时
        if (HAL_GetTick() - startTime &gt;= TIMEOUT_MS) 
        {
            timeoutFlag = 1;
            //break;
        }
    
    
    // 处理超时重传
    if (timeoutFlag) 
    {
        for (int i = 0; i &lt; MAX_RETRIES; i++) 
        {
            timeoutFlag = 0;
            
            // 重新发送数据
            HAL_UART_Transmit(&amp;huart3, uartTxBuffer, txIndex, HAL_MAX_DELAY);
            
            // 等待接收ACK确认消息
            // ...
        }
        
        // 达到最大重试次数后处理错误逻辑
        handleTransmissionError();
    }
}

void receiveData()
{
    uint8_t uartRxBuffer[UART_BUFFER_SIZE];
    uint16_t rxIndex = 0;
    
    while (1) 
    {
        if (HAL_UART_Receive(&amp;huart3, &amp;uartRxBuffer[rxIndex], 1, HAL_MAX_DELAY) == HAL_OK) 
        {
            if (uartRxBuffer[rxIndex] == 0xAA) // 可根据实际情况修改为实际的开始标识
            {
                if (rxIndex &gt;= 4) // 校验接收到的数据长度，确保长度足够包含相关字段
                {
                    uint16_t length = uartRxBuffer[2] + (uartRxBuffer[3] &lt;&lt; 8);
                    
                    if (rxIndex == length + 5) // 校验数据长度
                    {
                        CustomProtocol protocol;
                        
                        // 解析接收到的数据
                        protocol.start_byte = uartRxBuffer[0];
                        protocol.source = uartRxBuffer[1];
                        protocol.length = length;
                        protocol.data = &amp;uartRxBuffer[4];
                        protocol.checksum = uartRxBuffer[rxIndex - 2] + (uartRxBuffer[rxIndex - 1] &lt;&lt; 8);
                        protocol.end_byte[0] = uartRxBuffer[rxIndex - 6];
                        protocol.end_byte[1] = uartRxBuffer[rxIndex - 5];
                        
                        // 校验校验和和结束标识
                        if (protocol.checksum == calculateCRC(protocol.data, protocol.length) &amp;&amp;
                            protocol.end_byte[0] == 0xBB &amp;&amp; protocol.end_byte[1] == 0xCC) 
                        {                                            
                            // 判断数据类型是否为0xFF
                            if (protocol.data[0] != 0xFF)
                            {
                                // 发送确认消息
                                sendAck(0x01);

                                // 处理接收到的数据
                                processData(protocol.data, protocol.length);
                            }
                            else
                            {
                                // 数据类型为0xFF，忽略该数据
                            }

                            break;
                        } else 
                        {
                            // 数据校验失败，处理错误逻辑
                            handleReceptionError();
                            break;
                        }
                    }
                }
            }
            
            rxIndex++;
            
            if (rxIndex &gt;= UART_BUFFER_SIZE)
            {
                // 接收缓冲区已满，处理错误逻辑
                handleReceptionError();
                break;
            }
        }
    }
}


// 发送错误处理函数
void handleTransmissionError() 
{
    // 在此实现重发机制或其他错误处理逻辑
	  printf("\r\nTransmissionError !\n\r");
}

void sendAck(uint8_t source) 
{
    // 创建发送缓冲区
    uint8_t ackBuffer[UART_BUFFER_SIZE];
    uint8_t txIndex = 0;
    
    // 添加开始标识
    ackBuffer[txIndex++] = 0xAA; // 可根据需要修改为实际的开始标识
    
    // 添加数据来源
    ackBuffer[txIndex++] = source;
    
    // 添加数据长度
    ackBuffer[txIndex++] = 0x01; // 数据长度为1字节
    
    // 添加数据类型
    ackBuffer[txIndex++] = 0xFF;
    
    // 添加数据内容
    ackBuffer[txIndex++] = 0x00; // 数据内容全为0
    
    // 计算并添加校验和
    uint16_t checksum = calculateCRC(&amp;ackBuffer[4], txIndex - 4);
    ackBuffer[txIndex++] = checksum &amp; 0xFF;      // 校验和低字节
    ackBuffer[txIndex++] = (checksum &gt;&gt; 8) &amp; 0xFF; // 校验和高字节
    
    // 添加结束标识
    ackBuffer[txIndex++] = 0xBB;
    ackBuffer[txIndex++] = 0xCC;
    
    // 使用UART发送数据
    //HAL_UART_Transmit(&amp;huart3, ackBuffer, txIndex, HAL_MAX_DELAY);
		for (int i = 0; i &lt; txIndex; i++) 
		{
        printf("%02x", ackBuffer[i]);
    }
}


// 处理接收到的数据的函数
void processData(uint8_t* data, uint8_t length) 
{
    // 将数据存储到数组中，并打印出来
    uint8_t receivedData[UART_BUFFER_SIZE];
    memcpy(receivedData, data, length);
    
    for (int i = 0; i &lt; length; i++) 
	 {
        printf("%02X ", receivedData[i]);
    }
    
    printf("\n");
}

// 接收错误处理函数
void handleReceptionError() 
{
    // 在此处理接收错误逻辑
	  printf("\r\nReceptionError !\n\r");
}

// 处理ACK确认消息的函数
void handleAck() 
{
    // 处理ACK确认消息的逻辑
	  printf("\r\nACK received !\n\r");
}
/* USER CODE END 1 */
</code></pre> 
<p>发送的数据格式是对的，但是确认机制有点问题，无法正常ack确认</p> 
<pre><code class="hljs">uint8_t sendDataBuffer[] = {0x01,0x02,0x03,0x04,0x05};
uint8_t sendDataLength = sizeof(sendDataBuffer);
uint8_t sendDataSource = 0x01;  

sendData(sendDataBuffer, sendDataLength, sendDataSource);</code></pre> 
<p><img alt="" height="50" src="https://images2.imgbox.com/89/79/TMfnrhtc_o.png" width="631"></p> 
<p> 问题不晓得出在哪了</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bc2181af6414625d2067209ea2ee7b18/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Compose 为什么可以跨平台</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f520f864344902fce1aabd06402830fe/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux服务器增加虚拟交换内存</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>