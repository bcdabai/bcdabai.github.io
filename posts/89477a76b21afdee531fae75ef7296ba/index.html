<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Leetcode题解——算法思想之二分查找 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Leetcode题解——算法思想之二分查找" />
<meta property="og:description" content="1. 求开方
2. 大于给定元素的最小元素3. 有序数组的 Single Element4. 第一个错误的版本5. 旋转数组的最小数字6. 查找区间 正常实现
Input : [1,2,3,4,5] key : 3 return the index : 2 public int binarySearch(int[] nums, int key) { int l = 0, h = nums.length - 1; while (l &lt;= h) { int m = l &#43; (h - l) / 2; if (nums[m] == key) { return m; } else if (nums[m] &gt; key) { h = m - 1; } else { l = m &#43; 1; } } return -1; } 时间复杂度" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/89477a76b21afdee531fae75ef7296ba/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-06-12T13:31:00+08:00" />
<meta property="article:modified_time" content="2019-06-12T13:31:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Leetcode题解——算法思想之二分查找</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <p><a href="http://www.cnblogs.com/#1-%E6%B1%82%E5%BC%80%E6%96%B9" rel="nofollow">1. 求开方</a></p> 
 <ul><li><a href="http://www.cnblogs.com/#2-%E5%A4%A7%E4%BA%8E%E7%BB%99%E5%AE%9A%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E5%B0%8F%E5%85%83%E7%B4%A0" rel="nofollow">2. 大于给定元素的最小元素</a></li><li><a href="http://www.cnblogs.com/#3-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84-single-element" rel="nofollow">3. 有序数组的 Single Element</a></li><li><a href="http://www.cnblogs.com/#4-%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC" rel="nofollow">4. 第一个错误的版本</a></li><li><a href="http://www.cnblogs.com/#5-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97" rel="nofollow">5. 旋转数组的最小数字</a></li><li><a href="http://www.cnblogs.com/#6-%E6%9F%A5%E6%89%BE%E5%8C%BA%E9%97%B4" rel="nofollow">6. 查找区间</a></li></ul> 
 <p><strong>正常实现</strong></p> 
 <pre><code>Input : [1,2,3,4,5]
key : 3
return the index : 2
</code></pre> 
 <div class="highlight highlight-source-java"> 
  <pre><span class="pl-k">public <span class="pl-k">int binarySearch(<span class="pl-k">int[] nums, <span class="pl-k">int key) {
    <span class="pl-k">int l <span class="pl-k">= <span class="pl-c1">0, h <span class="pl-k">= nums<span class="pl-k">.length <span class="pl-k">- <span class="pl-c1">1; <span class="pl-k">while (l <span class="pl-k">&lt;= h) { <span class="pl-k">int m <span class="pl-k">= l <span class="pl-k">+ (h <span class="pl-k">- l) <span class="pl-k">/ <span class="pl-c1">2; <span class="pl-k">if (nums[m] <span class="pl-k">== key) { <span class="pl-k">return m; } <span class="pl-k">else <span class="pl-k">if (nums[m] <span class="pl-k">&gt; key) { h <span class="pl-k">= m <span class="pl-k">- <span class="pl-c1">1; } <span class="pl-k">else { l <span class="pl-k">= m <span class="pl-k">+ <span class="pl-c1">1; } } <span class="pl-k">return <span class="pl-k">-<span class="pl-c1">1; }</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre> 
 </div> 
 <p><strong>时间复杂度</strong></p> 
 <p>二分查找也称为折半查找，每次都能将查找区间减半，这种折半特性的算法时间复杂度为 O(logN)。</p> 
 <p><strong>m 计算</strong></p> 
 <p>有两种计算中值 m 的方式：</p> 
 <ul><li>m = (l + h) / 2</li><li>m = l + (h - l) / 2</li></ul> 
 <p>l + h 可能出现加法溢出，也就是说加法的结果大于整型能够表示的范围。但是 l 和 h 都为正数，因此 h - l 不会出现加法溢出问题。所以，最好使用第二种计算法方法。</p> 
 <p><strong>未成功查找的返回值</strong></p> 
 <p>循环退出时如果仍然没有查找到 key，那么表示查找失败。可以有两种返回值：</p> 
 <ul><li>-1：以一个错误码表示没有查找到 key</li><li>l：将 key 插入到 nums 中的正确位置</li></ul> 
 <p><strong>变种</strong></p> 
 <p>二分查找可以有很多变种，变种实现要注意边界值的判断。例如在一个有重复元素的数组中查找 key 的最左位置的实现如下：</p> 
 <div class="highlight highlight-source-java"> 
  <pre><span class="pl-k">public <span class="pl-k">int binarySearch(<span class="pl-k">int[] nums, <span class="pl-k">int key) {
    <span class="pl-k">int l <span class="pl-k">= <span class="pl-c1">0, h <span class="pl-k">= nums<span class="pl-k">.length <span class="pl-k">- <span class="pl-c1">1; <span class="pl-k">while (l <span class="pl-k">&lt; h) { <span class="pl-k">int m <span class="pl-k">= l <span class="pl-k">+ (h <span class="pl-k">- l) <span class="pl-k">/ <span class="pl-c1">2; <span class="pl-k">if (nums[m] <span class="pl-k">&gt;= key) { h <span class="pl-k">= m; } <span class="pl-k">else { l <span class="pl-k">= m <span class="pl-k">+ <span class="pl-c1">1; } } <span class="pl-k">return l; }</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre> 
 </div> 
 <p>该实现和正常实现有以下不同：</p> 
 <ul><li>h 的赋值表达式为 h = m</li><li>循环条件为 l &lt; h</li><li>最后返回 l 而不是 -1</li></ul> 
 <p>在 nums[m] &gt;= key 的情况下，可以推导出最左 key 位于 [l, m] 区间中，这是一个闭区间。h 的赋值表达式为 h = m，因为 m 位置也可能是解。</p> 
 <p>在 h 的赋值表达式为 h = m 的情况下，如果循环条件为 l &lt;= h，那么会出现循环无法退出的情况，因此循环条件只能是 l &lt; h。以下演示了循环条件为 l &lt;= h 时循环无法退出的情况：</p> 
 <pre><code>nums = {0, 1, 2}, key = 1
l   m   h
0   1   2  nums[m] &gt;= key
0   0   1  nums[m] &lt; key
1   1   1  nums[m] &gt;= key
1   1   1  nums[m] &gt;= key
...
</code></pre> 
 <p>当循环体退出时，不表示没有查找到 key，因此最后返回的结果不应该为 -1。为了验证有没有查找到，需要在调用端判断一下返回位置上的值和 key 是否相等。</p> 
 <h2><a id="user-content-1-求开方" class="anchor" href="http://www.cnblogs.com/#1-%E6%B1%82%E5%BC%80%E6%96%B9" rel="nofollow"></a>1. 求开方</h2> 
 <p><a href="https://leetcode.com/problems/sqrtx/description/" rel="nofollow">69. Sqrt(x) (Easy)</a></p> 
 <div class="highlight highlight-text-html-basic"> 
  <pre>Input: 4
Output: 2

Input: 8
Output: 2
Explanation: The square root of 8 is 2.82842..., and since we want to return an integer, the decimal part will be truncated.</pre> 
 </div> 
 <p>一个数 x 的开方 sqrt 一定在 0 ~ x 之间，并且满足 sqrt == x / sqrt。可以利用二分查找在 0 ~ x 之间查找 sqrt。</p> 
 <p>对于 x = 8，它的开方是 2.82842...，最后应该返回 2 而不是 3。在循环条件为 l &lt;= h 并且循环退出时，h 总是比 l 小 1，也就是说 h = 2，l = 3，因此最后的返回值应该为 h 而不是 l。</p> 
 <div class="highlight highlight-source-java"> 
  <pre><span class="pl-k">public <span class="pl-k">int mySqrt(<span class="pl-k">int x) {
    <span class="pl-k">if (x <span class="pl-k">&lt;= <span class="pl-c1">1) { <span class="pl-k">return x; } <span class="pl-k">int l <span class="pl-k">= <span class="pl-c1">1, h <span class="pl-k">= x; <span class="pl-k">while (l <span class="pl-k">&lt;= h) { <span class="pl-k">int mid <span class="pl-k">= l <span class="pl-k">+ (h <span class="pl-k">- l) <span class="pl-k">/ <span class="pl-c1">2; <span class="pl-k">int sqrt <span class="pl-k">= x <span class="pl-k">/ mid; <span class="pl-k">if (sqrt <span class="pl-k">== mid) { <span class="pl-k">return mid; } <span class="pl-k">else <span class="pl-k">if (mid <span class="pl-k">&gt; sqrt) { h <span class="pl-k">= mid <span class="pl-k">- <span class="pl-c1">1; } <span class="pl-k">else { l <span class="pl-k">= mid <span class="pl-k">+ <span class="pl-c1">1; } } <span class="pl-k">return h; }</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre> 
 </div> 
 <h2><a id="user-content-2-大于给定元素的最小元素" class="anchor" href="http://www.cnblogs.com/#2-%E5%A4%A7%E4%BA%8E%E7%BB%99%E5%AE%9A%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E5%B0%8F%E5%85%83%E7%B4%A0" rel="nofollow"></a>2. 大于给定元素的最小元素</h2> 
 <p><a href="https://leetcode.com/problems/find-smallest-letter-greater-than-target/description/" rel="nofollow">744. Find Smallest Letter Greater Than Target (Easy)</a></p> 
 <div class="highlight highlight-text-html-basic"> 
  <pre>Input:
letters = ["c", "f", "j"]
target = "d"
Output: "f"

Input:
letters = ["c", "f", "j"]
target = "k"
Output: "c"</pre> 
 </div> 
 <p>题目描述：给定一个有序的字符数组 letters 和一个字符 target，要求找出 letters 中大于 target 的最小字符，如果找不到就返回第 1 个字符。</p> 
 <div class="highlight highlight-source-java"> 
  <pre><span class="pl-k">public <span class="pl-k">char nextGreatestLetter(<span class="pl-k">char[] letters, <span class="pl-k">char target) {
    <span class="pl-k">int n <span class="pl-k">= letters<span class="pl-k">.length; <span class="pl-k">int l <span class="pl-k">= <span class="pl-c1">0, h <span class="pl-k">= n <span class="pl-k">- <span class="pl-c1">1; <span class="pl-k">while (l <span class="pl-k">&lt;= h) { <span class="pl-k">int m <span class="pl-k">= l <span class="pl-k">+ (h <span class="pl-k">- l) <span class="pl-k">/ <span class="pl-c1">2; <span class="pl-k">if (letters[m] <span class="pl-k">&lt;= target) { l <span class="pl-k">= m <span class="pl-k">+ <span class="pl-c1">1; } <span class="pl-k">else { h <span class="pl-k">= m <span class="pl-k">- <span class="pl-c1">1; } } <span class="pl-k">return l <span class="pl-k">&lt; n <span class="pl-k">? letters[l] <span class="pl-k">: letters[<span class="pl-c1">0]; }</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre> 
 </div> 
 <h2><a id="user-content-3-有序数组的-single-element" class="anchor" href="http://www.cnblogs.com/#3-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84-single-element" rel="nofollow"></a>3. 有序数组的 Single Element</h2> 
 <p><a href="https://leetcode.com/problems/single-element-in-a-sorted-array/description/" rel="nofollow">540. Single Element in a Sorted Array (Medium)</a></p> 
 <div class="highlight highlight-text-html-basic"> 
  <pre>Input: [1, 1, 2, 3, 3, 4, 4, 8, 8]
Output: 2</pre> 
 </div> 
 <p>题目描述：一个有序数组只有一个数不出现两次，找出这个数。</p> 
 <p>要求以 O(logN) 时间复杂度进行求解，因此不能遍历数组并进行异或操作来求解，这么做的时间复杂度为 O(N)。</p> 
 <p>令 index 为 Single Element 在数组中的位置。在 index 之后，数组中原来存在的成对状态被改变。如果 m 为偶数，并且 m + 1 &lt; index，那么 nums[m] == nums[m + 1]；m + 1 &gt;= index，那么 nums[m] != nums[m + 1]。</p> 
 <p>从上面的规律可以知道，如果 nums[m] == nums[m + 1]，那么 index 所在的数组位置为 [m + 2, h]，此时令 l = m + 2；如果 nums[m] != nums[m + 1]，那么 index 所在的数组位置为 [l, m]，此时令 h = m。</p> 
 <p>因为 h 的赋值表达式为 h = m，那么循环条件也就只能使用 l &lt; h 这种形式。</p> 
 <div class="highlight highlight-source-java"> 
  <pre><span class="pl-k">public <span class="pl-k">int singleNonDuplicate(<span class="pl-k">int[] nums) {
    <span class="pl-k">int l <span class="pl-k">= <span class="pl-c1">0, h <span class="pl-k">= nums<span class="pl-k">.length <span class="pl-k">- <span class="pl-c1">1; <span class="pl-k">while (l <span class="pl-k">&lt; h) { <span class="pl-k">int m <span class="pl-k">= l <span class="pl-k">+ (h <span class="pl-k">- l) <span class="pl-k">/ <span class="pl-c1">2; <span class="pl-k">if (m <span class="pl-k">% <span class="pl-c1">2 <span class="pl-k">== <span class="pl-c1">1) { m<span class="pl-k">--; <span class="pl-c"><span class="pl-c">// 保证 l/h/m 都在偶数位，使得查找区间大小一直都是奇数 } <span class="pl-k">if (nums[m] <span class="pl-k">== nums[m <span class="pl-k">+ <span class="pl-c1">1]) { l <span class="pl-k">= m <span class="pl-k">+ <span class="pl-c1">2; } <span class="pl-k">else { h <span class="pl-k">= m; } } <span class="pl-k">return nums[l]; }</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre> 
 </div> 
 <h2><a id="user-content-4-第一个错误的版本" class="anchor" href="http://www.cnblogs.com/#4-%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC" rel="nofollow"></a>4. 第一个错误的版本</h2> 
 <p><a href="https://leetcode.com/problems/first-bad-version/description/" rel="nofollow">278. First Bad Version (Easy)</a></p> 
 <p>题目描述：给定一个元素 n 代表有 [1, 2, ..., n] 版本，在第 x 位置开始出现错误版本，导致后面的版本都错误。可以调用 isBadVersion(int x) 知道某个版本是否错误，要求找到第一个错误的版本。</p> 
 <p>如果第 m 个版本出错，则表示第一个错误的版本在 [l, m] 之间，令 h = m；否则第一个错误的版本在 [m + 1, h] 之间，令 l = m + 1。</p> 
 <p>因为 h 的赋值表达式为 h = m，因此循环条件为 l &lt; h。</p> 
 <div class="highlight highlight-source-java"> 
  <pre><span class="pl-k">public <span class="pl-k">int firstBadVersion(<span class="pl-k">int n) {
    <span class="pl-k">int l <span class="pl-k">= <span class="pl-c1">1, h <span class="pl-k">= n; <span class="pl-k">while (l <span class="pl-k">&lt; h) { <span class="pl-k">int mid <span class="pl-k">= l <span class="pl-k">+ (h <span class="pl-k">- l) <span class="pl-k">/ <span class="pl-c1">2; <span class="pl-k">if (isBadVersion(mid)) { h <span class="pl-k">= mid; } <span class="pl-k">else { l <span class="pl-k">= mid <span class="pl-k">+ <span class="pl-c1">1; } } <span class="pl-k">return l; }</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre> 
 </div> 
 <h2><a id="user-content-5-旋转数组的最小数字" class="anchor" href="http://www.cnblogs.com/#5-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97" rel="nofollow"></a>5. 旋转数组的最小数字</h2> 
 <p><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/" rel="nofollow">153. Find Minimum in Rotated Sorted Array (Medium)</a></p> 
 <div class="highlight highlight-text-html-basic"> 
  <pre>Input: [3,4,5,1,2],
Output: 1</pre> 
 </div> 
 <div class="highlight highlight-source-java"> 
  <pre><span class="pl-k">public <span class="pl-k">int findMin(<span class="pl-k">int[] nums) {
    <span class="pl-k">int l <span class="pl-k">= <span class="pl-c1">0, h <span class="pl-k">= nums<span class="pl-k">.length <span class="pl-k">- <span class="pl-c1">1; <span class="pl-k">while (l <span class="pl-k">&lt; h) { <span class="pl-k">int m <span class="pl-k">= l <span class="pl-k">+ (h <span class="pl-k">- l) <span class="pl-k">/ <span class="pl-c1">2; <span class="pl-k">if (nums[m] <span class="pl-k">&lt;= nums[h]) { h <span class="pl-k">= m; } <span class="pl-k">else { l <span class="pl-k">= m <span class="pl-k">+ <span class="pl-c1">1; } } <span class="pl-k">return nums[l]; }</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre> 
 </div> 
 <h2><a id="user-content-6-查找区间" class="anchor" href="http://www.cnblogs.com/#6-%E6%9F%A5%E6%89%BE%E5%8C%BA%E9%97%B4" rel="nofollow"></a>6. 查找区间</h2> 
 <p><a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/" rel="nofollow">34. Find First and Last Position of Element in Sorted Array</a></p> 
 <div class="highlight highlight-text-html-basic"> 
  <pre>Input: nums = [5,7,7,8,8,10], target = 8
Output: [3,4]

Input: nums = [5,7,7,8,8,10], target = 6
Output: [-1,-1]</pre> 
 </div> 
 <div class="highlight highlight-source-java"> 
  <pre><span class="pl-k">public <span class="pl-k">int[] searchRange(<span class="pl-k">int[] nums, <span class="pl-k">int target) {
    <span class="pl-k">int first <span class="pl-k">= binarySearch(nums, target); <span class="pl-k">int last <span class="pl-k">= binarySearch(nums, target <span class="pl-k">+ <span class="pl-c1">1) <span class="pl-k">- <span class="pl-c1">1; <span class="pl-k">if (first <span class="pl-k">== nums<span class="pl-k">.length <span class="pl-k">|| nums[first] <span class="pl-k">!= target) { <span class="pl-k">return <span class="pl-k">new <span class="pl-smi">int[]{<!-- --><span class="pl-k">-<span class="pl-c1">1, <span class="pl-k">-<span class="pl-c1">1}; } <span class="pl-k">else { <span class="pl-k">return <span class="pl-k">new <span class="pl-smi">int[]{first, <span class="pl-smi">Math<span class="pl-k">.max(first, last)}; } } <span class="pl-k">private <span class="pl-k">int binarySearch(<span class="pl-k">int[] nums, <span class="pl-k">int target) { <span class="pl-k">int l <span class="pl-k">= <span class="pl-c1">0, h <span class="pl-k">= nums<span class="pl-k">.length; <span class="pl-c"><span class="pl-c">// 注意 h 的初始值 <span class="pl-k">while (l <span class="pl-k">&lt; h) { <span class="pl-k">int m <span class="pl-k">= l <span class="pl-k">+ (h <span class="pl-k">- l) <span class="pl-k">/ <span class="pl-c1">2; <span class="pl-k">if (nums[m] <span class="pl-k">&gt;= target) { h <span class="pl-k">= m; } <span class="pl-k">else { l <span class="pl-k">= m <span class="pl-k">+ <span class="pl-c1">1; } } <span class="pl-k">return l; }</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre> 
 </div> 
</div> 
<p>转载于:https://www.cnblogs.com/daimasanjiaomao/p/11009078.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a3bb6080f02c62c6bc422e9bf1e5b608/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Windows堆内存调试利器Gflags(pageheap)及高级用法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/70892252e9ed368d6d38f1f7fb319fa3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">zabbix 4.0.1安装、图表注释丢失，坐标轴没有单位的解决办法和中文乱码的解决方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>