<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spring入门(万字详细附代码讲解) - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Spring入门(万字详细附代码讲解)" />
<meta property="og:description" content="1.Spring介绍 Spring其实就是一种开源框架,指的是Spring Framework,具有良好的生态,这也是Spring经久不衰的原因
用一句话概括,Spring就是一个集成了众多工具和方法的IOC容器
2.IOC容器 什么是IOC容器呢?
IOC的中文翻译过来就是控制反转,IOC容器其实就是控制反转容器
那什么是控制反转呢?
这个词听起来好像很高大上,其实通俗来理解就是,本来我们写java类的时候,创建对象,是通过自己去new的,但是当我们控制反转之后,我们就把对象的创建和一系列读取等操作交给了Spring,Spring就帮我们完成这些操作 ,这样我们需要做的操作就两个,1.把对象存到Spring中去,2.从Spring中去取对象
3.控制反转(IOC)的好处 我们以一部手机为例,就简易的手机,假如我们需要的有CPU,线路板,电阻来组成
这样我们传统的代码开发,就要先new一个手机,但是我们想要完成一部手机,要有一个CPU,所以再调用CPU类组装CPU,但是CPU想要组装,就必须要先组装线路板,但是线路板想要组装,就必须依靠电阻,这样我们的程序就非常耦合,我们通过一张图,更加直观的来理解
可以看到,我们想要造一部手机,耦合度非常的高,如果我们的电阻这一栏,我们加一个电容属性,那么,我们上面的线路板中也需要把调用电阻的那一块进行修改,从而导致我们整个的代码都需要进行一个更新,这个时候,IOC的优势便体现出来了
我们只需要进行一个改进,就可以大大降低耦合度,我们可以在main函数中,将每一个对象都进行创建,然后我们可以在每一个类中,创建一个属性,用来接收下一级的对象,这样在我们进行对底层修改的时候,只需要对修改的代码进行修改和main函数中的参数进行修改即可,大大降低了带啊吗的耦合,我们也用一个图来理解
可以明显的看出来IOC容器的优势 4.DI DI是一种设计模式,就是依赖注入,在我们想要运行A时,A需要依赖数据库来完成,这时候我们不会像传统开发一样,去搭建DBUtile或者去newDBUtile的对象,而是将依赖关系配置到xml文件中去,由Spring去管理,这样就可以动态的去依赖关系注入到对象之中,从而实现解耦合
2.Spring使用 这里就不去教大家如何创建Spring项目了,我们如何使用Spring呢?,需要在xml文件中去添加Spring的依赖即可
这里我们具体讲一下如何存取对象
1.较为古老的用法 1.1添加启动类 我们需要在java包中进行创建一个启动类,只要包含main方法即可,类似这样
public class App { public static void main(String[] args) { } } 1.2创建Bean 什么是Bean呢?
Bean对象就是java中的普通对象,这里其实本质是一个类的写法
类似下面
public class User { public String Hi(String s){ return &#34;Hi &#34; &#43; s; } } 1.3存储Bean 创建好Bean之后,我们需要将其注册到Spring中去
这里我们使用最原始的方法
首先创建一个xml文件,在resource目录下,如下
这里面先将Spring的固定文件放进去,这个是Spring固定的配置文件
&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt; &lt;beans xmlns=&#34;http://www.springframework.org/schema/beans&#34; xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34; xsi:schemaLocation=&#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&#34;&gt; &lt;beans&gt; &lt;bean id = &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/c0a9ae9da0299cdf59945342f69e5efa/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-08T18:06:52+08:00" />
<meta property="article:modified_time" content="2023-04-08T18:06:52+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spring入门(万字详细附代码讲解)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2></h2> 
<h3 id="1.Spring%E4%BB%8B%E7%BB%8D">1.Spring介绍</h3> 
<p>Spring其实就是一种开源框架,指的是Spring Framework,具有良好的生态,这也是Spring经久不衰的原因</p> 
<p>用一句话概括,Spring就是一个集成了众多工具和方法的IOC容器</p> 
<p></p> 
<h3 id="2.IOC%E5%AE%B9%E5%99%A8">2.IOC容器</h3> 
<p><span style="background-color:#ffd900;">什么是IOC容器呢?</span></p> 
<p>IOC的中文翻译过来就是控制反转,IOC容器其实就是控制反转容器</p> 
<p><span style="background-color:#ffd900;">那什么是控制反转呢?</span></p> 
<p>这个词听起来好像很高大上,其实通俗来理解就是,本来我们写java类的时候,创建对象,是通过自己去new的,但是当我们控制反转之后,我们就把对象的创建和一系列读取等操作交给了Spring,Spring就帮我们完成这些操作 ,这样我们需要做的操作就两个,1.把对象存到Spring中去,2.从Spring中去取对象</p> 
<h3 id="3.%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC(IOC)%E7%9A%84%E5%A5%BD%E5%A4%84">3.控制反转(IOC)的好处</h3> 
<p>我们以一部手机为例,就简易的手机,假如我们需要的有CPU,线路板,电阻来组成</p> 
<p>这样我们传统的代码开发,就要先new一个手机,但是我们想要完成一部手机,要有一个CPU,所以再调用CPU类组装CPU,但是CPU想要组装,就必须要先组装线路板,但是线路板想要组装,就必须依靠电阻,这样我们的程序就非常耦合,我们通过一张图,更加直观的来理解</p> 
<p><img alt="" height="779" src="https://images2.imgbox.com/e6/ae/3ltddda4_o.png" width="443"></p> 
<p>可以看到,我们想要造一部手机,耦合度非常的高,如果我们的电阻这一栏,我们加一个电容属性,那么,我们上面的线路板中也需要把调用电阻的那一块进行修改,从而导致我们整个的代码都需要进行一个更新,这个时候,IOC的优势便体现出来了</p> 
<p>我们只需要进行一个改进,就可以大大降低耦合度,我们可以在main函数中,将每一个对象都进行创建,然后我们可以在每一个类中,创建一个属性,用来接收下一级的对象,这样在我们进行对底层修改的时候,只需要对修改的代码进行修改和main函数中的参数进行修改即可,大大降低了带啊吗的耦合,我们也用一个图来理解</p> 
<p> <img alt="" height="816" src="https://images2.imgbox.com/5e/f7/ka8ARNWl_o.png" width="411"></p> 
<p>可以明显的看出来IOC容器的优势 </p> 
<h3 id="4.DI">4.DI</h3> 
<p>DI是一种设计模式,就是依赖注入,在我们想要运行A时,A需要依赖数据库来完成,这时候我们不会像传统开发一样,去搭建DBUtile或者去newDBUtile的对象,而是将依赖关系配置到xml文件中去,由Spring去管理,这样就可以动态的去依赖关系注入到对象之中,从而实现解耦合</p> 
<h2 id="2.Spring%E4%BD%BF%E7%94%A8">2.Spring使用</h2> 
<p>这里就不去教大家如何创建Spring项目了,我们如何使用Spring呢?,需要在xml文件中去添加Spring的依赖即可</p> 
<p>这里我们具体讲一下如何存取对象</p> 
<h3 id="1.%E8%BE%83%E4%B8%BA%E5%8F%A4%E8%80%81%E7%9A%84%E7%94%A8%E6%B3%95">1.较为古老的用法</h3> 
<h4 id="1.1%E6%B7%BB%E5%8A%A0%E5%90%AF%E5%8A%A8%E7%B1%BB">1.1添加启动类</h4> 
<p>我们需要在java包中进行创建一个启动类,只要包含main方法即可,类似这样</p> 
<pre><code class="language-java">public class App {
    public static void main(String[] args) {
        
    }
}
</code></pre> 
<h4 id="1.2%E5%88%9B%E5%BB%BABean">1.2创建Bean</h4> 
<p>什么是Bean呢?</p> 
<p>Bean对象就是java中的普通对象,这里其实本质是一个类的写法</p> 
<p>类似下面</p> 
<pre><code class="language-java">public class User {
    public String Hi(String s){
        return "Hi " + s;
    }
}
</code></pre> 
<h4 id="1.3%E5%AD%98%E5%82%A8Bean">1.3存储Bean</h4> 
<p>创建好Bean之后,我们需要将其注册到Spring中去</p> 
<p>这里我们使用最原始的方法</p> 
<p>首先创建一个xml文件,在resource目录下,如下</p> 
<p><img alt="" height="316" src="https://images2.imgbox.com/bc/30/dFFV9lSF_o.png" width="469"></p> 
<p></p> 
<p>这里面先将Spring的固定文件放进去,这个是Spring固定的配置文件</p> 
<pre><code class="language-XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;
    &lt;beans&gt;
        &lt;bean id = "user" class="com.ganzhi.User"&gt;&lt;/bean&gt;
    &lt;/beans&gt;
&lt;/beans&gt;
</code></pre> 
<p> 然后我们只需要将User对象注入到Spring中即可</p> 
<h4 id="1.4%E8%8E%B7%E5%8F%96Bean">1.4获取Bean</h4> 
<p>我们创建Bean的目的就是为了拿来用,那我们要如何取到Bean中的属性呢</p> 
<p>首先我们需要得到Spring的上下文对象</p> 
<p>因为我们的Bean是交给Spring来管理的,所以需要用一个Spring 的上下文来进行操作,可以用如下的代码来实现</p> 
<pre><code class="language-java">public class App {
    public static void main(String[] args) {
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext("Spring-config.xml");
    }
}
</code></pre> 
<p>不仅如此,我们还可以利用Bean Factory来作为Spring的上下文,代码如下</p> 
<pre><code class="language-java">public class App {
    public static void main(String[] args) {
//        ApplicationContext applicationContext = new ClassPathXmlApplicationContext("Spring-config.xml");
        BeanFactory beanFactory = new XmlBeanFactory(new ClassPathResource("Spring-config.xml"));
    }
}
</code></pre> 
<p>这里BeanFactory其实和上面的ApplicationContext效果是一样的,后者是前者的子类</p> 
<h3 id="%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%3A"><span style="background-color:#ffd900;">常见面试题:</span></h3> 
<p>BeanFactory 和 ApplicationContext的区别</p> 
<p>1.二者都是Spring的顶级容器,并且ApplicationContext是BeanFactory的子类,他除了继承了BeanFactory的所有功能外,还增加了国际化支持,资源访问支持,事件传播等方面的支持</p> 
<p>2.从性能方面,ApplicationContext属于饿汉加载(也就是一次性加载并且初始化所有的Bean对象)而BeanFactory是懒汉加载(用到哪个Bean对象就加载哪个),所以我们可以看出来,BeanFactory比ApplicationContext更加轻量</p> 
<p>拓展:这里还有个ClassPathXmlApplicationContext类,他是Application的子类</p> 
<h4 id="1.5%E8%8E%B7%E5%8F%96%E6%8C%87%E5%AE%9A%E7%9A%84Bean%E5%AF%B9%E8%B1%A1">1.5获取指定的Bean对象</h4> 
<p>这里可以通过这种方法来获取Bean对象</p> 
<pre><code class="language-java">public class App {
    public static void main(String[] args) {
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext("Spring-config.xml");
//        BeanFactory beanFactory = new XmlBeanFactory(new ClassPathResource("Spring-config.xml"));

        User user = (User) applicationContext.getBean("user");
        System.out.println(user.Hi("张三"));
    }
}</code></pre> 
<p><span style="color:#fe2c24;">注意:这里getBean中的"user"必须和xml中的Beanid保存一致</span></p> 
<p></p> 
<p><img alt="" height="339" src="https://images2.imgbox.com/bd/6a/TRPOJbTW_o.png" width="1200"></p> 
<p> <img alt="" height="287" src="https://images2.imgbox.com/54/5d/QpY06z8I_o.png" width="1107"></p> 
<p>了解getBean()的重载方法</p> 
<pre><code class="language-java">public class App {
    public static void main(String[] args) {
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext("Spring-config.xml");
//        BeanFactory beanFactory = new XmlBeanFactory(new ClassPathResource("Spring-config.xml"));

        User user = (User) applicationContext.getBean(User.class);
        System.out.println(user.Hi("张三"));
    }
}
</code></pre> 
<p> 这里也可以直接用类名来获取</p> 
<p>或者id和类名一起使用</p> 
<pre><code class="language-java">package com.ganzhi;

import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.xml.XmlBeanFactory;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.core.io.ClassPathResource;

/**
 * Created with IntelliJ IDEA.
 * Description:
 * User: 
 * Date: 2023-04-05
 * Time: 17:55
 */
public class App {
    public static void main(String[] args) {
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext("Spring-config.xml");
//        BeanFactory beanFactory = new XmlBeanFactory(new ClassPathResource("Spring-config.xml"));

        User user = (User) applicationContext.getBean("user",User.class);
        System.out.println(user.Hi("张三"));
    }
}
</code></pre> 
<p>这里用一张图,带大家了解一下具体的流程</p> 
<p><img alt="" height="705" src="https://images2.imgbox.com/be/87/xNMyawie_o.png" width="844"></p> 
<h3 id="2.%E7%8E%B0%E5%9C%A8%E7%9A%84%20%E6%96%B9%E6%B3%95">2.现在的 方法</h3> 
<h4 id="1.%E9%85%8D%E7%BD%AE%E6%89%AB%E6%8F%8F%E8%B7%AF%E5%BE%84">1.配置扫描路径</h4> 
<p>这里我们需要告诉Spring去哪里扫描类,并存储,所以是非常重要的步骤</p> 
<p>这里我们附上xml</p> 
<pre><code class="language-XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:content="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd"&gt;
    &lt;content:component-scan base-package="com.ganzhi"&gt;&lt;/content:component-scan&gt;
&lt;/beans&gt;</code></pre> 
<p> 其中的content一行就是我们要扫描的路径</p> 
<h4 id="2.%E6%B7%BB%E5%8A%A0%E7%B1%BB%E6%B3%A8%E8%A7%A3">2.添加类注解</h4> 
<h4 id="2.1%40Controller(%E6%8E%A7%E5%88%B6%E5%99%A8%E5%AD%98%E5%82%A8)">2.1@Controller(控制器存储)</h4> 
<p>我们使用可以用@Controller来让对象存入到Spring,代码示例如下</p> 
<pre><code class="language-java">@Controller
public class User {
    public String Hi(String s){
        return "Hi " + s;
    }
}
</code></pre> 
<p>这样我们就可以扫描到这个对象了,利用上述的App类中的main,依然可以执行</p> 
<p>代码再次附上</p> 
<pre><code class="language-java">package com.ganzhi;

import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.xml.XmlBeanFactory;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.core.io.ClassPathResource;

/**
 * Created with IntelliJ IDEA.
 * Description:
 * User: 
 * Date: 2023-04-05
 * Time: 17:55
 */
public class App {
    public static void main(String[] args) {
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext("Spring-config.xml");
//        BeanFactory beanFactory = new XmlBeanFactory(new ClassPathResource("Spring-config.xml"));

        User user = (User) applicationContext.getBean("user");
        System.out.println(user.Hi("张三"));
    }
}
</code></pre> 
<h4 id="2.2.%40Service(%E6%9C%8D%E5%8A%A1%E5%AD%98%E5%82%A8)">2.2.@Service(服务存储)</h4> 
<p>代码如下</p> 
<pre><code class="language-java">@Service
public class User {
    public String Hi(String s){
        return "Hi " + s;
    }
}</code></pre> 
<h4 id="2.3.%40Repository%EF%BC%88%E4%BB%93%E5%BA%93%E5%AD%98%E5%82%A8%EF%BC%89">2.3.@Repository（仓库存储）</h4> 
<p>代码如下</p> 
<pre><code class="language-java">@Repository
public class User {
    public String Hi(String s){
        return "Hi " + s;
    }
}
</code></pre> 
<p>其他两个是@Component(组件存储) 和@Configuration(配置存储)使用方法都是和上面一样得到</p> 
<h4 id="4.%E7%B1%BB%E6%B3%A8%E8%A7%A3%E7%B1%BB%E5%9E%8B%E5%A4%9A%E7%9A%84%E5%8E%9F%E5%9B%A0">4.类注解类型多的原因</h4> 
<p>既然我们的类注解好像功能都是一样的,那为什么我们还要分那么多类型呢?</p> 
<p>其实还是为了区分不同注解的用途,但是都能用,这里就显示出我们Spring的宗旨了(约定大于配置)</p> 
<p>@Controller是表示的是业务逻辑层,用于检查参数的有效性</p> 
<p>@Service是服务层,调用持久化类实现的一些功能</p> 
<p>@Repository是持久层的,也就是持久存储数据的,直接和数据库进行交互</p> 
<p>@Configuration是配置层的,用于配置当前项目的一些信息</p> 
<p>@Component是归属于公共工具类</p> 
<p>不同的注解,调用流程是不同的,是Controller-&gt;Service-&gt;Repository</p> 
<p>而Component是他们四个的父类</p> 
<h4 id="5.Bean%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99">5.Bean的命名规则</h4> 
<h4 id="5.51.%E7%B1%BB%E5%90%8D%E7%9A%84%E9%A6%96%E5%AD%97%E6%AF%8D%E5%A4%A7%E5%86%99%2C%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%AD%97%E6%AF%8D%E5%B0%8F%E5%86%99">5.51.类名的首字母大写,第二个字母小写</h4> 
<p>这种就是我们一般类的命名规则,这里我们直接小写首字母即可完成读取</p> 
<p><img alt="" height="335" src="https://images2.imgbox.com/44/8b/CMpwO9jk_o.png" width="1200"></p> 
<p>这种也是我们最常见的</p> 
<h4 id="5.2.%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%AD%97%E6%AF%8D%E9%83%BD%E6%98%AF%E5%A4%A7%E5%86%99">5.2.第一个和第二个字母都是大写</h4> 
<p>这里需要用原类名来读取</p> 
<h4 id="%E2%80%8B%E7%BC%96%E8%BE%91%C2%A05.3.%E6%BA%90%E7%A0%81%E6%A6%82%E8%AF%BB"><img alt="" height="399" src="https://images2.imgbox.com/3d/ec/r4Isqggh_o.png" width="1200"> 5.3.源码概读</h4> 
<p>这里我们可以直接去源码查找命名规则</p> 
<p>这里我们直接唤醒idea的搜索,去搜索beanName,可以找到下面这个类</p> 
<p><img alt="" height="71" src="https://images2.imgbox.com/15/17/v0pn3pxA_o.png" width="824"></p> 
<p> 然后直接点进去,找到下面的方法</p> 
<p><img alt="" height="187" src="https://images2.imgbox.com/a6/0a/TXIzAcWt_o.png" width="883"></p> 
<p> 很明显,这里返回值里面调用的方法就是我们想要找的命名规则</p> 
<p>之间按住ctrl点击这个方法,去进行查看,就会得到下面的方法</p> 
<p><img alt="" height="358" src="https://images2.imgbox.com/1f/ed/W9khn3Lz_o.png" width="801"> 从这个方法我们</p> 
<p>可以看到,如果我们传入的名字是null或者长度为0,他会直接返回,如果不是,那下面第一个if语句的语义就是,如果第一个字母和第二个字母都是大写的话,就直接返回名字,如果不是,则走下面的,也就是其他情况,那么我们的做法就是第一个字母小写</p> 
<p>从这里也可以推导出,如果第一个字母小写,那么我们获取类的时候也需要第一个字母小写,也就是不需要更改</p> 
<h4 id="6.%E6%96%B9%E6%B3%95%E6%B3%A8%E8%A7%A3%40Bean">6.方法注解@Bean</h4> 
<p>方法注解就是放到某些方法上面的注解,但是需要注意,方法注解要配合类注解一起使用才有效</p> 
<p>而且Bean注解有多种用法,这是第一种,也是最简单的一种</p> 
<p>类似下面 </p> 
<h4 id="6.1%E6%9C%89%E4%B8%80%E4%B8%AAUser%E7%B1%BB%2C%E9%87%8C%E9%9D%A2%E5%AD%98%E6%94%BEUser%E5%AF%B9%E8%B1%A1">6.1Bean常规的使用</h4> 
<p>有一个User类,里面存放User对象</p> 
<pre><code class="language-java">package com;

import org.springframework.stereotype.Controller;

/**
 * Created with IntelliJ IDEA.
 * Description:
 * com.User: 
 * Date: 2023-04-05
 * Time: 17:59
 */
@Controller
public class User {
    private int Id;
    private String Name;

    public int getId() {
        return Id;
    }

    public void setId(int id) {
        Id = id;
    }

    public String getName() {
        return Name;
    }

    public void setName(String name) {
        Name = name;
    }

    @Override
    public String toString() {
        return "User{" +
                "Id=" + Id +
                ", Name='" + Name + '\'' +
                '}';
    }
}
</code></pre> 
<p>                                                                                                                                                                                     </p> 
<p>然后我们弄一个Users来存放User对象,顺便使用并@Bean注解</p> 
<pre><code class="language-java">package com.ganzhi;

import com.User;
import org.springframework.context.annotation.Bean;
import org.springframework.stereotype.Component;
import org.springframework.stereotype.Controller;

/**
 * Created with IntelliJ IDEA.
 * Description:
 * User:  
 * Date: 2023-04-06
 * Time: 21:17
 */
@Controller
public class Users {
    @Bean
    public User getUser(){
        User user = new User();
        user.setId(1);
        user.setName("zhangsan");
        return user;
    }
}
</code></pre> 
<p>     随后我们在App类中去运行                                                                                                                 </p> 
<pre><code class="language-java">package com;

import com.ganzhi.UserController;
import com.ganzhi.UserTest;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

/**
 * Created with IntelliJ IDEA.
 * Description:
 * com.User:  
 * Date: 2023-04-05
 * Time: 17:55
 */
public class App {
    public static void main(String[] args) {
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext("Spring-config.xml");


        User user = (User) applicationContext.getBean("getUser");
        System.out.println(user);
    }
}
</code></pre> 
<p>                          <span style="color:#fe2c24;">注意:这里的Bean命名规则和上面的命名规则是一致的,运行效果如下</span></p> 
<p><span style="color:#fe2c24;">注意:!!!!这里被Bean存入和获取的是不可以有参数的方法,因为这种方法存取参数是无法进行传递的</span></p> 
<p><img alt="" height="147" src="https://images2.imgbox.com/43/43/Tsrcwo5n_o.png" width="724">              证明了我们,可以正常去获得到Bean</p> 
<h4 id="%C2%A06.2.%E8%BF%99%E9%87%8C%E6%88%91%E4%BB%AC%E8%BF%98%E5%8F%AF%E4%BB%A5%E9%87%8D%E5%91%BD%E5%90%8DBean"> 6.2.这里我们还可以重命名Bean</h4> 
<p>如下</p> 
<pre><code class="language-java">package com.ganzhi;

import com.User;
import org.springframework.context.annotation.Bean;
import org.springframework.stereotype.Component;
import org.springframework.stereotype.Controller;

/**
 * Created with IntelliJ IDEA.
 * Description:
 * User:  
 * Date: 2023-04-06
 * Time: 21:17
 */
@Controller
public class Users {
    @Bean(name = {"u1"})
    public User getUser(){
        User user = new User();
        user.setId(1);
        user.setName("zhangsan");
        return user;
    }
}
</code></pre> 
<pre><code class="language-java">package com;

import com.ganzhi.UserController;
import com.ganzhi.UserTest;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

/**
 * Created with IntelliJ IDEA.
 * Description:
 * com.User:  
 * Date: 2023-04-05
 * Time: 17:55
 */
public class App {
    public static void main(String[] args) {
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext("Spring-config.xml");


        User user = (User) applicationContext.getBean("u1");
        System.out.println(user);
    }
}
</code></pre> 
<p>这里我们就给Bean重新起了一个叫u1的名字</p> 
<p><span style="color:#fe2c24;">注意:这里重命名的{}内其实是一个数组,可以存放多个Bean名,而且在读取的时候只要按照正确的方式,完全可以正常存取</span></p> 
<p></p> 
<h4 id="7.%E5%AF%B9%E8%B1%A1%E8%A3%85%E9%85%8D">7.对象装配</h4> 
<p>在上面我们都是通过applicationContext来拿到Bean的,那我们怎么样在非运行类中赋值给变量呢?</p> 
<p>这里我们就会使用到对象装配,这里也叫注入,有三种方式:属性注入,set注入,构造方法注入</p> 
<h4 id="7.1.%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5">7.1.属性注入</h4> 
<p>这是实现起来最简单的,只需要在需要赋值的变量上面加个@Autowired即可</p> 
<p>我们为了更好理解,就新建两个类,一个UserController,一个UserTest</p> 
<p>UserController:</p> 
<p>这个类是为了让我们拿到user对象,并且返回出去,便于UserTest调用</p> 
<pre><code class="language-java">package com.ganzhi;

import com.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.stereotype.Controller;

/**
 * Created with IntelliJ IDEA.
 * Description:
 * com.User:  
 * Date: 2023-04-05
 * Time: 21:18
 */
@Controller
public class UserController {
    public User getUserById(Integer id){
        User user = new User();
        user.setId(id);
        user.setName("zhangsan");
        return user;
    }
}
</code></pre> 
<p>UserTest:</p> 
<p>这个类是把上面存入的UserController 对象取出来,并且调用里面的getUserById方法,拿到User,返回给运行类,这里使用了属性注解,将Spring中的UserController 进行装配</p> 
<pre><code class="language-java">package com.ganzhi;

import com.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;

/**
 * Created with IntelliJ IDEA.
 * Description:
 * User: 王 
 * Date: 2023-04-06
 * Time: 21:33
 */
@Controller
public class UserTest {
   @Autowired
    private UserController userController;

    
    public User getUserById(Integer id){
        return userController.getUserById(id);
    }
}
</code></pre> 
<p>然后我们通过App类进行执行</p> 
<pre><code class="language-java">package com;

import com.ganzhi.UserController;
import com.ganzhi.UserTest;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

/**
 * Created with IntelliJ IDEA.
 * Description:
 * com.User:  
 * Date: 2023-04-05
 * Time: 17:55
 */
public class App {
    public static void main(String[] args) {
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext("Spring-config.xml");
//        BeanFactory beanFactory = new XmlBeanFactory(new ClassPathResource("Spring-config.xml"))
        UserTest userTest = applicationContext.getBean(UserTest.class);
        System.out.println(userTest.getUser(5).toString());


    }
}
</code></pre> 
<p>这里需要注意,我们拿到的是UserTest对象,而UserTest被注入了UserController对象,然而通过UserController的getUserById可以拿到一个User对象,再通过UserTest的getUserById返回给运行类,即可拿到User,我们这里模拟的是从库中取数据,所以反复调用,繁琐一些</p> 
<p>执行结果如下</p> 
<p><img alt="" height="205" src="https://images2.imgbox.com/b8/15/mOpjfM3G_o.png" width="826"></p> 
<h4 id="7.2.%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5">7.2.构造方法注入</h4> 
<p>我们这里只改变UserTest类</p> 
<pre><code class="language-java">package com.ganzhi;

import com.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;

/**
 * Created with IntelliJ IDEA.
 * Description:
 * User:  
 * Date: 2023-04-06
 * Time: 21:33
 */
@Controller
public class UserTest {

    private UserController userController;
    @Autowired
    public UserTest(UserController userController){
        this.userController = userController;
    }

    public User getUser(Integer id){
        return userController.getUserById(id);
    }
}
</code></pre> 
<p> 这里我们通过构造方法进行构造,我们 通过Autowired注解,给参数UserController进行赋值,然后通过构造方法中的赋值进行注入,也可以正确得到结果,这里就不赘述</p> 
<p>注意:当当前类只有一个构造方法时,可以省略@Autowired</p> 
<h4 id="7.3.set%E6%B3%A8%E5%85%A5">7.3.set注入</h4> 
<p>这里我们还是更改UserTest方法</p> 
<pre><code class="language-java">package com.ganzhi;

import com.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;

/**
 * Created with IntelliJ IDEA.
 * Description:
 * User: 王久实
 * Date: 2023-04-06
 * Time: 21:33
 */
@Controller
public class UserTest {

    private UserController userController;

    @Autowired
    public void setUserController(UserController userController){
        this.userController = userController;
    }
    public User getUser(Integer id){
        return userController.getUserById(id);
    }
}
</code></pre> 
<p>这里和上面的逻辑基本差不多,但是这里不可以省略@Autowired</p> 
<p></p> 
<h4 id="7.4.%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%83(%E9%9D%A2%E8%AF%95%E9%A2%98)">7.4.三种方法比较(面试题)</h4> 
<p><span style="background-color:#a2e043;">重要</span></p> 
<p>属性注入:</p> 
<p>        优势:使用简单,方便</p> 
<p>        劣势:只适用于IOC容器,只有在使用当前属性时,才会触发空指针异常</p> 
<p>构造方法注入:</p> 
<p>        优势:Spring官方推荐,通用,在使用之前,可以保证传入的类不为空,更符合单一设计原则</p> 
<p>        劣势:写法比较麻烦</p> 
<p>set注入:</p> 
<p>        优势:基本无</p> 
<p>        劣势:不如属性注入简介,不如构造方法通用</p> 
<p></p> 
<h4 id="7.5.Resource%E6%B3%A8%E8%A7%A3%E5%85%B3%E9%94%AE%E5%AD%97">7.5.Resource注解关键字</h4> 
<p>我们进行类注入时,不仅可以使用Autowired还可以使用Resource,这里基本使用方法和上面一致</p> 
<p>我们主要说一下不同的地方</p> 
<p>1.Resource是来自于JDK的注解,而Autowired来自于Spring</p> 
<p>2.Resource不适用于构造方法注入</p> 
<p>3.Resource可以支持Bean设置更多参数,如name,代码如下</p> 
<p> Users:</p> 
<pre><code class="language-java">package com.ganzhi;

import com.User;
import org.springframework.context.annotation.Bean;
import org.springframework.stereotype.Component;
import org.springframework.stereotype.Controller;

/**
 * Created with IntelliJ IDEA.
 * Description:
 * User:  
 * Date: 2023-04-06
 * Time: 21:17
 */
@Controller
public class Users {
    @Bean
    public User getUser1(){
        User user = new User();
        user.setId(1);
        user.setName("zhangsan");
        return user;
    }
    @Bean
    public User getUser2(){
        User user = new User();
        user.setId(2);
        user.setName("lisi");
        return user;
    }
}
</code></pre> 
<p>这里我们弄了两个Bean注解,那么我们就需要通过方法名来找了,但是Autowired却没有name参数,这时候,我们就可以使用Resource注解</p> 
<p>UserResource:</p> 
<pre><code class="language-java">package com.ganzhi;

import com.User;
import org.springframework.stereotype.Controller;

import javax.annotation.Resource;

/**
 * Created with IntelliJ IDEA.
 * Description:
 * User:   
 * Date: 2023-04-08
 * Time: 17:29
 */
@Controller
public class UserResource {
    @Resource(name = "getUser2")
    private User user;

    public void Hi(){
        System.out.println(user.toString());
    }
}
</code></pre> 
<p>这里我们去执行</p> 
<pre><code class="language-java">package com;

import com.ganzhi.UserController;
import com.ganzhi.UserResource;
import com.ganzhi.UserTest;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import javax.annotation.Resource;

/**
 * Created with IntelliJ IDEA.
 * Description:
 * com.User:  
 * Date: 2023-04-05
 * Time: 17:55
 */
public class App {


    public static void main(String[] args) {
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext("Spring-config.xml");

        UserResource userResource =  applicationContext.getBean("userResource", UserResource.class);
        userResource.Hi();
    }
}
</code></pre> 
<p>就可以得到下面的结果</p> 
<p><img alt="" height="218" src="https://images2.imgbox.com/79/22/8beae3JK_o.png" width="1134"></p> 
<h4 id="7.6.%40Qualifier">7.6.@Qualifier</h4> 
<p><br> 如果我们实在想用Autowired就需要多添加一个这个注解来进行设置参数</p> 
<p> 对UserResource进行修改</p> 
<pre><code class="language-java">package com.ganzhi;

import com.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Controller;

import javax.annotation.Resource;

/**
 * Created with IntelliJ IDEA.
 * Description:
 * User:  
 * Date: 2023-04-08
 * Time: 17:29
 */
@Controller
public class UserResource {
//    @Resource(name = "getUser2")
    @Autowired
    @Qualifier(value = "getUser2")
    private User user;

    public void Hi(){
        System.out.println(user.toString());
    }
}
</code></pre> 
<p>可以得到相同的结果</p> 
<p><img alt="" height="520" src="https://images2.imgbox.com/24/8d/u8p54uCY_o.png" width="1200"></p> 
<p>这里的value可以省略,直接写@Qualifier("getUser2")</p> 
<p></p> 
<p>到这里就结束了,感谢观看 </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f6da263296921d084f32113c04962359/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">51单片机点亮LED灯</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/90ba100691e69a5fdedf0118c39bfb1a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">初始Vue：为什么Vue.config.productionTip=false修改了，网页上的提示还在？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>