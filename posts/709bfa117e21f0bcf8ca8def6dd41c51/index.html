<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>实模式切换到保护模式，为什么要开启A20地址线（系统升级产生的兼容性问题）... - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="实模式切换到保护模式，为什么要开启A20地址线（系统升级产生的兼容性问题）..." />
<meta property="og:description" content="【-1】写在前面： 以下部分内容总结于 http://blog.csdn.net/ruyanhai/article/details/7181842 complementary: 兼容性是指运行在前期CPU，如8086/8088上的的程序，也可以运行在其以后的处理器，如80286上； 【0】看看intel处理器的发展历程 【1】8086/8088的寻址和问题 1.1）寻址：在8086/8088中，只有20根地址总线，所以可以访问的地址是2^20=1M，但由于8086/8088是16位地址模式，能够表示的地址范围是0-64K，所以为了在8086/8088下能够访问1M内存，Intel采取了分段的模式：16位段基地址:16位偏移。其绝对地址计算方法为：16位基地址左移4位&#43;16位偏移=20位地址；（这个比较简单） 1.2）问题： 但这种方式引起了新的问题，通过上述分段模式，能够表示的最大内存为：FFFFh:FFFFh=FFFF0h&#43;FFFFh=10FFEFh=1M&#43;64K-16Bytes（1M多余出来的部分被称做高端内存区HMA）。但8086/8088只有20位地址线，如果访问100000h~10FFEFh之间的内存，则必须有第21根地址线。所以当程序员给出超过1M（100000H-10FFEFH）的地址时，系统并不认为其访问越界而产生异常，而是自动从重新0开始计算，也就是说系统计算实际地址的时候是按照对1M求模的方式进行的，这种技术被称为wrap-around。 【2】80286的寻址和问题 2.0）寻址： 到了80286，系统的地址总线发展为24根，这样能够访问的内存可以达到2^24=16M。Intel在设计80286时提出的目标是，在实模式下，系统所表现的行为应该和8086/8088所表现的完全一样，也就是说，在实模式下，80286以及后续系列，应该和8086/8088完全兼容； 2.1）问题：如果程序员访问100000H-10FFEFH之间的内存，80286将实际访问这块内存，而不是像过去一样重新从0开始，因为80286有这个寻址能力，但是这就不能满足和8086/8088的系统兼容性，因为8086/8088不能访问到100000H-10FFEFH之间的内存的真实地址而是按照对1M求模的内存寻址方式； 【3】再浅谈80286 和 8086/8088 间的兼容性问题：（实模式下，80286的系统表现要同8086/8088的一致） 3.1）当A20被禁止时：程序员给出100000H~10FFEFH间的地址，80286和8086/8088 的系统表现是一致的，即按照对1M求模的方式进行寻址，满足系统升级的兼容性问题； 3.2）当A20被开启时：程序员给出的100000H~10FFEFH间的地址，80286是访问的真实地址，而8086/8088是始终是按照对1M求模的方式进行的（这里注意，是始终）； 【4】解决方法： 为了解决上述问题，IBM使用键盘控制器上剩余的一些输出线来管理第21根地址线（从0开始数是第20根），被称为A20Gate：如果A20 Gate被打开，则当程序员给出100000H-10FFEFH之间的地址的时候，系统将真正访问这块内存区域；如果A20Gate被禁止，则当程序员给出100000H-10FFEFH之间的地址的时候，系统仍然使用8086/8088的方式。 【5】有请实模式&#43;保护模式闪亮登场（干货） 5.1）实模式：实模式就是， 为了实现系统升级的兼容性，如80286的系统表现（包括80286以后的CPU）要与8086/8088 的系统表现一致，就需要80286 CPU访问100000H-10FFEFH之间的地址的时候， 按照对1M求模的方式进行， 无论A20地址线开启关闭与否， 这种内存访问情况 称为实模式； 5.2）保护模式：保护模式就是， 以A20地址线开启为前提，80286 CPU访问100000H-10FFEFH之间的地址的时候， 是访问真实的内存地址，不是求模访问，如访问100001H，就是真真切切地 访问 0x 100001H，而不是求模的 0x000001H 地址， 这种内存访问情况称为保护模式； 5.3）诞生日： 实模式是从8088/8086 就开始存在了， 而保护模式从 80286 才开始存在； 【6】为什么需要保护模式？（因为实模式与生俱来，是伴随着8088/8086 从天而降的，它仅仅是访问内存的一种方式而已； 还有对于8086/8088而言，它只有实模式这一种内存寻址方式，而对于80286包括其以后的CPU，有实模式和保护模式两种寻址方式，因为要兼顾系统兼容性） 显然随着CPU的升级，8088/8086的内存寻址方式已经无法满足需要，也可以说，为了能够访问10FFEFH以上的内存，则必须进入保护模式； 【7】A20被禁止&#43;被开启的不同结果 7.1）如果A20Gate被禁止：对于80286来说，其地址为24bit，其地址表示为EFFFFF；对于80386极其随后的32-bit芯片来说，其地址表示为FFEFFFFF。这种表示的意思是如果A20Gate被禁止，则其第20-bit在CPU做地址访问的时候是无效的，永远只能被作为0； 7.2）如果A20 Gate被打开：则其第20-bit是有效的，其值既可以是0，又可以是1； 7.3）所以：在保护模式下，如果A20 Gate被打开，则可以访问的内存则是连续的；如果A20Gate被禁止，则可以访问的内存只能是偶数段， 因为是20位（从0始）总为零，所23~20位只能是0000、0010、0100、0110、1000、1010、1100、1110对应十六进制为0、2、4、6、8、A、C、E。对应的十六进制地址段是000000-0FFFFF,200000-2FFFFF,400000-4FFFFF… 版权声明：本文为博主原创文章，未经博主允许不得转载。
转载于:https://www.cnblogs.com/pacoson/p/4893169.html" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/709bfa117e21f0bcf8ca8def6dd41c51/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-08-26T16:47:00+08:00" />
<meta property="article:modified_time" content="2015-08-26T16:47:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">实模式切换到保护模式，为什么要开启A20地址线（系统升级产生的兼容性问题）...</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <div class="markdown_views"> 
  <h3 id="1写在前面"><strong>【-1】写在前面：</strong></h3> 
  <h4 id="以下部分内容总结于-httpblogcsdnnetruyanhaiarticledetails7181842">以下部分内容总结于 <a href="http://blog.csdn.net/ruyanhai/article/details/7181842">http://blog.csdn.net/ruyanhai/article/details/7181842</a></h4> 
  <h4 id="complementary-兼容性是指运行在前期cpu如80868088上的的程序也可以运行在其以后的处理器如80286上">complementary: 兼容性是指运行在前期CPU，如8086/8088上的的程序，也可以运行在其以后的处理器，如80286上；</h4> 
  <hr> 
  <h3 id="0看看intel处理器的发展历程"><strong>【0】看看intel处理器的发展历程</strong></h3> 
  <p><img src="https://images2.imgbox.com/b9/ec/DLySDodA_o.png" alt="这里写图片描述" title=""></p> 
  <hr> 
  <h3 id="180868088的寻址和问题"><strong>【1】8086/8088的寻址和问题</strong></h3> 
  <h4 id="11寻址在80868088中只有20根地址总线所以可以访问的地址是2201m但由于80868088是16位地址模式能够表示的地址范围是0-64k所以为了在80868088下能够访问1m内存intel采取了分段的模式16位段基地址16位偏移其绝对地址计算方法为16位基地址左移4位16位偏移20位地址这个比较简单"><strong>1.1）寻址：</strong>在8086/8088中，只有20根地址总线，所以可以访问的地址是2^20=1M，但由于8086/8088是16位地址模式，能够表示的地址范围是0-64K，所以为了在8086/8088下能够访问1M内存，Intel采取了分段的模式：16位段基地址:16位偏移。其绝对地址计算方法为：16位基地址左移4位+16位偏移=20位地址；（这个比较简单）</h4> 
  <h4 id="12问题-但这种方式引起了新的问题通过上述分段模式能够表示的最大内存为ffffhffffhffff0hffffh10ffefh1m64k-16bytes1m多余出来的部分被称做高端内存区hma但80868088只有20位地址线如果访问100000h10ffefh之间的内存则必须有第21根地址线所以当程序员给出超过1m100000h-10ffefh的地址时系统并不认为其访问越界而产生异常而是自动从重新0开始计算也就是说系统计算实际地址的时候是按照对1m求模的方式进行的这种技术被称为wrap-around"><strong>1.2）问题：</strong> 但这种方式引起了新的问题，通过上述分段模式，能够表示的最大内存为：FFFFh:FFFFh=FFFF0h+FFFFh=10FFEFh=1M+64K-16Bytes（1M多余出来的部分被称做高端内存区HMA）。但8086/8088只有20位地址线，如果访问100000h~10FFEFh之间的内存，则必须有第21根地址线。所以当程序员给出超过1M（100000H-10FFEFH）的地址时，系统并不认为其访问越界而产生异常，而是自动从重新0开始计算，也就是说系统计算实际地址的时候是按照对1M求模的方式进行的，这种技术被称为wrap-around。</h4> 
  <hr> 
  <h3 id="280286的寻址和问题"><strong>【2】80286的寻址和问题</strong></h3> 
  <h4 id="20寻址-到了80286系统的地址总线发展为24根这样能够访问的内存可以达到22416mintel在设计80286时提出的目标是在实模式下系统所表现的行为应该和80868088所表现的完全一样也就是说在实模式下80286以及后续系列应该和80868088完全兼容"><strong>2.0）寻址：</strong> 到了80286，系统的地址总线发展为24根，这样能够访问的内存可以达到2^24=16M。Intel在设计80286时提出的目标是，在实模式下，系统所表现的行为应该和8086/8088所表现的完全一样，也就是说，在实模式下，80286以及后续系列，应该和8086/8088完全兼容；</h4> 
  <h4 id="21问题如果程序员访问100000h-10ffefh之间的内存80286将实际访问这块内存而不是像过去一样重新从0开始因为80286有这个寻址能力但是这就不能满足和80868088的系统兼容性因为80868088不能访问到100000h-10ffefh之间的内存的真实地址而是按照对1m求模的内存寻址方式"><strong>2.1）问题：</strong>如果程序员访问100000H-10FFEFH之间的内存，80286将实际访问这块内存，而不是像过去一样重新从0开始，因为80286有这个寻址能力，但是这就不能满足和8086/8088的系统兼容性，因为8086/8088不能访问到100000H-10FFEFH之间的内存的真实地址而是按照对1M求模的内存寻址方式；</h4> 
  <hr> 
  <h3 id="3再浅谈80286-和-80868088-间的兼容性问题实模式下80286的系统表现要同80868088的一致"><strong>【3】再浅谈80286 和 8086/8088 间的兼容性问题：（实模式下，80286的系统表现要同8086/8088的一致）</strong></h3> 
  <h4 id="31当a20被禁止时程序员给出100000h10ffefh间的地址80286和80868088-的系统表现是一致的即按照对1m求模的方式进行寻址满足系统升级的兼容性问题"><strong>3.1）当A20被禁止时：</strong>程序员给出100000H~10FFEFH间的地址，80286和8086/8088 的系统表现是一致的，即按照对1M求模的方式进行寻址，满足系统升级的兼容性问题；</h4> 
  <h4 id="32当a20被开启时程序员给出的100000h10ffefh间的地址80286是访问的真实地址而80868088是始终是按照对1m求模的方式进行的这里注意是始终"><strong>3.2）当A20被开启时：</strong>程序员给出的100000H~10FFEFH间的地址，80286是访问的真实地址，而8086/8088是始终是按照对1M求模的方式进行的（这里注意，是始终）；</h4> 
  <hr> 
  <h3 id="4解决方法"><strong>【4】解决方法：</strong></h3> 
  <h4 id="为了解决上述问题ibm使用键盘控制器上剩余的一些输出线来管理第21根地址线从0开始数是第20根被称为a20gate如果a20-gate被打开则当程序员给出100000h-10ffefh之间的地址的时候系统将真正访问这块内存区域如果a20gate被禁止则当程序员给出100000h-10ffefh之间的地址的时候系统仍然使用80868088的方式">为了解决上述问题，IBM使用键盘控制器上剩余的一些输出线来管理第21根地址线（从0开始数是第20根），被称为A20Gate：如果A20 Gate被打开，则当程序员给出100000H-10FFEFH之间的地址的时候，系统将真正访问这块内存区域；如果A20Gate被禁止，则当程序员给出100000H-10FFEFH之间的地址的时候，系统仍然使用8086/8088的方式。</h4> 
  <hr> 
  <h3 id="5有请实模式保护模式闪亮登场干货"><strong>【5】有请实模式+保护模式闪亮登场<font color="#FF0000">（干货）</font></strong></h3> 
  <h4 id="51实模式实模式就是-为了实现系统升级的兼容性如80286的系统表现包括80286以后的cpu要与80868088-的系统表现一致就需要80286-cpu访问100000h-10ffefh之间的地址的时候-按照对1m求模的方式进行-无论a20地址线开启关闭与否-这种内存访问情况-称为实模式"><strong>5.1）实模式：</strong>实模式就是， 为了实现系统升级的兼容性，如80286的系统表现（包括80286以后的CPU）要与8086/8088 的系统表现一致，就需要80286 CPU访问100000H-10FFEFH之间的地址的时候， 按照对1M求模的方式进行， 无论A20地址线开启关闭与否， 这种内存访问情况 称为实模式；</h4> 
  <h4 id="52保护模式保护模式就是-以a20地址线开启为前提80286-cpu访问100000h-10ffefh之间的地址的时候-是访问真实的内存地址不是求模访问如访问100001h就是真真切切地-访问-0x-100001h而不是求模的-0x000001h-地址-这种内存访问情况称为保护模式"><strong>5.2）保护模式：</strong>保护模式就是， 以A20地址线开启为前提，80286 CPU访问100000H-10FFEFH之间的地址的时候， 是访问真实的内存地址，不是求模访问，如访问100001H，就是真真切切地 访问 0x 100001H，而不是求模的 0x000001H 地址， 这种内存访问情况称为保护模式；</h4> 
  <h4 id="53诞生日-实模式是从80888086-就开始存在了-而保护模式从-80286-才开始存在"><strong>5.3）诞生日： </strong>实模式是从8088/8086 就开始存在了， 而保护模式从 80286 才开始存在；</h4> 
  <hr> 
  <h3 id="6为什么需要保护模式因为实模式与生俱来是伴随着80888086-从天而降的它仅仅是访问内存的一种方式而已-还有对于80868088而言它只有实模式这一种内存寻址方式而对于80286包括其以后的cpu有实模式和保护模式两种寻址方式因为要兼顾系统兼容性"><strong>【6】为什么需要保护模式？（因为实模式与生俱来，是伴随着8088/8086 从天而降的，它仅仅是访问内存的一种方式而已； 还有对于8086/8088而言，它只有实模式这一种内存寻址方式，而对于80286包括其以后的CPU，有实模式和保护模式两种寻址方式，因为要兼顾系统兼容性）</strong></h3> 
  <h4 id="显然随着cpu的升级80888086的内存寻址方式已经无法满足需要也可以说为了能够访问10ffefh以上的内存则必须进入保护模式">显然随着CPU的升级，8088/8086的内存寻址方式已经无法满足需要，也可以说，为了能够访问10FFEFH以上的内存，则必须进入保护模式；</h4> 
  <hr> 
  <h3 id="7a20被禁止被开启的不同结果"><strong>【7】A20被禁止+被开启的不同结果</strong></h3> 
  <h4 id="71如果a20gate被禁止对于80286来说其地址为24bit其地址表示为efffff对于80386极其随后的32-bit芯片来说其地址表示为ffefffff这种表示的意思是如果a20gate被禁止则其第20-bit在cpu做地址访问的时候是无效的永远只能被作为0"><strong>7.1）如果A20Gate被禁止：</strong>对于80286来说，其地址为24bit，其地址表示为EFFFFF；对于80386极其随后的32-bit芯片来说，其地址表示为FFEFFFFF。这种表示的意思是如果A20Gate被禁止，则其第20-bit在CPU做地址访问的时候是无效的，永远只能被作为0；</h4> 
  <h4 id="72如果a20-gate被打开则其第20-bit是有效的其值既可以是0又可以是1"><strong>7.2）如果A20 Gate被打开：</strong>则其第20-bit是有效的，其值既可以是0，又可以是1；</h4> 
  <h4 id="73所以在保护模式下如果a20-gate被打开则可以访问的内存则是连续的如果a20gate被禁止则可以访问的内存只能是偶数段"><strong>7.3）所以：</strong>在保护模式下，如果A20 Gate被打开，则可以访问的内存则是连续的；如果A20Gate被禁止，则可以访问的内存只能是偶数段，</h4> 
  <h4 id="因为是20位从0始总为零所2320位只能是00000010010001101000101011001110对应十六进制为02468ace对应的十六进制地址段是000000-0fffff200000-2fffff400000-4fffff">因为是20位（从0始）总为零，所23~20位只能是0000、0010、0100、0110、1000、1010、1100、1110对应十六进制为0、2、4、6、8、A、C、E。对应的十六进制地址段是000000-0FFFFF,200000-2FFFFF,400000-4FFFFF…</h4> 
 </div> 
 <div> 
  <p style="font-size:12px;">版权声明：本文为博主原创文章，未经博主允许不得转载。</p> 
 </div> 
</div> 
<p>转载于:https://www.cnblogs.com/pacoson/p/4893169.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/395dfaefc4b1cc9c1c000710c36eda50/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">LeetCode（38） Count and Say</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9c122e24fed044d8ce51aa490286c1d8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">PCIE协议解析 synopsys IP Core 读书笔记（2）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>