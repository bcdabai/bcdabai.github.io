<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java对象结构与synchronized实现原理及MarkWord详解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java对象结构与synchronized实现原理及MarkWord详解" />
<meta property="og:description" content="本博客的本意不是技术分享
只是在学习过程中感觉需要复习的知识点记录整理下来
方便复习，以便面试的时候用
具体细节请阅读《深入理解Java虚拟机》
若本文对你有帮助那十分荣幸。
JAVA对象的总体结构 由于Java面向对象的思想，在JVM中需要大量存储对象，存储时为了实现一些额外的功能，需要在对象中添加一些标记字段用于增强对象功能 。在学习并发编程知识synchronized时，我们总是难以理解其实现原理，因为偏向锁、轻量级锁、重量级锁都涉及到对象头，所以了解java对象头是我们深入了解synchronized的前提条件
堆内存中的java对象：
对象的几个部分的作用：
1.对象头中的Mark Word（标记字）主要用来表示对象的线程锁状态，另外还可以用来配合GC、存放该对象的hashCode；
2.Klass Pointer是一个指向方法区中Class信息的指针，意味着该对象可随时知道自己是哪个Class的实例；
3.数组长度也是占用64位（8字节）的空间，这是可选的，只有当本对象是一个数组对象时才会有这个部分；
4.实例数据是用于保存对象属性和值的主体部分，占用内存空间取决于对象的属性数量和类型；
5.对齐字是为了减少堆内存的碎片空间
获取一个对象布局实例 1 创建一个maven项目，引入pom
&lt;dependency&gt; &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt; &lt;artifactId&gt;jol-core&lt;/artifactId&gt; &lt;version&gt;0.9&lt;/version&gt; &lt;/dependency&gt; 2 调用ClassLayout.parseInstance().toPrintable()
```java @Test void contextLoads() { L l = new L(); //new 一个对象 System.out.println(ClassLayout.parseInstance(l).toPrintable());//输出 l对象 的布局 } com.struggle.javaobject.L object internals: OFFSET SIZE TYPE DESCRIPTION VALUE 0 4 (object header) 01 00 00 00 (00000001 00000000 00000000 00000000) (1) 4 4 (object header) 00 00 00 00 (00000000 00000000 00000000 00000000) (0) 8 4 (object header) fa bc 06 f8 (11111010 10111100 00000110 11111000) (-133776134) 12 1 boolean L." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/23e437265e399f13dd5624cee615b0e0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-07-01T23:57:39+08:00" />
<meta property="article:modified_time" content="2021-07-01T23:57:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java对象结构与synchronized实现原理及MarkWord详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>本博客的本意不是技术分享<br> 只是在学习过程中感觉需要复习的知识点记录整理下来<br> 方便复习，以便面试的时候用<br> 具体细节请阅读《深入理解Java虚拟机》<br> 若本文对你有帮助那十分荣幸。</p> 
<h3><a id="JAVA_5"></a>JAVA对象的总体结构</h3> 
<p>由于Java面向对象的思想，在JVM中需要大量存储对象，存储时为了实现一些额外的功能，需要在对象中添加一些标记字段用于增强对象功能 。在学习并发编程知识synchronized时，我们总是难以理解其实现原理，因为偏向锁、轻量级锁、重量级锁都涉及到对象头，所以了解java对象头是我们深入了解synchronized的前提条件<br> 堆内存中的java对象：<br> <img src="https://images2.imgbox.com/79/e2/rDyfDNPO_o.png" alt="在这里插入图片描述"><br> 对象的几个部分的作用：</p> 
<p>1.对象头中的Mark Word（标记字）主要用来表示对象的线程锁状态，另外还可以用来配合GC、存放该对象的hashCode；<br> 2.Klass Pointer是一个指向方法区中Class信息的指针，意味着该对象可随时知道自己是哪个Class的实例；<br> 3.数组长度也是占用64位（8字节）的空间，这是可选的，只有当本对象是一个数组对象时才会有这个部分；<br> 4.实例数据是用于保存对象属性和值的主体部分，占用内存空间取决于对象的属性数量和类型；<br> 5.对齐字是为了减少堆内存的碎片空间</p> 
<h3><a id="_17"></a>获取一个对象布局实例</h3> 
<p>1 创建一个maven项目，引入pom</p> 
<pre><code class="prism language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.openjdk.jol<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>jol-core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>0.9<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<p>2 调用ClassLayout.parseInstance().toPrintable()</p> 
<pre><code class="prism language-xml">
```java
@Test
void contextLoads() {
    L l = new L();  //new 一个对象
    System.out.println(ClassLayout.parseInstance(l).toPrintable());//输出 l对象 的布局
}
</code></pre> 
<pre><code class="prism language-java">com<span class="token punctuation">.</span>struggle<span class="token punctuation">.</span>javaobject<span class="token punctuation">.</span>L object internals<span class="token operator">:</span>
 OFFSET  SIZE      TYPE DESCRIPTION                               VALUE
      <span class="token number">0</span>     <span class="token number">4</span>           <span class="token punctuation">(</span>object header<span class="token punctuation">)</span>                           <span class="token number">01</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token punctuation">(</span><span class="token number">00000001</span> <span class="token number">00000000</span> <span class="token number">00000000</span> <span class="token number">00000000</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
      <span class="token number">4</span>     <span class="token number">4</span>           <span class="token punctuation">(</span>object header<span class="token punctuation">)</span>                           <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token punctuation">(</span><span class="token number">00000000</span> <span class="token number">00000000</span> <span class="token number">00000000</span> <span class="token number">00000000</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
      <span class="token number">8</span>     <span class="token number">4</span>           <span class="token punctuation">(</span>object header<span class="token punctuation">)</span>                           fa bc <span class="token number">06</span> f8 <span class="token punctuation">(</span><span class="token number">11111010</span> <span class="token number">10111100</span> <span class="token number">00000110</span> <span class="token number">11111000</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">133776134</span><span class="token punctuation">)</span>
     <span class="token number">12</span>     <span class="token number">1</span>   <span class="token keyword">boolean</span> L<span class="token punctuation">.</span>myboolean                               <span class="token boolean">true</span>
     <span class="token number">13</span>     <span class="token number">3</span>           <span class="token punctuation">(</span>loss due to the next object alignment<span class="token punctuation">)</span>
Instance size<span class="token operator">:</span> <span class="token number">16</span> bytes
Space losses<span class="token operator">:</span> <span class="token number">0</span> bytes internal <span class="token operator">+</span> <span class="token number">3</span> bytes external <span class="token operator">=</span> <span class="token number">3</span> bytes total
</code></pre> 
<p>对象头所占用的内存大小为12*8bit=96bit。<br> OFFSET：偏移地址，单位字节；<br> SIZE：占用的内存大小，单位为字节；<br> TYPE DESCRIPTION：类型描述，其中object header为对象头；<br> VALUE：对应内存中当前存储的值；</p> 
<h3><a id="_56"></a>对象头的组成</h3> 
<p>一个JAVA对象的存储结构。在Hotspot虚拟机中，对象在内存中的存储布局分为 3 块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）<br> 在我们刚刚打印的结果中可以这样归类:</p> 
<pre><code class="prism language-java">com<span class="token punctuation">.</span>struggle<span class="token punctuation">.</span>javaobject<span class="token punctuation">.</span>L object internals<span class="token operator">:</span>
 OFFSET  SIZE      TYPE DESCRIPTION                               VALUE
      <span class="token number">0</span>     <span class="token number">4</span>           <span class="token punctuation">(</span>object header<span class="token punctuation">)</span>    <span class="token comment">//markword             01 00 00 00 (00000001 00000000 00000000 00000000) (1)</span>
      <span class="token number">4</span>     <span class="token number">4</span>           <span class="token punctuation">(</span>object header<span class="token punctuation">)</span>    <span class="token comment">//markword             00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span>
      <span class="token number">8</span>     <span class="token number">4</span>           <span class="token punctuation">(</span>object header<span class="token punctuation">)</span>   <span class="token comment">//klass pointer类元数据  fa bc 06 f8 (11111010 10111100 00000110 11111000) (-133776134)</span>
     <span class="token number">12</span>     <span class="token number">1</span>   <span class="token keyword">boolean</span> L<span class="token punctuation">.</span>myboolean       <span class="token comment">// Instance Data 对象实际的数据          true</span>
     <span class="token number">13</span>     <span class="token number">3</span>           <span class="token punctuation">(</span>loss due to the next object alignment<span class="token punctuation">)</span> <span class="token comment">//Padding 对齐填充数据</span>
Instance size<span class="token operator">:</span> <span class="token number">16</span> bytes
Space losses<span class="token operator">:</span> <span class="token number">0</span> bytes internal <span class="token operator">+</span> <span class="token number">3</span> bytes external <span class="token operator">=</span> <span class="token number">3</span> bytes total
</code></pre> 
<p>1.Mark Word<br> 这部分主要用来存储对象自身的运行时数据，如hashcode、gc分代年龄等。mark word的位长度为JVM的一个Word大小，也就是说32位JVM的Mark word为32位，64位JVM为64位。<br> 为了让一个字大小存储更多的信息，JVM将字的最低两个位设置为标记位，不同标记位下的Mark Word示意如下：<br> <img src="https://images2.imgbox.com/92/5a/JoPFaZVQ_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/fc/61/V7lv7xJE_o.png" alt="在这里插入图片描述"><br> 其中各部分的含义如下：<br> lock:2位的锁状态标记位，由于希望用尽可能少的二进制位表示尽可能多的信息，所以设置了lock标记。该标记的值不同，整个mark word表示的含义不同。通过倒数三位数（<strong>包含biased_lock</strong>）我们可以判断出锁的类型</p> 
<p>enum {<!-- --><br> locked_value = 0, // 0 00 轻量级锁<br> unlocked_value = 1,// 0 01 无锁<br> monitor_value = 2,// 0 10 重量级锁<br> marked_value = 3,// 0 11 gc标志<br> biased_lock_pattern = 5 // 1 01 偏向锁<br> };</p> 
<p>biased_lock：<strong>对象是否启用偏向锁标记，只占1个二进制位。为1时表示对象启用偏向锁，为0时表示对象没有偏向锁。lock和biased_lock共同表示对象处于什么锁状态。</strong><br> age：<strong>4位的Java对象年龄。在GC中，如果对象在Survivor区复制一次，年龄增加1。当对象达到设定的阈值时，将会晋升到老年代。默认情况下，并行GC的年龄阈值为15，并发GC的年龄阈值为6。由于age只有4位，所以最大值为15，这就是-XX:MaxTenuringThreshold选项最大值为15的原因。</strong><br> identity_hashcode：31位的对象标识hashCode，采用延迟加载技术。调用方法System.identityHashCode()计算，并会将结果写到该对象头中。当对象加锁后（偏向、轻量级、重量级），MarkWord的字节没有足够的空间保存hashCode，因此该值会移动到管程Monitor中。<br> thread：持有偏向锁的线程ID。<br> epoch：偏向锁的时间戳。<br> ptr_to_lock_record：轻量级锁状态下，指向栈中锁记录的指针。<br> ptr_to_heavyweight_monitor：重量级锁状态下，指向对象监视器Monitor的指针。</p> 
<p>2.Klass Pointer<br> 即对象指向它的元数据的指针，虚拟机通过这个指针来确定是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针(通过句柄池访问)。</p> 
<p>简单引申一下对象的访问方式，我们创建对象的目的就是为了使用它。所以我们的Java程序在运行时会通过虚拟机栈中本地变量表的reference数据来操作堆上对象。但是reference只是JVM中规范的一个指向对象的引用，那这个引用如何去定位到具体的对象呢？因此，不同的虚拟机可以实现不同的定位方式。主要有两种：句柄池和直接指针。</p> 
<p>通过句柄池访问的话，对象的类型指针是不需要存在于对象头中的，但是目前大部分的虚拟机实现都是采用直接指针方式访问。此外如果对象为JAVA数组的话，那么在对象头中还会存在一部分数据来标识数组长度，否则JVM可以查看普通对象的元数据信息就可以知道其大小，看数组对象却不行。</p> 
<p>3 对齐填充字节<br> 因为JVM要求java的对象占的内存大小应该是8bit的倍数，所以后面有几个字节用于把对象的大小补齐至8bit的倍数。</p> 
<h3><a id="JVM_105"></a>JVM升级锁的过程</h3> 
<p>1，当没有被当成锁时，这就是一个普通的对象，Mark Word记录对象的HashCode，锁标志位是01，是否偏向锁那一位是0。</p> 
<p>2，当对象被当做同步锁并有一个线程A抢到了锁时，锁标志位还是01，但是否偏向锁那一位改成1，前23bit记录抢到锁的线程id，表示进入偏向锁状态。</p> 
<p>3，当线程A再次试图来获得锁时，JVM发现同步锁对象的标志位是01，是否偏向锁是1，也就是偏向状态，Mark Word中记录的线程id就是线程A自己的id，表示线程A已经获得了这个偏向锁，可以执行同步锁的代码。</p> 
<p>4，当线程B试图获得这个锁时，JVM发现同步锁处于偏向状态，但是Mark Word中的线程id记录的不是B，那么线程B会先用CAS操作试图获得锁，这里的获得锁操作是有可能成功的，因为线程A一般不会自动释放偏向锁。如果抢锁成功，就把Mark Word里的线程id改为线程B的id，代表线程B获得了这个偏向锁，可以执行同步锁代码。如果抢锁失败，则继续执行步骤5。</p> 
<p>5，偏向锁状态抢锁失败，代表当前锁有一定的竞争，偏向锁将升级为轻量级锁。JVM会在当前线程的线程栈中开辟一块单独的空间，里面保存指向对象锁Mark Word的指针，同时在对象锁Mark Word中保存指向这片空间的指针。上述两个保存操作都是CAS操作，如果保存成功，代表线程抢到了同步锁，就把Mark Word中的锁标志位改成00，可以执行同步锁代码。如果保存失败，表示抢锁失败，竞争太激烈，继续执行步骤6。</p> 
<p>6，轻量级锁抢锁失败，JVM会使用自旋锁，自旋锁不是一个锁状态，只是代表不断的重试，尝试抢锁。从JDK1.7开始，自旋锁默认启用，自旋次数由JVM决定。如果抢锁成功则执行同步锁代码，如果失败则继续执行步骤7。</p> 
<p>7，自旋锁重试之后如果抢锁依然失败，同步锁会升级至重量级锁，锁标志位改为10。在这个状态下，未抢到锁的线程都会被阻塞。</p> 
<p>参考和复制了以下博客：<br> https://blog.csdn.net/srs1995/article/details/109351177<br> https://blog.csdn.net/scdn_cp/article/details/86491792#comments</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/73fc1799bf196a524e7369f1babfaab5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">3.1 react的空标签</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4c81418724479dbe45010877789df941/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">计算机桌面如何分区,讲解电脑如何分区</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>