<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Git .gitignore 文件上传过滤配置 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Git .gitignore 文件上传过滤配置" />
<meta property="og:description" content=".gitignore 介绍 在项目编译过程中，会生成一些中间文件，或者在项目中的部分文件是不需要进行版本管理的。对于这些文件应该对于 Git 来讲是透明的。Git 提供这种功能，可以自己指定哪些文件可以不被管理。
具体方法是在版本管理的根目录下（与 .git 文件夹同级）创建一个 .gitignore（gitignore 是隐藏文件，所以前面有个点）在进行协作开发代码管理的过程中，常常会遇到某些临时文件、配置文件、或者生成文件等，这些文件由于不同的开发端会不一样，如果使用 git add . 将所有文件纳入 git 库中，那么会出现频繁的改动和 push，这样会引起开发上的不便。Git 可以很方便的帮助我们解决这个问题，那就是建立项目文件过滤规则。
Git 中提供两种过滤机制：
1）全局过滤机制，即对所有的 Git 都适用；
2）针对某个项目使用的过滤规则；
常用的是第二种，在项目下创建 .gitignore 文件。
创建 .gitignore windows：创建一个文件，文件名为：“.gitignore.”，注意前后都有一个点。保存之后系统会自动重命名为“.gitignore”
linux：touch .gitignore
配置语法 以斜杠 “/” 开头表示跟目录，放在末尾表示跟目录以及子目录下的所有该文件夹；
以星号 “*” 通配多个字符；
以问号 “?” 通配单个字符；
以方括号 “[]” 包含单个字符的匹配列表；
以叹号 “!” 表示不忽略(跟踪)匹配到的文件或目录；
此外，Git 对于 .ignore 配置文件是按行从上到下进行规则匹配的，意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效；
示例 fd1/*
说明：忽略目录 fd1 下的全部内容；注意，不管是根目录下的 /fd1/ 目录，还是某个子目录 /child/fd1/ 目录，都会被忽略
/fd1/*
说明：忽略根目录下的 /fd1/ 目录的全部内容
/mtk/do.c
说明：过滤某个具体文件
/*" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/c49957b527a680aede2cf2ebbc7be84d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-12T11:54:29+08:00" />
<meta property="article:modified_time" content="2022-02-12T11:54:29+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Git .gitignore 文件上传过滤配置</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>.gitignore 介绍</h2> 
<p></p> 
<p>在项目编译过程中，会生成一些中间文件，或者在项目中的部分文件是不需要进行版本管理的。对于这些文件应该对于 Git 来讲是透明的。Git 提供这种功能，可以自己指定哪些文件可以不被管理。</p> 
<p>具体方法是在版本管理的根目录下（与 .git 文件夹同级）创建一个  .gitignore（gitignore 是隐藏文件，所以前面有个点）在进行协作开发代码管理的过程中，常常会遇到某些临时文件、配置文件、或者生成文件等，这些文件由于不同的开发端会不一样，如果使用 git add . 将所有文件纳入 git 库中，那么会出现频繁的改动和 push，这样会引起开发上的不便。Git 可以很方便的帮助我们解决这个问题，那就是建立项目文件过滤规则。</p> 
<p></p> 
<p>Git 中提供两种过滤机制：</p> 
<p>1）全局过滤机制，即对所有的 Git 都适用；</p> 
<p>2）针对某个项目使用的过滤规则；</p> 
<p>常用的是第二种，在项目下创建 .gitignore 文件。</p> 
<p></p> 
<h2>创建 .gitignore</h2> 
<p></p> 
<p>windows：创建一个文件，文件名为：“.gitignore.”，注意前后都有一个点。保存之后系统会自动重命名为“.gitignore”</p> 
<p>linux：touch .gitignore</p> 
<p></p> 
<h2>配置语法</h2> 
<p></p> 
<blockquote> 
 <p>以斜杠 “<span style="color:#fe2c24;"><strong>/</strong></span>” 开头表示跟目录，放在末尾表示跟目录以及子目录下的所有该文件夹；</p> 
</blockquote> 
<blockquote> 
 <p>以星号 “<span style="color:#fe2c24;"><strong>*</strong></span>” 通配多个字符；</p> 
</blockquote> 
<blockquote> 
 <p>以问号 “<span style="color:#fe2c24;"><strong>?</strong></span>” 通配单个字符；</p> 
</blockquote> 
<blockquote> 
 <p>以方括号 “<span style="color:#fe2c24;"><strong>[]</strong></span>” 包含单个字符的匹配列表；</p> 
</blockquote> 
<blockquote> 
 <p>以叹号 “<span style="color:#fe2c24;"><strong>!</strong></span>” 表示不忽略(跟踪)匹配到的文件或目录；</p> 
</blockquote> 
<p>　　</p> 
<p>　　此外，Git 对于 .ignore 配置文件是按行从上到下进行规则匹配的，意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效；</p> 
<p></p> 
<h2>示例</h2> 
<p></p> 
<blockquote> 
 <p>fd1/*</p> 
</blockquote> 
<p>说明：忽略目录 fd1 下的全部内容；注意，不管是根目录下的 /fd1/ 目录，还是某个子目录 /child/fd1/ 目录，都会被忽略</p> 
<p></p> 
<blockquote> 
 <p>/fd1/*</p> 
</blockquote> 
<p>说明：忽略根目录下的 /fd1/ 目录的全部内容</p> 
<p></p> 
<blockquote> 
 <p>/mtk/do.c</p> 
</blockquote> 
<p>说明：过滤某个具体文件</p> 
<p></p> 
<blockquote> 
 <p>/*</p> 
 <p>!.gitignore</p> 
 <p>!/fw/bin/</p> 
 <p>!/fw/sf/</p> 
</blockquote> 
<p>说明：忽略全部内容，但是不忽略 .gitignore 文件、根目录下的 /fw/bin/ 和 /fw/sf/ 目录</p> 
<p></p> 
<p></p> 
<h3>方式一</h3> 
<p>首先要强调一点，这个文件的完整文件名就是 “.gitignore”，注意最前面有个 “.”。这样没有扩展名的文件在 Windows 下不太好创建，这里给出创建方法：</p> 
<p>创建一个文件，文件名为：“<span style="color:#fe2c24;"><strong>.gitignore.</strong></span>”，注意前后都有一个点。保存之后系统会自动重命名为“.gitignore”。</p> 
<p>一般来说每个 Git 项目中都需要一个 “.gitignore” 文件，这个文件的作用就是告诉 Git 哪些文件不需要添加到版本管理中。</p> 
<p>实际项目中，很多文件都是不需要版本管理的，比如 Python 的 .pyc 文件和一些包含密码的配置文件等等。</p> 
<p>这个文件的内容是一些规则，Git 会根据这些规则来判断是否将文件添加到版本控制中。</p> 
<p>下面我们看看常用的规则：</p> 
<ul><li>/mtk/ 过滤整个文件夹</li><li>*.zip 过滤所有.zip文件</li><li>/mtk/do.c 过滤某个具体文件</li></ul> 
<p>很简单吧，被过滤掉的文件就不会出现在你的GitHub库中了，当然本地库中还有，只是push的时候不会上传。</p> 
<p>需要注意的是，gitignore 还可以指定要将哪些文件添加到版本管理中：</p> 
<ul><li>!*.zip</li><li>!/mtk/one.txt</li></ul> 
<p>唯一的区别就是规则开头多了一个感叹号，Git 会将满足这类规则的文件添加到版本管理中。</p> 
<p>为什么要有两种规则呢？想象一个场景：我们只需要管理/mtk/目录中的one.txt文件，这个目录中的其他文件都不需要管理。那么我们就需要使用：</p> 
<ul><li>/mtk/</li><li>!/mtk/one.txt</li></ul> 
<p>假设我们只有过滤规则没有添加规则，那么我们就需要把/mtk/目录下除了one.txt以外的所有文件都写出来！</p> 
<p>最后需要强调的一点是，如果你不慎在创建.gitignore文件之前就push了项目，那么即使你在.gitignore文件中写入新的过滤规则，这些规则也不会起作用，Git仍然会对所有文件进行版本管理。</p> 
<p>简单来说，出现这种问题的原因就是Git已经开始管理这些文件了，所以你无法再通过过滤规则过滤它们。</p> 
<p>所以大家一定要养成在项目开始就创建 .gitignore 文件的习惯，否则一旦 push，处理起来会非常麻烦。</p> 
<p></p> 
<h3>方式二</h3> 
<p></p> 
<p>就是新建 .gitignore 然后再里面声明要忽略的文件夹或者文件就可以了，不过麻烦又来了，因为是点开头，没有文件名，没办法直接在 windows 目录下直接创建，必须通过右键 Git Bash，按照linux 的方式来新建 .gitignore 文件。具体步骤如下：</p> 
<p></p> 
<p>1. 在需要创建 .gitignore 文件的文件夹, 右键选择 Git Bash 进入命令行，进入项目所在目录。</p> 
<p></p> 
<p>2. 输入 touch .gitignore 在文件夹就生成了一个“.gitignore”文件。</p> 
<p></p> 
<p>3.然后用编辑器打开这个文件进行编辑就行了。如果你很牛，熟悉linux下的vi编辑的命令，也可以用命令来声明规则。</p> 
<p></p> 
<p>4.然后就写规则来操作要忽略的文件了。.gitignore文件过滤有两种模式，开放模式和保守模式</p> 
<p></p> 
<p>4.1.开放模式负责设置过滤哪些文件和文件夹</p> 
<p></p> 
<p>过滤文件夹设置：</p> 
<p>/mtk/ 表示过滤这个文件夹</p> 
<p></p> 
<p>过滤文件设置</p> 
<p>指定过滤某种类型的文件：</p> 
<p>*.zip</p> 
<p>*.rar</p> 
<p>*.via</p> 
<p>*.tmp</p> 
<p>*.err</p> 
<p></p> 
<p>指定过滤某个文件：</p> 
<p>/mtk/do.c</p> 
<p>/mtk/if.h</p> 
<p></p> 
<p>4.2.保守模式负责设置哪些文件不被过滤，也就是哪些文件要被跟踪。</p> 
<p></p> 
<p>跟踪某个文件夹</p> 
<p></p> 
<p>!/plutommi/mmi</p> 
<p></p> 
<p>跟踪某类文件</p> 
<p></p> 
<p>!*.c</p> 
<p>!*.h</p> 
<p></p> 
<p>跟踪某个指定文件</p> 
<p></p> 
<p>!/plutommi/mmi/mmi_features.h</p> 
<p></p> 
<p>4.3.配置.gitignore 的简易原则</p> 
<p></p> 
<p>采用共享模式与保守模式结合配置的办法。</p> 
<p></p> 
<p>eg：一个文件夹下有很多文件夹和文件，而我只想跟踪其中的一个文件，这样设置就可以满足这种情况，先用共享模式把整个目录都设置为不跟踪，然后再用保守模式把这个文件夹中想要跟踪的文件设置为被跟踪，配置很简单，就可以跟踪想要跟踪的文件。</p> 
<p></p> 
<p></p> 
<ul><li>所有空行或者以注释符号 ＃ 开头的行都会被 Git 忽略。</li><li>可以使用标准的 glob 模式匹配。</li><li>匹配模式最后跟反斜杠（/）说明要忽略的是目录。</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。</li></ul> 
<p>      所谓的 glob 模式是指 shell 所使用的、简化了的正则表达式。星号（*）匹配零个或多个任意字符；[abc] 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。</p> 
<p></p> 
<p>我们再看一个 .gitignore 文件的例子： </p> 
<p># 忽略所有 .a 结尾的文件</p> 
<p>*.a</p> 
<p># 但 lib.a 除外</p> 
<p>!lib.a</p> 
<p># 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</p> 
<p>/TODO</p> 
<p># 忽略 build/ 目录下的所有文件</p> 
<p>build/</p> 
<p># 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</p> 
<p>doc/*.txt</p> 
<p>其他信息可以直接 man gitignore 查看。 </p> 
<p></p> 
<h2>常用 .gitignore 文件</h2> 
<h3>C#</h3> 
<pre><code>!/DLLs/

*.exe

*.exp

*.ilk

*.lib

*.ncb

*.log

*.pdb

*.vcproj.*.user

*.suo

._*

[Dd]ebug

[Rr]elease

obj/

[Bb]in

!packages/build/

Bak/

packages/

[Rr]elease/

Key/

!NuGet.exe</code></pre> 
<p></p> 
<h3>C</h3> 
<pre><code># Prerequisites

*.d


# Object files

*.o

*.ko

*.obj

*.elf


# Linker output

*.ilk

*.map

*.exp


# Precompiled Headers

*.gch

*.pch


# Libraries

*.lib

*.a

*.la

*.lo


# Shared objects (inc. Windows DLLs)

*.dll

*.so

*.so.*

*.dylib


# Executables

*.exe

*.out

*.app

*.i*86

*.x86_64

*.hex


# Debug files

*.dSYM/

*.su

*.idb

*.pdb


# Kernel Module Compile Results

*.mod*

*.cmd

.tmp_versions/

modules.order

Module.symvers

Mkfile.old

dkms.conf


Debug/

Release/

ipch/


*.pdb

*.log

*.ilk

*.db

*.opendb</code></pre> 
<p></p> 
<h3>C++</h3> 
<pre><code># Prerequisites

*.d


# Compiled Object files

*.slo

*.lo

*.o

*.obj


# Precompiled Headers

*.gch

*.pch


# Compiled Dynamic libraries

*.so

*.dylib

*.dll


# Fortran module files

*.mod

*.smod


# Compiled Static libraries

*.lai

*.la

*.a

*.lib


# Executables

*.exe

*.out

*.app


Debug/

Release/

ipch/


*.pdb

*.log

*.ilk

*.db

*.opendb</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1d46d4fa1fcd44832d5f07832b8d2190/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">[tf1] 保存和加载参数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/09fc80dd3d802835fc78474d0718672f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">用python时间格式，计算出它的年月日</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>