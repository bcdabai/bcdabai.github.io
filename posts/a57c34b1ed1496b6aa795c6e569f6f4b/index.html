<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JAVA面向对象——方法重写与多态 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JAVA面向对象——方法重写与多态" />
<meta property="og:description" content=" 1.方法重写
什么是方法重写（overriding）：
子类根据需求对从父类继承的方法进行重新编写；重写时，可以用super.方法的方式来保留父类的方法；构造方法不能被重写 。 方法重写规则：
方法名相同 参数列表相同；返回值类型相同或者是其子类；访问权限不能严于父类；父类的静态方法不能被子类覆盖为非静态方法,父类的非静态方法不能被子类覆盖为静态方法；子类可以定义与父类同名的静态方法，以便在子类中隐藏父类的静态方法(注：静态方法中无法使用super)；父类的私有方法不能被子类覆盖；不能抛出比父类方法更多的异常。 2. 方法重写vs方法重载：
比较项
位置
方法名
参数表
返回值
访问修饰符
方法重写
子类
相同
相同
相同或是其子类
不能比父类更严格
方法重载
同类
相同
不相同
无关
无关
3.Object类
Object类是所有类的父类
Object类被子类经常重写的方法：
方法
说明
toString()
返回当前对象本身的有关信息，按字符串对象返回
equals()
比较两个对象是否是同一个对象，是则返回true
hashCode()
返回该对象的哈希代码值
getClass()
获取当前对象所属的类信息，返回Class对象
4.多态
什么是多态：
同一个引用类型，使用不同的实例而执行不同操作。 使用多态的步骤：
创建父类，依据需要编写一个方法（由于这个方法一定会被重写，所以这个方法的方法体不需要有具体的实现，可以通过把这个方法和父类定义为抽象方法和抽象类让方法在逻辑上就不存在方法体）；创建子类，重写父类中的父类；创建实现功能的类，在此类中创建调用之前被多次重写的方法的方法，这个方法的参数列表为（父类引用数据类型 对象名）的形式；最后创建测试类，创建以父类为引用、子类为对象的对象，再创建实现功能类的对象，调用实现功能类的对象中的方法，括号中填入父类为引用、子类为对象的对象名。 实现和使用多态的主要方式：
使用父类作为方法的形参 ； 使用父类作为方法的返回值。 5.向上转型&amp;向下转型
向上转型的形式：
&lt;父类型&gt; &lt;引用变量名&gt; = new &lt;子类型&gt;();
向上转型的注意点：
此时通过父类引用变量调用的方法是子类覆盖或继承父类的方法，不是父类的方法；此时通过父类引用变量无法调用子类特有的方法。 向下转型的形式：
&lt;子类型&gt; &lt;引用变量名&gt; = (&lt;子类型&gt; )&lt;父类型的引用变量&gt;; 向下转型的注意点：
在向下转型的过程中，如果没有转换为真实子类类型，会出现类型转换异常。 " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/a57c34b1ed1496b6aa795c6e569f6f4b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-08-15T21:44:52+08:00" />
<meta property="article:modified_time" content="2021-08-15T21:44:52+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JAVA面向对象——方法重写与多态</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>1.方法重写</p> 
<p>什么是方法重写（overriding）：</p> 
<ul><li>子类根据需求对从父类继承的方法进行重新编写；</li><li>重写时，可以用super.方法的方式来保留父类的方法；</li><li>构造方法不能被重写 。</li></ul> 
<p>方法重写规则：</p> 
<ul><li>方法名相同 参数列表相同；</li><li>返回值类型相同或者是其子类；</li><li>访问权限不能严于父类；</li><li>父类的静态方法不能被子类覆盖为非静态方法,父类的非静态方法不能被子类覆盖为静态方法；</li><li>子类可以定义与父类同名的静态方法，以便在子类中隐藏父类的静态方法(注：静态方法中无法使用super)；</li><li>父类的私有方法不能被子类覆盖；</li><li>不能抛出比父类方法更多的异常。</li></ul> 
<p>2. 方法重写vs方法重载：</p> 
<table border="0" cellpadding="0" cellspacing="0" style="width:629px;"><tbody><tr><td> <p style="text-align:center;">   比较项</p> </td><td> <p style="text-align:center;">位置</p> </td><td> <p style="text-align:center;">方法名</p> </td><td> <p style="text-align:center;">参数表</p> </td><td> <p style="text-align:center;">返回值</p> </td><td> <p style="text-align:center;">访问修饰符</p> </td></tr><tr><td> <p style="text-align:center;">方法重写</p> </td><td> <p style="text-align:center;">子类</p> </td><td> <p style="text-align:center;">相同</p> </td><td> <p style="text-align:center;">相同</p> </td><td> <p style="text-align:center;">相同或是其子类</p> </td><td> <p style="text-align:center;">不能比父类更严格</p> </td></tr><tr><td> <p style="text-align:center;">方法重载</p> </td><td> <p style="text-align:center;">同类</p> </td><td> <p style="text-align:center;">相同</p> </td><td> <p style="text-align:center;">不相同</p> </td><td> <p style="text-align:center;">无关</p> </td><td> <p style="text-align:center;">无关</p> </td></tr></tbody></table> 
<p> 3.Object类</p> 
<p>Object类是所有类的父类</p> 
<p>Object类被子类经常重写的方法：</p> 
<table border="0" cellpadding="0" cellspacing="0" style="width:612px;"><tbody><tr><td> <p style="text-align:center;">方法</p> </td><td> <p style="text-align:center;">说明</p> </td></tr><tr><td> <p>toString()</p> </td><td> <p>返回当前对象本身的有关信息，按字符串对象返回</p> </td></tr><tr><td> <p>equals()</p> </td><td> <p>比较两个对象是否是同一个对象，是则返回true</p> </td></tr><tr><td> <p>hashCode()</p> </td><td> <p>返回该对象的哈希代码值</p> </td></tr><tr><td> <p>getClass()</p> </td><td> <p>获取当前对象所属的类信息，返回Class对象</p> </td></tr></tbody></table> 
<p>4.多态</p> 
<p>什么是多态：</p> 
<p>同一个引用类型，使用不同的实例而执行不同操作。 </p> 
<p>使用多态的步骤：</p> 
<ul><li>创建父类，依据需要编写一个方法（由于这个方法一定会被重写，所以这个方法的方法体不需要有具体的实现，可以通过把这个方法和父类定义为抽象方法和抽象类让方法在逻辑上就不存在方法体）；</li><li>创建子类，重写父类中的父类；</li><li>创建实现功能的类，在此类中创建调用之前被多次重写的方法的方法，这个方法的参数列表为（父类引用数据类型  对象名）的形式；</li><li>最后创建测试类，创建以父类为引用、子类为对象的对象，再创建实现功能类的对象，调用实现功能类的对象中的方法，括号中填入父类为引用、子类为对象的对象名。</li></ul> 
<p>实现和使用多态的主要方式：</p> 
<ul><li>使用父类作为方法的形参 ；</li><li> 使用父类作为方法的返回值。</li></ul> 
<p>5.向上转型&amp;向下转型</p> 
<p>向上转型的形式：</p> 
<p> &lt;父类型&gt; &lt;引用变量名&gt; = new &lt;子类型&gt;();</p> 
<p>向上转型的注意点：</p> 
<ul><li>此时通过父类引用变量调用的方法是子类覆盖或继承父类的方法，不是父类的方法；</li><li>此时通过父类引用变量无法调用子类特有的方法。</li></ul> 
<p> 向下转型的形式：</p> 
<p>&lt;子类型&gt; &lt;引用变量名&gt; = (&lt;子类型&gt; )&lt;父类型的引用变量&gt;; </p> 
<p> 向下转型的注意点：</p> 
<ul><li>在向下转型的过程中，如果没有转换为真实子类类型，会出现类型转换异常。 </li></ul> 
<p> </p> 
<p> </p> 
<p> </p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6d4c8cc36eef01dd476c9d92128f02ec/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">获取DOM对象的五种方式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d4707882d097ee951af08a25d5e16d32/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">CUDN和CUDNN安装</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>