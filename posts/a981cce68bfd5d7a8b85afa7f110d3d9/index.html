<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>一文带你彻底理解高性能无锁队列 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="一文带你彻底理解高性能无锁队列" />
<meta property="og:description" content="一文带你彻底理解高性能无锁队列 目前，大部分软件设计都在追求高性能，快速处理，耗时低，仿佛已经是行业中必不可少的一部分。作为互联网从业人员，我们也必须适应时代的潮流，彻底掌握这种高性能编程。
问题引入：
一个生产者，多个消费者的队列，如果是你，你回怎么设计？ 想必拿到这个问题，更多的人脑海中已经浮现了一把锁；我也是的，那我们就从浅入深的来看看高性能的无锁队列是怎么一步一步的演化开来的。
1、低效的实现队列 编写多线程的时候，往往会发生资源竞争的现象，导致我们不得不加锁去保护变量，但在这个的同时也对性能造成了一定的损耗。
设计方案：（C&#43;&#43;）
如图所示：
这种设计方式的话，我们是不可避免加锁操作的，因为其本身就不是线程安全的。
流程：
生产者放入队列中时，加锁，数据输入后完成加锁操作；然后剩余线程进行争锁操作，进行取队列数据操作；
简单实现：
template&lt;class T&gt; class SimpleQueue { public: SimpleQueue() { } ~SimpleQueue() { } void Push(T val) { _mutex.lock(); _q.push(move(val)); _mutex.unlock(); } T Get() { _mutex.lock(); if (_q.empty()) { _mutex.unlock(); return 0; } T val = _q.front(); _q.pop(); _mutex.unlock(); return val; } private: mutex _mutex; queue&lt;T&gt;_q; }; 这个就是比较简单，同事性能较差的一种方案；
既然我们提到了高性能，那么这种操作是不不符合我们需求的，那还有什么更好的方案提供跟高的性能吗？
很显然的一个操作：去锁化-----也就是常说的无锁队列
2、无锁队列 其实有锁和无锁就是我们平时所说的乐观锁和悲观锁：
加锁是一种悲观的策略，它总是认为每次访问共享资源的时候，总会发生冲突，所以宁愿牺牲性能（时间）来保证数据安全。 无锁是一种乐观的策略，它假设线程访问共享资源不会发生冲突，所以不需要加锁，因此线程将不断执行，不需要停止。一旦碰到冲突，就重试当前操作直到没有冲突为止。 无锁的策略使用一种叫做比较交换的技术（CAS Compare And Swap）来鉴别线程冲突，一旦检测到冲突产生，就重试当前操作直到没有冲突为止。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/a981cce68bfd5d7a8b85afa7f110d3d9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-04-11T16:52:10+08:00" />
<meta property="article:modified_time" content="2021-04-11T16:52:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">一文带你彻底理解高性能无锁队列</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>一文带你彻底理解高性能无锁队列</h3> 
<p>目前，大部分软件设计都在追求高性能，快速处理，耗时低，仿佛已经是行业中必不可少的一部分。作为互联网从业人员，我们也必须适应时代的潮流，彻底掌握这种高性能编程。</p> 
<hr> 
<p>问题引入：</p> 
<pre><code>一个生产者，多个消费者的队列，如果是你，你回怎么设计？
</code></pre> 
<p>想必拿到这个问题，更多的人脑海中已经浮现了一把锁；我也是的，那我们就从浅入深的来看看高性能的无锁队列是怎么一步一步的演化开来的。</p> 
<hr> 
<h5><a id="1_16"></a>1、低效的实现队列</h5> 
<p>编写多线程的时候，往往会发生资源竞争的现象，导致我们不得不加锁去保护变量，但在这个的同时也对性能造成了一定的损耗。</p> 
<p>设计方案：（C++）</p> 
<p>如图所示：</p> 
<p><img src="https://images2.imgbox.com/9e/64/lotKOwqt_o.png" alt="在这里插入图片描述"></p> 
<p>这种设计方式的话，我们是不可避免加锁操作的，因为其本身就不是线程安全的。</p> 
<p>流程：</p> 
<p>生产者放入队列中时，加锁，数据输入后完成加锁操作；然后剩余线程进行争锁操作，进行取队列数据操作；</p> 
<p>简单实现：</p> 
<pre><code class="prism language-c++">template&lt;class T&gt;
class SimpleQueue
{
public:
	SimpleQueue() 
	{
	}
	~SimpleQueue()
	{
	}

	void Push(T val)
	{
		_mutex.lock();
		_q.push(move(val));
		_mutex.unlock();
	}

	T Get()
	{
		_mutex.lock();
		if (_q.empty())
		{
			_mutex.unlock();
			return 0;
		}
		T val = _q.front();
		_q.pop();
		_mutex.unlock();
		return val;
	}

private:
	mutex _mutex;
	queue&lt;T&gt;_q;
};
</code></pre> 
<p>这个就是比较简单，同事性能较差的一种方案；</p> 
<p>既然我们提到了高性能，那么这种操作是不不符合我们需求的，那还有什么更好的方案提供跟高的性能吗？</p> 
<p>很显然的一个操作：去锁化-----也就是常说的无锁队列</p> 
<hr> 
<h5><a id="2_82"></a>2、无锁队列</h5> 
<p>其实有锁和无锁就是我们平时所说的乐观锁和悲观锁：</p> 
<pre><code>   加锁是一种悲观的策略，它总是认为每次访问共享资源的时候，总会发生冲突，所以宁愿牺牲性能（时间）来保证数据安全。

   无锁是一种乐观的策略，它假设线程访问共享资源不会发生冲突，所以不需要加锁，因此线程将不断执行，不需要停止。一旦碰到冲突，就重试当前操作直到没有冲突为止。
</code></pre> 
<p>无锁的策略使用一种叫做比较交换的技术（CAS Compare And Swap）来鉴别线程冲突，一旦检测到冲突产生，就重试当前操作直到没有冲突为止。</p> 
<p>CAS是系统原语，CAS操作是一条CPU的原子指令，所以不会有线程安全问题。</p> 
<p><em>CAS</em> 的伪码:</p> 
<pre><code class="prism language-c++">template &lt;class T&gt;
bool CAS(T* addr, T expected, T value) 
{
   if (*addr == expected) 
   {
      *addr = value;
      return true;
   }
   return false;
} 
</code></pre> 
<p><em>CAS</em> 将 <em>expected</em> 与一个内存地址进行比较，如果比较成功，就将内存内容替换为 <em>new</em> 。当前大多数机器都在硬件级实现了这个操作，在 <em>Inter</em> 处理器上这个操作是 <em>CMPXCHG</em> ，因而 <em>CAS</em> 是一个最基础的原子操作。</p> 
<p>GCC4.1+版本中支持CAS的原子操作,API接口如下：</p> 
<pre><code class="prism language-C++">**bool** __sync_bool_compare_and_swap (type *ptr, type oldval type newval, ...)

type __sync_val_compare_and_swap (type *ptr, type oldval type newval, ...)
</code></pre> 
<pre><code class="prism language-c++">#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;queue&gt;
#include &lt;functional&gt;
#include &lt;stack&gt;
#include &lt;iostream&gt;
#include &lt;unistd.h&gt;
#include &lt;thread&gt;
#include &lt;list&gt;


using namespace std;

/*
*   说明：基于CAS封装的无锁List。
*/
template &lt;typename T&gt;
class JzLockfreeList
{
private:
	std::list&lt;T&gt; list;

private:
	int mutex;
	int lock;
	int unlock;
public:
	JzLockfreeList() :mutex(0), lock(0), unlock(1) {};
	~JzLockfreeList() {};

	void Lock()
	{
		while (!__sync_bool_compare_and_swap(&amp;mutex, lock, 1))
		{
			usleep(100);
		}
	}

	void Unlock()
	{
		__sync_bool_compare_and_swap(&amp;mutex, unlock, 0);
	}

	void Push(T data)
	{
		Lock();
		list.push_back(data);
		Unlock();
	}

	T Front()
	{
		Lock();
		T data = list.front();
		Unlock();

		return data;
	}

	void PopFront()
	{
		Lock();
		list.pop_front();
		Unlock();
	}

	bool IsEmpty()
	{
		Lock();
		if (list.empty())
		{
			Unlock();
			return true;
		}
		else
		{
			Unlock();
			return false;
		}
	}

	bool Find(T data)
	{
		typename std::list&lt;T&gt;::iterator it;

		Lock();
		for (it = list.begin(); it != list.end(); ++it)
		{
			if (*it == data)
			{
				Unlock();
				return true;
			}
		}

		Unlock();
		return false;
	}
};

JzLockfreeList&lt;int&gt; LF;

thread_local int num = 1;
//生产者
void Producer()
{
    while(true)
    {
        num++;
        cout&lt;&lt;"num push:"&lt;&lt;num&lt;&lt;endl;
        LF.Push(num);
        sleep(2);
    }
}

//消费者
void Customer()
{
    while(true)
    {
        if (!LF.IsEmpty())
        {
            cout &lt;&lt;"num get " &lt;&lt;LF.Front() &lt;&lt;endl;
            LF.PopFront();
        }
        sleep(1);
    }
}



int main()
{
    thread t1(Producer);
    thread t2(Customer);
    thread t3(Customer);
    t1.join();
    t2.join();
    t3.join();
	return 0;
}
</code></pre> 
<p>在C++11 中出现了CAS的用法，也为我们提供了API；</p> 
<pre><code class="prism language-c++">/*
* @brief：compare &amp; swap(CAS)。如果等于expect则swap，否则就返回--是否交换成功, 注意expect如果不相等，会把当前值写入到expected里面。
* 相比于strong，weak可能会出现[spurious wakeup](&lt;http://en.wikipedia.org/wiki/Spurious_wakeup&gt;).
* @param          若x等于expect,则设置为desired 返回true，
*                 否则最新值写入expect，返回false
*/
class atomic {
bool compare_exchange_strong(T&amp; expect /*用来比较的值*/, T desired/*用来设置的值*/)
bool compare_exchange_weak(T&amp; expect, T desired)
}
</code></pre> 
<hr> 
<p>其实在CAS中，还有一种异常产生，也就是常说的<code>ABA</code>的现象。所谓ABA现象就是当前现象期望值是A,某个线程将A改为B，另外线程将B改为A，导致当前线程误以为还是原来的值，然后操作就会导致一些异常出现。</p> 
<p>这里我们可以借用数据库乐观锁的方式，维护一个全局的版本号或者是标志，每次修改的时候需要期望值和内存值相等并且标识也没有发生改变的时候采取更新值。</p> 
<hr> 
<p>无锁（CAS）本身编程就不是很友好，如果没有彻底掌握，最好还是使用锁去编写。</p> 
<p>ompare_exchange_weak(T&amp; expect, T desired)<br> }</p> 
<pre><code>
****

其实在CAS中，还有一种异常产生，也就是常说的`ABA`的现象。所谓ABA现象就是当前现象期望值是A,某个线程将A改为B，另外线程将B改为A，导致当前线程误以为还是原来的值，然后操作就会导致一些异常出现。

这里我们可以借用数据库乐观锁的方式，维护一个全局的版本号或者是标志，每次修改的时候需要期望值和内存值相等并且标识也没有发生改变的时候采取更新值。

****

无锁（CAS）本身编程就不是很友好，如果没有彻底掌握，最好还是使用锁去编写。

CAS 更多的是一种思想，也是实现高性能编程的一种途径，目前已经有一些开源级别的无锁库可以提供我们使用，也许这些才是我们最好的选择。
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4784932b5d1ea7a4690ad46a0a8a6a8a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">leetcode 264. 丑数 II</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/922e2e9ae74e8fcc004f466cecd5880d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">php使用keras模型,浅谈keras 模型用于预测时的注意事项</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>