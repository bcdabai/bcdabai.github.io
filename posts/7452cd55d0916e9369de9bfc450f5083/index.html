<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python 算法高级篇：最小生成树算法的优化与应用 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Python 算法高级篇：最小生成树算法的优化与应用" />
<meta property="og:description" content="Python 算法高级篇：最小生成树算法的优化与应用 引言 1. 最小生成树问题简介2. Prim 算法3. Kruskal 算法4. 优化与比较5. 案例应用：通信网络设计6. 总结 引言 最小生成树（ Minimum Spanning Tree ， MST ）是图论中的一个重要问题，涉及到在一个加权连通图中找到一棵包含所有节点且边的权重之和最小的树。最小生成树问题在许多实际应用中都有重要作用，例如通信网络设计、电路板布线、城市规划等。在本篇博客中，我们将深入探讨最小生成树算法的优化和应用，主要关注两个著名的算法： Prim 算法和 Kruskal 算法。
😃😄 ❤️ ❤️ ❤️
1. 最小生成树问题简介 最小生成树问题是一个图论问题，通常描述为以下几个步骤：
给定一个带权重的连通图，其中节点表示地点，边表示路径，并带有权重表示路径的代价或距离。找到一个子图，这个子图是原图的一颗树，包含了所有的节点。保证这颗树的边的权重之和最小。 最小生成树问题的解可以有多个，但它们都具有相同的特点：包含了所有节点，但是边的权重之和最小。 Prim 算法和 Kruskal 算法是两个用于解决这个问题的经典算法。
2. Prim 算法 Prim 算法以一个起始节点开始，然后逐步将与当前最小生成树集合相连的最短边加入到该集合中。它维护两个集合：一个是已包含在最小生成树中的节点集合，另一个是未包含在其中的节点集合。在每一步中，算法从未包含集合中选择一个节点，并找到连接已包含节点集合和未包含节点集合的最短边。这个边会被添加到最小生成树中，将对应的节点移到已包含集合中。这个过程一直进行，直到已包含集合包含了所有节点为止。
下面是 Prim 算法的 Python 实现：
import heapq def prim(graph): min_spanning_tree = [] start_node = list(graph.keys())[0] visited = set([start_node]) edges = [ (cost, start_node, next_node) for next_node, cost in graph[start_node]." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/7452cd55d0916e9369de9bfc450f5083/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-01T08:30:00+08:00" />
<meta property="article:modified_time" content="2023-11-01T08:30:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python 算法高级篇：最小生成树算法的优化与应用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>Python 算法高级篇：最小生成树算法的优化与应用</h4> 
 <ul><li><a href="#font_size2font_2" rel="nofollow"><font size="2">引言</font></a></li><li><a href="#font_size2_1_font_7" rel="nofollow"><font size="2"> 1. 最小生成树问题简介</font></a></li><li><a href="#font_size22__Prim_font_17" rel="nofollow"><font size="2">2. Prim 算法</font></a></li><li><a href="#font_size23__Kruskal_font_49" rel="nofollow"><font size="2">3. Kruskal 算法</font></a></li><li><a href="#font_size24_font_81" rel="nofollow"><font size="2">4. 优化与比较</font></a></li><li><a href="#font_size25_font_87" rel="nofollow"><font size="2">5. 案例应用：通信网络设计</font></a></li><li><a href="#font_size26_font_95" rel="nofollow"><font size="2">6. 总结</font></a></li></ul> 
</div> 
<p></p> 
<h2><a id="font_size2font_2"></a><font size="2">引言</font></h2> 
<p><font size="2">最小生成树（ <strong>Minimum</strong> <strong>Spanning</strong> <strong>Tree</strong> ， <strong>MST</strong> ）是图论中的一个重要问题，涉及到在一个加权连通图中找到一棵包含所有节点且边的权重之和最小的树。最小生成树问题在许多实际应用中都有重要作用，例如通信网络设计、电路板布线、城市规划等。在本篇博客中，我们将深入探讨最小生成树算法的优化和应用，主要关注两个著名的算法： <strong>Prim</strong> 算法和 <strong>Kruskal</strong> 算法。</font></p> 
<p>😃😄 ❤️ ❤️ ❤️</p> 
<h2><a id="font_size2_1_font_7"></a><font size="2"> 1. 最小生成树问题简介</font></h2> 
<p><font size="2">最小生成树问题是一个图论问题，通常描述为以下几个步骤：</font></p> 
<ul><li><font size="2">给定一个带权重的连通图，其中节点表示地点，边表示路径，并带有权重表示路径的代价或距离。</font></li><li><font size="2">找到一个子图，这个子图是原图的一颗树，包含了所有的节点。</font></li><li><font size="2">保证这颗树的边的权重之和最小。</font></li></ul> 
<p><font size="2">最小生成树问题的解可以有多个，但它们都具有相同的特点：包含了所有节点，但是边的权重之和最小。 <strong>Prim</strong> 算法和 <strong>Kruskal</strong> 算法是两个用于解决这个问题的经典算法。</font></p> 
<h2><a id="font_size22__Prim_font_17"></a><font size="2">2. Prim 算法</font></h2> 
<p><font size="2"> <strong>Prim</strong> 算法以一个起始节点开始，然后逐步将与当前最小生成树集合相连的最短边加入到该集合中。它维护两个集合：一个是已包含在最小生成树中的节点集合，另一个是未包含在其中的节点集合。在每一步中，算法从未包含集合中选择一个节点，并找到连接已包含节点集合和未包含节点集合的最短边。这个边会被添加到最小生成树中，将对应的节点移到已包含集合中。这个过程一直进行，直到已包含集合包含了所有节点为止。</font></p> 
<p><font size="2">下面是 <strong>Prim</strong> 算法的 <strong>Python</strong> 实现：</font></p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> heapq

<span class="token keyword">def</span> <span class="token function">prim</span><span class="token punctuation">(</span>graph<span class="token punctuation">)</span><span class="token punctuation">:</span>
    min_spanning_tree <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    start_node <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span>graph<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
    visited <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">[</span>start_node<span class="token punctuation">]</span><span class="token punctuation">)</span>
    edges <span class="token operator">=</span> <span class="token punctuation">[</span>
        <span class="token punctuation">(</span>cost<span class="token punctuation">,</span> start_node<span class="token punctuation">,</span> next_node<span class="token punctuation">)</span>
        <span class="token keyword">for</span> next_node<span class="token punctuation">,</span> cost <span class="token keyword">in</span> graph<span class="token punctuation">[</span>start_node<span class="token punctuation">]</span><span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">]</span>
    heapq<span class="token punctuation">.</span>heapify<span class="token punctuation">(</span>edges<span class="token punctuation">)</span>

    <span class="token keyword">while</span> edges<span class="token punctuation">:</span>
        cost<span class="token punctuation">,</span> start<span class="token punctuation">,</span> next_node <span class="token operator">=</span> heapq<span class="token punctuation">.</span>heappop<span class="token punctuation">(</span>edges<span class="token punctuation">)</span>
        <span class="token keyword">if</span> next_node <span class="token keyword">not</span> <span class="token keyword">in</span> visited<span class="token punctuation">:</span>
            visited<span class="token punctuation">.</span>add<span class="token punctuation">(</span>next_node<span class="token punctuation">)</span>
            min_spanning_tree<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> next_node<span class="token punctuation">,</span> cost<span class="token punctuation">)</span><span class="token punctuation">)</span>

            <span class="token keyword">for</span> neighbor<span class="token punctuation">,</span> cost <span class="token keyword">in</span> graph<span class="token punctuation">[</span>next_node<span class="token punctuation">]</span><span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> neighbor <span class="token keyword">not</span> <span class="token keyword">in</span> visited<span class="token punctuation">:</span>
                    heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>edges<span class="token punctuation">,</span> <span class="token punctuation">(</span>cost<span class="token punctuation">,</span> next_node<span class="token punctuation">,</span> neighbor<span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token keyword">return</span> min_spanning_tree
</code></pre> 
<h2><a id="font_size23__Kruskal_font_49"></a><font size="2">3. Kruskal 算法</font></h2> 
<p><font size="2"> <strong>Kruskal</strong> 算法是另一种常用于解决最小生成树问题的算法。它从边的角度考虑问题，首先对所有边按照权重进行排序，然后从最小权重的边开始，逐渐构建最小生成树。在构建的过程中，它会检查每一条边，如果这条边连接了两个不在同一个连通分量中的节点，就将它加入到最小生成树中，同时将这两个连通分量合并。这个过程一直持续，直到最小生成树包含了所有的节点。</font></p> 
<p><font size="2">以下是 <strong>Kruskal</strong> 算法的 <strong>Python</strong> 实现：</font></p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">kruskal</span><span class="token punctuation">(</span>graph<span class="token punctuation">)</span><span class="token punctuation">:</span>
    min_spanning_tree <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    edges <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

    <span class="token keyword">for</span> node <span class="token keyword">in</span> graph<span class="token punctuation">:</span>
        <span class="token keyword">for</span> neighbor<span class="token punctuation">,</span> cost <span class="token keyword">in</span> graph<span class="token punctuation">[</span>node<span class="token punctuation">]</span><span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            edges<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>cost<span class="token punctuation">,</span> node<span class="token punctuation">,</span> neighbor<span class="token punctuation">)</span><span class="token punctuation">)</span>

    edges<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>

    parent <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>node<span class="token punctuation">:</span> node <span class="token keyword">for</span> node <span class="token keyword">in</span> graph<span class="token punctuation">}</span>

    <span class="token keyword">def</span> <span class="token function">find</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> parent<span class="token punctuation">[</span>node<span class="token punctuation">]</span> <span class="token operator">!=</span> node<span class="token punctuation">:</span>
            parent<span class="token punctuation">[</span>node<span class="token punctuation">]</span> <span class="token operator">=</span> find<span class="token punctuation">(</span>parent<span class="token punctuation">[</span>node<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> parent<span class="token punctuation">[</span>node<span class="token punctuation">]</span>

    <span class="token keyword">for</span> cost<span class="token punctuation">,</span> node1<span class="token punctuation">,</span> node2 <span class="token keyword">in</span> edges<span class="token punctuation">:</span>
        <span class="token keyword">if</span> find<span class="token punctuation">(</span>node1<span class="token punctuation">)</span> <span class="token operator">!=</span> find<span class="token punctuation">(</span>node2<span class="token punctuation">)</span><span class="token punctuation">:</span>
            min_spanning_tree<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>node1<span class="token punctuation">,</span> node2<span class="token punctuation">,</span> cost<span class="token punctuation">)</span><span class="token punctuation">)</span>
            parent<span class="token punctuation">[</span>find<span class="token punctuation">(</span>node1<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> find<span class="token punctuation">(</span>node2<span class="token punctuation">)</span>

    <span class="token keyword">return</span> min_spanning_tree
</code></pre> 
<h2><a id="font_size24_font_81"></a><font size="2">4. 优化与比较</font></h2> 
<p><font size="2"> <strong>Prim</strong> 算法和 <strong>Kruskal</strong> 算法是解决最小生成树问题的两种主要方法，它们在不同的场景中可能表现出不同的性能。通常情况下， <strong>Prim</strong> 算法在稠密图上效果更好，因为它以节点为中心，适合于连接较多节点的情况。而 <strong>Kruskal</strong> 算法在稀疏图上通常更快，因为它以边为中心，适合于连接较少节点但边比较多的情况。</font></p> 
<p><font size="2">可以根据实际情况选择合适的算法。在某些应用中，还可以进行算法的优化，例如使用堆（ <strong>heap</strong> ）数据结构来加速 <strong>Prim</strong> 算法。</font></p> 
<h2><a id="font_size25_font_87"></a><font size="2">5. 案例应用：通信网络设计</font></h2> 
<p><font size="2">假设我们是一家电信公司的工程师，需要为一座城市设计一个通信网络，以便将所有的建筑物都连接到网络中，并使得网络建设成本最低。这是一个最小生成树问题的实际应用。</font></p> 
<p><font size="2">我们可以将城市的建筑物看作图中的节点，将建筑物之间的距离或建设成本看作边的权重。通过运行 <strong>Prim</strong> 或 <strong>Kruskal</strong> 算法，我们可以找到一种最经济的方式来连接所有建筑物，从而使得通信网络的建设成本最小。</font></p> 
<p><font size="2">这是一个实际问题的抽象，最小生成树算法可以帮助我们解决这类问题，不仅在通信网络设计中有用，还在电路板布线、城市规划等众多领域中发挥着关键作用。</font></p> 
<h2><a id="font_size26_font_95"></a><font size="2">6. 总结</font></h2> 
<p><font size="2">最小生成树问题是图论中一个经典的优化问题，通常涉及在加权连通图中找到一棵树，以最小的总权重连接所有节点。 <strong>Prim</strong> 算法和 <strong>Kruskal</strong> 算法是解决这个问题的两种主要方法，它们各自在不同的场景中表现出色。</font></p> 
<p><font size="2">理解和掌握这两种算法以及它们的优化方法对于解决实际问题非常重要。最小生成树问题在通信网络设计、电路板布线、城市规划等领域都有广泛的应用。</font></p> 
<p><font size="2"><strong>[ 专栏推荐 ]</strong><br> <a href="https://blog.csdn.net/qq_38161040/category_12379687.html"> 😃 <font color="red">《<strong>Python</strong> 算法初阶：入门篇》</font>😄<br> ❤️【简介】：<font size="2">本课程是针对 <strong>Python</strong> 初学者设计的算法基础入门课程，涵盖算法概念、时间复杂度、空间复杂度等基础知识。通过实例演示线性搜索、二分搜索等算法，并介绍哈希表、深度优先搜索、广度优先搜索等搜索算法。此课程将为学员提供扎实的 <strong>Python</strong> 编程基础与算法入门，为解决实际问题打下坚实基础。</font><br> <img src="https://images2.imgbox.com/ae/a2/dnwXBAkV_o.png" alt="在这里插入图片描述"></a></font></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/242d45f0bad66b99d747a098b50bcc76/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">软考证书，彻底爆了！！</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/063f9c963867193e231278cd2aabac46/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python 算法高级篇：多阶段决策问题与状态转移方程的构建</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>