<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>浪花 - 根据标签搜索用户 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="浪花 - 根据标签搜索用户" />
<meta property="og:description" content="用户中心：集中提供用户的检索、操作、注册、登录、鉴权
此接口与用户关系紧密，在【用户中心】项目后端新增一个接口——根据标签搜索用户
AND：允许用户传入多个标签，多个标签都存在才能搜索出来OR：允许用户传入多个标签，有任何一个标签存在就能搜索出来 本文演示两种方式进行标签搜索：
使用 SQL 查询：通过 Mybatis-plus 的 like 方法实现标签信息 tags 的模糊匹配，优点是实现简单使用内存查询：优点是可以在代码中呈现，使用灵活 方式一：使用 SQL 查询 1. 使用 MybatisX 插件简化开发（在插件商店直接搜索 MybatisX 点击 install 进行插件的安装）
选择要操作的表，自动生成下列文件，提高开发效率
数据库表 - Java 实体类映射文件：Tag.java
针对 tag 表的数据库业务层操作：TagService.java 和 TagServiceImpl.java
针对 tag 表的数据库持久层操作：TagMapper.java
数据库操作映射 SQL（较复杂的 SQL 语句）文件：TagMapper.xml
2. 编写模糊查询匹配用户标签的业务代码
/** * 根据标签搜索用户 * @param tagNameList 用户的标签列表 * @return 匹配该标签列表的用户列表 */ public List&lt;User&gt; searchUsersByTags(List&lt;String&gt; tagNameList) { // 1. 判断参数是否为空 if (CollectionUtils.isEmpty(tagNameList)) { throw new BusinessException(ErrorCode.PARAMS_ERROR); } // 2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/42f2dc81005dbac1b77b29077a4f14ec/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-16T20:09:23+08:00" />
<meta property="article:modified_time" content="2024-01-16T20:09:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">浪花 - 根据标签搜索用户</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>用户中心：集中提供用户的检索、操作、注册、登录、鉴权</p> 
 <p>此接口与用户关系紧密，在【用户中心】项目后端新增一个接口——根据标签搜索用户</p> 
 <ul><li>AND：允许用户传入多个标签，多个标签都存在才能搜索出来</li><li>OR：允许用户传入多个标签，有任何一个标签存在就能搜索出来</li></ul> 
 <p>本文演示两种方式进行标签搜索：</p> 
 <ul><li>使用 SQL 查询：通过 Mybatis-plus 的 like 方法实现标签信息 tags 的模糊匹配，优点是实现简单</li><li>使用内存查询：优点是可以在代码中呈现，使用灵活</li></ul> 
</blockquote> 
<h2>方式一：使用 SQL 查询</h2> 
<p>1. 使用<strong> MybatisX 插件</strong>简化开发（在插件商店直接搜索 MybatisX 点击 install 进行插件的安装）</p> 
<ul><li> <p>选择要操作的表，自动生成下列文件，提高开发效率</p> 
  <ul><li> <p>数据库表 - Java 实体类映射文件：Tag.java</p> </li><li> <p>针对 tag 表的数据库业务层操作：TagService.java 和 TagServiceImpl.java</p> </li><li> <p>针对 tag 表的数据库持久层操作：TagMapper.java</p> </li><li> <p>数据库操作映射 SQL（较复杂的 SQL 语句）文件：TagMapper.xml</p> </li></ul></li></ul> 
<p class="img-center"><img alt="" height="412" src="https://images2.imgbox.com/b6/30/8sZVoLtJ_o.png" width="382"></p> 
<p>2. 编写模糊查询匹配用户标签的业务代码</p> 
<pre><code class="language-java">    /**
     * 根据标签搜索用户
     * @param tagNameList 用户的标签列表
     * @return 匹配该标签列表的用户列表
     */
    public List&lt;User&gt; searchUsersByTags(List&lt;String&gt; tagNameList) {
        // 1. 判断参数是否为空
        if (CollectionUtils.isEmpty(tagNameList)) {
            throw new BusinessException(ErrorCode.PARAMS_ERROR);
        }

        // 2. 构造查询器
        QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper();
        for (String tagName : tagNameList) {
            queryWrapper = queryWrapper.like("tags", tagName);
        }

        // 3. 根据标签列表查找用户
        List&lt;User&gt; userList = userMapper.selectList(queryWrapper);

        // 4. 返回脱敏后的用户列表
        return userList.stream().map(this::getSafetyUser).collect(Collectors.toList());
    }</code></pre> 
<p>3. 开启 Mybatis-plus 的 SQL 语句日志输出：在项目配置文件 application.yml 中添加下列配置信息</p> 
<pre><code class="language-XML">mybatis-plus:
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl #开启sql日志</code></pre> 
<p><img alt="" height="1018" src="https://images2.imgbox.com/1a/bd/LA8rUto0_o.png" width="1200"></p> 
<p> 4. Junit 单元测试</p> 
<pre><code class="language-java">@Test
public void testSearchUsersByTags() {
    List&lt;String&gt; tagNameList = new ArrayList&lt;&gt;();
    tagNameList.add("java");
    tagNameList.add("python");
    List&lt;User&gt; userList = userService.searchUsersByTags(tagNameList);
    Assertions.assertNotNull(userList);
}</code></pre> 
<p><img alt="" height="1018" src="https://images2.imgbox.com/68/6b/J8Ed9uXp_o.png" width="1200"></p> 
<p></p> 
<h2>方式二：使用内存查询</h2> 
<blockquote> 
 <p>使用 SQL 全量查询出所有用户，在内存中计算过滤符合条件的用户</p> 
</blockquote> 
<p>1. 先查询所有用户，遍历用户并取出用户的标签信息</p> 
<p>2. 在内存中判断 tags 是否包含所要求的标签</p> 
<ul><li>引入 Gson 依赖：将 tags 序列化为 Java 对象，使用 Set 集合接收</li><li>遍历要搜索的标签列表，判断用户是否拥有该标签</li></ul> 
<pre><code class="language-java">    /**
     * 根据标签搜索用户
     * @param tagNameList 用户的标签列表
     * @return 匹配该标签列表的用户列表
     */
    public List&lt;User&gt; searchUsersByTags(List&lt;String&gt; tagNameList) {
        // 1. 判断参数是否为空
        if (CollectionUtils.isEmpty(tagNameList)) {
            throw new BusinessException(ErrorCode.PARAMS_ERROR);
        }


        /**
         * 方式二：使用内存查询
         */
        // 1. 查询所有用户
        QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper();
        List&lt;User&gt; userList = userMapper.selectList(queryWrapper);

        Gson gson = new Gson();
        return userList.stream().filter(user -&gt; {
            // 2. 遍历用户取出标签信息
            String tagsStr = user.getTags();
            if (StringUtils.isEmpty(tagsStr)) {
                return false;
            }
            // 3. 在内存中判断是否包含要求标签
            Set&lt;String&gt; tempTagsNameSet = gson.fromJson(tagsStr, new TypeToken&lt;Set&lt;String&gt;&gt;(){}.getType());
            for (String tagName : tagNameList) {
                if (!tempTagsNameSet.contains(tagName)) {// 用户标签不包含所要求的标签
                    return false;
                }
            }
            return true;
        }).map(this::getSafetyUser).collect(Collectors.toList());
    }</code></pre> 
<p>3. Junit 单元测试</p> 
<p><img alt="" height="1018" src="https://images2.imgbox.com/1e/a2/iIfMEjJs_o.png" width="1200"></p> 
<p>4. 判断两种方式的效率</p> 
<ul><li>通过实际测试（计算）两种方法的运行时间来分析</li><li>数据量大时效果更明显</li></ul> 
<p>5. <strong>思路扩展：</strong>如果两种查询不相上下，时而 SQL 查询快，时而内存查询快，如何选择？</p> 
<ul><li>如果参数可以分析，可以<strong>根据用户的参数</strong>（比如搜索标签的数目）来选择适合的查询方式</li><li>如果参数不可分析，且数据库连接足够，内存空间足够，可以<strong>并发使用两种方式同时查询</strong>，哪种方式<strong>先返回</strong>数据就用谁的数据</li><li><strong>SQL 查询与内存运算相结合</strong>，先用 SQL 过滤一部分用户：例如要查询包含 "java" 等几十个标签用户，可以先使用 "java" 标签进行过滤，只剩下包含 "java" 标签的用户，再到内存中计算用户的其他标签</li></ul> 
<p></p> 
<h2>序列化和反序列化</h2> 
<p>1. 序列化和反序列化：将<strong>对象转换为字节流</strong>以便在网络中进行传输和存储的过程</p> 
<ul><li>序列化：将 Java 对象转为 JSON 字符串</li><li>反序列化：将 JSON 字符串转为 Java 对象</li></ul> 
<p>2. 几种 JSON 序列化库</p> 
<ul><li>fastjson（ali 出品）</li><li>gson（google 的，推荐）✔（本文使用方式）</li><li>jackson</li><li>kryo</li><li>hutool 工具中的 JSONUtil  
  <ul><li>引入依赖</li><li>序列化：JSONUtil.toBean(json, Object.class); 这里不适用，需要指定一个 Java 对象的字节码类型，但是我们的 tags 不是一个 Java 对象</li><li>反序列化：JSONUtil.toJsonStr(obj);</li></ul></li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/28435a2dc511c67a5a7e31f09f93bf75/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">开源云真机平台-Sonic平台-python自定义脚本-config.json方式实现全局配置参数的读写操作</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0b49c68536202d8e33479302a4489fe5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">边缘计算发展的瓶颈</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>